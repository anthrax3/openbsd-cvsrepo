head	1.29;
access;
symbols
	OPENBSD_5_7:1.28.0.18
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.22
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.20
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.16
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.14
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.10
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.12
	OPENBSD_5_0:1.28.0.8
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.6
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.22.0.18
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.16
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.14
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.12
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.10
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.8
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.6
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.4
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.19.0.4
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.21
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.06.19.11.12.24;	author jmatthew;	state dead;
branches;
next	1.28;
commitid	I5HMIEQiHPSVn0jd;

1.28
date	2010.02.18.10.40.53;	author sobrado;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.02.03.17.22;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2008.10.25.22.18.10;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.03.18.37.25;	author mjacob;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.17.17.40.26;	author mjacob;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.17.01.36.35;	author mjacob;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.14.00.20.55;	author mjacob;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.10.06.22.45.52;	author mjacob;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.01.07.16.40;	author mjacob;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.04.22.09.39;	author mjacob;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.12.23.51.20;	author mjacob;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.09.03.29.32;	author mjacob;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.06.01.07.23;	author mjacob;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.16.01.02.01;	author mjacob;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.06.05.31.49;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.06.05.47.00;	author mjacob;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.20.21.22.41;	author mjacob;	state Exp;
branches;
next	1.8;

1.8
date	99.12.16.05.20.53;	author mjacob;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.11.22.12.50.53;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	99.04.04.02.07.27;	author mjacob;	state Exp;
branches;
next	1.5;

1.5
date	99.04.04.01.28.26;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	99.03.25.22.58.39;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	99.03.17.12.54.32;	author mjacob;	state Exp;
branches;
next	1.2;

1.2
date	99.03.17.05.26.09;	author mjacob;	state Exp;
branches;
next	1.1;

1.1
date	98.03.24.03.26.10;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2000.02.21.22.29.06;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.05.14.22.23.58;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2003.05.19.21.54.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@remove isp(4) now that the ql* family have replaced it
@
text
@/*     $OpenBSD: ispvar.h,v 1.28 2010/02/18 10:40:53 sobrado Exp $ */
/* $FreeBSD: src/sys/dev/isp/ispvar.h,v 1.85 2007/07/02 20:08:20 mjacob Exp $ */
/*-
 *  Copyright (c) 1997-2007 by Matthew Jacob
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 * 
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 *  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 */
/*
 * Soft Definitions for for QLogic ISP SCSI adapters.
 */

#ifndef	_ISPVAR_H
#define	_ISPVAR_H

#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <dev/ic/isp_stds.h>
#include <dev/ic/ispmbox.h>
#endif
#ifdef	__FreeBSD__
#include <dev/isp/isp_stds.h>
#include <dev/isp/ispmbox.h>
#endif
#ifdef	__linux__
#include "isp_stds.h"
#include "ispmbox.h"
#endif
#ifdef	__svr4__
#include "isp_stds.h"
#include "ispmbox.h"
#endif

#define	ISP_CORE_VERSION_MAJOR	3
#define	ISP_CORE_VERSION_MINOR	0

/*
 * Vector for bus specific code to provide specific services.
 */
typedef struct ispsoftc ispsoftc_t;
struct ispmdvec {
	int		(*dv_rd_isr)
	    (struct ispsoftc *, u_int32_t *, u_int16_t *, u_int16_t *);
	u_int32_t	(*dv_rd_reg) (struct ispsoftc *, int);
	void		(*dv_wr_reg) (struct ispsoftc *, int, u_int32_t);
	int		(*dv_mbxdma) (struct ispsoftc *);
	int		(*dv_dmaset)
	    (struct ispsoftc *, XS_T *, ispreq_t *, u_int32_t *, u_int32_t);
	void		(*dv_dmaclr) (struct ispsoftc *, XS_T *, u_int32_t);
	void		(*dv_reset0) (struct ispsoftc *);
	void		(*dv_reset1) (struct ispsoftc *);
	void		(*dv_dregs) (struct ispsoftc *, const char *);
	const void *	dv_ispfw;	/* ptr to f/w */
	u_int16_t	dv_conf1;
	u_int16_t	dv_clock;	/* clock frequency */
};

/*
 * Overall parameters
 */
#define	MAX_TARGETS		16
#define	MAX_FC_TARG		512
#define	ISP_MAX_TARGETS(isp)	(IS_FC(isp)? MAX_FC_TARG : MAX_TARGETS)
#define	ISP_MAX_LUNS(isp)	(isp)->isp_maxluns

/*
 * Macros to access ISP registers through bus specific layers-
 * mostly wrappers to vector through the mdvec structure.
 */
#define	ISP_READ_ISR(isp, isrp, semap, mbox0p)	\
	(*(isp)->isp_mdvec->dv_rd_isr)(isp, isrp, semap, mbox0p)

#define	ISP_READ(isp, reg)	\
	(*(isp)->isp_mdvec->dv_rd_reg)((isp), (reg))

#define	ISP_WRITE(isp, reg, val)	\
	(*(isp)->isp_mdvec->dv_wr_reg)((isp), (reg), (val))

#define	ISP_MBOXDMASETUP(isp)	\
	(*(isp)->isp_mdvec->dv_mbxdma)((isp))

#define	ISP_DMASETUP(isp, xs, req, iptrp, optr)	\
	(*(isp)->isp_mdvec->dv_dmaset)((isp), (xs), (req), (iptrp), (optr))

#define	ISP_DMAFREE(isp, xs, hndl)		\
	if ((isp)->isp_mdvec->dv_dmaclr)	\
	    (*(isp)->isp_mdvec->dv_dmaclr)((isp), (xs), (hndl))

#define	ISP_RESET0(isp)	\
	if ((isp)->isp_mdvec->dv_reset0) (*(isp)->isp_mdvec->dv_reset0)((isp))
#define	ISP_RESET1(isp)	\
	if ((isp)->isp_mdvec->dv_reset1) (*(isp)->isp_mdvec->dv_reset1)((isp))
#define	ISP_DUMPREGS(isp, m)	\
	if ((isp)->isp_mdvec->dv_dregs) (*(isp)->isp_mdvec->dv_dregs)((isp),(m))

#define	ISP_SETBITS(isp, reg, val)	\
 (*(isp)->isp_mdvec->dv_wr_reg)((isp), (reg), ISP_READ((isp), (reg)) | (val))

#define	ISP_CLRBITS(isp, reg, val)	\
 (*(isp)->isp_mdvec->dv_wr_reg)((isp), (reg), ISP_READ((isp), (reg)) & ~(val))

/*
 * The MEMORYBARRIER macro is defined per platform (to provide synchronization
 * on Request and Response Queues, Scratch DMA areas, and Registers)
 *
 * Defined Memory Barrier Synchronization Types
 */
#define	SYNC_REQUEST	0	/* request queue synchronization */
#define	SYNC_RESULT	1	/* result queue synchronization */
#define	SYNC_SFORDEV	2	/* scratch, sync for ISP */
#define	SYNC_SFORCPU	3	/* scratch, sync for CPU */
#define	SYNC_REG	4	/* for registers */
#define	SYNC_ATIOQ	5	/* atio result queue (24xx) */

/*
 * Request/Response Queue defines and macros.
 * The maximum is defined per platform (and can be based on board type).
 */
/* This is the size of a queue entry (request and response) */
#define	QENTRY_LEN			64
/* Both request and result queue length must be a power of two */
#define	RQUEST_QUEUE_LEN(x)		MAXISPREQUEST(x)
#ifdef	ISP_TARGET_MODE
#define	RESULT_QUEUE_LEN(x)		MAXISPREQUEST(x)
#else
#define	RESULT_QUEUE_LEN(x)		\
	(((MAXISPREQUEST(x) >> 2) < 64)? 64 : MAXISPREQUEST(x) >> 2)
#endif
#define	ISP_QUEUE_ENTRY(q, idx)		(((u_int8_t *)q) + ((idx) * QENTRY_LEN))
#define	ISP_QUEUE_SIZE(n)		((n) * QENTRY_LEN)
#define	ISP_NXT_QENTRY(idx, qlen)	(((idx) + 1) & ((qlen)-1))
#define	ISP_QFREE(in, out, qlen)	\
	((in == out)? (qlen - 1) : ((in > out)? \
	((qlen - 1) - (in - out)) : (out - in - 1)))
#define	ISP_QAVAIL(isp)	\
	ISP_QFREE(isp->isp_reqidx, isp->isp_reqodx, RQUEST_QUEUE_LEN(isp))

#define	ISP_ADD_REQUEST(isp, nxti)					\
	MEMORYBARRIER(isp, SYNC_REQUEST, isp->isp_reqidx, QENTRY_LEN);	\
	ISP_WRITE(isp, isp->isp_rqstinrp, nxti);			\
	isp->isp_reqidx = nxti

/*
 * SCSI Specific Host Adapter Parameters- per bus, per target
 */
typedef struct {
	u_int32_t 				: 10,
			isp_bad_nvram		: 1,
			isp_gotdparms		: 1,
			isp_req_ack_active_neg	: 1,
			isp_data_line_active_neg: 1,
			isp_cmd_dma_burst_enable: 1,
			isp_data_dma_burst_enabl: 1,
			isp_fifo_threshold	: 3,
			isp_ptisp		: 1,
			isp_ultramode		: 1,
			isp_diffmode		: 1,
			isp_lvdmode		: 1,
			isp_fast_mttr		: 1,	/* fast sram */
			isp_initiator_id	: 4,
			isp_async_data_setup	: 4;
	u_int16_t	isp_selection_timeout;
	u_int16_t	isp_max_queue_depth;
	u_int8_t	isp_tag_aging;
	u_int8_t	isp_bus_reset_delay;
	u_int8_t	isp_retry_count;
	u_int8_t	isp_retry_delay;
	struct {
		u_int32_t	
			exc_throttle	:	8,
					:	1,
			dev_enable	:	1,	/* ignored */
			dev_update	:	1,
			dev_refresh	:	1,
			actv_offset	:	4,
			goal_offset	:	4,
			nvrm_offset	:	4;
		u_int8_t	actv_period;	/* current sync period */
		u_int8_t	goal_period;	/* goal sync period */
		u_int8_t	nvrm_period;	/* nvram sync period */
		u_int16_t	actv_flags;	/* current device flags */
		u_int16_t	goal_flags;	/* goal device flags */
		u_int16_t	nvrm_flags;	/* nvram device flags */
	} isp_devparam[MAX_TARGETS];
} sdparam;

/*
 * Device Flags
 */
#define	DPARM_DISC	0x8000
#define	DPARM_PARITY	0x4000
#define	DPARM_WIDE	0x2000
#define	DPARM_SYNC	0x1000
#define	DPARM_TQING	0x0800
#define	DPARM_ARQ	0x0400
#define	DPARM_QFRZ	0x0200
#define	DPARM_RENEG	0x0100
#define	DPARM_NARROW	0x0080
#define	DPARM_ASYNC	0x0040
#define	DPARM_PPR	0x0020
#define	DPARM_DEFAULT	(0xFF00 & ~DPARM_QFRZ)
#define	DPARM_SAFE_DFLT	(DPARM_DEFAULT & ~(DPARM_WIDE|DPARM_SYNC|DPARM_TQING))

/* technically, not really correct, as they need to be rated based upon clock */
#define	ISP_80M_SYNCPARMS	0x0c09
#define	ISP_40M_SYNCPARMS	0x0c0a
#define	ISP_20M_SYNCPARMS	0x0c0c
#define	ISP_20M_SYNCPARMS_1040	0x080c
#define	ISP_10M_SYNCPARMS	0x0c19
#define	ISP_08M_SYNCPARMS	0x0c25
#define	ISP_05M_SYNCPARMS	0x0c32
#define	ISP_04M_SYNCPARMS	0x0c41

/*
 * Fibre Channel Specifics
 */
/* These are for non-2K Login Firmware cards */
#define	FL_ID			0x7e	/* FL_Port Special ID */
#define	SNS_ID			0x80	/* SNS Server Special ID */
#define	NPH_MAX			0xfe

/* These are for 2K Login Firmware cards */
#define	NPH_RESERVED		0x7F0	/* begin of reserved N-port handles */
#define	NPH_MGT_ID		0x7FA	/* Management Server Special ID */
#define	NPH_SNS_ID		0x7FC	/* SNS Server Special ID */
#define	NPH_FL_ID		0x7FE	/* FL Port Special ID */
#define	NPH_MAX_2K		0x800

/*
 * "Unassigned" handle to be used internally
 */
#define	NIL_HANDLE		0xffff

/*
 * Limit for devices on an arbitrated loop.
 */
#define	LOCAL_LOOP_LIM		126

/*
 * Special Port IDs
 */
#define	MANAGEMENT_PORT_ID	0xFFFFFA
#define	SNS_PORT_ID		0xFFFFFC
#define	FABRIC_PORT_ID		0xFFFFFE


/*
 * FC Port Database entry.
 *
 * It has a handle that the f/w uses to address commands to a device.
 * This handle's value may be assigned by the firmware (e.g., for local loop
 * devices) or by the driver (e.g., for fabric devices).
 *
 * It has a state. If the state if VALID, that means that we've logged into
 * the device. We also *may* have a initiator map index entry. This is a value
 * from 0..MAX_FC_TARG that is used to index into the isp_ini_map array. If
 * the value therein is non-zero, then that value minus one is used to index
 * into the Port Database to find the handle for forming commands. There is
 * back-index minus one value within to Port Database entry that tells us 
 * which entry in isp_ini_map points to us (to avoid searching).
 *
 * Local loop devices the firmware automatically performs PLOGI on for us
 * (which is why that handle is imposed upon us). Fabric devices we assign
 * a handle to and perform the PLOGI on.
 *
 * When a PORT DATABASE CHANGED asynchronous event occurs, we mark all VALID
 * entries as PROBATIONAL. This allows us, if policy says to, just keep track
 * of devices whose handles change but are otherwise the same device (and
 * thus keep 'target' constant).
 *
 * In any case, we search all possible local loop handles. For each one that
 * has a port database entity returned, we search for any PROBATIONAL entry
 * that matches it and update as appropriate. Otherwise, as a new entry, we
 * find room for it in the Port Database. We *try* and use the handle as the
 * index to put it into the Database, but that's just an optimization. We mark
 * the entry VALID and make sure that the target index is updated and correct.
 *
 * When we get done searching the local loop, we then search similarily for
 * a list of devices we've gotten from the fabric name controller (if we're
 * on a fabric). VALID marking is also done similarily.
 *
 * When all of this is done, we can march through the database and clean up
 * any entry that is still PROBATIONAL (these represent devices which have
 * departed). Then we're done and can resume normal operations.
 *
 * Negative invariants that we try and test for are:
 *
 *  + There can never be two non-NIL entries with the same { Port, Node } WWN
 *    duples.
 *
 *  + There can never be two non-NIL entries with the same handle.
 *
 *  + There can never be two non-NIL entries which have the same ini_map_idx
 *    value.
 */
typedef struct {
	/*
	 * This is the handle that the firmware needs in order for us to
	 * send commands to the device. For pre-24XX cards, this would be
	 * the 'loopid'.
	 */
	u_int16_t	handle;
	/*
	 * The ini_map_idx, if nonzero, is the system virtual target ID (+1)
	 * as a cross-reference with the isp_ini_map.
	 *
	 * A device is 'autologin' if the firmware automatically logs into
	 * it (re-logins as needed). Basically, local private loop devices.
	 *
	 * The state is the current state of thsi entry.
	 *
	 * Role is Initiator, Target, Both
	 *
	 * Portid is obvious, as or node && port WWNs. The new_role and
	 * new_portid is for when we are pending a change.
	 */
	u_int16_t	ini_map_idx	: 12,
			autologin	: 1,	/* F/W does PLOGI/PLOGO */
			state		: 3;
	u_int32_t	reserved	: 6,
			roles		: 2,
			portid		: 24;
	u_int32_t	new_reserved	: 6,
			new_roles	: 2,
			new_portid	: 24;
	u_int64_t	node_wwn;
	u_int64_t	port_wwn;
} fcportdb_t;

#define	FC_PORTDB_STATE_NIL		0
#define	FC_PORTDB_STATE_PROBATIONAL	1
#define	FC_PORTDB_STATE_DEAD		2
#define	FC_PORTDB_STATE_CHANGED		3
#define	FC_PORTDB_STATE_NEW		4
#define	FC_PORTDB_STATE_PENDING_VALID	5
#define	FC_PORTDB_STATE_ZOMBIE		6
#define	FC_PORTDB_STATE_VALID		7

/*
 * FC card specific information
 */
typedef struct {
	u_int32_t				: 10,
				isp_tmode	: 1,
				isp_2klogin	: 1,
				isp_sccfw	: 1,
				isp_gbspeed	: 3,
						: 1,
						: 1,
				isp_gotdparms	: 1,
				isp_bad_nvram	: 1,
				isp_loopstate	: 4,	/* Current Loop State */
				isp_fwstate	: 4,	/* ISP F/W state */
				isp_topo	: 3,
				loop_seen_once	: 1;
	u_int32_t				: 8,
				isp_portid	: 24;	/* S_ID */
	u_int16_t		isp_fwoptions;
	u_int16_t		isp_xfwoptions;
	u_int16_t		isp_zfwoptions;
	u_int16_t		isp_loopid;	/* hard loop id */
	u_int16_t		isp_fwattr;	/* firmware attributes */
	u_int16_t		isp_execthrottle;
	u_int8_t		isp_retry_delay;
	u_int8_t		isp_retry_count;
	u_int8_t		isp_reserved;
	u_int16_t		isp_maxalloc;
	u_int16_t		isp_maxfrmlen;
	u_int64_t		isp_wwnn_nvram;
	u_int64_t		isp_wwpn_nvram;

	/*
	 * Our Port Data Base
	 */
	fcportdb_t		portdb[MAX_FC_TARG];

	/*
	 * This maps system virtual 'target' id to a portdb entry.
	 *
	 * The mapping function is to take any non-zero entry and
	 * subtract one to get the portdb index. This means that
	 * entries which are zero are unmapped (i.e., don't exist).
	 */
	u_int16_t		isp_ini_map[MAX_FC_TARG];

	/*
	 * Scratch DMA mapped in area to fetch Port Database stuff, etc.
	 */
	void *			isp_scratch;
	XS_DMA_ADDR_T		isp_scdma;
#ifdef	ISP_FW_CRASH_DUMP
	u_int16_t *		isp_dump_data;
#endif
} fcparam;

#define	FW_CONFIG_WAIT		0
#define	FW_WAIT_AL_PA		1
#define	FW_WAIT_LOGIN		2
#define	FW_READY		3
#define	FW_LOSS_OF_SYNC		4
#define	FW_ERROR		5
#define	FW_REINIT		6
#define	FW_NON_PART		7

#define	LOOP_NIL		0
#define	LOOP_LIP_RCVD		1
#define	LOOP_PDB_RCVD		2
#define	LOOP_SCANNING_LOOP	3
#define	LOOP_LSCAN_DONE		4
#define	LOOP_SCANNING_FABRIC	5
#define	LOOP_FSCAN_DONE		6
#define	LOOP_SYNCING_PDB	7
#define	LOOP_READY		8

#define	TOPO_NL_PORT		0
#define	TOPO_FL_PORT		1
#define	TOPO_N_PORT		2
#define	TOPO_F_PORT		3
#define	TOPO_PTP_STUB		4

/*
 * Soft Structure per host adapter
 */
struct ispsoftc {
	/*
	 * Platform (OS) specific data
	 */
	struct isposinfo	isp_osinfo;

	/*
	 * Pointer to bus specific functions and data
	 */
	struct ispmdvec *	isp_mdvec;

	/*
	 * (Mostly) nonvolatile state. Board specific parameters
	 * may contain some volatile state (e.g., current loop state).
	 */

	void * 			isp_param;	/* type specific */
	u_int16_t		isp_fwrev[3];	/* Loaded F/W revision */
	u_int16_t		isp_romfw_rev[3]; /* PROM F/W revision */
	u_int16_t		isp_maxcmds;	/* max possible I/O cmds */
	u_int8_t		isp_type;	/* HBA Chip Type */
	u_int8_t		isp_revision;	/* HBA Chip H/W Revision */
	u_int32_t		isp_maxluns;	/* maximum luns supported */

	u_int32_t		isp_clock	: 8,	/* input clock */
						: 4,
				isp_port	: 1,	/* 23XX/24XX only */
				isp_failed	: 1,	/* board failed */
				isp_open	: 1,	/* opened (ioctl) */
				isp_touched	: 1,	/* board ever seen? */
				isp_bustype	: 1,	/* SBus or PCI */
				isp_loaded_fw	: 1,	/* loaded firmware */
				isp_role	: 2,	/* roles supported */
				isp_dblev	: 12;	/* debug log mask */

	u_int32_t		isp_confopts;		/* config options */

	u_int32_t		isp_rqstinrp;	/* register for REQINP */
	u_int32_t		isp_rqstoutrp;	/* register for REQOUTP */
	u_int32_t		isp_respinrp;	/* register for RESINP */
	u_int32_t		isp_respoutrp;	/* register for RESOUTP */
	u_int32_t		isp_atioinrp;	/* register for ATIOINP */
	u_int32_t		isp_atiooutrp;	/* register for ATIOOUTP */

	/*
	 * Instrumentation
	 */
	u_int64_t		isp_intcnt;		/* total int count */
	u_int64_t		isp_intbogus;		/* spurious int count */
	u_int64_t		isp_intmboxc;		/* mbox completions */
	u_int64_t		isp_intoasync;		/* other async */
	u_int64_t		isp_rsltccmplt;		/* CMDs on result q */
	u_int64_t		isp_fphccmplt;		/* CMDs via fastpost */
	u_int16_t		isp_rscchiwater;
	u_int16_t		isp_fpcchiwater;

	/*
	 * Volatile state
	 */

	volatile u_int32_t	:	8,
		isp_mboxbsy	:	1,	/* mailbox command active */
		isp_state	:	3,
		isp_sendmarker	:	2,	/* send a marker entry */
		isp_update	:	2,	/* update parameters */
		isp_nactive	:	16;	/* how many commands active */
	volatile u_int32_t	isp_reqodx;	/* index of last ISP pickup */
	volatile u_int32_t	isp_reqidx;	/* index of next request */
	volatile u_int32_t	isp_residx;	/* index of next result */
	volatile u_int32_t	isp_resodx;	/* index of next result */
	volatile u_int32_t	isp_rspbsy;
	volatile u_int32_t	isp_lasthdls;	/* last handle seed */
	volatile u_int32_t	isp_obits;	/* mailbox command output */
	volatile u_int16_t	isp_mboxtmp[MAILBOX_STORAGE];
	volatile u_int16_t	isp_lastmbxcmd;	/* last mbox command sent */
	volatile u_int16_t	isp_mbxwrk0;
	volatile u_int16_t	isp_mbxwrk1;
	volatile u_int16_t	isp_mbxwrk2;
	volatile u_int16_t	isp_mbxwrk8;
	void *			isp_mbxworkp;

	/*
	 * Active commands are stored here, indexed by handle functions.
	 */
	XS_T **isp_xflist;

#ifdef	ISP_TARGET_MODE
	/*
	 * Active target commands are stored here, indexed by handle function.
	 */
	void **isp_tgtlist;
#endif

	/*
	 * request/result queue pointers and DMA handles for them.
	 */
	void *			isp_rquest;
	void *			isp_result;
	XS_DMA_ADDR_T		isp_rquest_dma;
	XS_DMA_ADDR_T		isp_result_dma;
#ifdef	ISP_TARGET_MODE
	/* for 24XX only */
	void *			isp_atioq;
	XS_DMA_ADDR_T		isp_atioq_dma;
#endif
};

#define	SDPARAM(isp)	((sdparam *) (isp)->isp_param)
#define	FCPARAM(isp)	((fcparam *) (isp)->isp_param)

/*
 * ISP Driver Run States
 */
#define	ISP_NILSTATE	0
#define	ISP_CRASHED	1
#define	ISP_RESETSTATE	2
#define	ISP_INITSTATE	3
#define	ISP_RUNSTATE	4

/*
 * ISP Configuration Options
 */
#define	ISP_CFG_NORELOAD	0x80	/* don't download f/w */
#define	ISP_CFG_NONVRAM		0x40	/* ignore NVRAM */
#define	ISP_CFG_TWOGB		0x20	/* force 2GB connection (23XX only) */
#define	ISP_CFG_ONEGB		0x10	/* force 1GB connection (23XX only) */
#define	ISP_CFG_FULL_DUPLEX	0x01	/* Full Duplex (Fibre Channel only) */
#define	ISP_CFG_PORT_PREF	0x0C	/* Mask for Port Prefs (2200 only) */
#define	ISP_CFG_LPORT		0x00	/* prefer {N/F}L-Port connection */
#define	ISP_CFG_NPORT		0x04	/* prefer {N/F}-Port connection */
#define	ISP_CFG_NPORT_ONLY	0x08	/* insist on {N/F}-Port connection */
#define	ISP_CFG_LPORT_ONLY	0x0C	/* insist on {N/F}L-Port connection */
#define	ISP_CFG_OWNWWPN		0x100	/* override NVRAM wwpn */
#define	ISP_CFG_OWNWWNN		0x200	/* override NVRAM wwnn */
#define	ISP_CFG_OWNFSZ		0x400	/* override NVRAM frame size */
#define	ISP_CFG_OWNLOOPID	0x800	/* override NVRAM loopid */
#define	ISP_CFG_OWNEXCTHROTTLE	0x1000	/* override NVRAM execution throttle */
#define	ISP_CFG_FOURGB		0x2000	/* force 4GB connection (24XX only) */

/*
 * Prior to calling isp_reset for the first time, the outer layer
 * should set isp_role to one of NONE, INITIATOR, TARGET, BOTH.
 *
 * If you set ISP_ROLE_NONE, the cards will be reset, new firmware loaded,
 * NVRAM read, and defaults set, but any further initialization (e.g.
 * INITIALIZE CONTROL BLOCK commands for 2X00 cards) won't be done.
 *
 * If INITIATOR MODE isn't set, attempts to run commands will be stopped
 * at isp_start and completed with the moral equivalent of SELECTION TIMEOUT.
 *
 * If TARGET MODE is set, it doesn't mean that the rest of target mode support
 * needs to be enabled, or will even work. What happens with the 2X00 cards
 * here is that if you have enabled it with TARGET MODE as part of the ICB
 * options, but you haven't given the f/w any ram resources for ATIOs or
 * Immediate Notifies, the f/w just handles what it can and you never see
 * anything. Basically, it sends a single byte of data (the first byte,
 * which you can set as part of the INITIALIZE CONTROL BLOCK command) for
 * INQUIRY, and sends back QUEUE FULL status for any other command.
 *
 */
#define	ISP_ROLE_NONE		0x0
#define	ISP_ROLE_TARGET		0x1
#define	ISP_ROLE_INITIATOR	0x2
#define	ISP_ROLE_BOTH		(ISP_ROLE_TARGET|ISP_ROLE_INITIATOR)
#define	ISP_ROLE_EITHER		ISP_ROLE_BOTH
#ifndef	ISP_DEFAULT_ROLES
#define	ISP_DEFAULT_ROLES	ISP_ROLE_INITIATOR
#endif


/*
 * Firmware related defines
 */
#define	ISP_CODE_ORG			0x1000	/* default f/w code start */
#define	ISP_CODE_ORG_2300		0x0800	/* ..except for 2300s */
#define	ISP_CODE_ORG_2400		0x100000 /* ..and 2400s */
#define	ISP_FW_REV(maj, min, mic)	((maj << 24) | (min << 16) | mic)
#define	ISP_FW_MAJOR(code)		((code >> 24) & 0xff)
#define	ISP_FW_MINOR(code)		((code >> 16) & 0xff)
#define	ISP_FW_MICRO(code)		((code >>  8) & 0xff)
#define	ISP_FW_REVX(xp)			((xp[0]<<24) | (xp[1] << 16) | xp[2])
#define	ISP_FW_MAJORX(xp)		(xp[0])
#define	ISP_FW_MINORX(xp)		(xp[1])
#define	ISP_FW_MICROX(xp)		(xp[2])
#define	ISP_FW_NEWER_THAN(i, major, minor, micro)		\
 (ISP_FW_REVX((i)->isp_fwrev) > ISP_FW_REV(major, minor, micro))
#define	ISP_FW_OLDER_THAN(i, major, minor, micro)		\
 (ISP_FW_REVX((i)->isp_fwrev) < ISP_FW_REV(major, minor, micro))

/*
 * Bus (implementation) types
 */
#define	ISP_BT_PCI		0	/* PCI Implementations */
#define	ISP_BT_SBUS		1	/* SBus Implementations */

/*
 * If we have not otherwise defined SBus support away make sure
 * it is defined here such that the code is included as default
 */
#ifndef	ISP_SBUS_SUPPORTED
#define	ISP_SBUS_SUPPORTED	1
#endif

/*
 * Chip Types
 */
#define	ISP_HA_SCSI		0xf
#define	ISP_HA_SCSI_UNKNOWN	0x1
#define	ISP_HA_SCSI_1020	0x2
#define	ISP_HA_SCSI_1020A	0x3
#define	ISP_HA_SCSI_1040	0x4
#define	ISP_HA_SCSI_1040A	0x5
#define	ISP_HA_SCSI_1040B	0x6
#define	ISP_HA_SCSI_1040C	0x7
#define	ISP_HA_SCSI_1240	0x8
#define	ISP_HA_SCSI_1080	0x9
#define	ISP_HA_SCSI_1280	0xa
#define	ISP_HA_SCSI_10160	0xb
#define	ISP_HA_SCSI_12160	0xc
#define	ISP_HA_FC		0xf0
#define	ISP_HA_FC_2100		0x10
#define	ISP_HA_FC_2200		0x20
#define	ISP_HA_FC_2300		0x30
#define	ISP_HA_FC_2312		0x40
#define	ISP_HA_FC_2322		0x50
#define	ISP_HA_FC_2400		0x60

#define	IS_SCSI(isp)	(isp->isp_type & ISP_HA_SCSI)
#define	IS_1240(isp)	(isp->isp_type == ISP_HA_SCSI_1240)
#define	IS_1080(isp)	(isp->isp_type == ISP_HA_SCSI_1080)
#define	IS_1280(isp)	(isp->isp_type == ISP_HA_SCSI_1280)
#define	IS_10160(isp)	(isp->isp_type == ISP_HA_SCSI_10160)
#define	IS_12160(isp)	(isp->isp_type == ISP_HA_SCSI_12160)

#define	IS_12X0(isp)	(IS_1240(isp) || IS_1280(isp))
#define	IS_1X160(isp)	(IS_10160(isp) || IS_12160(isp))
#define	IS_DUALBUS(isp)	(IS_12X0(isp) || IS_12160(isp))
#define	IS_ULTRA2(isp)	(IS_1080(isp) || IS_1280(isp) || IS_1X160(isp))
#define	IS_ULTRA3(isp)	(IS_1X160(isp))

#define	IS_FC(isp)	((isp)->isp_type & ISP_HA_FC)
#define	IS_2100(isp)	((isp)->isp_type == ISP_HA_FC_2100)
#define	IS_2200(isp)	((isp)->isp_type == ISP_HA_FC_2200)
#define	IS_23XX(isp)	((isp)->isp_type >= ISP_HA_FC_2300 && \
				(isp)->isp_type < ISP_HA_FC_2400)
#define	IS_2300(isp)	((isp)->isp_type == ISP_HA_FC_2300)
#define	IS_2312(isp)	((isp)->isp_type == ISP_HA_FC_2312)
#define	IS_2322(isp)	((isp)->isp_type == ISP_HA_FC_2322)
#define	IS_24XX(isp)	((isp)->isp_type >= ISP_HA_FC_2400)

/*
 * DMA related macros
 */
#define	DMA_WD3(x)	(((u_int16_t)(((u_int64_t)x) >> 48)) & 0xffff)
#define	DMA_WD2(x)	(((u_int16_t)(((u_int64_t)x) >> 32)) & 0xffff)
#define	DMA_WD1(x)	((u_int16_t)((x) >> 16) & 0xffff)
#define	DMA_WD0(x)	((u_int16_t)((x) & 0xffff))

#define	DMA_LO32(x)	((u_int32_t) (x))
#define	DMA_HI32(x)	((u_int32_t)(((u_int64_t)x) >> 32))

/*
 * Core System Function Prototypes
 */

/*
 * Reset Hardware. Totally. Assumes that you'll follow this with
 * a call to isp_init.
 */
void isp_reset(struct ispsoftc *);

/*
 * Initialize Hardware to known state
 */
void isp_init(struct ispsoftc *);

/*
 * Reset the ISP and call completion for any orphaned commands.
 */
void isp_reinit(struct ispsoftc *);

#ifdef	ISP_FW_CRASH_DUMP
/*
 * Dump firmware entry point.
 */
void isp_fw_dump(struct ispsoftc *isp);
#endif

/*
 * Internal Interrupt Service Routine
 *
 * The outer layers do the spade work to get the appropriate status register,
 * semaphore register and first mailbox register (if appropriate). This also
 * means that most spurious/bogus interrupts not for us can be filtered first.
 */
void isp_intr(struct ispsoftc *, u_int32_t, u_int16_t, u_int16_t);


/*
 * Command Entry Point- Platform Dependent layers call into this
 */
int isp_start(XS_T *);

/* these values are what isp_start returns */
#define	CMD_COMPLETE	101	/* command completed */
#define	CMD_EAGAIN	102	/* busy- maybe retry later */
#define	CMD_QUEUED	103	/* command has been queued for execution */
#define	CMD_RQLATER 	104	/* requeue this command later */

/*
 * Command Completion Point- Core layers call out from this with completed cmds
 */
void isp_done(XS_T *);

/*
 * Platform Dependent to External to Internal Control Function
 *
 * Assumes locks are held on entry. You should note that with many of
 * these commands and locks may be released while this is occurring.
 *
 * A few notes about some of these functions:
 *
 * ISPCTL_FCLINK_TEST tests to make sure we have good fibre channel link.
 * The argument is a pointer to an integer which is the time, in microseconds,
 * we should wait to see whether we have good link. This test, if successful,
 * lets us know our connection topology and our Loop ID/AL_PA and so on.
 * You can't get anywhere without this.
 *
 * ISPCTL_SCAN_FABRIC queries the name server (if we're on a fabric) for
 * all entities using the FC Generic Services subcommand GET ALL NEXT.
 * For each found entity, an ISPASYNC_FABRICDEV event is generated (see
 * below).
 *
 * ISPCTL_SCAN_LOOP does a local loop scan. This is only done if the connection
 * topology is NL or FL port (private or public loop). Since the QLogic f/w
 * 'automatically' manages local loop connections, this function essentially
 * notes the arrival, departure, and possible shuffling around of local loop
 * entities. Thus for each arrival and departure this generates an isp_async
 * event of ISPASYNC_PROMENADE (see below).
 *
 * ISPCTL_PDB_SYNC is somewhat misnamed. It actually is the final step, in
 * order, of ISPCTL_FCLINK_TEST, ISPCTL_SCAN_FABRIC, and ISPCTL_SCAN_LOOP.
 * The main purpose of ISPCTL_PDB_SYNC is to complete management of logging
 * and logging out of fabric devices (if one is on a fabric) and then marking
 * the 'loop state' as being ready to now be used for sending commands to
 * devices. Originally fabric name server and local loop scanning were
 * part of this function. It's now been separated to allow for finer control.
 */
typedef enum {
	ISPCTL_RESET_BUS,		/* Reset Bus */
	ISPCTL_RESET_DEV,		/* Reset Device */
	ISPCTL_ABORT_CMD,		/* Abort Command */
	ISPCTL_UPDATE_PARAMS,		/* Update Operating Parameters (SCSI) */
	ISPCTL_FCLINK_TEST,		/* Test FC Link Status */
	ISPCTL_SCAN_FABRIC,		/* (Re)scan Fabric Name Server */
	ISPCTL_SCAN_LOOP,		/* (Re)scan Local Loop */
	ISPCTL_PDB_SYNC,		/* Synchronize Port Database */
	ISPCTL_SEND_LIP,		/* Send a LIP */
	ISPCTL_GET_PORTNAME,		/* get portname from an N-port handle */
	ISPCTL_RUN_MBOXCMD,		/* run a mailbox command */
	ISPCTL_TOGGLE_TMODE,		/* toggle target mode */
	ISPCTL_GET_PDB,			/* get a single port database entry */
	ISPCTL_PLOGX			/* do a port login/logout */
} ispctl_t;
int isp_control(struct ispsoftc *, ispctl_t, void *);


/*
 * Platform Dependent to Internal to External Control Function
 * (each platform must provide such a function)
 *
 * Assumes locks are held.
 *
 * A few notes about some of these functions:
 *
 * ISPASYNC_CHANGE_NOTIFY notifies the outer layer that a change has
 * occurred that invalidates the list of fabric devices known and/or
 * the list of known loop devices. The argument passed is a pointer
 * whose values are defined below  (local loop change, name server
 * change, other). 'Other' may simply be a LIP, or a change in
 * connection topology.
 *
 * ISPASYNC_FABRIC_DEV announces the next element in a list of
 * fabric device names we're getting out of the name server. The
 * argument points to a GET ALL NEXT response structure. The list
 * is known to terminate with an entry that refers to ourselves.
 * One of the main purposes of this function is to allow outer
 * layers, which are OS dependent, to set policy as to which fabric
 * devices might actually be logged into (and made visible) later
 * at ISPCTL_PDB_SYNC time. Since there's a finite number of fabric
 * devices that we can log into (256 less 3 'reserved' for F-port
 * topologies), and fabrics can grow up to 8 million or so entries
 * (24 bits of Port Address, less a wad of reserved spaces), clearly
 * we had better let the OS determine login policy.
 *
 * ISPASYNC_PROMENADE has an argument that is a pointer to an integer which
 * is an index into the portdb in the softc ('target'). Whether that entry's
 * valid tag is set or not says whether something has arrived or departed.
 * The name refers to a favorite pastime of many city dwellers- watching
 * people come and go, talking of Michaelangelo, and so on..
 *
 * ISPASYNC_UNHANDLED_RESPONSE gives outer layers a chance to parse a
 * response queue entry not otherwise handled. The outer layer should
 * return non-zero if it handled it. The 'arg' points to an unmassaged
 * response queue entry.
 */

typedef enum {
	ISPASYNC_NEW_TGT_PARAMS,	/* New Target Parameters Negotiated */
	ISPASYNC_BUS_RESET,		/* Bus Was Reset */
	ISPASYNC_LOOP_DOWN,		/* FC Loop Down */
	ISPASYNC_LOOP_UP,		/* FC Loop Up */
	ISPASYNC_LIP,			/* LIP Received */
	ISPASYNC_LOOP_RESET,		/* Loop Reset Received */
	ISPASYNC_CHANGE_NOTIFY,		/* FC Change Notification */
	ISPASYNC_DEV_ARRIVED,		/* FC Device Arrival */
	ISPASYNC_DEV_CHANGED,		/* FC Device Change */
	ISPASYNC_DEV_STAYED,		/* FC Device Stayed the Same */
	ISPASYNC_DEV_GONE,		/* FC Device Depart */
	ISPASYNC_TARGET_NOTIFY,		/* target asynchronous notification event */
	ISPASYNC_TARGET_ACTION,		/* target action requested */
	ISPASYNC_CONF_CHANGE,		/* Platform Configuration Change */
	ISPASYNC_UNHANDLED_RESPONSE,	/* Unhandled Response Entry */
	ISPASYNC_FW_CRASH,		/* Firmware has crashed */
	ISPASYNC_FW_DUMPED,		/* Firmware crashdump taken */
	ISPASYNC_FW_RESTARTED		/* Firmware has been restarted */
} ispasync_t;
int isp_async(struct ispsoftc *, ispasync_t, void *);

#define	ISPASYNC_CHANGE_PDB	((void *) 0)
#define	ISPASYNC_CHANGE_SNS	((void *) 1)
#define	ISPASYNC_CHANGE_OTHER	((void *) 2)

/*
 * Platform Dependent Error and Debug Printout
 *
 * Generally this is:
 *
 *    void isp_prt(struct ispsoftc *, int level, const char *, ...)
 *
 * but due to compiler differences on different platforms this won't be
 * formally done here. Instead, it goes in each platform definition file.
 */

#define	ISP_LOGALL	0x0	/* log always */
#define	ISP_LOGCONFIG	0x1	/* log configuration messages */
#define	ISP_LOGINFO	0x2	/* log informational messages */
#define	ISP_LOGWARN	0x4	/* log warning messages */
#define	ISP_LOGERR	0x8	/* log error messages */
#define	ISP_LOGDEBUG0	0x10	/* log simple debug messages */
#define	ISP_LOGDEBUG1	0x20	/* log intermediate debug messages */
#define	ISP_LOGDEBUG2	0x40	/* log most debug messages */
#define	ISP_LOGDEBUG3	0x80	/* log high frequency debug messages */
#define	ISP_LOGSANCFG	0x100	/* log SAN configuration */
#define	ISP_LOGTDEBUG0	0x200	/* log simple debug messages (target mode) */
#define	ISP_LOGTDEBUG1	0x400	/* log intermediate debug messages (target) */
#define	ISP_LOGTDEBUG2	0x800	/* log all debug messages (target) */

/*
 * Each Platform provides it's own isposinfo substructure of the ispsoftc
 * defined above.
 *
 * Each platform must also provide the following macros/defines:
 *
 *
 *	ISP2100_SCRLEN	-	length for the Fibre Channel scratch DMA area
 *
 *	MEMZERO(dst, src)			platform zeroing function
 *	MEMCPY(dst, src, count)			platform copying function
 *	SNPRINTF(buf, bufsize, fmt, ...)	snprintf
 *	USEC_DELAY(usecs)			microsecond spindelay function
 *	USEC_SLEEP(isp, usecs)			microsecond sleep function
 *
 *	NANOTIME_T				nanosecond time type
 *
 *	GET_NANOTIME(NANOTIME_T *)		get current nanotime.
 *
 *	GET_NANOSEC(NANOTIME_T *)		get u_int64_t from NANOTIME_T
 *
 *	NANOTIME_SUB(NANOTIME_T *, NANOTIME_T *)
 *						subtract two NANOTIME_T values
 *
 *
 *	MAXISPREQUEST(struct ispsoftc *)	maximum request queue size
 *						for this particular board type
 *
 *	MEMORYBARRIER(struct ispsoftc *, barrier_type, offset, size)
 *
 *		Function/Macro the provides memory synchronization on
 *		various objects so that the ISP's and the system's view
 *		of the same object is consistent.
 *
 *	MBOX_ACQUIRE(struct ispsoftc *)		acquire lock on mailbox regs
 *	MBOX_WAIT_COMPLETE(struct ispsoftc *, mbreg_t *) wait for cmd to be done
 *	MBOX_NOTIFY_COMPLETE(struct ispsoftc *)	notification of mbox cmd donee
 *	MBOX_RELEASE(struct ispsoftc *)		release lock on mailbox regs
 *
 *	FC_SCRATCH_ACQUIRE(struct ispsoftc *)	acquire lock on FC scratch area
 *	FC_SCRATCH_RELEASE(struct ispsoftc *)	acquire lock on FC scratch area
 *
 *	SCSI_GOOD	SCSI 'Good' Status
 *	SCSI_CHECK	SCSI 'Check Condition' Status
 *	SCSI_BUSY	SCSI 'Busy' Status
 *	SCSI_QFULL	SCSI 'Queue Full' Status
 *
 *	XS_T		Platform SCSI transaction type (i.e., command for HBA)
 *	XS_DMA_ADDR_T	Platform PCI DMA Address Type
 *	XS_ISP(xs)	gets an instance out of an XS_T
 *	XS_CHANNEL(xs)	gets the channel (bus # for DUALBUS cards) ""
 *	XS_TGT(xs)	gets the target ""
 *	XS_LUN(xs)	gets the lun ""
 *	XS_CDBP(xs)	gets a pointer to the scsi CDB ""
 *	XS_CDBLEN(xs)	gets the CDB's length ""
 *	XS_XFRLEN(xs)	gets the associated data transfer length ""
 *	XS_TIME(xs)	gets the time (in milliseconds) for this command
 *	XS_RESID(xs)	gets the current residual count
 *	XS_STSP(xs)	gets a pointer to the SCSI status byte ""
 *	XS_SNSP(xs)	gets a pointer to the associate sense data
 *	XS_SNSLEN(xs)	gets the length of sense data storage
 *	XS_SNSKEY(xs)	dereferences XS_SNSP to get the current stored Sense Key
 *	XS_TAG_P(xs)	predicate of whether this command should be tagged
 *	XS_TAG_TYPE(xs)	which type of tag to use
 *	XS_SETERR(xs)	set error state
 *
 *		HBA_NOERROR	command has no erros
 *		HBA_BOTCH	hba botched something
 *		HBA_CMDTIMEOUT	command timed out
 *		HBA_SELTIMEOUT	selection timed out (also port logouts for FC)
 *		HBA_TGTBSY	target returned a BUSY status
 *		HBA_BUSRESET	bus reset destroyed command
 *		HBA_ABORTED	command was aborted (by request)
 *		HBA_DATAOVR	a data overrun was detected
 *		HBA_ARQFAIL	Automatic Request Sense failed
 *
 *	XS_ERR(xs)	return current error state
 *	XS_NOERR(xs)	there is no error currently set
 *	XS_INITERR(xs)	initialize error state
 *
 *	XS_SAVE_SENSE(xs, sp, len)	save sense data
 *
 *	XS_SET_STATE_STAT(isp, sp, xs)	platform dependent interpreter of
 *					response queue entry status bits
 *
 *
 *	DEFAULT_IID(struct ispsoftc *)		Default SCSI initiator ID
 *	DEFAULT_LOOPID(struct ispsoftc *)		Default FC Loop ID
 *	DEFAULT_NODEWWN(struct ispsoftc *)		Default Node WWN
 *	DEFAULT_PORTWWN(struct ispsoftc *)		Default Port WWN
 *	DEFAULT_FRAMESIZE(struct ispsoftc *)		Default Frame Size
 *	DEFAULT_EXEC_THROTTLE(struct ispsoftc *) Default Execution Throttle
 *		These establish reasonable defaults for each platform.
 * 		These must be available independent of card NVRAM and are
 *		to be used should NVRAM not be readable.
 *
 *	ISP_NODEWWN(struct ispsoftc *)		FC Node WWN to use
 *	ISP_PORTWWN(struct ispsoftc *)		FC Port WWN to use
 *
 *		These are to be used after NVRAM is read. The tags
 *		in fcparam.isp_ww{n,p}n_nvram reflect the values
 *		read from NVRAM (possibly corrected for card botches).
 *		Each platform can take that information and override
 *		it or ignore and return the Node and Port WWNs to be
 * 		used when sending the QLogic f/w the Initialization
 *		Control Block.
 *
 *	(XXX these do endian specific transformations- in transition XXX)
 *
 *	ISP_IOXPUT_8(struct ispsoftc *, u_int8_t srcval, u_int8_t *dstptr)
 *	ISP_IOXPUT_16(struct ispsoftc *, u_int16_t srcval, u_int16_t *dstptr)
 *	ISP_IOXPUT_32(struct ispsoftc *, u_int32_t srcval, u_int32_t *dstptr)
 *
 *	ISP_IOXGET_8(struct ispsoftc *, u_int8_t *srcptr, u_int8_t dstrval)
 *	ISP_IOXGET_16(struct ispsoftc *, u_int16_t *srcptr, u_int16_t dstrval)
 *	ISP_IOXGET_32(struct ispsoftc *, u_int32_t *srcptr, u_int32_t dstrval)
 *
 *	ISP_SWIZZLE_NVRAM_WORD(struct ispsoftc *, u_int16_t *)
 *	ISP_SWIZZLE_NVRAM_LONG(struct ispsoftc *, u_int32_t *)
 *	ISP_SWAP16(struct ispsoftc *, u_int16_t srcval)
 *	ISP_SWAP32(struct ispsoftc *, u_int32_t srcval)
 */

#endif	/* _ISPVAR_H */
@


1.28
log
@fix a few capitalizations of QLogic.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispvar.h,v 1.27 2009/06/24 11:00:53 krw Exp $ */
@


1.27
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d1 1
a1 1
/*     $OpenBSD: ispvar.h,v 1.26 2008/11/02 03:17:22 krw Exp $ */
d30 1
a30 1
 * Soft Definitions for for Qlogic ISP SCSI adapters.
d777 1
a777 1
 * topology is NL or FL port (private or public loop). Since the Qlogic f/w
d1005 1
a1005 1
 * 		used when sending the Qlogic f/w the Initialization
@


1.26
log
@Start updating isp. Just new defines, comments, whitespace, anything that
doesn't change the .o. Use isp_stds.h.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispvar.h,v 1.25 2008/10/25 22:18:10 krw Exp $ */
a38 4
#ifdef	ISP_TARGET_MODE
#include <dev/ic/isp_target.h>
#include <dev/ic/isp_tpublic.h>
#endif
a42 4
#ifdef	ISP_TARGET_MODE
#include <dev/isp/isp_target.h>
#include <dev/isp/isp_tpublic.h>
#endif
a46 3
#ifdef	ISP_TARGET_MODE
#include "isp_target.h"
#include "isp_tpublic.h"
d48 3
d53 2
a54 2
#define	ISP_CORE_VERSION_MAJOR	2
#define	ISP_CORE_VERSION_MINOR	7
d59 1
a59 1
struct ispsoftc;
d62 3
a64 3
	    (struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
	u_int16_t	(*dv_rd_reg) (struct ispsoftc *, int);
	void		(*dv_wr_reg) (struct ispsoftc *, int, u_int16_t);
d66 3
a68 4
	int		(*dv_dmaset) (struct ispsoftc *,
	    XS_T *, ispreq_t *, u_int16_t *, u_int16_t);
	void		(*dv_dmaclr)
	    (struct ispsoftc *, XS_T *, u_int16_t);
d72 1
a72 1
	u_int16_t	*dv_ispfw;	/* ptr to f/w */
d81 1
a81 1
#define	MAX_FC_TARG		256
a85 9
 * 'Types'
 */
#ifdef	ISP_DAC_SUPPORTED
typedef	u_int64_t	isp_dma_addr_t;
#else
typedef	u_int32_t	isp_dma_addr_t;
#endif

/*
d148 1
a148 1
#define	ISP_QUEUE_ENTRY(q, idx)		((q) + ((idx) * QENTRY_LEN))
d159 1
a159 1
	WRITE_REQUEST_QUEUE_IN_POINTER(isp, nxti);			\
a164 1

d166 3
a168 1
	u_int		isp_gotdparms		: 1,
d174 1
d236 4
a239 8
#define	FL_PORT_ID		0x7e	/* FL_Port Special ID */
#define	FC_PORT_ID		0x7f	/* Fabric Controller Special ID */
#define	FC_SNS_ID		0x80	/* SNS Server Special ID */

/* #define	ISP_USE_GA_NXT	1 */	/* Use GA_NXT with switches */
#ifndef	GA_NXT_MAX
#define	GA_NXT_MAX	256
#endif
d316 55
a370 4
	u_int32_t		isp_fwoptions	: 16,
				isp_gbspeed	: 2,
				isp_iid_set	: 1,
				loop_seen_once	: 1,
d372 1
a372 2
				isp_fwstate	: 3,	/* ISP F/W state */
				isp_gotdparms	: 1,
d374 7
a380 6
				isp_onfabric	: 1;
	u_int8_t		isp_iid;	/* 'initiator' id */
	u_int8_t		isp_loopid;	/* hard loop id */
	u_int8_t		isp_alpa;	/* ALPA */
	u_int32_t		isp_portid;
	volatile u_int16_t	isp_lipseq;	/* LIP sequence # */
d382 1
a382 1
	u_int8_t		isp_execthrottle;
d388 8
a395 2
	u_int64_t		isp_nodewwn;
	u_int64_t		isp_portwwn;
d397 7
a403 26
	 * Port Data Base. This is indexed by 'target', which is invariate.
	 * However, elements within can move around due to loop changes,
	 * so the actual loop ID passed to the F/W is in this structure.
	 * The first time the loop is seen up, loopid will match the index
	 * (except for fabric nodes which are above mapped above FC_SNS_ID
	 * and are completely virtual), but subsequent LIPs can cause things
	 * to move around.
	 */
	struct lportdb {
		u_int32_t
					port_type	: 8,
					loopid		: 8,
					fc4_type	: 4,
					last_fabric_dev	: 1,
							: 2,
					relogin		: 1,
					force_logout	: 1,
					was_fabric_dev	: 1,
					fabric_dev	: 1,
					loggedin	: 1,
					roles		: 2,
					valid		: 1;
		u_int32_t		portid;
		u_int64_t		node_wwn;
		u_int64_t		port_wwn;
	} portdb[MAX_FC_TARG], tport[FC_PORT_ID];
d408 2
a409 2
	caddr_t			isp_scratch;
	isp_dma_addr_t		isp_scdma;
d411 1
a411 1
	u_int16_t		*isp_dump_data;
d427 4
a430 4
#define	LOOP_SCANNING_FABRIC	3
#define	LOOP_FSCAN_DONE		4
#define	LOOP_SCANNING_LOOP	5
#define	LOOP_LSCAN_DONE		6
d443 1
a443 1
typedef struct ispsoftc {
d480 6
a485 4
	u_int16_t		isp_rqstinrp;	/* register for REQINP */
	u_int16_t		isp_rqstoutrp;	/* register for REQOUTP */
	u_int16_t		isp_respinrp;	/* register for RESINP */
	u_int16_t		isp_respoutrp;	/* register for RESOUTP */
d503 1
a503 2
	volatile u_int32_t
		isp_obits	:	8,	/* mailbox command output */
d509 8
a516 7
	volatile u_int16_t	isp_reqodx;	/* index of last ISP pickup */
	volatile u_int16_t	isp_reqidx;	/* index of next request */
	volatile u_int16_t	isp_residx;	/* index of next result */
	volatile u_int16_t	isp_resodx;	/* index of next result */
	volatile u_int16_t	isp_rspbsy;
	volatile u_int16_t	isp_lasthdls;	/* last handle seed */
	volatile u_int16_t	isp_mboxtmp[MAX_MAILBOX];
d521 1
d529 7
d537 1
a537 1
	 * request/result queue pointers and dma handles for them.
d539 10
a548 5
	caddr_t			isp_rquest;
	caddr_t			isp_result;
	isp_dma_addr_t		isp_rquest_dma;
	isp_dma_addr_t		isp_result_dma;
} ispsoftc_t;
d557 4
a560 3
#define	ISP_RESETSTATE	1
#define	ISP_INITSTATE	2
#define	ISP_RUNSTATE	3
d604 2
a605 2
#define	ISP_ROLE_INITIATOR	0x1
#define	ISP_ROLE_TARGET		0x2
d686 2
a687 1
#define	IS_23XX(isp)	((isp)->isp_type >= ISP_HA_FC_2300)
d696 4
a699 9
#ifdef	ISP_DAC_SUPPORTRED
#define	DMA_WD3(x)	(((x) >> 48) & 0xffff)
#define	DMA_WD2(x)	(((x) >> 32) & 0xffff)
#else
#define	DMA_WD3(x)	0
#define	DMA_WD2(x)	0
#endif
#define	DMA_WD1(x)	(((x) >> 16) & 0xffff)
#define	DMA_WD0(x)	(((x) & 0xffff))
d738 1
a738 1
void isp_intr(struct ispsoftc *, u_int16_t, u_int16_t, u_int16_t);
d801 1
a801 1
	ISPCTL_GET_POSMAP,		/* Get FC-AL position map */
d803 3
a805 1
	ISPCTL_TOGGLE_TMODE		/* toggle target mode */
d858 6
a863 5
	ISPASYNC_FABRIC_DEV,		/* FC Fabric Device Arrival */
	ISPASYNC_PROMENADE,		/* FC Objects coming && going */
	ISPASYNC_TARGET_MESSAGE,	/* target message */
	ISPASYNC_TARGET_EVENT,		/* target asynchronous event */
	ISPASYNC_TARGET_ACTION,		/* other target command action */
a885 6
#ifdef	__GNUC__
void isp_prt(struct ispsoftc *, int level, const char *, ...)
	__attribute__((__format__(__printf__,3,4)));
#else
void isp_prt(struct ispsoftc *, int level, const char *, ...);
#endif
d896 1
a896 1
#define	ISP_LOGDEBUG4	0x100	/* log high frequency debug messages */
d936 1
a936 1
 *	MBOX_WAIT_COMPLETE(struct ispsoftc *)	wait for mailbox cmd to be done
d949 1
d981 1
a981 1
 *	XS_SAVE_SENSE(xs, sp)		save sense data
d988 4
a991 4
 *	DEFAULT_LOOPID(struct ispsoftc *)	Default FC Loop ID
 *	DEFAULT_NODEWWN(struct ispsoftc *)	Default Node WWN
 *	DEFAULT_PORTWWN(struct ispsoftc *)	Default Port WWN
 *	DEFAULT_FRAMESIZE(struct ispsoftc *)	Default Frame Size
d1001 1
a1001 1
 *		in fcparam.isp_{node,port}wwn reflect the values
@


1.25
log
@Start updating isp. Just new defines, comments, whitespace, anything that
doesn't change the .o.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispvar.h,v 1.24 2008/01/21 20:00:33 sobrado Exp $ */
d37 1
d45 1
d53 1
@


1.24
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 28
a28 1
/*     $OpenBSD: ispvar.h,v 1.23 2007/04/10 17:47:55 miod Exp $ */
d30 1
a30 26
 * Soft Definitions for for QLogic ISP SCSI adapters.
 *
 * Copyright (c) 1997, 1998, 1999, 2000 by Matthew Jacob
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
d119 2
a120 2
#define	ISP_DMAFREE(isp, xs, hndl)	\
	if ((isp)->isp_mdvec->dv_dmaclr) \
d147 1
a235 1

d258 74
d448 1
a448 1
				isp_port	: 1,	/* 23XX only */
d543 1
d581 1
d592 2
d630 2
d652 2
d656 1
a656 1
 * DMA cookie macros
d668 3
d712 1
d744 1
a744 1
 * topology is NL or FL port (private or public loop). Since the QLogic f/w
d842 7
d872 1
a872 1
 * Each Platform provides its own isposinfo substructure of the ispsoftc
a877 7
 *	INLINE		-	platform specific define for 'inline' functions
 *
 *	ISP_DAC_SUPPORTED -	Is DAC (Dual Address Cycle) is supported?
 *				Basically means whether or not DMA for PCI
 *				PCI cards (Ultra2 or better or FC) works
 *				above 4GB.
 *
d966 2
a967 2
 *	ISP_NODEWWN(struct ispsoftc *)	FC Node WWN to use
 *	ISP_PORTWWN(struct ispsoftc *)	FC Port WWN to use
d974 2
a975 2
 * 		used when sending the QLogic f/w the Initialization Control
 *		Block.
d988 3
@


1.23
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispvar.h,v 1.22 2003/03/03 18:37:25 mjacob Exp $ */
d3 1
a3 1
 * Soft Definitions for for Qlogic ISP SCSI adapters.
d656 1
a656 1
 * topology is NL or FL port (private or public loop). Since the Qlogic f/w
d886 1
a886 1
 * 		used when sending the Qlogic f/w the Initialization Control
@


1.22
log
@Get rid of ISP_DMA_ADDR_T and uses ISP_DAC_SUPPORTED to define the
width of a dma address type- this also allows us to define macros that
set upper words of a dma address.

Remove STRNCAT.

Add (untested) 10160 support.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispvar.h,v 1.21 2002/08/17 17:40:26 mjacob Exp $ */
d777 1
a777 1
 * Each Platform provides it's own isposinfo substructure of the ispsoftc
@


1.21
log
@Reorder the lportdb dibfields.  Add some more CFG params.
Add ISPASYNC_FW_DUMPED, ISPASYNC_FW_RESTARTED async events.
Add ISP_FW_NEWER_THAN macro- makes the code easier to read.
DEFAULT_FRAMESIZE and DEFAULT_EXEC_THROTTLE macros.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispvar.h,v 1.20 2002/05/17 01:36:35 mjacob Exp $ */
d92 4
a95 2
#ifndef	ISP_DMA_ADDR_T
#define	ISP_DMA_ADDR_T	u_int32_t
d312 1
a312 1
	ISP_DMA_ADDR_T		isp_scdma;
d434 2
a435 2
	ISP_DMA_ADDR_T		isp_rquest_dma;
	ISP_DMA_ADDR_T		isp_result_dma;
d543 2
a544 1
#define	ISP_HA_SCSI_12160	0xb
d555 1
d559 1
d561 2
a562 2
#define	IS_ULTRA2(isp)	(IS_1080(isp) || IS_1280(isp) || IS_12160(isp))
#define	IS_ULTRA3(isp)	(IS_12160(isp))
d574 4
d580 1
d716 1
a716 1
 * is an index into the portdb in the softc ('target'). Whether that entrie's
d785 4
a788 4
 *	ISP_DMA_ADDR_T	-	platform specific dma address coookie- basically
 *				the largest integer that can hold the 32 or
 *				64 bit value appropriate for the QLogic's DMA
 *				addressing. Defaults to u_int32_t.
a794 1
 *	STRNCAT(dstbuf, size, srcbuf)		strncat
@


1.20
log
@Roll core version.

Make the firmware pointer no longer a const- since the continuation mailbox
code indexes off of this, compilers whine too much.

Fix various other definitions. Add a bunch of interrupt related stats.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.19 2001/12/14 00:20:55 mjacob Exp $ */
d290 1
a290 1
							: 4,
a291 1
					loopid		: 8,
d293 2
d462 3
d510 2
d732 3
a734 1
	ISPASYNC_FW_CRASH		/* Firmware has crashed */
d863 2
@


1.19
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.18 2001/10/06 22:45:52 mjacob Exp $ */
d57 1
a57 1
#define	ISP_CORE_VERSION_MINOR	5
d76 1
a76 1
	const u_int16_t	*dv_ispfw;	/* ptr to f/w */
d152 3
d157 1
d249 5
d288 4
a291 1
		u_int
d293 1
a293 1
							: 1,
d310 3
d368 2
a369 1
						: 5,
d390 6
d411 2
d416 4
a453 1
#define	ISP_CFG_OWNWWN		0x02	/* override NVRAM wwn */
d459 2
d540 1
d556 3
a558 1
#define	IS_2300(isp)	((isp)->isp_type >= ISP_HA_FC_2300)
d588 7
d805 2
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.19 2001/12/14 00:20:55 mjacob Exp $ */
d57 1
a57 1
#define	ISP_CORE_VERSION_MINOR	7
d76 1
a76 1
	u_int16_t	*dv_ispfw;	/* ptr to f/w */
a151 3
#ifdef	ISP_TARGET_MODE
#define	RESULT_QUEUE_LEN(x)		MAXISPREQUEST(x)
#else
a153 1
#endif
a244 5
/* #define	ISP_USE_GA_NXT	1 */	/* Use GA_NXT with switches */
#ifndef	GA_NXT_MAX
#define	GA_NXT_MAX	256
#endif

d279 1
a279 4
		u_int32_t
					port_type	: 8,
							: 4,
					fc4_type	: 4,
d281 1
a281 1
					last_fabric_dev	: 1,
a297 3
#ifdef	ISP_FW_CRASH_DUMP
	u_int16_t		*isp_dump_data;
#endif
d353 1
a353 2
						: 4,
				isp_port	: 1,	/* 23XX only */
a373 6
	u_int64_t		isp_intmboxc;		/* mbox completions */
	u_int64_t		isp_intoasync;		/* other async */
	u_int64_t		isp_rsltccmplt;		/* CMDs on result q */
	u_int64_t		isp_fphccmplt;		/* CMDs via fastpost */
	u_int16_t		isp_rscchiwater;
	u_int16_t		isp_fpcchiwater;
a388 2
	volatile u_int16_t	isp_resodx;	/* index of next result */
	volatile u_int16_t	isp_rspbsy;
a391 4
	volatile u_int16_t	isp_mbxwrk0;
	volatile u_int16_t	isp_mbxwrk1;
	volatile u_int16_t	isp_mbxwrk2;
	void *			isp_mbxworkp;
d426 1
a431 2
#define	ISP_CFG_OWNWWPN		0x100	/* override NVRAM wwpn */
#define	ISP_CFG_OWNWWNN		0x200	/* override NVRAM wwnn */
a510 1
#define	ISP_HA_FC_2312		0x40
d526 1
a526 3
#define	IS_23XX(isp)	((isp)->isp_type >= ISP_HA_FC_2300)
#define	IS_2300(isp)	((isp)->isp_type == ISP_HA_FC_2300)
#define	IS_2312(isp)	((isp)->isp_type == ISP_HA_FC_2312)
a555 7
#ifdef	ISP_FW_CRASH_DUMP
/*
 * Dump firmware entry point.
 */
void isp_fw_dump(struct ispsoftc *isp);
#endif

a765 2
 *	FC_SCRATCH_ACQUIRE(struct ispsoftc *)	acquire lock on FC scratch area
 *	FC_SCRATCH_RELEASE(struct ispsoftc *)	acquire lock on FC scratch area
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*     $OpenBSD$ */
d290 2
a292 1
					fc4_type	: 4,
a293 2
							: 2,
					relogin		: 1,
a460 3
#define	ISP_CFG_OWNFSZ		0x400	/* override NVRAM frame size */
#define	ISP_CFG_OWNLOOPID	0x800	/* override NVRAM loopid */
#define	ISP_CFG_OWNEXCTHROTTLE	0x1000	/* override NVRAM execution throttle */
a505 2
#define	ISP_FW_NEWER_THAN(i, major, minor, micro)		\
 (ISP_FW_REVX((i)->isp_fwrev) > ISP_FW_REV(major, minor, micro))
d726 1
a726 3
	ISPASYNC_FW_CRASH,		/* Firmware has crashed */
	ISPASYNC_FW_DUMPED,		/* Firmware crashdump taken */
	ISPASYNC_FW_RESTARTED		/* Firmware has been restarted */
a854 2
 *	DEFAULT_FRAMESIZE(struct ispsoftc *)	Default Frame Size
 *	DEFAULT_EXEC_THROTTLE(struct ispsoftc *) Default Execution Throttle
@


1.19.2.3
log
@sync
@
text
@d92 2
a93 4
#ifdef	ISP_DAC_SUPPORTED
typedef	u_int64_t	isp_dma_addr_t;
#else
typedef	u_int32_t	isp_dma_addr_t;
d310 1
a310 1
	isp_dma_addr_t		isp_scdma;
d432 2
a433 2
	isp_dma_addr_t		isp_rquest_dma;
	isp_dma_addr_t		isp_result_dma;
d541 1
a541 2
#define	ISP_HA_SCSI_10160	0xb
#define	ISP_HA_SCSI_12160	0xc
a551 1
#define	IS_10160(isp)	(isp->isp_type == ISP_HA_SCSI_10160)
a554 1
#define	IS_1X160(isp)	(IS_10160(isp) || IS_12160(isp))
d556 2
a557 2
#define	IS_ULTRA2(isp)	(IS_1080(isp) || IS_1280(isp) || IS_1X160(isp))
#define	IS_ULTRA3(isp)	(IS_1X160(isp))
a568 4
#ifdef	ISP_DAC_SUPPORTRED
#define	DMA_WD3(x)	(((x) >> 48) & 0xffff)
#define	DMA_WD2(x)	(((x) >> 32) & 0xffff)
#else
a570 1
#endif
d706 1
a706 1
 * is an index into the portdb in the softc ('target'). Whether that entry's
d775 4
a778 4
 *	ISP_DAC_SUPPORTED -	Is DAC (Dual Address Cycle) is supported?
 *				Basically means whether or not DMA for PCI
 *				PCI cards (Ultra2 or better or FC) works
 *				above 4GB.
d785 1
@


1.18
log
@Fix various 2300 (2Gb) last minute errata. Keep up with the jones' for
the target mode code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.17 2001/09/01 07:16:40 mjacob Exp $ */
d57 1
a57 1
#define	ISP_CORE_VERSION_MINOR	4
d163 4
a166 4
#define	ISP_ADD_REQUEST(isp, iptr)	\
	MEMORYBARRIER(isp, SYNC_REQUEST, iptr, QENTRY_LEN); \
	WRITE_REQUEST_QUEUE_IN_POINTER(isp, iptr); \
	isp->isp_reqidx = iptr
d353 3
a355 3
						: 6,
				isp_role	: 2,
						: 1,
d359 1
d380 2
a381 2
		isp_mboxbsy	:	8,	/* mailbox command active */
				:	1,
d485 8
d668 2
a669 3
 * return non-zero if it handled it. The 'arg' points to a (possibly only
 * partially) massaged response queue entry (see the platform's
 * ISP_UNSWIZZLE_RESPONSE macro).
d830 10
a839 8
 *	ISP_SWIZZLE_ICB
 *	ISP_UNSWIZZLE_AND_COPY_PDBP
 *	ISP_SWIZZLE_CONTINUATION
 *	ISP_SWIZZLE_REQUEST
 *	ISP_UNSWIZZLE_RESPONSE
 *	ISP_SWIZZLE_SNS_REQ
 *	ISP_UNSWIZZLE_SNS_RSP
 *	ISP_SWIZZLE_NVRAM_WORD
@


1.17
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.16 2001/04/04 22:09:39 mjacob Exp $ */
d247 1
a247 1
						: 2,
d260 1
a260 1
	u_int16_t		isp_xxxxxx;
d422 2
d469 3
d473 3
@


1.16
log
@Roll Core minor. Ansify source. Handles are now 16 bits. Add
ISPCTL_RUN_MBOXCMD entry point. Add ISPASYNC_UNHANDLED_RESPONSE
definition.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.15 2001/02/12 23:51:20 mjacob Exp $ */
d57 1
a57 1
#define	ISP_CORE_VERSION_MINOR	1
d64 2
d70 1
a70 1
		XS_T *, ispreq_t *, u_int16_t *, u_int16_t);
d72 1
a72 1
		(struct ispsoftc *, XS_T *, u_int16_t);
d84 2
a85 2
#define	MAX_TARGETS	16
#define	MAX_FC_TARG	256
d89 6
d100 2
d165 1
a165 1
	ISP_WRITE(isp, INMAILBOX4, iptr); \
d192 2
a193 1
		u_int	dev_enable	:	1,	/* ignored */
d195 1
d198 9
a206 7
			exc_throttle	:	8,
			cur_offset	:	4,
			sync_offset	:	4;
		u_int8_t	cur_period;	/* current sync period */
		u_int8_t	sync_period;	/* goal sync period */
		u_int16_t	dev_flags;	/* goal device flags */
		u_int16_t	cur_dflags;	/* current device flags */
d247 1
a247 1
						: 3,
d250 1
a250 1
				isp_loopstate	: 3,	/* Current Loop State */
d281 2
a282 1
							: 2,
d297 1
a297 1
	u_int32_t		isp_scdma;
d315 3
a317 3
#define	LOOP_LSCAN_DONE		4
#define	LOOP_SYNCING_PDB	6
#define	LOOP_READY		7
d363 5
d402 2
a403 2
	u_int32_t		isp_rquest_dma;
	u_int32_t		isp_result_dma;
d449 1
a449 1
 * 
d465 1
d493 1
d506 4
a509 3
#define	IS_FC(isp)	(isp->isp_type & ISP_HA_FC)
#define	IS_2100(isp)	(isp->isp_type == ISP_HA_FC_2100)
#define	IS_2200(isp)	(isp->isp_type == ISP_HA_FC_2200)
d514 4
a517 2
#define	DMA_MSW(x)	(((x) >> 16) & 0xffff)
#define	DMA_LSW(x)	(((x) & 0xffff))
d540 5
a544 1
 * Interrupt Service Routine
d546 2
a547 1
int isp_intr(void *);
d596 1
a596 1
 * part of this function. It's now been seperated to allow for finer control.
d661 2
d670 2
a671 1
	ISPASYNC_UNHANDLED_RESPONSE	/* Unhandled Response Entry */
d697 2
a698 1
#define	ISP_LOGDEBUG3	0x100	/* log high frequency debug messages */
d712 5
a821 2
 *
 *
d823 1
@


1.15
log
@Eliminate ISP2100_FABRIC- we always allow for fabric now. Add an
isp_iid_set/isp_iid for fibre channel- this is because we now
fake a port database entry for ourselves. Add the additional loop
states between LOOP_PDB_RCVD and LOOP_READY.

Change and comment on a wad of Fibre Channel isp_control functions.
Change and comment on some of the ISPASYNC Fibre Channel events.

Add was_fabric_dev/fabric_dev tags to our local FC database structure
(so we can see rapidly whether something was a fabric device but is
now gone).

Add a tag which says what role this adapter should take. It can take
on the value of None, Target, Initiator or Both. None is useful for
warm failover purposes. Remove the ISP_CFG_NOINIT silliness since
a role of "None" does this.

Add a isp_lastmbxcmd tag to store the opcode for the last mailbox
command used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.14 2001/01/09 03:29:32 mjacob Exp $ */
d57 1
a57 1
#define	ISP_CORE_VERSION_MINOR	0
d64 5
a68 5
	u_int16_t	(*dv_rd_reg) __P((struct ispsoftc *, int));
	void		(*dv_wr_reg) __P((struct ispsoftc *, int, u_int16_t));
	int		(*dv_mbxdma) __P((struct ispsoftc *));
	int		(*dv_dmaset) __P((struct ispsoftc *,
		XS_T *, ispreq_t *, u_int16_t *, u_int16_t));
d70 4
a73 4
		__P((struct ispsoftc *, XS_T *, u_int32_t));
	void		(*dv_reset0) __P((struct ispsoftc *));
	void		(*dv_reset1) __P((struct ispsoftc *));
	void		(*dv_dregs) __P((struct ispsoftc *, const char *));
d502 1
a502 1
void isp_reset __P((struct ispsoftc *));
d507 1
a507 1
void isp_init __P((struct ispsoftc *));
d512 1
a512 1
void isp_reinit __P((struct ispsoftc *));
d517 1
a517 1
int isp_intr __P((void *));
d522 1
a522 1
int isp_start __P((XS_T *));
d532 1
a532 1
void isp_done __P((XS_T *));
d579 1
d582 1
a582 1
int isp_control __P((struct ispsoftc *, ispctl_t, void *));
d618 6
d637 2
a638 1
	ISPASYNC_CONF_CHANGE		/* Platform Configuration Change */
d640 1
a640 1
int isp_async __P((struct ispsoftc *, ispasync_t, void *));
d650 1
a650 1
void isp_prt __P((struct ispsoftc *, int level, const char *, ...))
d653 1
a653 1
void isp_prt __P((struct ispsoftc *, int level, const char *, ...));
@


1.14
log
@Add in a ISP_CFG_NOINIT flag (other platform stuff). Define some of
the async code event changes. Note (for __GNUC__) that isp_prt has
__attributes__'s of __format__/__printf__....
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.13 2000/12/06 01:07:23 mjacob Exp $ */
a82 1
#ifdef	ISP2100_FABRIC
a83 4
#else
#define	MAX_FC_TARG	126
#endif

d233 2
a234 1
						: 4,
d241 1
d244 1
d246 1
a246 1
	u_int32_t		isp_portid;
d267 3
a269 1
							: 4,
d276 1
a276 1
	} portdb[MAX_FC_TARG], tport[FL_PORT_ID];
d297 5
d337 4
a340 1
	u_int32_t
a341 1
						: 1,
d344 4
a347 3
				isp_dblev	: 12,	/* debug log mask */
				isp_clock	: 8,	/* input clock */
				isp_confopts	: 8;	/* config options */
d370 1
a401 1
#define	ISP_CFG_NOINIT		0x20	/* just set defaults- don't init */
d411 31
d444 1
a444 1
#define	ISP_CODE_ORG		0x1000	/* default f/w code start */
d446 1
a446 1
#define	ISP_FW_REVX(xp)	((xp[0]<<24) | (xp[1] << 16) | xp[2])
d537 4
a540 1
 * Assumes all locks are held and that no reentrancy issues need be dealt with.
d542 25
d572 1
a572 1
	ISPCTL_UPDATE_PARAMS,		/* Update Operating Parameters */
d574 2
d577 2
d588 29
a616 1
 * Assumes all locks are held and that no reentrancy issues need be dealt with.
d620 1
a620 1
	ISPASYNC_NEW_TGT_PARAMS,
d624 3
a626 3
	ISPASYNC_CHANGE_NOTIFY,		/* FC SNS or Port Database Changed */
	ISPASYNC_FABRIC_DEV,		/* FC Fabric Device Arrived/Left */
	ISPASYNC_LOGGED_INOUT,		/* FC Object Logged In/Out */
d629 2
a630 1
	ISPASYNC_TARGET_ACTION		/* other target command action */
d634 4
a669 1
 *	ISP2100_FABRIC	-	defines whether FABRIC support is enabled
d702 1
a702 1
 * 
@


1.13
log
@Update isp codebase to current common head- USEC_SLEEP macro added,
instrumentation for interrupts, specific topology preferences for
the 2200. Fix the hole in the OpenBSD port becuause there'd been
no maxluns limit from the midlayer and have the command routine
bounce commands > the maxluns for a particular controller (in
particular, Qlogic FC cards where we can't tell when it hasn't been
us that have loaded the F/W whether or not SCCLUN is in effect
or not).
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.12 2000/10/16 01:02:01 mjacob Exp $ */
d393 1
a517 1
 *
d525 3
a527 3
	ISPASYNC_PDB_CHANGED,		/* FC Port Data Base Changed */
	ISPASYNC_CHANGE_NOTIFY,		/* FC SNS Change Notification */
	ISPASYNC_FABRIC_DEV,		/* FC New Fabric Device */
d537 4
d542 2
@


1.12
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.11 2000/07/06 05:31:49 mjacob Exp $ */
d340 5
d395 5
a399 1
#define	ISP_CFG_NPORT		0x04	/* try to force N- instead of L-Port */
d568 1
@


1.11
log
@Resync with FreeBSD/NetBSD. Salient features are that the mailbox command
routines are not necessarily polled now- this should cut down on some of
the spurious lost commands that have occurred. Also, we now watchdog each
command and make sure that command constipation doesn't occur (which it
has been documented to do on the QLA2100 cards).
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.10 2000/04/06 05:47:00 mjacob Exp $ */
d5 1
a5 3
 *---------------------------------------
 * Copyright (c) 1997, 1998, 1999 by Matthew Jacob
 * NASA/Ames Research Center
d7 1
a7 1
 *---------------------------------------
d14 1
a14 4
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
d56 2
a57 2
#define	ISP_CORE_VERSION_MAJOR	1
#define	ISP_CORE_VERSION_MINOR	16
d68 1
a68 1
		ISP_SCSI_XFER_T *, ispreq_t *, u_int16_t *, u_int16_t));
d70 1
a70 1
		__P((struct ispsoftc *, ISP_SCSI_XFER_T *, u_int32_t));
d73 1
a73 1
	void		(*dv_dregs) __P((struct ispsoftc *));
a74 6
	u_int16_t 	dv_fwlen;	/* length of f/w */
	u_int16_t	dv_codeorg;	/* code ORG for f/w */
	u_int32_t	dv_fwrev;	/* f/w revision */
	/*
	 * Initial values for conf1 register
	 */
d79 3
d94 2
a95 1
 * Macros to read, write ISP registers through bus specific code.
d118 2
a119 2
#define	ISP_DUMPREGS(isp)	\
	if ((isp)->isp_mdvec->dv_dregs) (*(isp)->isp_mdvec->dv_dregs)((isp))
d127 17
a143 1
/* this is the size of a queue entry (request and response) */
d145 4
a148 8
/* both request and result queue length must be a power of two */
#define	RQUEST_QUEUE_LEN		MAXISPREQUEST
/* I've seen wierdnesses with the result queue < 64 */
#if	MAXISPREQUEST > 64
#define	RESULT_QUEUE_LEN		(MAXISPREQUEST/2)
#else
#define	RESULT_QUEUE_LEN		MAXISPREQUEST
#endif
d152 1
a152 1
#define	ISP_QAVAIL(in, out, qlen)	\
d155 2
d159 3
a161 1
	ISP_WRITE(isp, INMAILBOX4, iptr), isp->isp_reqidx = iptr
d177 1
a177 1
						: 1,
d212 3
a214 2
#define	DPARM_NARROW	0x0080	/* Possibly only available with >= 7.55 fw */
#define	DPARM_ASYNC	0x0040	/* Possibly only available with >= 7.55 fw */
d220 4
a223 2
#define	ISP_40M_SYNCPARMS	0x080a
#define	ISP_20M_SYNCPARMS	0x080c
d308 1
a308 1
struct ispsoftc {
d332 1
a332 1
	u_int32_t				: 4,
d334 1
a334 1
				isp_fast_mttr	: 1,	/* fast sram */
d336 2
a337 2
						: 1,
				isp_dblev	: 8,	/* debug level */
d361 1
a361 1
	ISP_SCSI_XFER_T **isp_xflist;
d370 1
a370 1
};
d376 1
a376 1
 * ISP States
d392 4
d439 5
d446 1
a446 1
 * Function Prototypes
d463 1
a463 1
void isp_restart __P((struct ispsoftc *));
d471 1
a471 1
 * Command Entry Point
d473 11
a483 1
int32_t ispscsicmd __P((ISP_SCSI_XFER_T *));
d526 1
a526 1
 * lost command routine (XXXX IN TRANSITION XXXX)
d528 13
a540 1
void isp_lostcmd __P((struct ispsoftc *, ISP_SCSI_XFER_T *));
d542 117
@


1.10
log
@Roll internal revision level. Put in Fibre Channel topology storage
and definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.9 2000/02/20 21:22:41 mjacob Exp $ */
d62 1
a62 1
#define	ISP_CORE_VERSION_MINOR	13
d79 1
a79 1
	const u_int16_t *dv_ispfw;	/* ptr to f/w */
d98 1
a98 9
#ifdef	ISP2100_SCCLUN
#define	_ISP_FC_LUN(isp)	65536
#else
#define	_ISP_FC_LUN(isp)	16
#endif
#define	_ISP_SCSI_LUN(isp)	\
	((ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(7, 55, 0))? 32 : 8)
#define	ISP_MAX_LUNS(isp)	\
	(IS_FC(isp)? _ISP_FC_LUN(isp) : _ISP_SCSI_LUN(isp))
d256 5
a260 5
					loopid	: 8,
						: 4,
					fabdev	: 1,
					roles	: 2,
					valid	: 1;
d318 1
d324 1
a324 1
				isp_dogactive	: 1,	/* watchdog running */
d333 3
a335 1
	volatile u_int32_t	:	9,
a339 1

d344 1
@


1.9
log
@Add 12160 (Ultra3) support. Add files and changes for target mode support.
Do some SNS fabric suppor tchanges. Roll revision levels. Tested on
GENERIC i386 && sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.8 1999/12/16 05:20:53 mjacob Exp $ */
d62 1
a62 1
#define	ISP_CORE_VERSION_MINOR	12
d234 1
a234 1
						: 7,
d239 1
d294 6
@


1.8
log
@Add in dual LVD (1280) support. Reorganize the model codes slightly
and add in IS_DUALBUS and IS_ULTRA2 macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.7 1999/11/22 12:50:53 mjacob Exp $ */
d43 1
d50 1
d57 1
d62 1
a62 1
#define	ISP_CORE_VERSION_MINOR	11
d376 1
d401 1
d410 7
a416 5
#define	IS_12X0(isp)	\
	(isp->isp_type == ISP_HA_SCSI_1240 || isp->isp_type == ISP_HA_SCSI_1280)
#define	IS_DUALBUS(isp)	IS_12X0(isp)
#define	IS_ULTRA2(isp)	\
	(isp->isp_type == ISP_HA_SCSI_1080 || isp->isp_type == ISP_HA_SCSI_1280)
d418 3
d463 3
a465 5
#ifdef	ISP_TARGET_MODE
	ISPCTL_ENABLE_LUN,		/* enable a LUN */
	ISPCTL_MODIFY_LUN,		/* enable a LUN */
#endif
	ISPCTL_FCLINK_TEST		/* Test FC Link Status */
d486 3
a488 2
	ISPASYNC_TARGET_CMD,		/* New target command */
	ISPASYNC_TARGET_EVENT		/* New target event */
@


1.8.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.9 2000/02/20 21:22:41 mjacob Exp $ */
a42 1
#include <dev/ic/isp_tpublic.h>
a48 1
#include <dev/isp/isp_tpublic.h>
a54 1
#include "isp_tpublic.h"
d59 1
a59 1
#define	ISP_CORE_VERSION_MINOR	12
a372 1
#define	ISP_CFG_NPORT		0x04	/* try to force N- instead of L-Port */
a396 1
#define	ISP_HA_SCSI_12160	0xb
d405 5
a409 7
#define	IS_12160(isp)	(isp->isp_type == ISP_HA_SCSI_12160)

#define	IS_12X0(isp)	(IS_1240(isp) || IS_1280(isp))
#define	IS_DUALBUS(isp)	(IS_12X0(isp) || IS_12160(isp))
#define	IS_ULTRA2(isp)	(IS_1080(isp) || IS_1280(isp) || IS_12160(isp))
#define	IS_ULTRA3(isp)	(IS_12160(isp))

a410 3
#define	IS_2100(isp)	(isp->isp_type == ISP_HA_FC_2100)
#define	IS_2200(isp)	(isp->isp_type == ISP_HA_FC_2200)

d453 5
a457 3
	ISPCTL_FCLINK_TEST,		/* Test FC Link Status */
	ISPCTL_PDB_SYNC,		/* Synchronize Port Database */
	ISPCTL_TOGGLE_TMODE		/* toggle target mode */
d478 2
a479 3
	ISPASYNC_TARGET_MESSAGE,	/* target message */
	ISPASYNC_TARGET_EVENT,		/* target asynchronous event */
	ISPASYNC_TARGET_ACTION		/* other target command action */
@


1.8.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.16 2001/04/04 22:09:39 mjacob Exp $ */
d5 3
a7 1
 * Copyright (c) 1997, 1998, 1999, 2000 by Matthew Jacob
d9 1
a9 1
 *
d16 4
a19 1
 * 2. The name of the author may not be used to endorse or promote products
d61 2
a62 2
#define	ISP_CORE_VERSION_MAJOR	2
#define	ISP_CORE_VERSION_MINOR	1
d69 5
a73 5
	u_int16_t	(*dv_rd_reg) (struct ispsoftc *, int);
	void		(*dv_wr_reg) (struct ispsoftc *, int, u_int16_t);
	int		(*dv_mbxdma) (struct ispsoftc *);
	int		(*dv_dmaset) (struct ispsoftc *,
		XS_T *, ispreq_t *, u_int16_t *, u_int16_t);
d75 11
a85 5
		(struct ispsoftc *, XS_T *, u_int16_t);
	void		(*dv_reset0) (struct ispsoftc *);
	void		(*dv_reset1) (struct ispsoftc *);
	void		(*dv_dregs) (struct ispsoftc *, const char *);
	const u_int16_t	*dv_ispfw;	/* ptr to f/w */
a89 3
/*
 * Overall parameters
 */
d91 1
d93 4
d98 9
a106 1
#define	ISP_MAX_LUNS(isp)	(isp)->isp_maxluns
d110 1
a110 2
 * Macros to access ISP registers through bus specific layers-
 * mostly wrappers to vector through the mdvec structure.
d133 2
a134 2
#define	ISP_DUMPREGS(isp, m)	\
	if ((isp)->isp_mdvec->dv_dregs) (*(isp)->isp_mdvec->dv_dregs)((isp),(m))
d142 1
a142 17
/*
 * The MEMORYBARRIER macro is defined per platform (to provide synchronization
 * on Request and Response Queues, Scratch DMA areas, and Registers)
 *
 * Defined Memory Barrier Synchronization Types
 */
#define	SYNC_REQUEST	0	/* request queue synchronization */
#define	SYNC_RESULT	1	/* result queue synchronization */
#define	SYNC_SFORDEV	2	/* scratch, sync for ISP */
#define	SYNC_SFORCPU	3	/* scratch, sync for CPU */
#define	SYNC_REG	4	/* for registers */

/*
 * Request/Response Queue defines and macros.
 * The maximum is defined per platform (and can be based on board type).
 */
/* This is the size of a queue entry (request and response) */
d144 8
a151 4
/* Both request and result queue length must be a power of two */
#define	RQUEST_QUEUE_LEN(x)		MAXISPREQUEST(x)
#define	RESULT_QUEUE_LEN(x)		\
	(((MAXISPREQUEST(x) >> 2) < 64)? 64 : MAXISPREQUEST(x) >> 2)
d155 1
a155 1
#define	ISP_QFREE(in, out, qlen)	\
a157 2
#define	ISP_QAVAIL(isp)	\
	ISP_QFREE(isp->isp_reqidx, isp->isp_reqodx, RQUEST_QUEUE_LEN(isp))
d160 1
a160 3
	MEMORYBARRIER(isp, SYNC_REQUEST, iptr, QENTRY_LEN); \
	ISP_WRITE(isp, INMAILBOX4, iptr); \
	isp->isp_reqidx = iptr
d176 1
a176 1
			isp_fast_mttr		: 1,	/* fast sram */
d211 2
a212 3
#define	DPARM_NARROW	0x0080
#define	DPARM_ASYNC	0x0040
#define	DPARM_PPR	0x0020
d218 2
a219 4
#define	ISP_80M_SYNCPARMS	0x0c09
#define	ISP_40M_SYNCPARMS	0x0c0a
#define	ISP_20M_SYNCPARMS	0x0c0c
#define	ISP_20M_SYNCPARMS_1040	0x080c
d234 1
a234 2
						: 3,
				isp_iid_set	: 1,
a238 1
				isp_topo	: 3,
a239 1
	u_int8_t		isp_iid;	/* 'initiator' id */
d242 1
a243 2
	volatile u_int16_t	isp_lipseq;	/* LIP sequence # */
	u_int16_t		isp_xxxxxx;
d263 5
a267 7
					loopid		: 8,
							: 2,
					was_fabric_dev	: 1,
					fabric_dev	: 1,
					loggedin	: 1,
					roles		: 2,
					valid		: 1;
d271 1
a271 1
	} portdb[MAX_FC_TARG], tport[FC_PORT_ID];
a291 5
#define	LOOP_SCANNING_FABRIC	3
#define	LOOP_FSCAN_DONE		4
#define	LOOP_SCANNING_LOOP	5
#define	LOOP_LSCAN_DONE		4
#define	LOOP_SYNCING_PDB	6
a293 6
#define	TOPO_NL_PORT		0
#define	TOPO_FL_PORT		1
#define	TOPO_N_PORT		2
#define	TOPO_F_PORT		3
#define	TOPO_PTP_STUB		4

d297 1
a297 1
typedef struct ispsoftc {
a318 1
	u_int32_t		isp_maxluns;	/* maximum luns supported */
d320 1
a320 4
	u_int32_t		isp_clock	: 8,	/* input clock */
						: 6,
				isp_role	: 2,
						: 1,
d322 1
d324 4
a327 10
				isp_loaded_fw	: 1,	/* loaded firmware */
				isp_dblev	: 12;	/* debug log mask */

	u_int32_t		isp_confopts;		/* config options */

	/*
	 * Instrumentation
	 */
	u_int64_t		isp_intcnt;		/* total int count */
	u_int64_t		isp_intbogus;		/* spurious int count */
d333 1
a333 3
	volatile u_int32_t
		isp_mboxbsy	:	8,	/* mailbox command active */
				:	1,
d338 1
a342 2
	volatile u_int16_t	isp_mboxtmp[MAX_MAILBOX];
	volatile u_int16_t	isp_lastmbxcmd;	/* last mbox command sent */
d347 1
a347 1
	XS_T **isp_xflist;
d356 1
a356 1
} ispsoftc_t;
d362 1
a362 1
 * ISP Driver Run States
d376 1
a376 5
#define	ISP_CFG_PORT_PREF	0x0C	/* Mask for Port Prefs (2200 only) */
#define	ISP_CFG_LPORT		0x00	/* prefer {N/F}L-Port connection */
#define	ISP_CFG_NPORT		0x04	/* prefer {N/F}-Port connection */
#define	ISP_CFG_NPORT_ONLY	0x08	/* insist on {N/F}-Port connection */
#define	ISP_CFG_LPORT_ONLY	0x0C	/* insist on {N/F}L-Port connection */
a377 35
/*
 * Prior to calling isp_reset for the first time, the outer layer
 * should set isp_role to one of NONE, INITIATOR, TARGET, BOTH.
 *
 * If you set ISP_ROLE_NONE, the cards will be reset, new firmware loaded,
 * NVRAM read, and defaults set, but any further initialization (e.g.
 * INITIALIZE CONTROL BLOCK commands for 2X00 cards) won't be done.
 *
 * If INITIATOR MODE isn't set, attempts to run commands will be stopped
 * at isp_start and completed with the moral equivalent of SELECTION TIMEOUT.
 *
 * If TARGET MODE is set, it doesn't mean that the rest of target mode support
 * needs to be enabled, or will even work. What happens with the 2X00 cards
 * here is that if you have enabled it with TARGET MODE as part of the ICB
 * options, but you haven't given the f/w any ram resources for ATIOs or
 * Immediate Notifies, the f/w just handles what it can and you never see
 * anything. Basically, it sends a single byte of data (the first byte,
 * which you can set as part of the INITIALIZE CONTROL BLOCK command) for
 * INQUIRY, and sends back QUEUE FULL status for any other command.
 * 
 */
#define	ISP_ROLE_NONE		0x0
#define	ISP_ROLE_INITIATOR	0x1
#define	ISP_ROLE_TARGET		0x2
#define	ISP_ROLE_BOTH		(ISP_ROLE_TARGET|ISP_ROLE_INITIATOR)
#define	ISP_ROLE_EITHER		ISP_ROLE_BOTH
#ifndef	ISP_DEFAULT_ROLES
#define	ISP_DEFAULT_ROLES	ISP_ROLE_INITIATOR
#endif


/*
 * Firmware related defines
 */
#define	ISP_CODE_ORG			0x1000	/* default f/w code start */
d379 1
a379 1
#define	ISP_FW_REVX(xp)			((xp[0]<<24) | (xp[1] << 16) | xp[2])
a420 5
/*
 * DMA cookie macros
 */
#define	DMA_MSW(x)	(((x) >> 16) & 0xffff)
#define	DMA_LSW(x)	(((x) & 0xffff))
d423 1
a423 1
 * Core System Function Prototypes
d430 1
a430 1
void isp_reset(struct ispsoftc *);
d435 1
a435 1
void isp_init(struct ispsoftc *);
d440 1
a440 1
void isp_reinit(struct ispsoftc *);
d445 1
a445 11
int isp_intr(void *);

/*
 * Command Entry Point- Platform Dependent layers call into this
 */
int isp_start(XS_T *);
/* these values are what isp_start returns */
#define	CMD_COMPLETE	101	/* command completed */
#define	CMD_EAGAIN	102	/* busy- maybe retry later */
#define	CMD_QUEUED	103	/* command has been queued for execution */
#define	CMD_RQLATER 	104	/* requeue this command later */
d448 1
a448 1
 * Command Completion Point- Core layers call out from this with completed cmds
d450 1
a450 1
void isp_done(XS_T *);
d455 1
a455 2
 * Assumes locks are held on entry. You should note that with many of
 * these commands and locks may be released while this is occurring.
a456 27
 * A few notes about some of these functions:
 *
 * ISPCTL_FCLINK_TEST tests to make sure we have good fibre channel link.
 * The argument is a pointer to an integer which is the time, in microseconds,
 * we should wait to see whether we have good link. This test, if successful,
 * lets us know our connection topology and our Loop ID/AL_PA and so on.
 * You can't get anywhere without this.
 *
 * ISPCTL_SCAN_FABRIC queries the name server (if we're on a fabric) for
 * all entities using the FC Generic Services subcommand GET ALL NEXT.
 * For each found entity, an ISPASYNC_FABRICDEV event is generated (see
 * below).
 *
 * ISPCTL_SCAN_LOOP does a local loop scan. This is only done if the connection
 * topology is NL or FL port (private or public loop). Since the Qlogic f/w
 * 'automatically' manages local loop connections, this function essentially
 * notes the arrival, departure, and possible shuffling around of local loop
 * entities. Thus for each arrival and departure this generates an isp_async
 * event of ISPASYNC_PROMENADE (see below).
 *
 * ISPCTL_PDB_SYNC is somewhat misnamed. It actually is the final step, in
 * order, of ISPCTL_FCLINK_TEST, ISPCTL_SCAN_FABRIC, and ISPCTL_SCAN_LOOP.
 * The main purpose of ISPCTL_PDB_SYNC is to complete management of logging
 * and logging out of fabric devices (if one is on a fabric) and then marking
 * the 'loop state' as being ready to now be used for sending commands to
 * devices. Originally fabric name server and local loop scanning were
 * part of this function. It's now been seperated to allow for finer control.
d462 1
a462 1
	ISPCTL_UPDATE_PARAMS,		/* Update Operating Parameters (SCSI) */
a463 2
	ISPCTL_SCAN_FABRIC,		/* (Re)scan Fabric Name Server */
	ISPCTL_SCAN_LOOP,		/* (Re)scan Local Loop */
a464 3
	ISPCTL_SEND_LIP,		/* Send a LIP */
	ISPCTL_GET_POSMAP,		/* Get FC-AL position map */
	ISPCTL_RUN_MBOXCMD,		/* run a mailbox command */
d467 1
a467 1
int isp_control(struct ispsoftc *, ispctl_t, void *);
d474 1
a474 10
 * Assumes locks are held.
 *
 * A few notes about some of these functions:
 *
 * ISPASYNC_CHANGE_NOTIFY notifies the outer layer that a change has
 * occurred that invalidates the list of fabric devices known and/or
 * the list of known loop devices. The argument passed is a pointer
 * whose values are defined below  (local loop change, name server
 * change, other). 'Other' may simply be a LIP, or a change in
 * connection topology.
a475 24
 * ISPASYNC_FABRIC_DEV announces the next element in a list of
 * fabric device names we're getting out of the name server. The
 * argument points to a GET ALL NEXT response structure. The list
 * is known to terminate with an entry that refers to ourselves.
 * One of the main purposes of this function is to allow outer
 * layers, which are OS dependent, to set policy as to which fabric
 * devices might actually be logged into (and made visible) later
 * at ISPCTL_PDB_SYNC time. Since there's a finite number of fabric
 * devices that we can log into (256 less 3 'reserved' for F-port
 * topologies), and fabrics can grow up to 8 million or so entries
 * (24 bits of Port Address, less a wad of reserved spaces), clearly
 * we had better let the OS determine login policy.
 *
 * ISPASYNC_PROMENADE has an argument that is a pointer to an integer which
 * is an index into the portdb in the softc ('target'). Whether that entrie's
 * valid tag is set or not says whether something has arrived or departed.
 * The name refers to a favorite pastime of many city dwellers- watching
 * people come and go, talking of Michaelangelo, and so on..
 *
 * ISPASYNC_UNHANDLED_RESPONSE gives outer layers a chance to parse a
 * response queue entry not otherwise handled. The outer layer should
 * return non-zero if it handled it. The 'arg' points to a (possibly only
 * partially) massaged response queue entry (see the platform's
 * ISP_UNSWIZZLE_RESPONSE macro).
d479 1
a479 1
	ISPASYNC_NEW_TGT_PARAMS,	/* New Target Parameters Negotiated */
d483 3
a485 3
	ISPASYNC_CHANGE_NOTIFY,		/* FC Change Notification */
	ISPASYNC_FABRIC_DEV,		/* FC Fabric Device Arrival */
	ISPASYNC_PROMENADE,		/* FC Objects coming && going */
d488 1
a488 3
	ISPASYNC_TARGET_ACTION,		/* other target command action */
	ISPASYNC_CONF_CHANGE,		/* Platform Configuration Change */
	ISPASYNC_UNHANDLED_RESPONSE	/* Unhandled Response Entry */
d490 1
a490 5
int isp_async(struct ispsoftc *, ispasync_t, void *);

#define	ISPASYNC_CHANGE_PDB	((void *) 0)
#define	ISPASYNC_CHANGE_SNS	((void *) 1)
#define	ISPASYNC_CHANGE_OTHER	((void *) 2)
d493 1
a493 1
 * Platform Dependent Error and Debug Printout
d495 1
a495 6
#ifdef	__GNUC__
void isp_prt(struct ispsoftc *, int level, const char *, ...)
	__attribute__((__format__(__printf__,3,4)));
#else
void isp_prt(struct ispsoftc *, int level, const char *, ...);
#endif
a496 130
#define	ISP_LOGALL	0x0	/* log always */
#define	ISP_LOGCONFIG	0x1	/* log configuration messages */
#define	ISP_LOGINFO	0x2	/* log informational messages */
#define	ISP_LOGWARN	0x4	/* log warning messages */
#define	ISP_LOGERR	0x8	/* log error messages */
#define	ISP_LOGDEBUG0	0x10	/* log simple debug messages */
#define	ISP_LOGDEBUG1	0x20	/* log intermediate debug messages */
#define	ISP_LOGDEBUG2	0x40	/* log most debug messages */
#define	ISP_LOGDEBUG3	0x100	/* log high frequency debug messages */
#define	ISP_LOGTDEBUG0	0x200	/* log simple debug messages (target mode) */
#define	ISP_LOGTDEBUG1	0x400	/* log intermediate debug messages (target) */
#define	ISP_LOGTDEBUG2	0x800	/* log all debug messages (target) */

/*
 * Each Platform provides it's own isposinfo substructure of the ispsoftc
 * defined above.
 *
 * Each platform must also provide the following macros/defines:
 *
 *
 *	INLINE		-	platform specific define for 'inline' functions
 *
 *	ISP2100_SCRLEN	-	length for the Fibre Channel scratch DMA area
 *
 *	MEMZERO(dst, src)			platform zeroing function
 *	MEMCPY(dst, src, count)			platform copying function
 *	SNPRINTF(buf, bufsize, fmt, ...)	snprintf
 *	STRNCAT(dstbuf, size, srcbuf)		strncat
 *	USEC_DELAY(usecs)			microsecond spindelay function
 *	USEC_SLEEP(isp, usecs)			microsecond sleep function
 *
 *	NANOTIME_T				nanosecond time type
 *
 *	GET_NANOTIME(NANOTIME_T *)		get current nanotime.
 *
 *	GET_NANOSEC(NANOTIME_T *)		get u_int64_t from NANOTIME_T
 *
 *	NANOTIME_SUB(NANOTIME_T *, NANOTIME_T *)
 *						subtract two NANOTIME_T values
 *
 *
 *	MAXISPREQUEST(struct ispsoftc *)	maximum request queue size
 *						for this particular board type
 *
 *	MEMORYBARRIER(struct ispsoftc *, barrier_type, offset, size)
 *
 *		Function/Macro the provides memory synchronization on
 *		various objects so that the ISP's and the system's view
 *		of the same object is consistent.
 *
 *	MBOX_ACQUIRE(struct ispsoftc *)		acquire lock on mailbox regs
 *	MBOX_WAIT_COMPLETE(struct ispsoftc *)	wait for mailbox cmd to be done
 *	MBOX_NOTIFY_COMPLETE(struct ispsoftc *)	notification of mbox cmd donee
 *	MBOX_RELEASE(struct ispsoftc *)		release lock on mailbox regs
 *
 *
 *	SCSI_GOOD	SCSI 'Good' Status
 *	SCSI_CHECK	SCSI 'Check Condition' Status
 *	SCSI_BUSY	SCSI 'Busy' Status
 *	SCSI_QFULL	SCSI 'Queue Full' Status
 *
 *	XS_T		Platform SCSI transaction type (i.e., command for HBA)
 *	XS_ISP(xs)	gets an instance out of an XS_T
 *	XS_CHANNEL(xs)	gets the channel (bus # for DUALBUS cards) ""
 *	XS_TGT(xs)	gets the target ""
 *	XS_LUN(xs)	gets the lun ""
 *	XS_CDBP(xs)	gets a pointer to the scsi CDB ""
 *	XS_CDBLEN(xs)	gets the CDB's length ""
 *	XS_XFRLEN(xs)	gets the associated data transfer length ""
 *	XS_TIME(xs)	gets the time (in milliseconds) for this command
 *	XS_RESID(xs)	gets the current residual count
 *	XS_STSP(xs)	gets a pointer to the SCSI status byte ""
 *	XS_SNSP(xs)	gets a pointer to the associate sense data
 *	XS_SNSLEN(xs)	gets the length of sense data storage
 *	XS_SNSKEY(xs)	dereferences XS_SNSP to get the current stored Sense Key
 *	XS_TAG_P(xs)	predicate of whether this command should be tagged
 *	XS_TAG_TYPE(xs)	which type of tag to use
 *	XS_SETERR(xs)	set error state
 *
 *		HBA_NOERROR	command has no erros
 *		HBA_BOTCH	hba botched something
 *		HBA_CMDTIMEOUT	command timed out
 *		HBA_SELTIMEOUT	selection timed out (also port logouts for FC)
 *		HBA_TGTBSY	target returned a BUSY status
 *		HBA_BUSRESET	bus reset destroyed command
 *		HBA_ABORTED	command was aborted (by request)
 *		HBA_DATAOVR	a data overrun was detected
 *		HBA_ARQFAIL	Automatic Request Sense failed
 *
 *	XS_ERR(xs)	return current error state
 *	XS_NOERR(xs)	there is no error currently set
 *	XS_INITERR(xs)	initialize error state
 *
 *	XS_SAVE_SENSE(xs, sp)		save sense data
 *
 *	XS_SET_STATE_STAT(isp, sp, xs)	platform dependent interpreter of
 *					response queue entry status bits
 *
 *
 *	DEFAULT_IID(struct ispsoftc *)		Default SCSI initiator ID
 *	DEFAULT_LOOPID(struct ispsoftc *)	Default FC Loop ID
 *	DEFAULT_NODEWWN(struct ispsoftc *)	Default Node WWN
 *	DEFAULT_PORTWWN(struct ispsoftc *)	Default Port WWN
 *		These establish reasonable defaults for each platform.
 * 		These must be available independent of card NVRAM and are
 *		to be used should NVRAM not be readable.
 *
 *	ISP_NODEWWN(struct ispsoftc *)	FC Node WWN to use
 *	ISP_PORTWWN(struct ispsoftc *)	FC Port WWN to use
 *
 *		These are to be used after NVRAM is read. The tags
 *		in fcparam.isp_{node,port}wwn reflect the values
 *		read from NVRAM (possibly corrected for card botches).
 *		Each platform can take that information and override
 *		it or ignore and return the Node and Port WWNs to be
 * 		used when sending the Qlogic f/w the Initialization Control
 *		Block.
 *
 *	(XXX these do endian specific transformations- in transition XXX)
 *	ISP_SWIZZLE_ICB
 *	ISP_UNSWIZZLE_AND_COPY_PDBP
 *	ISP_SWIZZLE_CONTINUATION
 *	ISP_SWIZZLE_REQUEST
 *	ISP_UNSWIZZLE_RESPONSE
 *	ISP_SWIZZLE_SNS_REQ
 *	ISP_UNSWIZZLE_SNS_RSP
 *	ISP_SWIZZLE_NVRAM_WORD
 *
 *
 */
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.8.2.2 2001/05/14 22:23:58 niklas Exp $ */
d57 1
a57 1
#define	ISP_CORE_VERSION_MINOR	4
a63 2
	int		(*dv_rd_isr)
	    (struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
d68 1
a68 1
	    XS_T *, ispreq_t *, u_int16_t *, u_int16_t);
d70 1
a70 1
	    (struct ispsoftc *, XS_T *, u_int16_t);
d82 2
a83 2
#define	MAX_TARGETS		16
#define	MAX_FC_TARG		256
a86 6
/*
 * 'Types'
 */
#ifndef	ISP_DMA_ADDR_T
#define	ISP_DMA_ADDR_T	u_int32_t
#endif
a91 2
#define	ISP_READ_ISR(isp, isrp, semap, mbox0p)	\
	(*(isp)->isp_mdvec->dv_rd_isr)(isp, isrp, semap, mbox0p)
d155 1
a155 1
	WRITE_REQUEST_QUEUE_IN_POINTER(isp, iptr); \
d182 1
a182 2
		u_int32_t	
			exc_throttle	:	8,
a183 1
			dev_enable	:	1,	/* ignored */
d186 7
a192 9
			actv_offset	:	4,
			goal_offset	:	4,
			nvrm_offset	:	4;
		u_int8_t	actv_period;	/* current sync period */
		u_int8_t	goal_period;	/* goal sync period */
		u_int8_t	nvrm_period;	/* nvram sync period */
		u_int16_t	actv_flags;	/* current device flags */
		u_int16_t	goal_flags;	/* goal device flags */
		u_int16_t	nvrm_flags;	/* nvram device flags */
d233 1
a233 1
				isp_gbspeed	: 2,
d236 1
a236 1
				isp_loopstate	: 4,	/* Current Loop State */
d246 1
a246 1
	u_int16_t		isp_fwattr;	/* firmware attributes */
d267 1
a267 2
							: 1,
					force_logout	: 1,
d282 1
a282 1
	ISP_DMA_ADDR_T		isp_scdma;
d300 3
a302 3
#define	LOOP_LSCAN_DONE		6
#define	LOOP_SYNCING_PDB	7
#define	LOOP_READY		8
a347 5
	u_int16_t		isp_rqstinrp;	/* register for REQINP */
	u_int16_t		isp_rqstoutrp;	/* register for REQOUTP */
	u_int16_t		isp_respinrp;	/* register for RESINP */
	u_int16_t		isp_respoutrp;	/* register for RESOUTP */

d382 2
a383 2
	ISP_DMA_ADDR_T		isp_rquest_dma;
	ISP_DMA_ADDR_T		isp_result_dma;
a401 2
#define	ISP_CFG_TWOGB		0x20	/* force 2GB connection (23XX only) */
#define	ISP_CFG_ONEGB		0x10	/* force 1GB connection (23XX only) */
d429 1
a429 1
 *
a444 1
#define	ISP_CODE_ORG_2300		0x0800	/* ..except for 2300s */
a445 3
#define	ISP_FW_MAJOR(code)		((code >> 24) & 0xff)
#define	ISP_FW_MINOR(code)		((code >> 16) & 0xff)
#define	ISP_FW_MICRO(code)		((code >>  8) & 0xff)
a446 3
#define	ISP_FW_MAJORX(xp)		(xp[0])
#define	ISP_FW_MINORX(xp)		(xp[1])
#define	ISP_FW_MICROX(xp)		(xp[2])
a471 1
#define	ISP_HA_FC_2300		0x30
d484 3
a486 4
#define	IS_FC(isp)	((isp)->isp_type & ISP_HA_FC)
#define	IS_2100(isp)	((isp)->isp_type == ISP_HA_FC_2100)
#define	IS_2200(isp)	((isp)->isp_type == ISP_HA_FC_2200)
#define	IS_2300(isp)	((isp)->isp_type >= ISP_HA_FC_2300)
d491 2
a492 4
#define	DMA_WD3(x)	0
#define	DMA_WD2(x)	0
#define	DMA_WD1(x)	(((x) >> 16) & 0xffff)
#define	DMA_WD0(x)	(((x) & 0xffff))
d515 1
a515 5
 * Internal Interrupt Service Routine
 *
 * The outer layers do the spade work to get the appropriate status register,
 * semaphore register and first mailbox register (if appropriate). This also
 * means that most spurious/bogus interrupts not for us can be filtered first.
d517 1
a517 2
void isp_intr(struct ispsoftc *, u_int16_t, u_int16_t, u_int16_t);

d566 1
a566 1
 * part of this function. It's now been separated to allow for finer control.
a630 2
	ISPASYNC_LIP,			/* LIP Received */
	ISPASYNC_LOOP_RESET,		/* Loop Reset Received */
d638 1
a638 2
	ISPASYNC_UNHANDLED_RESPONSE,	/* Unhandled Response Entry */
	ISPASYNC_FW_CRASH		/* Firmware has crashed */
d664 1
a664 2
#define	ISP_LOGDEBUG3	0x80	/* log high frequency debug messages */
#define	ISP_LOGDEBUG4	0x100	/* log high frequency debug messages */
a677 5
 *	ISP_DMA_ADDR_T	-	platform specific dma address coookie- basically
 *				the largest integer that can hold the 32 or
 *				64 bit value appropriate for the QLogic's DMA
 *				addressing. Defaults to u_int32_t.
 *
d783 2
a785 1

@


1.8.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d57 1
a57 1
#define	ISP_CORE_VERSION_MINOR	5
d163 4
a166 4
#define	ISP_ADD_REQUEST(isp, nxti)					\
	MEMORYBARRIER(isp, SYNC_REQUEST, isp->isp_reqidx, QENTRY_LEN);	\
	WRITE_REQUEST_QUEUE_IN_POINTER(isp, nxti);			\
	isp->isp_reqidx = nxti
d353 3
a355 3
						: 5,
				isp_failed	: 1,	/* board failed */
				isp_open	: 1,	/* opened (ioctl) */
a358 1
				isp_role	: 2,	/* roles supported */
d379 2
a380 2
		isp_obits	:	8,	/* mailbox command output */
		isp_mboxbsy	:	1,	/* mailbox command active */
a483 8
 * If we have not otherwise defined SBus support away make sure
 * it is defined here such that the code is included as default
 */
#ifndef	ISP_SBUS_SUPPORTED
#define	ISP_SBUS_SUPPORTED	1
#endif

/*
d659 3
a661 2
 * return non-zero if it handled it. The 'arg' points to an unmassaged
 * response queue entry.
d822 8
a829 10
 *
 *	ISP_IOXPUT_8(struct ispsoftc *, u_int8_t srcval, u_int8_t *dstptr)
 *	ISP_IOXPUT_16(struct ispsoftc *, u_int16_t srcval, u_int16_t *dstptr)
 *	ISP_IOXPUT_32(struct ispsoftc *, u_int32_t srcval, u_int32_t *dstptr)
 *
 *	ISP_IOXGET_8(struct ispsoftc *, u_int8_t *srcptr, u_int8_t dstrval)
 *	ISP_IOXGET_16(struct ispsoftc *, u_int16_t *srcptr, u_int16_t dstrval)
 *	ISP_IOXGET_32(struct ispsoftc *, u_int32_t *srcptr, u_int32_t dstrval)
 *
 *	ISP_SWIZZLE_NVRAM_WORD(struct ispsoftc *, u_int16_t *)
@


1.8.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*     $OpenBSD$ */
d57 1
a57 1
#define	ISP_CORE_VERSION_MINOR	7
d76 1
a76 1
	u_int16_t	*dv_ispfw;	/* ptr to f/w */
d92 2
a93 4
#ifdef	ISP_DAC_SUPPORTED
typedef	u_int64_t	isp_dma_addr_t;
#else
typedef	u_int32_t	isp_dma_addr_t;
a151 3
#ifdef	ISP_TARGET_MODE
#define	RESULT_QUEUE_LEN(x)		MAXISPREQUEST(x)
#else
a153 1
#endif
a244 5
/* #define	ISP_USE_GA_NXT	1 */	/* Use GA_NXT with switches */
#ifndef	GA_NXT_MAX
#define	GA_NXT_MAX	256
#endif

d279 1
a279 2
		u_int32_t
					port_type	: 8,
d281 1
a281 4
					fc4_type	: 4,
					last_fabric_dev	: 1,
							: 2,
					relogin		: 1,
d297 1
a297 4
	isp_dma_addr_t		isp_scdma;
#ifdef	ISP_FW_CRASH_DUMP
	u_int16_t		*isp_dump_data;
#endif
d353 1
a353 2
						: 4,
				isp_port	: 1,	/* 23XX only */
a373 6
	u_int64_t		isp_intmboxc;		/* mbox completions */
	u_int64_t		isp_intoasync;		/* other async */
	u_int64_t		isp_rsltccmplt;		/* CMDs on result q */
	u_int64_t		isp_fphccmplt;		/* CMDs via fastpost */
	u_int16_t		isp_rscchiwater;
	u_int16_t		isp_fpcchiwater;
a388 2
	volatile u_int16_t	isp_resodx;	/* index of next result */
	volatile u_int16_t	isp_rspbsy;
a391 4
	volatile u_int16_t	isp_mbxwrk0;
	volatile u_int16_t	isp_mbxwrk1;
	volatile u_int16_t	isp_mbxwrk2;
	void *			isp_mbxworkp;
d403 2
a404 2
	isp_dma_addr_t		isp_rquest_dma;
	isp_dma_addr_t		isp_result_dma;
d426 1
a431 5
#define	ISP_CFG_OWNWWPN		0x100	/* override NVRAM wwpn */
#define	ISP_CFG_OWNWWNN		0x200	/* override NVRAM wwnn */
#define	ISP_CFG_OWNFSZ		0x400	/* override NVRAM frame size */
#define	ISP_CFG_OWNLOOPID	0x800	/* override NVRAM loopid */
#define	ISP_CFG_OWNEXCTHROTTLE	0x1000	/* override NVRAM execution throttle */
a476 2
#define	ISP_FW_NEWER_THAN(i, major, minor, micro)		\
 (ISP_FW_REVX((i)->isp_fwrev) > ISP_FW_REV(major, minor, micro))
d506 1
a506 2
#define	ISP_HA_SCSI_10160	0xb
#define	ISP_HA_SCSI_12160	0xc
a510 1
#define	ISP_HA_FC_2312		0x40
a515 1
#define	IS_10160(isp)	(isp->isp_type == ISP_HA_SCSI_10160)
a518 1
#define	IS_1X160(isp)	(IS_10160(isp) || IS_12160(isp))
d520 2
a521 2
#define	IS_ULTRA2(isp)	(IS_1080(isp) || IS_1280(isp) || IS_1X160(isp))
#define	IS_ULTRA3(isp)	(IS_1X160(isp))
d526 1
a526 3
#define	IS_23XX(isp)	((isp)->isp_type >= ISP_HA_FC_2300)
#define	IS_2300(isp)	((isp)->isp_type == ISP_HA_FC_2300)
#define	IS_2312(isp)	((isp)->isp_type == ISP_HA_FC_2312)
a530 4
#ifdef	ISP_DAC_SUPPORTRED
#define	DMA_WD3(x)	(((x) >> 48) & 0xffff)
#define	DMA_WD2(x)	(((x) >> 32) & 0xffff)
#else
a532 1
#endif
a555 7
#ifdef	ISP_FW_CRASH_DUMP
/*
 * Dump firmware entry point.
 */
void isp_fw_dump(struct ispsoftc *isp);
#endif

d661 1
a661 1
 * is an index into the portdb in the softc ('target'). Whether that entry's
d687 1
a687 3
	ISPASYNC_FW_CRASH,		/* Firmware has crashed */
	ISPASYNC_FW_DUMPED,		/* Firmware crashdump taken */
	ISPASYNC_FW_RESTARTED		/* Firmware has been restarted */
d728 4
a731 4
 *	ISP_DAC_SUPPORTED -	Is DAC (Dual Address Cycle) is supported?
 *				Basically means whether or not DMA for PCI
 *				PCI cards (Ultra2 or better or FC) works
 *				above 4GB.
d738 1
a765 2
 *	FC_SCRATCH_ACQUIRE(struct ispsoftc *)	acquire lock on FC scratch area
 *	FC_SCRATCH_RELEASE(struct ispsoftc *)	acquire lock on FC scratch area
a813 2
 *	DEFAULT_FRAMESIZE(struct ispsoftc *)	Default Frame Size
 *	DEFAULT_EXEC_THROTTLE(struct ispsoftc *) Default Execution Throttle
@


1.7
log
@Far too many things to note- a complete new revision coming in including
FABRIC support...
@
text
@d1 1
a1 1
/*	$OpenBSD: ispvar.h,v 1.6 1999/04/04 02:07:27 mjacob Exp $ */
d394 3
a396 2
#define	ISP_HA_SCSI_1080	0xd
#define	ISP_HA_SCSI_12X0	0xe
d402 1
d404 6
a409 1
#define	IS_12X0(isp)	(isp->isp_type == ISP_HA_SCSI_12X0)
@


1.6
log
@Roll out changes because the tree is frozen.
@
text
@d1 1
a1 2
/*	$OpenBSD: ispvar.h,v 1.5 1999/04/04 01:28:26 mjacob Exp $ */
/* release_03_25_99 */
d6 1
a6 1
 * Copyright (c) 1997, 1998 by Matthew Jacob
d41 3
d47 3
d53 3
d59 1
a59 1
#define	ISP_CORE_VERSION_MINOR	7
d70 1
a70 1
		ISP_SCSI_XFER_T *, ispreq_t *, u_int8_t *, u_int8_t));
d79 1
a79 1
	u_int16_t	dv_fwrev;	/* f/w revision */
a92 1
#define	DEFAULT_LOOPID	113
d94 46
a139 1
/* queue length must be a power of two */
d141 1
d143 2
d146 3
d152 1
a152 1
#define ISP_QAVAIL(in, out, qlen)	\
d154 5
a158 1
		((qlen - 1) - (in - out)) : (out - in - 1)))
d160 1
a160 1
 * SCSI Specific Host Adapter Parameters
d164 3
a166 2
        u_int		isp_req_ack_active_neg	: 1,	
	        	isp_data_line_active_neg: 1,
d173 1
a173 1
			isp_fast_mttr		: 1,
d175 3
a177 4
        		isp_async_data_setup	: 4;
        u_int16_t	isp_selection_timeout;
        u_int16_t	isp_max_queue_depth;
	u_int16_t	isp_clock;
d179 3
a181 3
       	u_int8_t	isp_bus_reset_delay;
        u_int8_t	isp_retry_count;
        u_int8_t	isp_retry_delay;
d183 2
a184 3
		u_int
			dev_enable	:	1,
			dev_announced	:	1,
d195 1
a195 1
} sdparam;	/* scsi device parameters */
d216 5
a220 5
#define ISP_20M_SYNCPARMS	0x080c
#define ISP_10M_SYNCPARMS	0x0c19
#define ISP_08M_SYNCPARMS	0x0c25
#define ISP_05M_SYNCPARMS	0x0c32
#define ISP_04M_SYNCPARMS	0x0c41
d225 4
d230 7
a236 1
	u_int64_t		isp_wwn;	/* WWN of adapter */
d239 2
d242 3
a244 3
        u_int8_t		isp_retry_delay;
        u_int8_t		isp_retry_count;
	u_int8_t		isp_fwstate;	/* ISP F/W state */
d247 2
a248 1
	u_int16_t		isp_fwoptions;
d250 7
a256 1
	 * Port Data Base
d258 11
a268 1
	isp_pdb_t		isp_pdb[MAX_FC_TARG];
d273 1
a273 1
	volatile caddr_t	isp_scratch;
d277 13
a289 46
#define	ISP2100_SCRLEN		0x100

#define	FW_CONFIG_WAIT		0x0000
#define	FW_WAIT_AL_PA		0x0001
#define	FW_WAIT_LOGIN		0x0002
#define	FW_READY		0x0003
#define	FW_LOSS_OF_SYNC		0x0004
#define	FW_ERROR		0x0005
#define	FW_REINIT		0x0006
#define	FW_NON_PART		0x0007

#ifdef	ISP_TARGET_MODE
/*
 * Some temporary Target Mode definitions
 */
typedef struct tmd_cmd {
	u_int8_t	cd_iid;		/* initiator */
	u_int8_t	cd_tgt;		/* target */
	u_int8_t	cd_lun;		/* LUN for this command */
	u_int8_t	cd_state;
	u_int8_t	cd_cdb[16];	/* command bytes */
	u_int8_t	cd_sensedata[20];
	u_int16_t	cd_rxid;
	u_int32_t	cd_datalen;
	u_int32_t	cd_totbytes;
	void *		cd_hba;
} tmd_cmd_t;

/*
 * Async Target Mode Event Definitions
 */
#define	TMD_BUS_RESET	0
#define	TMD_BDR		1

/*
 * Immediate Notify data structure.
 */
#define NOTIFY_MSGLEN	5
typedef struct {
	u_int8_t	nt_iid;			/* initiator */
	u_int8_t	nt_tgt;			/* target */
	u_int8_t	nt_lun;			/* LUN for this command */
	u_int8_t	nt_msg[NOTIFY_MSGLEN];	/* SCSI message byte(s) */
} tmd_notify_t;

#endif
d301 1
a301 1
	 * Pointer to bus specific data
d306 2
a307 1
	 * Mostly nonvolatile state, debugging, etc..
d310 15
a324 13
	u_int				: 8,
			isp_confopts	: 8,
			isp_port	: 1,	/* for dual ported impls */
			isp_used	: 1,
			isp_dblev	: 3,
			isp_gotdparms	: 1,
			isp_dogactive	: 1,
			isp_bustype	: 1,	/* BUS Implementation */
			isp_type	: 8;	/* HBA Type and Revision */

	u_int16_t		isp_fwrev;	/* Running F/W revision */
	u_int16_t		isp_romfw_rev;	/* 'ROM' F/W revision */
	void * 			isp_param;
d330 1
a330 2
	volatile u_int
				:	19,
d332 3
a334 3
		isp_sendmarker	:	1,	/* send a marker entry */
		isp_update	:	1,	/* update parameters */
		isp_nactive	:	9;	/* how many commands active */
d336 4
a339 7
	/*
	 * Result and Request Queue indices.
	 */
	volatile u_int8_t	isp_reqodx;	/* index of last ISP pickup */
	volatile u_int8_t	isp_reqidx;	/* index of next request */
	volatile u_int8_t	isp_residx;	/* index of next result */
	volatile u_int8_t	isp_seqno;	/* rolling sequence # */
d342 1
a342 7
	 * Sheer laziness, but it gets us around the problem
	 * where we don't have a clean way of remembering
	 * which transaction is bound to which ISP queue entry.
	 *
	 * There are other more clever ways to do this, but,
	 * jeez, so I blow a couple of KB per host adapter...
	 * and it *is* faster.
d344 1
a344 1
	ISP_SCSI_XFER_T *isp_xflist[RQUEST_QUEUE_LEN];
d347 1
a347 1
	 * request/result queues and dma handles for them.
d349 2
a350 2
	volatile caddr_t	isp_rquest;
	volatile caddr_t	isp_result;
d353 1
d355 2
a356 22
#ifdef	ISP_TARGET_MODE
	/*
	 * Vectors for handling target mode support.
	 *
	 * isp_tmd_newcmd is for feeding a newly arrived command to some
	 * upper layer.
	 *
	 * isp_tmd_event is for notifying some upper layer that an event has
	 * occurred that is not necessarily tied to any target (e.g., a SCSI
	 * Bus Reset).
	 *
	 * isp_tmd_notify is for notifying some upper layer that some
	 * event is now occurring that is either pertinent for a specific
	 * device or for a specific command (e.g., BDR or ABORT TAG).
	 *
	 * It is left undefined (for now) how pools of commands are managed.
	 */
	void		(*isp_tmd_newcmd) __P((void *, tmd_cmd_t *));
	void		(*isp_tmd_event) __P((void *, int));
	void		(*isp_tmd_notify) __P((void *, tmd_notify_t *));
#endif	   
};
d371 2
d374 2
a375 1
#define	ISP_FW_REV(maj, min)	((maj) << 10| (min))
d393 1
d398 1
a405 33
 * Macros to read, write ISP registers through bus specific code.
 */

#define	ISP_READ(isp, reg)	\
	(*(isp)->isp_mdvec->dv_rd_reg)((isp), (reg))

#define	ISP_WRITE(isp, reg, val)	\
	(*(isp)->isp_mdvec->dv_wr_reg)((isp), (reg), (val))

#define	ISP_MBOXDMASETUP(isp)	\
	(*(isp)->isp_mdvec->dv_mbxdma)((isp))

#define	ISP_DMASETUP(isp, xs, req, iptrp, optr)	\
	(*(isp)->isp_mdvec->dv_dmaset)((isp), (xs), (req), (iptrp), (optr))

#define	ISP_DMAFREE(isp, xs, seqno)	\
	if ((isp)->isp_mdvec->dv_dmaclr) \
		 (*(isp)->isp_mdvec->dv_dmaclr)((isp), (xs), (seqno))

#define	ISP_RESET0(isp)	\
	if ((isp)->isp_mdvec->dv_reset0) (*(isp)->isp_mdvec->dv_reset0)((isp))
#define	ISP_RESET1(isp)	\
	if ((isp)->isp_mdvec->dv_reset1) (*(isp)->isp_mdvec->dv_reset1)((isp))
#define	ISP_DUMPREGS(isp)	\
	if ((isp)->isp_mdvec->dv_dregs) (*(isp)->isp_mdvec->dv_dregs)((isp))

#define	ISP_SETBITS(isp, reg, val)	\
 (*(isp)->isp_mdvec->dv_wr_reg)((isp), (reg), ISP_READ((isp), (reg)) | (val))

#define	ISP_CLRBITS(isp, reg, val)	\
 (*(isp)->isp_mdvec->dv_wr_reg)((isp), (reg), ISP_READ((isp), (reg)) & ~(val))

/*
d438 1
a438 4
 * For: 	Aborting a running command	- arg is an ISP_SCSI_XFER_T *
 *		Resetting a Device		- arg is target to reset
 *		Resetting a BUS			- arg is ignored
 *		Updating parameters		- arg is ignored
a439 3
 * First argument is this instance's softc pointer.
 * Second argument is an index into xflist array.
 * Assumes all locks must be held already.
d442 9
a450 5
	ISPCTL_RESET_BUS,
	ISPCTL_RESET_DEV,
	ISPCTL_ABORT_CMD,
	ISPCTL_UPDATE_PARAMS,
	ISPCTL_FCLINK_TEST
d459 1
a459 1
 * For: 	Announcing Target Paramter Changes (arg is target)
a460 1
 * Assumes all locks are held.
d465 8
a472 5
	ISPASYNC_BUS_RESET,		/* Bus Reset */
	ISPASYNC_LOOP_DOWN,		/* Obvious FC only */
	ISPASYNC_LOOP_UP,		/* "" */
	ISPASYNC_PDB_CHANGE_COMPLETE,	/* "" */
	ISPASYNC_CHANGE_NOTIFY		/* "" */
a479 1

@


1.5
log
@Change f/w revision to major,minor,micro version. Add in ISP1040C definition.
@
text
@d1 2
a2 2
/*	$OpenBSD: ispvar.h,v 1.4 1999/03/25 22:58:39 mjacob Exp $ */
/* release_4_3_99 */
d262 2
a263 2
	u_int16_t		isp_fwrev[3];	/* Running F/W revision */
	u_int16_t		isp_romfw_rev[3]; /* 'ROM' F/W revision */
d341 1
a341 2
#define	ISP_FW_REV(maj, min, mic)	((maj << 24) | (min << 16) | mic)
#define	ISP_FW_REVX(xp)	((xp[0 ]<< 24) | (xp[1] << 16) | xp[2])
a342 1
 
a358 1
#define	ISP_HA_SCSI_1040C	0x7
@


1.4
log
@roll internal revision levels and enable 1080 support
@
text
@d1 2
a2 2
/*	$OpenBSD: ispvar.h,v 1.3 1999/03/17 12:54:32 mjacob Exp $ */
/* release_03_25_99 */
d262 2
a263 2
	u_int16_t		isp_fwrev;	/* Running F/W revision */
	u_int16_t		isp_romfw_rev;	/* 'ROM' F/W revision */
d341 2
a342 1
#define	ISP_FW_REV(maj, min)	((maj) << 10| (min))
d344 1
d361 1
@


1.3
log
@fix OpenBSD headers
@
text
@d1 2
a2 2
/*	$OpenBSD: ispvar.h,v 1.2 1999/03/17 05:26:09 mjacob Exp $ */
/* release_03_16_99 */
d51 1
a51 1
#define	ISP_CORE_VERSION_MINOR	6
d109 1
d126 7
a132 5
			exc_throttle	:	7,
			sync_offset	:	4,
			sync_period	:	8;
		u_int16_t dev_flags;		/* persistent device flags */
		u_int16_t cur_dflags;		/* current device flags */
d153 2
d254 1
a254 1
					: 1,
d359 2
a360 1
#define	ISP_HA_SCSI_1080	0xe
d366 1
@


1.2
log
@complete update of ISP driver- includes 2100 FC support
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
@


1.1
log
@add isp driver from netbsd, more munging needed
@
text
@d1 2
a2 2
/*	$NetBSD: ispvar.h,v 1.4 1997/04/05 02:48:36 mjacob Exp $	*/

d6 2
a7 1
 * Copyright (c) 1997 by Matthew Jacob
d10 1
a10 1
 *
d34 1
d40 1
d42 10
d54 1
a54 1
 * Vector for MD code to provide specific services.
d62 1
a62 1
		struct scsi_xfer *, ispreq_t *, u_int8_t *, u_int8_t));
d64 1
a64 1
		__P((struct ispsoftc *, struct scsi_xfer *, u_int32_t));
d67 1
d71 1
d80 52
a131 1
#define	MAX_LUNS	8
d133 41
a173 3
#define	RQUEST_QUEUE_LEN	256
#define	RESULT_QUEUE_LEN	(RQUEST_QUEUE_LEN >> 3)
#define	QENTRY_LEN		64
d175 53
a227 2
#define	ISP_QUEUE_ENTRY(q, idx)	((q) + ((idx) * QENTRY_LEN))
#define	ISP_QUEUE_SIZE(n)	((n) * QENTRY_LEN)
d233 8
a240 1
	struct device		isp_dev;
d242 30
a271 29
#define	isp_name	isp_dev.dv_xname
	struct scsi_link	isp_link;
	u_int8_t		isp_max_target;
	u_int8_t		isp_state;
	/*
	 * Host Adapter Parameters, nominally stored in NVRAM
	 */
        u_int16_t		isp_adapter_enabled	: 1,
        			isp_req_ack_active_neg	: 1,	
	        		isp_data_line_active_neg: 1,
				isp_cmd_dma_burst_enable: 1,
				isp_data_dma_burst_enabl: 1,
				isp_fifo_threshold	: 2,
							: 1,
				isp_initiator_id	: 4,
        			isp_async_data_setup	: 4;
        u_int16_t		isp_selection_timeout;
        u_int16_t		isp_max_queue_depth;
	u_int8_t		isp_tag_aging;
       	u_int8_t		isp_bus_reset_delay;
        u_int8_t		isp_retry_count;
        u_int8_t		isp_retry_delay;
	struct {
		u_int8_t	dev_flags;	/* Device Flags - see below */
		u_int8_t	exc_throttle;
		u_int8_t	sync_period;
		u_int8_t	sync_offset	: 4,
				dev_enable	: 1;
	} isp_devparam[MAX_TARGETS];
d273 1
a273 1
	 * Result and Request Queues.
d275 1
d278 2
a279 2
	volatile u_int8_t	isp_sendmarker;
	volatile u_int8_t	isp_seqno;
d283 1
a283 1
	 * which scsi_xfer is bound to which ISP queue entry.
d289 2
a290 1
	volatile struct scsi_xfer *isp_xflist[RQUEST_QUEUE_LEN];
d292 1
a292 1
	 * request/result queue
d298 22
d330 7
d339 1
a339 1
 * Device Flags
d341 2
a342 8
#define	DPARM_DISC	0x80
#define	DPARM_PARITY	0x40
#define	DPARM_WIDE	0x20
#define	DPARM_SYNC	0x10
#define	DPARM_TQING	0x08
#define	DPARM_ARQ	0x04
#define	DPARM_QFRZ	0x02
#define	DPARM_RENEG	0x01
d344 13
a356 1
#define	DPARM_DEFAULT	(0xff & ~DPARM_QFRZ)
d358 3
d363 1
a363 1
 * Macros to read, write ISP registers through MD code
d386 2
a387 1

d398 1
d400 2
a401 3
 * Reset Hardware.
 *
 * Only looks at sc_dev.dv_xname, sc_iot and sc_ioh fields.
d411 1
a411 1
 * Complete attachment of Hardware
d413 1
a413 1
void isp_attach __P((struct ispsoftc *));
d416 1
a416 1
 * Free any associated resources prior to decommissioning.
d418 1
a418 1
void isp_uninit __P((struct ispsoftc *));
d421 33
a453 1
 * Interrupt Service Routine
a454 1
int isp_intr __P((void *));
d456 9
d466 4
@

