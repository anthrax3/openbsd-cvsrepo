head	1.37;
access;
symbols
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.6
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.34.0.8
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.4
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.26.0.14
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.12
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.10
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.8
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.6
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.21
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.5
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.37
date	2015.06.19.11.12.24;	author jmatthew;	state dead;
branches;
next	1.36;
commitid	I5HMIEQiHPSVn0jd;

1.36
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	EF98ch02VpFassUi;

1.35
date	2013.03.04.00.41.54;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.06.16.59.42;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.01.20.55.57;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.17.00.22.13;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2008.11.17.00.18.13;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.01.15.49.25;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.26;

1.26
date	2004.08.02.19.55.45;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.24.19.35.23;	author tholo;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.30.16.57.42;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.06.07.45.59;	author mjacob;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.03.18.34.14;	author mjacob;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.17.01.33.24;	author mjacob;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.06.16.42.43;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.15.02.37.51;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.14.00.20.55;	author mjacob;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.01.07.16.40;	author mjacob;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.12.20.12.12;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.04.22.08.08;	author mjacob;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.12.23.47.49;	author mjacob;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.06.01.07.23;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.16.01.02.00;	author mjacob;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.06.05.31.48;	author mjacob;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.05.22.20.09;	author mjacob;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.20.21.22.41;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	99.12.16.05.23.52;	author mjacob;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.11.23.21.17.38;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	99.11.22.12.50.53;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	99.03.25.22.58.38;	author mjacob;	state Exp;
branches;
next	1.2;

1.2
date	99.03.17.12.54.32;	author mjacob;	state Exp;
branches;
next	1.1;

1.1
date	99.03.17.05.26.09;	author mjacob;	state Exp;
branches;
next	;

1.6.2.1
date	2000.02.21.22.29.05;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.03.24.09.09.10;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.05.14.22.23.55;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	1.6.2.9;

1.6.2.9
date	2003.05.13.19.35.02;	author ho;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2003.05.19.21.54.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@remove isp(4) now that the ql* family have replaced it
@
text
@/*      $OpenBSD: isp_openbsd.h,v 1.36 2014/07/08 17:19:25 deraadt Exp $ */
/*
 * OpenBSD Specific definitions for the QLogic ISP Host Adapter
 */
/*
 * Copyright (C) 1999, 2000, 2001 by Matthew Jacob
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef	_ISP_OPENBSD_H
#define	_ISP_OPENBSD_H

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>  
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h> 
#include <sys/proc.h>
#include <sys/queue.h>

#if	!(defined(__sparc__) && !defined(__sparcv9__))
#include <machine/bus.h>
#endif

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <scsi/scsi_message.h>
#include <scsi/scsi_debug.h>

/*
 * Efficiency- get rid of SBus code && tests unless we need them.
 */
#if	defined(__sparcv9__ ) || defined(__sparc__)
#define	ISP_SBUS_SUPPORTED	1
#else
#define	ISP_SBUS_SUPPORTED	0
#endif

#define	ISP_PLATFORM_VERSION_MAJOR	5
#define	ISP_PLATFORM_VERSION_MINOR	9

struct isposinfo {
	struct device		_dev;
	struct scsi_link	_link[2];
	struct scsi_adapter	_adapter;
	int			hiwater;
	int			splsaved;
	int			mboxwaiting;
	u_int32_t		islocked;
	u_int32_t		onintstack;
#if	!(defined(__sparc__) && !defined(__sparcv9__))
	bus_space_tag_t		bus_tag;
	bus_space_handle_t	bus_handle;
	bus_dma_tag_t		dmatag;
	bus_dmamap_t		cdmap;
#define	isp_dmatag		isp_osinfo.dmatag
#define	isp_cdmap		isp_osinfo.cdmap
#define	isp_bus_tag		isp_osinfo.bus_tag
#define	isp_bus_handle		isp_osinfo.bus_handle
#endif
	uint32_t		: 5,
		simqfrozen	: 3,
		hysteresis	: 8,
		gdt_running	: 1,
		ldt_running	: 1,
		disabled	: 1,
		fcbsy		: 1,
		mbox_sleeping	: 1,
		mbox_sleep_ok	: 1,
		mboxcmd_done	: 1,
		mboxbsy		: 1,
		no_mbox_ints	: 1,
		blocked		: 2,
		rtpend		: 1;
	int			_iid;
	union {
		u_int64_t 	_wwn;
		u_int16_t	_discovered[2];
	} un;
#define	discovered	un._discovered
	struct scsi_xfer_list wq;
	struct timeout rqt;
};
#define	MUST_POLL(isp)	\
	(isp->isp_osinfo.onintstack || isp->isp_osinfo.no_mbox_ints)

/*
 * Locking macros...
 */
#define	ISP_LOCK		isp_lock
#define	ISP_UNLOCK		isp_unlock

/*
 * Required Macros/Defines
 */

#define	ISP2100_SCRLEN		0x1000

#define	MEMZERO			bzero
#define	MEMCPY(dst, src, amt)	bcopy((src), (dst), (amt))
#define	SNPRINTF		snprintf
#define	USEC_DELAY		isp_delay
#define	USEC_SLEEP(isp, x)	delay(x)

extern struct timespec isp_nanotime;
#define	NANOTIME_T		struct timespec
#define	GET_NANOTIME(x)		*(x) = isp_nanotime
#define	GET_NANOSEC(x)		(((x)->tv_sec * 1000000000 + (x)->tv_nsec))
#define	NANOTIME_SUB		isp_nanotime_sub

#define MAXISPREQUEST(isp)      ((IS_FC(isp) || IS_ULTRA2(isp))? 1024 : 256)

#if	!(defined(__sparc__) && !defined(__sparcv9__))
#define	MEMORYBARRIER(isp, type, offset, size)			\
switch (type) {							\
case SYNC_REQUEST:						\
{								\
	off_t off = (off_t) offset * QENTRY_LEN;		\
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_cdmap,	\
	    off, size, BUS_DMASYNC_PREWRITE);			\
	break;							\
}								\
case SYNC_RESULT:						\
{								\
	off_t off = (off_t) offset * QENTRY_LEN  +		\
	    ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));		\
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_cdmap,	\
	    off, size, BUS_DMASYNC_POSTREAD);			\
	break;							\
}								\
case SYNC_SFORDEV:						\
{								\
	off_t off = (off_t) offset;				\
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_cdmap,	\
	    off, size, BUS_DMASYNC_PREWRITE);			\
	break;							\
}								\
case SYNC_SFORCPU:						\
{								\
	off_t off = (off_t) offset;				\
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_cdmap,	\
	    off, size, BUS_DMASYNC_POSTREAD);			\
	break;							\
}								\
case SYNC_REG:							\
	bus_space_barrier(isp->isp_bus_tag,			\
	    isp->isp_bus_handle, offset, size, 			\
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);	\
	break;							\
default:							\
	break;							\
}
#else
#define	MEMORYBARRIER(isp, type, offset, size)
#endif

#define	MBOX_ACQUIRE			isp_mbox_acquire
#define MBOX_WAIT_COMPLETE		isp_mbox_wait_complete
#define	MBOX_NOTIFY_COMPLETE		isp_mbox_notify_done
#define	MBOX_RELEASE			isp_mbox_release

#define	FC_SCRATCH_ACQUIRE(isp)						\
	if (isp->isp_osinfo.fcbsy) {					\
		isp_prt(isp, ISP_LOGWARN,				\
		    "FC scratch area busy (line %d)!", __LINE__);	\
	} else								\
		isp->isp_osinfo.fcbsy = 1
#define	FC_SCRATCH_RELEASE(isp)		 isp->isp_osinfo.fcbsy = 0

#ifndef	SCSI_GOOD
#define	SCSI_GOOD	0x0
#endif
#ifndef	SCSI_CHECK
#define	SCSI_CHECK	0x2
#endif
#ifndef	SCSI_BUSY
#define	SCSI_BUSY	0x8
#endif
#ifndef	SCSI_QFULL
#define	SCSI_QFULL	0x28
#endif

#define	XS_T			struct scsi_xfer
#if	!(defined(__sparc__) && !defined(__sparcv9__))
#define	XS_DMA_ADDR_T		bus_addr_t
#else
#define	XS_DMA_ADDR_T		u_int32_t
#endif
#define	XS_CHANNEL(xs)		(((xs)->sc_link->flags & SDEV_2NDBUS)? 1 : 0)
#define	XS_ISP(xs)		(xs)->sc_link->adapter_softc
#define	XS_LUN(xs)		((int) (xs)->sc_link->lun)
#define	XS_TGT(xs)		((int) (xs)->sc_link->target)
#define	XS_CDBP(xs)		((caddr_t) (xs)->cmd)
#define	XS_CDBLEN(xs)		(xs)->cmdlen
#define	XS_XFRLEN(xs)		(xs)->datalen
#define	XS_TIME(xs)		(xs)->timeout
#define	XS_RESID(xs)		(xs)->resid
#define	XS_STSP(xs)		(&(xs)->status)
#define	XS_SNSP(xs)		(&(xs)->sense)
#define	XS_SNSLEN(xs)		(sizeof (xs)->sense)
#define	XS_SNSKEY(xs)		((xs)->sense.flags)
#define	XS_TAG_P(xs)		(((xs)->flags & SCSI_POLL) != 0)
#define	XS_TAG_TYPE(xs)		REQFLAG_STAG

#define	XS_SETERR(xs, v)	(xs)->error = v

#	define	HBA_NOERROR		XS_NOERROR
#	define	HBA_BOTCH		XS_DRIVER_STUFFUP
#	define	HBA_CMDTIMEOUT		XS_TIMEOUT
#	define	HBA_SELTIMEOUT		XS_SELTIMEOUT
#	define	HBA_TGTBSY		XS_BUSY
#	define	HBA_BUSRESET		XS_RESET
#	define	HBA_ABORTED		XS_DRIVER_STUFFUP
#	define	HBA_DATAOVR		XS_DRIVER_STUFFUP
#	define	HBA_ARQFAIL		XS_DRIVER_STUFFUP

#define	XS_ERR(xs)		(xs)->error

#define	XS_NOERR(xs)		(xs)->error == XS_NOERROR

#define	XS_INITERR(xs)		(xs)->error = 0, XS_CMD_S_CLEAR(xs)

#define	XS_SAVE_SENSE(xs, sp, len)				\
	if (xs->error == XS_NOERROR) {			\
		xs->error = XS_SENSE;			\
	}						\
	bcopy(sp, &(xs)->sense, imin(XS_SNSLEN(xs), len))

#define	XS_SET_STATE_STAT(a, b, c)

#define	DEFAULT_IID(isp)	(isp)->isp_osinfo._iid
#define	DEFAULT_LOOPID(x)	107
#define	DEFAULT_NODEWWN(isp)	(isp)->isp_osinfo.un._wwn
#define	DEFAULT_PORTWWN(isp)	(isp)->isp_osinfo.un._wwn
#define	ISP_NODEWWN(isp)	FCPARAM(isp)->isp_wwnn_nvram
#define	ISP_PORTWWN(isp)	FCPARAM(isp)->isp_wwpn_nvram

#if	BYTE_ORDER == BIG_ENDIAN
#ifdef	ISP_SBUS_SUPPORTED
#define	ISP_IOXPUT_8(isp, s, d)		*(d) = s
#define	ISP_IOXPUT_16(isp, s, d)				\
	*(d) = (isp->isp_bustype == ISP_BT_SBUS)? s : swap16(s)
#define	ISP_IOXPUT_32(isp, s, d)				\
	*(d) = (isp->isp_bustype == ISP_BT_SBUS)? s : swap32(s)

#define	ISP_IOXGET_8(isp, s, d)		d = (*((u_int8_t *)s))
#define	ISP_IOXGET_16(isp, s, d)				\
	d = (isp->isp_bustype == ISP_BT_SBUS)?			\
	*((u_int16_t *)s) : swap16(*((u_int16_t *)s))
#define	ISP_IOXGET_32(isp, s, d)				\
	d = (isp->isp_bustype == ISP_BT_SBUS)?			\
	*((u_int32_t *)s) : swap32(*((u_int32_t *)s))
#else
#define	ISP_IOXPUT_8(isp, s, d)		*(d) = s
#define	ISP_IOXPUT_16(isp, s, d)	*(d) = swap16(s)
#define	ISP_IOXPUT_32(isp, s, d)	*(d) = swap32(s)
#define	ISP_IOXGET_8(isp, s, d)		d = (*((u_int8_t *)s))
#define	ISP_IOXGET_16(isp, s, d)	d = swap16(*((u_int16_t *)s))
#define	ISP_IOXGET_32(isp, s, d)	d = swap32(*((u_int32_t *)s))
#endif
#define	ISP_SWIZZLE_NVRAM_WORD(isp, rp)	*rp = swap16(*rp)
#define	ISP_SWIZZLE_NVRAM_LONG(isp, rp)	*rp = swap32(*rp)

#define	ISP_IOZGET_8(isp, s, d)		d = (*((u_int8_t *)s))
#define	ISP_IOZGET_16(isp, s, d)	d = (*((u_int16_t *)s))
#define	ISP_IOZGET_32(isp, s, d)	d = (*((u_int32_t *)s))
#define	ISP_IOZPUT_8(isp, s, d)		*(d) = s
#define	ISP_IOZPUT_16(isp, s, d)	*(d) = s
#define	ISP_IOZPUT_32(isp, s, d)	*(d) = s


#else
#define	ISP_IOXPUT_8(isp, s, d)		*(d) = s
#define	ISP_IOXPUT_16(isp, s, d)	*(d) = s
#define	ISP_IOXPUT_32(isp, s, d)	*(d) = s
#define	ISP_IOXGET_8(isp, s, d)		d = *(s)
#define	ISP_IOXGET_16(isp, s, d)	d = *(s)
#define	ISP_IOXGET_32(isp, s, d)	d = *(s)
#define	ISP_SWIZZLE_NVRAM_WORD(isp, rp)
#define	ISP_SWIZZLE_NVRAM_LONG(isp, rp)

#define	ISP_IOZPUT_8(isp, s, d)		*(d) = s
#define	ISP_IOZPUT_16(isp, s, d)	*(d) = swap16(s)
#define	ISP_IOZPUT_32(isp, s, d)	*(d) = swap32(s)

#define	ISP_IOZGET_8(isp, s, d)		d = (*((u_int8_t *)(s)))
#define	ISP_IOZGET_16(isp, s, d)	d = swap16(*((u_int16_t *)(s)))
#define	ISP_IOZGET_32(isp, s, d)	d = swap32(*((u_int32_t *)(s)))
#endif

#define	ISP_SWAP16(isp, s)	swap16(s)
#define	ISP_SWAP32(isp, s)	swap32(s)

/*
 * Includes of common header files
 */

#include <dev/ic/ispreg.h>
#include <dev/ic/ispvar.h>
#include <dev/ic/ispmbox.h>

/*
 * isp_osinfo definitions, extensions and shorthand.
 */
#define	isp_name	isp_osinfo._dev.dv_xname
#define	isp_unit	isp_osinfo._dev.dv_unit

/*
 * Driver prototypes..
 */
void isp_attach(struct ispsoftc *);
void isp_uninit(struct ispsoftc *);

void isp_lock(struct ispsoftc *);
void isp_unlock(struct ispsoftc *);
void isp_prt(struct ispsoftc *, int level, const char *, ...);
void isp_delay(int);
u_int64_t isp_nanotime_sub(struct timespec *, struct timespec *);
int isp_mbox_acquire(ispsoftc_t *);
void isp_mbox_wait_complete(ispsoftc_t *, mbreg_t *);
void isp_mbox_notify_done(ispsoftc_t *);
void isp_mbox_release(ispsoftc_t *);

/*
 * Driver wide data...
 */

/*              
 * Platform private flags                                               
 */

#define	XS_PSTS_INWDOG		0x10000
#define	XS_PSTS_GRACE		0x20000
#define	XS_PSTS_TIMED		0x40000
#define	XS_PSTS_ALL		SCSI_PRIVATE

#define	XS_CMD_S_WDOG(xs)	(xs)->flags |= XS_PSTS_INWDOG
#define	XS_CMD_C_WDOG(xs)	(xs)->flags &= ~XS_PSTS_INWDOG
#define	XS_CMD_WDOG_P(xs)	(((xs)->flags & XS_PSTS_INWDOG) != 0)

#define	XS_CMD_S_TIMER(xs)	(xs)->flags |= XS_PSTS_TIMED
#define	XS_CMD_C_TIMER(xs)	(xs)->flags &= ~XS_PSTS_TIMED
#define	XS_CMD_TIMER_P(xs)	(((xs)->flags & XS_PSTS_TIMED) != 0)

#define	XS_CMD_S_GRACE(xs)	(xs)->flags |= XS_PSTS_GRACE
#define	XS_CMD_C_GRACE(xs)	(xs)->flags &= ~XS_PSTS_GRACE
#define	XS_CMD_GRACE_P(xs)	(((xs)->flags & XS_PSTS_GRACE) != 0)

#define	XS_CMD_S_DONE(xs)	(xs)->flags |= ITSDONE
#define	XS_CMD_C_DONE(xs)	(xs)->flags &= ~ITSDONE
#define	XS_CMD_DONE_P(xs)	(((xs)->flags & ITSDONE) != 0)

#define	XS_CMD_S_CLEAR(xs)	(xs)->flags &= ~XS_PSTS_ALL

#include <dev/ic/isp_library.h>

#endif	/* _ISP_OPENBSD_H */
@


1.36
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.35 2013/03/04 00:41:54 dlg Exp $ */
@


1.35
log
@replace the LIST_ENTRY in scsi_xfer with a SIMPLEQ_ENTRY. the things that
use it want something they can add to the end of they do horrible things
to be able to do that with the LIST_ENTRY.

this makes those horrible things a bit less horrible, and makes it easier
to use lists of scsi_xfers in other things.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.34 2011/03/06 16:59:42 miod Exp $ */
a51 2

#include <uvm/uvm_extern.h>
@


1.34
log
@Make sure MEMORYBARRIER(SYNC_REG) performs a read/write bus_space_barrier,
instead of a read barrier only, as it is used in read-modify-write cycles.
ok mjacob
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.33 2010/06/26 23:24:44 guenther Exp $ */
d106 1
a106 1
	struct scsi_xfer	*wqf, *wqt;
@


1.33
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.32 2009/07/01 20:55:57 kettenis Exp $ */
d173 1
a173 1
	    BUS_SPACE_BARRIER_READ);				\
@


1.32
log
@Add a workaround for the fact that our clocks aren't running during autoconf
(at least on some of our architectures, including hppa).  Since isp(4) keeps
track of elapsed time to determine if it should continue to wait for the FC
link to come up it would wait very very long.  Figured out by krw@@.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.31 2009/06/24 11:00:53 krw Exp $ */
a40 1
#include <sys/user.h>
@


1.31
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.30 2008/11/17 00:22:13 krw Exp $ */
d128 1
a128 1
#define	USEC_DELAY		delay
d131 1
d133 1
a133 1
#define	GET_NANOTIME		nanotime
d343 1
@


1.30
log
@NETBSD -> OPENBSD in #endif comment.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.29 2008/11/17 00:18:13 krw Exp $ */
d65 2
a66 2
#define	ISP_PLATFORM_VERSION_MAJOR	2
#define	ISP_PLATFORM_VERSION_MINOR	1
d78 2
d81 1
a81 3
	bus_dmamap_t		rqdmap;
	bus_dmamap_t		rsdmap;
	bus_dmamap_t		scdmap;	/* FC only */
d83 15
a97 7
#define	isp_rqdmap		isp_osinfo.rqdmap
#define	isp_rsdmap		isp_osinfo.rsdmap
#define	isp_scdmap		isp_osinfo.scdmap
#endif
	unsigned int		: 28,
		
		rtpend		: 1,
d99 2
a100 1
		blocked		: 2;
d123 1
a123 6
#define	INLINE			__inline

/* We don't want expensive inline functions. */
#define EXP_INLINE

#define	ISP2100_SCRLEN		0x800
d128 2
a129 7
#define	USEC_DELAY(x)		delay(x)
#define	USEC_SLEEP(isp, x)		\
	if (!MUST_POLL(isp))		\
		ISP_UNLOCK(isp);	\
	delay(x);			\
	if (!MUST_POLL(isp))		\
		ISP_LOCK(isp)
d136 1
a136 1
#define	MAXISPREQUEST(isp)	256
d144 1
a144 1
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_rqdmap,	\
d150 3
a152 2
	off_t off = (off_t) offset * QENTRY_LEN;		\
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_rsdmap,	\
d159 1
a159 1
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_scdmap,	\
d166 1
a166 1
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_scdmap,	\
d171 4
d182 12
a193 14
#define	MBOX_ACQUIRE(isp)
#define	MBOX_WAIT_COMPLETE		isp_wait_complete

#define	MBOX_NOTIFY_COMPLETE(isp)					\
	if (isp->isp_osinfo.mboxwaiting) {				\
                isp->isp_osinfo.mboxwaiting = 0;			\
                wakeup(&isp->isp_osinfo.mboxwaiting);			\
        }								\
	isp->isp_mboxbsy = 0

#define	MBOX_RELEASE(isp)

#define	FC_SCRATCH_ACQUIRE(isp)
#define	FC_SCRATCH_RELEASE(isp)
d209 5
d248 1
a248 1
#define	XS_SAVE_SENSE(xs, sp)				\
d252 1
a252 2
	bcopy(sp->req_sense_data, &(xs)->sense,		\
	    imin(XS_SNSLEN(xs), sp->req_sense_len))
d260 2
a261 2
#define	ISP_NODEWWN(isp)	FCPARAM(isp)->isp_nodewwn
#define	ISP_PORTWWN(isp)	FCPARAM(isp)->isp_portwwn
d287 10
d305 9
d316 3
d339 8
a346 5
static INLINE void isp_lock(struct ispsoftc *);
static INLINE void isp_unlock(struct ispsoftc *);
static INLINE u_int64_t
isp_nanotime_sub(struct timespec *, struct timespec *);
static void isp_wait_complete(struct ispsoftc *);
a377 82

/*
 * Platform specific 'INLINE' or support functions
 */
static INLINE void
isp_lock(struct ispsoftc *isp)
{
	int s = splbio();
	if (isp->isp_osinfo.islocked++ == 0) {
		isp->isp_osinfo.splsaved = s;
	} else {
		splx(s);
	}
}

static INLINE void
isp_unlock(struct ispsoftc *isp)
{
	if (isp->isp_osinfo.islocked-- <= 1) {
		isp->isp_osinfo.islocked = 0;
		splx(isp->isp_osinfo.splsaved);
	}
}

static INLINE u_int64_t
isp_nanotime_sub(struct timespec *b, struct timespec *a)
{
	struct timespec x;
	u_int64_t elapsed;
	timespecsub(b, a, &x);
	elapsed = GET_NANOSEC(&x);
	if (elapsed == 0)
		elapsed++;
	return (elapsed);
}

static INLINE void
isp_wait_complete(struct ispsoftc *isp)
{
	int delaytime;
	if (isp->isp_mbxwrk0)
		delaytime = 60;
	else
		delaytime = 5;
	if (MUST_POLL(isp)) {
		int usecs = 0;
		delaytime *= 1000000;	/* convert to usecs */
		while (usecs < delaytime) {
			u_int16_t isr, sema, mbox;
			if (isp->isp_mboxbsy == 0) {
				break;
			}
			if (ISP_READ_ISR(isp, &isr, &sema, &mbox)) {
				isp_intr(isp, isr, sema, mbox);
				if (isp->isp_mboxbsy == 0) {
					break;
				}
			}
			USEC_DELAY(500);
			usecs += 500;
		}
		if (isp->isp_mboxbsy != 0) {
			isp_prt(isp, ISP_LOGWARN,
			    "Polled Mailbox Command (0x%x) Timeout",
			    isp->isp_lastmbxcmd);
		}
	} else {
		int rv = 0;
                isp->isp_osinfo.mboxwaiting = 1;
                while (isp->isp_osinfo.mboxwaiting && rv == 0) {
			rv = tsleep(&isp->isp_osinfo.mboxwaiting,
			    PRIBIO, "isp_mboxcmd", delaytime * hz);
		}
		if (rv == EWOULDBLOCK) {
			isp->isp_mboxbsy = 0;
			isp->isp_osinfo.mboxwaiting = 0;
			isp_prt(isp, ISP_LOGWARN,
			    "Interrupting Mailbox Command (0x%x) Timeout",
			    isp->isp_lastmbxcmd);
		}
	}
}
@


1.29
log
@Use new isp_library.c rather than isp_inline.h. No functional change.

Tested by naddy@@. 'go for it' marco@@
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.28 2008/06/01 15:49:25 kettenis Exp $ */
d432 1
a432 1
#endif	/* _ISP_NETBSD_H */
@


1.28
log
@Make SCSI isp(4) use the same SCSI initiator ID as the prom on sparc/sparc64.

ok marco@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.27 2008/01/21 20:00:33 sobrado Exp $ */
d430 1
a430 4
/*
 * Common INLINE functions
 */
#include <dev/ic/isp_inline.h>
@


1.27
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.26 2004/08/02 19:55:45 art Exp $ */
d92 1
d250 1
a250 1
#define	DEFAULT_IID(x)		7
@


1.26
log
@Use some horrible macros to uninline a few functions that are expensive
when inlined and shave a few k from the kernel size.

The goal here was not to make the nicest diff possible, but the smallest.

deraadt@@ drahn@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.25 2004/06/24 19:35:23 tholo Exp $ */
d3 1
a3 1
 * OpenBSD Specific definitions for the Qlogic ISP Host Adapter
@


1.25
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.24 2003/03/30 16:57:42 krw Exp $ */
d113 4
a116 1
#define	INLINE			inline
@


1.24
log
@Delete unused local version of strncat.

ok mjacob@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.23 2003/03/06 07:45:59 mjacob Exp $ */
d128 4
a131 4
#define	NANOTIME_T		struct timeval
#define	GET_NANOTIME		microtime
#define	GET_NANOSEC(x)		(((x)->tv_sec * 1000000 + (x)->tv_usec) * 1000)
#define	NANOTIME_SUB		isp_microtime_sub
d310 1
a310 1
isp_microtime_sub(struct timeval *, struct timeval *);
d368 1
a368 1
isp_microtime_sub(struct timeval *b, struct timeval *a)
d370 1
a370 1
	struct timeval x;
d372 1
a372 1
	timersub(b, a, &x);
@


1.23
log
@Remove double include of scsi_all.h
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.22 2003/03/03 18:34:14 mjacob Exp $ */
a308 1
static INLINE char *strncat(char *, const char *, size_t);
a364 18
}

static INLINE char *
strncat(char *d, const char *s, size_t c)
{
        char *t = d;

        if (c) {
                while (*d)
                        d++;
                while ((*d++ = *s++)) {
                        if (--c == 0) {
                                *d = '\0';
                                break;
                        }
                }
        }
        return (t);
@


1.22
log
@Remove STRNCAT define.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.21 2002/05/17 01:33:24 mjacob Exp $ */
a47 1
#include <scsi/scsi_all.h>
@


1.21
log
@Accomodate changes to fabric stuff as well as other core code changes.

Fix a buglet in delaying && waiting for mailbox completion.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.20 2002/03/06 16:42:43 jason Exp $ */
a120 1
#define	STRNCAT			strncat
@


1.20
log
@Get the offsets and lengths right when sync'n dma maps; patch from mjacob
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.19 2002/02/15 02:37:51 art Exp $ */
d116 1
a116 1
#define	ISP2100_SCRLEN		0x400
d188 3
d309 4
a312 4
static inline void isp_lock(struct ispsoftc *);
static inline void isp_unlock(struct ispsoftc *);
static inline char *strncat(char *, const char *, size_t);
static inline u_int64_t
d348 1
a348 1
 * Platform specific 'inline' or support functions
d350 1
a350 1
static inline void
d361 1
a361 1
static inline void
d370 1
a370 1
static inline char *
d388 1
a388 1
static inline u_int64_t
d400 1
a400 1
static inline void
d403 5
d410 2
a411 1
		while (usecs < 5 * 1000000) {
d435 1
a435 1
			    PRIBIO, "isp_mboxcmd", 5 * hz);
d448 1
a448 1
 * Common inline functions
@


1.19
log
@Much simpler timeout calculation.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.18 2001/12/14 00:20:55 mjacob Exp $ */
a149 1
	off += ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));		\
d156 1
a156 3
	off_t off =						\
	    ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp)) +		\
	    ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp)) + offset;	\
d163 1
a163 3
	off_t off =						\
	    ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp)) +		\
	    ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp)) + offset;	\
@


1.18
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.17 2001/11/06 19:53:18 miod Exp $ */
a429 8
			static struct timeval fivesec = { 5, 0 };
			int timo;
			struct timeval tv;
			microtime(&tv);
			timeradd(&tv, &fivesec, &tv);
			if ((timo = hzto(&tv)) == 0) {
				timo = 1;
			}
d431 1
a431 1
			    PRIBIO, "isp_mboxcmd", timo);
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.18 2001/12/14 00:20:55 mjacob Exp $ */
d116 1
a116 1
#define	ISP2100_SCRLEN		0x800
d150 1
d157 3
a159 1
	off_t off = (off_t) offset;				\
d166 3
a168 1
	off_t off = (off_t) offset;				\
a192 3
#define	FC_SCRATCH_ACQUIRE(isp)
#define	FC_SCRATCH_RELEASE(isp)

d311 4
a314 4
static INLINE void isp_lock(struct ispsoftc *);
static INLINE void isp_unlock(struct ispsoftc *);
static INLINE char *strncat(char *, const char *, size_t);
static INLINE u_int64_t
d350 1
a350 1
 * Platform specific 'INLINE' or support functions
d352 1
a352 1
static INLINE void
d363 1
a363 1
static INLINE void
d372 1
a372 1
static INLINE char *
d390 1
a390 1
static INLINE u_int64_t
d402 1
a402 1
static INLINE void
a404 5
	int delaytime;
	if (isp->isp_mbxwrk0)
		delaytime = 60;
	else
		delaytime = 5;
d407 1
a407 2
		delaytime *= 1000000;	/* convert to usecs */
		while (usecs < delaytime) {
d430 8
d439 1
a439 1
			    PRIBIO, "isp_mboxcmd", delaytime * hz);
d452 1
a452 1
 * Common INLINE functions
@


1.18.2.2
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d49 1
d121 1
d311 1
d368 18
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.16 2001/09/01 07:16:40 mjacob Exp $ */
d44 4
d57 8
d67 1
a67 1
#define	ISP_PLATFORM_VERSION_MINOR	0
d78 10
d137 40
a176 2
#ifdef	__alpha__
#define	MEMORYBARRIER(isp, type, offset, size)	alpha_mb()
d182 1
a182 1
#define	MBOX_WAIT_COMPLETE	isp_wait_complete
d257 15
a271 9
#define	ISP_UNSWIZZLE_AND_COPY_PDBP(isp, dest, src)	\
	if((void *)src != (void *)dest) bcopy(src, dest, sizeof (isp_pdb_t))
#define	ISP_SWIZZLE_ICB(a, b)
#ifdef	__sparc__
#define ISP_SWIZZLE_REQUEST(a, b)			\
	ISP_SBUSIFY_ISPHDR(a, &(b)->req_header);	\
        ISP_SBUSIFY_ISPREQ(a, b)
#define ISP_UNSWIZZLE_RESPONSE(a, b, c)			\
	ISP_SBUSIFY_ISPHDR(a, &(b)->req_header)
d273 6
a278 2
#define	ISP_SWIZZLE_REQUEST(a, b)
#define	ISP_UNSWIZZLE_RESPONSE(a, b, c)
d280 1
a280 9
#define	ISP_SWIZZLE_SNS_REQ(a, b)
#define	ISP_UNSWIZZLE_SNS_RSP(a, b, c)
#ifdef	__sparc__
#define	ISP_SWIZZLE_NVRAM_WORD(isp, rp)	\
	{								\
		u_int16_t tmp = *rp >> 8;				\
		tmp |= ((*rp & 0xff) << 8);				\
		*rp = tmp;						\
	}
d282 6
d407 1
a407 1
		while (usecs < 2 * 1000000) {
@


1.16
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.15 2001/08/12 20:33:50 mickey Exp $ */
d51 1
a51 1
#include <vm/vm.h>
@


1.15
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.14 2001/08/12 20:12:12 mickey Exp $ */
d340 1
a340 1
			(void) isp_intr(isp);
d343 6
@


1.14
log
@remove some of the redundant vm includes
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.13 2001/04/04 22:08:08 mjacob Exp $ */
a51 1
#include <vm/vm_param.h>
@


1.13
log
@Roll platform major/minor. Ansify. Add the appropriate bits for
going to a synchronous restart queue blockage model. Add bits
that say that scsi xfer has a timer active.

Ha. ha ha. Add the bits that note that we have sense data when we
get it.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.12 2001/02/12 23:47:49 mjacob Exp $ */
a52 1
#include <vm/pmap.h>
@


1.12
log
@Roll platform minor. Remove ISP2100_FABRIC defines (we don't care
anymore). Fix mailbox timeouts to correctly print out timing out
command.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.11 2000/12/06 01:07:23 mjacob Exp $ */
d6 1
a6 1
 * Copyright (C) 1999, 2000 by Matthew Jacob
d56 2
a57 2
#define	ISP_PLATFORM_VERSION_MAJOR	1
#define	ISP_PLATFORM_VERSION_MINOR	1
d63 1
d68 3
a70 1
	unsigned int		: 30,
d72 1
a72 1
		blocked		: 1;
d184 3
d242 2
a243 2
void isp_attach __P((struct ispsoftc *));
void isp_uninit __P((struct ispsoftc *));
d245 3
a247 3
static inline void isp_lock __P((struct ispsoftc *));
static inline void isp_unlock __P((struct ispsoftc *));
static inline char *strncat __P((char *, const char *, size_t));
d249 2
a250 2
isp_microtime_sub __P((struct timeval *, struct timeval *));
static void isp_wait_complete __P((struct ispsoftc *));
d262 1
d269 4
d287 1
a287 2
isp_lock(isp)
	struct ispsoftc *isp;
d298 1
a298 2
isp_unlock(isp)
	struct ispsoftc *isp;
d307 1
a307 4
strncat(d, s, c)
	char *d;
	const char *s;
	size_t c;
d325 1
a325 3
isp_microtime_sub(b, a)
	struct timeval *b;
	struct timeval *a;
d337 1
a337 2
isp_wait_complete(isp)
	struct ispsoftc *isp;
@


1.11
log
@Update isp codebase to current common head- USEC_SLEEP macro added,
instrumentation for interrupts, specific topology preferences for
the 2200. Fix the hole in the OpenBSD port becuause there'd been
no maxluns limit from the midlayer and have the command routine
bounce commands > the maxluns for a particular controller (in
particular, Qlogic FC cards where we can't tell when it hasn't been
us that have loaded the F/W whether or not SCCLUN is in effect
or not).
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.10 2000/10/16 01:02:00 mjacob Exp $ */
d57 1
a57 1
#define	ISP_PLATFORM_VERSION_MINOR	0
a92 1
#define	ISP2100_FABRIC		1
d347 3
a349 1
			isp_prt(isp, ISP_LOGWARN, "Mailbox Cmd (poll) Timeout");
d369 3
a371 1
			isp_prt(isp, ISP_LOGWARN, "Mailbox Cmd (intr) Timeout");
@


1.10
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.9 2000/07/06 05:31:48 mjacob Exp $ */
d78 8
d101 6
a250 8
/*
 * Locking macros...
 */
#define	ISP_LOCK		isp_lock
#define	ISP_UNLOCK		isp_unlock
#define	ISP_ILOCK(x)		isp_lock(x); isp->isp_osinfo.onintstack++
#define	ISP_IUNLOCK(x)		isp->isp_osinfo.onintstack--; isp_unlock(x)

d337 1
a337 1
	if (isp->isp_osinfo.onintstack || isp->isp_osinfo.no_mbox_ints) {
@


1.9
log
@Resync with FreeBSD/NetBSD. Salient features are that the mailbox command
routines are not necessarily polled now- this should cut down on some of
the spurious lost commands that have occurred. Also, we now watchdog each
command and make sure that command constipation doesn't occur (which it
has been documented to do on the QLA2100 cards).
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_openbsd.h,v 1.8 2000/03/05 22:20:09 mjacob Exp $ */
d4 3
a6 4
 *
 *---------------------------------------
 * Copyright (c) 1999 by Matthew Jacob
 * NASA/Ames Research Center
a7 1
 *---------------------------------------
d13 3
a15 19
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d17 10
a27 1

a43 1

a54 2
#define	ISP_PLATFORM_VERSION_MAJOR	0
#define	ISP_PLATFORM_VERSION_MINOR	10
d56 3
a58 1
#define	ISP_SCSI_XFER_T		struct scsi_xfer
d63 7
a69 1
	int			blocked;
d71 1
a71 1
		int	 	_seed;
a73 1
#define	seed		un._seed
d79 3
a81 13
#define	MBOX_WAIT_COMPLETE(isp)		\
	{ \
		int j; \
		for (j = 0; j < 60 * 2000; j++) { \
			if (isp_intr(isp) == 0) { \
				SYS_DELAY(500); \
			} \
			if (isp->isp_mboxbsy == 0) \
				break; \
		} \
		if (isp->isp_mboxbsy != 0) \
			printf("%s: mailbox timeout\n", isp->isp_name); \
	}
d83 1
a83 1
#define	MBOX_NOTIFY_COMPLETE(isp)	isp->isp_mboxbsy = 0
a84 1
#define	MAXISPREQUEST		256
d88 5
a92 3
#include <dev/ic/ispreg.h>
#include <dev/ic/ispvar.h>
#include <dev/ic/ispmbox.h>
d94 4
a97 2
#define	IDPRINTF(lev, x)	if (isp->isp_dblev >= lev) printf x
#define	PRINTF			printf
d99 1
a99 2
#define	MEMZERO			bzero
#define	MEMCPY(dst, src, count)	bcopy((src), (dst), (count))
d102 1
a102 1
#define	MemoryBarrier	alpha_mb
d104 1
a104 1
#define	MemoryBarrier()
d107 2
a108 2
#define	DMA_MSW(x)	(((x) >> 16) & 0xffff)
#define	DMA_LSW(x)	(((x) & 0xffff))
d110 6
a115 13
#if	defined(SCSIDEBUG)
#define	DFLT_DBLEVEL		3
#define	CFGPRINTF		printf
#elif	defined(DEBUG)
#define	DFLT_DBLEVEL		2
#define	CFGPRINTF		printf
#elif	defined(DIAGNOSTIC)
#define	DFLT_DBLEVEL		1
#define	CFGPRINTF		if (0) printf
#else
#define	DFLT_DBLEVEL		0
#define	CFGPRINTF		if (0) printf
#endif
d117 1
a117 6
#define	ISP_LOCKVAL_DECL	int isp_spl_save
#define	ISP_ILOCKVAL_DECL	ISP_LOCKVAL_DECL
#define	ISP_LOCK(x)		isp_spl_save = splbio()
#define	ISP_UNLOCK(x)		(void) splx(isp_spl_save)
#define	ISP_ILOCK		ISP_LOCK
#define	ISP_IUNLOCK		ISP_UNLOCK
d119 12
d132 2
a133 1
#define	XS_NULL(xs)		xs == NULL || xs->sc_link == NULL
d137 2
a138 2
#define	XS_RESID(xs)		(xs)->resid
#define	XS_CHANNEL(xs)		(((xs)->sc_link->flags & SDEV_2NDBUS)? 1 : 0)
a139 3
#define	XS_CDBLEN(xs)		(xs)->cmdlen
#define	XS_CDBP(xs)		((caddr_t) (xs)->cmd)
#define	XS_STS(xs)		(xs)->status
d141 2
d146 18
d165 37
a201 7
#define	HBA_NOERROR		XS_NOERROR
#define	HBA_BOTCH		XS_DRIVER_STUFFUP
#define	HBA_CMDTIMEOUT		XS_TIMEOUT
#define	HBA_SELTIMEOUT		XS_SELTIMEOUT
#define	HBA_TGTBSY		XS_BUSY
#ifdef	XS_RESET
#define	HBA_BUSRESET		XS_RESET
d203 1
a203 1
#define	HBA_BUSRESET		XS_DRIVER_STUFFUP
a204 3
#define	HBA_ABORTED		XS_DRIVER_STUFFUP
#define	HBA_DATAOVR		XS_DRIVER_STUFFUP
#define	HBA_ARQFAIL		XS_DRIVER_STUFFUP
d206 42
a247 2
#define	XS_SNS_IS_VALID(xs)	(xs)->error = XS_SENSE
#define	XS_IS_SNS_VALID(xs)	((xs)->error == XS_SENSE)
a266 7
#define	XS_INITERR(xs)		(xs)->error = 0, XS_CMD_S_CLEAR(xs)
#define	XS_SETERR(xs, v)	(xs)->error = v
#define	XS_ERR(xs)		(xs)->error
#define	XS_NOERR(xs)		(xs)->error == XS_NOERROR

#define	XS_CMD_DONE		isp_done

d268 1
a268 1
 * We use whether or not we're a polled command to decide about tagging.
d270 11
a280 1
#define	XS_CANTAG(xs)		(((xs)->flags & SCSI_POLL) != 0)
d282 9
a290 22
/*
 * This is our default tag (ordered).
 */
#define	XS_KINDOF_TAG(xs)	REQFLAG_OTAG

#define	CMD_COMPLETE		100
#define	CMD_EAGAIN		101
#define	CMD_QUEUED		102
#define	CMD_RQLATER		103

#define	isp_name		isp_osinfo._dev.dv_xname
#define	isp_unit		isp_osinfo._dev.dv_unit

#define	SCSI_QFULL		0x28

#define	SYS_DELAY(x)		delay(x)

#define	WATCH_INTERVAL	30

#define	FC_FW_READY_DELAY	(5 * 1000000)
#define	DEFAULT_LOOPID(x)	107
#define	DEFAULT_WWN(x)		(0x1000b00d00000000LL + (x)->isp_osinfo.seed)
a291 25
extern void isp_attach __P((struct ispsoftc *));
extern void isp_uninit __P((struct ispsoftc *));
extern void isp_done __P((ISP_SCSI_XFER_T *));


#define ISP_UNSWIZZLE_AND_COPY_PDBP(isp, dest, src)	\
        bcopy(src, dest, sizeof (isp_pdb_t))
#define ISP_SWIZZLE_ICB(a, b)
#ifdef	__sparc__
#define	ISP_SWIZZLE_CONTINUATION(a, b)	ISP_SBUSIFY_ISPHDR(a, &(b)->req_header)
#define ISP_SWIZZLE_REQUEST(a, b)			\
	ISP_SBUSIFY_ISPHDR(a, &(b)->req_header);	\
        ISP_SBUSIFY_ISPREQ(a, b)
#define ISP_UNSWIZZLE_RESPONSE(a, b)			\
	ISP_SBUSIFY_ISPHDR(a, &(b)->req_header)
#else
#define	ISP_SWIZZLE_CONTINUATION(a, b)
#define ISP_SWIZZLE_REQUEST(a, b)
#define ISP_UNSWIZZLE_RESPONSE(a, b)
#endif
#define	ISP_SWIZZLE_SNS_REQ(a, b)
#define	ISP_UNSWIZZLE_SNS_RSP(a, b, c)

#define	STRNCAT			strncat
static inline char *strncat(char *, const char *, size_t);
d293 4
a296 1
strncat(char *d, const char *s, size_t c)
d313 53
d367 3
a369 1
#define	INLINE	inline
d372 1
a372 1
#endif	/* _ISP_OPENBSD_H */
@


1.8
log
@roll minor revision level
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_openbsd.h,v 1.7 2000/02/20 21:22:41 mjacob Exp $ */
d66 1
a66 1
#define	ISP_PLATFORM_VERSION_MINOR	9
d81 1
d84 16
d101 1
a101 1
#ifdef	ISP2100_FABRIC
a102 3
#else
#define	ISP2100_SCRLEN		0x100
#endif
d177 19
a195 1
#define	XS_INITERR(xs)		(xs)->error = 0
d200 1
a200 2
#define	XS_CMD_DONE(xs)		(xs)->flags |= ITSDONE, scsi_done(xs)
#define	XS_IS_CMD_DONE(xs)	(((xs)->flags & ITSDONE) != 0)
d232 1
d252 21
@


1.7
log
@Add 12160 (Ultra3) support. Add files and changes for target mode support.
Do some SNS fabric suppor tchanges. Roll revision levels. Tested on
GENERIC i386 && sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_openbsd.h,v 1.6 1999/12/16 05:23:52 mjacob Exp $ */
d66 1
a66 1
#define	ISP_PLATFORM_VERSION_MINOR	8
@


1.6
log
@Roll platform version. Add a second scsi_link struct in the private
area (for dual bus support). Add in a proper XS_CHANNEL macro.
Reorder the printf level ifdefs- DEBUG should come before DIAGNOSTIC
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_openbsd.h,v 1.5 1999/11/23 21:17:38 mjacob Exp $ */
d66 1
a66 1
#define	ISP_PLATFORM_VERSION_MINOR	6
d83 1
a83 1
#define	MAXISPREQUEST	64
d207 1
d214 1
@


1.6.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_openbsd.h,v 1.7 2000/02/20 21:22:41 mjacob Exp $ */
d66 1
a66 1
#define	ISP_PLATFORM_VERSION_MINOR	8
d83 1
a83 1
#define	MAXISPREQUEST		256
a206 1
#define	ISP_SWIZZLE_CONTINUATION(a, b)	ISP_SBUSIFY_ISPHDR(a, &(b)->req_header)
a212 1
#define	ISP_SWIZZLE_CONTINUATION(a, b)
@


1.6.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d66 1
a66 1
#define	ISP_PLATFORM_VERSION_MINOR	9
@


1.6.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.13 2001/04/04 22:08:08 mjacob Exp $ */
d4 4
a7 3
 */
/*
 * Copyright (C) 1999, 2000, 2001 by Matthew Jacob
d9 1
d15 19
a33 3
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
a34 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d36 1
d53 1
d65 2
d68 1
a68 3
#define	ISP_PLATFORM_VERSION_MAJOR	2
#define	ISP_PLATFORM_VERSION_MINOR	0

d73 1
a73 10
	int			hiwater;
	int			splsaved;
	int			mboxwaiting;
	u_int32_t		islocked;
	u_int32_t		onintstack;
	unsigned int		: 28,
		
		rtpend		: 1,
		no_mbox_ints	: 1,
		blocked		: 2;
d75 1
a75 1
		u_int64_t 	_wwn;
d78 1
a80 1
	struct timeout rqt;
a81 2
#define	MUST_POLL(isp)	\
	(isp->isp_osinfo.onintstack || isp->isp_osinfo.no_mbox_ints)
d83 6
a88 5
/*
 * Locking macros...
 */
#define	ISP_LOCK		isp_lock
#define	ISP_UNLOCK		isp_unlock
d90 3
a92 3
/*
 * Required Macros/Defines
 */
d94 2
a95 3
#define	INLINE			inline

#define	ISP2100_SCRLEN		0x400
d98 1
a98 17
#define	MEMCPY(dst, src, amt)	bcopy((src), (dst), (amt))
#define	SNPRINTF		snprintf
#define	STRNCAT			strncat
#define	USEC_DELAY(x)		delay(x)
#define	USEC_SLEEP(isp, x)		\
	if (!MUST_POLL(isp))		\
		ISP_UNLOCK(isp);	\
	delay(x);			\
	if (!MUST_POLL(isp))		\
		ISP_LOCK(isp)

#define	NANOTIME_T		struct timeval
#define	GET_NANOTIME		microtime
#define	GET_NANOSEC(x)		(((x)->tv_sec * 1000000 + (x)->tv_usec) * 1000)
#define	NANOTIME_SUB		isp_microtime_sub

#define	MAXISPREQUEST(isp)	256
d101 1
a101 1
#define	MEMORYBARRIER(isp, type, offset, size)	alpha_mb()
d103 1
a103 1
#define	MEMORYBARRIER(isp, type, offset, size)
d106 2
a107 2
#define	MBOX_ACQUIRE(isp)
#define	MBOX_WAIT_COMPLETE	isp_wait_complete
d109 13
a121 6
#define	MBOX_NOTIFY_COMPLETE(isp)					\
	if (isp->isp_osinfo.mboxwaiting) {				\
                isp->isp_osinfo.mboxwaiting = 0;			\
                wakeup(&isp->isp_osinfo.mboxwaiting);			\
        }								\
	isp->isp_mboxbsy = 0
d123 6
a128 1
#define	MBOX_RELEASE(isp)
a129 12
#ifndef	SCSI_GOOD
#define	SCSI_GOOD	0x0
#endif
#ifndef	SCSI_CHECK
#define	SCSI_CHECK	0x2
#endif
#ifndef	SCSI_BUSY
#define	SCSI_BUSY	0x8
#endif
#ifndef	SCSI_QFULL
#define	SCSI_QFULL	0x28
#endif
d131 1
a131 2
#define	XS_T			struct scsi_xfer
#define	XS_CHANNEL(xs)		(((xs)->sc_link->flags & SDEV_2NDBUS)? 1 : 0)
d135 4
d140 1
a140 2
#define	XS_CDBLEN(xs)		(xs)->cmdlen
#define	XS_XFRLEN(xs)		(xs)->datalen
a141 2
#define	XS_RESID(xs)		(xs)->resid
#define	XS_STSP(xs)		(&(xs)->status)
a144 2
#define	XS_TAG_P(xs)		(((xs)->flags & SCSI_POLL) != 0)
#define	XS_TAG_TYPE(xs)		REQFLAG_STAG
d146 18
d165 2
d168 2
a169 9
#	define	HBA_NOERROR		XS_NOERROR
#	define	HBA_BOTCH		XS_DRIVER_STUFFUP
#	define	HBA_CMDTIMEOUT		XS_TIMEOUT
#	define	HBA_SELTIMEOUT		XS_SELTIMEOUT
#	define	HBA_TGTBSY		XS_BUSY
#	define	HBA_BUSRESET		XS_RESET
#	define	HBA_ABORTED		XS_DRIVER_STUFFUP
#	define	HBA_DATAOVR		XS_DRIVER_STUFFUP
#	define	HBA_ARQFAIL		XS_DRIVER_STUFFUP
d171 14
a184 1
#define	XS_ERR(xs)		(xs)->error
d186 2
a187 1
#define	XS_NOERR(xs)		(xs)->error == XS_NOERROR
d189 1
a189 1
#define	XS_INITERR(xs)		(xs)->error = 0, XS_CMD_S_CLEAR(xs)
d191 1
a191 6
#define	XS_SAVE_SENSE(xs, sp)				\
	if (xs->error == XS_NOERROR) {			\
		xs->error = XS_SENSE;			\
	}						\
	bcopy(sp->req_sense_data, &(xs)->sense,		\
	    imin(XS_SNSLEN(xs), sp->req_sense_len))
d193 1
a193 1
#define	XS_SET_STATE_STAT(a, b, c)
d195 1
a195 1
#define	DEFAULT_IID(x)		7
d197 9
a205 8
#define	DEFAULT_NODEWWN(isp)	(isp)->isp_osinfo.un._wwn
#define	DEFAULT_PORTWWN(isp)	(isp)->isp_osinfo.un._wwn
#define	ISP_NODEWWN(isp)	FCPARAM(isp)->isp_nodewwn
#define	ISP_PORTWWN(isp)	FCPARAM(isp)->isp_portwwn

#define	ISP_UNSWIZZLE_AND_COPY_PDBP(isp, dest, src)	\
	if((void *)src != (void *)dest) bcopy(src, dest, sizeof (isp_pdb_t))
#define	ISP_SWIZZLE_ICB(a, b)
d207 1
d211 1
a211 1
#define ISP_UNSWIZZLE_RESPONSE(a, b, c)			\
d214 3
a216 2
#define	ISP_SWIZZLE_REQUEST(a, b)
#define	ISP_UNSWIZZLE_RESPONSE(a, b, c)
a219 68
#ifdef	__sparc__
#define	ISP_SWIZZLE_NVRAM_WORD(isp, rp)	\
	{								\
		u_int16_t tmp = *rp >> 8;				\
		tmp |= ((*rp & 0xff) << 8);				\
		*rp = tmp;						\
	}
#else
#define	ISP_SWIZZLE_NVRAM_WORD(isp, rp)
#endif

/*
 * Includes of common header files
 */

#include <dev/ic/ispreg.h>
#include <dev/ic/ispvar.h>
#include <dev/ic/ispmbox.h>

/*
 * isp_osinfo definitions, extensions and shorthand.
 */
#define	isp_name	isp_osinfo._dev.dv_xname
#define	isp_unit	isp_osinfo._dev.dv_unit

/*
 * Driver prototypes..
 */
void isp_attach(struct ispsoftc *);
void isp_uninit(struct ispsoftc *);

static inline void isp_lock(struct ispsoftc *);
static inline void isp_unlock(struct ispsoftc *);
static inline char *strncat(char *, const char *, size_t);
static inline u_int64_t
isp_microtime_sub(struct timeval *, struct timeval *);
static void isp_wait_complete(struct ispsoftc *);

/*
 * Driver wide data...
 */

/*              
 * Platform private flags                                               
 */

#define	XS_PSTS_INWDOG		0x10000
#define	XS_PSTS_GRACE		0x20000
#define	XS_PSTS_TIMED		0x40000
#define	XS_PSTS_ALL		SCSI_PRIVATE

#define	XS_CMD_S_WDOG(xs)	(xs)->flags |= XS_PSTS_INWDOG
#define	XS_CMD_C_WDOG(xs)	(xs)->flags &= ~XS_PSTS_INWDOG
#define	XS_CMD_WDOG_P(xs)	(((xs)->flags & XS_PSTS_INWDOG) != 0)

#define	XS_CMD_S_TIMER(xs)	(xs)->flags |= XS_PSTS_TIMED
#define	XS_CMD_C_TIMER(xs)	(xs)->flags &= ~XS_PSTS_TIMED
#define	XS_CMD_TIMER_P(xs)	(((xs)->flags & XS_PSTS_TIMED) != 0)

#define	XS_CMD_S_GRACE(xs)	(xs)->flags |= XS_PSTS_GRACE
#define	XS_CMD_C_GRACE(xs)	(xs)->flags &= ~XS_PSTS_GRACE
#define	XS_CMD_GRACE_P(xs)	(((xs)->flags & XS_PSTS_GRACE) != 0)

#define	XS_CMD_S_DONE(xs)	(xs)->flags |= ITSDONE
#define	XS_CMD_C_DONE(xs)	(xs)->flags &= ~ITSDONE
#define	XS_CMD_DONE_P(xs)	(((xs)->flags & ITSDONE) != 0)

#define	XS_CMD_S_CLEAR(xs)	(xs)->flags &= ~XS_PSTS_ALL
d221 1
a221 99
/*
 * Platform specific 'inline' or support functions
 */
static inline void
isp_lock(struct ispsoftc *isp)
{
	int s = splbio();
	if (isp->isp_osinfo.islocked++ == 0) {
		isp->isp_osinfo.splsaved = s;
	} else {
		splx(s);
	}
}

static inline void
isp_unlock(struct ispsoftc *isp)
{
	if (isp->isp_osinfo.islocked-- <= 1) {
		isp->isp_osinfo.islocked = 0;
		splx(isp->isp_osinfo.splsaved);
	}
}

static inline char *
strncat(char *d, const char *s, size_t c)
{
        char *t = d;

        if (c) {
                while (*d)
                        d++;
                while ((*d++ = *s++)) {
                        if (--c == 0) {
                                *d = '\0';
                                break;
                        }
                }
        }
        return (t);
}

static inline u_int64_t
isp_microtime_sub(struct timeval *b, struct timeval *a)
{
	struct timeval x;
	u_int64_t elapsed;
	timersub(b, a, &x);
	elapsed = GET_NANOSEC(&x);
	if (elapsed == 0)
		elapsed++;
	return (elapsed);
}

static inline void
isp_wait_complete(struct ispsoftc *isp)
{
	if (MUST_POLL(isp)) {
		int usecs = 0;
		while (usecs < 2 * 1000000) {
			(void) isp_intr(isp);
			if (isp->isp_mboxbsy == 0) {
				break;
			}
			USEC_DELAY(500);
			usecs += 500;
		}
		if (isp->isp_mboxbsy != 0) {
			isp_prt(isp, ISP_LOGWARN,
			    "Polled Mailbox Command (0x%x) Timeout",
			    isp->isp_lastmbxcmd);
		}
	} else {
		int rv = 0;
                isp->isp_osinfo.mboxwaiting = 1;
                while (isp->isp_osinfo.mboxwaiting && rv == 0) {
			static struct timeval fivesec = { 5, 0 };
			int timo;
			struct timeval tv;
			microtime(&tv);
			timeradd(&tv, &fivesec, &tv);
			if ((timo = hzto(&tv)) == 0) {
				timo = 1;
			}
			rv = tsleep(&isp->isp_osinfo.mboxwaiting,
			    PRIBIO, "isp_mboxcmd", timo);
		}
		if (rv == EWOULDBLOCK) {
			isp->isp_mboxbsy = 0;
			isp->isp_osinfo.mboxwaiting = 0;
			isp_prt(isp, ISP_LOGWARN,
			    "Interrupting Mailbox Command (0x%x) Timeout",
			    isp->isp_lastmbxcmd);
		}
	}
}

/*
 * Common inline functions
 */
d224 1
a224 1
#endif	/* _ISP_NETBSD_H */
@


1.6.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.6.2.3 2001/05/14 22:23:55 niklas Exp $ */
d52 2
d342 1
a342 1
			u_int16_t isr, sema, mbox;
a344 6
			}
			if (ISP_READ_ISR(isp, &isr, &sema, &mbox)) {
				isp_intr(isp, isr, sema, mbox);
				if (isp->isp_mboxbsy == 0) {
					break;
				}
@


1.6.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d51 1
a51 1
#include <uvm/uvm_extern.h>
@


1.6.2.6
log
@Merge in trunk
@
text
@a43 4
#if	!(defined(__sparc__) && !defined(__sparcv9__))
#include <machine/bus.h>
#endif

a52 8
/*
 * Efficiency- get rid of SBus code && tests unless we need them.
 */
#if	defined(__sparcv9__ ) || defined(__sparc__)
#define	ISP_SBUS_SUPPORTED	1
#else
#define	ISP_SBUS_SUPPORTED	0
#endif
d55 1
a55 1
#define	ISP_PLATFORM_VERSION_MINOR	1
a65 10
#if	!(defined(__sparc__) && !defined(__sparcv9__))
	bus_dma_tag_t		dmatag;
	bus_dmamap_t		rqdmap;
	bus_dmamap_t		rsdmap;
	bus_dmamap_t		scdmap;	/* FC only */
#define	isp_dmatag		isp_osinfo.dmatag
#define	isp_rqdmap		isp_osinfo.rqdmap
#define	isp_rsdmap		isp_osinfo.rsdmap
#define	isp_scdmap		isp_osinfo.scdmap
#endif
d115 2
a116 40
#if	!(defined(__sparc__) && !defined(__sparcv9__))
#define	MEMORYBARRIER(isp, type, offset, size)			\
switch (type) {							\
case SYNC_REQUEST:						\
{								\
	off_t off = (off_t) offset * QENTRY_LEN;		\
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_rqdmap,	\
	    off, size, BUS_DMASYNC_PREWRITE);			\
	break;							\
}								\
case SYNC_RESULT:						\
{								\
	off_t off = (off_t) offset * QENTRY_LEN;		\
	off += ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));		\
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_rsdmap,	\
	    off, size, BUS_DMASYNC_POSTREAD);			\
	break;							\
}								\
case SYNC_SFORDEV:						\
{								\
	off_t off =						\
	    ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp)) +		\
	    ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp)) + offset;	\
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_scdmap,	\
	    off, size, BUS_DMASYNC_PREWRITE);			\
	break;							\
}								\
case SYNC_SFORCPU:						\
{								\
	off_t off =						\
	    ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp)) +		\
	    ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp)) + offset;	\
	bus_dmamap_sync(isp->isp_dmatag, isp->isp_scdmap,	\
	    off, size, BUS_DMASYNC_POSTREAD);			\
	break;							\
}								\
case SYNC_REG:							\
default:							\
	break;							\
}
d122 1
a122 1
#define	MBOX_WAIT_COMPLETE		isp_wait_complete
d197 9
a205 15
#if	BYTE_ORDER == BIG_ENDIAN
#ifdef	ISP_SBUS_SUPPORTED
#define	ISP_IOXPUT_8(isp, s, d)		*(d) = s
#define	ISP_IOXPUT_16(isp, s, d)				\
	*(d) = (isp->isp_bustype == ISP_BT_SBUS)? s : swap16(s)
#define	ISP_IOXPUT_32(isp, s, d)				\
	*(d) = (isp->isp_bustype == ISP_BT_SBUS)? s : swap32(s)

#define	ISP_IOXGET_8(isp, s, d)		d = (*((u_int8_t *)s))
#define	ISP_IOXGET_16(isp, s, d)				\
	d = (isp->isp_bustype == ISP_BT_SBUS)?			\
	*((u_int16_t *)s) : swap16(*((u_int16_t *)s))
#define	ISP_IOXGET_32(isp, s, d)				\
	d = (isp->isp_bustype == ISP_BT_SBUS)?			\
	*((u_int32_t *)s) : swap32(*((u_int32_t *)s))
d207 2
a208 6
#define	ISP_IOXPUT_8(isp, s, d)		*(d) = s
#define	ISP_IOXPUT_16(isp, s, d)	*(d) = swap16(s)
#define	ISP_IOXPUT_32(isp, s, d)	*(d) = swap32(s)
#define	ISP_IOXGET_8(isp, s, d)		d = (*((u_int8_t *)s))
#define	ISP_IOXGET_16(isp, s, d)	d = swap16(*((u_int16_t *)s))
#define	ISP_IOXGET_32(isp, s, d)	d = swap32(*((u_int32_t *)s))
d210 9
a218 1
#define	ISP_SWIZZLE_NVRAM_WORD(isp, rp)	*rp = swap16(*rp)
a219 6
#define	ISP_IOXPUT_8(isp, s, d)		*(d) = s
#define	ISP_IOXPUT_16(isp, s, d)	*(d) = s
#define	ISP_IOXPUT_32(isp, s, d)	*(d) = s
#define	ISP_IOXGET_8(isp, s, d)		d = *(s)
#define	ISP_IOXGET_16(isp, s, d)	d = *(s)
#define	ISP_IOXGET_32(isp, s, d)	d = *(s)
d339 1
a339 1
		while (usecs < 5 * 1000000) {
d362 8
d371 1
a371 1
			    PRIBIO, "isp_mboxcmd", 5 * hz);
@


1.6.2.7
log
@Merge in -current from about a week ago
@
text
@d150 1
d157 3
a159 1
	off_t off = (off_t) offset;				\
d166 3
a168 1
	off_t off = (off_t) offset;				\
@


1.6.2.8
log
@Sync the SMP branch with 3.3
@
text
@d49 1
d116 1
a116 1
#define	ISP2100_SCRLEN		0x800
d121 1
a187 3
#define	FC_SCRATCH_ACQUIRE(isp)
#define	FC_SCRATCH_RELEASE(isp)

d306 4
a309 4
static INLINE void isp_lock(struct ispsoftc *);
static INLINE void isp_unlock(struct ispsoftc *);
static INLINE char *strncat(char *, const char *, size_t);
static INLINE u_int64_t
d345 1
a345 1
 * Platform specific 'INLINE' or support functions
d347 1
a347 1
static INLINE void
d358 1
a358 1
static INLINE void
d367 1
a367 1
static INLINE char *
d385 1
a385 1
static INLINE u_int64_t
d397 1
a397 1
static INLINE void
a399 5
	int delaytime;
	if (isp->isp_mbxwrk0)
		delaytime = 60;
	else
		delaytime = 5;
d402 1
a402 2
		delaytime *= 1000000;	/* convert to usecs */
		while (usecs < delaytime) {
d426 1
a426 1
			    PRIBIO, "isp_mboxcmd", delaytime * hz);
d439 1
a439 1
 * Common INLINE functions
@


1.6.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*      $OpenBSD: isp_openbsd.h,v 1.6.2.8 2003/03/28 00:38:14 niklas Exp $ */
d309 1
d366 18
@


1.5
log
@make CFGPRINTF only available for SCSIDEBUG/DEBUG kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_openbsd.h,v 1.4 1999/11/22 12:50:53 mjacob Exp $ */
d66 1
a66 1
#define	ISP_PLATFORM_VERSION_MINOR	5
d71 1
a71 1
	struct scsi_link	_link;
d112 3
a117 3
#elif	defined(DEBUG)
#define	DFLT_DBLEVEL		2
#define	CFGPRINTF		printf
d136 1
a136 1
#define	XS_CHANNEL(xs)		0	/* only one channel supported */
@


1.4
log
@Far too many things to note- a complete new revision coming in including
FABRIC support...
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_openbsd.h,v 1.3 1999/03/25 22:58:38 mjacob Exp $ */
d114 1
a114 1
#define	CFGPRINTF		printf
@


1.3
log
@roll internal revision levels and enable 1080 support
@
text
@d1 1
a1 2
/*	$OpenBSD: isp_openbsd.h,v 1.2 1999/03/17 12:54:32 mjacob Exp $ */
/* release_03_25_99 */
d51 1
d66 1
a66 1
#define	ISP_PLATFORM_VERSION_MINOR	2
d73 8
a80 1
	int8_t			delay_throttle_count;
d84 5
d94 1
a95 1
#define	IDPRINTF(lev, x)	if (isp->isp_dblev >= lev) printf x
d106 3
d111 5
a115 2
#else
#if	defined(DEBUG)
d117 1
d119 2
a120 2
#define	DFLT_DBLEVEL		1
#endif
d136 1
d139 1
a139 1
#define	XS_CDBP(xs)		(xs)->cmd
d179 1
a179 1
#define	XS_KINDOF_TAG(xs)	REQFLAG_STAG
d181 4
a184 3
#define	CMD_COMPLETE		COMPLETE
#define	CMD_EAGAIN		TRY_AGAIN_LATER
#define	CMD_QUEUED		SUCCESSFULLY_QUEUED
d187 1
d189 1
a189 1
#define	FC_FW_READY_DELAY	(12 * 1000000)
d193 5
a197 1
#define	WATCH_INTERVAL	10
a201 89
static inline void isp_prtstst __P((ispstatusreq_t *));
static inline const char *isp2100_fw_statename __P((int));
static inline const char * isp2100_pdb_statename __P((int));

static inline void
isp_prtstst(sp)
	ispstatusreq_t *sp;
{
	char buf[128];
	sprintf(buf, "states->");
	if (sp->req_state_flags & RQSF_GOT_BUS)
		sprintf(buf, "%s%s", buf, "GOT_BUS ");
	if (sp->req_state_flags & RQSF_GOT_TARGET)
		sprintf(buf, "%s%s", buf, "GOT_TGT ");
	if (sp->req_state_flags & RQSF_SENT_CDB)
		sprintf(buf, "%s%s", buf, "SENT_CDB ");
	if (sp->req_state_flags & RQSF_XFRD_DATA)
		sprintf(buf, "%s%s", buf, "XFRD_DATA ");
	if (sp->req_state_flags & RQSF_GOT_STATUS)
		sprintf(buf, "%s%s", buf, "GOT_STS ");
	if (sp->req_state_flags & RQSF_GOT_SENSE)
		sprintf(buf, "%s%s", buf, "GOT_SNS ");
	if (sp->req_state_flags & RQSF_XFER_COMPLETE)
		sprintf(buf, "%s%s", buf, "XFR_CMPLT ");
	sprintf(buf, "%s%s", buf, "\n");
	sprintf(buf, "%s%s", buf, "status->");
	if (sp->req_status_flags & RQSTF_DISCONNECT)
		sprintf(buf, "%s%s", buf, "Disconnect ");
	if (sp->req_status_flags & RQSTF_SYNCHRONOUS)
		sprintf(buf, "%s%s", buf, "Sync_xfr ");
	if (sp->req_status_flags & RQSTF_PARITY_ERROR)
		sprintf(buf, "%s%s", buf, "Parity ");
	if (sp->req_status_flags & RQSTF_BUS_RESET)
		sprintf(buf, "%s%s", buf, "Bus_Reset ");
	if (sp->req_status_flags & RQSTF_DEVICE_RESET)
		sprintf(buf, "%s%s", buf, "Device_Reset ");
	if (sp->req_status_flags & RQSTF_ABORTED)
		sprintf(buf, "%s%s", buf, "Aborted ");
	if (sp->req_status_flags & RQSTF_TIMEOUT)
		sprintf(buf, "%s%s", buf, "Timeout ");
	if (sp->req_status_flags & RQSTF_NEGOTIATION)
		sprintf(buf, "%s%s", buf, "Negotiation ");
	sprintf(buf, "%s%s", buf, "\n");
	printf(buf);
}

static inline const char *
isp2100_fw_statename(state)
	int state;
{
	static char buf[16];
	switch(state) {
	case FW_CONFIG_WAIT:	return "Config Wait";
	case FW_WAIT_AL_PA:	return "Waiting for AL_PA";
	case FW_WAIT_LOGIN:	return "Wait Login";
	case FW_READY:		return "Ready";
	case FW_LOSS_OF_SYNC:	return "Loss Of Sync";
	case FW_ERROR:		return "Error";
	case FW_REINIT:		return "Re-Init";
	case FW_NON_PART:	return "Non-Participating";
	default:
		sprintf(buf, "0x%x", state);
		return buf;
	}
}

static inline const char *
isp2100_pdb_statename(pdb_state)
	int pdb_state;
{
	static char buf[16];
	switch(pdb_state) {
	case PDB_STATE_DISCOVERY:	return "Port Discovery";
	case PDB_STATE_WDISC_ACK:	return "Waiting Port Discovery ACK";
	case PDB_STATE_PLOGI:		return "Port Login";
	case PDB_STATE_PLOGI_ACK:	return "Wait Port Login ACK";
	case PDB_STATE_PRLI:		return "Process Login";
	case PDB_STATE_PRLI_ACK:	return "Wait Process Login ACK";
	case PDB_STATE_LOGGED_IN:	return "Logged In";
	case PDB_STATE_PORT_UNAVAIL:	return "Port Unavailable";
	case PDB_STATE_PRLO:		return "Process Logout";
	case PDB_STATE_PRLO_ACK:	return "Wait Process Logout ACK";
	case PDB_STATE_PLOGO:		return "Port Logout";
	case PDB_STATE_PLOG_ACK:	return "Wait Port Logout ACK";
	default:
		sprintf(buf, "0x%x", pdb_state);
		return buf;
	}
}
d203 15
a217 3
/*
 * Keep these off for now...
 */
d219 2
a220 2
#define	ISP_NO_FASTPOST_SCSI	1
#define	ISP_NO_FASTPOST_FC	1
@


1.2
log
@fix OpenBSD headers
@
text
@d1 2
a2 2
/*	$OpenBSD: isp_openbsd.h,v 1.1 1999/03/17 05:26:09 mjacob Exp $ */
/* release_03_16_99 */
d7 1
a7 1
 * Copyright (c) 1997, 1998, 1999 by Matthew Jacob
d66 1
a66 1
#define	ISP_PLATFORM_VERSION_MINOR	1
d73 1
d171 1
a171 1
#define	WATCH_INTERVAL	30
a271 2

#define	ISP_DISABLE_1080_SUPPORT	1
@


1.1
log
@complete update of ISP driver- includes 2100 FC support
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
@

