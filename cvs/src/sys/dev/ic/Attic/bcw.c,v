head	1.89;
access;
symbols
	OPENBSD_4_1:1.68.0.2
	OPENBSD_4_1_BASE:1.68;
locks; strict;
comment	@ * @;


1.89
date	2007.04.05.16.25.25;	author mglocker;	state dead;
branches;
next	1.88;

1.88
date	2007.04.04.20.48.12;	author mglocker;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.04.19.36.41;	author mglocker;	state Exp;
branches;
next	1.86;

1.86
date	2007.04.01.19.15.48;	author mglocker;	state Exp;
branches;
next	1.85;

1.85
date	2007.04.01.12.16.28;	author mglocker;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.01.00.08.17;	author mglocker;	state Exp;
branches;
next	1.83;

1.83
date	2007.03.31.23.50.59;	author mglocker;	state Exp;
branches;
next	1.82;

1.82
date	2007.03.31.23.38.03;	author mglocker;	state Exp;
branches;
next	1.81;

1.81
date	2007.03.31.09.48.02;	author mglocker;	state Exp;
branches;
next	1.80;

1.80
date	2007.03.20.21.14.39;	author mglocker;	state Exp;
branches;
next	1.79;

1.79
date	2007.03.20.13.52.48;	author mglocker;	state Exp;
branches;
next	1.78;

1.78
date	2007.03.20.11.55.36;	author mglocker;	state Exp;
branches;
next	1.77;

1.77
date	2007.03.18.15.00.28;	author mglocker;	state Exp;
branches;
next	1.76;

1.76
date	2007.03.18.14.40.47;	author mglocker;	state Exp;
branches;
next	1.75;

1.75
date	2007.03.16.22.22.24;	author mglocker;	state Exp;
branches;
next	1.74;

1.74
date	2007.03.16.15.28.54;	author mglocker;	state Exp;
branches;
next	1.73;

1.73
date	2007.03.16.13.49.11;	author mglocker;	state Exp;
branches;
next	1.72;

1.72
date	2007.03.16.12.16.31;	author mglocker;	state Exp;
branches;
next	1.71;

1.71
date	2007.03.15.14.30.49;	author mglocker;	state Exp;
branches;
next	1.70;

1.70
date	2007.03.12.22.29.38;	author mglocker;	state Exp;
branches;
next	1.69;

1.69
date	2007.03.12.06.51.16;	author mglocker;	state Exp;
branches;
next	1.68;

1.68
date	2007.03.04.19.04.31;	author mglocker;	state Exp;
branches;
next	1.67;

1.67
date	2007.03.04.16.10.10;	author mglocker;	state Exp;
branches;
next	1.66;

1.66
date	2007.03.04.15.41.58;	author mglocker;	state Exp;
branches;
next	1.65;

1.65
date	2007.03.04.14.27.27;	author mglocker;	state Exp;
branches;
next	1.64;

1.64
date	2007.03.04.00.43.26;	author mglocker;	state Exp;
branches;
next	1.63;

1.63
date	2007.03.01.19.48.00;	author mglocker;	state Exp;
branches;
next	1.62;

1.62
date	2007.02.27.07.04.18;	author mglocker;	state Exp;
branches;
next	1.61;

1.61
date	2007.02.26.16.15.35;	author mglocker;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.26.15.40.04;	author mglocker;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.25.17.03.08;	author mglocker;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.25.09.59.18;	author mglocker;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.24.23.05.04;	author mglocker;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.24.11.59.33;	author mglocker;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.23.22.28.08;	author mglocker;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.23.20.30.20;	author mglocker;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.23.20.10.32;	author mglocker;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.23.19.51.37;	author mglocker;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.23.19.44.37;	author mglocker;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.23.14.27.00;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.23.12.24.55;	author mglocker;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.23.10.52.24;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2007.02.23.10.40.54;	author mglocker;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.22.21.26.49;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.22.19.25.45;	author mglocker;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.22.17.04.31;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.20.21.24.36;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.18.16.03.33;	author mglocker;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.18.15.19.03;	author mglocker;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.18.15.14.38;	author mglocker;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.18.11.42.40;	author mglocker;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.18.09.37.21;	author mglocker;	state Exp;
branches;
next	1.37;

1.37
date	2007.02.18.00.05.39;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.14.10.48.23;	author mglocker;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.07.11.10.51;	author mglocker;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.07.00.29.44;	author mglocker;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.06.20.33.09;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.06.18.35.09;	author mglocker;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.05.12.52.30;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.05.11.36.23;	author mglocker;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.05.10.37.19;	author mglocker;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.05.10.20.04;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.05.10.17.32;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2007.01.05.07.09.15;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2007.01.03.18.54.29;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.03.14.58.33;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.03.10.41.04;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2007.01.03.06.31.54;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.03.06.24.09;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.03.06.20.14;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.03.06.10.47;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.03.06.02.27;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.03.05.53.03;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.03.05.46.42;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.03.05.44.59;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.28.22.40.57;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.28.22.23.07;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.27.14.22.48;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.27.14.05.57;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.08.01.28.40;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.06.19.21.45;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.29.21.34.06;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.26.11.14.17;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.24.20.27.41;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.22.22.20.34;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.22.15.12.50;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.21.11.41.14;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.17.20.04.52;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.17.18.58.31;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.89
log
@After been attacked by Michael Buesch <mb@@bu3sch.de> because we initially
were using some of their routines in the bcw driver, I decided to stop
working on it.  To avoid any further license chit chat I plain drop the
driver.
@
text
@/*	$OpenBSD: bcw.c,v 1.88 2007/04/04 20:48:12 mglocker Exp $ */

/*
 * Copyright (c) 2007 Marcus Glocker <mglocker@@openbsd.org>
 * Copyright (c) 2006 Jon Simola <jsimola@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Broadcom BCM43xx Wireless network chipsets (broadcom.com)
 * SiliconBackplane is technology from Sonics, Inc. (sonicsinc.com)
 */
 
#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/bcwreg.h>
#include <dev/ic/bcwvar.h>

#include <uvm/uvm_extern.h>

/*
 * Helper Routines
 */
void			bcw_shm_ctl_word(struct bcw_softc *, uint16_t,
			    uint16_t);
uint16_t		bcw_shm_read16(struct bcw_softc *, uint16_t, uint16_t);
void			bcw_shm_write16(struct bcw_softc *, uint16_t, uint16_t,
			    uint16_t);
uint32_t		bcw_shm_read32(struct bcw_softc *, uint16_t, uint16_t);
void			bcw_shm_write32(struct bcw_softc *, uint16_t, uint16_t,
			    uint32_t);
void			bcw_radio_write16(struct bcw_softc *, uint16_t,
			    uint16_t);
int			bcw_radio_read16(struct bcw_softc *, uint16_t);
void			bcw_phy_write16(struct bcw_softc *, uint16_t, uint16_t);
int			bcw_phy_read16(struct bcw_softc *, uint16_t);
void			bcw_ram_write(struct bcw_softc *, uint16_t, uint32_t);
int			bcw_lv(int, int, int);
void			bcw_dummy_transmission(struct bcw_softc *);
struct bcw_lopair *	bcw_get_lopair(struct bcw_softc *, uint16_t,
			    uint16_t);
void			bcw_stack_save(uint32_t *, size_t *, uint8_t, uint16_t,
			    uint16_t);
uint16_t		bcw_stack_restore(uint32_t *, uint8_t, uint16_t);
int			bcw_using_pio(struct bcw_softc *);
void			bcw_rate_memory_write(struct bcw_softc *, uint16_t,
			    int);
void			bcw_rate_memory_init(struct bcw_softc *);
uint16_t		bcw_flip_4bit(uint16_t);

/*
 * 80211
 */
int			bcw_init(struct ifnet *);
void			bcw_start(struct ifnet *);
void			bcw_stop(struct ifnet *, int);
void			bcw_watchdog(struct ifnet *);
void			bcw_set_opmode(struct ifnet *);
void			bcw_macfilter_set(struct bcw_softc *, uint16_t,
			    const uint8_t *);
void			bcw_macfilter_clear(struct bcw_softc *, uint16_t);
void			bcw_templateram_set(struct bcw_softc *);
void			bcw_mac_enable(struct bcw_softc *);
void			bcw_mac_disable(struct bcw_softc *);
uint32_t		bcw_intr_enable(struct bcw_softc *, uint32_t);
uint32_t		bcw_intr_disable(struct bcw_softc *, uint32_t);
void			bcw_rxintr(struct bcw_softc *);
void			bcw_txintr(struct bcw_softc *);
int			bcw_add_rxbuf(struct bcw_softc *, int);
void			bcw_rxdrain(struct bcw_softc *);
void			bcw_tick(void *);
int			bcw_ioctl(struct ifnet *, u_long, caddr_t);
int			bcw_alloc_rx_ring(struct bcw_softc *,
			    struct bcw_rx_ring *, int);
void			bcw_reset_rx_ring(struct bcw_softc *,
			    struct bcw_rx_ring *);
void			bcw_free_rx_ring(struct bcw_softc *,
			    struct bcw_rx_ring *);
int			bcw_alloc_tx_ring(struct bcw_softc *,
			    struct bcw_tx_ring *, int);
void			bcw_reset_tx_ring(struct bcw_softc *,
			    struct bcw_tx_ring *);
void			bcw_free_tx_ring(struct bcw_softc *,
			    struct bcw_tx_ring *);
int			bcw_newstate(struct ieee80211com *,
			    enum ieee80211_state, int);
int			bcw_media_change(struct ifnet *);
void			bcw_media_status(struct ifnet *, struct ifmediareq *);
int			bcw_validate_chip_access(struct bcw_softc *);
int			bcw_change_core(struct bcw_softc *, int);
int			bcw_core_enable(struct bcw_softc *, uint32_t);
int			bcw_core_disable(struct bcw_softc *, uint32_t);
void			bcw_80211_core_reset(struct bcw_softc *, int);
void			bcw_80211_core_disable(struct bcw_softc *);
int			bcw_iocore_enable(struct bcw_softc *, uint32_t);
int			bcw_get_firmware(const char *, const uint8_t *, size_t,
			    size_t *, size_t *);
int			bcw_load_firmware(struct bcw_softc *);
int			bcw_write_initvals(struct bcw_softc *,
			    const struct bcw_initval *, const unsigned int);
int			bcw_load_initvals(struct bcw_softc *);
void			bcw_leds_switch_all(struct bcw_softc *, int);
int			bcw_gpio_init(struct bcw_softc *);
int			bcw_chip_init(struct bcw_softc *);
int			bcw_bs_init(struct bcw_softc *);
int			bcw_80211_core_init(struct bcw_softc *, int);
uint8_t			bcw_sprom_crc8(uint8_t, uint8_t);
uint8_t			bcw_sprom_crc(const uint16_t *);
int			bcw_sprom_read(struct bcw_softc *, uint16_t *);
int			bcw_sprom_get(struct bcw_softc *);
void			bcw_microcode_init_fbf(struct bcw_softc *);

/*
 * PHY
 */
int			bcw_phy_get(struct bcw_softc *);
int			bcw_phy_init(struct bcw_softc *);
void			bcw_phy_initg(struct bcw_softc *);
void			bcw_phy_initb2(struct bcw_softc *);
void			bcw_phy_initb4(struct bcw_softc *);
void			bcw_phy_initb5(struct bcw_softc *);
void			bcw_phy_initb6(struct bcw_softc *);
void			bcw_phy_inita(struct bcw_softc *);
void			bcw_phy_setupa(struct bcw_softc *);
void			bcw_phy_setupg(struct bcw_softc *);
void			bcw_phy_calc_loopback_gain(struct bcw_softc *);
void			bcw_phy_agcsetup(struct bcw_softc *);
void			bcw_phy_init_pctl(struct bcw_softc *);
void			bcw_phy_init_noisescaletbl(struct bcw_softc *);
void			bcw_phy_set_baseband_atten(struct bcw_softc *,
			    uint16_t);
int8_t			bcw_phy_estimate_powerout(struct bcw_softc *, int8_t);
void			bcw_phy_xmitpower(struct bcw_softc *);
uint16_t		bcw_phy_lo_b_r15_loop(struct bcw_softc *);
void			bcw_phy_lo_b_measure(struct bcw_softc *);
void			bcw_phy_lo_g_state(struct bcw_softc *,
			    struct bcw_lopair *, struct bcw_lopair *, uint16_t);
void			bcw_phy_lo_g_measure(struct bcw_softc *);
void			bcw_phy_lo_g_measure_txctl2(struct bcw_softc *);
uint32_t		bcw_phy_lo_g_singledeviation(struct bcw_softc *,
			    uint16_t);
uint16_t		bcw_phy_lo_g_deviation_subval(struct bcw_softc *,
			    uint16_t);
void			bcw_phy_lo_adjust(struct bcw_softc *, int);
void			bcw_phy_lo_mark_current_used(struct bcw_softc *);
void			bcw_phy_lo_write(struct bcw_softc *,
			    struct bcw_lopair *);
struct bcw_lopair *	bcw_phy_find_lopair(struct bcw_softc *, uint16_t,
			    uint16_t, uint16_t);
struct bcw_lopair *	bcw_phy_current_lopair(struct bcw_softc *);
void			bcw_phy_set_antenna_diversity(struct bcw_softc *);
void			bcw_phy_calibrate(struct bcw_softc *);
int			bcw_phy_connect(struct bcw_softc *, int);
void			bcw_phy_lock(struct bcw_softc *);
void			bcw_phy_unlock(struct bcw_softc *);

/*
 * Radio
 */
int			bcw_radio_get(struct bcw_softc *);
void			bcw_radio_off(struct bcw_softc *);
void			bcw_radio_on(struct bcw_softc *);
void			bcw_radio_nrssi_hw_write(struct bcw_softc *,
			    uint16_t, int16_t);
int16_t			bcw_radio_nrssi_hw_read(struct bcw_softc *, uint16_t);
void			bcw_radio_nrssi_hw_update(struct bcw_softc *, uint16_t);
void			bcw_radio_calc_nrssi_threshold(struct bcw_softc *);
void			bcw_radio_calc_nrssi_slope(struct bcw_softc *);
void			bcw_radio_calc_nrssi_offset(struct bcw_softc *);
void			bcw_radio_set_all_gains(struct bcw_softc *, int16_t,
			    int16_t, int16_t);
void			bcw_radio_set_original_gains(struct bcw_softc *);
uint16_t		bcw_radio_calibrationvalue(struct bcw_softc *);
void			bcw_radio_set_txpower_a(struct bcw_softc *, uint16_t);
void			bcw_radio_set_txpower_bg(struct bcw_softc *, uint16_t,
			    uint16_t, uint16_t);
uint16_t		bcw_radio_init2050(struct bcw_softc *);
void			bcw_radio_init2060(struct bcw_softc *);
void			bcw_radio_spw(struct bcw_softc *, uint8_t);
int			bcw_radio_select_channel(struct bcw_softc *, uint8_t,
			    int);
uint16_t		bcw_radio_chan2freq_a(uint8_t);
uint16_t		bcw_radio_chan2freq_bg(uint8_t);
uint16_t		bcw_radio_default_baseband_atten(struct bcw_softc *);
uint16_t		bcw_radio_default_radio_atten(struct bcw_softc *);
uint16_t		bcw_radio_default_txctl1(struct bcw_softc *);
void			bcw_radio_clear_tssi(struct bcw_softc *);
void			bcw_radio_set_tx_iq(struct bcw_softc *);
uint16_t		bcw_radio_get_txgain_baseband(uint16_t);
uint16_t		bcw_radio_get_txgain_freq_power_amp(uint16_t);
uint16_t		bcw_radio_get_txgain_dac(uint16_t);
uint16_t		bcw_radio_freq_r3a_value(uint16_t);
int			bcw_radio_set_interf_mitigation(struct bcw_softc *,
			    int);
int			bcw_radio_interf_mitigation_enable(struct bcw_softc *,
			    int);
void			bcw_radio_set_txantenna(struct bcw_softc *, uint32_t);
void			bcw_radio_lock(struct bcw_softc *);
void			bcw_radio_unlock(struct bcw_softc *);

/*
 * ILT
 */
void			bcw_ilt_write(struct bcw_softc *, uint16_t, uint16_t);
uint16_t		bcw_ilt_read(struct bcw_softc *, uint16_t);

/*
 * Power Control
 */
void			bcw_pc_crystal_on(struct bcw_softc *);
void			bcw_pc_crystal_off(struct bcw_softc *);
int			bcw_pc_init(struct bcw_softc *);
int			bcw_pc_set_clock(struct bcw_softc *, uint16_t);
void			bcw_pc_saving_ctl_bits(struct bcw_softc *, int, int);
uint16_t		bcw_pc_powerup_delay(struct bcw_softc *);
int			bcw_pc_clock_freqlimit(struct bcw_softc *, int);
int			bcw_pc_get_slowclocksrc(struct bcw_softc *);

/*
 * XMIT
 */
uint8_t			bcw_xmit_plcp_get_ratecode_cck(const uint8_t);
uint8_t			bcw_xmit_plcp_get_ratecode_ofdm(const uint8_t);

struct cfdriver bcw_cd = {
	NULL, "bcw", DV_IFNET
};

#define BCW_PHY_STACKSAVE(offset)				\
	do {							\
		bcw_stack_save(stack, &stackidx, 0x1, (offset),	\
		    bcw_phy_read16(sc, (offset)));		\
	} while (0)
#define BCW_ILT_STACKSAVE(offset)				\
	do {							\
		bcw_stack_save(stack, &stackidx, 0x3, (offset), \
		    bcw_ilt_read(sc, (offset)));		\
	} while (0)
#define BCW_RADIO_STACKSAVE(offset)				\
	do {							\
		bcw_stack_save(stack, &stackidx, 0x2, (offset), \
		    bcw_radio_read16(sc, (offset)));		\
	} while (0)

/*
 * Table for bcw_radio_calibrationvalue()
 */
const uint16_t rcc_table[16] = {
	0x0002, 0x0003, 0x0001, 0x000F,
	0x0006, 0x0007, 0x0005, 0x000F,
	0x000A, 0x000B, 0x0009, 0x000F,
	0x000E, 0x000F, 0x000D, 0x000F,
};

/*
 * ILT (Internal Lookup Table)
 */
const uint32_t bcw_ilt_rotor[BCW_ILT_ROTOR_SIZE] = {
	0xFEB93FFD, 0xFEC63FFD, /* 0 */
	0xFED23FFD, 0xFEDF3FFD,
	0xFEEC3FFE, 0xFEF83FFE,
	0xFF053FFE, 0xFF113FFE,
	0xFF1E3FFE, 0xFF2A3FFF, /* 8 */
	0xFF373FFF, 0xFF443FFF,
	0xFF503FFF, 0xFF5D3FFF,
	0xFF693FFF, 0xFF763FFF,
	0xFF824000, 0xFF8F4000, /* 16 */
	0xFF9B4000, 0xFFA84000,
	0xFFB54000, 0xFFC14000,
	0xFFCE4000, 0xFFDA4000,
	0xFFE74000, 0xFFF34000, /* 24 */
	0x00004000, 0x000D4000,
	0x00194000, 0x00264000,
	0x00324000, 0x003F4000,
	0x004B4000, 0x00584000, /* 32 */
	0x00654000, 0x00714000,
	0x007E4000, 0x008A3FFF,
	0x00973FFF, 0x00A33FFF,
	0x00B03FFF, 0x00BC3FFF, /* 40 */
	0x00C93FFF, 0x00D63FFF,
	0x00E23FFE, 0x00EF3FFE,
	0x00FB3FFE, 0x01083FFE,
	0x01143FFE, 0x01213FFD, /* 48 */
	0x012E3FFD, 0x013A3FFD,
	0x01473FFD,
};

const uint16_t bcw_ilt_sigmasqr1[BCW_ILT_SIGMASQR_SIZE] = {
	0x007A, 0x0075, 0x0071, 0x006C, /* 0 */
	0x0067, 0x0063, 0x005E, 0x0059,
	0x0054, 0x0050, 0x004B, 0x0046,
	0x0042, 0x003D, 0x003D, 0x003D,
	0x003D, 0x003D, 0x003D, 0x003D, /* 16 */
	0x003D, 0x003D, 0x003D, 0x003D,
	0x003D, 0x003D, 0x0000, 0x003D,
	0x003D, 0x003D, 0x003D, 0x003D,
	0x003D, 0x003D, 0x003D, 0x003D, /* 32 */
	0x003D, 0x003D, 0x003D, 0x003D,
	0x0042, 0x0046, 0x004B, 0x0050,
	0x0054, 0x0059, 0x005E, 0x0063,
	0x0067, 0x006C, 0x0071, 0x0075, /* 48 */
	0x007A,
};

const uint16_t bcw_ilt_sigmasqr2[BCW_ILT_SIGMASQR_SIZE] = {
	0x00DE, 0x00DC, 0x00DA, 0x00D8, /* 0 */
	0x00D6, 0x00D4, 0x00D2, 0x00CF,
	0x00CD, 0x00CA, 0x00C7, 0x00C4,
	0x00C1, 0x00BE, 0x00BE, 0x00BE,
	0x00BE, 0x00BE, 0x00BE, 0x00BE, /* 16 */
	0x00BE, 0x00BE, 0x00BE, 0x00BE,
	0x00BE, 0x00BE, 0x0000, 0x00BE,
	0x00BE, 0x00BE, 0x00BE, 0x00BE,
	0x00BE, 0x00BE, 0x00BE, 0x00BE, /* 32 */
	0x00BE, 0x00BE, 0x00BE, 0x00BE,
	0x00C1, 0x00C4, 0x00C7, 0x00CA,
	0x00CD, 0x00CF, 0x00D2, 0x00D4,
	0x00D6, 0x00D8, 0x00DA, 0x00DC, /* 48 */
	0x00DE,
};

const uint32_t bcw_ilt_retard[BCW_ILT_RETARD_SIZE] = {
	0xDB93CB87, 0xD666CF64, /* 0 */
	0xD1FDD358, 0xCDA6D826,
	0xCA38DD9F, 0xC729E2B4,
	0xC469E88E, 0xC26AEE2B,
	0xC0DEF46C, 0xC073FA62, /* 8 */
	0xC01D00D5, 0xC0760743,
	0xC1560D1E, 0xC2E51369,
	0xC4ED18FF, 0xC7AC1ED7,
	0xCB2823B2, 0xCEFA28D9, /* 16 */
	0xD2F62D3F, 0xD7BB3197,
	0xDCE53568, 0xE1FE3875,
	0xE7D13B35, 0xED663D35,
	0xF39B3EC4, 0xF98E3FA7, /* 24 */
	0x00004000, 0x06723FA7,
	0x0C653EC4, 0x129A3D35,
	0x182F3B35, 0x1E023875,
	0x231B3568, 0x28453197, /* 32 */
	0x2D0A2D3F, 0x310628D9,
	0x34D823B2, 0x38541ED7,
	0x3B1318FF, 0x3D1B1369,
	0x3EAA0D1E, 0x3F8A0743, /* 40 */
	0x3FE300D5, 0x3F8DFA62,
	0x3F22F46C, 0x3D96EE2B,
	0x3B97E88E, 0x38D7E2B4,
	0x35C8DD9F, 0x325AD826, /* 48 */
	0x2E03D358, 0x299ACF64,
	0x246DCB87,
};

const uint16_t bcw_ilt_finefreqa[BCW_ILT_FINEFREQA_SIZE] = {
	0x0082, 0x0082, 0x0102, 0x0182, /* 0 */
	0x0202, 0x0282, 0x0302, 0x0382,
	0x0402, 0x0482, 0x0502, 0x0582,
	0x05E2, 0x0662, 0x06E2, 0x0762,
	0x07E2, 0x0842, 0x08C2, 0x0942, /* 16 */
	0x09C2, 0x0A22, 0x0AA2, 0x0B02,
	0x0B82, 0x0BE2, 0x0C62, 0x0CC2,
	0x0D42, 0x0DA2, 0x0E02, 0x0E62,
	0x0EE2, 0x0F42, 0x0FA2, 0x1002, /* 32 */
	0x1062, 0x10C2, 0x1122, 0x1182,
	0x11E2, 0x1242, 0x12A2, 0x12E2,
	0x1342, 0x13A2, 0x1402, 0x1442,
	0x14A2, 0x14E2, 0x1542, 0x1582, /* 48 */
	0x15E2, 0x1622, 0x1662, 0x16C1,
	0x1701, 0x1741, 0x1781, 0x17E1,
	0x1821, 0x1861, 0x18A1, 0x18E1,
	0x1921, 0x1961, 0x19A1, 0x19E1, /* 64 */
	0x1A21, 0x1A61, 0x1AA1, 0x1AC1,
	0x1B01, 0x1B41, 0x1B81, 0x1BA1,
	0x1BE1, 0x1C21, 0x1C41, 0x1C81,
	0x1CA1, 0x1CE1, 0x1D01, 0x1D41, /* 80 */
	0x1D61, 0x1DA1, 0x1DC1, 0x1E01,
	0x1E21, 0x1E61, 0x1E81, 0x1EA1,
	0x1EE1, 0x1F01, 0x1F21, 0x1F41,
	0x1F81, 0x1FA1, 0x1FC1, 0x1FE1, /* 96 */
	0x2001, 0x2041, 0x2061, 0x2081,
	0x20A1, 0x20C1, 0x20E1, 0x2101,
	0x2121, 0x2141, 0x2161, 0x2181,
	0x21A1, 0x21C1, 0x21E1, 0x2201, /* 112 */
	0x2221, 0x2241, 0x2261, 0x2281,
	0x22A1, 0x22C1, 0x22C1, 0x22E1,
	0x2301, 0x2321, 0x2341, 0x2361,
	0x2361, 0x2381, 0x23A1, 0x23C1, /* 128 */
	0x23E1, 0x23E1, 0x2401, 0x2421,
	0x2441, 0x2441, 0x2461, 0x2481,
	0x2481, 0x24A1, 0x24C1, 0x24C1,
	0x24E1, 0x2501, 0x2501, 0x2521, /* 144 */
	0x2541, 0x2541, 0x2561, 0x2561,
	0x2581, 0x25A1, 0x25A1, 0x25C1,
	0x25C1, 0x25E1, 0x2601, 0x2601,
	0x2621, 0x2621, 0x2641, 0x2641, /* 160 */
	0x2661, 0x2661, 0x2681, 0x2681,
	0x26A1, 0x26A1, 0x26C1, 0x26C1,
	0x26E1, 0x26E1, 0x2701, 0x2701,
	0x2721, 0x2721, 0x2740, 0x2740, /* 176 */
	0x2760, 0x2760, 0x2780, 0x2780,
	0x2780, 0x27A0, 0x27A0, 0x27C0,
	0x27C0, 0x27E0, 0x27E0, 0x27E0,
	0x2800, 0x2800, 0x2820, 0x2820, /* 192 */
	0x2820, 0x2840, 0x2840, 0x2840,
	0x2860, 0x2860, 0x2880, 0x2880,
	0x2880, 0x28A0, 0x28A0, 0x28A0,
	0x28C0, 0x28C0, 0x28C0, 0x28E0, /* 208 */
	0x28E0, 0x28E0, 0x2900, 0x2900,
	0x2900, 0x2920, 0x2920, 0x2920,
	0x2940, 0x2940, 0x2940, 0x2960,
	0x2960, 0x2960, 0x2960, 0x2980, /* 224 */
	0x2980, 0x2980, 0x29A0, 0x29A0,
	0x29A0, 0x29A0, 0x29C0, 0x29C0,
	0x29C0, 0x29E0, 0x29E0, 0x29E0,
	0x29E0, 0x2A00, 0x2A00, 0x2A00, /* 240 */
	0x2A00, 0x2A20, 0x2A20, 0x2A20,
	0x2A20, 0x2A40, 0x2A40, 0x2A40,
	0x2A40, 0x2A60, 0x2A60, 0x2A60,
};

const uint16_t bcw_ilt_noisea2[BCW_ILT_NOISEA2_SIZE] = {
	0x0001, 0x0001, 0x0001, 0xFFFE,
	0xFFFE, 0x3FFF, 0x1000, 0x0393,
};

const uint16_t bcw_ilt_noisea3[BCW_ILT_NOISEA3_SIZE] = {
	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
};

const uint16_t bcw_ilt_finefreqg[BCW_ILT_FINEFREQG_SIZE] = {
        0x0089, 0x02E9, 0x0409, 0x04E9, /* 0 */
        0x05A9, 0x0669, 0x0709, 0x0789,
        0x0829, 0x08A9, 0x0929, 0x0989,
        0x0A09, 0x0A69, 0x0AC9, 0x0B29,
        0x0BA9, 0x0BE9, 0x0C49, 0x0CA9, /* 16 */
        0x0D09, 0x0D69, 0x0DA9, 0x0E09,
        0x0E69, 0x0EA9, 0x0F09, 0x0F49,
        0x0FA9, 0x0FE9, 0x1029, 0x1089,
        0x10C9, 0x1109, 0x1169, 0x11A9, /* 32 */
        0x11E9, 0x1229, 0x1289, 0x12C9,
        0x1309, 0x1349, 0x1389, 0x13C9,
        0x1409, 0x1449, 0x14A9, 0x14E9,
        0x1529, 0x1569, 0x15A9, 0x15E9, /* 48 */
        0x1629, 0x1669, 0x16A9, 0x16E8,
        0x1728, 0x1768, 0x17A8, 0x17E8,
        0x1828, 0x1868, 0x18A8, 0x18E8,
        0x1928, 0x1968, 0x19A8, 0x19E8, /* 64 */
        0x1A28, 0x1A68, 0x1AA8, 0x1AE8,
        0x1B28, 0x1B68, 0x1BA8, 0x1BE8,
        0x1C28, 0x1C68, 0x1CA8, 0x1CE8,
        0x1D28, 0x1D68, 0x1DC8, 0x1E08, /* 80 */
        0x1E48, 0x1E88, 0x1EC8, 0x1F08,
        0x1F48, 0x1F88, 0x1FE8, 0x2028,
        0x2068, 0x20A8, 0x2108, 0x2148,
        0x2188, 0x21C8, 0x2228, 0x2268, /* 96 */
        0x22C8, 0x2308, 0x2348, 0x23A8,
        0x23E8, 0x2448, 0x24A8, 0x24E8,
        0x2548, 0x25A8, 0x2608, 0x2668,
        0x26C8, 0x2728, 0x2787, 0x27E7, /* 112 */
        0x2847, 0x28C7, 0x2947, 0x29A7,
        0x2A27, 0x2AC7, 0x2B47, 0x2BE7,
        0x2CA7, 0x2D67, 0x2E47, 0x2F67,
        0x3247, 0x3526, 0x3646, 0x3726, /* 128 */
        0x3806, 0x38A6, 0x3946, 0x39E6,
        0x3A66, 0x3AE6, 0x3B66, 0x3BC6,
        0x3C45, 0x3CA5, 0x3D05, 0x3D85,
        0x3DE5, 0x3E45, 0x3EA5, 0x3EE5, /* 144 */
        0x3F45, 0x3FA5, 0x4005, 0x4045,
        0x40A5, 0x40E5, 0x4145, 0x4185,
        0x41E5, 0x4225, 0x4265, 0x42C5,
        0x4305, 0x4345, 0x43A5, 0x43E5, /* 160 */
        0x4424, 0x4464, 0x44C4, 0x4504,
        0x4544, 0x4584, 0x45C4, 0x4604,
        0x4644, 0x46A4, 0x46E4, 0x4724,
        0x4764, 0x47A4, 0x47E4, 0x4824, /* 176 */
        0x4864, 0x48A4, 0x48E4, 0x4924,
        0x4964, 0x49A4, 0x49E4, 0x4A24,
        0x4A64, 0x4AA4, 0x4AE4, 0x4B23,
        0x4B63, 0x4BA3, 0x4BE3, 0x4C23, /* 192 */
        0x4C63, 0x4CA3, 0x4CE3, 0x4D23,
        0x4D63, 0x4DA3, 0x4DE3, 0x4E23,
        0x4E63, 0x4EA3, 0x4EE3, 0x4F23,
        0x4F63, 0x4FC3, 0x5003, 0x5043, /* 208 */
        0x5083, 0x50C3, 0x5103, 0x5143,
        0x5183, 0x51E2, 0x5222, 0x5262,
        0x52A2, 0x52E2, 0x5342, 0x5382,
        0x53C2, 0x5402, 0x5462, 0x54A2, /* 224 */
        0x5502, 0x5542, 0x55A2, 0x55E2,
        0x5642, 0x5682, 0x56E2, 0x5722,
        0x5782, 0x57E1, 0x5841, 0x58A1,
        0x5901, 0x5961, 0x59C1, 0x5A21, /* 240 */
        0x5AA1, 0x5B01, 0x5B81, 0x5BE1,
        0x5C61, 0x5D01, 0x5D80, 0x5E20,
        0x5EE0, 0x5FA0, 0x6080, 0x61C0,
};

const uint16_t bcw_ilt_noiseg1[BCW_ILT_NOISEG1_SIZE] = {
        0x013C, 0x01F5, 0x031A, 0x0631,
        0x0001, 0x0001, 0x0001, 0x0001,
};

const uint16_t bcw_ilt_noiseg2[BCW_ILT_NOISEG2_SIZE] = {
        0x5484, 0x3C40, 0x0000, 0x0000,
        0x0000, 0x0000, 0x0000, 0x0000,
};

const uint16_t bcw_ilt_noisescaleg1[BCW_ILT_NOISESCALEG_SIZE] = {
        0x6C77, 0x5162, 0x3B40, 0x3335, /* 0 */
        0x2F2D, 0x2A2A, 0x2527, 0x1F21,
        0x1A1D, 0x1719, 0x1616, 0x1414,
        0x1414, 0x1400, 0x1414, 0x1614,
        0x1716, 0x1A19, 0x1F1D, 0x2521, /* 16 */
        0x2A27, 0x2F2A, 0x332D, 0x3B35,
        0x5140, 0x6C62, 0x0077,
};

const uint16_t bcw_ilt_noisescaleg3[BCW_ILT_NOISESCALEG_SIZE] = {
        0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4, /* 0 */
        0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4,
        0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4,
        0xA4A4, 0xA400, 0xA4A4, 0xA4A4,
        0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4, /* 16 */
        0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4,
        0xA4A4, 0xA4A4, 0x00A4,
};

const uint16_t bcw_ilt_noisescaleg2[BCW_ILT_NOISESCALEG_SIZE] = {
        0xD8DD, 0xCBD4, 0xBCC0, 0XB6B7, /* 0 */
        0xB2B0, 0xADAD, 0xA7A9, 0x9FA1,
        0x969B, 0x9195, 0x8F8F, 0x8A8A,
        0x8A8A, 0x8A00, 0x8A8A, 0x8F8A,
        0x918F, 0x9695, 0x9F9B, 0xA7A1, /* 16 */
        0xADA9, 0xB2AD, 0xB6B0, 0xBCB7,
        0xCBC0, 0xD8D4, 0x00DD,
};

/*
 * Helper routines
 */
void
bcw_shm_ctl_word(struct bcw_softc *sc, uint16_t routing, uint16_t offset)
{
	uint32_t control;

	control = routing;
	control <<= 16;
	control |= offset;

	BCW_WRITE(sc, BCW_MMIO_SHM_CONTROL, control);
}

uint16_t
bcw_shm_read16(struct bcw_softc *sc, uint16_t routing, uint16_t offset)
{
	if (routing == BCW_SHM_SHARED) {
		if (offset & 0x0003) {
			bcw_shm_ctl_word(sc, routing, offset >> 2);

			return (BCW_READ16(sc, BCW_MMIO_SHM_DATA_UNALIGNED));
		}
		offset >>= 2;
	}
	bcw_shm_ctl_word(sc, routing, offset);

	return (BCW_READ16(sc, BCW_MMIO_SHM_DATA));
}

void
bcw_shm_write16(struct bcw_softc *sc, uint16_t routing, uint16_t offset,
    uint16_t val)
{
	if (routing == BCW_SHM_SHARED) {
		if (offset & 0x0003) {
			bcw_shm_ctl_word(sc, routing, offset >> 2);
			BCW_WRITE16(sc, BCW_MMIO_SHM_DATA_UNALIGNED, val);
			return;
		}
		offset >>= 2;
	}
	bcw_shm_ctl_word(sc, routing, offset);
	BCW_WRITE16(sc, BCW_MMIO_SHM_DATA, val);
}

uint32_t
bcw_shm_read32(struct bcw_softc *sc, uint16_t routing, uint16_t offset)
{
	uint32_t r;

	if (routing == BCW_SHM_SHARED) {
		if (offset & 0x003) {
			bcw_shm_ctl_word(sc, routing, offset >> 2);
			r = BCW_READ16(sc, BCW_MMIO_SHM_DATA_UNALIGNED);
			r <<= 16;
			bcw_shm_ctl_word(sc, routing, (offset >> 2) + 1);
			r |= BCW_READ16(sc, BCW_MMIO_SHM_DATA);
			return (r);
		}
		offset >>= 2;
	}
	bcw_shm_ctl_word(sc, routing, offset);
	r = BCW_READ(sc, BCW_MMIO_SHM_DATA);

	return (r);
}

void
bcw_shm_write32(struct bcw_softc *sc, uint16_t routing, uint16_t offset,
    uint32_t val)
{
	if (routing == BCW_SHM_SHARED) {
		if (offset & 0x0003) {
			bcw_shm_ctl_word(sc, routing, offset >> 2);
			BCW_WRITE16(sc, BCW_MMIO_SHM_DATA_UNALIGNED,
			    (val >> 16) & 0xffff);
			bcw_shm_ctl_word(sc, routing, (offset >> 2) + 1);
			BCW_WRITE16(sc, BCW_MMIO_SHM_DATA, val & 0xffff);
			return;
		}
		offset >>= 2;
	}
	bcw_shm_ctl_word(sc, routing, offset);
	BCW_WRITE(sc, BCW_MMIO_SHM_DATA, val);
}

void
bcw_radio_write16(struct bcw_softc *sc, uint16_t offset, uint16_t val)
{
	BCW_WRITE16(sc, BCW_MMIO_RADIO_CONTROL, offset);
	BCW_WRITE16(sc, BCW_MMIO_RADIO_DATA_LOW, val);
}

int
bcw_radio_read16(struct bcw_softc *sc, uint16_t offset)
{
	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		offset |= 0x0040;
		break;
	case BCW_PHY_TYPEB:
		if (sc->sc_radio_ver == 0x2053) {
			if (offset < 0x70)
				offset += 0x80;
			else if (offset < 0x80)
				offset += 0x70;
		} else if (sc->sc_radio_ver == 0x2050)
			offset |= 0x80;
		else
			return (0);
		break;
	case BCW_PHY_TYPEG:
		offset |= 0x80;
		break;
	}

	BCW_WRITE16(sc, BCW_MMIO_RADIO_CONTROL, offset);

	return (BCW_READ16(sc, BCW_MMIO_RADIO_DATA_LOW));
}

void
bcw_phy_write16(struct bcw_softc *sc, uint16_t offset, uint16_t val)
{
	BCW_WRITE16(sc, BCW_MMIO_PHY_CONTROL, offset);
	BCW_WRITE16(sc, BCW_MMIO_PHY_DATA, val);
}

int
bcw_phy_read16(struct bcw_softc *sc, uint16_t offset)
{
	BCW_WRITE16(sc, BCW_MMIO_PHY_CONTROL, offset);

	return (BCW_READ16(sc, BCW_MMIO_PHY_DATA));
}

void
bcw_ram_write(struct bcw_softc *sc, uint16_t offset, uint32_t val)
{
	uint32_t status;

	status = BCW_READ(sc, BCW_MMIO_SBF);
	if (!(status & BCW_SBF_REGISTER_BYTESWAP))
		val = swap32(val);

	BCW_WRITE(sc, BCW_MMIO_RAM_CONTROL, offset);
	BCW_WRITE(sc, BCW_MMIO_RAM_DATA, val);
}

int
bcw_lv(int number, int min, int max)
{
	if (number < min)
		return (min);
	else if (number > max)
		return (max);
	else
		return (number);
}

uint16_t
bcw_flip_4bit(uint16_t val)
{
	uint16_t flip = 0;

	flip |= (val & 0x0001) << 3;
	flip |= (val & 0x0002) << 1;
	flip |= (val & 0x0004) >> 1;
	flip |= (val & 0x0008) >> 3;

	return (flip);
}

/*
 * Dummy Transmission
 *
 * http://bcm-specs.sipsolutions.net/DummyTransmission
 */
void
bcw_dummy_transmission(struct bcw_softc *sc)
{
	unsigned int i, max_loop;
	uint16_t val = 0;
	uint32_t buffer[5] = {
	    0x00000000,
	    0x00000400,
	    0x00000000,
	    0x00000001,
	    0x00000000
	    };

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		max_loop = 0x1e;
		buffer[0] = 0xcc010200;
		break;
	case BCW_PHY_TYPEB:
	case BCW_PHY_TYPEG:
		max_loop = 0xfa;
		buffer[0] = 0x6e840b00;
		break;
	default:
		/* XXX panic()? */
		return;
	}

	for (i = 0; i < 5; i++)
		bcw_ram_write(sc, i * 4, buffer[i]);

	BCW_READ(sc, BCW_MMIO_SBF);

	BCW_WRITE16(sc, 0x0568, 0);
	BCW_WRITE16(sc, 0x07c0, 0);
	BCW_WRITE16(sc, 0x050c, sc->sc_phy_type == BCW_PHY_TYPEA ? 1 : 0);

	BCW_WRITE16(sc, 0x0508, 0);
	BCW_WRITE16(sc, 0x050a, 0);
	BCW_WRITE16(sc, 0x054c, 0);
	BCW_WRITE16(sc, 0x056a, 0x0014);
	BCW_WRITE16(sc, 0x0568, 0x0826);
	BCW_WRITE16(sc, 0x0500, 0);
	BCW_WRITE16(sc, 0x0502, 0x0030);

	if (sc->sc_radio_ver == 0x2050 && sc->sc_radio_rev <= 0x5)
		bcw_radio_write16(sc, 0x0051, 0x0017);
	for (i = 0; i < max_loop; i++) {
		val = BCW_READ16(sc, 0x050e);
		if (val & 0x0080)
			break;
		delay(10);
	}
	for (i = 0; i < 0x0a; i++) {
		val = BCW_READ16(sc, 0x050e);
		if (val & 0x0400)
			break;
		delay(10);
	}
	for (i = 0; i < 0x0a; i++) {
		val = BCW_READ16(sc, 0x0690);
		if (!(val & 0x0100))
			break;
		delay(10);
	}
	if (sc->sc_radio_ver == 0x2050 && sc->sc_radio_rev <= 0x5)
		bcw_radio_write16(sc, 0x0051, 0x0037);
}

struct bcw_lopair *
bcw_get_lopair(struct bcw_softc *sc, uint16_t radio_atten,
    uint16_t baseband_atten)
{
	return (sc->sc_phy_lopairs + (radio_atten + 14 *
	    (baseband_atten / 2)));
}

void
bcw_stack_save(uint32_t *_stackptr, size_t *stackidx, uint8_t id,
    uint16_t offset, uint16_t val)
{
	uint32_t *stackptr = &(_stackptr[*stackidx]);

	*stackptr = offset;
	*stackptr |= ((uint32_t)id) << 12;
	*stackptr |= ((uint32_t)val) << 16;
	(*stackidx)++;
}

uint16_t
bcw_stack_restore(uint32_t *stackptr, uint8_t id, uint16_t offset)
{
	size_t i;

	for (i = 0; i < BCW_INTERFSTACK_SIZE; i++, stackptr++) {
		if ((*stackptr & 0x00000fff) != offset)
			continue;
		if (((*stackptr & 0x0000f000) >> 12) != id)
			continue;
		return (((*stackptr & 0xffff0000) >> 16));
	}

	return (0);
}

int
bcw_using_pio(struct bcw_softc *sc)
{
	return (sc->sc_using_pio);
}

void
bcw_rate_memory_write(struct bcw_softc *sc, uint16_t rate, int is_ofdm)
{
	uint16_t offset;

	if (is_ofdm) {
		offset = 0x480;
		offset += (bcw_xmit_plcp_get_ratecode_ofdm(rate) & 0x000f) * 2;
	} else {
		offset = 0x4c0;
		offset += (bcw_xmit_plcp_get_ratecode_cck(rate) & 0x000f) * 2;
	}
	bcw_shm_write16(sc, BCW_SHM_SHARED, offset + 0x20,
	    bcw_shm_read16(sc, BCW_SHM_SHARED, offset));
}

void
bcw_rate_memory_init(struct bcw_softc *sc)
{
	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
	case BCW_PHY_TYPEG:
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11g.rs_rates[0], 1);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11g.rs_rates[1], 1);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11g.rs_rates[2], 1);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11g.rs_rates[3], 1);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11g.rs_rates[4], 1);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11g.rs_rates[5], 1);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11g.rs_rates[6], 1);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11g.rs_rates[7], 1);
	case BCW_PHY_TYPEB:
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11b.rs_rates[0], 0);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11b.rs_rates[1], 0);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11b.rs_rates[2], 0);
		bcw_rate_memory_write(sc,
		    ieee80211_std_rateset_11b.rs_rates[3], 0);
	default:
		/* XXX panic()? */
		break;
	}
}

/*
 * Attach device
 *
 * http://bcm-specs.sipsolutions.net/DeviceAttach
 */
void
bcw_attach(struct bcw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int i;
	uint32_t sbval;
	uint32_t core_id, core_rev, core_vendor;

	/* power on cardbus socket */
	if (sc->sc_enable)
		sc->sc_enable(sc);

	DPRINTF(("\n%s: BoardVendor=0x%x, BoardType=0x%x, BoardRev=0x%x\n",
	    sc->sc_dev.dv_xname,
	    sc->sc_board_vendor, sc->sc_board_type, sc->sc_board_rev));

	/*
	 * Attach chipset to backplane
	 */
	bcw_pc_crystal_on(sc);
	(sc->sc_conf_write)(sc, PCI_COMMAND_STATUS_REG,
	    (sc->sc_conf_read)(sc, PCI_COMMAND_STATUS_REG) &
	    ~PCI_STATUS_TARGET_TARGET_ABORT);

	/*
	 * Try and change to the ChipCommon Core
	 */
	if (bcw_change_core(sc, 0) == 0) {
		DPRINTF(("%s: Selected ChipCommon Core\n",
		    sc->sc_dev.dv_xname));
		sc->sc_chip_common_capa =
		    BCW_READ(sc, BCW_CHIPCOMMON_CAPABILITIES); /* XXX */
	}

	/*
	 * Core ID REG, this is either the default wireless core (0x812) or
	 * a ChipCommon core that was successfully selected above
	 */
	sbval = BCW_READ(sc, BCW_CIR_SBID_HI);
	core_id = (sbval & 0x8ff0) >> 4;
	core_rev = (sbval & 0x7000) >> 8;
	core_rev |= (sbval & 0xf);
	core_vendor = (sbval & 0xffff0000) >> 16;
	DPRINTF(("%s: CoreID=0x%x, CoreRev=0x%x, CoreVendor=0x%x\n",
	    sc->sc_dev.dv_xname, core_id, core_rev, core_vendor));

	/*
	 * If we successfully got a commoncore, and the corerev=4 or >=6
	 * get the number of cores from the chipid reg
	 */
	if (core_id == BCW_CORE_COMMON) {
		sc->sc_havecommon = 1;

		/* powercontrol init is done if a common core exists */
		bcw_pc_init(sc);

		sbval = BCW_READ(sc, BCW_CORE_COMMON_CHIPID);
		sc->sc_chip_id = (sbval & 0x0000ffff);
		sc->sc_chip_rev = (sbval & 0x000f0000) >> 16;
		sc->sc_chip_pkg = (sbval & 0x00f00000) >> 20;

		if (core_rev >= 4)
			sc->sc_numcores = (sbval & 0x0f000000) >> 24;
		else {
			switch (sc->sc_chip_id) {
			case 0x4710:
			case 0x4610:
			case 0x4704:
				sc->sc_numcores = 9;
				break;
			case 0x4310:
				sc->sc_numcores = 8;
				break;
			case 0x5365:
				sc->sc_numcores = 7;
				break;
			case 0x4306:
				sc->sc_numcores = 6;
				break;
			case 0x4307:
			case 0x4301:
				sc->sc_numcores = 5;
				break;
			case 0x4402:
				sc->sc_numcores = 3;
				break;
			default:
				/* set to max */
				sc->sc_numcores = BCW_MAX_CORES;
			}
		}
	} else { /* No CommonCore, set chipid, cores, rev based on product id */
		sc->sc_core_common = NULL;
		sc->sc_havecommon = 0;
		switch (sc->sc_prodid) {
		case 0x4710:
		case 0x4711:
		case 0x4712:
		case 0x4713:
		case 0x4714:
		case 0x4715:
			sc->sc_chip_id = 0x4710;
			sc->sc_numcores = 9;
			break;
		case 0x4610:
		case 0x4611:
		case 0x4612:
		case 0x4613:
		case 0x4614:
		case 0x4615:
			sc->sc_chip_id = 0x4610;
			sc->sc_numcores = 9;
			break;
		case 0x4402:
		case 0x4403:
			sc->sc_chip_id = 0x4402;
			sc->sc_numcores = 3;
			break;
		case 0x4305:
		case 0x4306:
		case 0x4307:
			sc->sc_chip_id = 0x4307;
			sc->sc_numcores = 5;
			break;
		case 0x4301:
			sc->sc_chip_id = 0x4301;
			sc->sc_numcores = 5;
			break;
		default:
			sc->sc_chip_id = sc->sc_prodid;
			/* Set to max */
			sc->sc_numcores = BCW_MAX_CORES;
		}
	}

	DPRINTF(("%s: ChipID=0x%x, ChipRev=0x%x, ChipPkg=0x%x, NumCores=%d\n",
	    sc->sc_dev.dv_xname,
	    sc->sc_chip_id, sc->sc_chip_rev, sc->sc_chip_pkg,
	    sc->sc_numcores));

	bcw_pc_set_clock(sc, BCW_PCTL_CLK_FAST);

	bcw_phy_connect(sc, 0);

	/*
	 * Get SPROM values and save them where they belong
	 */
	bcw_sprom_get(sc);

       /* Identify each core and reset the 802.11 cores */
       for (i = 0; i < sc->sc_numcores; i++) {
		if (bcw_change_core(sc, i)) {
			printf("%s: Failed change to core %d\n",
			    sc->sc_dev.dv_xname, i);
			continue;
		}

		sbval = BCW_READ(sc, BCW_CIR_SBID_HI);
		sc->sc_core[i].id = (sbval & 0x00008ff0) >> 4;
		sc->sc_core[i].rev = ((sbval & 0x00007000) >> 8 |
		    (sbval & 0x0000000f));

		switch (sc->sc_core[i].id) {
		case BCW_CORE_COMMON:
			sc->sc_core_common = &sc->sc_core[i];
			break;
#if 0
		case BCW_CORE_PCI:
			(sc->sc_ca == NULL)
			sc->sc_core_bus = &sc->sc_core[i];
			break;
		case BCW_CORE_PCMCIA:
			if (sc->sc_pa == NULL)
				sc->sc_core_bus = &sc->sc_core[i];
			break;
#endif
		case BCW_CORE_80211:
			sc->sc_core_80211 = &sc->sc_core[i];
			bcw_80211_core_reset(sc, 1);
			if (bcw_phy_get(sc))
				return;
			if (bcw_radio_get(sc))
				return;
			if (bcw_validate_chip_access(sc))
				return;
			bcw_radio_off(sc);
			bcw_microcode_init_fbf(sc);
			break;
		case BCW_CORE_NONEXIST:
			sc->sc_numcores = i + 1;
			break;
		default:
			/* ignore all other core types */
			break;
		}

		sc->sc_core[i].index = i;

		DPRINTF(("%s: core %d is type 0x%x rev %d\n",
		    sc->sc_dev.dv_xname, sc->sc_core[i].index,
		    sc->sc_core[i].id, sc->sc_core[i].rev));
	}

	/* turn crystal off */
	bcw_pc_crystal_off(sc);

	/*
	 * Switch to the 80211 core
	 */
	bcw_change_core(sc, sc->sc_core_80211->index);

        /*
	 * Set MAC address
	 */
        if (!IEEE80211_IS_MULTICAST(sc->sc_sprom.et1macaddr))
		memcpy(ic->ic_myaddr, sc->sc_sprom.et1macaddr, ETHER_ADDR_LEN);
        else
		memcpy(ic->ic_myaddr, sc->sc_sprom.il0macaddr, ETHER_ADDR_LEN);
        printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	/*
	 * Initialize the TSSI to DBM table
	 * The method is described at
	 * http://bcm-specs.sipsolutions.net/TSSI_to_DBM_Table
	 * but I suspect there's a standard way to do it in the 80211 stuff
	 */

	/*
	 * Allocate DMA-safe memory for ring descriptors.
	 * The receive and transmit rings are 4k aligned.
	 */
	bcw_alloc_rx_ring(sc, &sc->sc_rxring, BCW_RX_RING_COUNT);
	bcw_alloc_tx_ring(sc, &sc->sc_txring, BCW_TX_RING_COUNT);

	ic->ic_phytype = IEEE80211_T_OFDM;
	ic->ic_opmode = IEEE80211_M_STA; /* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* Set device capabilities - keep it simple */
	ic->ic_caps = IEEE80211_C_IBSS; /* IBSS mode supported */

	/* Set supported rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* Set supported channels */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	/* IBSS channel undefined for now */
	ic->ic_ibss_chan = &ic->ic_channels[0];

	ifp->if_softc = sc;
	ifp->if_init = bcw_init;
	ifp->if_ioctl = bcw_ioctl;
	ifp->if_start = bcw_start;
	ifp->if_watchdog = bcw_watchdog;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	IFQ_SET_READY(&ifp->if_snd);

	/* Attach the interface */
	if_attach(ifp);
	ieee80211_ifattach(ifp);

	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = bcw_newstate;

	ieee80211_media_init(ifp, bcw_media_change, bcw_media_status);

	timeout_set(&sc->sc_timeout, bcw_tick, sc);
}

/* handle media, and ethernet requests */
int
bcw_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct bcw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq   *ifr = (struct ifreq *) data;
	struct ifaddr *ifa = (struct ifaddr *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			//bcw_init(ifp);
			//arp_ifinit(&sc->bcw_ac, ifa); /* XXX */
			break;
#endif /* INET */
		default:
			//bcw_init(ifp);
			break;
		}
		break;
	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) &&
		    (!(ifp->if_flags & IFF_RUNNING)))
				bcw_init(ifp);
		else if (ifp->if_flags & IFF_RUNNING)
			bcw_stop(ifp, 1);
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCG80211TXPOWER:
		/*
		 * If the hardware radio transmitter switch is off, report a
		 * tx power of IEEE80211_TXPOWER_MIN to indicate that radio
		 * transmitter is killed.
		 */
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
		break;
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			bcw_init(ifp);
		error = 0;
	}

	splx(s);
	return error;
}

/*
 * Start packet transmission on the interface
 */
void
bcw_start(struct ifnet *ifp)
{
#if 0
	struct malo_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;
#endif

	/* if device is not up return directly */
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;
}

/* Watchdog timer handler. */
void
bcw_watchdog(struct ifnet *ifp)
{
	struct bcw_softc *sc = ifp->if_softc;

	printf("%s: device timeout\n", sc->sc_dev.dv_xname);
	ifp->if_oerrors++;

	(void) bcw_init(ifp);

	/* Try to get more packets going. */
	bcw_start(ifp);
}

void
bcw_set_opmode(struct ifnet *ifp)
{
	struct bcw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t status;
	uint16_t val;

	/* TODO */

	status = BCW_READ(sc, BCW_MMIO_SBF);
	/* reset status to infrastructure mode */
	status &= ~(BCW_SBF_AP | BCW_SBF_MONITOR);
	status &= ~BCW_SBF_PROMISC;
	status |= BCW_SBF_ADHOC;
	status |= BCW_SBF_PROMISC; /* XXX */

	switch (ic->ic_opmode) {
	case IEEE80211_M_MONITOR:
		status |= BCW_SBF_MONITOR;
		status |= BCW_SBF_PROMISC;
		break;
	case IEEE80211_M_IBSS:
		status &= ~BCW_SBF_ADHOC;
		break;
	case IEEE80211_M_HOSTAP:
		status |= BCW_SBF_AP;
		break;
	case IEEE80211_M_STA:
		/* nothing todo here */
		break;
	default:
		printf("%s: unknown mode in bcw_set_opmode()\n",
		    sc->sc_dev.dv_xname);
		break;
	}
	if (ifp->if_flags & IFF_PROMISC)
		status |= BCW_SBF_PROMISC;

	val = 0x0002;
	if (ic->ic_opmode != IEEE80211_M_IBSS &&
	    ic->ic_opmode != IEEE80211_M_HOSTAP) {
		if (sc->sc_chip_id == 0x4306 && sc->sc_chip_rev == 3)
			val = 0x0064;
		else
			val = 0x0032;
	}
	BCW_WRITE16(sc, 0x0612, val);
}

void
bcw_macfilter_set(struct bcw_softc *sc, uint16_t offset, const uint8_t *mac)
{
	uint16_t data;

	offset |= 0x0020;
	BCW_WRITE16(sc, BCW_MMIO_MACFILTER_CONTROL, offset);

	data = mac[0];
	data |= mac[1] << 8;
	BCW_WRITE16(sc, BCW_MMIO_MACFILTER_DATA, data);
	data = mac[2];
	data |= mac[3] << 8;
	BCW_WRITE16(sc, BCW_MMIO_MACFILTER_DATA, data);
	data = mac[4];
	data |= mac[5] << 8;
	BCW_WRITE16(sc, BCW_MMIO_MACFILTER_DATA, data);
}

void
bcw_macfilter_clear(struct bcw_softc *sc, uint16_t offset)
{
	const uint8_t zero_addr[ETHER_ADDR_LEN] = { 0 };

	bcw_macfilter_set(sc, offset, zero_addr);
}

/*
 * Write MAC and BSSID into template RAM
 *
 * http://bcm-specs.sipsolutions.net/TemplateRam
 */
void
bcw_templateram_set(struct bcw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t mac_bssid[ETHER_ADDR_LEN * 2];
	int i;

	bcopy(ic->ic_myaddr, mac_bssid, ETHER_ADDR_LEN);
	bcopy(ic->ic_bss->ni_bssid, mac_bssid + ETHER_ADDR_LEN, ETHER_ADDR_LEN);

	/*
	 * We write our MAC and BSSID at three different addresses in the
	 * template RAM, in 4 byte blocks.
	 */
	for (i = 0; i < sizeof(mac_bssid); i += sizeof(uint32_t))
		bcw_ram_write(sc, 0x20 + i, *((int32_t *)(mac_bssid + i)));
	for (i = 0; i < sizeof(mac_bssid); i += sizeof(uint32_t))
		bcw_ram_write(sc, 0x78 + i, *((int32_t *)(mac_bssid + i)));
	for (i = 0; i < sizeof(mac_bssid); i += sizeof(uint32_t))
		bcw_ram_write(sc, 0x478 + i, *((int32_t *)(mac_bssid + i)));
}

/*
 * Enable MAC on a PHY
 *
 * http://bcm-specs.sipsolutions.net/EnableMAC
 */
void
bcw_mac_enable(struct bcw_softc *sc)
{
	BCW_WRITE(sc, BCW_MMIO_SBF,
	    BCW_READ(sc, BCW_MMIO_SBF) | BCW_SBF_MAC_ENABLED);
	BCW_WRITE(sc, BCW_MMIO_GIR, BCW_INTR_READY);
	BCW_READ(sc, BCW_MMIO_SBF); /* dummy read */
	BCW_READ(sc, BCW_MMIO_GIR); /* dummy read */
	bcw_pc_saving_ctl_bits(sc, -1, -1);
}

/*
 * Disable MAC on a PHY
 *
 * http://bcm-specs.sipsolutions.net/SuspendMAC
 */
void
bcw_mac_disable(struct bcw_softc *sc)
{
	int i;
	uint32_t tmp;

	bcw_pc_saving_ctl_bits(sc, -1, -1);
	BCW_WRITE(sc, BCW_MMIO_SBF,
	    BCW_READ(sc, BCW_MMIO_SBF) & ~BCW_SBF_MAC_ENABLED);
	BCW_READ(sc, BCW_MMIO_GIR); /* dummy read */
	for (i = 10000; i; i--) {
		tmp = BCW_READ(sc, BCW_MMIO_GIR);
		if (tmp & BCW_INTR_READY)
			return;
		delay(1);
	}
	DPRINTF(("%s: MAC disable failed!\n", sc->sc_dev.dv_xname));
}

uint32_t
bcw_intr_enable(struct bcw_softc *sc, uint32_t mask)
{
	uint32_t old_mask;

	old_mask = BCW_READ(sc, BCW_MMIO_GIM);
	BCW_WRITE(sc, BCW_MMIO_GIM, old_mask | mask);

	DPRINTF(("%s: interrupts enabled\n", sc->sc_dev.dv_xname));

	return (old_mask);
}

uint32_t
bcw_intr_disable(struct bcw_softc *sc, uint32_t mask)
{
	uint32_t old_mask;

	old_mask = BCW_READ(sc, BCW_MMIO_GIM);
	BCW_WRITE(sc, BCW_MMIO_GIM, old_mask & ~mask);

	DPRINTF(("%s: interrupts disabled\n", sc->sc_dev.dv_xname));

	return (old_mask);
}

int
bcw_intr(void *arg)
{
	struct bcw_softc *sc = arg;
	uint32_t reason;
	uint32_t dma_reason[6];

	if (!(sc->sc_flags & BCW_FLAGS_INITIALIZED))
		return (0);

	reason = BCW_READ(sc, BCW_MMIO_GIR);
	if (reason == 0xffffffff)
		return (0);

	reason &= BCW_READ(sc, BCW_MMIO_GIM);
	if (!reason)
		return (0);

	dma_reason[0] = BCW_READ(sc, BCW_MMIO_DMA0_REASON) & 0x0001dc00;
	dma_reason[1] = BCW_READ(sc, BCW_MMIO_DMA1_REASON) & 0x0000dc00;
	dma_reason[2] = BCW_READ(sc, BCW_MMIO_DMA2_REASON) & 0x0000dc00;
	dma_reason[3] = BCW_READ(sc, BCW_MMIO_DMA3_REASON) & 0x0001dc00;
	dma_reason[4] = BCW_READ(sc, BCW_MMIO_DMA4_REASON) & 0x0000dc00;
	dma_reason[5] = BCW_READ(sc, BCW_MMIO_DMA5_REASON) & 0x0000dc00;

	/* ACK interrupt */
	BCW_WRITE(sc, BCW_MMIO_GIR, reason);
	BCW_WRITE(sc, BCW_MMIO_GIM, dma_reason[0]);
	BCW_WRITE(sc, BCW_MMIO_GIM, dma_reason[1]);
	BCW_WRITE(sc, BCW_MMIO_GIM, dma_reason[2]);
	BCW_WRITE(sc, BCW_MMIO_GIM, dma_reason[3]);
	BCW_WRITE(sc, BCW_MMIO_GIM, dma_reason[4]);
	BCW_WRITE(sc, BCW_MMIO_GIM, dma_reason[5]);

	bcw_intr_disable(sc, BCW_INTR_ALL);

	if (reason & BCW_INTR_PS) {
		printf("handle PS intr\n");
		bcw_pc_saving_ctl_bits(sc, -1, -1);
	} else
		printf("INTR ALERT!!!\n");

	bcw_intr_enable(sc, BCW_INTR_INITIAL);

	return (1);
}

/*
 * Receive interrupt handler
 */
void
bcw_rxintr(struct bcw_softc *sc)
{
#if 0
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
#endif
}

/*
 * Transmit interrupt handler
 */
void
bcw_txintr(struct bcw_softc *sc)
{
#if 0
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
#endif

}

/*
 * Initialize the interface
 *
 * http://bcm-specs.sipsolutions.net/DeviceUp
 */
int
bcw_init(struct ifnet *ifp)
{
        struct bcw_softc *sc = ifp->if_softc;
	//struct ieee80211com *ic = &sc->sc_ic;
        int i, error;
	uint32_t coremask = 0;

	/* initialize PHY values */
	sc->sc_phy_antenna_diversity = 0xffff;
	memset(sc->sc_phy_minlowsig, 0xff, sizeof(sc->sc_phy_minlowsig));
	memset(sc->sc_phy_minlowsigpos, 0, sizeof(sc->sc_phy_minlowsigpos));
	sc->sc_phy_calibrated = 0;
	sc->sc_phy_is_locked = 0;
	sc->sc_phy_lopairs = malloc(sizeof(struct bcw_lopair) * BCW_LO_COUNT,
	    M_DEVBUF, M_NOWAIT);
	if (sc->sc_phy_lopairs)
		memset(sc->sc_phy_lopairs, 0, sizeof(struct bcw_lopair) *
		    BCW_LO_COUNT);
	memset(sc->sc_phy_loopback_gain, 0, sizeof(sc->sc_phy_loopback_gain));

	/* initialize Radio values */
	sc->sc_radio_baseband_atten =
	    bcw_radio_default_baseband_atten(sc);
	sc->sc_radio_radio_atten =
	    bcw_radio_default_radio_atten(sc);
	sc->sc_radio_txctl1 = bcw_radio_default_txctl1(sc);
	sc->sc_radio_txctl2 = 0xffff;
	sc->sc_radio_txpwr_offset = 0;
	sc->sc_radio_nrssislope = 0;
	for (i = 0; i < BCW_ARRAY_SIZE(sc->sc_radio_nrssi); i++)
		sc->sc_radio_nrssi[i] = -1000;
	for (i = 0; i < BCW_ARRAY_SIZE(sc->sc_radio_nrssi_lt); i++)
		sc->sc_radio_nrssi_lt[i] = i;
	sc->sc_radio_lofcal = 0xffff;
	sc->sc_radio_initval = 0xffff;
	sc->sc_radio_aci_enable = 0;
	sc->sc_radio_aci_wlan_automatic = 0;
	sc->sc_radio_aci_hw_rssi = 0;

	bcw_change_core(sc, sc->sc_core_80211->index);

	bcw_pc_crystal_on(sc);

	bcw_pc_init(sc);

	bcw_pc_set_clock(sc, BCW_PCTL_CLK_FAST);

	coremask |= (1 << 1);
	bcw_iocore_enable(sc, coremask);

	bcw_80211_core_reset(sc, 1);

	/* initialize 80211 core */
	if ((error = bcw_80211_core_init(sc, 1)))
		return (error);

	bcw_pc_set_clock(sc, BCW_PCTL_CLK_DYNAMIC);

	bcw_mac_enable(sc);
	bcw_intr_enable(sc, BCW_INTR_INITIAL);
	bcw_pc_set_clock(sc, BCW_PCTL_CLK_DYNAMIC);

	/* start timer */
	timeout_add(&sc->sc_timeout, hz);

	/* mark as running, and no outputs active */
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	sc->sc_flags |= BCW_FLAGS_INITIALIZED;

	return (0);
}

/*
 * Add a receive buffer to the indicated descriptor
 */
int
bcw_add_rxbuf(struct bcw_softc *sc, int idx)
{
	return (0);
}

/*
 * Drain the receive queue
 */
void
bcw_rxdrain(struct bcw_softc *sc)
{

}

/*
 * Stop transmission on the interface
 *
 * http://bcm-specs.sipsolutions.net/DeviceDown
 */
void
bcw_stop(struct ifnet *ifp, int disable)
{
	struct bcw_softc *sc = ifp->if_softc;

	/* disable all interrupts */
	bcw_intr_disable(sc, BCW_INTR_ALL);

	/* disable the 80211 core */
	bcw_80211_core_disable(sc);

	/* turn off crystal */
	bcw_pc_crystal_off(sc);

	/* Stop the 1 second timer */
	timeout_del(&sc->sc_timeout);

	/* Mark the interface down and cancel the watchdog timer. */
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
	ifp->if_timer = 0;

	/* Disable interrupts. */
	BCW_WRITE(sc, BCW_MMIO_DMA0_INT_MASK, 0);
	sc->sc_intmask = 0;
	delay(10);

	/* Stop the DMA */
	BCW_WRITE(sc, BCW_DMA_RXCONTROL(0), 0);
	BCW_WRITE(sc, BCW_DMA_TXCONTROL(0), 0);
	delay(10);

	/* drain receive queue */
	if (disable)
		bcw_rxdrain(sc);
}

int
bcw_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	return (0);
}

int
bcw_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		bcw_init(ifp);

	return (0);
}

	void
bcw_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct bcw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int rate;

	imr->ifm_status = IFM_AVALID;
	imr->ifm_active = IFM_IEEE80211;
	if (ic->ic_state == IEEE80211_S_RUN)
		imr->ifm_status |= IFM_ACTIVE;

	/*
	 * XXX Read current transmission rate from the adapter.
	 */
	//val = CSR_READ_4(sc, IWI_CSR_CURRENT_TX_RATE);
	/* convert PLCP signal to 802.11 rate */
	//rate = bcw_rate(val);
	rate = 0;

	imr->ifm_active |= ieee80211_rate2media(ic, rate, ic->ic_curmode);
	switch (ic->ic_opmode) {
		case IEEE80211_M_STA:
			break;
		case IEEE80211_M_IBSS:
			imr->ifm_active |= IFM_IEEE80211_ADHOC;
			break;
		case IEEE80211_M_MONITOR:
			imr->ifm_active |= IFM_IEEE80211_MONITOR;
			break;
		case IEEE80211_M_AHDEMO:
		case IEEE80211_M_HOSTAP:
			/* should not get there */
			break;
	}
}

/*
 * One second timer, checks link status
 */
void
bcw_tick(void *v)
{
#if 0
	struct bcw_softc *sc = v;

	/* http://bcm-specs.sipsolutions.net/PeriodicTasks */
	timeout_add(&sc->bcw_timeout, hz);
#endif
}

/*
 * Validate Chip Access
 *
 * This function ensures that the 80211 core is setup correctly and
 * and is read for use.
 *
 * http://bcm-specs.sipsolutions.net/ValidateChipAccess
 */
int
bcw_validate_chip_access(struct bcw_softc *sc)
{
	uint32_t save, val;

	/* test 1 (this test is just for the 80211 core) */
	if (sc->sc_core[sc->sc_currentcore].id != BCW_CORE_80211)
		goto fail;

	/* save value */
	save = bcw_shm_read32(sc, BCW_SHM_SHARED, 0);

	/* test 2 */
	bcw_shm_write32(sc, BCW_SHM_SHARED, 0, 0xaa5555aa);
	val = bcw_shm_read32(sc, BCW_SHM_SHARED, 0);
	if (val != 0xaa5555aa)
		goto fail;

	/* test 3 */
	bcw_shm_write32(sc, BCW_SHM_SHARED, 0, 0x55aaaa55);
	val = bcw_shm_read32(sc, BCW_SHM_SHARED, 0);
	if (val != 0x55aaaa55)
		goto fail;

	/* restore value */
	bcw_shm_write32(sc, BCW_SHM_SHARED, 0, save);

	if (sc->sc_core_80211->rev >= 3) {
		/* test 4 */
		BCW_WRITE16(sc, 0x18c, 0xaaaa);
		BCW_WRITE(sc, 0x18c, 0xccccbbbb);
		val = BCW_READ16(sc, 0x604);
		if (val != 0xbbbb)
			goto fail;
		/* test 5 */
		val = BCW_READ16(sc, 0x606);
		if (val != 0xcccc)
			goto fail;
		BCW_WRITE(sc, 0x18c, 0);
	}

	/* test 6 */
	val = BCW_READ(sc, BCW_MMIO_SBF);
	if ((val | 0x80000000) != 0x80000400)
		goto fail;

	/* test 7 */
	val = BCW_READ(sc, BCW_MMIO_GIR);
	if (val != 0)
		goto fail;

	/* test 8 */
	if (sc->sc_phy_type > BCW_PHY_TYPEG)
		goto fail;

	return (0);

fail:
	printf("%s: Chip Access Validation failed!\n", sc->sc_dev.dv_xname);
	return (1);
}

int
bcw_detach(void *arg)
{
	struct bcw_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	timeout_del(&sc->sc_scan_to);

	bcw_stop(ifp, 1);
	ieee80211_ifdetach(ifp);
	if_detach(ifp);
	bcw_free_rx_ring(sc, &sc->sc_rxring);
	bcw_free_tx_ring(sc, &sc->sc_txring);

	/* power off cardbus socket */
	if (sc->sc_disable)
		sc->sc_disable(sc);

	return (0);
}

int
bcw_alloc_rx_ring(struct bcw_softc *sc, struct bcw_rx_ring *ring, int count)
{
	struct bcw_desc *desc;
	struct bcw_rx_data *data;
	int i, nsegs, error;

	ring->count = count;
	ring->cur = ring->next = 0;

	error = bus_dmamap_create(sc->sc_dmat,
	    count * sizeof(struct bcw_desc), 1,
	    count * sizeof(struct bcw_desc), 0,
	    BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat,
	    count * sizeof(struct bcw_desc),
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    count * sizeof(struct bcw_desc), (caddr_t *)&ring->desc,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    count * sizeof(struct bcw_desc), NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	bzero(ring->desc, count * sizeof(struct bcw_desc));
	ring->physaddr = ring->map->dm_segs->ds_addr;

	ring->data = malloc(count * sizeof (struct bcw_rx_data), M_DEVBUF,
	    M_NOWAIT);
	if (ring->data == NULL) {
		printf("%s: could not allocate soft data\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}

	BCW_WRITE(sc, BCW_DMA_RXADDR, ring->physaddr + 0x40000000);

	/*
	 * Pre-allocate Rx buffers and populate Rx ring.
	 */
	bzero(ring->data, count * sizeof (struct bcw_rx_data));
	for (i = 0; i < count; i++) {
		desc = &ring->desc[i];
		data = &ring->data[i];

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &data->map);
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: could not load rx buf DMA map",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	
		desc->addr = htole32(data->map->dm_segs->ds_addr);

		if (i != (count - 1))
			desc->ctrl = htole32(BCW_RXBUF_LEN);
		else
			desc->ctrl = htole32(BCW_RXBUF_LEN | CTRL_EOT);
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	return (0);

fail:	bcw_free_rx_ring(sc, ring);
	return (error);
}

void
bcw_reset_rx_ring(struct bcw_softc *sc, struct bcw_rx_ring *ring)
{
	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ring->cur = ring->next = 0;
}

void
bcw_free_rx_ring(struct bcw_softc *sc, struct bcw_rx_ring *ring)
{
	struct bcw_rx_data *data;
	int i;

	if (ring->desc != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    ring->count * sizeof(struct bcw_desc));
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}

	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    data->map->dm_mapsize,
				    BUS_DMASYNC_POSTREAD);
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}

			if (data->map != NULL)
				bus_dmamap_destroy(sc->sc_dmat, data->map);
		}
		free(ring->data, M_DEVBUF);
	}
}

int
bcw_alloc_tx_ring(struct bcw_softc *sc, struct bcw_tx_ring *ring,
    int count)
{
	int i, nsegs, error;

	ring->count = count;
	ring->queued = 0;
	ring->cur = ring->next = ring->stat = 0;

	error = bus_dmamap_create(sc->sc_dmat,
	    count * sizeof(struct bcw_desc), 1,
	    count * sizeof(struct bcw_desc), 0, BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat,
	    count * sizeof(struct bcw_desc),
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    count * sizeof(struct bcw_desc), (caddr_t *)&ring->desc,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    count * sizeof(struct bcw_desc), NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	memset(ring->desc, 0, count * sizeof(struct bcw_desc));
	ring->physaddr = ring->map->dm_segs->ds_addr;

	/* MAGIC */
	BCW_WRITE(sc, BCW_DMA_TXADDR, ring->physaddr + 0x40000000);

	ring->data = malloc(count * sizeof(struct bcw_tx_data), M_DEVBUF,
	    M_NOWAIT);
	if (ring->data == NULL) {
		printf("%s: could not allocate soft data\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}

	memset(ring->data, 0, count * sizeof(struct bcw_tx_data));
	for (i = 0; i < count; i++) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    BCW_MAX_SCATTER, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &ring->data[i].map);
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	return (0);

fail:	bcw_free_tx_ring(sc, ring);
	return (error);
}

void
bcw_reset_tx_ring(struct bcw_softc *sc, struct bcw_tx_ring *ring)
{
	struct bcw_desc *desc;
	struct bcw_tx_data *data;
	int i;

	for (i = 0; i < ring->count; i++) {
		desc = &ring->desc[i];
		data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}

		/*
		 * The node has already been freed at that point so don't call
		 * ieee80211_release_node() here.
		 */
		data->ni = NULL;
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ring->queued = 0;
	ring->cur = ring->next = ring->stat = 0;
}

void
bcw_free_tx_ring(struct bcw_softc *sc, struct bcw_tx_ring *ring)
{
	struct bcw_tx_data *data;
	int i;

	if (ring->desc != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    ring->count * sizeof(struct bcw_desc));
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}

	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    data->map->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}

			/*
			 * The node has already been freed at that point so
			 * don't call ieee80211_release_node() here.
			 */
			data->ni = NULL;

			if (data->map != NULL)
				bus_dmamap_destroy(sc->sc_dmat, data->map);
		}
		free(ring->data, M_DEVBUF);
	}
}

int
bcw_change_core(struct bcw_softc *sc, int changeto)
{
	int i;
	uint32_t sbval;

	(sc->sc_conf_write)(sc, BCW_ADDR_SPACE0, BCW_CORE_SELECT(changeto));

	/* loop to see if the selected core shows up */
	for (i = 0; i < 10; i++) {
		sbval = (sc->sc_conf_read)(sc, BCW_ADDR_SPACE0);
		if (sbval == BCW_CORE_SELECT(changeto))
			break;
		delay(10);
	}
	if (i == 10) {
		DPRINTF(("%s: can not change to core %d!\n",
		    sc->sc_dev.dv_xname, changeto)); 
		return (1);
	}

	/* core changed */
	sc->sc_lastcore = sc->sc_currentcore;
	sc->sc_currentcore = changeto;

	return (0);
}

/*
 * Enable current core
 */
int
bcw_core_enable(struct bcw_softc *sc, uint32_t core_flags)
{
	uint32_t sbtmstatelow;
	uint32_t sbtmstatehigh;
	uint32_t sbimstate;
	int error;

	if ((error = bcw_core_disable(sc, core_flags)))
		return (error);

	sbtmstatelow =
	    BCW_SBTMSTATELOW_CLOCK |
	    BCW_SBTMSTATELOW_RESET |
	    BCW_SBTMSTATELOW_FGCLOCK |
	    core_flags;
	BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, sbtmstatelow);
	delay(1);

	sbtmstatehigh = BCW_READ(sc, BCW_CIR_SBTMSTATEHIGH);
	if (sbtmstatehigh & BCW_SBTMSTATEHIGH_SERROR) {
		sbtmstatehigh = 0;
		BCW_WRITE(sc, BCW_CIR_SBTMSTATEHIGH, sbtmstatehigh);
	}

	sbimstate = BCW_READ(sc, BCW_CIR_SBIMSTATE);
	if (sbimstate & (BCW_SBIMSTATE_IB_ERROR | BCW_SBIMSTATE_TIMEOUT)) {
		sbimstate &= ~(BCW_SBIMSTATE_IB_ERROR | BCW_SBIMSTATE_TIMEOUT);
		BCW_WRITE(sc, BCW_CIR_SBIMSTATE, sbimstate);
	}

	sbtmstatelow =
	    BCW_SBTMSTATELOW_CLOCK |
	    BCW_SBTMSTATELOW_FGCLOCK |
	    core_flags;
	BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, sbtmstatelow);
	delay(1);

	sbtmstatelow = BCW_SBTMSTATELOW_CLOCK | core_flags;
	BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, sbtmstatelow);
	delay(1);

	return (0);
}

/*
 * Disable current core
 */
int
bcw_core_disable(struct bcw_softc *sc, uint32_t core_flags)
{
	uint32_t sbtmstatelow;
	uint32_t sbtmstatehigh;
	int i;

	/* fetch sbtmstatelow from core information registers */
	sbtmstatelow = BCW_READ(sc, BCW_CIR_SBTMSTATELOW);

	/* core is already in reset */
	if (sbtmstatelow & BCW_SBTMSTATELOW_RESET)
		goto out;

	if (sbtmstatelow & BCW_SBTMSTATELOW_CLOCK) {
		sbtmstatelow =
		    BCW_SBTMSTATELOW_CLOCK |
		    BCW_SBTMSTATELOW_REJECT;
		BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, sbtmstatelow);

		for (i = 0; i < 1000; i++) {
			sbtmstatelow = BCW_READ(sc, BCW_CIR_SBTMSTATELOW);
			if (sbtmstatelow & BCW_SBTMSTATELOW_REJECT) {
				i = -1;
				break;
			}
			delay(10);
		}
		if (i != -1) {
			DPRINTF(("%s: can not disable core, REJECT timeout!\n",
			   sc->sc_dev.dv_xname));
			return (EBUSY);
		}

		for (i = 0; i < 1000; i++) {
			sbtmstatehigh = BCW_READ(sc, BCW_CIR_SBTMSTATEHIGH);
			if (!(sbtmstatehigh & BCW_SBTMSTATEHIGH_BUSY)) {
				i = -1;
				break;
			}
			delay(10);
		}
		if (i != -1) {
			DPRINTF(("%s: can not disable, core, BUSY timeout!\n",
			    sc->sc_dev.dv_xname));
			return (EBUSY);
		}

		sbtmstatelow =
		    BCW_SBTMSTATELOW_FGCLOCK |
		    BCW_SBTMSTATELOW_REJECT |
		    BCW_SBTMSTATELOW_RESET |
		    BCW_SBTMSTATELOW_CLOCK |
		    core_flags;
		BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, sbtmstatelow);
		delay(10); 
	}

	sbtmstatelow =
	    BCW_SBTMSTATELOW_RESET |
	    BCW_SBTMSTATELOW_REJECT |
	    core_flags;
	BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, sbtmstatelow);

out:
	/* XXX sc_current_core_enabled = 0 */

	return (0);
}

/*
 * Reset the 80211 core
 *
 * http://bcm-specs.sipsolutions.net/80211CoreReset
 */
void
bcw_80211_core_reset(struct bcw_softc *sc, int connect_phy)
{
	uint32_t flags = 0x00040000;

	if (connect_phy)
		flags |= 0x20000000;
	bcw_phy_connect(sc, connect_phy);
	bcw_core_enable(sc, flags);
	BCW_WRITE16(sc, 0x03e6, 0);
	BCW_WRITE(sc, BCW_MMIO_SBF, BCW_READ(sc, BCW_MMIO_SBF) |
	    BCW_SBF_400_MAGIC);
}

/*
 * Disable the 80211 core
 *
 * http://bcm-specs.sipsolutions.net/80211CoreDisable
 */
void
bcw_80211_core_disable(struct bcw_softc *sc)
{
	bcw_radio_off(sc);
	BCW_WRITE16(sc, 0x03e6, 0x00f4);
	bcw_core_disable(sc, 0);
}

int
bcw_iocore_enable(struct bcw_softc *sc, uint32_t coremask)
{
	uint32_t val;
	uint32_t bp_flag_nr;
	int error;

	val = BCW_READ(sc, BCW_CIR_SBTPSFLAG);
	bp_flag_nr = val & SBTPS_BACKPLANEFLAGMASK;

	if ((error = bcw_change_core(sc, 2)))
		return (error);

	if (sc->sc_core[sc->sc_currentcore].rev < 6 &&
	    sc->sc_core[sc->sc_currentcore].id == BCW_CORE_PCI) {
		val = BCW_READ(sc, BCW_CIR_SBINTVEC);
		val |= (1 << bp_flag_nr);
		BCW_WRITE(sc, BCW_CIR_SBINTVEC, val);
	} else {
		val = (sc->sc_conf_read)(sc, BCW_PCICFG_ICR);
		val |= coremask << 8;
		(sc->sc_conf_write)(sc, BCW_PCICFG_ICR, val);
	}
	
	if (sc->sc_core[sc->sc_currentcore].id == BCW_CORE_PCI) {
		val = BCW_READ(sc, BCW_PCICORE_SBTOPCI2);
		val |= BCW_SBTOPCI2_PREFETCH | BCW_SBTOPCI2_BURST;
		BCW_WRITE(sc, BCW_PCICORE_SBTOPCI2, val);

		if (sc->sc_core[sc->sc_currentcore].rev < 5) {
			val = BCW_READ(sc, BCW_CIR_SBIMCONFIGLOW);
			val |= (2 << BCW_SBIMCONFIGLOW_STS) &
			    BCW_SBIMCONFIGLOW_STM;
			val |= (3 << BCW_SBIMCONFIGLOW_STS) &
			    BCW_SBIMCONFIGLOW_STM;
			BCW_WRITE(sc, BCW_CIR_SBIMCONFIGLOW, val);
			/* TODO commit PCI settings */
		} else if (sc->sc_core[sc->sc_currentcore].rev >= 11) {
			val = BCW_READ(sc, BCW_PCICORE_SBTOPCI2);
			val |= BCW_SBTOPCI2_MEMREAD_MULTI;
			BCW_WRITE(sc, BCW_PCICORE_SBTOPCI2, val);
		}
	}

	if ((error = bcw_change_core(sc, sc->sc_lastcore)))
		return (error);

	return (0);
}

int
bcw_get_firmware(const char *name, const uint8_t *ucode, size_t size_ucode,
    size_t *size, size_t *offset)
{
	int i, nfiles, off = 0, ret = 1;
	struct fwheader *h;

	if ((h = malloc(sizeof(struct fwheader), M_DEVBUF, M_NOWAIT)) == NULL)
		return (ret);

	/* get number of firmware files */
	bcopy(ucode, &nfiles, sizeof(nfiles));
	nfiles = ntohl(nfiles);
	off += sizeof(nfiles);

	/* parse header and search the firmware */
	for (i = 0; i < nfiles && off < size_ucode; i++) {
		bzero(h, sizeof(struct fwheader));
		bcopy(ucode + off, h, sizeof(struct fwheader));
		off += sizeof(struct fwheader);

		if (strcmp(name, h->filename) == 0) {
			ret = 0;
			*size = ntohl(h->filesize);
			*offset = ntohl(h->fileoffset);
			break;
		}
	}

	free(h, M_DEVBUF);

	return (ret);
}

int
bcw_load_firmware(struct bcw_softc *sc)
{
	int rev = sc->sc_core[sc->sc_currentcore].rev;
	int error, len, i;
	uint32_t *data;
	uint8_t *ucode;
	size_t size_ucode, size_micro, size_pcm, off_micro, off_pcm;
	char *name = "bcw-bcm43xx";
	char filename[64];

	/* load firmware */
	if ((error = loadfirmware(name, &ucode, &size_ucode)) != 0) {
		printf("%s: error %d, could not read microcode %s!\n",
		    sc->sc_dev.dv_xname, error, name);
		return (EIO);
	}
	DPRINTF(("%s: successfully read %s\n", sc->sc_dev.dv_xname, name));

	/* get microcode file offset */
	snprintf(filename, sizeof(filename), "bcm43xx_microcode%d.fw",
	    rev >= 5 ? 5 : rev);

	if (bcw_get_firmware(filename, ucode, size_ucode, &size_micro,
	    &off_micro) != 0) {
		printf("%s: get offset for firmware file %s failed!\n",
		    sc->sc_dev.dv_xname, filename);
		goto fail;
	}

	/* get pcm file offset */
	snprintf(filename, sizeof(filename), "bcm43xx_pcm%d.fw",
	    rev < 5 ? 4 : 5);

	if (bcw_get_firmware(filename, ucode, size_ucode, &size_pcm,
	    &off_pcm) != 0) {
		printf("%s: get offset for firmware file %s failed!\n",
		    sc->sc_dev.dv_xname, filename);
		goto fail;
	}

	/* upload microcode */
	data = (uint32_t *)(ucode + off_micro);
	len = size_micro / sizeof(uint32_t);
	bcw_shm_ctl_word(sc, BCW_SHM_UCODE, 0);
	for (i = 0; i < len; i++) {
		BCW_WRITE(sc, BCW_MMIO_SHM_DATA, betoh32(data[i]));
		delay(10);
	}
	DPRINTF(("%s: uploaded microcode\n", sc->sc_dev.dv_xname));

	/* upload pcm */
	data = (uint32_t *)(ucode + off_pcm);
	len = size_pcm / sizeof(uint32_t);
	bcw_shm_ctl_word(sc, BCW_SHM_PCM, 0x01ea);
	BCW_WRITE(sc, BCW_MMIO_SHM_DATA, 0x00004000);
	bcw_shm_ctl_word(sc, BCW_SHM_PCM, 0x01eb);
	for (i = 0; i < len; i++) {
		BCW_WRITE(sc, BCW_MMIO_SHM_DATA, betoh32(data[i]));
		delay(10);
	}
	DPRINTF(("%s: uploaded pcm\n", sc->sc_dev.dv_xname));

	free(ucode, M_DEVBUF);

	return (0);

fail:	free(ucode, M_DEVBUF);
	return (EIO);
}

int
bcw_write_initvals(struct bcw_softc *sc, const struct bcw_initval *data,
    const unsigned int len)
{
	int i;
	uint16_t offset, size;
	uint32_t value;

	for (i = 0; i < len; i++) {
		offset = betoh16(data[i].offset);
		size = betoh16(data[i].size);
		value = betoh32(data[i].value);

		if (offset >= 0x1000)
			goto bad_format;
		if (size == 2) {
			if (value & 0xffff0000)
				goto bad_format;
			BCW_WRITE16(sc, offset, (uint16_t)value);
		} else if (size == 4)
			BCW_WRITE(sc, offset, value);
		else
			goto bad_format;
	}

	return (0);

bad_format:
	printf("%s: initvals file-format error!\n", sc->sc_dev.dv_xname);
	return (EIO);
}

int
bcw_load_initvals(struct bcw_softc *sc)
{
	int rev = sc->sc_core[sc->sc_currentcore].rev;
	int error, nr;
	uint32_t val;
	uint8_t *ucode;
	size_t size_ucode, size_ival0, size_ival1, off_ival0, off_ival1;
	char *name = "bcw-bcm43xx";
	char filename[64];

	/* load firmware */
	if ((error = loadfirmware(name, &ucode, &size_ucode)) != 0) {
		printf("%s: error %d, could not read microcode %s!\n",
		    sc->sc_dev.dv_xname, error, name);
		return (EIO);
	}
	DPRINTF(("%s: successfully read %s\n", sc->sc_dev.dv_xname, name));

	/* get initval0 file offset */
	if (rev == 2 || rev == 4) {
		switch (sc->sc_phy_type) {
		case BCW_PHY_TYPEA:
			nr = 3;
			break;
		case BCW_PHY_TYPEB:
		case BCW_PHY_TYPEG:
			nr = 1;
			break;
		default:
			printf("%s: no initvals available!\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	} else if (rev >= 5) {
		switch (sc->sc_phy_type) {
		case BCW_PHY_TYPEA:
			nr = 7;
			break;
		case BCW_PHY_TYPEB:
		case BCW_PHY_TYPEG:
			nr = 5;
			break;
		default:
			printf("%s: no initvals available!\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	} else {
		printf("%s: no initvals available!\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	snprintf(filename, sizeof(filename), "bcm43xx_initval%02d.fw", nr);

	if (bcw_get_firmware(filename, ucode, size_ucode, &size_ival0,
	    &off_ival0) != 0) {
		printf("%s: get offset for initval0 file %s failed\n",
		    sc->sc_dev.dv_xname, filename);
		goto fail;
	}

	/* get initval1 file offset */
	if (rev >= 5) {
		switch (sc->sc_phy_type) {
		case BCW_PHY_TYPEA:
			val = BCW_READ(sc, BCW_SBTMSTATEHI);
			if (val & 0x00010000)
				nr = 9;
			else
				nr = 10;
			break;
		case BCW_PHY_TYPEB:
		case BCW_PHY_TYPEG:
			nr = 6;
			break;
		default:
			printf("%s: no initvals available!\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		snprintf(filename, sizeof(filename), "bcm43xx_initval%02d.fw",
		    nr);

		if (bcw_get_firmware(filename, ucode, size_ucode, &size_ival1,
		    &off_ival1) != 0) {
			printf("%s: get offset for initval1 file %s failed\n",
			    sc->sc_dev.dv_xname, filename);
			goto fail;
		}
	}

	/* upload initval0 */
	if (bcw_write_initvals(sc, (struct bcw_initval *)(ucode + off_ival0),
	    size_ival0 / sizeof(struct bcw_initval)))
		goto fail;
	DPRINTF(("%s: uploaded initval0\n", sc->sc_dev.dv_xname));

	/* upload initval1 */
	if (off_ival1 != 0) {
		if (bcw_write_initvals(sc,
		    (struct bcw_initval *)(ucode + off_ival1),
		    size_ival1 / sizeof(struct bcw_initval)))
			goto fail;
		DPRINTF(("%s: uploaded initval1\n", sc->sc_dev.dv_xname));
	}

	free(ucode, M_DEVBUF);

	return (0);

fail:	free(ucode, M_DEVBUF);
	return (EIO);
}

void
bcw_leds_switch_all(struct bcw_softc *sc, int on)
{
	struct bcw_led *led;
	uint16_t ledctl;
	int i, bit_on;

	ledctl = BCW_READ16(sc, BCW_MMIO_GPIO_CONTROL);

	for (i = 0; i < BCW_NR_LEDS; i++) {
		led = &(sc->leds[i]);
		if (led->behaviour == BCW_LED_INACTIVE)
			continue;
		if (on)
			bit_on = led->activelow ? 0 : 1;
		else
			bit_on = led->activelow ? 0 : 1;
		if (bit_on)
			ledctl |= (1 << i);
		else
			ledctl &= ~(1 << i);
	}

	BCW_WRITE16(sc, BCW_MMIO_GPIO_CONTROL, ledctl);
}

int
bcw_gpio_init(struct bcw_softc *sc)
{
	uint32_t mask, set;
	int error = 0;

	BCW_WRITE(sc, BCW_MMIO_SBF, BCW_READ(sc, BCW_MMIO_SBF) & 0xffff3fff);

	bcw_leds_switch_all(sc, 0);

	BCW_WRITE16(sc, BCW_MMIO_GPIO_MASK,
	    BCW_READ16(sc, BCW_MMIO_GPIO_MASK) | 0x000f);

	mask = 0x0000001f;
	set = 0x0000000f;

	if (sc->sc_chip_id == 0x4301) {
		mask |= 0x0060;
		set |= 0x0060;
	}
	if (0) { /* XXX conditional unknown */
		BCW_WRITE16(sc, BCW_MMIO_GPIO_MASK,
		    BCW_READ16(sc, BCW_MMIO_GPIO_MASK) | 0x0100);
		mask |= 0x0180;
		set |= 0x0180;
	}
	if (sc->sc_sprom.boardflags & BCW_BF_PACTRL) {
		BCW_WRITE16(sc, BCW_MMIO_GPIO_MASK,
		    BCW_READ16(sc, BCW_MMIO_GPIO_MASK) | 0x0200);
		mask |= 0x0200;
		set |= 0x0200;
	}
	if (sc->sc_chip_rev >= 2)
		mask |= 0x0010; /* XXX this is redundant */

	/*
	 * TODO bcw_change_core_to_gpio()
	 *
	 * Where to find the GPIO register depends on the chipset.
	 * If it has a ChipCommon, its register at offset 0x6c is the GPIO
	 * control register. Otherwise the register at offset 0x6c in the
	 * PCI core is the GPIO control register.
	 */
	if ((error = bcw_change_core(sc, 0)))
		return (error);

	BCW_WRITE(sc, BCW_GPIO_CTRL, (BCW_READ(sc, BCW_GPIO_CTRL) & mask) |
	    set);

	error = bcw_change_core(sc, sc->sc_lastcore);

	return (error);
}

/*
 * Initialize the chip
 *
 * http://bcm-specs.sipsolutions.net/ChipInit
 */
int
bcw_chip_init(struct bcw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint8_t limit;
	uint16_t val16;
	uint32_t val32;
	int error, i;

	BCW_WRITE(sc, BCW_MMIO_SBF, BCW_SBF_CORE_READY | BCW_SBF_400_MAGIC);

	/* load firmware */
	if ((error = bcw_load_firmware(sc)))
		return (error);

	/*
	 * verify firmware revision
	 */
	BCW_WRITE(sc, BCW_MMIO_GIR, 0xffffffff);
	BCW_WRITE(sc, BCW_MMIO_SBF, 0x00020402);
	for (i = 0; i < 50; i++) {
		if (BCW_READ(sc, BCW_MMIO_GIR) == BCW_INTR_READY)
			break;
		delay(10);
	}
	if (i == 50) {
		printf("%s: interrupt-ready timeout!\n", sc->sc_dev.dv_xname);
		return (1);
	}
	BCW_READ(sc, BCW_MMIO_GIR);	/* dummy read */

	val16 = bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_REVISION);

	DPRINTF(("%s: Firmware revision 0x%x, patchlevel 0x%x "
            "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
	    sc->sc_dev.dv_xname, val16,
	    bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_PATCHLEVEL),
            (bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_DATE) >> 12)
            & 0xf,
            (bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_DATE) >> 8)
            & 0xf,
            bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_DATE)
            & 0xff,
            (bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_TIME) >> 11)
            & 0x1f,
            (bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_TIME) >> 5)
            & 0x3f,
            bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_TIME)
	    & 0x1f));

	if (val16 > 0x128) {
		printf("%s: no support for this firmware revision!\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}

	/* initialize GPIO */
	if ((error = bcw_gpio_init(sc)))
		return (error);

	/* load init values */
	if ((error = bcw_load_initvals(sc)))
		return (error);

	if (sc->sc_core[sc->sc_currentcore].rev > 9) {
		BCW_WRITE(sc, 0x540, 0x540);
		BCW_WRITE(sc, 0x520, 0x520);
		BCW_WRITE(sc, 0x540, 0x540);
		BCW_WRITE(sc, 0x418, 0xe0a);
		BCW_WRITE(sc, 0x41a, 0x90b);
		BCW_WRITE(sc, 0x41c, 0x20e);
		BCW_WRITE(sc, 0x41e, 0); 
	}

	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x5c, 0xa);

	BCW_WRITE(sc, 0x0100, 0x01000000);

	if (sc->sc_core[sc->sc_currentcore].rev < 5)
		BCW_WRITE(sc, 0x010c, 0x01000000);

	val32 = BCW_READ(sc, BCW_MMIO_SBF);
	val32 &= ~BCW_SBF_AP;
	BCW_WRITE(sc, BCW_MMIO_SBF, val32);
	val32 = BCW_READ(sc, BCW_MMIO_SBF);
	val32 |= BCW_SBF_ADHOC;
	BCW_WRITE(sc, BCW_MMIO_SBF, val32);

	if (bcw_using_pio(sc)) {
		BCW_WRITE(sc, 0x0210, 0x00000100);
		BCW_WRITE(sc, 0x0230, 0x00000100);
		BCW_WRITE(sc, 0x0250, 0x00000100);
		BCW_WRITE(sc, 0x0270, 0x00000100);
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0034, 0);
	}

	/* probe response timeout value */
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0074, 0);

	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x400, 0x8);

	/* TODO slot timing */

	bcw_set_opmode(ifp);

	if (sc->sc_core[sc->sc_currentcore].rev < 3) {
		BCW_WRITE16(sc, 0x060e, 0);
		BCW_WRITE16(sc, 0x0610, 0x8000);
		BCW_WRITE16(sc, 0x0604, 0);
		BCW_WRITE16(sc, 0x0606, 0x0200);
	} else {
		BCW_WRITE(sc, 0x0188, 0x80000000);
		BCW_WRITE(sc, 0x018c, 0x02000000);
	}

	BCW_WRITE(sc, BCW_MMIO_GIR, 0x00004000);
	BCW_WRITE(sc, BCW_MMIO_DMA0_INT_MASK, 0x0001dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA1_INT_MASK, 0x0000dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA2_INT_MASK, 0x0000dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA3_INT_MASK, 0x0001dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA4_INT_MASK, 0x0000dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA5_INT_MASK, 0x0000dc00);

	val32 = BCW_READ(sc, BCW_CIR_SBTMSTATELOW);
	val32 |= 0x00100000;
	BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, val32);

	if (sc->sc_core[sc->sc_currentcore].rev >= 5)
		BCW_WRITE16(sc, BCW_MMIO_POWERUP_DELAY,
		    bcw_pc_powerup_delay(sc));

	val16 = sc->sc_core[sc->sc_currentcore].rev;
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x16, val16);

	/* short/long retry limit */
	limit = bcw_lv(BCW_DEFAULT_SHORT_RETRY_LIMIT, 0, 0xf);
	bcw_shm_write32(sc, BCW_SHM_80211, 0x0006, limit);
	limit = bcw_lv(BCW_DEFAULT_LONG_RETRY_LIMIT, 0, 0xf);
	bcw_shm_write32(sc, BCW_SHM_80211, 0x0007, limit);

	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0044, 3);
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0046, 2);

	bcw_macfilter_clear(sc, BCW_MACFILTER_SELF);
	bcw_macfilter_set(sc, BCW_MACFILTER_SELF, ic->ic_myaddr);

	bcw_macfilter_clear(sc, BCW_MACFILTER_ASSOC);
	bcw_macfilter_set(sc, BCW_MACFILTER_ASSOC, ic->ic_bss->ni_bssid);

	bcw_templateram_set(sc);

	DPRINTF(("%s: Chip initialized\n", sc->sc_dev.dv_xname));

	return (0);
}

/*
 * Initialize the BS
 *
 * http://bcm-specs.sipsolutions.net/BSInit
 */
int
bcw_bs_init(struct bcw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t ucodeflags;

	BCW_WRITE16(sc, 0x03e6, 0);

	bcw_radio_on(sc);

	bcw_phy_init(sc);

	bcw_radio_set_interf_mitigation(sc, sc->sc_radio_interfmode);

	bcw_phy_set_antenna_diversity(sc);

	bcw_radio_set_txantenna(sc, BCW_RADIO_TXANTENNA_DEFAULT);

	/* minimum contention window */
	if (sc->sc_phy_type == BCW_PHY_TYPEB)
		bcw_shm_write32(sc, BCW_SHM_80211, 0x0003, 0x0000001f);
	else
		bcw_shm_write32(sc, BCW_SHM_80211, 0x0003, 0x0000000f);

	/* maximum contention window */
	bcw_shm_write32(sc, BCW_SHM_80211, 0x0004, 0x000003ff);

	bcw_rate_memory_init(sc);

	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x52, sc->sc_phy_type);
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x50, sc->sc_phy_rev);

	ucodeflags = bcw_shm_read32(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET);
	ucodeflags |= 0x100000;
	bcw_shm_write32(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET, ucodeflags);

	if (sc->sc_phy_type == BCW_PHY_TYPEA &&
	    sc->sc_core[sc->sc_currentcore].rev <= 4)
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x3c, 0x1d);
	else
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x3c, 0x1e);

	if (ic->ic_opmode != IEEE80211_M_IBSS &&
	    ic->ic_opmode == IEEE80211_M_HOSTAP) {
		BCW_WRITE16(sc, 0x612, 0x2);
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x416, 0x2);
	} else if (sc->sc_phy_type == BCW_PHY_TYPEA) {
		BCW_WRITE16(sc, 0x612, 0x78);
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x416, 0x78);
	} else {
		BCW_WRITE16(sc, 0x612, 0xfa);
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x416, 0xfa);
	}

	return (0);
}

/*
 * Initialize the 80211 core
 *
 * http://bcm-specs.sipsolutions.net/80211Init
 */
int
bcw_80211_core_init(struct bcw_softc *sc, int active_80211_core)
{
	uint32_t ucodeflags;
	//uint32_t sbimconfiglow;
	int error;
#if 0
	if (sc->sc_core_bus->rev <= 5 && sc->sc_core_bus->id != BCW_CORE_PCIE) {
		sbimconfiglow = BCW_READ(sc, BCW_CIR_SBIMCONFIGLOW);
		sbimconfiglow &= ~BCW_SBIMCONFIGLOW_RTM;
		sbimconfiglow &= ~BCW_SBIMCONFIGLOW_STM;
		sbimconfiglow |= 0x32;
		BCW_WRITE(sc, BCW_CIR_SBIMCONFIGLOW, sbimconfiglow);
	}
#endif

	bcw_phy_calibrate(sc);

	if ((error = bcw_chip_init(sc)))
		return (error);

	if ((error = bcw_bs_init(sc)))
		return (error);

	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0016, 0);

	/*
	 * Set microcode flags if necessery
	 */
	ucodeflags = bcw_shm_read32(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET);
	//ucodeflags |= 0x00000010; /* XXX */
	if (sc->sc_phy_type == BCW_PHY_TYPEB ||
	    sc->sc_phy_type == BCW_PHY_TYPEG)
		ucodeflags |= BCW_UCODEFLAG_UNKBGPHY;
	if (sc->sc_phy_type == BCW_PHY_TYPEG && sc->sc_phy_rev == 1)
		ucodeflags |= BCW_UCODEFLAG_UNKGPHY;
	if (sc->sc_phy_type == BCW_PHY_TYPEB && sc->sc_phy_rev >= 2 &&
	    sc->sc_radio_ver == 0x2050)
		ucodeflags &= ~BCW_UCODEFLAG_UNKGPHY;
	if (sc->sc_sprom.boardflags & BCW_BF_PACTRL)
		ucodeflags |= BCW_UCODEFLAG_UNKPACTRL;
	if (ucodeflags !=
	    bcw_shm_read32(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET))
		bcw_shm_write32(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET,
		    ucodeflags);

	if (sc->sc_core[sc->sc_currentcore].rev >= 5)
		BCW_WRITE16(sc, 0x043c, 0x000c);

	if (active_80211_core) {
		if (bcw_using_pio(sc)) {
			/* TODO bcw_pio_init() */
		} else {
			/* TODO bcw_dma_init() */
		}
	}

	BCW_WRITE16(sc, 0x0612, 0x0050);
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0416, 0x0050);
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0414, 0x01f4);
#if 0
	bcw_mac_enable(sc);
	bcw_intr_enable(sc, 0xb007a864);
#endif

	return (0);
}

uint8_t
bcw_sprom_crc8(uint8_t crc, uint8_t data)
{
        static const uint8_t t[] = {
	    0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
	    0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
	    0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
	    0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
	    0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
	    0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
	    0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
	    0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
	    0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
	    0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
	    0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
	    0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
	    0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
	    0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
	    0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
	    0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
	    0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
	    0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
	    0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
	    0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
	    0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
	    0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
	    0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
	    0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
	    0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
	    0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
	    0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
	    0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
	    0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
	    0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
	    0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
	    0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F,
        };

        return (t[crc ^ data]);
}

uint8_t
bcw_sprom_crc(const uint16_t *sprom)
{
	int word;
	uint8_t crc = 0xff;

	for (word = 0; word < BCW_SPROM_SIZE - 1; word++) {
		crc = bcw_sprom_crc8(crc, sprom[word] & 0x00ff);
		crc = bcw_sprom_crc8(crc, (sprom[word] & 0xff00) >> 8);
	}
	crc = bcw_sprom_crc8(crc, sprom[BCW_SPROM_VERSION] & 0x00ff);
	crc ^= 0xff;

	return (crc);
}

int
bcw_sprom_read(struct bcw_softc *sc, uint16_t *sprom)
{
	int i;
	uint8_t crc, expected_crc;

	for (i = 0; i < BCW_SPROM_SIZE; i++)
		sprom[i] = BCW_READ16(sc, BCW_SPROM_BASE + (i * 2));

	/* CRC-8 check */
	crc = bcw_sprom_crc(sprom);
	expected_crc = (sprom[BCW_SPROM_VERSION] & 0xff00) >> 8;
	if (crc != expected_crc) {
		printf("%s: invalid SPROM checksum! (0x%02x, expected 0x%02x\n",
		    sc->sc_dev.dv_xname, crc, expected_crc);
		return (EINVAL);
	}

	return (0);
}

/*
 * Get whole SPROM content
 *
 * http://bcm-specs.sipsolutions.net/SPROM
 */
int
bcw_sprom_get(struct bcw_softc *sc)
{
	uint16_t val;
	uint16_t *sprom;

	sprom = malloc(BCW_SPROM_SIZE * sizeof(uint16_t), M_DEVBUF, M_NOWAIT);
	if (sprom == NULL) {
		printf("%s: malloc in SPROM extract failed!\n",
		    sc->sc_dev.dv_xname);
		return (ENOMEM);
	}

	bcw_sprom_read(sc, sprom);

	/* boardflags */
	val = sprom[BCW_SPROM_BOARDFLAGS];
	sc->sc_sprom.boardflags2 = val;

	/* il0macaddr */
	val = sprom[BCW_SPROM_IL0MACADDR];
	*((uint16_t *)sc->sc_sprom.il0macaddr) = htobe16(val);
	val = sprom[BCW_SPROM_IL0MACADDR + 1];
	*(((uint16_t *)sc->sc_sprom.il0macaddr) + 1) = htobe16(val);
	val = sprom[BCW_SPROM_IL0MACADDR + 2];
	*(((uint16_t *)sc->sc_sprom.il0macaddr) + 2) = htobe16(val);

	/* et0macaddr */
	val = sprom[BCW_SPROM_ET0MACADDR];
	*((uint16_t *)sc->sc_sprom.et0macaddr) = htobe16(val);
	val = sprom[BCW_SPROM_ET0MACADDR + 1];
	*(((uint16_t *)sc->sc_sprom.et0macaddr) + 1) = htobe16(val);
	val = sprom[BCW_SPROM_ET0MACADDR + 2];
	*(((uint16_t *)sc->sc_sprom.et0macaddr) + 2) = htobe16(val);

	/* et1macaddr */
	val = sprom[BCW_SPROM_ET1MACADDR];
	*((uint16_t *)sc->sc_sprom.et1macaddr) = htobe16(val);
	val = sprom[BCW_SPROM_ET1MACADDR + 1];
	*(((uint16_t *)sc->sc_sprom.et1macaddr) + 1) = htobe16(val);
	val = sprom[BCW_SPROM_ET1MACADDR + 2];
	*(((uint16_t *)sc->sc_sprom.et1macaddr) + 2) = htobe16(val);

	/* ethernet phy settigns */
	val = sprom[BCW_SPROM_ETHPHY];
	sc->sc_sprom.et0phyaddr = (val & 0x001f);
	sc->sc_sprom.et1phyaddr = (val & 0x03e0);
	sc->sc_sprom.et0mdcport = (val & (1 << 14)) >> 14;
	sc->sc_sprom.et1mdcport = (val & (1 << 15)) >> 15;

	/* boardrev, antennas, locale */
	val = sprom[BCW_SPROM_BOARDREV];
	sc->sc_sprom.boardrev = (val & 0x00ff);
	sc->sc_sprom.locale = (val & 0x0f00);
	sc->sc_sprom.antennas_aphy = (val & 0x3000) >> 12;
	sc->sc_sprom.antennas_bgphy = (val & 0xc000) >> 14;

	/* pa0b */
	sc->sc_sprom.pa0b0 = sprom[BCW_SPROM_PA0B0];
	sc->sc_sprom.pa0b1 = sprom[BCW_SPROM_PA0B1];
	sc->sc_sprom.pa0b2 = sprom[BCW_SPROM_PA0B2];

	/* wl0gpio */
	val = sprom[BCW_SPROM_WL0GPIO0];
	if (val == 0)
		val = 0xffff;
	sc->sc_sprom.wl0gpio0 = val & 0x00ff;
	sc->sc_sprom.wl0gpio1 = (val & 0xff00) >> 8;
	val = sprom[BCW_SPROM_WL0GPIO2];
	if (val == 0)
		val = 0xffff;
	sc->sc_sprom.wl0gpio2 = val & 0x00ff;
	sc->sc_sprom.wl0gpio3 = (val & 0xff00) >> 8;

	/* maxpower */
	val = sprom[BCW_SPROM_MAXPWR];
	sc->sc_sprom.maxpower_aphy = (val & 0xff00) >> 8;
	sc->sc_sprom.maxpower_bgphy = val & 0xff00;

	/* pa1b */
	sc->sc_sprom.pa1b0 = sprom[BCW_SPROM_PA1B0];
	sc->sc_sprom.pa1b1 = sprom[BCW_SPROM_PA1B1];
	sc->sc_sprom.pa1b2 = sprom[BCW_SPROM_PA1B2];

	/* idle tssi target */
	val = sprom[BCW_SPROM_IDL_TSSI_TGT];
	sc->sc_sprom.idle_tssi_tgt_aphy = val & 0x00ff;
	sc->sc_sprom.idle_tssi_tgt_bgphy = (val & 0xff00) >> 8;

	/* boardflags */
	val = sprom[BCW_SPROM_BOARDFLAGS];
	if (val == 0xffff)
		val = 0;
	sc->sc_sprom.boardflags = val;
	/* TODO boardflags workarounds */

	/* antenna gain */
	val = sprom[BCW_SPROM_ANTENNA_GAIN];
	if (val == 0 || val == 0xffff)
		val = 0x0202;
	sc->sc_sprom.antennagain_aphy = ((val & 0xff00) >> 8) * 4;
	sc->sc_sprom.antennagain_bgphy = (val & 0x00ff) * 4;

	return (0);
}

/*
 * Init the Microcode Flags Bitfield
 *
 * http://bcm-specs.sipsolutions.net/MicrocodeFlagsBitfield
 */
void
bcw_microcode_init_fbf(struct bcw_softc *sc)
{
	uint32_t val;

	val = 0;
	if (sc->sc_phy_type == BCW_PHY_TYPEA ||
	    sc->sc_phy_type == BCW_PHY_TYPEB ||
	    sc->sc_phy_type == BCW_PHY_TYPEG)
		val |= 2;
	if (sc->sc_phy_type == BCW_PHY_TYPEG && sc->sc_phy_rev == 1)
		val |= 0x20;
	if (sc->sc_phy_type == BCW_PHY_TYPEG &&
	    sc->sc_sprom.boardflags & BCW_BF_PACTRL)
		val |= 0x40;
	if (sc->sc_phy_type == BCW_PHY_TYPEG && sc->sc_phy_rev < 3)
		val |= 0x8;
	if (sc->sc_sprom.boardflags & BCW_BF_XTAL)
		val |= 0x400;
	if (sc->sc_phy_type == BCW_PHY_TYPEB)
		val |= 0x4;
	if (sc->sc_radio_ver == 0x2050 && sc->sc_radio_rev <= 5)
	    	val |= 0x40000;
	/* XXX device not up and PCI bus with rev =< 10 set 0x80000 */

	bcw_shm_write32(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET, val);
}

/*
 * PHY
 */
int
bcw_phy_get(struct bcw_softc *sc)
{
	uint32_t val;

	val = BCW_READ16(sc, 0x3E0);
	sc->sc_phy_ver = (val & 0xf000) >> 12;
	sc->sc_phy_rev = val & 0xf;
	sc->sc_phy_type = (val & 0xf00) >> 8;

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		DPRINTF(("%s: PHY %d (A) ",
		    sc->sc_dev.dv_xname, sc->sc_phy_type));
		if (sc->sc_phy_rev != 2 &&
		    sc->sc_phy_rev != 3 &&
		    sc->sc_phy_rev != 5 &&
		    sc->sc_phy_rev != 6 &&
		    sc->sc_phy_rev != 7) {
			printf("has invalid revision %d!\n", sc->sc_phy_rev);
			return (1);
		}
		break;
	case BCW_PHY_TYPEB:
		DPRINTF(("%s: PHY %d (B) ",
		    sc->sc_dev.dv_xname, sc->sc_phy_type));
		if (sc->sc_phy_rev != 2 &&
		    sc->sc_phy_rev != 4 &&
		    sc->sc_phy_rev != 7) {
			printf("has invalid revision %d!\n", sc->sc_phy_rev);
			return (1);
		}
		break;
	case BCW_PHY_TYPEG:
		DPRINTF(("%s: PHY %d (G) ",
		    sc->sc_dev.dv_xname, sc->sc_phy_type));
		if (sc->sc_phy_rev != 1 &&
		    sc->sc_phy_rev != 2 &&
		    sc->sc_phy_rev != 4 &&
		    sc->sc_phy_rev != 6 &&
		    sc->sc_phy_rev != 7 &&
		    sc->sc_phy_rev != 8) {
			printf("has invalid revision %d!\n", sc->sc_phy_rev);
			return (1);
		}
		break;
	default:
		DPRINTF(("Unknown PHY type %d!\n", sc->sc_phy_type));
		return (1);
	}

	DPRINTF(("ver %d rev %d\n", sc->sc_phy_ver, sc->sc_phy_rev));

	return (0);
}

int
bcw_phy_init(struct bcw_softc *sc)
{
	int error = ENODEV;

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		if (sc->sc_phy_rev == 2 || sc->sc_phy_rev == 3) {
			error = 0;
		}
		break;
	case BCW_PHY_TYPEB:
		switch (sc->sc_phy_rev) {
		case 2:
			bcw_phy_initb2(sc);
			error = 0;
			break;
		case 4:
			bcw_phy_initb4(sc);
			error = 0;
			break;
		case 5:
			bcw_phy_initb5(sc);
			error = 0;
			break;
		case 6:
			bcw_phy_initb6(sc);
			error = 0;
			break;
		}
		break;
	case BCW_PHY_TYPEG:
		bcw_phy_initg(sc);
		error = 0;
		DPRINTF(("%s: PHY type G initialized\n", sc->sc_dev.dv_xname));
		break;
	}

	if (error)
		printf("%s: PHY type unknown!\n", sc->sc_dev.dv_xname);

	return (error);
}

void
bcw_phy_initg(struct bcw_softc *sc)
{
	uint16_t tmp;

	if (sc->sc_phy_rev == 1)
		bcw_phy_initb5(sc);
	else
		bcw_phy_initb6(sc);
	if (sc->sc_phy_rev >= 2 || sc->sc_phy_connected)
		bcw_phy_inita(sc);

	if (sc->sc_phy_rev >= 2) {
		bcw_phy_write16(sc, 0x0814, 0);
		bcw_phy_write16(sc, 0x0815, 0);
		if (sc->sc_phy_rev == 2)
			bcw_phy_write16(sc, 0x0811, 0);
		else if (sc->sc_phy_rev >= 3)
			bcw_phy_write16(sc, 0x0811, 0x0400);
		bcw_phy_write16(sc, 0x0015, 0x00c0);
		if (sc->sc_phy_connected) {
			tmp = bcw_phy_read16(sc, 0x0400) & 0xff;
			if (tmp < 6) {
				bcw_phy_write16(sc, 0x04c2, 0x1816);
				bcw_phy_write16(sc, 0x04c3, 0x8006);
				if (tmp != 3)
					bcw_phy_write16(sc, 0x04cc,
					    (bcw_phy_read16(sc, 0x04cc) &
					    0x00ff) | 0x1f00);
			}
		}
	}

	if (sc->sc_phy_rev < 3 && sc->sc_phy_connected)
		bcw_phy_write16(sc, 0x047e, 0x0078);
	if (sc->sc_phy_rev >= 6 && sc->sc_phy_rev <= 8) {
		bcw_phy_write16(sc, 0x0801, bcw_phy_read16(sc, 0x0801) |
		    0x0080);
		bcw_phy_write16(sc, 0x043e, bcw_phy_read16(sc, 0x043e) |
		    0x0004);
	}
	if (sc->sc_phy_rev >= 2 && sc->sc_phy_connected)
		bcw_phy_calc_loopback_gain(sc);
	if (sc->sc_radio_rev != 8) {
		if (sc->sc_radio_initval == 0xffff)
			sc->sc_radio_initval = bcw_radio_init2050(sc);
		else
			bcw_radio_write16(sc, 0x0078, sc->sc_radio_initval);
	}
	if (sc->sc_radio_txctl2 == 0xffff)
		bcw_phy_lo_g_measure(sc);
	else {
		if (sc->sc_radio_ver == 0x2050 && sc->sc_radio_rev == 8)
			bcw_radio_write16(sc, 0x0052,
			    (sc->sc_radio_txctl1 << 4) | sc->sc_radio_txctl2);
		else
			bcw_radio_write16(sc, 0x0052,
			    (bcw_radio_read16(sc, 0x0052) & 0xfff0) |
			    sc->sc_radio_txctl1);
		if (sc->sc_phy_rev >= 6)
			bcw_phy_write16(sc, 0x0036,
			    (bcw_phy_read16(sc, 0x0036) & 0xf000) |
			    (sc->sc_radio_txctl2 << 12));
		if (sc->sc_sprom.boardflags & BCW_BF_PACTRL)
			bcw_phy_write16(sc, 0x002e, 0x8075);
		else
			bcw_phy_write16(sc, 0x002e, 0x807f);
		if (sc->sc_phy_rev < 2)
			bcw_phy_write16(sc, 0x002f, 0x0101);
		else
			bcw_phy_write16(sc, 0x002f, 0x0202);
	}
	if (sc->sc_phy_connected) {
		bcw_phy_lo_adjust(sc, 0);
		bcw_phy_write16(sc, 0x080f, 0x8078);
	}

	if (!(sc->sc_sprom.boardflags & BCW_BF_RSSI)) {
		bcw_radio_nrssi_hw_update(sc, 0xffff);
		bcw_radio_calc_nrssi_threshold(sc);
	} else if (sc->sc_phy_connected) {
		if (sc->sc_radio_nrssi[0] == -1000) {
			bcw_radio_calc_nrssi_slope(sc);
		} else {
			bcw_radio_calc_nrssi_threshold(sc);
		}
	}

	if (sc->sc_radio_rev == 8)
		bcw_phy_write16(sc, 0x0805, 0x3230);
	bcw_phy_init_pctl(sc);
	if (sc->sc_chip_id == 0x4306 && sc->sc_chip_pkg == 2) {
		bcw_phy_write16(sc, 0x0429, bcw_phy_read16(sc, 0x0429) &
		    0xbfff);
		bcw_phy_write16(sc, 0x04c3, bcw_phy_read16(sc, 0x04c3) &
		    0x7fff);
	}
}

void
bcw_phy_initb5(struct bcw_softc *sc)
{
	uint16_t offset;

	if (sc->sc_phy_rev == 1 && sc->sc_radio_rev == 0x2050)
		bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) |
		    0x0050);

	if (sc->sc_board_vendor != PCI_VENDOR_BROADCOM &&
	    sc->sc_board_type != 0x0416) {
		for (offset = 0x00a8; offset < 0x00c7; offset++)
			bcw_phy_write16(sc, offset,
			    (bcw_phy_read16(sc, offset) + 0x02020) & 0x3f3f);
	}

	bcw_phy_write16(sc, 0x0035, (bcw_phy_read16(sc, 0x0035) & 0xf0ff) |
	    0x0700);

	if (sc->sc_radio_rev == 0x2050)
		bcw_phy_write16(sc, 0x0038, 0x0667);

	if (sc->sc_phy_connected) {
		if (sc->sc_radio_rev == 0x2050) {
			bcw_radio_write16(sc, 0x007a,
			    bcw_radio_read16(sc, 0x007a) | 0x0020);
			bcw_radio_write16(sc, 0x0051,
			    bcw_radio_read16(sc, 0x0051) | 0x0004);
		}
		BCW_WRITE16(sc, BCW_MMIO_PHY_RADIO, 0);
		bcw_phy_write16(sc, 0x0802, bcw_phy_read16(sc, 0x0802) |
		    0x0100);
		bcw_phy_write16(sc, 0x042b, bcw_phy_read16(sc, 0x042b) |
		    0x2000);
		bcw_phy_write16(sc, 0x001c, 0x186a);
		bcw_phy_write16(sc, 0x0013,
		    (bcw_phy_read16(sc, 0x0013) & 0x00ff) | 0x1900);
		bcw_phy_write16(sc, 0x0035,
		    (bcw_phy_read16(sc, 0x0035) & 0xffc0) | 0x0064);
		bcw_phy_write16(sc, 0x005d,
		    (bcw_phy_read16(sc, 0x005d) & 0xff80) | 0x000a);
	}

	if (sc->sc_phy_rev == 1 && sc->sc_radio_rev == 0x2050) {
		bcw_phy_write16(sc, 0x0026, 0xce00);
		bcw_phy_write16(sc, 0x0021, 0x3763);
		bcw_phy_write16(sc, 0x0022, 0x1bc3);
		bcw_phy_write16(sc, 0x0023, 0x06f9);
		bcw_phy_write16(sc, 0x0024, 0x037e);
	} else
		bcw_phy_write16(sc, 0x0026, 0xcc00);
	bcw_phy_write16(sc, 0x0030, 0x00c6);
	BCW_WRITE16(sc, 0x3ec, 0x3f22);

	if (sc->sc_phy_rev == 1 && sc->sc_radio_rev == 0x2050)
		bcw_phy_write16(sc, 0x0020, 0x3e1c);
	else
		bcw_phy_write16(sc, 0x0020, 0x301c);

	if (sc->sc_phy_rev == 0)
		BCW_WRITE16(sc, 0x03e4, 0x3000);

	/* force to channel 7, even if not supported */
	bcw_radio_select_channel(sc, 7, 0);

	if (sc->sc_radio_rev != 0x2050) {
		bcw_radio_write16(sc, 0x0075, 0x0080);
		bcw_radio_write16(sc, 0x0079, 0x0081);
	}

	bcw_radio_write16(sc, 0x0050, 0x0020);
	bcw_radio_write16(sc, 0x0050, 0x0023);

	if (sc->sc_radio_rev == 0x2050) {
		bcw_radio_write16(sc, 0x0050, 0x0020);
		bcw_radio_write16(sc, 0x005a, 0x0070);
	}

	bcw_radio_write16(sc, 0x005b, 0x007b);
	bcw_radio_write16(sc, 0x005c, 0x00b0);

	bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) | 0x0007);

	bcw_radio_select_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG, 0);

	bcw_phy_write16(sc, 0x0014, 0x0080);
	bcw_phy_write16(sc, 0x0032, 0x00ca);
	bcw_phy_write16(sc, 0x88a3, 0x002a);

	bcw_radio_set_txpower_bg(sc, 0xffff, 0xffff, 0xffff);

	if (sc->sc_radio_rev == 0x2050)
		bcw_radio_write16(sc, 0x005d, 0x000d);

	BCW_WRITE16(sc, 0x03e4, (BCW_READ16(sc, 0x03e4) & 0xffc0) | 0x0004);
}

void
bcw_phy_initb2(struct bcw_softc *sc)
{
	uint16_t offset, val;

	BCW_WRITE16(sc, 0x03ec, 0x3f22);
	bcw_phy_write16(sc, 0x0020, 0x301c);
	bcw_phy_write16(sc, 0x0026, 0x0000);
	bcw_phy_write16(sc, 0x0030, 0x00c6);
	bcw_phy_write16(sc, 0x0088, 0x3e00);
	val = 0x3c3d;
	for (offset = 0x0089; offset < 0x00a7; offset++) {
		bcw_phy_write16(sc, offset, val);
		val -= 0x0202;
	}
	bcw_phy_write16(sc, 0x03e4, 0x3000);
	if (sc->sc_radio_channel == 0xff)
		bcw_radio_select_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG, 0);
	else
		bcw_radio_select_channel(sc, sc->sc_radio_channel, 0);
	if (sc->sc_radio_ver != 0x2050) {
		bcw_radio_write16(sc, 0x0075, 0x0080);
		bcw_radio_write16(sc, 0x0079, 0x0081);
	}
	bcw_radio_write16(sc, 0x0050, 0x0020);
	bcw_radio_write16(sc, 0x0050, 0x0023);
	if (sc->sc_radio_ver == 0x2050) {
		bcw_radio_write16(sc, 0x0050, 0x0020);
		bcw_radio_write16(sc, 0x005a, 0x0070);
		bcw_radio_write16(sc, 0x005b, 0x007b);
		bcw_radio_write16(sc, 0x005c, 0x00b0);
		bcw_radio_write16(sc, 0x007a, 0x000f);
		bcw_phy_write16(sc, 0x0038, 0x0677);
		bcw_radio_init2050(sc);
	}
	bcw_phy_write16(sc, 0x0014, 0x0080);
	bcw_phy_write16(sc, 0x0032, 0x00ca);
	bcw_phy_write16(sc, 0x0032, 0x00cc);
	bcw_phy_write16(sc, 0x0035, 0x07c2);
	bcw_phy_lo_b_measure(sc);
	bcw_phy_write16(sc, 0x0026, 0xcc00);
	if (sc->sc_radio_ver != 0x2050)
		bcw_phy_write16(sc, 0x0026, 0xce00);
	BCW_WRITE16(sc, BCW_MMIO_CHANNEL_EXT, 0x1000);
	bcw_phy_write16(sc, 0x002a, 0x88a3);
	bcw_radio_set_txpower_bg(sc, 0xffff, 0xffff, 0xffff);
	bcw_phy_init_pctl(sc);
}

void
bcw_phy_initb4(struct bcw_softc *sc)
{
	uint16_t offset, val;

	BCW_WRITE16(sc, 0x03ec, 0x3f22);
	bcw_phy_write16(sc, 0x0020, 0x301c);
	bcw_phy_write16(sc, 0x0026, 0x0000);
	bcw_phy_write16(sc, 0x0030, 0x00c6);
	bcw_phy_write16(sc, 0x0088, 0x3e00);
	val = 0x3c3d;
	for (offset = 0x0089; offset < 0x00a7; offset++) {
		bcw_phy_write16(sc, offset, val);
		val -= 0x0202;
	}
	bcw_phy_write16(sc, 0x3e4, 0x3000);
	if (sc->sc_radio_channel == 0xff)
		bcw_radio_select_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG, 0);
	else
		bcw_radio_select_channel(sc, sc->sc_radio_channel, 0);
	if (sc->sc_radio_ver == 0x2050) {
		bcw_radio_write16(sc, 0x0050, 0x0020);
		bcw_radio_write16(sc, 0x005a, 0x0070);
		bcw_radio_write16(sc, 0x005b, 0x007b);
		bcw_radio_write16(sc, 0x005c, 0x00b0);
		bcw_radio_write16(sc, 0x007a, 0x000f);
		bcw_phy_write16(sc, 0x0038, 0x0677);
		bcw_radio_init2050(sc);
	}
	bcw_phy_write16(sc, 0x0014, 0x0080);
	bcw_phy_write16(sc, 0x0032, 0x00ca);
	if (sc->sc_radio_ver == 0x2050)
		bcw_phy_write16(sc, 0x0032, 0x00e0);
	bcw_phy_write16(sc, 0x0035, 0x07c2);

	bcw_phy_lo_b_measure(sc);

	bcw_phy_write16(sc, 0x0026, 0xcc00);
	if (sc->sc_radio_ver == 0x2050)
		bcw_phy_write16(sc, 0x0026, 0xce00);
	BCW_WRITE16(sc, BCW_MMIO_CHANNEL_EXT, 0x1100);
	bcw_phy_write16(sc, 0x002a, 0x88c2);
	if (sc->sc_radio_ver == 0x2050)
		bcw_phy_write16(sc, 0x002a, 0x88c2);
	bcw_radio_set_txpower_bg(sc, 0xffff, 0xffff, 0xffff);
	if (sc->sc_sprom.boardflags & BCW_BF_RSSI) {
		bcw_radio_calc_nrssi_slope(sc);
		bcw_radio_calc_nrssi_threshold(sc);
	}
	bcw_phy_init_pctl(sc);
}

void
bcw_phy_initb6(struct bcw_softc *sc)
{
	uint16_t offset, val;

	bcw_phy_write16(sc, 0x003e, 0x817a);
	bcw_radio_write16(sc, 0x007a, (bcw_radio_read16(sc, 0x007a) | 0x0058));

	if (sc->sc_radio_mnf == 0x17f && sc->sc_radio_ver == 0x2050 &&
	    (sc->sc_radio_rev == 3 || sc->sc_radio_rev == 4 ||
	    sc->sc_radio_rev == 5)) {
		bcw_radio_write16(sc, 0x0051, 0x001f);
		bcw_radio_write16(sc, 0x0052, 0x0040);
		bcw_radio_write16(sc, 0x0053, 0x005b);
		bcw_radio_write16(sc, 0x0054, 0x0098);
		bcw_radio_write16(sc, 0x005a, 0x0088);
		bcw_radio_write16(sc, 0x005b, 0x0088);
		bcw_radio_write16(sc, 0x005d, 0x0088);
		bcw_radio_write16(sc, 0x005e, 0x0088);
		bcw_radio_write16(sc, 0x007d, 0x0088);
	}

	if (sc->sc_radio_mnf == 0x17f && sc->sc_radio_ver == 0x2050 &&
	    sc->sc_radio_rev == 6) {
		bcw_radio_write16(sc, 0x0051, 0);
		bcw_radio_write16(sc, 0x0052, 0x0040);
		bcw_radio_write16(sc, 0x0053, 0x00b7);
		bcw_radio_write16(sc, 0x0054, 0x0098);
		bcw_radio_write16(sc, 0x005a, 0x0088);
		bcw_radio_write16(sc, 0x005b, 0x008b);
		bcw_radio_write16(sc, 0x005c, 0x00b5);
		bcw_radio_write16(sc, 0x005d, 0x0088);
		bcw_radio_write16(sc, 0x005e, 0x0088);
		bcw_radio_write16(sc, 0x007d, 0x0088);
		bcw_radio_write16(sc, 0x007c, 0x0001);
		bcw_radio_write16(sc, 0x007e, 0x0008);
	}

	if (sc->sc_radio_mnf == 0x017f && sc->sc_radio_ver == 0x2050 &&
	    sc->sc_radio_rev == 7) {
		bcw_radio_write16(sc, 0x0051, 0);
		bcw_radio_write16(sc, 0x0052, 0x0040);
		bcw_radio_write16(sc, 0x0053, 0x00b7);
		bcw_radio_write16(sc, 0x0054, 0x0098);
		bcw_radio_write16(sc, 0x005a, 0x0088);
		bcw_radio_write16(sc, 0x005b, 0x00a8);
		bcw_radio_write16(sc, 0x005c, 0x0075);
		bcw_radio_write16(sc, 0x005d, 0x00f5);
		bcw_radio_write16(sc, 0x005e, 0x00b8);
		bcw_radio_write16(sc, 0x007d, 0x00e8);
		bcw_radio_write16(sc, 0x007c, 0x0001);
		bcw_radio_write16(sc, 0x007e, 0x0008);
		bcw_radio_write16(sc, 0x007b, 0);
	}

	if (sc->sc_radio_mnf == 0x17f && sc->sc_radio_ver == 0x2050 &&
	    sc->sc_radio_rev == 8) {
		bcw_radio_write16(sc, 0x0051, 0);
		bcw_radio_write16(sc, 0x0052, 0x0040);
		bcw_radio_write16(sc, 0x0053, 0x00b7);
		bcw_radio_write16(sc, 0x0054, 0x0098);
		bcw_radio_write16(sc, 0x005a, 0x0088);
		bcw_radio_write16(sc, 0x005b, 0x006b);
		bcw_radio_write16(sc, 0x005c, 0x000f);
		if (sc->sc_sprom.boardflags & 0x8000) {
			bcw_radio_write16(sc, 0x005d, 0x00fa);
			bcw_radio_write16(sc, 0x005e, 0x00d8);
		} else {
			bcw_radio_write16(sc, 0x005d, 0x00f5);
			bcw_radio_write16(sc, 0x005e, 0x00b8);
		}
		bcw_radio_write16(sc, 0x0073, 0x0003);
		bcw_radio_write16(sc, 0x007d, 0x00a8);
		bcw_radio_write16(sc, 0x007c, 0x0001);
		bcw_radio_write16(sc, 0x007e, 0x0008);
	}

	val = 0x1e1f;
	for (offset = 0x0088; offset < 0x0098; offset++) {
		bcw_phy_write16(sc, offset, val);
		val -= 0x0202;
	}
	val = 0x3e3f;
	for (offset = 0x0098; offset < 0x00a8; offset++) {
		bcw_phy_write16(sc, offset, val);
		val -= 0x0202;
	}
	val = 0x2120;
	for (offset = 0x00a8; offset < 0x00c8; offset++) {
		bcw_phy_write16(sc, offset, (val & 0x3f3f));
		val += 0x0202;
	}

	if (sc->sc_phy_type == BCW_PHY_TYPEG) {
		bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) |
		    0x0020);
		bcw_radio_write16(sc, 0x0051, bcw_radio_read16(sc, 0x0051) |
		    0x0004);
		bcw_phy_write16(sc, 0x0802, bcw_phy_read16(sc, 0x0802) |
		    0x0100);
		bcw_phy_write16(sc, 0x042b, bcw_phy_read16(sc, 0x042b) |
		    0x2000);
	}

	/* force to channel 7, even if not supported */
	bcw_radio_select_channel(sc, 7, 0);

	bcw_radio_write16(sc, 0x0050, 0x0020);
	bcw_radio_write16(sc, 0x0050, 0x0023);
	delay(40);
	bcw_radio_write16(sc, 0x007c, (bcw_radio_read16(sc, 0x007c) |
	    0x0002));
	bcw_radio_write16(sc, 0x0050, 0x0020);
	if (sc->sc_radio_mnf == 0x17f && sc->sc_radio_ver == 0x2050 &&
	    sc->sc_radio_rev <= 2) {
		bcw_radio_write16(sc, 0x0050, 0x0020);
		bcw_radio_write16(sc, 0x005a, 0x0070);
		bcw_radio_write16(sc, 0x005b, 0x007b);
		bcw_radio_write16(sc, 0x005c, 0x00b0);
	}
	bcw_radio_write16(sc, 0x007a, (bcw_radio_read16(sc, 0x007a) & 0x00f8) |
	    0x0007);

	bcw_radio_select_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG, 0);
	
	bcw_phy_write16(sc, 0x0014, 0x0200);
	if (sc->sc_radio_ver == 0x2050) {
		if (sc->sc_radio_rev == 3 || sc->sc_radio_rev == 4 ||
		    sc->sc_radio_rev == 5)
			bcw_phy_write16(sc, 0x002a, 0x8ac0);
		else
			bcw_phy_write16(sc, 0x002a, 0x88c2);
	}
	bcw_phy_write16(sc, 0x0038, 0x0668);
	bcw_radio_set_txpower_bg(sc, 0xffff, 0xffff, 0xffff);
	if (sc->sc_radio_ver == 0x2050) {
		if (sc->sc_radio_rev == 3 || sc->sc_radio_rev == 4 ||
		    sc->sc_radio_rev == 5)
			bcw_phy_write16(sc, 0x005d,
			    bcw_phy_read16(sc, 0x005d) | 0x0003);
		else if (sc->sc_radio_rev <= 2)
			bcw_phy_write16(sc, 0x005d, 0x000d);
	}

	if (sc->sc_phy_rev == 4)
		bcw_phy_write16(sc, 0x0002, (bcw_phy_read16(sc, 0x0002) &
		    0xffc0) | 0x0004);
	else
		BCW_WRITE16(sc, 0x03e4, 0x0009);
	if (sc->sc_phy_type == BCW_PHY_TYPEB) {
		BCW_WRITE16(sc, 0x03e6, 0x8140);
		bcw_phy_write16(sc, 0x0016, 0x0410);
		bcw_phy_write16(sc, 0x0017, 0x0820);
		bcw_phy_write16(sc, 0x0062, 0x0007);
		(void)bcw_radio_calibrationvalue(sc);
		bcw_phy_lo_b_measure(sc);
		if (sc->sc_sprom.boardflags & BCW_BF_RSSI) {
			bcw_radio_calc_nrssi_slope(sc);
			bcw_radio_calc_nrssi_threshold(sc);
		}
		bcw_phy_init_pctl(sc);
	} else
		BCW_WRITE16(sc, 0x03e6, 0);
}

void
bcw_phy_inita(struct bcw_softc *sc)
{
	uint16_t tval;

	if (sc->sc_phy_type == BCW_PHY_TYPEA)
		bcw_phy_setupa(sc);
	else {
		bcw_phy_setupg(sc);
		if (sc->sc_sprom.boardflags & BCW_BF_PACTRL)
			bcw_phy_write16(sc, 0x046e, 0x03cf);
		return;
	}

	bcw_phy_write16(sc, BCW_PHY_A_CRS, (bcw_phy_read16(sc, BCW_PHY_A_CRS) &
	    0xf83c) | 0x0340);
	bcw_phy_write16(sc, 0x0034, 0x0001);

	bcw_phy_write16(sc, BCW_PHY_A_CRS, bcw_phy_read16(sc, BCW_PHY_A_CRS) |
	    (1 << 14));
	bcw_radio_init2060(sc);

	if (sc->sc_board_vendor == PCI_VENDOR_BROADCOM &&
	    (sc->sc_board_type == 0x0416 || sc->sc_board_type == 0x040a)) {
		if (sc->sc_radio_lofcal == 0xffff)
			bcw_radio_set_tx_iq(sc);
		else
			bcw_radio_write16(sc, 0x001e, sc->sc_radio_lofcal);
	}

	bcw_phy_write16(sc, 0x007a, 0xf111);

	if (sc->sc_phy_savedpctlreg == 0xffff) {
		bcw_radio_write16(sc, 0x0019, 0);
		bcw_radio_write16(sc, 0x0017, 0x0020);

		tval = bcw_ilt_read(sc, 0x3001);
		if (sc->sc_phy_rev == 1)
			bcw_ilt_write(sc, 0x3001, (bcw_ilt_read(sc, 0x3001) &
			    0xff87) | 0x0058);
		else
			bcw_ilt_write(sc, 0x3001, (bcw_ilt_read(sc, 0x3001) &
			    0xffc3) | 0x002c);
		bcw_dummy_transmission(sc);
		sc->sc_phy_savedpctlreg = bcw_phy_read16(sc, BCW_PHY_A_PCTL);
		bcw_ilt_write(sc, 0x3001, tval);

		bcw_radio_set_txpower_a(sc, 0x0018);
	}
	bcw_radio_clear_tssi(sc);
}

void
bcw_phy_setupa(struct bcw_softc *sc)
{
	uint16_t i;

	switch (sc->sc_phy_rev) {
	case 2:
		bcw_phy_write16(sc, 0x008e, 0x3800);
		bcw_phy_write16(sc, 0x0035, 0x03ff);
		bcw_phy_write16(sc, 0x0036, 0x0400);

		bcw_ilt_write(sc, 0x3807, 0x0051);

		bcw_phy_write16(sc, 0x001c, 0x0ff9);
		bcw_phy_write16(sc, 0x0020, bcw_phy_read16(sc, 0x0020) &
		    0xff0f);
		bcw_ilt_write(sc, 0x3c0c, 0x07bf);
		bcw_radio_write16(sc, 0x0002, 0x07bf);

		bcw_phy_write16(sc, 0x0024, 0x4680);
		bcw_phy_write16(sc, 0x0020, 0x0003);
		bcw_phy_write16(sc, 0x001d, 0x0f40);
		bcw_phy_write16(sc, 0x001f, 0x1c00);

		bcw_phy_write16(sc, 0x002a, (bcw_phy_read16(sc, 0x002a) &
		    0x00ff) | 0x0400);
		bcw_phy_write16(sc, 0x002b, bcw_phy_read16(sc, 0x002b) &
		    0xfbff);
		bcw_phy_write16(sc, 0x008e, 0x58c1);

		bcw_ilt_write(sc, 0x0803, 0x000f);
		bcw_ilt_write(sc, 0x0804, 0x001f);
		bcw_ilt_write(sc, 0x0805, 0x002a);
		bcw_ilt_write(sc, 0x0805, 0x0030);
		bcw_ilt_write(sc, 0x0807, 0x003a);

		bcw_ilt_write(sc, 0x0000, 0x0013);
		bcw_ilt_write(sc, 0x0001, 0x0013);
		bcw_ilt_write(sc, 0x0002, 0x0013);
		bcw_ilt_write(sc, 0x0003, 0x0013);
		bcw_ilt_write(sc, 0x0004, 0x0015);
		bcw_ilt_write(sc, 0x0005, 0x0015);
		bcw_ilt_write(sc, 0x0006, 0x0019);

		bcw_ilt_write(sc, 0x0404, 0x0003);
		bcw_ilt_write(sc, 0x0405, 0x0003);
		bcw_ilt_write(sc, 0x0406, 0x0007);

		for (i = 0; i < 16; i++)
			bcw_ilt_write(sc, 0x4000 + i, (0x8 + i) & 0x000f);

		bcw_ilt_write(sc, 0x3003, 0x1044);
		bcw_ilt_write(sc, 0x3004, 0x7201);
		bcw_ilt_write(sc, 0x3006, 0x0040);
		bcw_ilt_write(sc, 0x3001, (bcw_ilt_read(sc, 0x3001) & 0x0010) |
		    0x0008);

		for (i = 0; i < BCW_ILT_FINEFREQA_SIZE; i++)
			bcw_ilt_write(sc, 0x5800 + i, bcw_ilt_finefreqa[i]);

		for (i = 0; i < BCW_ILT_NOISEA2_SIZE; i++)
			bcw_ilt_write(sc, 0x1800 + i, bcw_ilt_noisea2[i]);

		for (i = 0; i < BCW_ILT_ROTOR_SIZE; i++)
			bcw_ilt_write(sc, 0x2000 + i, bcw_ilt_rotor[i]);

		bcw_phy_init_noisescaletbl(sc);
		for (i = 0; i < BCW_ILT_RETARD_SIZE; i++)
			bcw_ilt_write(sc, 0x2400 + i, bcw_ilt_retard[i]);

		break;
	case 3:
		for (i = 0; i< 64; i++)
			bcw_ilt_write(sc, 0x4000 + i, i);

		bcw_ilt_write(sc, 0x3807, 0x0051);

		bcw_phy_write16(sc, 0x001c, 0x0ff9);
		bcw_phy_write16(sc, 0x0020, bcw_phy_read16(sc, 0x0020) &
		    0x0ff0f);
		bcw_radio_write16(sc, 0x0002, 0x07bf);

		bcw_phy_write16(sc, 0x0024, 0x4680);
		bcw_phy_write16(sc, 0x0020, 0x0003);
		bcw_phy_write16(sc, 0x001d, 0x0f40);
		bcw_phy_write16(sc, 0x001f, 0x1c00);
		bcw_phy_write16(sc, 0x002a, (bcw_phy_read16(sc, 0x002a) &
		    0x00ff) | 0x0400);
		bcw_ilt_write(sc, 0x3001, (bcw_ilt_read(sc, 0x3001) &
		    0x0010) | 0x0008);
		for (i = 0; i < BCW_ILT_NOISEA3_SIZE; i++)
			bcw_ilt_write(sc, 0x1800 + i, bcw_ilt_noisea3[i]);

		bcw_phy_init_noisescaletbl(sc);
		for (i = 0; i < BCW_ILT_SIGMASQR_SIZE; i++)
			bcw_ilt_write(sc, 0x5000 + i, bcw_ilt_sigmasqr1[i]);

		bcw_phy_write16(sc, 0x0003, 0x1808);

		bcw_ilt_write(sc, 0x0803, 0x000f);
		bcw_ilt_write(sc, 0x0804, 0x001f);
		bcw_ilt_write(sc, 0x0805, 0x002a);
		bcw_ilt_write(sc, 0x0805, 0x0030);
		bcw_ilt_write(sc, 0x0807, 0x003a);

		bcw_ilt_write(sc, 0x0000, 0x0013);
		bcw_ilt_write(sc, 0x0001, 0x0013);
		bcw_ilt_write(sc, 0x0002, 0x0013);
		bcw_ilt_write(sc, 0x0003, 0x0013);
		bcw_ilt_write(sc, 0x0004, 0x0015);
		bcw_ilt_write(sc, 0x0005, 0x0015);
		bcw_ilt_write(sc, 0x0006, 0x0019);

		bcw_ilt_write(sc, 0x0404, 0x0003);
		bcw_ilt_write(sc, 0x0405, 0x0003);
		bcw_ilt_write(sc, 0x0406, 0x0007);

		bcw_ilt_write(sc, 0x3c02, 0x000f);
		bcw_ilt_write(sc, 0x3c03, 0x0014);
		break;
	default:
		/* XXX panic()? */
		break;
	}
}

void
bcw_phy_setupg(struct bcw_softc *sc)
{
	uint16_t i;

	if (sc->sc_phy_rev == 1) {
		bcw_phy_write16(sc, 0x0406, 0x4f19);
		bcw_phy_write16(sc, BCW_PHY_G_CRS, (bcw_phy_read16(sc,
		    BCW_PHY_G_CRS) & 0xfc3f) | 0x0340);
		bcw_phy_write16(sc, 0x042c, 0x005a);
		bcw_phy_write16(sc, 0x0427, 0x001a);

		for (i = 0; i < BCW_ILT_FINEFREQG_SIZE; i++)
			bcw_ilt_write(sc, 0x5800 + i, bcw_ilt_finefreqg[i]);

		for (i = 0; i < BCW_ILT_NOISEG1_SIZE; i++)
			bcw_ilt_write(sc, 0x1800 + i, bcw_ilt_noiseg1[i]);

		for (i = 0; i < BCW_ILT_ROTOR_SIZE; i++)
			bcw_ilt_write(sc, 0x2000 + i, bcw_ilt_rotor[i]);
	} else {
		bcw_radio_nrssi_hw_write(sc, 0xba98, (int16_t) 0x7654);

		if (sc->sc_phy_type == 2) {
			bcw_phy_write16(sc, 0x04c0, 0x1861);
			bcw_phy_write16(sc, 0x04c1, 0x0271);
		} else {
			bcw_phy_write16(sc, 0x04c0, 0x0098);
			bcw_phy_write16(sc, 0x04c1, 0x0070);
			bcw_phy_write16(sc, 0x04c9, 0x0080);
		}
		bcw_phy_write16(sc, 0x042b, bcw_phy_read16(sc, 0x042b) |
		    0x0800);

		for (i = 0; i < 64; i++)
			bcw_ilt_write(sc, 0x4000 + i, i);
		for (i = 0; i < BCW_ILT_NOISEG2_SIZE; i++)
			bcw_ilt_write(sc, 0x1800 + i, bcw_ilt_noiseg2[i]);
	}

	if (sc->sc_phy_rev <= 2)
		for (i = 0; i < BCW_ILT_NOISESCALEG_SIZE; i++)
			bcw_ilt_write(sc, 0x1400 + i, bcw_ilt_noisescaleg1[i]);
	else if ((sc->sc_phy_rev >= 7) && (bcw_phy_read16(sc, 0x0449) & 0x0200))
		for (i = 0; i < BCW_ILT_NOISESCALEG_SIZE; i++)
			bcw_ilt_write(sc, 0x1400 + i, bcw_ilt_noisescaleg3[i]);
	else
		for (i = 0; i < BCW_ILT_NOISESCALEG_SIZE; i++)
			bcw_ilt_write(sc, 0x1400 + i, bcw_ilt_noisescaleg2[i]);

	if (sc->sc_phy_rev == 2)
		for (i = 0; i < BCW_ILT_SIGMASQR_SIZE; i++)
			bcw_ilt_write(sc, 0x5000 + i, bcw_ilt_sigmasqr1[i]);
	else if ((sc->sc_phy_rev > 2) && (sc->sc_phy_rev <= 8))
		for (i = 0; i < BCW_ILT_SIGMASQR_SIZE; i++)
			bcw_ilt_write(sc, 0x5000 + i, bcw_ilt_sigmasqr2[i]);

	if (sc->sc_phy_rev == 1) {
		for (i = 0; i < BCW_ILT_RETARD_SIZE; i++)
			bcw_ilt_write(sc, 0x2400 + i, bcw_ilt_retard[i]);
		for (i = 0; i < 4; i++) {
			bcw_ilt_write(sc, 0x5404 + i, 0x0020);
			bcw_ilt_write(sc, 0x5408 + i, 0x0020);
			bcw_ilt_write(sc, 0x540c + i, 0x0020);
			bcw_ilt_write(sc, 0x5410 + i, 0x0020);
		}
		bcw_phy_agcsetup(sc);

		if (sc->sc_board_vendor == PCI_VENDOR_BROADCOM &&
		    sc->sc_board_type == 0x0416 &&
		    sc->sc_board_rev == 0x0017)
			return;

		bcw_ilt_write(sc, 0x5001, 0x0002);
		bcw_ilt_write(sc, 0x5002, 0x0001);
	} else {
		for (i = 0; i <= 0x2f; i++)
			bcw_ilt_write(sc, 0x1000 +  i, 0x0820);
		bcw_phy_agcsetup(sc);
		bcw_phy_read16(sc, 0x0400);
		bcw_phy_write16(sc, 0x0403, 0x1000);
		bcw_ilt_write(sc, 0x3c02, 0x000f);
		bcw_ilt_write(sc, 0x3c03, 0x0014);

		if (sc->sc_board_vendor == PCI_VENDOR_BROADCOM &&
		    sc->sc_board_type == 0x0416 &&
		    sc->sc_board_rev == 0x0017)
			return;

		bcw_ilt_write(sc, 0x0401, 0x0002);
		bcw_ilt_write(sc, 0x0402, 0x0001);
	}
}

void
bcw_phy_calc_loopback_gain(struct bcw_softc *sc)
{
	uint16_t backup_phy[15];
	uint16_t backup_radio[3];
	uint16_t backup_bband;
	uint16_t i;
	uint16_t loop1_cnt, loop1_done, loop1_omitted;
	uint16_t loop2_done;

	backup_phy[0]  = bcw_phy_read16(sc, 0x0429);
	backup_phy[1]  = bcw_phy_read16(sc, 0x0001);
	backup_phy[2]  = bcw_phy_read16(sc, 0x0811);
	backup_phy[3]  = bcw_phy_read16(sc, 0x0812);
	backup_phy[4]  = bcw_phy_read16(sc, 0x0814);
	backup_phy[5]  = bcw_phy_read16(sc, 0x0815);
	backup_phy[6]  = bcw_phy_read16(sc, 0x005a);
	backup_phy[7]  = bcw_phy_read16(sc, 0x0059);
	backup_phy[8]  = bcw_phy_read16(sc, 0x0058);
	backup_phy[9]  = bcw_phy_read16(sc, 0x000a);
	backup_phy[10] = bcw_phy_read16(sc, 0x0003);
	backup_phy[11] = bcw_phy_read16(sc, 0x080f);
	backup_phy[12] = bcw_phy_read16(sc, 0x0810);
	backup_phy[13] = bcw_phy_read16(sc, 0x002b);
	backup_phy[14] = bcw_phy_read16(sc, 0x0015);
	bcw_phy_read16(sc, 0x002d);
	backup_bband = sc->sc_radio_baseband_atten;
	backup_radio[0] = bcw_radio_read16(sc, 0x0052);
	backup_radio[1] = bcw_radio_read16(sc, 0x0043);
	backup_radio[2] = bcw_radio_read16(sc, 0x007a);

	bcw_phy_write16(sc, 0x0429, bcw_phy_read16(sc, 0x0429) & 0x3fff);
	bcw_phy_write16(sc, 0x0001, bcw_phy_read16(sc, 0x0001) & 0x8000);
	bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) & 0x0002);
	bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) & 0xfffd);
	bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) & 0x0001);
	bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) & 0xfffe);
	bcw_phy_write16(sc, 0x0814, bcw_phy_read16(sc, 0x0814) & 0x0001);
	bcw_phy_write16(sc, 0x0815, bcw_phy_read16(sc, 0x0815) & 0xfffe);
	bcw_phy_write16(sc, 0x0814, bcw_phy_read16(sc, 0x0814) & 0x0002);
	bcw_phy_write16(sc, 0x0815, bcw_phy_read16(sc, 0x0815) & 0xfffd);
	bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) & 0x000c);
	bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) & 0x000c);

	bcw_phy_write16(sc, 0x0811, (bcw_phy_read16(sc, 0x0811) & 0xffcf) |
	    0x0030);
	bcw_phy_write16(sc, 0x0812, (bcw_phy_read16(sc, 0x0812) & 0xffcf) |
	    0x0010);

	bcw_phy_write16(sc, 0x005a, 0x0780);
	bcw_phy_write16(sc, 0x0059, 0xc810);
	bcw_phy_write16(sc, 0x0058, 0x000d);
	if (sc->sc_phy_ver == 9)
		bcw_phy_write16(sc, 0x0003, 0x0122);
	else
		bcw_phy_write16(sc, 0x000a, bcw_phy_read16(sc, 0x000a) |
		    0x2000);
	bcw_phy_write16(sc, 0x0814, bcw_phy_read16(sc, 0x0814) | 0x0004);
	bcw_phy_write16(sc, 0x0815, bcw_phy_read16(sc, 0x0815) & 0xfffb);
	bcw_phy_write16(sc, 0x0003, (bcw_phy_read16(sc, 0x0003) & 0xff9f) |
	    0x0040);
	if (sc->sc_radio_ver == 0x2050 && sc->sc_radio_rev == 2) {
		bcw_radio_write16(sc, 0x0052, 0x0000);
		bcw_radio_write16(sc, 0x0043, (bcw_radio_read16(sc, 0x0043) &
		    0xfff0) | 0x0009);
		loop1_cnt = 9;
	} else if (sc->sc_radio_rev == 8) {
		bcw_radio_write16(sc, 0x0043, 0x000f);
		loop1_cnt = 15;
	} else
		loop1_cnt = 0;

	bcw_phy_set_baseband_atten(sc, 11);

	if (sc->sc_phy_rev >= 3)
		bcw_phy_write16(sc, 0x080f, 0xc020);
	else
		bcw_phy_write16(sc, 0x080f, 0x8020);
	bcw_phy_write16(sc, 0x0810, 0x0000);

	bcw_phy_write16(sc, 0x002b, (bcw_phy_read16(sc, 0x002b) & 0xffc0) |
	    0x0001);
	bcw_phy_write16(sc, 0x002b, (bcw_phy_read16(sc, 0x002b) & 0xc0ff) |
	    0x0800);
	bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) | 0x0100);
	bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) | 0xcfff);
	if (sc->sc_sprom.boardflags & BCW_BF_EXTLNA) {
		if (sc->sc_phy_rev >= 7) {
			bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) |
			    0x0800);
			bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) |
			    0x8000);
		}
	}
	bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) & 0x00f7);

	for (i = 0; i < loop1_cnt; i++) {
		bcw_radio_write16(sc, 0x0043, loop1_cnt);
		bcw_phy_write16(sc, 0x0812, (bcw_phy_read16(sc, 0x0812) &
		    0xf0ff) | (i << 8));
		bcw_phy_write16(sc, 0x0015, (bcw_phy_read16(sc, 0x0015) &
		    0x0fff) | 0xa000);
		bcw_phy_write16(sc, 0x0015, (bcw_phy_read16(sc, 0x0015) &
		    0x0fff) | 0xf000);
		delay(20);
		if (bcw_phy_read16(sc, 0x0002d) >= 0x0dfc)
			break;
	}
	loop1_done = i;
	loop1_omitted = loop1_cnt - loop1_done;

	loop2_done = 0;
	if (loop1_done >= 8) {
		bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) |
		    0x0030);
		for (i = loop1_done - 8; i < 16; i++) {
			bcw_phy_write16(sc, 0x0812,
			    (bcw_phy_read16(sc, 0x0812) & 0xf0ff) | (i << 8));
			bcw_phy_write16(sc, 0x0015,
			    (bcw_phy_read16(sc, 0x0015) & 0x0fff) | 0xa000);
			bcw_phy_write16(sc, 0x0015,
			    (bcw_phy_read16(sc, 0x0015) & 0x0fff) | 0xf000);
			delay(20);
			if (bcw_phy_read16(sc, 0x002d) >= 0x0dfc)
				break;
		}
	}

	bcw_phy_write16(sc, 0x0814, backup_phy[4]);
	bcw_phy_write16(sc, 0x0815, backup_phy[5]);
	bcw_phy_write16(sc, 0x005a, backup_phy[6]);
	bcw_phy_write16(sc, 0x0059, backup_phy[7]);
	bcw_phy_write16(sc, 0x0058, backup_phy[8]);
	bcw_phy_write16(sc, 0x000a, backup_phy[9]);
	bcw_phy_write16(sc, 0x0003, backup_phy[10]);
	bcw_phy_write16(sc, 0x080f, backup_phy[11]);
	bcw_phy_write16(sc, 0x0810, backup_phy[12]);
	bcw_phy_write16(sc, 0x002b, backup_phy[13]);
	bcw_phy_write16(sc, 0x0015, backup_phy[14]);

	bcw_phy_set_baseband_atten(sc, backup_bband);

	bcw_radio_write16(sc, 0x0052, backup_radio[0]);
	bcw_radio_write16(sc, 0x0043, backup_radio[1]);
	bcw_radio_write16(sc, 0x007a, backup_radio[2]);

	bcw_phy_write16(sc, 0x0811, backup_phy[2] | 0x0003);
	delay(10);
	bcw_phy_write16(sc, 0x0811, backup_phy[2]);
	bcw_phy_write16(sc, 0x0812, backup_phy[3]);
	bcw_phy_write16(sc, 0x0429, backup_phy[0]);
	bcw_phy_write16(sc, 0x0001, backup_phy[1]);

	sc->sc_phy_loopback_gain[0] = ((loop1_done * 6) - (loop1_omitted * 4))
	    - 11;
	sc->sc_phy_loopback_gain[1] = (24 - (3 * loop2_done)) * 2; 
}

void
bcw_phy_agcsetup(struct bcw_softc *sc)
{
	uint16_t offset = 0;

	if (sc->sc_phy_rev == 1)
		offset = 0x4c00;

	bcw_ilt_write(sc, offset, 0x00fe);
	bcw_ilt_write(sc, offset + 1, 0x000d);
	bcw_ilt_write(sc, offset + 2, 0x0013);
	bcw_ilt_write(sc, offset + 3, 0x0019);

	if (sc->sc_phy_rev == 1) {
		bcw_ilt_write(sc, 0x1800, 0x2710);
		bcw_ilt_write(sc, 0x1801, 0x9b83);
		bcw_ilt_write(sc, 0x1802, 0x9b83);
		bcw_ilt_write(sc, 0x1803, 0x0f8d);
		bcw_phy_write16(sc, 0x0455, 0x0004);
	}

	bcw_phy_write16(sc, 0x04a5, (bcw_phy_read16(sc, 0x04a5) & 0x00ff) |
	    0x5700);
	bcw_phy_write16(sc, 0x041a, (bcw_phy_read16(sc, 0x041a) & 0xff80) |
	    0x000f);
	bcw_phy_write16(sc, 0x041a, (bcw_phy_read16(sc, 0x041a) & 0xc07f) |
	    0x2b80);
	bcw_phy_write16(sc, 0x048c, (bcw_phy_read16(sc, 0x048c) & 0xf0ff) |
	    0x0300);

	bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) | 0x0008);

	bcw_phy_write16(sc, 0x04a0, (bcw_phy_read16(sc, 0x04a0) & 0xfff0) |
	    0x0008);
	bcw_phy_write16(sc, 0x04a1, (bcw_phy_read16(sc, 0x04a1) & 0xf0ff) |
	    0x0600);
	bcw_phy_write16(sc, 0x04a2, (bcw_phy_read16(sc, 0x04a2) & 0xf0ff) |
	    0x0700);
	bcw_phy_write16(sc, 0x04a0, (bcw_phy_read16(sc, 0x04a0) & 0xf0ff) |
	    0x0100);

	if (sc->sc_phy_rev == 1)
		bcw_phy_write16(sc, 0x04a2, (bcw_phy_read16(sc, 0x4a2) &
		    0xfff0) | 0x0007);

	bcw_phy_write16(sc, 0x0488, (bcw_phy_read16(sc, 0x0488) & 0xff00) |
	    0x001c);
	bcw_phy_write16(sc, 0x0488, (bcw_phy_read16(sc, 0x0488) & 0xc0ff) |
	    0x0200);
	bcw_phy_write16(sc, 0x0496, (bcw_phy_read16(sc, 0x0496) & 0xff00) |
	    0x001c);
	bcw_phy_write16(sc, 0x0489, (bcw_phy_read16(sc, 0x0489) & 0xff00) |
	    0x0020);
	bcw_phy_write16(sc, 0x0489, (bcw_phy_read16(sc, 0x0489) & 0xc0ff) |
	    0x0200);
	bcw_phy_write16(sc, 0x0482, (bcw_phy_read16(sc, 0x0482) & 0xff00) |
	    0x001c);
	bcw_phy_write16(sc, 0x0496, (bcw_phy_read16(sc, 0x0496) & 0x00ff) |
	    0x1a00);
	bcw_phy_write16(sc, 0x0481, (bcw_phy_read16(sc, 0x0481) & 0xff00) |
	    0x0028);
	bcw_phy_write16(sc, 0x0481, (bcw_phy_read16(sc, 0x0481) & 0x00ff) |
	    0x2c00);

	if (sc->sc_phy_rev == 1) {
		bcw_phy_write16(sc, 0x0430, 0x092b);
		bcw_phy_write16(sc, 0x041b, (bcw_phy_read16(sc, 0x041b) &
		    0xffe1) | 0x0002);
	} else {
		bcw_phy_write16(sc, 0x041b, bcw_phy_read16(sc, 0x41b) &
		    0xffe1);
		bcw_phy_write16(sc, 0x041f, 0x287a);
		bcw_phy_write16(sc, 0x0420, (bcw_phy_read16(sc, 0x0420) &
		    0xfff0) | 0x0004);
	}

	if (sc->sc_phy_rev > 2) {
		bcw_phy_write16(sc, 0x0422, 0x287a);
		bcw_phy_write16(sc, 0x0420, (bcw_phy_read16(sc, 0x0420) &
		   0x0fff) | 0x3000);
	}

	bcw_phy_write16(sc, 0x04a8, (bcw_phy_read16(sc, 0x04a8) & 0x8080) |
	    0x7874);
	bcw_phy_write16(sc, 0x048e, 0x1c00);

	if (sc->sc_phy_rev == 1) {
		bcw_phy_write16(sc, 0x04ab, (bcw_phy_read16(sc, 0x04ab) &
		    0xf0ff) | 0x0600);
		bcw_phy_write16(sc, 0x048b, 0x005e);
		bcw_phy_write16(sc, 0x048c, (bcw_phy_read16(sc, 0x048c) &
		    0xff00) | 0x001e);
		bcw_phy_write16(sc, 0x048d, 0x0002);
	}

	bcw_ilt_write(sc, offset + 0x0800, 0);
	bcw_ilt_write(sc, offset + 0x0801, 7);
	bcw_ilt_write(sc, offset + 0x0802, 16);
	bcw_ilt_write(sc, offset + 0x0803, 28);
}

void
bcw_phy_init_pctl(struct bcw_softc *sc)
{
	uint16_t saved_batt = 0, saved_ratt = 0, saved_txctl1 = 0;
	int must_reset_txpower = 0;

	if (sc->sc_board_vendor == PCI_VENDOR_BROADCOM &&
	    sc->sc_board_type == 0x0416)
		return;

	BCW_WRITE16(sc, 0x03e6, BCW_READ16(sc, 0x03e6) & 0xffdf);
	bcw_phy_write16(sc, 0x0028, 0x8018);

	if (sc->sc_phy_type == BCW_PHY_TYPEG) {
		if (!sc->sc_phy_connected)
			return;
		bcw_phy_write16(sc, 0x047a, 0xc111);
	}
	if (sc->sc_phy_savedpctlreg != 0xffff)
		return;

	if (sc->sc_phy_type == BCW_PHY_TYPEB &&
	    sc->sc_phy_rev >= 2 &&
	    sc->sc_radio_ver == 0x2050) {
		bcw_radio_write16(sc, 0x0076, bcw_radio_read16(sc, 0x0076) |
		    0x0084);
	} else {
		saved_batt = sc->sc_radio_baseband_atten;
		saved_ratt = sc->sc_radio_radio_atten;
		saved_txctl1 = sc->sc_radio_txctl1;
		if ((sc->sc_radio_rev >= 6) && (sc->sc_radio_rev <= 8))
			bcw_radio_set_txpower_bg(sc, 0xb, 0x1f, 0);
		else
			bcw_radio_set_txpower_bg(sc, 0xb, 9, 0);
		must_reset_txpower = 1;
	}
	bcw_dummy_transmission(sc);

	sc->sc_phy_savedpctlreg = bcw_phy_read16(sc, BCW_PHY_G_PCTL);

	if (must_reset_txpower)
		bcw_radio_set_txpower_bg(sc, saved_batt, saved_ratt,
		    saved_txctl1);
	else
		bcw_radio_write16(sc, 0x0076, bcw_radio_read16(sc, 0x0076) &
		    0xff7b);
	bcw_radio_clear_tssi(sc);
}

void
bcw_phy_init_noisescaletbl(struct bcw_softc *sc)
{
	int i;

	bcw_phy_write16(sc, BCW_PHY_ILT_A_CTRL, 0x1400);
	for (i = 0; i < 12; i++) {
		if (sc->sc_phy_rev == 2)
			bcw_phy_write16(sc, BCW_PHY_ILT_A_DATA1, 0x6767);
		else
			bcw_phy_write16(sc, BCW_PHY_ILT_A_DATA1, 0x2323);
	}

	if (sc->sc_phy_rev == 2)
		bcw_phy_write16(sc, BCW_PHY_ILT_A_DATA1, 0x6700);
	else
		bcw_phy_write16(sc, BCW_PHY_ILT_A_DATA1, 0x2300);

	for (i = 0; i < 11; i++) {
		if (sc->sc_phy_rev == 2)
			bcw_phy_write16(sc, BCW_PHY_ILT_A_DATA1, 0x6767);
		else
			bcw_phy_write16(sc, BCW_PHY_ILT_A_DATA1, 0x0023);
	}

	if (sc->sc_phy_rev == 2)
		bcw_phy_write16(sc, BCW_PHY_ILT_A_DATA1, 0x0067);
	else
		bcw_phy_write16(sc, BCW_PHY_ILT_A_DATA1, 0x0023);
}

void
bcw_phy_set_baseband_atten(struct bcw_softc *sc,
    uint16_t baseband_atten)
{
	uint16_t val;

	if (sc->sc_phy_ver == 0) {
		val = (BCW_READ16(sc, 0x03e6) & 0xfff0);
		val |= (baseband_atten & 0x000f);
		BCW_WRITE16(sc, 0x03e6, val);
		return;
	}

	if (sc->sc_phy_ver > 1) {
		val = bcw_phy_read16(sc, 0x0060) & ~0x003c;
		val |= (baseband_atten << 2) & 0x003c;
	} else {
		val = bcw_phy_read16(sc, 0x0060) & ~0x0078;
		val |= (baseband_atten << 3) & 0x0078;
	}
	bcw_phy_write16(sc, 0x0060, val);
}

int8_t
bcw_phy_estimate_powerout(struct bcw_softc *sc, int8_t tssi)
{
	int8_t dbm = 0;
	int32_t tmp;

	tmp = sc->sc_phy_idle_tssi;
	tmp += tssi;
	tmp -= sc->sc_phy_savedpctlreg;

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		tmp += 0x80;
		tmp = bcw_lv(tmp, 0x00, 0xff);
		//dbm = sc->sc_phy_tssi2dbm[tmp]; /* XXX */
		break;
	case BCW_PHY_TYPEB:
	case BCW_PHY_TYPEG:
		tmp = bcw_lv(tmp, 0x00, 0x3f);
		//dbm = sc->sc_phy_tssi2dbm[tmp]; /* XXX "/
		break;
	default:
		/* XXX panic()? */
		break;
	}

	return (dbm);
}

void
bcw_phy_xmitpower(struct bcw_softc *sc)
{
	if (sc->sc_phy_savedpctlreg == 0xffff)
		return;
	if (sc->sc_board_type == 0x0416 &&
	    sc->sc_board_vendor == PCI_VENDOR_BROADCOM)
		return;

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		/* nohting todo for A PHYs yet */
		break;
	case BCW_PHY_TYPEB:
	case BCW_PHY_TYPEG: {
		uint16_t tmp;
		uint16_t txpower;
		int8_t v0, v1, v2, v3;
		int8_t average;
		uint8_t max_pwr;
		int16_t desired_pwr, estimated_pwr, pwr_adjust;
		int16_t radio_att_delta, baseband_att_delta;
		int16_t radio_attenuation, baseband_attenuation;

		tmp = bcw_shm_read16(sc, BCW_SHM_SHARED, 0x0058);
		v0 = (int8_t)(tmp & 0x00ff);
		v1 = (int8_t)((tmp & 0xff00) >> 8);
		tmp = bcw_shm_read16(sc, BCW_SHM_SHARED, 0x005a);
		v2 = (int8_t)(tmp & 0x00ff);
		v3 = (int8_t)((tmp & 0xff00) >> 8);
		tmp = 0;

		if (v0 == 0x7f || v1 == 0x7f || v2 == 0x7f || v3 == 0x07) {
			tmp = bcw_shm_read16(sc, BCW_SHM_SHARED,
			    0x0070);
			v0 = (int8_t)(tmp & 0x00ff);
			v1 = (int8_t)((tmp & 0xff00) >> 8);
			tmp = bcw_shm_read16(sc, BCW_SHM_SHARED,
			    0x0072);

			v2 = (int8_t)(tmp & 0x00ff);
			v3 = (int8_t)((tmp & 0xff00) >> 8);
			if (v0 == 0x7f || v1 == 0x7f || v2 == 0x7f ||
			    v3 == 0x7f)
				return;
			v0 = (v0 + 0x20) & 0x3f;
			v1 = (v1 + 0x20) & 0x3f;
			v2 = (v2 + 0x20) & 0x3f;
			v3 = (v3 + 0x20) & 0x3f;
			tmp = 1;
		}
		bcw_radio_clear_tssi(sc);

		average = (v0 + v1 + v2 + v3 + 2) / 4;

		if (tmp && (bcw_shm_read16(sc, BCW_SHM_SHARED, 0x005e) &
		    0x8))
			average -= 13;

		bcw_phy_estimate_powerout(sc, average);

		if ((sc->sc_sprom.boardflags & BCW_BF_PACTRL) &&
		    (sc->sc_phy_type == BCW_PHY_TYPEG))
			max_pwr -= 0x3;

		desired_pwr = bcw_lv(sc->sc_radio_txpower_desired, 0, max_pwr);
		/* check if we need to adjust the current power */
		pwr_adjust = desired_pwr - estimated_pwr;
		radio_att_delta = -(pwr_adjust + 7) >> 3;
		baseband_att_delta = -(pwr_adjust >> 1) - (4 * radio_att_delta);
		if ((radio_att_delta == 0) && (baseband_att_delta == 0)) {
			bcw_phy_lo_mark_current_used(sc);
			return;
		}

		/* calculate the new attenuation values */
		baseband_attenuation = sc->sc_radio_baseband_atten;
		baseband_attenuation += baseband_att_delta;
		radio_attenuation = sc->sc_radio_radio_atten;
		radio_attenuation += radio_att_delta;

		if (radio_attenuation < 0) {
			baseband_attenuation -= (4 * -radio_attenuation);
			radio_attenuation = 0;
		} else if (radio_attenuation > 9) {
			baseband_attenuation += (4 * (radio_attenuation - 9));
			radio_attenuation = 9;
		} else {
			while (baseband_attenuation < 0 &&
			    radio_attenuation > 0) {
				baseband_attenuation += 4;
				radio_attenuation--;
			}
			while (baseband_attenuation > 11 &&
			    radio_attenuation < 9) {
				baseband_attenuation -= 4;
				radio_attenuation++;
			}
		}
		baseband_attenuation = bcw_lv(baseband_attenuation, 0, 11);

		txpower = sc->sc_radio_txctl1;
		if ((sc->sc_radio_ver == 0x02050) && (sc->sc_radio_rev == 2)) {
			if (radio_attenuation <= 1) {
				if (txpower == 0) {
					txpower = 3;
					radio_attenuation += 2;
					baseband_attenuation += 2;
				} else if (sc->sc_sprom.boardflags &
				    BCW_BF_PACTRL) {
					baseband_attenuation += 4 *
					    (radio_attenuation - 2);
					radio_attenuation = 2;
				}
			} else if (radio_attenuation > 4 && txpower != 0) {
				txpower = 0;
				if (baseband_attenuation < 3) {
					radio_attenuation -= 3;
					baseband_attenuation += 2;
				} else {
					radio_attenuation -= 2;
					baseband_attenuation -= 2;
				}
			}
		}
		sc->sc_radio_txctl1 = txpower;
		baseband_attenuation = bcw_lv(baseband_attenuation, 0, 11);
		radio_attenuation = bcw_lv(radio_attenuation, 0, 9);

		bcw_phy_lock(sc);
		bcw_radio_lock(sc);
		bcw_radio_set_txpower_bg(sc, baseband_attenuation,
		    radio_attenuation, txpower);
		bcw_phy_lo_mark_current_used(sc);
		bcw_radio_unlock(sc);
		bcw_phy_unlock(sc);
		break;
	}
	default:
		/* XXX panic()? */
		break;
	}
}

uint16_t
bcw_phy_lo_b_r15_loop(struct bcw_softc *sc)
{
	int i;
	uint16_t r = 0;

	/* XXX splnet()? */
	for (i = 0; i < 10; i++) {
		bcw_phy_write16(sc, 0x0015, 0xafa0);
		delay(1);
		bcw_phy_write16(sc, 0x0015, 0xefa0);
		delay(10);
		bcw_phy_write16(sc, 0x0015, 0xffa0);
		delay(40);
		r += bcw_phy_read16(sc, 0x002c);
	}
	/* XXX splnet()? */

	return (r);
}

void
bcw_phy_lo_b_measure(struct bcw_softc *sc)
{
	uint16_t regstack[12] = { 0 };
	uint16_t mls;
	uint16_t fval;
	int i, j;

	regstack[0] = bcw_phy_read16(sc, 0x0015);
	regstack[1] = bcw_radio_read16(sc, 0x0052) & 0xfff0;

	if (sc->sc_radio_ver == 0x2053) {
		regstack[2]  = bcw_phy_read16(sc, 0x000a);
		regstack[3]  = bcw_phy_read16(sc, 0x002a);
		regstack[4]  = bcw_phy_read16(sc, 0x0035);
		regstack[5]  = bcw_phy_read16(sc, 0x0003);
		regstack[6]  = bcw_phy_read16(sc, 0x0001);
		regstack[7]  = bcw_phy_read16(sc, 0x0030);

		regstack[8]  = bcw_radio_read16(sc, 0x0043);
		regstack[9]  = bcw_radio_read16(sc, 0x007a);
		regstack[10] = BCW_READ16(sc, 0x03ec);
		regstack[11] = bcw_radio_read16(sc, 0x0052) & 0x00f0;

		bcw_phy_write16(sc, 0x0030, 0x00ff);
		BCW_WRITE16(sc, 0x3ec, 0x3f3f);
		bcw_phy_write16(sc, 0x0035, regstack[4] & 0xff7f);
		bcw_radio_write16(sc, 0x007a, regstack[9] & 0xfff0);
	}
	bcw_phy_write16(sc, 0x0015, 0xb000);
	bcw_phy_write16(sc, 0x002b, 0x0004);

	if (sc->sc_radio_ver == 0x2053) {
		bcw_phy_write16(sc, 0x002b, 0x0203);
		bcw_phy_write16(sc, 0x002a, 0x08a3);
	}

	sc->sc_phy_minlowsig[0] = 0xffff;

	for (i = 0; i < 4; i++) {
		bcw_radio_write16(sc, 0x0052, regstack[1] | i);
		bcw_phy_lo_b_r15_loop(sc);
	}
	for (i = 0; i < 10; i++) {
		bcw_radio_write16(sc, 0x0052, regstack[1] | i);
		mls = bcw_phy_lo_b_r15_loop(sc) / 10;
		if (mls < sc->sc_phy_minlowsig[0]) {
			sc->sc_phy_minlowsig[0] = mls;
			sc->sc_phy_minlowsigpos[0] = i;
		}
	}
	bcw_radio_write16(sc, 0x0052, regstack[1] | sc->sc_phy_minlowsigpos[0]);

	sc->sc_phy_minlowsig[1] = 0xffff;

	for (i = -4; i < 5; i += 2) {
		for (j = -4; j < 5; j += 2) {
			if (j < 0)
				fval = (0x0100 * i) + j + 0x0100;
			else
				fval = (0x0100 * i) + j;
			bcw_phy_write16(sc, 0x002f, fval);
			mls = bcw_phy_lo_b_r15_loop(sc) / 10;
			if (mls < sc->sc_phy_minlowsig[1]) {
				sc->sc_phy_minlowsig[1] = mls;
				sc->sc_phy_minlowsigpos[1] = fval;
			}
		}
	}
	sc->sc_phy_minlowsigpos[1] += 0x0101;

	bcw_phy_write16(sc, 0x002f, sc->sc_phy_minlowsigpos[1]);
	if (sc->sc_radio_ver == 0x2053) {
		bcw_phy_write16(sc, 0x000a, regstack[2]);
		bcw_phy_write16(sc, 0x002a, regstack[3]);
		bcw_phy_write16(sc, 0x0035, regstack[4]);
		bcw_phy_write16(sc, 0x0003, regstack[5]);
		bcw_phy_write16(sc, 0x0001, regstack[6]);
		bcw_phy_write16(sc, 0x0030, regstack[7]);

		bcw_radio_write16(sc, 0x0043, regstack[8]);
		bcw_radio_write16(sc, 0x007a, regstack[9]);

		bcw_radio_write16(sc, 0x0052, (bcw_radio_read16(sc, 0x0052) &
		    0x000f) | regstack[11]);
		BCW_WRITE16(sc, 0x03ec, regstack[10]);
	}
	bcw_phy_write16(sc, 0x0015, regstack[0]);
}

void
bcw_phy_lo_g_state(struct bcw_softc *sc, struct bcw_lopair *in_pair,
    struct bcw_lopair *out_pair, uint16_t r27)
{
	const struct bcw_lopair transitions[8] = {
	    { .high =  1,  .low =  1, },
	    { .high =  1,  .low =  0, },
	    { .high =  1,  .low = -1, },
	    { .high =  0,  .low = -1, },
	    { .high = -1,  .low = -1, },
	    { .high = -1,  .low =  0, },
	    { .high = -1,  .low =  1, },
	    { .high =  0,  .low =  1, } };
	struct bcw_lopair lowest_transition = {
	    .high = in_pair->high,
	    .low = in_pair->low };
	struct bcw_lopair tmp_pair;
	struct bcw_lopair transition;
	int i = 12;
	int state = 0;
	int found_lower;
	int j, begin, end;
	uint32_t lowest_deviation;
	uint32_t tmp;

	bcw_phy_lo_write(sc, &lowest_transition);
	lowest_deviation = bcw_phy_lo_g_singledeviation(sc, r27);
	do {
		found_lower = 0;
		if (state == 0) {
			begin = 1;
			end = 8;
		} else if (state % 2 == 0) {
			begin = state - 1;
			end = state + 1;
		} else {
			begin = state - 2;
			end = state + 2;
		}
		if (begin < 1)
			begin += 8;
		if (end > 8)
			end -= 8;

		j = begin;
		tmp_pair.high = lowest_transition.high;
		tmp_pair.low = lowest_transition.low;
		while (1) {
			transition.high = tmp_pair.high +
			    transitions[j - 1].high;
			transition.low = tmp_pair.low +
			    transitions[j - 1].low;
			if ((abs(transition.low) < 9) && (abs(transition.high)
			    < 9)) {
				bcw_phy_lo_write(sc, &transition);
				tmp = bcw_phy_lo_g_singledeviation(sc, r27);
				if (tmp < lowest_deviation) {
					lowest_deviation = tmp;
					state = j;
					found_lower = 1;
					lowest_transition.high =
					    transition.high;
					lowest_transition.low =
					    transition.low;
				}
			}
			if (j == end)
				break;
			if (j == 8)
				j = 1;
			else
				j++;
		}
	} while (i-- && found_lower);

	out_pair->high = lowest_transition.high;
	out_pair->low = lowest_transition.low;
}

void
bcw_phy_lo_g_measure(struct bcw_softc *sc)
{
	const uint8_t pairorder[10] = { 3, 1, 5, 7, 9, 2, 0, 4, 6, 8 };
	const int is_initializing = 0; /* XXX */
	uint16_t h, i, oldi = 0, j;
	struct bcw_lopair control;
	struct bcw_lopair *tmp_control;
	uint16_t tmp;
	uint16_t regstack[16] = { 0 };
	uint16_t oldchannel;
	uint8_t r27 = 0, r31;

	oldchannel = sc->sc_radio_channel;
	/* setup */
	if (sc->sc_phy_connected) {
		regstack[0] = bcw_phy_read16(sc, BCW_PHY_G_CRS);
		regstack[1] = bcw_phy_read16(sc, 0x0802);
		bcw_phy_write16(sc, BCW_PHY_G_CRS, regstack[0] & 0x7fff);
		bcw_phy_write16(sc, 0x0802, regstack[1] & 0xfffc);
	}
	regstack[3]  = BCW_READ16(sc, 0x03e2);
	BCW_WRITE16(sc, 0x03e2, regstack[3] | 0x8000);
	regstack[4]  = BCW_READ16(sc, BCW_MMIO_CHANNEL_EXT);
	regstack[5]  = bcw_phy_read16(sc, 0x15);
	regstack[6]  = bcw_phy_read16(sc, 0x2a);
	regstack[7]  = bcw_phy_read16(sc, 0x35);
	regstack[8]  = bcw_phy_read16(sc, 0x60);
	regstack[9]  = bcw_radio_read16(sc, 0x43);
	regstack[10] = bcw_radio_read16(sc, 0x7a);
	regstack[11] = bcw_radio_read16(sc, 0x52);
	if (sc->sc_phy_connected) {
		regstack[12] = bcw_phy_read16(sc, 0x0811);
		regstack[13] = bcw_phy_read16(sc, 0x0812);
		regstack[14] = bcw_phy_read16(sc, 0x0814);
		regstack[15] = bcw_phy_read16(sc, 0x0815);
	}
	bcw_radio_select_channel(sc, 6, 0);
	if (sc->sc_phy_connected) {
		bcw_phy_write16(sc, BCW_PHY_G_CRS, regstack[0] & 0x7fff);
		bcw_phy_write16(sc, 0x0802, regstack[1] & 0xfffc);
		bcw_dummy_transmission(sc);
	}
	bcw_radio_write16(sc, 0x0043, 0x0006);

	bcw_phy_set_baseband_atten(sc, 2);

	BCW_WRITE16(sc, BCW_MMIO_CHANNEL_EXT, 0);
	bcw_phy_write16(sc, 0x002e, 0x007f);
	bcw_phy_write16(sc, 0x080f, 0x0078);
	bcw_phy_write16(sc, 0x0035, regstack[7] & ~(1 << 7));
	bcw_radio_write16(sc, 0x007a, regstack[10] & 0xfff0);
	bcw_phy_write16(sc, 0x002b, 0x0203);
	bcw_phy_write16(sc, 0x002a, 0x08a3);
	if (sc->sc_phy_type) {
		bcw_phy_write16(sc, 0x0814, regstack[14] | 0x0003);
		bcw_phy_write16(sc, 0x0815, regstack[15] & 0xfffc);
		bcw_phy_write16(sc, 0x0811, 0x01b3);
		bcw_phy_write16(sc, 0x0812, 0x00b2);
	}
	if (is_initializing)
		bcw_phy_lo_g_measure_txctl2(sc);

	bcw_phy_write16(sc, 0x080f, 0x8078);

	/* measure */
	control.low = 0;
	control.high = 0;
	for (h = 0; h < 10; h++) {
		/* loop over each possible RadioAttenuation (0 - 9) */
		i = pairorder[h];
		if (is_initializing) {
			if (i == 3) {
				control.low = 0;
				control.high = 0;
			} else if (((i % 2 == 1) && (oldi % 2 == 1)) ||
			    ((i % 2 == 0) && (oldi % 2 == 0))) {
				tmp_control = bcw_get_lopair(sc, oldi, 0);
				memcpy(&control, tmp_control, sizeof(control));
			} else {
				tmp_control = bcw_get_lopair(sc, 3, 0);
				memcpy(&control, tmp_control, sizeof(control));
			}
		}
		/* loop over each possible BasebandAttenuation / 2 */
		for (j = 0; j < 4; j++) {
			if (is_initializing) {
				tmp = i * 2 + j;
				r27 = 0;
				r31 = 0;
				if (tmp > 14) {
					r31 = 1;
					if (tmp > 17)
						r27 = 1;
					if (tmp > 19)
						r27 = 2;
				}
			} else {
				tmp_control = bcw_get_lopair(sc, i, j * 2);
				if (!tmp_control->used)
					continue;
				memcpy(&control, tmp_control, sizeof(control));
				r27 = 3;
				r31 = 0;
			}
			bcw_radio_write16(sc, 0x43, i);
			bcw_radio_write16(sc, 0x52, sc->sc_radio_txctl2);
			delay(10);

			bcw_phy_set_baseband_atten(sc, j * 2);

			tmp = (regstack[10] & 0xfff0);
			if (r31)
				tmp |= 0x0008;
			bcw_radio_write16(sc, 0x007a, tmp);

			tmp_control = bcw_get_lopair(sc, i, j * 2);
			bcw_phy_lo_g_state(sc, &control, tmp_control, r27);
		}
		oldi = i;
	}
	/* loop over each possible RadioAttenuation (10 - 13) */
	for (i = 10; i < 14; i++) {
		/* loop over each possible BasebandAttenuation / 2 */
		for (j = 0; j < 4; j++) {
			if (is_initializing) {
				tmp_control = bcw_get_lopair(sc, i - 9, j * 2);
				memcpy(&control, tmp_control, sizeof(control));
				tmp = (i - 9) * 2 + j - 5; /* XXX */
				r27 = 0;
				r31 = 0;
				if (tmp > 14) {
					r31 = 1;
					if (tmp > 17)
						r27 = 1;
					if (tmp > 19)
						r27 = 2;
				}
			} else {
				tmp_control = bcw_get_lopair(sc, i - 9, j * 2);
				if (!tmp_control->used)
					continue;
				memcpy(&control, tmp_control, sizeof(control));
				r27 = 3;
				r31 = 0;
			}
			bcw_radio_write16(sc, 0x043, i - 9);
			bcw_radio_write16(sc, 0x052, sc->sc_radio_txctl2 |
			    (3 << 4)); /* XXX */
			delay(10);

			bcw_phy_set_baseband_atten(sc, j * 2);

			tmp = (regstack[10] & 0xfff0);
			if (r31)
				tmp |= 0x0008;
			bcw_radio_write16(sc, 0x7a, tmp);

			tmp_control = bcw_get_lopair(sc, i, j * 2);
			bcw_phy_lo_g_state(sc, &control, tmp_control, r27);
		}

	}

	/* restoration */
	if (sc->sc_phy_connected) {
		bcw_phy_write16(sc, 0x0015, 0xe300);
		bcw_phy_write16(sc, 0x0812, (r27 << 8) | 0xa0);
		delay(5);
		bcw_phy_write16(sc, 0x0812, (r27 << 8) | 0xa2);
		delay(2);
		bcw_phy_write16(sc, 0x0812, (r27 << 8) | 0xa3);
	} else
		bcw_phy_write16(sc, 0x0015, r27 | 0xefa0);
	bcw_phy_lo_adjust(sc, is_initializing);
	bcw_phy_write16(sc, 0x002e, 0x807f);
	if (sc->sc_phy_connected)
		bcw_phy_write16(sc, 0x002f, 0x0202);
	else
		bcw_phy_write16(sc, 0x002f, 0x0101);
	bcw_phy_write16(sc, BCW_MMIO_CHANNEL_EXT, regstack[4]);
	bcw_phy_write16(sc, 0x0015, regstack[5]);
	bcw_phy_write16(sc, 0x0015, regstack[6]);
	bcw_phy_write16(sc, 0x0015, regstack[7]);
	bcw_phy_write16(sc, 0x0015, regstack[8]);
	bcw_radio_write16(sc, 0x0043, regstack[9]);
	bcw_radio_write16(sc, 0x007a, regstack[10]);
	regstack[11] &= 0x00f0;
	regstack[11] |= (bcw_radio_read16(sc, 0x52) & 0x000f);
	bcw_radio_write16(sc, 0x52, regstack[11]);
	BCW_WRITE16(sc, 0x03e2, regstack[3]);
	if (sc->sc_phy_connected) {
		bcw_phy_write16(sc, 0x0811, regstack[12]);
		bcw_phy_write16(sc, 0x0812, regstack[13]);
		bcw_phy_write16(sc, 0x0814, regstack[14]);
		bcw_phy_write16(sc, 0x0815, regstack[15]);
		bcw_phy_write16(sc, BCW_PHY_G_CRS, regstack[0]);
		bcw_phy_write16(sc, 0x0802, regstack[1]);
	}
	bcw_radio_select_channel(sc, oldchannel, 1);
}

void
bcw_phy_lo_g_measure_txctl2(struct bcw_softc *sc)
{
	uint16_t txctl2 = 0, i;
	uint32_t smallest, tmp;

	bcw_radio_write16(sc, 0x0052, 0);
	delay(10);
	smallest = bcw_phy_lo_g_singledeviation(sc, 0);
	for (i = 0; i < 16; i++) {
		bcw_radio_write16(sc, 0x0052, i);
		delay(10);
		tmp = bcw_phy_lo_g_singledeviation(sc, 0);
		if (tmp < smallest) {
			smallest = tmp;
			txctl2 = i;
		}
	}
	sc->sc_radio_txctl2 = txctl2;
}

uint32_t
bcw_phy_lo_g_singledeviation(struct bcw_softc *sc, uint16_t control)
{
	int i;
	uint32_t r = 0;

	for (i = 0; i < 8; i++)
		r += bcw_phy_lo_g_deviation_subval(sc, control);

	return (r);
}

uint16_t
bcw_phy_lo_g_deviation_subval(struct bcw_softc *sc, uint16_t control)
{
	uint16_t r;
	//unsigned long flags;

	/* XXX splnet()? */

	if (sc->sc_phy_connected) {
		bcw_phy_write16(sc, 0x15, 0xe300);
		control <<= 8;
		bcw_phy_write16(sc, 0x0812, control | 0x00b0);
		delay(5);
		bcw_phy_write16(sc, 0x0812, control | 0x00b2);
		delay(2);
		bcw_phy_write16(sc, 0x0812, control | 0x00b3);
		delay(4);
		bcw_phy_write16(sc, 0x0015, 0xf300);
		delay(8);
	} else {
		bcw_phy_write16(sc, 0x0015, control | 0xefa0);
		delay(2);
		bcw_phy_write16(sc, 0x0015, control | 0xefe0);
		delay(4);
		bcw_phy_write16(sc, 0x0015, control | 0xffe0);
		delay(8);
	}
	r = bcw_phy_read16(sc, 0x002d);

	/* XXX splnet()? */

	return (r);
}

void
bcw_phy_lo_adjust(struct bcw_softc *sc, int fixed)
{
	struct bcw_lopair *pair;

	if (fixed)
		pair = bcw_phy_find_lopair(sc, 2, 3, 0);
	else
		pair = bcw_phy_current_lopair(sc);

	bcw_phy_lo_write(sc, pair);
}

void
bcw_phy_lo_mark_current_used(struct bcw_softc *sc)
{
	struct bcw_lopair *pair;

	pair = bcw_phy_current_lopair(sc);
	pair->used = 1;
}

void
bcw_phy_lo_write(struct bcw_softc *sc, struct bcw_lopair *pair)
{
	uint16_t val;

	val = (uint8_t)(pair->low);
	val |= ((uint8_t)(pair->high)) << 8;

#ifdef BCW_DEBUG
	if (pair->low < -8 || pair->low > 8 ||
	    pair->high < -8 || pair->high > 8)
		printf("%s: writing invalid LO pair "
		    "low: %d, high: %d, index: %lu)\n",
		    pair->low, pair->high,
		    (unsigned long)(pair - sc->sc_phy_lopairs));
#endif

	bcw_phy_write16(sc, BCW_PHY_G_LO_CONTROL, val);
}

struct bcw_lopair *
bcw_phy_find_lopair(struct bcw_softc *sc, uint16_t baseband_atten,
    uint16_t radio_atten, uint16_t tx)
{
	static const uint8_t dict[10] =
	    { 11, 10, 11, 12, 13, 12, 13, 12, 13, 12 };

	if (baseband_atten > 6)
		baseband_atten = 6;

	if (tx == 3)
		return (bcw_get_lopair(sc, radio_atten, baseband_atten));

	return (bcw_get_lopair(sc, dict[radio_atten], baseband_atten));
}

struct bcw_lopair *
bcw_phy_current_lopair(struct bcw_softc *sc)
{
	return (bcw_phy_find_lopair(sc, sc->sc_radio_baseband_atten,
	    sc->sc_radio_radio_atten, sc->sc_radio_txctl1));
}

void
bcw_phy_set_antenna_diversity(struct bcw_softc *sc)
{
	uint16_t antennadiv;
	uint16_t offset;
	uint16_t val;
	uint32_t ucodeflags;

	if (antennadiv == 0xffff)
		antennadiv = 3;

	ucodeflags = bcw_shm_read32(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET);
	bcw_shm_write32(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET,
	    ucodeflags & ~BCW_UCODEFLAG_AUTODIV);

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
	case BCW_PHY_TYPEG:
		if (sc->sc_phy_type == BCW_PHY_TYPEA)
			offset = 0;
		else
			offset = 0x0400;

		if (antennadiv == 2)
			val = (3 << 7);
		else
			val = (antennadiv << 7);
		bcw_phy_write16(sc, offset + 1,
		    (bcw_phy_read16(sc, offset + 1) & 0x7e7f) | val);

		if (antennadiv >= 2) {
			if (antennadiv == 2)
				val = (antennadiv << 7);
			else
				val = (0 << 7);
			bcw_phy_write16(sc, offset + 0x2b,
			    (bcw_phy_read16(sc, offset + 0x2b) & 0xfeff) | val);
		}

		if (sc->sc_phy_type == BCW_PHY_TYPEG) {
			if (antennadiv >= 2)
				bcw_phy_write16(sc, 0x048c,
				    bcw_phy_read16(sc, 0x048c) | 0x2000);
			else
				bcw_phy_write16(sc, 0x048c,
				    bcw_phy_read16(sc, 0x048c) | ~0x2000);
			if (sc->sc_phy_rev >= 2) {
				bcw_phy_write16(sc, 0x0461,
				    bcw_phy_read16(sc, 0x0461) | 0x0010);
				bcw_phy_write16(sc, 0x04ad,
				    (bcw_phy_read16(sc, 0x04ad) & 0x00ff) |
				    0x0015);
				if (sc->sc_phy_rev == 2)
					bcw_phy_write16(sc, 0x0427, 0x0008);
				else
					bcw_phy_write16(sc, 0x0427,
					    (bcw_phy_read16(sc, 0x0427) &
					    0x00ff) | 0x0008);
			} else if (sc->sc_phy_rev >= 6)
				bcw_phy_write16(sc, 0x049b, 0x00dc);
		} else {
			if (sc->sc_phy_rev < 3)
				bcw_phy_write16(sc, 0x002b,
				    (bcw_phy_read16(sc, 0x002b) & 0x00ff) |
				    0x0024);
			else {
				bcw_phy_write16(sc, 0x0061,
				    bcw_phy_read16(sc, 0x0061) | 0x0010);
				if (sc->sc_phy_rev == 3) {
					bcw_phy_write16(sc, 0x0093, 0x001d);
					bcw_phy_write16(sc, 0x0027, 0x0008);
				} else {
					bcw_phy_write16(sc, 0x0093, 0x003a);
					bcw_phy_write16(sc, 0x0027,
					    (bcw_phy_read16(sc, 0x0027) &
					    0x00ff) | 0x0008);	
				}
			}
		}
		break;
	case BCW_PHY_TYPEB:
		if (sc->sc_core[sc->sc_currentcore].rev == 2)
			val = (3 << 7);
		else
			val = (antennadiv << 7);
		bcw_phy_write16(sc, 0x03e2, (bcw_phy_read16(sc, 0x03e2) &
		    0xfe7f) | val);
		break;
	default:
		/* XXX panic()? */
		break;
	}

	if (antennadiv >= 2) {
		ucodeflags = bcw_shm_read32(sc, BCW_SHM_SHARED,
		    BCW_UCODEFLAGS_OFFSET);
		bcw_shm_write32(sc, BCW_SHM_SHARED,
		    BCW_UCODEFLAGS_OFFSET, ucodeflags |
		    BCW_UCODEFLAG_AUTODIV);
	}

	sc->sc_phy_antenna_diversity = antennadiv;
}

void
bcw_phy_calibrate(struct bcw_softc *sc)
{
	BCW_READ(sc, BCW_MMIO_SBF);

	if (sc->sc_phy_calibrated)
		return;
	if (sc->sc_phy_type == BCW_PHY_TYPEG && sc->sc_phy_rev == 1) {
		bcw_80211_core_reset(sc, 0);
		bcw_phy_initg(sc);
		bcw_80211_core_reset(sc, 1);
	}
	sc->sc_phy_calibrated = 1;
}

/*
 * Connect the PHY
 *
 * http://bcm-specs.sipsolutions.net/SetPHY
 */
int
bcw_phy_connect(struct bcw_softc *sc, int connect)
{
	uint32_t flags;

	if (sc->sc_core[sc->sc_currentcore].rev < 5)
		goto out;

	flags = BCW_READ(sc, BCW_CIR_SBTMSTATEHIGH);
	if (connect) {
		if (!(flags & 0x00010000))
			return (ENODEV);
		flags = BCW_READ(sc, BCW_CIR_SBTMSTATELOW);
		flags |= (0x800 << 18);
		BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, flags);
	} else {
		if (!(flags & 0x00020000))
			return (ENODEV);
		flags = BCW_READ(sc, BCW_CIR_SBTMSTATELOW);
		flags &= ~(0x800 << 18);
		BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, flags);
	}

out:
	sc->sc_phy_connected = connect;
	if (connect)
		DPRINTF(("%s: PHY connected\n", sc->sc_dev.dv_xname));
	else
		DPRINTF(("%s: PHY disconnected\n", sc->sc_dev.dv_xname));

	return (0);
}

void
bcw_phy_lock(struct bcw_softc *sc)
{
        struct ieee80211com *ic = &sc->sc_ic;

	if (BCW_READ(sc, BCW_MMIO_SBF) == 0) {
		sc->sc_phy_is_locked = 0;
		return;
	}

	if (sc->sc_core[sc->sc_currentcore].rev < 3)
		bcw_mac_disable(sc);
	else {
		if (ic->ic_opmode != IEEE80211_M_HOSTAP)
			bcw_pc_saving_ctl_bits(sc, -1, -1);
	}

	sc->sc_phy_is_locked = 1;
}

void
bcw_phy_unlock(struct bcw_softc *sc)
{
        struct ieee80211com *ic = &sc->sc_ic;

	if (sc->sc_core[sc->sc_currentcore].rev < 3) {
		if (sc->sc_phy_is_locked)
			bcw_mac_enable(sc);
	} else {
		if (ic->ic_opmode != IEEE80211_M_HOSTAP)
			bcw_pc_saving_ctl_bits(sc, -1, -1);
	}

	sc->sc_phy_is_locked = 0;
}

/*
 * Radio
 */
int
bcw_radio_get(struct bcw_softc *sc)
{
	uint32_t val;

	/*
	 * XXX
	 * Query the RadioID register, on a 4317 use a lookup instead
	 * Different PHYs have different radio register layouts, so
	 * a wrapper func should be written.
	 * Getting the RadioID is the only 32bit operation done with the
	 * Radio registers, and requires seperate 16bit reads from the low
	 * and the high data addresses.
	 */
	if (sc->sc_chip_id != 0x4317) {
		BCW_WRITE16(sc, BCW_MMIO_RADIO_CONTROL, BCW_RADIO_ID);
		val = BCW_READ16(sc, BCW_MMIO_RADIO_DATA_HIGH);
		val <<= 16;
		BCW_WRITE16(sc, BCW_MMIO_RADIO_CONTROL, BCW_RADIO_ID);
		sc->sc_radio_mnf =
		    val | BCW_READ16(sc, BCW_MMIO_RADIO_DATA_LOW);
	} else {
		switch (sc->sc_chip_rev) {
		case 0:	
			sc->sc_radio_mnf = 0x3205017F;
			break;
		case 1:
			sc->sc_radio_mnf = 0x4205017f;
			break;
		default:
			sc->sc_radio_mnf = 0x5205017f;
		}
	}

	sc->sc_radio_rev = (sc->sc_radio_mnf & 0xf0000000) >> 28;
        sc->sc_radio_ver = (sc->sc_radio_mnf & 0x0ffff000) >> 12;

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		if (sc->sc_radio_ver != 0x2060) {
			printf("%s: invalid PHY A radio 0x%x!\n",
			    sc->sc_dev.dv_xname, sc->sc_radio_ver);
			return (1);
		}
		break;
	case BCW_PHY_TYPEB:
		if ((sc->sc_radio_ver & 0xfff0) != 0x2050) {
			printf("%s: invalid PHY B radio 0x%x!\n",
			    sc->sc_dev.dv_xname, sc->sc_radio_ver);
			return (1);
		}
		break;
	case BCW_PHY_TYPEG:
		if (sc->sc_radio_ver != 0x2050) {
			printf("%s: invalid PHY G radio 0x%x!\n",
			    sc->sc_dev.dv_xname, sc->sc_radio_ver);
			return (1);
		}
		break;
	}

	DPRINTF(("%s: Radio rev %d ver 0x%x mnf 0x%x\n",
	    sc->sc_dev.dv_xname, sc->sc_radio_rev, sc->sc_radio_ver,
	    sc->sc_radio_mnf & 0xfff));

	return (0);
}

void
bcw_radio_off(struct bcw_softc *sc)
{
	/* Magic unexplained values */
	if (sc->sc_phy_type == BCW_PHY_TYPEA) {
		bcw_radio_write16(sc, 0x0004, 0x00ff);
		bcw_radio_write16(sc, 0x0005, 0x00fb);
		bcw_phy_write16(sc, 0x0010, bcw_phy_read16(sc, 0x0010) |
		    0x0008);
		bcw_phy_write16(sc, 0x0011, bcw_phy_read16(sc, 0x0011) |
		    0x0008);
	}
	if (sc->sc_phy_type == BCW_PHY_TYPEB && sc->sc_core_80211->rev >= 5) {
		bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) |
		    0x008c);
		bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) &
		    0xff73);
	} else
		bcw_phy_write16(sc, 0x0015, 0xaa00);

	DPRINTF(("%s: Radio turned off\n", sc->sc_dev.dv_xname));
}

void
bcw_radio_on(struct bcw_softc *sc)
{
	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		bcw_radio_write16(sc, 0x0004, 0x00c0);
		bcw_radio_write16(sc, 0x0005, 0x0008);
		bcw_phy_write16(sc, 0x0010, bcw_phy_read16(sc, 0x0010) &
		    0xfff7);
		bcw_phy_write16(sc, 0x0011, bcw_phy_read16(sc, 0x0011) &
		    0xfff7);
		bcw_radio_init2060(sc);
		break;
	case BCW_PHY_TYPEB:
	case BCW_PHY_TYPEG:
		bcw_phy_write16(sc, 0x0015, 0x8000);
		bcw_phy_write16(sc, 0x0015, 0xcc00);
		bcw_phy_write16(sc, 0x0015, sc->sc_phy_connected ? 0x00c0 : 0);
		if (bcw_radio_select_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG,
		    1))
			return;
		break;
	default:
		return;
	}

	DPRINTF(("%s: Radio turned on\n", sc->sc_dev.dv_xname)); 
}

void
bcw_radio_nrssi_hw_write(struct bcw_softc *sc, uint16_t offset, int16_t val)
{
	bcw_phy_write16(sc, BCW_PHY_NRSSILT_CTRL, offset);
	bcw_phy_write16(sc, BCW_PHY_NRSSILT_DATA, (uint16_t)val);
}

int16_t
bcw_radio_nrssi_hw_read(struct bcw_softc *sc, uint16_t offset)
{
	uint16_t val;

	bcw_phy_write16(sc, BCW_PHY_NRSSILT_CTRL, offset);
	val = bcw_phy_read16(sc, BCW_PHY_NRSSILT_DATA);

	return ((int16_t)val);
}

void
bcw_radio_nrssi_hw_update(struct bcw_softc *sc, uint16_t val)
{
	uint16_t i;
	int16_t tmp;

	for (i = 0; i < 64; i++) {
		tmp = bcw_radio_nrssi_hw_read(sc, i);
		tmp -= val;
		tmp = bcw_lv(tmp, 32, 31);
		bcw_radio_nrssi_hw_write(sc, i, tmp);
	}
}

void
bcw_radio_calc_nrssi_threshold(struct bcw_softc *sc)
{
	int32_t threshold;
	int32_t a, b;
	int16_t tmp16;
	uint16_t tmp_u16;

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEB:
		if (sc->sc_radio_ver != 0x2050)
			return;
		if (!(sc->sc_sprom.boardflags & BCW_BF_RSSI))
			return;

		if (sc->sc_radio_rev >= 6) {
			threshold = (sc->sc_radio_nrssi[1] -
			    sc->sc_radio_nrssi[0]) * 32;
			threshold += 20 * (sc->sc_radio_nrssi[0] + 1);
			threshold /= 40;
		} else
			threshold = sc->sc_radio_nrssi[1] - 5;

		threshold = bcw_lv(threshold, 0, 0x3e);
		bcw_phy_read16(sc, 0x0020);
		bcw_phy_write16(sc, 0x0020, (((uint16_t)threshold) << 8) |
		    0x001c);

		if (sc->sc_radio_rev >= 6) {
			bcw_phy_write16(sc, 0x0087, 0x0e0d);
			bcw_phy_write16(sc, 0x0086, 0x0c0d);
			bcw_phy_write16(sc, 0x0085, 0x0a09);
			bcw_phy_write16(sc, 0x0084, 0x0808);
			bcw_phy_write16(sc, 0x0083, 0x0808);
			bcw_phy_write16(sc, 0x0082, 0x0604);
			bcw_phy_write16(sc, 0x0081, 0x0302);
			bcw_phy_write16(sc, 0x0080, 0x0100);
		}
		break;
	case BCW_PHY_TYPEG:
		if (!sc->sc_phy_connected ||
		    !(sc->sc_sprom.boardflags & BCW_BF_RSSI)) {
			tmp16 = bcw_radio_nrssi_hw_read(sc, 0x20);
			if (tmp16 >= 0x20)
				tmp16 -= 0x40;
			if (tmp16 < 3)
				bcw_phy_write16(sc, 0x048a,
				    (bcw_phy_read16(sc, 0x048a) & 0xf000) |
				    0x09eb);
			else
				bcw_phy_write16(sc, 0x048a,
				    (bcw_phy_read16(sc, 0x048a) & 0xf000) |
				    0x0aed);
		} else {
			if (sc->sc_radio_interfmode ==
			    BCW_RADIO_INTERFMODE_NONWLAN) {
				a = 0xe;
				b = 0xa;
			} else if (sc->sc_radio_aci_wlan_automatic &&
			    sc->sc_radio_aci_enable) {
				a = 0x13;
				b = 0x12;
			} else {
				a = 0xe;
				b = 0x11;
			}

			a = a * (sc->sc_radio_nrssi[1] - sc->sc_radio_nrssi[0]);
			a += (sc->sc_radio_nrssi[0] << 6);
			if (a < 32)
				a += 31;
			else
				a += 32;
			a = a >> 6;
			a = bcw_lv(a, -31, 31);

			b = b * (sc->sc_radio_nrssi[1] - sc->sc_radio_nrssi[0]);
			b += (sc->sc_radio_nrssi[0] << 6);
			if (b < 32)
				b += 31;
			else
				b += 32;
			b = b >> 6;
			b = bcw_lv(b, -31, 31);

			tmp_u16 = bcw_phy_read16(sc, 0x048a) & 0xf000;
			tmp_u16 |= ((uint32_t)b & 0x0000003f);
			tmp_u16 |= (((uint32_t)a & 0x0000003f) << 6);
			bcw_phy_write16(sc, 0x048a, tmp_u16);
		}
		break;
	default:
		/* XXX panic()? */
		return;
	}
}

void
bcw_radio_calc_nrssi_slope(struct bcw_softc *sc)
{
	uint16_t backup[18] = { 0 };
	uint16_t tmp;
	int16_t nrssi0, nrssi1;

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEB:
		backup[0]  = bcw_radio_read16(sc, 0x007a);
		backup[1]  = bcw_radio_read16(sc, 0x0052);
		backup[2]  = bcw_radio_read16(sc, 0x0043);
		backup[3]  = bcw_phy_read16(sc, 0x0030);
		backup[4]  = bcw_phy_read16(sc, 0x0026);
		backup[5]  = bcw_phy_read16(sc, 0x0015);
		backup[6]  = bcw_phy_read16(sc, 0x0020);
		backup[7]  = bcw_phy_read16(sc, 0x005a);
		backup[8]  = bcw_phy_read16(sc, 0x0059);
		backup[9]  = bcw_phy_read16(sc, 0x0058);
		backup[10] = bcw_phy_read16(sc, 0x03e2);
		backup[11] = BCW_READ16(sc, 0x03e6);
		backup[12] = BCW_READ16(sc, 0x007a);
		backup[13] = BCW_READ16(sc, BCW_MMIO_CHANNEL_EXT);

		tmp = bcw_radio_read16(sc, 0x007a);
		tmp &= ((sc->sc_phy_rev >= 5) ? 0x007f : 0x000f);
		bcw_radio_write16(sc, 0x007a, tmp);
		bcw_phy_write16(sc, 0x0030, 0x00f);
		BCW_WRITE16(sc, 0x03ec, 0x7f7f);
		bcw_phy_write16(sc, 0x0026, 0);
		bcw_phy_write16(sc, 0x0015, bcw_phy_read16(sc, 0x0015) |
		    0x0020);
		bcw_phy_write16(sc, 0x002a, 0x08a3);
		bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) |
		    0x0080);

		nrssi0 = (uint16_t)bcw_phy_read16(sc, 0x0027);
		bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) &
		    0x007f);
		if (sc->sc_phy_rev >= 2)
			BCW_WRITE16(sc, 0x03e6, 0x0040);
		else if (sc->sc_phy_rev == 0)
			BCW_WRITE16(sc, 0x03e6, 0x0122);
		else
			BCW_WRITE16(sc, BCW_MMIO_CHANNEL_EXT,
			    BCW_READ16(sc, BCW_MMIO_CHANNEL_EXT) & 0x2000);
		bcw_phy_write16(sc, 0x0020, 0x3f3f);
		bcw_phy_write16(sc, 0x0014, 0xf330);
		bcw_radio_write16(sc, 0x005a, 0xf330);
		bcw_radio_write16(sc, 0x0043,
		    bcw_radio_read16(sc, 0x0043) & 0x0f0);
		bcw_phy_write16(sc, 0x005a, 0x0480);
		bcw_phy_write16(sc, 0x0059, 0x0810);
		bcw_phy_write16(sc, 0x0058, 0x000d);
		delay(20);

		nrssi1 = (int16_t)bcw_phy_read16(sc, 0x0027);
		bcw_phy_write16(sc, 0x0030, backup[3]);
		bcw_radio_write16(sc, 0x007a, backup[0]);
		BCW_WRITE16(sc, 0x03e2, backup[11]);
		bcw_phy_write16(sc, 0x0026, backup[4]);
		bcw_phy_write16(sc, 0x0015, backup[5]);
		bcw_phy_write16(sc, 0x002a, backup[6]);
		bcw_radio_spw(sc, sc->sc_radio_channel);
		if (sc->sc_phy_rev != 0)
			BCW_WRITE16(sc, 0x3f4, backup[13]);

		bcw_phy_write16(sc, 0x0020, backup[7]);
		bcw_phy_write16(sc, 0x0020, backup[8]);
		bcw_phy_write16(sc, 0x0020, backup[9]);
		bcw_phy_write16(sc, 0x0020, backup[10]);
		bcw_radio_write16(sc, 0x0052, backup[1]);
		bcw_radio_write16(sc, 0x0043, backup[2]);

		if (nrssi0 == nrssi1)
			sc->sc_radio_nrssislope = 0x00010000;
		else
			sc->sc_radio_nrssislope = 0x00400000 /
			    (nrssi0 - nrssi1);

		if (nrssi0 <= -4) {
			sc->sc_radio_nrssi[0] = nrssi0;
			sc->sc_radio_nrssi[1] = nrssi1;
		}
		break;
	case BCW_PHY_TYPEG:
		if (sc->sc_radio_rev >= 9)
			return;
		if (sc->sc_radio_rev == 8)
			bcw_radio_calc_nrssi_offset(sc);
		break;
	}
}

void
bcw_radio_calc_nrssi_offset(struct bcw_softc *sc)
{
	uint16_t backup[20] = { 0 };
	int16_t v47f;
	uint16_t i;
	uint16_t saved = 0xffff;

	backup[0] = bcw_phy_read16(sc, 0x0001);
	backup[1] = bcw_phy_read16(sc, 0x0811);
	backup[2] = bcw_phy_read16(sc, 0x0812);
	backup[3] = bcw_phy_read16(sc, 0x0814);
	backup[4] = bcw_phy_read16(sc, 0x0815);
	backup[5] = bcw_phy_read16(sc, 0x005a);
	backup[6] = bcw_phy_read16(sc, 0x0059);
	backup[7] = bcw_phy_read16(sc, 0x0058);
	backup[8] = bcw_phy_read16(sc, 0x000a);
	backup[9] = bcw_phy_read16(sc, 0x0003);
	backup[10] = bcw_radio_read16(sc, 0x007a);
	backup[11] = bcw_radio_read16(sc, 0x0043);

	bcw_phy_write16(sc, 0x0429, bcw_phy_read16(sc, 0x0429) & 0x7fff);
	bcw_phy_write16(sc, 0x0001, (bcw_phy_read16(sc, 0x0001) & 0x3fff) |
	    0x4000);
	bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) | 0x000c);
	bcw_phy_write16(sc, 0x0812, (bcw_phy_read16(sc, 0x0812) & 0xfff3) |
	    0x0004);
	bcw_phy_write16(sc, 0x0802, bcw_phy_read16(sc, 0x0802) & ~(0x1 | 0x2));

	if (sc->sc_phy_rev >= 6) {
		backup[12] = bcw_phy_read16(sc, 0x002e);
		backup[13] = bcw_phy_read16(sc, 0x002f);
		backup[14] = bcw_phy_read16(sc, 0x080f);
		backup[15] = bcw_phy_read16(sc, 0x0810);
		backup[16] = bcw_phy_read16(sc, 0x0801);
		backup[17] = bcw_phy_read16(sc, 0x0060);
		backup[18] = bcw_phy_read16(sc, 0x0014);
		backup[19] = bcw_phy_read16(sc, 0x0478);

		bcw_phy_write16(sc, 0x002e, 0);
		bcw_phy_write16(sc, 0x002e, 0);
		bcw_phy_write16(sc, 0x002e, 0);
		bcw_phy_write16(sc, 0x002e, 0);
		bcw_phy_write16(sc, 0x0478, bcw_phy_read16(sc, 0x0478) |
		    0x0100);
		bcw_phy_write16(sc, 0x0801, bcw_phy_read16(sc, 0x0801) |
		    0x0040);
		bcw_phy_write16(sc, 0x0060, bcw_phy_read16(sc, 0x0060) |
		    0x0040);
		bcw_phy_write16(sc, 0x0014, bcw_phy_read16(sc, 0x0014) |
		    0x0200);
	}
	bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) | 0x0070);
	bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) | 0x0080);
	delay(30);

	v47f = (int16_t)((bcw_phy_read16(sc, 0x047f) >> 8) & 0x00ef);
	if (v47f >= 0x20)
		v47f -= 0x40;
	if (v47f == 31) {
		for (i = 7; i >= 4; i--) {
			bcw_radio_write16(sc, 0x007b, i);
			delay(20);
			v47f = (int16_t)((bcw_phy_read16(sc, 0x047f) >> 8) &
			    0x003f);
			if (v47f >= 0x20)
				v47f -= 0x40;
			if (v47f < 31 && saved == 0xffff)
				saved = i;
		}
		if (saved == 0xffff)
			saved = 4;
	} else {
		bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) &
		    0x007f);

		bcw_phy_write16(sc, 0x0814, bcw_phy_read16(sc, 0x0814) |
		    0x0001);
		bcw_phy_write16(sc, 0x0815, bcw_phy_read16(sc, 0x0815) &
		    0xfffe);
		bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) |
		    0x000c);
		bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) |
		    0x000c);
		bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) |
		    0x0030);
		bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) |
		    0x0030);
		bcw_phy_write16(sc, 0x005a, 0x0480);
		bcw_phy_write16(sc, 0x0059, 0x0810);
		bcw_phy_write16(sc, 0x0058, 0x000d);
		if (sc->sc_phy_rev == 0)
			bcw_phy_write16(sc, 0x0003, 0x0122);
		else
			bcw_phy_write16(sc, 0x000a, bcw_phy_read16(sc, 0x000a) |
			    0x2000);
		bcw_phy_write16(sc, 0x0814, bcw_phy_read16(sc, 0x0814) |
		    0x0004);
		bcw_phy_write16(sc, 0x0815, bcw_phy_read16(sc, 0x0815) &
		    0xfffb);
		bcw_phy_write16(sc, 0x0003, (bcw_phy_read16(sc, 0x0003) &
		    0xff9f) | 0x0040);
		bcw_radio_write16(sc, 0x007a, bcw_radio_read16(sc, 0x007a) |
		    0x000f);
		bcw_radio_set_all_gains(sc, 3, 0, 1);
		bcw_radio_write16(sc, 0x0043, (bcw_radio_read16(sc, 0x0043) &
		    0x00f0) | 0x000f);
		delay(30);
		v47f = (int16_t)((bcw_phy_read16(sc, 0x047f) >> 8) & 0x003f);
		if (v47f >= 0x20)
			v47f -= 0x40;
		if (v47f == -32) {
			for (i = 0; i < 4; i++) {
				bcw_radio_write16(sc, 0x007b, i);
				delay(20);
				v47f = (int16_t)((bcw_phy_read16(sc, 0x047f) >>
				    8) & 0x003f);
				if (v47f >= 0x20)
					v47f -= 0x40;
				if (v47f > -31 && saved == 0xffff)
					saved = i;
			}
			if (saved == 0xfff)
				saved = 3;
		} else
			saved = 0;
	}
	bcw_radio_write16(sc, 0x007b, saved);

	if (sc->sc_phy_rev >= 6) {
		bcw_phy_write16(sc, 0x002e, backup[12]);
		bcw_phy_write16(sc, 0x002f, backup[13]);
		bcw_phy_write16(sc, 0x080f, backup[14]);
		bcw_phy_write16(sc, 0x0810, backup[15]);
	}
	bcw_phy_write16(sc, 0x0814, backup[3]);
	bcw_phy_write16(sc, 0x0815, backup[4]);
	bcw_phy_write16(sc, 0x005a, backup[5]);
	bcw_phy_write16(sc, 0x0059, backup[6]);
	bcw_phy_write16(sc, 0x0058, backup[7]);
	bcw_phy_write16(sc, 0x000a, backup[8]);
	bcw_phy_write16(sc, 0x0003, backup[9]);
	bcw_radio_write16(sc, 0x0043, backup[11]);
	bcw_radio_write16(sc, 0x007a, backup[10]);
	bcw_phy_write16(sc, 0x0802, bcw_phy_read16(sc, 0x0802) | 0x1 | 0x2);
	bcw_phy_write16(sc, 0x0429, bcw_phy_read16(sc, 0x0429) | 0x8000);
	bcw_radio_set_original_gains(sc);
	if (sc->sc_phy_rev >= 6) {
		bcw_phy_write16(sc, 0x0801, backup[16]);
		bcw_phy_write16(sc, 0x0060, backup[17]);
		bcw_phy_write16(sc, 0x0014, backup[18]);
		bcw_phy_write16(sc, 0x0478, backup[19]);
	}
	bcw_phy_write16(sc, 0x0001, backup[0]);
	bcw_phy_write16(sc, 0x0812, backup[2]);
	bcw_phy_write16(sc, 0x0001, backup[1]);
}

void
bcw_radio_set_all_gains(struct bcw_softc *sc, int16_t first, int16_t second,
    int16_t third)
{
	uint16_t i;
	uint16_t start = 0x08, end = 0x18;
	uint16_t offset = 0x0400;
	uint16_t tmp;

	if (sc->sc_phy_rev <= 1) {
		offset = 0x5000;
		start = 0x10;
		end = 0x20;
	}

	for (i = 0; i < 4; i++)
		bcw_ilt_write(sc, offset + i, first);

	for (i = start; i < end; i++)
		bcw_ilt_write(sc, offset + i, second);

	if (third != -1) {
		bcw_phy_write16(sc, 0x04a0, (bcw_phy_read16(sc, 0x04a0) &
		    0xbfbf) | tmp);
		bcw_phy_write16(sc, 0x04a1, (bcw_phy_read16(sc, 0x04a1) &
		    0xbfbf) | tmp);
		bcw_phy_write16(sc, 0x04a2, (bcw_phy_read16(sc, 0x04a2) &
		    0xbfbf) | tmp);
	}
	bcw_dummy_transmission(sc);
}

void
bcw_radio_set_original_gains(struct bcw_softc *sc)
{
	uint16_t i, tmp;
	uint16_t offset = 0x0400;
	uint16_t start = 0x0008, end = 0x0018;

	if (sc->sc_phy_rev <= 1) {
		offset = 0x5000;
		start = 0x0010;
		end = 0x0020;
	}

	for (i = 0; i < 4; i++) {
		tmp = (i & 0xfffc);
		tmp |= (i & 0x0001) << 1;
		tmp |= (i & 0x0002) >> 1;

		bcw_ilt_write(sc, offset + i, tmp);
	}

	for (i = start; i < end; i++)
		bcw_ilt_write(sc, offset + i, i - start);

	bcw_phy_write16(sc, 0x04a0, (bcw_phy_read16(sc, 0x04a0) & 0xbfbf) |
	    0x4040);
	bcw_phy_write16(sc, 0x04a1, (bcw_phy_read16(sc, 0x04a1) & 0xbfbf) |
	    0x4040);
	bcw_phy_write16(sc, 0x04a2, (bcw_phy_read16(sc, 0x04a2) & 0xbfbf) |
	    0x4000);
	bcw_dummy_transmission(sc);
}

uint16_t
bcw_radio_calibrationvalue(struct bcw_softc *sc)
{
	uint16_t reg, index, r;

	reg = bcw_radio_read16(sc, 0x0060);
	index = (reg & 0x001e) >> 1;
	r = rcc_table[index] << 1;
	r |= (reg & 0x0001);
	r |= 0x0020;

	return (r);
}

void
bcw_radio_set_txpower_a(struct bcw_softc *sc, uint16_t txpower)
{
	uint16_t pamp, base, dac, ilt;

	txpower = bcw_lv(txpower, 0, 63);

	pamp = bcw_radio_get_txgain_freq_power_amp(txpower);
	pamp <<= 5;
	pamp &= 0x00e0;
	bcw_phy_write16(sc, 0x0019, pamp);

	base = bcw_radio_get_txgain_baseband(txpower);
	base &= 0x000f;
	bcw_phy_write16(sc, 0x0017, base | 0x0020);

	ilt = bcw_ilt_read(sc, 0x3001);
	ilt &= 0x0007;

	dac = bcw_radio_get_txgain_dac(txpower);
	dac <<= 3;
	dac |= ilt;

	bcw_ilt_write(sc, 0x3001, dac);

	sc->sc_radio_txpwr_offset = txpower;
}

void
bcw_radio_set_txpower_bg(struct bcw_softc *sc, uint16_t baseband_atten,
    uint16_t radio_atten, uint16_t txpower)
{
	if (baseband_atten == 0xffff)
		baseband_atten = sc->sc_radio_baseband_atten;
	if (radio_atten == 0xffff)
		radio_atten = sc->sc_radio_radio_atten;
	if (txpower == 0xffff)
		txpower = sc->sc_radio_txctl1;

	sc->sc_radio_baseband_atten = baseband_atten;
	sc->sc_radio_radio_atten = radio_atten;
	sc->sc_radio_txctl1 = txpower;

	bcw_phy_set_baseband_atten(sc, baseband_atten);
	bcw_radio_write16(sc, 0x0043, radio_atten);
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0064, radio_atten);
	if (sc->sc_radio_ver == 0x2050)
		bcw_radio_write16(sc, 0x0052, (bcw_radio_read16(sc, 0x0052) &
		    ~0x0070) | ((txpower << 4) & 0x0070));

	/* XXX unclear specs */
	if (sc->sc_phy_type == BCW_PHY_TYPEG)
		bcw_phy_lo_adjust(sc, 0);
}

uint16_t
bcw_radio_init2050(struct bcw_softc *sc)
{
	uint16_t backup[19] = { 0 };
	uint16_t r;
	uint16_t i, j;
	uint32_t tmp1 = 0, tmp2 = 0;

	backup[0]  = bcw_radio_read16(sc, 0x0043);
	backup[14] = bcw_radio_read16(sc, 0x0051);
	backup[15] = bcw_radio_read16(sc, 0x0052);
	backup[1]  = bcw_phy_read16(sc, 0x0015);
	backup[16] = bcw_phy_read16(sc, 0x005a);
	backup[17] = bcw_phy_read16(sc, 0x0059);
	backup[18] = bcw_phy_read16(sc, 0x0058);
	if (sc->sc_phy_type == BCW_PHY_TYPEB) {
		backup[2] = bcw_phy_read16(sc, 0x0030);
		backup[3] = BCW_READ16(sc, 0x03ec);
		bcw_phy_write16(sc, 0x0030, 0x00ff);
		BCW_WRITE16(sc, 0x03ec, 0x3f3f);
	} else {
		if (sc->sc_phy_connected) {
			backup[4] = bcw_phy_read16(sc, 0x0811);
			backup[5] = bcw_phy_read16(sc, 0x0812);
			backup[6] = bcw_phy_read16(sc, 0x0814);
			backup[7] = bcw_phy_read16(sc, 0x0815);
			backup[8] = bcw_phy_read16(sc, BCW_PHY_G_CRS);
			backup[9] = bcw_phy_read16(sc, 0x0802);
			bcw_phy_write16(sc, 0x0814,
			    (bcw_phy_read16(sc, 0x0814) | 0x0003));
			bcw_phy_write16(sc, 0x0815,
			    (bcw_phy_read16(sc, 0x0815) & 0xfffc));
			bcw_phy_write16(sc, BCW_PHY_G_CRS,
			    (bcw_phy_read16(sc, BCW_PHY_G_CRS) & 0x7fff));
			bcw_phy_write16(sc, 0x0802,
			    (bcw_phy_read16(sc, 0x0802) & 0xfffc));
			bcw_phy_write16(sc, 0x0811, 0x01b3);
			bcw_phy_write16(sc, 0x0812, 0x0fb2);
		}
		BCW_WRITE16(sc, BCW_MMIO_PHY_RADIO,
		    (BCW_READ16(sc, BCW_MMIO_PHY_RADIO) | 0x8000));
	}
	backup[10] = bcw_phy_read16(sc, 0x0035);
	bcw_phy_write16(sc, 0x0035, (bcw_phy_read16(sc, 0x0035) & 0xff7f));
	backup[11] = BCW_READ16(sc, 0x03e6);
	backup[12] = BCW_READ16(sc, BCW_MMIO_CHANNEL_EXT);

	/* initialization */
	if (sc->sc_phy_ver == 0)
		BCW_WRITE16(sc, 0x03e6, 0x0122);
	else {
		if (sc->sc_phy_ver >= 2)
			BCW_WRITE16(sc, 0x03e6, 0x0040);
		BCW_WRITE16(sc, BCW_MMIO_CHANNEL_EXT,
		    (BCW_READ16(sc, BCW_MMIO_CHANNEL_EXT) | 0x2000));
	}

	r = bcw_radio_calibrationvalue(sc);

	if (sc->sc_phy_type == BCW_PHY_TYPEB)
		bcw_radio_write16(sc, 0x0078, 0x0003);

	bcw_phy_write16(sc, 0x0015, 0xbfaf);
	bcw_phy_write16(sc, 0x002b, 0x1403);
	if (sc->sc_phy_connected)
		bcw_phy_write16(sc, 0x0812, 0x00b2);
	bcw_phy_write16(sc, 0x0015, 0xbfa0);
	bcw_radio_write16(sc, 0x0051, (bcw_radio_read16(sc, 0x0051) |
	    0x0004));
	bcw_radio_write16(sc, 0x0052, 0);
	bcw_radio_write16(sc, 0x0043, bcw_radio_read16(sc, 0x0043) | 0x0009);
	bcw_phy_write16(sc, 0x0058, 0);

	for (i = 0; i < 16; i++) {
		bcw_phy_write16(sc, 0x005a, 0x0480);
		bcw_phy_write16(sc, 0x0059, 0xc810);
		bcw_phy_write16(sc, 0x0058, 0x000d);
		if (sc->sc_phy_connected)
			bcw_phy_write16(sc, 0x0812, 0x30b2);
		bcw_phy_write16(sc, 0x0015, 0xafb0);
		delay(10);
		if (sc->sc_phy_connected)
			bcw_phy_write16(sc, 0x0812, 0x30b2);
		bcw_phy_write16(sc, 0x0015, 0xefb0);
		delay(10);
		if (sc->sc_phy_connected)
			bcw_phy_write16(sc, 0x0812, 0x30b2);
		bcw_phy_write16(sc, 0x0015, 0xfff0);
		delay(10);
		tmp1 += bcw_phy_read16(sc, 0x002d);
		bcw_phy_write16(sc, 0x0058, 0);
		if (sc->sc_phy_connected)
			bcw_phy_write16(sc, 0x0812, 0x30b2);
		bcw_phy_write16(sc, 0x0015, 0xafb0);
	}

	tmp1++;
	tmp1 >>= 9;
	delay(10);
	bcw_phy_write16(sc, 0x0058, 0);

	for (i = 0; i < 16; i++) {
		bcw_radio_write16(sc, 0x0078, (bcw_flip_4bit(i) << 1) | 0x0020);

		backup[13] = bcw_radio_read16(sc, 0x0078);
		delay(10);
		for (j = 0; j < 16; j++) {
			bcw_phy_write16(sc, 0x005a, 0x0d80);
			bcw_phy_write16(sc, 0x0059, 0xc810);
			bcw_phy_write16(sc, 0x0058, 0x000d);
			if (sc->sc_phy_connected)
				bcw_phy_write16(sc, 0x0812, 0x30b2);
			bcw_phy_write16(sc, 0x0015, 0xafb0);
			delay(10);
			if (sc->sc_phy_connected)
				bcw_phy_write16(sc, 0x0812, 0x30b2);
			bcw_phy_write16(sc, 0x0015, 0xefb0);
			delay(10);
			if (sc->sc_phy_connected)
				bcw_phy_write16(sc, 0x812, 0x30b3);
			bcw_phy_write16(sc, 0x0015, 0xfff0);
			delay(10);
			tmp2 += bcw_phy_read16(sc, 0x002d);
			bcw_phy_write16(sc, 0x0058, 0);
			if (sc->sc_phy_connected)
				bcw_phy_write16(sc, 0x0812, 0x30b2);
			bcw_phy_write16(sc, 0x0015, 0xafb0);
		}
		tmp2++;
		tmp2 >>= 8;
		if (tmp1 < tmp2)
			break;
	}

	/* restore the registers */
	bcw_phy_write16(sc, 0x0015, backup[1]);
	bcw_radio_write16(sc, 0x0051, backup[14]);
	bcw_radio_write16(sc, 0x0052, backup[15]);
	bcw_radio_write16(sc, 0x0043, backup[0]);
	bcw_phy_write16(sc, 0x005a, backup[16]);
	bcw_phy_write16(sc, 0x0059, backup[17]);
	bcw_phy_write16(sc, 0x0058, backup[18]);
	BCW_WRITE16(sc, 0x03e6, backup[11]);
	if (sc->sc_phy_ver != 0)
		BCW_WRITE16(sc, BCW_MMIO_CHANNEL_EXT, backup[12]);
	bcw_phy_write16(sc, 0x0035, backup[10]);
	bcw_radio_select_channel(sc, sc->sc_radio_channel, 1);
	if (sc->sc_phy_type == BCW_PHY_TYPEB) {
		bcw_phy_write16(sc, 0x0030, backup[2]);
		BCW_WRITE16(sc, 0x03ec, backup[3]);
	} else {
		BCW_WRITE16(sc, BCW_MMIO_PHY_RADIO,
		    (BCW_READ16(sc, BCW_MMIO_PHY_RADIO) & 0x7fff));
		if (sc->sc_phy_connected) {
			bcw_phy_write16(sc, 0x0811, backup[4]);
			bcw_phy_write16(sc, 0x0812, backup[5]);
			bcw_phy_write16(sc, 0x0814, backup[6]);
			bcw_phy_write16(sc, 0x0815, backup[7]);
			bcw_phy_write16(sc, BCW_PHY_G_CRS, backup[8]);
			bcw_phy_write16(sc, 0x0802, backup[9]);
		}
	}
	if (i >= 15)
		r = backup[13];

	return (r);
}

void
bcw_radio_init2060(struct bcw_softc *sc)
{
	int error;

	bcw_radio_write16(sc, 0x0004, 0x00c0);
	bcw_radio_write16(sc, 0x0005, 0x0008);
	bcw_radio_write16(sc, 0x0009, 0x0040);
	bcw_radio_write16(sc, 0x0005, 0x00aa);
	bcw_radio_write16(sc, 0x0032, 0x008f);
	bcw_radio_write16(sc, 0x0006, 0x008f);
	bcw_radio_write16(sc, 0x0034, 0x008f);
	bcw_radio_write16(sc, 0x002c, 0x0007);
	bcw_radio_write16(sc, 0x0082, 0x0080);
	bcw_radio_write16(sc, 0x0080, 0x0000);
	bcw_radio_write16(sc, 0x003f, 0x00d4);
	bcw_radio_write16(sc, 0x0005, bcw_radio_read16(sc, 0x0005) & ~0x0008);
	bcw_radio_write16(sc, 0x0081, bcw_radio_read16(sc, 0x0081) & ~0x0010);
	bcw_radio_write16(sc, 0x0081, bcw_radio_read16(sc, 0x0081) & ~0x0020);
	bcw_radio_write16(sc, 0x0081, bcw_radio_read16(sc, 0x0081) & ~0x0020);
	delay(400);
	bcw_radio_write16(sc, 0x0081, (bcw_radio_read16(sc, 0x0081) & ~0x0020) |
	    0x0010);
	delay(400);
	bcw_radio_write16(sc, 0x0005, (bcw_radio_read16(sc, 0x0005) & ~0x0020) |
	    0x0008);
	bcw_radio_write16(sc, 0x0085, bcw_radio_read16(sc, 0x0085) & ~0x0010);
	bcw_radio_write16(sc, 0x0005, bcw_radio_read16(sc, 0x0005) & ~0x0008);
	bcw_radio_write16(sc, 0x0081, bcw_radio_read16(sc, 0x0081) & ~0x0040);
	bcw_radio_write16(sc, 0x0081, (bcw_radio_read16(sc, 0x0081) & ~0x0040) |
	    0x0040);
	bcw_radio_write16(sc, 0x0005, (bcw_radio_read16(sc, 0x0081) & ~0x0008) |
	    0x0008);
	bcw_phy_write16(sc, 0x0063, 0xddc6);
	bcw_phy_write16(sc, 0x0069, 0x07be);
	bcw_phy_write16(sc, 0x006a, 0x0000);

	error = bcw_radio_select_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_A, 0);

	delay(1000);
}

void
bcw_radio_spw(struct bcw_softc *sc, uint8_t channel)
{
	if (sc->sc_radio_ver != 0x2050 || sc->sc_radio_rev >= 6)
		/* we do not need the workaround */
		return;

	if (channel <= 10)
		BCW_WRITE16(sc, BCW_MMIO_CHANNEL,
		    bcw_radio_chan2freq_bg(channel + 4));
	else
		BCW_WRITE16(sc, BCW_MMIO_CHANNEL, bcw_radio_chan2freq_bg(1));

	delay(100);

	BCW_WRITE16(sc, BCW_MMIO_CHANNEL, bcw_radio_chan2freq_bg(channel));
}

int
bcw_radio_select_channel(struct bcw_softc *sc, uint8_t channel, int spw)
{
	uint16_t freq, tmp, r8;

	if (sc->sc_radio_mnf == 0x17f && sc->sc_radio_ver == 0x2060 &&
	    sc->sc_radio_rev == 1) {
		freq = bcw_radio_chan2freq_a(channel);

		r8 = bcw_radio_read16(sc, 0x0008);
		BCW_WRITE16(sc, 0x03f0, freq);
		bcw_radio_write16(sc, 0x0008, r8);

		tmp = bcw_radio_read16(sc, 0x002e);
		tmp &= 0x0080;

		bcw_radio_write16(sc, 0x002e, tmp);

		if (freq >= 4920 && freq <= 5500)
			r8 = 3 * freq / 116;
		bcw_radio_write16(sc, 0x0007, (r8 << 4) | r8);
		bcw_radio_write16(sc, 0x0020, (r8 << 4) | r8);
		bcw_radio_write16(sc, 0x0021, (r8 << 4) | r8);
		bcw_radio_write16(sc, 0x0022, (bcw_radio_read16(sc, 0x0022) &
		    0x000f) | (r8 << 4));
		bcw_radio_write16(sc, 0x002a, (r8 << 4));
		bcw_radio_write16(sc, 0x002b, (r8 << 4));
		bcw_radio_write16(sc, 0x0008, (bcw_radio_read16(sc, 0x0008) &
		    0x00f0) | (r8 << 4));
		bcw_radio_write16(sc, 0x0029, (bcw_radio_read16(sc, 0x0029) &
		    0xff0f) | 0x00b0);
		bcw_radio_write16(sc, 0x0035, 0x00aa);
		bcw_radio_write16(sc, 0x0036, 0x0085);
		bcw_radio_write16(sc, 0x003a, (bcw_radio_read16(sc, 0x003a) &
		    0xff20) | bcw_radio_freq_r3a_value(freq));
		bcw_radio_write16(sc, 0x003d, bcw_radio_read16(sc, 0x003d) &
		    0x00ff);
		bcw_radio_write16(sc, 0x0081, (bcw_radio_read16(sc, 0x0081) &
		    0xff7f) | 0x0080);
		bcw_radio_write16(sc, 0x0035, bcw_radio_read16(sc, 0x0035) &
		    0xffef);
		bcw_radio_write16(sc, 0x0035, (bcw_radio_read16(sc, 0x0035) &
		    0xffef) | 0x0010);
		bcw_radio_set_tx_iq(sc);
		bcw_phy_xmitpower(sc);
	} else {
		if (spw)
			bcw_radio_spw(sc, channel);
		
		BCW_WRITE16(sc, BCW_MMIO_CHANNEL,
		    bcw_radio_chan2freq_bg(channel));

		if (channel == 14) {
			/* TODO */
		} else {
			BCW_WRITE16(sc, BCW_MMIO_CHANNEL_EXT,
			    BCW_READ16(sc, BCW_MMIO_CHANNEL_EXT) & 0xf7bf);
		}
	}

	sc->sc_radio_channel = channel;

	delay(8000);

	return (0);
}

uint16_t
bcw_radio_chan2freq_a(uint8_t channel)
{
	return (5000 + 5 * channel);
}

uint16_t
bcw_radio_chan2freq_bg(uint8_t channel)
{
	static const uint16_t freqs_bg[14] = {
	    12, 17, 22, 27,
	    32, 37, 42, 47,
	    52, 57, 62, 67,
	    72, 84 };

	if (channel < 1 && channel > 14)
		return (0);

	return (freqs_bg[channel - 1]);
}

uint16_t
bcw_radio_default_baseband_atten(struct bcw_softc *sc)
{
	if (sc->sc_radio_ver == 0x2050 && sc->sc_radio_rev < 6)
		return (0);

	return (2);
}

uint16_t
bcw_radio_default_radio_atten(struct bcw_softc *sc)
{
	uint16_t att = 0xffff;

	if (sc->sc_phy_type == BCW_PHY_TYPEA)
		return (0x60);

	switch (sc->sc_radio_ver) {
	case 0x2053:
		switch (sc->sc_radio_rev) {
		case 1:
			att = 6;
			break;
		}
		break;
	case 0x2050:
		switch (sc->sc_radio_rev) {
		case 0:
			att = 5;
			break;
		case 1:
			if (sc->sc_phy_type == BCW_PHY_TYPEG) {
				if (sc->sc_board_vendor ==
				    PCI_VENDOR_BROADCOM &&
				    sc->sc_board_type == 0x0421 &&
				    sc->sc_board_rev >= 30)
					att = 3;
				else if (sc->sc_board_vendor ==
				    PCI_VENDOR_BROADCOM &&
				    sc->sc_board_type == 0x0416)
					att = 3;
				else
						att = 1;
			} else {
				if (sc->sc_board_vendor ==
				    PCI_VENDOR_BROADCOM &&
				    sc->sc_board_type == 0x0421 &&
				    sc->sc_board_rev >= 30)
					att = 7;
				else
					att = 6;
			}
			break;
		case 2:
			if (sc->sc_phy_type == BCW_PHY_TYPEG) {
				if (sc->sc_board_vendor ==
				    PCI_VENDOR_BROADCOM &&
				    sc->sc_board_type == 0x0421 &&
				    sc->sc_board_rev >= 30)
					att = 3;
				else if (sc->sc_board_vendor ==
				    PCI_VENDOR_BROADCOM &&
				    sc->sc_board_type == 0x0416)
					att = 5;
				else if (sc->sc_chip_id == 0x4320)
					att = 4;
				else
					att = 3;
			} else
				att = 6;
			break;
		case 3:
			att = 5;
			break;
		case 4:
		case 5:
			att = 1;
			break;
		case 6:
		case 7:
			att = 5;
			break;
		case 8:
			att = 0x1a;
			break;
		case 9:
		default:
			att = 5;
		}
	}
	if (sc->sc_board_vendor == PCI_VENDOR_BROADCOM &&
	    sc->sc_board_type == 0x0421) {
		if (sc->sc_board_rev < 0x43)
			att = 2;
		else if (sc->sc_board_rev < 0x51)
			att = 3; 
	}
	if (att == 0x0ffff)
		att = 5;

	return (att);
}

uint16_t
bcw_radio_default_txctl1(struct bcw_softc *sc)
{
	if (sc->sc_radio_ver != 0x2050)
		return (0);
	if (sc->sc_radio_rev == 1)
		return (3);
	if (sc->sc_radio_rev < 6)
		return (2);
	if (sc->sc_radio_rev == 8)
		return (1);

	return (0);
}

void
bcw_radio_clear_tssi(struct bcw_softc *sc)
{
	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0068, 0x7f7f);
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x006a, 0x7f7f);
		break;
	case BCW_PHY_TYPEB:
	case BCW_PHY_TYPEG:
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0058, 0x7f7f);
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x005a, 0x7f7f);
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0070, 0x7f7f);
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0072, 0x7f7f);
		break;
	}
}

void
bcw_radio_set_tx_iq(struct bcw_softc *sc)
{
	const uint8_t data_high[5] = { 0x00, 0x40, 0x80, 0x90, 0xD0 };
	const uint8_t data_low[5] = { 0x00, 0x01, 0x05, 0x06, 0x0A };
	uint16_t tmp = bcw_radio_read16(sc, 0x001e);
	int i, j;

	for (i = 0; i < 5; i++) {
		for (j = 0; j < 5; j++) {
			if (tmp == (data_high[i] << 4 | data_low[j])) {
				bcw_phy_write16(sc, 0x0069, (i - j) << 8 |
				    0x00c0);
				return;
			}
		}
	}
}

uint16_t
bcw_radio_get_txgain_baseband(uint16_t txpower)
{
	uint16_t r;

	if (txpower >= 54)
		r = 2;
	else if (txpower >= 49)
		r = 4;
	else if (txpower >= 44)
		r = 5;
	else
		r = 6;

	return (r);
}

uint16_t
bcw_radio_get_txgain_freq_power_amp(uint16_t txpower)
{
	uint16_t r;

	if (txpower >= 32)
		r = 0;
	else if (txpower >= 25)
		r = 1;
	else if (txpower >= 20)
		r = 2;
	else if (txpower >= 12)
		r = 3;
	else
		r = 4;

	return (r);
}

uint16_t
bcw_radio_get_txgain_dac(uint16_t txpower)
{
	uint16_t r;

	if (txpower >= 54)
		r = txpower - 53;
	else if (txpower >= 49)
		r = txpower - 42;
	else if (txpower >= 44)
		r = txpower - 37;
	else if (txpower >= 32)
		r = txpower - 32;
	else if (txpower >= 25)
		r = txpower - 20;
	else if (txpower >= 20)
		r = txpower - 13;
	else if (txpower >= 12)
		r = txpower - 8;
	else
		r = txpower;

	return (r);
}

uint16_t
bcw_radio_freq_r3a_value(uint16_t frequency)
{
	uint16_t val;

	if (frequency < 5091)
		val = 0x0040;
	else if (frequency < 5321)
		val = 0;
	else if (frequency < 5806)
		val = 0x0080;
	else
		val = 0x0040;

	return (val);
}

int
bcw_radio_set_interf_mitigation(struct bcw_softc *sc, int mode)
{
	int currentmode;

	if (sc->sc_phy_type != BCW_PHY_TYPEG || sc->sc_phy_type == 0 ||
	    sc->sc_phy_connected == 0)
		return (ENODEV);

	sc->sc_radio_aci_wlan_automatic = 0;
	switch (mode) {
	case BCW_RADIO_INTERFMODE_AUTOWLAN:
		sc->sc_radio_aci_wlan_automatic = 1;
		if (sc->sc_radio_aci_enable)
			mode = BCW_RADIO_INTERFMODE_MANUALWLAN;
		else
			mode = BCW_RADIO_INTERFMODE_NONE;
		break;
	case BCW_RADIO_INTERFMODE_NONE:
	case BCW_RADIO_INTERFMODE_NONWLAN:
	case BCW_RADIO_INTERFMODE_MANUALWLAN:
		break;
	default:
		return (EINVAL);
	}

	currentmode = sc->sc_radio_interfmode;
	if (currentmode == mode)
		return (0);
	if (currentmode != BCW_RADIO_INTERFMODE_NONE) {
		sc->sc_radio_aci_enable = 0;
		sc->sc_radio_aci_hw_rssi = 0;
	} else
		bcw_radio_interf_mitigation_enable(sc, mode);
	sc->sc_radio_interfmode = mode;

	return (0);
}

int
bcw_radio_interf_mitigation_enable(struct bcw_softc *sc, int mode)
{
	uint16_t tmp, flipped;
	uint32_t tmp32;
	size_t stackidx = 0;
	uint32_t *stack = sc->sc_radio_interfstack;

	switch (mode) {
	case BCW_RADIO_INTERFMODE_NONWLAN:
		if (sc->sc_phy_rev != 1) {
			bcw_phy_write16(sc, 0x042b,
			    bcw_phy_read16(sc, 0x042b) | 0x0800);
			bcw_phy_write16(sc, BCW_PHY_G_CRS,
			    bcw_phy_read16(sc, BCW_PHY_G_CRS) & ~0x4000);
			break;
		}
		BCW_RADIO_STACKSAVE(0x0078);
		tmp = (bcw_radio_read16(sc, 0x0078) & 0x001e);
		flipped = bcw_flip_4bit(tmp);
		if (flipped < 10 && flipped >= 8)
			flipped = 7;
		else if (flipped >= 10)
			flipped -= 3;
		flipped = bcw_flip_4bit(flipped);
		flipped = (flipped << 1) | 0x0020;
		bcw_radio_write16(sc, 0x0078, flipped);

		bcw_radio_calc_nrssi_threshold(sc);

		BCW_PHY_STACKSAVE(0x0406);
		bcw_phy_write16(sc, 0x0406, 0x7e28);

		bcw_phy_write16(sc, 0x042b,
		    bcw_phy_read16(sc, 0x042b) | 0x08000);
		bcw_phy_write16(sc, BCW_PHY_RADIO_BITFIELD,
		    bcw_phy_read16(sc, BCW_PHY_RADIO_BITFIELD) | 0x1000);
		BCW_PHY_STACKSAVE(0x04a0);
		bcw_phy_write16(sc, 0x04a0,
		    (bcw_phy_read16(sc, 0x04a0) & 0xc0c0) | 0x0008);
		BCW_PHY_STACKSAVE(0x04a1);
		bcw_phy_write16(sc, 0x04a1,
		    (bcw_phy_read16(sc, 0x04a1) & 0xc0c0) | 0x0605);
		BCW_PHY_STACKSAVE(0x04a2);
		bcw_phy_write16(sc, 0x04a2,
		    (bcw_phy_read16(sc, 0x04a2) & 0xc0c0) | 0x0204);
		BCW_PHY_STACKSAVE(0x04a8);
		bcw_phy_write16(sc, 0x04a8,
		    (bcw_phy_read16(sc, 0x04a8) & 0xc0c0) | 0x0803);
		BCW_PHY_STACKSAVE(0x04ab);
		bcw_phy_write16(sc, 0x04ab,
		    (bcw_phy_read16(sc, 0x04ab) & 0xc0c0) | 0x0605);

		BCW_PHY_STACKSAVE(0x04a7);
		bcw_phy_write16(sc, 0x04a7, 0x0002);
		BCW_PHY_STACKSAVE(0x04a3);
		bcw_phy_write16(sc, 0x04a3, 0x287a);
		BCW_PHY_STACKSAVE(0x04a9);
		bcw_phy_write16(sc, 0x04a9, 0x2027);
		BCW_PHY_STACKSAVE(0x0493);
		bcw_phy_write16(sc, 0x0493, 0x32f5);
		BCW_PHY_STACKSAVE(0x04aa);
		bcw_phy_write16(sc, 0x04aa, 0x2027);
		BCW_PHY_STACKSAVE(0x04ac);
		bcw_phy_write16(sc, 0x04ac, 0x32f5);
		break;
	case BCW_RADIO_INTERFMODE_MANUALWLAN:
		if (bcw_phy_read16(sc, 0x0033) & 0x0800)
			break;

		sc->sc_radio_aci_enable = 1;

		BCW_PHY_STACKSAVE(BCW_PHY_RADIO_BITFIELD);
		BCW_PHY_STACKSAVE(BCW_PHY_G_CRS);
		if (sc->sc_phy_rev < 2)
			BCW_PHY_STACKSAVE(0x0406);
		else {
			BCW_PHY_STACKSAVE(0x04c0);
			BCW_PHY_STACKSAVE(0x04c1);
		}
		BCW_PHY_STACKSAVE(0x0033);
		BCW_PHY_STACKSAVE(0x04a7);
		BCW_PHY_STACKSAVE(0x04a3);
		BCW_PHY_STACKSAVE(0x04a9);
		BCW_PHY_STACKSAVE(0x04aa);
		BCW_PHY_STACKSAVE(0x04ac);
		BCW_PHY_STACKSAVE(0x0493);
		BCW_PHY_STACKSAVE(0x04a1);
		BCW_PHY_STACKSAVE(0x04a0);
		BCW_PHY_STACKSAVE(0x04a2);
		BCW_PHY_STACKSAVE(0x048a);
		BCW_PHY_STACKSAVE(0x04a8);
		BCW_PHY_STACKSAVE(0x04ab);
		if (sc->sc_phy_rev == 2) {
			BCW_PHY_STACKSAVE(0x04ad);
			BCW_PHY_STACKSAVE(0x04ae);
		} else if (sc->sc_phy_rev >= 3) {
			BCW_PHY_STACKSAVE(0x04ad);
			BCW_PHY_STACKSAVE(0x0415);
			BCW_PHY_STACKSAVE(0x0416);
			BCW_PHY_STACKSAVE(0x0417);
			BCW_ILT_STACKSAVE(0x1a00 + 0x2);
			BCW_ILT_STACKSAVE(0x1a00 + 0x3);
		}
		BCW_PHY_STACKSAVE(0x042b);
		BCW_PHY_STACKSAVE(0x048c);

		bcw_phy_write16(sc, BCW_PHY_RADIO_BITFIELD,
		    bcw_phy_read16(sc, BCW_PHY_RADIO_BITFIELD) & ~0x1000);
		bcw_phy_write16(sc, BCW_PHY_G_CRS,
		    (bcw_phy_read16(sc, BCW_PHY_G_CRS) & 0xfffc) | 0x0002);

		bcw_phy_write16(sc, 0x0033, 0x0800);
		bcw_phy_write16(sc, 0x04a3, 0x2027);
		bcw_phy_write16(sc, 0x04a9, 0x1ca8);
		bcw_phy_write16(sc, 0x0493, 0x287a);
		bcw_phy_write16(sc, 0x04aa, 0x1ca8);
		bcw_phy_write16(sc, 0x04ac, 0x287a);

		bcw_phy_write16(sc, 0x04a0,
		    (bcw_phy_read16(sc, 0x04a0) & 0xffc0) | 0x001a);
		bcw_phy_write16(sc, 0x04a7, 0x000d);

		if (sc->sc_phy_rev < 2) {
			bcw_phy_write16(sc, 0x0406, 0xff0d);
		} else if (sc->sc_phy_rev == 2) {
			bcw_phy_write16(sc, 0x04c0, 0xffff);
			bcw_phy_write16(sc, 0x04c1, 0x00a9);
		} else {
			bcw_phy_write16(sc, 0x04c0, 0x00c1);
			bcw_phy_write16(sc, 0x04c1, 0x0059);
		}

		bcw_phy_write16(sc, 0x04a1,
		    (bcw_phy_read16(sc, 0x04a1) & 0xc0ff) | 0x1800);
		bcw_phy_write16(sc, 0x04a1,
		    (bcw_phy_read16(sc, 0x04a1) & 0xc0ff) | 0x0015);
		bcw_phy_write16(sc, 0x04a8,
		    (bcw_phy_read16(sc, 0x04a8) & 0xcfff) | 0x1000);
		bcw_phy_write16(sc, 0x04a8,
		    (bcw_phy_read16(sc, 0x04a8) & 0xf0ff) | 0x0a00);
		bcw_phy_write16(sc, 0x04ab,
		    (bcw_phy_read16(sc, 0x04a8) & 0xcfff) | 0x1000);
		bcw_phy_write16(sc, 0x04ab,
		    (bcw_phy_read16(sc, 0x04ab) & 0xf0ff) | 0x0800);
		bcw_phy_write16(sc, 0x04ab,
		    (bcw_phy_read16(sc, 0x04ab) & 0xf0ff) | 0x0010);
		bcw_phy_write16(sc, 0x04ab,
		    (bcw_phy_read16(sc, 0x04ab) & 0xfff0) | 0x0005);
		bcw_phy_write16(sc, 0x04a8,
		    (bcw_phy_read16(sc, 0x04a8) & 0xffcf) | 0x0010);
		bcw_phy_write16(sc, 0x04a8,
		    (bcw_phy_read16(sc, 0x04a8) & 0xfff0) | 0x0006);
		bcw_phy_write16(sc, 0x04a2,
		    (bcw_phy_read16(sc, 0x04a2) & 0xf0ff) | 0x0800);
		bcw_phy_write16(sc, 0x04a0,
		    (bcw_phy_read16(sc, 0x04a0) & 0xf0ff) | 0x0500);
		bcw_phy_write16(sc, 0x04a2,
		    (bcw_phy_read16(sc, 0x04a2) & 0xfff0) | 0x000b);

		if (sc->sc_phy_rev >= 3) {
			bcw_phy_write16(sc, 0x048a,
			    bcw_phy_read16(sc, 0x048a) & ~0x8000);
			bcw_phy_write16(sc, 0x0415,
			    (bcw_phy_read16(sc, 0x0415) & 0x8000) | 0x36d8);
			bcw_phy_write16(sc, 0x0416,
			    (bcw_phy_read16(sc, 0x0416) & 0x8000) | 0x36d8);
			bcw_phy_write16(sc, 0x0417,
			    (bcw_phy_read16(sc, 0x0417) & 0xfe00) | 0x016d);
		} else {
			bcw_phy_write16(sc, 0x048a,
			    bcw_phy_read16(sc, 0x048a) | 0x1000);
			bcw_phy_write16(sc, 0x048a,
			    (bcw_phy_read16(sc, 0x048a) & 0x9fff) | 0x2000);
			tmp32 = bcw_shm_read16(sc, BCW_SHM_SHARED,
			    BCW_UCODEFLAGS_OFFSET);
			if (!(tmp32 & 0x800)) {
				tmp32 |= 0x800;
				bcw_shm_write16(sc, BCW_SHM_SHARED,
				    BCW_UCODEFLAGS_OFFSET, tmp32);
			}
		}
		if (sc->sc_phy_rev >= 2) {
			bcw_phy_write16(sc, 0x042b, bcw_phy_read16(sc, 0x042b) |
			    0x0800);
		}
		bcw_phy_write16(sc, 0x048c, (bcw_phy_read16(sc, 0x048c) &
		    0xff00) | 0x007f);
		if (sc->sc_phy_rev == 2) {
			bcw_phy_write16(sc, 0x04ae,
			    (bcw_phy_read16(sc, 0x04ae) & 0xff00) | 0x007f);
			bcw_phy_write16(sc, 0x04ad,
			    (bcw_phy_read16(sc, 0x04ad) & 0x00ff) | 0x1300);
		} else if (sc->sc_phy_rev >= 6) {
			bcw_ilt_write(sc, 0x1a00 + 0x3, 0x007f);
			bcw_ilt_write(sc, 0x1a00 + 0x2, 0x007f);
			bcw_phy_write16(sc, 0x04ad,
			    bcw_phy_read16(sc, 0x04ad) & 0x00ff);
		}
		bcw_radio_calc_nrssi_slope(sc);
		break;
	default:
		 /* XXX panic()? */
		break;
	}

	return (0);
}

void
bcw_radio_set_txantenna(struct bcw_softc *sc, uint32_t val)
{
	uint16_t tmp;

	val <<= 8;
	tmp = bcw_shm_read16(sc, BCW_SHM_SHARED, 0x0022) & 0xfcff;
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0022, tmp | val);
	tmp = bcw_shm_read16(sc, BCW_SHM_SHARED, 0x03a8) & 0xfcff;
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x03a8, tmp | val);
	tmp = bcw_shm_read16(sc, BCW_SHM_SHARED, 0x0054) & 0xfcff;
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0054, tmp | val);
}

void
bcw_radio_lock(struct bcw_softc *sc)
{
	uint32_t status;

	status = BCW_READ(sc, BCW_MMIO_SBF);
	status |= BCW_SBF_RADIOREG_LOCK;
	BCW_WRITE(sc, BCW_MMIO_SBF, status);
	delay(10);
}

void
bcw_radio_unlock(struct bcw_softc *sc)
{
	uint32_t status;

	BCW_READ16(sc, 0x3e0);
	status = BCW_READ(sc, BCW_MMIO_SBF);
	status &= ~BCW_SBF_RADIOREG_LOCK;
	BCW_WRITE(sc, BCW_MMIO_SBF, status);
}

/*
 * ILT
 */
void
bcw_ilt_write(struct bcw_softc *sc, uint16_t offset, uint16_t val)
{
	if (sc->sc_phy_type == BCW_PHY_TYPEA) {
		bcw_phy_write16(sc, BCW_PHY_ILT_A_CTRL, offset);
		bcw_phy_write16(sc, BCW_PHY_ILT_A_DATA1, val);
	} else {
		bcw_phy_write16(sc, BCW_PHY_ILT_G_CTRL, offset);
		bcw_phy_write16(sc, BCW_PHY_ILT_G_DATA1, val);
	}
}

uint16_t
bcw_ilt_read(struct bcw_softc *sc, uint16_t offset)
{
        if (sc->sc_phy_type == BCW_PHY_TYPEA) {
                bcw_phy_write16(sc, BCW_PHY_ILT_A_CTRL, offset);
                return (bcw_phy_read16(sc, BCW_PHY_ILT_A_DATA1));
        } else {
                bcw_phy_write16(sc, BCW_PHY_ILT_G_CTRL, offset);
                return (bcw_phy_read16(sc, BCW_PHY_ILT_G_DATA1));
        }
}

/*
 * Power Control
 */
void
bcw_pc_crystal_on(struct bcw_softc *sc)
{
	uint32_t val;

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOI);
	if (val & BCW_PCTL_XTAL_POWERUP)
		return; /* crystal is already on */

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOO);
	val |= (BCW_PCTL_XTAL_POWERUP | BCW_PCTL_PLL_POWERDOWN);
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOO, val);
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOE, val);

	delay(1000);

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOO);
	val &= ~BCW_PCTL_PLL_POWERDOWN;
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOO, val);

	delay(5000);
}

void
bcw_pc_crystal_off(struct bcw_softc *sc)
{
	uint32_t val;

	/* TODO return if radio is hardware disabled */

	if (sc->sc_chip_rev < 5)
		return;
	if (sc->sc_sprom.boardflags & BCW_BF_XTAL)
		return;

	bcw_pc_set_clock(sc, BCW_PCTL_CLK_SLOW);

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOO);
	val |= BCW_PCTL_PLL_POWERDOWN;
	val &= ~BCW_PCTL_XTAL_POWERUP;
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOO, val);

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOE);
	val |= (BCW_PCTL_PLL_POWERDOWN | BCW_PCTL_XTAL_POWERUP);
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOE, val);
}

int
bcw_pc_init(struct bcw_softc *sc)
{
	int maxfreq;
	int error;

	if ((error = bcw_change_core(sc, 0)))
		return (error);

	if (sc->sc_chip_id == 0x4321) {
		if (sc->sc_chip_rev == 1)
			BCW_WRITE(sc, BCW_CHIPCOMMON_CTL, 0x00a4);
		if (sc->sc_chip_rev == 0)
			BCW_WRITE(sc, BCW_CHIPCOMMON_CTL, 0x03a4);
	}

	if (!(sc->sc_chip_common_capa & BCW_CAPABILITIES_PCTL))
		return (ENODEV); /* no power control */

	if (sc->sc_core[sc->sc_currentcore].rev >= 10) {
		BCW_WRITE(sc, BCW_CHIPCOMMON_SYSCLKCTL,
		    (BCW_READ(sc, BCW_CHIPCOMMON_SYSCLKCTL) & 0x0000ffff) |
		    0x40000);
	} else {
		maxfreq = bcw_pc_clock_freqlimit(sc, 1);
		BCW_WRITE(sc, BCW_CHIPCOMMON_PLLONDELAY,
		    (maxfreq * 150 + 99999) / 1000000);
		BCW_WRITE(sc, BCW_CHIPCOMMON_FREFSELDELAY,
		    (maxfreq * 15 + 99999) / 100000);
	}

	if ((error = bcw_change_core(sc, sc->sc_lastcore)))
		return (error);

	return (0);
}

int
bcw_pc_set_clock(struct bcw_softc *sc, uint16_t mode)
{
	int error;
	uint32_t tmp;

	if ((error = bcw_change_core(sc, 0)))
		return (error);

	if (sc->sc_core[sc->sc_currentcore].rev < 6) {
		if (mode == BCW_PCTL_CLK_FAST)
			bcw_pc_crystal_on(sc);
	} else if (sc->sc_chip_common_capa & BCW_CAPABILITIES_PCTL &&
	    sc->sc_core[sc->sc_currentcore].rev < 10) {
		switch (mode) {
		case BCW_PCTL_CLK_FAST:
			tmp = BCW_READ(sc, BCW_CHIPCOMMON_SLOWCLKCTL);
			tmp = (tmp & ~BCW_PCTL_FORCE_SLOW) |
			    BCW_PCTL_FORCE_PLL;
			BCW_WRITE(sc, BCW_CHIPCOMMON_SLOWCLKCTL, tmp);
			break;
		case BCW_PCTL_CLK_SLOW:
			tmp = BCW_READ(sc, BCW_CHIPCOMMON_SLOWCLKCTL);
			tmp |= BCW_PCTL_FORCE_SLOW;
			BCW_WRITE(sc, BCW_CHIPCOMMON_SLOWCLKCTL, tmp);
			break;
		case BCW_PCTL_CLK_DYNAMIC:
			tmp = BCW_READ(sc, BCW_CHIPCOMMON_SLOWCLKCTL);
			tmp &= ~BCW_PCTL_FORCE_SLOW;
			tmp |= BCW_PCTL_FORCE_PLL;
			tmp &= ~BCW_PCTL_DYN_XTAL;
			BCW_WRITE(sc, BCW_CHIPCOMMON_SLOWCLKCTL, tmp);
			break;
		}
	}

	if ((error = bcw_change_core(sc, sc->sc_lastcore)))
		return (error);
	
	return (0);
}

void
bcw_pc_saving_ctl_bits(struct bcw_softc *sc, int bit25, int bit26)
{
	int i;
	uint32_t status;

	bit25 = 0;
	bit26 = 1;

	if (bit25 == -1) {
		/* TODO */
	}
	if (bit26 == -1) {
		/* TODO */
	}

	status = BCW_READ(sc, BCW_MMIO_SBF);
	if (bit25)
		status |= BCW_SBF_PS1;
	else
		status &= ~BCW_SBF_PS1;
	if (bit26)
		status |= BCW_SBF_PS2;
	else
		status &= ~BCW_SBF_PS2;
	BCW_WRITE(sc, BCW_MMIO_SBF, status);
	if (bit26 && sc->sc_core[sc->sc_currentcore].rev >= 5) {
		for (i = 0; i < 100; i++) {
			if (bcw_shm_read32(sc, BCW_SHM_SHARED, 0x0040) != 4)
				break;
			delay(10);
		}
	}
}

uint16_t
bcw_pc_powerup_delay(struct bcw_softc *sc)
{
	uint16_t delay = 0;
	uint32_t pllondelay;
	int minfreq;

	/* TODO just for PCI bus type */

	if (!(sc->sc_chip_common_capa & BCW_CAPABILITIES_PCTL))
		return (0);

	bcw_change_core(sc, 0);

	minfreq = bcw_pc_clock_freqlimit(sc, 0);
	pllondelay = BCW_READ(sc, BCW_CHIPCOMMON_PLLONDELAY);
	delay = (((pllondelay + 2) * 1000000) + (minfreq - 1)) / minfreq;

	bcw_change_core(sc, sc->sc_lastcore);

	return (delay);
}

int
bcw_pc_clock_freqlimit(struct bcw_softc *sc, int getmax)
{
	int limit, clocksrc, divisor;
	uint32_t tmp;

	clocksrc = bcw_pc_get_slowclocksrc(sc);

	if (sc->sc_core[sc->sc_currentcore].rev < 6) {
		switch (clocksrc) {
		case 0:
			divisor = 64;
			break;
		case 1:
			divisor = 32;
			break;
		default:
			/* XXX panic()? */
			divisor = 1;
		}
	} else if (sc->sc_core[sc->sc_currentcore].rev < 10) {
		switch (clocksrc) {
		case 2:
			divisor = 1;
			break;
		case 1:
		case 0:
			tmp = BCW_READ(sc, 0xb8);
			divisor = ((tmp & 0xffff0000) >> 16) + 1;
			divisor *= 4;
			break;
		default:
			/* XXX panic()? */
			divisor = 1;
		}
	} else {
		tmp = BCW_READ(sc, 0xb8);
		divisor = ((tmp & 0xffff0000) >> 16) + 1;
		divisor *= 4;
	}

	switch (clocksrc) {
	case 2:
		if (getmax)
			limit = 43000;
		else
			limit = 25000;
		break;
	case 1:
		if (getmax)
			limit = 20200000;
		else
			limit = 19800000;
		break;
	case 0:
		if (getmax)
			limit = 34000000;
		else
			limit = 25000000;
		break;
	default:
		/* panic()? */
		limit = 0;
	}

	limit /= divisor;

	return (limit);
			
}

int
bcw_pc_get_slowclocksrc(struct bcw_softc *sc)
{
	uint32_t tmp;

	if (sc->sc_core[sc->sc_currentcore].rev < 6) {
		/* TODO check bus type */
		tmp = (sc->sc_conf_read)(sc, BCW_PCTL_OUT);
		if (tmp & 0x10)
			return (0);
		return (1);
	}

	if (sc->sc_core[sc->sc_currentcore].rev < 10) {
		tmp = BCW_READ(sc, 0xb8); /* XXX */
		tmp &= 0x7;
		if (tmp == 0)
			return (2);
		if (tmp == 1)
			return (1);
		if (tmp == 2)
			return (0);
	}

	return (1);
}

/*
 * XMIT
 */
uint8_t
bcw_xmit_plcp_get_ratecode_cck(const uint8_t bitrate)
{
	if (ieee80211_std_rateset_11b.rs_rates[0] == bitrate)
		return (0x0a);
	else if (ieee80211_std_rateset_11b.rs_rates[1] == bitrate)
		return (0x14);
	else if (ieee80211_std_rateset_11b.rs_rates[2] == bitrate)
		return (0x37);
	else if (ieee80211_std_rateset_11b.rs_rates[3] == bitrate)
		return (0x6e);

	return (0);
}

uint8_t
bcw_xmit_plcp_get_ratecode_ofdm(const uint8_t bitrate)
{
	if (ieee80211_std_rateset_11g.rs_rates[0] == bitrate)
		return (0xb);
	else if (ieee80211_std_rateset_11g.rs_rates[1] == bitrate)
		return (0xf);
	else if (ieee80211_std_rateset_11g.rs_rates[2] == bitrate)
		return (0xa);
	else if (ieee80211_std_rateset_11g.rs_rates[3] == bitrate)
		return (0xe);
	else if (ieee80211_std_rateset_11g.rs_rates[4] == bitrate)
		return (0x9);
	else if (ieee80211_std_rateset_11g.rs_rates[5] == bitrate)
		return (0xd);
	else if (ieee80211_std_rateset_11g.rs_rates[6] == bitrate)
		return (0x8);
	else if (ieee80211_std_rateset_11g.rs_rates[7] == bitrate)
		return (0xc);

	return (0);
}
@


1.88
log
@Activate interference mitigation.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.87 2007/04/04 19:36:41 mglocker Exp $ */
@


1.87
log
@Debugging.  Fix a lot wrong registers.  Fix a couple of /* XXX */ and
/* TODO */ for the radio / PHY init.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.86 2007/04/01 19:15:48 mglocker Exp $ */
d2900 1
d2909 2
d2939 3
a2941 2
	if (sc->sc_phy_type == BCW_PHY_TYPEA) {
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x612, 0x2);
d2943 2
a2944 2

		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x612, 0x78);
d2946 3
@


1.86
log
@Write MAC and BSSID into devices template RAM at init time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.85 2007/04/01 12:16:28 mglocker Exp $ */
d83 1
a83 1
struct bcw_lopair *	bcw_get_lopair(struct bcw_softc *sc, uint16_t,
d92 1
a193 1
void			bcw_phy_prepare_init(struct bcw_softc *);
d197 2
a235 1
void			bcw_radio_prepare_init(struct bcw_softc *);
d241 2
d258 3
d282 5
d741 13
d783 1
a783 1
		/* XXX assert? */
a841 2
	/* XXX assert() */

a845 2

	/* XXX assert() */
a852 2
	/* XXX assert() */

a860 2
	/* XXX assert() */

d918 1
a918 1
		/* XXX assert() */
a981 2
		/* XXX do early init of sc_core[0] here */

d1071 2
d1228 1
a1228 1
			/* XXX arp_ifinit(&sc->bcw_ac, ifa); */
d1519 2
a1520 1
	}
d1562 1
a1562 1
        int error;
d1565 6
d1573 23
a1595 2
	bcw_phy_prepare_init(sc);	/* XXX probably unpack function */
	bcw_radio_prepare_init(sc);	/* XXX probably unpack function */
a2238 4
	/* TODO sc->sc_current_core_enabled = 1; */

	/* XXX assert() */

d2696 1
a2696 1
	if (0) { /* FIXME conditional unknown */
d2709 1
a2709 1
		mask |= 0x0010; /* FIXME this is redundant */
d2739 1
d2810 1
a2810 1
	BCW_WRITE(sc, 0x5c, 0xa);
d2813 1
d2818 1
a2818 1
	val32 &= ~BCW_SBF_ADHOC;
a2823 4
	val32 = BCW_READ(sc, BCW_MMIO_SBF);
	val32 |= 0x100000;
	BCW_WRITE(sc, BCW_MMIO_SBF, val32);

d2835 5
a2839 1
	BCW_WRITE(sc, 0x400, 0x8);
d2850 1
d2863 4
d2908 4
d3361 1
a3361 1
			bcw_phy_write16(sc, 0x0811, 0x0000);
a3426 1
			/* XXX assert() */
a3428 1
			/* XXX assert() */
d3840 1
a3840 1
		bcw_radio_write16(sc, 0x0019, 0x0000);
d3980 1
a3980 1
		/* XXX assert? */
a3989 2
	/* XXX assert? */

a4343 2
	/* XXX assert() */

d4463 1
a4463 1
		/* XXX assert() */
d4599 2
a4600 2
		/* TODO bcw_phy_lock() */
		/* TODO bcw_radio_lock() */
d4604 2
a4605 2
		/* TODO bcw_radio_unlock() */
		/* TODO bcw_phy_unlock() */
d4609 1
a4609 1
		/* XXX assert() */
d4620 1
a4620 1
	/* XXX splnet() ? */
d4630 1
a4630 2
	/* XXX splnet() ? */
	/* XXX bcm43xx_voluntary_preempt() ? */
a4753 1
		/* XXX assert() */
a4772 1
			/* XXX assert() */
a4911 1
			/* XXX bcm43xx_voluntary_preempt() ? */
d4932 1
a4932 1
				tmp = (i - 9) * 2 + j - 5; /* FIXME */
d4952 1
a4952 1
			    (3 << 4)); /* FIXME */
a4953 1
			/* XXX bcm43xx_voluntary_preempt() */
d4963 1
a4963 1
			/* XXX bcm43xx_phy_lo_g_state() */
a4975 1
		/* XXX bcm43xx_voluntary_preempt() */
d5045 2
a5046 1
	/* XXX splnet ? */
d5068 1
a5068 2
	/* XXX splnet ? */
	/* XXX bcm43xx_voluntary_preempt() ? */
a5124 2
	/* XXX assert() */

a5138 18
bcw_phy_prepare_init(struct bcw_softc *sc)
{
	sc->sc_phy_antenna_diversity = 0xffff;
	memset(sc->sc_phy_minlowsig, 0xff, sizeof(sc->sc_phy_minlowsig));
	memset(sc->sc_phy_minlowsigpos, 0, sizeof(sc->sc_phy_minlowsigpos));

	/* flags */
	sc->sc_phy_calibrated = 0;
	sc->sc_phy_is_locked = 0;

	if (sc->sc_phy_lopairs)
		memset(sc->sc_phy_lopairs, 0, sizeof(struct bcw_lopair) *
		    BCW_LO_COUNT);

	memset(sc->sc_phy_loopback_gain, 0, sizeof(sc->sc_phy_loopback_gain));
}

void
a5147 1
	/* XXX assert() */
d5149 2
a5150 2
	ucodeflags = bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET);
	bcw_shm_write16(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET,
d5219 1
a5219 1
		if (1) /* XXX current_core->rev */
d5227 1
a5227 1
		/* XXX assert() */
d5232 1
a5232 1
		ucodeflags = bcw_shm_read16(sc, BCW_SHM_SHARED,
d5234 1
a5234 1
		bcw_shm_write16(sc, BCW_SHM_SHARED,
d5295 36
d5340 1
d5342 1
a5342 1
	 * XXX Different PHYs have different radio register layouts, so
d5578 1
a5578 1
		/* XXX assert() */
d5905 1
a5905 1
	r = bcw_radio_read16(sc, 0x0060);
a5956 2
	/* XXX assert() */

d6052 1
a6052 1
		bcw_phy_write16(sc, 0x0015, 0xfff0);
d6071 1
a6071 2
		/* XXX flip_4bit(i) */
		bcw_radio_write16(sc, 0x0078, i << 1 | 0x0020);
a6175 2
	/* XXX assert() */

a6266 2
	/* XXX assert() */

a6444 2
	/* XXX assert(txpower <= 63); ? */

a6461 2
	/* XXX assert(txpower <= 63); ? */

a6480 2
	/* XXX assert(txpower <= 63); ? */

a6517 29
void
bcw_radio_prepare_init(struct bcw_softc *sc)
{
	int i;

	/* set default attenuation values */
	sc->sc_radio_baseband_atten =
	    bcw_radio_default_baseband_atten(sc);
	sc->sc_radio_radio_atten =
	    bcw_radio_default_radio_atten(sc);
	sc->sc_radio_txctl1 = bcw_radio_default_txctl1(sc);
	sc->sc_radio_txctl2 = 0xffff;
	sc->sc_radio_txpwr_offset = 0;

	/* nrssi */
	sc->sc_radio_nrssislope = 0;
	for (i = 0; i < BCW_ARRAY_SIZE(sc->sc_radio_nrssi); i++)
		sc->sc_radio_nrssi[i] = -1000;
	for (i = 0; i < BCW_ARRAY_SIZE(sc->sc_radio_nrssi_lt); i++)
		sc->sc_radio_nrssi_lt[i] = i;

	sc->sc_radio_lofcal = 0xffff;
	sc->sc_radio_initval = 0xffff;

	sc->sc_radio_aci_enable = 0;
	sc->sc_radio_aci_wlan_automatic = 0;
	sc->sc_radio_aci_hw_rssi = 0;
}

d6574 1
a6574 1
		/* XXX radio_stacksave() */
d6576 1
a6576 1
		flipped = tmp; /* XXX flip_4bit(tmp) */
d6581 1
a6581 1
		flipped = flipped; /* XXX flip_4bit(flipped) */
d6759 1
a6759 1
		 /* XXX assert () */
d6780 22
d6861 1
d6882 1
a6882 1
	//int maxfreq;
d6903 1
a6903 2
		/* TODO get maxfreq */
#if 0
a6907 1
#endif
d6993 121
a7128 2
	/* XXX assert() */

a7150 2

	/* XXX assert() */
@


1.85
log
@Some sorting.  More comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.84 2007/04/01 00:08:17 mglocker Exp $ */
d104 1
d1372 27
d2832 1
d2834 5
@


1.84
log
@Remove dead code.  Comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.83 2007/03/31 23:50:59 mglocker Exp $ */
a130 2
void			bcw_pc_crystal_on(struct bcw_softc *);
void			bcw_pc_crystal_off(struct bcw_softc *);
d249 2
a1169 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
d1174 2
a1176 1
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
d1185 1
d1578 5
a1582 1
/* Stop transmission on the interface */
a2093 46
void
bcw_pc_crystal_on(struct bcw_softc *sc)
{
	uint32_t val;

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOI);
	if (val & BCW_PCTL_XTAL_POWERUP)
		return; /* crystal is already on */

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOO);
	val |= (BCW_PCTL_XTAL_POWERUP | BCW_PCTL_PLL_POWERDOWN);
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOO, val);
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOE, val);

	delay(1000);

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOO);
	val &= ~BCW_PCTL_PLL_POWERDOWN;
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOO, val);

	delay(5000);
}

void
bcw_pc_crystal_off(struct bcw_softc *sc)
{
	uint32_t val;

	/* TODO return if radio is hardware disabled */
	if (sc->sc_chip_rev < 5)
		return;
	if (sc->sc_sprom.boardflags & BCW_BF_XTAL)
		return;

	bcw_pc_set_clock(sc, BCW_PCTL_CLK_SLOW);

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOO);
	val |= BCW_PCTL_PLL_POWERDOWN;
	val &= ~BCW_PCTL_XTAL_POWERUP;
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOO, val);

	val = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOE);
	val |= (BCW_PCTL_PLL_POWERDOWN | BCW_PCTL_XTAL_POWERUP);
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOE, val);
}

d6763 46
@


1.83
log
@Since I spent some work on this beast, too, I allow myself to add me
to the drivers copyright note.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.82 2007/03/31 23:38:03 mglocker Exp $ */
d22 1
a22 1
 * SiliconBackplane is technology from Sonics, Inc.(sonicsinc.com)
d906 5
d1119 1
a1119 4
	 * XXX Select the 802.11 core, then
	 * Get and display the PHY info from the MIMO
	 * This probably won't work for cards with multiple radio cores, as
	 * the spec suggests that there is one PHY for each core
a1122 7
#if 0
	sc->sc_phy_lopairs = malloc(sizeof(struct bcw_lopair) * BCW_LO_COUNT,
	    M_DEVBUF, M_NOWAIT);
	bcw_phy_prepare_init(sc);
	bcw_radio_prepare_init(sc);
#endif

d1508 2
d1523 2
@


1.82
log
@Move extraction / verification of PHY and radio values into own functions.
Move initialization of the microcode flags bitfield into own function.
Simplify and improve chip access validation function.
Restructure initalization flow according to the reverse engeneering pages.
We are able to ifconfig up again after a ifconfig down now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.81 2007/03/31 09:48:02 mglocker Exp $ */
d4 1
@


1.81
log
@Enable interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.80 2007/03/20 21:14:39 mglocker Exp $ */
d152 2
a153 1
int			bcw_sprom_extract(struct bcw_softc *);
d158 1
d201 1
a909 1
	int error;
a963 2
		bcw_pc_set_clock(sc, BCW_PCTL_CLK_FAST);

d1048 6
a1053 1
	bcw_iocore_enable(sc, (1 << 1));
d1055 1
a1055 1
       /* Reset and Identify each core */
d1057 5
a1061 2
		if (bcw_change_core(sc, i) == 0) {
			sbval = BCW_READ(sc, BCW_CIR_SBID_HI);
d1063 9
a1071 5
			sc->sc_core[i].id = (sbval & 0x00008ff0) >> 4;
			sc->sc_core[i].rev =
			    ((sbval & 0x00007000) >> 8 | (sbval & 0x0000000f));

			switch (sc->sc_core[i].id) {
d1073 6
a1078 5
			case BCW_CORE_COMMON:
				sc->sc_core_common = &sc->sc_core[i];
				break;
			case BCW_CORE_PCI:
				(sc->sc_ca == NULL)
d1080 1
a1080 5
				break;
			case BCW_CORE_PCMCIA:
				if (sc->sc_pa == NULL)
					sc->sc_core_bus = &sc->sc_core[i];
				break;
d1082 25
a1106 23
			case BCW_CORE_80211:
				bcw_80211_core_reset(sc, 1);
				bcw_radio_off(sc);
				sc->sc_core_80211 = &sc->sc_core[i];
				break;
			case BCW_CORE_NONEXIST:
				sc->sc_numcores = i + 1;
				break;
			default:
				/* Ignore all other core types */
				break;
			}
			DPRINTF(("%s: core %d is type 0x%x rev %d\n",
			    sc->sc_dev.dv_xname, i, 
			    sc->sc_core[i].id, sc->sc_core[i].rev));
			/* XXX Fill out the core location vars */
			sbval = BCW_READ(sc, BCW_SBTPSFLAG);
			sc->sc_core[i].backplane_flag =
			sbval & SBTPS_BACKPLANEFLAGMASK;
			sc->sc_core[i].index = i;
		} else
			DPRINTF(("%s: Failed change to core %d",
			    sc->sc_dev.dv_xname, i));
d1120 1
a1120 30
	sbval = BCW_READ16(sc, 0x3E0);
	sc->sc_phy_ver = (sbval & 0xf000) >> 12;
	sc->sc_phy_rev = sbval & 0xf;
	sc->sc_phy_type = (sbval & 0xf00) >> 8;

	DPRINTF(("%s: PHY version %d revision %d ",
	    sc->sc_dev.dv_xname, sc->sc_phy_ver, sc->sc_phy_rev));

	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		DPRINTF(("PHY %d (A)\n", sc->sc_phy_type));
		break;
	case BCW_PHY_TYPEB:
		DPRINTF(("PHY %d (B)\n", sc->sc_phy_type));
		break;
	case BCW_PHY_TYPEG:
		DPRINTF(("PHY %d (G)\n", sc->sc_phy_type));
		break;
	case BCW_PHY_TYPEN:
		DPRINTF(("PHY %d (N)\n", sc->sc_phy_type));
		break;
	default:
		DPRINTF(("Unrecognizeable PHY type %d\n",
		    sc->sc_phy_type));
		break;
	}

	/*
	 * Initialize softc vars
	 */
d1125 1
a1125 110

	/*
	 * Query the RadioID register, on a 4317 use a lookup instead
	 * XXX Different PHYs have different radio register layouts, so
	 * a wrapper func should be written.
	 * Getting the RadioID is the only 32bit operation done with the
	 * Radio registers, and requires seperate 16bit reads from the low
	 * and the high data addresses.
	 */
	if (sc->sc_chip_id != 0x4317) {
		BCW_WRITE16(sc, BCW_MMIO_RADIO_CONTROL, BCW_RADIO_ID);
		sbval = BCW_READ16(sc, BCW_MMIO_RADIO_DATA_HIGH);
		sbval <<= 16;
		BCW_WRITE16(sc, BCW_MMIO_RADIO_CONTROL, BCW_RADIO_ID);
		sc->sc_radio_mnf =
		    sbval | BCW_READ16(sc, BCW_MMIO_RADIO_DATA_LOW);
	} else {
		switch (sc->sc_chip_rev) {
		case 0:	
			sc->sc_radio_mnf = 0x3205017F;
			break;
		case 1:
			sc->sc_radio_mnf = 0x4205017f;
			break;
		default:
			sc->sc_radio_mnf = 0x5205017f;
		}
	}

	sc->sc_radio_rev = (sc->sc_radio_mnf & 0xf0000000) >> 28;
	sc->sc_radio_ver = (sc->sc_radio_mnf & 0x0ffff000) >> 12;

	DPRINTF(("%s: Radio Rev %d, Ver 0x%x, Manuf 0x%x\n",
	    sc->sc_dev.dv_xname, sc->sc_radio_rev, sc->sc_radio_ver,
	    sc->sc_radio_mnf & 0xfff));

	error = bcw_validate_chip_access(sc);
	if (error) {
		printf("%s: failed Chip Access Validation at %d\n",
		    sc->sc_dev.dv_xname, error);
		return;
	}

	/* Test for valid PHY/revision combinations, probably a simpler way */
	if (sc->sc_phy_type == BCW_PHY_TYPEA) {
		switch (sc->sc_phy_rev) {
		case 2:
		case 3:
		case 5:
		case 6:
		case 7:
			break;
		default:
			printf("%s: invalid PHY A revision %d\n",
			    sc->sc_dev.dv_xname, sc->sc_phy_rev);
			return;
		}
	}
	if (sc->sc_phy_type == BCW_PHY_TYPEB) {
		switch (sc->sc_phy_rev) {
		case 2:
		case 4:
		case 7:
			break;
		default:
			printf("%s: invalid PHY B revision %d\n",
			    sc->sc_dev.dv_xname, sc->sc_phy_rev);
			return;
		}
	}
	if (sc->sc_phy_type == BCW_PHY_TYPEG) {
		switch(sc->sc_phy_rev) {
		case 1:
		case 2:
		case 4:
		case 6:
		case 7:
		case 8:
			break;
		default:
			printf("%s: invalid PHY G revision %d\n",
			    sc->sc_dev.dv_xname, sc->sc_phy_rev);
			return;
		}
	}

	/* test for valid radio revisions */
	if ((sc->sc_phy_type == BCW_PHY_TYPEA) &
	    (sc->sc_radio_ver != 0x2060)) {
		    	printf("%s: invalid PHY A radio 0x%x\n",
		    	    sc->sc_dev.dv_xname, sc->sc_radio_ver);
		    	return;
	}
	if ((sc->sc_phy_type == BCW_PHY_TYPEB) &
	    ((sc->sc_radio_ver & 0xfff0) != 0x2050)) {
		    	printf("%s: invalid PHY B radio 0x%x\n",
		    	    sc->sc_dev.dv_xname, sc->sc_radio_ver);
		    	return;
	}
	if ((sc->sc_phy_type == BCW_PHY_TYPEG) &
	    (sc->sc_radio_ver != 0x2050)) {
		    	printf("%s: invalid PHY G radio 0x%x\n",
		    	    sc->sc_dev.dv_xname, sc->sc_radio_ver);
		    	return;
	}

	/*
	 * Extract SPROM values and save them where they belong
	 */
	bcw_sprom_extract(sc);
a1136 26
	 * Init the Microcode Flags Bitfield
	 *
	 * http://bcm-specs.sipsolutions.net/MicrocodeFlagsBitfield
	 */
	sbval = 0;
	if (sc->sc_phy_type == BCW_PHY_TYPEA ||
	    sc->sc_phy_type == BCW_PHY_TYPEB ||
	    sc->sc_phy_type == BCW_PHY_TYPEG)
		sbval |= 2;
	if (sc->sc_phy_type == BCW_PHY_TYPEG && sc->sc_phy_rev == 1)
		sbval |= 0x20;
	if (sc->sc_phy_type == BCW_PHY_TYPEG &&
	    sc->sc_sprom.boardflags & BCW_BF_PACTRL)
		sbval |= 0x40;
	if (sc->sc_phy_type == BCW_PHY_TYPEG && sc->sc_phy_rev < 3)
		sbval |= 0x8;
	if (sc->sc_sprom.boardflags & BCW_BF_XTAL)
		sbval |= 0x400;
	if (sc->sc_phy_type == BCW_PHY_TYPEB)
		sbval |= 0x4;
	if (sc->sc_radio_ver == 0x2050 && sc->sc_radio_rev <= 5)
	    	sbval |= 0x40000;
	/* XXX device not up and PCI bus with rev =< 10 set 0x80000 */
	bcw_shm_write32(sc, BCW_SHM_SHARED, BCW_UCODEFLAGS_OFFSET, sbval);

	/*
d1521 5
d1689 2
a1690 2
 * This function ensures that the chip is setup correctly and is ready
 * for use.
d1697 1
a1697 1
	uint32_t save,val;
d1699 3
a1701 8
	/* Make sure we're dealing with the wireless core */
	bcw_change_core(sc, sc->sc_core_80211->index);

	/*
	 * We use the offset of zero a lot here to reset the SHM pointer to the
	 * beginning of it's memory area, as it automatically moves on every
	 * access to the SHM DATA registers
	 */
d1703 2
a1704 9
	/* Backup SHM uCode Revision before we clobber it */
	BCW_WRITE(sc, BCW_MMIO_SHM_CONTROL, (BCW_SHM_SHARED << 16) + 0);
	save = BCW_READ(sc, BCW_MMIO_SHM_DATA);

	/* write test value */
	BCW_WRITE(sc, BCW_MMIO_SHM_CONTROL, (BCW_SHM_SHARED << 16) + 0);
	BCW_WRITE(sc, BCW_MMIO_SHM_DATA, 0xaa5555aa);
	/* Read it back */
	BCW_WRITE(sc, BCW_MMIO_SHM_CONTROL, (BCW_SHM_SHARED << 16) + 0);
d1706 3
a1708 1
	val = BCW_READ(sc, BCW_MMIO_SHM_DATA);
d1710 1
a1710 1
		return (1);
d1712 5
a1716 5
	/* write 2nd test value */
	BCW_WRITE(sc, BCW_MMIO_SHM_CONTROL, (BCW_SHM_SHARED << 16) + 0);
	BCW_WRITE(sc, BCW_MMIO_SHM_DATA, 0x55aaaa55);
	/* Read it back */
	BCW_WRITE(sc, BCW_MMIO_SHM_CONTROL, (BCW_SHM_SHARED << 16) + 0);
d1718 2
a1719 3
	val = BCW_READ(sc, BCW_MMIO_SHM_DATA);
	if (val != 0x55aaaa55)
		return 2;
a1720 3
	/* Restore the saved value now that we're done */
	BCW_WRITE(sc, BCW_MMIO_SHM_CONTROL, (BCW_SHM_SHARED << 16) + 0);
	BCW_WRITE(sc, BCW_MMIO_SHM_DATA, save);
d1722 1
a1722 7
		/* do some test writes and reads against the TSF */
		/*
		 * This works during the attach, but the spec at
		 * http://bcm-specs.sipsolutions.net/Timing
		 * say that we're reading/writing silly places, so these regs
		 * are not quite documented yet
		 */
d1726 3
a1728 1
		if (val != 0xbbbb) return 3;
d1730 3
a1732 3
		if (val != 0xcccc) return 4;
		/* re-clear the TSF since we just filled it with garbage */
		BCW_WRITE(sc, 0x18c, 0x0);
d1735 1
a1735 1
	/* Check the Status Bit Field for some unknown bits */
d1737 4
a1740 7
	if ((val | 0x80000000) != 0x80000400 ) {
		printf("%s: Warning, SBF is 0x%x, expected 0x80000400\n",
		    sc->sc_dev.dv_xname, val);
		/* May not be a critical failure, just warn for now */
		//return (5);
	}
	/* Verify there are no interrupts active on the core */
d1742 6
a1747 4
	if (val != 0) {
		DPRINTF(("Failed Pending Interrupt test with val=0x%x\n", val));
		return (6);
	}
a1748 7
	/* Above G means it's unsupported currently, like N */
	if (sc->sc_phy_type > BCW_PHY_TYPEG) {
		DPRINTF(("PHY type %d greater than supported type %d\n",
		    sc->sc_phy_type, BCW_PHY_TYPEG));
		return (7);
	}
	
d1750 4
d3055 1
a3055 1
 * Extract whole SPROM content
d3060 1
a3060 1
bcw_sprom_extract(struct bcw_softc *sc)
d3166 33
d3202 56
d5287 67
@


1.80
log
@Fix crystal on/off routine (no more panic).  Add two new routines to
set and clear the device's MAC filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.79 2007/03/20 13:52:48 mglocker Exp $ */
a94 1
void			bcw_reset(struct bcw_softc *);
d104 1
d130 2
a131 1
void			bcw_powercontrol_crystal_off(struct bcw_softc *);
a132 1
int			bcw_reset_core(struct bcw_softc *, uint32_t);
d136 2
d147 1
d245 1
a245 1
 * Power
d247 3
a249 1
void			bcw_power_saving_ctl_bits(struct bcw_softc *, int, int);
a616 1
			/* unaligned acccess */
a637 1
			/* unaligned access */
d708 1
a708 1
		val = htobe32(val); /* XXX swab32() */
d725 5
d740 2
a741 1
	    0x00000000 };
d763 7
a769 7
	BCW_WRITE16(sc, 0x0568, 0x0000);
	BCW_WRITE16(sc, 0x07c0, 0x0000);
	BCW_WRITE16(sc, 0x050c, ((sc->sc_phy_type == BCW_PHY_TYPEA) ? 1 : 0));

	BCW_WRITE16(sc, 0x0508, 0x0000);
	BCW_WRITE16(sc, 0x050a, 0x0000);
	BCW_WRITE16(sc, 0x054c, 0x0000);
d772 1
a772 1
	BCW_WRITE16(sc, 0x0500, 0x0000);
d921 1
a921 1
	 * Turn crystal on
d923 4
a926 1
	bcw_powercontrol_crystal_on(sc);
d931 1
a931 1
	if (bcw_change_core(sc, 0) == 0)
d934 3
d959 5
d967 1
a967 1
		sc->sc_chip_package = (sbval & 0x00f00000) >> 20;
d1045 1
a1045 1
	    sc->sc_chip_id, sc->sc_chip_rev, sc->sc_chip_package,
d1048 2
d1060 1
a1061 1
				bcw_reset_core(sc, 0);
a1064 2
#if 0
				bcw_reset_core(sc,0);
a1065 1
#endif
a1067 1
#if 0
a1068 1
				bcw_reset_core(sc,0);
d1074 2
a1075 2
				bcw_reset_core(sc,
				    SBTML_80211FLAG | SBTML_80211PHY);
d1092 1
a1092 1
			sc->sc_core[i].num = i;
d1096 1
a1096 1
	} /* End of For loop */
d1098 2
a1099 2
	/* Now that we have cores identified, finish the reset */
	bcw_reset(sc);
d1107 1
a1107 1
	bcw_change_core(sc, sc->sc_core_80211->num);
a1248 2
	bcw_radio_off(sc);

d1254 3
a1256 1
        /* MAC address */
a1260 1

d1263 5
a1267 2
	/* Init the Microcode Flags Bitfield */
	/* http://bcm-specs.sipsolutions.net/MicrocodeFlagsBitfield */
d1269 5
a1273 6
	if ((sc->sc_phy_type == BCW_PHY_TYPEA) ||
	    (sc->sc_phy_type == BCW_PHY_TYPEB) ||
	    (sc->sc_phy_type == BCW_PHY_TYPEG))
		sbval |= 2; /* Turned on during init for non N phys */
	if ((sc->sc_phy_type == BCW_PHY_TYPEG) &&
	    (sc->sc_phy_rev == 1))
d1275 2
a1276 2
	if ((sc->sc_phy_type == BCW_PHY_TYPEG) &&
	    ((sc->sc_sprom.boardflags & BCW_BF_PACTRL) == BCW_BF_PACTRL))
d1278 3
a1280 4
	if ((sc->sc_phy_type == BCW_PHY_TYPEG) &&
	    (sc->sc_phy_rev < 3))
		sbval |= 0x8; /* MAGIC */
	if ((sc->sc_sprom.boardflags & BCW_BF_XTAL) == BCW_BF_XTAL)
d1284 1
a1284 2
	if ((sc->sc_radio_ver == 0x2050) &&
	    (sc->sc_radio_rev <= 5))
d1286 2
a1287 20
	/*
	 * XXX If the device isn't up and this is a PCI bus with revision
	 * 10 or less set bit 0x80000
	 */

	/*
	 * Now, write the value into the regster
	 *
	 * The MicrocodeBitFlags is an unaligned 32bit value in SHM, so the
	 * strategy is to select the aligned word for the lower 16 bits,
	 * but write to the unaligned address. Then, because the SHM
	 * pointer is automatically incremented to the next aligned word,
	 * we can just write the remaining bits as a 16 bit write.
	 * This explanation could make more sense, but an SHM read/write
	 * wrapper of some sort would be better.
	 */
	BCW_WRITE(sc, BCW_MMIO_SHM_CONTROL,
	    (BCW_SHM_SHARED << 16) + BCW_UCODEFLAGS_OFFSET - 2);
	BCW_WRITE16(sc, BCW_MMIO_SHM_DATA_UNALIGNED, sbval & 0x00ff);
	BCW_WRITE16(sc, BCW_MMIO_SHM_DATALOW, (sbval & 0xff00) >> 16);
a1296 5
	 * Turn crystal off
	 */
	bcw_powercontrol_crystal_off(sc);

	/*
d1539 25
a1563 1
	bcw_power_saving_ctl_bits(sc, -1, -1);
a1594 1
#if 0
d1597 37
a1633 1
#endif
d1635 1
a1635 1
	return (0);
d1672 12
d1686 1
a1686 1
	if ((error = bcw_80211_core_init(sc, 1))) /* XXX */
d1689 2
a1690 3
#if 0
	bcw_macfilter_clear(sc, BCW_MACFILTER_ASSOC);
	bcw_macfilter_set(sc, BCW_MACFILTER_SELF, ic->ic_myaddr);
d1693 1
a1693 1
#endif
d1702 2
d1731 9
a1761 47
/* reset the chip */
void
bcw_reset(struct bcw_softc *sc)
{
	uint32_t sbval;
	uint32_t reject;

	/*
	 * Figure out what revision the Sonic Backplane is, as the position
	 * of the Reject bit changes.
	 */
	sbval = BCW_READ(sc, BCW_CIR_SBID_LO);
	sc->sc_sbrev = (sbval & SBREV_MASK) >> SBREV_MASK_SHIFT;

	switch (sc->sc_sbrev) {
	case 0:
		reject = SBTML_REJ22;
		break;
	case 1:
		reject = SBTML_REJ23;
		break;
	default:
		reject = SBTML_REJ22 | SBTML_REJ23;
	}

	sbval = BCW_READ(sc, BCW_SBTMSTATELOW);

	/*
	 * If the 802.11 core is enabled, only clock of clock,reset,reject
	 * will be set, and we need to reset all the DMA engines first.
	 */
	bcw_change_core(sc, sc->sc_core_80211->num);

	sbval = BCW_READ(sc, BCW_SBTMSTATELOW);

	/* Clear Baseband Attenuation, might only work for B/G rev < 0 */
	BCW_WRITE16(sc, BCW_RADIO_BASEBAND, 0);

	/* Set 0x400 in the MMIO StatusBitField reg */
	sbval = BCW_READ(sc, BCW_MMIO_SBF);
	sbval |= BCW_SBF_400_MAGIC;
	BCW_WRITE(sc, BCW_MMIO_SBF, sbval);

	/* Change back to the Wireless core */
	bcw_change_core(sc, sc->sc_core_80211->num);
}

d1848 1
a1848 1
	bcw_change_core(sc, sc->sc_core_80211->num);
d2260 1
a2260 1
bcw_powercontrol_crystal_on(struct bcw_softc *sc)
d2265 1
a2265 1
	if ((val & BCW_PCTL_XTAL_POWERUP) == BCW_PCTL_XTAL_POWERUP)
d2283 1
a2283 1
bcw_powercontrol_crystal_off(struct bcw_softc *sc)
d2290 1
a2290 1
	if ((sc->sc_sprom.boardflags & BCW_BF_XTAL))
d2293 1
a2293 1
	/* TODO bcw_powercontrol_clock_slow() */
d2308 1
a2309 1
	int i;
d2311 1
a2311 2
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_ADDR_SPACE0,
	    BCW_CORE_SELECT(changeto));
d2315 1
a2315 1
		sbval = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_ADDR_SPACE0);
a2332 131
int
bcw_reset_core(struct bcw_softc *sc, uint32_t flags)
{
	uint32_t	sbval, reject, val;
	int		i;

	/*
	 * Figure out what revision the Sonic Backplane is, as the position
	 * of the Reject bit changes.
	 */
	switch (sc->sc_sbrev) {
	case 0:
		reject = SBTML_REJ22;
		break;
	case 1:
		reject = SBTML_REJ23;
		break;
	default:
		reject = SBTML_REJ22 | SBTML_REJ23;
	}

	/* disable core if not in reset */
	if (!(sbval & SBTML_RESET)) {
		/* if the core is not enabled, the clock won't be enabled */
		if (!(sbval & SBTML_CLK)) {
			BCW_WRITE(sc, BCW_SBTMSTATELOW,
			    SBTML_RESET | reject | flags);
			delay(1);
			sbval = BCW_READ(sc, BCW_SBTMSTATELOW);
			goto disabled;

			BCW_WRITE(sc, BCW_SBTMSTATELOW, reject);
			delay(1);
			/* wait until busy is clear */
			for (i = 0; i < 10000; i++) {
				val = BCW_READ(sc, BCW_SBTMSTATEHI);
				if (!(val & SBTMH_BUSY))
					break;
				delay(10);
			}
			if (i == 10000)
				printf("%s: while resetting core, busy did "
				    "not clear\n", sc->sc_dev.dv_xname);

			val = BCW_READ(sc, BCW_CIR_SBID_LO);
			if (val & BCW_CIR_SBID_LO_INITIATOR) {
				sbval = BCW_READ(sc, BCW_SBIMSTATE);
				BCW_WRITE(sc, BCW_SBIMSTATE,
				    sbval | SBIM_REJECT);
				sbval = BCW_READ(sc, BCW_SBIMSTATE);
				delay(1);

				/* wait until busy is clear */
				for (i = 0; i < 10000; i++) {
					val = BCW_READ(sc, BCW_SBTMSTATEHI);
					if (!(val & SBTMH_BUSY))
						break;
					delay(10);
				}
				if (i == 10000)
					printf("%s: while resetting core, busy "
					    "did not clear\n",
					    sc->sc_dev.dv_xname);
			} /* end initiator check */

			/* set reset and reject while enabling the clocks */
			/* XXX why isn't reject in here? */
			BCW_WRITE(sc, BCW_SBTMSTATELOW,
			    SBTML_FGC | SBTML_CLK | SBTML_RESET | flags);
			val = BCW_READ(sc, BCW_SBTMSTATELOW);
			delay(10);

			val = BCW_READ(sc, BCW_CIR_SBID_LO);
			if (val & BCW_CIR_SBID_LO_INITIATOR) {
				sbval = BCW_READ(sc, BCW_SBIMSTATE);
				BCW_WRITE(sc, BCW_SBIMSTATE,
				    sbval & ~SBIM_REJECT);
				sbval = BCW_READ(sc, BCW_SBIMSTATE);
				delay(1);

				/* wait until busy is clear */
				for (i = 0; i < 10000; i++) {
					val = BCW_READ(sc, BCW_SBTMSTATEHI);
					if (!(val & SBTMH_BUSY))
						break;
					delay(10);
				}
				if (i == 10000)
					printf("%s: while resetting core, busy "
					    "did not clear\n",
					    sc->sc_dev.dv_xname);
			} /* end initiator check */

			BCW_WRITE(sc, BCW_SBTMSTATELOW,
			    SBTML_RESET | reject | flags);
			delay(1);
		}
	}

disabled:

	/* This is enabling/resetting the core */
	/* enable clock */
	BCW_WRITE(sc, BCW_SBTMSTATELOW,
	    SBTML_FGC | SBTML_CLK | SBTML_RESET | flags);
	val = BCW_READ(sc, BCW_SBTMSTATELOW);
	delay(1);

	/* clear any error bits that may be on */
	val = BCW_READ(sc, BCW_SBTMSTATEHI);
	if (val & SBTMH_SERR)
		BCW_WRITE(sc, BCW_SBTMSTATEHI, 0);
	val = BCW_READ(sc, BCW_SBIMSTATE);
	if (val & (SBIM_INBANDERR | SBIM_TIMEOUT))
		BCW_WRITE(sc, BCW_SBIMSTATE,
		    val & ~(SBIM_INBANDERR | SBIM_TIMEOUT));

	/* clear reset and allow it to propagate throughout the core */
	BCW_WRITE(sc, BCW_SBTMSTATELOW,
	    SBTML_FGC | SBTML_CLK | flags);
	val = BCW_READ(sc, BCW_SBTMSTATELOW);
	delay(1);

	/* leave clock enabled */
	BCW_WRITE(sc, BCW_SBTMSTATELOW, SBTML_CLK | flags);
	val = BCW_READ(sc, BCW_SBTMSTATELOW);
	delay(1);

	return 0;
}

d2467 41
a2507 4
#if 0
	if (1) { /* XXX */
		BCW_WRITE(sc, BCW_MMIO_SBF, BCW_READ(sc, BCW_MMIO_SBF) &
		    ~(BCW_SBF_MAC_ENABLED | 0x00000002));
d2509 23
a2531 9
#endif
		if (connect_phy)
			flags |= 0x20000000;
		bcw_phy_connect(sc, connect_phy);
		bcw_core_enable(sc, flags);
		BCW_WRITE16(sc, 0x03e6, 0);
		BCW_WRITE(sc, BCW_MMIO_SBF, BCW_READ(sc, BCW_MMIO_SBF) |
		    BCW_SBF_400_MAGIC);
#if 0
d2533 5
a2537 1
#endif
d2881 2
a2882 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d2885 1
a2885 1
	int error, i, tmp;
d2942 9
a2950 2
	/* turn radio on */
	bcw_radio_on(sc);
d2952 1
a2952 8
	BCW_WRITE16(sc, 0x03e6, 0);
	if ((error = bcw_phy_init(sc)))
		return (error);

	/* select initial interference mitigation */
	tmp = sc->sc_radio_interfmode;
	sc->sc_radio_interfmode = BCW_RADIO_INTERFMODE_NONE;
	bcw_radio_set_interf_mitigation(sc, tmp);
a2953 7
	bcw_phy_set_antenna_diversity(sc);
	bcw_radio_set_txantenna(sc, BCW_RADIO_TXANTENNA_DEFAULT);
	if (sc->sc_phy_type == BCW_PHY_TYPEB) {
		val16 = BCW_READ16(sc, 0x005e);
		val16 |= 0x0004;
		BCW_WRITE16(sc, 0x005e, val16);
	}
d2980 1
a2980 2
	/* initially set the wireless operation mode */
	bcw_set_opmode(ifp);
d3002 14
a3015 1
	/* TODO bcw_pctl_powerup_delay(sc) */
d3023 51
a3080 1
	uint8_t limit;
d3082 1
a3082 1
	uint32_t sbimconfiglow;
d3084 1
a3084 1

d3089 1
a3089 4
		if (1) /* XXX find out the bus type (PCI, CARDBUS, PCMCIA */
			sbimconfiglow |= 0x32;
		else
			sbimconfiglow |= 0x53;
d3092 1
d3095 1
d3099 2
a3100 2
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0016,
	    sc->sc_core[sc->sc_currentcore].rev);
d3102 5
d3108 3
a3110 8

	if (0) /* XXX */
		ucodeflags |= 0x00000010;

	/* HW decryption needs to be set now */
	ucodeflags |= 0x40000000;

	if (sc->sc_phy_type == BCW_PHY_TYPEG) {
d3112 9
a3120 12
		if (sc->sc_phy_rev == 1)
			ucodeflags |= BCW_UCODEFLAG_UNKGPHY;
		if (sc->sc_sprom.boardflags & BCW_BF_PACTRL)
			ucodeflags |= BCW_UCODEFLAG_UNKPACTRL;
	} else if (sc->sc_phy_type == BCW_PHY_TYPEB) {
		ucodeflags |= BCW_UCODEFLAG_UNKBGPHY;
		if (sc->sc_phy_rev >= 2 && sc->sc_radio_ver == 0x2050)
			ucodeflags &= ~BCW_UCODEFLAG_UNKGPHY;
	}

	if (ucodeflags != bcw_shm_read32(sc, BCW_SHM_SHARED,
	    BCW_UCODEFLAGS_OFFSET)) {
a3122 23
	}

	/* short/long retry limit */
	limit = bcw_lv(BCW_DEFAULT_SHORT_RETRY_LIMIT, 0, 0xf);
	bcw_shm_write32(sc, BCW_SHM_80211, 0x0006, limit);
	limit = bcw_lv(BCW_DEFAULT_LONG_RETRY_LIMIT, 0, 0xf);
	bcw_shm_write32(sc, BCW_SHM_80211, 0x0007, limit);

	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0044, 3);
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0046, 2);

	bcw_rate_memory_init(sc);

	/* minimum contention window */
	if (sc->sc_phy_type == BCW_PHY_TYPEB)
		bcw_shm_write32(sc, BCW_SHM_80211, 0x0003, 0x0000001f);
	else
		bcw_shm_write32(sc, BCW_SHM_80211, 0x0003, 0x0000000f);

	/* maximum contention window */
	bcw_shm_write32(sc, BCW_SHM_80211, 0x0004, 0x000003ff);

	/* TODO bcw_gen_bssid(), bcw_write_mac_bssid_templates() */
d3134 1
d3138 4
a3141 7

	if (active_80211_core) {
		if (1) /* XXX initial channel */
			bcw_radio_select_channel(sc, 0, 0);
	}

	/* TODO sc->sc_current_core_initialized = 1; */
d3475 1
a3475 1
	if (sc->sc_chip_id == 0x4306 && sc->sc_chip_rev == 2) {
d5345 1
a5345 1
		flags |= (0x8000 << 18);
d6816 1
a6816 1
 * Power
d6818 81
d6900 1
a6900 1
bcw_power_saving_ctl_bits(struct bcw_softc *sc, int bit25, int bit26)
d6905 3
d6927 1
a6927 2
			if (bcw_shm_read32(sc, BCW_SHM_SHARED, 0x0040)
			    != 4)
@


1.79
log
@Document some routines by pointing to the refering specs URL.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.78 2007/03/20 11:55:36 mglocker Exp $ */
d101 3
d912 5
d1299 1
a1299 3
	 * XXX TODO still for the card attach:
	 * - Disable the 80211 Core (and wrapper for on/off)
	 * - Setup LEDs to blink in whatever fashionable manner
d1301 1
a1301 1
	//bcw_powercontrol_crystal_off(sc);	/* TODO Fix panic! */
d1305 1
a1305 1
	 * The receive and transmit rings are 4k aligned
d1314 1
a1314 1
	/* set device capabilities - keep it simple */
d1506 27
d1582 1
d1618 1
d1625 7
d2235 16
a2250 1
	uint32_t sbval;
d2252 1
a2252 11
	sbval = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOI);
	if ((sbval & BCW_PCTL_XTAL_POWERUP) != BCW_PCTL_XTAL_POWERUP) {
		sbval = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOO);
		sbval |= (BCW_PCTL_XTAL_POWERUP & BCW_PCTL_PLL_POWERDOWN);
		(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOO, sbval);
		delay(1000);
		sbval = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOO);
		sbval &= ~BCW_PCTL_PLL_POWERDOWN;
		(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOO, sbval);
		delay(5000);
	}
d2258 1
a2258 1
	uint32_t sbval;
d2260 1
a2260 1
	/* XXX Return if radio is hardware disabled */
d2263 1
a2263 1
	if ((sc->sc_sprom.boardflags & BCW_BF_XTAL) == BCW_BF_XTAL)
d2266 1
a2266 1
	/* XXX bcw_powercontrol_clock_slow() */
d2268 8
a2275 7
	sbval = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOO);
	sbval |= BCW_PCTL_PLL_POWERDOWN;
	sbval &= ~BCW_PCTL_XTAL_POWERUP;
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOO, sbval);
	sbval = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_GPIOE);
	sbval |= BCW_PCTL_PLL_POWERDOWN | BCW_PCTL_XTAL_POWERUP;
	(sc->sc_conf_write)(sc->sc_dev_softc, BCW_GPIOE, sbval);
@


1.78
log
@Read the whole SPROM content with a single routine to a own sprom struct.

For those people who have reported about broken MAC address at attach
time, this should fix the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.77 2007/03/18 15:00:28 mglocker Exp $ */
d1500 5
d3199 5
@


1.77
log
@Comment routine which does the chip access validation.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.76 2007/03/18 14:40:47 mglocker Exp $ */
d143 4
a908 33
	 * Don't reset the chip here, we can only reset each core and we
	 * haven't identified the cores yet.
	 */
	//bcw_reset(sc);

	/*
	 * Attach to the Backplane and start the card up
	 */

	/*
	 * Get a copy of the BoardFlags and fix for broken boards.
	 * This needs to be done as soon as possible to determine if the
	 * board supports power control settings. If so, the board has to
	 * be powered on and the clock started. This may even need to go
	 * before the initial chip reset above.
	 */
	sc->sc_boardflags = BCW_READ16(sc, BCW_SPROM_BOARDFLAGS);

	/*
	 * Dell, Product ID 0x4301 Revision 0x74, set BCW_BF_BTCOEXIST
	 * Apple Board Type 0x4e Revision > 0x40, set BCW_BF_PACTRL
	 */

	/*
	 * Should just about everything below here be moved to external files
	 * to keep this file sane? The BCM43xx chips have so many exceptions
	 * based on the version of the chip, the radio, cores and phys that
	 * it would be a huge mess to inline it all here. See the 100 lines
	 * below for an example of just figuring out what the chip id is and
	 * how many cores it has.
	 */

	/*
a1225 11
	/* Read antenna gain from SPROM and multiply by 4 */
	sbval = BCW_READ16(sc, BCW_SPROM_ANTGAIN);
	/* If unset, assume 2 */
	if ((sbval == 0) || (sbval == 0xffff))
		sbval = 0x0202;
	if (sc->sc_phy_type == BCW_PHY_TYPEA)
		sc->sc_radio_gain = (sbval & 0xff);
	else
		sc->sc_radio_gain = ((sbval & 0xff00) >> 8);
	sc->sc_radio_gain *= 4;

d1227 1
a1227 2
	 * Set the paXbY vars, X=0 for PHY A, X=1 for B/G, but we'll
	 * just grab them all while we're here
d1229 9
a1237 8
	sc->sc_radio_pa0b0 = BCW_READ16(sc, BCW_SPROM_PA0B0);
	sc->sc_radio_pa0b1 = BCW_READ16(sc, BCW_SPROM_PA0B1);
	    
	sc->sc_radio_pa0b2 = BCW_READ16(sc, BCW_SPROM_PA0B2);
	sc->sc_radio_pa1b0 = BCW_READ16(sc, BCW_SPROM_PA1B0);
	    
	sc->sc_radio_pa1b1 = BCW_READ16(sc, BCW_SPROM_PA1B1);
	sc->sc_radio_pa1b2 = BCW_READ16(sc, BCW_SPROM_PA1B2);
a1238 7
	/* Get the idle TSSI */
	sbval = BCW_READ16(sc, BCW_SPROM_IDLETSSI);
	if (sc->sc_phy_type == BCW_PHY_TYPEA)
		sc->sc_idletssi = (sbval & 0xff);
	else
		sc->sc_idletssi = ((sbval & 0xff00) >> 8);
	
d1250 1
a1250 1
	    ((sc->sc_boardflags & BCW_BF_PACTRL) == BCW_BF_PACTRL))
d1255 1
a1255 1
	if ((sc->sc_boardflags & BCW_BF_XTAL) == BCW_BF_XTAL)
a1310 30
	/* MAC address */
	if (sc->sc_phy_type == BCW_PHY_TYPEA) {
		i = BCW_READ16(sc, BCW_SPROM_ET1MACADDR);
		ic->ic_myaddr[0] = (i & 0xff00) >> 8;
		ic->ic_myaddr[1] = i & 0xff;
		i = BCW_READ16(sc, BCW_SPROM_ET1MACADDR + 2);
		    
		ic->ic_myaddr[2] = (i & 0xff00) >> 8;
		ic->ic_myaddr[3] = i & 0xff;
		i = BCW_READ16(sc, BCW_SPROM_ET1MACADDR + 4);
		    
		ic->ic_myaddr[4] = (i & 0xff00) >> 8;
		ic->ic_myaddr[5] = i & 0xff;
	} else { /* assume B or G PHY */
		i = BCW_READ16(sc, BCW_SPROM_IL0MACADDR);
		    
		ic->ic_myaddr[0] = (i & 0xff00) >> 8;
		ic->ic_myaddr[1] = i & 0xff;
		i = BCW_READ16(sc, BCW_SPROM_IL0MACADDR + 2);
		    
		ic->ic_myaddr[2] = (i & 0xff00) >> 8;
		ic->ic_myaddr[3] = i & 0xff;
		i = BCW_READ16(sc, BCW_SPROM_IL0MACADDR + 4);
		    
		ic->ic_myaddr[4] = (i & 0xff00) >> 8;
		ic->ic_myaddr[5] = i & 0xff;
	}
	
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

d2211 1
a2211 1
	if ((sc->sc_boardflags & BCW_BF_XTAL) == BCW_BF_XTAL)
d2842 1
a2842 1
	if (sc->sc_boardflags & BCW_BF_PACTRL) {
d3056 1
a3056 1
		if (sc->sc_boardflags & BCW_BF_PACTRL)
d3116 184
d3410 1
a3410 1
		if (sc->sc_boardflags & BCW_BF_PACTRL)
d3424 1
a3424 1
	if (!(sc->sc_boardflags & BCW_BF_RSSI)) {
d3639 1
a3639 1
	if (sc->sc_boardflags & BCW_BF_RSSI) {
d3710 1
a3710 1
		if (sc->sc_boardflags & 0x8000) {
d3802 1
a3802 1
		if (sc->sc_boardflags & BCW_BF_RSSI) {
d3820 1
a3820 1
		if (sc->sc_boardflags & BCW_BF_PACTRL)
d4171 1
a4171 1
	if (sc->sc_boardflags & BCW_BF_EXTLNA) {
d4539 1
a4539 1
		if ((sc->sc_boardflags & BCW_BF_PACTRL) &&
d4586 2
a4587 1
				} else if (sc->sc_boardflags & BCW_BF_PACTRL) {
d5429 1
a5429 1
		if (!(sc->sc_boardflags & BCW_BF_RSSI))
d5458 1
a5458 1
		    !(sc->sc_boardflags & BCW_BF_RSSI)) {
@


1.76
log
@o Add bcw_80211_core_init() according to
  http://bcm-specs.sipsolutions.net/80211Init.
o Add a rewritten version of bcw_core_reset() called bcw_80211_core_reset()
  according to http://bcm-specs.sipsolutions.net/80211CoreReset.  This
  will probably replace bcw_core_reset(), but I need more verification
  first.
o Add bcw_core_enable() and bcw_core_disable().  There seems to be
  devices which contain several 802.11 cores.  The unused needs to be
  disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.75 2007/03/16 22:22:24 mglocker Exp $ */
d126 1
a126 1
int			bcw_validatechipaccess(struct bcw_softc *);
d1183 1
a1183 1
	error = bcw_validatechipaccess(sc);
d1839 5
d1846 1
a1846 1
bcw_validatechipaccess(struct bcw_softc *sc)
@


1.75
log
@Split the whole chip init stuff in bcw_init() into a new function
called bcw_chip_init(), according to the 80211Init steps in the spec.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.74 2007/03/16 15:28:54 mglocker Exp $ */
d72 2
d88 3
d130 3
d142 1
d183 2
d239 6
d573 1
a573 1
			return (BCW_READ16(sc, BCW_MMIO_SHM_DATAHIGH));
d589 1
a589 1
			BCW_WRITE16(sc, BCW_MMIO_SHM_DATAHIGH, val);
d607 1
a607 1
			r = BCW_READ16(sc, BCW_MMIO_SHM_DATAHIGH);
d622 20
d834 53
d1326 2
a1327 2
	    (BCW_SHM_SHARED << 16) + BCW_SHM_MICROCODEFLAGSLOW - 2);
	BCW_WRITE16(sc, BCW_MMIO_SHM_DATAHIGH, sbval & 0x00ff);
d1658 2
a1659 2
	/* initialize chip */
	if ((error = bcw_chip_init(sc)))
d2457 152
d3086 103
d5071 3
a5073 4
	ucodeflags = bcw_shm_read16(sc, BCW_SHM_SHARED,
	    BCW_SHM_MICROCODEFLAGSLOW);
	bcw_shm_write16(sc, BCW_SHM_SHARED, BCW_SHM_MICROCODEFLAGSLOW,
	    ucodeflags & ~BCW_SHM_MICROCODEFLAGSAUTODIV);
d5155 1
a5155 1
		    BCW_SHM_MICROCODEFLAGSLOW);
d5157 2
a5158 2
		    BCW_SHM_MICROCODEFLAGSLOW, ucodeflags |
		    BCW_SHM_MICROCODEFLAGSAUTODIV);
d5164 53
d6592 1
a6592 1
			    BCW_SHM_MICROCODEFLAGSLOW);
d6596 1
a6596 1
				    BCW_SHM_MICROCODEFLAGSLOW, tmp32);
d6701 45
@


1.74
log
@Cleanup prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.73 2007/03/16 13:49:11 mglocker Exp $ */
d133 1
d1559 3
a1561 1
/* initialize the interface */
d1565 2
a1566 51
	struct bcw_softc *sc = ifp->if_softc;
	uint16_t val16;
	uint32_t val32;
	int error, i, tmp;

	BCW_WRITE(sc, BCW_MMIO_SBF, BCW_SBF_CORE_READY | BCW_SBF_400_MAGIC);

	/* load firmware */
	if ((error = bcw_load_firmware(sc)))
		return (error);

	/*
	 * verify firmware revision
	 */
	BCW_WRITE(sc, BCW_MMIO_GIR, 0xffffffff);
	BCW_WRITE(sc, BCW_MMIO_SBF, 0x00020402);
	for (i = 0; i < 50; i++) {
		if (BCW_READ(sc, BCW_MMIO_GIR) == BCW_INTR_READY)
			break;
		delay(10);
	}
	if (i == 50) {
		printf("%s: interrupt-ready timeout!\n", sc->sc_dev.dv_xname);
		return (1);
	}
	BCW_READ(sc, BCW_MMIO_GIR);	/* dummy read */

	val16 = bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_REVISION);

	DPRINTF(("%s: Firmware revision 0x%x, patchlevel 0x%x "
            "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
	    sc->sc_dev.dv_xname, val16,
	    bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_PATCHLEVEL),
            (bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_DATE) >> 12)
            & 0xf,
            (bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_DATE) >> 8)
            & 0xf,
            bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_DATE)
            & 0xff,
            (bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_TIME) >> 11)
            & 0x1f,
            (bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_TIME) >> 5)
            & 0x3f,
            bcw_shm_read16(sc, BCW_SHM_SHARED, BCW_UCODE_TIME)
	    & 0x1f));

	if (val16 > 0x128) {
		printf("%s: no support for this firmware revision!\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}
d1568 2
a1569 2
	/* initialize GPIO */
	if ((error = bcw_gpio_init(sc)))
a1571 76
	/* load init values */
	if ((error = bcw_load_initvals(sc)))
		return (error);

	/* turn radio on */
	bcw_radio_on(sc);

	BCW_WRITE16(sc, 0x03e6, 0);
	if ((error = bcw_phy_init(sc)))
		return (error);

	/* select initial interference mitigation */
	tmp = sc->sc_radio_interfmode;
	sc->sc_radio_interfmode = BCW_RADIO_INTERFMODE_NONE;
	bcw_radio_set_interf_mitigation(sc, tmp);

	bcw_phy_set_antenna_diversity(sc);
	bcw_radio_set_txantenna(sc, BCW_RADIO_TXANTENNA_DEFAULT);
	if (sc->sc_phy_type == BCW_PHY_TYPEB) {
		val16 = BCW_READ16(sc, 0x005e);
		val16 |= 0x0004;
		BCW_WRITE16(sc, 0x005e, val16);
	}
	BCW_WRITE(sc, 0x0100, 0x01000000);
	if (sc->sc_core[sc->sc_currentcore].rev < 5)
		BCW_WRITE(sc, 0x010c, 0x01000000);

	val32 = BCW_READ(sc, BCW_MMIO_SBF);
	val32 &= ~BCW_SBF_ADHOC;
	BCW_WRITE(sc, BCW_MMIO_SBF, val32);
	val32 = BCW_READ(sc, BCW_MMIO_SBF);
	val32 |= BCW_SBF_ADHOC;
	BCW_WRITE(sc, BCW_MMIO_SBF, val32);

	val32 = BCW_READ(sc, BCW_MMIO_SBF);
	val32 |= 0x100000;
	BCW_WRITE(sc, BCW_MMIO_SBF, val32);

	if (bcw_using_pio(sc)) {
		BCW_WRITE(sc, 0x0210, 0x00000100);
		BCW_WRITE(sc, 0x0230, 0x00000100);
		BCW_WRITE(sc, 0x0250, 0x00000100);
		BCW_WRITE(sc, 0x0270, 0x00000100);
		bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0034, 0);
	}

	/* probe response timeout value */
	bcw_shm_write16(sc, BCW_SHM_SHARED, 0x0074, 0);

	/* initially set the wireless operation mode */
	bcw_set_opmode(ifp);

	if (sc->sc_core[sc->sc_currentcore].rev < 3) {
		BCW_WRITE16(sc, 0x060e, 0);
		BCW_WRITE16(sc, 0x0610, 0x8000);
		BCW_WRITE16(sc, 0x0604, 0);
		BCW_WRITE16(sc, 0x0606, 0x0200);
	} else {
		BCW_WRITE(sc, 0x0188, 0x80000000);
		BCW_WRITE(sc, 0x018c, 0x02000000);
	}
	BCW_WRITE(sc, BCW_MMIO_GIR, 0x00004000);
	BCW_WRITE(sc, BCW_MMIO_DMA0_INT_MASK, 0x0001dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA1_INT_MASK, 0x0000dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA2_INT_MASK, 0x0000dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA3_INT_MASK, 0x0001dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA4_INT_MASK, 0x0000dc00);
	BCW_WRITE(sc, BCW_MMIO_DMA5_INT_MASK, 0x0000dc00);

	val32 = BCW_READ(sc, BCW_CIR_SBTMSTATELOW);
	val32 |= 0x00100000;
	BCW_WRITE(sc, BCW_CIR_SBTMSTATELOW, val32);
	/* TODO bcw_pctl_powerup_delay(sc) */

	DPRINTF(("%s: Chip initialized\n", sc->sc_dev.dv_xname));

d2698 143
@


1.73
log
@Remove a lot of dead code and nonexisting registers.  This stuff was mostly
copied over from bce(4) and is obsolete or needs to be rewritten.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.72 2007/03/16 12:16:31 mglocker Exp $ */
a23 2
/* standard includes, probably some extras */

d63 158
a220 12
/* helper routines */
void		bcw_shm_ctl_word(struct bcw_softc *, uint16_t, uint16_t);
uint16_t	bcw_shm_read16(struct bcw_softc *, uint16_t, uint16_t);
void		bcw_shm_write16(struct bcw_softc *, uint16_t, uint16_t,
		    uint16_t);
uint32_t	bcw_shm_read32(struct bcw_softc *, uint16_t, uint16_t);
void		bcw_radio_write16(struct bcw_softc *, uint16_t, uint16_t);
int		bcw_radio_read16(struct bcw_softc *, uint16_t);
void		bcw_phy_write16(struct bcw_softc *, uint16_t, uint16_t);
int		bcw_phy_read16(struct bcw_softc *, uint16_t);
void		bcw_ram_write(struct bcw_softc *, uint16_t, uint32_t);
int		bcw_lv(int, int, int);
d222 4
a225 126
void		bcw_dummy_transmission(struct bcw_softc *);
struct bcw_lopair *
		bcw_get_lopair(struct bcw_softc *sc, uint16_t radio_atten,
		    uint16_t baseband_atten);
void		bcw_stack_save(uint32_t *, size_t *, uint8_t, uint16_t,
		    uint16_t);
uint16_t	bcw_stack_restore(uint32_t *, uint8_t, uint16_t);
int		bcw_using_pio(struct bcw_softc *);

void		bcw_reset(struct bcw_softc *);
int		bcw_init(struct ifnet *);
void		bcw_start(struct ifnet *);
void		bcw_stop(struct ifnet *, int);
void		bcw_watchdog(struct ifnet *);
void		bcw_set_opmode(struct ifnet *);
void		bcw_mac_enable(struct bcw_softc *);
uint32_t	bcw_intr_enable(struct bcw_softc *, uint32_t);
uint32_t	bcw_intr_disable(struct bcw_softc *, uint32_t);
void		bcw_rxintr(struct bcw_softc *);
void		bcw_txintr(struct bcw_softc *);
//void		bcw_add_mac(struct bcw_softc *, uint8_t *, unsigned long);
int		bcw_add_rxbuf(struct bcw_softc *, int);
void		bcw_rxdrain(struct bcw_softc *);
void		bcw_tick(void *);
int		bcw_ioctl(struct ifnet *, u_long, caddr_t);
int		bcw_alloc_rx_ring(struct bcw_softc *, struct bcw_rx_ring *,
		    int);
void		bcw_reset_rx_ring(struct bcw_softc *, struct bcw_rx_ring *);
void		bcw_free_rx_ring(struct bcw_softc *, struct bcw_rx_ring *);
int		bcw_alloc_tx_ring(struct bcw_softc *, struct bcw_tx_ring *,
		    int);
void		bcw_reset_tx_ring(struct bcw_softc *, struct bcw_tx_ring *);
void		bcw_free_tx_ring(struct bcw_softc *, struct bcw_tx_ring *);
/* 80211 functions copied from iwi */
int		bcw_newstate(struct ieee80211com *, enum ieee80211_state, int);
int		bcw_media_change(struct ifnet *);
void		bcw_media_status(struct ifnet *, struct ifmediareq *);
/* fashionably new functions */
int		bcw_validatechipaccess(struct bcw_softc *);
void		bcw_powercontrol_crystal_off(struct bcw_softc *);
int		bcw_change_core(struct bcw_softc *, int);
int		bcw_reset_core(struct bcw_softc *, uint32_t);
int		bcw_get_firmware(const char *, const uint8_t *, size_t,
		    size_t *, size_t *);
int		bcw_load_firmware(struct bcw_softc *);
int		bcw_write_initvals(struct bcw_softc *,
		    const struct bcw_initval *, const unsigned int);
int		bcw_load_initvals(struct bcw_softc *);
void		bcw_leds_switch_all(struct bcw_softc *, int);
int		bcw_gpio_init(struct bcw_softc *);
/* phy */
int		bcw_phy_init(struct bcw_softc *);
void		bcw_phy_initg(struct bcw_softc *);
void		bcw_phy_initb2(struct bcw_softc *);
void		bcw_phy_initb4(struct bcw_softc *);
void		bcw_phy_initb5(struct bcw_softc *);
void		bcw_phy_initb6(struct bcw_softc *);
void		bcw_phy_inita(struct bcw_softc *);
void		bcw_phy_setupa(struct bcw_softc *);
void		bcw_phy_setupg(struct bcw_softc *);
void		bcw_phy_calc_loopback_gain(struct bcw_softc *);
void		bcw_phy_agcsetup(struct bcw_softc *);
void		bcw_phy_init_pctl(struct bcw_softc *);
void		bcw_phy_init_noisescaletbl(struct bcw_softc *);
void		bcw_phy_set_baseband_atten(struct bcw_softc *, uint16_t);
int8_t		bcw_phy_estimate_powerout(struct bcw_softc *, int8_t tssi);
void		bcw_phy_xmitpower(struct bcw_softc *);
uint16_t	bcw_phy_lo_b_r15_loop(struct bcw_softc *);
void		bcw_phy_lo_b_measure(struct bcw_softc *);
void		bcw_phy_lo_g_state(struct bcw_softc *,  struct bcw_lopair *,
		    struct bcw_lopair *, uint16_t);
void		bcw_phy_lo_g_measure(struct bcw_softc *);
void		bcw_phy_lo_g_measure_txctl2(struct bcw_softc *);
uint32_t	bcw_phy_lo_g_singledeviation(struct bcw_softc *, uint16_t);
uint16_t	bcw_phy_lo_g_deviation_subval(struct bcw_softc *, uint16_t);
void		bcw_phy_lo_adjust(struct bcw_softc *, int fixed);
void		bcw_phy_lo_mark_current_used(struct bcw_softc *);
void		bcw_phy_lo_write(struct bcw_softc *, struct bcw_lopair *);
struct bcw_lopair *
		bcw_phy_find_lopair(struct bcw_softc *, uint16_t, uint16_t,
		    uint16_t);
struct bcw_lopair *
		bcw_phy_current_lopair(struct bcw_softc *);
void		bcw_phy_prepare_init(struct bcw_softc *);
void		bcw_phy_set_antenna_diversity(struct bcw_softc *);
/* radio */
void		bcw_radio_off(struct bcw_softc *);
void		bcw_radio_on(struct bcw_softc *);
void		bcw_radio_nrssi_hw_write(struct bcw_softc *, uint16_t, int16_t);
int16_t		bcw_radio_nrssi_hw_read(struct bcw_softc *, uint16_t);
void		bcw_radio_nrssi_hw_update(struct bcw_softc *, uint16_t);
void		bcw_radio_calc_nrssi_threshold(struct bcw_softc *);
void		bcw_radio_calc_nrssi_slope(struct bcw_softc *);
void		bcw_radio_calc_nrssi_offset(struct bcw_softc *);
void		bcw_radio_set_all_gains(struct bcw_softc *, int16_t, int16_t,
		    int16_t);
void		bcw_radio_set_original_gains(struct bcw_softc *);
uint16_t	bcw_radio_calibrationvalue(struct bcw_softc *);
void		bcw_radio_set_txpower_a(struct bcw_softc *, uint16_t);
void		bcw_radio_set_txpower_bg(struct bcw_softc *, uint16_t, uint16_t,
		    uint16_t);
uint16_t	bcw_radio_init2050(struct bcw_softc *);
void		bcw_radio_init2060(struct bcw_softc *);
void		bcw_radio_spw(struct bcw_softc *, uint8_t);
int		bcw_radio_select_channel(struct bcw_softc *, uint8_t, int );
uint16_t	bcw_radio_chan2freq_a(uint8_t);
uint16_t	bcw_radio_chan2freq_bg(uint8_t);
uint16_t	bcw_radio_default_baseband_attenuation(struct bcw_softc *);
uint16_t	bcw_radio_default_radio_attenuation(struct bcw_softc *);
uint16_t	bcw_radio_default_txctl1(struct bcw_softc *);
void		bcw_radio_clear_tssi(struct bcw_softc *);
void		bcw_radio_set_tx_iq(struct bcw_softc *);
uint16_t	bcw_radio_get_txgain_baseband(uint16_t);
uint16_t	bcw_radio_get_txgain_freq_power_amp(uint16_t);
uint16_t	bcw_radio_get_txgain_dac(uint16_t);
uint16_t	bcw_radio_freq_r3a_value(uint16_t);
void		bcw_radio_prepare_init(struct bcw_softc *);
int		bcw_radio_set_interference_mitigation(struct bcw_softc *, int);
int		bcw_radio_interference_mitigation_enable(struct bcw_softc *,
		    int);
void		bcw_radio_set_txantenna(struct bcw_softc *, uint32_t);
/* ilt */
void		bcw_ilt_write(struct bcw_softc *, uint16_t, uint16_t);
uint16_t	bcw_ilt_read(struct bcw_softc *, uint16_t);
/* power */
void		bcw_power_saving_ctl_bits(struct bcw_softc *, int, int);
d1632 1
a1632 1
	bcw_radio_set_interference_mitigation(sc, tmp);
d5693 1
a5693 1
bcw_radio_default_baseband_attenuation(struct bcw_softc *sc)
d5702 1
a5702 1
bcw_radio_default_radio_attenuation(struct bcw_softc *sc)
d5938 1
a5938 1
	    bcw_radio_default_baseband_attenuation(sc);
d5940 1
a5940 1
	    bcw_radio_default_radio_attenuation(sc);
d5961 1
a5961 1
bcw_radio_set_interference_mitigation(struct bcw_softc *sc, int mode)
d5993 1
a5993 1
		bcw_radio_interference_mitigation_enable(sc, mode);
d6000 1
a6000 1
bcw_radio_interference_mitigation_enable(struct bcw_softc *sc, int mode)
@


1.72
log
@Better (constant) register naming.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.71 2007/03/15 14:30:49 mglocker Exp $ */
a100 1
void		bcw_set_filter(struct ifnet *); 
d1381 3
a1383 1
/* Start packet transmission on the interface. */
d1388 4
a1391 6
	struct bcw_softc *sc = ifp->if_softc;
	struct mbuf    *m0;
	bus_dmamap_t    dmamap;
	int		txstart;
	int		txsfree;
	int		error;
a1392 1
	int		newpkts = 0;
d1394 1
a1394 4
	/*
	 * do not start another if currently transmitting, and more
	 * descriptors(tx slots) are needed for next packet.
	 */
a1396 114

#if 0   /* FIXME */
	/* determine number of descriptors available */
	if (sc->sc_txsnext >= sc->sc_txin)
		txsfree = BCW_NTXDESC - 1 + sc->sc_txin - sc->sc_txsnext;
	else
		txsfree = sc->sc_txin - sc->sc_txsnext - 1;

	/*
	 * Loop through the send queue, setting up transmit descriptors
	 * until we drain the queue, or use up all available transmit
	 * descriptors.
	 */
	while (txsfree > 0) {
		int	seg;

		/* Grab a packet off the queue. */
		IFQ_POLL(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;

		/* get the transmit slot dma map */
		dmamap = sc->sc_cdata.bcw_tx_map[sc->sc_txsnext];

		/*
		 * Load the DMA map.  If this fails, the packet either
		 * didn't fit in the alloted number of segments, or we
		 * were short on resources. If the packet will not fit,
		 * it will be dropped. If short on resources, it will
		 * be tried again later.
		 */
		error = bus_dmamap_load_mbuf(sc->sc_dmat, dmamap, m0,
		    BUS_DMA_WRITE | BUS_DMA_NOWAIT);
		if (error == EFBIG) {
			printf("%s: Tx packet consumes too many DMA segments, "
			    "dropping...\n", sc->sc_dev.dv_xname);
			IFQ_DEQUEUE(&ifp->if_snd, m0);
			m_freem(m0);
			ifp->if_oerrors++;
			continue;
		} else if (error) {
			/* short on resources, come back later */
			printf("%s: unable to load Tx buffer, error = %d\n",
			    sc->sc_dev.dv_xname, error);
			break;
		}
		/* If not enough descriptors available, try again later */
		if (dmamap->dm_nsegs > txsfree) {
			ifp->if_flags |= IFF_OACTIVE;
			bus_dmamap_unload(sc->sc_dmat, dmamap);
			break;
		}
		/* WE ARE NOW COMMITTED TO TRANSMITTING THE PACKET. */

		/* So take it off the queue */
		IFQ_DEQUEUE(&ifp->if_snd, m0);

		/* save the pointer so it can be freed later */
		sc->sc_cdata.bcw_tx_chain[sc->sc_txsnext] = m0;

		/* Sync the data DMA map. */
		bus_dmamap_sync(sc->sc_dmat, dmamap, 0, dmamap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

		/* Initialize the transmit descriptor(s). */
		txstart = sc->sc_txsnext;
		for (seg = 0; seg < dmamap->dm_nsegs; seg++) {
			uint32_t ctrl;

			ctrl = dmamap->dm_segs[seg].ds_len & CTRL_BC_MASK;
			if (seg == 0)
				ctrl |= CTRL_SOF;
			if (seg == dmamap->dm_nsegs - 1)
				ctrl |= CTRL_EOF;
			if (sc->sc_txsnext == BCW_NTXDESC - 1)
				ctrl |= CTRL_EOT;
			ctrl |= CTRL_IOC;
			sc->bcw_tx_ring[sc->sc_txsnext].ctrl = htole32(ctrl);
			/* MAGIC */
			sc->bcw_tx_ring[sc->sc_txsnext].addr =
			    htole32(dmamap->dm_segs[seg].ds_addr + 0x40000000);
			if (sc->sc_txsnext + 1 > BCW_NTXDESC - 1)
				sc->sc_txsnext = 0;
			else
				sc->sc_txsnext++;
			txsfree--;
		}
		/* sync descriptors being used */
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ring_map,
		    sizeof(struct bcw_dma_slot) * txstart + PAGE_SIZE,
		    sizeof(struct bcw_dma_slot) * dmamap->dm_nsegs,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

		/* Give the packet to the chip. */
		BCW_WRITE(sc, BCW_DMA_DPTR,
		    sc->sc_txsnext * sizeof(struct bcw_dma_slot));

		newpkts++;

#if NBPFILTER > 0
		/* Pass the packet to any BPF listeners. */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif				/* NBPFILTER > 0 */
	}
	if (txsfree == 0) {
		/* No more slots left; notify upper layer. */
		ifp->if_flags |= IFF_OACTIVE;
	}
#endif /* FIXME */
	if (newpkts) {
		/* Set a watchdog timer in case the chip flakes out. */
		ifp->if_timer = 5;
	}
a1503 4
	//struct bcw_softc *sc = arg;
	//uint32_t reason;

	return (0);
d1505 2
a1506 61
	struct ifnet *ifp;
	uint32_t intstatus;
	int wantinit;
	int handled = 0;

	for (wantinit = 0; wantinit == 0;) {
		intstatus = (sc->sc_conf_read)(sc->sc_dev_softc, BCW_INT_STS);

		/* ignore if not ours, or unsolicited interrupts */
		intstatus &= sc->sc_intmask;
		if (intstatus == 0)
			break;

		handled = 1;

		/* Ack interrupt */
		(sc->sc_conf_write)(sc->sc_dev_softc, BCW_INT_STS, intstatus);

		/* Receive interrupts. */
		if (intstatus & I_RI)
			bcw_rxintr(sc);
		/* Transmit interrupts. */
		if (intstatus & I_XI)
			bcw_txintr(sc);
		/* Error interrupts */
		if (intstatus & ~(I_RI | I_XI)) {
			if (intstatus & I_XU)
				printf("%s: transmit fifo underflow\n",
				    sc->sc_dev.dv_xname);
			if (intstatus & I_RO) {
				printf("%s: receive fifo overflow\n",
				    sc->sc_dev.dv_xname);
				ifp->if_ierrors++;
			}
			if (intstatus & I_RU)
				printf("%s: receive descriptor underflow\n",
				    sc->sc_dev.dv_xname);
			if (intstatus & I_DE)
				printf("%s: descriptor protocol error\n",
				    sc->sc_dev.dv_xname);
			if (intstatus & I_PD)
				printf("%s: data error\n",
				    sc->sc_dev.dv_xname);
			if (intstatus & I_PC)
				printf("%s: descriptor error\n",
				    sc->sc_dev.dv_xname);
			if (intstatus & I_TO)
				printf("%s: general purpose timeout\n",
				    sc->sc_dev.dv_xname);
			wantinit = 1;
		}
	}

	if (handled) {
		if (wantinit)
			bcw_init(ifp);
		/* Try to get more packets going. */
		bcw_start(ifp);
	}

	return (handled);
d1508 1
d1511 3
a1513 1
/* Receive interrupt handler */
d1518 2
a1519 109
	struct rx_pph *pph;
	struct mbuf *m;
	int len;
	int i;
#endif
	int curr;

	/* get pointer to active receive slot */
	curr = BCW_READ(sc, BCW_DMA_RXSTATUS(0)) & RS_CD_MASK;
	curr = curr / sizeof(struct bcw_dma_slot);
	if (curr >= BCW_RX_RING_COUNT)
		curr = BCW_RX_RING_COUNT - 1;

#if 0
	/* process packets up to but not current packet being worked on */
	for (i = sc->sc_rxin; i != curr;
	    i + 1 > BCW_NRXDESC - 1 ? i = 0 : i++) {
		/* complete any post dma memory ops on packet */
		bus_dmamap_sync(sc->sc_dmat, sc->sc_cdata.bcw_rx_map[i], 0,
		    sc->sc_cdata.bcw_rx_map[i]->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);

		/*
		 * If the packet had an error, simply recycle the buffer,
		 * resetting the len, and flags.
		 */
		pph = mtod(sc->sc_cdata.bcw_rx_chain[i], struct rx_pph *);
		if (pph->flags & (RXF_NO | RXF_RXER | RXF_CRC | RXF_OV)) {
			/* XXX Increment input error count */
			pph->len = 0;
			pph->flags = 0;
			continue;
		}
		/* receive the packet */
		len = pph->len;
		if (len == 0)
			continue;	/* no packet if empty */
		pph->len = 0;
		pph->flags = 0;
		/* bump past pre header to packet */
		sc->sc_cdata.bcw_rx_chain[i]->m_data +=
		    BCW_PREPKT_HEADER_SIZE;

 		/*
		 * The chip includes the CRC with every packet.  Trim
		 * it off here.
		 */
		len -= ETHER_CRC_LEN;

		/*
		 * If the packet is small enough to fit in a
		 * single header mbuf, allocate one and copy
		 * the data into it.  This greatly reduces
		 * memory consumption when receiving lots
		 * of small packets.
		 *
		 * Otherwise, add a new buffer to the receive
		 * chain.  If this fails, drop the packet and
		 * recycle the old buffer.
		 */
		if (len <= (MHLEN - 2)) {
			MGETHDR(m, M_DONTWAIT, MT_DATA);
			if (m == NULL)
				goto dropit;
			m->m_data += 2;
			memcpy(mtod(m, caddr_t),
			    mtod(sc->sc_cdata.bcw_rx_chain[i], caddr_t), len);
			sc->sc_cdata.bcw_rx_chain[i]->m_data -=
			    BCW_PREPKT_HEADER_SIZE;
		} else {
			m = sc->sc_cdata.bcw_rx_chain[i];
			if (bcw_add_rxbuf(sc, i) != 0) {
		dropit:
				/* XXX increment wireless input error counter */
				/* continue to use old buffer */
				sc->sc_cdata.bcw_rx_chain[i]->m_data -=
				    BCW_PREPKT_HEADER_SIZE;
				bus_dmamap_sync(sc->sc_dmat,
				    sc->sc_cdata.bcw_rx_map[i], 0,
				    sc->sc_cdata.bcw_rx_map[i]->dm_mapsize,
				    BUS_DMASYNC_PREREAD);
				continue;
			}
		}

		m->m_pkthdr.rcvif = ifp;
		m->m_pkthdr.len = m->m_len = len;
		/* XXX Increment input packet count */

#if NBPFILTER > 0
		/*
		 * Pass this up to any BPF listeners, but only
		 * pass it up the stack if it's for us.
		 *
		 * if (ifp->if_bpf)
		 *	bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
		 */
#endif				/* NBPFILTER > 0 */

		/* XXX Pass it on. */
		//ether_input_mbuf(ifp, m);

		/* re-check current in case it changed */
		curr = (BCW_READ(sc, BCW_DMA_RXSTATUS) & RS_CD_MASK) /
		    sizeof(struct bcw_dma_slot);
		if (curr >= BCW_NRXDESC)
			curr = BCW_NRXDESC - 1;
	}
	sc->sc_rxin = curr;
d1523 3
a1525 1
/* Transmit interrupt handler */
a1528 6
//	struct ifnet *ifp = &sc->bcw_ac.ac_if;
	int curr;
//	int i;

//	ifp->if_flags &= ~IFF_OACTIVE;

d1530 2
a1531 21
	/*
	 * Go through the Tx list and free mbufs for those
	 * frames which have been transmitted.
	 */
	curr = BCW_READ(sc, BCW_DMA_TXSTATUS) & RS_CD_MASK;
	curr = curr / sizeof(struct bcw_dma_slot);
	if (curr >= BCW_NTXDESC)
		curr = BCW_NTXDESC - 1;
	for (i = sc->sc_txin; i != curr;
	    i + 1 > BCW_NTXDESC - 1 ? i = 0 : i++) {
		/* do any post dma memory ops on transmit data */
		if (sc->sc_cdata.bcw_tx_chain[i] == NULL)
			continue;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_cdata.bcw_tx_map[i], 0,
		    sc->sc_cdata.bcw_tx_map[i]->dm_mapsize,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, sc->sc_cdata.bcw_tx_map[i]);
		m_freem(sc->sc_cdata.bcw_tx_chain[i]);
		sc->sc_cdata.bcw_tx_chain[i] = NULL;
		ifp->if_opackets++;
	}
a1532 1
	sc->sc_txin = curr;
a1533 6
	/*
	 * If there are no more pending transmissions, cancel the watchdog
	 * timer
	 */
//	if (sc->sc_txsnext == sc->sc_txin)
//		ifp->if_timer = 0;
a1671 89
#if 0
	/* Cancel any pending I/O. */
	bcw_stop(ifp, 0);

	/*
	 * Most of this needs to be rewritten to take into account the
	 * possible single/multiple core nature of the BCM43xx, and the
	 * differences from the BCM44xx ethernet chip that if_bce.c is
	 * written for.
	 */

	/* enable pci interrupts, bursts, and prefetch */

	/* remap the pci registers to the Sonics config registers */
	/* XXX - use (sc->sc_conf_read/write) */
	/* save the current map, so it can be restored */
	reg_win = BCW_READ(sc, BCW_REG0_WIN);

	/* set register window to Sonics registers */
	BCW_WRITE(sc, BCW_REG0_WIN, BCW_SONICS_WIN);

	/* enable SB to PCI interrupt */
	BCW_WRITE(sc, BCW_SBINTVEC, BCW_READ(sc, BCW_SBINTVEC) | SBIV_ENET0);

	/* enable prefetch and bursts for sonics-to-pci translation 2 */
	BCW_WRITE(sc, BCW_SPCI_TR2,
	    BCW_READ(sc, BCW_SPCI_TR2) | SBTOPCI_PREF | SBTOPCI_BURST);

	/* restore to ethernet register space */
	BCW_WRITE(sc, BCW_REG0_WIN, reg_win);

	/* Reset the chip to a known state. */
	bcw_reset(sc);

	/* FIXME */
	/* Initialize transmit descriptors */
	memset(sc->bcw_tx_ring, 0, BCW_NTXDESC * sizeof(struct bcw_dma_slot));
	sc->sc_txsnext = 0;
	sc->sc_txin = 0;

	/* enable crc32 generation and set proper LED modes */
	BCW_WRITE(sc, BCW_MACCTL,
	    BCW_READ(sc, BCW_MACCTL) | BCW_EMC_CRC32_ENAB | BCW_EMC_LED);
	    
	/* reset or clear powerdown control bit  */
	BCW_WRITE(sc, BCW_MACCTL, BCW_READ(sc, BCW_MACCTL) & ~BCW_EMC_PDOWN);

	/* setup DMA interrupt control */
	BCW_WRITE(sc, BCW_DMAI_CTL, 1 << 24);	/* MAGIC */

	/* setup packet filter */
	bcw_set_filter(ifp);

	/* set max frame length, account for possible VLAN tag */
	BCW_WRITE(sc, BCW_RX_MAX, ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);
	BCW_WRITE(sc, BCW_TX_MAX, ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);

	/* set tx watermark */
	BCW_WRITE(sc, BCW_TX_WATER, 56);

	/* enable transmit */
	BCW_WRITE(sc, BCW_DMA_TXCTL, XC_XE);

	/*
	 * Give the receive ring to the chip, and
	 * start the receive DMA engine.
	 */
	sc->sc_rxin = 0;

	/* enable receive */
	BCW_WRITE(sc, BCW_DMA_RXCTL, BCW_PREPKT_HEADER_SIZE << 1 | 1);

	/* Enable interrupts */
	sc->sc_intmask =
	    I_XI | I_RI | I_XU | I_RO | I_RU | I_DE | I_PD | I_PC | I_TO;
	BCW_WRITE(sc, BCW_INT_MASK, sc->sc_intmask);
	    
	/* FIXME */
	/* start the receive dma */
	BCW_WRITE(sc, BCW_DMA_RXDPTR,
	    BCW_NRXDESC * sizeof(struct bcw_dma_slot));

	/* set media */
	//mii_mediachg(&sc->bcw_mii);

	/* turn on the ethernet mac */
	BCW_WRITE(sc, BCW_ENET_CTL, BCW_READ(sc, BCW_ENET_CTL) | EC_EE);
	    
#endif
d1682 3
a1684 1
/* Add a receive buffer to the indicated descriptor. */
a1687 30
#if 0
	struct mbuf *m;
	int error;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);

	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}
	if (sc->sc_cdata.bcw_rx_chain[idx] != NULL)
		bus_dmamap_unload(sc->sc_dmat,
		    sc->sc_cdata.bcw_rx_map[idx]);

	sc->sc_cdata.bcw_rx_chain[idx] = m;

	error = bus_dmamap_load(sc->sc_dmat, sc->sc_cdata.bcw_rx_map[idx],
	    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
	    BUS_DMA_READ | BUS_DMA_NOWAIT);
	if (error)
		return (error);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cdata.bcw_rx_map[idx], 0,
	    sc->sc_cdata.bcw_rx_map[idx]->dm_mapsize, BUS_DMASYNC_PREREAD);

	BCW_INIT_RXDESC(sc, idx);

a1688 3
#endif
	return (1);

d1691 3
a1693 1
/* Drain the receive queue. */
a1696 3
#if 0
	/* FIXME */
	int i;
a1697 9
	for (i = 0; i < BCW_NRXDESC; i++) {
		if (sc->sc_cdata.bcw_rx_chain[i] != NULL) {
			bus_dmamap_unload(sc->sc_dmat,
			    sc->sc_cdata.bcw_rx_map[i]);
			m_freem(sc->sc_cdata.bcw_rx_chain[i]);
			sc->sc_cdata.bcw_rx_chain[i] = NULL;
		}
	}
#endif
a1704 1
	//uint32_t val;
a1717 11
	/* Disable emac */
#if 0
	BCW_WRITE(sc, BCW_ENET_CTL, EC_ED);
	for (i = 0; i < 200; i++) {
		val = BCW_READ(sc, BCW_ENET_CTL);
		    
		if (!(val & EC_ED))
			break;
		delay(10);
	}
#endif
a1722 12
#if 0	/* FIXME */
	/* Release any queued transmit buffers. */
	for (i = 0; i < BCW_NTXDESC; i++) {
		if (sc->sc_cdata.bcw_tx_chain[i] != NULL) {
			bus_dmamap_unload(sc->sc_dmat,
			    sc->sc_cdata.bcw_tx_map[i]);
			m_freem(sc->sc_cdata.bcw_tx_chain[i]);
			sc->sc_cdata.bcw_tx_chain[i] = NULL;
		}
	}
#endif

a1761 14
#if 0
	if ((sbval & (SBTML_RESET | reject | SBTML_CLK)) == SBTML_CLK) {
		/* XXX Stop all DMA */
		/* XXX reset the dma engines */
	}
	/* XXX Cores are reset manually elsewhere for now */
	/* Reset the wireless core, attaching the PHY */
	bcw_reset_core(sc, SBTML_80211FLAG | SBTML_80211PHY );
	bcw_change_core(sc, sc->sc_core_common->num);
	bcw_reset_core(sc, 0);
	bcw_change_core(sc, sc->sc_core_bus->num);
	bcw_reset_core(sc, 0);
#endif
	/* XXX update PHYConnected to requested value */
a1770 14
	/* XXX Clear saved interrupt status for DMA controllers */

	/*
	 * XXX Attach cores to the backplane, if we have more than one
	 * Don't attach PCMCIA cores on a PCI card, and reverse?
	 * OR together the bus flags of the 3 cores and write to PCICR
	 */
#if 0
	if (sc->sc_havecommon == 1) {
		sbval = (sc->sc_conf_read)(sc, BCW_PCICR);
		sbval |= 0x1 << 8; /* XXX hardcoded bitmask of single core */
		(sc->sc_conf_write)(sc, BCW_PCICR, sbval);
	}
#endif
a1774 41
/* Set up the receive filter. */
void
bcw_set_filter(struct ifnet *ifp)
{
#if 0
	struct bcw_softc *sc = ifp->if_softc;

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		BCW_WRITE(sc, BCW_RX_CTL, BCW_READ(sc, BCW_RX_CTL) | ERC_PE);
	} else {
		ifp->if_flags &= ~IFF_ALLMULTI;

		/* turn off promiscuous */
		BCW_WRITE(sc, BCW_RX_CTL, BCW_READ(sc, BCW_RX_CTL) & ~ERC_PE);

		/* enable/disable broadcast */
		if (ifp->if_flags & IFF_BROADCAST)
			BCW_WRITE(sc, BCW_RX_CTL,
			    BCW_READ(sc, BCW_RX_CTL) & ~ERC_DB);
		else
			BCW_WRITE(sc, BCW_RX_CTL,
			    BCW_READ(sc, BCW_RX_CTL) | ERC_DB);

		/* disable the filter */
		BCW_WRITE(sc, BCW_FILT_CTL, 0);

		/* add our own address */
		// bcw_add_mac(sc, sc->bcw_ac.ac_enaddr, 0);

		/* for now accept all multicast */
		BCW_WRITE(sc, BCW_RX_CTL, BCW_READ(sc, BCW_RX_CTL) | ERC_AM);

		ifp->if_flags |= IFF_ALLMULTI;

		/* enable the filter */
		BCW_WRITE(sc, BCW_FILT_CTL, BCW_READ(sc, BCW_FILT_CTL) | 1);
	}
#endif
}

a1777 7
#if 0
	struct bcw_softc *sc = ic->ic_softc;
	enum ieee80211_state ostate;
	uint32_t tmp;

	ostate = ic->ic_state;
#endif
a1800 1
	//uint32_t val;
d1833 3
a1835 1
/* One second timer, checks link status */
d1841 1
a1954 31

#if 0
void
bcw_free_ring(struct bcw_softc *sc, struct bcw_dma_slot *ring)
{
	struct bcw_chain data *data;
	struct bcw_dma_slot *bcwd;
	int i;

	if (sc->bcw_rx_chain != NULL) {
		for (i = 0; i < BCW_NRXDESC; i++) {
			bcwd = &sc->bcw_rx_ring[i];

			if (sc->bcw_rx_chain[i] != NULL) {
				bus_dmamap_sync(sc->sc_dmat,
				    sc->bcw_ring_map,
				    sizeof(struct bcw_dma_slot) * x,
				    sizeof(struct bcw_dma_slot),
				    BUS_DMASYNC_POSTREAD);
				bus_dmamap_unload(sc->sc_dmat,
				    sc->bcw_ring_map);
				m_freem(sc->bcw_rx_chain[i]);
			}

			if (sc->bcw_ring_map != NULL)
				bus_dmamap_destroy(sc->sc_dmat,
				    sc->bcw_ring_map);
		}
	}
}
#endif
@


1.71
log
@Set chip operation mode in the init path.  Add first bits to enable
interrupts at some point.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.70 2007/03/12 22:29:38 mglocker Exp $ */
d524 1
a524 1
	BCW_WRITE(sc, BCW_SHM_CONTROL, control);
d530 1
a530 1
	if (routing == BCW_SHM_CONTROL_SHARED) {
d534 1
a534 1
			return (BCW_READ16(sc, BCW_SHM_DATAHIGH));
d540 1
a540 1
	return (BCW_READ16(sc, BCW_SHM_DATA));
d547 1
a547 1
	if (routing == BCW_SHM_CONTROL_SHARED) {
d550 1
a550 1
			BCW_WRITE16(sc, BCW_SHM_DATAHIGH, val);
d556 1
a556 1
	BCW_WRITE16(sc, BCW_SHM_DATA, val);
d564 1
a564 1
	if (routing == BCW_SHM_CONTROL_SHARED) {
d568 1
a568 1
			r = BCW_READ16(sc, BCW_SHM_DATAHIGH);
d571 1
a571 1
			r |= BCW_READ16(sc, BCW_SHM_DATA);
d577 1
a577 1
	r = BCW_READ(sc, BCW_SHM_DATA);
d585 2
a586 2
	BCW_WRITE16(sc, BCW_RADIO_CONTROL, offset);
	BCW_WRITE16(sc, BCW_RADIO_DATALOW, val);
d612 1
a612 1
	BCW_WRITE16(sc, BCW_RADIO_CONTROL, offset);
d614 1
a614 1
	return (BCW_READ16(sc, BCW_RADIO_DATALOW));
d620 2
a621 2
	BCW_WRITE16(sc, BCW_PHY_CONTROL, offset);
	BCW_WRITE16(sc, BCW_PHY_DATA, val);
d627 1
a627 1
	BCW_WRITE16(sc, BCW_PHY_CONTROL, offset);
d629 1
a629 1
	return (BCW_READ16(sc, BCW_PHY_DATA));
d637 1
a637 1
	status = BCW_READ(sc, BCW_SBF);
d686 1
a686 1
	BCW_READ(sc, BCW_SBF);
d1045 2
a1046 2
		BCW_WRITE16(sc, BCW_RADIO_CONTROL, BCW_RADIO_ID);
		sbval = BCW_READ16(sc, BCW_RADIO_DATAHIGH);
d1048 3
a1050 2
		BCW_WRITE16(sc, BCW_RADIO_CONTROL, BCW_RADIO_ID);
		sc->sc_radio_mnf = sbval | BCW_READ16(sc, BCW_RADIO_DATALOW);
d1213 4
a1216 4
	BCW_WRITE(sc, BCW_SHM_CONTROL,
	    (BCW_SHM_CONTROL_SHARED << 16) + BCW_SHM_MICROCODEFLAGSLOW - 2);
	BCW_WRITE16(sc, BCW_SHM_DATAHIGH, sbval & 0x00ff);
	BCW_WRITE16(sc, BCW_SHM_DATALOW, (sbval & 0xff00) >> 16);
d1543 1
a1543 1
	status = BCW_READ(sc, BCW_SBF);
d1586 5
a1590 4
	BCW_WRITE(sc, BCW_SBF, BCW_READ(sc, BCW_SBF) | BCW_SBF_MAC_ENABLED);
	BCW_WRITE(sc, BCW_GIR, BCW_INTR_READY);
	BCW_READ(sc, BCW_SBF); /* dummy read */
	BCW_READ(sc, BCW_GIR); /* dummy read */
d1599 2
a1600 2
	old_mask = BCW_READ(sc, BCW_GIM);
	BCW_WRITE(sc, BCW_GIM, old_mask | mask);
d1612 2
a1613 2
	old_mask = BCW_READ(sc, BCW_GIM);
	BCW_WRITE(sc, BCW_GIM, old_mask & ~mask);
d1861 1
a1861 1
	BCW_WRITE(sc, BCW_SBF, BCW_SBF_CORE_READY | BCW_SBF_400_MAGIC);
d1870 2
a1871 2
	BCW_WRITE(sc, BCW_GIR, 0xffffffff);
	BCW_WRITE(sc, BCW_SBF, 0x00020402);
d1873 1
a1873 1
		if (BCW_READ(sc, BCW_GIR) == BCW_INTR_READY)
d1881 1
a1881 1
	BCW_READ(sc, BCW_GIR);	/* dummy read */
d1883 1
a1883 1
	val16 = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, BCW_UCODE_REVISION);
d1888 2
a1889 2
	    bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, BCW_UCODE_PATCHLEVEL),
            (bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, BCW_UCODE_DATE) >> 12)
d1891 1
a1891 1
            (bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, BCW_UCODE_DATE) >> 8)
d1893 1
a1893 1
            bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, BCW_UCODE_DATE)
d1895 1
a1895 1
            (bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, BCW_UCODE_TIME) >> 11)
d1897 1
a1897 1
            (bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, BCW_UCODE_TIME) >> 5)
d1899 1
a1899 1
            bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, BCW_UCODE_TIME)
d1939 1
a1939 1
	val32 = BCW_READ(sc, BCW_SBF);
d1941 2
a1942 2
	BCW_WRITE(sc, BCW_SBF, val32);
	val32 = BCW_READ(sc, BCW_SBF);
d1944 1
a1944 1
	BCW_WRITE(sc, BCW_SBF, val32);
d1946 1
a1946 1
	val32 = BCW_READ(sc, BCW_SBF);
d1948 1
a1948 1
	BCW_WRITE(sc, BCW_SBF, val32);
d1955 1
a1955 1
		bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0034, 0);
d1959 1
a1959 1
	bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0074, 0);
d1973 7
a1979 7
	BCW_WRITE(sc, BCW_GIR, 0x00004000);
	BCW_WRITE(sc, BCW_DMA0_INT_MASK, 0x0001dc00);
	BCW_WRITE(sc, BCW_DMA1_INT_MASK, 0x0000dc00);
	BCW_WRITE(sc, BCW_DMA2_INT_MASK, 0x0000dc00);
	BCW_WRITE(sc, BCW_DMA3_INT_MASK, 0x0001dc00);
	BCW_WRITE(sc, BCW_DMA4_INT_MASK, 0x0000dc00);
	BCW_WRITE(sc, BCW_DMA5_INT_MASK, 0x0000dc00);
d2161 1
a2161 1
	BCW_WRITE(sc, BCW_DMA0_INT_MASK, 0);
d2251 1
a2251 1
	sbval = BCW_READ(sc, BCW_SBF);
d2253 1
a2253 1
	BCW_WRITE(sc, BCW_SBF, sbval);
d2409 2
a2410 2
	BCW_WRITE(sc, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
	save = BCW_READ(sc, BCW_SHM_DATA);
d2413 2
a2414 2
	BCW_WRITE(sc, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
	BCW_WRITE(sc, BCW_SHM_DATA, 0xaa5555aa);
d2416 1
a2416 1
	BCW_WRITE(sc, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
d2418 1
a2418 1
	val = BCW_READ(sc, BCW_SHM_DATA);
d2423 2
a2424 2
	BCW_WRITE(sc, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
	BCW_WRITE(sc, BCW_SHM_DATA, 0x55aaaa55);
d2426 1
a2426 1
	BCW_WRITE(sc, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
d2428 1
a2428 1
	val = BCW_READ(sc, BCW_SHM_DATA);
d2433 2
a2434 2
	BCW_WRITE(sc, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
	BCW_WRITE(sc, BCW_SHM_DATA, save);
d2454 1
a2454 1
	val = BCW_READ(sc, BCW_SBF);
d2462 1
a2462 1
	val = BCW_READ(sc, BCW_GIR);
d2848 1
a2848 1
	if ((sbval & BCW_XTALPOWERUP) != BCW_XTALPOWERUP) {
d2850 1
a2850 1
		sbval |= (BCW_XTALPOWERUP & BCW_PLLPOWERDOWN);
d2854 1
a2854 1
		sbval &= ~BCW_PLLPOWERDOWN;
d2874 2
a2875 2
	sbval |= BCW_PLLPOWERDOWN;
	sbval &= ~BCW_XTALPOWERUP;
d2878 1
a2878 1
	sbval |= BCW_PLLPOWERDOWN | BCW_XTALPOWERUP;
d3120 1
a3120 1
	bcw_shm_ctl_word(sc, BCW_SHM_CONTROL_MCODE, 0);
d3122 1
a3122 1
		BCW_WRITE(sc, BCW_SHM_DATA, betoh32(data[i]));
d3130 3
a3132 3
	bcw_shm_ctl_word(sc, BCW_SHM_CONTROL_PCM, 0x01ea);
	BCW_WRITE(sc, BCW_SHM_DATA, 0x00004000);
	bcw_shm_ctl_word(sc, BCW_SHM_CONTROL_PCM, 0x01eb);
d3134 1
a3134 1
		BCW_WRITE(sc, BCW_SHM_DATA, betoh32(data[i]));
d3327 1
a3327 1
	BCW_WRITE(sc, BCW_SBF, BCW_READ(sc, BCW_SBF) & 0xffff3fff);
d3331 2
a3332 1
	BCW_WRITE16(sc, BCW_GPIO_MASK, BCW_READ16(sc, BCW_GPIO_MASK) | 0x000f);
d3342 2
a3343 2
		BCW_WRITE16(sc, BCW_GPIO_MASK, BCW_READ16(sc, BCW_GPIO_MASK) |
		    0x0100);
d3348 2
a3349 2
		BCW_WRITE16(sc, BCW_GPIO_MASK, BCW_READ16(sc, BCW_GPIO_MASK) |
		    0x0200);
d4577 1
a4577 1
		tmp = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, 0x0058);
d4580 1
a4580 1
		tmp = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, 0x005a);
d4586 1
a4586 1
			tmp = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED,
d4590 1
a4590 1
			tmp = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED,
d4608 1
a4608 1
		if (tmp && (bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, 0x005e) &
d5258 1
a5258 1
	ucodeflags = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED,
d5260 1
a5260 1
	bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, BCW_SHM_MICROCODEFLAGSLOW,
d5342 1
a5342 1
		ucodeflags = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED,
d5344 1
a5344 1
		bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED,
d5914 1
a5914 1
	bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0064, radio_atten);
d6368 2
a6369 2
		bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0068, 0x7f7f);
		bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x006a, 0x7f7f);
d6373 4
a6376 4
		bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0058, 0x7f7f);
		bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x005a, 0x7f7f);
		bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0070, 0x7f7f);
		bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0072, 0x7f7f);
d6726 1
a6726 1
			tmp32 = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED,
d6730 1
a6730 1
				bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED,
d6767 6
a6772 6
	tmp = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, 0x0022) & 0xfcff;
	bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0022, tmp | val);
	tmp = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, 0x03a8) & 0xfcff;
	bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x03a8, tmp | val);
	tmp = bcw_shm_read16(sc, BCW_SHM_CONTROL_SHARED, 0x0054) & 0xfcff;
	bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0054, tmp | val);
d6818 1
a6818 1
	status = BCW_READ(sc, BCW_SBF);
d6827 1
a6827 1
	BCW_WRITE(sc, BCW_SBF, status);
d6830 1
a6830 1
			if (bcw_shm_read32(sc, BCW_SHM_CONTROL_SHARED, 0x0040)
@


1.70
log
@In bcw_init() check for real revision numbers now and fix a wrong
register (typo).
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.69 2007/03/12 06:51:16 mglocker Exp $ */
d70 1
d92 4
d203 2
d559 23
d1532 86
d1619 1
a1619 1
bcw_intr(void *xsc)
d1621 5
a1625 1
	struct bcw_softc *sc;
a1630 2
	sc = xsc;

d1687 1
d1956 1
d1959 3
d6797 36
@


1.69
log
@Finish chip base initialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.68 2007/03/04 19:04:31 mglocker Exp $ */
d1815 1
a1815 1
	if (1) /* XXX current_core->rev */
d1839 1
a1839 1
	if (1) { /* XXX core_rev */
d1846 1
a1846 1
		BCW_WRITE(sc, 0x0606, 0x02000000);
d1859 1
@


1.68
log
@Fix another panic in bcw_phy_init() for sparc64.  Now firmware loads
and radio initializes on sparc64, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.67 2007/03/04 16:10:10 mglocker Exp $ */
d81 4
d158 1
d191 4
d203 11
d703 42
d1737 2
a1738 1
	int error, i;
d1802 59
a1860 1
	return (0);
d1862 1
a1875 1
#if 0
a1894 1
#endif
d1896 1
a1896 1
#if 0 /* FIXME */
a1900 1
#endif
a1938 1
#if 0
a1942 1
#endif
d1946 1
a1946 1
#if 0
d2035 1
a2035 1
	BCW_WRITE(sc, BCW_INT_MASK, 0);
d5119 106
d6384 262
@


1.67
log
@Fix bcw_gpio_init();  Before we can write to the GPIO control register,
we must switch back to the common core.  Found because sparc64 panics
on this (I start to like sparc64 :).
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.66 2007/03/04 15:41:58 mglocker Exp $ */
d3244 1
a3244 1
			bcw_phy_write16(sc, 0x002f, 0x807f);
d4673 3
a4675 3
	regstack[9]  = bcw_phy_read16(sc, 0x43);
	regstack[10] = bcw_phy_read16(sc, 0x7a);
	regstack[11] = bcw_phy_read16(sc, 0x52);
@


1.66
log
@Make bcw_change_core() conform to other functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.65 2007/03/04 14:27:27 mglocker Exp $ */
d3082 1
d3113 6
a3118 3
	 * TODO
	 * We need to switch to common or pci core before we can write
	 * to BCW_GPIO_CTR.
d3120 2
a3121 1
	return (0);
d3126 3
a3128 1
	return (0);
@


1.65
log
@Fix panic caused by bcw_leds_switch_all() because reading from wrong
register.  Noted while testing on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.64 2007/03/04 00:43:26 mglocker Exp $ */
d736 1
a736 1
	if (bcw_change_core(sc, 0))
d847 1
a847 1
		if (bcw_change_core(sc, i)) {
a2027 1

d2642 2
a2643 2
	uint32_t	sbval;
	int		i;
d2647 1
d2655 11
a2665 6
	if (i < 10) {
		sc->sc_lastcore = sc->sc_currentcore;
		sc->sc_currentcore = changeto;
		return 1;
	} else
		return 0;
@


1.64
log
@Kill a cardbus dependency which breaked kernel compilation e.g. for
sparc*.

OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.63 2007/03/01 19:48:00 mglocker Exp $ */
d3054 1
a3054 1
	ledctl = BCW_READ16(sc, BCW_GPIO_CTRL);
d3070 1
a3070 1
	BCW_WRITE16(sc, BCW_GPIO_CTRL, ledctl);
d3105 7
@


1.63
log
@Set phy / radio softc vars to initial default values.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.62 2007/02/27 07:04:18 mglocker Exp $ */
a58 1
#include <dev/cardbus/cardbusvar.h>
d1452 1
a1452 1
		intstatus = (sc->sc_conf_read)(sc, BCW_INT_STS);
d1462 1
a1462 1
		(sc->sc_conf_write)(sc, BCW_INT_STS, intstatus);
d2605 1
a2605 1
	sbval = (sc->sc_conf_read)(sc, BCW_GPIOI);
d2607 1
a2607 1
		sbval = (sc->sc_conf_read)(sc, BCW_GPIOO);
d2609 1
a2609 1
		(sc->sc_conf_write)(sc, BCW_GPIOO, sbval);
d2611 1
a2611 1
		sbval = (sc->sc_conf_read)(sc, BCW_GPIOO);
d2613 1
a2613 1
		(sc->sc_conf_write)(sc, BCW_GPIOO, sbval);
d2631 1
a2631 1
	sbval = (sc->sc_conf_read)(sc, BCW_GPIOO);
d2634 2
a2635 2
	(sc->sc_conf_write)(sc, BCW_GPIOO, sbval);
	sbval = (sc->sc_conf_read)(sc, BCW_GPIOE);
d2637 1
a2637 1
	(sc->sc_conf_write)(sc, BCW_GPIOE, sbval);
d2646 1
a2646 1
	(sc->sc_conf_write)(sc, BCW_ADDR_SPACE0,
d2650 1
a2650 1
		sbval = (sc->sc_conf_read)(sc, BCW_ADDR_SPACE0);
@


1.62
log
@Fix page fault trap in radio init code path and activate radio init in
bcw_init().  Remove obsolete debug code therefore.  The radio seems
to initialize (can't verify yet), but I'm sure there are still some tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.61 2007/02/26 16:15:35 mglocker Exp $ */
d154 1
d179 1
d186 1
d937 3
d942 2
a943 1
	memset(sc->sc_phy_lopairs, 0, sizeof(struct bcw_lopair) * BCW_LO_COUNT);
d4966 18
d5980 15
d6114 29
@


1.61
log
@Finish bcw_radio_default_radio_attenuation().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.60 2007/02/26 15:40:04 mglocker Exp $ */
d684 5
a688 6
	struct ifnet	*ifp = &ic->ic_if;
	int		error;
	int		i;
	uint32_t	sbval;
	//uint16_t	sbval16;
	uint32_t	core_id, core_rev, core_vendor;
d906 1
d911 1
d914 1
d932 5
a936 1
	} /* end of switch */
d1730 2
a1731 2
	//if ((error = bcw_phy_init(sc)))
	//	return (error);
a3456 2
	printf("trap 1\n");

a3585 1
	printf("trap 2\n");
a4901 2
	printf("trap 4\n");

a4902 2

	printf("trap 4 end\n");
a4918 2
	printf("trap 5\n");

a4921 2
	printf("trap 5 end\n");

a4930 2
	printf("trap 6\n");

a4931 2

	printf("trap 6 end\n");
a5524 2

	printf("trap 3\n");
@


1.60
log
@As we have the PCI softc data now, replace the fake if's with real ones.
Add some more debug info.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.59 2007/02/25 17:03:08 mglocker Exp $ */
d5895 19
d5915 36
d5953 9
d5963 1
a5963 1
	return (0);
@


1.59
log
@Power on/off cardbus socket at attach/detach time.  Makes firmware upload
work on my BCM4318 cardbus device now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.58 2007/02/25 09:59:18 mglocker Exp $ */
d695 4
d736 1
a736 1
		DPRINTF(("\n%s: Selected ChipCommon Core\n",
d3257 2
a3258 1
	if (1) { /* XXX bcw->board_vendor */
d3636 2
a3637 1
	if (1) { /* XXX board_vendor, board_type */
d3862 3
a3864 1
		if (1) /* XXX board_vendor, board_type, board_revision */
d3878 3
a3880 1
		if (1) /* XXX board_vendor, board_type, board_revision */
d4154 4
a4157 1
	/* TODO board_vendor, board_type */
d4286 2
a4287 1
	if (1) /* XXX board_vendor, board_type */
@


1.58
log
@Calculate number of cores correctly.  This is done based on the common
core revision.  Now my BCM4318 and BCM4306 both get the right number of
cores.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.57 2007/02/24 23:05:04 mglocker Exp $ */
d688 1
a688 1
//	uint16_t	sbval16;
d691 4
d699 1
a699 1
//	bcw_reset(sc);
d2234 4
@


1.57
log
@Get correct chip revision and also get chip package.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.56 2007/02/24 11:59:33 mglocker Exp $ */
d689 1
d736 6
a741 2
	DPRINTF(("%s: Got Core ID Reg 0x%x, type is 0x%x\n",
	    sc->sc_dev.dv_xname, sbval, (sbval & 0x8ff0) >> 4));
d747 1
a747 1
	if (((sbval & 0x00008ff0) >> 4) == BCW_CORE_COMMON) {
d749 1
d751 1
d756 2
a757 3
		//sc->sc_chip_rev =
		//    ((sbval & 0x00007000) >> 8 | (sbval & 0x0000000f));
		if ((sc->sc_chip_rev == 4) || (sc->sc_chip_rev >= 6))
d759 1
a759 1
		else
d785 3
a787 2
			} /* end of switch */
	} else { /* No CommonCore, set chipid,cores,rev based on product id */
d828 2
a829 2
		} /* end of switch */
	} /* End of if/else */
@


1.56
log
@Fix value typos, sync radio vars with phy vars, add radio default
attenuation routine, add temporary debug printfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.55 2007/02/23 22:28:08 mglocker Exp $ */
d746 6
a751 4
		sc->sc_chipid = (sbval & 0x0000ffff);
		sc->sc_chiprev =
		    ((sbval & 0x00007000) >> 8 | (sbval & 0x0000000f));
		if ((sc->sc_chiprev == 4) || (sc->sc_chiprev >= 6))
d754 1
a754 1
			switch (sc->sc_chipid) {
d790 1
a790 1
			sc->sc_chipid = 0x4710;
d799 1
a799 1
			sc->sc_chipid = 0x4610;
d804 1
a804 1
			sc->sc_chipid = 0x4402;
d810 1
a810 1
			sc->sc_chipid = 0x4307;
d814 1
a814 1
			sc->sc_chipid = 0x4301;
d818 1
a818 1
			sc->sc_chipid = sc->sc_prodid;
d824 4
a827 3
	DPRINTF(("%s: ChipID=0x%x, ChipRev=0x%x, NumCores=%d\n",
	    sc->sc_dev.dv_xname, sc->sc_chipid,
	    sc->sc_chiprev, sc->sc_numcores));
d925 1
a925 1
	if (sc->sc_chipid != 0x4317) {
d932 1
a932 1
		switch (sc->sc_chiprev) {
d1709 2
a1710 2
	if ((error = bcw_phy_init(sc)))
		return (error);
d2593 1
a2593 1
	if (sc->sc_chiprev < 5)
d3056 1
a3056 1
	if (sc->sc_chipid == 0x4301) {
d3072 1
a3072 1
	if (sc->sc_chiprev >= 2)
d3221 1
a3221 1
	if (sc->sc_chipid == 0x4306 && sc->sc_chiprev == 2) {
@


1.55
log
@Add bcw_phy_lo_g_state().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.54 2007/02/23 20:30:20 mglocker Exp $ */
d176 2
a177 1
uint16_t	bcw_radio_defaultbaseband(struct bcw_softc *);
d890 1
a890 1
	sc->sc_phy_version = (sbval & 0xf000) >> 12;
d894 1
a894 1
	    sc->sc_dev.dv_xname, sc->sc_phy_version, sc->sc_phy_rev));
d1093 1
a1093 1
	BCW_WRITE16(sc, BCW_SHM_DATALOW, (sbval & 0xff00)>>16);
d3428 2
d3549 1
a3549 1

d3559 1
d3912 1
a3912 1
	if (sc->sc_phy_version == 9)
d4204 1
a4204 1
	if (sc->sc_phy_version == 0) {
d4211 1
a4211 1
	if (sc->sc_phy_version > 1) {
d4867 2
d4870 2
d4888 2
d4893 2
d4904 2
d4907 2
d4921 2
d5485 1
a5485 1
	if (radio_atten == 0xfff)
d5487 1
a5487 1
	if (txpower == 0xfff)
d5503 2
d5558 1
a5558 1
	if (sc->sc_phy_version == 0)
d5561 1
a5561 1
		if (sc->sc_phy_version >= 2)
d5654 1
a5654 1
	if (sc->sc_phy_version != 0)
d5832 1
a5832 1
bcw_radio_defaultbaseband(struct bcw_softc *sc)
d5838 31
a5868 1
} 
@


1.54
log
@Add bcw_radio_freq_r3a_value() and complement bcw_phy_initg().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.53 2007/02/23 20:10:32 mglocker Exp $ */
d140 2
d148 1
a153 1
void		bcw_lowrite(struct bcw_softc *, struct bcw_lopair *);
d1705 2
a1706 2
	//if ((error = bcw_phy_init(sc)))
	//	return (error);
d3114 1
d3119 1
a3119 1
		printf("%s: Unknown PHYTYPE found!\n", sc->sc_dev.dv_xname);
d4501 81
d4699 1
a4699 1
			/* TODO bcm43xx_phy_lo_g_state() */
d4863 1
a4863 1
	bcw_lowrite(sc, pair);
d4875 20
a4915 11
}

void
bcw_lowrite(struct bcw_softc *sc, struct bcw_lopair *pair)
{
	uint16_t val;

	val = (uint8_t)(pair->low);
	val |= ((uint8_t)(pair->high)) << 8;

	bcw_phy_write16(sc, BCW_PHY_G_LO_CONTROL, val);
@


1.53
log
@Complement and fix a bunch of things in bcw_radio_select_channel().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.52 2007/02/23 19:51:37 mglocker Exp $ */
d180 1
d3166 1
a3166 1
			sc->sc_radio_initval = 0; /* XXX bcw_radio_initval */ 
d4615 1
a4615 1
			/* XXX bcm43xx_phy_lo_g_state() */
d5383 1
a5383 1
	/* XXX do we need that assert() mess here really? */
d5662 1
a5662 1
		    0xff20) | 0); /* TODO */
d5829 17
@


1.52
log
@Add missing routine to just allow a number in a given range.  Replaces
some /* XXX */ lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.51 2007/02/23 19:44:37 mglocker Exp $ */
d171 3
a173 2
int		bcw_radio_channel(struct bcw_softc *, uint8_t, int );
int		bcw_radio_chan2freq_bg(uint8_t);
d1702 2
a1703 2
	if ((error = bcw_phy_init(sc)))
		return (error);
d3283 1
a3283 1
	bcw_radio_channel(sc, 7, 0);
d3303 1
a3303 1
	bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG, 0);
d3334 1
a3334 1
		bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG, 0);
d3336 1
a3336 1
		bcw_radio_channel(sc, sc->sc_radio_channel, 0);
d3383 1
a3383 1
		bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG, 0);
d3385 1
a3385 1
		bcw_radio_channel(sc, sc->sc_radio_channel, 0);
d3523 1
a3523 1
	bcw_radio_channel(sc, 7, 0);
d3541 1
a3541 1
	bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG, 0);
d4533 1
a4533 1
	bcw_radio_channel(sc, 6, 0);
d4698 1
a4698 1
	bcw_radio_channel(sc, oldchannel, 1);
d4868 2
a4869 1
		if (bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_BG, 1))
d5543 1
a5543 1
	bcw_radio_channel(sc, sc->sc_radio_channel, 1);
d5602 1
a5602 1
	error = bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL_A, 0);
d5628 1
a5628 1
bcw_radio_channel(struct bcw_softc *sc, uint8_t channel, int spw)
d5632 3
a5634 1
	freq = 1; /* TODO */
d5636 3
a5638 3
	r8 = bcw_radio_read16(sc, 0x0008);
	BCW_WRITE16(sc, 0x3f0, freq);
	bcw_radio_write16(sc, 0x0008, r8);
d5640 2
a5641 2
	tmp = bcw_radio_read16(sc, 0x002e);
	tmp &= 0x0080;
d5643 1
a5643 1
	bcw_radio_write16(sc, 0x002e, tmp);
d5645 2
a5646 5
	if (freq >= 4920 && freq <= 5500)
		r8 = 3 * freq / 116;

	if (sc->sc_radio_mnf == 0x17f && sc->sc_radio_ver == 0x2060 &&
	    sc->sc_radio_rev == 1) {
a5669 1

a5670 1

d5679 6
a5684 1
		/* TODO more stuff if channel = 14 */
d5687 2
d5694 9
a5702 1
int
@


1.51
log
@Add bcw_phy_xmitpower().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.50 2007/02/23 14:27:00 mglocker Exp $ */
d4904 1
a4904 1
		/* XXX limit_value() ? */
d4932 1
a4932 1
		threshold = 0; /* XXX limit_value() */
d4983 1
a4983 1
			a = 0; /* XXX limit_value() */
d4992 1
a4992 1
			b = 0; /* XXX limit_value() */
d5342 1
a5342 1
	/* TODO txpower = limit_value(txpower, 0, 63); */
@


1.50
log
@Complement bcw_radio_set_txpower_a().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.49 2007/02/23 12:24:55 mglocker Exp $ */
d76 2
d136 2
d145 1
d588 11
d3201 1
a3201 1
			/* XXX assert() ? */
d3204 1
a3204 1
			/* XXX assert() ? */
d4116 1
a4116 1
	/* XXX assert() ? */
d4212 171
d4780 9
d5001 1
a5001 1
		/* XXX assert() ?*/
d5602 1
a5602 1
	/* XXX assert(error == 0) ? */
d5672 1
a5672 1
		/* TODO bcw_radio_phy_xmitpower() */
@


1.49
log
@Add and activate bcw_radio_init2050 (radio type B).
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.48 2007/02/23 10:52:24 mglocker Exp $ */
d171 3
d5148 1
a5148 1
	/* TODO pamp = bcw_get_txgain_freq_power_amp(txpower); */
d5153 1
a5153 1
	/*TODO base = bcw_get_txgain_banseband(txpower); */
d5160 1
a5160 1
	/* TODO dac = bcw_get_txgain_dac(txpower); */
d5551 67
@


1.48
log
@Activate bcw_phy_init2060() (type A radio) in bcw_radio_on().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.47 2007/02/23 10:40:54 mglocker Exp $ */
d163 1
d3330 1
a3330 1
		/* TODO bcw_radio_init2050() */
d3373 1
a3373 1
		/* TODO bcw_radio_init2050() */
d5193 169
@


1.47
log
@Complement bcw_phy_inita(), add bcw_radio_init2060().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.46 2007/02/22 21:26:49 mglocker Exp $ */
d4660 1
a4660 1
		/* TODO bcw_radio_init_2060() */
@


1.46
log
@Add bcw_phy_lo_b_measure().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.45 2007/02/22 19:25:45 mglocker Exp $ */
d160 1
d163 1
d169 1
d3565 1
a3565 1
	//uint16_t val;
d3575 36
d5138 28
d5195 44
d5301 1
a5301 1
		/* TODO bcw_radio_set_tx_iq() */
d5358 19
@


1.45
log
@Add bcw_phy_initb2() and bcw_phy_initb4().  Activate bcw_phy_init() in the
bcw_init() path.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.44 2007/02/22 17:04:31 mglocker Exp $ */
d134 2
d159 1
d176 10
d3332 1
a3332 1
	/* TODO bcw_phy_lo_b_measure() */
d3377 1
a3377 1
	/* TODO bcw_phy_lo_b_measure() */
d3543 1
a3543 1
	if (sc->sc_phy_type == BCW_PHY_TYPEG) {
d3548 7
a3554 1
		/* TODO */
d4153 112
d5082 14
@


1.44
log
@Halftime for PHY init code, another ~1000 new lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.43 2007/02/20 21:24:36 mglocker Exp $ */
d122 2
d1665 2
a1666 4
	//if ((error = bcw_phy_init(sc)))
		//return (error);

	assert(0);
d3054 1
a3054 1
			// bcw_phy_initb2(sc);
d3058 1
a3058 1
			// bcw_phy_initb4(sc);
d3266 1
a3266 1
	bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL, 0);
d3281 101
d3504 1
a3504 1
	bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL, 0);
d4497 1
a4497 1
		if (bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL, 1))
@


1.43
log
@~1052 lines of new PHY radio initialization code and no end in sight.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.42 2007/02/18 16:03:33 mglocker Exp $ */
d75 2
d129 1
d133 3
d147 8
d161 1
d548 81
d3072 1
a3072 1
		// bcw_phy_initg(sc);
d3092 1
a3092 1
	if (sc->sc_phy_rev >= 2 || 1) /* XXX phy->connect */
d3103 1
a3103 1
		if (1) { /* XXX phy->connect */
d3116 1
a3116 1
	if (sc->sc_phy_rev < 3 && 1) /* XXX phy->connect */
d3124 1
a3124 1
	if (sc->sc_phy_rev >= 2 && 1) /* XXX phy->connect */
d3134 48
d3205 1
a3205 1
	if (1) { /* XXX phy->connected */
d3932 48
d4036 231
d4268 35
d4395 1
a4395 1
		bcw_phy_write16(sc, 0x0015, 0); /* XXX check for phy connect */
d4413 439
d4984 18
@


1.42
log
@Add bcw_phy_set_baseband_attenuation().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.41 2007/02/18 15:19:03 mglocker Exp $ */
d66 1
a66 1
/* register routines */
d75 3
d122 15
a136 1
void		bcw_phy_set_baseband_attenuation(struct bcw_softc *, uint16_t);
d140 2
a141 1
void		bcw_radio_txpower_bg(struct bcw_softc *, uint16_t, uint16_t,
d147 3
d156 282
a437 1
 * Register routines
d533 8
d1570 2
d2966 1
a2966 1
			// bcw_phy_initb5(sc);
d2970 1
a2970 1
			// bcw_phy_initb6(sc);
d2990 2
d2996 42
d3128 1
a3128 1
	/* TODO bcw_radio_set_tx_power() */
d3270 1
a3270 1
	/* TODO bcw_radio_set_tx_power() */
d3296 525
a3820 2
bcw_phy_set_baseband_attenuation(struct bcw_softc *sc,
    uint16_t baseband_attenuation)
d3826 1
a3826 1
		val |= (baseband_attenuation & 0x000f);
d3833 1
a3833 1
		val |= (baseband_attenuation << 2) & 0x003c;
d3836 1
a3836 1
		val |= (baseband_attenuation << 3) & 0x0078;
d3841 53
d3949 1
a3949 2
bcw_radio_txpower_bg(struct bcw_softc *sc, uint16_t baseband_attenuation,
    uint16_t radio_attenuation, uint16_t txpower)
d3951 24
a3974 7
	//if (baseband_attenuation == 0xffff)
	//if (radio_attenuation == 0xfff)
	//if (txpower == 0xfff)

	bcw_phy_set_baseband_attenuation(sc, baseband_attenuation);
	bcw_radio_write16(sc, 0x0043, radio_attenuation);
	bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0064, radio_attenuation);
d3980 2
a3981 1
	//if (sc->sc_phy_type == BCW_PHY_TYPEG)
d4087 27
@


1.41
log
@Comment corrections from Bret Lambert.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.40 2007/02/18 15:14:38 mglocker Exp $ */
d119 1
a119 1
void		bcw_phy_lo_adjust(struct bcw_softc *, int);
d2939 23
d3017 2
a3018 2
bcw_radio_txpower_bg(struct bcw_softc *sc, uint16_t baseband_att,
    uint16_t radio_att, uint16_t txpower)
d3020 2
a3021 2
	//if (baseband_att == 0xffff)
	//if (radio_att == 0xfff)
d3024 3
a3026 2
	bcw_radio_write16(sc, 0x0043, radio_att);
	bcw_shm_write16(sc, BCW_SHM_CONTROL_SHARED, 0x0064, radio_att);
@


1.40
log
@Add bcw_shm_write16().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.39 2007/02/18 11:42:40 mglocker Exp $ */
d252 1
a252 1
	 * Get a copy of the BoardFlags and fix for broken boards
d662 1
a662 1
	 * The receive, and transmit rings are 4k aligned
d1365 1
a1365 1
/* Add a receive buffer to the indiciated descriptor. */
@


1.39
log
@Sort routines (phy, radio).
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.38 2007/02/18 09:37:21 mglocker Exp $ */
d69 2
d119 1
d123 1
a123 1
void		bcw_radio_txpower(struct bcw_softc *, uint16_t, uint16_t,
d166 16
d2994 1
a2994 1
bcw_radio_txpower(struct bcw_softc *sc, uint16_t baseband_att,
d2997 9
d3007 2
@


1.38
log
@Start to add radio PHY initialization routines.

Rename some radio variable names to names which doesn't confuse me
everytime I have to use them.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.37 2007/02/18 00:05:39 mglocker Exp $ */
d66 1
a77 1

a86 1

a94 1

a102 5
void		bcw_radio_off(struct bcw_softc *);
void		bcw_radio_on(struct bcw_softc *);
int		bcw_radio_channel(struct bcw_softc *, uint8_t, int );
void		bcw_spw(struct bcw_softc *, uint8_t);
int		bcw_chan2freq_bg(uint8_t);
d112 1
a112 1

d117 9
d131 3
a2160 146
void
bcw_radio_off(struct bcw_softc *sc)
{
	/* Magic unexplained values */
	if (sc->sc_phy_type == BCW_PHY_TYPEA) {
		bcw_radio_write16(sc, 0x0004, 0x00ff);
		bcw_radio_write16(sc, 0x0005, 0x00fb);
		bcw_phy_write16(sc, 0x0010, bcw_phy_read16(sc, 0x0010) |
		    0x0008);
		bcw_phy_write16(sc, 0x0011, bcw_phy_read16(sc, 0x0011) |
		    0x0008);
	}
	if (sc->sc_phy_type == BCW_PHY_TYPEB && sc->sc_core_80211->rev >= 5) {
		bcw_phy_write16(sc, 0x0811, bcw_phy_read16(sc, 0x0811) |
		    0x008c);
		bcw_phy_write16(sc, 0x0812, bcw_phy_read16(sc, 0x0812) &
		    0xff73);
	} else
		bcw_phy_write16(sc, 0x0015, 0xaa00);

	DPRINTF(("%s: Radio turned off\n", sc->sc_dev.dv_xname));
}

void
bcw_radio_on(struct bcw_softc *sc)
{
	switch (sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		bcw_radio_write16(sc, 0x0004, 0x00c0);
		bcw_radio_write16(sc, 0x0005, 0x0008);
		bcw_phy_write16(sc, 0x0010, bcw_phy_read16(sc, 0x0010) &
		    0xfff7);
		bcw_phy_write16(sc, 0x0011, bcw_phy_read16(sc, 0x0011) &
		    0xfff7);
		/* TODO bcw_radio_init_2060() */
		break;
	case BCW_PHY_TYPEB:
	case BCW_PHY_TYPEG:
		bcw_phy_write16(sc, 0x0015, 0x8000);
		bcw_phy_write16(sc, 0x0015, 0xcc00);
		bcw_phy_write16(sc, 0x0015, 0); /* XXX check for phy connect */
		if (bcw_radio_channel(sc, BCW_RADIO_DEFAULT_CHANNEL, 1))
			return;
		break;
	default:
		return;
	}

	DPRINTF(("%s: Radio turned on\n", sc->sc_dev.dv_xname)); 
}

int
bcw_radio_channel(struct bcw_softc *sc, uint8_t channel, int spw)
{
	uint16_t freq, tmp, r8;

	freq = 1; /* TODO */

	r8 = bcw_radio_read16(sc, 0x0008);
	BCW_WRITE16(sc, 0x3f0, freq);
	bcw_radio_write16(sc, 0x0008, r8);

	tmp = bcw_radio_read16(sc, 0x002e);
	tmp &= 0x0080;

	bcw_radio_write16(sc, 0x002e, tmp);

	if (freq >= 4920 && freq <= 5500)
		r8 = 3 * freq / 116;

	if (sc->sc_radio_mnf == 0x17f && sc->sc_radio_ver == 0x2060 &&
	    sc->sc_radio_rev == 1) {
		bcw_radio_write16(sc, 0x0007, (r8 << 4) | r8);
		bcw_radio_write16(sc, 0x0020, (r8 << 4) | r8);
		bcw_radio_write16(sc, 0x0021, (r8 << 4) | r8);
		bcw_radio_write16(sc, 0x0022, (bcw_radio_read16(sc, 0x0022) &
		    0x000f) | (r8 << 4));
		bcw_radio_write16(sc, 0x002a, (r8 << 4));
		bcw_radio_write16(sc, 0x002b, (r8 << 4));
		bcw_radio_write16(sc, 0x0008, (bcw_radio_read16(sc, 0x0008) &
		    0x00f0) | (r8 << 4));
		bcw_radio_write16(sc, 0x0029, (bcw_radio_read16(sc, 0x0029) &
		    0xff0f) | 0x00b0);
		bcw_radio_write16(sc, 0x0035, 0x00aa);
		bcw_radio_write16(sc, 0x0036, 0x0085);
		bcw_radio_write16(sc, 0x003a, (bcw_radio_read16(sc, 0x003a) &
		    0xff20) | 0); /* TODO */
		bcw_radio_write16(sc, 0x003d, bcw_radio_read16(sc, 0x003d) &
		    0x00ff);
		bcw_radio_write16(sc, 0x0081, (bcw_radio_read16(sc, 0x0081) &
		    0xff7f) | 0x0080);
		bcw_radio_write16(sc, 0x0035, bcw_radio_read16(sc, 0x0035) &
		    0xffef);
		bcw_radio_write16(sc, 0x0035, (bcw_radio_read16(sc, 0x0035) &
		    0xffef) | 0x0010);

		/* TODO bcw_radio_set_tx_iq() */

		/* TODO bcw_radio_phy_xmitpower() */
	} else {
		if (spw)
			bcw_spw(sc, channel);
		
		BCW_WRITE16(sc, BCW_MMIO_CHANNEL, bcw_chan2freq_bg(channel));

		/* TODO more stuff if channel = 14 */
	}

	delay(8000);

	return (0);
}

void
bcw_spw(struct bcw_softc *sc, uint8_t channel)
{
	if (sc->sc_radio_ver != 0x2050 || sc->sc_radio_rev >= 6)
		/* we do not need the workaround */
		return;

	if (channel <= 10)
		BCW_WRITE16(sc, BCW_MMIO_CHANNEL,
		    bcw_chan2freq_bg(channel + 4));
	else
		BCW_WRITE16(sc, BCW_MMIO_CHANNEL, bcw_chan2freq_bg(1));

	delay(100);

	BCW_WRITE16(sc, BCW_MMIO_CHANNEL, bcw_chan2freq_bg(channel));
}

int
bcw_chan2freq_bg(uint8_t channel)
{
	static const uint16_t freqs_bg[14] = {
	    12, 17, 22, 27,
	    32, 37, 42, 47,
	    52, 57, 62, 67,
	    72, 84 };

	if (channel < 1 && channel > 14)
		return (0);

	return (freqs_bg[channel - 1]);
}

d2918 166
@


1.37
log
@Turn radio (version 2050) on.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.36 2007/01/14 10:48:23 mglocker Exp $ */
d120 5
d172 1
a172 1
		if (sc->sc_radiotype == 0x2053) {
d177 1
a177 1
		} else if (sc->sc_radiotype == 0x2050)
d454 1
a454 1
		sc->sc_radioid = sbval | BCW_READ16(sc, BCW_RADIO_DATALOW);
d458 1
a458 1
			sc->sc_radioid = 0x3205017F;
d461 1
a461 1
			sc->sc_radioid = 0x4205017f;
d464 1
a464 1
			sc->sc_radioid = 0x5205017f;
d468 2
a469 2
	sc->sc_radiorev = (sc->sc_radioid & 0xf0000000) >> 28;
	sc->sc_radiotype = (sc->sc_radioid & 0x0ffff000) >> 12;
d472 2
a473 2
	    sc->sc_dev.dv_xname, sc->sc_radiorev, sc->sc_radiotype,
	    sc->sc_radioid & 0xfff));
d527 1
a527 1
	    (sc->sc_radiotype != 0x2060)) {
d529 1
a529 1
		    	    sc->sc_dev.dv_xname, sc->sc_radiotype);
d533 1
a533 1
	    ((sc->sc_radiotype & 0xfff0) != 0x2050)) {
d535 1
a535 1
		    	    sc->sc_dev.dv_xname, sc->sc_radiotype);
d539 1
a539 1
	    (sc->sc_radiotype != 0x2050)) {
d541 1
a541 1
		    	    sc->sc_dev.dv_xname, sc->sc_radiotype);
d598 2
a599 2
	if ((sc->sc_radiotype == 0x2050) &&
	    (sc->sc_radiorev <= 5))
d1233 2
d2226 2
a2227 2
	if (sc->sc_radioid == 0x17f && sc->sc_radiotype == 0x2060 &&
	    sc->sc_radiorev == 1) {
d2272 1
a2272 1
	if (sc->sc_radiotype != 0x2050 || sc->sc_radiorev >= 6)
d2749 310
@


1.36
log
@Introduce register read/write helper routines for radio and phy.  Start
to add bcw_radio_on() and bcw_radio_channel().

ok Jon Simola
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.35 2007/01/07 11:10:51 mglocker Exp $ */
d108 2
d1225 3
a1227 1
	//bcw_radio_on(sc);
d2168 2
d2189 3
a2191 3
		/* XXX we must check for phy connected later */
		bcw_phy_write16(sc, 0x0015, 1 ? 0x00c0 : 0);
		/* TODO bcw_radio_channel() */
d2194 1
a2194 1
		break;
d2196 2
d2219 2
a2220 1
	if (1) {
d2249 6
a2254 1
		/* TODO */
d2262 32
@


1.35
log
@Spacing, comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.34 2007/01/07 00:29:44 mglocker Exp $ */
d68 4
d106 2
d151 50
d1222 3
d2148 17
a2164 1
	uint16_t sbval16;
d2166 3
d2171 7
a2177 15
		/* Magic unexplained values */
		BCW_WRITE16(sc, BCW_RADIO_CONTROL, 0x04);
		BCW_WRITE16(sc, BCW_RADIO_DATALOW, 0xff);
		BCW_WRITE16(sc, BCW_RADIO_CONTROL, 0x05);
		BCW_WRITE16(sc, BCW_RADIO_DATALOW, 0xfb);
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x10);
		sbval16 = BCW_READ16(sc, BCW_PHY_DATA);
		sbval16 |= 0x8;
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x10);
		BCW_WRITE16(sc, BCW_PHY_DATA, sbval16);
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x11);
		sbval16 = BCW_READ16(sc, BCW_PHY_DATA);
		sbval16 |= 0x8;
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x11);
		BCW_WRITE16(sc, BCW_PHY_DATA, sbval16);
d2179 1
d2181 6
a2186 13
		if (sc->sc_core_80211->rev >= 5) {
			BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x811);
			sbval16 = BCW_READ16(sc, BCW_PHY_DATA);
			sbval16 |= 0x8c;
			BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x811);
			BCW_WRITE16(sc, BCW_PHY_DATA, sbval16);
			BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x812);
			sbval16 = BCW_READ16(sc, BCW_PHY_DATA);
			sbval16 &= 0xff73;
			BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x812);
			BCW_WRITE16(sc, BCW_PHY_DATA, sbval16);
		}
		/* FALLTHROUGH */
d2188 53
a2240 2
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x15);
		BCW_WRITE16(sc, BCW_PHY_DATA, 0xaa00);
d2242 4
d2247 1
@


1.34
log
@Initialize GPIO.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.33 2007/01/06 20:33:09 mglocker Exp $ */
d2089 1
a2089 1
	uint16_t	sbval16;
d2091 1
a2091 1
	switch(sc->sc_phy_type) {
d2122 1
a2122 1
		/* FALL-THROUGH */
d2126 1
a2126 1
	} /* end of switch statement to turn off radio */
@


1.33
log
@Fix error string for loadfirmware().
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.32 2007/01/06 18:35:09 mglocker Exp $ */
d109 2
d1158 4
d2511 65
@


1.32
log
@Make the driver able to read the network byte ordered firmware file.

ok deraadt@@ (also for the last dev/microcode/bcw import).
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.31 2007/01/05 12:52:30 mglocker Exp $ */
d2404 1
a2404 1
		printf("%s: error %d, could not read initval0 %s!\n",
@


1.31
log
@Check that ucode size doesn't get exceeded when parsing for a firmware
file.

Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.30 2007/01/05 11:36:23 mglocker Exp $ */
d2266 1
d2277 2
a2278 2
			*size = h->filesize;
			*offset = h->fileoffset;
@


1.30
log
@If the firmware load routines fail, be sure the ucode gets freed.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.29 2007/01/05 10:37:19 mglocker Exp $ */
d103 2
a104 2
int		bcw_get_firmware(const char *, const uint8_t *, size_t *,
		    size_t *);
d2255 2
a2256 2
bcw_get_firmware(const char *name, const uint8_t *ucode, size_t *size,
    size_t *offset)
d2269 1
a2269 1
	for (i = 0; i < nfiles; i++) {
d2310 2
a2311 1
	if (bcw_get_firmware(filename, ucode, &size_micro, &off_micro) != 0) {
d2321 2
a2322 1
	if (bcw_get_firmware(filename, ucode, &size_pcm, &off_pcm) != 0) {
d2445 2
a2446 1
	if (bcw_get_firmware(filename, ucode, &size_ival0, &off_ival0) != 0) {
d2475 2
a2476 2
		if (bcw_get_firmware(filename, ucode, &size_ival1, &off_ival1)
		    != 0) {
@


1.29
log
@Report about correct firmware filename if not found.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.28 2007/01/05 10:20:04 mglocker Exp $ */
d2313 1
a2313 1
		return (EIO);
d2323 1
a2323 1
		return (EIO);
d2351 3
d2418 3
a2420 1
			goto bad_noinitval;
d2432 3
a2434 1
			goto bad_noinitval;
d2436 4
a2439 2
	} else
		goto bad_noinitval;
d2446 1
a2446 1
		return (EIO);
d2464 3
a2466 1
			goto bad_noinitval;
d2476 1
a2476 1
			return (EIO);
d2483 1
a2483 1
		return (EIO);
d2491 1
a2491 1
			return (EIO);
d2499 1
a2499 2
bad_noinitval:
	printf("%s: no initvals available!\n", sc->sc_dev.dv_xname);
@


1.28
log
@Prototypes spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.27 2007/01/05 10:17:32 mglocker Exp $ */
d2311 2
a2312 2
		printf("%s: getting firmware file %s failed!\n",
		    sc->sc_dev.dv_xname, name);
d2321 2
a2322 2
		printf("%s: getting firmware file %s failed!\n",
		    sc->sc_dev.dv_xname, name);
d2435 1
a2435 1
		printf("%s: getting initval0 file %s failed\n",
d2463 1
a2463 1
			printf("%s: getting initval1 file %s failed\n",
@


1.27
log
@Make the upload of initialization values work again, after implementing
the single firmware file.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.26 2007/01/05 07:09:15 mglocker Exp $ */
d66 1
a66 1
void	bcw_shm_ctl_word(struct bcw_softc *, uint16_t, uint16_t);
d69 23
a91 21
void	bcw_reset(struct bcw_softc *);
int	bcw_init(struct ifnet *);
void	bcw_start(struct ifnet *);
void	bcw_stop(struct ifnet *, int);

void	bcw_watchdog(struct ifnet *);
void	bcw_rxintr(struct bcw_softc *);
void	bcw_txintr(struct bcw_softc *);
//void	bcw_add_mac(struct bcw_softc *, uint8_t *, unsigned long);
int	bcw_add_rxbuf(struct bcw_softc *, int);
void	bcw_rxdrain(struct bcw_softc *);
void	bcw_set_filter(struct ifnet *); 
void	bcw_tick(void *);
int	bcw_ioctl(struct ifnet *, u_long, caddr_t);

int	bcw_alloc_rx_ring(struct bcw_softc *, struct bcw_rx_ring *, int);
void	bcw_reset_rx_ring(struct bcw_softc *, struct bcw_rx_ring *);
void	bcw_free_rx_ring(struct bcw_softc *, struct bcw_rx_ring *);
int	bcw_alloc_tx_ring(struct bcw_softc *, struct bcw_tx_ring *, int);
void	bcw_reset_tx_ring(struct bcw_softc *, struct bcw_tx_ring *);
void	bcw_free_tx_ring(struct bcw_softc *, struct bcw_tx_ring *);
d94 3
a96 3
int	bcw_newstate(struct ieee80211com *, enum ieee80211_state, int);
int	bcw_media_change(struct ifnet *);
void	bcw_media_status(struct ifnet *, struct ifmediareq *);
d98 11
a108 10
int	bcw_validatechipaccess(struct bcw_softc *);
void	bcw_powercontrol_crystal_off(struct bcw_softc *);
int	bcw_change_core(struct bcw_softc *, int);
void	bcw_radio_off(struct bcw_softc *);
int	bcw_reset_core(struct bcw_softc *, uint32_t);
int	bcw_get_firmware(const char *, const uint8_t *, size_t *, size_t *);
int	bcw_load_firmware(struct bcw_softc *);
int	bcw_write_initvals(struct bcw_softc *, const struct bcw_initval *,
	    const unsigned int);
int	bcw_load_initvals(struct bcw_softc *);
@


1.26
log
@First shot of making the driver capable to parse several firmware files
from one single file.

Suggested and help by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.25 2007/01/03 18:54:29 mglocker Exp $ */
a1152 2
	return (0);

d2388 12
a2399 3
	uint8_t *initval0, *initval1;
	size_t size_initval0, size_initval1;
	char name[32];
d2401 1
a2401 1
	/* read initval0 file */
d2429 1
a2429 1
	snprintf(name, sizeof(name), "bcm43xx_initval%02d.fw", nr);
d2431 3
a2433 3
	if ((error = loadfirmware(name, &initval0, &size_initval0)) != 0) {
		printf("%s: error %d, could not read initval0 %s!\n",
		    sc->sc_dev.dv_xname, error, name);
a2435 1
	DPRINTF(("%s: successfully read %s\n", sc->sc_dev.dv_xname, name));
d2437 1
a2437 1
	/* read initval1 file */
d2455 2
a2456 1
		snprintf(name, sizeof(name), "bcm43xx_initval%02d.fw", nr);
d2458 1
a2458 1
		if ((error = loadfirmware(name, &initval1, &size_initval1))
d2460 2
a2461 2
			printf("%s: error %d, could not read initval1 %s\n",
			    sc->sc_dev.dv_xname, error, name);
a2463 2
		DPRINTF(("%s: successfully read %s\n", sc->sc_dev.dv_xname,
		    name));
d2467 2
a2468 2
	if (bcw_write_initvals(sc, (struct bcw_initval *)initval0,
	    size_initval0 / sizeof(struct bcw_initval)))
a2470 1
	free(initval0, M_DEVBUF);
d2473 4
a2476 3
	if (initval1 != NULL) {
		if (bcw_write_initvals(sc, (struct bcw_initval *)initval1,
		    size_initval1 / sizeof(struct bcw_initval)))
a2478 1
		free(initval1, M_DEVBUF);
d2480 2
@


1.25
log
@After the firmware has been loaded to the chip, read the exact firmware
revision from the chip and print it in a debug line.  Verify that the
firmware has the right revision for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.24 2007/01/03 14:58:33 mglocker Exp $ */
d101 1
d1153 2
d2254 33
d2292 4
a2295 7
	uint8_t *ucode, *pcm;
	size_t size_ucode, size_pcm;
	char name[32];

	/* read microcode file */
	snprintf(name, sizeof(name), "bcm43xx_microcode%d.fw",
	    rev >= 5 ? 5 : rev);
d2297 1
d2305 12
a2316 2
	/* read pcm file */
	snprintf(name, sizeof(name), "bcm43xx_pcm%d.fw",
d2319 3
a2321 3
	if ((error = loadfirmware(name, &pcm, &size_pcm)) != 0) {
		printf("%s: error %d, could not read pcm %s!\n",
		    sc->sc_dev.dv_xname, error, name);
a2323 1
	DPRINTF(("%s: successfully read %s\n", sc->sc_dev.dv_xname, name));
d2326 2
a2327 2
	data = (uint32_t *)ucode;
	len = size_ucode / sizeof(uint32_t);
a2333 1
	free(ucode, M_DEVBUF);
d2336 1
a2336 1
	data = (uint32_t *)pcm;
d2346 2
a2347 1
	free(pcm, M_DEVBUF);
@


1.24
log
@Rename bcw_shm_write_4() to bcw_shm_ctl_word().  We need the original
name space for the new routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.23 2007/01/03 10:41:04 mglocker Exp $ */
d67 1
d122 16
d1102 2
a1103 1
	int error;
d1110 41
@


1.23
log
@Pretty printing of debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.22 2007/01/03 06:31:54 mglocker Exp $ */
d66 1
a66 1
void	bcw_shm_write_4(struct bcw_softc *, uint16_t, uint16_t);
d110 1
a110 1
bcw_shm_write_4(struct bcw_softc *sc, uint16_t routing, uint16_t offset)
d2226 1
a2226 1
	bcw_shm_write_4(sc, BCW_SHM_CONTROL_MCODE, 0);
d2237 1
a2237 1
	bcw_shm_write_4(sc, BCW_SHM_CONTROL_PCM, 0x01ea);
d2239 1
a2239 1
	bcw_shm_write_4(sc, BCW_SHM_CONTROL_PCM, 0x01eb);
@


1.22
log
@Avoid mixing of u_int* and uint* in the same code.  uint* wins.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.21 2007/01/03 06:24:09 mglocker Exp $ */
d168 1
a168 1
		DPRINTF(("%s: Selected ChipCommon Core\n",
@


1.21
log
@Replace bus_space_read_2() by the BCW_READ16 macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.20 2007/01/03 06:20:14 mglocker Exp $ */
d76 1
a76 1
//void	bcw_add_mac(struct bcw_softc *, u_int8_t *, unsigned long);
d99 1
a99 1
int	bcw_reset_core(struct bcw_softc *, u_int32_t);
d128 2
a129 2
	u_int32_t	sbval;
//	u_int16_t	sbval16;
d787 1
a787 1
			u_int32_t ctrl;
d856 1
a856 1
	u_int32_t intstatus;
d1266 1
a1266 1
	//u_int32_t val;
d1317 2
a1318 2
	u_int32_t sbval;
	u_int32_t reject;
d1513 1
a1513 1
	u_int32_t save,val;
d1957 1
a1957 1
	u_int32_t sbval;
d1975 1
a1975 1
	u_int32_t sbval;
d1997 1
a1997 1
	u_int32_t	sbval;
d2020 1
a2020 1
	u_int16_t	sbval16;
d2061 1
a2061 1
bcw_reset_core(struct bcw_softc *sc, u_int32_t flags)
d2063 1
a2063 1
	u_int32_t	sbval, reject, val;
@


1.20
log
@Replace bus_space_write_2() by the BCW_WRITE16 macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.19 2007/01/03 06:10:47 mglocker Exp $ */
d2030 1
a2030 2
		sbval16 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA);
d2035 1
a2035 2
		sbval16 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA);
d2043 1
a2043 2
			sbval16 = bus_space_read_2(sc->sc_iot,
			    sc->sc_ioh, BCW_PHY_DATA);
d2048 1
a2048 2
			sbval16 = bus_space_read_2(sc->sc_iot,
			    sc->sc_ioh, BCW_PHY_DATA);
@


1.19
log
@Replace bus_space_read_4() by the BCW_READ macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.18 2007/01/03 06:02:27 mglocker Exp $ */
d2025 5
a2029 10
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_RADIO_CONTROL, 0x04);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_RADIO_DATALOW, 0xff);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_RADIO_CONTROL, 0x05);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_RADIO_DATALOW, 0xfb);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x10);
d2033 3
a2035 6
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x10);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA, sbval16);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x11);
d2039 2
a2040 4
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x11);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA, sbval16);
d2044 1
a2044 2
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x811);
d2048 3
a2050 6
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x811);
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_DATA, sbval16);
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x812);
d2054 2
a2055 4
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x812);
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_DATA, sbval16);
d2059 2
a2060 4
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x15);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA, 0xaa00);
@


1.18
log
@Replace bus_space_write_4() by the BCW_WRITE macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.17 2007/01/03 05:53:03 mglocker Exp $ */
d270 1
a270 2
			sbval = bus_space_read_4(sc->sc_iot,
			    sc->sc_ioh, BCW_CIR_SBID_HI);
d311 1
a311 2
			sbval = bus_space_read_4(sc->sc_iot,
			    sc->sc_ioh, BCW_SBTPSFLAG);
d1346 1
a1346 1
	sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW);
d2110 1
a2110 2
			sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW);
d2117 1
a2117 2
				val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBTMSTATEHI);
d2126 1
a2126 2
			val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_CIR_SBID_LO);
d2128 1
a2128 2
				sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE);
d2131 1
a2131 2
				sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE);
d2136 1
a2136 2
					val = bus_space_read_4(sc->sc_iot,
					sc->sc_ioh, BCW_SBTMSTATEHI);
d2151 1
a2151 2
			val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW);
d2154 1
a2154 2
			val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_CIR_SBID_LO);
d2156 1
a2156 2
				sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE);
d2159 1
a2159 2
				sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE);
d2164 1
a2164 2
					val = bus_space_read_4(sc->sc_iot,
					sc->sc_ioh, BCW_SBTMSTATEHI);
d2187 1
a2187 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW);
d2191 1
a2191 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATEHI);
d2194 1
a2194 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBIMSTATE);
d2202 1
a2202 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW);
d2207 1
a2207 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW);
d2355 1
a2355 2
			val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATEHI);
@


1.17
log
@Spacing, comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.16 2007/01/03 05:46:42 mglocker Exp $ */
d118 1
a118 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_CONTROL, control);
d2109 2
a2110 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW, SBTML_RESET | reject | flags );
d2116 1
a2116 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW, reject);
d2135 2
a2136 2
				bus_space_write_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE, sbval | SBIM_REJECT);
d2157 2
a2158 3
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW, SBTML_FGC | SBTML_CLK |
			    SBTML_RESET | flags );
d2168 2
a2169 2
				bus_space_write_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE, sbval & ~SBIM_REJECT);
d2188 2
a2189 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW, SBTML_RESET | reject | flags );
d2198 2
a2199 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW,
	    SBTML_FGC | SBTML_CLK | SBTML_RESET | flags );
d2206 1
a2206 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATEHI, 0);
d2209 1
a2209 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBIMSTATE,
d2213 2
a2214 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW,
	    SBTML_FGC | SBTML_CLK | flags );
d2219 1
a2219 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW,
	    SBTML_CLK | flags );
@


1.16
log
@Add first shot of the firmware upload.  Tested on i386 and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.15 2007/01/03 05:44:59 mglocker Exp $ */
d179 4
a182 2
	/* If we successfully got a commoncore, and the corerev=4 or >=6
	   get the number of cores from the chipid reg */
a495 1

d624 1
d662 2
a663 1
		if ((ifp->if_flags & IFF_UP) && (!(ifp->if_flags & IFF_RUNNING)))
d918 1
@


1.15
log
@Uncomment bcw_powercontrol_crystal_off() for now because it leads to
a panic later.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.14 2006/12/28 22:40:57 mglocker Exp $ */
d66 2
d100 4
d110 12
d650 1
a650 1
			bcw_init(ifp);
d655 1
a655 1
			bcw_init(ifp);
d1083 13
d2223 192
@


1.14
log
@spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.13 2006/12/28 22:23:07 mglocker Exp $ */
d531 1
a531 1
	bcw_powercontrol_crystal_off(sc);
@


1.13
log
@Finish core enumeration, break out core change and reset functions.

From Jon Simola <simola@@mecha.com>.  Diff merged together by me with
last changes from jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.12 2006/12/27 14:22:48 jsg Exp $ */
a111 1
	
d131 1
a131 1
	    
d146 1
a146 1
	/* 
d160 1
a160 1
	
a473 1
	
d476 1
a476 1
	
d503 2
a504 1
	/* Now, write the value into the regster
d525 1
a525 1
	
d543 1
a543 1
	
d1145 2
a1146 2

#if 0 /* FIXME */
d1148 2
a1149 2
	BCW_WRITE(sc, BCW_DMA_RXDPTR, BCW_NRXDESC * sizeof(struct bcw_dma_slot));
	    
a1153 1

a1158 1

d1213 2
a1214 1
#if 0 /* FIXME */
a1318 2
#endif
#if 0
a1326 1

d1357 1
a1357 1
	void
d1374 2
a1375 2
			BCW_WRITE(sc,
					BCW_RX_CTL, BCW_READ(sc, BCW_RX_CTL) & ~ERC_DB);
d1377 2
a1378 3
			BCW_WRITE(sc,
					BCW_RX_CTL, BCW_READ(sc, BCW_RX_CTL) | ERC_DB);
		sc->bcw_bhandle, 
d1380 2
a1381 2
			/* disable the filter */
			BCW_WRITE(sc, BCW_FILT_CTL, 0);
d1397 1
a1397 1
	int
d1410 1
a1410 1
	int
d1464 1
a1464 1
	void
d1477 1
a1477 1
	int
a1560 2


a1578 1

a2191 1

@


1.12
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.11 2006/12/27 14:05:57 jsg Exp $ */
d95 3
d109 1
a109 1
	int		i,j;
d111 1
a111 1
	u_int16_t	sbval16;
d115 2
a116 1
	 * Reset the chip
d118 1
a118 1
	bcw_reset(sc);
d146 1
a146 11
#if 0
	sbval = pci_conf_read(sc->sc_pa.pa_pc, sc->sc_pa.pa_tag,
	    BCW_ADDR_SPACE0);
	if ((sbval & 0xffff0000) != 0x18000000) {
		DPRINTF(("\n%s: Trial Core read was 0x%x, single core only?\n",
		    sc->sc_dev.dv_xname, sbval));
	 	//sc->sc_singlecore=1;
	} else
		DPRINTF(("\n%s: Trial Core read was 0x%x\n",
		    sc->sc_dev.dv_xname, sbval));
#endif
d150 3
a152 11
	for (i = 0; i < 10; i++) {
		(sc->sc_conf_write)(sc, BCW_ADDR_SPACE0, BCW_CORE_SELECT(0));
		delay(10);
		sbval = (sc->sc_conf_read)(sc, BCW_ADDR_SPACE0);
		if (sbval == BCW_CORE_SELECT(0)) {
			DPRINTF(("%s: Selected ChipCommon Core\n",
			    sc->sc_dev.dv_xname));
			break;
		}
		delay(10);
	}
d166 1
d169 1
a169 1
		sc->sc_corerev =
d171 1
a171 1
		if ((sc->sc_corerev == 4) || (sc->sc_corerev >= 6))
d197 2
a198 2
				/* XXX Educated Guess */
				sc->sc_numcores = 0;
d201 1
d248 6
a253 21
	/* Identify each core */
	if (sc->sc_numcores >= 2) { /* Exclude single core chips */
 		for (i = 0; i < sc->sc_numcores; i++) {
// 			DPRINTF(("%s: Trying core %d -\n",
// 			    sc->sc_dev.dv_xname, i));
 			(sc->sc_conf_write)(sc, BCW_ADDR_SPACE0,
			    BCW_CORE_SELECT(i));
			/* loop to see if the selected core shows up */
			for (j = 0; j < 10; j++) {
				sbval = (sc->sc_conf_read)(sc, BCW_ADDR_SPACE0);
//				DPRINTF(("%s: read %d for core %d = 0x%x\n",
//				    sc->sc_dev.dv_xname, j, i, sbval));
				if (sbval == BCW_CORE_SELECT(i)) break;
				delay(10);
			}
			if (j < 10) {
				sbval = BCW_READ(sc, BCW_CIR_SBID_HI);
				DPRINTF(("%s: Found core %d of type 0x%x\n",
				    sc->sc_dev.dv_xname, i, 
				    (sbval & 0x00008ff0) >> 4));
			}
d255 2
a256 2
		} /* End of For loop */
	}
d258 12
a269 4
	/*
	 * XXX Attach cores to the backplane, if we have more than one
	 */
	// ??? if (!sc->sc_singlecore) {
d271 5
a275 5
	if (sc->sc_havecommon == 1) {
		sbval = BCW_READ(sc, BCW_PCICR);
		sbval |= 0x1 << 8; /* XXX hardcoded bitmask of single core */
		BCW_WRITE(sc, BCW_PCICR, sbval);
	}
d277 29
d309 2
d312 1
a312 5
	for (i = 0; i < sc->sc_numcores; i++) {
		if (sc->sc_core[i].id == BCW_CORE_80211)
			(sc->sc_conf_write)(sc, BCW_ADDR_SPACE0,
			    BCW_CORE_SELECT(i));
	}
d353 1
a353 1
		switch (sc->sc_corerev) {
d442 1
a442 43
	/*
	 * Switch the radio off - candidate for seperate function
	 */
	switch(sc->sc_phy_type) {
	case BCW_PHY_TYPEA:
		/* Magic unexplained values */
		BCW_WRITE16(sc, BCW_RADIO_CONTROL, 0x04);
		BCW_WRITE16(sc, BCW_RADIO_DATALOW, 0xff);
		BCW_WRITE16(sc, BCW_RADIO_CONTROL, 0x05);
		BCW_WRITE16(sc, BCW_RADIO_DATALOW, 0xfb);
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x10);

		sbval16 = BCW_READ16(sc, BCW_PHY_DATA);
		sbval16 |= 0x8;
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x10);
		BCW_WRITE16(sc, BCW_PHY_DATA, sbval16);
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x11);

		sbval16 = BCW_READ16(sc, BCW_PHY_DATA);
		sbval16 |= 0x8;
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x11);
		BCW_WRITE16(sc, BCW_PHY_DATA, sbval16);
		break;
	case BCW_PHY_TYPEG:
		if (sc->sc_corerev >= 5) {
			BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x811);
			sbval16 = BCW_READ16(sc, BCW_PHY_DATA);
			sbval16 |= 0x8c;
			BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x811);
			BCW_WRITE16(sc, BCW_PHY_DATA, sbval16);
			BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x812);
			sbval16 = BCW_READ16(sc, BCW_PHY_DATA);
			sbval16 &= 0xff73;
			BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x812);
			    
			BCW_WRITE16(sc, BCW_PHY_DATA, sbval16);
			    
		}
		/* FALL-THROUGH */
	default:
		BCW_WRITE16(sc, BCW_PHY_CONTROL, 0x15);
		BCW_WRITE16(sc, BCW_PHY_DATA, 0xaa00);
	} /* end of switch statement to turn off radio */
a1065 1
	u_int32_t reg_win;
d1080 2
a1081 1

d1100 1
a1285 1
	int i;
a1286 1
	u_int32_t val;
a1288 9
	/* Really stupid PCI space dump */
#if 0
	for (i = 0xe00; i < 0x1000; i += 4) {
		if ((i % 16) == 0)
		    DPRINTF(("%s: 0x%04x - ",sc->sc_dev.dv_xname, i));
		DPRINTF(("0x%08x ", BCW_READ(sc, i)));
		if ((i % 16) == 12) DPRINTF(("\n"));
	}
#endif
d1291 1
a1291 2
	 * of the Reject bit changed. Save the revision in the softc, and
	 * use the local variable 'reject' in all the bit banging.
d1294 1
a1295 1
	sc->sc_sbrev = (sbval & SBREV_MASK) >> SBREV_MASK_SHIFT;
d1313 3
d1318 2
a1319 2
		/* Stop all DMA */
		/* reset the dma engines */
d1322 9
a1330 120
	/* disable 802.11 core if not in reset */
	if (!(sbval & SBTML_RESET)) {
		/* if the core is not enabled, the clock won't be enabled */
		if (!(sbval & SBTML_CLK)) {
			BCW_WRITE(sc, BCW_SBTMSTATELOW, SBTML_RESET | reject |
			    SBTML_80211FLAG | SBTML_80211PHY );
			delay(1);
			sbval = BCW_READ(sc, BCW_SBTMSTATELOW);
			goto disabled;

			BCW_WRITE(sc, BCW_SBTMSTATELOW, reject);
			    
			delay(1);
			/* wait until busy is clear */
			for (i = 0; i < 10000; i++) {
				val = BCW_READ(sc, BCW_SBTMSTATEHI);
				    
				if (!(val & SBTMH_BUSY))
					break;
				delay(10);
			}
			if (i == 10000)
				printf("%s: while resetting core, busy did "
				    "not clear\n", sc->sc_dev.dv_xname);

			val = BCW_READ(sc, BCW_CIR_SBID_LO);
			    
			if (val & BCW_CIR_SBID_LO_INITIATOR) {
				sbval = BCW_READ(sc,
				    BCW_SBIMSTATE);
				BCW_WRITE(sc, BCW_SBIMSTATE, sbval |
				    SBIM_REJECT);
				    
				sbval = BCW_READ(sc, BCW_SBIMSTATE);
				    
				delay(1);

				/* wait until busy is clear */
				for (i = 0; i < 10000; i++) {
					val = BCW_READ(sc, BCW_SBTMSTATEHI);
					
					if (!(val & SBTMH_BUSY))
						break;
					delay(10);
				}
				if (i == 10000)
					printf("%s: while resetting core, busy "
					    "did not clear\n",
					    sc->sc_dev.dv_xname);
			} /* end initiator check */

			/* set reset and reject while enabling the clocks */
			BCW_WRITE(sc, BCW_SBTMSTATELOW, SBTML_FGC | SBTML_CLK |
			    SBTML_RESET | SBTML_80211FLAG | SBTML_80211PHY);
			val = BCW_READ(sc, BCW_SBTMSTATELOW);
			    
			delay(10);

			val = BCW_READ(sc, BCW_CIR_SBID_LO);

			if (val & BCW_CIR_SBID_LO_INITIATOR) {
				sbval = BCW_READ(sc, BCW_SBIMSTATE);
				    
				BCW_WRITE(sc, BCW_SBIMSTATE, sbval &
				    ~SBIM_REJECT);
				    
				sbval = BCW_READ(sc, BCW_SBIMSTATE);
				delay(1);

				/* wait until busy is clear */
				for (i = 0; i < 10000; i++) {
					val = BCW_READ(sc, BCW_SBTMSTATEHI);

					if (!(val & SBTMH_BUSY))
						break;
					delay(10);
				}
				if (i == 10000)
					printf("%s: while resetting core, busy "
					    "did not clear\n",
					    sc->sc_dev.dv_xname);
			} /* end initiator check */

			BCW_WRITE(sc, BCW_SBTMSTATELOW, SBTML_RESET | reject |
			    SBTML_80211FLAG | SBTML_80211PHY);
			delay(1);
		}
	}

disabled:

	/* This is enabling/resetting the core */
	/* enable clock */
	BCW_WRITE(sc, BCW_SBTMSTATELOW,
	    SBTML_FGC | SBTML_CLK | SBTML_RESET |
	    SBTML_80211FLAG | SBTML_80211PHY );
	val = BCW_READ(sc, BCW_SBTMSTATELOW);
	delay(1);

	/* clear any error bits that may be on */
	val = BCW_READ(sc, BCW_SBTMSTATEHI);
	if (val & SBTMH_SERR)
		BCW_WRITE(sc, BCW_SBTMSTATEHI, 0);
	val = BCW_READ(sc, BCW_SBIMSTATE);
	if (val & (SBIM_INBANDERR | SBIM_TIMEOUT))
		BCW_WRITE(sc, BCW_SBIMSTATE,
		    val & ~(SBIM_INBANDERR | SBIM_TIMEOUT));
		    
	/* clear reset and allow it to propagate throughout the core */
	BCW_WRITE(sc, BCW_SBTMSTATELOW,
	    SBTML_FGC | SBTML_CLK | SBTML_80211FLAG | SBTML_80211PHY );
	val = BCW_READ(sc, BCW_SBTMSTATELOW);
	delay(1);

	/* leave clock enabled */
	BCW_WRITE(sc, BCW_SBTMSTATELOW, SBTML_CLK | SBTML_80211FLAG |
	    SBTML_80211PHY);
	    
	val = BCW_READ(sc, BCW_SBTMSTATELOW);
	delay(1);
d1344 15
d1362 1
a1362 1
void
d1380 1
a1380 1
			    BCW_RX_CTL, BCW_READ(sc, BCW_RX_CTL) & ~ERC_DB);
d1383 2
a1384 2
			    BCW_RX_CTL, BCW_READ(sc, BCW_RX_CTL) | ERC_DB);
			    sc->bcw_bhandle, 
d1386 2
a1387 2
		/* disable the filter */
		BCW_WRITE(sc, BCW_FILT_CTL, 0);
d1394 1
a1394 1
		    
d1403 1
a1403 1
int
d1416 1
a1416 1
int
d1431 1
a1431 1
void
d1442 1
a1442 1
	imr->ifm_status |= IFM_ACTIVE;
d1444 1
a1444 1
        /*
d1454 12
a1465 12
	case IEEE80211_M_STA:
		break;
	case IEEE80211_M_IBSS:
		imr->ifm_active |= IFM_IEEE80211_ADHOC;
		break;
	case IEEE80211_M_MONITOR:
		imr->ifm_active |= IFM_IEEE80211_MONITOR;
		break;
        case IEEE80211_M_AHDEMO:
        case IEEE80211_M_HOSTAP:
		/* should not get there */
		break;
d1470 1
a1470 1
void
d1483 1
a1483 1
int
d1488 3
d1500 1
a1500 1
	
d1506 1
a1506 1
	    
d1510 1
a1510 1
	
d1516 1
a1516 1
	    
d1524 1
a1524 2
	
	if (sc->sc_corerev >= 3) {
d1954 1
a1954 1
	if (sc->sc_corerev < 5)
d1968 234
@


1.11
log
@Wrap bus space access in similiar macros to other drivers
making things much more readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.10 2006/12/08 01:28:40 mglocker Exp $ */
d300 1
a300 1
	for (i=0; i < sc->sc_numcores; i++) {
d306 3
a308 3
	sc->sc_phy_version = (sbval&0xf000)>>12;
	sc->sc_phy_rev = sbval&0xf;
	sc->sc_phy_type = (sbval&0xf00)>>8;
d677 1
a677 1
		if ((ifp->if_flags & IFF_UP)&&(!(ifp->if_flags & IFF_RUNNING)))
d1326 1
a1326 1
	for (i=0xe00; i<0x1000; i+=4) {
@


1.10
log
@From Jon Simola <simola@@mecha.com>:

Style and whitespace cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.9 2006/12/06 19:21:45 mglocker Exp $ */
d127 2
a128 2
	sc->sc_boardflags = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
	    BCW_SPROM_BOARDFLAGS);
d172 1
a172 1
	sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_CIR_SBID_HI);
d180 1
a180 2
		sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    BCW_CORE_COMMON_CHIPID);
d276 1
a276 2
				sbval = bus_space_read_4(sc->sc_iot,
				    sc->sc_ioh, BCW_CIR_SBID_HI);
d291 1
a291 1
		sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_PCICR);
d293 1
a293 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_PCICR, sbval);
d305 1
a305 1
	sbval = bus_space_read_2(sc->sc_iot, sc->sc_ioh, 0x3E0);
d339 2
a340 4
		bus_space_write_2(sc->sc_iot, sc->sc_ioh, BCW_RADIO_CONTROL,
		    BCW_RADIO_ID);
		sbval=bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_RADIO_DATAHIGH);
d342 2
a343 4
		bus_space_write_2(sc->sc_iot, sc->sc_ioh, BCW_RADIO_CONTROL,
		    BCW_RADIO_ID);
		sc->sc_radioid = sbval | bus_space_read_2(sc->sc_iot,
		    sc->sc_ioh, BCW_RADIO_DATALOW);
d440 7
a446 12
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_RADIO_CONTROL, 0x04);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_RADIO_DATALOW, 0xff);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_RADIO_CONTROL, 0x05);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_RADIO_DATALOW, 0xfb);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x10);
		sbval16 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA);
d448 5
a452 8
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x10);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA, sbval16);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x11);
		sbval16 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA);
d454 2
a455 4
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x11);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA, sbval16);
d459 2
a460 4
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x811);
			sbval16 = bus_space_read_2(sc->sc_iot,
			    sc->sc_ioh, BCW_PHY_DATA);
d462 4
a465 8
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x811);
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_DATA, sbval16);
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x812);
			sbval16 = bus_space_read_2(sc->sc_iot,
			    sc->sc_ioh, BCW_PHY_DATA);
d467 4
a470 4
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x812);
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_DATA, sbval16);
d474 2
a475 4
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_CONTROL, 0x15);
		bus_space_write_2(sc->sc_iot, sc->sc_ioh,
		    BCW_PHY_DATA, 0xaa00);
d479 1
a479 1
	sbval = bus_space_read_2(sc->sc_iot, sc->sc_ioh, BCW_SPROM_ANTGAIN);
d493 8
a500 12
	sc->sc_radio_pa0b0 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
	    BCW_SPROM_PA0B0);
	sc->sc_radio_pa0b1 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
	    BCW_SPROM_PA0B1);
	sc->sc_radio_pa0b2 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
	    BCW_SPROM_PA0B2);
	sc->sc_radio_pa1b0 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
	    BCW_SPROM_PA1B0);
	sc->sc_radio_pa1b1 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
	    BCW_SPROM_PA1B1);
	sc->sc_radio_pa1b2 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
	    BCW_SPROM_PA1B2);
d503 1
a503 1
	sbval = bus_space_read_2(sc->sc_iot, sc->sc_ioh, BCW_SPROM_IDLETSSI);
d549 1
a549 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_CONTROL,
d551 2
a552 4
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, BCW_SHM_DATAHIGH,
	    sbval & 0x00ff);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, BCW_SHM_DATALOW,
	    (sbval & 0xff00)>>16);
d584 1
a584 2
		i = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_SPROM_ET1MACADDR);
d587 2
a588 2
		i = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_SPROM_ET1MACADDR + 2);
d591 2
a592 2
		i = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_SPROM_ET1MACADDR + 4);
d596 2
a597 2
		i = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_SPROM_IL0MACADDR);
d600 2
a601 2
		i = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_SPROM_IL0MACADDR + 2);
d604 2
a605 2
		i = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
		    BCW_SPROM_IL0MACADDR + 4);
d830 1
a830 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_DPTR,
d948 1
a948 2
	curr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_RXSTATUS(0)) &
	    RS_CD_MASK;
d1043 1
a1043 2
		curr = (bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    BCW_DMA_RXSTATUS) & RS_CD_MASK) /
d1067 1
a1067 1
	curr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_TXSTATUS) & RS_CD_MASK;
d1117 1
a1117 1
	reg_win = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_REG0_WIN);
d1120 1
a1120 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_REG0_WIN, BCW_SONICS_WIN);
d1123 1
a1123 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBINTVEC,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBINTVEC) |
	    SBIV_ENET0);
d1126 2
a1127 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SPCI_TR2,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SPCI_TR2) |
	    SBTOPCI_PREF | SBTOPCI_BURST);
d1130 1
a1130 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_REG0_WIN, reg_win);
d1143 3
a1145 4
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_MACCTL,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_MACCTL) |
	    BCW_EMC_CRC32_ENAB | BCW_EMC_LED);

d1147 1
a1147 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_MACCTL,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_MACCTL) &
	    ~BCW_EMC_PDOWN);
d1150 1
a1150 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMAI_CTL, 1 << 24);	/* MAGIC */
d1156 2
a1157 4
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_RX_MAX,
	    ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_TX_MAX,
	    ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);
d1160 1
a1160 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_TX_WATER, 56);
d1163 1
a1163 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_TXCTL, XC_XE);
d1172 1
a1172 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_RXCTL,
	    BCW_PREPKT_HEADER_SIZE << 1 | 1);
d1177 2
a1178 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_INT_MASK,
	    sc->sc_intmask);
d1182 2
a1183 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_RXDPTR,
	    BCW_NRXDESC * sizeof(struct bcw_dma_slot));
d1191 2
a1192 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_ENET_CTL,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
	    BCW_ENET_CTL) | EC_EE);
d1278 1
a1278 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_INT_MASK, 0);
d1284 1
a1284 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_ENET_CTL, EC_ED);
d1286 2
a1287 2
		val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    BCW_ENET_CTL);
d1294 2
a1295 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_RXCONTROL(0), 0);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_TXCONTROL(0), 0);
d1329 1
a1329 1
		DPRINTF(("0x%08x ",bus_space_read_4(sc->sc_iot, sc->sc_ioh,i)));
d1338 1
a1338 1
	sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_CIR_SBID_LO);
d1352 1
a1352 1
	sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW);
d1368 1
a1368 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW, SBTML_RESET | reject |
d1371 1
a1371 2
			sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW);
d1374 2
a1375 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW, reject);
d1379 2
a1380 2
				val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBTMSTATEHI);
d1389 2
a1390 2
			val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_CIR_SBID_LO);
d1392 1
a1392 5
				sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE);
				bus_space_write_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE, sbval | SBIM_REJECT);
				sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d1394 5
d1403 2
a1404 2
					val = bus_space_read_4(sc->sc_iot,
					sc->sc_ioh, BCW_SBTMSTATEHI);
d1416 1
a1416 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW, SBTML_FGC | SBTML_CLK |
d1418 2
a1419 2
			val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW);
d1422 2
a1423 2
			val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_CIR_SBID_LO);
d1425 6
a1430 6
				sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE);
				bus_space_write_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE, sbval & ~SBIM_REJECT);
				sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_SBIMSTATE);
d1435 2
a1436 2
					val = bus_space_read_4(sc->sc_iot,
					sc->sc_ioh, BCW_SBTMSTATEHI);
d1447 1
a1447 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_SBTMSTATELOW, SBTML_RESET | reject |
d1457 1
a1457 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW,
d1460 1
a1460 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW);
d1464 1
a1464 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATEHI);
d1466 2
a1467 2
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATEHI, 0);
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBIMSTATE);
d1469 1
a1469 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBIMSTATE,
d1471 1
a1471 1

d1473 1
a1473 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW,
d1475 1
a1475 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW);
d1479 4
a1482 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW,
	    SBTML_CLK | SBTML_80211FLAG | SBTML_80211PHY);
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW);
d1488 1
a1488 1
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, BCW_RADIO_BASEBAND, 0);
d1491 1
a1491 1
	sbval=bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBF);
d1493 1
a1493 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBF, sbval);
d1508 1
a1508 3
		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL,
		    bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL)
		    | ERC_PE);
d1513 1
a1513 3
		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL,
		    bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle,
		    BCW_RX_CTL) & ~ERC_PE);
d1517 2
a1518 3
			bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle,
			    BCW_RX_CTL, bus_space_read_4(sc->bcw_btag,
			    sc->bcw_bhandle, BCW_RX_CTL) & ~ERC_DB);
d1520 3
a1522 3
			bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle,
			    BCW_RX_CTL, bus_space_read_4(sc->bcw_btag,
			    sc->bcw_bhandle, BCW_RX_CTL) | ERC_DB);
d1525 1
a1525 2
		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_FILT_CTL,
		    0);
d1531 2
a1532 3
		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL,
		bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL) |
		    ERC_AM);
d1536 1
a1536 3
		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_FILT_CTL,
		    bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle,
		    BCW_FILT_CTL) | 1);
d1633 2
a1634 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_CONTROL,
	    (BCW_SHM_CONTROL_SHARED << 16) + 0);
	save = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_DATA);
d1637 2
a1638 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_CONTROL,
	    (BCW_SHM_CONTROL_SHARED << 16) + 0);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_DATA, 0xaa5555aa);
d1640 3
a1642 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_CONTROL,
	    (BCW_SHM_CONTROL_SHARED << 16) + 0);
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_DATA);
d1647 2
a1648 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_CONTROL,
	    (BCW_SHM_CONTROL_SHARED << 16) + 0);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_DATA, 0x55aaaa55);
d1650 3
a1652 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_CONTROL,
	    (BCW_SHM_CONTROL_SHARED << 16) + 0);
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_DATA);
d1657 2
a1658 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_CONTROL,
	    (BCW_SHM_CONTROL_SHARED << 16) + 0);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_DATA, save);
d1668 3
a1670 3
		bus_space_write_2(sc->sc_iot, sc->sc_ioh, 0x18c, 0xaaaa);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, 0x18c, 0xccccbbbb);
		val = bus_space_read_2(sc->sc_iot, sc->sc_ioh, 0x604);
d1672 1
a1672 1
		val = bus_space_read_2(sc->sc_iot, sc->sc_ioh, 0x606);
d1675 1
a1675 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, 0x18c, 0x0);
d1679 1
a1679 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_SBF);
d1687 1
a1687 1
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_GIR);
d1813 1
a1813 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_RXADDR,
	    ring->physaddr + 0x40000000);
d1964 1
a1964 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_TXADDR,
	    ring->physaddr + 0x40000000);
@


1.9
log
@From Jon Simola <simola@@mecha.com>:

Add bus-specific config space read and write functions, this fixes the
attach for ian@@darwinsys.com and properly enumerates multiple cores.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.8 2006/11/29 21:34:06 mglocker Exp $ */
d104 3
a106 3
	struct ifnet   *ifp = &ic->ic_if;
	int             error;
	int             i,j;
d121 1
a121 1
	 * Get a copy of the BoardFlags and fix for broken boards 
d143 1
a143 1
	sbval = pci_conf_read(sc->sc_pa.pa_pc, sc->sc_pa.pa_tag, 
a188 28
				case 0x4710:
				case 0x4610:
				case 0x4704:
					sc->sc_numcores = 9;
					break;
				case 0x4310:
					sc->sc_numcores = 8;
					break;
				case 0x5365:
					sc->sc_numcores = 7;
					break;
				case 0x4306:
					sc->sc_numcores = 6;
					break;
				case 0x4307:
				case 0x4301:
					sc->sc_numcores = 5;
					break;
				case 0x4402:
					sc->sc_numcores = 3;
					break;
				default:
					/* XXX Educated Guess */
					sc->sc_numcores = 0;
			} /* end of switch */
	} else { /* No CommonCore, set chipid,cores,rev based on product id */
		sc->sc_havecommon = 0;
		switch(sc->sc_prodid) {
d190 2
a191 6
			case 0x4711:
			case 0x4712:
			case 0x4713:
			case 0x4714:
			case 0x4715:
				sc->sc_chipid = 0x4710;
d194 2
a195 8
			case 0x4610:
			case 0x4611:
			case 0x4612:
			case 0x4613:
			case 0x4614:
			case 0x4615:
				sc->sc_chipid = 0x4610;
				sc->sc_numcores = 9;
d197 2
a198 4
			case 0x4402:
			case 0x4403:
				sc->sc_chipid = 0x4402;
				sc->sc_numcores = 3;
a199 1
			case 0x4305:
d201 2
d204 1
a204 1
				sc->sc_chipid = 0x4307;
d207 2
a208 3
			case 0x4301:
				sc->sc_chipid = 0x4301;
				sc->sc_numcores = 5;
d211 43
a253 3
				sc->sc_chipid = sc->sc_prodid;
				/* Set to max */
				sc->sc_numcores = BCW_MAX_CORES;
d314 16
a329 16
		case BCW_PHY_TYPEA:
			DPRINTF(("PHY %d (A)\n",sc->sc_phy_type));
			break;
		case BCW_PHY_TYPEB:
			DPRINTF(("PHY %d (B)\n",sc->sc_phy_type));
			break;
		case BCW_PHY_TYPEG:
			DPRINTF(("PHY %d (G)\n",sc->sc_phy_type));
			break;
		case BCW_PHY_TYPEN:
			DPRINTF(("PHY %d (N)\n",sc->sc_phy_type));
			break;
		default:
			DPRINTF(("Unrecognizeable PHY type %d\n",
			    sc->sc_phy_type));
			break;
d337 1
a337 1
	 * Radio registers, and requires seperate 16bit reads from the low 
d348 1
a348 1
		sc->sc_radioid = sbval | bus_space_read_2(sc->sc_iot, 
d351 9
a359 9
		switch(sc->sc_corerev) {
			case 0:	
				sc->sc_radioid = 0x3205017F;
				break;
			case 1:
				sc->sc_radioid = 0x4205017f;
				break;
			default:
				sc->sc_radioid = 0x5205017f;
d379 11
a389 10
		switch(sc->sc_phy_rev) {
			case 2:
			case 3:
			case 5:
			case 6:
			case 7:	break;
			default: 
				printf("%s: invalid PHY A revision %d\n",
				    sc->sc_dev.dv_xname, sc->sc_phy_rev);
				return;
d393 9
a401 8
		switch(sc->sc_phy_rev) {
			case 2:
			case 4:
			case 7:	break;
			default: 
				printf("%s: invalid PHY B revision %d\n",
				    sc->sc_dev.dv_xname, sc->sc_phy_rev);
				return;
d406 11
a416 10
			case 1:
			case 2:
			case 4:
			case 6:
			case 7:
			case 8:	break;
			default: 
				printf("%s: invalid PHY G revision %d\n",
				    sc->sc_dev.dv_xname, sc->sc_phy_rev);
				return;
d444 31
a474 4
		case BCW_PHY_TYPEA:
			/* Magic unexplained values */
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_RADIO_CONTROL, 0x04);
d476 4
a479 1
			    BCW_RADIO_DATALOW, 0xff);
d481 1
a481 20
			    BCW_RADIO_CONTROL, 0x05);
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_RADIO_DATALOW, 0xfb);
			/* 
			 * "When the term MaskSet is used, it is shorthand 
			 * for reading a value from a register, applying a 
			 * bitwise AND mask to the value and then applying 
			 * a bitwise OR to set a value. This value is then 
			 * written back to the register."
			 *  - This makes little sense when the docs say that
			 *    here we read a value, AND it with 0xffff, then
			 *    OR with 0x8. Why not just set the 0x8 bit?
			 */
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x10);
			sbval16 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_DATA);
			sbval16 |= 0x8;
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x10);
a483 1

d485 4
a488 4
			    BCW_PHY_CONTROL, 0x11);
			sbval16 = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_DATA);
			sbval16 |= 0x8;
d490 1
a490 1
			    BCW_PHY_CONTROL, 0x11);
d493 7
a499 29
			break;
		case BCW_PHY_TYPEG:
			if (sc->sc_corerev >= 5) {
				bus_space_write_2(sc->sc_iot, sc->sc_ioh,
				    BCW_PHY_CONTROL, 0x811);
				sbval16 = bus_space_read_2(sc->sc_iot,
				    sc->sc_ioh, BCW_PHY_DATA);
				sbval16 |= 0x8c;
				bus_space_write_2(sc->sc_iot, sc->sc_ioh,
				    BCW_PHY_CONTROL, 0x811);
				bus_space_write_2(sc->sc_iot, sc->sc_ioh,
				    BCW_PHY_DATA, sbval16);

				bus_space_write_2(sc->sc_iot, sc->sc_ioh,
				    BCW_PHY_CONTROL, 0x812);
				sbval16 = bus_space_read_2(sc->sc_iot,
				    sc->sc_ioh, BCW_PHY_DATA);
				sbval16 &= 0xff73;
				bus_space_write_2(sc->sc_iot, sc->sc_ioh,
				    BCW_PHY_CONTROL, 0x812);
				bus_space_write_2(sc->sc_iot, sc->sc_ioh,
				    BCW_PHY_DATA, sbval16);
			}
			/* FALL-THROUGH */
		default:
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_CONTROL, 0x15);
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
			    BCW_PHY_DATA, 0xaa00);
d532 1
a532 1
	if(sc->sc_phy_type == BCW_PHY_TYPEA)
d542 1
a542 1
	if((sc->sc_phy_type == BCW_PHY_TYPEA) ||
d546 1
a546 1
	if((sc->sc_phy_type == BCW_PHY_TYPEG) &&
d552 1
a552 1
	if((sc->sc_phy_type == BCW_PHY_TYPEG) &&
d557 1
a557 1
	if(sc->sc_phy_type == BCW_PHY_TYPEB)
d559 1
a559 1
	if((sc->sc_radiotype == 0x2050) &&
d563 1
a563 1
	 * XXX If the device isn't up and this is a PCI bus with revision 
d577 1
a577 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SHM_CONTROL, 
d584 1
a584 1
	/* 
d586 1
a586 1
	 * The method is described at 
d591 2
a592 2
	/* 
	 * XXX TODO still for the card attach: 
d613 1
a613 1
	if(sc->sc_phy_type == BCW_PHY_TYPEA) {
d657 1
a657 1
        ic->ic_ibss_chan = &ic->ic_channels[0];
d659 1
a659 1
        ifp->if_softc = sc;
d671 2
a672 2
        /* override state transition machine */
        sc->sc_newstate = ic->ic_newstate;
d687 1
a687 1
	int             s, error = 0;
d708 1
a708 1
		if((ifp->if_flags & IFF_UP)&&(!(ifp->if_flags & IFF_RUNNING)))
d710 1
a710 1
		else if(ifp->if_flags & IFF_RUNNING)
d724 1
a724 1
                /*
d755 2
a756 2
	int             txstart;
	int             txsfree;
d759 1
a759 1
	int             newpkts = 0;
d762 3
a764 3
         * do not start another if currently transmitting, and more
         * descriptors(tx slots) are needed for next packet.
         */
d776 4
a779 4
         * Loop through the send queue, setting up transmit descriptors
         * until we drain the queue, or use up all available transmit
         * descriptors.
         */
d856 3
a858 3
			  sizeof(struct bcw_dma_slot) * txstart + PAGE_SIZE,
			     sizeof(struct bcw_dma_slot) * dmamap->dm_nsegs,
				BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d862 1
a862 1
			     sc->sc_txsnext * sizeof(struct bcw_dma_slot));
d940 1
a940 1
				       sc->sc_dev.dv_xname);
d943 1
a943 1
				       sc->sc_dev.dv_xname);
d979 1
a979 1
	curr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_RXSTATUS(0)) & 
d1012 1
a1012 1
		sc->sc_cdata.bcw_rx_chain[i]->m_data += 
d1097 3
a1099 3
         * Go through the Tx list and free mbufs for those
         * frames which have been transmitted.
         */
d1207 3
a1209 3
         * Give the receive ring to the chip, and
         * start the receive DMA engine.
         */
d1370 1
a1370 1
		if ((i % 16) == 0) 
d1385 8
a1392 8
		case 0:
			reject = SBTML_REJ22;
			break;
		case 1:
			reject = SBTML_REJ23;
			break;
		default:
			reject = SBTML_REJ22 | SBTML_REJ23;
d1460 2
a1461 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, 
			    BCW_SBTMSTATELOW, SBTML_FGC | SBTML_CLK | 
d1504 1
a1504 1
	    SBTML_FGC | SBTML_CLK | SBTML_RESET | 
d1611 2
a1612 2
        int error;
        
d1626 1
a1626 1
        struct bcw_softc *sc = ifp->if_softc;
d1631 1
a1631 1
        imr->ifm_status = IFM_AVALID;
d1637 2
a1638 2
         * XXX Read current transmission rate from the adapter.
         */
d1644 1
a1644 1
        imr->ifm_active |= ieee80211_rate2media(ic, rate, ic->ic_curmode);
d1651 3
a1653 3
        case IEEE80211_M_MONITOR:
                imr->ifm_active |= IFM_IEEE80211_MONITOR;
                break;
d1685 1
a1685 1
	 
d1720 1
a1720 1
		/* 
d1724 1
a1724 1
		 * are not quite documented yet 
d1734 2
a1735 2
	}	
	
d2150 1
a2150 1
	if (sc->sc_corerev < 5) 
@


1.8
log
@From Jon Simola <simola@@mecha.com>:

New bcw_powercontrol_crystal_on() function, and fix the license for the
pci wrapper.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.7 2006/11/26 11:14:17 deraadt Exp $ */
d59 1
d94 1
d142 3
a144 14

	/*
	 * XXX Can we read BCW_ADDR_SPACE0 and see if it returns a likely
	 * Core? On the 4318 that only has an 802.11 core, it always reads as
	 * some garbage, so if we do a read first we could set a "singlecore"
	 * flag instead of thrashing around trying to select non-existant
	 * cores. Testing requires cards that do have multiple cores. This
	 * would also simplify identifying cards into 3 classes early:
	 *   - Multiple Cores without a Chip Common Core
	 *   - Multiple Cores with a Chip Common Core
	 *   - Single Core
	 */

	sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_ADDR_SPACE0);
d152 1
a152 1

d157 1
a157 2
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_ADDR_SPACE0,
		    BCW_CORE_SELECT(0));
d159 1
a159 2
		sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    BCW_ADDR_SPACE0);
d161 2
a162 1
			DPRINTF(("%s: Selected ChipCommon Core\n"));
d252 2
a253 2
				/* XXX educated guess */
				sc->sc_numcores = 1;
d263 5
a267 5
 		for (i = 0; i <= sc->sc_numcores; i++) {
 			DPRINTF(("%s: Trying core %d -\n",
 			    sc->sc_dev.dv_xname, i));
 			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_ADDR_SPACE0, BCW_CORE_SELECT(i));
d270 3
a272 4
				sbval=bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_ADDR_SPACE0);
				DPRINTF(("%s: read %d for core %d = 0x%x\n",
				    sc->sc_dev.dv_xname, j, i, sbval));
d276 3
a278 1
			if (j < 10) 
d282 2
a283 1
			//sc->sc_core[i].id = (sbval & 0x00008ff0) >> 4;
d291 1
d297 1
a297 1

d299 1
d302 5
d514 3
a516 2
	if((sbval == 0) || (sbval == 0xffff)) sbval = 0x0202;
	if(sc->sc_phy_type == BCW_PHY_TYPEA)
a602 1
	 * - Powercontrol Crystal Off (and write a wrapper for on/off)
d605 1
d919 1
a919 2
		intstatus = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    BCW_INT_STS);
d929 1
a929 2
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_INT_STS,
		    intstatus);
d1376 9
d1391 1
d2140 1
a2140 1
	sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOI);
d2142 1
a2142 1
		sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOO);
d2144 1
a2144 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOO, sbval);
d2146 1
a2146 1
		sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOO);
d2148 1
a2148 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOO, sbval);
d2151 22
@


1.7
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.6 2006/11/24 20:27:41 mglocker Exp $ */
d2127 17
@


1.6
log
@From Jon Simola <jsimola@@gmail.com>:

Completely rewrote bcw_reset() based on new specs, this cleared up the
random attach warning I occasionally had during warm boots.

Also change the license, as nearly nothing is left of the original bce
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.5 2006/11/22 22:20:34 damien Exp $ */
d653 2
a654 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = bcw_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = bcw_rateset_11g;
@


1.5
log
@style(9): remove variables names from prototypes.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.4 2006/11/22 15:12:50 mglocker Exp $ */
a4 1
 * Copyright (c) 2003 Clifford Wright. All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a21 2
 *
 * Cliff Wright cliff@@snipe444.org
d119 14
d140 1
a140 1
	 
d177 1
a177 1
	
a377 8
	/* Get a copy of the BoardFlags and fix for broken boards */
	sc->sc_boardflags = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
	    BCW_SPROM_BOARDFLAGS);
	/*
	 * Dell, Product ID 0x4301 Revision 0x74, set BCW_BF_BTCOEXIST
	 * Apple Board Type 0x4e Revision > 0x40, set BCW_BF_PACTRL
	 */

d1376 19
a1395 1
	/* if SB core is up, only clock of clock,reset,reject will be set */
d1397 5
d1403 1
a1403 3
	/* The core isn't running if the if the clock isn't enabled */
	if ((sbval & (SBTML_RESET | SBTML_REJ | SBTML_CLK)) == SBTML_CLK) {

a1405 26
	} else {
		//u_int32_t reg_win;

		/* remap the pci registers to the Sonics config registers */

		/* save the current map, so it can be restored */
		reg_win = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    BCW_REG0_WIN);
		/* set register window to Sonics registers */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_REG0_WIN,
		    BCW_SONICS_WIN);

		/* enable SB to PCI interrupt */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBINTVEC,
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		        BCW_SBINTVEC) |
		    SBIV_ENET0);

		/* enable prefetch and bursts for sonics-to-pci translation 2 */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SPCI_TR2,
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			BCW_SPCI_TR2) |
		    SBTOPCI_PREF | SBTOPCI_BURST);

		/* restore to ethernet register space */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_REG0_WIN, reg_win);
d1408 1
a1408 1
	/* disable SB core if not in reset */
d1410 24
d1435 29
a1463 4
		/* set the reject bit */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW,
		    SBTML_REJ | SBTML_CLK);
		for (i = 0; i < 200; i++) {
d1466 2
a1467 9
			if (val & SBTML_REJ)
				break;
			delay(1);
		}
		if (i == 200)
			printf("%s: while resetting core, reject did not set\n",
			    sc->sc_dev.dv_xname);
		/* wait until busy is clear */
		for (i = 0; i < 200; i++) {
d1469 27
a1495 3
			    BCW_SBTMSTATEHI);
			if (!(val & 0x4))
				break;
a1497 13
		if (i == 200)
			printf("%s: while resetting core, busy did not clear\n",
			    sc->sc_dev.dv_xname);
		/* set reset and reject while enabling the clocks */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW,
		    SBTML_FGC | SBTML_CLK | SBTML_REJ | SBTML_RESET |
		    SBTML_80211FLAG);
		val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    BCW_SBTMSTATELOW);
		delay(10);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_SBTMSTATELOW,
		    SBTML_REJ | SBTML_RESET);
		delay(1);
d1499 3
d1512 1
a1512 1
	if (val & 1)
d1515 1
a1515 1
	if (val & SBIM_MAGIC_ERRORBITS)
d1517 1
a1517 1
		    val & ~SBIM_MAGIC_ERRORBITS);
d1531 5
d1538 1
a1538 1
	sbval |= 0x400; 
d1540 3
@


1.4
log
@From Jon Simola <jon@@mecha.ca>:

Attach to cardbus based bcw cards, and more cleanup. This should help
with a few of the card lockup reports I've received.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.3 2006/11/21 11:41:14 mglocker Exp $ */
d94 6
a99 8
int	bcw_alloc_rx_ring(struct bcw_softc *sc, struct bcw_rx_ring *ring,
	    int count);
void	bcw_reset_rx_ring(struct bcw_softc *sc, struct bcw_rx_ring *ring);
void	bcw_free_rx_ring(struct bcw_softc *sc, struct bcw_rx_ring *ring);
int	bcw_alloc_tx_ring(struct bcw_softc *sc, struct bcw_tx_ring *ring,
	    int count);
void	bcw_reset_tx_ring(struct bcw_softc *sc, struct bcw_tx_ring *ring);
void	bcw_free_tx_ring(struct bcw_softc *sc, struct bcw_tx_ring *ring);
d106 1
a106 1
int	bcw_validatechipaccess(struct bcw_softc *ifp);
@


1.3
log
@From Jon Simola <simola@@mecha.com>:

Lots of help from Jonathan Gray. bcw_regs has been removed,
and DMA/descriptor style changes that look more normal. Tested,
no loss in current unfunctionality.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.2 2006/11/17 20:04:52 mglocker Exp $ */
a118 16
#if 0
	struct pci_attach_args *pa = &sc->sc_pa;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char     *intrstr = NULL;
#endif
#if 0
	caddr_t         kva;
	bus_dma_segment_t seg;
	int             rseg;
	pcireg_t        memtype;
	bus_addr_t      memaddr;
	bus_size_t      memsize;
	int             pmreg;
	pcireg_t        pmode;
#endif
d157 1
a157 1
		DPRINTF(("%s: Trial Core read was 0x%x, single core only?\n",
d160 3
a162 1
	}
d173 4
a176 3
		DPRINTF(("%s: Core change read %d = 0x%x\n",
		    sc->sc_dev.dv_xname,i,sbval));
		if (sbval == BCW_CORE_SELECT(0)) break;
a178 17
	/* 
	 * Try and change to random cores
	 */
	for (j = 1; j < 10; j++) {
		for (i = 0; i < 10; i++) {
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    BCW_ADDR_SPACE0, BCW_CORE_SELECT(j));
			delay(10);
			sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_ADDR_SPACE0);
			DPRINTF(("%s: Core change read %d = 0x%x\n",
			    sc->sc_dev.dv_xname,i,sbval));
			if (sbval == BCW_CORE_SELECT(j)) break;
			delay(10);
		}
	}
	//DPRINTF(("\n")); /* Pretty print so the debugs start on new lines */
d182 1
a182 1
	 * a ChipCommon core
d276 1
a276 1
 			DPRINTF(("%s: Trying core %d - ", 
d284 1
a284 1
				DPRINTF(("%s: read %d for core %d = 0x%x ",
a294 1
		DPRINTF(("\n")); /* Make pretty debug output */
d298 1
a298 1
	 * Attach cores to the backplane, if we have more than one
d611 1
a611 1
	 * TODO still for the card attach: 
d660 1
a660 2
	printf(": %s, address %s\n", sc->bcw_intrstr,
	    ether_sprintf(ic->ic_myaddr));
d770 8
a777 5
//	struct bcw_softc *sc = ifp->if_softc;
//	struct mbuf    *m0;
//	bus_dmamap_t    dmamap;
//	int             txstart;
//	int             txsfree;
a778 1
//	int             error;
d800 1
a800 1
		int             seg;
d991 6
a996 2
//	struct rx_pph *pph;
//	struct mbuf *m;
a997 2
//	int len;
//	int i;
d1252 1
a1253 1
#if 0
d1383 2
d1386 1
a1386 3
	u_int32_t sbval;
	int i;
	
d1389 1
a1389 1

d1393 1
a1393 4
#if 0
		// Stop all DMA
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMAI_CTL, 0);

a1394 33
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_TXCTL, 0);
		val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    BCW_DMA_RXSTATUS);
		/* if error on receive, wait to go idle */
		if (val & RS_ERROR) {
			for (i = 0; i < 100; i++) {
				val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    BCW_DMA_RXSTATUS);
				if (val & RS_DMA_IDLE)
					break;
				delay(10);
			}
			if (i == 100)
				printf("%s: receive dma did not go idle after"
				    " error\n", sc->sc_dev.dv_xname);
		}
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DMA_RXSTATUS, 0);

		/* reset ethernet mac */

		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_ENET_CTL,
		    EC_ES);
		for (i = 0; i < 200; i++) {
			val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    BCW_ENET_CTL);
			if (!(val & EC_ES))
				break;
			delay(10);
		}
		if (i == 200)
			printf("%s: timed out resetting ethernet mac\n",
			       sc->sc_dev.dv_xname);
#endif
d1396 1
a1396 1
		u_int32_t reg_win;
d1399 1
a1399 1
#if 0
d1406 1
a1406 1
#endif
d1422 1
a1422 1

d1489 1
a1489 4
#if 0
	/* Write a 0 to MMIO reg 0x3e6, Baseband attenuation */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, 0x3e6,0);
#endif
a1493 17
#if 0
	/* initialize MDC preamble, frequency */
	/* MAGIC */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_MI_CTL, 0x8d);

	/* enable phy, differs for internal, and external */
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_DEVCTL);
	if (!(val & BCW_DC_IP)) {
		/* select external phy */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_ENET_CTL,
		    EC_EP);
	} else if (val & BCW_DC_ER) {	/* internal, clear reset bit if on */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_DEVCTL,
		    val & ~BCW_DC_ER);
		delay(100);
	}
#endif
a1646 1
	DPRINTF(("Write test 1, "));	
d1651 1
a1651 3
	DPRINTF(("Read test 1, "));
	if (val != 0xaa5555aa) {
		DPRINTF(("Failed test 1\n"));
a1652 2
	} else
		DPRINTF(("Passed test 1\n"));
a1657 1
	DPRINTF(("Write test 2, "));
d1662 1
a1662 3
	DPRINTF(("Read test 2, "));
	if (val != 0x55aaaa55) {
		DPRINTF(("Failed test 2\n"));
a1663 2
	} else
		DPRINTF(("Passed test 2\n"));
a1670 1
		DPRINTF(("Doing corerev >= 3 tests\n"));
d1743 1
a1743 1
		if (i = 0; i < BCW_NRXDESC; i++) {
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: bcw.c,v 1.1 2006/11/17 18:58:31 mglocker Exp $ */
d83 1
a83 1
/* Functions copied from bce - */
d93 10
a109 9
/* read/write functions */
u_int8_t	bcw_read8(void *, u_int32_t);
u_int16_t	bcw_read16(void *, u_int32_t);
u_int32_t	bcw_read32(void *, u_int32_t);
void		bcw_write8(void *, u_int32_t, u_int8_t);
void		bcw_write16(void *, u_int32_t, u_int16_t);
void		bcw_write32(void *, u_int32_t, u_int32_t);
void		bcw_barrier(void *, u_int32_t, u_int32_t, int);

d117 1
a117 1
	struct ieee80211com *ic = &sc->bcw_ic;
a118 1
	struct bcw_regs *regs = &sc->bcw_regs;
d120 1
a120 1
	struct pci_attach_args *pa = &sc->bcw_pa;
d125 1
a128 1
#if 0
a139 12
	//sc->bcw_pa = *pa;
	//sc->bcw_dmatag = pa->pa_dmat;

	if (sc->bcw_regs.r_read8 == NULL) {
		sc->bcw_regs.r_read8 = bcw_read8;
		sc->bcw_regs.r_read16 = bcw_read16;
		sc->bcw_regs.r_read32 = bcw_read32;
		sc->bcw_regs.r_write8 = bcw_write8;
		sc->bcw_regs.r_write16 = bcw_write16;
		sc->bcw_regs.r_write32 = bcw_write32;
		sc->bcw_regs.r_barrier = bcw_barrier;
	}
d171 1
a171 1
	sbval = BCW_READ32(regs, BCW_ADDR_SPACE0);
d174 2
a175 2
		    sc->bcw_dev.dv_xname, sbval));
	 	//sc->bcw_singlecore=1;
d182 2
a183 1
		BCW_WRITE32(regs, BCW_ADDR_SPACE0, BCW_CORE_SELECT(0));
d185 2
a186 1
		sbval = BCW_READ32(regs, BCW_ADDR_SPACE0);
d188 1
a188 1
		    sc->bcw_dev.dv_xname,i,sbval));
d192 16
d214 1
a214 1
	sbval = BCW_READ32(regs, BCW_CIR_SBID_HI);
d216 1
a216 1
	    sc->bcw_dev.dv_xname, sbval, (sbval & 0x8ff0) >> 4));
d221 5
a225 4
		sc->bcw_havecommon = 1;
		sbval = BCW_READ32(regs, BCW_CORE_COMMON_CHIPID);
		sc->bcw_chipid = (sbval & 0x0000ffff);
		sc->bcw_corerev =
d227 2
a228 2
		if ((sc->bcw_corerev == 4) || (sc->bcw_corerev >= 6))
			sc->bcw_numcores = (sbval & 0x0f000000) >> 24;
d230 1
a230 1
			switch (sc->bcw_chipid) {
d234 1
a234 1
					sc->bcw_numcores = 9;
d237 1
a237 1
					sc->bcw_numcores = 8;
d240 1
a240 1
					sc->bcw_numcores = 7;
d243 1
a243 1
					sc->bcw_numcores = 6;
d247 1
a247 1
					sc->bcw_numcores = 5;
d250 1
a250 1
					sc->bcw_numcores = 3;
d254 1
a254 1
					sc->bcw_numcores = 0;
d257 2
a258 2
		sc->bcw_havecommon = 0;
		switch(sc->bcw_prodid) {
d265 2
a266 2
				sc->bcw_chipid = 0x4710;
				sc->bcw_numcores = 9;
d274 2
a275 2
				sc->bcw_chipid = 0x4610;
				sc->bcw_numcores = 9;
d279 2
a280 2
				sc->bcw_chipid = 0x4402;
				sc->bcw_numcores = 3;
d285 2
a286 2
				sc->bcw_chipid = 0x4307;
				sc->bcw_numcores = 5;
d289 2
a290 2
				sc->bcw_chipid = 0x4301;
				sc->bcw_numcores = 5;
d293 1
a293 1
				sc->bcw_chipid = sc->bcw_prodid;
d295 1
a295 1
				sc->bcw_numcores = 1;
d300 2
a301 2
	    sc->bcw_dev.dv_xname, sc->bcw_chipid,
	    sc->bcw_chiprev, sc->bcw_numcores));
d304 2
a305 2
	if (sc->bcw_numcores >= 2) { /* Exclude single core chips */
 		for (i = 0; i <= sc->bcw_numcores; i++) {
d307 3
a309 2
 			    sc->bcw_dev.dv_xname, i));
 			BCW_WRITE32(regs, BCW_ADDR_SPACE0, BCW_CORE_SELECT(i));
d312 2
a313 1
				sbval=BCW_READ32(regs, BCW_ADDR_SPACE0);
d315 1
a315 1
				    sc->bcw_dev.dv_xname, j, i, sbval));
d321 1
a321 1
				    sc->bcw_dev.dv_xname, i, 
d323 1
a323 1
			//sc->bcw_core[i].id = (sbval & 0x00008ff0) >> 4;
d331 3
a333 3
	// ??? if (!sc->bcw_singlecore) {
	if (sc->bcw_havecommon == 1) {
		sbval = BCW_READ32(regs, BCW_PCICR);
d335 1
a335 1
		BCW_WRITE32(regs, BCW_PCICR, sbval);
d341 4
a344 4
	sbval = BCW_READ16(regs, 0x3E0);
	sc->bcw_phy_version = (sbval&0xf000)>>12;
	sc->bcw_phy_rev = sbval&0xf;
	sc->bcw_phy_type = (sbval&0xf00)>>8;
d346 2
a347 2
	    sc->bcw_dev.dv_xname, sc->bcw_phy_version, sc->bcw_phy_rev));
	switch (sc->bcw_phy_type) {
d349 1
a349 1
			DPRINTF(("PHY %d (A)\n",sc->bcw_phy_type));
d352 1
a352 1
			DPRINTF(("PHY %d (B)\n",sc->bcw_phy_type));
d355 1
a355 1
			DPRINTF(("PHY %d (G)\n",sc->bcw_phy_type));
d358 1
a358 1
			DPRINTF(("PHY %d (N)\n",sc->bcw_phy_type));
d362 1
a362 1
			    sc->bcw_phy_type));
d374 5
a378 3
	if (sc->bcw_chipid != 0x4317) {
		BCW_WRITE16(regs, BCW_RADIO_CONTROL, BCW_RADIO_ID);
		sbval=BCW_READ16(regs, BCW_RADIO_DATAHIGH);
d380 4
a383 2
		BCW_WRITE16(regs, BCW_RADIO_CONTROL, BCW_RADIO_ID);
		sc->bcw_radioid = sbval | BCW_READ16(regs, BCW_RADIO_DATALOW);
d385 1
a385 1
		switch(sc->bcw_corerev) {
d387 1
a387 1
				sc->bcw_radioid = 0x3205017F;
d390 1
a390 1
				sc->bcw_radioid = 0x4205017f;
d393 1
a393 1
				sc->bcw_radioid = 0x5205017f;
d397 2
a398 2
	sc->bcw_radiorev = (sc->bcw_radioid & 0xf0000000) >> 28;
	sc->bcw_radiotype = (sc->bcw_radioid & 0x0ffff000) >> 12;
d401 2
a402 2
	    sc->bcw_dev.dv_xname, sc->bcw_radiorev, sc->bcw_radiotype,
	    sc->bcw_radioid & 0xfff));
d407 1
a407 1
		    sc->bcw_dev.dv_xname, error);
d411 8
d420 2
a421 2
	if (sc->bcw_phy_type == BCW_PHY_TYPEA) {
		switch(sc->bcw_phy_rev) {
d429 1
a429 1
				    sc->bcw_dev.dv_xname, sc->bcw_phy_rev);
d433 2
a434 2
	if (sc->bcw_phy_type == BCW_PHY_TYPEB) {
		switch(sc->bcw_phy_rev) {
d440 1
a440 1
				    sc->bcw_dev.dv_xname, sc->bcw_phy_rev);
d444 2
a445 2
	if (sc->bcw_phy_type == BCW_PHY_TYPEG) {
		switch(sc->bcw_phy_rev) {
d454 1
a454 1
				    sc->bcw_dev.dv_xname, sc->bcw_phy_rev);
d460 2
a461 2
	if ((sc->bcw_phy_type == BCW_PHY_TYPEA) &
	    (sc->bcw_radiotype != 0x2060)) {
d463 1
a463 1
		    	    sc->bcw_dev.dv_xname, sc->bcw_radiotype);
d466 2
a467 2
	if ((sc->bcw_phy_type == BCW_PHY_TYPEB) &
	    ((sc->bcw_radiotype & 0xfff0) != 0x2050)) {
d469 1
a469 1
		    	    sc->bcw_dev.dv_xname, sc->bcw_radiotype);
d472 2
a473 2
	if ((sc->bcw_phy_type == BCW_PHY_TYPEG) &
	    (sc->bcw_radiotype != 0x2050)) {
d475 1
a475 1
		    	    sc->bcw_dev.dv_xname, sc->bcw_radiotype);
d482 1
a482 1
	switch(sc->bcw_phy_type) {
d485 8
a492 4
			BCW_WRITE16(regs, BCW_RADIO_CONTROL, 0x04);
			BCW_WRITE16(regs, BCW_RADIO_DATALOW, 0xff);
			BCW_WRITE16(regs, BCW_RADIO_CONTROL, 0x05);
			BCW_WRITE16(regs, BCW_RADIO_DATALOW, 0xfb);
d503 4
a506 2
			BCW_WRITE16(regs, BCW_PHY_CONTROL, 0x10);
			sbval16 = BCW_READ16(regs, BCW_PHY_DATA);
d508 9
a516 5
			BCW_WRITE16(regs, BCW_PHY_CONTROL, 0x10);
			BCW_WRITE16(regs, BCW_PHY_DATA, sbval16);

			BCW_WRITE16(regs, BCW_PHY_CONTROL, 0x11);
			sbval16 = BCW_READ16(regs, BCW_PHY_DATA);
d518 4
a521 2
			BCW_WRITE16(regs, BCW_PHY_CONTROL, 0x11);
			BCW_WRITE16(regs, BCW_PHY_DATA, sbval16);
d524 5
a528 3
			if (sc->bcw_corerev >= 5) {
				BCW_WRITE16(regs, BCW_PHY_CONTROL, 0x811);
				sbval16 = BCW_READ16(regs, BCW_PHY_DATA);
d530 9
a538 5
				BCW_WRITE16(regs, BCW_PHY_CONTROL, 0x811);
				BCW_WRITE16(regs, BCW_PHY_DATA, sbval16);

				BCW_WRITE16(regs, BCW_PHY_CONTROL, 0x812);
				sbval16 = BCW_READ16(regs, BCW_PHY_DATA);
d540 4
a543 2
				BCW_WRITE16(regs, BCW_PHY_CONTROL, 0x812);
				BCW_WRITE16(regs, BCW_PHY_DATA, sbval16);
d547 4
a550 2
			BCW_WRITE16(regs, BCW_PHY_CONTROL, 0x15);
			BCW_WRITE16(regs, BCW_PHY_DATA, 0xaa00);
a552 2
	// XXX - Get a copy of the BoardFlags to keep in RAM

d554 1
a554 1
	sbval = BCW_READ16(regs, BCW_SPROM_ANTGAIN);
d557 2
a558 2
	if(sc->bcw_phy_type == BCW_PHY_TYPEA)
		sc->bcw_radio_gain = (sbval & 0xff);
d560 2
a561 2
		sc->bcw_radio_gain = ((sbval & 0xff00) >> 8);
	sc->bcw_radio_gain *= 4;
d567 12
a578 6
	sc->bcw_radio_pa0b0 = BCW_READ16(regs, BCW_SPROM_PA0B0);
	sc->bcw_radio_pa0b1 = BCW_READ16(regs, BCW_SPROM_PA0B1);
	sc->bcw_radio_pa0b2 = BCW_READ16(regs, BCW_SPROM_PA0B2);
	sc->bcw_radio_pa1b0 = BCW_READ16(regs, BCW_SPROM_PA1B0);
	sc->bcw_radio_pa1b1 = BCW_READ16(regs, BCW_SPROM_PA1B1);
	sc->bcw_radio_pa1b2 = BCW_READ16(regs, BCW_SPROM_PA1B2);
d581 3
a583 3
	sbval = BCW_READ16(regs, BCW_SPROM_IDLETSSI);
	if(sc->bcw_phy_type == BCW_PHY_TYPEA)
		sc->bcw_idletssi = (sbval & 0xff);
d585 1
a585 1
		sc->bcw_idletssi = ((sbval & 0xff00) >> 8);
d592 3
a594 3
	if((sc->bcw_phy_type == BCW_PHY_TYPEA) ||
	    (sc->bcw_phy_type == BCW_PHY_TYPEB) ||
	    (sc->bcw_phy_type == BCW_PHY_TYPEG))
d596 2
a597 2
	if((sc->bcw_phy_type == BCW_PHY_TYPEG) &&
	    (sc->bcw_phy_rev == 1))
d599 5
a603 6
	/*
	 * XXX If this is a G PHY with BoardFlags BFL_PACTRL set,
	 * set bit 0x40
	 */
	if((sc->bcw_phy_type == BCW_PHY_TYPEG) &&
	    (sc->bcw_phy_rev < 3))
d605 3
a607 2
	/* XXX If BoardFlags BFL_XTAL is set, set bit 0x400 */
	if(sc->bcw_phy_type == BCW_PHY_TYPEB)
d609 2
a610 2
	if((sc->bcw_radiotype == 0x2050) &&
	    (sc->bcw_radiorev <= 5))
d627 1
a627 1
	BCW_WRITE32(regs, BCW_SHM_CONTROL, 
d629 4
a632 2
	BCW_WRITE16(regs, BCW_SHM_DATAHIGH, sbval & 0x00ff);
	BCW_WRITE16(regs, BCW_SHM_DATALOW, (sbval & 0xff00)>>16);
d643 1
a643 1
	 * - Disable the 80211 Core
a650 2
	 * XXX - still not too sure on how this works, it is
	 * some of the remaining untouched code from if_bce
d652 2
a653 59
	if ((error = bus_dmamem_alloc(sc->bcw_dmatag,
	    2 * PAGE_SIZE, PAGE_SIZE, 2 * PAGE_SIZE,
	    &seg, 1, &rseg, BUS_DMA_NOWAIT))) {
		printf("%s: unable to alloc space for ring descriptors, "
		       "error = %d\n", sc->bcw_dev.dv_xname, error);
		return;
	}
	/* map ring space to kernel */
	if ((error = bus_dmamem_map(sc->bcw_dmatag, &seg, rseg,
	    2 * PAGE_SIZE, &kva, BUS_DMA_NOWAIT))) {
		printf("%s: unable to map DMA buffers, error = %d\n",
		    sc->bcw_dev.dv_xname, error);
		bus_dmamem_free(sc->bcw_dmatag, &seg, rseg);
		return;
	}
	/* create a dma map for the ring */
	if ((error = bus_dmamap_create(sc->bcw_dmatag,
	    2 * PAGE_SIZE, 1, 2 * PAGE_SIZE, 0, BUS_DMA_NOWAIT,
	    &sc->bcw_ring_map))) {
		printf("%s: unable to create ring DMA map, error = %d\n",
		    sc->bcw_dev.dv_xname, error);
		bus_dmamem_unmap(sc->bcw_dmatag, kva, 2 * PAGE_SIZE);
		bus_dmamem_free(sc->bcw_dmatag, &seg, rseg);
		return;
	}
	/* connect the ring space to the dma map */
	if (bus_dmamap_load(sc->bcw_dmatag, sc->bcw_ring_map, kva,
	    2 * PAGE_SIZE, NULL, BUS_DMA_NOWAIT)) {
		bus_dmamap_destroy(sc->bcw_dmatag, sc->bcw_ring_map);
		bus_dmamem_unmap(sc->bcw_dmatag, kva, 2 * PAGE_SIZE);
		bus_dmamem_free(sc->bcw_dmatag, &seg, rseg);
		return;
	}
	/* save the ring space in softc */
	sc->bcw_rx_ring = (struct bcw_dma_slot *) kva;
	sc->bcw_tx_ring = (struct bcw_dma_slot *) (kva + PAGE_SIZE);

	/* Create the transmit buffer DMA maps. */
	for (i = 0; i < BCW_NTXDESC; i++) {
		if ((error = bus_dmamap_create(sc->bcw_dmatag, MCLBYTES,
		    BCW_NTXFRAGS, MCLBYTES, 0, 0,
		    &sc->bcw_cdata.bcw_tx_map[i])) != 0) {
			printf("%s: unable to create tx DMA map, error = %d\n",
			    sc->bcw_dev.dv_xname, error);
		}
		sc->bcw_cdata.bcw_tx_chain[i] = NULL;
	}

	/* Create the receive buffer DMA maps. */
	for (i = 0; i < BCW_NRXDESC; i++) {
		if ((error = bus_dmamap_create(sc->bcw_dmatag, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &sc->bcw_cdata.bcw_rx_map[i])) != 0) {
			printf("%s: unable to create rx DMA map, error = %d\n",
			    sc->bcw_dev.dv_xname, error);
		}
		sc->bcw_cdata.bcw_rx_chain[i] = NULL;
	}

	/* End of the DMA stuff */
d663 3
a665 2
	if(sc->bcw_phy_type == BCW_PHY_TYPEA) {
		i=BCW_READ16(regs, BCW_SPROM_ET1MACADDR);
d668 2
a669 1
		i=BCW_READ16(regs, BCW_SPROM_ET1MACADDR + 2);
d672 2
a673 1
		i=BCW_READ16(regs, BCW_SPROM_ET1MACADDR + 4);
d677 2
a678 1
		i=BCW_READ16(regs, BCW_SPROM_IL0MACADDR);
d681 2
a682 1
		i=BCW_READ16(regs, BCW_SPROM_IL0MACADDR + 2);
d685 2
a686 1
		i=BCW_READ16(regs, BCW_SPROM_IL0MACADDR + 4);
d717 1
a717 1
	bcopy(sc->bcw_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
d727 1
a727 1
	timeout_set(&sc->bcw_timeout, bcw_tick, sc);
d735 1
a735 2
	struct ieee80211com *ic = &sc->bcw_ic;
	//struct bcw_regs *regs = &sc->bcw_regs;
a740 6
#if 0
	if ((error = ether_ioctl(ifp, &sc->bcw_ac, cmd, data)) > 0) {
		splx(s);
		return (error);
	}
#endif
d750 1
a750 1
			arp_ifinit(&sc->bcw_ac, ifa);
d802 5
a806 6
	struct bcw_softc *sc = ifp->if_softc;
	struct bcw_regs *regs = &sc->bcw_regs;
	struct mbuf    *m0;
	bus_dmamap_t    dmamap;
	int             txstart;
	int             txsfree;
d808 1
a808 1
	int             error;
d817 1
d819 2
a820 2
	if (sc->bcw_txsnext >= sc->bcw_txin)
		txsfree = BCW_NTXDESC - 1 + sc->bcw_txin - sc->bcw_txsnext;
d822 1
a822 1
		txsfree = sc->bcw_txin - sc->bcw_txsnext - 1;
d838 1
a838 1
		dmamap = sc->bcw_cdata.bcw_tx_map[sc->bcw_txsnext];
d847 1
a847 1
		error = bus_dmamap_load_mbuf(sc->bcw_dmatag, dmamap, m0,
d851 1
a851 1
			    "dropping...\n", sc->bcw_dev.dv_xname);
d859 1
a859 1
			    sc->bcw_dev.dv_xname, error);
d865 1
a865 1
			bus_dmamap_unload(sc->bcw_dmatag, dmamap);
d874 1
a874 1
		sc->bcw_cdata.bcw_tx_chain[sc->bcw_txsnext] = m0;
d877 1
a877 1
		bus_dmamap_sync(sc->bcw_dmatag, dmamap, 0, dmamap->dm_mapsize,
d881 1
a881 1
		txstart = sc->bcw_txsnext;
d890 1
a890 1
			if (sc->bcw_txsnext == BCW_NTXDESC - 1)
d893 1
a893 1
			sc->bcw_tx_ring[sc->bcw_txsnext].ctrl = htole32(ctrl);
d895 1
a895 1
			sc->bcw_tx_ring[sc->bcw_txsnext].addr =
d897 2
a898 2
			if (sc->bcw_txsnext + 1 > BCW_NTXDESC - 1)
				sc->bcw_txsnext = 0;
d900 1
a900 1
				sc->bcw_txsnext++;
d904 1
a904 1
		bus_dmamap_sync(sc->bcw_dmatag, sc->bcw_ring_map,
d910 2
a911 2
		BCW_WRITE32(regs, BCW_DMA_DPTR,
			     sc->bcw_txsnext * sizeof(struct bcw_dma_slot));
d925 1
d938 1
a938 1
	printf("%s: device timeout\n", sc->bcw_dev.dv_xname);
a950 1
	struct bcw_regs *regs;
a956 2
	regs = &sc->bcw_regs;
	ifp = &sc->bcw_ac.ac_if;
d959 2
a960 1
		intstatus = BCW_READ32(regs, BCW_INT_STS);
d963 1
a963 1
		intstatus &= sc->bcw_intmask;
d970 2
a971 1
		BCW_WRITE32(regs, BCW_INT_STS, intstatus);
d983 1
a983 1
				    sc->bcw_dev.dv_xname);
d986 1
a986 1
				    sc->bcw_dev.dv_xname);
d991 1
a991 1
				       sc->bcw_dev.dv_xname);
d994 1
a994 1
				       sc->bcw_dev.dv_xname);
d997 1
a997 1
				    sc->bcw_dev.dv_xname);
d1000 1
a1000 1
				    sc->bcw_dev.dv_xname);
d1003 1
a1003 1
				    sc->bcw_dev.dv_xname);
d1021 2
a1022 4
	struct ifnet *ifp = &sc->bcw_ac.ac_if;
	struct bcw_regs *regs = &sc->bcw_regs;
	struct rx_pph *pph;
	struct mbuf *m;
d1024 2
a1025 2
	int len;
	int i;
d1028 2
a1029 1
	curr = BCW_READ32(regs, BCW_DMA_RXSTATUS) & RS_CD_MASK;
d1031 2
a1032 2
	if (curr >= BCW_NRXDESC)
		curr = BCW_NRXDESC - 1;
d1034 1
d1036 1
a1036 1
	for (i = sc->bcw_rxin; i != curr;
d1039 2
a1040 2
		bus_dmamap_sync(sc->bcw_dmatag, sc->bcw_cdata.bcw_rx_map[i], 0,
		    sc->bcw_cdata.bcw_rx_map[i]->dm_mapsize,
d1047 1
a1047 1
		pph = mtod(sc->bcw_cdata.bcw_rx_chain[i], struct rx_pph *);
d1049 1
a1049 1
			ifp->if_ierrors++;
d1061 1
a1061 1
		sc->bcw_cdata.bcw_rx_chain[i]->m_data += 
d1087 2
a1088 2
			    mtod(sc->bcw_cdata.bcw_rx_chain[i], caddr_t), len);
			sc->bcw_cdata.bcw_rx_chain[i]->m_data -=
d1091 1
a1091 1
			m = sc->bcw_cdata.bcw_rx_chain[i];
d1094 1
a1094 1
				ifp->if_ierrors++;
d1096 1
a1096 1
				sc->bcw_cdata.bcw_rx_chain[i]->m_data -=
d1098 3
a1100 3
				bus_dmamap_sync(sc->bcw_dmatag,
				    sc->bcw_cdata.bcw_rx_map[i], 0,
				    sc->bcw_cdata.bcw_rx_map[i]->dm_mapsize,
d1108 1
a1108 1
		ifp->if_ipackets++;
d1114 3
a1117 2
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1120 2
a1121 2
		/* Pass it on. */
		ether_input_mbuf(ifp, m);
d1124 1
a1124 1
		curr = (BCW_READ32(regs,
d1130 2
a1131 1
	sc->bcw_rxin = curr;
d1138 1
a1138 2
	struct ifnet *ifp = &sc->bcw_ac.ac_if;
	struct bcw_regs *regs = &sc->bcw_regs;
d1140 1
a1140 1
	int i;
d1142 1
a1142 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1144 1
d1149 1
a1149 1
	curr = BCW_READ32(regs, BCW_DMA_TXSTATUS) & RS_CD_MASK;
d1153 1
a1153 1
	for (i = sc->bcw_txin; i != curr;
d1156 1
a1156 1
		if (sc->bcw_cdata.bcw_tx_chain[i] == NULL)
d1158 2
a1159 2
		bus_dmamap_sync(sc->bcw_dmatag, sc->bcw_cdata.bcw_tx_map[i], 0,
		    sc->bcw_cdata.bcw_tx_map[i]->dm_mapsize,
d1161 3
a1163 3
		bus_dmamap_unload(sc->bcw_dmatag, sc->bcw_cdata.bcw_tx_map[i]);
		m_freem(sc->bcw_cdata.bcw_tx_chain[i]);
		sc->bcw_cdata.bcw_tx_chain[i] = NULL;
d1166 2
a1167 1
	sc->bcw_txin = curr;
d1173 2
a1174 2
	if (sc->bcw_txsnext == sc->bcw_txin)
		ifp->if_timer = 0;
a1181 1
	struct bcw_regs *regs = &sc->bcw_regs;
a1182 2
	int error;
	int i;
d1194 1
a1194 1
	/* enable pci inerrupts, bursts, and prefetch */
d1199 1
a1199 1
	reg_win = BCW_READ32(regs, BCW_REG0_WIN);
d1202 1
a1202 1
	BCW_WRITE32(regs, BCW_REG0_WIN, BCW_SONICS_WIN);
d1205 2
a1206 2
	BCW_WRITE32(regs, BCW_SBINTVEC,
	    BCW_READ32(regs, BCW_SBINTVEC) |
d1210 2
a1211 2
	BCW_WRITE32(regs, BCW_SPCI_TR2,
	    BCW_READ32(regs, BCW_SPCI_TR2) |
d1215 1
a1215 1
	BCW_WRITE32(regs, BCW_REG0_WIN, reg_win);
d1220 1
d1223 3
a1225 2
	sc->bcw_txsnext = 0;
	sc->bcw_txin = 0;
d1228 2
a1229 2
	BCW_WRITE32(regs, BCW_MACCTL,
	    BCW_READ32(regs, BCW_MACCTL) |
d1233 2
a1234 2
	BCW_WRITE32(regs, BCW_MACCTL,
	    BCW_READ32(regs, BCW_MACCTL) &
d1238 1
a1238 1
	BCW_WRITE32(regs, BCW_DMAI_CTL, 1 << 24);	/* MAGIC */
d1244 1
a1244 1
	BCW_WRITE32(regs, BCW_RX_MAX,
d1246 1
a1246 1
	BCW_WRITE32(regs, BCW_TX_MAX,
d1250 1
a1250 1
	BCW_WRITE32(regs, BCW_TX_WATER, 56);
d1253 1
a1253 4
	BCW_WRITE32(regs, BCW_DMA_TXCTL, XC_XE);
	/* MAGIC */
	BCW_WRITE32(regs, BCW_DMA_TXADDR,
	    sc->bcw_ring_map->dm_segs[0].ds_addr + PAGE_SIZE + 0x40000000);
d1259 1
a1259 1
	sc->bcw_rxin = 0;
a1260 2
	/* clear the rx descriptor ring */
	memset(sc->bcw_rx_ring, 0, BCW_NRXDESC * sizeof(struct bcw_dma_slot));
d1262 1
a1262 1
	BCW_WRITE32(regs, BCW_DMA_RXCTL,
a1263 16
	BCW_WRITE32(regs, BCW_DMA_RXADDR,
	    sc->bcw_ring_map->dm_segs[0].ds_addr + 0x40000000);	/* MAGIC */

	/* Initalize receive descriptors */
	for (i = 0; i < BCW_NRXDESC; i++) {
		if (sc->bcw_cdata.bcw_rx_chain[i] == NULL) {
			if ((error = bcw_add_rxbuf(sc, i)) != 0) {
				printf("%s: unable to allocate or map rx(%d) "
				    "mbuf, error = %d\n", sc->bcw_dev.dv_xname,
				    i, error);
				bcw_rxdrain(sc);
				return (error);
			}
		} else
			BCW_INIT_RXDESC(sc, i);
	}
d1266 1
a1266 1
	sc->bcw_intmask =
d1268 2
a1269 2
	BCW_WRITE32(regs, BCW_INT_MASK,
	    sc->bcw_intmask);
d1271 1
d1273 1
a1273 1
	BCW_WRITE32(regs, BCW_DMA_RXDPTR,
d1275 1
d1282 2
a1283 2
	bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_ENET_CTL,
	    bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle,
d1288 1
a1288 1
	timeout_add(&sc->bcw_timeout, hz);
d1301 1
d1314 3
a1316 3
	if (sc->bcw_cdata.bcw_rx_chain[idx] != NULL)
		bus_dmamap_unload(sc->bcw_dmatag,
		    sc->bcw_cdata.bcw_rx_map[idx]);
d1318 1
a1318 1
	sc->bcw_cdata.bcw_rx_chain[idx] = m;
d1320 1
a1320 1
	error = bus_dmamap_load(sc->bcw_dmatag, sc->bcw_cdata.bcw_rx_map[idx],
d1326 2
a1327 2
	bus_dmamap_sync(sc->bcw_dmatag, sc->bcw_cdata.bcw_rx_map[idx], 0,
	    sc->bcw_cdata.bcw_rx_map[idx]->dm_mapsize, BUS_DMASYNC_PREREAD);
d1332 2
d1341 1
d1345 5
a1349 5
		if (sc->bcw_cdata.bcw_rx_chain[i] != NULL) {
			bus_dmamap_unload(sc->bcw_dmatag,
			    sc->bcw_cdata.bcw_rx_map[i]);
			m_freem(sc->bcw_cdata.bcw_rx_chain[i]);
			sc->bcw_cdata.bcw_rx_chain[i] = NULL;
d1352 1
a1359 2
	struct bcw_regs *regs = &sc->bcw_regs;
	int i;
d1363 1
a1363 1
	timeout_del(&sc->bcw_timeout);
d1370 2
a1371 2
	BCW_WRITE32(regs, BCW_INT_MASK, 0);
	sc->bcw_intmask = 0;
d1376 1
a1376 1
	bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_ENET_CTL, EC_ED);
d1378 1
a1378 1
		val = bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle,
d1386 2
a1387 2
	BCW_WRITE32(regs, BCW_DMA_RXCTL, 0);
	BCW_WRITE32(regs, BCW_DMA_TXCTL, 0);
d1390 1
d1393 5
a1397 5
		if (sc->bcw_cdata.bcw_tx_chain[i] != NULL) {
			bus_dmamap_unload(sc->bcw_dmatag,
			    sc->bcw_cdata.bcw_tx_map[i]);
			m_freem(sc->bcw_cdata.bcw_tx_chain[i]);
			sc->bcw_cdata.bcw_tx_chain[i] = NULL;
d1400 1
a1410 1
	struct bcw_regs *regs = &sc->bcw_regs;
d1416 1
a1416 1
	sbval = BCW_READ32(regs, BCW_SBTMSTATELOW);
d1421 1
d1423 1
a1423 1
		BCW_WRITE32(regs, BCW_DMAI_CTL, 0);
d1426 3
a1428 2
		BCW_WRITE32(regs, BCW_DMA_TXCTL, 0);
		val = BCW_READ32(regs, BCW_DMA_RXSTATUS);
d1432 2
a1433 1
				val = BCW_READ32(regs, BCW_DMA_RXSTATUS);
d1440 1
a1440 1
				    " error\n", sc->bcw_dev.dv_xname);
d1442 1
a1442 1
		BCW_WRITE32(regs, BCW_DMA_RXSTATUS, 0);
d1445 2
a1446 2
#if 0
		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_ENET_CTL,
d1449 1
a1449 1
			val = bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle,
d1457 1
a1457 1
			       sc->bcw_dev.dv_xname);
d1463 1
a1463 1

d1465 2
a1466 1
		reg_win = BCW_READ32(regs, BCW_REG0_WIN);
d1468 3
a1470 2
		BCW_WRITE32(regs, BCW_REG0_WIN, BCW_SONICS_WIN);

d1472 2
a1473 2
		BCW_WRITE32(regs, BCW_SBINTVEC,
		    BCW_READ32(regs,
d1478 2
a1479 2
		BCW_WRITE32(regs, BCW_SPCI_TR2,
		    BCW_READ32(regs,
d1484 1
a1484 1
		BCW_WRITE32(regs, BCW_REG0_WIN, reg_win);
d1491 2
a1492 1
		BCW_WRITE32(regs, BCW_SBTMSTATELOW, SBTML_REJ | SBTML_CLK);
d1494 2
a1495 1
			val = BCW_READ32(regs, BCW_SBTMSTATELOW);
d1502 1
a1502 1
			    sc->bcw_dev.dv_xname);
d1505 2
a1506 1
			val = BCW_READ32(regs, BCW_SBTMSTATEHI);
d1513 1
a1513 1
			    sc->bcw_dev.dv_xname);
d1515 1
a1515 1
		BCW_WRITE32(regs, BCW_SBTMSTATELOW,
d1518 2
a1519 1
		val = BCW_READ32(regs, BCW_SBTMSTATELOW);
d1521 2
a1522 1
		BCW_WRITE32(regs, BCW_SBTMSTATELOW, SBTML_REJ | SBTML_RESET);
d1527 1
a1527 1
	BCW_WRITE32(regs, BCW_SBTMSTATELOW,
d1530 1
a1530 1
	val = BCW_READ32(regs, BCW_SBTMSTATELOW);
d1534 1
a1534 1
	val = BCW_READ32(regs, BCW_SBTMSTATEHI);
d1536 2
a1537 2
		BCW_WRITE32(regs, BCW_SBTMSTATEHI, 0);
	val = BCW_READ32(regs, BCW_SBIMSTATE);
d1539 1
a1539 1
		BCW_WRITE32(regs, BCW_SBIMSTATE,
d1543 1
a1543 1
	BCW_WRITE32(regs, BCW_SBTMSTATELOW,
d1545 1
a1545 1
	val = BCW_READ32(regs, BCW_SBTMSTATELOW);
d1549 1
a1549 1
	BCW_WRITE32(regs, BCW_SBTMSTATELOW,
d1551 1
a1551 1
	val = BCW_READ32(regs, BCW_SBTMSTATELOW);
d1553 1
a1553 1

d1555 2
a1556 2
	BCW_WRITE16(regs, 0x3e6,0);
	
d1558 1
a1558 1
	sbval=BCW_READ32(regs, 0x120);
d1560 1
a1560 1
	BCW_WRITE32(regs, 0x120, sbval);
d1564 1
a1564 1
	bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_MI_CTL, 0x8d);
d1567 1
a1567 1
	val = bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle, BCW_DEVCTL);
d1570 1
a1570 1
		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_ENET_CTL,
d1573 1
a1573 1
		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_DEVCTL,
d1615 1
a1615 1
		bcw_add_mac(sc, sc->bcw_ac.ac_enaddr, 0);
d1663 1
a1663 1
	struct ieee80211com *ic = &sc->bcw_ic;
d1665 1
a1665 1
	int rate;                                                                        
a1713 1
	struct bcw_regs *regs = &sc->bcw_regs;
d1723 1
a1723 1
	BCW_WRITE32(regs, BCW_SHM_CONTROL,
d1725 1
a1725 1
	save = BCW_READ32(regs, BCW_SHM_DATA);
d1728 3
a1730 2
	BCW_WRITE32(regs, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
	BCW_WRITE32(regs, BCW_SHM_DATA, 0xaa5555aa);
d1733 3
a1735 2
	BCW_WRITE32(regs, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
	val = BCW_READ32(regs, BCW_SHM_DATA);
d1744 3
a1746 2
	BCW_WRITE32(regs, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
	BCW_WRITE32(regs, BCW_SHM_DATA, 0x55aaaa55);
d1749 3
a1751 2
	BCW_WRITE32(regs, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
	val = BCW_READ32(regs, BCW_SHM_DATA);
d1760 3
a1762 2
	BCW_WRITE32(regs, BCW_SHM_CONTROL, (BCW_SHM_CONTROL_SHARED << 16) + 0);
	BCW_WRITE32(regs, BCW_SHM_DATA, save);
d1764 1
a1764 1
	if (sc->bcw_corerev >= 3) {
d1773 3
a1775 3
		BCW_WRITE16(regs, 0x18c, 0xaaaa);
		BCW_WRITE32(regs, 0x18c, 0xccccbbbb);
		val = BCW_READ16(regs, 0x604);
d1777 1
a1777 1
		val = BCW_READ16(regs, 0x606);
d1780 1
a1780 1
		BCW_WRITE32(regs, 0x18c, 0x0);
d1784 1
a1784 1
	val = BCW_READ32(regs, BCW_SBF);
d1787 1
a1787 1
		    sc->bcw_dev.dv_xname,val);
d1792 3
a1794 3
	val = BCW_READ32(regs, BCW_GIR);
	if (val!=0) {
		DPRINTF(("Failed Pending Interrupt test with val=0x%x\n",val));
d1799 1
a1799 1
	if (sc->bcw_phy_type > BCW_PHY_TYPEG) {
d1801 1
a1801 1
		    sc->bcw_phy_type, BCW_PHY_TYPEG));
d1809 3
a1811 5
/*
 * Abstracted reads and writes - from rtw
 */
u_int8_t
bcw_read8(void *arg, u_int32_t off)
d1813 13
a1825 2
	struct bcw_regs *regs = (struct bcw_regs *)arg;
	return (bus_space_read_1(regs->r_bt, regs->r_bh, off));
d1828 4
a1831 2
u_int16_t
bcw_read16(void *arg, u_int32_t off)
d1833 24
a1856 2
	struct bcw_regs *regs = (struct bcw_regs *)arg;
	return (bus_space_read_2(regs->r_bt, regs->r_bh, off));
d1858 1
d1860 2
a1861 2
u_int32_t
bcw_read32(void *arg, u_int32_t off)
d1863 113
a1975 2
	struct bcw_regs *regs = (struct bcw_regs *)arg;
	return (bus_space_read_4(regs->r_bt, regs->r_bh, off));
d1979 1
a1979 1
bcw_write8(void *arg, u_int32_t off, u_int8_t val)
d1981 4
a1984 2
	struct bcw_regs *regs = (struct bcw_regs *)arg;
	bus_space_write_1(regs->r_bt, regs->r_bh, off, val);
d1988 1
a1988 1
bcw_write16(void *arg, u_int32_t off, u_int16_t val)
d1990 108
a2097 2
	struct bcw_regs *regs = (struct bcw_regs *)arg;
	bus_space_write_2(regs->r_bt, regs->r_bh, off, val);
d2101 1
a2101 1
bcw_write32(void *arg, u_int32_t off, u_int32_t val)
d2103 28
a2130 2
	struct bcw_regs *regs = (struct bcw_regs *)arg;
	bus_space_write_4(regs->r_bt, regs->r_bh, off, val);
d2134 1
a2134 1
bcw_barrier(void *arg, u_int32_t reg0, u_int32_t reg1, int flags)
d2136 35
a2170 3
	struct bcw_regs *regs = (struct bcw_regs *)arg;
	bus_space_barrier(regs->r_bh, regs->r_bt, MIN(reg0, reg1),
	    MAX(reg0, reg1) - MIN(reg0, reg1) + 4, flags);
d2172 1
@


1.1
log
@This is a very initial import for a driver which supports the IEEE 802.11
Broadcom BCM43xx chipset.  Device attaches, but has no further
functionality yet.

The work has been done by Jon Simola <jsimola@@gmail.com>, based on the
existing bce(4) code.  He will continue to work on the driver and try
to make further progress.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d87 1
a87 1
//static	void	bcw_add_mac(struct bcw_softc *, u_int8_t *, unsigned long);
a108 1

d119 6
a124 4
//	struct pci_attach_args *pa = &sc->bcw_pa;
//	pci_chipset_tag_t pc = pa->pa_pc;
//	pci_intr_handle_t ih;
//	const char     *intrstr = NULL;
d128 7
a134 5
//	pcireg_t        memtype;
//	bus_addr_t      memaddr;
//	bus_size_t      memsize;
//	int             pmreg;
//	pcireg_t        pmode;
d140 2
a141 2
//	sc->bcw_pa = *pa;
//	sc->bcw_dmatag = pa->pa_dmat;
a152 1

d202 1
a202 1
//	DPRINTF(("\n")); // Pretty print so the debugs start on new lines
d218 2
a219 1
		sc->bcw_corerev = ((sbval & 0x00007000) >> 8 | (sbval & 0x0000000f));
d314 1
a314 1
//				sc->bcw_core[i].id = (sbval & 0x00008ff0) >> 4;
a460 1
	
d542 1
a542 1
	// http://bcm-specs.sipsolutions.net/MicrocodeFlagsBitfield
d552 4
a555 1
	// XXX If this is a G PHY with BoardFlags BFL_PACTRL set, set bit 0x40
d559 1
a559 1
	// XXX If BoardFlags BFL_XTAL is set, set bit 0x400
d565 4
a568 3
	/* XXX If the device isn't up and this is a PCI bus with revision 
	  10 or less set bit 0x80000 */

d570 2
a571 2
	/* Now, write the value into the regster */
	/*
a590 1

a598 2


d607 1
a607 1
				      &seg, 1, &rseg, BUS_DMA_NOWAIT))) {
d623 1
a623 1
				       &sc->bcw_ring_map))) {
d645 2
a646 1
		    BCW_NTXFRAGS, MCLBYTES, 0, 0, &sc->bcw_cdata.bcw_tx_map[i])) != 0) {
a664 1

d666 1
a666 1
	ic->ic_opmode = IEEE80211_M_STA;        /* default to BSS mode */
d670 1
a670 2
	ic->ic_caps =
	  IEEE80211_C_IBSS;          /* IBSS mode supported */
d704 5
a708 5
	  ic->ic_channels[i].ic_freq =
	    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
	  ic->ic_channels[i].ic_flags =
	    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
	    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
d740 1
a740 1
//	struct bcw_regs *regs = &sc->bcw_regs;
d746 6
a751 5

//	if ((error = ether_ioctl(ifp, &sc->bcw_ac, cmd, data)) > 0) {
//		splx(s);
//		return (error);
//	}
d889 1
a889 1
				BUS_DMASYNC_PREWRITE);
d905 1
d907 1
a907 1
			    htole32(dmamap->dm_segs[seg].ds_addr + 0x40000000);	/* MAGIC */
d962 1
a962 1
	struct ifnet   *ifp;
d964 2
a965 2
	int             wantinit;
	int             handled = 0;
a970 1

d1032 1
a1032 1
	struct ifnet   *ifp = &sc->bcw_ac.ac_if;
d1034 5
a1038 5
	struct rx_pph  *pph;
	struct mbuf    *m;
	int             curr;
	int             len;
	int             i;
d1147 1
a1147 1
	struct ifnet   *ifp = &sc->bcw_ac.ac_if;
d1149 2
a1150 2
	int             curr;
	int             i;
d1192 2
a1193 2
	int             error;
	int             i;
d1263 1
d1265 1
a1265 1
	    sc->bcw_ring_map->dm_segs[0].ds_addr + PAGE_SIZE + 0x40000000);	/* MAGIC */
d1306 1
a1306 1
//	mii_mediachg(&sc->bcw_mii);
d1309 5
a1313 3
//	bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_ENET_CTL,
//	    bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle,
//	    BCW_ENET_CTL) | EC_EE);
d1322 1
a1322 1
	return 0;
d1329 2
a1330 2
	struct mbuf    *m;
	int             error;
d1366 1
a1366 1
	int             i;
d1384 1
a1384 1
	int             i;
d1399 2
a1400 1
	/* Disable emac
d1409 1
a1409 1
	*/
d1432 1
a1432 2
bcw_reset(sc)
	struct bcw_softc *sc;
d1437 1
a1437 2
	int	i;

d1465 2
a1466 1
		/* reset ethernet mac 
d1479 1
a1479 1
		*/
d1532 2
a1533 1
		    SBTML_FGC | SBTML_CLK | SBTML_REJ | SBTML_RESET | SBTML_80211FLAG );
d1539 1
a1539 1
	// This is enabling/resetting the core
d1575 4
a1578 3

//	/* initialize MDC preamble, frequency */
//	bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_MI_CTL, 0x8d);	/* MAGIC */
d1581 2
a1582 2
//	val = bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle, BCW_DEVCTL);
//	if (!(val & BCW_DC_IP)) {
d1584 8
a1591 6
//		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_ENET_CTL, EC_EP);
//	} else if (val & BCW_DC_ER) {	/* internal, clear reset bit if on */
//		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_DEVCTL,
//		    val & ~BCW_DC_ER);
//		delay(100);
//	}
d1598 2
a1599 1
//	struct bcw_softc *sc = ifp->if_softc;
d1601 7
a1607 7
//	if (ifp->if_flags & IFF_PROMISC) {
//		ifp->if_flags |= IFF_ALLMULTI;
//		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL,
//		    bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL)
//		    | ERC_PE);
//	} else {
//		ifp->if_flags &= ~IFF_ALLMULTI;
d1610 3
a1612 3
//		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL,
//		    bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle,
//		    BCW_RX_CTL) & ~ERC_PE);
d1615 8
a1622 8
//		if (ifp->if_flags & IFF_BROADCAST)
//			bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle,
//			    BCW_RX_CTL, bus_space_read_4(sc->bcw_btag,
//			    sc->bcw_bhandle, BCW_RX_CTL) & ~ERC_DB);
//		else
//			bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle,
//			    BCW_RX_CTL, bus_space_read_4(sc->bcw_btag,
//			    sc->bcw_bhandle, BCW_RX_CTL) | ERC_DB);
d1625 2
a1626 2
//		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_FILT_CTL,
//		    0);
d1629 1
a1629 1
//		bcw_add_mac(sc, sc->bcw_ac.ac_enaddr, 0);
d1632 4
a1635 4
//		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL,
//		bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle, BCW_RX_CTL) |
//		    ERC_AM);
//		ifp->if_flags |= IFF_ALLMULTI;
d1638 5
a1642 4
//		bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_FILT_CTL,
//		    bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle,
//		    BCW_FILT_CTL) | 1);
//	}
d1648 4
a1651 3
//        struct bcw_softc *sc = ic->ic_softc;
//	enum ieee80211_state ostate;
//	uint32_t tmp;
d1653 3
a1655 2
//	ostate = ic->ic_state;
	return 0;
d1670 1
a1670 1
	return 0;
d1678 1
a1678 1
//	uint32_t val;
d1689 1
a1689 1
//	val = CSR_READ_4(sc, IWI_CSR_CURRENT_TX_RATE);
d1691 1
a1691 1
//	rate = bcw_rate(val);
d1715 5
a1719 5
//	struct bcw_softc *sc = v;
//	http://bcm-specs.sipsolutions.net/PeriodicTasks
//	timeout_add(&sc->bcw_timeout, hz);


a1724 1
	
d1752 2
a1753 2
		return 1;
	} else {
a1754 1
	}
d1767 1
a1767 1
	} else {
a1768 1
	}
d1799 1
a1799 1
		//return 5;
d1805 1
a1805 1
		return 6;
d1812 1
a1812 1
		return 7;
d1815 1
a1815 1
	return 0;
@

