head	1.3;
access;
symbols
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	UBC_SYNC_A:1.3
	UBC_SYNC_B:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.3
date	99.07.30.13.43.36;	author d;	state dead;
branches;
next	1.2;

1.2
date	99.07.14.03.52.27;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.06.21.23.21.46;	author d;	state Exp;
branches;
next	;


desc
@@


1.3
log
@rename rl2->rln for sanity
@
text
@/*	$OpenBSD: rl2cmd.h,v 1.2 1999/07/14 03:52:27 d Exp $	*/
/*
 * David Leonard <d@@openbsd.org>, 1999. Public Domain.
 *
 * RangeLAN2 host-to-card message protocol.
 */

/* Micro-message command header. */
struct rl2_mm_cmd {
	u_int8_t	cmd_letter;	/* Command letter */
	u_int8_t	cmd_seq;	/* Incremented on each command */
#define RL2_MAXSEQ		0x7c
	u_int8_t	cmd_fn;		/* Function number */
	u_int8_t	cmd_error;	/* Reserved */
};
#define RL2_MM_CMD(l,n)		((((unsigned int)l)<<8) | ((unsigned int)n))
#define RL2_MM_CMD_LETTER(cmd)	((unsigned char)(((cmd) & 0xff00)>>8))
#define RL2_MM_CMD_FUNCTION(cmd) ((unsigned char)((cmd) & 0xff))
#define RL2_CMDCODE(letter, num) ((((letter) & 0xff) << 8) | ((num) & 0xff))

/* Initialise card, and set operational parameters. */
struct rl2_mm_init {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_INIT 			{ 'A', 0, 0, 0 }
	u_int8_t	enaddr[6];
	u_int8_t	opmode;
#define RL2_MM_INIT_OPMODE_NORMAL		0
#define RL2_MM_INIT_OPMODE_PROMISC		1
#define RL2_MM_INIT_OPMODE_PROTOCOL		2
	u_int8_t	stationtype;		/* RL2_STATIONTYPE_... */
	u_int8_t	hop_period;
	u_int8_t	bfreq;
	u_int8_t	sfreq;
	u_char		channel    : 4;		/* lower bits */
	u_char		subchannel : 4;		/* upper bits */
	char		mastername[11];
	u_char		sec1       : 4;		/* default 3 */
	u_char		domain     : 4;		/* default 0 */
	u_int8_t	sec2;			/* default 2 */
	u_int8_t	sec3;			/* default 1 */
	u_int8_t	sync_to;		/* 1 if roaming */
	u_int8_t	xxx_pad;		/* zero */
	char		syncname[11];
};

/* Result of initialisation. */
struct rl2_mm_initted {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_INITTED 			{ 'a', 0, 0, 0 }
	u_int8_t	xxx;
};

/* Start searching for other masters. */
struct rl2_mm_search {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_SEARCH			{ 'A', 0, 1, 0 }
	u_int8_t	xxx1[23];
	u_char		xxx2       : 4;
	u_char		domain     : 4;
	u_int8_t	roaming;
	u_int8_t	xxx3;			/* default 0 */
	u_int8_t	xxx4;			/* default 1 */
	u_int8_t	xxx5;			/* default 0 */
	u_int8_t	xxx6[11];
};

/* Notification that searching has started. */
struct rl2_mm_searching {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_SEARCHING		{ 'a', 0, 1, 0 }
	u_int8_t	xxx;
};

/* Terminate search. */
#define RL2_MM_ABORTSEARCH		{ 'A', 0, 3, 0 }

/* Station synchronised to a master. */
struct rl2_mm_synchronised {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_SYNCHRONISED		{ 'a', 0, 4, 0 }
	u_char		channel    : 4;		/* lower bits */
	u_char		subchannel : 4;		/* upper bits */
	char		mastername[11];
	u_int8_t	enaddr[6];
};

/* Station lost synchronisation with a master. */
#define RL2_MM_UNSYNCHRONISED		{ 'a', 0, 5, 0 }

/* Send card to sleep. (See rl2_wakeup().) */
struct rl2_mm_standby {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_STANDBY			{ 'A', 0, 6, 0 }
	u_int8_t	xxx;			/* default 0 */
};

/* Set ITO (inactivity timeout timer). */
struct rl2_mm_setito {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_SETITO			{ 'A', 0, 7, 0 }
	u_int8_t	xxx;			/* default 3 */
	u_int8_t	timeout;
	u_char		bd_wakeup : 1;
	u_char		pm_sync : 7;
	u_int8_t	sniff_time;
};

/* ITO acknowledgment */
#define RL2_MM_GOTITO			{ 'a', 0, 7, 0 }

/* Send keepalive protocol message (?). */
#define RL2_MM_SENDKEEPALIVE		{ 'A', 0, 8, 0 }

/* Set multicast mode. */
struct rl2_mm_multicast {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_MULTICAST		{ 'A', 0, 9, 0 }
	u_int8_t	enable;
};

/* Ack multicast mode change. */
#define RL2_MM_MULTICASTING		{ 'a', 0, 9, 0 }

/* Request statistics. */
#define RL2_MM_GETSTATS			{ 'A', 0, 11, 0 }

/* Statistics results. */
#define RL2_MM_GOTSTATS			{ 'a', 0, 11, 0 }

/* Set security ID used in channel. */
struct rl2_mm_setsecurity {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_SETSECURITY		{ 'A', 0, 12, 0 }
	u_int8_t	sec1;
	u_int8_t	sec2;
	u_int8_t	sec3;
};

/* Ack set security ID. */
#define RL2_MM_GOTSECURITY		{ 'a', 0, 12, 0 }

/* Request firmware version. */
#define RL2_MM_GETPROMVERSION		{ 'A', 0, 13, 0 }

/* Reply with firmware version. */
struct rl2_mm_gotpromversion {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_GOTPROMVERSION		{ 'a', 0, 13, 0 }
	u_int8_t	xxx;			/* sizeof version? */
	char		version[7];
};

/* Request station's MAC address (same as ethernet). */
#define RL2_MM_GETENADDR		{ 'A', 0, 14, 0 }

/* Reply with station's MAC address. */
struct rl2_mm_gotenaddr {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_GOTENADDR		{ 'a', 0, 14, 0 }
	u_int8_t	xxx;
	u_int8_t	enaddr[6];
};

/* Tune various channel parameters. */
struct rl2_mm_setmagic {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_SETMAGIC			{ 'A', 0, 16, 0 }
	u_char		fairness_slot : 3;
	u_char		deferral_slot : 5;
	u_int8_t	regular_mac_retry;	/* default 0x07 */
	u_int8_t	frag_mac_retry;		/* default 0x0a */
	u_int8_t	regular_mac_qfsk;	/* default 0x02 */
	u_int8_t	frag_mac_qfsk;		/* default 0x05 */
	u_int8_t	xxx1;			/* default 0xff */
	u_int8_t	xxx2;			/* default 0xff */
	u_int8_t	xxx3;			/* default 0xff */
	u_int8_t	xxx4;			/* zero */
};

/* Ack channel tuning. */
#define RL2_MM_GOTMAGIC			{ 'a', 0, 16, 0 }

/* Set roaming parameters - used when multiple masters available. */
struct rl2_mm_setroaming {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_SETROAMING		{ 'A', 0, 17, 0 }
	u_int8_t	sync_alarm;
	u_int8_t	retry_thresh;
	u_int8_t	rssi_threshold;
	u_int8_t	xxx1;			/* default 0x5a */
	u_int8_t	sync_rssi_threshold;
	u_int8_t	xxx2;			/* default 0xa5 */
	u_int8_t	missed_sync;
};

/* Ack roaming parameter change. */
#define RL2_MM_GOTROAMING		{ 'a', 0, 17, 0 }

#define RL2_MM_ROAMING			{ 'a', 0, 18, 0 }
#define RL2_MM_ROAM			{ 'A', 0, 19, 0 }

/* Hardware fault notification. (Usually the antenna.) */
#define RL2_MM_FAULT			{ 'a', 0, 20, 0 }

#define RL2_MM_EEPROM_PROTECT		{ 'A', 0, 23, 0 }
#define RL2_MM_EEPROM_PROTECTED		{ 'a', 0, 23, 0 }
#define RL2_MM_EEPROM_UNPROTECT		{ 'A', 0, 24, 0 }
#define RL2_MM_EEPROM_UNPROTECTED	{ 'a', 0, 24, 0 }

/* Receive hop statistics. */
#define RL2_MM_HOP_STATISTICS		{ 'a', 0, 35, 0 }

/* Transmit a frame on the channel. */
struct rl2_mm_sendpacket {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_SENDPACKET		{ 'B', 0, 0, 0 }
	u_int8_t	mode;
#define RL2_MM_SENDPACKET_MODE_BIT7	0x80
#define RL2_MM_SENDPACKET_MODE_ZFIRST	0x20
#define RL2_MM_SENDPACKET_MODE_QFSK	0x03
	u_int8_t	power;			/* default 0x70 */
	u_int8_t	length_lo;
	u_int8_t	length_hi;
	u_int8_t	xxx1;			/* default 0 */
	u_int8_t	xxx2;			/* default 0 */
	u_int8_t	sequence;		/* must increment */
	u_int8_t	xxx3;			/* default 0 */
};

/* Ack packet transmission. */
#define RL2_MM_SENTPACKET		{ 'b', 0, 0, 0 }

/* Notification of frame received from channel. */
struct rl2_mm_recvpacket {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_RECVPACKET		{ 'b', 0, 1, 0 }
	u_int8_t	xxx[8];
};

/* Disable hopping. (?) */
struct rl2_mm_disablehopping {
	struct		rl2_mm_cmd mm_cmd;
#define RL2_MM_DISABLEHOPPING		{ 'C', 0, 9, 0 }
	u_int8_t	hopflag;
#define RL2_MM_DISABLEHOPPING_HOPFLAG_DISABLE	0x52
};

@


1.2
log
@KNF, cleanup, saner names
@
text
@d1 1
a1 1
/*	$OpenBSD: rl2cmd.h,v 1.1 1999/06/21 23:21:46 d Exp $	*/
@


1.1
log
@RangeLAN2 wireless network card
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
a8 4
/*
 * Micro-message commands
 */

d10 5
a14 4
	u_int8_t cmd_letter;		/* command letter */
	u_int8_t cmd_seq;		/* must increment, <0x80 */
	u_int8_t cmd_fn;		/* function number */
	u_int8_t cmd_error;		/* reserved */
a15 1

a18 31

#if 0
  /* A: Initialisation commands */
	RL2_MM_INITIALIZE = 0,			/* A0   a0  */ /* [3]>0 */
	RL2_MM_SEARCH_AND_SYNC,			/* A1   a1- */
	RL2_MM_SEARCH_CONTINUE,			/* A2   a2. */
	RL2_MM_ABORT_SEARCH,			/* A3   a3. */
	RL2_MM_SYNCHRONISED,			/*      a4  */ /*HandleInSync*/
	RL2_MM_UNSYNCHRONISED,			/* A5       */
	RL2_MM_GOTO_STANDBY,			/* A6       */	/* stop() */
	RL2_MM_ITO,				/* A7   a7. */
	RL2_MM_KEEPALIVE,			/* A8   a8. */
	RL2_MM_MULTICAST,			/* A9   a9. */
	RL2_MM_RFNC_STATS,			/* A11  a11.*/
	RL2_MM_SECURITY,			/* A12  a12.*/
	RL2_MM_ROM_VERSION,			/* A13  a13 */
	RL2_MM_GLOBAL_ADDR,			/* A14  a14 */
	RL2_MM_CONFIGMAC,			/* A16  a16.*/
	RL2_MM_ROAMPARAM,			/* A17  a17.*/
	RL2_MM_ROAMING,				/*      a18 */ /* LLDRoam */
	RL2_MM_ROAM,				/* A19  a19 */
	RL2_MM_FAULT,				/*      a20 */ /* beep,reset */
	RL2_MM_SNIFF_MODE,			/* A22      */
	RL2_MM_DISABLE_EEPROM_WRITE,		/* A23  a23.*/
	RL2_MM_ENABLE_EEPROMP_WRITE,		/* A24  a24.*/
	RL2_MM_HOPSTATS,			/* A35  a35 */
  /* B: Data commands */
  /* C: Diagnostic commands */
	RL2_MM_DISABLE_HOPPING,			/* C9       */
#endif

d21 30
a50 35
#define u_int4_t u_int8_t

struct rl2_mm_setparam {
	struct rl2_mm_cmd mm_cmd;
#define RL2_MM_SETPARAM 		{ 'A', 0, 0, 0 }
#define RL2_MM_SETPARAM_CODE		RL2_CMDCODE('A',0)
	u_int8_t enaddr[6];
	u_int8_t opmode;
#define RL2_MM_SETPARAM_OPMODE_NORMAL		0
#define RL2_MM_SETPARAM_OPMODE_PROMISC		1
#define RL2_MM_SETPARAM_OPMODE_PROTOCOL		2
	u_int8_t stationtype;
#define RL2_MM_SETPARAM_STATIONTYPE_SLAVE	RL2_STATIONTYPE_SLAVE
#define RL2_MM_SETPARAM_STATIONTYPE_ALTMASTER	RL2_STATIONTYPE_ALTMASTER
#define RL2_MM_SETPARAM_STATIONTYPE_MASTER	RL2_STATIONTYPE_MASTER
	u_int8_t hop_period;
	u_int8_t bfreq;
	u_int8_t sfreq;
	u_int4_t channel    : 4;	/* lower bits */
	u_int4_t subchannel : 4;	/* upper bits */
	char     mastername[11];
	u_int4_t sec1       : 4;	/* default 3 */
	u_int4_t domain     : 4;	/* default 0 */
	u_int8_t sec2;			/* default 2 */
	u_int8_t sec3;			/* default 1 */
	u_int8_t sync_to;		/* 1 if roaming */
	u_int8_t xxx_pad;		/* zero */
	char     syncname[11];
};

struct rl2_mm_paramset {
	struct rl2_mm_cmd mm_cmd;
#define RL2_MM_PARAMSET 		{ 'a', 0, 0, 0 }
#define RL2_MM_PARAMSET_CODE		RL2_CMDCODE('a',0)
	u_int8_t xxx;
d53 1
d55 1
a55 1
	struct rl2_mm_cmd mm_cmd;
d57 8
a64 9
#define RL2_MM_SEARCH_CODE		RL2_CMDCODE('A',1)
	u_int8_t xxx1[23];
	u_int4_t xxx2       : 4;
	u_int4_t domain     : 4;
	u_int8_t roaming;
	u_int8_t xxx3;			/* default 0 */
	u_int8_t xxx4;			/* default 1 */
	u_int8_t xxx5;			/* default 0 */
	u_int8_t xxx6[11];
d67 1
d69 1
a69 1
	struct rl2_mm_cmd mm_cmd;
d71 1
a71 2
#define RL2_MM_SEARCHING_CODE		RL2_CMDCODE('a',1)
	u_int8_t xxx;
d74 1
a75 1
#define RL2_MM_ABORTSEARCH_CODE		RL2_CMDCODE('A',3)
d77 1
d79 1
a79 1
	struct rl2_mm_cmd mm_cmd;
d81 4
a84 5
#define RL2_MM_SYNCHRONISED_CODE	RL2_CMDCODE('a',4)
	u_int4_t channel    : 4;	/* lower bits */
	u_int4_t subchannel : 4;	/* upper bits */
	char	 mastername[11];
	u_int8_t enaddr[6];
d87 1
a88 1
#define RL2_MM_UNSYNCHRONISED_CODE	RL2_CMDCODE('a',5)
d90 1
d92 1
a92 1
	struct rl2_mm_cmd mm_cmd;
d94 1
a94 1
	u_int8_t xxx;			/* default 0 */
d97 1
d99 1
a99 1
	struct rl2_mm_cmd mm_cmd;
d101 5
a105 5
	u_int8_t xxx;			/* default 3 */
	u_int8_t timeout;
	unsigned int bd_wakeup : 1;
	unsigned int pm_sync : 7;
	u_int8_t sniff_time;
d108 1
d111 1
d114 1
d116 1
a116 1
	struct rl2_mm_cmd mm_cmd;
d118 1
a118 1
	u_int8_t enable;
d121 1
d124 1
d126 2
d130 1
d132 1
a132 1
	struct rl2_mm_cmd mm_cmd;
d134 3
a136 3
	u_int8_t sec1;
	u_int8_t sec2;
	u_int8_t sec3;
d139 1
d142 1
d145 1
d147 1
a147 1
	struct rl2_mm_cmd mm_cmd;
d149 2
a150 2
	u_int8_t xxx;
	char	 version[7];
d153 1
d156 1
d158 1
a158 1
	struct rl2_mm_cmd mm_cmd;
d160 2
a161 2
	u_int8_t xxx;
	u_int8_t enaddr[6];
d164 1
d166 1
a166 1
	struct rl2_mm_cmd mm_cmd;
d168 10
a177 10
	u_char   fairness_slot : 3;
	u_char   deferral_slot : 5;
	u_int8_t regular_mac_retry;	/* default 0x07 */
	u_int8_t frag_mac_retry;	/* default 0x0a */
	u_int8_t regular_mac_qfsk;	/* default 0x02 */
	u_int8_t frag_mac_qfsk;		/* default 0x05 */
	u_int8_t xxx1;			/* default 0xff */
	u_int8_t xxx2;			/* default 0xff */
	u_int8_t xxx3;			/* default 0xff */
	u_int8_t xxx4;			/* zero */
d180 1
d183 1
d185 1
a185 1
	struct rl2_mm_cmd mm_cmd;
d187 7
a193 7
	u_int8_t sync_alarm;
	u_int8_t retry_thresh;
	u_int8_t rssi_threshold;
	u_int8_t xxx1;			/* default 0x5a */
	u_int8_t sync_rssi_threshold;
	u_int8_t xxx2;			/* default 0xa5 */
	u_int8_t missed_sync;
d196 1
d201 2
d204 1
a204 1
#define RL2_MM_FAULT_CODE		RL2_CMDCODE('a',20)
d209 2
d213 1
d215 1
a215 1
	struct rl2_mm_cmd mm_cmd;
d217 1
a217 1
	u_int8_t mode;
d221 7
a227 7
	u_int8_t power;			/* default 0x70 */
	u_int8_t length_lo;
	u_int8_t length_hi;
	u_int8_t xxx1;			/* default 0 */
	u_int8_t xxx2;			/* default 0 */
	u_int8_t sequence;		/* must increment */
	u_int8_t xxx3;			/* default 0 */
d230 1
d233 1
d235 1
a235 1
	struct rl2_mm_cmd mm_cmd;
d237 1
a237 1
	u_int8_t xxx[8];
d240 1
d242 1
a242 1
	struct rl2_mm_cmd mm_cmd;
d244 1
a244 1
	u_int8_t hopflag;
a246 10

/* queue */
struct rl2_rx {
        SIMPLEQ_ENTRY(rl2_rx)   rx_entry;
        size_t                  rx_size;
        struct rl2_mm_cmd       rx_hdr;
        u_int8_t                rx_data[1];
};

#define RL2_MAX_RX_QUEUE_LEN		16
@

