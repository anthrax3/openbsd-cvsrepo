head	1.13;
access;
symbols
	OPENBSD_4_5:1.12.0.22
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.20
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.18
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.16
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.14
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.12
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.24
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.22
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.20
	OPENBSD_2_8:1.9.0.18
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.16
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.14
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.12
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.10
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.8
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.13
date	2009.04.15.06.54.44;	author oga;	state dead;
branches;
next	1.12;

1.12
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.03.20.22.03.05;	author chuck;	state Exp;
branches
	1.9.14.1
	1.9.24.1;
next	1.8;

1.8
date	96.07.16.22.08.16;	author chuck;	state Exp;
branches;
next	1.7;

1.7
date	96.07.11.22.47.07;	author chuck;	state Exp;
branches;
next	1.6;

1.6
date	96.07.03.17.21.18;	author chuck;	state Exp;
branches;
next	1.5;

1.5
date	96.06.29.23.22.35;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	96.06.29.19.59.39;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	96.06.27.04.27.48;	author chuck;	state Exp;
branches;
next	1.2;

1.2
date	96.06.21.21.36.33;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	96.06.21.15.27.20;	author chuck;	state Exp;
branches;
next	;

1.9.14.1
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.9.14.2;

1.9.14.2
date	2004.02.19.10.56.19;	author niklas;	state Exp;
branches;
next	;

1.9.24.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove en(4) (no manpage present, no none removed), and the midway.c glue code
for it.

It is very unlikely this still compiles, the hardware is dead. It isn't in any
arch's config file. the sparc sbus code is even commented out in files.sparc.

Not to mention that the code is fucking appauling, doesn't even know that sparc
got bus.h ages ago, still uses vtophys(), defines all types of functions to
arch-specific hacks.

I will miss the bitchy comments, though...

As a note to other drivers: this is the fate that awaits you if you screw up my
ctags on commonly used functions.

"you have my ok" claudio@@, "zap zap zap" deraadt@@

If i've missed any bits, please remove them.
@
text
@/*	$OpenBSD: midwayvar.h,v 1.12 2003/10/21 18:58:49 jmc Exp $	*/

/*
 *
 * Copyright (c) 1996 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *	Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * m i d w a y v a r . h
 *
 * we define the en_softc here so that bus specific modules can allocate
 * it as the first item in their softc.   note that BSD-required 
 * "struct device" is in the mid_softc!
 *
 * author: Chuck Cranor <chuck@@ccrc.wustl.edu>
 */

/*
 * params needed to determine softc size
 */

#ifndef EN_NTX
#define EN_NTX          8       /* number of tx bufs to use */
#endif
#ifndef EN_TXSZ
#define EN_TXSZ         32      /* transmit buf size in KB */
#endif
#ifndef EN_RXSZ
#define EN_RXSZ         32      /* recv buf size in KB */
#endif
#define EN_MAXNRX       ((2048-(EN_NTX*EN_TXSZ))/EN_RXSZ)
				/* largest possible NRX (depends on RAM size) */


#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__bsdi__)
#define EN_INTR_TYPE int
#define EN_INTR_RET(X) return(X)
#if defined(__NetBSD__) || defined(__OpenBSD__)
#define EN_IOCTL_CMDT u_long
#elif defined(__bsdi__)
#define EN_IOCTL_CMDT int
#endif

#elif defined(__FreeBSD__)

#define EN_INTR_TYPE void
#define EN_INTR_RET(X) return
#define EN_IOCTL_CMDT int

struct device {
  char dv_xname[IFNAMSIZ];
};

#define DV_IFNET 1

struct cfdriver {
  int zero;
  char *name;
  int one;
  int cd_ndevs;
  void *cd_devs[NEN];
};

#endif


/*
 * softc
 */

struct en_softc {
  /* bsd glue */
  struct device sc_dev;		/* system device */
  struct ifnet enif;		/* network ifnet handle */

  /* bus glue */
  bus_space_tag_t en_memt;	/* for EN_READ/EN_WRITE */
  bus_space_handle_t en_base;	/* base of en card */
  bus_size_t en_obmemsz;	/* size of en card (bytes) */
  void (*en_busreset)(void *);	/* bus specific reset function */

  /* serv list */
  u_int32_t hwslistp;		/* hw pointer to service list (byte offset) */
  u_int16_t swslist[MID_SL_N];	/* software service list (see en_service()) */
  u_int16_t swsl_head, 		/* ends of swslist (index into swslist) */
	    swsl_tail;
  u_int32_t swsl_size;		/* # of items in swsl */
  

  /* xmit dma */
  u_int32_t dtq[MID_DTQ_N];	/* sw copy of dma q (see ENIDQ macros) */
  u_int32_t dtq_free;		/* # of dtq's free */
  u_int32_t dtq_us;		/* software copy of our pointer (byte offset) */
  u_int32_t dtq_chip;		/* chip's pointer (byte offset) */
  u_int32_t need_dtqs;		/* true if we ran out of DTQs */

  /* recv dma */
  u_int32_t drq[MID_DRQ_N];	/* sw copy of dma q (see ENIDQ macros) */
  u_int32_t drq_free;		/* # of drq's free */
  u_int32_t drq_us;		/* software copy of our pointer (byte offset) */
  u_int32_t drq_chip;		/* chip's pointer (byte offset) */
  u_int32_t need_drqs;		/* true if we ran out of DRQs */

  /* xmit buf ctrl. (per channel) */
  struct {
    u_int32_t mbsize;		/* # mbuf bytes we are using (max=TXHIWAT) */
    u_int32_t bfree;		/* # free bytes in buffer (not dma or xmit) */
    u_int32_t start, stop;	/* ends of buffer area (byte offset) */
    u_int32_t cur;		/* next free area (byte offset) */
    u_int32_t nref;		/* # of VCs using this channel */
    struct ifqueue indma;	/* mbufs being dma'd now */
    struct ifqueue q;		/* mbufs waiting for dma now */
  } txslot[MID_NTX_CH];

  /* xmit vc ctrl. (per vc) */
  u_int8_t txspeed[MID_N_VC];	/* speed of tx on a VC */
  u_int8_t txvc2slot[MID_N_VC]; /* map VC to slot */

  /* recv vc ctrl. (per vc).   maps VC number to recv slot */
  u_int16_t rxvc2slot[MID_N_VC];
  int en_nrx;			/* # of active rx slots */

  /* recv buf ctrl. (per recv slot) */
  struct {
    void *rxhand;		/* recv. handle if doing direct delivery */
    u_int32_t mode;		/* saved copy of mode info */
    u_int32_t start, stop;	/* ends of my buffer area */
    u_int32_t cur;		/* where I am at */
    u_int16_t atm_vci;		/* backpointer to VCI */
    u_int8_t atm_flags;		/* copy of atm_flags from atm_ph */
    u_int8_t oth_flags;		/* other flags */
    u_int32_t raw_threshold;	/* for raw mode */
    struct ifqueue indma;	/* mbufs being dma'd now */
    struct ifqueue q;		/* mbufs waiting for dma now */
  } rxslot[EN_MAXNRX];		/* recv info */

  /* stats */
  u_int32_t vtrash;		/* sw copy of counter */
  u_int32_t otrash;		/* sw copy of counter */
  u_int32_t ttrash;		/* # of RBD's with T bit set */
  u_int32_t mfix;		/* # of times we had to call mfix */
  u_int32_t mfixfail;		/* # of times mfix failed */
  u_int32_t headbyte;		/* # of times we used BYTE DMA at front */
  u_int32_t tailbyte;		/* # of times we used BYTE DMA at end */
  u_int32_t tailflush;		/* # of times we had to FLUSH out DMA bytes */
  u_int32_t txmbovr;		/* # of times we dropped due to mbsize */
  u_int32_t dmaovr;		/* tx dma overflow count */
  u_int32_t txoutspace;		/* out of space in xmit buffer */
  u_int32_t txdtqout;		/* out of DTQs */
  u_int32_t launch;		/* total # of launches */
  u_int32_t lheader;		/* # of launches without OB header */
  u_int32_t ltail;		/* # of launches without OB tail */
  u_int32_t hwpull;		/* # of pulls off hardware service list */
  u_int32_t swadd;		/* # of pushes on sw service list */
  u_int32_t rxqnotus;		/* # of times we pull from rx q, but fail */
  u_int32_t rxqus;		/* # of good pulls from rx q */
  u_int32_t rxoutboth;		/* # of times out of mbufs and DRQs */
  u_int32_t rxdrqout;		/* # of times out of DRQs */
  u_int32_t rxmbufout;		/* # of time out of mbufs */

  /* random stuff */
  u_int32_t ipl;		/* sbus interrupt lvl (1 on pci?) */
  u_int8_t bestburstcode;	/* code of best burst we can use */
  u_int8_t bestburstlen;	/* length of best burst (bytes) */
  u_int8_t bestburstshift;	/* (x >> shift) == (x / bestburstlen) */
  u_int8_t bestburstmask;	/* bits to check if not multiple of burst */
  u_int8_t alburst;		/* align dma bursts? */
  u_int8_t is_adaptec;		/* adaptec version of midway? */
};

/*
 * exported functions
 */

void	en_attach(struct en_softc *);
EN_INTR_TYPE	en_intr(void *);
void	en_reset(struct en_softc *);
@


1.12
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.11 2002/03/15 01:20:04 millert Exp $	*/
@


1.11
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.10 2002/03/14 01:26:54 millert Exp $	*/
d53 1
a53 1
#define EN_TXSZ         32      /* trasmit buf size in KB */
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.9 1997/03/20 22:03:05 chuck Exp $	*/
d107 1
a107 2
  void (*en_busreset)(void *);
				/* bus specific reset function */
@


1.9
log
@MAJOR CHANGES: [contributed by Chuck Cranor <chuck@@ccrc.wustl.edu> and
                Anne Hutton <hutton@@isi.edu>]:
   - add support for Adaptec 155 PCI ATM cards (e.g. ANA-5940)
          - add sc->is_adaptec to handle differences between cards.
          - break out MID_MK_TXQ/MID_MK_RXQ seperate macros to handle
                  the new Adaptec format TXQ/RXQ.
          - adjust en_dqneed to return 1 on ADP (since the Adaptec can
                  DMA anything in one DRQ/DTQ!)
          - add hook for a bus specific reset function (adaptec has
                  a seperate reset register that needs to be hit when
                  resettting the midway).
          - adjust DMA test to not worry about burst sizes on the
                  adaptec (since it handles it all for us!) and to handle
                  the new DTQ/DRQ format.
          - add Adaptec DMA support to en_txlaunch() and en_service()


BUG FIXES:
   - fixed receiver panic under heavy load ("lost mbuf in slot 0!").
          when the reassembly buffer overflows, the T-bit is set in
          the RDB and the data field is empty.  en_service() sets up
          a 4-byte (RDB size) dummy DMA without IF_ENQUEUE.  but the
          recv intr handling in en_intr() always does IF_DEQUEUE.
          as a result, a successive recv intr loses its mbuf and
          leads to a panic.  the solution is to only IF_DEQUEUE if
          the interrupt has non-zero length (indicating that there
          is an mbuf to get).   in order for this to work, EN_DQ_MK
          must always be non-zero.   we do this by or'ing in an unused
          bit (0x80000).
                  reported by: Kenjiro Cho <kjc@@csl.sony.co.jp>

   - fix setting of transmit channel when txspeed[] is non-zero
          (e.g. traffic shaping).    the old scheme didn't work
          properly (it allowed the same VCI to use multiple tx channels
          thus defeating the txspeed[] parameter).   the new scheme
          statically assigns a VC to a channel when txspeed[] is set.
          [note that the code to set txspeed[] isn't in the driver right
          now since a MI interface to do this hasn't been made yet]
          we add sc->txvc2slot[] and sc->txslot[n].nref for this.
                  reported by: Kenjiro Cho <kjc@@csl.sony.co.jp>,
                                  Milind M Buddihikot <milind@@ccrc.wustl.edu>,
                                  Dong Lin <dong@@eecs.harvard.edu>

    - if aal5 frame has a CRC error then the length field in the aal5 trailer
          may not be valid, so we can not use it [and we must dump the frame]
                  contributed by: Yuhang Sun <sunyh@@dworkin.wustl.edu> & chuck

   - when doing SRAM copies, be sure to round up the length to the next
          largest word (otherwise the driver will try to do a byte clean
          up DMA and then get an ID error interrupt).


MINOR CLEANUPS:
   - add some extra support for a few more versions of FreeBSD
                  contributed by: Kenjiro Cho <kjc@@csl.sony.co.jp>

   - clean up loops in DMA test
                  contributed by: Kenjiro Cho <kjc@@csl.sony.co.jp>

   - restructure and cleanup of en_read/en_write macros/inlines

   - clean up some byte ordering stuff so that we are consistant throughout
          the driver
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.10 1997/03/20 21:34:46 chuck Exp $	*/
d107 1
a107 1
  void (*en_busreset) __P((void *));
d203 3
a205 3
void	en_attach __P((struct en_softc *));
EN_INTR_TYPE	en_intr __P((void *));
void	en_reset __P((struct en_softc *));
@


1.9.24.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.9 1997/03/20 22:03:05 chuck Exp $	*/
d107 2
a108 1
  void (*en_busreset)(void *);	/* bus specific reset function */
d203 3
a205 3
void	en_attach(struct en_softc *);
EN_INTR_TYPE	en_intr(void *);
void	en_reset(struct en_softc *);
@


1.9.14.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 2
a108 1
  void (*en_busreset)(void *);	/* bus specific reset function */
d203 3
a205 3
void	en_attach(struct en_softc *);
EN_INTR_TYPE	en_intr(void *);
void	en_reset(struct en_softc *);
@


1.9.14.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d53 1
a53 1
#define EN_TXSZ         32      /* transmit buf size in KB */
@


1.8
log
@midway fixes + new stuff:
 - alpha changes from cgd

 - merged multiple DRQ/DTQ ADD macros into a single DRQ and a single DTQ
   macro with a uniform interface to make the code simpler and easier to read.

 - en_start: only update atm_flags if EN_MBUF_OPT is enabled (which it
	should be)

 - for alburst: make sure we don't DMA more bytes than we need (on both
	tx and rx).   if the alburst is larger than we need, drop to
	MIDDMA_WORD mode.

 - major change: enable the use of byte and 2 byte DMA on the trasmit side.
   this allows us to DMA from non-word sized/aligned mbufs directly.
   [the old code would always call en_mfix which would copy (or move) the
    data in order to ensure proper alignment...   it turns out TCP gives
    us non-word sized/aligned mbufs when it is retransmitting, so we needed
    to handle this case more efficiently.]    the following functions
   were changed to make this work:
    - en_dqneed: add an arg to let us know if we are transmitting or not.
	if we are TX, then we must take into account byte DMAs when
	estimating the number of DTQs we will need for a buffer
    - en_start: only mfix mbufs if DMA is disabled
    - en_txdma: only set launch.nodma if we have en_mfix'd the mbuf chain
	also, we may need a DTQ to flush the chip's internal byte buffer
    - en_txlaunch: only attempt a copy if we have the proper alignment.
	add byte dma code for the front and end of the buffer.
	make sure the internal dma buffer is flushed out.
    - en_dump: keep track of how many times we have to use byte sized DMA

midwayreg:
 - add byte/2byte DMA defines

midwayvar:
 - add new stat counter to monitor less-than-word lengthed DMA
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.6 1996/07/11 22:48:13 chuck Exp $	*/
d104 5
a108 3
  bus_chipset_tag_t en_bc;	/* for EN_READ/EN_WRITE */
  bus_mem_handle_t en_base;	/* base of en card */
  bus_mem_size_t en_obmemsz;	/* size of en card (bytes) */
d138 1
d145 1
d196 1
@


1.7
log
@fix:
  - en_mfix shouldn't touch M_EXT mbufs.    change to avoid this [at
    the expense of allocating a new cluster mbuf to copy to].

    XXX: en_mfix is getting called more often than I hoped it would
    (seems to happen when TCP retransmits... we get all sorts of odd
    sized, odd lengthed data mbufs, yuck).    i may revise the xmit
    DMA code to use non-word sized dma.
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.5 1996/07/03 17:22:02 chuck Exp $	*/
d167 3
@


1.6
log
@ported to FreeBSD 2.2-960612-SNAP.
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.4 1996/06/29 23:23:37 chuck Exp $	*/
d166 1
@


1.5
log
@new: add a raw_threshold for raw mode.   this basically tells the driver
	to ignore inbound data sizes less than the threshold.  otherwise,
	when connected to a video aal0 input the driver gives us a massive
	stream of 56 byte mbufs each with one aal0 cell in it and the
	system just can't keep up with it, especially if the socket buffer
	size is large [it hangs until you turn off the video source].

fixes: when turning off a vc, try and check the freshest copy of the mode
	when seeing if we need to enter the "drain" state.   also, don't
	panic if we get unexpected rx interrupt on a VCI (instead make sure
	the VC is off, print a warning, and move on!).
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.3 1996/06/29 20:00:44 chuck Exp $	*/
d61 33
d195 2
a196 1
int	en_intr __P((void *));
@


1.4
log
@change:
 - change rxso into a void handle ... no need to know details at this low
	level.
fix:
 - forgot to init "vci" during ENOTHER_DRAIN case of RX DMA interrupt
	[could cause a vm_fault on native mode connection close depending
	on needing to drain out the VC and also the random value of vci]
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.2 1996/06/27 04:29:45 chuck Exp $	*/
d123 1
@


1.3
log
@fixes/improvements:
 - more stat counters (rxmbufout -- mbufs, ttrash -- trashed RBD)
 - add swsl_size to keep track of size of software slist
 - revise when we call en_service
 - fix handling of circular lists (was getting full vs empty confused in
	extreem cases...)
 - native mode atm: remove sbappend code: can't do it here since
	socket buffer is protected only by splsoftnet and that doesn't
	mask enintr off.    forces us to switch to a two level interrupt
	scheme.    revise call to atm_input to reflect that.
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayvar.h,v 1.1 1996/06/22 01:50:59 chuck Exp $	*/
d116 1
a116 1
    struct socket *rxso;	/* socket if using direct delivery */
@


1.2
log
@use correct copyright
@
text
@d1 1
a1 2
/*	$OpenBSD: midwayvar.h,v 1.1 1996/06/21 15:27:20 chuck Exp $	*/
/*	(sync'd to midwayvar.h 1.4)	*/
d80 1
d130 1
a133 1
  u_int32_t ddrop;		/* # of direct deposit drops due to sbsize */
d145 1
@


1.1
log
@device driver from the Efficient Networks "MIDWAY" ATM155 chip.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	(sync'd to midwayvar.h 1.3)	*/
d6 1
a6 1
 * Copyright (c) 1996 Charles D. Cranor
d19 2
a20 1
 *      This product includes software developed by Charles D. Cranor.
@
