head	1.25;
access;
symbols
	OPENBSD_5_7:1.24.0.18
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.22
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.20
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.16
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.14
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.10
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.12
	OPENBSD_5_0:1.24.0.8
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.6
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.20
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.18
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.16
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.14
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.12
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.10
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.8
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.6
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.4
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.4
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.18
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2015.06.19.11.12.24;	author jmatthew;	state dead;
branches;
next	1.24;
commitid	I5HMIEQiHPSVn0jd;

1.24
date	2010.02.18.10.40.53;	author sobrado;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.02.03.17.22;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.27.00.46.09;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.03.18.38.10;	author mjacob;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.17.17.41.26;	author mjacob;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.17.01.34.58;	author mjacob;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.14.00.20.55;	author mjacob;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.10.06.22.45.52;	author mjacob;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.01.07.16.40;	author mjacob;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.04.22.09.16;	author mjacob;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.12.23.48.29;	author mjacob;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.09.03.28.12;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.16.01.02.01;	author mjacob;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.06.05.31.49;	author mjacob;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.20.21.22.41;	author mjacob;	state Exp;
branches;
next	1.7;

1.7
date	99.11.22.12.50.53;	author mjacob;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.04.04.02.04.40;	author mjacob;	state Exp;
branches;
next	1.5;

1.5
date	99.04.04.01.33.13;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	99.03.25.22.58.38;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	99.03.17.12.54.32;	author mjacob;	state Exp;
branches;
next	1.2;

1.2
date	99.03.17.05.26.09;	author mjacob;	state Exp;
branches;
next	1.1;

1.1
date	98.03.24.03.26.10;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2000.02.21.22.29.05;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.05.14.22.23.57;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.05.19.21.54.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@remove isp(4) now that the ql* family have replaced it
@
text
@/*     $OpenBSD: ispmbox.h,v 1.24 2010/02/18 10:40:53 sobrado Exp $ */
/* $FreeBSD: src/sys/dev/isp/ispmbox.h,v 1.59 2007/03/10 02:39:54 mjacob Exp $ */
/*-
 *  Copyright (c) 1997-2007 by Matthew Jacob
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 * 
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 *  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 */
/*
 * Mailbox and Queue Entry Definitions for for QLogic ISP SCSI adapters.
 */
#ifndef	_ISPMBOX_H
#define	_ISPMBOX_H

/*
 * Mailbox Command Opcodes
 */
#define MBOX_NO_OP			0x0000
#define MBOX_LOAD_RAM			0x0001
#define MBOX_EXEC_FIRMWARE		0x0002
#define MBOX_DUMP_RAM			0x0003
#define MBOX_WRITE_RAM_WORD		0x0004
#define MBOX_READ_RAM_WORD		0x0005
#define MBOX_MAILBOX_REG_TEST		0x0006
#define MBOX_VERIFY_CHECKSUM		0x0007
#define MBOX_ABOUT_FIRMWARE		0x0008
#define	MBOX_LOAD_RISC_RAM_2100		0x0009
					/*   a */
#define	MBOX_LOAD_RISC_RAM		0x000b
					/*   c */
#define MBOX_WRITE_RAM_WORD_EXTENDED	0x000d
#define MBOX_CHECK_FIRMWARE		0x000e
#define	MBOX_READ_RAM_WORD_EXTENDED	0x000f
#define MBOX_INIT_REQ_QUEUE		0x0010
#define MBOX_INIT_RES_QUEUE		0x0011
#define MBOX_EXECUTE_IOCB		0x0012
#define MBOX_WAKE_UP			0x0013
#define MBOX_STOP_FIRMWARE		0x0014
#define MBOX_ABORT			0x0015
#define MBOX_ABORT_DEVICE		0x0016
#define MBOX_ABORT_TARGET		0x0017
#define MBOX_BUS_RESET			0x0018
#define MBOX_STOP_QUEUE			0x0019
#define MBOX_START_QUEUE		0x001a
#define MBOX_SINGLE_STEP_QUEUE		0x001b
#define MBOX_ABORT_QUEUE		0x001c
#define MBOX_GET_DEV_QUEUE_STATUS	0x001d
					/*  1e */
#define MBOX_GET_FIRMWARE_STATUS	0x001f
#define MBOX_GET_INIT_SCSI_ID		0x0020
#define MBOX_GET_SELECT_TIMEOUT		0x0021
#define MBOX_GET_RETRY_COUNT		0x0022
#define MBOX_GET_TAG_AGE_LIMIT		0x0023
#define MBOX_GET_CLOCK_RATE		0x0024
#define MBOX_GET_ACT_NEG_STATE		0x0025
#define MBOX_GET_ASYNC_DATA_SETUP_TIME	0x0026
#define MBOX_GET_SBUS_PARAMS		0x0027
#define		MBOX_GET_PCI_PARAMS	MBOX_GET_SBUS_PARAMS
#define MBOX_GET_TARGET_PARAMS		0x0028
#define MBOX_GET_DEV_QUEUE_PARAMS	0x0029
#define	MBOX_GET_RESET_DELAY_PARAMS	0x002a
					/*  2b */
					/*  2c */
					/*  2d */
					/*  2e */
					/*  2f */
#define MBOX_SET_INIT_SCSI_ID		0x0030
#define MBOX_SET_SELECT_TIMEOUT		0x0031
#define MBOX_SET_RETRY_COUNT		0x0032
#define MBOX_SET_TAG_AGE_LIMIT		0x0033
#define MBOX_SET_CLOCK_RATE		0x0034
#define MBOX_SET_ACT_NEG_STATE		0x0035
#define MBOX_SET_ASYNC_DATA_SETUP_TIME	0x0036
#define MBOX_SET_SBUS_CONTROL_PARAMS	0x0037
#define		MBOX_SET_PCI_PARAMETERS	0x0037
#define MBOX_SET_TARGET_PARAMS		0x0038
#define MBOX_SET_DEV_QUEUE_PARAMS	0x0039
#define	MBOX_SET_RESET_DELAY_PARAMS	0x003a
					/*  3b */
					/*  3c */
					/*  3d */
					/*  3e */
					/*  3f */
#define	MBOX_RETURN_BIOS_BLOCK_ADDR	0x0040
#define	MBOX_WRITE_FOUR_RAM_WORDS	0x0041
#define	MBOX_EXEC_BIOS_IOCB		0x0042
#define	MBOX_SET_FW_FEATURES		0x004a
#define	MBOX_GET_FW_FEATURES		0x004b
#define		FW_FEATURE_FAST_POST	0x1
#define		FW_FEATURE_LVD_NOTIFY	0x2
#define		FW_FEATURE_RIO_32BIT	0x4
#define		FW_FEATURE_RIO_16BIT	0x8

#define	MBOX_INIT_REQ_QUEUE_A64		0x0052
#define	MBOX_INIT_RES_QUEUE_A64		0x0053

#define	MBOX_ENABLE_TARGET_MODE		0x0055
#define		ENABLE_TARGET_FLAG	0x8000
#define		ENABLE_TQING_FLAG	0x0004
#define		ENABLE_MANDATORY_DISC	0x0002
#define	MBOX_GET_TARGET_STATUS		0x0056

/* These are for the ISP2X00 FC cards */
#define	MBOX_GET_LOOP_ID		0x0020
#define	MBOX_GET_FIRMWARE_OPTIONS	0x0028
#define	MBOX_SET_FIRMWARE_OPTIONS	0x0038
#define	MBOX_GET_RESOURCE_COUNT		0x0042
#define	MBOX_REQUEST_OFFLINE_MODE	0x0043
#define	MBOX_ENHANCED_GET_PDB		0x0047
#define	MBOX_EXEC_COMMAND_IOCB_A64	0x0054
#define	MBOX_INIT_FIRMWARE		0x0060
#define	MBOX_GET_INIT_CONTROL_BLOCK	0x0061
#define	MBOX_INIT_LIP			0x0062
#define	MBOX_GET_FC_AL_POSITION_MAP	0x0063
#define	MBOX_GET_PORT_DB		0x0064
#define	MBOX_CLEAR_ACA			0x0065
#define	MBOX_TARGET_RESET		0x0066
#define	MBOX_CLEAR_TASK_SET		0x0067
#define	MBOX_ABORT_TASK_SET		0x0068
#define	MBOX_GET_FW_STATE		0x0069
#define	MBOX_GET_PORT_NAME		0x006A
#define	MBOX_GET_LINK_STATUS		0x006B
#define	MBOX_INIT_LIP_RESET		0x006C
#define	MBOX_SEND_SNS			0x006E
#define	MBOX_FABRIC_LOGIN		0x006F
#define	MBOX_SEND_CHANGE_REQUEST	0x0070
#define	MBOX_FABRIC_LOGOUT		0x0071
#define	MBOX_INIT_LIP_LOGIN		0x0072
#define	MBOX_LUN_RESET			0x007E

#define	MBOX_DRIVER_HEARTBEAT		0x005B
#define	MBOX_FW_HEARTBEAT		0x005C

#define	MBOX_GET_SET_DATA_RATE		0x005D	/* 24XX/23XX only */
#define		MBGSD_GET_RATE		0
#define		MBGSD_SET_RATE		1
#define		MBGSD_SET_RATE_NOW	2	/* 24XX only */
#define		MBGSD_ONEGB	0
#define		MBGSD_TWOGB	1
#define		MBGSD_AUTO	2
#define		MBGSD_FOURGB	3		/* 24XX only */


#define	ISP2100_SET_PCI_PARAM		0x00ff

#define	MBOX_BUSY			0x04

/*
 * Mailbox Command Complete Status Codes
 */
#define	MBOX_COMMAND_COMPLETE		0x4000
#define	MBOX_INVALID_COMMAND		0x4001
#define	MBOX_HOST_INTERFACE_ERROR	0x4002
#define	MBOX_TEST_FAILED		0x4003
#define	MBOX_COMMAND_ERROR		0x4005
#define	MBOX_COMMAND_PARAM_ERROR	0x4006
#define	MBOX_PORT_ID_USED		0x4007
#define	MBOX_LOOP_ID_USED		0x4008
#define	MBOX_ALL_IDS_USED		0x4009
#define	MBOX_NOT_LOGGED_IN		0x400A
/* pseudo mailbox completion codes */
#define	MBOX_REGS_BUSY			0x6000	/* registers in use */
#define	MBOX_TIMEOUT			0x6001	/* command timed out */

#define	MBLOGALL			0x000f
#define	MBLOGNONE			0x0000
#define	MBLOGMASK(x)			((x) & 0xf)

/*
 * Asynchronous event status codes
 */
#define	ASYNC_BUS_RESET			0x8001
#define	ASYNC_SYSTEM_ERROR		0x8002
#define	ASYNC_RQS_XFER_ERR		0x8003
#define	ASYNC_RSP_XFER_ERR		0x8004
#define	ASYNC_QWAKEUP			0x8005
#define	ASYNC_TIMEOUT_RESET		0x8006
#define	ASYNC_DEVICE_RESET		0x8007
#define	ASYNC_EXTMSG_UNDERRUN		0x800A
#define	ASYNC_SCAM_INT			0x800B
#define	ASYNC_HUNG_SCSI			0x800C
#define	ASYNC_KILLED_BUS		0x800D
#define	ASYNC_BUS_TRANSIT		0x800E	/* LVD -> HVD, eg. */
#define	ASYNC_LIP_OCCURRED		0x8010
#define	ASYNC_LOOP_UP			0x8011
#define	ASYNC_LOOP_DOWN			0x8012
#define	ASYNC_LOOP_RESET		0x8013
#define	ASYNC_PDB_CHANGED		0x8014
#define	ASYNC_CHANGE_NOTIFY		0x8015
#define	ASYNC_LIP_F8			0x8016
#define	ASYNC_LIP_ERROR			0x8017
#define	ASYNC_SECURITY_UPDATE		0x801B
#define	ASYNC_CMD_CMPLT			0x8020
#define	ASYNC_CTIO_DONE			0x8021
#define	ASYNC_IP_XMIT_DONE		0x8022
#define	ASYNC_IP_RECV_DONE		0x8023
#define	ASYNC_IP_BROADCAST		0x8024
#define	ASYNC_IP_RCVQ_LOW		0x8025
#define	ASYNC_IP_RCVQ_EMPTY		0x8026
#define	ASYNC_IP_RECV_DONE_ALIGNED	0x8027
#define	ASYNC_PTPMODE			0x8030
#define	ASYNC_RIO1			0x8031
#define	ASYNC_RIO2			0x8032
#define	ASYNC_RIO3			0x8033
#define	ASYNC_RIO4			0x8034
#define	ASYNC_RIO5			0x8035
#define	ASYNC_CONNMODE			0x8036
#define		ISP_CONN_LOOP		1
#define		ISP_CONN_PTP		2
#define		ISP_CONN_BADLIP		3
#define		ISP_CONN_FATAL		4
#define		ISP_CONN_LOOPBACK	5
#define	ASYNC_RIO_RESP			0x8040
#define	ASYNC_RIO_COMP			0x8042
#define	ASYNC_RCV_ERR			0x8048

/*
 * 2.01.31 2200 Only. Need Bit 13 in Mailbox 1 for Set Firmware Options
 * mailbox command to enable this.
 */
#define	ASYNC_QFULL_SENT		0x8049

/*
 * 24XX only
 */
#define	ASYNC_RJT_SENT			0x8049

/*
 * All IOCB Queue entries are this size
 */
#define	QENTRY_LEN			64

/*
 * Command Structure Definitions
 */

typedef struct {
	u_int32_t	ds_base;
	u_int32_t	ds_count;
} ispds_t;

typedef struct {
	u_int32_t	ds_base;
	u_int32_t	ds_basehi;
	u_int32_t	ds_count;
} ispds64_t;

#define	DSTYPE_32BIT	0
#define	DSTYPE_64BIT	1
typedef struct {
	u_int16_t	ds_type;	/* 0-> ispds_t, 1-> ispds64_t */
	u_int32_t	ds_segment;	/* unused */
	u_int32_t	ds_base;	/* 32 bit address of DSD list */
} ispdslist_t;


/*
 * These elements get swizzled around for SBus instances.
 */
#define	ISP_SWAP8(a, b)	{		\
	u_int8_t tmp;			\
	tmp = a;			\
	a = b;				\
	b = tmp;			\
}
typedef struct {
	u_int8_t	rqs_entry_type;
	u_int8_t	rqs_entry_count;
	u_int8_t	rqs_seqno;
	u_int8_t	rqs_flags;
} isphdr_t;

/* RQS Flag definitions */
#define	RQSFLAG_CONTINUATION	0x01
#define	RQSFLAG_FULL		0x02
#define	RQSFLAG_BADHEADER	0x04
#define	RQSFLAG_BADPACKET	0x08
#define	RQSFLAG_MASK		0x0f

/* RQS entry_type definitions */
#define	RQSTYPE_REQUEST		0x01
#define	RQSTYPE_DATASEG		0x02
#define	RQSTYPE_RESPONSE	0x03
#define	RQSTYPE_MARKER		0x04
#define	RQSTYPE_CMDONLY		0x05
#define	RQSTYPE_ATIO		0x06	/* Target Mode */
#define	RQSTYPE_CTIO		0x07	/* Target Mode */
#define	RQSTYPE_SCAM		0x08
#define	RQSTYPE_A64		0x09
#define	RQSTYPE_A64_CONT	0x0a
#define	RQSTYPE_ENABLE_LUN	0x0b	/* Target Mode */
#define	RQSTYPE_MODIFY_LUN	0x0c	/* Target Mode */
#define	RQSTYPE_NOTIFY		0x0d	/* Target Mode */
#define	RQSTYPE_NOTIFY_ACK	0x0e	/* Target Mode */
#define	RQSTYPE_CTIO1		0x0f	/* Target Mode */
#define	RQSTYPE_STATUS_CONT	0x10
#define	RQSTYPE_T2RQS		0x11
#define	RQSTYPE_CTIO7		0x12
#define	RQSTYPE_IP_XMIT		0x13
#define	RQSTYPE_TSK_MGMT	0x14
#define	RQSTYPE_T4RQS		0x15
#define	RQSTYPE_ATIO2		0x16	/* Target Mode */
#define	RQSTYPE_CTIO2		0x17	/* Target Mode */
#define	RQSTYPE_T7RQS		0x18
#define	RQSTYPE_T3RQS		0x19
#define	RQSTYPE_IP_XMIT_64	0x1b
#define	RQSTYPE_CTIO4		0x1e	/* Target Mode */
#define	RQSTYPE_CTIO3		0x1f	/* Target Mode */
#define	RQSTYPE_RIO1		0x21
#define	RQSTYPE_RIO2		0x22
#define	RQSTYPE_IP_RECV		0x23
#define	RQSTYPE_IP_RECV_CONT	0x24
#define	RQSTYPE_CT_PASSTHRU	0x29
#define	RQSTYPE_MS_PASSTHRU	0x29
#define	RQSTYPE_ABORT_IO	0x33
#define	RQSTYPE_T6RQS		0x48
#define	RQSTYPE_LOGIN		0x52
#define	RQSTYPE_ABTS_RCVD	0x54	/* 24XX only */
#define	RQSTYPE_ABTS_RSP	0x55	/* 24XX only */


#define	ISP_RQDSEG	4
typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int8_t	req_lun_trn;
	u_int8_t	req_target;
	u_int16_t	req_cdblen;
	u_int16_t	req_flags;
	u_int16_t	req_reserved;
	u_int16_t	req_time;
	u_int16_t	req_seg_count;
	u_int8_t	req_cdb[12];
	ispds_t		req_dataseg[ISP_RQDSEG];
} ispreq_t;
#define	ISP_RQDSEG_A64	2

typedef struct {
	isphdr_t	mrk_header;
	u_int32_t	mrk_handle;
	u_int8_t	mrk_reserved0;
	u_int8_t	mrk_target;
	u_int16_t	mrk_modifier;
	u_int16_t	mrk_flags;
	u_int16_t	mrk_lun;
	u_int8_t	mrk_reserved1[48];
} isp_marker_t;
	
typedef struct {
	isphdr_t	mrk_header;
	u_int32_t	mrk_handle;
	u_int16_t	mrk_nphdl;
	u_int8_t	mrk_modifier;
	u_int8_t	mrk_reserved0;
	u_int8_t	mrk_reserved1;
	u_int8_t	mrk_vphdl;
	u_int16_t	mrk_reserved2;
	u_int8_t	mrk_lun[8];
	u_int8_t	mrk_reserved3[40];
} isp_marker_24xx_t;
	

#define SYNC_DEVICE	0
#define SYNC_TARGET	1
#define SYNC_ALL	2
#define SYNC_LIP	3

#define	ISP_RQDSEG_T2		3
typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int8_t	req_lun_trn;
	u_int8_t	req_target;
	u_int16_t	req_scclun;
	u_int16_t	req_flags;
	u_int16_t	req_reserved;
	u_int16_t	req_time;
	u_int16_t	req_seg_count;
	u_int8_t	req_cdb[16];
	u_int32_t	req_totalcnt;
	ispds_t		req_dataseg[ISP_RQDSEG_T2];
} ispreqt2_t;

typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int16_t	req_target;
	u_int16_t	req_scclun;
	u_int16_t	req_flags;
	u_int16_t	req_reserved;
	u_int16_t	req_time;
	u_int16_t	req_seg_count;
	u_int8_t	req_cdb[16];
	u_int32_t	req_totalcnt;
	ispds_t		req_dataseg[ISP_RQDSEG_T2];
} ispreqt2e_t;

#define	ISP_RQDSEG_T3		2
typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int8_t	req_lun_trn;
	u_int8_t	req_target;
	u_int16_t	req_scclun;
	u_int16_t	req_flags;
	u_int16_t	req_reserved;
	u_int16_t	req_time;
	u_int16_t	req_seg_count;
	u_int8_t	req_cdb[16];
	u_int32_t	req_totalcnt;
	ispds64_t	req_dataseg[ISP_RQDSEG_T3];
} ispreqt3_t;
#define	ispreq64_t	ispreqt3_t	/* same as.... */

typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int16_t	req_target;
	u_int16_t	req_scclun;
	u_int16_t	req_flags;
	u_int16_t	req_reserved;
	u_int16_t	req_time;
	u_int16_t	req_seg_count;
	u_int8_t	req_cdb[16];
	u_int32_t	req_totalcnt;
	ispds64_t	req_dataseg[ISP_RQDSEG_T3];
} ispreqt3e_t;

/* req_flag values */
#define	REQFLAG_NODISCON	0x0001
#define	REQFLAG_HTAG		0x0002
#define	REQFLAG_OTAG		0x0004
#define	REQFLAG_STAG		0x0008
#define	REQFLAG_TARGET_RTN	0x0010

#define	REQFLAG_NODATA		0x0000
#define	REQFLAG_DATA_IN		0x0020
#define	REQFLAG_DATA_OUT	0x0040
#define	REQFLAG_DATA_UNKNOWN	0x0060

#define	REQFLAG_DISARQ		0x0100
#define	REQFLAG_FRC_ASYNC	0x0200
#define	REQFLAG_FRC_SYNC	0x0400
#define	REQFLAG_FRC_WIDE	0x0800
#define	REQFLAG_NOPARITY	0x1000
#define	REQFLAG_STOPQ		0x2000
#define	REQFLAG_XTRASNS		0x4000
#define	REQFLAG_PRIORITY	0x8000

typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int8_t	req_lun_trn;
	u_int8_t	req_target;
	u_int16_t	req_cdblen;
	u_int16_t	req_flags;
	u_int16_t	req_reserved;
	u_int16_t	req_time;
	u_int16_t	req_seg_count;
	u_int8_t	req_cdb[44];
} ispextreq_t;

/* 24XX only */
typedef struct {
	u_int16_t	fcd_length;
	u_int16_t	fcd_a1500;
	u_int16_t	fcd_a3116;
	u_int16_t	fcd_a4732;
	u_int16_t	fcd_a6348;
} fcp_cmnd_ds_t;

typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int16_t	req_nphdl;
	u_int16_t	req_time;
	u_int16_t	req_seg_count;
	u_int16_t	req_fc_rsp_dsd_length;
	u_int8_t	req_lun[8];
	u_int16_t	req_flags;
	u_int16_t	req_fc_cmnd_dsd_length;
	u_int16_t	req_fc_cmnd_dsd_a1500;
	u_int16_t	req_fc_cmnd_dsd_a3116;
	u_int16_t	req_fc_cmnd_dsd_a4732;
	u_int16_t	req_fc_cmnd_dsd_a6348;
	u_int16_t	req_fc_rsp_dsd_a1500;
	u_int16_t	req_fc_rsp_dsd_a3116;
	u_int16_t	req_fc_rsp_dsd_a4732;
	u_int16_t	req_fc_rsp_dsd_a6348;
	u_int32_t	req_totalcnt;
	u_int16_t	req_tidlo;
	u_int8_t	req_tidhi;
	u_int8_t	req_vpidx;
	ispds64_t	req_dataseg;
} ispreqt6_t;

typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int16_t	req_nphdl;
	u_int16_t	req_time;
	u_int16_t	req_seg_count;
	u_int16_t	req_reserved;
	u_int8_t	req_lun[8];
	u_int8_t	req_alen_datadir;
	u_int8_t	req_task_management;
	u_int8_t	req_task_attribute;
	u_int8_t	req_crn;
	u_int8_t	req_cdb[16];
	u_int32_t	req_dl;
	u_int16_t	req_tidlo;
	u_int8_t	req_tidhi;
	u_int8_t	req_vpidx;
	ispds64_t	req_dataseg;
} ispreqt7_t;

/* I/O Abort Structure */
typedef struct {
	isphdr_t	abrt_header;
	u_int32_t	abrt_handle;
	u_int16_t	abrt_nphdl;
	u_int16_t	abrt_options;
	u_int32_t	abrt_cmd_handle;
	u_int8_t	abrt_reserved[32];
	u_int16_t	abrt_tidlo;
	u_int8_t	abrt_tidhi;
	u_int8_t	abrt_vpidx;
	u_int8_t	abrt_reserved1[12];
} isp24xx_abrt_t;
#define	ISP24XX_ABRT_NO_ABTS	0x01	/* don't actually send an ABTS */
#define	ISP24XX_ABRT_ENXIO	0x31	/* in nphdl on return */

#define	ISP_CDSEG	7
typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_reserved;
	ispds_t		req_dataseg[ISP_CDSEG];
} ispcontreq_t;

#define	ISP_CDSEG64	5
typedef struct {
	isphdr_t	req_header;
	ispds64_t	req_dataseg[ISP_CDSEG64];
} ispcontreq64_t;

typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int16_t	req_scsi_status;
	u_int16_t	req_completion_status;
	u_int16_t	req_state_flags;
	u_int16_t	req_status_flags;
	u_int16_t	req_time;
#define	req_response_len	req_time	/* FC only */
	u_int16_t	req_sense_len;
	u_int32_t	req_resid;
	u_int8_t	req_response[8];	/* FC only */
	u_int8_t	req_sense_data[32];
} ispstatusreq_t;

/*
 * Status Continuation
 */
typedef struct {
	isphdr_t	req_header;
	u_int8_t	req_sense_data[60];
} ispstatus_cont_t;

/*
 * 24XX Type 0 status
 */
typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int16_t	req_completion_status;
	u_int16_t	req_oxid;
	u_int32_t	req_resid;
	u_int16_t	req_reserved0;
	u_int16_t	req_state_flags;
	u_int16_t	req_reserved1;
	u_int16_t	req_scsi_status;
	u_int32_t	req_fcp_residual;
	u_int32_t	req_sense_len;
	u_int32_t	req_response_len;
	u_int8_t	req_rsp_sense[28];
} isp24xx_statusreq_t;

/* 
 * For QLogic 2X00, the high order byte of SCSI status has
 * additional meaning.
 */
#define	RQCS_RU	0x800	/* Residual Under */
#define	RQCS_RO	0x400	/* Residual Over */
#define	RQCS_RESID	(RQCS_RU|RQCS_RO)
#define	RQCS_SV	0x200	/* Sense Length Valid */
#define	RQCS_RV	0x100	/* FCP Response Length Valid */

/*
 * CT Passthru IOCB
 */
typedef struct {
	isphdr_t	ctp_header;
	u_int32_t	ctp_handle;
	u_int16_t	ctp_status;
	u_int16_t	ctp_nphdl;	/* n-port handle */
	u_int16_t	ctp_cmd_cnt;	/* Command DSD count */
	u_int16_t	ctp_vpidx;	/* low 8 bits */
	u_int16_t	ctp_time;
	u_int16_t	ctp_reserved0;
	u_int16_t	ctp_rsp_cnt;	/* Response DSD count */
	u_int16_t	ctp_reserved1[5];
	u_int32_t	ctp_rsp_bcnt;	/* Response byte count */
	u_int32_t	ctp_cmd_bcnt;	/* Command byte count */
	ispds64_t	ctp_dataseg[2];
} isp_ct_pt_t;

/*
 * MS Passthru IOCB
 */
typedef struct {
	isphdr_t	ms_header;
	u_int32_t	ms_handle;
	u_int16_t	ms_nphdl;	/* handle in high byte for !2k f/w */
	u_int16_t	ms_status;
	u_int16_t	ms_flags;
	u_int16_t	ms_reserved1;	/* low 8 bits */
	u_int16_t	ms_time;
	u_int16_t	ms_cmd_cnt;	/* Command DSD count */
	u_int16_t	ms_tot_cnt;	/* Total DSD Count */
	u_int8_t	ms_type;	/* MS type */
	u_int8_t	ms_r_ctl;	/* R_CTL */
	u_int16_t	ms_rxid;	/* RX_ID */
	u_int16_t	ms_reserved2;
	u_int32_t	ms_handle2;
	u_int32_t	ms_rsp_bcnt;	/* Response byte count */
	u_int32_t	ms_cmd_bcnt;	/* Command byte count */
	ispds64_t	ms_dataseg[2];
} isp_ms_t;

/* 
 * Completion Status Codes.
 */
#define RQCS_COMPLETE			0x0000
#define RQCS_DMA_ERROR			0x0002
#define RQCS_RESET_OCCURRED		0x0004
#define RQCS_ABORTED			0x0005
#define RQCS_TIMEOUT			0x0006
#define RQCS_DATA_OVERRUN		0x0007
#define RQCS_DATA_UNDERRUN		0x0015
#define	RQCS_QUEUE_FULL			0x001C

/* 1X00 Only Completion Codes */
#define RQCS_INCOMPLETE			0x0001
#define RQCS_TRANSPORT_ERROR		0x0003
#define RQCS_COMMAND_OVERRUN		0x0008
#define RQCS_STATUS_OVERRUN		0x0009
#define RQCS_BAD_MESSAGE		0x000a
#define RQCS_NO_MESSAGE_OUT		0x000b
#define RQCS_EXT_ID_FAILED		0x000c
#define RQCS_IDE_MSG_FAILED		0x000d
#define RQCS_ABORT_MSG_FAILED		0x000e
#define RQCS_REJECT_MSG_FAILED		0x000f
#define RQCS_NOP_MSG_FAILED		0x0010
#define RQCS_PARITY_ERROR_MSG_FAILED	0x0011
#define RQCS_DEVICE_RESET_MSG_FAILED	0x0012
#define RQCS_ID_MSG_FAILED		0x0013
#define RQCS_UNEXP_BUS_FREE		0x0014
#define	RQCS_XACT_ERR1			0x0018
#define	RQCS_XACT_ERR2			0x0019
#define	RQCS_XACT_ERR3			0x001A
#define	RQCS_BAD_ENTRY			0x001B
#define	RQCS_PHASE_SKIPPED		0x001D
#define	RQCS_ARQS_FAILED		0x001E
#define	RQCS_WIDE_FAILED		0x001F
#define	RQCS_SYNCXFER_FAILED		0x0020
#define	RQCS_LVD_BUSERR			0x0021

/* 2X00 Only Completion Codes */
#define	RQCS_PORT_UNAVAILABLE		0x0028
#define	RQCS_PORT_LOGGED_OUT		0x0029
#define	RQCS_PORT_CHANGED		0x002A
#define	RQCS_PORT_BUSY			0x002B

/* 24XX Only Completion Codes */
#define	RQCS_24XX_DRE			0x0011	/* data reassembly error */
#define	RQCS_24XX_TABORT		0x0013	/* aborted by target */
#define	RQCS_24XX_ENOMEM		0x002C	/* f/w resource unavailable */
#define	RQCS_24XX_TMO			0x0030	/* task management overrun */


/*
 * 1X00 specific State Flags 
 */
#define RQSF_GOT_BUS			0x0100
#define RQSF_GOT_TARGET			0x0200
#define RQSF_SENT_CDB			0x0400
#define RQSF_XFRD_DATA			0x0800
#define RQSF_GOT_STATUS			0x1000
#define RQSF_GOT_SENSE			0x2000
#define	RQSF_XFER_COMPLETE		0x4000

/*
 * 2X00 specific State Flags
 * (same as 1X00 except RQSF_GOT_BUS/RQSF_GOT_TARGET are not available)
 */
#define	RQSF_DATA_IN			0x0020
#define	RQSF_DATA_OUT			0x0040
#define	RQSF_STAG			0x0008
#define	RQSF_OTAG			0x0004
#define	RQSF_HTAG			0x0002
/*
 * 1X00 Status Flags
 */
#define RQSTF_DISCONNECT		0x0001
#define RQSTF_SYNCHRONOUS		0x0002
#define RQSTF_PARITY_ERROR		0x0004
#define RQSTF_BUS_RESET			0x0008
#define RQSTF_DEVICE_RESET		0x0010
#define RQSTF_ABORTED			0x0020
#define RQSTF_TIMEOUT			0x0040
#define RQSTF_NEGOTIATION		0x0080

/*
 * 2X00 specific state flags
 */
/* RQSF_SENT_CDB	*/
/* RQSF_XFRD_DATA	*/
/* RQSF_GOT_STATUS	*/
/* RQSF_XFER_COMPLETE	*/

/*
 * 2X00 specific status flags
 */
/* RQSTF_ABORTED */
/* RQSTF_TIMEOUT */
#define	RQSTF_DMA_ERROR			0x0080
#define	RQSTF_LOGOUT			0x2000

/*
 * Miscellaneous
 */
#ifndef	ISP_EXEC_THROTTLE
#define	ISP_EXEC_THROTTLE	16
#endif

/*
 * About Firmware returns an 'attribute' word in mailbox 6.
 * These attributes are for 2200 and 2300.
 */
#define	ISP_FW_ATTR_TMODE	0x01
#define	ISP_FW_ATTR_SCCLUN	0x02
#define	ISP_FW_ATTR_FABRIC	0x04
#define	ISP_FW_ATTR_CLASS2	0x08
#define	ISP_FW_ATTR_FCTAPE	0x10
#define	ISP_FW_ATTR_IP		0x20
#define	ISP_FW_ATTR_VI		0x40
#define	ISP_FW_ATTR_VI_SOLARIS	0x80
#define	ISP_FW_ATTR_2KLOGINS	0x100	/* XXX: just a guess */

/* and these are for the 2400 */
#define	ISP2400_FW_ATTR_CLASS2	(1 << 0)
#define	ISP2400_FW_ATTR_IP	(1 << 1)
#define	ISP2400_FW_ATTR_MULTIID	(1 << 2)
#define	ISP2400_FW_ATTR_SB2	(1 << 3)
#define	ISP2400_FW_ATTR_T10CRC	(1 << 4)
#define	ISP2400_FW_ATTR_VI	(1 << 5)
#define	ISP2400_FW_ATTR_EXPFW	(1 << 13)

/*
 * Reduced Interrupt Operation Response Queue Entreis
 */

typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handles[15];
} isp_rio1_t;

typedef struct {
	isphdr_t	req_header;
	u_int16_t	req_handles[30];
} isp_rio2_t;

/*
 * FC (ISP2100/ISP2200/ISP2300/ISP2400) specific data structures
 */

/*
 * Initialization Control Block
 *
 * Version One (prime) format.
 */
typedef struct {
	u_int8_t	icb_version;
	u_int8_t	icb_reserved0;
	u_int16_t	icb_fwoptions;
	u_int16_t	icb_maxfrmlen;
	u_int16_t	icb_maxalloc;
	u_int16_t	icb_execthrottle;
	u_int8_t	icb_retry_count;
	u_int8_t	icb_retry_delay;
	u_int8_t	icb_portname[8];
	u_int16_t	icb_hardaddr;
	u_int8_t	icb_iqdevtype;
	u_int8_t	icb_logintime;
	u_int8_t	icb_nodename[8];
	u_int16_t	icb_rqstout;
	u_int16_t	icb_rspnsin;
	u_int16_t	icb_rqstqlen;
	u_int16_t	icb_rsltqlen;
	u_int16_t	icb_rqstaddr[4];
	u_int16_t	icb_respaddr[4];
	u_int16_t	icb_lunenables;
	u_int8_t	icb_ccnt;
	u_int8_t	icb_icnt;
	u_int16_t	icb_lunetimeout;
	u_int16_t	icb_reserved1;
	u_int16_t	icb_xfwoptions;
	u_int8_t	icb_racctimer;
	u_int8_t	icb_idelaytimer;
	u_int16_t	icb_zfwoptions;
	u_int16_t	icb_reserved2[13];
} isp_icb_t;

#define	ICB_VERSION1	1

#define	ICBOPT_EXTENDED		0x8000
#define	ICBOPT_BOTH_WWNS	0x4000
#define	ICBOPT_FULL_LOGIN	0x2000
#define	ICBOPT_STOP_ON_QFULL	0x1000	/* 2200/2100 only */
#define	ICBOPT_PREVLOOP		0x0800
#define	ICBOPT_SRCHDOWN		0x0400
#define	ICBOPT_NOLIP		0x0200
#define	ICBOPT_PDBCHANGE_AE	0x0100
#define	ICBOPT_INI_TGTTYPE	0x0080
#define	ICBOPT_INI_ADISC	0x0040
#define	ICBOPT_INI_DISABLE	0x0020
#define	ICBOPT_TGT_ENABLE	0x0010
#define	ICBOPT_FAST_POST	0x0008
#define	ICBOPT_FULL_DUPLEX	0x0004
#define	ICBOPT_FAIRNESS		0x0002
#define	ICBOPT_HARD_ADDRESS	0x0001

#define	ICBXOPT_NO_LOGOUT	0x8000	/* no logout on link failure */
#define	ICBXOPT_FCTAPE_CCQ	0x4000	/* FC-Tape Command Queueing */
#define	ICBXOPT_FCTAPE_CONFIRM	0x2000
#define	ICBXOPT_FCTAPE		0x1000
#define	ICBXOPT_CLASS2_ACK0	0x0200
#define	ICBXOPT_CLASS2		0x0100
#define	ICBXOPT_NO_PLAY		0x0080	/* don't play if can't get hard addr */
#define	ICBXOPT_TOPO_MASK	0x0070
#define	ICBXOPT_LOOP_ONLY	0x0000
#define	ICBXOPT_PTP_ONLY	0x0010
#define	ICBXOPT_LOOP_2_PTP	0x0020
#define	ICBXOPT_PTP_2_LOOP	0x0030
/*
 * The lower 4 bits of the xfwoptions field are the OPERATION MODE bits.
 * RIO is not defined for the 23XX cards (just 2200)
 */
#define	ICBXOPT_RIO_OFF		0
#define	ICBXOPT_RIO_16BIT	1
#define	ICBXOPT_RIO_32BIT	2
#define	ICBXOPT_RIO_16BIT_IOCB	3
#define	ICBXOPT_RIO_32BIT_IOCB	4
#define	ICBXOPT_ZIO		5	
#define	ICBXOPT_TIMER_MASK	0x7

#define	ICBZOPT_RATE_MASK	0xC000
#define	ICBZOPT_RATE_ONEGB	0x0000
#define	ICBZOPT_RATE_AUTO	0x8000
#define	ICBZOPT_RATE_TWOGB	0x4000
#define	ICBZOPT_50_OHM		0x2000
#define	ICBZOPT_ENA_OOF		0x0040	/* out of order frame handling */
#define	ICBZOPT_RSPSZ_MASK	0x0030
#define	ICBZOPT_RSPSZ_24	0x0000
#define	ICBZOPT_RSPSZ_12	0x0010
#define	ICBZOPT_RSPSZ_24A	0x0020
#define	ICBZOPT_RSPSZ_32	0x0030
#define	ICBZOPT_SOFTID		0x0002
#define	ICBZOPT_ENA_RDXFR_RDY	0x0001

/* 2400 F/W options */
#define	ICB2400_OPT1_BOTH_WWNS		0x00004000
#define	ICB2400_OPT1_FULL_LOGIN		0x00002000
#define	ICB2400_OPT1_PREVLOOP		0x00000800
#define	ICB2400_OPT1_SRCHDOWN		0x00000400
#define	ICB2400_OPT1_NOLIP		0x00000200
#define	ICB2400_OPT1_INI_DISABLE	0x00000020
#define	ICB2400_OPT1_TGT_ENABLE		0x00000010
#define	ICB2400_OPT1_FULL_DUPLEX	0x00000004
#define	ICB2400_OPT1_FAIRNESS		0x00000002
#define	ICB2400_OPT1_HARD_ADDRESS	0x00000001

#define	ICB2400_OPT2_FCTAPE		0x00001000
#define	ICB2400_OPT2_CLASS2_ACK0	0x00000200
#define	ICB2400_OPT2_CLASS2		0x00000100
#define	ICB2400_OPT2_NO_PLAY		0x00000080
#define	ICB2400_OPT2_TOPO_MASK		0x00000070
#define	ICB2400_OPT2_LOOP_ONLY		0x00000000
#define	ICB2400_OPT2_PTP_ONLY		0x00000010
#define	ICB2400_OPT2_LOOP_2_PTP		0x00000020
#define	ICB2400_OPT2_PTP_2_LOOP		0x00000030
#define	ICB2400_OPT2_TIMER_MASK		0x00000007
#define	ICB2400_OPT2_ZIO		0x00000005
#define	ICB2400_OPT2_ZIO1		0x00000006

#define	ICB2400_OPT3_75_OHM		0x00010000
#define	ICB2400_OPT3_RATE_MASK		0x0000E000
#define	ICB2400_OPT3_RATE_ONEGB		0x00000000
#define	ICB2400_OPT3_RATE_TWOGB		0x00002000
#define ICB2400_OPT3_RATE_AUTO		0x00004000
#define	ICB2400_OPT3_RATE_FOURGB	0x00006000
#define	ICB2400_OPT3_ENA_OOF_XFRDY	0x00000200
#define	ICB2400_OPT3_NO_LOCAL_PLOGI	0x00000080
#define	ICB2400_OPT3_ENA_OOF		0x00000040
/* note that a response size flag of zero is reserved! */
#define	ICB2400_OPT3_RSPSZ_MASK		0x00000030
#define	ICB2400_OPT3_RSPSZ_12		0x00000010
#define	ICB2400_OPT3_RSPSZ_24		0x00000020
#define	ICB2400_OPT3_RSPSZ_32		0x00000030
#define	ICB2400_OPT3_SOFTID		0x00000002

#define	ICB_MIN_FRMLEN		256
#define	ICB_MAX_FRMLEN		2112
#define	ICB_DFLT_FRMLEN		1024
#define	ICB_DFLT_ALLOC		256
#define	ICB_DFLT_THROTTLE	16
#define	ICB_DFLT_RDELAY		5
#define	ICB_DFLT_RCOUNT		3

#define	ICB_LOGIN_TOV		30
#define	ICB_LUN_ENABLE_TOV	180


/*
 * And somebody at QLogic had a great idea that you could just change
 * the structure *and* keep the version number the same as the other cards.
 */
typedef struct {
	u_int16_t	icb_version;
	u_int16_t	icb_reserved0;
	u_int16_t	icb_maxfrmlen;
	u_int16_t	icb_execthrottle;
	u_int16_t	icb_xchgcnt;
	u_int16_t	icb_hardaddr;
	u_int8_t	icb_portname[8];
	u_int8_t	icb_nodename[8];
	u_int16_t	icb_rspnsin;
	u_int16_t	icb_rqstout;
	u_int16_t	icb_retry_count;
	u_int16_t	icb_priout;
	u_int16_t	icb_rsltqlen;
	u_int16_t	icb_rqstqlen;
	u_int16_t	icb_ldn_nols;
	u_int16_t	icb_prqstqlen;
	u_int16_t	icb_rqstaddr[4];
	u_int16_t	icb_respaddr[4];
	u_int16_t	icb_priaddr[4];	
	u_int16_t	icb_reserved1[4];
	u_int16_t	icb_atio_in;
	u_int16_t	icb_atioqlen;
	u_int16_t	icb_atioqaddr[4];
	u_int16_t	icb_idelaytimer;
	u_int16_t	icb_logintime;
	u_int32_t	icb_fwoptions1;
	u_int32_t	icb_fwoptions2;
	u_int32_t	icb_fwoptions3;
	u_int16_t	icb_reserved2[12];
} isp_icb_2400_t;

#define	RQRSP_ADDR0015	0
#define	RQRSP_ADDR1631	1
#define	RQRSP_ADDR3247	2
#define	RQRSP_ADDR4863	3


#define	ICB_NNM0	7
#define	ICB_NNM1	6
#define	ICB_NNM2	5
#define	ICB_NNM3	4
#define	ICB_NNM4	3
#define	ICB_NNM5	2
#define	ICB_NNM6	1
#define	ICB_NNM7	0

#define	MAKE_NODE_NAME_FROM_WWN(array, wwn)	\
	array[ICB_NNM0] = (u_int8_t) ((wwn >>  0) & 0xff), \
	array[ICB_NNM1] = (u_int8_t) ((wwn >>  8) & 0xff), \
	array[ICB_NNM2] = (u_int8_t) ((wwn >> 16) & 0xff), \
	array[ICB_NNM3] = (u_int8_t) ((wwn >> 24) & 0xff), \
	array[ICB_NNM4] = (u_int8_t) ((wwn >> 32) & 0xff), \
	array[ICB_NNM5] = (u_int8_t) ((wwn >> 40) & 0xff), \
	array[ICB_NNM6] = (u_int8_t) ((wwn >> 48) & 0xff), \
	array[ICB_NNM7] = (u_int8_t) ((wwn >> 56) & 0xff)

#define	MAKE_WWN_FROM_NODE_NAME(wwn, array)	\
	wwn =	((u_int64_t) array[ICB_NNM0]) | \
		((u_int64_t) array[ICB_NNM1] <<  8) | \
		((u_int64_t) array[ICB_NNM2] << 16) | \
		((u_int64_t) array[ICB_NNM3] << 24) | \
		((u_int64_t) array[ICB_NNM4] << 32) | \
		((u_int64_t) array[ICB_NNM5] << 40) | \
		((u_int64_t) array[ICB_NNM6] << 48) | \
		((u_int64_t) array[ICB_NNM7] << 56)

/*
 * Port Data Base Element
 */

typedef struct {
	u_int16_t	pdb_options;
	u_int8_t	pdb_mstate;
	u_int8_t	pdb_sstate;
	u_int8_t	pdb_hardaddr_bits[4];
	u_int8_t	pdb_portid_bits[4];
	u_int8_t	pdb_nodename[8];
	u_int8_t	pdb_portname[8];
	u_int16_t	pdb_execthrottle;
	u_int16_t	pdb_exec_count;
	u_int8_t	pdb_retry_count;
	u_int8_t	pdb_retry_delay;
	u_int16_t	pdb_resalloc;
	u_int16_t	pdb_curalloc;
	u_int16_t	pdb_qhead;
	u_int16_t	pdb_qtail;
	u_int16_t	pdb_tl_next;
	u_int16_t	pdb_tl_last;
	u_int16_t	pdb_features;	/* PLOGI, Common Service */
	u_int16_t	pdb_pconcurrnt;	/* PLOGI, Common Service */
	u_int16_t	pdb_roi;	/* PLOGI, Common Service */
	u_int8_t	pdb_target;
	u_int8_t	pdb_initiator;	/* PLOGI, Class 3 Control Flags */
	u_int16_t	pdb_rdsiz;	/* PLOGI, Class 3 */
	u_int16_t	pdb_ncseq;	/* PLOGI, Class 3 */
	u_int16_t	pdb_noseq;	/* PLOGI, Class 3 */
	u_int16_t	pdb_labrtflg;
	u_int16_t	pdb_lstopflg;
	u_int16_t	pdb_sqhead;
	u_int16_t	pdb_sqtail;
	u_int16_t	pdb_ptimer;
	u_int16_t	pdb_nxt_seqid;
	u_int16_t	pdb_fcount;
	u_int16_t	pdb_prli_len;
	u_int16_t	pdb_prli_svc0;
	u_int16_t	pdb_prli_svc3;
	u_int16_t	pdb_loopid;
	u_int16_t	pdb_il_ptr;
	u_int16_t	pdb_sl_ptr;
} isp_pdb_21xx_t;

#define	PDB_OPTIONS_XMITTING	(1<<11)
#define	PDB_OPTIONS_LNKXMIT	(1<<10)
#define	PDB_OPTIONS_ABORTED	(1<<9)
#define	PDB_OPTIONS_ADISC	(1<<1)

#define	PDB_STATE_DISCOVERY	0
#define	PDB_STATE_WDISC_ACK	1
#define	PDB_STATE_PLOGI		2
#define	PDB_STATE_PLOGI_ACK	3
#define	PDB_STATE_PRLI		4
#define	PDB_STATE_PRLI_ACK	5
#define	PDB_STATE_LOGGED_IN	6
#define	PDB_STATE_PORT_UNAVAIL	7
#define	PDB_STATE_PRLO		8
#define	PDB_STATE_PRLO_ACK	9
#define	PDB_STATE_PLOGO		10
#define	PDB_STATE_PLOG_ACK	11

#define		SVC3_TGT_ROLE		0x10
#define 	SVC3_INI_ROLE		0x20
#define			SVC3_ROLE_MASK	0x30
#define			SVC3_ROLE_SHIFT	4

#define	BITS2WORD(x)		((x)[0] << 16 | (x)[3] << 8 | (x)[2])
#define	BITS2WORD_24XX(x)	((x)[0] << 16 | (x)[1] << 8 | (x)[2])

/*
 * Port Data Base Element- 24XX cards
 */
typedef struct {
	u_int16_t	pdb_flags;
	u_int8_t	pdb_curstate;
	u_int8_t	pdb_laststate;
	u_int8_t	pdb_hardaddr_bits[4];
	u_int8_t	pdb_portid_bits[4];
#define		pdb_nxt_seqid_2400	pdb_portid_bits[3]
	u_int16_t	pdb_retry_timer;
	u_int16_t	pdb_handle;
	u_int16_t	pdb_rcv_dsize;
	u_int16_t	pdb_reserved0;
	u_int16_t	pdb_prli_svc0;
	u_int16_t	pdb_prli_svc3;
	u_int8_t	pdb_portname[8];
	u_int8_t	pdb_nodename[8];
	u_int8_t	pdb_reserved1[24];
} isp_pdb_24xx_t;

#define	PDB2400_TID_SUPPORTED	0x4000
#define	PDB2400_FC_TAPE		0x0080
#define	PDB2400_CLASS2_ACK0	0x0040
#define	PDB2400_FCP_CONF	0x0020
#define	PDB2400_CLASS2		0x0010
#define	PDB2400_ADDR_VALID	0x0002

/*
 * Common elements from the above two structures that are actually useful to us.
 */
typedef struct {
	u_int16_t	handle;
	u_int16_t	reserved;
	u_int32_t	s3_role	: 8,
			portid	: 24;
	u_int8_t	portname[8];
	u_int8_t	nodename[8];
} isp_pdb_t;

/*
 * Genericized Port Login/Logout software structure
 */
typedef struct {
	u_int16_t	handle;
	u_int32_t
		flags	: 8,
		portid	: 24;
} isp_plcmd_t;
/* the flags to use are those for PLOGX_FLG_* below */

/*
 * ISP24XX- Login/Logout Port IOCB
 */
typedef struct {
	isphdr_t	plogx_header;
	u_int32_t	plogx_handle;
	u_int16_t	plogx_status;
	u_int16_t	plogx_nphdl;
	u_int16_t	plogx_flags;
	u_int16_t	plogx_vphdl;		/* low 8 bits */
	u_int16_t	plogx_portlo;		/* low 16 bits */
	u_int16_t	plogx_rspsz_porthi;
	struct {
		u_int16_t	lo16;
		u_int16_t	hi16;
	} plogx_ioparm[11];
} isp_plogx_t;

#define	PLOGX_STATUS_OK		0x00
#define	PLOGX_STATUS_UNAVAIL	0x28
#define	PLOGX_STATUS_LOGOUT	0x29
#define	PLOGX_STATUS_IOCBERR	0x31

#define	PLOGX_IOCBERR_NOLINK	0x01
#define	PLOGX_IOCBERR_NOIOCB	0x02
#define	PLOGX_IOCBERR_NOXGHG	0x03
#define	PLOGX_IOCBERR_FAILED	0x04	/* further info in IOPARM 1 */
#define	PLOGX_IOCBERR_NOFABRIC	0x05
#define	PLOGX_IOCBERR_NOTREADY	0x07
#define	PLOGX_IOCBERR_NOLOGIN	0x08	/* further info in IOPARM 1 */
#define	PLOGX_IOCBERR_NOPCB	0x0a
#define	PLOGX_IOCBERR_REJECT	0x18	/* further info in IOPARM 1 */
#define	PLOGX_IOCBERR_EINVAL	0x19	/* further info in IOPARM 1 */
#define	PLOGX_IOCBERR_PORTUSED	0x1a	/* further info in IOPARM 1 */
#define	PLOGX_IOCBERR_HNDLUSED	0x1b	/* further info in IOPARM 1 */
#define	PLOGX_IOCBERR_NOHANDLE	0x1c
#define	PLOGX_IOCBERR_NOFLOGI	0x1f	/* further info in IOPARM 1 */

#define	PLOGX_FLG_CMD_MASK	0xf
#define	PLOGX_FLG_CMD_PLOGI	0
#define	PLOGX_FLG_CMD_PRLI	1
#define	PLOGX_FLG_CMD_PDISC	2
#define	PLOGX_FLG_CMD_LOGO	8
#define	PLOGX_FLG_CMD_PRLO	9
#define	PLOGX_FLG_CMD_TPRLO	10

#define	PLOGX_FLG_COND_PLOGI		0x10	/* if with PLOGI */
#define	PLOGX_FLG_IMPLICIT		0x10	/* if with LOGO, PRLO, TPRLO */
#define	PLOGX_FLG_SKIP_PRLI		0x20	/* if with PLOGI */
#define	PLOGX_FLG_IMPLICIT_LOGO_ALL	0x20	/* if with LOGO */
#define	PLOGX_FLG_EXPLICIT_LOGO		0x40	/* if with LOGO */
#define	PLOGX_FLG_COMMON_FEATURES	0x80	/* if with PLOGI */
#define	PLOGX_FLG_FREE_NPHDL		0x80	/* if with with LOGO */

#define	PLOGX_FLG_CLASS2		0x100	/* if with PLOGI */
#define	PLOGX_FLG_FCP2_OVERRIDE		0x200	/* if with PRLOG, PRLI */

/*
 * Simple Name Server Data Structures
 */
#define	SNS_GA_NXT	0x100
#define	SNS_GPN_ID	0x112
#define	SNS_GNN_ID	0x113
#define	SNS_GFF_ID	0x11F
#define	SNS_GID_FT	0x171
#define	SNS_RFT_ID	0x217
typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_reserved0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_reserved1;
	u_int16_t	snscb_data[1];	/* variable data */
} sns_screq_t;	/* Subcommand Request Structure */

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_reserved0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_reserved1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_reserved2;
	u_int32_t	snscb_reserved3;
	u_int32_t	snscb_port;
} sns_ga_nxt_req_t;
#define	SNS_GA_NXT_REQ_SIZE	(sizeof (sns_ga_nxt_req_t))

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_reserved0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_reserved1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_reserved2;
	u_int32_t	snscb_reserved3;
	u_int32_t	snscb_portid;
} sns_gxn_id_req_t;
#define	SNS_GXN_ID_REQ_SIZE	(sizeof (sns_gxn_id_req_t))

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_reserved0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_reserved1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_mword_div_2;
	u_int32_t	snscb_reserved3;
	u_int32_t	snscb_fc4_type;
} sns_gid_ft_req_t;
#define	SNS_GID_FT_REQ_SIZE	(sizeof (sns_gid_ft_req_t))

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_reserved0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_reserved1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_reserved2;
	u_int32_t	snscb_reserved3;
	u_int32_t	snscb_port;
	u_int32_t	snscb_fc4_types[8];
} sns_rft_id_req_t;
#define	SNS_RFT_ID_REQ_SIZE	(sizeof (sns_rft_id_req_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	u_int8_t	snscb_port_type;
	u_int8_t	snscb_port_id[3];
	u_int8_t	snscb_portname[8];
	u_int16_t	snscb_data[1];	/* variable data */
} sns_scrsp_t;	/* Subcommand Response Structure */

typedef struct {
	ct_hdr_t	snscb_cthdr;
	u_int8_t	snscb_port_type;
	u_int8_t	snscb_port_id[3];
	u_int8_t	snscb_portname[8];
	u_int8_t	snscb_pnlen;		/* symbolic port name length */
	u_int8_t	snscb_pname[255];	/* symbolic port name */
	u_int8_t	snscb_nodename[8];
	u_int8_t	snscb_nnlen;		/* symbolic node name length */
	u_int8_t	snscb_nname[255];	/* symbolic node name */
	u_int8_t	snscb_ipassoc[8];
	u_int8_t	snscb_ipaddr[16];
	u_int8_t	snscb_svc_class[4];
	u_int8_t	snscb_fc4_types[32];
	u_int8_t	snscb_fpname[8];
	u_int8_t	snscb_reserved;
	u_int8_t	snscb_hardaddr[3];
} sns_ga_nxt_rsp_t;	/* Subcommand Response Structure */
#define	SNS_GA_NXT_RESP_SIZE	(sizeof (sns_ga_nxt_rsp_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	u_int8_t	snscb_wwn[8];
} sns_gxn_id_rsp_t;
#define	SNS_GXN_ID_RESP_SIZE	(sizeof (sns_gxn_id_rsp_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	u_int32_t	snscb_fc4_features[32];
} sns_gff_id_rsp_t;
#define	SNS_GFF_ID_RESP_SIZE	(sizeof (sns_gff_id_rsp_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	struct {
		u_int8_t	control;
		u_int8_t	portid[3];
	} snscb_ports[1];
} sns_gid_ft_rsp_t;
#define	SNS_GID_FT_RESP_SIZE(x)	((sizeof (sns_gid_ft_rsp_t)) + ((x - 1) << 2))
#define	SNS_RFT_ID_RESP_SIZE	(sizeof (ct_hdr_t))

/*
 * Other Misc Structures
 */

/* ELS Pass Through */
typedef struct {
	isphdr_t	els_hdr;
	u_int32_t	els_handle;
	u_int16_t	els_status;
	u_int16_t	els_nphdl;
	u_int16_t	els_xmit_dsd_count;	/* outgoing only */
	u_int8_t	els_vphdl;
	u_int8_t	els_sof;
	u_int32_t	els_rxid;
	u_int16_t	els_recv_dsd_count;	/* outgoing only */
	u_int8_t	els_opcode;
	u_int8_t	els_reserved1;
	u_int8_t	els_did_lo;
	u_int8_t	els_did_mid;
	u_int8_t	els_did_hi;
	u_int8_t	els_reserved2;
	u_int16_t	els_reserved3;
	u_int16_t	els_ctl_flags;
	union {
		struct {
			u_int32_t	_els_bytecnt;
			u_int32_t	_els_subcode1;
			u_int32_t	_els_subcode2;
			u_int8_t	_els_reserved4[20];
		} in;
		struct {
			u_int32_t	_els_recv_bytecnt;
			u_int32_t	_els_xmit_bytecnt;
			u_int32_t	_els_xmit_dsd_length;
			u_int16_t	_els_xmit_dsd_a1500;
			u_int16_t	_els_xmit_dsd_a3116;
			u_int16_t	_els_xmit_dsd_a4732;
			u_int16_t	_els_xmit_dsd_a6348;
			u_int32_t	_els_recv_dsd_length;
			u_int16_t	_els_recv_dsd_a1500;
			u_int16_t	_els_recv_dsd_a3116;
			u_int16_t	_els_recv_dsd_a4732;
			u_int16_t	_els_recv_dsd_a6348;
		} out;
	} inout;
#define	els_bytecnt		inout.in._els_bytecnt
#define	els_subcode1		inout.in._els_subcode1
#define	els_subcode2		inout.in._els_subcode2
#define	els_reserved4		inout.in._els_reserved4
#define	els_recv_bytecnt	inout.out._els_recv_bytecnt
#define	els_xmit_bytecnt	inout.out._els_xmit_bytecnt
#define	els_xmit_dsd_length	inout.out._els_xmit_dsd_length
#define	els_xmit_dsd_a1500	inout.out._els_xmit_dsd_a1500
#define	els_xmit_dsd_a3116	inout.out._els_xmit_dsd_a3116
#define	els_xmit_dsd_a4732	inout.out._els_xmit_dsd_a4732
#define	els_xmit_dsd_a6348	inout.out._els_xmit_dsd_a6348
#define	els_recv_dsd_length	inout.out._els_recv_dsd_length
#define	els_recv_dsd_a1500	inout.out._els_recv_dsd_a1500
#define	els_recv_dsd_a3116	inout.out._els_recv_dsd_a3116
#define	els_recv_dsd_a4732	inout.out._els_recv_dsd_a4732
#define	els_recv_dsd_a6348	inout.out._els_recv_dsd_a6348
} els_t;

/*
 * A handy package structure for running FC-SCSI commands via RUN IOCB A64.
 */
typedef struct {
	u_int16_t	handle;
	u_int16_t	lun;
	u_int32_t	portid;
	u_int32_t	timeout;
	union {
		struct {
			u_int32_t data_length;
			u_int8_t do_read;
			u_int8_t pad[3];
			u_int8_t cdb[16];
			void *data_ptr;
		} beg;
		struct {
			u_int32_t data_residual;
			u_int8_t status;
			u_int8_t pad;
			u_int16_t sense_length;
			u_int8_t sense_data[32];
		} end;
	} fcd;
} isp_xcmd_t;
#endif	/* _ISPMBOX_H */
@


1.24
log
@fix a few capitalizations of QLogic.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispmbox.h,v 1.23 2009/06/24 11:00:53 krw Exp $ */
@


1.23
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d1 1
a1 1
/*     $OpenBSD: ispmbox.h,v 1.22 2008/11/02 03:17:22 krw Exp $ */
d30 1
a30 1
 * Mailbox and Queue Entry Definitions for for Qlogic ISP SCSI adapters.
d609 1
a609 1
 * For Qlogic 2X00, the high order byte of SCSI status has
@


1.22
log
@Start updating isp. Just new defines, comments, whitespace, anything that
doesn't change the .o. Use isp_stds.h.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispmbox.h,v 1.21 2008/10/27 00:46:09 krw Exp $ */
a167 4
typedef struct {
	u_int16_t param[8];
} mbreg_t;

a252 12
#define	WRITE_REQUEST_QUEUE_IN_POINTER(isp, value)	\
	ISP_WRITE(isp, isp->isp_rqstinrp, value)

#define	READ_REQUEST_QUEUE_OUT_POINTER(isp)		\
	ISP_READ(isp, isp->isp_rqstoutrp)

#define	READ_RESPONSE_QUEUE_IN_POINTER(isp)		\
	ISP_READ(isp, isp->isp_respinrp)

#define	WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, value)	\
	ISP_WRITE(isp, isp->isp_respoutrp, value)

d324 1
a324 1
#define	RQSTYPE_CSET0		0x18
a348 1
#define	req_modifier	req_cdblen	/* marker packet */
d812 1
a812 1
typedef struct isp_icb {
d884 1
a884 1
#define	ICBXOPT_ZIO		(1 << 5)
d887 4
a892 5
/* These 3 only apply to the 2300 */
#define	ICBZOPT_RATE_ONEGB	(MBGSD_ONEGB << 14)
#define	ICBZOPT_RATE_TWOGB	(MBGSD_TWOGB << 14)
#define	ICBZOPT_RATE_AUTO	(MBGSD_AUTO << 14)

a1014 16
/*
 * FC-AL Position Map
 *
 * This is an at most 128 byte map that returns either
 * the LILP or Firmware generated list of ports.
 *
 * We deviate a bit from the returned QLogic format to
 * use an extra bit to say whether this was a LILP or
 * f/w generated map.
 */
typedef struct {
	u_int8_t	fwmap	: 1,
			count	: 7;
	u_int8_t	map[127];
} fcpos_map_t;

d1068 1
a1068 1
} isp_pdb_t;
d1127 8
a1134 7

#define	FS_ACC	0x8002
#define	FS_RJT	0x8001

#define	FC4_IP		5 /* ISO/EEC 8802-2 LLC/SNAP "Out of Order Delivery" */
#define	FC4_SCSI	8 /* SCSI-3 via Fivre Channel Protocol (FCP) */
#define	FC4_FC_SVC	0x20	/* Fibre Channel Services */
@


1.21
log
@Start updating isp. Just new defines, comments, whitespace, anything that
doesn't change the .o.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispmbox.h,v 1.20 2008/01/21 20:00:33 sobrado Exp $ */
a1161 22
/*
 * CT definition
 *
 * This is as the QLogic f/w documentations defines it- which is just opposite,
 * bit wise, from what the specification defines it as. Additionally, the
 * ct_response and ct_resid (really from FC-GS-2) need to be byte swapped.
 */

typedef struct {
	u_int8_t	ct_revision;
	u_int8_t	ct_portid[3];
	u_int8_t	ct_fcs_type;
	u_int8_t	ct_fcs_subtype;
	u_int8_t	ct_options;
	u_int8_t	ct_res0;
	u_int16_t	ct_response;
	u_int16_t	ct_resid;
	u_int8_t	ct_res1;
	u_int8_t	ct_reason;
	u_int8_t	ct_explanation;
	u_int8_t	ct_vunique;
} ct_hdr_t;
@


1.20
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 28
a28 1
/*     $OpenBSD: ispmbox.h,v 1.19 2003/03/03 18:38:10 mjacob Exp $ */
d30 1
a30 26
 * Mailbox and Queue Entry Definitions for for QLogic ISP SCSI adapters.
 *
 * Copyright (c) 1997, 1998, 1999, 2000 by Matthew Jacob
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
d47 1
a47 1
					/*   9 */
d49 1
a49 1
					/*   b */
d51 1
a51 1
					/*   d */
d128 1
d149 1
d154 4
a157 3
#define	MBOX_GET_SET_DATA_RATE		0x005D	/* 23XX only */
#define		MBGSD_GET_RATE	0
#define		MBGSD_SET_RATE	1
d161 1
d185 4
d215 2
d239 2
d248 1
a248 1
 * Mailbox Usages
d250 6
d314 1
d334 1
d336 1
d349 7
d373 1
d375 24
a398 2
#define	ispreq64_t	ispreqt3_t	/* same as.... */
#define	ISP_RQDSEG_A64	2
a399 3
/*
 * A request packet can also be a marker packet.
 */
d403 1
d413 1
a413 1
	u_int16_t	_res2;
d421 14
d443 1
a443 1
	u_int16_t	_res2;
d450 15
d494 1
a494 1
	u_int16_t	_res1;
d500 70
d573 1
a573 1
	u_int32_t	_res1;
d598 3
d606 19
d626 1
a626 1
 * For QLogic 2X00, the high order byte of SCSI status has
d635 42
d721 7
d785 1
d793 12
d821 1
a821 1
 * FC (ISP2100) specific data structures
d831 1
a831 1
	u_int8_t	_reserved0;
d853 1
a853 1
	u_int16_t	_reserved1;
d858 1
a858 1
	u_int16_t	_reserved2[13];
d860 1
d863 15
a878 15
#define	ICBOPT_FAIRNESS		0x0002
#define	ICBOPT_FULL_DUPLEX	0x0004
#define	ICBOPT_FAST_POST	0x0008
#define	ICBOPT_TGT_ENABLE	0x0010
#define	ICBOPT_INI_DISABLE	0x0020
#define	ICBOPT_INI_ADISC	0x0040
#define	ICBOPT_INI_TGTTYPE	0x0080
#define	ICBOPT_PDBCHANGE_AE	0x0100
#define	ICBOPT_NOLIP		0x0200
#define	ICBOPT_SRCHDOWN		0x0400
#define	ICBOPT_PREVLOOP		0x0800
#define	ICBOPT_STOP_ON_QFULL	0x1000
#define	ICBOPT_FULL_LOGIN	0x2000
#define	ICBOPT_BOTH_WWNS	0x4000
#define	ICBOPT_EXTENDED		0x8000
d880 4
d886 10
a895 5
#define	ICBXOPT_LOOP_ONLY	(0 << 4)
#define	ICBXOPT_PTP_ONLY	(1 << 4)
#define	ICBXOPT_LOOP_2_PTP	(2 << 4)
#define	ICBXOPT_PTP_2_LOOP	(3 << 4)

d902 1
d904 2
a905 2
#define	ICBZOPT_ENA_RDXFR_RDY	0x01
#define	ICBZOPT_ENA_OOF		(1 << 6) /* out of order frame handling */
d911 48
d968 39
d1049 10
a1066 1
#define	BITS2WORD(x)	((x)[0] << 16 | (x)[3] << 8 | (x)[2])
d1127 35
d1191 71
d1270 1
a1270 1
	u_int16_t	snscb_res0;
d1273 1
a1273 1
	u_int16_t	snscb_res1;
d1279 1
a1279 1
	u_int16_t	snscb_res0;
d1282 1
a1282 1
	u_int16_t	snscb_res1;
d1284 2
a1285 2
	u_int16_t	snscb_res2;
	u_int32_t	snscb_res3;
d1292 1
a1292 1
	u_int16_t	snscb_res0;
d1295 1
a1295 1
	u_int16_t	snscb_res1;
d1297 2
a1298 2
	u_int16_t	snscb_res2;
	u_int32_t	snscb_res3;
d1305 1
a1305 1
	u_int16_t	snscb_res0;
d1308 1
a1308 1
	u_int16_t	snscb_res1;
d1311 1
a1311 1
	u_int32_t	snscb_res3;
d1318 1
a1318 1
	u_int16_t	snscb_res0;
d1321 1
a1321 1
	u_int16_t	snscb_res1;
d1323 2
a1324 2
	u_int16_t	snscb_res2;
	u_int32_t	snscb_res3;
d1378 1
d1380 3
a1382 1
#define	SNS_RFT_ID_RESP_SIZE	(sizeof (ct_hdr_t))
d1384 84
@


1.19
log
@Add some A64 defines.

Fix egregious botch where ICBXOPT_ZIO is suppose to be bit #5, not
the value '5'.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispmbox.h,v 1.18 2002/08/17 17:41:26 mjacob Exp $ */
d3 1
a3 1
 * Mailbox and Queue Entry Definitions for for Qlogic ISP SCSI adapters.
d454 1
a454 1
 * For Qlogic 2X00, the high order byte of SCSI status has
d707 1
a707 1
 * We deviate a bit from the returned qlogic format to
@


1.18
log
@Add ICBZOPT_ENA_OOF and FC4_FC_SVC defines.
@
text
@d1 1
a1 1
/*     $OpenBSD: ispmbox.h,v 1.17 2002/05/17 01:34:58 mjacob Exp $ */
d112 3
d344 3
d657 1
a657 1
#define	ICBXOPT_ZIO		5
@


1.17
log
@Add new definitions for RIO operation, many new SNS commands, and structures
(i.e., finally use a real CT Header for responses to nameserver commands).
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.16 2001/12/14 00:20:55 mjacob Exp $ */
d651 1
d807 1
@


1.16
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.15 2001/10/06 22:45:52 mjacob Exp $ */
d51 1
a51 1
					/*   f */
d107 1
d109 2
a110 1
#define		FW_FEATURE_FAST_POST	0x1
d144 3
d649 2
a650 2
#define	ICBXOPT_RIO_16BIT_DELAY	3
#define	ICBXOPT_RIO_32BIT_DELAY	4
d652 2
d779 34
a812 3
#define	SNS_GAN	0x100
#define	SNS_GP3	0x171
#define	SNS_RFT	0x217
a820 3
#define	SNS_GAN_REQ_SIZE	(sizeof (sns_screq_t)+(5*(sizeof (u_int16_t))))
#define	SNS_GP3_REQ_SIZE	(sizeof (sns_screq_t)+(5*(sizeof (u_int16_t))))
#define	SNS_RFT_REQ_SIZE	(sizeof (sns_screq_t)+(21*(sizeof (u_int16_t))))
d823 54
a876 1
	u_int8_t	snscb_cthdr[16];
a881 3
#define	SNS_GAN_RESP_SIZE	608	/* Maximum response size (bytes) */
#define	SNS_GP3_RESP_SIZE	532	/* XXX: For 128 ports */
#define	SNS_RFT_RESP_SIZE	16
d884 1
a884 1
	u_int8_t	snscb_cthdr[16];
d900 25
a924 1
} sns_ganrsp_t;	/* Subcommand Response Structure */
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.16 2001/12/14 00:20:55 mjacob Exp $ */
d51 1
a51 1
#define	MBOX_READ_RAM_WORD_EXTENDED	0x000f
d107 1
a108 3
#define		FW_FEATURE_LVD_NOTIFY	0x2
#define		FW_FEATURE_RIO_32BIT	0x4
#define		FW_FEATURE_RIO_16BIT	0x8
a141 3
#define	MBOX_DRIVER_HEARTBEAT		0x005B
#define	MBOX_FW_HEARTBEAT		0x005C

d644 2
a645 2
#define	ICBXOPT_RIO_16BIT_IOCB	3
#define	ICBXOPT_RIO_32BIT_IOCB	4
a646 2
#define	ICBZOPT_ENA_RDXFR_RDY	0x01
#define	ICBZOPT_ENA_OOF		(1 << 6) /* out of order frame handling */
d772 3
a774 34
/*
 * CT definition
 *
 * This is as the QLogic f/w documentations defines it- which is just opposite,
 * bit wise, from what the specification defines it as. Additionally, the
 * ct_response and ct_resid (really from FC-GS-2) need to be byte swapped.
 */

typedef struct {
	u_int8_t	ct_revision;
	u_int8_t	ct_portid[3];
	u_int8_t	ct_fcs_type;
	u_int8_t	ct_fcs_subtype;
	u_int8_t	ct_options;
	u_int8_t	ct_res0;
	u_int16_t	ct_response;
	u_int16_t	ct_resid;
	u_int8_t	ct_res1;
	u_int8_t	ct_reason;
	u_int8_t	ct_explanation;
	u_int8_t	ct_vunique;
} ct_hdr_t;
#define	FS_ACC	0x8002
#define	FS_RJT	0x8001

#define	FC4_IP		5 /* ISO/EEC 8802-2 LLC/SNAP "Out of Order Delivery" */
#define	FC4_SCSI	8 /* SCSI-3 via Fivre Channel Protocol (FCP) */

#define	SNS_GA_NXT	0x100
#define	SNS_GPN_ID	0x112
#define	SNS_GNN_ID	0x113
#define	SNS_GFF_ID	0x11F
#define	SNS_GID_FT	0x171
#define	SNS_RFT_ID	0x217
d783 3
d788 1
a788 54
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_res0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_res1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_res2;
	u_int32_t	snscb_res3;
	u_int32_t	snscb_port;
} sns_ga_nxt_req_t;
#define	SNS_GA_NXT_REQ_SIZE	(sizeof (sns_ga_nxt_req_t))

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_res0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_res1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_res2;
	u_int32_t	snscb_res3;
	u_int32_t	snscb_portid;
} sns_gxn_id_req_t;
#define	SNS_GXN_ID_REQ_SIZE	(sizeof (sns_gxn_id_req_t))

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_res0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_res1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_mword_div_2;
	u_int32_t	snscb_res3;
	u_int32_t	snscb_fc4_type;
} sns_gid_ft_req_t;
#define	SNS_GID_FT_REQ_SIZE	(sizeof (sns_gid_ft_req_t))

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_res0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_res1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_res2;
	u_int32_t	snscb_res3;
	u_int32_t	snscb_port;
	u_int32_t	snscb_fc4_types[8];
} sns_rft_id_req_t;
#define	SNS_RFT_ID_REQ_SIZE	(sizeof (sns_rft_id_req_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
d794 3
d799 1
a799 1
	ct_hdr_t	snscb_cthdr;
d815 1
a815 25
} sns_ga_nxt_rsp_t;	/* Subcommand Response Structure */
#define	SNS_GA_NXT_RESP_SIZE	(sizeof (sns_ga_nxt_rsp_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	u_int8_t	snscb_wwn[8];
} sns_gxn_id_rsp_t;
#define	SNS_GXN_ID_RESP_SIZE	(sizeof (sns_gxn_id_rsp_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	u_int32_t	snscb_fc4_features[32];
} sns_gff_id_rsp_t;
#define	SNS_GFF_ID_RESP_SIZE	(sizeof (sns_gff_id_rsp_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	struct {
		u_int8_t	control;
		u_int8_t	portid[3];
	} snscb_ports[1];
} sns_gid_ft_rsp_t;
#define	SNS_GID_FT_RESP_SIZE(x)	((sizeof (sns_gid_ft_rsp_t)) + ((x - 1) << 2))

#define	SNS_RFT_ID_RESP_SIZE	(sizeof (ct_hdr_t))
@


1.16.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*     $OpenBSD$ */
a650 1
#define	ICBXOPT_ZIO		5
a805 1
#define	FC4_FC_SVC	0x20	/* Fibre Channel Services */
@


1.16.2.3
log
@sync
@
text
@a111 3
#define	MBOX_INIT_REQ_QUEUE_A64		0x0052
#define	MBOX_INIT_RES_QUEUE_A64		0x0053

a340 3
#define	ispreq64_t	ispreqt3_t	/* same as.... */
#define	ISP_RQDSEG_A64	2

d651 1
a651 1
#define	ICBXOPT_ZIO		(1 << 5)
@


1.15
log
@Fix various 2300 (2Gb) last minute errata. Keep up with the jones' for
the target mode code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.14 2001/09/01 07:16:40 mjacob Exp $ */
d256 2
d268 1
a268 1
#define	_ISP_SWAP8(a, b)	{	\
a279 12
/*
 * There are no (for all intents and purposes) non-sparc SBus machines
 */
#ifdef	__sparc__
#define	ISP_SBUSIFY_ISPHDR(isp, hdrp)					\
    if ((isp)->isp_bustype == ISP_BT_SBUS) {				\
	_ISP_SWAP8((hdrp)->rqs_entry_count, (hdrp)->rqs_entry_type);	\
	_ISP_SWAP8((hdrp)->rqs_flags, (hdrp)->rqs_seqno);		\
    }
#else
#define	ISP_SBUSIFY_ISPHDR(a, b)
#endif
a342 12
/*
 * There are no (for all intents and purposes) non-sparc SBus machines
 */
#ifdef	__sparc__
#define	ISP_SBUSIFY_ISPREQ(isp, rqp)					\
    if ((isp)->isp_bustype == ISP_BT_SBUS) {				\
	_ISP_SWAP8((rqp)->req_target, (rqp)->req_lun_trn);		\
    }
#else
#define	ISP_SBUSIFY_ISPREQ(a, b)
#endif

d354 1
a354 1
	u_int32_t	req_cdb[4];
d370 1
a370 1
	u_int32_t	req_cdb[4];
d436 5
@


1.14
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.13 2001/04/04 22:09:16 mjacob Exp $ */
d110 1
a110 1
#define	MBOX_ENABLE_TARGET_MODE		0x55
d114 34
a147 1
#define	MBOX_GET_TARGET_STATUS		0x56
a148 25
/* These are for the ISP2100 FC cards */
#define	MBOX_GET_LOOP_ID		0x20
#define	MBOX_GET_FIRMWARE_OPTIONS	0x28
#define	MBOX_SET_FIRMWARE_OPTIONS	0x38
#define	MBOX_GET_RESOURCE_COUNT		0x42
#define	MBOX_ENHANCED_GET_PDB		0x47
#define	MBOX_EXEC_COMMAND_IOCB_A64	0x54
#define	MBOX_INIT_FIRMWARE		0x60
#define	MBOX_GET_INIT_CONTROL_BLOCK	0x61
#define	MBOX_INIT_LIP			0x62
#define	MBOX_GET_FC_AL_POSITION_MAP	0x63
#define	MBOX_GET_PORT_DB		0x64
#define	MBOX_CLEAR_ACA			0x65
#define	MBOX_TARGET_RESET		0x66
#define	MBOX_CLEAR_TASK_SET		0x67
#define	MBOX_ABORT_TASK_SET		0x68
#define	MBOX_GET_FW_STATE		0x69
#define	MBOX_GET_PORT_NAME		0x6a
#define	MBOX_GET_LINK_STATUS		0x6b
#define	MBOX_INIT_LIP_RESET		0x6c
#define	MBOX_SEND_SNS			0x6e
#define	MBOX_FABRIC_LOGIN		0x6f
#define	MBOX_SEND_CHANGE_REQUEST	0x70
#define	MBOX_FABRIC_LOGOUT		0x71
#define	MBOX_INIT_LIP_LOGIN		0x72
d665 3
a667 3
#define	ICBXOPT_RATE_ONEGB	(0 << 14)
#define	ICBXOPT_RATE_TWOGB	(1 << 14)
#define	ICBXOPT_RATE_AUTO	(2 << 14)
@


1.13
log
@Add some additional mailbox definitions. Rename ICBOPT_PORTNAME to
ICBOPT_BOTH_WWNS as being more descriptive.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.12 2001/02/12 23:48:29 mjacob Exp $ */
a35 1

d76 1
d118 2
d121 1
a181 4
#define	ASYNC_CMD_CMPLT			0x8020
#define	ASYNC_CTIO_DONE			0x8021

/* for ISP2100 only */
d188 9
a196 2

/* for ISP2200 only */
d198 5
d209 23
d242 16
a263 4

/*
 * These elements get swizzled around for SBus instances.
 */
d307 1
a307 1

d309 2
a310 2
#define	RQSTYPE_ATIO2		0x16
#define	RQSTYPE_CTIO2		0x17
d313 7
a319 2

#define	RQSTYPE_CTIO3		0x1f
d357 1
a357 1
#define	ISP_RQDSEG_T2	3
d373 16
d430 6
d571 14
d656 4
@


1.12
log
@Add structure defining FC-AL position maps. The only tool that I know of
that really uses this is luxadm(8) under Solaris.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.11 2001/01/09 03:28:12 mjacob Exp $ */
d112 3
d488 10
d553 1
a553 1
#define	ICBOPT_USE_PORTNAME	0x4000
@


1.11
log
@Add some FC specific state flag defines (for status completion
entries). Add some defines for the SNS "Register FC4 Type" subcommand.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.10 2000/10/16 01:02:01 mjacob Exp $ */
d591 16
@


1.10
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.9 2000/07/06 05:31:49 mjacob Exp $ */
d376 1
a376 1
 * For Qlogic 2100, the high order byte of SCSI status has
d441 9
d663 1
d674 1
d685 1
@


1.9
log
@Resync with FreeBSD/NetBSD. Salient features are that the mailbox command
routines are not necessarily polled now- this should cut down on some of
the spurious lost commands that have occurred. Also, we now watchdog each
command and make sure that command constipation doesn't occur (which it
has been documented to do on the QLA2100 cards).
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.8 2000/02/20 21:22:41 mjacob Exp $ */
d5 1
a5 3
 *---------------------------------------
 * Copyright (c) 1997, 1998, 1999 by Matthew Jacob
 * NASA/Ames Research Center
a6 1
 *---------------------------------------
d14 1
a14 4
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
d157 3
d371 1
a371 1
	u_int8_t	_res1[8];
d381 1
d383 1
a383 1
#define	RQCS_RV	0x100	/* Residual Valid */
a388 1
#define RQCS_INCOMPLETE			0x0001
a389 1
#define RQCS_TRANSPORT_ERROR		0x0003
d394 6
a412 1
#define RQCS_DATA_UNDERRUN		0x0015
a416 1
#define	RQCS_QUEUE_FULL			0x001C
d423 1
a423 1
/* 2100 Only Completion Codes */
d430 1
a430 1
 * State Flags (not applicable to 2100)
d441 1
a441 1
 * Status Flags (not applicable to 2100)
d451 23
@


1.8
log
@Add 12160 (Ultra3) support. Add files and changes for target mode support.
Do some SNS fabric suppor tchanges. Roll revision levels. Tested on
GENERIC i386 && sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.7 1999/11/22 12:50:53 mjacob Exp $ */
d121 1
d568 1
a568 1
#define	BITS2WORD(x)	(x)[0] << 16 | (x)[3] << 8 | (x)[2]
@


1.7
log
@Far too many things to note- a complete new revision coming in including
FABRIC support...
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.6 1999/04/04 02:04:40 mjacob Exp $ */
d116 3
d158 4
d189 9
d249 1
a249 1
#define	RQSTYPE_CTIO0		0x07	/* Target Mode */
d370 1
d510 14
d650 19
@


1.7.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.8 2000/02/20 21:22:41 mjacob Exp $ */
a115 3
#define	MBOX_ENABLE_TARGET_MODE		0x55
#define		ENABLE_TARGET_FLAG	0x8000

a154 4
#define	MBOX_PORT_ID_USED		0x4007
#define	MBOX_LOOP_ID_USED		0x4008
#define	MBOX_ALL_IDS_USED		0x4009
#define	MBOX_NOT_LOGGED_IN		0x400A
a181 9
/* for ISP2200 only */
#define	ASYNC_PTPMODE			0x8030
#define	ASYNC_CONNMODE			0x8036
#define		ISP_CONN_LOOP		1
#define		ISP_CONN_PTP		2
#define		ISP_CONN_BADLIP		3
#define		ISP_CONN_FATAL		4
#define		ISP_CONN_LOOPBACK	5

d233 1
a233 1
#define	RQSTYPE_CTIO		0x07	/* Target Mode */
a353 1
#define	req_response_len	req_time	/* FC only */
a492 14
#define	ICBXOPT_CLASS2_ACK0	0x0200
#define	ICBXOPT_CLASS2		0x0100
#define	ICBXOPT_LOOP_ONLY	(0 << 4)
#define	ICBXOPT_PTP_ONLY	(1 << 4)
#define	ICBXOPT_LOOP_2_PTP	(2 << 4)
#define	ICBXOPT_PTP_2_LOOP	(3 << 4)

#define	ICBXOPT_RIO_OFF		0
#define	ICBXOPT_RIO_16BIT	1
#define	ICBXOPT_RIO_32BIT	2
#define	ICBXOPT_RIO_16BIT_DELAY	3
#define	ICBXOPT_RIO_32BIT_DELAY	4


a618 19

typedef struct {
	u_int8_t	snscb_cthdr[16];
	u_int8_t	snscb_port_type;
	u_int8_t	snscb_port_id[3];
	u_int8_t	snscb_portname[8];
	u_int8_t	snscb_pnlen;		/* symbolic port name length */
	u_int8_t	snscb_pname[255];	/* symbolic port name */
	u_int8_t	snscb_nodename[8];
	u_int8_t	snscb_nnlen;		/* symbolic node name length */
	u_int8_t	snscb_nname[255];	/* symbolic node name */
	u_int8_t	snscb_ipassoc[8];
	u_int8_t	snscb_ipaddr[16];
	u_int8_t	snscb_svc_class[4];
	u_int8_t	snscb_fc4_types[32];
	u_int8_t	snscb_fpname[8];
	u_int8_t	snscb_reserved;
	u_int8_t	snscb_hardaddr[3];
} sns_ganrsp_t;	/* Subcommand Response Structure */
@


1.7.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.13 2001/04/04 22:09:16 mjacob Exp $ */
d5 3
a7 1
 * Copyright (c) 1997, 1998, 1999, 2000 by Matthew Jacob
d9 1
d17 4
a20 1
 * 2. The name of the author may not be used to endorse or promote products
a117 3
#define		ENABLE_TQING_FLAG	0x0004
#define		ENABLE_MANDATORY_DISC	0x0002
#define	MBOX_GET_TARGET_STATUS		0x56
a120 1
#define	MBOX_GET_RESOURCE_COUNT		0x42
a161 3
#define	MBLOGALL			0x000f
#define	MBLOGNONE			0x0000
#define	MBLOGMASK(x)			((x) & 0xf)
d373 1
a373 1
	u_int8_t	req_response[8];	/* FC only */
d378 1
a378 1
 * For Qlogic 2X00, the high order byte of SCSI status has
a382 1
#define	RQCS_RESID	(RQCS_RU|RQCS_RO)
d384 1
a384 1
#define	RQCS_RV	0x100	/* FCP Response Length Valid */
d390 1
d392 1
a396 6
#define RQCS_DATA_UNDERRUN		0x0015
#define	RQCS_QUEUE_FULL			0x001C

/* 1X00 Only Completion Codes */
#define RQCS_INCOMPLETE			0x0001
#define RQCS_TRANSPORT_ERROR		0x0003
d410 1
d415 1
d422 1
a422 1
/* 2X00 Only Completion Codes */
d429 1
a429 1
 * 1X00 specific State Flags 
d440 1
a440 10
 * 2X00 specific State Flags
 * (same as 1X00 except RQSF_GOT_BUS/RQSF_GOT_TARGET are not available)
 */
#define	RQSF_DATA_IN			0x0020
#define	RQSF_DATA_OUT			0x0040
#define	RQSF_STAG			0x0008
#define	RQSF_OTAG			0x0004
#define	RQSF_HTAG			0x0002
/*
 * 1X00 Status Flags
a451 33
 * 2X00 specific state flags
 */
/* RQSF_SENT_CDB	*/
/* RQSF_XFRD_DATA	*/
/* RQSF_GOT_STATUS	*/
/* RQSF_XFER_COMPLETE	*/

/*
 * 2X00 specific status flags
 */
/* RQSTF_ABORTED */
/* RQSTF_TIMEOUT */
#define	RQSTF_DMA_ERROR			0x0080
#define	RQSTF_LOGOUT			0x2000

/*
 * Miscellaneous
 */
#ifndef	ISP_EXEC_THROTTLE
#define	ISP_EXEC_THROTTLE	16
#endif

/*
 * About Firmware returns an 'attribute' word in mailbox 6.
 */
#define	ISP_FW_ATTR_TMODE	0x01
#define	ISP_FW_ATTR_SCCLUN	0x02
#define	ISP_FW_ATTR_FABRIC	0x04
#define	ISP_FW_ATTR_CLASS2	0x08
#define	ISP_FW_ATTR_FCTAPE	0x10
#define	ISP_FW_ATTR_IP		0x20

/*
d507 1
a507 1
#define	ICBOPT_BOTH_WWNS	0x4000
a559 16
 * FC-AL Position Map
 *
 * This is an at most 128 byte map that returns either
 * the LILP or Firmware generated list of ports.
 *
 * We deviate a bit from the returned qlogic format to
 * use an extra bit to say whether this was a LILP or
 * f/w generated map.
 */
typedef struct {
	u_int8_t	fwmap	: 1,
			count	: 7;
	u_int8_t	map[127];
} fcpos_map_t;

/*
d567 1
a567 1
#define	BITS2WORD(x)	((x)[0] << 16 | (x)[3] << 8 | (x)[2])
a629 1
#define	SNS_RFT	0x217
a639 1
#define	SNS_RFT_REQ_SIZE	(sizeof (sns_screq_t)+(21*(sizeof (u_int16_t))))
a649 1
#define	SNS_RFT_RESP_SIZE	16
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ispmbox.h,v 1.7.2.2 2001/05/14 22:23:57 niklas Exp $ */
d36 1
a76 1
#define		MBOX_GET_PCI_PARAMS	MBOX_GET_SBUS_PARAMS
d110 1
a110 1
#define	MBOX_ENABLE_TARGET_MODE		0x0055
d114 1
a114 34
#define	MBOX_GET_TARGET_STATUS		0x0056

/* These are for the ISP2X00 FC cards */
#define	MBOX_GET_LOOP_ID		0x0020
#define	MBOX_GET_FIRMWARE_OPTIONS	0x0028
#define	MBOX_SET_FIRMWARE_OPTIONS	0x0038
#define	MBOX_GET_RESOURCE_COUNT		0x0042
#define	MBOX_ENHANCED_GET_PDB		0x0047
#define	MBOX_EXEC_COMMAND_IOCB_A64	0x0054
#define	MBOX_INIT_FIRMWARE		0x0060
#define	MBOX_GET_INIT_CONTROL_BLOCK	0x0061
#define	MBOX_INIT_LIP			0x0062
#define	MBOX_GET_FC_AL_POSITION_MAP	0x0063
#define	MBOX_GET_PORT_DB		0x0064
#define	MBOX_CLEAR_ACA			0x0065
#define	MBOX_TARGET_RESET		0x0066
#define	MBOX_CLEAR_TASK_SET		0x0067
#define	MBOX_ABORT_TASK_SET		0x0068
#define	MBOX_GET_FW_STATE		0x0069
#define	MBOX_GET_PORT_NAME		0x006A
#define	MBOX_GET_LINK_STATUS		0x006B
#define	MBOX_INIT_LIP_RESET		0x006C
#define	MBOX_SEND_SNS			0x006E
#define	MBOX_FABRIC_LOGIN		0x006F
#define	MBOX_SEND_CHANGE_REQUEST	0x0070
#define	MBOX_FABRIC_LOGOUT		0x0071
#define	MBOX_INIT_LIP_LOGIN		0x0072

#define	MBOX_GET_SET_DATA_RATE		0x005D	/* 23XX only */
#define		MBGSD_GET_RATE	0
#define		MBGSD_SET_RATE	1
#define		MBGSD_ONEGB	0
#define		MBGSD_TWOGB	1
#define		MBGSD_AUTO	2
d116 22
d179 4
d189 2
a190 9
#define	ASYNC_LIP_F8			0x8016
#define	ASYNC_CMD_CMPLT			0x8020
#define	ASYNC_CTIO_DONE			0x8021
#define	ASYNC_IP_XMIT_DONE		0x8022
#define	ASYNC_IP_RECV_DONE		0x8023
#define	ASYNC_IP_BROADCAST		0x8024
#define	ASYNC_IP_RCVQ_LOW		0x8025
#define	ASYNC_IP_RCVQ_EMPTY		0x8026
#define	ASYNC_IP_RECV_DONE_ALIGNED	0x8027
a191 5
#define	ASYNC_RIO1			0x8031
#define	ASYNC_RIO2			0x8032
#define	ASYNC_RIO3			0x8033
#define	ASYNC_RIO4			0x8034
#define	ASYNC_RIO5			0x8035
a197 23
#define	ASYNC_RIO_RESP			0x8040
#define	ASYNC_RIO_COMP			0x8042
/*
 * 2.01.31 2200 Only. Need Bit 13 in Mailbox 1 for Set Firmware Options
 * mailbox command to enable this.
 */
#define	ASYNC_QFULL_SENT		0x8049

/*
 * Mailbox Usages
 */

#define	WRITE_REQUEST_QUEUE_IN_POINTER(isp, value)	\
	ISP_WRITE(isp, isp->isp_rqstinrp, value)

#define	READ_REQUEST_QUEUE_OUT_POINTER(isp)		\
	ISP_READ(isp, isp->isp_rqstoutrp)

#define	READ_RESPONSE_QUEUE_IN_POINTER(isp)		\
	ISP_READ(isp, isp->isp_respinrp)

#define	WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, value)	\
	ISP_WRITE(isp, isp->isp_respoutrp, value)
a207 16
typedef struct {
	u_int32_t	ds_base;
	u_int32_t	ds_basehi;
	u_int32_t	ds_count;
} ispds64_t;

typedef struct {
	u_int16_t	ds_type;	/* 0-> ispds_t, 1-> ispds64_t */
	u_int32_t	ds_segment;	/* unused */
	u_int32_t	ds_base;	/* 32 bit address of DSD list */
} ispdslist_t;


/*
 * These elements get swizzled around for SBus instances.
 */
d214 4
d261 1
a261 1
#define	RQSTYPE_IP_XMIT		0x13
d263 2
a264 2
#define	RQSTYPE_ATIO2		0x16	/* Target Mode */
#define	RQSTYPE_CTIO2		0x17	/* Target Mode */
d267 2
a268 7
#define	RQSTYPE_IP_XMIT_64	0x1b
#define	RQSTYPE_CTIO4		0x1e	/* Target Mode */
#define	RQSTYPE_CTIO3		0x1f	/* Target Mode */
#define	RQSTYPE_RIO1		0x21
#define	RQSTYPE_RIO2		0x22
#define	RQSTYPE_IP_RECV		0x23
#define	RQSTYPE_IP_RECV_CONT	0x24
d306 1
a306 1
#define	ISP_RQDSEG_T2		3
a321 16
#define	ISP_RQDSEG_T3		2
typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handle;
	u_int8_t	req_lun_trn;
	u_int8_t	req_target;
	u_int16_t	req_scclun;
	u_int16_t	req_flags;
	u_int16_t	_res2;
	u_int16_t	req_time;
	u_int16_t	req_seg_count;
	u_int32_t	req_cdb[4];
	u_int32_t	req_totalcnt;
	ispds64_t	req_dataseg[ISP_RQDSEG_T3];
} ispreqt3_t;

a362 6
#define	ISP_CDSEG64	5
typedef struct {
	isphdr_t	req_header;
	ispds64_t	req_dataseg[ISP_CDSEG64];
} ispcontreq64_t;

a497 14
 * Reduced Interrupt Operation Response Queue Entreis
 */

typedef struct {
	isphdr_t	req_header;
	u_int32_t	req_handles[15];
} isp_rio1_t;

typedef struct {
	isphdr_t	req_header;
	u_int16_t	req_handles[30];
} isp_rio2_t;

/*
a568 4
/* These 3 only apply to the 2300 */
#define	ICBZOPT_RATE_ONEGB	(MBGSD_ONEGB << 14)
#define	ICBZOPT_RATE_TWOGB	(MBGSD_TWOGB << 14)
#define	ICBZOPT_RATE_AUTO	(MBGSD_AUTO << 14)
@


1.7.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a255 2
#define	DSTYPE_32BIT	0
#define	DSTYPE_64BIT	1
d266 1
a266 1
#define	ISP_SWAP8(a, b)	{		\
d278 12
d353 12
d376 1
a376 1
	u_int8_t	req_cdb[16];
d392 1
a392 1
	u_int8_t	req_cdb[16];
a457 5

typedef struct {
	isphdr_t	req_header;
	u_int8_t	req_sense_data[60];
} ispstatus_cont_t;
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*     $OpenBSD$ */
d51 1
a51 1
#define	MBOX_READ_RAM_WORD_EXTENDED	0x000f
d107 1
a108 6
#define		FW_FEATURE_LVD_NOTIFY	0x2
#define		FW_FEATURE_RIO_32BIT	0x4
#define		FW_FEATURE_RIO_16BIT	0x8

#define	MBOX_INIT_REQ_QUEUE_A64		0x0052
#define	MBOX_INIT_RES_QUEUE_A64		0x0053
a141 3
#define	MBOX_DRIVER_HEARTBEAT		0x005B
#define	MBOX_FW_HEARTBEAT		0x005C

a335 3
#define	ispreq64_t	ispreqt3_t	/* same as.... */
#define	ISP_RQDSEG_A64	2

d644 2
a645 3
#define	ICBXOPT_RIO_16BIT_IOCB	3
#define	ICBXOPT_RIO_32BIT_IOCB	4
#define	ICBXOPT_ZIO		(1 << 5)
a646 2
#define	ICBZOPT_ENA_RDXFR_RDY	0x01
#define	ICBZOPT_ENA_OOF		(1 << 6) /* out of order frame handling */
d772 3
a774 35
/*
 * CT definition
 *
 * This is as the QLogic f/w documentations defines it- which is just opposite,
 * bit wise, from what the specification defines it as. Additionally, the
 * ct_response and ct_resid (really from FC-GS-2) need to be byte swapped.
 */

typedef struct {
	u_int8_t	ct_revision;
	u_int8_t	ct_portid[3];
	u_int8_t	ct_fcs_type;
	u_int8_t	ct_fcs_subtype;
	u_int8_t	ct_options;
	u_int8_t	ct_res0;
	u_int16_t	ct_response;
	u_int16_t	ct_resid;
	u_int8_t	ct_res1;
	u_int8_t	ct_reason;
	u_int8_t	ct_explanation;
	u_int8_t	ct_vunique;
} ct_hdr_t;
#define	FS_ACC	0x8002
#define	FS_RJT	0x8001

#define	FC4_IP		5 /* ISO/EEC 8802-2 LLC/SNAP "Out of Order Delivery" */
#define	FC4_SCSI	8 /* SCSI-3 via Fivre Channel Protocol (FCP) */
#define	FC4_FC_SVC	0x20	/* Fibre Channel Services */

#define	SNS_GA_NXT	0x100
#define	SNS_GPN_ID	0x112
#define	SNS_GNN_ID	0x113
#define	SNS_GFF_ID	0x11F
#define	SNS_GID_FT	0x171
#define	SNS_RFT_ID	0x217
d783 3
d788 1
a788 54
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_res0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_res1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_res2;
	u_int32_t	snscb_res3;
	u_int32_t	snscb_port;
} sns_ga_nxt_req_t;
#define	SNS_GA_NXT_REQ_SIZE	(sizeof (sns_ga_nxt_req_t))

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_res0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_res1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_res2;
	u_int32_t	snscb_res3;
	u_int32_t	snscb_portid;
} sns_gxn_id_req_t;
#define	SNS_GXN_ID_REQ_SIZE	(sizeof (sns_gxn_id_req_t))

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_res0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_res1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_mword_div_2;
	u_int32_t	snscb_res3;
	u_int32_t	snscb_fc4_type;
} sns_gid_ft_req_t;
#define	SNS_GID_FT_REQ_SIZE	(sizeof (sns_gid_ft_req_t))

typedef struct {
	u_int16_t	snscb_rblen;	/* response buffer length (words) */
	u_int16_t	snscb_res0;
	u_int16_t	snscb_addr[4];	/* response buffer address */
	u_int16_t	snscb_sblen;	/* subcommand buffer length (words) */
	u_int16_t	snscb_res1;
	u_int16_t	snscb_cmd;
	u_int16_t	snscb_res2;
	u_int32_t	snscb_res3;
	u_int32_t	snscb_port;
	u_int32_t	snscb_fc4_types[8];
} sns_rft_id_req_t;
#define	SNS_RFT_ID_REQ_SIZE	(sizeof (sns_rft_id_req_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
d794 3
d799 1
a799 1
	ct_hdr_t	snscb_cthdr;
d815 1
a815 25
} sns_ga_nxt_rsp_t;	/* Subcommand Response Structure */
#define	SNS_GA_NXT_RESP_SIZE	(sizeof (sns_ga_nxt_rsp_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	u_int8_t	snscb_wwn[8];
} sns_gxn_id_rsp_t;
#define	SNS_GXN_ID_RESP_SIZE	(sizeof (sns_gxn_id_rsp_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	u_int32_t	snscb_fc4_features[32];
} sns_gff_id_rsp_t;
#define	SNS_GFF_ID_RESP_SIZE	(sizeof (sns_gff_id_rsp_t))

typedef struct {
	ct_hdr_t	snscb_cthdr;
	struct {
		u_int8_t	control;
		u_int8_t	portid[3];
	} snscb_ports[1];
} sns_gid_ft_rsp_t;
#define	SNS_GID_FT_RESP_SIZE(x)	((sizeof (sns_gid_ft_rsp_t)) + ((x - 1) << 2))

#define	SNS_RFT_ID_RESP_SIZE	(sizeof (ct_hdr_t))
@


1.6
log
@Roll out changes because the tree is frozen.
@
text
@d1 1
a1 2
/*	$OpenBSD: ispmbox.h,v 1.5 1999/04/04 01:33:13 mjacob Exp $ */
/* release_03_25_99 */
d6 1
a6 1
 * Copyright (c) 1997, 1998 by Matthew Jacob
d85 1
a85 1
					/*  2a */
d96 1
a96 1
#define MBOX_SET_ACTIVE_NEG_STATE	0x0035
d102 1
a102 1
					/*  3a */
d132 4
d191 10
a201 6
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	rqs_entry_count;
	u_int8_t	rqs_entry_type;
	u_int8_t	rqs_flags;
	u_int8_t	rqs_seqno;
#else
d206 12
a218 1
} isphdr_t;
a257 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	req_target;
	u_int8_t	req_lun_trn;
#else
a259 1
#endif
d270 19
a292 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	req_target;
	u_int8_t	req_lun_trn;
#else
a294 1
#endif
a328 4
#if	BYTE_ORDER == BIG_ENDIAN
	u_int8_t	req_target;
	u_int8_t	req_lun_trn;
#else
a330 1
#endif
a347 20
	u_int32_t	_res1;
#if	BYTE_ORDER == BIG_ENDIAN
	u_int8_t	req_target;
	u_int8_t	req_lun_trn;
	u_int8_t	_res2;
	u_int8_t	req_modifier;
#else
	u_int8_t	req_lun_trn;
	u_int8_t	req_target;
	u_int8_t	req_modifier;
	u_int8_t	_res2;
#endif
} ispmarkreq_t;

#define SYNC_DEVICE	0
#define SYNC_TARGET	1
#define SYNC_ALL	2

typedef struct {
	isphdr_t	req_header;
d441 1
a441 1
 * Version One format.
d443 1
a443 5
typedef struct {
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	_reserved0;
	u_int8_t	icb_version;
#else
d446 2
a447 3
#endif
        u_int16_t	icb_fwoptions;
        u_int16_t	icb_maxfrmlen;
a449 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	icb_retry_delay;
	u_int8_t	icb_retry_count;
#else
d452 1
a452 2
#endif
        u_int8_t	icb_nodename[8];
a453 2
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	_reserved1;
d455 2
a456 5
#else
	u_int8_t	icb_iqdevtype;
	u_int8_t	_reserved1;
#endif
        u_int8_t	icb_portname[8];
d459 14
a472 4
        u_int16_t	icb_rqstqlen;
        u_int16_t	icb_rsltqlen;
        u_int16_t	icb_rqstaddr[4];
        u_int16_t	icb_respaddr[4];
d476 16
a491 15
#define	ICBOPT_HARD_ADDRESS	(1<<0)
#define	ICBOPT_FAIRNESS		(1<<1)
#define	ICBOPT_FULL_DUPLEX	(1<<2)
#define	ICBOPT_FAST_POST	(1<<3)
#define	ICBOPT_TGT_ENABLE	(1<<4)
#define	ICBOPT_INI_DISABLE	(1<<5)
#define	ICBOPT_INI_ADISC	(1<<6)
#define	ICBOPT_INI_TGTTYPE	(1<<7)
#define	ICBOPT_PDBCHANGE_AE	(1<<8)
#define	ICBOPT_NOLIP		(1<<9)
#define	ICBOPT_SRCHDOWN		(1<<10)
#define	ICBOPT_PREVLOOP		(1<<11)
#define	ICBOPT_STOP_ON_QFULL	(1<<12)
#define	ICBOPT_FULL_LOGIN	(1<<13)
#define	ICBOPT_USE_PORTNAME	(1<<14)
d497 5
d508 1
a533 4
#if	BYTE_ORDER == BIG_ENDIAN
	u_int8_t	pdb_sstate;
	u_int8_t	pdb_mstate;
#else
d536 1
a536 8
#endif
#if BYTE_ORDER == BIG_ENDIAN
#define	BITS2WORD(x)	\
	(x)[1] << 16 | (x)[2] << 8 | (x)[3]
#else
#define	BITS2WORD(x)	\
	(x)[0] << 16 | (x)[3] << 8 | (x)[2]
#endif
a542 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	pdb_retry_delay;
	u_int8_t	pdb_retry_count;
#else
a544 1
#endif
a553 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	pdb_initiator;	/* PLOGI, Class 3 Control Flags */
	u_int8_t	pdb_target;
#else
a555 1
#endif
a573 2
#define	INVALID_PDB_OPTIONS	0xDEAD

d595 1
d597 2
a598 9
/*
 * Target Mode Structures
 */
#define TGTSVALID	0x80	/* scsi status & sense data valid */
#define	SUGGSENSELEN	18

/*
 * Structure for Enable Lun and Modify Lun queue entries
 */
d600 19
a618 410
	isphdr_t		le_header;
	u_int32_t		le_reserved2;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t		le_lun;
	u_int8_t		le_rsvd;
	u_int8_t		le_ops;		/* Modify LUN only */
	u_int8_t		le_tgt;		/* Not for FC */
#endif
	u_int32_t		le_flags;	/* Not for FC */
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t		le_status;
	u_int8_t		le_rsvd2;
	u_int8_t		le_cmd_count;
	u_int8_t		le_in_count;
	u_int8_t		le_cdb6len;	/* Not for FC */
	u_int8_t		le_cdb7len;	/* Not for FC */
#endif
	u_int16_t		le_timeout;
	u_int16_t		le_reserved[20];
} lun_entry_t;

/*
 * le_flags values
 */
#define LUN_TQAE	0x00000001	/* Tagged Queue Action Enable */
#define LUN_DSSM	0x01000000	/* Disable Sending SDP Message */
#define LUN_DM		0x40000000	/* Disconnects Mandatory */

/*
 * le_ops values
 */
#define LUN_CCINCR	0x01	/* increment command count */
#define LUN_CCDECR	0x02	/* decrement command count */
#define LUN_ININCR	0x40	/* increment immed. notify count */
#define LUN_INDECR	0x80	/* decrement immed. notify count */

/*
 * le_status values
 */
#define LUN_ERR		0x04	/* request completed with error */
#define LUN_INVAL	0x06	/* invalid request */
#define LUN_NOCAP	0x16	/* can't provide requested capability */
#define LUN_ENABLED	0x3E	/* LUN already enabled */

/*
 * Immediate Notify Entry structure
 */
#define IN_MSGLEN	8	/* 8 bytes */
#define IN_RSVDLEN	8	/* 8 words */
typedef struct {
	isphdr_t	in_header;
	u_int32_t	in_reserved2;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	in_lun;			/* lun */
	u_int8_t	in_iid;			/* initiator */
	u_int8_t	in_rsvd;
	u_int8_t	in_tgt;			/* target */
#endif
	u_int32_t	in_flags;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	in_status;
	u_int8_t	in_rsvd2;
	u_int8_t	in_tag_val;		/* tag value */
	u_int8_t	in_tag_type;		/* tag type */
#endif
	u_int16_t	in_seqid;		/* sequence id */
	u_int8_t	in_msg[IN_MSGLEN];	/* SCSI message bytes */
	u_int16_t	in_reserved[IN_RSVDLEN];
	u_int8_t	in_sense[SUGGSENSELEN];	/* suggested sense data */
} in_entry_t;

typedef struct {
	isphdr_t	in_header;
	u_int32_t	in_reserved2;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	in_lun;		/* lun */
	u_int8_t	in_iid;		/* initiator */
#endif
	u_int16_t	in_rsvd;
	u_int32_t	in_rsvd2;
	u_int16_t	in_status;
	u_int16_t	in_task_flags;
	u_int16_t	in_seqid;	/* sequence id */
} in_fcentry_t;

/*
 * Values for the in_status field
 */
#define IN_NO_RCAP	0x16	/* requested capability not available */
#define IN_IDE_RECEIVED	0x33	/* Initiator Detected Error msg received */
#define IN_RSRC_UNAVAIL	0x34	/* resource unavailable */
#define IN_MSG_RECEIVED	0x36	/* SCSI message received */
#define	IN_PORT_LOGOUT	0x29	/* port has logged out (FC) */
#define	IN_ABORT_TASK	0x20	/* task named in RX_ID is being aborted (FC) */

/*
 * Notify Acknowledge Entry structure
 */
#define NA_RSVDLEN	22
typedef struct {
	isphdr_t	na_header;
	u_int32_t	na_reserved2;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	na_lun;		/* lun */
	u_int8_t	na_iid;		/* initiator */
	u_int8_t	na_rsvd;
	u_int8_t	na_tgt;		/* target */
#endif
	u_int32_t	na_flags;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	na_status;
	u_int8_t	na_event;
#endif
	u_int16_t	na_seqid;	/* sequence id */
	u_int16_t	na_reserved[NA_RSVDLEN];
} na_entry_t;

/*
 * Value for the na_event field
 */
#define NA_RST_CLRD	0x80	/* Clear an async event notification */

#define	NA2_RSVDLEN	21
typedef struct {
	isphdr_t	na_header;
	u_int32_t	na_reserved2;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	na_lun;		/* lun */
	u_int8_t	na_iid;		/* initiator */
#endif
	u_int16_t	na_rsvd;
	u_int16_t	na_flags;
	u_int16_t	na_rsvd2;
	u_int16_t	na_status;
	u_int16_t	na_task_flags;
	u_int16_t	na_seqid;	/* sequence id */
	u_int16_t	na_reserved[NA2_RSVDLEN];
} na_fcentry_t;
#define	NAFC_RST_CLRD	0x40

/*
 * Value for the na_event field
 */
#define NA_RST_CLRD	0x80	/* Clear an async event notification */
/*
 * Accept Target I/O Entry structure
 */
#define ATIO_CDBLEN	26

typedef struct {
	isphdr_t	at_header;
	u_int32_t	at_reserved2;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	at_lun;			/* lun */
	u_int8_t	at_iid;			/* initiator */
	u_int8_t	at_cdblen;	 	/* cdb length */
	u_int8_t	at_tgt;			/* target */
#endif
	u_int32_t	at_flags;	
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	at_status;		/* firmware status */
	u_int8_t	at_scsi_status;		/* scsi status */
	u_int8_t	at_tag_val;		/* tag value */
	u_int8_t	at_tag_type;		/* tag type */
#endif
	u_int8_t	at_cdb[ATIO_CDBLEN];	/* received CDB */
	u_int8_t	at_sense[SUGGSENSELEN];	/* suggested sense data */
} at_entry_t;

/*
 * at_flags values
 */
#define AT_NODISC	0x00008000	/* disconnect disabled */
#define AT_TQAE		0x00000001	/* Tagged Queue Action enabled */

/*
 * at_status values
 */
#define AT_PATH_INVALID	0x07	/* ATIO sent to firmware for disabled lun */
#define AT_PHASE_ERROR	0x14	/* Bus phase sequence error */
#define AT_NOCAP	0x16	/* Requested capability not available */
#define AT_BDR_MSG	0x17	/* Bus Device Reset msg received */
#define AT_CDB		0x3D	/* CDB received */

/*
 * Accept Target I/O Entry structure, Type 2
 */
#define ATIO2_CDBLEN	16

typedef struct {
	isphdr_t	at_header;	
	u_int32_t	at_reserved2;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	at_lun;			/* lun */
	u_int8_t	at_iid;			/* initiator */
#endif
	u_int16_t	at_rxid;	 	/* response ID */
	u_int16_t	at_flags;
	u_int16_t	at_status;		/* firmware status */
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	at_reserved1;
	u_int8_t	at_taskcodes;
	u_int8_t	at_taskflags;
	u_int8_t	at_execodes;
#endif
	u_int8_t	at_cdb[ATIO2_CDBLEN];	/* received CDB */
	u_int32_t	at_datalen;		/* allocated data len */
	u_int16_t	at_scclun;
	u_int16_t	at_reserved3;
	u_int16_t	at_scsi_status;
	u_int8_t	at_sense[SUGGSENSELEN];	/* suggested sense data */
} at2_entry_t;

#define	ATIO2_TC_ATTR_MASK	0x7
#define	ATIO2_TC_ATTR_SIMPLEQ	0
#define	ATIO2_TC_ATTR_HEADOFQ	1
#define	ATIO2_TC_ATTR_ORDERED	2
#define	ATIO2_TC_ATTR_ACAQ	4
#define	ATIO2_TC_ATTR_UNTAGGED	5
#define	TC2TT(code)	\
	(((code) == ATIO2_TC_ATTR_SIMPLEQ)? 0x20 : \
	(((code) == ATIO2_TC_ATTR_HEADOFQ)? 0x21 : \
	(((code) == ATIO2_TC_ATTR_ORDERED)? 0x22 : \
	(((code) == ATIO2_TC_ATTR_ACAQ)? 0x24 : 0))))
	     

/*
 * Continue Target I/O Entry structure
 * Request from driver. The response from the
 * ISP firmware is the same except that the last 18
 * bytes are overwritten by suggested sense data if
 * the 'autosense valid' bit is set in the status byte.
 */
typedef struct {
	isphdr_t	ct_header;
	u_int32_t	ct_reserved;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	ct_lun;		/* lun */
	u_int8_t	ct_iid;		/* initiator id */
	u_int8_t	ct_rsvd;
	u_int8_t	ct_tgt;		/* our target id */
#endif
	u_int32_t	ct_flags;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t 	ct_status;	/* isp status */
	u_int8_t 	ct_scsi_status;	/* scsi status */
	u_int8_t 	ct_tag_val;	/* tag value */
	u_int8_t 	ct_tag_type;	/* tag type */
#endif
	u_int32_t	ct_xfrlen;	/* transfer length */
	u_int32_t	ct_resid;	/* residual length */
	u_int16_t	ct_timeout;
	u_int16_t	ct_seg_count;
	ispds_t		ct_dataseg[ISP_RQDSEG];
} ct_entry_t;

/*
 * ct_flags values
 */
#define CT_TQAE		0x00000001	/* Tagged Queue Action enable */
#define CT_DATA_IN	0x00000040	/* Data direction */
#define CT_DATA_OUT	0x00000080	/* Data direction */
#define CT_NO_DATA	0x000000C0	/* Data direction */
#define CT_DATAMASK	0x000000C0	/* Data direction */
#define CT_NODISC	0x00008000	/* Disconnects disabled */
#define CT_DSDP		0x01000000	/* Disable Save Data Pointers */
#define CT_SENDRDP	0x04000000	/* Send Restore Pointers msg */
#define CT_SENDSTATUS	0x80000000	/* Send SCSI status byte */

/*
 * ct_status values
 * - set by the firmware when it returns the CTIO
 */
#define CT_OK		0x01	/* completed without error */
#define CT_ABORTED	0x02	/* aborted by host */
#define CT_ERR		0x04	/* see sense data for error */
#define CT_INVAL	0x06	/* request for disabled lun */
#define CT_NOPATH	0x07	/* invalid ITL nexus */
#define	CT_INVRXID	0x08	/* (FC only) Invalid RX_ID */
#define CT_RSELTMO	0x0A	/* reselection timeout after 2 tries */
#define CT_TIMEOUT	0x0B	/* timed out */
#define CT_RESET	0x0E	/* SCSI Bus Reset occurred */
#define CT_PHASE_ERROR	0x14	/* Bus phase sequence error */
#define CT_BDR_MSG	0x17	/* Bus Device Reset msg received */
#define CT_TERMINATED	0x19	/* due to Terminate Transfer mbox cmd */
#define	CT_LOGOUT	0x29	/* port logout not acknowledged yet */
#define CT_NOACK	0x35	/* Outstanding Immed. Notify. entry */

/*
 * When the firmware returns a CTIO entry, it may overwrite the last
 * part of the structure with sense data. This starts at offset 0x2E
 * into the entry, which is in the middle of ct_dataseg[1]. Rather
 * than define a new struct for this, I'm just using the sense data
 * offset.
 */
#define CTIO_SENSE_OFFSET	0x2E

/*
 * Entry length in u_longs. All entries are the same size so
 * any one will do as the numerator.
 */
#define UINT32_ENTRY_SIZE	(sizeof(at_entry_t)/sizeof(u_int32_t))

/*
 * QLA2100 CTIO (type 2) entry
 */
#define	MAXRESPLEN	26
typedef struct {
	isphdr_t	ct_header;
	u_int32_t	ct_reserved;
#if	BYTE_ORDER == BIG_ENDIAN
#else
	u_int8_t	ct_lun;		/* lun */
	u_int8_t	ct_iid;		/* initiator id */
#endif
	u_int16_t	ct_rxid;	 /* response ID */
	u_int16_t	ct_flags;
	u_int16_t 	ct_status;	/* isp status */
	u_int16_t	ct_timeout;
	u_int16_t	ct_seg_count;
	u_int32_t	ct_reloff;	/* relative offset */
	u_int32_t	ct_resid;	/* residual length */
	union {
		/*
		 * The three different modes that the target driver
		 * can set the CTIO2 up as.
		 *
		 * The first is for sending FCP_DATA_IUs as well as
		 * (optionally) sending a terminal SCSI status FCP_RSP_IU.
		 *
		 * The second is for sending SCSI sense data in an FCP_RSP_IU.
		 * Note that no FCP_DATA_IUs will be sent.
		 *
		 * The third is for sending FCP_RSP_IUs as built specifically
		 * in system memory as located by the isp_dataseg.
		 */
		struct {
			u_int32_t _reserved;
			u_int16_t _reserved2;
			u_int16_t ct_scsi_status;
			u_int32_t ct_xfrlen;
			ispds_t   ct_dataseg[ISP_RQDSEG_T2];
		} m0;
		struct {
			u_int16_t _reserved;
			u_int16_t _reserved2;
			u_int16_t ct_senselen;
			u_int16_t ct_scsi_status;
			u_int16_t ct_resplen;
			u_int8_t  ct_resp[MAXRESPLEN];
		} m1;
		struct {
			u_int32_t _reserved;
			u_int16_t _reserved2;
			u_int16_t _reserved3;
			u_int32_t ct_datalen;
			ispds_t ct_fcp_rsp_iudata;
		} m2;
		/*
		 * CTIO2 returned from F/W...
		 */
		struct {
			u_int32_t _reserved[4];
			u_int16_t ct_scsi_status;
			u_int8_t  ct_sense[SUGGSENSELEN];
		} fw;
	} rsp;
} ct2_entry_t;
/*
 * ct_flags values for CTIO2
 */
#define	CT2_FLAG_MMASK	0x0003
#define	CT2_FLAG_MODE0	0x0000
#define	CT2_FLAG_MODE1	0x0001
#define	CT2_FLAG_MODE2	0x0002
#define CT2_DATA_IN	CT_DATA_IN
#define CT2_DATA_OUT	CT_DATA_OUT
#define CT2_NO_DATA	CT_NO_DATA
#define CT2_DATAMASK	CT_DATA_MASK
#define	CT2_CCINCR	0x0100
#define	CT2_FASTPOST	0x0200
#define CT2_SENDSTATUS	0x8000

/*
 * ct_status values are (mostly) the same as that for ct_entry.
 */

/*
 * ct_scsi_status values- the low 8 bits are the normal SCSI status
 * we know and love. The upper 8 bits are validity markers for FCP_RSP_IU
 * fields.
 */
#define	CT2_RSPLEN_VALID	0x0100
#define	CT2_SNSLEN_VALID	0x0200
#define	CT2_DATA_OVER		0x0400
#define	CT2_DATA_UNDER		0x0800
@


1.5
log
@Remove incorrect BIG_ENDIAN defines and substitute in the SBus only macros
that will SBusify an isp header or the lun/target portions of a request IOCB-
and have these only valid iff __sparc__ (no non-sparc SBus machine that *I*
know about).
@
text
@d1 2
a2 2
/*	$OpenBSD: ispmbox.h,v 1.4 1999/03/25 22:58:38 mjacob Exp $ */
/* release_4_3_99 */
a187 10
#define	_ISP_SWAP8(a, b)	{	\
	u_int8_t tmp;			\
	tmp = a;			\
	a = b;				\
	b = tmp;			\
}

/*
 * These elements get swizzled around for SBus instances.
 */
d189 6
d199 1
a200 12
/*
 * There are no (for all intents and purposes) non-sparc SBus machines
 */
#ifdef	__sparc__
#define	ISP_SBUSIFY_ISPHDR(isp, hdrp)					\
    if ((isp)->isp_bustype == ISP_BT_SBUS) {				\
	_ISP_SWAP8((hdrp)->rqs_entry_count, (hdrp)->rqs_entry_type);	\
	_ISP_SWAP8((hdrp)->rqs_flags, (hdrp)->rqs_seqno);		\
    }
#else
#define	ISP_SBUSIFY_ISPHDR(a, b)
#endif
d240 4
d246 1
a256 19
/*
 * A request packet can also be a marker packet.
 */
#define SYNC_DEVICE	0
#define SYNC_TARGET	1
#define SYNC_ALL	2

/*
 * There are no (for all intents and purposes) non-sparc SBus machines
 */
#ifdef	__sparc__
#define	ISP_SBUSIFY_ISPREQ(isp, rqp)					\
    if ((isp)->isp_bustype == ISP_BT_SBUS) {				\
	_ISP_SWAP8((rqp)->req_target, (rqp)->req_lun_trn);		\
    }
#else
#define	ISP_SBUSIFY_ISPREQ(a, b)
#endif

d261 4
d267 1
d302 4
d308 1
d326 20
d442 4
d448 1
d453 4
d459 1
d462 4
d468 1
a504 1

d530 4
d536 8
a543 1
#define	BITS2WORD(x)	(x)[0] << 16 | (x)[3] << 8 | (x)[2]
d550 4
d556 1
d566 4
d572 1
d627 2
d633 1
d635 2
d643 1
d679 2
d685 1
d687 2
d693 1
d703 2
d707 1
d732 2
d738 1
d740 2
d744 1
d758 2
d762 1
d785 2
d791 1
d793 2
d799 1
d827 2
d831 1
d835 2
d841 1
d873 2
d879 1
d881 2
d887 1
d949 2
d953 1
@


1.4
log
@roll internal revision levels and enable 1080 support
@
text
@d1 2
a2 2
/*	$OpenBSD: ispmbox.h,v 1.3 1999/03/17 12:54:32 mjacob Exp $ */
/* release_03_25_99 */
d188 10
a198 6
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	rqs_entry_count;
	u_int8_t	rqs_entry_type;
	u_int8_t	rqs_flags;
	u_int8_t	rqs_seqno;
#else
d203 12
a215 1
} isphdr_t;
a254 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	req_target;
	u_int8_t	req_lun_trn;
#else
a256 1
#endif
d267 19
a289 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	req_target;
	u_int8_t	req_lun_trn;
#else
a291 1
#endif
a325 4
#if	BYTE_ORDER == BIG_ENDIAN
	u_int8_t	req_target;
	u_int8_t	req_lun_trn;
#else
a327 1
#endif
a344 20
	u_int32_t	_res1;
#if	BYTE_ORDER == BIG_ENDIAN
	u_int8_t	req_target;
	u_int8_t	req_lun_trn;
	u_int8_t	_res2;
	u_int8_t	req_modifier;
#else
	u_int8_t	req_lun_trn;
	u_int8_t	req_target;
	u_int8_t	req_modifier;
	u_int8_t	_res2;
#endif
} ispmarkreq_t;

#define SYNC_DEVICE	0
#define SYNC_TARGET	1
#define SYNC_ALL	2

typedef struct {
	isphdr_t	req_header;
a440 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	_reserved0;
	u_int8_t	icb_version;
#else
a442 1
#endif
a446 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	icb_retry_delay;
	u_int8_t	icb_retry_count;
#else
a448 1
#endif
a450 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	_reserved1;
	u_int8_t	icb_iqdevtype;
#else
a452 1
#endif
d489 1
a514 4
#if	BYTE_ORDER == BIG_ENDIAN
	u_int8_t	pdb_sstate;
	u_int8_t	pdb_mstate;
#else
d517 1
a517 8
#endif
#if BYTE_ORDER == BIG_ENDIAN
#define	BITS2WORD(x)	\
	(x)[1] << 16 | (x)[2] << 8 | (x)[3]
#else
#define	BITS2WORD(x)	\
	(x)[0] << 16 | (x)[3] << 8 | (x)[2]
#endif
a523 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	pdb_retry_delay;
	u_int8_t	pdb_retry_count;
#else
a525 1
#endif
a534 4
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t	pdb_initiator;	/* PLOGI, Class 3 Control Flags */
	u_int8_t	pdb_target;
#else
a536 1
#endif
a590 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a594 1
#endif
a595 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a601 1
#endif
a636 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a640 1
#endif
a641 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a645 1
#endif
a654 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a656 1
#endif
a680 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a684 1
#endif
a685 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a687 1
#endif
a700 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a702 1
#endif
a724 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a728 1
#endif
a729 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a733 1
#endif
a760 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a762 1
#endif
a765 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a769 1
#endif
a800 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a804 1
#endif
a805 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a809 1
#endif
a870 2
#if	BYTE_ORDER == BIG_ENDIAN
#else
a872 1
#endif
@


1.3
log
@fix OpenBSD headers
@
text
@d1 2
a2 2
/*	$OpenBSD: ispmbox.h,v 1.2 1999/03/17 05:26:09 mjacob Exp $ */
/* release_03_16_99 */
a503 1

@


1.2
log
@complete update of ISP driver- includes 2100 FC support
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
@


1.1
log
@add isp driver from netbsd, more munging needed
@
text
@d1 2
a2 2
/*	$NetBSD: ispmbox.h,v 1.1.1.1 1997/03/12 20:44:51 cgd Exp $	*/

d4 1
a4 1
 * Mailbox and Command Definitions for for Qlogic ISP SCSI adapters.
d6 2
a7 1
 * Copyright (c) 1997 by Matthew Jacob
d10 1
d35 1
a36 1

d100 1
d112 24
d140 1
a140 1
	u_int16_t param[6];
d144 36
d207 1
d209 25
a233 5
#define	RQSTYPE_REQUEST		1
#define	RQSTYPE_DATASEG		2
#define	RQSTYPE_RESPONSE	3
#define	RQSTYPE_MARKER		4
#define	RQSTYPE_CMDONLY		5
d250 1
a250 1
	u_int16_t	_res1;
d257 21
d291 7
d338 1
a338 1
} ipsmarkreq_t;
d358 12
d392 16
d409 3
a411 1

d415 1
a415 1
#define RQSF_TRANFERRED_DATA		0x0800
d418 1
d420 3
d431 605
@

