head	1.5;
access;
symbols
	OPENBSD_4_3:1.4.0.30
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.28
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.26
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.24
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.22
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.20
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.18
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.16
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.14
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.12
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.10
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2
	SMP_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2008.05.23.14.04.19;	author brad;	state dead;
branches;
next	1.4;

1.4
date	2001.07.04.09.02.59;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.27.05.44.53;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.17.16.16.31;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	99.12.16.02.56.56;	author deraadt;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.05.14.22.23.32;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.04.10.40.40;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Bye bye awi(4). No net80211 love, uses its own WEP code and has not worked
properly in 8.5 years so just garbage collect the driver.

ok damien@@ deraadt@@
@
text
@/* $OpenBSD: awireg.h,v 1.4 2001/07/04 09:02:59 niklas Exp $ */
/* $NetBSD: awireg.h,v 1.3 2000/03/22 11:22:22 onoe Exp $ */

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * The firmware typically loaded onto Am79C930-based 802.11 interfaces
 * uses a 32k or larger shared memory buffer to communicate with the
 * host.
 *
 * Depending on the exact configuration of the device, this buffer may
 * either be mapped into PCMCIA memory space, or accessible a byte at
 * a type through PCMCIA I/O space.
 *
 * This header defines offsets into this shared memory.
 */


/*
 * LAST_TXD block.  5 32-bit words.
 *
 * There are five different output queues; this defines pointers to
 * the last completed descriptor for each one.
 */
#define AWI_LAST_TXD		0x3ec	/* last completed Tx Descr */

#define AWI_LAST_BCAST_TXD		AWI_LAST_TXD+0
#define AWI_LAST_MGT_TXD		AWI_LAST_TXD+4
#define AWI_LAST_DATA_TXD		AWI_LAST_TXD+8
#define AWI_LAST_PS_POLL_TXD		AWI_LAST_TXD+12
#define AWI_LAST_CF_POLL_TXD		AWI_LAST_TXD+16

/*
 * Banner block; null-terminated string.
 *
 * The doc says it contains
 * "PCnetMobile:v2.00 mmddyy APIx.x\0"
 */

#define AWI_BANNER		0x480	/* Version string */
#define AWI_BANNER_LEN			0x20

/*
 * Command block protocol:
 * write command byte to a zero value.
 * write command status to a zero value.
 * write arguments to AWI_COMMAND_PARAMS
 * write command byte to a non-zero value.
 * wait for command status to be non-zero.
 * write command byte to a zero value.
 * write command status to a zero value.
 */

#define AWI_CMD			0x4a0	/* Command opcode byte */

#define AWI_CMD_IDLE			0x0
#define AWI_CMD_NOP			0x1

#define AWI_CMD_SET_MIB			0x2
#define AWI_CMD_GET_MIB			0x9

#define AWI_CA_MIB_TYPE			0x0
#define AWI_CA_MIB_SIZE			0x1
#define AWI_CA_MIB_INDEX		0x2
#define AWI_CA_MIB_DATA			0x4

#define AWI_MIB_LOCAL			0x0
#define AWI_MIB_ADDR			0x2
#define AWI_MIB_MAC			0x3
#define AWI_MIB_STAT			0x4
#define AWI_MIB_MGT			0x5
#define AWI_MIB_DRVR			0x6
#define AWI_MIB_PHY			0x7


#define AWI_CMD_INIT_TX			0x3

#define AWI_CA_TX_LEN			0x14
#define AWI_CA_TX_DATA			0x0
#define AWI_CA_TX_MGT			0x4
#define AWI_CA_TX_BCAST		       	0x8
#define AWI_CA_TX_PS			0xc
#define AWI_CA_TX_CF			0x10

#define AWI_CMD_FLUSH_TX		0x4

#define AWI_CA_FTX_LEN			0x5
#define AWI_CA_FTX_DATA			0x0
#define AWI_CA_FTX_MGT			0x1
#define AWI_CA_FTX_BCAST		0x2
#define AWI_CA_FTX_PS			0x3
#define AWI_CA_FTX_CF			0x4

#define AWI_CMD_INIT_RX			0x5
#define AWI_CA_IRX_LEN			0x8
#define AWI_CA_IRX_DATA_DESC		0x0 /* return */
#define AWI_CA_IRX_PS_DESC		0x4 /* return */

#define AWI_CMD_KILL_RX			0x6

#define AWI_CMD_SLEEP			0x7
#define AWI_CA_SLEEP_LEN		0x8 
#define AWI_CA_WAKEUP			0x0 /* uint64 */

#define AWI_CMD_WAKE			0x8

#define AWI_CMD_SCAN			0xa
#define AWI_CA_SCAN_LEN			0x6
#define AWI_CA_SCAN_DURATION		0x0
#define AWI_CA_SCAN_SET			0x2
#define AWI_CA_SCAN_PATTERN		0x3
#define AWI_CA_SCAN_IDX			0x4
#define AWI_CA_SCAN_SUSP		0x5

#define AWI_CMD_SYNC			0xb
#define AWI_CA_SYNC_LEN			0x14
#define AWI_CA_SYNC_SET			0x0
#define AWI_CA_SYNC_PATTERN		0x1
#define AWI_CA_SYNC_IDX			0x2
#define AWI_CA_SYNC_STARTBSS		0x3
#define AWI_CA_SYNC_DWELL		0x4
#define AWI_CA_SYNC_MBZ			0x6
#define AWI_CA_SYNC_TIMESTAMP		0x8
#define AWI_CA_SYNC_REFTIME		0x10

#define AWI_CMD_RESUME			0xc

#define AWI_CMD_STATUS			0x4a1 	/* Command status */

#define AWI_STAT_IDLE			0x0
#define AWI_STAT_OK			0x1
#define AWI_STAT_BADCMD			0x2
#define AWI_STAT_BADPARM		0x3
#define AWI_STAT_NOTIMP			0x4
#define AWI_STAT_BADRES			0x5
#define AWI_STAT_BADMODE		0x6

#define AWI_ERROR_OFFSET	0x4a2 	/* Offset to erroneous parameter */
#define AWI_CMD_PARAMS		0x4a4 	/* Command parameters */

#define AWI_CSB			0x4f0 	/* Control/Status block */

#define AWI_SELFTEST		0x4f0

#define AWI_SELFTEST_INIT		0x00 /* initial */
#define AWI_SELFTEST_FIRMCKSUM		0x01 /* firmware cksum running */
#define AWI_SELFTEST_HARDWARE		0x02 /* hardware tests running */
#define AWI_SELFTEST_MIB		0x03 /* mib initializing */

#define AWI_SELFTEST_MIB_FAIL		0xfa
#define AWI_SELFTEST_RADIO_FAIL		0xfb
#define AWI_SELFTEST_MAC_FAIL		0xfc
#define AWI_SELFTEST_FLASH_FAIL		0xfd
#define AWI_SELFTEST_RAM_FAIL		0xfe
#define AWI_SELFTEST_PASSED		0xff

#define AWI_STA_STATE		0x4f1

#define AWI_STA_AP			0x20 /* acting as AP */
#define AWI_STA_NOPSP			0x10 /* Power Saving disabled */
#define AWI_STA_DOZE			0x08 /* about to go to sleep */
#define AWI_STA_PSP			0x04 /* enable PSP */
#define AWI_STA_RXEN			0x02 /* enable RX */
#define AWI_STA_TXEN			0x01 /* enable TX */
					      
#define AWI_INTSTAT		0x4f3
#define AWI_INTMASK		0x4f4

/* Bits in AWI_INTSTAT/AWI_INTMASK */

#define AWI_INT_GROGGY			0x80 /* about to wake up */
#define AWI_INT_CFP_ENDING		0x40 /* cont. free period ending */
#define AWI_INT_DTIM			0x20 /* beacon outgoing */
#define AWI_INT_CFP_START		0x10 /* cont. free period starting */
#define AWI_INT_SCAN_CMPLT		0x08 /* scan complete */
#define AWI_INT_TX			0x04 /* tx done */
#define AWI_INT_RX			0x02 /* rx done */
#define AWI_INT_CMD			0x01 /* cmd done */

/*
 * The following are used to implement a locking protocol between host
 * and MAC to protect the interrupt status and mask fields.
 *
 * driver: read lockout_host byte; if zero, set lockout_mac to non-zero,
 *	then reread lockout_host byte; if still zero, host has lock.
 *	if non-zero, clear lockout_mac, loop.
 */

#define AWI_LOCKOUT_MAC		0x4f5
#define AWI_LOCKOUT_HOST	0x4f6


#define AWI_INTSTAT2		0x4f7
#define AWI_INTMASK2		0x4fd

/* Bits in AWI_INTSTAT2/INTMASK2 */
#define AWI_INT2_RXMGT			0x80 		/* mgt/ps received */
#define AWI_INT2_RXDATA			0x40 		/* data received */
#define AWI_INT2_TXMGT			0x10		/* mgt tx done */
#define AWI_INT2_TXCF			0x08		/* CF tx done */
#define AWI_INT2_TXPS			0x04		/* PS tx done */
#define AWI_INT2_TXBCAST		0x02		/* Broadcast tx done */
#define AWI_INT2_TXDATA			0x01		/* data tx done */

#define AWI_DIS_PWRDN		0x4fc		/* disable powerdown if set */

#define AWI_DRIVERSTATE		0x4fe		/* driver state */

#define AWI_DRV_STATEMASK		0x0f

#define AWI_DRV_RESET			0x0
#define AWI_DRV_INFSY			0x1 /* inf synced */
#define AWI_DRV_ADHSC			0x2 /* adhoc scan */
#define AWI_DRV_ADHSY			0x3 /* adhoc synced */
#define AWI_DRV_INFSC			0x4 /* inf scanning */
#define AWI_DRV_INFAUTH			0x5 /* inf authed */
#define AWI_DRV_INFASSOC		0x6 /* inf associated */
#define AWI_DRV_INFTOSS			0x7 /* inf handoff */
#define AWI_DRV_APNONE			0x8 /* AP activity: no assoc */
#define AWI_DRV_APQUIET			0xc /* AP: >=one assoc, no traffic */
#define AWI_DRV_APLO			0xd /* AP: >=one assoc, light tfc */
#define AWI_DRV_APMED			0xe /* AP: >=one assoc, mod tfc */
#define AWI_DRV_APHIGH			0xf /* AP: >=one assoc, heavy tfc */

#define AWI_DRV_AUTORXLED		0x10
#define AWI_DRV_AUTOTXLED		0x20
#define AWI_DRV_RXLED			0x40
#define AWI_DRV_TXLED			0x80

#define AWI_VBM			0x500	/* Virtual Bit Map */

#define AWI_BUFFERS		0x600	/* Buffers */
#define	AWI_BUFFERS_END		0x6000

/*
 * Receive descriptors; there are a linked list of these chained
 * through the "NEXT" fields, starting from XXX
 */

#define AWI_RXD_SIZE			0x18

#define AWI_RXD_NEXT			0x4
#define AWI_RXD_NEXT_LAST		0x80000000


#define AWI_RXD_HOST_DESC_STATE		0x9

#define AWI_RXD_ST_OWN		0x80 /* host owns this */
#define AWI_RXD_ST_CONSUMED	0x40 /* host is done */
#define AWI_RXD_ST_LF		0x20 /* last frag */
#define AWI_RXD_ST_CRC		0x08 /* CRC error */
#define AWI_RXD_ST_OFLO		0x02 /* possible buffer overrun */
#define AWI_RXD_ST_RXERROR	0x01 /* this frame is borked; discard me */

#define AWI_RXD_RSSI		0xa /* 1 byte: radio strength indicator */
#define AWI_RXD_INDEX		0xb /* 1 byte: FH hop index or DS channel */
#define AWI_RXD_LOCALTIME	0xc /* 4 bytes: local time of RX */
#define AWI_RXD_START_FRAME	0x10 /* 4 bytes: ptr to first received byte */
#define AWI_RXD_LEN		0x14 /* 2 bytes: rx len in bytes */
#define AWI_RXD_RATE		0x16 /* 1 byte: rx rate in 1e5 bps */

/*
 * Transmit descriptors.
 */

#define AWI_TXD_SIZE		0x18

#define AWI_TXD_START		0x00 /* pointer to start of frame */
#define AWI_TXD_NEXT		0x04 /* pointer to next TXD */
#define AWI_TXD_LENGTH		0x08 /* length of frame */
#define AWI_TXD_STATE		0x0a /* state */

#define AWI_TXD_ST_OWN		0x80 /* MAC owns this  */
#define AWI_TXD_ST_DONE		0x40 /* MAC is done */
#define AWI_TXD_ST_REJ		0x20 /* MAC doesn't like */
#define AWI_TXD_ST_MSDU		0x10 /* MSDU timeout */
#define AWI_TXD_ST_ABRT		0x08 /* TX aborted */
#define AWI_TXD_ST_RETURNED	0x04 /* TX returned */
#define AWI_TXD_ST_RETRY	0x02 /* TX retries exceeded */
#define AWI_TXD_ST_ERROR	0x01 /* TX error */

#define AWI_TXD_RATE		0x0b /* rate */

#define AWI_RATE_1MBIT		10
#define AWI_RATE_2MBIT		20

#define AWI_TXD_NDA		0x0c /* num DIFS attempts */
#define AWI_TXD_NDF		0x0d /* num DIFS failures */
#define AWI_TXD_NSA		0x0e /* num SIFS attempts */
#define AWI_TXD_NSF		0x0f /* num SIFS failures */

#define AWI_TXD_NRA		0x14 /* num RTS attempts */
#define AWI_TXD_NDTA		0x15 /* num data attempts */
#define AWI_TXD_CTL		0x16 /* control */

#define AWI_TXD_CTL_PSN		0x80	/* preserve sequence in MAC frame */
#define AWI_TXD_CTL_BURST	0x02    /* host is doing 802.11 fragmt. */
#define AWI_TXD_CTL_FRAGS	0x01    /* override normal fragmentation */

/*
 * MIB structures.
 */

#define	AWI_ESS_ID_SIZE			(IEEE80211_NWID_LEN+2)
struct awi_mib_local {
	u_int8_t	Fragmentation_Dis;
	u_int8_t	Add_PLCP_Dis;
	u_int8_t	MAC_Hdr_Prsv;
	u_int8_t	Rx_Mgmt_Que_En;
	u_int8_t	Re_Assembly_Dis;
	u_int8_t	Strip_PLCP_Dis;
	u_int8_t	Rx_Error_Dis;
	u_int8_t	Power_Saving_Mode_Dis;
	u_int8_t	Accept_All_Multicast_Dis;
	u_int8_t	Check_Seq_Cntl_Dis;
	u_int8_t	Flush_CFP_Queue_On_CF_End;
	u_int8_t	Network_Mode;
	u_int8_t	PWD_Lvl;
	u_int8_t	CFP_Mode;
	u_int8_t	Tx_Buffer_Offset[4];
	u_int8_t	Tx_Buffer_Size[4];
	u_int8_t	Rx_Buffer_Offset[4];
	u_int8_t	Rx_Buffer_Size[4];
	u_int8_t	Acting_as_AP;
	u_int8_t	Fill_CFP;
};

struct awi_mib_mac {
	u_int8_t	_Reserved1[2];
	u_int8_t	_Reserved2[2];
	u_int8_t	aRTS_Threshold[2];
	u_int8_t	aCW_max[2];
	u_int8_t	aCW_min[2];
	u_int8_t	aPromiscuous_Enable;
	u_int8_t	_Reserved3;
	u_int8_t	_Reserved4[4];
	u_int8_t	aShort_Retry_Limit;
	u_int8_t	aLong_Retry_Limit;
	u_int8_t	aMax_Frame_Length[2];
	u_int8_t	aFragmentation_Threshold[2];
	u_int8_t	aProbe_Delay[2];
	u_int8_t	aMin_Probe_Response_Time[2];
	u_int8_t	aMax_Probe_Response_Time[2];
	u_int8_t	aMax_Transmit_MSDU_Lifetime[4];
	u_int8_t	aMax_Receive_MSDU_Lifetime[4];
	u_int8_t	aStation_Basic_Rate[2];
	u_int8_t	aDesired_ESS_ID[AWI_ESS_ID_SIZE];
};

struct awi_mib_stat {
	u_int8_t	aTransmitted_MPDU_Count[4];
	u_int8_t	aTransmitted_MSDU_Count[4];
	u_int8_t	aOctets_Transmitted_Cnt[4];
	u_int8_t	aMulticast_Transmitted_Frame_Count[2];
	u_int8_t	aBroadcast_Transmitted_Frame_Count[2];
	u_int8_t	aFailed_Count[4];
	u_int8_t	aRetry_Count[4];
	u_int8_t	aMultiple_Retry_Count[4];
	u_int8_t	aFrame_Duplicate_Count[4];
	u_int8_t	aRTS_Success_Count[4];
	u_int8_t	aRTS_Failure_Count[4];
	u_int8_t	aACK_Failure_Count[4];
	u_int8_t	aReceived_Frame_Count [4];
	u_int8_t	aOctets_Received_Count[4];
	u_int8_t	aMulticast_Received_Count[2];
	u_int8_t	aBroadcast_Received_Count[2];
	u_int8_t	aFCS_Error_Count[4];
	u_int8_t	aError_Count[4];
	u_int8_t	aWEP_Undecryptable_Count[4];
};

struct awi_mib_mgt {
	u_int8_t	aPower_Mgt_Mode;
	u_int8_t	aScan_Mode;
#define	AWI_SCAN_PASSIVE		0x00
#define	AWI_SCAN_ACTIVE			0x01
#define	AWI_SCAN_BACKGROUND		0x02
	u_int8_t	aScan_State;
	u_int8_t	aDTIM_Period;
	u_int8_t	aATIM_Window[2];
	u_int8_t	Wep_Required;
	u_int8_t	_Reserved1;
	u_int8_t	aBeacon_Period[2];
	u_int8_t	aPassive_Scan_Duration[2];
	u_int8_t	aListen_Interval[2];
	u_int8_t	aMedium_Occupancy_Limit[2];
	u_int8_t	aMax_MPDU_Time[2];
	u_int8_t	aCFP_Max_Duration[2];
	u_int8_t	aCFP_Rate;
	u_int8_t	Do_Not_Receive_DTIMs;
	u_int8_t	aStation_ID[2];
	u_int8_t	aCurrent_BSS_ID[ETHER_ADDR_LEN];
	u_int8_t	aCurrent_ESS_ID[AWI_ESS_ID_SIZE];
};

#define	AWI_GROUP_ADDR_SIZE	4
struct awi_mib_addr {
	u_int8_t	aMAC_Address[ETHER_ADDR_LEN];
	u_int8_t	aGroup_Addresses[AWI_GROUP_ADDR_SIZE][ETHER_ADDR_LEN];
	u_int8_t	aTransmit_Enable_Status;
	u_int8_t	_Reserved1;
};

#define AWI_PWR_LEVEL_SIZE 4
struct awi_mib_phy {
	u_int8_t	aSlot_Time[2];
	u_int8_t	aSIFS[2];
	u_int8_t	aMPDU_Maximum[2];
	u_int8_t	aHop_Time[2];
	u_int8_t	aSuprt_Data_Rates[4];
	u_int8_t	aCurrent_Reg_Domain;
#define	AWI_REG_DOMAIN_US	0x10
#define	AWI_REG_DOMAIN_CA	0x20
#define	AWI_REG_DOMAIN_EU	0x30
#define	AWI_REG_DOMAIN_ES	0x31
#define	AWI_REG_DOMAIN_FR	0x32
#define	AWI_REG_DOMAIN_JP	0x40
	u_int8_t	aPreamble_Lngth;
	u_int8_t	aPLCP_Hdr_Lngth;
	u_int8_t	Pwr_Up_Time[AWI_PWR_LEVEL_SIZE][2];
	u_int8_t	IEEE_PHY_Type;
#define	AWI_PHY_TYPE_FH		1
#define	AWI_PHY_TYPE_DS		2
#define	AWI_PHY_TYPE_IR		3
	u_int8_t	RCR_33A_Bits[8];
};
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/* $OpenBSD: awireg.h,v 1.3 2000/03/22 11:22:22 onoe Exp $ */
@


1.3
log
@recieve -> receive
@
text
@d1 1
@


1.2
log
@replace if_awi w/ semi-current netbsd driver; still has problems
@
text
@d230 1
a230 1
#define AWI_INT2_RXMGT			0x80 		/* mgt/ps recieved */
@


1.1
log
@non-working awi driver; someone finish it
@
text
@d1 1
a1 2
/* $NetBSD: awireg.h,v 1.2 1999/11/05 05:13:36 sommerfeld Exp $ */
/* $OpenBSD$ */
d60 5
a64 5
#define AWI_LAST_BCAST_TXD	AWI_LAST_TXD+0
#define AWI_LAST_MGT_TXD	AWI_LAST_TXD+4
#define AWI_LAST_DATA_TXD	AWI_LAST_TXD+8
#define AWI_LAST_PS_POLL_TXD	AWI_LAST_TXD+12
#define AWI_LAST_CF_POLL_TXD	AWI_LAST_TXD+16
d74 1
a74 1
#define AWI_BANNER_LEN		0x20
d87 1
a87 1
#define AWI_CMD		0x4a0	/* Command opcode byte */
d89 2
a90 2
#define AWI_CMD_IDLE		0x0
#define AWI_CMD_NOP		0x1
d92 2
a93 2
#define AWI_CMD_SET_MIB	0x2
#define AWI_CMD_GET_MIB	0x9
d95 2
a96 2
#define AWI_CA_MIB_TYPE		0x0
#define AWI_CA_MIB_SIZE		0x1
d98 1
a98 1
#define AWI_CA_MIB_DATA		0x4
d100 7
a106 7
#define AWI_MIB_LOCAL		0x0
#define AWI_MIB_MAC_ADDR	0x2
#define AWI_MIB_MAC		0x3
#define AWI_MIB_MAC_STAT	0x4
#define AWI_MIB_MAC_MGT	0x5
#define AWI_MIB_DRVR_MAC	0x6
#define AWI_MIB_PHY		0x7
a107 1
#define AWI_MIB_LAST		AWI_MIB_PHY
d109 1
a109 2

#define AWI_CMD_INIT_TX	0x3
d114 1
a114 1
#define AWI_CA_TX_BCAST	       	0x8
d118 1
a118 1
#define AWI_CMD_FLUSH_TX	0x4
d121 1
a121 1
#define AWI_CA_FTX_DATA		0x0
d127 1
a127 1
#define AWI_CMD_INIT_RX	0x5
d132 1
a132 1
#define AWI_CMD_KILL_RX	0x6
d134 1
a134 1
#define AWI_CMD_SLEEP		0x7
d138 1
a138 1
#define AWI_CMD_WAKE		0x8
d140 2
a141 2
#define AWI_CMD_SCAN		0xa
#define AWI_CA_SCAN_LEN		0x6
d143 1
a143 1
#define AWI_CA_SCAN_SET		0x2
d145 1
a145 1
#define AWI_CA_SCAN_IDX		0x4
d148 3
a150 3
#define AWI_CMD_SYNC		0xb
#define AWI_CA_SYNC_LEN		0x14
#define AWI_CA_SYNC_SET		0x0
d152 1
a152 1
#define AWI_CA_SYNC_IDX		0x2
d155 1
a155 1
#define AWI_CA_SYNC_MBZ		0x6
d159 1
a159 1
#define AWI_CMD_RESUME		0xc
d161 1
a161 1
#define AWI_CMD_STATUS		0x4a1 	/* Command status */
d163 7
a169 7
#define AWI_STAT_IDLE		0x0
#define AWI_STAT_OK		0x1
#define AWI_STAT_BADCMD	0x2
#define AWI_STAT_BADPARM	0x3
#define AWI_STAT_NOTIMP	0x4
#define AWI_STAT_BADRES	0x5
#define AWI_STAT_BADMODE	0x6
d174 1
a174 1
#define AWI_CSB		0x4f0 	/* Control/Status block */
d184 1
a184 1
#define AWI_SELFTEST_RADIO_FAIL	0xfb
d186 1
a186 1
#define AWI_SELFTEST_FLASH_FAIL	0xfd
a212 2
#define AWI_INT_BITS "\20\1CMD\2RX\3TX\4SCAN\5CFPST\6DTIM\7CFPE\10GROGGY"

d222 1
a222 1
#define AWI_LOCKOUT_MAC	0x4f5
d230 7
a236 7
#define AWI_INT2_RXMGT		0x80 		/* mgt/ps recieved */
#define AWI_INT2_RXDATA	0x40 		/* data received */
#define AWI_INT2_TXMGT		0x10		/* mgt tx done */
#define AWI_INT2_TXCF		0x08f		/* CF tx done */
#define AWI_INT2_TXPS		0x04		/* PS tx done */
#define AWI_INT2_TXBCAST	0x02		/* Broadcast tx done */
#define AWI_INT2_TXDATA	0x01		/* data tx done */
d240 1
a240 1
#define AWI_DRIVERSTATE	0x4fe		/* driver state */
d249 1
a249 1
#define AWI_DRV_INFAUTH		0x5 /* inf authed */
d251 1
a251 1
#define AWI_DRV_INFTOSS		0x7 /* inf handoff */
d253 1
a253 1
#define AWI_DRV_APQUIET		0xc /* AP: >=one assoc, no traffic */
d258 4
a261 4
#define AWI_DRV_AUTORXLED			0x10
#define AWI_DRV_AUTOTXLED			0x20
#define AWI_DRV_RXLED				0x40
#define AWI_DRV_TXLED				0x80
d263 1
a263 1
#define AWI_VBM		0x500	/* Virtual Bit Map */
d266 1
d273 1
a273 1
#define AWI_RXD_SIZE		0x18
d275 2
a276 2
#define AWI_RXD_NEXT		0x4
#define AWI_RXD_NEXT_LAST	0x80000000
d279 1
a279 1
#define AWI_RXD_HOST_DESC_STATE	0x9
d285 1
a285 1
#define AWI_RXD_ST_OFLO	0x02 /* possible buffer overrun */
a287 2
#define AWI_RXD_ST_BITS	"\20\1ERROR\2OVERRUN\4CRC\6LF\7CONSUMED\10OWN"

d306 1
a306 1
#define AWI_TXD_ST_OWN			0x80 /* MAC owns this  */
d308 1
a308 1
#define AWI_TXD_ST_REJ			0x20 /* MAC doesn't like */
d311 3
a313 3
#define AWI_TXD_ST_RETURNED		0x04 /* TX returned */
#define AWI_TXD_ST_RETRY		0x02 /* TX retries exceeded */
#define AWI_TXD_ST_ERROR		0x01 /* TX error */
d317 2
a318 2
#define AWI_RATE_1MBIT			10
#define AWI_RATE_2MBIT			20
d329 1
a329 1
#define AWI_TXD_CTL_PSN	0x80	/* preserve sequence in MAC frame */
d337 23
a359 3
/*
 * MIB 0: Local MIB
 */
d361 21
a381 130
#define AWI_MIB_LOCAL_NOFRAG		0
#define AWI_MIB_LOCAL_NOPLCP		1
#define AWI_MIB_LOCAL_MACPRES		2
#define AWI_MIB_LOCAL_RXMGTQ		3
#define AWI_MIB_LOCAL_NOREASM		4
#define AWI_MIB_LOCAL_NOSTRIPPLCP	5
#define AWI_MIB_LOCAL_NORXERROR	6
#define AWI_MIB_LOCAL_NOPWRSAVE	7

#define AWI_MIB_LOCAL_FILTMULTI	8
#define AWI_MIB_LOCAL_NOSEQCHECK	9
#define AWI_MIB_LOCAL_CFPENDFLUSHCFPQ	10
#define AWI_MIB_LOCAL_INFRA_MODE	11
#define AWI_MIB_LOCAL_PWD_LEVEL	12
#define AWI_MIB_LOCAL_CFPMODE		13

#define AWI_MIB_LOCAL_TXB_OFFSET		14
#define AWI_MIB_LOCAL_TXB_SIZE		18
#define AWI_MIB_LOCAL_RXB_OFFSET		22
#define AWI_MIB_LOCAL_RXB_SIZE		26

#define AWI_MIB_LOCAL_ACTING_AS_AP	30
#define AWI_MIB_LOCAL_FILL_CFP		31
#define AWI_MIB_LOCAL_SIZE		32

/*
 * MAC mib 
 */

#define AWI_MIB_MAC_RTS_THRESH		4	 /* 2 bytes */
#define AWI_MIB_MAC_CW_MAX		6
#define AWI_MIB_MAC_CW_MIN		8
#define AWI_MIB_MAC_PROMISC		10
#define AWI_MIB_MAC_SHORT_RETRY	16
#define AWI_MIB_MAC_LONG_RETRY		17
#define AWI_MIB_MAC_MAX_FRAME		18
#define AWI_MIB_MAC_MAX_FRAG		20
#define AWI_MIB_MAC_PROBE_DELAY	22
#define AWI_MIB_MAC_PROBE_RESP_MIN	24
#define AWI_MIB_MAC_PROBE_RESP_MAX	26
#define AWI_MIB_MAC_MAX_TX_MSDU_LIFE	28
#define AWI_MIB_MAC_MAX_RX_MSDU_LIFE	32
#define AWI_MIB_MAC_STATION_BASE_RATE	36
#define AWI_MIB_MAC_DES_ESSID		38		/* 34 bytes */

/*
 * MGT mib.
 */

#define AWI_MIB_MGT_POWER_MODE		0
#define AWI_MIB_MGT_SCAN_MODE		1
#define AWI_MIB_MGT_SCAN_STATE		2
#define AWI_MIB_MGT_DTIM_PERIOD	3
#define AWI_MIB_MGT_ATIM_WINDOW	4
#define AWI_MIB_MGT_WEPREQ		6
#define AWI_MIB_MGT_BEACON_PD		8
#define AWI_MIB_MGT_PASSIVE_SCAN	10
#define AWI_MIB_MGT_LISTEN_INT		12
#define AWI_MIB_MGT_MEDIUP_OCC		14
#define AWI_MIB_MGT_MAX_MPDU_TIME	16
#define AWI_MIB_MGT_CFP_MAX_DUR	18
#define AWI_MIB_MGT_CFP_RATE		20
#define AWI_MIB_MGT_NO_DTMS		21
#define AWI_MIB_MGT_STATION_ID		22
#define AWI_MIB_MGT_BSS_ID		24
#define AWI_MIB_MGT_ESS_ID		30 		/* 34 bytes */
#define AWI_MIB_MGT_ESS_SIZE		34


/*
 * MAC address group.
 */

#define AWI_MIB_MAC_ADDR_MINE		0
#define AWI_MIB_MAC_ADDR_MULTI0	6
#define AWI_MIB_MAC_ADDR_MULTI1	12
#define AWI_MIB_MAC_ADDR_MULTI2	18
#define AWI_MIB_MAC_ADDR_MULTI3	24

#define AWI_MIB_MAC_ADDR_TXEN		30

/*
 * 802.11 media layer goo.
 * Should be split out into separate module independant of this driver.
 */

#define IEEEWL_FC		0 		/* frame control */

#define IEEEWL_FC_VERS		0
#define IEEEWL_FC_VERS_MASK	0x03

#define IEEEWL_FC_TYPE_MGT	0
#define IEEEWL_FC_TYPE_CTL	1
#define IEEEWL_FC_TYPE_DATA	2

#define IEEEWL_FC_TYPE_MASK	0x0c
#define IEEEWL_FC_TYPE_SHIFT	2

#define IEEEWL_FC_SUBTYPE_MASK	0xf0
#define IEEEWL_FC_SUBTYPE_SHIFT	4

#define IEEEWL_SUBTYPE_ASSOCREQ		0x00
#define IEEEWL_SUBTYPE_ASSOCRESP	0x01
#define IEEEWL_SUBTYPE_REASSOCREQ	0x02
#define IEEEWL_SUBTYPE_REASSOCRESP	0x03
#define IEEEWL_SUBTYPE_PROBEREQ		0x04
#define IEEEWL_SUBTYPE_PROBERESP	0x05

#define IEEEWL_SUBTYPE_BEACON		0x08
#define IEEEWL_SUBTYPE_DISSOC		0x0a
#define IEEEWL_SUBTYPE_AUTH		0x0b
#define IEEEWL_SUBTYPE_DEAUTH		0x0c

#define IEEEWL_FC2		1		/* second byte of fc */

/*
 * TLV tags for things we care about..
 */
#define IEEEWL_MGT_TLV_SSID		0
#define IEEEWL_MGT_TLV_FHPARMS		2

/*
 * misc frame control bits in second byte of frame control word.
 * there are others, but we don't ever want to set them..
 */

#define IEEEWL_FC2_DSMASK		0x03

#define IEEEWL_FC2_TODS			0x01
#define IEEEWL_FC2_FROMDS		0x02
d383 20
a402 14
#define IEEEWL_FH_CHANSET_MIN		1
#define IEEEWL_FH_CHANSET_MAX		3
#define IEEEWL_FH_PATTERN_MIN		0
#define IEEEWL_FH_PATTERN_MAX		77

struct awi_mac_header 
{
	u_int8_t	awi_fc;
	u_int8_t	awi_f2;
	u_int16_t	awi_duration;
	u_int8_t	awi_addr1[6];
	u_int8_t	awi_addr2[6];
	u_int8_t	awi_addr3[6];
	u_int16_t	awi_seqctl;
d405 22
a426 3
struct awi_llc_header
{
	u_int8_t	awi_llc_goo[8];
d429 6
a434 4
struct awi_assoc_hdr 
{
	u_int8_t	awi_cap_info[2];
	u_int8_t	awi_li[2];
d437 22
a458 5
struct awi_auth_hdr 
{
	u_int8_t	awi_algno[2];
	u_int8_t	awi_seqno[2];
	u_int8_t	awi_status[2];		
@


1.1.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 1
/* $NetBSD: awireg.h,v 1.3 2000/03/22 11:22:22 onoe Exp $ */
d61 5
a65 5
#define AWI_LAST_BCAST_TXD		AWI_LAST_TXD+0
#define AWI_LAST_MGT_TXD		AWI_LAST_TXD+4
#define AWI_LAST_DATA_TXD		AWI_LAST_TXD+8
#define AWI_LAST_PS_POLL_TXD		AWI_LAST_TXD+12
#define AWI_LAST_CF_POLL_TXD		AWI_LAST_TXD+16
d75 1
a75 1
#define AWI_BANNER_LEN			0x20
d88 1
a88 1
#define AWI_CMD			0x4a0	/* Command opcode byte */
d90 2
a91 2
#define AWI_CMD_IDLE			0x0
#define AWI_CMD_NOP			0x1
d93 2
a94 2
#define AWI_CMD_SET_MIB			0x2
#define AWI_CMD_GET_MIB			0x9
d96 2
a97 2
#define AWI_CA_MIB_TYPE			0x0
#define AWI_CA_MIB_SIZE			0x1
d99 1
a99 1
#define AWI_CA_MIB_DATA			0x4
d101 7
a107 7
#define AWI_MIB_LOCAL			0x0
#define AWI_MIB_ADDR			0x2
#define AWI_MIB_MAC			0x3
#define AWI_MIB_STAT			0x4
#define AWI_MIB_MGT			0x5
#define AWI_MIB_DRVR			0x6
#define AWI_MIB_PHY			0x7
d109 1
d111 2
a112 1
#define AWI_CMD_INIT_TX			0x3
d117 1
a117 1
#define AWI_CA_TX_BCAST		       	0x8
d121 1
a121 1
#define AWI_CMD_FLUSH_TX		0x4
d124 1
a124 1
#define AWI_CA_FTX_DATA			0x0
d130 1
a130 1
#define AWI_CMD_INIT_RX			0x5
d135 1
a135 1
#define AWI_CMD_KILL_RX			0x6
d137 1
a137 1
#define AWI_CMD_SLEEP			0x7
d141 1
a141 1
#define AWI_CMD_WAKE			0x8
d143 2
a144 2
#define AWI_CMD_SCAN			0xa
#define AWI_CA_SCAN_LEN			0x6
d146 1
a146 1
#define AWI_CA_SCAN_SET			0x2
d148 1
a148 1
#define AWI_CA_SCAN_IDX			0x4
d151 3
a153 3
#define AWI_CMD_SYNC			0xb
#define AWI_CA_SYNC_LEN			0x14
#define AWI_CA_SYNC_SET			0x0
d155 1
a155 1
#define AWI_CA_SYNC_IDX			0x2
d158 1
a158 1
#define AWI_CA_SYNC_MBZ			0x6
d162 1
a162 1
#define AWI_CMD_RESUME			0xc
d164 1
a164 1
#define AWI_CMD_STATUS			0x4a1 	/* Command status */
d166 7
a172 7
#define AWI_STAT_IDLE			0x0
#define AWI_STAT_OK			0x1
#define AWI_STAT_BADCMD			0x2
#define AWI_STAT_BADPARM		0x3
#define AWI_STAT_NOTIMP			0x4
#define AWI_STAT_BADRES			0x5
#define AWI_STAT_BADMODE		0x6
d177 1
a177 1
#define AWI_CSB			0x4f0 	/* Control/Status block */
d187 1
a187 1
#define AWI_SELFTEST_RADIO_FAIL		0xfb
d189 1
a189 1
#define AWI_SELFTEST_FLASH_FAIL		0xfd
d216 2
d227 1
a227 1
#define AWI_LOCKOUT_MAC		0x4f5
d235 7
a241 7
#define AWI_INT2_RXMGT			0x80 		/* mgt/ps recieved */
#define AWI_INT2_RXDATA			0x40 		/* data received */
#define AWI_INT2_TXMGT			0x10		/* mgt tx done */
#define AWI_INT2_TXCF			0x08		/* CF tx done */
#define AWI_INT2_TXPS			0x04		/* PS tx done */
#define AWI_INT2_TXBCAST		0x02		/* Broadcast tx done */
#define AWI_INT2_TXDATA			0x01		/* data tx done */
d245 1
a245 1
#define AWI_DRIVERSTATE		0x4fe		/* driver state */
d254 1
a254 1
#define AWI_DRV_INFAUTH			0x5 /* inf authed */
d256 1
a256 1
#define AWI_DRV_INFTOSS			0x7 /* inf handoff */
d258 1
a258 1
#define AWI_DRV_APQUIET			0xc /* AP: >=one assoc, no traffic */
d263 4
a266 4
#define AWI_DRV_AUTORXLED		0x10
#define AWI_DRV_AUTOTXLED		0x20
#define AWI_DRV_RXLED			0x40
#define AWI_DRV_TXLED			0x80
d268 1
a268 1
#define AWI_VBM			0x500	/* Virtual Bit Map */
a270 1
#define	AWI_BUFFERS_END		0x6000
d277 1
a277 1
#define AWI_RXD_SIZE			0x18
d279 2
a280 2
#define AWI_RXD_NEXT			0x4
#define AWI_RXD_NEXT_LAST		0x80000000
d283 1
a283 1
#define AWI_RXD_HOST_DESC_STATE		0x9
d289 1
a289 1
#define AWI_RXD_ST_OFLO		0x02 /* possible buffer overrun */
d292 2
d312 1
a312 1
#define AWI_TXD_ST_OWN		0x80 /* MAC owns this  */
d314 1
a314 1
#define AWI_TXD_ST_REJ		0x20 /* MAC doesn't like */
d317 3
a319 3
#define AWI_TXD_ST_RETURNED	0x04 /* TX returned */
#define AWI_TXD_ST_RETRY	0x02 /* TX retries exceeded */
#define AWI_TXD_ST_ERROR	0x01 /* TX error */
d323 2
a324 2
#define AWI_RATE_1MBIT		10
#define AWI_RATE_2MBIT		20
d335 1
a335 1
#define AWI_TXD_CTL_PSN		0x80	/* preserve sequence in MAC frame */
d343 131
a473 23
#define	AWI_ESS_ID_SIZE			(IEEE80211_NWID_LEN+2)
struct awi_mib_local {
	u_int8_t	Fragmentation_Dis;
	u_int8_t	Add_PLCP_Dis;
	u_int8_t	MAC_Hdr_Prsv;
	u_int8_t	Rx_Mgmt_Que_En;
	u_int8_t	Re_Assembly_Dis;
	u_int8_t	Strip_PLCP_Dis;
	u_int8_t	Rx_Error_Dis;
	u_int8_t	Power_Saving_Mode_Dis;
	u_int8_t	Accept_All_Multicast_Dis;
	u_int8_t	Check_Seq_Cntl_Dis;
	u_int8_t	Flush_CFP_Queue_On_CF_End;
	u_int8_t	Network_Mode;
	u_int8_t	PWD_Lvl;
	u_int8_t	CFP_Mode;
	u_int8_t	Tx_Buffer_Offset[4];
	u_int8_t	Tx_Buffer_Size[4];
	u_int8_t	Rx_Buffer_Offset[4];
	u_int8_t	Rx_Buffer_Size[4];
	u_int8_t	Acting_as_AP;
	u_int8_t	Fill_CFP;
};
d475 2
a476 21
struct awi_mib_mac {
	u_int8_t	_Reserved1[2];
	u_int8_t	_Reserved2[2];
	u_int8_t	aRTS_Threshold[2];
	u_int8_t	aCW_max[2];
	u_int8_t	aCW_min[2];
	u_int8_t	aPromiscuous_Enable;
	u_int8_t	_Reserved3;
	u_int8_t	_Reserved4[4];
	u_int8_t	aShort_Retry_Limit;
	u_int8_t	aLong_Retry_Limit;
	u_int8_t	aMax_Frame_Length[2];
	u_int8_t	aFragmentation_Threshold[2];
	u_int8_t	aProbe_Delay[2];
	u_int8_t	aMin_Probe_Response_Time[2];
	u_int8_t	aMax_Probe_Response_Time[2];
	u_int8_t	aMax_Transmit_MSDU_Lifetime[4];
	u_int8_t	aMax_Receive_MSDU_Lifetime[4];
	u_int8_t	aStation_Basic_Rate[2];
	u_int8_t	aDesired_ESS_ID[AWI_ESS_ID_SIZE];
};
d478 14
a491 20
struct awi_mib_stat {
	u_int8_t	aTransmitted_MPDU_Count[4];
	u_int8_t	aTransmitted_MSDU_Count[4];
	u_int8_t	aOctets_Transmitted_Cnt[4];
	u_int8_t	aMulticast_Transmitted_Frame_Count[2];
	u_int8_t	aBroadcast_Transmitted_Frame_Count[2];
	u_int8_t	aFailed_Count[4];
	u_int8_t	aRetry_Count[4];
	u_int8_t	aMultiple_Retry_Count[4];
	u_int8_t	aFrame_Duplicate_Count[4];
	u_int8_t	aRTS_Success_Count[4];
	u_int8_t	aRTS_Failure_Count[4];
	u_int8_t	aACK_Failure_Count[4];
	u_int8_t	aReceived_Frame_Count [4];
	u_int8_t	aOctets_Received_Count[4];
	u_int8_t	aMulticast_Received_Count[2];
	u_int8_t	aBroadcast_Received_Count[2];
	u_int8_t	aFCS_Error_Count[4];
	u_int8_t	aError_Count[4];
	u_int8_t	aWEP_Undecryptable_Count[4];
d494 3
a496 22
struct awi_mib_mgt {
	u_int8_t	aPower_Mgt_Mode;
	u_int8_t	aScan_Mode;
#define	AWI_SCAN_PASSIVE		0x00
#define	AWI_SCAN_ACTIVE			0x01
#define	AWI_SCAN_BACKGROUND		0x02
	u_int8_t	aScan_State;
	u_int8_t	aDTIM_Period;
	u_int8_t	aATIM_Window[2];
	u_int8_t	Wep_Required;
	u_int8_t	_Reserved1;
	u_int8_t	aBeacon_Period[2];
	u_int8_t	aPassive_Scan_Duration[2];
	u_int8_t	aListen_Interval[2];
	u_int8_t	aMedium_Occupancy_Limit[2];
	u_int8_t	aMax_MPDU_Time[2];
	u_int8_t	aCFP_Max_Duration[2];
	u_int8_t	aCFP_Rate;
	u_int8_t	Do_Not_Receive_DTIMs;
	u_int8_t	aStation_ID[2];
	u_int8_t	aCurrent_BSS_ID[ETHER_ADDR_LEN];
	u_int8_t	aCurrent_ESS_ID[AWI_ESS_ID_SIZE];
d499 4
a502 6
#define	AWI_GROUP_ADDR_SIZE	4
struct awi_mib_addr {
	u_int8_t	aMAC_Address[ETHER_ADDR_LEN];
	u_int8_t	aGroup_Addresses[AWI_GROUP_ADDR_SIZE][ETHER_ADDR_LEN];
	u_int8_t	aTransmit_Enable_Status;
	u_int8_t	_Reserved1;
d505 5
a509 22
#define AWI_PWR_LEVEL_SIZE 4
struct awi_mib_phy {
	u_int8_t	aSlot_Time[2];
	u_int8_t	aSIFS[2];
	u_int8_t	aMPDU_Maximum[2];
	u_int8_t	aHop_Time[2];
	u_int8_t	aSuprt_Data_Rates[4];
	u_int8_t	aCurrent_Reg_Domain;
#define	AWI_REG_DOMAIN_US	0x10
#define	AWI_REG_DOMAIN_CA	0x20
#define	AWI_REG_DOMAIN_EU	0x30
#define	AWI_REG_DOMAIN_ES	0x31
#define	AWI_REG_DOMAIN_FR	0x32
#define	AWI_REG_DOMAIN_JP	0x40
	u_int8_t	aPreamble_Lngth;
	u_int8_t	aPLCP_Hdr_Lngth;
	u_int8_t	Pwr_Up_Time[AWI_PWR_LEVEL_SIZE][2];
	u_int8_t	IEEE_PHY_Type;
#define	AWI_PHY_TYPE_FH		1
#define	AWI_PHY_TYPE_DS		2
#define	AWI_PHY_TYPE_IR		3
	u_int8_t	RCR_33A_Bits[8];
@


1.1.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d230 1
a230 1
#define AWI_INT2_RXMGT			0x80 		/* mgt/ps received */
@


1.1.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/* $OpenBSD$ */
@


