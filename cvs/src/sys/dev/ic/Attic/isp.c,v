head	1.54;
access;
symbols
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.53.0.6
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.52.0.8
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.52.0.6
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.52.0.2
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.4
	OPENBSD_5_0:1.51.0.4
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.46.0.4
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.44.0.4
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.37.0.4
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.35.0.8
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.6
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.35.0.4
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.25.0.4
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.27
	UBC:1.25.0.2
	UBC_BASE:1.25
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.9
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.54
date	2015.06.19.11.12.24;	author jmatthew;	state dead;
branches;
next	1.53;
commitid	I5HMIEQiHPSVn0jd;

1.53
date	2014.02.14.05.17.05;	author jmatthew;	state Exp;
branches;
next	1.52;

1.52
date	2011.10.22.19.34.06;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2010.12.31.19.26.00;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2010.11.20.05.12.38;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2010.02.20.12.39.41;	author sobrado;	state Exp;
branches;
next	1.48;

1.48
date	2010.02.18.10.16.12;	author sobrado;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.14.18.41.02;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2009.06.03.05.11.09;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.17.23.08.08;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.11.22.53.46;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.28.18.40.21;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.16.23.41.42;	author fgsch;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.23.01.32.25;	author ray;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.31.23.25.27;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.18.03.36.35;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.23.20.13.07;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.03.18.43.51;	author mjacob;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.03.18.31.42;	author mjacob;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.28.20.31.34;	author mjacob;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2002.12.15.13.18.11;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.17.17.48.45;	author mjacob;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.17.01.31.13;	author mjacob;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.14.00.20.54;	author mjacob;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.10.24.18.31.15;	author mjacob;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.06.22.45.52;	author mjacob;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.01.07.16.39;	author mjacob;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.04.22.06.54;	author mjacob;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.12.23.44.59;	author mjacob;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.09.03.26.18;	author mjacob;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.06.01.07.21;	author mjacob;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.16.01.01.58;	author mjacob;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.06.05.31.48;	author mjacob;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.06.05.50.43;	author mjacob;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.05.22.18.59;	author mjacob;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.20.21.22.40;	author mjacob;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.09.22.44.27;	author mjacob;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.12.20.05.36.06;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	99.12.16.05.26.52;	author mjacob;	state Exp;
branches;
next	1.9;

1.9
date	99.11.23.21.16.04;	author mjacob;	state Exp;
branches;
next	1.8;

1.8
date	99.11.22.12.50.52;	author mjacob;	state Exp;
branches;
next	1.7;

1.7
date	99.03.26.00.34.59;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	99.03.25.22.58.38;	author mjacob;	state Exp;
branches;
next	1.5;

1.5
date	99.03.17.12.54.31;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	99.03.17.05.26.08;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	99.01.11.05.12.17;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.03.24.04.05.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.03.24.03.26.09;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2000.02.21.22.29.04;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2000.03.24.09.09.09;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.05.14.22.23.53;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2003.05.13.19.35.01;	author ho;	state Exp;
branches;
next	1.12.2.8;

1.12.2.8
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.54
log
@remove isp(4) now that the ql* family have replaced it
@
text
@/* 	$OpenBSD: isp.c,v 1.53 2014/02/14 05:17:05 jmatthew Exp $ */
/*	$FreeBSD: src/sys/dev/isp/isp.c,v 1.150 2008/12/15 21:42:38 marius Exp $*/
/*-
 *  Copyright (c) 1997-2007 by Matthew Jacob
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 * 
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 *  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 */

/*
 * Machine and OS Independent (well, as best as possible)
 * code for the QLogic ISP SCSI and FC-SCSI adapters.
 */

/*
 * Inspiration and ideas about this driver are from Erik Moe's Linux driver
 * (qlogicisp.c) and Dave Miller's SBus version of same (qlogicisp.c). Some
 * ideas dredged from the Solaris driver.
 */

/*
 * Include header file appropriate for platform we're building on.
 */
#ifdef	__NetBSD__
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD$");
#include <dev/ic/isp_netbsd.h>
#endif
#ifdef	__FreeBSD__
#include <sys/cdefs.h>
__FBSDID("$FreeBSD: src/sys/dev/isp/isp.c,v 1.149 2007/07/10 07:55:04 mjacob Exp $");
#include <dev/isp/isp_freebsd.h>
#endif
#ifdef	__OpenBSD__
#include <dev/ic/isp_openbsd.h>
#endif
#ifdef	__linux__
#include "isp_linux.h"
#endif
#ifdef	__svr4__
#include "isp_solaris.h"
#endif

/*
 * General defines
 */

#define	MBOX_DELAY_COUNT	1000000 / 100
#define	ISP_MARK_PORTDB(a, b)	\
    isp_prt(isp, ISP_LOGSANCFG, "line %d: markportdb", __LINE__); \
    isp_mark_portdb(a, b)

/*
 * Local static data
 */
static const char fconf[] =
    "PortDB[%d] changed:\n current =(0x%x@@0x%06x 0x%08x%08x 0x%08x%08x)\n"
    " database=(0x%x@@0x%06x 0x%08x%08x 0x%08x%08x)";
static const char notresp[] =
  "Not RESPONSE in RESPONSE Queue (type 0x%x) @@ idx %d (next %d) nlooked %d";
static const char xact1[] =
    "HBA attempted queued transaction with disconnect not set for %d.%d.%d";
static const char xact2[] =
    "HBA attempted queued transaction to target routine %d on target %d bus %d";
static const char xact3[] =
    "HBA attempted queued cmd for %d.%d.%d when queueing disabled";
static const char pskip[] =
    "SCSI phase skipped for target %d.%d.%d";
static const char topology[] =
    "HBA PortID 0x%06x N-Port Handle %d, Connection Topology '%s'";
static const char ourwwn[] =
    "HBA WWNN 0x%08x%08x HBA WWPN 0x%08x%08x";
static const char finmsg[] =
    "%d.%d.%d: FIN dl%d resid %d STS 0x%x SKEY %c XS_ERR=0x%x";
static const char sc0[] =
    "%s CHAN %d FTHRSH %d IID %d RESETD %d RETRYC %d RETRYD %d ASD 0x%x";
static const char sc1[] =
    "%s RAAN 0x%x DLAN 0x%x DDMAB 0x%x CDMAB 0x%x SELTIME %d MQD %d";
static const char sc2[] = "%s CHAN %d TGT %d FLAGS 0x%x 0x%x/0x%x";
static const char sc3[] = "Generated";
static const char sc4[] = "NVRAM";
static const char bun[] =
    "bad underrun for %d.%d (count %d, resid %d, status %s)";

/*
 * Local function prototypes.
 */
int isp_parse_async(struct ispsoftc *, u_int16_t);
int isp_handle_other_response(struct ispsoftc *, int, isphdr_t *,
    u_int32_t *);
void
isp_parse_status(struct ispsoftc *, ispstatusreq_t *, XS_T *, long *);
void
isp_parse_status_24xx(struct ispsoftc *, isp24xx_statusreq_t *, XS_T *, long *);
void isp_fastpost_complete(struct ispsoftc *, u_int16_t);
int isp_mbox_continue(struct ispsoftc *);
void isp_scsi_init(struct ispsoftc *);
void isp_scsi_channel_init(struct ispsoftc *, int);
void isp_fibre_init(struct ispsoftc *);
void isp_mark_portdb(struct ispsoftc *, int);
int isp_plogx(struct ispsoftc *, u_int16_t, u_int32_t, int, int);
int isp_port_login(struct ispsoftc *, u_int16_t, u_int32_t);
int isp_port_logout(struct ispsoftc *, u_int16_t, u_int32_t);
int isp_getpdb(struct ispsoftc *, u_int16_t, isp_pdb_t *, int);
u_int64_t isp_get_portname(struct ispsoftc *, int, int);
int isp_fclink_test(struct ispsoftc *, int);
const char *ispfc_fw_statename(int);
int isp_pdb_sync(struct ispsoftc *);
int isp_scan_loop(struct ispsoftc *);
int isp_gid_ft_sns(struct ispsoftc *);
int isp_gid_ft_ct_passthru(struct ispsoftc *);
int isp_scan_fabric(struct ispsoftc *);
int isp_login_device(struct ispsoftc *, u_int32_t, isp_pdb_t *, u_int16_t *);
int isp_register_fc4_type(struct ispsoftc *);
u_int16_t isp_nxt_handle(struct ispsoftc *, u_int16_t);
void isp_fw_state(struct ispsoftc *);
void isp_mboxcmd_qnw(struct ispsoftc *, mbreg_t *, int);
void isp_mboxcmd(struct ispsoftc *, mbreg_t *);

void isp_update(struct ispsoftc *);
void isp_update_bus(struct ispsoftc *, int);
void isp_setdfltparm(struct ispsoftc *, int);
void isp_setdfltfcparm(struct ispsoftc *);
int isp_read_nvram(struct ispsoftc *);
void isp_rdnvram_word(struct ispsoftc *, int, u_int16_t *);
void isp_parse_nvram_1020(struct ispsoftc *, u_int8_t *);
void isp_parse_nvram_1080(struct ispsoftc *, int, u_int8_t *);
void isp_parse_nvram_12160(struct ispsoftc *, int, u_int8_t *);
void isp_fix_nvram_wwns(struct ispsoftc *);
void isp_parse_nvram_2100(struct ispsoftc *, u_int8_t *);

/*
 * Reset Hardware.
 *
 * Hit the chip over the head, download new f/w if available and set it running.
 *
 * Locking done elsewhere.
 */

void
isp_reset(struct ispsoftc *isp)
{
	mbreg_t mbs;
	u_int32_t code_org;
	int loops, i, dodnld = 1;
	static const char *btype = "????";
	static const char dcrc[] = "Downloaded RISC Code Checksum Failure";

	isp->isp_state = ISP_NILSTATE;

	/*
	 * Basic types (SCSI, FibreChannel and PCI or SBus)
	 * have been set in the MD code. We figure out more
	 * here. Possibly more refined types based upon PCI
	 * identification. Chip revision has been gathered.
	 *
	 * After we've fired this chip up, zero out the conf1 register
	 * for SCSI adapters and do other settings for the 2100.
	 */

	/*
	 * Get the current running firmware revision out of the
	 * chip before we hit it over the head (if this is our
	 * first time through). Note that we store this as the
	 * 'ROM' firmware revision- which it may not be. In any
	 * case, we don't really use this yet, but we may in
	 * the future.
	 */
	if (isp->isp_touched == 0) {
		/*
		 * First see whether or not we're sitting in the ISP PROM.
		 * If we've just been reset, we'll have the string "ISP   "
		 * spread through outgoing mailbox registers 1-3. We do
		 * this for PCI cards because otherwise we really don't
		 * know what state the card is in and we could hang if
		 * we try this command otherwise.
		 *
		 * For SBus cards, we just do this because they almost
		 * certainly will be running firmware by now.
		 */
		if (ISP_READ(isp, OUTMAILBOX1) != 0x4953 ||
		    ISP_READ(isp, OUTMAILBOX2) != 0x5020 ||
		    ISP_READ(isp, OUTMAILBOX3) != 0x2020) {
			/*
			 * Just in case it was paused...
			 */
			ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
			MEMZERO(&mbs, sizeof (mbs));
			mbs.param[0] = MBOX_ABOUT_FIRMWARE;
			mbs.logval = MBLOGNONE;
			isp_mboxcmd(isp, &mbs);
			if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
				isp->isp_romfw_rev[0] = mbs.param[1];
				isp->isp_romfw_rev[1] = mbs.param[2];
				isp->isp_romfw_rev[2] = mbs.param[3];
			}
		}
		isp->isp_touched = 1;
	}

	ISP_DISABLE_INTS(isp);

	/*
	 * Pick an initial maxcmds value which will be used
	 * to allocate xflist pointer space. It may be changed
	 * later by the firmware.
	 */
	if (IS_2322(isp)) {
		isp->isp_maxcmds = 2048;
	} else if (IS_23XX(isp) || IS_2200(isp)) {
		isp->isp_maxcmds = 1024;
 	} else {
		isp->isp_maxcmds = 512;
	}

	/*
	 * Set up DMA for the request and result queues.
	 *
	 * We do this now so we can use the request queue
	 * for a dma
	 */
	if (ISP_MBOXDMASETUP(isp) != 0) {
		isp_prt(isp, ISP_LOGERR, "Cannot setup DMA");
		return;
	}


	/*
	 * Set up default request/response queue in-pointer/out-pointer
	 * register indices.
	 */
	if (IS_23XX(isp)) {
		isp->isp_rqstinrp = BIU_REQINP;
		isp->isp_rqstoutrp = BIU_REQOUTP;
		isp->isp_respinrp = BIU_RSPINP;
		isp->isp_respoutrp = BIU_RSPOUTP;
	} else {
		isp->isp_rqstinrp = INMAILBOX4;
		isp->isp_rqstoutrp = OUTMAILBOX4;
		isp->isp_respinrp = OUTMAILBOX5;
		isp->isp_respoutrp = INMAILBOX5;
	}

	/*
	 * Put the board into PAUSE mode (so we can read the SXP registers
	 * or write FPM/FBM registers).
	 */
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);

	if (IS_FC(isp)) {
		switch (isp->isp_type) {
		case ISP_HA_FC_2100:
			btype = "2100";
			break;
		case ISP_HA_FC_2200:
			btype = "2200";
			break;
		case ISP_HA_FC_2300:
			btype = "2300";
			break;
		case ISP_HA_FC_2312:
			btype = "2312";
			break;
		case ISP_HA_FC_2322:
			btype = "2322";
			break;
		default:
			break;
		}

		/*
		 * While we're paused, reset the FPM module and FBM
		 * fifos.
		 */
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_FPM0_REGS);
		ISP_WRITE(isp, FPM_DIAG_CONFIG, FPM_SOFT_RESET);
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_FB_REGS);
		ISP_WRITE(isp, FBM_CMD, FBMCMD_FIFO_RESET_ALL);
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_RISC_REGS);
	} else if (IS_1240(isp)) {
		sdparam *sdp = isp->isp_param;
		btype = "1240";
		isp->isp_clock = 60;
		sdp->isp_ultramode = 1;
		sdp++;
		sdp->isp_ultramode = 1;
		/*
		 * XXX: Should probably do some bus sensing.
		 */
	} else if (IS_ULTRA3(isp)) {
		sdparam *sdp = isp->isp_param;

		isp->isp_clock = 100;

		if (IS_10160(isp))
			btype = "10160";
		else if (IS_12160(isp))
			btype = "12160";
		else
			btype = "<UNKLVD>";
		sdp->isp_lvdmode = 1;

		if (IS_DUALBUS(isp)) {
			sdp++;
			sdp->isp_lvdmode = 1;
		}
	} else if (IS_ULTRA2(isp)) {
		static const char m[] = "bus %d is in %s Mode";
		u_int16_t l;
		sdparam *sdp = isp->isp_param;

		isp->isp_clock = 100;

		if (IS_1280(isp))
			btype = "1280";
		else if (IS_1080(isp))
			btype = "1080";
		else
			btype = "<UNKLVD>";

		l = ISP_READ(isp, SXP_PINS_DIFF) & ISP1080_MODE_MASK;
		switch (l) {
		case ISP1080_LVD_MODE:
			sdp->isp_lvdmode = 1;
			isp_prt(isp, ISP_LOGCONFIG, m, 0, "LVD");
			break;
		case ISP1080_HVD_MODE:
			sdp->isp_diffmode = 1;
			isp_prt(isp, ISP_LOGCONFIG, m, 0, "Differential");
			break;
		case ISP1080_SE_MODE:
			sdp->isp_ultramode = 1;
			isp_prt(isp, ISP_LOGCONFIG, m, 0, "Single-Ended");
			break;
		default:
			isp_prt(isp, ISP_LOGERR,
			    "unknown mode on bus %d (0x%x)", 0, l);
			break;
		}

		if (IS_DUALBUS(isp)) {
			sdp++;
			l = ISP_READ(isp, SXP_PINS_DIFF|SXP_BANK1_SELECT);
			l &= ISP1080_MODE_MASK;
			switch(l) {
			case ISP1080_LVD_MODE:
				sdp->isp_lvdmode = 1;
				isp_prt(isp, ISP_LOGCONFIG, m, 1, "LVD");
				break;
			case ISP1080_HVD_MODE:
				sdp->isp_diffmode = 1;
				isp_prt(isp, ISP_LOGCONFIG,
				    m, 1, "Differential");
				break;
			case ISP1080_SE_MODE:
				sdp->isp_ultramode = 1;
				isp_prt(isp, ISP_LOGCONFIG,
				    m, 1, "Single-Ended");
				break;
			default:
				isp_prt(isp, ISP_LOGERR,
				    "unknown mode on bus %d (0x%x)", 1, l);
				break;
			}
		}
	} else {
		sdparam *sdp = isp->isp_param;
		i = ISP_READ(isp, BIU_CONF0) & BIU_CONF0_HW_MASK;
		switch (i) {
		default:
			isp_prt(isp, ISP_LOGALL, "Unknown Chip Type 0x%x", i);
			/* FALLTHROUGH */
		case 1:
			btype = "1020";
			isp->isp_type = ISP_HA_SCSI_1020;
			isp->isp_clock = 40;
			break;
		case 2:
			/*
			 * Some 1020A chips are Ultra Capable, but don't
			 * run the clock rate up for that unless told to
			 * do so by the Ultra Capable bits being set.
			 */
			btype = "1020A";
			isp->isp_type = ISP_HA_SCSI_1020A;
			isp->isp_clock = 40;
			break;
		case 3:
			btype = "1040";
			isp->isp_type = ISP_HA_SCSI_1040;
			isp->isp_clock = 60;
			break;
		case 4:
			btype = "1040A";
			isp->isp_type = ISP_HA_SCSI_1040A;
			isp->isp_clock = 60;
			break;
		case 5:
			btype = "1040B";
			isp->isp_type = ISP_HA_SCSI_1040B;
			isp->isp_clock = 60;
			break;
		case 6:
			btype = "1040C";
			isp->isp_type = ISP_HA_SCSI_1040C;
			isp->isp_clock = 60;
                        break;
		}
		/*
		 * Now, while we're at it, gather info about ultra
		 * and/or differential mode.
		 */
		if (ISP_READ(isp, SXP_PINS_DIFF) & SXP_PINS_DIFF_MODE) {
			isp_prt(isp, ISP_LOGCONFIG, "Differential Mode");
			sdp->isp_diffmode = 1;
		} else {
			sdp->isp_diffmode = 0;
		}
		i = ISP_READ(isp, RISC_PSR);
		if (isp->isp_bustype == ISP_BT_SBUS) {
			i &= RISC_PSR_SBUS_ULTRA;
		} else {
			i &= RISC_PSR_PCI_ULTRA;
		}
		if (i != 0) {
			isp_prt(isp, ISP_LOGCONFIG, "Ultra Mode Capable");
			sdp->isp_ultramode = 1;
			/*
			 * If we're in Ultra Mode, we have to be 60MHz clock-
			 * even for the SBus version.
			 */
			isp->isp_clock = 60;
		} else {
			sdp->isp_ultramode = 0;
			/*
			 * Clock is known. Gronk.
			 */
		}

		/*
		 * Machine dependent clock (if set) overrides
		 * our generic determinations.
		 */
		if (isp->isp_mdvec->dv_clock) {
			if (isp->isp_mdvec->dv_clock < isp->isp_clock) {
				isp->isp_clock = isp->isp_mdvec->dv_clock;
			}
		}

	}

	/*
	 * Clear instrumentation
	 */
	isp->isp_intcnt = isp->isp_intbogus = 0;

	/*
	 * Do MD specific pre initialization
	 */
	ISP_RESET0(isp);

	/*
	 * Hit the chip over the head with hammer,
	 * and give the ISP a chance to recover.
	 */

	if (IS_SCSI(isp)) {
		ISP_WRITE(isp, BIU_ICR, BIU_ICR_SOFT_RESET);
		/*
		 * A slight delay...
		 */
		USEC_DELAY(100);

		/*
		 * Clear data && control DMA engines.
		 */
		ISP_WRITE(isp, CDMA_CONTROL,
		    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);
		ISP_WRITE(isp, DDMA_CONTROL,
		    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);


	} else {
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);
		/*
		 * A slight delay...
		 */
		USEC_DELAY(100);

		/*
		 * Clear data && control DMA engines.
		 */
		ISP_WRITE(isp, CDMA2100_CONTROL,
			DMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);
		ISP_WRITE(isp, TDMA2100_CONTROL,
			DMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);
		ISP_WRITE(isp, RDMA2100_CONTROL,
			DMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);
	}

	/*
	 * Wait for ISP to be ready to go...
	 */
	loops = MBOX_DELAY_COUNT;
	for (;;) {
		if (IS_SCSI(isp)) {
			if (!(ISP_READ(isp, BIU_ICR) & BIU_ICR_SOFT_RESET)) {
				break;
			}
		} else {
			if (!(ISP_READ(isp, BIU2100_CSR) & BIU2100_SOFT_RESET))
				break;
		}
		USEC_DELAY(100);
		if (--loops < 0) {
			ISP_DUMPREGS(isp, "chip reset timed out");
			ISP_RESET0(isp);
			return;
		}
	}

	/*
	 * After we've fired this chip up, zero out the conf1 register
	 * for SCSI adapters and other settings for the 2100.
	 */

	if (IS_SCSI(isp)) {
		ISP_WRITE(isp, BIU_CONF1, 0);
	} else {
		ISP_WRITE(isp, BIU2100_CSR, 0);
	}

	/*
	 * Reset RISC Processor
	 */
	ISP_WRITE(isp, HCCR, HCCR_CMD_RESET);
	USEC_DELAY(100);
	ISP_WRITE(isp, BIU_SEMA, 0);

	
	/*
	 * Post-RISC Reset stuff.
	 */
	if (IS_SCSI(isp)) {
		u_int16_t tmp = isp->isp_mdvec->dv_conf1;
		/*
		 * Busted FIFO. Turn off all but burst enables.
		 */
		if (isp->isp_type == ISP_HA_SCSI_1040A) {
			tmp &= BIU_BURST_ENABLE;
		}
		ISP_SETBITS(isp, BIU_CONF1, tmp);
		if (tmp & BIU_BURST_ENABLE) {
			ISP_SETBITS(isp, CDMA_CONF, DMA_ENABLE_BURST);
			ISP_SETBITS(isp, DDMA_CONF, DMA_ENABLE_BURST);
		}
		if (SDPARAM(isp)->isp_ptisp) {
			if (SDPARAM(isp)->isp_ultramode) {
				while (ISP_READ(isp, RISC_MTR) != 0x1313) {
					ISP_WRITE(isp, RISC_MTR, 0x1313);
					ISP_WRITE(isp, HCCR, HCCR_CMD_STEP);
				}
			} else {
				ISP_WRITE(isp, RISC_MTR, 0x1212);
			}
			/*
			 * PTI specific register
			 */
			ISP_WRITE(isp, RISC_EMB, DUAL_BANK);
		} else {
			ISP_WRITE(isp, RISC_MTR, 0x1212);
		}
		ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
	} else {
		ISP_WRITE(isp, RISC_MTR2100, 0x1212);
		if (IS_2200(isp) || IS_23XX(isp)) {
			ISP_WRITE(isp, HCCR, HCCR_2X00_DISABLE_PARITY_PAUSE);
		}
		ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
	}

	ISP_WRITE(isp, isp->isp_rqstinrp, 0);
	ISP_WRITE(isp, isp->isp_rqstoutrp, 0);
	ISP_WRITE(isp, isp->isp_respinrp, 0);
	ISP_WRITE(isp, isp->isp_respoutrp, 0);


	/*
	 * Do MD specific post initialization
	 */
	ISP_RESET1(isp);

	/*
	 * Wait for everything to finish firing up.
	 *
	 * Avoid doing this on the 2312 because you can generate a PCI
	 * parity error (chip breakage).
	 */
	if (IS_2312(isp)) {
		USEC_DELAY(100);
	} else {
		loops = MBOX_DELAY_COUNT;
		while (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {
			USEC_DELAY(100);
			if (--loops < 0) {
				ISP_RESET0(isp);
				isp_prt(isp, ISP_LOGERR,
				    "MBOX_BUSY never cleared on reset");
				return;
			}
		}
	}

	/*
	 * Up until this point we've done everything by just reading or
	 * setting registers. From this point on we rely on at least *some*
	 * kind of firmware running in the card.
	 */

	/*
	 * Do some sanity checking.
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_NO_OP;
	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		ISP_RESET0(isp);
		return;
	}

	if (IS_SCSI(isp)) {
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_MAILBOX_REG_TEST;
		mbs.param[1] = 0xdead;
		mbs.param[2] = 0xbeef;
		mbs.param[3] = 0xffff;
		mbs.param[4] = 0x1111;
		mbs.param[5] = 0xa5a5;
		mbs.param[6] = 0x0000;
		mbs.param[7] = 0x0000;
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			ISP_RESET0(isp);
			return;
		}
		if (mbs.param[1] != 0xdead || mbs.param[2] != 0xbeef ||
		    mbs.param[3] != 0xffff || mbs.param[4] != 0x1111 ||
		    mbs.param[5] != 0xa5a5) {
			ISP_RESET0(isp);
			isp_prt(isp, ISP_LOGERR,
			    "Register Test Failed (0x%x 0x%x 0x%x 0x%x 0x%x)",
			    mbs.param[1], mbs.param[2], mbs.param[3],
			    mbs.param[4], mbs.param[5]);
			return;
		}

	}

	/*
	 * Download new Firmware, unless requested not to do so.
	 * This is made slightly trickier in some cases where the
	 * firmware of the ROM revision is newer than the revision
	 * compiled into the driver. So, where we used to compare
	 * versions of our f/w and the ROM f/w, now we just see
	 * whether we have f/w at all and whether a config flag
	 * has disabled our download.
	 */
	if ((isp->isp_mdvec->dv_ispfw == NULL) ||
	    (isp->isp_confopts & ISP_CFG_NORELOAD)) {
		dodnld = 0;
	}

	if (IS_23XX(isp)) {
		code_org = ISP_CODE_ORG_2300;
	} else {
		code_org = ISP_CODE_ORG;
	}

	if (dodnld && IS_23XX(isp)) {
		const u_int16_t *ptr = isp->isp_mdvec->dv_ispfw;
		u_int16_t wi, wl, segno;
		u_int32_t la;

		la = code_org;
		segno = 0;

		for (;;) {
			u_int32_t nxtaddr;

#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG0,
			    "load 0x%x words of code at load address 0x%x",
			    ptr[3], la);
#endif

			wi = 0;
			wl = ptr[3];

			while (wi < ptr[3]) {
				u_int16_t *cp;
				u_int32_t nw;
				
				nw = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp)) >> 1;
				if (nw > wl) {
					nw = wl;
				}
				if (nw > (1 << 15)) {
					nw = 1 << 15;
				}
				cp = isp->isp_rquest;
				for (i = 0; i < nw; i++) {
					ISP_IOXPUT_16(isp,  ptr[wi++], &cp[i]);
					wl--;
				}
				MEMORYBARRIER(isp, SYNC_REQUEST,
				    0, ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp)));
				MEMZERO(&mbs, sizeof (mbs));
				mbs.param[0] = MBOX_LOAD_RISC_RAM;
				mbs.param[1] = la;
				mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
				mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
				mbs.param[4] = nw;
				mbs.param[6] = DMA_WD3(isp->isp_rquest_dma);
				mbs.param[7] = DMA_WD2(isp->isp_rquest_dma);
				mbs.param[8] = la >> 16;
				mbs.logval = MBLOGALL;
				isp_mboxcmd(isp, &mbs);
				if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
					isp_prt(isp, ISP_LOGERR,
					    "F/W Risc Ram Load Failed");
					ISP_RESET0(isp);
					return;
				}
				la += nw;
			}

			if (!IS_2322(isp)) {
				/*
				 * Verify that it downloaded correctly.
				 */
				MEMZERO(&mbs, sizeof (mbs));
				mbs.param[0] = MBOX_VERIFY_CHECKSUM;
				mbs.param[1] = code_org;
				mbs.logval = MBLOGNONE;
				isp_mboxcmd(isp, &mbs);
				if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
					isp_prt(isp, ISP_LOGERR, dcrc);
					ISP_RESET0(isp);
					return;
				}
				break;
			}

			if (++segno == 3) {
				break;
			}

			/*
			 * If we're a 2322, the firmware actually comes in
			 * three chunks. We loaded the first at the code_org
			 * address. The other two chunks, which follow right
			 * after each other in memory here, get loaded at
			 * addresses specfied at offset 0x9..0xB.
			 */

			nxtaddr = ptr[3];
			ptr = &ptr[nxtaddr];
			la = ptr[5] | ((ptr[4] & 0x3f) << 16);
		}
		isp->isp_loaded_fw = 1;
	} else if (dodnld) {
		union {
			const u_int16_t *cp;
			u_int16_t *np;
		} u;
		u.cp = isp->isp_mdvec->dv_ispfw;
		isp->isp_mbxworkp = &u.np[1];
		isp->isp_mbxwrk0 = u.np[3] - 1;
		isp->isp_mbxwrk1 = code_org + 1;
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_WRITE_RAM_WORD;
		mbs.param[1] = code_org;
		mbs.param[2] = u.np[0];
		mbs.logval = MBLOGNONE;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			isp_prt(isp, ISP_LOGERR,
			    "F/W download failed at word %d",
			    isp->isp_mbxwrk1 - code_org);
			ISP_RESET0(isp);
			return;
		}
		/*
		 * Verify that it downloaded correctly.
		 */
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_VERIFY_CHECKSUM;
		mbs.param[1] = code_org;
		mbs.logval = MBLOGNONE;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			isp_prt(isp, ISP_LOGERR, dcrc);
			ISP_RESET0(isp);
			return;
		}
		isp->isp_loaded_fw = 1;
	} else {
		isp->isp_loaded_fw = 0;
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG2, "skipping f/w download");
#endif
	}

	/*
	 * Now start it rolling.
	 *
	 * If we didn't actually download f/w,
	 * we still need to (re)start it.
	 */


	MEMZERO(&mbs, sizeof (mbs));
	mbs.timeout = 1000000;
	mbs.param[0] = MBOX_EXEC_FIRMWARE;
	if (IS_2322(isp)) {
		mbs.param[1] = code_org;
		if (isp->isp_loaded_fw) {
			mbs.param[2] = 0;
		} else {
			mbs.param[2] = 1;
		}
	} else {
		mbs.param[1] = code_org;
	}

	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (IS_2322(isp)) {
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			ISP_RESET0(isp);
			return;
		}
	}

	/*
	 * Give it a chance to finish starting up.
	 */
	USEC_DELAY(250000);

	if (IS_SCSI(isp)) {
		/*
		 * Set CLOCK RATE, but only if asked to.
		 */
		if (isp->isp_clock) {
			MEMZERO(&mbs, sizeof (mbs));
			mbs.param[0] = MBOX_SET_CLOCK_RATE;
			mbs.param[1] = isp->isp_clock;
			mbs.logval = MBLOGNONE;
			isp_mboxcmd(isp, &mbs);
			/* we will try not to care if this fails */
		}
	}

	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_ABOUT_FIRMWARE;
	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		ISP_RESET0(isp);
		return;
	}

	/*
	 * The SBus firmware that we are using apparently does not return
	 * major, minor, micro revisions in the mailbox registers, which
	 * is really, really, annoying.
	 */
	if (ISP_SBUS_SUPPORTED && isp->isp_bustype == ISP_BT_SBUS) {
		if (dodnld) {
#ifdef	ISP_TARGET_MODE
			isp->isp_fwrev[0] = 7;
			isp->isp_fwrev[1] = 55;
#else
			isp->isp_fwrev[0] = 1;
			isp->isp_fwrev[1] = 37;
#endif
			isp->isp_fwrev[2] = 0;
		} 
	} else {
		isp->isp_fwrev[0] = mbs.param[1];
		isp->isp_fwrev[1] = mbs.param[2];
		isp->isp_fwrev[2] = mbs.param[3];
	}

	isp_prt(isp, ISP_LOGALL,
	    "board type %s rev 0x%x, %s firmware rev %d.%d.%d",
	    btype, isp->isp_revision, dodnld? "loaded" : "resident",
	    isp->isp_fwrev[0], isp->isp_fwrev[1], isp->isp_fwrev[2]);

	if (IS_FC(isp)) {
		/*
		 * We do not believe firmware attributes for 2100 code less
		 * than 1.17.0, unless it's the firmware we specifically
		 * are loading.
		 *
		 * Note that all 22XX and later f/w is greater than 1.X.0.
		 */
		if ((ISP_FW_OLDER_THAN(isp, 1, 17, 1))) {
#ifdef	USE_SMALLER_2100_FIRMWARE
			FCPARAM(isp)->isp_fwattr = ISP_FW_ATTR_SCCLUN;
#else
			FCPARAM(isp)->isp_fwattr = 0;
#endif
		} else {
			FCPARAM(isp)->isp_fwattr = mbs.param[6];
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG0,
			    "Firmware Attributes = 0x%x", mbs.param[6]);
#endif
		}
		FCPARAM(isp)->isp_2klogin = 0;
		FCPARAM(isp)->isp_sccfw = 0;
		FCPARAM(isp)->isp_tmode = 0;
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
			FCPARAM(isp)->isp_sccfw = 1;
		}
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_2KLOGINS) {
			FCPARAM(isp)->isp_2klogin = 1;
			FCPARAM(isp)->isp_sccfw = 1;
		}
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_TMODE) {
			FCPARAM(isp)->isp_tmode = 1;
		}
		if (FCPARAM(isp)->isp_2klogin) {
			isp_prt(isp, ISP_LOGCONFIG, "2K Logins Supported");
		}
	}

	if (isp->isp_romfw_rev[0] || isp->isp_romfw_rev[1] ||
	    isp->isp_romfw_rev[2]) {
		isp_prt(isp, ISP_LOGCONFIG, "Last F/W revision was %d.%d.%d",
		    isp->isp_romfw_rev[0], isp->isp_romfw_rev[1],
		    isp->isp_romfw_rev[2]);
	}

	{
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_GET_FIRMWARE_STATUS;
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			ISP_RESET0(isp);
			return;
		}
		if (isp->isp_maxcmds >= mbs.param[2]) {
			isp->isp_maxcmds = mbs.param[2];
		}
	}
	isp_prt(isp, ISP_LOGCONFIG,
	    "%d max I/O command limit set", isp->isp_maxcmds);
	isp_fw_state(isp);

	isp->isp_state = ISP_RESETSTATE;

	/*
	 * Okay- now that we have new firmware running, we now (re)set our
	 * notion of how many luns we support. This is somewhat tricky because
	 * if we haven't loaded firmware, we sometimes do not have an easy way
	 * of knowing how many luns we support.
	 *
	 * Expanded lun firmware gives you 32 luns for SCSI cards and
	 * 16384 luns for Fibre Channel cards.
	 *
	 * It turns out that even for QLogic 2100s with ROM 1.10 and above
	 * we do get a firmware attributes word returned in mailbox register 6.
	 *
	 * Because the lun is in a different position in the Request Queue
	 * Entry structure for Fibre Channel with expanded lun firmware, we
	 * can only support one lun (lun zero) when we don't know what kind
	 * of firmware we're running.
	 */
	if (IS_SCSI(isp)) {
		if (dodnld) {
			if (IS_ULTRA2(isp) || IS_ULTRA3(isp)) {
				isp->isp_maxluns = 32;
			} else {
				isp->isp_maxluns = 8;
			}
		} else {
			isp->isp_maxluns = 8;
		}
	} else {
		if (FCPARAM(isp)->isp_sccfw) {
			isp->isp_maxluns = 16384;
		} else {
			isp->isp_maxluns = 16;
		}
	}
	/*
	 * Must do this first to get defaults established.
	 */
	if (IS_SCSI(isp)) {
		isp_setdfltparm(isp, 0);
		if (IS_DUALBUS(isp)) {
			isp_setdfltparm(isp, 1);
		}
	} else {
		isp_setdfltfcparm(isp);
	}

}

/*
 * Initialize Parameters of Hardware to a known state.
 *
 * Locks are held before coming here.
 */

void
isp_init(struct ispsoftc *isp)
{
	if (IS_FC(isp)) {
		/*
		 * Do this *before* initializing the firmware.
		 */
		ISP_MARK_PORTDB(isp, 0);
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_NIL;

		if (isp->isp_role != ISP_ROLE_NONE) {
			isp_fibre_init(isp);
		}
	} else {
		isp_scsi_init(isp);
	}
}

void
isp_scsi_init(struct ispsoftc *isp)
{
	sdparam *sdp_chan0, *sdp_chan1;
	mbreg_t mbs;

	sdp_chan0 = isp->isp_param;
	sdp_chan1 = sdp_chan0;
	if (IS_DUALBUS(isp)) {
		sdp_chan1++;
	}

	/*
	 * If we have no role (neither target nor initiator), return.
	 */
	if (isp->isp_role == ISP_ROLE_NONE) {
		return;
	}

	/* First do overall per-card settings. */

	/*
	 * If we have fast memory timing enabled, turn it on.
	 */
	if (sdp_chan0->isp_fast_mttr) {
		ISP_WRITE(isp, RISC_MTR, 0x1313);
	}

	/*
	 * Set Retry Delay and Count.
	 * You set both channels at the same time.
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SET_RETRY_COUNT;
	mbs.param[1] = sdp_chan0->isp_retry_count;
	mbs.param[2] = sdp_chan0->isp_retry_delay;
	mbs.param[6] = sdp_chan1->isp_retry_count;
	mbs.param[7] = sdp_chan1->isp_retry_delay;
	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
	}

	/*
	 * Set ASYNC DATA SETUP time. This is very important.
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SET_ASYNC_DATA_SETUP_TIME;
	mbs.param[1] = sdp_chan0->isp_async_data_setup;
	mbs.param[2] = sdp_chan1->isp_async_data_setup;
	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
	}

	/*
	 * Set ACTIVE Negation State.
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SET_ACT_NEG_STATE;
	mbs.param[1] =
	    (sdp_chan0->isp_req_ack_active_neg << 4) |
	    (sdp_chan0->isp_data_line_active_neg << 5);
	mbs.param[2] =
	    (sdp_chan1->isp_req_ack_active_neg << 4) |
	    (sdp_chan1->isp_data_line_active_neg << 5);
	mbs.logval = MBLOGNONE;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGERR,
		    "failed to set active negation state (%d,%d), (%d,%d)",
		    sdp_chan0->isp_req_ack_active_neg,
		    sdp_chan0->isp_data_line_active_neg,
		    sdp_chan1->isp_req_ack_active_neg,
		    sdp_chan1->isp_data_line_active_neg);
		/*
		 * But don't return.
		 */
	}

	/*
	 * Set the Tag Aging limit
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SET_TAG_AGE_LIMIT;
	mbs.param[1] = sdp_chan0->isp_tag_aging;
	mbs.param[2] = sdp_chan1->isp_tag_aging;
	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGERR, "failed to set tag age limit (%d,%d)",
		    sdp_chan0->isp_tag_aging, sdp_chan1->isp_tag_aging);
		return;
	}

	/*
	 * Set selection timeout.
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SET_SELECT_TIMEOUT;
	mbs.param[1] = sdp_chan0->isp_selection_timeout;
	mbs.param[2] = sdp_chan1->isp_selection_timeout;
	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
	}

	/* now do per-channel settings */
	isp_scsi_channel_init(isp, 0);
	if (IS_DUALBUS(isp))
		isp_scsi_channel_init(isp, 1);

	/*
	 * Now enable request/response queues
	 */

	if (IS_ULTRA2(isp) || IS_1240(isp)) {
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_INIT_RES_QUEUE_A64;
		mbs.param[1] = RESULT_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_result_dma);
		mbs.param[3] = DMA_WD0(isp->isp_result_dma);
		mbs.param[4] = 0;
		mbs.param[6] = DMA_WD3(isp->isp_result_dma);
		mbs.param[7] = DMA_WD2(isp->isp_result_dma);
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_residx = mbs.param[5];

		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_INIT_REQ_QUEUE_A64;
		mbs.param[1] = RQUEST_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
		mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
		mbs.param[5] = 0;
		mbs.param[6] = DMA_WD3(isp->isp_result_dma);
		mbs.param[7] = DMA_WD2(isp->isp_result_dma);
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_reqidx = isp->isp_reqodx = mbs.param[4];
	} else {
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_INIT_RES_QUEUE;
		mbs.param[1] = RESULT_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_result_dma);
		mbs.param[3] = DMA_WD0(isp->isp_result_dma);
		mbs.param[4] = 0;
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_residx = mbs.param[5];

		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_INIT_REQ_QUEUE;
		mbs.param[1] = RQUEST_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
		mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
		mbs.param[5] = 0;
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_reqidx = isp->isp_reqodx = mbs.param[4];
	}

	/*
	 * Turn on Fast Posting, LVD transitions
	 *
	 * Ultra2 F/W always has had fast posting (and LVD transitions)
	 *
	 * Ultra and older (i.e., SBus) cards may not. It's just safer
	 * to assume not for them.
	 */

	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SET_FW_FEATURES;
	mbs.param[1] = 0;
	if (IS_ULTRA2(isp))
		mbs.param[1] |= FW_FEATURE_LVD_NOTIFY;
#ifndef	ISP_NO_RIO
	if (IS_ULTRA2(isp) || IS_1240(isp))
		mbs.param[1] |= FW_FEATURE_RIO_16BIT;
#else
	if (IS_ULTRA2(isp) || IS_1240(isp))
		mbs.param[1] |= FW_FEATURE_FAST_POST;
#endif
	if (mbs.param[1] != 0) {
		u_int16_t sfeat = mbs.param[1];
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			isp_prt(isp, ISP_LOGINFO,
			    "Enabled FW features (0x%x)", sfeat);
		}
	}

	/*
	 * Let the outer layers decide whether to issue a SCSI bus reset.
	 */
	isp->isp_state = ISP_INITSTATE;
}

void
isp_scsi_channel_init(struct ispsoftc *isp, int channel)
{
	sdparam *sdp;
	mbreg_t mbs;
	int tgt;

	sdp = isp->isp_param;
	sdp += channel;

	/*
	 * Set (possibly new) Initiator ID.
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SET_INIT_SCSI_ID;
	mbs.param[1] = (channel << 7) | sdp->isp_initiator_id;
	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
	}
	isp_prt(isp, ISP_LOGINFO, "Initiator ID is %d on Channel %d",
	    sdp->isp_initiator_id, channel);


	/*
	 * Set current per-target parameters to an initial safe minimum.
	 */
	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		int lun;
		u_int16_t sdf;

		if (sdp->isp_devparam[tgt].dev_enable == 0) {
			continue;
		}
#ifndef	ISP_TARGET_MODE
		sdf = sdp->isp_devparam[tgt].goal_flags;
		sdf &= DPARM_SAFE_DFLT;
		/*
		 * It is not quite clear when this changed over so that
		 * we could force narrow and async for 1000/1020 cards,
		 * but assume that this is only the case for loaded
		 * firmware.
		 */
		if (isp->isp_loaded_fw) {
			sdf |= DPARM_NARROW | DPARM_ASYNC;
		}
#else
		/*
		 * The !$*!)$!$)* f/w uses the same index into some
		 * internal table to decide how to respond to negotiations,
		 * so if we've said "let's be safe" for ID X, and ID X
		 * selects *us*, the negotiations will back to 'safe'
		 * (as in narrow/async). What the f/w *should* do is
		 * use the initiator id settings to decide how to respond.
		 */
		sdp->isp_devparam[tgt].goal_flags = sdf = DPARM_DEFAULT;
#endif
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_SET_TARGET_PARAMS;
		mbs.param[1] = (channel << 15) | (tgt << 8);
		mbs.param[2] = sdf;
		if ((sdf & DPARM_SYNC) == 0) {
			mbs.param[3] = 0;
		} else {
			mbs.param[3] =
			    (sdp->isp_devparam[tgt].goal_offset << 8) |
			    (sdp->isp_devparam[tgt].goal_period);
		}
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0,
		    "Initial Settings bus%d tgt%d flags 0x%x off 0x%x per 0x%x",
		    channel, tgt, mbs.param[2], mbs.param[3] >> 8,
		    mbs.param[3] & 0xff);
#endif
		mbs.logval = MBLOGNONE;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			sdf = DPARM_SAFE_DFLT;
			MEMZERO(&mbs, sizeof (mbs));
			mbs.param[0] = MBOX_SET_TARGET_PARAMS;
			mbs.param[1] = (tgt << 8) | (channel << 15);
			mbs.param[2] = sdf;
			mbs.param[3] = 0;
			mbs.logval = MBLOGALL;
			isp_mboxcmd(isp, &mbs);
			if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
				continue;
			}
		}

		/*
		 * We don't update any information directly from the f/w
		 * because we need to run at least one command to cause a
		 * new state to be latched up. So, we just assume that we
		 * converge to the values we just had set.
		 *
		 * Ensure that we don't believe tagged queuing is enabled yet.
		 * It turns out that sometimes the ISP just ignores our
		 * attempts to set parameters for devices that it hasn't
		 * seen yet.
		 */
		sdp->isp_devparam[tgt].actv_flags = sdf & ~DPARM_TQING;
		for (lun = 0; lun < (int) isp->isp_maxluns; lun++) {
			MEMZERO(&mbs, sizeof (mbs));
			mbs.param[0] = MBOX_SET_DEV_QUEUE_PARAMS;
			mbs.param[1] = (channel << 15) | (tgt << 8) | lun;
			mbs.param[2] = sdp->isp_max_queue_depth;
			mbs.param[3] = sdp->isp_devparam[tgt].exc_throttle;
			mbs.logval = MBLOGALL;
			isp_mboxcmd(isp, &mbs);
			if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
				break;
			}
		}
	}
	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		if (sdp->isp_devparam[tgt].dev_refresh) {
			isp->isp_sendmarker |= (1 << channel);
			isp->isp_update |= (1 << channel);
			break;
		}
	}
}

/*
 * Fibre Channel specific initialization.
 */
void
isp_fibre_init(struct ispsoftc *isp)
{
	fcparam *fcp;
	isp_icb_t local, *icbp = &local;
	mbreg_t mbs;
	int ownloopid;
	u_int64_t nwwn, pwwn;

	fcp = isp->isp_param;

	MEMZERO(icbp, sizeof (*icbp));
	icbp->icb_version = ICB_VERSION1;
	icbp->icb_fwoptions = fcp->isp_fwoptions;

	/*
	 * Firmware Options are either retrieved from NVRAM or
	 * are patched elsewhere. We check them for sanity here
	 * and make changes based on board revision, but otherwise
	 * let others decide policy.
	 */

	/*
	 * If this is a 2100 < revision 5, we have to turn off FAIRNESS.
	 */
	if (IS_2100(isp) && isp->isp_revision < 5) {
		icbp->icb_fwoptions &= ~ICBOPT_FAIRNESS;
	}

	/*
	 * We have to use FULL LOGIN even though it resets the loop too much
	 * because otherwise port database entries don't get updated after
	 * a LIP- this is a known f/w bug for 2100 f/w less than 1.17.0.
	 */
	if (!ISP_FW_NEWER_THAN(isp, 1, 17, 0)) {
		icbp->icb_fwoptions |= ICBOPT_FULL_LOGIN;
	}

	/*
	 * Insist on Port Database Update Async notifications
	 */
	icbp->icb_fwoptions |= ICBOPT_PDBCHANGE_AE;

	/*
	 * Make sure that target role reflects into fwoptions.
	 */
	if (isp->isp_role & ISP_ROLE_TARGET) {
		icbp->icb_fwoptions |= ICBOPT_TGT_ENABLE;
	} else {
		icbp->icb_fwoptions &= ~ICBOPT_TGT_ENABLE;
	}

	if (isp->isp_role & ISP_ROLE_INITIATOR) {
		icbp->icb_fwoptions &= ~ICBOPT_INI_DISABLE;
	} else {
		icbp->icb_fwoptions |= ICBOPT_INI_DISABLE;
	}

	icbp->icb_maxfrmlen = fcp->isp_maxfrmlen;
	if (icbp->icb_maxfrmlen < ICB_MIN_FRMLEN ||
	    icbp->icb_maxfrmlen > ICB_MAX_FRMLEN) {
		isp_prt(isp, ISP_LOGERR,
		    "bad frame length (%d) from NVRAM- using %d",
		    fcp->isp_maxfrmlen, ICB_DFLT_FRMLEN);
		icbp->icb_maxfrmlen = ICB_DFLT_FRMLEN;
	}
	icbp->icb_maxalloc = fcp->isp_maxalloc;
	if (icbp->icb_maxalloc < 1) {
		isp_prt(isp, ISP_LOGERR,
		    "bad maximum allocation (%d)- using 16", fcp->isp_maxalloc);
		icbp->icb_maxalloc = 16;
	}
	icbp->icb_execthrottle = fcp->isp_execthrottle;
	if (icbp->icb_execthrottle < 1) {
		isp_prt(isp, ISP_LOGERR,
		    "bad execution throttle of %d- using 16",
		    fcp->isp_execthrottle);
		icbp->icb_execthrottle = ICB_DFLT_THROTTLE;
	}
	icbp->icb_retry_delay = fcp->isp_retry_delay;
	icbp->icb_retry_count = fcp->isp_retry_count;
	icbp->icb_hardaddr = fcp->isp_loopid;
	ownloopid = (isp->isp_confopts & ISP_CFG_OWNLOOPID) != 0;
	if (icbp->icb_hardaddr > 125) {
		icbp->icb_hardaddr = 0;
		ownloopid = 0;
	}

	/*
	 * Our life seems so much better with 2200s and later with
	 * the latest f/w if we set Hard Address.
	 */
	if (ownloopid || ISP_FW_NEWER_THAN(isp, 2, 2, 5)) {
		icbp->icb_fwoptions |= ICBOPT_HARD_ADDRESS;
	}

	/*
	 * Right now we just set extended options to prefer point-to-point
	 * over loop based upon some soft config options.
	 * 
	 * NB: for the 2300, ICBOPT_EXTENDED is required.
	 */
	if (IS_2200(isp) || IS_23XX(isp)) {
		icbp->icb_fwoptions |= ICBOPT_EXTENDED;
		/*
		 * Prefer or force Point-To-Point instead Loop?
		 */
		switch(isp->isp_confopts & ISP_CFG_PORT_PREF) {
		case ISP_CFG_NPORT:
			icbp->icb_xfwoptions |= ICBXOPT_PTP_2_LOOP;
			break;
		case ISP_CFG_NPORT_ONLY:
			icbp->icb_xfwoptions |= ICBXOPT_PTP_ONLY;
			break;
		case ISP_CFG_LPORT_ONLY:
			icbp->icb_xfwoptions |= ICBXOPT_LOOP_ONLY;
			break;
		default:
			icbp->icb_xfwoptions |= ICBXOPT_LOOP_2_PTP;
			break;
		}
		if (IS_2200(isp)) {
			icbp->icb_fwoptions &= ~ICBOPT_FAST_POST;
		} else {
			/*
			 * QLogic recommends that FAST Posting be turned
			 * off for 23XX cards and instead allow the HBA
			 * to write response queue entries and interrupt
			 * after a delay (ZIO).
			 */
			icbp->icb_fwoptions &= ~ICBOPT_FAST_POST;
			if ((fcp->isp_xfwoptions & ICBXOPT_TIMER_MASK) ==
			    ICBXOPT_ZIO) {
				icbp->icb_xfwoptions |= ICBXOPT_ZIO;
				icbp->icb_idelaytimer = 10;
			}
			if (isp->isp_confopts & ISP_CFG_ONEGB) {
				icbp->icb_zfwoptions |= ICBZOPT_RATE_ONEGB;
			} else if (isp->isp_confopts & ISP_CFG_TWOGB) {
				icbp->icb_zfwoptions |= ICBZOPT_RATE_TWOGB;
			} else {
				icbp->icb_zfwoptions |= ICBZOPT_RATE_AUTO;
			}
			if (fcp->isp_zfwoptions & ICBZOPT_50_OHM) {
				icbp->icb_zfwoptions |= ICBZOPT_50_OHM;
			}
		}
	}


	/*
	 * For 22XX > 2.1.26 && 23XX, set some options.
	 * XXX: Probably okay for newer 2100 f/w too.
	 */
	if (ISP_FW_NEWER_THAN(isp, 2, 26, 0)) {
		/*
		 * Turn on LIP F8 async event (1)
		 * Turn on generate AE 8013 on all LIP Resets (2)
		 * Disable LIP F7 switching (8)
		 */
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_SET_FIRMWARE_OPTIONS;
		mbs.param[1] = 0xb;
		mbs.param[2] = 0;
		mbs.param[3] = 0;
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
	}
	icbp->icb_logintime = ICB_LOGIN_TOV;
	icbp->icb_lunetimeout = ICB_LUN_ENABLE_TOV;

	nwwn = ISP_NODEWWN(isp);
	pwwn = ISP_PORTWWN(isp);
	if (nwwn && pwwn) {
		icbp->icb_fwoptions |= ICBOPT_BOTH_WWNS;
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, nwwn);
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pwwn);
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG1,
		    "Setting ICB Node 0x%08x%08x Port 0x%08x%08x",
		    ((u_int32_t) (nwwn >> 32)),
		    ((u_int32_t) (nwwn & 0xffffffff)),
		    ((u_int32_t) (pwwn >> 32)),
		    ((u_int32_t) (pwwn & 0xffffffff)));
#endif
	} else if (pwwn) {
		icbp->icb_fwoptions &= ~ICBOPT_BOTH_WWNS;
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pwwn);
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG1,
		    "Setting ICB Port 0x%08x%08x",
		    ((u_int32_t) (pwwn >> 32)),
		    ((u_int32_t) (pwwn & 0xffffffff)));
#endif
	} else {
		isp_prt(isp, ISP_LOGERR, "No valid WWNs to use");
		return;
	}
	icbp->icb_rqstqlen = RQUEST_QUEUE_LEN(isp);
	if (icbp->icb_rqstqlen < 1) {
		isp_prt(isp, ISP_LOGERR, "bad request queue length");
	}
	icbp->icb_rsltqlen = RESULT_QUEUE_LEN(isp);
	if (icbp->icb_rsltqlen < 1) {
		isp_prt(isp, ISP_LOGERR, "bad result queue length");
	}
	icbp->icb_rqstaddr[RQRSP_ADDR0015] = DMA_WD0(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR1631] = DMA_WD1(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR3247] = DMA_WD2(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR4863] = DMA_WD3(isp->isp_rquest_dma);
	icbp->icb_respaddr[RQRSP_ADDR0015] = DMA_WD0(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR1631] = DMA_WD1(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR3247] = DMA_WD2(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR4863] = DMA_WD3(isp->isp_result_dma);

#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0,
	    "isp_fibre_init: fwopt 0x%x xfwopt 0x%x zfwopt 0x%x",
	    icbp->icb_fwoptions, icbp->icb_xfwoptions, icbp->icb_zfwoptions);
#endif

	FC_SCRATCH_ACQUIRE(isp);
	isp_put_icb(isp, icbp, (isp_icb_t *)fcp->isp_scratch);

	/*
	 * Init the firmware
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_INIT_FIRMWARE;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
	mbs.logval = MBLOGALL;
	mbs.timeout = 30 * 1000000;
#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0, "INIT F/W from %p (%08x%08x)",
	    fcp->isp_scratch, (u_int32_t) ((u_int64_t)fcp->isp_scdma >> 32),
	    (u_int32_t) fcp->isp_scdma);
#endif
	MEMORYBARRIER(isp, SYNC_SFORDEV, 0, sizeof (*icbp));
	isp_mboxcmd(isp, &mbs);
	FC_SCRATCH_RELEASE(isp);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_print_bytes(isp, "isp_fibre_init", sizeof (*icbp), icbp);
		return;
	}
	isp->isp_reqidx = 0;
	isp->isp_reqodx = 0;
	isp->isp_residx = 0;

	/*
	 * Whatever happens, we're now committed to being here.
	 */
	isp->isp_state = ISP_INITSTATE;
}

void
isp_mark_portdb(struct ispsoftc *isp, int onprobation)
{
	fcparam *fcp = (fcparam *) isp->isp_param;
	int i;

	for (i = 0; i < MAX_FC_TARG; i++) {
		if (onprobation == 0) {
			MEMZERO(&fcp->portdb[i], sizeof (fcportdb_t));
		} else {
			switch (fcp->portdb[i].state) {
			case FC_PORTDB_STATE_CHANGED:
			case FC_PORTDB_STATE_PENDING_VALID:
			case FC_PORTDB_STATE_VALID:
			case FC_PORTDB_STATE_PROBATIONAL:
				fcp->portdb[i].state =
					FC_PORTDB_STATE_PROBATIONAL;
				break;
			case FC_PORTDB_STATE_ZOMBIE:
				break;
			case FC_PORTDB_STATE_NIL:
			default:
				MEMZERO(&fcp->portdb[i], sizeof (fcportdb_t));
				fcp->portdb[i].state =
					FC_PORTDB_STATE_NIL;
				break;
			}
		}
	}
}

/*
 * Perform an IOCB PLOGI or LOGO via EXECUTE IOCB A64 for 24XX cards
 * or via FABRIC LOGIN/FABRIC LOGOUT for other cards.
 */
int
isp_plogx(struct ispsoftc *isp, u_int16_t handle, u_int32_t portid, int flags, int gs)
{
	int action = flags & PLOGX_FLG_CMD_MASK;
	if (action == PLOGX_FLG_CMD_PLOGI) {
		return (isp_port_login(isp, handle, portid));
	} else if (action == PLOGX_FLG_CMD_LOGO) {
		return (isp_port_logout(isp, handle, portid));
	} else {
		return (MBOX_INVALID_COMMAND);
	}
}

int
isp_port_login(struct ispsoftc *isp, u_int16_t handle, u_int32_t portid)
{
	mbreg_t mbs;

	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_FABRIC_LOGIN;
	if (FCPARAM(isp)->isp_2klogin) {
		mbs.param[1] = handle;
		mbs.ibits = (1 << 10);
	} else {
		mbs.param[1] = handle << 8;
	}
	mbs.param[2] = portid >> 16;
	mbs.param[3] = portid;
	mbs.logval = MBLOGNONE;
	mbs.timeout = 500000;
	isp_mboxcmd(isp, &mbs);

	switch (mbs.param[0]) {
	case MBOX_PORT_ID_USED:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0,
		    "isp_plogi_old: portid 0x%06x already logged in as %u",
		    portid, mbs.param[1]);
#endif
		return (MBOX_PORT_ID_USED | (mbs.param[1] << 16));

	case MBOX_LOOP_ID_USED:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0,
		    "isp_plogi_old: handle %u in use for port id 0x%02xXXXX",
		    handle, mbs.param[1] & 0xff);
#endif
		return (MBOX_LOOP_ID_USED);

	case MBOX_COMMAND_COMPLETE:
		return (0);

	case MBOX_COMMAND_ERROR:
		isp_prt(isp, ISP_LOGINFO,
		    "isp_plogi_old: error 0x%x in PLOGI to port 0x%06x",
		    mbs.param[1], portid);
		return (MBOX_COMMAND_ERROR);

	case MBOX_ALL_IDS_USED:
		isp_prt(isp, ISP_LOGINFO,
		    "isp_plogi_old: all IDs used for fabric login");
		return (MBOX_ALL_IDS_USED);

	default:
		isp_prt(isp, ISP_LOGINFO,
		    "isp_plogi_old: error 0x%x on port login of 0x%06x@@0x%0x",
		    mbs.param[0], portid, handle);
		return (mbs.param[0]);
	}
}

int
isp_port_logout(struct ispsoftc *isp, u_int16_t handle, u_int32_t portid)
{
	mbreg_t mbs;

	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_FABRIC_LOGOUT;
	if (FCPARAM(isp)->isp_2klogin) {
		mbs.param[1] = handle;
		mbs.ibits = (1 << 10);
	} else {
		mbs.param[1] = handle << 8;
	}
	mbs.logval = MBLOGNONE;
	mbs.timeout = 100000;
	isp_mboxcmd(isp, &mbs);
	return (mbs.param[0] == MBOX_COMMAND_COMPLETE? 0 : mbs.param[0]);
}

int
isp_getpdb(struct ispsoftc *isp, u_int16_t id, isp_pdb_t *pdb, int dolock)
{
	fcparam *fcp = (fcparam *) isp->isp_param;
	mbreg_t mbs;
	union {
		isp_pdb_21xx_t fred;
		isp_pdb_24xx_t bill;
	} un;

	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_GET_PORT_DB;
	if (FCPARAM(isp)->isp_2klogin) {
		mbs.param[1] = id;
		mbs.ibits = (1 << 10);
	} else {
		mbs.param[1] = id << 8;
	}
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
	mbs.timeout = 250000;
	mbs.logval = MBLOGALL & ~MBOX_COMMAND_PARAM_ERROR;
	if (dolock) {
		FC_SCRATCH_ACQUIRE(isp);
	}
	MEMORYBARRIER(isp, SYNC_SFORDEV, 0, sizeof (un));
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		if (dolock) {
			FC_SCRATCH_RELEASE(isp);
		}
		return (-1);
	}
	{
		isp_get_pdb_21xx(isp, fcp->isp_scratch, &un.fred);
		pdb->handle = un.fred.pdb_loopid;
		pdb->s3_role = un.fred.pdb_prli_svc3;
		pdb->portid = BITS2WORD(un.fred.pdb_portid_bits);
		MEMCPY(pdb->portname, un.fred.pdb_portname, 8);
		MEMCPY(pdb->nodename, un.fred.pdb_nodename, 8);
	}
	if (dolock) {
		FC_SCRATCH_RELEASE(isp);
	}
	return (0);
}

u_int64_t
isp_get_portname(struct ispsoftc *isp, int loopid, int nodename)
{
	u_int64_t wwn = (u_int64_t) -1;
	mbreg_t mbs;

	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_GET_PORT_NAME;
	if (FCPARAM(isp)->isp_2klogin || IS_24XX(isp)) {
		mbs.param[1] = loopid;
		mbs.ibits = (1 << 10);
		if (nodename) {
			mbs.param[10] = 1;
		}
	} else {
		mbs.param[1] = loopid << 8;
		if (nodename) {
			mbs.param[1] |= 1;
		}
	}
	mbs.logval = MBLOGALL & ~MBOX_COMMAND_PARAM_ERROR;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return (wwn);
	}
	{
		wwn =
		    (((u_int64_t)(mbs.param[2] & 0xff))  << 56) |
		    (((u_int64_t)(mbs.param[2] >> 8))	<< 48) |
		    (((u_int64_t)(mbs.param[3] & 0xff))	<< 40) |
		    (((u_int64_t)(mbs.param[3] >> 8))	<< 32) |
		    (((u_int64_t)(mbs.param[6] & 0xff))	<< 24) |
		    (((u_int64_t)(mbs.param[6] >> 8))	<< 16) |
		    (((u_int64_t)(mbs.param[7] & 0xff))	<<  8) |
		    (((u_int64_t)(mbs.param[7] >> 8)));
	}
	return (wwn);
}

/*
 * Make sure we have good FC link.
 */

int
isp_fclink_test(struct ispsoftc *isp, int usdelay)
{
	static const char *toponames[] = {
		"Private Loop",
		"FL Port",
		"N-Port to N-Port",
		"F Port",
		"F Port (no FLOGI_ACC response)"
	};
	mbreg_t mbs;
	int count, check_for_fabric;
	u_int8_t lwfs;
	int loopid;
	fcparam *fcp;
	fcportdb_t *lp;
	isp_pdb_t pdb;

	fcp = isp->isp_param;

	isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0, "FC Link Test Entry");
	ISP_MARK_PORTDB(isp, 1);

	/*
	 * Wait up to N microseconds for F/W to go to a ready state.
	 */
	lwfs = FW_CONFIG_WAIT;
	count = 0;
	while (count < usdelay) {
		u_int64_t enano;
		u_int32_t wrk;
		NANOTIME_T hra, hrb;

		GET_NANOTIME(&hra);
		isp_fw_state(isp);
		if (lwfs != fcp->isp_fwstate) {
			isp_prt(isp, ISP_LOGCONFIG|ISP_LOGSANCFG,
			    "Firmware State <%s->%s>",
			    ispfc_fw_statename((int)lwfs),
			    ispfc_fw_statename((int)fcp->isp_fwstate));
			lwfs = fcp->isp_fwstate;
		}
		if (fcp->isp_fwstate == FW_READY &&
		    fcp->isp_loopstate >= LOOP_PDB_RCVD) {
			break;
		}
		GET_NANOTIME(&hrb);

		/*
		 * Get the elapsed time in nanoseconds.
		 * Always guaranteed to be non-zero.
		 */
		enano = NANOTIME_SUB(&hrb, &hra);

#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG1,
		    "usec%d: 0x%lx->0x%lx enano 0x%x%08x",
		    count, (long) GET_NANOSEC(&hra), (long) GET_NANOSEC(&hrb),
		    (u_int32_t)(enano >> 32), (u_int32_t)(enano & 0xffffffff));
#endif

		/*
		 * If the elapsed time is less than 1 millisecond,
		 * delay a period of time up to that millisecond of
		 * waiting.
		 *
		 * This peculiar code is an attempt to try and avoid
		 * invoking u_int64_t math support functions for some
		 * platforms where linkage is a problem.
		 */
		if (enano < (1000 * 1000)) {
			count += 1000;
			enano = (1000 * 1000) - enano;
			while (enano > (u_int64_t) 4000000000U) {
				USEC_SLEEP(isp, 4000000);
				enano -= (u_int64_t) 4000000000U;
			}
			wrk = enano;
			wrk /= 1000;
			USEC_SLEEP(isp, wrk);
		} else {
			while (enano > (u_int64_t) 4000000000U) {
				count += 4000000;
				enano -= (u_int64_t) 4000000000U;
			}
			wrk = enano;
			count += (wrk / 1000);
		}
	}

	/*
	 * If we haven't gone to 'ready' state, return.
	 */
	if (fcp->isp_fwstate != FW_READY) {
		isp_prt(isp, ISP_LOGSANCFG,
		    "isp_fclink_test: not at FW_READY state");
		return (-1);
	}

	/*
	 * Get our Loop ID and Port ID.
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_GET_LOOP_ID;
	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return (-1);
	}

	if (FCPARAM(isp)->isp_2klogin) {
		fcp->isp_loopid = mbs.param[1];
	} else {
		fcp->isp_loopid = mbs.param[1] & 0xff;
	}

	if (IS_2100(isp)) {
		fcp->isp_topo = TOPO_NL_PORT;
	} else {
		int topo = (int) mbs.param[6];
		if (topo < TOPO_NL_PORT || topo > TOPO_PTP_STUB) {
			topo = TOPO_PTP_STUB;
		}
		fcp->isp_topo = topo;
	}
	fcp->isp_portid = mbs.param[2] | (mbs.param[3] << 16);

	if (IS_2100(isp)) {
		/*
		 * Don't bother with fabric if we are using really old
		 * 2100 firmware. It's just not worth it.
		 */
		if (ISP_FW_NEWER_THAN(isp, 1, 15, 37)) {
			check_for_fabric = 1;
		} else {
			check_for_fabric = 0;
		}
	} else if (fcp->isp_topo == TOPO_FL_PORT ||
	    fcp->isp_topo == TOPO_F_PORT) {
		check_for_fabric = 1;
	} else {
		check_for_fabric = 0;
	}

	loopid = FL_ID;

	if (check_for_fabric && isp_getpdb(isp, loopid, &pdb, 1) == 0) {
		int r;
		if (IS_2100(isp)) {
			fcp->isp_topo = TOPO_FL_PORT;
		}
		if (pdb.portid == 0) {
			/*
			 * Crock.
			 */
			fcp->isp_topo = TOPO_NL_PORT;
			goto not_on_fabric;
		}

		/*
		 * Save the Fabric controller's port database entry.
		 */
		lp = &fcp->portdb[FL_ID];
		lp->state = FC_PORTDB_STATE_PENDING_VALID;
		MAKE_WWN_FROM_NODE_NAME(lp->node_wwn, pdb.nodename);
		MAKE_WWN_FROM_NODE_NAME(lp->port_wwn, pdb.portname);
		lp->roles = (pdb.s3_role & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
		lp->portid = pdb.portid;
		lp->handle = pdb.handle;
		lp->new_portid = lp->portid;
		lp->new_roles = lp->roles;
		r = isp_register_fc4_type(isp);
		if (r) {
			isp_prt(isp, ISP_LOGSANCFG,
			    "isp_fclink_test: register fc4 type failed");
			return (-1);
		}
	} else {
not_on_fabric:
		fcp->portdb[FL_ID].state = FC_PORTDB_STATE_NIL;
	}

	fcp->isp_gbspeed = 1;
	if (IS_23XX(isp)) {
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_GET_SET_DATA_RATE;
		mbs.param[1] = MBGSD_GET_RATE;
		/* mbs.param[2] undefined if we're just getting rate */
		mbs.logval = MBLOGALL;
		mbs.timeout = 3000000;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			if (mbs.param[1] == MBGSD_FOURGB) {
				isp_prt(isp, ISP_LOGINFO, "4Gb link speed/s");
				fcp->isp_gbspeed = 4;
			} if (mbs.param[1] == MBGSD_TWOGB) {
				isp_prt(isp, ISP_LOGINFO, "2Gb link speed/s");
				fcp->isp_gbspeed = 2;
			}
		}
	}

	/*
	 * Announce ourselves, too.
	 */
	isp_prt(isp, ISP_LOGSANCFG|ISP_LOGCONFIG, topology, fcp->isp_portid,
	    fcp->isp_loopid, toponames[fcp->isp_topo]);
	isp_prt(isp, ISP_LOGSANCFG|ISP_LOGCONFIG, ourwwn,
	    (u_int32_t) (ISP_NODEWWN(isp) >> 32),
	    (u_int32_t) ISP_NODEWWN(isp),
	    (u_int32_t) (ISP_PORTWWN(isp) >> 32),
	    (u_int32_t) ISP_PORTWWN(isp));
	isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0, "FC Link Test Complete");
	return (0);
}

const char *
ispfc_fw_statename(int state)
{
	switch(state) {
	case FW_CONFIG_WAIT:	return "Config Wait";
	case FW_WAIT_AL_PA:	return "Waiting for AL_PA";
	case FW_WAIT_LOGIN:	return "Wait Login";
	case FW_READY:		return "Ready";
	case FW_LOSS_OF_SYNC:	return "Loss Of Sync";
	case FW_ERROR:		return "Error";
	case FW_REINIT:		return "Re-Init";
	case FW_NON_PART:	return "Nonparticipating";
	default:		return "?????";
	}
}

/*
 * Complete the synchronization of our Port Database.
 *
 * At this point, we've scanned the local loop (if any) and the fabric
 * and performed fabric logins on all new devices.
 *
 * Our task here is to go through our port database and remove any entities
 * that are still marked probational (issuing PLOGO for ones which we had
 * PLOGI'd into) or are dead.
 *
 * Our task here is to also check policy to decide whether devices which
 * have *changed* in some way should still be kept active. For example,
 * if a device has just changed PortID, we can either elect to treat it
 * as an old device or as a newly arrived device (and notify the outer
 * layer appropriately).
 *
 * We also do initiator map target id assignment here for new initiator
 * devices and refresh old ones ot make sure that they point to the corret
 * entities.
 */
int
isp_pdb_sync(struct ispsoftc *isp)
{
	fcparam *fcp = isp->isp_param;
	fcportdb_t *lp;
	u_int16_t dbidx;

	if (fcp->isp_loopstate == LOOP_READY) {
		return (0);
	}

	/*
	 * Make sure we're okay for doing this right now.
	 */
	if (fcp->isp_loopstate != LOOP_PDB_RCVD &&
	    fcp->isp_loopstate != LOOP_FSCAN_DONE &&
	    fcp->isp_loopstate != LOOP_LSCAN_DONE) {
		isp_prt(isp, ISP_LOGWARN, "isp_pdb_sync: bad loopstate %d",
		    fcp->isp_loopstate);
		return (-1);
	}

	if (fcp->isp_topo == TOPO_FL_PORT ||
	    fcp->isp_topo == TOPO_NL_PORT ||
	    fcp->isp_topo == TOPO_N_PORT) {
		if (fcp->isp_loopstate < LOOP_LSCAN_DONE) {
			if (isp_scan_loop(isp) != 0) {
				isp_prt(isp, ISP_LOGWARN,
				    "isp_pdb_sync: isp_scan_loop failed");
				return (-1);
			}
		}
	}

	if (fcp->isp_topo == TOPO_F_PORT || fcp->isp_topo == TOPO_FL_PORT) {
		if (fcp->isp_loopstate < LOOP_FSCAN_DONE) {
			if (isp_scan_fabric(isp) != 0) {
				isp_prt(isp, ISP_LOGWARN,
				    "isp_pdb_sync: isp_scan_fabric failed");
				return (-1);
			}
		}
	}

	isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0, "Synchronizing PDBs");

	fcp->isp_loopstate = LOOP_SYNCING_PDB;

	for (dbidx = 0; dbidx < MAX_FC_TARG; dbidx++) {
		lp = &fcp->portdb[dbidx];

		if (lp->state == FC_PORTDB_STATE_NIL) {
			continue;
		}

		if (lp->state == FC_PORTDB_STATE_VALID) {
			if (dbidx != FL_ID) {
				isp_prt(isp,
				    ISP_LOGERR, "portdb idx %d already valid",
			    	    dbidx);
			}
			continue;
		}

		switch (lp->state) {
		case FC_PORTDB_STATE_PROBATIONAL:
		case FC_PORTDB_STATE_DEAD:
			/*
			 * It's up to the outer layers to clear isp_ini_map.
			 */
			lp->state = FC_PORTDB_STATE_NIL;
			isp_async(isp, ISPASYNC_DEV_GONE, lp);
			if (lp->autologin == 0) {
				(void) isp_plogx(isp, lp->handle, lp->portid,
				    PLOGX_FLG_CMD_LOGO |
				    PLOGX_FLG_IMPLICIT |
				    PLOGX_FLG_FREE_NPHDL, 0);
			} else {
				lp->autologin = 0;
			}
			lp->new_roles = 0;
			lp->new_portid = 0;
			/*
			 * Note that we might come out of this with our state
			 * set to FC_PORTDB_STATE_ZOMBIE.
			 */
			break;
		case FC_PORTDB_STATE_NEW:
			/*
			 * It's up to the outer layers to assign a virtual
			 * target id in isp_ini_map (if any).
			 */
			lp->portid = lp->new_portid;
			lp->roles = lp->new_roles;
			lp->state = FC_PORTDB_STATE_VALID;
			isp_async(isp, ISPASYNC_DEV_ARRIVED, lp);
			lp->new_roles = 0;
			lp->new_portid = 0;
			lp->reserved = 0;
			lp->new_reserved = 0;
			break;
		case FC_PORTDB_STATE_CHANGED:
/*
 * XXXX FIX THIS
 */
			lp->state = FC_PORTDB_STATE_VALID;
			isp_async(isp, ISPASYNC_DEV_CHANGED, lp);
			lp->new_roles = 0;
			lp->new_portid = 0;
			lp->reserved = 0;
			lp->new_reserved = 0;
			break;
		case FC_PORTDB_STATE_PENDING_VALID:
			lp->portid = lp->new_portid;
			lp->roles = lp->new_roles;
			if (lp->ini_map_idx) {
				int t = lp->ini_map_idx - 1;
				fcp->isp_ini_map[t] = dbidx + 1;
			}
			lp->state = FC_PORTDB_STATE_VALID;
			isp_async(isp, ISPASYNC_DEV_STAYED, lp);
			if (dbidx != FL_ID) {
				lp->new_roles = 0;
				lp->new_portid = 0;
			}
			lp->reserved = 0;
			lp->new_reserved = 0;
			break;
		case FC_PORTDB_STATE_ZOMBIE:
			break;
		default:
			isp_prt(isp, ISP_LOGWARN,
			    "isp_scan_loop: state %d for idx %d",
			    lp->state, dbidx);
			isp_dump_portdb(isp);
		}
	}

	/*
	 * If we get here, we've for sure seen not only a valid loop
	 * but know what is or isn't on it, so mark this for usage
	 * in isp_start.
	 */
	fcp->loop_seen_once = 1;
	fcp->isp_loopstate = LOOP_READY;
	return (0);
}

/*
 * Scan local loop for devices.
 */
int
isp_scan_loop(struct ispsoftc *isp)
{
	fcportdb_t *lp, tmp;
	fcparam *fcp = isp->isp_param;
	int i;
	isp_pdb_t pdb;
	u_int16_t handle, lim = 0;

	if (fcp->isp_fwstate < FW_READY ||
	    fcp->isp_loopstate < LOOP_PDB_RCVD) {
		return (-1);
	}

	if (fcp->isp_loopstate > LOOP_SCANNING_LOOP) {
		return (0);
	}

	/*
	 * Check our connection topology.
	 *
	 * If we're a public or private loop, we scan 0..125 as handle values.
	 * The firmware has (typically) peformed a PLOGI for us.
	 *
	 * If we're a N-port connection, we treat this is a short loop (0..1).
	 *
	 * If we're in target mode, we can all possible handles to see who
	 * might have logged into us.
	 */
	switch (fcp->isp_topo) {
	case TOPO_NL_PORT:
	case TOPO_FL_PORT:
		lim = LOCAL_LOOP_LIM;
		break;
	case TOPO_N_PORT:
		lim = 2;
		break;
	default:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "no loop topology to scan");
#endif
		fcp->isp_loopstate = LOOP_LSCAN_DONE;
		return (0);
	}

	fcp->isp_loopstate = LOOP_SCANNING_LOOP;

	isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0, "FC scan loop 0..%d", lim-1);


	/*
	 * Run through the list and get the port database info for each one.
	 */
	for (handle = 0; handle < lim; handle++) {
		/*
		 * But don't even try for ourselves...
	 	 */
		if (handle == fcp->isp_loopid) {
			continue;
		}

		/*
		 * In older cards with older f/w GET_PORT_DATABASE has been
		 * known to hang. This trick gets around that problem.
		 */
		if (IS_2100(isp) || IS_2200(isp)) {
			u_int64_t node_wwn = isp_get_portname(isp, handle, 1);
			if (fcp->isp_loopstate < LOOP_SCANNING_LOOP) {
				return (-1);
			}
			if (node_wwn == 0) {
				continue;
			}
		}

		/*
		 * Get the port database entity for this index.
		 */
		if (isp_getpdb(isp, handle, &pdb, 1) != 0) {
			if (fcp->isp_loopstate < LOOP_SCANNING_LOOP) {
				ISP_MARK_PORTDB(isp, 1);
				return (-1);
			}
			continue;
		}

		if (fcp->isp_loopstate < LOOP_SCANNING_LOOP) {
			ISP_MARK_PORTDB(isp, 1);
			return (-1);
		}

		/*
		 * On *very* old 2100 firmware we would end up sometimes
		 * with the firmware returning the port database entry
		 * for something else. We used to restart this, but
		 * now we just punt.
		 */
		if (IS_2100(isp) && pdb.handle != handle) {
			isp_prt(isp, ISP_LOGWARN,
			    "giving up on synchronizing the port database");
			ISP_MARK_PORTDB(isp, 1);
			return (-1);
		}

		/*
		 * Save the pertinent info locally.
		 */
		MAKE_WWN_FROM_NODE_NAME(tmp.node_wwn, pdb.nodename);
		MAKE_WWN_FROM_NODE_NAME(tmp.port_wwn, pdb.portname);
		tmp.roles = (pdb.s3_role & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
		tmp.portid = pdb.portid;
		tmp.handle = pdb.handle;

		/*
		 * Check to make sure it's still a valid entry. The 24XX seems
		 * to return a portid but not a WWPN/WWNN or role for devices
		 * which shift on a loop.
		 */
		if (tmp.node_wwn == 0 || tmp.port_wwn == 0 || tmp.portid == 0) {
			int a, b, c;
			a = (tmp.node_wwn == 0);
			b = (tmp.port_wwn == 0);
			c = (tmp.portid == 0);
			isp_prt(isp, ISP_LOGWARN,
			    "bad pdb (%1d%1d%1d) @@ handle 0x%x", a, b, c,
			    handle);
			isp_dump_portdb(isp);
			continue;
		}

		/*
		 * Now search the entire port database
		 * for the same Port and Node WWN.
		 */
		for (i = 0; i < MAX_FC_TARG; i++) {
			lp = &fcp->portdb[i];
			if (lp->state == FC_PORTDB_STATE_NIL) {
				continue;
			}
			if (lp->node_wwn != tmp.node_wwn) {
				continue;
			}
			if (lp->port_wwn != tmp.port_wwn) {
				continue;
			}

			/*
			 * Okay- we've found a non-nil entry that matches.
			 * Check to make sure it's probational or a zombie.
			 */
			if (lp->state != FC_PORTDB_STATE_PROBATIONAL &&
			    lp->state != FC_PORTDB_STATE_ZOMBIE) {
				isp_prt(isp, ISP_LOGERR,
				    "[%d] not probational/zombie (0x%x)",
				    i, lp->state);
				isp_dump_portdb(isp);
				ISP_MARK_PORTDB(isp, 1);
				return (-1);
			}

			/*
			 * Mark the device as something the f/w logs into
			 * automatically.
			 */
			lp->autologin = 1;

			/*
			 * Check to make see if really still the same
			 * device. If it is, we mark it pending valid.
			 */
			if (lp->portid == tmp.portid &&
			    lp->handle == tmp.handle &&
			    lp->roles == tmp.roles) {
				lp->new_portid = tmp.portid;
				lp->new_roles = tmp.roles;
				lp->state = FC_PORTDB_STATE_PENDING_VALID;
				isp_prt(isp, ISP_LOGSANCFG,
				    "Loop Port 0x%02x@@0x%x Pending Valid",
				    tmp.portid, tmp.handle);
				break;
			}
		
			/*
			 * We can wipe out the old handle value
			 * here because it's no longer valid.
			 */
			lp->handle = tmp.handle;

			/*
			 * Claim that this has changed and let somebody else
			 * decide what to do.
			 */
			isp_prt(isp, ISP_LOGSANCFG,
			    "Loop Port 0x%02x@@0x%x changed",
			    tmp.portid, tmp.handle);
			lp->state = FC_PORTDB_STATE_CHANGED;
			lp->new_portid = tmp.portid;
			lp->new_roles = tmp.roles;
			break;
		}

		/*
		 * Did we find and update an old entry?
		 */
		if (i < MAX_FC_TARG) {
			continue;
		}

		/*
		 * Ah. A new device entry. Find an empty slot
		 * for it and save info for later disposition.
		 */
		for (i = 0; i < MAX_FC_TARG; i++) {
			if (fcp->portdb[i].state == FC_PORTDB_STATE_NIL) {
				break;
			}
		}
		if (i == MAX_FC_TARG) {
			isp_prt(isp, ISP_LOGERR, "out of portdb entries");
			continue;
		}
		lp = &fcp->portdb[i];

		MEMZERO(lp, sizeof (fcportdb_t));
		lp->autologin = 1;
		lp->state = FC_PORTDB_STATE_NEW;
		lp->new_portid = tmp.portid;
		lp->new_roles = tmp.roles;
		lp->handle = tmp.handle;
		lp->port_wwn = tmp.port_wwn;
		lp->node_wwn = tmp.node_wwn;
		isp_prt(isp, ISP_LOGSANCFG,
		    "Loop Port 0x%02x@@0x%x is New Entry",
		    tmp.portid, tmp.handle);
	}
	fcp->isp_loopstate = LOOP_LSCAN_DONE;
	return (0);
}

/*
 * Scan the fabric for devices and add them to our port database.
 *
 * Use the GID_FT command to get all Port IDs for FC4 SCSI devices it knows.
 *
 * For 2100-23XX cards, we can use the SNS mailbox command to pass simple
 * name server commands to the switch management server via the QLogic f/w.
 *
 * For the 24XX card, we have to use CT-Pass through run via the Execute IOCB
 * mailbox command.
 *
 * The net result is to leave the list of Port IDs setting untranslated in
 * offset IGPOFF of the FC scratch area, whereupon we'll canonicalize it to
 * host order at OGPOFF.
 */

/*
 * Take less than half of our scratch area to store Port IDs 
 */
#define	GIDLEN	((ISP2100_SCRLEN >> 1) - 16 - SNS_GID_FT_REQ_SIZE)
#define	NGENT	((GIDLEN - 16) >> 2)

#define	IGPOFF	(2 * QENTRY_LEN)
#define	OGPOFF	(ISP2100_SCRLEN >> 1)
#define	ZTXOFF	(ISP2100_SCRLEN - (1 * QENTRY_LEN))
#define	CTXOFF	(ISP2100_SCRLEN - (2 * QENTRY_LEN))
#define	XTXOFF	(ISP2100_SCRLEN - (3 * QENTRY_LEN))

int
isp_gid_ft_sns(struct ispsoftc *isp)
{
	union {
		sns_gid_ft_req_t _x;
		u_int8_t _y[SNS_GID_FT_REQ_SIZE];
	} un;
	fcparam *fcp = FCPARAM(isp);
	sns_gid_ft_req_t *rq = &un._x;
	mbreg_t mbs;

#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0, "scanning fabric (GID_FT) via SNS");
#endif

	MEMZERO(rq, SNS_GID_FT_REQ_SIZE);
	rq->snscb_rblen = GIDLEN >> 1;
	rq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma + IGPOFF);
	rq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma + IGPOFF);
	rq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma + IGPOFF);
	rq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma + IGPOFF);
	rq->snscb_sblen = 6;
	rq->snscb_cmd = SNS_GID_FT;
	rq->snscb_mword_div_2 = NGENT;
	rq->snscb_fc4_type = FC4_SCSI;

	isp_put_gid_ft_request(isp, rq, fcp->isp_scratch);
	MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GID_FT_REQ_SIZE);

	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SEND_SNS;
	mbs.param[1] = SNS_GID_FT_REQ_SIZE >> 1;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
	mbs.logval = MBLOGALL;
	mbs.timeout = 10000000;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		if (mbs.param[0] == MBOX_INVALID_COMMAND) {
			return (1);
		} else {
			return (-1);
		}
	}
	return (0);
}

int
isp_scan_fabric(struct ispsoftc *isp)
{
	fcparam *fcp = FCPARAM(isp);
	u_int32_t portid;
	u_int16_t handle, oldhandle;
	int portidx, portlim, r;
	sns_gid_ft_rsp_t *rs0, *rs1;

	isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0, "FC Scan Fabric");
	if (fcp->isp_fwstate != FW_READY ||
	    fcp->isp_loopstate < LOOP_LSCAN_DONE) {
		return (-1);
	}
	if (fcp->isp_loopstate > LOOP_SCANNING_FABRIC) {
		return (0);
	}
	if (fcp->isp_topo != TOPO_FL_PORT && fcp->isp_topo != TOPO_F_PORT) {
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0,
		    "FC Scan Fabric Done (no fabric)");
		return (0);
	}

	FC_SCRATCH_ACQUIRE(isp);
	fcp->isp_loopstate = LOOP_SCANNING_FABRIC;

	r = isp_gid_ft_sns(isp);
	if (r > 0) {
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		FC_SCRATCH_RELEASE(isp);
		return (0);
	} else if (r < 0) {
		fcp->isp_loopstate = LOOP_PDB_RCVD;	/* try again */
		FC_SCRATCH_RELEASE(isp);
		return (0);
	}
	if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
		FC_SCRATCH_RELEASE(isp);
		return (-1);
	}

	MEMORYBARRIER(isp, SYNC_SFORCPU, IGPOFF, GIDLEN);
	rs0 = (sns_gid_ft_rsp_t *) ((u_int8_t *)fcp->isp_scratch+IGPOFF);
	rs1 = (sns_gid_ft_rsp_t *) ((u_int8_t *)fcp->isp_scratch+OGPOFF);
	isp_get_gid_ft_response(isp, rs0, rs1, NGENT);
	if (rs1->snscb_cthdr.ct_cmd_resp != LS_ACC) {
		int level;
		if (rs1->snscb_cthdr.ct_reason == 9 &&
		    rs1->snscb_cthdr.ct_explanation == 7) {
			level = ISP_LOGSANCFG|ISP_LOGDEBUG0;
		} else {
			level = ISP_LOGWARN;
		}
		isp_prt(isp, level, "Fabric Nameserver rejected GID_FT "
		    "(Reason=0x%x Expl=0x%x)", rs1->snscb_cthdr.ct_reason,
		    rs1->snscb_cthdr.ct_explanation);
		FC_SCRATCH_RELEASE(isp);
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		return (0);
	}


	/*
	 * If we get this far, we certainly still have the fabric controller.
	 */
	fcp->portdb[FL_ID].state = FC_PORTDB_STATE_PENDING_VALID;

	/*
	 * Prime the handle we will start using.
	 */
	oldhandle = NIL_HANDLE;

	/*
	 * Okay, we now have a list of Port IDs for all FC4 SCSI devices
	 * that the Fabric Name server knows about. Go through the list
	 * and remove duplicate port ids.
	 */

	portlim = 0;
	portidx = 0;
	for (portidx = 0; portidx < NGENT-1; portidx++) {
		if (rs1->snscb_ports[portidx].control & 0x80) {
			break;
		}
	}

	/*
	 * If we're not at the last entry, our list wasn't big enough.
	 */
	if ((rs1->snscb_ports[portidx].control & 0x80) == 0) {
		isp_prt(isp, ISP_LOGWARN,
		    "fabric too big for scratch area: increase ISP2100_SCRLEN");
	}
	portlim = portidx + 1;
	isp_prt(isp, ISP_LOGSANCFG,
	    "got %d ports back from name server", portlim);

	for (portidx = 0; portidx < portlim; portidx++) {
		int npidx;

		portid =
		    ((rs1->snscb_ports[portidx].portid[0]) << 16) |
		    ((rs1->snscb_ports[portidx].portid[1]) << 8) |
		    ((rs1->snscb_ports[portidx].portid[2]));

		for (npidx = portidx + 1; npidx < portlim; npidx++) {
			u_int32_t new_portid =
			    ((rs1->snscb_ports[npidx].portid[0]) << 16) |
			    ((rs1->snscb_ports[npidx].portid[1]) << 8) |
			    ((rs1->snscb_ports[npidx].portid[2]));
			if (new_portid == portid) {
				break;
			}
		}

		if (npidx < portlim) {
			rs1->snscb_ports[npidx].portid[0] = 0;
			rs1->snscb_ports[npidx].portid[1] = 0;
			rs1->snscb_ports[npidx].portid[2] = 0;
			isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0,
			    "removing duplicate PortID 0x%x entry from list",
			    portid);
		}
	}

	/*
	 * Okay, we now have a list of Port IDs for all FC4 SCSI devices
	 * that the Fabric Name server knows about.
	 *
	 * For each entry on this list go through our port database looking
	 * for probational entries- if we find one, then an old entry is
	 * is maybe still this one. We get some information to find out.
	 *
	 * Otherwise, it's a new fabric device, and we log into it
	 * (unconditionally). After searching the entire database
	 * again to make sure that we never ever ever ever have more
	 * than one entry that has the same PortID or the same
	 * WWNN/WWPN duple, we enter the device into our database.
	 */

	for (portidx = 0; portidx < portlim; portidx++) {
		fcportdb_t *lp;
		isp_pdb_t pdb;
		u_int64_t wwnn, wwpn;
		int dbidx, nr;

		portid =
		    ((rs1->snscb_ports[portidx].portid[0]) << 16) |
		    ((rs1->snscb_ports[portidx].portid[1]) << 8) |
		    ((rs1->snscb_ports[portidx].portid[2]));

		if (portid == 0) {
			isp_prt(isp, ISP_LOGSANCFG,
			    "skipping null PortID at idx %d", portidx);
			continue;
		}

		/*
		 * Skip ourselves...
		 */
		if (portid == fcp->isp_portid) {
			isp_prt(isp, ISP_LOGSANCFG,
			    "skip ourselves @@ PortID 0x%06x", portid);
			continue;
		}
		isp_prt(isp, ISP_LOGSANCFG,
		    "Checking Fabric Port 0x%06x", portid);

		/*
		 * We now search our Port Database for any
		 * probational entries with this PortID. We don't
		 * look for zombies here- only probational
		 * entries (we've already logged out of zombies).
		 */
		for (dbidx = 0; dbidx < MAX_FC_TARG; dbidx++) {
			lp = &fcp->portdb[dbidx];

			if (lp->state != FC_PORTDB_STATE_PROBATIONAL) {
				continue;
			}
			if (lp->portid == portid) {
				break;
			}
		}

		/*
		 * We found a probational entry with this Port ID.
		 */
		if (dbidx < MAX_FC_TARG) {
			int handle_changed = 0;

			lp = &fcp->portdb[dbidx];

			/*
			 * See if we're still logged into it.
			 *
			 * If we aren't, mark it as a dead device and
			 * leave the new portid in the database entry
			 * for somebody further along to decide what to
			 * do (policy choice).
			 *
			 * If we are, check to see if it's the same
			 * device still (it should be). If for some
			 * reason it isn't, mark it as a changed device
			 * and leave the new portid and role in the
			 * database entry for somebody further along to
			 * decide what to do (policy choice).
			 *
			 */

			r = isp_getpdb(isp, lp->handle, &pdb, 0);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				ISP_MARK_PORTDB(isp, 1);
				return (-1);
			}
			if (r != 0) {
				lp->new_portid = portid;
				lp->state = FC_PORTDB_STATE_DEAD;
				isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0,
				    "Fabric Port 0x%06x considered dead",
				    portid);
				continue;
			}


			/*
			 * Check to make sure that handle, portid, WWPN and
			 * WWNN agree. If they don't, then the association
			 * between this PortID and the stated handle has been
			 * broken by the firmware.
			 */
			MAKE_WWN_FROM_NODE_NAME(wwnn, pdb.nodename);
			MAKE_WWN_FROM_NODE_NAME(wwpn, pdb.portname);
			if (pdb.handle != lp->handle ||
			    pdb.portid != portid ||
			    wwpn != lp->port_wwn ||
			    wwnn != lp->node_wwn) {
				isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0,
				    fconf, dbidx, pdb.handle, pdb.portid,
				    (u_int32_t) (wwnn >> 32), (u_int32_t) wwnn,
				    (u_int32_t) (wwpn >> 32), (u_int32_t) wwpn,
				    lp->handle, portid,
				    (u_int32_t) (lp->node_wwn >> 32),
				    (u_int32_t) lp->node_wwn,
				    (u_int32_t) (lp->port_wwn >> 32),
				    (u_int32_t) lp->port_wwn);
				/*
				 * Try to re-login to this device using a
				 * new handle. If that fails, mark it dead.
				 * 
				 * isp_login_device will check for handle and
				 * portid consistency after re-login.
				 * 
				 */
				if (isp_login_device(isp, portid, &pdb,
				    &oldhandle)) {
					lp->new_portid = portid;
					lp->state = FC_PORTDB_STATE_DEAD;
					if (fcp->isp_loopstate !=
					    LOOP_SCANNING_FABRIC) {
						FC_SCRATCH_RELEASE(isp);
						ISP_MARK_PORTDB(isp, 1);
						return (-1);
					}
					continue;
				}
				MAKE_WWN_FROM_NODE_NAME(wwnn, pdb.nodename);
				MAKE_WWN_FROM_NODE_NAME(wwpn, pdb.portname);
				if (wwpn != lp->port_wwn ||
				    wwnn != lp->node_wwn) {
					isp_prt(isp, ISP_LOGWARN, "changed WWN"
					    " after relogin");
					lp->new_portid = portid;
					lp->state = FC_PORTDB_STATE_DEAD;
					continue;
				}

				lp->handle = pdb.handle;
				handle_changed++;
			}

			nr = (pdb.s3_role & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;

			/*
			 * Check to see whether the portid and roles have
			 * stayed the same. If they have stayed the same,
			 * we believe that this is the same device and it
			 * hasn't become disconnected and reconnected, so
			 * mark it as pending valid.
			 *
			 * If they aren't the same, mark the device as a
			 * changed device and save the new port id and role
			 * and let somebody else decide.
			 */

			lp->new_portid = portid;
			lp->new_roles = nr;
			if (pdb.portid != lp->portid || nr != lp->roles ||
			    handle_changed) {
				isp_prt(isp, ISP_LOGSANCFG,
				    "Fabric Port 0x%06x changed", portid);
				lp->state = FC_PORTDB_STATE_CHANGED;
			} else {
				isp_prt(isp, ISP_LOGSANCFG,
				    "Fabric Port 0x%06x Now Pending Valid",
				    portid);
				lp->state = FC_PORTDB_STATE_PENDING_VALID;
			}
			continue;
		}

		/*
		 * Ah- a new entry. Search the database again for all non-NIL
		 * entries to make sure we never ever make a new database entry
		 * with the same port id. While we're at it, mark where the
		 * last free entry was.
		 */
	
		dbidx = MAX_FC_TARG;
		for (lp = fcp->portdb; lp < &fcp->portdb[MAX_FC_TARG]; lp++) {
			if (lp >= &fcp->portdb[FL_ID] &&
			    lp <= &fcp->portdb[SNS_ID]) {
				continue;
			}
			if (lp->state == FC_PORTDB_STATE_NIL) {
				if (dbidx == MAX_FC_TARG) {
					dbidx = lp - fcp->portdb;
				}
				continue;
			}
			if (lp->state == FC_PORTDB_STATE_ZOMBIE) {
				continue;
			}
			if (lp->portid == portid) {
				break;
			}
		}

		if (lp < &fcp->portdb[MAX_FC_TARG]) {
			isp_prt(isp, ISP_LOGWARN,
			    "PortID 0x%06x already at %d handle %d state %d",
			    portid, dbidx, lp->handle, lp->state);
			continue;
		}

		/*
		 * We should have the index of the first free entry seen.
		 */
		if (dbidx == MAX_FC_TARG) {
			isp_prt(isp, ISP_LOGERR,
			    "port database too small to login PortID 0x%06x"
			    "- increase MAX_FC_TARG", portid);
			continue;
		}

		/*
		 * Otherwise, point to our new home.
		 */
		lp = &fcp->portdb[dbidx];

		/*
		 * Try to see if we are logged into this device,
		 * and maybe log into it.
		 *
		 * isp_login_device will check for handle and
		 * portid consistency after login.
		 */
		if (isp_login_device(isp, portid, &pdb, &oldhandle)) {
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				ISP_MARK_PORTDB(isp, 1);
				return (-1);
			}
			continue;
		}

		handle = pdb.handle;
		MAKE_WWN_FROM_NODE_NAME(wwnn, pdb.nodename);
		MAKE_WWN_FROM_NODE_NAME(wwpn, pdb.portname);
		nr = (pdb.s3_role & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;

		/*
		 * And go through the database *one* more time to make sure
		 * that we do not make more than one entry that has the same
		 * WWNN/WWPN duple
		 */
		for (dbidx = 0; dbidx < MAX_FC_TARG; dbidx++) {
			if (dbidx >= FL_ID && dbidx <= SNS_ID) {
				continue;
			}
			if (fcp->portdb[dbidx].state == FC_PORTDB_STATE_NIL) {
				continue;
			}
			if (fcp->portdb[dbidx].node_wwn == wwnn &&
			    fcp->portdb[dbidx].port_wwn == wwpn) {
				break;
			}
		}

		if (dbidx == MAX_FC_TARG) {
			MEMZERO(lp, sizeof (fcportdb_t));
			lp->handle = handle;
			lp->node_wwn = wwnn;
			lp->port_wwn = wwpn;
			lp->new_portid = portid;
			lp->new_roles = nr;
			lp->state = FC_PORTDB_STATE_NEW;
			isp_prt(isp, ISP_LOGSANCFG,
			    "Fabric Port 0x%06x is New Entry", portid);
			continue;
		}

    		if (fcp->portdb[dbidx].state != FC_PORTDB_STATE_ZOMBIE) {
			isp_prt(isp, ISP_LOGWARN,
			    "PortID 0x%x 0x%08x%08x/0x%08x%08x %ld already at "
			    "idx %d, state 0x%x", portid,
			    (u_int32_t) (wwnn >> 32), (u_int32_t) wwnn,
			    (u_int32_t) (wwpn >> 32), (u_int32_t) wwpn,
			    (long) (lp - fcp->portdb), dbidx,
			    fcp->portdb[dbidx].state);
			continue;
		}

		/*
		 * We found a zombie entry that matches us.
		 * Revive it. We know that WWN and WWPN
		 * are the same. For fabric devices, we
		 * don't care that handle is different
		 * as we assign that. If role or portid
		 * are different, it maybe a changed device.
		 */
		lp = &fcp->portdb[dbidx];
		lp->handle = handle;
		lp->new_portid = portid;
		lp->new_roles = nr;
		if (lp->portid != portid || lp->roles != nr) {
			isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0,
			    "Zombie Fabric Port 0x%06x Now Changed", portid);
			lp->state = FC_PORTDB_STATE_CHANGED;
		} else {
			isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0,
			    "Zombie Fabric Port 0x%06x Now Pending Valid",
			    portid);
			lp->state = FC_PORTDB_STATE_PENDING_VALID;
		}
	}

	FC_SCRATCH_RELEASE(isp);
	if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
		ISP_MARK_PORTDB(isp, 1);
		return (-1);
	}
	fcp->isp_loopstate = LOOP_FSCAN_DONE;
	isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0, "FC Scan Fabric Done");
	return (0);
}

/*
 * Find an unused handle and try and use to login to a port.
 */
int
isp_login_device(struct ispsoftc *isp, u_int32_t portid, isp_pdb_t *p, u_int16_t *ohp)
{
	int lim, i, r;
	u_int16_t handle;

	if (FCPARAM(isp)->isp_2klogin) {
		lim = NPH_MAX_2K;
	} else {
		lim = NPH_MAX;
	}

	handle = isp_nxt_handle(isp, *ohp);
	for (i = 0; i < lim; i++) {
		/*
		 * See if we're still logged into something with
		 * this handle and that something agrees with this
		 * port id.
		 */
		r = isp_getpdb(isp, handle, p, 0);
		if (r == 0 && p->portid != portid) {
			(void) isp_plogx(isp, handle, portid,
			    PLOGX_FLG_CMD_LOGO | PLOGX_FLG_IMPLICIT, 1);
		} else if (r == 0) {
			break;
		}
		if (FCPARAM(isp)->isp_loopstate != LOOP_SCANNING_FABRIC) {
			return (-1);
		}
		/*
		 * Now try and log into the device
		 */
		r = isp_plogx(isp, handle, portid, PLOGX_FLG_CMD_PLOGI, 1);
		if (FCPARAM(isp)->isp_loopstate != LOOP_SCANNING_FABRIC) {
			return (-1);
		}
		if (r == 0) {
			*ohp = handle;
			break;
		} else if ((r & 0xffff) == MBOX_PORT_ID_USED) {
			handle = r >> 16;
			break;
		} else if (r != MBOX_LOOP_ID_USED) {
			i = lim;
			break;
		} else {
			*ohp = handle;
			handle = isp_nxt_handle(isp, *ohp);
		}
	}

	if (i == lim) {
		isp_prt(isp, ISP_LOGWARN, "PLOGI 0x%06x failed", portid);
		return (-1);
	}

	/*
	 * If we successfully logged into it, get the PDB for it
	 * so we can crosscheck that it is still what we think it
	 * is and that we also have the role it plays
	 */
	r = isp_getpdb(isp, handle, p, 0);
	if (FCPARAM(isp)->isp_loopstate != LOOP_SCANNING_FABRIC) {
		return (-1);
	}
	if (r != 0) {
		isp_prt(isp, ISP_LOGERR, "new device 0x%06x@@0x%x disappeared",
		    portid, handle);
		return (-1);
	}

	if (p->handle != handle || p->portid != portid) {
		isp_prt(isp, ISP_LOGERR,
		    "new device 0x%06x@@0x%x changed (0x%06x@@0x%0x)",
		    portid, handle, p->portid, p->handle);
		return (-1);
	}
	return (0);
}

int
isp_register_fc4_type(struct ispsoftc *isp)
{
	fcparam *fcp = isp->isp_param;
	u_int8_t local[SNS_RFT_ID_REQ_SIZE];
	sns_screq_t *reqp = (sns_screq_t *) local;
	mbreg_t mbs;

	MEMZERO((void *) reqp, SNS_RFT_ID_REQ_SIZE);
	reqp->snscb_rblen = SNS_RFT_ID_RESP_SIZE >> 1;
	reqp->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma + 0x100);
	reqp->snscb_sblen = 22;
	reqp->snscb_data[0] = SNS_RFT_ID;
	reqp->snscb_data[4] = fcp->isp_portid & 0xffff;
	reqp->snscb_data[5] = (fcp->isp_portid >> 16) & 0xff;
	reqp->snscb_data[6] = (1 << FC4_SCSI);
	FC_SCRATCH_ACQUIRE(isp);
	isp_put_sns_request(isp, reqp, (sns_screq_t *) fcp->isp_scratch);
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SEND_SNS;
	mbs.param[1] = SNS_RFT_ID_REQ_SIZE >> 1;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
	mbs.logval = MBLOGALL;
	mbs.timeout = 10000000;
	MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_RFT_ID_REQ_SIZE);
	isp_mboxcmd(isp, &mbs);
	FC_SCRATCH_RELEASE(isp);
	if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
		return (0);
	} else {
		return (-1);
	}
}

u_int16_t
isp_nxt_handle(struct ispsoftc *isp, u_int16_t handle)
{
	int i;
	if (handle == NIL_HANDLE) {
		if (FCPARAM(isp)->isp_topo == TOPO_F_PORT) {
			handle = 0;
		} else {
			handle = SNS_ID+1;
		}
	} else {
		handle += 1;
		if (handle >= FL_ID && handle <= SNS_ID) {
			handle = SNS_ID+1;
		}
		if (handle >= NPH_RESERVED && handle <= NPH_FL_ID) {
			handle = NPH_FL_ID+1;
		}
		if (FCPARAM(isp)->isp_2klogin) {
			if (handle == NPH_MAX_2K) {
				handle = 0;
			}
		} else {
			if (handle == NPH_MAX) {
				handle = 0;
			}
		}
	}
	if (handle == FCPARAM(isp)->isp_loopid) {
		return (isp_nxt_handle(isp, handle));
	}
	for (i = 0; i < MAX_FC_TARG; i++) {
		if (FCPARAM(isp)->portdb[i].state == FC_PORTDB_STATE_NIL) {
			continue;
		}
		if (FCPARAM(isp)->portdb[i].handle == handle) {
			return (isp_nxt_handle(isp, handle));
		}
	}
	return (handle);
}

/*
 * Start a command. Locking is assumed done in the caller.
 */

int
isp_start(XS_T *xs)
{
	struct ispsoftc *isp;
	u_int32_t nxti, optr, handle;
	u_int8_t local[QENTRY_LEN];
	ispreq_t *reqp, *qep;
	void *cdbp;
	u_int16_t *tptr;
	int target, i, hdlidx = 0;

	XS_INITERR(xs);
	isp = XS_ISP(xs);

	/*
	 * Check to make sure we're supporting initiator role.
	 */
	if ((isp->isp_role & ISP_ROLE_INITIATOR) == 0) {
		XS_SETERR(xs, HBA_SELTIMEOUT);
		return (CMD_COMPLETE);
	}

	/*
	 * Now make sure we're running.
	 */

	if (isp->isp_state != ISP_RUNSTATE) {
		isp_prt(isp, ISP_LOGERR, "Adapter not at RUNSTATE");
		XS_SETERR(xs, HBA_BOTCH);
		return (CMD_COMPLETE);
	}

	/*
	 * Check command CDB length, etc.. We really are limited to 16 bytes
	 * for Fibre Channel, but can do up to 44 bytes in parallel SCSI,
	 * but probably only if we're running fairly new firmware (we'll
	 * let the old f/w choke on an extended command queue entry).
	 */

	if (XS_CDBLEN(xs) > (IS_FC(isp)? 16 : 44) || XS_CDBLEN(xs) == 0) {
		isp_prt(isp, ISP_LOGERR,
		    "unsupported cdb length (%d, CDB[0]=0x%x)",
		    XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);
		XS_SETERR(xs, HBA_BOTCH);
		return (CMD_COMPLETE);
	}

	/*
	 * The firmware on the 1020/1020A doesn't seem to implement
	 * extended commands.  Bail out early since we don't seem to
	 * be able to recover from issuing a command that isn't
	 * implemented.
	 */

	if (XS_CDBLEN(xs) > 12 && isp->isp_type < ISP_HA_SCSI_1040) {
		XS_SETERR(xs, HBA_BOTCH);
		return (CMD_COMPLETE);
	}

	/*
	 * Translate the target to device handle as appropriate, checking
	 * for correct device state as well.
	 */
	target = XS_TGT(xs);
	if (IS_FC(isp)) {
		fcparam *fcp = isp->isp_param;

		/*
		 * Try again later.
		 */
		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate != LOOP_READY) {
			return (CMD_RQLATER);
		}

		if (XS_TGT(xs) >= MAX_FC_TARG) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
			return (CMD_COMPLETE);
		}

		hdlidx = fcp->isp_ini_map[XS_TGT(xs)] - 1;
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG1, "XS_TGT(xs)=%d- hdlidx value %d",
		    XS_TGT(xs), hdlidx);
#endif
		if (hdlidx < 0 || hdlidx >= MAX_FC_TARG) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
			return (CMD_COMPLETE);
		}
		if (fcp->portdb[hdlidx].state == FC_PORTDB_STATE_ZOMBIE) {
			return (CMD_RQLATER);
		}
		if (fcp->portdb[hdlidx].state != FC_PORTDB_STATE_VALID) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
			return (CMD_COMPLETE);
		}
		target = fcp->portdb[hdlidx].handle;
		xs->sc_link->node_wwn = fcp->portdb[hdlidx].node_wwn;
		xs->sc_link->port_wwn = fcp->portdb[hdlidx].port_wwn;
	}

	/*
	 * Next check to see if any HBA or Device parameters need to be updated.
	 */
	if (isp->isp_update != 0) {
		isp_update(isp);
	}

 start_again:

	if (isp_getrqentry(isp, &nxti, &optr, (void *)&qep)) {
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "Request Queue Overflow");
#endif
		XS_SETERR(xs, HBA_BOTCH);
		return (CMD_EAGAIN);
	}

	/*
	 * Now see if we need to synchronize the ISP with respect to anything.
	 * We do dual duty here (cough) for synchronizing for busses other
	 * than which we got here to send a command to.
	 */
	reqp = (ispreq_t *) local;
	if (isp->isp_sendmarker) {
		for (i = 0; i < (IS_DUALBUS(isp)? 2: 1); i++) {
			isp_marker_t *m = (isp_marker_t *) qep;
			if ((isp->isp_sendmarker & (1 << i)) == 0) {
				continue;
			}
			MEMZERO(m, QENTRY_LEN);
			m->mrk_header.rqs_entry_count = 1;
			m->mrk_header.rqs_entry_type = RQSTYPE_MARKER;
			m->mrk_target = (i << 7);	/* bus # */
			m->mrk_modifier = SYNC_ALL;
			isp_put_marker(isp, m, (isp_marker_t *) qep);
			ISP_ADD_REQUEST(isp, nxti);
			isp->isp_sendmarker &= ~(1 << i);
			goto start_again;
		}
	}

	MEMZERO((void *)reqp, QENTRY_LEN);
	reqp->req_header.rqs_entry_count = 1;
	if (IS_FC(isp)) {
		reqp->req_header.rqs_entry_type = RQSTYPE_T2RQS;
	} else {
		if (XS_CDBLEN(xs) > 12)
			reqp->req_header.rqs_entry_type = RQSTYPE_CMDONLY;
		else
			reqp->req_header.rqs_entry_type = RQSTYPE_REQUEST;
	}
	/* reqp->req_header.rqs_flags = 0; */
	/* reqp->req_header.rqs_seqno = 0; */
	if (IS_FC(isp)) {
		/*
		 * See comment in isp_intr
		 */
		/* XS_RESID(xs) = 0; */

		/*
		 * Fibre Channel always requires some kind of tag.
		 * The QLogic drivers seem be happy not to use a tag,
		 * but this breaks for some devices (IBM drives).
		 */
		if (XS_TAG_P(xs)) {
			((ispreqt2_t *)reqp)->req_flags = XS_TAG_TYPE(xs);
		} else {
			/*
			 * If we don't know what tag to use, use HEAD OF QUEUE
			 * for Request Sense or Simple.
			 */
			if (XS_CDBP(xs)[0] == 0x3)	/* REQUEST SENSE */
				((ispreqt2_t *)reqp)->req_flags = REQFLAG_HTAG;
			else
				((ispreqt2_t *)reqp)->req_flags = REQFLAG_STAG;
		}
	} else {
		sdparam *sdp = (sdparam *)isp->isp_param;
		sdp += XS_CHANNEL(xs);
		if ((sdp->isp_devparam[target].actv_flags & DPARM_TQING) &&
		    XS_TAG_P(xs)) {
			reqp->req_flags = XS_TAG_TYPE(xs);
		}
	}
	cdbp = reqp->req_cdb;
	tptr = &reqp->req_time;

	if (IS_SCSI(isp)) {
		reqp->req_target = target | (XS_CHANNEL(xs) << 7);
		reqp->req_lun_trn = XS_LUN(xs);
		reqp->req_cdblen = XS_CDBLEN(xs);
	} else if (FCPARAM(isp)->isp_2klogin) {
		((ispreqt2e_t *)reqp)->req_target = target;
		((ispreqt2e_t *)reqp)->req_scclun = XS_LUN(xs);
	} else if (FCPARAM(isp)->isp_sccfw) {
		((ispreqt2_t *)reqp)->req_target = target;
		((ispreqt2_t *)reqp)->req_scclun = XS_LUN(xs);
	} else {
		((ispreqt2_t *)reqp)->req_target = target;
		((ispreqt2_t *)reqp)->req_lun_trn = XS_LUN(xs);
	}
	MEMCPY(cdbp, XS_CDBP(xs), XS_CDBLEN(xs));

	*tptr = XS_TIME(xs) / 1000;
	if (*tptr == 0 && XS_TIME(xs)) {
		*tptr = 1;
	}

	if (isp_save_xs(isp, xs, &handle)) {
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "out of xflist pointers");
#endif
		XS_SETERR(xs, HBA_BOTCH);
		return (CMD_EAGAIN);
	}
	/* Whew. Thankfully the same for type 7 requests */
	reqp->req_handle = handle;

	/*
	 * Set up DMA and/or do any bus swizzling of the request entry
	 * so that the QLogic F/W understands what is being asked of it.
	 */
	i = ISP_DMASETUP(isp, xs, reqp, &nxti, optr);
	if (i != CMD_QUEUED) {
		isp_destroy_handle(isp, handle);
		/*
		 * dmasetup sets actual error in packet, and
		 * return what we were given to return.
		 */
		return (i);
	}
	XS_SETERR(xs, HBA_NOERROR);
#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0,
	    "START cmd for %d.%d.%d cmd 0x%x datalen %ld",
	    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs), XS_CDBP(xs)[0],
	    (long) XS_XFRLEN(xs));
#endif
	ISP_ADD_REQUEST(isp, nxti);
	isp->isp_nactive++;
	return (CMD_QUEUED);
}

/*
 * isp control
 * Locks (ints blocked) assumed held.
 */

int
isp_control(struct ispsoftc *isp, ispctl_t ctl, void *arg)
{
	XS_T *xs;
	mbreg_t mbs;
	int bus, tgt;
	u_int32_t handle;

	MEMZERO(&mbs, sizeof (mbs));

	switch (ctl) {
	default:
		isp_prt(isp, ISP_LOGERR, "Unknown Control Opcode 0x%x", ctl);
		break;

	case ISPCTL_RESET_BUS:
		/*
		 * Issue a bus reset.
		 */
		if (IS_FC(isp)) {
			mbs.param[1] = 10;
			bus = 0;
		} else {
			mbs.param[1] = SDPARAM(isp)->isp_bus_reset_delay;
			if (mbs.param[1] < 2) {
				mbs.param[1] = 2;
			}
			bus = *((int *) arg);
			if (IS_DUALBUS(isp)) {
				mbs.param[2] = bus;
			}
		}
		mbs.param[0] = MBOX_BUS_RESET;
		isp->isp_sendmarker |= (1 << bus);
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			break;
		}
		isp_prt(isp, ISP_LOGINFO,
		    "driver initiated bus reset of bus %d", bus);
		return (0);

	case ISPCTL_RESET_DEV:
		tgt = (*((int *) arg)) & 0xffff;
		if (IS_FC(isp)) {
			if (FCPARAM(isp)->isp_2klogin) {
				mbs.param[1] = tgt;
				mbs.ibits = (1 << 10);
			} else {
				mbs.param[1] = (tgt << 8);
			}
			bus = 0;
		} else {
			bus = (*((int *) arg)) >> 16;
			mbs.param[1] = (bus << 15) | (tgt << 8);
		}
		mbs.param[0] = MBOX_ABORT_TARGET;
		mbs.param[2] = 3;	/* 'delay', in seconds */
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			break;
		}
		isp_prt(isp, ISP_LOGINFO,
		    "Target %d on Bus %d Reset Succeeded", tgt, bus);
		isp->isp_sendmarker |= (1 << bus);
		return (0);

	case ISPCTL_ABORT_CMD:
		xs = (XS_T *) arg;
		tgt = XS_TGT(xs);

		handle = isp_find_handle(isp, xs);
		if (handle == 0) {
			isp_prt(isp, ISP_LOGWARN,
			    "cannot find handle for command to abort");
			break;
		}
		if (IS_FC(isp)) {
			if (FCPARAM(isp)->isp_sccfw) {
				if (FCPARAM(isp)->isp_2klogin) {
					mbs.param[1] = tgt;
				} else {
					mbs.param[1] = tgt << 8;
				}
				mbs.param[6] = XS_LUN(xs);
			} else {
				mbs.param[1] = tgt << 8 | XS_LUN(xs);
			}
		} else {
			bus = XS_CHANNEL(xs);
			mbs.param[1] = (bus << 15) | (tgt << 8) | XS_LUN(xs);
		}
		mbs.param[0] = MBOX_ABORT;
		mbs.param[2] = handle;
		mbs.logval = MBLOGALL & ~MBOX_COMMAND_ERROR;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			break;
		}
		return (0);

	case ISPCTL_UPDATE_PARAMS:

		isp_update(isp);
		return (0);

	case ISPCTL_FCLINK_TEST:

		if (IS_FC(isp)) {
			int usdelay = *((int *) arg);
			if (usdelay == 0) {
				usdelay =  250000;
			}
			return (isp_fclink_test(isp, usdelay));
		}
		break;

	case ISPCTL_SCAN_FABRIC:

		if (IS_FC(isp)) {
			return (isp_scan_fabric(isp));
		}
		break;

	case ISPCTL_SCAN_LOOP:

		if (IS_FC(isp)) {
			return (isp_scan_loop(isp));
		}
		break;

	case ISPCTL_PDB_SYNC:

		if (IS_FC(isp)) {
			return (isp_pdb_sync(isp));
		}
		break;

	case ISPCTL_SEND_LIP:

		if (IS_FC(isp)) {
			mbs.param[0] = MBOX_INIT_LIP;
			if (FCPARAM(isp)->isp_2klogin) {
				mbs.ibits = (1 << 10);
			}
			mbs.logval = MBLOGALL;
			isp_mboxcmd(isp, &mbs);
			if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
				return (0);
			}
		}
		break;

	case ISPCTL_GET_PDB:
		if (IS_FC(isp) && arg) {
			int id = *((int *)arg);
			isp_pdb_t *pdb = arg;
			return (isp_getpdb(isp, id, pdb, 1));
		}
		break;

	case ISPCTL_GET_PORTNAME:
	{
		u_int64_t *wwnp = arg;
		int loopid = *wwnp;
		*wwnp = isp_get_portname(isp, loopid, 0);
		if (*wwnp == (u_int64_t) -1) {
			break;
		} else {
			return (0);
		}
	}
	case ISPCTL_RUN_MBOXCMD:

		isp_mboxcmd(isp, arg);
		return(0);

	case ISPCTL_PLOGX:
	{
		isp_plcmd_t *p = arg;
		int r;

		if ((p->flags & PLOGX_FLG_CMD_MASK) != PLOGX_FLG_CMD_PLOGI ||
		    (p->handle != NIL_HANDLE)) {
			return (isp_plogx(isp, p->handle, p->portid,
			    p->flags, 0));
		}
		do {
			p->handle = isp_nxt_handle(isp, p->handle);
			r = isp_plogx(isp, p->handle, p->portid, p->flags, 0);
			if ((r & 0xffff) == MBOX_PORT_ID_USED) {
				p->handle = r >> 16;
				r = 0;
				break;
			}
		} while ((r & 0xffff) == MBOX_LOOP_ID_USED);
		return (r);
	}
#ifdef	ISP_TARGET_MODE
	case ISPCTL_TOGGLE_TMODE:
	{

		/*
		 * We don't check/set against role here- that's the
		 * responsibility for the outer layer to coordinate.
		 */
		if (IS_SCSI(isp)) {
			int param = *(int *)arg;
			mbs.param[0] = MBOX_ENABLE_TARGET_MODE;
			mbs.param[1] = param & 0xffff;
			mbs.param[2] = param >> 16;
			mbs.logval = MBLOGALL;
			isp_mboxcmd(isp, &mbs);
			if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
				break;
			}
		}
		return (0);
	}
#endif
	}
	return (-1);
}

/*
 * Interrupt Service Routine(s).
 *
 * External (OS) framework has done the appropriate locking,
 * and the locking will be held throughout this function.
 */

/*
 * Limit our stack depth by sticking with the max likely number
 * of completions on a request queue at any one time.
 */
#ifndef	MAX_REQUESTQ_COMPLETIONS
#define	MAX_REQUESTQ_COMPLETIONS	32
#endif

void
isp_intr(struct ispsoftc *isp, u_int32_t isr, u_int16_t sema, u_int16_t mbox)
{
	XS_T *complist[MAX_REQUESTQ_COMPLETIONS], *xs;
	u_int32_t iptr, optr, junk;
	int i, nlooked = 0, ndone = 0;

again:
	optr = isp->isp_residx;
	/*
	 * Is this a mailbox related interrupt?
	 * The mailbox semaphore will be nonzero if so.
	 */
	if (sema) {
		if (mbox & 0x4000) {
			isp->isp_intmboxc++;
			if (isp->isp_mboxbsy) {
				int obits = isp->isp_obits;
				isp->isp_mboxtmp[0] = mbox;
				for (i = 1; i < MAX_MAILBOX(isp); i++) {
					if ((obits & (1 << i)) == 0) {
						continue;
					}
					isp->isp_mboxtmp[i] =
					    ISP_READ(isp, MBOX_OFF(i));
				}
				if (isp->isp_mbxwrk0) {
					if (isp_mbox_continue(isp) == 0) {
						return;
					}
				}
				MBOX_NOTIFY_COMPLETE(isp);
			} else {
				isp_prt(isp, ISP_LOGWARN,
				    "mailbox cmd (0x%x) with no waiters", mbox);
			}
		} else if (isp_parse_async(isp, mbox) < 0) {
			return;
		}
		if ((IS_FC(isp) && mbox != ASYNC_RIO_RESP) ||
		    isp->isp_state != ISP_RUNSTATE) {
			goto out;
		}
	}

	/*
	 * We can't be getting this now.
	 */
	if (isp->isp_state != ISP_RUNSTATE) {
		isp_prt(isp, ISP_LOGINFO,
		    "interrupt (ISR=%x SEMA=%x) when not ready", isr, sema);
		/*
		 * Thank you very much!  *Burrrp*!
		 */
		ISP_WRITE(isp, isp->isp_respoutrp,
		    ISP_READ(isp, isp->isp_respinrp));
		if (IS_24XX(isp)) {
			ISP_DISABLE_INTS(isp);
		}
		goto out;
	}

#ifdef	ISP_TARGET_MODE
	/*
	 * Check for ATIO Queue entries.
	 */
	if (isp->isp_rspbsy == 0 && (isp->isp_role & ISP_ROLE_TARGET) &&
	    IS_24XX(isp)) {
		iptr = ISP_READ(isp, isp->isp_atioinrp);
		optr = ISP_READ(isp, isp->isp_atiooutrp);

		isp->isp_rspbsy = 1;
		while (optr != iptr) {
			u_int8_t qe[QENTRY_LEN];
			isphdr_t *hp;
			u_int32_t oop;
			void *addr;

			oop = optr;
			MEMORYBARRIER(isp, SYNC_ATIOQ, oop, QENTRY_LEN);
			addr = ISP_QUEUE_ENTRY(isp->isp_atioq, oop);
			isp_get_hdr(isp, addr, (isphdr_t *)qe);
			hp = (isphdr_t *)qe;
			switch (hp->rqs_entry_type) {
			case RQSTYPE_NOTIFY:
			case RQSTYPE_ATIO:
				(void) isp_target_notify(isp, addr, &oop);
				break;
			default:
				isp_print_qentry(isp, "?ATIOQ entry?",
				    oop, addr);
				break;
			}
			optr = ISP_NXT_QENTRY(oop, RESULT_QUEUE_LEN(isp));
			ISP_WRITE(isp, isp->isp_atiooutrp, optr);
		}
		isp->isp_rspbsy = 0;
		optr = isp->isp_residx;
	}
#endif

	/*
	 * Get the current Response Queue Out Pointer.
	 *
	 * If we're a 2300 or 2400, we can ask what hardware what it thinks.
	 */
	if (IS_23XX(isp)) {
		optr = ISP_READ(isp, isp->isp_respoutrp);
		/*
		 * Debug: to be taken out eventually
		 */
		if (isp->isp_residx != optr) {
			isp_prt(isp, ISP_LOGINFO,
			    "isp_intr: hard optr=%x, soft optr %x",
			    optr, isp->isp_residx);
			isp->isp_residx = optr;
		}
	} else {
		optr = isp->isp_residx;
	}

	/*
	 * You *must* read the Response Queue In Pointer
	 * prior to clearing the RISC interrupt.
	 *
	 * Debounce the 2300 if revision less than 2.
	 */
	if (IS_2100(isp) || (IS_2300(isp) && isp->isp_revision < 2)) {
		i = 0;
		do {
			iptr = ISP_READ(isp, isp->isp_respinrp);
			junk = ISP_READ(isp, isp->isp_respinrp);
		} while (junk != iptr && ++i < 1000);

		if (iptr != junk) {
			isp_prt(isp, ISP_LOGWARN,
			    "Response Queue Out Pointer Unstable (%x, %x)",
			    iptr, junk);
			goto out;
		}
	} else {
		iptr = ISP_READ(isp, isp->isp_respinrp);
	}
	isp->isp_resodx = iptr;


	if (optr == iptr && sema == 0) {
		/*
		 * There are a lot of these- reasons unknown- mostly on
		 * faster Alpha machines.
		 *
		 * I tried delaying after writing HCCR_CMD_CLEAR_RISC_INT to
		 * make sure the old interrupt went away (to avoid 'ringing'
		 * effects), but that didn't stop this from occurring.
		 */
		if (IS_23XX(isp)) {
			USEC_DELAY(100);
			iptr = ISP_READ(isp, isp->isp_respinrp);
			junk = ISP_READ(isp, BIU_R2HSTSLO);
		} else {
			junk = ISP_READ(isp, BIU_ISR);
		}
		if (optr == iptr) {
			if (IS_23XX(isp)) {
				;
			} else {
				sema = ISP_READ(isp, BIU_SEMA);
				mbox = ISP_READ(isp, OUTMAILBOX0);
				if ((sema & 0x3) && (mbox & 0x8000)) {
					goto again;
				}
			}
			isp->isp_intbogus++;
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG1,
			    "bogus intr- isr %x (%x) iptr %x optr %x",
			    isr, junk, iptr, optr);
#endif
		}
	}
	isp->isp_resodx = iptr;


	if (isp->isp_rspbsy) {
		goto out;
	}
	isp->isp_rspbsy = 1;
	while (optr != iptr) {
		u_int8_t qe[QENTRY_LEN];
		ispstatusreq_t *sp = (ispstatusreq_t *) qe;
		isphdr_t *hp;
		int buddaboom, etype, scsi_status, completion_status;
		int req_status_flags, req_state_flags;
		u_int8_t *snsp, *resp;
		u_int32_t rlen, slen;
		long resid;
		u_int16_t oop;

		hp = (isphdr_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);
		oop = optr;
		optr = ISP_NXT_QENTRY(optr, RESULT_QUEUE_LEN(isp));
		nlooked++;
 read_again:
		buddaboom = req_status_flags = req_state_flags = 0;
		resid = 0L;

		/*
		 * Synchronize our view of this response queue entry.
		 */
		MEMORYBARRIER(isp, SYNC_RESULT, oop, QENTRY_LEN);
		isp_get_hdr(isp, hp, &sp->req_header);
		etype = sp->req_header.rqs_entry_type;

		if (etype == RQSTYPE_RESPONSE) {
			isp_get_response(isp, (ispstatusreq_t *) hp, sp);
#ifndef SMALL_KERNEL
			if (isp->isp_dblev & ISP_LOGDEBUG1) {
				isp_print_bytes(isp,
				    "Response Queue Entry", QENTRY_LEN, sp);
			}
#endif
			scsi_status = sp->req_scsi_status;
			completion_status = sp->req_completion_status;
			req_status_flags = sp->req_status_flags;
			req_state_flags = sp->req_state_flags;
			resid = sp->req_resid;
		} else if (etype == RQSTYPE_RIO2) {
			isp_rio2_t *rio = (isp_rio2_t *)qe;
			isp_get_rio2(isp, (isp_rio2_t *) hp, rio);
#ifndef SMALL_KERNEL
			if (isp->isp_dblev & ISP_LOGDEBUG1) {
				isp_print_bytes(isp,
				    "Response Queue Entry", QENTRY_LEN, rio);
			}
#endif
			for (i = 0; i < rio->req_header.rqs_seqno; i++) {
				isp_fastpost_complete(isp, rio->req_handles[i]);
			}
			if (isp->isp_fpcchiwater < rio->req_header.rqs_seqno) {
				isp->isp_fpcchiwater =
				    rio->req_header.rqs_seqno;
			}
			MEMZERO(hp, QENTRY_LEN);	/* PERF */
			continue;
		} else {
			/*
			 * Somebody reachable via isp_handle_other_response
			 * may have updated the response queue pointers for
			 * us, so we reload our goal index.
			 */
			int r;
			r = isp_handle_other_response(isp, etype, hp, &optr);
			if (r < 0) {
				goto read_again;
			}
			if (r > 0) {
				iptr = isp->isp_resodx;
				MEMZERO(hp, QENTRY_LEN);	/* PERF */
				continue;
			}

			/*
			 * After this point, we'll just look at the header as
			 * we don't know how to deal with the rest of the
			 * response.
			 */

			/*
			 * It really has to be a bounced request just copied
			 * from the request queue to the response queue. If
			 * not, something bad has happened.
			 */
			if (etype != RQSTYPE_REQUEST) {
				isp_prt(isp, ISP_LOGERR, notresp,
				    etype, oop, optr, nlooked);
				isp_print_bytes(isp,
				    "Request Queue Entry", QENTRY_LEN, sp);
				MEMZERO(hp, QENTRY_LEN);	/* PERF */
				continue;
			}
			buddaboom = 1;
			scsi_status = sp->req_scsi_status;
			completion_status = sp->req_completion_status;
			req_status_flags = sp->req_status_flags;
			req_state_flags = sp->req_state_flags;
			resid = sp->req_resid;
		}

		if (sp->req_header.rqs_flags & RQSFLAG_MASK) {
			if (sp->req_header.rqs_flags & RQSFLAG_CONTINUATION) {
				isp_prt(isp, ISP_LOGWARN,
				    "continuation segment");
				ISP_WRITE(isp, isp->isp_respoutrp, optr);
				continue;
			}
			if (sp->req_header.rqs_flags & RQSFLAG_FULL) {
#ifndef SMALL_KERNEL
				isp_prt(isp, ISP_LOGDEBUG1,
				    "internal queues full");
#endif
				/*
				 * We'll synthesize a QUEUE FULL message below.
				 */
			}
			if (sp->req_header.rqs_flags & RQSFLAG_BADHEADER) {
				isp_print_bytes(isp, "bad header flag",
				    QENTRY_LEN, sp);
				buddaboom++;
			}
			if (sp->req_header.rqs_flags & RQSFLAG_BADPACKET) {
				isp_print_bytes(isp, "bad request packet",
				    QENTRY_LEN, sp);
				buddaboom++;
			}
		}

		if (sp->req_handle > isp->isp_maxcmds || sp->req_handle < 1) {
			isp_prt(isp, ISP_LOGERR,
			    "bad request handle %d (type 0x%x)",
			    sp->req_handle, etype);
			MEMZERO(hp, QENTRY_LEN);	/* PERF */
			ISP_WRITE(isp, isp->isp_respoutrp, optr);
			continue;
		}
		xs = isp_find_xs(isp, sp->req_handle);
		if (xs == NULL) {
			u_int8_t ts = completion_status & 0xff;
			/*
			 * Only whine if this isn't the expected fallout of
			 * aborting the command.
			 */
			if (etype != RQSTYPE_RESPONSE) {
				isp_prt(isp, ISP_LOGERR,
				    "cannot find handle 0x%x (type 0x%x)",
				    sp->req_handle, etype);
			} else if (ts != RQCS_ABORTED) {
				isp_prt(isp, ISP_LOGERR,
				    "cannot find handle 0x%x (status 0x%x)",
				    sp->req_handle, ts);
			}
			MEMZERO(hp, QENTRY_LEN);	/* PERF */
			ISP_WRITE(isp, isp->isp_respoutrp, optr);
			continue;
		}
		isp_destroy_handle(isp, sp->req_handle);
		if (req_status_flags & RQSTF_BUS_RESET) {
			XS_SETERR(xs, HBA_BUSRESET);
			isp->isp_sendmarker |= (1 << XS_CHANNEL(xs));
		}
		if (buddaboom) {
			XS_SETERR(xs, HBA_BOTCH);
		}

		resp = NULL;
		rlen = 0;
		snsp = NULL;
		slen = 0;
		if (IS_FC(isp) && (scsi_status & RQCS_RV) != 0) {
			resp = sp->req_response;
			rlen = sp->req_response_len;
		}
		if (IS_FC(isp) && (scsi_status & RQCS_SV) != 0) {
			/*
			 * Fibre Channel F/W doesn't say we got status
			 * if there's Sense Data instead. I guess they
			 * think it goes w/o saying.
			 */
			req_state_flags |= RQSF_GOT_STATUS|RQSF_GOT_SENSE;
			snsp = sp->req_sense_data;
			slen = sp->req_sense_len;
		} else if (IS_SCSI(isp) && (req_state_flags & RQSF_GOT_SENSE)) {
			snsp = sp->req_sense_data;
			slen = sp->req_sense_len;
		}
		if (req_state_flags & RQSF_GOT_STATUS) {
			*XS_STSP(xs) = scsi_status & 0xff;
		}

		switch (etype) {
		case RQSTYPE_RESPONSE:
			XS_SET_STATE_STAT(isp, xs, sp);
			if (resp && rlen >= 4 &&
			    resp[FCP_RSPNS_CODE_OFFSET] != 0) {
				isp_prt(isp, ISP_LOGWARN,
				    "%d.%d.%d FCP RESPONSE: 0x%x",
				    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),
				    resp[FCP_RSPNS_CODE_OFFSET]);
				XS_SETERR(xs, HBA_BOTCH);
			}
			isp_parse_status(isp, (void *)sp, xs, &resid);
			if ((XS_NOERR(xs) || XS_ERR(xs) == HBA_NOERROR) &&
			    (*XS_STSP(xs) == SCSI_BUSY)) {
				XS_SETERR(xs, HBA_TGTBSY);
			}
			if (IS_SCSI(isp)) {
				XS_RESID(xs) = resid;
				/*
				 * A new synchronous rate was negotiated for
				 * this target. Mark state such that we'll go
				 * look up that which has changed later.
				 */
				if (req_status_flags & RQSTF_NEGOTIATION) {
					int t = XS_TGT(xs);
					sdparam *sdp = isp->isp_param;
					sdp += XS_CHANNEL(xs);
					sdp->isp_devparam[t].dev_refresh = 1;
					isp->isp_update |=
					    (1 << XS_CHANNEL(xs));
				}
			} else {
				if (req_status_flags & RQSF_XFER_COMPLETE) {
					XS_RESID(xs) = 0;
				} else if (scsi_status & RQCS_RESID) {
					XS_RESID(xs) = resid;
				} else {
					XS_RESID(xs) = 0;
				}
			}
			if (snsp && slen) {
				XS_SAVE_SENSE(xs, snsp, slen);
			}
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG2,
			   "asked for %ld got raw resid %ld settled for %ld",
			    (long) XS_XFRLEN(xs), resid, (long) XS_RESID(xs));
#endif
			break;
		case RQSTYPE_REQUEST:
		case RQSTYPE_A64:
		case RQSTYPE_T2RQS:
		case RQSTYPE_T3RQS:
		case RQSTYPE_T7RQS:
			if (sp->req_header.rqs_flags & RQSFLAG_FULL) {
				/*
				 * Force Queue Full status.
				 */
				*XS_STSP(xs) = SCSI_QFULL;
				XS_SETERR(xs, HBA_NOERROR);
			} else if (XS_NOERR(xs)) {
				/*
				 * ????
				 */
				XS_SETERR(xs, HBA_BOTCH);
#ifndef SMALL_KERNEL
				isp_prt(isp, ISP_LOGDEBUG0,
				    "Request Queue Entry bounced back");
#endif
				if ((isp->isp_dblev & ISP_LOGDEBUG1) == 0) {
					isp_print_bytes(isp, "Bounced Request",
					    QENTRY_LEN, qe);
				}
			}
			XS_RESID(xs) = XS_XFRLEN(xs);
			break;
		default:
			isp_print_bytes(isp, "Unhandled Response Type",
			    QENTRY_LEN, qe);
			if (XS_NOERR(xs)) {
				XS_SETERR(xs, HBA_BOTCH);
			}
			break;
		}

		/*
		 * Free any DMA resources. As a side effect, this may
		 * also do any cache flushing necessary for data coherence.
		 */
		if (XS_XFRLEN(xs)) {
			ISP_DMAFREE(isp, xs, sp->req_handle);
		}

		if (((isp->isp_dblev & (ISP_LOGDEBUG2|ISP_LOGDEBUG3))) ||
		    ((isp->isp_dblev & ISP_LOGDEBUG0) && ((!XS_NOERR(xs)) ||
		    (*XS_STSP(xs) != SCSI_GOOD)))) {
			char skey;
			if (req_state_flags & RQSF_GOT_SENSE) {
				skey = XS_SNSKEY(xs) & 0xf;
				if (skey < 10)
					skey += '0';
				else
					skey += 'a' - 10;
			} else if (*XS_STSP(xs) == SCSI_CHECK) {
				skey = '?';
			} else {
				skey = '.';
			}
			isp_prt(isp, ISP_LOGALL, finmsg, XS_CHANNEL(xs),
			    XS_TGT(xs), XS_LUN(xs), XS_XFRLEN(xs), XS_RESID(xs),
			    *XS_STSP(xs), skey, XS_ERR(xs));
		}

		if (isp->isp_nactive > 0)
		    isp->isp_nactive--;
		complist[ndone++] = xs;	/* defer completion call until later */
		MEMZERO(hp, QENTRY_LEN);	/* PERF */
		if (ndone == MAX_REQUESTQ_COMPLETIONS) {
			break;
		}
	}

	/*
	 * If we looked at any commands, then it's valid to find out
	 * what the outpointer is. It also is a trigger to update the
	 * ISP's notion of what we've seen so far.
	 */
	if (nlooked) {
		ISP_WRITE(isp, isp->isp_respoutrp, optr);
		/*
		 * While we're at it, read the requst queue out pointer.
		 */
		isp->isp_reqodx = ISP_READ(isp, isp->isp_rqstoutrp);
		if (isp->isp_rscchiwater < ndone) {
			isp->isp_rscchiwater = ndone;
		}
	}

out:

	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
	ISP_WRITE(isp, BIU_SEMA, 0);

	isp->isp_residx = optr;
	isp->isp_rspbsy = 0;
	for (i = 0; i < ndone; i++) {
		xs = complist[i];
		if (xs) {
			isp->isp_rsltccmplt++;
			isp_done(xs);
		}
	}
}

/*
 * Support routines.
 */

int
isp_parse_async(struct ispsoftc *isp, u_int16_t mbox)
{
	int rval = 0;
	int bus;

	if (IS_DUALBUS(isp)) {
		bus = ISP_READ(isp, OUTMAILBOX6);
	} else {
		bus = 0;
	}
#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG2, "Async Mbox 0x%x", mbox);
#endif

	switch (mbox) {
	case ASYNC_BUS_RESET:
		isp->isp_sendmarker |= (1 << bus);
#ifdef	ISP_TARGET_MODE
		if (isp_target_async(isp, bus, mbox)) {
			rval = -1;
		}
#endif
		isp_async(isp, ISPASYNC_BUS_RESET, &bus);
		break;
	case ASYNC_SYSTEM_ERROR:
		isp->isp_state = ISP_CRASHED;
		if (IS_FC(isp)) {
			FCPARAM(isp)->isp_loopstate = LOOP_NIL;
			FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		}
		/*
		 * Were we waiting for a mailbox command to complete?
		 * If so, it's dead, so wake up the waiter.
		 */
		if (isp->isp_mboxbsy) {
			isp->isp_obits = 1;
			isp->isp_mboxtmp[0] = MBOX_HOST_INTERFACE_ERROR;
			MBOX_NOTIFY_COMPLETE(isp);
		}
		/*
		 * It's up to the handler for isp_async to reinit stuff and
		 * restart the firmware
		 */
		isp_async(isp, ISPASYNC_FW_CRASH, NULL);
		rval = -1;
		break;

	case ASYNC_RQS_XFER_ERR:
		isp_prt(isp, ISP_LOGERR, "Request Queue Transfer Error");
		break;

	case ASYNC_RSP_XFER_ERR:
		isp_prt(isp, ISP_LOGERR, "Response Queue Transfer Error");
		break;

	case ASYNC_QWAKEUP:
		/*
		 * We've just been notified that the Queue has woken up.
		 * We don't need to be chatty about this- just unlatch things
		 * and move on.
		 */
		mbox = ISP_READ(isp, isp->isp_rqstoutrp);
		break;

	case ASYNC_TIMEOUT_RESET:
		isp_prt(isp, ISP_LOGWARN,
		    "timeout initiated SCSI bus reset of bus %d", bus);
		isp->isp_sendmarker |= (1 << bus);
#ifdef	ISP_TARGET_MODE
		if (isp_target_async(isp, bus, mbox)) {
			rval = -1;
		}
#endif
		break;

	case ASYNC_DEVICE_RESET:
		isp_prt(isp, ISP_LOGINFO, "device reset on bus %d", bus);
		isp->isp_sendmarker |= (1 << bus);
#ifdef	ISP_TARGET_MODE
		if (isp_target_async(isp, bus, mbox)) {
			rval = -1;
		}
#endif
		break;

	case ASYNC_EXTMSG_UNDERRUN:
		isp_prt(isp, ISP_LOGWARN, "extended message underrun");
		break;

	case ASYNC_SCAM_INT:
		isp_prt(isp, ISP_LOGINFO, "SCAM interrupt");
		break;

	case ASYNC_HUNG_SCSI:
		isp_prt(isp, ISP_LOGERR,
		    "stalled SCSI Bus after DATA Overrun");
		/* XXX: Need to issue SCSI reset at this point */
		break;

	case ASYNC_KILLED_BUS:
		isp_prt(isp, ISP_LOGERR, "SCSI Bus reset after DATA Overrun");
		break;

	case ASYNC_BUS_TRANSIT:
		mbox = ISP_READ(isp, OUTMAILBOX2);
		switch (mbox & 0x1c00) {
		case SXP_PINS_LVD_MODE:
			isp_prt(isp, ISP_LOGINFO, "Transition to LVD mode");
			SDPARAM(isp)->isp_diffmode = 0;
			SDPARAM(isp)->isp_ultramode = 0;
			SDPARAM(isp)->isp_lvdmode = 1;
			break;
		case SXP_PINS_HVD_MODE:
			isp_prt(isp, ISP_LOGINFO,
			    "Transition to Differential mode");
			SDPARAM(isp)->isp_diffmode = 1;
			SDPARAM(isp)->isp_ultramode = 0;
			SDPARAM(isp)->isp_lvdmode = 0;
			break;
		case SXP_PINS_SE_MODE:
			isp_prt(isp, ISP_LOGINFO,
			    "Transition to Single Ended mode");
			SDPARAM(isp)->isp_diffmode = 0;
			SDPARAM(isp)->isp_ultramode = 1;
			SDPARAM(isp)->isp_lvdmode = 0;
			break;
		default:
			isp_prt(isp, ISP_LOGWARN,
			    "Transition to Unknown Mode 0x%x", mbox);
			break;
		}
		/*
		 * XXX: Set up to renegotiate again!
		 */
		/* Can only be for a 1080... */
		isp->isp_sendmarker |= (1 << bus);
		break;

	/*
	 * We can use bus, which will always be zero for FC cards,
	 * as a mailbox pattern accumulator to be checked below.
	 */
	case ASYNC_RIO5:
		bus = 0x1ce;	/* outgoing mailbox regs 1-3, 6-7 */
		break;

	case ASYNC_RIO4:
		bus = 0x14e;	/* outgoing mailbox regs 1-3, 6 */
		break;

	case ASYNC_RIO3:
		bus = 0x10e;	/* outgoing mailbox regs 1-3 */
		break;

	case ASYNC_RIO2:
		bus = 0x106;	/* outgoing mailbox regs 1-2 */
		break;

	case ASYNC_RIO1:
	case ASYNC_CMD_CMPLT:
		bus = 0x102;	/* outgoing mailbox regs 1 */
		break;

	case ASYNC_RIO_RESP:
		return (rval);

	case ASYNC_CTIO_DONE:
	{
#ifdef	ISP_TARGET_MODE
		int handle =
		    (ISP_READ(isp, OUTMAILBOX2) << 16) | 
		    (ISP_READ(isp, OUTMAILBOX1));
		if (isp_target_async(isp, handle, mbox)) {
			rval = -1;
		} else {
			/* count it as a fast posting intr */
			isp->isp_fphccmplt++;
		}
#else
		isp_prt(isp, ISP_LOGINFO, "Fast Posting CTIO done");
		isp->isp_fphccmplt++;	/* count it as a fast posting intr */
#endif
		break;
	}
	case ASYNC_LIP_ERROR:
	case ASYNC_LIP_F8:
	case ASYNC_LIP_OCCURRED:
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_LIP_RCVD;
		isp->isp_sendmarker = 1;
		ISP_MARK_PORTDB(isp, 1);
		isp_async(isp, ISPASYNC_LIP, NULL);
#ifdef	ISP_TARGET_MODE
		if (isp_target_async(isp, bus, mbox)) {
			rval = -1;
		}
#endif
		/*
		 * We've had problems with data corruption occuring on
		 * commands that complete (with no apparent error) after
		 * we receive a LIP. This has been observed mostly on
		 * Local Loop topologies. To be safe, let's just mark
		 * all active commands as dead.
		 */
		if (FCPARAM(isp)->isp_topo == TOPO_NL_PORT ||
		    FCPARAM(isp)->isp_topo == TOPO_FL_PORT) {
			int i, j;
			for (i = j = 0; i < isp->isp_maxcmds; i++) {
				XS_T *xs;
				xs = isp->isp_xflist[i];
				if (xs != NULL) {
					j++;
					XS_SETERR(xs, HBA_BUSRESET);
				}
			}
			if (j) {
				isp_prt(isp, ISP_LOGERR,
				    "LIP destroyed %d active commands", j);
			}
		}
		break;

	case ASYNC_LOOP_UP:
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_LIP_RCVD;
		ISP_MARK_PORTDB(isp, 1);
		isp_async(isp, ISPASYNC_LOOP_UP, NULL);
#ifdef	ISP_TARGET_MODE
		if (isp_target_async(isp, bus, mbox)) {
			rval = -1;
		}
#endif
		break;

	case ASYNC_LOOP_DOWN:
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_NIL;
		ISP_MARK_PORTDB(isp, 1);
		isp_async(isp, ISPASYNC_LOOP_DOWN, NULL);
#ifdef	ISP_TARGET_MODE
		if (isp_target_async(isp, bus, mbox)) {
			rval = -1;
		}
#endif
		break;

	case ASYNC_LOOP_RESET:
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_NIL;
		ISP_MARK_PORTDB(isp, 1);
		isp_async(isp, ISPASYNC_LOOP_RESET, NULL);
#ifdef	ISP_TARGET_MODE
		if (isp_target_async(isp, bus, mbox)) {
			rval = -1;
		}
#endif
		break;

	case ASYNC_PDB_CHANGED:
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
		ISP_MARK_PORTDB(isp, 1);
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_PDB);
		break;

	case ASYNC_CHANGE_NOTIFY:
	    	if (FCPARAM(isp)->isp_topo == TOPO_F_PORT) {
			FCPARAM(isp)->isp_loopstate = LOOP_LSCAN_DONE;
		} else {
			FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
		}
		ISP_MARK_PORTDB(isp, 1);
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_SNS);
		break;

	case ASYNC_PTPMODE:
		ISP_MARK_PORTDB(isp, 1);
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_LIP_RCVD;
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_OTHER);
#ifdef	ISP_TARGET_MODE
		if (isp_target_async(isp, bus, mbox)) {
			rval = -1;
		}
#endif
		isp_prt(isp, ISP_LOGINFO, "Point-to-Point mode");
		break;

	case ASYNC_CONNMODE:
		mbox = ISP_READ(isp, OUTMAILBOX1);
		ISP_MARK_PORTDB(isp, 1);
		switch (mbox) {
		case ISP_CONN_LOOP:
			isp_prt(isp, ISP_LOGINFO,
			    "Point-to-Point -> Loop mode");
			break;
		case ISP_CONN_PTP:
			isp_prt(isp, ISP_LOGINFO,
			    "Loop -> Point-to-Point mode");
			break;
		case ISP_CONN_BADLIP:
			isp_prt(isp, ISP_LOGWARN,
			    "Point-to-Point -> Loop mode (BAD LIP)");
			break;
		case ISP_CONN_FATAL:
			isp_prt(isp, ISP_LOGERR, "FATAL CONNECTION ERROR");
			isp_async(isp, ISPASYNC_FW_CRASH, NULL);
			return (-1);
		case ISP_CONN_LOOPBACK:
			isp_prt(isp, ISP_LOGWARN,
			    "Looped Back in Point-to-Point mode");
			break;
		default:
			isp_prt(isp, ISP_LOGWARN,
			    "Unknown connection mode (0x%x)", mbox);
			break;
		}
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_OTHER);
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_LIP_RCVD;
		break;

	case ASYNC_RJT_SENT:	/* same as ASYNC_QFULL_SENT */
		if (IS_2200(isp)) {
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGTDEBUG0, "QFULL sent");
#endif
			break;
		}
		/* FALLTHROUGH */
	default:
		isp_prt(isp, ISP_LOGWARN, "Unknown Async Code 0x%x", mbox);
		break;
	}

	if (bus & 0x100) {
		int i, nh;
		u_int16_t handles[16];

		for (nh = 0, i = 1; i < MAX_MAILBOX(isp); i++) {
			if ((bus & (1 << i)) == 0) {
				continue;
			}
			handles[nh++] = ISP_READ(isp, MBOX_OFF(i));
		}
		for (i = 0; i < nh; i++) {
			isp_fastpost_complete(isp, handles[i]);
#ifndef SMALL_KERNEL
			isp_prt(isp,  ISP_LOGDEBUG3,
			    "fast post completion of %u", handles[i]);
#endif
		}
		if (isp->isp_fpcchiwater < nh) {
			isp->isp_fpcchiwater = nh;
		}
	} else {
		isp->isp_intoasync++;
	}
	return (rval);
}

/*
 * Handle other response entries. A pointer to the request queue output
 * index is here in case we want to eat several entries at once, although
 * this is not used currently.
 */

int
isp_handle_other_response(struct ispsoftc *isp, int type,
    isphdr_t *hp, u_int32_t *optrp)
{
	switch (type) {
	case RQSTYPE_STATUS_CONT:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "Ignored Continuation Response");
#endif
		return (1);
	case RQSTYPE_MARKER:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "Marker Response");
#endif
		return (1);
	case RQSTYPE_ATIO:
	case RQSTYPE_CTIO:
	case RQSTYPE_ENABLE_LUN:
	case RQSTYPE_MODIFY_LUN:
	case RQSTYPE_NOTIFY:
	case RQSTYPE_NOTIFY_ACK:
	case RQSTYPE_CTIO1:
	case RQSTYPE_ATIO2:
	case RQSTYPE_CTIO2:
	case RQSTYPE_CTIO3:
	case RQSTYPE_CTIO7:
	case RQSTYPE_ABTS_RCVD:
	case RQSTYPE_ABTS_RSP:
		isp->isp_rsltccmplt++;	/* count as a response completion */
#ifdef	ISP_TARGET_MODE
		if (isp_target_notify(isp, (ispstatusreq_t *) hp, optrp)) {
			return (1);
		}
#endif
		/* FALLTHROUGH */
	case RQSTYPE_REQUEST:
	default:
		USEC_DELAY(100);
		if (type != isp_get_response_type(isp, hp)) {
			/*
			 * This is questionable- we're just papering over
			 * something we've seen on SMP linux in target
			 * mode- we don't really know what's happening
			 * here that causes us to think we've gotten
			 * an entry, but that either the entry isn't
			 * filled out yet or our CPU read data is stale.
			 */
			isp_prt(isp, ISP_LOGINFO,
				"unstable type in response queue");
			return (-1);
		}
		isp_prt(isp, ISP_LOGWARN, "Unhandled Response Type 0x%x",
		    isp_get_response_type(isp, hp));
		if (isp_async(isp, ISPASYNC_UNHANDLED_RESPONSE, hp)) {
			return (1);
		}
		return (0);
	}
}

void
isp_parse_status(struct ispsoftc *isp, ispstatusreq_t *sp, XS_T *xs, long *rp)
{
	switch (sp->req_completion_status & 0xff) {
	case RQCS_COMPLETE:
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_NOERROR);
		}
		return;

	case RQCS_INCOMPLETE:
		if ((sp->req_state_flags & RQSF_GOT_TARGET) == 0) {
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG1,
			    "Selection Timeout for %d.%d.%d",
			    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
#endif
			if (XS_NOERR(xs)) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				*rp = XS_XFRLEN(xs);
			}
			return;
		}
		isp_prt(isp, ISP_LOGERR,
		    "command incomplete for %d.%d.%d, state 0x%x",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),
		    sp->req_state_flags);
		break;

	case RQCS_DMA_ERROR:
		isp_prt(isp, ISP_LOGERR, "DMA error for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		*rp = XS_XFRLEN(xs);
		break;

	case RQCS_TRANSPORT_ERROR:
	{
		char buf[172];
		SNPRINTF(buf, sizeof (buf), "states=>");
		if (sp->req_state_flags & RQSF_GOT_BUS) {
			SNPRINTF(buf, sizeof (buf), "%s GOT_BUS", buf);
		}
		if (sp->req_state_flags & RQSF_GOT_TARGET) {
			SNPRINTF(buf, sizeof (buf), "%s GOT_TGT", buf);
		}
		if (sp->req_state_flags & RQSF_SENT_CDB) {
			SNPRINTF(buf, sizeof (buf), "%s SENT_CDB", buf);
		}
		if (sp->req_state_flags & RQSF_XFRD_DATA) {
			SNPRINTF(buf, sizeof (buf), "%s XFRD_DATA", buf);
		}
		if (sp->req_state_flags & RQSF_GOT_STATUS) {
			SNPRINTF(buf, sizeof (buf), "%s GOT_STS", buf);
		}
		if (sp->req_state_flags & RQSF_GOT_SENSE) {
			SNPRINTF(buf, sizeof (buf), "%s GOT_SNS", buf);
		}
		if (sp->req_state_flags & RQSF_XFER_COMPLETE) {
			SNPRINTF(buf, sizeof (buf), "%s XFR_CMPLT", buf);
		}
		SNPRINTF(buf, sizeof (buf), "%s\nstatus=>", buf);
		if (sp->req_status_flags & RQSTF_DISCONNECT) {
			SNPRINTF(buf, sizeof (buf), "%s Disconnect", buf);
		}
		if (sp->req_status_flags & RQSTF_SYNCHRONOUS) {
			SNPRINTF(buf, sizeof (buf), "%s Sync_xfr", buf);
		}
		if (sp->req_status_flags & RQSTF_PARITY_ERROR) {
			SNPRINTF(buf, sizeof (buf), "%s Parity", buf);
		}
		if (sp->req_status_flags & RQSTF_BUS_RESET) {
			SNPRINTF(buf, sizeof (buf), "%s Bus_Reset", buf);
		}
		if (sp->req_status_flags & RQSTF_DEVICE_RESET) {
			SNPRINTF(buf, sizeof (buf), "%s Device_Reset", buf);
		}
		if (sp->req_status_flags & RQSTF_ABORTED) {
			SNPRINTF(buf, sizeof (buf), "%s Aborted", buf);
		}
		if (sp->req_status_flags & RQSTF_TIMEOUT) {
			SNPRINTF(buf, sizeof (buf), "%s Timeout", buf);
		}
		if (sp->req_status_flags & RQSTF_NEGOTIATION) {
			SNPRINTF(buf, sizeof (buf), "%s Negotiation", buf);
		}
		isp_prt(isp, ISP_LOGERR, "%s", buf);
		isp_prt(isp, ISP_LOGERR, "transport error for %d.%d.%d:\n%s",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs), buf);
		*rp = XS_XFRLEN(xs);
		break;
	}
	case RQCS_RESET_OCCURRED:
		isp_prt(isp, ISP_LOGWARN,
		    "bus reset destroyed command for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		isp->isp_sendmarker |= (1 << XS_CHANNEL(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_BUSRESET);
		}
		*rp = XS_XFRLEN(xs);
		return;

	case RQCS_ABORTED:
		isp_prt(isp, ISP_LOGERR, "command aborted for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		isp->isp_sendmarker |= (1 << XS_CHANNEL(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_ABORTED);
		}
		return;

	case RQCS_TIMEOUT:
		isp_prt(isp, ISP_LOGWARN, "command timed out for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		/*
	 	 * XXX: Check to see if we logged out of the device.
		 */
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_CMDTIMEOUT);
		}
		return;

	case RQCS_DATA_OVERRUN:
		XS_RESID(xs) = sp->req_resid;
		isp_prt(isp, ISP_LOGERR, "data overrun for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_DATAOVR);
		}
		return;

	case RQCS_COMMAND_OVERRUN:
		isp_prt(isp, ISP_LOGERR,
		    "command overrun for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_STATUS_OVERRUN:
		isp_prt(isp, ISP_LOGERR,
		    "status overrun for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_BAD_MESSAGE:
		isp_prt(isp, ISP_LOGERR,
		    "msg not COMMAND COMPLETE after status %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_NO_MESSAGE_OUT:
		isp_prt(isp, ISP_LOGERR,
		    "No MESSAGE OUT phase after selection on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_EXT_ID_FAILED:
		isp_prt(isp, ISP_LOGERR, "EXTENDED IDENTIFY failed %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_IDE_MSG_FAILED:
		isp_prt(isp, ISP_LOGERR,
		    "INITIATOR DETECTED ERROR rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_ABORT_MSG_FAILED:
		isp_prt(isp, ISP_LOGERR, "ABORT OPERATION rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_REJECT_MSG_FAILED:
		isp_prt(isp, ISP_LOGERR, "MESSAGE REJECT rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_NOP_MSG_FAILED:
		isp_prt(isp, ISP_LOGERR, "NOP rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_PARITY_ERROR_MSG_FAILED:
		isp_prt(isp, ISP_LOGERR,
		    "MESSAGE PARITY ERROR rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_DEVICE_RESET_MSG_FAILED:
		isp_prt(isp, ISP_LOGWARN,
		    "BUS DEVICE RESET rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_ID_MSG_FAILED:
		isp_prt(isp, ISP_LOGERR, "IDENTIFY rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_UNEXP_BUS_FREE:
		isp_prt(isp, ISP_LOGERR, "%d.%d.%d had an unexpected bus free",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_DATA_UNDERRUN:
	{
		if (IS_FC(isp)) {
			int ru_marked = (sp->req_scsi_status & RQCS_RU) != 0;
			if (!ru_marked || sp->req_resid > XS_XFRLEN(xs)) {
				isp_prt(isp, ISP_LOGWARN, bun, XS_TGT(xs),
				    XS_LUN(xs), XS_XFRLEN(xs), sp->req_resid,
				    (ru_marked)? "marked" : "not marked");
				if (XS_NOERR(xs)) {
					XS_SETERR(xs, HBA_BOTCH);
				}
				return;
			}
		}
		XS_RESID(xs) = sp->req_resid;
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_NOERROR);
		}
		return;
	}

	case RQCS_XACT_ERR1:
		isp_prt(isp, ISP_LOGERR, xact1, XS_CHANNEL(xs),
		    XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_XACT_ERR2:
		isp_prt(isp, ISP_LOGERR, xact2,
		    XS_LUN(xs), XS_TGT(xs), XS_CHANNEL(xs));
		break;

	case RQCS_XACT_ERR3:
		isp_prt(isp, ISP_LOGERR, xact3,
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_BAD_ENTRY:
		isp_prt(isp, ISP_LOGERR, "Invalid IOCB entry type detected");
		break;

	case RQCS_QUEUE_FULL:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0,
		    "internal queues full for %d.%d.%d status 0x%x",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs), *XS_STSP(xs));
#endif

		/*
		 * If QFULL or some other status byte is set, then this
		 * isn't an error, per se.
		 *
		 * Unfortunately, some QLogic f/w writers have, in
		 * some cases, ommitted to *set* status to QFULL.
		 *

		if (*XS_STSP(xs) != SCSI_GOOD && XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_NOERROR);
			return;
		}

		 *
		 *
		 */

		*XS_STSP(xs) = SCSI_QFULL;
		XS_SETERR(xs, HBA_NOERROR);
		return;

	case RQCS_PHASE_SKIPPED:
		isp_prt(isp, ISP_LOGERR, pskip, XS_CHANNEL(xs),
		    XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_ARQS_FAILED:
		isp_prt(isp, ISP_LOGERR,
		    "Auto Request Sense failed for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_ARQFAIL);
		}
		return;

	case RQCS_WIDE_FAILED:
		isp_prt(isp, ISP_LOGERR,
		    "Wide Negotiation failed for %d.%d.%d",
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
		if (IS_SCSI(isp)) {
			sdparam *sdp = isp->isp_param;
			sdp += XS_CHANNEL(xs);
			sdp->isp_devparam[XS_TGT(xs)].goal_flags &= ~DPARM_WIDE;
			sdp->isp_devparam[XS_TGT(xs)].dev_update = 1;
			isp->isp_update |= (1 << XS_CHANNEL(xs));
		}
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_NOERROR);
		}
		return;

	case RQCS_SYNCXFER_FAILED:
		isp_prt(isp, ISP_LOGERR,
		    "SDTR Message failed for target %d.%d.%d",
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
		if (IS_SCSI(isp)) {
			sdparam *sdp = isp->isp_param;
			sdp += XS_CHANNEL(xs);
			sdp->isp_devparam[XS_TGT(xs)].goal_flags &= ~DPARM_SYNC;
			sdp->isp_devparam[XS_TGT(xs)].dev_update = 1;
			isp->isp_update |= (1 << XS_CHANNEL(xs));
		}
		break;

	case RQCS_LVD_BUSERR:
		isp_prt(isp, ISP_LOGERR,
		    "Bad LVD condition while talking to %d.%d.%d",
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
		break;

	case RQCS_PORT_UNAVAILABLE:
		/*
		 * No such port on the loop. Moral equivalent of SELTIMEO
		 */
	case RQCS_PORT_LOGGED_OUT:
	{
		const char *reason;
		u_int8_t sts = sp->req_completion_status & 0xff;

		/*
		 * It was there (maybe)- treat as a selection timeout.
		 */
		if (sts == RQCS_PORT_UNAVAILABLE) {
			reason = "unavailable";
		} else {
			reason = "logout";
		}

		isp_prt(isp, ISP_LOGINFO, "port %s for target %d",
		    reason, XS_TGT(xs));

		/*
		 * If we're on a local loop, force a LIP (which is overkill)
		 * to force a re-login of this unit. If we're on fabric,
		 * then we'll have to log in again as a matter of course.
		 */
		if (FCPARAM(isp)->isp_topo == TOPO_NL_PORT ||
		    FCPARAM(isp)->isp_topo == TOPO_FL_PORT) {
			mbreg_t mbs;
			MEMZERO(&mbs, sizeof (mbs));
			mbs.param[0] = MBOX_INIT_LIP;
			if (FCPARAM(isp)->isp_2klogin) {
				mbs.ibits = (1 << 10);
			}
			mbs.logval = MBLOGALL;
			isp_mboxcmd_qnw(isp, &mbs, 1);
		}
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
		}
		return;
	}
	case RQCS_PORT_CHANGED:
		isp_prt(isp, ISP_LOGWARN,
		    "port changed for target %d", XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
		}
		return;

	case RQCS_PORT_BUSY:
		isp_prt(isp, ISP_LOGWARN,
		    "port busy for target %d", XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_TGTBSY);
		}
		return;

	default:
		isp_prt(isp, ISP_LOGERR, "Unknown Completion Status 0x%x",
		    sp->req_completion_status);
		break;
	}
	if (XS_NOERR(xs)) {
		XS_SETERR(xs, HBA_BOTCH);
	}
}

void
isp_fastpost_complete(struct ispsoftc *isp, u_int16_t fph)
{
	XS_T *xs;

	if (fph == 0) {
		return;
	}
	xs = isp_find_xs(isp, fph);
	if (xs == NULL) {
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG1,
		    "Command for fast post handle 0x%x not found", fph);
#endif
		return;
	}
	isp_destroy_handle(isp, fph);

	/*
	 * Since we don't have a result queue entry item,
	 * we must believe that SCSI status is zero and
	 * that all data transferred.
	 */
	XS_SET_STATE_STAT(isp, xs, NULL);
	XS_RESID(xs) = 0;
	*XS_STSP(xs) = SCSI_GOOD;
	if (XS_XFRLEN(xs)) {
		ISP_DMAFREE(isp, xs, fph);
	}
	if (isp->isp_nactive)
		isp->isp_nactive--;
	isp->isp_fphccmplt++;
	isp_done(xs);
}

int
isp_mbox_continue(struct ispsoftc *isp)
{
	mbreg_t mbs;
	u_int16_t *ptr;
	u_int32_t offset;

	switch (isp->isp_lastmbxcmd) {
	case MBOX_WRITE_RAM_WORD:
	case MBOX_READ_RAM_WORD:
	case MBOX_WRITE_RAM_WORD_EXTENDED:
	case MBOX_READ_RAM_WORD_EXTENDED:
		break;
	default:
		return (1);
	}
	if (isp->isp_mboxtmp[0] != MBOX_COMMAND_COMPLETE) {
		isp->isp_mbxwrk0 = 0;
		return (-1);
	}

	/*
	 * Clear the previous interrupt.
	 */
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
	ISP_WRITE(isp, BIU_SEMA, 0);

	/*
	 * Continue with next word.
	 */
	MEMZERO(&mbs, sizeof (mbs));
	ptr = isp->isp_mbxworkp;
	switch (isp->isp_lastmbxcmd) {
	case MBOX_WRITE_RAM_WORD:
		mbs.param[1] = isp->isp_mbxwrk1++;
		mbs.param[2] = *ptr++;
		break;
	case MBOX_READ_RAM_WORD:
		*ptr++ = isp->isp_mboxtmp[2];
		mbs.param[1] = isp->isp_mbxwrk1++;
		break;
	case MBOX_WRITE_RAM_WORD_EXTENDED:
		offset = isp->isp_mbxwrk1;
		offset |= isp->isp_mbxwrk8 << 16;

		mbs.param[2] = *ptr++;
		mbs.param[1] = offset;
		mbs.param[8] = offset >> 16;
		isp->isp_mbxwrk1 = ++offset;
		isp->isp_mbxwrk8 = offset >> 16;
		break;
	case MBOX_READ_RAM_WORD_EXTENDED:
		offset = isp->isp_mbxwrk1;
		offset |= isp->isp_mbxwrk8 << 16;

		*ptr++ = isp->isp_mboxtmp[2];
		mbs.param[1] = offset;
		mbs.param[8] = offset >> 16;
		isp->isp_mbxwrk1 = ++offset;
		isp->isp_mbxwrk8 = offset >> 16;
		break;
	}
	isp->isp_mbxworkp = ptr;
	isp->isp_mbxwrk0--;
	mbs.param[0] = isp->isp_lastmbxcmd;
	mbs.logval = MBLOGALL;
	isp_mboxcmd_qnw(isp, &mbs, 0);
	return (0);
}

#define	HIWRD(x)			((x) >> 16)
#define	LOWRD(x)			((x)  & 0xffff)
#define	ISPOPMAP(a, b)			(((a) << 16) | (b))
static const u_int32_t mbpscsi[] = {
	ISPOPMAP(0x01, 0x01),	/* 0x00: MBOX_NO_OP */
	ISPOPMAP(0x1f, 0x01),	/* 0x01: MBOX_LOAD_RAM */
	ISPOPMAP(0x03, 0x01),	/* 0x02: MBOX_EXEC_FIRMWARE */
	ISPOPMAP(0x1f, 0x01),	/* 0x03: MBOX_DUMP_RAM */
	ISPOPMAP(0x07, 0x07),	/* 0x04: MBOX_WRITE_RAM_WORD */
	ISPOPMAP(0x03, 0x07),	/* 0x05: MBOX_READ_RAM_WORD */
	ISPOPMAP(0x3f, 0x3f),	/* 0x06: MBOX_MAILBOX_REG_TEST */
	ISPOPMAP(0x07, 0x07),	/* 0x07: MBOX_VERIFY_CHECKSUM	*/
	ISPOPMAP(0x01, 0x0f),	/* 0x08: MBOX_ABOUT_FIRMWARE */
	ISPOPMAP(0x00, 0x00),	/* 0x09: */
	ISPOPMAP(0x00, 0x00),	/* 0x0a: */
	ISPOPMAP(0x00, 0x00),	/* 0x0b: */
	ISPOPMAP(0x00, 0x00),	/* 0x0c: */
	ISPOPMAP(0x00, 0x00),	/* 0x0d: */
	ISPOPMAP(0x01, 0x05),	/* 0x0e: MBOX_CHECK_FIRMWARE */
	ISPOPMAP(0x00, 0x00),	/* 0x0f: */
	ISPOPMAP(0x1f, 0x1f),	/* 0x10: MBOX_INIT_REQ_QUEUE */
	ISPOPMAP(0x3f, 0x3f),	/* 0x11: MBOX_INIT_RES_QUEUE */
	ISPOPMAP(0x0f, 0x0f),	/* 0x12: MBOX_EXECUTE_IOCB */
	ISPOPMAP(0x03, 0x03),	/* 0x13: MBOX_WAKE_UP	*/
	ISPOPMAP(0x01, 0x3f),	/* 0x14: MBOX_STOP_FIRMWARE */
	ISPOPMAP(0x0f, 0x0f),	/* 0x15: MBOX_ABORT */
	ISPOPMAP(0x03, 0x03),	/* 0x16: MBOX_ABORT_DEVICE */
	ISPOPMAP(0x07, 0x07),	/* 0x17: MBOX_ABORT_TARGET */
	ISPOPMAP(0x07, 0x07),	/* 0x18: MBOX_BUS_RESET */
	ISPOPMAP(0x03, 0x07),	/* 0x19: MBOX_STOP_QUEUE */
	ISPOPMAP(0x03, 0x07),	/* 0x1a: MBOX_START_QUEUE */
	ISPOPMAP(0x03, 0x07),	/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
	ISPOPMAP(0x03, 0x07),	/* 0x1c: MBOX_ABORT_QUEUE */
	ISPOPMAP(0x03, 0x4f),	/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
	ISPOPMAP(0x00, 0x00),	/* 0x1e: */
	ISPOPMAP(0x01, 0x07),	/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
	ISPOPMAP(0x01, 0x07),	/* 0x20: MBOX_GET_INIT_SCSI_ID */
	ISPOPMAP(0x01, 0x07),	/* 0x21: MBOX_GET_SELECT_TIMEOUT */
	ISPOPMAP(0x01, 0xc7),	/* 0x22: MBOX_GET_RETRY_COUNT	*/
	ISPOPMAP(0x01, 0x07),	/* 0x23: MBOX_GET_TAG_AGE_LIMIT */
	ISPOPMAP(0x01, 0x03),	/* 0x24: MBOX_GET_CLOCK_RATE */
	ISPOPMAP(0x01, 0x07),	/* 0x25: MBOX_GET_ACT_NEG_STATE */
	ISPOPMAP(0x01, 0x07),	/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */
	ISPOPMAP(0x01, 0x07),	/* 0x27: MBOX_GET_PCI_PARAMS */
	ISPOPMAP(0x03, 0x4f),	/* 0x28: MBOX_GET_TARGET_PARAMS */
	ISPOPMAP(0x03, 0x0f),	/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */
	ISPOPMAP(0x01, 0x07),	/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */
	ISPOPMAP(0x00, 0x00),	/* 0x2b: */
	ISPOPMAP(0x00, 0x00),	/* 0x2c: */
	ISPOPMAP(0x00, 0x00),	/* 0x2d: */
	ISPOPMAP(0x00, 0x00),	/* 0x2e: */
	ISPOPMAP(0x00, 0x00),	/* 0x2f: */
	ISPOPMAP(0x03, 0x03),	/* 0x30: MBOX_SET_INIT_SCSI_ID */
	ISPOPMAP(0x07, 0x07),	/* 0x31: MBOX_SET_SELECT_TIMEOUT */
	ISPOPMAP(0xc7, 0xc7),	/* 0x32: MBOX_SET_RETRY_COUNT	*/
	ISPOPMAP(0x07, 0x07),	/* 0x33: MBOX_SET_TAG_AGE_LIMIT */
	ISPOPMAP(0x03, 0x03),	/* 0x34: MBOX_SET_CLOCK_RATE */
	ISPOPMAP(0x07, 0x07),	/* 0x35: MBOX_SET_ACT_NEG_STATE */
	ISPOPMAP(0x07, 0x07),	/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */
	ISPOPMAP(0x07, 0x07),	/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */
	ISPOPMAP(0x4f, 0x4f),	/* 0x38: MBOX_SET_TARGET_PARAMS */
	ISPOPMAP(0x0f, 0x0f),	/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */
	ISPOPMAP(0x07, 0x07),	/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */
	ISPOPMAP(0x00, 0x00),	/* 0x3b: */
	ISPOPMAP(0x00, 0x00),	/* 0x3c: */
	ISPOPMAP(0x00, 0x00),	/* 0x3d: */
	ISPOPMAP(0x00, 0x00),	/* 0x3e: */
	ISPOPMAP(0x00, 0x00),	/* 0x3f: */
	ISPOPMAP(0x01, 0x03),	/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */
	ISPOPMAP(0x3f, 0x01),	/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */
	ISPOPMAP(0x03, 0x07),	/* 0x42: MBOX_EXEC_BIOS_IOCB */
	ISPOPMAP(0x00, 0x00),	/* 0x43: */
	ISPOPMAP(0x00, 0x00),	/* 0x44: */
	ISPOPMAP(0x03, 0x03),	/* 0x45: SET SYSTEM PARAMETER */
	ISPOPMAP(0x01, 0x03),	/* 0x46: GET SYSTEM PARAMETER */
	ISPOPMAP(0x00, 0x00),	/* 0x47: */
	ISPOPMAP(0x01, 0xcf),	/* 0x48: GET SCAM CONFIGURATION */
	ISPOPMAP(0xcf, 0xcf),	/* 0x49: SET SCAM CONFIGURATION */
	ISPOPMAP(0x03, 0x03),	/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */
	ISPOPMAP(0x01, 0x03),	/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */
	ISPOPMAP(0x00, 0x00),	/* 0x4c: */
	ISPOPMAP(0x00, 0x00),	/* 0x4d: */
	ISPOPMAP(0x00, 0x00),	/* 0x4e: */
	ISPOPMAP(0x00, 0x00),	/* 0x4f: */
	ISPOPMAP(0xdf, 0xdf),	/* 0x50: LOAD RAM A64 */
	ISPOPMAP(0xdf, 0xdf),	/* 0x51: DUMP RAM A64 */
	ISPOPMAP(0xdf, 0xff),	/* 0x52: INITIALIZE REQUEST QUEUE A64 */
	ISPOPMAP(0xef, 0xff),	/* 0x53: INITIALIZE RESPONSE QUEUE A64 */
	ISPOPMAP(0xcf, 0x01),	/* 0x54: EXECUCUTE COMMAND IOCB A64 */
	ISPOPMAP(0x07, 0x01),	/* 0x55: ENABLE TARGET MODE */
	ISPOPMAP(0x03, 0x0f),	/* 0x56: GET TARGET STATUS */
	ISPOPMAP(0x00, 0x00),	/* 0x57: */
	ISPOPMAP(0x00, 0x00),	/* 0x58: */
	ISPOPMAP(0x00, 0x00),	/* 0x59: */
	ISPOPMAP(0x03, 0x03),	/* 0x5a: SET DATA OVERRUN RECOVERY MODE */
	ISPOPMAP(0x01, 0x03),	/* 0x5b: GET DATA OVERRUN RECOVERY MODE */
	ISPOPMAP(0x0f, 0x0f),	/* 0x5c: SET HOST DATA */
	ISPOPMAP(0x01, 0x01)	/* 0x5d: GET NOST DATA */
};

#ifdef SMALL_KERNEL
#define ISP_STRIPPED
#endif

#ifndef		ISP_STRIPPED
static const char *scsi_mbcmd_names[] = {
	"NO-OP",
	"LOAD RAM",
	"EXEC FIRMWARE",
	"DUMP RAM",
	"WRITE RAM WORD",
	"READ RAM WORD",
	"MAILBOX REG TEST",
	"VERIFY CHECKSUM",
	"ABOUT FIRMWARE",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"CHECK FIRMWARE",
	NULL,
	"INIT REQUEST QUEUE",
	"INIT RESULT QUEUE",
	"EXECUTE IOCB",
	"WAKE UP",
	"STOP FIRMWARE",
	"ABORT",
	"ABORT DEVICE",
	"ABORT TARGET",
	"BUS RESET",
	"STOP QUEUE",
	"START QUEUE",
	"SINGLE STEP QUEUE",
	"ABORT QUEUE",
	"GET DEV QUEUE STATUS",
	NULL,
	"GET FIRMWARE STATUS",
	"GET INIT SCSI ID",
	"GET SELECT TIMEOUT",
	"GET RETRY COUNT",
	"GET TAG AGE LIMIT",
	"GET CLOCK RATE",
	"GET ACT NEG STATE",
	"GET ASYNC DATA SETUP TIME",
	"GET PCI PARAMS",
	"GET TARGET PARAMS",
	"GET DEV QUEUE PARAMS",
	"GET RESET DELAY PARAMS",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"SET INIT SCSI ID",
	"SET SELECT TIMEOUT",
	"SET RETRY COUNT",
	"SET TAG AGE LIMIT",
	"SET CLOCK RATE",
	"SET ACT NEG STATE",
	"SET ASYNC DATA SETUP TIME",
	"SET PCI CONTROL PARAMS",
	"SET TARGET PARAMS",
	"SET DEV QUEUE PARAMS",
	"SET RESET DELAY PARAMS",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"RETURN BIOS BLOCK ADDR",
	"WRITE FOUR RAM WORDS",
	"EXEC BIOS IOCB",
	NULL,
	NULL,
	"SET SYSTEM PARAMETER",
	"GET SYSTEM PARAMETER",
	NULL,
	"GET SCAM CONFIGURATION",
	"SET SCAM CONFIGURATION",
	"SET FIRMWARE FEATURES",
	"GET FIRMWARE FEATURES",
	NULL,
	NULL,
	NULL,
	NULL,
	"LOAD RAM A64",
	"DUMP RAM A64",
	"INITIALIZE REQUEST QUEUE A64",
	"INITIALIZE RESPONSE QUEUE A64",
	"EXECUTE IOCB A64",
	"ENABLE TARGET MODE",
	"GET TARGET MODE STATE",
	NULL,
	NULL,
	NULL,
	"SET DATA OVERRUN RECOVERY MODE",
	"GET DATA OVERRUN RECOVERY MODE",
	"SET HOST DATA",
	"GET NOST DATA",
};
#endif

static const u_int32_t mbpfc[] = {
	ISPOPMAP(0x01, 0x01),	/* 0x00: MBOX_NO_OP */
	ISPOPMAP(0x1f, 0x01),	/* 0x01: MBOX_LOAD_RAM */
	ISPOPMAP(0x0f, 0x01),	/* 0x02: MBOX_EXEC_FIRMWARE */
	ISPOPMAP(0xdf, 0x01),	/* 0x03: MBOX_DUMP_RAM */
	ISPOPMAP(0x07, 0x07),	/* 0x04: MBOX_WRITE_RAM_WORD */
	ISPOPMAP(0x03, 0x07),	/* 0x05: MBOX_READ_RAM_WORD */
	ISPOPMAP(0xff, 0xff),	/* 0x06: MBOX_MAILBOX_REG_TEST */
	ISPOPMAP(0x03, 0x07),	/* 0x07: MBOX_VERIFY_CHECKSUM	*/
	ISPOPMAP(0x01, 0x4f),	/* 0x08: MBOX_ABOUT_FIRMWARE */
	ISPOPMAP(0xdf, 0x01),	/* 0x09: MBOX_LOAD_RISC_RAM_2100 */
	ISPOPMAP(0xdf, 0x01),	/* 0x0a: DUMP RAM */
	ISPOPMAP(0x1ff, 0x01),	/* 0x0b: MBOX_LOAD_RISC_RAM */
	ISPOPMAP(0x00, 0x00),	/* 0x0c: */
	ISPOPMAP(0x10f, 0x01),	/* 0x0d: MBOX_WRITE_RAM_WORD_EXTENDED */
	ISPOPMAP(0x01, 0x05),	/* 0x0e: MBOX_CHECK_FIRMWARE */
	ISPOPMAP(0x10f, 0x05),	/* 0x0f: MBOX_READ_RAM_WORD_EXTENDED */
	ISPOPMAP(0x1f, 0x11),	/* 0x10: MBOX_INIT_REQ_QUEUE */
	ISPOPMAP(0x2f, 0x21),	/* 0x11: MBOX_INIT_RES_QUEUE */
	ISPOPMAP(0x0f, 0x01),	/* 0x12: MBOX_EXECUTE_IOCB */
	ISPOPMAP(0x03, 0x03),	/* 0x13: MBOX_WAKE_UP	*/
	ISPOPMAP(0x01, 0xff),	/* 0x14: MBOX_STOP_FIRMWARE */
	ISPOPMAP(0x4f, 0x01),	/* 0x15: MBOX_ABORT */
	ISPOPMAP(0x07, 0x01),	/* 0x16: MBOX_ABORT_DEVICE */
	ISPOPMAP(0x07, 0x01),	/* 0x17: MBOX_ABORT_TARGET */
	ISPOPMAP(0x03, 0x03),	/* 0x18: MBOX_BUS_RESET */
	ISPOPMAP(0x07, 0x05),	/* 0x19: MBOX_STOP_QUEUE */
	ISPOPMAP(0x07, 0x05),	/* 0x1a: MBOX_START_QUEUE */
	ISPOPMAP(0x07, 0x05),	/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
	ISPOPMAP(0x07, 0x05),	/* 0x1c: MBOX_ABORT_QUEUE */
	ISPOPMAP(0x07, 0x03),	/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
	ISPOPMAP(0x00, 0x00),	/* 0x1e: */
	ISPOPMAP(0x01, 0x07),	/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
	ISPOPMAP(0x01, 0x4f),	/* 0x20: MBOX_GET_LOOP_ID */
	ISPOPMAP(0x00, 0x00),	/* 0x21: */
	ISPOPMAP(0x01, 0x07),	/* 0x22: MBOX_GET_RETRY_COUNT	*/
	ISPOPMAP(0x00, 0x00),	/* 0x23: */
	ISPOPMAP(0x00, 0x00),	/* 0x24: */
	ISPOPMAP(0x00, 0x00),	/* 0x25: */
	ISPOPMAP(0x00, 0x00),	/* 0x26: */
	ISPOPMAP(0x00, 0x00),	/* 0x27: */
	ISPOPMAP(0x01, 0x03),	/* 0x28: MBOX_GET_FIRMWARE_OPTIONS */
	ISPOPMAP(0x03, 0x07),	/* 0x29: MBOX_GET_PORT_QUEUE_PARAMS */
	ISPOPMAP(0x00, 0x00),	/* 0x2a: */
	ISPOPMAP(0x00, 0x00),	/* 0x2b: */
	ISPOPMAP(0x00, 0x00),	/* 0x2c: */
	ISPOPMAP(0x00, 0x00),	/* 0x2d: */
	ISPOPMAP(0x00, 0x00),	/* 0x2e: */
	ISPOPMAP(0x00, 0x00),	/* 0x2f: */
	ISPOPMAP(0x00, 0x00),	/* 0x30: */
	ISPOPMAP(0x00, 0x00),	/* 0x31: */
	ISPOPMAP(0x07, 0x07),	/* 0x32: MBOX_SET_RETRY_COUNT	*/
	ISPOPMAP(0x00, 0x00),	/* 0x33: */
	ISPOPMAP(0x00, 0x00),	/* 0x34: */
	ISPOPMAP(0x00, 0x00),	/* 0x35: */
	ISPOPMAP(0x00, 0x00),	/* 0x36: */
	ISPOPMAP(0x00, 0x00),	/* 0x37: */
	ISPOPMAP(0x0f, 0x01),	/* 0x38: MBOX_SET_FIRMWARE_OPTIONS */
	ISPOPMAP(0x0f, 0x07),	/* 0x39: MBOX_SET_PORT_QUEUE_PARAMS */
	ISPOPMAP(0x00, 0x00),	/* 0x3a: */
	ISPOPMAP(0x00, 0x00),	/* 0x3b: */
	ISPOPMAP(0x00, 0x00),	/* 0x3c: */
	ISPOPMAP(0x00, 0x00),	/* 0x3d: */
	ISPOPMAP(0x00, 0x00),	/* 0x3e: */
	ISPOPMAP(0x00, 0x00),	/* 0x3f: */
	ISPOPMAP(0x03, 0x01),	/* 0x40: MBOX_LOOP_PORT_BYPASS */
	ISPOPMAP(0x03, 0x01),	/* 0x41: MBOX_LOOP_PORT_ENABLE */
	ISPOPMAP(0x03, 0x07),	/* 0x42: MBOX_GET_RESOURCE_COUNT */
	ISPOPMAP(0x01, 0x01),	/* 0x43: MBOX_REQUEST_OFFLINE_MODE */
	ISPOPMAP(0x00, 0x00),	/* 0x44: */
	ISPOPMAP(0x00, 0x00),	/* 0x45: */
	ISPOPMAP(0x00, 0x00),	/* 0x46: */
	ISPOPMAP(0xcf, 0x03),	/* 0x47: GET PORT_DATABASE ENHANCED */
	ISPOPMAP(0x00, 0x00),	/* 0x48: */
	ISPOPMAP(0x00, 0x00),	/* 0x49: */
	ISPOPMAP(0x00, 0x00),	/* 0x4a: */
	ISPOPMAP(0x00, 0x00),	/* 0x4b: */
	ISPOPMAP(0x00, 0x00),	/* 0x4c: */
	ISPOPMAP(0x00, 0x00),	/* 0x4d: */
	ISPOPMAP(0x00, 0x00),	/* 0x4e: */
	ISPOPMAP(0x00, 0x00),	/* 0x4f: */
	ISPOPMAP(0x00, 0x00),	/* 0x50: */
	ISPOPMAP(0x00, 0x00),	/* 0x51: */
	ISPOPMAP(0x00, 0x00),	/* 0x52: */
	ISPOPMAP(0x00, 0x00),	/* 0x53: */
	ISPOPMAP(0xcf, 0x01),	/* 0x54: EXECUTE IOCB A64 */
	ISPOPMAP(0x00, 0x00),	/* 0x55: */
	ISPOPMAP(0x00, 0x00),	/* 0x56: */
	ISPOPMAP(0x00, 0x00),	/* 0x57: */
	ISPOPMAP(0x00, 0x00),	/* 0x58: */
	ISPOPMAP(0x00, 0x00),	/* 0x59: */
	ISPOPMAP(0x00, 0x00),	/* 0x5a: */
	ISPOPMAP(0x03, 0x01),	/* 0x5b: MBOX_DRIVER_HEARTBEAT */
	ISPOPMAP(0xcf, 0x01),	/* 0x5c: MBOX_FW_HEARTBEAT */
	ISPOPMAP(0x07, 0x03),	/* 0x5d: MBOX_GET_SET_DATA_RATE */
	ISPOPMAP(0x00, 0x00),	/* 0x5e: */
	ISPOPMAP(0x00, 0x00),	/* 0x5f: */
	ISPOPMAP(0xcd, 0x01),	/* 0x60: MBOX_INIT_FIRMWARE */
	ISPOPMAP(0x00, 0x00),	/* 0x61: */
	ISPOPMAP(0x01, 0x01),	/* 0x62: MBOX_INIT_LIP */
	ISPOPMAP(0xcd, 0x03),	/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */
	ISPOPMAP(0xcf, 0x01),	/* 0x64: MBOX_GET_PORT_DB */
	ISPOPMAP(0x07, 0x01),	/* 0x65: MBOX_CLEAR_ACA */
	ISPOPMAP(0x07, 0x01),	/* 0x66: MBOX_TARGET_RESET */
	ISPOPMAP(0x07, 0x01),	/* 0x67: MBOX_CLEAR_TASK_SET */
	ISPOPMAP(0x07, 0x01),	/* 0x68: MBOX_ABORT_TASK_SET */
	ISPOPMAP(0x01, 0x07),	/* 0x69: MBOX_GET_FW_STATE */
	ISPOPMAP(0x03, 0xcf),	/* 0x6a: MBOX_GET_PORT_NAME */
	ISPOPMAP(0xcf, 0x01),	/* 0x6b: MBOX_GET_LINK_STATUS */
	ISPOPMAP(0x0f, 0x01),	/* 0x6c: MBOX_INIT_LIP_RESET */
	ISPOPMAP(0x00, 0x00),	/* 0x6d: */
	ISPOPMAP(0xcf, 0x03),	/* 0x6e: MBOX_SEND_SNS */
	ISPOPMAP(0x0f, 0x07),	/* 0x6f: MBOX_FABRIC_LOGIN */
	ISPOPMAP(0x03, 0x01),	/* 0x70: MBOX_SEND_CHANGE_REQUEST */
	ISPOPMAP(0x03, 0x03),	/* 0x71: MBOX_FABRIC_LOGOUT */
	ISPOPMAP(0x0f, 0x0f),	/* 0x72: MBOX_INIT_LIP_LOGIN */
	ISPOPMAP(0x00, 0x00),	/* 0x73: */
	ISPOPMAP(0x07, 0x01),	/* 0x74: LOGIN LOOP PORT */
	ISPOPMAP(0xcf, 0x03),	/* 0x75: GET PORT/NODE NAME LIST */
	ISPOPMAP(0x4f, 0x01),	/* 0x76: SET VENDOR ID */
	ISPOPMAP(0xcd, 0x01),	/* 0x77: INITIALIZE IP MAILBOX */
	ISPOPMAP(0x00, 0x00),	/* 0x78: */
	ISPOPMAP(0x00, 0x00),	/* 0x79: */
	ISPOPMAP(0x00, 0x00),	/* 0x7a: */
	ISPOPMAP(0x00, 0x00),	/* 0x7b: */
	ISPOPMAP(0x4f, 0x03),	/* 0x7c: Get ID List */
	ISPOPMAP(0xcf, 0x01),	/* 0x7d: SEND LFA */
	ISPOPMAP(0x0f, 0x01)	/* 0x7e: LUN RESET */
};
/*
 * Footnotes
 *
 * (1): this sets bits 21..16 in mailbox register #8, which we nominally 
 *	do not access at this time in the core driver. The caller is
 *	responsible for setting this register first (Gross!). The assumption
 *	is that we won't overflow.
 */

#ifndef		ISP_STRIPPED
static const char *fc_mbcmd_names[] = {
	"NO-OP",
	"LOAD RAM",
	"EXEC FIRMWARE",
	"DUMP RAM",
	"WRITE RAM WORD",
	"READ RAM WORD",
	"MAILBOX REG TEST",
	"VERIFY CHECKSUM",
	"ABOUT FIRMWARE",
	"LOAD RAM",
	"DUMP RAM",
	"WRITE RAM WORD EXTENDED",
	NULL,
	"READ RAM WORD EXTENDED",
	"CHECK FIRMWARE",
	NULL,
	"INIT REQUEST QUEUE",
	"INIT RESULT QUEUE",
	"EXECUTE IOCB",
	"WAKE UP",
	"STOP FIRMWARE",
	"ABORT",
	"ABORT DEVICE",
	"ABORT TARGET",
	"BUS RESET",
	"STOP QUEUE",
	"START QUEUE",
	"SINGLE STEP QUEUE",
	"ABORT QUEUE",
	"GET DEV QUEUE STATUS",
	NULL,
	"GET FIRMWARE STATUS",
	"GET LOOP ID",
	NULL,
	"GET RETRY COUNT",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"GET FIRMWARE OPTIONS",
	"GET PORT QUEUE PARAMS",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"SET RETRY COUNT",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"SET FIRMWARE OPTIONS",
	"SET PORT QUEUE PARAMS",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"LOOP PORT BYPASS",
	"LOOP PORT ENABLE",
	"GET RESOURCE COUNT",
	"REQUEST NON PARTICIPATING MODE",
	NULL,
	NULL,
	NULL,
	"GET PORT DATABASE ENHANCED",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"EXECUTE IOCB A64",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"DRIVER HEARTBEAT",
	NULL,
	"GET/SET DATA RATE",
	NULL,
	NULL,
	"INIT FIRMWARE",
	NULL,
	"INIT LIP",
	"GET FC-AL POSITION MAP",
	"GET PORT DATABASE",
	"CLEAR ACA",
	"TARGET RESET",
	"CLEAR TASK SET",
	"ABORT TASK SET",
	"GET FW STATE",
	"GET PORT NAME",
	"GET LINK STATUS",
	"INIT LIP RESET",
	NULL,
	"SEND SNS",
	"FABRIC LOGIN",
	"SEND CHANGE REQUEST",
	"FABRIC LOGOUT",
	"INIT LIP LOGIN",
	NULL,
	"LOGIN LOOP PORT",
	"GET PORT/NODE NAME LIST",
	"SET VENDOR ID",
	"INITIALIZE IP MAILBOX",
	NULL,
	NULL,
	NULL,
	NULL,
	"Get ID List",
	"SEND LFA",
	"Lun RESET"
};
#endif

void
isp_mboxcmd_qnw(struct ispsoftc *isp, mbreg_t *mbp, int nodelay)
{
	unsigned int ibits, obits, box, opcode;
	const u_int32_t *mcp;

	if (IS_FC(isp)) {
		mcp = mbpfc;
	} else {
		mcp = mbpscsi;
	}
	opcode = mbp->param[0];
	ibits = HIWRD(mcp[opcode]) & NMBOX_BMASK(isp);
	obits = LOWRD(mcp[opcode]) & NMBOX_BMASK(isp);
	ibits |= mbp->ibits;
	obits |= mbp->obits;
	for (box = 0; box < MAX_MAILBOX(isp); box++) {
		if (ibits & (1 << box)) {
			ISP_WRITE(isp, MBOX_OFF(box), mbp->param[box]);
		}
		if (nodelay == 0) {
			isp->isp_mboxtmp[box] = mbp->param[box] = 0;
		}
	}
	if (nodelay == 0) {
		isp->isp_lastmbxcmd = opcode;
		isp->isp_obits = obits;
		isp->isp_mboxbsy = 1;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);
	/*
	 * Oddly enough, if we're not delaying for an answer,
	 * delay a bit to give the f/w a chance to pick up the
	 * command.
	 */
	if (nodelay) {
		USEC_DELAY(1000);
	}
}

void
isp_mboxcmd(struct ispsoftc *isp, mbreg_t *mbp)
{
	const char *cname, *xname;
	char tname[16], mname[16];
	unsigned int lim, ibits, obits, box, opcode;
	const u_int32_t *mcp;

	if (IS_FC(isp)) {
		mcp = mbpfc;
		lim = (sizeof (mbpfc) / sizeof (mbpfc[0]));
	} else {
		mcp = mbpscsi;
		lim = (sizeof (mbpscsi) / sizeof (mbpscsi[0]));
	}

	if ((opcode = mbp->param[0]) >= lim) {
		mbp->param[0] = MBOX_INVALID_COMMAND;
		isp_prt(isp, ISP_LOGERR, "Unknown Command 0x%x", opcode);
		return;
	}

	ibits = HIWRD(mcp[opcode]) & NMBOX_BMASK(isp);
	obits = LOWRD(mcp[opcode]) & NMBOX_BMASK(isp);

	/*
	 * Pick up any additional bits that the caller might have set.
	 */
	ibits |= mbp->ibits;
	obits |= mbp->obits;

	if (ibits == 0 && obits == 0) {
		mbp->param[0] = MBOX_COMMAND_PARAM_ERROR;
		isp_prt(isp, ISP_LOGERR, "no parameters for 0x%x", opcode);
		return;
	}

	/*
	 * Get exclusive usage of mailbox registers.
	 */
	if (MBOX_ACQUIRE(isp)) {
		mbp->param[0] = MBOX_REGS_BUSY;
		goto out;
	}

	for (box = 0; box < MAX_MAILBOX(isp); box++) {
		if (ibits & (1 << box)) {
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG1, "IN mbox %d = 0x%04x", box,
			    mbp->param[box]);
#endif
			ISP_WRITE(isp, MBOX_OFF(box), mbp->param[box]);
		}
		isp->isp_mboxtmp[box] = mbp->param[box] = 0;
	}

	isp->isp_lastmbxcmd = opcode;

	/*
	 * We assume that we can't overwrite a previous command.
	 */
	isp->isp_obits = obits;
	isp->isp_mboxbsy = 1;

	/*
	 * Set Host Interrupt condition so that RISC will pick up mailbox regs.
	 */
	ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);

	/*
	 * While we haven't finished the command, spin our wheels here.
	 */
	MBOX_WAIT_COMPLETE(isp, mbp);

	/*
	 * Did the command time out?
	 */
	if (mbp->param[0] == MBOX_TIMEOUT) {
		MBOX_RELEASE(isp);
		goto out;
	}

	/*
	 * Copy back output registers.
	 */
	for (box = 0; box < MAX_MAILBOX(isp); box++) {
		if (obits & (1 << box)) {
			mbp->param[box] = isp->isp_mboxtmp[box];
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG1, "OUT mbox %d = 0x%04x", box,
			    mbp->param[box]);
#endif
		}
	}

	MBOX_RELEASE(isp);
 out:
	isp->isp_mboxbsy = 0;
	if (mbp->logval == 0 || opcode == MBOX_EXEC_FIRMWARE) {
		return;
	}
#ifdef ISP_STRIPPED
	cname = NULL;
#else
	cname = (IS_FC(isp))? fc_mbcmd_names[opcode] : scsi_mbcmd_names[opcode];
#endif
	if (cname == NULL) {
		cname = tname;
		SNPRINTF(tname, sizeof tname, "opcode %x", opcode);
	}

	/*
	 * Just to be chatty here...
	 */
	xname = NULL;
	switch (mbp->param[0]) {
	case MBOX_COMMAND_COMPLETE:
		break;
	case MBOX_INVALID_COMMAND:
		if (mbp->logval & MBLOGMASK(MBOX_COMMAND_COMPLETE)) {
			xname = "INVALID COMMAND";
		}
		break;
	case MBOX_HOST_INTERFACE_ERROR:
		if (mbp->logval & MBLOGMASK(MBOX_HOST_INTERFACE_ERROR)) {
			xname = "HOST INTERFACE ERROR";
		}
		break;
	case MBOX_TEST_FAILED:
		if (mbp->logval & MBLOGMASK(MBOX_TEST_FAILED)) {
			xname = "TEST FAILED";
		}
		break;
	case MBOX_COMMAND_ERROR:
		if (mbp->logval & MBLOGMASK(MBOX_COMMAND_ERROR)) {
			xname = "COMMAND ERROR";
		}
		break;
	case MBOX_COMMAND_PARAM_ERROR:
		if (mbp->logval & MBLOGMASK(MBOX_COMMAND_PARAM_ERROR)) {
			xname = "COMMAND PARAMETER ERROR";
		}
		break;
	case MBOX_LOOP_ID_USED:
		if (mbp->logval & MBLOGMASK(MBOX_LOOP_ID_USED)) {
			xname = "LOOP ID ALREADY IN USE";
		}
		break;
	case MBOX_PORT_ID_USED:
		if (mbp->logval & MBLOGMASK(MBOX_PORT_ID_USED)) {
			xname = "PORT ID ALREADY IN USE";
		}
		break;
	case MBOX_ALL_IDS_USED:
		if (mbp->logval & MBLOGMASK(MBOX_ALL_IDS_USED)) {
			xname = "ALL LOOP IDS IN USE";
		}
		break;
	case MBOX_REGS_BUSY:
		xname = "REGISTERS BUSY";
		break;
	case MBOX_TIMEOUT:
		xname = "TIMEOUT";
		break;
	default:
		SNPRINTF(mname, sizeof mname, "error 0x%x", mbp->param[0]);
		xname = mname;
		break;
	}
	if (xname) {
		isp_prt(isp, ISP_LOGALL, "Mailbox Command '%s' failed (%s)",
		    cname, xname);
	}
}

void
isp_fw_state(struct ispsoftc *isp)
{
	if (IS_FC(isp)) {
		mbreg_t mbs;
		fcparam *fcp = isp->isp_param;

		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_GET_FW_STATE;
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			fcp->isp_fwstate = mbs.param[1];
		}
	}
}

void
isp_update(struct ispsoftc *isp)
{
	int bus, upmask;

	for (bus = 0, upmask = isp->isp_update; upmask != 0; bus++) {
		if (upmask & (1 << bus)) {
			isp_update_bus(isp, bus);
		}
		upmask &= ~(1 << bus);
	}
}

void
isp_update_bus(struct ispsoftc *isp, int bus)
{
	int tgt;
	mbreg_t mbs;
	sdparam *sdp;

	isp->isp_update &= ~(1 << bus);
	if (IS_FC(isp)) {
		/*
		 * There are no 'per-bus' settings for Fibre Channel.
		 */
		return;
	}
	sdp = isp->isp_param;
	sdp += bus;

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		u_int16_t flags, period, offset;
		int get;

		if (sdp->isp_devparam[tgt].dev_enable == 0) {
			sdp->isp_devparam[tgt].dev_update = 0;
			sdp->isp_devparam[tgt].dev_refresh = 0;
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG0,
	 		    "skipping target %d bus %d update", tgt, bus);
#endif
			continue;
		}
		/*
		 * If the goal is to update the status of the device,
		 * take what's in goal_flags and try and set the device
		 * toward that. Otherwise, if we're just refreshing the
		 * current device state, get the current parameters.
		 */

		MEMZERO(&mbs, sizeof (mbs));

		/*
		 * Refresh overrides set
		 */
		if (sdp->isp_devparam[tgt].dev_refresh) {
			mbs.param[0] = MBOX_GET_TARGET_PARAMS;
			get = 1;
		} else if (sdp->isp_devparam[tgt].dev_update) {
			mbs.param[0] = MBOX_SET_TARGET_PARAMS;

			/*
			 * Make sure goal_flags has "Renegotiate on Error"
			 * on and "Freeze Queue on Error" off.
			 */
			sdp->isp_devparam[tgt].goal_flags |= DPARM_RENEG;
			sdp->isp_devparam[tgt].goal_flags &= ~DPARM_QFRZ;
			mbs.param[2] = sdp->isp_devparam[tgt].goal_flags;

			/*
			 * Insist that PARITY must be enabled
			 * if SYNC or WIDE is enabled.
			 */
			if ((mbs.param[2] & (DPARM_SYNC|DPARM_WIDE)) != 0) {
				mbs.param[2] |= DPARM_PARITY;
			}

			if (mbs.param[2] & DPARM_SYNC) {
				mbs.param[3] =
				    (sdp->isp_devparam[tgt].goal_offset << 8) |
				    (sdp->isp_devparam[tgt].goal_period);
			}
			/*
			 * A command completion later that has
			 * RQSTF_NEGOTIATION set can cause
			 * the dev_refresh/announce cycle also.
			 *
			 * Note: It is really important to update our current
			 * flags with at least the state of TAG capabilities-
			 * otherwise we might try and send a tagged command
			 * when we have it all turned off. So change it here
			 * to say that current already matches goal.
			 */
			sdp->isp_devparam[tgt].actv_flags &= ~DPARM_TQING;
			sdp->isp_devparam[tgt].actv_flags |=
			    (sdp->isp_devparam[tgt].goal_flags & DPARM_TQING);
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG0,
			    "bus %d set tgt %d flags 0x%x off 0x%x period 0x%x",
			    bus, tgt, mbs.param[2], mbs.param[3] >> 8,
			    mbs.param[3] & 0xff);
#endif
			get = 0;
		} else {
			continue;
		}
		mbs.param[1] = (bus << 15) | (tgt << 8);
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			continue;
		}
		if (get == 0) {
			isp->isp_sendmarker |= (1 << bus);
			sdp->isp_devparam[tgt].dev_update = 0;
			sdp->isp_devparam[tgt].dev_refresh = 1;
		} else {
			sdp->isp_devparam[tgt].dev_refresh = 0;
			flags = mbs.param[2];
			period = mbs.param[3] & 0xff;
			offset = mbs.param[3] >> 8;
			sdp->isp_devparam[tgt].actv_flags = flags;
			sdp->isp_devparam[tgt].actv_period = period;
			sdp->isp_devparam[tgt].actv_offset = offset;
			get = (bus << 16) | tgt;
			(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);
		}
	}

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		if (sdp->isp_devparam[tgt].dev_update ||
		    sdp->isp_devparam[tgt].dev_refresh) {
			isp->isp_update |= (1 << bus);
			break;
		}
	}
}

#ifndef	DEFAULT_EXEC_THROTTLE
#define	DEFAULT_EXEC_THROTTLE(isp)	ISP_EXEC_THROTTLE
#endif

void
isp_setdfltparm(struct ispsoftc *isp, int channel)
{
	int tgt;
	sdparam *sdp;

	sdp = (sdparam *) isp->isp_param;
	sdp += channel;

	/*
	 * Been there, done that, got the T-shirt...
	 */
	if (sdp->isp_gotdparms) {
		return;
	}
	sdp->isp_gotdparms = 1;
	sdp->isp_bad_nvram = 0;
	/*
	 * Establish some default parameters.
	 */
	sdp->isp_cmd_dma_burst_enable = 0;
	sdp->isp_data_dma_burst_enabl = 1;
	sdp->isp_fifo_threshold = 0;
	sdp->isp_initiator_id = DEFAULT_IID(isp);
	if (isp->isp_type >= ISP_HA_SCSI_1040) {
		sdp->isp_async_data_setup = 9;
	} else {
		sdp->isp_async_data_setup = 6;
	}
	sdp->isp_selection_timeout = 250;
	sdp->isp_max_queue_depth = MAXISPREQUEST(isp);
	sdp->isp_tag_aging = 8;
	sdp->isp_bus_reset_delay = 5;
	/*
	 * Don't retry selection, busy or queue full automatically- reflect
	 * these back to us.
	 */
	sdp->isp_retry_count = 0;
	sdp->isp_retry_delay = 0;

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		sdp->isp_devparam[tgt].exc_throttle = ISP_EXEC_THROTTLE;
		sdp->isp_devparam[tgt].dev_enable = 1;
	}

	/*
	 * If we've not been told to avoid reading NVRAM, try and read it.
	 * If we're successful reading it, we can then return because NVRAM
	 * will tell us what the desired settings are. Otherwise, we establish
	 * some reasonable 'fake' nvram and goal defaults.
	 */

	if ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {
		if (isp_read_nvram(isp) == 0) {
			return;
		}
		sdp->isp_bad_nvram = 1;
	}

	/*
	 * Now try and see whether we have specific values for them.
	 */
	if ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {
		mbreg_t mbs;

		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_GET_ACT_NEG_STATE;
		mbs.logval = MBLOGNONE;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			sdp->isp_req_ack_active_neg = 1;
			sdp->isp_data_line_active_neg = 1;
		} else {
			sdp->isp_req_ack_active_neg =
			    (mbs.param[1+channel] >> 4) & 0x1;
			sdp->isp_data_line_active_neg =
			    (mbs.param[1+channel] >> 5) & 0x1;
		}
	}

#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0, sc0, sc3,
	    0, sdp->isp_fifo_threshold, sdp->isp_initiator_id,
	    sdp->isp_bus_reset_delay, sdp->isp_retry_count,
	    sdp->isp_retry_delay, sdp->isp_async_data_setup);
	isp_prt(isp, ISP_LOGDEBUG0, sc1, sc3,
	    sdp->isp_req_ack_active_neg, sdp->isp_data_line_active_neg,
	    sdp->isp_data_dma_burst_enabl, sdp->isp_cmd_dma_burst_enable,
	    sdp->isp_selection_timeout, sdp->isp_max_queue_depth);
#endif

	/*
	 * The trick here is to establish a default for the default (honk!)
	 * state (goal_flags). Then try and get the current status from
	 * the card to fill in the current state. We don't, in fact, set
	 * the default to the SAFE default state- that's not the goal state.
	 */
	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		u_int8_t off, per;
		sdp->isp_devparam[tgt].actv_offset = 0;
		sdp->isp_devparam[tgt].actv_period = 0;
		sdp->isp_devparam[tgt].actv_flags = 0;

		sdp->isp_devparam[tgt].goal_flags =
		    sdp->isp_devparam[tgt].nvrm_flags = DPARM_DEFAULT;

		/*
		 * We default to Wide/Fast for versions less than a 1040
		 * (unless it's SBus).
		 */
		if (IS_ULTRA3(isp)) {
			off = ISP_80M_SYNCPARMS >> 8;
			per = ISP_80M_SYNCPARMS & 0xff;
		} else if (IS_ULTRA2(isp)) {
			off = ISP_40M_SYNCPARMS >> 8;
			per = ISP_40M_SYNCPARMS & 0xff;
		} else if (IS_1240(isp)) {
			off = ISP_20M_SYNCPARMS >> 8;
			per = ISP_20M_SYNCPARMS & 0xff;
		} else if ((isp->isp_bustype == ISP_BT_SBUS &&
		    isp->isp_type < ISP_HA_SCSI_1020A) ||
		    (isp->isp_bustype == ISP_BT_PCI &&
		    isp->isp_type < ISP_HA_SCSI_1040) ||
		    (isp->isp_clock && isp->isp_clock < 60) ||
		    (sdp->isp_ultramode == 0)) {
			off = ISP_10M_SYNCPARMS >> 8;
			per = ISP_10M_SYNCPARMS & 0xff;
		} else {
			off = ISP_20M_SYNCPARMS_1040 >> 8;
			per = ISP_20M_SYNCPARMS_1040 & 0xff;
		}
		sdp->isp_devparam[tgt].goal_offset =
		    sdp->isp_devparam[tgt].nvrm_offset = off;
		sdp->isp_devparam[tgt].goal_period =
		    sdp->isp_devparam[tgt].nvrm_period = per;

#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, sc2, sc3,
		    channel, tgt, sdp->isp_devparam[tgt].nvrm_flags,
		    sdp->isp_devparam[tgt].nvrm_offset,
		    sdp->isp_devparam[tgt].nvrm_period);
#endif
	}
}

#ifndef	DEFAULT_FRAMESIZE
#define	DEFAULT_FRAMESIZE(isp)		ICB_DFLT_FRMLEN
#endif
void
isp_setdfltfcparm(struct ispsoftc *isp)
{
	fcparam *fcp = FCPARAM(isp);

	if (fcp->isp_gotdparms) {
		return;
	}
	fcp->isp_gotdparms = 1;
	fcp->isp_bad_nvram = 0;
	fcp->isp_maxfrmlen = DEFAULT_FRAMESIZE(isp);
	fcp->isp_maxalloc = ICB_DFLT_ALLOC;
	fcp->isp_execthrottle = DEFAULT_EXEC_THROTTLE(isp);
	fcp->isp_retry_delay = ICB_DFLT_RDELAY;
	fcp->isp_retry_count = ICB_DFLT_RCOUNT;
	/* Platform specific.... */
	fcp->isp_loopid = DEFAULT_LOOPID(isp);
	fcp->isp_wwnn_nvram = DEFAULT_NODEWWN(isp);
	fcp->isp_wwpn_nvram = DEFAULT_PORTWWN(isp);
	fcp->isp_fwoptions = 0;
	fcp->isp_fwoptions |= ICBOPT_FAIRNESS;
	fcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;
	fcp->isp_fwoptions |= ICBOPT_HARD_ADDRESS;
	fcp->isp_fwoptions |= ICBOPT_FAST_POST;
	if (isp->isp_confopts & ISP_CFG_FULL_DUPLEX) {
		fcp->isp_fwoptions |= ICBOPT_FULL_DUPLEX;
	}

	/*
	 * Make sure this is turned off now until we get
	 * extended options from NVRAM
	 */
	fcp->isp_fwoptions &= ~ICBOPT_EXTENDED;

	/*
	 * Now try and read NVRAM unless told to not do so.
	 * This will set fcparam's isp_wwnn_nvram && isp_wwpn_nvram.
	 */
	if ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {
		int i, j = 0;
		/*
		 * Give a couple of tries at reading NVRAM.
		 */
		for (i = 0; i < 2; i++) {
			j = isp_read_nvram(isp);
			if (j == 0) {
				break;
			}
		}
		if (j) {
			fcp->isp_bad_nvram = 1;
			isp->isp_confopts |= ISP_CFG_NONVRAM;
			isp->isp_confopts |= ISP_CFG_OWNWWPN;
			isp->isp_confopts |= ISP_CFG_OWNWWNN;
		}
	} else {
		isp->isp_confopts |= ISP_CFG_OWNWWPN|ISP_CFG_OWNWWNN;
	}

	/*
	 * Set node && port to override platform set defaults
	 * unless the nvram read failed (or none was done),
	 * or the platform code wants to use what had been
	 * set in the defaults.
	 */
	if (isp->isp_confopts & ISP_CFG_OWNWWNN) {
		isp_prt(isp, ISP_LOGCONFIG, "Using Node WWN 0x%08x%08x",
		    (u_int32_t) (DEFAULT_NODEWWN(isp) >> 32),
		    (u_int32_t) (DEFAULT_NODEWWN(isp) & 0xffffffff));
		ISP_NODEWWN(isp) = DEFAULT_NODEWWN(isp);
	} else {
		/*
		 * We always start out with values derived
		 * from NVRAM or our platform default.
		 */
		ISP_NODEWWN(isp) = fcp->isp_wwnn_nvram;
		if (fcp->isp_wwnn_nvram == 0) {
			isp_prt(isp, ISP_LOGCONFIG,
			    "bad WWNN- using default");
			ISP_NODEWWN(isp) = DEFAULT_NODEWWN(isp);
		}
	}
	if (isp->isp_confopts & ISP_CFG_OWNWWPN) {
		isp_prt(isp, ISP_LOGCONFIG, "Using Port WWN 0x%08x%08x",
		    (u_int32_t) (DEFAULT_PORTWWN(isp) >> 32),
		    (u_int32_t) (DEFAULT_PORTWWN(isp) & 0xffffffff));
		ISP_PORTWWN(isp) = DEFAULT_PORTWWN(isp);
	} else {
		/*
		 * We always start out with values derived
		 * from NVRAM or our platform default.
		 */
		ISP_PORTWWN(isp) = fcp->isp_wwpn_nvram;
		if (fcp->isp_wwpn_nvram == 0) {
			isp_prt(isp, ISP_LOGCONFIG,
			    "bad WWPN- using default");
			ISP_PORTWWN(isp) = DEFAULT_PORTWWN(isp);
		}
	}
}

/*
 * Re-initialize the ISP and complete all orphaned commands
 * with a 'botched' notice. The reset/init routines should
 * not disturb an already active list of commands.
 */

void
isp_reinit(struct ispsoftc *isp)
{
	XS_T *xs;
	u_int32_t tmp;

	if (IS_FC(isp)) {
		ISP_MARK_PORTDB(isp, 0);
	}
	isp_reset(isp);
	if (isp->isp_state != ISP_RESETSTATE) {
		isp_prt(isp, ISP_LOGERR, "isp_reinit cannot reset card");
	} else if (isp->isp_role != ISP_ROLE_NONE) {
		isp_init(isp);
		if (isp->isp_state == ISP_INITSTATE) {
			isp->isp_state = ISP_RUNSTATE;
		}
		if (isp->isp_state != ISP_RUNSTATE) {
			isp_prt(isp, ISP_LOGERR,
			    "isp_reinit cannot restart card");
			ISP_DISABLE_INTS(isp);
		}
	} else {
		ISP_DISABLE_INTS(isp);
		if (IS_FC(isp)) {
			/*
			 * If we're in ISP_ROLE_NONE, turn off the lasers.
			 */
			if (!IS_24XX(isp)) {
				ISP_WRITE(isp, BIU2100_CSR, BIU2100_FPM0_REGS);
				ISP_WRITE(isp, FPM_DIAG_CONFIG, FPM_SOFT_RESET);
				ISP_WRITE(isp, BIU2100_CSR, BIU2100_FB_REGS);
				ISP_WRITE(isp, FBM_CMD, FBMCMD_FIFO_RESET_ALL);
				ISP_WRITE(isp, BIU2100_CSR, BIU2100_RISC_REGS);
			}
		}
 	}
	isp->isp_nactive = 0;

	for (tmp = 0; tmp < isp->isp_maxcmds; tmp++) {
		u_int32_t handle;

		xs = isp->isp_xflist[tmp];
		if (xs == NULL) {
			continue;
		}
		handle = isp_find_handle(isp, xs);
		if (handle == 0) {
			continue;
		}
		isp_destroy_handle(isp, handle);
		if (XS_XFRLEN(xs)) {
			ISP_DMAFREE(isp, xs, handle);
			XS_RESID(xs) = XS_XFRLEN(xs);
		} else {
			XS_RESID(xs) = 0;
		}
		XS_SETERR(xs, HBA_BUSRESET);
		isp_done(xs);
	}
#ifdef	ISP_TARGET_MODE
	MEMZERO(isp->isp_tgtlist, isp->isp_maxcmds * sizeof (void **));
#endif
}

/*
 * NVRAM Routines
 */
int
isp_read_nvram(struct ispsoftc *isp)
{
	int i, amt, retval;
	u_int8_t csum, minversion;
	union {
		u_int8_t _x[ISP2100_NVRAM_SIZE];
		u_int16_t _s[ISP2100_NVRAM_SIZE>>1];
	} _n;
#define	nvram_data	_n._x
#define	nvram_words	_n._s

	if (IS_FC(isp)) {
		amt = ISP2100_NVRAM_SIZE;
		minversion = 1;
	} else if (IS_ULTRA2(isp)) {
		amt = ISP1080_NVRAM_SIZE;
		minversion = 0;
	} else {
		amt = ISP_NVRAM_SIZE;
		minversion = 2;
	}

	for (i = 0; i < amt>>1; i++) {
		isp_rdnvram_word(isp, i, &nvram_words[i]);
	}

	if (nvram_data[0] != 'I' || nvram_data[1] != 'S' ||
	    nvram_data[2] != 'P') {
		if (isp->isp_bustype != ISP_BT_SBUS) {
			if (nvram_data[0] != 0 || nvram_data[1] != 0 ||
			    nvram_data[2] != 0)
				isp_prt(isp, ISP_LOGWARN,
				    "invalid NVRAM header");
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG0, "%x %x %x",
			    nvram_data[0], nvram_data[1], nvram_data[2]);
#endif
		}
		retval = -1;
		goto out;
	}

	for (csum = 0, i = 0; i < amt; i++) {
		csum += nvram_data[i];
	}
	if (csum != 0) {
		isp_prt(isp, ISP_LOGWARN, "invalid NVRAM checksum");
		retval = -1;
		goto out;
	}

	if (ISP_NVRAM_VERSION(nvram_data) < minversion) {
		isp_prt(isp, ISP_LOGWARN, "version %d NVRAM not understood",
		    ISP_NVRAM_VERSION(nvram_data));
		retval = -1;
		goto out;
	}

	if (IS_ULTRA3(isp)) {
		isp_parse_nvram_12160(isp, 0, nvram_data);
		if (IS_12160(isp))
			isp_parse_nvram_12160(isp, 1, nvram_data);
	} else if (IS_1080(isp)) {
		isp_parse_nvram_1080(isp, 0, nvram_data);
	} else if (IS_1280(isp) || IS_1240(isp)) {
		isp_parse_nvram_1080(isp, 0, nvram_data);
		isp_parse_nvram_1080(isp, 1, nvram_data);
	} else if (IS_SCSI(isp)) {
		isp_parse_nvram_1020(isp, nvram_data);
	} else {
		isp_parse_nvram_2100(isp, nvram_data);
	}
	retval = 0;
out:
	return (retval);
#undef	nvram_data
#undef	nvram_words
}

void
isp_rdnvram_word(struct ispsoftc *isp, int wo, u_int16_t *rp)
{
	int i, cbits;
	u_int16_t bit, rqst, junk;

	ISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);
	USEC_DELAY(10);
	ISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);
	USEC_DELAY(10);

	if (IS_FC(isp)) {
		wo &= ((ISP2100_NVRAM_SIZE >> 1) - 1); 
		if (IS_2312(isp) && isp->isp_port) {
			wo += 128;
		}
		rqst = (ISP_NVRAM_READ << 8) | wo;
		cbits = 10;
	} else if (IS_ULTRA2(isp)) {
		wo &= ((ISP1080_NVRAM_SIZE >> 1) - 1);
		rqst = (ISP_NVRAM_READ << 8) | wo;
		cbits = 10;
	} else {
		wo &= ((ISP_NVRAM_SIZE >> 1) - 1);
		rqst = (ISP_NVRAM_READ << 6) | wo;
		cbits = 8;
	}

	/*
	 * Clock the word select request out...
	 */
	for (i = cbits; i >= 0; i--) {
		if ((rqst >> i) & 1) {
			bit = BIU_NVRAM_SELECT | BIU_NVRAM_DATAOUT;
		} else {
			bit = BIU_NVRAM_SELECT;
		}
		ISP_WRITE(isp, BIU_NVRAM, bit);
		USEC_DELAY(10);
		junk = ISP_READ(isp, BIU_NVRAM);	/* force PCI flush */
		ISP_WRITE(isp, BIU_NVRAM, bit | BIU_NVRAM_CLOCK);
		USEC_DELAY(10);
		junk = ISP_READ(isp, BIU_NVRAM);	/* force PCI flush */
		ISP_WRITE(isp, BIU_NVRAM, bit);
		USEC_DELAY(10);
		junk = ISP_READ(isp, BIU_NVRAM);	/* force PCI flush */
	}
	/*
	 * Now read the result back in (bits come back in MSB format).
	 */
	*rp = 0;
	for (i = 0; i < 16; i++) {
		u_int16_t rv;
		*rp <<= 1;
		ISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);
		USEC_DELAY(10);
		rv = ISP_READ(isp, BIU_NVRAM);
		if (rv & BIU_NVRAM_DATAIN) {
			*rp |= 1;
		}
		USEC_DELAY(10);
		ISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);
		USEC_DELAY(10);
		junk = ISP_READ(isp, BIU_NVRAM);	/* force PCI flush */
	}
	ISP_WRITE(isp, BIU_NVRAM, 0);
	USEC_DELAY(10);
	junk = ISP_READ(isp, BIU_NVRAM);	/* force PCI flush */
	ISP_SWIZZLE_NVRAM_WORD(isp, rp);
}

void
isp_parse_nvram_1020(struct ispsoftc *isp, u_int8_t *nvram_data)
{
	sdparam *sdp = (sdparam *) isp->isp_param;
	int tgt;

	sdp->isp_fifo_threshold =
		ISP_NVRAM_FIFO_THRESHOLD(nvram_data) |
		(ISP_NVRAM_FIFO_THRESHOLD_128(nvram_data) << 2);

	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		sdp->isp_initiator_id =
			ISP_NVRAM_INITIATOR_ID(nvram_data);

	sdp->isp_bus_reset_delay =
		ISP_NVRAM_BUS_RESET_DELAY(nvram_data);

	sdp->isp_retry_count =
		ISP_NVRAM_BUS_RETRY_COUNT(nvram_data);

	sdp->isp_retry_delay =
		ISP_NVRAM_BUS_RETRY_DELAY(nvram_data);

	sdp->isp_async_data_setup =
		ISP_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data);

	if (isp->isp_type >= ISP_HA_SCSI_1040) {
		if (sdp->isp_async_data_setup < 9) {
			sdp->isp_async_data_setup = 9;
		}
	} else {
		if (sdp->isp_async_data_setup != 6) {
			sdp->isp_async_data_setup = 6;
		}
	}

	sdp->isp_req_ack_active_neg =
		ISP_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data);

	sdp->isp_data_line_active_neg =
		ISP_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data);

	sdp->isp_data_dma_burst_enabl =
		ISP_NVRAM_DATA_DMA_BURST_ENABLE(nvram_data);

	sdp->isp_cmd_dma_burst_enable =
		ISP_NVRAM_CMD_DMA_BURST_ENABLE(nvram_data);

	sdp->isp_tag_aging =
		ISP_NVRAM_TAG_AGE_LIMIT(nvram_data);

	sdp->isp_selection_timeout =
		ISP_NVRAM_SELECTION_TIMEOUT(nvram_data);

	sdp->isp_max_queue_depth =
		ISP_NVRAM_MAX_QUEUE_DEPTH(nvram_data);

	sdp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);

#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0, sc0, sc4,
	    0, sdp->isp_fifo_threshold, sdp->isp_initiator_id,
	    sdp->isp_bus_reset_delay, sdp->isp_retry_count,
	    sdp->isp_retry_delay, sdp->isp_async_data_setup);
	isp_prt(isp, ISP_LOGDEBUG0, sc1, sc4,
	    sdp->isp_req_ack_active_neg, sdp->isp_data_line_active_neg,
	    sdp->isp_data_dma_burst_enabl, sdp->isp_cmd_dma_burst_enable,
	    sdp->isp_selection_timeout, sdp->isp_max_queue_depth);
#endif

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		sdp->isp_devparam[tgt].dev_enable =
			ISP_NVRAM_TGT_DEVICE_ENABLE(nvram_data, tgt);
		sdp->isp_devparam[tgt].exc_throttle =
			ISP_NVRAM_TGT_EXEC_THROTTLE(nvram_data, tgt);
		sdp->isp_devparam[tgt].nvrm_offset =
			ISP_NVRAM_TGT_SYNC_OFFSET(nvram_data, tgt);
		sdp->isp_devparam[tgt].nvrm_period =
			ISP_NVRAM_TGT_SYNC_PERIOD(nvram_data, tgt);
		/*
		 * We probably shouldn't lie about this, but it
		 * it makes it much safer if we limit NVRAM values
		 * to sanity.
		 */
		if (isp->isp_type < ISP_HA_SCSI_1040) {
			/*
			 * If we're not ultra, we can't possibly
			 * be a shorter period than this.
			 */
			if (sdp->isp_devparam[tgt].nvrm_period < 0x19) {
				sdp->isp_devparam[tgt].nvrm_period = 0x19;
			}
			if (sdp->isp_devparam[tgt].nvrm_offset > 0xc) {
				sdp->isp_devparam[tgt].nvrm_offset = 0x0c;
			}
		} else {
			if (sdp->isp_devparam[tgt].nvrm_offset > 0x8) {
				sdp->isp_devparam[tgt].nvrm_offset = 0x8;
			}
		}
		sdp->isp_devparam[tgt].nvrm_flags = 0;
		if (ISP_NVRAM_TGT_RENEG(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_RENEG;
		sdp->isp_devparam[tgt].nvrm_flags |= DPARM_ARQ;
		if (ISP_NVRAM_TGT_TQING(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_TQING;
		if (ISP_NVRAM_TGT_SYNC(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_SYNC;
		if (ISP_NVRAM_TGT_WIDE(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_WIDE;
		if (ISP_NVRAM_TGT_PARITY(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_PARITY;
		if (ISP_NVRAM_TGT_DISC(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_DISC;
		sdp->isp_devparam[tgt].actv_flags = 0; /* we don't know */
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, sc2, sc4,
		    0, tgt, sdp->isp_devparam[tgt].nvrm_flags,
		    sdp->isp_devparam[tgt].nvrm_offset,
		    sdp->isp_devparam[tgt].nvrm_period);
#endif
		sdp->isp_devparam[tgt].goal_offset =
		    sdp->isp_devparam[tgt].nvrm_offset;
		sdp->isp_devparam[tgt].goal_period =
		    sdp->isp_devparam[tgt].nvrm_period;
		sdp->isp_devparam[tgt].goal_flags =
		    sdp->isp_devparam[tgt].nvrm_flags;
	}
}

void
isp_parse_nvram_1080(struct ispsoftc *isp, int bus, u_int8_t *nvram_data)
{
	sdparam *sdp = (sdparam *) isp->isp_param;
	int tgt;

	sdp += bus;

	sdp->isp_fifo_threshold =
	    ISP1080_NVRAM_FIFO_THRESHOLD(nvram_data);

	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		sdp->isp_initiator_id =
		    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);

	sdp->isp_bus_reset_delay =
	    ISP1080_NVRAM_BUS_RESET_DELAY(nvram_data, bus);

	sdp->isp_retry_count =
	    ISP1080_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);

	sdp->isp_retry_delay =
	    ISP1080_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);

	sdp->isp_async_data_setup =
	    ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data, bus);

	sdp->isp_req_ack_active_neg =
	    ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data, bus);

	sdp->isp_data_line_active_neg =
	    ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data, bus);

	sdp->isp_data_dma_burst_enabl =
	    ISP1080_NVRAM_BURST_ENABLE(nvram_data);

	sdp->isp_cmd_dma_burst_enable =
	    ISP1080_NVRAM_BURST_ENABLE(nvram_data);

	sdp->isp_selection_timeout =
	    ISP1080_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);

	sdp->isp_max_queue_depth =
	     ISP1080_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);

#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0, sc0, sc4,
	    bus, sdp->isp_fifo_threshold, sdp->isp_initiator_id,
	    sdp->isp_bus_reset_delay, sdp->isp_retry_count,
	    sdp->isp_retry_delay, sdp->isp_async_data_setup);
	isp_prt(isp, ISP_LOGDEBUG0, sc1, sc4,
	    sdp->isp_req_ack_active_neg, sdp->isp_data_line_active_neg,
	    sdp->isp_data_dma_burst_enabl, sdp->isp_cmd_dma_burst_enable,
	    sdp->isp_selection_timeout, sdp->isp_max_queue_depth);
#endif


	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		sdp->isp_devparam[tgt].dev_enable =
		    ISP1080_NVRAM_TGT_DEVICE_ENABLE(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].exc_throttle =
			ISP1080_NVRAM_TGT_EXEC_THROTTLE(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_offset =
			ISP1080_NVRAM_TGT_SYNC_OFFSET(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_period =
			ISP1080_NVRAM_TGT_SYNC_PERIOD(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_flags = 0;
		if (ISP1080_NVRAM_TGT_RENEG(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_RENEG;
		sdp->isp_devparam[tgt].nvrm_flags |= DPARM_ARQ;
		if (ISP1080_NVRAM_TGT_TQING(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_TQING;
		if (ISP1080_NVRAM_TGT_SYNC(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_SYNC;
		if (ISP1080_NVRAM_TGT_WIDE(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_WIDE;
		if (ISP1080_NVRAM_TGT_PARITY(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_PARITY;
		if (ISP1080_NVRAM_TGT_DISC(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_DISC;
		sdp->isp_devparam[tgt].actv_flags = 0;
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, sc2, sc4,
		    bus, tgt, sdp->isp_devparam[tgt].nvrm_flags,
		    sdp->isp_devparam[tgt].nvrm_offset,
		    sdp->isp_devparam[tgt].nvrm_period);
#endif
		sdp->isp_devparam[tgt].goal_offset =
		    sdp->isp_devparam[tgt].nvrm_offset;
		sdp->isp_devparam[tgt].goal_period =
		    sdp->isp_devparam[tgt].nvrm_period;
		sdp->isp_devparam[tgt].goal_flags =
		    sdp->isp_devparam[tgt].nvrm_flags;
	}
}

void
isp_parse_nvram_12160(struct ispsoftc *isp, int bus, u_int8_t *nvram_data)
{
	sdparam *sdp = (sdparam *) isp->isp_param;
	int tgt;

	sdp += bus;

	sdp->isp_fifo_threshold =
	    ISP12160_NVRAM_FIFO_THRESHOLD(nvram_data);

	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		sdp->isp_initiator_id =
		    ISP12160_NVRAM_INITIATOR_ID(nvram_data, bus);

	sdp->isp_bus_reset_delay =
	    ISP12160_NVRAM_BUS_RESET_DELAY(nvram_data, bus);

	sdp->isp_retry_count =
	    ISP12160_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);

	sdp->isp_retry_delay =
	    ISP12160_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);

	sdp->isp_async_data_setup =
	    ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data, bus);

	sdp->isp_req_ack_active_neg =
	    ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data, bus);

	sdp->isp_data_line_active_neg =
	    ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data, bus);

	sdp->isp_data_dma_burst_enabl =
	    ISP12160_NVRAM_BURST_ENABLE(nvram_data);

	sdp->isp_cmd_dma_burst_enable =
	    ISP12160_NVRAM_BURST_ENABLE(nvram_data);

	sdp->isp_selection_timeout =
	    ISP12160_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);

	sdp->isp_max_queue_depth =
	     ISP12160_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);

#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0, sc0, sc4,
	    bus, sdp->isp_fifo_threshold, sdp->isp_initiator_id,
	    sdp->isp_bus_reset_delay, sdp->isp_retry_count,
	    sdp->isp_retry_delay, sdp->isp_async_data_setup);
	isp_prt(isp, ISP_LOGDEBUG0, sc1, sc4,
	    sdp->isp_req_ack_active_neg, sdp->isp_data_line_active_neg,
	    sdp->isp_data_dma_burst_enabl, sdp->isp_cmd_dma_burst_enable,
	    sdp->isp_selection_timeout, sdp->isp_max_queue_depth);
#endif

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		sdp->isp_devparam[tgt].dev_enable =
		    ISP12160_NVRAM_TGT_DEVICE_ENABLE(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].exc_throttle =
			ISP12160_NVRAM_TGT_EXEC_THROTTLE(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_offset =
			ISP12160_NVRAM_TGT_SYNC_OFFSET(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_period =
			ISP12160_NVRAM_TGT_SYNC_PERIOD(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_flags = 0;
		if (ISP12160_NVRAM_TGT_RENEG(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_RENEG;
		sdp->isp_devparam[tgt].nvrm_flags |= DPARM_ARQ;
		if (ISP12160_NVRAM_TGT_TQING(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_TQING;
		if (ISP12160_NVRAM_TGT_SYNC(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_SYNC;
		if (ISP12160_NVRAM_TGT_WIDE(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_WIDE;
		if (ISP12160_NVRAM_TGT_PARITY(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_PARITY;
		if (ISP12160_NVRAM_TGT_DISC(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_DISC;
		sdp->isp_devparam[tgt].actv_flags = 0;
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, sc2, sc4,
		    bus, tgt, sdp->isp_devparam[tgt].nvrm_flags,
		    sdp->isp_devparam[tgt].nvrm_offset,
		    sdp->isp_devparam[tgt].nvrm_period);
#endif
		sdp->isp_devparam[tgt].goal_offset =
		    sdp->isp_devparam[tgt].nvrm_offset;
		sdp->isp_devparam[tgt].goal_period =
		    sdp->isp_devparam[tgt].nvrm_period;
		sdp->isp_devparam[tgt].goal_flags =
		    sdp->isp_devparam[tgt].nvrm_flags;
	}
}

void
isp_fix_nvram_wwns(struct ispsoftc *isp)
{
	fcparam *fcp = FCPARAM(isp);

	/*
	 * Make sure we have both Node and Port as non-zero values.
	 */
	if (fcp->isp_wwnn_nvram != 0 && fcp->isp_wwpn_nvram == 0) {
		fcp->isp_wwpn_nvram = fcp->isp_wwnn_nvram;
	} else if (fcp->isp_wwnn_nvram == 0 && fcp->isp_wwpn_nvram != 0) {
		fcp->isp_wwnn_nvram = fcp->isp_wwpn_nvram;
	}

	/*
	 * Make the Node and Port values sane if they're NAA == 2.
	 * This means to clear bits 48..56 for the Node WWN and
	 * make sure that there's some non-zero value in 48..56
	 * for the Port WWN.
	 */
	if (fcp->isp_wwnn_nvram && fcp->isp_wwpn_nvram) {
		if ((fcp->isp_wwnn_nvram & (((u_int64_t) 0xfff) << 48)) != 0 &&
		    (fcp->isp_wwnn_nvram >> 60) == 2) {
			fcp->isp_wwnn_nvram &= ~((u_int64_t) 0xfff << 48);
		}
		if ((fcp->isp_wwpn_nvram & (((u_int64_t) 0xfff) << 48)) == 0 &&
		    (fcp->isp_wwpn_nvram >> 60) == 2) {
			fcp->isp_wwpn_nvram |= ((u_int64_t) 1 << 56);
		}
	}
}

void
isp_parse_nvram_2100(struct ispsoftc *isp, u_int8_t *nvram_data)
{
	fcparam *fcp = FCPARAM(isp);
	u_int64_t wwn;

	/*
	 * There is NVRAM storage for both Port and Node entities-
	 * but the Node entity appears to be unused on all the cards
	 * I can find. However, we should account for this being set
	 * at some point in the future.
	 *
	 * QLogic WWNs have an NAA of 2, but usually nothing shows up in
	 * bits 48..60. In the case of the 2202, it appears that they do
	 * use bit 48 to distinguish between the two instances on the card.
	 * The 2204, which I've never seen, *probably* extends this method.
	 */
	wwn = ISP2100_NVRAM_PORT_NAME(nvram_data);
	if (wwn) {
		isp_prt(isp, ISP_LOGCONFIG, "NVRAM Port WWN 0x%08x%08x",
		    (u_int32_t) (wwn >> 32), (u_int32_t) (wwn & 0xffffffff));
		if ((wwn >> 60) == 0) {
			wwn |= (((u_int64_t) 2)<< 60);
		}
	}
	fcp->isp_wwpn_nvram = wwn;
	if (IS_2200(isp) || IS_23XX(isp)) {
		wwn = ISP2100_NVRAM_NODE_NAME(nvram_data);
		if (wwn) {
			isp_prt(isp, ISP_LOGCONFIG, "NVRAM Node WWN 0x%08x%08x",
			    (u_int32_t) (wwn >> 32),
			    (u_int32_t) (wwn & 0xffffffff));
			if ((wwn >> 60) == 0) {
				wwn |= (((u_int64_t) 2)<< 60);
			}
		}
	} else {
		wwn &= ~((u_int64_t) 0xfff << 48);
	}
	fcp->isp_wwnn_nvram = wwn;

	isp_fix_nvram_wwns(isp);

	fcp->isp_maxalloc = ISP2100_NVRAM_MAXIOCBALLOCATION(nvram_data);
	if ((isp->isp_confopts & ISP_CFG_OWNFSZ) == 0) {
		fcp->isp_maxfrmlen = ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);
	}
	fcp->isp_retry_delay = ISP2100_NVRAM_RETRY_DELAY(nvram_data);
	fcp->isp_retry_count = ISP2100_NVRAM_RETRY_COUNT(nvram_data);
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0) {
		fcp->isp_loopid = ISP2100_NVRAM_HARDLOOPID(nvram_data);
	}
	if ((isp->isp_confopts & ISP_CFG_OWNEXCTHROTTLE) == 0) {
		fcp->isp_execthrottle =
			ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);
	}
	fcp->isp_fwoptions = ISP2100_NVRAM_OPTIONS(nvram_data);
#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0,
	    "NVRAM 0x%08x%08x 0x%08x%08x maxalloc %d maxframelen %d",
	    (u_int32_t) (fcp->isp_wwnn_nvram >> 32), (u_int32_t) fcp->isp_wwnn_nvram,
	    (u_int32_t) (fcp->isp_wwpn_nvram >> 32), (u_int32_t) fcp->isp_wwpn_nvram,
	    ISP2100_NVRAM_MAXIOCBALLOCATION(nvram_data),
	    ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data));
	isp_prt(isp, ISP_LOGDEBUG0,
	    "execthrottle %d fwoptions 0x%x hardloop %d tov %d",
	    ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data),
	    ISP2100_NVRAM_OPTIONS(nvram_data),
	    ISP2100_NVRAM_HARDLOOPID(nvram_data),
	    ISP2100_NVRAM_TOV(nvram_data));
#endif
	fcp->isp_xfwoptions = ISP2100_XFW_OPTIONS(nvram_data);
	fcp->isp_zfwoptions = ISP2100_ZFW_OPTIONS(nvram_data);
#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0,
	    "xfwoptions 0x%x zfw options 0x%x",
	    ISP2100_XFW_OPTIONS(nvram_data), ISP2100_ZFW_OPTIONS(nvram_data));
#endif
}

#ifdef	ISP_FW_CRASH_DUMP
void isp2200_fw_dump(struct ispsoftc *);
void isp2300_fw_dump(struct ispsoftc *);

void
isp2200_fw_dump(struct ispsoftc *isp)
{
	int i, j;
	mbreg_t mbs;
	u_int16_t *ptr;

	MEMZERO(&mbs, sizeof (mbs));
	ptr = FCPARAM(isp)->isp_dump_data;
	if (ptr == NULL) {
		isp_prt(isp, ISP_LOGERR,
		   "No place to dump RISC registers and SRAM");
		return;
	}
	if (*ptr++) {
		isp_prt(isp, ISP_LOGERR,
		   "dump area for RISC registers and SRAM already used");
		return;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
			break;
		}
	}
	if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
		/*
		 * PBIU Registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + (i << 1));
		}

		/*
		 * Mailbox Registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, MBOX_BLOCK + (i << 1));
		}

		/*
		 * DMA Registers
		 */
		for (i = 0; i < 48; i++) {
			*ptr++ = ISP_READ(isp, DMA_BLOCK + 0x20 + (i << 1));
		}

		/*
		 * RISC H/W Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0);
		for (i = 0; i < 16; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0xA0 + (i << 1));
		}

		/*
		 * RISC GP Registers
		 */
		for (j = 0; j < 8; j++) {
			ISP_WRITE(isp, BIU_BLOCK + 0xA4, 0x2000 + (j << 8));
			for (i = 0; i < 16; i++) {
				*ptr++ =
				    ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
			}
		}

		/*
		 * Frame Buffer Hardware Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x10);
		for (i = 0; i < 16; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * Fibre Protocol Module 0 Hardware Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x20);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * Fibre Protocol Module 1 Hardware Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x30);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}
	} else {
		isp_prt(isp, ISP_LOGERR, "RISC Would Not Pause");
		return;
	}
	isp_prt(isp, ISP_LOGALL,
	   "isp_fw_dump: RISC registers dumped successfully");
	ISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, OUTMAILBOX0) == 0) {
			break;
		}
	}
	if (ISP_READ(isp, OUTMAILBOX0) != 0) {
		isp_prt(isp, ISP_LOGERR, "Board Would Not Reset");
		return;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
			break;
		}
	}
	if ((ISP_READ(isp, HCCR) & HCCR_PAUSE) == 0) {
		isp_prt(isp, ISP_LOGERR, "RISC Would Not Pause After Reset");
		return;
	}
	ISP_WRITE(isp, RISC_EMB, 0xf2);
	ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if ((ISP_READ(isp, HCCR) & HCCR_PAUSE) == 0) {
			break;
		}
	}
	ISP_ENABLE_INTS(isp);
	mbs.param[0] = MBOX_READ_RAM_WORD;
	mbs.param[1] = 0x1000;
	isp->isp_mbxworkp = (void *) ptr;
	isp->isp_mbxwrk0 = 0xefff;	/* continuation count */
	isp->isp_mbxwrk1 = 0x1001;	/* next SRAM address */
	isp_control(isp, ISPCTL_RUN_MBOXCMD, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGWARN,
		    "RAM DUMP FAILED @@ WORD %x", isp->isp_mbxwrk1);
		return;
	}
	ptr = isp->isp_mbxworkp;	/* finish fetch of final word */
	*ptr++ = isp->isp_mboxtmp[2];
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped successfully");
	FCPARAM(isp)->isp_dump_data[0] = isp->isp_type; /* now used */
	(void) isp_async(isp, ISPASYNC_FW_DUMPED, 0);
}

void
isp2300_fw_dump(struct ispsoftc *isp)
{
	int i, j;
	mbreg_t mbs;
	u_int16_t *ptr;

	MEMZERO(&mbs, sizeof (mbs));
	ptr = FCPARAM(isp)->isp_dump_data;
	if (ptr == NULL) {
		isp_prt(isp, ISP_LOGERR,
		   "No place to dump RISC registers and SRAM");
		return;
	}
	if (*ptr++) {
		isp_prt(isp, ISP_LOGERR,
		   "dump area for RISC registers and SRAM already used");
		return;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
			break;
		}
	}
	if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
		/*
		 * PBIU registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + (i << 1));
		}

		/*
		 * ReqQ-RspQ-Risc2Host Status registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x10 + (i << 1));
		}

		/*
		 * Mailbox Registers
		 */
		for (i = 0; i < 32; i++) {
			*ptr++ =
			    ISP_READ(isp, PCI_MBOX_REGS2300_OFF + (i << 1));
		}

		/*
		 * Auto Request Response DMA registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x40);
		for (i = 0; i < 32; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * DMA registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x50);
		for (i = 0; i < 48; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * RISC hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0);
		for (i = 0; i < 16; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0xA0 + (i << 1));
		}

		/*
		 * RISC GP? registers
		 */
		for (j = 0; j < 8; j++) {
			ISP_WRITE(isp, BIU_BLOCK + 0xA4, 0x2000 + (j << 9));
			for (i = 0; i < 16; i++) {
				*ptr++ =
				    ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
			}
		}

		/*
		 * frame buffer hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x10);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * FPM B0 hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x20);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * FPM B1 hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x30);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}
	} else {
		isp_prt(isp, ISP_LOGERR, "RISC Would Not Pause");
		return;
	}
	isp_prt(isp, ISP_LOGALL,
	   "isp_fw_dump: RISC registers dumped successfully");
	ISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, OUTMAILBOX0) == 0) {
			break;
		}
	}
	if (ISP_READ(isp, OUTMAILBOX0) != 0) {
		isp_prt(isp, ISP_LOGERR, "Board Would Not Reset");
		return;
	}
	ISP_ENABLE_INTS(isp);
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_READ_RAM_WORD;
	mbs.param[1] = 0x800;
	isp->isp_mbxworkp = (void *) ptr;
	isp->isp_mbxwrk0 = 0xf7ff;	/* continuation count */
	isp->isp_mbxwrk1 = 0x801;	/* next SRAM address */
	isp_control(isp, ISPCTL_RUN_MBOXCMD, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGWARN,
		    "RAM DUMP FAILED @@ WORD %x", isp->isp_mbxwrk1);
		return;
	}
	ptr = isp->isp_mbxworkp;	/* finish fetch of final word */
	*ptr++ = isp->isp_mboxtmp[2];
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_READ_RAM_WORD_EXTENDED;
	mbs.param[8] = 1;
	isp->isp_mbxworkp = (void *) ptr;
	isp->isp_mbxwrk0 = 0xffff;	/* continuation count */
	isp->isp_mbxwrk1 = 0x1;		/* next SRAM address */
	isp->isp_mbxwrk8 = 0x1;
	isp_control(isp, ISPCTL_RUN_MBOXCMD, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGWARN,
		    "RAM DUMP FAILED @@ WORD %x", 0x10000 + isp->isp_mbxwrk1);
		return;
	}
	ptr = isp->isp_mbxworkp;	/* finish final word */
	*ptr++ = mbs.param[2];
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped successfully");
	FCPARAM(isp)->isp_dump_data[0] = isp->isp_type; /* now used */
	(void) isp_async(isp, ISPASYNC_FW_DUMPED, 0);
}

void
isp_fw_dump(struct ispsoftc *isp)
{
	if (IS_2200(isp))
		isp2200_fw_dump(isp);
	else if (IS_23XX(isp))
		isp2300_fw_dump(isp);
}
#endif
@


1.53
log
@remove isp24xx-related code.  it doesn't work, qle(4) replaces it, and
we need the space in the i386 ramdisks.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.52 2011/10/22 19:34:06 miod Exp $ */
@


1.52
log
@Comment out ISP_{T,}DEBUG[0-3] traces if option SMALL_KERNEL; allows alpha
floppyB to fit again. ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.51 2010/12/31 19:26:00 kettenis Exp $ */
a119 1
void isp_fibre_init_2400(struct ispsoftc *);
a134 1
int isp_register_fc4_type_24xx(struct ispsoftc *);
a144 1
int isp_read_nvram_2400(struct ispsoftc *);
a145 1
void isp_rd_2400_nvram(struct ispsoftc *, u_int32_t, u_int32_t *);
a150 1
void isp_parse_nvram_2400(struct ispsoftc *, u_int8_t *);
d164 1
a164 1
	u_int32_t code_org, val;
d207 1
a207 6
			if (IS_24XX(isp)) {
				ISP_WRITE(isp, BIU2400_HCCR,
				    HCCR_2400_CMD_RELEASE);
			} else {
				ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
			}
d228 1
a228 3
	if (IS_24XX(isp)) {
		isp->isp_maxcmds = 4096;
	} else if (IS_2322(isp)) {
d252 1
a252 8
	if (IS_24XX(isp)) {
		isp->isp_rqstinrp = BIU2400_REQINP;
		isp->isp_rqstoutrp = BIU2400_REQOUTP;
		isp->isp_respinrp = BIU2400_RSPINP;
		isp->isp_respoutrp = BIU2400_RSPOUTP;
		isp->isp_atioinrp = BIU2400_ATIO_RSPINP;
		isp->isp_atiooutrp = BIU2400_ATIO_REQINP;
	} else if (IS_23XX(isp)) {
d268 1
a268 7
	if (IS_24XX(isp)) {
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_CLEAR_HOST_INT);
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_CLEAR_RISC_INT);
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_PAUSE);
	} else {
		ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	}
a286 3
		case ISP_HA_FC_2400:
			btype = "2422";
			break;
d291 9
a299 11
		if (!IS_24XX(isp)) {
			/*
			 * While we're paused, reset the FPM module and FBM
			 * fifos.
			 */
			ISP_WRITE(isp, BIU2100_CSR, BIU2100_FPM0_REGS);
			ISP_WRITE(isp, FPM_DIAG_CONFIG, FPM_SOFT_RESET);
			ISP_WRITE(isp, BIU2100_CSR, BIU2100_FB_REGS);
			ISP_WRITE(isp, FBM_CMD, FBMCMD_FIFO_RESET_ALL);
			ISP_WRITE(isp, BIU2100_CSR, BIU2100_RISC_REGS);
		}
a502 38
	} else if (IS_24XX(isp)) {
		/*
		 * Stop DMA and wait for it to stop.
		 */
		ISP_WRITE(isp, BIU2400_CSR, BIU2400_DMA_STOP|(3 << 4));
		for (val = loops = 0; loops < 30000; loops++) {
			USEC_DELAY(10);
			val = ISP_READ(isp, BIU2400_CSR);
			if ((val & BIU2400_DMA_ACTIVE) == 0) {
				break;
			}
		} 
		if (val & BIU2400_DMA_ACTIVE) {
			ISP_RESET0(isp);
			isp_prt(isp, ISP_LOGERR, "DMA Failed to Stop on Reset");
			return;
		}
		/*
		 * Hold it in SOFT_RESET and STOP state for 100us.
		 */
		ISP_WRITE(isp, BIU2400_CSR,
		    BIU2400_SOFT_RESET|BIU2400_DMA_STOP|(3 << 4));
		USEC_DELAY(100);
		for (loops = 0; loops < 10000; loops++) {
			USEC_DELAY(5);
			val = ISP_READ(isp, OUTMAILBOX0);
		}
		for (val = loops = 0; loops < 500000; loops ++) {
			val = ISP_READ(isp, BIU2400_CSR);
			if ((val & BIU2400_SOFT_RESET) == 0) {
				break;
			}
		}
		if (val & BIU2400_SOFT_RESET) {
			ISP_RESET0(isp);
			isp_prt(isp, ISP_LOGERR, "Failed to come out of reset");
			return;
		}
a529 4
		} else if (IS_24XX(isp)) {
			if (ISP_READ(isp, OUTMAILBOX0) == 0) {
				break;
			}
d549 1
a549 1
	} else if (!IS_24XX(isp)) {
d556 3
a558 9
	if (IS_24XX(isp)) {
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_RESET);
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_RELEASE);
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_CLEAR_RESET);
	} else {
		ISP_WRITE(isp, HCCR, HCCR_CMD_RESET);
		USEC_DELAY(100);
		ISP_WRITE(isp, BIU_SEMA, 0);
	}
d564 1
a564 14
	if (IS_24XX(isp)) {
		for (val = loops = 0; loops < 5000000; loops++) {
			USEC_DELAY(5);
			val = ISP_READ(isp, OUTMAILBOX0);
			if (val == 0) {
				break;
			}
		}
		if (val != 0) {
			ISP_RESET0(isp);
			isp_prt(isp, ISP_LOGERR, "reset didn't clear");
			return;
		}
	} else if (IS_SCSI(isp)) {
d652 1
a652 1
	if (IS_SCSI(isp) || IS_24XX(isp)) {
d695 1
a695 3
	if (IS_24XX(isp)) {
		code_org = ISP_CODE_ORG_2400;
	} else if (IS_23XX(isp)) {
d701 1
a701 71
	if (dodnld && IS_24XX(isp)) {
		const u_int32_t *ptr = isp->isp_mdvec->dv_ispfw;

		/*
		 * NB: Whatever you do do, do *not* issue the VERIFY FIRMWARE
		 * NB: command to the 2400 while loading new firmware. This
		 * NB: causes the new f/w to start and immediately crash back
		 * NB: to the ROM.
		 */

		/*
		 * Keep loading until we run out of f/w.
		 */
		code_org = ptr[2];	/* 1st load address is our start addr */

		for (;;) {
			u_int32_t la, wi, wl;

#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG0,
			    "load 0x%x words of code at load address 0x%x",
			    ptr[3], ptr[2]);
#endif

			wi = 0;
			la = ptr[2];
			wl = ptr[3];

			while (wi < ptr[3]) {
				u_int32_t *cp;
				u_int32_t nw;

				nw = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp)) >> 2;
				if (nw > wl) {
					nw = wl;
				}
				cp = isp->isp_rquest;
				for (i = 0; i < nw; i++) {
					ISP_IOXPUT_32(isp,  ptr[wi++], &cp[i]);
					wl--;
				}
				MEMORYBARRIER(isp, SYNC_REQUEST,
				    0, ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp)));
				MEMZERO(&mbs, sizeof (mbs));
				mbs.param[0] = MBOX_LOAD_RISC_RAM;
				mbs.param[1] = la;
				mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
				mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
				mbs.param[4] = nw >> 16;
				mbs.param[5] = nw;
				mbs.param[6] = DMA_WD3(isp->isp_rquest_dma);
				mbs.param[7] = DMA_WD2(isp->isp_rquest_dma);
				mbs.param[8] = la >> 16;
				mbs.logval = MBLOGALL;
				isp_mboxcmd(isp, &mbs);
				if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
					isp_prt(isp, ISP_LOGERR,
					    "F/W Risc Ram Load Failed");
					ISP_RESET0(isp);
					return;
				}
				la += nw;
			}

			if (ptr[1] == 0) {
				break;
			}
			ptr += ptr[3];
		} 
		isp->isp_loaded_fw = 1;
	} else if (dodnld && IS_23XX(isp)) {
d847 1
a847 9
	if (IS_24XX(isp)) {
		mbs.param[1] = code_org >> 16;
		mbs.param[2] = code_org;
		if (isp->isp_loaded_fw) {
			mbs.param[3] = 0;
		} else {
			mbs.param[3] = 1;
		}
	} else if (IS_2322(isp)) {
d860 1
a860 1
	if (IS_2322(isp) || IS_24XX(isp)) {
a894 6
	if (IS_24XX(isp) && mbs.param[1] == 0xdead) {
		isp_prt(isp, ISP_LOGERR, "f/w didn't *really* start");
		ISP_RESET0(isp);
		return;
	}

d946 4
a949 1
		if (IS_24XX(isp)) {
d952 2
a954 11
		} else {
			if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
				FCPARAM(isp)->isp_sccfw = 1;
			}
			if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_2KLOGINS) {
				FCPARAM(isp)->isp_2klogin = 1;
				FCPARAM(isp)->isp_sccfw = 1;
			}
			if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_TMODE) {
				FCPARAM(isp)->isp_tmode = 1;
			}
d968 1
a968 1
	if (!IS_24XX(isp)) {
d1053 1
a1053 5
			if (IS_24XX(isp)) {
				isp_fibre_init_2400(isp);
			} else {
				isp_fibre_init(isp);
			}
a1662 265
isp_fibre_init_2400(struct ispsoftc *isp)
{
	fcparam *fcp;
	isp_icb_2400_t local, *icbp = &local;
	mbreg_t mbs;
	int ownloopid;
	u_int64_t nwwn, pwwn;

	fcp = isp->isp_param;

	/*
	 * Turn on LIP F8 async event (1)
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SET_FIRMWARE_OPTIONS;
	mbs.param[1] = 1;
	mbs.logval = MBLOGALL;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
	}

	/*
	 * XXX: This should be applied to icb- not fwoptions
	 */
	if (isp->isp_role & ISP_ROLE_TARGET) {
		fcp->isp_fwoptions |= ICB2400_OPT1_TGT_ENABLE;
	} else {
		fcp->isp_fwoptions &= ~ICB2400_OPT1_TGT_ENABLE;
	}

	if (isp->isp_role & ISP_ROLE_INITIATOR) {
		fcp->isp_fwoptions &= ~ICB2400_OPT1_INI_DISABLE;
	} else {
		fcp->isp_fwoptions |= ICB2400_OPT1_INI_DISABLE;
	}

	MEMZERO(icbp, sizeof (*icbp));
	icbp->icb_version = ICB_VERSION1;
	icbp->icb_maxfrmlen = fcp->isp_maxfrmlen;
	if (icbp->icb_maxfrmlen < ICB_MIN_FRMLEN ||
	    icbp->icb_maxfrmlen > ICB_MAX_FRMLEN) {
		isp_prt(isp, ISP_LOGERR,
		    "bad frame length (%d) from NVRAM- using %d",
		    fcp->isp_maxfrmlen, ICB_DFLT_FRMLEN);
		icbp->icb_maxfrmlen = ICB_DFLT_FRMLEN;
	}

	icbp->icb_execthrottle = fcp->isp_execthrottle;
	if (icbp->icb_execthrottle < 1) {
		isp_prt(isp, ISP_LOGERR,
		    "bad execution throttle of %d- using 16",
		    fcp->isp_execthrottle);
		icbp->icb_execthrottle = ICB_DFLT_THROTTLE;
	}

	if (isp->isp_role & ISP_ROLE_TARGET) {
		/*
		 * Get current resource count
		 */
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_GET_RESOURCE_COUNT;
		mbs.obits = 0x4cf;
		mbs.logval = MBLOGALL;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		icbp->icb_xchgcnt = mbs.param[3];
	}

	icbp->icb_fwoptions1 = fcp->isp_fwoptions;

	icbp->icb_hardaddr = fcp->isp_loopid;
	ownloopid = (isp->isp_confopts & ISP_CFG_OWNLOOPID) != 0;
	if (icbp->icb_hardaddr > 125) {
		icbp->icb_hardaddr = 0;
		ownloopid = 0;
	}
	if (ownloopid) {
		icbp->icb_fwoptions1 |= ICB2400_OPT1_HARD_ADDRESS;
	}

	icbp->icb_fwoptions2 = fcp->isp_xfwoptions;
	switch(isp->isp_confopts & ISP_CFG_PORT_PREF) {
	case ISP_CFG_NPORT:
		icbp->icb_fwoptions2 &= ~ICB2400_OPT2_TOPO_MASK;
		icbp->icb_fwoptions2 |= ICB2400_OPT2_PTP_2_LOOP;
		break;
	case ISP_CFG_NPORT_ONLY:
		icbp->icb_fwoptions2 &= ~ICB2400_OPT2_TOPO_MASK;
		icbp->icb_fwoptions2 |= ICB2400_OPT2_PTP_ONLY;
		break;
	case ISP_CFG_LPORT_ONLY:
		icbp->icb_fwoptions2 &= ~ICB2400_OPT2_TOPO_MASK;
		icbp->icb_fwoptions2 |= ICB2400_OPT2_LOOP_ONLY;
		break;
	default:
		icbp->icb_fwoptions2 &= ~ICB2400_OPT2_TOPO_MASK;
		icbp->icb_fwoptions2 |= ICB2400_OPT2_LOOP_2_PTP;
		break;
	}

	switch (icbp->icb_fwoptions2 & ICB2400_OPT2_TIMER_MASK) {
	case ICB2400_OPT2_ZIO:
	case ICB2400_OPT2_ZIO1:
		icbp->icb_idelaytimer = 0;
		break;
	case 0:
		break;
	default:
		isp_prt(isp, ISP_LOGWARN, "bad value %x in fwopt2 timer field",
		    icbp->icb_fwoptions2 & ICB2400_OPT2_TIMER_MASK);
		icbp->icb_fwoptions2 &= ~ICB2400_OPT2_TIMER_MASK;
		break;
	}

	icbp->icb_fwoptions3 = fcp->isp_zfwoptions;
	icbp->icb_fwoptions3 &= ~ICB2400_OPT3_RATE_AUTO;
	if (isp->isp_confopts & ISP_CFG_ONEGB) {
		icbp->icb_fwoptions3 |= ICB2400_OPT3_RATE_ONEGB;
	} else if (isp->isp_confopts & ISP_CFG_TWOGB) {
		icbp->icb_fwoptions3 |= ICB2400_OPT3_RATE_TWOGB;
	} else if (isp->isp_confopts & ISP_CFG_FOURGB) {
		icbp->icb_fwoptions3 |= ICB2400_OPT3_RATE_FOURGB;
	} else {
		icbp->icb_fwoptions3 |= ICB2400_OPT3_RATE_AUTO;
	}

	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0) {
		icbp->icb_fwoptions3 |= ICB2400_OPT3_SOFTID;
	}
	icbp->icb_logintime = ICB_LOGIN_TOV;

	nwwn = ISP_NODEWWN(isp);
	pwwn = ISP_PORTWWN(isp);

	if (nwwn && pwwn) {
		icbp->icb_fwoptions1 |= ICB2400_OPT1_BOTH_WWNS;
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, nwwn);
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pwwn);
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG1,
		    "Setting ICB Node 0x%08x%08x Port 0x%08x%08x",
		    ((u_int32_t) (nwwn >> 32)),
		    ((u_int32_t) (nwwn & 0xffffffff)),
		    ((u_int32_t) (pwwn >> 32)),
		    ((u_int32_t) (pwwn & 0xffffffff)));
#endif
	} else if (pwwn) {
		icbp->icb_fwoptions1 &= ~ICB2400_OPT1_BOTH_WWNS;
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pwwn);
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG1,
		    "Setting ICB Port 0x%08x%08x",
		    ((u_int32_t) (pwwn >> 32)),
		    ((u_int32_t) (pwwn & 0xffffffff)));
#endif
	} else {
		isp_prt(isp, ISP_LOGERR, "No valid WWNs to use");
		return;
	}
	icbp->icb_retry_count = fcp->isp_retry_count;

	icbp->icb_rqstqlen = RQUEST_QUEUE_LEN(isp);
	if (icbp->icb_rqstqlen < 8) {
		isp_prt(isp, ISP_LOGERR, "bad request queue length %d",
		    icbp->icb_rqstqlen);
		return;
	}
	icbp->icb_rsltqlen = RESULT_QUEUE_LEN(isp);
	if (icbp->icb_rsltqlen < 8) {
		isp_prt(isp, ISP_LOGERR, "bad result queue length %d",
		    icbp->icb_rsltqlen);
		return;
	}
	icbp->icb_rqstaddr[RQRSP_ADDR0015] = DMA_WD0(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR1631] = DMA_WD1(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR3247] = DMA_WD2(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR4863] = DMA_WD3(isp->isp_rquest_dma);

	icbp->icb_respaddr[RQRSP_ADDR0015] = DMA_WD0(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR1631] = DMA_WD1(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR3247] = DMA_WD2(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR4863] = DMA_WD3(isp->isp_result_dma);

#ifdef	ISP_TARGET_MODE
	if (isp->isp_role & ISP_ROLE_TARGET) {
		icbp->icb_atioqlen = RESULT_QUEUE_LEN(isp);
		if (icbp->icb_atioqlen < 8) {
			isp_prt(isp, ISP_LOGERR, "bad ATIO queue length %d",
			    icbp->icb_atioqlen);
			return;
		}
		icbp->icb_atioqaddr[RQRSP_ADDR0015] =
		    DMA_WD0(isp->isp_atioq_dma);
		icbp->icb_atioqaddr[RQRSP_ADDR1631] =
		    DMA_WD1(isp->isp_atioq_dma);
		icbp->icb_atioqaddr[RQRSP_ADDR3247] =
		    DMA_WD2(isp->isp_atioq_dma);
		icbp->icb_atioqaddr[RQRSP_ADDR4863] =
		    DMA_WD3(isp->isp_atioq_dma);
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0,
		    "isp_fibre_init_2400: atioq %04x%04x%04x%04x",
		    DMA_WD3(isp->isp_atioq_dma), DMA_WD2(isp->isp_atioq_dma),
		    DMA_WD1(isp->isp_atioq_dma), DMA_WD0(isp->isp_atioq_dma));
#endif
	}
#endif

#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0,
	    "isp_fibre_init_2400: fwopt1 0x%x fwopt2 0x%x fwopt3 0x%x",
	    icbp->icb_fwoptions1, icbp->icb_fwoptions2, icbp->icb_fwoptions3);

	isp_prt(isp, ISP_LOGDEBUG0,
	    "isp_fibre_init_2400: rqst %04x%04x%04x%04x rsp %04x%04x%04x%04x",
	    DMA_WD3(isp->isp_rquest_dma), DMA_WD2(isp->isp_rquest_dma),
	    DMA_WD1(isp->isp_rquest_dma), DMA_WD0(isp->isp_rquest_dma),
	    DMA_WD3(isp->isp_result_dma), DMA_WD2(isp->isp_result_dma),
	    DMA_WD1(isp->isp_result_dma), DMA_WD0(isp->isp_result_dma));

	if (isp->isp_dblev & ISP_LOGDEBUG1) {
		isp_print_bytes(isp, "isp_fibre_init_2400", sizeof (*icbp),
		    icbp);
	}
#endif
	FC_SCRATCH_ACQUIRE(isp);
	isp_put_icb_2400(isp, icbp, fcp->isp_scratch);


	/*
	 * Init the firmware
	 */
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_INIT_FIRMWARE;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
	mbs.logval = MBLOGALL;
	mbs.timeout = 30 * 1000000;
#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0, "INIT F/W from %04x%04x%04x%04x",
	    DMA_WD3(fcp->isp_scdma), DMA_WD2(fcp->isp_scdma),
	    DMA_WD1(fcp->isp_scdma), DMA_WD0(fcp->isp_scdma));
#endif
	MEMORYBARRIER(isp, SYNC_SFORDEV, 0, sizeof (*icbp));
	isp_mboxcmd(isp, &mbs);
	FC_SCRATCH_RELEASE(isp);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
	}
	isp->isp_reqidx = 0;
	isp->isp_reqodx = 0;
	isp->isp_residx = 0;

	/*
	 * Whatever happens, we're now committed to being here.
	 */
	isp->isp_state = ISP_INITSTATE;
}

void
d1700 7
a1706 31
	mbreg_t mbs;
	u_int8_t q[QENTRY_LEN];
	isp_plogx_t *plp;
	u_int8_t *scp;
	u_int32_t sst, parm1;
	int rval;

	if (!IS_24XX(isp)) {
		int action = flags & PLOGX_FLG_CMD_MASK;
		if (action == PLOGX_FLG_CMD_PLOGI) {
			return (isp_port_login(isp, handle, portid));
		} else if (action == PLOGX_FLG_CMD_LOGO) {
			return (isp_port_logout(isp, handle, portid));
		} else {
			return (MBOX_INVALID_COMMAND);
		}
	}

	MEMZERO(q, QENTRY_LEN);
	plp = (isp_plogx_t *) q;
	plp->plogx_header.rqs_entry_count = 1;
	plp->plogx_header.rqs_entry_type = RQSTYPE_LOGIN;
	plp->plogx_handle = 0xffffffff;
	plp->plogx_nphdl = handle;
	plp->plogx_portlo = portid;
	plp->plogx_rspsz_porthi = (portid >> 16) & 0xff;
	plp->plogx_flags = flags;

#ifndef SMALL_KERNEL
	if (isp->isp_dblev & ISP_LOGDEBUG1) {
		isp_print_bytes(isp, "IOCB LOGX", QENTRY_LEN, plp);
a1707 120
#endif

	if (gs == 0) {
		FC_SCRATCH_ACQUIRE(isp);
	}
	scp = FCPARAM(isp)->isp_scratch;
	isp_put_plogx(isp, plp, (isp_plogx_t *) scp);


	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_EXEC_COMMAND_IOCB_A64;
	mbs.param[1] = QENTRY_LEN;
	mbs.param[2] = DMA_WD1(FCPARAM(isp)->isp_scdma);
	mbs.param[3] = DMA_WD0(FCPARAM(isp)->isp_scdma);
	mbs.param[6] = DMA_WD3(FCPARAM(isp)->isp_scdma);
	mbs.param[7] = DMA_WD2(FCPARAM(isp)->isp_scdma);
	mbs.timeout = 500000;
	mbs.logval = MBLOGALL;
	MEMORYBARRIER(isp, SYNC_SFORDEV, 0, QENTRY_LEN);
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		rval = mbs.param[0];
		goto out;
	}
	MEMORYBARRIER(isp, SYNC_SFORCPU, QENTRY_LEN, QENTRY_LEN);
	scp += QENTRY_LEN;
	isp_get_plogx(isp, (isp_plogx_t *) scp, plp);
#ifndef SMALL_KERNEL
	if (isp->isp_dblev & ISP_LOGDEBUG1) {
		isp_print_bytes(isp, "IOCB LOGX response", QENTRY_LEN, plp);
	}
#endif

	if (plp->plogx_status == PLOGX_STATUS_OK) {
		rval = 0;
		goto out;
	} else if (plp->plogx_status != PLOGX_STATUS_IOCBERR) {
		isp_prt(isp, ISP_LOGWARN, "status 0x%x on port login IOCB",
		    plp->plogx_status);
		rval = -1;
		goto out;
	}

	sst = plp->plogx_ioparm[0].lo16 | (plp->plogx_ioparm[0].hi16 << 16);
	parm1 = plp->plogx_ioparm[1].lo16 | (plp->plogx_ioparm[1].hi16 << 16);

	rval = -1;

	switch (sst) {
	case PLOGX_IOCBERR_NOLINK:
		isp_prt(isp, ISP_LOGERR, "PLOGX failed- no link");
		break;
	case PLOGX_IOCBERR_NOIOCB:
		isp_prt(isp, ISP_LOGERR, "PLOGX failed- no IOCB buffer");
		break;
	case PLOGX_IOCBERR_NOXGHG:
		isp_prt(isp, ISP_LOGERR,
		    "PLOGX failed- no Exchange Control Block");
		break;
	case PLOGX_IOCBERR_FAILED:
		isp_prt(isp, ISP_LOGERR,
		    "PLOGX(0x%x) of Port 0x%06x failed: reason 0x%x (last LOGIN"
		    " state 0x%x)", flags, portid, parm1 & 0xff,
		    (parm1 >> 8) & 0xff);
		break;
	case PLOGX_IOCBERR_NOFABRIC:
		isp_prt(isp, ISP_LOGERR, "PLOGX failed- no fabric");
		break;
	case PLOGX_IOCBERR_NOTREADY:
		isp_prt(isp, ISP_LOGERR, "PLOGX failed- f/w not ready");
		break;
	case PLOGX_IOCBERR_NOLOGIN:
		isp_prt(isp, ISP_LOGERR,
		    "PLOGX failed- not logged in (last LOGIN state 0x%x)",
		    parm1);
		rval = MBOX_NOT_LOGGED_IN;
		break;
	case PLOGX_IOCBERR_REJECT:
		isp_prt(isp, ISP_LOGERR, "PLOGX failed: LS_RJT = 0x%x", parm1);
		break;
	case PLOGX_IOCBERR_NOPCB:
		isp_prt(isp, ISP_LOGERR, "PLOGX failed- no PCB allocated");
		break;
	case PLOGX_IOCBERR_EINVAL:
		isp_prt(isp, ISP_LOGERR,
		    "PLOGX failed: invalid parameter at offset 0x%x", parm1);
		break;
	case PLOGX_IOCBERR_PORTUSED:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0,
		    "portid 0x%x already logged in with N-port handle 0x%x",
		    portid, parm1);
#endif
		rval = MBOX_PORT_ID_USED | (handle << 16);
		break;
	case PLOGX_IOCBERR_HNDLUSED:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0,
		    "N-port handle 0x%x already used for portid 0x%x",
		    handle, parm1);
#endif
		rval = MBOX_LOOP_ID_USED;
		break;
	case PLOGX_IOCBERR_NOHANDLE:
		isp_prt(isp, ISP_LOGERR, "PLOGX failed- no handle allocated");
		break;
	case PLOGX_IOCBERR_NOFLOGI:
		isp_prt(isp, ISP_LOGERR, "PLOGX failed- no FLOGI_ACC");
		break;
	default:
		isp_prt(isp, ISP_LOGERR, "status %x from %x", plp->plogx_status,
		    flags);
		rval = -1;
		break;
	}
out:
	if (gs == 0) {
		FC_SCRATCH_RELEASE(isp);
	}
	return (rval);
d1799 1
a1799 4
	if (IS_24XX(isp)) {
		mbs.ibits = 0x3ff;
		mbs.param[1] = id;
	} else if (FCPARAM(isp)->isp_2klogin) {
d1822 1
a1822 8
	if (IS_24XX(isp)) {
		isp_get_pdb_24xx(isp, fcp->isp_scratch, &un.bill);
		pdb->handle = un.bill.pdb_handle;
		pdb->s3_role = un.bill.pdb_prli_svc3;
		pdb->portid = BITS2WORD_24XX(un.bill.pdb_portid_bits);
		MEMCPY(pdb->portname, un.bill.pdb_portname, 8);
		MEMCPY(pdb->nodename, un.bill.pdb_nodename, 8);
	} else {
d1861 1
a1861 11
	if (IS_24XX(isp)) {
		wwn =
		    (((u_int64_t)(mbs.param[2] >> 8))   << 56) |
		    (((u_int64_t)(mbs.param[2] & 0xff))	<< 48) |
		    (((u_int64_t)(mbs.param[3] >> 8))	<< 40) |
		    (((u_int64_t)(mbs.param[3] & 0xff))	<< 32) |
		    (((u_int64_t)(mbs.param[6] >> 8))	<< 24) |
		    (((u_int64_t)(mbs.param[6] & 0xff))	<< 16) |
		    (((u_int64_t)(mbs.param[7] >> 8))	<<  8) |
		    (((u_int64_t)(mbs.param[7] & 0xff)));
	} else {
d2023 1
a2023 5
	if (IS_24XX(isp)) {
		loopid = NPH_FL_ID;
	} else {
		loopid = FL_ID;
	}
d2050 1
a2050 5
		if (IS_24XX(isp)) {
			r = isp_register_fc4_type_24xx(isp);
		} else {
			r = isp_register_fc4_type(isp);
		}
d2062 1
a2062 1
	if (IS_23XX(isp) || IS_24XX(isp)) {
a2598 110
isp_gid_ft_ct_passthru(struct ispsoftc *isp)
{
	mbreg_t mbs;
	fcparam *fcp = FCPARAM(isp);
	union {
		isp_ct_pt_t plocal;
		ct_hdr_t clocal;
		u_int8_t q[QENTRY_LEN];
	} un;
	isp_ct_pt_t *pt;
	ct_hdr_t *ct;
	u_int32_t *rp;
	u_int8_t *scp = fcp->isp_scratch;

#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0, "scanning fabric (GID_FT) via CT");
#endif

	if (!IS_24XX(isp)) {
		return (1);
	}

	/*
	 * Build a Passthrough IOCB in memory.
	 */
	pt = &un.plocal;
	MEMZERO(un.q, QENTRY_LEN);
	pt->ctp_header.rqs_entry_count = 1;
	pt->ctp_header.rqs_entry_type = RQSTYPE_CT_PASSTHRU;
	pt->ctp_handle = 0xffffffff;
	pt->ctp_nphdl = NPH_SNS_ID;
	pt->ctp_cmd_cnt = 1;
	pt->ctp_time = 30;
	pt->ctp_rsp_cnt = 1;
	pt->ctp_rsp_bcnt = GIDLEN;
	pt->ctp_cmd_bcnt = sizeof (*ct) + sizeof (u_int32_t);
	pt->ctp_dataseg[0].ds_base = DMA_LO32(fcp->isp_scdma+XTXOFF);
	pt->ctp_dataseg[0].ds_basehi = DMA_HI32(fcp->isp_scdma+XTXOFF);
	pt->ctp_dataseg[0].ds_count = sizeof (*ct) + sizeof (u_int32_t);
	pt->ctp_dataseg[1].ds_base = DMA_LO32(fcp->isp_scdma+IGPOFF);
	pt->ctp_dataseg[1].ds_basehi = DMA_HI32(fcp->isp_scdma+IGPOFF);
	pt->ctp_dataseg[1].ds_count = GIDLEN;
#ifndef SMALL_KERNEL
	if (isp->isp_dblev & ISP_LOGDEBUG1) {
		isp_print_bytes(isp, "ct IOCB", QENTRY_LEN, pt);
	}
#endif
	isp_put_ct_pt(isp, pt, (isp_ct_pt_t *) &scp[CTXOFF]);

	/*
	 * Build the CT header and command in memory.
	 *
	 * Note that the CT header has to end up as Big Endian format in memory.
	 */
	ct = &un.clocal;
	MEMZERO(ct, sizeof (*ct));
	ct->ct_revision = CT_REVISION;
	ct->ct_fcs_type = CT_FC_TYPE_FC;
	ct->ct_fcs_subtype = CT_FC_SUBTYPE_NS;
	ct->ct_cmd_resp = SNS_GID_FT;
	ct->ct_bcnt_resid = (GIDLEN - 16) >> 2;

	isp_put_ct_hdr(isp, ct, (ct_hdr_t *) &scp[XTXOFF]);
	rp = (u_int32_t *) &scp[XTXOFF+sizeof (*ct)];
	ISP_IOZPUT_32(isp, FC4_SCSI, rp);
#ifndef SMALL_KERNEL
	if (isp->isp_dblev & ISP_LOGDEBUG1) {
		isp_print_bytes(isp, "CT HDR + payload after put",
		    sizeof (*ct) + sizeof (u_int32_t), &scp[XTXOFF]);
	}
#endif
	MEMZERO(&scp[ZTXOFF], QENTRY_LEN);
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_EXEC_COMMAND_IOCB_A64;
	mbs.param[1] = QENTRY_LEN;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma + CTXOFF);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma + CTXOFF);
	mbs.param[6] = DMA_WD3(fcp->isp_scdma + CTXOFF);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma + CTXOFF);
	mbs.timeout = 500000;
	mbs.logval = MBLOGALL;
	MEMORYBARRIER(isp, SYNC_SFORDEV, XTXOFF, 2 * QENTRY_LEN);
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return (-1);
	}
	MEMORYBARRIER(isp, SYNC_SFORCPU, ZTXOFF, QENTRY_LEN);
	pt = &un.plocal;
	isp_get_ct_pt(isp, (isp_ct_pt_t *) &scp[ZTXOFF], pt);
#ifndef SMALL_KERNEL
	if (isp->isp_dblev & ISP_LOGDEBUG1) {
		isp_print_bytes(isp, "IOCB response", QENTRY_LEN, pt);
	}
#endif

	if (pt->ctp_status && pt->ctp_status != RQCS_DATA_UNDERRUN) {
		isp_prt(isp, ISP_LOGWARN, "CT Passthrough returned 0x%x",
		    pt->ctp_status);
		return (-1);
	}
	MEMORYBARRIER(isp, SYNC_SFORCPU, IGPOFF, GIDLEN + 16);
#ifndef SMALL_KERNEL
	if (isp->isp_dblev & ISP_LOGDEBUG1) {
		isp_print_bytes(isp, "CT response", GIDLEN+16, &scp[IGPOFF]);
	}
#endif
	return (0);
}

int
d2625 1
a2625 6
	if (IS_24XX(isp)) {
		r = isp_gid_ft_ct_passthru(isp);
	} else {
		r = isp_gid_ft_sns(isp);
	}

a3179 107
int
isp_register_fc4_type_24xx(struct ispsoftc *isp)
{
	mbreg_t mbs;
	fcparam *fcp = FCPARAM(isp);
	union {
		isp_ct_pt_t plocal;
		rft_id_t clocal;
		u_int8_t q[QENTRY_LEN];
	} un;
	isp_ct_pt_t *pt;
	ct_hdr_t *ct;
	rft_id_t *rp;
	u_int8_t *scp = fcp->isp_scratch;

	FC_SCRATCH_ACQUIRE(isp);
	/*
	 * Build a Passthrough IOCB in memory.
	 */
	MEMZERO(un.q, QENTRY_LEN);
	pt = &un.plocal;
	pt->ctp_header.rqs_entry_count = 1;
	pt->ctp_header.rqs_entry_type = RQSTYPE_CT_PASSTHRU;
	pt->ctp_handle = 0xffffffff;
	pt->ctp_nphdl = NPH_SNS_ID;
	pt->ctp_cmd_cnt = 1;
	pt->ctp_time = 1;
	pt->ctp_rsp_cnt = 1;
	pt->ctp_rsp_bcnt = sizeof (ct_hdr_t);
	pt->ctp_cmd_bcnt = sizeof (rft_id_t);
	pt->ctp_dataseg[0].ds_base = DMA_LO32(fcp->isp_scdma+XTXOFF);
	pt->ctp_dataseg[0].ds_basehi = DMA_HI32(fcp->isp_scdma+XTXOFF);
	pt->ctp_dataseg[0].ds_count = sizeof (rft_id_t);
	pt->ctp_dataseg[1].ds_base = DMA_LO32(fcp->isp_scdma+IGPOFF);
	pt->ctp_dataseg[1].ds_basehi = DMA_HI32(fcp->isp_scdma+IGPOFF);
	pt->ctp_dataseg[1].ds_count = sizeof (ct_hdr_t);
	isp_put_ct_pt(isp, pt, (isp_ct_pt_t *) &scp[CTXOFF]);

	/*
	 * Build the CT header and command in memory.
	 *
	 * Note that the CT header has to end up as Big Endian format in memory.
	 */
	MEMZERO(&un.clocal, sizeof (un.clocal));
	ct = &un.clocal.rftid_hdr;
	ct->ct_revision = CT_REVISION;
	ct->ct_fcs_type = CT_FC_TYPE_FC;
	ct->ct_fcs_subtype = CT_FC_SUBTYPE_NS;
	ct->ct_cmd_resp = SNS_RFT_ID;
	ct->ct_bcnt_resid = (sizeof (rft_id_t) - sizeof (ct_hdr_t)) >> 2;
	rp = &un.clocal;
	rp->rftid_portid[0] = fcp->isp_portid >> 16;
	rp->rftid_portid[1] = fcp->isp_portid >> 8;
	rp->rftid_portid[2] = fcp->isp_portid;
	rp->rftid_fc4types[FC4_SCSI >> 5] = 1 << (FC4_SCSI & 0x1f);
	isp_put_rft_id(isp, rp, (rft_id_t *) &scp[XTXOFF]);

	MEMZERO(&scp[ZTXOFF], sizeof (ct_hdr_t));

	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_EXEC_COMMAND_IOCB_A64;
	mbs.param[1] = QENTRY_LEN;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma + CTXOFF);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma + CTXOFF);
	mbs.param[6] = DMA_WD3(fcp->isp_scdma + CTXOFF);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma + CTXOFF);
	mbs.timeout = 500000;
	mbs.logval = MBLOGALL;
	MEMORYBARRIER(isp, SYNC_SFORDEV, XTXOFF, 2 * QENTRY_LEN);
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		FC_SCRATCH_RELEASE(isp);
		return (-1);
	}
	MEMORYBARRIER(isp, SYNC_SFORCPU, ZTXOFF, QENTRY_LEN);
	pt = &un.plocal;
	isp_get_ct_pt(isp, (isp_ct_pt_t *) &scp[ZTXOFF], pt);
#ifndef SMALL_KERNEL
	if (isp->isp_dblev & ISP_LOGDEBUG1) {
		isp_print_bytes(isp, "IOCB response", QENTRY_LEN, pt);
	}
#endif
	if (pt->ctp_status) {
		FC_SCRATCH_RELEASE(isp);
		isp_prt(isp, ISP_LOGWARN, "CT Passthrough returned 0x%x",
		    pt->ctp_status);
		return (-1);
	}

	isp_get_ct_hdr(isp, (ct_hdr_t *) &scp[IGPOFF], ct);
	FC_SCRATCH_RELEASE(isp);

	if (ct->ct_cmd_resp == LS_RJT) {
		isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0,
		    "Register FC4 Type rejected");
		return (-1);
	} else if (ct->ct_cmd_resp == LS_ACC) {
		isp_prt(isp, ISP_LOGSANCFG|ISP_LOGDEBUG0,
		    "Register FC4 Type accepted");
		return(0);
	} else {
		isp_prt(isp, ISP_LOGWARN,
		    "Register FC4 Type: 0x%x", ct->ct_cmd_resp);
		return (-1);
	}
}

d3351 5
a3355 2
		if (IS_24XX(isp)) {
			isp_marker_24xx_t *m = (isp_marker_24xx_t *) qep;
d3359 1
d3361 1
a3361 1
			isp_put_marker_24xx(isp, m, (isp_marker_24xx_t *)qep);
d3363 1
a3363 1
			isp->isp_sendmarker = 0;
a3364 16
		} else {
			for (i = 0; i < (IS_DUALBUS(isp)? 2: 1); i++) {
				isp_marker_t *m = (isp_marker_t *) qep;
				if ((isp->isp_sendmarker & (1 << i)) == 0) {
					continue;
				}
				MEMZERO(m, QENTRY_LEN);
				m->mrk_header.rqs_entry_count = 1;
				m->mrk_header.rqs_entry_type = RQSTYPE_MARKER;
				m->mrk_target = (i << 7);	/* bus # */
				m->mrk_modifier = SYNC_ALL;
				isp_put_marker(isp, m, (isp_marker_t *) qep);
				ISP_ADD_REQUEST(isp, nxti);
				isp->isp_sendmarker &= ~(1 << i);
				goto start_again;
			}
d3370 1
a3370 3
	if (IS_24XX(isp)) {
		reqp->req_header.rqs_entry_type = RQSTYPE_T7RQS;
	} else if (IS_FC(isp)) {
d3380 1
a3380 20
	if (IS_24XX(isp)) {
		int ttype;
		if (XS_TAG_P(xs)) {
			ttype = XS_TAG_TYPE(xs);
		} else {
			if (XS_CDBP(xs)[0] == 0x3) {
				ttype = REQFLAG_HTAG;
			} else {
				ttype = REQFLAG_STAG;
			}
		}
		if (ttype == REQFLAG_OTAG) {
			ttype = FCP_CMND_TASK_ATTR_ORDERED;
		} else if (ttype == REQFLAG_HTAG) {
			ttype = FCP_CMND_TASK_ATTR_HEAD;
		} else {
			ttype = FCP_CMND_TASK_ATTR_SIMPLE;
		}
		((ispreqt7_t *)reqp)->req_task_attribute = ttype;
	} else if (IS_FC(isp)) {
a3417 14
	} else if (IS_24XX(isp)) {
		fcportdb_t *lp;

		lp = &FCPARAM(isp)->portdb[hdlidx];
		((ispreqt7_t *)reqp)->req_nphdl = target;
		((ispreqt7_t *)reqp)->req_tidlo = lp->portid;
		((ispreqt7_t *)reqp)->req_tidhi = lp->portid >> 16;
		if (XS_LUN(xs) > 256) {
			((ispreqt7_t *)reqp)->req_lun[0] = XS_LUN(xs) >> 8;
			((ispreqt7_t *)reqp)->req_lun[0] |= 0x40;
		}
		((ispreqt7_t *)reqp)->req_lun[1] = XS_LUN(xs);
		cdbp = ((ispreqt7_t *)reqp)->req_cdb;
		tptr = &((ispreqt7_t *)reqp)->req_time;
a3433 3
	if (IS_24XX(isp) && *tptr > 0x1999) {
		*tptr = 0x1999;
	}
d3494 1
a3494 4
		if (IS_24XX(isp)) {
			isp_prt(isp, ISP_LOGWARN, "RESET BUS NOT IMPLEMENTED");
			break;
		} else if (IS_FC(isp)) {
d3520 1
a3520 4
		if (IS_24XX(isp)) {
			isp_prt(isp, ISP_LOGWARN, "RESET DEV NOT IMPLEMENTED");
			break;
		} else if (IS_FC(isp)) {
d3554 1
a3554 4
		if (IS_24XX(isp)) {
			isp_prt(isp, ISP_LOGWARN, "ABORT CMD NOT IMPLEMENTED");
			break;
		} else if (IS_FC(isp)) {
d3617 1
a3617 1
		if (IS_FC(isp) && !IS_24XX(isp)) {
d3822 1
a3822 1
	if (IS_23XX(isp) || IS_24XX(isp)) {
d3871 1
a3871 3
		if (IS_24XX(isp)) {
			junk = 0;
		} else if (IS_23XX(isp)) {
d3879 1
a3879 1
			if (IS_23XX(isp) || IS_24XX(isp)) {
d3929 1
a3929 15
		if (IS_24XX(isp) && etype == RQSTYPE_RESPONSE) {
			isp24xx_statusreq_t *sp2 = (isp24xx_statusreq_t *)qe;
			isp_get_24xx_response(isp,
			    (isp24xx_statusreq_t *)hp, sp2);
#ifndef SMALL_KERNEL
			if (isp->isp_dblev & ISP_LOGDEBUG1) {
				isp_print_bytes(isp,
				    "Response Queue Entry", QENTRY_LEN, sp2);
			}
#endif
			scsi_status = sp2->req_scsi_status;
			completion_status = sp2->req_completion_status;
			req_state_flags = 0;
			resid = sp2->req_resid;
		} else if (etype == RQSTYPE_RESPONSE) {
d4073 1
a4073 4
		if (IS_24XX(isp) && (scsi_status & (RQCS_RV|RQCS_SV)) != 0) {
			resp = ((isp24xx_statusreq_t *)sp)->req_rsp_sense;
			rlen = ((isp24xx_statusreq_t *)sp)->req_response_len;
		} else if (IS_FC(isp) && (scsi_status & RQCS_RV) != 0) {
d4084 2
a4085 10
			if (IS_24XX(isp)) {
				snsp =
				    ((isp24xx_statusreq_t *)sp)->req_rsp_sense;
				snsp += rlen;
				slen =
				    ((isp24xx_statusreq_t *)sp)->req_sense_len;
			} else {
				snsp = sp->req_sense_data;
				slen = sp->req_sense_len;
			}
d4105 1
a4105 6
			if (IS_24XX(isp)) {
				isp_parse_status_24xx(isp,
				    (isp24xx_statusreq_t *)sp, xs, &resid);
			} else {
				isp_parse_status(isp, (void *)sp, xs, &resid);
			}
d4234 2
a4235 6
	if (IS_24XX(isp)) {
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_CLEAR_RISC_INT);
	} else {
		ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
		ISP_WRITE(isp, BIU_SEMA, 0);
	}
d4581 1
a4581 6
		if (IS_24XX(isp)) {
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGTDEBUG0, "LS_RJT sent");
#endif
			break;
		} else if (IS_2200(isp)) {
a5073 185
isp_parse_status_24xx(struct ispsoftc *isp, isp24xx_statusreq_t *sp,
    XS_T *xs, long *rp)
{
	int ru_marked, sv_marked;
	switch (sp->req_completion_status) {
	case RQCS_COMPLETE:
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_NOERROR);
		}
		return;

	case RQCS_DMA_ERROR:
		isp_prt(isp, ISP_LOGERR, "DMA error for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_TRANSPORT_ERROR:
		isp_prt(isp, ISP_LOGERR, "transport error for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		break;

	case RQCS_RESET_OCCURRED:
		isp_prt(isp, ISP_LOGWARN,
		    "bus reset destroyed command for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		isp->isp_sendmarker |= (1 << XS_CHANNEL(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_BUSRESET);
		}
		return;

	case RQCS_ABORTED:
		isp_prt(isp, ISP_LOGERR, "command aborted for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		isp->isp_sendmarker |= (1 << XS_CHANNEL(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_ABORTED);
		}
		return;

	case RQCS_TIMEOUT:
		isp_prt(isp, ISP_LOGWARN, "command timed out for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_CMDTIMEOUT);
		}
		return;

	case RQCS_DATA_OVERRUN:
		XS_RESID(xs) = sp->req_resid;
		isp_prt(isp, ISP_LOGERR,
		    "data overrun for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_DATAOVR);
		}
		return;

	case RQCS_24XX_DRE:	/* data reassembly error */
		isp_prt(isp, ISP_LOGERR, "data reassembly error for target %d",
		    XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_ABORTED);
		}
		*rp = XS_XFRLEN(xs);
		return;

	case RQCS_24XX_TABORT:	/* aborted by target */
		isp_prt(isp, ISP_LOGERR, "target %d sent ABTS",
		    XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_ABORTED);
		}
		return;

	case RQCS_DATA_UNDERRUN:
		ru_marked = (sp->req_scsi_status & RQCS_RU) != 0;
		/*
		 * We can get an underrun w/o things being marked 
		 * if we got a non-zero status.
		 */
		sv_marked = (sp->req_scsi_status & (RQCS_SV|RQCS_RV)) != 0;
		if ((ru_marked == 0 && sv_marked == 0) ||
		    (sp->req_resid > XS_XFRLEN(xs))) {
			isp_prt(isp, ISP_LOGWARN, bun, XS_TGT(xs),
			    XS_LUN(xs), XS_XFRLEN(xs), sp->req_resid,
			    (ru_marked)? "marked" : "not marked");
			if (XS_NOERR(xs)) {
				XS_SETERR(xs, HBA_BOTCH);
			}
			return;
		}
		XS_RESID(xs) = sp->req_resid;
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0,
		    "%d.%d.%d data underrun (%d) for command 0x%x",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),
		    sp->req_resid, XS_CDBP(xs)[0] & 0xff);
#endif
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_NOERROR);
		}
		return;

	case RQCS_PORT_UNAVAILABLE:
		/*
		 * No such port on the loop. Moral equivalent of SELTIMEO
		 */
	case RQCS_PORT_LOGGED_OUT:
	{
		const char *reason;
		u_int8_t sts = sp->req_completion_status & 0xff;

		/*
		 * It was there (maybe)- treat as a selection timeout.
		 */
		if (sts == RQCS_PORT_UNAVAILABLE) {
			reason = "unavailable";
		} else {
			reason = "logout";
		}

		isp_prt(isp, ISP_LOGINFO, "port %s for target %d",
		    reason, XS_TGT(xs));

		/*
		 * If we're on a local loop, force a LIP (which is overkill)
		 * to force a re-login of this unit. If we're on fabric,
		 * then we'll have to log in again as a matter of course.
		 */
		if (FCPARAM(isp)->isp_topo == TOPO_NL_PORT ||
		    FCPARAM(isp)->isp_topo == TOPO_FL_PORT) {
			mbreg_t mbs;
			MEMZERO(&mbs, sizeof (mbs));
			mbs.param[0] = MBOX_INIT_LIP;
			if (FCPARAM(isp)->isp_2klogin) {
				mbs.ibits = (1 << 10);
			}
			mbs.logval = MBLOGALL;
			isp_mboxcmd_qnw(isp, &mbs, 1);
		}
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
		}
		return;
	}
	case RQCS_PORT_CHANGED:
		isp_prt(isp, ISP_LOGWARN,
		    "port changed for target %d", XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
		}
		return;


	case RQCS_24XX_ENOMEM:	/* f/w resource unavailable */
		isp_prt(isp, ISP_LOGWARN,
		    "f/w resource unavailable for target %d", XS_TGT(xs));
		if (XS_NOERR(xs)) {
			*XS_STSP(xs) = SCSI_BUSY;
			XS_SETERR(xs, HBA_TGTBSY);
		}
		return;

	case RQCS_24XX_TMO:	/* task management overrun */
		isp_prt(isp, ISP_LOGWARN,
		    "command for target %d overlapped task management",
		    XS_TGT(xs));
		if (XS_NOERR(xs)) {
			*XS_STSP(xs) = SCSI_BUSY;
			XS_SETERR(xs, HBA_TGTBSY);
		}
		return;

	default:
		isp_prt(isp, ISP_LOGERR, "Unknown Completion Status 0x%x",
		    sp->req_completion_status);
		break;
	}
	if (XS_NOERR(xs)) {
		XS_SETERR(xs, HBA_BOTCH);
	}
}

void
d5132 2
a5133 6
	if (IS_24XX(isp)) {
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_CLEAR_RISC_INT);
	} else {
		ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
		ISP_WRITE(isp, BIU_SEMA, 0);
	}
d5680 1
a5680 5
	if (IS_24XX(isp)) {
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_SET_HOST_INT);
	} else {
		ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);
	}
d5758 1
a5758 5
	if (IS_24XX(isp)) {
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_SET_HOST_INT);
	} else {
		ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);
	}
d6360 1
a6360 3
	if (IS_24XX(isp)) {
		return (isp_read_nvram_2400(isp));
	} else if (IS_FC(isp)) {
a6427 40
int
isp_read_nvram_2400(struct ispsoftc *isp)
{
	u_int8_t *nvram_data = FCPARAM(isp)->isp_scratch;
	int retval = 0;
	u_int32_t addr, csum, lwrds, *dptr;
	
	if (isp->isp_port) {
		addr = ISP2400_NVRAM_PORT1_ADDR;
	} else {
		addr = ISP2400_NVRAM_PORT0_ADDR;
	}
	
	dptr = (u_int32_t *) nvram_data;
	for (lwrds = 0; lwrds < ISP2400_NVRAM_SIZE >> 2; lwrds++) {
		isp_rd_2400_nvram(isp, addr++, dptr++);
	}
	if (nvram_data[0] != 'I' || nvram_data[1] != 'S' ||
	    nvram_data[2] != 'P') {
		isp_prt(isp, ISP_LOGWARN, "invalid NVRAM header (%x %x %x)",
		    nvram_data[0], nvram_data[1], nvram_data[2]);
		retval = -1;
		goto out;
	}
	dptr = (u_int32_t *) nvram_data;
	for (csum = 0, lwrds = 0; lwrds < ISP2400_NVRAM_SIZE >> 2; lwrds++) {
		u_int32_t tmp;
		ISP_IOXGET_32(isp, &dptr[lwrds], tmp);
		csum += tmp;
	}
	if (csum != 0) {
		isp_prt(isp, ISP_LOGWARN, "invalid NVRAM checksum");
		retval = -1;
		goto out;
	}
	isp_parse_nvram_2400(isp, nvram_data);
out:
	return (retval);
}

a6499 23
isp_rd_2400_nvram(struct ispsoftc *isp, u_int32_t addr, u_int32_t *rp)
{
	int loops = 0;
	const u_int32_t base = 0x7ffe0000;
	u_int32_t tmp = 0;

	ISP_WRITE(isp, BIU2400_FLASH_ADDR, base | addr);
	for (loops = 0; loops < 5000; loops++) {
		USEC_DELAY(10);
		tmp = ISP_READ(isp, BIU2400_FLASH_ADDR);
		if ((tmp & (1U << 31)) != 0) {
			break;
		}
	}
	if (tmp & (1U << 31)) {
		*rp = ISP_READ(isp, BIU2400_FLASH_DATA);
		ISP_SWIZZLE_NVRAM_LONG(isp, rp);
	} else {
		*rp = 0xffffffff;
	}
}

void
a6931 60
void
isp_parse_nvram_2400(struct ispsoftc *isp, u_int8_t *nvram_data)
{
	fcparam *fcp = FCPARAM(isp);
	u_int64_t wwn;

#ifndef SMALL_KERNEL
	isp_prt(isp, ISP_LOGDEBUG0,
	    "NVRAM 0x%08x%08x 0x%08x%08x exchg_cnt %d maxframelen %d",
	    (u_int32_t) (ISP2400_NVRAM_NODE_NAME(nvram_data) >> 32),
	    (u_int32_t) (ISP2400_NVRAM_NODE_NAME(nvram_data)),
	    (u_int32_t) (ISP2400_NVRAM_PORT_NAME(nvram_data) >> 32),
	    (u_int32_t) (ISP2400_NVRAM_PORT_NAME(nvram_data)),
	    ISP2400_NVRAM_EXCHANGE_COUNT(nvram_data),
	    ISP2400_NVRAM_MAXFRAMELENGTH(nvram_data));
	isp_prt(isp, ISP_LOGDEBUG0,
	    "NVRAM execthr %d loopid %d fwopt1 0x%x fwopt2 0x%x fwopt3 0x%x",
	    ISP2400_NVRAM_EXECUTION_THROTTLE(nvram_data),
	    ISP2400_NVRAM_HARDLOOPID(nvram_data),
	    ISP2400_NVRAM_FIRMWARE_OPTIONS1(nvram_data),
	    ISP2400_NVRAM_FIRMWARE_OPTIONS2(nvram_data),
	    ISP2400_NVRAM_FIRMWARE_OPTIONS3(nvram_data));
#endif

	wwn = ISP2400_NVRAM_PORT_NAME(nvram_data);
	if (wwn) {
		if ((wwn >> 60) != 2 && (wwn >> 60) != 5) {
			wwn = 0;
		}
	}
	fcp->isp_wwpn_nvram = wwn;

	wwn = ISP2400_NVRAM_NODE_NAME(nvram_data);
	if (wwn) {
		if ((wwn >> 60) != 2 && (wwn >> 60) != 5) {
			wwn = 0;
		}
	}
	fcp->isp_wwnn_nvram = wwn;

	isp_fix_nvram_wwns(isp);

	if (ISP2400_NVRAM_EXCHANGE_COUNT(nvram_data)) {
		fcp->isp_maxalloc = ISP2400_NVRAM_EXCHANGE_COUNT(nvram_data);
	}
	if ((isp->isp_confopts & ISP_CFG_OWNFSZ) == 0) {
		fcp->isp_maxfrmlen = ISP2400_NVRAM_MAXFRAMELENGTH(nvram_data);
	}
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0) {
		fcp->isp_loopid = ISP2400_NVRAM_HARDLOOPID(nvram_data);
	}
	if ((isp->isp_confopts & ISP_CFG_OWNEXCTHROTTLE) == 0) {
		fcp->isp_execthrottle =
			ISP2400_NVRAM_EXECUTION_THROTTLE(nvram_data);
	}
	fcp->isp_fwoptions = ISP2400_NVRAM_FIRMWARE_OPTIONS1(nvram_data);
	fcp->isp_xfwoptions = ISP2400_NVRAM_FIRMWARE_OPTIONS2(nvram_data);
	fcp->isp_zfwoptions = ISP2400_NVRAM_FIRMWARE_OPTIONS3(nvram_data);
}

a7246 3
	else if (IS_24XX(isp))
		isp_prt(isp, ISP_LOGERR, "24XX dump method undefined");

@


1.51
log
@The firmware we use for the 1020/1020A (SBUS) cards doesn't seem to implement
the commands necessary to do "big" SCSI commands (e.g. READ_CAPACITY_16).
Bail out early on those cards instead of attempting to execute the
unimplemented firmware command and failing to recover from it.

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.50 2010/11/20 05:12:38 deraadt Exp $ */
d812 1
d816 1
d875 1
d879 1
d994 1
d996 1
d1115 1
d1118 1
d1530 1
d1535 1
d1769 1
d1776 1
d1780 1
d1785 1
d1807 1
d1811 1
d1827 1
d1831 1
d1991 1
d1998 1
d2002 1
d2007 1
d2052 1
d2057 1
d2061 1
d2077 1
d2093 1
d2097 1
d2180 1
d2184 1
d2211 1
d2215 1
d2272 1
d2276 1
d2280 1
d2284 1
d2327 1
d2331 1
d2335 1
d2339 1
d2549 1
d2554 1
d2944 1
d2946 1
d3184 1
d3186 1
d3237 1
d3239 1
d3265 1
d3269 1
d3288 1
d3293 1
d3312 1
d3316 1
d3324 1
d3328 1
d3996 1
d4000 1
d4153 1
d4156 1
d4183 1
d4185 1
d4332 1
d4334 1
d4355 1
d4360 1
d4796 1
d4800 1
d4840 1
d4845 1
d4852 1
d4857 1
d4866 1
d4871 1
d4933 1
d4936 1
d5074 1
d5078 1
d5096 1
d5099 1
d5204 1
d5206 1
d5523 1
d5525 1
d5528 1
d5530 1
d5551 1
d5554 1
d5577 1
d5579 1
d5582 1
d5584 1
d5643 1
d5647 1
d5875 1
d5879 1
d6113 1
d6118 1
d6214 1
d6217 1
d6877 1
d6880 1
d6922 1
d6925 1
d7063 1
d7066 1
d7122 1
d7127 1
d7248 1
d7257 1
d7304 1
d7309 1
d7527 1
d7530 1
d7766 1
d7775 1
d7822 1
d7827 1
d7882 1
d7891 1
d7918 1
d7923 1
d7978 1
d7987 1
d8013 1
d8018 1
d8117 1
d8130 1
d8133 1
d8137 1
d8146 1
d8162 1
@


1.50
log
@clean up cases of ;;
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.49 2010/02/20 12:39:41 sobrado Exp $ */
d4057 12
@


1.49
log
@minor tweak to improve consistency with other drivers; startup
messages are usually lower case (exceptions are manufacturer codenames
as "Pentium" or "Horse").
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.48 2010/02/18 10:16:12 sobrado Exp $ */
d6165 2
a6166 2
		mbs.param[1] = isp->isp_mbxwrk1++;;
		mbs.param[2] = *ptr++;;
d6176 1
a6176 1
		mbs.param[2] = *ptr++;;
@


1.48
log
@improve startup messages displayed by isp(4) in such a way entries
printed by this driver in dmesg are more standard (and short); while
here, fix the capitalization of QLogic.

ok krw@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.47 2009/07/14 18:41:02 miod Exp $ */
d1089 1
a1089 1
	    "Board type %s rev 0x%x, %s firmware rev %d.%d.%d",
@


1.47
log
@Silence ``invalid NVRAM header'' message if the NVRAM header is three zero
bytes (as encountered on sgi).
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.46 2009/06/24 11:00:53 krw Exp $ */
d32 1
a32 1
 * code for the Qlogic ISP SCSI and FC-SCSI adapters.
d1089 1
a1089 1
	    "Board Type %s, Chip Revision 0x%x, %s F/W Revision %d.%d.%d",
d4193 1
a4193 1
		 * The Qlogic drivers seem be happy not to use a tag,
d4267 1
a4267 1
	 * so that the Qlogic F/W understands what is being asked of it.
d7934 1
a7934 1
	 * Qlogic WWNs have an NAA of 2, but usually nothing shows up in
@


1.46
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.45 2009/06/03 05:11:09 krw Exp $ */
d7399 4
a7402 1
			isp_prt(isp, ISP_LOGWARN, "invalid NVRAM header");
@


1.45
log
@mjacob took kettenis's r1.44 into FreeBSD and added a tweak to
ensure lvdmode is set. Apply that tweak.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.44 2008/07/17 23:08:08 kettenis Exp $ */
d3 27
d32 1
a32 26
 * code for the QLogic ISP SCSI adapters.
 *
 * Copyright (c) 1997, 1998, 1999, 2000, 2001 by Matthew Jacob
 * Feral Software
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a43 1

d45 2
d50 2
d69 3
d76 3
a78 20
static const char portshift[] =
    "Target %d Loop ID 0x%x (Port 0x%x) => Loop 0x%x (Port 0x%x)";
static const char portdup[] =
    "Target %d duplicates Target %d- killing off both";
static const char retained[] =
    "Retaining Loop ID 0x%x for Target %d (Port 0x%x)";
static const char lretained[] =
    "Retained login of Target %d (Loop ID 0x%x) Port 0x%x";
static const char plogout[] =
    "Logging out Target %d at Loop ID 0x%x (Port 0x%x)";
static const char plogierr[] =
    "Command Error in PLOGI for Port 0x%x (0x%x)";
static const char nopdb[] =
    "Could not get PDB for Device @@ Port 0x%x";
static const char pdbmfail1[] =
    "PDB Loop ID info for Device @@ Port 0x%x does not match up (0x%x)";
static const char pdbmfail2[] =
    "PDB Port info for Device @@ Port 0x%x does not match up (0x%x)";
static const char ldumped[] =
    "Target %d (Loop ID 0x%x) Port 0x%x dumped after login info mismatch";
d90 3
a92 3
    "Loop ID %d, AL_PA 0x%x, Port ID 0x%x, Loop State 0x%x, Topology '%s'";
static const char swrej[] =
    "Fabric Nameserver rejected %s (Reason=0x%x Expl=0x%x) for Port ID 0x%x";
d94 1
a94 1
    "(%d.%d.%d): FIN dl%d resid %lu STS 0x%x SKEY %c XS_ERR=0x%x";
d108 48
a155 34
static int isp_parse_async(struct ispsoftc *, u_int16_t);
static int isp_handle_other_response(struct ispsoftc *, int, isphdr_t *,
    u_int16_t *);
static void
isp_parse_status(struct ispsoftc *, ispstatusreq_t *, XS_T *);
static void isp_fastpost_complete(struct ispsoftc *, u_int16_t);
static int isp_mbox_continue(struct ispsoftc *);
static void isp_scsi_init(struct ispsoftc *);
static void isp_scsi_channel_init(struct ispsoftc *, int);
static void isp_fibre_init(struct ispsoftc *);
static void isp_mark_getpdb_all(struct ispsoftc *);
static int isp_getmap(struct ispsoftc *, fcpos_map_t *);
static int isp_getpdb(struct ispsoftc *, int, isp_pdb_t *);
static u_int64_t isp_get_portname(struct ispsoftc *, int, int);
static int isp_fclink_test(struct ispsoftc *, int);
static char *isp2100_fw_statename(int);
static int isp_pdb_sync(struct ispsoftc *);
static int isp_scan_loop(struct ispsoftc *);
static int isp_fabric_mbox_cmd(struct ispsoftc *, mbreg_t *);
static int isp_scan_fabric(struct ispsoftc *, int);
static void isp_register_fc4_type(struct ispsoftc *);
static void isp_fw_state(struct ispsoftc *);
static void isp_mboxcmd_qnw(struct ispsoftc *, mbreg_t *, int);
static void isp_mboxcmd(struct ispsoftc *, mbreg_t *, int);

static void isp_update(struct ispsoftc *);
static void isp_update_bus(struct ispsoftc *, int);
static void isp_setdfltparm(struct ispsoftc *, int);
static int isp_read_nvram(struct ispsoftc *);
static void isp_rdnvram_word(struct ispsoftc *, int, u_int16_t *);
static void isp_parse_nvram_1020(struct ispsoftc *, u_int8_t *);
static void isp_parse_nvram_1080(struct ispsoftc *, int, u_int8_t *);
static void isp_parse_nvram_12160(struct ispsoftc *, int, u_int8_t *);
static void isp_parse_nvram_2100(struct ispsoftc *, u_int8_t *);
d169 1
a169 1
	u_int16_t code_org;
d171 2
a172 1
	char *btype = "????";
d212 6
a217 1
			ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
d220 2
a221 1
			isp_mboxcmd(isp, &mbs, MBLOGNONE);
d231 28
a258 1
	DISABLE_INTS(isp);
d264 8
a271 1
	if (IS_23XX(isp)) {
d287 7
a293 1
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
d309 6
d318 12
a329 8
		/*
		 * While we're paused, reset the FPM module and FBM fifos.
		 */
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_FPM0_REGS);
		ISP_WRITE(isp, FPM_DIAG_CONFIG, FPM_SOFT_RESET);
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_FB_REGS);
		ISP_WRITE(isp, FBM_CMD, FBMCMD_FIFO_RESET_ALL);
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_RISC_REGS);
a511 2
again:

d533 38
d595 5
a599 1
			if (!(ISP_READ(isp, BIU_ICR) & BIU_ICR_SOFT_RESET))
d601 1
d609 1
d621 1
a621 1
	} else {
d628 9
a636 4
	ISP_WRITE(isp, HCCR, HCCR_CMD_RESET);
	USEC_DELAY(100);
	/* Clear semaphore register (just to be sure) */
	ISP_WRITE(isp, BIU_SEMA, 0);
d638 1
d640 1
a640 3
	 * Establish some initial burst rate stuff.
	 * (only for the 1XX0 boards). This really should
	 * be done later after fetching from NVRAM.
d642 14
a655 1
	if (IS_SCSI(isp)) {
d668 8
a675 5
#ifdef	PTI_CARDS
		if (((sdparam *) isp->isp_param)->isp_ultramode) {
			while (ISP_READ(isp, RISC_MTR) != 0x1313) {
				ISP_WRITE(isp, RISC_MTR, 0x1313);
				ISP_WRITE(isp, HCCR, HCCR_CMD_STEP);
d677 4
d684 1
a684 7
		/*
		 * PTI specific register
		 */
		ISP_WRITE(isp, RISC_EMB, DUAL_BANK)
#else
		ISP_WRITE(isp, RISC_MTR, 0x1212);
#endif
d690 1
d693 5
a697 1
	ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE); /* release paused processor */
d710 2
a711 2
	if (IS_23XX(isp)) {
		USEC_DELAY(5);
d717 1
d736 2
a737 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d739 1
d743 1
a743 1
	if (IS_SCSI(isp)) {
d751 4
a754 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d756 1
d762 1
d786 3
a788 1
	if (IS_23XX(isp))
d790 1
a790 1
	else
d792 125
d918 42
a959 3
	if (dodnld) {
		isp->isp_mbxworkp = (void *) &isp->isp_mdvec->dv_ispfw[1];
		isp->isp_mbxwrk0 = isp->isp_mdvec->dv_ispfw[3] - 1;
d964 3
a966 2
		mbs.param[2] = isp->isp_mdvec->dv_ispfw[0];
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
d971 2
a972 2
			dodnld = 0;
			goto again;
d980 2
a981 1
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
d983 2
a984 1
			isp_prt(isp, ISP_LOGERR, "Ram Checksum Failure");
d1002 1
d1004 28
a1031 2
	mbs.param[1] = code_org;
	isp_mboxcmd(isp, &mbs, MBLOGNONE);
d1033 1
a1033 1
	 * Give it a chance to start.
d1035 1
a1035 1
	USEC_DELAY(500);
d1045 2
a1046 1
			isp_mboxcmd(isp, &mbs, MBLOGALL);
d1053 2
a1054 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d1056 7
d1087 2
a1088 1
	isp_prt(isp, ISP_LOGCONFIG,
d1099 1
a1099 1
		 * Note that all 22XX and 23XX f/w is greater than 1.X.0.
d1101 1
a1101 1
		if (!(ISP_FW_NEWER_THAN(isp, 1, 17, 0))) {
d1112 21
a1132 3
		if (ISP_READ(isp, BIU2100_CSR) & BIU2100_PCI64) {
			isp_prt(isp, ISP_LOGCONFIG,
			    "Installed in 64-Bit PCI slot");
d1143 12
a1154 5
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_GET_FIRMWARE_STATUS;
	isp_mboxcmd(isp, &mbs, MBLOGALL);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
d1156 2
a1157 3
	isp->isp_maxcmds = mbs.param[2];
	isp_prt(isp, ISP_LOGINFO,
	    "%d max I/O commands supported", mbs.param[2]);
a1159 7
	/*
	 * Set up DMA for the request and result mailboxes.
	 */
	if (ISP_MBOXDMASETUP(isp) != 0) {
		isp_prt(isp, ISP_LOGERR, "Cannot setup DMA");
		return;
	}
d1190 1
a1190 1
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
d1196 12
a1218 7
	/*
	 * Must do this first to get defaults established.
	 */
	isp_setdfltparm(isp, 0);
	if (IS_DUALBUS(isp)) {
		isp_setdfltparm(isp, 1);
	}
d1220 14
a1233 1
		isp_fibre_init(isp);
d1239 1
a1239 1
static void
d1277 2
a1278 2

	isp_mboxcmd(isp, &mbs, MBLOGALL);
d1290 2
a1291 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d1307 2
a1308 2

	isp_mboxcmd(isp, &mbs, MBLOGNONE);
d1328 2
a1329 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d1343 2
a1344 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d1367 2
a1368 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d1382 2
a1383 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d1395 2
a1396 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d1408 2
a1409 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
a1433 1
#ifndef	ISP_NO_FASTPOST
a1436 1
#endif
d1439 2
a1440 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d1453 1
a1453 1
static void
d1469 2
a1470 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d1526 2
a1527 1
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
d1535 2
a1536 1
			isp_mboxcmd(isp, &mbs, MBLOGALL);
d1560 2
a1561 1
			isp_mboxcmd(isp, &mbs, MBLOGALL);
a1577 2
 *
 * Locks are held before coming here.
d1579 1
a1579 1
static void
d1585 1
a1585 1
	int loopid;
a1589 15
	/*
	 * Do this *before* initializing the firmware.
	 */
	isp_mark_getpdb_all(isp);
	fcp->isp_fwstate = FW_CONFIG_WAIT;
	fcp->isp_loopstate = LOOP_NIL;

	/*
	 * If we have no role (neither target nor initiator), return.
	 */
	if (isp->isp_role == ISP_ROLE_NONE) {
		return;
	}

	loopid = fcp->isp_loopid;
d1592 1
d1604 2
a1605 2
	if ((isp->isp_type == ISP_HA_FC_2100) && isp->isp_revision < 5) {
		fcp->isp_fwoptions &= ~ICBOPT_FAIRNESS;
d1614 1
a1614 1
		fcp->isp_fwoptions |= ICBOPT_FULL_LOGIN;
d1620 1
a1620 1
	fcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;
d1626 7
a1632 1
		fcp->isp_fwoptions |= ICBOPT_TGT_ENABLE;
d1634 1
a1634 1
		fcp->isp_fwoptions &= ~ICBOPT_TGT_ENABLE;
a1636 4
	/*
	 * Propagate all of this into the ICB structure.
	 */
	icbp->icb_fwoptions = fcp->isp_fwoptions;
d1660 15
a1674 1
	icbp->icb_hardaddr = loopid;
d1700 3
a1702 1
		if (IS_23XX(isp)) {
a1707 3
			 *
			 * If we set ZIO, it will disable fast posting,
			 * so we don't need to clear it in fwoptions.
d1709 6
a1714 10
			icbp->icb_xfwoptions |= ICBXOPT_ZIO;
#if	0
			/*
			 * Values, in 100us increments. The default
			 * is 2 (200us) if a value 0 (default) is
			 * selected.
			 */
			icbp->icb_idelaytimer = 2;
#endif

d1722 3
a1727 20
#ifndef	ISP_NO_RIO_FC
	/*
	 * RIO seems to be enabled in 2100s for fw >= 1.17.0.
	 *
	 * I've had some questionable problems with RIO on 2200.
	 * More specifically, on a 2204 I had problems with RIO
	 * on a Linux system where I was dropping commands right
	 * and left. It's not clear to me what the actual problem
	 * was.
	 *
	 * 23XX Cards do not support RIO. Instead they support ZIO.
	 */
#if	0
	if (!IS_23XX(isp) && ISP_FW_NEWER_THAN(isp, 1, 17, 0)) {
		icbp->icb_xfwoptions |= ICBXOPT_RIO_16BIT;
		icbp->icb_racctimer = 4;
		icbp->icb_idelaytimer = 8;
	}
#endif
#endif
d1730 1
a1730 1
	 * For 22XX > 2.1.26 && 23XX, set someoptions.
d1744 5
a1748 9
		isp_mboxcmd(isp, &mbs, MBLOGALL);
	}
	icbp->icb_logintime = 30;	/* 30 second login timeout */

	if (IS_23XX(isp)) {
		ISP_WRITE(isp, isp->isp_rqstinrp, 0);
        	ISP_WRITE(isp, isp->isp_rqstoutrp, 0);
        	ISP_WRITE(isp, isp->isp_respinrp, 0);
		ISP_WRITE(isp, isp->isp_respoutrp, 0);
d1750 2
d1765 7
d1773 2
a1774 2
		isp_prt(isp, ISP_LOGDEBUG1, "Not using any WWNs");
		icbp->icb_fwoptions &= ~(ICBOPT_BOTH_WWNS|ICBOPT_FULL_LOGIN);
d1777 3
d1781 3
d1792 1
d1809 2
d1812 4
a1815 3
	    fcp->isp_scratch, (uint32_t) ((uint64_t)fcp->isp_scdma >> 32),
	    (uint32_t) fcp->isp_scdma);
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d1818 1
d1821 2
a1822 1
	isp->isp_reqidx = isp->isp_reqodx = 0;
a1823 1
	isp->isp_sendmarker = 1;
d1831 2
a1832 9
/*
 * Fibre Channel Support- get the port database for the id.
 *
 * Locks are held before coming here. Return 0 if success,
 * else failure.
 */

static int
isp_getmap(struct ispsoftc *isp, fcpos_map_t *map)
d1834 2
a1835 1
	fcparam *fcp = (fcparam *) isp->isp_param;
d1837 4
d1842 10
a1851 11
 	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_GET_FC_AL_POSITION_MAP;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
	FC_SCRATCH_ACQUIRE(isp);
	isp_mboxcmd(isp, &mbs, MBLOGALL & ~MBOX_COMMAND_PARAM_ERROR);
	if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
		MEMCPY(map, fcp->isp_scratch, sizeof (fcpos_map_t));
		map->fwmap = mbs.param[1] != 0;
		FC_SCRATCH_RELEASE(isp);
		return (0);
a1852 3
	FC_SCRATCH_RELEASE(isp);
	return (-1);
}
d1854 7
a1860 7
static void
isp_mark_getpdb_all(struct ispsoftc *isp)
{
	fcparam *fcp = (fcparam *) isp->isp_param;
	int i;
	for (i = 0; i < MAX_FC_TARG; i++) {
		fcp->portdb[i].valid = fcp->portdb[i].fabric_dev = 0;
a1861 1
}
d1863 5
a1867 5
static int
isp_getpdb(struct ispsoftc *isp, int id, isp_pdb_t *pdbp)
{
	fcparam *fcp = (fcparam *) isp->isp_param;
	mbreg_t mbs;
d1869 9
a1877 13
 	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_GET_PORT_DB;
	mbs.param[1] = id << 8;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
	FC_SCRATCH_ACQUIRE(isp);
	isp_mboxcmd(isp, &mbs, MBLOGALL & ~MBOX_COMMAND_PARAM_ERROR);
	if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
		isp_get_pdb(isp, (isp_pdb_t *)fcp->isp_scratch, pdbp);
		FC_SCRATCH_RELEASE(isp);
		return (0);
a1878 3
	FC_SCRATCH_RELEASE(isp);
	return (-1);
}
d1880 7
a1886 5
static u_int64_t
isp_get_portname(struct ispsoftc *isp, int loopid, int nodename)
{
	u_int64_t wwn = 0;
	mbreg_t mbs;
d1888 13
a1900 16
 	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_GET_PORT_NAME;
	mbs.param[1] = loopid << 8;
	if (nodename)
		mbs.param[1] |= 1;
	isp_mboxcmd(isp, &mbs, MBLOGALL & ~MBOX_COMMAND_PARAM_ERROR);
	if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
		wwn =
		    (((u_int64_t)(mbs.param[2] & 0xff)) << 56) |
		    (((u_int64_t)(mbs.param[2] >> 8))	<< 48) |
		    (((u_int64_t)(mbs.param[3] & 0xff))	<< 40) |
		    (((u_int64_t)(mbs.param[3] >> 8))	<< 32) |
		    (((u_int64_t)(mbs.param[6] & 0xff))	<< 24) |
		    (((u_int64_t)(mbs.param[6] >> 8))	<< 16) |
		    (((u_int64_t)(mbs.param[7] & 0xff))	<<  8) |
		    (((u_int64_t)(mbs.param[7] >> 8)));
a1901 2
	return (wwn);
}
d1903 1
a1903 3
/*
 * Make sure we have good FC link and know our Loop ID.
 */
d1905 9
a1913 16
static int
isp_fclink_test(struct ispsoftc *isp, int usdelay)
{
	static char *toponames[] = {
		"Private Loop",
		"FL Port",
		"N-Port to N-Port",
		"F Port",
		"F Port (no FLOGI_ACC response)"
	};
	mbreg_t mbs;
	int count, check_for_fabric;
	u_int8_t lwfs;
	fcparam *fcp;
	struct lportdb *lp;
	isp_pdb_t pdb;
d1915 19
a1933 1
	fcp = isp->isp_param;
d1935 13
a1947 3
	/*
	 * XXX: Here is where we would start a 'loop dead' timeout
	 */
d1949 11
a1959 9
	/*
	 * Wait up to N microseconds for F/W to go to a ready state.
	 */
	lwfs = FW_CONFIG_WAIT;
	count = 0;
	while (count < usdelay) {
		u_int64_t enano;
		u_int32_t wrk;
		NANOTIME_T hra, hrb;
d1961 4
a1964 12
		GET_NANOTIME(&hra);
		isp_fw_state(isp);
		if (lwfs != fcp->isp_fwstate) {
			isp_prt(isp, ISP_LOGINFO, "Firmware State <%s->%s>",
			    isp2100_fw_statename((int)lwfs),
			    isp2100_fw_statename((int)fcp->isp_fwstate));
			lwfs = fcp->isp_fwstate;
		}
		if (fcp->isp_fwstate == FW_READY) {
			break;
		}
		GET_NANOTIME(&hrb);
d1966 2
a1967 5
		/*
		 * Get the elapsed time in nanoseconds.
		 * Always guaranteed to be non-zero.
		 */
		enano = NANOTIME_SUB(&hrb, &hra);
d1969 13
d1983 30
a2012 3
		    "usec%d: 0x%lx->0x%lx enano 0x%x%08x",
		    count, (long) GET_NANOSEC(&hra), (long) GET_NANOSEC(&hrb),
		    (u_int32_t)(enano >> 32), (u_int32_t)(enano & 0xffffffff));
d2014 7
a2020 26
		/*
		 * If the elapsed time is less than 1 millisecond,
		 * delay a period of time up to that millisecond of
		 * waiting.
		 *
		 * This peculiar code is an attempt to try and avoid
		 * invoking u_int64_t math support functions for some
		 * platforms where linkage is a problem.
		 */
		if (enano < (1000 * 1000)) {
			count += 1000;
			enano = (1000 * 1000) - enano;
			while (enano > (u_int64_t) 4000000000U) {
				USEC_SLEEP(isp, 4000000);
				enano -= (u_int64_t) 4000000000U;
			}
			wrk = enano;
			wrk /= 1000;
			USEC_SLEEP(isp, wrk);
		} else {
			while (enano > (u_int64_t) 4000000000U) {
				count += 4000000;
				enano -= (u_int64_t) 4000000000U;
			}
			wrk = enano;
			count += (wrk / 1000);
d2022 12
d2035 5
d2041 10
a2050 5
	/*
	 * If we haven't gone to 'ready' state, return.
	 */
	if (fcp->isp_fwstate != FW_READY) {
		return (-1);
d2052 3
d2057 1
a2057 1
	 * Get our Loop ID (if possible). We really need to have it.
d2060 13
a2072 2
	mbs.param[0] = MBOX_GET_LOOP_ID;
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d2074 1
a2074 1
		return (-1);
d2076 3
a2078 10
	fcp->isp_loopid = mbs.param[1];
	if (IS_2200(isp) || IS_23XX(isp)) {
		int topo = (int) mbs.param[6];
		if (topo < TOPO_NL_PORT || topo > TOPO_PTP_STUB)
			topo = TOPO_PTP_STUB;
		fcp->isp_topo = topo;
	} else {
		fcp->isp_topo = TOPO_NL_PORT;
	}
	fcp->isp_portid = fcp->isp_alpa = mbs.param[2] & 0xff;
d2081 1
a2081 4
	 * Check to see if we're on a fabric by trying to see if we
	 * can talk to the fabric name server. This can be a bit
	 * tricky because if we're a 2100, we should check always
	 * (in case we're connected to a server doing aliasing).
d2083 8
a2090 1
	fcp->isp_onfabric = 0;
d2092 3
a2094 7
	if (IS_2100(isp)) {
		/*
		 * Don't bother with fabric if we are using really old
		 * 2100 firmware. It's just not worth it.
		 */
		if (ISP_FW_NEWER_THAN(isp, 1, 15, 37)) {
			check_for_fabric = 1;
d2096 868
a2963 1
			check_for_fabric = 0;
a2964 5
	} else if (fcp->isp_topo == TOPO_FL_PORT ||
	    fcp->isp_topo == TOPO_F_PORT) {
		check_for_fabric = 1;
	} else
		check_for_fabric = 0;
d2966 24
a2989 4
	if (check_for_fabric && isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {
		int loopid = FL_PORT_ID;
		if (IS_2100(isp)) {
			fcp->isp_topo = TOPO_FL_PORT;
d2992 58
a3049 1
		if (BITS2WORD(pdb.pdb_portid_bits) == 0) {
d3051 2
a3052 1
			 * Crock.
d3054 14
a3067 2
			fcp->isp_topo = TOPO_NL_PORT;
			goto not_on_fabric;
a3068 1
		fcp->isp_portid = mbs.param[2] | ((int) mbs.param[3] << 16);
d3071 2
a3072 1
		 * Save the Fabric controller's port database entry.
d3074 145
a3218 31
		lp = &fcp->portdb[loopid];
		lp->node_wwn =
		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_nodename[7]));
		lp->port_wwn =
		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_portname[7]));
		lp->roles =
		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
		lp->portid = BITS2WORD(pdb.pdb_portid_bits);
		lp->loopid = pdb.pdb_loopid;
		lp->loggedin = lp->valid = 1;
		fcp->isp_onfabric = 1;
		(void) isp_async(isp, ISPASYNC_PROMENADE, &loopid);
		isp_register_fc4_type(isp);
	} else {
not_on_fabric:
		fcp->isp_onfabric = 0;
		fcp->portdb[FL_PORT_ID].valid = 0;
d3220 1
d3222 40
a3261 13
	fcp->isp_gbspeed = 1;
	if (IS_23XX(isp)) {
 		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_GET_SET_DATA_RATE;
		mbs.param[1] = MBGSD_GET_RATE;
		/* mbs.param[2] undefined if we're just getting rate */
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			if (mbs.param[1] == MBGSD_TWOGB) {
				isp_prt(isp, ISP_LOGINFO, "2Gb link speed/s");
				fcp->isp_gbspeed = 2;
			}
		}
d3264 4
a3267 20
	isp_prt(isp, ISP_LOGCONFIG, topology, fcp->isp_loopid, fcp->isp_alpa,
	    fcp->isp_portid, fcp->isp_loopstate, toponames[fcp->isp_topo]);

	/*
	 * Announce ourselves, too. This involves synthesizing an entry.
	 */
	if (fcp->isp_iid_set == 0) {
		fcp->isp_iid_set = 1;
		fcp->isp_iid = fcp->isp_loopid;
		lp = &fcp->portdb[fcp->isp_iid];
	} else {
		lp = &fcp->portdb[fcp->isp_iid];
		if (fcp->isp_portid != lp->portid ||
		    fcp->isp_loopid != lp->loopid ||
		    fcp->isp_nodewwn != ISP_NODEWWN(isp) ||
		    fcp->isp_portwwn != ISP_PORTWWN(isp)) {
			lp->valid = 0;
			count = fcp->isp_iid;
			(void) isp_async(isp, ISPASYNC_PROMENADE, &count);
		}
d3269 3
a3271 17
	lp->loopid = fcp->isp_loopid;
	lp->portid = fcp->isp_portid;
	lp->node_wwn = ISP_NODEWWN(isp);
	lp->port_wwn = ISP_PORTWWN(isp);
	switch (isp->isp_role) {
	case ISP_ROLE_NONE:
		lp->roles = 0;
		break;
	case ISP_ROLE_TARGET:
		lp->roles = SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT;
		break;
	case ISP_ROLE_INITIATOR:
		lp->roles = SVC3_INI_ROLE >> SVC3_ROLE_SHIFT;
		break;
	case ISP_ROLE_BOTH:
		lp->roles = (SVC3_INI_ROLE|SVC3_TGT_ROLE) >> SVC3_ROLE_SHIFT;
		break;
a3272 3
	lp->loggedin = lp->valid = 1;
	count = fcp->isp_iid;
	(void) isp_async(isp, ISPASYNC_PROMENADE, &count);
d3276 2
a3277 2
static char *
isp2100_fw_statename(int state)
d3279 19
a3297 10
	switch(state) {
	case FW_CONFIG_WAIT:	return "Config Wait";
	case FW_WAIT_AL_PA:	return "Waiting for AL_PA";
	case FW_WAIT_LOGIN:	return "Wait Login";
	case FW_READY:		return "Ready";
	case FW_LOSS_OF_SYNC:	return "Loss Of Sync";
	case FW_ERROR:		return "Error";
	case FW_REINIT:		return "Re-Init";
	case FW_NON_PART:	return "Nonparticipating";
	default:		return "?????";
a3298 1
}
d3300 2
a3301 4
/*
 * Synchronize our soft copy of the port database with what the f/w thinks
 * (with a view toward possibly for a specific target....)
 */
d3303 5
a3307 7
static int
isp_pdb_sync(struct ispsoftc *isp)
{
	struct lportdb *lp;
	fcparam *fcp = isp->isp_param;
	isp_pdb_t pdb;
	int loopid, base, lim;
d3309 11
a3319 6
	/*
	 * Make sure we're okay for doing this right now.
	 */
	if (fcp->isp_loopstate != LOOP_PDB_RCVD &&
	    fcp->isp_loopstate != LOOP_FSCAN_DONE &&
	    fcp->isp_loopstate != LOOP_LSCAN_DONE) {
d3323 11
a3333 6
	if (fcp->isp_topo == TOPO_FL_PORT || fcp->isp_topo == TOPO_NL_PORT ||
	    fcp->isp_topo == TOPO_N_PORT) {
		if (fcp->isp_loopstate < LOOP_LSCAN_DONE) {
			if (isp_scan_loop(isp) != 0) {
				return (-1);
			}
d3335 6
d3342 1
a3342 1
	fcp->isp_loopstate = LOOP_SYNCING_PDB;
d3345 1
a3345 2
	 * If we get this far, we've settled our differences with the f/w
	 * (for local loop device) and we can say that the loop state is ready.
d3347 1
d3349 4
a3352 5
	if (fcp->isp_topo == TOPO_NL_PORT) {
		fcp->loop_seen_once = 1;
		fcp->isp_loopstate = LOOP_READY;
		return (0);
	}
d3355 3
a3357 2
	 * Find all Fabric Entities that didn't make it from one scan to the
	 * next and let the world know they went away. Scan the whole database.
d3359 6
a3364 7
	for (lp = &fcp->portdb[0]; lp < &fcp->portdb[MAX_FC_TARG]; lp++) {
		if (lp->was_fabric_dev && lp->fabric_dev == 0) {
			loopid = lp - fcp->portdb;
			lp->valid = 0;	/* should already be set */
			(void) isp_async(isp, ISPASYNC_PROMENADE, &loopid);
			MEMZERO((void *) lp, sizeof (*lp));
			continue;
a3365 1
		lp->was_fabric_dev = lp->fabric_dev;
a3367 10
	if (fcp->isp_topo == TOPO_FL_PORT)
		base = FC_SNS_ID+1;
	else
		base = 0;

	if (fcp->isp_topo == TOPO_N_PORT)
		lim = 1;
	else
		lim = MAX_FC_TARG;

d3369 1
a3369 3
	 * Now log in any fabric devices that the outer layer has
	 * left for us to see. This seems the most sane policy
	 * for the moment.
d3371 7
a3377 3
	for (lp = &fcp->portdb[base]; lp < &fcp->portdb[lim]; lp++) {
		u_int32_t portid;
		mbreg_t mbs;
d3379 2
a3380 4
		loopid = lp - fcp->portdb;
		if (loopid >= FL_PORT_ID && loopid <= FC_SNS_ID) {
			continue;
		}
d3382 11
a3392 137
		/*
		 * Anything here?
		 */
		if (lp->port_wwn == 0) {
			continue;
		}

		/*
		 * Don't try to log into yourself.
		 */
		if ((portid = lp->portid) == fcp->isp_portid) {
			continue;
		}


		/*
		 * If we'd been logged in- see if we still are and we haven't
		 * changed. If so, no need to log ourselves out, etc..
		 *
		 * Unfortunately, our charming QLogic f/w has decided to
		 * return a valid port database entry for a fabric device
		 * that has, in fact, gone away. And it hangs trying to
		 * log it out.
		 */
		if (lp->loggedin && lp->force_logout == 0 &&
		    isp_getpdb(isp, lp->loopid, &pdb) == 0) {
			int nrole;
			u_int64_t nwwnn, nwwpn;
			nwwnn =
			    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
			    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
			    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
			    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
			    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
			    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
			    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
			    (((u_int64_t)pdb.pdb_nodename[7]));
			nwwpn =
			    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
			    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
			    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
			    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
			    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
			    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
			    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
			    (((u_int64_t)pdb.pdb_portname[7]));
			nrole = (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >>
			    SVC3_ROLE_SHIFT;
			if (pdb.pdb_loopid == lp->loopid && lp->portid ==
			    (u_int32_t) BITS2WORD(pdb.pdb_portid_bits) &&
			    nwwnn == lp->node_wwn && nwwpn == lp->port_wwn &&
			    lp->roles == nrole && lp->force_logout == 0) {
				lp->loggedin = lp->valid = 1;
				isp_prt(isp, ISP_LOGCONFIG, lretained,
				    (int) (lp - fcp->portdb),
				    (int) lp->loopid, lp->portid);
				continue;
			}
		}

		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
			return (-1);
		}

		/*
		 * Force a logout if we were logged in.
		 */
		if (lp->loggedin) {
			if (lp->force_logout ||
			    isp_getpdb(isp, lp->loopid, &pdb) == 0) {
				MEMZERO(&mbs, sizeof (mbs));
				mbs.param[0] = MBOX_FABRIC_LOGOUT;
				mbs.param[1] = lp->loopid << 8;
				isp_mboxcmd(isp, &mbs, MBLOGNONE);
				isp_prt(isp, ISP_LOGINFO, plogout,
				    (int) (lp - fcp->portdb), lp->loopid,
				    lp->portid);
			}
			lp->force_logout = lp->loggedin = 0;
			if (fcp->isp_fwstate != FW_READY ||
			    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
				return (-1);
			}
		}

		/*
		 * And log in....
		 */
		loopid = lp - fcp->portdb;
		lp->loopid = FL_PORT_ID;
		do {
			MEMZERO(&mbs, sizeof (mbs));
			mbs.param[0] = MBOX_FABRIC_LOGIN;
			mbs.param[1] = loopid << 8;
			mbs.param[2] = portid >> 16;
			mbs.param[3] = portid & 0xffff;
			isp_mboxcmd(isp, &mbs, MBLOGALL & ~(MBOX_LOOP_ID_USED |
			    MBOX_PORT_ID_USED | MBOX_COMMAND_ERROR));
			if (fcp->isp_fwstate != FW_READY ||
			    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
				return (-1);
			}
			switch (mbs.param[0]) {
			case MBOX_LOOP_ID_USED:
				/*
				 * Try the next available loop id.
				 */
				loopid++;
				break;
			case MBOX_PORT_ID_USED:
				/*
				 * This port is already logged in.
				 * Snaffle the loop id it's using if it's
				 * nonzero, otherwise we're hosed.
				 */
				if (mbs.param[1] != 0) {
					loopid = mbs.param[1];
					isp_prt(isp, ISP_LOGINFO, retained,
					    loopid, (int) (lp - fcp->portdb),
					    lp->portid);
				} else {
					loopid = MAX_FC_TARG;
					break;
				}
				/* FALLTHROUGH */
			case MBOX_COMMAND_COMPLETE:
				lp->loggedin = 1;
				lp->loopid = loopid;
				break;
			case MBOX_COMMAND_ERROR:
				isp_prt(isp, ISP_LOGINFO, plogierr,
				    portid, mbs.param[1]);
				/* FALLTHROUGH */
			case MBOX_ALL_IDS_USED: /* We're outta IDs */
			default:
				loopid = MAX_FC_TARG;
a3394 23
		} while (lp->loopid == FL_PORT_ID && loopid < MAX_FC_TARG);

		/*
		 * If we get here and we haven't set a Loop ID,
		 * we failed to log into this device.
		 */

		if (lp->loopid == FL_PORT_ID) {
			lp->loopid = 0;
			continue;
		}

		/*
		 * Make sure we can get the appropriate port information.
		 */
		if (isp_getpdb(isp, lp->loopid, &pdb) != 0) {
			isp_prt(isp, ISP_LOGWARN, nopdb, lp->portid);
			goto dump_em;
		}

		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
			return (-1);
d3397 7
a3403 54
		if (pdb.pdb_loopid != lp->loopid) {
			isp_prt(isp, ISP_LOGWARN, pdbmfail1,
			    lp->portid, pdb.pdb_loopid);
			goto dump_em;
		}

		if (lp->portid != (u_int32_t) BITS2WORD(pdb.pdb_portid_bits)) {
			isp_prt(isp, ISP_LOGWARN, pdbmfail2,
			    lp->portid, BITS2WORD(pdb.pdb_portid_bits));
			goto dump_em;
		}

		lp->roles =
		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
		lp->node_wwn =
		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_nodename[7]));
		lp->port_wwn =
		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_portname[7]));
		/*
		 * Check to make sure this all makes sense.
		 */
		if (lp->node_wwn && lp->port_wwn) {
			lp->valid = 1;
			loopid = lp - fcp->portdb;
			(void) isp_async(isp, ISPASYNC_PROMENADE, &loopid);
			continue;
		}
dump_em:
		lp->valid = 0;
		isp_prt(isp, ISP_LOGINFO,
		    ldumped, loopid, lp->loopid, lp->portid);
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_FABRIC_LOGOUT;
		mbs.param[1] = lp->loopid << 8;
		mbs.param[2] = 0;
		mbs.param[3] = 0;
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
			return (-1);
a3405 33
	/*
	 * If we get here, we've for sure seen not only a valid loop
	 * but know what is or isn't on it, so mark this for usage
	 * in isp_start.
	 */
	fcp->loop_seen_once = 1;
	fcp->isp_loopstate = LOOP_READY;
	return (0);
}

static int
isp_scan_loop(struct ispsoftc *isp)
{
	struct lportdb *lp;
	fcparam *fcp = isp->isp_param;
	isp_pdb_t pdb;
	int loopid, lim, hival;

	switch (fcp->isp_topo) {
	case TOPO_NL_PORT:
		hival = FL_PORT_ID;
		break;
	case TOPO_N_PORT:
		hival = 2;
		break;
	case TOPO_FL_PORT:
		hival = FC_PORT_ID;
		break;
	default:
		fcp->isp_loopstate = LOOP_LSCAN_DONE;
		return (0);
	}
	fcp->isp_loopstate = LOOP_SCANNING_LOOP;
d3408 6
a3413 7
	 * make sure the temp port database is clean...
	 */
	MEMZERO((void *)fcp->tport, sizeof (fcp->tport));

	/*
	 * Run through the local loop ports and get port database info
	 * for each loop ID.
d3415 5
a3419 3
	 * There's a somewhat unexplained situation where the f/w passes back
	 * the wrong database entity- if that happens, just restart (up to
	 * FL_PORT_ID times).
a3420 2
	for (lim = loopid = 0; loopid < hival; loopid++) {
		lp = &fcp->tport[loopid];
d3422 5
a3426 5
		/*
		 * Don't even try for ourselves...
	 	 */
		if (loopid == fcp->isp_loopid)
			continue;
d3428 8
a3435 10
		lp->node_wwn = isp_get_portname(isp, loopid, 1);
		if (fcp->isp_loopstate < LOOP_SCANNING_LOOP)
			return (-1);
		if (lp->node_wwn == 0)
			continue;
		lp->port_wwn = isp_get_portname(isp, loopid, 0);
		if (fcp->isp_loopstate < LOOP_SCANNING_LOOP)
			return (-1);
		if (lp->port_wwn == 0) {
			lp->node_wwn = 0;
d3440 1
a3440 1
		 * Get an entry....
d3442 3
a3444 3
		if (isp_getpdb(isp, loopid, &pdb) != 0) {
			if (fcp->isp_loopstate < LOOP_SCANNING_LOOP)
				return (-1);
d3447 2
a3448 3
		if (fcp->isp_loopstate < LOOP_SCANNING_LOOP) {
			return (-1);
		}
d3451 4
a3454 2
		 * If the returned database element doesn't match what we
		 * asked for, restart the process entirely (up to a point...).
d3456 4
a3459 3
		if (pdb.pdb_loopid != loopid) {
			loopid = 0;
			if (lim++ < hival) {
d3462 3
a3464 3
			isp_prt(isp, ISP_LOGWARN,
			    "giving up on synchronizing the port database");
			return (-1);
d3468 1
a3468 1
		 * Save the pertinent info locally.
d3470 2
a3471 23
		lp->node_wwn =
		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_nodename[7]));
		lp->port_wwn =
		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_portname[7]));
		lp->roles =
		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
		lp->portid = BITS2WORD(pdb.pdb_portid_bits);
		lp->loopid = pdb.pdb_loopid;
	}
d3473 1
a3473 12
	/*
	 * Mark all of the permanent local loop database entries as invalid
	 * (except our own entry).
	 */
	for (loopid = 0; loopid < hival; loopid++) {
		if (loopid == fcp->isp_iid) {
			fcp->portdb[loopid].valid = 1;
			fcp->portdb[loopid].loopid = fcp->isp_loopid;
			continue;
		}
		fcp->portdb[loopid].valid = 0;
	}
d3475 16
a3490 6
	/*
	 * Now merge our local copy of the port database into our saved copy.
	 * Notify the outer layers of new devices arriving.
	 */
	for (loopid = 0; loopid < hival; loopid++) {
		int i;
d3492 14
a3505 13
		/*
		 * If we don't have a non-zero Port WWN, we're not here.
		 */
		if (fcp->tport[loopid].port_wwn == 0) {
			continue;
		}

		/*
		 * Skip ourselves.
		 */
		if (loopid == fcp->isp_iid) {
			continue;
		}
a3506 9
		/*
		 * For the purposes of deciding whether this is the
		 * 'same' device or not, we only search for an identical
		 * Port WWN. Node WWNs may or may not be the same as
		 * the Port WWN, and there may be multiple different
		 * Port WWNs with the same Node WWN. It would be chaos
		 * to have multiple identical Port WWNs, so we don't
		 * allow that.
		 */
a3507 7
		for (i = 0; i < hival; i++) {
			int j;
			if (fcp->portdb[i].port_wwn == 0)
				continue;
			if (fcp->portdb[i].port_wwn !=
			    fcp->tport[loopid].port_wwn)
				continue;
d3509 4
a3512 4
			 * We found this WWN elsewhere- it's changed
			 * loopids then. We don't change its actual
			 * position in our cached port database- we
			 * just change the actual loop ID we'd use.
d3514 51
a3564 10
			if (fcp->portdb[i].loopid != loopid) {
				isp_prt(isp, ISP_LOGINFO, portshift, i,
				    fcp->portdb[i].loopid,
				    fcp->portdb[i].portid, loopid,
				    fcp->tport[loopid].portid);
			}
			fcp->portdb[i].portid = fcp->tport[loopid].portid;
			fcp->portdb[i].loopid = loopid;
			fcp->portdb[i].valid = 1;
			fcp->portdb[i].roles = fcp->tport[loopid].roles;
d3567 9
a3575 2
			 * Now make sure this Port WWN doesn't exist elsewhere
			 * in the port database.
d3577 33
a3609 4
			for (j = i+1; j < hival; j++) {
				if (fcp->portdb[i].port_wwn !=
				    fcp->portdb[j].port_wwn) {
					continue;
d3611 7
a3617 9
				isp_prt(isp, ISP_LOGWARN, portdup, j, i);
				/*
				 * Invalidate the 'old' *and* 'new' ones.
				 * This is really harsh and not quite right,
				 * but if this happens, we really don't know
				 * who is what at this point.
				 */
				fcp->portdb[i].valid = 0;
				fcp->portdb[j].valid = 0;
a3618 1
			break;
d3621 4
a3624 8
		/*
		 * If we didn't traverse the entire port database,
		 * then we found (and remapped) an existing entry.
		 * No need to notify anyone- go for the next one.
		 */
		if (i < hival) {
			isp_prt(isp, ISP_LOGINFO, retained,
			    fcp->portdb[i].loopid, i, fcp->portdb[i].portid);
d3629 1
a3629 2
		 * We've not found this Port WWN anywhere. It's a new entry.
		 * See if we can leave it where it is (with target == loopid).
d3631 5
a3635 13
		if (fcp->portdb[loopid].port_wwn != 0) {
			for (lim = 0; lim < hival; lim++) {
				if (fcp->portdb[lim].port_wwn == 0)
					break;
			}
			/* "Cannot Happen" */
			if (lim == hival) {
				isp_prt(isp, ISP_LOGWARN, "Remap Overflow");
				continue;
			}
			i = lim;
		} else {
			i = loopid;
d3639 1
a3639 2
		 * NB:	The actual loopid we use here is loopid- we may
		 *	in fact be at a completely different index (target).
d3641 1
a3641 6
		fcp->portdb[i].loopid = loopid;
		fcp->portdb[i].port_wwn = fcp->tport[loopid].port_wwn;
		fcp->portdb[i].node_wwn = fcp->tport[loopid].node_wwn;
		fcp->portdb[i].roles = fcp->tport[loopid].roles;
		fcp->portdb[i].portid = fcp->tport[loopid].portid;
		fcp->portdb[i].valid = 1;
d3644 5
a3648 1
		 * Tell the outside world we've arrived.
d3650 6
a3655 9
		(void) isp_async(isp, ISPASYNC_PROMENADE, &i);
	}

	/*
	 * Now find all previously used targets that are now invalid and
	 * notify the outer layers that they're gone.
	 */
	for (lp = &fcp->portdb[0]; lp < &fcp->portdb[hival]; lp++) {
		if (lp->valid || lp->port_wwn == 0) {
d3659 5
d3665 3
a3667 3
		 * Tell the outside world we've gone
		 * away and erase our pdb entry.
		 *
d3669 12
a3680 7
		loopid = lp - fcp->portdb;
		(void) isp_async(isp, ISPASYNC_PROMENADE, &loopid);
		MEMZERO((void *) lp, sizeof (*lp));
	}
	fcp->isp_loopstate = LOOP_LSCAN_DONE;
	return (0);
}
d3682 12
d3695 9
a3703 8
static int
isp_fabric_mbox_cmd(struct ispsoftc *isp, mbreg_t *mbp)
{
	/* the caller sets up the mailbox */
	isp_mboxcmd(isp, mbp, MBLOGNONE);
	if (mbp->param[0] != MBOX_COMMAND_COMPLETE) {
		if (FCPARAM(isp)->isp_loopstate == LOOP_SCANNING_FABRIC) {
			FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
d3705 22
a3726 29
		if (mbp->param[0] == MBOX_COMMAND_ERROR) {
			char tbuf[16];
			char *m;
			switch (mbp->param[1]) {
			case 1:
				m = "No Loop";
				break;
			case 2:
				m = "Failed to allocate IOCB buffer";
				break;
			case 3:
				m = "Failed to allocate XCB buffer";
				break;
			case 4:
				m = "timeout or transmit failed";
				break;
			case 5:
				m = "no fabric loop";
				break;
			case 6:
				m = "remote device not a target";
				break;
			default:
				SNPRINTF(tbuf, sizeof tbuf, "%x",
				    mbp->param[1]);
				m = tbuf;
				break;
			}
			isp_prt(isp, ISP_LOGERR, "SNS Failed- %s", m);
a3727 1
		return (-1);
d3730 3
a3732 2
	if (FCPARAM(isp)->isp_fwstate != FW_READY ||
	    FCPARAM(isp)->isp_loopstate < LOOP_SCANNING_FABRIC) {
d3735 3
a3737 1
	return(0);
d3740 5
a3744 3
#ifdef	ISP_USE_GA_NXT
static int
isp_scan_fabric(struct ispsoftc *isp, int ftype)
d3746 2
a3747 3
	fcparam *fcp = isp->isp_param;
	u_int32_t portid, first_portid, last_portid;
	int hicap, last_port_same;
d3749 4
a3752 3
	if (fcp->isp_onfabric == 0) {
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		return (0);
d3755 15
a3769 46
	FC_SCRATCH_ACQUIRE(isp);

	/*
	 * Since Port IDs are 24 bits, we can check against having seen
	 * anything yet with this value.
	 */
	last_port_same = 0;
	last_portid = 0xffffffff;	/* not a port */
	first_portid = portid = fcp->isp_portid;
	fcp->isp_loopstate = LOOP_SCANNING_FABRIC;

	for (hicap = 0; hicap < GA_NXT_MAX; hicap++) {
		mbreg_t mbs;
		sns_screq_t *rq;
		sns_ga_nxt_rsp_t *rs0, *rs1;
		struct lportdb lcl;
		u_int8_t sc[SNS_GA_NXT_RESP_SIZE];

		rq = (sns_screq_t *)sc;
		MEMZERO((void *) rq, SNS_GA_NXT_REQ_SIZE);
		rq->snscb_rblen = SNS_GA_NXT_RESP_SIZE >> 1;
		rq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+0x100);
		rq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+0x100);
		rq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+0x100);
		rq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+0x100);
		rq->snscb_sblen = 6;
		rq->snscb_data[0] = SNS_GA_NXT;
		rq->snscb_data[4] = portid & 0xffff;
		rq->snscb_data[5] = (portid >> 16) & 0xff;
		isp_put_sns_request(isp, rq, (sns_screq_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GA_NXT_REQ_SIZE);
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GA_NXT_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
a3771 23
		MEMORYBARRIER(isp, SYNC_SFORCPU, 0x100, SNS_GA_NXT_RESP_SIZE);
		rs1 = (sns_ga_nxt_rsp_t *) sc;
		rs0 = (sns_ga_nxt_rsp_t *) ((u_int8_t *)fcp->isp_scratch+0x100);
		isp_get_ga_nxt_response(isp, rs0, rs1);
		if (rs1->snscb_cthdr.ct_response != FS_ACC) {
			int level;
			if (rs1->snscb_cthdr.ct_reason == 9 &&
			    rs1->snscb_cthdr.ct_explanation == 7)
				level = ISP_LOGDEBUG0;
			else
				level = ISP_LOGWARN;
			isp_prt(isp, level, swrej, "GA_NXT",
			    rs1->snscb_cthdr.ct_reason,
			    rs1->snscb_cthdr.ct_explanation, portid);
			FC_SCRATCH_RELEASE(isp);
			fcp->isp_loopstate = LOOP_FSCAN_DONE;
			return (0);
		}
		portid =
		    (((u_int32_t) rs1->snscb_port_id[0]) << 16) |
		    (((u_int32_t) rs1->snscb_port_id[1]) << 8) |
		    (((u_int32_t) rs1->snscb_port_id[2]));

d3773 1
a3773 2
		 * XXX: We should check to make sure that this entry
		 * XXX: supports the type(s) we are interested in.
d3775 3
a3777 46
		/*
		 * Okay, we now have information about a fabric object.
		 * If it is the type we're interested in, tell the outer layers
		 * about it. The outer layer needs to  know: Port ID, WWNN,
		 * WWPN, FC4 type, and port type.
		 *
		 * The lportdb structure is adequate for this.
		 */
		MEMZERO(&lcl, sizeof (lcl));
		lcl.port_type = rs1->snscb_port_type;
		lcl.fc4_type = ftype;
		lcl.portid = portid;
		lcl.node_wwn =
		    (((u_int64_t)rs1->snscb_nodename[0]) << 56) |
		    (((u_int64_t)rs1->snscb_nodename[1]) << 48) |
		    (((u_int64_t)rs1->snscb_nodename[2]) << 40) |
		    (((u_int64_t)rs1->snscb_nodename[3]) << 32) |
		    (((u_int64_t)rs1->snscb_nodename[4]) << 24) |
		    (((u_int64_t)rs1->snscb_nodename[5]) << 16) |
		    (((u_int64_t)rs1->snscb_nodename[6]) <<  8) |
		    (((u_int64_t)rs1->snscb_nodename[7]));
		lcl.port_wwn =
		    (((u_int64_t)rs1->snscb_portname[0]) << 56) |
		    (((u_int64_t)rs1->snscb_portname[1]) << 48) |
		    (((u_int64_t)rs1->snscb_portname[2]) << 40) |
		    (((u_int64_t)rs1->snscb_portname[3]) << 32) |
		    (((u_int64_t)rs1->snscb_portname[4]) << 24) |
		    (((u_int64_t)rs1->snscb_portname[5]) << 16) |
		    (((u_int64_t)rs1->snscb_portname[6]) <<  8) |
		    (((u_int64_t)rs1->snscb_portname[7]));

		/*
		 * Does this fabric object support the type we want?
		 * If not, skip it.
		 */
		if (rs1->snscb_fc4_types[ftype >> 5] & (1 << (ftype & 0x1f))) {
			if (first_portid == portid) {
				lcl.last_fabric_dev = 1;
			} else {
				lcl.last_fabric_dev = 0;
			}
			(void) isp_async(isp, ISPASYNC_FABRIC_DEV, &lcl);
		} else {
			isp_prt(isp, ISP_LOGDEBUG0,
			    "PortID 0x%x doesn't support FC4 type 0x%x",
			    portid, ftype);
d3779 9
a3787 11
		if (first_portid == portid) {
			fcp->isp_loopstate = LOOP_FSCAN_DONE;
			FC_SCRATCH_RELEASE(isp);
			return (0);
		}
		if (portid == last_portid) {
			if (last_port_same++ > 20) {
				isp_prt(isp, ISP_LOGWARN,
				    "tangled fabric database detected");
				break;
			}
d3789 2
a3790 2
			last_port_same = 0 ;
			last_portid = portid;
d3793 26
a3818 3
	FC_SCRATCH_RELEASE(isp);
	if (hicap >= GA_NXT_MAX) {
		isp_prt(isp, ISP_LOGWARN, "fabric too big (> %d)", GA_NXT_MAX);
a3819 1
	fcp->isp_loopstate = LOOP_FSCAN_DONE;
a3821 3
#else
#define	GIDLEN	((ISP2100_SCRLEN >> 1) + 16)
#define	NGENT	((GIDLEN - 16) >> 2)
d3823 2
a3824 5
#define	IGPOFF	(ISP2100_SCRLEN - GIDLEN)
#define	GXOFF	(256)

static int
isp_scan_fabric(struct ispsoftc *isp, int ftype)
d3826 3
a3828 1
	fcparam *fcp = FCPARAM(isp);
a3829 8
	int i;
	sns_gid_ft_req_t *rq;
	sns_gid_ft_rsp_t *rs0, *rs1;

	if (fcp->isp_onfabric == 0) {
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		return (0);
	}
d3831 11
d3843 1
a3843 15
	fcp->isp_loopstate = LOOP_SCANNING_FABRIC;

	rq = (sns_gid_ft_req_t *)fcp->tport;
	MEMZERO((void *) rq, SNS_GID_FT_REQ_SIZE);
	rq->snscb_rblen = GIDLEN >> 1;
	rq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+IGPOFF);
	rq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+IGPOFF);
	rq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+IGPOFF);
	rq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+IGPOFF);
	rq->snscb_sblen = 6;
	rq->snscb_cmd = SNS_GID_FT;
	rq->snscb_mword_div_2 = NGENT;
	rq->snscb_fc4_type = ftype;
	isp_put_gid_ft_request(isp, rq, (sns_gid_ft_req_t *) fcp->isp_scratch);
	MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GID_FT_REQ_SIZE);
d3846 1
a3846 1
	mbs.param[1] = SNS_GID_FT_REQ_SIZE >> 1;
a3848 4

	/*
	 * Leave 4 and 5 alone
	 */
d3851 8
a3858 5
	if (isp_fabric_mbox_cmd(isp, &mbs)) {
		if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
			fcp->isp_loopstate = LOOP_PDB_RCVD;
		}
		FC_SCRATCH_RELEASE(isp);
d3861 39
a3899 22
	if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
		FC_SCRATCH_RELEASE(isp);
		return (-1);
	}
	MEMORYBARRIER(isp, SYNC_SFORCPU, IGPOFF, GIDLEN);
	rs1 = (sns_gid_ft_rsp_t *) fcp->tport;
	rs0 = (sns_gid_ft_rsp_t *) ((u_int8_t *)fcp->isp_scratch+IGPOFF);
	isp_get_gid_ft_response(isp, rs0, rs1, NGENT);
	if (rs1->snscb_cthdr.ct_response != FS_ACC) {
		int level;
		if (rs1->snscb_cthdr.ct_reason == 9 &&
		    rs1->snscb_cthdr.ct_explanation == 7)
			level = ISP_LOGDEBUG0;
		else
			level = ISP_LOGWARN;
		isp_prt(isp, level, swrej, "GID_FT",
		    rs1->snscb_cthdr.ct_reason,
		    rs1->snscb_cthdr.ct_explanation, 0);
		FC_SCRATCH_RELEASE(isp);
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		return (0);
	}
d3902 1
a3902 4
	 * Okay, we now have a list of Port IDs for this class of device.
	 * Go through the list and for each one get the WWPN/WWNN for it
	 * and tell the outer layers about it. The outer layer needs to
	 * know: Port ID, WWNN, WWPN, FC4 type, and (possibly) port type.
d3904 1
a3904 1
	 * The lportdb structure is adequate for this.
d3906 13
a3918 197
	i = -1;
	do {
		sns_gxn_id_req_t grqbuf, *gq = &grqbuf;
		sns_gxn_id_rsp_t *gs0, grsbuf, *gs1 = &grsbuf;
		struct lportdb lcl;
#if	0
		sns_gff_id_rsp_t *fs0, ffsbuf, *fs1 = &ffsbuf;
#endif

		i++;
		MEMZERO(&lcl, sizeof (lcl));
		lcl.fc4_type = ftype;
		lcl.portid =
		    (((u_int32_t) rs1->snscb_ports[i].portid[0]) << 16) |
		    (((u_int32_t) rs1->snscb_ports[i].portid[1]) << 8) |
		    (((u_int32_t) rs1->snscb_ports[i].portid[2]));

		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
		gq->snscb_rblen = SNS_GXN_ID_RESP_SIZE >> 1;
		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF);
		gq->snscb_sblen = 6;
		gq->snscb_cmd = SNS_GPN_ID;
		gq->snscb_portid = lcl.portid;
		isp_put_gxn_id_request(isp, gq,
		    (sns_gxn_id_req_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE);
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GXN_ID_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GXN_ID_RESP_SIZE);
		gs0 = (sns_gxn_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
		isp_get_gxn_id_response(isp, gs0, gs1);
		if (gs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, ISP_LOGWARN, swrej, "GPN_ID",
			    gs1->snscb_cthdr.ct_reason,
			    gs1->snscb_cthdr.ct_explanation, lcl.portid);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				return (-1);
			}
			continue;
		}
		lcl.port_wwn = 
		    (((u_int64_t)gs1->snscb_wwn[0]) << 56) |
		    (((u_int64_t)gs1->snscb_wwn[1]) << 48) |
		    (((u_int64_t)gs1->snscb_wwn[2]) << 40) |
		    (((u_int64_t)gs1->snscb_wwn[3]) << 32) |
		    (((u_int64_t)gs1->snscb_wwn[4]) << 24) |
		    (((u_int64_t)gs1->snscb_wwn[5]) << 16) |
		    (((u_int64_t)gs1->snscb_wwn[6]) <<  8) |
		    (((u_int64_t)gs1->snscb_wwn[7]));

		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
		gq->snscb_rblen = SNS_GXN_ID_RESP_SIZE >> 1;
		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF);
		gq->snscb_sblen = 6;
		gq->snscb_cmd = SNS_GNN_ID;
		gq->snscb_portid = lcl.portid;
		isp_put_gxn_id_request(isp, gq,
		    (sns_gxn_id_req_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE);
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GXN_ID_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GXN_ID_RESP_SIZE);
		gs0 = (sns_gxn_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
		isp_get_gxn_id_response(isp, gs0, gs1);
		if (gs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, ISP_LOGWARN, swrej, "GNN_ID",
			    gs1->snscb_cthdr.ct_reason,
			    gs1->snscb_cthdr.ct_explanation, lcl.portid);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				return (-1);
			}
			continue;
		}
		lcl.node_wwn = 
		    (((u_int64_t)gs1->snscb_wwn[0]) << 56) |
		    (((u_int64_t)gs1->snscb_wwn[1]) << 48) |
		    (((u_int64_t)gs1->snscb_wwn[2]) << 40) |
		    (((u_int64_t)gs1->snscb_wwn[3]) << 32) |
		    (((u_int64_t)gs1->snscb_wwn[4]) << 24) |
		    (((u_int64_t)gs1->snscb_wwn[5]) << 16) |
		    (((u_int64_t)gs1->snscb_wwn[6]) <<  8) |
		    (((u_int64_t)gs1->snscb_wwn[7]));

		/*
		 * The QLogic f/w is bouncing this with a parameter error.
		 */
#if	0
		/*
		 * Try and get FC4 Features (FC-GS-3 only).
		 * We can use the sns_gxn_id_req_t for this request.
		 */
		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
		gq->snscb_rblen = SNS_GFF_ID_RESP_SIZE >> 1;
		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF);
		gq->snscb_sblen = 6;
		gq->snscb_cmd = SNS_GFF_ID;
		gq->snscb_portid = lcl.portid;
		isp_put_gxn_id_request(isp, gq,
		    (sns_gxn_id_req_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE);
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GXN_ID_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GFF_ID_RESP_SIZE);
		fs0 = (sns_gff_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
		isp_get_gff_id_response(isp, fs0, fs1);
		if (fs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, /* ISP_LOGDEBUG0 */ ISP_LOGWARN,
			    swrej, "GFF_ID",
			    fs1->snscb_cthdr.ct_reason,
			    fs1->snscb_cthdr.ct_explanation, lcl.portid);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				return (-1);
			}
		} else {
			int index = (ftype >> 3);
			int bshft = (ftype & 0x7) * 4;
			int fc4_fval =
			    (fs1->snscb_fc4_features[index] >> bshft) & 0xf;
			if (fc4_fval & 0x1) {
				lcl.roles |=
				    (SVC3_INI_ROLE >> SVC3_ROLE_SHIFT);
			}
			if (fc4_fval & 0x2) {
				lcl.roles |=
				    (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);
			}
		}
#endif
d3920 1
a3920 13
		/*
		 * If we really want to know what kind of port type this is,
		 * we have to run another CT command. Otherwise, we'll leave
		 * it as undefined.
		 *
		lcl.port_type = 0;
		 */
		if (rs1->snscb_ports[i].control & 0x80) {
			lcl.last_fabric_dev = 1;
		} else {
			lcl.last_fabric_dev = 0;
		}
		(void) isp_async(isp, ISPASYNC_FABRIC_DEV, &lcl);
d3922 26
a3947 7
	} while ((rs1->snscb_ports[i].control & 0x80) == 0 && i < NGENT-1);

	/*
	 * If we're not at the last entry, our list isn't big enough.
	 */
	if ((rs1->snscb_ports[i].control & 0x80) == 0) {
		isp_prt(isp, ISP_LOGWARN, "fabric too big for scratch area");
d3950 1
d3952 14
a3965 2
	fcp->isp_loopstate = LOOP_FSCAN_DONE;
	return (0);
a3966 1
#endif
d3968 2
a3969 2
static void
isp_register_fc4_type(struct ispsoftc *isp)
d3971 35
a4005 35
	fcparam *fcp = isp->isp_param;
	u_int8_t local[SNS_RFT_ID_REQ_SIZE];
	sns_screq_t *reqp = (sns_screq_t *) local;
	mbreg_t mbs;

	MEMZERO((void *) reqp, SNS_RFT_ID_REQ_SIZE);
	reqp->snscb_rblen = SNS_RFT_ID_RESP_SIZE >> 1;
	reqp->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma + 0x100);
	reqp->snscb_sblen = 22;
	reqp->snscb_data[0] = SNS_RFT_ID;
	reqp->snscb_data[4] = fcp->isp_portid & 0xffff;
	reqp->snscb_data[5] = (fcp->isp_portid >> 16) & 0xff;
	reqp->snscb_data[6] = (1 << FC4_SCSI);
#if	0
	reqp->snscb_data[6] |= (1 << FC4_IP);	/* ISO/IEC 8802-2 LLC/SNAP */
#endif
	FC_SCRATCH_ACQUIRE(isp);
	isp_put_sns_request(isp, reqp, (sns_screq_t *) fcp->isp_scratch);
	MEMZERO(&mbs, sizeof (mbs));
	mbs.param[0] = MBOX_SEND_SNS;
	mbs.param[1] = SNS_RFT_ID_REQ_SIZE >> 1;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
	/*
	 * Leave 4 and 5 alone
	 */
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
	isp_mboxcmd(isp, &mbs, MBLOGALL);
	FC_SCRATCH_RELEASE(isp);
	if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGDEBUG0, "Register FC4 types succeeded");
d4007 1
d4018 1
a4018 1
	u_int16_t nxti, optr, handle;
d4021 3
a4023 1
	int target, i;
d4062 2
a4063 2
	 * Check to see whether we have good firmware state still or
	 * need to refresh our port database for this target.
d4068 4
a4071 2
		struct lportdb *lp;
#ifdef	HANDLE_LOOPSTATE_IN_OUTER_LAYERS
d4077 3
a4079 84
		/*
		 * If we're not on a Fabric, we can't have a target
		 * above FL_PORT_ID-1.
		 *
		 * If we're on a fabric and *not* connected as an F-port,
		 * we can't have a target less than FC_SNS_ID+1. This
		 * keeps us from having to sort out the difference between
		 * local public loop devices and those which we might get
		 * from a switch's database.
		 */
		if (fcp->isp_onfabric == 0) {
			if (target >= FL_PORT_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
		} else {
			if (target >= FL_PORT_ID && target <= FC_SNS_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
			/*
			 * We used to exclude having local loop ports
			 * at the same time that we have fabric ports.
			 * That is, we used to exclude having ports
			 * at < FL_PORT_ID if we're FL-port.
			 *
			 * That's wrong. The only thing that could be
			 * dicey is if the switch you're connected to
			 * has these local loop ports appear on the
			 * fabric and we somehow attach them twice.
			 */
		}
#else
		/*
		 * Check for f/w being in ready state. If the f/w
		 * isn't in ready state, then we don't know our
		 * loop ID and the f/w hasn't completed logging
		 * into all targets on the loop. If this is the
		 * case, then bounce the command. We pretend this is
		 * a SELECTION TIMEOUT error if we've never gone to
		 * FW_READY state at all- in this case we may not
		 * be hooked to a loop at all and we shouldn't hang
		 * the machine for this. Otherwise, defer this command
		 * until later.
		 */
		if (fcp->isp_fwstate != FW_READY) {
			/*
			 * Give ourselves at most a 250ms delay.
			 */
			if (isp_fclink_test(isp, 250000)) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				if (fcp->loop_seen_once) {
					return (CMD_RQLATER);
				} else {
					return (CMD_COMPLETE);
				}
			}
		}

		/*
		 * If we're not on a Fabric, we can't have a target
		 * above FL_PORT_ID-1.
		 *
		 * If we're on a fabric and *not* connected as an F-port,
		 * we can't have a target less than FC_SNS_ID+1. This
		 * keeps us from having to sort out the difference between
		 * local public loop devices and those which we might get
		 * from a switch's database.
		 */
		if (fcp->isp_onfabric == 0) {
			if (target >= FL_PORT_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
		} else {
			if (target >= FL_PORT_ID && target <= FC_SNS_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
			if (fcp->isp_topo != TOPO_F_PORT &&
			    target < FL_PORT_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
d4082 4
a4085 9
		/*
		 * If our loop state is such that we haven't yet received
		 * a "Port Database Changed" notification (after a LIP or
		 * a Loop Reset or firmware initialization), then defer
		 * sending commands for a little while, but only if we've
		 * seen a valid loop at one point (otherwise we can get
		 * stuck at initialization time).
		 */
		if (fcp->isp_loopstate < LOOP_PDB_RCVD) {
d4087 1
a4087 5
			if (fcp->loop_seen_once) {
				return (CMD_RQLATER);
			} else {
				return (CMD_COMPLETE);
			}
d4089 1
a4089 8

		/*
		 * If we're in the middle of loop or fabric scanning
		 * or merging the port databases, retry this command later.
		 */
		if (fcp->isp_loopstate == LOOP_SCANNING_FABRIC ||
		    fcp->isp_loopstate == LOOP_SCANNING_LOOP ||
		    fcp->isp_loopstate == LOOP_SYNCING_PDB) {
d4092 1
a4092 50

		/*
		 * If our loop state is now such that we've just now
		 * received a Port Database Change notification, then
		 * we have to go off and (re)scan the fabric. We back
		 * out and try again later if this doesn't work.
		 */
		if (fcp->isp_loopstate == LOOP_PDB_RCVD && fcp->isp_onfabric) {
			if (isp_scan_fabric(isp, FC4_SCSI)) {
				return (CMD_RQLATER);
			}
			if (fcp->isp_fwstate != FW_READY ||
			    fcp->isp_loopstate < LOOP_FSCAN_DONE) {
				return (CMD_RQLATER);
			}
		}

		/*
		 * If our loop state is now such that we've just now
		 * received a Port Database Change notification, then
		 * we have to go off and (re)synchronize our port
		 * database.
		 */
		if (fcp->isp_loopstate < LOOP_READY) {
			if (isp_pdb_sync(isp)) {
				return (CMD_RQLATER);
			}
			if (fcp->isp_fwstate != FW_READY ||
			    fcp->isp_loopstate != LOOP_READY) {
				return (CMD_RQLATER);
			}
		}

		/*
		 * XXX: Here's were we would cancel any loop_dead flag
		 * XXX: also cancel in dead_loop timeout that's running
		 */
#endif

		/*
		 * Now check whether we should even think about pursuing this.
		 */
		lp = &fcp->portdb[target];
		if (lp->valid == 0) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
			return (CMD_COMPLETE);
		}
		if ((lp->roles & (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT)) == 0) {
			isp_prt(isp, ISP_LOGDEBUG2,
			    "Target %d does not have target service", target);
d4096 3
a4098 7
		/*
		 * Now turn target into what the actual Loop ID is.
		 */
		target = lp->loopid;
		xs->sc_link->node_wwn = lp->node_wwn;
		xs->sc_link->port_wwn = lp->port_wwn;

d4102 1
a4102 2
	 * Next check to see if any HBA or Device
	 * parameters need to be updated.
d4108 2
d4123 7
a4129 14
		u_int8_t n = (IS_DUALBUS(isp)? 2: 1);
		/*
		 * Check ports to send markers for...
		 */
		for (i = 0; i < n; i++) {
			if ((isp->isp_sendmarker & (1 << i)) == 0) {
				continue;
			}
			MEMZERO((void *) reqp, QENTRY_LEN);
			reqp->req_header.rqs_entry_count = 1;
			reqp->req_header.rqs_entry_type = RQSTYPE_MARKER;
			reqp->req_modifier = SYNC_ALL;
			reqp->req_target = i << 7;	/* insert bus number */
			isp_put_request(isp, reqp, qep);
d4131 17
a4147 6
			isp->isp_sendmarker &= ~(1 << i);
			if (isp_getrqentry(isp, &nxti, &optr, (void *) &qep)) {
				isp_prt(isp, ISP_LOGDEBUG0,
				    "Request Queue Overflow+");
				XS_SETERR(xs, HBA_BOTCH);
				return (CMD_EAGAIN);
d4154 3
a4156 1
	if (IS_FC(isp)) {
d4166 20
a4185 1
	if (IS_FC(isp)) {
d4193 1
a4193 1
		 * The QLogic drivers seem be happy not to use a tag,
d4216 3
a4218 1
	reqp->req_target = target | (XS_CHANNEL(xs) << 7);
d4220 1
d4223 20
d4244 2
a4245 4
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN)
			((ispreqt2_t *)reqp)->req_scclun = XS_LUN(xs);
		else
			((ispreqt2_t *)reqp)->req_lun_trn = XS_LUN(xs);
d4247 1
a4247 1
	MEMCPY(reqp->req_cdb, XS_CDBP(xs), XS_CDBLEN(xs));
d4249 6
a4254 3
	reqp->req_time = XS_TIME(xs) / 1000;
	if (reqp->req_time == 0 && XS_TIME(xs)) {
		reqp->req_time = 1;
d4262 1
d4267 1
a4267 1
	 * so that the QLogic F/W understands what is being asked of it.
d4279 1
a4279 1
	isp_prt(isp, ISP_LOGDEBUG2,
d4299 3
a4301 1
	u_int16_t handle;
d4312 9
a4320 6
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_BUS_RESET;
		if (IS_SCSI(isp)) {
			mbs.param[1] =
			    ((sdparam *) isp->isp_param)->isp_bus_reset_delay;
			if (mbs.param[1] < 2)
d4322 1
d4324 1
a4324 1
			if (IS_DUALBUS(isp))
d4326 1
a4326 3
		} else {
			mbs.param[1] = 10;
			bus = 0;
d4328 1
d4330 2
a4331 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d4341 15
a4355 2
		bus = (*((int *) arg)) >> 16;
		MEMZERO(&mbs, sizeof (mbs));
a4356 1
		mbs.param[1] = (tgt << 8) | (bus << 15);
d4358 2
a4359 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d4371 1
d4378 10
a4387 8
		bus = XS_CHANNEL(xs);
		MEMZERO(&mbs, sizeof (mbs));
		mbs.param[0] = MBOX_ABORT;
		if (IS_FC(isp)) {
			if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN)  {
				mbs.param[1] = tgt << 8;
				mbs.param[4] = 0;
				mbs.param[5] = 0;
d4393 2
a4394 2
			mbs.param[1] =
			    (bus << 15) | (XS_TGT(xs) << 8) | XS_LUN(xs);
d4396 1
d4398 4
a4401 3
		isp_mboxcmd(isp, &mbs, MBLOGALL & ~MBOX_COMMAND_ERROR);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			return (0);
d4403 1
a4403 5
		/*
		 * XXX: Look for command in the REQUEST QUEUE. That is,
		 * XXX: It hasn't been picked up by firmware yet.
		 */
		break;
d4413 4
a4416 1
			int usdelay = (arg)? *((int *) arg) : 250000;
d4424 1
a4424 2
			int ftype = (arg)? *((int *) arg) : FC4_SCSI;
			return (isp_scan_fabric(isp, ftype));
d4444 1
a4444 2
		if (IS_FC(isp)) {
			MEMZERO(&mbs, sizeof (mbs));
d4446 5
a4450 1
			isp_mboxcmd(isp, &mbs, MBLOGALL);
d4457 1
a4457 2
	case ISPCTL_GET_POSMAP:

d4459 3
a4461 1
			return (isp_getmap(isp, arg));
d4465 11
d4478 1
a4478 1
		isp_mboxcmd(isp, arg, MBLOGALL);
d4481 21
a4511 1
			MEMZERO(&mbs, sizeof (mbs));
d4515 2
a4516 1
			isp_mboxcmd(isp, &mbs, MBLOGALL);
d4540 1
a4540 1
#define	MAX_REQUESTQ_COMPLETIONS	64
d4544 1
a4544 1
isp_intr(struct ispsoftc *isp, u_int16_t isr, u_int16_t sema, u_int16_t mbox)
d4547 1
a4547 1
	u_int16_t iptr, optr, junk;
d4551 1
d4562 1
a4562 1
				for (i = 1; i < MAX_MAILBOX; i++) {
d4577 1
a4577 2
				    "Mbox Command Async (0x%x) with no waiters",
				    mbox);
d4584 1
a4584 3
			ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
			ISP_WRITE(isp, BIU_SEMA, 0);
			return;
d4592 1
a4592 1
		isp_prt(isp, ISP_LOGWARN,
d4597 7
a4603 2
		WRITE_RESPONSE_QUEUE_OUT_POINTER(isp,
		    READ_RESPONSE_QUEUE_IN_POINTER(isp));
d4605 36
a4640 3
		ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
		ISP_WRITE(isp, BIU_SEMA, 0);
		return;
d4642 1
d4647 1
a4647 1
	 * If we're a 2300, we can ask what hardware what it thinks.
d4649 1
a4649 1
	if (IS_23XX(isp)) {
d4655 2
a4656 1
			isp_prt(isp, ISP_LOGWARN, "optr %x soft optr %x",
d4658 1
d4673 2
a4674 2
			iptr = READ_RESPONSE_QUEUE_IN_POINTER(isp);
			junk = READ_RESPONSE_QUEUE_IN_POINTER(isp);
a4677 1
			ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
d4681 1
a4681 1
			return;
d4684 1
a4684 1
		iptr = READ_RESPONSE_QUEUE_IN_POINTER(isp);
d4698 3
a4700 1
		if (IS_23XX(isp)) {
d4702 1
a4702 1
			iptr = READ_RESPONSE_QUEUE_IN_POINTER(isp);
d4708 1
a4708 1
			if (IS_23XX(isp)) {
d4724 1
a4724 2
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
	ISP_WRITE(isp, BIU_SEMA, 0);
d4727 1
a4727 1
		return;
a4729 1

d4731 2
a4732 1
		ispstatusreq_t local, *sp = &local;
d4734 5
a4738 1
		int type;
a4739 1
		int buddaboom = 0;
d4745 4
d4753 2
d4756 13
a4768 3
		type = isp_get_response_type(isp, hp);

		if (type == RQSTYPE_RESPONSE) {
d4770 22
a4791 5
		} else if (type == RQSTYPE_RIO2) {
			isp_rio2_t rio;
			isp_get_rio2(isp, (isp_rio2_t *) hp, &rio);
			for (i = 0; i < rio.req_header.rqs_seqno; i++) {
				isp_fastpost_complete(isp, rio.req_handles[i]);
a4792 2
			if (isp->isp_fpcchiwater < rio.req_header.rqs_seqno)
				isp->isp_fpcchiwater = rio.req_header.rqs_seqno;
d4801 6
a4806 1
			if (isp_handle_other_response(isp, type, hp, &optr)) {
a4816 1
			isp_get_response(isp, (ispstatusreq_t *) hp, sp);
d4823 1
a4823 1
			if (sp->req_header.rqs_entry_type != RQSTYPE_REQUEST) {
d4825 3
a4827 6
				    sp->req_header.rqs_entry_type, oop, optr,
				    nlooked);
				if (isp->isp_dblev & ISP_LOGDEBUG0) {
					isp_print_bytes(isp, "Queue Entry",
					    QENTRY_LEN, sp);
				}
d4832 5
d4839 1
a4839 3
		if (sp->req_header.rqs_flags & 0xf) {
#define	_RQS_OFLAGS	\
	~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)
d4843 1
a4843 1
				WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, optr);
d4854 2
a4855 1
				isp_prt(isp, ISP_LOGERR,  "bad header flag");
d4859 2
a4860 7
				isp_prt(isp, ISP_LOGERR, "bad request packet");
				buddaboom++;
			}
			if (sp->req_header.rqs_flags & _RQS_OFLAGS) {
				isp_prt(isp, ISP_LOGERR,
				    "unknown flags (0x%x) in response",
				    sp->req_header.rqs_flags);
a4862 1
#undef	_RQS_OFLAGS
d4864 1
d4866 3
d4870 1
a4870 5
			isp_prt(isp, ISP_LOGERR,
			    "bad request handle %d (type 0x%x, flags 0x%x)",
			    sp->req_handle, sp->req_header.rqs_entry_type,
			    sp->req_header.rqs_flags);
			WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, optr);
d4875 1
a4875 2
			u_int8_t ts = sp->req_completion_status & 0xff;
			MEMZERO(hp, QENTRY_LEN);	/* PERF */
d4880 1
a4880 1
			if (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {
d4883 1
a4883 2
				    sp->req_handle,
				    sp->req_header.rqs_entry_type);
d4889 2
a4890 1
			WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, optr);
d4894 1
a4894 1
		if (sp->req_status_flags & RQSTF_BUS_RESET) {
d4902 12
a4913 1
		if (IS_FC(isp) && (sp->req_scsi_status & RQCS_SV)) {
d4919 14
a4932 1
			sp->req_state_flags |= RQSF_GOT_STATUS;
d4934 2
a4935 2
		if (sp->req_state_flags & RQSF_GOT_STATUS) {
			*XS_STSP(xs) = sp->req_scsi_status & 0xff;
d4938 1
a4938 1
		switch (sp->req_header.rqs_entry_type) {
d4940 15
a4954 2
			XS_SET_STATE_STAT(isp, xs, sp);
			isp_parse_status(isp, sp, xs);
d4960 1
a4960 6
				XS_RESID(xs) = sp->req_resid;
				if ((sp->req_state_flags & RQSF_GOT_STATUS) &&
				    (*XS_STSP(xs) == SCSI_CHECK) &&
				    (sp->req_state_flags & RQSF_GOT_SENSE)) {
					XS_SAVE_SENSE(xs, sp);
				}
d4966 1
a4966 1
				if (sp->req_status_flags & RQSTF_NEGOTIATION) {
d4975 1
a4975 1
				if (sp->req_status_flags & RQSF_XFER_COMPLETE) {
d4977 2
a4978 2
				} else if (sp->req_scsi_status & RQCS_RESID) {
					XS_RESID(xs) = sp->req_resid;
d4982 3
a4984 7
				if ((sp->req_state_flags & RQSF_GOT_STATUS) &&
				    (*XS_STSP(xs) == SCSI_CHECK) &&
				    (sp->req_scsi_status & RQCS_SV)) {
					XS_SAVE_SENSE(xs, sp);
					/* solely for the benefit of debug */
					sp->req_state_flags |= RQSF_GOT_SENSE;
				}
d4987 2
a4988 2
			   "asked for %ld got resid %ld", (long) XS_XFRLEN(xs),
			   (long) sp->req_resid);
d4991 4
d5005 1
d5008 4
a5011 1
				XS_SETERR(xs, HBA_BOTCH);
d5016 2
a5017 3
			isp_prt(isp, ISP_LOGWARN,
			    "unhandled response queue type 0x%x",
			    sp->req_header.rqs_entry_type);
d5025 3
a5027 2
		 * Free any dma resources. As a side effect, this may
		 * also do any cache flushing necessary for data coherence.			 */
d5033 1
a5033 1
		    ((isp->isp_dblev & ISP_LOGDEBUG1) && ((!XS_NOERR(xs)) ||
d5036 1
a5036 1
			if (sp->req_state_flags & RQSF_GOT_SENSE) {
d5048 1
a5048 2
			    XS_TGT(xs), XS_LUN(xs), XS_XFRLEN(xs),
			    (ulong)XS_RESID(xs),
d5067 1
a5067 1
		WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, optr);
d5069 1
a5069 1
		 * While we're at it, read the request queue out pointer.
d5071 2
a5072 2
		isp->isp_reqodx = READ_REQUEST_QUEUE_OUT_POINTER(isp);
		if (isp->isp_rscchiwater < ndone)
d5074 10
d5101 1
a5101 1
static int
d5118 1
a5118 1
		if (isp_target_async(isp, bus, mbox))
d5120 1
d5125 14
a5138 1
#ifdef	ISP_FW_CRASH_DUMP
d5140 2
a5141 5
		 * If we have crash dumps enabled, it's up to the handler
		 * for isp_async to reinit stuff and restart the firmware
		 * after performing the crash dump. The reason we do things
		 * this way is that we may need to activate a kernel thread
		 * to do all the crash dump goop.
a5143 5
#else
		isp_async(isp, ISPASYNC_FW_CRASH, NULL);
		isp_reinit(isp);
		isp_async(isp, ISPASYNC_FW_RESTARTED, NULL);
#endif
d5161 1
a5161 1
		mbox = READ_REQUEST_QUEUE_OUT_POINTER(isp);
d5169 1
a5169 1
		if (isp_target_async(isp, bus, mbox))
d5171 1
d5179 1
a5179 1
		if (isp_target_async(isp, bus, mbox))
d5181 1
d5272 1
a5272 1
		if (isp_target_async(isp, handle, mbox))
d5274 4
d5280 1
a5281 1
		isp->isp_fphccmplt++;	/* count it as a fast posting intr */
d5284 1
a5286 2
		FCPARAM(isp)->isp_lipseq =
		    ISP_READ(isp, OUTMAILBOX1);
d5290 1
a5290 1
		isp_mark_getpdb_all(isp);
d5293 1
a5293 1
		if (isp_target_async(isp, bus, mbox))
d5295 1
d5298 1
a5298 1
		 * We've had problems with data corruption occurring on
d5326 1
a5326 1
		isp_mark_getpdb_all(isp);
d5329 1
a5329 1
		if (isp_target_async(isp, bus, mbox))
d5331 1
d5339 1
a5339 1
		isp_mark_getpdb_all(isp);
d5342 1
a5342 1
		if (isp_target_async(isp, bus, mbox))
d5344 1
d5352 1
a5352 1
		isp_mark_getpdb_all(isp);
d5355 1
a5355 1
		if (isp_target_async(isp, bus, mbox))
d5357 1
d5364 1
a5364 1
		isp_mark_getpdb_all(isp);
d5369 6
a5374 5
		/*
		 * Not correct, but it will force us to rescan the loop.
		 */
		FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
		isp_mark_getpdb_all(isp);
d5379 1
a5379 5
		if (FCPARAM(isp)->isp_onfabric)
			FCPARAM(isp)->isp_topo = TOPO_F_PORT;
		else
			FCPARAM(isp)->isp_topo = TOPO_N_PORT;
		isp_mark_getpdb_all(isp);
d5385 1
a5385 1
		if (isp_target_async(isp, bus, mbox))
d5387 1
d5394 1
a5394 1
		isp_mark_getpdb_all(isp);
a5409 3
#ifdef	ISP_FW_CRASH_DUMP
			isp_async(isp, ISPASYNC_FW_CRASH, NULL);
#else
a5410 3
			isp_reinit(isp);
			isp_async(isp, ISPASYNC_FW_RESTARTED, NULL);
#endif
d5427 9
d5443 1
a5443 1
		u_int16_t handles[5];
d5445 1
a5445 1
		for (nh = 0, i = 1; i < MAX_MAILBOX; i++) {
d5456 1
a5456 1
		if (isp->isp_fpcchiwater < nh)
d5458 1
d5471 1
a5471 1
static int
d5473 1
a5473 1
    isphdr_t *hp, u_int16_t *optrp)
d5477 4
a5480 1
		isp_prt(isp, ISP_LOGINFO, "Ignored Continuation Response");
d5492 3
d5504 16
a5522 2
		isp_prt(isp, ISP_LOGWARN, "Unhandled Response Type 0x%x",
		    isp_get_response_type(isp, hp));
d5527 2
a5528 2
static void
isp_parse_status(struct ispsoftc *isp, ispstatusreq_t *sp, XS_T *xs)
d5544 1
d5557 1
d5613 1
d5624 1
d5640 1
a5640 1
	 	 * Check to see if we logged out the device.
a5641 7
		if (IS_FC(isp)) {
			if ((sp->req_completion_status & RQSTF_LOGOUT) &&
			    FCPARAM(isp)->portdb[XS_TGT(xs)].valid &&
			    FCPARAM(isp)->portdb[XS_TGT(xs)].fabric_dev) {
				FCPARAM(isp)->portdb[XS_TGT(xs)].relogin = 1;
			}
		}
d5848 4
d5855 9
a5863 6
		if ((sp->req_completion_status & 0xff) == RQCS_PORT_UNAVAILABLE)
			isp_prt(isp, ISP_LOGINFO,
			    "port unavailable for target %d", XS_TGT(xs));
		else
			isp_prt(isp, ISP_LOGINFO,
			    "port logout for target %d", XS_TGT(xs));
d5867 1
a5867 1
		 * then we'll have to relogin as a matter of course.
d5874 4
d5880 154
d6036 3
a6038 1
		 * Probably overkill.
d6040 11
a6050 4
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
		isp_mark_getpdb_all(isp);
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_OTHER);
d6055 1
a6055 1

d6064 11
a6074 1
	case RQCS_PORT_BUSY:
d6076 2
a6077 1
		    "port busy for target %d", XS_TGT(xs));
d6079 1
d6094 1
a6094 1
static void
d6104 1
a6104 1
		isp_prt(isp, ISP_LOGWARN,
d6127 1
a6127 1
static int
d6132 1
d6137 1
a6147 1

d6151 6
a6156 2
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
	ISP_WRITE(isp, BIU_SEMA, 0);
d6165 5
a6169 1
		mbs.param[2] = *ptr++;
d6172 10
a6181 1
	case MBOX_READ_RAM_WORD:
d6183 3
d6187 4
a6190 1
		mbs.param[1] = isp->isp_mbxwrk1++;
d6194 1
d6196 1
a6196 1
	isp->isp_mbxwrk0 -= 1;
d6201 4
a6204 5

#define	HIBYT(x)			((x) >> 0x8)
#define	LOBYT(x)			((x)  & 0xff)
#define	ISPOPMAP(a, b)			(((a) << 8) | (b))
static const u_int16_t mbpscsi[] = {
d6212 1
a6212 1
	ISPOPMAP(0x03, 0x07),	/* 0x07: MBOX_VERIFY_CHECKSUM	*/
d6289 1
a6289 1
	ISPOPMAP(0xcf, 0x01),	/* 0x54: EXECUTE IOCB A64 */
d6305 2
a6306 2
#ifndef	ISP_STRIPPED
static char *scsi_mbcmd_names[] = {
d6404 1
a6404 1
static const u_int16_t mbpfc[] = {
d6407 1
a6407 1
	ISPOPMAP(0x03, 0x01),	/* 0x02: MBOX_EXEC_FIRMWARE */
d6412 1
a6412 1
	ISPOPMAP(0x03, 0x05),	/* 0x07: MBOX_VERIFY_CHECKSUM	*/
d6414 1
a6414 1
	ISPOPMAP(0xdf, 0x01),	/* 0x09: LOAD RAM */
d6416 1
a6416 1
	ISPOPMAP(0x00, 0x00),	/* 0x0b: */
d6418 1
a6418 1
	ISPOPMAP(0x00, 0x00),	/* 0x0d: */
d6420 1
a6420 1
	ISPOPMAP(0x03, 0x07),	/* 0x0f: MBOX_READ_RAM_WORD_EXTENDED(1) */
d6471 2
a6472 2
	ISPOPMAP(0x03, 0x07),	/* 0x42: MBOX_GET_RESOURCE_COUNTS */
	ISPOPMAP(0x01, 0x01),	/* 0x43: MBOX_REQUEST_NON_PARTICIPATING_MODE */
d6501 1
a6501 1
	ISPOPMAP(0xfd, 0x31),	/* 0x60: MBOX_INIT_FIRMWARE */
d6531 1
a6531 1
	ISPOPMAP(0x07, 0x01)	/* 0x7e: Lun RESET */
d6538 2
a6539 1
 *	responsible for setting this register first (Gross!).
d6542 2
a6543 2
#ifndef	ISP_STRIPPED
static char *fc_mbcmd_names[] = {
d6555 1
a6555 1
	NULL,
d6610 1
a6610 1
	"GET RESOURCE COUNTS",
d6615 1
a6615 1
	"GET PORT DATABASE,, ENHANCED",
d6674 1
a6674 1
static void
d6677 2
a6678 2
	unsigned int lim, ibits, obits, box, opcode;
	const u_int16_t *mcp;
a6681 1
		lim = (sizeof (mbpfc) / sizeof (mbpfc[0]));
a6683 1
		lim = (sizeof (mbpscsi) / sizeof (mbpscsi[0]));
d6686 5
a6690 3
	ibits = HIBYT(mcp[opcode]) & NMBOX_BMASK(isp);
	obits = LOBYT(mcp[opcode]) & NMBOX_BMASK(isp);
	for (box = 0; box < MAX_MAILBOX; box++) {
a6691 2
			isp_prt(isp, ISP_LOGDEBUG1, "IN mbox %d = 0x%x", box,
			    mbp->param[box]);
d6703 5
a6707 1
	ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);
d6718 2
a6719 2
static void
isp_mboxcmd(struct ispsoftc *isp, mbreg_t *mbp, int logmask)
d6721 2
a6722 1
	char *cname, *xname, tname[16], mname[16];
d6724 1
a6724 1
	const u_int16_t *mcp;
d6740 8
a6747 2
	ibits = HIBYT(mcp[opcode]) & NMBOX_BMASK(isp);
	obits = LOBYT(mcp[opcode]) & NMBOX_BMASK(isp);
d6758 4
a6761 1
	MBOX_ACQUIRE(isp);
d6763 1
a6763 1
	for (box = 0; box < MAX_MAILBOX; box++) {
d6765 2
d6783 5
a6787 1
	ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);
d6792 1
a6792 1
	MBOX_WAIT_COMPLETE(isp);
d6794 4
a6797 5
	if (isp->isp_mboxbsy) {
		/*
		 * Command timed out.
		 */
		isp->isp_mboxbsy = 0;
d6799 1
a6799 1
		return;
d6805 1
a6805 1
	for (box = 0; box < MAX_MAILBOX; box++) {
d6808 1
a6808 1
			isp_prt(isp, ISP_LOGDEBUG1, "OUT mbox %d = 0x%x", box,
d6814 3
a6816 2

	if (logmask == 0 || opcode == MBOX_EXEC_FIRMWARE) {
d6819 1
a6819 1
#ifdef	ISP_STRIPPED
d6837 1
a6837 1
		if (logmask & MBLOGMASK(MBOX_COMMAND_COMPLETE))
d6839 1
d6842 1
a6842 1
		if (logmask & MBLOGMASK(MBOX_HOST_INTERFACE_ERROR))
d6844 1
d6847 1
a6847 1
		if (logmask & MBLOGMASK(MBOX_TEST_FAILED))
d6849 1
d6852 1
a6852 1
		if (logmask & MBLOGMASK(MBOX_COMMAND_ERROR))
d6854 1
d6857 1
a6857 1
		if (logmask & MBLOGMASK(MBOX_COMMAND_PARAM_ERROR))
d6859 1
d6862 1
a6862 1
		if (logmask & MBLOGMASK(MBOX_LOOP_ID_USED))
d6864 1
d6867 1
a6867 1
		if (logmask & MBLOGMASK(MBOX_PORT_ID_USED))
d6869 1
d6872 1
a6872 1
		if (logmask & MBLOGMASK(MBOX_ALL_IDS_USED))
d6874 1
d6876 4
a6879 1
	case 0:		/* special case */
d6887 1
a6887 1
	if (xname)
d6890 1
d6893 1
a6893 1
static void
d6902 2
a6903 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d6910 1
a6910 1
static void
d6923 1
a6923 1
static void
a6964 1
			sdp->isp_devparam[tgt].dev_refresh = 0;
d6968 1
a6974 1

a7007 2
			sdp->isp_devparam[tgt].dev_update = 0;
			sdp->isp_devparam[tgt].dev_refresh = 1;
d7013 5
a7017 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d7020 12
a7031 1
			continue;
a7032 8
		flags = mbs.param[2];
		period = mbs.param[3] & 0xff;
		offset = mbs.param[3] >> 8;
		sdp->isp_devparam[tgt].actv_flags = flags;
		sdp->isp_devparam[tgt].actv_period = period;
		sdp->isp_devparam[tgt].actv_offset = offset;
		get = (bus << 16) | tgt;
		(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);
a7043 3
#ifndef	DEFAULT_FRAMESIZE
#define	DEFAULT_FRAMESIZE(isp)		ICB_DFLT_FRMLEN
#endif
d7048 1
a7048 1
static void
a7053 81
	if (IS_FC(isp)) {
		fcparam *fcp = (fcparam *) isp->isp_param;
		int nvfail;

		fcp += channel;
		if (fcp->isp_gotdparms) {
			return;
		}
		fcp->isp_gotdparms = 1;
		fcp->isp_maxfrmlen = DEFAULT_FRAMESIZE(isp);
		fcp->isp_maxalloc = ICB_DFLT_ALLOC;
		fcp->isp_execthrottle = DEFAULT_EXEC_THROTTLE(isp);
		fcp->isp_retry_delay = ICB_DFLT_RDELAY;
		fcp->isp_retry_count = ICB_DFLT_RCOUNT;
		/* Platform specific.... */
		fcp->isp_loopid = DEFAULT_LOOPID(isp);
		fcp->isp_nodewwn = DEFAULT_NODEWWN(isp);
		fcp->isp_portwwn = DEFAULT_PORTWWN(isp);
		fcp->isp_fwoptions = 0;
		fcp->isp_fwoptions |= ICBOPT_FAIRNESS;
		fcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;
		fcp->isp_fwoptions |= ICBOPT_HARD_ADDRESS;
#ifndef	ISP_NO_FASTPOST_FC
		fcp->isp_fwoptions |= ICBOPT_FAST_POST;
#endif
		if (isp->isp_confopts & ISP_CFG_FULL_DUPLEX)
			fcp->isp_fwoptions |= ICBOPT_FULL_DUPLEX;

		/*
		 * Make sure this is turned off now until we get
		 * extended options from NVRAM
		 */
		fcp->isp_fwoptions &= ~ICBOPT_EXTENDED;

		/*
		 * Now try and read NVRAM unless told to not do so.
		 * This will set fcparam's isp_nodewwn && isp_portwwn.
		 */
		if ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {
		    	nvfail = isp_read_nvram(isp);
			if (nvfail)
				isp->isp_confopts |= ISP_CFG_NONVRAM;
		} else {
			nvfail = 1;
		}
		/*
		 * Set node && port to override platform set defaults
		 * unless the nvram read failed (or none was done),
		 * or the platform code wants to use what had been
		 * set in the defaults.
		 */
		if (nvfail) {
			isp->isp_confopts |= ISP_CFG_OWNWWPN|ISP_CFG_OWNWWNN;
		}
		if (isp->isp_confopts & ISP_CFG_OWNWWNN) {
			isp_prt(isp, ISP_LOGCONFIG, "Using Node WWN 0x%08x%08x",
			    (u_int32_t) (DEFAULT_NODEWWN(isp) >> 32),
			    (u_int32_t) (DEFAULT_NODEWWN(isp) & 0xffffffff));
			ISP_NODEWWN(isp) = DEFAULT_NODEWWN(isp);
		} else {
			/*
			 * We always start out with values derived
			 * from NVRAM or our platform default.
			 */
			ISP_NODEWWN(isp) = fcp->isp_nodewwn;
		}
		if (isp->isp_confopts & ISP_CFG_OWNWWPN) {
			isp_prt(isp, ISP_LOGCONFIG, "Using Port WWN 0x%08x%08x",
			    (u_int32_t) (DEFAULT_PORTWWN(isp) >> 32),
			    (u_int32_t) (DEFAULT_PORTWWN(isp) & 0xffffffff));
			ISP_PORTWWN(isp) = DEFAULT_PORTWWN(isp);
		} else {
			/*
			 * We always start out with values derived
			 * from NVRAM or our platform default.
			 */
			ISP_PORTWWN(isp) = fcp->isp_portwwn;
		}
		return;
	}

d7064 1
a7064 1

d7104 1
d7115 2
a7116 1
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
d7154 1
a7154 1
		 * (unless its SBus).
d7189 104
a7296 2
 *
 * Locks held prior to coming here.
d7303 1
a7303 1
	u_int16_t handle;
d7305 3
d7319 15
d7335 1
a7335 1
	}
d7338 4
a7341 2
	for (handle = 1; (int) handle <= isp->isp_maxcmds; handle++) {
		xs = isp_find_xs(isp, handle);
d7345 4
d7359 3
d7367 1
a7367 1
static int
d7370 1
a7370 1
	int i, amt;
d7379 3
a7381 1
	if (IS_FC(isp)) {
d7392 1
a7392 5
	/*
	 * Just read the first two words first to see if we have a valid
	 * NVRAM to continue reading the rest with.
	 */
	for (i = 0; i < 2; i++) {
d7395 1
d7403 2
a7404 4
		return (-1);
	}
	for (i = 2; i < amt>>1; i++) {
		isp_rdnvram_word(isp, i, &nvram_words[i]);
d7406 1
d7412 2
a7413 1
		return (-1);
d7415 1
d7419 2
a7420 1
		return (-1);
d7437 3
a7439 1
	return (0);
d7444 41
a7484 1
static void
d7488 1
a7488 1
	u_int16_t bit, rqst;
d7491 1
a7491 1
	USEC_DELAY(2);
d7493 1
a7493 1
	USEC_DELAY(2);
d7496 1
a7496 1
		wo &= ((ISP2100_NVRAM_SIZE >> 1) - 1);
d7522 2
a7523 1
		USEC_DELAY(2);
d7525 2
a7526 1
		USEC_DELAY(2);
d7528 2
a7529 1
		USEC_DELAY(2);
d7539 1
a7539 1
		USEC_DELAY(2);
d7544 1
a7544 1
		USEC_DELAY(2);
d7546 2
a7547 1
		USEC_DELAY(2);
d7550 2
a7551 1
	USEC_DELAY(2);
d7555 24
a7578 1
static void
d7704 1
a7704 1
static void
d7796 1
a7796 1
static void
d7887 33
a7919 1
static void
d7922 1
a7922 1
	fcparam *fcp = (fcparam *) isp->isp_param;
d7931 1
a7931 1
	 * QLogic WWNs have an NAA of 2, but usually nothing shows up in
d7944 1
a7944 1
	fcp->isp_portwwn = wwn;
d7946 1
a7946 1
		wwn = ISP2200_NVRAM_NODE_NAME(nvram_data);
d7958 42
a7999 1
	fcp->isp_nodewwn = wwn;
d8001 21
a8021 7
	/*
	 * Make sure we have both Node and Port as non-zero values.
	 */
	if (fcp->isp_nodewwn != 0 && fcp->isp_portwwn == 0) {
		fcp->isp_portwwn = fcp->isp_nodewwn;
	} else if (fcp->isp_nodewwn == 0 && fcp->isp_portwwn != 0) {
		fcp->isp_nodewwn = fcp->isp_portwwn;
d8023 1
d8025 4
a8028 14
	/*
	 * Make the Node and Port values sane if they're NAA == 2.
	 * This means to clear bits 48..56 for the Node WWN and
	 * make sure that there's some non-zero value in 48..56
	 * for the Port WWN.
	 */
	if (fcp->isp_nodewwn && fcp->isp_portwwn) {
		if ((fcp->isp_nodewwn & (((u_int64_t) 0xfff) << 48)) != 0 &&
		    (fcp->isp_nodewwn >> 60) == 2) {
			fcp->isp_nodewwn &= ~((u_int64_t) 0xfff << 48);
		}
		if ((fcp->isp_portwwn & (((u_int64_t) 0xfff) << 48)) == 0 &&
		    (fcp->isp_portwwn >> 60) == 2) {
			fcp->isp_portwwn |= ((u_int64_t) 1 << 56);
d8031 1
d8033 1
a8033 6
	isp_prt(isp, ISP_LOGDEBUG0,
	    "NVRAM: maxfrmlen %d execthrottle %d fwoptions 0x%x loopid %x",
	    ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data),
	    ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data),
	    ISP2100_NVRAM_OPTIONS(nvram_data),
	    ISP2100_NVRAM_HARDLOOPID(nvram_data));
d8035 10
a8044 13
	fcp->isp_maxalloc =
		ISP2100_NVRAM_MAXIOCBALLOCATION(nvram_data);
	if ((isp->isp_confopts & ISP_CFG_OWNFSZ) == 0)
		fcp->isp_maxfrmlen =
			ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);
	fcp->isp_retry_delay =
		ISP2100_NVRAM_RETRY_DELAY(nvram_data);
	fcp->isp_retry_count =
		ISP2100_NVRAM_RETRY_COUNT(nvram_data);
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		fcp->isp_loopid =
			ISP2100_NVRAM_HARDLOOPID(nvram_data);
	if ((isp->isp_confopts & ISP_CFG_OWNEXCTHROTTLE) == 0)
d8046 5
a8050 2
			ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);
	fcp->isp_fwoptions = ISP2100_NVRAM_OPTIONS(nvram_data);
d8054 2
a8055 2
static void isp2200_fw_dump(struct ispsoftc *);
static void isp2300_fw_dump(struct ispsoftc *);
d8057 1
a8057 1
static void
d8064 1
d8183 1
a8183 2
	ENABLE_INTS(isp);
	MEMZERO(&mbs, sizeof (mbs));
d8202 1
a8202 1
static void
d8209 1
d8326 1
a8326 1
	ENABLE_INTS(isp);
a8340 8

	/*
	 * We don't have access to mailbox registers 8.. onward
	 * in our 'common' device model- so we have to set it
	 * here and hope it stays the same!
	 */
	ISP_WRITE(isp, PCI_MBOX_REGS2300_OFF + (8 << 1), 0x1);

d8343 1
a8343 1
	mbs.param[1] = 0;
d8347 1
d8368 3
@


1.44
log
@Zero mbreg_t structure *before* initializing any members, not when we're
halfway through.  Makes the ISP12160 correctly load its firmware again on
sparc64.

ok krw@@
@
text
@d1 2
a2 1
/* 	$OpenBSD: isp.c,v 1.43 2008/06/11 22:53:46 krw Exp $ */
d279 2
d289 6
@


1.43
log
@Zero mbreg_t (mailbox) structures allocated on the stack before filling
them in and sending to the adapter. Reduces probe of empty controller
from 15 minutes or so to 30 seconds or so. And probably fixes other
things too.

Also add a few more debug statements and tweak some comments.

From mjacob via FreeBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.42 2008/05/28 18:40:21 kettenis Exp $ */
d4791 1
a4804 1
	MEMZERO(&mbs, sizeof (mbs));
@


1.42
log
@Don't try reading the SXP_PINS_DIFF on the 10160 and 12160 SCSI controllers.
The registers seems to return 0 on my 12160 and there are some indications
that it doesn't really exist.  This may fix panics seen with the 10160 on
sparc64 machines.

ok krw@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.41 2008/01/21 20:00:33 sobrado Exp $ */
d206 1
d597 1
d605 1
d651 1
d666 1
d688 1
d702 1
d710 1
d775 1
d886 1
d901 1
d913 1
d938 1
d952 1
d971 1
d985 1
d999 1
d1011 1
d1033 1
d1075 1
d1119 1
d1137 1
d1161 1
d1366 1
d1418 1
a1419 1
	mbs.param[1] = 0;
a1421 2
	mbs.param[4] = 0;
	mbs.param[5] = 0;
d1424 3
d1455 1
a1456 1
	mbs.param[1] = 0;
a1458 9
	/*
	 * Unneeded. For the 2100, except for initializing f/w, registers
	 * 4/5 have to not be written to.
	 *	mbs.param[4] = 0;
	 *	mbs.param[5] = 0;
	 *
	 */
	mbs.param[6] = 0;
	mbs.param[7] = 0;
d1487 1
a1491 7
	/*
	 * Unneeded. For the 2100, except for initializing f/w, registers
	 * 4/5 have to not be written to.
	 *	mbs.param[4] = 0;
	 *	mbs.param[5] = 0;
	 *
	 */
d1511 1
d1631 1
d1725 1
d1952 1
a1954 2
				mbs.param[2] = 0;
				mbs.param[3] = 0;
d1973 1
d2090 1
d2386 1
d2476 1
d2627 1
d2705 1
d2761 1
d2825 1
d2927 1
d3339 1
a3340 1
		mbs.param[2] = 0;
d3365 1
d3388 1
a3402 1
		mbs.param[3] = 0;
d3452 1
d3483 1
d4686 1
d4804 1
d5302 2
d5401 2
d5480 1
d5537 2
d5565 1
a5565 3
			if ((mbs.param[2] & DPARM_SYNC) == 0) {
				mbs.param[3] = 0;
			} else {
a5629 1
	mbreg_t mbs;
d5769 3
d6566 1
d6709 1
d6731 1
@


1.41
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.40 2007/10/16 23:41:42 fgsch Exp $ */
d276 9
a295 4
		else if (IS_10160(isp))
			btype = "10160";
		else if (IS_12160(isp))
			btype = "12160";
@


1.40
log
@more remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.39 2007/05/23 01:32:25 ray Exp $ */
d4 1
a4 1
 * code for the Qlogic ISP SCSI adapters.
d1882 1
a1882 1
		 * Unfortunately, our charming Qlogic f/w has decided to
d3221 1
a3221 1
		 * The Qlogic drivers seem be happy not to use a tag,
d3270 1
a3270 1
	 * so that the Qlogic F/W understands what is being asked of it.
d6318 1
a6318 1
	 * Qlogic WWNs have an NAA of 2, but usually nothing shows up in
@


1.39
log
@%z in printf(9) is not the same as %z in printf(3).  Change to %lu
and cast arg to ulong.

OK jsg@@ and krw@@.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.38 2007/04/10 17:47:55 miod Exp $ */
d3501 2
a3502 2
				int i = 0, obits = isp->isp_obits;
				isp->isp_mboxtmp[i++] = mbox;
@


1.38
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.37 2006/05/31 23:25:27 krw Exp $ */
d102 1
a102 1
    "(%d.%d.%d): FIN dl%d resid %zu STS 0x%x SKEY %c XS_ERR=0x%x";
d3883 2
a3884 1
			    XS_TGT(xs), XS_LUN(xs), XS_XFRLEN(xs), XS_RESID(xs),
@


1.37
log
@Capture the port_wwn and node_wwn corresponding to a target id every
time a scsi_request is processed. Crude but effective until a more
elegant solution is found. This allows the boot drive to be found on
fibre channel booting machines.

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.36 2006/04/20 20:31:12 miod Exp $ */
d2257 1
a2257 1
			 * loopids then. We don't change it's actual
d5772 1
a5772 1
		 * (unless it's SBus).
@


1.36
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.35 2004/07/18 03:36:35 deraadt Exp $ */
d3150 3
@


1.35
log
@#ifdef SMALL_KERNEL -> #define ISP_STRIPPED
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.34 2003/10/21 18:58:49 jmc Exp $ */
d102 1
a102 1
    "(%d.%d.%d): FIN dl%d resid %d STS 0x%x SKEY %c XS_ERR=0x%x";
@


1.34
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.33 2003/04/23 20:13:07 mickey Exp $ */
d4876 4
@


1.33
log
@give 'em some const; mjacob@@ ok
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.32 2003/03/03 18:43:51 mjacob Exp $ */
d2015 1
a2015 1
		 * Make sure we can get the approriate port information.
d3380 1
a3380 1
		 * XXX: It hasen't been picked up by firmware yet.
d3901 1
a3901 1
		 * While we're at it, read the requst queue out pointer.
d4108 1
a4108 1
		 * We've had problems with data corruption occuring on
@


1.32
log
@Argh. Put back mickey's change here and also follow Ted's suggestion
wrt bogus identity assignments.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.31 2003/03/03 18:31:42 mjacob Exp $ */
d4780 1
a4780 1
static u_int16_t mbpscsi[] = {
d4976 1
a4976 1
static u_int16_t mbpfc[] = {
d5249 1
a5249 1
	u_int16_t *mcp;
d5290 1
a5290 1
	u_int16_t *mcp;
@


1.31
log
@Add (untested, no h/w) 10160 support. Propagate some spelling fixes.
Add back in merged 'mhz' change.

Use A64 variants to initialize ULTRA2 or better && 1240 cards. If PAE
is ever implemented for *BSD, we'll be closer to being ready to go.

Add in a commented out example for how to adjust idelaytimer on 2300s.

If we have ISP_FW_CRASH_DUMP defined, then don't reinit the isp in
ISP_CONN_FATAL case- that's up to the platform outer layer to do after
it finishes saving a f/w crashdump.

Replaces STRNCAT with SNPRINTF.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.30 2003/02/28 20:31:34 mjacob Exp $ */
d402 1
a402 1
			 * If we're in Ultra Mode, we have to be 60Mhz clock-
d4299 1
a4299 2
#else
		optrp = optrp;
a4300 1
#endif
@


1.30
log
@
Revert previous change. This driver is shared with 4 other platforms.
Baloney gratuitous changes to comments w/o even a headsup to the author
will be reverted.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.29 2003/02/11 19:20:27 mickey Exp $ */
d287 2
d793 1
a793 1
	 * Because the lun is in a a different position in the Request Queue
a796 4
	 *
	 * Note that we only do this once (the first time thru isp_reset)
	 * because we may be called again after firmware has been loaded once
	 * and released.
d951 37
a987 11
	mbs.param[0] = MBOX_INIT_RES_QUEUE;
	mbs.param[1] = RESULT_QUEUE_LEN(isp);
	mbs.param[2] = DMA_WD1(isp->isp_result_dma);
	mbs.param[3] = DMA_WD0(isp->isp_result_dma);
	mbs.param[4] = 0;
	mbs.param[5] = 0;
	isp_mboxcmd(isp, &mbs, MBLOGALL);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
	}
	isp->isp_residx = mbs.param[5];
d989 10
a998 8
	mbs.param[0] = MBOX_INIT_REQ_QUEUE;
	mbs.param[1] = RQUEST_QUEUE_LEN(isp);
	mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
	mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
	mbs.param[4] = 0;
	isp_mboxcmd(isp, &mbs, MBLOGALL);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
a999 1
	isp->isp_reqidx = isp->isp_reqodx = mbs.param[4];
d1288 8
d1635 1
a1635 1
	 * (in case we're connected to an server doing aliasing).
d3160 1
a3160 1
	if (isp_getrqentry(isp, &nxti, &optr, (void **)&qep)) {
d3189 1
a3189 1
			if (isp_getrqentry(isp, &nxti, &optr, (void **) &qep)) {
d4219 3
d4225 1
d4348 1
a4348 2
		buf[0] = 0;
		STRNCAT(buf, "states=>", sizeof buf);
d4350 1
a4350 1
			STRNCAT(buf, " GOT_BUS", sizeof buf);
d4353 1
a4353 1
			STRNCAT(buf, " GOT_TGT", sizeof buf);
d4356 1
a4356 1
			STRNCAT(buf, " SENT_CDB", sizeof buf);
d4359 1
a4359 1
			STRNCAT(buf, " XFRD_DATA", sizeof buf);
d4362 1
a4362 1
			STRNCAT(buf, " GOT_STS", sizeof buf);
d4365 1
a4365 1
			STRNCAT(buf, " GOT_SNS", sizeof buf);
d4368 1
a4368 1
			STRNCAT(buf, " XFR_CMPLT", sizeof buf);
d4370 1
a4370 1
		STRNCAT(buf, "\nstatus=>", sizeof buf);
d4372 1
a4372 1
			STRNCAT(buf, " Disconnect", sizeof buf);
d4375 1
a4375 1
			STRNCAT(buf, " Sync_xfr", sizeof buf);
d4378 1
a4378 1
			STRNCAT(buf, " Parity", sizeof buf);
d4381 1
a4381 1
			STRNCAT(buf, " Bus_Reset", sizeof buf);
d4384 1
a4384 1
			STRNCAT(buf, " Device_Reset", sizeof buf);
d4387 1
a4387 1
			STRNCAT(buf, " Aborted", sizeof buf);
d4390 1
a4390 1
			STRNCAT(buf, " Timeout", sizeof buf);
d4393 1
a4393 1
			STRNCAT(buf, " Negotiation", sizeof buf);
d4865 2
a4866 2
	ISPOPMAP(0xdf, 0xdf),	/* 0x52: INITIALIZE REQUEST QUEUE A64 */
	ISPOPMAP(0xff, 0xff),	/* 0x53: INITIALIZE RESPONSE QUEUE A64 */
d5208 1
a5208 1
	NULL,
d5908 2
a5909 1
		isp_parse_nvram_12160(isp, 1, nvram_data);
@


1.29
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.28 2002/12/15 13:18:11 henning Exp $ */
d400 1
a400 1
			 * If we're in Ultra Mode, we have to be 60MHz clock-
@


1.28
log
@more typos fixed by torh
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.27 2002/08/17 17:48:45 mjacob Exp $ */
d400 1
a400 1
			 * If we're in Ultra Mode, we have to be 60Mhz clock-
@


1.27
log
@If the HBA is already 'touched', still set maxluns.

Don't whine if the name server returns "no such registered type"
when we ask it for all FC-SCSI objects.

Fix a few typos.

If we get a f/w crash, if ISP_FW_CRASH_DUMP is *not* defined, do
the isp_reinit inline, otherwise, let the platform isp_async
drive things. This is because, typically, the platform isp_async
will freeze things and wake up a thread to do the actual f/w
crash dump (really *can't* be done on the interrupt stack- the
23XX has one move on the order of 500KBytes of crash dump data).

Set up to handle default framsize && exec_throttle and iid/loopid
overrides.


If we're using ancient (pre 1.17.0) 2100 f/w (for the cards that cannot
load f/w images > 0x7fff words), set ISP_FW_ATTR_SCCLUN. We explicitly
don't believe we can find attributes if f/w is < 1.17.0, so we have to
set SCCLUN for the 1.15.37 f/w we're using manually- otherwise every
target will replicate itself across all 16 supported luns for non-SCCLUN
f/w.

Correctly set things up for 23XX and either fast posting or ZIO. The
23XX, it turns out, does not support RIO. If you put a non-zero value
in xfwoptions, this will disable fast posting. If you put ICBXOPT_ZIO
in xfwoptions, then the 23XX will do interrupt delays but post to the
response queue- apparently QLogic *now* believes that reading multiple
handles from registers is less of a win than writing (and delaying)
multiple 64 byte responses to the response queue.

At the end of taking a a good f/w crash dump, send the ISPASYNC_FW_DUMPED
event to the outer layers (who can then do things like wake a user
daemon to *fetch* the crash image, etc.).
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.26 2002/05/17 01:31:13 mjacob Exp $ */
d6498 1
a6498 1
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped succesfully");
d6661 1
a6661 1
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped succesfully");
@


1.26
log
@Switch to new fabric search mechanism (leave the old one in place). Switch
vendors really don't like to support GET ALL NEXT, so we use a different,
larger memory footprint, method.

Split 2300/2312 support so we distinguish between the two.

Correctly identify that SCC Luns are 16384 luns for us, not 65536.

Turn on Reduced Interrupt Operation for LVD SCSI cards, which rocks.

Do 'mailbox continuations' in some cases- this batches repeated mailbox
commands so we don't have to wake the invokee until we're done with the
N thousand or so mailbox commands we needed to do.

Put in firmware dump code (optioned out for now- but there if needed to
capture issues for QLogic).

Fix a boatload of bugs- like handling cases of dropped frames that show
up as 'bogus' residuals (i.e., we get a a DATA UNDERRUN as reported by
the f/w, but there is no RESPONSE UNDERRUN in the FCP RSPNS IU, or the
residual is bogus- this led to a lot of silent data corruption cases).
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.25 2001/12/14 00:20:54 mjacob Exp $ */
d164 1
a164 1
	int loops, i, touched, dodnld = 1;
d187 1
a187 1
	if ((touched = isp->isp_touched) == 0) {
d731 4
a734 1
		 * than 1.17.0.
d736 4
a739 2
		if (IS_2100(isp) && 
		   (ISP_FW_REVX(isp->isp_fwrev) < ISP_FW_REV(1, 17, 0))) {
d741 1
d800 3
a802 3
	if (touched == 0) {
		if (IS_SCSI(isp)) {
			if (dodnld) {
d808 7
a814 5
			if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
				isp->isp_maxluns = 16384;
			} else {
				isp->isp_maxluns = 16;
			}
d1181 1
a1181 1
	if (ISP_FW_REVX(isp->isp_fwrev) < ISP_FW_REV(1, 17, 0)) {
d1253 11
a1263 3
			if (IS_2300(isp) && isp->isp_revision < 2) {
				icbp->icb_fwoptions &= ~ICBOPT_FAST_POST;
			}
d1282 1
a1282 2
	 * was, but it seems safer to only support this on the
	 * 23XX cards.
d1284 1
a1284 2
	 * I have it disabled if we support a target mode role for
	 * reasons I can't now remember.
d1286 2
a1287 1
	if ((isp->isp_role & ISP_ROLE_TARGET) == 0 && IS_23XX(isp)) {
d1293 1
d1295 5
a1299 2
	if ((IS_2200(isp) && ISP_FW_REVX(isp->isp_fwrev) >=
	    ISP_FW_REV(2, 1, 26)) || IS_23XX(isp)) {
d1346 3
a1348 2
	isp_prt(isp, ISP_LOGDEBUG1,
	    "isp_fibre_init: fwoptions 0x%x", fcp->isp_fwoptions);
d1606 12
a1617 3
	if (IS_2100(isp))
		check_for_fabric = 1;
	else if (fcp->isp_topo == TOPO_FL_PORT || fcp->isp_topo == TOPO_F_PORT)
d1619 1
a1619 1
	else
d2444 7
a2450 1
			isp_prt(isp, ISP_LOGWARN, swrej, "GA_NXT",
d2463 4
d2599 7
a2605 1
		isp_prt(isp, ISP_LOGWARN, swrej, "GID_FT",
d3072 1
a3072 1
			    fcp->isp_loopstate < LOOP_PDB_RCVD) {
d3248 1
a3248 1
	    XS_CHANNEL(xs), target, XS_LUN(xs), XS_CDBP(xs)[0],
d3488 2
a3489 1
		if (IS_FC(isp) || isp->isp_state != ISP_RUNSTATE) {
d3715 1
a3715 2
			if (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE ||
			    ts != RQCS_ABORTED) {
d3717 7
a3723 2
				    "cannot find handle 0x%x in xflist",
				    sp->req_handle);
d3913 8
d3922 5
a3926 1
		/* no point continuing after this */
d4045 1
a4045 1
		break;
d4186 1
d4188 1
a4188 4
#ifdef	ISP_TARGET_MODE
			(void) isp_target_async(isp, bus, ASYNC_SYSTEM_ERROR);
#endif
			/* no point continuing after this */
d4386 10
d5541 7
d5564 1
a5564 1
		fcp->isp_maxfrmlen = ICB_DFLT_FRMLEN;
d5566 1
a5566 1
		fcp->isp_execthrottle = ISP_EXEC_THROTTLE;
d5783 9
a5791 8
		goto skip;
	}
	isp_init(isp);
	if (isp->isp_role == ISP_ROLE_NONE) {
		goto skip;
	}
	if (isp->isp_state == ISP_INITSTATE) {
		isp->isp_state = ISP_RUNSTATE;
a5792 4
	if (isp->isp_state != ISP_RUNSTATE) {
		isp_prt(isp, ISP_LOGERR, "isp_reinit cannot restart card");
	}
skip:
d5964 3
a5966 2
	sdp->isp_initiator_id =
		ISP_NVRAM_INITIATOR_ID(nvram_data);
d6091 3
a6093 2
	sdp->isp_initiator_id =
	    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);
d6183 3
a6185 2
	sdp->isp_initiator_id =
	    ISP12160_NVRAM_INITIATOR_ID(nvram_data, bus);
d6330 7
d6339 3
a6341 2
	fcp->isp_maxfrmlen =
		ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);
d6346 6
a6351 4
	fcp->isp_loopid =
		ISP2100_NVRAM_HARDLOOPID(nvram_data);
	fcp->isp_execthrottle =
		ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);
a6352 4
	isp_prt(isp, ISP_LOGDEBUG0,
	    "NVRAM: maxfrmlen %d execthrottle %d fwoptions 0x%x loopid %x",
	    fcp->isp_maxfrmlen, fcp->isp_execthrottle, fcp->isp_fwoptions,
	    fcp->isp_loopid);
d6500 1
d6663 1
@


1.25
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.24 2001/10/24 18:31:15 mjacob Exp $ */
d99 2
d110 2
d116 1
a116 1
static int isp_parse_async(struct ispsoftc *, int);
d122 1
d134 2
a135 1
static int isp_scan_fabric(struct ispsoftc *);
d138 1
d223 1
a223 1
	if (IS_2300(isp)) {
d252 3
d548 1
a548 1
		if (IS_2200(isp) || IS_2300(isp)) {
d566 1
a566 1
	if (IS_2300(isp)) {
d632 1
a632 1
	if (IS_2300(isp))
d638 13
a650 12
		u_int16_t fwlen  = isp->isp_mdvec->dv_ispfw[3];
		for (i = 0; i < fwlen; i++) {
			mbs.param[0] = MBOX_WRITE_RAM_WORD;
			mbs.param[1] = code_org + i;
			mbs.param[2] = isp->isp_mdvec->dv_ispfw[i];
			isp_mboxcmd(isp, &mbs, MBLOGNONE);
			if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
				isp_prt(isp, ISP_LOGERR,
				    "F/W download failed at word %d", i);
				dodnld = 0;
				goto again;
			}
a651 1

d679 4
a682 2
	/* give it a chance to start */
	USEC_SLEEP(isp, 500);
d780 1
a780 1
	 * 65536 luns for Fibre Channel cards.
d803 1
a803 1
				isp->isp_maxluns = 65536;
d981 5
d988 2
d1150 1
a1150 1
	loopid = DEFAULT_LOOPID(isp);
a1181 1

d1225 1
a1225 1
	if (IS_2200(isp) || IS_2300(isp)) {
d1244 2
a1245 2
		if (IS_2300(isp)) {
			if (isp->isp_revision < 2) {
d1258 21
d1280 1
a1280 1
	    ISP_FW_REV(2, 1, 26)) || IS_2300(isp)) {
d1294 1
a1294 1
	if (IS_2300(isp)) {
d1329 2
d1345 1
d1385 1
d1390 1
d1393 1
d1426 1
d1430 1
d1433 1
d1568 1
a1568 1
	if (IS_2200(isp) || IS_2300(isp)) {
d1645 1
a1645 1
	if (IS_2300(isp)) {
d1658 1
a1658 1
	isp_prt(isp, ISP_LOGINFO, topology, fcp->isp_loopid, fcp->isp_alpa,
d1825 1
a1825 1
		if (lp->loggedin &&
d1854 1
a1854 1
				isp_prt(isp, ISP_LOGINFO, lretained,
a1860 2
		lp->force_logout = 0;

d1870 2
a1871 1
			if (isp_getpdb(isp, lp->loopid, &pdb) == 0) {
a1876 1
				lp->loggedin = 0;
d1881 1
a1881 1
			lp->loggedin = 0;
a1897 4
			if (IS_2200(isp) || IS_2300(isp)) {
				/* only issue a PLOGI if not logged in */
				mbs.param[1] |= 0x1;
			}
d2301 50
d2352 1
a2352 1
isp_scan_fabric(struct ispsoftc *isp)
d2356 1
a2356 1
	int hicap, first_portid_seen, last_port_same;
d2363 1
d2374 1
a2374 2

	for (first_portid_seen = hicap = 0; hicap < 65535; hicap++) {
d2377 3
a2379 2
		sns_ganrsp_t *rs0, *rs1;
		u_int8_t sc[SNS_GAN_REQ_SIZE];
d2382 2
a2383 2
		MEMZERO((void *) rq, SNS_GAN_REQ_SIZE);
		rq->snscb_rblen = SNS_GAN_RESP_SIZE >> 1;
d2389 1
a2389 1
		rq->snscb_data[0] = SNS_GAN;
d2393 1
a2393 1
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GAN_REQ_SIZE);
d2395 1
a2395 1
		mbs.param[1] = SNS_GAN_REQ_SIZE >> 1;
d2403 2
a2404 3
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			if (fcp->isp_loopstate == LOOP_SCANNING_FABRIC) {
d2407 1
a2407 30
			if (mbs.param[0] == MBOX_COMMAND_ERROR) {
				char tbuf[16];
				char *m;
				switch (mbs.param[1]) {
				case 1:
					m = "No Loop";
					break;
				case 2:
					m = "Failed to allocate IOCB buffer";
					break;
				case 3:
					m = "Failed to allocate XCB buffer";
					break;
				case 4:
					m = "timeout or transmit failed";
					break;
				case 5:
					m = "no fabric loop";
					break;
				case 6:
					m = "remote device not a target";
					break;
				default:
					SNPRINTF(tbuf, sizeof tbuf, "%x",
					    mbs.param[1]);
					m = tbuf;
					break;
				}
				isp_prt(isp, ISP_LOGERR, "SNS Failed- %s", m);
			}
d2410 11
a2420 3
		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate < LOOP_SCANNING_FABRIC) {
			return (-1);
d2422 2
a2423 5
		MEMORYBARRIER(isp, SYNC_SFORCPU, 0x100, SNS_GAN_RESP_SIZE);
		rs1 = (sns_ganrsp_t *) fcp->isp_scratch;
		rs0 = (sns_ganrsp_t *) ((u_int8_t *)fcp->isp_scratch + 0x100);
		isp_get_gan_response(isp, rs0, rs1);
		portid = (((u_int32_t) rs1->snscb_port_id[0]) << 16) |
d2426 48
a2473 1
		(void) isp_async(isp, ISPASYNC_FABRIC_DEV, rs1);
d2476 1
d2486 1
d2490 27
d2518 48
a2565 2
	if (hicap >= 65535) {
		isp_prt(isp, ISP_LOGWARN, "fabric too big (> 65535)");
d2569 6
a2574 1
	 * We either have a broken name server or a huge fabric if we get here.
d2576 219
d2798 1
d2804 1
a2804 1
	u_int8_t local[SNS_RFT_REQ_SIZE];
d2808 2
a2809 2
	MEMZERO((void *) reqp, SNS_RFT_REQ_SIZE);
	reqp->snscb_rblen = SNS_RFT_RESP_SIZE >> 1;
d2815 1
a2815 1
	reqp->snscb_data[0] = SNS_RFT;
d2818 1
a2818 1
	reqp->snscb_data[6] = 0x100;	/* SCS - FCP */
d2820 1
a2820 1
	reqp->snscb_data[6] |= 20;	/* ISO/IEC 8802-2 LLC/SNAP */
d2822 1
d2825 1
a2825 1
	mbs.param[1] = SNS_RFT_REQ_SIZE >> 1;
d2834 1
d3023 1
a3023 1
			if (isp_scan_fabric(isp)) {
d3322 2
a3323 1
			return (isp_scan_fabric(isp));
d3400 3
a3402 1
#define	MAX_REQUESTQ_COMPLETIONS	32
d3411 1
d3418 1
d3429 5
d3440 2
a3441 6
		} else {
			int fhandle = isp_parse_async(isp, (int) mbox);
			isp_prt(isp, ISP_LOGDEBUG2, "Async Mbox 0x%x", mbox);
			if (fhandle > 0) {
				isp_fastpost_complete(isp, (u_int16_t) fhandle);
			}
d3472 1
a3472 1
	if (IS_2300(isp)) {
d3474 3
d3488 2
d3491 1
a3491 1
	if (IS_2100(isp) || IS_2300(isp)) {
d3508 1
d3520 1
a3520 1
		if (IS_2300(isp)) {
d3528 11
a3538 1
			isp_prt(isp, ISP_LOGDEBUG0,
a3540 1
			isp->isp_intbogus++;
d3543 1
d3547 5
d3572 10
d3583 7
a3589 1
			if (!isp_handle_other_response(isp, type, hp, &optr)) {
d3663 1
d3665 10
a3674 3
			isp_prt(isp, ISP_LOGERR,
			    "cannot find handle 0x%x in xflist",
			    sp->req_handle);
d3818 1
a3818 1
		 * While we're at it, reqad the requst queue out pointer.
d3821 2
d3826 1
d3830 1
d3841 1
a3841 1
isp_parse_async(struct ispsoftc *isp, int mbox)
d3843 1
a3844 1
	u_int16_t fast_post_handle = 0;
d3851 1
d3857 2
a3858 1
		isp_target_async(isp, bus, mbox);
d3865 2
a3866 1
		return (-1);
d3890 2
a3891 1
		isp_target_async(isp, bus, mbox);
d3899 2
a3900 1
		isp_target_async(isp, bus, mbox);
d3957 21
d3979 4
a3982 3
		fast_post_handle = ISP_READ(isp, OUTMAILBOX1);
		isp_prt(isp, ISP_LOGDEBUG3, "fast post completion of %u",
		    fast_post_handle);
d3986 1
d3988 5
a3992 7
		/*
		 * Bus gets overloaded with the handle. Dual bus
		 * cards don't put bus# into the handle.
		 */
		bus = (ISP_READ(isp, OUTMAILBOX2) << 16) |
		    ISP_READ(isp, OUTMAILBOX1);
		isp_target_async(isp, bus, mbox);
d3996 1
d3998 1
a3998 1

d4009 2
a4010 1
		isp_target_async(isp, bus, mbox);
d4044 2
a4045 1
		isp_target_async(isp, bus, mbox);
d4056 2
a4057 1
		isp_target_async(isp, bus, mbox);
d4068 2
a4069 1
		isp_target_async(isp, bus, mbox);
d4100 2
a4101 1
		isp_target_async(isp, bus, mbox);
d4126 1
a4126 1
			isp_target_async(isp, bus, ASYNC_SYSTEM_ERROR);
d4149 22
a4170 1
	return (fast_post_handle);
d4186 1
a4186 1
		return (0);
d4197 1
d4199 3
a4201 1
		return (isp_target_notify(isp, (ispstatusreq_t *) hp, optrp));
d4209 1
a4209 1
			return (0);
d4213 1
a4213 1
		return (-1);
d4413 13
d4431 1
d4454 2
a4455 2
		    "internal queues full for %d.%d.%d status 0x%x", XS_TGT(xs),
		    XS_LUN(xs), XS_CHANNEL(xs), *XS_STSP(xs));
a4530 6
		isp_prt(isp, ISP_LOGINFO,
		    "Port Unavailable for target %d", XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
		}
		return;
d4535 25
a4559 2
		isp_prt(isp, ISP_LOGINFO,
		    "port logout for target %d", XS_TGT(xs));
d4620 1
d4624 49
d4888 1
a4888 1
	ISPOPMAP(0x00, 0x00),	/* 0x0f: */
d4964 2
a4965 2
	ISPOPMAP(0x00, 0x00),	/* 0x5b: */
	ISPOPMAP(0x00, 0x00),	/* 0x5c: */
d5001 7
d5024 1
a5024 1
	NULL,
d5142 40
d5529 5
a5533 3
		if (nvfail || (isp->isp_confopts & ISP_CFG_OWNWWN)) {
			isp_prt(isp, ISP_LOGCONFIG,
			    "Using Node WWN 0x%08x%08x, Port WWN 0x%08x%08x",
d5535 11
a5545 1
			    (u_int32_t) (DEFAULT_NODEWWN(isp) & 0xffffffff),
a5547 2
			isp->isp_confopts |= ISP_CFG_OWNWWN;
			ISP_NODEWWN(isp) = DEFAULT_NODEWWN(isp);
a5553 1
			ISP_NODEWWN(isp) = fcp->isp_nodewwn;
d5827 3
d6212 9
a6220 6
	wwn = ISP2100_NVRAM_NODE_NAME(nvram_data);
	if (wwn) {
		isp_prt(isp, ISP_LOGCONFIG, "NVRAM Node WWN 0x%08x%08x",
		    (u_int32_t) (wwn >> 32), (u_int32_t) (wwn & 0xffffffff));
		if ((wwn >> 60) == 0) {
			wwn |= (((u_int64_t) 2)<< 60);
d6222 2
d6267 3
a6269 2
	    "NVRAM: maxfrmlen %d execthrottle %d fwoptions 0x%x",
	    fcp->isp_maxfrmlen, fcp->isp_execthrottle, fcp->isp_fwoptions);
d6271 319
@


1.25.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.25 2001/12/14 00:20:54 mjacob Exp $ */
a98 2
static const char swrej[] =
    "Fabric Nameserver rejected %s (Reason=0x%x Expl=0x%x) for Port ID 0x%x";
a107 2
static const char bun[] =
    "bad underrun for %d.%d (count %d, resid %d, status %s)";
d112 1
a112 1
static int isp_parse_async(struct ispsoftc *, u_int16_t);
a117 1
static int isp_mbox_continue(struct ispsoftc *);
d129 1
a129 2
static int isp_fabric_mbox_cmd(struct ispsoftc *, mbreg_t *);
static int isp_scan_fabric(struct ispsoftc *, int);
a131 1
static void isp_mboxcmd_qnw(struct ispsoftc *, mbreg_t *, int);
d216 1
a216 1
	if (IS_23XX(isp)) {
a244 3
		case ISP_HA_FC_2312:
			btype = "2312";
			break;
d538 1
a538 1
		if (IS_2200(isp) || IS_23XX(isp)) {
d556 1
a556 1
	if (IS_23XX(isp)) {
d622 1
a622 1
	if (IS_23XX(isp))
d628 12
a639 13
		isp->isp_mbxworkp = (void *) &isp->isp_mdvec->dv_ispfw[1];
		isp->isp_mbxwrk0 = isp->isp_mdvec->dv_ispfw[3] - 1;
		isp->isp_mbxwrk1 = code_org + 1;
		mbs.param[0] = MBOX_WRITE_RAM_WORD;
		mbs.param[1] = code_org;
		mbs.param[2] = isp->isp_mdvec->dv_ispfw[0];
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			isp_prt(isp, ISP_LOGERR,
			    "F/W download failed at word %d",
			    isp->isp_mbxwrk1 - code_org);
			dodnld = 0;
			goto again;
d641 1
d669 2
a670 4
	/*
	 * Give it a chance to start.
	 */
	USEC_DELAY(500);
d768 1
a768 1
	 * 16384 luns for Fibre Channel cards.
d791 1
a791 1
				isp->isp_maxluns = 16384;
a968 5
#ifndef	ISP_NO_RIO
	if (IS_ULTRA2(isp) || IS_1240(isp))
		mbs.param[1] |= FW_FEATURE_RIO_16BIT;
#else
#ifndef	ISP_NO_FASTPOST
a970 2
#endif
#endif
d1131 1
a1131 1
	loopid = fcp->isp_loopid;
d1163 1
d1207 1
a1207 1
	if (IS_2200(isp) || IS_23XX(isp)) {
d1226 2
a1227 2
		if (IS_23XX(isp)) {
			if (IS_2300(isp) && isp->isp_revision < 2) {
a1239 21
#ifndef	ISP_NO_RIO_FC
	/*
	 * RIO seems to be enabled in 2100s for fw >= 1.17.0.
	 *
	 * I've had some questionable problems with RIO on 2200.
	 * More specifically, on a 2204 I had problems with RIO
	 * on a Linux system where I was dropping commands right
	 * and left. It's not clear to me what the actual problem
	 * was, but it seems safer to only support this on the
	 * 23XX cards.
	 *
	 * I have it disabled if we support a target mode role for
	 * reasons I can't now remember.
	 */
	if ((isp->isp_role & ISP_ROLE_TARGET) == 0 && IS_23XX(isp)) {
		icbp->icb_xfwoptions |= ICBXOPT_RIO_16BIT;
		icbp->icb_racctimer = 4;
		icbp->icb_idelaytimer = 8;
	}
#endif

d1241 1
a1241 1
	    ISP_FW_REV(2, 1, 26)) || IS_23XX(isp)) {
d1255 1
a1255 1
	if (IS_23XX(isp)) {
a1289 2

	FC_SCRATCH_ACQUIRE(isp);
a1303 1
	FC_SCRATCH_RELEASE(isp);
a1342 1
	FC_SCRATCH_ACQUIRE(isp);
a1346 1
		FC_SCRATCH_RELEASE(isp);
a1348 1
	FC_SCRATCH_RELEASE(isp);
a1380 1
	FC_SCRATCH_ACQUIRE(isp);
a1383 1
		FC_SCRATCH_RELEASE(isp);
a1385 1
	FC_SCRATCH_RELEASE(isp);
d1520 1
a1520 1
	if (IS_2200(isp) || IS_23XX(isp)) {
d1597 1
a1597 1
	if (IS_23XX(isp)) {
d1610 1
a1610 1
	isp_prt(isp, ISP_LOGCONFIG, topology, fcp->isp_loopid, fcp->isp_alpa,
d1777 1
a1777 1
		if (lp->loggedin && lp->force_logout == 0 &&
d1806 1
a1806 1
				isp_prt(isp, ISP_LOGCONFIG, lretained,
d1813 2
d1824 1
a1824 2
			if (lp->force_logout ||
			    isp_getpdb(isp, lp->loopid, &pdb) == 0) {
d1830 1
d1835 1
a1835 1
			lp->force_logout = lp->loggedin = 0;
d1852 4
a2258 50

static int
isp_fabric_mbox_cmd(struct ispsoftc *isp, mbreg_t *mbp)
{
	isp_mboxcmd(isp, mbp, MBLOGNONE);
	if (mbp->param[0] != MBOX_COMMAND_COMPLETE) {
		if (FCPARAM(isp)->isp_loopstate == LOOP_SCANNING_FABRIC) {
			FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
		}
		if (mbp->param[0] == MBOX_COMMAND_ERROR) {
			char tbuf[16];
			char *m;
			switch (mbp->param[1]) {
			case 1:
				m = "No Loop";
				break;
			case 2:
				m = "Failed to allocate IOCB buffer";
				break;
			case 3:
				m = "Failed to allocate XCB buffer";
				break;
			case 4:
				m = "timeout or transmit failed";
				break;
			case 5:
				m = "no fabric loop";
				break;
			case 6:
				m = "remote device not a target";
				break;
			default:
				SNPRINTF(tbuf, sizeof tbuf, "%x",
				    mbp->param[1]);
				m = tbuf;
				break;
			}
			isp_prt(isp, ISP_LOGERR, "SNS Failed- %s", m);
		}
		return (-1);
	}

	if (FCPARAM(isp)->isp_fwstate != FW_READY ||
	    FCPARAM(isp)->isp_loopstate < LOOP_SCANNING_FABRIC) {
		return (-1);
	}
	return(0);
}

#ifdef	ISP_USE_GA_NXT
d2260 1
a2260 1
isp_scan_fabric(struct ispsoftc *isp, int ftype)
d2264 1
a2264 1
	int hicap, last_port_same;
a2270 1
	FC_SCRATCH_ACQUIRE(isp);
d2281 2
a2282 1
	for (hicap = 0; hicap < GA_NXT_MAX; hicap++) {
d2285 2
a2286 3
		sns_ga_nxt_rsp_t *rs0, *rs1;
		struct lportdb lcl;
		u_int8_t sc[SNS_GA_NXT_RESP_SIZE];
d2289 2
a2290 2
		MEMZERO((void *) rq, SNS_GA_NXT_REQ_SIZE);
		rq->snscb_rblen = SNS_GA_NXT_RESP_SIZE >> 1;
d2296 1
a2296 1
		rq->snscb_data[0] = SNS_GA_NXT;
d2300 1
a2300 1
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GA_NXT_REQ_SIZE);
d2302 1
a2302 1
		mbs.param[1] = SNS_GA_NXT_REQ_SIZE >> 1;
d2310 3
a2312 2
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
d2315 30
a2344 1
			FC_SCRATCH_RELEASE(isp);
d2347 3
a2349 11
		MEMORYBARRIER(isp, SYNC_SFORCPU, 0x100, SNS_GA_NXT_RESP_SIZE);
		rs1 = (sns_ga_nxt_rsp_t *) sc;
		rs0 = (sns_ga_nxt_rsp_t *) ((u_int8_t *)fcp->isp_scratch+0x100);
		isp_get_ga_nxt_response(isp, rs0, rs1);
		if (rs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, ISP_LOGWARN, swrej, "GA_NXT",
			    rs1->snscb_cthdr.ct_reason,
			    rs1->snscb_cthdr.ct_explanation, portid);
			FC_SCRATCH_RELEASE(isp);
			fcp->isp_loopstate = LOOP_FSCAN_DONE;
			return (0);
d2351 5
a2355 2
		portid =
		    (((u_int32_t) rs1->snscb_port_id[0]) << 16) |
d2358 1
a2358 48

		/*
		 * Okay, we now have information about a fabric object.
		 * If it is the type we're interested in, tell the outer layers
		 * about it. The outer layer needs to  know: Port ID, WWNN,
		 * WWPN, FC4 type, and port type.
		 *
		 * The lportdb structure is adequate for this.
		 */
		MEMZERO(&lcl, sizeof (lcl));
		lcl.port_type = rs1->snscb_port_type;
		lcl.fc4_type = ftype;
		lcl.portid = portid;
		lcl.node_wwn =
		    (((u_int64_t)rs1->snscb_nodename[0]) << 56) |
		    (((u_int64_t)rs1->snscb_nodename[1]) << 48) |
		    (((u_int64_t)rs1->snscb_nodename[2]) << 40) |
		    (((u_int64_t)rs1->snscb_nodename[3]) << 32) |
		    (((u_int64_t)rs1->snscb_nodename[4]) << 24) |
		    (((u_int64_t)rs1->snscb_nodename[5]) << 16) |
		    (((u_int64_t)rs1->snscb_nodename[6]) <<  8) |
		    (((u_int64_t)rs1->snscb_nodename[7]));
		lcl.port_wwn =
		    (((u_int64_t)rs1->snscb_portname[0]) << 56) |
		    (((u_int64_t)rs1->snscb_portname[1]) << 48) |
		    (((u_int64_t)rs1->snscb_portname[2]) << 40) |
		    (((u_int64_t)rs1->snscb_portname[3]) << 32) |
		    (((u_int64_t)rs1->snscb_portname[4]) << 24) |
		    (((u_int64_t)rs1->snscb_portname[5]) << 16) |
		    (((u_int64_t)rs1->snscb_portname[6]) <<  8) |
		    (((u_int64_t)rs1->snscb_portname[7]));

		/*
		 * Does this fabric object support the type we want?
		 * If not, skip it.
		 */
		if (rs1->snscb_fc4_types[ftype >> 5] & (1 << (ftype & 0x1f))) {
			if (first_portid == portid) {
				lcl.last_fabric_dev = 1;
			} else {
				lcl.last_fabric_dev = 0;
			}
			(void) isp_async(isp, ISPASYNC_FABRIC_DEV, &lcl);
		} else {
			isp_prt(isp, ISP_LOGDEBUG0,
			    "PortID 0x%x doesn't support FC4 type 0x%x",
			    portid, ftype);
		}
a2360 1
			FC_SCRATCH_RELEASE(isp);
a2369 1
			last_port_same = 0 ;
a2372 27
	FC_SCRATCH_RELEASE(isp);
	if (hicap >= GA_NXT_MAX) {
		isp_prt(isp, ISP_LOGWARN, "fabric too big (> %d)", GA_NXT_MAX);
	}
	fcp->isp_loopstate = LOOP_FSCAN_DONE;
	return (0);
}
#else
#define	GIDLEN	((ISP2100_SCRLEN >> 1) + 16)
#define	NGENT	((GIDLEN - 16) >> 2)

#define	IGPOFF	(ISP2100_SCRLEN - GIDLEN)
#define	GXOFF	(256)

static int
isp_scan_fabric(struct ispsoftc *isp, int ftype)
{
	fcparam *fcp = FCPARAM(isp);
	mbreg_t mbs;
	int i;
	sns_gid_ft_req_t *rq;
	sns_gid_ft_rsp_t *rs0, *rs1;

	if (fcp->isp_onfabric == 0) {
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		return (0);
	}
d2374 2
a2375 48
	FC_SCRATCH_ACQUIRE(isp);
	fcp->isp_loopstate = LOOP_SCANNING_FABRIC;

	rq = (sns_gid_ft_req_t *)fcp->tport;
	MEMZERO((void *) rq, SNS_GID_FT_REQ_SIZE);
	rq->snscb_rblen = GIDLEN >> 1;
	rq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+IGPOFF);
	rq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+IGPOFF);
	rq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+IGPOFF);
	rq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+IGPOFF);
	rq->snscb_sblen = 6;
	rq->snscb_cmd = SNS_GID_FT;
	rq->snscb_mword_div_2 = NGENT;
	rq->snscb_fc4_type = ftype;
	isp_put_gid_ft_request(isp, rq, (sns_gid_ft_req_t *) fcp->isp_scratch);
	MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GID_FT_REQ_SIZE);
	mbs.param[0] = MBOX_SEND_SNS;
	mbs.param[1] = SNS_GID_FT_REQ_SIZE >> 1;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);

	/*
	 * Leave 4 and 5 alone
	 */
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
	if (isp_fabric_mbox_cmd(isp, &mbs)) {
		if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
			fcp->isp_loopstate = LOOP_PDB_RCVD;
		}
		FC_SCRATCH_RELEASE(isp);
		return (-1);
	}
	if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
		FC_SCRATCH_RELEASE(isp);
		return (-1);
	}
	MEMORYBARRIER(isp, SYNC_SFORCPU, IGPOFF, GIDLEN);
	rs1 = (sns_gid_ft_rsp_t *) fcp->tport;
	rs0 = (sns_gid_ft_rsp_t *) ((u_int8_t *)fcp->isp_scratch+IGPOFF);
	isp_get_gid_ft_response(isp, rs0, rs1, NGENT);
	if (rs1->snscb_cthdr.ct_response != FS_ACC) {
		isp_prt(isp, ISP_LOGWARN, swrej, "GID_FT",
		    rs1->snscb_cthdr.ct_reason,
		    rs1->snscb_cthdr.ct_explanation, 0);
		FC_SCRATCH_RELEASE(isp);
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		return (0);
d2379 1
a2379 6
	 * Okay, we now have a list of Port IDs for this class of device.
	 * Go through the list and for each one get the WWPN/WWNN for it
	 * and tell the outer layers about it. The outer layer needs to
	 * know: Port ID, WWNN, WWPN, FC4 type, and (possibly) port type.
	 *
	 * The lportdb structure is adequate for this.
a2380 219
	i = -1;
	do {
		sns_gxn_id_req_t grqbuf, *gq = &grqbuf;
		sns_gxn_id_rsp_t *gs0, grsbuf, *gs1 = &grsbuf;
		struct lportdb lcl;
#if	0
		sns_gff_id_rsp_t *fs0, ffsbuf, *fs1 = &ffsbuf;
#endif

		i++;
		MEMZERO(&lcl, sizeof (lcl));
		lcl.fc4_type = ftype;
		lcl.portid =
		    (((u_int32_t) rs1->snscb_ports[i].portid[0]) << 16) |
		    (((u_int32_t) rs1->snscb_ports[i].portid[1]) << 8) |
		    (((u_int32_t) rs1->snscb_ports[i].portid[2]));

		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
		gq->snscb_rblen = SNS_GXN_ID_RESP_SIZE >> 1;
		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF);
		gq->snscb_sblen = 6;
		gq->snscb_cmd = SNS_GPN_ID;
		gq->snscb_portid = lcl.portid;
		isp_put_gxn_id_request(isp, gq,
		    (sns_gxn_id_req_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE);
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GXN_ID_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GXN_ID_RESP_SIZE);
		gs0 = (sns_gxn_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
		isp_get_gxn_id_response(isp, gs0, gs1);
		if (gs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, ISP_LOGWARN, swrej, "GPN_ID",
			    gs1->snscb_cthdr.ct_reason,
			    gs1->snscb_cthdr.ct_explanation, lcl.portid);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				return (-1);
			}
			continue;
		}
		lcl.port_wwn = 
		    (((u_int64_t)gs1->snscb_wwn[0]) << 56) |
		    (((u_int64_t)gs1->snscb_wwn[1]) << 48) |
		    (((u_int64_t)gs1->snscb_wwn[2]) << 40) |
		    (((u_int64_t)gs1->snscb_wwn[3]) << 32) |
		    (((u_int64_t)gs1->snscb_wwn[4]) << 24) |
		    (((u_int64_t)gs1->snscb_wwn[5]) << 16) |
		    (((u_int64_t)gs1->snscb_wwn[6]) <<  8) |
		    (((u_int64_t)gs1->snscb_wwn[7]));

		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
		gq->snscb_rblen = SNS_GXN_ID_RESP_SIZE >> 1;
		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF);
		gq->snscb_sblen = 6;
		gq->snscb_cmd = SNS_GNN_ID;
		gq->snscb_portid = lcl.portid;
		isp_put_gxn_id_request(isp, gq,
		    (sns_gxn_id_req_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE);
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GXN_ID_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GXN_ID_RESP_SIZE);
		gs0 = (sns_gxn_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
		isp_get_gxn_id_response(isp, gs0, gs1);
		if (gs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, ISP_LOGWARN, swrej, "GNN_ID",
			    gs1->snscb_cthdr.ct_reason,
			    gs1->snscb_cthdr.ct_explanation, lcl.portid);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				return (-1);
			}
			continue;
		}
		lcl.node_wwn = 
		    (((u_int64_t)gs1->snscb_wwn[0]) << 56) |
		    (((u_int64_t)gs1->snscb_wwn[1]) << 48) |
		    (((u_int64_t)gs1->snscb_wwn[2]) << 40) |
		    (((u_int64_t)gs1->snscb_wwn[3]) << 32) |
		    (((u_int64_t)gs1->snscb_wwn[4]) << 24) |
		    (((u_int64_t)gs1->snscb_wwn[5]) << 16) |
		    (((u_int64_t)gs1->snscb_wwn[6]) <<  8) |
		    (((u_int64_t)gs1->snscb_wwn[7]));

		/*
		 * The QLogic f/w is bouncing this with a parameter error.
		 */
#if	0
		/*
		 * Try and get FC4 Features (FC-GS-3 only).
		 * We can use the sns_gxn_id_req_t for this request.
		 */
		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
		gq->snscb_rblen = SNS_GFF_ID_RESP_SIZE >> 1;
		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF);
		gq->snscb_sblen = 6;
		gq->snscb_cmd = SNS_GFF_ID;
		gq->snscb_portid = lcl.portid;
		isp_put_gxn_id_request(isp, gq,
		    (sns_gxn_id_req_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE);
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GXN_ID_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GFF_ID_RESP_SIZE);
		fs0 = (sns_gff_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
		isp_get_gff_id_response(isp, fs0, fs1);
		if (fs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, /* ISP_LOGDEBUG0 */ ISP_LOGWARN,
			    swrej, "GFF_ID",
			    fs1->snscb_cthdr.ct_reason,
			    fs1->snscb_cthdr.ct_explanation, lcl.portid);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				return (-1);
			}
		} else {
			int index = (ftype >> 3);
			int bshft = (ftype & 0x7) * 4;
			int fc4_fval =
			    (fs1->snscb_fc4_features[index] >> bshft) & 0xf;
			if (fc4_fval & 0x1) {
				lcl.roles |=
				    (SVC3_INI_ROLE >> SVC3_ROLE_SHIFT);
			}
			if (fc4_fval & 0x2) {
				lcl.roles |=
				    (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);
			}
		}
#endif

		/*
		 * If we really want to know what kind of port type this is,
		 * we have to run another CT command. Otherwise, we'll leave
		 * it as undefined.
		 *
		lcl.port_type = 0;
		 */
		if (rs1->snscb_ports[i].control & 0x80) {
			lcl.last_fabric_dev = 1;
		} else {
			lcl.last_fabric_dev = 0;
		}
		(void) isp_async(isp, ISPASYNC_FABRIC_DEV, &lcl);

	} while ((rs1->snscb_ports[i].control & 0x80) == 0 && i < NGENT-1);

	/*
	 * If we're not at the last entry, our list isn't big enough.
	 */
	if ((rs1->snscb_ports[i].control & 0x80) == 0) {
		isp_prt(isp, ISP_LOGWARN, "fabric too big for scratch area");
	}

	FC_SCRATCH_RELEASE(isp);
a2383 1
#endif
d2389 1
a2389 1
	u_int8_t local[SNS_RFT_ID_REQ_SIZE];
d2393 2
a2394 2
	MEMZERO((void *) reqp, SNS_RFT_ID_REQ_SIZE);
	reqp->snscb_rblen = SNS_RFT_ID_RESP_SIZE >> 1;
d2400 1
a2400 1
	reqp->snscb_data[0] = SNS_RFT_ID;
d2403 1
a2403 1
	reqp->snscb_data[6] = (1 << FC4_SCSI);
d2405 1
a2405 1
	reqp->snscb_data[6] |= (1 << FC4_IP);	/* ISO/IEC 8802-2 LLC/SNAP */
a2406 1
	FC_SCRATCH_ACQUIRE(isp);
d2409 1
a2409 1
	mbs.param[1] = SNS_RFT_ID_REQ_SIZE >> 1;
a2417 1
	FC_SCRATCH_RELEASE(isp);
d2606 1
a2606 1
			if (isp_scan_fabric(isp, FC4_SCSI)) {
d2905 1
a2905 2
			int ftype = (arg)? *((int *) arg) : FC4_SCSI;
			return (isp_scan_fabric(isp, ftype));
d2982 1
a2982 3
#ifndef	MAX_REQUESTQ_COMPLETIONS
#define	MAX_REQUESTQ_COMPLETIONS	64
#endif
a2990 1
again:
a2996 1
			isp->isp_intmboxc++;
a3006 5
				if (isp->isp_mbxwrk0) {
					if (isp_mbox_continue(isp) == 0) {
						return;
					}
				}
d3013 6
a3018 2
		} else if (isp_parse_async(isp, mbox) < 0) {
			return;
d3049 1
a3049 1
	if (IS_23XX(isp)) {
a3050 3
		/*
		 * Debug: to be taken out eventually
		 */
a3061 2
	 *
	 * Debounce the 2300 if revision less than 2.
d3063 1
a3063 1
	if (IS_2100(isp) || (IS_2300(isp) && isp->isp_revision < 2)) {
a3079 1
	isp->isp_resodx = iptr;
d3091 1
a3091 1
		if (IS_23XX(isp)) {
d3099 1
a3099 11
			if (IS_23XX(isp)) {
				;
			} else {
				sema = ISP_READ(isp, BIU_SEMA);
				mbox = ISP_READ(isp, OUTMAILBOX0);
				if ((sema & 0x3) && (mbox & 0x8000)) {
					goto again;
				}
			}
			isp->isp_intbogus++;
			isp_prt(isp, ISP_LOGDEBUG1,
d3102 1
a3104 1
	isp->isp_resodx = iptr;
a3107 5
	if (isp->isp_rspbsy) {
		return;
	}
	isp->isp_rspbsy = 1;

a3127 10
		} else if (type == RQSTYPE_RIO2) {
			isp_rio2_t rio;
			isp_get_rio2(isp, (isp_rio2_t *) hp, &rio);
			for (i = 0; i < rio.req_header.rqs_seqno; i++) {
				isp_fastpost_complete(isp, rio.req_handles[i]);
			}
			if (isp->isp_fpcchiwater < rio.req_header.rqs_seqno)
				isp->isp_fpcchiwater = rio.req_header.rqs_seqno;
			MEMZERO(hp, QENTRY_LEN);	/* PERF */
			continue;
d3129 1
a3129 7
			/*
			 * Somebody reachable via isp_handle_other_response
			 * may have updated the response queue pointers for
			 * us, so we reload our goal index.
			 */
			if (isp_handle_other_response(isp, type, hp, &optr)) {
				iptr = isp->isp_resodx;
a3202 1
			u_int8_t ts = sp->req_completion_status & 0xff;
d3204 3
a3206 10
			/*
			 * Only whine if this isn't the expected fallout of
			 * aborting the command.
			 */
			if (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE ||
			    ts != RQCS_ABORTED) {
				isp_prt(isp, ISP_LOGERR,
				    "cannot find handle 0x%x in xflist",
				    sp->req_handle);
			}
d3350 1
a3350 1
		 * While we're at it, read the requst queue out pointer.
a3352 2
		if (isp->isp_rscchiwater < ndone)
			isp->isp_rscchiwater = ndone;
a3355 1
	isp->isp_rspbsy = 0;
a3358 1
			isp->isp_rsltccmplt++;
d3369 1
a3369 1
isp_parse_async(struct ispsoftc *isp, u_int16_t mbox)
a3370 1
	int rval = 0;
d3372 1
a3378 1
	isp_prt(isp, ISP_LOGDEBUG2, "Async Mbox 0x%x", mbox);
d3384 1
a3384 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3391 1
a3391 2
		rval = -1;
		break;
d3415 1
a3415 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3423 1
a3423 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
a3479 21
	/*
	 * We can use bus, which will always be zero for FC cards,
	 * as a mailbox pattern accumulator to be checked below.
	 */
	case ASYNC_RIO5:
		bus = 0x1ce;	/* outgoing mailbox regs 1-3, 6-7 */
		break;

	case ASYNC_RIO4:
		bus = 0x14e;	/* outgoing mailbox regs 1-3, 6 */
		break;

	case ASYNC_RIO3:
		bus = 0x10e;	/* outgoing mailbox regs 1-3 */
		break;

	case ASYNC_RIO2:
		bus = 0x106;	/* outgoing mailbox regs 1-2 */
		break;

	case ASYNC_RIO1:
d3481 3
a3483 4
		bus = 0x102;	/* outgoing mailbox regs 1 */
		break;

	case ASYNC_RIO_RESP:
a3486 1
	{
d3488 7
a3494 5
		int handle =
		    (ISP_READ(isp, OUTMAILBOX2) << 16) | 
		    (ISP_READ(isp, OUTMAILBOX1));
		if (isp_target_async(isp, handle, mbox))
			rval = -1;
a3497 1
		isp->isp_fphccmplt++;	/* count it as a fast posting intr */
d3499 1
a3499 1
	}
d3510 1
a3510 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3544 1
a3544 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3555 1
a3555 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3566 1
a3566 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3597 1
a3597 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3622 1
a3622 1
			(void) isp_target_async(isp, bus, ASYNC_SYSTEM_ERROR);
d3645 1
a3645 22

	if (bus & 0x100) {
		int i, nh;
		u_int16_t handles[5];

		for (nh = 0, i = 1; i < MAX_MAILBOX; i++) {
			if ((bus & (1 << i)) == 0) {
				continue;
			}
			handles[nh++] = ISP_READ(isp, MBOX_OFF(i));
		}
		for (i = 0; i < nh; i++) {
			isp_fastpost_complete(isp, handles[i]);
			isp_prt(isp,  ISP_LOGDEBUG3,
			    "fast post completion of %u", handles[i]);
		}
		if (isp->isp_fpcchiwater < nh)
			isp->isp_fpcchiwater = nh;
	} else {
		isp->isp_intoasync++;
	}
	return (rval);
d3661 1
a3661 1
		return (1);
a3671 1
		isp->isp_rsltccmplt++;	/* count as a response completion */
d3673 1
a3673 3
		if (isp_target_notify(isp, (ispstatusreq_t *) hp, optrp)) {
			return (1);
		}
d3681 1
a3681 1
			return (1);
d3685 1
a3685 1
		return (0);
a3884 13
	{
		if (IS_FC(isp)) {
			int ru_marked = (sp->req_scsi_status & RQCS_RU) != 0;
			if (!ru_marked || sp->req_resid > XS_XFRLEN(xs)) {
				isp_prt(isp, ISP_LOGWARN, bun, XS_TGT(xs),
				    XS_LUN(xs), XS_XFRLEN(xs), sp->req_resid,
				    (ru_marked)? "marked" : "not marked");
				if (XS_NOERR(xs)) {
					XS_SETERR(xs, HBA_BOTCH);
				}
				return;
			}
		}
a3889 1
	}
d3912 2
a3913 2
		    "internal queues full for %d.%d.%d status 0x%x",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs), *XS_STSP(xs));
d3989 6
d3999 2
a4000 25
		if ((sp->req_completion_status & 0xff) == RQCS_PORT_UNAVAILABLE)
			isp_prt(isp, ISP_LOGINFO,
			    "port unavailable for target %d", XS_TGT(xs));
		else
			isp_prt(isp, ISP_LOGINFO,
			    "port logout for target %d", XS_TGT(xs));
		/*
		 * If we're on a local loop, force a LIP (which is overkill)
		 * to force a re-login of this unit. If we're on fabric,
		 * then we'll have to relogin as a matter of course.
		 */
		if (FCPARAM(isp)->isp_topo == TOPO_NL_PORT ||
		    FCPARAM(isp)->isp_topo == TOPO_FL_PORT) {
			mbreg_t mbs;
			mbs.param[0] = MBOX_INIT_LIP;
			isp_mboxcmd_qnw(isp, &mbs, 1);
		}

		/*
		 * Probably overkill.
		 */
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
		isp_mark_getpdb_all(isp);
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_OTHER);
a4060 1
	isp->isp_fphccmplt++;
a4063 49
static int
isp_mbox_continue(struct ispsoftc *isp)
{
	mbreg_t mbs;
	u_int16_t *ptr;

	switch (isp->isp_lastmbxcmd) {
	case MBOX_WRITE_RAM_WORD:
	case MBOX_READ_RAM_WORD:
	case MBOX_READ_RAM_WORD_EXTENDED:
		break;
	default:
		return (1);
	}
	if (isp->isp_mboxtmp[0] != MBOX_COMMAND_COMPLETE) {
		isp->isp_mbxwrk0 = 0;
		return (-1);
	}


	/*
	 * Clear the previous interrupt.
	 */
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
	ISP_WRITE(isp, BIU_SEMA, 0);

	/*
	 * Continue with next word.
	 */
	ptr = isp->isp_mbxworkp;
	switch (isp->isp_lastmbxcmd) {
	case MBOX_WRITE_RAM_WORD:
		mbs.param[2] = *ptr++;
		mbs.param[1] = isp->isp_mbxwrk1++;
		break;
	case MBOX_READ_RAM_WORD:
	case MBOX_READ_RAM_WORD_EXTENDED:
		*ptr++ = isp->isp_mboxtmp[2];
		mbs.param[1] = isp->isp_mbxwrk1++;
		break;
	}
	isp->isp_mbxworkp = ptr;
	mbs.param[0] = isp->isp_lastmbxcmd;
	isp->isp_mbxwrk0 -= 1;
	isp_mboxcmd_qnw(isp, &mbs, 0);
	return (0);
}


d4279 1
a4279 1
	ISPOPMAP(0x03, 0x07),	/* 0x0f: MBOX_READ_RAM_WORD_EXTENDED(1) */
d4355 2
a4356 2
	ISPOPMAP(0x03, 0x01),	/* 0x5b: MBOX_DRIVER_HEARTBEAT */
	ISPOPMAP(0xcf, 0x01),	/* 0x5c: MBOX_FW_HEARTBEAT */
a4391 7
/*
 * Footnotes
 *
 * (1): this sets bits 21..16 in mailbox register #8, which we nominally 
 *	do not access at this time in the core driver. The caller is
 *	responsible for setting this register first (Gross!).
 */
d4408 1
a4408 1
	"READ RAM WORD EXTENDED",
a4525 40
isp_mboxcmd_qnw(struct ispsoftc *isp, mbreg_t *mbp, int nodelay)
{
	unsigned int lim, ibits, obits, box, opcode;
	u_int16_t *mcp;

	if (IS_FC(isp)) {
		mcp = mbpfc;
		lim = (sizeof (mbpfc) / sizeof (mbpfc[0]));
	} else {
		mcp = mbpscsi;
		lim = (sizeof (mbpscsi) / sizeof (mbpscsi[0]));
	}
	opcode = mbp->param[0];
	ibits = HIBYT(mcp[opcode]) & NMBOX_BMASK(isp);
	obits = LOBYT(mcp[opcode]) & NMBOX_BMASK(isp);
	for (box = 0; box < MAX_MAILBOX; box++) {
		if (ibits & (1 << box)) {
			ISP_WRITE(isp, MBOX_OFF(box), mbp->param[box]);
		}
		if (nodelay == 0) {
			isp->isp_mboxtmp[box] = mbp->param[box] = 0;
		}
	}
	if (nodelay == 0) {
		isp->isp_lastmbxcmd = opcode;
		isp->isp_obits = obits;
		isp->isp_mboxbsy = 1;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);
	/*
	 * Oddly enough, if we're not delaying for an answer,
	 * delay a bit to give the f/w a chance to pick up the
	 * command.
	 */
	if (nodelay) {
		USEC_DELAY(1000);
	}
}

static void
d4873 3
a4875 5
		if (nvfail) {
			isp->isp_confopts |= ISP_CFG_OWNWWPN|ISP_CFG_OWNWWNN;
		}
		if (isp->isp_confopts & ISP_CFG_OWNWWNN) {
			isp_prt(isp, ISP_LOGCONFIG, "Using Node WWN 0x%08x%08x",
d4877 1
a4877 11
			    (u_int32_t) (DEFAULT_NODEWWN(isp) & 0xffffffff));
			ISP_NODEWWN(isp) = DEFAULT_NODEWWN(isp);
		} else {
			/*
			 * We always start out with values derived
			 * from NVRAM or our platform default.
			 */
			ISP_NODEWWN(isp) = fcp->isp_nodewwn;
		}
		if (isp->isp_confopts & ISP_CFG_OWNWWPN) {
			isp_prt(isp, ISP_LOGCONFIG, "Using Port WWN 0x%08x%08x",
d4880 2
d4888 1
a5161 3
		if (IS_2312(isp) && isp->isp_port) {
			wo += 128;
		}
d5544 6
a5549 9
	if (IS_2200(isp) || IS_23XX(isp)) {
		wwn = ISP2200_NVRAM_NODE_NAME(nvram_data);
		if (wwn) {
			isp_prt(isp, ISP_LOGCONFIG, "NVRAM Node WWN 0x%08x%08x",
			    (u_int32_t) (wwn >> 32),
			    (u_int32_t) (wwn & 0xffffffff));
			if ((wwn >> 60) == 0) {
				wwn |= (((u_int64_t) 2)<< 60);
			}
a5550 2
	} else {
		wwn &= ~((u_int64_t) 0xfff << 48);
d5594 2
a5595 3
	    "NVRAM: maxfrmlen %d execthrottle %d fwoptions 0x%x loopid %x",
	    fcp->isp_maxfrmlen, fcp->isp_execthrottle, fcp->isp_fwoptions,
	    fcp->isp_loopid);
a5596 319

#ifdef	ISP_FW_CRASH_DUMP
static void isp2200_fw_dump(struct ispsoftc *);
static void isp2300_fw_dump(struct ispsoftc *);

static void
isp2200_fw_dump(struct ispsoftc *isp)
{
	int i, j;
	mbreg_t mbs;
	u_int16_t *ptr;

	ptr = FCPARAM(isp)->isp_dump_data;
	if (ptr == NULL) {
		isp_prt(isp, ISP_LOGERR,
		   "No place to dump RISC registers and SRAM");
		return;
	}
	if (*ptr++) {
		isp_prt(isp, ISP_LOGERR,
		   "dump area for RISC registers and SRAM already used");
		return;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
			break;
		}
	}
	if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
		/*
		 * PBIU Registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + (i << 1));
		}

		/*
		 * Mailbox Registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, MBOX_BLOCK + (i << 1));
		}

		/*
		 * DMA Registers
		 */
		for (i = 0; i < 48; i++) {
			*ptr++ = ISP_READ(isp, DMA_BLOCK + 0x20 + (i << 1));
		}

		/*
		 * RISC H/W Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0);
		for (i = 0; i < 16; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0xA0 + (i << 1));
		}

		/*
		 * RISC GP Registers
		 */
		for (j = 0; j < 8; j++) {
			ISP_WRITE(isp, BIU_BLOCK + 0xA4, 0x2000 + (j << 8));
			for (i = 0; i < 16; i++) {
				*ptr++ =
				    ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
			}
		}

		/*
		 * Frame Buffer Hardware Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x10);
		for (i = 0; i < 16; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * Fibre Protocol Module 0 Hardware Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x20);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * Fibre Protocol Module 1 Hardware Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x30);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}
	} else {
		isp_prt(isp, ISP_LOGERR, "RISC Would Not Pause");
		return;
	}
	isp_prt(isp, ISP_LOGALL,
	   "isp_fw_dump: RISC registers dumped successfully");
	ISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, OUTMAILBOX0) == 0) {
			break;
		}
	}
	if (ISP_READ(isp, OUTMAILBOX0) != 0) {
		isp_prt(isp, ISP_LOGERR, "Board Would Not Reset");
		return;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
			break;
		}
	}
	if ((ISP_READ(isp, HCCR) & HCCR_PAUSE) == 0) {
		isp_prt(isp, ISP_LOGERR, "RISC Would Not Pause After Reset");
		return;
	}
	ISP_WRITE(isp, RISC_EMB, 0xf2);
	ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if ((ISP_READ(isp, HCCR) & HCCR_PAUSE) == 0) {
			break;
		}
	}
	ENABLE_INTS(isp);
	mbs.param[0] = MBOX_READ_RAM_WORD;
	mbs.param[1] = 0x1000;
	isp->isp_mbxworkp = (void *) ptr;
	isp->isp_mbxwrk0 = 0xefff;	/* continuation count */
	isp->isp_mbxwrk1 = 0x1001;	/* next SRAM address */
	isp_control(isp, ISPCTL_RUN_MBOXCMD, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGWARN,
		    "RAM DUMP FAILED @@ WORD %x", isp->isp_mbxwrk1);
		return;
	}
	ptr = isp->isp_mbxworkp;	/* finish fetch of final word */
	*ptr++ = isp->isp_mboxtmp[2];
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped succesfully");
	FCPARAM(isp)->isp_dump_data[0] = isp->isp_type; /* now used */
}

static void
isp2300_fw_dump(struct ispsoftc *isp)
{
	int i, j;
	mbreg_t mbs;
	u_int16_t *ptr;

	ptr = FCPARAM(isp)->isp_dump_data;
	if (ptr == NULL) {
		isp_prt(isp, ISP_LOGERR,
		   "No place to dump RISC registers and SRAM");
		return;
	}
	if (*ptr++) {
		isp_prt(isp, ISP_LOGERR,
		   "dump area for RISC registers and SRAM already used");
		return;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
			break;
		}
	}
	if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
		/*
		 * PBIU registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + (i << 1));
		}

		/*
		 * ReqQ-RspQ-Risc2Host Status registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x10 + (i << 1));
		}

		/*
		 * Mailbox Registers
		 */
		for (i = 0; i < 32; i++) {
			*ptr++ =
			    ISP_READ(isp, PCI_MBOX_REGS2300_OFF + (i << 1));
		}

		/*
		 * Auto Request Response DMA registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x40);
		for (i = 0; i < 32; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * DMA registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x50);
		for (i = 0; i < 48; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * RISC hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0);
		for (i = 0; i < 16; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0xA0 + (i << 1));
		}

		/*
		 * RISC GP? registers
		 */
		for (j = 0; j < 8; j++) {
			ISP_WRITE(isp, BIU_BLOCK + 0xA4, 0x2000 + (j << 9));
			for (i = 0; i < 16; i++) {
				*ptr++ =
				    ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
			}
		}

		/*
		 * frame buffer hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x10);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * FPM B0 hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x20);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * FPM B1 hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x30);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}
	} else {
		isp_prt(isp, ISP_LOGERR, "RISC Would Not Pause");
		return;
	}
	isp_prt(isp, ISP_LOGALL,
	   "isp_fw_dump: RISC registers dumped successfully");
	ISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, OUTMAILBOX0) == 0) {
			break;
		}
	}
	if (ISP_READ(isp, OUTMAILBOX0) != 0) {
		isp_prt(isp, ISP_LOGERR, "Board Would Not Reset");
		return;
	}
	ENABLE_INTS(isp);
	mbs.param[0] = MBOX_READ_RAM_WORD;
	mbs.param[1] = 0x800;
	isp->isp_mbxworkp = (void *) ptr;
	isp->isp_mbxwrk0 = 0xf7ff;	/* continuation count */
	isp->isp_mbxwrk1 = 0x801;	/* next SRAM address */
	isp_control(isp, ISPCTL_RUN_MBOXCMD, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGWARN,
		    "RAM DUMP FAILED @@ WORD %x", isp->isp_mbxwrk1);
		return;
	}
	ptr = isp->isp_mbxworkp;	/* finish fetch of final word */
	*ptr++ = isp->isp_mboxtmp[2];

	/*
	 * We don't have access to mailbox registers 8.. onward
	 * in our 'common' device model- so we have to set it
	 * here and hope it stays the same!
	 */
	ISP_WRITE(isp, PCI_MBOX_REGS2300_OFF + (8 << 1), 0x1);

	mbs.param[0] = MBOX_READ_RAM_WORD_EXTENDED;
	mbs.param[1] = 0;
	isp->isp_mbxworkp = (void *) ptr;
	isp->isp_mbxwrk0 = 0xffff;	/* continuation count */
	isp->isp_mbxwrk1 = 0x1;		/* next SRAM address */
	isp_control(isp, ISPCTL_RUN_MBOXCMD, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGWARN,
		    "RAM DUMP FAILED @@ WORD %x", 0x10000 + isp->isp_mbxwrk1);
		return;
	}
	ptr = isp->isp_mbxworkp;	/* finish final word */
	*ptr++ = mbs.param[2];
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped succesfully");
	FCPARAM(isp)->isp_dump_data[0] = isp->isp_type; /* now used */
}

void
isp_fw_dump(struct ispsoftc *isp)
{
	if (IS_2200(isp))
		isp2200_fw_dump(isp);
	else if (IS_23XX(isp))
		isp2300_fw_dump(isp);
}
#endif
@


1.25.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.25.2.1 2002/06/11 03:42:18 art Exp $ */
d164 1
a164 1
	int loops, i, dodnld = 1;
d187 1
a187 1
	if (isp->isp_touched == 0) {
d731 1
a731 4
		 * than 1.17.0, unless it's the firmware we specifically
		 * are loading.
		 *
		 * Note that all 22XX and 23XX f/w is greater than 1.X.0.
d733 2
a734 4
		if (!(ISP_FW_NEWER_THAN(isp, 1, 17, 0))) {
#ifdef	USE_SMALLER_2100_FIRMWARE
			FCPARAM(isp)->isp_fwattr = ISP_FW_ATTR_SCCLUN;
#else
a735 1
#endif
d794 3
a796 3
	if (IS_SCSI(isp)) {
		if (dodnld) {
			if (IS_ULTRA2(isp) || IS_ULTRA3(isp)) {
d802 5
a806 7
			isp->isp_maxluns = 8;
		}
	} else {
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
			isp->isp_maxluns = 16384;
		} else {
			isp->isp_maxluns = 16;
d1173 1
a1173 1
	if (!ISP_FW_NEWER_THAN(isp, 1, 17, 0)) {
d1245 3
a1247 11
			/*
			 * QLogic recommends that FAST Posting be turned
			 * off for 23XX cards and instead allow the HBA
			 * to write response queue entries and interrupt
			 * after a delay (ZIO).
			 *
			 * If we set ZIO, it will disable fast posting,
			 * so we don't need to clear it in fwoptions.
			 */
			icbp->icb_xfwoptions |= ICBXOPT_ZIO;

d1266 2
a1267 1
	 * was.
d1269 2
a1270 1
	 * 23XX Cards do not support RIO. Instead they support ZIO.
d1272 1
a1272 2
#if	0
	if (!IS_23XX(isp) && ISP_FW_NEWER_THAN(isp, 1, 17, 0)) {
a1277 1
#endif
d1279 2
a1280 5
	/*
	 * For 22XX > 2.1.26 && 23XX, set someoptions.
	 * XXX: Probably okay for newer 2100 f/w too.
	 */
	if (ISP_FW_NEWER_THAN(isp, 2, 26, 0)) {
d1327 2
a1328 3
	isp_prt(isp, ISP_LOGDEBUG0,
	    "isp_fibre_init: fwopt 0x%x xfwopt 0x%x zfwopt 0x%x",
	    icbp->icb_fwoptions, icbp->icb_xfwoptions, icbp->icb_zfwoptions);
d1586 3
a1588 12
	if (IS_2100(isp)) {
		/*
		 * Don't bother with fabric if we are using really old
		 * 2100 firmware. It's just not worth it.
		 */
		if (ISP_FW_NEWER_THAN(isp, 1, 15, 37)) {
			check_for_fabric = 1;
		} else {
			check_for_fabric = 0;
		}
	} else if (fcp->isp_topo == TOPO_FL_PORT ||
	    fcp->isp_topo == TOPO_F_PORT) {
d1590 1
a1590 1
	} else
d2415 1
a2415 7
			int level;
			if (rs1->snscb_cthdr.ct_reason == 9 &&
			    rs1->snscb_cthdr.ct_explanation == 7)
				level = ISP_LOGDEBUG0;
			else
				level = ISP_LOGWARN;
			isp_prt(isp, level, swrej, "GA_NXT",
a2427 4
		 * XXX: We should check to make sure that this entry
		 * XXX: supports the type(s) we are interested in.
		 */
		/*
d2560 1
a2560 7
		int level;
		if (rs1->snscb_cthdr.ct_reason == 9 &&
		    rs1->snscb_cthdr.ct_explanation == 7)
			level = ISP_LOGDEBUG0;
		else
			level = ISP_LOGWARN;
		isp_prt(isp, level, swrej, "GID_FT",
d3027 1
a3027 1
			    fcp->isp_loopstate < LOOP_FSCAN_DONE) {
d3203 1
a3203 1
	    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs), XS_CDBP(xs)[0],
d3443 1
a3443 2
		if ((IS_FC(isp) && mbox != ASYNC_RIO_RESP) ||
		    isp->isp_state != ISP_RUNSTATE) {
d3669 2
a3670 1
			if (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {
d3672 2
a3673 7
				    "cannot find handle 0x%x (type 0x%x)",
				    sp->req_handle,
				    sp->req_header.rqs_entry_type);
			} else if (ts != RQCS_ABORTED) {
				isp_prt(isp, ISP_LOGERR,
				    "cannot find handle 0x%x (status 0x%x)",
				    sp->req_handle, ts);
a3862 8
#ifdef	ISP_FW_CRASH_DUMP
		/*
		 * If we have crash dumps enabled, it's up to the handler
		 * for isp_async to reinit stuff and restart the firmware
		 * after performing the crash dump. The reason we do things
		 * this way is that we may need to activate a kernel thread
		 * to do all the crash dump goop.
		 */
d3864 1
a3864 5
#else
		isp_async(isp, ISPASYNC_FW_CRASH, NULL);
		isp_reinit(isp);
		isp_async(isp, ISPASYNC_FW_RESTARTED, NULL);
#endif
d3983 1
a3983 1
		return (rval);
a4123 1
			isp_async(isp, ISPASYNC_FW_CRASH, NULL);
d4125 4
a4128 1
			isp_async(isp, ISPASYNC_FW_RESTARTED, NULL);
a4325 10
		/*
	 	 * Check to see if we logged out the device.
		 */
		if (IS_FC(isp)) {
			if ((sp->req_completion_status & RQSTF_LOGOUT) &&
			    FCPARAM(isp)->portdb[XS_TGT(xs)].valid &&
			    FCPARAM(isp)->portdb[XS_TGT(xs)].fabric_dev) {
				FCPARAM(isp)->portdb[XS_TGT(xs)].relogin = 1;
			}
		}
a5470 7
#ifndef	DEFAULT_FRAMESIZE
#define	DEFAULT_FRAMESIZE(isp)		ICB_DFLT_FRMLEN
#endif
#ifndef	DEFAULT_EXEC_THROTTLE
#define	DEFAULT_EXEC_THROTTLE(isp)	ISP_EXEC_THROTTLE
#endif

d5487 1
a5487 1
		fcp->isp_maxfrmlen = DEFAULT_FRAMESIZE(isp);
d5489 1
a5489 1
		fcp->isp_execthrottle = DEFAULT_EXEC_THROTTLE(isp);
d5706 11
a5716 9
	} else if (isp->isp_role != ISP_ROLE_NONE) {
		isp_init(isp);
		if (isp->isp_state == ISP_INITSTATE) {
			isp->isp_state = ISP_RUNSTATE;
		}
		if (isp->isp_state != ISP_RUNSTATE) {
			isp_prt(isp, ISP_LOGERR,
			    "isp_reinit cannot restart card");
		}
d5718 1
d5890 2
a5891 3
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		sdp->isp_initiator_id =
			ISP_NVRAM_INITIATOR_ID(nvram_data);
d6016 2
a6017 3
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		sdp->isp_initiator_id =
		    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);
d6107 2
a6108 3
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		sdp->isp_initiator_id =
		    ISP12160_NVRAM_INITIATOR_ID(nvram_data, bus);
a6252 7
	isp_prt(isp, ISP_LOGDEBUG0,
	    "NVRAM: maxfrmlen %d execthrottle %d fwoptions 0x%x loopid %x",
	    ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data),
	    ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data),
	    ISP2100_NVRAM_OPTIONS(nvram_data),
	    ISP2100_NVRAM_HARDLOOPID(nvram_data));

d6255 2
a6256 3
	if ((isp->isp_confopts & ISP_CFG_OWNFSZ) == 0)
		fcp->isp_maxfrmlen =
			ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);
d6261 4
a6264 6
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		fcp->isp_loopid =
			ISP2100_NVRAM_HARDLOOPID(nvram_data);
	if ((isp->isp_confopts & ISP_CFG_OWNEXCTHROTTLE) == 0)
		fcp->isp_execthrottle =
			ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);
d6266 4
a6416 1
	(void) isp_async(isp, ISPASYNC_FW_DUMPED, 0);
a6578 1
	(void) isp_async(isp, ISPASYNC_FW_DUMPED, 0);
@


1.25.2.3
log
@sync
@
text
@d1 1
a1 1
/* 	$OpenBSD$ */
a286 2
		else if (IS_10160(isp))
			btype = "10160";
d400 1
a400 1
			 * If we're in Ultra Mode, we have to be 60MHz clock-
d791 1
a791 1
	 * Because the lun is in a different position in the Request Queue
d795 4
d953 11
a963 13
	if (IS_ULTRA2(isp) || IS_1240(isp)) {
		mbs.param[0] = MBOX_INIT_RES_QUEUE_A64;
		mbs.param[1] = RESULT_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_result_dma);
		mbs.param[3] = DMA_WD0(isp->isp_result_dma);
		mbs.param[4] = 0;
		mbs.param[6] = DMA_WD3(isp->isp_result_dma);
		mbs.param[7] = DMA_WD2(isp->isp_result_dma);
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_residx = mbs.param[5];
d965 8
a972 34
		mbs.param[0] = MBOX_INIT_REQ_QUEUE_A64;
		mbs.param[1] = RQUEST_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
		mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
		mbs.param[5] = 0;
		mbs.param[6] = DMA_WD3(isp->isp_result_dma);
		mbs.param[7] = DMA_WD2(isp->isp_result_dma);
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_reqidx = isp->isp_reqodx = mbs.param[4];
	} else {
		mbs.param[0] = MBOX_INIT_RES_QUEUE;
		mbs.param[1] = RESULT_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_result_dma);
		mbs.param[3] = DMA_WD0(isp->isp_result_dma);
		mbs.param[4] = 0;
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_residx = mbs.param[5];

		mbs.param[0] = MBOX_INIT_REQ_QUEUE;
		mbs.param[1] = RQUEST_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
		mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
		mbs.param[5] = 0;
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_reqidx = isp->isp_reqodx = mbs.param[4];
d974 1
a1262 8
#if	0
			/*
			 * Values, in 100us increments. The default
			 * is 2 (200us) if a value 0 (default) is
			 * selected.
			 */
			icbp->icb_idelaytimer = 2;
#endif
d1602 1
a1602 1
	 * (in case we're connected to a server doing aliasing).
d3127 1
a3127 1
	if (isp_getrqentry(isp, &nxti, &optr, (void *)&qep)) {
d3156 1
a3156 1
			if (isp_getrqentry(isp, &nxti, &optr, (void *) &qep)) {
a4185 3
#ifdef	ISP_FW_CRASH_DUMP
			isp_async(isp, ISPASYNC_FW_CRASH, NULL);
#else
a4188 1
#endif
d4262 3
a4265 1
		/* FALLTHROUGH */
d4311 2
a4312 1
		SNPRINTF(buf, sizeof (buf), "states=>");
d4314 1
a4314 1
			SNPRINTF(buf, sizeof (buf), "%s GOT_BUS", buf);
d4317 1
a4317 1
			SNPRINTF(buf, sizeof (buf), "%s GOT_TGT", buf);
d4320 1
a4320 1
			SNPRINTF(buf, sizeof (buf), "%s SENT_CDB", buf);
d4323 1
a4323 1
			SNPRINTF(buf, sizeof (buf), "%s XFRD_DATA", buf);
d4326 1
a4326 1
			SNPRINTF(buf, sizeof (buf), "%s GOT_STS", buf);
d4329 1
a4329 1
			SNPRINTF(buf, sizeof (buf), "%s GOT_SNS", buf);
d4332 1
a4332 1
			SNPRINTF(buf, sizeof (buf), "%s XFR_CMPLT", buf);
d4334 1
a4334 1
		SNPRINTF(buf, sizeof (buf), "%s\nstatus=>", buf);
d4336 1
a4336 1
			SNPRINTF(buf, sizeof (buf), "%s Disconnect", buf);
d4339 1
a4339 1
			SNPRINTF(buf, sizeof (buf), "%s Sync_xfr", buf);
d4342 1
a4342 1
			SNPRINTF(buf, sizeof (buf), "%s Parity", buf);
d4345 1
a4345 1
			SNPRINTF(buf, sizeof (buf), "%s Bus_Reset", buf);
d4348 1
a4348 1
			SNPRINTF(buf, sizeof (buf), "%s Device_Reset", buf);
d4351 1
a4351 1
			SNPRINTF(buf, sizeof (buf), "%s Aborted", buf);
d4354 1
a4354 1
			SNPRINTF(buf, sizeof (buf), "%s Timeout", buf);
d4357 1
a4357 1
			SNPRINTF(buf, sizeof (buf), "%s Negotiation", buf);
d4746 1
a4746 1
static const u_int16_t mbpscsi[] = {
d4829 2
a4830 2
	ISPOPMAP(0xdf, 0xff),	/* 0x52: INITIALIZE REQUEST QUEUE A64 */
	ISPOPMAP(0xef, 0xff),	/* 0x53: INITIALIZE RESPONSE QUEUE A64 */
d4942 1
a4942 1
static const u_int16_t mbpfc[] = {
d5172 1
a5172 1
	"DRIVER HEARTBEAT",
d5215 1
a5215 1
	const u_int16_t *mcp;
d5256 1
a5256 1
	const u_int16_t *mcp;
d5872 1
a5872 2
		if (IS_12160(isp))
			isp_parse_nvram_12160(isp, 1, nvram_data);
d6498 1
a6498 1
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped successfully");
d6661 1
a6661 1
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped successfully");
@


1.24
log
@Protect against deranged fabric name servers.

Correct the # of output mailboxes for EXECUTE IOCB A64.

Comment out some redundant initialization to zero.

If we get ISP_QUEUES_FULL status, remember to actually set SCSI_QFULL
since the QLogic f/w, on some cards, doesn't do so. Grumble.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.23 2001/10/06 22:45:52 mjacob Exp $ */
d112 31
a142 31
static int isp_parse_async __P((struct ispsoftc *, int));
static int isp_handle_other_response
__P((struct ispsoftc *, ispstatusreq_t *, u_int16_t *));
static void isp_parse_status
__P((struct ispsoftc *, ispstatusreq_t *, XS_T *));
static void isp_fastpost_complete __P((struct ispsoftc *, u_int16_t));
static void isp_scsi_init __P((struct ispsoftc *));
static void isp_scsi_channel_init __P((struct ispsoftc *, int));
static void isp_fibre_init __P((struct ispsoftc *));
static void isp_mark_getpdb_all __P((struct ispsoftc *));
static int isp_getmap __P((struct ispsoftc *, fcpos_map_t *));
static int isp_getpdb __P((struct ispsoftc *, int, isp_pdb_t *));
static u_int64_t isp_get_portname __P((struct ispsoftc *, int, int));
static int isp_fclink_test __P((struct ispsoftc *, int));
static char *isp2100_fw_statename __P((int));
static int isp_pdb_sync __P((struct ispsoftc *));
static int isp_scan_loop __P((struct ispsoftc *));
static int isp_scan_fabric __P((struct ispsoftc *));
static void isp_register_fc4_type __P((struct ispsoftc *));
static void isp_fw_state __P((struct ispsoftc *));
static void isp_mboxcmd __P((struct ispsoftc *, mbreg_t *, int));

static void isp_update __P((struct ispsoftc *));
static void isp_update_bus __P((struct ispsoftc *, int));
static void isp_setdfltparm __P((struct ispsoftc *, int));
static int isp_read_nvram __P((struct ispsoftc *));
static void isp_rdnvram_word __P((struct ispsoftc *, int, u_int16_t *));
static void isp_parse_nvram_1020 __P((struct ispsoftc *, u_int8_t *));
static void isp_parse_nvram_1080 __P((struct ispsoftc *, int, u_int8_t *));
static void isp_parse_nvram_12160 __P((struct ispsoftc *, int, u_int8_t *));
static void isp_parse_nvram_2100 __P((struct ispsoftc *, u_int8_t *));
d695 1
a695 1
	if (isp->isp_bustype == ISP_BT_SBUS) {
d1110 1
a1110 1
	isp_icb_t *icbp;
a1131 1
	icbp = (isp_icb_t *) fcp->isp_scratch;
a1132 1

d1290 1
a1290 2
	ISP_SWIZZLE_ICB(isp, icbp);

d1383 1
a1383 1
		ISP_UNSWIZZLE_AND_COPY_PDBP(isp, pdbp, fcp->isp_scratch);
a2263 3
	sns_screq_t *reqp;
	sns_scrsp_t *resp;
	mbreg_t mbs;
d2271 1
a2271 2
	reqp = (sns_screq_t *) fcp->isp_scratch;
	resp = (sns_scrsp_t *) (&((char *)fcp->isp_scratch)[0x100]);
d2281 1
d2283 18
a2300 15
		MEMZERO((void *) reqp, SNS_GAN_REQ_SIZE);
		reqp->snscb_rblen = SNS_GAN_RESP_SIZE >> 1;
		reqp->snscb_addr[RQRSP_ADDR0015] =
			DMA_WD0(fcp->isp_scdma + 0x100);
		reqp->snscb_addr[RQRSP_ADDR1631] =
			DMA_WD1(fcp->isp_scdma + 0x100);
		reqp->snscb_addr[RQRSP_ADDR3247] =
			DMA_WD2(fcp->isp_scdma + 0x100);
		reqp->snscb_addr[RQRSP_ADDR4863] =
			DMA_WD3(fcp->isp_scdma + 0x100);
		reqp->snscb_sblen = 6;
		reqp->snscb_data[0] = SNS_GAN;
		reqp->snscb_data[4] = portid & 0xffff;
		reqp->snscb_data[5] = (portid >> 16) & 0xff;
		ISP_SWIZZLE_SNS_REQ(isp, reqp);
d2351 8
a2358 5
		ISP_UNSWIZZLE_SNS_RSP(isp, resp, SNS_GAN_RESP_SIZE >> 1);
		portid = (((u_int32_t) resp->snscb_port_id[0]) << 16) |
		    (((u_int32_t) resp->snscb_port_id[1]) << 8) |
		    (((u_int32_t) resp->snscb_port_id[2]));
		(void) isp_async(isp, ISPASYNC_FABRIC_DEV, resp);
d2389 2
a2390 1
	sns_screq_t *reqp;
a2392 1
	reqp = (sns_screq_t *) fcp->isp_scratch;
d2407 1
a2407 1
	ISP_SWIZZLE_SNS_REQ(isp, reqp);
d2431 3
a2433 8
	u_int16_t iptr, optr, handle;
	union {
		ispreq_t *_reqp;
		ispreqt2_t *_t2reqp;
	} _u;
#define	reqp	_u._reqp
#define	t2reqp	_u._t2reqp
#define	UZSIZE	max(sizeof (ispreq_t), sizeof (ispreqt2_t))
d2665 1
a2665 1
	if (isp_getrqentry(isp, &iptr, &optr, (void **) &reqp)) {
d2676 1
d2686 1
a2686 1
			MEMZERO((void *) reqp, sizeof (*reqp));
d2691 4
a2694 4
			ISP_SWIZZLE_REQUEST(isp, reqp);
			ISP_ADD_REQUEST(isp, iptr);

			if (isp_getrqentry(isp, &iptr, &optr, (void **)&reqp)) {
d2703 1
a2703 1
	MEMZERO((void *) reqp, UZSIZE);
d2727 1
a2727 1
			t2reqp->req_flags = XS_TAG_TYPE(xs);
d2734 1
a2734 1
				t2reqp->req_flags = REQFLAG_HTAG;
d2736 1
a2736 1
				t2reqp->req_flags = REQFLAG_STAG;
d2752 1
a2752 1
			t2reqp->req_scclun = XS_LUN(xs);
d2754 1
a2754 1
			t2reqp->req_lun_trn = XS_LUN(xs);
d2759 1
a2759 1
	if (reqp->req_time == 0 && XS_TIME(xs))
d2761 1
a2762 7
	/*
	 * Always give a bit more leeway to commands after a bus reset.
	 * XXX: DOES NOT DISTINGUISH WHICH PORT MAY HAVE BEEN SYNCED
	 */
	if (isp->isp_sendmarker && reqp->req_time < 5) {
		reqp->req_time = 5;
	}
d2769 1
d2773 2
a2774 2
 	*/
	i = ISP_DMASETUP(isp, xs, reqp, &iptr, optr);
d2788 1
a2788 1
	ISP_ADD_REQUEST(isp, iptr);
a2789 2
	if (isp->isp_sendmarker)
		isp->isp_sendmarker = 0;
a2790 2
#undef	reqp
#undef	t2reqp
d2997 2
a2998 2
			int obits, i = 0;
			if ((obits = isp->isp_mboxbsy) != 0) {
d3109 3
a3111 1
		ispstatusreq_t *sp;
d3115 1
a3115 1
		sp = (ispstatusreq_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);
d3120 11
a3130 8
		 * Do any appropriate unswizzling of what the Qlogic f/w has
		 * written into memory so it makes sense to us. This is a
		 * per-platform thing. Also includes any memory barriers.
		 */
		ISP_UNSWIZZLE_RESPONSE(isp, sp, oop);
		if (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {
			if (isp_handle_other_response(isp, sp, &optr) == 0) {
				MEMZERO(sp, sizeof (isphdr_t));
d3133 8
d3154 1
a3154 1
				MEMZERO(sp, sizeof (isphdr_t));
d3193 1
a3193 1
			MEMZERO(sp, sizeof (isphdr_t));
d3203 1
a3203 1
			MEMZERO(sp, sizeof (isphdr_t));
d3212 1
d3336 1
a3336 1
		MEMZERO(sp, sizeof (isphdr_t));
d3655 2
a3656 2
isp_handle_other_response(struct ispsoftc *isp,
    ispstatusreq_t *sp, u_int16_t *optrp)
d3658 1
a3658 1
	switch (sp->req_header.rqs_entry_type) {
d3673 1
a3673 1
		return (isp_target_notify(isp, sp, optrp));
d3680 1
a3680 1
		if (isp_async(isp, ISPASYNC_UNHANDLED_RESPONSE, sp)) {
d3684 1
a3684 1
		    sp->req_header.rqs_entry_type);
d4572 2
a4573 1
	isp->isp_mboxbsy = obits;
d4584 9
@


1.23
log
@Fix various 2300 (2Gb) last minute errata. Keep up with the jones' for
the target mode code.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.22 2001/09/01 07:16:39 mjacob Exp $ */
d2266 1
a2266 1
	u_int32_t portid, first_portid;
d2270 1
a2270 1
	int hicap, first_portid_seen;
d2283 2
d2363 9
d2374 3
a2376 1
	isp_prt(isp, ISP_LOGWARN, "broken fabric nameserver...*wheeze*...");
d2717 2
a2718 2
	reqp->req_header.rqs_flags = 0;
	reqp->req_header.rqs_seqno = 0;
d2723 1
a2723 1
		XS_RESID(xs) = 0;
d2774 1
a2774 1
		isp_prt(isp, ISP_LOGDEBUG1, "out of xflist pointers");
d3286 5
d3910 1
a3910 1
		isp_prt(isp, ISP_LOGDEBUG1,
d3913 1
d3917 5
a3921 1
		 */
d3926 8
a3933 1
		break;
d4151 1
a4151 1
	ISPOPMAP(0xcf, 0xff),	/* 0x54: EXECUTE IOCB A64 */
@


1.22
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.21 2001/04/04 22:06:54 mjacob Exp $ */
a66 2
static const char warnlun[] =
    "WARNING- cannot determine Expanded LUN capability- limiting to one LUN";
a161 1

d184 7
a190 1
		 * spread through outgoing mailbox registers 1-3.
d200 1
a200 4
			isp_mboxcmd(isp, &mbs, MBOX_COMMAND_ERROR);
			/*
			 * This *shouldn't* fail.....
			 */
d211 1
d216 11
a226 4
	isp->isp_rqstinrp = INMAILBOX4;
	isp->isp_rqstoutrp = OUTMAILBOX4;
	isp->isp_respinrp = OUTMAILBOX5;
	isp->isp_respoutrp = INMAILBOX5;
a242 4
			isp->isp_rqstinrp = BIU_REQINP;
			isp->isp_rqstoutrp = BIU_REQOUTP;
			isp->isp_respinrp = BIU_RSPINP;
			isp->isp_respoutrp = BIU_RSPOUTP;
d551 4
a554 1
	 * Wait for everything to finish firing up...
d556 11
a566 7
	loops = MBOX_DELAY_COUNT;
	while (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {
		USEC_DELAY(100);
		if (--loops < 0) {
			isp_prt(isp, ISP_LOGERR,
			    "MBOX_BUSY never cleared on reset");
			return;
d689 22
d714 2
a715 1
	    mbs.param[1], mbs.param[2], mbs.param[3]);
d717 12
a728 2
		isp_prt(isp, ISP_LOGCONFIG, "Firmware Attributes = 0x%x",
		    mbs.param[6]);
a734 3
	isp->isp_fwrev[0] = mbs.param[1];
	isp->isp_fwrev[1] = mbs.param[2];
	isp->isp_fwrev[2] = mbs.param[3];
d764 2
a765 5
	 * if we haven't loaded firmware, we don't have an easy way of telling
	 * how many luns we support.
	 *
	 * We'll make a simplifying assumption- if we loaded firmware, we
	 * are running with expanded lun firmware, otherwise not.
d770 3
d783 2
a784 2
		if (dodnld) {
			if (IS_SCSI(isp)) {
d787 1
a787 1
				isp->isp_maxluns = 65536;
d790 2
a791 2
			if (IS_SCSI(isp)) {
				isp->isp_maxluns = 8;
d793 1
a793 2
				isp_prt(isp, ISP_LOGALL, warnlun);
				isp->isp_maxluns = 1;
d1216 1
a1216 1
			icbp->icb_xfwoptions = ICBXOPT_PTP_2_LOOP;
d1219 1
a1219 1
			icbp->icb_xfwoptions = ICBXOPT_PTP_ONLY;
d1222 1
a1222 1
			icbp->icb_xfwoptions = ICBXOPT_LOOP_ONLY;
d1225 1
a1225 1
			icbp->icb_xfwoptions = ICBXOPT_LOOP_2_PTP;
d1232 7
a1238 1
			icbp->icb_xfwoptions |= ICBXOPT_RATE_AUTO;
d1242 2
a1243 1
	if (IS_2200(isp) || IS_2300(isp)) {
d1599 14
d2742 1
a2742 1
		if (isp->isp_maxluns > 16)
d2865 1
a2865 1
			if (isp->isp_maxluns > 16) {
d4045 1
a4045 1
	ISPOPMAP(0x01, 0x4f),	/* 0x08: MBOX_ABOUT_FIRMWARE */
d4241 1
a4241 1
	ISPOPMAP(0x01, 0x0f),	/* 0x08: MBOX_ABOUT_FIRMWARE */
d4273 1
a4273 1
	ISPOPMAP(0x01, 0x3),	/* 0x28: MBOX_GET_FIRMWARE_OPTIONS */
d4326 1
a4326 1
	ISPOPMAP(0x00, 0x00),	/* 0x5d: */
d4457 1
a4457 1
	NULL,
d5553 2
a5554 1
	    "fwoptions from nvram are 0x%x", fcp->isp_fwoptions);
@


1.21
log
@Ansify source. Say which channel the initiator ID is for. Rename
ICBOPT_PORTNAME to ICBOPT_BOTH_WWNS as being more descriptive.
Change handles to 16 bits. Add ISPCTL_RUN_MBOXCMD control function.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.20 2001/02/12 23:44:59 mjacob Exp $ */
d73 1
a73 1
static const char retained[] = 
d103 8
d153 1
d158 1
d160 1
a160 1
	char *revname = "????";
d168 2
a169 1
	 * here.
d211 8
d229 1
a229 1
			revname = "2100";
d232 8
a239 1
			revname = "2200";
d254 1
a254 1
		revname = "1240";
d270 1
a270 1
			revname = "1280";
d272 1
a272 1
			revname = "1080";
d274 1
a274 1
			revname = "12160";
d276 1
a276 1
			revname = "<UNKLVD>";
d331 1
a331 1
			revname = "1020";
d341 1
a341 1
			revname = "1020A";
d346 1
a346 1
			revname = "1040";
d351 1
a351 1
			revname = "1040A";
d356 1
a356 1
			revname = "1040B";
d360 2
a361 2
		case 6: 
			revname = "1040C";
d364 1
a364 1
                        break; 
d534 1
a534 1
		if (IS_2200(isp)) {
d611 5
d620 1
a620 1
			mbs.param[1] = ISP_CODE_ORG + i;
d635 1
a635 1
		mbs.param[1] = ISP_CODE_ORG;
d654 1
d656 1
a656 1
	mbs.param[1] = ISP_CODE_ORG;
d679 3
a681 3
	    "Board Revision %s, %s F/W Revision %d.%d.%d", revname,
	    dodnld? "loaded" : "resident", mbs.param[1], mbs.param[2],
	    mbs.param[3]);
d895 2
a896 2
	mbs.param[2] = DMA_MSW(isp->isp_result_dma);
	mbs.param[3] = DMA_LSW(isp->isp_result_dma);
d907 2
a908 2
	mbs.param[2] = DMA_MSW(isp->isp_rquest_dma);
	mbs.param[3] = DMA_LSW(isp->isp_rquest_dma);
d970 1
a970 1
	 * Set current per-target parameters to a safe minimum.
d980 10
a989 13
		if (tgt == sdp->isp_initiator_id) {
			sdf = DPARM_DEFAULT;
		} else {
			sdf = DPARM_SAFE_DFLT;
			/*
			 * It is not quite clear when this changed over so that
			 * we could force narrow and async for 1000/1020 cards,
			 * but assume that this is only the case for loaded
			 * firmware.
			 */
			if (isp->isp_loaded_fw) {
				sdf |= DPARM_NARROW | DPARM_ASYNC;
			}
d1000 1
a1000 1
		sdf = DPARM_DEFAULT;
d1009 2
a1010 2
			    (sdp->isp_devparam[tgt].sync_offset << 8) |
			    (sdp->isp_devparam[tgt].sync_period);
d1013 1
a1013 1
		    "bus %d set tgt %d flags 0x%x off 0x%x period 0x%x",
d1040 1
a1040 1
		sdp->isp_devparam[tgt].cur_dflags = sdf & ~DPARM_TQING;
d1125 1
a1125 1
	
d1166 2
d1169 1
a1169 1
	if (IS_2200(isp)) {
d1188 27
a1215 1
	icbp->icb_logintime = 60;	/* 60 second login timeout */
d1235 8
a1242 4
	icbp->icb_rqstaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_rquest_dma);
	icbp->icb_respaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_result_dma);
d1253 2
a1254 2
	mbs.param[2] = DMA_MSW(fcp->isp_scdma);
	mbs.param[3] = DMA_LSW(fcp->isp_scdma);
d1257 2
a1258 2
	mbs.param[6] = 0;
	mbs.param[7] = 0;
d1288 2
a1289 2
	mbs.param[2] = DMA_MSW(fcp->isp_scdma);
	mbs.param[3] = DMA_LSW(fcp->isp_scdma);
d1326 2
a1327 2
	mbs.param[2] = DMA_MSW(fcp->isp_scdma);
	mbs.param[3] = DMA_LSW(fcp->isp_scdma);
d1335 2
a1336 2
	mbs.param[6] = 0;
	mbs.param[7] = 0;
d1476 1
a1476 1
	if (IS_2200(isp)) {
d1630 1
a1630 1
	    fcp->isp_loopstate != LOOP_FSCAN_DONE && 
d1723 1
a1723 1
			nwwnn = 
d1732 1
a1732 1
			nwwpn = 
d1746 1
a1746 1
			    lp->roles == nrole) {
d1755 2
d1794 1
a1794 1
			if (IS_2200(isp)) {
d2138 2
d2191 1
a2191 1
		 * 
d2229 1
a2229 1
			DMA_LSW(fcp->isp_scdma + 0x100);
d2231 5
a2235 1
			DMA_MSW(fcp->isp_scdma + 0x100);
d2243 8
a2250 5
		mbs.param[2] = DMA_MSW(fcp->isp_scdma);
		mbs.param[3] = DMA_LSW(fcp->isp_scdma);
		mbs.param[6] = 0;
		mbs.param[7] = 0;
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d2255 30
d2321 4
a2324 2
	reqp->snscb_addr[RQRSP_ADDR0015] = DMA_LSW(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR1631] = DMA_MSW(fcp->isp_scdma + 0x100);
d2336 7
a2342 4
	mbs.param[2] = DMA_MSW(fcp->isp_scdma);
	mbs.param[3] = DMA_LSW(fcp->isp_scdma);
	mbs.param[6] = 0;
	mbs.param[7] = 0;
a2369 1

d2437 11
a2447 5
			if (fcp->isp_topo != TOPO_F_PORT &&
			    target < FL_PORT_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
d2661 1
a2661 1
			 * for Request Sense or Ordered (for safety's sake).
d2666 1
a2666 1
				t2reqp->req_flags = REQFLAG_OTAG;
d2670 2
a2671 1
		if ((sdp->isp_devparam[target].cur_dflags & DPARM_TQING) &&
d2923 2
a2924 2
int
isp_intr(void *arg)
a2925 1
	struct ispsoftc *isp = arg;
d2927 1
a2927 1
	u_int16_t iptr, optr, isr, sema, junk;
d2930 4
a2933 32
	if (IS_2100(isp)) {
		i = 0;
		do {
			isr = ISP_READ(isp, BIU_ISR);
			junk = ISP_READ(isp, BIU_ISR);
		} while (isr != junk && ++i < 1000);
		if (isr != junk) {
			isp_prt(isp, ISP_LOGWARN,
			    "isr unsteady (%x, %x)", isr, junk);
		}
		i = 0;
		do {
			sema = ISP_READ(isp, BIU_SEMA);
			junk = ISP_READ(isp, BIU_SEMA);
		} while (sema != junk && ++i < 1000);
		if (sema != junk) {
			isp_prt(isp, ISP_LOGWARN,
			    "sema unsteady (%x, %x)", sema, junk);
		}
	} else {
		isr = ISP_READ(isp, BIU_ISR);
		sema = ISP_READ(isp, BIU_SEMA);
	}
	isp_prt(isp, ISP_LOGDEBUG3, "isp_intr isr %x sem %x", isr, sema);
	isr &= INT_PENDING_MASK(isp);
	sema &= BIU_SEMA_LOCK;
	isp->isp_intcnt++;
	if (isr == 0 && sema == 0) {
		isp->isp_intbogus++;
		return (0);
	}

a2934 18
		u_int16_t mbox;

		if (IS_2100(isp)) {
			i = 0;
			do {
				mbox = ISP_READ(isp, OUTMAILBOX0);
				junk = ISP_READ(isp, OUTMAILBOX0);;
			} while (junk != mbox && ++i < 1000);
			if (mbox != junk) {
				isp_prt(isp, ISP_LOGWARN,
				    "mailbox0 unsteady (%x, %x)", mbox, junk);
				ISP_WRITE(isp, BIU_SEMA, 0);
				ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
				return (1);
			}
		} else {
			mbox = ISP_READ(isp, OUTMAILBOX0);
		}
d2960 1
d2962 1
a2962 2
			ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
			return (1);
d2971 7
a2977 2
		    "interrupt (isr=%x, sema=%x) when not ready", isr, sema);
		ISP_WRITE(isp, INMAILBOX5, ISP_READ(isp, OUTMAILBOX5));
d2980 1
a2980 1
		return (1);
d2984 3
a2986 1
	 * You *must* read OUTMAILBOX5 prior to clearing the RISC interrupt.
d2988 9
a2996 1
	optr = isp->isp_residx;
d2998 5
a3002 1
	if (IS_2100(isp)) {
d3005 2
a3006 2
			iptr = ISP_READ(isp, OUTMAILBOX5);
			junk = ISP_READ(isp, OUTMAILBOX5);
d3012 3
a3014 2
			    "mailbox5 unsteady (%x, %x)", iptr, junk);
			return (1);
d3017 1
a3017 1
		iptr = ISP_READ(isp, OUTMAILBOX5);
a3019 4
	if (sema) {
		ISP_WRITE(isp, BIU_SEMA, 0);
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
d3030 13
a3042 4
		junk = ISP_READ(isp, BIU_ISR);
		isp_prt(isp, ISP_LOGDEBUG2,
		    "bogus intr- isr %x (%x) iptr %x optr %x",
		    isr, junk, iptr, optr);
d3044 2
d3092 1
a3092 1
				ISP_WRITE(isp, INMAILBOX5, optr);
d3124 1
a3124 1
			ISP_WRITE(isp, INMAILBOX5, optr);
d3133 1
a3133 1
			ISP_WRITE(isp, INMAILBOX5, optr);
d3268 5
a3272 2
		ISP_WRITE(isp, INMAILBOX5, optr);
		isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);
a3281 1
	return (1);
d3309 1
a3309 8
		mbox = ISP_READ(isp, OUTMAILBOX1);
		isp_prt(isp, ISP_LOGERR,
		    "Internal Firmware Error @@ RISC Addr 0x%x", mbox);
		ISP_DUMPREGS(isp, "Firmware Error");
		isp_reinit(isp);
#ifdef	ISP_TARGET_MODE
		isp_target_async(isp, bus, ASYNC_SYSTEM_ERROR);
#endif
d3327 1
a3327 1
		mbox = ISP_READ(isp, OUTMAILBOX4);
d3420 1
d3428 1
a3428 1
		isp_prt(isp, ISP_LOGINFO, "LIP occurred");
d3432 23
d3484 1
a3484 1
		isp_prt(isp, ISP_LOGINFO, "Loop RESET");
d3822 2
a3823 2
		isp_prt(isp, ISP_LOGERR, xact3, XS_TGT(xs),
		    XS_LUN(xs), XS_CHANNEL(xs));
d3845 2
a3846 2
		isp_prt(isp, ISP_LOGERR, pskip,
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3865 1
a3865 1
			sdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_WIDE;
d3881 1
a3881 1
			sdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_SYNC;
a3902 1

d4212 1
a4212 1
	ISPOPMAP(0x0f, 0x1),	/* 0x28: MBOX_GET_FIRMWARE_OPTIONS */
d4626 1
a4626 1
		 * take what's in dev_flags and try and set the device
d4641 1
a4641 1
			 * Make sure dev_flags has "Renegotiate on Error"
d4644 4
a4647 2
			sdp->isp_devparam[tgt].dev_flags |= DPARM_RENEG;
			sdp->isp_devparam[tgt].dev_flags &= ~DPARM_QFRZ;
a4648 2
			mbs.param[2] = sdp->isp_devparam[tgt].dev_flags;
			
d4661 2
a4662 2
				    (sdp->isp_devparam[tgt].sync_offset << 8) |
				    (sdp->isp_devparam[tgt].sync_period);
d4666 1
a4666 1
			 * RQSTF_NEGOTIATION set canl cause
a4667 1
			 &
d4675 3
a4677 3
			sdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;
			sdp->isp_devparam[tgt].cur_dflags |=
			    (sdp->isp_devparam[tgt].dev_flags & DPARM_TQING);
d4697 3
a4699 3
		sdp->isp_devparam[tgt].cur_dflags = flags;
		sdp->isp_devparam[tgt].cur_period = period;
		sdp->isp_devparam[tgt].cur_offset = offset;
d4806 1
a4806 1
	sdp->isp_cmd_dma_burst_enable = 1;
d4818 7
a4824 3
	sdp->isp_bus_reset_delay = 3;
	sdp->isp_retry_count = 2;
	sdp->isp_retry_delay = 2;
d4833 3
a4835 3
	 * If we're successful reading it, we can return since NVRAM will
	 * tell us the right thing to do. Otherwise, establish some reasonable
	 * defaults.
d4837 1
d4861 8
a4868 6
	isp_prt(isp, ISP_LOGDEBUG0,
	    "defaulting bus %d REQ/ACK Active Negation is %d",
	    channel, sdp->isp_req_ack_active_neg);
	isp_prt(isp, ISP_LOGDEBUG0,
	    "defaulting bus %d DATA Active Negation is %d",
	    channel, sdp->isp_data_line_active_neg);
d4872 1
a4872 1
	 * state (dev_flags). Then try and get the current status from
d4877 8
a4884 4
		sdp->isp_devparam[tgt].cur_offset = 0;
		sdp->isp_devparam[tgt].cur_period = 0;
		sdp->isp_devparam[tgt].dev_flags = DPARM_DEFAULT;
		sdp->isp_devparam[tgt].cur_dflags = 0;
d4889 10
a4898 1
		if ((isp->isp_bustype == ISP_BT_SBUS &&
d4904 2
a4905 19
			sdp->isp_devparam[tgt].sync_offset =
			    ISP_10M_SYNCPARMS >> 8;
			sdp->isp_devparam[tgt].sync_period =
			    ISP_10M_SYNCPARMS & 0xff;
		} else if (IS_ULTRA3(isp)) {
			sdp->isp_devparam[tgt].sync_offset =
			    ISP_80M_SYNCPARMS >> 8;
			sdp->isp_devparam[tgt].sync_period =
			    ISP_80M_SYNCPARMS & 0xff;
		} else if (IS_ULTRA2(isp)) {
			sdp->isp_devparam[tgt].sync_offset =
			    ISP_40M_SYNCPARMS >> 8;
			sdp->isp_devparam[tgt].sync_period =
			    ISP_40M_SYNCPARMS & 0xff;
		} else if (IS_1240(isp)) {
			sdp->isp_devparam[tgt].sync_offset =
			    ISP_20M_SYNCPARMS >> 8;
			sdp->isp_devparam[tgt].sync_period =
			    ISP_20M_SYNCPARMS & 0xff;
d4907 2
a4908 49
			sdp->isp_devparam[tgt].sync_offset =
			    ISP_20M_SYNCPARMS_1040 >> 8;
			sdp->isp_devparam[tgt].sync_period =
			    ISP_20M_SYNCPARMS_1040 & 0xff;
		}

		/*
		 * Don't get current target parameters if we've been
		 * told not to use NVRAM- it's really the same thing.
		 */
		if ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {

			mbs.param[0] = MBOX_GET_TARGET_PARAMS;
			mbs.param[1] = tgt << 8;
			isp_mboxcmd(isp, &mbs, MBLOGALL);
			if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
				continue;
			}
			sdp->isp_devparam[tgt].cur_dflags = mbs.param[2];
			sdp->isp_devparam[tgt].dev_flags = mbs.param[2];
			sdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;
			sdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;

			/*
			 * The maximum period we can really see
			 * here is 100 (decimal), or 400 ns.
			 * For some unknown reason we sometimes
			 * get back wildass numbers from the
			 * boot device's parameters (alpha only).
			 */
			if ((mbs.param[3] & 0xff) <= 0x64) {
				sdp->isp_devparam[tgt].sync_period =
				    mbs.param[3] & 0xff;
				sdp->isp_devparam[tgt].sync_offset =
				    mbs.param[3] >> 8;
			}

			/*
			 * It is not safe to run Ultra Mode with a clock < 60.
			 */
			if (((isp->isp_clock && isp->isp_clock < 60) ||
			    (isp->isp_type < ISP_HA_SCSI_1020A)) &&
			    (sdp->isp_devparam[tgt].sync_period <=
			    (ISP_20M_SYNCPARMS & 0xff))) {
				sdp->isp_devparam[tgt].sync_offset =
				    ISP_10M_SYNCPARMS >> 8;
				sdp->isp_devparam[tgt].sync_period =
				    ISP_10M_SYNCPARMS & 0xff;
			}
d4910 9
a4918 5
		isp_prt(isp, ISP_LOGDEBUG0,
		    "Initial bus %d tgt %d flags %x offset %x period %x",
		    channel, tgt, sdp->isp_devparam[tgt].dev_flags,
		    sdp->isp_devparam[tgt].sync_offset,
		    sdp->isp_devparam[tgt].sync_period);
a5112 1
	int i;
d5114 1
a5166 9
	for (i = 0; i < MAX_TARGETS; i++) {
		sdp->isp_devparam[i].dev_enable =
			ISP_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i);
		sdp->isp_devparam[i].exc_throttle =
			ISP_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i);
		sdp->isp_devparam[i].sync_offset =
			ISP_NVRAM_TGT_SYNC_OFFSET(nvram_data, i);
		sdp->isp_devparam[i].sync_period =
			ISP_NVRAM_TGT_SYNC_PERIOD(nvram_data, i);
d5168 23
d5196 2
a5197 2
			if (sdp->isp_devparam[i].sync_period < 0x19) {
				sdp->isp_devparam[i].sync_period = 0x19;
d5199 2
a5200 2
			if (sdp->isp_devparam[i].sync_offset > 0xc) {
				sdp->isp_devparam[i].sync_offset = 0x0c;
d5203 2
a5204 2
			if (sdp->isp_devparam[i].sync_offset > 0x8) {
				sdp->isp_devparam[i].sync_offset = 0x8;
d5207 25
a5231 15
		sdp->isp_devparam[i].dev_flags = 0;
		if (ISP_NVRAM_TGT_RENEG(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_RENEG;
		sdp->isp_devparam[i].dev_flags |= DPARM_ARQ;
		if (ISP_NVRAM_TGT_TQING(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_TQING;
		if (ISP_NVRAM_TGT_SYNC(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_SYNC;
		if (ISP_NVRAM_TGT_WIDE(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_WIDE;
		if (ISP_NVRAM_TGT_PARITY(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_PARITY;
		if (ISP_NVRAM_TGT_DISC(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_DISC;
		sdp->isp_devparam[i].cur_dflags = 0; /* we don't know */
a5237 1
	int i;
d5239 2
d5243 1
a5243 1
	sdp->isp_fifo_threshold = 
d5259 1
a5259 2
	    ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,
	    bus);
d5262 1
a5262 2
	    ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,
	    bus);
d5265 1
a5265 2
	    ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,
	    bus);
d5279 44
a5322 24
	for (i = 0; i < MAX_TARGETS; i++) {
		sdp->isp_devparam[i].dev_enable =
		    ISP1080_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);
		sdp->isp_devparam[i].exc_throttle =
			ISP1080_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);
		sdp->isp_devparam[i].sync_offset =
			ISP1080_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);
		sdp->isp_devparam[i].sync_period =
			ISP1080_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);
		sdp->isp_devparam[i].dev_flags = 0;
		if (ISP1080_NVRAM_TGT_RENEG(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_RENEG;
		sdp->isp_devparam[i].dev_flags |= DPARM_ARQ;
		if (ISP1080_NVRAM_TGT_TQING(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_TQING;
		if (ISP1080_NVRAM_TGT_SYNC(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_SYNC;
		if (ISP1080_NVRAM_TGT_WIDE(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_WIDE;
		if (ISP1080_NVRAM_TGT_PARITY(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_PARITY;
		if (ISP1080_NVRAM_TGT_DISC(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_DISC;
		sdp->isp_devparam[i].cur_dflags = 0;
d5330 1
a5330 1
	int i;
d5337 1
a5337 1
	sdp->isp_initiator_id = 
d5350 1
a5350 2
	    ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,
	    bus);
d5353 1
a5353 2
	    ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,
	    bus);
d5356 1
a5356 2
	    ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,
	    bus);
d5370 43
a5412 24
	for (i = 0; i < MAX_TARGETS; i++) {
		sdp->isp_devparam[i].dev_enable =
		    ISP12160_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);
		sdp->isp_devparam[i].exc_throttle =
			ISP12160_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);
		sdp->isp_devparam[i].sync_offset =
			ISP12160_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);
		sdp->isp_devparam[i].sync_period =
			ISP12160_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);
		sdp->isp_devparam[i].dev_flags = 0;
		if (ISP12160_NVRAM_TGT_RENEG(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_RENEG;
		sdp->isp_devparam[i].dev_flags |= DPARM_ARQ;
		if (ISP12160_NVRAM_TGT_TQING(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_TQING;
		if (ISP12160_NVRAM_TGT_SYNC(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_SYNC;
		if (ISP12160_NVRAM_TGT_WIDE(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_WIDE;
		if (ISP12160_NVRAM_TGT_PARITY(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_PARITY;
		if (ISP12160_NVRAM_TGT_DISC(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_DISC;
		sdp->isp_devparam[i].cur_dflags = 0;
d5438 1
a5438 1
			wwn |= (((u_int64_t) 2)<< 60); 
d5447 1
a5447 1
			wwn |= (((u_int64_t) 2)<< 60); 
@


1.20
log
@Remove ISP2100_FABRIC defines- we always handle fabric now. Insert
isp_getmap helper function (for getting Loop Position map). Make
sure we (for our own benefit) mark req_state_flags with RQSF_GOT_SENSE
for Fibre Channel if we got sense data- the !*$)!*$)~*$)*$ Qlogic
f/w doesn't do so. Add ISPCTL_SCAN_FABRIC, ISPCTL_SCAN_LOOP, ISPCTL_SEND_LIP,
and ISPCTL_GET_POSMAP isp_control functions. Correctly send async notifications
upstream for changes in the name server, changes in the port database, and
f/w crashes. Correctly set topology when we get a ASYNC_PTPMODE event.

Quite massively redo how we handle Loop events- we've now added several
intermediate states between LOOP_PDB_RCVD and LOOP_READY. This allows us
a lot finer control about how we scan fabric, whether we go further
than scanning fabric, how we look at the local loop, and whether we
merge entries at the level or not. This is the next to last step for
moving managing loop state out of the core module entirely (whereupon
loop && fabric events will simply freeze the command queue and a thread
will run to figure out what's changed and *it* will re-enable the queu).
This fine amount of control also gets us closer to having an external
policy engine decide which fabric devices we really want to log into.

When resetting the Qlogic 2X00 units, reset the FPM (Fibre Protocol
Module) and FBM (Fibre Buffer Modules). Also remember to clear the
semaphore registers. Tell the RISC processor to not halt on FPM
parity errors.

Throw out the ISP_CFG_NOINIT silliness and instead go to the use of
adapter 'roles' to see whether one completes initialization or not
(mostly for Fibre Channel). The ultimate intent, btw, of all of this
is to have a warm standby adapter for failover reasons.  Because
we do roles now, setting of Target Capable Class 3 service parameters
in the ICB for the 2x00 cards reflects from role. Also, in isp_start,
if we're not supporting an initiator role, we bounce outgoing commands
with a Selection Timeout error. Also clean out the TOGGLE_TMODE
goop for FC- there is no toggling of target mode like there is
for parallel SCSI cards.

Do more cleanup with respect to using target ids 0..125 in F-port
topologies. Also keep track of things which *were* fabric devices
so that when you rescan the fabric you can notify the outer layers
when fabric devices go away.

Only force a LOGOUT for fabric devices if they're still logged in
(i.e., you cat their Port Database entry. Clean up the Get All Next
scanning.

Finally, use a new tag in the softc to store the opcode for the
last mailbox command used so we can report which opcode timed
out.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.19 2001/01/09 03:26:18 mjacob Exp $ */
d6 1
a6 1
 * Copyright (c) 1997, 1998, 1999, 2000 by Matthew Jacob
d111 1
a111 1
static void isp_fastpost_complete __P((struct ispsoftc *, u_int32_t));
d146 1
a146 2
isp_reset(isp)
	struct ispsoftc *isp;
d651 2
d734 1
a734 2
isp_init(isp)
	struct ispsoftc *isp;
d751 1
a751 2
isp_scsi_init(isp)
	struct ispsoftc *isp;
d915 1
a915 3
isp_scsi_channel_init(isp, channel)
	struct ispsoftc *isp;
	int channel;
d933 2
a934 1
	isp_prt(isp, ISP_LOGINFO, "Initiator ID is %d", sdp->isp_initiator_id);
d947 16
a962 1
		sdf = DPARM_SAFE_DFLT;
d964 6
a969 4
		 * It is not quite clear when this changed over so that
		 * we could force narrow and async for 1000/1020 cards,
		 * but assume that this is only the case for loaded
		 * firmware.
d971 2
a972 3
		if (isp->isp_loaded_fw) {
			sdf |= DPARM_NARROW | DPARM_ASYNC;
		}
d974 1
a974 1
		mbs.param[1] = (tgt << 8) | (channel << 15);
d983 5
a987 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d1038 1
a1038 2
isp_fibre_init(isp)
	struct ispsoftc *isp;
a1095 5
	/*
	 * We don't set ICBOPT_PORTNAME because we want our
	 * Node Name && Port Names to be distinct.
	 */

d1163 1
d1174 1
a1174 1
		fcp->isp_fwoptions &= ~(ICBOPT_USE_PORTNAME|ICBOPT_FULL_LOGIN);
d1220 1
a1220 3
isp_getmap(isp, map)
	struct ispsoftc *isp;
	fcpos_map_t *map;
d1248 1
a1248 2
isp_mark_getpdb_all(isp)
	struct ispsoftc *isp;
d1258 1
a1258 4
isp_getpdb(isp, id, pdbp)
	struct ispsoftc *isp;
	int id;
	isp_pdb_t *pdbp;
d1285 1
a1285 4
isp_get_portname(isp, loopid, nodename)
	struct ispsoftc *isp;
	int loopid;
	int nodename;
d1314 1
a1314 3
isp_fclink_test(isp, usdelay)
	struct ispsoftc *isp;
	int usdelay;
d1365 2
a1366 1
		isp_prt(isp, ISP_LOGDEBUG3, "usec%d: 0x%lx->0x%lx enano %lu",
d1368 1
a1368 2
		    (enano > ((u_int64_t)0xffffffff))? 0xffffffff :
		    (unsigned long) (enano & 0xffffffff));
d1387 2
a1388 1
			USEC_SLEEP(isp, wrk/1000);
d1537 1
a1537 2
isp2100_fw_statename(state)
	int state;
d1558 1
a1558 2
isp_pdb_sync(isp)
	struct ispsoftc *isp;
d1868 1
a1868 2
isp_scan_loop(isp)
	struct ispsoftc *isp;
d2137 1
a2137 2
isp_scan_fabric(isp)
	struct ispsoftc *isp;
d2247 1
a2247 2
isp_start(xs)
	XS_T *xs;
d2250 1
a2250 1
	u_int16_t iptr, optr;
d2305 33
d2454 1
d2586 1
a2586 1
	if (isp_save_xs(isp, xs, &reqp->req_handle)) {
d2591 1
d2598 1
a2598 1
		isp_destroy_handle(isp, reqp->req_handle);
d2625 1
a2625 4
isp_control(isp, ctl, arg)
	struct ispsoftc *isp;
	ispctl_t ctl;
	void *arg;
d2630 1
a2630 1
	u_int32_t handle;
d2703 2
a2704 2
		mbs.param[3] = handle >> 16;
		mbs.param[2] = handle & 0xffff;
d2767 5
a2774 1
		int ena = *(int *)arg;
d2781 1
d2783 2
a2784 1
			mbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;
d2811 1
a2811 2
isp_intr(arg)
	void *arg;
d2887 1
a2887 1
			u_int32_t fhandle = isp_parse_async(isp, (int) mbox);
d2890 1
a2890 1
				isp_fastpost_complete(isp, fhandle);
d3028 3
a3030 1
			    "bad request handle %d", sp->req_handle);
d3125 1
a3125 1
			    "unhandled respose queue type 0x%x",
d3194 1
a3194 3
isp_parse_async(isp, mbox)
	struct ispsoftc *isp;
	int mbox;
d3197 1
a3197 1
	u_int32_t fast_post_handle = 0;
d3216 2
a3217 1
		    "Internal FW Error @@ RISC Addr 0x%x", mbox);
d3244 1
a3244 1
		    "timeout initiated SCSI bus reset of bus %d\n", bus);
d3313 1
a3313 2
		fast_post_handle = (ISP_READ(isp, OUTMAILBOX2) << 16) |
		    ISP_READ(isp, OUTMAILBOX1);
d3463 2
a3464 4
isp_handle_other_response(isp, sp, optrp)
	struct ispsoftc *isp;
	ispstatusreq_t *sp;
	u_int16_t *optrp;
d3488 3
d3498 1
a3498 4
isp_parse_status(isp, sp, xs)
	struct ispsoftc *isp;
	ispstatusreq_t *sp;
	XS_T *xs;
d3830 1
a3830 3
isp_fastpost_complete(isp, fph)
	struct ispsoftc *isp;
	u_int32_t fph;
d3834 1
a3834 1
	if (fph < 1) {
d3873 1
a3873 1
	ISPOPMAP(0x01, 0x0f),	/* 0x08: MBOX_ABOUT_FIRMWARE */
d3950 2
a3951 2
	ISPOPMAP(0x03, 0x01),	/* 0x55: ENABLE TARGET MODE */
	ISPOPMAP(0x00, 0x00),	/* 0x56: */
d3961 1
a3961 1
#ifndef	ISP_STRIPEED
d4049 1
a4049 1
	NULL,
d4064 1
a4064 1
	ISPOPMAP(0x1f, 0x01),	/* 0x03: MBOX_DUMP_RAM */
d4323 1
a4323 4
isp_mboxcmd(isp, mbp, logmask)
	struct ispsoftc *isp;
	mbreg_t *mbp;
	int logmask;
d4401 2
a4402 1
		SNPRINTF(cname, sizeof tname, "opcode %x", opcode);
d4458 1
a4458 2
isp_fw_state(isp)
	struct ispsoftc *isp;
d4473 1
a4473 2
isp_update(isp)
	struct ispsoftc *isp;
d4486 1
a4486 3
isp_update_bus(isp, bus)
	struct ispsoftc *isp;
	int bus;
d4509 1
a4509 1
			isp_prt(isp, ISP_LOGDEBUG1,
d4568 1
a4568 1
			isp_prt(isp, ISP_LOGDEBUG2,
d4578 1
a4578 1
		mbs.param[1] = (bus << 15) | (tgt << 8) ;
d4604 1
a4604 3
isp_setdfltparm(isp, channel)
	struct ispsoftc *isp;
	int channel;
d4694 24
d4734 1
a4734 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
a4743 3
	} else {
		sdp->isp_req_ack_active_neg = 1;
		sdp->isp_data_line_active_neg = 1;
d4746 1
a4746 1
	isp_prt(isp, ISP_LOGDEBUG1,
d4749 1
a4749 1
	isp_prt(isp, ISP_LOGDEBUG1,
d4844 1
a4844 1
		isp_prt(isp, ISP_LOGDEBUG1,
a4849 24

	/*
	 * Establish default some more default parameters.
	 */
	sdp->isp_cmd_dma_burst_enable = 1;
	sdp->isp_data_dma_burst_enabl = 1;
	sdp->isp_fifo_threshold = 0;
	sdp->isp_initiator_id = DEFAULT_IID(isp);
	if (isp->isp_type >= ISP_HA_SCSI_1040) {
		sdp->isp_async_data_setup = 9;
	} else {
		sdp->isp_async_data_setup = 6;
	}
	sdp->isp_selection_timeout = 250;
	sdp->isp_max_queue_depth = MAXISPREQUEST(isp);
	sdp->isp_tag_aging = 8;
	sdp->isp_bus_reset_delay = 3;
	sdp->isp_retry_count = 2;
	sdp->isp_retry_delay = 2;

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		sdp->isp_devparam[tgt].exc_throttle = ISP_EXEC_THROTTLE;
		sdp->isp_devparam[tgt].dev_enable = 1;
	}
d4861 1
a4861 2
isp_reinit(isp)
	struct ispsoftc *isp;
d4864 1
a4864 1
	u_int32_t handle;
d4905 1
a4905 2
isp_read_nvram(isp)
	struct ispsoftc *isp;
d4978 1
a4978 4
isp_rdnvram_word(isp, wo, rp)
	struct ispsoftc *isp;
	int wo;
	u_int16_t *rp;
d5041 1
a5041 3
isp_parse_nvram_1020(isp, nvram_data)
	struct ispsoftc *isp;
	u_int8_t *nvram_data;
d5142 1
a5142 4
isp_parse_nvram_1080(isp, bus, nvram_data)
	struct ispsoftc *isp;
	int bus;
	u_int8_t *nvram_data;
d5215 1
a5215 4
isp_parse_nvram_12160(isp, bus, nvram_data)
	struct ispsoftc *isp;
	int bus;
	u_int8_t *nvram_data;
d5289 1
a5289 3
isp_parse_nvram_2100(isp, nvram_data)
	struct ispsoftc *isp;
	u_int8_t *nvram_data;
@


1.19
log
@Make some strings constant (from Bill Sommerfeld @@ NetBSD). Clean up some
wwn handling. Do a Register FC4 Type (so that we can work with McData
switches). Allow F-port topologies to use the target range 0..125 for
logging in fabric devices. We changed ISPASYNC_PDB_CHANGED to
ISPASYNC_LOGGED_INOUT and now use ISPASYNC_CHANGE_NOTIFY for both
loop && fabric events.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.18 2000/12/06 01:07:21 mjacob Exp $ */
a74 1
#ifdef	ISP2100_FABRIC
a88 1
#endif
d102 1
a102 1
    "(%d.%d.%d): FIN dl%d resid%d STS 0x%x SKEY %c XS_ERR=0x%x";
d116 1
d121 2
a122 3
static int isp_same_lportdb __P((struct lportdb *, struct lportdb *));
static int isp_pdb_sync __P((struct ispsoftc *, int));
#ifdef	ISP2100_FABRIC
a124 1
#endif
d203 2
a204 1
	 * Put the board into PAUSE mode (so we can read the SXP registers).
d219 8
d470 2
d509 3
d743 4
a746 6
	if ((isp->isp_confopts & ISP_CFG_NOINIT) == 0) {
		if (IS_FC(isp)) {
			isp_fibre_init(isp);
		} else {
			isp_scsi_init(isp);
		}
d763 7
d1031 14
d1084 13
d1173 1
d1175 1
a1175 1
	 * Do this *before* initializing the firmware.
a1176 4
	isp_mark_getpdb_all(isp);
	fcp->isp_fwstate = FW_CONFIG_WAIT;
	fcp->isp_loopstate = LOOP_NIL;

d1206 30
d1243 1
a1243 1
		fcp->portdb[i].valid = 0;
d1322 1
a1322 1
	int count;
d1325 1
a1325 1
#if	defined(ISP2100_FABRIC)
d1327 1
a1327 1
#endif
d1420 1
a1420 1
	fcp->isp_alpa = mbs.param[2];
d1422 6
a1427 1
#if	defined(ISP2100_FABRIC)
d1429 10
a1438 3
	if (fcp->isp_topo != TOPO_N_PORT &&
	    isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {
		struct lportdb *lp;
d1442 9
a1450 2
		fcp->isp_portid = mbs.param[2] | (((int)mbs.param[3]) << 16);
		fcp->isp_onfabric = 1;
d1455 1
a1455 1
		lp = &fcp->portdb[FL_PORT_ID];
d1479 2
d1482 2
a1483 4
	} else
#endif
	{
		fcp->isp_portid = mbs.param[2];
d1491 39
a1549 17
static int
isp_same_lportdb(a, b)
	struct lportdb *a, *b;
{
	/*
	 * We decide two lports are the same if they have non-zero and
	 * identical port WWNs and identical loop IDs.
	 */

	if (a->port_wwn == 0 || a->port_wwn != b->port_wwn ||
	    a->loopid != b->loopid || a->roles != b->roles) {
		return (0);
	} else {
		return (1);
	}
}

d1556 1
a1556 1
isp_pdb_sync(isp, target)
a1557 1
	int target;
d1559 1
a1559 1
	struct lportdb *lp, *tport;
d1562 1
a1562 1
	int loopid, frange, prange, lim;
a1563 1
#ifdef	ISP2100_FABRIC
d1565 1
a1565 2
	 * XXX: If we do this *after* building up our local port database,
	 * XXX: the commands simply don't work.
d1567 16
d1584 2
a1585 1
	 * (Re)discover all fabric devices
a1586 3
	if (fcp->isp_onfabric)
		(void) isp_scan_fabric(isp);
#endif
d1588 4
a1591 13

	switch (fcp->isp_topo) {
	case TOPO_F_PORT:
	case TOPO_PTP_STUB:
		frange = prange = 0;
		break;
	case TOPO_N_PORT:
		prange = 2;
		break;
	default:
		frange = FC_SNS_ID+1;
		prange = FL_PORT_ID;
		break;
d1595 2
a1596 6
	 * Run through the local loop ports and get port database info
	 * for each loop ID.
	 *
	 * There's a somewhat unexplained situation where the f/w passes back
	 * the wrong database entity- if that happens, just restart (up to
	 * FL_PORT_ID times).
d1598 20
a1617 1
	tport = fcp->tport;
d1620 3
a1622 1
	 * make sure the temp port database is clean...
d1624 3
a1626 1
	MEMZERO((void *) tport, sizeof (tport));
d1628 2
a1629 6
	for (lim = loopid = 0; loopid < prange; loopid++) {
		lp = &tport[loopid];
		lp->node_wwn = isp_get_portname(isp, loopid, 1);
		if (fcp->isp_loopstate < LOOP_PDB_RCVD)
			return (-1);
		if (lp->node_wwn == 0)
d1631 5
a1635 3
		lp->port_wwn = isp_get_portname(isp, loopid, 0);
		if (fcp->isp_loopstate < LOOP_PDB_RCVD)
			return (-1);
a1636 1
			lp->node_wwn = 0;
d1641 1
a1641 1
		 * Get an entry....
d1643 1
a1643 3
		if (isp_getpdb(isp, loopid, &pdb) != 0) {
			if (fcp->isp_loopstate < LOOP_PDB_RCVD)
				return (-1);
a1646 2
		if (fcp->isp_loopstate < LOOP_PDB_RCVD)
			return (-1);
d1649 7
a1655 2
		 * If the returned database element doesn't match what we
		 * asked for, restart the process entirely (up to a point...).
d1657 32
a1688 3
		if (pdb.pdb_loopid != loopid) {
			loopid = 0;
			if (lim++ < FL_PORT_ID) {
a1690 3
			isp_prt(isp, ISP_LOGWARN,
			    "giving up on synchronizing the port database");
			return (-1);
d1693 3
a1695 36
		/*
		 * Save the pertinent info locally.
		 */
		lp->node_wwn =
		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_nodename[7]));
		lp->port_wwn =
		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_portname[7]));
		lp->roles =
		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
		lp->portid = BITS2WORD(pdb.pdb_portid_bits);
		lp->loopid = pdb.pdb_loopid;
		/*
		 * Do a quick check to see whether this matches the saved port
		 * database for the same loopid. We do this here to save
		 * searching later (if possible). Note that this fails over
		 * time as things shuffle on the loop- we get the current
		 * loop state (where loop id as an index matches loop id in
		 * use) and then compare it to our saved database which
		 * never shifts.
		 */
		if (target >= 0 && isp_same_lportdb(lp, &fcp->portdb[target])) {
			lp->valid = 1;
a1696 21
	}

	/*
	 * If we get this far, we've settled our differences with the f/w
	 * and we can say that the loop state is ready.
	 */
	fcp->isp_loopstate = LOOP_READY;

	/*
	 * Mark all of the permanent local loop database entries as invalid.
	 */
	for (loopid = 0; loopid < FL_PORT_ID; loopid++) {
		fcp->portdb[loopid].valid = 0;
	}

	/*
	 * Now merge our local copy of the port database into our saved copy.
	 * Notify the outer layers of new devices arriving.
	 */
	for (loopid = 0; loopid < prange; loopid++) {
		int i;
d1699 1
a1699 1
		 * If we don't have a non-zero Port WWN, we're not here.
d1701 17
a1717 2
		if (tport[loopid].port_wwn == 0) {
			continue;
d1721 1
a1721 4
		 * If we've already marked our tmp copy as valid,
		 * this means that we've decided that it's the
		 * same as our saved data base. This didn't include
		 * the 'valid' marking so we have set that here.
d1723 16
a1738 32
		if (tport[loopid].valid) {
			fcp->portdb[loopid].valid = 1;
			continue;
		}

		/*
		 * For the purposes of deciding whether this is the
		 * 'same' device or not, we only search for an identical
		 * Port WWN. Node WWNs may or may not be the same as
		 * the Port WWN, and there may be multiple different
		 * Port WWNs with the same Node WWN. It would be chaos
		 * to have multiple identical Port WWNs, so we don't
		 * allow that.
		 */

		for (i = 0; i < FL_PORT_ID; i++) {
			int j;
			if (fcp->portdb[i].port_wwn == 0)
				continue;
			if (fcp->portdb[i].port_wwn != tport[loopid].port_wwn)
				continue;
			/*
			 * We found this WWN elsewhere- it's changed
			 * loopids then. We don't change it's actual
			 * position in our cached port database- we
			 * just change the actual loop ID we'd use.
			 */
			if (fcp->portdb[i].loopid != loopid) {
				isp_prt(isp, ISP_LOGINFO, portshift, i,
				    fcp->portdb[i].loopid,
				    fcp->portdb[i].portid, loopid,
				    tport[loopid].portid);
d1740 8
a1747 15
			fcp->portdb[i].portid = tport[loopid].portid;
			fcp->portdb[i].loopid = loopid;
			fcp->portdb[i].valid = 1;
			fcp->portdb[i].roles = tport[loopid].roles;

			/*
			 * Now make sure this Port WWN doesn't exist elsewhere
			 * in the port database.
			 */
			for (j = i+1; j < FL_PORT_ID; j++) {
				if (fcp->portdb[i].port_wwn !=
				    fcp->portdb[j].port_wwn) {
					continue;
				}
				isp_prt(isp, ISP_LOGWARN, portdup, j, i);
d1749 3
a1751 4
				 * Invalidate the 'old' *and* 'new' ones.
				 * This is really harsh and not quite right,
				 * but if this happens, we really don't know
				 * who is what at this point.
d1753 22
a1774 2
				fcp->portdb[i].valid = 0;
				fcp->portdb[j].valid = 0;
d1776 1
a1776 2
			break;
		}
d1779 2
a1780 3
		 * If we didn't traverse the entire port database,
		 * then we found (and remapped) an existing entry.
		 * No need to notify anyone- go for the next one.
d1782 3
a1784 1
		if (i < FL_PORT_ID) {
d1789 1
a1789 2
		 * We've not found this Port WWN anywhere. It's a new entry.
		 * See if we can leave it where it is (with target == loopid).
d1791 14
a1804 13
		if (fcp->portdb[loopid].port_wwn != 0) {
			for (lim = 0; lim < FL_PORT_ID; lim++) {
				if (fcp->portdb[lim].port_wwn == 0)
					break;
			}
			/* "Cannot Happen" */
			if (lim == FL_PORT_ID) {
				isp_prt(isp, ISP_LOGWARN, "Remap Overflow");
				continue;
			}
			i = lim;
		} else {
			i = loopid;
d1807 5
a1811 10
		/*
		 * NB:	The actual loopid we use here is loopid- we may
		 *	in fact be at a completely different index (target).
		 */
		fcp->portdb[i].loopid = loopid;
		fcp->portdb[i].port_wwn = tport[loopid].port_wwn;
		fcp->portdb[i].node_wwn = tport[loopid].node_wwn;
		fcp->portdb[i].roles = tport[loopid].roles;
		fcp->portdb[i].portid = tport[loopid].portid;
		fcp->portdb[i].valid = 1;
d1813 20
d1834 1
a1834 1
		 * Tell the outside world we've arrived.
d1836 19
a1854 1
		(void) isp_async(isp, ISPASYNC_LOGGED_INOUT, &i);
a1855 1

d1857 3
a1859 2
	 * Now find all previously used targets that are now invalid and
	 * notify the outer layers that they're gone.
d1861 13
a1873 3
	for (lp = fcp->portdb; lp < &fcp->portdb[prange]; lp++) {
		if (lp->valid || lp->port_wwn == 0)
			continue;
d1875 13
a1887 6
		/*
		 * Tell the outside world we've gone away.
		 */
		loopid = lp - fcp->portdb;
		(void) isp_async(isp, ISPASYNC_LOGGED_INOUT, &loopid);
		MEMZERO((void *) lp, sizeof (*lp));
d1889 1
a1890 1
#ifdef	ISP2100_FABRIC
d1892 1
a1892 1
	 * Now log in any fabric devices
d1894 18
a1911 4
	for (lp = &fcp->portdb[frange];
	     lp < &fcp->portdb[MAX_FC_TARG]; lp++) {
		u_int32_t portid;
		mbreg_t mbs;
d1913 10
a1922 2
		loopid = lp - fcp->portdb;
		if (loopid >= FL_PORT_ID && loopid <= FC_SNS_ID) {
d1927 1
a1927 1
		 * Anything here?
d1929 3
a1931 1
		if (lp->port_wwn == 0) {
d1934 3
d1939 15
a1953 1
		 * Don't try to log into yourself.
d1955 32
a1986 1
		if ((portid = lp->portid) == fcp->isp_portid) {
d1989 2
d1992 6
d2000 1
a2000 7
		 * If we'd been logged in- see if we still are and we haven't
		 * changed. If so, no need to log ourselves out, etc..
		 *
		 * Unfortunately, our charming Qlogic f/w has decided to
		 * return a valid port database entry for a fabric device
		 * that has, in fact, gone away. And it hangs trying to
		 * log it out.
d2002 2
a2003 34
		if (lp->loggedin &&
		    isp_getpdb(isp, lp->loopid, &pdb) == 0) {
			int nrole;
			u_int64_t nwwnn, nwwpn;
			nwwnn = 
			    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
			    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
			    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
			    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
			    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
			    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
			    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
			    (((u_int64_t)pdb.pdb_nodename[7]));
			nwwpn = 
			    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
			    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
			    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
			    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
			    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
			    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
			    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
			    (((u_int64_t)pdb.pdb_portname[7]));
			nrole = (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >>
			    SVC3_ROLE_SHIFT;
			if (pdb.pdb_loopid == lp->loopid && lp->portid ==
			    (u_int32_t) BITS2WORD(pdb.pdb_portid_bits) &&
			    nwwnn == lp->node_wwn && nwwpn == lp->port_wwn &&
			    lp->roles == nrole) {
				lp->loggedin = lp->valid = 1;
				isp_prt(isp, ISP_LOGINFO, lretained,
				    (int) (lp - fcp->portdb),
				    (int) lp->loopid, lp->portid);
				continue;
			}
d2007 1
a2007 1
		 * Force a logout if we were logged in.
d2009 2
a2010 9
		if (lp->loggedin) {
			mbs.param[0] = MBOX_FABRIC_LOGOUT;
			mbs.param[1] = lp->loopid << 8;
			mbs.param[2] = 0;
			mbs.param[3] = 0;
			isp_mboxcmd(isp, &mbs, MBLOGNONE);
			lp->loggedin = 0;
			isp_prt(isp, ISP_LOGINFO, plogout,
			    (int) (lp - fcp->portdb), lp->loopid, lp->portid);
d2014 7
a2020 1
		 * And log in....
d2022 19
a2040 10
		loopid = lp - fcp->portdb;
		lp->loopid = 0;
		do {
			mbs.param[0] = MBOX_FABRIC_LOGIN;
			mbs.param[1] = loopid << 8;
			mbs.param[2] = portid >> 16;
			mbs.param[3] = portid & 0xffff;
			if (IS_2200(isp)) {
				/* only issue a PLOGI if not logged in */
				mbs.param[1] |= 0x1;
d2042 15
a2056 4
			isp_mboxcmd(isp, &mbs, MBLOGALL & ~(MBOX_LOOP_ID_USED |
			    MBOX_PORT_ID_USED | MBOX_COMMAND_ERROR));
			switch (mbs.param[0]) {
			case MBOX_LOOP_ID_USED:
d2058 4
a2061 1
				 * Try the next available loop id.
d2063 2
a2064 30
				loopid++;
				break;
			case MBOX_PORT_ID_USED:
				/*
				 * This port is already logged in.
				 * Snaffle the loop id it's using if it's
				 * nonzero, otherwise we're hosed.
				 */
				if (mbs.param[1] != 0) {
					loopid = mbs.param[1];
					isp_prt(isp, ISP_LOGINFO, retained,
					    loopid, (int) (lp - fcp->portdb),
					    lp->portid);
				} else {
					loopid = MAX_FC_TARG;
					break;
				}
				/* FALLTHROUGH */
			case MBOX_COMMAND_COMPLETE:
				lp->loggedin = 1;
				lp->loopid = loopid;
				break;
			case MBOX_COMMAND_ERROR:
				isp_prt(isp, ISP_LOGINFO, plogierr,
				    portid, mbs.param[1]);
				/* FALLTHROUGH */
			case MBOX_ALL_IDS_USED: /* We're outta IDs */
			default:
				loopid = MAX_FC_TARG;
				break;
d2066 2
a2067 1
		} while (lp->loopid == 0 && loopid < MAX_FC_TARG);
d2070 3
a2072 2
		 * If we get here and we haven't set a Loop ID,
		 * we failed to log into this device.
d2074 1
a2074 2

		if (lp->loopid == 0) {
d2079 2
a2080 1
		 * Make sure we can get the approriate port information.
d2082 13
a2094 3
		if (isp_getpdb(isp, lp->loopid, &pdb) != 0) {
			isp_prt(isp, ISP_LOGWARN, nopdb, lp->portid);
			goto dump_em;
d2097 16
a2112 5
		if (pdb.pdb_loopid != lp->loopid) {
			isp_prt(isp, ISP_LOGWARN, pdbmfail1,
			    lp->portid, pdb.pdb_loopid);
			goto dump_em;
		}
d2114 7
a2120 4
		if (lp->portid != (u_int32_t) BITS2WORD(pdb.pdb_portid_bits)) {
			isp_prt(isp, ISP_LOGWARN, pdbmfail2,
			    lp->portid, BITS2WORD(pdb.pdb_portid_bits));
			goto dump_em;
a2122 20
		lp->roles =
		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
		lp->node_wwn =
		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_nodename[7]));
		lp->port_wwn =
		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_portname[7]));
d2124 3
a2126 1
		 * Check to make sure this all makes sense.
d2128 3
a2130 15
		if (lp->node_wwn && lp->port_wwn) {
			lp->valid = 1;
			loopid = lp - fcp->portdb;
			(void) isp_async(isp, ISPASYNC_LOGGED_INOUT, &loopid);
			continue;
		}
dump_em:
		lp->valid = 0;
		isp_prt(isp, ISP_LOGINFO,
		    ldumped, loopid, lp->loopid, lp->portid);
		mbs.param[0] = MBOX_FABRIC_LOGOUT;
		mbs.param[1] = lp->loopid << 8;
		mbs.param[2] = 0;
		mbs.param[3] = 0;
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
d2132 1
a2132 7
#endif
	/*
	 * If we get here, we've for sure seen not only a valid loop
	 * but know what is or isn't on it, so mark this for usage
	 * in isp_start.
	 */
	fcp->loop_seen_once = 1;
a2135 1
#ifdef	ISP2100_FABRIC
d2141 1
a2141 1
	u_int32_t portid, first_nz_portid;
d2145 6
a2150 1
	int hicap;
d2154 6
a2159 1
	first_nz_portid = portid = fcp->isp_portid;
d2161 1
a2161 1
	for (hicap = 0; hicap < 1024; hicap++) {
d2181 7
d2194 3
a2196 7
		if (isp_async(isp, ISPASYNC_FABRIC_DEV, resp)) {
			return (-1);
		}
		if (first_nz_portid == 0 && portid) {
			first_nz_portid = portid;
		}
		if (first_nz_portid == portid) {
d2200 3
d2206 1
d2239 1
a2239 1
		isp_prt(isp, ISP_LOGINFO, "Register FC4 types succeeded");
d2242 1
a2242 1
#endif
d2265 13
d2307 26
a2332 1
#if	defined(ISP2100_FABRIC)
a2358 26
#endif
		/*
		 * Check for f/w being in ready state. If the f/w
		 * isn't in ready state, then we don't know our
		 * loop ID and the f/w hasn't completed logging
		 * into all targets on the loop. If this is the
		 * case, then bounce the command. We pretend this is
		 * a SELECTION TIMEOUT error if we've never gone to
		 * FW_READY state at all- in this case we may not
		 * be hooked to a loop at all and we shouldn't hang
		 * the machine for this. Otherwise, defer this command
		 * until later.
		 */
		if (fcp->isp_fwstate != FW_READY) {
			/*
			 * Give ourselves at most a 250ms delay.
			 */
			if (isp_fclink_test(isp, 250000)) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				if (fcp->loop_seen_once) {
					return (CMD_RQLATER);
				} else {
					return (CMD_COMPLETE);
				}
			}
		}
d2378 26
d2409 7
a2415 4
		if (fcp->isp_loopstate == LOOP_PDB_RCVD) {
			if (isp_pdb_sync(isp, target)) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
d2439 1
a2439 1
		 * Now turn target into what the actual loop ID is.
d2574 3
a2576 2
	    "START cmd for %d.%d.%d cmd 0x%x datalen %d",
	    XS_CHANNEL(xs), target, XS_LUN(xs), XS_CDBP(xs)[0], XS_XFRLEN(xs));
d2686 1
d2691 1
d2698 14
d2713 8
d2722 12
a2733 1
			return (isp_pdb_sync(isp, -1));
d2736 1
d2741 5
a2752 27
		} else {
			fcparam *fcp = isp->isp_param;
			/*
			 * We assume somebody has quiesced this bus.
			 */
			if (ena) {
				if (fcp->isp_fwoptions & ICBOPT_TGT_ENABLE) {
					return (0);
				}
				fcp->isp_fwoptions |= ICBOPT_TGT_ENABLE;
			} else {
				if (!(fcp->isp_fwoptions & ICBOPT_TGT_ENABLE)) {
					return (0);
				}
				fcp->isp_fwoptions &= ~ICBOPT_TGT_ENABLE;
			}
			isp->isp_state = ISP_NILSTATE;
			isp_reset(isp);
			if (isp->isp_state != ISP_RESETSTATE) {
				break;
			}
			isp_init(isp);
			if ((isp->isp_confopts & ISP_CFG_NOINIT) == 0) {
				if (isp->isp_state == ISP_INITSTATE) {
					isp->isp_state = ISP_RUNSTATE;
				}
			}
d3066 2
d3070 3
a3072 2
			isp_prt(isp, ISP_LOGDEBUG2, "asked for %d got resid %d",
				XS_XFRLEN(xs), sp->req_resid);
d3104 2
a3105 1
		    ((isp->isp_dblev & ISP_LOGDEBUG1) && !XS_NOERR(xs))) {
d3112 1
a3112 1
					skey += 'a';
d3184 1
a3184 1
		isp_target_async(isp, bus, mbox);
d3347 1
a3347 1
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, (void *) 0);
d3356 1
a3356 1
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, (void *) 1);
d3361 2
a3363 2
		else
			FCPARAM(isp)->isp_topo = TOPO_F_PORT;
d3368 1
d3377 1
d3380 2
a3381 1
			isp_prt(isp, ISP_LOGINFO, "Point-to-Point->Loop mode");
d3384 2
a3385 1
			isp_prt(isp, ISP_LOGINFO, "Loop->Point-to-Point mode");
d3389 1
a3389 1
			    "Point-to-Point->Loop mode (1)");
a3398 1

d3402 5
d3408 4
d4336 2
d4438 1
a4438 1
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE)
d4440 1
d4848 10
a4857 5
	if (isp->isp_state == ISP_RESETSTATE) {
		isp_init(isp);
		if (isp->isp_state == ISP_INITSTATE) {
			isp->isp_state = ISP_RUNSTATE;
		}
d4860 1
a4860 1
		isp_prt(isp, ISP_LOGERR, "isp_reinit cannot restart ISP");
d4862 1
@


1.18
log
@Update isp codebase to current common head- USEC_SLEEP macro added,
instrumentation for interrupts, specific topology preferences for
the 2200. Fix the hole in the OpenBSD port becuause there'd been
no maxluns limit from the midlayer and have the command routine
bounce commands > the maxluns for a particular controller (in
particular, Qlogic FC cards where we can't tell when it hasn't been
us that have loaded the F/W whether or not SCCLUN is in effect
or not).
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.17 2000/10/16 01:01:58 mjacob Exp $ */
d67 1
a67 1
static char *warnlun =
d69 1
a69 1
static char *portshift =
d71 1
a71 1
static char *portdup =
d73 1
a73 1
static char *retained = 
d76 1
a76 1
static char *lretained =
d78 1
a78 1
static char *plogout =
d80 1
a80 1
static char *plogierr =
d82 1
a82 1
static char *nopdb =
d84 1
a84 1
static char *pdbmfail1 =
d86 1
a86 1
static char *pdbmfail2 =
d88 1
a88 1
static char *ldumped =
d91 1
a91 1
static char *notresp =
d93 1
a93 1
static char *xact1 =
d95 1
a95 1
static char *xact2 =
d97 1
a97 1
static char *xact3 =
d99 1
a99 1
static char *pskip =
d101 1
a101 1
static char *topology =
d103 1
a103 1
static char *finmsg =
d126 1
d154 1
a154 1
	char *revname;
d190 1
a190 1
			isp_mboxcmd(isp, &mbs, MBLOGNONE);
a210 1
		revname = "2X00";
d213 1
a213 1
			revname[1] = '1';
d216 1
a216 1
			revname[1] = '2';
d232 1
a232 1
		static char *m = "bus %d is in %s Mode";
d732 6
a737 4
	if (IS_FC(isp)) {
		isp_fibre_init(isp);
	} else {
		isp_scsi_init(isp);
d1293 5
d1302 1
a1302 6
		 */
		isp_prt(isp, ISP_LOGDEBUG3, "usec%d: 0x%lx->0x%lx enano %u",
		    count, (long) GET_NANOSEC(&hra), (long) GET_NANOSEC(&hrb),
		    enano);

		/*
d1390 1
a1390 5
#if	0
		if (isp->isp_rfabric == 0) {
			isp_i_register_fc4_type(isp);
		}
#endif
a1395 3
#if	0
		isp->isp_rfabric = 0;
#endif
d1452 1
a1452 1
	int loopid, prange, lim;
d1470 1
a1470 1
		prange = 0;
d1476 1
d1711 1
a1711 1
		(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &i);
d1726 1
a1726 1
		(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);
d1734 1
a1734 1
	for (lp = &fcp->portdb[FC_SNS_ID+1];
d1739 5
d1747 1
a1747 1
		if (lp->port_wwn == 0)
d1749 1
d1754 1
a1754 1
		if ((portid = lp->portid) == fcp->isp_portid)
d1756 1
d1762 5
d1927 1
a1927 1
			(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);
d2007 33
d2095 7
a2101 3
		 * above FL_PORT_ID-1. If we're on a fabric and
		 * connected as an F-port, we can't have a target
		 * less than FC_SNS_ID+1.
d2113 1
a2113 1
			if (fcp->isp_topo == TOPO_F_PORT &&
d2490 4
a2493 2
			if (isp->isp_state != ISP_INITSTATE) {
				break;
a2494 1
			isp->isp_state = ISP_RUNSTATE;
d2580 1
a2580 1
				for (i = 1; i < 8; i++) {
d3085 1
a3085 1
		isp_prt(isp, ISP_LOGINFO, "Port Database Changed");
a3088 1
		isp_mark_getpdb_all(isp);
d3093 2
a3094 1
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, NULL);
d4312 2
d4345 15
a4359 1
		 * Now try and read NVRAM
d4361 17
a4377 8
		if ((isp->isp_confopts & (ISP_CFG_NONVRAM|ISP_CFG_OWNWWN)) ||
		    (isp_read_nvram(isp))) {
			isp_prt(isp, ISP_LOGINFO,
			    "Node WWN 0x%08x%08x, Port WWN 0x%08x%08x",
			    (u_int32_t) (fcp->isp_nodewwn >> 32),
			    (u_int32_t) (fcp->isp_nodewwn & 0xffffffff),
			    (u_int32_t) (fcp->isp_portwwn >> 32),
			    (u_int32_t) (fcp->isp_portwwn & 0xffffffff));
@


1.17
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.16 2000/07/06 05:31:48 mjacob Exp $ */
d92 1
a92 1
  "Not RESPONSE in RESPONSE Queue (type 0x%x) @@ idx %d (next %d)";
d379 5
d617 1
a617 1
	USEC_DELAY(500);
d1086 2
a1087 1
		if (isp->isp_confopts & ISP_CFG_NPORT)
d1089 8
a1096 1
		else
d1098 2
d1309 1
a1309 1
				USEC_DELAY(4000000);
d1313 1
a1313 1
			USEC_DELAY(wrk/1000);
d2505 1
d2507 1
d2642 6
a2647 1
				    sp->req_header.rqs_entry_type, oop, optr);
d2875 3
d3082 3
d3158 1
a3158 1
			    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
a4024 6

	/*
	 * Give the f/w a chance to pick this up.
	 */
	USEC_DELAY(250);

@


1.16
log
@Resync with FreeBSD/NetBSD. Salient features are that the mailbox command
routines are not necessarily polled now- this should cut down on some of
the spurious lost commands that have occurred. Also, we now watchdog each
command and make sure that command constipation doesn't occur (which it
has been documented to do on the QLA2100 cards).
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.15 2000/04/06 05:50:43 mjacob Exp $ */
d6 2
a7 2
 * Copyright (c) 1997, 1998, 1999 by Matthew Jacob
 * NASA/Ames Research Center
d16 1
a16 4
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
d54 3
d67 38
a104 1

d112 1
a112 1
__P((struct ispsoftc *, ispstatusreq_t *, ISP_SCSI_XFER_T *));
d121 1
d128 1
a128 2
static void isp_dumpregs __P((struct ispsoftc *, const char *));
static void isp_mboxcmd __P((struct ispsoftc *, mbreg_t *));
a139 1

d157 1
d162 1
a162 4
	 */
	isp->isp_dblev = DFLT_DBLEVEL;

	/*
d164 1
a164 1
	 * for SCSI adapters and other settings for the 2100.
d177 21
a197 13
		 * Just in case it was paused...
		 */
		ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
		mbs.param[0] = MBOX_ABOUT_FIRMWARE;
		isp_mboxcmd(isp, &mbs);
		/*
		 * If this fails, it probably means we're running
		 * an old prom, if anything at all...
		 */
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			isp->isp_romfw_rev[0] = mbs.param[1];
			isp->isp_romfw_rev[1] = mbs.param[2];
			isp->isp_romfw_rev[2] = mbs.param[3];
d232 1
a232 1
		static char *m = "%s: bus %d is in %s Mode\n";
d251 1
a251 1
			CFGPRINTF(m, isp->isp_name, 0, "LVD");
d255 1
a255 1
			CFGPRINTF(m, isp->isp_name, 0, "Differential");
d259 1
a259 1
			CFGPRINTF(m, isp->isp_name, 0, "Single-Ended");
d262 2
a263 2
			CFGPRINTF("%s: unknown mode on bus %d (0x%x)\n",
			    isp->isp_name, 0, l);
d274 1
a274 1
				CFGPRINTF(m, isp->isp_name, 1, "LVD");
d278 2
a279 1
				CFGPRINTF(m, isp->isp_name, 1, "Differential");
d283 2
a284 1
				CFGPRINTF(m, isp->isp_name, 1, "Single-Ended");
d287 2
a288 2
				CFGPRINTF("%s: unknown mode on bus %d (0x%x)\n",
				    isp->isp_name, 1, l);
d297 1
a297 2
			PRINTF("%s: unknown chip rev. 0x%x- assuming a 1020\n",
			    isp->isp_name, i);
d340 1
a340 1
			CFGPRINTF("%s: Differential Mode\n", isp->isp_name);
d352 1
a352 1
			CFGPRINTF("%s: Ultra Mode Capable\n", isp->isp_name);
d395 1
a395 9
		SYS_DELAY(100);

#if	0
		PRINTF("%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
		    isp->isp_name, ISP_READ(isp, OUTMAILBOX0),
		    ISP_READ(isp, OUTMAILBOX1), ISP_READ(isp, OUTMAILBOX2),
		    ISP_READ(isp, OUTMAILBOX3), ISP_READ(isp, OUTMAILBOX4),
		    ISP_READ(isp, OUTMAILBOX5));
#endif
d411 1
a411 1
		SYS_DELAY(100);
d436 1
a436 1
		SYS_DELAY(100);
d438 1
a438 1
			isp_dumpregs(isp, "chip reset timed out");
d458 1
a458 1
	SYS_DELAY(100);
d510 1
a510 1
		SYS_DELAY(100);
d512 2
a513 2
			PRINTF("%s: MBOX_BUSY never cleared on reset\n",
			    isp->isp_name);
d528 1
a528 1
	isp_mboxcmd(isp, &mbs);
a529 1
		isp_dumpregs(isp, "NOP test failed");
d540 1
a540 1
		isp_mboxcmd(isp, &mbs);
a541 2
			isp_dumpregs(isp,
				"Mailbox Register test didn't complete");
d547 4
a550 1
			isp_dumpregs(isp, "Register Test Failed");
d571 1
a571 3
		u_int16_t fwlen  = isp->isp_mdvec->dv_fwlen;
		if (fwlen == 0)
			fwlen = isp->isp_mdvec->dv_ispfw[3]; /* usually here */
d574 1
a574 1
			mbs.param[1] = isp->isp_mdvec->dv_codeorg + i;
d576 1
a576 1
			isp_mboxcmd(isp, &mbs);
d578 2
a579 2
				PRINTF("%s: F/W download failed at word %d\n",
				    isp->isp_name, i);
d589 2
a590 2
		mbs.param[1] = isp->isp_mdvec->dv_codeorg;
		isp_mboxcmd(isp, &mbs);
d592 1
a592 1
			isp_dumpregs(isp, "ram checksum failure");
d595 1
d597 2
a598 1
		IDPRINTF(3, ("%s: skipping f/w download\n", isp->isp_name));
d609 2
a610 5
	if (isp->isp_mdvec->dv_codeorg)
		mbs.param[1] = isp->isp_mdvec->dv_codeorg;
	else
		mbs.param[1] = 0x1000;
	isp_mboxcmd(isp, &mbs);
d612 1
a612 1
	SYS_DELAY(500);
d621 2
a622 6
			isp_mboxcmd(isp, &mbs);
			if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
				PRINTF("failed to set clockrate (0x%x)\n",
				    mbs.param[0]);
				/* but continue */
			}
d625 1
d627 1
a627 1
	isp_mboxcmd(isp, &mbs);
a628 1
		PRINTF("could not get f/w started (0x%x)\n", mbs.param[0]);
d631 4
a634 3
	CFGPRINTF("%s: Board Revision %s, %s F/W Revision %d.%d.%d\n",
	    isp->isp_name, revname, dodnld? "loaded" : "resident",
	    mbs.param[1], mbs.param[2], mbs.param[3]);
d637 2
a638 1
			CFGPRINTF("%s: in 64-Bit PCI slot\n", isp->isp_name);
d647 1
a647 1
		CFGPRINTF("%s: Last F/W revision was %d.%d.%d\n", isp->isp_name,
d653 1
a653 1
	isp_mboxcmd(isp, &mbs);
a654 1
		PRINTF("%s: could not GET FIRMWARE STATUS\n", isp->isp_name);
d658 2
a659 2
	CFGPRINTF("%s: %d max I/O commands supported\n",
	    isp->isp_name, mbs.param[2]);
d666 1
a666 1
		PRINTF("%s: can't setup dma mailboxes\n", isp->isp_name);
d703 1
a703 3
				PRINTF("%s: WARNING- cannot determine Expanded "
				    "LUN capability- limiting to one LUN\n",
				    isp->isp_name);
a726 1

d752 1
a752 1
	if (isp->isp_fast_mttr) {
d766 1
a766 1
	isp_mboxcmd(isp, &mbs);
a767 2
		PRINTF("%s: failed to set retry count and retry delay\n",
		    isp->isp_name);
d777 1
a777 1
	isp_mboxcmd(isp, &mbs);
a778 2
		PRINTF("%s: failed to set asynchronous data setup time\n",
		    isp->isp_name);
d793 1
a793 1
	isp_mboxcmd(isp, &mbs);
d795 2
a796 2
		PRINTF("%s: failed to set active negation state "
		    "(%d,%d),(%d,%d)\n", isp->isp_name,
d812 1
a812 1
	isp_mboxcmd(isp, &mbs);
d814 2
a815 3
		PRINTF("%s: failed to set tag age limit (%d,%d)\n",
		    isp->isp_name, sdp_chan0->isp_tag_aging,
		    sdp_chan1->isp_tag_aging);
d825 1
a825 1
	isp_mboxcmd(isp, &mbs);
a826 1
		PRINTF("%s: failed to set selection timeout\n", isp->isp_name);
d840 1
a840 1
	mbs.param[1] = RESULT_QUEUE_LEN;
d845 1
a845 1
	isp_mboxcmd(isp, &mbs);
a846 1
		PRINTF("%s: set of response queue failed\n", isp->isp_name);
d849 1
a849 1
	isp->isp_residx = 0;
d852 1
a852 1
	mbs.param[1] = RQUEST_QUEUE_LEN;
d856 1
a856 2
	mbs.param[5] = 0;
	isp_mboxcmd(isp, &mbs);
a857 1
		PRINTF("%s: set of request queue failed\n", isp->isp_name);
d860 1
a860 1
	isp->isp_reqidx = isp->isp_reqodx = 0;
d879 4
a882 7
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			PRINTF("%s: cannot enable FW features (0x%x)\n",
			    isp->isp_name, sfeat);
		} else {
			CFGPRINTF("%s: enabled FW features (0x%x)\n",
			    isp->isp_name, sfeat);
d909 1
a909 1
	isp_mboxcmd(isp, &mbs);
a910 2
		PRINTF("%s: cannot set initiator id on bus %d to %d\n",
		    isp->isp_name, channel, sdp->isp_initiator_id);
d913 2
a923 2
			IDPRINTF(2, ("%s: skipping target %d bus %d settings\n",
			    isp->isp_name, tgt, channel));
d926 1
a926 1

d928 4
a931 2
		 * If we're in LVD mode, then we pretty much should
		 * only disable tagged queuing.
d933 2
a934 16
		if (IS_ULTRA2(isp) && sdp->isp_lvdmode) {
			sdf = DPARM_DEFAULT & ~DPARM_TQING;
		} else {
			int rvf = ISP_FW_REVX(isp->isp_fwrev);
			sdf = DPARM_SAFE_DFLT;
			
			/*
			 * It is not quite clear when this changed over so that
			 * we could force narrow and async, so assume >= 7.55
			 * for i/t F/W and = 4.55 for initiator f/w.
			 */
			if ((ISP_FW_REV(4, 55, 0) <= rvf &&
			    (ISP_FW_REV(5, 0, 0) > rvf)) ||
			    (ISP_FW_REV(7, 55, 0) <= rvf)) {
				sdf |= DPARM_NARROW | DPARM_ASYNC;
			}
d939 8
a946 4
		mbs.param[3] =
		    (sdp->isp_devparam[tgt].sync_offset << 8) |
		    (sdp->isp_devparam[tgt].sync_period);
		isp_mboxcmd(isp, &mbs);
d952 2
a953 4
			mbs.param[3] =
			    (sdp->isp_devparam[tgt].sync_offset << 8) |
			    (sdp->isp_devparam[tgt].sync_period);
			isp_mboxcmd(isp, &mbs);
a954 2
				PRINTF("%s: failed even to set defaults for "
				    "target %d\n", isp->isp_name, tgt);
a958 31
#if	0
		/*
		 * We don't update dev_flags with what we've set
		 * because that's not the ultimate goal setting.
		 * If we succeed with the command, we *do* update
		 * cur_dflags by getting target parameters.
		 */
		mbs.param[0] = MBOX_GET_TARGET_PARAMS;
		mbs.param[1] = (tgt << 8) | (channel << 15);
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			/*
			 * Urrr.... We'll set cur_dflags to DPARM_SAFE_DFLT so
			 * we don't try and do tags if tags aren't enabled.
			 */
			sdp->isp_devparam[tgt].cur_dflags = DPARM_SAFE_DFLT;
		} else {
			sdp->isp_devparam[tgt].cur_dflags = mbs.param[2];
			sdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;
			sdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;
		}
		IDPRINTF(3, ("%s: set flags 0x%x got 0x%x back for target %d\n",
		    isp->isp_name, sdf, mbs.param[2], tgt));

#else
		/*
		 * We don't update any information because we need to run
		 * at least one command per target to cause a new state
		 * to be latched.
		 */
#endif
d960 5
d970 2
a971 2
		sdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;
		for (lun = 0; lun < isp->isp_maxluns; lun++) {
d976 1
a976 1
			isp_mboxcmd(isp, &mbs);
a977 3
				PRINTF("%s: failed to set device queue "
				    "parameters for target %d, lun %d\n",
				    isp->isp_name, tgt, lun);
d982 7
d1004 1
a1007 9
	/*
	 * For systems that don't have BIOS methods for which
	 * we can easily change the NVRAM based loopid, we'll
	 * override that here. Note that when we initialize
	 * the firmware we may get back a different loopid than
	 * we asked for anyway. XXX This is probably not the
	 * best way to figure this out XXX
	 */
#ifndef	__i386__
a1008 4
#else
	loopid = fcp->isp_loopid;
#endif

d1013 8
a1020 6
#ifdef	ISP_TARGET_MODE
	fcp->isp_fwoptions = ICBOPT_TGT_ENABLE;
#else
	fcp->isp_fwoptions = 0;
#endif
	fcp->isp_fwoptions |= ICBOPT_FAIRNESS;
d1027 1
a1027 2
	fcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;
	fcp->isp_fwoptions |= ICBOPT_HARD_ADDRESS;
d1036 5
a1040 5
#ifndef	ISP_NO_FASTPOST_FC
	fcp->isp_fwoptions |= ICBOPT_FAST_POST;
#endif
	if (isp->isp_confopts & ISP_CFG_FULL_DUPLEX)
		fcp->isp_fwoptions |= ICBOPT_FULL_DUPLEX;
d1051 3
a1053 2
		PRINTF("%s: bad frame length (%d) from NVRAM- using %d\n",
		    isp->isp_name, fcp->isp_maxfrmlen, ICB_DFLT_FRMLEN);
d1058 2
a1059 2
		PRINTF("%s: bad maximum allocation (%d)- using 16\n",
		     isp->isp_name, fcp->isp_maxalloc);
d1064 3
a1066 2
		PRINTF("%s: bad execution throttle of %d- using 16\n",
		    isp->isp_name, fcp->isp_execthrottle);
d1072 4
a1075 1
#ifdef	PRET_A_PORTE
a1085 1
#endif
d1088 11
a1098 3
	if (fcp->isp_nodewwn) {
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, fcp->isp_nodewwn);
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, fcp->isp_portwwn);
d1100 1
d1103 2
a1104 2
	icbp->icb_rqstqlen = RQUEST_QUEUE_LEN;
	icbp->icb_rsltqlen = RESULT_QUEUE_LEN;
d1109 2
d1120 11
a1130 21
	MemoryBarrier();
	for (;;) {
		mbs.param[0] = MBOX_INIT_FIRMWARE;
		mbs.param[1] = 0;
		mbs.param[2] = DMA_MSW(fcp->isp_scdma);
		mbs.param[3] = DMA_LSW(fcp->isp_scdma);
		mbs.param[4] = 0;
		mbs.param[5] = 0;
		mbs.param[6] = 0;
		mbs.param[7] = 0;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			PRINTF("%s: INIT FIRMWARE failed (code 0x%x)\n",
			    isp->isp_name, mbs.param[0]);
			if (mbs.param[0] & 0x8000) {
				SYS_DELAY(1000);
				continue;
			}
			return;
		}
		break;
a1131 1

d1182 2
a1183 4
	isp_mboxcmd(isp, &mbs);
	switch (mbs.param[0]) {
	case MBOX_COMMAND_COMPLETE:
		MemoryBarrier();
d1185 1
a1185 13
		break;
	case MBOX_HOST_INTERFACE_ERROR:
		PRINTF("%s: DMA error getting port database\n", isp->isp_name);
		return (-1);
	case MBOX_COMMAND_PARAM_ERROR:
		/* Not Logged In */
		IDPRINTF(3, ("%s: Param Error on Get Port Database for id %d\n",
		    isp->isp_name, id));
		return (-1);
	default:
		PRINTF("%s: error 0x%x getting port database for ID %d\n",
		    isp->isp_name, mbs.param[0], id);
		return (-1);
d1187 1
a1187 1
	return (0);
d1203 1
a1203 1
	isp_mboxcmd(isp, &mbs);
d1223 1
a1223 1
isp_fclink_test(isp, waitdelay)
d1225 1
a1225 1
	int waitdelay;
d1244 4
d1251 7
a1257 1
	for (count = 0; count < waitdelay; count += 100) {
d1260 2
a1261 2
			PRINTF("%s: Firmware State %s -> %s\n",
			    isp->isp_name, isp2100_fw_statename((int)lwfs),
d1268 39
a1306 1
		SYS_DELAY(100);	/* wait 100 microseconds */
d1320 1
a1320 1
	isp_mboxcmd(isp, &mbs);
a1321 1
		PRINTF("%s: GET LOOP ID failed\n", isp->isp_name);
d1389 2
a1390 4
	CFGPRINTF("%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State "
	    "0x%x topology '%s'\n", isp->isp_name, fcp->isp_loopid,
	    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate,
	    toponames[fcp->isp_topo]);
d1395 16
a1410 3
/*
 * Compare two local port db entities and return 1 if they're the same, else 0.
 */
d1521 2
a1522 2
			PRINTF("%s: giving up on synchronizing the port "
			    "database\n", isp->isp_name);
d1626 2
a1627 3
				PRINTF("%s: Target ID %d Loop 0x%x (Port 0x%x) "
				    "=> Loop 0x%x (Port 0x%x) \n",
				    isp->isp_name, i, fcp->portdb[i].loopid,
d1645 1
a1645 3
				PRINTF("%s: Target ID %d Duplicates Target ID "
				    "%d- killing off both\n",
				    isp->isp_name, j, i);
d1678 1
a1678 1
				PRINTF("%s: remap overflow?\n", isp->isp_name);
d1774 3
a1776 4
				IDPRINTF(1, ("%s: retained login of Target %d "
				    "(Loop 0x%x) Port ID 0x%x\n",
				    isp->isp_name, (int) (lp - fcp->portdb),
				    (int) lp->loopid, lp->portid));
d1789 1
a1789 1
			isp_mboxcmd(isp, &mbs);
d1791 2
a1792 3
			IDPRINTF(1, ("%s: Logging out target %d at Loop ID %d "
			    "(port id 0x%x)\n", isp->isp_name,
			    (int) (lp - fcp->portdb), lp->loopid, lp->portid));
d1809 2
a1810 1
			isp_mboxcmd(isp, &mbs);
d1826 3
a1828 5
					IDPRINTF(1, ("%s: Retaining loopid 0x%x"
					    " for Target %d (port id 0x%x)\n",
					    isp->isp_name, loopid,
					    (int) (lp - fcp->portdb),
					    lp->portid));
d1839 2
a1840 3
				PRINTF("%s: command error in PLOGI for port "
				    " 0x%x (0x%x)\n", isp->isp_name, portid,
				    mbs.param[1]);
d1862 1
a1862 2
			PRINTF("%s: could not get PDB for device@@port 0x%x\n",
			    isp->isp_name, lp->portid);
d1867 2
a1868 3
			PRINTF("%s: PDB loopid info for device@@port 0x%x does "
			    "not match up (0x%x)\n", isp->isp_name, lp->portid,
			    pdb.pdb_loopid);
d1873 2
a1874 3
			PRINTF("%s: PDB port info for device@@port 0x%x does "
			    "not match up (0x%x)\n", isp->isp_name, lp->portid,
			    BITS2WORD(pdb.pdb_portid_bits));
d1909 2
a1910 2
		PRINTF("%s: Target %d (Loop 0x%x) Port ID 0x%x dumped after "
		    "login\n", isp->isp_name, loopid, lp->loopid, lp->portid);
d1915 1
a1915 1
		isp_mboxcmd(isp, &mbs);
d1921 1
a1921 1
	 * in ispscsicmd.
d1961 1
a1961 2
		MemoryBarrier();
		isp_mboxcmd(isp, &mbs);
a1962 2
			IDPRINTF(1, ("%s: SNS failed (0x%x)\n", isp->isp_name,
			    mbs.param[0]));
d1989 3
a1991 3
int32_t
ispscsicmd(xs)
	ISP_SCSI_XFER_T *xs;
d2008 1
a2008 1
		PRINTF("%s: adapter not ready\n", isp->isp_name);
d2021 3
a2023 2
		PRINTF("%s: unsupported cdb length (%d, CDB[0]=0x%x)\n",
		    isp->isp_name, XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);
d2073 4
a2076 1
			if (isp_fclink_test(isp, FC_FW_READY_DELAY)) {
d2117 5
d2130 2
a2131 2
			IDPRINTF(3, ("%s: target %d is not a target\n",
			    isp->isp_name, target));
d2150 1
a2150 1
		IDPRINTF(2, ("%s: Request Queue Overflow\n", isp->isp_name));
a2174 1
			MemoryBarrier();
d2178 2
a2179 2
				IDPRINTF(2, ("%s: Request Queue Overflow+\n",
				    isp->isp_name));
d2209 2
a2210 2
		if (XS_CANTAG(xs)) {
			t2reqp->req_flags = XS_KINDOF_TAG(xs);
d2212 4
d2224 2
a2225 2
		    XS_CANTAG(xs)) {
			reqp->req_flags = XS_KINDOF_TAG(xs);
d2252 1
a2252 1
		IDPRINTF(2, ("%s: out of xflist pointers\n", isp->isp_name));
d2270 3
a2272 4
	IDPRINTF(5, ("%s(%d.%d.%d): START cmd 0x%x datalen %d\n",
	    isp->isp_name, XS_CHANNEL(xs), target, XS_LUN(xs),
	    reqp->req_cdb[0], XS_XFRLEN(xs)));
	MemoryBarrier();
d2293 1
a2293 1
	ISP_SCSI_XFER_T *xs;
d2300 1
a2300 2
		PRINTF("%s: isp_control unknown control op %x\n",
		    isp->isp_name, ctl);
d2322 1
a2322 1
		isp_mboxcmd(isp, &mbs);
a2323 1
			isp_dumpregs(isp, "isp_control SCSI bus reset failed");
d2326 2
a2327 2
		CFGPRINTF("%s: driver initiated bus reset of bus %d\n",
		    isp->isp_name, bus);
d2336 1
a2336 1
		isp_mboxcmd(isp, &mbs);
a2337 2
			PRINTF("%s: isp_control MBOX_RESET_DEV failure (code "
			    "%x)\n", isp->isp_name, mbs.param[0]);
d2340 2
a2341 2
		PRINTF("%s: Target %d on Bus %d Reset Succeeded\n",
		    isp->isp_name, tgt, bus);
d2346 1
a2346 1
		xs = (ISP_SCSI_XFER_T *) arg;
d2350 2
a2351 2
			PRINTF("%s: isp_control- cannot find command to abort "
			    "in active list\n", isp->isp_name);
d2371 3
a2373 13
		isp_mboxcmd(isp, &mbs);
		switch (mbs.param[0]) {
		case MBOX_COMMAND_COMPLETE:
			IDPRINTF(1,
			    ("%s: command (handle 0x%x) for %d.%d.%d aborted\n",
			    isp->isp_name, handle, bus, tgt, XS_LUN(xs)));
			/* FALLTHROUGH */
		case MBOX_COMMAND_ERROR:
			break;
		default:
			PRINTF("%s: command (handle 0x%x) abort failed (%x)\n",
			    isp->isp_name, handle, mbs.param[0]);
			break;
d2375 5
a2379 1
		return (0);
d2387 2
a2388 1
			return (isp_fclink_test(isp, FC_FW_READY_DELAY));
a2396 1

d2399 2
a2401 1
			int ena = *(int *)arg;
d2404 1
a2404 1
			isp_mboxcmd(isp, &mbs);
a2405 3
				PRINTF("%s: cannot %sable target mode (0x%x)\n",
				    isp->isp_name, ena? "en" : "dis",
				    mbs.param[0]);
d2408 26
d2436 1
d2449 6
a2458 1
	ISP_SCSI_XFER_T *complist[RESULT_QUEUE_LEN], *xs;
d2460 1
d2471 2
a2472 2
			PRINTF("%s: isr unsteady (%x, %x)\n",
			    isp->isp_name, isr, junk);
d2480 2
a2481 2
			PRINTF("%s: sema unsteady (%x, %x)\n",
			    isp->isp_name, sema, junk);
d2487 1
a2487 1
	IDPRINTF(5, ("%s: isp_intr isr %x sem %x\n", isp->isp_name, isr, sema));
d2504 2
a2505 2
				PRINTF("%s: mailbox0 unsteady (%x, %x)\n",
				    isp->isp_name, mbox, junk);
d2526 3
a2528 2
				PRINTF("%s: Command Mbox 0x%x\n",
				    isp->isp_name, mbox);
d2532 1
a2532 2
			IDPRINTF(4, ("%s: Async Mbox 0x%x\n",
			    isp->isp_name, mbox));
d2548 2
a2549 2
		PRINTF("%s: interrupt (isr=%x, sema=%x) when not ready\n",
		    isp->isp_name, isr, sema);
d2570 2
a2571 2
			PRINTF("%s: mailbox5 unsteady (%x, %x)\n",
			    isp->isp_name, iptr, junk);
d2593 3
a2595 2
		IDPRINTF(2, ("%s: null intr- isr %x (%x) iptr %x optr %x\n",
		    isp->isp_name, isr, junk, iptr, optr));
d2605 1
a2605 1
		optr = ISP_NXT_QENTRY(optr, RESULT_QUEUE_LEN);
a2606 1
		MemoryBarrier();
d2610 1
a2610 1
		 * per-platform thing.
d2612 1
a2612 1
		ISP_UNSWIZZLE_RESPONSE(isp, sp);
d2615 1
d2624 1
a2624 3
				PRINTF("%s: not RESPONSE in RESPONSE Queue "
				    "(type 0x%x) @@ idx %d (next %d)\n",
				    isp->isp_name,
d2626 1
d2636 2
a2637 2
				IDPRINTF(4, ("%s: continuation segment\n",
				    isp->isp_name));
d2642 2
a2643 2
				IDPRINTF(2, ("%s: internal queues full\n",
				    isp->isp_name));
d2649 1
a2649 1
				PRINTF("%s: bad header\n", isp->isp_name);
d2653 1
a2653 2
				PRINTF("%s: bad request packet\n",
				    isp->isp_name);
d2657 3
a2659 2
				PRINTF("%s: unknown flags in response (0x%x)\n",
				    isp->isp_name, sp->req_header.rqs_flags);
d2665 3
a2667 2
			PRINTF("%s: bad request handle %d\n", isp->isp_name,
			    sp->req_handle);
d2673 4
a2676 2
			PRINTF("%s: NULL xs in xflist (handle 0x%x)\n",
			    isp->isp_name, sp->req_handle);
d2687 2
a2688 7
		XS_STS(xs) = sp->req_scsi_status & 0xff;
		if (IS_SCSI(isp)) {
			if (sp->req_state_flags & RQSF_GOT_SENSE) {
				MEMCPY(XS_SNSP(xs), sp->req_sense_data,
					XS_SNSLEN(xs));
				XS_SNS_IS_VALID(xs);
			}
d2690 3
a2692 3
			 * A new synchronous rate was negotiated for this
			 * target. Mark state such that we'll go look up
			 * that which has changed later.
d2694 1
a2694 17
			if (sp->req_status_flags & RQSTF_NEGOTIATION) {
				sdparam *sdp = isp->isp_param;
				sdp += XS_CHANNEL(xs);
				sdp->isp_devparam[XS_TGT(xs)].dev_refresh = 1;
				isp->isp_update |= (1 << XS_CHANNEL(xs));
			}
		} else {
			if (sp->req_scsi_status & RQCS_SV) {
				int amt = min(XS_SNSLEN(xs), sp->req_sense_len);
				MEMCPY(XS_SNSP(xs), sp->req_sense_data, amt);
				XS_SNS_IS_VALID(xs);
				sp->req_state_flags |= RQSF_GOT_SENSE;
			} else if (XS_STS(xs) == SCSI_CHECK) {
				IDPRINTF(2,
				    ("%s: check condition with no sense data\n",
				    isp->isp_name));
			}
d2696 2
a2697 2
		if (XS_NOERR(xs) && XS_STS(xs) == SCSI_BUSY) {
			XS_SETERR(xs, HBA_TGTBSY);
d2700 41
a2740 7
		if (sp->req_header.rqs_entry_type == RQSTYPE_RESPONSE) {
			if (XS_NOERR(xs)) {
			    if (sp->req_completion_status != RQCS_COMPLETE) {
				isp_parse_status(isp, sp, xs);
			    } else {
				XS_SETERR(xs, HBA_NOERROR);
			    }
d2742 4
a2745 1
		} else if (sp->req_header.rqs_entry_type == RQSTYPE_REQUEST) {
d2750 1
a2750 1
				XS_STS(xs) = SCSI_QFULL;
d2755 6
a2760 3
		} else {
			PRINTF("%s: unhandled respose queue type 0x%x\n",
			    isp->isp_name, sp->req_header.rqs_entry_type);
d2764 1
d2766 4
a2769 7
		if (IS_SCSI(isp)) {
			XS_RESID(xs) = sp->req_resid;
		} else if (sp->req_scsi_status & RQCS_RU) {
			XS_RESID(xs) = sp->req_resid;
			IDPRINTF(4, ("%s: cnt %d rsd %d\n", isp->isp_name,
				XS_XFRLEN(xs), sp->req_resid));
		}
d2773 4
a2776 5
		if ((isp->isp_dblev >= 5) ||
		    (isp->isp_dblev > 2 && !XS_NOERR(xs))) {
			PRINTF("%s(%d.%d): FIN dl%d resid%d STS %x",
			    isp->isp_name, XS_TGT(xs), XS_LUN(xs),
			    XS_XFRLEN(xs), XS_RESID(xs), XS_STS(xs));
d2778 9
a2786 4
				PRINTF(" Skey: %x", XS_SNSKEY(xs));
				if (!(XS_IS_SNS_VALID(xs))) {
					PRINTF(" BUT NOT SET");
				}
d2788 3
a2790 1
			PRINTF(" XS_ERR=0x%x\n", (unsigned int) XS_ERR(xs));
d2796 4
d2816 1
a2816 1
			XS_CMD_DONE(xs);
a2840 2
	case MBOX_COMMAND_COMPLETE:	/* sometimes these show up */
		break;
d2850 3
a2852 3
		PRINTF("%s: Internal FW Error @@ RISC Addr 0x%x\n",
		    isp->isp_name, mbox);
		isp_restart(isp);
d2857 1
a2857 1
		PRINTF("%s: Request Queue Transfer Error\n", isp->isp_name);
d2861 1
a2861 1
		PRINTF("%s: Response Queue Transfer Error\n", isp->isp_name);
d2874 2
a2875 2
		PRINTF("%s: timeout initiated SCSI bus reset of bus %d\n",
		    isp->isp_name, bus);
d2883 1
a2883 1
		PRINTF("%s: device reset on bus %d\n", isp->isp_name, bus);
d2891 1
a2891 1
		PRINTF("%s: extended message underrun\n", isp->isp_name);
d2895 1
a2895 1
		PRINTF("%s: SCAM interrupt\n", isp->isp_name);
d2899 2
a2900 2
		PRINTF("%s: stalled SCSI Bus after DATA Overrun\n",
		    isp->isp_name);
d2905 1
a2905 2
		PRINTF("%s: SCSI Bus reset after DATA Overrun\n",
		    isp->isp_name);
d2912 4
a2915 4
			PRINTF("%s: Transition to LVD mode\n", isp->isp_name);
			((sdparam *)isp->isp_param)->isp_diffmode = 0;
			((sdparam *)isp->isp_param)->isp_ultramode = 0;
			((sdparam *)isp->isp_param)->isp_lvdmode = 1;
d2918 5
a2922 5
			PRINTF("%s: Transition to Differential mode\n",
			    isp->isp_name);
			((sdparam *)isp->isp_param)->isp_diffmode = 1;
			((sdparam *)isp->isp_param)->isp_ultramode = 0;
			((sdparam *)isp->isp_param)->isp_lvdmode = 0;
d2925 5
a2929 5
			PRINTF("%s: Transition to Single Ended mode\n",
			    isp->isp_name);
			((sdparam *)isp->isp_param)->isp_diffmode = 0;
			((sdparam *)isp->isp_param)->isp_ultramode = 1;
			((sdparam *)isp->isp_param)->isp_lvdmode = 0;
d2932 2
a2933 2
			PRINTF("%s: Transition to unknown mode 0x%x\n",
			    isp->isp_name, mbox);
d2946 2
a2947 2
		IDPRINTF(4, ("%s: fast post completion of %u\n", isp->isp_name,
		    fast_post_handle));
d2951 11
a2961 2
		/* Should only occur when Fast Posting Set for 2100s */
		PRINTF("%s: CTIO done\n", isp->isp_name);
d2965 1
a2965 1
		((fcparam *) isp->isp_param)->isp_lipseq =
d2967 2
a2968 2
		((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;
d2971 1
a2971 1
		IDPRINTF(1, ("%s: LIP occurred\n", isp->isp_name));
d2979 2
a2980 2
		((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;
d2990 2
a2991 2
		((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;
d3001 2
a3002 2
		((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;
d3004 1
a3004 1
		PRINTF("%s: Loop RESET\n", isp->isp_name);
d3012 1
a3012 1
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;
d3014 1
a3014 1
		IDPRINTF(1, ("%s: Port Database Changed\n", isp->isp_name));
d3022 1
a3022 1
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;
d3027 2
a3028 2
		if (((fcparam *) isp->isp_param)->isp_onfabric)
			((fcparam *) isp->isp_param)->isp_topo = TOPO_N_PORT;
d3030 1
a3030 1
			((fcparam *) isp->isp_param)->isp_topo = TOPO_F_PORT;
d3033 2
a3034 2
		((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;
d3038 1
a3038 1
		PRINTF("%s: Point-to-Point mode\n", isp->isp_name);
d3045 1
a3045 2
			PRINTF("%s: Point-to-Point -> Loop mode\n",
			    isp->isp_name);
d3048 1
a3048 2
			PRINTF("%s: Loop -> Point-to-Point mode\n",
			    isp->isp_name);
d3051 2
a3052 2
			PRINTF("%s: Point-to-Point -> Loop mode (1)\n",
			    isp->isp_name);
d3055 2
a3056 2
			PRINTF("%s: FATAL CONNECTION ERROR\n", isp->isp_name);
			isp_restart(isp);
d3061 2
a3062 2
			PRINTF("%s: Looped Back in Point-to-Point mode\n",
			     isp->isp_name);
d3067 1
a3067 1
		PRINTF("%s: unknown async code 0x%x\n", isp->isp_name, mbox);
d3086 3
d3102 1
d3107 1
a3107 1
		PRINTF("%s: unhandled response type 0x%x\n", isp->isp_name,
d3117 1
a3117 1
	ISP_SCSI_XFER_T *xs;
d3119 1
a3119 1
	switch (sp->req_completion_status) {
d3121 3
a3123 1
		XS_SETERR(xs, HBA_NOERROR);
d3128 6
a3133 4
			IDPRINTF(3, ("%s: Selection Timeout for %d.%d.%d\n",
			    isp->isp_name, XS_TGT(xs), XS_LUN(xs),
			    XS_CHANNEL(xs)));
			XS_SETERR(xs, HBA_SELTIMEOUT);
d3136 3
a3138 2
		PRINTF("%s: command incomplete for %d.%d.%d, state 0x%x\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),
d3143 2
a3144 2
		PRINTF("%s: DMA error for command on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3148 53
a3200 3
		PRINTF("%s: transport error for %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		isp_prtstst(sp);
d3202 1
a3202 1

d3204 3
a3206 2
		IDPRINTF(1, ("%s: bus reset destroyed command for %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));
d3208 3
a3210 1
		XS_SETERR(xs, HBA_BUSRESET);
d3214 2
a3215 2
		PRINTF("%s: command aborted for %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3217 3
a3219 1
		XS_SETERR(xs, HBA_ABORTED);
d3223 5
a3227 3
		IDPRINTF(2, ("%s: command timed out for %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));
		XS_SETERR(xs, HBA_CMDTIMEOUT);
d3231 5
a3235 3
		if (IS_FC(isp)) {
			XS_RESID(xs) = sp->req_resid;
			break;
a3236 3
		PRINTF("%s: data overrun for command on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		XS_SETERR(xs, HBA_DATAOVR);
d3240 3
a3242 2
		PRINTF("%s: command overrun for command on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3246 3
a3248 2
		PRINTF("%s: status overrun for command on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3252 3
a3254 2
		PRINTF("%s: msg not COMMAND COMPLETE after status %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3258 3
a3260 2
		PRINTF("%s: No MESSAGE OUT phase after selection on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3264 2
a3265 2
		PRINTF("%s: EXTENDED IDENTIFY failed %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3269 3
a3271 2
		PRINTF("%s: INITIATOR DETECTED ERROR rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3275 2
a3276 2
		PRINTF("%s: ABORT OPERATION rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3280 2
a3281 2
		PRINTF("%s: MESSAGE REJECT rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3285 2
a3286 2
		PRINTF("%s: NOP rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3290 3
a3292 2
		PRINTF("%s: MESSAGE PARITY ERROR rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3296 3
a3298 2
		PRINTF("%s: BUS DEVICE RESET rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3302 2
a3303 2
		PRINTF("%s: IDENTIFY rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3307 2
a3308 2
		PRINTF("%s: %d.%d.%d had an unexpected bus free\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3312 3
a3314 2
		if (IS_FC(isp)) {
			XS_RESID(xs) = sp->req_resid;
a3315 1
		XS_SETERR(xs, HBA_NOERROR);
d3319 1
a3319 2
		PRINTF("%s: HBA attempted queued transaction with disconnect "
		    "not set for %d.%d.%d\n", isp->isp_name, XS_CHANNEL(xs),
d3324 1
a3324 2
		PRINTF("%s: HBA attempted queued transaction to target "
		    "routine %d on target %d, bus %d\n", isp->isp_name,
d3329 2
a3330 3
		PRINTF("%s: HBA attempted queued transaction for target %d lun "
		    "%d on bus %d when queueing disabled\n", isp->isp_name,
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3334 1
a3334 1
		PRINTF("%s: invalid IOCB entry type detected\n", isp->isp_name);
d3338 3
a3340 3
		IDPRINTF(3, ("%s: internal queues full for target %d lun %d "
		    "bus %d, status 0x%x\n", isp->isp_name, XS_TGT(xs),
		    XS_LUN(xs), XS_CHANNEL(xs), XS_STS(xs)));
d3345 1
a3345 1
		if (XS_STS(xs) != 0) {
d3352 2
a3353 3
		PRINTF("%s: SCSI phase skipped (e.g., COMMAND COMPLETE w/o "
		    "STATUS phase) for target %d lun %d bus %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3357 6
a3362 2
		PRINTF("%s: Auto Request Sense failed for %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3366 3
a3368 2
		PRINTF("%s: Wide Negotiation failed for %d.%d.%d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3376 3
a3378 1
		XS_SETERR(xs, HBA_NOERROR);
d3382 3
a3384 2
		PRINTF("%s: SDTR Message failed for target %d.%d.%d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3395 3
a3397 2
		PRINTF("%s: Bad LVD condition while talking to %d.%d.%d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3404 5
a3408 3
		IDPRINTF(3, ("%s: Port Unavailable for target %d\n",
		    isp->isp_name, XS_TGT(xs)));
		XS_SETERR(xs, HBA_SELTIMEOUT);
d3415 5
a3419 3
		IDPRINTF(2, ("%s: port logout for target %d\n",
			isp->isp_name, XS_TGT(xs)));
		XS_SETERR(xs, HBA_SELTIMEOUT);
d3423 5
a3427 3
		PRINTF("%s: port changed for target %d\n",
		    isp->isp_name, XS_TGT(xs));
		XS_SETERR(xs, HBA_SELTIMEOUT);
d3431 5
a3435 3
		PRINTF("%s: port busy for target %d\n",
		    isp->isp_name, XS_TGT(xs));
		XS_SETERR(xs, HBA_TGTBSY);
d3439 2
a3440 2
		PRINTF("%s: completion status 0x%x\n",
		    isp->isp_name, sp->req_completion_status);
d3443 3
a3445 1
	XS_SETERR(xs, HBA_BOTCH);
d3453 1
a3453 1
	ISP_SCSI_XFER_T *xs;
d3460 2
a3461 2
		PRINTF("%s: command for fast posting handle 0x%x not found\n",
		    isp->isp_name, fph);
d3471 1
d3473 1
a3473 1
	XS_STS(xs) = 0;
a3476 1
	XS_CMD_DONE(xs);
d3479 1
d3582 99
d3811 132
d3944 1
a3944 1
isp_mboxcmd(isp, mbp)
d3947 1
d3949 1
d3963 1
a3963 1
		PRINTF("%s: unknown command 0x%x\n", isp->isp_name, opcode);
d3972 1
a3972 2
		PRINTF("%s: no parameters for opcode 0x%x\n", isp->isp_name,
			opcode);
d3976 5
d4001 1
a4001 1
	SYS_DELAY(250);
d4018 14
d4035 1
d4040 2
a4041 2
		IDPRINTF(2, ("%s: mbox cmd %x failed with INVALID_COMMAND\n",
		    isp->isp_name, opcode));
d4044 2
a4045 2
		PRINTF("%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\n",
		    isp->isp_name, opcode);
d4048 2
a4049 2
		PRINTF("%s: mbox cmd %x failed with TEST_FAILED\n",
		    isp->isp_name, opcode);
d4052 2
a4053 3
		if (opcode != MBOX_ABOUT_FIRMWARE)
		    PRINTF("%s: mbox cmd %x failed with COMMAND_ERROR\n",
			isp->isp_name, opcode);
d4056 2
a4057 9
		switch (opcode) {
		case MBOX_GET_PORT_DB:
		case MBOX_GET_PORT_NAME:
		case MBOX_GET_DEV_QUEUE_PARAMS:
			break;
		default:
			PRINTF("%s: mbox cmd %x failed with "
			    "COMMAND_PARAM_ERROR\n", isp->isp_name, opcode);
		}
a4058 1

d4060 3
d4064 3
d4068 5
a4073 1

d4075 2
a4076 8
		/*
		 * The expected return of EXEC_FIRMWARE is zero.
		 */
		if ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||
		    (opcode != MBOX_EXEC_FIRMWARE)) {
			PRINTF("%s: mbox cmd %x failed with error %x\n",
				isp->isp_name, opcode, mbp->param[0]);
		}
d4079 3
a4081 73
}

void
isp_lostcmd(isp, xs)
	struct ispsoftc *isp;
	ISP_SCSI_XFER_T *xs;
{
	mbreg_t mbs;

	mbs.param[0] = MBOX_GET_FIRMWARE_STATUS;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_dumpregs(isp, "couldn't GET FIRMWARE STATUS");
		return;
	}
	if (mbs.param[1]) {
		PRINTF("%s: %d commands on completion queue\n",
		    isp->isp_name, mbs.param[1]);
	}
	if (XS_NULL(xs))
		return;

	mbs.param[0] = MBOX_GET_DEV_QUEUE_STATUS;
	mbs.param[1] = (XS_TGT(xs) << 8) | XS_LUN(xs); /* XXX: WHICH BUS? */
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_dumpregs(isp, "couldn't GET DEVICE QUEUE STATUS");
		return;
	}
	PRINTF("%s: lost command for target %d lun %d, %d active of %d, "
		"Queue State: %x\n", isp->isp_name, XS_TGT(xs),
		XS_LUN(xs), mbs.param[2], mbs.param[3], mbs.param[1]);

	isp_dumpregs(isp, "lost command");
	/*
	 * XXX: Need to try and do something to recover.
	 */
}

static void
isp_dumpregs(isp, msg)
	struct ispsoftc *isp;
	const char *msg;
{
	PRINTF("%s: %s\n", isp->isp_name, msg);
	if (IS_SCSI(isp))
		PRINTF("    biu_conf1=%x", ISP_READ(isp, BIU_CONF1));
	else
		PRINTF("    biu_csr=%x", ISP_READ(isp, BIU2100_CSR));
	PRINTF(" biu_icr=%x biu_isr=%x biu_sema=%x ", ISP_READ(isp, BIU_ICR),
	    ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));
	PRINTF("risc_hccr=%x\n", ISP_READ(isp, HCCR));


	if (IS_SCSI(isp)) {
		ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
		PRINTF("    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\n",
			ISP_READ(isp, CDMA_CONF), ISP_READ(isp, CDMA_STATUS),
			ISP_READ(isp, CDMA_FIFO_STS));
		PRINTF("    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\n",
			ISP_READ(isp, DDMA_CONF), ISP_READ(isp, DDMA_STATUS),
			ISP_READ(isp, DDMA_FIFO_STS));
		PRINTF("    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\n",
			ISP_READ(isp, SXP_INTERRUPT),
			ISP_READ(isp, SXP_GROSS_ERR),
			ISP_READ(isp, SXP_PINS_CTRL));
		ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
	}
	PRINTF("    mbox regs: %x %x %x %x %x\n",
	    ISP_READ(isp, OUTMAILBOX0), ISP_READ(isp, OUTMAILBOX1),
	    ISP_READ(isp, OUTMAILBOX2), ISP_READ(isp, OUTMAILBOX3),
	    ISP_READ(isp, OUTMAILBOX4));
	ISP_DUMPREGS(isp);
a4087 1
	mbreg_t mbs;
d4089 1
a4089 1
		int once = 0;
d4091 1
a4091 1
again:
d4093 3
a4095 38
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			IDPRINTF(1, ("%s: isp_fw_state 0x%x\n", isp->isp_name,
			    mbs.param[0]));
			switch (mbs.param[0]) {
			case ASYNC_PDB_CHANGED:
				if (once++ < 10) {
					goto again;
				}
				fcp->isp_fwstate = FW_CONFIG_WAIT;
				fcp->isp_loopstate = LOOP_PDB_RCVD;
				goto again;
			case ASYNC_LIP_OCCURRED:
				fcp->isp_lipseq = mbs.param[1];
				/* FALLTHROUGH */
			case ASYNC_LOOP_UP:
				fcp->isp_fwstate = FW_CONFIG_WAIT;
				fcp->isp_loopstate = LOOP_LIP_RCVD;
				if (once++ < 10) {
					goto again;
				}
				break;
			case ASYNC_LOOP_RESET:
			case ASYNC_LOOP_DOWN:
				fcp->isp_fwstate = FW_CONFIG_WAIT;
				fcp->isp_loopstate = LOOP_NIL;
				/* FALLTHROUGH */
			case ASYNC_CHANGE_NOTIFY:
				if (once++ < 10) {
					goto again;
				}
				break;
			}
			PRINTF("%s: GET FIRMWARE STATE failed (0x%x)\n",
			    isp->isp_name, mbs.param[0]);
			return;
		}
		fcp->isp_fwstate = mbs.param[1];
d4103 1
a4103 1
	int bus;
d4105 2
a4106 2
	for (bus = 0; isp->isp_update != 0; bus++) {
		if (isp->isp_update & (1 << bus)) {
a4107 1
			isp->isp_update ^= (1 << bus);
d4109 1
d4122 1
d4124 3
a4128 1

d4137 4
a4140 2
			IDPRINTF(2, ("%s: skipping target %d bus %d update\n",
			    isp->isp_name, tgt, bus));
a4142 1

d4149 9
a4157 1
		if (sdp->isp_devparam[tgt].dev_update) {
d4159 7
d4167 1
d4169 2
a4170 2
			 * Insist that PARITY must be enabled if SYNC
			 * is enabled.
d4172 1
a4172 1
			if (mbs.param[2] & DPARM_SYNC) {
d4175 8
a4182 4
			mbs.param[3] =
				(sdp->isp_devparam[tgt].sync_offset << 8) |
				(sdp->isp_devparam[tgt].sync_period);
			sdp->isp_devparam[tgt].dev_update = 0;
d4185 3
a4187 2
			 * RQSTF_NEGOTIATION set will cause
			 * the dev_refresh/announce cycle.
d4198 5
a4203 4
			IDPRINTF(3, ("%s: bus %d set tgt %d flags 0x%x off 0x%x"
			    " period 0x%x\n", isp->isp_name, bus, tgt,
			    mbs.param[2], mbs.param[3] >> 8,
			    mbs.param[3] & 0xff));
a4204 4
		} else if (sdp->isp_devparam[tgt].dev_refresh) {
			mbs.param[0] = MBOX_GET_TARGET_PARAMS;
			sdp->isp_devparam[tgt].dev_refresh = 0;
			get = 1;
d4209 1
a4209 7
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			PRINTF("%s: failed to %cet SCSI parameters for "
			    "target %d\n", isp->isp_name, (get)? 'g' : 's',
			    tgt);
			continue;
		}
d4223 8
d4251 1
a4251 1
		fcp->isp_execthrottle = ICB_DFLT_THROTTLE;
d4256 18
a4273 8
		fcp->isp_nodewwn = DEFAULT_WWN(isp);
		if ((fcp->isp_nodewwn >> 60) == 2) {
			fcp->isp_nodewwn &= ~((u_int64_t) 0xfff << 48);
			fcp->isp_portwwn = fcp->isp_nodewwn |
			    (((u_int64_t)(isp->isp_unit+1)) << 48);
		} else {
			fcp->isp_portwwn = fcp->isp_nodewwn;
		}
d4279 3
a4281 2
			PRINTF("%s: Node WWN 0x%08x%08x, Port WWN 0x%08x%08x\n",
			    isp->isp_name, (u_int32_t) (fcp->isp_nodewwn >> 32),
d4317 1
a4317 1
		isp_mboxcmd(isp, &mbs);
a4318 1
			IDPRINTF(2, ("could not GET ACT NEG STATE\n"));
d4332 6
a4337 4
	IDPRINTF(3, ("%s: defaulting bus %d REQ/ACK Active Negation is %d\n",
	    isp->isp_name, channel, sdp->isp_req_ack_active_neg));
	IDPRINTF(3, ("%s: defaulting bus %d DATA Active Negation is %d\n",
	    isp->isp_name, channel, sdp->isp_data_line_active_neg));
d4364 5
d4374 1
a4374 1
		} else {
d4379 5
d4394 1
a4394 1
			isp_mboxcmd(isp, &mbs);
d4430 3
a4432 3
		IDPRINTF(3, ("%s: bus %d tgt %d flags %x offset %x period %x\n",
		    isp->isp_name, channel, tgt,
		    sdp->isp_devparam[tgt].dev_flags,
d4434 1
a4434 1
		    sdp->isp_devparam[tgt].sync_period));
d4443 1
a4443 2
	sdp->isp_initiator_id = 7;
	/* XXXX This is probably based upon clock XXXX */
d4450 1
a4450 1
	sdp->isp_max_queue_depth = MAXISPREQUEST;
d4457 1
a4457 1
		sdp->isp_devparam[tgt].exc_throttle = 16;
d4471 1
a4471 1
isp_restart(isp)
d4474 1
a4474 1
	ISP_SCSI_XFER_T *xs;
d4485 1
a4485 1
		PRINTF("%s: isp_restart cannot restart ISP\n", isp->isp_name);
d4489 1
a4489 1
	for (handle = 1; handle <= (int) isp->isp_maxcmds; handle++) {
d4502 1
a4502 1
		XS_CMD_DONE(xs);
d4543 3
a4545 3
			PRINTF("%s: invalid NVRAM header (%x,%x,%x,%x)\n",
			    isp->isp_name, nvram_data[0], nvram_data[1],
			    nvram_data[2], nvram_data[3]);
d4556 1
a4556 1
		PRINTF("%s: invalid NVRAM checksum\n", isp->isp_name);
d4560 1
a4560 1
		PRINTF("%s: version %d NVRAM not understood\n", isp->isp_name,
a4577 1
	IDPRINTF(3, ("%s: NVRAM is valid\n", isp->isp_name));
d4593 1
a4593 1
	SYS_DELAY(2);
d4595 1
a4595 1
	SYS_DELAY(2);
d4621 1
a4621 1
		SYS_DELAY(2);
d4623 1
a4623 1
		SYS_DELAY(2);
d4625 1
a4625 1
		SYS_DELAY(2);
d4635 1
a4635 1
		SYS_DELAY(2);
d4640 1
a4640 1
		SYS_DELAY(2);
d4642 1
a4642 1
		SYS_DELAY(2);
d4645 2
a4646 4
	SYS_DELAY(2);
#if	BYTE_ORDER == BIG_ENDIAN
	*rp = ((*rp >> 8) | ((*rp & 0xff) << 8));
#endif
a4654 2
	static char *tru = "true";
	static char *not = "false";
d4707 1
a4707 30
	isp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);
	if (isp->isp_dblev > 2) {
		PRINTF("%s: NVRAM values:\n", isp->isp_name);
		PRINTF("             Fifo Threshold = 0x%x\n",
		    sdp->isp_fifo_threshold);
		PRINTF("            Bus Reset Delay = %d\n",
		    sdp->isp_bus_reset_delay);
		PRINTF("                Retry Count = %d\n",
		    sdp->isp_retry_count);
		PRINTF("                Retry Delay = %d\n",
		    sdp->isp_retry_delay);
		PRINTF("              Tag Age Limit = %d\n",
		    sdp->isp_tag_aging);
		PRINTF("          Selection Timeout = %d\n",
		    sdp->isp_selection_timeout);
		PRINTF("            Max Queue Depth = %d\n",
		    sdp->isp_max_queue_depth);
		PRINTF("           Async Data Setup = 0x%x\n",
		    sdp->isp_async_data_setup);
		PRINTF("    REQ/ACK Active Negation = %s\n",
		    sdp->isp_req_ack_active_neg? tru : not);
		PRINTF("  Data Line Active Negation = %s\n",
		    sdp->isp_data_line_active_neg? tru : not);
		PRINTF("      Data DMA Burst Enable = %s\n",
		    sdp->isp_data_dma_burst_enabl? tru : not);
		PRINTF("       Cmd DMA Burst Enable = %s\n",
		    sdp->isp_cmd_dma_burst_enable? tru : not);
		PRINTF("                  Fast MTTR = %s\n",
		    isp->isp_fast_mttr? tru : not);
	}
d4724 1
a4724 2
				sdp->isp_devparam[i].sync_period =
				    0x19;
d4727 1
a4727 2
				sdp->isp_devparam[i].sync_offset =
				    0x0c;
a4736 4
		if (ISP_NVRAM_TGT_QFRZ(nvram_data, i)) {
			PRINTF("%s: not supporting QFRZ option for "
			    "target %d\n", isp->isp_name, i);
		}
a4737 4
		if (ISP_NVRAM_TGT_ARQ(nvram_data, i) == 0) {
			PRINTF("%s: not disabling ARQ option for "
			    "target %d\n", isp->isp_name, i);
		}
a4748 9
		if (isp->isp_dblev > 2) {
			PRINTF("   Target %d: Enabled %d Throttle %d "
			    "Offset %d Period %d Flags 0x%x\n", i,
			    sdp->isp_devparam[i].dev_enable,
			    sdp->isp_devparam[i].exc_throttle,
			    sdp->isp_devparam[i].sync_offset,
			    sdp->isp_devparam[i].sync_period,
			    sdp->isp_devparam[i].dev_flags);
		}
a4757 2
	static char *tru = "true";
	static char *not = "false";
a4800 28
	if (isp->isp_dblev >= 3) {
		PRINTF("%s: ISP1080 bus %d NVRAM values:\n",
		    isp->isp_name, bus);
		PRINTF("               Initiator ID = %d\n",
		    sdp->isp_initiator_id);
		PRINTF("             Fifo Threshold = 0x%x\n",
		    sdp->isp_fifo_threshold);
		PRINTF("            Bus Reset Delay = %d\n",
		    sdp->isp_bus_reset_delay);
		PRINTF("                Retry Count = %d\n",
		    sdp->isp_retry_count);
		PRINTF("                Retry Delay = %d\n",
		    sdp->isp_retry_delay);
		PRINTF("              Tag Age Limit = %d\n",
		    sdp->isp_tag_aging);
		PRINTF("          Selection Timeout = %d\n",
		    sdp->isp_selection_timeout);
		PRINTF("            Max Queue Depth = %d\n",
		    sdp->isp_max_queue_depth);
		PRINTF("           Async Data Setup = 0x%x\n",
		    sdp->isp_async_data_setup);
		PRINTF("    REQ/ACK Active Negation = %s\n",
		    sdp->isp_req_ack_active_neg? tru : not);
		PRINTF("  Data Line Active Negation = %s\n",
		    sdp->isp_data_line_active_neg? tru : not);
		PRINTF("       Cmd DMA Burst Enable = %s\n",
		    sdp->isp_cmd_dma_burst_enable? tru : not);
	}
a4812 5
		if (ISP1080_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {
			PRINTF("%s: not supporting QFRZ option "
			    "for target %d bus %d\n",
			    isp->isp_name, i, bus);
		}
a4813 5
		if (ISP1080_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {
			PRINTF("%s: not disabling ARQ option "
			    "for target %d bus %d\n",
			    isp->isp_name, i, bus);
		}
a4824 10
		if (isp->isp_dblev >= 3) {
			PRINTF("   Target %d: Ena %d Throttle "
			    "%d Offset %d Period %d Flags "
			    "0x%x\n", i,
			    sdp->isp_devparam[i].dev_enable,
			    sdp->isp_devparam[i].exc_throttle,
			    sdp->isp_devparam[i].sync_offset,
			    sdp->isp_devparam[i].sync_period,
			    sdp->isp_devparam[i].dev_flags);
		}
a4833 2
	static char *tru = "true";
	static char *not = "false";
a4877 29
	if (isp->isp_dblev >= 3) {
		PRINTF("%s: ISP12160 bus %d NVRAM values:\n",
		    isp->isp_name, bus);
		PRINTF("               Initiator ID = %d\n",
		    sdp->isp_initiator_id);
		PRINTF("             Fifo Threshold = 0x%x\n",
		    sdp->isp_fifo_threshold);
		PRINTF("            Bus Reset Delay = %d\n",
		    sdp->isp_bus_reset_delay);
		PRINTF("                Retry Count = %d\n",
		    sdp->isp_retry_count);
		PRINTF("                Retry Delay = %d\n",
		    sdp->isp_retry_delay);
		PRINTF("              Tag Age Limit = %d\n",
		    sdp->isp_tag_aging);
		PRINTF("          Selection Timeout = %d\n",
		    sdp->isp_selection_timeout);
		PRINTF("            Max Queue Depth = %d\n",
		    sdp->isp_max_queue_depth);
		PRINTF("           Async Data Setup = 0x%x\n",
		    sdp->isp_async_data_setup);
		PRINTF("    REQ/ACK Active Negation = %s\n",
		    sdp->isp_req_ack_active_neg? tru : not);
		PRINTF("  Data Line Active Negation = %s\n",
		    sdp->isp_data_line_active_neg? tru : not);
		PRINTF("       Cmd DMA Burst Enable = %s\n",
		    sdp->isp_cmd_dma_burst_enable? tru : not);
	}

a4889 4
		if (ISP12160_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {
			PRINTF("%s: not supporting QFRZ option "
			    "for target %d bus %d\n", isp->isp_name, i, bus);
		}
a4890 4
		if (ISP12160_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {
			PRINTF("%s: not disabling ARQ option "
			    "for target %d bus %d\n", isp->isp_name, i, bus);
		}
a4901 9
		if (isp->isp_dblev >= 3) {
			PRINTF("   Target %d: Ena %d Throttle %d Offset %d "
			    "Period %d Flags 0x%x\n", i,
			    sdp->isp_devparam[i].dev_enable,
			    sdp->isp_devparam[i].exc_throttle,
			    sdp->isp_devparam[i].sync_offset,
			    sdp->isp_devparam[i].sync_period,
			    sdp->isp_devparam[i].dev_flags);
		}
d4911 31
a4941 12
	union {
		struct {
#if	BYTE_ORDER == BIG_ENDIAN
			u_int32_t hi32;
			u_int32_t lo32;
#else
			u_int32_t lo32;
			u_int32_t hi32;
#endif
		} wd;
		u_int64_t full64;
	} wwnstore;
d4944 1
a4944 3
	 * There is supposed to be WWNN storage as distinct
	 * from WWPN storage in NVRAM, but it doesn't appear
	 * to be used sanely.
d4946 5
d4952 14
a4965 22
	wwnstore.full64 = ISP2100_NVRAM_PORT_NAME(nvram_data);
	if (wwnstore.full64 != 0LL) {
		switch ((int) (wwnstore.full64 >> 60)) {
		case 0:
			/*
			 * Broken cards with nothing in the top nibble.
			 * Pah.
			 */
			wwnstore.full64 |= (2LL << 60); 
			/* FALLTHROUGH */
		case 2:
			fcp->isp_portwwn = wwnstore.full64;
			fcp->isp_nodewwn = wwnstore.full64;
			fcp->isp_nodewwn &= ~((0xfffLL) << 48);
			if (fcp->isp_nodewwn == fcp->isp_portwwn) {
				fcp->isp_portwwn |=
				    (((u_int64_t)(isp->isp_unit+1)) << 48);
			}
			break;
		default:
			fcp->isp_portwwn = wwnstore.full64;
			fcp->isp_nodewwn = wwnstore.full64;
a4967 5
	CFGPRINTF("%s: Node WWN 0x%08x%08x, Port WWN 0x%08x%08x\n",
	    isp->isp_name, (u_int32_t) (fcp->isp_nodewwn >> 32),
	    (u_int32_t) (fcp->isp_nodewwn & 0xffffffff),
	    (u_int32_t) (fcp->isp_portwwn >> 32),
	    (u_int32_t) (fcp->isp_portwwn & 0xffffffff));
d4982 2
a4983 19
	if (isp->isp_dblev > 2) {
		PRINTF("%s: NVRAM values:\n", isp->isp_name);
		PRINTF("  Max IOCB Allocation = %d\n",
		    fcp->isp_maxalloc);
		PRINTF("     Max Frame Length = %d\n",
		    fcp->isp_maxfrmlen);
		PRINTF("   Execution Throttle = %d\n",
		    fcp->isp_execthrottle);
		PRINTF("          Retry Count = %d\n",
		    fcp->isp_retry_count);
		PRINTF("          Retry Delay = %d\n",
		    fcp->isp_retry_delay);
		PRINTF("         Hard Loop ID = %d\n",
		    fcp->isp_loopid);
		PRINTF("              Options = 0x%x\n",
		    fcp->isp_fwoptions);
		PRINTF("          HBA Options = 0x%x\n",
		    ISP2100_NVRAM_HBA_OPTIONS(nvram_data));
	}
@


1.15
log
@Get FC connection topology out of f/w during startup. Reset restriction
against targets < 129 if we're on a Public Loop- we can have those, yes.
Fix all the settings isp_sendmarker all throughout this file to OR in
the bus that we are trying to synchronize (e.g., after a bus reset)- this
way we don't wipe out pending sendmarker settings that haven't been done
yet.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.14 2000/03/05 22:18:59 mjacob Exp $ */
d116 1
a116 1
	int loops, i, dodnld = 1;
d141 1
a141 1
	if (isp->isp_touched == 0) {
d579 2
d641 40
d906 1
a906 1
		int maxlun, lun;
d910 1
a910 1
			IDPRINTF(1, ("%s: skipping target %d bus %d settings\n",
d997 1
a997 7
		if ((ISP_FW_REV(4, 55, 0) <= ISP_FW_REVX(isp->isp_fwrev) &&
		    (ISP_FW_REV(5, 0, 0) > ISP_FW_REVX(isp->isp_fwrev))) ||
		    (ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(7, 55, 0)))
			maxlun = 32;
		else
			maxlun = 8;
		for (lun = 0; lun < maxlun; lun++) {
d1064 1
a1064 1
	 * a LIP- this is a known f/w bug.
a1117 1
		u_int64_t pn;
d1119 1
a1119 18
		if (fcp->isp_portwwn) {
			pn = fcp->isp_portwwn;
		} else {
			pn = fcp->isp_nodewwn |
			    (((u_int64_t)(isp->isp_unit+1)) << 56);
		}
		/*
		 * If the top nibble is 2, we can construct a port name
		 * from the node name by setting a nonzero instance in
		 * bits 56..59. Otherwise, we need to make it identical
		 * to Node name...
		 */
		if ((fcp->isp_nodewwn >> 60) == 2) {
			MAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pn);
		} else {
			MAKE_NODE_NAME_FROM_WWN(icbp->icb_portname,
			    fcp->isp_nodewwn);
		}
d1274 2
a1275 1
		"F Port"
d1322 4
a1325 4
		count = (int) mbs.param[6];
		if (count < TOPO_NL_PORT || count > TOPO_PTP_STUB)
			count = TOPO_PTP_STUB;
		fcp->isp_topo = count;
d1329 1
a1330 5
	/*
	 * If we're not on a fabric, the low 8 bits will be our AL_PA.
	 * If we're on a fabric, the low 8 bits will still be our AL_PA.
	 */
	fcp->isp_alpa = mbs.param[2];
d1333 4
a1336 3
	if (isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {

		if (IS_2100(isp))
d1338 1
a1338 1

a1340 4
		CFGPRINTF("%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State "
		    "0x%x topology '%s'\n", isp->isp_name, fcp->isp_loopid,
		    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate,
		    toponames[fcp->isp_topo]);
d1343 1
a1343 1
		 * Make sure we're logged out of all fabric devices.
d1345 27
a1371 12
		for (count = FC_SNS_ID+1; count < MAX_FC_TARG; count++) {
			struct lportdb *lp = &fcp->portdb[count];
			if (lp->valid == 0 || lp->fabdev == 0)
				continue;
			PRINTF("%s: logging out target %d at Loop ID %d "
			    "(port id 0x%x)\n", isp->isp_name, count,
			    lp->loopid, lp->portid);
			mbs.param[0] = MBOX_FABRIC_LOGOUT;
			mbs.param[1] = lp->loopid << 8;
			mbs.param[2] = 0;
			mbs.param[3] = 0;
			isp_mboxcmd(isp, &mbs);
d1373 1
d1376 12
a1387 2
	CFGPRINTF("%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology '%s'\n",
	    isp->isp_name, fcp->isp_loopid, fcp->isp_alpa, fcp->isp_loopstate,
d1389 1
d1407 1
a1407 1
	    a->loopid != b->loopid) {
d1427 1
a1427 1
	int loopid, lim;
d1442 13
d1469 2
a1470 1
	for (lim = loopid = 0; loopid < FL_PORT_ID; loopid++) {
d1473 2
d1478 2
d1489 2
d1494 3
a1501 2
			IDPRINTF(1, ("%s: wankage (%d != %d)\n",
			    isp->isp_name, pdb.pdb_loopid, loopid));
d1567 1
a1567 1
	for (loopid = 0; loopid < FL_PORT_ID; loopid++) {
d1620 1
a1620 4
			/*
			 * XXX: Should we also propagate roles in case they
			 * XXX: changed?
			 */
d1695 1
a1695 1
	for (lp = fcp->portdb; lp < &fcp->portdb[FL_PORT_ID]; lp++) {
d1711 1
a1711 1
	for (lim = FC_SNS_ID+1, lp = &fcp->portdb[FC_SNS_ID+1];
d1717 1
a1717 1
		 * Nothing here?
d1728 42
d1773 1
a1773 1
		if (lp->valid) {
d1779 4
a1782 1
			lp->valid = 0;
a1789 1
		lim = 0;
d1793 2
a1798 2
			mbs.param[2] = portid >> 16;
			mbs.param[3] = portid & 0xffff;
d1810 2
a1811 1
				 * Snaffle the loop id it's using.
d1813 10
a1822 2
				if ((loopid = mbs.param[1]) == 0) {
					lim = -1;
d1826 1
a1827 1
				lim = 1;
d1830 3
a1832 2
				PRINTF("%s: command error in PLOGI (0x%x)\n",
				    isp->isp_name, mbs.param[1]);
d1836 1
a1836 1
				lim = -1;
d1839 8
a1846 2
		} while (lim == 0 && loopid < MAX_FC_TARG);
		if (lim < 0)
d1848 1
d1850 3
a1852 2
		lp->valid = 1;
		lp->fabdev = 1;
d1854 3
a1856 7
			/*
			 * Be kind...
			 */
			lp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);
			PRINTF("%s: Faked PortID 0x%x into LoopID %d\n",
			    isp->isp_name, lp->portid, lp->loopid);
			continue;
d1858 1
d1860 11
a1870 4
			lp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);
			PRINTF("%s: Wanked PortID 0x%x to LoopID %d\n",
			    isp->isp_name, lp->portid, lp->loopid);
			continue;
d1872 1
a1874 1
		lp->portid = BITS2WORD(pdb.pdb_portid_bits);
d1897 1
d1902 4
a1905 3
		lp->fabdev = lp->valid = 0;
		PRINTF("%s: Target %d (Loop 0x%x) Port ID 0x%x lost its WWN\n",
		    isp->isp_name, loopid, lp->loopid, lp->portid);
d2139 1
a2139 1
		IDPRINTF(1, ("%s: Request Queue Overflow\n", isp->isp_name));
d2168 1
a2168 1
				IDPRINTF(1, ("%s: Request Queue Overflow+\n",
d2219 4
a2222 5
#ifdef	ISP2100_SCCLUN
		t2reqp->req_scclun = XS_LUN(xs);
#else
		t2reqp->req_lun_trn = XS_LUN(xs);
#endif
d2338 1
d2348 8
a2355 8
#ifdef	ISP2100_SCCLUN
			mbs.param[1] = XS_TGT(xs) << 8;
			mbs.param[4] = 0;
			mbs.param[5] = 0;
			mbs.param[6] = XS_LUN(xs);
#else
			mbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);
#endif
d2363 11
a2373 3
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			PRINTF("%s: isp_control MBOX_ABORT failure (code %x)\n",
			    isp->isp_name, mbs.param[0]);
a2375 2
		PRINTF("%s: command for target %d lun %d was aborted\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2383 4
a2386 1
		return (isp_fclink_test(isp, FC_FW_READY_DELAY));
d2389 4
a2392 1
		return (isp_pdb_sync(isp, -1));
d2427 1
a2427 2
	u_int16_t iptr, optr;
	u_int16_t isr, isrb, sema;
d2430 20
a2449 5
	/*
	 * Well, if we've disabled interrupts, we may get a case where
	 * isr isn't set, but sema is. In any case, debounce isr reads.
	 */
	do {
d2451 2
a2452 3
		isrb = ISP_READ(isp, BIU_ISR);
	} while (isr != isrb);
	sema = ISP_READ(isp, BIU_SEMA) & 0x1;
d2454 3
a2456 5
	if (isr == 0) {
		return (0);
	}
	if (!INT_PENDING(isp, isr)) {
		IDPRINTF(4, ("%s: isp_intr isr=%x\n", isp->isp_name, isr));
a2458 9
	if (isp->isp_state != ISP_RUNSTATE) {
		IDPRINTF(3, ("%s: interrupt (isr=%x,sema=%x) when not ready\n",
		    isp->isp_name, isr, sema));
		ISP_WRITE(isp, INMAILBOX5, ISP_READ(isp, OUTMAILBOX5));
		ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
		ISP_WRITE(isp, BIU_SEMA, 0);
		ENABLE_INTS(isp);
		return (1);
	}
d2461 18
a2478 1
		u_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);
d2480 15
a2494 2
			IDPRINTF(4, ("%s: Command Mbox 0x%x\n",
			    isp->isp_name, mbox));
d2503 15
a2518 2
		ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
		ENABLE_INTS(isp);
d2526 21
a2546 1
	iptr = ISP_READ(isp, OUTMAILBOX5);
d2548 13
a2560 3
	if (optr == iptr) {
		IDPRINTF(4, ("why intr? isr %x iptr %x optr %x\n",
		    isr, optr, iptr));
d2675 3
a2677 2
				IDPRINTF(1, ("%s: check condition with no sense"
				    " data\n", isp->isp_name));
a2718 18
		/*
		 * Let the platforms cope.
		 */
#if	0
		/*
		 * XXX: If we have a check condition, but no Sense Data,
		 * XXX: mark it as an error (ARQ failed). We need to
		 * XXX: to do a more distinct job because there may
		 * XXX: cases where ARQ is disabled.
		 */
		if (XS_STS(xs) == SCSI_CHECK && !(XS_IS_SNS_VALID(xs))) {
			if (XS_NOERR(xs)) {
				PRINTF("%s: ARQ failure for target %d lun %d\n",
				    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
				XS_SETERR(xs, HBA_ARQFAIL);
			}
		}
#endif
d2747 1
a2754 1
	ENABLE_INTS(isp);
d2944 1
a2944 1
		IDPRINTF(2, ("%s: Port Database Changed\n", isp->isp_name));
d2957 11
d3222 1
a3222 1
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3326 228
a3553 119
#define	HINIB(x)			((x) >> 0x4)
#define	LONIB(x)			((x)  & 0xf)
#define	MAKNIB(a, b)			(((a) << 4) | (b))
static u_int8_t mbpcnt[] = {
	MAKNIB(1, 1),	/* 0x00: MBOX_NO_OP */
	MAKNIB(5, 5),	/* 0x01: MBOX_LOAD_RAM */
	MAKNIB(2, 0),	/* 0x02: MBOX_EXEC_FIRMWARE */
	MAKNIB(5, 5),	/* 0x03: MBOX_DUMP_RAM */
	MAKNIB(3, 3),	/* 0x04: MBOX_WRITE_RAM_WORD */
	MAKNIB(2, 3),	/* 0x05: MBOX_READ_RAM_WORD */
	MAKNIB(6, 6),	/* 0x06: MBOX_MAILBOX_REG_TEST */
	MAKNIB(2, 3),	/* 0x07: MBOX_VERIFY_CHECKSUM	*/
	MAKNIB(1, 4),	/* 0x08: MBOX_ABOUT_FIRMWARE */
	MAKNIB(0, 0),	/* 0x09: */
	MAKNIB(0, 0),	/* 0x0a: */
	MAKNIB(0, 0),	/* 0x0b: */
	MAKNIB(0, 0),	/* 0x0c: */
	MAKNIB(0, 0),	/* 0x0d: */
	MAKNIB(1, 2),	/* 0x0e: MBOX_CHECK_FIRMWARE */
	MAKNIB(0, 0),	/* 0x0f: */
	MAKNIB(5, 5),	/* 0x10: MBOX_INIT_REQ_QUEUE */
	MAKNIB(6, 6),	/* 0x11: MBOX_INIT_RES_QUEUE */
	MAKNIB(4, 4),	/* 0x12: MBOX_EXECUTE_IOCB */
	MAKNIB(2, 2),	/* 0x13: MBOX_WAKE_UP	*/
	MAKNIB(1, 6),	/* 0x14: MBOX_STOP_FIRMWARE */
	MAKNIB(4, 4),	/* 0x15: MBOX_ABORT */
	MAKNIB(2, 2),	/* 0x16: MBOX_ABORT_DEVICE */
	MAKNIB(3, 3),	/* 0x17: MBOX_ABORT_TARGET */
	MAKNIB(3, 1),	/* 0x18: MBOX_BUS_RESET */
	MAKNIB(2, 3),	/* 0x19: MBOX_STOP_QUEUE */
	MAKNIB(2, 3),	/* 0x1a: MBOX_START_QUEUE */
	MAKNIB(2, 3),	/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
	MAKNIB(2, 3),	/* 0x1c: MBOX_ABORT_QUEUE */
	MAKNIB(2, 4),	/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
	MAKNIB(0, 0),	/* 0x1e: */
	MAKNIB(1, 3),	/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
	MAKNIB(1, 4),	/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */
	MAKNIB(1, 3),	/* 0x21: MBOX_GET_SELECT_TIMEOUT */
	MAKNIB(1, 3),	/* 0x22: MBOX_GET_RETRY_COUNT	*/
	MAKNIB(1, 2),	/* 0x23: MBOX_GET_TAG_AGE_LIMIT */
	MAKNIB(1, 2),	/* 0x24: MBOX_GET_CLOCK_RATE */
	MAKNIB(1, 2),	/* 0x25: MBOX_GET_ACT_NEG_STATE */
	MAKNIB(1, 2),	/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */
	MAKNIB(1, 3),	/* 0x27: MBOX_GET_PCI_PARAMS */
	MAKNIB(2, 4),	/* 0x28: MBOX_GET_TARGET_PARAMS */
	MAKNIB(2, 4),	/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */
	MAKNIB(1, 2),	/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */
	MAKNIB(0, 0),	/* 0x2b: */
	MAKNIB(0, 0),	/* 0x2c: */
	MAKNIB(0, 0),	/* 0x2d: */
	MAKNIB(0, 0),	/* 0x2e: */
	MAKNIB(0, 0),	/* 0x2f: */
	MAKNIB(2, 2),	/* 0x30: MBOX_SET_INIT_SCSI_ID */
	MAKNIB(2, 3),	/* 0x31: MBOX_SET_SELECT_TIMEOUT */
	MAKNIB(3, 3),	/* 0x32: MBOX_SET_RETRY_COUNT	*/
	MAKNIB(2, 2),	/* 0x33: MBOX_SET_TAG_AGE_LIMIT */
	MAKNIB(2, 2),	/* 0x34: MBOX_SET_CLOCK_RATE */
	MAKNIB(2, 2),	/* 0x35: MBOX_SET_ACT_NEG_STATE */
	MAKNIB(2, 2),	/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */
	MAKNIB(3, 3),	/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */
	MAKNIB(4, 4),	/* 0x38: MBOX_SET_TARGET_PARAMS */
	MAKNIB(4, 4),	/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */
	MAKNIB(1, 2),	/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */
	MAKNIB(0, 0),	/* 0x3b: */
	MAKNIB(0, 0),	/* 0x3c: */
	MAKNIB(0, 0),	/* 0x3d: */
	MAKNIB(0, 0),	/* 0x3e: */
	MAKNIB(0, 0),	/* 0x3f: */
	MAKNIB(1, 2),	/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */
	MAKNIB(6, 1),	/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */
	MAKNIB(2, 3),	/* 0x42: MBOX_EXEC_BIOS_IOCB */
	MAKNIB(0, 0),	/* 0x43: */
	MAKNIB(0, 0),	/* 0x44: */
	MAKNIB(0, 0),	/* 0x45: */
	MAKNIB(0, 0),	/* 0x46: */
	MAKNIB(0, 0),	/* 0x47: */
	MAKNIB(0, 0),	/* 0x48: */
	MAKNIB(0, 0),	/* 0x49: */
	MAKNIB(2, 1),	/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */
	MAKNIB(1, 2),	/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */
	MAKNIB(0, 0),	/* 0x4c: */
	MAKNIB(0, 0),	/* 0x4d: */
	MAKNIB(0, 0),	/* 0x4e: */
	MAKNIB(0, 0),	/* 0x4f: */
	MAKNIB(0, 0),	/* 0x50: */
	MAKNIB(0, 0),	/* 0x51: */
	MAKNIB(0, 0),	/* 0x52: */
	MAKNIB(0, 0),	/* 0x53: */
	MAKNIB(8, 0),	/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */
	MAKNIB(2, 1),	/* 0x55: MBOX_ENABLE_TARGET_MODE */
	MAKNIB(0, 0),	/* 0x56: */
	MAKNIB(0, 0),	/* 0x57: */
	MAKNIB(0, 0),	/* 0x58: */
	MAKNIB(0, 0),	/* 0x59: */
	MAKNIB(0, 0),	/* 0x5a: */
	MAKNIB(0, 0),	/* 0x5b: */
	MAKNIB(0, 0),	/* 0x5c: */
	MAKNIB(0, 0),	/* 0x5d: */
	MAKNIB(0, 0),	/* 0x5e: */
	MAKNIB(0, 0),	/* 0x5f: */
	MAKNIB(8, 6),	/* 0x60: MBOX_INIT_FIRMWARE */
	MAKNIB(0, 0),	/* 0x61: */
	MAKNIB(2, 1),	/* 0x62: MBOX_INIT_LIP */
	MAKNIB(8, 1),	/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */
	MAKNIB(8, 1),	/* 0x64: MBOX_GET_PORT_DB */
	MAKNIB(3, 1),	/* 0x65: MBOX_CLEAR_ACA */
	MAKNIB(3, 1),	/* 0x66: MBOX_TARGET_RESET */
	MAKNIB(3, 1),	/* 0x67: MBOX_CLEAR_TASK_SET */
	MAKNIB(3, 1),	/* 0x68: MBOX_ABORT_TASK_SET */
	MAKNIB(1, 2),	/* 0x69: MBOX_GET_FW_STATE */
	MAKNIB(2, 8),	/* 0x6a: MBOX_GET_PORT_NAME */
	MAKNIB(8, 1),	/* 0x6b: MBOX_GET_LINK_STATUS */
	MAKNIB(4, 4),	/* 0x6c: MBOX_INIT_LIP_RESET */
	MAKNIB(0, 0),	/* 0x6d: */
	MAKNIB(8, 2),	/* 0x6e: MBOX_SEND_SNS */
	MAKNIB(4, 3),	/* 0x6f: MBOX_FABRIC_LOGIN */
	MAKNIB(2, 1),	/* 0x70: MBOX_SEND_CHANGE_REQUEST */
	MAKNIB(2, 1),	/* 0x71: MBOX_FABRIC_LOGOUT */
	MAKNIB(4, 1)	/* 0x72: MBOX_INIT_LIP_LOGIN */
a3554 1
#define	NMBCOM	(sizeof (mbpcnt) / sizeof (mbpcnt[0]))
d3561 9
a3569 12
	int outparam, inparam;
	int loops, dld = 0;
	u_int8_t opcode;

	if (mbp->param[0] == ISP2100_SET_PCI_PARAM) {
		opcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;
		inparam = 4;
		outparam = 4;
		goto command_known;
	} else if (mbp->param[0] > NMBCOM) {
		PRINTF("%s: bad command %x\n", isp->isp_name, mbp->param[0]);
		return;
d3572 3
a3574 7
	opcode = mbp->param[0];
	inparam = HINIB(mbpcnt[mbp->param[0]]);
	outparam =  LONIB(mbpcnt[mbp->param[0]]);

	if (inparam == 0 && outparam == 0) {
		PRINTF("%s: no parameters for %x\n", isp->isp_name,
			mbp->param[0]);
d3578 2
d3581 5
a3585 92
	/*
	 * Check for variants
	 */
#ifdef	ISP2100_SCCLUN
	if (IS_FC(isp)) {
		switch (mbp->param[0]) {
		case MBOX_ABORT:
			inparam = 7;
			break;
		case MBOX_ABORT_DEVICE:
		case MBOX_START_QUEUE:
		case MBOX_STOP_QUEUE:
		case MBOX_SINGLE_STEP_QUEUE:
		case MBOX_ABORT_QUEUE:
		case MBOX_GET_DEV_QUEUE_STATUS:
			inparam = 3;
			break;
		case MBOX_BUS_RESET:
			inparam = 2;
			break;
		default:
			break;
		}
	}
#endif

command_known:

	/*
	 * Set semaphore on mailbox registers to win any races to acquire them.
	 */
	ISP_WRITE(isp, BIU_SEMA, 1);

	/*
	 * Qlogic Errata for the ISP2100 says that there is a necessary
	 * debounce between between writing the semaphore register
	 * and reading a mailbox register. I believe we're okay here.
	 */

	/*
	 * Make sure we can send some words.
	 * Check to see if there's an async mbox event pending.
	 */

	loops = MBOX_DELAY_COUNT;
	while ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {
		if (ISP_READ(isp, BIU_SEMA) & 1) {
			int fph;
			u_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);
			/*
			 * We have a pending MBOX async event.
			 */
			if (mbox & 0x8000) {
				fph = isp_parse_async(isp, (int) mbox);
				IDPRINTF(5, ("%s: line %d, fph %d\n",
				    isp->isp_name, __LINE__, fph));
				ISP_WRITE(isp, BIU_SEMA, 0);
				ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
				if (fph < 0) {
					return;
				} else if (fph > 0) {
					isp_fastpost_complete(isp, fph);
				}
				SYS_DELAY(100);
				goto command_known;
			}
			/*
			 * We have a pending MBOX completion? Might be
			 * from a previous command. We can't (sometimes)
			 * just clear HOST INTERRUPT, so we'll just silently
			 * eat this here.
			 */
			if (mbox & 0x4000) {
				IDPRINTF(5, ("%s: line %d, mbox 0x%x\n",
				    isp->isp_name, __LINE__, mbox));
				ISP_WRITE(isp, BIU_SEMA, 0);
				ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
				SYS_DELAY(100);
				goto command_known;
			}
		}
		SYS_DELAY(100);
		if (--loops < 0) {
			if (dld++ > 10) {
				PRINTF("%s: isp_mboxcmd could not get command "
				    "started\n", isp->isp_name);
				return;
			}
			ISP_WRITE(isp, BIU_SEMA, 0);
			ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
			goto command_known;
		}
d3588 3
a3590 23
	/*
	 * Write input parameters.
	 *
	 * Special case some of the setups for the dual port SCSI cards.
	 * XXX Eventually will be fixed by converting register write/read
	 * XXX counts to bitmasks.
	 */
	if (IS_DUALBUS(isp)) {
		switch (opcode) {
		case MBOX_GET_RETRY_COUNT:
		case MBOX_SET_RETRY_COUNT:
			ISP_WRITE(isp, INMAILBOX7, mbp->param[7]);
			mbp->param[7] = 0;
			ISP_WRITE(isp, INMAILBOX6, mbp->param[6]);
			mbp->param[6] = 0;
			break;
		case MBOX_SET_ASYNC_DATA_SETUP_TIME:
		case MBOX_SET_ACT_NEG_STATE:
		case MBOX_SET_TAG_AGE_LIMIT:
		case MBOX_SET_SELECT_TIMEOUT:
			ISP_WRITE(isp, INMAILBOX2, mbp->param[2]);
			mbp->param[2] = 0;
			break;
d3592 1
a3592 21
	}

	switch (inparam) {
	case 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;
	case 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;
	case 6:
		/*
		 * The Qlogic 2100 cannot have registers 4 and 5 written to
		 * after initialization or BAD THINGS HAPPEN (tm).
		 */
		if (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)
			ISP_WRITE(isp, INMAILBOX5, mbp->param[5]);
		mbp->param[5] = 0;
	case 5:
		if (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)
			ISP_WRITE(isp, INMAILBOX4, mbp->param[4]);
		mbp->param[4] = 0;
	case 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;
	case 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;
	case 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;
	case 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;
d3596 1
a3596 1
	 * Clear RISC int condition.
d3598 1
a3598 7
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);

	/*
	 * Clear semaphore on mailbox registers so that the Qlogic
	 * may update outgoing registers.
	 */
	ISP_WRITE(isp, BIU_SEMA, 0);
d3606 1
a3606 2
	 * Wait until HOST INT has gone away (meaning that the Qlogic
	 * has picked up the mailbox command. Wait a long time.
d3608 1
a3608 8
	loops = MBOX_DELAY_COUNT * 5;
	while ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {
		SYS_DELAY(100);
		if (--loops < 0) {
			PRINTF("%s: isp_mboxcmd timeout #2\n", isp->isp_name);
			return;
		}
	}
a3609 18
	/*
	 * While the Semaphore registers isn't set, wait for the Qlogic
	 * to process the mailbox command. Again- wait a long time.
	 */
	loops = MBOX_DELAY_COUNT * 5;
	while ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {
		SYS_DELAY(100);
		/*
		 * Wierd- I've seen the case where the semaphore register
		 * isn't getting set- sort of a violation of the protocol..
		 */
		if (ISP_READ(isp, OUTMAILBOX0) & 0x4000)
			break;
		if (--loops < 0) {
			PRINTF("%s: isp_mboxcmd timeout #3\n", isp->isp_name);
			return;
		}
	}
d3612 1
a3612 1
	 * Make sure that the MBOX_BUSY has gone away
d3614 1
a3614 29
	loops = MBOX_DELAY_COUNT;
	for (;;) {
		u_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);
		if (mbox == MBOX_BUSY) {
			if (--loops < 0) {
				PRINTF("%s: isp_mboxcmd timeout #4\n",
				    isp->isp_name);
				return;
			}
			SYS_DELAY(100);
			continue;
		}
		/*
		 * We have a pending MBOX async event.
		 */
		if (mbox & 0x8000) {
			int fph = isp_parse_async(isp, (int) mbox);
			ISP_WRITE(isp, BIU_SEMA, 0);
			ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
			if (fph < 0) {
				return;
			} else if (fph > 0) {
				isp_fastpost_complete(isp, fph);
			}
			SYS_DELAY(100);
			continue;
		}
		break;
	}
d3617 1
a3617 2
	 * Pick up output parameters. Special case some of the readbacks
	 * for the dual port SCSI cards.
d3619 3
a3621 23
	if (IS_DUALBUS(isp)) {
		switch (opcode) {
		case MBOX_GET_RETRY_COUNT:
		case MBOX_SET_RETRY_COUNT:
			mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);
			mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);
			break;
		case MBOX_GET_TAG_AGE_LIMIT:
		case MBOX_SET_TAG_AGE_LIMIT:
		case MBOX_GET_ACT_NEG_STATE:
		case MBOX_SET_ACT_NEG_STATE:
		case MBOX_SET_ASYNC_DATA_SETUP_TIME:
		case MBOX_GET_ASYNC_DATA_SETUP_TIME:
		case MBOX_GET_RESET_DELAY_PARAMS:
		case MBOX_SET_RESET_DELAY_PARAMS:
			mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);
			break;
		}
	}

	if (IS_2200(isp)) {
		if (opcode == MBOX_GET_LOOP_ID) {
			mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);
a3624 21
	switch (outparam) {
	case 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);
	case 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);
	case 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);
	case 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);
	case 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);
	case 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);
	case 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);
	case 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);
	}

	/*
	 * Clear RISC int.
	 */
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);

	/*
	 * Release semaphore on mailbox registers
	 */
	ISP_WRITE(isp, BIU_SEMA, 0);

a3664 24

	/*
	 * Be silent about these...
	 */
	case ASYNC_PDB_CHANGED:
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;
		break;

	case ASYNC_LIP_OCCURRED:
		((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];
		/* FALLTHROUGH */
	case ASYNC_LOOP_UP:
		((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;
		break;

	case ASYNC_LOOP_DOWN:
	case ASYNC_LOOP_RESET:
		((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;
		((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;
		/* FALLTHROUGH */
	case ASYNC_CHANGE_NOTIFY:
		break;

d3837 1
a3837 1
			IDPRINTF(1, ("%s: skipping target %d bus %d update\n",
d3936 7
a3942 1
		fcp->isp_portwwn = 0;
d3948 5
a3952 3
			PRINTF("%s: using Node WWN 0x%08x%08x\n",
			    isp->isp_name, (u_int32_t)(fcp->isp_nodewwn >> 32),
			    (u_int32_t)(fcp->isp_nodewwn & 0xffffffff));
d4025 2
a4026 1
		    (isp->isp_clock && isp->isp_clock < 60)) {
a4134 3
#if	0
	isp->isp_gotdparms = 0;
#endif
a4732 2
	wwnstore.full64 = ISP2100_NVRAM_NODE_NAME(nvram_data);

d4734 3
a4736 1
	 * Broken PTI cards with nothing in the top nibble. Pah.
d4738 24
a4761 7
	if ((wwnstore.wd.hi32 >> 28) == 0) {
		wwnstore.wd.hi32 |= (2 << 28);
		CFGPRINTF("%s: (corrected) Adapter WWN 0x%08x%08x\n",
		    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);
	} else {
		CFGPRINTF("%s: Adapter WWN 0x%08x%08x\n", isp->isp_name,
		    wwnstore.wd.hi32, wwnstore.wd.lo32);
d4763 5
a4767 1
	fcp->isp_nodewwn = wwnstore.full64;
a4768 18
	/*
	 * If the Node WWN has 2 in the top nibble, we can
	 * authoritatively construct a Port WWN by adding
	 * our unit number (plus one to make it nonzero) and
	 * putting it into bits 59..56. If the top nibble isn't
	 * 2, then we just set them identically.
	 */
	if ((fcp->isp_nodewwn >> 60) == 2) {
		fcp->isp_portwwn = fcp->isp_nodewwn |
		    (((u_int64_t)(isp->isp_unit+1)) << 56);
	} else {
		fcp->isp_portwwn = fcp->isp_nodewwn;
	}
	wwnstore.full64 = ISP2100_NVRAM_BOOT_NODE_NAME(nvram_data);
	if (wwnstore.full64 != 0) {
		PRINTF("%s: BOOT DEVICE WWN 0x%08x%08x\n",
		    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);
	}
@


1.14
log
@Clean up some error messages so that the channel source is printed. Don't
wipe out the whole marker flag when a bus event happens on one channel- just
or in the channel that needs to have a marker sent. Correctly mark a
PORT CHANGED error with a 'selection timeout'.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.13 2000/02/20 21:22:40 mjacob Exp $ */
d1259 1
a1259 1
	int count, topo = -1;
d1303 4
a1306 3
		topo = (int) mbs.param[6];
		if (topo < 0 || topo > 3)
			topo = 0;
d1308 1
a1308 1
		topo = 0;
d1321 1
a1321 1
			topo = 1;
d1328 1
a1328 1
		    toponames[topo]);
d1350 1
a1350 1
	    toponames[topo]);
d1909 18
a1926 7
		if (target >= FL_PORT_ID) {
			/*
			 * If we're not on a Fabric, we can't have a target
			 * above FL_PORT_ID-1. If we're on a fabric, we
			 * can't have a target less than FC_SNS_ID+1.
			 */
			if (fcp->isp_onfabric == 0 || target <= FC_SNS_ID) {
d2185 1
a2185 1
		isp->isp_sendmarker = 1 << bus;
d2209 1
a2209 1
		isp->isp_sendmarker = 1 << bus;
d2585 1
a2585 1
		isp->isp_sendmarker = (1 << bus);
d2619 1
a2619 1
		isp->isp_sendmarker = (1 << bus);
d2627 1
a2627 1
		isp->isp_sendmarker = 1 << bus;
d2684 1
a2684 1
		isp->isp_sendmarker = (1 << bus);
d2735 1
a2735 1
		isp->isp_sendmarker = 1 << bus;
@


1.13
log
@Add 12160 (Ultra3) support. Add files and changes for target mode support.
Do some SNS fabric suppor tchanges. Roll revision levels. Tested on
GENERIC i386 && sparc.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.12 2000/01/09 22:44:27 mjacob Exp $ */
d2836 3
a2838 2
			IDPRINTF(3, ("%s: Selection Timeout for target %d\n",
			    isp->isp_name, XS_TGT(xs)));
d2842 2
a2843 2
		PRINTF("%s: command incomplete for target %d lun %d, state "
		    "0x%x\n", isp->isp_name, XS_TGT(xs), XS_LUN(xs),
d2848 2
a2849 2
		PRINTF("%s: DMA error for command on target %d, lun %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2853 2
a2854 1
		PRINTF("%s: transport error\n", isp->isp_name);
d2859 3
a2861 7
		IDPRINTF(2, ("%s: bus %d reset destroyed command for target %d "
		    "lun %d\n", isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs),
		    XS_LUN(xs)));
		/*
		 * XXX: Get port number for bus
		 */
		isp->isp_sendmarker = 3;
d2866 3
a2868 6
		PRINTF("%s: command aborted for target %d lun %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
		/*
		 * XXX: Get port number for bus
		 */
		isp->isp_sendmarker = 3;
d2873 2
a2874 2
		IDPRINTF(2, ("%s: command timed out for target %d lun %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs)));
d2883 2
d2889 2
a2890 2
		PRINTF("%s: command overrun for command on target %d, lun %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2894 2
a2895 2
		PRINTF("%s: status overrun for command on target %d, lun %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2899 2
a2900 3
		PRINTF("%s: message not COMMAND COMPLETE after status on "
		    "target %d, lun %d\n", isp->isp_name, XS_TGT(xs),
		    XS_LUN(xs));
d2904 2
a2905 3
		PRINTF("%s: No MESSAGE OUT phase after selection on "
		    "target %d, lun %d\n", isp->isp_name, XS_TGT(xs),
		    XS_LUN(xs));
d2909 2
a2910 2
		PRINTF("%s: EXTENDED IDENTIFY failed on target %d, lun %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2914 2
a2915 2
		PRINTF("%s: target %d lun %d rejected INITIATOR DETECTED "
		    "ERROR message\n", isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2919 2
a2920 2
		PRINTF("%s: target %d lun %d rejected ABORT message\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2924 2
a2925 2
		PRINTF("%s: target %d lun %d rejected MESSAGE REJECT message\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2929 2
a2930 2
		PRINTF("%s: target %d lun %d rejected NOP message\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2934 2
a2935 2
		PRINTF("%s: target %d lun %d rejected MESSAGE PARITY ERROR "
		    "message\n", isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2939 2
a2940 2
		PRINTF("%s: target %d lun %d rejected BUS DEVICE RESET "
		    "message\n", isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2944 2
a2945 2
		PRINTF("%s: target %d lun %d rejected IDENTIFY "
		    "message\n", isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d2949 2
a2950 2
		PRINTF("%s: target %d lun %d had an unexpected bus free\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
a2955 1
			/* an UNDERRUN is not a botch ??? */
d2962 2
a2963 2
		    "not set for target %d lun %d\n", isp->isp_name, XS_TGT(xs),
		    XS_LUN(xs));
d2968 2
a2969 2
		    "routine %d on target %d\n", isp->isp_name, XS_LUN(xs),
		    XS_TGT(xs));
d2974 2
a2975 2
		    "%d when queueing disabled\n", isp->isp_name, XS_TGT(xs),
		    XS_LUN(xs));
d2984 2
a2985 2
		    "status 0x%x\n", isp->isp_name, XS_TGT(xs), XS_LUN(xs),
		    XS_STS(xs)));
d2998 2
a2999 2
		    "STATUS phase) for target %d lun %d\n", isp->isp_name,
		    XS_TGT(xs), XS_LUN(xs));
d3003 2
a3004 3
		PRINTF("%s: Auto Request Sense failed for target %d lun %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
		XS_SETERR(xs, HBA_ARQFAIL);
d3008 2
a3009 2
		PRINTF("%s: Wide Negotiation failed for target %d lun %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d3015 1
a3015 1
			isp->isp_update = XS_CHANNEL(xs)+1;
d3021 2
a3022 2
		PRINTF("%s: SDTR Message failed for target %d lun %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d3028 1
a3028 1
			isp->isp_update = XS_CHANNEL(xs)+1;
d3033 2
a3034 2
		PRINTF("%s: Bad LVD Bus condition while talking to target %d "
		    "lun %d\n", isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d3057 3
a3059 2
			isp->isp_name, XS_TGT(xs));
		break;
d3063 1
a3063 1
			isp->isp_name, XS_TGT(xs));
d3068 2
a3069 2
		PRINTF("%s: comp status %x\n", isp->isp_name,
		    sp->req_completion_status);
@


1.12
log
@Crank up the debug levels for a couple of ISPDEBUG lines
so that a SCSIDEBUG kernel doesn't completely overrun the
console.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.11 1999/12/20 05:36:06 mjacob Exp $ */
d98 5
d196 9
a204 1
		revname = "1080";
d225 1
a225 1
		if (IS_1280(isp)) {
a226 1
			revname[1] = '2';
d808 2
a809 3
	 * Ultra and older (i.e., SBus) cards may not. Assume SBus cards
	 * do not, and only guess that 4.55.0 <= x < 5.0.0 (initiator
	 * only) and x >= 7.55 (initiator/target) has fast posting.
d816 1
a816 4
#ifndef	ISP_NO_FASTPOST_SCSI
	if ((ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(4, 55, 0) &&
	    (ISP_FW_REVX(isp->isp_fwrev) < ISP_FW_REV(5, 0, 0))) ||
	    (ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(7, 55, 0))) {
a817 2
	}
#endif
a1015 1

d1067 13
a1079 1
	icbp->icb_logintime = 30;	/* 30 second login timeout */
a1257 1
	char *tname;
d1302 6
a1307 8
	if (isp->isp_type == ISP_HA_FC_2200) {
		if (ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(2, 0, 14)) {
			topo = (int) mbs.param[6];
		}
	} else if (isp->isp_type == ISP_HA_FC_2100) {
		if (ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(1, 17, 26)) {
			topo = (int) mbs.param[6];
		}
a1308 4
	if (topo < 0 || topo > 3)
		tname = "unknown";
	else
		tname = toponames[topo];
d1318 4
d1325 3
a1327 2
		    "0x%x topology %s\n", isp->isp_name, fcp->isp_loopid,
		    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate, tname);
d1347 1
a1347 1
	CFGPRINTF("%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology %s\n",
d1349 1
a1349 2
	    tname);
	fcp->loop_seen_once = 1;
d1411 1
d1484 1
a1484 1
		if (isp_same_lportdb(lp, &fcp->portdb[target])) {
d1653 1
a1653 1
	for (lp = &fcp->portdb[FC_SNS_ID+1];
d1655 1
d1663 1
d1667 1
a1667 1
		if (lp->portid == fcp->isp_portid)
d1671 1
a1671 1
		 * Force a logout.
d1673 8
a1680 6
		lp->loopid = loopid = lp - fcp->portdb;
		mbs.param[0] = MBOX_FABRIC_LOGOUT;
		mbs.param[1] = lp->loopid << 8;
		mbs.param[2] = 0;
		mbs.param[3] = 0;
		isp_mboxcmd(isp, &mbs);
d1685 19
a1703 12
		mbs.param[0] = MBOX_FABRIC_LOGIN;
		mbs.param[1] = lp->loopid << 8;
		mbs.param[2] = lp->portid >> 16;
		mbs.param[3] = lp->portid & 0xffff;
		isp_mboxcmd(isp, &mbs);
		switch (mbs.param[0]) {
		case  MBOX_COMMAND_COMPLETE:
			break;
		case MBOX_COMMAND_ERROR:
			switch (mbs.param[1]) {
			case	1:
				PRINTF("%s: no loop\n", isp->isp_name);
d1705 12
a1716 17
			case	2:
				PRINTF("%s: IOCB buffer could not be alloced\n",
				    isp->isp_name);
				break;
			case	3:
				PRINTF("%s: could not alloc xchange resource\n",
				    isp->isp_name);
				break;
			case	4:
				PRINTF("%s: ELS timeout\n", isp->isp_name);
				break;
			case	5:
				PRINTF("%s: no fabric port\n", isp->isp_name);
				break;
			case	6:
				PRINTF("%s: remote device cannot be a target\n",
				    isp->isp_name);
d1718 5
d1724 1
d1727 2
a1729 3
		default:
			continue;
		}
d1733 1
a1733 1
		if (isp_getpdb(isp, loopid, &pdb) != 0) {
a1750 1
		lp->loopid = loopid;
d1773 1
d1787 6
d1833 2
d1886 4
a1889 2
	 * We *could* do the different sequence type that has close
	 * to the whole Queue Entry for the command...
d1892 1
a1892 1
	if (XS_CDBLEN(xs) > (IS_FC(isp) ? 16 : 12) || XS_CDBLEN(xs) == 0) {
d1894 1
a1894 1
		    isp->isp_name, XS_CDBLEN(xs), XS_CDBP(xs)[0]);
d1947 3
a1949 1
		 * sending commands for a little while.
d1953 5
a1957 1
			return (CMD_RQLATER);
d2044 4
a2047 1
		reqp->req_header.rqs_entry_type = RQSTYPE_REQUEST;
d2160 1
d2167 2
a2168 1
			mbs.param[2] = bus;
a2170 1
			mbs.param[2] = 0;
d2223 2
a2224 2
		mbs.param[2] = handle >> 16;
		mbs.param[3] = handle & 0xffff;
d2241 4
d2246 14
a2259 5
	case ISPCTL_ENABLE_LUN:
		return (isp_modify_lun, 1, arg));

	case ISPCTL_MODIFY_LUN:
		return (isp_modify_lun, 0, arg));
d2351 2
a2352 1
		 * written into memory so it makes sense to us.
a2356 1
				ISP_WRITE(isp, INMAILBOX5, optr);
a2364 1
				ISP_WRITE(isp, INMAILBOX5, optr);
d2445 3
a2447 1
			if (XS_STS(xs) == SCSI_CHECK) {
a2448 2
				MEMCPY(XS_SNSP(xs), sp->req_sense_data,
					XS_SNSLEN(xs));
d2450 3
d2495 4
d2511 1
d2575 1
a2575 1
		isp_target_async(isp, bus, ASYNC_BUS_RESET);
d2609 1
a2609 1
		isp_target_async(isp, bus, ASYNC_TIMEOUT_RESET);
d2617 1
a2617 1
		isp_target_async(isp, bus, ASYNC_DEVICE_RESET);
d2695 3
d2706 3
d2717 3
d2729 1
a2729 1
		isp_target_async(isp, bus, ASYNC_LOOP_RESET);
d2749 31
d2801 1
a2801 1
	case RQSTYPE_CTIO0:
d2811 1
a2811 1
		return (isp_target_entry(isp, sp));
d3203 1
a3203 1
	MAKNIB(0, 0),	/* 0x55: */
d3512 6
d3574 6
d3947 8
a3954 1
		if (isp->isp_type < ISP_HA_SCSI_1040 ||
d4019 1
a4019 1
		    sdp->isp_devparam[tgt].sync_period,
a4098 1

a4102 2
	static char *tru = "true";
	static char *not = "false";
d4155 8
a4162 117
	if (IS_ULTRA2(isp)) {
		int bus;
		sdparam *sdp = (sdparam *) isp->isp_param;
		for (bus = 0; bus < (IS_DUALBUS(isp)? 2 : 1); bus++, sdp++) {
			sdp->isp_fifo_threshold = 
			    ISP1080_NVRAM_FIFO_THRESHOLD(nvram_data);

			sdp->isp_initiator_id =
			    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);

			sdp->isp_bus_reset_delay =
			    ISP1080_NVRAM_BUS_RESET_DELAY(nvram_data, bus);

			sdp->isp_retry_count =
			    ISP1080_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);

			sdp->isp_retry_delay =
			    ISP1080_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);

			sdp->isp_async_data_setup =
			    ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,
			    bus);

			sdp->isp_req_ack_active_neg =
			    ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,
			    bus);

			sdp->isp_data_line_active_neg =
			    ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,
			    bus);

			sdp->isp_data_dma_burst_enabl =
			    ISP1080_NVRAM_BURST_ENABLE(nvram_data);

			sdp->isp_cmd_dma_burst_enable =
			    ISP1080_NVRAM_BURST_ENABLE(nvram_data);

			sdp->isp_selection_timeout =
			    ISP1080_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);

			sdp->isp_max_queue_depth =
			     ISP1080_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);

			if (isp->isp_dblev >= 3) {
				PRINTF("%s: ISP1080 bus %d NVRAM values:\n",
				    isp->isp_name, bus);
				PRINTF("               Initiator ID = %d\n",
				    sdp->isp_initiator_id);
				PRINTF("             Fifo Threshold = 0x%x\n",
				    sdp->isp_fifo_threshold);
				PRINTF("            Bus Reset Delay = %d\n",
				    sdp->isp_bus_reset_delay);
				PRINTF("                Retry Count = %d\n",
				    sdp->isp_retry_count);
				PRINTF("                Retry Delay = %d\n",
				    sdp->isp_retry_delay);
				PRINTF("              Tag Age Limit = %d\n",
				    sdp->isp_tag_aging);
				PRINTF("          Selection Timeout = %d\n",
				    sdp->isp_selection_timeout);
				PRINTF("            Max Queue Depth = %d\n",
				    sdp->isp_max_queue_depth);
				PRINTF("           Async Data Setup = 0x%x\n",
				    sdp->isp_async_data_setup);
				PRINTF("    REQ/ACK Active Negation = %s\n",
				    sdp->isp_req_ack_active_neg? tru : not);
				PRINTF("  Data Line Active Negation = %s\n",
				    sdp->isp_data_line_active_neg? tru : not);
				PRINTF("       Cmd DMA Burst Enable = %s\n",
				    sdp->isp_cmd_dma_burst_enable? tru : not);
			}
			for (i = 0; i < MAX_TARGETS; i++) {
				sdp->isp_devparam[i].dev_enable =
				    ISP1080_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);
				sdp->isp_devparam[i].exc_throttle =
					ISP1080_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);
				sdp->isp_devparam[i].sync_offset =
					ISP1080_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);
				sdp->isp_devparam[i].sync_period =
					ISP1080_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);
				sdp->isp_devparam[i].dev_flags = 0;
				if (ISP1080_NVRAM_TGT_RENEG(nvram_data, i, bus))
					sdp->isp_devparam[i].dev_flags |= DPARM_RENEG;
				if (ISP1080_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {
					PRINTF("%s: not supporting QFRZ option "
					    "for target %d bus %d\n",
					    isp->isp_name, i, bus);
				}
				sdp->isp_devparam[i].dev_flags |= DPARM_ARQ;
				if (ISP1080_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {
					PRINTF("%s: not disabling ARQ option "
					    "for target %d bus %d\n",
					    isp->isp_name, i, bus);
				}
				if (ISP1080_NVRAM_TGT_TQING(nvram_data, i, bus))
					sdp->isp_devparam[i].dev_flags |= DPARM_TQING;
				if (ISP1080_NVRAM_TGT_SYNC(nvram_data, i, bus))
					sdp->isp_devparam[i].dev_flags |= DPARM_SYNC;
				if (ISP1080_NVRAM_TGT_WIDE(nvram_data, i, bus))
					sdp->isp_devparam[i].dev_flags |= DPARM_WIDE;
				if (ISP1080_NVRAM_TGT_PARITY(nvram_data, i, bus))
					sdp->isp_devparam[i].dev_flags |= DPARM_PARITY;
				if (ISP1080_NVRAM_TGT_DISC(nvram_data, i, bus))
					sdp->isp_devparam[i].dev_flags |= DPARM_DISC;
				sdp->isp_devparam[i].cur_dflags = 0;
				if (isp->isp_dblev >= 3) {
					PRINTF("   Target %d: Ena %d Throttle "
					    "%d Offset %d Period %d Flags "
					    "0x%x\n", i,
					    sdp->isp_devparam[i].dev_enable,
					    sdp->isp_devparam[i].exc_throttle,
					    sdp->isp_devparam[i].sync_offset,
					    sdp->isp_devparam[i].sync_period,
					    sdp->isp_devparam[i].dev_flags);
				}
			}
		}
d4164 1
a4164 143
		sdparam *sdp = (sdparam *) isp->isp_param;

		sdp->isp_fifo_threshold =
			ISP_NVRAM_FIFO_THRESHOLD(nvram_data) |
			(ISP_NVRAM_FIFO_THRESHOLD_128(nvram_data) << 2);

		sdp->isp_initiator_id =
			ISP_NVRAM_INITIATOR_ID(nvram_data);

		sdp->isp_bus_reset_delay =
			ISP_NVRAM_BUS_RESET_DELAY(nvram_data);

		sdp->isp_retry_count =
			ISP_NVRAM_BUS_RETRY_COUNT(nvram_data);

		sdp->isp_retry_delay =
			ISP_NVRAM_BUS_RETRY_DELAY(nvram_data);

		sdp->isp_async_data_setup =
			ISP_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data);

		if (isp->isp_type >= ISP_HA_SCSI_1040) {
			if (sdp->isp_async_data_setup < 9) {
				sdp->isp_async_data_setup = 9;
			}
		} else {
			if (sdp->isp_async_data_setup != 6) {
				sdp->isp_async_data_setup = 6;
			}
		}

		sdp->isp_req_ack_active_neg =
			ISP_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data);

		sdp->isp_data_line_active_neg =
			ISP_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data);

		sdp->isp_data_dma_burst_enabl =
			ISP_NVRAM_DATA_DMA_BURST_ENABLE(nvram_data);

		sdp->isp_cmd_dma_burst_enable =
			ISP_NVRAM_CMD_DMA_BURST_ENABLE(nvram_data);

		sdp->isp_tag_aging =
			ISP_NVRAM_TAG_AGE_LIMIT(nvram_data);

		sdp->isp_selection_timeout =
			ISP_NVRAM_SELECTION_TIMEOUT(nvram_data);

		sdp->isp_max_queue_depth =
			ISP_NVRAM_MAX_QUEUE_DEPTH(nvram_data);

		isp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);
		if (isp->isp_dblev > 2) {
			PRINTF("%s: NVRAM values:\n", isp->isp_name);
			PRINTF("             Fifo Threshold = 0x%x\n",
			    sdp->isp_fifo_threshold);
			PRINTF("            Bus Reset Delay = %d\n",
			    sdp->isp_bus_reset_delay);
			PRINTF("                Retry Count = %d\n",
			    sdp->isp_retry_count);
			PRINTF("                Retry Delay = %d\n",
			    sdp->isp_retry_delay);
			PRINTF("              Tag Age Limit = %d\n",
			    sdp->isp_tag_aging);
			PRINTF("          Selection Timeout = %d\n",
			    sdp->isp_selection_timeout);
			PRINTF("            Max Queue Depth = %d\n",
			    sdp->isp_max_queue_depth);
			PRINTF("           Async Data Setup = 0x%x\n",
			    sdp->isp_async_data_setup);
			PRINTF("    REQ/ACK Active Negation = %s\n",
			    sdp->isp_req_ack_active_neg? tru : not);
			PRINTF("  Data Line Active Negation = %s\n",
			    sdp->isp_data_line_active_neg? tru : not);
			PRINTF("      Data DMA Burst Enable = %s\n",
			    sdp->isp_data_dma_burst_enabl? tru : not);
			PRINTF("       Cmd DMA Burst Enable = %s\n",
			    sdp->isp_cmd_dma_burst_enable? tru : not);
			PRINTF("                  Fast MTTR = %s\n",
			    isp->isp_fast_mttr? tru : not);
		}
		for (i = 0; i < MAX_TARGETS; i++) {
			sdp->isp_devparam[i].dev_enable =
				ISP_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i);
			sdp->isp_devparam[i].exc_throttle =
				ISP_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i);
			sdp->isp_devparam[i].sync_offset =
				ISP_NVRAM_TGT_SYNC_OFFSET(nvram_data, i);
			sdp->isp_devparam[i].sync_period =
				ISP_NVRAM_TGT_SYNC_PERIOD(nvram_data, i);

			if (isp->isp_type < ISP_HA_SCSI_1040) {
				/*
				 * If we're not ultra, we can't possibly
				 * be a shorter period than this.
				 */
				if (sdp->isp_devparam[i].sync_period < 0x19) {
					sdp->isp_devparam[i].sync_period =
					    0x19;
				}
				if (sdp->isp_devparam[i].sync_offset > 0xc) {
					sdp->isp_devparam[i].sync_offset =
					    0x0c;
				}
			} else {
				if (sdp->isp_devparam[i].sync_offset > 0x8) {
					sdp->isp_devparam[i].sync_offset = 0x8;
				}
			}
			sdp->isp_devparam[i].dev_flags = 0;
			if (ISP_NVRAM_TGT_RENEG(nvram_data, i))
				sdp->isp_devparam[i].dev_flags |= DPARM_RENEG;
			if (ISP_NVRAM_TGT_QFRZ(nvram_data, i)) {
				PRINTF("%s: not supporting QFRZ option for "
				    "target %d\n", isp->isp_name, i);
			}
			sdp->isp_devparam[i].dev_flags |= DPARM_ARQ;
			if (ISP_NVRAM_TGT_ARQ(nvram_data, i) == 0) {
				PRINTF("%s: not disabling ARQ option for "
				    "target %d\n", isp->isp_name, i);
			}
			if (ISP_NVRAM_TGT_TQING(nvram_data, i))
				sdp->isp_devparam[i].dev_flags |= DPARM_TQING;
			if (ISP_NVRAM_TGT_SYNC(nvram_data, i))
				sdp->isp_devparam[i].dev_flags |= DPARM_SYNC;
			if (ISP_NVRAM_TGT_WIDE(nvram_data, i))
				sdp->isp_devparam[i].dev_flags |= DPARM_WIDE;
			if (ISP_NVRAM_TGT_PARITY(nvram_data, i))
				sdp->isp_devparam[i].dev_flags |= DPARM_PARITY;
			if (ISP_NVRAM_TGT_DISC(nvram_data, i))
				sdp->isp_devparam[i].dev_flags |= DPARM_DISC;
			sdp->isp_devparam[i].cur_dflags = 0; /* we don't know */
			if (isp->isp_dblev > 2) {
				PRINTF("   Target %d: Enabled %d Throttle %d "
				    "Offset %d Period %d Flags 0x%x\n", i,
				    sdp->isp_devparam[i].dev_enable,
				    sdp->isp_devparam[i].exc_throttle,
				    sdp->isp_devparam[i].sync_offset,
				    sdp->isp_devparam[i].sync_period,
				    sdp->isp_devparam[i].dev_flags);
			}
		}
d4166 1
a4166 78
		fcparam *fcp = (fcparam *) isp->isp_param;
		union {
			struct {
#if	BYTE_ORDER == BIG_ENDIAN
				u_int32_t hi32;
				u_int32_t lo32;
#else
				u_int32_t lo32;
				u_int32_t hi32;
#endif
			} wd;
			u_int64_t full64;
		} wwnstore;

		wwnstore.full64 = ISP2100_NVRAM_NODE_NAME(nvram_data);
		/*
		 * Broken PTI cards with nothing in the top nibble. Pah.
		 */
		if ((wwnstore.wd.hi32 >> 28) == 0) {
			wwnstore.wd.hi32 |= (2 << 28);
			CFGPRINTF("%s: (corrected) Adapter WWN 0x%08x%08x\n",
			    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);
		} else {
			CFGPRINTF("%s: Adapter WWN 0x%08x%08x\n", isp->isp_name,
			    wwnstore.wd.hi32, wwnstore.wd.lo32);
		}
		fcp->isp_nodewwn = wwnstore.full64;

		/*
		 * If the Node WWN has 2 in the top nibble, we can
		 * authoritatively construct a Port WWN by adding
		 * our unit number (plus one to make it nonzero) and
		 * putting it into bits 59..56. If the top nibble isn't
		 * 2, then we just set them identically.
		 */
		if ((fcp->isp_nodewwn >> 60) == 2) {
			fcp->isp_portwwn = fcp->isp_nodewwn |
			    (((u_int64_t)(isp->isp_unit+1)) << 56);
		} else {
			fcp->isp_portwwn = fcp->isp_nodewwn;
		}
		wwnstore.full64 = ISP2100_NVRAM_BOOT_NODE_NAME(nvram_data);
		if (wwnstore.full64 != 0) {
			PRINTF("%s: BOOT DEVICE WWN 0x%08x%08x\n",
			    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);
		}
		fcp->isp_maxalloc =
			ISP2100_NVRAM_MAXIOCBALLOCATION(nvram_data);
		fcp->isp_maxfrmlen =
			ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);
		fcp->isp_retry_delay =
			ISP2100_NVRAM_RETRY_DELAY(nvram_data);
		fcp->isp_retry_count =
			ISP2100_NVRAM_RETRY_COUNT(nvram_data);
		fcp->isp_loopid =
			ISP2100_NVRAM_HARDLOOPID(nvram_data);
		fcp->isp_execthrottle =
			ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);
		fcp->isp_fwoptions = ISP2100_NVRAM_OPTIONS(nvram_data);
		if (isp->isp_dblev > 2) {
			PRINTF("%s: NVRAM values:\n", isp->isp_name);
			PRINTF("  Max IOCB Allocation = %d\n",
			    fcp->isp_maxalloc);
			PRINTF("     Max Frame Length = %d\n",
			    fcp->isp_maxfrmlen);
			PRINTF("   Execution Throttle = %d\n",
			    fcp->isp_execthrottle);
			PRINTF("          Retry Count = %d\n",
			    fcp->isp_retry_count);
			PRINTF("          Retry Delay = %d\n",
			    fcp->isp_retry_delay);
			PRINTF("         Hard Loop ID = %d\n",
			    fcp->isp_loopid);
			PRINTF("              Options = 0x%x\n",
			    fcp->isp_fwoptions);
			PRINTF("          HBA Options = 0x%x\n",
			    ISP2100_NVRAM_HBA_OPTIONS(nvram_data));
		}
d4170 2
d4240 490
@


1.12.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.13 2000/02/20 21:22:40 mjacob Exp $ */
a97 5
static void isp_parse_nvram_1020 __P((struct ispsoftc *, u_int8_t *));
static void isp_parse_nvram_1080 __P((struct ispsoftc *, int, u_int8_t *));
static void isp_parse_nvram_12160 __P((struct ispsoftc *, int, u_int8_t *));
static void isp_parse_nvram_2100 __P((struct ispsoftc *, u_int8_t *));

d191 1
a191 9
		if (IS_1280(isp))
			revname = "1280";
		else if (IS_1080(isp))
			revname = "1080";
		else if (IS_12160(isp))
			revname = "12160";
		else
			revname = "<UNKLVD>";

d212 1
a212 1
		if (IS_DUALBUS(isp)) {
d214 1
d796 3
a798 2
	 * Ultra and older (i.e., SBus) cards may not. It's just safer
	 * to assume not for them.
d805 4
a808 1
	if (IS_ULTRA2(isp) || IS_1240(isp))
d810 2
d1010 1
d1062 1
a1062 13
#ifdef	PRET_A_PORTE
	if (IS_2200(isp)) {
		icbp->icb_fwoptions |= ICBOPT_EXTENDED;
		/*
		 * Prefer or force Point-To-Point instead Loop?
		 */
		if (isp->isp_confopts & ISP_CFG_NPORT)
			icbp->icb_xfwoptions = ICBXOPT_PTP_2_LOOP;
		else
			icbp->icb_xfwoptions = ICBXOPT_LOOP_2_PTP;
	}
#endif
	icbp->icb_logintime = 60;	/* 60 second login timeout */
d1241 1
d1286 8
a1293 6
	if (IS_2200(isp)) {
		topo = (int) mbs.param[6];
		if (topo < 0 || topo > 3)
			topo = 0;
	} else {
		topo = 0;
d1295 4
a1307 4

		if (IS_2100(isp))
			topo = 1;

d1311 2
a1312 3
		    "0x%x topology '%s'\n", isp->isp_name, fcp->isp_loopid,
		    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate,
		    toponames[topo]);
d1332 1
a1332 1
	CFGPRINTF("%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology '%s'\n",
d1334 2
a1335 1
	    toponames[topo]);
a1396 1

d1469 1
a1469 1
		if (target >= 0 && isp_same_lportdb(lp, &fcp->portdb[target])) {
d1638 1
a1638 1
	for (lim = FC_SNS_ID+1, lp = &fcp->portdb[FC_SNS_ID+1];
a1639 1
		u_int32_t portid;
a1646 1

d1650 1
a1650 1
		if ((portid = lp->portid) == fcp->isp_portid)
d1654 1
a1654 1
		 * Force a logout if we were logged in.
d1656 6
a1661 8
		if (lp->valid) {
			mbs.param[0] = MBOX_FABRIC_LOGOUT;
			mbs.param[1] = lp->loopid << 8;
			mbs.param[2] = 0;
			mbs.param[3] = 0;
			isp_mboxcmd(isp, &mbs);
			lp->valid = 0;
		}
d1666 26
a1691 19
		loopid = lp - fcp->portdb;
		lp->loopid = 0;
		lim = 0;
		do {
			mbs.param[0] = MBOX_FABRIC_LOGIN;
			mbs.param[1] = loopid << 8;
			if (IS_2200(isp)) {
				/* only issue a PLOGI if not logged in */
				mbs.param[1] |= 0x1;
			}
			mbs.param[2] = portid >> 16;
			mbs.param[3] = portid & 0xffff;
			isp_mboxcmd(isp, &mbs);
			switch (mbs.param[0]) {
			case MBOX_LOOP_ID_USED:
				/*
				 * Try the next available loop id.
				 */
				loopid++;
d1693 3
a1695 12
			case MBOX_PORT_ID_USED:
				/*
				 * This port is already logged in.
				 * Snaffle the loop id it's using.
				 */
				if ((loopid = mbs.param[1]) == 0) {
					lim = -1;
				}
				/* FALLTHROUGH */
			case MBOX_COMMAND_COMPLETE:
				lp->loopid = loopid;
				lim = 1;
a1696 5
			case MBOX_COMMAND_ERROR:
				PRINTF("%s: command error in PLOGI (0x%x)\n",
				    isp->isp_name, mbs.param[1]);
				/* FALLTHROUGH */
			case MBOX_ALL_IDS_USED: /* We're outta IDs */
a1697 1
				lim = -1;
a1699 2
		} while (lim == 0 && loopid < MAX_FC_TARG);
		if (lim < 0)
d1701 3
d1707 1
a1707 1
		if (isp_getpdb(isp, lp->loopid, &pdb) != 0) {
d1725 1
a1747 1
			loopid = lp - fcp->portdb;
a1760 6
	/*
	 * If we get here, we've for sure seen not only a valid loop
	 * but know what is or isn't on it, so mark this for usage
	 * in ispscsicmd.
	 */
	fcp->loop_seen_once = 1;
a1800 2
			IDPRINTF(1, ("%s: SNS failed (0x%x)\n", isp->isp_name,
			    mbs.param[0]));
d1852 2
a1853 4
	 * Check command CDB length, etc.. We really are limited to 16 bytes
	 * for Fibre Channel, but can do up to 44 bytes in parallel SCSI,
	 * but probably only if we're running fairly new firmware (we'll
	 * let the old f/w choke on an extended command queue entry).
d1856 1
a1856 1
	if (XS_CDBLEN(xs) > (IS_FC(isp)? 16 : 44) || XS_CDBLEN(xs) == 0) {
d1858 1
a1858 1
		    isp->isp_name, XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);
d1911 1
a1911 3
		 * sending commands for a little while, but only if we've
		 * seen a valid loop at one point (otherwise we can get
		 * stuck at initialization time).
d1915 1
a1915 5
			if (fcp->loop_seen_once) {
				return (CMD_RQLATER);
			} else {
				return (CMD_COMPLETE);
			}
d2002 1
a2002 4
		if (XS_CDBLEN(xs) > 12)
			reqp->req_header.rqs_entry_type = RQSTYPE_CMDONLY;
		else
			reqp->req_header.rqs_entry_type = RQSTYPE_REQUEST;
a2114 1
		mbs.param[2] = 0;
d2121 1
a2121 2
			if (IS_DUALBUS(isp))
				mbs.param[2] = bus;
d2124 1
d2177 2
a2178 2
		mbs.param[3] = handle >> 16;
		mbs.param[2] = handle & 0xffff;
d2195 3
d2199 2
a2200 18
	case ISPCTL_PDB_SYNC:
		return (isp_pdb_sync(isp, -1));

#ifdef	ISP_TARGET_MODE
	case ISPCTL_TOGGLE_TMODE:
		if (IS_SCSI(isp)) {
			int ena = *(int *)arg;
			mbs.param[0] = MBOX_ENABLE_TARGET_MODE;
			mbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;
			isp_mboxcmd(isp, &mbs);
			if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
				PRINTF("%s: cannot %sable target mode (0x%x)\n",
				    isp->isp_name, ena? "en" : "dis",
				    mbs.param[0]);
				break;
			}
		}
		return (0);
d2292 1
a2292 2
		 * written into memory so it makes sense to us. This is a
		 * per-platform thing.
d2297 1
d2306 1
d2387 1
a2387 3
			if (sp->req_scsi_status & RQCS_SV) {
				int amt = min(XS_SNSLEN(xs), sp->req_sense_len);
				MEMCPY(XS_SNSP(xs), sp->req_sense_data, amt);
d2389 2
a2391 3
			} else if (XS_STS(xs) == SCSI_CHECK) {
				IDPRINTF(1, ("%s: check condition with no sense"
				    " data\n", isp->isp_name));
a2433 4
		 * Let the platforms cope.
		 */
#if	0
		/*
a2445 1
#endif
d2509 1
a2509 1
		isp_target_async(isp, bus, mbox);
d2543 1
a2543 1
		isp_target_async(isp, bus, mbox);
d2551 1
a2551 1
		isp_target_async(isp, bus, mbox);
a2628 3
#ifdef	ISP_TARGET_MODE
		isp_target_async(isp, bus, mbox);
#endif
a2636 3
#ifdef	ISP_TARGET_MODE
		isp_target_async(isp, bus, mbox);
#endif
a2644 3
#ifdef	ISP_TARGET_MODE
		isp_target_async(isp, bus, mbox);
#endif
d2654 1
a2654 1
		isp_target_async(isp, bus, mbox);
a2673 31
	case ASYNC_PTPMODE:
		PRINTF("%s: Point-to-Point mode\n", isp->isp_name);
		break;

	case ASYNC_CONNMODE:
		mbox = ISP_READ(isp, OUTMAILBOX1);
		switch (mbox) {
		case ISP_CONN_LOOP:
			PRINTF("%s: Point-to-Point -> Loop mode\n",
			    isp->isp_name);
			break;
		case ISP_CONN_PTP:
			PRINTF("%s: Loop -> Point-to-Point mode\n",
			    isp->isp_name);
			break;
		case ISP_CONN_BADLIP:
			PRINTF("%s: Point-to-Point -> Loop mode (1)\n",
			    isp->isp_name);
			break;
		case ISP_CONN_FATAL:
			PRINTF("%s: FATAL CONNECTION ERROR\n", isp->isp_name);
			isp_restart(isp);
			/* no point continuing after this */
			return (-1);

		case ISP_CONN_LOOPBACK:
			PRINTF("%s: Looped Back in Point-to-Point mode\n",
			     isp->isp_name);
		}
		break;

d2695 1
a2695 1
	case RQSTYPE_CTIO:
d2705 1
a2705 1
		return (isp_target_notify(isp, sp, optrp));
d3097 1
a3097 1
	MAKNIB(2, 1),	/* 0x55: MBOX_ENABLE_TARGET_MODE */
a3405 6
	if (IS_2200(isp)) {
		if (opcode == MBOX_GET_LOOP_ID) {
			mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);
		}
	}

a3461 6
	case MBOX_LOOP_ID_USED:
	case MBOX_PORT_ID_USED:
	case MBOX_ALL_IDS_USED:
		break;


d3829 1
a3829 8
		/*
		 * We default to Wide/Fast for versions less than a 1040
		 * (unless it's SBus).
		 */
		if ((isp->isp_bustype == ISP_BT_SBUS &&
		    isp->isp_type < ISP_HA_SCSI_1020A) ||
		    (isp->isp_bustype == ISP_BT_PCI &&
		    isp->isp_type < ISP_HA_SCSI_1040) ||
d3894 1
a3894 1
		    sdp->isp_devparam[tgt].sync_offset,
d3974 1
d3979 2
d4033 117
a4149 8
	if (IS_ULTRA3(isp)) {
		isp_parse_nvram_12160(isp, 0, nvram_data);
		isp_parse_nvram_12160(isp, 1, nvram_data);
	} else if (IS_1080(isp)) {
		isp_parse_nvram_1080(isp, 0, nvram_data);
	} else if (IS_1280(isp) || IS_1240(isp)) {
		isp_parse_nvram_1080(isp, 0, nvram_data);
		isp_parse_nvram_1080(isp, 1, nvram_data);
d4151 143
a4293 1
		isp_parse_nvram_1020(isp, nvram_data);
d4295 78
a4372 1
		isp_parse_nvram_2100(isp, nvram_data);
a4375 2
#undef	nvram_data
#undef	nvram_words
a4443 490
}

static void
isp_parse_nvram_1020(isp, nvram_data)
	struct ispsoftc *isp;
	u_int8_t *nvram_data;
{
	int i;
	static char *tru = "true";
	static char *not = "false";
	sdparam *sdp = (sdparam *) isp->isp_param;

	sdp->isp_fifo_threshold =
		ISP_NVRAM_FIFO_THRESHOLD(nvram_data) |
		(ISP_NVRAM_FIFO_THRESHOLD_128(nvram_data) << 2);

	sdp->isp_initiator_id =
		ISP_NVRAM_INITIATOR_ID(nvram_data);

	sdp->isp_bus_reset_delay =
		ISP_NVRAM_BUS_RESET_DELAY(nvram_data);

	sdp->isp_retry_count =
		ISP_NVRAM_BUS_RETRY_COUNT(nvram_data);

	sdp->isp_retry_delay =
		ISP_NVRAM_BUS_RETRY_DELAY(nvram_data);

	sdp->isp_async_data_setup =
		ISP_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data);

	if (isp->isp_type >= ISP_HA_SCSI_1040) {
		if (sdp->isp_async_data_setup < 9) {
			sdp->isp_async_data_setup = 9;
		}
	} else {
		if (sdp->isp_async_data_setup != 6) {
			sdp->isp_async_data_setup = 6;
		}
	}

	sdp->isp_req_ack_active_neg =
		ISP_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data);

	sdp->isp_data_line_active_neg =
		ISP_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data);

	sdp->isp_data_dma_burst_enabl =
		ISP_NVRAM_DATA_DMA_BURST_ENABLE(nvram_data);

	sdp->isp_cmd_dma_burst_enable =
		ISP_NVRAM_CMD_DMA_BURST_ENABLE(nvram_data);

	sdp->isp_tag_aging =
		ISP_NVRAM_TAG_AGE_LIMIT(nvram_data);

	sdp->isp_selection_timeout =
		ISP_NVRAM_SELECTION_TIMEOUT(nvram_data);

	sdp->isp_max_queue_depth =
		ISP_NVRAM_MAX_QUEUE_DEPTH(nvram_data);

	isp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);
	if (isp->isp_dblev > 2) {
		PRINTF("%s: NVRAM values:\n", isp->isp_name);
		PRINTF("             Fifo Threshold = 0x%x\n",
		    sdp->isp_fifo_threshold);
		PRINTF("            Bus Reset Delay = %d\n",
		    sdp->isp_bus_reset_delay);
		PRINTF("                Retry Count = %d\n",
		    sdp->isp_retry_count);
		PRINTF("                Retry Delay = %d\n",
		    sdp->isp_retry_delay);
		PRINTF("              Tag Age Limit = %d\n",
		    sdp->isp_tag_aging);
		PRINTF("          Selection Timeout = %d\n",
		    sdp->isp_selection_timeout);
		PRINTF("            Max Queue Depth = %d\n",
		    sdp->isp_max_queue_depth);
		PRINTF("           Async Data Setup = 0x%x\n",
		    sdp->isp_async_data_setup);
		PRINTF("    REQ/ACK Active Negation = %s\n",
		    sdp->isp_req_ack_active_neg? tru : not);
		PRINTF("  Data Line Active Negation = %s\n",
		    sdp->isp_data_line_active_neg? tru : not);
		PRINTF("      Data DMA Burst Enable = %s\n",
		    sdp->isp_data_dma_burst_enabl? tru : not);
		PRINTF("       Cmd DMA Burst Enable = %s\n",
		    sdp->isp_cmd_dma_burst_enable? tru : not);
		PRINTF("                  Fast MTTR = %s\n",
		    isp->isp_fast_mttr? tru : not);
	}
	for (i = 0; i < MAX_TARGETS; i++) {
		sdp->isp_devparam[i].dev_enable =
			ISP_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i);
		sdp->isp_devparam[i].exc_throttle =
			ISP_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i);
		sdp->isp_devparam[i].sync_offset =
			ISP_NVRAM_TGT_SYNC_OFFSET(nvram_data, i);
		sdp->isp_devparam[i].sync_period =
			ISP_NVRAM_TGT_SYNC_PERIOD(nvram_data, i);

		if (isp->isp_type < ISP_HA_SCSI_1040) {
			/*
			 * If we're not ultra, we can't possibly
			 * be a shorter period than this.
			 */
			if (sdp->isp_devparam[i].sync_period < 0x19) {
				sdp->isp_devparam[i].sync_period =
				    0x19;
			}
			if (sdp->isp_devparam[i].sync_offset > 0xc) {
				sdp->isp_devparam[i].sync_offset =
				    0x0c;
			}
		} else {
			if (sdp->isp_devparam[i].sync_offset > 0x8) {
				sdp->isp_devparam[i].sync_offset = 0x8;
			}
		}
		sdp->isp_devparam[i].dev_flags = 0;
		if (ISP_NVRAM_TGT_RENEG(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_RENEG;
		if (ISP_NVRAM_TGT_QFRZ(nvram_data, i)) {
			PRINTF("%s: not supporting QFRZ option for "
			    "target %d\n", isp->isp_name, i);
		}
		sdp->isp_devparam[i].dev_flags |= DPARM_ARQ;
		if (ISP_NVRAM_TGT_ARQ(nvram_data, i) == 0) {
			PRINTF("%s: not disabling ARQ option for "
			    "target %d\n", isp->isp_name, i);
		}
		if (ISP_NVRAM_TGT_TQING(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_TQING;
		if (ISP_NVRAM_TGT_SYNC(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_SYNC;
		if (ISP_NVRAM_TGT_WIDE(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_WIDE;
		if (ISP_NVRAM_TGT_PARITY(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_PARITY;
		if (ISP_NVRAM_TGT_DISC(nvram_data, i))
			sdp->isp_devparam[i].dev_flags |= DPARM_DISC;
		sdp->isp_devparam[i].cur_dflags = 0; /* we don't know */
		if (isp->isp_dblev > 2) {
			PRINTF("   Target %d: Enabled %d Throttle %d "
			    "Offset %d Period %d Flags 0x%x\n", i,
			    sdp->isp_devparam[i].dev_enable,
			    sdp->isp_devparam[i].exc_throttle,
			    sdp->isp_devparam[i].sync_offset,
			    sdp->isp_devparam[i].sync_period,
			    sdp->isp_devparam[i].dev_flags);
		}
	}
}

static void
isp_parse_nvram_1080(isp, bus, nvram_data)
	struct ispsoftc *isp;
	int bus;
	u_int8_t *nvram_data;
{
	static char *tru = "true";
	static char *not = "false";
	int i;
	sdparam *sdp = (sdparam *) isp->isp_param;
	sdp += bus;

	sdp->isp_fifo_threshold = 
	    ISP1080_NVRAM_FIFO_THRESHOLD(nvram_data);

	sdp->isp_initiator_id =
	    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);

	sdp->isp_bus_reset_delay =
	    ISP1080_NVRAM_BUS_RESET_DELAY(nvram_data, bus);

	sdp->isp_retry_count =
	    ISP1080_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);

	sdp->isp_retry_delay =
	    ISP1080_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);

	sdp->isp_async_data_setup =
	    ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,
	    bus);

	sdp->isp_req_ack_active_neg =
	    ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,
	    bus);

	sdp->isp_data_line_active_neg =
	    ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,
	    bus);

	sdp->isp_data_dma_burst_enabl =
	    ISP1080_NVRAM_BURST_ENABLE(nvram_data);

	sdp->isp_cmd_dma_burst_enable =
	    ISP1080_NVRAM_BURST_ENABLE(nvram_data);

	sdp->isp_selection_timeout =
	    ISP1080_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);

	sdp->isp_max_queue_depth =
	     ISP1080_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);

	if (isp->isp_dblev >= 3) {
		PRINTF("%s: ISP1080 bus %d NVRAM values:\n",
		    isp->isp_name, bus);
		PRINTF("               Initiator ID = %d\n",
		    sdp->isp_initiator_id);
		PRINTF("             Fifo Threshold = 0x%x\n",
		    sdp->isp_fifo_threshold);
		PRINTF("            Bus Reset Delay = %d\n",
		    sdp->isp_bus_reset_delay);
		PRINTF("                Retry Count = %d\n",
		    sdp->isp_retry_count);
		PRINTF("                Retry Delay = %d\n",
		    sdp->isp_retry_delay);
		PRINTF("              Tag Age Limit = %d\n",
		    sdp->isp_tag_aging);
		PRINTF("          Selection Timeout = %d\n",
		    sdp->isp_selection_timeout);
		PRINTF("            Max Queue Depth = %d\n",
		    sdp->isp_max_queue_depth);
		PRINTF("           Async Data Setup = 0x%x\n",
		    sdp->isp_async_data_setup);
		PRINTF("    REQ/ACK Active Negation = %s\n",
		    sdp->isp_req_ack_active_neg? tru : not);
		PRINTF("  Data Line Active Negation = %s\n",
		    sdp->isp_data_line_active_neg? tru : not);
		PRINTF("       Cmd DMA Burst Enable = %s\n",
		    sdp->isp_cmd_dma_burst_enable? tru : not);
	}
	for (i = 0; i < MAX_TARGETS; i++) {
		sdp->isp_devparam[i].dev_enable =
		    ISP1080_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);
		sdp->isp_devparam[i].exc_throttle =
			ISP1080_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);
		sdp->isp_devparam[i].sync_offset =
			ISP1080_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);
		sdp->isp_devparam[i].sync_period =
			ISP1080_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);
		sdp->isp_devparam[i].dev_flags = 0;
		if (ISP1080_NVRAM_TGT_RENEG(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_RENEG;
		if (ISP1080_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {
			PRINTF("%s: not supporting QFRZ option "
			    "for target %d bus %d\n",
			    isp->isp_name, i, bus);
		}
		sdp->isp_devparam[i].dev_flags |= DPARM_ARQ;
		if (ISP1080_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {
			PRINTF("%s: not disabling ARQ option "
			    "for target %d bus %d\n",
			    isp->isp_name, i, bus);
		}
		if (ISP1080_NVRAM_TGT_TQING(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_TQING;
		if (ISP1080_NVRAM_TGT_SYNC(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_SYNC;
		if (ISP1080_NVRAM_TGT_WIDE(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_WIDE;
		if (ISP1080_NVRAM_TGT_PARITY(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_PARITY;
		if (ISP1080_NVRAM_TGT_DISC(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_DISC;
		sdp->isp_devparam[i].cur_dflags = 0;
		if (isp->isp_dblev >= 3) {
			PRINTF("   Target %d: Ena %d Throttle "
			    "%d Offset %d Period %d Flags "
			    "0x%x\n", i,
			    sdp->isp_devparam[i].dev_enable,
			    sdp->isp_devparam[i].exc_throttle,
			    sdp->isp_devparam[i].sync_offset,
			    sdp->isp_devparam[i].sync_period,
			    sdp->isp_devparam[i].dev_flags);
		}
	}
}

static void
isp_parse_nvram_12160(isp, bus, nvram_data)
	struct ispsoftc *isp;
	int bus;
	u_int8_t *nvram_data;
{
	static char *tru = "true";
	static char *not = "false";
	sdparam *sdp = (sdparam *) isp->isp_param;
	int i;

	sdp += bus;

	sdp->isp_fifo_threshold =
	    ISP12160_NVRAM_FIFO_THRESHOLD(nvram_data);

	sdp->isp_initiator_id = 
	    ISP12160_NVRAM_INITIATOR_ID(nvram_data, bus);

	sdp->isp_bus_reset_delay =
	    ISP12160_NVRAM_BUS_RESET_DELAY(nvram_data, bus);

	sdp->isp_retry_count =
	    ISP12160_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);

	sdp->isp_retry_delay =
	    ISP12160_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);

	sdp->isp_async_data_setup =
	    ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,
	    bus);

	sdp->isp_req_ack_active_neg =
	    ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,
	    bus);

	sdp->isp_data_line_active_neg =
	    ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,
	    bus);

	sdp->isp_data_dma_burst_enabl =
	    ISP12160_NVRAM_BURST_ENABLE(nvram_data);

	sdp->isp_cmd_dma_burst_enable =
	    ISP12160_NVRAM_BURST_ENABLE(nvram_data);

	sdp->isp_selection_timeout =
	    ISP12160_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);

	sdp->isp_max_queue_depth =
	     ISP12160_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);

	if (isp->isp_dblev >= 3) {
		PRINTF("%s: ISP12160 bus %d NVRAM values:\n",
		    isp->isp_name, bus);
		PRINTF("               Initiator ID = %d\n",
		    sdp->isp_initiator_id);
		PRINTF("             Fifo Threshold = 0x%x\n",
		    sdp->isp_fifo_threshold);
		PRINTF("            Bus Reset Delay = %d\n",
		    sdp->isp_bus_reset_delay);
		PRINTF("                Retry Count = %d\n",
		    sdp->isp_retry_count);
		PRINTF("                Retry Delay = %d\n",
		    sdp->isp_retry_delay);
		PRINTF("              Tag Age Limit = %d\n",
		    sdp->isp_tag_aging);
		PRINTF("          Selection Timeout = %d\n",
		    sdp->isp_selection_timeout);
		PRINTF("            Max Queue Depth = %d\n",
		    sdp->isp_max_queue_depth);
		PRINTF("           Async Data Setup = 0x%x\n",
		    sdp->isp_async_data_setup);
		PRINTF("    REQ/ACK Active Negation = %s\n",
		    sdp->isp_req_ack_active_neg? tru : not);
		PRINTF("  Data Line Active Negation = %s\n",
		    sdp->isp_data_line_active_neg? tru : not);
		PRINTF("       Cmd DMA Burst Enable = %s\n",
		    sdp->isp_cmd_dma_burst_enable? tru : not);
	}

	for (i = 0; i < MAX_TARGETS; i++) {
		sdp->isp_devparam[i].dev_enable =
		    ISP12160_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);
		sdp->isp_devparam[i].exc_throttle =
			ISP12160_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);
		sdp->isp_devparam[i].sync_offset =
			ISP12160_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);
		sdp->isp_devparam[i].sync_period =
			ISP12160_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);
		sdp->isp_devparam[i].dev_flags = 0;
		if (ISP12160_NVRAM_TGT_RENEG(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_RENEG;
		if (ISP12160_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {
			PRINTF("%s: not supporting QFRZ option "
			    "for target %d bus %d\n", isp->isp_name, i, bus);
		}
		sdp->isp_devparam[i].dev_flags |= DPARM_ARQ;
		if (ISP12160_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {
			PRINTF("%s: not disabling ARQ option "
			    "for target %d bus %d\n", isp->isp_name, i, bus);
		}
		if (ISP12160_NVRAM_TGT_TQING(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_TQING;
		if (ISP12160_NVRAM_TGT_SYNC(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_SYNC;
		if (ISP12160_NVRAM_TGT_WIDE(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_WIDE;
		if (ISP12160_NVRAM_TGT_PARITY(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_PARITY;
		if (ISP12160_NVRAM_TGT_DISC(nvram_data, i, bus))
			sdp->isp_devparam[i].dev_flags |= DPARM_DISC;
		sdp->isp_devparam[i].cur_dflags = 0;
		if (isp->isp_dblev >= 3) {
			PRINTF("   Target %d: Ena %d Throttle %d Offset %d "
			    "Period %d Flags 0x%x\n", i,
			    sdp->isp_devparam[i].dev_enable,
			    sdp->isp_devparam[i].exc_throttle,
			    sdp->isp_devparam[i].sync_offset,
			    sdp->isp_devparam[i].sync_period,
			    sdp->isp_devparam[i].dev_flags);
		}
	}
}

static void
isp_parse_nvram_2100(isp, nvram_data)
	struct ispsoftc *isp;
	u_int8_t *nvram_data;
{
	fcparam *fcp = (fcparam *) isp->isp_param;
	union {
		struct {
#if	BYTE_ORDER == BIG_ENDIAN
			u_int32_t hi32;
			u_int32_t lo32;
#else
			u_int32_t lo32;
			u_int32_t hi32;
#endif
		} wd;
		u_int64_t full64;
	} wwnstore;

	wwnstore.full64 = ISP2100_NVRAM_NODE_NAME(nvram_data);

	/*
	 * Broken PTI cards with nothing in the top nibble. Pah.
	 */
	if ((wwnstore.wd.hi32 >> 28) == 0) {
		wwnstore.wd.hi32 |= (2 << 28);
		CFGPRINTF("%s: (corrected) Adapter WWN 0x%08x%08x\n",
		    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);
	} else {
		CFGPRINTF("%s: Adapter WWN 0x%08x%08x\n", isp->isp_name,
		    wwnstore.wd.hi32, wwnstore.wd.lo32);
	}
	fcp->isp_nodewwn = wwnstore.full64;

	/*
	 * If the Node WWN has 2 in the top nibble, we can
	 * authoritatively construct a Port WWN by adding
	 * our unit number (plus one to make it nonzero) and
	 * putting it into bits 59..56. If the top nibble isn't
	 * 2, then we just set them identically.
	 */
	if ((fcp->isp_nodewwn >> 60) == 2) {
		fcp->isp_portwwn = fcp->isp_nodewwn |
		    (((u_int64_t)(isp->isp_unit+1)) << 56);
	} else {
		fcp->isp_portwwn = fcp->isp_nodewwn;
	}
	wwnstore.full64 = ISP2100_NVRAM_BOOT_NODE_NAME(nvram_data);
	if (wwnstore.full64 != 0) {
		PRINTF("%s: BOOT DEVICE WWN 0x%08x%08x\n",
		    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);
	}
	fcp->isp_maxalloc =
		ISP2100_NVRAM_MAXIOCBALLOCATION(nvram_data);
	fcp->isp_maxfrmlen =
		ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);
	fcp->isp_retry_delay =
		ISP2100_NVRAM_RETRY_DELAY(nvram_data);
	fcp->isp_retry_count =
		ISP2100_NVRAM_RETRY_COUNT(nvram_data);
	fcp->isp_loopid =
		ISP2100_NVRAM_HARDLOOPID(nvram_data);
	fcp->isp_execthrottle =
		ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);
	fcp->isp_fwoptions = ISP2100_NVRAM_OPTIONS(nvram_data);
	if (isp->isp_dblev > 2) {
		PRINTF("%s: NVRAM values:\n", isp->isp_name);
		PRINTF("  Max IOCB Allocation = %d\n",
		    fcp->isp_maxalloc);
		PRINTF("     Max Frame Length = %d\n",
		    fcp->isp_maxfrmlen);
		PRINTF("   Execution Throttle = %d\n",
		    fcp->isp_execthrottle);
		PRINTF("          Retry Count = %d\n",
		    fcp->isp_retry_count);
		PRINTF("          Retry Delay = %d\n",
		    fcp->isp_retry_delay);
		PRINTF("         Hard Loop ID = %d\n",
		    fcp->isp_loopid);
		PRINTF("              Options = 0x%x\n",
		    fcp->isp_fwoptions);
		PRINTF("          HBA Options = 0x%x\n",
		    ISP2100_NVRAM_HBA_OPTIONS(nvram_data));
	}
@


1.12.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/* 	$OpenBSD$ */
d2836 2
a2837 3
			IDPRINTF(3, ("%s: Selection Timeout for %d.%d.%d\n",
			    isp->isp_name, XS_TGT(xs), XS_LUN(xs),
			    XS_CHANNEL(xs)));
d2841 2
a2842 2
		PRINTF("%s: command incomplete for %d.%d.%d, state 0x%x\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),
d2847 2
a2848 2
		PRINTF("%s: DMA error for command on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2852 1
a2852 2
		PRINTF("%s: transport error for %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2857 7
a2863 3
		IDPRINTF(1, ("%s: bus reset destroyed command for %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));
		isp->isp_sendmarker |= (1 << XS_CHANNEL(xs));
d2868 6
a2873 3
		PRINTF("%s: command aborted for %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		isp->isp_sendmarker |= (1 << XS_CHANNEL(xs));
d2878 2
a2879 2
		IDPRINTF(2, ("%s: command timed out for %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));
a2887 2
		PRINTF("%s: data overrun for command on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2892 2
a2893 2
		PRINTF("%s: command overrun for command on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2897 2
a2898 2
		PRINTF("%s: status overrun for command on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2902 3
a2904 2
		PRINTF("%s: msg not COMMAND COMPLETE after status %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2908 3
a2910 2
		PRINTF("%s: No MESSAGE OUT phase after selection on %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2914 2
a2915 2
		PRINTF("%s: EXTENDED IDENTIFY failed %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2919 2
a2920 2
		PRINTF("%s: INITIATOR DETECTED ERROR rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2924 2
a2925 2
		PRINTF("%s: ABORT OPERATION rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2929 2
a2930 2
		PRINTF("%s: MESSAGE REJECT rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2934 2
a2935 2
		PRINTF("%s: NOP rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2939 2
a2940 2
		PRINTF("%s: MESSAGE PARITY ERROR rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2944 2
a2945 2
		PRINTF("%s: BUS DEVICE RESET rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2949 2
a2950 2
		PRINTF("%s: IDENTIFY rejected by %d.%d.%d\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2954 2
a2955 2
		PRINTF("%s: %d.%d.%d had an unexpected bus free\n",
		    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2961 1
d2968 2
a2969 2
		    "not set for %d.%d.%d\n", isp->isp_name, XS_CHANNEL(xs),
		    XS_TGT(xs), XS_LUN(xs));
d2974 2
a2975 2
		    "routine %d on target %d, bus %d\n", isp->isp_name,
		    XS_LUN(xs), XS_TGT(xs), XS_CHANNEL(xs));
d2980 2
a2981 2
		    "%d on bus %d when queueing disabled\n", isp->isp_name,
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d2990 2
a2991 2
		    "bus %d, status 0x%x\n", isp->isp_name, XS_TGT(xs),
		    XS_LUN(xs), XS_CHANNEL(xs), XS_STS(xs)));
d3004 2
a3005 2
		    "STATUS phase) for target %d lun %d bus %d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3009 3
a3011 2
		PRINTF("%s: Auto Request Sense failed for %d.%d.%d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3015 2
a3016 2
		PRINTF("%s: Wide Negotiation failed for %d.%d.%d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3022 1
a3022 1
			isp->isp_update |= (1 << XS_CHANNEL(xs));
d3028 2
a3029 2
		PRINTF("%s: SDTR Message failed for target %d.%d.%d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3035 1
a3035 1
			isp->isp_update |= (1 << XS_CHANNEL(xs));
d3040 2
a3041 2
		PRINTF("%s: Bad LVD condition while talking to %d.%d.%d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3064 2
a3065 3
		    isp->isp_name, XS_TGT(xs));
		XS_SETERR(xs, HBA_SELTIMEOUT);
		return;
d3069 1
a3069 1
		    isp->isp_name, XS_TGT(xs));
d3074 2
a3075 2
		PRINTF("%s: completion status 0x%x\n",
		    isp->isp_name, sp->req_completion_status);
@


1.12.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.21 2001/04/04 22:06:54 mjacob Exp $ */
d6 2
a7 2
 * Copyright (c) 1997, 1998, 1999, 2000, 2001 by Matthew Jacob
 * Feral Software
d16 4
a19 1
 * 2. The name of the author may not be used to endorse or promote products
a56 3
#ifdef	__svr4__
#include "isp_solaris.h"
#endif
d67 1
a67 36
static const char warnlun[] =
    "WARNING- cannot determine Expanded LUN capability- limiting to one LUN";
static const char portshift[] =
    "Target %d Loop ID 0x%x (Port 0x%x) => Loop 0x%x (Port 0x%x)";
static const char portdup[] =
    "Target %d duplicates Target %d- killing off both";
static const char retained[] = 
    "Retaining Loop ID 0x%x for Target %d (Port 0x%x)";
static const char lretained[] =
    "Retained login of Target %d (Loop ID 0x%x) Port 0x%x";
static const char plogout[] =
    "Logging out Target %d at Loop ID 0x%x (Port 0x%x)";
static const char plogierr[] =
    "Command Error in PLOGI for Port 0x%x (0x%x)";
static const char nopdb[] =
    "Could not get PDB for Device @@ Port 0x%x";
static const char pdbmfail1[] =
    "PDB Loop ID info for Device @@ Port 0x%x does not match up (0x%x)";
static const char pdbmfail2[] =
    "PDB Port info for Device @@ Port 0x%x does not match up (0x%x)";
static const char ldumped[] =
    "Target %d (Loop ID 0x%x) Port 0x%x dumped after login info mismatch";
static const char notresp[] =
  "Not RESPONSE in RESPONSE Queue (type 0x%x) @@ idx %d (next %d) nlooked %d";
static const char xact1[] =
    "HBA attempted queued transaction with disconnect not set for %d.%d.%d";
static const char xact2[] =
    "HBA attempted queued transaction to target routine %d on target %d bus %d";
static const char xact3[] =
    "HBA attempted queued cmd for %d.%d.%d when queueing disabled";
static const char pskip[] =
    "SCSI phase skipped for target %d.%d.%d";
static const char topology[] =
    "Loop ID %d, AL_PA 0x%x, Port ID 0x%x, Loop State 0x%x, Topology '%s'";
static const char finmsg[] =
    "(%d.%d.%d): FIN dl%d resid %d STS 0x%x SKEY %c XS_ERR=0x%x";
d75 2
a76 2
__P((struct ispsoftc *, ispstatusreq_t *, XS_T *));
static void isp_fastpost_complete __P((struct ispsoftc *, u_int16_t));
a80 1
static int isp_getmap __P((struct ispsoftc *, fcpos_map_t *));
d84 3
a86 3
static char *isp2100_fw_statename __P((int));
static int isp_pdb_sync __P((struct ispsoftc *));
static int isp_scan_loop __P((struct ispsoftc *));
d88 1
a88 1
static void isp_register_fc4_type __P((struct ispsoftc *));
d90 2
a91 1
static void isp_mboxcmd __P((struct ispsoftc *, mbreg_t *, int));
d103 1
d112 2
a113 1
isp_reset(struct ispsoftc *isp)
d116 2
a117 2
	int loops, i, touched, dodnld = 1;
	char *revname = "????";
a120 1

d125 4
a128 1
	 *
d130 1
a130 1
	 * for SCSI adapters and do other settings for the 2100.
d141 7
a147 1
	if ((touched = isp->isp_touched) == 0) {
d149 7
a155 21
		 * First see whether or not we're sitting in the ISP PROM.
		 * If we've just been reset, we'll have the string "ISP   "
		 * spread through outgoing mailbox registers 1-3.
		 */
		if (ISP_READ(isp, OUTMAILBOX1) != 0x4953 ||
		    ISP_READ(isp, OUTMAILBOX2) != 0x5020 ||
		    ISP_READ(isp, OUTMAILBOX3) != 0x2020) {
			/*
			 * Just in case it was paused...
			 */
			ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
			mbs.param[0] = MBOX_ABOUT_FIRMWARE;
			isp_mboxcmd(isp, &mbs, MBOX_COMMAND_ERROR);
			/*
			 * This *shouldn't* fail.....
			 */
			if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
				isp->isp_romfw_rev[0] = mbs.param[1];
				isp->isp_romfw_rev[1] = mbs.param[2];
				isp->isp_romfw_rev[2] = mbs.param[3];
			}
d163 1
a163 2
	 * Put the board into PAUSE mode (so we can read the SXP registers
	 * or write FPM/FBM registers).
d168 1
d171 1
a171 1
			revname = "2100";
d174 1
a174 1
			revname = "2200";
a178 8
		/*
		 * While we're paused, reset the FPM module and FBM fifos.
		 */
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_FPM0_REGS);
		ISP_WRITE(isp, FPM_DIAG_CONFIG, FPM_SOFT_RESET);
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_FB_REGS);
		ISP_WRITE(isp, FBM_CMD, FBMCMD_FIFO_RESET_ALL);
		ISP_WRITE(isp, BIU2100_CSR, BIU2100_RISC_REGS);
d190 1
a190 1
		static const char m[] = "bus %d is in %s Mode";
d209 1
a209 1
			isp_prt(isp, ISP_LOGCONFIG, m, 0, "LVD");
d213 1
a213 1
			isp_prt(isp, ISP_LOGCONFIG, m, 0, "Differential");
d217 1
a217 1
			isp_prt(isp, ISP_LOGCONFIG, m, 0, "Single-Ended");
d220 2
a221 2
			isp_prt(isp, ISP_LOGERR,
			    "unknown mode on bus %d (0x%x)", 0, l);
d232 1
a232 1
				isp_prt(isp, ISP_LOGCONFIG, m, 1, "LVD");
d236 1
a236 2
				isp_prt(isp, ISP_LOGCONFIG,
				    m, 1, "Differential");
d240 1
a240 2
				isp_prt(isp, ISP_LOGCONFIG,
				    m, 1, "Single-Ended");
d243 2
a244 2
				isp_prt(isp, ISP_LOGERR,
				    "unknown mode on bus %d (0x%x)", 1, l);
d253 2
a254 1
			isp_prt(isp, ISP_LOGALL, "Unknown Chip Type 0x%x", i);
d297 1
a297 1
			isp_prt(isp, ISP_LOGCONFIG, "Differential Mode");
d309 1
a309 1
			isp_prt(isp, ISP_LOGCONFIG, "Ultra Mode Capable");
a335 5
	 * Clear instrumentation
	 */
	isp->isp_intcnt = isp->isp_intbogus = 0;

	/*
d352 9
a360 1
		USEC_DELAY(100);
d376 1
a376 1
		USEC_DELAY(100);
d401 1
a401 1
		USEC_DELAY(100);
d403 1
a403 1
			ISP_DUMPREGS(isp, "chip reset timed out");
d423 1
a423 3
	USEC_DELAY(100);
	/* Clear semaphore register (just to be sure) */
	ISP_WRITE(isp, BIU_SEMA, 0);
a460 3
		if (IS_2200(isp)) {
			ISP_WRITE(isp, HCCR, HCCR_2X00_DISABLE_PARITY_PAUSE);
		}
d475 1
a475 1
		USEC_DELAY(100);
d477 2
a478 2
			isp_prt(isp, ISP_LOGERR,
			    "MBOX_BUSY never cleared on reset");
d493 1
a493 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d495 1
d506 1
a506 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d508 2
d515 1
a515 4
			isp_prt(isp, ISP_LOGERR,
			    "Register Test Failed (0x%x 0x%x 0x%x 0x%x 0x%x)",
			    mbs.param[1], mbs.param[2], mbs.param[3],
			    mbs.param[4], mbs.param[5]);
d536 3
a538 1
		u_int16_t fwlen  = isp->isp_mdvec->dv_ispfw[3];
d541 1
a541 1
			mbs.param[1] = ISP_CODE_ORG + i;
d543 1
a543 1
			isp_mboxcmd(isp, &mbs, MBLOGNONE);
d545 2
a546 2
				isp_prt(isp, ISP_LOGERR,
				    "F/W download failed at word %d", i);
d556 2
a557 2
		mbs.param[1] = ISP_CODE_ORG;
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
d559 1
a559 1
			isp_prt(isp, ISP_LOGERR, "Ram Checksum Failure");
a561 1
		isp->isp_loaded_fw = 1;
d563 1
a563 2
		isp->isp_loaded_fw = 0;
		isp_prt(isp, ISP_LOGDEBUG2, "skipping f/w download");
d574 5
a578 4
	mbs.param[1] = ISP_CODE_ORG;
	isp_mboxcmd(isp, &mbs, MBLOGNONE);
	/* give it a chance to start */
	USEC_SLEEP(isp, 500);
d587 6
a592 2
			isp_mboxcmd(isp, &mbs, MBLOGALL);
			/* we will try not to care if this fails */
a594 1

d596 1
a596 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d598 1
d601 3
a603 4
	isp_prt(isp, ISP_LOGCONFIG,
	    "Board Revision %s, %s F/W Revision %d.%d.%d", revname,
	    dodnld? "loaded" : "resident", mbs.param[1], mbs.param[2],
	    mbs.param[3]);
a604 2
		isp_prt(isp, ISP_LOGCONFIG, "Firmware Attributes = 0x%x",
		    mbs.param[6]);
d606 1
a606 2
			isp_prt(isp, ISP_LOGCONFIG,
			    "Installed in 64-Bit PCI slot");
d615 1
a615 1
		isp_prt(isp, ISP_LOGCONFIG, "Last F/W revision was %d.%d.%d",
d621 1
a621 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d623 1
d627 2
a628 2
	isp_prt(isp, ISP_LOGINFO,
	    "%d max I/O commands supported", mbs.param[2]);
d635 1
a635 1
		isp_prt(isp, ISP_LOGERR, "Cannot setup DMA");
a638 38

	/*
	 * Okay- now that we have new firmware running, we now (re)set our
	 * notion of how many luns we support. This is somewhat tricky because
	 * if we haven't loaded firmware, we don't have an easy way of telling
	 * how many luns we support.
	 *
	 * We'll make a simplifying assumption- if we loaded firmware, we
	 * are running with expanded lun firmware, otherwise not.
	 *
	 * Expanded lun firmware gives you 32 luns for SCSI cards and
	 * 65536 luns for Fibre Channel cards.
	 *
	 * Because the lun is in a a different position in the Request Queue
	 * Entry structure for Fibre Channel with expanded lun firmware, we
	 * can only support one lun (lun zero) when we don't know what kind
	 * of firmware we're running.
	 *
	 * Note that we only do this once (the first time thru isp_reset)
	 * because we may be called again after firmware has been loaded once
	 * and released.
	 */
	if (touched == 0) {
		if (dodnld) {
			if (IS_SCSI(isp)) {
				isp->isp_maxluns = 32;
			} else {
				isp->isp_maxluns = 65536;
			}
		} else {
			if (IS_SCSI(isp)) {
				isp->isp_maxluns = 8;
			} else {
				isp_prt(isp, ISP_LOGALL, warnlun);
				isp->isp_maxluns = 1;
			}
		}
	}
d648 2
a649 1
isp_init(struct ispsoftc *isp)
d658 1
d667 2
a668 1
isp_scsi_init(struct ispsoftc *isp)
a678 7
	/*
	 * If we have no role (neither target nor initiator), return.
	 */
	if (isp->isp_role == ISP_ROLE_NONE) {
		return;
	}

d684 1
a684 1
	if (sdp_chan0->isp_fast_mttr) {
d698 1
a698 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d700 2
d711 1
a711 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d713 2
d729 1
a729 1
	isp_mboxcmd(isp, &mbs, MBLOGNONE);
d731 2
a732 2
		isp_prt(isp, ISP_LOGERR,
		    "failed to set active negation state (%d,%d), (%d,%d)",
d748 1
a748 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d750 3
a752 2
		isp_prt(isp, ISP_LOGERR, "failed to set tag age limit (%d,%d)",
		    sdp_chan0->isp_tag_aging, sdp_chan1->isp_tag_aging);
d762 1
a762 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d764 1
d778 1
a778 1
	mbs.param[1] = RESULT_QUEUE_LEN(isp);
d783 1
a783 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d785 1
d788 1
a788 1
	isp->isp_residx = mbs.param[5];
d791 1
a791 1
	mbs.param[1] = RQUEST_QUEUE_LEN(isp);
d795 2
a796 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d798 1
d801 1
a801 1
	isp->isp_reqidx = isp->isp_reqodx = mbs.param[4];
d820 7
a826 4
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			isp_prt(isp, ISP_LOGINFO,
			    "Enabled FW features (0x%x)", sfeat);
d837 3
a839 1
isp_scsi_channel_init(struct ispsoftc *isp, int channel)
d853 1
a853 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d855 2
a858 3
	isp_prt(isp, ISP_LOGINFO, "Initiator ID is %d on Channel %d",
	    sdp->isp_initiator_id, channel);

d864 1
a864 1
		int lun;
d868 2
d872 7
a878 3
#ifndef	ISP_TARGET_MODE
		if (tgt == sdp->isp_initiator_id) {
			sdf = DPARM_DEFAULT;
d880 1
d882 1
d885 2
a886 3
			 * we could force narrow and async for 1000/1020 cards,
			 * but assume that this is only the case for loaded
			 * firmware.
d888 3
a890 1
			if (isp->isp_loaded_fw) {
a893 11
#else
		/*
		 * The !$*!)$!$)* f/w uses the same index into some
		 * internal table to decide how to respond to negotiations,
		 * so if we've said "let's be safe" for ID X, and ID X
		 * selects *us*, the negotiations will back to 'safe'
		 * (as in narrow/async). What the f/w *should* do is
		 * use the initiator id settings to decide how to respond.
		 */
		sdf = DPARM_DEFAULT;
#endif
d895 1
a895 1
		mbs.param[1] = (channel << 15) | (tgt << 8);
d897 4
a900 12
		if ((sdf & DPARM_SYNC) == 0) {
			mbs.param[3] = 0;
		} else {
			mbs.param[3] =
			    (sdp->isp_devparam[tgt].sync_offset << 8) |
			    (sdp->isp_devparam[tgt].sync_period);
		}
		isp_prt(isp, ISP_LOGDEBUG0,
		    "bus %d set tgt %d flags 0x%x off 0x%x period 0x%x",
		    channel, tgt, mbs.param[2], mbs.param[3] >> 8,
		    mbs.param[3] & 0xff);
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
d906 4
a909 2
			mbs.param[3] = 0;
			isp_mboxcmd(isp, &mbs, MBLOGALL);
d911 2
d917 31
a948 5
		 * We don't update any information directly from the f/w
		 * because we need to run at least one command to cause a
		 * new state to be latched up. So, we just assume that we
		 * converge to the values we just had set.
		 *
d954 8
a961 2
		sdp->isp_devparam[tgt].cur_dflags = sdf & ~DPARM_TQING;
		for (lun = 0; lun < (int) isp->isp_maxluns; lun++) {
d966 1
a966 1
			isp_mboxcmd(isp, &mbs, MBLOGALL);
d968 3
a974 7
	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		if (sdp->isp_devparam[tgt].dev_refresh) {
			isp->isp_sendmarker |= (1 << channel);
			isp->isp_update |= (1 << channel);
			break;
		}
	}
d983 2
a984 1
isp_fibre_init(struct ispsoftc *isp)
a989 1
	u_int64_t nwwn, pwwn;
d994 6
a999 1
	 * Do this *before* initializing the firmware.
d1001 5
a1005 10
	isp_mark_getpdb_all(isp);
	fcp->isp_fwstate = FW_CONFIG_WAIT;
	fcp->isp_loopstate = LOOP_NIL;

	/*
	 * If we have no role (neither target nor initiator), return.
	 */
	if (isp->isp_role == ISP_ROLE_NONE) {
		return;
	}
a1006 1
	loopid = DEFAULT_LOOPID(isp);
d1011 6
a1016 8

	/*
	 * Firmware Options are either retrieved from NVRAM or
	 * are patched elsewhere. We check them for sanity here
	 * and make changes based on board revision, but otherwise
	 * let others decide policy.
	 */

d1023 2
a1024 1

d1028 1
a1028 1
	 * a LIP- this is a known f/w bug for 2100 f/w less than 1.17.0.
d1033 5
d1040 2
a1041 7
	 * Insist on Port Database Update Async notifications
	 */
	fcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;

	
	/*
	 * Make sure that target role reflects into fwoptions.
a1042 5
	if (isp->isp_role & ISP_ROLE_TARGET) {
		fcp->isp_fwoptions |= ICBOPT_TGT_ENABLE;
	} else {
		fcp->isp_fwoptions &= ~ICBOPT_TGT_ENABLE;
	}
a1043 3
	/*
	 * Propagate all of this into the ICB structure.
	 */
d1048 2
a1049 3
		isp_prt(isp, ISP_LOGERR,
		    "bad frame length (%d) from NVRAM- using %d",
		    fcp->isp_maxfrmlen, ICB_DFLT_FRMLEN);
d1054 2
a1055 2
		isp_prt(isp, ISP_LOGERR,
		    "bad maximum allocation (%d)- using 16", fcp->isp_maxalloc);
d1060 2
a1061 3
		isp_prt(isp, ISP_LOGERR,
		    "bad execution throttle of %d- using 16",
		    fcp->isp_execthrottle);
d1067 1
a1067 4
	/*
	 * Right now we just set extended options to prefer point-to-point
	 * over loop based upon some soft config options.
	 */
d1073 1
a1073 2
		switch(isp->isp_confopts & ISP_CFG_PORT_PREF) {
		case ISP_CFG_NPORT:
d1075 1
a1075 8
			break;
		case ISP_CFG_NPORT_ONLY:
			icbp->icb_xfwoptions = ICBXOPT_PTP_ONLY;
			break;
		case ISP_CFG_LPORT_ONLY:
			icbp->icb_xfwoptions = ICBXOPT_LOOP_ONLY;
			break;
		default:
a1076 2
			break;
		}
d1078 1
d1081 21
a1101 12
	nwwn = ISP_NODEWWN(isp);
	pwwn = ISP_PORTWWN(isp);
	if (nwwn && pwwn) {
		icbp->icb_fwoptions |= ICBOPT_BOTH_WWNS;
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, nwwn);
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pwwn);
		isp_prt(isp, ISP_LOGDEBUG1,
		    "Setting ICB Node 0x%08x%08x Port 0x%08x%08x",
		    ((u_int32_t) (nwwn >> 32)),
		    ((u_int32_t) (nwwn & 0xffffffff)),
		    ((u_int32_t) (pwwn >> 32)),
		    ((u_int32_t) (pwwn & 0xffffffff)));
d1103 1
a1103 2
		isp_prt(isp, ISP_LOGDEBUG1, "Not using any WWNs");
		icbp->icb_fwoptions &= ~(ICBOPT_BOTH_WWNS|ICBOPT_FULL_LOGIN);
d1105 2
a1106 2
	icbp->icb_rqstqlen = RQUEST_QUEUE_LEN(isp);
	icbp->icb_rsltqlen = RESULT_QUEUE_LEN(isp);
a1110 2
	isp_prt(isp, ISP_LOGDEBUG1,
	    "isp_fibre_init: fwoptions 0x%x", fcp->isp_fwoptions);
a1112 1

d1114 1
a1114 1
	 * Init the firmware
d1116 25
a1140 11
	mbs.param[0] = MBOX_INIT_FIRMWARE;
	mbs.param[1] = 0;
	mbs.param[2] = DMA_MSW(fcp->isp_scdma);
	mbs.param[3] = DMA_LSW(fcp->isp_scdma);
	mbs.param[4] = 0;
	mbs.param[5] = 0;
	mbs.param[6] = 0;
	mbs.param[7] = 0;
	isp_mboxcmd(isp, &mbs, MBLOGALL);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		return;
d1142 1
a1159 28
static int
isp_getmap(struct ispsoftc *isp, fcpos_map_t *map)
{
	fcparam *fcp = (fcparam *) isp->isp_param;
	mbreg_t mbs;

	mbs.param[0] = MBOX_GET_FC_AL_POSITION_MAP;
	mbs.param[1] = 0;
	mbs.param[2] = DMA_MSW(fcp->isp_scdma);
	mbs.param[3] = DMA_LSW(fcp->isp_scdma);
	/*
	 * Unneeded. For the 2100, except for initializing f/w, registers
	 * 4/5 have to not be written to.
	 *	mbs.param[4] = 0;
	 *	mbs.param[5] = 0;
	 *
	 */
	mbs.param[6] = 0;
	mbs.param[7] = 0;
	isp_mboxcmd(isp, &mbs, MBLOGALL & ~MBOX_COMMAND_PARAM_ERROR);
	if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
		MEMCPY(map, fcp->isp_scratch, sizeof (fcpos_map_t));
		map->fwmap = mbs.param[1] != 0;
		return (0);
	}
	return (-1);
}

d1161 2
a1162 1
isp_mark_getpdb_all(struct ispsoftc *isp)
d1167 1
a1167 1
		fcp->portdb[i].valid = fcp->portdb[i].fabric_dev = 0;
d1172 4
a1175 1
isp_getpdb(struct ispsoftc *isp, int id, isp_pdb_t *pdbp)
d1193 4
a1196 2
	isp_mboxcmd(isp, &mbs, MBLOGALL & ~MBOX_COMMAND_PARAM_ERROR);
	if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
d1198 13
a1210 1
		return (0);
d1212 1
a1212 1
	return (-1);
d1216 4
a1219 1
isp_get_portname(struct ispsoftc *isp, int loopid, int nodename)
d1228 1
a1228 1
	isp_mboxcmd(isp, &mbs, MBLOGALL & ~MBOX_COMMAND_PARAM_ERROR);
d1248 3
a1250 1
isp_fclink_test(struct ispsoftc *isp, int usdelay)
d1256 1
a1256 2
		"F Port",
		"F Port (no FLOGI_ACC response)"
d1259 1
a1259 1
	int count, check_for_fabric;
d1262 1
a1262 1
	struct lportdb *lp;
d1264 1
a1264 1

a1267 4
	 * XXX: Here is where we would start a 'loop dead' timeout
	 */

	/*
d1271 1
a1271 7
	count = 0;
	while (count < usdelay) {
		u_int64_t enano;
		u_int32_t wrk;
		NANOTIME_T hra, hrb;

		GET_NANOTIME(&hra);
d1274 2
a1275 2
			isp_prt(isp, ISP_LOGINFO, "Firmware State <%s->%s>",
			    isp2100_fw_statename((int)lwfs),
d1282 1
a1282 40
		GET_NANOTIME(&hrb);

		/*
		 * Get the elapsed time in nanoseconds.
		 * Always guaranteed to be non-zero.
		 */
		enano = NANOTIME_SUB(&hrb, &hra);

		isp_prt(isp, ISP_LOGDEBUG1,
		    "usec%d: 0x%lx->0x%lx enano 0x%x%08x",
		    count, (long) GET_NANOSEC(&hra), (long) GET_NANOSEC(&hrb),
		    (u_int32_t)(enano >> 32), (u_int32_t)(enano & 0xffffffff));

		/*
		 * If the elapsed time is less than 1 millisecond,
		 * delay a period of time up to that millisecond of
		 * waiting.
		 *
		 * This peculiar code is an attempt to try and avoid
		 * invoking u_int64_t math support functions for some
		 * platforms where linkage is a problem.
		 */
		if (enano < (1000 * 1000)) {
			count += 1000;
			enano = (1000 * 1000) - enano;
			while (enano > (u_int64_t) 4000000000U) {
				USEC_SLEEP(isp, 4000000);
				enano -= (u_int64_t) 4000000000U;
			}
			wrk = enano;
			wrk /= 1000;
			USEC_SLEEP(isp, wrk);
		} else {
			while (enano > (u_int64_t) 4000000000U) {
				count += 4000000;
				enano -= (u_int64_t) 4000000000U;
			}
			wrk = enano;
			count += (wrk / 1000);
		}
d1296 1
a1296 1
	isp_mboxcmd(isp, &mbs, MBLOGALL);
d1298 1
d1303 3
a1305 4
		int topo = (int) mbs.param[6];
		if (topo < TOPO_NL_PORT || topo > TOPO_PTP_STUB)
			topo = TOPO_PTP_STUB;
		fcp->isp_topo = topo;
d1307 1
a1307 1
		fcp->isp_topo = TOPO_NL_PORT;
a1308 1
	fcp->isp_portid = fcp->isp_alpa = mbs.param[2] & 0xff;
d1311 2
a1312 4
	 * Check to see if we're on a fabric by trying to see if we
	 * can talk to the fabric name server. This can be a bit
	 * tricky because if we're a 2100, we should check always
	 * (in case we're connected to an server doing aliasing).
d1314 2
d1317 4
d1322 6
a1327 6
	if (IS_2100(isp))
		check_for_fabric = 1;
	else if (fcp->isp_topo == TOPO_FL_PORT || fcp->isp_topo == TOPO_F_PORT)
		check_for_fabric = 1;
	else
		check_for_fabric = 0;
d1329 15
a1343 4
	if (check_for_fabric && isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {
		int loopid = FL_PORT_ID;
		if (IS_2100(isp)) {
			fcp->isp_topo = TOPO_FL_PORT;
d1345 11
d1357 8
a1364 8
		if (BITS2WORD(pdb.pdb_portid_bits) == 0) {
			/*
			 * Crock.
			 */
			fcp->isp_topo = TOPO_NL_PORT;
			goto not_on_fabric;
		}
		fcp->isp_portid = mbs.param[2] | ((int) mbs.param[3] << 16);
d1366 7
a1372 96
		/*
		 * Save the Fabric controller's port database entry.
		 */
		lp = &fcp->portdb[loopid];
		lp->node_wwn =
		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_nodename[7]));
		lp->port_wwn =
		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_portname[7]));
		lp->roles =
		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
		lp->portid = BITS2WORD(pdb.pdb_portid_bits);
		lp->loopid = pdb.pdb_loopid;
		lp->loggedin = lp->valid = 1;
		fcp->isp_onfabric = 1;
		(void) isp_async(isp, ISPASYNC_PROMENADE, &loopid);
		isp_register_fc4_type(isp);
	} else {
not_on_fabric:
		fcp->isp_onfabric = 0;
		fcp->portdb[FL_PORT_ID].valid = 0;
	}

	isp_prt(isp, ISP_LOGINFO, topology, fcp->isp_loopid, fcp->isp_alpa,
	    fcp->isp_portid, fcp->isp_loopstate, toponames[fcp->isp_topo]);

	/*
	 * Announce ourselves, too. This involves synthesizing an entry.
	 */
	if (fcp->isp_iid_set == 0) {
		fcp->isp_iid_set = 1;
		fcp->isp_iid = fcp->isp_loopid;
		lp = &fcp->portdb[fcp->isp_iid];
	} else {
		lp = &fcp->portdb[fcp->isp_iid];
		if (fcp->isp_portid != lp->portid ||
		    fcp->isp_loopid != lp->loopid ||
		    fcp->isp_nodewwn != ISP_NODEWWN(isp) ||
		    fcp->isp_portwwn != ISP_PORTWWN(isp)) {
			lp->valid = 0;
			count = fcp->isp_iid;
			(void) isp_async(isp, ISPASYNC_PROMENADE, &count);
		}
	}
	lp->loopid = fcp->isp_loopid;
	lp->portid = fcp->isp_portid;
	lp->node_wwn = ISP_NODEWWN(isp);
	lp->port_wwn = ISP_PORTWWN(isp);
	switch (isp->isp_role) {
	case ISP_ROLE_NONE:
		lp->roles = 0;
		break;
	case ISP_ROLE_TARGET:
		lp->roles = SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT;
		break;
	case ISP_ROLE_INITIATOR:
		lp->roles = SVC3_INI_ROLE >> SVC3_ROLE_SHIFT;
		break;
	case ISP_ROLE_BOTH:
		lp->roles = (SVC3_INI_ROLE|SVC3_TGT_ROLE) >> SVC3_ROLE_SHIFT;
		break;
	}
	lp->loggedin = lp->valid = 1;
	count = fcp->isp_iid;
	(void) isp_async(isp, ISPASYNC_PROMENADE, &count);
	return (0);
}

static char *
isp2100_fw_statename(int state)
{
	switch(state) {
	case FW_CONFIG_WAIT:	return "Config Wait";
	case FW_WAIT_AL_PA:	return "Waiting for AL_PA";
	case FW_WAIT_LOGIN:	return "Wait Login";
	case FW_READY:		return "Ready";
	case FW_LOSS_OF_SYNC:	return "Loss Of Sync";
	case FW_ERROR:		return "Error";
	case FW_REINIT:		return "Re-Init";
	case FW_NON_PART:	return "Nonparticipating";
	default:		return "?????";
	}
}
d1380 3
a1382 1
isp_pdb_sync(struct ispsoftc *isp)
d1384 1
a1384 1
	struct lportdb *lp;
d1387 1
a1387 1
	int loopid, base, lim;
d1389 1
d1391 2
a1392 1
	 * Make sure we're okay for doing this right now.
a1393 16
	if (fcp->isp_loopstate != LOOP_PDB_RCVD &&
	    fcp->isp_loopstate != LOOP_FSCAN_DONE && 
	    fcp->isp_loopstate != LOOP_LSCAN_DONE) {
		return (-1);
	}

	if (fcp->isp_topo == TOPO_FL_PORT || fcp->isp_topo == TOPO_NL_PORT ||
	    fcp->isp_topo == TOPO_N_PORT) {
		if (fcp->isp_loopstate < LOOP_LSCAN_DONE) {
			if (isp_scan_loop(isp) != 0) {
				return (-1);
			}
		}
	}
	fcp->isp_loopstate = LOOP_SYNCING_PDB;

d1395 1
a1395 2
	 * If we get this far, we've settled our differences with the f/w
	 * (for local loop device) and we can say that the loop state is ready.
d1397 3
a1400 306
	if (fcp->isp_topo == TOPO_NL_PORT) {
		fcp->loop_seen_once = 1;
		fcp->isp_loopstate = LOOP_READY;
		return (0);
	}

	/*
	 * Find all Fabric Entities that didn't make it from one scan to the
	 * next and let the world know they went away. Scan the whole database.
	 */
	for (lp = &fcp->portdb[0]; lp < &fcp->portdb[MAX_FC_TARG]; lp++) {
		if (lp->was_fabric_dev && lp->fabric_dev == 0) {
			loopid = lp - fcp->portdb;
			lp->valid = 0;	/* should already be set */
			(void) isp_async(isp, ISPASYNC_PROMENADE, &loopid);
			MEMZERO((void *) lp, sizeof (*lp));
			continue;
		}
		lp->was_fabric_dev = lp->fabric_dev;
	}

	if (fcp->isp_topo == TOPO_FL_PORT)
		base = FC_SNS_ID+1;
	else
		base = 0;

	if (fcp->isp_topo == TOPO_N_PORT)
		lim = 1;
	else
		lim = MAX_FC_TARG;

	/*
	 * Now log in any fabric devices that the outer layer has
	 * left for us to see. This seems the most sane policy
	 * for the moment.
	 */
	for (lp = &fcp->portdb[base]; lp < &fcp->portdb[lim]; lp++) {
		u_int32_t portid;
		mbreg_t mbs;

		loopid = lp - fcp->portdb;
		if (loopid >= FL_PORT_ID && loopid <= FC_SNS_ID) {
			continue;
		}

		/*
		 * Anything here?
		 */
		if (lp->port_wwn == 0) {
			continue;
		}

		/*
		 * Don't try to log into yourself.
		 */
		if ((portid = lp->portid) == fcp->isp_portid) {
			continue;
		}


		/*
		 * If we'd been logged in- see if we still are and we haven't
		 * changed. If so, no need to log ourselves out, etc..
		 *
		 * Unfortunately, our charming Qlogic f/w has decided to
		 * return a valid port database entry for a fabric device
		 * that has, in fact, gone away. And it hangs trying to
		 * log it out.
		 */
		if (lp->loggedin &&
		    isp_getpdb(isp, lp->loopid, &pdb) == 0) {
			int nrole;
			u_int64_t nwwnn, nwwpn;
			nwwnn = 
			    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
			    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
			    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
			    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
			    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
			    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
			    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
			    (((u_int64_t)pdb.pdb_nodename[7]));
			nwwpn = 
			    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
			    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
			    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
			    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
			    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
			    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
			    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
			    (((u_int64_t)pdb.pdb_portname[7]));
			nrole = (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >>
			    SVC3_ROLE_SHIFT;
			if (pdb.pdb_loopid == lp->loopid && lp->portid ==
			    (u_int32_t) BITS2WORD(pdb.pdb_portid_bits) &&
			    nwwnn == lp->node_wwn && nwwpn == lp->port_wwn &&
			    lp->roles == nrole) {
				lp->loggedin = lp->valid = 1;
				isp_prt(isp, ISP_LOGINFO, lretained,
				    (int) (lp - fcp->portdb),
				    (int) lp->loopid, lp->portid);
				continue;
			}
		}

		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
			return (-1);
		}

		/*
		 * Force a logout if we were logged in.
		 */
		if (lp->loggedin) {
			if (isp_getpdb(isp, lp->loopid, &pdb) == 0) {
				mbs.param[0] = MBOX_FABRIC_LOGOUT;
				mbs.param[1] = lp->loopid << 8;
				mbs.param[2] = 0;
				mbs.param[3] = 0;
				isp_mboxcmd(isp, &mbs, MBLOGNONE);
				lp->loggedin = 0;
				isp_prt(isp, ISP_LOGINFO, plogout,
				    (int) (lp - fcp->portdb), lp->loopid,
				    lp->portid);
			}
			lp->loggedin = 0;
			if (fcp->isp_fwstate != FW_READY ||
			    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
				return (-1);
			}
		}

		/*
		 * And log in....
		 */
		loopid = lp - fcp->portdb;
		lp->loopid = FL_PORT_ID;
		do {
			mbs.param[0] = MBOX_FABRIC_LOGIN;
			mbs.param[1] = loopid << 8;
			mbs.param[2] = portid >> 16;
			mbs.param[3] = portid & 0xffff;
			if (IS_2200(isp)) {
				/* only issue a PLOGI if not logged in */
				mbs.param[1] |= 0x1;
			}
			isp_mboxcmd(isp, &mbs, MBLOGALL & ~(MBOX_LOOP_ID_USED |
			    MBOX_PORT_ID_USED | MBOX_COMMAND_ERROR));
			if (fcp->isp_fwstate != FW_READY ||
			    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
				return (-1);
			}
			switch (mbs.param[0]) {
			case MBOX_LOOP_ID_USED:
				/*
				 * Try the next available loop id.
				 */
				loopid++;
				break;
			case MBOX_PORT_ID_USED:
				/*
				 * This port is already logged in.
				 * Snaffle the loop id it's using if it's
				 * nonzero, otherwise we're hosed.
				 */
				if (mbs.param[1] != 0) {
					loopid = mbs.param[1];
					isp_prt(isp, ISP_LOGINFO, retained,
					    loopid, (int) (lp - fcp->portdb),
					    lp->portid);
				} else {
					loopid = MAX_FC_TARG;
					break;
				}
				/* FALLTHROUGH */
			case MBOX_COMMAND_COMPLETE:
				lp->loggedin = 1;
				lp->loopid = loopid;
				break;
			case MBOX_COMMAND_ERROR:
				isp_prt(isp, ISP_LOGINFO, plogierr,
				    portid, mbs.param[1]);
				/* FALLTHROUGH */
			case MBOX_ALL_IDS_USED: /* We're outta IDs */
			default:
				loopid = MAX_FC_TARG;
				break;
			}
		} while (lp->loopid == FL_PORT_ID && loopid < MAX_FC_TARG);

		/*
		 * If we get here and we haven't set a Loop ID,
		 * we failed to log into this device.
		 */

		if (lp->loopid == FL_PORT_ID) {
			lp->loopid = 0;
			continue;
		}

		/*
		 * Make sure we can get the approriate port information.
		 */
		if (isp_getpdb(isp, lp->loopid, &pdb) != 0) {
			isp_prt(isp, ISP_LOGWARN, nopdb, lp->portid);
			goto dump_em;
		}

		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
			return (-1);
		}

		if (pdb.pdb_loopid != lp->loopid) {
			isp_prt(isp, ISP_LOGWARN, pdbmfail1,
			    lp->portid, pdb.pdb_loopid);
			goto dump_em;
		}

		if (lp->portid != (u_int32_t) BITS2WORD(pdb.pdb_portid_bits)) {
			isp_prt(isp, ISP_LOGWARN, pdbmfail2,
			    lp->portid, BITS2WORD(pdb.pdb_portid_bits));
			goto dump_em;
		}

		lp->roles =
		    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;
		lp->node_wwn =
		    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |
		    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |
		    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |
		    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |
		    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |
		    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |
		    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_nodename[7]));
		lp->port_wwn =
		    (((u_int64_t)pdb.pdb_portname[0]) << 56) |
		    (((u_int64_t)pdb.pdb_portname[1]) << 48) |
		    (((u_int64_t)pdb.pdb_portname[2]) << 40) |
		    (((u_int64_t)pdb.pdb_portname[3]) << 32) |
		    (((u_int64_t)pdb.pdb_portname[4]) << 24) |
		    (((u_int64_t)pdb.pdb_portname[5]) << 16) |
		    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |
		    (((u_int64_t)pdb.pdb_portname[7]));
		/*
		 * Check to make sure this all makes sense.
		 */
		if (lp->node_wwn && lp->port_wwn) {
			lp->valid = 1;
			loopid = lp - fcp->portdb;
			(void) isp_async(isp, ISPASYNC_PROMENADE, &loopid);
			continue;
		}
dump_em:
		lp->valid = 0;
		isp_prt(isp, ISP_LOGINFO,
		    ldumped, loopid, lp->loopid, lp->portid);
		mbs.param[0] = MBOX_FABRIC_LOGOUT;
		mbs.param[1] = lp->loopid << 8;
		mbs.param[2] = 0;
		mbs.param[3] = 0;
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate != LOOP_SYNCING_PDB) {
			return (-1);
		}
	}
	/*
	 * If we get here, we've for sure seen not only a valid loop
	 * but know what is or isn't on it, so mark this for usage
	 * in isp_start.
	 */
	fcp->loop_seen_once = 1;
	fcp->isp_loopstate = LOOP_READY;
	return (0);
}

static int
isp_scan_loop(struct ispsoftc *isp)
{
	struct lportdb *lp;
	fcparam *fcp = isp->isp_param;
	isp_pdb_t pdb;
	int loopid, lim, hival;

	switch (fcp->isp_topo) {
	case TOPO_NL_PORT:
		hival = FL_PORT_ID;
		break;
	case TOPO_N_PORT:
		hival = 2;
		break;
	case TOPO_FL_PORT:
		hival = FC_PORT_ID;
		break;
	default:
		fcp->isp_loopstate = LOOP_LSCAN_DONE;
		return (0);
	}
	fcp->isp_loopstate = LOOP_SCANNING_LOOP;

	/*
	 * make sure the temp port database is clean...
	 */
	MEMZERO((void *)fcp->tport, sizeof (fcp->tport));
d1410 1
a1410 8
	for (lim = loopid = 0; loopid < hival; loopid++) {
		lp = &fcp->tport[loopid];

		/*
		 * Don't even try for ourselves...
	 	 */
		if (loopid == fcp->isp_loopid)
			continue;
d1412 6
a1418 2
		if (fcp->isp_loopstate < LOOP_SCANNING_LOOP)
			return (-1);
a1421 2
		if (fcp->isp_loopstate < LOOP_SCANNING_LOOP)
			return (-1);
a1430 2
			if (fcp->isp_loopstate < LOOP_SCANNING_LOOP)
				return (-1);
a1432 3
		if (fcp->isp_loopstate < LOOP_SCANNING_LOOP) {
			return (-1);
		}
d1439 2
d1442 1
a1442 1
			if (lim++ < hival) {
d1445 2
a1446 2
			isp_prt(isp, ISP_LOGWARN,
			    "giving up on synchronizing the port database");
d1475 12
d1490 2
a1491 2
	 * Mark all of the permanent local loop database entries as invalid
	 * (except our own entry).
d1493 6
a1498 6
	for (loopid = 0; loopid < hival; loopid++) {
		if (loopid == fcp->isp_iid) {
			fcp->portdb[loopid].valid = 1;
			fcp->portdb[loopid].loopid = fcp->isp_loopid;
			continue;
		}
d1506 1
a1506 1
	for (loopid = 0; loopid < hival; loopid++) {
d1512 1
a1512 1
		if (fcp->tport[loopid].port_wwn == 0) {
d1517 4
a1520 1
		 * Skip ourselves.
d1522 2
a1523 1
		if (loopid == fcp->isp_iid) {
d1537 1
a1537 1
		for (i = 0; i < hival; i++) {
d1541 1
a1541 2
			if (fcp->portdb[i].port_wwn !=
			    fcp->tport[loopid].port_wwn)
d1550 3
a1552 2
				isp_prt(isp, ISP_LOGINFO, portshift, i,
				    fcp->portdb[i].loopid,
d1554 1
a1554 1
				    fcp->tport[loopid].portid);
d1556 1
a1556 1
			fcp->portdb[i].portid = fcp->tport[loopid].portid;
d1559 4
a1562 1
			fcp->portdb[i].roles = fcp->tport[loopid].roles;
d1568 1
a1568 1
			for (j = i+1; j < hival; j++) {
d1573 3
a1575 1
				isp_prt(isp, ISP_LOGWARN, portdup, j, i);
d1593 153
a1745 1
		if (i < hival) {
d1748 21
a1768 1

d1770 1
a1770 2
		 * We've not found this Port WWN anywhere. It's a new entry.
		 * See if we can leave it where it is (with target == loopid).
d1772 4
a1775 13
		if (fcp->portdb[loopid].port_wwn != 0) {
			for (lim = 0; lim < hival; lim++) {
				if (fcp->portdb[lim].port_wwn == 0)
					break;
			}
			/* "Cannot Happen" */
			if (lim == hival) {
				isp_prt(isp, ISP_LOGWARN, "Remap Overflow");
				continue;
			}
			i = lim;
		} else {
			i = loopid;
d1777 8
a1784 16

		/*
		 * NB:	The actual loopid we use here is loopid- we may
		 *	in fact be at a completely different index (target).
		 */
		fcp->portdb[i].loopid = loopid;
		fcp->portdb[i].port_wwn = fcp->tport[loopid].port_wwn;
		fcp->portdb[i].node_wwn = fcp->tport[loopid].node_wwn;
		fcp->portdb[i].roles = fcp->tport[loopid].roles;
		fcp->portdb[i].portid = fcp->tport[loopid].portid;
		fcp->portdb[i].valid = 1;

		/*
		 * Tell the outside world we've arrived.
		 */
		(void) isp_async(isp, ISPASYNC_PROMENADE, &i);
d1786 1
a1786 1

d1788 3
a1790 2
	 * Now find all previously used targets that are now invalid and
	 * notify the outer layers that they're gone.
d1792 1
a1792 15
	for (lp = &fcp->portdb[0]; lp < &fcp->portdb[hival]; lp++) {
		if (lp->valid || lp->port_wwn == 0) {
			continue;
		}

		/*
		 * Tell the outside world we've gone
		 * away and erase our pdb entry.
		 * 
		 */
		loopid = lp - fcp->portdb;
		(void) isp_async(isp, ISPASYNC_PROMENADE, &loopid);
		MEMZERO((void *) lp, sizeof (*lp));
	}
	fcp->isp_loopstate = LOOP_LSCAN_DONE;
d1796 1
d1798 2
a1799 1
isp_scan_fabric(struct ispsoftc *isp)
d1802 1
a1802 1
	u_int32_t portid, first_portid;
d1806 1
a1806 6
	int hicap, first_portid_seen;

	if (fcp->isp_onfabric == 0) {
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		return (0);
	}
d1810 1
a1810 6
	/*
	 * Since Port IDs are 24 bits, we can check against having seen
	 * anything yet with this value.
	 */
	first_portid = portid = fcp->isp_portid;
	fcp->isp_loopstate = LOOP_SCANNING_FABRIC;
d1812 1
a1812 1
	for (first_portid_seen = hicap = 0; hicap < 65535; hicap++) {
d1830 2
a1831 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d1833 2
a1834 7
			if (fcp->isp_loopstate == LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			return (-1);
		}
		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate < LOOP_SCANNING_FABRIC) {
d1841 7
a1847 3
		(void) isp_async(isp, ISPASYNC_FABRIC_DEV, resp);
		if (first_portid == portid) {
			fcp->isp_loopstate = LOOP_FSCAN_DONE;
a1850 3

	isp_prt(isp, ISP_LOGWARN, "broken fabric nameserver...*wheeze*...");

a1853 1
	fcp->isp_loopstate = LOOP_FSCAN_DONE;
a1855 20

static void
isp_register_fc4_type(struct ispsoftc *isp)
{
	fcparam *fcp = isp->isp_param;
	sns_screq_t *reqp;
	mbreg_t mbs;

	reqp = (sns_screq_t *) fcp->isp_scratch;
	MEMZERO((void *) reqp, SNS_RFT_REQ_SIZE);
	reqp->snscb_rblen = SNS_RFT_RESP_SIZE >> 1;
	reqp->snscb_addr[RQRSP_ADDR0015] = DMA_LSW(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR1631] = DMA_MSW(fcp->isp_scdma + 0x100);
	reqp->snscb_sblen = 22;
	reqp->snscb_data[0] = SNS_RFT;
	reqp->snscb_data[4] = fcp->isp_portid & 0xffff;
	reqp->snscb_data[5] = (fcp->isp_portid >> 16) & 0xff;
	reqp->snscb_data[6] = 0x100;	/* SCS - FCP */
#if	0
	reqp->snscb_data[6] |= 20;	/* ISO/IEC 8802-2 LLC/SNAP */
a1856 13
	ISP_SWIZZLE_SNS_REQ(isp, reqp);
	mbs.param[0] = MBOX_SEND_SNS;
	mbs.param[1] = SNS_RFT_REQ_SIZE >> 1;
	mbs.param[2] = DMA_MSW(fcp->isp_scdma);
	mbs.param[3] = DMA_LSW(fcp->isp_scdma);
	mbs.param[6] = 0;
	mbs.param[7] = 0;
	isp_mboxcmd(isp, &mbs, MBLOGALL);
	if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGDEBUG0, "Register FC4 types succeeded");
	}
}

d1861 3
a1863 2
int
isp_start(XS_T *xs)
d1866 1
a1866 1
	u_int16_t iptr, optr, handle;
a1878 13

	/*
	 * Check to make sure we're supporting initiator role.
	 */
	if ((isp->isp_role & ISP_ROLE_INITIATOR) == 0) {
		XS_SETERR(xs, HBA_SELTIMEOUT);
		return (CMD_COMPLETE);
	}

	/*
	 * Now make sure we're running.
	 */

d1880 1
a1880 1
		isp_prt(isp, ISP_LOGERR, "Adapter not at RUNSTATE");
d1893 2
a1894 3
		isp_prt(isp, ISP_LOGERR,
		    "unsupported cdb length (%d, CDB[0]=0x%x)",
		    XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);
d1907 8
a1914 28
#ifdef	HANDLE_LOOPSTATE_IN_OUTER_LAYERS
		if (fcp->isp_fwstate != FW_READY ||
		    fcp->isp_loopstate != LOOP_READY) {
			return (CMD_RQLATER);
		}

		/*
		 * If we're not on a Fabric, we can't have a target
		 * above FL_PORT_ID-1.
		 *
		 * If we're on a fabric and *not* connected as an F-port,
		 * we can't have a target less than FC_SNS_ID+1. This
		 * keeps us from having to sort out the difference between
		 * local public loop devices and those which we might get
		 * from a switch's database.
		 */
		if (fcp->isp_onfabric == 0) {
			if (target >= FL_PORT_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
		} else {
			if (target >= FL_PORT_ID && target <= FC_SNS_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
			if (fcp->isp_topo != TOPO_F_PORT &&
			    target < FL_PORT_ID) {
d1919 1
a1919 1
#else
d1933 1
a1933 4
			/*
			 * Give ourselves at most a 250ms delay.
			 */
			if (isp_fclink_test(isp, 250000)) {
a1943 27
		 * If we're not on a Fabric, we can't have a target
		 * above FL_PORT_ID-1.
		 *
		 * If we're on a fabric and *not* connected as an F-port,
		 * we can't have a target less than FC_SNS_ID+1. This
		 * keeps us from having to sort out the difference between
		 * local public loop devices and those which we might get
		 * from a switch's database.
		 */
		if (fcp->isp_onfabric == 0) {
			if (target >= FL_PORT_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
		} else {
			if (target >= FL_PORT_ID && target <= FC_SNS_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
			if (fcp->isp_topo != TOPO_F_PORT &&
			    target < FL_PORT_ID) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
			}
		}

		/*
a1960 26
		 * If we're in the middle of loop or fabric scanning
		 * or merging the port databases, retry this command later.
		 */
		if (fcp->isp_loopstate == LOOP_SCANNING_FABRIC ||
		    fcp->isp_loopstate == LOOP_SCANNING_LOOP ||
		    fcp->isp_loopstate == LOOP_SYNCING_PDB) {
			return (CMD_RQLATER);
		}

		/*
		 * If our loop state is now such that we've just now
		 * received a Port Database Change notification, then
		 * we have to go off and (re)scan the fabric. We back
		 * out and try again later if this doesn't work.
		 */
		if (fcp->isp_loopstate == LOOP_PDB_RCVD && fcp->isp_onfabric) {
			if (isp_scan_fabric(isp)) {
				return (CMD_RQLATER);
			}
			if (fcp->isp_fwstate != FW_READY ||
			    fcp->isp_loopstate < LOOP_PDB_RCVD) {
				return (CMD_RQLATER);
			}
		}

		/*
d1966 4
a1969 7
		if (fcp->isp_loopstate < LOOP_READY) {
			if (isp_pdb_sync(isp)) {
				return (CMD_RQLATER);
			}
			if (fcp->isp_fwstate != FW_READY ||
			    fcp->isp_loopstate != LOOP_READY) {
				return (CMD_RQLATER);
a1973 6
		 * XXX: Here's were we would cancel any loop_dead flag
		 * XXX: also cancel in dead_loop timeout that's running
		 */
#endif

		/*
d1982 2
a1983 2
			isp_prt(isp, ISP_LOGDEBUG2,
			    "Target %d does not have target service", target);
d1988 1
a1988 1
		 * Now turn target into what the actual Loop ID is.
d2002 1
a2002 1
		isp_prt(isp, ISP_LOGDEBUG0, "Request Queue Overflow");
d2027 1
d2031 2
a2032 2
				isp_prt(isp, ISP_LOGDEBUG0,
				    "Request Queue Overflow+");
d2062 2
a2063 2
		if (XS_TAG_P(xs)) {
			t2reqp->req_flags = XS_TAG_TYPE(xs);
a2064 4
			/*
			 * If we don't know what tag to use, use HEAD OF QUEUE
			 * for Request Sense or Ordered (for safety's sake).
			 */
d2073 2
a2074 2
		    XS_TAG_P(xs)) {
			reqp->req_flags = XS_TAG_TYPE(xs);
d2082 5
a2086 4
		if (isp->isp_maxluns > 16)
			t2reqp->req_scclun = XS_LUN(xs);
		else
			t2reqp->req_lun_trn = XS_LUN(xs);
d2101 2
a2102 2
	if (isp_save_xs(isp, xs, &handle)) {
		isp_prt(isp, ISP_LOGDEBUG1, "out of xflist pointers");
a2105 1
	reqp->req_handle = handle;
d2112 1
a2112 1
		isp_destroy_handle(isp, handle);
d2120 4
a2123 4
	isp_prt(isp, ISP_LOGDEBUG2,
	    "START cmd for %d.%d.%d cmd 0x%x datalen %ld",
	    XS_CHANNEL(xs), target, XS_LUN(xs), XS_CDBP(xs)[0],
	    (long) XS_XFRLEN(xs));
d2139 4
a2142 1
isp_control(struct ispsoftc *isp, ispctl_t ctl, void *arg)
d2144 1
a2144 1
	XS_T *xs;
d2147 1
a2147 1
	u_int16_t handle;
d2151 2
a2152 1
		isp_prt(isp, ISP_LOGERR, "Unknown Control Opcode 0x%x", ctl);
d2173 2
a2174 2
		isp->isp_sendmarker |= (1 << bus);
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d2176 1
d2179 2
a2180 2
		isp_prt(isp, ISP_LOGINFO,
		    "driver initiated bus reset of bus %d", bus);
d2189 1
a2189 1
		isp_mboxcmd(isp, &mbs, MBLOGALL);
d2191 2
d2195 3
a2197 3
		isp_prt(isp, ISP_LOGINFO,
		    "Target %d on Bus %d Reset Succeeded", tgt, bus);
		isp->isp_sendmarker |= (1 << bus);
d2201 1
a2201 2
		xs = (XS_T *) arg;
		tgt = XS_TGT(xs);
d2204 2
a2205 2
			isp_prt(isp, ISP_LOGWARN,
			    "cannot find handle for command to abort");
d2211 8
a2218 8
			if (isp->isp_maxluns > 16) {
				mbs.param[1] = tgt << 8;
				mbs.param[4] = 0;
				mbs.param[5] = 0;
				mbs.param[6] = XS_LUN(xs);
			} else {
				mbs.param[1] = tgt << 8 | XS_LUN(xs);
			}
d2223 7
a2229 5
		mbs.param[3] = 0;
		mbs.param[2] = handle;
		isp_mboxcmd(isp, &mbs, MBLOGALL & ~MBOX_COMMAND_ERROR);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			return (0);
d2231 3
a2233 5
		/*
		 * XXX: Look for command in the REQUEST QUEUE. That is,
		 * XXX: It hasen't been picked up by firmware yet.
		 */
		break;
a2235 1

d2240 1
a2240 20

		if (IS_FC(isp)) {
			int usdelay = (arg)? *((int *) arg) : 250000;
			return (isp_fclink_test(isp, usdelay));
		}
		break;

	case ISPCTL_SCAN_FABRIC:

		if (IS_FC(isp)) {
			return (isp_scan_fabric(isp));
		}
		break;

	case ISPCTL_SCAN_LOOP:

		if (IS_FC(isp)) {
			return (isp_scan_loop(isp));
		}
		break;
d2243 1
a2243 28

		if (IS_FC(isp)) {
			return (isp_pdb_sync(isp));
		}
		break;

	case ISPCTL_SEND_LIP:

		if (IS_FC(isp)) {
			mbs.param[0] = MBOX_INIT_LIP;
			isp_mboxcmd(isp, &mbs, MBLOGALL);
			if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
				return (0);
			}
		}
		break;

	case ISPCTL_GET_POSMAP:

		if (IS_FC(isp) && arg) {
			return (isp_getmap(isp, arg));
		}
		break;

	case ISPCTL_RUN_MBOXCMD:

		isp_mboxcmd(isp, arg, MBLOGALL);
		return(0);
a2246 6
	{

		/*
		 * We don't check/set against role here- that's the
		 * responsibility for the outer layer to coordinate.
		 */
d2248 1
a2248 1
			int param = *(int *)arg;
d2250 2
a2251 3
			mbs.param[1] = param & 0xffff;
			mbs.param[2] = param >> 16;
			isp_mboxcmd(isp, &mbs, MBLOGALL);
d2253 3
a2259 1
	}
a2271 6
/*
 * Limit our stack depth by sticking with the max likely number
 * of completions on a request queue at any one time.
 */
#define	MAX_REQUESTQ_COMPLETIONS	32

d2273 2
a2274 1
isp_intr(void *arg)
d2276 1
d2278 2
a2279 2
	XS_T *complist[MAX_REQUESTQ_COMPLETIONS], *xs;
	u_int16_t iptr, optr, isr, sema, junk;
d2282 5
a2286 20
	if (IS_2100(isp)) {
		i = 0;
		do {
			isr = ISP_READ(isp, BIU_ISR);
			junk = ISP_READ(isp, BIU_ISR);
		} while (isr != junk && ++i < 1000);
		if (isr != junk) {
			isp_prt(isp, ISP_LOGWARN,
			    "isr unsteady (%x, %x)", isr, junk);
		}
		i = 0;
		do {
			sema = ISP_READ(isp, BIU_SEMA);
			junk = ISP_READ(isp, BIU_SEMA);
		} while (sema != junk && ++i < 1000);
		if (sema != junk) {
			isp_prt(isp, ISP_LOGWARN,
			    "sema unsteady (%x, %x)", sema, junk);
		}
	} else {
d2288 6
a2293 1
		sema = ISP_READ(isp, BIU_SEMA);
d2295 2
a2296 6
	isp_prt(isp, ISP_LOGDEBUG3, "isp_intr isr %x sem %x", isr, sema);
	isr &= INT_PENDING_MASK(isp);
	sema &= BIU_SEMA_LOCK;
	isp->isp_intcnt++;
	if (isr == 0 && sema == 0) {
		isp->isp_intbogus++;
d2299 9
d2310 1
a2310 18
		u_int16_t mbox;

		if (IS_2100(isp)) {
			i = 0;
			do {
				mbox = ISP_READ(isp, OUTMAILBOX0);
				junk = ISP_READ(isp, OUTMAILBOX0);;
			} while (junk != mbox && ++i < 1000);
			if (mbox != junk) {
				isp_prt(isp, ISP_LOGWARN,
				    "mailbox0 unsteady (%x, %x)", mbox, junk);
				ISP_WRITE(isp, BIU_SEMA, 0);
				ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
				return (1);
			}
		} else {
			mbox = ISP_READ(isp, OUTMAILBOX0);
		}
d2312 2
a2313 16
			int obits, i = 0;
			if ((obits = isp->isp_mboxbsy) != 0) {
				isp->isp_mboxtmp[i++] = mbox;
				for (i = 1; i < MAX_MAILBOX; i++) {
					if ((obits & (1 << i)) == 0) {
						continue;
					}
					isp->isp_mboxtmp[i] =
					    ISP_READ(isp, MBOX_OFF(i));
				}
				MBOX_NOTIFY_COMPLETE(isp);
			} else {
				isp_prt(isp, ISP_LOGWARN,
				    "Mbox Command Async (0x%x) with no waiters",
				    mbox);
			}
d2315 3
a2317 2
			int fhandle = isp_parse_async(isp, (int) mbox);
			isp_prt(isp, ISP_LOGDEBUG2, "Async Mbox 0x%x", mbox);
d2319 1
a2319 1
				isp_fastpost_complete(isp, (u_int16_t) fhandle);
d2322 1
a2322 14
		if (IS_FC(isp) || isp->isp_state != ISP_RUNSTATE) {
			ISP_WRITE(isp, BIU_SEMA, 0);
			ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
			return (1);
		}
	}

	/*
	 * We can't be getting this now.
	 */
	if (isp->isp_state != ISP_RUNSTATE) {
		isp_prt(isp, ISP_LOGWARN,
		    "interrupt (isr=%x, sema=%x) when not ready", isr, sema);
		ISP_WRITE(isp, INMAILBOX5, ISP_READ(isp, OUTMAILBOX5));
d2324 1
a2324 1
		ISP_WRITE(isp, BIU_SEMA, 0);
d2332 1
a2332 21

	if (IS_2100(isp)) {
		i = 0;
		do {
			iptr = ISP_READ(isp, OUTMAILBOX5);
			junk = ISP_READ(isp, OUTMAILBOX5);
		} while (junk != iptr && ++i < 1000);

		if (iptr != junk) {
			ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
			isp_prt(isp, ISP_LOGWARN,
			    "mailbox5 unsteady (%x, %x)", iptr, junk);
			return (1);
		}
	} else {
		iptr = ISP_READ(isp, OUTMAILBOX5);
	}

	if (sema) {
		ISP_WRITE(isp, BIU_SEMA, 0);
	}
d2334 3
a2336 14

	if (optr == iptr && sema == 0) {
		/*
		 * There are a lot of these- reasons unknown- mostly on
		 * faster Alpha machines.
		 *
		 * I tried delaying after writing HCCR_CMD_CLEAR_RISC_INT to
		 * make sure the old interrupt went away (to avoid 'ringing'
		 * effects), but that didn't stop this from occurring.
		 */
		junk = ISP_READ(isp, BIU_ISR);
		isp_prt(isp, ISP_LOGDEBUG2,
		    "bogus intr- isr %x (%x) iptr %x optr %x",
		    isr, junk, iptr, optr);
d2346 1
a2346 1
		optr = ISP_NXT_QENTRY(optr, RESULT_QUEUE_LEN(isp));
d2348 1
d2352 1
a2352 1
		 * per-platform thing. Also includes any memory barriers.
d2354 1
a2354 1
		ISP_UNSWIZZLE_RESPONSE(isp, sp, oop);
a2356 1
				MEMZERO(sp, sizeof (isphdr_t));
d2365 4
a2368 8
				isp_prt(isp, ISP_LOGERR, notresp,
				    sp->req_header.rqs_entry_type, oop, optr,
				    nlooked);
				if (isp->isp_dblev & ISP_LOGDEBUG0) {
					isp_print_bytes(isp, "Queue Entry",
					    QENTRY_LEN, sp);
				}
				MEMZERO(sp, sizeof (isphdr_t));
d2378 2
a2379 2
				isp_prt(isp, ISP_LOGWARN,
				    "continuation segment");
d2384 2
a2385 2
				isp_prt(isp, ISP_LOGDEBUG1,
				    "internal queues full");
d2391 1
a2391 1
				isp_prt(isp, ISP_LOGERR,  "bad header flag");
d2395 2
a2396 1
				isp_prt(isp, ISP_LOGERR, "bad request packet");
d2400 2
a2401 3
				isp_prt(isp, ISP_LOGERR,
				    "unknown flags (0x%x) in response",
				    sp->req_header.rqs_flags);
d2407 2
a2408 5
			MEMZERO(sp, sizeof (isphdr_t));
			isp_prt(isp, ISP_LOGERR,
			    "bad request handle %d (type 0x%x, flags 0x%x)",
			    sp->req_handle, sp->req_header.rqs_entry_type,
			    sp->req_header.rqs_flags);
d2414 2
a2415 4
			MEMZERO(sp, sizeof (isphdr_t));
			isp_prt(isp, ISP_LOGERR,
			    "cannot find handle 0x%x in xflist",
			    sp->req_handle);
d2426 7
a2432 2

		if (IS_FC(isp) && (sp->req_scsi_status & RQCS_SV)) {
d2434 3
a2436 3
			 * Fibre Channel F/W doesn't say we got status
			 * if there's Sense Data instead. I guess they
			 * think it goes w/o saying.
d2438 16
a2453 1
			sp->req_state_flags |= RQSF_GOT_STATUS;
d2455 2
a2456 2
		if (sp->req_state_flags & RQSF_GOT_STATUS) {
			*XS_STSP(xs) = sp->req_scsi_status & 0xff;
d2459 7
a2465 43
		switch (sp->req_header.rqs_entry_type) {
		case RQSTYPE_RESPONSE:
			XS_SET_STATE_STAT(isp, xs, sp);
			isp_parse_status(isp, sp, xs);
			if ((XS_NOERR(xs) || XS_ERR(xs) == HBA_NOERROR) &&
			    (*XS_STSP(xs) == SCSI_BUSY)) {
				XS_SETERR(xs, HBA_TGTBSY);
			}
			if (IS_SCSI(isp)) {
				XS_RESID(xs) = sp->req_resid;
				if ((sp->req_state_flags & RQSF_GOT_STATUS) &&
				    (*XS_STSP(xs) == SCSI_CHECK) &&
				    (sp->req_state_flags & RQSF_GOT_SENSE)) {
					XS_SAVE_SENSE(xs, sp);
				}
				/*
				 * A new synchronous rate was negotiated for
				 * this target. Mark state such that we'll go
				 * look up that which has changed later.
				 */
				if (sp->req_status_flags & RQSTF_NEGOTIATION) {
					int t = XS_TGT(xs);
					sdparam *sdp = isp->isp_param;
					sdp += XS_CHANNEL(xs);
					sdp->isp_devparam[t].dev_refresh = 1;
					isp->isp_update |=
					    (1 << XS_CHANNEL(xs));
				}
			} else {
				if (sp->req_status_flags & RQSF_XFER_COMPLETE) {
					XS_RESID(xs) = 0;
				} else if (sp->req_scsi_status & RQCS_RESID) {
					XS_RESID(xs) = sp->req_resid;
				} else {
					XS_RESID(xs) = 0;
				}
				if ((sp->req_state_flags & RQSF_GOT_STATUS) &&
				    (*XS_STSP(xs) == SCSI_CHECK) &&
				    (sp->req_scsi_status & RQCS_SV)) {
					XS_SAVE_SENSE(xs, sp);
					/* solely for the benefit of debug */
					sp->req_state_flags |= RQSF_GOT_SENSE;
				}
d2467 1
a2467 5
			isp_prt(isp, ISP_LOGDEBUG2,
			   "asked for %ld got resid %ld", (long) XS_XFRLEN(xs),
			   (long) sp->req_resid);
			break;
		case RQSTYPE_REQUEST:
d2472 1
a2472 1
				*XS_STSP(xs) = SCSI_QFULL;
d2477 3
a2479 6
			XS_RESID(xs) = XS_XFRLEN(xs);
			break;
		default:
			isp_prt(isp, ISP_LOGWARN,
			    "unhandled response queue type 0x%x",
			    sp->req_header.rqs_entry_type);
a2482 1
			break;
d2484 7
a2490 4

		/*
		 * Free any dma resources. As a side effect, this may
		 * also do any cache flushing necessary for data coherence.			 */
d2494 23
a2516 5

		if (((isp->isp_dblev & (ISP_LOGDEBUG2|ISP_LOGDEBUG3))) ||
		    ((isp->isp_dblev & ISP_LOGDEBUG1) && ((!XS_NOERR(xs)) ||
		    (*XS_STSP(xs) != SCSI_GOOD)))) {
			char skey;
d2518 4
a2521 9
				skey = XS_SNSKEY(xs) & 0xf;
				if (skey < 10)
					skey += '0';
				else
					skey += 'a' - 10;
			} else if (*XS_STSP(xs) == SCSI_CHECK) {
				skey = '?';
			} else {
				skey = '.';
d2523 1
a2523 3
			isp_prt(isp, ISP_LOGALL, finmsg, XS_CHANNEL(xs),
			    XS_TGT(xs), XS_LUN(xs), XS_XFRLEN(xs), XS_RESID(xs),
			    *XS_STSP(xs), skey, XS_ERR(xs));
a2528 4
		MEMZERO(sp, sizeof (isphdr_t));
		if (ndone == MAX_REQUESTQ_COMPLETIONS) {
			break;
		}
a2539 1

d2544 1
a2544 1
			isp_done(xs);
d2547 1
d2556 3
a2558 1
isp_parse_async(struct ispsoftc *isp, int mbox)
d2561 1
a2561 1
	u_int16_t fast_post_handle = 0;
d2570 2
d2573 1
a2573 1
		isp->isp_sendmarker |= (1 << bus);
d2581 3
a2583 7
		isp_prt(isp, ISP_LOGERR,
		    "Internal Firmware Error @@ RISC Addr 0x%x", mbox);
		ISP_DUMPREGS(isp, "Firmware Error");
		isp_reinit(isp);
#ifdef	ISP_TARGET_MODE
		isp_target_async(isp, bus, ASYNC_SYSTEM_ERROR);
#endif
d2588 1
a2588 1
		isp_prt(isp, ISP_LOGERR, "Request Queue Transfer Error");
d2592 1
a2592 1
		isp_prt(isp, ISP_LOGERR, "Response Queue Transfer Error");
d2605 3
a2607 3
		isp_prt(isp, ISP_LOGWARN,
		    "timeout initiated SCSI bus reset of bus %d", bus);
		isp->isp_sendmarker |= (1 << bus);
d2614 2
a2615 2
		isp_prt(isp, ISP_LOGINFO, "device reset on bus %d", bus);
		isp->isp_sendmarker |= (1 << bus);
d2622 1
a2622 1
		isp_prt(isp, ISP_LOGWARN, "extended message underrun");
d2626 1
a2626 1
		isp_prt(isp, ISP_LOGINFO, "SCAM interrupt");
d2630 2
a2631 2
		isp_prt(isp, ISP_LOGERR,
		    "stalled SCSI Bus after DATA Overrun");
d2636 2
a2637 1
		isp_prt(isp, ISP_LOGERR, "SCSI Bus reset after DATA Overrun");
d2644 4
a2647 4
			isp_prt(isp, ISP_LOGINFO, "Transition to LVD mode");
			SDPARAM(isp)->isp_diffmode = 0;
			SDPARAM(isp)->isp_ultramode = 0;
			SDPARAM(isp)->isp_lvdmode = 1;
d2650 5
a2654 5
			isp_prt(isp, ISP_LOGINFO,
			    "Transition to Differential mode");
			SDPARAM(isp)->isp_diffmode = 1;
			SDPARAM(isp)->isp_ultramode = 0;
			SDPARAM(isp)->isp_lvdmode = 0;
d2657 5
a2661 5
			isp_prt(isp, ISP_LOGINFO,
			    "Transition to Single Ended mode");
			SDPARAM(isp)->isp_diffmode = 0;
			SDPARAM(isp)->isp_ultramode = 1;
			SDPARAM(isp)->isp_lvdmode = 0;
d2664 2
a2665 2
			isp_prt(isp, ISP_LOGWARN,
			    "Transition to Unknown Mode 0x%x", mbox);
d2672 1
a2672 1
		isp->isp_sendmarker |= (1 << bus);
d2676 4
a2679 3
		fast_post_handle = ISP_READ(isp, OUTMAILBOX1);
		isp_prt(isp, ISP_LOGDEBUG3, "fast post completion of %u",
		    fast_post_handle);
d2683 2
a2684 11
#ifdef	ISP_TARGET_MODE
		/*
		 * Bus gets overloaded with the handle. Dual bus
		 * cards don't put bus# into the handle.
		 */
		bus = (ISP_READ(isp, OUTMAILBOX2) << 16) |
		    ISP_READ(isp, OUTMAILBOX1);
		isp_target_async(isp, bus, mbox);
#else
		isp_prt(isp, ISP_LOGINFO, "Fast Posting CTIO done");
#endif
d2688 1
a2688 1
		FCPARAM(isp)->isp_lipseq =
d2690 2
a2691 2
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_LIP_RCVD;
d2694 1
a2694 1
		isp_prt(isp, ISP_LOGINFO, "LIP occurred");
d2702 2
a2703 2
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_LIP_RCVD;
d2713 2
a2714 2
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_NIL;
d2723 3
a2725 3
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_NIL;
d2727 1
a2727 1
		isp_prt(isp, ISP_LOGINFO, "Loop RESET");
d2735 1
a2735 1
		FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
d2737 1
a2737 1
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_PDB);
d2741 1
d2745 2
a2746 3
		FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
		isp_mark_getpdb_all(isp);
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_SNS);
d2750 1
a2750 13
		if (FCPARAM(isp)->isp_onfabric)
			FCPARAM(isp)->isp_topo = TOPO_F_PORT;
		else
			FCPARAM(isp)->isp_topo = TOPO_N_PORT;
		isp_mark_getpdb_all(isp);
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_LIP_RCVD;
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_OTHER);
#ifdef	ISP_TARGET_MODE
		isp_target_async(isp, bus, mbox);
#endif
		isp_prt(isp, ISP_LOGINFO, "Point-to-Point mode");
a2754 1
		isp_mark_getpdb_all(isp);
d2757 2
a2758 2
			isp_prt(isp, ISP_LOGINFO,
			    "Point-to-Point -> Loop mode");
d2761 2
a2762 2
			isp_prt(isp, ISP_LOGINFO,
			    "Loop -> Point-to-Point mode");
d2765 2
a2766 2
			isp_prt(isp, ISP_LOGWARN,
			    "Point-to-Point -> Loop mode (BAD LIP)");
d2769 2
a2770 5
			isp_prt(isp, ISP_LOGERR, "FATAL CONNECTION ERROR");
			isp_reinit(isp);
#ifdef	ISP_TARGET_MODE
			isp_target_async(isp, bus, ASYNC_SYSTEM_ERROR);
#endif
d2773 1
d2775 2
a2776 7
			isp_prt(isp, ISP_LOGWARN,
			    "Looped Back in Point-to-Point mode");
			break;
		default:
			isp_prt(isp, ISP_LOGWARN,
			    "Unknown connection mode (0x%x)", mbox);
			break;
a2777 4
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_OTHER);
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_fwstate = FW_CONFIG_WAIT;
		FCPARAM(isp)->isp_loopstate = LOOP_LIP_RCVD;
d2781 1
a2781 1
		isp_prt(isp, ISP_LOGWARN, "Unknown Async Code 0x%x", mbox);
d2794 4
a2797 2
isp_handle_other_response(struct ispsoftc *isp,
    ispstatusreq_t *sp, u_int16_t *optrp)
a2799 3
	case RQSTYPE_STATUS_CONT:
		isp_prt(isp, ISP_LOGINFO, "Ignored Continuation Response");
		return (0);
a2812 1
		optrp = optrp;
d2817 1
a2817 4
		if (isp_async(isp, ISPASYNC_UNHANDLED_RESPONSE, sp)) {
			return (0);
		}
		isp_prt(isp, ISP_LOGWARN, "Unhandled Response Type 0x%x",
d2824 4
a2827 1
isp_parse_status(struct ispsoftc *isp, ispstatusreq_t *sp, XS_T *xs)
d2829 1
a2829 1
	switch (sp->req_completion_status & 0xff) {
d2831 1
a2831 3
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_NOERROR);
		}
d2836 4
a2839 6
			isp_prt(isp, ISP_LOGDEBUG1,
			    "Selection Timeout for %d.%d.%d",
			    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
			if (XS_NOERR(xs)) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
			}
d2842 2
a2843 3
		isp_prt(isp, ISP_LOGERR,
		    "command incomplete for %d.%d.%d, state 0x%x",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),
d2848 2
a2849 2
		isp_prt(isp, ISP_LOGERR, "DMA error for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2853 3
a2855 53
	{
		char buf[172];
		buf[0] = 0;
		STRNCAT(buf, "states=>", sizeof buf);
		if (sp->req_state_flags & RQSF_GOT_BUS) {
			STRNCAT(buf, " GOT_BUS", sizeof buf);
		}
		if (sp->req_state_flags & RQSF_GOT_TARGET) {
			STRNCAT(buf, " GOT_TGT", sizeof buf);
		}
		if (sp->req_state_flags & RQSF_SENT_CDB) {
			STRNCAT(buf, " SENT_CDB", sizeof buf);
		}
		if (sp->req_state_flags & RQSF_XFRD_DATA) {
			STRNCAT(buf, " XFRD_DATA", sizeof buf);
		}
		if (sp->req_state_flags & RQSF_GOT_STATUS) {
			STRNCAT(buf, " GOT_STS", sizeof buf);
		}
		if (sp->req_state_flags & RQSF_GOT_SENSE) {
			STRNCAT(buf, " GOT_SNS", sizeof buf);
		}
		if (sp->req_state_flags & RQSF_XFER_COMPLETE) {
			STRNCAT(buf, " XFR_CMPLT", sizeof buf);
		}
		STRNCAT(buf, "\nstatus=>", sizeof buf);
		if (sp->req_status_flags & RQSTF_DISCONNECT) {
			STRNCAT(buf, " Disconnect", sizeof buf);
		}
		if (sp->req_status_flags & RQSTF_SYNCHRONOUS) {
			STRNCAT(buf, " Sync_xfr", sizeof buf);
		}
		if (sp->req_status_flags & RQSTF_PARITY_ERROR) {
			STRNCAT(buf, " Parity", sizeof buf);
		}
		if (sp->req_status_flags & RQSTF_BUS_RESET) {
			STRNCAT(buf, " Bus_Reset", sizeof buf);
		}
		if (sp->req_status_flags & RQSTF_DEVICE_RESET) {
			STRNCAT(buf, " Device_Reset", sizeof buf);
		}
		if (sp->req_status_flags & RQSTF_ABORTED) {
			STRNCAT(buf, " Aborted", sizeof buf);
		}
		if (sp->req_status_flags & RQSTF_TIMEOUT) {
			STRNCAT(buf, " Timeout", sizeof buf);
		}
		if (sp->req_status_flags & RQSTF_NEGOTIATION) {
			STRNCAT(buf, " Negotiation", sizeof buf);
		}
		isp_prt(isp, ISP_LOGERR, "%s", buf);
		isp_prt(isp, ISP_LOGERR, "transport error for %d.%d.%d:\n%s",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs), buf);
d2857 1
a2857 1
	}
d2859 2
a2860 3
		isp_prt(isp, ISP_LOGWARN,
		    "bus reset destroyed command for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2862 1
a2862 3
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_BUSRESET);
		}
d2866 2
a2867 2
		isp_prt(isp, ISP_LOGERR, "command aborted for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2869 1
a2869 3
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_ABORTED);
		}
d2873 3
a2875 5
		isp_prt(isp, ISP_LOGWARN, "command timed out for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_CMDTIMEOUT);
		}
d2879 3
a2881 5
		XS_RESID(xs) = sp->req_resid;
		isp_prt(isp, ISP_LOGERR, "data overrun for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_DATAOVR);
d2883 3
d2889 2
a2890 3
		isp_prt(isp, ISP_LOGERR,
		    "command overrun for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2894 2
a2895 3
		isp_prt(isp, ISP_LOGERR,
		    "status overrun for command on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2899 2
a2900 3
		isp_prt(isp, ISP_LOGERR,
		    "msg not COMMAND COMPLETE after status %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2904 2
a2905 3
		isp_prt(isp, ISP_LOGERR,
		    "No MESSAGE OUT phase after selection on %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2909 2
a2910 2
		isp_prt(isp, ISP_LOGERR, "EXTENDED IDENTIFY failed %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2914 2
a2915 3
		isp_prt(isp, ISP_LOGERR,
		    "INITIATOR DETECTED ERROR rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2919 2
a2920 2
		isp_prt(isp, ISP_LOGERR, "ABORT OPERATION rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2924 2
a2925 2
		isp_prt(isp, ISP_LOGERR, "MESSAGE REJECT rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2929 2
a2930 2
		isp_prt(isp, ISP_LOGERR, "NOP rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2934 2
a2935 3
		isp_prt(isp, ISP_LOGERR,
		    "MESSAGE PARITY ERROR rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2939 2
a2940 3
		isp_prt(isp, ISP_LOGWARN,
		    "BUS DEVICE RESET rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2944 2
a2945 2
		isp_prt(isp, ISP_LOGERR, "IDENTIFY rejected by %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2949 2
a2950 2
		isp_prt(isp, ISP_LOGERR, "%d.%d.%d had an unexpected bus free",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d2954 2
a2955 3
		XS_RESID(xs) = sp->req_resid;
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_NOERROR);
d2957 1
d2961 2
a2962 1
		isp_prt(isp, ISP_LOGERR, xact1, XS_CHANNEL(xs),
d2967 2
a2968 1
		isp_prt(isp, ISP_LOGERR, xact2,
d2973 3
a2975 2
		isp_prt(isp, ISP_LOGERR, xact3, XS_TGT(xs),
		    XS_LUN(xs), XS_CHANNEL(xs));
d2979 1
a2979 1
		isp_prt(isp, ISP_LOGERR, "Invalid IOCB entry type detected");
d2983 3
a2985 3
		isp_prt(isp, ISP_LOGDEBUG1,
		    "internal queues full for %d.%d.%d status 0x%x", XS_TGT(xs),
		    XS_LUN(xs), XS_CHANNEL(xs), *XS_STSP(xs));
d2990 1
a2990 1
		if (*XS_STSP(xs) != SCSI_GOOD && XS_NOERR(xs)) {
d2997 3
a2999 2
		isp_prt(isp, ISP_LOGERR, pskip,
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3003 2
a3004 6
		isp_prt(isp, ISP_LOGERR,
		    "Auto Request Sense failed for %d.%d.%d",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_ARQFAIL);
		}
d3008 2
a3009 3
		isp_prt(isp, ISP_LOGERR,
		    "Wide Negotiation failed for %d.%d.%d",
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3017 1
a3017 3
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_NOERROR);
		}
d3021 2
a3022 3
		isp_prt(isp, ISP_LOGERR,
		    "SDTR Message failed for target %d.%d.%d",
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3033 2
a3034 3
		isp_prt(isp, ISP_LOGERR,
		    "Bad LVD condition while talking to %d.%d.%d",
		    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));
d3041 3
a3043 5
		isp_prt(isp, ISP_LOGINFO,
		    "Port Unavailable for target %d", XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
		}
d3050 3
a3052 5
		isp_prt(isp, ISP_LOGINFO,
		    "port logout for target %d", XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
		}
d3056 3
a3058 5
		isp_prt(isp, ISP_LOGWARN,
		    "port changed for target %d", XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_SELTIMEOUT);
		}
d3062 3
a3064 5
		isp_prt(isp, ISP_LOGWARN,
		    "port busy for target %d", XS_TGT(xs));
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_TGTBSY);
		}
d3068 2
a3069 2
		isp_prt(isp, ISP_LOGERR, "Unknown Completion Status 0x%x",
		    sp->req_completion_status);
d3072 1
a3072 3
	if (XS_NOERR(xs)) {
		XS_SETERR(xs, HBA_BOTCH);
	}
d3076 3
a3078 1
isp_fastpost_complete(struct ispsoftc *isp, u_int16_t fph)
d3080 1
a3080 1
	XS_T *xs;
d3082 1
a3082 1
	if (fph == 0) {
d3087 2
a3088 2
		isp_prt(isp, ISP_LOGWARN,
		    "Command for fast post handle 0x%x not found", fph);
a3097 1
	XS_SET_STATE_STAT(isp, xs, NULL);
d3099 1
a3099 1
	*XS_STSP(xs) = SCSI_GOOD;
d3103 1
a3105 1
	isp_done(xs);
d3108 119
a3226 98
#define	HIBYT(x)			((x) >> 0x8)
#define	LOBYT(x)			((x)  & 0xff)
#define	ISPOPMAP(a, b)			(((a) << 8) | (b))
static u_int16_t mbpscsi[] = {
	ISPOPMAP(0x01, 0x01),	/* 0x00: MBOX_NO_OP */
	ISPOPMAP(0x1f, 0x01),	/* 0x01: MBOX_LOAD_RAM */
	ISPOPMAP(0x03, 0x01),	/* 0x02: MBOX_EXEC_FIRMWARE */
	ISPOPMAP(0x1f, 0x01),	/* 0x03: MBOX_DUMP_RAM */
	ISPOPMAP(0x07, 0x07),	/* 0x04: MBOX_WRITE_RAM_WORD */
	ISPOPMAP(0x03, 0x07),	/* 0x05: MBOX_READ_RAM_WORD */
	ISPOPMAP(0x3f, 0x3f),	/* 0x06: MBOX_MAILBOX_REG_TEST */
	ISPOPMAP(0x03, 0x07),	/* 0x07: MBOX_VERIFY_CHECKSUM	*/
	ISPOPMAP(0x01, 0x4f),	/* 0x08: MBOX_ABOUT_FIRMWARE */
	ISPOPMAP(0x00, 0x00),	/* 0x09: */
	ISPOPMAP(0x00, 0x00),	/* 0x0a: */
	ISPOPMAP(0x00, 0x00),	/* 0x0b: */
	ISPOPMAP(0x00, 0x00),	/* 0x0c: */
	ISPOPMAP(0x00, 0x00),	/* 0x0d: */
	ISPOPMAP(0x01, 0x05),	/* 0x0e: MBOX_CHECK_FIRMWARE */
	ISPOPMAP(0x00, 0x00),	/* 0x0f: */
	ISPOPMAP(0x1f, 0x1f),	/* 0x10: MBOX_INIT_REQ_QUEUE */
	ISPOPMAP(0x3f, 0x3f),	/* 0x11: MBOX_INIT_RES_QUEUE */
	ISPOPMAP(0x0f, 0x0f),	/* 0x12: MBOX_EXECUTE_IOCB */
	ISPOPMAP(0x03, 0x03),	/* 0x13: MBOX_WAKE_UP	*/
	ISPOPMAP(0x01, 0x3f),	/* 0x14: MBOX_STOP_FIRMWARE */
	ISPOPMAP(0x0f, 0x0f),	/* 0x15: MBOX_ABORT */
	ISPOPMAP(0x03, 0x03),	/* 0x16: MBOX_ABORT_DEVICE */
	ISPOPMAP(0x07, 0x07),	/* 0x17: MBOX_ABORT_TARGET */
	ISPOPMAP(0x07, 0x07),	/* 0x18: MBOX_BUS_RESET */
	ISPOPMAP(0x03, 0x07),	/* 0x19: MBOX_STOP_QUEUE */
	ISPOPMAP(0x03, 0x07),	/* 0x1a: MBOX_START_QUEUE */
	ISPOPMAP(0x03, 0x07),	/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
	ISPOPMAP(0x03, 0x07),	/* 0x1c: MBOX_ABORT_QUEUE */
	ISPOPMAP(0x03, 0x4f),	/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
	ISPOPMAP(0x00, 0x00),	/* 0x1e: */
	ISPOPMAP(0x01, 0x07),	/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
	ISPOPMAP(0x01, 0x07),	/* 0x20: MBOX_GET_INIT_SCSI_ID */
	ISPOPMAP(0x01, 0x07),	/* 0x21: MBOX_GET_SELECT_TIMEOUT */
	ISPOPMAP(0x01, 0xc7),	/* 0x22: MBOX_GET_RETRY_COUNT	*/
	ISPOPMAP(0x01, 0x07),	/* 0x23: MBOX_GET_TAG_AGE_LIMIT */
	ISPOPMAP(0x01, 0x03),	/* 0x24: MBOX_GET_CLOCK_RATE */
	ISPOPMAP(0x01, 0x07),	/* 0x25: MBOX_GET_ACT_NEG_STATE */
	ISPOPMAP(0x01, 0x07),	/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */
	ISPOPMAP(0x01, 0x07),	/* 0x27: MBOX_GET_PCI_PARAMS */
	ISPOPMAP(0x03, 0x4f),	/* 0x28: MBOX_GET_TARGET_PARAMS */
	ISPOPMAP(0x03, 0x0f),	/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */
	ISPOPMAP(0x01, 0x07),	/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */
	ISPOPMAP(0x00, 0x00),	/* 0x2b: */
	ISPOPMAP(0x00, 0x00),	/* 0x2c: */
	ISPOPMAP(0x00, 0x00),	/* 0x2d: */
	ISPOPMAP(0x00, 0x00),	/* 0x2e: */
	ISPOPMAP(0x00, 0x00),	/* 0x2f: */
	ISPOPMAP(0x03, 0x03),	/* 0x30: MBOX_SET_INIT_SCSI_ID */
	ISPOPMAP(0x07, 0x07),	/* 0x31: MBOX_SET_SELECT_TIMEOUT */
	ISPOPMAP(0xc7, 0xc7),	/* 0x32: MBOX_SET_RETRY_COUNT	*/
	ISPOPMAP(0x07, 0x07),	/* 0x33: MBOX_SET_TAG_AGE_LIMIT */
	ISPOPMAP(0x03, 0x03),	/* 0x34: MBOX_SET_CLOCK_RATE */
	ISPOPMAP(0x07, 0x07),	/* 0x35: MBOX_SET_ACT_NEG_STATE */
	ISPOPMAP(0x07, 0x07),	/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */
	ISPOPMAP(0x07, 0x07),	/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */
	ISPOPMAP(0x4f, 0x4f),	/* 0x38: MBOX_SET_TARGET_PARAMS */
	ISPOPMAP(0x0f, 0x0f),	/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */
	ISPOPMAP(0x07, 0x07),	/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */
	ISPOPMAP(0x00, 0x00),	/* 0x3b: */
	ISPOPMAP(0x00, 0x00),	/* 0x3c: */
	ISPOPMAP(0x00, 0x00),	/* 0x3d: */
	ISPOPMAP(0x00, 0x00),	/* 0x3e: */
	ISPOPMAP(0x00, 0x00),	/* 0x3f: */
	ISPOPMAP(0x01, 0x03),	/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */
	ISPOPMAP(0x3f, 0x01),	/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */
	ISPOPMAP(0x03, 0x07),	/* 0x42: MBOX_EXEC_BIOS_IOCB */
	ISPOPMAP(0x00, 0x00),	/* 0x43: */
	ISPOPMAP(0x00, 0x00),	/* 0x44: */
	ISPOPMAP(0x03, 0x03),	/* 0x45: SET SYSTEM PARAMETER */
	ISPOPMAP(0x01, 0x03),	/* 0x46: GET SYSTEM PARAMETER */
	ISPOPMAP(0x00, 0x00),	/* 0x47: */
	ISPOPMAP(0x01, 0xcf),	/* 0x48: GET SCAM CONFIGURATION */
	ISPOPMAP(0xcf, 0xcf),	/* 0x49: SET SCAM CONFIGURATION */
	ISPOPMAP(0x03, 0x03),	/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */
	ISPOPMAP(0x01, 0x03),	/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */
	ISPOPMAP(0x00, 0x00),	/* 0x4c: */
	ISPOPMAP(0x00, 0x00),	/* 0x4d: */
	ISPOPMAP(0x00, 0x00),	/* 0x4e: */
	ISPOPMAP(0x00, 0x00),	/* 0x4f: */
	ISPOPMAP(0xdf, 0xdf),	/* 0x50: LOAD RAM A64 */
	ISPOPMAP(0xdf, 0xdf),	/* 0x51: DUMP RAM A64 */
	ISPOPMAP(0xdf, 0xdf),	/* 0x52: INITIALIZE REQUEST QUEUE A64 */
	ISPOPMAP(0xff, 0xff),	/* 0x53: INITIALIZE RESPONSE QUEUE A64 */
	ISPOPMAP(0xcf, 0xff),	/* 0x54: EXECUTE IOCB A64 */
	ISPOPMAP(0x07, 0x01),	/* 0x55: ENABLE TARGET MODE */
	ISPOPMAP(0x03, 0x0f),	/* 0x56: GET TARGET STATUS */
	ISPOPMAP(0x00, 0x00),	/* 0x57: */
	ISPOPMAP(0x00, 0x00),	/* 0x58: */
	ISPOPMAP(0x00, 0x00),	/* 0x59: */
	ISPOPMAP(0x03, 0x03),	/* 0x5a: SET DATA OVERRUN RECOVERY MODE */
	ISPOPMAP(0x01, 0x03),	/* 0x5b: GET DATA OVERRUN RECOVERY MODE */
	ISPOPMAP(0x0f, 0x0f),	/* 0x5c: SET HOST DATA */
	ISPOPMAP(0x01, 0x01)	/* 0x5d: GET NOST DATA */
d3228 31
d3260 24
a3283 97
#ifndef	ISP_STRIPPED
static char *scsi_mbcmd_names[] = {
	"NO-OP",
	"LOAD RAM",
	"EXEC FIRMWARE",
	"DUMP RAM",
	"WRITE RAM WORD",
	"READ RAM WORD",
	"MAILBOX REG TEST",
	"VERIFY CHECKSUM",
	"ABOUT FIRMWARE",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"CHECK FIRMWARE",
	NULL,
	"INIT REQUEST QUEUE",
	"INIT RESULT QUEUE",
	"EXECUTE IOCB",
	"WAKE UP",
	"STOP FIRMWARE",
	"ABORT",
	"ABORT DEVICE",
	"ABORT TARGET",
	"BUS RESET",
	"STOP QUEUE",
	"START QUEUE",
	"SINGLE STEP QUEUE",
	"ABORT QUEUE",
	"GET DEV QUEUE STATUS",
	NULL,
	"GET FIRMWARE STATUS",
	"GET INIT SCSI ID",
	"GET SELECT TIMEOUT",
	"GET RETRY COUNT",
	"GET TAG AGE LIMIT",
	"GET CLOCK RATE",
	"GET ACT NEG STATE",
	"GET ASYNC DATA SETUP TIME",
	"GET PCI PARAMS",
	"GET TARGET PARAMS",
	"GET DEV QUEUE PARAMS",
	"GET RESET DELAY PARAMS",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"SET INIT SCSI ID",
	"SET SELECT TIMEOUT",
	"SET RETRY COUNT",
	"SET TAG AGE LIMIT",
	"SET CLOCK RATE",
	"SET ACT NEG STATE",
	"SET ASYNC DATA SETUP TIME",
	"SET PCI CONTROL PARAMS",
	"SET TARGET PARAMS",
	"SET DEV QUEUE PARAMS",
	"SET RESET DELAY PARAMS",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"RETURN BIOS BLOCK ADDR",
	"WRITE FOUR RAM WORDS",
	"EXEC BIOS IOCB",
	NULL,
	NULL,
	"SET SYSTEM PARAMETER",
	"GET SYSTEM PARAMETER",
	NULL,
	"GET SCAM CONFIGURATION",
	"SET SCAM CONFIGURATION",
	"SET FIRMWARE FEATURES",
	"GET FIRMWARE FEATURES",
	NULL,
	NULL,
	NULL,
	NULL,
	"LOAD RAM A64",
	"DUMP RAM A64",
	"INITIALIZE REQUEST QUEUE A64",
	"INITIALIZE RESPONSE QUEUE A64",
	"EXECUTE IOCB A64",
	"ENABLE TARGET MODE",
	"GET TARGET MODE STATE",
	NULL,
	NULL,
	NULL,
	"SET DATA OVERRUN RECOVERY MODE",
	"GET DATA OVERRUN RECOVERY MODE",
	"SET HOST DATA",
	"GET NOST DATA",
};
d3286 143
a3428 129
static u_int16_t mbpfc[] = {
	ISPOPMAP(0x01, 0x01),	/* 0x00: MBOX_NO_OP */
	ISPOPMAP(0x1f, 0x01),	/* 0x01: MBOX_LOAD_RAM */
	ISPOPMAP(0x03, 0x01),	/* 0x02: MBOX_EXEC_FIRMWARE */
	ISPOPMAP(0xdf, 0x01),	/* 0x03: MBOX_DUMP_RAM */
	ISPOPMAP(0x07, 0x07),	/* 0x04: MBOX_WRITE_RAM_WORD */
	ISPOPMAP(0x03, 0x07),	/* 0x05: MBOX_READ_RAM_WORD */
	ISPOPMAP(0xff, 0xff),	/* 0x06: MBOX_MAILBOX_REG_TEST */
	ISPOPMAP(0x03, 0x05),	/* 0x07: MBOX_VERIFY_CHECKSUM	*/
	ISPOPMAP(0x01, 0x0f),	/* 0x08: MBOX_ABOUT_FIRMWARE */
	ISPOPMAP(0xdf, 0x01),	/* 0x09: LOAD RAM */
	ISPOPMAP(0xdf, 0x01),	/* 0x0a: DUMP RAM */
	ISPOPMAP(0x00, 0x00),	/* 0x0b: */
	ISPOPMAP(0x00, 0x00),	/* 0x0c: */
	ISPOPMAP(0x00, 0x00),	/* 0x0d: */
	ISPOPMAP(0x01, 0x05),	/* 0x0e: MBOX_CHECK_FIRMWARE */
	ISPOPMAP(0x00, 0x00),	/* 0x0f: */
	ISPOPMAP(0x1f, 0x11),	/* 0x10: MBOX_INIT_REQ_QUEUE */
	ISPOPMAP(0x2f, 0x21),	/* 0x11: MBOX_INIT_RES_QUEUE */
	ISPOPMAP(0x0f, 0x01),	/* 0x12: MBOX_EXECUTE_IOCB */
	ISPOPMAP(0x03, 0x03),	/* 0x13: MBOX_WAKE_UP	*/
	ISPOPMAP(0x01, 0xff),	/* 0x14: MBOX_STOP_FIRMWARE */
	ISPOPMAP(0x4f, 0x01),	/* 0x15: MBOX_ABORT */
	ISPOPMAP(0x07, 0x01),	/* 0x16: MBOX_ABORT_DEVICE */
	ISPOPMAP(0x07, 0x01),	/* 0x17: MBOX_ABORT_TARGET */
	ISPOPMAP(0x03, 0x03),	/* 0x18: MBOX_BUS_RESET */
	ISPOPMAP(0x07, 0x05),	/* 0x19: MBOX_STOP_QUEUE */
	ISPOPMAP(0x07, 0x05),	/* 0x1a: MBOX_START_QUEUE */
	ISPOPMAP(0x07, 0x05),	/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
	ISPOPMAP(0x07, 0x05),	/* 0x1c: MBOX_ABORT_QUEUE */
	ISPOPMAP(0x07, 0x03),	/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
	ISPOPMAP(0x00, 0x00),	/* 0x1e: */
	ISPOPMAP(0x01, 0x07),	/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
	ISPOPMAP(0x01, 0x4f),	/* 0x20: MBOX_GET_LOOP_ID */
	ISPOPMAP(0x00, 0x00),	/* 0x21: */
	ISPOPMAP(0x01, 0x07),	/* 0x22: MBOX_GET_RETRY_COUNT	*/
	ISPOPMAP(0x00, 0x00),	/* 0x23: */
	ISPOPMAP(0x00, 0x00),	/* 0x24: */
	ISPOPMAP(0x00, 0x00),	/* 0x25: */
	ISPOPMAP(0x00, 0x00),	/* 0x26: */
	ISPOPMAP(0x00, 0x00),	/* 0x27: */
	ISPOPMAP(0x0f, 0x1),	/* 0x28: MBOX_GET_FIRMWARE_OPTIONS */
	ISPOPMAP(0x03, 0x07),	/* 0x29: MBOX_GET_PORT_QUEUE_PARAMS */
	ISPOPMAP(0x00, 0x00),	/* 0x2a: */
	ISPOPMAP(0x00, 0x00),	/* 0x2b: */
	ISPOPMAP(0x00, 0x00),	/* 0x2c: */
	ISPOPMAP(0x00, 0x00),	/* 0x2d: */
	ISPOPMAP(0x00, 0x00),	/* 0x2e: */
	ISPOPMAP(0x00, 0x00),	/* 0x2f: */
	ISPOPMAP(0x00, 0x00),	/* 0x30: */
	ISPOPMAP(0x00, 0x00),	/* 0x31: */
	ISPOPMAP(0x07, 0x07),	/* 0x32: MBOX_SET_RETRY_COUNT	*/
	ISPOPMAP(0x00, 0x00),	/* 0x33: */
	ISPOPMAP(0x00, 0x00),	/* 0x34: */
	ISPOPMAP(0x00, 0x00),	/* 0x35: */
	ISPOPMAP(0x00, 0x00),	/* 0x36: */
	ISPOPMAP(0x00, 0x00),	/* 0x37: */
	ISPOPMAP(0x0f, 0x01),	/* 0x38: MBOX_SET_FIRMWARE_OPTIONS */
	ISPOPMAP(0x0f, 0x07),	/* 0x39: MBOX_SET_PORT_QUEUE_PARAMS */
	ISPOPMAP(0x00, 0x00),	/* 0x3a: */
	ISPOPMAP(0x00, 0x00),	/* 0x3b: */
	ISPOPMAP(0x00, 0x00),	/* 0x3c: */
	ISPOPMAP(0x00, 0x00),	/* 0x3d: */
	ISPOPMAP(0x00, 0x00),	/* 0x3e: */
	ISPOPMAP(0x00, 0x00),	/* 0x3f: */
	ISPOPMAP(0x03, 0x01),	/* 0x40: MBOX_LOOP_PORT_BYPASS */
	ISPOPMAP(0x03, 0x01),	/* 0x41: MBOX_LOOP_PORT_ENABLE */
	ISPOPMAP(0x03, 0x07),	/* 0x42: MBOX_GET_RESOURCE_COUNTS */
	ISPOPMAP(0x01, 0x01),	/* 0x43: MBOX_REQUEST_NON_PARTICIPATING_MODE */
	ISPOPMAP(0x00, 0x00),	/* 0x44: */
	ISPOPMAP(0x00, 0x00),	/* 0x45: */
	ISPOPMAP(0x00, 0x00),	/* 0x46: */
	ISPOPMAP(0xcf, 0x03),	/* 0x47: GET PORT_DATABASE ENHANCED */
	ISPOPMAP(0x00, 0x00),	/* 0x48: */
	ISPOPMAP(0x00, 0x00),	/* 0x49: */
	ISPOPMAP(0x00, 0x00),	/* 0x4a: */
	ISPOPMAP(0x00, 0x00),	/* 0x4b: */
	ISPOPMAP(0x00, 0x00),	/* 0x4c: */
	ISPOPMAP(0x00, 0x00),	/* 0x4d: */
	ISPOPMAP(0x00, 0x00),	/* 0x4e: */
	ISPOPMAP(0x00, 0x00),	/* 0x4f: */
	ISPOPMAP(0x00, 0x00),	/* 0x50: */
	ISPOPMAP(0x00, 0x00),	/* 0x51: */
	ISPOPMAP(0x00, 0x00),	/* 0x52: */
	ISPOPMAP(0x00, 0x00),	/* 0x53: */
	ISPOPMAP(0xcf, 0x01),	/* 0x54: EXECUTE IOCB A64 */
	ISPOPMAP(0x00, 0x00),	/* 0x55: */
	ISPOPMAP(0x00, 0x00),	/* 0x56: */
	ISPOPMAP(0x00, 0x00),	/* 0x57: */
	ISPOPMAP(0x00, 0x00),	/* 0x58: */
	ISPOPMAP(0x00, 0x00),	/* 0x59: */
	ISPOPMAP(0x00, 0x00),	/* 0x5a: */
	ISPOPMAP(0x00, 0x00),	/* 0x5b: */
	ISPOPMAP(0x00, 0x00),	/* 0x5c: */
	ISPOPMAP(0x00, 0x00),	/* 0x5d: */
	ISPOPMAP(0x00, 0x00),	/* 0x5e: */
	ISPOPMAP(0x00, 0x00),	/* 0x5f: */
	ISPOPMAP(0xfd, 0x31),	/* 0x60: MBOX_INIT_FIRMWARE */
	ISPOPMAP(0x00, 0x00),	/* 0x61: */
	ISPOPMAP(0x01, 0x01),	/* 0x62: MBOX_INIT_LIP */
	ISPOPMAP(0xcd, 0x03),	/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */
	ISPOPMAP(0xcf, 0x01),	/* 0x64: MBOX_GET_PORT_DB */
	ISPOPMAP(0x07, 0x01),	/* 0x65: MBOX_CLEAR_ACA */
	ISPOPMAP(0x07, 0x01),	/* 0x66: MBOX_TARGET_RESET */
	ISPOPMAP(0x07, 0x01),	/* 0x67: MBOX_CLEAR_TASK_SET */
	ISPOPMAP(0x07, 0x01),	/* 0x68: MBOX_ABORT_TASK_SET */
	ISPOPMAP(0x01, 0x07),	/* 0x69: MBOX_GET_FW_STATE */
	ISPOPMAP(0x03, 0xcf),	/* 0x6a: MBOX_GET_PORT_NAME */
	ISPOPMAP(0xcf, 0x01),	/* 0x6b: MBOX_GET_LINK_STATUS */
	ISPOPMAP(0x0f, 0x01),	/* 0x6c: MBOX_INIT_LIP_RESET */
	ISPOPMAP(0x00, 0x00),	/* 0x6d: */
	ISPOPMAP(0xcf, 0x03),	/* 0x6e: MBOX_SEND_SNS */
	ISPOPMAP(0x0f, 0x07),	/* 0x6f: MBOX_FABRIC_LOGIN */
	ISPOPMAP(0x03, 0x01),	/* 0x70: MBOX_SEND_CHANGE_REQUEST */
	ISPOPMAP(0x03, 0x03),	/* 0x71: MBOX_FABRIC_LOGOUT */
	ISPOPMAP(0x0f, 0x0f),	/* 0x72: MBOX_INIT_LIP_LOGIN */
	ISPOPMAP(0x00, 0x00),	/* 0x73: */
	ISPOPMAP(0x07, 0x01),	/* 0x74: LOGIN LOOP PORT */
	ISPOPMAP(0xcf, 0x03),	/* 0x75: GET PORT/NODE NAME LIST */
	ISPOPMAP(0x4f, 0x01),	/* 0x76: SET VENDOR ID */
	ISPOPMAP(0xcd, 0x01),	/* 0x77: INITIALIZE IP MAILBOX */
	ISPOPMAP(0x00, 0x00),	/* 0x78: */
	ISPOPMAP(0x00, 0x00),	/* 0x79: */
	ISPOPMAP(0x00, 0x00),	/* 0x7a: */
	ISPOPMAP(0x00, 0x00),	/* 0x7b: */
	ISPOPMAP(0x4f, 0x03),	/* 0x7c: Get ID List */
	ISPOPMAP(0xcf, 0x01),	/* 0x7d: SEND LFA */
	ISPOPMAP(0x07, 0x01)	/* 0x7e: Lun RESET */
};
d3430 18
a3447 131
#ifndef	ISP_STRIPPED
static char *fc_mbcmd_names[] = {
	"NO-OP",
	"LOAD RAM",
	"EXEC FIRMWARE",
	"DUMP RAM",
	"WRITE RAM WORD",
	"READ RAM WORD",
	"MAILBOX REG TEST",
	"VERIFY CHECKSUM",
	"ABOUT FIRMWARE",
	"LOAD RAM",
	"DUMP RAM",
	NULL,
	NULL,
	NULL,
	"CHECK FIRMWARE",
	NULL,
	"INIT REQUEST QUEUE",
	"INIT RESULT QUEUE",
	"EXECUTE IOCB",
	"WAKE UP",
	"STOP FIRMWARE",
	"ABORT",
	"ABORT DEVICE",
	"ABORT TARGET",
	"BUS RESET",
	"STOP QUEUE",
	"START QUEUE",
	"SINGLE STEP QUEUE",
	"ABORT QUEUE",
	"GET DEV QUEUE STATUS",
	NULL,
	"GET FIRMWARE STATUS",
	"GET LOOP ID",
	NULL,
	"GET RETRY COUNT",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"GET FIRMWARE OPTIONS",
	"GET PORT QUEUE PARAMS",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"SET RETRY COUNT",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"SET FIRMWARE OPTIONS",
	"SET PORT QUEUE PARAMS",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"LOOP PORT BYPASS",
	"LOOP PORT ENABLE",
	"GET RESOURCE COUNTS",
	"REQUEST NON PARTICIPATING MODE",
	NULL,
	NULL,
	NULL,
	"GET PORT DATABASE,, ENHANCED",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"EXECUTE IOCB A64",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"INIT FIRMWARE",
	NULL,
	"INIT LIP",
	"GET FC-AL POSITION MAP",
	"GET PORT DATABASE",
	"CLEAR ACA",
	"TARGET RESET",
	"CLEAR TASK SET",
	"ABORT TASK SET",
	"GET FW STATE",
	"GET PORT NAME",
	"GET LINK STATUS",
	"INIT LIP RESET",
	NULL,
	"SEND SNS",
	"FABRIC LOGIN",
	"SEND CHANGE REQUEST",
	"FABRIC LOGOUT",
	"INIT LIP LOGIN",
	NULL,
	"LOGIN LOOP PORT",
	"GET PORT/NODE NAME LIST",
	"SET VENDOR ID",
	"INITIALIZE IP MAILBOX",
	NULL,
	NULL,
	NULL,
	NULL,
	"Get ID List",
	"SEND LFA",
	"Lun RESET"
};
#endif
d3449 31
a3479 28
static void
isp_mboxcmd(struct ispsoftc *isp, mbreg_t *mbp, int logmask)
{
	char *cname, *xname, tname[16], mname[16];
	unsigned int lim, ibits, obits, box, opcode;
	u_int16_t *mcp;

	if (IS_FC(isp)) {
		mcp = mbpfc;
		lim = (sizeof (mbpfc) / sizeof (mbpfc[0]));
	} else {
		mcp = mbpscsi;
		lim = (sizeof (mbpscsi) / sizeof (mbpscsi[0]));
	}

	if ((opcode = mbp->param[0]) >= lim) {
		mbp->param[0] = MBOX_INVALID_COMMAND;
		isp_prt(isp, ISP_LOGERR, "Unknown Command 0x%x", opcode);
		return;
	}

	ibits = HIBYT(mcp[opcode]) & NMBOX_BMASK(isp);
	obits = LOBYT(mcp[opcode]) & NMBOX_BMASK(isp);

	if (ibits == 0 && obits == 0) {
		mbp->param[0] = MBOX_COMMAND_PARAM_ERROR;
		isp_prt(isp, ISP_LOGERR, "no parameters for 0x%x", opcode);
		return;
d3483 2
a3484 1
	 * Get exclusive usage of mailbox registers.
d3486 19
a3504 1
	MBOX_ACQUIRE(isp);
d3506 3
a3508 3
	for (box = 0; box < MAX_MAILBOX; box++) {
		if (ibits & (1 << box)) {
			ISP_WRITE(isp, MBOX_OFF(box), mbp->param[box]);
a3509 1
		isp->isp_mboxtmp[box] = mbp->param[box] = 0;
d3512 10
a3521 1
	isp->isp_lastmbxcmd = opcode;
d3524 1
a3524 1
	 * We assume that we can't overwrite a previous command.
d3526 1
a3526 1
	isp->isp_mboxbsy = obits;
d3529 1
a3529 1
	 * Set Host Interrupt condition so that RISC will pick up mailbox regs.
d3531 1
a3531 30
	ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);

	/*
	 * While we haven't finished the command, spin our wheels here.
	 */
	MBOX_WAIT_COMPLETE(isp);

	/*
	 * Copy back output registers.
	 */
	for (box = 0; box < MAX_MAILBOX; box++) {
		if (obits & (1 << box)) {
			mbp->param[box] = isp->isp_mboxtmp[box];
		}
	}

	MBOX_RELEASE(isp);

	if (logmask == 0 || opcode == MBOX_EXEC_FIRMWARE) {
		return;
	}
#ifdef	ISP_STRIPPED
	cname = NULL;
#else
	cname = (IS_FC(isp))? fc_mbcmd_names[opcode] : scsi_mbcmd_names[opcode];
#endif
	if (cname == NULL) {
		cname = tname;
		SNPRINTF(tname, sizeof tname, "opcode %x", opcode);
	}
a3535 1
	xname = NULL;
d3540 2
a3541 2
		if (logmask & MBLOGMASK(MBOX_COMMAND_COMPLETE))
			xname = "INVALID COMMAND";
d3544 2
a3545 2
		if (logmask & MBLOGMASK(MBOX_HOST_INTERFACE_ERROR))
			xname = "HOST INTERFACE ERROR";
d3548 2
a3549 2
		if (logmask & MBLOGMASK(MBOX_TEST_FAILED))
			xname = "TEST FAILED";
d3552 3
a3554 2
		if (logmask & MBLOGMASK(MBOX_COMMAND_ERROR))
			xname = "COMMAND ERROR";
d3557 9
a3565 2
		if (logmask & MBLOGMASK(MBOX_COMMAND_PARAM_ERROR))
			xname = "COMMAND PARAMETER ERROR";
d3567 1
d3569 2
a3570 2
		if (logmask & MBLOGMASK(MBOX_LOOP_ID_USED))
			xname = "LOOP ID ALREADY IN USE";
d3572 7
a3578 3
	case MBOX_PORT_ID_USED:
		if (logmask & MBLOGMASK(MBOX_PORT_ID_USED))
			xname = "PORT ID ALREADY IN USE";
d3580 7
a3586 3
	case MBOX_ALL_IDS_USED:
		if (logmask & MBLOGMASK(MBOX_ALL_IDS_USED))
			xname = "ALL LOOP IDS IN USE";
d3588 7
a3594 2
	case 0:		/* special case */
		xname = "TIMEOUT";
d3596 1
d3598 8
a3605 2
		SNPRINTF(mname, sizeof mname, "error 0x%x", mbp->param[0]);
		xname = mname;
d3608 73
a3680 3
	if (xname)
		isp_prt(isp, ISP_LOGALL, "Mailbox Command '%s' failed (%s)",
		    cname, xname);
d3684 2
a3685 1
isp_fw_state(struct ispsoftc *isp)
d3687 1
d3689 1
a3689 1
		mbreg_t mbs;
d3691 1
a3691 1

d3693 36
a3728 3
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			fcp->isp_fwstate = mbs.param[1];
d3730 1
d3735 2
a3736 1
isp_update(struct ispsoftc *isp)
d3738 1
a3738 1
	int bus, upmask;
d3740 2
a3741 2
	for (bus = 0, upmask = isp->isp_update; upmask != 0; bus++) {
		if (upmask & (1 << bus)) {
d3743 1
a3744 1
		upmask &= ~(1 << bus);
d3749 3
a3751 1
isp_update_bus(struct ispsoftc *isp, int bus)
a3756 1
	isp->isp_update &= ~(1 << bus);
a3757 3
		/*
		 * There are no 'per-bus' settings for Fibre Channel.
		 */
d3760 1
d3769 2
a3770 4
			sdp->isp_devparam[tgt].dev_update = 0;
			sdp->isp_devparam[tgt].dev_refresh = 0;
			isp_prt(isp, ISP_LOGDEBUG0,
	 		    "skipping target %d bus %d update", tgt, bus);
d3773 1
d3780 1
a3780 9

		/*
		 * Refresh overrides set
		 */
		if (sdp->isp_devparam[tgt].dev_refresh) {
			mbs.param[0] = MBOX_GET_TARGET_PARAMS;
			sdp->isp_devparam[tgt].dev_refresh = 0;
			get = 1;
		} else if (sdp->isp_devparam[tgt].dev_update) {
a3781 7
			/*
			 * Make sure dev_flags has "Renegotiate on Error"
			 * on and "Freeze Queue on Error" off.
			 */
			sdp->isp_devparam[tgt].dev_flags |= DPARM_RENEG;
			sdp->isp_devparam[tgt].dev_flags &= ~DPARM_QFRZ;

a3782 1
			
d3784 2
a3785 2
			 * Insist that PARITY must be enabled
			 * if SYNC or WIDE is enabled.
d3787 1
a3787 1
			if ((mbs.param[2] & (DPARM_SYNC|DPARM_WIDE)) != 0) {
d3790 4
a3793 8

			if ((mbs.param[2] & DPARM_SYNC) == 0) {
				mbs.param[3] = 0;
			} else {
				mbs.param[3] =
				    (sdp->isp_devparam[tgt].sync_offset << 8) |
				    (sdp->isp_devparam[tgt].sync_period);
			}
d3796 2
a3797 3
			 * RQSTF_NEGOTIATION set canl cause
			 * the dev_refresh/announce cycle also.
			 &
a3807 5
			isp_prt(isp, ISP_LOGDEBUG0,
			    "bus %d set tgt %d flags 0x%x off 0x%x period 0x%x",
			    bus, tgt, mbs.param[2], mbs.param[3] >> 8,
			    mbs.param[3] & 0xff);
			sdp->isp_devparam[tgt].dev_update = 0;
d3809 4
d3814 4
d3821 8
a3828 2
		mbs.param[1] = (bus << 15) | (tgt << 8);
		isp_mboxcmd(isp, &mbs, MBLOGALL);
a3841 8

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		if (sdp->isp_devparam[tgt].dev_update ||
		    sdp->isp_devparam[tgt].dev_refresh) {
			isp->isp_update |= (1 << bus);
			break;
		}
	}
d3845 3
a3847 1
isp_setdfltparm(struct ispsoftc *isp, int channel)
a3854 2
		int nvfail;

d3862 1
a3862 1
		fcp->isp_execthrottle = ISP_EXEC_THROTTLE;
d3867 2
a3868 18
		fcp->isp_nodewwn = DEFAULT_NODEWWN(isp);
		fcp->isp_portwwn = DEFAULT_PORTWWN(isp);
		fcp->isp_fwoptions = 0;
		fcp->isp_fwoptions |= ICBOPT_FAIRNESS;
		fcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;
		fcp->isp_fwoptions |= ICBOPT_HARD_ADDRESS;
#ifndef	ISP_NO_FASTPOST_FC
		fcp->isp_fwoptions |= ICBOPT_FAST_POST;
#endif
		if (isp->isp_confopts & ISP_CFG_FULL_DUPLEX)
			fcp->isp_fwoptions |= ICBOPT_FULL_DUPLEX;

		/*
		 * Make sure this is turned off now until we get
		 * extended options from NVRAM
		 */
		fcp->isp_fwoptions &= ~ICBOPT_EXTENDED;

d3870 1
a3870 2
		 * Now try and read NVRAM unless told to not do so.
		 * This will set fcparam's isp_nodewwn && isp_portwwn.
d3872 5
a3876 30
		if ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {
		    	nvfail = isp_read_nvram(isp);
			if (nvfail)
				isp->isp_confopts |= ISP_CFG_NONVRAM;
		} else {
			nvfail = 1;
		}
		/*
		 * Set node && port to override platform set defaults
		 * unless the nvram read failed (or none was done),
		 * or the platform code wants to use what had been
		 * set in the defaults.
		 */
		if (nvfail || (isp->isp_confopts & ISP_CFG_OWNWWN)) {
			isp_prt(isp, ISP_LOGCONFIG,
			    "Using Node WWN 0x%08x%08x, Port WWN 0x%08x%08x",
			    (u_int32_t) (DEFAULT_NODEWWN(isp) >> 32),
			    (u_int32_t) (DEFAULT_NODEWWN(isp) & 0xffffffff),
			    (u_int32_t) (DEFAULT_PORTWWN(isp) >> 32),
			    (u_int32_t) (DEFAULT_PORTWWN(isp) & 0xffffffff));
			isp->isp_confopts |= ISP_CFG_OWNWWN;
			ISP_NODEWWN(isp) = DEFAULT_NODEWWN(isp);
			ISP_PORTWWN(isp) = DEFAULT_PORTWWN(isp);
		} else {
			/*
			 * We always start out with values derived
			 * from NVRAM or our platform default.
			 */
			ISP_NODEWWN(isp) = fcp->isp_nodewwn;
			ISP_PORTWWN(isp) = fcp->isp_portwwn;
a3892 24
	 * Establish some default parameters.
	 */
	sdp->isp_cmd_dma_burst_enable = 1;
	sdp->isp_data_dma_burst_enabl = 1;
	sdp->isp_fifo_threshold = 0;
	sdp->isp_initiator_id = DEFAULT_IID(isp);
	if (isp->isp_type >= ISP_HA_SCSI_1040) {
		sdp->isp_async_data_setup = 9;
	} else {
		sdp->isp_async_data_setup = 6;
	}
	sdp->isp_selection_timeout = 250;
	sdp->isp_max_queue_depth = MAXISPREQUEST(isp);
	sdp->isp_tag_aging = 8;
	sdp->isp_bus_reset_delay = 3;
	sdp->isp_retry_count = 2;
	sdp->isp_retry_delay = 2;

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		sdp->isp_devparam[tgt].exc_throttle = ISP_EXEC_THROTTLE;
		sdp->isp_devparam[tgt].dev_enable = 1;
	}

	/*
d3909 1
a3909 1
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
d3911 1
d3920 3
d3925 4
a3928 6
	isp_prt(isp, ISP_LOGDEBUG0,
	    "defaulting bus %d REQ/ACK Active Negation is %d",
	    channel, sdp->isp_req_ack_active_neg);
	isp_prt(isp, ISP_LOGDEBUG0,
	    "defaulting bus %d DATA Active Negation is %d",
	    channel, sdp->isp_data_line_active_neg);
d3949 1
a3949 2
		    (isp->isp_clock && isp->isp_clock < 60) ||
		    (sdp->isp_ultramode == 0)) {
a3953 5
		} else if (IS_ULTRA3(isp)) {
			sdp->isp_devparam[tgt].sync_offset =
			    ISP_80M_SYNCPARMS >> 8;
			sdp->isp_devparam[tgt].sync_period =
			    ISP_80M_SYNCPARMS & 0xff;
d3959 1
a3959 1
		} else if (IS_1240(isp)) {
a3963 5
		} else {
			sdp->isp_devparam[tgt].sync_offset =
			    ISP_20M_SYNCPARMS_1040 >> 8;
			sdp->isp_devparam[tgt].sync_period =
			    ISP_20M_SYNCPARMS_1040 & 0xff;
d3974 1
a3974 1
			isp_mboxcmd(isp, &mbs, MBLOGALL);
d4010 3
a4012 3
		isp_prt(isp, ISP_LOGDEBUG0,
		    "Initial bus %d tgt %d flags %x offset %x period %x",
		    channel, tgt, sdp->isp_devparam[tgt].dev_flags,
d4014 26
a4039 1
		    sdp->isp_devparam[tgt].sync_period);
d4052 2
a4053 1
isp_reinit(struct ispsoftc *isp)
d4055 2
a4056 2
	XS_T *xs;
	u_int16_t handle;
d4058 3
d4062 5
a4066 10
	if (isp->isp_state != ISP_RESETSTATE) {
		isp_prt(isp, ISP_LOGERR, "isp_reinit cannot reset card");
		goto skip;
	}
	isp_init(isp);
	if (isp->isp_role == ISP_ROLE_NONE) {
		goto skip;
	}
	if (isp->isp_state == ISP_INITSTATE) {
		isp->isp_state = ISP_RUNSTATE;
d4069 1
a4069 1
		isp_prt(isp, ISP_LOGERR, "isp_reinit cannot restart card");
a4070 1
skip:
d4073 1
a4073 1
	for (handle = 1; (int) handle <= isp->isp_maxcmds; handle++) {
d4086 1
a4086 1
		isp_done(xs);
d4094 2
a4095 1
isp_read_nvram(struct ispsoftc *isp)
d4127 3
a4129 3
			isp_prt(isp, ISP_LOGWARN, "invalid NVRAM header");
			isp_prt(isp, ISP_LOGDEBUG0, "%x %x %x",
			    nvram_data[0], nvram_data[1], nvram_data[2]);
d4140 1
a4140 1
		isp_prt(isp, ISP_LOGWARN, "invalid NVRAM checksum");
d4144 1
a4144 1
		isp_prt(isp, ISP_LOGWARN, "version %d NVRAM not understood",
d4162 1
d4169 4
a4172 1
isp_rdnvram_word(struct ispsoftc *isp, int wo, u_int16_t *rp)
d4178 1
a4178 1
	USEC_DELAY(2);
d4180 1
a4180 1
	USEC_DELAY(2);
d4206 1
a4206 1
		USEC_DELAY(2);
d4208 1
a4208 1
		USEC_DELAY(2);
d4210 1
a4210 1
		USEC_DELAY(2);
d4220 1
a4220 1
		USEC_DELAY(2);
d4225 1
a4225 1
		USEC_DELAY(2);
d4227 1
a4227 1
		USEC_DELAY(2);
d4230 4
a4233 2
	USEC_DELAY(2);
	ISP_SWIZZLE_NVRAM_WORD(isp, rp);
d4237 3
a4239 1
isp_parse_nvram_1020(struct ispsoftc *isp, u_int8_t *nvram_data)
d4242 2
d4296 30
a4325 1
	sdp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);
d4342 2
a4343 1
				sdp->isp_devparam[i].sync_period = 0x19;
d4346 2
a4347 1
				sdp->isp_devparam[i].sync_offset = 0x0c;
d4357 4
d4362 4
d4377 9
d4390 4
a4393 1
isp_parse_nvram_1080(struct ispsoftc *isp, int bus, u_int8_t *nvram_data)
d4395 2
d4440 28
d4480 5
d4486 5
d4502 10
d4516 4
a4519 1
isp_parse_nvram_12160(struct ispsoftc *isp, int bus, u_int8_t *nvram_data)
d4521 2
d4567 29
d4608 4
d4613 4
d4628 9
d4641 3
a4643 1
isp_parse_nvram_2100(struct ispsoftc *isp, u_int8_t *nvram_data)
d4646 14
a4659 1
	u_int64_t wwn;
d4662 1
a4662 9
	 * There is NVRAM storage for both Port and Node entities-
	 * but the Node entity appears to be unused on all the cards
	 * I can find. However, we should account for this being set
	 * at some point in the future.
	 *
	 * Qlogic WWNs have an NAA of 2, but usually nothing shows up in
	 * bits 48..60. In the case of the 2202, it appears that they do
	 * use bit 48 to distinguish between the two instances on the card.
	 * The 2204, which I've never seen, *probably* extends this method.
d4664 7
a4670 16
	wwn = ISP2100_NVRAM_PORT_NAME(nvram_data);
	if (wwn) {
		isp_prt(isp, ISP_LOGCONFIG, "NVRAM Port WWN 0x%08x%08x",
		    (u_int32_t) (wwn >> 32), (u_int32_t) (wwn & 0xffffffff));
		if ((wwn >> 60) == 0) {
			wwn |= (((u_int64_t) 2)<< 60); 
		}
	}
	fcp->isp_portwwn = wwn;
	wwn = ISP2100_NVRAM_NODE_NAME(nvram_data);
	if (wwn) {
		isp_prt(isp, ISP_LOGCONFIG, "NVRAM Node WWN 0x%08x%08x",
		    (u_int32_t) (wwn >> 32), (u_int32_t) (wwn & 0xffffffff));
		if ((wwn >> 60) == 0) {
			wwn |= (((u_int64_t) 2)<< 60); 
		}
d4672 1
a4672 1
	fcp->isp_nodewwn = wwn;
d4675 5
a4679 1
	 * Make sure we have both Node and Port as non-zero values.
d4681 4
a4684 1
	if (fcp->isp_nodewwn != 0 && fcp->isp_portwwn == 0) {
a4685 2
	} else if (fcp->isp_nodewwn == 0 && fcp->isp_portwwn != 0) {
		fcp->isp_nodewwn = fcp->isp_portwwn;
d4687 4
a4690 16

	/*
	 * Make the Node and Port values sane if they're NAA == 2.
	 * This means to clear bits 48..56 for the Node WWN and
	 * make sure that there's some non-zero value in 48..56
	 * for the Port WWN.
	 */
	if (fcp->isp_nodewwn && fcp->isp_portwwn) {
		if ((fcp->isp_nodewwn & (((u_int64_t) 0xfff) << 48)) != 0 &&
		    (fcp->isp_nodewwn >> 60) == 2) {
			fcp->isp_nodewwn &= ~((u_int64_t) 0xfff << 48);
		}
		if ((fcp->isp_portwwn & (((u_int64_t) 0xfff) << 48)) == 0 &&
		    (fcp->isp_portwwn >> 60) == 2) {
			fcp->isp_portwwn |= ((u_int64_t) 1 << 56);
		}
a4691 1

d4705 19
a4723 2
	isp_prt(isp, ISP_LOGDEBUG0,
	    "fwoptions from nvram are 0x%x", fcp->isp_fwoptions);
@


1.12.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.12.2.3 2001/05/14 22:23:53 niklas Exp $ */
d67 2
d73 1
a73 1
static const char retained[] =
a102 8
static const char sc0[] =
    "%s CHAN %d FTHRSH %d IID %d RESETD %d RETRYC %d RETRYD %d ASD 0x%x";
static const char sc1[] =
    "%s RAAN 0x%x DLAN 0x%x DDMAB 0x%x CDMAB 0x%x SELTIME %d MQD %d";
static const char sc2[] = "%s CHAN %d TGT %d FLAGS 0x%x 0x%x/0x%x";
static const char sc3[] = "Generated";
static const char sc4[] = "NVRAM";

a144 1

a148 1
	u_int16_t code_org;
d150 1
a150 1
	char *btype = "????";
d154 1
d158 1
a158 2
	 * here. Possibly more refined types based upon PCI
	 * identification. Chip revision has been gathered.
d176 1
a176 7
		 * spread through outgoing mailbox registers 1-3. We do
		 * this for PCI cards because otherwise we really don't
		 * know what state the card is in and we could hang if
		 * we try this command otherwise.
		 *
		 * For SBus cards, we just do this because they almost
		 * certainly will be running firmware by now.
d186 4
a189 1
			isp_mboxcmd(isp, &mbs, MBLOGNONE);
a201 16
	 * Set up default request/response queue in-pointer/out-pointer
	 * register indices.
	 */
	if (IS_2300(isp)) {
		isp->isp_rqstinrp = BIU_REQINP;
		isp->isp_rqstoutrp = BIU_REQOUTP;
		isp->isp_respinrp = BIU_RSPINP;
		isp->isp_respoutrp = BIU_RSPOUTP;
	} else {
		isp->isp_rqstinrp = INMAILBOX4;
		isp->isp_rqstoutrp = OUTMAILBOX4;
		isp->isp_respinrp = OUTMAILBOX5;
		isp->isp_respoutrp = INMAILBOX5;
	}

	/*
d210 1
a210 1
			btype = "2100";
d213 1
a213 4
			btype = "2200";
			break;
		case ISP_HA_FC_2300:
			btype = "2300";
d228 1
a228 1
		btype = "1240";
d244 1
a244 1
			btype = "1280";
d246 1
a246 1
			btype = "1080";
d248 1
a248 1
			btype = "12160";
d250 1
a250 1
			btype = "<UNKLVD>";
d305 1
a305 1
			btype = "1020";
d315 1
a315 1
			btype = "1020A";
d320 1
a320 1
			btype = "1040";
d325 1
a325 1
			btype = "1040A";
d330 1
a330 1
			btype = "1040B";
d334 2
a335 2
		case 6:
			btype = "1040C";
d338 1
a338 1
                        break;
d508 1
a508 1
		if (IS_2200(isp) || IS_2300(isp)) {
d521 1
a521 4
	 * Wait for everything to finish firing up.
	 *
	 * Avoid doing this on the 2312 because you can generate a PCI
	 * parity error (chip breakage).
d523 7
a529 11
	if (IS_2300(isp)) {
		USEC_DELAY(5);
	} else {
		loops = MBOX_DELAY_COUNT;
		while (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {
			USEC_DELAY(100);
			if (--loops < 0) {
				isp_prt(isp, ISP_LOGERR,
				    "MBOX_BUSY never cleared on reset");
				return;
			}
a584 5
	if (IS_2300(isp))
		code_org = ISP_CODE_ORG_2300;
	else
		code_org = ISP_CODE_ORG;

d589 1
a589 1
			mbs.param[1] = code_org + i;
d604 1
a604 1
		mbs.param[1] = code_org;
a622 1

d624 1
a624 1
	mbs.param[1] = code_org;
a645 22

	/*
	 * The SBus firmware that we are using apparently does not return
	 * major, minor, micro revisions in the mailbox registers, which
	 * is really, really, annoying.
	 */
	if (isp->isp_bustype == ISP_BT_SBUS) {
		if (dodnld) {
#ifdef	ISP_TARGET_MODE
			isp->isp_fwrev[0] = 7;
			isp->isp_fwrev[1] = 55;
#else
			isp->isp_fwrev[0] = 1;
			isp->isp_fwrev[1] = 37;
#endif
			isp->isp_fwrev[2] = 0;
		} 
	} else {
		isp->isp_fwrev[0] = mbs.param[1];
		isp->isp_fwrev[1] = mbs.param[2];
		isp->isp_fwrev[2] = mbs.param[3];
	}
d647 3
a649 4
	    "Board Type %s, Chip Revision 0x%x, %s F/W Revision %d.%d.%d",
	    btype, isp->isp_revision, dodnld? "loaded" : "resident",
	    isp->isp_fwrev[0], isp->isp_fwrev[1], isp->isp_fwrev[2]);

d651 2
a652 12
		/*
		 * We do not believe firmware attributes for 2100 code less
		 * than 1.17.0.
		 */
		if (IS_2100(isp) && 
		   (ISP_FW_REVX(isp->isp_fwrev) < ISP_FW_REV(1, 17, 0))) {
			FCPARAM(isp)->isp_fwattr = 0;
		} else {
			FCPARAM(isp)->isp_fwattr = mbs.param[6];
			isp_prt(isp, ISP_LOGDEBUG0,
			    "Firmware Attributes = 0x%x", mbs.param[6]);
		}
d659 3
d691 5
a695 2
	 * if we haven't loaded firmware, we sometimes do not have an easy way
	 * of knowing how many luns we support.
a699 3
	 * It turns out that even for QLogic 2100s with ROM 1.10 and above
	 * we do get a firmware attributes word returned in mailbox register 6.
	 *
d710 2
a711 2
		if (IS_SCSI(isp)) {
			if (dodnld) {
d714 1
a714 1
				isp->isp_maxluns = 8;
d717 2
a718 2
			if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
				isp->isp_maxluns = 65536;
d720 2
a721 1
				isp->isp_maxluns = 16;
d863 2
a864 2
	mbs.param[2] = DMA_WD1(isp->isp_result_dma);
	mbs.param[3] = DMA_WD0(isp->isp_result_dma);
d875 2
a876 2
	mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
	mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
d938 1
a938 1
	 * Set current per-target parameters to an initial safe minimum.
d948 13
a960 10
		sdf = sdp->isp_devparam[tgt].goal_flags;
		sdf &= DPARM_SAFE_DFLT;
		/*
		 * It is not quite clear when this changed over so that
		 * we could force narrow and async for 1000/1020 cards,
		 * but assume that this is only the case for loaded
		 * firmware.
		 */
		if (isp->isp_loaded_fw) {
			sdf |= DPARM_NARROW | DPARM_ASYNC;
d971 1
a971 1
		sdp->isp_devparam[tgt].goal_flags = sdf = DPARM_DEFAULT;
d980 2
a981 2
			    (sdp->isp_devparam[tgt].goal_offset << 8) |
			    (sdp->isp_devparam[tgt].goal_period);
d984 1
a984 1
		    "Initial Settings bus%d tgt%d flags 0x%x off 0x%x per 0x%x",
d1011 1
a1011 1
		sdp->isp_devparam[tgt].actv_flags = sdf & ~DPARM_TQING;
d1096 1
a1096 1

a1136 2
	 * 
	 * NB: for the 2300, ICBOPT_EXTENDED is required.
d1138 1
a1138 1
	if (IS_2200(isp) || IS_2300(isp)) {
d1145 1
a1145 1
			icbp->icb_xfwoptions |= ICBXOPT_PTP_2_LOOP;
d1148 1
a1148 1
			icbp->icb_xfwoptions |= ICBXOPT_PTP_ONLY;
d1151 1
a1151 1
			icbp->icb_xfwoptions |= ICBXOPT_LOOP_ONLY;
d1154 1
a1154 1
			icbp->icb_xfwoptions |= ICBXOPT_LOOP_2_PTP;
a1156 34
		if (IS_2300(isp)) {
			if (isp->isp_revision < 2) {
				icbp->icb_fwoptions &= ~ICBOPT_FAST_POST;
			}
			if (isp->isp_confopts & ISP_CFG_ONEGB) {
				icbp->icb_zfwoptions |= ICBZOPT_RATE_ONEGB;
			} else if (isp->isp_confopts & ISP_CFG_TWOGB) {
				icbp->icb_zfwoptions |= ICBZOPT_RATE_TWOGB;
			} else {
				icbp->icb_zfwoptions |= ICBZOPT_RATE_AUTO;
			}
		}
	}

	if ((IS_2200(isp) && ISP_FW_REVX(isp->isp_fwrev) >=
	    ISP_FW_REV(2, 1, 26)) || IS_2300(isp)) {
		/*
		 * Turn on LIP F8 async event (1)
		 * Turn on generate AE 8013 on all LIP Resets (2)
		 * Disable LIP F7 switching (8)
		 */
		mbs.param[0] = MBOX_SET_FIRMWARE_OPTIONS;
		mbs.param[1] = 0xb;
		mbs.param[2] = 0;
		mbs.param[3] = 0;
		isp_mboxcmd(isp, &mbs, MBLOGALL);
	}
	icbp->icb_logintime = 30;	/* 30 second login timeout */

	if (IS_2300(isp)) {
		ISP_WRITE(isp, isp->isp_rqstinrp, 0);
        	ISP_WRITE(isp, isp->isp_rqstoutrp, 0);
        	ISP_WRITE(isp, isp->isp_respinrp, 0);
		ISP_WRITE(isp, isp->isp_respoutrp, 0);
d1158 1
d1178 4
a1181 8
	icbp->icb_rqstaddr[RQRSP_ADDR0015] = DMA_WD0(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR1631] = DMA_WD1(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR3247] = DMA_WD2(isp->isp_rquest_dma);
	icbp->icb_rqstaddr[RQRSP_ADDR4863] = DMA_WD3(isp->isp_rquest_dma);
	icbp->icb_respaddr[RQRSP_ADDR0015] = DMA_WD0(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR1631] = DMA_WD1(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR3247] = DMA_WD2(isp->isp_result_dma);
	icbp->icb_respaddr[RQRSP_ADDR4863] = DMA_WD3(isp->isp_result_dma);
d1192 2
a1193 2
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
d1196 2
a1197 2
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
d1227 2
a1228 2
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
d1265 2
a1266 2
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
d1274 2
a1275 2
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
d1415 1
a1415 1
	if (IS_2200(isp) || IS_2300(isp)) {
a1490 14
	fcp->isp_gbspeed = 1;
	if (IS_2300(isp)) {
		mbs.param[0] = MBOX_GET_SET_DATA_RATE;
		mbs.param[1] = MBGSD_GET_RATE;
		/* mbs.param[2] undefined if we're just getting rate */
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			if (mbs.param[1] == MBGSD_TWOGB) {
				isp_prt(isp, ISP_LOGINFO, "2Gb link speed/s");
				fcp->isp_gbspeed = 2;
			}
		}
	}

d1569 1
a1569 1
	    fcp->isp_loopstate != LOOP_FSCAN_DONE &&
d1662 1
a1662 1
			nwwnn =
d1671 1
a1671 1
			nwwpn =
d1685 1
a1685 1
			    lp->roles == nrole && lp->force_logout == 0) {
a1693 2
		lp->force_logout = 0;

d1731 1
a1731 1
			if (IS_2200(isp) || IS_2300(isp)) {
a2074 2
			isp_prt(isp, ISP_LOGINFO, retained,
			    fcp->portdb[i].loopid, i, fcp->portdb[i].portid);
d2126 1
a2126 1
		 *
d2140 1
a2140 1
	u_int32_t portid, first_portid, last_portid;
d2144 1
a2144 1
	int hicap, first_portid_seen, last_port_same;
a2156 2
	last_port_same = 0;
	last_portid = 0xffffffff;	/* not a port */
d2164 1
a2164 1
			DMA_WD0(fcp->isp_scdma + 0x100);
d2166 1
a2166 5
			DMA_WD1(fcp->isp_scdma + 0x100);
		reqp->snscb_addr[RQRSP_ADDR3247] =
			DMA_WD2(fcp->isp_scdma + 0x100);
		reqp->snscb_addr[RQRSP_ADDR4863] =
			DMA_WD3(fcp->isp_scdma + 0x100);
d2174 5
a2178 8
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
a2182 30
			if (mbs.param[0] == MBOX_COMMAND_ERROR) {
				char tbuf[16];
				char *m;
				switch (mbs.param[1]) {
				case 1:
					m = "No Loop";
					break;
				case 2:
					m = "Failed to allocate IOCB buffer";
					break;
				case 3:
					m = "Failed to allocate XCB buffer";
					break;
				case 4:
					m = "timeout or transmit failed";
					break;
				case 5:
					m = "no fabric loop";
					break;
				case 6:
					m = "remote device not a target";
					break;
				default:
					SNPRINTF(tbuf, sizeof tbuf, "%x",
					    mbs.param[1]);
					m = tbuf;
					break;
				}
				isp_prt(isp, ISP_LOGERR, "SNS Failed- %s", m);
			}
a2197 9
		if (portid == last_portid) {
			if (last_port_same++ > 20) {
				isp_prt(isp, ISP_LOGWARN,
				    "tangled fabric database detected");
				break;
			}
		} else {
			last_portid = portid;
		}
d2200 1
a2200 3
	if (hicap >= 65535) {
		isp_prt(isp, ISP_LOGWARN, "fabric too big (> 65535)");
	}
d2219 2
a2220 4
	reqp->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma + 0x100);
	reqp->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma + 0x100);
d2232 4
a2235 7
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
	/*
	 * Leave 4 and 5 alone
	 */
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
d2263 1
d2331 5
a2335 11
			/*
			 * We used to exclude having local loop ports
			 * at the same time that we have fabric ports.
			 * That is, we used to exclude having ports
			 * at < FL_PORT_ID if we're FL-port.
			 *
			 * That's wrong. The only thing that could be
			 * dicey is if the switch you're connected to
			 * has these local loop ports appear on the
			 * fabric and we somehow attach them twice.
			 */
d2531 2
a2532 2
	/* reqp->req_header.rqs_flags = 0; */
	/* reqp->req_header.rqs_seqno = 0; */
d2537 1
a2537 1
		/* XS_RESID(xs) = 0; */
d2549 1
a2549 1
			 * for Request Sense or Simple.
d2554 1
a2554 1
				t2reqp->req_flags = REQFLAG_STAG;
d2558 1
a2558 2
		sdp += XS_CHANNEL(xs);
		if ((sdp->isp_devparam[target].actv_flags & DPARM_TQING) &&
d2568 1
a2568 1
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN)
d2587 1
a2587 1
		isp_prt(isp, ISP_LOGDEBUG0, "out of xflist pointers");
d2691 1
a2691 1
			if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN)  {
d2810 2
a2811 2
void
isp_intr(struct ispsoftc *isp, u_int16_t isr, u_int16_t sema, u_int16_t mbox)
d2813 1
d2815 1
a2815 1
	u_int16_t iptr, optr, junk;
d2818 32
a2849 4
	/*
	 * Is this a mailbox related interrupt?
	 * The mailbox semaphore will be nonzero if so.
	 */
d2851 18
d2894 1
d2896 1
a2896 2
			ISP_WRITE(isp, BIU_SEMA, 0);
			return;
d2905 2
a2906 7
		    "interrupt (ISR=%x SEMA=%x) when not ready", isr, sema);
		/*
		 * Thank you very much!  *Burrrp*!
		 */
		WRITE_RESPONSE_QUEUE_OUT_POINTER(isp,
		    READ_RESPONSE_QUEUE_IN_POINTER(isp));

d2909 1
a2909 1
		return;
d2913 1
a2913 3
	 * Get the current Response Queue Out Pointer.
	 *
	 * If we're a 2300, we can ask what hardware what it thinks.
d2915 1
a2915 9
	if (IS_2300(isp)) {
		optr = ISP_READ(isp, isp->isp_respoutrp);
		if (isp->isp_residx != optr) {
			isp_prt(isp, ISP_LOGWARN, "optr %x soft optr %x",
			    optr, isp->isp_residx);
		}
	} else {
		optr = isp->isp_residx;
	}
d2917 1
a2917 5
	/*
	 * You *must* read the Response Queue In Pointer
	 * prior to clearing the RISC interrupt.
	 */
	if (IS_2100(isp) || IS_2300(isp)) {
d2920 2
a2921 2
			iptr = READ_RESPONSE_QUEUE_IN_POINTER(isp);
			junk = READ_RESPONSE_QUEUE_IN_POINTER(isp);
d2927 2
a2928 3
			    "Response Queue Out Pointer Unstable (%x, %x)",
			    iptr, junk);
			return;
d2931 1
a2931 1
		iptr = READ_RESPONSE_QUEUE_IN_POINTER(isp);
d2934 4
d2948 4
a2951 13
		if (IS_2300(isp)) {
			USEC_DELAY(100);
			iptr = READ_RESPONSE_QUEUE_IN_POINTER(isp);
			junk = ISP_READ(isp, BIU_R2HSTSLO);
		} else {
			junk = ISP_READ(isp, BIU_ISR);
		}
		if (optr == iptr) {
			isp_prt(isp, ISP_LOGDEBUG0,
			    "bogus intr- isr %x (%x) iptr %x optr %x",
			    isr, junk, iptr, optr);
			isp->isp_intbogus++;
		}
a2952 2
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
	ISP_WRITE(isp, BIU_SEMA, 0);
d2999 1
a2999 1
				WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, optr);
d3031 1
a3031 1
			WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, optr);
d3040 1
a3040 1
			WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, optr);
a3118 5
				/*
				 * ????
				 */
				isp_prt(isp, ISP_LOGDEBUG0,
				    "Request Queue Entry bounced back");
d3175 2
a3176 5
		WRITE_RESPONSE_QUEUE_OUT_POINTER(isp, optr);
		/*
		 * While we're at it, reqad the requst queue out pointer.
		 */
		isp->isp_reqodx = READ_REQUEST_QUEUE_OUT_POINTER(isp);
d3186 1
d3214 8
a3221 1
		isp_async(isp, ISPASYNC_FW_CRASH, NULL);
d3239 1
a3239 1
		mbox = READ_REQUEST_QUEUE_OUT_POINTER(isp);
a3331 1
	case ASYNC_LIP_F8:
d3339 1
a3339 1
		isp_async(isp, ISPASYNC_LIP, NULL);
a3342 23
		/*
		 * We've had problems with data corruption occuring on
		 * commands that complete (with no apparent error) after
		 * we receive a LIP. This has been observed mostly on
		 * Local Loop topologies. To be safe, let's just mark
		 * all active commands as dead.
		 */
		if (FCPARAM(isp)->isp_topo == TOPO_NL_PORT ||
		    FCPARAM(isp)->isp_topo == TOPO_FL_PORT) {
			int i, j;
			for (i = j = 0; i < isp->isp_maxcmds; i++) {
				XS_T *xs;
				xs = isp->isp_xflist[i];
				if (xs != NULL) {
					j++;
					XS_SETERR(xs, HBA_BUSRESET);
				}
			}
			if (j) {
				isp_prt(isp, ISP_LOGERR,
				    "LIP destroyed %d active commands", j);
			}
		}
d3372 1
a3372 1
		isp_async(isp, ISPASYNC_LOOP_RESET, NULL);
d3710 2
a3711 2
		isp_prt(isp, ISP_LOGERR, xact3,
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));
d3719 1
a3719 1
		isp_prt(isp, ISP_LOGDEBUG0,
a3721 1

d3725 1
a3725 5
		 *
		 * Unfortunately, some QLogic f/w writers have, in
		 * some cases, ommitted to *set* status to QFULL.
		 *

d3730 1
a3730 8

		 *
		 *
		 */

		*XS_STSP(xs) = SCSI_QFULL;
		XS_SETERR(xs, HBA_NOERROR);
		return;
d3733 2
a3734 2
		isp_prt(isp, ISP_LOGERR, pskip, XS_CHANNEL(xs),
		    XS_TGT(xs), XS_LUN(xs));
d3753 1
a3753 1
			sdp->isp_devparam[XS_TGT(xs)].goal_flags &= ~DPARM_WIDE;
d3769 1
a3769 1
			sdp->isp_devparam[XS_TGT(xs)].goal_flags &= ~DPARM_SYNC;
d3791 1
d3873 1
a3873 1
	ISPOPMAP(0x01, 0x0f),	/* 0x08: MBOX_ABOUT_FIRMWARE */
d3949 1
a3949 1
	ISPOPMAP(0xcf, 0x01),	/* 0x54: EXECUTE IOCB A64 */
d4069 1
a4069 1
	ISPOPMAP(0x01, 0x4f),	/* 0x08: MBOX_ABOUT_FIRMWARE */
d4101 1
a4101 1
	ISPOPMAP(0x01, 0x03),	/* 0x28: MBOX_GET_FIRMWARE_OPTIONS */
d4154 1
a4154 1
	ISPOPMAP(0x07, 0x03),	/* 0x5d: MBOX_GET_SET_DATA_RATE */
d4285 1
a4285 1
	"GET/SET DATA RATE",
d4515 1
a4515 1
		 * take what's in goal_flags and try and set the device
d4530 1
a4530 1
			 * Make sure goal_flags has "Renegotiate on Error"
d4533 2
a4534 4
			sdp->isp_devparam[tgt].goal_flags |= DPARM_RENEG;
			sdp->isp_devparam[tgt].goal_flags &= ~DPARM_QFRZ;

			mbs.param[2] = sdp->isp_devparam[tgt].goal_flags;
d4536 2
d4550 2
a4551 2
				    (sdp->isp_devparam[tgt].goal_offset << 8) |
				    (sdp->isp_devparam[tgt].goal_period);
d4555 1
a4555 1
			 * RQSTF_NEGOTIATION set can cause
d4557 1
d4565 3
a4567 3
			sdp->isp_devparam[tgt].actv_flags &= ~DPARM_TQING;
			sdp->isp_devparam[tgt].actv_flags |=
			    (sdp->isp_devparam[tgt].goal_flags & DPARM_TQING);
d4587 3
a4589 3
		sdp->isp_devparam[tgt].actv_flags = flags;
		sdp->isp_devparam[tgt].actv_period = period;
		sdp->isp_devparam[tgt].actv_offset = offset;
d4696 1
a4696 1
	sdp->isp_cmd_dma_burst_enable = 0;
d4708 3
a4710 7
	sdp->isp_bus_reset_delay = 5;
	/*
	 * Don't retry selection, busy or queue full automatically- reflect
	 * these back to us.
	 */
	sdp->isp_retry_count = 0;
	sdp->isp_retry_delay = 0;
d4719 3
a4721 3
	 * If we're successful reading it, we can then return because NVRAM
	 * will tell us what the desired settings are. Otherwise, we establish
	 * some reasonable 'fake' nvram and goal defaults.
a4722 1

d4746 6
a4751 8
	isp_prt(isp, ISP_LOGDEBUG0, sc0, sc3,
	    0, sdp->isp_fifo_threshold, sdp->isp_initiator_id,
	    sdp->isp_bus_reset_delay, sdp->isp_retry_count,
	    sdp->isp_retry_delay, sdp->isp_async_data_setup);
	isp_prt(isp, ISP_LOGDEBUG0, sc1, sc3,
	    sdp->isp_req_ack_active_neg, sdp->isp_data_line_active_neg,
	    sdp->isp_data_dma_burst_enabl, sdp->isp_cmd_dma_burst_enable,
	    sdp->isp_selection_timeout, sdp->isp_max_queue_depth);
d4755 1
a4755 1
	 * state (goal_flags). Then try and get the current status from
d4760 4
a4763 8
		u_int8_t off, per;
		sdp->isp_devparam[tgt].actv_offset = 0;
		sdp->isp_devparam[tgt].actv_period = 0;
		sdp->isp_devparam[tgt].actv_flags = 0;

		sdp->isp_devparam[tgt].goal_flags =
		    sdp->isp_devparam[tgt].nvrm_flags = DPARM_DEFAULT;

d4768 1
a4768 10
		if (IS_ULTRA3(isp)) {
			off = ISP_80M_SYNCPARMS >> 8;
			per = ISP_80M_SYNCPARMS & 0xff;
		} else if (IS_ULTRA2(isp)) {
			off = ISP_40M_SYNCPARMS >> 8;
			per = ISP_40M_SYNCPARMS & 0xff;
		} else if (IS_1240(isp)) {
			off = ISP_20M_SYNCPARMS >> 8;
			per = ISP_20M_SYNCPARMS & 0xff;
		} else if ((isp->isp_bustype == ISP_BT_SBUS &&
d4774 19
a4792 2
			off = ISP_10M_SYNCPARMS >> 8;
			per = ISP_10M_SYNCPARMS & 0xff;
d4794 49
a4842 2
			off = ISP_20M_SYNCPARMS_1040 >> 8;
			per = ISP_20M_SYNCPARMS_1040 & 0xff;
d4844 5
a4848 9
		sdp->isp_devparam[tgt].goal_offset =
		    sdp->isp_devparam[tgt].nvrm_offset = off;
		sdp->isp_devparam[tgt].goal_period =
		    sdp->isp_devparam[tgt].nvrm_period = per;

		isp_prt(isp, ISP_LOGDEBUG0, sc2, sc3,
		    channel, tgt, sdp->isp_devparam[tgt].nvrm_flags,
		    sdp->isp_devparam[tgt].nvrm_offset,
		    sdp->isp_devparam[tgt].nvrm_period);
d5043 1
a5044 1
	int tgt;
d5097 9
a5106 23
	isp_prt(isp, ISP_LOGDEBUG0, sc0, sc4,
	    0, sdp->isp_fifo_threshold, sdp->isp_initiator_id,
	    sdp->isp_bus_reset_delay, sdp->isp_retry_count,
	    sdp->isp_retry_delay, sdp->isp_async_data_setup);
	isp_prt(isp, ISP_LOGDEBUG0, sc1, sc4,
	    sdp->isp_req_ack_active_neg, sdp->isp_data_line_active_neg,
	    sdp->isp_data_dma_burst_enabl, sdp->isp_cmd_dma_burst_enable,
	    sdp->isp_selection_timeout, sdp->isp_max_queue_depth);

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		sdp->isp_devparam[tgt].dev_enable =
			ISP_NVRAM_TGT_DEVICE_ENABLE(nvram_data, tgt);
		sdp->isp_devparam[tgt].exc_throttle =
			ISP_NVRAM_TGT_EXEC_THROTTLE(nvram_data, tgt);
		sdp->isp_devparam[tgt].nvrm_offset =
			ISP_NVRAM_TGT_SYNC_OFFSET(nvram_data, tgt);
		sdp->isp_devparam[tgt].nvrm_period =
			ISP_NVRAM_TGT_SYNC_PERIOD(nvram_data, tgt);
		/*
		 * We probably shouldn't lie about this, but it
		 * it makes it much safer if we limit NVRAM values
		 * to sanity.
		 */
d5112 2
a5113 2
			if (sdp->isp_devparam[tgt].nvrm_period < 0x19) {
				sdp->isp_devparam[tgt].nvrm_period = 0x19;
d5115 2
a5116 2
			if (sdp->isp_devparam[tgt].nvrm_offset > 0xc) {
				sdp->isp_devparam[tgt].nvrm_offset = 0x0c;
d5119 2
a5120 2
			if (sdp->isp_devparam[tgt].nvrm_offset > 0x8) {
				sdp->isp_devparam[tgt].nvrm_offset = 0x8;
d5123 15
a5137 25
		sdp->isp_devparam[tgt].nvrm_flags = 0;
		if (ISP_NVRAM_TGT_RENEG(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_RENEG;
		sdp->isp_devparam[tgt].nvrm_flags |= DPARM_ARQ;
		if (ISP_NVRAM_TGT_TQING(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_TQING;
		if (ISP_NVRAM_TGT_SYNC(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_SYNC;
		if (ISP_NVRAM_TGT_WIDE(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_WIDE;
		if (ISP_NVRAM_TGT_PARITY(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_PARITY;
		if (ISP_NVRAM_TGT_DISC(nvram_data, tgt))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_DISC;
		sdp->isp_devparam[tgt].actv_flags = 0; /* we don't know */
		isp_prt(isp, ISP_LOGDEBUG0, sc2, sc4,
		    0, tgt, sdp->isp_devparam[tgt].nvrm_flags,
		    sdp->isp_devparam[tgt].nvrm_offset,
		    sdp->isp_devparam[tgt].nvrm_period);
		sdp->isp_devparam[tgt].goal_offset =
		    sdp->isp_devparam[tgt].nvrm_offset;
		sdp->isp_devparam[tgt].goal_period =
		    sdp->isp_devparam[tgt].nvrm_period;
		sdp->isp_devparam[tgt].goal_flags =
		    sdp->isp_devparam[tgt].nvrm_flags;
d5144 1
a5145 2
	int tgt;

d5148 1
a5148 1
	sdp->isp_fifo_threshold =
d5164 2
a5165 1
	    ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data, bus);
d5168 2
a5169 1
	    ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data, bus);
d5172 2
a5173 1
	    ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data, bus);
d5187 24
a5210 44
	isp_prt(isp, ISP_LOGDEBUG0, sc0, sc4,
	    bus, sdp->isp_fifo_threshold, sdp->isp_initiator_id,
	    sdp->isp_bus_reset_delay, sdp->isp_retry_count,
	    sdp->isp_retry_delay, sdp->isp_async_data_setup);
	isp_prt(isp, ISP_LOGDEBUG0, sc1, sc4,
	    sdp->isp_req_ack_active_neg, sdp->isp_data_line_active_neg,
	    sdp->isp_data_dma_burst_enabl, sdp->isp_cmd_dma_burst_enable,
	    sdp->isp_selection_timeout, sdp->isp_max_queue_depth);


	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		sdp->isp_devparam[tgt].dev_enable =
		    ISP1080_NVRAM_TGT_DEVICE_ENABLE(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].exc_throttle =
			ISP1080_NVRAM_TGT_EXEC_THROTTLE(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_offset =
			ISP1080_NVRAM_TGT_SYNC_OFFSET(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_period =
			ISP1080_NVRAM_TGT_SYNC_PERIOD(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_flags = 0;
		if (ISP1080_NVRAM_TGT_RENEG(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_RENEG;
		sdp->isp_devparam[tgt].nvrm_flags |= DPARM_ARQ;
		if (ISP1080_NVRAM_TGT_TQING(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_TQING;
		if (ISP1080_NVRAM_TGT_SYNC(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_SYNC;
		if (ISP1080_NVRAM_TGT_WIDE(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_WIDE;
		if (ISP1080_NVRAM_TGT_PARITY(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_PARITY;
		if (ISP1080_NVRAM_TGT_DISC(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_DISC;
		sdp->isp_devparam[tgt].actv_flags = 0;
		isp_prt(isp, ISP_LOGDEBUG0, sc2, sc4,
		    bus, tgt, sdp->isp_devparam[tgt].nvrm_flags,
		    sdp->isp_devparam[tgt].nvrm_offset,
		    sdp->isp_devparam[tgt].nvrm_period);
		sdp->isp_devparam[tgt].goal_offset =
		    sdp->isp_devparam[tgt].nvrm_offset;
		sdp->isp_devparam[tgt].goal_period =
		    sdp->isp_devparam[tgt].nvrm_period;
		sdp->isp_devparam[tgt].goal_flags =
		    sdp->isp_devparam[tgt].nvrm_flags;
d5218 1
a5218 1
	int tgt;
d5225 1
a5225 1
	sdp->isp_initiator_id =
d5238 2
a5239 1
	    ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data, bus);
d5242 2
a5243 1
	    ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data, bus);
d5246 2
a5247 1
	    ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data, bus);
d5261 24
a5284 43
	isp_prt(isp, ISP_LOGDEBUG0, sc0, sc4,
	    bus, sdp->isp_fifo_threshold, sdp->isp_initiator_id,
	    sdp->isp_bus_reset_delay, sdp->isp_retry_count,
	    sdp->isp_retry_delay, sdp->isp_async_data_setup);
	isp_prt(isp, ISP_LOGDEBUG0, sc1, sc4,
	    sdp->isp_req_ack_active_neg, sdp->isp_data_line_active_neg,
	    sdp->isp_data_dma_burst_enabl, sdp->isp_cmd_dma_burst_enable,
	    sdp->isp_selection_timeout, sdp->isp_max_queue_depth);

	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
		sdp->isp_devparam[tgt].dev_enable =
		    ISP12160_NVRAM_TGT_DEVICE_ENABLE(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].exc_throttle =
			ISP12160_NVRAM_TGT_EXEC_THROTTLE(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_offset =
			ISP12160_NVRAM_TGT_SYNC_OFFSET(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_period =
			ISP12160_NVRAM_TGT_SYNC_PERIOD(nvram_data, tgt, bus);
		sdp->isp_devparam[tgt].nvrm_flags = 0;
		if (ISP12160_NVRAM_TGT_RENEG(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_RENEG;
		sdp->isp_devparam[tgt].nvrm_flags |= DPARM_ARQ;
		if (ISP12160_NVRAM_TGT_TQING(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_TQING;
		if (ISP12160_NVRAM_TGT_SYNC(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_SYNC;
		if (ISP12160_NVRAM_TGT_WIDE(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_WIDE;
		if (ISP12160_NVRAM_TGT_PARITY(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_PARITY;
		if (ISP12160_NVRAM_TGT_DISC(nvram_data, tgt, bus))
			sdp->isp_devparam[tgt].nvrm_flags |= DPARM_DISC;
		sdp->isp_devparam[tgt].actv_flags = 0;
		isp_prt(isp, ISP_LOGDEBUG0, sc2, sc4,
		    bus, tgt, sdp->isp_devparam[tgt].nvrm_flags,
		    sdp->isp_devparam[tgt].nvrm_offset,
		    sdp->isp_devparam[tgt].nvrm_period);
		sdp->isp_devparam[tgt].goal_offset =
		    sdp->isp_devparam[tgt].nvrm_offset;
		sdp->isp_devparam[tgt].goal_period =
		    sdp->isp_devparam[tgt].nvrm_period;
		sdp->isp_devparam[tgt].goal_flags =
		    sdp->isp_devparam[tgt].nvrm_flags;
d5310 1
a5310 1
			wwn |= (((u_int64_t) 2)<< 60);
d5319 1
a5319 1
			wwn |= (((u_int64_t) 2)<< 60);
d5364 1
a5364 2
	    "NVRAM: maxfrmlen %d execthrottle %d fwoptions 0x%x",
	    fcp->isp_maxfrmlen, fcp->isp_execthrottle, fcp->isp_fwoptions);
@


1.12.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/* 	$OpenBSD$ */
d112 31
a142 31
static int isp_parse_async(struct ispsoftc *, int);
static int isp_handle_other_response(struct ispsoftc *, int, isphdr_t *,
    u_int16_t *);
static void
isp_parse_status(struct ispsoftc *, ispstatusreq_t *, XS_T *);
static void isp_fastpost_complete(struct ispsoftc *, u_int16_t);
static void isp_scsi_init(struct ispsoftc *);
static void isp_scsi_channel_init(struct ispsoftc *, int);
static void isp_fibre_init(struct ispsoftc *);
static void isp_mark_getpdb_all(struct ispsoftc *);
static int isp_getmap(struct ispsoftc *, fcpos_map_t *);
static int isp_getpdb(struct ispsoftc *, int, isp_pdb_t *);
static u_int64_t isp_get_portname(struct ispsoftc *, int, int);
static int isp_fclink_test(struct ispsoftc *, int);
static char *isp2100_fw_statename(int);
static int isp_pdb_sync(struct ispsoftc *);
static int isp_scan_loop(struct ispsoftc *);
static int isp_scan_fabric(struct ispsoftc *);
static void isp_register_fc4_type(struct ispsoftc *);
static void isp_fw_state(struct ispsoftc *);
static void isp_mboxcmd(struct ispsoftc *, mbreg_t *, int);

static void isp_update(struct ispsoftc *);
static void isp_update_bus(struct ispsoftc *, int);
static void isp_setdfltparm(struct ispsoftc *, int);
static int isp_read_nvram(struct ispsoftc *);
static void isp_rdnvram_word(struct ispsoftc *, int, u_int16_t *);
static void isp_parse_nvram_1020(struct ispsoftc *, u_int8_t *);
static void isp_parse_nvram_1080(struct ispsoftc *, int, u_int8_t *);
static void isp_parse_nvram_12160(struct ispsoftc *, int, u_int8_t *);
static void isp_parse_nvram_2100(struct ispsoftc *, u_int8_t *);
d695 1
a695 1
	if (ISP_SBUS_SUPPORTED && isp->isp_bustype == ISP_BT_SBUS) {
d1110 1
a1110 1
	isp_icb_t local, *icbp = &local;
d1132 1
d1134 1
d1292 2
a1293 1
	isp_put_icb(isp, icbp, (isp_icb_t *)fcp->isp_scratch);
d1386 1
a1386 1
		isp_get_pdb(isp, (isp_pdb_t *)fcp->isp_scratch, pdbp);
d2267 3
d2277 2
a2278 1

a2287 1

d2289 15
a2303 18
		mbreg_t mbs;
		sns_screq_t *rq;
		sns_ganrsp_t *rs0, *rs1;
		u_int8_t sc[SNS_GAN_REQ_SIZE];

		rq = (sns_screq_t *)sc;
		MEMZERO((void *) rq, SNS_GAN_REQ_SIZE);
		rq->snscb_rblen = SNS_GAN_RESP_SIZE >> 1;
		rq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+0x100);
		rq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+0x100);
		rq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+0x100);
		rq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+0x100);
		rq->snscb_sblen = 6;
		rq->snscb_data[0] = SNS_GAN;
		rq->snscb_data[4] = portid & 0xffff;
		rq->snscb_data[5] = (portid >> 16) & 0xff;
		isp_put_sns_request(isp, rq, (sns_screq_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GAN_REQ_SIZE);
d2354 5
a2358 8
		MEMORYBARRIER(isp, SYNC_SFORCPU, 0x100, SNS_GAN_RESP_SIZE);
		rs1 = (sns_ganrsp_t *) fcp->isp_scratch;
		rs0 = (sns_ganrsp_t *) ((u_int8_t *)fcp->isp_scratch + 0x100);
		isp_get_gan_response(isp, rs0, rs1);
		portid = (((u_int32_t) rs1->snscb_port_id[0]) << 16) |
		    (((u_int32_t) rs1->snscb_port_id[1]) << 8) |
		    (((u_int32_t) rs1->snscb_port_id[2]));
		(void) isp_async(isp, ISPASYNC_FABRIC_DEV, rs1);
d2389 1
a2389 2
	u_int8_t local[SNS_RFT_REQ_SIZE];
	sns_screq_t *reqp = (sns_screq_t *) local;
d2392 1
d2407 1
a2407 1
	isp_put_sns_request(isp, reqp, (sns_screq_t *) fcp->isp_scratch);
d2431 8
a2438 3
	u_int16_t nxti, optr, handle;
	u_int8_t local[QENTRY_LEN];
	ispreq_t *reqp, *qep;
d2670 1
a2670 1
	if (isp_getrqentry(isp, &nxti, &optr, (void **)&qep)) {
a2680 1
	reqp = (ispreq_t *) local;
d2690 1
a2690 1
			MEMZERO((void *) reqp, QENTRY_LEN);
d2695 4
a2698 4
			isp_put_request(isp, reqp, qep);
			ISP_ADD_REQUEST(isp, nxti);
			isp->isp_sendmarker &= ~(1 << i);
			if (isp_getrqentry(isp, &nxti, &optr, (void **) &qep)) {
d2707 1
a2707 1
	MEMZERO((void *)reqp, QENTRY_LEN);
d2731 1
a2731 1
			((ispreqt2_t *)reqp)->req_flags = XS_TAG_TYPE(xs);
d2738 1
a2738 1
				((ispreqt2_t *)reqp)->req_flags = REQFLAG_HTAG;
d2740 1
a2740 1
				((ispreqt2_t *)reqp)->req_flags = REQFLAG_STAG;
d2756 1
a2756 1
			((ispreqt2_t *)reqp)->req_scclun = XS_LUN(xs);
d2758 1
a2758 1
			((ispreqt2_t *)reqp)->req_lun_trn = XS_LUN(xs);
d2763 1
a2763 1
	if (reqp->req_time == 0 && XS_TIME(xs)) {
d2765 7
a2772 1

a2778 1

d2782 2
a2783 2
	 */
	i = ISP_DMASETUP(isp, xs, reqp, &nxti, optr);
d2797 1
a2797 1
	ISP_ADD_REQUEST(isp, nxti);
d2799 2
d2802 2
d3010 2
a3011 2
			if (isp->isp_mboxbsy) {
				int i = 0, obits = isp->isp_obits;
d3122 1
a3122 3
		ispstatusreq_t local, *sp = &local;
		isphdr_t *hp;
		int type;
d3126 1
a3126 1
		hp = (isphdr_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);
d3131 8
a3138 11
		 * Synchronize our view of this response queue entry.
		 */
		MEMORYBARRIER(isp, SYNC_RESULT, oop, QENTRY_LEN);

		type = isp_get_response_type(isp, hp);

		if (type == RQSTYPE_RESPONSE) {
			isp_get_response(isp, (ispstatusreq_t *) hp, sp);
		} else {
			if (!isp_handle_other_response(isp, type, hp, &optr)) {
				MEMZERO(hp, QENTRY_LEN);	/* PERF */
a3140 8

			/*
			 * After this point, we'll just look at the header as
			 * we don't know how to deal with the rest of the
			 * response.
			 */
			isp_get_response(isp, (ispstatusreq_t *) hp, sp);

d3154 1
a3154 1
				MEMZERO(hp, QENTRY_LEN);	/* PERF */
d3193 1
a3193 1
			MEMZERO(hp, QENTRY_LEN);	/* PERF */
d3203 1
a3203 1
			MEMZERO(hp, QENTRY_LEN);	/* PERF */
a3211 1
			XS_SETERR(xs, HBA_BUSRESET);
d3335 1
a3335 1
		MEMZERO(hp, QENTRY_LEN);	/* PERF */
d3654 2
a3655 2
isp_handle_other_response(struct ispsoftc *isp, int type,
    isphdr_t *hp, u_int16_t *optrp)
d3657 1
a3657 1
	switch (type) {
d3672 1
a3672 1
		return (isp_target_notify(isp, (ispstatusreq_t *) hp, optrp));
d3679 1
a3679 1
		if (isp_async(isp, ISPASYNC_UNHANDLED_RESPONSE, hp)) {
d3683 1
a3683 1
		    isp_get_response_type(isp, hp));
d4571 1
a4571 2
	isp->isp_obits = obits;
	isp->isp_mboxbsy = 1;
a4581 9

	if (isp->isp_mboxbsy) {
		/*
		 * Command timed out.
		 */
		isp->isp_mboxbsy = 0;
		MBOX_RELEASE(isp);
		return;
	}
@


1.12.2.6
log
@Sync the SMP branch with 3.3
@
text
@a98 2
static const char swrej[] =
    "Fabric Nameserver rejected %s (Reason=0x%x Expl=0x%x) for Port ID 0x%x";
a107 2
static const char bun[] =
    "bad underrun for %d.%d (count %d, resid %d, status %s)";
d112 1
a112 1
static int isp_parse_async(struct ispsoftc *, u_int16_t);
a117 1
static int isp_mbox_continue(struct ispsoftc *);
d129 1
a129 2
static int isp_fabric_mbox_cmd(struct ispsoftc *, mbreg_t *);
static int isp_scan_fabric(struct ispsoftc *, int);
a131 1
static void isp_mboxcmd_qnw(struct ispsoftc *, mbreg_t *, int);
d157 1
a157 1
	int loops, i, dodnld = 1;
d180 1
a180 1
	if (isp->isp_touched == 0) {
d216 1
a216 1
	if (IS_23XX(isp)) {
a244 3
		case ISP_HA_FC_2312:
			btype = "2312";
			break;
a276 2
		else if (IS_10160(isp))
			btype = "10160";
d390 1
a390 1
			 * If we're in Ultra Mode, we have to be 60MHz clock-
d538 1
a538 1
		if (IS_2200(isp) || IS_23XX(isp)) {
d556 1
a556 1
	if (IS_23XX(isp)) {
d622 1
a622 1
	if (IS_23XX(isp))
d628 12
a639 13
		isp->isp_mbxworkp = (void *) &isp->isp_mdvec->dv_ispfw[1];
		isp->isp_mbxwrk0 = isp->isp_mdvec->dv_ispfw[3] - 1;
		isp->isp_mbxwrk1 = code_org + 1;
		mbs.param[0] = MBOX_WRITE_RAM_WORD;
		mbs.param[1] = code_org;
		mbs.param[2] = isp->isp_mdvec->dv_ispfw[0];
		isp_mboxcmd(isp, &mbs, MBLOGNONE);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			isp_prt(isp, ISP_LOGERR,
			    "F/W download failed at word %d",
			    isp->isp_mbxwrk1 - code_org);
			dodnld = 0;
			goto again;
d641 1
d669 2
a670 4
	/*
	 * Give it a chance to start.
	 */
	USEC_DELAY(500);
d719 1
a719 4
		 * than 1.17.0, unless it's the firmware we specifically
		 * are loading.
		 *
		 * Note that all 22XX and 23XX f/w is greater than 1.X.0.
d721 2
a722 4
		if (!(ISP_FW_NEWER_THAN(isp, 1, 17, 0))) {
#ifdef	USE_SMALLER_2100_FIRMWARE
			FCPARAM(isp)->isp_fwattr = ISP_FW_ATTR_SCCLUN;
#else
a723 1
#endif
d768 1
a768 1
	 * 16384 luns for Fibre Channel cards.
d773 1
a773 1
	 * Because the lun is in a different position in the Request Queue
d777 4
d782 3
a784 3
	if (IS_SCSI(isp)) {
		if (dodnld) {
			if (IS_ULTRA2(isp) || IS_ULTRA3(isp)) {
d790 5
a794 7
			isp->isp_maxluns = 8;
		}
	} else {
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
			isp->isp_maxluns = 16384;
		} else {
			isp->isp_maxluns = 16;
d933 11
a943 13
	if (IS_ULTRA2(isp) || IS_1240(isp)) {
		mbs.param[0] = MBOX_INIT_RES_QUEUE_A64;
		mbs.param[1] = RESULT_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_result_dma);
		mbs.param[3] = DMA_WD0(isp->isp_result_dma);
		mbs.param[4] = 0;
		mbs.param[6] = DMA_WD3(isp->isp_result_dma);
		mbs.param[7] = DMA_WD2(isp->isp_result_dma);
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_residx = mbs.param[5];
d945 8
a952 34
		mbs.param[0] = MBOX_INIT_REQ_QUEUE_A64;
		mbs.param[1] = RQUEST_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
		mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
		mbs.param[5] = 0;
		mbs.param[6] = DMA_WD3(isp->isp_result_dma);
		mbs.param[7] = DMA_WD2(isp->isp_result_dma);
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_reqidx = isp->isp_reqodx = mbs.param[4];
	} else {
		mbs.param[0] = MBOX_INIT_RES_QUEUE;
		mbs.param[1] = RESULT_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_result_dma);
		mbs.param[3] = DMA_WD0(isp->isp_result_dma);
		mbs.param[4] = 0;
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_residx = mbs.param[5];

		mbs.param[0] = MBOX_INIT_REQ_QUEUE;
		mbs.param[1] = RQUEST_QUEUE_LEN(isp);
		mbs.param[2] = DMA_WD1(isp->isp_rquest_dma);
		mbs.param[3] = DMA_WD0(isp->isp_rquest_dma);
		mbs.param[5] = 0;
		isp_mboxcmd(isp, &mbs, MBLOGALL);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			return;
		}
		isp->isp_reqidx = isp->isp_reqodx = mbs.param[4];
d954 1
a968 5
#ifndef	ISP_NO_RIO
	if (IS_ULTRA2(isp) || IS_1240(isp))
		mbs.param[1] |= FW_FEATURE_RIO_16BIT;
#else
#ifndef	ISP_NO_FASTPOST
a970 2
#endif
#endif
d1131 1
a1131 1
	loopid = fcp->isp_loopid;
d1154 1
a1154 1
	if (!ISP_FW_NEWER_THAN(isp, 1, 17, 0)) {
d1163 1
d1207 1
a1207 1
	if (IS_2200(isp) || IS_23XX(isp)) {
d1226 4
a1229 20
		if (IS_23XX(isp)) {
			/*
			 * QLogic recommends that FAST Posting be turned
			 * off for 23XX cards and instead allow the HBA
			 * to write response queue entries and interrupt
			 * after a delay (ZIO).
			 *
			 * If we set ZIO, it will disable fast posting,
			 * so we don't need to clear it in fwoptions.
			 */
			icbp->icb_xfwoptions |= ICBXOPT_ZIO;
#if	0
			/*
			 * Values, in 100us increments. The default
			 * is 2 (200us) if a value 0 (default) is
			 * selected.
			 */
			icbp->icb_idelaytimer = 2;
#endif

d1240 2
a1241 26
#ifndef	ISP_NO_RIO_FC
	/*
	 * RIO seems to be enabled in 2100s for fw >= 1.17.0.
	 *
	 * I've had some questionable problems with RIO on 2200.
	 * More specifically, on a 2204 I had problems with RIO
	 * on a Linux system where I was dropping commands right
	 * and left. It's not clear to me what the actual problem
	 * was.
	 *
	 * 23XX Cards do not support RIO. Instead they support ZIO.
	 */
#if	0
	if (!IS_23XX(isp) && ISP_FW_NEWER_THAN(isp, 1, 17, 0)) {
		icbp->icb_xfwoptions |= ICBXOPT_RIO_16BIT;
		icbp->icb_racctimer = 4;
		icbp->icb_idelaytimer = 8;
	}
#endif
#endif

	/*
	 * For 22XX > 2.1.26 && 23XX, set someoptions.
	 * XXX: Probably okay for newer 2100 f/w too.
	 */
	if (ISP_FW_NEWER_THAN(isp, 2, 26, 0)) {
d1255 1
a1255 1
	if (IS_23XX(isp)) {
d1288 2
a1289 5
	isp_prt(isp, ISP_LOGDEBUG0,
	    "isp_fibre_init: fwopt 0x%x xfwopt 0x%x zfwopt 0x%x",
	    icbp->icb_fwoptions, icbp->icb_xfwoptions, icbp->icb_zfwoptions);

	FC_SCRATCH_ACQUIRE(isp);
a1303 1
	FC_SCRATCH_RELEASE(isp);
a1342 1
	FC_SCRATCH_ACQUIRE(isp);
a1346 1
		FC_SCRATCH_RELEASE(isp);
a1348 1
	FC_SCRATCH_RELEASE(isp);
a1380 1
	FC_SCRATCH_ACQUIRE(isp);
a1383 1
		FC_SCRATCH_RELEASE(isp);
a1385 1
	FC_SCRATCH_RELEASE(isp);
d1520 1
a1520 1
	if (IS_2200(isp) || IS_23XX(isp)) {
d1534 1
a1534 1
	 * (in case we're connected to a server doing aliasing).
d1538 3
a1540 12
	if (IS_2100(isp)) {
		/*
		 * Don't bother with fabric if we are using really old
		 * 2100 firmware. It's just not worth it.
		 */
		if (ISP_FW_NEWER_THAN(isp, 1, 15, 37)) {
			check_for_fabric = 1;
		} else {
			check_for_fabric = 0;
		}
	} else if (fcp->isp_topo == TOPO_FL_PORT ||
	    fcp->isp_topo == TOPO_F_PORT) {
d1542 1
a1542 1
	} else
d1597 1
a1597 1
	if (IS_23XX(isp)) {
d1610 1
a1610 1
	isp_prt(isp, ISP_LOGCONFIG, topology, fcp->isp_loopid, fcp->isp_alpa,
d1777 1
a1777 1
		if (lp->loggedin && lp->force_logout == 0 &&
d1806 1
a1806 1
				isp_prt(isp, ISP_LOGCONFIG, lretained,
d1813 2
d1824 1
a1824 2
			if (lp->force_logout ||
			    isp_getpdb(isp, lp->loopid, &pdb) == 0) {
d1830 1
d1835 1
a1835 1
			lp->force_logout = lp->loggedin = 0;
d1852 4
a2258 50

static int
isp_fabric_mbox_cmd(struct ispsoftc *isp, mbreg_t *mbp)
{
	isp_mboxcmd(isp, mbp, MBLOGNONE);
	if (mbp->param[0] != MBOX_COMMAND_COMPLETE) {
		if (FCPARAM(isp)->isp_loopstate == LOOP_SCANNING_FABRIC) {
			FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
		}
		if (mbp->param[0] == MBOX_COMMAND_ERROR) {
			char tbuf[16];
			char *m;
			switch (mbp->param[1]) {
			case 1:
				m = "No Loop";
				break;
			case 2:
				m = "Failed to allocate IOCB buffer";
				break;
			case 3:
				m = "Failed to allocate XCB buffer";
				break;
			case 4:
				m = "timeout or transmit failed";
				break;
			case 5:
				m = "no fabric loop";
				break;
			case 6:
				m = "remote device not a target";
				break;
			default:
				SNPRINTF(tbuf, sizeof tbuf, "%x",
				    mbp->param[1]);
				m = tbuf;
				break;
			}
			isp_prt(isp, ISP_LOGERR, "SNS Failed- %s", m);
		}
		return (-1);
	}

	if (FCPARAM(isp)->isp_fwstate != FW_READY ||
	    FCPARAM(isp)->isp_loopstate < LOOP_SCANNING_FABRIC) {
		return (-1);
	}
	return(0);
}

#ifdef	ISP_USE_GA_NXT
d2260 1
a2260 1
isp_scan_fabric(struct ispsoftc *isp, int ftype)
d2264 1
a2264 1
	int hicap, last_port_same;
a2270 1
	FC_SCRATCH_ACQUIRE(isp);
d2281 2
a2282 1
	for (hicap = 0; hicap < GA_NXT_MAX; hicap++) {
d2285 2
a2286 3
		sns_ga_nxt_rsp_t *rs0, *rs1;
		struct lportdb lcl;
		u_int8_t sc[SNS_GA_NXT_RESP_SIZE];
d2289 2
a2290 2
		MEMZERO((void *) rq, SNS_GA_NXT_REQ_SIZE);
		rq->snscb_rblen = SNS_GA_NXT_RESP_SIZE >> 1;
d2296 1
a2296 1
		rq->snscb_data[0] = SNS_GA_NXT;
d2300 1
a2300 1
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GA_NXT_REQ_SIZE);
d2302 1
a2302 1
		mbs.param[1] = SNS_GA_NXT_REQ_SIZE >> 1;
d2310 3
a2312 2
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
d2315 30
a2344 1
			FC_SCRATCH_RELEASE(isp);
d2347 3
a2349 17
		MEMORYBARRIER(isp, SYNC_SFORCPU, 0x100, SNS_GA_NXT_RESP_SIZE);
		rs1 = (sns_ga_nxt_rsp_t *) sc;
		rs0 = (sns_ga_nxt_rsp_t *) ((u_int8_t *)fcp->isp_scratch+0x100);
		isp_get_ga_nxt_response(isp, rs0, rs1);
		if (rs1->snscb_cthdr.ct_response != FS_ACC) {
			int level;
			if (rs1->snscb_cthdr.ct_reason == 9 &&
			    rs1->snscb_cthdr.ct_explanation == 7)
				level = ISP_LOGDEBUG0;
			else
				level = ISP_LOGWARN;
			isp_prt(isp, level, swrej, "GA_NXT",
			    rs1->snscb_cthdr.ct_reason,
			    rs1->snscb_cthdr.ct_explanation, portid);
			FC_SCRATCH_RELEASE(isp);
			fcp->isp_loopstate = LOOP_FSCAN_DONE;
			return (0);
d2351 5
a2355 2
		portid =
		    (((u_int32_t) rs1->snscb_port_id[0]) << 16) |
d2358 1
a2358 52

		/*
		 * XXX: We should check to make sure that this entry
		 * XXX: supports the type(s) we are interested in.
		 */
		/*
		 * Okay, we now have information about a fabric object.
		 * If it is the type we're interested in, tell the outer layers
		 * about it. The outer layer needs to  know: Port ID, WWNN,
		 * WWPN, FC4 type, and port type.
		 *
		 * The lportdb structure is adequate for this.
		 */
		MEMZERO(&lcl, sizeof (lcl));
		lcl.port_type = rs1->snscb_port_type;
		lcl.fc4_type = ftype;
		lcl.portid = portid;
		lcl.node_wwn =
		    (((u_int64_t)rs1->snscb_nodename[0]) << 56) |
		    (((u_int64_t)rs1->snscb_nodename[1]) << 48) |
		    (((u_int64_t)rs1->snscb_nodename[2]) << 40) |
		    (((u_int64_t)rs1->snscb_nodename[3]) << 32) |
		    (((u_int64_t)rs1->snscb_nodename[4]) << 24) |
		    (((u_int64_t)rs1->snscb_nodename[5]) << 16) |
		    (((u_int64_t)rs1->snscb_nodename[6]) <<  8) |
		    (((u_int64_t)rs1->snscb_nodename[7]));
		lcl.port_wwn =
		    (((u_int64_t)rs1->snscb_portname[0]) << 56) |
		    (((u_int64_t)rs1->snscb_portname[1]) << 48) |
		    (((u_int64_t)rs1->snscb_portname[2]) << 40) |
		    (((u_int64_t)rs1->snscb_portname[3]) << 32) |
		    (((u_int64_t)rs1->snscb_portname[4]) << 24) |
		    (((u_int64_t)rs1->snscb_portname[5]) << 16) |
		    (((u_int64_t)rs1->snscb_portname[6]) <<  8) |
		    (((u_int64_t)rs1->snscb_portname[7]));

		/*
		 * Does this fabric object support the type we want?
		 * If not, skip it.
		 */
		if (rs1->snscb_fc4_types[ftype >> 5] & (1 << (ftype & 0x1f))) {
			if (first_portid == portid) {
				lcl.last_fabric_dev = 1;
			} else {
				lcl.last_fabric_dev = 0;
			}
			(void) isp_async(isp, ISPASYNC_FABRIC_DEV, &lcl);
		} else {
			isp_prt(isp, ISP_LOGDEBUG0,
			    "PortID 0x%x doesn't support FC4 type 0x%x",
			    portid, ftype);
		}
a2360 1
			FC_SCRATCH_RELEASE(isp);
a2369 1
			last_port_same = 0 ;
a2372 48
	FC_SCRATCH_RELEASE(isp);
	if (hicap >= GA_NXT_MAX) {
		isp_prt(isp, ISP_LOGWARN, "fabric too big (> %d)", GA_NXT_MAX);
	}
	fcp->isp_loopstate = LOOP_FSCAN_DONE;
	return (0);
}
#else
#define	GIDLEN	((ISP2100_SCRLEN >> 1) + 16)
#define	NGENT	((GIDLEN - 16) >> 2)

#define	IGPOFF	(ISP2100_SCRLEN - GIDLEN)
#define	GXOFF	(256)

static int
isp_scan_fabric(struct ispsoftc *isp, int ftype)
{
	fcparam *fcp = FCPARAM(isp);
	mbreg_t mbs;
	int i;
	sns_gid_ft_req_t *rq;
	sns_gid_ft_rsp_t *rs0, *rs1;

	if (fcp->isp_onfabric == 0) {
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		return (0);
	}

	FC_SCRATCH_ACQUIRE(isp);
	fcp->isp_loopstate = LOOP_SCANNING_FABRIC;

	rq = (sns_gid_ft_req_t *)fcp->tport;
	MEMZERO((void *) rq, SNS_GID_FT_REQ_SIZE);
	rq->snscb_rblen = GIDLEN >> 1;
	rq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+IGPOFF);
	rq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+IGPOFF);
	rq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+IGPOFF);
	rq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+IGPOFF);
	rq->snscb_sblen = 6;
	rq->snscb_cmd = SNS_GID_FT;
	rq->snscb_mword_div_2 = NGENT;
	rq->snscb_fc4_type = ftype;
	isp_put_gid_ft_request(isp, rq, (sns_gid_ft_req_t *) fcp->isp_scratch);
	MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GID_FT_REQ_SIZE);
	mbs.param[0] = MBOX_SEND_SNS;
	mbs.param[1] = SNS_GID_FT_REQ_SIZE >> 1;
	mbs.param[2] = DMA_WD1(fcp->isp_scdma);
	mbs.param[3] = DMA_WD0(fcp->isp_scdma);
d2374 2
a2375 33
	/*
	 * Leave 4 and 5 alone
	 */
	mbs.param[6] = DMA_WD3(fcp->isp_scdma);
	mbs.param[7] = DMA_WD2(fcp->isp_scdma);
	if (isp_fabric_mbox_cmd(isp, &mbs)) {
		if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
			fcp->isp_loopstate = LOOP_PDB_RCVD;
		}
		FC_SCRATCH_RELEASE(isp);
		return (-1);
	}
	if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
		FC_SCRATCH_RELEASE(isp);
		return (-1);
	}
	MEMORYBARRIER(isp, SYNC_SFORCPU, IGPOFF, GIDLEN);
	rs1 = (sns_gid_ft_rsp_t *) fcp->tport;
	rs0 = (sns_gid_ft_rsp_t *) ((u_int8_t *)fcp->isp_scratch+IGPOFF);
	isp_get_gid_ft_response(isp, rs0, rs1, NGENT);
	if (rs1->snscb_cthdr.ct_response != FS_ACC) {
		int level;
		if (rs1->snscb_cthdr.ct_reason == 9 &&
		    rs1->snscb_cthdr.ct_explanation == 7)
			level = ISP_LOGDEBUG0;
		else
			level = ISP_LOGWARN;
		isp_prt(isp, level, swrej, "GID_FT",
		    rs1->snscb_cthdr.ct_reason,
		    rs1->snscb_cthdr.ct_explanation, 0);
		FC_SCRATCH_RELEASE(isp);
		fcp->isp_loopstate = LOOP_FSCAN_DONE;
		return (0);
d2379 1
a2379 220
	 * Okay, we now have a list of Port IDs for this class of device.
	 * Go through the list and for each one get the WWPN/WWNN for it
	 * and tell the outer layers about it. The outer layer needs to
	 * know: Port ID, WWNN, WWPN, FC4 type, and (possibly) port type.
	 *
	 * The lportdb structure is adequate for this.
	 */
	i = -1;
	do {
		sns_gxn_id_req_t grqbuf, *gq = &grqbuf;
		sns_gxn_id_rsp_t *gs0, grsbuf, *gs1 = &grsbuf;
		struct lportdb lcl;
#if	0
		sns_gff_id_rsp_t *fs0, ffsbuf, *fs1 = &ffsbuf;
#endif

		i++;
		MEMZERO(&lcl, sizeof (lcl));
		lcl.fc4_type = ftype;
		lcl.portid =
		    (((u_int32_t) rs1->snscb_ports[i].portid[0]) << 16) |
		    (((u_int32_t) rs1->snscb_ports[i].portid[1]) << 8) |
		    (((u_int32_t) rs1->snscb_ports[i].portid[2]));

		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
		gq->snscb_rblen = SNS_GXN_ID_RESP_SIZE >> 1;
		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF);
		gq->snscb_sblen = 6;
		gq->snscb_cmd = SNS_GPN_ID;
		gq->snscb_portid = lcl.portid;
		isp_put_gxn_id_request(isp, gq,
		    (sns_gxn_id_req_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE);
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GXN_ID_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GXN_ID_RESP_SIZE);
		gs0 = (sns_gxn_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
		isp_get_gxn_id_response(isp, gs0, gs1);
		if (gs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, ISP_LOGWARN, swrej, "GPN_ID",
			    gs1->snscb_cthdr.ct_reason,
			    gs1->snscb_cthdr.ct_explanation, lcl.portid);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				return (-1);
			}
			continue;
		}
		lcl.port_wwn = 
		    (((u_int64_t)gs1->snscb_wwn[0]) << 56) |
		    (((u_int64_t)gs1->snscb_wwn[1]) << 48) |
		    (((u_int64_t)gs1->snscb_wwn[2]) << 40) |
		    (((u_int64_t)gs1->snscb_wwn[3]) << 32) |
		    (((u_int64_t)gs1->snscb_wwn[4]) << 24) |
		    (((u_int64_t)gs1->snscb_wwn[5]) << 16) |
		    (((u_int64_t)gs1->snscb_wwn[6]) <<  8) |
		    (((u_int64_t)gs1->snscb_wwn[7]));

		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
		gq->snscb_rblen = SNS_GXN_ID_RESP_SIZE >> 1;
		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF);
		gq->snscb_sblen = 6;
		gq->snscb_cmd = SNS_GNN_ID;
		gq->snscb_portid = lcl.portid;
		isp_put_gxn_id_request(isp, gq,
		    (sns_gxn_id_req_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE);
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GXN_ID_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GXN_ID_RESP_SIZE);
		gs0 = (sns_gxn_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
		isp_get_gxn_id_response(isp, gs0, gs1);
		if (gs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, ISP_LOGWARN, swrej, "GNN_ID",
			    gs1->snscb_cthdr.ct_reason,
			    gs1->snscb_cthdr.ct_explanation, lcl.portid);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				return (-1);
			}
			continue;
		}
		lcl.node_wwn = 
		    (((u_int64_t)gs1->snscb_wwn[0]) << 56) |
		    (((u_int64_t)gs1->snscb_wwn[1]) << 48) |
		    (((u_int64_t)gs1->snscb_wwn[2]) << 40) |
		    (((u_int64_t)gs1->snscb_wwn[3]) << 32) |
		    (((u_int64_t)gs1->snscb_wwn[4]) << 24) |
		    (((u_int64_t)gs1->snscb_wwn[5]) << 16) |
		    (((u_int64_t)gs1->snscb_wwn[6]) <<  8) |
		    (((u_int64_t)gs1->snscb_wwn[7]));

		/*
		 * The QLogic f/w is bouncing this with a parameter error.
		 */
#if	0
		/*
		 * Try and get FC4 Features (FC-GS-3 only).
		 * We can use the sns_gxn_id_req_t for this request.
		 */
		MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t));
		gq->snscb_rblen = SNS_GFF_ID_RESP_SIZE >> 1;
		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF);
		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF);
		gq->snscb_sblen = 6;
		gq->snscb_cmd = SNS_GFF_ID;
		gq->snscb_portid = lcl.portid;
		isp_put_gxn_id_request(isp, gq,
		    (sns_gxn_id_req_t *) fcp->isp_scratch);
		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE);
		mbs.param[0] = MBOX_SEND_SNS;
		mbs.param[1] = SNS_GXN_ID_REQ_SIZE >> 1;
		mbs.param[2] = DMA_WD1(fcp->isp_scdma);
		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
		/*
		 * Leave 4 and 5 alone
		 */
		mbs.param[6] = DMA_WD3(fcp->isp_scdma);
		mbs.param[7] = DMA_WD2(fcp->isp_scdma);
		if (isp_fabric_mbox_cmd(isp, &mbs)) {
			if (fcp->isp_loopstate >= LOOP_SCANNING_FABRIC) {
				fcp->isp_loopstate = LOOP_PDB_RCVD;
			}
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
			FC_SCRATCH_RELEASE(isp);
			return (-1);
		}
		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GFF_ID_RESP_SIZE);
		fs0 = (sns_gff_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF);
		isp_get_gff_id_response(isp, fs0, fs1);
		if (fs1->snscb_cthdr.ct_response != FS_ACC) {
			isp_prt(isp, /* ISP_LOGDEBUG0 */ ISP_LOGWARN,
			    swrej, "GFF_ID",
			    fs1->snscb_cthdr.ct_reason,
			    fs1->snscb_cthdr.ct_explanation, lcl.portid);
			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) {
				FC_SCRATCH_RELEASE(isp);
				return (-1);
			}
		} else {
			int index = (ftype >> 3);
			int bshft = (ftype & 0x7) * 4;
			int fc4_fval =
			    (fs1->snscb_fc4_features[index] >> bshft) & 0xf;
			if (fc4_fval & 0x1) {
				lcl.roles |=
				    (SVC3_INI_ROLE >> SVC3_ROLE_SHIFT);
			}
			if (fc4_fval & 0x2) {
				lcl.roles |=
				    (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);
			}
		}
#endif

		/*
		 * If we really want to know what kind of port type this is,
		 * we have to run another CT command. Otherwise, we'll leave
		 * it as undefined.
		 *
		lcl.port_type = 0;
		 */
		if (rs1->snscb_ports[i].control & 0x80) {
			lcl.last_fabric_dev = 1;
		} else {
			lcl.last_fabric_dev = 0;
		}
		(void) isp_async(isp, ISPASYNC_FABRIC_DEV, &lcl);

	} while ((rs1->snscb_ports[i].control & 0x80) == 0 && i < NGENT-1);

	/*
	 * If we're not at the last entry, our list isn't big enough.
a2380 5
	if ((rs1->snscb_ports[i].control & 0x80) == 0) {
		isp_prt(isp, ISP_LOGWARN, "fabric too big for scratch area");
	}

	FC_SCRATCH_RELEASE(isp);
a2383 1
#endif
d2389 1
a2389 1
	u_int8_t local[SNS_RFT_ID_REQ_SIZE];
d2393 2
a2394 2
	MEMZERO((void *) reqp, SNS_RFT_ID_REQ_SIZE);
	reqp->snscb_rblen = SNS_RFT_ID_RESP_SIZE >> 1;
d2400 1
a2400 1
	reqp->snscb_data[0] = SNS_RFT_ID;
d2403 1
a2403 1
	reqp->snscb_data[6] = (1 << FC4_SCSI);
d2405 1
a2405 1
	reqp->snscb_data[6] |= (1 << FC4_IP);	/* ISO/IEC 8802-2 LLC/SNAP */
a2406 1
	FC_SCRATCH_ACQUIRE(isp);
d2409 1
a2409 1
	mbs.param[1] = SNS_RFT_ID_REQ_SIZE >> 1;
a2417 1
	FC_SCRATCH_RELEASE(isp);
d2606 1
a2606 1
			if (isp_scan_fabric(isp, FC4_SCSI)) {
d2610 1
a2610 1
			    fcp->isp_loopstate < LOOP_FSCAN_DONE) {
d2665 1
a2665 1
	if (isp_getrqentry(isp, &nxti, &optr, (void *)&qep)) {
d2694 1
a2694 1
			if (isp_getrqentry(isp, &nxti, &optr, (void *) &qep)) {
d2786 1
a2786 1
	    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs), XS_CDBP(xs)[0],
d2905 1
a2905 2
			int ftype = (arg)? *((int *) arg) : FC4_SCSI;
			return (isp_scan_fabric(isp, ftype));
d2982 1
a2982 3
#ifndef	MAX_REQUESTQ_COMPLETIONS
#define	MAX_REQUESTQ_COMPLETIONS	64
#endif
a2990 1
again:
a2996 1
			isp->isp_intmboxc++;
a3006 5
				if (isp->isp_mbxwrk0) {
					if (isp_mbox_continue(isp) == 0) {
						return;
					}
				}
d3013 6
a3018 2
		} else if (isp_parse_async(isp, mbox) < 0) {
			return;
d3020 1
a3020 2
		if ((IS_FC(isp) && mbox != ASYNC_RIO_RESP) ||
		    isp->isp_state != ISP_RUNSTATE) {
d3049 1
a3049 1
	if (IS_23XX(isp)) {
a3050 3
		/*
		 * Debug: to be taken out eventually
		 */
a3061 2
	 *
	 * Debounce the 2300 if revision less than 2.
d3063 1
a3063 1
	if (IS_2100(isp) || (IS_2300(isp) && isp->isp_revision < 2)) {
a3079 1
	isp->isp_resodx = iptr;
d3091 1
a3091 1
		if (IS_23XX(isp)) {
d3099 1
a3099 11
			if (IS_23XX(isp)) {
				;
			} else {
				sema = ISP_READ(isp, BIU_SEMA);
				mbox = ISP_READ(isp, OUTMAILBOX0);
				if ((sema & 0x3) && (mbox & 0x8000)) {
					goto again;
				}
			}
			isp->isp_intbogus++;
			isp_prt(isp, ISP_LOGDEBUG1,
d3102 1
a3104 1
	isp->isp_resodx = iptr;
a3107 5
	if (isp->isp_rspbsy) {
		return;
	}
	isp->isp_rspbsy = 1;

a3127 10
		} else if (type == RQSTYPE_RIO2) {
			isp_rio2_t rio;
			isp_get_rio2(isp, (isp_rio2_t *) hp, &rio);
			for (i = 0; i < rio.req_header.rqs_seqno; i++) {
				isp_fastpost_complete(isp, rio.req_handles[i]);
			}
			if (isp->isp_fpcchiwater < rio.req_header.rqs_seqno)
				isp->isp_fpcchiwater = rio.req_header.rqs_seqno;
			MEMZERO(hp, QENTRY_LEN);	/* PERF */
			continue;
d3129 1
a3129 7
			/*
			 * Somebody reachable via isp_handle_other_response
			 * may have updated the response queue pointers for
			 * us, so we reload our goal index.
			 */
			if (isp_handle_other_response(isp, type, hp, &optr)) {
				iptr = isp->isp_resodx;
a3202 1
			u_int8_t ts = sp->req_completion_status & 0xff;
d3204 3
a3206 14
			/*
			 * Only whine if this isn't the expected fallout of
			 * aborting the command.
			 */
			if (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {
				isp_prt(isp, ISP_LOGERR,
				    "cannot find handle 0x%x (type 0x%x)",
				    sp->req_handle,
				    sp->req_header.rqs_entry_type);
			} else if (ts != RQCS_ABORTED) {
				isp_prt(isp, ISP_LOGERR,
				    "cannot find handle 0x%x (status 0x%x)",
				    sp->req_handle, ts);
			}
d3350 1
a3350 1
		 * While we're at it, read the requst queue out pointer.
a3352 2
		if (isp->isp_rscchiwater < ndone)
			isp->isp_rscchiwater = ndone;
a3355 1
	isp->isp_rspbsy = 0;
a3358 1
			isp->isp_rsltccmplt++;
d3369 1
a3369 1
isp_parse_async(struct ispsoftc *isp, u_int16_t mbox)
a3370 1
	int rval = 0;
d3372 1
a3378 1
	isp_prt(isp, ISP_LOGDEBUG2, "Async Mbox 0x%x", mbox);
d3384 1
a3384 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
a3388 8
#ifdef	ISP_FW_CRASH_DUMP
		/*
		 * If we have crash dumps enabled, it's up to the handler
		 * for isp_async to reinit stuff and restart the firmware
		 * after performing the crash dump. The reason we do things
		 * this way is that we may need to activate a kernel thread
		 * to do all the crash dump goop.
		 */
d3390 2
a3391 7
#else
		isp_async(isp, ISPASYNC_FW_CRASH, NULL);
		isp_reinit(isp);
		isp_async(isp, ISPASYNC_FW_RESTARTED, NULL);
#endif
		rval = -1;
		break;
d3415 1
a3415 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3423 1
a3423 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
a3479 21
	/*
	 * We can use bus, which will always be zero for FC cards,
	 * as a mailbox pattern accumulator to be checked below.
	 */
	case ASYNC_RIO5:
		bus = 0x1ce;	/* outgoing mailbox regs 1-3, 6-7 */
		break;

	case ASYNC_RIO4:
		bus = 0x14e;	/* outgoing mailbox regs 1-3, 6 */
		break;

	case ASYNC_RIO3:
		bus = 0x10e;	/* outgoing mailbox regs 1-3 */
		break;

	case ASYNC_RIO2:
		bus = 0x106;	/* outgoing mailbox regs 1-2 */
		break;

	case ASYNC_RIO1:
d3481 3
a3483 1
		bus = 0x102;	/* outgoing mailbox regs 1 */
a3485 3
	case ASYNC_RIO_RESP:
		return (rval);

a3486 1
	{
d3488 7
a3494 5
		int handle =
		    (ISP_READ(isp, OUTMAILBOX2) << 16) | 
		    (ISP_READ(isp, OUTMAILBOX1));
		if (isp_target_async(isp, handle, mbox))
			rval = -1;
a3497 1
		isp->isp_fphccmplt++;	/* count it as a fast posting intr */
d3499 1
a3499 1
	}
d3510 1
a3510 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3544 1
a3544 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3555 1
a3555 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3566 1
a3566 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
d3597 1
a3597 2
		if (isp_target_async(isp, bus, mbox))
			rval = -1;
a3619 4
#ifdef	ISP_FW_CRASH_DUMP
			isp_async(isp, ISPASYNC_FW_CRASH, NULL);
#else
			isp_async(isp, ISPASYNC_FW_CRASH, NULL);
d3621 2
a3622 1
			isp_async(isp, ISPASYNC_FW_RESTARTED, NULL);
d3624 1
d3645 1
a3645 22

	if (bus & 0x100) {
		int i, nh;
		u_int16_t handles[5];

		for (nh = 0, i = 1; i < MAX_MAILBOX; i++) {
			if ((bus & (1 << i)) == 0) {
				continue;
			}
			handles[nh++] = ISP_READ(isp, MBOX_OFF(i));
		}
		for (i = 0; i < nh; i++) {
			isp_fastpost_complete(isp, handles[i]);
			isp_prt(isp,  ISP_LOGDEBUG3,
			    "fast post completion of %u", handles[i]);
		}
		if (isp->isp_fpcchiwater < nh)
			isp->isp_fpcchiwater = nh;
	} else {
		isp->isp_intoasync++;
	}
	return (rval);
d3661 1
a3661 1
		return (1);
a3671 1
		isp->isp_rsltccmplt++;	/* count as a response completion */
d3673 4
a3676 3
		if (isp_target_notify(isp, (ispstatusreq_t *) hp, optrp)) {
			return (1);
		}
a3677 1
		/* FALLTHROUGH */
d3681 1
a3681 1
			return (1);
d3685 1
a3685 1
		return (0);
d3723 2
a3724 1
		SNPRINTF(buf, sizeof (buf), "states=>");
d3726 1
a3726 1
			SNPRINTF(buf, sizeof (buf), "%s GOT_BUS", buf);
d3729 1
a3729 1
			SNPRINTF(buf, sizeof (buf), "%s GOT_TGT", buf);
d3732 1
a3732 1
			SNPRINTF(buf, sizeof (buf), "%s SENT_CDB", buf);
d3735 1
a3735 1
			SNPRINTF(buf, sizeof (buf), "%s XFRD_DATA", buf);
d3738 1
a3738 1
			SNPRINTF(buf, sizeof (buf), "%s GOT_STS", buf);
d3741 1
a3741 1
			SNPRINTF(buf, sizeof (buf), "%s GOT_SNS", buf);
d3744 1
a3744 1
			SNPRINTF(buf, sizeof (buf), "%s XFR_CMPLT", buf);
d3746 1
a3746 1
		SNPRINTF(buf, sizeof (buf), "%s\nstatus=>", buf);
d3748 1
a3748 1
			SNPRINTF(buf, sizeof (buf), "%s Disconnect", buf);
d3751 1
a3751 1
			SNPRINTF(buf, sizeof (buf), "%s Sync_xfr", buf);
d3754 1
a3754 1
			SNPRINTF(buf, sizeof (buf), "%s Parity", buf);
d3757 1
a3757 1
			SNPRINTF(buf, sizeof (buf), "%s Bus_Reset", buf);
d3760 1
a3760 1
			SNPRINTF(buf, sizeof (buf), "%s Device_Reset", buf);
d3763 1
a3763 1
			SNPRINTF(buf, sizeof (buf), "%s Aborted", buf);
d3766 1
a3766 1
			SNPRINTF(buf, sizeof (buf), "%s Timeout", buf);
d3769 1
a3769 1
			SNPRINTF(buf, sizeof (buf), "%s Negotiation", buf);
a3797 10
		/*
	 	 * Check to see if we logged out the device.
		 */
		if (IS_FC(isp)) {
			if ((sp->req_completion_status & RQSTF_LOGOUT) &&
			    FCPARAM(isp)->portdb[XS_TGT(xs)].valid &&
			    FCPARAM(isp)->portdb[XS_TGT(xs)].fabric_dev) {
				FCPARAM(isp)->portdb[XS_TGT(xs)].relogin = 1;
			}
		}
a3884 13
	{
		if (IS_FC(isp)) {
			int ru_marked = (sp->req_scsi_status & RQCS_RU) != 0;
			if (!ru_marked || sp->req_resid > XS_XFRLEN(xs)) {
				isp_prt(isp, ISP_LOGWARN, bun, XS_TGT(xs),
				    XS_LUN(xs), XS_XFRLEN(xs), sp->req_resid,
				    (ru_marked)? "marked" : "not marked");
				if (XS_NOERR(xs)) {
					XS_SETERR(xs, HBA_BOTCH);
				}
				return;
			}
		}
a3889 1
	}
d3912 2
a3913 2
		    "internal queues full for %d.%d.%d status 0x%x",
		    XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs), *XS_STSP(xs));
d3989 6
d3999 2
a4000 25
		if ((sp->req_completion_status & 0xff) == RQCS_PORT_UNAVAILABLE)
			isp_prt(isp, ISP_LOGINFO,
			    "port unavailable for target %d", XS_TGT(xs));
		else
			isp_prt(isp, ISP_LOGINFO,
			    "port logout for target %d", XS_TGT(xs));
		/*
		 * If we're on a local loop, force a LIP (which is overkill)
		 * to force a re-login of this unit. If we're on fabric,
		 * then we'll have to relogin as a matter of course.
		 */
		if (FCPARAM(isp)->isp_topo == TOPO_NL_PORT ||
		    FCPARAM(isp)->isp_topo == TOPO_FL_PORT) {
			mbreg_t mbs;
			mbs.param[0] = MBOX_INIT_LIP;
			isp_mboxcmd_qnw(isp, &mbs, 1);
		}

		/*
		 * Probably overkill.
		 */
		isp->isp_sendmarker = 1;
		FCPARAM(isp)->isp_loopstate = LOOP_PDB_RCVD;
		isp_mark_getpdb_all(isp);
		isp_async(isp, ISPASYNC_CHANGE_NOTIFY, ISPASYNC_CHANGE_OTHER);
a4060 1
	isp->isp_fphccmplt++;
a4063 49
static int
isp_mbox_continue(struct ispsoftc *isp)
{
	mbreg_t mbs;
	u_int16_t *ptr;

	switch (isp->isp_lastmbxcmd) {
	case MBOX_WRITE_RAM_WORD:
	case MBOX_READ_RAM_WORD:
	case MBOX_READ_RAM_WORD_EXTENDED:
		break;
	default:
		return (1);
	}
	if (isp->isp_mboxtmp[0] != MBOX_COMMAND_COMPLETE) {
		isp->isp_mbxwrk0 = 0;
		return (-1);
	}


	/*
	 * Clear the previous interrupt.
	 */
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
	ISP_WRITE(isp, BIU_SEMA, 0);

	/*
	 * Continue with next word.
	 */
	ptr = isp->isp_mbxworkp;
	switch (isp->isp_lastmbxcmd) {
	case MBOX_WRITE_RAM_WORD:
		mbs.param[2] = *ptr++;
		mbs.param[1] = isp->isp_mbxwrk1++;
		break;
	case MBOX_READ_RAM_WORD:
	case MBOX_READ_RAM_WORD_EXTENDED:
		*ptr++ = isp->isp_mboxtmp[2];
		mbs.param[1] = isp->isp_mbxwrk1++;
		break;
	}
	isp->isp_mbxworkp = ptr;
	mbs.param[0] = isp->isp_lastmbxcmd;
	isp->isp_mbxwrk0 -= 1;
	isp_mboxcmd_qnw(isp, &mbs, 0);
	return (0);
}


d4150 2
a4151 2
	ISPOPMAP(0xdf, 0xff),	/* 0x52: INITIALIZE REQUEST QUEUE A64 */
	ISPOPMAP(0xef, 0xff),	/* 0x53: INITIALIZE RESPONSE QUEUE A64 */
d4279 1
a4279 1
	ISPOPMAP(0x03, 0x07),	/* 0x0f: MBOX_READ_RAM_WORD_EXTENDED(1) */
d4355 2
a4356 2
	ISPOPMAP(0x03, 0x01),	/* 0x5b: MBOX_DRIVER_HEARTBEAT */
	ISPOPMAP(0xcf, 0x01),	/* 0x5c: MBOX_FW_HEARTBEAT */
a4391 7
/*
 * Footnotes
 *
 * (1): this sets bits 21..16 in mailbox register #8, which we nominally 
 *	do not access at this time in the core driver. The caller is
 *	responsible for setting this register first (Gross!).
 */
d4408 1
a4408 1
	"READ RAM WORD EXTENDED",
d4486 1
a4486 1
	"DRIVER HEARTBEAT",
a4525 40
isp_mboxcmd_qnw(struct ispsoftc *isp, mbreg_t *mbp, int nodelay)
{
	unsigned int lim, ibits, obits, box, opcode;
	u_int16_t *mcp;

	if (IS_FC(isp)) {
		mcp = mbpfc;
		lim = (sizeof (mbpfc) / sizeof (mbpfc[0]));
	} else {
		mcp = mbpscsi;
		lim = (sizeof (mbpscsi) / sizeof (mbpscsi[0]));
	}
	opcode = mbp->param[0];
	ibits = HIBYT(mcp[opcode]) & NMBOX_BMASK(isp);
	obits = LOBYT(mcp[opcode]) & NMBOX_BMASK(isp);
	for (box = 0; box < MAX_MAILBOX; box++) {
		if (ibits & (1 << box)) {
			ISP_WRITE(isp, MBOX_OFF(box), mbp->param[box]);
		}
		if (nodelay == 0) {
			isp->isp_mboxtmp[box] = mbp->param[box] = 0;
		}
	}
	if (nodelay == 0) {
		isp->isp_lastmbxcmd = opcode;
		isp->isp_obits = obits;
		isp->isp_mboxbsy = 1;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);
	/*
	 * Oddly enough, if we're not delaying for an answer,
	 * delay a bit to give the f/w a chance to pick up the
	 * command.
	 */
	if (nodelay) {
		USEC_DELAY(1000);
	}
}

static void
a4814 7
#ifndef	DEFAULT_FRAMESIZE
#define	DEFAULT_FRAMESIZE(isp)		ICB_DFLT_FRMLEN
#endif
#ifndef	DEFAULT_EXEC_THROTTLE
#define	DEFAULT_EXEC_THROTTLE(isp)	ISP_EXEC_THROTTLE
#endif

d4831 1
a4831 1
		fcp->isp_maxfrmlen = DEFAULT_FRAMESIZE(isp);
d4833 1
a4833 1
		fcp->isp_execthrottle = DEFAULT_EXEC_THROTTLE(isp);
d4873 3
a4875 5
		if (nvfail) {
			isp->isp_confopts |= ISP_CFG_OWNWWPN|ISP_CFG_OWNWWNN;
		}
		if (isp->isp_confopts & ISP_CFG_OWNWWNN) {
			isp_prt(isp, ISP_LOGCONFIG, "Using Node WWN 0x%08x%08x",
d4877 1
a4877 11
			    (u_int32_t) (DEFAULT_NODEWWN(isp) & 0xffffffff));
			ISP_NODEWWN(isp) = DEFAULT_NODEWWN(isp);
		} else {
			/*
			 * We always start out with values derived
			 * from NVRAM or our platform default.
			 */
			ISP_NODEWWN(isp) = fcp->isp_nodewwn;
		}
		if (isp->isp_confopts & ISP_CFG_OWNWWPN) {
			isp_prt(isp, ISP_LOGCONFIG, "Using Port WWN 0x%08x%08x",
d4880 2
d4888 1
d5041 11
a5051 9
	} else if (isp->isp_role != ISP_ROLE_NONE) {
		isp_init(isp);
		if (isp->isp_state == ISP_INITSTATE) {
			isp->isp_state = ISP_RUNSTATE;
		}
		if (isp->isp_state != ISP_RUNSTATE) {
			isp_prt(isp, ISP_LOGERR,
			    "isp_reinit cannot restart card");
		}
d5053 1
d5133 1
a5133 2
		if (IS_12160(isp))
			isp_parse_nvram_12160(isp, 1, nvram_data);
a5161 3
		if (IS_2312(isp) && isp->isp_port) {
			wo += 128;
		}
d5222 2
a5223 3
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		sdp->isp_initiator_id =
			ISP_NVRAM_INITIATOR_ID(nvram_data);
d5348 2
a5349 3
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		sdp->isp_initiator_id =
		    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);
d5439 2
a5440 3
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		sdp->isp_initiator_id =
		    ISP12160_NVRAM_INITIATOR_ID(nvram_data, bus);
d5544 6
a5549 9
	if (IS_2200(isp) || IS_23XX(isp)) {
		wwn = ISP2200_NVRAM_NODE_NAME(nvram_data);
		if (wwn) {
			isp_prt(isp, ISP_LOGCONFIG, "NVRAM Node WWN 0x%08x%08x",
			    (u_int32_t) (wwn >> 32),
			    (u_int32_t) (wwn & 0xffffffff));
			if ((wwn >> 60) == 0) {
				wwn |= (((u_int64_t) 2)<< 60);
			}
a5550 2
	} else {
		wwn &= ~((u_int64_t) 0xfff << 48);
a5579 7
	isp_prt(isp, ISP_LOGDEBUG0,
	    "NVRAM: maxfrmlen %d execthrottle %d fwoptions 0x%x loopid %x",
	    ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data),
	    ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data),
	    ISP2100_NVRAM_OPTIONS(nvram_data),
	    ISP2100_NVRAM_HARDLOOPID(nvram_data));

d5582 2
a5583 3
	if ((isp->isp_confopts & ISP_CFG_OWNFSZ) == 0)
		fcp->isp_maxfrmlen =
			ISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);
d5588 4
a5591 6
	if ((isp->isp_confopts & ISP_CFG_OWNLOOPID) == 0)
		fcp->isp_loopid =
			ISP2100_NVRAM_HARDLOOPID(nvram_data);
	if ((isp->isp_confopts & ISP_CFG_OWNEXCTHROTTLE) == 0)
		fcp->isp_execthrottle =
			ISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);
d5593 3
a5596 321

#ifdef	ISP_FW_CRASH_DUMP
static void isp2200_fw_dump(struct ispsoftc *);
static void isp2300_fw_dump(struct ispsoftc *);

static void
isp2200_fw_dump(struct ispsoftc *isp)
{
	int i, j;
	mbreg_t mbs;
	u_int16_t *ptr;

	ptr = FCPARAM(isp)->isp_dump_data;
	if (ptr == NULL) {
		isp_prt(isp, ISP_LOGERR,
		   "No place to dump RISC registers and SRAM");
		return;
	}
	if (*ptr++) {
		isp_prt(isp, ISP_LOGERR,
		   "dump area for RISC registers and SRAM already used");
		return;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
			break;
		}
	}
	if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
		/*
		 * PBIU Registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + (i << 1));
		}

		/*
		 * Mailbox Registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, MBOX_BLOCK + (i << 1));
		}

		/*
		 * DMA Registers
		 */
		for (i = 0; i < 48; i++) {
			*ptr++ = ISP_READ(isp, DMA_BLOCK + 0x20 + (i << 1));
		}

		/*
		 * RISC H/W Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0);
		for (i = 0; i < 16; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0xA0 + (i << 1));
		}

		/*
		 * RISC GP Registers
		 */
		for (j = 0; j < 8; j++) {
			ISP_WRITE(isp, BIU_BLOCK + 0xA4, 0x2000 + (j << 8));
			for (i = 0; i < 16; i++) {
				*ptr++ =
				    ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
			}
		}

		/*
		 * Frame Buffer Hardware Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x10);
		for (i = 0; i < 16; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * Fibre Protocol Module 0 Hardware Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x20);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * Fibre Protocol Module 1 Hardware Registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x30);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}
	} else {
		isp_prt(isp, ISP_LOGERR, "RISC Would Not Pause");
		return;
	}
	isp_prt(isp, ISP_LOGALL,
	   "isp_fw_dump: RISC registers dumped successfully");
	ISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, OUTMAILBOX0) == 0) {
			break;
		}
	}
	if (ISP_READ(isp, OUTMAILBOX0) != 0) {
		isp_prt(isp, ISP_LOGERR, "Board Would Not Reset");
		return;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
			break;
		}
	}
	if ((ISP_READ(isp, HCCR) & HCCR_PAUSE) == 0) {
		isp_prt(isp, ISP_LOGERR, "RISC Would Not Pause After Reset");
		return;
	}
	ISP_WRITE(isp, RISC_EMB, 0xf2);
	ISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if ((ISP_READ(isp, HCCR) & HCCR_PAUSE) == 0) {
			break;
		}
	}
	ENABLE_INTS(isp);
	mbs.param[0] = MBOX_READ_RAM_WORD;
	mbs.param[1] = 0x1000;
	isp->isp_mbxworkp = (void *) ptr;
	isp->isp_mbxwrk0 = 0xefff;	/* continuation count */
	isp->isp_mbxwrk1 = 0x1001;	/* next SRAM address */
	isp_control(isp, ISPCTL_RUN_MBOXCMD, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGWARN,
		    "RAM DUMP FAILED @@ WORD %x", isp->isp_mbxwrk1);
		return;
	}
	ptr = isp->isp_mbxworkp;	/* finish fetch of final word */
	*ptr++ = isp->isp_mboxtmp[2];
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped successfully");
	FCPARAM(isp)->isp_dump_data[0] = isp->isp_type; /* now used */
	(void) isp_async(isp, ISPASYNC_FW_DUMPED, 0);
}

static void
isp2300_fw_dump(struct ispsoftc *isp)
{
	int i, j;
	mbreg_t mbs;
	u_int16_t *ptr;

	ptr = FCPARAM(isp)->isp_dump_data;
	if (ptr == NULL) {
		isp_prt(isp, ISP_LOGERR,
		   "No place to dump RISC registers and SRAM");
		return;
	}
	if (*ptr++) {
		isp_prt(isp, ISP_LOGERR,
		   "dump area for RISC registers and SRAM already used");
		return;
	}
	ISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
			break;
		}
	}
	if (ISP_READ(isp, HCCR) & HCCR_PAUSE) {
		/*
		 * PBIU registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + (i << 1));
		}

		/*
		 * ReqQ-RspQ-Risc2Host Status registers
		 */
		for (i = 0; i < 8; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x10 + (i << 1));
		}

		/*
		 * Mailbox Registers
		 */
		for (i = 0; i < 32; i++) {
			*ptr++ =
			    ISP_READ(isp, PCI_MBOX_REGS2300_OFF + (i << 1));
		}

		/*
		 * Auto Request Response DMA registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x40);
		for (i = 0; i < 32; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * DMA registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x50);
		for (i = 0; i < 48; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * RISC hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0);
		for (i = 0; i < 16; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0xA0 + (i << 1));
		}

		/*
		 * RISC GP? registers
		 */
		for (j = 0; j < 8; j++) {
			ISP_WRITE(isp, BIU_BLOCK + 0xA4, 0x2000 + (j << 9));
			for (i = 0; i < 16; i++) {
				*ptr++ =
				    ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
			}
		}

		/*
		 * frame buffer hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x10);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * FPM B0 hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x20);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}

		/*
		 * FPM B1 hardware registers
		 */
		ISP_WRITE(isp, BIU2100_CSR, 0x30);
		for (i = 0; i < 64; i++) {
			*ptr++ = ISP_READ(isp, BIU_BLOCK + 0x80 + (i << 1));
		}
	} else {
		isp_prt(isp, ISP_LOGERR, "RISC Would Not Pause");
		return;
	}
	isp_prt(isp, ISP_LOGALL,
	   "isp_fw_dump: RISC registers dumped successfully");
	ISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);
	for (i = 0; i < 100; i++) {
		USEC_DELAY(100);
		if (ISP_READ(isp, OUTMAILBOX0) == 0) {
			break;
		}
	}
	if (ISP_READ(isp, OUTMAILBOX0) != 0) {
		isp_prt(isp, ISP_LOGERR, "Board Would Not Reset");
		return;
	}
	ENABLE_INTS(isp);
	mbs.param[0] = MBOX_READ_RAM_WORD;
	mbs.param[1] = 0x800;
	isp->isp_mbxworkp = (void *) ptr;
	isp->isp_mbxwrk0 = 0xf7ff;	/* continuation count */
	isp->isp_mbxwrk1 = 0x801;	/* next SRAM address */
	isp_control(isp, ISPCTL_RUN_MBOXCMD, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGWARN,
		    "RAM DUMP FAILED @@ WORD %x", isp->isp_mbxwrk1);
		return;
	}
	ptr = isp->isp_mbxworkp;	/* finish fetch of final word */
	*ptr++ = isp->isp_mboxtmp[2];

	/*
	 * We don't have access to mailbox registers 8.. onward
	 * in our 'common' device model- so we have to set it
	 * here and hope it stays the same!
	 */
	ISP_WRITE(isp, PCI_MBOX_REGS2300_OFF + (8 << 1), 0x1);

	mbs.param[0] = MBOX_READ_RAM_WORD_EXTENDED;
	mbs.param[1] = 0;
	isp->isp_mbxworkp = (void *) ptr;
	isp->isp_mbxwrk0 = 0xffff;	/* continuation count */
	isp->isp_mbxwrk1 = 0x1;		/* next SRAM address */
	isp_control(isp, ISPCTL_RUN_MBOXCMD, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_prt(isp, ISP_LOGWARN,
		    "RAM DUMP FAILED @@ WORD %x", 0x10000 + isp->isp_mbxwrk1);
		return;
	}
	ptr = isp->isp_mbxworkp;	/* finish final word */
	*ptr++ = mbs.param[2];
	isp_prt(isp, ISP_LOGALL, "isp_fw_dump: SRAM dumped successfully");
	FCPARAM(isp)->isp_dump_data[0] = isp->isp_type; /* now used */
	(void) isp_async(isp, ISPASYNC_FW_DUMPED, 0);
}

void
isp_fw_dump(struct ispsoftc *isp)
{
	if (IS_2200(isp))
		isp2200_fw_dump(isp);
	else if (IS_23XX(isp))
		isp2300_fw_dump(isp);
}
#endif
@


1.12.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.12.2.6 2003/03/28 00:38:13 niklas Exp $ */
d4780 1
a4780 1
static const u_int16_t mbpscsi[] = {
d4976 1
a4976 1
static const u_int16_t mbpfc[] = {
d5249 1
a5249 1
	const u_int16_t *mcp;
d5290 1
a5290 1
	const u_int16_t *mcp;
@


1.12.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* 	$OpenBSD$ */
d2015 1
a2015 1
		 * Make sure we can get the appropriate port information.
d3380 1
a3380 1
		 * XXX: It hasn't been picked up by firmware yet.
d3901 1
a3901 1
		 * While we're at it, read the request queue out pointer.
d4108 1
a4108 1
		 * We've had problems with data corruption occurring on
@


1.11
log
@Clean up some DUALBUS initialization code. Clean up some checking
against f/w revision because we'll now use initiator only mode f/w
(if loading f/w) because we get more commands active in this case (and
avoid some apparent sloppiness wrt Qlogic's f/w release practices).
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.10 1999/12/16 05:26:52 mjacob Exp $ */
d2253 1
a2253 1
			IDPRINTF(3, ("%s: Command Mbox 0x%x\n",
d2257 1
a2257 1
			IDPRINTF(3, ("%s: Async Mbox 0x%x\n",
d2320 1
a2320 1
				IDPRINTF(3, ("%s: continuation segment\n",
d2612 1
a2612 1
		IDPRINTF(3, ("%s: fast post completion of %u\n", isp->isp_name,
@


1.10
log
@Add in cleaner dual bus and dual LVD bus support.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.9 1999/11/23 21:16:04 mjacob Exp $ */
d792 7
a798 1
	 *  Turn on Fast Posting, LVD transitions
d801 4
a804 3
	if (IS_ULTRA2(isp) ||
	    ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(7, 55, 0)) {
		mbs.param[0] = MBOX_SET_FW_FEATURES;
d806 3
d810 1
a810 2
#else
		mbs.param[1] = 0;
d812 9
a820 8
		if (IS_ULTRA2(isp))
			mbs.param[1] |= FW_FEATURE_LVD_NOTIFY;
		if (mbs.param[1] != 0) {
			isp_mboxcmd(isp, &mbs);
			if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
				PRINTF("%s: unable enable FW features\n",
				    isp->isp_name);
			}
d874 1
d876 1
d879 2
a880 1
			 * we could force narrow and async, so assume >= 7.55.
d882 3
a884 2
			if (ISP_FW_REVX(isp->isp_fwrev) >=
			    ISP_FW_REV(7, 55, 0)) {
d934 1
d949 3
a951 1
		if (ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(7, 55, 0))
d3739 1
a3739 1
	sdparam *sdp, *sdp_chan0, *sdp_chan1;
d3769 2
a3770 3
	sdp_chan0 = (sdparam *) isp->isp_param;
	sdp_chan1 = sdp_chan0 + 1;
	sdp = sdp_chan0 + channel;
d3795 12
a3806 9
	mbs.param[0] = MBOX_GET_ACT_NEG_STATE;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		IDPRINTF(2, ("could not GET ACT NEG STATE\n"));
		sdp_chan0->isp_req_ack_active_neg = 1;
		sdp_chan0->isp_data_line_active_neg = 1;
		if (IS_DUALBUS(isp)) {
			sdp_chan1->isp_req_ack_active_neg = 1;
			sdp_chan1->isp_data_line_active_neg = 1;
d3809 2
a3810 8
		sdp_chan0->isp_req_ack_active_neg = (mbs.param[1] >> 4) & 0x1;
		sdp_chan0->isp_data_line_active_neg = (mbs.param[1] >> 5) & 0x1;
		if (IS_DUALBUS(isp)) {
			sdp_chan1->isp_req_ack_active_neg =
			    (mbs.param[2] >> 4) & 0x1;
			sdp_chan1->isp_data_line_active_neg =
			    (mbs.param[2] >> 5) & 0x1;
		}
d3813 5
d3851 1
a3851 3
		if (isp->isp_confopts & ISP_CFG_NONVRAM) {
			continue;
		}
d3853 10
a3862 10
		mbs.param[0] = MBOX_GET_TARGET_PARAMS;
		mbs.param[1] = tgt << 8;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			continue;
		}
		sdp->isp_devparam[tgt].cur_dflags = mbs.param[2];
		sdp->isp_devparam[tgt].dev_flags = mbs.param[2];
		sdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;
		sdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;
d3864 13
a3876 13
		/*
		 * The maximum period we can really see
		 * here is 100 (decimal), or 400 ns.
		 * For some unknown reason we sometimes
		 * get back wildass numbers from the
		 * boot device's parameters (alpha only).
		 */
		if ((mbs.param[3] & 0xff) <= 0x64) {
			sdp->isp_devparam[tgt].sync_period =
			    mbs.param[3] & 0xff;
			sdp->isp_devparam[tgt].sync_offset =
			    mbs.param[3] >> 8;
		}
d3878 12
a3889 11
		/*
		 * It is not safe to run Ultra Mode with a clock < 60.
		 */
		if (((isp->isp_clock && isp->isp_clock < 60) ||
		    (isp->isp_type < ISP_HA_SCSI_1020A)) &&
		    (sdp->isp_devparam[tgt].sync_period <=
		    (ISP_20M_SYNCPARMS & 0xff))) {
			sdp->isp_devparam[tgt].sync_offset =
			    ISP_10M_SYNCPARMS >> 8;
			sdp->isp_devparam[tgt].sync_period =
			    ISP_10M_SYNCPARMS & 0xff;
d3891 5
@


1.9
log
@make a couple more items CFGPRINTF items
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.8 1999/11/22 12:50:52 mjacob Exp $ */
d158 1
a158 1
	 * Put the board into PAUSE mode.
d174 3
a176 2
	} else if (IS_12X0(isp)) {
		revname = "12X0";
d178 8
a185 1
	} else if (IS_1080(isp)) {
d188 3
a191 1
		isp->isp_clock = 100;
d196 1
a196 1
			PRINTF("%s: LVD Mode\n", isp->isp_name);
d200 1
a200 1
			CFGPRINTF("%s: Differential Mode\n", isp->isp_name);
d204 1
a204 1
			CFGPRINTF("%s: Single-Ended Mode\n", isp->isp_name);
d207 2
a208 6
			/*
			 * Hmm. Up in a wierd mode. This means all SCSI I/O
			 * buffer lines are tristated, so we're in a lot of
			 * trouble if we don't set things up right.
			 */
			PRINTF("%s: Illegal Mode 0x%x\n", isp->isp_name, l);
d211 25
d275 1
a275 1
			revname = "1040C(?)";
d643 1
a643 1
	if (IS_12X0(isp)) {
d663 1
a663 1
	if (IS_12X0(isp)) {
d758 1
a758 1
	if (IS_12X0(isp))
d795 1
a795 1
	if (IS_1080(isp) ||
d803 1
a803 1
		if (IS_1080(isp))
d861 1
a861 1
		if (IS_1080(isp) && sdp->isp_lvdmode) {
d1954 1
a1954 1
		u_int8_t n = (IS_12X0(isp)? 2: 1);
d2480 1
a2480 6
	/*
 	 * It is not documented anywhere that bus is always in OUTMAILBOX6
	 * for dual bus cards- and we don't have the h/w to prove it either,
	 * So we'll just assume......
	 */
	if (IS_1080(isp) || IS_12X0(isp)) {
d2734 3
a2736 2
		IDPRINTF(2, ("%s: bus reset destroyed command for target %d "
		    "lun %d\n", isp->isp_name, XS_TGT(xs), XS_LUN(xs)));
d3244 1
a3244 1
	if (IS_12X0(isp)) {
d3369 1
a3369 1
	if (IS_12X0(isp)) {
d3544 1
a3544 1
			ISP_READ(isp, SXP_PINS_CONTROL));
d3785 1
a3785 1
		if (IS_12X0(isp)) {
d3792 1
a3792 1
		if (IS_12X0(isp)) {
d3817 1
a3817 1
		} else if (IS_1080(isp)) {
d3971 1
a3971 1
	} else if (IS_1080(isp) || IS_12X0(isp)) {
d4011 1
a4011 1
	if (IS_1080(isp) || IS_12X0(isp)) {
d4014 1
a4014 1
		for (bus = 0; bus < (IS_1080(isp)? 1 : 2); bus++, sdp++) {
d4374 1
a4374 1
	} else if (IS_1080(isp) || IS_12X0(isp)) {
@


1.8
log
@Far too many things to note- a complete new revision coming in including
FABRIC support...
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.7 1999/03/26 00:34:59 mjacob Exp $ */
d190 1
a190 1
			PRINTF("%s: Differential Mode\n", isp->isp_name);
d194 1
a194 1
			PRINTF("%s: Single-Ended Mode\n", isp->isp_name);
d254 1
a254 1
			PRINTF("%s: Differential Mode\n", isp->isp_name);
d266 1
a266 1
			PRINTF("%s: Ultra Mode Capable\n", isp->isp_name);
d2085 1
a2085 1
		PRINTF("%s: driver initiated bus reset of bus %d\n",
@


1.7
log
@Annoying little nigglet- apparently *some* Qlogic temporarily ignore
settings you've just sent them and return random values if you follow
the set by a get. This causes problems when you latter run a Tag-enabled
command when you've command tagged mode off.
@
text
@d1 1
a1 2
/* 	$OpenBSD: isp.c,v 1.6 1999/03/25 22:58:38 mjacob Exp $ */
/* release_03_25_99 */
d6 1
a6 1
 * Copyright (c) 1997, 1998 by Matthew Jacob
a66 25
#ifdef	ISP_TARGET_MODE
static const char tgtiqd[36] = {
	0x03, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x51, 0x4C, 0x4F, 0x47, 0x49, 0x43, 0x20, 0x20,
#ifdef	__NetBSD__
	0x4E, 0x45, 0x54, 0x42, 0x53, 0x44, 0x20, 0x20,
#else
# ifdef	__FreeBSD__
	0x46, 0x52, 0x45, 0x45, 0x42, 0x52, 0x44, 0x20,
# else
#  ifdef __OpenBSD__
	0x4F, 0x50, 0x45, 0x4E, 0x42, 0x52, 0x44, 0x20,
#  else
#   ifdef linux
	0x4C, 0x49, 0x4E, 0x55, 0x58, 0x20, 0x20, 0x20,
#   else
#   endif
#  endif
# endif
#endif
	0x54, 0x41, 0x52, 0x47, 0x45, 0x54, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x31
};
#endif

d73 1
a73 9
__P((struct ispsoftc *, ispstatusreq_t *, u_int8_t *));
#ifdef	ISP_TARGET_MODE
static int isp_modify_lun __P((struct ispsoftc *, int, int, int));
static void isp_notify_ack __P((struct ispsoftc *, void *));
static void isp_handle_atio __P((struct ispsoftc *, void *));
static void isp_handle_atio2 __P((struct ispsoftc *, void *));
static void isp_handle_ctio __P((struct ispsoftc *, void *));
static void isp_handle_ctio2 __P((struct ispsoftc *, void *));
#endif
d76 3
a78 1
static void isp_fastpost_complete __P((struct ispsoftc *, int));
d82 1
d84 5
a90 1
static void isp_dumpxflist __P((struct ispsoftc *));
d93 3
a95 2
static void isp_update  __P((struct ispsoftc *));
static void isp_setdfltparm __P((struct ispsoftc *));
d102 1
a102 1
 * Hit the chip over the head, download new f/w and set it running.
d136 1
a136 1
	if (isp->isp_used == 0) {
d143 8
a150 9
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			/*
			 * If this fails, it probably means we're running
			 * an old prom, if anything at all...
			 */
			isp->isp_romfw_rev = 0;
		} else {
			isp->isp_romfw_rev =
			    (((u_int16_t) mbs.param[1]) << 10) + mbs.param[2];
d152 1
a152 1
		isp->isp_used = 1;
d155 2
d158 1
a158 1
	 * Put it into PAUSE mode.
d163 14
a176 1
		revname = "2100";
d181 1
a181 1
		sdp->isp_clock = 100;
d216 1
a216 1
			sdp->isp_clock = 40;
d226 1
a226 1
			sdp->isp_clock = 40;
d231 1
a231 1
			sdp->isp_clock = 60;
d236 1
a236 1
			sdp->isp_clock = 60;
d241 1
a241 1
			sdp->isp_clock = 60;
d243 5
d272 1
a272 1
			sdp->isp_clock = 60;
d285 2
a286 2
			if (isp->isp_mdvec->dv_clock < sdp->isp_clock) {
				sdp->isp_clock = isp->isp_mdvec->dv_clock;
d351 1
a351 1
		if (isp->isp_type & ISP_HA_SCSI) {
a427 5
	 * Enable interrupts
	 */
	ENABLE_INTS(isp);

	/*
d456 1
a456 1
	if (isp->isp_type & ISP_HA_SCSI) {
d487 1
a487 1
	if ((isp->isp_mdvec->dv_fwlen == 0) ||
d492 5
a496 2
	if (dodnld && isp->isp_mdvec->dv_fwlen) {
		for (i = 0; i < isp->isp_mdvec->dv_fwlen; i++) {
d537 1
a537 2
	if (isp->isp_type & ISP_HA_SCSI) {
		sdparam *sdp = isp->isp_param;
d541 1
a541 1
		if (sdp->isp_clock) {
d543 1
a543 1
			mbs.param[1] = sdp->isp_clock;
d546 2
a547 1
				isp_dumpregs(isp, "failed to set CLOCKRATE");
a548 3
			} else {
				IDPRINTF(3, ("%s: setting input clock to %d\n",
				    isp->isp_name, sdp->isp_clock));
d555 1
a555 1
		isp_dumpregs(isp, "ABOUT FIRMWARE command failed");
d558 3
a560 3
	PRINTF("%s: Board Revision %s, %s F/W Revision %d.%d\n",
		isp->isp_name, revname, dodnld? "loaded" : "resident",
		mbs.param[1], mbs.param[2]);
d563 1
a563 1
			PRINTF("%s: in 64-Bit PCI slot\n", isp->isp_name);
d566 16
a581 4
	isp->isp_fwrev = (((u_int16_t) mbs.param[1]) << 10) + mbs.param[2];
	if (isp->isp_romfw_rev && dodnld) {
		PRINTF("%s: Last F/W revision was %d.%d\n", isp->isp_name,
		    isp->isp_romfw_rev >> 10, isp->isp_romfw_rev & 0x3ff);
d583 3
d587 8
d608 20
a627 1
	sdparam *sdp;
d629 8
a636 1
	int tgt;
d639 1
a639 1
	 * Must do first.
d641 3
a643 1
	isp_setdfltparm(isp);
d646 2
a647 1
	 * Set up DMA for the request and result mailboxes.
d649 10
a658 2
	if (ISP_MBOXDMASETUP(isp) != 0) {
		PRINTF("%s: can't setup dma mailboxes\n", isp->isp_name);
d663 1
a663 2
	 * If we're fibre, we have a completely different
	 * initialization method.
d665 7
a671 2
	if (IS_FC(isp)) {
		isp_fibre_init(isp);
a673 1
	sdp = isp->isp_param;
d676 1
a676 1
	 * If we have fast memory timing enabled, turn it on.
d678 19
a696 2
	if (sdp->isp_fast_mttr) {
		ISP_WRITE(isp, RISC_MTR, 0x1313);
d700 1
a700 1
	 * Set (possibly new) Initiator ID.
d702 3
a704 2
	mbs.param[0] = MBOX_SET_INIT_SCSI_ID;
	mbs.param[1] = sdp->isp_initiator_id;
d707 3
a709 1
		isp_dumpregs(isp, "failed to set initiator id");
d714 1
a714 1
	 * Set Retry Delay and Count
d716 3
a718 3
	mbs.param[0] = MBOX_SET_RETRY_COUNT;
	mbs.param[1] = sdp->isp_retry_count;
	mbs.param[2] = sdp->isp_retry_delay;
d721 1
a721 1
		isp_dumpregs(isp, "failed to set retry count and delay");
d725 5
d731 1
a731 1
	 * Set ASYNC DATA SETUP time. This is very important.
d733 7
a739 2
	mbs.param[0] = MBOX_SET_ASYNC_DATA_SETUP_TIME;
	mbs.param[1] = sdp->isp_async_data_setup;
d742 1
a742 1
		isp_dumpregs(isp, "failed to set async data setup time");
d745 1
d747 6
a752 7
	/*
	 * Set ACTIVE Negation State.
	 */
	mbs.param[0] = MBOX_SET_ACTIVE_NEG_STATE;
	mbs.param[1] =
	    (sdp->isp_req_ack_active_neg << 4) |
	    (sdp->isp_data_line_active_neg << 5);
d755 1
a755 1
		isp_dumpregs(isp, "failed to set active neg state");
d758 1
d761 1
a761 1
	 * Set the Tag Aging limit
d764 17
a780 6
	mbs.param[0] = MBOX_SET_TAG_AGE_LIMIT;
	mbs.param[1] = sdp->isp_tag_aging;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_dumpregs(isp, "failed to set tag age limit");
		return;
d784 1
a784 1
	 * Set selection timeout.
d786 14
d801 5
a805 2
	mbs.param[0] = MBOX_SET_SELECT_TIMEOUT;
	mbs.param[1] = sdp->isp_selection_timeout;
d808 2
a809 1
		isp_dumpregs(isp, "failed to set selection timeout");
d820 3
a822 1
		if (sdp->isp_devparam[tgt].dev_enable == 0)
d824 1
a825 1
		sdf = DPARM_SAFE_DFLT;
d827 2
a828 2
		 * It is not quite clear when this changed over so that
		 * we could force narrow and async, so assume >= 7.55.
d830 12
a841 2
		if (isp->isp_fwrev >= ISP_FW_REV(7, 55)) {
			sdf |= DPARM_NARROW | DPARM_ASYNC;
d844 1
a844 1
		mbs.param[1] = tgt << 8;
d853 1
a853 1
			mbs.param[1] = tgt << 8;
d865 2
d874 1
a874 1
		mbs.param[1] = (tgt << 8);
d887 9
d903 4
a906 2

		maxlun = (isp->isp_fwrev >= ISP_FW_REV(7, 55))? 32 : 8;
d909 1
a909 1
			mbs.param[1] = (tgt << 8) | lun;
a919 68
		/*
		 * And mark this as an unannounced device
		 */
		sdp->isp_devparam[tgt].dev_announced = 0;
	}

	mbs.param[0] = MBOX_INIT_RES_QUEUE;
	mbs.param[1] = RESULT_QUEUE_LEN;
	mbs.param[2] = (u_int16_t) (isp->isp_result_dma >> 16);
	mbs.param[3] = (u_int16_t) (isp->isp_result_dma & 0xffff);
	mbs.param[4] = 0;
	mbs.param[5] = 0;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_dumpregs(isp, "set of response queue failed");
		return;
	}
	isp->isp_residx = 0;

	mbs.param[0] = MBOX_INIT_REQ_QUEUE;
	mbs.param[1] = RQUEST_QUEUE_LEN;
	mbs.param[2] = (u_int16_t) (isp->isp_rquest_dma >> 16);
	mbs.param[3] = (u_int16_t) (isp->isp_rquest_dma & 0xffff);
	mbs.param[4] = 0;
	mbs.param[5] = 0;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_dumpregs(isp, "set of request queue failed");
		return;
	}
	isp->isp_reqidx = isp->isp_reqodx = 0;

	/*
	 *  Turn on Fast Posting, LVD transitions
	 */

	if (IS_1080(isp) || isp->isp_fwrev >= ISP_FW_REV(7, 55)) {
		mbs.param[0] = MBOX_SET_FW_FEATURES;
#ifndef	ISP_NO_FASTPOST_SCSI
		mbs.param[1] |= FW_FEATURE_FAST_POST;
#else
		mbs.param[1] = 0;
#endif
		if (IS_1080(isp))
			mbs.param[1] |= FW_FEATURE_LVD_NOTIFY;
		if (mbs.param[1] != 0) {
			isp_mboxcmd(isp, &mbs);
			if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
				PRINTF("%s: unable enable FW features\n",
				    isp->isp_name);
			}
		}
	}

	/*
	 * Let the outer layers decide whether to issue a SCSI bus reset.
	 */
#if	0
	/*
	 * XXX: See whether or not for 7.55 F/W or later we
	 * XXX: can do without this, and see whether we should
	 * XXX: honor the NVRAM SCSI_RESET_DISABLE token.
	 */
	mbs.param[0] = MBOX_BUS_RESET;
	mbs.param[1] = 3;
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		isp_dumpregs(isp, "SCSI bus reset failed");
a920 6
	/*
	 * This is really important to have set after a bus reset.
	 */
	isp->isp_sendmarker = 1;
#endif
	isp->isp_state = ISP_INITSTATE;
d935 1
a935 1
	int count, loopid;
d948 1
a948 1
	loopid = DEFAULT_LOOPID;
a952 10
#if	defined(ISP2100_FABRIC) && defined(ISP2100_SCCLUN)
	PRINTF("%s: Fabric Support, Expanded Lun Support\n", isp->isp_name);
#endif
#if	defined(ISP2100_FABRIC) && !defined(ISP2100_SCCLUN)
	PRINTF("%s: Fabric Support\n", isp->isp_name);
#endif
#if	!defined(ISP2100_FABRIC) && defined(ISP2100_SCCLUN)
	PRINTF("%s: Expanded Lun Support\n", isp->isp_name);
#endif

d958 1
a958 1
	fcp->isp_fwoptions = ICBOPT_TGT_ENABLE|ICBOPT_INI_TGTTYPE;
d962 8
a969 1
	fcp->isp_fwoptions |= ICBOPT_INI_ADISC|ICBOPT_FAIRNESS;
d972 8
d983 7
a989 6
#ifdef	CHECKME
	fcp->isp_fwoptions |= ICBOPT_USE_PORTNAME;
#endif
#ifdef	ISP2100_FABRIC
	fcp->isp_fwoptions |= ICBOPT_FULL_LOGIN;
#endif
d997 1
d1000 5
d1006 5
d1014 1
d1016 23
a1038 4
	MAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, fcp->isp_wwn);
	if (icbp->icb_fwoptions & ICBOPT_USE_PORTNAME) {
		u_int64_t portname = fcp->isp_wwn | (2LL << 56);
		MAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, portname);
d1042 5
a1046 9
	icbp->icb_rqstaddr[RQRSP_ADDR0015] =
	    (u_int16_t) (isp->isp_rquest_dma & 0xffff);
	icbp->icb_rqstaddr[RQRSP_ADDR1631] =
	    (u_int16_t) (isp->isp_rquest_dma >> 16);
	icbp->icb_respaddr[RQRSP_ADDR0015] =
	    (u_int16_t) (isp->isp_result_dma & 0xffff);
	icbp->icb_respaddr[RQRSP_ADDR1631] =
	    (u_int16_t) (isp->isp_result_dma >> 16);
	MemoryBarrier();
d1048 9
a1056 1
	for (count = 0; count < 10; count++) {
d1059 2
a1060 2
		mbs.param[2] = (u_int16_t) (fcp->isp_scdma >> 16);
		mbs.param[3] = (u_int16_t) (fcp->isp_scdma & 0xffff);
a1064 1

d1066 6
a1071 17

		switch (mbs.param[0]) {
		case MBOX_COMMAND_COMPLETE:
			count = 10;
			break;
		case ASYNC_PDB_CHANGED:
			isp_mark_getpdb_all(isp);
			/* FALL THROUGH */
		case ASYNC_LIP_OCCURRED:
		case ASYNC_LOOP_UP:
		case ASYNC_LOOP_DOWN:
		case ASYNC_LOOP_RESET:
		case ASYNC_CHANGE_NOTIFY:
			if (count > 9) {
				PRINTF("%s: too many retries to get going- "
				    "giving up\n", isp->isp_name);
				return;
a1072 3
			break;
		default:
			isp_dumpregs(isp, "INIT FIRMWARE failed");
d1075 1
d1077 1
a1085 9
	fcp->isp_fwstate = FW_CONFIG_WAIT;

	isp_mark_getpdb_all(isp);

#ifdef	ISP_TARGET_MODE
	if (isp_modify_lun(isp, 0, 1, 1)) {
		PRINTF("%s: failed to enable target mode\n", isp->isp_name);
	}
#endif
a1098 1
	isp_pdb_t *p;
d1100 3
a1102 2
	for (p = &fcp->isp_pdb[0]; p < &fcp->isp_pdb[MAX_FC_TARG]; p++) {
		p->pdb_options = INVALID_PDB_OPTIONS;
d1114 1
d1117 2
a1118 2
	mbs.param[2] = (u_int16_t) (fcp->isp_scdma >> 16);
	mbs.param[3] = (u_int16_t) (fcp->isp_scdma & 0xffff);
d1132 1
a1132 1
		MEMCPY(pdbp, fcp->isp_scratch, sizeof (isp_pdb_t));
d1139 2
a1140 2
		IDPRINTF(3, ("%s: Comand Param Error on Get Port Database\n",
		    isp->isp_name));
d1150 28
d1187 7
d1195 1
a1195 1
	int count;
d1198 3
a1200 1

d1238 18
d1257 31
a1287 2
	PRINTF("%s: Loop ID %d, ALPA 0x%x\n", isp->isp_name,
	    fcp->isp_loopid, fcp->isp_alpa);
d1289 14
d1304 6
d1313 463
d1784 1
a1784 1
	u_int8_t iptr, optr;
d1792 1
a1792 1
	int i, rqidx;
d1808 3
a1810 3
	if (XS_CDBLEN(xs) > ((isp->isp_type & ISP_HA_FC)? 16 : 12)) {
		PRINTF("%s: unsupported cdb length (%d)\n",
		    isp->isp_name, XS_CDBLEN(xs));
d1819 1
d1822 14
a1835 2
		isp_pdb_t *pdbp = &fcp->isp_pdb[XS_TGT(xs)];

d1837 10
a1846 2
		 * Check for f/w being in ready state. Well, okay,
		 * our cached copy of it...
d1851 28
d1882 1
d1884 1
a1884 1
		 * Refresh our port database if needed.
d1886 10
a1895 5
		if (pdbp->pdb_options == INVALID_PDB_OPTIONS) {
			if (isp_getpdb(isp, XS_TGT(xs), pdbp) == 0) {
				isp_async(isp, ISPASYNC_PDB_CHANGE_COMPLETE,
				    (void *) (long) XS_TGT(xs));
			}
d1897 4
d1907 1
a1907 1
	if (isp->isp_update) {
d1911 2
a1912 7
	optr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);
	iptr = isp->isp_reqidx;

	reqp = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);
	iptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);
	if (iptr == optr) {
		IDPRINTF(2, ("%s: Request Queue Overflow\n", isp->isp_name));
d1917 5
d1923 1
a1923 8
		u_int8_t niptr;
		ispmarkreq_t *marker = (ispmarkreq_t *) reqp;

		MEMZERO((void *) marker, sizeof (*marker));
		marker->req_header.rqs_entry_count = 1;
		marker->req_header.rqs_entry_type = RQSTYPE_MARKER;
		marker->req_modifier = SYNC_ALL;

d1925 1
a1925 1
		 * Unconditionally update the input pointer anyway.
d1927 19
a1945 9
		ISP_WRITE(isp, INMAILBOX4, iptr);
		isp->isp_reqidx = iptr;

		niptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);
		if (niptr == optr) {
			IDPRINTF(2, ("%s: Request Queue Overflow+\n",
			    isp->isp_name));
			XS_SETERR(xs, HBA_BOTCH);
			return (CMD_EAGAIN);
a1946 2
		reqp = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);
		iptr = niptr;
d1951 1
a1951 1
	if (isp->isp_type & ISP_HA_FC) {
d1957 2
a1958 20
	reqp->req_header.rqs_seqno = isp->isp_seqno++;

	for (rqidx = 0; rqidx < RQUEST_QUEUE_LEN; rqidx++) {
		if (isp->isp_xflist[rqidx] == NULL)
			break;
	}
	if (rqidx == RQUEST_QUEUE_LEN) {
		IDPRINTF(2, ("%s: out of xflist pointers\n", isp->isp_name));
		XS_SETERR(xs, HBA_BOTCH);
		return (CMD_EAGAIN);
	} else {
		/*
		 * Never have a handle that is zero, so
		 * set req_handle off by one.
		 */
		isp->isp_xflist[rqidx] = xs;
		reqp->req_handle = rqidx+1;
	}

	if (isp->isp_type & ISP_HA_FC) {
d1966 2
a1967 4
		 * If we're marked as "Can't Tag", just do simple
		 * instead of ordered tags. It's pretty clear to me
		 * that we shouldn't do head of queue tagging in
		 * this case.
d1972 4
a1975 1
			t2reqp->req_flags = REQFLAG_STAG;
d1979 1
a1979 1
		if ((sdp->isp_devparam[XS_TGT(xs)].cur_dflags & DPARM_TQING) &&
a1981 2
		} else {
			reqp->req_flags = 0;
d1984 2
a1985 2
	reqp->req_target = XS_TGT(xs);
	if (isp->isp_type & ISP_HA_SCSI) {
d1990 1
a1990 1
		reqp->req_scclun = XS_LUN(xs);
d1992 1
a1992 1
		reqp->req_lun_trn = XS_LUN(xs);
a1993 1

a1996 4
	IDPRINTF(5, ("%s(%d.%d): START%d cmd 0x%x datalen %d\n", isp->isp_name,
	    XS_TGT(xs), XS_LUN(xs), reqp->req_header.rqs_seqno,
	    reqp->req_cdb[0], XS_XFRLEN(xs)));

d2003 1
d2005 1
a2005 1
	if (isp->isp_sendmarker && reqp->req_time < 5)
d2007 10
a2016 1

d2019 1
a2019 4
		/*
		 * Take memory of it away...
		 */
		isp->isp_xflist[rqidx] = NULL;
d2027 3
d2031 1
a2031 2
	ISP_WRITE(isp, INMAILBOX4, iptr);
	isp->isp_reqidx = iptr;
d2053 2
a2054 1
	int i;
a2063 5
		 * This is really important to have set after a bus reset.
		 */
		isp->isp_sendmarker = 1;

		/*
d2067 1
a2067 1
		if (isp->isp_type & ISP_HA_SCSI) {
d2072 2
d2075 3
a2077 4
			/*
			 * Unparameterized.
			 */
			mbs.param[1] = 5;
d2079 1
d2085 2
a2086 1
		PRINTF("%s: driver initiated bus reset\n", isp->isp_name);
d2090 2
d2093 1
a2093 1
		mbs.param[1] = ((long)arg) << 8;
d2097 2
a2098 1
			isp_dumpregs(isp, "Target Reset Failed");
d2101 3
a2103 3
		PRINTF("%s: Target %d Reset Succeeded\n", isp->isp_name,
		    (int) ((long) arg));
		isp->isp_sendmarker = 1;
d2108 2
a2109 6
		for (i = 0; i < RQUEST_QUEUE_LEN; i++) {
			if (xs == isp->isp_xflist[i]) {
				break;
			}
		}
		if (i == RQUEST_QUEUE_LEN) {
d2114 1
d2116 1
a2117 1
		if (isp->isp_type & ISP_HA_FC) {
d2122 3
d2126 2
a2127 1
			mbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);
d2129 2
a2130 5
#else
		mbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);
#endif
		mbs.param[2] = (i+1) >> 16;
		mbs.param[3] = (i+1) & 0xffff;
d2147 7
d2171 2
a2172 2
	u_int8_t iptr, optr;
	u_int16_t isr;
d2175 25
a2199 17
	isr = ISP_READ(isp, BIU_ISR);
	if (isp->isp_type & ISP_HA_FC) {
		if (isr == 0 || (isr & BIU2100_ISR_RISC_INT) == 0) {
			if (isr) {
				IDPRINTF(4, ("%s: isp_intr isr=%x\n",
				    isp->isp_name, isr));
			}
			return (0);
		}
	} else {
		if (isr == 0 || (isr & BIU_ISR_RISC_INT) == 0) {
			if (isr) {
				IDPRINTF(4, ("%s: isp_intr isr=%x\n",
				    isp->isp_name, isr));
			}
			return (0);
		}
d2202 1
a2202 1
	if (ISP_READ(isp, BIU_SEMA) & 1) {
d2205 1
a2205 1
			IDPRINTF(3, ("%s: isp_intr sees 0x%x\n",
a2206 1
			ISP_WRITE(isp, BIU_SEMA, 0);
d2209 4
a2212 19
			ISP_WRITE(isp, BIU_SEMA, 0);
			if (fhandle < 0) {
				return (1);
			} else if (fhandle > 0) {
				xs = (void *)isp->isp_xflist[fhandle - 1];
				isp->isp_xflist[fhandle - 1] = NULL;
				/*
				 * Since we don't have a result queue entry
				 * item, we must believe that SCSI status is
				 * zero and that all data transferred.
				 */
				XS_RESID(xs) = 0;
				XS_STS(xs) = 0;
				if (XS_XFRLEN(xs)) {
					ISP_DMAFREE(isp, xs, fhandle - 1);
				}
				if (isp->isp_nactive > 0)
				    isp->isp_nactive--;
				complist[ndone++] = xs;
d2215 4
a2219 1
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
d2221 3
d2226 1
a2226 1

a2230 1
	ENABLE_INTS(isp);
d2234 1
a2234 1
		u_int8_t oop;
d2242 5
d2254 2
a2255 1
			 * from the request queue to the response queue.
a2256 1

d2259 4
a2264 3
			PRINTF("%s: not RESPONSE in RESPONSE Queue "
			    "(type 0x%x) @@ idx %d (next %d)\n", isp->isp_name,
			    sp->req_header.rqs_entry_type, oop, optr);
d2269 2
d2272 2
a2276 2
			PRINTF("%s: rqs_flags=%x", isp->isp_name,
				sp->req_header.rqs_flags & 0xf);
d2278 5
a2282 4
				PRINTF("%s: internal queues full\n",
				    isp->isp_name);
				/* XXXX: this command *could* get restarted */
				buddaboom++;
d2293 6
d2300 1
a2300 1
		if (sp->req_handle > RQUEST_QUEUE_LEN || sp->req_handle < 1) {
d2302 1
a2302 1
				sp->req_handle);
d2306 1
a2306 1
		xs = (void *) isp->isp_xflist[sp->req_handle - 1];
d2308 1
a2308 1
			PRINTF("%s: NULL xs in xflist (handle %x)\n",
a2309 1
			isp_dumpxflist(isp);
d2313 1
a2313 1
		isp->isp_xflist[sp->req_handle - 1] = NULL;
d2315 1
a2315 1
			isp->isp_sendmarker = 1;
d2321 1
a2321 1
		if (isp->isp_type & ISP_HA_SCSI) {
d2334 1
a2334 1
				isp->isp_update = 1;
d2336 1
d2358 10
d2369 2
a2370 2
			PRINTF("%s: unknown return %x\n", isp->isp_name,
				sp->req_header.rqs_entry_type);
d2375 1
a2375 1
		if (isp->isp_type & ISP_HA_SCSI) {
d2383 1
a2383 1
			ISP_DMAFREE(isp, xs, sp->req_handle - 1);
d2400 1
a2400 1
			PRINTF("%s(%d.%d): FIN%d dl%d resid%d STS %x",
d2402 1
a2402 2
			    sp->req_header.rqs_seqno, XS_XFRLEN(xs),
			    XS_RESID(xs), XS_STS(xs));
d2433 1
d2446 1
d2449 11
d2464 1
a2464 2
		isp_async(isp, ISPASYNC_BUS_RESET, NULL);
		isp->isp_sendmarker = 1;
d2466 1
a2466 1
		isp_notify_ack(isp, NULL);
d2468 1
a2469 1

d2487 5
a2491 1
		/* don't need to be chatty */
d2496 3
a2498 2
		PRINTF("%s: timeout initiated SCSI bus reset\n", isp->isp_name);
		isp->isp_sendmarker = 1;
d2500 1
a2500 1
		isp_notify_ack(isp, NULL);
d2505 2
a2506 2
		isp->isp_sendmarker = 1;
		PRINTF("%s: device reset\n", isp->isp_name);
d2508 1
a2508 1
		isp_notify_ack(isp, NULL);
d2526 4
a2529 560
	case ASYNC_KILLED_BUS:
		PRINTF("%s: SCSI Bus reset after DATA Overrun\n",
		    isp->isp_name);
		break;

	case ASYNC_BUS_TRANSIT:
		mbox = ISP_READ(isp, OUTMAILBOX2);
		switch (mbox & 0x1c00) {
		case SXP_PINS_LVD_MODE:
			PRINTF("%s: Transition to LVD mode\n", isp->isp_name);
			((sdparam *)isp->isp_param)->isp_diffmode = 0;
			((sdparam *)isp->isp_param)->isp_ultramode = 0;
			((sdparam *)isp->isp_param)->isp_lvdmode = 1;
			break;
		case SXP_PINS_HVD_MODE:
			PRINTF("%s: Transition to Differential mode\n",
			    isp->isp_name);
			((sdparam *)isp->isp_param)->isp_diffmode = 1;
			((sdparam *)isp->isp_param)->isp_ultramode = 0;
			((sdparam *)isp->isp_param)->isp_lvdmode = 0;
			break;
		case SXP_PINS_SE_MODE:
			PRINTF("%s: Transition to Single Ended mode\n",
			    isp->isp_name);
			((sdparam *)isp->isp_param)->isp_diffmode = 0;
			((sdparam *)isp->isp_param)->isp_ultramode = 1;
			((sdparam *)isp->isp_param)->isp_lvdmode = 0;
			break;
		default:
			PRINTF("%s: Transition to unknown mode 0x%x\n",
			    isp->isp_name, mbox);
			break;
		}
		/*
		 * XXX: Set up to renegotiate again!
		 */
		isp->isp_sendmarker = 1;
		break;

	case ASYNC_CMD_CMPLT:
		fast_post_handle = (ISP_READ(isp, OUTMAILBOX2) << 16) |
		    ISP_READ(isp, OUTMAILBOX1);
		IDPRINTF(3, ("%s: fast post completion of %u\n", isp->isp_name,
		    fast_post_handle));
		break;

	case ASYNC_CTIO_DONE:
		/* Should only occur when Fast Posting Set for 2100s */
		PRINTF("%s: CTIO done\n", isp->isp_name);
		break;

	case ASYNC_LIP_OCCURRED:
		isp->isp_sendmarker = 1;
		PRINTF("%s: LIP occurred\n", isp->isp_name);
		break;

	case ASYNC_LOOP_UP:
		isp->isp_sendmarker = 1;
		isp_async(isp, ISPASYNC_LOOP_UP, NULL);
		break;

	case ASYNC_LOOP_DOWN:
		isp_async(isp, ISPASYNC_LOOP_DOWN, NULL);
		break;

	case ASYNC_LOOP_RESET:
		isp->isp_sendmarker = 1;
		PRINTF("%s: Loop RESET\n", isp->isp_name);
#ifdef	ISP_TARGET_MODE
		isp_notify_ack(isp, NULL);
#endif
		break;

	case ASYNC_PDB_CHANGED:
		isp->isp_sendmarker = 1;
		isp_mark_getpdb_all(isp);
		PRINTF("%s: Port Database Changed\n", isp->isp_name);
		break;

	case ASYNC_CHANGE_NOTIFY:
		break;

	default:
		PRINTF("%s: unknown async code 0x%x\n", isp->isp_name, mbox);
		break;
	}
	return (fast_post_handle);
}

static int
isp_handle_other_response(isp, sp, optrp)
	struct ispsoftc *isp;
	ispstatusreq_t *sp;
	u_int8_t *optrp;
{
	u_int8_t iptr, optr;
	int reqsize = 0;
	void *ireqp = NULL;
#ifdef	ISP_TARGET_MODE
	union {
		at_entry_t	*atio;
		at2_entry_t	*at2io;
		ct_entry_t	*ctio;
		ct2_entry_t	*ct2io;
		lun_entry_t	*lunen;
		in_entry_t	*inot;
		in_fcentry_t	*inot_fc;
		na_entry_t	*nack;
		na_fcentry_t	*nack_fc;
		void		*voidp;
#define	atio	un.atio
#define	at2io	un.at2io
#define	ctio	un.ctio
#define	ct2io	un.ct2io
#define	lunen	un.lunen
#define	inot	un.inot
#define	inot_fc	un.inot_fc
#define	nack	un.nack
#define	nack_fc	un.nack_fc
	} un;

	un.voidp = sp;
#endif


	switch (sp->req_header.rqs_entry_type) {
	case RQSTYPE_REQUEST:
		return (-1);
#ifdef	ISP_TARGET_MODE
	case RQSTYPE_NOTIFY_ACK:
	{
		static const char *f =
			"%s: Notify Ack Status 0x%x Sequence Id 0x%x\n"
		/*
		 * The ISP is acknowleding our ack of an Immediate Notify.
		 */
		if (isp->isp_type & ISP_HA_FC) {
			PRINTF(f, isp->isp_name,
			    nack_fc->na-status, nack_fc->na_seqid);
		} else {
			PRINTF(f, isp->isp_name,
			    nack->na_status, nack->na_seqid);
		}
		break;
	}
	case RQSTYPE_NOTIFY:
	{
		u_int16_t seqid, status;

		/*
		 * Either the ISP received a SCSI message it cannot handle
		 * or some other out of band condition (e.g., Port Logout)
		 * or it is returning an Immediate Notify entry we sent.
		 */
		if (isp->isp_type & ISP_HA_FC) {
			status = inot_fc->status;
			seqid = inot_fc->in_seqid;
		} else {
			status = inot->status;
			seqid = inot->seqid & 0xff;
		}
		PRINTF("%s: Immediate Notify Status 0x%x Sequence Id 0x%x\n",
		    isp->isp_name, status, seqid);

		switch (status) {
		case IN_MSG_RECEIVED:
		case IN_IDE_RECEIVED:
			ptisp_got_msg(ptp, &inot);
			break;
		case IN_RSRC_UNAVAIL:
			PRINTF("%s: Firmware out of ATIOs\n", isp->isp_name);
			break;
		case IN_ABORT_TASK:
			PRINTF("%s: Abort Task iid %d rx_id 0x%x\n",
			    inot_fc->in_iid, seqid);
			break;
		case IN_PORT_LOGOUT:
			PRINTF("%s: Port Logout for Initiator %d\n",
			    isp->isp_name, inot_fc->in_iid);
			break;
		default:
			PRINTF("%s: bad status (0x%x) in Immediate Notify\n",
			    isp->isp_name, status);
			break;

		}
		isp_notify_ack(isp, un.voidp);
		reqsize = 0;
		break;
	}
	case RQSTYPE_ENABLE_LUN:
	case RQSTYPE_MODIFY_LUN:
		if (lunen->req_status != 1) {
		    PRINTF("%s: ENABLE/MODIFY LUN returned status 0x%x\n",
			isp->isp_name, lunen->req_status);
		}
		break;
	case RQSTYPE_ATIO2:
	{
		fcparam *fcp = isp->isp_param;
		ispctiot2_t local, *ct2 = NULL;
		ispatiot2_t *at2 = (ispatiot2_t *) sp;
		int s, lun;

#ifdef	ISP2100_SCCLUN
		lun = at2->req_scclun;
#else
		lun = at2->req_lun;
#endif
		PRINTF("%s: atio2 loopid %d for lun %d rxid 0x%x flags0x%x "
		    "tflags0x%x ecodes0x%x rqstatus0x%x\n", isp->isp_name,
		    at2->req_initiator, lun, at2->req_rxid,
		    at2->req_flags, at2->req_taskflags, at2->req_execodes,
		    at2->req_status);

		switch (at2->req_status & ~ATIO_SENSEVALID) {
		case ATIO_PATH_INVALID:
			PRINTF("%s: ATIO2 Path Invalid\n", isp->isp_name);
			break;
		case ATIO_NOCAP:
			PRINTF("%s: ATIO2 No Cap\n", isp->isp_name);
			break;
		case ATIO_BDR_MSG:
			PRINTF("%s: ATIO2 BDR Received\n", isp->isp_name);
			break;
		case ATIO_CDB_RECEIVED:
			ct2 = &local;
			break;
		default:
			PRINTF("%s: unknown req_status 0x%x\n", isp->isp_name,
			    at2->req_status);
			break;
		}
		if (ct2 == NULL) {
			/*
			 * Just do an ACCEPT on this fellow.
			 */
			at2->req_header.rqs_entry_type = RQSTYPE_ATIO2;
			at2->req_header.rqs_flags = 0;
			at2->req_flags = 1;
			ireqp = at2;
			reqsize = sizeof (*at2);
			break;
		}
		PRINTF("%s: datalen %d cdb0=0x%x\n", isp->isp_name,
		    at2->req_datalen, at2->req_cdb[0]);
		MEMZERO((void *) ct2, sizeof (*ct2));
		ct2->req_header.rqs_entry_type = RQSTYPE_CTIO2;
		ct2->req_header.rqs_entry_count = 1;
		ct2->req_header.rqs_flags = 0;
		ct2->req_header.rqs_seqno = isp->isp_seqno++;
		ct2->req_handle = (at2->req_initiator << 16) | lun;
#ifndef	ISP2100_SCCLUN
		ct2->req_lun = lun;
#endif
		ct2->req_initiator = at2->req_initiator;
		ct2->req_rxid = at2->req_rxid;

		ct2->req_flags = CTIO_SEND_STATUS;
		switch (at2->req_cdb[0]) {
		case 0x0:		/* TUR */
			ct2->req_flags |= CTIO_NODATA | CTIO2_SMODE0;
			ct2->req_m.mode0.req_scsi_status = CTIO2_STATUS_VALID;
			break;

		case 0x3:		/* REQUEST SENSE */
		case 0x12:		/* INQUIRE */
			ct2->req_flags |= CTIO_SEND_DATA | CTIO2_SMODE0;
			ct2->req_m.mode0.req_scsi_status = CTIO2_STATUS_VALID;
			ct2->req_seg_count = 1;
			if (at2->req_cdb[0] == 0x12) {
				s = sizeof (tgtiqd);
				MEMCPY(fcp->isp_scratch, tgtiqd, s);
			} else {
				s = at2->req_datalen;
				MEMZERO(fcp->isp_scratch, s);
			}
			ct2->req_m.mode0.req_dataseg[0].ds_base =
			    fcp->isp_scdma;
			ct2->req_m.mode0.req_dataseg[0].ds_count = s;
			ct2->req_m.mode0.req_datalen = s;
#if	1
			if (at2->req_datalen < s) {
				ct2->req_m.mode1.req_scsi_status |=
				    CTIO2_RESP_VALID|CTIO2_RSPOVERUN;
			} else if (at2->req_datalen > s) {
				ct2->req_m.mode1.req_scsi_status |=
				    CTIO2_RESP_VALID|CTIO2_RSPUNDERUN;
			}
#endif
			break;

		default:		/* ALL OTHERS */
			ct2->req_flags |= CTIO_NODATA | CTIO2_SMODE1;
			ct2->req_m.mode1.req_scsi_status = 0;
#if	1
			if (at2->req_datalen) {
				ct2->req_m.mode1.req_scsi_status |=
				    CTIO2_RSPUNDERUN;
#if	BYTE_ORDER == BIG_ENDIAN
				ct2->req_resid[1] = at2->req_datalen & 0xff;
				ct2->req_resid[0] =
					(at2->req_datalen >> 8) & 0xff;
				ct2->req_resid[3] =
					(at2->req_datalen >> 16) & 0xff;
				ct2->req_resid[2] =
					(at2->req_datalen >> 24) & 0xff;
#else
				ct2->req_resid[0] = at2->req_datalen & 0xff;
				ct2->req_resid[1] =
					(at2->req_datalen >> 8) & 0xff;
				ct2->req_resid[2] =
					(at2->req_datalen >> 16) & 0xff;
				ct2->req_resid[3] =
					(at2->req_datalen >> 24) & 0xff;
#endif
			}
#endif
			if ((at2->req_status & ATIO_SENSEVALID) == 0) {
				ct2->req_m.mode1.req_sense_len = 18;
				ct2->req_m.mode1.req_scsi_status |= 2;
				ct2->req_m.mode1.req_response[0] = 0x70;
				ct2->req_m.mode1.req_response[2] = 0x2;
			} else {
				ct2->req_m.mode1.req_sense_len = 18;
				ct2->req_m.mode1.req_scsi_status |=
				    at2->req_scsi_status;
				MEMCPY(ct2->req_m.mode1.req_response,
				    at2->req_sense, sizeof (at2->req_sense));
			}
			break;
		}
		reqsize = sizeof (*ct2);
		ireqp = ct2;
		break;
	}
	case RQSTYPE_CTIO2:
	{
		ispatiot2_t *at2;
		ispctiot2_t *ct2 = (ispctiot2_t *) sp;
		PRINTF("%s: CTIO2 returned status 0x%x\n", isp->isp_name,
		    ct2->req_status);
		/*
		 * Return the ATIO to the board.
		 */
		at2 = (ispatiot2_t *) sp;
		at2->req_header.rqs_entry_type = RQSTYPE_ATIO2;
		at2->req_header.rqs_entry_count = 1;
		at2->req_header.rqs_flags = 0;
		at2->req_header.rqs_seqno = isp->isp_seqno++;
		at2->req_status = 1;
		reqsize = sizeof (*at2);
		ireqp = at2;
		break;
	}
#undef	atio
#undef	at2io
#undef	ctio
#undef	ct2io
#undef	lunen
#undef	inot
#undef	inot_fc
#undef	nack
#undef	nack_fc
#endif
	default:
		PRINTF("%s: other response type %x\n", isp->isp_name,
		    sp->req_header.rqs_entry_type);
		break;
	}
	if (reqsize) {
		void *reqp;
		optr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);
		iptr = isp->isp_reqidx;
		reqp = (void *) ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);
		iptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);
		if (iptr == optr) {
			PRINTF("%s: Request Queue Overflow other response\n",
			    isp->isp_name);
		} else {
			MEMCPY(reqp, ireqp, reqsize);
			ISP_WRITE(isp, INMAILBOX4, iptr);
			isp->isp_reqidx = iptr;
		}
	}
	return (0);
}

#ifdef	ISP_TARGET_MODE

static void isp_tmd_newcmd_dflt __P((void *, tmd_cmd_t *));
static void isp_tmd_event_dflt __P((void *, int));
static void isp_tmd_notify_dflt __P((void *, tmd_notify_t *));

static void isp_tgt_data_xfer __P ((tmd_cmd_t *));
static void isp_tgt_endcmd __P ((tmd_cmd_t *, u_int8_t));
static void isp_tgt_done __P ((tmd_cmd_t *));

static void
isp_tmd_newcmd_dflt(arg0, cmdp)
	void *arg0;
	tmd_cmd_t *cmdp;
{
}

static void
isp_tmd_event_dflt(arg0, event)
	void *arg0;
	int event;
{
}

static void
isp_tmd_notify_dflt(arg0, npt)
	void *arg0;
	tmd_notify_t *npt;
{
}

/*
 * Locks held, and ints disabled (if FC).
 *
 * XXX: SETUP ONLY FOR INITIAL ENABLING RIGHT NOW
 */
static int
isp_modify_lun(isp, lun, icnt, ccnt)
	struct ispsoftc *isp;
	int lun;	/* logical unit to enable, modify, or disable */
	int icnt;	/* immediate notify count */
	int ccnt;	/* command count */
{
	isplun_t *ip = NULL;
	u_int8_t iptr, optr;

	optr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);
	iptr = isp->isp_reqidx;
	ip = (isplun_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);
	iptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);
	if (iptr == optr) {
		PRINTF("%s: Request Queue Overflow in isp_modify_lun\n",
		    isp->isp_name);
		return (-1);
	}

	MEMZERO((void *) ip, sizeof (*ip));
	ip->req_header.rqs_entry_type = RQSTYPE_ENABLE_LUN;
	ip->req_header.rqs_entry_count = 1;
	ip->req_header.rqs_seqno = isp->isp_seqno++;
	ip->req_handle = RQSTYPE_ENABLE_LUN;
	if (isp->isp_type & ISP_HA_SCSI) {
		ip->req_lun = lun;
	}
	ip->req_cmdcount = ccnt;
	ip->req_imcount = icnt;
	ip->req_timeout = 0;	/* default 30 seconds */
	ISP_WRITE(isp, INMAILBOX4, iptr);
	isp->isp_reqidx = iptr;
	return (0);
}

static void
isp_notify_ack(isp, ptrp)
	struct ispsoftc *isp;
	void *ptrp;
{
	void *reqp;
	u_int8_t iptr, optr;
	union {
		na_fcentry_t _naf;
		na_entry_t _nas;
	} un;

	MEMZERO((caddr_t)&un, sizeof (un));
	un._nas.na_header.rqs_entry_type = RQSTYPE_NOTIFY_ACK;
	un._nas.na_header.rqs_entry_count = 1;

	if (isp->isp_type & ISP_HA_FC) {
		na_fcentry_t *na = &un._nas;
		if (ptrp) {
			in_fcentry_t *inp = ptrp;
			na->na_iid = inp->in_iid;
			na->na_lun = inp->in_lun;
			na->na_task_flags = inp->in_task_flags;
			na->na_seqid = inp->in_seqid;
			na->na_status = inp->in_status;
		} else {
			na->na_flags = NAFC_RST_CLRD;
		}
	} else {
		na_entry_t *na = &un._nas;
		if (ptrp) {
			in_entry_t *inp = ptrp;
			na->na_iid = inp->in_iid;
			na->na_lun = inp->in_lun;
			na->na_tgt = inp->in_tgt;
			na->na_seqid = inp->in_seqid;
		} else {
			na->na_flags = NA_RST_CLRD;
		}
	}
	optr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);
	iptr = isp->isp_reqidx;
	reqp = (void *) ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);
	iptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);
	if (iptr == optr) {
		PRINTF("%s: Request Queue Overflow For isp_notify_ack\n",
		    isp->isp_name);
	} else {
		MEMCPY(reqp, ireqp, sizeof (un));
		ISP_WRITE(isp, INMAILBOX4, iptr);
		isp->isp_reqidx = iptr;
	}
}

/*
 * These are dummy stubs for now until the outside framework is plugged in.
 */

static void
isp_handle_atio (isp, aep)
	struct ispsoftc *isp;
	at_entry_t *aep;
{
	int status, connected;
	tmd_cmd_t local, *cdp = &local;

	/*
	 * Get the ATIO status and see if we're still connected.
	 */
	status = aep->at_status;
	connected = ((aep->at_flags & AT_NODISC) != 0);

	PRINTF("%s: ATIO status=0x%x, connected=%d\n", isp->isp_name,
	    status, connected);

	/*
	 * The firmware status (except for the SenseValid bit) indicates
	 * why this ATIO was sent to us.
	 * If SenseValid is set, the firware has recommended Sense Data.
	 * If the Disconnects Disabled bit is set in the flags field,
	 * we're still connected on the SCSI bus - i.e. the initiator
	 * did not set DiscPriv in the identify message. We don't care
	 * about this so it's ignored.
	 */
	switch (status & ~TGTSVALID) {
	case AT_PATH_INVALID:
		/*
		 * ATIO rejected by the firmware due to disabled lun.
		 */
		PRINTF("%s: Firmware rejected ATIO for disabled lun %d\n",
		    isp->isp_name, aep->at_lun);
		break;

	case AT_PHASE_ERROR:
		/*
		 * Bus Pase Sequence error.
		 *
		 * The firmware should have filled in the correct
		 * sense data.
		 */
d2531 18
a2548 8

		if (status & TGTSVALID) {
			MEMCPY(&cdp->cd_sensedata, aep->at_sense,
			    sizeof (cdp->cd_sensedata));
			PRINTF("%s: Bus Phase Sequence error key 0x%x\n",
			    isp->isp_name, cdp->cd_sensedata[2] & 0xf);
		} else {
			PRINTF("%s: Bus Phase Sequence With No Sense\n",
d2550 8
d2559 5
a2563 1
		(*isp->isp_tmd_newcmd)(isp, cdp);
d2566 5
a2570 8
	case AT_NOCAP:
		/*
		 * Requested Capability not available
		 * We sent an ATIO that overflowed the firmware's
		 * command resource count.
		 */
		PRINTF("%s: Firmware rejected ATIO, command count overflow\n",
		    isp->isp_name);
d2573 3
a2575 24
	case AT_BDR_MSG:
		/*
		 * If we send an ATIO to the firmware to increment
		 * its command resource count, and the firmware is
		 * recovering from a Bus Device Reset, it returns
		 * the ATIO with this status.
		 */
		PRINTF("%s: ATIO returned with BDR received\n", isp->isp_name);
		break;

	case AT_CDB:
		/*
		 * New CDB
		 */
		cdp->cd_hba = isp;
		cdp->cd_iid = aep->at_iid;
		cdp->cd_tgt = aep->at_tgt;
		cdp->cd_lun = aep->at_lun;
		cdp->cd_tagtype = aep->at_tag_type;
		cdp->cd_tagval = aep->at_tag_val;
		MEMCPY(cdp->cd_cdb, aep->at_cdb, 16);
		PRINTF("%s: CDB 0x%x itl %d/%d/%d\n", isp->isp_name,
		    cdp->cd_cdb[0], cdp->cd_iid, cdp->cd_tgt, cdp->cd_lun);
		(*isp->isp_tmd_newcmd)(isp, cdp);
d2578 8
a2585 10
	default:
		PRINTF("%s: Unknown status (0x%x) in ATIO\n",
		    isp->isp_name, status);
		cdp->cd_hba = isp;
		cdp->cd_iid = aep->at_iid;
		cdp->cd_tgt = aep->at_tgt;
		cdp->cd_lun = aep->at_lun;
		cdp->cd_tagtype = aep->at_tag_type;
		cdp->cd_tagval = aep->at_tag_val;
		isp_tgtcmd_done(cdp);
a2586 2
	}
}
d2588 7
a2594 7
static void
isp_handle_atio2(isp, aep)
	struct ispsoftc *isp;
	at2_entry_t *aep;
{
	int status;
	tmd_cmd_t local, *cdp = &local;
d2596 7
a2602 5
	/*
	 * Get the ATIO2 status.
	 */
	status = aep->at_status;
	PRINTD("%s: ATIO2 status=0x%x\n", status);
d2604 9
a2612 12
	/*
	 * The firmware status (except for the SenseValid bit) indicates
	 * why this ATIO was sent to us.
	 * If SenseValid is set, the firware has recommended Sense Data.
	 */
	switch (status & ~TGTSVALID) {
	case AT_PATH_INVALID:
		/*
		 * ATIO rejected by the firmware due to disabled lun.
		 */
		PRINTF("%s: Firmware rejected ATIO2 for disabled lun %d\n",
		    isp->isp_name, aep->at_lun);
d2615 5
a2619 8
	case AT_NOCAP:
		/*
		 * Requested Capability not available
		 * We sent an ATIO that overflowed the firmware's
		 * command resource count.
		 */
		PRINTF("%s: Firmware rejected ATIO2, command count overflow\n",
		    isp->isp_name);
d2622 2
a2623 1
	case AT_BDR_MSG:
d2625 4
a2628 24
		 * If we send an ATIO to the firmware to increment
		 * its command resource count, and the firmware is
		 * recovering from a Bus Device Reset, it returns
		 * the ATIO with this status.
		 */
		PRINTF("%s: ATIO2 returned with BDR rcvd\n", isp->isp_name);
		break;

	case AT_CDB:
		/*
		 * New CDB
		 */
		cdp->cd_hba = isp;
		cdp->cd_iid = aep->at_iid;
		cdp->cd_tgt = 0;
		cdp->cd_lun = aep->at_lun;
		MEMCPY(cdp->cd_cdb, aep->at_cdb, 16);
		cdp->cd_rxid = aep->at_rxid;
		cdp->cp_origdlen = aep->at_datalen;
		cdp->cp_totbytes = 0;
		PRINTF("%s: CDB 0x%x rx_id 0x%x itl %d/%d/%d dlen %d\n",
		    isp->isp_name, cdp->cd_cdb[0], cdp->cd_tagval, cdp->cd_iid,
		    cdp->cd_tgt, cdp->cd_lun, aep->at_datalen);
		(*isp->isp_tmd_newcmd)(isp, cdp);
d2632 1
a2632 8
		PRINTF("%s: Unknown status (0x%x) in ATIO2\n",
		    isp->isp_name, status);
		cdp->cd_hba = isp;
		cdp->cd_iid = aep->at_iid;
		cdp->cd_tgt = aep->at_tgt;
		cdp->cd_lun = aep->at_lun;
		cdp->cp_rxid = aep->at_rxid;
		isp_tgtcmd_done(cdp);
d2635 1
d2638 5
a2642 6
static void
isp_handle_ctio(isp, cep)
	struct ispsoftc *isp;
	ct_entry_t *aep;
{
}
d2644 2
a2645 2
static void
isp_handle_ctio2(isp, cep)
d2647 2
a2648 1
	at2_entry_t *aep;
d2650 22
a2672 1
#endif
d2710 4
a2713 1
		isp->isp_sendmarker = 1;
d2720 4
a2723 1
		isp->isp_sendmarker = 1;
d2734 1
a2734 1
		if (isp->isp_type & ISP_HA_FC) {
d2809 1
a2809 1
		if (isp->isp_type & ISP_HA_FC) {
d2839 1
a2839 1
		PRINTF("%s: internal queues full for target %d lun %d "
d2841 1
a2841 1
		    XS_STS(xs));
d2867 1
a2867 1
		if (isp->isp_type & ISP_HA_SCSI) {
d2869 1
a2869 1
			isp->isp_update = 1;
d2872 1
d2880 1
a2880 1
		if (isp->isp_type & ISP_HA_SCSI) {
d2882 1
a2882 1
			isp->isp_update = 1;
d2885 1
d2907 2
a2908 2
		PRINTF("%s: port logout for target %d\n",
			isp->isp_name, XS_TGT(xs));
d2934 1
a2934 1
	int fph;
d2938 1
a2938 1
	if (fph < 1)
d2940 2
a2941 2
	xs = (ISP_SCSI_XFER_T *) isp->isp_xflist[fph - 1];
	isp->isp_xflist[fph - 1] = NULL;
d2943 2
a2944 2
		PRINTF("%s: fast posting handle 0x%x not found\n",
		    isp->isp_name, fph - 1);
d2947 2
d2957 1
a2957 1
		ISP_DMAFREE(isp, xs, fph - 1);
d2960 2
d2976 1
a2976 1
	MAKNIB(1, 3),	/* 0x08: MBOX_ABOUT_FIRMWARE */
d3000 2
a3001 2
	MAKNIB(1, 3),	/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */
	MAKNIB(1, 2),	/* 0x21: MBOX_GET_SELECT_TIMEOUT */
d3010 1
a3010 1
	MAKNIB(0, 0),	/* 0x2a: */
d3017 1
a3017 1
	MAKNIB(2, 2),	/* 0x31: MBOX_SET_SELECT_TIMEOUT */
d3021 1
a3021 1
	MAKNIB(2, 2),	/* 0x35: MBOX_SET_ACTIVE_NEG_STATE */
d3026 1
a3026 1
	MAKNIB(0, 0),	/* 0x3a: */
d3065 1
a3065 1
	MAKNIB(0, 0),	/* 0x60: MBOX_GET_INIT_CONTROL_BLOCK  (FORMAT?) */
d3078 4
a3081 4
	MAKNIB(0, 0),	/* 0x6e: */
	MAKNIB(0, 0),	/* 0x6f: */
	MAKNIB(0, 0),	/* 0x70: */
	MAKNIB(0, 0),	/* 0x71: */
d3120 1
a3120 1
	if (isp->isp_type & ISP_HA_FC) {
d3133 3
d3150 8
a3157 2
	 * Make sure we can send some words. Check to see id there's
	 * an async mbox event pending.
a3161 1
		SYS_DELAY(100);
d3170 2
d3188 3
a3190 1
			if (mbox == MBOX_COMMAND_COMPLETE) {
d3197 1
d3211 5
a3215 3
	 * If we're a 1080 or a 1240, make sure that for a couple of commands
	 * the port parameter is set. This is sort of a temporary solution
	 * to do it here rather than every place a mailbox command is formed.
d3217 15
a3231 6
	if (IS_1080(isp) || IS_12X0(isp)) {
		switch (mbp->param[0]) {
		case MBOX_BUS_RESET:
			mbp->param[2] = isp->isp_port;
			break;
		default:
a3235 3
	/*
	 * Write input parameters.
	 */
a3267 1
	ENABLE_INTS(isp);
d3339 2
a3340 1
	 * Pick up output parameters.
d3342 20
d3402 3
a3404 2
		PRINTF("%s: mbox cmd %x failed with COMMAND_ERROR\n",
		    isp->isp_name, opcode);
d3421 3
d3426 2
d3429 4
d3435 3
a3439 3
	case ASYNC_PDB_CHANGED:
		isp_mark_getpdb_all(isp);
		break;
d3475 1
a3475 1
	mbs.param[1] = (XS_TGT(xs) << 8) | XS_LUN(xs);
d3497 1
a3497 1
	if (isp->isp_type & ISP_HA_SCSI)
d3506 1
a3506 1
	if (isp->isp_type & ISP_HA_SCSI) {
a3527 21
isp_dumpxflist(isp)
	struct ispsoftc *isp;
{
	volatile ISP_SCSI_XFER_T *xs;
	int i, hdp;

	for (hdp = i = 0; i < RQUEST_QUEUE_LEN; i++) {
		xs = isp->isp_xflist[i];
		if (xs == NULL) {
			continue;
		}
		if (hdp == 0) {
			PRINTF("%s: active requests\n", isp->isp_name);
			hdp++;
		}
		PRINTF(" Active Handle %d: tgt %d lun %d dlen %d\n",
		    i+1, XS_TGT(xs), XS_LUN(xs), XS_XFRLEN(xs));
	}
}

static void
d3532 1
a3532 1
	if (isp->isp_type & ISP_HA_FC) {
d3539 2
d3543 6
a3548 2
				isp_mark_getpdb_all(isp);
				/* FALL THROUGH */
d3550 2
d3553 7
d3561 3
a3563 1
			case ASYNC_LOOP_RESET:
d3565 1
a3565 1
				if (once++ < 2) {
d3570 2
a3571 1
			isp_dumpregs(isp, "GET FIRMWARE STATE failed");
d3582 15
d3601 1
a3601 3
	isp->isp_update = 0;

	if (isp->isp_type & ISP_HA_FC) {
d3606 2
d3609 1
a3609 1
		u_int16_t flags, period, offset, changed;
d3613 2
d3627 7
d3652 5
d3665 1
a3665 1
		mbs.param[1] = tgt << 8;
a3672 1

d3674 1
a3674 4
			/*
			 * XXX: Need a SYNC_TARGET for efficiency...
			 */
			isp->isp_sendmarker = 1;
a3679 10
		if (sdp->isp_devparam[tgt].cur_dflags != flags ||
		    sdp->isp_devparam[tgt].cur_period != period ||
		    sdp->isp_devparam[tgt].cur_offset != offset) {
			IDPRINTF(3, ("%s: tgt %d flags 0x%x period %d "
			    "off %d\n", isp->isp_name, tgt, flags,
			    period, offset));
			changed = 1;
		} else {
			changed = 0;
		}
d3683 2
a3684 6
		if (sdp->isp_devparam[tgt].dev_announced == 0 || changed) {
			if (isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &tgt))
				sdp->isp_devparam[tgt].dev_announced = 0;
			else
				sdp->isp_devparam[tgt].dev_announced = 1;
		}
d3689 1
a3689 1
isp_setdfltparm(isp)
d3691 1
d3695 33
a3727 1
	sdparam *sdp;
d3732 1
a3732 2
	if (isp->isp_gotdparms) {
		IDPRINTF(3, ("%s: already have dparms\n", isp->isp_name));
d3735 1
a3735 1
	isp->isp_gotdparms = 1;
a3742 1

a3747 16
	if (IS_FC(isp)) {
		fcparam *fcp = (fcparam *) isp->isp_param;
		fcp->isp_maxfrmlen = ICB_DFLT_FRMLEN;
		fcp->isp_maxalloc = 256;
		fcp->isp_execthrottle = 16;
		fcp->isp_retry_delay = 5;
		fcp->isp_retry_count = 0;
		/*
		 * It would be nice to fake up a WWN in case we don't
		 * get one out of NVRAM. Solaris does this for SOCAL
		 * cards that don't have SBus properties- it sets up
		 * a WWN based upon the system MAC Address.
		 */
		fcp->isp_wwn = 0;
		return;
	}
d3749 3
a3751 1
	sdp = (sdparam *) isp->isp_param;
d3756 6
a3761 2
		sdp->isp_req_ack_active_neg = 1;
		sdp->isp_data_line_active_neg = 1;
d3763 8
a3770 2
		sdp->isp_req_ack_active_neg = (mbs.param[1] >> 4) & 0x1;
		sdp->isp_data_line_active_neg = (mbs.param[1] >> 5) & 0x1;
d3785 1
a3785 1
		    (sdp->isp_clock && sdp->isp_clock < 60)) {
d3838 1
a3838 1
		if (((sdp->isp_clock && sdp->isp_clock < 60) ||
d3850 1
a3850 1
	 * Set Default Host Adapter Parameters
d3856 1
d3863 1
a3863 1
	sdp->isp_max_queue_depth = 128;
d3866 2
a3867 2
	sdp->isp_retry_count = 0;
	sdp->isp_retry_delay = 1;
d3877 2
a3878 1
 * with a 'botched' notice.
d3887 2
a3888 2
	ISP_SCSI_XFER_T *tlist[RQUEST_QUEUE_LEN], *xs;
	int i;
d3890 3
a3892 4
	for (i = 0; i < RQUEST_QUEUE_LEN; i++) {
		tlist[i] = (ISP_SCSI_XFER_T *) isp->isp_xflist[i];
		isp->isp_xflist[i] = NULL;
	}
d3903 1
d3905 3
a3907 3
	for (i = 0; i < RQUEST_QUEUE_LEN; i++) {
		xs = tlist[i];
		if (XS_NULL(xs)) {
d3910 7
a3916 3
		if (isp->isp_nactive > 0)
		    isp->isp_nactive--;
		XS_RESID(xs) = XS_XFRLEN(xs);
d3930 2
d3944 3
d3962 3
a3964 1
			PRINTF("%s: invalid NVRAM header\n", isp->isp_name);
d3984 118
a4101 1
	if (isp->isp_type & ISP_HA_SCSI) {
d4154 1
a4154 1
		sdp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);
a4155 2
			static char *true = "true";
			static char *false = "false";
d4174 1
a4174 1
			    sdp->isp_req_ack_active_neg? true : false);
d4176 1
a4176 1
			    sdp->isp_data_line_active_neg? true : false);
d4178 1
a4178 1
			    sdp->isp_data_dma_burst_enabl? true : false);
d4180 1
a4180 1
			    sdp->isp_cmd_dma_burst_enable? true : false);
d4182 1
a4182 1
			    sdp->isp_fast_mttr? true : false);
d4256 1
a4256 1
			} wds;
d4261 26
a4286 3
		PRINTF("%s: Adapter WWN 0x%08x%08x\n", isp->isp_name,
		    wwnstore.wds.hi32, wwnstore.wds.lo32);
		fcp->isp_wwn = wwnstore.full64;
d4290 1
a4290 2
			    isp->isp_name, wwnstore.wds.hi32,
			    wwnstore.wds.lo32);
d4343 1
a4343 1
	if (isp->isp_type & ISP_HA_FC) {
d4345 4
@


1.6
log
@roll internal revision levels and enable 1080 support
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp.c,v 1.5 1999/03/17 12:54:31 mjacob Exp $ */
d746 1
a746 1
		 * cur_dflags.
d762 8
@


1.5
log
@fix OpenBSD headers
@
text
@d1 2
a2 2
/* 	$OpenBSD: isp.c,v 1.4 1999/03/17 05:26:08 mjacob Exp $ */
/* release_03_16_99 */
a6 1
 *---------------------------------------
a9 1
 *---------------------------------------
d114 1
a114 1
static int isp_fclink_test __P((struct ispsoftc *));
d190 1
d193 24
a216 3
		sdp->isp_clock = 0;	/* don't set clock */
		sdp->isp_diffmode = 1;
		sdp->isp_ultramode = 1;
d226 1
a226 1
			revname = "1020";	
d236 1
a236 1
			revname = "1020A";	
d280 1
a280 1
                } else {
d330 1
a330 1
		      DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);
d332 1
a332 1
		      DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);
d409 1
a409 1
                	while(ISP_READ(isp, RISC_MTR) != 0x1313) {
d413 1
a413 1
                } else {
d573 1
a573 1
	if (isp->isp_type & ISP_HA_FC) {
d613 1
a613 1
		
a715 5
		 *
		 * Otherwise, a SCSI bus reset issued below will force
		 * the back to the narrow, async state (but see note
		 * below also). Technically we should also do without
		 * Parity.
a719 1

d723 3
a725 1
		mbs.param[3] = 0;
d732 3
a734 1
			mbs.param[3] = 0;
d742 20
a761 2
		sdp->isp_devparam[tgt].cur_dflags = sdf;

d809 1
a809 1
	 *  Turn on Fast Posting
d811 3
d815 12
a826 7
	if (isp->isp_fwrev >= ISP_FW_REV(7, 55)) {
		mbs.param[0] = MBOX_SET_FW_FEATURES;
		mbs.param[1] = FW_FEATURE_FAST_POST;
		isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			PRINTF("%s: unable to enable FAST Posting\n",
			    isp->isp_name);
a828 1
#endif
d834 1
a834 1
	/*	
d990 2
a1022 1
#ifdef	GETPDB_WORKING_YET
a1024 16

	/*
	 * Get Port Queue Parameters first- this is
	 * a Q&D way to see whether we're logged into
	 * this port.
	 */
	mbs.param[0] = MBOX_GET_DEV_QUEUE_PARAMS;
	mbs.param[1] = id << 8;
	mbs.param[2] = 0;
#ifdef	ISP2100_SCCLUN
	mbs.param[3] = 0;
#endif
	isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE)
		return (-1);

d1029 7
a1035 2
	mbs.param[4] = 0;
	mbs.param[5] = 0;
d1050 1
a1050 1
		   isp->isp_name));
a1056 3
#else
	pdbp->pdb_options = 1;
#endif
d1065 1
a1065 1
isp_fclink_test(isp)
d1067 1
a1077 1
	 * This is a platform specific 
d1080 1
a1080 1
	for (count = 0; count < FC_FW_READY_DELAY; count += 100) {
d1100 1
d1107 1
a1107 1
		PRINTF("%s: GET LOOP ID failed\n", isp->isp_name); 
d1148 1
a1148 1
	 * to the whole Queue Entry for the command,...
d1171 1
a1171 1
			if (isp_fclink_test(isp)) {
d1177 1
a1177 3
		 * Here's the spot we would need to find out whether
		 * the port names have changed, whether it's still
		 * a target role, etc..
d1180 1
a1180 10
			/*
			 * If we don't know what it is- don't talk to it.
			 * This also handles cases where it's not logged
			 * into this port/target.
			 */
			if (isp_getpdb(isp, XS_TGT(xs), pdbp)) {
				XS_SETERR(xs, HBA_SELTIMEOUT);
				return (CMD_COMPLETE);
#ifdef	GETPDB_WORKING_YET
			} else {
a1182 1
#endif
d1264 1
d1275 1
a1275 1
 			t2reqp->req_flags = REQFLAG_STAG; 
d1388 1
a1388 1
        case ISPCTL_RESET_DEV:
d1402 1
a1402 1
        case ISPCTL_ABORT_CMD:
d1441 1
a1441 1
		return(0);
d1444 1
a1444 1
		return (isp_fclink_test(isp));
d1471 1
a1471 1
					     isp->isp_name, isr));
d1479 1
a1479 1
					     isp->isp_name, isr));
d1488 2
a1489 4
			if (mbox != MBOX_COMMAND_COMPLETE) {
				PRINTF("%s: isp_intr sees 0x%x\n",
				    isp->isp_name,mbox);
			}
d1497 1
a1497 2
				xs = (ISP_SCSI_XFER_T *)
				    isp->isp_xflist[fhandle - 1];
d1511 1
a1511 1
				complist[ndone++] = xs;	
d1585 1
a1585 1
		xs = (ISP_SCSI_XFER_T *) isp->isp_xflist[sp->req_handle - 1];
d1694 1
a1694 1
	 	isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);
d1785 31
a1815 2
		PRINTF("%s: LBD->HVD Transition 0x%x\n",
		    isp->isp_name, ISP_READ(isp, OUTMAILBOX1));
d1888 1
a1888 1
		void            *voidp;
d1949 3
a1951 3
                        PRINTF("%s: Firmware out of ATIOs\n", isp->isp_name);
                        break;
                case IN_ABORT_TASK:
d1954 2
a1955 2
                        break;
                case IN_PORT_LOGOUT:
d1958 2
a1959 2
                        break;
                default:
d1961 2
a1962 2
                            isp->isp_name, status);
                        break;
d2050 1
a2050 1
				s = sizeof(tgtiqd);
d2122 1
a2122 1
	 	 * Return the ATIO to the board.
d2323 1
a2323 1
	switch(status & ~TGTSVALID) {
d2422 1
a2422 1
	switch(status & ~TGTSVALID) {
d2740 1
a2740 1
		       sp->req_completion_status);
d2777 1
a2777 1
#define MAKNIB(a, b)			(((a) << 4) | (b))
d2803 1
a2803 1
	MAKNIB(2, 2),	/* 0x18: MBOX_BUS_RESET */
a2951 2
#define	NEW_MB_WAY	1
#ifdef	NEW_MB_WAY
a2955 2
#endif

d3009 15
d3029 12
a3040 2
	case 6: ISP_WRITE(isp, INMAILBOX5, mbp->param[5]); mbp->param[5] = 0;
	case 5: ISP_WRITE(isp, INMAILBOX4, mbp->param[4]); mbp->param[4] = 0;
a3063 34
#ifndef	NEW_MB_WAY
	/*
	 * Wait until RISC int is set, except 2100
	 */
	if ((isp->isp_type & ISP_HA_FC) == 0) {
		loops = MBOX_DELAY_COUNT;
		while ((ISP_READ(isp, BIU_ISR) & BIU_ISR_RISC_INT) == 0) {
			SYS_DELAY(100);
			if (--loops < 0) {
				PRINTF("%s: isp_mboxcmd timeout #2\n",
				    isp->isp_name);
				return;
			}
		}
	}

	/*
	 * Check to make sure that the semaphore has been set.
	 */
	loops = MBOX_DELAY_COUNT;
	while ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {
		SYS_DELAY(100);
		/*
		 * Wierd- I've seen the case where the semaphore register
		 * isn't getting set- sort of a violation of the protocol..
		 */
		if (ISP_READ(isp, OUTMAILBOX0) & 0x4000)
			break;
		if (--loops < 0) {
			PRINTF("%s: isp_mboxcmd timeout #3\n", isp->isp_name);
			return;
		}
	}
#else
a3094 1
#endif
d3156 1
a3156 1
	switch(mbp->param[0]) {
d3229 1
a3229 1
		       isp->isp_name, mbs.param[1]);
d3262 1
a3262 1
	       ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));
d3364 6
d3377 14
a3390 2
			sdp->isp_devparam[tgt].dev_refresh = 1;
			isp->isp_update = 1;
a3412 2
			sdp->isp_devparam[tgt].cur_dflags =
			    sdp->isp_devparam[tgt].dev_flags;
d3419 2
a3420 2
		    sdp->isp_devparam[tgt].sync_period != period ||
		    sdp->isp_devparam[tgt].sync_offset != offset) {
a3427 1

d3429 2
a3430 3
		sdp->isp_devparam[tgt].dev_flags = flags;
		sdp->isp_devparam[tgt].sync_period = period;
		sdp->isp_devparam[tgt].sync_offset = offset;
d3444 1
a3444 1
	int i;
d3457 11
a3467 3
	if ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0 &&
	    (isp_read_nvram(isp) == 0)) {
		return;
d3498 11
a3508 3
	for (i = 0; i < MAX_TARGETS; i++) {
		sdp->isp_devparam[i].dev_flags = DPARM_DEFAULT;
		sdp->isp_devparam[i].cur_dflags = DPARM_SAFE_DFLT;
d3511 1
a3511 1
			sdp->isp_devparam[i].sync_offset =
d3513 1
a3513 1
			sdp->isp_devparam[i].sync_period =
d3515 5
d3521 1
a3521 1
			sdp->isp_devparam[i].sync_offset =
d3523 1
a3523 1
			sdp->isp_devparam[i].sync_period =
d3531 1
a3531 1
		if (isp->isp_confopts & ISP_CFG_NONVRAM)
d3533 1
d3536 1
a3536 1
		mbs.param[1] = i << 8;
d3541 5
a3545 1
		sdp->isp_devparam[i].dev_flags = mbs.param[2];
d3551 1
a3551 4
		 * boot device's parameters.
		 *
		 * XXX: Hmm- this may be based on a different
		 * XXX: clock rate.
d3554 4
a3557 2
			sdp->isp_devparam[i].sync_period = mbs.param[3] & 0xff;
			sdp->isp_devparam[i].sync_offset = mbs.param[3] >> 8; 
d3565 1
a3565 1
		    (sdp->isp_devparam[i].sync_period ==
d3567 1
a3567 1
			sdp->isp_devparam[i].sync_offset =
d3569 1
a3569 1
			sdp->isp_devparam[i].sync_period =
d3593 3
a3595 3
	for (i = 0; i < MAX_TARGETS; i++) {
		sdp->isp_devparam[i].exc_throttle = 16;
		sdp->isp_devparam[i].dev_enable = 1;
d3599 1
a3599 1
/* 
d3727 1
a3727 1
		
d3831 1
@


1.4
log
@complete update of ISP driver- includes 2100 FC support
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
@


1.3
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 2
a2 2
/*	$NetBSD: isp.c,v 1.7 1997/06/08 06:31:52 thorpej Exp $	*/

d4 1
a4 1
 * Machine Independent (well, as best as possible)
d7 3
a9 4
 * Specific probe attach and support routines for Qlogic ISP SCSI adapters.
 *
 * Copyright (c) 1997 by Matthew Jacob
 * NASA AMES Research Center.
d11 1
d40 2
a41 1
 * (qlogicisp.c) and Dave Miller's SBus version of same (qlogicisp.c)
d44 3
a46 27
#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>  
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h> 
#include <sys/proc.h>
#include <sys/user.h>


#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <scsi/scsi_message.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>

#include <vm/vm.h>
#include <vm/vm_param.h>
#include <vm/pmap.h>

#include <dev/ic/ispreg.h>
#include <dev/ic/ispvar.h>
#include <dev/ic/ispmbox.h>
d48 12
a59 1
#define	MBOX_DELAY_COUNT	1000000 / 100
d61 3
a63 3
struct cfdriver isp_cd = {
	NULL, "isp", DV_DULL
};
d65 1
a65 3
static void	ispminphys __P((struct buf *));
static int32_t	ispscsicmd __P((struct scsi_xfer *xs));
static int	isp_mboxcmd __P((struct ispsoftc *, mbreg_t *));
d67 25
a91 2
static struct scsi_adapter isp_switch = {
	ispscsicmd, ispminphys, 0, 0
d93 1
a94 1
static struct scsi_device isp_dev = { NULL, NULL, NULL, NULL };
d96 30
a125 3
static int isp_poll __P((struct ispsoftc *, struct scsi_xfer *, int));	
static int isp_parse_status __P((struct ispsoftc *, ispstatusreq_t *));
static void isp_lostcmd __P((struct ispsoftc *, struct scsi_xfer *));
d130 3
a132 1
 * Only looks at sc_dev.dv_xname, sc_iot and sc_ioh fields.
d139 2
a140 2
	int loops, i;
	u_int8_t clock;
d143 8
d152 2
a153 1
	 * Do MD specific pre initialization
a154 1
	ISP_RESET0(isp);
d157 6
a162 3
	 * Try and get old clock rate out before we hit the
	 * chip over the head- but if and only if we don't
	 * know our desired clock rate.
d164 13
a176 7
	clock = isp->isp_mdvec->dv_clock;
	if (clock == 0) {
		mbs.param[0] = MBOX_GET_CLOCK_RATE;
		(void) isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] == MBOX_COMMAND_COMPLETE) {
			clock = mbs.param[1];
			printf("board-clock 0x%x ", clock);
d178 2
a179 1
			clock = 0;
d181 1
d185 1
a185 1
	 * Hit the chip over the head with hammer.
d187 91
a278 1
	ISP_WRITE(isp, BIU_ICR, BIU_ICR_SOFT_RESET);
d280 1
a280 1
	 * Give the ISP a chance to recover...
d282 3
a284 1
	delay(100);
d287 2
a288 1
	 * Clear data && control DMA engines.
d290 20
a309 1
	ISP_WRITE(isp, CDMA_CONTROL,
d311 1
a311 1
	ISP_WRITE(isp, DDMA_CONTROL,
d313 20
d337 9
a345 2
	while ((ISP_READ(isp, BIU_ICR) & BIU_ICR_SOFT_RESET) != 0) {
		delay(100);
d347 1
a347 1
			printf("chip reset timed out\n", isp->isp_name);
d351 1
d353 2
a354 1
	 * More initialization
d357 9
a365 1
	ISP_WRITE(isp, BIU_CONF1, 0);
d367 1
a367 1
	delay(100);
d369 15
a383 3
	if (isp->isp_mdvec->dv_conf1) {
		ISP_SETBITS(isp, BIU_CONF1, isp->isp_mdvec->dv_conf1);
		if (isp->isp_mdvec->dv_conf1 & BIU_BURST_ENABLE) {
d387 16
d404 1
a404 1
		ISP_WRITE(isp, BIU_CONF1, 0);
a406 3
#if	0
	ISP_WRITE(isp, RISC_MTR, 0x1212);	/* FM */
#endif
d417 20
a436 2
	ISP_WRITE(isp, BIU_ICR,
		  BIU_ICR_ENABLE_RISC_INT | BIU_ICR_ENABLE_ALL_INTS);
a440 1

d442 1
a442 1
	(void) isp_mboxcmd(isp, &mbs);
d444 1
a444 1
		printf("NOP test failed\n");
d448 20
a467 39
	mbs.param[0] = MBOX_MAILBOX_REG_TEST;
	mbs.param[1] = 0xdead;
	mbs.param[2] = 0xbeef;
	mbs.param[3] = 0xffff;
	mbs.param[4] = 0x1111;
	mbs.param[5] = 0xa5a5;
	(void) isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		printf("Mailbox Register test didn't complete\n");
		return;
	}
	i = 0;
	if (mbs.param[1] != 0xdead) {
		printf("Register Test Failed @@reg %d (got %x)\n",
			1, mbs.param[1]);
		i++;
	}
	if (mbs.param[2] != 0xbeef) {
		printf("Register Test Failed @@reg %d (got %x)\n",
			2, mbs.param[2]);
		i++;
	}
	if (mbs.param[3] != 0xffff) {
		printf("Register Test Failed @@reg %d (got %x)\n",
			3, mbs.param[3]);
		i++;
	}
	if (mbs.param[4] != 0x1111) {
		printf("Register Test Failed @@reg %d (got %x)\n",
			4, mbs.param[4]);
		i++;
	}
	if (mbs.param[5] != 0xa5a5) {
		printf("Register Test Failed @@reg %d (got %x)\n",
			5, mbs.param[5]);
		i++;
	}
	if (i) {
		return;
d471 33
a503 7
	 * Download new Firmware
	 */
	for (i = 0; i < isp->isp_mdvec->dv_fwlen; i++) {
		mbs.param[0] = MBOX_WRITE_RAM_WORD;
		mbs.param[1] = isp->isp_mdvec->dv_codeorg + i;
		mbs.param[2] = isp->isp_mdvec->dv_ispfw[i];
		(void) isp_mboxcmd(isp, &mbs);
d505 1
a505 1
			printf("f/w download failed\n");
d508 2
d513 4
a516 12
	 * Verify that it downloaded correctly.
	 */
	mbs.param[0] = MBOX_VERIFY_CHECKSUM;
	mbs.param[1] = isp->isp_mdvec->dv_codeorg;
	(void) isp_mboxcmd(isp, &mbs);
	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
		printf("ram checksum failure\n");
		return;
	}

	/*
	 * Now start it rolling...
d520 5
a524 2
	mbs.param[1] = isp->isp_mdvec->dv_codeorg;
	(void) isp_mboxcmd(isp, &mbs);
d526 16
a541 10
	/*
	 * Set CLOCK RATE
	 */
	if (clock) {
		mbs.param[0] = MBOX_SET_CLOCK_RATE;
		mbs.param[1] = clock;
		(void) isp_mboxcmd(isp, &mbs);
		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
			printf("failed to set CLOCKRATE\n");
			return;
d545 1
a545 1
	(void) isp_mboxcmd(isp, &mbs);
d547 1
a547 1
		printf("ABOUT FIRMWARE command failed\n");
d550 14
a563 1
	printf("F/W rev %d.%d ", mbs.param[1], mbs.param[2]);
d568 3
a570 1
 * Initialize Hardware to known state
d572 1
d577 1
d579 1
a579 1
	int s, i, l;
d582 1
a582 2
	 * Set Default Host Adapter Parameters
	 * XXX: Should try and get them out of NVRAM
d584 1
d586 15
a600 20
	isp->isp_adapter_enabled = 1;
	isp->isp_req_ack_active_neg = 1;
	isp->isp_data_line_active_neg = 1;
	isp->isp_cmd_dma_burst_enable = 1;
	isp->isp_data_dma_burst_enabl = 1;
	isp->isp_fifo_threshold = 2;
	isp->isp_initiator_id = 7;
	isp->isp_async_data_setup = 6;
	isp->isp_selection_timeout = 250;
	isp->isp_max_queue_depth = 256;
	isp->isp_tag_aging = 8;
	isp->isp_bus_reset_delay = 3;
	isp->isp_retry_count = 0;
	isp->isp_retry_delay = 1;
	for (i = 0; i < MAX_TARGETS; i++) {
		isp->isp_devparam[i].dev_flags = DPARM_DEFAULT;
		isp->isp_devparam[i].exc_throttle = 16;
		isp->isp_devparam[i].sync_period = 25;
		isp->isp_devparam[i].sync_offset = 12;
		isp->isp_devparam[i].dev_enable = 1;
d602 1
d604 6
d611 3
a613 2
	s = splbio();

d615 2
a616 2
	mbs.param[1] = isp->isp_initiator_id;
	(void) isp_mboxcmd(isp, &mbs);
d618 1
a618 2
		(void) splx(s);
		printf("%s: failed to set initiator id\n", isp->isp_name);
d622 3
d626 3
a628 3
	mbs.param[1] = isp->isp_retry_count;
	mbs.param[2] = isp->isp_retry_delay;
	(void) isp_mboxcmd(isp, &mbs);
d630 1
a630 3
		(void) splx(s);
		printf("%s: failed to set retry count and delay\n",
		       isp->isp_name);
d634 3
d638 2
a639 2
	mbs.param[1] = isp->isp_async_data_setup;
	(void) isp_mboxcmd(isp, &mbs);
d641 1
a641 3
		(void) splx(s);
		printf("%s: failed to set async data setup time\n",
		       isp->isp_name);
d645 3
d650 3
a652 3
		(isp->isp_req_ack_active_neg << 4) |
		(isp->isp_data_line_active_neg << 5);
	(void) isp_mboxcmd(isp, &mbs);
d654 1
a654 3
		(void) splx(s);
		printf("%s: failed to set active negation state\n",
		       isp->isp_name);
d658 3
d663 2
a664 2
	mbs.param[1] = isp->isp_tag_aging;
	(void) isp_mboxcmd(isp, &mbs);
d666 1
a666 2
		(void) splx(s);
		printf("%s: failed to set tag age limit\n", isp->isp_name);
d670 4
d675 2
a676 2
	mbs.param[1] = isp->isp_selection_timeout;
	(void) isp_mboxcmd(isp, &mbs);
d678 1
a678 2
		(void) splx(s);
		printf("%s: failed to set selection timeout\n", isp->isp_name);
d682 8
a689 2
	for (i = 0; i < MAX_TARGETS; i++) {
		if (isp->isp_devparam[i].dev_enable == 0)
d692 14
d707 4
a710 6
		mbs.param[1] = i << 8;
		mbs.param[2] = isp->isp_devparam[i].dev_flags << 8;
		mbs.param[3] =
			(isp->isp_devparam[i].sync_offset << 8) |
			(isp->isp_devparam[i].sync_period);
		(void) isp_mboxcmd(isp, &mbs);
d712 11
a722 4
			(void) splx(s);
			printf("%s: failed to set target parameters\n",
			       isp->isp_name);
			return;
d724 1
d726 2
a727 1
		for (l = 0; l < MAX_LUNS; l++) {
d729 4
a732 4
			mbs.param[1] = (i << 8) | l;
			mbs.param[2] = isp->isp_max_queue_depth;
			mbs.param[3] = isp->isp_devparam[i].exc_throttle;
			(void) isp_mboxcmd(isp, &mbs);
d734 4
a737 4
				(void) splx(s);
				printf("%s: failed to set device queue "
				       "parameters\n", isp->isp_name);
				return;
d740 4
a743 10
	}


	/*
	 * Set up DMA for the request and result mailboxes.
	 */
	if (ISP_MBOXDMASETUP(isp)) {
		(void) splx(s);
		printf("%s: can't setup DMA for mailboxes\n", isp->isp_name);
		return;
d752 1
a752 1
	(void) isp_mboxcmd(isp, &mbs);
d754 1
a754 2
		(void) splx(s);
		printf("%s: set of response queue failed\n", isp->isp_name);
d764 2
a765 1
	(void) isp_mboxcmd(isp, &mbs);
d767 1
a767 2
		(void) splx(s);
		printf("%s: set of request queue failed\n", isp->isp_name);
d770 16
a785 1
	isp->isp_reqidx = 0;
d787 4
d792 3
a794 6
	 * Unfortunately, this is the only way right now for
	 * forcing a sync renegotiation. If we boot off of
	 * an Alpha, it's put the chip in SYNC mode, but we
	 * haven't necessarily set up the parameters the
	 * same, so we'll have to yank the reset line to
	 * get everyone to renegotiate.
a795 2


d797 2
a798 2
	mbs.param[1] = 2;
	(void) isp_mboxcmd(isp, &mbs);
d800 1
a800 2
		(void) splx(s);
		printf("%s: SCSI bus reset failed\n", isp->isp_name);
d802 3
d806 1
a806 1
	(void) splx(s);
d811 3
a813 1
 * Complete attachment of Hardware, include subdevices.
d815 2
a816 2
void
isp_attach(isp)
d819 4
a822 10
	isp->isp_state = ISP_RUNSTATE;
	isp->isp_link.adapter_softc = isp;
	isp->isp_link.adapter_target = isp->isp_initiator_id;
	isp->isp_link.adapter = &isp_switch;
	isp->isp_link.device = &isp_dev;
	isp->isp_link.openings = RQUEST_QUEUE_LEN / (MAX_TARGETS - 1);
	isp->isp_link.adapter_buswidth = MAX_TARGETS;
	config_found((void *)isp, &isp->isp_link, scsiprint);
}

d824 1
a824 12
/*
 * Free any associated resources prior to decommissioning.
 */
void
isp_uninit(isp)
	struct ispsoftc *isp;
{
}

/*
 * minphys our xfers
 */
a825 4
static void
ispminphys(bp)
	struct buf *bp;
{
d827 12
a838 7
	 * XX: Only the 1020 has a 24 bit limit.
	 */
	if (bp->b_bcount >= (1 << 24)) {
		bp->b_bcount = (1 << 24) - 1;
	}
	minphys(bp);
}
d840 9
a848 11
/*
 * start an xfer
 */
static int32_t
ispscsicmd(xs)
	struct scsi_xfer *xs;
{
	struct ispsoftc *isp;
	u_int8_t iptr, optr;
	ispreq_t *req;
	int s, i;
d850 2
a851 1
	isp = xs->sc_link->adapter_softc;
d853 18
a870 2
	optr = ISP_READ(isp, OUTMAILBOX4);
	iptr = isp->isp_reqidx;
d872 309
a1180 2
	req = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);
	iptr = (iptr + 1) & (RQUEST_QUEUE_LEN - 1);
d1182 3
a1184 3
		printf("%s: Request Queue Overflow\n", isp->isp_name);
		xs->error = XS_DRIVER_STUFFUP;
		return (TRY_AGAIN_LATER);
a1186 1
	s = splbio();
d1188 2
a1189 1
		ipsmarkreq_t *marker = (ipsmarkreq_t *) req;
d1191 1
a1191 1
		bzero((void *) marker, sizeof (*marker));
d1196 5
a1200 1
		isp->isp_sendmarker = 0;
d1202 17
a1218 10
		if (((iptr + 1) & (RQUEST_QUEUE_LEN - 1)) == optr) {
			ISP_WRITE(isp, INMAILBOX4, iptr);
			isp->isp_reqidx = iptr;
			(void) splx(s);
			printf("%s: Request Queue Overflow+\n", isp->isp_name);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
		req = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);
		iptr = (iptr + 1) & (RQUEST_QUEUE_LEN - 1);
d1220 2
d1223 2
a1224 9

	bzero((void *) req, sizeof (*req));
	req->req_header.rqs_entry_count = 1;
	req->req_header.rqs_entry_type = RQSTYPE_REQUEST;
	req->req_header.rqs_flags = 0;
	req->req_header.rqs_seqno = isp->isp_seqno++;

	for (i = 0; i < RQUEST_QUEUE_LEN; i++) {
		if (isp->isp_xflist[i] == NULL)
d1227 4
a1230 3
	if (i == RQUEST_QUEUE_LEN) {
		panic("%s: ran out of xflist pointers", isp->isp_name);
		/* NOTREACHED */
d1232 6
a1237 2
		isp->isp_xflist[i] = xs;
		req->req_handle = i;
d1240 35
a1274 10
	req->req_flags = 0;
	req->req_lun_trn = xs->sc_link->lun;
	req->req_target = xs->sc_link->target;
	req->req_cdblen = xs->cmdlen;
	bcopy((void *)xs->cmd, req->req_cdb, xs->cmdlen);

#if	0
	printf("%s(%d.%d): START%d cmd 0x%x datalen %d\n", isp->isp_name,
		xs->sc_link->target, xs->sc_link->lun,
		req->req_header.rqs_seqno, *(u_char *) xs->cmd, xs->datalen);
a1276 13
	req->req_time = xs->timeout / 1000;
	req->req_seg_count = 0;
	if (ISP_DMASETUP(isp, xs, req, &iptr, optr)) {
		(void) splx(s);
		xs->error = XS_DRIVER_STUFFUP;
		return (COMPLETE);
	}
	xs->error = 0;
	ISP_WRITE(isp, INMAILBOX4, iptr);
	isp->isp_reqidx = iptr;
	(void) splx(s);
	if ((xs->flags & SCSI_POLL) == 0) {
		return (SUCCESSFULLY_QUEUED);
d1278 9
d1289 1
a1289 1
	 * If we can't use interrupts, poll on completion.
d1291 9
a1299 7
	if (isp_poll(isp, xs, xs->timeout)) {
#if 0
		/* XXX try to abort it, or whatever */
		if (isp_poll(isp, xs, xs->timeout) {
			/* XXX really nuke it */
		}
#endif
d1301 2
a1302 2
		 * If no other error occurred but we didn't finish,
		 * something bad happened.
d1304 1
a1304 4
		if ((xs->flags & ITSDONE) == 0 && xs->error == XS_NOERROR) {
			isp_lostcmd(isp, xs);
			xs->error = XS_DRIVER_STUFFUP;
		}
d1306 10
a1315 1
	return (COMPLETE);
d1319 2
a1320 1
 * Interrupt Service Routine(s)
d1324 1
a1324 1
isp_poll(isp, xs, mswait)
d1326 2
a1327 2
	struct scsi_xfer *xs;
	int mswait;
d1329 89
d1419 3
a1421 3
	while (mswait) {
		/* Try the interrupt handling routine */
		(void)isp_intr((void *)isp);
d1423 2
a1424 5
		/* See if the xs is now done */
		if (xs->flags & ITSDONE)
			return (0);
		delay(1000);		/* wait one millisecond */
		mswait--;
d1426 1
a1426 1
	return (1);
d1429 7
d1440 1
a1440 1
	struct scsi_xfer *xs;
d1442 3
a1444 1
	u_int16_t iptr, optr, isr;
d1447 49
a1495 4
	if (isr == 0 || (isr & BIU_ISR_RISC_INT) == 0) {
#if	0
		if (isr) {
			printf("%s: isp_intr isr=%x\n", isp->isp_name, isr);
a1496 2
#endif
		return (0);
d1498 1
a1501 3
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
	ISP_WRITE(isp, BIU_ICR,
		  BIU_ICR_ENABLE_RISC_INT | BIU_ICR_ENABLE_ALL_INTS);
d1503 3
a1505 20
	if (ISP_READ(isp, BIU_SEMA) & 1) {
		u_int16_t mbox0 = ISP_READ(isp, OUTMAILBOX0);
		switch (mbox0) {
		case ASYNC_BUS_RESET:
		case ASYNC_TIMEOUT_RESET:
			printf("%s: bus or timeout reset\n", isp->isp_name);
			isp->isp_sendmarker = 1;
			break;
		default:
			printf("%s: async %x\n", isp->isp_name, mbox0);
			break;
		}
		ISP_WRITE(isp, BIU_SEMA, 0);
#if	0
	} else {
		if (optr == iptr) {
			printf("why'd we interrupt? isr %x iptr %x optr %x\n",
				isr, optr, iptr);
		}
#endif
d1507 1
d1511 1
d1515 13
a1528 4
		optr = (optr + 1) & (RESULT_QUEUE_LEN-1);
		if (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {
			printf("%s: not RESPONSE in RESPONSE Queue (0x%x)\n",
				isp->isp_name, sp->req_header.rqs_entry_type);
d1533 3
d1544 1
a1544 1
			printf("%s: rqs_flags=%x\n", isp->isp_name,
d1546 15
d1562 2
a1563 2
		if (sp->req_handle >= RQUEST_QUEUE_LEN) {
			printf("%s: bad request handle %d\n", isp->isp_name,
d1568 1
a1568 1
		xs = (struct scsi_xfer *) isp->isp_xflist[sp->req_handle];
d1570 3
a1572 1
			printf("%s: NULL xs in xflist\n", isp->isp_name);
d1576 1
a1576 1
		isp->isp_xflist[sp->req_handle] = NULL;
d1581 29
a1609 1
			xs->error = XS_DRIVER_STUFFUP;
a1610 8
		if (sp->req_state_flags & RQSF_GOT_SENSE) {
			bcopy(sp->req_sense_data, &xs->sense,
				sizeof (xs->sense));
			xs->error = XS_SENSE;
		}
		xs->status = sp->req_scsi_status;
		if (xs->error == 0 && xs->status == SCSI_BUSY)
			xs->error = XS_BUSY;
d1613 7
a1619 2
			if (xs->error == 0)
				xs->error = isp_parse_status(isp, sp);
d1621 1
a1621 1
			printf("%s: unknown return %x\n", isp->isp_name,
d1623 13
a1635 2
			if (xs->error == 0)
				xs->error = XS_DRIVER_STUFFUP;
d1637 12
a1648 4
		xs->resid = sp->req_resid;
		xs->flags |= ITSDONE;
		if (xs->datalen) {
			ISP_DMAFREE(isp, xs, sp->req_handle);
d1650 11
a1660 9
#if	0
		printf("%s(%d.%d): FINISH%d cmd 0x%x resid %d STS %x",
			isp->isp_name, xs->sc_link->target, xs->sc_link->lun,
			sp->req_header.rqs_seqno, *(u_char *) xs->cmd,
			xs->resid, xs->status);
		if (sp->req_state_flags & RQSF_GOT_SENSE) {
			printf(" Skey: %x", xs->sense.flags);
			if (xs->error != XS_SENSE) {
				printf(" BUT NOT SET");
d1662 1
d1664 12
a1675 2
		printf(" xs->error %d\n", xs->error);
#endif
d1677 1
a1677 1
		scsi_done(xs);
d1680 6
d1694 1
a1694 1
isp_parse_status(isp, sp)
d1696 1
a1696 1
	ispstatusreq_t *sp;
d1698 11
a1708 3
	switch (sp->req_completion_status) {
	case RQCS_COMPLETE:
		return (XS_NOERROR);
d1710 752
d2464 4
a2467 1
			return (XS_SELTIMEOUT);
d2469 3
a2471 2
		printf("%s: incomplete, state %x\n",
			isp->isp_name, sp->req_state_flags);
d2473 11
a2483 4
	case RQCS_DATA_UNDERRUN:
		return (XS_NOERROR);
	case RQCS_TIMEOUT:
		return (XS_TIMEOUT);
d2485 2
a2486 1
		printf("%s: reset occurred\n", isp->isp_name);
d2488 3
a2490 1
		break;
d2492 2
a2493 1
		printf("%s: command aborted\n", isp->isp_name);
d2495 108
d2604 88
d2693 1
a2693 1
		printf("%s: comp status %x\n", isp->isp_name,
d2697 30
a2726 1
	return (XS_DRIVER_STUFFUP);
d2733 115
a2847 67
	MAKNIB(1, 1),	/* MBOX_NO_OP */
	MAKNIB(5, 5),	/* MBOX_LOAD_RAM */
	MAKNIB(2, 0),	/* MBOX_EXEC_FIRMWARE */
	MAKNIB(5, 5),	/* MBOX_DUMP_RAM */
	MAKNIB(3, 3),	/* MBOX_WRITE_RAM_WORD */
	MAKNIB(2, 3),	/* MBOX_READ_RAM_WORD */
	MAKNIB(6, 6),	/* MBOX_MAILBOX_REG_TEST */
	MAKNIB(2, 3),	/* MBOX_VERIFY_CHECKSUM	*/
	MAKNIB(1, 3),	/* MBOX_ABOUT_FIRMWARE */
	MAKNIB(0, 0),	/* 0x0009 */
	MAKNIB(0, 0),	/* 0x000a */
	MAKNIB(0, 0),	/* 0x000b */
	MAKNIB(0, 0),	/* 0x000c */
	MAKNIB(0, 0),	/* 0x000d */
	MAKNIB(1, 2),	/* MBOX_CHECK_FIRMWARE */
	MAKNIB(0, 0),	/* 0x000f */
	MAKNIB(5, 5),	/* MBOX_INIT_REQ_QUEUE */
	MAKNIB(6, 6),	/* MBOX_INIT_RES_QUEUE */
	MAKNIB(4, 4),	/* MBOX_EXECUTE_IOCB */
	MAKNIB(2, 2),	/* MBOX_WAKE_UP	*/
	MAKNIB(1, 6),	/* MBOX_STOP_FIRMWARE */
	MAKNIB(4, 4),	/* MBOX_ABORT */
	MAKNIB(2, 2),	/* MBOX_ABORT_DEVICE */
	MAKNIB(3, 3),	/* MBOX_ABORT_TARGET */
	MAKNIB(2, 2),	/* MBOX_BUS_RESET */
	MAKNIB(2, 3),	/* MBOX_STOP_QUEUE */
	MAKNIB(2, 3),	/* MBOX_START_QUEUE */
	MAKNIB(2, 3),	/* MBOX_SINGLE_STEP_QUEUE */
	MAKNIB(2, 3),	/* MBOX_ABORT_QUEUE */
	MAKNIB(2, 4),	/* MBOX_GET_DEV_QUEUE_STATUS */
	MAKNIB(0, 0),	/* 0x001e */
	MAKNIB(1, 3),	/* MBOX_GET_FIRMWARE_STATUS */
	MAKNIB(1, 2),	/* MBOX_GET_INIT_SCSI_ID */
	MAKNIB(1, 2),	/* MBOX_GET_SELECT_TIMEOUT */
	MAKNIB(1, 3),	/* MBOX_GET_RETRY_COUNT	*/
	MAKNIB(1, 2),	/* MBOX_GET_TAG_AGE_LIMIT */
	MAKNIB(1, 2),	/* MBOX_GET_CLOCK_RATE */
	MAKNIB(1, 2),	/* MBOX_GET_ACT_NEG_STATE */
	MAKNIB(1, 2),	/* MBOX_GET_ASYNC_DATA_SETUP_TIME */
	MAKNIB(1, 3),	/* MBOX_GET_PCI_PARAMS */
	MAKNIB(2, 4),	/* MBOX_GET_TARGET_PARAMS */
	MAKNIB(2, 4),	/* MBOX_GET_DEV_QUEUE_PARAMS */
	MAKNIB(0, 0),	/* 0x002a */
	MAKNIB(0, 0),	/* 0x002b */
	MAKNIB(0, 0),	/* 0x002c */
	MAKNIB(0, 0),	/* 0x002d */
	MAKNIB(0, 0),	/* 0x002e */
	MAKNIB(0, 0),	/* 0x002f */
	MAKNIB(2, 2),	/* MBOX_SET_INIT_SCSI_ID */
	MAKNIB(2, 2),	/* MBOX_SET_SELECT_TIMEOUT */
	MAKNIB(3, 3),	/* MBOX_SET_RETRY_COUNT	*/
	MAKNIB(2, 2),	/* MBOX_SET_TAG_AGE_LIMIT */
	MAKNIB(2, 2),	/* MBOX_SET_CLOCK_RATE */
	MAKNIB(2, 2),	/* MBOX_SET_ACTIVE_NEG_STATE */
	MAKNIB(2, 2),	/* MBOX_SET_ASYNC_DATA_SETUP_TIME */
	MAKNIB(3, 3),	/* MBOX_SET_PCI_CONTROL_PARAMS */
	MAKNIB(4, 4),	/* MBOX_SET_TARGET_PARAMS */
	MAKNIB(4, 4),	/* MBOX_SET_DEV_QUEUE_PARAMS */
	MAKNIB(0, 0),	/* 0x003a */
	MAKNIB(0, 0),	/* 0x003b */
	MAKNIB(0, 0),	/* 0x003c */
	MAKNIB(0, 0),	/* 0x003d */
	MAKNIB(0, 0),	/* 0x003e */
	MAKNIB(0, 0),	/* 0x003f */
	MAKNIB(1, 2),	/* MBOX_RETURN_BIOS_BLOCK_ADDR */
	MAKNIB(6, 1),	/* MBOX_WRITE_FOUR_RAM_WORDS */
	MAKNIB(2, 3)	/* MBOX_EXEC_BIOS_IOCB */
d2851 1
a2851 1
static int
d2857 2
a2858 1
	int loops;
d2860 8
a2867 3
	if (mbp->param[0] > NMBCOM) {
		printf("%s: bad command %x\n", isp->isp_name, mbp->param[0]);
		return (-1);
d2870 1
d2873 1
d2875 1
a2875 1
		printf("%s: no parameters for %x\n", isp->isp_name,
d2877 24
a2900 1
		return (-1);
d2902 3
d2906 2
d2909 9
a2917 1
	 * Make sure we can send some words..
d2922 32
a2953 1
		delay(100);
d2955 8
a2962 2
			printf("%s: isp_mboxcmd timeout #1\n", isp->isp_name);
			return (-1);
d2967 1
a2967 1
	 * Write input parameters
d2970 2
d2981 7
a2987 1
	 * Clear semaphore on mailbox registers
d2991 1
d2993 1
a2993 1
	 * Clear RISC int condition.
d2995 1
a2995 1
	ISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);
d2997 1
d2999 13
a3011 3
	 * Set Host Interrupt condition so that RISC will pick up mailbox regs.
	 */
	ISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);
d3014 1
a3014 1
	 * Wait until RISC int is set
d3017 21
a3037 2
	while ((ISP_READ(isp, BIU_ISR) & BIU_ISR_RISC_INT) != 0) {
		delay(100);
d3039 2
a3040 2
			printf("%s: isp_mboxcmd timeout #2\n", isp->isp_name);
			return (-1);
d3045 2
a3046 1
	 * Check to make sure that the semaphore has been set.
d3048 1
a3048 1
	loops = MBOX_DELAY_COUNT;
d3050 7
a3056 1
		delay(100);
d3058 2
a3059 2
			printf("%s: isp_mboxcmd timeout #3\n", isp->isp_name);
			return (-1);
d3062 1
d3068 25
a3092 5
	while (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {
		delay(100);
		if (--loops < 0) {
			printf("%s: isp_mboxcmd timeout #4\n", isp->isp_name);
			return (-1);
d3094 1
a3096 1

d3101 2
d3120 60
a3179 1
	return (0);
d3182 4
a3185 2
static void
isp_lostcmd(struct ispsoftc *isp, struct scsi_xfer *xs)
d3188 1
d3190 1
a3190 2
	(void) isp_mboxcmd(isp, &mbs);

d3192 1
a3192 1
		printf("%s: couldn't GET FIRMWARE STATUS\n", isp->isp_name);
d3195 5
a3199 3
	printf("%s: lost command, %d commands active of total %d\n",
	       isp->isp_name, mbs.param[1], mbs.param[2]);
	if (xs == NULL || xs->sc_link == NULL)
d3203 2
a3204 2
	mbs.param[1] = xs->sc_link->target << 8 | xs->sc_link->lun;
	(void) isp_mboxcmd(isp, &mbs);
d3206 223
a3428 1
		printf("%s: couldn't GET DEVICE STATUS\n", isp->isp_name);
d3431 463
a3893 3
	printf("%s: lost command, target %d lun %d, State: %x\n",
	       isp->isp_name, mbs.param[1] >> 8, mbs.param[1] & 0x7,
	       mbs.param[2] & 0xff);
@


1.2
log
@nicer output
@
text
@d593 1
a593 1
		panic("%s: ran out of xflist pointers\n", isp->isp_name);
@


1.1
log
@add isp driver from netbsd, more munging needed
@
text
@d121 1
a121 2
			printf("using board clock 0x%x ",
				isp->isp_name, clock);
d292 1
a292 1
	printf("F/W Revision %d.%d\n", mbs.param[1], mbs.param[2]);
@

