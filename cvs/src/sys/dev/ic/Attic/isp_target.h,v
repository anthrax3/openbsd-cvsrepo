head	1.16;
access;
symbols
	OPENBSD_5_7:1.15.0.10
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.14
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.12
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.14.0.10
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.8
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.6
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.22
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.20
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.18
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.16
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.14
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.12
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.10
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2015.06.19.11.12.24;	author jmatthew;	state dead;
branches;
next	1.15;
commitid	I5HMIEQiHPSVn0jd;

1.15
date	2011.10.22.19.34.06;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.02.02.01.47;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.17.17.42.04;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.17.01.33.50;	author mjacob;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.14.00.20.55;	author mjacob;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.10.06.22.45.52;	author mjacob;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.01.07.16.40;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.04.09.03.02;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.04.22.08.55;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.09.03.27.28;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.16.01.02.00;	author mjacob;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.06.05.31.48;	author mjacob;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.20.21.22.40;	author mjacob;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.02.21.22.29.05;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.05.14.22.23.56;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove isp(4) now that the ql* family have replaced it
@
text
@/*	$OpenBSD: isp_target.h,v 1.15 2011/10/22 19:34:06 miod Exp $	*/
/* $FreeBSD: src/sys/dev/isp/isp_target.h,v 1.30 2007/03/10 02:39:54 mjacob Exp $ */
/*-
 *  Copyright (c) 1997-2007 by Matthew Jacob
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 * 
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 *  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 */
/*
 * QLogic Target Mode Structure and Flag Definitions
 */
#ifndef	_ISP_TARGET_H
#define	_ISP_TARGET_H

#define	QLTM_SENSELEN	18	/* non-FC cards only */
#define QLTM_SVALID	0x80

/*
 * Structure for Enable Lun and Modify Lun queue entries
 */
typedef struct {
	isphdr_t	le_header;
	u_int32_t	le_reserved;
	u_int8_t	le_lun;
	u_int8_t	le_rsvd;
	u_int8_t	le_ops;		/* Modify LUN only */
	u_int8_t	le_tgt;		/* Not for FC */
	u_int32_t	le_flags;	/* Not for FC */
	u_int8_t	le_status;
	u_int8_t	le_reserved2;
	u_int8_t	le_cmd_count;
	u_int8_t	le_in_count;
	u_int8_t	le_cdb6len;	/* Not for FC */
	u_int8_t	le_cdb7len;	/* Not for FC */
	u_int16_t	le_timeout;
	u_int16_t	le_reserved3[20];
} lun_entry_t;

/*
 * le_flags values
 */
#define LUN_TQAE	0x00000002	/* bit1  Tagged Queue Action Enable */
#define LUN_DSSM	0x01000000	/* bit24 Disable Sending SDP Message */
#define	LUN_DISAD	0x02000000	/* bit25 Disable autodisconnect */
#define LUN_DM		0x40000000	/* bit30 Disconnects Mandatory */

/*
 * le_ops values
 */
#define LUN_CCINCR	0x01	/* increment command count */
#define LUN_CCDECR	0x02	/* decrement command count */
#define LUN_ININCR	0x40	/* increment immed. notify count */
#define LUN_INDECR	0x80	/* decrement immed. notify count */

/*
 * le_status values
 */
#define	LUN_OK		0x01	/* we be rockin' */
#define LUN_ERR		0x04	/* request completed with error */
#define LUN_INVAL	0x06	/* invalid request */
#define LUN_NOCAP	0x16	/* can't provide requested capability */
#define LUN_ENABLED	0x3E	/* LUN already enabled */

/*
 * Immediate Notify Entry structure
 */
#define IN_MSGLEN	8	/* 8 bytes */
#define IN_RSVDLEN	8	/* 8 words */
typedef struct {
	isphdr_t	in_header;
	u_int32_t	in_reserved;
	u_int8_t	in_lun;		/* lun */
	u_int8_t	in_iid;		/* initiator */
	u_int8_t	in_reserved2;
	u_int8_t	in_tgt;		/* target */
	u_int32_t	in_flags;
	u_int8_t	in_status;
	u_int8_t	in_rsvd2;
	u_int8_t	in_tag_val;	/* tag value */
	u_int8_t	in_tag_type;	/* tag type */
	u_int16_t	in_seqid;	/* sequence id */
	u_int8_t	in_msg[IN_MSGLEN];	/* SCSI message bytes */
	u_int16_t	in_reserved3[IN_RSVDLEN];
	u_int8_t	in_sense[QLTM_SENSELEN];/* suggested sense data */
} in_entry_t;

typedef struct {
	isphdr_t	in_header;
	u_int32_t	in_reserved;
	u_int8_t	in_lun;		/* lun */
	u_int8_t	in_iid;		/* initiator */
	u_int16_t	in_scclun;
	u_int32_t	in_reserved2;
	u_int16_t	in_status;
	u_int16_t	in_task_flags;
	u_int16_t	in_seqid;	/* sequence id */
} in_fcentry_t;

typedef struct {
	isphdr_t	in_header;
	u_int32_t	in_reserved;
	u_int16_t	in_iid;		/* initiator */
	u_int16_t	in_scclun;
	u_int32_t	in_reserved2;
	u_int16_t	in_status;
	u_int16_t	in_task_flags;
	u_int16_t	in_seqid;	/* sequence id */
} in_fcentry_e_t;

/*
 * Values for the in_status field
 */
#define	IN_REJECT	0x0D	/* Message Reject message received */
#define IN_RESET	0x0E	/* Bus Reset occurred */
#define IN_NO_RCAP	0x16	/* requested capability not available */
#define IN_IDE_RECEIVED	0x33	/* Initiator Detected Error msg received */
#define IN_RSRC_UNAVAIL	0x34	/* resource unavailable */
#define IN_MSG_RECEIVED	0x36	/* SCSI message received */
#define	IN_ABORT_TASK	0x20	/* task named in RX_ID is being aborted (FC) */
#define	IN_PORT_LOGOUT	0x29	/* port has logged out (FC) */
#define	IN_PORT_CHANGED	0x2A	/* port changed */
#define	IN_GLOBAL_LOGO	0x2E	/* all ports logged out */
#define	IN_NO_NEXUS	0x3B	/* Nexus not established */

/*
 * Values for the in_task_flags field- should only get one at a time!
 */
#define	TASK_FLAGS_RESERVED_MASK	(0xe700)
#define	TASK_FLAGS_CLEAR_ACA		(1<<14)
#define	TASK_FLAGS_TARGET_RESET		(1<<13)
#define	TASK_FLAGS_LUN_RESET		(1<<12)
#define	TASK_FLAGS_CLEAR_TASK_SET	(1<<10)
#define	TASK_FLAGS_ABORT_TASK_SET	(1<<9)

/*
 * ISP24XX Immediate Notify
 */
typedef struct {
	isphdr_t	in_header;
	u_int32_t	in_reserved;
	u_int16_t	in_nphdl;
	u_int16_t	in_reserved1;
	u_int16_t	in_flags;
	u_int16_t	in_srr_rxid;
	u_int16_t	in_status;
	u_int8_t	in_status_subcode;
	u_int8_t	in_reserved2;
	u_int32_t	in_rxid;
	u_int16_t	in_srr_reloff_lo;
	u_int16_t	in_srr_reloff_hi;
	u_int16_t	in_srr_iu;
	u_int16_t	in_srr_oxid;
	u_int8_t	in_reserved3[18];
	u_int8_t	in_reserved4;
	u_int8_t	in_vpindex;
	u_int32_t	in_reserved5;
	u_int16_t	in_portid_lo;
	u_int8_t	in_portid_hi;
	u_int8_t	in_reserved6;
	u_int16_t	in_reserved7;
	u_int16_t	in_oxid;
} in_fcentry_24xx_t;

#define	IN24XX_FLAG_PUREX_IOCB		0x1
#define	IN24XX_FLAG_GLOBAL_LOGOUT	0x2

#define	IN24XX_LIP_RESET	0x0E
#define	IN24XX_LINK_RESET	0x0F
#define	IN24XX_PORT_LOGOUT	0x29
#define	IN24XX_PORT_CHANGED	0x2A
#define	IN24XX_LINK_FAILED	0x2E
#define	IN24XX_SRR_RCVD		0x45
#define	IN24XX_ELS_RCVD		0x46	/*
					 * login-affectin ELS received- check
					 * subcode for specific opcode
					 */
/*
 * Notify Acknowledge Entry structure
 */
#define NA_RSVDLEN	22
typedef struct {
	isphdr_t	na_header;
	u_int32_t	na_reserved;
	u_int8_t	na_lun;		/* lun */
	u_int8_t	na_iid;		/* initiator */
	u_int8_t	na_reserved2;
	u_int8_t	na_tgt;		/* target */
	u_int32_t	na_flags;
	u_int8_t	na_status;
	u_int8_t	na_event;
	u_int16_t	na_seqid;	/* sequence id */
	u_int16_t	na_reserved3[NA_RSVDLEN];
} na_entry_t;

/*
 * Value for the na_event field
 */
#define NA_RST_CLRD	0x80	/* Clear an async event notification */
#define	NA_OK		0x01	/* Notify Acknowledge Succeeded */
#define	NA_INVALID	0x06	/* Invalid Notify Acknowledge */

#define	NA2_RSVDLEN	21
typedef struct {
	isphdr_t	na_header;
	u_int32_t	na_reserved;
	u_int8_t	na_reserved1;
	u_int8_t	na_iid;		/* initiator loop id */
	u_int16_t	na_response;
	u_int16_t	na_flags;
	u_int16_t	na_reserved2;
	u_int16_t	na_status;
	u_int16_t	na_task_flags;
	u_int16_t	na_seqid;	/* sequence id */
	u_int16_t	na_reserved3[NA2_RSVDLEN];
} na_fcentry_t;

typedef struct {
	isphdr_t	na_header;
	u_int32_t	na_reserved;
	u_int16_t	na_iid;		/* initiator loop id */
	u_int16_t	na_response;	/* response code */
	u_int16_t	na_flags;
	u_int16_t	na_reserved2;
	u_int16_t	na_status;
	u_int16_t	na_task_flags;
	u_int16_t	na_seqid;	/* sequence id */
	u_int16_t	na_reserved3[NA2_RSVDLEN];
} na_fcentry_e_t;

#define	NAFC_RCOUNT	0x80	/* increment resource count */
#define NAFC_RST_CLRD	0x20	/* Clear LIP Reset */
#define	NAFC_TVALID	0x10	/* task mangement response code is valid */

/*
 * ISP24XX Notify Acknowledge
 */

typedef struct {
	isphdr_t	na_header;
	u_int32_t	na_handle;
	u_int16_t	na_nphdl;
	u_int16_t	na_reserved1;
	u_int16_t	na_flags;
	u_int16_t	na_srr_rxid;
	u_int16_t	na_status;
	u_int8_t	na_status_subcode;
	u_int8_t	na_reserved2;
	u_int32_t	na_rxid;
	u_int16_t	na_srr_reloff_lo;
	u_int16_t	na_srr_reloff_hi;
	u_int16_t	na_srr_iu;
	u_int16_t	na_srr_flags;
	u_int8_t	na_reserved3[18];
	u_int8_t	na_reserved4;
	u_int8_t	na_vpindex;
	u_int8_t	na_srr_reject_vunique;
	u_int8_t	na_srr_reject_explanation;
	u_int8_t	na_srr_reject_code;
	u_int8_t	na_reserved5;
	u_int8_t	na_reserved6[6];
	u_int16_t	na_oxid;
} na_fcentry_24xx_t;

/*
 * Accept Target I/O Entry structure
 */
#define ATIO_CDBLEN	26

typedef struct {
	isphdr_t	at_header;
	u_int16_t	at_reserved;
	u_int16_t	at_handle;
	u_int8_t	at_lun;		/* lun */
	u_int8_t	at_iid;		/* initiator */
	u_int8_t	at_cdblen; 	/* cdb length */
	u_int8_t	at_tgt;		/* target */
	u_int32_t	at_flags;
	u_int8_t	at_status;	/* firmware status */
	u_int8_t	at_scsi_status;	/* scsi status */
	u_int8_t	at_tag_val;	/* tag value */
	u_int8_t	at_tag_type;	/* tag type */
	u_int8_t	at_cdb[ATIO_CDBLEN];	/* received CDB */
	u_int8_t	at_sense[QLTM_SENSELEN];/* suggested sense data */
} at_entry_t;

/*
 * at_flags values
 */
#define AT_NODISC	0x00008000	/* disconnect disabled */
#define AT_TQAE		0x00000002	/* Tagged Queue Action enabled */

/*
 * at_status values
 */
#define AT_PATH_INVALID	0x07	/* ATIO sent to firmware for disabled lun */
#define	AT_RESET	0x0E	/* SCSI Bus Reset Occurred */
#define AT_PHASE_ERROR	0x14	/* Bus phase sequence error */
#define AT_NOCAP	0x16	/* Requested capability not available */
#define AT_BDR_MSG	0x17	/* Bus Device Reset msg received */
#define AT_CDB		0x3D	/* CDB received */
/*
 * Macros to create and fetch and test concatenated handle and tag value macros
 */

#define	AT_MAKE_TAGID(tid, bus, inst, aep)				\
	tid = aep->at_handle;						\
	if (aep->at_flags & AT_TQAE) {					\
		tid |= (aep->at_tag_val << 16);				\
		tid |= (1 << 24);					\
	}								\
	tid |= (bus << 25);						\
	tid |= (inst << 26)

#define	CT_MAKE_TAGID(tid, bus, inst, ct)				\
	tid = ct->ct_fwhandle;						\
	if (ct->ct_flags & CT_TQAE) {					\
		tid |= (ct->ct_tag_val << 16);				\
		tid |= (1 << 24);					\
	}								\
	tid |= ((bus & 0x1) << 25);					\
	tid |= (inst << 26)

#define	AT_HAS_TAG(val)		((val) & (1 << 24))
#define	AT_GET_TAG(val)		(((val) >> 16) & 0xff)
#define	AT_GET_INST(val)	(((val) >> 26) & 0x3f)
#define	AT_GET_BUS(val)		(((val) >> 25) & 0x1)
#define	AT_GET_HANDLE(val)	((val) & 0xffff)

#define	IN_MAKE_TAGID(tid, bus, inst, inp)				\
	tid = inp->in_seqid;						\
	tid |= (inp->in_tag_val << 16);					\
	tid |= (1 << 24);						\
	tid |= (bus << 25);						\
	tid |= (inst << 26)

#define	TAG_INSERT_INST(tid, inst)					\
	tid &= ~(0x3ffffff);						\
	tid |= (inst << 26)

#define	TAG_INSERT_BUS(tid, bus)					\
	tid &= ~(1 << 25);						\
	tid |= (bus << 25)

/*
 * Accept Target I/O Entry structure, Type 2
 */
#define ATIO2_CDBLEN	16

typedef struct {
	isphdr_t	at_header;
	u_int32_t	at_reserved;
	u_int8_t	at_lun;		/* lun or reserved */
	u_int8_t	at_iid;		/* initiator */
	u_int16_t	at_rxid; 	/* response ID */
	u_int16_t	at_flags;
	u_int16_t	at_status;	/* firmware status */
	u_int8_t	at_crn;		/* command reference number */
	u_int8_t	at_taskcodes;
	u_int8_t	at_taskflags;
	u_int8_t	at_execodes;
	u_int8_t	at_cdb[ATIO2_CDBLEN];	/* received CDB */
	u_int32_t	at_datalen;		/* allocated data len */
	u_int16_t	at_scclun;		/* SCC Lun or reserved */
	u_int16_t	at_wwpn[4];		/* WWPN of initiator */
	u_int16_t	at_reserved2[6];
	u_int16_t	at_oxid;
} at2_entry_t;

typedef struct {
	isphdr_t	at_header;
	u_int32_t	at_reserved;
	u_int16_t	at_iid;		/* initiator */
	u_int16_t	at_rxid; 	/* response ID */
	u_int16_t	at_flags;
	u_int16_t	at_status;	/* firmware status */
	u_int8_t	at_crn;		/* command reference number */
	u_int8_t	at_taskcodes;
	u_int8_t	at_taskflags;
	u_int8_t	at_execodes;
	u_int8_t	at_cdb[ATIO2_CDBLEN];	/* received CDB */
	u_int32_t	at_datalen;		/* allocated data len */
	u_int16_t	at_scclun;		/* SCC Lun or reserved */
	u_int16_t	at_wwpn[4];		/* WWPN of initiator */
	u_int16_t	at_reserved2[6];
	u_int16_t	at_oxid;
} at2e_entry_t;

#define	ATIO2_WWPN_OFFSET	0x2A
#define	ATIO2_OXID_OFFSET	0x3E

#define	ATIO2_TC_ATTR_MASK	0x7
#define	ATIO2_TC_ATTR_SIMPLEQ	0
#define	ATIO2_TC_ATTR_HEADOFQ	1
#define	ATIO2_TC_ATTR_ORDERED	2
#define	ATIO2_TC_ATTR_ACAQ	4
#define	ATIO2_TC_ATTR_UNTAGGED	5

#define	ATIO2_EX_WRITE		0x1
#define	ATIO2_EX_READ		0x2
/*
 * Macros to create and fetch and test concatenated handle and tag value macros
 */
#define	AT2_MAKE_TAGID(tid, bus, inst, aep)				\
	tid = aep->at_rxid;						\
	tid |= (((u_int64_t)inst) << 32);				\
	tid |= (((u_int64_t)bus) << 48)

#define	CT2_MAKE_TAGID(tid, bus, inst, ct)				\
	tid = ct->ct_rxid;						\
	tid |= (((u_int64_t)inst) << 32);				\
	tid |= (((u_int64_t)(bus & 0xff)) << 48)

#define	AT2_HAS_TAG(val)	1
#define	AT2_GET_TAG(val)	((val) & 0xffffffff)
#define	AT2_GET_INST(val)	((val) >> 32)
#define	AT2_GET_HANDLE		AT2_GET_TAG
#define	AT2_GET_BUS(val)	(((val) >> 48) & 0xff)

#define	FC_HAS_TAG	AT2_HAS_TAG
#define	FC_GET_TAG	AT2_GET_TAG
#define	FC_GET_INST	AT2_GET_INST
#define	FC_GET_HANDLE	AT2_GET_HANDLE

#define	IN_FC_MAKE_TAGID(tid, bus, inst, seqid)				\
	tid = seqid;							\
	tid |= (((u_int64_t)inst) << 32);				\
	tid |= (((u_int64_t)(bus & 0xff)) << 48)

#define	FC_TAG_INSERT_INST(tid, inst)					\
	tid &= ~0xffff00000000ull;					\
	tid |= (((u_int64_t)inst) << 32)

/*
 * 24XX ATIO Definition
 *
 * This is *quite* different from other entry types.
 * First of all, it has its own queue it comes in on.
 *
 * Secondly, it doesn't have a normal header.
 *
 * Thirdly, it's just a passthru of the FCP CMND IU
 * which is recorded in big endian mode.
 */
typedef struct {
	u_int8_t	at_type;
	u_int8_t	at_count;
	/*
	 * Task attribute in high four bits,
	 * the rest is the FCP CMND IU Length.
	 * NB: the command can extend past the
	 * length for a single queue entry.
	 */
	u_int16_t	at_ta_len;
	u_int32_t	at_rxid;
	fc_hdr_t	at_hdr;
	fcp_cmnd_iu_t	at_cmnd;
} at7_entry_t;


/*
 * Continue Target I/O Entry structure
 * Request from driver. The response from the
 * ISP firmware is the same except that the last 18
 * bytes are overwritten by suggested sense data if
 * the 'autosense valid' bit is set in the status byte.
 */
typedef struct {
	isphdr_t	ct_header;
	u_int16_t	ct_syshandle;
	u_int16_t	ct_fwhandle;	/* required by f/w */
	u_int8_t	ct_lun;	/* lun */
	u_int8_t	ct_iid;	/* initiator id */
	u_int8_t	ct_reserved2;
	u_int8_t	ct_tgt;	/* our target id */
	u_int32_t	ct_flags;
	u_int8_t 	ct_status;	/* isp status */
	u_int8_t 	ct_scsi_status;	/* scsi status */
	u_int8_t 	ct_tag_val;	/* tag value */
	u_int8_t 	ct_tag_type;	/* tag type */
	u_int32_t	ct_xfrlen;	/* transfer length */
	u_int32_t	ct_resid;	/* residual length */
	u_int16_t	ct_timeout;
	u_int16_t	ct_seg_count;
	ispds_t		ct_dataseg[ISP_RQDSEG];
} ct_entry_t;

/*
 * For some of the dual port SCSI adapters, port (bus #) is reported
 * in the MSbit of ct_iid. Bit fields are a bit too awkward here.
 *
 * Note that this does not apply to FC adapters at all which can and
 * do report IIDs between 0x81 && 0xfe (or 0x7ff) which represent devices
 * that have logged in across a SCSI fabric.
 */
#define	GET_IID_VAL(x)		(x & 0x3f)
#define	GET_BUS_VAL(x)		((x >> 7) & 0x1)
#define	SET_IID_VAL(y, x)	y = ((y & ~0x3f) | (x & 0x3f))
#define	SET_BUS_VAL(y, x)	y = ((y & 0x3f) | ((x & 0x1) << 7))

/*
 * ct_flags values
 */
#define CT_TQAE		0x00000002	/* bit  1, Tagged Queue Action enable */
#define CT_DATA_IN	0x00000040	/* bits 6&7, Data direction */
#define CT_DATA_OUT	0x00000080	/* bits 6&7, Data direction */
#define CT_NO_DATA	0x000000C0	/* bits 6&7, Data direction */
#define	CT_CCINCR	0x00000100	/* bit 8, autoincrement atio count */
#define CT_DATAMASK	0x000000C0	/* bits 6&7, Data direction */
#define	CT_INISYNCWIDE	0x00004000	/* bit 14, Do Sync/Wide Negotiation */
#define CT_NODISC	0x00008000	/* bit 15, Disconnects disabled */
#define CT_DSDP		0x01000000	/* bit 24, Disable Save Data Pointers */
#define CT_SENDRDP	0x04000000	/* bit 26, Send Restore Pointers msg */
#define CT_SENDSTATUS	0x80000000	/* bit 31, Send SCSI status byte */

/*
 * ct_status values
 * - set by the firmware when it returns the CTIO
 */
#define CT_OK		0x01	/* completed without error */
#define CT_ABORTED	0x02	/* aborted by host */
#define CT_ERR		0x04	/* see sense data for error */
#define CT_INVAL	0x06	/* request for disabled lun */
#define CT_NOPATH	0x07	/* invalid ITL nexus */
#define	CT_INVRXID	0x08	/* (FC only) Invalid RX_ID */
#define	CT_DATA_OVER	0x09	/* (FC only) Data Overrun */
#define CT_RSELTMO	0x0A	/* reselection timeout after 2 tries */
#define CT_TIMEOUT	0x0B	/* timed out */
#define CT_RESET	0x0E	/* SCSI Bus Reset occurred */
#define	CT_PARITY	0x0F	/* Uncorrectable Parity Error */
#define	CT_BUS_ERROR	0x10	/* (FC Only) DMA PCI Error */
#define	CT_PANIC	0x13	/* Unrecoverable Error */
#define CT_PHASE_ERROR	0x14	/* Bus phase sequence error */
#define	CT_DATA_UNDER	0x15	/* (FC only) Data Underrun */
#define CT_BDR_MSG	0x17	/* Bus Device Reset msg received */
#define CT_TERMINATED	0x19	/* due to Terminate Transfer mbox cmd */
#define	CT_PORTUNAVAIL	0x28	/* port not available */
#define	CT_LOGOUT	0x29	/* port logout */
#define	CT_PORTCHANGED	0x2A	/* port changed */
#define	CT_IDE		0x33	/* Initiator Detected Error */
#define CT_NOACK	0x35	/* Outstanding Immed. Notify. entry */
#define	CT_SRR		0x45	/* SRR Received */
#define	CT_LUN_RESET	0x48	/* Lun Reset Received */

/*
 * When the firmware returns a CTIO entry, it may overwrite the last
 * part of the structure with sense data. This starts at offset 0x2E
 * into the entry, which is in the middle of ct_dataseg[1]. Rather
 * than define a new struct for this, I'm just using the sense data
 * offset.
 */
#define CTIO_SENSE_OFFSET	0x2E

/*
 * Entry length in u_longs. All entries are the same size so
 * any one will do as the numerator.
 */
#define UINT32_ENTRY_SIZE	(sizeof(at_entry_t)/sizeof(u_int32_t))

/*
 * QLA2100 CTIO (type 2) entry
 */
#define	MAXRESPLEN	26
typedef struct {
	isphdr_t	ct_header;
	u_int32_t	ct_syshandle;
	u_int8_t	ct_lun;		/* lun */
	u_int8_t	ct_iid;		/* initiator id */
	u_int16_t	ct_rxid;	/* response ID */
	u_int16_t	ct_flags;
	u_int16_t 	ct_status;	/* isp status */
	u_int16_t	ct_timeout;
	u_int16_t	ct_seg_count;
	u_int32_t	ct_reloff;	/* relative offset */
	int32_t		ct_resid;	/* residual length */
	union {
		/*
		 * The three different modes that the target driver
		 * can set the CTIO{2,3,4} up as.
		 *
		 * The first is for sending FCP_DATA_IUs as well as
		 * (optionally) sending a terminal SCSI status FCP_RSP_IU.
		 *
		 * The second is for sending SCSI sense data in an FCP_RSP_IU.
		 * Note that no FCP_DATA_IUs will be sent.
		 *
		 * The third is for sending FCP_RSP_IUs as built specifically
		 * in system memory as located by the isp_dataseg.
		 */
		struct {
			u_int32_t _reserved;
			u_int16_t _reserved2;
			u_int16_t ct_scsi_status;
			u_int32_t ct_xfrlen;
			union {
				ispds_t ct_dataseg[ISP_RQDSEG_T2];
				ispds64_t ct_dataseg64[ISP_RQDSEG_T3];
				ispdslist_t ct_dslist;
			} u;
		} m0;
		struct {
			u_int16_t _reserved;
			u_int16_t _reserved2;
			u_int16_t ct_senselen;
			u_int16_t ct_scsi_status;
			u_int16_t ct_resplen;
			u_int8_t  ct_resp[MAXRESPLEN];
		} m1;
		struct {
			u_int32_t _reserved;
			u_int16_t _reserved2;
			u_int16_t _reserved3;
			u_int32_t ct_datalen;
			ispds_t ct_fcp_rsp_iudata;
		} m2;
	} rsp;
} ct2_entry_t;

typedef struct {
	isphdr_t	ct_header;
	u_int32_t	ct_syshandle;
	u_int16_t	ct_iid;		/* initiator id */
	u_int16_t	ct_rxid;	/* response ID */
	u_int16_t	ct_flags;
	u_int16_t 	ct_status;	/* isp status */
	u_int16_t	ct_timeout;
	u_int16_t	ct_seg_count;
	u_int32_t	ct_reloff;	/* relative offset */
	int32_t		ct_resid;	/* residual length */
	union {
		struct {
			u_int32_t _reserved;
			u_int16_t _reserved2;
			u_int16_t ct_scsi_status;
			u_int32_t ct_xfrlen;
			union {
				ispds_t ct_dataseg[ISP_RQDSEG_T2];
				ispds64_t ct_dataseg64[ISP_RQDSEG_T3];
				ispdslist_t ct_dslist;
			} u;
		} m0;
		struct {
			u_int16_t _reserved;
			u_int16_t _reserved2;
			u_int16_t ct_senselen;
			u_int16_t ct_scsi_status;
			u_int16_t ct_resplen;
			u_int8_t  ct_resp[MAXRESPLEN];
		} m1;
		struct {
			u_int32_t _reserved;
			u_int16_t _reserved2;
			u_int16_t _reserved3;
			u_int32_t ct_datalen;
			ispds_t ct_fcp_rsp_iudata;
		} m2;
	} rsp;
} ct2e_entry_t;

/*
 * ct_flags values for CTIO2
 */
#define	CT2_FLAG_MODE0	0x0000
#define	CT2_FLAG_MODE1	0x0001
#define	CT2_FLAG_MODE2	0x0002
#define		CT2_FLAG_MMASK	0x0003
#define CT2_DATA_IN	0x0040
#define CT2_DATA_OUT	0x0080
#define CT2_NO_DATA	0x00C0
#define 	CT2_DATAMASK	0x00C0
#define	CT2_CCINCR	0x0100
#define	CT2_FASTPOST	0x0200
#define	CT2_CONFIRM	0x2000
#define	CT2_TERMINATE	0x4000
#define CT2_SENDSTATUS	0x8000

/*
 * ct_status values are (mostly) the same as that for ct_entry.
 */

/*
 * ct_scsi_status values- the low 8 bits are the normal SCSI status
 * we know and love. The upper 8 bits are validity markers for FCP_RSP_IU
 * fields.
 */
#define	CT2_RSPLEN_VALID	0x0100
#define	CT2_SNSLEN_VALID	0x0200
#define	CT2_DATA_OVER		0x0400
#define	CT2_DATA_UNDER		0x0800

/*
 * ISP24XX CTIO
 */
#define	MAXRESPLEN_24XX	24
typedef struct {
	isphdr_t	ct_header;
	u_int32_t	ct_syshandle;
	u_int16_t	ct_nphdl;	/* status on returned CTIOs */
	u_int16_t	ct_timeout;
	u_int16_t	ct_seg_count;
	u_int8_t	ct_vpindex;
	u_int8_t	ct_xflags;
	u_int16_t	ct_iid_lo;	/* low 16 bits of portid */
	u_int8_t	ct_iid_hi;	/* hi 8 bits of portid */
	u_int8_t	ct_reserved;
	u_int32_t	ct_rxid;
	u_int16_t	ct_senselen;	/* mode 0 only */
	u_int16_t	ct_flags;
	int32_t		ct_resid;	/* residual length */
	u_int16_t	ct_oxid;
	u_int16_t	ct_scsi_status;	/* modes 0 && 1 only */
	union {
		struct {
			u_int32_t	reloff;
			u_int32_t	reserved0;
			u_int32_t	ct_xfrlen;
			u_int32_t	reserved1;
			ispds64_t	ds;
		} m0;
		struct {
			u_int16_t ct_resplen;
			u_int16_t reserved;
			u_int8_t  ct_resp[MAXRESPLEN_24XX];
		} m1;
		struct {
			u_int32_t reserved0;
			u_int32_t ct_datalen;
			u_int32_t reserved1;
			ispds64_t ct_fcp_rsp_iudata;
		} m2;
	} rsp;
} ct7_entry_t;

/*
 * ct_flags values for CTIO7
 */
#define CT7_DATA_IN	0x0002
#define CT7_DATA_OUT	0x0001
#define CT7_NO_DATA	0x0000
#define 	CT7_DATAMASK	0x003
#define	CT7_DSD_ENABLE	0x0004
#define	CT7_CONF_STSFD	0x0010
#define	CT7_EXPLCT_CONF	0x0020
#define	CT7_FLAG_MODE0	0x0000
#define	CT7_FLAG_MODE1	0x0040
#define	CT7_FLAG_MODE7	0x0080
#define		CT7_FLAG_MMASK	0x00C0
#define	CT7_FASTPOST	0x0100
#define	CT7_ATTR_MASK	0x1e00	/* task attributes from atio7 */
#define	CT7_CONFIRM	0x2000
#define	CT7_TERMINATE	0x4000
#define CT7_SENDSTATUS	0x8000

/*
 * Type 7 CTIO status codes
 */
#define CT7_OK		0x01	/* completed without error */
#define CT7_ABORTED	0x02	/* aborted by host */
#define CT7_ERR		0x04	/* see sense data for error */
#define CT7_INVAL	0x06	/* request for disabled lun */
#define	CT7_INVRXID	0x08	/* (FC only) Invalid RX_ID */
#define	CT7_DATA_OVER	0x09	/* (FC only) Data Overrun */
#define CT7_TIMEOUT	0x0B	/* timed out */
#define CT7_RESET	0x0E	/* LIP Rset Received */
#define	CT7_BUS_ERROR	0x10	/* DMA PCI Error */
#define	CT7_REASSY_ERR	0x11	/* DMA reassembly error */
#define	CT7_DATA_UNDER	0x15	/* (FC only) Data Underrun */
#define	CT7_PORTUNAVAIL	0x28	/* port not available */
#define	CT7_LOGOUT	0x29	/* port logout */
#define	CT7_PORTCHANGED	0x2A	/* port changed */
#define	CT7_SRR		0x45	/* SRR Received */

/*
 * Other 24XX related target IOCBs
 */

/*
 * ABTS Received
 */
typedef struct {
	isphdr_t	abts_header;
	u_int8_t	abts_reserved0[6];
	u_int16_t	abts_nphdl;
	u_int16_t	abts_reserved1;
	u_int16_t	abts_sof;
	u_int32_t	abts_rxid_abts;
	u_int16_t	abts_did_lo;
	u_int8_t	abts_did_hi;
	u_int8_t	abts_r_ctl;
	u_int16_t	abts_sid_lo;
	u_int8_t	abts_sid_hi;
	u_int8_t	abts_cs_ctl;
	u_int16_t	abts_fs_ctl;
	u_int8_t	abts_f_ctl;
	u_int8_t	abts_type;
	u_int16_t	abts_seq_cnt;
	u_int8_t	abts_df_ctl;
	u_int8_t	abts_seq_id;
	u_int16_t	abts_rx_id;
	u_int16_t	abts_ox_id;
	u_int32_t	abts_param;
	u_int8_t	abts_reserved2[16];
	u_int32_t	abts_rxid_task;
} abts_t;

typedef struct {
	isphdr_t	abts_rsp_header;
	u_int32_t	abts_rsp_handle;
	u_int16_t	abts_rsp_status;
	u_int16_t	abts_rsp_nphdl;
	u_int16_t	abts_rsp_ctl_flags;
	u_int16_t	abts_rsp_sof;
	u_int32_t	abts_rsp_rxid_abts;
	u_int16_t	abts_rsp_did_lo;
	u_int8_t	abts_rsp_did_hi;
	u_int8_t	abts_rsp_r_ctl;
	u_int16_t	abts_rsp_sid_lo;
	u_int8_t	abts_rsp_sid_hi;
	u_int8_t	abts_rsp_cs_ctl;
	u_int16_t	abts_rsp_f_ctl_lo;
	u_int8_t	abts_rsp_f_ctl_hi;
	u_int8_t	abts_rsp_type;
	u_int16_t	abts_rsp_seq_cnt;
	u_int8_t	abts_rsp_df_ctl;
	u_int8_t	abts_rsp_seq_id;
	u_int16_t	abts_rsp_rx_id;
	u_int16_t	abts_rsp_ox_id;
	u_int32_t	abts_rsp_param;
	union {
		struct {
			u_int16_t reserved;
			u_int8_t  last_seq_id;
			u_int8_t  seq_id_valid;
			u_int16_t aborted_rx_id;
			u_int16_t aborted_ox_id;
			u_int16_t high_seq_cnt;
			u_int16_t low_seq_cnt;
			u_int8_t  reserved2[4];
		} ba_acc;
		struct {
			u_int8_t vendor_unique;
			u_int8_t explanation;
			u_int8_t reason;
			u_int8_t reserved;
			u_int8_t reserved2[12];
		} ba_rjt;
		struct {
			u_int8_t  reserved[8];
			u_int32_t subcode1;
			u_int32_t subcode2;
		} rsp;
		u_int8_t reserved[16];
	} abts_rsp_payload;
	u_int32_t	abts_rsp_rxid_task;
} abts_rsp_t;

/* terminate this ABTS exchange */
#define	ISP24XX_ABTS_RSP_TERMINATE	0x01

#define	ISP24XX_ABTS_RSP_COMPLETE	0x00
#define	ISP24XX_ABTS_RSP_RESET		0x04
#define	ISP24XX_ABTS_RSP_ABORTED	0x05
#define	ISP24XX_ABTS_RSP_TIMEOUT	0x06
#define	ISP24XX_ABTS_RSP_INVXID		0x08
#define	ISP24XX_ABTS_RSP_LOGOUT		0x29
#define	ISP24XX_ABTS_RSP_SUBCODE	0x31

/*
 * Debug macros
 */

#ifdef SMALL_KERNEL
#define	ISP_TDQE(isp, msg, idx, arg)	\
    do { } while (0)
#else
#define	ISP_TDQE(isp, msg, idx, arg)	\
    if (isp->isp_dblev & ISP_LOGTDEBUG2) isp_print_qentry(isp, msg, idx, arg)
#endif

#ifndef	ISP_TOOLS
/*
 * The functions below are for the publicly available
 * target mode functions that are internal to the QLogic driver.
 */

/*
 * This function handles new response queue entry appropriate for target mode.
 */
int isp_target_notify(ispsoftc_t *, void *, u_int32_t *);

/*
 * This function externalizes the ability to acknowledge an Immediate Notify
 * request.
 */
void isp_notify_ack(ispsoftc_t *, void *);

/*
 * Enable/Disable/Modify a logical unit.
 * (softc, cmd, bus, tgt, lun, cmd_cnt, inotify_cnt, opaque)
 */
#define	DFLT_CMND_CNT	0xfe	/* unmonitored */
#define	DFLT_INOT_CNT	0xfe	/* unmonitored */
int isp_lun_cmd(ispsoftc_t *, int, int, int, int, int, int, u_int32_t);

/*
 * General request queue 'put' routine for target mode entries.
 */
int isp_target_put_entry(ispsoftc_t *isp, void *);

/*
 * General routine to put back an ATIO entry-
 * used for replenishing f/w resource counts.
 * The argument is a pointer to a source ATIO
 * or ATIO2.
 */
int isp_target_put_atio(ispsoftc_t *, void *);

/*
 * General routine to send a final CTIO for a command- used mostly for
 * local responses.
 */
int isp_endcmd(ispsoftc_t *, void *, u_int32_t, u_int32_t);
#define	ECMD_SVALID	0x100

/*
 * Handle an asynchronous event
 *
 * Return nonzero if the interrupt that generated this event has been dismissed.
 */
int isp_target_async(ispsoftc_t *, int, int);
#endif
#endif	/* _ISP_TARGET_H */
@


1.15
log
@Comment out ISP_{T,}DEBUG[0-3] traces if option SMALL_KERNEL; allows alpha
floppyB to fit again. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.14 2009/06/24 11:00:53 krw Exp $	*/
@


1.14
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.13 2008/11/02 02:01:47 krw Exp $	*/
d891 4
d897 1
@


1.13
log
@Start updating isp. Just new defines, comments, whitespace, anything that
doesn't change the .o.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.12 2008/01/21 20:00:33 sobrado Exp $	*/
a2 25
/*
 * Copyright (c) 1997, 1998
 * Patrick Stirling
 * pms@@psconsult.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
a147 3
#define	TASK_FLAGS_ABORT_TASK		(1<<9)
#define	TASK_FLAGS_CLEAR_TASK_SET	(1<<10)
#define	TASK_FLAGS_TARGET_RESET		(1<<13)
a149 1
#define	TASK_FLAGS_TERMINATE_TASK	(1<<15)
a154 16
#ifndef	MSG_ABORT_TAG
#define	MSG_ABORT_TAG		0x06
#endif
#ifndef	MSG_CLEAR_QUEUE
#define	MSG_CLEAR_QUEUE		0x0e
#endif
#ifndef	MSG_BUS_DEV_RESET
#define	MSG_BUS_DEV_RESET	0x0b
#endif
#ifndef	MSG_REL_RECOVERY
#define	MSG_REL_RECOVERY	0x10
#endif
#ifndef	MSG_TERM_IO_PROC
#define	MSG_TERM_IO_PROC	0x11
#endif

d226 3
a228 3
	u_int8_t	na_lun;		/* lun */
	u_int8_t	na_iid;		/* initiator */
	u_int16_t	na_scclun;
d325 8
a332 9
#define	AT_MAKE_TAGID(tid, aep)						\
	tid = ((aep)->at_handle << 16);					\
	if ((aep)->at_flags & AT_TQAE)					\
		(tid) |= ((aep)->at_tag_val + 1)

#define	CT_MAKE_TAGID(tid, ct)						\
	tid = ((ct)->ct_fwhandle << 16);				\
	if ((ct)->ct_flags & CT_TQAE)					\
		(tid) |= ((ct)->ct_tag_val + 1)
d334 11
a344 2
#define	AT_HAS_TAG(val)		((val) & 0xffff)
#define	AT_GET_TAG(val)		AT_HAS_TAG(val) - 1
d347 1
a347 1
#define	AT_GET_HANDLE(val)	((val) >> 16)
d377 1
a377 1
	u_int8_t	at_reserved1;
d489 1
a489 2
	u_int16_t	ct_reserved;
#define	ct_syshandle	ct_reserved	/* we use this */
d504 1
a504 8
	/*
	 * This is so we can share tag name space with
	 * CTIO{2,3,4} with the minimum of pain.
	 */
	union {
		ispds_t		ct_a[ISP_RQDSEG];
	} _u;
#define	ct_dataseg	_u.ct_a
d556 1
a556 1
#define	CT_PORTNOTAVAIL	0x28	/* port not available */
d585 1
a585 2
	u_int16_t	ct_reserved;
	u_int16_t	ct_fwhandle;	/* just to match CTIO */
d615 4
a618 7
				ispds_t ct_a[ISP_RQDSEG_T2];	/* CTIO2 */
				ispds64_t ct_b[ISP_RQDSEG_T3];	/* CTIO3 */
				ispdslist_t ct_c;		/* CTIO4 */
			} _u;
#define	ct_dataseg	_u.ct_a
#define	ct_dataseg64	_u.ct_b
#define	ct_dslist	_u.ct_c
a634 8
		/*
		 * CTIO2 returned from F/W...
		 */
		struct {
			u_int32_t _reserved[4];
			u_int16_t ct_scsi_status;
			u_int8_t  ct_sense[QLTM_SENSELEN];
		} fw;
d686 4
a689 4
#define CT2_DATA_IN	CT_DATA_IN
#define CT2_DATA_OUT	CT_DATA_OUT
#define CT2_NO_DATA	CT_NO_DATA
#define CT2_DATAMASK	CT_DATAMASK
d894 1
a894 1
#ifdef	ISP_TARGET_FUNCTIONS
d903 1
a903 1
int isp_target_notify(struct ispsoftc *, void *, u_int16_t *);
d916 2
a917 2
#define	DFLT_INOT_CNT	16
int isp_lun_cmd(struct ispsoftc *, int, int, int, int, int, int, u_int32_t);
d922 1
a922 1
int isp_target_put_entry(struct ispsoftc *isp, void *);
d930 1
a930 1
int isp_target_put_atio(struct ispsoftc *, void *);
d936 1
a936 1
int isp_endcmd(struct ispsoftc *, void *, u_int32_t, u_int16_t);
d944 1
a944 2

int isp_target_async(struct ispsoftc *, int, int);
@


1.12
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 2
a2 3
/*	$OpenBSD: isp_target.h,v 1.11 2002/08/17 17:42:04 mjacob Exp $	*/

/* @@(#)isp_target.h 1.3 */
a3 2
 * QLogic Target Mode Structure and Flag Definitions
 *
a8 6
 * Additional Copyright (c) 1999, 2000, 2001
 * Matthew Jacob
 * mjacob@@feral.com
 * All rights reserved.
 *
 *
d27 29
a55 1
 *
d60 1
a60 3
/*
 * Defines for all entry types
 */
a61 1
#define	QLTM_SENSELEN	18
d144 11
d176 1
d179 4
d200 42
a241 1

d281 14
d297 32
a365 1

d382 2
d386 15
d426 19
d455 62
d557 2
a558 2
 * do report IIDs between 129 && 255 (these represent devices that have
 * logged in across a SCSI fabric).
d598 1
a599 1
#define	CT_DATA_UNDER	0x15	/* (FC only) Data Underrun */
d606 2
d695 41
a738 1
#define	CT2_FLAG_MMASK	0x0003
d742 1
d749 2
d768 177
d961 6
@


1.11
log
@Set default command count to 'unmonitored'. Set inotify to 16.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.10 2002/05/17 01:33:50 mjacob Exp $	*/
d5 1
a5 1
 * Qlogic Target Mode Structure and Flag Definitions
d516 1
a516 1
 * target mode functions that are internal to the Qlogic driver.
@


1.10
log
@keep up with the jones' (sync up with external source)
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.9 2001/12/14 00:20:55 mjacob Exp $	*/
d528 2
a529 2
#define	DFLT_CMND_CNT	32
#define	DFLT_INOT_CNT	4
@


1.9
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.8 2001/10/06 22:45:52 mjacob Exp $	*/
d285 3
a287 2
	u_int16_t	at_scclun;	/* SCC Lun or reserved */
	u_int16_t	at_reserved2[10];
d414 3
a416 3
	u_int8_t	ct_lun;	/* lun */
	u_int8_t	ct_iid;	/* initiator id */
	u_int16_t	ct_rxid; /* response ID */
d554 2
d558 1
a558 1
void isp_target_async(struct ispsoftc *, int, int);
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.9 2001/12/14 00:20:55 mjacob Exp $	*/
d285 2
a286 3
	u_int16_t	at_scclun;		/* SCC Lun or reserved */
	u_int16_t	at_wwpn[4];		/* WWPN of initiator */
	u_int16_t	at_reserved2[6];
d413 3
a415 3
	u_int8_t	ct_lun;		/* lun */
	u_int8_t	ct_iid;		/* initiator id */
	u_int16_t	ct_rxid;	/* response ID */
a552 2
 *
 * Return nonzero if the interrupt that generated this event has been dismissed.
d555 1
a555 1
int isp_target_async(struct ispsoftc *, int, int);
@


1.9.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.9.2.1 2002/06/11 03:42:19 art Exp $	*/
d528 2
a529 2
#define	DFLT_CMND_CNT	0xfe	/* unmonitored */
#define	DFLT_INOT_CNT	16
@


1.8
log
@Fix various 2300 (2Gb) last minute errata. Keep up with the jones' for
the target mode code.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.7 2001/09/01 07:16:40 mjacob Exp $	*/
d325 8
a332 1
	ispds_t		ct_dataseg[ISP_RQDSEG];
d425 1
a425 1
		 * can set the CTIO2 up as.
d441 8
a448 9
			ispds_t ct_dataseg[ISP_RQDSEG_T2];
			/*
			 * For CTIO3, an ispds64_t would go here, padded
			 * to the end of the request.
			 */
			/*
			 * For CTIO4, an ispdlist_t would go here, padded
			 * to the end of the request.
			 */
a505 180
 * Macros for packing/unpacking the above structures
 */

#ifdef	__sparc__
#define	ISP_SBUS_SWOZZLE(isp, src, dst, taga, tagb)	\
	if (isp->isp_bustype == ISP_BT_SBUS) {	\
		u_int8_t tmp = src -> taga;	\
		dst -> taga =  dst -> tagb;	\
		src -> tagb =  tmp;		\
	} else { \
		dst -> taga =  src -> taga;	\
		dst -> tagb =  src -> taga;	\
	}
#else
#define	ISP_SBUS_SWOZZLE(isp, src, dst, taga, tagb)	\
		dst -> taga =  src -> taga;	\
		dst -> tagb =  src -> taga
#endif

#define	MCIDF(d, s)	if ((void *) d != (void *)s) MEMCPY(d, s, QENTRY_LEN)

/* This is really only for SBus cards on a sparc */
#ifdef	__sparc__
#define	ISP_SWIZ_ATIO(isp, vdst, vsrc)					\
{									\
	at_entry_t *src = (at_entry_t *) vsrc;				\
	at_entry_t *dst = (at_entry_t *) vdst;				\
	dst->at_header = src->at_header;				\
	dst->at_reserved = src->at_reserved;				\
	dst->at_handle = src->at_handle;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_lun, at_iid);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_cdblen, at_tgt);		\
	dst->at_flags = src->at_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_status, at_scsi_status);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_tag_val, at_tag_type);	\
	MEMCPY(dst->at_cdb, src->at_cdb, ATIO_CDBLEN);			\
	MEMCPY(dst->at_sense, src->at_sense, QLTM_SENSELEN);		\
}
#define	ISP_SWIZ_ATIO2(isp, vdst, vsrc)					\
{									\
	at2_entry_t *src = (at2_entry_t *) vsrc;			\
	at2_entry_t *dst = (at2_entry_t *) vdst;			\
	dst->at_reserved = src->at_reserved;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_lun, at_iid);		\
	dst->at_rxid = src->at_rxid;					\
	dst->at_flags = src->at_flags;					\
	dst->at_status = src->at_status;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_reserved1, at_taskcodes);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_taskflags, at_execodes);	\
	MEMCPY(dst->at_cdb, src->at_cdb, ATIO2_CDBLEN);			\
	dst->at_datalen = src->at_datalen;				\
	dst->at_scclun = src->at_scclun;				\
	MEMCPY(dst->at_reserved2, src->at_reserved2, sizeof dst->at_reserved2);\
	dst->at_oxid = src->at_oxid;					\
}
#define	ISP_SWIZ_CTIO(isp, vdst, vsrc)					\
{									\
	ct_entry_t *src = (ct_entry_t *) vsrc;				\
	ct_entry_t *dst = (ct_entry_t *) vdst;				\
	dst->ct_header = src->ct_header;				\
	dst->ct_syshandle = src->ct_syshandle;				\
	dst->ct_fwhandle = src->ct_fwhandle;				\
	dst->ct_fwhandle = src->ct_fwhandle;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_lun, ct_iid);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_reserved2, ct_tgt);		\
	dst->ct_flags = src->ct_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_status, ct_scsi_status);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_tag_val, ct_tag_type);	\
	dst->ct_xfrlen = src->ct_xfrlen;				\
	dst->ct_resid = src->ct_resid;					\
	dst->ct_timeout = src->ct_timeout;				\
	dst->ct_seg_count = src->ct_seg_count;				\
	MEMCPY(dst->ct_dataseg, src->ct_dataseg, sizeof (dst->ct_dataseg)); \
}
#define	ISP_SWIZ_CTIO2(isp, vdst, vsrc)					\
{									\
	ct2_entry_t *src = (ct2_entry_t *) vsrc;			\
	ct2_entry_t *dst = (ct2_entry_t *) vdst;			\
	dst->ct_header = src->ct_header;				\
	dst->ct_syshandle = src->ct_syshandle;				\
	dst->ct_fwhandle = src->ct_fwhandle;				\
	dst->ct_fwhandle = src->ct_fwhandle;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_lun, ct_iid);		\
	dst->ct_rxid = src->ct_rxid;					\
	dst->ct_flags = src->ct_flags;					\
	dst->ct_status = src->ct_status;				\
	dst->ct_timeout = src->ct_timeout;				\
	dst->ct_seg_count = src->ct_seg_count;				\
	dst->ct_reloff = src->ct_reloff;				\
	dst->ct_resid = src->ct_resid;					\
	dst->rsp = src->rsp;						\
}
#define	ISP_SWIZ_ENABLE_LUN(isp, vdst, vsrc)				\
{									\
	lun_entry_t *src = (lun_entry_t *)vsrc;				\
	lun_entry_t *dst = (lun_entry_t *)vdst;				\
	dst->le_header = src->le_header;				\
	dst->le_reserved2 = src->le_reserved2;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_lun, le_rsvd);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_ops, le_tgt);		\
	dst->le_flags = src->le_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_status, le_reserved2);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_cmd_count, le_in_count);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_cdb6len, le_cdb7len);	\
	dst->le_timeout = src->le_timeout;				\
	dst->le_reserved = src->le_reserved;				\
}
#define	ISP_SWIZ_NOTIFY(isp, vdst, vsrc)				\
{									\
	in_entry_type *src = (in_entry_t *)vsrc;			\
	in_entry_type *dst = (in_entry_t *)vdst;			\
	dst->in_header = src->in_header;				\
	dst->in_reserved2 = src->in_reserved2;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_lun, in_iid);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_reserved2, in_tgt);		\
	dst->in_flags = src->in_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_status, in_rsvd2);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_tag_val, in_tag_type);	\
	dst->in_seqid = src->in_seqid;					\
	MEMCPY(dst->in_msg, src->in_msg, IN_MSGLEN);			\
	MEMCPY(dst->in_reserved, src->in_reserved, IN_RESERVED);	\
	MEMCPY(dst->in_sense, src->in_sense, QLTM_SENSELEN);		\
}
#define	ISP_SWIZ_NOTIFY_FC(isp, vdst, vsrc)				\
{									\
	in_fcentry_type *src = (in_fcentry_t *)vsrc;			\
	in_fcentry_type *dst = (in_fcentry_t *)vdst;			\
	dst->in_header = src->in_header;				\
	dst->in_reserved2 = src->in_reserved2;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_lun, in_iid);		\
	dst->in_scclun = src->in_scclun;				\
	dst->in_reserved2 = src->in_reserved2;				\
	dst->in_status = src->in_status;				\
	dst->in_task_flags = src->in_task_flags;			\
	dst->in_seqid = src->in_seqid;					\
}
#define	ISP_SWIZ_NOT_ACK(isp, vdst, vsrc)				\
{									\
	na_entry_t *src = (na_entry_t *)vsrc;				\
	na_entry_t *dst = (na_entry_t *)vdst;				\
	dst->na_header = src->na_header;				\
	dst->na_reserved = src->na_reserved;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, na_lun, na_iid);		\
	dst->na_reserved2 = src->na_reserved2;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, na_reserved, na_tgt);		\
	dst->na_flags = src->na_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, na_status, na_event);		\
	dst->na_seqid = src->na_seqid;					\
	MEMCPY(dst->na_reserved3, src->na_reserved3, NA_RSVDLEN);	\
}
#define	ISP_SWIZ_NOT_ACK_FC(isp, vdst, vsrc)				\
{									\
	na_fcentry_t *src = (na_fcentry_t *)vsrc;			\
	na_fcentry_t *dst = (na_fcentry_t *)vdst;			\
	dst->na_header = src->na_header;				\
	dst->na_reserved = src->na_reserved;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, na_lun, na_iid);		\
	dst->na_scclun = src->na_scclun;				\
	dst->na_flags = src->na_flags;					\
	dst->na_reserved2 = src->na_reserved2;				\
	dst->na_status = src->na_status;				\
	dst->na_task_flags = src->na_task_flags;			\
	dst->na_seqid = src->na_seqid;					\
	MEMCPY(dst->na_reserved3, src->na_reserved3, NA2_RSVDLEN);	\
}
#else
#define	ISP_SWIZ_ATIO(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_ATIO2(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_CTIO(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_CTIO2(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_ENABLE_LUN(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_ATIO2(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_CTIO2(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_NOTIFY(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_NOTIFY_FC(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_NOT_ACK(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_NOT_ACK_FC(isp, d, s)	MCIDF(d, s)
#endif

/*
d512 1
d514 2
a515 2
 * The functions below are target mode functions that
 * are generally internal to the Qlogic driver.
d556 1
a556 1

@


1.7
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_target.h,v 1.6 2001/07/04 09:03:02 niklas Exp $	*/
d338 2
a339 2
#define	SET_IID_VAL(y, x)	(y | (x & 0x3f))
#define	SET_BUS_VAL(y, x)	(y | ((x & 0x1) << 7))
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d366 1
d371 1
d375 1
d435 8
d698 1
d700 3
a702 3
#define	DFLT_CMD_CNT	32	/* XX */
#define	DFLT_INOTIFY	(4)
int isp_lun_cmd(struct ispsoftc *, int, int, int, int, u_int32_t);
@


1.5
log
@Keep up with the Joneses- sync up with core code for (eventual) usage here.
@
text
@d1 2
@


1.4
log
@Add offsets for WWPN && OXID that FC f/w stuffs into an ATIO2.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.h,v 1.3 2000/10/16 01:02:00 mjacob Exp $ */
d10 1
a10 1
 * Additional Copyright (c) 1999< 2000
d36 2
a37 2
#ifndef	_ISPTARGET_H
#define	_ISPTARGET_H
d69 1
a69 1
#define LUN_TQAE	0x00000001	/* bit1  Tagged Queue Action Enable */
d215 2
a216 1
	u_int32_t	at_reserved;
d234 1
a234 1
#define AT_TQAE		0x00000001	/* Tagged Queue Action enabled */
d247 18
d284 2
a285 3
	u_int16_t	at_reserved2;
	u_int16_t	at_scsi_status;
	u_int8_t	at_sense[QLTM_SENSELEN];
d307 3
a309 1
	u_int32_t	ct_reserved;
d342 1
a342 1
#define CT_TQAE		0x00000001	/* bit  1, Tagged Queue Action enable */
d399 2
a400 1
	u_int32_t	ct_reserved;
d491 5
a495 4
#define	ISP_SBUS_SWOZZLE(isp, src, dest, taga, tagb)	\
	if (isp->isp_bus == ISP_SBUS) {	\
		source -> taga =  dest -> tagb;	\
		source -> tagb =  dest -> taga;	\
d497 2
a498 2
		source -> taga =  dest -> taga;	\
		source -> tagb =  dest -> taga;	\
d501 3
a503 3
#define	ISP_SBUS_SWOZZLE(isp, src, dest, taga, tagb)	\
		source -> taga =  dest -> taga;	\
		source -> tagb =  dest -> taga;
d510 33
a542 1
#define	ISP_SWIZ_ATIO(isp, dest, vsrc)					\
d544 16
a559 17
	at_entry_t *source = (at_entry_t *) vsrc;			\
	at_entry_t local, *vdst;					\
	if ((void *)dest == (void *)vsrc) {				\
		MEMCPY(vsrc, &local, sizeof (at_entry_t));		\
		vdst = &local;						\
	} else {							\
		vdst = dest;						\
	}								\
	vdst->at_header = source->at_header;				\
	vdst->at_reserved2 = source->at_reserved2;			\
	ISP_SBUS_SWOZZLE(isp, source, vdst, at_lun, at_iid);		\
	ISP_SBUS_SWOZZLE(isp, source, vdst, at_cdblen, at_tgt);		\
	vdst->at_flags = source->at_flags;				\
	ISP_SBUS_SWOZZLE(isp, source, vdst, at_status, at_scsi_status);	\
	ISP_SBUS_SWOZZLE(isp, source, vdst, at_tag_val, at_tag_type);	\
	MEMCPY(vdst->at_cdb, source->at_cdb, ATIO_CDBLEN);		\
	MEMCPY(vdst->at_sense, source->at_sense, QLTM_SENSELEN);	\
d561 34
a594 2

#define	ISP_SWIZ_CTIO(isp, dest, vsrc)					\
d596 13
a608 22
	ct_entry_t *source = (ct_entry_t *) vsrc;			\
	ct_entry_t *local, *vdst;					\
	if ((void *)dest == (void *)vsrc) {				\
		MEMCPY(vsrc, &local, sizeof (ct_entry_t));		\
		vdst = &local;						\
	} else {							\
		vdst = dest;						\
	}								\
	vdst->ct_header = source->ct_header;				\
	vdst->ct_reserved = source->ct_reserved;			\
	ISP_SBUS_SWOZZLE(isp, source, vdst, ct_lun, ct_iid);		\
	ISP_SBUS_SWOZZLE(isp, source, vdst, ct_rsvd, ct_tgt);		\
	vdst->ct_flags = source->ct_flags;				\
	ISP_SBUS_SWOZZLE(isp, source, vdst, ct_status, ct_scsi_status);	\
	ISP_SBUS_SWOZZLE(isp, source, vdst, ct_tag_val, ct_tag_type);	\
	vdst->ct_xfrlen = source->ct_xfrlen;				\
	vdst->ct_resid = source->ct_resid;				\
	vdst->ct_timeout = source->ct_timeout;				\
	vdst->ct_seg_count = source->ct_seg_count;			\
	MEMCPY(vdst->ct_cdb, source->ct_cdb, ATIO_CDBLEN);		\
	MEMCPY(vdst->ct_sense, source->ct_sense, QLTM_SENSELEN);	\
	vdst->ct_dataseg = source->ct_dataseg;				\
d610 1
a610 1
#define	ISP_SWIZ_ENABLE_LUN(isp, dest, vsrc)				\
d612 10
a621 18
	lun_entry_t *source = (lun_entry_t *)vsrc;			\
	lun_entry_t *local, *vdst;					\
	if ((void *)dest == (void *)vsrc) {				\
		MEMCPY(vsrc, &local, sizeof (lun_entry_t));		\
		vdst = &local;						\
	} else {							\
		vdst = dest;						\
	}								\
	vdst->le_header = source->le_header;				\
	vdst->le_reserved2 = source->le_reserved2;			\
	ISP_SBUS_SWOZZLE(isp, source, vdst, le_lun, le_rsvd);		\
	ISP_SBUS_SWOZZLE(isp, source, vdst, le_ops, le_tgt);		\
	vdst->le_flags = source->le_flags;				\
	ISP_SBUS_SWOZZLE(isp, source, vdst, le_status, le_rsvd2);	\
	ISP_SBUS_SWOZZLE(isp, source, vdst, le_cmd_count, le_in_count);	\
	ISP_SBUS_SWOZZLE(isp, source, vdst, le_cdb6len, le_cdb7len);	\
	vdst->le_timeout = source->le_timeout;				\
	vdst->le_reserved = source->le_reserved;			\
d623 1
a623 1
#define	ISP_SWIZ_NOTIFY(isp, dest, vsrc)				\
d625 11
a635 19
	in_entry_type *source = (in_entry_t *)vsrc;			\
	in_entry_t *local, *vdst;					\
	if ((void *)dest == (void *)vsrc) {				\
		MEMCPY(vsrc, &local, sizeof (in_entry_t));		\
		vdst = &local;						\
	} else {							\
		vdst = dest;						\
	}								\
	vdst->in_header = source->in_header;				\
	vdst->in_reserved2 = source->in_reserved2;			\
	ISP_SBUS_SWOZZLE(isp, source, vdst, in_lun, in_iid);		\
	ISP_SBUS_SWOZZLE(isp, source, vdst, in_rsvd, in_tgt);		\
	vdst->in_flags = source->in_flags;				\
	ISP_SBUS_SWOZZLE(isp, source, vdst, in_status, in_rsvd2);	\
	ISP_SBUS_SWOZZLE(isp, source, vdst, in_tag_val, in_tag_type);	\
	vdst->in_seqid = source->in_seqid;				\
	MEMCPY(vdst->in_msg, source->in_msg, IN_MSGLEN);		\
	MEMCPY(vdst->in_reserved, source->in_reserved, IN_RESERVED);	\
	MEMCPY(vdst->in_sense, source->in_sense, QLTM_SENSELEN);	\
d637 1
a637 1
#define	ISP_SWIZ_NOT_ACK(isp, dest)					\
d639 12
a650 16
	na_entry_t *source = (na_entry_t *)vsrc;			\
	na_entry_t *local, *vdst;					\
	if ((void *)dest == (void *)vsrc) {				\
		MEMCPY(vsrc, &local, sizeof (na_entry_t));		\
		vdst = &local;						\
	} else {							\
		vdst = dest;						\
	}								\
	vdst->na_header = source->na_header;				\
	vdst->na_reserved2 = source->na_reserved2;			\
	ISP_SBUS_SWOZZLE(isp, source, vdst, na_lun, na_iid);		\
	ISP_SBUS_SWOZZLE(isp, source, vdst, na_rsvd, na_tgt);		\
	vdst->na_flags = source->na_flags;				\
	ISP_SBUS_SWOZZLE(isp, source, vdst, na_status, na_event);	\
	vdst->na_seqid = source->na_seqid;				\
	MEMCPY(vdst->na_reserved, source->na_reserved, NA_RSVDLEN);	\
a651 3
#define	ISP_SWIZ_NOT_ACK_FC(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_ATIO2(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_CTIO2(isp, d, s)	MCIDF(d, s)
d654 1
d656 1
d658 2
d661 1
a663 2
#define	ISP_SWIZ_ATIO2(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_CTIO2(isp, d, s)	MCIDF(d, s)
d681 1
a681 1
int isp_target_notify __P((struct ispsoftc *, void *, u_int16_t *));
d688 1
a688 1
int isp_lun_cmd __P((struct ispsoftc *, int, int, int, int, u_int32_t));
d693 1
a693 1
int isp_target_put_entry __P((struct ispsoftc *isp, void *));
d698 2
d701 1
a701 2
int
isp_target_put_atio __P((struct ispsoftc *, int, int, int, int, int));
d707 1
a707 2
int
isp_endcmd __P((struct ispsoftc *, void *, u_int32_t, u_int32_t));
d714 1
a714 1
void isp_target_async __P((struct ispsoftc *, int, int));
d716 1
a716 1
#endif	/* _ISPTARGET_H */
@


1.3
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.h,v 1.2 2000/07/06 05:31:48 mjacob Exp $ */
d269 3
@


1.2
log
@Resync with FreeBSD/NetBSD. Salient features are that the mailbox command
routines are not necessarily polled now- this should cut down on some of
the spurious lost commands that have occurred. Also, we now watchdog each
command and make sure that command constipation doesn't occur (which it
has been documented to do on the QLA2100 cards).
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.h,v 1.1 2000/02/20 21:22:40 mjacob Exp $ */
d10 1
a10 1
 * Additional Copyright (c) 1999
d22 1
a22 4
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
d129 1
d139 1
d325 1
d344 2
d352 1
d508 1
a508 1
	ct_entry_t *source = (ct_entry-t *) vsrc;			\
a610 1
extern int isp_tdebug;
d612 1
a612 3
	if (isp_tdebug > 3) isp_print_qentry(isp, msg, idx, arg)

#define	ITDEBUG(level, msg)	if (isp_tdebug >= level) PRINTF msg
d627 1
a627 1
#define	DFLT_CMD_CNT	(RESULT_QUEUE_LEN >> 1)
@


1.1
log
@Add 12160 (Ultra3) support. Add files and changes for target mode support.
Do some SNS fabric suppor tchanges. Roll revision levels. Tested on
GENERIC i386 && sparc.
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
d74 1
d190 2
d629 1
a629 1
int isp_lun_cmd __P((struct ispsoftc *isp, int, int, int, int, u_int32_t));
d641 1
a641 1
isp_target_put_atio __P((struct ispsoftc *isp, int, int, int, int, int));
d648 1
a648 1
isp_endcmd __P((struct ispsoftc *isp, void *, u_int32_t, u_int32_t));
@


1.1.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.h,v 1.1 2000/02/20 21:22:40 mjacob Exp $ */
@


1.1.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* @@(#)isp_target.h 1.3 */
d10 1
a10 1
 * Additional Copyright (c) 1999, 2000, 2001
d22 4
a25 1
 * 2. The name of the author may not be used to endorse or promote products
d39 2
a40 2
#ifndef	_ISP_TARGET_H
#define	_ISP_TARGET_H
d72 1
a72 1
#define LUN_TQAE	0x00000002	/* bit1  Tagged Queue Action Enable */
a73 1
#define	LUN_DISAD	0x02000000	/* bit25 Disable autodisconnect */
a130 1
#define	IN_REJECT	0x0D	/* Message Reject message received */
a139 1
#define	IN_NO_NEXUS	0x3B	/* Nexus not established */
a188 2
#define	NA_OK		0x01	/* Notify Acknowledge Succeeded */
#define	NA_INVALID	0x06	/* Invalid Notify Acknowledge */
d213 1
a213 2
	u_int16_t	at_reserved;
	u_int16_t	at_handle;
d231 1
a231 1
#define AT_TQAE		0x00000002	/* Tagged Queue Action enabled */
a243 18
 * Macros to create and fetch and test concatenated handle and tag value macros
 */

#define	AT_MAKE_TAGID(tid, aep)						\
	tid = ((aep)->at_handle << 16);					\
	if ((aep)->at_flags & AT_TQAE)					\
		(tid) |= ((aep)->at_tag_val + 1)

#define	CT_MAKE_TAGID(tid, ct)						\
	tid = ((ct)->ct_fwhandle << 16);				\
	if ((ct)->ct_flags & CT_TQAE)					\
		(tid) |= ((ct)->ct_tag_val + 1)

#define	AT_HAS_TAG(val)		((val) & 0xffff)
#define	AT_GET_TAG(val)		AT_HAS_TAG(val) - 1
#define	AT_GET_HANDLE(val)	((val) >> 16)

/*
d263 3
a265 2
	u_int16_t	at_reserved2[10];
	u_int16_t	at_oxid;
a267 3
#define	ATIO2_WWPN_OFFSET	0x2A
#define	ATIO2_OXID_OFFSET	0x3E

d284 1
a284 3
	u_int16_t	ct_reserved;
#define	ct_syshandle	ct_reserved	/* we use this */
	u_int16_t	ct_fwhandle;	/* required by f/w */
d317 1
a317 1
#define CT_TQAE		0x00000002	/* bit  1, Tagged Queue Action enable */
a322 1
#define	CT_INISYNCWIDE	0x00004000	/* bit 14, Do Sync/Wide Negotiation */
a340 2
#define	CT_PARITY	0x0F	/* Uncorrectable Parity Error */
#define	CT_PANIC	0x13	/* Unrecoverable Error */
a346 1
#define	CT_IDE		0x33	/* Initiator Detected Error */
d370 1
a370 2
	u_int16_t	ct_reserved;
	u_int16_t	ct_fwhandle;	/* just to match CTIO */
d461 4
a464 5
#define	ISP_SBUS_SWOZZLE(isp, src, dst, taga, tagb)	\
	if (isp->isp_bustype == ISP_BT_SBUS) {	\
		u_int8_t tmp = src -> taga;	\
		dst -> taga =  dst -> tagb;	\
		src -> tagb =  tmp;		\
d466 2
a467 2
		dst -> taga =  src -> taga;	\
		dst -> tagb =  src -> taga;	\
d470 3
a472 3
#define	ISP_SBUS_SWOZZLE(isp, src, dst, taga, tagb)	\
		dst -> taga =  src -> taga;	\
		dst -> tagb =  src -> taga
d479 1
a479 1
#define	ISP_SWIZ_ATIO(isp, vdst, vsrc)					\
d481 17
a497 12
	at_entry_t *src = (at_entry_t *) vsrc;				\
	at_entry_t *dst = (at_entry_t *) vdst;				\
	dst->at_header = src->at_header;				\
	dst->at_reserved = src->at_reserved;				\
	dst->at_handle = src->at_handle;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_lun, at_iid);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_cdblen, at_tgt);		\
	dst->at_flags = src->at_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_status, at_scsi_status);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_tag_val, at_tag_type);	\
	MEMCPY(dst->at_cdb, src->at_cdb, ATIO_CDBLEN);			\
	MEMCPY(dst->at_sense, src->at_sense, QLTM_SENSELEN);		\
d499 2
a500 1
#define	ISP_SWIZ_ATIO2(isp, vdst, vsrc)					\
d502 22
a523 14
	at2_entry_t *src = (at2_entry_t *) vsrc;			\
	at2_entry_t *dst = (at2_entry_t *) vdst;			\
	dst->at_reserved = src->at_reserved;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_lun, at_iid);		\
	dst->at_rxid = src->at_rxid;					\
	dst->at_flags = src->at_flags;					\
	dst->at_status = src->at_status;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_reserved1, at_taskcodes);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, at_taskflags, at_execodes);	\
	MEMCPY(dst->at_cdb, src->at_cdb, ATIO2_CDBLEN);			\
	dst->at_datalen = src->at_datalen;				\
	dst->at_scclun = src->at_scclun;				\
	MEMCPY(dst->at_reserved2, src->at_reserved2, sizeof dst->at_reserved2);\
	dst->at_oxid = src->at_oxid;					\
d525 1
a525 1
#define	ISP_SWIZ_CTIO(isp, vdst, vsrc)					\
d527 18
a544 16
	ct_entry_t *src = (ct_entry_t *) vsrc;				\
	ct_entry_t *dst = (ct_entry_t *) vdst;				\
	dst->ct_header = src->ct_header;				\
	dst->ct_syshandle = src->ct_syshandle;				\
	dst->ct_fwhandle = src->ct_fwhandle;				\
	dst->ct_fwhandle = src->ct_fwhandle;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_lun, ct_iid);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_reserved2, ct_tgt);		\
	dst->ct_flags = src->ct_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_status, ct_scsi_status);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_tag_val, ct_tag_type);	\
	dst->ct_xfrlen = src->ct_xfrlen;				\
	dst->ct_resid = src->ct_resid;					\
	dst->ct_timeout = src->ct_timeout;				\
	dst->ct_seg_count = src->ct_seg_count;				\
	MEMCPY(dst->ct_dataseg, src->ct_dataseg, sizeof (dst->ct_dataseg)); \
d546 1
a546 1
#define	ISP_SWIZ_CTIO2(isp, vdst, vsrc)					\
d548 19
a566 15
	ct2_entry_t *src = (ct2_entry_t *) vsrc;			\
	ct2_entry_t *dst = (ct2_entry_t *) vdst;			\
	dst->ct_header = src->ct_header;				\
	dst->ct_syshandle = src->ct_syshandle;				\
	dst->ct_fwhandle = src->ct_fwhandle;				\
	dst->ct_fwhandle = src->ct_fwhandle;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, ct_lun, ct_iid);		\
	dst->ct_rxid = src->ct_rxid;					\
	dst->ct_flags = src->ct_flags;					\
	dst->ct_status = src->ct_status;				\
	dst->ct_timeout = src->ct_timeout;				\
	dst->ct_seg_count = src->ct_seg_count;				\
	dst->ct_reloff = src->ct_reloff;				\
	dst->ct_resid = src->ct_resid;					\
	dst->rsp = src->rsp;						\
d568 1
a568 1
#define	ISP_SWIZ_ENABLE_LUN(isp, vdst, vsrc)				\
d570 16
a585 70
	lun_entry_t *src = (lun_entry_t *)vsrc;				\
	lun_entry_t *dst = (lun_entry_t *)vdst;				\
	dst->le_header = src->le_header;				\
	dst->le_reserved2 = src->le_reserved2;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_lun, le_rsvd);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_ops, le_tgt);		\
	dst->le_flags = src->le_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_status, le_reserved2);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_cmd_count, le_in_count);	\
	ISP_SBUS_SWOZZLE(isp, src, dst, le_cdb6len, le_cdb7len);	\
	dst->le_timeout = src->le_timeout;				\
	dst->le_reserved = src->le_reserved;				\
}
#define	ISP_SWIZ_NOTIFY(isp, vdst, vsrc)				\
{									\
	in_entry_type *src = (in_entry_t *)vsrc;			\
	in_entry_type *dst = (in_entry_t *)vdst;			\
	dst->in_header = src->in_header;				\
	dst->in_reserved2 = src->in_reserved2;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_lun, in_iid);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_reserved2, in_tgt);		\
	dst->in_flags = src->in_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_status, in_rsvd2);		\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_tag_val, in_tag_type);	\
	dst->in_seqid = src->in_seqid;					\
	MEMCPY(dst->in_msg, src->in_msg, IN_MSGLEN);			\
	MEMCPY(dst->in_reserved, src->in_reserved, IN_RESERVED);	\
	MEMCPY(dst->in_sense, src->in_sense, QLTM_SENSELEN);		\
}
#define	ISP_SWIZ_NOTIFY_FC(isp, vdst, vsrc)				\
{									\
	in_fcentry_type *src = (in_fcentry_t *)vsrc;			\
	in_fcentry_type *dst = (in_fcentry_t *)vdst;			\
	dst->in_header = src->in_header;				\
	dst->in_reserved2 = src->in_reserved2;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, in_lun, in_iid);		\
	dst->in_scclun = src->in_scclun;				\
	dst->in_reserved2 = src->in_reserved2;				\
	dst->in_status = src->in_status;				\
	dst->in_task_flags = src->in_task_flags;			\
	dst->in_seqid = src->in_seqid;					\
}
#define	ISP_SWIZ_NOT_ACK(isp, vdst, vsrc)				\
{									\
	na_entry_t *src = (na_entry_t *)vsrc;				\
	na_entry_t *dst = (na_entry_t *)vdst;				\
	dst->na_header = src->na_header;				\
	dst->na_reserved = src->na_reserved;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, na_lun, na_iid);		\
	dst->na_reserved2 = src->na_reserved2;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, na_reserved, na_tgt);		\
	dst->na_flags = src->na_flags;					\
	ISP_SBUS_SWOZZLE(isp, src, dst, na_status, na_event);		\
	dst->na_seqid = src->na_seqid;					\
	MEMCPY(dst->na_reserved3, src->na_reserved3, NA_RSVDLEN);	\
}
#define	ISP_SWIZ_NOT_ACK_FC(isp, vdst, vsrc)				\
{									\
	na_fcentry_t *src = (na_fcentry_t *)vsrc;			\
	na_fcentry_t *dst = (na_fcentry_t *)vdst;			\
	dst->na_header = src->na_header;				\
	dst->na_reserved = src->na_reserved;				\
	ISP_SBUS_SWOZZLE(isp, src, dst, na_lun, na_iid);		\
	dst->na_scclun = src->na_scclun;				\
	dst->na_flags = src->na_flags;					\
	dst->na_reserved2 = src->na_reserved2;				\
	dst->na_status = src->na_status;				\
	dst->na_task_flags = src->na_task_flags;			\
	dst->na_seqid = src->na_seqid;					\
	MEMCPY(dst->na_reserved3, src->na_reserved3, NA2_RSVDLEN);	\
d587 3
a591 1
#define	ISP_SWIZ_ATIO2(isp, d, s)	MCIDF(d, s)
a592 1
#define	ISP_SWIZ_CTIO2(isp, d, s)	MCIDF(d, s)
a593 2
#define	ISP_SWIZ_ATIO2(isp, d, s)	MCIDF(d, s)
#define	ISP_SWIZ_CTIO2(isp, d, s)	MCIDF(d, s)
a594 1
#define	ISP_SWIZ_NOTIFY_FC(isp, d, s)	MCIDF(d, s)
d597 2
d605 1
d607 3
a609 1
    if (isp->isp_dblev & ISP_LOGTDEBUG2) isp_print_qentry(isp, msg, idx, arg)
d619 1
a619 1
int isp_target_notify(struct ispsoftc *, void *, u_int16_t *);
d624 1
a624 1
#define	DFLT_CMD_CNT	32	/* XX */
d626 1
a626 1
int isp_lun_cmd(struct ispsoftc *, int, int, int, int, u_int32_t);
d631 1
a631 1
int isp_target_put_entry(struct ispsoftc *isp, void *);
a635 2
 * The argument is a pointer to a source ATIO
 * or ATIO2.
d637 2
a638 1
int isp_target_put_atio(struct ispsoftc *, void *);
d644 2
a645 1
int isp_endcmd(struct ispsoftc *, void *, u_int32_t, u_int16_t);
d652 1
a652 1
void isp_target_async(struct ispsoftc *, int, int);
d654 1
a654 1
#endif	/* _ISP_TARGET_H */
@


1.1.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 2
/*	$OpenBSD$	*/

d336 2
a337 2
#define	SET_IID_VAL(y, x)	y = ((y & ~0x3f) | (x & 0x3f))
#define	SET_BUS_VAL(y, x)	y = ((y & 0x3f) | ((x & 0x1) << 7))
a363 1
#define	CT_DATA_OVER	0x09	/* (FC only) Data Overrun */
a367 1
#define	CT_BUS_ERROR	0x10	/* (FC Only) DMA PCI Error */
a370 1
#define	CT_DATA_UNDER	0x15	/* (FC only) Data Underrun */
a429 8
			/*
			 * For CTIO3, an ispds64_t would go here, padded
			 * to the end of the request.
			 */
			/*
			 * For CTIO4, an ispdlist_t would go here, padded
			 * to the end of the request.
			 */
a684 1
 * (softc, cmd, bus, tgt, lun, cmd_cnt, inotify_cnt, opaque)
d686 3
a688 3
#define	DFLT_CMND_CNT	32
#define	DFLT_INOT_CNT	4
int isp_lun_cmd(struct ispsoftc *, int, int, int, int, int, int, u_int32_t);
@


1.1.2.4
log
@Merge in trunk
@
text
@d325 1
a325 8
	/*
	 * This is so we can share tag name space with
	 * CTIO{2,3,4} with the minimum of pain.
	 */
	union {
		ispds_t		ct_a[ISP_RQDSEG];
	} _u;
#define	ct_dataseg	_u.ct_a
d418 1
a418 1
		 * can set the CTIO{2,3,4} up as.
d434 9
a442 8
			union {
				ispds_t ct_a[ISP_RQDSEG_T2];	/* CTIO2 */
				ispds64_t ct_b[ISP_RQDSEG_T3];	/* CTIO3 */
				ispdslist_t ct_c;		/* CTIO4 */
			} _u;
#define	ct_dataseg	_u.ct_a
#define	ct_dataseg64	_u.ct_b
#define	ct_dslist	_u.ct_c
d500 180
a685 1
#ifdef	ISP_TARGET_FUNCTIONS
d687 2
a688 2
 * The functions below are for the publicly available
 * target mode functions that are internal to the Qlogic driver.
d729 1
a729 1
#endif
@


1.1.2.5
log
@Sync the SMP branch with 3.3
@
text
@d285 2
a286 3
	u_int16_t	at_scclun;		/* SCC Lun or reserved */
	u_int16_t	at_wwpn[4];		/* WWPN of initiator */
	u_int16_t	at_reserved2[6];
d413 3
a415 3
	u_int8_t	ct_lun;		/* lun */
	u_int8_t	ct_iid;		/* initiator id */
	u_int16_t	ct_rxid;	/* response ID */
d527 2
a528 2
#define	DFLT_CMND_CNT	0xfe	/* unmonitored */
#define	DFLT_INOT_CNT	16
a552 2
 *
 * Return nonzero if the interrupt that generated this event has been dismissed.
d555 1
a555 1
int isp_target_async(struct ispsoftc *, int, int);
@


