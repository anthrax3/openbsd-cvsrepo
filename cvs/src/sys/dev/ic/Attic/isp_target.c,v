head	1.19;
access;
symbols
	OPENBSD_5_6:1.18.0.14
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.12
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.8
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.12
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.10
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.8
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.4
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.9
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.19
date	2014.10.12.14.11.09;	author jsg;	state dead;
branches;
next	1.18;
commitid	ki4keNKAzYOPtyEg;

1.18
date	2011.10.22.19.34.06;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.02.18.10.40.53;	author sobrado;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.18.09.44.18;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.03.20.58.46;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.03.18.34.59;	author mjacob;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.17.17.42.54;	author mjacob;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.17.01.33.50;	author mjacob;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.14.00.20.55;	author mjacob;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.10.06.22.45.52;	author mjacob;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.01.07.16.40;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.04.22.08.55;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.16.01.02.00;	author mjacob;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.06.05.31.48;	author mjacob;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.20.21.22.40;	author mjacob;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.02.21.22.29.05;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.05.14.22.23.55;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.02.19.10.56.19;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.21.54.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove some unused files
ok miod@@
@
text
@/* $OpenBSD: isp_target.c,v 1.18 2011/10/22 19:34:06 miod Exp $ */
/*-
 *  Copyright (c) 1997-2007 by Matthew Jacob
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 * 
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 *  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 */
/*
 * Machine and OS Independent Target Mode Code for the QLogic SCSI/FC adapters.
 */
/*
 * Bug fixes gratefully acknowledged from:
 *	Oded Kedem <oded@@kashya.com>
 */
/*
 * Include header file appropriate for platform we're building on.
 */

#ifdef	__NetBSD__
#include <dev/ic/isp_netbsd.h>
#endif
#ifdef	__FreeBSD__
#include <sys/cdefs.h>
__FBSDID("$FreeBSD: src/sys/dev/isp/isp_target.c,v 1.45 2007/10/12 06:03:43 kevlo Exp $");
#include <dev/isp/isp_freebsd.h>
#endif
#ifdef	__OpenBSD__
#include <dev/ic/isp_openbsd.h>
#endif
#ifdef	__linux__
#include "isp_linux.h"
#endif

#ifdef	ISP_TARGET_MODE
static const char atiocope[] =
    "ATIO returned for lun %d because it was in the middle of Bus Device Reset "
    "on bus %d";
static const char atior[] =
    "ATIO returned on for lun %d on from loopid %d because a Bus Reset "
    "occurred on bus %d";

static void isp_got_msg(ispsoftc_t *, in_entry_t *);
static void isp_got_msg_fc(ispsoftc_t *, in_fcentry_t *);
static void isp_got_tmf_24xx(ispsoftc_t *, at7_entry_t *);
static void isp_handle_atio(ispsoftc_t *, at_entry_t *);
static void isp_handle_atio2(ispsoftc_t *, at2_entry_t *);
static void isp_handle_ctio(ispsoftc_t *, ct_entry_t *);
static void isp_handle_ctio2(ispsoftc_t *, ct2_entry_t *);
static void isp_handle_ctio7(ispsoftc_t *, ct7_entry_t *);

/*
 * The QLogic driver gets an interrupt to look at response queue entries.
 * Some of these are status completions for initiatior mode commands, but
 * if target mode is enabled, we get a whole wad of response queue entries
 * to be handled here.
 *
 * Basically the split into 3 main groups: Lun Enable/Modification responses,
 * SCSI Command processing, and Immediate Notification events.
 *
 * You start by writing a request queue entry to enable target mode (and
 * establish some resource limitations which you can modify later).
 * The f/w responds with a LUN ENABLE or LUN MODIFY response with
 * the status of this action. If the enable was successful, you can expect...
 *
 * Response queue entries with SCSI commands encapsulate show up in an ATIO
 * (Accept Target IO) type- sometimes with enough info to stop the command at
 * this level. Ultimately the driver has to feed back to the f/w's request
 * queue a sequence of CTIOs (continue target I/O) that describe data to
 * be moved and/or status to be sent) and finally finishing with sending
 * to the f/w's response queue an ATIO which then completes the handshake
 * with the f/w for that command. There's a lot of variations on this theme,
 * including flags you can set in the CTIO for the QLogic 2X00 fibre channel
 * cards that 'auto-replenish' the f/w's ATIO count, but this is the basic
 * gist of it.
 *
 * The third group that can show up in the response queue are Immediate
 * Notification events. These include things like notifications of SCSI bus
 * resets, or Bus Device Reset messages or other messages received. This
 * a classic oddbins area. It can get  a little weird because you then turn
 * around and acknowledge the Immediate Notify by writing an entry onto the
 * request queue and then the f/w turns around and gives you an acknowledgement
 * to *your* acknowledgement on the response queue (the idea being to let
 * the f/w tell you when the event is *really* over I guess).
 *
 */


/*
 * A new response queue entry has arrived. The interrupt service code
 * has already swizzled it into the platform dependent from canonical form.
 *
 * Because of the way this driver is designed, unfortunately most of the
 * actual synchronization work has to be done in the platform specific
 * code- we have no synchroniation primitives in the common code.
 */

int
isp_target_notify(ispsoftc_t *isp, void *vptr, uint32_t *optrp)
{
	uint16_t status;
	uint32_t seqid;
	union {
		at_entry_t	*atiop;
		at2_entry_t	*at2iop;
		at2e_entry_t	*at2eiop;
		at7_entry_t	*at7iop;
		ct_entry_t	*ctiop;
		ct2_entry_t	*ct2iop;
		ct2e_entry_t	*ct2eiop;
		ct7_entry_t	*ct7iop;
		lun_entry_t	*lunenp;
		in_entry_t	*inotp;
		in_fcentry_t	*inot_fcp;
		in_fcentry_e_t	*inote_fcp;
		in_fcentry_24xx_t *inot_24xx;
		na_entry_t	*nackp;
		na_fcentry_t	*nack_fcp;
		na_fcentry_e_t	*nacke_fcp;
		na_fcentry_24xx_t *nack_24xx;
		isphdr_t	*hp;
		abts_t		*abts;
		abts_rsp_t	*abts_rsp;
		els_t		*els;
		void *		*vp;
#define	atiop		unp.atiop
#define	at2iop		unp.at2iop
#define	at2eiop		unp.at2eiop
#define	at7iop		unp.at7iop
#define	ctiop		unp.ctiop
#define	ct2iop		unp.ct2iop
#define	ct2eiop		unp.ct2eiop
#define	ct7iop		unp.ct7iop
#define	lunenp		unp.lunenp
#define	inotp		unp.inotp
#define	inot_fcp	unp.inot_fcp
#define	inote_fcp	unp.inote_fcp
#define	inot_24xx	unp.inot_24xx
#define	nackp		unp.nackp
#define	nack_fcp	unp.nack_fcp
#define	nacke_fcp	unp.nacke_fcp
#define	nack_24xx	unp.nack_24xx
#define	abts		unp.abts
#define	abts_rsp	unp.abts_rsp
#define els		unp.els
#define	hdrp		unp.hp
	} unp;
	uint8_t local[QENTRY_LEN];
	int bus, type, level, rval = 1;

	type = isp_get_response_type(isp, (isphdr_t *)vptr);
	unp.vp = vptr;

	ISP_TDQE(isp, "isp_target_notify", (int) *optrp, vptr);

	switch(type) {
	case RQSTYPE_ATIO:
		if (IS_24XX(isp)) {
			int len;

			isp_get_atio7(isp, at7iop, (at7_entry_t *) local);
			at7iop = (at7_entry_t *) local;
			/*
			 * Check for and do something with commands whose IULEN
			 * extends past a singel queue entry.
			 */
			len = at7iop->at_ta_len & 0xfffff;
			if (len > (QENTRY_LEN - 8)) {
				len -= (QENTRY_LEN - 8);
				isp_prt(isp, ISP_LOGINFO,
				    "long IU length (%d) ignored", len);
				while (len > 0) {
					*optrp =  ISP_NXT_QENTRY(*optrp,
					    RESULT_QUEUE_LEN(isp));
					len -= QENTRY_LEN;
				}
			}
			/*
			 * Check for a task management function
			 */
			if (at7iop->at_cmnd.fcp_cmnd_task_management) {
				isp_got_tmf_24xx(isp, at7iop);
				break;
			}
			/*
			 * Just go straight to outer layer for this one.
			 */
			(void) isp_async(isp, ISPASYNC_TARGET_ACTION, local);
		} else {
			isp_get_atio(isp, atiop, (at_entry_t *) local);
			isp_handle_atio(isp, (at_entry_t *) local);
		}
		break;

	case RQSTYPE_CTIO:
		isp_get_ctio(isp, ctiop, (ct_entry_t *) local);
		isp_handle_ctio(isp, (ct_entry_t *) local);
		break;

	case RQSTYPE_ATIO2:
		if (FCPARAM(isp)->isp_2klogin) {
			isp_get_atio2e(isp, at2eiop, (at2e_entry_t *) local);
		} else {
			isp_get_atio2(isp, at2iop, (at2_entry_t *) local);
		}
		isp_handle_atio2(isp, (at2_entry_t *) local);
		break;

	case RQSTYPE_CTIO3:
	case RQSTYPE_CTIO2:
		if (FCPARAM(isp)->isp_2klogin) {
			isp_get_ctio2e(isp, ct2eiop, (ct2e_entry_t *) local);
		} else {
			isp_get_ctio2(isp, ct2iop, (ct2_entry_t *) local);
		}
		isp_handle_ctio2(isp, (ct2_entry_t *) local);
		break;

	case RQSTYPE_CTIO7:
		isp_get_ctio7(isp, ct7iop, (ct7_entry_t *) local);
		isp_handle_ctio7(isp, (ct7_entry_t *) local);
		break;

	case RQSTYPE_ENABLE_LUN:
	case RQSTYPE_MODIFY_LUN:
		isp_get_enable_lun(isp, lunenp, (lun_entry_t *) local);
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, local);
		break;

	case RQSTYPE_NOTIFY:
		/*
		 * Either the ISP received a SCSI message it can't
		 * handle, or it's returning an Immed. Notify entry
		 * we sent. We can send Immed. Notify entries to
		 * increment the firmware's resource count for them
		 * (we set this initially in the Enable Lun entry).
		 */
		bus = 0;
		if (IS_24XX(isp)) {
			isp_get_notify_24xx(isp, inot_24xx,
			    (in_fcentry_24xx_t *)local);
			inot_24xx = (in_fcentry_24xx_t *) local;
			status = inot_24xx->in_status;
			seqid = inot_24xx->in_rxid;
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGTDEBUG0,
			    "Immediate Notify status=0x%x seqid=0x%x",
			    status, seqid);
#endif
			switch (status) {
			case IN24XX_LIP_RESET:
			case IN24XX_LINK_RESET:
			case IN24XX_PORT_LOGOUT:
			case IN24XX_PORT_CHANGED:
			case IN24XX_LINK_FAILED:
			case IN24XX_SRR_RCVD:
			case IN24XX_ELS_RCVD:
				(void) isp_async(isp, ISPASYNC_TARGET_ACTION,
				    &local);
				break;
			default:
				isp_prt(isp, ISP_LOGINFO,
				    "isp_target_notify: unknown status (0x%x)",
				    status);
				isp_notify_ack(isp, local);
				break;
			}
			break;
		} else if (IS_FC(isp)) {
			if (FCPARAM(isp)->isp_2klogin) {
				isp_get_notify_fc_e(isp, inote_fcp,
				    (in_fcentry_e_t *)local);
			} else {
				isp_get_notify_fc(isp, inot_fcp,
				    (in_fcentry_t *)local);
			}
			inot_fcp = (in_fcentry_t *) local;
			status = inot_fcp->in_status;
			seqid = inot_fcp->in_seqid;
		} else {
			isp_get_notify(isp, inotp, (in_entry_t *)local);
			inotp = (in_entry_t *) local;
			status = inotp->in_status & 0xff;
			seqid = inotp->in_seqid;
			if (IS_DUALBUS(isp)) {
				bus = GET_BUS_VAL(inotp->in_iid);
				SET_BUS_VAL(inotp->in_iid, 0);
			}
		}

#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGTDEBUG0,
		    "Immediate Notify On Bus %d, status=0x%x seqid=0x%x",
		    bus, status, seqid);
#endif

		switch (status) {
		case IN_MSG_RECEIVED:
		case IN_IDE_RECEIVED:
			if (IS_FC(isp)) {
				isp_got_msg_fc(isp, (in_fcentry_t *)local);
			} else {
				isp_got_msg(isp, (in_entry_t *)local);
			}
			break;
		case IN_RSRC_UNAVAIL:
			isp_prt(isp, ISP_LOGINFO, "Firmware out of ATIOs");
			isp_notify_ack(isp, local);
			break;
		case IN_RESET:
		{
			/*
			 * We form the notify structure here because we need
			 * to mark it as needing a NOTIFY ACK on return.
			 */
			tmd_notify_t notify;

			MEMZERO(&notify, sizeof (tmd_notify_t));
			notify.nt_hba = isp;
			notify.nt_iid = INI_ANY;
			/* nt_tgt set in outer layers */
			notify.nt_lun = LUN_ANY;
			notify.nt_tagval = TAG_ANY;
			notify.nt_ncode = NT_BUS_RESET;
			notify.nt_need_ack = 1;
			(void) isp_async(isp, ISPASYNC_TARGET_NOTIFY, &notify);
			break;
		}
		case IN_PORT_LOGOUT:
		case IN_ABORT_TASK:
		case IN_PORT_CHANGED:
		case IN_GLOBAL_LOGO:
			(void) isp_async(isp, ISPASYNC_TARGET_ACTION, &local);
			break;
		default:
			isp_prt(isp, ISP_LOGINFO,
			    "isp_target_notify: unknown status (0x%x)",
			    status);
			isp_notify_ack(isp, local);
			break;
		}
		break;

	case RQSTYPE_NOTIFY_ACK:
		/*
		 * The ISP is acknowledging our acknowledgement of an
		 * Immediate Notify entry for some asynchronous event.
		 */
		if (IS_24XX(isp)) {
			isp_get_notify_ack_24xx(isp, nack_24xx,
			    (na_fcentry_24xx_t *) local);
			nack_24xx = (na_fcentry_24xx_t *) local;
			if (nack_24xx->na_status != NA_OK) {
				level = ISP_LOGINFO;
			} else {
				level = ISP_LOGTDEBUG1;
			}
			isp_prt(isp, level,
			    "Notify Ack Status=0x%x; Subcode 0x%x seqid=0x%x",
			    nack_24xx->na_status, nack_24xx->na_status_subcode,
			    nack_24xx->na_rxid);
		} else if (IS_FC(isp)) {
			if (FCPARAM(isp)->isp_2klogin) {
				isp_get_notify_ack_fc_e(isp, nacke_fcp,
				    (na_fcentry_e_t *)local);
			} else {
				isp_get_notify_ack_fc(isp, nack_fcp,
				    (na_fcentry_t *)local);
			}
			nack_fcp = (na_fcentry_t *)local;
			if (nack_fcp->na_status != NA_OK) {
				level = ISP_LOGINFO;
			} else {
				level = ISP_LOGTDEBUG1;
			}
			isp_prt(isp, level,
			    "Notify Ack Status=0x%x seqid 0x%x",
			    nack_fcp->na_status, nack_fcp->na_seqid);
		} else {
			isp_get_notify_ack(isp, nackp, (na_entry_t *)local);
			nackp = (na_entry_t *)local;
			if (nackp->na_status != NA_OK) {
				level = ISP_LOGINFO;
			} else {
				level = ISP_LOGTDEBUG1;
			}
			isp_prt(isp, level,
			    "Notify Ack event 0x%x status=0x%x seqid 0x%x",
			    nackp->na_event, nackp->na_status, nackp->na_seqid);
		}
		break;

	case RQSTYPE_ABTS_RCVD:
		isp_get_abts(isp, abts, (abts_t *)local);
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, &local);
		break;
	case RQSTYPE_ABTS_RSP:
		isp_get_abts_rsp(isp, abts_rsp, (abts_rsp_t *)local);
		abts_rsp = (abts_rsp_t *) local;
		if (abts_rsp->abts_rsp_status) {
			level = ISP_LOGINFO;
		} else {
			level = ISP_LOGTDEBUG0;
		}
		isp_prt(isp, level,
		    "ABTS RSP response[0x%x]: status=0x%x sub=(0x%x 0x%x)",
		    abts_rsp->abts_rsp_rxid_task, abts_rsp->abts_rsp_status,
		    abts_rsp->abts_rsp_payload.rsp.subcode1,
		    abts_rsp->abts_rsp_payload.rsp.subcode2);
		break;
	default:
		isp_prt(isp, ISP_LOGERR,
		    "Unknown entry type 0x%x in isp_target_notify", type);
		rval = 0;
		break;
	}
#undef	atiop
#undef	at2iop
#undef	at2eiop
#undef	at7iop
#undef	ctiop
#undef	ct2iop
#undef	ct2eiop
#undef	ct7iop
#undef	lunenp
#undef	inotp
#undef	inot_fcp
#undef	inote_fcp
#undef	inot_24xx
#undef	nackp
#undef	nack_fcp
#undef	nacke_fcp
#undef	hack_24xx
#undef	abts
#undef	abts_rsp
#undef	els
#undef	hdrp
	return (rval);
}

 
/*
 * Toggle (on/off) target mode for bus/target/lun
 *
 * The caller has checked for overlap and legality.
 *
 * Note that not all of bus, target or lun can be paid attention to.
 * Note also that this action will not be complete until the f/w writes
 * response entry. The caller is responsible for synchronizing this.
 */
int
isp_lun_cmd(ispsoftc_t *isp, int cmd, int bus, int tgt, int lun,
    int cmd_cnt, int inot_cnt, uint32_t opaque)
{
	lun_entry_t el;
	uint32_t nxti, optr;
	void *outp;


	MEMZERO(&el, sizeof (el));
	if (IS_DUALBUS(isp)) {
		el.le_rsvd = (bus & 0x1) << 7;
	}
	el.le_cmd_count = cmd_cnt;
	el.le_in_count = inot_cnt;
	if (cmd == RQSTYPE_ENABLE_LUN) {
		if (IS_SCSI(isp)) {
			el.le_flags = LUN_TQAE|LUN_DISAD;
			el.le_cdb6len = 12;
			el.le_cdb7len = 12;
		}
	} else if (cmd == -RQSTYPE_ENABLE_LUN) {
		cmd = RQSTYPE_ENABLE_LUN;
		el.le_cmd_count = 0;
		el.le_in_count = 0;
	} else if (cmd == -RQSTYPE_MODIFY_LUN) {
		cmd = RQSTYPE_MODIFY_LUN;
		el.le_ops = LUN_CCDECR | LUN_INDECR;
	} else {
		el.le_ops = LUN_CCINCR | LUN_ININCR;
	}
	el.le_header.rqs_entry_type = cmd;
	el.le_header.rqs_entry_count = 1;
	el.le_reserved = opaque;
	if (IS_SCSI(isp)) {
		el.le_tgt = tgt;
		el.le_lun = lun;
	} else if (FCPARAM(isp)->isp_sccfw == 0) {
		el.le_lun = lun;
	}
	el.le_timeout = 30;

	if (isp_getrqentry(isp, &nxti, &optr, &outp)) {
		isp_prt(isp, ISP_LOGERR,
		    "Request Queue Overflow in isp_lun_cmd");
		return (-1);
	}
	ISP_TDQE(isp, "isp_lun_cmd", (int) optr, &el);
	isp_put_enable_lun(isp, &el, outp);
	ISP_ADD_REQUEST(isp, nxti);
	return (0);
}


int
isp_target_put_entry(ispsoftc_t *isp, void *ap)
{
	void *outp;
	uint32_t nxti, optr;
	uint8_t etype = ((isphdr_t *) ap)->rqs_entry_type;

	if (isp_getrqentry(isp, &nxti, &optr, &outp)) {
		isp_prt(isp, ISP_LOGWARN,
		    "Request Queue Overflow in isp_target_put_entry");
		return (-1);
	}
	switch (etype) {
	case RQSTYPE_ATIO:
		isp_put_atio(isp, (at_entry_t *) ap, (at_entry_t *) outp);
		break;
	case RQSTYPE_ATIO2:
		if (FCPARAM(isp)->isp_2klogin) {
			isp_put_atio2e(isp, (at2e_entry_t *) ap,
			    (at2e_entry_t *) outp);
		} else {
			isp_put_atio2(isp, (at2_entry_t *) ap,
			    (at2_entry_t *) outp);
		}
		break;
	case RQSTYPE_CTIO:
		isp_put_ctio(isp, (ct_entry_t *) ap, (ct_entry_t *) outp);
		break;
	case RQSTYPE_CTIO2:
		if (FCPARAM(isp)->isp_2klogin) {
			isp_put_ctio2e(isp, (ct2e_entry_t *) ap,
			    (ct2e_entry_t *) outp);
		} else {
			isp_put_ctio2(isp, (ct2_entry_t *) ap,
			    (ct2_entry_t *) outp);
		}
		break;
	case RQSTYPE_CTIO7:
		isp_put_ctio7(isp, (ct7_entry_t *) ap, (ct7_entry_t *) outp);
		break;
	default:
		isp_prt(isp, ISP_LOGERR,
		    "Unknown type 0x%x in isp_put_entry", etype);
		return (-1);
	}
	ISP_TDQE(isp, "isp_target_put_entry", (int) optr, ap);
	ISP_ADD_REQUEST(isp, nxti);
	return (0);
}

int
isp_target_put_atio(ispsoftc_t *isp, void *arg)
{
	union {
		at_entry_t _atio;
		at2_entry_t _atio2;
		at2e_entry_t _atio2e;
	} atun;

	MEMZERO(&atun, sizeof atun);
	if (IS_FC(isp)) {
		at2_entry_t *aep = arg;
		atun._atio2.at_header.rqs_entry_type = RQSTYPE_ATIO2;
		atun._atio2.at_header.rqs_entry_count = 1;
		if (FCPARAM(isp)->isp_sccfw) {
			atun._atio2.at_scclun = aep->at_scclun;
		} else {
			atun._atio2.at_lun = (uint8_t) aep->at_lun;
		}
		if (FCPARAM(isp)->isp_2klogin) {
			atun._atio2e.at_iid = ((at2e_entry_t *)aep)->at_iid;
		} else {
			atun._atio2.at_iid = aep->at_iid;
		}
		atun._atio2.at_rxid = aep->at_rxid;
		atun._atio2.at_status = CT_OK;
	} else {
		at_entry_t *aep = arg;
		atun._atio.at_header.rqs_entry_type = RQSTYPE_ATIO;
		atun._atio.at_header.rqs_entry_count = 1;
		atun._atio.at_handle = aep->at_handle;
		atun._atio.at_iid = aep->at_iid;
		atun._atio.at_tgt = aep->at_tgt;
		atun._atio.at_lun = aep->at_lun;
		atun._atio.at_tag_type = aep->at_tag_type;
		atun._atio.at_tag_val = aep->at_tag_val;
		atun._atio.at_status = (aep->at_flags & AT_TQAE);
		atun._atio.at_status |= CT_OK;
	}
	return (isp_target_put_entry(isp, &atun));
}

/*
 * Command completion- both for handling cases of no resources or
 * no blackhole driver, or other cases where we have to, inline,
 * finish the command sanely, or for normal command completion.
 *
 * The 'completion' code value has the scsi status byte in the low 8 bits.
 * If status is a CHECK CONDITION and bit 8 is nonzero, then bits 12..15 have
 * the sense key and  bits 16..23 have the ASCQ and bits 24..31 have the ASC
 * values.
 *
 * NB: the key, asc, ascq, cannot be used for parallel SCSI as it doesn't
 * NB: inline SCSI sense reporting. As such, we lose this information. XXX.
 *
 * For both parallel && fibre channel, we use the feature that does
 * an automatic resource autoreplenish so we don't have then later do
 * put of an atio to replenish the f/w's resource count.
 */

int
isp_endcmd(ispsoftc_t *isp, void *arg, uint32_t code, uint32_t hdl)
{
	int sts;
	union {
		ct_entry_t _ctio;
		ct2_entry_t _ctio2;
		ct2e_entry_t _ctio2e;
		ct7_entry_t _ctio7;
	} un;

	MEMZERO(&un, sizeof un);
	sts = code & 0xff;

	if (IS_24XX(isp)) {
		at7_entry_t *aep = arg;
		ct7_entry_t *cto = &un._ctio7;

		cto->ct_header.rqs_entry_type = RQSTYPE_CTIO7;
		cto->ct_header.rqs_entry_count = 1;
/* XXXX */	cto->ct_nphdl = aep->at_hdr.seq_id;
		cto->ct_rxid = aep->at_rxid;
		cto->ct_iid_lo = (aep->at_hdr.s_id[1] << 8) |
		    aep->at_hdr.s_id[2];
		cto->ct_iid_hi = aep->at_hdr.s_id[0];
		cto->ct_oxid = aep->at_hdr.ox_id;
		cto->ct_scsi_status = sts;
		cto->ct_flags = CT7_FLAG_MODE1 | CT7_NO_DATA | CT7_SENDSTATUS;
		if (sts == SCSI_CHECK && (code & ECMD_SVALID)) {
			cto->rsp.m1.ct_resplen = 16;
			cto->rsp.m1.ct_resp[0] = 0xf0;
			cto->rsp.m1.ct_resp[2] = (code >> 12) & 0xf;
			cto->rsp.m1.ct_resp[7] = 8;
			cto->rsp.m1.ct_resp[12] = (code >> 24) & 0xff;
			cto->rsp.m1.ct_resp[13] = (code >> 16) & 0xff;
		}
		if (aep->at_cmnd.cdb_dl.sf.fcp_cmnd_dl) {
			cto->ct_resid = aep->at_cmnd.cdb_dl.sf.fcp_cmnd_dl;
			cto->ct_scsi_status |= CT2_DATA_UNDER;
		}
		cto->ct_syshandle = hdl;
	} else if (IS_FC(isp)) {
		at2_entry_t *aep = arg;
		ct2_entry_t *cto = &un._ctio2;

		cto->ct_header.rqs_entry_type = RQSTYPE_CTIO2;
		cto->ct_header.rqs_entry_count = 1;
		if (FCPARAM(isp)->isp_sccfw == 0) {
			cto->ct_lun = aep->at_lun;
		}
		if (FCPARAM(isp)->isp_2klogin) {
			un._ctio2e.ct_iid = ((at2e_entry_t *)aep)->at_iid;
		} else {
			cto->ct_iid = aep->at_iid;
		}
		cto->ct_rxid = aep->at_rxid;
		cto->rsp.m1.ct_scsi_status = sts;
		cto->ct_flags = CT2_SENDSTATUS | CT2_NO_DATA | CT2_FLAG_MODE1;
		if (hdl == 0) {
			cto->ct_flags |= CT2_CCINCR;
		}
		if (aep->at_datalen) {
			cto->ct_resid = aep->at_datalen;
			cto->rsp.m1.ct_scsi_status |= CT2_DATA_UNDER;
		}
		if (sts == SCSI_CHECK && (code & ECMD_SVALID)) {
			cto->rsp.m1.ct_resp[0] = 0xf0;
			cto->rsp.m1.ct_resp[2] = (code >> 12) & 0xf;
			cto->rsp.m1.ct_resp[7] = 8;
			cto->rsp.m1.ct_resp[12] = (code >> 24) & 0xff;
			cto->rsp.m1.ct_resp[13] = (code >> 16) & 0xff;
			cto->rsp.m1.ct_senselen = 16;
			cto->rsp.m1.ct_scsi_status |= CT2_SNSLEN_VALID;
		}
		cto->ct_syshandle = hdl;
	} else {
		at_entry_t *aep = arg;
		ct_entry_t *cto = &un._ctio;

		cto->ct_header.rqs_entry_type = RQSTYPE_CTIO;
		cto->ct_header.rqs_entry_count = 1;
		cto->ct_fwhandle = aep->at_handle;
		cto->ct_iid = aep->at_iid;
		cto->ct_tgt = aep->at_tgt;
		cto->ct_lun = aep->at_lun;
		cto->ct_tag_type = aep->at_tag_type;
		cto->ct_tag_val = aep->at_tag_val;
		if (aep->at_flags & AT_TQAE) {
			cto->ct_flags |= CT_TQAE;
		}
		cto->ct_flags = CT_SENDSTATUS | CT_NO_DATA;
		if (hdl == 0) {
			cto->ct_flags |= CT_CCINCR;
		}
		cto->ct_scsi_status = sts;
		cto->ct_syshandle = hdl;
	}
	return (isp_target_put_entry(isp, &un));
}

/*
 * These are either broadcast events or specifically CTIO fast completion
 */
int
isp_target_async(ispsoftc_t *isp, int bus, int event)
{
	tmd_notify_t notify;

	MEMZERO(&notify, sizeof (tmd_notify_t));
	notify.nt_hba = isp;
	notify.nt_iid = INI_ANY;
	/* nt_tgt set in outer layers */
	notify.nt_lun = LUN_ANY;
	notify.nt_tagval = TAG_ANY;

	if (IS_SCSI(isp)) {
		TAG_INSERT_BUS(notify.nt_tagval, bus);
	}

	switch (event) {
	case ASYNC_LOOP_UP:
	case ASYNC_PTPMODE:
		notify.nt_ncode = NT_LINK_UP;
		(void) isp_async(isp, ISPASYNC_TARGET_NOTIFY, &notify);
		break;
	case ASYNC_LOOP_DOWN:
		notify.nt_ncode = NT_LINK_DOWN;
		(void) isp_async(isp, ISPASYNC_TARGET_NOTIFY, &notify);
		break;
	case ASYNC_LIP_ERROR:
	case ASYNC_LIP_F8:
	case ASYNC_LIP_OCCURRED:
	case ASYNC_LOOP_RESET:
		notify.nt_ncode = NT_LIP_RESET;
		(void) isp_async(isp, ISPASYNC_TARGET_NOTIFY, &notify);
		break;
	case ASYNC_BUS_RESET:
	case ASYNC_TIMEOUT_RESET:	/* XXX: where does this come from ? */
		notify.nt_ncode = NT_BUS_RESET;
		(void) isp_async(isp, ISPASYNC_TARGET_NOTIFY, &notify);
		break;
	case ASYNC_DEVICE_RESET:
		notify.nt_ncode = NT_TARGET_RESET;
		(void) isp_async(isp, ISPASYNC_TARGET_NOTIFY, &notify);
		break;
	case ASYNC_CTIO_DONE:
	{
		uint8_t storage[QENTRY_LEN];
		memset(storage, 0, QENTRY_LEN);
		if (IS_24XX(isp)) {
			ct7_entry_t *ct = (ct7_entry_t *) storage;
			ct->ct_header.rqs_entry_type = RQSTYPE_CTIO7;
			ct->ct_nphdl = CT7_OK;
			ct->ct_syshandle = bus;
			ct->ct_flags = CT7_SENDSTATUS|CT7_FASTPOST;
		} else if (IS_FC(isp)) {
            		/* This should also suffice for 2K login code */
			ct2_entry_t *ct = (ct2_entry_t *) storage;
			ct->ct_header.rqs_entry_type = RQSTYPE_CTIO2;
			ct->ct_status = CT_OK;
			ct->ct_syshandle = bus;
			ct->ct_flags = CT2_SENDSTATUS|CT2_FASTPOST;
		} else {
			ct_entry_t *ct = (ct_entry_t *) storage;
			ct->ct_header.rqs_entry_type = RQSTYPE_CTIO;
			ct->ct_status = CT_OK;
			ct->ct_fwhandle = bus;
			ct->ct_flags = CT_SENDSTATUS;
		}
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, storage);
		break;
	}
	default:
		isp_prt(isp, ISP_LOGERR,
		    "isp_target_async: unknown event 0x%x", event);
		if (isp->isp_state == ISP_RUNSTATE) {
			isp_notify_ack(isp, NULL);
		}
		break;
	}
	return (0);
}


/*
 * Process a received message.
 * The ISP firmware can handle most messages, there are only
 * a few that we need to deal with:
 * - abort: clean up the current command
 * - abort tag and clear queue
 */

static void
isp_got_msg(ispsoftc_t *isp, in_entry_t *inp)
{
	tmd_notify_t nt;
	uint8_t status = inp->in_status & ~QLTM_SVALID;

	MEMZERO(&nt, sizeof (nt));
	nt.nt_hba = isp;
	nt.nt_iid = GET_IID_VAL(inp->in_iid);
	nt.nt_tgt = inp->in_tgt;
	nt.nt_lun = inp->in_lun;
	IN_MAKE_TAGID(nt.nt_tagval, GET_BUS_VAL(inp->in_iid), 0, inp);
	nt.nt_lreserved = inp;

	if (status == IN_IDE_RECEIVED || status == IN_MSG_RECEIVED) {
		switch (inp->in_msg[0]) {
		case MSG_ABORT:
			nt.nt_ncode = NT_ABORT_TASK_SET;
			break;
		case MSG_BUS_DEV_RESET:
			nt.nt_ncode = NT_TARGET_RESET;
			break;
		case MSG_ABORT_TAG:
			nt.nt_ncode = NT_ABORT_TASK;
			break;
		case MSG_CLEAR_QUEUE:
			nt.nt_ncode = NT_CLEAR_TASK_SET;
			break;
		case MSG_REL_RECOVERY:
			nt.nt_ncode = NT_CLEAR_ACA;
			break;
		case MSG_TERM_IO_PROC:
			nt.nt_ncode = NT_ABORT_TASK;
			break;
		case MSG_LUN_RESET:
			nt.nt_ncode = NT_LUN_RESET;
			break;
		default:
			isp_prt(isp, ISP_LOGERR,
			    "unhandled message 0x%x", inp->in_msg[0]);
			isp_notify_ack(isp, inp);
			return;
		}
		(void) isp_async(isp, ISPASYNC_TARGET_NOTIFY, &nt);
	} else {
		isp_prt(isp, ISP_LOGERR,
		    "unknown immediate notify status 0x%x", inp->in_status);
		isp_notify_ack(isp, inp);
	}
}

/*
 * Synthesize a message from the task management flags in a FCP_CMND_IU.
 */
static void
isp_got_msg_fc(ispsoftc_t *isp, in_fcentry_t *inp)
{
	tmd_notify_t nt;
	static const char f1[] = "%s from N-port handle 0x%x lun %d seq 0x%x";
	static const char f2[] = "unknown %s 0x%x lun %d N-Port handle 0x%x "
	    "task flags 0x%x seq 0x%x\n";
	uint16_t seqid, loopid;

	MEMZERO(&nt, sizeof (tmd_notify_t));
	nt.nt_hba = isp;
	if (FCPARAM(isp)->isp_2klogin) {
		nt.nt_iid = ((in_fcentry_e_t *)inp)->in_iid;
		loopid = ((in_fcentry_e_t *)inp)->in_iid;
		seqid = ((in_fcentry_e_t *)inp)->in_seqid;
	} else {
		nt.nt_iid = inp->in_iid;
		loopid = inp->in_iid;
		seqid = inp->in_seqid;
	}
	/* nt_tgt set in outer layers */
	if (FCPARAM(isp)->isp_sccfw) {
		nt.nt_lun = inp->in_scclun;
	} else {
		nt.nt_lun = inp->in_lun;
	}
	IN_FC_MAKE_TAGID(nt.nt_tagval, 0, 0, seqid);
	nt.nt_need_ack = 1;
	nt.nt_lreserved = inp;

	if (inp->in_status != IN_MSG_RECEIVED) {
		isp_prt(isp, ISP_LOGINFO, f2, "immediate notify status",
		    inp->in_status, nt.nt_lun, loopid, inp->in_task_flags,
		    inp->in_seqid);
		isp_notify_ack(isp, inp);
		return;
	}

	if (inp->in_task_flags & TASK_FLAGS_ABORT_TASK_SET) {
		isp_prt(isp, ISP_LOGINFO, f1, "ABORT TASK SET",
		    loopid, nt.nt_lun, inp->in_seqid);
		nt.nt_ncode = NT_ABORT_TASK_SET;
	} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_TASK_SET) {
		isp_prt(isp, ISP_LOGINFO, f1, "CLEAR TASK SET",
		    loopid, nt.nt_lun, inp->in_seqid);
		nt.nt_ncode = NT_CLEAR_TASK_SET;
	} else if (inp->in_task_flags & TASK_FLAGS_LUN_RESET) {
		isp_prt(isp, ISP_LOGINFO, f1, "LUN RESET",
		    loopid, nt.nt_lun, inp->in_seqid);
		nt.nt_ncode = NT_LUN_RESET;
	} else if (inp->in_task_flags & TASK_FLAGS_TARGET_RESET) {
		isp_prt(isp, ISP_LOGINFO, f1, "TARGET RESET",
		    loopid, nt.nt_lun, inp->in_seqid);
		nt.nt_ncode = NT_TARGET_RESET;
	} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_ACA) {
		isp_prt(isp, ISP_LOGINFO, f1, "CLEAR ACA",
		    loopid, nt.nt_lun, inp->in_seqid);
		nt.nt_ncode = NT_CLEAR_ACA;
	} else {
		isp_prt(isp, ISP_LOGWARN, f2, "task flag", inp->in_status,
		    nt.nt_lun, loopid, inp->in_task_flags,  inp->in_seqid);
		isp_notify_ack(isp, inp);
		return;
	}
	(void) isp_async(isp, ISPASYNC_TARGET_NOTIFY, &nt);
}

#define	HILO(x)	(uint32_t) (x >> 32),  (uint32_t) x
static void
isp_got_tmf_24xx(ispsoftc_t *isp, at7_entry_t *aep)
{
	tmd_notify_t nt;
	static const char f1[] =
	    "%s from PortID 0x%06x lun %d seq 0x%08x%08x";
	static const char f2[] = 
	    "unknown Task Flag 0x%x lun %d PortID 0x%x tag 0x%08x%08x";
	uint32_t sid;

	MEMZERO(&nt, sizeof (tmd_notify_t));
	nt.nt_hba = isp;
	nt.nt_iid = INI_ANY;
	nt.nt_lun =
	    (aep->at_cmnd.fcp_cmnd_lun[0] << 8) |
	    (aep->at_cmnd.fcp_cmnd_lun[1]);
	/*
	 * XXX: VPIDX HAS TO BE DERIVED FROM DESTINATION PORT
	 */
	nt.nt_tagval = aep->at_rxid;
	nt.nt_lreserved = aep;
	sid =
	    (aep->at_hdr.s_id[0] << 16) |
	    (aep->at_hdr.s_id[1] <<  8) |
	    (aep->at_hdr.s_id[2]);

	if (aep->at_cmnd.fcp_cmnd_task_management &
	    FCP_CMND_TMF_ABORT_TASK_SET) {
		isp_prt(isp, ISP_LOGINFO, f1, "ABORT TASK SET",
		    sid, nt.nt_lun, HILO(nt.nt_tagval));
		nt.nt_ncode = NT_ABORT_TASK_SET;
	} else if (aep->at_cmnd.fcp_cmnd_task_management &
	    FCP_CMND_TMF_CLEAR_TASK_SET) {
		isp_prt(isp, ISP_LOGINFO, f1, "CLEAR TASK SET",
		    sid, nt.nt_lun, HILO(nt.nt_tagval));
		nt.nt_ncode = NT_CLEAR_TASK_SET;
	} else if (aep->at_cmnd.fcp_cmnd_task_management &
	    FCP_CMND_TMF_LUN_RESET) {
		isp_prt(isp, ISP_LOGINFO, f1, "LUN RESET",
		    sid, nt.nt_lun, HILO(nt.nt_tagval));
		nt.nt_ncode = NT_LUN_RESET;
	} else if (aep->at_cmnd.fcp_cmnd_task_management &
	    FCP_CMND_TMF_TGT_RESET) {
		isp_prt(isp, ISP_LOGINFO, f1, "TARGET RESET",
		    sid, nt.nt_lun, HILO(nt.nt_tagval));
		nt.nt_ncode = NT_TARGET_RESET;
		nt.nt_lun = LUN_ANY;
	} else if (aep->at_cmnd.fcp_cmnd_task_management &
	    FCP_CMND_TMF_CLEAR_ACA) {
		isp_prt(isp, ISP_LOGINFO, f1, "CLEAR ACA",
		    sid, nt.nt_lun, HILO(nt.nt_tagval));
		nt.nt_ncode = NT_CLEAR_ACA;
	} else {
		isp_prt(isp, ISP_LOGWARN, f2,
		    aep->at_cmnd.fcp_cmnd_task_management,
		    nt.nt_lun, sid, HILO(nt.nt_tagval));
		isp_endcmd(isp, aep, 0, 0);
		return;
	}
	(void) isp_async(isp, ISPASYNC_TARGET_NOTIFY, &nt);
}

void
isp_notify_ack(ispsoftc_t *isp, void *arg)
{
	char storage[QENTRY_LEN];
	uint32_t nxti, optr;
	void *outp;

	if (isp_getrqentry(isp, &nxti, &optr, &outp)) {
		isp_prt(isp, ISP_LOGWARN,
		    "Request Queue Overflow For isp_notify_ack");
		return;
	}

	MEMZERO(storage, QENTRY_LEN);

	if (IS_24XX(isp) && arg != NULL && (((isphdr_t *)arg)->rqs_entry_type == RQSTYPE_ATIO)) {
		at7_entry_t *aep = arg;
		isp_endcmd(isp, aep, 0, 0);
		return;
	} else if (IS_24XX(isp) && arg != NULL && (((isphdr_t *)arg)->rqs_entry_type == RQSTYPE_ABTS_RSP)) {
		abts_rsp_t *abts_rsp = (abts_rsp_t *) storage;
		/*
		 * The caller will have set response values as appropriate
		 * in the ABTS structure just before calling us.
		 */
		MEMCPY(abts_rsp, arg, QENTRY_LEN);
		isp_put_abts_rsp(isp, abts_rsp, (abts_rsp_t *)outp);
	} else if (IS_24XX(isp)) {
		na_fcentry_24xx_t *na = (na_fcentry_24xx_t *) storage;
		if (arg) {
			in_fcentry_24xx_t *in = arg;
			na->na_nphdl = in->in_nphdl;
			na->na_status = in->in_status;
			na->na_status_subcode = in->in_status_subcode;
			na->na_rxid = in->in_rxid;
			na->na_oxid = in->in_oxid;
			if (in->in_status == IN24XX_SRR_RCVD) {
				na->na_srr_rxid = in->in_srr_rxid;
				na->na_srr_reloff_hi = in->in_srr_reloff_hi;
				na->na_srr_reloff_lo = in->in_srr_reloff_lo;
				na->na_srr_iu = in->in_srr_iu;
				na->na_srr_flags = 1;
				na->na_srr_reject_vunique = 0;
				na->na_srr_reject_explanation = 1;
				na->na_srr_reject_code = 1;
			}
		}
		na->na_header.rqs_entry_type = RQSTYPE_NOTIFY_ACK;
		na->na_header.rqs_entry_count = 1;
		isp_put_notify_24xx_ack(isp, na, (na_fcentry_24xx_t *)outp);
	} else if (IS_FC(isp)) {
		na_fcentry_t *na = (na_fcentry_t *) storage;
		int iid = 0;

		if (arg) {
			in_fcentry_t *inp = arg;
			MEMCPY(storage, arg, sizeof (isphdr_t));
			if (FCPARAM(isp)->isp_2klogin) {
				((na_fcentry_e_t *)na)->na_iid =
				    ((in_fcentry_e_t *)inp)->in_iid;
				iid = ((na_fcentry_e_t *)na)->na_iid;
			} else {
				na->na_iid = inp->in_iid;
				iid = na->na_iid;
			}
			na->na_task_flags =
			    inp->in_task_flags & TASK_FLAGS_RESERVED_MASK;
			na->na_seqid = inp->in_seqid;
			na->na_flags = NAFC_RCOUNT;
			na->na_status = inp->in_status;
			if (inp->in_status == IN_RESET) {
				na->na_flags |= NAFC_RST_CLRD;
			}
			if (inp->in_status == IN_MSG_RECEIVED) {
				na->na_flags |= NAFC_TVALID;
				na->na_response = 0;	/* XXX SUCCEEDED XXX */
			}
		} else {
			na->na_flags = NAFC_RST_CLRD;
		}
		na->na_header.rqs_entry_type = RQSTYPE_NOTIFY_ACK;
		na->na_header.rqs_entry_count = 1;
		if (FCPARAM(isp)->isp_2klogin) {
			isp_put_notify_ack_fc_e(isp, (na_fcentry_e_t *) na,
			    (na_fcentry_e_t *)outp);
		} else {
			isp_put_notify_ack_fc(isp, na, (na_fcentry_t *)outp);
		}
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGTDEBUG0, "notify ack loopid %u seqid %x "
		    "flags %x tflags %x response %x", iid, na->na_seqid,
		    na->na_flags, na->na_task_flags, na->na_response);
#endif
	} else {
		na_entry_t *na = (na_entry_t *) storage;
		if (arg) {
			in_entry_t *inp = arg;
			MEMCPY(storage, arg, sizeof (isphdr_t));
			na->na_iid = inp->in_iid;
			na->na_lun = inp->in_lun;
			na->na_tgt = inp->in_tgt;
			na->na_seqid = inp->in_seqid;
			if (inp->in_status == IN_RESET) {
				na->na_event = NA_RST_CLRD;
			}
		} else {
			na->na_event = NA_RST_CLRD;
		}
		na->na_header.rqs_entry_type = RQSTYPE_NOTIFY_ACK;
		na->na_header.rqs_entry_count = 1;
		isp_put_notify_ack(isp, na, (na_entry_t *)outp);
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGTDEBUG0, "notify ack loopid %u lun %u tgt "
		    "%u seqid %x event %x", na->na_iid, na->na_lun, na->na_tgt,
		    na->na_seqid, na->na_event);
#endif
	}
	ISP_TDQE(isp, "isp_notify_ack", (int) optr, storage);
	ISP_ADD_REQUEST(isp, nxti);
}

static void
isp_handle_atio(ispsoftc_t *isp, at_entry_t *aep)
{
	int lun;
	lun = aep->at_lun;
	/*
	 * The firmware status (except for the QLTM_SVALID bit) indicates
	 * why this ATIO was sent to us.
	 *
	 * If QLTM_SVALID is set, the firware has recommended Sense Data.
	 *
	 * If the DISCONNECTS DISABLED bit is set in the flags field,
	 * we're still connected on the SCSI bus - i.e. the initiator
	 * did not set DiscPriv in the identify message. We don't care
	 * about this so it's ignored.
	 */

	switch(aep->at_status & ~QLTM_SVALID) {
	case AT_PATH_INVALID:
		/*
		 * ATIO rejected by the firmware due to disabled lun.
		 */
		isp_prt(isp, ISP_LOGERR,
		    "rejected ATIO for disabled lun %d", lun);
		break;
	case AT_NOCAP:
		/*
		 * Requested Capability not available
		 * We sent an ATIO that overflowed the firmware's
		 * command resource count.
		 */
		isp_prt(isp, ISP_LOGERR,
		    "rejected ATIO for lun %d because of command count"
		    " overflow", lun);
		break;

	case AT_BDR_MSG:
		/*
		 * If we send an ATIO to the firmware to increment
		 * its command resource count, and the firmware is
		 * recovering from a Bus Device Reset, it returns
		 * the ATIO with this status. We set the command
		 * resource count in the Enable Lun entry and do
		 * not increment it. Therefore we should never get
		 * this status here.
		 */
		isp_prt(isp, ISP_LOGERR, atiocope, lun,
		    GET_BUS_VAL(aep->at_iid));
		break;

	case AT_CDB:		/* Got a CDB */
	case AT_PHASE_ERROR:	/* Bus Phase Sequence Error */
		/*
		 * Punt to platform specific layer.
		 */
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, aep);
		break;

	case AT_RESET:
		/*
		 * A bus reset came along and blew away this command. Why
		 * they do this in addition the async event code stuff,
		 * I dunno.
		 *
		 * Ignore it because the async event will clear things
		 * up for us.
		 */
		isp_prt(isp, ISP_LOGWARN, atior, lun,
		    GET_IID_VAL(aep->at_iid), GET_BUS_VAL(aep->at_iid));
		break;


	default:
		isp_prt(isp, ISP_LOGERR,
		    "Unknown ATIO status 0x%x from loopid %d for lun %d",
		    aep->at_status, aep->at_iid, lun);
		(void) isp_target_put_atio(isp, aep);
		break;
	}
}

static void
isp_handle_atio2(ispsoftc_t *isp, at2_entry_t *aep)
{
	int lun, iid;

	if (FCPARAM(isp)->isp_sccfw) {
		lun = aep->at_scclun;
	} else {
		lun = aep->at_lun;
	}

	if (FCPARAM(isp)->isp_2klogin) {
		iid = ((at2e_entry_t *)aep)->at_iid;
	} else {
		iid = aep->at_iid;
	}

	/*
	 * The firmware status (except for the QLTM_SVALID bit) indicates
	 * why this ATIO was sent to us.
	 *
	 * If QLTM_SVALID is set, the firware has recommended Sense Data.
	 *
	 * If the DISCONNECTS DISABLED bit is set in the flags field,
	 * we're still connected on the SCSI bus - i.e. the initiator
	 * did not set DiscPriv in the identify message. We don't care
	 * about this so it's ignored.
	 */

	switch(aep->at_status & ~QLTM_SVALID) {
	case AT_PATH_INVALID:
		/*
		 * ATIO rejected by the firmware due to disabled lun.
		 */
		isp_prt(isp, ISP_LOGERR,
		    "rejected ATIO2 for disabled lun %d", lun);
		break;
	case AT_NOCAP:
		/*
		 * Requested Capability not available
		 * We sent an ATIO that overflowed the firmware's
		 * command resource count.
		 */
		isp_prt(isp, ISP_LOGERR,
		    "rejected ATIO2 for lun %d- command count overflow", lun);
		break;

	case AT_BDR_MSG:
		/*
		 * If we send an ATIO to the firmware to increment
		 * its command resource count, and the firmware is
		 * recovering from a Bus Device Reset, it returns
		 * the ATIO with this status. We set the command
		 * resource count in the Enable Lun entry and no
		 * not increment it. Therefore we should never get
		 * this status here.
		 */
		isp_prt(isp, ISP_LOGERR, atiocope, lun, 0);
		break;

	case AT_CDB:		/* Got a CDB */
		/*
		 * Punt to platform specific layer.
		 */
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, aep);
		break;

	case AT_RESET:
		/*
		 * A bus reset came along an blew away this command. Why
		 * they do this in addition the async event code stuff,
		 * I dunno.
		 *
		 * Ignore it because the async event will clear things
		 * up for us.
		 */
		isp_prt(isp, ISP_LOGERR, atior, lun, iid, 0);
		break;


	default:
		isp_prt(isp, ISP_LOGERR,
		    "Unknown ATIO2 status 0x%x from loopid %d for lun %d",
		    aep->at_status, iid, lun);
		(void) isp_target_put_atio(isp, aep);
		break;
	}
}

static void
isp_handle_ctio(ispsoftc_t *isp, ct_entry_t *ct)
{
	void *xs;
	int pl = ISP_LOGTDEBUG2;
	char *fmsg = NULL;

	if (ct->ct_syshandle) {
		xs = isp_find_xs_tgt(isp, ct->ct_syshandle);
		if (xs == NULL) {
			pl = ISP_LOGALL;
		}
	} else {
		xs = NULL;
	}

	switch(ct->ct_status & ~QLTM_SVALID) {
	case CT_OK:
		/*
		 * There are generally 3 possibilities as to why we'd get
		 * this condition:
		 * 	We disconnected after receiving a CDB.
		 * 	We sent or received data.
		 * 	We sent status & command complete.
		 */

		if (ct->ct_flags & CT_SENDSTATUS) {
			break;
		} else if ((ct->ct_flags & CT_DATAMASK) == CT_NO_DATA) {
			/*
			 * Nothing to do in this case.
			 */
			isp_prt(isp, pl, "CTIO- iid %d disconnected OK",
			    ct->ct_iid);
			return;
		}
		break;

	case CT_BDR_MSG:
		/*
		 * Bus Device Reset message received or the SCSI Bus has
		 * been Reset; the firmware has gone to Bus Free.
		 *
		 * The firmware generates an async mailbox interrupt to
		 * notify us of this and returns outstanding CTIOs with this
		 * status. These CTIOs are handled in that same way as
		 * CT_ABORTED ones, so just fall through here.
		 */
		fmsg = "Bus Device Reset";
		/*FALLTHROUGH*/
	case CT_RESET:
		if (fmsg == NULL)
			fmsg = "Bus Reset";
		/*FALLTHROUGH*/
	case CT_ABORTED:
		/*
		 * When an Abort message is received the firmware goes to
		 * Bus Free and returns all outstanding CTIOs with the status
		 * set, then sends us an Immediate Notify entry.
		 */
		if (fmsg == NULL)
			fmsg = "ABORT TAG message sent by Initiator";

#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGTDEBUG0, "CTIO destroyed by %s", fmsg);
#endif
		break;

	case CT_INVAL:
		/*
		 * CTIO rejected by the firmware due to disabled lun.
		 * "Cannot Happen".
		 */
		isp_prt(isp, ISP_LOGERR,
		    "Firmware rejected CTIO for disabled lun %d",
		    ct->ct_lun);
		break;

	case CT_NOPATH:
		/*
		 * CTIO rejected by the firmware due "no path for the
		 * nondisconnecting nexus specified". This means that
		 * we tried to access the bus while a non-disconnecting
		 * command is in process.
		 */
		isp_prt(isp, ISP_LOGERR,
		    "Firmware rejected CTIO for bad nexus %d/%d/%d",
		    ct->ct_iid, ct->ct_tgt, ct->ct_lun);
		break;

	case CT_RSELTMO:
		fmsg = "Reselection";
		/*FALLTHROUGH*/
	case CT_TIMEOUT:
		if (fmsg == NULL)
			fmsg = "Command";
		isp_prt(isp, ISP_LOGERR, "Firmware timed out on %s", fmsg);
		break;

	case	CT_PANIC:
		if (fmsg == NULL)
			fmsg = "Unrecoverable Error";
		/*FALLTHROUGH*/
	case CT_ERR:
		if (fmsg == NULL)
			fmsg = "Completed with Error";
		/*FALLTHROUGH*/
	case CT_PHASE_ERROR:
		if (fmsg == NULL)
			fmsg = "Phase Sequence Error";
		/*FALLTHROUGH*/
	case CT_TERMINATED:
		if (fmsg == NULL)
			fmsg = "terminated by TERMINATE TRANSFER";
		/*FALLTHROUGH*/
	case CT_NOACK:
		if (fmsg == NULL)
			fmsg = "unacknowledged Immediate Notify pending";
		isp_prt(isp, ISP_LOGERR, "CTIO returned by f/w- %s", fmsg);
		break;
	default:
		isp_prt(isp, ISP_LOGERR, "Unknown CTIO status 0x%x",
		    ct->ct_status & ~QLTM_SVALID);
		break;
	}

	if (xs == NULL) {
		/*
		 * There may be more than one CTIO for a data transfer,
		 * or this may be a status CTIO we're not monitoring.
		 *
		 * The assumption is that they'll all be returned in the
		 * order we got them.
		 */
		if (ct->ct_syshandle == 0) {
			if ((ct->ct_flags & CT_SENDSTATUS) == 0) {
				isp_prt(isp, pl,
				    "intermediate CTIO completed ok");
			} else {
				isp_prt(isp, pl,
				    "unmonitored CTIO completed ok");
			}
		} else {
			isp_prt(isp, pl,
			    "NO xs for CTIO (handle 0x%x) status 0x%x",
			    ct->ct_syshandle, ct->ct_status & ~QLTM_SVALID);
		}
	} else {
		/*
		 * Final CTIO completed. Release DMA resources and
		 * notify platform dependent layers.
		 */
		if ((ct->ct_flags & CT_DATAMASK) != CT_NO_DATA) {
			ISP_DMAFREE(isp, xs, ct->ct_syshandle);
		}
		isp_prt(isp, pl, "final CTIO complete");
		/*
		 * The platform layer will destroy the handle if appropriate.
		 */
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);
	}
}

static void
isp_handle_ctio2(ispsoftc_t *isp, ct2_entry_t *ct)
{
	void *xs;
	int pl = ISP_LOGTDEBUG2;
	char *fmsg = NULL;

	if (ct->ct_syshandle) {
		xs = isp_find_xs_tgt(isp, ct->ct_syshandle);
		if (xs == NULL) {
			pl = ISP_LOGALL;
		}
	} else {
		xs = NULL;
	}

	switch(ct->ct_status & ~QLTM_SVALID) {
	case CT_BUS_ERROR:
		isp_prt(isp, ISP_LOGERR, "PCI DMA Bus Error");
		/* FALLTHROUGH */
	case CT_DATA_OVER:
	case CT_DATA_UNDER:
	case CT_OK:
		/*
		 * There are generally 2 possibilities as to why we'd get
		 * this condition:
		 * 	We sent or received data.
		 * 	We sent status & command complete.
		 */

		break;

	case CT_BDR_MSG:
		/*
		 * Target Reset function received.
		 *
		 * The firmware generates an async mailbox interrupt to
		 * notify us of this and returns outstanding CTIOs with this
		 * status. These CTIOs are handled in that same way as
		 * CT_ABORTED ones, so just fall through here.
		 */
		fmsg = "TARGET RESET";
		/*FALLTHROUGH*/
	case CT_RESET:
		if (fmsg == NULL)
			fmsg = "LIP Reset";
		/*FALLTHROUGH*/
	case CT_ABORTED:
		/*
		 * When an Abort message is received the firmware goes to
		 * Bus Free and returns all outstanding CTIOs with the status
		 * set, then sends us an Immediate Notify entry.
		 */
		if (fmsg == NULL) {
			fmsg = "ABORT";
		}

#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGTDEBUG0,
		    "CTIO2 destroyed by %s: RX_ID=0x%x", fmsg, ct->ct_rxid);
#endif
		break;

	case CT_INVAL:
		/*
		 * CTIO rejected by the firmware - invalid data direction.
		 */
		isp_prt(isp, ISP_LOGERR, "CTIO2 had wrong data direction");
		break;

	case CT_RSELTMO:
		fmsg = "failure to reconnect to initiator";
		/*FALLTHROUGH*/
	case CT_TIMEOUT:
		if (fmsg == NULL)
			fmsg = "command";
		isp_prt(isp, ISP_LOGERR, "Firmware timed out on %s", fmsg);
		break;

	case CT_ERR:
		fmsg = "Completed with Error";
		/*FALLTHROUGH*/
	case CT_LOGOUT:
		if (fmsg == NULL)
			fmsg = "Port Logout";
		/*FALLTHROUGH*/
	case CT_PORTUNAVAIL:
		if (fmsg == NULL)
			fmsg = "Port not available";
		/*FALLTHROUGH*/
	case CT_PORTCHANGED:
		if (fmsg == NULL)
			fmsg = "Port Changed";
		/*FALLTHROUGH*/
	case CT_NOACK:
		if (fmsg == NULL)
			fmsg = "unacknowledged Immediate Notify pending";
		isp_prt(isp, ISP_LOGWARN, "CTIO returned by f/w- %s", fmsg);
		break;

	case CT_INVRXID:
		/*
		 * CTIO rejected by the firmware because an invalid RX_ID.
		 * Just print a message.
		 */
		isp_prt(isp, ISP_LOGWARN,
		    "CTIO2 completed with Invalid RX_ID 0x%x", ct->ct_rxid);
		break;

	default:
		isp_prt(isp, ISP_LOGERR, "Unknown CTIO2 status 0x%x",
		    ct->ct_status & ~QLTM_SVALID);
		break;
	}

	if (xs == NULL) {
		/*
		 * There may be more than one CTIO for a data transfer,
		 * or this may be a status CTIO we're not monitoring.
		 *
		 * The assumption is that they'll all be returned in the
		 * order we got them.
		 */
		if (ct->ct_syshandle == 0) {
			if ((ct->ct_flags & CT2_SENDSTATUS) == 0) {
				isp_prt(isp, pl,
				    "intermediate CTIO completed ok");
			} else {
				isp_prt(isp, pl,
				    "unmonitored CTIO completed ok");
			}
		} else {
			isp_prt(isp, pl,
			    "NO xs for CTIO (handle 0x%x) status 0x%x",
			    ct->ct_syshandle, ct->ct_status & ~QLTM_SVALID);
		}
	} else {
		if ((ct->ct_flags & CT2_DATAMASK) != CT2_NO_DATA) {
			ISP_DMAFREE(isp, xs, ct->ct_syshandle);
		}
		if (ct->ct_flags & CT2_SENDSTATUS) {
			/*
			 * Sent status and command complete.
			 *
			 * We're now really done with this command, so we
			 * punt to the platform dependent layers because
			 * only there can we do the appropriate command
			 * complete thread synchronization.
			 */
			isp_prt(isp, pl, "status CTIO complete");
		} else {
			/*
			 * Final CTIO completed. Release DMA resources and
			 * notify platform dependent layers.
			 */
			isp_prt(isp, pl, "data CTIO complete");
		}
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);
		/*
		 * The platform layer will destroy the handle if appropriate.
		 */
	}
}

static void
isp_handle_ctio7(ispsoftc_t *isp, ct7_entry_t *ct)
{
	void *xs;
	int pl = ISP_LOGTDEBUG2;
	char *fmsg = NULL;

	if (ct->ct_syshandle) {
		xs = isp_find_xs_tgt(isp, ct->ct_syshandle);
		if (xs == NULL) {
			pl = ISP_LOGALL;
		}
	} else {
		xs = NULL;
	}

	switch(ct->ct_nphdl) {
	case CT7_BUS_ERROR:
		isp_prt(isp, ISP_LOGERR, "PCI DMA Bus Error");
		/* FALL Through */
	case CT7_DATA_OVER:
	case CT7_DATA_UNDER:
	case CT7_OK:
		/*
		 * There are generally 2 possibilities as to why we'd get
		 * this condition:
		 * 	We sent or received data.
		 * 	We sent status & command complete.
		 */

		break;

	case CT7_RESET:
		if (fmsg == NULL) {
			fmsg = "LIP Reset";
		}
		/*FALLTHROUGH*/
	case CT7_ABORTED:
		/*
		 * When an Abort message is received the firmware goes to
		 * Bus Free and returns all outstanding CTIOs with the status
		 * set, then sends us an Immediate Notify entry.
		 */
		if (fmsg == NULL) {
			fmsg = "ABORT";
		}
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGTDEBUG0,
		    "CTIO7 destroyed by %s: RX_ID=0x%x", fmsg, ct->ct_rxid);
#endif
		break;

	case CT7_TIMEOUT:
		if (fmsg == NULL) {
			fmsg = "command";
		}
		isp_prt(isp, ISP_LOGERR, "Firmware timed out on %s", fmsg);
		break;

	case CT7_ERR:
		fmsg = "Completed with Error";
		/*FALLTHROUGH*/
	case CT7_LOGOUT:
		if (fmsg == NULL) {
			fmsg = "Port Logout";
		}
		/*FALLTHROUGH*/
	case CT7_PORTUNAVAIL:
		if (fmsg == NULL) {
			fmsg = "Port not available";
		}
		/*FALLTHROUGH*/
	case CT7_PORTCHANGED:
		if (fmsg == NULL) {
			fmsg = "Port Changed";
		}
		isp_prt(isp, ISP_LOGWARN, "CTIO returned by f/w- %s", fmsg);
		break;

	case CT7_INVRXID:
		/*
		 * CTIO rejected by the firmware because an invalid RX_ID.
		 * Just print a message.
		 */
		isp_prt(isp, ISP_LOGWARN,
		    "CTIO7 completed with Invalid RX_ID 0x%x", ct->ct_rxid);
		break;

	case CT7_REASSY_ERR:
		isp_prt(isp, ISP_LOGWARN, "reassembly error");
		break;

	case CT7_SRR:
		isp_prt(isp, ISP_LOGWARN, "SRR received");
		break;

	default:
		isp_prt(isp, ISP_LOGERR, "Unknown CTIO7 status 0x%x",
		    ct->ct_nphdl);
		break;
	}

	if (xs == NULL) {
		/*
		 * There may be more than one CTIO for a data transfer,
		 * or this may be a status CTIO we're not monitoring.
		 *
		 * The assumption is that they'll all be returned in the
		 * order we got them.
		 */
		if (ct->ct_syshandle == 0) {
			if (ct->ct_flags & CT7_TERMINATE) {
				isp_prt(isp, ISP_LOGINFO,
				    "termination of 0x%x complete",
				    ct->ct_rxid);
			} else if ((ct->ct_flags & CT7_SENDSTATUS) == 0) {
				isp_prt(isp, pl,
				    "intermediate CTIO completed ok");
			} else {
				isp_prt(isp, pl,
				    "unmonitored CTIO completed ok");
			}
		} else {
			isp_prt(isp, pl,
			    "NO xs for CTIO (handle 0x%x) status 0x%x",
			    ct->ct_syshandle, ct->ct_nphdl);
		}
	} else {
		if ((ct->ct_flags & CT2_DATAMASK) != CT2_NO_DATA) {
			ISP_DMAFREE(isp, xs, ct->ct_syshandle);
		}
		if (ct->ct_flags & CT2_SENDSTATUS) {
			/*
			 * Sent status and command complete.
			 *
			 * We're now really done with this command, so we
			 * punt to the platform dependent layers because
			 * only there can we do the appropriate command
			 * complete thread synchronization.
			 */
			isp_prt(isp, pl, "status CTIO complete");
		} else {
			/*
			 * Final CTIO completed. Release DMA resources and
			 * notify platform dependent layers.
			 */
			isp_prt(isp, pl, "data CTIO complete");
		}
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);
		/*
		 * The platform layer will destroy the handle if appropriate.
		 */
	}
}
#endif
@


1.18
log
@Comment out ISP_{T,}DEBUG[0-3] traces if option SMALL_KERNEL; allows alpha
floppyB to fit again. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.17 2010/02/18 10:40:53 sobrado Exp $ */
@


1.17
log
@fix a few capitalizations of QLogic.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.16 2009/06/24 11:00:53 krw Exp $ */
d264 1
d268 1
d310 1
d314 1
d1098 1
d1102 1
d1121 1
d1125 1
d1364 1
d1366 1
d1521 1
d1524 1
d1674 1
d1677 1
@


1.16
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.15 2008/01/21 20:00:33 sobrado Exp $ */
d29 1
a29 1
 * Machine and OS Independent Target Mode Code for the Qlogic SCSI/FC adapters.
d72 1
a72 1
 * The Qlogic driver gets an interrupt to look at response queue entries.
d92 1
a92 1
 * including flags you can set in the CTIO for the Qlogic 2X00 fibre channel
@


1.15
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 27
a27 1
/* $OpenBSD: isp_target.c,v 1.14 2007/02/14 00:53:48 jsg Exp $ */
d29 1
a29 26
 * Machine and OS Independent Target Mode Code for the QLogic SCSI/FC adapters.
 *
 * Copyright (c) 1999, 2000, 2001 by Matthew Jacob
 * All rights reserved.
 * mjacob@@feral.com
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a30 1

d43 2
d59 2
a60 2
    "ATIO returned on for lun %d on from IID %d because a Bus Reset occurred "
    "on bus %d";
d62 8
a69 7
static void isp_got_msg(struct ispsoftc *, int, in_entry_t *);
static void isp_got_msg_fc(struct ispsoftc *, int, in_fcentry_t *);
static void isp_notify_ack(struct ispsoftc *, void *);
static void isp_handle_atio(struct ispsoftc *, at_entry_t *);
static void isp_handle_atio2(struct ispsoftc *, at2_entry_t *);
static void isp_handle_ctio(struct ispsoftc *, ct_entry_t *);
static void isp_handle_ctio2(struct ispsoftc *, ct2_entry_t *);
d72 1
a72 1
 * The QLogic driver gets an interrupt to look at response queue entries.
d92 1
a92 1
 * including flags you can set in the CTIO for the QLogic 2X00 fibre channel
d113 2
a114 2
 * actual synchronization work has to be done in the platform-specific
 * code - we have no synchronization primitives in the common code.
d118 1
a118 1
isp_target_notify(struct ispsoftc *isp, void *vptr, u_int16_t *optrp)
d120 2
a121 1
	u_int16_t status, seqid;
d125 2
d129 2
d134 2
d138 2
d141 3
d147 2
d151 2
d156 2
d160 5
d167 2
a168 2
	u_int8_t local[QENTRY_LEN];
	int bus, type, rval = 1;
d177 35
a211 2
		isp_get_atio(isp, atiop, (at_entry_t *) local);
		isp_handle_atio(isp, (at_entry_t *) local);
d213 1
d218 1
d220 5
a224 1
		isp_get_atio2(isp, at2iop, (at2_entry_t *) local);
d227 2
d230 5
a234 1
		isp_get_ctio2(isp, ct2iop, (ct2_entry_t *) local);
d237 6
d258 36
a293 2
		if (IS_FC(isp)) {
			isp_get_notify_fc(isp, inot_fcp, (in_fcentry_t *)local);
d307 1
a311 4
		/*
		 * ACK it right away.
		 */
		isp_notify_ack(isp, (status == IN_RESET)? NULL : local);
a312 3
		case IN_RESET:
			(void) isp_async(isp, ISPASYNC_BUS_RESET, &bus);
			break;
d316 1
a316 1
				isp_got_msg_fc(isp, bus, (in_fcentry_t *)local);
d318 1
a318 1
				isp_got_msg(isp, bus, (in_entry_t *)local);
d322 2
a323 1
			isp_prt(isp, ISP_LOGWARN, "Firmware out of ATIOs");
d325 19
d351 4
a354 2
			isp_prt(isp, ISP_LOGERR,
			    "bad status (0x%x) in isp_target_notify", status);
d364 21
a384 3
		if (IS_FC(isp)) {
			isp_get_notify_ack_fc(isp, nack_fcp,
			    (na_fcentry_t *)local);
d386 7
a392 2
			isp_prt(isp, ISP_LOGTDEBUG1,
			    "Notify Ack status=0x%x seqid 0x%x",
d397 6
a402 1
			isp_prt(isp, ISP_LOGTDEBUG1,
d407 19
d434 2
d438 2
d443 2
d447 5
d467 2
a468 2
isp_lun_cmd(struct ispsoftc *isp, int cmd, int bus, int tgt, int lun,
    int cmd_cnt, int inot_cnt, u_int32_t opaque)
d471 1
a471 1
	u_int16_t nxti, optr;
d503 1
a503 1
	} else if ((FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) == 0) {
d506 1
a506 1
	el.le_timeout = 2;
d521 1
a521 1
isp_target_put_entry(struct ispsoftc *isp, void *ap)
d524 2
a525 2
	u_int16_t nxti, optr;
	u_int8_t etype = ((isphdr_t *) ap)->rqs_entry_type;
d537 7
a543 1
		isp_put_atio2(isp, (at2_entry_t *) ap, (at2_entry_t *) outp);
d549 10
a558 1
		isp_put_ctio2(isp, (ct2_entry_t *) ap, (ct2_entry_t *) outp);
a564 1

d571 1
a571 1
isp_target_put_atio(struct ispsoftc *isp, void *arg)
d576 1
d584 2
a585 2
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
			atun._atio2.at_scclun = (u_int16_t) aep->at_scclun;
d587 6
a592 1
			atun._atio2.at_lun = (u_int8_t) aep->at_lun;
a593 1
		atun._atio2.at_iid = aep->at_iid;
d631 1
a631 1
isp_endcmd(struct ispsoftc *isp, void *arg, u_int32_t code, u_int16_t hdl)
d637 2
d644 28
a671 1
	if (IS_FC(isp)) {
d677 1
a677 2
		cto->ct_iid = aep->at_iid;
		if ((FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) == 0) {
d680 5
d686 1
a686 1
		cto->rsp.m1.ct_scsi_status = sts & 0xff;
d695 1
a695 1
		if ((sts & 0xff) == SCSI_CHECK && (sts & ECMD_SVALID)) {
d730 3
d734 1
a734 1
isp_target_async(struct ispsoftc *isp, int bus, int event)
d736 12
a747 2
	tmd_event_t evt;
	tmd_msg_t msg;
d750 10
a759 5
	/*
	 * These three we handle here to propagate an effective bus reset
	 * upstream, but these do not require any immediate notify actions
	 * so we return when done.
	 */
a761 2
	case ASYNC_LOOP_UP:
	case ASYNC_LOOP_DOWN:
d763 3
a765 8
	case ASYNC_PTPMODE:
		/*
		 * These don't require any immediate notify actions. We used
		 * treat them like SCSI Bus Resets, but that was just plain
		 * wrong. Let the normal CTIO completion report what occurred.
		 */
                return (0);

d767 3
a769 7
	case ASYNC_TIMEOUT_RESET:
		if (IS_FC(isp)) {
			return (0); /* we'll be getting an inotify instead */
		}
		evt.ev_bus = bus;
		evt.ev_event = event;
		(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);
d772 20
a791 7
		/*
		 * Bus Device Reset resets a specific target, so
		 * we pass this as a synthesized message.
		 */
		MEMZERO(&msg, sizeof msg);
		if (IS_FC(isp)) {
			msg.nt_iid = FCPARAM(isp)->isp_loopid;
d793 5
a797 1
			msg.nt_iid = SDPARAM(isp)->isp_initiator_id;
d799 1
a799 3
		msg.nt_bus = bus;
		msg.nt_msg[0] = MSG_BUS_DEV_RESET;
		(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);
d801 1
d805 3
d810 1
a810 3
	if (isp->isp_state == ISP_RUNSTATE)
		isp_notify_ack(isp, NULL);
	return(0);
d823 1
a823 1
isp_got_msg(struct ispsoftc *isp, int bus, in_entry_t *inp)
d825 10
a834 1
	u_int8_t status = inp->in_status & ~QLTM_SVALID;
d837 29
a865 11
		tmd_msg_t msg;

		MEMZERO(&msg, sizeof (msg));
		msg.nt_bus = bus;
		msg.nt_iid = inp->in_iid;
		msg.nt_tgt = inp->in_tgt;
		msg.nt_lun = inp->in_lun;
		msg.nt_tagtype = inp->in_tag_type;
		msg.nt_tagval = inp->in_tag_val;
		MEMCPY(msg.nt_msg, inp->in_msg, IN_MSGLEN);
		(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);
d869 1
d877 1
a877 1
isp_got_msg_fc(struct ispsoftc *isp, int bus, in_fcentry_t *inp)
d879 20
a898 7
	int lun;
	static const char f1[] = "%s from iid %d lun %d seq 0x%x";
	static const char f2[] = 
	    "unknown %s 0x%x lun %d iid %d task flags 0x%x seq 0x%x\n";

	if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
		lun = inp->in_scclun;
d900 1
a900 1
		lun = inp->in_lun;
d902 3
d908 26
a933 2
		    inp->in_status, lun, inp->in_iid,
		    inp->in_task_flags,  inp->in_seqid);
d935 7
a941 1
		tmd_msg_t msg;
d943 59
a1001 35
		MEMZERO(&msg, sizeof (msg));
		msg.nt_bus = bus;
		msg.nt_iid = inp->in_iid;
		msg.nt_tagval = inp->in_seqid;
		msg.nt_lun = lun;

		if (inp->in_task_flags & TASK_FLAGS_ABORT_TASK) {
			isp_prt(isp, ISP_LOGINFO, f1, "ABORT TASK",
			    inp->in_iid, lun, inp->in_seqid);
			msg.nt_msg[0] = MSG_ABORT_TAG;
		} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_TASK_SET) {
			isp_prt(isp, ISP_LOGINFO, f1, "CLEAR TASK SET",
			    inp->in_iid, lun, inp->in_seqid);
			msg.nt_msg[0] = MSG_CLEAR_QUEUE;
		} else if (inp->in_task_flags & TASK_FLAGS_TARGET_RESET) {
			isp_prt(isp, ISP_LOGINFO, f1, "TARGET RESET",
			    inp->in_iid, lun, inp->in_seqid);
			msg.nt_msg[0] = MSG_BUS_DEV_RESET;
		} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_ACA) {
			isp_prt(isp, ISP_LOGINFO, f1, "CLEAR ACA",
			    inp->in_iid, lun, inp->in_seqid);
			/* ???? */
			msg.nt_msg[0] = MSG_REL_RECOVERY;
		} else if (inp->in_task_flags & TASK_FLAGS_TERMINATE_TASK) {
			isp_prt(isp, ISP_LOGINFO, f1, "TERMINATE TASK",
			    inp->in_iid, lun, inp->in_seqid);
			msg.nt_msg[0] = MSG_TERM_IO_PROC;
		} else {
			isp_prt(isp, ISP_LOGWARN, f2, "task flag",
			    inp->in_status, lun, inp->in_iid,
			    inp->in_task_flags,  inp->in_seqid);
		}
		if (msg.nt_msg[0]) {
			(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);
		}
d1003 1
d1006 2
a1007 2
static void
isp_notify_ack(struct ispsoftc *isp, void *arg)
d1010 1
a1010 1
	u_int16_t nxti, optr;
d1021 36
a1056 1
	if (IS_FC(isp)) {
d1058 2
d1063 4
a1066 3
			na->na_iid = inp->in_iid;
			if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
				na->na_lun = inp->in_scclun;
d1068 2
a1069 1
				na->na_lun = inp->in_lun;
d1071 2
a1072 1
			na->na_task_flags = inp->in_task_flags;
d1079 4
d1088 9
a1096 1
		isp_put_notify_ack_fc(isp, na, (na_fcentry_t *)outp);
d1115 3
d1124 1
a1124 1
isp_handle_atio(struct ispsoftc *isp, at_entry_t *aep)
d1132 1
a1132 1
	 * If QLTM_SVALID is set, the firmware has recommended Sense Data.
d1197 1
a1197 1
		    "Unknown ATIO status 0x%x from initiator %d for lun %d",
d1205 1
a1205 1
isp_handle_atio2(struct ispsoftc *isp, at2_entry_t *aep)
d1207 1
a1207 1
	int lun;
d1209 1
a1209 1
	if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
d1215 6
d1225 1
a1225 1
	 * If QLTM_SVALID is set, the firmware has recommended Sense Data.
d1280 1
a1280 1
		isp_prt(isp, ISP_LOGERR, atior, lun, aep->at_iid, 0);
d1286 2
a1287 2
		    "Unknown ATIO2 status 0x%x from initiator %d for lun %d",
		    aep->at_status, aep->at_iid, lun);
d1294 1
a1294 1
isp_handle_ctio(struct ispsoftc *isp, ct_entry_t *ct)
d1301 2
a1302 2
		xs = isp_find_xs(isp, ct->ct_syshandle);
		if (xs == NULL)
d1304 1
d1356 1
a1356 1
		isp_prt(isp, ISP_LOGWARN, "CTIO destroyed by %s", fmsg);
d1455 1
a1455 1
isp_handle_ctio2(struct ispsoftc *isp, ct2_entry_t *ct)
d1457 1
a1457 1
	XS_T *xs;
d1462 2
a1463 2
		xs = isp_find_xs(isp, ct->ct_syshandle);
		if (xs == NULL)
d1465 1
d1495 1
a1495 1
		fmsg = "TARGET RESET Task Management Function Received";
d1507 3
a1509 2
		if (fmsg == NULL)
			fmsg = "ABORT Task Management Function Received";
d1511 2
a1512 1
		isp_prt(isp, ISP_LOGERR, "CTIO2 destroyed by %s", fmsg);
d1538 1
a1538 1
	case CT_PORTNOTAVAIL:
d1541 1
d1545 1
d1549 1
a1549 1
		isp_prt(isp, ISP_LOGERR, "CTIO returned by f/w- %s", fmsg);
d1557 1
a1557 1
		isp_prt(isp, ISP_LOGERR,
d1576 1
a1576 1
			if ((ct->ct_flags & CT_SENDSTATUS) == 0) {
d1592 154
a1745 1
		if (ct->ct_flags & CT_SENDSTATUS) {
@


1.14
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.13 2003/10/21 18:58:49 jmc Exp $ */
d3 1
a3 1
 * Machine and OS Independent Target Mode Code for the Qlogic SCSI/FC adapters.
d69 1
a69 1
 * The Qlogic driver gets an interrupt to look at response queue entries.
d89 1
a89 1
 * including flags you can set in the CTIO for the Qlogic 2X00 fibre channel
@


1.13
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.12 2003/09/18 09:44:18 jmc Exp $ */
d1050 1
a1050 1
		/* FALL Through */
@


1.12
log
@typo in error;
from Brian Poole
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.11 2003/03/03 20:58:46 mjacob Exp $ */
d110 2
a111 2
 * actual synchronization work has to be done in the platform specific
 * code- we have no synchroniation primitives in the common code.
d717 1
a717 1
	 * If QLTM_SVALID is set, the firware has recommended Sense Data.
d804 1
a804 1
	 * If QLTM_SVALID is set, the firware has recommended Sense Data.
d914 1
a914 1
		 * The firmware generates an async mailbox interupt to
d1067 1
a1067 1
		 * The firmware generates an async mailbox interupt to
@


1.11
log
@nuke extra semicolon
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.10 2003/03/03 18:34:59 mjacob Exp $ */
d1094 1
a1094 1
		isp_prt(isp, ISP_LOGERR, "CTIO2 had wrong data directiond");
@


1.10
log
@In isp_putback_atio, propagate iid && rxid for FC ATIOs.

LINT fixes for printing out the lun for recevied messages.

Spelling fix.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.9 2002/08/17 17:42:54 mjacob Exp $ */
d366 1
a366 1
	ISP_TDQE(isp, "isp_target_put_entry", (int) optr, ap);;
@


1.9
log
@isp_target_notify changes what it returns for success.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.8 2002/05/17 01:33:50 mjacob Exp $ */
d389 2
d616 1
a616 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d620 1
a620 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d624 1
a624 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d628 1
a628 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d633 1
a633 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d637 1
a637 1
			    inp->in_status, msg.nt_lun, inp->in_iid,
d768 1
a768 1
		 * A bus reset came along an blew away this command. Why
@


1.8
log
@keep up with the jones' (sync up with external source)
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.7 2001/12/14 00:20:55 mjacob Exp $ */
d142 1
a142 1
	int bus, type, rval = 0;
d219 1
a220 10
			isp_prt(isp, ISP_LOGWARN,
			    "Abort Task from IID %d RX_ID 0x%x",
			    inot_fcp->in_iid, seqid);
			(void) isp_async(isp, ISPASYNC_TARGET_ACTION, &bus);
			break;
		case IN_PORT_LOGOUT:
			isp_prt(isp, ISP_LOGWARN,
			    "Port Logout for Initiator %d RX_ID 0x%x",
			    inot_fcp->in_iid, seqid);
			break;
a221 4
			isp_prt(isp, ISP_LOGWARN,
			    "Port Changed for Initiator %d RX_ID 0x%x",
			    inot_fcp->in_iid, seqid);
			break;
d223 1
a223 1
			isp_prt(isp, ISP_LOGWARN, "All ports logged out");
d255 1
a255 1
		rval = -1;
d491 1
a491 1
void
d514 1
a514 1
                return;
d519 1
a519 1
			return;	/* we'll be getting an inotify instead */
d547 1
@


1.7
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.6 2001/10/06 22:45:52 mjacob Exp $ */
d32 4
d685 1
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.7 2001/12/14 00:20:55 mjacob Exp $ */
a31 4
 * Bug fixes gratefully acknowledged from:
 *	Oded Kedem <oded@@kashya.com>
 */
/*
a680 1
			na->na_status = inp->in_status;
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.7.2.1 2002/06/11 03:42:19 art Exp $ */
d142 1
a142 1
	int bus, type, rval = 1;
d219 6
d226 4
a229 1
		case IN_ABORT_TASK:
d231 4
d236 1
a236 1
			(void) isp_async(isp, ISPASYNC_TARGET_ACTION, &local);
d268 1
a268 1
		rval = 0;
d504 1
a504 1
int
d527 1
a527 1
                return (0);
d532 1
a532 1
			return (0); /* we'll be getting an inotify instead */
a559 1
	return(0);
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d366 1
a366 1
	ISP_TDQE(isp, "isp_target_put_entry", (int) optr, ap);
a388 2
		atun._atio2.at_iid = aep->at_iid;
		atun._atio2.at_rxid = aep->at_rxid;
d614 1
a614 1
			    inp->in_iid, lun, inp->in_seqid);
d618 1
a618 1
			    inp->in_iid, lun, inp->in_seqid);
d622 1
a622 1
			    inp->in_iid, lun, inp->in_seqid);
d626 1
a626 1
			    inp->in_iid, lun, inp->in_seqid);
d631 1
a631 1
			    inp->in_iid, lun, inp->in_seqid);
d635 1
a635 1
			    inp->in_status, lun, inp->in_iid,
d766 1
a766 1
		 * A bus reset came along and blew away this command. Why
@


1.6
log
@Fix various 2300 (2Gb) last minute errata. Keep up with the jones' for
the target mode code.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.5 2001/09/01 07:16:40 mjacob Exp $ */
d137 2
a138 1
	int bus, rval = 0;
d140 1
d145 1
a145 1
	switch(hdrp->rqs_entry_type) {
d147 2
a148 1
		isp_handle_atio(isp, atiop);
d151 2
a152 1
		isp_handle_ctio(isp, ctiop);
d155 2
a156 1
		isp_handle_atio2(isp, at2iop);
d159 2
a160 1
		isp_handle_ctio2(isp, ct2iop);
d164 2
a165 1
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, vptr);
d178 2
d183 2
d199 1
a199 1
		isp_notify_ack(isp, (status == IN_RESET)? NULL : vptr);
d207 1
a207 1
				isp_got_msg_fc(isp, bus, vptr);
d209 1
a209 1
				isp_got_msg(isp, bus, vptr);
d247 3
d254 2
d263 1
a263 2
		    "Unknown entry type 0x%x in isp_target_notify",
		    hdrp->rqs_entry_type);
d295 1
a295 1
	u_int16_t iptr, optr;
d332 2
a333 2
	if (isp_getrqentry(isp, &iptr, &optr, &outp)) {
		isp_prt(isp, ISP_LOGWARN,
a336 1
	ISP_SWIZ_ENABLE_LUN(isp, outp, &el);
d338 2
a339 1
	ISP_ADD_REQUEST(isp, iptr);
d348 1
a348 1
	u_int16_t iptr, optr;
d351 1
a351 1
	if (isp_getrqentry(isp, &iptr, &optr, &outp)) {
d358 1
a358 1
		ISP_SWIZ_ATIO(isp, outp, ap);
d361 1
a361 1
		ISP_SWIZ_ATIO2(isp, outp, ap);
d364 1
a364 1
		ISP_SWIZ_CTIO(isp, outp, ap);
d367 1
a367 1
		ISP_SWIZ_CTIO2(isp, outp, ap);
d376 1
a376 2

	ISP_ADD_REQUEST(isp, iptr);
d656 1
a656 1
	u_int16_t iptr, optr;
d659 1
a659 1
	if (isp_getrqentry(isp, &iptr, &optr, &outp)) {
d689 1
a689 1
		ISP_SWIZ_NOT_ACK_FC(isp, outp, na);
d707 1
a707 1
		ISP_SWIZ_NOT_ACK(isp, outp, na);
d710 1
a710 1
	ISP_ADD_REQUEST(isp, iptr);
d755 1
a755 1
		 * resource count in the Enable Lun entry and no
@


1.5
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.4 2001/04/04 22:08:55 mjacob Exp $ */
d50 2
a51 1
    "ATIO returned for lun %d because it was in the middle of Bus Device Reset";
d53 2
a54 1
    "ATIO returned for lun %d from initiator %d because a Bus Reset occurred";
d177 2
a178 2
				bus = (inotp->in_iid & 0x80) >> 7;
				inotp->in_iid &= ~0x80;
d181 8
a188 2
		isp_prt(isp, ISP_LOGTDEBUG1,
		    "Immediate Notify, status=0x%x seqid=0x%x", status, seqid);
d206 1
a206 1
			    "Abort Task for Initiator %d RX_ID 0x%x",
d208 1
a227 1
		isp_notify_ack(isp, vptr);
d312 1
a312 1
	} else if (isp->isp_maxluns <= 16) {
d379 1
a379 1
		if (isp->isp_maxluns > 16) {
d382 1
a382 1
			atun._atio2.at_lun = (u_int8_t) aep->at_scclun;
d438 1
a438 1
		if (isp->isp_maxluns <= 16) {
d498 1
d502 8
a509 4
		evt.ev_bus = bus;
		evt.ev_event = event;
		(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);
		return;
a510 1
	case ASYNC_LOOP_RESET:
d582 1
d587 6
d595 1
a595 1
		    inp->in_status, inp->in_lun, inp->in_iid,
a602 5
		if (isp->isp_maxluns > 16) {
			msg.nt_lun = inp->in_scclun;
		} else {
			msg.nt_lun = inp->in_lun;
		}
d604 1
d608 1
a608 1
			    inp->in_iid, inp->in_lun, inp->in_seqid);
d612 1
a612 1
			    inp->in_iid, inp->in_lun, inp->in_seqid);
d616 1
a616 1
			    inp->in_iid, inp->in_lun, inp->in_seqid);
d620 1
a620 1
			    inp->in_iid, inp->in_lun, inp->in_seqid);
d625 1
a625 1
			    inp->in_iid, inp->in_lun, inp->in_seqid);
d629 1
a629 1
			    inp->in_status, inp->in_lun, inp->in_iid,
d659 1
a659 1
			if (isp->isp_maxluns > 16) {
d745 2
a746 1
		isp_prt(isp, ISP_LOGERR, atiocope, lun);
d766 2
a767 1
		isp_prt(isp, ISP_LOGWARN, atior, lun, aep->at_iid);
d785 1
a785 1
	if (isp->isp_maxluns > 16) {
d831 1
a831 1
		isp_prt(isp, ISP_LOGERR, atiocope, lun);
d850 1
a850 1
		isp_prt(isp, ISP_LOGERR, atior, lun, aep->at_iid);
d923 1
a923 1
			fmsg = "ABORT TASK sent by Initiator";
@


1.4
log
@Keep up with the Joneses- sync up with core code for (eventual) usage here.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.3 2000/10/16 01:02:00 mjacob Exp $ */
d269 1
a269 1
    u_int32_t opaque)
d280 2
a281 2
	el.le_cmd_count = DFLT_CMD_CNT;
	el.le_in_count = DFLT_INOTIFY;
d441 1
a441 1
			cto->ct_flags |= CT2_DATA_UNDER;
d450 1
a450 1
			cto->ct_flags |= CT2_SNSLEN_VALID;
a960 1

a961 8
#if	0
			if (status & SENSEVALID) {
				bcopy((caddr_t) (cep + CTIO_SENSE_OFFSET),
				    (caddr_t) &cdp->cd_sensedata,
				    sizeof(scsi_sense_t));
				cdp->cd_flags |= CDF_SENSEVALID;
			}
#endif
d991 5
a995 5
			/*
			 * Final CTIO completed. Release DMA resources and
			 * notify platform dependent layers.
			 */
		if (ct->ct_flags & CT_DATAMASK) {
d1022 5
d1039 1
a1039 2
		 * Bus Device Reset message received or the SCSI Bus has
		 * been Reset; the firmware has gone to Bus Free.
d1046 1
a1046 1
		fmsg = "Bus Device Reset";
d1050 1
a1050 1
			fmsg = "Bus Reset";
d1059 1
a1059 1
			fmsg = "ABORT TASK sent by Initiator";
a1070 12
	case CT_NOPATH:
		/*
		 * CTIO rejected by the firmware due "no path for the
		 * nondisconnecting nexus specified". This means that
		 * we tried to access the bus while a non-disconnecting
		 * command is in process.
		 */
		isp_prt(isp, ISP_LOGERR,
		    "Firmware rejected CTIO2 for bad nexus %d->%d",
		    ct->ct_iid, ct->ct_lun);
		break;

d1072 1
a1072 1
		fmsg = "Reselection";
d1076 1
a1076 1
			fmsg = "Command";
a1082 8
	case CT_PHASE_ERROR:	/* Bus phase sequence error */
		if (fmsg == NULL)
			fmsg = "Phase Sequence Error";
		/*FALLTHROUGH*/
	case CT_TERMINATED:
		if (fmsg == NULL)
			fmsg = "terminated by TERMINATE TRANSFER";
		/*FALLTHROUGH*/
d1090 3
a1095 1

a1096 8
#if	0
			if (status & SENSEVALID) {
				bcopy((caddr_t) (cep + CTIO_SENSE_OFFSET),
				    (caddr_t) &cdp->cd_sensedata,
				    sizeof(scsi_sense_t));
				cdp->cd_flags |= CDF_SENSEVALID;
			}
#endif
d1136 3
a1154 1
			ISP_DMAFREE(isp, xs, ct->ct_syshandle);
@


1.3
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.2 2000/07/06 05:31:48 mjacob Exp $ */
d5 1
a5 1
 * Copyright (c) 1999, 2000 by Matthew Jacob
d49 1
a49 1
static char *atiocope =
d51 1
a51 1
static char *atior =
d54 3
a56 3
static void isp_got_msg __P((struct ispsoftc *, int, in_entry_t *));
static void isp_got_msg_fc __P((struct ispsoftc *, int, in_fcentry_t *));
static void isp_notify_ack __P((struct ispsoftc *, void *));
d90 1
a90 1
 * a classic oddbins area. It can get  a little wierd because you then turn
d109 1
a109 4
isp_target_notify(isp, vptr, optrp)
	struct ispsoftc *isp;
	void *vptr;
	u_int16_t *optrp;
d268 2
a269 7
isp_lun_cmd(isp, cmd, bus, tgt, lun, opaque)
	struct ispsoftc *isp;
	int cmd;
	int bus;
	int tgt;
	int lun;
	u_int32_t opaque;
d307 1
d322 1
a322 3
isp_target_put_entry(isp, ap)
	struct ispsoftc *isp;
	void *ap;
d359 1
a359 7
isp_target_put_atio(isp, iid, tgt, lun, ttype, tval)
	struct ispsoftc *isp;
	int iid;
	int tgt;
	int lun;
	int ttype;
	int tval;
d368 1
d372 1
a372 1
			atun._atio2.at_scclun = (u_int16_t) lun;
d374 1
a374 1
			atun._atio2.at_lun = (u_int8_t) lun;
d378 1
d381 8
a388 6
		atun._atio.at_iid = iid;
		atun._atio.at_tgt = tgt;
		atun._atio.at_lun = lun;
		atun._atio.at_tag_type = ttype;
		atun._atio.at_tag_val = tval;
		atun._atio.at_status = CT_OK;
d404 1
a404 1
 * NB: inline SCSI sense reporting.
d412 1
a412 1
isp_endcmd(struct ispsoftc *isp, void *arg, u_int32_t code, u_int32_t hdl)
d452 1
a452 1
		cto->ct_reserved = hdl;
d459 1
d465 3
d473 1
a473 1
		cto->ct_reserved = hdl;
d479 1
a479 4
isp_target_async(isp, bus, event)
	struct ispsoftc *isp;
	int bus;
	int event;
d542 1
a542 4
isp_got_msg(isp, bus, inp)
	struct ispsoftc *isp;
	int bus;
	in_entry_t *inp;
d568 1
a568 4
isp_got_msg_fc(isp, bus, inp)
	struct ispsoftc *isp;
	int bus;
	in_fcentry_t *inp;
d570 2
a571 2
	static char *f1 = "%s from iid %d lun %d seq 0x%x";
	static char *f2 = 
d624 1
a624 3
isp_notify_ack(isp, arg)
	struct ispsoftc *isp;
	void *arg;
d685 1
a685 3
isp_handle_atio(isp, aep)
	struct ispsoftc *isp;
	at_entry_t *aep;
d758 1
a758 2
		(void) isp_target_put_atio(isp, aep->at_iid, aep->at_tgt,
		    lun, aep->at_tag_type, aep->at_tag_val);
d764 1
a764 3
isp_handle_atio2(isp, aep)
	struct ispsoftc *isp;
	at2_entry_t *aep;
d841 1
a841 1
		(void) isp_target_put_atio(isp, aep->at_iid, 0, lun, 0, 0);
d847 1
a847 3
isp_handle_ctio(isp, ct)
	struct ispsoftc *isp;
	ct_entry_t *ct;
d849 1
a849 1
	XS_T *xs;
d853 2
a854 2
	if (ct->ct_reserved) {
		xs = isp_find_xs(isp, ct->ct_reserved);
a857 1
		pl = ISP_LOGTDEBUG1;
d942 4
d947 2
a948 1
		fmsg = "Completed with Error";
d986 1
a986 1
		if (ct->ct_reserved == 0) {
d997 1
a997 1
			    ct->ct_reserved, ct->ct_status & ~QLTM_SVALID);
a999 11
		if (ct->ct_flags & CT_SENDSTATUS) {
			/*
			 * Sent status and command complete.
			 *
			 * We're now really done with this command, so we
			 * punt to the platform dependent layers because
			 * only there can we do the appropriate command
			 * complete thread synchronization.
			 */
			isp_prt(isp, pl, "status CTIO complete");
		} else {
d1004 2
a1005 2
			isp_prt(isp, pl, "data CTIO complete");
			ISP_DMAFREE(isp, xs, ct->ct_reserved);
d1007 1
a1007 1
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);
d1011 1
d1016 1
a1016 3
isp_handle_ctio2(isp, ct)
	struct ispsoftc *isp;
	ct2_entry_t *ct;
d1022 2
a1023 2
	if (ct->ct_reserved) {
		xs = isp_find_xs(isp, ct->ct_reserved);
a1026 1
		pl = ISP_LOGTDEBUG1;
d1140 1
a1140 1
		isp_prt(isp, ISP_LOGERR, "Unknown CTIO status 0x%x",
d1153 1
a1153 1
		if (ct->ct_reserved == 0) {
d1164 1
a1164 1
			    ct->ct_reserved, ct->ct_status & ~QLTM_SVALID);
d1183 1
a1183 1
			ISP_DMAFREE(isp, xs, ct->ct_reserved);
@


1.2
log
@Resync with FreeBSD/NetBSD. Salient features are that the mailbox command
routines are not necessarily polled now- this should cut down on some of
the spurious lost commands that have occurred. Also, we now watchdog each
command and make sure that command constipation doesn't occur (which it
has been documented to do on the QLA2100 cards).
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.1 2000/02/20 21:22:40 mjacob Exp $ */
d5 1
a5 1
 * Copyright (c) 1999 by Matthew Jacob
d15 1
a15 4
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
d49 4
a52 1
int isp_tdebug = 0;
d182 2
a183 2
		ITDEBUG(2, ("isp_target_notify: Immediate Notify, "
		    "status=0x%x seqid=0x%x\n", status, seqid));
d197 1
a197 1
			PRINTF("%s: Firmware out of ATIOs\n", isp->isp_name);
d200 3
a202 2
			PRINTF("%s: Abort Task for Initiator %d RX_ID 0x%x\n",
			    isp->isp_name, inot_fcp->in_iid, seqid);
d205 3
a207 2
			PRINTF("%s: Port Logout for Initiator %d RX_ID 0x%x\n",
			    isp->isp_name, inot_fcp->in_iid, seqid);
d210 3
a212 2
			PRINTF("%s: Port Changed for Initiator %d RX_ID 0x%x\n",
			    isp->isp_name, inot_fcp->in_iid, seqid);
d215 1
a215 1
			PRINTF("%s: All ports logged out\n", isp->isp_name);
d218 2
a219 2
			PRINTF("%s: bad status (0x%x) in isp_target_notify\n",
			    isp->isp_name, status);
d231 3
a233 3
			ITDEBUG(2, ("%s: Notify Ack status=0x%x seqid 0x%x\n",
			    isp->isp_name, nack_fcp->na_status,
			    nack_fcp->na_seqid));
d235 3
a237 3
			ITDEBUG(2, ("%s: Notify Ack event 0x%x status=0x%x "
			    "seqid 0x%x\n", isp->isp_name, nackp->na_event,
			    nackp->na_status, nackp->na_seqid));
d241 3
a243 2
		PRINTF("%s: Unknown entry type 0x%x in isp_target_notify",
		    isp->isp_name, hdrp->rqs_entry_type);
d317 2
a318 2
		PRINTF("%s: Request Queue Overflow in isp_lun_cmd\n",
		    isp->isp_name);
d338 2
a339 2
		PRINTF("%s: Request Queue Overflow in isp_target_put_entry "
		    "for type 0x%x\n", isp->isp_name, etype);
d356 2
a357 2
		PRINTF("%s: Unknown type 0x%x in isp_put_entry\n",
		    isp->isp_name, etype);
d525 1
a525 2
			msg.nt_iid =
			    ((fcparam *)isp->isp_param)->isp_loopid;
d527 1
a527 2
			msg.nt_iid =
			    ((sdparam *)isp->isp_param)->isp_initiator_id;
d534 2
a535 2
		PRINTF("%s: isp_target_async: unknown event 0x%x\n",
		    isp->isp_name, event);
d538 2
a539 1
	isp_notify_ack(isp, NULL);
d572 2
a573 2
		PRINTF("%s: unknown immediate notify status 0x%x\n",
		    isp->isp_name, inp->in_status);
d586 1
a586 1
	static char *f1 = "%s: %s from iid %d lun %d seq 0x%x\n";
d588 1
a588 1
	    "%s: unknown %s 0x%x lun %d iid %d task flags 0x%x seq 0x%x\n";
d591 1
a591 1
		PRINTF(f2, isp->isp_name, "immediate notify status",
d608 1
a608 1
			PRINTF(f1, isp->isp_name, "ABORT TASK",
d612 1
a612 1
			PRINTF(f1, isp->isp_name, "CLEAR TASK SET",
d616 1
a616 1
			PRINTF(f1, isp->isp_name, "TARGET RESET",
d620 1
a620 1
			PRINTF(f1, isp->isp_name, "CLEAR ACA",
d625 1
a625 1
			PRINTF(f1, isp->isp_name, "TERMINATE TASK",
d629 1
a629 1
			PRINTF(f2, isp->isp_name, "task flag",
d649 2
a650 2
		PRINTF("%s: Request Queue Overflow For isp_notify_ack\n",
		    isp->isp_name);
d726 2
a727 2
		PRINTF("%s: rejected ATIO for disabled lun %d\n",
		    isp->isp_name, lun);
d735 3
a737 2
		PRINTF("%s: rejected ATIO for lun %d because of command count"
		    " overflow\n", isp->isp_name, lun);
d750 1
a750 3
		PRINTF("%s: ATIO returned for lun %d because it was in the "
		    " middle of coping with a Bus Device Reset\n",
		    isp->isp_name, lun);
d770 1
a770 3
		PRINTF("%s: ATIO returned for lun %d from initiator %d because"
		    " a Bus Reset occurred\n", isp->isp_name, lun,
		    aep->at_iid);
d775 3
a777 2
		PRINTF("%s: Unknown ATIO status 0x%x from initiator %d for lun"
		    " %d\n", isp->isp_name, aep->at_status, aep->at_iid, lun);
d814 2
a815 2
		PRINTF("%s: rejected ATIO2 for disabled lun %d\n",
		    isp->isp_name, lun);
d823 2
a824 2
		PRINTF("%s: rejected ATIO2 for lun %d because of command count"
		    " overflow\n", isp->isp_name, lun);
d837 1
a837 3
		PRINTF("%s: ATIO2 returned for lun %d because it was in the "
		    " middle of coping with a Bus Device Reset\n",
		    isp->isp_name, lun);
d856 1
a856 3
		PRINTF("%s: ATIO2 returned for lun %d from initiator %d because"
		    " a Bus Reset occurred\n", isp->isp_name, lun,
		    aep->at_iid);
d861 3
a863 2
		PRINTF("%s: Unknown ATIO2 status 0x%x from initiator %d for lun"
		    " %d\n", isp->isp_name, aep->at_status, aep->at_iid, lun);
d874 2
a875 2
	ISP_SCSI_XFER_T *xs;
	int pl = 0;
d881 1
a881 1
			pl = 0;
d883 1
a883 1
		pl = 2;
d903 2
a904 2
			IDPRINTF(pl, ("%s:CTIO- iid %d disconnected OK\n",
			    isp->isp_name, ct->ct_iid));
d934 1
a934 1
		PRINTF("%s: CTIO destroyed by %s\n", isp->isp_name, fmsg);
d942 3
a944 2
		PRINTF("%s: Firmware rejected CTIO for disabled lun %d\n",
		    isp->isp_name, ct->ct_lun);
d954 3
a956 2
		PRINTF("%s: Firmware rejected CTIO for bad nexus %d/%d/%d\n",
		    isp->isp_name, ct->ct_iid, ct->ct_tgt, ct->ct_lun);
d965 1
a965 1
		PRINTF("%s: Firmware timed out on %s\n", isp->isp_name, fmsg);
d983 1
a983 1
		PRINTF("%s: CTIO returned by f/w- %s\n", isp->isp_name, fmsg);
d994 1
a994 1
		PRINTF("%s: Unknown CTIO status 0x%x\n", isp->isp_name,
d1009 2
a1010 3
				IDPRINTF(pl,
				    ("%s: intermediate CTIO completed ok\n",
				    isp->isp_name));
d1012 2
a1013 3
				IDPRINTF(pl,
				    ("%s: unmonitored CTIO completed ok\n",
				    isp->isp_name));
d1016 3
a1018 4
			IDPRINTF(pl,
			    ("%s: NO xs for CTIO (handle 0x%x) status 0x%x\n",
			    isp->isp_name, ct->ct_reserved,
			    ct->ct_status & ~QLTM_SVALID));
d1030 1
a1030 2
			IDPRINTF(pl,
			    ("%s:status CTIO complete\n", isp->isp_name));
d1036 1
a1036 2
			IDPRINTF(pl,
			    ("%s: data CTIO complete\n", isp->isp_name));
d1051 2
a1052 2
	ISP_SCSI_XFER_T *xs;
	int pl = 3;
d1058 1
a1058 1
			pl = 0;
d1060 1
a1060 1
		pl = 2;
d1100 1
a1100 1
		PRINTF("%s: CTIO2 destroyed by %s\n", isp->isp_name, fmsg);
d1107 1
a1107 1
		PRINTF("%s: CTIO2 had wrong data directiond\n", isp->isp_name);
d1117 3
a1119 2
		PRINTF("%s: Firmware rejected CTIO2 for bad nexus %d->%d\n",
		    isp->isp_name, ct->ct_iid, ct->ct_lun);
d1128 1
a1128 1
		PRINTF("%s: Firmware timed out on %s\n", isp->isp_name, fmsg);
d1153 1
a1153 1
		PRINTF("%s: CTIO returned by f/w- %s\n", isp->isp_name, fmsg);
d1169 2
a1170 2
		PRINTF("%s: CTIO2 completed with Invalid RX_ID 0x%x\n",
		    isp->isp_name, ct->ct_rxid);
d1174 2
a1175 2
		IDPRINTF(pl, ("%s: Unknown CTIO status 0x%x\n", isp->isp_name,
		    ct->ct_status & ~QLTM_SVALID));
d1189 2
a1190 3
				IDPRINTF(pl,
				    ("%s: intermediate CTIO completed ok\n",
				    isp->isp_name));
d1192 2
a1193 3
				IDPRINTF(pl,
				    ("%s: unmonitored CTIO completed ok\n",
				    isp->isp_name));
d1196 3
a1198 4
			IDPRINTF(pl,
			    ("%s: NO xs for CTIO (handle 0x%x) status 0x%x\n",
			    isp->isp_name, ct->ct_reserved,
			    ct->ct_status & ~QLTM_SVALID));
d1210 1
a1210 2
			IDPRINTF(pl,
			    ("%s: status CTIO complete\n", isp->isp_name));
d1216 1
a1216 2
			IDPRINTF(pl,
			    ("%s: data CTIO complete\n", isp->isp_name));
@


1.1
log
@Add 12160 (Ultra3) support. Add files and changes for target mode support.
Do some SNS fabric suppor tchanges. Roll revision levels. Tested on
GENERIC i386 && sparc.
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
d288 1
a288 1
			el.le_flags = LUN_TQAE;
d308 1
a308 2
#ifndef	ISP2100_SCCLUN
	} else {
a309 1
#endif
d381 5
a385 5
#ifdef ISP2100_SCCLUN
		atun._atio2.at_scclun = (uint16_t) lun;
#else
		atun._atio2.at_lun = (uint8_t) lun;
#endif
d437 3
a439 3
#ifndef	ISP2100_SCCLUN
		cto->ct_lun = aep->at_lun;
#endif
d597 5
a601 5
#ifdef	ISP2100_SCCLUN
		msg.nt_lun = inp->in_scclun;
#else
		msg.nt_lun = inp->in_lun;
#endif
d659 5
a663 5
#ifdef	ISP2100_SCCLUN
			na->na_lun = inp->in_scclun;
#else
			na->na_lun = inp->in_lun;
#endif
d673 2
d686 1
a686 1
				na->na_flags = NA_RST_CLRD;
d689 1
a689 1
			na->na_flags = NA_RST_CLRD;
d691 2
d789 7
a795 5
#ifdef	ISP2100_SCCLUN
	lun = aep->at_scclun;
#else
	lun = aep->at_lun;
#endif
d899 3
a901 1
		if ((ct->ct_flags & CT_DATAMASK) == CT_NO_DATA) {
d905 2
a906 2
			IDPRINTF(pl, ("%s: CTIO- initiator disconnected OK\n",
			    isp->isp_name));
d1034 1
a1034 1
			    ("%s: status CTIO complete\n", isp->isp_name));
@


1.1.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.1 2000/02/20 21:22:40 mjacob Exp $ */
@


1.1.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.4 2001/04/04 22:08:55 mjacob Exp $ */
d5 1
a5 1
 * Copyright (c) 1999, 2000, 2001 by Matthew Jacob
d15 4
a18 1
 * 2. The name of the author may not be used to endorse or promote products
d52 5
a56 8
static const char atiocope[] =
    "ATIO returned for lun %d because it was in the middle of Bus Device Reset";
static const char atior[] =
    "ATIO returned for lun %d from initiator %d because a Bus Reset occurred";

static void isp_got_msg(struct ispsoftc *, int, in_entry_t *);
static void isp_got_msg_fc(struct ispsoftc *, int, in_fcentry_t *);
static void isp_notify_ack(struct ispsoftc *, void *);
d90 1
a90 1
 * a classic oddbins area. It can get  a little weird because you then turn
d109 4
a112 1
isp_target_notify(struct ispsoftc *isp, void *vptr, u_int16_t *optrp)
d182 2
a183 2
		isp_prt(isp, ISP_LOGTDEBUG1,
		    "Immediate Notify, status=0x%x seqid=0x%x", status, seqid);
d197 1
a197 1
			isp_prt(isp, ISP_LOGWARN, "Firmware out of ATIOs");
d200 2
a201 3
			isp_prt(isp, ISP_LOGWARN,
			    "Abort Task for Initiator %d RX_ID 0x%x",
			    inot_fcp->in_iid, seqid);
d204 2
a205 3
			isp_prt(isp, ISP_LOGWARN,
			    "Port Logout for Initiator %d RX_ID 0x%x",
			    inot_fcp->in_iid, seqid);
d208 2
a209 3
			isp_prt(isp, ISP_LOGWARN,
			    "Port Changed for Initiator %d RX_ID 0x%x",
			    inot_fcp->in_iid, seqid);
d212 1
a212 1
			isp_prt(isp, ISP_LOGWARN, "All ports logged out");
d215 2
a216 2
			isp_prt(isp, ISP_LOGERR,
			    "bad status (0x%x) in isp_target_notify", status);
d228 3
a230 3
			isp_prt(isp, ISP_LOGTDEBUG1,
			    "Notify Ack status=0x%x seqid 0x%x",
			    nack_fcp->na_status, nack_fcp->na_seqid);
d232 3
a234 3
			isp_prt(isp, ISP_LOGTDEBUG1,
			    "Notify Ack event 0x%x status=0x%x seqid 0x%x",
			    nackp->na_event, nackp->na_status, nackp->na_seqid);
d238 2
a239 3
		isp_prt(isp, ISP_LOGERR,
		    "Unknown entry type 0x%x in isp_target_notify",
		    hdrp->rqs_entry_type);
d267 7
a273 2
isp_lun_cmd(struct ispsoftc *isp, int cmd, int bus, int tgt, int lun,
    u_int32_t opaque)
d288 1
a288 1
			el.le_flags = LUN_TQAE|LUN_DISAD;
d308 2
a309 1
	} else if (isp->isp_maxluns <= 16) {
d311 1
a312 1
	el.le_timeout = 2;
d315 2
a316 2
		isp_prt(isp, ISP_LOGWARN,
		    "Request Queue Overflow in isp_lun_cmd");
d327 3
a329 1
isp_target_put_entry(struct ispsoftc *isp, void *ap)
d336 2
a337 2
		isp_prt(isp, ISP_LOGWARN,
		    "Request Queue Overflow in isp_target_put_entry");
d354 2
a355 2
		isp_prt(isp, ISP_LOGERR,
		    "Unknown type 0x%x in isp_put_entry", etype);
d366 7
a372 1
isp_target_put_atio(struct ispsoftc *isp, void *arg)
a380 1
		at2_entry_t *aep = arg;
d383 5
a387 5
		if (isp->isp_maxluns > 16) {
			atun._atio2.at_scclun = (u_int16_t) aep->at_scclun;
		} else {
			atun._atio2.at_lun = (u_int8_t) aep->at_scclun;
		}
a389 1
		at_entry_t *aep = arg;
d392 6
a397 8
		atun._atio.at_handle = aep->at_handle;
		atun._atio.at_iid = aep->at_iid;
		atun._atio.at_tgt = aep->at_tgt;
		atun._atio.at_lun = aep->at_lun;
		atun._atio.at_tag_type = aep->at_tag_type;
		atun._atio.at_tag_val = aep->at_tag_val;
		atun._atio.at_status = (aep->at_flags & AT_TQAE);
		atun._atio.at_status |= CT_OK;
d413 1
a413 1
 * NB: inline SCSI sense reporting. As such, we lose this information. XXX.
d421 1
a421 1
isp_endcmd(struct ispsoftc *isp, void *arg, u_int32_t code, u_int16_t hdl)
d439 3
a441 3
		if (isp->isp_maxluns <= 16) {
			cto->ct_lun = aep->at_lun;
		}
d461 1
a461 1
		cto->ct_syshandle = hdl;
a467 1
		cto->ct_fwhandle = aep->at_handle;
a472 3
		if (aep->at_flags & AT_TQAE) {
			cto->ct_flags |= CT_TQAE;
		}
d478 1
a478 1
		cto->ct_syshandle = hdl;
d484 4
a487 1
isp_target_async(struct ispsoftc *isp, int bus, int event)
d523 2
a524 1
			msg.nt_iid = FCPARAM(isp)->isp_loopid;
d526 2
a527 1
			msg.nt_iid = SDPARAM(isp)->isp_initiator_id;
d534 2
a535 2
		isp_prt(isp, ISP_LOGERR,
		    "isp_target_async: unknown event 0x%x", event);
d538 1
a538 2
	if (isp->isp_state == ISP_RUNSTATE)
		isp_notify_ack(isp, NULL);
d551 4
a554 1
isp_got_msg(struct ispsoftc *isp, int bus, in_entry_t *inp)
d571 2
a572 2
		isp_prt(isp, ISP_LOGERR,
		    "unknown immediate notify status 0x%x", inp->in_status);
d580 4
a583 1
isp_got_msg_fc(struct ispsoftc *isp, int bus, in_fcentry_t *inp)
d585 3
a587 3
	static const char f1[] = "%s from iid %d lun %d seq 0x%x";
	static const char f2[] = 
	    "unknown %s 0x%x lun %d iid %d task flags 0x%x seq 0x%x\n";
d590 1
a590 1
		isp_prt(isp, ISP_LOGINFO, f2, "immediate notify status",
d599 5
a603 5
		if (isp->isp_maxluns > 16) {
			msg.nt_lun = inp->in_scclun;
		} else {
			msg.nt_lun = inp->in_lun;
		}
d607 1
a607 1
			isp_prt(isp, ISP_LOGINFO, f1, "ABORT TASK",
d611 1
a611 1
			isp_prt(isp, ISP_LOGINFO, f1, "CLEAR TASK SET",
d615 1
a615 1
			isp_prt(isp, ISP_LOGINFO, f1, "TARGET RESET",
d619 1
a619 1
			isp_prt(isp, ISP_LOGINFO, f1, "CLEAR ACA",
d624 1
a624 1
			isp_prt(isp, ISP_LOGINFO, f1, "TERMINATE TASK",
d628 1
a628 1
			isp_prt(isp, ISP_LOGWARN, f2, "task flag",
d639 3
a641 1
isp_notify_ack(struct ispsoftc *isp, void *arg)
d648 2
a649 2
		isp_prt(isp, ISP_LOGWARN,
		    "Request Queue Overflow For isp_notify_ack");
d661 5
a665 5
			if (isp->isp_maxluns > 16) {
				na->na_lun = inp->in_scclun;
			} else {
				na->na_lun = inp->in_lun;
			}
a674 2
		na->na_header.rqs_entry_type = RQSTYPE_NOTIFY_ACK;
		na->na_header.rqs_entry_count = 1;
d686 1
a686 1
				na->na_event = NA_RST_CLRD;
d689 1
a689 1
			na->na_event = NA_RST_CLRD;
a690 2
		na->na_header.rqs_entry_type = RQSTYPE_NOTIFY_ACK;
		na->na_header.rqs_entry_count = 1;
d698 3
a700 1
isp_handle_atio(struct ispsoftc *isp, at_entry_t *aep)
d721 2
a722 2
		isp_prt(isp, ISP_LOGERR,
		    "rejected ATIO for disabled lun %d", lun);
d730 2
a731 3
		isp_prt(isp, ISP_LOGERR,
		    "rejected ATIO for lun %d because of command count"
		    " overflow", lun);
d744 3
a746 1
		isp_prt(isp, ISP_LOGERR, atiocope, lun);
d766 3
a768 1
		isp_prt(isp, ISP_LOGWARN, atior, lun, aep->at_iid);
d773 4
a776 4
		isp_prt(isp, ISP_LOGERR,
		    "Unknown ATIO status 0x%x from initiator %d for lun %d",
		    aep->at_status, aep->at_iid, lun);
		(void) isp_target_put_atio(isp, aep);
d782 3
a784 1
isp_handle_atio2(struct ispsoftc *isp, at2_entry_t *aep)
d787 5
a791 7

	if (isp->isp_maxluns > 16) {
		lun = aep->at_scclun;
	} else {
		lun = aep->at_lun;
	}

d809 2
a810 2
		isp_prt(isp, ISP_LOGERR,
		    "rejected ATIO2 for disabled lun %d", lun);
d818 2
a819 2
		isp_prt(isp, ISP_LOGERR,
		    "rejected ATIO2 for lun %d- command count overflow", lun);
d832 3
a834 1
		isp_prt(isp, ISP_LOGERR, atiocope, lun);
d853 3
a855 1
		isp_prt(isp, ISP_LOGERR, atior, lun, aep->at_iid);
d860 3
a862 4
		isp_prt(isp, ISP_LOGERR,
		    "Unknown ATIO2 status 0x%x from initiator %d for lun %d",
		    aep->at_status, aep->at_iid, lun);
		(void) isp_target_put_atio(isp, aep);
d868 3
a870 1
isp_handle_ctio(struct ispsoftc *isp, ct_entry_t *ct)
d872 2
a873 2
	void *xs;
	int pl = ISP_LOGTDEBUG2;
d876 2
a877 2
	if (ct->ct_syshandle) {
		xs = isp_find_xs(isp, ct->ct_syshandle);
d879 1
a879 1
			pl = ISP_LOGALL;
d881 1
d895 1
a895 3
		if (ct->ct_flags & CT_SENDSTATUS) {
			break;
		} else if ((ct->ct_flags & CT_DATAMASK) == CT_NO_DATA) {
d899 2
a900 2
			isp_prt(isp, pl, "CTIO- iid %d disconnected OK",
			    ct->ct_iid);
d930 1
a930 1
		isp_prt(isp, ISP_LOGWARN, "CTIO destroyed by %s", fmsg);
d938 2
a939 3
		isp_prt(isp, ISP_LOGERR,
		    "Firmware rejected CTIO for disabled lun %d",
		    ct->ct_lun);
d949 2
a950 3
		isp_prt(isp, ISP_LOGERR,
		    "Firmware rejected CTIO for bad nexus %d/%d/%d",
		    ct->ct_iid, ct->ct_tgt, ct->ct_lun);
d959 1
a959 1
		isp_prt(isp, ISP_LOGERR, "Firmware timed out on %s", fmsg);
a961 4
	case	CT_PANIC:
		if (fmsg == NULL)
			fmsg = "Unrecoverable Error";
		/*FALLTHROUGH*/
d963 1
a963 2
		if (fmsg == NULL)
			fmsg = "Completed with Error";
d977 1
a977 1
		isp_prt(isp, ISP_LOGERR, "CTIO returned by f/w- %s", fmsg);
d988 1
a988 1
		isp_prt(isp, ISP_LOGERR, "Unknown CTIO status 0x%x",
d1001 1
a1001 1
		if (ct->ct_syshandle == 0) {
d1003 3
a1005 2
				isp_prt(isp, pl,
				    "intermediate CTIO completed ok");
d1007 3
a1009 2
				isp_prt(isp, pl,
				    "unmonitored CTIO completed ok");
d1012 4
a1015 3
			isp_prt(isp, pl,
			    "NO xs for CTIO (handle 0x%x) status 0x%x",
			    ct->ct_syshandle, ct->ct_status & ~QLTM_SVALID);
d1018 12
d1034 3
a1036 2
		if (ct->ct_flags & CT_DATAMASK) {
			ISP_DMAFREE(isp, xs, ct->ct_syshandle);
d1038 1
a1038 1
		isp_prt(isp, pl, "final CTIO complete");
a1041 1
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);
d1046 3
a1048 1
isp_handle_ctio2(struct ispsoftc *isp, ct2_entry_t *ct)
d1050 2
a1051 2
	XS_T *xs;
	int pl = ISP_LOGTDEBUG2;
d1054 2
a1055 2
	if (ct->ct_syshandle) {
		xs = isp_find_xs(isp, ct->ct_syshandle);
d1057 1
a1057 1
			pl = ISP_LOGALL;
d1059 1
d1099 1
a1099 1
		isp_prt(isp, ISP_LOGERR, "CTIO2 destroyed by %s", fmsg);
d1106 1
a1106 1
		isp_prt(isp, ISP_LOGERR, "CTIO2 had wrong data directiond");
d1116 2
a1117 3
		isp_prt(isp, ISP_LOGERR,
		    "Firmware rejected CTIO2 for bad nexus %d->%d",
		    ct->ct_iid, ct->ct_lun);
d1126 1
a1126 1
		isp_prt(isp, ISP_LOGERR, "Firmware timed out on %s", fmsg);
d1151 1
a1151 1
		isp_prt(isp, ISP_LOGERR, "CTIO returned by f/w- %s", fmsg);
d1167 2
a1168 2
		isp_prt(isp, ISP_LOGERR,
		    "CTIO2 completed with Invalid RX_ID 0x%x", ct->ct_rxid);
d1172 2
a1173 2
		isp_prt(isp, ISP_LOGERR, "Unknown CTIO2 status 0x%x",
		    ct->ct_status & ~QLTM_SVALID);
d1185 1
a1185 1
		if (ct->ct_syshandle == 0) {
d1187 3
a1189 2
				isp_prt(isp, pl,
				    "intermediate CTIO completed ok");
d1191 3
a1193 2
				isp_prt(isp, pl,
				    "unmonitored CTIO completed ok");
d1196 4
a1199 3
			isp_prt(isp, pl,
			    "NO xs for CTIO (handle 0x%x) status 0x%x",
			    ct->ct_syshandle, ct->ct_status & ~QLTM_SVALID);
d1211 2
a1212 1
			isp_prt(isp, pl, "status CTIO complete");
d1218 3
a1220 2
			isp_prt(isp, pl, "data CTIO complete");
			ISP_DMAFREE(isp, xs, ct->ct_syshandle);
@


1.1.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: isp_target.c,v 1.1.2.2 2001/05/14 22:23:55 niklas Exp $ */
d50 1
a50 2
    "ATIO returned for lun %d because it was in the middle of Bus Device Reset "
    "on bus %d";
d52 1
a52 2
    "ATIO returned on for lun %d on from IID %d because a Bus Reset occurred "
    "on bus %d";
d175 2
a176 2
				bus = GET_BUS_VAL(inotp->in_iid);
				SET_BUS_VAL(inotp->in_iid, 0);
d179 2
a180 8
		isp_prt(isp, ISP_LOGTDEBUG0,
		    "Immediate Notify On Bus %d, status=0x%x seqid=0x%x",
		    bus, status, seqid);

		/*
		 * ACK it right away.
		 */
		isp_notify_ack(isp, (status == IN_RESET)? NULL : vptr);
d198 1
a198 1
			    "Abort Task from IID %d RX_ID 0x%x",
a199 1
			(void) isp_async(isp, ISPASYNC_TARGET_ACTION, &bus);
d219 1
d269 1
a269 1
    int cmd_cnt, int inot_cnt, u_int32_t opaque)
d280 2
a281 2
	el.le_cmd_count = cmd_cnt;
	el.le_in_count = inot_cnt;
d304 1
a304 1
	} else if ((FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) == 0) {
d371 1
a371 1
		if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
d374 1
a374 1
			atun._atio2.at_lun = (u_int8_t) aep->at_lun;
d430 1
a430 1
		if ((FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) == 0) {
d441 1
a441 1
			cto->rsp.m1.ct_scsi_status |= CT2_DATA_UNDER;
d450 1
a450 1
			cto->rsp.m1.ct_scsi_status |= CT2_SNSLEN_VALID;
a489 1
	case ASYNC_LIP_F8:
d493 5
a498 8
	case ASYNC_PTPMODE:
		/*
		 * These don't require any immediate notify actions. We used
		 * treat them like SCSI Bus Resets, but that was just plain
		 * wrong. Let the normal CTIO completion report what occurred.
		 */
                return;

a569 1
	int lun;
a573 6
	if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
		lun = inp->in_scclun;
	} else {
		lun = inp->in_lun;
	}

d576 1
a576 1
		    inp->in_status, lun, inp->in_iid,
d584 5
a589 1
		msg.nt_lun = lun;
d593 1
a593 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d597 1
a597 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d601 1
a601 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d605 1
a605 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d610 1
a610 1
			    inp->in_iid, msg.nt_lun, inp->in_seqid);
d614 1
a614 1
			    inp->in_status, msg.nt_lun, inp->in_iid,
d644 1
a644 1
			if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
d730 1
a730 2
		isp_prt(isp, ISP_LOGERR, atiocope, lun,
		    GET_BUS_VAL(aep->at_iid));
d750 1
a750 2
		isp_prt(isp, ISP_LOGWARN, atior, lun,
		    GET_IID_VAL(aep->at_iid), GET_BUS_VAL(aep->at_iid));
d768 1
a768 1
	if (FCPARAM(isp)->isp_fwattr & ISP_FW_ATTR_SCCLUN) {
d814 1
a814 1
		isp_prt(isp, ISP_LOGERR, atiocope, lun, 0);
d833 1
a833 1
		isp_prt(isp, ISP_LOGERR, atior, lun, aep->at_iid, 0);
d906 1
a906 1
			fmsg = "ABORT TAG message sent by Initiator";
d961 1
d963 8
d1000 5
a1004 5
		/*
		 * Final CTIO completed. Release DMA resources and
		 * notify platform dependent layers.
		 */
		if ((ct->ct_flags & CT_DATAMASK) != CT_NO_DATA) {
a1030 5
	case CT_BUS_ERROR:
		isp_prt(isp, ISP_LOGERR, "PCI DMA Bus Error");
		/* FALL Through */
	case CT_DATA_OVER:
	case CT_DATA_UNDER:
d1043 2
a1044 1
		 * Target Reset function received.
d1051 1
a1051 1
		fmsg = "TARGET RESET Task Management Function Received";
d1055 1
a1055 1
			fmsg = "LIP Reset";
d1064 1
a1064 1
			fmsg = "ABORT Task Management Function Received";
d1076 12
d1089 1
a1089 1
		fmsg = "failure to reconnect to initiator";
d1093 1
a1093 1
			fmsg = "command";
d1100 8
a1114 3
	case CT_PORTCHANGED:
		if (fmsg == NULL)
			fmsg = "Port Changed";
d1118 1
d1120 8
a1166 3
		if ((ct->ct_flags & CT2_DATAMASK) != CT2_NO_DATA) {
			ISP_DMAFREE(isp, xs, ct->ct_syshandle);
		}
d1183 1
@


1.1.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d137 1
a137 2
	u_int8_t local[QENTRY_LEN];
	int bus, type, rval = 0;
a138 1
	type = isp_get_response_type(isp, (isphdr_t *)vptr);
d143 1
a143 1
	switch(type) {
d145 1
a145 2
		isp_get_atio(isp, atiop, (at_entry_t *) local);
		isp_handle_atio(isp, (at_entry_t *) local);
d148 1
a148 2
		isp_get_ctio(isp, ctiop, (ct_entry_t *) local);
		isp_handle_ctio(isp, (ct_entry_t *) local);
d151 1
a151 2
		isp_get_atio2(isp, at2iop, (at2_entry_t *) local);
		isp_handle_atio2(isp, (at2_entry_t *) local);
d154 1
a154 2
		isp_get_ctio2(isp, ct2iop, (ct2_entry_t *) local);
		isp_handle_ctio2(isp, (ct2_entry_t *) local);
d158 1
a158 2
		isp_get_enable_lun(isp, lunenp, (lun_entry_t *) local);
		(void) isp_async(isp, ISPASYNC_TARGET_ACTION, local);
a170 2
			isp_get_notify_fc(isp, inot_fcp, (in_fcentry_t *)local);
			inot_fcp = (in_fcentry_t *) local;
a173 2
			isp_get_notify(isp, inotp, (in_entry_t *)local);
			inotp = (in_entry_t *) local;
d188 1
a188 1
		isp_notify_ack(isp, (status == IN_RESET)? NULL : local);
d196 1
a196 1
				isp_got_msg_fc(isp, bus, (in_fcentry_t *)local);
d198 1
a198 1
				isp_got_msg(isp, bus, (in_entry_t *)local);
a235 3
			isp_get_notify_ack_fc(isp, nack_fcp,
			    (na_fcentry_t *)local);
			nack_fcp = (na_fcentry_t *)local;
a239 2
			isp_get_notify_ack(isp, nackp, (na_entry_t *)local);
			nackp = (na_entry_t *)local;
d247 2
a248 1
		    "Unknown entry type 0x%x in isp_target_notify", type);
d280 1
a280 1
	u_int16_t nxti, optr;
d317 2
a318 2
	if (isp_getrqentry(isp, &nxti, &optr, &outp)) {
		isp_prt(isp, ISP_LOGERR,
d322 1
d324 1
a324 2
	isp_put_enable_lun(isp, &el, outp);
	ISP_ADD_REQUEST(isp, nxti);
d333 1
a333 1
	u_int16_t nxti, optr;
d336 1
a336 1
	if (isp_getrqentry(isp, &nxti, &optr, &outp)) {
d343 1
a343 1
		isp_put_atio(isp, (at_entry_t *) ap, (at_entry_t *) outp);
d346 1
a346 1
		isp_put_atio2(isp, (at2_entry_t *) ap, (at2_entry_t *) outp);
d349 1
a349 1
		isp_put_ctio(isp, (ct_entry_t *) ap, (ct_entry_t *) outp);
d352 1
a352 1
		isp_put_ctio2(isp, (ct2_entry_t *) ap, (ct2_entry_t *) outp);
d361 2
a362 1
	ISP_ADD_REQUEST(isp, nxti);
d642 1
a642 1
	u_int16_t nxti, optr;
d645 1
a645 1
	if (isp_getrqentry(isp, &nxti, &optr, &outp)) {
d675 1
a675 1
		isp_put_notify_ack_fc(isp, na, (na_fcentry_t *)outp);
d693 1
a693 1
		isp_put_notify_ack(isp, na, (na_entry_t *)outp);
d696 1
a696 1
	ISP_ADD_REQUEST(isp, nxti);
d741 1
a741 1
		 * resource count in the Enable Lun entry and do
@


1.1.2.5
log
@Sync the SMP branch with 3.3
@
text
@a31 4
 * Bug fixes gratefully acknowledged from:
 *	Oded Kedem <oded@@kashya.com>
 */
/*
d138 1
a138 1
	int bus, type, rval = 1;
d215 6
d222 4
a225 1
		case IN_ABORT_TASK:
d227 4
d232 1
a232 1
			(void) isp_async(isp, ISPASYNC_TARGET_ACTION, &local);
d264 1
a264 1
		rval = 0;
d375 1
a375 1
	ISP_TDQE(isp, "isp_target_put_entry", (int) optr, ap);
a397 2
		atun._atio2.at_iid = aep->at_iid;
		atun._atio2.at_rxid = aep->at_rxid;
d500 1
a500 1
int
d523 1
a523 1
                return (0);
d528 1
a528 1
			return (0); /* we'll be getting an inotify instead */
a555 1
	return(0);
d622 1
a622 1
			    inp->in_iid, lun, inp->in_seqid);
d626 1
a626 1
			    inp->in_iid, lun, inp->in_seqid);
d630 1
a630 1
			    inp->in_iid, lun, inp->in_seqid);
d634 1
a634 1
			    inp->in_iid, lun, inp->in_seqid);
d639 1
a639 1
			    inp->in_iid, lun, inp->in_seqid);
d643 1
a643 1
			    inp->in_status, lun, inp->in_iid,
a680 1
			na->na_status = inp->in_status;
d773 1
a773 1
		 * A bus reset came along and blew away this command. Why
@


1.1.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d110 2
a111 2
 * actual synchronization work has to be done in the platform-specific
 * code - we have no synchronization primitives in the common code.
d717 1
a717 1
	 * If QLTM_SVALID is set, the firmware has recommended Sense Data.
d804 1
a804 1
	 * If QLTM_SVALID is set, the firmware has recommended Sense Data.
d914 1
a914 1
		 * The firmware generates an async mailbox interrupt to
d1067 1
a1067 1
		 * The firmware generates an async mailbox interrupt to
d1094 1
a1094 1
		isp_prt(isp, ISP_LOGERR, "CTIO2 had wrong data direction");
@


