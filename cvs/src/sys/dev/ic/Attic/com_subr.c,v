head	1.16;
access;
symbols
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5;
locks; strict;
comment	@ * @;


1.16
date	2008.11.24.09.29.06;	author deraadt;	state dead;
branches;
next	1.15;

1.15
date	2008.11.23.17.59.00;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.21.18.49.47;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.26.17.35.03;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.12.14.57.16;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.22.14.11.44;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.20.17.37.34;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.20.10.34.52;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2006.12.28.20.50.26;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.31.11.06.30;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.30.21.31.57;	author fkr;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.02.22.35.06;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.13.18.37.58;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.13.14.58.56;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.13.01.59.42;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.26.22.32.06;	author miod;	state Exp;
branches;
next	;


desc
@@


1.16
log
@die die die
@
text
@@


1.15
log
@pccom can finally die; ok kettenis dlg drahn, tested by okan
@
text
@@


1.14
log
@Switch i386 from pccom to com.  Welcomed by many.

ok dlg@@, jsing@@, deraadt@@
@
text
@a0 449
/*	$OpenBSD: com_subr.c,v 1.13 2008/04/26 17:35:03 kettenis Exp $	*/

/*
 * Copyright (c) 1997 - 1999, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)com.c	7.5 (Berkeley) 5/16/91
 */

/*
 * COM driver, based on HP dca driver
 * uses National Semiconductor NS16450/NS16550AF UART
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/tty.h>

#include "com.h"
#define	NPCCOM	0

#include <machine/bus.h>
#if !defined(__sparc__) || defined(__sparc64__)
#include <machine/intr.h>
#endif

#if !defined(__sparc__) || defined(__sparc64__)
#define	COM_CONSOLE
#include <dev/cons.h>
#endif

#include <dev/ic/comreg.h>
#include <dev/ic/ns16550reg.h>
#define	com_lcr	com_cfcr

#if NCOM > 0
#include <dev/ic/comvar.h>
#endif

#ifdef COM_PXA2X0
#define com_isr 8
#define ISR_SEND	(ISR_RXPL | ISR_XMODE | ISR_XMITIR)
#define ISR_RECV	(ISR_RXPL | ISR_XMODE | ISR_RCVEIR)
#endif

#ifdef	COM_CONSOLE
#include <sys/conf.h>
cdev_decl(com);
#endif

void	com_enable_debugport(struct com_softc *);
void	com_fifo_probe(struct com_softc *);

#if defined(COM_CONSOLE) || defined(KGDB)
void
com_enable_debugport(sc)
	struct com_softc *sc;
{
	int s;

	/* Turn on line break interrupt, set carrier. */
	s = splhigh();
#ifdef KGDB
	SET(sc->sc_ier, IER_ERXRDY);
#ifdef COM_PXA2X0
	if (sc->sc_uarttype == COM_UART_PXA2X0)
		sc->sc_ier |= IER_EUART | IER_ERXTOUT;
#endif
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_ier, sc->sc_ier);
#endif
	SET(sc->sc_mcr, MCR_DTR | MCR_RTS | MCR_IENABLE);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);

	splx(s);
}
#endif	/* COM_CONSOLED || KGDB */

void
com_attach_subr(sc)
	struct com_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t lcr;

	sc->sc_ier = 0;
#ifdef COM_PXA2X0
	if (sc->sc_uarttype == COM_UART_PXA2X0)
		sc->sc_ier |= IER_EUART;
#endif
	/* disable interrupts */
	bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);

#ifdef COM_CONSOLE
	if (sc->sc_iot == comconsiot && sc->sc_iobase == comconsaddr) {
		comconsattached = 1;
		delay(10000);			/* wait for output to finish */
		SET(sc->sc_hwflags, COM_HW_CONSOLE);
		SET(sc->sc_swflags, COM_SW_SOFTCAR);
	}
#endif

	/*
	 * Probe for all known forms of UART.
	 */
	lcr = bus_space_read_1(iot, ioh, com_lcr);
	bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
	bus_space_write_1(iot, ioh, com_efr, 0);
	bus_space_write_1(iot, ioh, com_lcr, 0);

	bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	delay(100);

	/*
	 * Skip specific probes if attachment code knows it already.
	 */
	if (sc->sc_uarttype == COM_UART_UNKNOWN)
		switch (bus_space_read_1(iot, ioh, com_iir) >> 6) {
		case 0:
			sc->sc_uarttype = COM_UART_16450;
			break;
		case 2:
			sc->sc_uarttype = COM_UART_16550;
			break;
		case 3:
			sc->sc_uarttype = COM_UART_16550A;
			break;
		default:
			sc->sc_uarttype = COM_UART_UNKNOWN;
			break;
		}

	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		if (bus_space_read_1(iot, ioh, com_efr) == 0) {
			sc->sc_uarttype = COM_UART_ST16650;
		} else {
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			if (bus_space_read_1(iot, ioh, com_efr) == 0)
				sc->sc_uarttype = COM_UART_ST16650V2;
		}
	}

#if NPCCOM > 0	/* until com works with large FIFOs */
	if (sc->sc_uarttype == COM_UART_ST16650V2) { /* Probe for XR16850s */
		u_int8_t dlbl, dlbh;

		/* Enable latch access and get the current values. */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		dlbl = bus_space_read_1(iot, ioh, com_dlbl);
		dlbh = bus_space_read_1(iot, ioh, com_dlbh);

		/* Zero out the latch divisors */
		bus_space_write_1(iot, ioh, com_dlbl, 0);
		bus_space_write_1(iot, ioh, com_dlbh, 0);

		if (bus_space_read_1(iot, ioh, com_dlbh) == 0x10) {
			sc->sc_uarttype = COM_UART_XR16850;
			sc->sc_uartrev = bus_space_read_1(iot, ioh, com_dlbl);
		}

		/* Reset to original. */
		bus_space_write_1(iot, ioh, com_dlbl, dlbl);
		bus_space_write_1(iot, ioh, com_dlbh, dlbh);
	}
#endif

	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for TI16750s */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		bus_space_write_1(iot, ioh, com_fifo,
		    FIFO_ENABLE | FIFO_ENABLE_64BYTE);
		if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 7) {
#if 0
			bus_space_write_1(iot, ioh, com_lcr, 0);
			if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 6)
#endif
				sc->sc_uarttype = COM_UART_TI16750;
		}
		bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	}

	/* Reset the LCR (latch access is probably enabled). */
	bus_space_write_1(iot, ioh, com_lcr, lcr);
	if (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */
		u_int8_t scr0, scr1, scr2;

		scr0 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0xa5);
		scr1 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0x5a);
		scr2 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, scr0);

		if ((scr1 != 0xa5) || (scr2 != 0x5a))
			sc->sc_uarttype = COM_UART_8250;
	}

	/*
	 * Print UART type and initialize ourself.
	 */
	switch (sc->sc_uarttype) {
	case COM_UART_UNKNOWN:
		printf(": unknown uart\n");
		break;
	case COM_UART_8250:
		printf(": ns8250, no fifo\n");
		break;
	case COM_UART_16450:
		printf(": ns16450, no fifo\n");
		break;
	case COM_UART_16550:
		printf(": ns16550, no working fifo\n");
		break;
	case COM_UART_16550A:
		if (sc->sc_fifolen == 0)
			sc->sc_fifolen = 16;
		printf(": ns16550a, %d byte fifo\n", sc->sc_fifolen);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		break;
#ifdef COM_PXA2X0
	case COM_UART_PXA2X0:
		printf(": pxa2x0, 32 byte fifo");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 32;
		if (sc->sc_iobase == comsiraddr) {
			SET(sc->sc_hwflags, COM_HW_SIR);
			printf(" (SIR)");
		}
		printf("\n");
		break;
#endif
	case COM_UART_ST16650:
		printf(": st16650, no working fifo\n");
		break;
	case COM_UART_ST16650V2:
		if (sc->sc_fifolen == 0)
			sc->sc_fifolen = 32;
		printf(": st16650, %d byte fifo\n", sc->sc_fifolen);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		break;
	case COM_UART_ST16C654:
		printf(": st16c654, 64 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 64;
		break;
	case COM_UART_TI16750:
		printf(": ti16750, 64 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 64;
		break;
#if NPCCOM > 0
	case COM_UART_XR16850:
		printf(": xr16850 (rev %d), 128 byte fifo\n", sc->sc_uartrev);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 128;
		break;
#ifdef COM_UART_OX16C950
	case COM_UART_OX16C950:
		printf(": ox16c950 (rev %d), 128 byte fifo\n", sc->sc_uartrev);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 128;
		break;
#endif
#endif
	default:
		panic("comattach: bad fifo type");
	}

#ifdef KGDB
	/*
	 * Allow kgdb to "take over" this port.  If this is
	 * the kgdb device, it has exclusive use.
	 */

	if (iot == com_kgdb_iot && sc->sc_iobase == com_kgdb_addr &&
	    !ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		printf("%s: kgdb\n", sc->sc_dev.dv_xname);
		SET(sc->sc_hwflags, COM_HW_KGDB);
	}
#endif /* KGDB */

#if defined(COM_CONSOLE) || defined(KGDB)
	if (!ISSET(sc->sc_hwflags, COM_HW_CONSOLE|COM_HW_KGDB))
#endif
		com_fifo_probe(sc);

	if (sc->sc_fifolen == 0) {
		CLR(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 1;
	}

	/* clear and disable fifo */
	bus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);
	(void)bus_space_read_1(iot, ioh, com_data);
	bus_space_write_1(iot, ioh, com_fifo, 0);

	sc->sc_mcr = 0;
	bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);

#ifdef COM_CONSOLE
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		int maj;

		/* locate the major number */
		for (maj = 0; maj < nchrdev; maj++)
			if (cdevsw[maj].d_open == comopen)
				break;

		if (maj < nchrdev && cn_tab->cn_dev == NODEV)
			cn_tab->cn_dev = makedev(maj, sc->sc_dev.dv_unit);

		printf("%s: console\n", sc->sc_dev.dv_xname);
	}
#endif

	timeout_set(&sc->sc_diag_tmo, comdiag, sc);
	timeout_set(&sc->sc_dtr_tmo, com_raisedtr, sc);
#if NCOM > 0
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	sc->sc_si = softintr_establish(IPL_TTY, comsoft, sc);
	if (sc->sc_si == NULL)
		panic("%s: can't establish soft interrupt",
		    sc->sc_dev.dv_xname);
#else
	timeout_set(&sc->sc_comsoft_tmo, comsoft, sc);
#endif
#endif	/* NCOM */

	/*
	 * If there are no enable/disable functions, assume the device
	 * is always enabled.
	 */
	if (!sc->enable)
		sc->enabled = 1;

#if defined(COM_CONSOLE) || defined(KGDB)
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE|COM_HW_KGDB))
		com_enable_debugport(sc);
#endif
}

void
com_fifo_probe(struct com_softc *sc)
{
	bus_space_handle_t ioh = sc->sc_ioh;
	bus_space_tag_t iot = sc->sc_iot;
	u_int8_t fifo, ier;
	int timo, len;

	if (!ISSET(sc->sc_hwflags, COM_HW_FIFO))
		return;

	ier = 0;
#ifdef COM_PXA2X0
	if (sc->sc_uarttype == COM_UART_PXA2X0)
		ier |= IER_EUART;
#endif
	bus_space_write_1(iot, ioh, com_ier, ier);
	bus_space_write_1(iot, ioh, com_lcr, LCR_DLAB);
	bus_space_write_1(iot, ioh, com_dlbl, 3);
	bus_space_write_1(iot, ioh, com_dlbh, 0);
	bus_space_write_1(iot, ioh, com_lcr, LCR_PNONE | LCR_8BITS);
	bus_space_write_1(iot, ioh, com_mcr, MCR_LOOPBACK);

	fifo = FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST;
	if (sc->sc_uarttype == COM_UART_TI16750)
		fifo |= FIFO_ENABLE_64BYTE;

	bus_space_write_1(iot, ioh, com_fifo, fifo);

	for (len = 0; len < 256; len++) {
		bus_space_write_1(iot, ioh, com_data, (len + 1));
		timo = 2000;
		while (!ISSET(bus_space_read_1(iot, ioh, com_lsr),
		    LSR_TXRDY) && --timo)
			delay(1);
		if (!timo)
			break;
	}

	delay(100);

	for (len = 0; len < 256; len++) {
		timo = 2000;
		while (!ISSET(bus_space_read_1(iot, ioh, com_lsr),
		    LSR_RXRDY) && --timo)
			delay(1);
		if (!timo || bus_space_read_1(iot, ioh, com_data) != (len + 1))
			break;
	}

	/* For safety, always use the smaller value. */
	if (sc->sc_fifolen > len) {
		printf("%s: probed fifo depth: %d bytes\n",
		    sc->sc_dev.dv_xname, len);
		sc->sc_fifolen = len;
	}
}
@


1.13
log
@Keep order of "#if defined..." consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.12 2008/04/12 14:57:16 kettenis Exp $	*/
a70 3
#ifdef i386
#include "pccom.h"
#else
a71 1
#endif
a88 3
#endif
#if NPCCOM > 0
#include <i386/isa/pccomvar.h>
@


1.12
log
@Tighten check for consoleness by comparing comconsiot as well as comconsaddr.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.11 2007/10/22 14:11:44 fgsch Exp $	*/
d78 1
a78 1
#if defined(__sparc64__) || !defined(__sparc__)
@


1.11
log
@enable the fifo probe code as long as the serial is not used as console
or kgdb. if this probes to be a problem it will be disabled again .
tested and ok by toby@@ otto@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.10 2007/03/20 17:37:34 deraadt Exp $	*/
d153 1
a153 1
	if (sc->sc_iobase == comconsaddr) {
@


1.10
log
@An complete lack of peer review before this is commited means it gets pulled.
No exceptions.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.8 2006/12/28 20:50:26 miod Exp $	*/
d327 15
a341 2
#ifdef notyet
	com_fifo_probe(sc);
d343 1
a356 13

#ifdef KGDB
	/*
	 * Allow kgdb to "take over" this port.  If this is
	 * the kgdb device, it has exclusive use.
	 */

	if (iot == com_kgdb_iot && sc->sc_iobase == com_kgdb_addr &&
	    !ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		printf("%s: kgdb\n", sc->sc_dev.dv_xname);
		SET(sc->sc_hwflags, COM_HW_KGDB);
	}
#endif /* KGDB */
@


1.9
log
@on com_console we need a little delay to let fifo flush itself before resetting it and stuff to avoid garbled dmesg output; found on some arm
@
text
@a325 4
#ifdef COM_CONSOLE
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
		delay(10000);			/* wait for output to finish */
#endif
@


1.8
log
@Support for ST16C654 chips, however these aren't detected as such, so the
attachment code has to know better for now;
from Alexei G. Malinin (alexei.malinin@@inetcomm.ru)
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.7 2006/07/31 11:06:30 mickey Exp $	*/
d326 4
@


1.7
log
@puc@@cardbus (only added (commented out) to whom has puc@@pci enabled)
tested on puc@@pci by fkr and meself on the cardbus.
still needs a bit more work but generally works.
deraadt@@ ok and some input from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.6 2006/05/30 21:31:57 fkr Exp $	*/
d172 18
a189 22
#ifdef COM_PXA2X0
	/* Attachment driver presets COM_UART_PXA2X0. */
	if (sc->sc_uarttype != COM_UART_PXA2X0)
#endif
#ifdef COM_UART_OX16C950
	/* Attachment driver presets COM_UART_OX16C950. */
	if (sc->sc_uarttype != COM_UART_OX16C950)
#endif
	switch(bus_space_read_1(iot, ioh, com_iir) >> 6) {
	case 0:
		sc->sc_uarttype = COM_UART_16450;
		break;
	case 2:
		sc->sc_uarttype = COM_UART_16550;
		break;
	case 3:
		sc->sc_uarttype = COM_UART_16550A;
		break;
	default:
		sc->sc_uarttype = COM_UART_UNKNOWN;
		break;
	}
d298 5
@


1.6
log
@remove dev/isa/isavar.h include, not needed anymore
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.5 2005/11/02 22:35:06 fgsch Exp $	*/
d176 4
d314 7
@


1.5
log
@change zaurus fifo lenght back to 32 until some issues are sorted out.
requested by uwe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.4 2005/10/13 18:37:58 fgsch Exp $	*/
a94 1
#include <dev/isa/isavar.h>
@


1.4
log
@be sure to always set fifolen to at least 1 and if the code probes a 0 byte
fifo (ie., a 16450 misdetected as 16550a) the HW_FIFO bit is disabled.
reported and ok by miod@@. work with him.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.3 2005/10/13 14:58:56 fgsch Exp $	*/
d281 1
a281 1
		printf(": pxa2x0, 64 byte fifo");
d283 1
a283 1
		sc->sc_fifolen = 64;
@


1.3
log
@Over the years, different UARTs have appeared in the market.
Unfortunately most vendors implement hidden bits/features and ships with
buggy buffers. This is our first attempt to fix this.  Test the fifo size
by putting the fifo into loopback mode and reading back what we wrote.
It seems to be very much accurate and has correctly identified several
buggy UARTs. Commented out for now.
Tested by several people with different hardware, many thanks.
Idea from Theo, code by myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.2 2005/10/13 01:59:42 fgsch Exp $	*/
a314 2
	if (sc->sc_fifolen == 0)
		sc->sc_fifolen = 1;	/* default */
d319 5
@


1.2
log
@first thing found by the fifo tester; pxa2x0 uarts are actually 64 bytes
deep. ok by uwe@@ who confirmed this against specs.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_subr.c,v 1.1 2005/09/26 22:32:06 miod Exp $	*/
d111 1
d318 4
d383 58
@


1.1
log
@Share com probe code between com and pccom; allows us to get rid of awkward
code duplication in cardbus, pcmcia and puc attachments.

Joint effort with fgs@@; blessed deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d280 1
a280 1
		printf(": pxa2x0, 32 byte fifo");
d282 1
a282 1
		sc->sc_fifolen = 32;
@

