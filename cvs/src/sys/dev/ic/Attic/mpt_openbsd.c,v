head	1.34;
access;
symbols
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	SMP:1.11.0.2
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7;
locks; strict;
comment	@ * @;


1.34
date	2006.06.29.22.14.41;	author dlg;	state dead;
branches;
next	1.33;

1.33
date	2006.04.20.20.29.56;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.02.04.19.05.00;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.03.04.00.08;	author marco;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.01.02.15.21;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.28.23.24.31;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.20.03.24.35;	author marco;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.16.04.31.32;	author marco;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.06.01.42.23;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.02.03.27.39;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.20.03.20.06;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.20.03.14.26;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.20.03.05.32;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.20.02.48.39;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.28.14.38.27;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.21.04.49.26;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.03.00.59.56;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.26.04.43.59;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.22.04.54.26;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.23.20.52.15;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.12.23.57.14;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.30.00.45.04;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.22.18.57.18;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.28.01.45.48;	author marco;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2004.04.25.03.55.25;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.12.13.24.27;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.11.12.56.05;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.19.02.47.36;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.17.00.47.06;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.15.09.53.33;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.14.23.14.36;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.10.01.09.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.07.05.08.16;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.06.03.03.07;	author krw;	state Exp;
branches;
next	;

1.11.2.1
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.34
log
@remove mpt. it has since been replaced with mpi, which is a smaller and
cleaner driver that supports more hardware.
@
text
@/*	$OpenBSD: mpt_openbsd.c,v 1.33 2006/04/20 20:29:56 miod Exp $	*/
/*	$NetBSD: mpt_netbsd.c,v 1.7 2003/07/14 15:47:11 lukem Exp $	*/

/*
 * Copyright (c) 2004 Milos Urbanek
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 2000, 2001 by Greg Ansley
 * Partially derived from Matt Jacob's ISP driver.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Additional Copyright (c) 2002 by Matthew Jacob under same license.
 */

/*
 * mpt_openbsd.c:
 *
 * OpenBSD-specific routines for LSI Fusion adapters.  Includes some
 * bus_dma glue, and SCSI glue.
 *
 * Adapted from the NetBSD "mpt" driver by Milos Urbanek for
 * ZOOM International, s.r.o.
 */

#include <sys/cdefs.h>
/* __KERNEL_RCSID(0, "$NetBSD: mpt_netbsd.c,v 1.7 2003/07/14 15:47:11 lukem Exp $"); */

#include <dev/ic/mpt.h>			/* pulls in all headers */

void	mpt_run_ppr(struct mpt_softc *, int);
int	mpt_ppr(struct mpt_softc *, struct scsi_link *, int, int);
int	mpt_poll(struct mpt_softc *, struct scsi_xfer *, int);
void	mpt_timeout(void *);
void	mpt_done(struct mpt_softc *, uint32_t);
int	mpt_run_xfer(struct mpt_softc *, struct scsi_xfer *);
void	mpt_check_xfer_settings(struct mpt_softc *, struct scsi_xfer *, MSG_SCSI_IO_REQUEST *);
void	mpt_ctlop(struct mpt_softc *, void *vmsg, uint32_t);
void	mpt_event_notify_reply(struct mpt_softc *, MSG_EVENT_NOTIFY_REPLY *);

int	mpt_action(struct scsi_xfer *);
void	mpt_minphys(struct buf *);

struct cfdriver mpt_cd = {
	NULL, "mpt", DV_DULL
};

/* the below structure is so we have a default dev struct for our link struct */
static struct scsi_device mpt_dev = {
	NULL, /* Use default error handler */
	NULL, /* have a queue, served by this */
	NULL, /* have no async handler */
	NULL, /* Use default 'done' routine */
};

enum mpt_scsi_speed { U320, U160, U80 };

/*
 * try speed and
 * return 0 if failed
 * return 1 if passed
 */
int
mpt_ppr(struct mpt_softc *mpt, struct scsi_link *sc_link, int speed, int flags)
{
	CONFIG_PAGE_SCSI_DEVICE_0 page0;
	CONFIG_PAGE_SCSI_DEVICE_1 page1;
	uint8_t tp;
	int error;
	struct scsi_inquiry_data inqbuf;

	DNPRINTF(30, "Entering PPR\n");

	if (mpt->is_fc) {
		/*
		 * SCSI transport settings don't make any sense for
		 * Fibre Channel; silently ignore the request.
		 */
		return 1; /* success */
	}

	/*
	 * Always allow disconnect; we don't have a way to disable
	 * it right now, in any case.
	 */
	mpt->mpt_disc_enable |= (1 << sc_link->target);

	/*
	 * Enable tagged queueing.
	 */
	if (sc_link->quirks & SDEV_NOTAGS)
		mpt->mpt_tag_enable &= ~(1 << sc_link->target);
	else
		mpt->mpt_tag_enable |= (1 << sc_link->target);

	page1 = mpt->mpt_dev_page1[sc_link->target];

	/*
	 * Set the wide/narrow parameter for the target.
	 */
	if (sc_link->quirks & SDEV_NOWIDE)
		page1.RequestedParameters &= ~MPI_SCSIDEVPAGE1_RP_WIDE;
	else {
		page1.RequestedParameters |= MPI_SCSIDEVPAGE1_RP_WIDE;
	}

	/*
	 * Set the synchronous parameters for the target.
	 */
	page1.RequestedParameters &=
	    ~(MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK |
	    MPI_SCSIDEVPAGE1_RP_MAX_SYNC_OFFSET_MASK |
	    MPI_SCSIDEVPAGE1_RP_DT | MPI_SCSIDEVPAGE1_RP_QAS |
	    MPI_SCSIDEVPAGE1_RP_IU);

	if (!(sc_link->quirks & SDEV_NOSYNC)) {
		int factor, offset, np;

		/*
		 * Factor:
		 * 0x08 = U320 = 6.25ns
		 * 0x09 = U160 = 12.5ns
		 * 0x0a = U80 = 25ns
		 */
		factor = (mpt->mpt_port_page0.Capabilities >> 8) & 0xff;
		offset = (mpt->mpt_port_page0.Capabilities >> 16) & 0xff;
		np = 0;

		switch (speed) {
		case U320:
			/* do nothing */
			break;

		case U160:
			factor = 0x09; /* force U160 */
			break;

		case U80:
			factor = 0x0a; /* force U80 */
		}

		if (factor < 0x9) {
			/* Ultra320 enable QAS & IU */
			np |= MPI_SCSIDEVPAGE1_RP_QAS | MPI_SCSIDEVPAGE1_RP_IU;
		}
		if (factor < 0xa) {
			/* >= Ultra160 enable DT transfer */
			np |= MPI_SCSIDEVPAGE1_RP_DT;
		}
		np |= (factor << 8) | (offset << 16);
		page1.RequestedParameters |= np;
	}

	/* write parameters out to chip */
	if (mpt_write_cfg_page(mpt, sc_link->target, &page1.Header)) {
		mpt_prt(mpt, "unable to write Device Page 1");
		return 0;
	}

	/* make sure the parameters were written */
	if (mpt_read_cfg_page(mpt, sc_link->target, &page1.Header)) {
		mpt_prt(mpt, "unable to read back Device Page 1");
		return 0;
	}

	mpt->mpt_dev_page1[sc_link->target] = page1;

	DNPRINTF(30,
	    "%s: SPI Target %d Page 1: RequestedParameters %x Config %x\n",
	    DEVNAME(mpt),
	    sc_link->target,
	    mpt->mpt_dev_page1[sc_link->target].RequestedParameters,
	    mpt->mpt_dev_page1[sc_link->target].Configuration);

	/*
	 * use INQUIRY for PPR two reasons:
	 * 1) actually transfer data at requested speed
	 * 2) no need to test for TUR QUIRK
	 */
	error = scsi_inquire(sc_link, &inqbuf, flags);
	if (error) {
		mpt_prt(mpt, "Invalid INQUIRY on target: %d", sc_link->target);
		return 0;
	}

	/* read page 0 back to figure out if the PPR worked */
	page0 = mpt->mpt_dev_page0[sc_link->target];
	if (mpt_read_cfg_page(mpt, sc_link->target, &page0.Header)) {
		mpt_prt(mpt, "unable to read Device Page 0");
		return 0;
	}

	DNPRINTF(30,
	    "%s: SPI Tgt %d Page 0: NParms %x Information %x\n",
	    DEVNAME(mpt),
	    sc_link->target,
	    page0.NegotiatedParameters, page0.Information);

	if (!(page0.NegotiatedParameters & 0x07) && (speed == U320)) {
		/*
		 * if lowest 3 aren't set the PPR probably failed,
		 * retry with other parameters
		 */
		DNPRINTF(30, "%s: U320 PPR failed\n", DEVNAME(mpt));
		return 0;
	}

	if ((((page0.NegotiatedParameters >> 8) & 0xff) > 0x09) &&
	    (speed == U160)) {
		/* if transfer period > 0x09 then U160 PPR failed, retry */
		DNPRINTF(30, "%s: U160 PPR failed\n", DEVNAME(mpt));
		return 0;
	}

	/*
	 * Bit 3 - PPR rejected:  IOC sets this if the device rejects PPR.
	 * Bit 2 - WDTR rejected: IOC sets this if the device rejects WDTR.
	 * Bit 1 - SDTR Rejected: IOC sets this if the device rejects SDTR.
	 * Bit 0 - 1 A SCSI SDTR, WDTR, or PPR negotiation has occurred.
	 */
	if (page0.Information & 0x0e) {
		/* target rejected PPR message */
		mpt_prt(mpt, "Target %d rejected PPR message with %02x",
		    sc_link->target,
		    (uint8_t)page0.Information);

		return 0;
	}

	/* print PPR results */
	switch ((page0.NegotiatedParameters >> 8) & 0xff) {
	case 0x08:
		tp = 160;
		break;

	case 0x09:
		tp = 80;
		break;

	case 0x0a:
		tp = 40;
		break;

	case 0x0b:
		tp = 20;
		break;

	case 0x0c:
		tp = 10;
		break;

	default:
		tp = 0;
	}

	mpt_prt(mpt,
	    "target %d %s at %dMHz width %dbit offset %d QAS %d DT %d IU %d",
	    sc_link->target,
	    tp ? "Synchronous" : "Asynchronous",
	    tp,
	    (page0.NegotiatedParameters & 0x20000000) ? 16 : 8,
	    (page0.NegotiatedParameters >> 16) & 0xff,
	    (page0.NegotiatedParameters & 0x04) ? 1 : 0,
	    (page0.NegotiatedParameters & 0x02) ? 1 : 0,
	    (page0.NegotiatedParameters & 0x01) ? 1 : 0);

	return 1; /* success */
}

/*
 * Run PPR on all attached devices
 */
void
mpt_run_ppr(struct mpt_softc *mpt, int flags)
{
	struct scsi_link *sc_link;
	struct device *dev;
	u_int8_t target;
	u_int16_t buswidth;

	/* walk device list */
	for (dev = TAILQ_FIRST(&alldevs); dev != NULL;
	    dev = TAILQ_NEXT(dev, dv_list)) {
		if (dev->dv_parent == (struct device *)mpt) {
			/* found scsibus softc */
			buswidth = ((struct scsi_link *)&mpt->sc_link)->
			    adapter_buswidth;
			/* printf("mpt_softc: %x  scsibus: %x  buswidth: %d\n",
			 *     mpt, dev, buswidth); */
			/* walk target list */
			for (target = 0; target < buswidth; target++) {
				sc_link = ((struct scsibus_softc *)dev)->
				    sc_link[target][0];
				if ((sc_link != NULL)) {
					/* got a device! run PPR */
					/* skip CPU devices since they
					 * can crash at U320 speeds */
					if ((sc_link->inqdata.device & SID_TYPE)
					    == T_PROCESSOR) {
						continue;
					}
					if (mpt_ppr(mpt, sc_link, U320, flags)){
						mpt->mpt_negotiated_speed
						    [target] = U320;
						continue;
					}

					if (mpt_ppr(mpt, sc_link, U160, flags)){
						mpt->mpt_negotiated_speed
						    [target] = U160;
						continue;
					}

					if (mpt_ppr(mpt, sc_link, U80, flags)) {
						mpt->mpt_negotiated_speed
						    [target] = U80;
						continue;
					}
				} /* sc_link */
			} /* for target */
		} /* if dev */
	} /* end for dev */
}

/*
 * Complete attachment of hardware, include subdevices.
 */
void
mpt_attach(struct mpt_softc *mpt)
{
	struct scsi_link *lptr = &mpt->sc_link;

	mpt->bus = 0;		/* XXX ?? */

	/* Fill in the scsi_adapter. */
	mpt->sc_adapter.scsi_cmd = mpt_action;
	mpt->sc_adapter.scsi_minphys = mpt_minphys;

	/* Fill in the prototype scsi_link */
	lptr->adapter_softc = mpt;
	lptr->device = &mpt_dev;
	lptr->adapter = &mpt->sc_adapter;
	lptr->flags = 0;
	lptr->luns = 8;

	if (mpt->is_fc) {
		lptr->adapter_buswidth = 256;
		lptr->adapter_target = 256;
	} else {
		lptr->adapter_buswidth = 16;
		lptr->adapter_target = mpt->mpt_ini_id;
	}
	lptr->openings = MPT_MAX_REQUESTS(mpt) / lptr->adapter_buswidth;

	DNPRINTF(10, "%s: IM support: %x\n", DEVNAME(mpt), mpt->im_support);

	(void) config_found(&mpt->mpt_dev, lptr, scsiprint);

	/* done attaching now walk targets and PPR them */
	/* FC does not do PPR */
	if (!mpt->is_fc) {
		mpt_run_ppr(mpt, SCSI_POLL);
	}
}

int
mpt_dma_mem_alloc(struct mpt_softc *mpt)
{
	bus_dma_segment_t reply_seg, request_seg;
	int reply_rseg, request_rseg;
	bus_addr_t pptr, end;
	caddr_t vptr;
	size_t len;
	int error, i;

	/* Check if we have already allocated the reply memory. */
	if (mpt->reply != NULL)
		return (0);

	/*
	 * Allocate the request pool.  This isn't really DMA'd memory,
	 * but it's a convenient place to do it.
	 */
	len = sizeof(struct req_entry) * MPT_MAX_REQUESTS(mpt);
	mpt->request_pool = malloc(len, M_DEVBUF, M_WAITOK);
	if (mpt->request_pool == NULL) {
		printf("%s: unable to allocate request pool\n",
		    mpt->mpt_dev.dv_xname);
		return (ENOMEM);
	}
	bzero(mpt->request_pool, len);
	
	/*
	 * Allocate DMA resources for reply buffers.
	 */
	error = bus_dmamap_create(mpt->sc_dmat, PAGE_SIZE, 1, PAGE_SIZE,
	    0, 0, &mpt->reply_dmap);
	if (error) {
		printf("%s: unable to create reply DMA map, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto free_request_pool;
	}

	error = bus_dmamem_alloc(mpt->sc_dmat, PAGE_SIZE, PAGE_SIZE, 0,
	    &reply_seg, 1, &reply_rseg, 0);
	if (error) {
		printf("%s: unable to allocate reply area, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto destroy_reply;
	}

	error = bus_dmamem_map(mpt->sc_dmat, &reply_seg, reply_rseg, PAGE_SIZE,
	    (caddr_t *) &mpt->reply, BUS_DMA_COHERENT/*XXX*/);
	if (error) {
		printf("%s: unable to map reply area, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto free_reply;
	}

	error = bus_dmamap_load(mpt->sc_dmat, mpt->reply_dmap, mpt->reply,
	    PAGE_SIZE, NULL, 0);
	if (error) {
		printf("%s: unable to load reply DMA map, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto unmap_reply;
	}

	/*
	 * Allocate DMA resources for request buffers.
	 */
	error = bus_dmamap_create(mpt->sc_dmat, MPT_REQ_MEM_SIZE(mpt), 1,
	    MPT_REQ_MEM_SIZE(mpt), 0, 0, &mpt->request_dmap);
	if (error) {
		printf("%s: unable to create request DMA map, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto unload_reply;
	}

	error = bus_dmamem_alloc(mpt->sc_dmat, MPT_REQ_MEM_SIZE(mpt),
	    PAGE_SIZE, 0, &request_seg, 1, &request_rseg, 0);
	if (error) {
		printf("%s: unable to allocate request area, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto destroy_request;
	}

	error = bus_dmamem_map(mpt->sc_dmat, &request_seg, request_rseg,
	    MPT_REQ_MEM_SIZE(mpt), (caddr_t *) &mpt->request, 0);
	if (error) {
		printf("%s: unable to map request area, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto free_request;
	}

	error = bus_dmamap_load(mpt->sc_dmat, mpt->request_dmap, mpt->request,
	    MPT_REQ_MEM_SIZE(mpt), NULL, 0);
	if (error) {
		printf("%s: unable to load request DMA map, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto unmap_request;
	}

	pptr = mpt->request_dmap->dm_segs[0].ds_addr;
	vptr = (caddr_t) mpt->request;
	end = pptr + MPT_REQ_MEM_SIZE(mpt);

	for (i = 0; pptr < end; i++) {
		struct req_entry *req = &mpt->request_pool[i];
		req->index = i;

		/* Store location of Request Data */
		req->req_pbuf = pptr;
		req->req_vbuf = vptr;

		pptr += MPT_REQUEST_AREA;
		vptr += MPT_REQUEST_AREA;

		req->sense_pbuf = (pptr - MPT_SENSE_SIZE);
		req->sense_vbuf = (vptr - MPT_SENSE_SIZE);

		error = bus_dmamap_create(mpt->sc_dmat, MAXPHYS,
		    MPT_SGL_MAX, MAXPHYS, 0, 0, &req->dmap);
		if (error) {
			printf("%s: unable to create req %d DMA map, error = "
			    "%d", mpt->mpt_dev.dv_xname, i, error);
			goto unload_request;
		}
	}

	mpt->request_phys = mpt->request_dmap->dm_segs[0].ds_addr;
	mpt->reply_phys = mpt->reply_dmap->dm_segs[0].ds_addr;
	return (0);

unload_request:	
	for (--i; i >= 0; i--) {
		struct req_entry *req = &mpt->request_pool[i];
		if (req->dmap != NULL)
			bus_dmamap_destroy(mpt->sc_dmat, req->dmap);
	}
	bus_dmamap_unload(mpt->sc_dmat, mpt->request_dmap);
unmap_request:
	bus_dmamem_unmap(mpt->sc_dmat, (caddr_t)mpt->request, PAGE_SIZE);
free_request:
	bus_dmamem_free(mpt->sc_dmat, &request_seg, 1);
destroy_request:
	bus_dmamap_destroy(mpt->sc_dmat, mpt->request_dmap);

unload_reply:
	bus_dmamap_unload(mpt->sc_dmat, mpt->reply_dmap);
unmap_reply:
	bus_dmamem_unmap(mpt->sc_dmat, (caddr_t)mpt->reply, PAGE_SIZE);
free_reply:
	bus_dmamem_free(mpt->sc_dmat, &reply_seg, 1);
destroy_reply:
	bus_dmamap_destroy(mpt->sc_dmat, mpt->reply_dmap);
	
free_request_pool:
	free(mpt->request_pool, M_DEVBUF);

	mpt->reply = NULL;
	mpt->request = NULL;
	mpt->request_pool = NULL;

	return (error);
}

int
mpt_intr(void *arg)
{
	struct mpt_softc *mpt = arg;
	int nrepl = 0;
	uint32_t reply;

	/*
	if ((mpt_read(mpt, MPT_OFFSET_INTR_STATUS) & MPT_INTR_REPLY_READY) == 0)
		return (0);
	*/

	/*
	 * Speed up trick to save one PCI read.
	 * Reply FIFO replies 0xffffffff whenever
	 * MPT_OFFSET_INTR_STATUS & MPT_INTR_REPLY_READY == 0
	 *
	 */

	reply = mpt_pop_reply_queue(mpt);

	if (reply == 0xffffffff) {
		/* check doorbell, this is error path not IO path */
		/* FIXME for now ignore strays and doorbells */
		return (0);
	}

	while (reply != MPT_REPLY_EMPTY) {
		nrepl++;
#ifdef MPT_DEBUG
		if (mpt_debug > 50) {
			if ((reply & MPT_CONTEXT_REPLY) != 0)
				/* Address reply; IOC has something to say */
				mpt_print_reply(MPT_REPLY_PTOV(mpt, reply));
			else
				/* Context reply; all went well */
				mpt_prt(mpt, "context %u reply OK", reply);
		}
#endif /* MPT_DEBUG */
		mpt_done(mpt, reply);
		reply = mpt_pop_reply_queue(mpt);
	}
	return (nrepl != 0);
}

void
mpt_prt(struct mpt_softc *mpt, const char *fmt, ...)
{
	va_list ap;

	printf("%s: ", mpt->mpt_dev.dv_xname);
	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
	printf("\n");
}

int
mpt_poll(struct mpt_softc *mpt, struct scsi_xfer *xs, int count)
{

	/* Timeouts are in msec, so we loop in 1000usec cycles */
	while (count) {
		mpt_intr(mpt);
		if (xs->flags & ITSDONE) {
			return (0);
		}
		delay(1000);		/* only happens in boot, so ok */
		count--;
	}
	return (1);
}

void
mpt_timeout(void *arg)
{
	struct req_entry *req = arg;
	struct scsi_xfer *xs = req->xfer;
	struct scsi_link *linkp = xs->sc_link;
	struct mpt_softc *mpt = (void *) linkp->adapter_softc;
	uint32_t oseq;
	int s, index;

	mpt_prt(mpt, "command timeout");
	sc_print_addr(linkp);

	s = splbio();

	oseq = req->sequence;
	mpt->timeouts++;
	if (mpt_intr(mpt)) {
		if (req->sequence != oseq) {
			mpt_prt(mpt, "recovered from command timeout");
			splx(s);
			return;
		}
	}
	mpt_prt(mpt,
	    "timeout on request index = 0x%x, seq = 0x%08x",
	    req->index, req->sequence);
	mpt_check_doorbell(mpt);
	mpt_prt(mpt, "Status 0x%08x, Mask 0x%08x, Doorbell 0x%08x",
	    mpt_read(mpt, MPT_OFFSET_INTR_STATUS),
	    mpt_read(mpt, MPT_OFFSET_INTR_MASK),
	    mpt_read(mpt, MPT_OFFSET_DOORBELL));
#ifdef MPT_DEBUG
	mpt_prt(mpt, "request state: %s", mpt_req_state(req->debug));
	mpt_print_scsi_io_request((MSG_SCSI_IO_REQUEST *)req->req_vbuf);
#else
	mpt_prt(mpt, "request state: %i", req->debug);
#endif /* MPT_DEBUG */

	for(index = 0; index < MPT_MAX_REQUESTS(mpt); index++)
		if (req == &mpt->request_pool[index]) {
			req->debug = REQ_TIMEOUT;
			break;
		}

	mpt_done(mpt, index);

	splx(s);
}

void
mpt_done(struct mpt_softc *mpt, uint32_t reply)
{
	struct scsi_xfer *xs = NULL;
	struct scsi_link *linkp;
	int index;
	struct req_entry *req;
	MSG_REQUEST_HEADER *mpt_req;
	MSG_SCSI_IO_REPLY *mpt_reply;


	if ((reply & MPT_CONTEXT_REPLY) == 0) {
		/* context reply (ok) */
		mpt_reply = NULL;
		index = reply & MPT_CONTEXT_MASK;
	} else {
		/* address reply (error) */

		/* XXX BUS_DMASYNC_POSTREAD XXX */
		mpt_reply = MPT_REPLY_PTOV(mpt, reply);
#ifdef MPT_DEBUG
		if (mpt_debug > 50) {
			uint32_t *pReply = (uint32_t *) mpt_reply;

			mpt_prt(mpt, "Address Reply (index %u):",
			    mpt_reply->MsgContext & 0xffff);
			mpt_prt(mpt, "%08x %08x %08x %08x",
			    pReply[0], pReply[1], pReply[2], pReply[3]);
			mpt_prt(mpt, "%08x %08x %08x %08x",
			    pReply[4], pReply[5], pReply[6], pReply[7]);
			mpt_prt(mpt, "%08x %08x %08x %08x",
			    pReply[8], pReply[9], pReply[10], pReply[11]);
		}
#endif /* MPT_DEBUG */
		index = mpt_reply->MsgContext;
	}

	/*
	 * Address reply with MessageContext high bit set.
	 * This is most likely a notify message, so we try
	 * to process it, then free it.
	 */
	if ((index & 0x80000000) != 0) {
		if (mpt_reply != NULL)
			mpt_ctlop(mpt, mpt_reply, reply);
		else
			mpt_prt(mpt, "mpt_done: index 0x%x, NULL reply", index);
		return;
	}

	/* Did we end up with a valid index into the table? */
	if (index < 0 || index >= MPT_MAX_REQUESTS(mpt)) {
		mpt_prt(mpt, "mpt_done: invalid index (0x%x) in reply", index);
		return;
	}

	req = &mpt->request_pool[index];

	/* Make sure memory hasn't been trashed. */
	if (req->index != index) {
		mpt_prt(mpt, "mpt_done: corrupted struct req_entry (0x%x)", index);
		return;
	}

	MPT_SYNC_REQ(mpt, req, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	mpt_req = req->req_vbuf;

	/* Short cut for task management replies; nothing more for us to do. */
	if (mpt_req->Function == MPI_FUNCTION_SCSI_TASK_MGMT) {
		DNPRINTF(50, "%s: mpt_done: TASK MGMT\n", DEVNAME(mpt));
		goto done;
	}

	if (mpt_req->Function == MPI_FUNCTION_PORT_ENABLE)
		goto done;

	/*
	 * At this point, it had better be a SCSI I/O command, but don't
	 * crash if it isn't.
	 */
	if (mpt_req->Function != MPI_FUNCTION_SCSI_IO_REQUEST) {
		DNPRINTF(10, "%s: mpt_done: unknown Function 0x%x (0x%x)\n",
		    DEVNAME(mpt), mpt_req->Function, index);
		goto done;
	}

	/* Recover scsi_xfer from the request structure. */
	xs = req->xfer;

	/* Can't have a SCSI command without a scsi_xfer. */
	if (xs == NULL) {
		mpt_prt(mpt,
		    "mpt_done: no scsi_xfer, index = 0x%x, seq = 0x%08x",
		    req->index, req->sequence);
#ifdef MPT_DEBUG
		mpt_prt(mpt, "request state: %s", mpt_req_state(req->debug));
		mpt_prt(mpt, "mpt_request:");
		mpt_print_scsi_io_request((MSG_SCSI_IO_REQUEST *)req->req_vbuf);
#else
		mpt_prt(mpt, "request state: %i", req->debug);
#endif /* MPT_DEBUG */

		if (mpt_reply != NULL) {
#ifdef MPT_DEBUG
			mpt_prt(mpt, "mpt_reply:");
			mpt_print_reply(mpt_reply);
#endif /* MPT_DEBUG */
		} else {
			mpt_prt(mpt, "context reply: 0x%08x", reply);
		}
		goto done;
	}

	timeout_del(&xs->stimeout);

	linkp = xs->sc_link;

	/*
	 * If we were a data transfer, unload the map that described
	 * the data buffer.
	 */
	if (xs->datalen != 0) {
		bus_dmamap_sync(mpt->sc_dmat, req->dmap, 0,
		    req->dmap->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD
						      : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(mpt->sc_dmat, req->dmap);
	}

	if (req->debug == REQ_TIMEOUT) {
		xs->error = XS_TIMEOUT;
		xs->status = SCSI_OK;
		xs->resid = 0;
		goto done;
	} else if (mpt_reply == NULL) {
		/*
		 * Context reply; report that the command was
		 * successful!
		 *
		 * Also report the xfer mode, if necessary.
		 */
		xs->error = XS_NOERROR;
		xs->status = SCSI_OK;
		xs->resid = 0;
		goto done;
	}

	xs->status = mpt_reply->SCSIStatus;
	switch (mpt_reply->IOCStatus) {
	case MPI_IOCSTATUS_SCSI_DATA_OVERRUN:
		xs->error = XS_DRIVER_STUFFUP;
		break;

	case MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:
		/*
		 * Yikes!  Tagged queue full comes through this path!
		 *
		 * So we'll change it to a status error and anything
		 * that returns status should probably be a status
		 * error as well.
		 */
		xs->resid = xs->datalen - mpt_reply->TransferCount;
		if (mpt_reply->SCSIState &
		    MPI_SCSI_STATE_NO_SCSI_STATUS) {
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		/* FALLTHROUGH */
	case MPI_IOCSTATUS_SUCCESS:
	case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:
		switch (xs->status) {
		case SCSI_OK:
			xs->resid = 0;
			break;

		case SCSI_CHECK:
			xs->error = XS_SENSE;
			break;

		case SCSI_BUSY:
			xs->error = XS_BUSY;
			break;

		case SCSI_QUEUE_FULL:
			xs->error = XS_TIMEOUT;
			xs->retries++;
			break;
		default:
			sc_print_addr(linkp);
			mpt_prt(mpt, "invalid status code %d", xs->status);
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		break;

	case MPI_IOCSTATUS_BUSY:
	case MPI_IOCSTATUS_INSUFFICIENT_RESOURCES:
		xs->error = XS_BUSY;
		break;

	case MPI_IOCSTATUS_SCSI_INVALID_BUS:
	case MPI_IOCSTATUS_SCSI_INVALID_TARGETID:
	case MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:
		xs->error = XS_SELTIMEOUT;
		break;

	case MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:
		xs->error = XS_DRIVER_STUFFUP;
		break;

	case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:
		xs->error = XS_DRIVER_STUFFUP;
		break;

	case MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED:
		/* XXX */
		xs->error = XS_DRIVER_STUFFUP;
		break;

	case MPI_IOCSTATUS_SCSI_IOC_TERMINATED:
		/* XXX */
		xs->error = XS_DRIVER_STUFFUP;
		break;

	case MPI_IOCSTATUS_SCSI_EXT_TERMINATED:
		/* XXX This is a bus-reset */
		xs->error = XS_DRIVER_STUFFUP;
		break;

	default:
		/* XXX unrecognized HBA error */
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	if (mpt_reply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {
		memcpy(&xs->sense, req->sense_vbuf,
		    sizeof(xs->sense));
	} else if (mpt_reply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_FAILED) {
		/*
		 * This will cause the scsi layer to issue
		 * a REQUEST SENSE.
		 */
		if (xs->status == SCSI_CHECK)
			xs->error = XS_BUSY;
	}

 done:
	/* If IOC done with this requeset, free it up. */
	if (mpt_reply == NULL || (mpt_reply->MsgFlags & 0x80) == 0)
		mpt_free_request(mpt, req);

	/* If address reply, give the buffer back to the IOC. */
	if (mpt_reply != NULL)
		mpt_free_reply(mpt, (reply << 1));

	if (xs != NULL) {
		xs->flags |= ITSDONE;
		scsi_done(xs);
	}
}

int
mpt_run_xfer(struct mpt_softc *mpt, struct scsi_xfer *xs)
{
	struct scsi_link *linkp = xs->sc_link;
	struct req_entry *req;
	MSG_SCSI_IO_REQUEST *mpt_req;
	int error, s;

	s = splbio();
	req = mpt_get_request(mpt);
	if (req == NULL) {
		/* This should happen very infrequently. */
		xs->error = XS_DRIVER_STUFFUP;
		xs->flags |= ITSDONE;
		scsi_done(xs);
		splx(s);
		return (COMPLETE);
	}
	splx(s);

	/* Link the req and the scsi_xfer. */
	req->xfer = xs;

	/* Now we build the command for the IOC */
	mpt_req = req->req_vbuf;
	bzero(mpt_req, sizeof(*mpt_req));

	mpt_req->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
	mpt_req->Bus = mpt->bus;

	mpt_req->SenseBufferLength =
	    (sizeof(xs->sense) < MPT_SENSE_SIZE) ?
	    sizeof(xs->sense) : MPT_SENSE_SIZE;

	/*
	 * We use the message context to find the request structure when
	 * we get the command completion interrupt from the IOC.
	 */
	mpt_req->MsgContext = req->index;

	/* Which physical device to do the I/O on. */
	mpt_req->TargetID = linkp->target;
	mpt_req->LUN[1] = linkp->lun;

	/* Set the direction of the transfer. */
	if (xs->flags & SCSI_DATA_IN)
		mpt_req->Control = MPI_SCSIIO_CONTROL_READ;
	else if (xs->flags & SCSI_DATA_OUT)
		mpt_req->Control = MPI_SCSIIO_CONTROL_WRITE;
	else
		mpt_req->Control = MPI_SCSIIO_CONTROL_NODATATRANSFER;

	mpt_check_xfer_settings(mpt, xs, mpt_req);

	/* Copy the SCSI command block into place. */
	memcpy(mpt_req->CDB, xs->cmd, xs->cmdlen);

	mpt_req->CDBLength = xs->cmdlen;
	mpt_req->DataLength = xs->datalen;
	mpt_req->SenseBufferLowAddr = req->sense_pbuf;

	/*
	 * Map the DMA transfer.
	 */
	if (xs->datalen) {
		SGE_SIMPLE32 *se;

		error = bus_dmamap_load(mpt->sc_dmat, req->dmap, xs->data,
		    xs->datalen, NULL,
		    ((xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT
						       : BUS_DMA_WAITOK) |
		    BUS_DMA_STREAMING |
		    ((xs->flags & SCSI_DATA_IN) ? BUS_DMA_READ
						       : BUS_DMA_WRITE));
		switch (error) {
		case 0:
			break;

		case ENOMEM:
		case EAGAIN:
			xs->error = XS_DRIVER_STUFFUP;
			goto out_bad;
		default:
			mpt_prt(mpt, "error %d loading DMA map", error);
 out_bad:
			s = splbio();
			mpt_free_request(mpt, req);
			splx(s);
			return (TRY_AGAIN_LATER);
		}

		if (req->dmap->dm_nsegs > MPT_NSGL_FIRST(mpt)) {
			int seg, i, nleft = req->dmap->dm_nsegs;
			uint32_t flags;
			SGE_CHAIN32 *ce;

			seg = 0;

			mpt_req->DataLength = xs->datalen;
			flags = MPI_SGE_FLAGS_SIMPLE_ELEMENT;
			if (xs->flags & SCSI_DATA_OUT)
				flags |= MPI_SGE_FLAGS_HOST_TO_IOC;

			se = (SGE_SIMPLE32 *) &mpt_req->SGL;
			for (i = 0; i < MPT_NSGL_FIRST(mpt) - 1;
			    i++, se++, seg++) {
				uint32_t tf;

				bzero(se, sizeof(*se));
				se->Address = req->dmap->dm_segs[seg].ds_addr;
				MPI_pSGE_SET_LENGTH(se,
				    req->dmap->dm_segs[seg].ds_len);
				tf = flags;
				if (i == MPT_NSGL_FIRST(mpt) - 2)
					tf |= MPI_SGE_FLAGS_LAST_ELEMENT;
				MPI_pSGE_SET_FLAGS(se, tf);
				nleft--;
			}

			/*
			 * Tell the IOC where to find the first chain element.
			 */
			mpt_req->ChainOffset =
			    ((char *)se - (char *)mpt_req) >> 2;

			/*
			 * Until we're finished with all segments...
			 */
			while (nleft) {
				int ntodo;

				/*
				 * Construct the chain element that points to
				 * the next segment.
				 */
				ce = (SGE_CHAIN32 *) se++;
				if (nleft > MPT_NSGL(mpt)) {
					ntodo = MPT_NSGL(mpt) - 1;
					ce->NextChainOffset = (MPT_RQSL(mpt) -
					    sizeof(SGE_SIMPLE32)) >> 2;
					ce->Length = MPT_NSGL(mpt)
						* sizeof(SGE_SIMPLE32);
				} else {
					ntodo = nleft;
					ce->NextChainOffset = 0;
					ce->Length = ntodo
						* sizeof(SGE_SIMPLE32);
				}
				ce->Address = req->req_pbuf +
				    ((char *)se - (char *)mpt_req);
				ce->Flags = MPI_SGE_FLAGS_CHAIN_ELEMENT;
				for (i = 0; i < ntodo; i++, se++, seg++) {
					uint32_t tf;

					bzero(se, sizeof(*se));
					se->Address =
					    req->dmap->dm_segs[seg].ds_addr;
					MPI_pSGE_SET_LENGTH(se,
					    req->dmap->dm_segs[seg].ds_len);
					tf = flags;
					if (i == ntodo - 1) {
						tf |=
						    MPI_SGE_FLAGS_LAST_ELEMENT;
						if (ce->NextChainOffset == 0) {
							tf |=
						    MPI_SGE_FLAGS_END_OF_LIST |
						    MPI_SGE_FLAGS_END_OF_BUFFER;
						}
					}
					MPI_pSGE_SET_FLAGS(se, tf);
					nleft--;
				}
			}
			bus_dmamap_sync(mpt->sc_dmat, req->dmap, 0,
			    req->dmap->dm_mapsize,
			    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
			    BUS_DMASYNC_PREWRITE);
		} else {
			int i;
			uint32_t flags;

			mpt_req->DataLength = xs->datalen;
			flags = MPI_SGE_FLAGS_SIMPLE_ELEMENT;
			if (xs->flags & SCSI_DATA_OUT)
				flags |= MPI_SGE_FLAGS_HOST_TO_IOC;

			/* Copy the segments into our SG list. */
			se = (SGE_SIMPLE32 *) &mpt_req->SGL;
			for (i = 0; i < req->dmap->dm_nsegs;
			    i++, se++) {
				uint32_t tf;

				bzero(se, sizeof(*se));
				se->Address = req->dmap->dm_segs[i].ds_addr;
				MPI_pSGE_SET_LENGTH(se,
				    req->dmap->dm_segs[i].ds_len);
				tf = flags;
				if (i == req->dmap->dm_nsegs - 1) {
					tf |=
					    MPI_SGE_FLAGS_LAST_ELEMENT |
					    MPI_SGE_FLAGS_END_OF_BUFFER |
					    MPI_SGE_FLAGS_END_OF_LIST;
				}
				MPI_pSGE_SET_FLAGS(se, tf);
			}
			bus_dmamap_sync(mpt->sc_dmat, req->dmap, 0,
			    req->dmap->dm_mapsize,
			    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
			    BUS_DMASYNC_PREWRITE);
		}
	} else {
		/*
		 * No data to transfer; just make a single simple SGL
		 * with zero length.
		 */
		SGE_SIMPLE32 *se = (SGE_SIMPLE32 *) &mpt_req->SGL;
		bzero(se, sizeof(*se));
		MPI_pSGE_SET_FLAGS(se,
		    (MPI_SGE_FLAGS_LAST_ELEMENT | MPI_SGE_FLAGS_END_OF_BUFFER |
		    MPI_SGE_FLAGS_SIMPLE_ELEMENT | MPI_SGE_FLAGS_END_OF_LIST));
	}

#ifdef MPT_DEBUG
	if (mpt_debug > 50)
		mpt_print_scsi_io_request(mpt_req);
#endif /* MPT_DEBUG */

	s = splbio();

	/* Always reset xs->stimeout, lest we timeout_del() with trash */
	timeout_set(&xs->stimeout, mpt_timeout, req);

	if ((xs->flags & SCSI_POLL) == 0)
		timeout_add(&xs->stimeout, mstohz(xs->timeout));
	mpt_send_cmd(mpt, req);
	splx(s);

	if ((xs->flags & SCSI_POLL) == 0) {
		return (SUCCESSFULLY_QUEUED);
	}
	/*
	 * If we can't use interrupts, poll on completion.
	 */
	if (mpt_poll(mpt, xs, xs->timeout)) {
		mpt_timeout(req);
		/* XXX scsi_done called
		return (TRY_AGAIN_LATER);
		*/
		/* XXX MP this does not look correct */
		return (COMPLETE);
	}

	return (COMPLETE);
}

void
mpt_ctlop(struct mpt_softc *mpt, void *vmsg, uint32_t reply)
{
	MSG_DEFAULT_REPLY *dmsg = vmsg;

	switch (dmsg->Function) {
	case MPI_FUNCTION_EVENT_NOTIFICATION:
		mpt_event_notify_reply(mpt, vmsg);
		mpt_free_reply(mpt, (reply << 1));
		break;

	case MPI_FUNCTION_EVENT_ACK:
		mpt_free_reply(mpt, (reply << 1));
		break;

	case MPI_FUNCTION_PORT_ENABLE:
	    {
		MSG_PORT_ENABLE_REPLY *msg = vmsg;
		int index = msg->MsgContext & ~0x80000000;

		DNPRINTF(10, "%s: enable port reply index %d\n",
		    DEVNAME(mpt), index);

		if (index >= 0 && index < MPT_MAX_REQUESTS(mpt)) {
			struct req_entry *req = &mpt->request_pool[index];
			req->debug = REQ_DONE;
		}
		mpt_free_reply(mpt, (reply << 1));
		break;
	    }

	case MPI_FUNCTION_CONFIG:
	    {
		MSG_CONFIG_REPLY *msg = vmsg;
		int index = msg->MsgContext & ~0x80000000;
		if (index >= 0 && index < MPT_MAX_REQUESTS(mpt)) {
			struct req_entry *req = &mpt->request_pool[index];
			req->debug = REQ_DONE;
			req->sequence = reply;
		} else
			mpt_free_reply(mpt, (reply << 1));
		break;
	    }

	default:
		mpt_prt(mpt, "unknown ctlop: 0x%x", dmsg->Function);
	}
}

void
mpt_event_notify_reply(struct mpt_softc *mpt, MSG_EVENT_NOTIFY_REPLY *msg)
{

	switch (msg->Event) {
	case MPI_EVENT_LOG_DATA:
	    {
		int i;

		/* Some error occurrerd that the Fusion wants logged. */
		mpt_prt(mpt, "EvtLogData: IOCLogInfo: 0x%08x", msg->IOCLogInfo);
		mpt_prt(mpt, "EvtLogData: Event Data:");
		for (i = 0; i < msg->EventDataLength; i++) {
			if ((i % 4) == 0)
				printf("%s:\t", mpt->mpt_dev.dv_xname);
			printf("0x%08x%c", msg->Data[i],
			    ((i % 4) == 3) ? '\n' : ' ');
		}
		if ((i % 4) != 0)
			printf("\n");
		break;
	    }

	case MPI_EVENT_UNIT_ATTENTION:
		mpt_prt(mpt, "Unit Attn: Bus 0x%02x Target 0x%02x",
		    (msg->Data[0] >> 8) & 0xff, msg->Data[0] & 0xff);
		break;

	case MPI_EVENT_IOC_BUS_RESET:
		/* We generated a bus reset. */
		mpt_prt(mpt, "IOC Bus Reset Port %d",
		    (msg->Data[0] >> 8) & 0xff);
		break;

	case MPI_EVENT_EXT_BUS_RESET:
		/* Someone else generated a bus reset. */
		mpt_prt(mpt, "External Bus Reset");
		/*
		 * These replies don't return EventData like the MPI
		 * spec says they do.
		 */
		/* XXX Send an async event? */
		break;

	case MPI_EVENT_RESCAN:
		/*
		 * In general, thise means a device has been added
		 * to the loop.
		 */
		mpt_prt(mpt, "Rescan Port %d", (msg->Data[0] >> 8) & 0xff);
		/* XXX Send an async event? */
		break;

	case MPI_EVENT_LINK_STATUS_CHANGE:
		mpt_prt(mpt, "Port %d: Link state %s",
		    (msg->Data[1] >> 8) & 0xff,
		    (msg->Data[0] & 0xff) == 0 ? "Failed" : "Active");
		break;

	case MPI_EVENT_LOOP_STATE_CHANGE:
		switch ((msg->Data[0] >> 16) & 0xff) {
		case 0x01:
			mpt_prt(mpt,
			    "Port %d: FC Link Event: LIP(%02x,%02x) "
			    "(Loop Initialization)",
			    (msg->Data[1] >> 8) & 0xff,
			    (msg->Data[0] >> 8) & 0xff,
			    (msg->Data[0]     ) & 0xff);
			switch ((msg->Data[0] >> 8) & 0xff) {
			case 0xf7:
				if ((msg->Data[0] & 0xff) == 0xf7)
					mpt_prt(mpt, "\tDevice needs AL_PA");
				else
					mpt_prt(mpt, "\tDevice %02x doesn't "
					    "like FC performance",
					    msg->Data[0] & 0xff);
				break;

			case 0xf8:
				if ((msg->Data[0] & 0xff) == 0xf7)
					mpt_prt(mpt, "\tDevice detected loop "
					    "failure before acquiring AL_PA");
				else
					mpt_prt(mpt, "\tDevice %02x detected "
					    "loop failure",
					    msg->Data[0] & 0xff);
				break;

			default:
				mpt_prt(mpt, "\tDevice %02x requests that "
				    "device %02x reset itself",
				    msg->Data[0] & 0xff,
				    (msg->Data[0] >> 8) & 0xff);
				break;
			}
			break;

		case 0x02:
			mpt_prt(mpt, "Port %d: FC Link Event: LPE(%02x,%02x) "
			    "(Loop Port Enable)",
			    (msg->Data[1] >> 8) & 0xff,
			    (msg->Data[0] >> 8) & 0xff,
			    (msg->Data[0]     ) & 0xff);
			break;

		case 0x03:
			mpt_prt(mpt, "Port %d: FC Link Event: LPB(%02x,%02x) "
			    "(Loop Port Bypass)",
			    (msg->Data[1] >> 8) & 0xff,
			    (msg->Data[0] >> 8) & 0xff,
			    (msg->Data[0]     ) & 0xff);
			break;

		default:
			mpt_prt(mpt, "Port %d: FC Link Event: "
			    "Unknown event (%02x %02x %02x)",
			    (msg->Data[1] >>  8) & 0xff,
			    (msg->Data[0] >> 16) & 0xff,
			    (msg->Data[0] >>  8) & 0xff,
			    (msg->Data[0]      ) & 0xff);
			break;
		}
		break;

	case MPI_EVENT_LOGOUT:
		mpt_prt(mpt, "Port %d: FC Logout: N_PortID: %02x",
		    (msg->Data[1] >> 8) & 0xff, msg->Data[0]);
		break;

	case MPI_EVENT_EVENT_CHANGE:
		/*
		 * This is just an acknowledgement of our
		 * mpt_send_event_request().
		 */
		break;

	default:
		mpt_prt(mpt, "Unknown async event: 0x%x", msg->Event);
		break;
	}

	if (msg->AckRequired) {
		MSG_EVENT_ACK *ackp;
		struct req_entry *req;

		if ((req = mpt_get_request(mpt)) == NULL) {
			/* XXX XXX XXX XXXJRT */
			panic("mpt_event_notify_reply: unable to allocate "
			    "request structure");
		}

		ackp = (MSG_EVENT_ACK *) req->req_vbuf;
		bzero(ackp, sizeof(*ackp));
		ackp->Function = MPI_FUNCTION_EVENT_ACK;
		ackp->Event = msg->Event;
		ackp->EventContext = msg->EventContext;
		ackp->MsgContext = req->index | 0x80000000;
		mpt_check_doorbell(mpt);
		mpt_send_cmd(mpt, req);
	}
}

void
mpt_check_xfer_settings(struct mpt_softc *mpt, struct scsi_xfer *xs, MSG_SCSI_IO_REQUEST *mpt_req)
{
	if (mpt->is_fc) {
		/*
		 * SCSI transport settings don't make any sense for
		 * Fibre Channel; silently ignore the request.
		 */
		return;
	}

	/*
	 * XXX never do these commands with tags. Should really be
	 * in a higher layer.
	 */
	if (xs->cmd->opcode == INQUIRY ||
	    xs->cmd->opcode == TEST_UNIT_READY ||
	    xs->cmd->opcode == REQUEST_SENSE)
		return;

	/* Set the queue behavior. */
	if (mpt->is_fc || (mpt->mpt_tag_enable & (1 << xs->sc_link->target))) {
			mpt_req->Control |= MPI_SCSIIO_CONTROL_SIMPLEQ;
	} else {
		mpt_req->Control |= MPI_SCSIIO_CONTROL_UNTAGGED;
		mpt_req->Control |= MPI_SCSIIO_CONTROL_NO_DISCONNECT;
	}
}

/*****************************************************************************
 * SCSI interface routines
 *****************************************************************************/

int
mpt_action(struct scsi_xfer *xfer)
{
	struct mpt_softc *mpt = (void *) xfer->sc_link->adapter_softc;
	int ret;

	ret = mpt_run_xfer(mpt, xfer);

	return ret;
}

void
mpt_minphys(struct buf *bp)
{

/*
 * Subtract one from the SGL limit, since we need an extra one to handle
 * an non-page-aligned transfer.
 */
#define	MPT_MAX_XFER	((MPT_SGL_MAX - 1) * PAGE_SIZE)

	if (bp->b_bcount > MPT_MAX_XFER)
		bp->b_bcount = MPT_MAX_XFER;
	minphys(bp);
}

/*
 * Allocate DMA resources for FW image
 *
 * img_sz : size of image
 * maxsgl : maximum number of DMA segments
 */
int
mpt_alloc_fw_mem(struct mpt_softc *mpt, int maxsgl)
{
	int error, rseg;

	error = bus_dmamap_create(mpt->sc_dmat, mpt->fw_image_size, maxsgl,
	    mpt->fw_image_size, 0, 0, &mpt->fw_dmap);
	if (error) {
		mpt_prt(mpt, "unable to create request DMA map, error = %d",
		    error);
		return (error);
	}

	error = bus_dmamem_alloc(mpt->sc_dmat, mpt->fw_image_size, PAGE_SIZE, 0,
		&mpt->fw_seg, 1, &rseg, 0);
	if (error) {
		mpt_prt(mpt, "unable to allocate fw memory, error = %d", error);
		goto destroy;
	}

	error = bus_dmamem_map(mpt->sc_dmat, &mpt->fw_seg, 1,
	    mpt->fw_image_size, (caddr_t *)&mpt->fw, BUS_DMA_COHERENT);
	if (error) {
		mpt_prt(mpt, "unable to map fw area, error = %d", error);
		goto free;
	}

	error = bus_dmamap_load(mpt->sc_dmat, mpt->fw_dmap, mpt->fw,
	    mpt->fw_image_size, NULL, 0);
	if (error) {
		mpt_prt(mpt, "unable to load request DMA map, error = %d",
		    error);
		goto unmap;
	}

	return(error);

unmap:
	bus_dmamem_unmap(mpt->sc_dmat, (caddr_t)mpt->fw, mpt->fw_image_size);
free:
	bus_dmamem_free(mpt->sc_dmat, &mpt->fw_seg, 1);
destroy:
	bus_dmamap_destroy(mpt->sc_dmat, mpt->fw_dmap);

	mpt->fw = NULL;
	bzero(&mpt->fw_seg, sizeof(mpt->fw_seg));
		
	return (error);
}

void
mpt_free_fw_mem(struct mpt_softc *mpt)
{
	bus_dmamap_unload(mpt->sc_dmat, mpt->fw_dmap);
	bus_dmamem_unmap(mpt->sc_dmat, (caddr_t)mpt->fw, mpt->fw_image_size);
	bus_dmamem_free(mpt->sc_dmat, &mpt->fw_seg, 1);
	bus_dmamap_destroy(mpt->sc_dmat, mpt->fw_dmap);
}
@


1.33
log
@printf() calls with the format string spanning several lines should not have
trailing commas between string chunks, for this has unexpected effects.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.32 2006/02/04 19:05:00 marco Exp $	*/
@


1.32
log
@Redo debugging mechanism to something less loud and more useful.

Shaves 22k of the kernel.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.31 2005/12/03 04:00:08 marco Exp $	*/
d562 1
a562 1
			printf("%s: unable to create req %d DMA map, error = ",
@


1.31
log
@Remove some typedef struct goo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.30 2005/12/01 02:15:21 krw Exp $	*/
d150 1
a150 3
	if (mpt->verbose > 1) {
		mpt_prt(mpt, "Entering PPR");
	}
d245 7
a251 7
	if (mpt->verbose > 1) {
		mpt_prt(mpt,
		    "SPI Target %d Page 1: RequestedParameters %x Config %x",
		    sc_link->target,
		    mpt->mpt_dev_page1[sc_link->target].RequestedParameters,
		    mpt->mpt_dev_page1[sc_link->target].Configuration);
	}
d271 5
a275 6
	if (mpt->verbose > 1) {
		mpt_prt(mpt,
		    "SPI Tgt %d Page 0: NParms %x Information %x",
		    sc_link->target,
		    page0.NegotiatedParameters, page0.Information);
	}
d282 1
a282 3
		if (mpt->verbose > 1) {
			mpt_prt(mpt, "U320 PPR failed");
		}
d289 1
a289 3
		if (mpt->verbose > 1) {
			mpt_prt(mpt, "U160 PPR failed");
		}
d433 1
a433 5
#ifdef MPT_DEBUG
	mpt->verbose = 2;
#endif

	mpt_prt(mpt, "IM support: %x", mpt->im_support);
d634 3
a636 2
		if (mpt->verbose > 1) {
			if ((reply & MPT_CONTEXT_REPLY) != 0) {
d639 1
a639 1
			} else {
a641 1
			}
d643 1
d710 1
d712 4
a715 2
	if (mpt->verbose > 1)
		mpt_print_scsi_io_request((MSG_SCSI_IO_REQUEST *)req->req_vbuf);
d748 2
a749 1
		if (mpt->verbose > 1) {
d761 1
d797 1
a797 2
		if (mpt->verbose > 1)
			mpt_prt(mpt, "mpt_done: TASK MGMT");
d809 2
a810 3
		if (mpt->verbose > 1)
			mpt_prt(mpt, "mpt_done: unknown Function 0x%x (0x%x)",
			    mpt_req->Function, index);
d822 1
d826 3
d831 1
d834 1
d1212 2
a1213 1
	if (mpt->verbose > 1)
d1215 1
d1264 4
a1267 2
		if (mpt->verbose > 1)
			mpt_prt(mpt, "enable port reply index %d", index);
@


1.30
log
@bus_dma code clean up. No functional change. Polished form of diff
from marco@@.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.29 2005/11/28 23:24:31 krw Exp $	*/
d109 3
a111 3
void	mpt_run_ppr(mpt_softc_t *, int);
int	mpt_ppr(mpt_softc_t *, struct scsi_link *, int, int);
int	mpt_poll(mpt_softc_t *, struct scsi_xfer *, int);
d113 5
a117 5
void	mpt_done(mpt_softc_t *, uint32_t);
int	mpt_run_xfer(mpt_softc_t *, struct scsi_xfer *);
void	mpt_check_xfer_settings(mpt_softc_t *, struct scsi_xfer *, MSG_SCSI_IO_REQUEST *);
void	mpt_ctlop(mpt_softc_t *, void *vmsg, uint32_t);
void	mpt_event_notify_reply(mpt_softc_t *, MSG_EVENT_NOTIFY_REPLY *);
d142 1
a142 1
mpt_ppr(mpt_softc_t *mpt, struct scsi_link *sc_link, int speed, int flags)
d359 1
a359 1
mpt_run_ppr(mpt_softc_t *mpt, int flags)
d414 1
a414 1
mpt_attach(mpt_softc_t *mpt)
d456 1
a456 1
mpt_dma_mem_alloc(mpt_softc_t *mpt)
d473 1
a473 1
	len = sizeof(request_t) * MPT_MAX_REQUESTS(mpt);
d557 1
a557 1
		request_t *req = &mpt->request_pool[i];
d585 1
a585 1
		request_t *req = &mpt->request_pool[i];
d619 1
a619 1
	mpt_softc_t *mpt = arg;
d661 1
a661 1
mpt_prt(mpt_softc_t *mpt, const char *fmt, ...)
d673 1
a673 1
mpt_poll(mpt_softc_t *mpt, struct scsi_xfer *xs, int count)
d691 1
a691 1
	request_t *req = arg;
d694 1
a694 1
	mpt_softc_t *mpt = (void *) linkp->adapter_softc;
d736 1
a736 1
mpt_done(mpt_softc_t *mpt, uint32_t reply)
d741 1
a741 1
	request_t *req;
d793 1
a793 1
		mpt_prt(mpt, "mpt_done: corrupted request_t (0x%x)", index);
d992 1
a992 1
mpt_run_xfer(mpt_softc_t *mpt, struct scsi_xfer *xs)
d995 1
a995 1
	request_t *req;
d1245 1
a1245 1
mpt_ctlop(mpt_softc_t *mpt, void *vmsg, uint32_t reply)
d1266 1
a1266 1
			request_t *req = &mpt->request_pool[index];
d1278 1
a1278 1
			request_t *req = &mpt->request_pool[index];
d1292 1
a1292 1
mpt_event_notify_reply(mpt_softc_t *mpt, MSG_EVENT_NOTIFY_REPLY *msg)
d1434 1
a1434 1
		request_t *req;
d1454 1
a1454 1
mpt_check_xfer_settings(mpt_softc_t *mpt, struct scsi_xfer *xs, MSG_SCSI_IO_REQUEST *mpt_req)
d1489 1
a1489 1
	mpt_softc_t *mpt = (void *) xfer->sc_link->adapter_softc;
d1519 1
a1519 1
mpt_alloc_fw_mem(mpt_softc_t *mpt, int maxsgl)
d1569 1
a1569 1
mpt_free_fw_mem(mpt_softc_t *mpt)
@


1.29
log
@Correct parameter in bus_dmamem_alloc().

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.28 2005/11/20 03:24:35 marco Exp $	*/
d481 1
d485 8
d498 1
a498 1
		goto fail_0;
d506 1
a506 9
		goto fail_1;
	}

	error = bus_dmamap_create(mpt->sc_dmat, PAGE_SIZE, 1, PAGE_SIZE,
	    0, 0, &mpt->reply_dmap);
	if (error) {
		printf("%s: unable to create reply DMA map, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto fail_2;
d514 1
a514 1
		goto fail_3;
a515 1
	mpt->reply_phys = mpt->reply_dmap->dm_segs[0].ds_addr;
d520 8
d533 1
a533 1
		goto fail_4;
d541 1
a541 9
		goto fail_5;
	}

	error = bus_dmamap_create(mpt->sc_dmat, MPT_REQ_MEM_SIZE(mpt), 1,
	    MPT_REQ_MEM_SIZE(mpt), 0, 0, &mpt->request_dmap);
	if (error) {
		printf("%s: unable to create request DMA map, error = %d\n",
		    mpt->mpt_dev.dv_xname, error);
		goto fail_6;
d549 1
a549 1
		goto fail_7;
a550 1
	mpt->request_phys = mpt->request_dmap->dm_segs[0].ds_addr;
d552 1
a552 1
	pptr = mpt->request_phys;
d575 1
a575 1
			goto fail_8;
d579 2
d583 1
a583 1
 fail_8:
d590 5
a594 1
 fail_7:
d596 2
a597 5
 fail_6:
	bus_dmamem_unmap(mpt->sc_dmat, (caddr_t)mpt->request, PAGE_SIZE);
 fail_5:
	bus_dmamem_free(mpt->sc_dmat, &request_seg, request_rseg);
 fail_4:
d599 5
a603 1
 fail_3:
d605 2
a606 5
 fail_2:
	bus_dmamem_unmap(mpt->sc_dmat, (caddr_t)mpt->reply, PAGE_SIZE);
 fail_1:
	bus_dmamem_free(mpt->sc_dmat, &reply_seg, reply_rseg);
 fail_0:
d1519 1
a1519 1
mpt_alloc_fw_mem(mpt_softc_t *mpt, uint32_t img_sz, int maxsgl)
d1521 1
a1521 1
	int error;
d1523 2
a1524 2
	error = bus_dmamap_create(mpt->sc_dmat, img_sz, maxsgl, img_sz,
	    0, 0, &mpt->fw_dmap);
d1528 1
a1528 1
		goto fw_fail0;
d1531 2
a1532 2
	error = bus_dmamem_alloc(mpt->sc_dmat, img_sz, PAGE_SIZE, 0,
		&mpt->fw_seg, 1, &mpt->fw_rseg, 0);
d1535 1
a1535 1
		goto fw_fail1;
d1538 2
a1539 2
	error = bus_dmamem_map(mpt->sc_dmat, &mpt->fw_seg, mpt->fw_rseg, img_sz,
		(caddr_t *)&mpt->fw, BUS_DMA_COHERENT);
d1542 1
a1542 1
		goto fw_fail2;
d1545 2
a1546 2
	error = bus_dmamap_load(mpt->sc_dmat, mpt->fw_dmap, mpt->fw, img_sz,
		NULL, 0);
d1548 3
a1550 2
		mpt_prt(mpt, "unable to load request DMA map, error = %d", error);
		goto fw_fail3;
d1555 5
a1559 5
fw_fail3:
	bus_dmamem_unmap(mpt->sc_dmat, (caddr_t)mpt->fw, img_sz);
fw_fail2:
	bus_dmamem_free(mpt->sc_dmat, &mpt->fw_seg, mpt->fw_rseg);
fw_fail1:
d1561 1
a1561 1
fw_fail0:
d1563 2
d1573 1
a1573 1
	bus_dmamem_free(mpt->sc_dmat, &mpt->fw_seg, mpt->fw_rseg);
@


1.28
log
@Reorder dma stuff so that it makes sense.

ok dlg@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.27 2005/11/16 04:31:32 marco Exp $	*/
d1529 1
a1529 1
		&mpt->fw_seg, maxsgl, &mpt->fw_rseg, 0);
@


1.27
log
@Synch up all .h mpi files with FreeBSD.  These new files contain the latest
LSI changes necssary for IM.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.26 2005/11/06 01:42:23 dlg Exp $	*/
d1520 8
d1532 1
a1532 1
		goto fw_fail0;
a1538 8
		goto fw_fail1;
	}

	error = bus_dmamap_create(mpt->sc_dmat, img_sz, maxsgl, img_sz,
		0, 0, &mpt->fw_dmap);
	if (error) {
		mpt_prt(mpt, "unable to create request DMA map, error = %d",
			error);
d1550 1
d1552 1
a1552 1
	bus_dmamap_unload(mpt->sc_dmat, mpt->fw_dmap);
d1554 2
a1556 2
fw_fail1:
	bus_dmamem_unmap(mpt->sc_dmat, (caddr_t)mpt->fw, img_sz);
a1557 2
	bus_dmamem_free(mpt->sc_dmat, &mpt->fw_seg, mpt->fw_rseg);

a1565 1
	bus_dmamap_destroy(mpt->sc_dmat, mpt->fw_dmap);
d1568 1
@


1.26
log
@clean up some early but unused work on bio support.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.25 2005/11/02 03:27:39 krw Exp $	*/
d144 2
a145 2
	fCONFIG_PAGE_SCSI_DEVICE_0 page0;
	fCONFIG_PAGE_SCSI_DEVICE_1 page1;
@


1.25
log
@It is invalid to scsi_done(xs) and then return TRY_AGAIN_LATER.
scsi_done() can release the scsi_request xs and TRY_AGAIN_LATER will
refer to it and submit it for re-execution. This was being done only
if bus_dmamap_load() failed.

Ensure the controller resources are freed before returning
TRY_AGAIN_LATER, since new resources will be allocated when the
command is executed again.

Don't bother setting xs->error before returning TRY_AGAIN_LATER as the
code returned to sets xs->error to XS_BUSY.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.24 2005/07/20 03:20:06 marco Exp $	*/
a121 3
#if NBIO > 0
int    mpt_ioctl(struct device *, u_long, caddr_t);
#endif
a443 6
#if NBIO > 0
	if (bio_register(&mpt->mpt_dev, mpt_ioctl) != 0)
		panic("%s: controller registration failed",
		    mpt->mpt_dev.dv_xname);
#endif

a1570 67

#if NBIO > 0
int
mpt_ioctl(dev, cmd, addr)
	struct device *dev;
	u_long cmd;
	caddr_t addr;
{
	int error = 0;
	int rv;
	struct mpt_dummy *dummy;
	struct mpt_mfg0 *pmfg0;
	fCONFIG_PAGE_MANUFACTURING_0 mfgp0;
	mpt_softc_t *mpt = (mpt_softc_t *)dev;

	switch (cmd) {
	case MPT_IOCTL_DUMMY:
		dummy = (struct mpt_dummy *)addr;
		if (mpt->verbose > 2) {
			printf("%s: MPT_IOCTL_DUMMY %d\n",
			    dev->dv_xname, dummy->x++);
		}
		break;
	case MPT_IOCTL_MFG0:
		/* Retrieve Manufacturing Page 0 */
		mfgp0.Header.PageNumber = 0;
		mfgp0.Header.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
		rv = mpt_read_cfg_page(mpt, 0, &mfgp0.Header);
		if (rv) {
			mpt_prt(mpt, "Could not retrieve MFG PAGE 0.");
			error = EINVAL;
		} else {
			if (mpt->verbose > 2) {
				printf("Chip name: %s\n",
				    mfgp0.ChipName);
				printf("Chip Revision: %s\n",
				    mfgp0.ChipRevision);
				printf("Board name: %s\n",
				    mfgp0.BoardName);
				printf("Board assembly: %s\n",
				    mfgp0.BoardAssembly);
				printf("Board tracer number: %s\n",
				    mfgp0.BoardTracerNumber);
			}
			pmfg0 = (struct mpt_mfg0 *)addr;
			memcpy(&pmfg0->cpm0, &mfgp0,
			    sizeof(fCONFIG_PAGE_MANUFACTURING_0));
		}
		break;
	case MPT_IOCTL_MFG1:
		/* Retrieve Manufacturing Page 1 */
		break;
	case MPT_IOCTL_MFG2:
		/* Retrieve Manufacturing Page 2 */
		break;
	case MPT_IOCTL_MFG3:
		/* Retrieve Manufacturing Page 3 */
		break;
	case MPT_IOCTL_MFG4:
		/* Retrieve Manufacturing Page 4 */
		break;
	default:
		error = EINVAL;
	}
	return (error);
}
#endif
@


1.24
log
@Remove some more dead code and stale comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.23 2005/07/20 03:14:26 marco Exp $	*/
a1079 1
			xs->error = XS_DRIVER_STUFFUP;
a1083 2
			xs->flags |= ITSDONE;
			scsi_done(xs);
@


1.23
log
@Remove some old NetBSDism for resource shortages.  Add proper handling for this
in OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.22 2005/07/20 03:05:32 marco Exp $	*/
a453 2
	/*mpt_prt(mpt, "IM support: %x %x", mpt->im_support,
	    mpt->mpt_ioc_page2.CapabilitiesFlags);*/
a875 7
#if 0 /*XXX report xfer mode not impl */
		if (mpt->mpt_report_xfer_mode != 0) {
			if ((mpt->mpt_report_xfer_mode &
			    (1 << periph->periph_target)) != 0)
				mpt_get_xfer_mode(mpt, periph);
		}
#endif
a906 6
#if 0 /* XXX xfer mode */
			/* Report the xfer mode, if necessary. */
			if ((mpt->mpt_report_xfer_mode &
			    (1 << periph->periph_target)) != 0)
				mpt_get_xfer_mode(mpt, periph);
#endif
d1246 1
a1488 6
#if 0
	if (mpt->is_fc == 0 && (mpt->mpt_disc_enable &
			(1 << linkp->target)) == 0)
		mpt_req->Control |= MPI_SCSIIO_CONTROL_NO_DISCONNECT;
#endif
	return;
a1490 2
/* XXXJRT mpt_bus_reset() */

d1502 1
a1503 15
#if 0
	switch (req) {
	case ADAPTER_REQ_RUN_XFER:
		mpt_run_xfer(mpt, (struct scsipi_xfer *) arg);
		return;

	case ADAPTER_REQ_GROW_RESOURCES:
		/* Not supported. */
		return;

	case ADAPTER_REQ_SET_XFER_MODE:
		mpt_set_xfer_mode(mpt, (struct scsipi_xfer_mode *) arg);
		return;
	}
#endif
@


1.22
log
@Delete dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.21 2005/07/20 02:48:39 marco Exp $	*/
a944 1
#if 0 /* XS_RESOURCE_SHORTAGE not impl */
d947 1
a947 1
		xs->error = XS_RESOURCE_SHORTAGE;
d949 1
a949 1
#endif
a1092 1
			/* xs->error = XS_RESOURCE_SHORTAGE; */
@


1.21
log
@Skip processor devices when running PPR as per XXX.  Ran into a box where the
SAFTE device freaked out when a PPR was attempted.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.20 2004/12/28 14:38:27 deraadt Exp $	*/
a1025 3
		/*
		xs->error = XS_RESOURCE_SHORTAGE;
		*/
@


1.20
log
@indent properly
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.19 2004/11/21 04:49:26 marco Exp $	*/
d384 1
a384 1
					/* FIXME: skip CPU devices since they
d386 2
a387 1
					/*if (device == cpu) {
d389 1
a389 1
					}*/
@


1.19
log
@Fix theo's amd64
Fix vmware
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.18 2004/10/26 04:43:59 marco Exp $	*/
d130 1
a130 2
static struct scsi_device mpt_dev = 
{
d258 1
a258 1
	/* 
d270 5
a274 5
        page0 = mpt->mpt_dev_page0[sc_link->target];
        if (mpt_read_cfg_page(mpt, sc_link->target, &page0.Header)) {
                mpt_prt(mpt, "unable to read Device Page 0");
                return 0;
        }
d276 2
a277 2
        if (mpt->verbose > 1) {
                mpt_prt(mpt,
d281 1
a281 1
        }
d288 1
a288 1
        	if (mpt->verbose > 1) {
d297 1
a297 1
        	if (mpt->verbose > 1) {
d447 4
a450 4
        if (bio_register(&mpt->mpt_dev, mpt_ioctl) != 0)
                panic("%s: controller registration failed",
                    mpt->mpt_dev.dv_xname);
#endif  
d637 1
a637 1
	 * Reply FIFO replies 0xffffffff whenever 
d764 1
a764 1
			
d880 1
a880 1
			     (1 << periph->periph_target)) != 0)
d918 1
a918 1
			     (1 << periph->periph_target)) != 0)
d984 1
a984 1
		
d1124 1
a1124 1
			     i++, se++, seg++) {
d1194 2
a1195 3
			    (xs->flags & SCSI_DATA_IN) ?
			    				BUS_DMASYNC_PREREAD
						      : BUS_DMASYNC_PREWRITE);
d1208 1
a1208 1
			     i++, se++) {
d1226 2
a1227 3
			    (xs->flags & SCSI_DATA_IN) ?
			    				BUS_DMASYNC_PREREAD
						      : BUS_DMASYNC_PREWRITE);
d1238 1
a1238 1
		     MPI_SGE_FLAGS_SIMPLE_ELEMENT | MPI_SGE_FLAGS_END_OF_LIST));
d1458 1
a1458 1
	
d1496 2
a1497 2
             xs->cmd->opcode == TEST_UNIT_READY ||
             xs->cmd->opcode == REQUEST_SENSE)
d1610 1
a1610 1
 
d1627 3
a1629 3
        struct device *dev;
        u_long cmd;
        caddr_t addr;
d1639 16
a1654 2
		case MPT_IOCTL_DUMMY:
			dummy = (struct mpt_dummy *)addr;
d1656 10
a1665 2
				printf("%s: MPT_IOCTL_DUMMY %d\n",
				    dev->dv_xname, dummy->x++);
d1667 19
a1685 42
			break;
		case MPT_IOCTL_MFG0:
			/* Retrieve Manufacturing Page 0 */
			mfgp0.Header.PageNumber = 0;
			mfgp0.Header.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
			rv = mpt_read_cfg_page(mpt, 0, &mfgp0.Header);
			if (rv) {
				mpt_prt(mpt, "Could not retrieve MFG PAGE 0.");
				error = EINVAL;
			}
			else {  
				if (mpt->verbose > 2) {
					printf("Chip name: %s\n",
					    mfgp0.ChipName);
					printf("Chip Revision: %s\n",
					    mfgp0.ChipRevision);
					printf("Board name: %s\n",
					    mfgp0.BoardName);
					printf("Board assembly: %s\n",
					    mfgp0.BoardAssembly);
					printf("Board tracer number: %s\n",
					    mfgp0.BoardTracerNumber);
				}
				pmfg0 = (struct mpt_mfg0 *)addr;
				memcpy(&pmfg0->cpm0, &mfgp0,
				    sizeof(fCONFIG_PAGE_MANUFACTURING_0));
			}
			break;
			/* Retrieve Manufacturing Page 1 */
		case MPT_IOCTL_MFG1:
			break;
			/* Retrieve Manufacturing Page 2 */
		case MPT_IOCTL_MFG2:
			break;
			/* Retrieve Manufacturing Page 3 */
		case MPT_IOCTL_MFG3:
			break;
			/* Retrieve Manufacturing Page 4 */
		case MPT_IOCTL_MFG4:
			break;
		default:
			error = EINVAL;
@


1.18
log
@Revert to 3.6-current code since IBM onboard mpt's act up.  Found by pval & deraadt

no cookie for me...
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.15 2004/08/23 20:52:15 marco Exp $	*/
d122 3
d194 2
a195 1
	page1.RequestedParameters &= ~(MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK |
d199 1
d212 1
a212 1
		
d214 7
a220 3
			case U320:
				/* do nothing */
				break;
d222 2
a223 6
			case U160:
				factor = 0x09; /* force U160 */
				break;
				
			case U80:
				factor = 0x0a; /* force U80 */
d279 3
a281 3
                    "SPI Tgt %d Page 0: NParms %x Information %x",
                    sc_link->target,
                    page0.NegotiatedParameters, page0.Information);
d285 4
a288 1
		/* if lowest 3 aren't set the PPR probably failed, retry with other parameters */
d295 2
a296 1
	if ((((page0.NegotiatedParameters >> 8) & 0xff) > 0x09) && (speed == U160)) {
d305 4
a308 4
	 * Bit 3 - PPR rejected: The IOC sets this bit if the device rejects a PPR message.
	 * Bit 2 - WDTR Rejected: The IOC sets this bit if the device rejects a WDTR message.
	 * Bit 1 - SDTR Rejected: The IOC sets this bit if the device rejects a SDTR message.
	 * Bit 0 - 1 A SCSI SDTR, WDTR, or PPR negotiation has occurred with this device.
d313 3
a315 2
			sc_link->target,
			(uint8_t)page0.Information);
d321 19
a339 19
		case 0x08:
			tp = 160;
			break;
			
		case 0x09:
			tp = 80;
			break;
			
		case 0x0a:
			tp = 40;
			break;
			
		case 0x0b:
			tp = 20;
			break;
			
		case 0x0c:
			tp = 10;
			break;
d341 2
a342 2
		default:
			tp = 0;
d346 9
a354 9
		"target %d %s at %dMHz width %dbit offset %d QAS %d DT %d IU %d",
		sc_link->target,
		tp ? "Synchronous" : "Asynchronous",
		tp,
		(page0.NegotiatedParameters & 0x20000000) ? 16 : 8,
		(page0.NegotiatedParameters >> 16) & 0xff,
		(page0.NegotiatedParameters & 0x04) ? 1 : 0,
		(page0.NegotiatedParameters & 0x02) ? 1 : 0,
		(page0.NegotiatedParameters & 0x01) ? 1 : 0);
d375 2
a376 1
			buswidth = ((struct scsi_link *)&mpt->sc_link)->adapter_buswidth;
d378 1
a378 1
				mpt, dev, buswidth); */
d381 2
a382 1
				sc_link = ((struct scsibus_softc *)dev)->sc_link[target][0];
d390 3
a392 2
					if (mpt_ppr(mpt, sc_link, U320, flags)) {
						mpt->mpt_negotiated_speed[target] = U320;
d396 3
a398 2
					if (mpt_ppr(mpt, sc_link, U160, flags)) {
						mpt->mpt_negotiated_speed[target] = U160;
d403 2
a404 1
						mpt->mpt_negotiated_speed[target] = U80;
a406 1

a419 2
	struct _CONFIG_PAGE_IOC_2 iocp2;
	int rv;
d447 9
a455 23
	/* Read IOC page 2 to figure out if we have IM */
	rv = mpt_read_cfg_header(mpt, MPI_CONFIG_PAGETYPE_IOC, 2,
	    0, &iocp2.Header);
	if (rv) {
		mpt_prt(mpt, "Could not retrieve IOC PAGE 2 to determine"
		    "RAID capabilities.");
	}
	else {
		mpt->im_support = iocp2.CapabilitiesFlags &
		    (MPI_IOCPAGE2_CAP_FLAGS_IS_SUPPORT |
		     MPI_IOCPAGE2_CAP_FLAGS_IME_SUPPORT |
		     MPI_IOCPAGE2_CAP_FLAGS_IM_SUPPORT);

		if (mpt->verbose > 1) {
			mpt_prt(mpt, "IOC Page 2: %x %x %x %x %x",
			    iocp2.CapabilitiesFlags,
			    iocp2.NumActiveVolumes,
			    iocp2.MaxVolumes,
			    iocp2.NumActivePhysDisks,
			    iocp2.MaxPhysDisks);
			mpt_prt(mpt, "IM support: %x", mpt->im_support);
		}
	}
d1626 68
@


1.17
log
@Add RAID volume page
Add more IOC pages
Some cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.16 2004/10/22 04:54:26 marco Exp $	*/
a121 3
#if NBIO > 0
int    mpt_ioctl(struct device *, u_long, caddr_t);
#endif
d191 1
a191 2
	page1.RequestedParameters &=
	    ~(MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK |
a194 1

d207 1
a207 1

d209 3
a211 3
		case U320:
			/* do nothing */
			break;
d213 6
a218 6
		case U160:
			factor = 0x09; /* force U160 */
			break;

		case U80:
			factor = 0x0a; /* force U80 */
d274 3
a276 3
		    "SPI Tgt %d Page 0: NParms %x Information %x",
		    sc_link->target,
		    page0.NegotiatedParameters, page0.Information);
d280 1
a280 4
		/*
		 * if lowest 3 aren't set the PPR probably failed,
		 * retry with other parameters
		 */
d287 1
a287 2
	if ((((page0.NegotiatedParameters >> 8) & 0xff) > 0x09) &&
	    (speed == U160)) {
d296 4
a299 4
	 * Bit 3 - PPR rejected:  IOC sets this if the device rejects PPR.
	 * Bit 2 - WDTR rejected: IOC sets this if the device rejects WDTR.
	 * Bit 1 - SDTR Rejected: IOC sets this if the device rejects SDTR.
	 * Bit 0 - 1 A SCSI SDTR, WDTR, or PPR negotiation has occurred.
d304 2
a305 3
		    sc_link->target,
		    (uint8_t)page0.Information);

d311 19
a329 3
	case 0x08:
		tp = 160;
		break;
d331 2
a332 18
	case 0x09:
		tp = 80;
		break;

	case 0x0a:
		tp = 40;
		break;

	case 0x0b:
		tp = 20;
		break;

	case 0x0c:
		tp = 10;
		break;

	default:
		tp = 0;
d336 9
a344 9
	    "target %d %s at %dMHz width %dbit offset %d QAS %d DT %d IU %d",
	    sc_link->target,
	    tp ? "Synchronous" : "Asynchronous",
	    tp,
	    (page0.NegotiatedParameters & 0x20000000) ? 16 : 8,
	    (page0.NegotiatedParameters >> 16) & 0xff,
	    (page0.NegotiatedParameters & 0x04) ? 1 : 0,
	    (page0.NegotiatedParameters & 0x02) ? 1 : 0,
	    (page0.NegotiatedParameters & 0x01) ? 1 : 0);
d365 1
a365 2
			buswidth = ((struct scsi_link *)&mpt->sc_link)->
			    adapter_buswidth;
d367 1
a367 1
			 *     mpt, dev, buswidth); */
d370 1
a370 2
				sc_link = ((struct scsibus_softc *)dev)->
				    sc_link[target][0];
d378 2
a379 3
					if (mpt_ppr(mpt, sc_link, U320, flags)){
						mpt->mpt_negotiated_speed
						    [target] = U320;
d383 2
a384 3
					if (mpt_ppr(mpt, sc_link, U160, flags)){
						mpt->mpt_negotiated_speed
						    [target] = U160;
d389 1
a389 2
						mpt->mpt_negotiated_speed
						    [target] = U80;
d392 1
d406 2
d435 23
a457 9
#if NBIO > 0
        if (bio_register(&mpt->mpt_dev, mpt_ioctl) != 0)
                panic("%s: controller registration failed",
                    mpt->mpt_dev.dv_xname);
#endif  

	mpt_prt(mpt, "IM support: %x", mpt->im_support);
	/*mpt_prt(mpt, "IM support: %x %x", mpt->im_support,
	    mpt->mpt_ioc_page2.CapabilitiesFlags);*/
a1627 68

#if NBIO > 0
int
mpt_ioctl(dev, cmd, addr)
        struct device *dev;
        u_long cmd;
        caddr_t addr;
{
	int error = 0;
	int rv;
	struct mpt_dummy *dummy;
	struct mpt_mfg0 *pmfg0;
	fCONFIG_PAGE_MANUFACTURING_0 mfgp0;
	mpt_softc_t *mpt = (mpt_softc_t *)dev;

	switch (cmd) {
		case MPT_IOCTL_DUMMY:
			dummy = (struct mpt_dummy *)addr;
			if (mpt->verbose > 2) {
				printf("%s: MPT_IOCTL_DUMMY %d\n",
				    dev->dv_xname, dummy->x++);
			}
			break;
		case MPT_IOCTL_MFG0:
			/* Retrieve Manufacturing Page 0 */
			mfgp0.Header.PageNumber = 0;
			mfgp0.Header.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
			rv = mpt_read_cfg_page(mpt, 0, &mfgp0.Header);
			if (rv) {
				mpt_prt(mpt, "Could not retrieve MFG PAGE 0.");
				error = EINVAL;
			}
			else {  
				if (mpt->verbose > 2) {
					printf("Chip name: %s\n",
					    mfgp0.ChipName);
					printf("Chip Revision: %s\n",
					    mfgp0.ChipRevision);
					printf("Board name: %s\n",
					    mfgp0.BoardName);
					printf("Board assembly: %s\n",
					    mfgp0.BoardAssembly);
					printf("Board tracer number: %s\n",
					    mfgp0.BoardTracerNumber);
				}
				pmfg0 = (struct mpt_mfg0 *)addr;
				memcpy(&pmfg0->cpm0, &mfgp0,
				    sizeof(fCONFIG_PAGE_MANUFACTURING_0));
			}
			break;
			/* Retrieve Manufacturing Page 1 */
		case MPT_IOCTL_MFG1:
			break;
			/* Retrieve Manufacturing Page 2 */
		case MPT_IOCTL_MFG2:
			break;
			/* Retrieve Manufacturing Page 3 */
		case MPT_IOCTL_MFG3:
			break;
			/* Retrieve Manufacturing Page 4 */
		case MPT_IOCTL_MFG4:
			break;
		default:
			error = EINVAL;
	}
	return (error);
}
#endif
@


1.16
log
@Add:
* bio ioctl interface
* retrieval of manufacturing pages
* retrieval of IOC pages
* IM detection during boot

This is the initial infrastructure to add IM/IME/IS support to the mpt driver.  This is not extremely useful yet. Userland tool to follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.15 2004/08/23 20:52:15 marco Exp $	*/
d194 2
a195 1
	page1.RequestedParameters &= ~(MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK |
d199 1
d212 1
a212 1
		
d214 7
a220 3
			case U320:
				/* do nothing */
				break;
d222 2
a223 6
			case U160:
				factor = 0x09; /* force U160 */
				break;
				
			case U80:
				factor = 0x0a; /* force U80 */
d279 3
a281 3
                    "SPI Tgt %d Page 0: NParms %x Information %x",
                    sc_link->target,
                    page0.NegotiatedParameters, page0.Information);
d285 4
a288 1
		/* if lowest 3 aren't set the PPR probably failed, retry with other parameters */
d295 2
a296 1
	if ((((page0.NegotiatedParameters >> 8) & 0xff) > 0x09) && (speed == U160)) {
d305 4
a308 4
	 * Bit 3 - PPR rejected: The IOC sets this bit if the device rejects a PPR message.
	 * Bit 2 - WDTR Rejected: The IOC sets this bit if the device rejects a WDTR message.
	 * Bit 1 - SDTR Rejected: The IOC sets this bit if the device rejects a SDTR message.
	 * Bit 0 - 1 A SCSI SDTR, WDTR, or PPR negotiation has occurred with this device.
d313 3
a315 2
			sc_link->target,
			(uint8_t)page0.Information);
d321 19
a339 19
		case 0x08:
			tp = 160;
			break;
			
		case 0x09:
			tp = 80;
			break;
			
		case 0x0a:
			tp = 40;
			break;
			
		case 0x0b:
			tp = 20;
			break;
			
		case 0x0c:
			tp = 10;
			break;
d341 2
a342 2
		default:
			tp = 0;
d346 9
a354 9
		"target %d %s at %dMHz width %dbit offset %d QAS %d DT %d IU %d",
		sc_link->target,
		tp ? "Synchronous" : "Asynchronous",
		tp,
		(page0.NegotiatedParameters & 0x20000000) ? 16 : 8,
		(page0.NegotiatedParameters >> 16) & 0xff,
		(page0.NegotiatedParameters & 0x04) ? 1 : 0,
		(page0.NegotiatedParameters & 0x02) ? 1 : 0,
		(page0.NegotiatedParameters & 0x01) ? 1 : 0);
d375 2
a376 1
			buswidth = ((struct scsi_link *)&mpt->sc_link)->adapter_buswidth;
d378 1
a378 1
				mpt, dev, buswidth); */
d381 2
a382 1
				sc_link = ((struct scsibus_softc *)dev)->sc_link[target][0];
d390 3
a392 2
					if (mpt_ppr(mpt, sc_link, U320, flags)) {
						mpt->mpt_negotiated_speed[target] = U320;
d396 3
a398 2
					if (mpt_ppr(mpt, sc_link, U160, flags)) {
						mpt->mpt_negotiated_speed[target] = U160;
d403 2
a404 1
						mpt->mpt_negotiated_speed[target] = U80;
a406 1

a452 5
	mpt->im_support = mpt->mpt_ioc_page2.CapabilitiesFlags &
	    (MPI_IOCPAGE2_CAP_FLAGS_IS_SUPPORT |
	     MPI_IOCPAGE2_CAP_FLAGS_IME_SUPPORT |
	     MPI_IOCPAGE2_CAP_FLAGS_IM_SUPPORT);

d454 2
d1649 1
a1650 1
		case MPT_IOCTL_MFG0:
@


1.15
log
@Fix license.  ok krw@@, deraadt@@ tedu@@ & Milos Urbanek <urbanek at zoom-int.cz>
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.14 2004/07/12 23:57:14 marco Exp $	*/
d122 3
a408 2
	struct _CONFIG_PAGE_IOC_2 iocp2;
	int rv;
d436 10
a445 12
	/* Read IOC page 2 to figure out if we have IM */
	rv = mpt_read_cfg_header(mpt, MPI_CONFIG_PAGETYPE_IOC, 2,
	    0, &iocp2.Header);
	if (rv) {
		mpt_prt(mpt, "Could not retrieve IOC PAGE 2 to determine"
		    "RAID capabilities.");
	}
	else {
		mpt->im_support = iocp2.CapabilitiesFlags &
		    (MPI_IOCPAGE2_CAP_FLAGS_IS_SUPPORT |
		     MPI_IOCPAGE2_CAP_FLAGS_IME_SUPPORT |
		     MPI_IOCPAGE2_CAP_FLAGS_IM_SUPPORT);
d447 1
a447 10
		if (mpt->verbose > 1) {
			mpt_prt(mpt, "IOC Page 2: %x %x %x %x %x",
			    iocp2.CapabilitiesFlags,
			    iocp2.NumActiveVolumes,
			    iocp2.MaxVolumes,
			    iocp2.NumActivePhysDisks,
			    iocp2.MaxPhysDisks);
			mpt_prt(mpt, "IM support: %x", mpt->im_support);
		}
	}
d1618 68
@


1.14
log
@Add detection of IM/IS/IME support in mpt_attach().  This is in preparation to add RAID support.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.13 2004/06/30 00:45:04 krw Exp $	*/
d17 11
a27 6
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
@


1.13
log
@Force SCSI_POLL for commands issued during probe. Fixes problem with mpt on
MP kernels which don't enable interrupts until after probe.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.12 2004/06/22 18:57:18 marco Exp $	*/
d401 2
d429 25
@


1.12
log
@Remove all static functions.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.11 2004/04/28 01:45:48 marco Exp $	*/
d104 2
a105 2
void	mpt_run_ppr(mpt_softc_t *);
int	mpt_ppr(mpt_softc_t *, struct scsi_link *, int speed);
d138 1
a138 1
mpt_ppr(mpt_softc_t *mpt, struct scsi_link *sc_link, int speed)
a141 1
        struct scsi_inquiry scsi_cmd;
d254 1
a254 11
	bzero(&scsi_cmd, sizeof scsi_cmd);
	scsi_cmd.opcode = INQUIRY;
	bzero(&inqbuf, sizeof inqbuf);
	/*
	 * Ask only for a minimal amount of data, since we only want to
	 * test data xfer not read all the INQUIRY data.
	 */
	scsi_cmd.length = SID_INQUIRY_HDR + SID_SCSI2_ALEN;
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
		sizeof(scsi_cmd), (u_char *)&inqbuf, scsi_cmd.length, 0, 10000, NULL,
		SCSI_DATA_IN);
d348 1
a348 1
mpt_run_ppr(mpt_softc_t *mpt)
d367 3
a369 3
				/* got a device! run PPR */
					/* FIXME: skip CPU devices since they can
					 * crash at U320 speeds */
d373 1
a373 1
					if (mpt_ppr(mpt, sc_link, U320)) {
d378 1
a378 1
					if (mpt_ppr(mpt, sc_link, U160)) {
d383 1
a383 1
					if (mpt_ppr(mpt, sc_link, U80)) {
d432 1
a432 1
		mpt_run_ppr(mpt);
@


1.11
log
@Removing some erroneous \n junk and a little KNF.  ok & tested krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.10 2004/04/25 03:55:25 krw Exp $	*/
d104 9
a112 9
static void	mpt_run_ppr(mpt_softc_t *);
static int	mpt_ppr(mpt_softc_t *, struct scsi_link *, int speed);
static int	mpt_poll(mpt_softc_t *, struct scsi_xfer *, int);
static void	mpt_timeout(void *);
static void	mpt_done(mpt_softc_t *, uint32_t);
static int	mpt_run_xfer(mpt_softc_t *, struct scsi_xfer *);
static void	mpt_check_xfer_settings(mpt_softc_t *, struct scsi_xfer *, MSG_SCSI_IO_REQUEST *);
static void	mpt_ctlop(mpt_softc_t *, void *vmsg, uint32_t);
static void	mpt_event_notify_reply(mpt_softc_t *, MSG_EVENT_NOTIFY_REPLY *);
d114 2
a115 2
static int	mpt_action(struct scsi_xfer *);
static void	mpt_minphys(struct buf *);
d661 1
a661 1
static int
d677 1
a677 1
static void
d724 1
a724 1
static void
d994 1
a994 1
static int
d1255 1
a1255 1
static void
d1302 1
a1302 1
static void
d1505 1
a1505 1
static int
d1530 1
a1530 1
static void
d1559 1
a1559 1
	mpt_prt(mpt, "unable to allocate fw memory, error = %d", error);
d1581 1
a1581 1
	mpt_prt(mpt, "unable to load request DMA map, error = %d", error);
@


1.11.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.10
log
@Make it clear that we will give each target an openings value equal to
the number of available requests divided by the maximum number of
targets on the bus.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.9 2004/04/12 13:24:27 marco Exp $	*/
d267 1
a267 1
		mpt_prt(mpt, "Invalid INQUIRY on target: %d\n", sc_link->target);
d367 2
a368 1
	for (dev = TAILQ_FIRST(&alldevs); dev != NULL; dev = TAILQ_NEXT(dev, dv_list)) {
d515 2
a516 2
		printf("%s: unable to allocate request area, "
		    "error = %d\n", mpt->mpt_dev.dv_xname, error);
d531 2
a532 2
		printf("%s: unable to create request DMA map, "
		    "error = %d\n", mpt->mpt_dev.dv_xname, error);
d566 2
a567 2
			printf("%s: unable to create req %d DMA map, "
			    "error = %d\n", mpt->mpt_dev.dv_xname, i, error);
d687 1
a687 1
	mpt_prt(mpt, "command timeout\n");
d920 1
a920 1
			printf("invalid status code %d\n", xs->status);
d1559 1
a1559 1
	mpt_prt(mpt, "unable to allocate fw memory, error = %d\n", error);
d1566 1
a1566 1
		mpt_prt(mpt, "unable to map fw area, error = %d\n", error);
d1573 1
a1573 1
		mpt_prt(mpt, "unable to create request DMA map, error = %d\n",
d1581 1
a1581 1
	mpt_prt(mpt, "unable to load request DMA map, error = %d\n", error);
@


1.9
log
@Fix DMA length on complex SGL.  Apparantly this fixes the outstanding 1.03.xx mpt firmware issue.  From NetBSD pointed out by deraadt@@.  ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.8 2004/04/11 12:56:05 marco Exp $	*/
a427 1
		lptr->openings = 4; /* 1024 requests / 256 targets = 4 each */
a430 1
		lptr->openings = 16; /* 1024 requests / 16 targets = 16 each */
d432 1
@


1.8
log
@Use INQUIRY instead of TUR for PPR.  By doing this the target device actually transfers data at the requested speed; in essence this is a poor-mans domain validation.  Also some SCSI device are horribly out of spec and they won't respond correctly to TUR.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.7 2004/03/19 02:47:36 krw Exp $	*/
d1141 2
d1146 2
a1148 1
				ce->Length = ntodo * sizeof(SGE_SIMPLE32);
@


1.7
log
@Tweak isr to speed it up, panic in correct spot, prepare for more firmware
handling and error handling.

From Marco Peereboom, with suggestions from LSI.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.6 2004/03/17 00:47:06 krw Exp $	*/
d142 1
d144 2
d250 20
a269 5
	/* use TUR for PPR, use another command if there is a NO_TUR quirk */
	/* FIXME */
	scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
		scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST |
		SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);
d378 2
@


1.6
log
@Reduce openings to avoid both usual 'EIO' problems in interrupt mode
and apparently some mpt specific problems. With this change installs
to my U320 disk work, and work *fast*.

Try to return XS_TIMEOUT for timeouts rather than XS_NOERROR.

Load on-board firmware. Currently v1.01.61 seems to work well, but
the latest 1.03.23 does not.

With these changes Marco and Milos torture chambers now report no
problems and we should be set for 3.5.

Mostly from Milos Urbanek and Marco Peereboom.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.5 2004/03/15 09:53:33 deraadt Exp $	*/
d592 1
d595 8
d605 7
@


1.5
log
@DO NOT UNDO MY COMMITS
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.4 2004/03/14 23:14:36 krw Exp $	*/
a390 1
	int maxq;
a393 3
	maxq = (mpt->mpt_global_credits < MPT_MAX_REQUESTS(mpt)) ?
	    mpt->mpt_global_credits : MPT_MAX_REQUESTS(mpt);

a401 1
	lptr->openings = maxq;
d408 1
d412 1
d678 2
a679 1
		if (req == &mpt->request_pool[index])
d681 1
d811 6
a816 1
	if (mpt_reply == NULL) {
d833 1
a833 4
		mpt_free_request(mpt, req);
		xs->flags |= ITSDONE;
		scsi_done(xs);
		return;
d1504 63
@


1.4
log
@Add first cut at PPR negotiation. From Marco Peereboom.

Call mpt_done() instead of scsi_done() when the command times out.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.3 2004/03/10 01:09:29 deraadt Exp $	*/
a102 2

#include <machine/stdarg.h>		/* for mpt_prt() */
@


1.3
log
@no need for re-including machine/stdarg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.2 2004/03/07 05:08:16 krw Exp $	*/
d104 4
a112 4
static void	mpt_set_xfer_mode(mpt_softc_t *, struct scsi_xfer *);
#if 0
static void	mpt_get_xfer_mode(mpt_softc_t *, struct scsipi_periph *);
#endif
d132 254
d424 6
d654 1
a654 1
	int s;
d682 5
a686 8
	/* XXX WHAT IF THE IOC IS STILL USING IT?? */
	/* XXX MU we should delay the call to mpt_free_request */
	req->xfer = NULL;
	mpt_free_request(mpt, req);

	xs->error = XS_TIMEOUT;
	xs->flags |= ITSDONE;
	scsi_done(xs);
d904 3
d908 3
d912 4
d917 1
a917 1
		/* XXX When in doubt, STUFFUP. */
a1013 3
	if (cold && !(xs->sc_link->quirks & SDEV_NOWIDE))
		mpt_set_xfer_mode(mpt, xs);

a1216 135
void
mpt_set_xfer_mode(mpt_softc_t *mpt, struct scsi_xfer *xs)
{
	fCONFIG_PAGE_SCSI_DEVICE_1 tmp;

	if (mpt->is_fc) {
		/*
		 * SCSI transport settings don't make any sense for
		 * Fibre Channel; silently ignore the request.
		 */
		return;
	}

	/*
	 * Always allow disconnect; we don't have a way to disable
	 * it right now, in any case.
	 */
	mpt->mpt_disc_enable |= (1 << xs->sc_link->target);

	if (xs->sc_link->quirks & SDEV_NOTAGS)
		mpt->mpt_tag_enable &= ~(1 << xs->sc_link->target);
	else
		mpt->mpt_tag_enable |= (1 << xs->sc_link->target);

	tmp = mpt->mpt_dev_page1[xs->sc_link->target];

	/*
	 * Set the wide/narrow parameter for the target.
	 */
	if (xs->sc_link->quirks & SDEV_NOWIDE)
		tmp.RequestedParameters &= ~MPI_SCSIDEVPAGE1_RP_WIDE;
	else {
		tmp.RequestedParameters |= MPI_SCSIDEVPAGE1_RP_WIDE;
	}
	/*
	 * Set the synchronous parameters for the target.
	 *
	 * XXX If we request sync transfers, we just go ahead and
	 * XXX request the maximum available.  We need finer control
	 * XXX in order to implement Domain Validation.
	 */
	tmp.RequestedParameters &= ~(MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK |
	    MPI_SCSIDEVPAGE1_RP_MAX_SYNC_OFFSET_MASK |
	    MPI_SCSIDEVPAGE1_RP_DT | MPI_SCSIDEVPAGE1_RP_QAS |
	    MPI_SCSIDEVPAGE1_RP_IU);
	if (!(xs->sc_link->quirks & SDEV_NOSYNC)) {
		int factor, offset, np;

		factor = (mpt->mpt_port_page0.Capabilities >> 8) & 0xff;
		offset = (mpt->mpt_port_page0.Capabilities >> 16) & 0xff;
		np = 0;
		if (factor < 0x9) {
			/* Ultra320 */
			np |= MPI_SCSIDEVPAGE1_RP_QAS | MPI_SCSIDEVPAGE1_RP_IU;
		}
		if (factor < 0xa) {
			/* at least Ultra160 */
			np |= MPI_SCSIDEVPAGE1_RP_DT;
		}
		np |= (factor << 8) | (offset << 16);
		tmp.RequestedParameters |= np;
	}

	if (mpt_write_cfg_page(mpt, xs->sc_link->target, &tmp.Header)) {
		mpt_prt(mpt, "unable to write Device Page 1");
		return;
	}

	if (mpt_read_cfg_page(mpt, xs->sc_link->target, &tmp.Header)) {
		mpt_prt(mpt, "unable to read back Device Page 1");
		return;
	}

	mpt->mpt_dev_page1[xs->sc_link->target] = tmp;
	if (mpt->verbose > 1) {
		mpt_prt(mpt,
		    "SPI Target %d Page 1: RequestedParameters %x Config %x",
		    xs->sc_link->target,
		    mpt->mpt_dev_page1[xs->sc_link->target].RequestedParameters,
		    mpt->mpt_dev_page1[xs->sc_link->target].Configuration);
	}

	return;
}
#if 0
static void
mpt_get_xfer_mode(mpt_softc_t *mpt, struct scsipi_periph *periph)
{
	fCONFIG_PAGE_SCSI_DEVICE_0 tmp;
	struct scsipi_xfer_mode xm;
	int period, offset;

	tmp = mpt->mpt_dev_page0[periph->periph_target];
	if (mpt_read_cfg_page(mpt, periph->periph_target, &tmp.Header)) {
		mpt_prt(mpt, "unable to read Device Page 0");
		return;
	}

	if (mpt->verbose > 1) {
		mpt_prt(mpt,
		    "SPI Tgt %d Page 0: NParms %x Information %x",
		    periph->periph_target,
		    tmp.NegotiatedParameters, tmp.Information);
	}

	xm.xm_target = periph->periph_target;
	xm.xm_mode = 0;

	if (tmp.NegotiatedParameters & MPI_SCSIDEVPAGE0_NP_WIDE)
		xm.xm_mode |= PERIPH_CAP_WIDE16;

	period = (tmp.NegotiatedParameters >> 8) & 0xff;
	offset = (tmp.NegotiatedParameters >> 16) & 0xff;
	if (offset) {
		xm.xm_period = period;
		xm.xm_offset = offset;
		xm.xm_mode |= PERIPH_CAP_SYNC;
	}

	/*
	 * Tagged queueing is all controlled by us; there is no
	 * other setting to query.
	 */
	if (mpt->mpt_tag_enable & (1 << periph->periph_target))
		xm.xm_mode |= PERIPH_CAP_TQING;

	/*
	 * We're going to deliver the async event, so clear the marker.
	 */
	mpt->mpt_report_xfer_mode &= ~(1 << periph->periph_target);

	scsipi_async_event(&mpt->sc_channel, ASYNC_EVENT_XFER_MODE, &xm);
}
#endif /* scsipi_xfer_mode */

d1436 1
a1436 1
#if 0
d1445 1
a1445 1
#endif
@


1.2
log
@Eliminate bit fields and unused fields in mpt_softc.

Return XS_DRIVER_STUFFUP for all status values we aren't sure of.

Mostly from Milos Urbanek.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpt_openbsd.c,v 1.1 2004/03/06 03:03:07 krw Exp $	*/
a102 2

#include <machine/stdarg.h>		/* for mpt_prt() */
@


1.1
log
@Initial version of driver for LSI MPT devices, like the U320 1030.
Basically works but much still to fix/implement.

From NetBSD via Milos Urbanek and Marco Peereboom.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a648 3
		xs->error = XS_DRIVER_STUFFUP;
		break;

a649 3
		/* XXX What should we do here? */
		break;

a650 4
		/* XXX */
		xs->error = XS_DRIVER_STUFFUP;
		break;

d652 1
a652 1
		/* XXX */
@

