head	1.10;
access;
symbols
	OPENBSD_4_5:1.9.0.22
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.20
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.18
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.16
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.22
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.20
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.18
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.16
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.8.0.14
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.12
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.10
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.10
date	2009.04.15.06.54.44;	author oga;	state dead;
branches;
next	1.9;

1.9
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	99.06.06.15.39.16;	author deraadt;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	97.03.20.22.03.04;	author chuck;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.22.46.25;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.12.20.30.21;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.16.22.08.16;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	96.07.03.17.21.17;	author chuck;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.04.07.02;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	96.06.21.15.27.20;	author chuck;	state Exp;
branches;
next	;

1.8.4.1
date	2004.02.19.10.56.19;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove en(4) (no manpage present, no none removed), and the midway.c glue code
for it.

It is very unlikely this still compiles, the hardware is dead. It isn't in any
arch's config file. the sparc sbus code is even commented out in files.sparc.

Not to mention that the code is fucking appauling, doesn't even know that sparc
got bus.h ages ago, still uses vtophys(), defines all types of functions to
arch-specific hacks.

I will miss the bitchy comments, though...

As a note to other drivers: this is the fate that awaits you if you screw up my
ctags on commonly used functions.

"you have my ok" claudio@@, "zap zap zap" deraadt@@

If i've missed any bits, please remove them.
@
text
@/*	$OpenBSD: midwayreg.h,v 1.9 2003/10/21 18:58:49 jmc Exp $	*/

/*
 * m i d w a y r e g . h
 *
 * this file contains the description of the ENI ATM midway chip
 * data structures.   see midway.c for more details.
 *
 */

#if defined(__sparc__) || defined(__FreeBSD__)
/* XXX: gross.   netbsd/sparc doesn't have machine/bus.h yet. */
typedef void * bus_space_tag_t;
typedef u_int32_t pci_chipset_tag_t;
typedef caddr_t bus_space_handle_t;
typedef u_int32_t bus_size_t;
typedef caddr_t bus_addr_t;

#define bus_space_read_4(t, h, o) ((void) t,                            \
    (*(volatile u_int32_t *)((h) + (o))))
#define bus_space_write_4(t, h, o, v)                                   \
    ((void) t, ((void)(*(volatile u_int32_t *)((h) + (o)) = (v))))

#if defined(__sparc__)
#define vtophys(x) ((u_int32_t)(x))	/* sun4c dvma */
#endif

#endif


#define MID_SZTOB(X) 	((X) * 256 * 4) /* size to bytes */
#define MID_BTOSZ(X)	((X) / 256 / 4)	/* bytes to "size" */

#define MID_N_VC	1024		/* # of VCs we can use */
#define MID_NTX_CH	8		/* 8 transmit channels (shared) */
#define MID_ATMDATASZ	48		/* need data in 48 byte blocks */

/*
 * card data structures, top down
 *
 * in order to have a portable driver, the netbsd guys will not let us
 * use structs.   we have a bus_space_handle_t which is the en_base address.
 * everything else is an offset from that base.   all card data must be 
 * accessed with bus_space_read_4()/bus_space_write_4():
 *
 * rv = bus_space_read_4(sc->en_memt, sc->en_base, BYTE_OFFSET);
 * bus_space_write_4(sc->en_memt, sc->en_base, BYTE_OFFSET, VALUE);
 *
 * en_card: the whole card (prom + phy + midway + obmem)
 * 	obmem contains: vci tab + dma queues (rx & tx) + service list + bufs
 */

/* byte offsets from en_base of various items */
#define MID_PHYOFF	0x030000	/* PHY offset */
#define MID_MIDOFF	0x040000	/* midway regs offset */
#define MID_RAMOFF	0x200000	/* RAM offset */
#define MID_DRQOFF	0x204000	/* DRQ offset */
#define MID_DRQEND	MID_DTQOFF	/* DRQ end */
#define MID_DTQOFF	0x205000	/* DTQ offset */
#define MID_DTQEND	MID_SLOFF	/* DTQ end */
#define MID_SLOFF	0x206000	/* service list */
#define MID_SLEND	MID_BUFOFF	/* service list end */
#define MID_BUFOFF	0x207000	/* buffer area */
#define MID_PROBEOFF	0x21fffc	/* start probe here */
#define MID_PROBSIZE	0x020000	/* 128 KB */
#define MID_MAXOFF	0x3ffffc	/* max offset */

/*
 * prom & phy: not defined here
 */

/*
 * midway regs  (byte offsets from en_base)
 */

#define MID_RESID	0x40000		/* write=reset reg, read=ID reg */

#define MID_VER(X)	(((X) & 0xf0000000) >> 28) /* midway version # */
#define MID_MID(X)	(((X) & 0x700) >> 8) 	/* motherboard ID */
#define MID_IS_SABRE(X) ((X) & 0x80)		/* sabre controller? */
#define MID_IS_SUNI(X)	((X) & 0x40)		/* SUNI? vs utopia */
#define MID_IS_UPIPE(X)	((X) & 0x20)		/* utopia pipeline? */
#define MID_DID(X)	((X) & 0x1f)		/* daughterboard ID */

#define MID_INTACK	0x40004		/* interrupt ACK */
#define MID_INTSTAT	0x40008		/* interrupt status */
#define MID_INTENA	0x4000c		/* interrupt enable */

#define MID_TXCHAN(N) (1 << ((N) + 9))	/* ack/status/enable xmit channel bit*/
#define MID_INT_TX	0x1fe00		/* mask for any xmit interrupt */
#define MID_INT_DMA_OVR 0x00100		/* DMA overflow interrupt */
#define MID_INT_IDENT   0x00080		/* ident match error interrupt */
#define MID_INT_LERR    0x00040		/* LERR interrupt (sbus?) */
#define MID_INT_DMA_ERR 0x00020		/* DMA error interrupt */
#define MID_INT_DMA_RX  0x00010		/* DMA recv interrupt */
#define MID_INT_DMA_TX	0x00008		/* DMA xmit interrupt */
#define MID_INT_SERVICE 0x00004		/* service list interrupt */
#define MID_INT_SUNI	0x00002		/* SUNI interrupt */
#define MID_INT_STATS	0x00001		/* stats overflow interrupt */

#define MID_INT_ANY	0x1ffff		/* any interrupt? */

#define MID_INTBITS "\20\21T7\20T6\17T5\16T4\15T3\14T2\13T1\12T0\11DMAOVR\10ID\7LERR\6DMAERR\5RXDMA\4TXDMA\3SERV\2SUNI\1STAT"

#define MID_MAST_CSR	0x40010		/* master CSR */

#define MID_IPL(X)	(((X) & 0x1c0) >> 6) /* IPL */
#define MID_SETIPL(I)	((I) << 6)
#define MID_MCSR_TXLOCK	0x20		/* lock on xmit overflow mode */
/* NOTE: next 5 bits: write 1 means enable, write 0 means no change */
#define MID_MCSR_ENDMA	0x10		/* DMA enable */
#define MID_MCSR_ENTX	0x08		/* TX enable */
#define MID_MCSR_ENRX	0x04		/* RX enable */
#define MID_MCSR_W1MS	0x02		/* wait 1 msec */
#define MID_MCSR_W500US	0x01		/* wait 500 usec */

#define MID_MCSRBITS "\20\6LCK\5DMAON\4TXON\3RXON\2W1MS\1W500US"

#define MID_STAT	0x40014		/* stat register, clear on read */

#define MID_VTRASH(X) (((X) >> 16) & 0xffff)
					/* # cells trashed due to VCI's mode */
#define MID_OTRASH(X) ((X) & 0xffff)	/* # cells trashed due to overflow */

#define MID_SERV_WRITE	0x40018		/* 10 bit service write pointer (r/o) */
#define MID_DMA_ADDR	0x4001c		/* VA of DMA (r/o) */

  /* DMA queue pointers (bits 0 to 8) */
#define MID_DMA_WRRX	0x40020		/* write ptr. for DMA recv queue */
					/* (for adaptor -> host xfers) */
#define MID_DMA_RDRX	0x40024		/* read ptr for DMA recv queue (r/o) */
					/* (i.e. current adaptor->host xfer) */
#define MID_DMA_WRTX	0x40028		/* write ptr for DMA xmit queue */
					/* (for host -> adaptor xfers) */
#define MID_DMA_RDTX	0x4002c		/* read ptr for DMA xmit queue (r/o) */
					/* (i.e. current host->adaptor xfer) */

	/* xmit channel regs (1 per channel, MID_NTX_CH max channels) */

#define MIDX_PLACE(N)	(0x40040+((N)*0x10))	/* xmit place */

#define MIDX_MKPLACE(SZ,LOC) ( ((SZ) << 11) | (LOC) )
#define MIDX_LOC(X)	((X) & 0x7ff)	/* location in obmem */
#define MIDX_SZ(X)	((X) >> 11)	/* (size of block / 256) in int32_t's*/
#define MIDX_BASE(X)	\
	(((MIDX_LOC(X) << MIDV_LOCTOPSHFT) * sizeof(u_int32_t)) + MID_RAMOFF)

  /* the following two regs are word offsets in the block */
#define MIDX_READPTR(N)	(0x40044+((N)*0x10))	/* xmit read pointer (r/o) */
#define MIDX_DESCSTART(N) (0x40048+((N)*0x10))	/* seg currently in DMA (r/o) */


/*
 * obmem items
 */

/* 
 * vci table in obmem (offset from MID_VCTOFF)
 */

#define MID_VC(N)	(MID_RAMOFF+((N)*0x10))

#define MIDV_TRASH	0x00000000	/* ignore VC */
#define MIDV_AAL5	0x80000000	/* do AAL5 on it */
#define MIDV_NOAAL	0x40000000	/* do per-cell stuff on it */
#define MIDV_MASK	0xc0000000	/* mode mask */
#define MIDV_SETMODE(VC,M) (((VC) & ~(MIDV_MASK)) | (M))  /* new mode */
#define MIDV_PTI	0x20000000	/* save PTI cells? */
#define MIDV_LOCTOPSHFT	8		/* shift to get top 11 bits of 19 */
#define MIDV_LOCSHIFT	18
#define MIDV_LOCMASK	0x7ff
#define MIDV_LOC(X)	(((X) >> MIDV_LOCSHIFT) & MIDV_LOCMASK) 
					/* 11 most sig bits of addr */
#define MIDV_SZSHIFT	15
#define MIDV_SZ(X)	(((X) >> MIDV_SZSHIFT) & 7) 
					/* size encoded the usual way */
#define MIDV_INSERVICE	0x1		/* in service list */

#define MID_DST_RP(N)	(MID_VC(N)|0x4)

#define MIDV_DSTART_SHIFT	16		/* shift */
#define MIDV_DSTART(X) (((X) >> MIDV_DSTART_SHIFT) & 0x7fff)
#define MIDV_READP_MASK		0x7fff		/* valid bits, (shift = 0) */

#define MID_WP_ST_CNT(N) (MID_VC(N)|0x8)      /* write pointer/state/count */

#define MIDV_WRITEP_MASK	0x7fff0000	/* mask for write ptr. */
#define MIDV_WRITEP_SHIFT	16
#define MIDV_ST_IDLE		0x0000
#define MIDV_ST_TRASH		0xc000
#define MIDV_ST_REASS		0x4000
#define MIDV_CCOUNT		0x7ff		/* cell count */

#define MID_CRC(N)	(MID_VC(N)|0xc)		/* CRC */

/*
 * dma recv q.
 */

#define MID_DMA_END	(1 << 5)	/* for both tx and rx */
#define MID_DMA_CNT(X)	(((X) >> 16) & 0xffff)
#define MID_DMA_TXCHAN(X) (((X) >> 6) & 0x7)
#define MID_DMA_RXVCI(X)  (((X) >> 6) & 0x3ff)
#define MID_DMA_TYPE(X)	((X) & 0xf)

#define MID_DRQ_N	512			/* # of descriptors */
#define MID_DRQ_A2REG(N)	(((N) - MID_DRQOFF) >> 3)
				/* convert byte offset to reg value */
#define MID_DRQ_REG2A(N)	(((N) << 3) + MID_DRQOFF) /* and back */

/* note: format of word 1 of RXQ is different between ENI and ADP cards */
#define MID_MK_RXQ_ENI(CNT,VC,END,TYPE) \
	( ((CNT) << 16)|((VC) << 6)|(END)|(TYPE) )

#define MID_MK_RXQ_ADP(CNT,VC,END,JK) \
	( ((CNT) << 12)|((VC) << 2)|((END) >> 4)|(((JK) != 0) ? 1 : 0))
/*
 * dma xmit q.
 */

#define MID_DTQ_N	512			/* # of descriptors */
#define MID_DTQ_A2REG(N)	(((N) - MID_DTQOFF) >> 3)
				/* convert byte offset to reg value */
#define MID_DTQ_REG2A(N)	(((N) << 3) + MID_DTQOFF) /* and back */


/* note: format of word 1 of TXQ is different between ENI and ADP cards */
#define MID_MK_TXQ_ENI(CNT,CHN,END,TYPE) \
	( ((CNT) << 16)|((CHN) << 6)|(END)|(TYPE) )

#define MID_MK_TXQ_ADP(CNT,CHN,END,JK) \
	( ((CNT) << 12)|((CHN) << 2)|((END) >> 4)|(((JK) != 0) ? 1 : 0) )

/*
 * dma types
 */

#define MIDDMA_JK	0x3	/* just kidding */
#define MIDDMA_BYTE	0x1	/* byte */
#define MIDDMA_2BYTE	0x2	/* 2 bytes */
#define MIDDMA_WORD	0x0	/* word */
#define MIDDMA_2WORD	0x7	/* 2 words */
#define MIDDMA_4WORD	0x4	/* 4 words */
#define MIDDMA_8WORD	0x5	/* 8 words */
#define MIDDMA_16WORD	0x6	/* 16 words!!! */
#define MIDDMA_2WMAYBE	0xf	/* 2 words, maybe */
#define MIDDMA_4WMAYBE	0xc	/* 4 words, maybe */
#define MIDDMA_8WMAYBE	0xd	/* 8 words, maybe */
#define MIDDMA_16WMAYBE	0xe	/* 16 words, maybe */

#define MIDDMA_MAYBE	0xc	/* mask to detect WMAYBE dma code */
#define MIDDMA_MAXBURST	(16 * sizeof(u_int32_t))	/* largest burst */

/*
 * service list
 */

#define MID_SL_N	1024	/* max # entries on slist */
#define MID_SL_A2REG(N)	(((N) - MID_SLOFF) >> 2)
				/* convert byte offset to reg value */
#define MID_SL_REG2A(N)	(((N) << 2) + MID_SLOFF) /* and back */

/*
 * data in the buffer area of obmem
 */

/*
 * recv buffer desc. (1 u_int32_t at start of buffer)
 */

#define MID_RBD_SIZE	4			/* RBD size */
#define MID_CHDR_SIZE	4			/* on aal0, cell header size */
#define MID_RBD_ID(X)	((X) & 0xfe000000)	/* get ID */
#define MID_RBD_STDID	0x36000000		/* standard ID */
#define MID_RBD_CLP	0x01000000		/* CLP: cell loss priority */
#define MID_RBD_CE	0x00010000		/* CE: congestion experienced */
#define MID_RBD_T	0x00001000		/* T: trashed due to overflow */
#define MID_RBD_CRCERR	0x00000800		/* CRC error */
#define MID_RBD_CNT(X)	((X) & 0x7ff)		/* cell count */

/*
 * xmit buffer desc. (2 u_int32_t's at start of buffer)
 * (note we treat the PR & RATE as a single u_int8_t)
 */

#define MID_TBD_SIZE	8
#define MID_TBD_MK1(AAL,PR_RATE,CNT) \
	(MID_TBD_STDID|(AAL)|((PR_RATE) << 19)|(CNT))
#define MID_TBD_STDID	0xb0000000	/* standard ID */
#define MID_TBD_AAL5 	0x08000000	/* AAL 5 */
#define MID_TBD_NOAAL5	0x00000000	/* not AAL 5 */

#define MID_TBD_MK2(VCI,PTI,CLP) \
	(((VCI) << 4)|((PTI) << 1)|(CLP))

/*
 * aal5 pdu tail, last 2 words of last cell of AAL5 frame
 * (word 2 is CRC .. handled by hw)
 */

#define MID_PDU_SIZE	8
#define MID_PDU_MK1(UU,CPI,LEN) \
	(((UU) << 24)|((CPI) << 16)|(LEN))
#define MID_PDU_LEN(X) ((X) & 0xffff)
@


1.9
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayreg.h,v 1.8 1999/06/06 15:39:16 deraadt Exp $	*/
@


1.8
log
@use __sparc__
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayreg.h,v 1.7 1997/03/20 22:03:04 chuck Exp $	*/
d211 1
a211 1
/* note: format of word 1 of RXQ is different beween ENI and ADP cards */
d227 1
a227 1
/* note: format of word 1 of TXQ is different beween ENI and ADP cards */
@


1.8.4.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d211 1
a211 1
/* note: format of word 1 of RXQ is different between ENI and ADP cards */
d227 1
a227 1
/* note: format of word 1 of TXQ is different between ENI and ADP cards */
@


1.7
log
@MAJOR CHANGES: [contributed by Chuck Cranor <chuck@@ccrc.wustl.edu> and
                Anne Hutton <hutton@@isi.edu>]:
   - add support for Adaptec 155 PCI ATM cards (e.g. ANA-5940)
          - add sc->is_adaptec to handle differences between cards.
          - break out MID_MK_TXQ/MID_MK_RXQ seperate macros to handle
                  the new Adaptec format TXQ/RXQ.
          - adjust en_dqneed to return 1 on ADP (since the Adaptec can
                  DMA anything in one DRQ/DTQ!)
          - add hook for a bus specific reset function (adaptec has
                  a seperate reset register that needs to be hit when
                  resettting the midway).
          - adjust DMA test to not worry about burst sizes on the
                  adaptec (since it handles it all for us!) and to handle
                  the new DTQ/DRQ format.
          - add Adaptec DMA support to en_txlaunch() and en_service()


BUG FIXES:
   - fixed receiver panic under heavy load ("lost mbuf in slot 0!").
          when the reassembly buffer overflows, the T-bit is set in
          the RDB and the data field is empty.  en_service() sets up
          a 4-byte (RDB size) dummy DMA without IF_ENQUEUE.  but the
          recv intr handling in en_intr() always does IF_DEQUEUE.
          as a result, a successive recv intr loses its mbuf and
          leads to a panic.  the solution is to only IF_DEQUEUE if
          the interrupt has non-zero length (indicating that there
          is an mbuf to get).   in order for this to work, EN_DQ_MK
          must always be non-zero.   we do this by or'ing in an unused
          bit (0x80000).
                  reported by: Kenjiro Cho <kjc@@csl.sony.co.jp>

   - fix setting of transmit channel when txspeed[] is non-zero
          (e.g. traffic shaping).    the old scheme didn't work
          properly (it allowed the same VCI to use multiple tx channels
          thus defeating the txspeed[] parameter).   the new scheme
          statically assigns a VC to a channel when txspeed[] is set.
          [note that the code to set txspeed[] isn't in the driver right
          now since a MI interface to do this hasn't been made yet]
          we add sc->txvc2slot[] and sc->txslot[n].nref for this.
                  reported by: Kenjiro Cho <kjc@@csl.sony.co.jp>,
                                  Milind M Buddihikot <milind@@ccrc.wustl.edu>,
                                  Dong Lin <dong@@eecs.harvard.edu>

    - if aal5 frame has a CRC error then the length field in the aal5 trailer
          may not be valid, so we can not use it [and we must dump the frame]
                  contributed by: Yuhang Sun <sunyh@@dworkin.wustl.edu> & chuck

   - when doing SRAM copies, be sure to round up the length to the next
          largest word (otherwise the driver will try to do a byte clean
          up DMA and then get an ID error interrupt).


MINOR CLEANUPS:
   - add some extra support for a few more versions of FreeBSD
                  contributed by: Kenjiro Cho <kjc@@csl.sony.co.jp>

   - clean up loops in DMA test
                  contributed by: Kenjiro Cho <kjc@@csl.sony.co.jp>

   - restructure and cleanup of en_read/en_write macros/inlines

   - clean up some byte ordering stuff so that we are consistant throughout
          the driver
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayreg.h,v 1.6 1997/03/20 21:34:47 chuck Exp $	*/
d11 1
a11 1
#if defined(sparc) || defined(__FreeBSD__)
d24 1
a24 1
#if defined(sparc)
@


1.6
log
@Arrival of new bus.h from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayreg.h,v 1.5 1996/11/12 20:30:21 niklas Exp $	*/
d13 1
a13 1
typedef void * bus_chipset_tag_t;
d15 7
a21 6
typedef caddr_t bus_mem_handle_t;
typedef u_int32_t bus_mem_size_t;
typedef caddr_t bus_mem_addr_t;

#define bus_mem_read_4(t, h, o) ((void) t, (*(volatile u_int32_t *)((h) + (o))))
#define bus_mem_write_4(t, h, o, v)                                     \
d42 1
a42 1
 * use structs.   we have a bus_mem_handle_t which is the en_base address.
d44 1
a44 1
 * accessed with bus_mem_read_4()/bus_mem_write_4():
d46 2
a47 2
 * rv = bus_mem_read_4(sc->en_bc, sc->en_base, BYTE_OFFSET);
 * bus_mem_write_4(sc->en_bc, sc->en_base, BYTE_OFFSET, VALUE);
d211 2
a212 1
#define MID_MK_RXQ(CNT,VC,END,TYPE) \
d215 2
d227 2
a228 1
#define MID_MK_TXQ(CNT,CHN,END,TYPE) \
d230 3
@


1.5
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayreg.h,v 1.4 1996/07/16 22:08:16 chuck Exp $	*/
d12 1
a12 1
/* XXX: gross.   netbsd/sparc doesn't have machine/bus.old.h yet. */
@


1.4
log
@midway fixes + new stuff:
 - alpha changes from cgd

 - merged multiple DRQ/DTQ ADD macros into a single DRQ and a single DTQ
   macro with a uniform interface to make the code simpler and easier to read.

 - en_start: only update atm_flags if EN_MBUF_OPT is enabled (which it
	should be)

 - for alburst: make sure we don't DMA more bytes than we need (on both
	tx and rx).   if the alburst is larger than we need, drop to
	MIDDMA_WORD mode.

 - major change: enable the use of byte and 2 byte DMA on the trasmit side.
   this allows us to DMA from non-word sized/aligned mbufs directly.
   [the old code would always call en_mfix which would copy (or move) the
    data in order to ensure proper alignment...   it turns out TCP gives
    us non-word sized/aligned mbufs when it is retransmitting, so we needed
    to handle this case more efficiently.]    the following functions
   were changed to make this work:
    - en_dqneed: add an arg to let us know if we are transmitting or not.
	if we are TX, then we must take into account byte DMAs when
	estimating the number of DTQs we will need for a buffer
    - en_start: only mfix mbufs if DMA is disabled
    - en_txdma: only set launch.nodma if we have en_mfix'd the mbuf chain
	also, we may need a DTQ to flush the chip's internal byte buffer
    - en_txlaunch: only attempt a copy if we have the proper alignment.
	add byte dma code for the front and end of the buffer.
	make sure the internal dma buffer is flushed out.
    - en_dump: keep track of how many times we have to use byte sized DMA

midwayreg:
 - add byte/2byte DMA defines

midwayvar:
 - add new stat counter to monitor less-than-word lengthed DMA
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayreg.h,v 1.3 1996/07/03 17:22:00 chuck Exp $	*/
d12 1
a12 1
/* XXX: gross.   netbsd/sparc doesn't have machine/bus.h yet. */
@


1.3
log
@ported to FreeBSD 2.2-960612-SNAP.
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayreg.h,v 1.2 1996/06/26 04:08:55 chuck Exp $	*/
d231 2
@


1.2
log
@fixes:
  [1] rxslot "cur" pointer wasn't updated if we copied all data and
	didn't have any fill.   this could cause a service id mismatch
	panic under load.
  [2] recv of aal0 forgot to include the cell header in the data length
	calc [add cell header length to midwayreg.h]
  [3] fix control info "chop" for raw mode and aal0
  [4] handle rxsb better for native atm connections
	(XXX: still working on this ... not complete and needs revision)
@
text
@d1 1
a1 1
/*	$OpenBSD: midwayreg.h,v 1.1 1996/06/22 01:50:56 chuck Exp $	*/
d11 2
a12 2
#ifdef sparc
/* XXX: gross.   sparc doesn't have machine/bus.h yet. */
d22 5
a26 1
#define vtophys(x) ((u_int32_t)(x))
@


1.1
log
@device driver from the Efficient Networks "MIDWAY" ATM155 chip.
@
text
@d1 1
a1 2
/*	$OpenBSD:$	*/
/*	(sync'd to midwayreg.h 1.4)	*/
d257 2
a258 1
#define MID_RBD_SIZE	4
@
