head	1.16;
access;
symbols
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.2;
locks; strict;
comment	@ * @;


1.16
date	2009.06.29.19.28.13;	author kettenis;	state dead;
branches;
next	1.15;

1.15
date	2008.10.27.00.46.09;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.02.19.55.45;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.03.18.33.49;	author mjacob;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.17.01.32.04;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.14.00.20.55;	author mjacob;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.09.01.07.16.40;	author mjacob;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.04.22.07.19;	author mjacob;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.02.04.49.02;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.12.23.45.33;	author mjacob;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.16.01.01.59;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.06.05.31.48;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.20.21.22.41;	author mjacob;	state Exp;
branches;
next	1.2;

1.2
date	99.12.03.03.48.56;	author mjacob;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.11.22.12.50.53;	author mjacob;	state Exp;
branches;
next	;

1.2.2.1
date	2000.02.21.22.29.05;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.05.14.22.23.54;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2003.05.19.21.54.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Zap isp_inline.h; it is no longer used.

ok deraadt@@
@
text
@/*	$OpenBSD: isp_inline.h,v 1.15 2008/10/27 00:46:09 krw Exp $ */
/*
 * QLogic Host Adapter Inline Functions
 *
 * Copyright (c) 1999, 2000, 2001 by Matthew Jacob
 * Feral Software
 * All rights reserved.
 * mjacob@@feral.com
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#ifndef	_ISP_INLINE_H
#define	_ISP_INLINE_H

#ifndef EXP_INLINE
#define EXP_INLINE static __inline
#define EXPENSIVE_INLINE
#endif

/*
 * Handle Functions.
 * For each outstanding command there will be a non-zero handle.
 * There will be at most isp_maxcmds handles, and isp_lasthdls
 * will be a seed for the last handled allocated.
 */

static INLINE int isp_save_xs(struct ispsoftc *, XS_T *, u_int16_t *);
static INLINE XS_T *isp_find_xs(struct ispsoftc *, u_int16_t);
static INLINE u_int16_t isp_find_handle(struct ispsoftc *, XS_T *);
static INLINE int isp_handle_index(u_int16_t);
static INLINE void isp_destroy_handle(struct ispsoftc *, u_int16_t);
static INLINE void isp_remove_handle(struct ispsoftc *, XS_T *);

static INLINE int
isp_save_xs(struct ispsoftc *isp, XS_T *xs, u_int16_t *handlep)
{
	int i, j;

	for (j = isp->isp_lasthdls, i = 0; i < (int) isp->isp_maxcmds; i++) {
		if (isp->isp_xflist[j] == NULL) {
			break;
		}
		if (++j == isp->isp_maxcmds) {
			j = 0;
		}
	}
	if (i == isp->isp_maxcmds) {
		return (-1);
	}
	isp->isp_xflist[j] = xs;
	*handlep = j+1;
	if (++j == isp->isp_maxcmds)
		j = 0;
	isp->isp_lasthdls = (u_int16_t)j;
	return (0);
}

static INLINE XS_T *
isp_find_xs(struct ispsoftc *isp, u_int16_t handle)
{
	if (handle < 1 || handle > (u_int16_t) isp->isp_maxcmds) {
		return (NULL);
	} else {
		return (isp->isp_xflist[handle - 1]);
	}
}

static INLINE u_int16_t
isp_find_handle(struct ispsoftc *isp, XS_T *xs)
{
	int i;
	if (xs != NULL) {
		for (i = 0; i < isp->isp_maxcmds; i++) {
			if (isp->isp_xflist[i] == xs) {
				return ((u_int16_t) i+1);
			}
		}
	}
	return (0);
}

static INLINE int
isp_handle_index(u_int16_t handle)
{
	return (handle-1);
}

static INLINE void
isp_destroy_handle(struct ispsoftc *isp, u_int16_t handle)
{
	if (handle > 0 && handle <= (u_int16_t) isp->isp_maxcmds) {
		isp->isp_xflist[isp_handle_index(handle)] = NULL;
	}
}

static INLINE void
isp_remove_handle(struct ispsoftc *isp, XS_T *xs)
{
	isp_destroy_handle(isp, isp_find_handle(isp, xs));
}

EXP_INLINE int
isp_getrqentry(struct ispsoftc *, u_int16_t *, u_int16_t *, void **);

#ifdef EXPENSIVE_INLINE
EXP_INLINE int
isp_getrqentry(struct ispsoftc *isp, u_int16_t *iptrp,
    u_int16_t *optrp, void **resultp)
{
	volatile u_int16_t iptr, optr;

	optr = isp->isp_reqodx = READ_REQUEST_QUEUE_OUT_POINTER(isp);
	iptr = isp->isp_reqidx;
	*resultp = ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);
	iptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN(isp));
	if (iptr == optr) {
		return (1);
	}
	if (optrp)
		*optrp = optr;
	if (iptrp)
		*iptrp = iptr;
	return (0);
}
#endif

static INLINE void isp_print_qentry (struct ispsoftc *, char *, int, void *);


#define	TBA	(4 * (((QENTRY_LEN >> 2) * 3) + 1) + 1)
static INLINE void
isp_print_qentry(struct ispsoftc *isp, char *msg, int idx, void *arg)
{
	char buf[TBA];
	int amt, i, j;
	u_int8_t *ptr = arg;

	isp_prt(isp, ISP_LOGALL, "%s index %d=>", msg, idx);
	for (buf[0] = 0, amt = i = 0; i < 4; i++) {
		buf[0] = 0;
		SNPRINTF(buf, TBA, "  ");
		for (j = 0; j < (QENTRY_LEN >> 2); j++) {
			SNPRINTF(buf, TBA, "%s %02x", buf, ptr[amt++] & 0xff);
		}
		isp_prt(isp, ISP_LOGALL, buf);
	}
}

static INLINE void isp_print_bytes(struct ispsoftc *, char *, int, void *);

static INLINE void
isp_print_bytes(struct ispsoftc *isp, char *msg, int amt, void *arg)
{
	char buf[128];
	u_int8_t *ptr = arg;
	int off;

	if (msg)
		isp_prt(isp, ISP_LOGALL, "%s:", msg);
	off = 0;
	buf[0] = 0;
	while (off < amt) {
		int j, to;
		to = off;
		for (j = 0; j < 16; j++) {
			SNPRINTF(buf, 128, "%s %02x", buf, ptr[off++] & 0xff);
			if (off == amt)
				break;
		}
		isp_prt(isp, ISP_LOGALL, "0x%08x:%s", to, buf);
		buf[0] = 0;
	}
}

/*
 * Do the common path to try and ensure that link is up, we've scanned
 * the fabric (if we're on a fabric), and that we've synchronized this
 * all with our own database and done the appropriate logins.
 *
 * We repeatedly check for firmware state and loop state after each
 * action because things may have changed while we were doing this.
 * Any failure or change of state causes us to return a nonzero value.
 *
 * We honor HBA roles in that if we're not in Initiator mode, we don't
 * attempt to sync up the database (that's for somebody else to do,
 * if ever).
 *
 * We assume we enter here with any locks held.
 */

static INLINE int isp_fc_runstate(struct ispsoftc *, int);

static INLINE int
isp_fc_runstate(struct ispsoftc *isp, int tval)
{
	fcparam *fcp;
	int *tptr;

	if (IS_SCSI(isp))
		return (0);

	tptr = tval? &tval : NULL;
	if (isp_control(isp, ISPCTL_FCLINK_TEST, tptr) != 0) {
		return (-1);
	}
	fcp = FCPARAM(isp);
	if (fcp->isp_fwstate != FW_READY || fcp->isp_loopstate < LOOP_PDB_RCVD)
		return (-1);
	if (isp_control(isp, ISPCTL_SCAN_FABRIC, NULL) != 0) {
		return (-1);
	}
	if (isp_control(isp, ISPCTL_SCAN_LOOP, NULL) != 0) {
		return (-1);
	}
	if ((isp->isp_role & ISP_ROLE_INITIATOR) == 0) {
		return (0);
	}
	if (isp_control(isp, ISPCTL_PDB_SYNC, NULL) != 0) {
		return (-1);
	}
	if (fcp->isp_fwstate != FW_READY || fcp->isp_loopstate != LOOP_READY) {
		return (-1);
	}
	return (0);
}

/*
 * Functions to move stuff to a form that the QLogic RISC engine understands
 * and functions to move stuff back to a form the processor understands.
 *
 * Each platform is required to provide the 8, 16 and 32 bit
 * swizzle and unswizzle macros (ISP_IOX{PUT|GET}_{8,16,32})
 *
 * The assumption is that swizzling and unswizzling is mostly done 'in place'
 * (with a few exceptions for efficiency).
 */

EXP_INLINE void isp_copy_out_hdr(struct ispsoftc *, isphdr_t *, isphdr_t *);
EXP_INLINE void isp_copy_in_hdr(struct ispsoftc *, isphdr_t *, isphdr_t *);
static INLINE int isp_get_response_type(struct ispsoftc *, isphdr_t *);

static INLINE void
isp_put_request(struct ispsoftc *, ispreq_t *, ispreq_t *);
static INLINE void
isp_put_request_t2(struct ispsoftc *, ispreqt2_t *, ispreqt2_t *);
static INLINE void
isp_put_request_t3(struct ispsoftc *, ispreqt3_t *, ispreqt3_t *);
static INLINE void
isp_put_extended_request(struct ispsoftc *, ispextreq_t *, ispextreq_t *);
static INLINE void
isp_put_cont_req(struct ispsoftc *, ispcontreq_t *, ispcontreq_t *);
static INLINE void
isp_put_cont64_req(struct ispsoftc *, ispcontreq64_t *, ispcontreq64_t *);
static INLINE void
isp_get_response(struct ispsoftc *, ispstatusreq_t *, ispstatusreq_t *);
static INLINE void
isp_get_response_x(struct ispsoftc *, ispstatus_cont_t *, ispstatus_cont_t *);
static INLINE void
isp_get_rio2(struct ispsoftc *, isp_rio2_t *, isp_rio2_t *);
static INLINE void
isp_put_icb(struct ispsoftc *, isp_icb_t *, isp_icb_t *);
static INLINE void
isp_get_pdb(struct ispsoftc *, isp_pdb_t *, isp_pdb_t *);
EXP_INLINE void
isp_get_ct_hdr(struct ispsoftc *isp, ct_hdr_t *, ct_hdr_t *);
static INLINE void
isp_put_sns_request(struct ispsoftc *, sns_screq_t *, sns_screq_t *);
static INLINE void
isp_put_gid_ft_request(struct ispsoftc *, sns_gid_ft_req_t *,
    sns_gid_ft_req_t *);
EXP_INLINE void
isp_put_gxn_id_request(struct ispsoftc *, sns_gxn_id_req_t *,
    sns_gxn_id_req_t *);
static INLINE void
isp_get_sns_response(struct ispsoftc *, sns_scrsp_t *, sns_scrsp_t *, int);
static INLINE void
isp_get_gid_ft_response(struct ispsoftc *, sns_gid_ft_rsp_t *,
    sns_gid_ft_rsp_t *, int);
static INLINE void
isp_get_gxn_id_response(struct ispsoftc *, sns_gxn_id_rsp_t *,
    sns_gxn_id_rsp_t *);
static INLINE void
isp_get_gff_id_response(struct ispsoftc *, sns_gff_id_rsp_t *,
    sns_gff_id_rsp_t *);
static INLINE void
isp_get_ga_nxt_response(struct ispsoftc *, sns_ga_nxt_rsp_t *,
    sns_ga_nxt_rsp_t *);
#ifdef	ISP_TARGET_MODE
#ifndef	_ISP_TARGET_H
#include "isp_target.h"
#endif
static INLINE void
isp_put_atio(struct ispsoftc *, at_entry_t *, at_entry_t *);
static INLINE void
isp_get_atio(struct ispsoftc *, at_entry_t *, at_entry_t *);
static INLINE void
isp_put_atio2(struct ispsoftc *, at2_entry_t *, at2_entry_t *);
static INLINE void
isp_get_atio2(struct ispsoftc *, at2_entry_t *, at2_entry_t *);
static INLINE void
isp_put_ctio(struct ispsoftc *, ct_entry_t *, ct_entry_t *);
static INLINE void
isp_get_ctio(struct ispsoftc *, ct_entry_t *, ct_entry_t *);
static INLINE void
isp_put_ctio2(struct ispsoftc *, ct2_entry_t *, ct2_entry_t *);
static INLINE void
isp_get_ctio2(struct ispsoftc *, ct2_entry_t *, ct2_entry_t *);
static INLINE void
isp_put_enable_lun(struct ispsoftc *, lun_entry_t *, lun_entry_t *);
static INLINE void
isp_get_enable_lun(struct ispsoftc *, lun_entry_t *, lun_entry_t *);
static INLINE void
isp_put_notify(struct ispsoftc *, in_entry_t *, in_entry_t *);
static INLINE void
isp_get_notify(struct ispsoftc *, in_entry_t *, in_entry_t *);
static INLINE void
isp_put_notify_fc(struct ispsoftc *, in_fcentry_t *, in_fcentry_t *);
static INLINE void
isp_get_notify_fc(struct ispsoftc *, in_fcentry_t *, in_fcentry_t *);
static INLINE void
isp_put_notify_ack(struct ispsoftc *, na_entry_t *, na_entry_t *);
static INLINE void
isp_get_notify_ack(struct ispsoftc *, na_entry_t *, na_entry_t *);
static INLINE void
isp_put_notify_ack_fc(struct ispsoftc *, na_fcentry_t *, na_fcentry_t *);
static INLINE void
isp_get_notify_ack_fc(struct ispsoftc *, na_fcentry_t *, na_fcentry_t *);
#endif

#define	ISP_IS_SBUS(isp)	\
	(ISP_SBUS_SUPPORTED && (isp)->isp_bustype == ISP_BT_SBUS)

/*
 * Swizzle/Copy Functions
 */

#ifdef EXPENSIVE_INLINE
EXP_INLINE void
isp_copy_out_hdr(struct ispsoftc *isp, isphdr_t *hpsrc, isphdr_t *hpdst)
{
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, hpsrc->rqs_entry_type,
		    &hpdst->rqs_entry_count);
		ISP_IOXPUT_8(isp, hpsrc->rqs_entry_count,
		    &hpdst->rqs_entry_type);
		ISP_IOXPUT_8(isp, hpsrc->rqs_seqno,
		    &hpdst->rqs_flags);
		ISP_IOXPUT_8(isp, hpsrc->rqs_flags,
		    &hpdst->rqs_seqno);
	} else {
		ISP_IOXPUT_8(isp, hpsrc->rqs_entry_type,
		    &hpdst->rqs_entry_type);
		ISP_IOXPUT_8(isp, hpsrc->rqs_entry_count,
		    &hpdst->rqs_entry_count);
		ISP_IOXPUT_8(isp, hpsrc->rqs_seqno,
		    &hpdst->rqs_seqno);
		ISP_IOXPUT_8(isp, hpsrc->rqs_flags,
		    &hpdst->rqs_flags);
	}
}

EXP_INLINE void
isp_copy_in_hdr(struct ispsoftc *isp, isphdr_t *hpsrc, isphdr_t *hpdst)
{
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &hpsrc->rqs_entry_type,
		    hpdst->rqs_entry_count);
		ISP_IOXGET_8(isp, &hpsrc->rqs_entry_count,
		    hpdst->rqs_entry_type);
		ISP_IOXGET_8(isp, &hpsrc->rqs_seqno,
		    hpdst->rqs_flags);
		ISP_IOXGET_8(isp, &hpsrc->rqs_flags,
		    hpdst->rqs_seqno);
	} else {
		ISP_IOXGET_8(isp, &hpsrc->rqs_entry_type,
		    hpdst->rqs_entry_type);
		ISP_IOXGET_8(isp, &hpsrc->rqs_entry_count,
		    hpdst->rqs_entry_count);
		ISP_IOXGET_8(isp, &hpsrc->rqs_seqno,
		    hpdst->rqs_seqno);
		ISP_IOXGET_8(isp, &hpsrc->rqs_flags,
		    hpdst->rqs_flags);
	}
}
#endif

static INLINE int
isp_get_response_type(struct ispsoftc *isp, isphdr_t *hp)
{
	u_int8_t type;
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &hp->rqs_entry_count, type);
	} else {
		ISP_IOXGET_8(isp, &hp->rqs_entry_type, type);
	}
	return ((int)type);
}

static INLINE void
isp_put_request(struct ispsoftc *isp, ispreq_t *rqsrc, ispreq_t *rqdst)
{
	int i;
	isp_copy_out_hdr(isp, &rqsrc->req_header, &rqdst->req_header);
	ISP_IOXPUT_32(isp, rqsrc->req_handle, &rqdst->req_handle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, rqsrc->req_lun_trn, &rqdst->req_target);
		ISP_IOXPUT_8(isp, rqsrc->req_target, &rqdst->req_lun_trn);
	} else {
		ISP_IOXPUT_8(isp, rqsrc->req_lun_trn, &rqdst->req_lun_trn);
		ISP_IOXPUT_8(isp, rqsrc->req_target, &rqdst->req_target);
	}
	ISP_IOXPUT_16(isp, rqsrc->req_cdblen, &rqdst->req_cdblen);
	ISP_IOXPUT_16(isp, rqsrc->req_flags, &rqdst->req_flags);
	ISP_IOXPUT_16(isp, rqsrc->req_time, &rqdst->req_time);
	ISP_IOXPUT_16(isp, rqsrc->req_seg_count, &rqdst->req_seg_count);
	for (i = 0; i < 12; i++) {
		ISP_IOXPUT_8(isp, rqsrc->req_cdb[i], &rqdst->req_cdb[i]);
	}
	for (i = 0; i < ISP_RQDSEG; i++) {
		ISP_IOXPUT_32(isp, rqsrc->req_dataseg[i].ds_base,
		    &rqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, rqsrc->req_dataseg[i].ds_count,
		    &rqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_request_t2(struct ispsoftc *isp, ispreqt2_t *tqsrc, ispreqt2_t *tqdst)
{
	int i;
	isp_copy_out_hdr(isp, &tqsrc->req_header, &tqdst->req_header);
	ISP_IOXPUT_32(isp, tqsrc->req_handle, &tqdst->req_handle);
	ISP_IOXPUT_8(isp, tqsrc->req_lun_trn, &tqdst->req_lun_trn);
	ISP_IOXPUT_8(isp, tqsrc->req_target, &tqdst->req_target);
	ISP_IOXPUT_16(isp, tqsrc->req_scclun, &tqdst->req_scclun);
	ISP_IOXPUT_16(isp, tqsrc->req_flags,  &tqdst->req_flags);
	ISP_IOXPUT_16(isp, tqsrc->req_reserved, &tqdst->req_reserved);
	ISP_IOXPUT_16(isp, tqsrc->req_time, &tqdst->req_time);
	ISP_IOXPUT_16(isp, tqsrc->req_seg_count, &tqdst->req_seg_count);
	for (i = 0; i < 16; i++) {
		ISP_IOXPUT_8(isp, tqsrc->req_cdb[i], &tqdst->req_cdb[i]);
	}
	ISP_IOXPUT_32(isp, tqsrc->req_totalcnt, &tqdst->req_totalcnt);
	for (i = 0; i < ISP_RQDSEG_T2; i++) {
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_base,
		    &tqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_count,
		    &tqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_request_t3(struct ispsoftc *isp, ispreqt3_t *tqsrc, ispreqt3_t *tqdst)
{
	int i;
	isp_copy_out_hdr(isp, &tqsrc->req_header, &tqdst->req_header);
	ISP_IOXPUT_32(isp, tqsrc->req_handle, &tqdst->req_handle);
	ISP_IOXPUT_8(isp, tqsrc->req_lun_trn, &tqdst->req_lun_trn);
	ISP_IOXPUT_8(isp, tqsrc->req_target, &tqdst->req_target);
	ISP_IOXPUT_16(isp, tqsrc->req_scclun, &tqdst->req_scclun);
	ISP_IOXPUT_16(isp, tqsrc->req_flags,  &tqdst->req_flags);
	ISP_IOXPUT_16(isp, tqsrc->req_reserved, &tqdst->req_reserved);
	ISP_IOXPUT_16(isp, tqsrc->req_time, &tqdst->req_time);
	ISP_IOXPUT_16(isp, tqsrc->req_seg_count, &tqdst->req_seg_count);
	for (i = 0; i < 16; i++) {
		ISP_IOXPUT_8(isp, tqsrc->req_cdb[i], &tqdst->req_cdb[i]);
	}
	ISP_IOXPUT_32(isp, tqsrc->req_totalcnt, &tqdst->req_totalcnt);
	for (i = 0; i < ISP_RQDSEG_T3; i++) {
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_base,
		    &tqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_basehi,
		    &tqdst->req_dataseg[i].ds_basehi);
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_count,
		    &tqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_extended_request(struct ispsoftc *isp, ispextreq_t *xqsrc,
    ispextreq_t *xqdst)
{
	int i;
	isp_copy_out_hdr(isp, &xqsrc->req_header, &xqdst->req_header);
	ISP_IOXPUT_32(isp, xqsrc->req_handle, &xqdst->req_handle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, xqsrc->req_lun_trn, &xqdst->req_target);
		ISP_IOXPUT_8(isp, xqsrc->req_target, &xqdst->req_lun_trn);
	} else {
		ISP_IOXPUT_8(isp, xqsrc->req_lun_trn, &xqdst->req_lun_trn);
		ISP_IOXPUT_8(isp, xqsrc->req_target, &xqdst->req_target);
	}
	ISP_IOXPUT_16(isp, xqsrc->req_cdblen, &xqdst->req_cdblen);
	ISP_IOXPUT_16(isp, xqsrc->req_flags, &xqdst->req_flags);
	ISP_IOXPUT_16(isp, xqsrc->req_time, &xqdst->req_time);
	ISP_IOXPUT_16(isp, xqsrc->req_seg_count, &xqdst->req_seg_count);
	for (i = 0; i < 44; i++) {
		ISP_IOXPUT_8(isp, xqsrc->req_cdb[i], &xqdst->req_cdb[i]);
	}
}

static INLINE void
isp_put_cont_req(struct ispsoftc *isp, ispcontreq_t *cqsrc, ispcontreq_t *cqdst)
{
	int i;
	isp_copy_out_hdr(isp, &cqsrc->req_header, &cqdst->req_header);
	for (i = 0; i < ISP_CDSEG; i++) {
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_base,
		    &cqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_count,
		    &cqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_cont64_req(struct ispsoftc *isp, ispcontreq64_t *cqsrc,
    ispcontreq64_t *cqdst)
{
	int i;
	isp_copy_out_hdr(isp, &cqsrc->req_header, &cqdst->req_header);
	for (i = 0; i < ISP_CDSEG64; i++) {
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_base,
		    &cqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_basehi,
		    &cqdst->req_dataseg[i].ds_basehi);
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_count,
		    &cqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_get_response(struct ispsoftc *isp, ispstatusreq_t *spsrc,
    ispstatusreq_t *spdst)
{
	int i;
	isp_copy_in_hdr(isp, &spsrc->req_header, &spdst->req_header);
	ISP_IOXGET_32(isp, &spsrc->req_handle, spdst->req_handle);
	ISP_IOXGET_16(isp, &spsrc->req_scsi_status, spdst->req_scsi_status);
	ISP_IOXGET_16(isp, &spsrc->req_completion_status,
	    spdst->req_completion_status);
	ISP_IOXGET_16(isp, &spsrc->req_state_flags, spdst->req_state_flags);
	ISP_IOXGET_16(isp, &spsrc->req_status_flags, spdst->req_status_flags);
	ISP_IOXGET_16(isp, &spsrc->req_time, spdst->req_time);
	ISP_IOXGET_16(isp, &spsrc->req_sense_len, spdst->req_sense_len);
	ISP_IOXGET_32(isp, &spsrc->req_resid, spdst->req_resid);
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &spsrc->req_response[i],
		    spdst->req_response[i]);
	}
	for (i = 0; i < 32; i++) {
		ISP_IOXGET_8(isp, &spsrc->req_sense_data[i],
		    spdst->req_sense_data[i]);
	}
}

static INLINE void
isp_get_response_x(struct ispsoftc *isp, ispstatus_cont_t *cpsrc,
    ispstatus_cont_t *cpdst)
{
	int i;
	isp_copy_in_hdr(isp, &cpsrc->req_header, &cpdst->req_header);
	for (i = 0; i < 60; i++) {
		ISP_IOXGET_8(isp, &cpsrc->req_sense_data[i],
		    cpdst->req_sense_data[i]);
	}
}

static INLINE void
isp_get_rio2(struct ispsoftc *isp, isp_rio2_t *r2src, isp_rio2_t *r2dst)
{
	int i;
	isp_copy_in_hdr(isp, &r2src->req_header, &r2dst->req_header);
	if (r2dst->req_header.rqs_seqno > 30)
		r2dst->req_header.rqs_seqno = 30;
	for (i = 0; i < r2dst->req_header.rqs_seqno; i++) {
		ISP_IOXGET_16(isp, &r2src->req_handles[i],
		    r2dst->req_handles[i]);
	}
	while (i < 30) {
		r2dst->req_handles[i++] = 0;
	}
}

static INLINE void
isp_put_icb(struct ispsoftc *isp, isp_icb_t *Is, isp_icb_t *Id)
{
	int i;
	ISP_SWAP8(Is->icb_version, Is->icb_reserved0);
	ISP_IOXPUT_8(isp, Is->icb_version, &Id->icb_version);
	ISP_IOXPUT_8(isp, Is->icb_reserved0, &Id->icb_reserved0);
	ISP_IOXPUT_16(isp, Is->icb_fwoptions, &Id->icb_fwoptions);
	ISP_IOXPUT_16(isp, Is->icb_maxfrmlen, &Id->icb_maxfrmlen);
	ISP_IOXPUT_16(isp, Is->icb_maxalloc, &Id->icb_maxalloc);
	ISP_IOXPUT_16(isp, Is->icb_execthrottle, &Id->icb_execthrottle);
	ISP_SWAP8(Is->icb_retry_count, Is->icb_retry_delay);
	ISP_IOXPUT_8(isp, Is->icb_retry_count, &Id->icb_retry_count);
	ISP_IOXPUT_8(isp, Is->icb_retry_delay, &Id->icb_retry_delay);
	for (i = 0; i < 8; i++) {
		ISP_IOXPUT_8(isp, Is->icb_portname[i], &Id->icb_portname[i]);
	}
	ISP_IOXPUT_16(isp, Is->icb_hardaddr, &Id->icb_hardaddr);
	ISP_SWAP8(Is->icb_iqdevtype, Is->icb_logintime);
	ISP_IOXPUT_8(isp, Is->icb_iqdevtype, &Id->icb_iqdevtype);
	ISP_IOXPUT_8(isp, Is->icb_logintime, &Id->icb_logintime);
	for (i = 0; i < 8; i++) {
		ISP_IOXPUT_8(isp, Is->icb_nodename[i], &Id->icb_nodename[i]);
	}
	ISP_IOXPUT_16(isp, Is->icb_rqstout, &Id->icb_rqstout);
	ISP_IOXPUT_16(isp, Is->icb_rspnsin, &Id->icb_rspnsin);
	ISP_IOXPUT_16(isp, Is->icb_rqstqlen, &Id->icb_rqstqlen);
	ISP_IOXPUT_16(isp, Is->icb_rsltqlen, &Id->icb_rsltqlen);
	for (i = 0; i < 4; i++) {
		ISP_IOXPUT_16(isp, Is->icb_rqstaddr[i], &Id->icb_rqstaddr[i]);
	}
	for (i = 0; i < 4; i++) {
		ISP_IOXPUT_16(isp, Is->icb_respaddr[i], &Id->icb_respaddr[i]);
	}
	ISP_IOXPUT_16(isp, Is->icb_lunenables, &Id->icb_lunenables);
	ISP_SWAP8(Is->icb_ccnt, Is->icb_icnt);
	ISP_IOXPUT_8(isp, Is->icb_ccnt, &Id->icb_ccnt);
	ISP_IOXPUT_8(isp, Is->icb_icnt, &Id->icb_icnt);
	ISP_IOXPUT_16(isp, Is->icb_lunetimeout, &Id->icb_lunetimeout);
	ISP_IOXPUT_16(isp, Is->icb_xfwoptions, &Id->icb_xfwoptions);
	ISP_SWAP8(Is->icb_racctimer, Is->icb_idelaytimer);
	ISP_IOXPUT_8(isp, Is->icb_racctimer, &Id->icb_racctimer);
	ISP_IOXPUT_8(isp, Is->icb_idelaytimer, &Id->icb_idelaytimer);
	ISP_IOXPUT_16(isp, Is->icb_zfwoptions, &Id->icb_zfwoptions);
}

static INLINE void
isp_get_pdb(struct ispsoftc *isp, isp_pdb_t *src, isp_pdb_t *dst)
{
	int i;
	ISP_IOXGET_16(isp, &src->pdb_options, dst->pdb_options);
        ISP_IOXGET_8(isp, &src->pdb_mstate, dst->pdb_mstate);
        ISP_IOXGET_8(isp, &src->pdb_sstate, dst->pdb_sstate);
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_8(isp, &src->pdb_hardaddr_bits[i],
		    dst->pdb_hardaddr_bits[i]);
	}
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_8(isp, &src->pdb_portid_bits[i],
		    dst->pdb_portid_bits[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->pdb_nodename[i], dst->pdb_nodename[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->pdb_portname[i], dst->pdb_portname[i]);
	}
	ISP_IOXGET_16(isp, &src->pdb_execthrottle, dst->pdb_execthrottle);
	ISP_IOXGET_16(isp, &src->pdb_exec_count, dst->pdb_exec_count);
	ISP_IOXGET_8(isp, &src->pdb_retry_count, dst->pdb_retry_count);
	ISP_IOXGET_8(isp, &src->pdb_retry_delay, dst->pdb_retry_delay);
	ISP_IOXGET_16(isp, &src->pdb_resalloc, dst->pdb_resalloc);
	ISP_IOXGET_16(isp, &src->pdb_curalloc, dst->pdb_curalloc);
	ISP_IOXGET_16(isp, &src->pdb_qhead, dst->pdb_qhead);
	ISP_IOXGET_16(isp, &src->pdb_qtail, dst->pdb_qtail);
	ISP_IOXGET_16(isp, &src->pdb_tl_next, dst->pdb_tl_next);
	ISP_IOXGET_16(isp, &src->pdb_tl_last, dst->pdb_tl_last);
	ISP_IOXGET_16(isp, &src->pdb_features, dst->pdb_features);
	ISP_IOXGET_16(isp, &src->pdb_pconcurrnt, dst->pdb_pconcurrnt);
	ISP_IOXGET_16(isp, &src->pdb_roi, dst->pdb_roi);
	ISP_IOXGET_8(isp, &src->pdb_target, dst->pdb_target);
	ISP_IOXGET_8(isp, &src->pdb_initiator, dst->pdb_initiator);
	ISP_IOXGET_16(isp, &src->pdb_rdsiz, dst->pdb_rdsiz);
	ISP_IOXGET_16(isp, &src->pdb_ncseq, dst->pdb_ncseq);
	ISP_IOXGET_16(isp, &src->pdb_noseq, dst->pdb_noseq);
	ISP_IOXGET_16(isp, &src->pdb_labrtflg, dst->pdb_labrtflg);
	ISP_IOXGET_16(isp, &src->pdb_lstopflg, dst->pdb_lstopflg);
	ISP_IOXGET_16(isp, &src->pdb_sqhead, dst->pdb_sqhead);
	ISP_IOXGET_16(isp, &src->pdb_sqtail, dst->pdb_sqtail);
	ISP_IOXGET_16(isp, &src->pdb_ptimer, dst->pdb_ptimer);
	ISP_IOXGET_16(isp, &src->pdb_nxt_seqid, dst->pdb_nxt_seqid);
	ISP_IOXGET_16(isp, &src->pdb_fcount, dst->pdb_fcount);
	ISP_IOXGET_16(isp, &src->pdb_prli_len, dst->pdb_prli_len);
	ISP_IOXGET_16(isp, &src->pdb_prli_svc0, dst->pdb_prli_svc0);
	ISP_IOXGET_16(isp, &src->pdb_prli_svc3, dst->pdb_prli_svc3);
	ISP_IOXGET_16(isp, &src->pdb_loopid, dst->pdb_loopid);
	ISP_IOXGET_16(isp, &src->pdb_il_ptr, dst->pdb_il_ptr);
	ISP_IOXGET_16(isp, &src->pdb_sl_ptr, dst->pdb_sl_ptr);
}


/*
 * CT_HDR canonicalization- only needed for SNS responses
 */
#ifdef EXPENSIVE_INLINE
EXP_INLINE void
isp_get_ct_hdr(struct ispsoftc *isp, ct_hdr_t *src, ct_hdr_t *dst)
{
	ISP_IOXGET_8(isp, &src->ct_revision, dst->ct_revision);
	ISP_IOXGET_8(isp, &src->ct_portid[0], dst->ct_portid[0]);
	ISP_IOXGET_8(isp, &src->ct_portid[1], dst->ct_portid[1]);
	ISP_IOXGET_8(isp, &src->ct_portid[2], dst->ct_portid[2]);
	ISP_IOXGET_8(isp, &src->ct_fcs_type, dst->ct_fcs_type);
	ISP_IOXGET_8(isp, &src->ct_fcs_subtype, dst->ct_fcs_subtype);
	ISP_IOXGET_8(isp, &src->ct_options, dst->ct_options);
	ISP_IOXGET_8(isp, &src->ct_res0, dst->ct_res0);
	ISP_IOXGET_16(isp, &src->ct_response, dst->ct_response);
	dst->ct_response = (dst->ct_response << 8) | (dst->ct_response >> 8);
	ISP_IOXGET_16(isp, &src->ct_resid, dst->ct_resid);
	dst->ct_resid = (dst->ct_resid << 8) | (dst->ct_resid >> 8);
	ISP_IOXGET_8(isp, &src->ct_res1, dst->ct_res1);
	ISP_IOXGET_8(isp, &src->ct_reason, dst->ct_reason);
	ISP_IOXGET_8(isp, &src->ct_explanation, dst->ct_explanation);
	ISP_IOXGET_8(isp, &src->ct_vunique, dst->ct_vunique);
}
#endif

/*
 * Generic SNS request - not particularly useful since the per-command data
 * isn't always 16 bit words.
 */
static INLINE void
isp_put_sns_request(struct ispsoftc *isp, sns_screq_t *src, sns_screq_t *dst)
{
	int i, nw = (int) src->snscb_sblen;
	ISP_IOXPUT_16(isp, src->snscb_rblen, &dst->snscb_rblen);
	for (i = 0; i < 4; i++) {
		ISP_IOXPUT_16(isp, src->snscb_addr[i], &dst->snscb_addr[i]);
	}
	ISP_IOXPUT_16(isp, src->snscb_sblen, &dst->snscb_sblen);
	for (i = 0; i < nw; i++) {
		ISP_IOXPUT_16(isp, src->snscb_data[i], &dst->snscb_data[i]);
	}
	
}

static INLINE void
isp_put_gid_ft_request(struct ispsoftc *isp, sns_gid_ft_req_t *src,
    sns_gid_ft_req_t *dst)
{
	ISP_IOXPUT_16(isp, src->snscb_rblen, &dst->snscb_rblen);
	ISP_IOXPUT_16(isp, src->snscb_reserved0, &dst->snscb_reserved0);
	ISP_IOXPUT_16(isp, src->snscb_addr[0], &dst->snscb_addr[0]);
	ISP_IOXPUT_16(isp, src->snscb_addr[1], &dst->snscb_addr[1]);
	ISP_IOXPUT_16(isp, src->snscb_addr[2], &dst->snscb_addr[2]);
	ISP_IOXPUT_16(isp, src->snscb_addr[3], &dst->snscb_addr[3]);
	ISP_IOXPUT_16(isp, src->snscb_sblen, &dst->snscb_sblen);
	ISP_IOXPUT_16(isp, src->snscb_reserved1, &dst->snscb_reserved1);
	ISP_IOXPUT_16(isp, src->snscb_cmd, &dst->snscb_cmd);
	ISP_IOXPUT_16(isp, src->snscb_mword_div_2, &dst->snscb_mword_div_2);
	ISP_IOXPUT_32(isp, src->snscb_reserved3, &dst->snscb_reserved3);
	ISP_IOXPUT_32(isp, src->snscb_fc4_type, &dst->snscb_fc4_type);
}

#ifdef EXPENSIVE_INLINE
EXP_INLINE void
isp_put_gxn_id_request(struct ispsoftc *isp, sns_gxn_id_req_t *src,
    sns_gxn_id_req_t *dst)
{
	ISP_IOXPUT_16(isp, src->snscb_rblen, &dst->snscb_rblen);
	ISP_IOXPUT_16(isp, src->snscb_reserved0, &dst->snscb_reserved0);
	ISP_IOXPUT_16(isp, src->snscb_addr[0], &dst->snscb_addr[0]);
	ISP_IOXPUT_16(isp, src->snscb_addr[1], &dst->snscb_addr[1]);
	ISP_IOXPUT_16(isp, src->snscb_addr[2], &dst->snscb_addr[2]);
	ISP_IOXPUT_16(isp, src->snscb_addr[3], &dst->snscb_addr[3]);
	ISP_IOXPUT_16(isp, src->snscb_sblen, &dst->snscb_sblen);
	ISP_IOXPUT_16(isp, src->snscb_reserved1, &dst->snscb_reserved1);
	ISP_IOXPUT_16(isp, src->snscb_cmd, &dst->snscb_cmd);
	ISP_IOXPUT_16(isp, src->snscb_reserved2, &dst->snscb_reserved2);
	ISP_IOXPUT_32(isp, src->snscb_reserved3, &dst->snscb_reserved3);
	ISP_IOXPUT_32(isp, src->snscb_portid, &dst->snscb_portid);
}
#endif

/*
 * Generic SNS response - not particularly useful since the per-command data
 * isn't always 16 bit words.
 */
static INLINE void
isp_get_sns_response(struct ispsoftc *isp, sns_scrsp_t *src,
    sns_scrsp_t *dst, int nwords)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	ISP_IOXGET_8(isp, &src->snscb_port_type, dst->snscb_port_type);
	for (i = 0; i < 3; i++) {
		ISP_IOXGET_8(isp, &src->snscb_port_id[i],
		    dst->snscb_port_id[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_portname[i],
		    dst->snscb_portname[i]);
	}
	for (i = 0; i < nwords; i++) {
		ISP_IOXGET_16(isp, &src->snscb_data[i], dst->snscb_data[i]);
	}
}

static INLINE void
isp_get_gid_ft_response(struct ispsoftc *isp, sns_gid_ft_rsp_t *src,
    sns_gid_ft_rsp_t *dst, int nwords)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	for (i = 0; i < nwords; i++) {
		int j;
		ISP_IOXGET_8(isp,
		    &src->snscb_ports[i].control,
		    dst->snscb_ports[i].control);
		for (j = 0; j < 3; j++) {
			ISP_IOXGET_8(isp,
			    &src->snscb_ports[i].portid[j],
			    dst->snscb_ports[i].portid[j]);
		}
		if (dst->snscb_ports[i].control & 0x80) {
			break;
		}
	}
}

static INLINE void
isp_get_gxn_id_response(struct ispsoftc *isp, sns_gxn_id_rsp_t *src,
    sns_gxn_id_rsp_t *dst)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	for (i = 0; i < 8; i++)
		ISP_IOXGET_8(isp, &src->snscb_wwn[i], dst->snscb_wwn[i]);
}

static INLINE void
isp_get_gff_id_response(struct ispsoftc *isp, sns_gff_id_rsp_t *src,
    sns_gff_id_rsp_t *dst)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	for (i = 0; i < 32; i++) {
		ISP_IOXGET_32(isp, &src->snscb_fc4_features[i],
		    dst->snscb_fc4_features[i]);
	}
}

static INLINE void
isp_get_ga_nxt_response(struct ispsoftc *isp, sns_ga_nxt_rsp_t *src,
    sns_ga_nxt_rsp_t *dst)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	ISP_IOXGET_8(isp, &src->snscb_port_type, dst->snscb_port_type);
	for (i = 0; i < 3; i++) {
		ISP_IOXGET_8(isp, &src->snscb_port_id[i],
		    dst->snscb_port_id[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_portname[i],
		    dst->snscb_portname[i]);
	}
	ISP_IOXGET_8(isp, &src->snscb_pnlen, dst->snscb_pnlen);
	for (i = 0; i < 255; i++) {
		ISP_IOXGET_8(isp, &src->snscb_pname[i], dst->snscb_pname[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_nodename[i],
		    dst->snscb_nodename[i]);
	}
	ISP_IOXGET_8(isp, &src->snscb_nnlen, dst->snscb_nnlen);
	for (i = 0; i < 255; i++) {
		ISP_IOXGET_8(isp, &src->snscb_nname[i], dst->snscb_nname[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_ipassoc[i],
		    dst->snscb_ipassoc[i]);
	}
	for (i = 0; i < 16; i++) {
		ISP_IOXGET_8(isp, &src->snscb_ipaddr[i], dst->snscb_ipaddr[i]);
	}
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_8(isp, &src->snscb_svc_class[i],
		    dst->snscb_svc_class[i]);
	}
	for (i = 0; i < 32; i++) {
		ISP_IOXGET_8(isp, &src->snscb_fc4_types[i],
		    dst->snscb_fc4_types[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_fpname[i], dst->snscb_fpname[i]);
	}
	ISP_IOXGET_8(isp, &src->snscb_reserved, dst->snscb_reserved);
	for (i = 0; i < 3; i++) {
		ISP_IOXGET_8(isp, &src->snscb_hardaddr[i],
		    dst->snscb_hardaddr[i]);
	}
}

#ifdef	ISP_TARGET_MODE
static INLINE void
isp_put_atio(struct ispsoftc *isp, at_entry_t *atsrc, at_entry_t *atdst)
{
	int i;
	isp_copy_out_hdr(isp, &atsrc->at_header, &atdst->at_header);
	ISP_IOXPUT_16(isp, atsrc->at_reserved, &atdst->at_reserved);
	ISP_IOXPUT_16(isp, atsrc->at_handle, &atdst->at_handle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, atsrc->at_lun, &atdst->at_iid);
		ISP_IOXPUT_8(isp, atsrc->at_iid, &atdst->at_lun);
		ISP_IOXPUT_8(isp, atsrc->at_cdblen, &atdst->at_tgt);
		ISP_IOXPUT_8(isp, atsrc->at_tgt, &atdst->at_cdblen);
		ISP_IOXPUT_8(isp, atsrc->at_status, &atdst->at_scsi_status);
		ISP_IOXPUT_8(isp, atsrc->at_scsi_status, &atdst->at_status);
		ISP_IOXPUT_8(isp, atsrc->at_tag_val, &atdst->at_tag_type);
		ISP_IOXPUT_8(isp, atsrc->at_tag_type, &atdst->at_tag_val);
	} else {
		ISP_IOXPUT_8(isp, atsrc->at_lun, &atdst->at_lun);
		ISP_IOXPUT_8(isp, atsrc->at_iid, &atdst->at_iid);
		ISP_IOXPUT_8(isp, atsrc->at_cdblen, &atdst->at_cdblen);
		ISP_IOXPUT_8(isp, atsrc->at_tgt, &atdst->at_tgt);
		ISP_IOXPUT_8(isp, atsrc->at_status, &atdst->at_status);
		ISP_IOXPUT_8(isp, atsrc->at_scsi_status,
		    &atdst->at_scsi_status);
		ISP_IOXPUT_8(isp, atsrc->at_tag_val, &atdst->at_tag_val);
		ISP_IOXPUT_8(isp, atsrc->at_tag_type, &atdst->at_tag_type);
	}
	ISP_IOXPUT_32(isp, atsrc->at_flags, &atdst->at_flags);
	for (i = 0; i < ATIO_CDBLEN; i++) {
		ISP_IOXPUT_8(isp, atsrc->at_cdb[i], &atdst->at_cdb[i]);
	}
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXPUT_8(isp, atsrc->at_sense[i], &atdst->at_sense[i]);
	}
}

static INLINE void
isp_get_atio(struct ispsoftc *isp, at_entry_t *atsrc, at_entry_t *atdst)
{
	int i;
	isp_copy_in_hdr(isp, &atsrc->at_header, &atdst->at_header);
	ISP_IOXGET_16(isp, &atsrc->at_reserved, atdst->at_reserved);
	ISP_IOXGET_16(isp, &atsrc->at_handle, atdst->at_handle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &atsrc->at_lun, atdst->at_iid);
		ISP_IOXGET_8(isp, &atsrc->at_iid, atdst->at_lun);
		ISP_IOXGET_8(isp, &atsrc->at_cdblen, atdst->at_tgt);
		ISP_IOXGET_8(isp, &atsrc->at_tgt, atdst->at_cdblen);
		ISP_IOXGET_8(isp, &atsrc->at_status, atdst->at_scsi_status);
		ISP_IOXGET_8(isp, &atsrc->at_scsi_status, atdst->at_status);
		ISP_IOXGET_8(isp, &atsrc->at_tag_val, atdst->at_tag_type);
		ISP_IOXGET_8(isp, &atsrc->at_tag_type, atdst->at_tag_val);
	} else {
		ISP_IOXGET_8(isp, &atsrc->at_lun, atdst->at_lun);
		ISP_IOXGET_8(isp, &atsrc->at_iid, atdst->at_iid);
		ISP_IOXGET_8(isp, &atsrc->at_cdblen, atdst->at_cdblen);
		ISP_IOXGET_8(isp, &atsrc->at_tgt, atdst->at_tgt);
		ISP_IOXGET_8(isp, &atsrc->at_status, atdst->at_status);
		ISP_IOXGET_8(isp, &atsrc->at_scsi_status,
		    atdst->at_scsi_status);
		ISP_IOXGET_8(isp, &atsrc->at_tag_val, atdst->at_tag_val);
		ISP_IOXGET_8(isp, &atsrc->at_tag_type, atdst->at_tag_type);
	}
	ISP_IOXGET_32(isp, &atsrc->at_flags, atdst->at_flags);
	for (i = 0; i < ATIO_CDBLEN; i++) {
		ISP_IOXGET_8(isp, &atsrc->at_cdb[i], atdst->at_cdb[i]);
	}
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXGET_8(isp, &atsrc->at_sense[i], atdst->at_sense[i]);
	}
}

static INLINE void
isp_put_atio2(struct ispsoftc *isp, at2_entry_t *atsrc, at2_entry_t *atdst)
{
	int i;
	isp_copy_out_hdr(isp, &atsrc->at_header, &atdst->at_header);
	ISP_IOXPUT_32(isp, atsrc->at_reserved, &atdst->at_reserved);
	ISP_IOXPUT_8(isp, atsrc->at_lun, &atdst->at_lun);
	ISP_IOXPUT_8(isp, atsrc->at_iid, &atdst->at_iid);
	ISP_IOXPUT_16(isp, atsrc->at_rxid, &atdst->at_rxid);
	ISP_IOXPUT_16(isp, atsrc->at_flags, &atdst->at_flags);
	ISP_IOXPUT_16(isp, atsrc->at_status, &atdst->at_status);
	ISP_IOXPUT_8(isp, atsrc->at_reserved1, &atdst->at_reserved1);
	ISP_IOXPUT_8(isp, atsrc->at_taskcodes, &atdst->at_taskcodes);
	ISP_IOXPUT_8(isp, atsrc->at_taskflags, &atdst->at_taskflags);
	ISP_IOXPUT_8(isp, atsrc->at_execodes, &atdst->at_execodes);
	for (i = 0; i < ATIO2_CDBLEN; i++) {
		ISP_IOXPUT_8(isp, atsrc->at_cdb[i], &atdst->at_cdb[i]);
	}
	ISP_IOXPUT_32(isp, atsrc->at_datalen, &atdst->at_datalen);
	ISP_IOXPUT_16(isp, atsrc->at_scclun, &atdst->at_scclun);
	for (i = 0; i < 4; i++) {
		ISP_IOXPUT_16(isp, atsrc->at_wwpn[i], &atdst->at_wwpn[i]);
	}
	for (i = 0; i < 6; i++) {
		ISP_IOXPUT_16(isp, atsrc->at_reserved2[i],
		    &atdst->at_reserved2[i]);
	}
	ISP_IOXPUT_16(isp, atsrc->at_oxid, &atdst->at_oxid);
}

static INLINE void
isp_get_atio2(struct ispsoftc *isp, at2_entry_t *atsrc, at2_entry_t *atdst)
{
	int i;
	isp_copy_in_hdr(isp, &atsrc->at_header, &atdst->at_header);
	ISP_IOXGET_32(isp, &atsrc->at_reserved, atdst->at_reserved);
	ISP_IOXGET_8(isp, &atsrc->at_lun, atdst->at_lun);
	ISP_IOXGET_8(isp, &atsrc->at_iid, atdst->at_iid);
	ISP_IOXGET_16(isp, &atsrc->at_rxid, atdst->at_rxid);
	ISP_IOXGET_16(isp, &atsrc->at_flags, atdst->at_flags);
	ISP_IOXGET_16(isp, &atsrc->at_status, atdst->at_status);
	ISP_IOXGET_8(isp, &atsrc->at_reserved1, atdst->at_reserved1);
	ISP_IOXGET_8(isp, &atsrc->at_taskcodes, atdst->at_taskcodes);
	ISP_IOXGET_8(isp, &atsrc->at_taskflags, atdst->at_taskflags);
	ISP_IOXGET_8(isp, &atsrc->at_execodes, atdst->at_execodes);
	for (i = 0; i < ATIO2_CDBLEN; i++) {
		ISP_IOXGET_8(isp, &atsrc->at_cdb[i], atdst->at_cdb[i]);
	}
	ISP_IOXGET_32(isp, &atsrc->at_datalen, atdst->at_datalen);
	ISP_IOXGET_16(isp, &atsrc->at_scclun, atdst->at_scclun);
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_16(isp, &atsrc->at_wwpn[i], atdst->at_wwpn[i]);
	}
	for (i = 0; i < 6; i++) {
		ISP_IOXGET_16(isp, &atsrc->at_reserved2[i],
		    atdst->at_reserved2[i]);
	}
	ISP_IOXGET_16(isp, &atsrc->at_oxid, atdst->at_oxid);
}

static INLINE void
isp_put_ctio(struct ispsoftc *isp, ct_entry_t *ctsrc, ct_entry_t *ctdst)
{
	int i;
	isp_copy_out_hdr(isp, &ctsrc->ct_header, &ctdst->ct_header);
	ISP_IOXPUT_16(isp, ctsrc->ct_reserved, &ctdst->ct_reserved);
	ISP_IOXPUT_16(isp, ctsrc->ct_fwhandle, &ctdst->ct_fwhandle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, ctsrc->ct_iid, &ctdst->ct_lun);
		ISP_IOXPUT_8(isp, ctsrc->ct_lun, &ctdst->ct_iid);
		ISP_IOXPUT_8(isp, ctsrc->ct_tgt, &ctdst->ct_reserved2);
		ISP_IOXPUT_8(isp, ctsrc->ct_reserved2, &ctdst->ct_tgt);
		ISP_IOXPUT_8(isp, ctsrc->ct_status, &ctdst->ct_scsi_status);
		ISP_IOXPUT_8(isp, ctsrc->ct_scsi_status, &ctdst->ct_status);
		ISP_IOXPUT_8(isp, ctsrc->ct_tag_type, &ctdst->ct_tag_val);
		ISP_IOXPUT_8(isp, ctsrc->ct_tag_val, &ctdst->ct_tag_type);
	} else {
		ISP_IOXPUT_8(isp, ctsrc->ct_iid, &ctdst->ct_iid);
		ISP_IOXPUT_8(isp, ctsrc->ct_lun, &ctdst->ct_lun);
		ISP_IOXPUT_8(isp, ctsrc->ct_tgt, &ctdst->ct_tgt);
		ISP_IOXPUT_8(isp, ctsrc->ct_reserved2, &ctdst->ct_reserved2);
		ISP_IOXPUT_8(isp, ctsrc->ct_scsi_status,
		    &ctdst->ct_scsi_status);
		ISP_IOXPUT_8(isp, ctsrc->ct_status, &ctdst->ct_status);
		ISP_IOXPUT_8(isp, ctsrc->ct_tag_type, &ctdst->ct_tag_type);
		ISP_IOXPUT_8(isp, ctsrc->ct_tag_val, &ctdst->ct_tag_val);
	}
	ISP_IOXPUT_32(isp, ctsrc->ct_flags, &ctdst->ct_flags);
	ISP_IOXPUT_32(isp, ctsrc->ct_xfrlen, &ctdst->ct_xfrlen);
	ISP_IOXPUT_32(isp, ctsrc->ct_resid, &ctdst->ct_resid);
	ISP_IOXPUT_16(isp, ctsrc->ct_timeout, &ctdst->ct_timeout);
	ISP_IOXPUT_16(isp, ctsrc->ct_seg_count, &ctdst->ct_seg_count);
	for (i = 0; i < ISP_RQDSEG; i++) {
		ISP_IOXPUT_32(isp, ctsrc->ct_dataseg[i].ds_base,
		    &ctdst->ct_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, ctsrc->ct_dataseg[i].ds_count,
		    &ctdst->ct_dataseg[i].ds_count);
	}
}

static INLINE void
isp_get_ctio(struct ispsoftc *isp, ct_entry_t *ctsrc, ct_entry_t *ctdst)
{
	int i;
	isp_copy_in_hdr(isp, &ctsrc->ct_header, &ctdst->ct_header);
	ISP_IOXGET_16(isp, &ctsrc->ct_reserved, ctdst->ct_reserved);
	ISP_IOXGET_16(isp, &ctsrc->ct_fwhandle, ctdst->ct_fwhandle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &ctsrc->ct_lun, ctdst->ct_iid);
		ISP_IOXGET_8(isp, &ctsrc->ct_iid, ctdst->ct_lun);
		ISP_IOXGET_8(isp, &ctsrc->ct_reserved2, ctdst->ct_tgt);
		ISP_IOXGET_8(isp, &ctsrc->ct_tgt, ctdst->ct_reserved2);
		ISP_IOXGET_8(isp, &ctsrc->ct_status, ctdst->ct_scsi_status);
		ISP_IOXGET_8(isp, &ctsrc->ct_scsi_status, ctdst->ct_status);
		ISP_IOXGET_8(isp, &ctsrc->ct_tag_val, ctdst->ct_tag_type);
		ISP_IOXGET_8(isp, &ctsrc->ct_tag_type, ctdst->ct_tag_val);
	} else {
		ISP_IOXGET_8(isp, &ctsrc->ct_lun, ctdst->ct_lun);
		ISP_IOXGET_8(isp, &ctsrc->ct_iid, ctdst->ct_iid);
		ISP_IOXGET_8(isp, &ctsrc->ct_reserved2, ctdst->ct_reserved2);
		ISP_IOXGET_8(isp, &ctsrc->ct_tgt, ctdst->ct_tgt);
		ISP_IOXGET_8(isp, &ctsrc->ct_status, ctdst->ct_status);
		ISP_IOXGET_8(isp, &ctsrc->ct_scsi_status,
		    ctdst->ct_scsi_status);
		ISP_IOXGET_8(isp, &ctsrc->ct_tag_val, ctdst->ct_tag_val);
		ISP_IOXGET_8(isp, &ctsrc->ct_tag_type, ctdst->ct_tag_type);
	}
	ISP_IOXGET_32(isp, &ctsrc->ct_flags, ctdst->ct_flags);
	ISP_IOXGET_32(isp, &ctsrc->ct_xfrlen, ctdst->ct_xfrlen);
	ISP_IOXGET_32(isp, &ctsrc->ct_resid, ctdst->ct_resid);
	ISP_IOXGET_16(isp, &ctsrc->ct_timeout, ctdst->ct_timeout);
	ISP_IOXGET_16(isp, &ctsrc->ct_seg_count, ctdst->ct_seg_count);
	for (i = 0; i < ISP_RQDSEG; i++) {
		ISP_IOXGET_32(isp,
		    &ctsrc->ct_dataseg[i].ds_base,
		    ctdst->ct_dataseg[i].ds_base);
		ISP_IOXGET_32(isp,
		    &ctsrc->ct_dataseg[i].ds_count,
		    ctdst->ct_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_ctio2(struct ispsoftc *isp, ct2_entry_t *ctsrc, ct2_entry_t *ctdst)
{
	int i;
	isp_copy_out_hdr(isp, &ctsrc->ct_header, &ctdst->ct_header);
	ISP_IOXPUT_16(isp, ctsrc->ct_reserved, &ctdst->ct_reserved);
	ISP_IOXPUT_16(isp, ctsrc->ct_fwhandle, &ctdst->ct_fwhandle);
	ISP_IOXPUT_8(isp, ctsrc->ct_lun, &ctdst->ct_lun);
	ISP_IOXPUT_8(isp, ctsrc->ct_iid, &ctdst->ct_iid);
	ISP_IOXPUT_16(isp, ctsrc->ct_rxid, &ctdst->ct_rxid);
	ISP_IOXPUT_16(isp, ctsrc->ct_flags, &ctdst->ct_flags);
	ISP_IOXPUT_16(isp, ctsrc->ct_timeout, &ctdst->ct_timeout);
	ISP_IOXPUT_16(isp, ctsrc->ct_seg_count, &ctdst->ct_seg_count);
	ISP_IOXPUT_32(isp, ctsrc->ct_resid, &ctdst->ct_resid);
	ISP_IOXPUT_32(isp, ctsrc->ct_reloff, &ctdst->ct_reloff);
	if ((ctsrc->ct_flags & CT2_FLAG_MMASK) == CT2_FLAG_MODE0) {
		ISP_IOXPUT_32(isp, ctsrc->rsp.m0._reserved,
		    &ctdst->rsp.m0._reserved);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m0._reserved2,
		    &ctdst->rsp.m0._reserved2);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m0.ct_scsi_status,
		    &ctdst->rsp.m0.ct_scsi_status);
		ISP_IOXPUT_32(isp, ctsrc->rsp.m0.ct_xfrlen,
		    &ctdst->rsp.m0.ct_xfrlen);
		if (ctsrc->ct_header.rqs_entry_type == RQSTYPE_CTIO2) {
			for (i = 0; i < ISP_RQDSEG_T2; i++) {
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg[i].ds_base,
				    &ctdst->rsp.m0.ct_dataseg[i].ds_base);
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg[i].ds_count,
				    &ctdst->rsp.m0.ct_dataseg[i].ds_count);
			}
		} else if (ctsrc->ct_header.rqs_entry_type == RQSTYPE_CTIO3) {
			for (i = 0; i < ISP_RQDSEG_T3; i++) {
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg64[i].ds_base,
				    &ctdst->rsp.m0.ct_dataseg64[i].ds_base);
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg64[i].ds_basehi,
				    &ctdst->rsp.m0.ct_dataseg64[i].ds_basehi);
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg64[i].ds_count,
				    &ctdst->rsp.m0.ct_dataseg64[i].ds_count);
			}
		} else if (ctsrc->ct_header.rqs_entry_type == RQSTYPE_CTIO4) {
			ISP_IOXPUT_16(isp, ctsrc->rsp.m0.ct_dslist.ds_type,
			    &ctdst->rsp.m0.ct_dslist.ds_type);
			ISP_IOXPUT_32(isp, ctsrc->rsp.m0.ct_dslist.ds_segment,
			    &ctdst->rsp.m0.ct_dslist.ds_segment);
			ISP_IOXPUT_32(isp, ctsrc->rsp.m0.ct_dslist.ds_base,
			    &ctdst->rsp.m0.ct_dslist.ds_base);
		}
	} else if ((ctsrc->ct_flags & CT2_FLAG_MMASK) == CT2_FLAG_MODE1) {
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1._reserved,
		    &ctdst->rsp.m1._reserved);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1._reserved2,
		    &ctdst->rsp.m1._reserved2);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1.ct_senselen,
		    &ctdst->rsp.m1.ct_senselen);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1.ct_scsi_status,
		    &ctdst->rsp.m1.ct_scsi_status);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1.ct_resplen,
		    &ctdst->rsp.m1.ct_resplen);
		for (i = 0; i < MAXRESPLEN; i++) {
			ISP_IOXPUT_8(isp, ctsrc->rsp.m1.ct_resp[i],
			    &ctdst->rsp.m1.ct_resp[i]);
		}
	} else {
		ISP_IOXPUT_32(isp, ctsrc->rsp.m2._reserved,
		    &ctdst->rsp.m2._reserved);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m2._reserved2,
		    &ctdst->rsp.m2._reserved2);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m2._reserved3,
		    &ctdst->rsp.m2._reserved3);
		ISP_IOXPUT_32(isp, ctsrc->rsp.m2.ct_datalen,
		    &ctdst->rsp.m2.ct_datalen);
		ISP_IOXPUT_32(isp, ctsrc->rsp.m2.ct_fcp_rsp_iudata.ds_base,
		    &ctdst->rsp.m2.ct_fcp_rsp_iudata.ds_base);
		ISP_IOXPUT_32(isp, ctsrc->rsp.m2.ct_fcp_rsp_iudata.ds_count,
		    &ctdst->rsp.m2.ct_fcp_rsp_iudata.ds_count);
	}
}

static INLINE void
isp_get_ctio2(struct ispsoftc *isp, ct2_entry_t *ctsrc, ct2_entry_t *ctdst)
{
	int i;
	isp_copy_in_hdr(isp, &ctsrc->ct_header, &ctdst->ct_header);
	ISP_IOXGET_16(isp, &ctsrc->ct_reserved, ctdst->ct_reserved);
	ISP_IOXGET_16(isp, &ctsrc->ct_fwhandle, ctdst->ct_fwhandle);
	ISP_IOXGET_8(isp, &ctsrc->ct_lun, ctdst->ct_lun);
	ISP_IOXGET_8(isp, &ctsrc->ct_iid, ctdst->ct_iid);
	ISP_IOXGET_16(isp, &ctsrc->ct_rxid, ctdst->ct_rxid);
	ISP_IOXGET_16(isp, &ctsrc->ct_flags, ctdst->ct_flags);
	ISP_IOXGET_16(isp, &ctsrc->ct_status, ctdst->ct_status);
	ISP_IOXGET_16(isp, &ctsrc->ct_timeout, ctdst->ct_timeout);
	ISP_IOXGET_16(isp, &ctsrc->ct_seg_count, ctdst->ct_seg_count);
	ISP_IOXGET_32(isp, &ctsrc->ct_reloff, ctdst->ct_reloff);
	ISP_IOXGET_32(isp, &ctsrc->ct_resid, ctdst->ct_resid);
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_32(isp, &ctsrc->rsp.fw._reserved[i],
		    ctdst->rsp.fw._reserved[i]);
	}
	ISP_IOXGET_16(isp, &ctsrc->rsp.fw.ct_scsi_status,
	    ctdst->rsp.fw.ct_scsi_status);
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXGET_8(isp, &ctsrc->rsp.fw.ct_sense[i],
		    ctdst->rsp.fw.ct_sense[i]);
	}
}

static INLINE void
isp_put_enable_lun(struct ispsoftc *isp, lun_entry_t *lesrc, lun_entry_t *ledst)
{
	int i;
	isp_copy_out_hdr(isp, &lesrc->le_header, &ledst->le_header);
	ISP_IOXPUT_32(isp, lesrc->le_reserved, &ledst->le_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, lesrc->le_lun, &ledst->le_rsvd);
		ISP_IOXPUT_8(isp, lesrc->le_rsvd, &ledst->le_lun);
		ISP_IOXPUT_8(isp, lesrc->le_ops, &ledst->le_tgt);
		ISP_IOXPUT_8(isp, lesrc->le_tgt, &ledst->le_ops);
		ISP_IOXPUT_8(isp, lesrc->le_status, &ledst->le_reserved2);
		ISP_IOXPUT_8(isp, lesrc->le_reserved2, &ledst->le_status);
		ISP_IOXPUT_8(isp, lesrc->le_cmd_count, &ledst->le_in_count);
		ISP_IOXPUT_8(isp, lesrc->le_in_count, &ledst->le_cmd_count);
		ISP_IOXPUT_8(isp, lesrc->le_cdb6len, &ledst->le_cdb7len);
		ISP_IOXPUT_8(isp, lesrc->le_cdb7len, &ledst->le_cdb6len);
	} else {
		ISP_IOXPUT_8(isp, lesrc->le_lun, &ledst->le_lun);
		ISP_IOXPUT_8(isp, lesrc->le_rsvd, &ledst->le_rsvd);
		ISP_IOXPUT_8(isp, lesrc->le_ops, &ledst->le_ops);
		ISP_IOXPUT_8(isp, lesrc->le_tgt, &ledst->le_tgt);
		ISP_IOXPUT_8(isp, lesrc->le_status, &ledst->le_status);
		ISP_IOXPUT_8(isp, lesrc->le_reserved2, &ledst->le_reserved2);
		ISP_IOXPUT_8(isp, lesrc->le_cmd_count, &ledst->le_cmd_count);
		ISP_IOXPUT_8(isp, lesrc->le_in_count, &ledst->le_in_count);
		ISP_IOXPUT_8(isp, lesrc->le_cdb6len, &ledst->le_cdb6len);
		ISP_IOXPUT_8(isp, lesrc->le_cdb7len, &ledst->le_cdb7len);
	}
	ISP_IOXPUT_32(isp, lesrc->le_flags, &ledst->le_flags);
	ISP_IOXPUT_16(isp, lesrc->le_timeout, &ledst->le_timeout);
	for (i = 0; i < 20; i++) {
		ISP_IOXPUT_8(isp, lesrc->le_reserved3[i],
		    &ledst->le_reserved3[i]);
	}
}

static INLINE void
isp_get_enable_lun(struct ispsoftc *isp, lun_entry_t *lesrc, lun_entry_t *ledst)
{
	int i;
	isp_copy_in_hdr(isp, &lesrc->le_header, &ledst->le_header);
	ISP_IOXGET_32(isp, &lesrc->le_reserved, ledst->le_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &lesrc->le_lun, ledst->le_rsvd);
		ISP_IOXGET_8(isp, &lesrc->le_rsvd, ledst->le_lun);
		ISP_IOXGET_8(isp, &lesrc->le_ops, ledst->le_tgt);
		ISP_IOXGET_8(isp, &lesrc->le_tgt, ledst->le_ops);
		ISP_IOXGET_8(isp, &lesrc->le_status, ledst->le_reserved2);
		ISP_IOXGET_8(isp, &lesrc->le_reserved2, ledst->le_status);
		ISP_IOXGET_8(isp, &lesrc->le_cmd_count, ledst->le_in_count);
		ISP_IOXGET_8(isp, &lesrc->le_in_count, ledst->le_cmd_count);
		ISP_IOXGET_8(isp, &lesrc->le_cdb6len, ledst->le_cdb7len);
		ISP_IOXGET_8(isp, &lesrc->le_cdb7len, ledst->le_cdb6len);
	} else {
		ISP_IOXGET_8(isp, &lesrc->le_lun, ledst->le_lun);
		ISP_IOXGET_8(isp, &lesrc->le_rsvd, ledst->le_rsvd);
		ISP_IOXGET_8(isp, &lesrc->le_ops, ledst->le_ops);
		ISP_IOXGET_8(isp, &lesrc->le_tgt, ledst->le_tgt);
		ISP_IOXGET_8(isp, &lesrc->le_status, ledst->le_status);
		ISP_IOXGET_8(isp, &lesrc->le_reserved2, ledst->le_reserved2);
		ISP_IOXGET_8(isp, &lesrc->le_cmd_count, ledst->le_cmd_count);
		ISP_IOXGET_8(isp, &lesrc->le_in_count, ledst->le_in_count);
		ISP_IOXGET_8(isp, &lesrc->le_cdb6len, ledst->le_cdb6len);
		ISP_IOXGET_8(isp, &lesrc->le_cdb7len, ledst->le_cdb7len);
	}
	ISP_IOXGET_32(isp, &lesrc->le_flags, ledst->le_flags);
	ISP_IOXGET_16(isp, &lesrc->le_timeout, ledst->le_timeout);
	for (i = 0; i < 20; i++) {
		ISP_IOXGET_8(isp, &lesrc->le_reserved3[i],
		    ledst->le_reserved3[i]);
	}
}

static INLINE void
isp_put_notify(struct ispsoftc *isp, in_entry_t *insrc, in_entry_t *indst)
{
	int i;
	isp_copy_out_hdr(isp, &insrc->in_header, &indst->in_header);
	ISP_IOXPUT_32(isp, insrc->in_reserved, &indst->in_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, insrc->in_lun, &indst->in_iid);
		ISP_IOXPUT_8(isp, insrc->in_iid, &indst->in_lun);
		ISP_IOXPUT_8(isp, insrc->in_reserved2, &indst->in_tgt);
		ISP_IOXPUT_8(isp, insrc->in_tgt, &indst->in_reserved2);
		ISP_IOXPUT_8(isp, insrc->in_status, &indst->in_rsvd2);
		ISP_IOXPUT_8(isp, insrc->in_rsvd2, &indst->in_status);
		ISP_IOXPUT_8(isp, insrc->in_tag_val, &indst->in_tag_type);
		ISP_IOXPUT_8(isp, insrc->in_tag_type, &indst->in_tag_val);
	} else {
		ISP_IOXPUT_8(isp, insrc->in_lun, &indst->in_lun);
		ISP_IOXPUT_8(isp, insrc->in_iid, &indst->in_iid);
		ISP_IOXPUT_8(isp, insrc->in_reserved2, &indst->in_reserved2);
		ISP_IOXPUT_8(isp, insrc->in_tgt, &indst->in_tgt);
		ISP_IOXPUT_8(isp, insrc->in_status, &indst->in_status);
		ISP_IOXPUT_8(isp, insrc->in_rsvd2, &indst->in_rsvd2);
		ISP_IOXPUT_8(isp, insrc->in_tag_val, &indst->in_tag_val);
		ISP_IOXPUT_8(isp, insrc->in_tag_type, &indst->in_tag_type);
	}
	ISP_IOXPUT_32(isp, insrc->in_flags, &indst->in_flags);
	ISP_IOXPUT_16(isp, insrc->in_seqid, &indst->in_seqid);
	for (i = 0; i < IN_MSGLEN; i++) {
		ISP_IOXPUT_8(isp, insrc->in_msg[i], &indst->in_msg[i]);
	}
	for (i = 0; i < IN_RSVDLEN; i++) {
		ISP_IOXPUT_8(isp, insrc->in_reserved3[i],
		    &indst->in_reserved3[i]);
	}
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXPUT_8(isp, insrc->in_sense[i],
		    &indst->in_sense[i]);
	}
}

static INLINE void
isp_get_notify(struct ispsoftc *isp, in_entry_t *insrc, in_entry_t *indst)
{
	int i;
	isp_copy_in_hdr(isp, &insrc->in_header, &indst->in_header);
	ISP_IOXGET_32(isp, &insrc->in_reserved, indst->in_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &insrc->in_lun, indst->in_iid);
		ISP_IOXGET_8(isp, &insrc->in_iid, indst->in_lun);
		ISP_IOXGET_8(isp, &insrc->in_reserved2, indst->in_tgt);
		ISP_IOXGET_8(isp, &insrc->in_tgt, indst->in_reserved2);
		ISP_IOXGET_8(isp, &insrc->in_status, indst->in_rsvd2);
		ISP_IOXGET_8(isp, &insrc->in_rsvd2, indst->in_status);
		ISP_IOXGET_8(isp, &insrc->in_tag_val, indst->in_tag_type);
		ISP_IOXGET_8(isp, &insrc->in_tag_type, indst->in_tag_val);
	} else {
		ISP_IOXGET_8(isp, &insrc->in_lun, indst->in_lun);
		ISP_IOXGET_8(isp, &insrc->in_iid, indst->in_iid);
		ISP_IOXGET_8(isp, &insrc->in_reserved2, indst->in_reserved2);
		ISP_IOXGET_8(isp, &insrc->in_tgt, indst->in_tgt);
		ISP_IOXGET_8(isp, &insrc->in_status, indst->in_status);
		ISP_IOXGET_8(isp, &insrc->in_rsvd2, indst->in_rsvd2);
		ISP_IOXGET_8(isp, &insrc->in_tag_val, indst->in_tag_val);
		ISP_IOXGET_8(isp, &insrc->in_tag_type, indst->in_tag_type);
	}
	ISP_IOXGET_32(isp, &insrc->in_flags, indst->in_flags);
	ISP_IOXGET_16(isp, &insrc->in_seqid, indst->in_seqid);
	for (i = 0; i < IN_MSGLEN; i++) {
		ISP_IOXGET_8(isp, &insrc->in_msg[i], indst->in_msg[i]);
	}
	for (i = 0; i < IN_RSVDLEN; i++) {
		ISP_IOXGET_8(isp, &insrc->in_reserved3[i],
		    indst->in_reserved3[i]);
	}
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXGET_8(isp, &insrc->in_sense[i],
		    indst->in_sense[i]);
	}
}

static INLINE void
isp_put_notify_fc(struct ispsoftc *isp, in_fcentry_t *insrc,
    in_fcentry_t *indst)
{
	isp_copy_out_hdr(isp, &insrc->in_header, &indst->in_header);
	ISP_IOXPUT_32(isp, insrc->in_reserved, &indst->in_reserved);
	ISP_IOXPUT_8(isp, insrc->in_lun, &indst->in_lun);
	ISP_IOXPUT_8(isp, insrc->in_iid, &indst->in_iid);
	ISP_IOXPUT_16(isp, insrc->in_scclun, &indst->in_scclun);
	ISP_IOXPUT_32(isp, insrc->in_reserved2, &indst->in_reserved2);
	ISP_IOXPUT_16(isp, insrc->in_status, &indst->in_status);
	ISP_IOXPUT_16(isp, insrc->in_task_flags, &indst->in_task_flags);
	ISP_IOXPUT_16(isp, insrc->in_seqid, &indst->in_seqid);
}

static INLINE void
isp_get_notify_fc(struct ispsoftc *isp, in_fcentry_t *insrc,
    in_fcentry_t *indst)
{
	isp_copy_in_hdr(isp, &insrc->in_header, &indst->in_header);
	ISP_IOXGET_32(isp, &insrc->in_reserved, indst->in_reserved);
	ISP_IOXGET_8(isp, &insrc->in_lun, indst->in_lun);
	ISP_IOXGET_8(isp, &insrc->in_iid, indst->in_iid);
	ISP_IOXGET_16(isp, &insrc->in_scclun, indst->in_scclun);
	ISP_IOXGET_32(isp, &insrc->in_reserved2, indst->in_reserved2);
	ISP_IOXGET_16(isp, &insrc->in_status, indst->in_status);
	ISP_IOXGET_16(isp, &insrc->in_task_flags, indst->in_task_flags);
	ISP_IOXGET_16(isp, &insrc->in_seqid, indst->in_seqid);
}

static INLINE void
isp_put_notify_ack(struct ispsoftc *isp, na_entry_t *nasrc,  na_entry_t *nadst)
{
	int i;
	isp_copy_out_hdr(isp, &nasrc->na_header, &nadst->na_header);
	ISP_IOXPUT_32(isp, nasrc->na_reserved, &nadst->na_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, nasrc->na_lun, &nadst->na_iid);
		ISP_IOXPUT_8(isp, nasrc->na_iid, &nadst->na_lun);
		ISP_IOXPUT_8(isp, nasrc->na_status, &nadst->na_event);
		ISP_IOXPUT_8(isp, nasrc->na_event, &nadst->na_status);
	} else {
		ISP_IOXPUT_8(isp, nasrc->na_lun, &nadst->na_lun);
		ISP_IOXPUT_8(isp, nasrc->na_iid, &nadst->na_iid);
		ISP_IOXPUT_8(isp, nasrc->na_status, &nadst->na_status);
		ISP_IOXPUT_8(isp, nasrc->na_event, &nadst->na_event);
	}
	ISP_IOXPUT_32(isp, nasrc->na_flags, &nadst->na_flags);
	for (i = 0; i < NA_RSVDLEN; i++) {
		ISP_IOXPUT_16(isp, nasrc->na_reserved3[i],
		    &nadst->na_reserved3[i]);
	}
}

static INLINE void
isp_get_notify_ack(struct ispsoftc *isp, na_entry_t *nasrc, na_entry_t *nadst)
{
	int i;
	isp_copy_in_hdr(isp, &nasrc->na_header, &nadst->na_header);
	ISP_IOXGET_32(isp, &nasrc->na_reserved, nadst->na_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &nasrc->na_lun, nadst->na_iid);
		ISP_IOXGET_8(isp, &nasrc->na_iid, nadst->na_lun);
		ISP_IOXGET_8(isp, &nasrc->na_status, nadst->na_event);
		ISP_IOXGET_8(isp, &nasrc->na_event, nadst->na_status);
	} else {
		ISP_IOXGET_8(isp, &nasrc->na_lun, nadst->na_lun);
		ISP_IOXGET_8(isp, &nasrc->na_iid, nadst->na_iid);
		ISP_IOXGET_8(isp, &nasrc->na_status, nadst->na_status);
		ISP_IOXGET_8(isp, &nasrc->na_event, nadst->na_event);
	}
	ISP_IOXGET_32(isp, &nasrc->na_flags, nadst->na_flags);
	for (i = 0; i < NA_RSVDLEN; i++) {
		ISP_IOXGET_16(isp, &nasrc->na_reserved3[i],
		    nadst->na_reserved3[i]);
	}
}

static INLINE void
isp_put_notify_ack_fc(struct ispsoftc *isp, na_fcentry_t *nasrc,
    na_fcentry_t *nadst)
{
	int i;
	isp_copy_out_hdr(isp, &nasrc->na_header, &nadst->na_header);
	ISP_IOXPUT_32(isp, nasrc->na_reserved, &nadst->na_reserved);
	ISP_IOXPUT_8(isp, nasrc->na_lun, &nadst->na_lun);
	ISP_IOXPUT_8(isp, nasrc->na_iid, &nadst->na_iid);
	ISP_IOXPUT_16(isp, nasrc->na_scclun, &nadst->na_scclun);
	ISP_IOXPUT_16(isp, nasrc->na_flags, &nadst->na_flags);
	ISP_IOXPUT_16(isp, nasrc->na_reserved2, &nadst->na_reserved2);
	ISP_IOXPUT_16(isp, nasrc->na_status, &nadst->na_status);
	ISP_IOXPUT_16(isp, nasrc->na_task_flags, &nadst->na_task_flags);
	ISP_IOXPUT_16(isp, nasrc->na_seqid, &nadst->na_seqid);
	for (i = 0; i < NA2_RSVDLEN; i++) {
		ISP_IOXPUT_16(isp, nasrc->na_reserved3[i],
		    &nadst->na_reserved3[i]);
	}
}

static INLINE void
isp_get_notify_ack_fc(struct ispsoftc *isp, na_fcentry_t *nasrc,
    na_fcentry_t *nadst)
{
	int i;
	isp_copy_in_hdr(isp, &nasrc->na_header, &nadst->na_header);
	ISP_IOXGET_32(isp, &nasrc->na_reserved, nadst->na_reserved);
	ISP_IOXGET_8(isp, &nasrc->na_lun, nadst->na_lun);
	ISP_IOXGET_8(isp, &nasrc->na_iid, nadst->na_iid);
	ISP_IOXGET_16(isp, &nasrc->na_scclun, nadst->na_scclun);
	ISP_IOXGET_16(isp, &nasrc->na_flags, nadst->na_flags);
	ISP_IOXGET_16(isp, &nasrc->na_reserved2, nadst->na_reserved2);
	ISP_IOXGET_16(isp, &nasrc->na_status, nadst->na_status);
	ISP_IOXGET_16(isp, &nasrc->na_task_flags, nadst->na_task_flags);
	ISP_IOXGET_16(isp, &nasrc->na_seqid, nadst->na_seqid);
	for (i = 0; i < NA2_RSVDLEN; i++) {
		ISP_IOXGET_16(isp, &nasrc->na_reserved3[i],
		    nadst->na_reserved3[i]);
	}
}
#endif
#endif	/* _ISP_INLINE_H */
@


1.15
log
@Start updating isp. Just new defines, comments, whitespace, anything that
doesn't change the .o.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.14 2008/01/21 20:00:33 sobrado Exp $ */
@


1.14
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.13 2004/08/02 19:55:45 art Exp $ */
d457 1
a457 1
	ISP_IOXPUT_16(isp, tqsrc->_res2, &tqdst->_res2);
d482 1
a482 1
	ISP_IOXPUT_16(isp, tqsrc->_res2, &tqdst->_res2);
d608 1
a608 1
	ISP_SWAP8(Is->icb_version, Is->_reserved0);
d610 1
a610 1
	ISP_IOXPUT_8(isp, Is->_reserved0, &Id->_reserved0);
d755 1
a755 1
	ISP_IOXPUT_16(isp, src->snscb_res0, &dst->snscb_res0);
d761 1
a761 1
	ISP_IOXPUT_16(isp, src->snscb_res1, &dst->snscb_res1);
d764 1
a764 1
	ISP_IOXPUT_32(isp, src->snscb_res3, &dst->snscb_res3);
d774 1
a774 1
	ISP_IOXPUT_16(isp, src->snscb_res0, &dst->snscb_res0);
d780 1
a780 1
	ISP_IOXPUT_16(isp, src->snscb_res1, &dst->snscb_res1);
d782 2
a783 2
	ISP_IOXPUT_16(isp, src->snscb_res2, &dst->snscb_res2);
	ISP_IOXPUT_32(isp, src->snscb_res3, &dst->snscb_res3);
@


1.13
log
@Use some horrible macros to uninline a few functions that are expensive
when inlined and shave a few k from the kernel size.

The goal here was not to make the nicest diff possible, but the smallest.

deraadt@@ drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.12 2003/03/03 18:33:49 mjacob Exp $ */
d3 1
a3 1
 * Qlogic Host Adapter Inline Functions
@


1.12
log
@For type 3 requests, the count is ISP_RQDSEG_T3, not ISP_RQDSEG_T2, that we need
to set up.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.11 2002/05/17 01:32:04 mjacob Exp $ */
d35 5
d122 1
a122 1
static INLINE int
d125 2
a126 1
static INLINE int
d145 1
d258 2
a259 2
static INLINE void isp_copy_out_hdr(struct ispsoftc *, isphdr_t *, isphdr_t *);
static INLINE void isp_copy_in_hdr(struct ispsoftc *, isphdr_t *, isphdr_t *);
d284 1
a284 1
static INLINE void
d291 1
a291 1
static INLINE void
d356 3
a358 1
static INLINE void
d382 1
a382 1
static INLINE void
d405 1
d708 2
a709 1
static INLINE void
d729 1
d768 2
a769 1
static INLINE void
d786 1
@


1.11
log
@Various new inlines for RIO entries as well as various FC-GS-2 related
structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.10 2001/12/14 00:20:55 mjacob Exp $ */
d479 1
a479 1
	for (i = 0; i < ISP_RQDSEG_T2; i++) {
@


1.10
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.9 2001/09/01 07:16:40 mjacob Exp $ */
d272 2
d278 2
d282 6
d290 11
a300 1
isp_get_gan_response(struct ispsoftc *, sns_ganrsp_t *, sns_ganrsp_t *);
d400 1
a400 1
	uint8_t type;
d579 16
d694 29
d739 40
d783 1
a783 3
	for (i = 0; i < 16; i++) {
		ISP_IOXGET_8(isp, &src->snscb_cthdr[i], dst->snscb_cthdr[i]);
	}
d799 24
a822 1
isp_get_gan_response(struct ispsoftc *isp, sns_ganrsp_t *src, sns_ganrsp_t *dst)
d825 14
a838 2
	for (i = 0; i < 16; i++) {
		ISP_IOXGET_8(isp, &src->snscb_cthdr[i], dst->snscb_cthdr[i]);
d840 8
d987 5
a991 2
	for (i = 0; i < 10; i++) {
		ISP_IOXPUT_8(isp, atsrc->at_reserved2[i],
d1017 5
a1021 2
	for (i = 0; i < 10; i++) {
		ISP_IOXGET_8(isp, &atsrc->at_reserved2[i],
d1123 1
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.10 2001/12/14 00:20:55 mjacob Exp $ */
a271 2
isp_get_rio2(struct ispsoftc *, isp_rio2_t *, isp_rio2_t *);
static INLINE void
a275 2
isp_get_ct_hdr(struct ispsoftc *isp, ct_hdr_t *, ct_hdr_t *);
static INLINE void
a277 6
isp_put_gid_ft_request(struct ispsoftc *, sns_gid_ft_req_t *,
    sns_gid_ft_req_t *);
static INLINE void
isp_put_gxn_id_request(struct ispsoftc *, sns_gxn_id_req_t *,
    sns_gxn_id_req_t *);
static INLINE void
d280 1
a280 11
isp_get_gid_ft_response(struct ispsoftc *, sns_gid_ft_rsp_t *,
    sns_gid_ft_rsp_t *, int);
static INLINE void
isp_get_gxn_id_response(struct ispsoftc *, sns_gxn_id_rsp_t *,
    sns_gxn_id_rsp_t *);
static INLINE void
isp_get_gff_id_response(struct ispsoftc *, sns_gff_id_rsp_t *,
    sns_gff_id_rsp_t *);
static INLINE void
isp_get_ga_nxt_response(struct ispsoftc *, sns_ga_nxt_rsp_t *,
    sns_ga_nxt_rsp_t *);
d380 1
a380 1
	u_int8_t type;
a558 16
isp_get_rio2(struct ispsoftc *isp, isp_rio2_t *r2src, isp_rio2_t *r2dst)
{
	int i;
	isp_copy_in_hdr(isp, &r2src->req_header, &r2dst->req_header);
	if (r2dst->req_header.rqs_seqno > 30)
		r2dst->req_header.rqs_seqno = 30;
	for (i = 0; i < r2dst->req_header.rqs_seqno; i++) {
		ISP_IOXGET_16(isp, &r2src->req_handles[i],
		    r2dst->req_handles[i]);
	}
	while (i < 30) {
		r2dst->req_handles[i++] = 0;
	}
}

static INLINE void
a657 29

/*
 * CT_HDR canonicalization- only needed for SNS responses
 */
static INLINE void
isp_get_ct_hdr(struct ispsoftc *isp, ct_hdr_t *src, ct_hdr_t *dst)
{
	ISP_IOXGET_8(isp, &src->ct_revision, dst->ct_revision);
	ISP_IOXGET_8(isp, &src->ct_portid[0], dst->ct_portid[0]);
	ISP_IOXGET_8(isp, &src->ct_portid[1], dst->ct_portid[1]);
	ISP_IOXGET_8(isp, &src->ct_portid[2], dst->ct_portid[2]);
	ISP_IOXGET_8(isp, &src->ct_fcs_type, dst->ct_fcs_type);
	ISP_IOXGET_8(isp, &src->ct_fcs_subtype, dst->ct_fcs_subtype);
	ISP_IOXGET_8(isp, &src->ct_options, dst->ct_options);
	ISP_IOXGET_8(isp, &src->ct_res0, dst->ct_res0);
	ISP_IOXGET_16(isp, &src->ct_response, dst->ct_response);
	dst->ct_response = (dst->ct_response << 8) | (dst->ct_response >> 8);
	ISP_IOXGET_16(isp, &src->ct_resid, dst->ct_resid);
	dst->ct_resid = (dst->ct_resid << 8) | (dst->ct_resid >> 8);
	ISP_IOXGET_8(isp, &src->ct_res1, dst->ct_res1);
	ISP_IOXGET_8(isp, &src->ct_reason, dst->ct_reason);
	ISP_IOXGET_8(isp, &src->ct_explanation, dst->ct_explanation);
	ISP_IOXGET_8(isp, &src->ct_vunique, dst->ct_vunique);
}

/*
 * Generic SNS request - not particularly useful since the per-command data
 * isn't always 16 bit words.
 */
a673 40
isp_put_gid_ft_request(struct ispsoftc *isp, sns_gid_ft_req_t *src,
    sns_gid_ft_req_t *dst)
{
	ISP_IOXPUT_16(isp, src->snscb_rblen, &dst->snscb_rblen);
	ISP_IOXPUT_16(isp, src->snscb_res0, &dst->snscb_res0);
	ISP_IOXPUT_16(isp, src->snscb_addr[0], &dst->snscb_addr[0]);
	ISP_IOXPUT_16(isp, src->snscb_addr[1], &dst->snscb_addr[1]);
	ISP_IOXPUT_16(isp, src->snscb_addr[2], &dst->snscb_addr[2]);
	ISP_IOXPUT_16(isp, src->snscb_addr[3], &dst->snscb_addr[3]);
	ISP_IOXPUT_16(isp, src->snscb_sblen, &dst->snscb_sblen);
	ISP_IOXPUT_16(isp, src->snscb_res1, &dst->snscb_res1);
	ISP_IOXPUT_16(isp, src->snscb_cmd, &dst->snscb_cmd);
	ISP_IOXPUT_16(isp, src->snscb_mword_div_2, &dst->snscb_mword_div_2);
	ISP_IOXPUT_32(isp, src->snscb_res3, &dst->snscb_res3);
	ISP_IOXPUT_32(isp, src->snscb_fc4_type, &dst->snscb_fc4_type);
}

static INLINE void
isp_put_gxn_id_request(struct ispsoftc *isp, sns_gxn_id_req_t *src,
    sns_gxn_id_req_t *dst)
{
	ISP_IOXPUT_16(isp, src->snscb_rblen, &dst->snscb_rblen);
	ISP_IOXPUT_16(isp, src->snscb_res0, &dst->snscb_res0);
	ISP_IOXPUT_16(isp, src->snscb_addr[0], &dst->snscb_addr[0]);
	ISP_IOXPUT_16(isp, src->snscb_addr[1], &dst->snscb_addr[1]);
	ISP_IOXPUT_16(isp, src->snscb_addr[2], &dst->snscb_addr[2]);
	ISP_IOXPUT_16(isp, src->snscb_addr[3], &dst->snscb_addr[3]);
	ISP_IOXPUT_16(isp, src->snscb_sblen, &dst->snscb_sblen);
	ISP_IOXPUT_16(isp, src->snscb_res1, &dst->snscb_res1);
	ISP_IOXPUT_16(isp, src->snscb_cmd, &dst->snscb_cmd);
	ISP_IOXPUT_16(isp, src->snscb_res2, &dst->snscb_res2);
	ISP_IOXPUT_32(isp, src->snscb_res3, &dst->snscb_res3);
	ISP_IOXPUT_32(isp, src->snscb_portid, &dst->snscb_portid);
}

/*
 * Generic SNS response - not particularly useful since the per-command data
 * isn't always 16 bit words.
 */
static INLINE void
d678 3
a680 1
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
d696 1
a696 2
isp_get_gid_ft_response(struct ispsoftc *isp, sns_gid_ft_rsp_t *src,
    sns_gid_ft_rsp_t *dst, int nwords)
d699 2
a700 36
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	for (i = 0; i < nwords; i++) {
		int j;
		ISP_IOXGET_8(isp,
		    &src->snscb_ports[i].control,
		    dst->snscb_ports[i].control);
		for (j = 0; j < 3; j++) {
			ISP_IOXGET_8(isp,
			    &src->snscb_ports[i].portid[j],
			    dst->snscb_ports[i].portid[j]);
		}
		if (dst->snscb_ports[i].control & 0x80) {
			break;
		}
	}
}

static INLINE void
isp_get_gxn_id_response(struct ispsoftc *isp, sns_gxn_id_rsp_t *src,
    sns_gxn_id_rsp_t *dst)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	for (i = 0; i < 8; i++)
		ISP_IOXGET_8(isp, &src->snscb_wwn[i], dst->snscb_wwn[i]);
}

static INLINE void
isp_get_gff_id_response(struct ispsoftc *isp, sns_gff_id_rsp_t *src,
    sns_gff_id_rsp_t *dst)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	for (i = 0; i < 32; i++) {
		ISP_IOXGET_32(isp, &src->snscb_fc4_features[i],
		    dst->snscb_fc4_features[i]);
a701 8
}

static INLINE void
isp_get_ga_nxt_response(struct ispsoftc *isp, sns_ga_nxt_rsp_t *src,
    sns_ga_nxt_rsp_t *dst)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
d841 2
a842 5
	for (i = 0; i < 4; i++) {
		ISP_IOXPUT_16(isp, atsrc->at_wwpn[i], &atdst->at_wwpn[i]);
	}
	for (i = 0; i < 6; i++) {
		ISP_IOXPUT_16(isp, atsrc->at_reserved2[i],
d868 2
a869 5
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_16(isp, &atsrc->at_wwpn[i], atdst->at_wwpn[i]);
	}
	for (i = 0; i < 6; i++) {
		ISP_IOXGET_16(isp, &atsrc->at_reserved2[i],
a970 1
	ISP_IOXPUT_32(isp, ctsrc->ct_reloff, &ctdst->ct_reloff);
@


1.10.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d479 1
a479 1
	for (i = 0; i < ISP_RQDSEG_T3; i++) {
@


1.9
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.8 2001/04/04 22:07:19 mjacob Exp $ */
d239 1103
@


1.8
log
@Ansify source. Handles are now 16 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.7 2001/03/02 04:49:02 mjacob Exp $ */
d126 1
a126 1
	optr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);
@


1.7
log
@Fix isp_print_qentry to print all four lines- it's been broken for months.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.6 2001/02/12 23:45:33 mjacob Exp $ */
d5 1
a5 1
 * Copyright (c) 1999, 2000 by Matthew Jacob
d42 6
a47 17
static INLINE int
isp_save_xs __P((struct ispsoftc *, XS_T *, u_int32_t *));

static INLINE XS_T *
isp_find_xs __P((struct ispsoftc *, u_int32_t));

static INLINE u_int32_t
isp_find_handle __P((struct ispsoftc *, XS_T *));

static INLINE int
isp_handle_index __P((u_int32_t));

static INLINE void
isp_destroy_handle __P((struct ispsoftc *, u_int32_t));

static INLINE void
isp_remove_handle __P((struct ispsoftc *, XS_T *));
d50 1
a50 4
isp_save_xs(isp, xs, handlep)
	struct ispsoftc *isp;
	XS_T *xs;
	u_int32_t *handlep;
d74 1
a74 3
isp_find_xs(isp, handle)
	struct ispsoftc *isp;
	u_int32_t handle;
d76 1
a76 1
	if (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {
d83 2
a84 4
static INLINE u_int32_t
isp_find_handle(isp, xs)
	struct ispsoftc *isp;
	XS_T *xs;
d90 1
a90 1
				return ((u_int32_t) i+1);
d98 1
a98 2
isp_handle_index(handle)
	u_int32_t handle;
d104 1
a104 3
isp_destroy_handle(isp, handle)
	struct ispsoftc *isp;
	u_int32_t handle;
d106 1
a106 1
	if (handle > 0 && handle <= (u_int32_t) isp->isp_maxcmds) {
d112 1
a112 3
isp_remove_handle(isp, xs)
	struct ispsoftc *isp;
	XS_T *xs;
d118 1
a118 1
isp_getrqentry __P((struct ispsoftc *, u_int16_t *, u_int16_t *, void **));
d121 2
a122 5
isp_getrqentry(isp, iptrp, optrp, resultp)
	struct ispsoftc *isp;
	u_int16_t *iptrp;
	u_int16_t *optrp;
	void **resultp;
d140 1
a140 2
static INLINE void
isp_print_qentry __P((struct ispsoftc *, char *, int, void *));
d145 1
a145 5
isp_print_qentry(isp, msg, idx, arg)
	struct ispsoftc *isp;
	char *msg;
	int idx;
	void *arg;
d162 1
a162 2
static INLINE void
isp_print_bytes __P((struct ispsoftc *, char *, int, void *));
d165 1
a165 5
isp_print_bytes(isp, msg, amt, arg)
	struct ispsoftc *isp;
	char *msg;
	int amt;
	void *arg;
d204 1
a204 1
static INLINE int isp_fc_runstate __P((struct ispsoftc *, int));
d207 1
a207 3
isp_fc_runstate(isp, tval)
	struct ispsoftc *isp;
	int tval;
@


1.6
log
@Add isp_fc_runstate function- this function's purpose is to, in stages,
and depending on role, make sure link is up, scan the fabric (if we're
connected to a fabric), scan the local loop (if appropriate), merge
the results into the local port database then, check once again
to make sure we have f/w at FW_READY state and the the loopstate
is LOOP_READY.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.5 2000/10/16 01:01:59 mjacob Exp $ */
d182 1
d185 1
d189 1
a189 1
		STRNCAT(buf, "\n", TBA);
a190 1
	isp_prt(isp, ISP_LOGALL, "%s index %d:%s", msg, idx, buf);
@


1.5
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.4 2000/07/06 05:31:48 mjacob Exp $ */
d221 54
@


1.4
log
@Resync with FreeBSD/NetBSD. Salient features are that the mailbox command
routines are not necessarily polled now- this should cut down on some of
the spurious lost commands that have occurred. Also, we now watchdog each
command and make sure that command constipation doesn't occur (which it
has been documented to do on the QLA2100 cards).
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.3 2000/02/20 21:22:41 mjacob Exp $ */
d3 1
a3 1
 * Qlogic Inline Functions
d5 1
a5 2
 *---------------------------------------
 * Copyright (c) 1999 by Matthew Jacob
a8 1
 *---------------------------------------
d16 1
a16 4
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
a34 103
static INLINE void isp_prtstst __P((ispstatusreq_t *));
static INLINE char *isp2100_fw_statename __P((int));
static INLINE char *isp2100_pdb_statename __P((int));


static INLINE void
isp_prtstst(sp)
	ispstatusreq_t *sp;
{
	char buf[172];
	buf[0] = 0;
	STRNCAT(buf, "states=>", sizeof buf);
	if (sp->req_state_flags & RQSF_GOT_BUS) {
		STRNCAT(buf, " GOT_BUS", sizeof buf);
	}
	if (sp->req_state_flags & RQSF_GOT_TARGET) {
		STRNCAT(buf, " GOT_TGT", sizeof buf);
	}
	if (sp->req_state_flags & RQSF_SENT_CDB) {
		STRNCAT(buf, " SENT_CDB", sizeof buf);
	}
	if (sp->req_state_flags & RQSF_XFRD_DATA) {
		STRNCAT(buf, " XFRD_DATA", sizeof buf);
	}
	if (sp->req_state_flags & RQSF_GOT_STATUS) {
		STRNCAT(buf, " GOT_STS", sizeof buf);
	}
	if (sp->req_state_flags & RQSF_GOT_SENSE) {
		STRNCAT(buf, " GOT_SNS", sizeof buf);
	}
	if (sp->req_state_flags & RQSF_XFER_COMPLETE) {
		STRNCAT(buf, " XFR_CMPLT", sizeof buf);
	}
	STRNCAT(buf, "\nstatus=>", sizeof buf);
	if (sp->req_status_flags & RQSTF_DISCONNECT) {
		STRNCAT(buf, " Disconnect", sizeof buf);
	}
	if (sp->req_status_flags & RQSTF_SYNCHRONOUS) {
		STRNCAT(buf, " Sync_xfr", sizeof buf);
	}
	if (sp->req_status_flags & RQSTF_PARITY_ERROR) {
		STRNCAT(buf, " Parity", sizeof buf);
	}
	if (sp->req_status_flags & RQSTF_BUS_RESET) {
		STRNCAT(buf, " Bus_Reset", sizeof buf);
	}
	if (sp->req_status_flags & RQSTF_DEVICE_RESET) {
		STRNCAT(buf, " Device_Reset", sizeof buf);
	}
	if (sp->req_status_flags & RQSTF_ABORTED) {
		STRNCAT(buf, " Aborted", sizeof buf);
	}
	if (sp->req_status_flags & RQSTF_TIMEOUT) {
		STRNCAT(buf, " Timeout", sizeof buf);
	}
	if (sp->req_status_flags & RQSTF_NEGOTIATION) {
		STRNCAT(buf, " Negotiation", sizeof buf);
	}
	PRINTF(buf, "%s\n", buf);
}

static INLINE char *
isp2100_fw_statename(state)
	int state;
{
	static char buf[16];
	switch(state) {
	case FW_CONFIG_WAIT:	return "Config Wait";
	case FW_WAIT_AL_PA:	return "Waiting for AL_PA";
	case FW_WAIT_LOGIN:	return "Wait Login";
	case FW_READY:		return "Ready";
	case FW_LOSS_OF_SYNC:	return "Loss Of Sync";
	case FW_ERROR:		return "Error";
	case FW_REINIT:		return "Re-Init";
	case FW_NON_PART:	return "Nonparticipating";
	default:
		sprintf(buf, "0x%x", state);
		return buf;
	}
}

static INLINE char *isp2100_pdb_statename(int pdb_state)
{
	static char buf[16];
	switch(pdb_state) {
	case PDB_STATE_DISCOVERY:	return "Port Discovery";
	case PDB_STATE_WDISC_ACK:	return "Waiting Port Discovery ACK";
	case PDB_STATE_PLOGI:		return "Port Login";
	case PDB_STATE_PLOGI_ACK:	return "Wait Port Login ACK";
	case PDB_STATE_PRLI:		return "Process Login";
	case PDB_STATE_PRLI_ACK:	return "Wait Process Login ACK";
	case PDB_STATE_LOGGED_IN:	return "Logged In";
	case PDB_STATE_PORT_UNAVAIL:	return "Port Unavailable";
	case PDB_STATE_PRLO:		return "Process Logout";
	case PDB_STATE_PRLO_ACK:	return "Wait Process Logout ACK";
	case PDB_STATE_PLOGO:		return "Port Logout";
	case PDB_STATE_PLOG_ACK:	return "Wait Port Logout ACK";
	default:
		sprintf(buf, "0x%x", pdb_state);
		return buf;
	}
}

d43 1
a43 1
isp_save_xs __P((struct ispsoftc *, ISP_SCSI_XFER_T *, u_int32_t *));
d45 1
a45 1
static INLINE ISP_SCSI_XFER_T *
d49 1
a49 1
isp_find_handle __P((struct ispsoftc *, ISP_SCSI_XFER_T *));
d58 1
a58 1
isp_remove_handle __P((struct ispsoftc *, ISP_SCSI_XFER_T *));
d63 1
a63 1
	ISP_SCSI_XFER_T *xs;
d83 1
a83 1
	isp->isp_lasthdls = j;
d87 1
a87 1
static INLINE ISP_SCSI_XFER_T *
d102 1
a102 1
	ISP_SCSI_XFER_T *xs;
d135 1
a135 1
	ISP_SCSI_XFER_T *xs;
d155 1
a155 1
	iptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);
d169 2
d178 1
d181 3
a183 2
	PRINTF("%s %s index %d:\n", isp->isp_name, msg, idx);
	for (amt = i = 0; i < 4; i++) {
d185 32
a216 1
			PRINTF(" %02x", ptr[amt++] & 0xff);
d218 2
a219 1
		PRINTF("\n");
@


1.3
log
@Add 12160 (Ultra3) support. Add files and changes for target mode support.
Do some SNS fabric suppor tchanges. Roll revision levels. Tested on
GENERIC i386 && sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.2 1999/12/03 03:48:56 mjacob Exp $ */
d49 3
a51 2
	char buf[172], *p = buf;
	sprintf(p, "states->");
d53 1
a53 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "GOT_BUS ");
d56 1
a56 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "GOT_TGT ");
d59 1
a59 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "SENT_CDB ");
d62 1
a62 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "XFRD_DATA ");
d65 1
a65 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "GOT_STS ");
d68 1
a68 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "GOT_SNS ");
d71 1
a71 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "XFR_CMPLT ");
d73 1
a73 4
	p += strlen(p);
	sprintf(p, "%s%s", buf, "\n");
	p += strlen(p);
	sprintf(p, "%s%s", buf, "status->");
d75 1
a75 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "Disconnect ");
d78 1
a78 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "Sync_xfr ");
d81 1
a81 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "Parity ");
d84 1
a84 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "Bus_Reset ");
d87 1
a87 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "Device_Reset ");
d90 1
a90 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "Aborted ");
d93 1
a93 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "Timeout ");
d96 1
a96 2
		p += strlen(p);
		sprintf(p, "%s%s", buf, "Negotiation ");
d159 3
d223 7
d236 1
a236 1
		isp->isp_xflist[handle - 1] = NULL;
d267 4
a270 2
	*optrp = optr;
	*iptrp = iptr;
@


1.2
log
@Amazingly neither the compiler nor review missed this silly botch.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.1 1999/11/22 12:50:53 mjacob Exp $ */
d277 21
@


1.2.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.3 2000/02/20 21:22:41 mjacob Exp $ */
a276 21
}

static INLINE void
isp_print_qentry __P((struct ispsoftc *, char *, int, void *));

static INLINE void
isp_print_qentry(isp, msg, idx, arg)
	struct ispsoftc *isp;
	char *msg;
	int idx;
	void *arg;
{
	int amt, i, j;
	u_int8_t *ptr = arg;
	PRINTF("%s %s index %d:\n", isp->isp_name, msg, idx);
	for (amt = i = 0; i < 4; i++) {
		for (j = 0; j < (QENTRY_LEN >> 2); j++) {
			PRINTF(" %02x", ptr[amt++] & 0xff);
		}
		PRINTF("\n");
	}
@


1.2.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.8 2001/04/04 22:07:19 mjacob Exp $ */
d3 1
a3 1
 * Qlogic Host Adapter Inline Functions
d5 2
a6 1
 * Copyright (c) 1999, 2000, 2001 by Matthew Jacob
d10 1
d18 4
a21 1
 * 2. The name of the author may not be used to endorse or promote products
d40 120
d167 14
a180 6
static INLINE int isp_save_xs(struct ispsoftc *, XS_T *, u_int16_t *);
static INLINE XS_T *isp_find_xs(struct ispsoftc *, u_int16_t);
static INLINE u_int16_t isp_find_handle(struct ispsoftc *, XS_T *);
static INLINE int isp_handle_index(u_int16_t);
static INLINE void isp_destroy_handle(struct ispsoftc *, u_int16_t);
static INLINE void isp_remove_handle(struct ispsoftc *, XS_T *);
d183 4
a186 1
isp_save_xs(struct ispsoftc *isp, XS_T *xs, u_int16_t *handlep)
d205 1
a205 1
	isp->isp_lasthdls = (u_int16_t)j;
d209 4
a212 2
static INLINE XS_T *
isp_find_xs(struct ispsoftc *isp, u_int16_t handle)
d214 1
a214 1
	if (handle < 1 || handle > (u_int16_t) isp->isp_maxcmds) {
d221 4
a224 2
static INLINE u_int16_t
isp_find_handle(struct ispsoftc *isp, XS_T *xs)
d230 1
a230 1
				return ((u_int16_t) i+1);
a236 6
static INLINE int
isp_handle_index(u_int16_t handle)
{
	return (handle-1);
}

d238 3
a240 1
isp_destroy_handle(struct ispsoftc *isp, u_int16_t handle)
d242 2
a243 2
	if (handle > 0 && handle <= (u_int16_t) isp->isp_maxcmds) {
		isp->isp_xflist[isp_handle_index(handle)] = NULL;
d248 3
a250 1
isp_remove_handle(struct ispsoftc *isp, XS_T *xs)
d256 1
a256 1
isp_getrqentry(struct ispsoftc *, u_int16_t *, u_int16_t *, void **);
d259 5
a263 2
isp_getrqentry(struct ispsoftc *isp, u_int16_t *iptrp,
    u_int16_t *optrp, void **resultp)
d270 1
a270 1
	iptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN(isp));
d274 2
a275 4
	if (optrp)
		*optrp = optr;
	if (iptrp)
		*iptrp = iptr;
d279 2
a280 2
static INLINE void isp_print_qentry (struct ispsoftc *, char *, int, void *);

a281 1
#define	TBA	(4 * (((QENTRY_LEN >> 2) * 3) + 1) + 1)
d283 5
a287 1
isp_print_qentry(struct ispsoftc *isp, char *msg, int idx, void *arg)
a288 1
	char buf[TBA];
d291 2
a292 5

	isp_prt(isp, ISP_LOGALL, "%s index %d=>", msg, idx);
	for (buf[0] = 0, amt = i = 0; i < 4; i++) {
		buf[0] = 0;
		SNPRINTF(buf, TBA, "  ");
d294 1
a294 26
			SNPRINTF(buf, TBA, "%s %02x", buf, ptr[amt++] & 0xff);
		}
		isp_prt(isp, ISP_LOGALL, buf);
	}
}

static INLINE void isp_print_bytes(struct ispsoftc *, char *, int, void *);

static INLINE void
isp_print_bytes(struct ispsoftc *isp, char *msg, int amt, void *arg)
{
	char buf[128];
	u_int8_t *ptr = arg;
	int off;

	if (msg)
		isp_prt(isp, ISP_LOGALL, "%s:", msg);
	off = 0;
	buf[0] = 0;
	while (off < amt) {
		int j, to;
		to = off;
		for (j = 0; j < 16; j++) {
			SNPRINTF(buf, 128, "%s %02x", buf, ptr[off++] & 0xff);
			if (off == amt)
				break;
d296 1
a296 41
		isp_prt(isp, ISP_LOGALL, "0x%08x:%s", to, buf);
		buf[0] = 0;
	}
}

/*
 * Do the common path to try and ensure that link is up, we've scanned
 * the fabric (if we're on a fabric), and that we've synchronized this
 * all with our own database and done the appropriate logins.
 *
 * We repeatedly check for firmware state and loop state after each
 * action because things may have changed while we were doing this.
 * Any failure or change of state causes us to return a nonzero value.
 *
 * We honor HBA roles in that if we're not in Initiator mode, we don't
 * attempt to sync up the database (that's for somebody else to do,
 * if ever).
 *
 * We assume we enter here with any locks held.
 */

static INLINE int isp_fc_runstate(struct ispsoftc *, int);

static INLINE int
isp_fc_runstate(struct ispsoftc *isp, int tval)
{
	fcparam *fcp;
	int *tptr;

	if (IS_SCSI(isp))
		return (0);

	tptr = tval? &tval : NULL;
	if (isp_control(isp, ISPCTL_FCLINK_TEST, tptr) != 0) {
		return (-1);
	}
	fcp = FCPARAM(isp);
	if (fcp->isp_fwstate != FW_READY || fcp->isp_loopstate < LOOP_PDB_RCVD)
		return (-1);
	if (isp_control(isp, ISPCTL_SCAN_FABRIC, NULL) != 0) {
		return (-1);
a297 13
	if (isp_control(isp, ISPCTL_SCAN_LOOP, NULL) != 0) {
		return (-1);
	}
	if ((isp->isp_role & ISP_ROLE_INITIATOR) == 0) {
		return (0);
	}
	if (isp_control(isp, ISPCTL_PDB_SYNC, NULL) != 0) {
		return (-1);
	}
	if (fcp->isp_fwstate != FW_READY || fcp->isp_loopstate != LOOP_READY) {
		return (-1);
	}
	return (0);
@


1.2.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_inline.h,v 1.2.2.2 2001/05/14 22:23:54 niklas Exp $ */
d126 1
a126 1
	optr = isp->isp_reqodx = READ_REQUEST_QUEUE_OUT_POINTER(isp);
@


1.2.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a238 1103

/*
 * Functions to move stuff to a form that the QLogic RISC engine understands
 * and functions to move stuff back to a form the processor understands.
 *
 * Each platform is required to provide the 8, 16 and 32 bit
 * swizzle and unswizzle macros (ISP_IOX{PUT|GET}_{8,16,32})
 *
 * The assumption is that swizzling and unswizzling is mostly done 'in place'
 * (with a few exceptions for efficiency).
 */

static INLINE void isp_copy_out_hdr(struct ispsoftc *, isphdr_t *, isphdr_t *);
static INLINE void isp_copy_in_hdr(struct ispsoftc *, isphdr_t *, isphdr_t *);
static INLINE int isp_get_response_type(struct ispsoftc *, isphdr_t *);

static INLINE void
isp_put_request(struct ispsoftc *, ispreq_t *, ispreq_t *);
static INLINE void
isp_put_request_t2(struct ispsoftc *, ispreqt2_t *, ispreqt2_t *);
static INLINE void
isp_put_request_t3(struct ispsoftc *, ispreqt3_t *, ispreqt3_t *);
static INLINE void
isp_put_extended_request(struct ispsoftc *, ispextreq_t *, ispextreq_t *);
static INLINE void
isp_put_cont_req(struct ispsoftc *, ispcontreq_t *, ispcontreq_t *);
static INLINE void
isp_put_cont64_req(struct ispsoftc *, ispcontreq64_t *, ispcontreq64_t *);
static INLINE void
isp_get_response(struct ispsoftc *, ispstatusreq_t *, ispstatusreq_t *);
static INLINE void
isp_get_response_x(struct ispsoftc *, ispstatus_cont_t *, ispstatus_cont_t *);
static INLINE void
isp_put_icb(struct ispsoftc *, isp_icb_t *, isp_icb_t *);
static INLINE void
isp_get_pdb(struct ispsoftc *, isp_pdb_t *, isp_pdb_t *);
static INLINE void
isp_put_sns_request(struct ispsoftc *, sns_screq_t *, sns_screq_t *);
static INLINE void
isp_get_sns_response(struct ispsoftc *, sns_scrsp_t *, sns_scrsp_t *, int);
static INLINE void
isp_get_gan_response(struct ispsoftc *, sns_ganrsp_t *, sns_ganrsp_t *);
#ifdef	ISP_TARGET_MODE
#ifndef	_ISP_TARGET_H
#include "isp_target.h"
#endif
static INLINE void
isp_put_atio(struct ispsoftc *, at_entry_t *, at_entry_t *);
static INLINE void
isp_get_atio(struct ispsoftc *, at_entry_t *, at_entry_t *);
static INLINE void
isp_put_atio2(struct ispsoftc *, at2_entry_t *, at2_entry_t *);
static INLINE void
isp_get_atio2(struct ispsoftc *, at2_entry_t *, at2_entry_t *);
static INLINE void
isp_put_ctio(struct ispsoftc *, ct_entry_t *, ct_entry_t *);
static INLINE void
isp_get_ctio(struct ispsoftc *, ct_entry_t *, ct_entry_t *);
static INLINE void
isp_put_ctio2(struct ispsoftc *, ct2_entry_t *, ct2_entry_t *);
static INLINE void
isp_get_ctio2(struct ispsoftc *, ct2_entry_t *, ct2_entry_t *);
static INLINE void
isp_put_enable_lun(struct ispsoftc *, lun_entry_t *, lun_entry_t *);
static INLINE void
isp_get_enable_lun(struct ispsoftc *, lun_entry_t *, lun_entry_t *);
static INLINE void
isp_put_notify(struct ispsoftc *, in_entry_t *, in_entry_t *);
static INLINE void
isp_get_notify(struct ispsoftc *, in_entry_t *, in_entry_t *);
static INLINE void
isp_put_notify_fc(struct ispsoftc *, in_fcentry_t *, in_fcentry_t *);
static INLINE void
isp_get_notify_fc(struct ispsoftc *, in_fcentry_t *, in_fcentry_t *);
static INLINE void
isp_put_notify_ack(struct ispsoftc *, na_entry_t *, na_entry_t *);
static INLINE void
isp_get_notify_ack(struct ispsoftc *, na_entry_t *, na_entry_t *);
static INLINE void
isp_put_notify_ack_fc(struct ispsoftc *, na_fcentry_t *, na_fcentry_t *);
static INLINE void
isp_get_notify_ack_fc(struct ispsoftc *, na_fcentry_t *, na_fcentry_t *);
#endif

#define	ISP_IS_SBUS(isp)	\
	(ISP_SBUS_SUPPORTED && (isp)->isp_bustype == ISP_BT_SBUS)

/*
 * Swizzle/Copy Functions
 */
static INLINE void
isp_copy_out_hdr(struct ispsoftc *isp, isphdr_t *hpsrc, isphdr_t *hpdst)
{
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, hpsrc->rqs_entry_type,
		    &hpdst->rqs_entry_count);
		ISP_IOXPUT_8(isp, hpsrc->rqs_entry_count,
		    &hpdst->rqs_entry_type);
		ISP_IOXPUT_8(isp, hpsrc->rqs_seqno,
		    &hpdst->rqs_flags);
		ISP_IOXPUT_8(isp, hpsrc->rqs_flags,
		    &hpdst->rqs_seqno);
	} else {
		ISP_IOXPUT_8(isp, hpsrc->rqs_entry_type,
		    &hpdst->rqs_entry_type);
		ISP_IOXPUT_8(isp, hpsrc->rqs_entry_count,
		    &hpdst->rqs_entry_count);
		ISP_IOXPUT_8(isp, hpsrc->rqs_seqno,
		    &hpdst->rqs_seqno);
		ISP_IOXPUT_8(isp, hpsrc->rqs_flags,
		    &hpdst->rqs_flags);
	}
}

static INLINE void
isp_copy_in_hdr(struct ispsoftc *isp, isphdr_t *hpsrc, isphdr_t *hpdst)
{
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &hpsrc->rqs_entry_type,
		    hpdst->rqs_entry_count);
		ISP_IOXGET_8(isp, &hpsrc->rqs_entry_count,
		    hpdst->rqs_entry_type);
		ISP_IOXGET_8(isp, &hpsrc->rqs_seqno,
		    hpdst->rqs_flags);
		ISP_IOXGET_8(isp, &hpsrc->rqs_flags,
		    hpdst->rqs_seqno);
	} else {
		ISP_IOXGET_8(isp, &hpsrc->rqs_entry_type,
		    hpdst->rqs_entry_type);
		ISP_IOXGET_8(isp, &hpsrc->rqs_entry_count,
		    hpdst->rqs_entry_count);
		ISP_IOXGET_8(isp, &hpsrc->rqs_seqno,
		    hpdst->rqs_seqno);
		ISP_IOXGET_8(isp, &hpsrc->rqs_flags,
		    hpdst->rqs_flags);
	}
}

static INLINE int
isp_get_response_type(struct ispsoftc *isp, isphdr_t *hp)
{
	uint8_t type;
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &hp->rqs_entry_count, type);
	} else {
		ISP_IOXGET_8(isp, &hp->rqs_entry_type, type);
	}
	return ((int)type);
}

static INLINE void
isp_put_request(struct ispsoftc *isp, ispreq_t *rqsrc, ispreq_t *rqdst)
{
	int i;
	isp_copy_out_hdr(isp, &rqsrc->req_header, &rqdst->req_header);
	ISP_IOXPUT_32(isp, rqsrc->req_handle, &rqdst->req_handle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, rqsrc->req_lun_trn, &rqdst->req_target);
		ISP_IOXPUT_8(isp, rqsrc->req_target, &rqdst->req_lun_trn);
	} else {
		ISP_IOXPUT_8(isp, rqsrc->req_lun_trn, &rqdst->req_lun_trn);
		ISP_IOXPUT_8(isp, rqsrc->req_target, &rqdst->req_target);
	}
	ISP_IOXPUT_16(isp, rqsrc->req_cdblen, &rqdst->req_cdblen);
	ISP_IOXPUT_16(isp, rqsrc->req_flags, &rqdst->req_flags);
	ISP_IOXPUT_16(isp, rqsrc->req_time, &rqdst->req_time);
	ISP_IOXPUT_16(isp, rqsrc->req_seg_count, &rqdst->req_seg_count);
	for (i = 0; i < 12; i++) {
		ISP_IOXPUT_8(isp, rqsrc->req_cdb[i], &rqdst->req_cdb[i]);
	}
	for (i = 0; i < ISP_RQDSEG; i++) {
		ISP_IOXPUT_32(isp, rqsrc->req_dataseg[i].ds_base,
		    &rqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, rqsrc->req_dataseg[i].ds_count,
		    &rqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_request_t2(struct ispsoftc *isp, ispreqt2_t *tqsrc, ispreqt2_t *tqdst)
{
	int i;
	isp_copy_out_hdr(isp, &tqsrc->req_header, &tqdst->req_header);
	ISP_IOXPUT_32(isp, tqsrc->req_handle, &tqdst->req_handle);
	ISP_IOXPUT_8(isp, tqsrc->req_lun_trn, &tqdst->req_lun_trn);
	ISP_IOXPUT_8(isp, tqsrc->req_target, &tqdst->req_target);
	ISP_IOXPUT_16(isp, tqsrc->req_scclun, &tqdst->req_scclun);
	ISP_IOXPUT_16(isp, tqsrc->req_flags,  &tqdst->req_flags);
	ISP_IOXPUT_16(isp, tqsrc->_res2, &tqdst->_res2);
	ISP_IOXPUT_16(isp, tqsrc->req_time, &tqdst->req_time);
	ISP_IOXPUT_16(isp, tqsrc->req_seg_count, &tqdst->req_seg_count);
	for (i = 0; i < 16; i++) {
		ISP_IOXPUT_8(isp, tqsrc->req_cdb[i], &tqdst->req_cdb[i]);
	}
	ISP_IOXPUT_32(isp, tqsrc->req_totalcnt, &tqdst->req_totalcnt);
	for (i = 0; i < ISP_RQDSEG_T2; i++) {
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_base,
		    &tqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_count,
		    &tqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_request_t3(struct ispsoftc *isp, ispreqt3_t *tqsrc, ispreqt3_t *tqdst)
{
	int i;
	isp_copy_out_hdr(isp, &tqsrc->req_header, &tqdst->req_header);
	ISP_IOXPUT_32(isp, tqsrc->req_handle, &tqdst->req_handle);
	ISP_IOXPUT_8(isp, tqsrc->req_lun_trn, &tqdst->req_lun_trn);
	ISP_IOXPUT_8(isp, tqsrc->req_target, &tqdst->req_target);
	ISP_IOXPUT_16(isp, tqsrc->req_scclun, &tqdst->req_scclun);
	ISP_IOXPUT_16(isp, tqsrc->req_flags,  &tqdst->req_flags);
	ISP_IOXPUT_16(isp, tqsrc->_res2, &tqdst->_res2);
	ISP_IOXPUT_16(isp, tqsrc->req_time, &tqdst->req_time);
	ISP_IOXPUT_16(isp, tqsrc->req_seg_count, &tqdst->req_seg_count);
	for (i = 0; i < 16; i++) {
		ISP_IOXPUT_8(isp, tqsrc->req_cdb[i], &tqdst->req_cdb[i]);
	}
	ISP_IOXPUT_32(isp, tqsrc->req_totalcnt, &tqdst->req_totalcnt);
	for (i = 0; i < ISP_RQDSEG_T2; i++) {
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_base,
		    &tqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_basehi,
		    &tqdst->req_dataseg[i].ds_basehi);
		ISP_IOXPUT_32(isp, tqsrc->req_dataseg[i].ds_count,
		    &tqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_extended_request(struct ispsoftc *isp, ispextreq_t *xqsrc,
    ispextreq_t *xqdst)
{
	int i;
	isp_copy_out_hdr(isp, &xqsrc->req_header, &xqdst->req_header);
	ISP_IOXPUT_32(isp, xqsrc->req_handle, &xqdst->req_handle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, xqsrc->req_lun_trn, &xqdst->req_target);
		ISP_IOXPUT_8(isp, xqsrc->req_target, &xqdst->req_lun_trn);
	} else {
		ISP_IOXPUT_8(isp, xqsrc->req_lun_trn, &xqdst->req_lun_trn);
		ISP_IOXPUT_8(isp, xqsrc->req_target, &xqdst->req_target);
	}
	ISP_IOXPUT_16(isp, xqsrc->req_cdblen, &xqdst->req_cdblen);
	ISP_IOXPUT_16(isp, xqsrc->req_flags, &xqdst->req_flags);
	ISP_IOXPUT_16(isp, xqsrc->req_time, &xqdst->req_time);
	ISP_IOXPUT_16(isp, xqsrc->req_seg_count, &xqdst->req_seg_count);
	for (i = 0; i < 44; i++) {
		ISP_IOXPUT_8(isp, xqsrc->req_cdb[i], &xqdst->req_cdb[i]);
	}
}

static INLINE void
isp_put_cont_req(struct ispsoftc *isp, ispcontreq_t *cqsrc, ispcontreq_t *cqdst)
{
	int i;
	isp_copy_out_hdr(isp, &cqsrc->req_header, &cqdst->req_header);
	for (i = 0; i < ISP_CDSEG; i++) {
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_base,
		    &cqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_count,
		    &cqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_cont64_req(struct ispsoftc *isp, ispcontreq64_t *cqsrc,
    ispcontreq64_t *cqdst)
{
	int i;
	isp_copy_out_hdr(isp, &cqsrc->req_header, &cqdst->req_header);
	for (i = 0; i < ISP_CDSEG64; i++) {
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_base,
		    &cqdst->req_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_basehi,
		    &cqdst->req_dataseg[i].ds_basehi);
		ISP_IOXPUT_32(isp, cqsrc->req_dataseg[i].ds_count,
		    &cqdst->req_dataseg[i].ds_count);
	}
}

static INLINE void
isp_get_response(struct ispsoftc *isp, ispstatusreq_t *spsrc,
    ispstatusreq_t *spdst)
{
	int i;
	isp_copy_in_hdr(isp, &spsrc->req_header, &spdst->req_header);
	ISP_IOXGET_32(isp, &spsrc->req_handle, spdst->req_handle);
	ISP_IOXGET_16(isp, &spsrc->req_scsi_status, spdst->req_scsi_status);
	ISP_IOXGET_16(isp, &spsrc->req_completion_status,
	    spdst->req_completion_status);
	ISP_IOXGET_16(isp, &spsrc->req_state_flags, spdst->req_state_flags);
	ISP_IOXGET_16(isp, &spsrc->req_status_flags, spdst->req_status_flags);
	ISP_IOXGET_16(isp, &spsrc->req_time, spdst->req_time);
	ISP_IOXGET_16(isp, &spsrc->req_sense_len, spdst->req_sense_len);
	ISP_IOXGET_32(isp, &spsrc->req_resid, spdst->req_resid);
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &spsrc->req_response[i],
		    spdst->req_response[i]);
	}
	for (i = 0; i < 32; i++) {
		ISP_IOXGET_8(isp, &spsrc->req_sense_data[i],
		    spdst->req_sense_data[i]);
	}
}

static INLINE void
isp_get_response_x(struct ispsoftc *isp, ispstatus_cont_t *cpsrc,
    ispstatus_cont_t *cpdst)
{
	int i;
	isp_copy_in_hdr(isp, &cpsrc->req_header, &cpdst->req_header);
	for (i = 0; i < 60; i++) {
		ISP_IOXGET_8(isp, &cpsrc->req_sense_data[i],
		    cpdst->req_sense_data[i]);
	}
}

static INLINE void
isp_put_icb(struct ispsoftc *isp, isp_icb_t *Is, isp_icb_t *Id)
{
	int i;
	ISP_SWAP8(Is->icb_version, Is->_reserved0);
	ISP_IOXPUT_8(isp, Is->icb_version, &Id->icb_version);
	ISP_IOXPUT_8(isp, Is->_reserved0, &Id->_reserved0);
	ISP_IOXPUT_16(isp, Is->icb_fwoptions, &Id->icb_fwoptions);
	ISP_IOXPUT_16(isp, Is->icb_maxfrmlen, &Id->icb_maxfrmlen);
	ISP_IOXPUT_16(isp, Is->icb_maxalloc, &Id->icb_maxalloc);
	ISP_IOXPUT_16(isp, Is->icb_execthrottle, &Id->icb_execthrottle);
	ISP_SWAP8(Is->icb_retry_count, Is->icb_retry_delay);
	ISP_IOXPUT_8(isp, Is->icb_retry_count, &Id->icb_retry_count);
	ISP_IOXPUT_8(isp, Is->icb_retry_delay, &Id->icb_retry_delay);
	for (i = 0; i < 8; i++) {
		ISP_IOXPUT_8(isp, Is->icb_portname[i], &Id->icb_portname[i]);
	}
	ISP_IOXPUT_16(isp, Is->icb_hardaddr, &Id->icb_hardaddr);
	ISP_SWAP8(Is->icb_iqdevtype, Is->icb_logintime);
	ISP_IOXPUT_8(isp, Is->icb_iqdevtype, &Id->icb_iqdevtype);
	ISP_IOXPUT_8(isp, Is->icb_logintime, &Id->icb_logintime);
	for (i = 0; i < 8; i++) {
		ISP_IOXPUT_8(isp, Is->icb_nodename[i], &Id->icb_nodename[i]);
	}
	ISP_IOXPUT_16(isp, Is->icb_rqstout, &Id->icb_rqstout);
	ISP_IOXPUT_16(isp, Is->icb_rspnsin, &Id->icb_rspnsin);
	ISP_IOXPUT_16(isp, Is->icb_rqstqlen, &Id->icb_rqstqlen);
	ISP_IOXPUT_16(isp, Is->icb_rsltqlen, &Id->icb_rsltqlen);
	for (i = 0; i < 4; i++) {
		ISP_IOXPUT_16(isp, Is->icb_rqstaddr[i], &Id->icb_rqstaddr[i]);
	}
	for (i = 0; i < 4; i++) {
		ISP_IOXPUT_16(isp, Is->icb_respaddr[i], &Id->icb_respaddr[i]);
	}
	ISP_IOXPUT_16(isp, Is->icb_lunenables, &Id->icb_lunenables);
	ISP_SWAP8(Is->icb_ccnt, Is->icb_icnt);
	ISP_IOXPUT_8(isp, Is->icb_ccnt, &Id->icb_ccnt);
	ISP_IOXPUT_8(isp, Is->icb_icnt, &Id->icb_icnt);
	ISP_IOXPUT_16(isp, Is->icb_lunetimeout, &Id->icb_lunetimeout);
	ISP_IOXPUT_16(isp, Is->icb_xfwoptions, &Id->icb_xfwoptions);
	ISP_SWAP8(Is->icb_racctimer, Is->icb_idelaytimer);
	ISP_IOXPUT_8(isp, Is->icb_racctimer, &Id->icb_racctimer);
	ISP_IOXPUT_8(isp, Is->icb_idelaytimer, &Id->icb_idelaytimer);
	ISP_IOXPUT_16(isp, Is->icb_zfwoptions, &Id->icb_zfwoptions);
}

static INLINE void
isp_get_pdb(struct ispsoftc *isp, isp_pdb_t *src, isp_pdb_t *dst)
{
	int i;
	ISP_IOXGET_16(isp, &src->pdb_options, dst->pdb_options);
        ISP_IOXGET_8(isp, &src->pdb_mstate, dst->pdb_mstate);
        ISP_IOXGET_8(isp, &src->pdb_sstate, dst->pdb_sstate);
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_8(isp, &src->pdb_hardaddr_bits[i],
		    dst->pdb_hardaddr_bits[i]);
	}
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_8(isp, &src->pdb_portid_bits[i],
		    dst->pdb_portid_bits[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->pdb_nodename[i], dst->pdb_nodename[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->pdb_portname[i], dst->pdb_portname[i]);
	}
	ISP_IOXGET_16(isp, &src->pdb_execthrottle, dst->pdb_execthrottle);
	ISP_IOXGET_16(isp, &src->pdb_exec_count, dst->pdb_exec_count);
	ISP_IOXGET_8(isp, &src->pdb_retry_count, dst->pdb_retry_count);
	ISP_IOXGET_8(isp, &src->pdb_retry_delay, dst->pdb_retry_delay);
	ISP_IOXGET_16(isp, &src->pdb_resalloc, dst->pdb_resalloc);
	ISP_IOXGET_16(isp, &src->pdb_curalloc, dst->pdb_curalloc);
	ISP_IOXGET_16(isp, &src->pdb_qhead, dst->pdb_qhead);
	ISP_IOXGET_16(isp, &src->pdb_qtail, dst->pdb_qtail);
	ISP_IOXGET_16(isp, &src->pdb_tl_next, dst->pdb_tl_next);
	ISP_IOXGET_16(isp, &src->pdb_tl_last, dst->pdb_tl_last);
	ISP_IOXGET_16(isp, &src->pdb_features, dst->pdb_features);
	ISP_IOXGET_16(isp, &src->pdb_pconcurrnt, dst->pdb_pconcurrnt);
	ISP_IOXGET_16(isp, &src->pdb_roi, dst->pdb_roi);
	ISP_IOXGET_8(isp, &src->pdb_target, dst->pdb_target);
	ISP_IOXGET_8(isp, &src->pdb_initiator, dst->pdb_initiator);
	ISP_IOXGET_16(isp, &src->pdb_rdsiz, dst->pdb_rdsiz);
	ISP_IOXGET_16(isp, &src->pdb_ncseq, dst->pdb_ncseq);
	ISP_IOXGET_16(isp, &src->pdb_noseq, dst->pdb_noseq);
	ISP_IOXGET_16(isp, &src->pdb_labrtflg, dst->pdb_labrtflg);
	ISP_IOXGET_16(isp, &src->pdb_lstopflg, dst->pdb_lstopflg);
	ISP_IOXGET_16(isp, &src->pdb_sqhead, dst->pdb_sqhead);
	ISP_IOXGET_16(isp, &src->pdb_sqtail, dst->pdb_sqtail);
	ISP_IOXGET_16(isp, &src->pdb_ptimer, dst->pdb_ptimer);
	ISP_IOXGET_16(isp, &src->pdb_nxt_seqid, dst->pdb_nxt_seqid);
	ISP_IOXGET_16(isp, &src->pdb_fcount, dst->pdb_fcount);
	ISP_IOXGET_16(isp, &src->pdb_prli_len, dst->pdb_prli_len);
	ISP_IOXGET_16(isp, &src->pdb_prli_svc0, dst->pdb_prli_svc0);
	ISP_IOXGET_16(isp, &src->pdb_prli_svc3, dst->pdb_prli_svc3);
	ISP_IOXGET_16(isp, &src->pdb_loopid, dst->pdb_loopid);
	ISP_IOXGET_16(isp, &src->pdb_il_ptr, dst->pdb_il_ptr);
	ISP_IOXGET_16(isp, &src->pdb_sl_ptr, dst->pdb_sl_ptr);
}

static INLINE void
isp_put_sns_request(struct ispsoftc *isp, sns_screq_t *src, sns_screq_t *dst)
{
	int i, nw = (int) src->snscb_sblen;
	ISP_IOXPUT_16(isp, src->snscb_rblen, &dst->snscb_rblen);
	for (i = 0; i < 4; i++) {
		ISP_IOXPUT_16(isp, src->snscb_addr[i], &dst->snscb_addr[i]);
	}
	ISP_IOXPUT_16(isp, src->snscb_sblen, &dst->snscb_sblen);
	for (i = 0; i < nw; i++) {
		ISP_IOXPUT_16(isp, src->snscb_data[i], &dst->snscb_data[i]);
	}
	
}

static INLINE void
isp_get_sns_response(struct ispsoftc *isp, sns_scrsp_t *src,
    sns_scrsp_t *dst, int nwords)
{
	int i;
	for (i = 0; i < 16; i++) {
		ISP_IOXGET_8(isp, &src->snscb_cthdr[i], dst->snscb_cthdr[i]);
	}
	ISP_IOXGET_8(isp, &src->snscb_port_type, dst->snscb_port_type);
	for (i = 0; i < 3; i++) {
		ISP_IOXGET_8(isp, &src->snscb_port_id[i],
		    dst->snscb_port_id[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_portname[i],
		    dst->snscb_portname[i]);
	}
	for (i = 0; i < nwords; i++) {
		ISP_IOXGET_16(isp, &src->snscb_data[i], dst->snscb_data[i]);
	}
}

static INLINE void
isp_get_gan_response(struct ispsoftc *isp, sns_ganrsp_t *src, sns_ganrsp_t *dst)
{
	int i;
	for (i = 0; i < 16; i++) {
		ISP_IOXGET_8(isp, &src->snscb_cthdr[i], dst->snscb_cthdr[i]);
	}
	ISP_IOXGET_8(isp, &src->snscb_port_type, dst->snscb_port_type);
	for (i = 0; i < 3; i++) {
		ISP_IOXGET_8(isp, &src->snscb_port_id[i],
		    dst->snscb_port_id[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_portname[i],
		    dst->snscb_portname[i]);
	}
	ISP_IOXGET_8(isp, &src->snscb_pnlen, dst->snscb_pnlen);
	for (i = 0; i < 255; i++) {
		ISP_IOXGET_8(isp, &src->snscb_pname[i], dst->snscb_pname[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_nodename[i],
		    dst->snscb_nodename[i]);
	}
	ISP_IOXGET_8(isp, &src->snscb_nnlen, dst->snscb_nnlen);
	for (i = 0; i < 255; i++) {
		ISP_IOXGET_8(isp, &src->snscb_nname[i], dst->snscb_nname[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_ipassoc[i],
		    dst->snscb_ipassoc[i]);
	}
	for (i = 0; i < 16; i++) {
		ISP_IOXGET_8(isp, &src->snscb_ipaddr[i], dst->snscb_ipaddr[i]);
	}
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_8(isp, &src->snscb_svc_class[i],
		    dst->snscb_svc_class[i]);
	}
	for (i = 0; i < 32; i++) {
		ISP_IOXGET_8(isp, &src->snscb_fc4_types[i],
		    dst->snscb_fc4_types[i]);
	}
	for (i = 0; i < 8; i++) {
		ISP_IOXGET_8(isp, &src->snscb_fpname[i], dst->snscb_fpname[i]);
	}
	ISP_IOXGET_8(isp, &src->snscb_reserved, dst->snscb_reserved);
	for (i = 0; i < 3; i++) {
		ISP_IOXGET_8(isp, &src->snscb_hardaddr[i],
		    dst->snscb_hardaddr[i]);
	}
}

#ifdef	ISP_TARGET_MODE
static INLINE void
isp_put_atio(struct ispsoftc *isp, at_entry_t *atsrc, at_entry_t *atdst)
{
	int i;
	isp_copy_out_hdr(isp, &atsrc->at_header, &atdst->at_header);
	ISP_IOXPUT_16(isp, atsrc->at_reserved, &atdst->at_reserved);
	ISP_IOXPUT_16(isp, atsrc->at_handle, &atdst->at_handle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, atsrc->at_lun, &atdst->at_iid);
		ISP_IOXPUT_8(isp, atsrc->at_iid, &atdst->at_lun);
		ISP_IOXPUT_8(isp, atsrc->at_cdblen, &atdst->at_tgt);
		ISP_IOXPUT_8(isp, atsrc->at_tgt, &atdst->at_cdblen);
		ISP_IOXPUT_8(isp, atsrc->at_status, &atdst->at_scsi_status);
		ISP_IOXPUT_8(isp, atsrc->at_scsi_status, &atdst->at_status);
		ISP_IOXPUT_8(isp, atsrc->at_tag_val, &atdst->at_tag_type);
		ISP_IOXPUT_8(isp, atsrc->at_tag_type, &atdst->at_tag_val);
	} else {
		ISP_IOXPUT_8(isp, atsrc->at_lun, &atdst->at_lun);
		ISP_IOXPUT_8(isp, atsrc->at_iid, &atdst->at_iid);
		ISP_IOXPUT_8(isp, atsrc->at_cdblen, &atdst->at_cdblen);
		ISP_IOXPUT_8(isp, atsrc->at_tgt, &atdst->at_tgt);
		ISP_IOXPUT_8(isp, atsrc->at_status, &atdst->at_status);
		ISP_IOXPUT_8(isp, atsrc->at_scsi_status,
		    &atdst->at_scsi_status);
		ISP_IOXPUT_8(isp, atsrc->at_tag_val, &atdst->at_tag_val);
		ISP_IOXPUT_8(isp, atsrc->at_tag_type, &atdst->at_tag_type);
	}
	ISP_IOXPUT_32(isp, atsrc->at_flags, &atdst->at_flags);
	for (i = 0; i < ATIO_CDBLEN; i++) {
		ISP_IOXPUT_8(isp, atsrc->at_cdb[i], &atdst->at_cdb[i]);
	}
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXPUT_8(isp, atsrc->at_sense[i], &atdst->at_sense[i]);
	}
}

static INLINE void
isp_get_atio(struct ispsoftc *isp, at_entry_t *atsrc, at_entry_t *atdst)
{
	int i;
	isp_copy_in_hdr(isp, &atsrc->at_header, &atdst->at_header);
	ISP_IOXGET_16(isp, &atsrc->at_reserved, atdst->at_reserved);
	ISP_IOXGET_16(isp, &atsrc->at_handle, atdst->at_handle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &atsrc->at_lun, atdst->at_iid);
		ISP_IOXGET_8(isp, &atsrc->at_iid, atdst->at_lun);
		ISP_IOXGET_8(isp, &atsrc->at_cdblen, atdst->at_tgt);
		ISP_IOXGET_8(isp, &atsrc->at_tgt, atdst->at_cdblen);
		ISP_IOXGET_8(isp, &atsrc->at_status, atdst->at_scsi_status);
		ISP_IOXGET_8(isp, &atsrc->at_scsi_status, atdst->at_status);
		ISP_IOXGET_8(isp, &atsrc->at_tag_val, atdst->at_tag_type);
		ISP_IOXGET_8(isp, &atsrc->at_tag_type, atdst->at_tag_val);
	} else {
		ISP_IOXGET_8(isp, &atsrc->at_lun, atdst->at_lun);
		ISP_IOXGET_8(isp, &atsrc->at_iid, atdst->at_iid);
		ISP_IOXGET_8(isp, &atsrc->at_cdblen, atdst->at_cdblen);
		ISP_IOXGET_8(isp, &atsrc->at_tgt, atdst->at_tgt);
		ISP_IOXGET_8(isp, &atsrc->at_status, atdst->at_status);
		ISP_IOXGET_8(isp, &atsrc->at_scsi_status,
		    atdst->at_scsi_status);
		ISP_IOXGET_8(isp, &atsrc->at_tag_val, atdst->at_tag_val);
		ISP_IOXGET_8(isp, &atsrc->at_tag_type, atdst->at_tag_type);
	}
	ISP_IOXGET_32(isp, &atsrc->at_flags, atdst->at_flags);
	for (i = 0; i < ATIO_CDBLEN; i++) {
		ISP_IOXGET_8(isp, &atsrc->at_cdb[i], atdst->at_cdb[i]);
	}
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXGET_8(isp, &atsrc->at_sense[i], atdst->at_sense[i]);
	}
}

static INLINE void
isp_put_atio2(struct ispsoftc *isp, at2_entry_t *atsrc, at2_entry_t *atdst)
{
	int i;
	isp_copy_out_hdr(isp, &atsrc->at_header, &atdst->at_header);
	ISP_IOXPUT_32(isp, atsrc->at_reserved, &atdst->at_reserved);
	ISP_IOXPUT_8(isp, atsrc->at_lun, &atdst->at_lun);
	ISP_IOXPUT_8(isp, atsrc->at_iid, &atdst->at_iid);
	ISP_IOXPUT_16(isp, atsrc->at_rxid, &atdst->at_rxid);
	ISP_IOXPUT_16(isp, atsrc->at_flags, &atdst->at_flags);
	ISP_IOXPUT_16(isp, atsrc->at_status, &atdst->at_status);
	ISP_IOXPUT_8(isp, atsrc->at_reserved1, &atdst->at_reserved1);
	ISP_IOXPUT_8(isp, atsrc->at_taskcodes, &atdst->at_taskcodes);
	ISP_IOXPUT_8(isp, atsrc->at_taskflags, &atdst->at_taskflags);
	ISP_IOXPUT_8(isp, atsrc->at_execodes, &atdst->at_execodes);
	for (i = 0; i < ATIO2_CDBLEN; i++) {
		ISP_IOXPUT_8(isp, atsrc->at_cdb[i], &atdst->at_cdb[i]);
	}
	ISP_IOXPUT_32(isp, atsrc->at_datalen, &atdst->at_datalen);
	ISP_IOXPUT_16(isp, atsrc->at_scclun, &atdst->at_scclun);
	for (i = 0; i < 10; i++) {
		ISP_IOXPUT_8(isp, atsrc->at_reserved2[i],
		    &atdst->at_reserved2[i]);
	}
	ISP_IOXPUT_16(isp, atsrc->at_oxid, &atdst->at_oxid);
}

static INLINE void
isp_get_atio2(struct ispsoftc *isp, at2_entry_t *atsrc, at2_entry_t *atdst)
{
	int i;
	isp_copy_in_hdr(isp, &atsrc->at_header, &atdst->at_header);
	ISP_IOXGET_32(isp, &atsrc->at_reserved, atdst->at_reserved);
	ISP_IOXGET_8(isp, &atsrc->at_lun, atdst->at_lun);
	ISP_IOXGET_8(isp, &atsrc->at_iid, atdst->at_iid);
	ISP_IOXGET_16(isp, &atsrc->at_rxid, atdst->at_rxid);
	ISP_IOXGET_16(isp, &atsrc->at_flags, atdst->at_flags);
	ISP_IOXGET_16(isp, &atsrc->at_status, atdst->at_status);
	ISP_IOXGET_8(isp, &atsrc->at_reserved1, atdst->at_reserved1);
	ISP_IOXGET_8(isp, &atsrc->at_taskcodes, atdst->at_taskcodes);
	ISP_IOXGET_8(isp, &atsrc->at_taskflags, atdst->at_taskflags);
	ISP_IOXGET_8(isp, &atsrc->at_execodes, atdst->at_execodes);
	for (i = 0; i < ATIO2_CDBLEN; i++) {
		ISP_IOXGET_8(isp, &atsrc->at_cdb[i], atdst->at_cdb[i]);
	}
	ISP_IOXGET_32(isp, &atsrc->at_datalen, atdst->at_datalen);
	ISP_IOXGET_16(isp, &atsrc->at_scclun, atdst->at_scclun);
	for (i = 0; i < 10; i++) {
		ISP_IOXGET_8(isp, &atsrc->at_reserved2[i],
		    atdst->at_reserved2[i]);
	}
	ISP_IOXGET_16(isp, &atsrc->at_oxid, atdst->at_oxid);
}

static INLINE void
isp_put_ctio(struct ispsoftc *isp, ct_entry_t *ctsrc, ct_entry_t *ctdst)
{
	int i;
	isp_copy_out_hdr(isp, &ctsrc->ct_header, &ctdst->ct_header);
	ISP_IOXPUT_16(isp, ctsrc->ct_reserved, &ctdst->ct_reserved);
	ISP_IOXPUT_16(isp, ctsrc->ct_fwhandle, &ctdst->ct_fwhandle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, ctsrc->ct_iid, &ctdst->ct_lun);
		ISP_IOXPUT_8(isp, ctsrc->ct_lun, &ctdst->ct_iid);
		ISP_IOXPUT_8(isp, ctsrc->ct_tgt, &ctdst->ct_reserved2);
		ISP_IOXPUT_8(isp, ctsrc->ct_reserved2, &ctdst->ct_tgt);
		ISP_IOXPUT_8(isp, ctsrc->ct_status, &ctdst->ct_scsi_status);
		ISP_IOXPUT_8(isp, ctsrc->ct_scsi_status, &ctdst->ct_status);
		ISP_IOXPUT_8(isp, ctsrc->ct_tag_type, &ctdst->ct_tag_val);
		ISP_IOXPUT_8(isp, ctsrc->ct_tag_val, &ctdst->ct_tag_type);
	} else {
		ISP_IOXPUT_8(isp, ctsrc->ct_iid, &ctdst->ct_iid);
		ISP_IOXPUT_8(isp, ctsrc->ct_lun, &ctdst->ct_lun);
		ISP_IOXPUT_8(isp, ctsrc->ct_tgt, &ctdst->ct_tgt);
		ISP_IOXPUT_8(isp, ctsrc->ct_reserved2, &ctdst->ct_reserved2);
		ISP_IOXPUT_8(isp, ctsrc->ct_scsi_status,
		    &ctdst->ct_scsi_status);
		ISP_IOXPUT_8(isp, ctsrc->ct_status, &ctdst->ct_status);
		ISP_IOXPUT_8(isp, ctsrc->ct_tag_type, &ctdst->ct_tag_type);
		ISP_IOXPUT_8(isp, ctsrc->ct_tag_val, &ctdst->ct_tag_val);
	}
	ISP_IOXPUT_32(isp, ctsrc->ct_flags, &ctdst->ct_flags);
	ISP_IOXPUT_32(isp, ctsrc->ct_xfrlen, &ctdst->ct_xfrlen);
	ISP_IOXPUT_32(isp, ctsrc->ct_resid, &ctdst->ct_resid);
	ISP_IOXPUT_16(isp, ctsrc->ct_timeout, &ctdst->ct_timeout);
	ISP_IOXPUT_16(isp, ctsrc->ct_seg_count, &ctdst->ct_seg_count);
	for (i = 0; i < ISP_RQDSEG; i++) {
		ISP_IOXPUT_32(isp, ctsrc->ct_dataseg[i].ds_base,
		    &ctdst->ct_dataseg[i].ds_base);
		ISP_IOXPUT_32(isp, ctsrc->ct_dataseg[i].ds_count,
		    &ctdst->ct_dataseg[i].ds_count);
	}
}

static INLINE void
isp_get_ctio(struct ispsoftc *isp, ct_entry_t *ctsrc, ct_entry_t *ctdst)
{
	int i;
	isp_copy_in_hdr(isp, &ctsrc->ct_header, &ctdst->ct_header);
	ISP_IOXGET_16(isp, &ctsrc->ct_reserved, ctdst->ct_reserved);
	ISP_IOXGET_16(isp, &ctsrc->ct_fwhandle, ctdst->ct_fwhandle);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &ctsrc->ct_lun, ctdst->ct_iid);
		ISP_IOXGET_8(isp, &ctsrc->ct_iid, ctdst->ct_lun);
		ISP_IOXGET_8(isp, &ctsrc->ct_reserved2, ctdst->ct_tgt);
		ISP_IOXGET_8(isp, &ctsrc->ct_tgt, ctdst->ct_reserved2);
		ISP_IOXGET_8(isp, &ctsrc->ct_status, ctdst->ct_scsi_status);
		ISP_IOXGET_8(isp, &ctsrc->ct_scsi_status, ctdst->ct_status);
		ISP_IOXGET_8(isp, &ctsrc->ct_tag_val, ctdst->ct_tag_type);
		ISP_IOXGET_8(isp, &ctsrc->ct_tag_type, ctdst->ct_tag_val);
	} else {
		ISP_IOXGET_8(isp, &ctsrc->ct_lun, ctdst->ct_lun);
		ISP_IOXGET_8(isp, &ctsrc->ct_iid, ctdst->ct_iid);
		ISP_IOXGET_8(isp, &ctsrc->ct_reserved2, ctdst->ct_reserved2);
		ISP_IOXGET_8(isp, &ctsrc->ct_tgt, ctdst->ct_tgt);
		ISP_IOXGET_8(isp, &ctsrc->ct_status, ctdst->ct_status);
		ISP_IOXGET_8(isp, &ctsrc->ct_scsi_status,
		    ctdst->ct_scsi_status);
		ISP_IOXGET_8(isp, &ctsrc->ct_tag_val, ctdst->ct_tag_val);
		ISP_IOXGET_8(isp, &ctsrc->ct_tag_type, ctdst->ct_tag_type);
	}
	ISP_IOXGET_32(isp, &ctsrc->ct_flags, ctdst->ct_flags);
	ISP_IOXGET_32(isp, &ctsrc->ct_xfrlen, ctdst->ct_xfrlen);
	ISP_IOXGET_32(isp, &ctsrc->ct_resid, ctdst->ct_resid);
	ISP_IOXGET_16(isp, &ctsrc->ct_timeout, ctdst->ct_timeout);
	ISP_IOXGET_16(isp, &ctsrc->ct_seg_count, ctdst->ct_seg_count);
	for (i = 0; i < ISP_RQDSEG; i++) {
		ISP_IOXGET_32(isp,
		    &ctsrc->ct_dataseg[i].ds_base,
		    ctdst->ct_dataseg[i].ds_base);
		ISP_IOXGET_32(isp,
		    &ctsrc->ct_dataseg[i].ds_count,
		    ctdst->ct_dataseg[i].ds_count);
	}
}

static INLINE void
isp_put_ctio2(struct ispsoftc *isp, ct2_entry_t *ctsrc, ct2_entry_t *ctdst)
{
	int i;
	isp_copy_out_hdr(isp, &ctsrc->ct_header, &ctdst->ct_header);
	ISP_IOXPUT_16(isp, ctsrc->ct_reserved, &ctdst->ct_reserved);
	ISP_IOXPUT_16(isp, ctsrc->ct_fwhandle, &ctdst->ct_fwhandle);
	ISP_IOXPUT_8(isp, ctsrc->ct_lun, &ctdst->ct_lun);
	ISP_IOXPUT_8(isp, ctsrc->ct_iid, &ctdst->ct_iid);
	ISP_IOXPUT_16(isp, ctsrc->ct_rxid, &ctdst->ct_rxid);
	ISP_IOXPUT_16(isp, ctsrc->ct_flags, &ctdst->ct_flags);
	ISP_IOXPUT_16(isp, ctsrc->ct_timeout, &ctdst->ct_timeout);
	ISP_IOXPUT_16(isp, ctsrc->ct_seg_count, &ctdst->ct_seg_count);
	ISP_IOXPUT_32(isp, ctsrc->ct_resid, &ctdst->ct_resid);
	if ((ctsrc->ct_flags & CT2_FLAG_MMASK) == CT2_FLAG_MODE0) {
		ISP_IOXPUT_32(isp, ctsrc->rsp.m0._reserved,
		    &ctdst->rsp.m0._reserved);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m0._reserved2,
		    &ctdst->rsp.m0._reserved2);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m0.ct_scsi_status,
		    &ctdst->rsp.m0.ct_scsi_status);
		ISP_IOXPUT_32(isp, ctsrc->rsp.m0.ct_xfrlen,
		    &ctdst->rsp.m0.ct_xfrlen);
		if (ctsrc->ct_header.rqs_entry_type == RQSTYPE_CTIO2) {
			for (i = 0; i < ISP_RQDSEG_T2; i++) {
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg[i].ds_base,
				    &ctdst->rsp.m0.ct_dataseg[i].ds_base);
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg[i].ds_count,
				    &ctdst->rsp.m0.ct_dataseg[i].ds_count);
			}
		} else if (ctsrc->ct_header.rqs_entry_type == RQSTYPE_CTIO3) {
			for (i = 0; i < ISP_RQDSEG_T3; i++) {
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg64[i].ds_base,
				    &ctdst->rsp.m0.ct_dataseg64[i].ds_base);
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg64[i].ds_basehi,
				    &ctdst->rsp.m0.ct_dataseg64[i].ds_basehi);
				ISP_IOXPUT_32(isp,
				    ctsrc->rsp.m0.ct_dataseg64[i].ds_count,
				    &ctdst->rsp.m0.ct_dataseg64[i].ds_count);
			}
		} else if (ctsrc->ct_header.rqs_entry_type == RQSTYPE_CTIO4) {
			ISP_IOXPUT_16(isp, ctsrc->rsp.m0.ct_dslist.ds_type,
			    &ctdst->rsp.m0.ct_dslist.ds_type);
			ISP_IOXPUT_32(isp, ctsrc->rsp.m0.ct_dslist.ds_segment,
			    &ctdst->rsp.m0.ct_dslist.ds_segment);
			ISP_IOXPUT_32(isp, ctsrc->rsp.m0.ct_dslist.ds_base,
			    &ctdst->rsp.m0.ct_dslist.ds_base);
		}
	} else if ((ctsrc->ct_flags & CT2_FLAG_MMASK) == CT2_FLAG_MODE1) {
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1._reserved,
		    &ctdst->rsp.m1._reserved);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1._reserved2,
		    &ctdst->rsp.m1._reserved2);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1.ct_senselen,
		    &ctdst->rsp.m1.ct_senselen);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1.ct_scsi_status,
		    &ctdst->rsp.m1.ct_scsi_status);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m1.ct_resplen,
		    &ctdst->rsp.m1.ct_resplen);
		for (i = 0; i < MAXRESPLEN; i++) {
			ISP_IOXPUT_8(isp, ctsrc->rsp.m1.ct_resp[i],
			    &ctdst->rsp.m1.ct_resp[i]);
		}
	} else {
		ISP_IOXPUT_32(isp, ctsrc->rsp.m2._reserved,
		    &ctdst->rsp.m2._reserved);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m2._reserved2,
		    &ctdst->rsp.m2._reserved2);
		ISP_IOXPUT_16(isp, ctsrc->rsp.m2._reserved3,
		    &ctdst->rsp.m2._reserved3);
		ISP_IOXPUT_32(isp, ctsrc->rsp.m2.ct_datalen,
		    &ctdst->rsp.m2.ct_datalen);
		ISP_IOXPUT_32(isp, ctsrc->rsp.m2.ct_fcp_rsp_iudata.ds_base,
		    &ctdst->rsp.m2.ct_fcp_rsp_iudata.ds_base);
		ISP_IOXPUT_32(isp, ctsrc->rsp.m2.ct_fcp_rsp_iudata.ds_count,
		    &ctdst->rsp.m2.ct_fcp_rsp_iudata.ds_count);
	}
}

static INLINE void
isp_get_ctio2(struct ispsoftc *isp, ct2_entry_t *ctsrc, ct2_entry_t *ctdst)
{
	int i;
	isp_copy_in_hdr(isp, &ctsrc->ct_header, &ctdst->ct_header);
	ISP_IOXGET_16(isp, &ctsrc->ct_reserved, ctdst->ct_reserved);
	ISP_IOXGET_16(isp, &ctsrc->ct_fwhandle, ctdst->ct_fwhandle);
	ISP_IOXGET_8(isp, &ctsrc->ct_lun, ctdst->ct_lun);
	ISP_IOXGET_8(isp, &ctsrc->ct_iid, ctdst->ct_iid);
	ISP_IOXGET_16(isp, &ctsrc->ct_rxid, ctdst->ct_rxid);
	ISP_IOXGET_16(isp, &ctsrc->ct_flags, ctdst->ct_flags);
	ISP_IOXGET_16(isp, &ctsrc->ct_status, ctdst->ct_status);
	ISP_IOXGET_16(isp, &ctsrc->ct_timeout, ctdst->ct_timeout);
	ISP_IOXGET_16(isp, &ctsrc->ct_seg_count, ctdst->ct_seg_count);
	ISP_IOXGET_32(isp, &ctsrc->ct_reloff, ctdst->ct_reloff);
	ISP_IOXGET_32(isp, &ctsrc->ct_resid, ctdst->ct_resid);
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_32(isp, &ctsrc->rsp.fw._reserved[i],
		    ctdst->rsp.fw._reserved[i]);
	}
	ISP_IOXGET_16(isp, &ctsrc->rsp.fw.ct_scsi_status,
	    ctdst->rsp.fw.ct_scsi_status);
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXGET_8(isp, &ctsrc->rsp.fw.ct_sense[i],
		    ctdst->rsp.fw.ct_sense[i]);
	}
}

static INLINE void
isp_put_enable_lun(struct ispsoftc *isp, lun_entry_t *lesrc, lun_entry_t *ledst)
{
	int i;
	isp_copy_out_hdr(isp, &lesrc->le_header, &ledst->le_header);
	ISP_IOXPUT_32(isp, lesrc->le_reserved, &ledst->le_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, lesrc->le_lun, &ledst->le_rsvd);
		ISP_IOXPUT_8(isp, lesrc->le_rsvd, &ledst->le_lun);
		ISP_IOXPUT_8(isp, lesrc->le_ops, &ledst->le_tgt);
		ISP_IOXPUT_8(isp, lesrc->le_tgt, &ledst->le_ops);
		ISP_IOXPUT_8(isp, lesrc->le_status, &ledst->le_reserved2);
		ISP_IOXPUT_8(isp, lesrc->le_reserved2, &ledst->le_status);
		ISP_IOXPUT_8(isp, lesrc->le_cmd_count, &ledst->le_in_count);
		ISP_IOXPUT_8(isp, lesrc->le_in_count, &ledst->le_cmd_count);
		ISP_IOXPUT_8(isp, lesrc->le_cdb6len, &ledst->le_cdb7len);
		ISP_IOXPUT_8(isp, lesrc->le_cdb7len, &ledst->le_cdb6len);
	} else {
		ISP_IOXPUT_8(isp, lesrc->le_lun, &ledst->le_lun);
		ISP_IOXPUT_8(isp, lesrc->le_rsvd, &ledst->le_rsvd);
		ISP_IOXPUT_8(isp, lesrc->le_ops, &ledst->le_ops);
		ISP_IOXPUT_8(isp, lesrc->le_tgt, &ledst->le_tgt);
		ISP_IOXPUT_8(isp, lesrc->le_status, &ledst->le_status);
		ISP_IOXPUT_8(isp, lesrc->le_reserved2, &ledst->le_reserved2);
		ISP_IOXPUT_8(isp, lesrc->le_cmd_count, &ledst->le_cmd_count);
		ISP_IOXPUT_8(isp, lesrc->le_in_count, &ledst->le_in_count);
		ISP_IOXPUT_8(isp, lesrc->le_cdb6len, &ledst->le_cdb6len);
		ISP_IOXPUT_8(isp, lesrc->le_cdb7len, &ledst->le_cdb7len);
	}
	ISP_IOXPUT_32(isp, lesrc->le_flags, &ledst->le_flags);
	ISP_IOXPUT_16(isp, lesrc->le_timeout, &ledst->le_timeout);
	for (i = 0; i < 20; i++) {
		ISP_IOXPUT_8(isp, lesrc->le_reserved3[i],
		    &ledst->le_reserved3[i]);
	}
}

static INLINE void
isp_get_enable_lun(struct ispsoftc *isp, lun_entry_t *lesrc, lun_entry_t *ledst)
{
	int i;
	isp_copy_in_hdr(isp, &lesrc->le_header, &ledst->le_header);
	ISP_IOXGET_32(isp, &lesrc->le_reserved, ledst->le_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &lesrc->le_lun, ledst->le_rsvd);
		ISP_IOXGET_8(isp, &lesrc->le_rsvd, ledst->le_lun);
		ISP_IOXGET_8(isp, &lesrc->le_ops, ledst->le_tgt);
		ISP_IOXGET_8(isp, &lesrc->le_tgt, ledst->le_ops);
		ISP_IOXGET_8(isp, &lesrc->le_status, ledst->le_reserved2);
		ISP_IOXGET_8(isp, &lesrc->le_reserved2, ledst->le_status);
		ISP_IOXGET_8(isp, &lesrc->le_cmd_count, ledst->le_in_count);
		ISP_IOXGET_8(isp, &lesrc->le_in_count, ledst->le_cmd_count);
		ISP_IOXGET_8(isp, &lesrc->le_cdb6len, ledst->le_cdb7len);
		ISP_IOXGET_8(isp, &lesrc->le_cdb7len, ledst->le_cdb6len);
	} else {
		ISP_IOXGET_8(isp, &lesrc->le_lun, ledst->le_lun);
		ISP_IOXGET_8(isp, &lesrc->le_rsvd, ledst->le_rsvd);
		ISP_IOXGET_8(isp, &lesrc->le_ops, ledst->le_ops);
		ISP_IOXGET_8(isp, &lesrc->le_tgt, ledst->le_tgt);
		ISP_IOXGET_8(isp, &lesrc->le_status, ledst->le_status);
		ISP_IOXGET_8(isp, &lesrc->le_reserved2, ledst->le_reserved2);
		ISP_IOXGET_8(isp, &lesrc->le_cmd_count, ledst->le_cmd_count);
		ISP_IOXGET_8(isp, &lesrc->le_in_count, ledst->le_in_count);
		ISP_IOXGET_8(isp, &lesrc->le_cdb6len, ledst->le_cdb6len);
		ISP_IOXGET_8(isp, &lesrc->le_cdb7len, ledst->le_cdb7len);
	}
	ISP_IOXGET_32(isp, &lesrc->le_flags, ledst->le_flags);
	ISP_IOXGET_16(isp, &lesrc->le_timeout, ledst->le_timeout);
	for (i = 0; i < 20; i++) {
		ISP_IOXGET_8(isp, &lesrc->le_reserved3[i],
		    ledst->le_reserved3[i]);
	}
}

static INLINE void
isp_put_notify(struct ispsoftc *isp, in_entry_t *insrc, in_entry_t *indst)
{
	int i;
	isp_copy_out_hdr(isp, &insrc->in_header, &indst->in_header);
	ISP_IOXPUT_32(isp, insrc->in_reserved, &indst->in_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, insrc->in_lun, &indst->in_iid);
		ISP_IOXPUT_8(isp, insrc->in_iid, &indst->in_lun);
		ISP_IOXPUT_8(isp, insrc->in_reserved2, &indst->in_tgt);
		ISP_IOXPUT_8(isp, insrc->in_tgt, &indst->in_reserved2);
		ISP_IOXPUT_8(isp, insrc->in_status, &indst->in_rsvd2);
		ISP_IOXPUT_8(isp, insrc->in_rsvd2, &indst->in_status);
		ISP_IOXPUT_8(isp, insrc->in_tag_val, &indst->in_tag_type);
		ISP_IOXPUT_8(isp, insrc->in_tag_type, &indst->in_tag_val);
	} else {
		ISP_IOXPUT_8(isp, insrc->in_lun, &indst->in_lun);
		ISP_IOXPUT_8(isp, insrc->in_iid, &indst->in_iid);
		ISP_IOXPUT_8(isp, insrc->in_reserved2, &indst->in_reserved2);
		ISP_IOXPUT_8(isp, insrc->in_tgt, &indst->in_tgt);
		ISP_IOXPUT_8(isp, insrc->in_status, &indst->in_status);
		ISP_IOXPUT_8(isp, insrc->in_rsvd2, &indst->in_rsvd2);
		ISP_IOXPUT_8(isp, insrc->in_tag_val, &indst->in_tag_val);
		ISP_IOXPUT_8(isp, insrc->in_tag_type, &indst->in_tag_type);
	}
	ISP_IOXPUT_32(isp, insrc->in_flags, &indst->in_flags);
	ISP_IOXPUT_16(isp, insrc->in_seqid, &indst->in_seqid);
	for (i = 0; i < IN_MSGLEN; i++) {
		ISP_IOXPUT_8(isp, insrc->in_msg[i], &indst->in_msg[i]);
	}
	for (i = 0; i < IN_RSVDLEN; i++) {
		ISP_IOXPUT_8(isp, insrc->in_reserved3[i],
		    &indst->in_reserved3[i]);
	}
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXPUT_8(isp, insrc->in_sense[i],
		    &indst->in_sense[i]);
	}
}

static INLINE void
isp_get_notify(struct ispsoftc *isp, in_entry_t *insrc, in_entry_t *indst)
{
	int i;
	isp_copy_in_hdr(isp, &insrc->in_header, &indst->in_header);
	ISP_IOXGET_32(isp, &insrc->in_reserved, indst->in_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &insrc->in_lun, indst->in_iid);
		ISP_IOXGET_8(isp, &insrc->in_iid, indst->in_lun);
		ISP_IOXGET_8(isp, &insrc->in_reserved2, indst->in_tgt);
		ISP_IOXGET_8(isp, &insrc->in_tgt, indst->in_reserved2);
		ISP_IOXGET_8(isp, &insrc->in_status, indst->in_rsvd2);
		ISP_IOXGET_8(isp, &insrc->in_rsvd2, indst->in_status);
		ISP_IOXGET_8(isp, &insrc->in_tag_val, indst->in_tag_type);
		ISP_IOXGET_8(isp, &insrc->in_tag_type, indst->in_tag_val);
	} else {
		ISP_IOXGET_8(isp, &insrc->in_lun, indst->in_lun);
		ISP_IOXGET_8(isp, &insrc->in_iid, indst->in_iid);
		ISP_IOXGET_8(isp, &insrc->in_reserved2, indst->in_reserved2);
		ISP_IOXGET_8(isp, &insrc->in_tgt, indst->in_tgt);
		ISP_IOXGET_8(isp, &insrc->in_status, indst->in_status);
		ISP_IOXGET_8(isp, &insrc->in_rsvd2, indst->in_rsvd2);
		ISP_IOXGET_8(isp, &insrc->in_tag_val, indst->in_tag_val);
		ISP_IOXGET_8(isp, &insrc->in_tag_type, indst->in_tag_type);
	}
	ISP_IOXGET_32(isp, &insrc->in_flags, indst->in_flags);
	ISP_IOXGET_16(isp, &insrc->in_seqid, indst->in_seqid);
	for (i = 0; i < IN_MSGLEN; i++) {
		ISP_IOXGET_8(isp, &insrc->in_msg[i], indst->in_msg[i]);
	}
	for (i = 0; i < IN_RSVDLEN; i++) {
		ISP_IOXGET_8(isp, &insrc->in_reserved3[i],
		    indst->in_reserved3[i]);
	}
	for (i = 0; i < QLTM_SENSELEN; i++) {
		ISP_IOXGET_8(isp, &insrc->in_sense[i],
		    indst->in_sense[i]);
	}
}

static INLINE void
isp_put_notify_fc(struct ispsoftc *isp, in_fcentry_t *insrc,
    in_fcentry_t *indst)
{
	isp_copy_out_hdr(isp, &insrc->in_header, &indst->in_header);
	ISP_IOXPUT_32(isp, insrc->in_reserved, &indst->in_reserved);
	ISP_IOXPUT_8(isp, insrc->in_lun, &indst->in_lun);
	ISP_IOXPUT_8(isp, insrc->in_iid, &indst->in_iid);
	ISP_IOXPUT_16(isp, insrc->in_scclun, &indst->in_scclun);
	ISP_IOXPUT_32(isp, insrc->in_reserved2, &indst->in_reserved2);
	ISP_IOXPUT_16(isp, insrc->in_status, &indst->in_status);
	ISP_IOXPUT_16(isp, insrc->in_task_flags, &indst->in_task_flags);
	ISP_IOXPUT_16(isp, insrc->in_seqid, &indst->in_seqid);
}

static INLINE void
isp_get_notify_fc(struct ispsoftc *isp, in_fcentry_t *insrc,
    in_fcentry_t *indst)
{
	isp_copy_in_hdr(isp, &insrc->in_header, &indst->in_header);
	ISP_IOXGET_32(isp, &insrc->in_reserved, indst->in_reserved);
	ISP_IOXGET_8(isp, &insrc->in_lun, indst->in_lun);
	ISP_IOXGET_8(isp, &insrc->in_iid, indst->in_iid);
	ISP_IOXGET_16(isp, &insrc->in_scclun, indst->in_scclun);
	ISP_IOXGET_32(isp, &insrc->in_reserved2, indst->in_reserved2);
	ISP_IOXGET_16(isp, &insrc->in_status, indst->in_status);
	ISP_IOXGET_16(isp, &insrc->in_task_flags, indst->in_task_flags);
	ISP_IOXGET_16(isp, &insrc->in_seqid, indst->in_seqid);
}

static INLINE void
isp_put_notify_ack(struct ispsoftc *isp, na_entry_t *nasrc,  na_entry_t *nadst)
{
	int i;
	isp_copy_out_hdr(isp, &nasrc->na_header, &nadst->na_header);
	ISP_IOXPUT_32(isp, nasrc->na_reserved, &nadst->na_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXPUT_8(isp, nasrc->na_lun, &nadst->na_iid);
		ISP_IOXPUT_8(isp, nasrc->na_iid, &nadst->na_lun);
		ISP_IOXPUT_8(isp, nasrc->na_status, &nadst->na_event);
		ISP_IOXPUT_8(isp, nasrc->na_event, &nadst->na_status);
	} else {
		ISP_IOXPUT_8(isp, nasrc->na_lun, &nadst->na_lun);
		ISP_IOXPUT_8(isp, nasrc->na_iid, &nadst->na_iid);
		ISP_IOXPUT_8(isp, nasrc->na_status, &nadst->na_status);
		ISP_IOXPUT_8(isp, nasrc->na_event, &nadst->na_event);
	}
	ISP_IOXPUT_32(isp, nasrc->na_flags, &nadst->na_flags);
	for (i = 0; i < NA_RSVDLEN; i++) {
		ISP_IOXPUT_16(isp, nasrc->na_reserved3[i],
		    &nadst->na_reserved3[i]);
	}
}

static INLINE void
isp_get_notify_ack(struct ispsoftc *isp, na_entry_t *nasrc, na_entry_t *nadst)
{
	int i;
	isp_copy_in_hdr(isp, &nasrc->na_header, &nadst->na_header);
	ISP_IOXGET_32(isp, &nasrc->na_reserved, nadst->na_reserved);
	if (ISP_IS_SBUS(isp)) {
		ISP_IOXGET_8(isp, &nasrc->na_lun, nadst->na_iid);
		ISP_IOXGET_8(isp, &nasrc->na_iid, nadst->na_lun);
		ISP_IOXGET_8(isp, &nasrc->na_status, nadst->na_event);
		ISP_IOXGET_8(isp, &nasrc->na_event, nadst->na_status);
	} else {
		ISP_IOXGET_8(isp, &nasrc->na_lun, nadst->na_lun);
		ISP_IOXGET_8(isp, &nasrc->na_iid, nadst->na_iid);
		ISP_IOXGET_8(isp, &nasrc->na_status, nadst->na_status);
		ISP_IOXGET_8(isp, &nasrc->na_event, nadst->na_event);
	}
	ISP_IOXGET_32(isp, &nasrc->na_flags, nadst->na_flags);
	for (i = 0; i < NA_RSVDLEN; i++) {
		ISP_IOXGET_16(isp, &nasrc->na_reserved3[i],
		    nadst->na_reserved3[i]);
	}
}

static INLINE void
isp_put_notify_ack_fc(struct ispsoftc *isp, na_fcentry_t *nasrc,
    na_fcentry_t *nadst)
{
	int i;
	isp_copy_out_hdr(isp, &nasrc->na_header, &nadst->na_header);
	ISP_IOXPUT_32(isp, nasrc->na_reserved, &nadst->na_reserved);
	ISP_IOXPUT_8(isp, nasrc->na_lun, &nadst->na_lun);
	ISP_IOXPUT_8(isp, nasrc->na_iid, &nadst->na_iid);
	ISP_IOXPUT_16(isp, nasrc->na_scclun, &nadst->na_scclun);
	ISP_IOXPUT_16(isp, nasrc->na_flags, &nadst->na_flags);
	ISP_IOXPUT_16(isp, nasrc->na_reserved2, &nadst->na_reserved2);
	ISP_IOXPUT_16(isp, nasrc->na_status, &nadst->na_status);
	ISP_IOXPUT_16(isp, nasrc->na_task_flags, &nadst->na_task_flags);
	ISP_IOXPUT_16(isp, nasrc->na_seqid, &nadst->na_seqid);
	for (i = 0; i < NA2_RSVDLEN; i++) {
		ISP_IOXPUT_16(isp, nasrc->na_reserved3[i],
		    &nadst->na_reserved3[i]);
	}
}

static INLINE void
isp_get_notify_ack_fc(struct ispsoftc *isp, na_fcentry_t *nasrc,
    na_fcentry_t *nadst)
{
	int i;
	isp_copy_in_hdr(isp, &nasrc->na_header, &nadst->na_header);
	ISP_IOXGET_32(isp, &nasrc->na_reserved, nadst->na_reserved);
	ISP_IOXGET_8(isp, &nasrc->na_lun, nadst->na_lun);
	ISP_IOXGET_8(isp, &nasrc->na_iid, nadst->na_iid);
	ISP_IOXGET_16(isp, &nasrc->na_scclun, nadst->na_scclun);
	ISP_IOXGET_16(isp, &nasrc->na_flags, nadst->na_flags);
	ISP_IOXGET_16(isp, &nasrc->na_reserved2, nadst->na_reserved2);
	ISP_IOXGET_16(isp, &nasrc->na_status, nadst->na_status);
	ISP_IOXGET_16(isp, &nasrc->na_task_flags, nadst->na_task_flags);
	ISP_IOXGET_16(isp, &nasrc->na_seqid, nadst->na_seqid);
	for (i = 0; i < NA2_RSVDLEN; i++) {
		ISP_IOXGET_16(isp, &nasrc->na_reserved3[i],
		    nadst->na_reserved3[i]);
	}
}
#endif
@


1.2.2.5
log
@Sync the SMP branch with 3.3
@
text
@a271 2
isp_get_rio2(struct ispsoftc *, isp_rio2_t *, isp_rio2_t *);
static INLINE void
a275 2
isp_get_ct_hdr(struct ispsoftc *isp, ct_hdr_t *, ct_hdr_t *);
static INLINE void
a277 6
isp_put_gid_ft_request(struct ispsoftc *, sns_gid_ft_req_t *,
    sns_gid_ft_req_t *);
static INLINE void
isp_put_gxn_id_request(struct ispsoftc *, sns_gxn_id_req_t *,
    sns_gxn_id_req_t *);
static INLINE void
d280 1
a280 11
isp_get_gid_ft_response(struct ispsoftc *, sns_gid_ft_rsp_t *,
    sns_gid_ft_rsp_t *, int);
static INLINE void
isp_get_gxn_id_response(struct ispsoftc *, sns_gxn_id_rsp_t *,
    sns_gxn_id_rsp_t *);
static INLINE void
isp_get_gff_id_response(struct ispsoftc *, sns_gff_id_rsp_t *,
    sns_gff_id_rsp_t *);
static INLINE void
isp_get_ga_nxt_response(struct ispsoftc *, sns_ga_nxt_rsp_t *,
    sns_ga_nxt_rsp_t *);
d380 1
a380 1
	u_int8_t type;
d459 1
a459 1
	for (i = 0; i < ISP_RQDSEG_T3; i++) {
a558 16
isp_get_rio2(struct ispsoftc *isp, isp_rio2_t *r2src, isp_rio2_t *r2dst)
{
	int i;
	isp_copy_in_hdr(isp, &r2src->req_header, &r2dst->req_header);
	if (r2dst->req_header.rqs_seqno > 30)
		r2dst->req_header.rqs_seqno = 30;
	for (i = 0; i < r2dst->req_header.rqs_seqno; i++) {
		ISP_IOXGET_16(isp, &r2src->req_handles[i],
		    r2dst->req_handles[i]);
	}
	while (i < 30) {
		r2dst->req_handles[i++] = 0;
	}
}

static INLINE void
a657 29

/*
 * CT_HDR canonicalization- only needed for SNS responses
 */
static INLINE void
isp_get_ct_hdr(struct ispsoftc *isp, ct_hdr_t *src, ct_hdr_t *dst)
{
	ISP_IOXGET_8(isp, &src->ct_revision, dst->ct_revision);
	ISP_IOXGET_8(isp, &src->ct_portid[0], dst->ct_portid[0]);
	ISP_IOXGET_8(isp, &src->ct_portid[1], dst->ct_portid[1]);
	ISP_IOXGET_8(isp, &src->ct_portid[2], dst->ct_portid[2]);
	ISP_IOXGET_8(isp, &src->ct_fcs_type, dst->ct_fcs_type);
	ISP_IOXGET_8(isp, &src->ct_fcs_subtype, dst->ct_fcs_subtype);
	ISP_IOXGET_8(isp, &src->ct_options, dst->ct_options);
	ISP_IOXGET_8(isp, &src->ct_res0, dst->ct_res0);
	ISP_IOXGET_16(isp, &src->ct_response, dst->ct_response);
	dst->ct_response = (dst->ct_response << 8) | (dst->ct_response >> 8);
	ISP_IOXGET_16(isp, &src->ct_resid, dst->ct_resid);
	dst->ct_resid = (dst->ct_resid << 8) | (dst->ct_resid >> 8);
	ISP_IOXGET_8(isp, &src->ct_res1, dst->ct_res1);
	ISP_IOXGET_8(isp, &src->ct_reason, dst->ct_reason);
	ISP_IOXGET_8(isp, &src->ct_explanation, dst->ct_explanation);
	ISP_IOXGET_8(isp, &src->ct_vunique, dst->ct_vunique);
}

/*
 * Generic SNS request - not particularly useful since the per-command data
 * isn't always 16 bit words.
 */
a673 40
isp_put_gid_ft_request(struct ispsoftc *isp, sns_gid_ft_req_t *src,
    sns_gid_ft_req_t *dst)
{
	ISP_IOXPUT_16(isp, src->snscb_rblen, &dst->snscb_rblen);
	ISP_IOXPUT_16(isp, src->snscb_res0, &dst->snscb_res0);
	ISP_IOXPUT_16(isp, src->snscb_addr[0], &dst->snscb_addr[0]);
	ISP_IOXPUT_16(isp, src->snscb_addr[1], &dst->snscb_addr[1]);
	ISP_IOXPUT_16(isp, src->snscb_addr[2], &dst->snscb_addr[2]);
	ISP_IOXPUT_16(isp, src->snscb_addr[3], &dst->snscb_addr[3]);
	ISP_IOXPUT_16(isp, src->snscb_sblen, &dst->snscb_sblen);
	ISP_IOXPUT_16(isp, src->snscb_res1, &dst->snscb_res1);
	ISP_IOXPUT_16(isp, src->snscb_cmd, &dst->snscb_cmd);
	ISP_IOXPUT_16(isp, src->snscb_mword_div_2, &dst->snscb_mword_div_2);
	ISP_IOXPUT_32(isp, src->snscb_res3, &dst->snscb_res3);
	ISP_IOXPUT_32(isp, src->snscb_fc4_type, &dst->snscb_fc4_type);
}

static INLINE void
isp_put_gxn_id_request(struct ispsoftc *isp, sns_gxn_id_req_t *src,
    sns_gxn_id_req_t *dst)
{
	ISP_IOXPUT_16(isp, src->snscb_rblen, &dst->snscb_rblen);
	ISP_IOXPUT_16(isp, src->snscb_res0, &dst->snscb_res0);
	ISP_IOXPUT_16(isp, src->snscb_addr[0], &dst->snscb_addr[0]);
	ISP_IOXPUT_16(isp, src->snscb_addr[1], &dst->snscb_addr[1]);
	ISP_IOXPUT_16(isp, src->snscb_addr[2], &dst->snscb_addr[2]);
	ISP_IOXPUT_16(isp, src->snscb_addr[3], &dst->snscb_addr[3]);
	ISP_IOXPUT_16(isp, src->snscb_sblen, &dst->snscb_sblen);
	ISP_IOXPUT_16(isp, src->snscb_res1, &dst->snscb_res1);
	ISP_IOXPUT_16(isp, src->snscb_cmd, &dst->snscb_cmd);
	ISP_IOXPUT_16(isp, src->snscb_res2, &dst->snscb_res2);
	ISP_IOXPUT_32(isp, src->snscb_res3, &dst->snscb_res3);
	ISP_IOXPUT_32(isp, src->snscb_portid, &dst->snscb_portid);
}

/*
 * Generic SNS response - not particularly useful since the per-command data
 * isn't always 16 bit words.
 */
static INLINE void
d678 3
a680 1
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
d696 1
a696 2
isp_get_gid_ft_response(struct ispsoftc *isp, sns_gid_ft_rsp_t *src,
    sns_gid_ft_rsp_t *dst, int nwords)
d699 2
a700 14
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	for (i = 0; i < nwords; i++) {
		int j;
		ISP_IOXGET_8(isp,
		    &src->snscb_ports[i].control,
		    dst->snscb_ports[i].control);
		for (j = 0; j < 3; j++) {
			ISP_IOXGET_8(isp,
			    &src->snscb_ports[i].portid[j],
			    dst->snscb_ports[i].portid[j]);
		}
		if (dst->snscb_ports[i].control & 0x80) {
			break;
		}
a701 30
}

static INLINE void
isp_get_gxn_id_response(struct ispsoftc *isp, sns_gxn_id_rsp_t *src,
    sns_gxn_id_rsp_t *dst)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	for (i = 0; i < 8; i++)
		ISP_IOXGET_8(isp, &src->snscb_wwn[i], dst->snscb_wwn[i]);
}

static INLINE void
isp_get_gff_id_response(struct ispsoftc *isp, sns_gff_id_rsp_t *src,
    sns_gff_id_rsp_t *dst)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
	for (i = 0; i < 32; i++) {
		ISP_IOXGET_32(isp, &src->snscb_fc4_features[i],
		    dst->snscb_fc4_features[i]);
	}
}

static INLINE void
isp_get_ga_nxt_response(struct ispsoftc *isp, sns_ga_nxt_rsp_t *src,
    sns_ga_nxt_rsp_t *dst)
{
	int i;
	isp_get_ct_hdr(isp, &src->snscb_cthdr, &dst->snscb_cthdr);
d841 2
a842 5
	for (i = 0; i < 4; i++) {
		ISP_IOXPUT_16(isp, atsrc->at_wwpn[i], &atdst->at_wwpn[i]);
	}
	for (i = 0; i < 6; i++) {
		ISP_IOXPUT_16(isp, atsrc->at_reserved2[i],
d868 2
a869 5
	for (i = 0; i < 4; i++) {
		ISP_IOXGET_16(isp, &atsrc->at_wwpn[i], atdst->at_wwpn[i]);
	}
	for (i = 0; i < 6; i++) {
		ISP_IOXGET_16(isp, &atsrc->at_reserved2[i],
a970 1
	ISP_IOXPUT_32(isp, ctsrc->ct_reloff, &ctdst->ct_reloff);
@


1.1
log
@Far too many things to note- a complete new revision coming in including
FABRIC support...
@
text
@d1 1
a1 1
/*	$OpenBSD: $ */
d49 1
a49 1
	char *p, buf[172];
@

