head	1.20;
access;
symbols
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.8
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.18
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.14
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.16
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.12
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.10
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.14
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.12
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.10
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.8
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.4
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.16
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.12
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2013.10.28.12.33.32;	author mpi;	state dead;
branches;
next	1.19;

1.19
date	2010.09.20.07.40.41;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.02.22.50.00;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.04.45.58;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.02.26.01.44.33;	author art;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	96.11.28.23.27.52;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.11.12.20.30.22;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.10.31.01.01.38;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.10.16.12.41.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.21.22.27.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.18.10.22.29;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.00.27.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.12.41.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.23.47.25;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.32;	author deraadt;	state Exp;
branches;
next	;

1.11.6.1
date	2001.07.04.10.41.04;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@tedu FDDI support and the 3 flavors the driver for DEC devices, even
miod@@ cannot find two boards using the same media.

With precious punctuation review from guenther@@, thanks!

ok deraadt@@, henning@@
@
text
@/*	$OpenBSD: pdqvar.h,v 1.19 2010/09/20 07:40:41 deraadt Exp $	*/
/*	$NetBSD: pdqvar.h,v 1.11 1996/10/25 21:33:37 cgd Exp $	*/

/*-
 * Copyright (c) 1995, 1996 Matt Thomas <matt@@3am-software.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Id: pdqvar.h,v 1.18 1996/06/07 20:02:25 thomas Exp
 *
 */

/*
 * DEC PDQ FDDI Controller; PDQ O/S dependent definitions
 *
 * Written by Matt Thomas
 *
 */

#ifndef _PDQ_OS_H
#define	_PDQ_OS_H

#define	PDQ_OS_TX_TIMEOUT		5	/* seconds */

typedef struct _pdq_t pdq_t;
typedef struct _pdq_csrs_t pdq_csrs_t;
typedef struct _pdq_pci_csrs_t pdq_pci_csrs_t;
typedef struct _pdq_lanaddr_t pdq_lanaddr_t;
typedef unsigned int pdq_uint32_t;
typedef unsigned short pdq_uint16_t;
typedef unsigned char pdq_uint8_t;
typedef enum _pdq_boolean_t pdq_boolean_t;
typedef enum _pdq_type_t pdq_type_t;
typedef enum _pdq_state_t pdq_state_t;

enum _pdq_type_t {
    PDQ_DEFPA,		/* PCI-bus */
    PDQ_DEFEA,		/* EISA-bus */
    PDQ_DEFTA,		/* TurboChannel */
    PDQ_DEFAA,		/* FutureBus+ */
    PDQ_DEFQA		/* Q-bus */
};

#if defined(PDQTEST)
#include <pdq_os_test.h>
#elif defined(__FreeBSD__) || defined(__bsdi__) || defined(__NetBSD__) \
    || defined(__OpenBSD__)

#include <sys/param.h>
#include <sys/systm.h>
#ifndef M_MCAST
#include <sys/mbuf.h>
#endif /* M_CAST */
#include <sys/malloc.h>
#include <uvm/uvm_extern.h>

#define	PDQ_USE_MBUFS
#if defined(__NetBSD__) || defined(__OpenBSD__)
#define	PDQ_OS_PREFIX			"%s: "
#define	PDQ_OS_PREFIX_ARGS		pdq->pdq_os_name
#else
#define	PDQ_OS_PREFIX			"%s%d: "
#define	PDQ_OS_PREFIX_ARGS		pdq->pdq_os_name, pdq->pdq_unit
#endif
#define	PDQ_OS_PAGESIZE			NBPG
#define	PDQ_OS_USEC_DELAY(n)		DELAY(n)
#define	PDQ_OS_MEMZERO(p, n)		bzero((caddr_t)(p), (n))
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(__alpha__)
#define	PDQ_OS_VA_TO_PA(pdq, p)		(alpha_XXX_dmamap((vaddr_t)p))
#else
#define	PDQ_OS_VA_TO_PA(pdq, p)		vtophys((vaddr_t)p)
#endif
#define	PDQ_OS_MEMALLOC(n)		malloc(n, M_DEVBUF, M_NOWAIT)
#define	PDQ_OS_MEMFREE(p, n)		free((void *) p, M_DEVBUF)
#ifdef __FreeBSD__
#define	PDQ_OS_MEMALLOC_CONTIG(n)	vm_page_alloc_contig(n, 0, 0xffffffff, PAGE_SIZE)
#define	PDQ_OS_MEMFREE_CONTIG(p, n)	kmem_free(kernel_map, (vm_offset_t) p, n)
#else
#define	PDQ_OS_MEMALLOC_CONTIG(n)	uvm_km_alloc(kernel_map, round_page(n))
#define	PDQ_OS_MEMFREE_CONTIG(p, n)	uvm_km_free(kernel_map, (vaddr_t) p, n)
#endif /* __FreeBSD__ */

#if defined(__FreeBSD__)
#include <vm/pmap.h>
#include <vm/vm_extern.h>
#include <machine/cpufunc.h>
#include <machine/clock.h>
typedef void ifnet_ret_t;
typedef int ioctl_cmd_t;
typedef enum { PDQ_BUS_EISA, PDQ_BUS_PCI } pdq_bus_t;
typedef	u_int16_t pdq_bus_ioport_t;
typedef volatile pdq_uint32_t *pdq_bus_memaddr_t;
typedef pdq_bus_memaddr_t pdq_bus_memoffset_t;
#if BSD >= 199506	/* __FreeBSD__ */
#define	PDQ_BPF_MTAP(sc, m, dir)	bpf_mtap(&(sc)->sc_if, m, dir)
#define	PDQ_BPFATTACH(sc, t, s)		bpfattach(&(sc)->sc_if, t, s)
#endif


#elif defined(__bsdi__)
#include <machine/inline.h>
typedef int ifnet_ret_t;
typedef int ioctl_cmd_t;
typedef enum { PDQ_BUS_EISA, PDQ_BUS_PCI } pdq_bus_t;
typedef	u_int16_t pdq_bus_ioport_t;
typedef volatile pdq_uint32_t *pdq_bus_memaddr_t;
typedef pdq_bus_memaddr_t pdq_bus_memoffset_t;


#elif defined(__NetBSD__) || defined(__OpenBSD__)
#include <machine/bus.h>
#include <machine/intr.h>
#define	PDQ_OS_PTR_FMT		"%p"
typedef void ifnet_ret_t;
typedef u_long ioctl_cmd_t;
typedef	bus_space_tag_t pdq_bus_t;
typedef	bus_space_handle_t pdq_bus_ioport_t;
typedef	bus_space_handle_t pdq_bus_memaddr_t;
typedef pdq_uint32_t pdq_bus_memoffset_t;
#define	PDQ_OS_IOMEM
#define PDQ_OS_IORD_32(t, base, offset)		bus_space_read_4  (t, base, offset)
#define PDQ_OS_IOWR_32(t, base, offset, data)	bus_space_write_4 (t, base, offset, data)
#define PDQ_OS_IORD_8(t, base, offset)		bus_space_read_1  (t, base, offset)
#define PDQ_OS_IOWR_8(t, base, offset, data)	bus_space_write_1 (t, base, offset, data)
#define PDQ_OS_MEMRD_32(t, base, offset)	bus_space_read_4(t, base, offset)
#define PDQ_OS_MEMWR_32(t, base, offset, data)	bus_space_write_4(t, base, offset, data)
#define	PDQ_CSR_OFFSET(base, offset)		(0 + (offset)*sizeof(pdq_uint32_t))

#if defined(PDQ_IOMAPPED)
#define	PDQ_CSR_WRITE(csr, name, data)		PDQ_OS_IOWR_32((csr)->csr_bus, (csr)->csr_base, (csr)->name, data)
#define	PDQ_CSR_READ(csr, name)			PDQ_OS_IORD_32((csr)->csr_bus, (csr)->csr_base, (csr)->name)
#else
#define	PDQ_CSR_WRITE(csr, name, data)		PDQ_OS_MEMWR_32((csr)->csr_bus, (csr)->csr_base, (csr)->name, data)
#define	PDQ_CSR_READ(csr, name)			PDQ_OS_MEMRD_32((csr)->csr_bus, (csr)->csr_base, (csr)->name)
#endif

#endif

#if !defined(PDQ_BPF_MTAP)
#define	PDQ_BPF_MTAP(sc, m, dir) bpf_mtap((sc)->sc_bpf, m, dir)
#endif

#if !defined(PDQ_BPFATTACH)
#define	PDQ_BPFATTACH(sc, t, s)bpfattach(&(sc)->sc_bpf, &(sc)->sc_if, t, s)
#endif

#if !defined(PDQ_OS_PTR_FMT)
#define	PDQ_OS_PTR_FMT	"0x%x"
#endif

#if !defined(PDQ_OS_IOMEM)
#define PDQ_OS_IORD_32(t, base, offset)		inl((base) + (offset))
#define PDQ_OS_IOWR_32(t, base, offset, data)	outl((base) + (offset), data)
#define PDQ_OS_IORD_8(t, base, offset)		inb((base) + (offset))
#define PDQ_OS_IOWR_8(t, base, offset, data)	outb((base) + (offset), data)
#define PDQ_OS_MEMRD_32(t, base, offset)	(0 + *((base) + (offset)))
#define PDQ_OS_MEMWR_32(t, base, offset, data)	do *((base) + (offset)) = (data); while (0)
#endif
#ifndef PDQ_CSR_OFFSET
#define	PDQ_CSR_OFFSET(base, offset)		(0 + (base) + (offset))
#endif

#ifndef PDQ_CSR_WRITE
#define	PDQ_CSR_WRITE(csr, name, data)		PDQ_OS_MEMWR_32((csr)->csr_bus, (csr)->name, 0, data)
#define	PDQ_CSR_READ(csr, name)			PDQ_OS_MEMRD_32((csr)->csr_bus, (csr)->name, 0)
#endif

#if !defined(PDQ_HWSUPPORT)

typedef struct {
#if defined(__bsdi__)
    struct device sc_dev;		/* base device */
    struct isadev sc_id;		/* ISA device */
    struct intrhand sc_ih;		/* interrupt vectoring */
    struct atshutdown sc_ats;		/* shutdown routine */
#elif defined(__NetBSD__) || defined(__OpenBSD__)
    struct device sc_dev;		/* base device */
    void *sc_ih;			/* interrupt vectoring */
    bus_space_tag_t sc_csrtag;		/* space tag for CSRs */
    bus_space_handle_t sc_csrhandle;	/* space handle for CSRs */
#define sc_bc		sc_csrtag
#define sc_membase	sc_csrhandle
    bus_space_tag_t sc_iotag;		/* i/o space tag */
    bus_space_handle_t sc_iobase;	/* i/o space handle */
#elif defined(__FreeBSD__)
    struct kern_devconf *sc_kdc;	/* freebsd cruft */
#endif
    struct arpcom sc_arpcom;
#define	sc_if		sc_arpcom.ac_if
    pdq_t *sc_pdq;
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
    pdq_bus_ioport_t sc_iobase;
#ifdef PDQ_IOMAPPED
#define	sc_membase	sc_iobase
#else
    pdq_bus_memaddr_t sc_membase;
#endif
    pdq_bus_t sc_bc;
#endif /* ! __NetBSD__ && ! __OpenBSD__ */
#if !defined(__bsdi__) || _BSDI_VERSION >= 199401
#define	sc_bpf		sc_if.if_bpf
#else
    caddr_t sc_bpf;
#endif
} pdq_softc_t;


extern void pdq_ifreset(pdq_softc_t *sc);
extern void pdq_ifinit(pdq_softc_t *sc);
extern void pdq_ifwatchdog(struct ifnet *ifp);
extern ifnet_ret_t pdq_ifstart(struct ifnet *ifp);
extern int pdq_ifioctl(struct ifnet *ifp, ioctl_cmd_t cmd, caddr_t data);
extern void pdq_ifattach(pdq_softc_t *sc, ifnet_ret_t (*ifwatchdog)(int unit));
#endif /* !PDQ_HWSUPPORT */


#elif defined(DLPI_PDQ)
#include <sys/param.h>
#include <sys/kmem.h>
#include <sys/ddi.h>
#include <sys/stream.h>

#define	PDQ_USE_STREAMS
#define	PDQ_OS_PREFIX			"%s board %d "
#define	PDQ_OS_PREFIX_ARGS		pdq->pdq_os_name, pdq->pdq_unit

#define	PDQ_OS_PAGESIZE			PAGESIZE
#define	PDQ_OS_USEC_DELAY(n)		drv_usecwait(n)
#define	PDQ_OS_MEMZERO(p, n)		bzero((caddr_t)(p), (n))
#define	PDQ_OS_VA_TO_PA(pdq, p)		vtop((caddr_t)p, NULL)
#define	PDQ_OS_MEMALLOC(n)		kmem_zalloc(n, KM_NOSLEEP)
#define	PDQ_OS_MEMFREE(p, n)		kmem_free((caddr_t) p, n)
#define	PDQ_OS_MEMALLOC_CONTIG(n)	kmem_zalloc_physreq(n, decfddiphysreq_db, KM_NOSLEEP)
#define	PDQ_OS_MEMFREE_CONTIG(p, n)	PDQ_OS_MEMFREE(p, n)

extern physreq_t *decfddiphysreq_db;
extern physreq_t *decfddiphysreq_mblk;

#define	PDQ_OS_DATABUF_ALLOC(b)		((void) (((b) = allocb_physreq(PDQ_OS_DATABUF_SIZE, BPRI_MED, decfddiphysreq_mblk)) && ((b)->b_wptr = (b)->b_rptr + PDQ_OS_DATABUF_SIZE)))

#define PDQ_OS_IORD_8(port)		inb(port)
#define PDQ_OS_IOWR_8(port, data)	outb(port, data)
#endif


#ifdef PDQ_USE_MBUFS
#define	PDQ_OS_DATABUF_SIZE			(MCLBYTES)
#define	PDQ_OS_DATABUF_FREE(b)			(m_freem(b))
#define	PDQ_OS_DATABUF_NEXT(b)			((b)->m_next)
#define	PDQ_OS_DATABUF_NEXT_SET(b, b1)		((b)->m_next = (b1))
#define	PDQ_OS_DATABUF_NEXTPKT(b)		((b)->m_nextpkt)
#define	PDQ_OS_DATABUF_NEXTPKT_SET(b, b1)	((b)->m_nextpkt = (b1))
#define	PDQ_OS_DATABUF_LEN(b)			((b)->m_len)
#define	PDQ_OS_DATABUF_LEN_SET(b, n)		((b)->m_len = (n))
/* #define	PDQ_OS_DATABUF_LEN_ADJ(b, n)		((b)->m_len += (n)) */
#define	PDQ_OS_DATABUF_PTR(b)			(mtod((b), pdq_uint8_t *))
#define	PDQ_OS_DATABUF_ADJ(b, n)		((b)->m_data += (n), (b)->m_len -= (n))
typedef struct mbuf PDQ_OS_DATABUF_T;

#define	PDQ_OS_DATABUF_ALLOC(b) do { \
    PDQ_OS_DATABUF_T *x_m0; \
    MGETHDR(x_m0, M_DONTWAIT, MT_DATA); \
    if (x_m0 != NULL) { \
	MCLGET(x_m0, M_DONTWAIT);	\
	if ((x_m0->m_flags & M_EXT) == 0) { \
	    m_free(x_m0); \
	    (b) = NULL; \
	} else { \
	    (b) = x_m0; \
	    x_m0->m_len = PDQ_OS_DATABUF_SIZE; \
	} \
    } else { \
	(b) = NULL; \
    } \
} while (0)
#define	PDQ_OS_DATABUF_RESET(b)	((b)->m_data = (b)->m_ext.ext_buf, (b)->m_len = MCLBYTES)
#endif /* PDQ_USE_MBUFS */

#ifdef PDQ_USE_STREAMS
#define	PDQ_OS_DATABUF_SIZE			(2048)
#define	PDQ_OS_DATABUF_FREE(b)			(freemsg(b))
#define	PDQ_OS_DATABUF_NEXT(b)			((b)->b_cont)
#define	PDQ_OS_DATABUF_NEXT_SET(b, b1)		((b)->b_cont = (b1))
#define	PDQ_OS_DATABUF_NEXTPKT(b)		((b)->b_next)
#define	PDQ_OS_DATABUF_NEXTPKT_SET(b, b1)	((b)->b_next = (b1))
#define	PDQ_OS_DATABUF_LEN(b)			((b)->b_wptr - (b)->b_rptr)
#define	PDQ_OS_DATABUF_LEN_SET(b, n)		((b)->b_wptr = (b)->b_rptr + (n))
/*#define	PDQ_OS_DATABUF_LEN_ADJ(b, n)		((b)->b_wptr += (n))*/
#define	PDQ_OS_DATABUF_PTR(b)			((pdq_uint8_t *) (b)->b_rptr)
#define	PDQ_OS_DATABUF_ADJ(b, n)		((b)->b_rptr += (n))
typedef mblk_t PDQ_OS_DATABUF_T;

#ifndef	PDQ_OS_DATABUF_ALLOC
#define	PDQ_OS_DATABUF_ALLOC(b)			((void) (((b) = allocb(PDQ_OS_DATABUF_SIZE, BPRI_MED)) && ((b)->b_wptr = (b)->b_rptr + PDQ_OS_DATABUF_SIZE)))
#endif /* PDQ_OS_DATABUF_ALLOC */
#endif /* PDQ_USE_STREAMS */

#define	PDQ_OS_TX_TRANSMIT		5

#define	PDQ_OS_DATABUF_ENQUEUE(q, b)	do { \
    PDQ_OS_DATABUF_NEXTPKT_SET(b, NULL); \
    if ((q)->q_tail == NULL) \
	(q)->q_head = (b); \
    else \
	PDQ_OS_DATABUF_NEXTPKT_SET(((PDQ_OS_DATABUF_T *)(q)->q_tail), b); \
    (q)->q_tail = (b); \
} while (0)

#define	PDQ_OS_DATABUF_DEQUEUE(q, b)	do { \
    if (((b) = (PDQ_OS_DATABUF_T *) (q)->q_head) != NULL) { \
	if (((q)->q_head = PDQ_OS_DATABUF_NEXTPKT(b)) == NULL) \
	    (q)->q_tail = NULL; \
	PDQ_OS_DATABUF_NEXTPKT_SET(b, NULL); \
    } \
} while (0)

extern void pdq_os_addr_fill(pdq_t *pdq, pdq_lanaddr_t *addrs, size_t numaddrs);
extern void pdq_os_receive_pdu(pdq_t *, PDQ_OS_DATABUF_T *pdu, size_t pdulen);
extern void pdq_os_restart_transmitter(pdq_t *pdq);
extern void pdq_os_transmit_done(pdq_t *pdq, PDQ_OS_DATABUF_T *pdu);

extern pdq_boolean_t pdq_queue_transmit_data(pdq_t *pdq, PDQ_OS_DATABUF_T *pdu);
extern void pdq_flush_transmitter(pdq_t *pdq);

extern void pdq_run(pdq_t *pdq);
extern pdq_state_t pdq_stop(pdq_t *pdq);
extern void pdq_hwreset(pdq_t *pdq);

extern int pdq_interrupt(pdq_t *pdq);
extern pdq_t *pdq_initialize(pdq_bus_t bus, pdq_bus_memaddr_t csr_va,
			     const char *name, int unit,
			     void *ctx, pdq_type_t type);
#endif /* _PDQ_OS_H */
@


1.19
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.18 2006/03/25 22:41:43 djm Exp $	*/
@


1.18
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.17 2005/11/23 11:30:14 mickey Exp $	*/
a196 1
    void *sc_ats;			/* shutdown hook */
@


1.17
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.16 2002/06/09 03:14:18 todd Exp $	*/
d113 2
a114 2
#define	PDQ_BPF_MTAP(sc, m)	bpf_mtap(&(sc)->sc_if, m)
#define	PDQ_BPFATTACH(sc, t, s)	bpfattach(&(sc)->sc_if, t, s)
d158 1
a158 1
#define	PDQ_BPF_MTAP(sc, m)	bpf_mtap((sc)->sc_bpf, m)
d162 1
a162 1
#define	PDQ_BPFATTACH(sc, t, s)	bpfattach(&(sc)->sc_bpf, &(sc)->sc_if, t, s)
@


1.16
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.15 2002/06/02 22:50:00 deraadt Exp $	*/
d87 1
a87 1
#define	PDQ_OS_VA_TO_PA(pdq, p)		(alpha_XXX_dmamap((vm_offset_t)p))
d89 1
a89 1
#define	PDQ_OS_VA_TO_PA(pdq, p)		vtophys(p)
@


1.15
log
@withough -> without
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.14 2001/11/06 19:53:18 miod Exp $	*/
d207 2
a208 2
    struct arpcom sc_ac;
#define	sc_if		sc_ac.ac_if
@


1.14
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.13 2001/09/19 20:50:58 mickey Exp $	*/
d14 1
a14 1
 *    derived from this software withough specific prior written permission
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.14 2001/11/06 19:53:18 miod Exp $	*/
d14 1
a14 1
 *    derived from this software without specific prior written permission
d207 2
a208 2
    struct arpcom sc_arpcom;
#define	sc_if		sc_arpcom.ac_if
@


1.13
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.12 2001/06/27 04:45:58 art Exp $	*/
a72 1
#include <vm/vm.h>
@


1.12
log
@zap old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.11 1999/02/26 01:44:33 art Exp $	*/
d74 1
a74 1
#include <vm/vm_kern.h>
@


1.11
log
@compatibility with uvm kmem allocators
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.10 1996/11/28 23:27:52 niklas Exp $	*/
a97 1
#if defined(UVM)
a99 4
#else
#define	PDQ_OS_MEMALLOC_CONTIG(n)	kmem_alloc(kernel_map, round_page(n))
#define	PDQ_OS_MEMFREE_CONTIG(p, n)	kmem_free(kernel_map, (vm_offset_t) p, n)
#endif
@


1.11.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.11 1999/02/26 01:44:33 art Exp $	*/
d98 1
d101 4
@


1.11.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.11.6.1 2001/07/04 10:41:04 niklas Exp $	*/
d74 1
a74 1
#include <uvm/uvm_extern.h>
@


1.11.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 1
@


1.11.6.4
log
@Sync the SMP branch with 3.3
@
text
@d14 1
a14 1
 *    derived from this software without specific prior written permission
d207 2
a208 2
    struct arpcom sc_arpcom;
#define	sc_if		sc_arpcom.ac_if
@


1.10
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.9 1996/11/12 20:30:22 niklas Exp $	*/
d98 4
d104 1
@


1.9
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*	$OpenBSD: pdqvar.h,v 1.8 1996/10/31 01:01:38 niklas Exp $	*/
/*	$NetBSD: pdqvar.h,v 1.8 1996/07/10 18:55:05 cgd Exp $	*/
d88 1
a88 1
#define	PDQ_OS_VA_TO_PA(pdq, p)		(vtophys((vm_offset_t)p) | (pdq->pdq_type == PDQ_DEFTA ? 0 : 0x40000000))
d130 1
a130 1
#include <machine/bus.old.h>
d135 3
a137 7
typedef	bus_chipset_tag_t pdq_bus_t;
typedef	bus_io_handle_t pdq_bus_ioport_t;
#if defined(PDQ_IOMAPPED)
typedef	bus_io_handle_t pdq_bus_memaddr_t;
#else
typedef bus_mem_handle_t pdq_bus_memaddr_t;
#endif
d140 6
a145 6
#define PDQ_OS_IORD_32(t, base, offset)		bus_io_read_4  (t, base, offset)
#define PDQ_OS_IOWR_32(t, base, offset, data)	bus_io_write_4 (t, base, offset, data)
#define PDQ_OS_IORD_8(t, base, offset)		bus_io_read_1  (t, base, offset)
#define PDQ_OS_IOWR_8(t, base, offset, data)	bus_io_write_1 (t, base, offset, data)
#define PDQ_OS_MEMRD_32(t, base, offset)	bus_mem_read_4(t, base, offset)
#define PDQ_OS_MEMWR_32(t, base, offset, data)	bus_mem_write_4(t, base, offset, data)
d199 6
d211 1
a211 1
#if defined(__alpha__) || defined(__i386__)
a212 1
#endif
d219 1
@


1.8
log
@$OpenBSD RCSIDs
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.8 1996/07/10 18:55:05 cgd Exp $	*/
d130 1
a130 1
#include <machine/bus.h>
@


1.7
log
@latest pdq from matt thomas
@
text
@d1 1
@


1.6
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@d1 1
a1 2
/*	$OpenBSD: pdqvar.h,v 1.5 1996/06/18 10:22:29 deraadt Exp $	*/
/*	$NetBSD: pdqvar.h,v 1.6.4.1 1996/06/08 00:17:49 cgd Exp $	*/
d63 2
a64 1
#elif defined(__FreeBSD__) || defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
d87 1
a87 1
#define	PDQ_OS_VA_TO_PA(pdq, p)		(vtophys(p) | (pdq->pdq_type == PDQ_DEFTA ? 0 : 0x40000000))
@


1.5
log
@New rev. from Matt Thomas (June 7, 1996), which
(1) adds another parameter to PDQ_OS_VA_TO_PA() so that (via a
    hack) the driver works on more Alpha models, and
(2) adds the definition PDQ_OS_PTR_FMT, which specifies what printf
    format to use when printing pointers.  (%p under NetBSD.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pdqvar.h,v 1.4 1996/05/26 00:27:05 deraadt Exp $	*/
d64 1
a64 1
#elif defined(__FreeBSD__) || defined(__bsdi__) || defined(__NetBSD__)
d76 1
a76 1
#if defined(__NetBSD__)
d86 1
a86 1
#if defined(__NetBSD__) && defined(__alpha__)
d128 1
a128 1
#elif defined(__NetBSD__)
d198 1
a198 1
#elif defined(__NetBSD__)
@


1.4
log
@sync 0521
@
text
@d1 2
a2 2
/*	$OpenBSD: pdqvar.h,v 1.3 1996/05/10 12:41:13 deraadt Exp $	*/
/*	$NetBSD: pdqvar.h,v 1.6 1996/05/20 00:26:26 thorpej Exp $	*/
d27 1
a27 1
 * Id: pdqvar.h,v 1.17 1996/05/17 01:15:18 thomas Exp
d87 1
a87 1
#define	PDQ_OS_VA_TO_PA(p)		(vtophys(p) | 0x40000000)
d89 1
a89 1
#define	PDQ_OS_VA_TO_PA(p)		vtophys(p)
d131 1
d169 4
d247 1
a247 1
#define	PDQ_OS_VA_TO_PA(p)		vtop((caddr_t)p, NULL)
@


1.3
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pdqvar.h,v 1.5 1996/05/07 01:43:17 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995 Matt Thomas (thomas@@lkg.dec.com)
d27 1
a27 34
 * from Id: pdq_os.h,v 1.11 1995/08/20 18:59:00 thomas Exp
 *
 * Log: pdq_os.h,v
 * Revision 1.11  1995/08/20  18:59:00  thomas
 * Changes for NetBSD
 *
 * Revision 1.10  1995/08/16  22:57:28  thomas
 * Add support for NetBSD
 *
 * Revision 1.9  1995/06/21  18:29:27  thomas
 * SVR4.2 changes
 *
 * Revision 1.8  1995/06/12  17:49:37  thomas
 * Add SVR4.2 support
 *
 * Revision 1.7  1995/04/20  20:17:33  thomas
 * Add PCI support for BSD/OS.
 * Fix BSD/OS EISA support.
 * Set latency timer for DEFPA to recommended value if 0.
 *
 * Revision 1.6  1995/03/14  01:52:52  thomas
 * Update for new FreeBSD PCI Interrupt interface
 * Use inl/inb/... inline macros provided by FreeBSD and BSDI
 *
 * Revision 1.5  1995/03/10  17:42:24  thomas
 * More changes for BSDI
 *
 * Revision 1.4  1995/03/06  17:08:56  thomas
 * Add copyright/disclaimer
 * Add inx/outx macros
 *
 * Revision 1.3  1995/03/03  13:48:35  thomas
 * more fixes
 *
d43 19
d67 1
d76 4
d82 1
a82 1

d86 3
d90 1
d102 2
d108 10
d122 6
d129 2
d133 50
a185 4
#define PDQ_OS_IORD_32(port)		inl(port)
#define PDQ_OS_IOWR_32(port, data)	outl(port, data)
#define PDQ_OS_IORD_8(port)		inb(port)
#define PDQ_OS_IOWR_8(port, data)	outb(port, data)
d188 1
a188 1
#ifdef __bsdi__
d197 2
d201 1
d203 10
a212 4
    unsigned sc_iobase;
} pdq_softc_t;

#define	sc_if		sc_ac.ac_if
a213 4

#if defined(__NetBSD__)
typedef ifnet_ret_t (*pdq_ifwatchdog_t)(struct ifnet *ifp);
typedef ifnet_ret_t (*pdq_ifinit_t)(struct ifnet *ifp);
d215 1
a215 2
typedef ifnet_ret_t (*pdq_ifwatchdog_t)(int unit);
typedef ifnet_ret_t (*pdq_ifinit_t)(int unit);
d217 2
d222 1
a222 1
extern void pdq_ifwatchdog(pdq_softc_t *sc);
d225 4
a228 3
extern void pdq_ifattach(pdq_softc_t *sc, pdq_ifinit_t ifinit,
			 pdq_ifwatchdog_t ifwatchdog);
#endif /* PDQ_HWSUPPORT */
a333 22
extern void pdq_print_fddi_chars(pdq_t *pdq, const pdq_response_status_chars_get_t *rsp);

extern void pdq_init_csrs(pdq_csrs_t *csrs, void *csrs_va, size_t csr_size);
extern void pdq_init_pci_csrs(pdq_pci_csrs_t *csrs, void *csrs_va, size_t csr_size);

extern void pdq_flush_databuf_queue(pdq_databuf_queue_t *q);

extern pdq_boolean_t pdq_do_port_control(const pdq_csrs_t * const csrs, pdq_uint32_t cmd);
extern void pdq_read_mla(const pdq_csrs_t * const csrs, pdq_lanaddr_t *hwaddr);
extern void pdq_read_fwrev(const pdq_csrs_t * const csrs, pdq_fwrev_t *fwrev);
extern pdq_boolean_t pdq_read_error_log(pdq_t *pdq, pdq_response_error_log_get_t *log_entry);
extern pdq_chip_rev_t pdq_read_chiprev(const pdq_csrs_t * const csrs);

extern void pdq_queue_commands(pdq_t *pdq);
extern void pdq_process_command_responses(pdq_t *pdq);
extern void pdq_process_unsolicited_events(pdq_t *pdq);

extern void pdq_process_received_data(pdq_t *pdq, pdq_rx_info_t *rx,
				      pdq_rxdesc_t *receives,
				      pdq_uint32_t completion_goal,
				      pdq_uint32_t ring_mask);

a334 1
extern void pdq_process_transmitted_data(pdq_t *pdq);
d337 2
a338 1

a339 2
extern pdq_state_t pdq_stop(pdq_t *pdq);
extern void pdq_run(pdq_t *pdq);
d342 3
a344 3
extern pdq_t *pdq_initialize(void *csr_va, const char *name, int unit, void *ctx, pdq_type_t type);


@


1.2
log
@NetBSD 960317 merge
@
text
@d2 1
a2 1
/*	$NetBSD: pdqvar.h,v 1.4 1996/03/11 21:41:35 thorpej Exp $	*/
d145 8
d158 2
a159 2
extern void pdq_ifattach(pdq_softc_t *sc, ifnet_ret_t (*ifinit)(int unit),
			 ifnet_ret_t (*ifwatchdog)(int unit));
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: pdqvar.h,v 1.2 1995/08/19 04:35:22 cgd Exp $	*/
d26 36
d68 1
a105 1
#if !defined(PDQ_HWSUPPORT)
d108 1
d119 2
d130 1
a130 1
    struct intrhand sc_ih;		/* intrrupt vectoring */
d134 1
a134 1
    void *sc_ih;			/* intrrupt vectoring */
d291 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
