head	1.3;
access;
symbols
	OPENBSD_3_8:1.2.0.16
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.14
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.12
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.10
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.22
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.20
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.18
	OPENBSD_2_8:1.1.0.16
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.14
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.12
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.10
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2006.01.22.17.42.55;	author grange;	state dead;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.09.13.14.16.19;	author niklas;	state Exp;
branches
	1.1.12.1
	1.1.22.1;
next	;

1.1.12.1
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	;

1.1.22.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Nothing uses this file anymore.

ok miod@@
@
text
@/*	$OpenBSD: ds.h,v 1.2 2002/03/14 01:26:54 millert Exp $	*/
/*	$NetBSD: ds.h,v 1.1 1997/07/06 22:22:01 is Exp $	*/

/*-
 * Copyright (c) 1997 Ignatios Souvatzis. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Definitions for access to Dallas Semiconductor chips which attach to 
 * the same 1-wire bus as the DS2404 RTC.
 */

#ifndef DALLAS_SEMI_CHIPS_H
#define DALLAS_SEMI_CHIPS_H

/* Family codes (low byte of the ROM) */

#define DS_FAMILY_2404	0x04	/* DS2404 Econoram Time Chip */

/*
 * ROM access codes. These are only available from the 1-wire bus, and one
 * of them MUST be used before a memory access code is called. If you want
 * to detect which devices are on the bus, you have to issue the ROM search
 * function (see data sheet).
 * If only one device is on the BUS, and you don't want any ROM function,
 * issue the SKIP function.
 * READ ROM works only if only one device is on the bus.
 */

#define DS_ROM_MATCH		0x55	/* 55 8-bytes-of-ROM-to-select */
#define DS_ROM_SEARCH		0xf0	/* see data sheet */
#define DS_ROM_SKIP		0xCC	/* don't do ROM function */
#define DS_ROM_READ		0x33	/* 33 -> 8 bytes of ROM */

/*
 * Memory access codes. These are available from the 1- or 3-wire bus, and
 * but you must use one of the ROM access codes first, if using the 1-wire 
 * bus.
 *
 * You can read from any starting address up to the end of the chip, or
 * abort the read with a reset pulse.
 * You first write 2-32 bytes beginning some address to the scratchpad.
 * Starting address and final byte stream length are remembered by the 
 * chip. After reading data and address/length back from the scratchpad,
 * and verifying the information, you can issue the copy scratchpad command
 * to copy the written parts of the scratchpad to the corresponding parts
 * of the implied (in the address) memory page.
 */

#define DS_MEM_WRITE_SCRATCH	0x0f	/* 0F low-ads high-ads data ... */
#define DS_MEM_READ_SCRATCH	0xaa	/* AA -> low-ads high-ads end-ofs 
					 * data ... */
#define DS_MEM_COPY_SCRATCH	0x55	/* 55 low-ads high-ads end-ofs */
#define DS_MEM_READ_MEMORY	0xf0	/* F0 low-ads high-ads -> data ...*/

/*
 * Hardware handle for access functions
 */

struct ds_handle {
	int (*ds_read_bit)(void *);
	void (*ds_write_bit)(void *, int);
	void (*ds_reset)(void *);
	void *ds_hw_handle;
};

/*
 * Functions for access to Dallas Semiconductor chips which attach to 
 * the same 1-wire bus as the DS2404 RTC.
 */

static __inline u_int8_t ds_read_byte(struct ds_handle *);
static __inline void ds_write_byte(struct ds_handle *, unsigned int);

static __inline u_int8_t
ds_read_byte(dsh)
	struct ds_handle *dsh;
{
	u_int8_t buf;
	int i;

	for (i = buf = 0; i < 8; ++i)
		buf |= (dsh->ds_read_bit)(dsh->ds_hw_handle) << i;

	return buf;
}

static __inline void
ds_write_byte(dsh, b)
	struct ds_handle *dsh;
	unsigned int b;
{
	int i;

	for (i = 0; i < 8; ++i) {
		(dsh->ds_write_bit)(dsh->ds_hw_handle, b & 1);
		b >>= 1;
	}
}

#endif /* DALLAS_SEMI_CHIPS_H */
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ds.h,v 1.1 1997/09/13 14:16:19 niklas Exp $	*/
@


1.1
log
@From NetBSD: MI stuff for DS2404 RTC
@
text
@d1 1
a1 1
/*	$OpenBSD: ds.h,v 1.1 1997/07/06 22:22:01 is Exp $	*/
d85 3
a87 3
	int (*ds_read_bit) __P((void *));
	void (*ds_write_bit) __P((void *, int));
	void (*ds_reset) __P((void *));
d96 2
a97 2
static __inline u_int8_t ds_read_byte __P((struct ds_handle *));
static __inline void ds_write_byte __P((struct ds_handle *, unsigned int));
@


1.1.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ds.h,v 1.1 1997/09/13 14:16:19 niklas Exp $	*/
d85 3
a87 3
	int (*ds_read_bit)(void *);
	void (*ds_write_bit)(void *, int);
	void (*ds_reset)(void *);
d96 2
a97 2
static __inline u_int8_t ds_read_byte(struct ds_handle *);
static __inline void ds_write_byte(struct ds_handle *, unsigned int);
@


1.1.12.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 3
a87 3
	int (*ds_read_bit)(void *);
	void (*ds_write_bit)(void *, int);
	void (*ds_reset)(void *);
d96 2
a97 2
static __inline u_int8_t ds_read_byte(struct ds_handle *);
static __inline void ds_write_byte(struct ds_handle *, unsigned int);
@


