head	1.19;
access;
symbols
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	UBC:1.1.0.4
	UBC_SYNC_A:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.19
date	2006.01.14.15.14.33;	author kettenis;	state dead;
branches;
next	1.18;

1.18
date	2006.01.12.22.45.46;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.12.22.31.11;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.12.20.03.14;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.09.20.40.19;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.07.12.42.45;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.03.19.30.09;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.30.19.47.39;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.30.09.45.20;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.25.10.23.27;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.24.23.30.55;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.24.19.35.23;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.07.07.00.46;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.10.19.58.16;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.13.22.07.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.12.14.10.53;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.05.13.42.36;	author couderc;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.29.21.21.25;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.25.21.24.15;	author grange;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.05.12.19.59.12;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Rename nslm7x.c into lm78.c and nslm7xvar.h into lm78var.h, and clean up
lm78var.h.
Now that I've completely rewritten the driver, replace copyright with my own.
suggested by deraadt@@
@
text
@/*	$OpenBSD: nslm7x.c,v 1.18 2006/01/12 22:45:46 kettenis Exp $	*/
/*	$NetBSD: nslm7x.c,v 1.17 2002/11/15 14:55:41 ad Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Bill Squier.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/queue.h>
#include <sys/sensors.h>
#include <machine/bus.h>

#include <dev/ic/nslm7xvar.h>

#if defined(LMDEBUG)
#define DPRINTF(x)		do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

struct cfdriver lm_cd = {
	NULL, "lm", DV_DULL
};

int  lm_match(struct lm_softc *);
int  wb_match(struct lm_softc *);
int  def_match(struct lm_softc *);

void lm_setup_sensors(struct lm_softc *, struct lm_sensor *);
void lm_refresh(void *);

void lm_refresh_sensor_data(struct lm_softc *);
void lm_refresh_volts(struct lm_softc *, int);
void lm_refresh_nvolts(struct lm_softc *, int);
void lm_refresh_temp(struct lm_softc *, int);
void lm_refresh_fanrpm(struct lm_softc *, int);

void wb_refresh_sensor_data(struct lm_softc *);
void wb_refresh_n12volts(struct lm_softc *, int);
void wb_refresh_n5volts(struct lm_softc *, int);
void wb_refresh_temp(struct lm_softc *, int);
void wb_refresh_fanrpm(struct lm_softc *, int);
void wb_w83792d_refresh_fanrpm(struct lm_softc *, int);

struct lm_chip {
	int (*chip_match)(struct lm_softc *);
};

struct lm_chip lm_chips[] = {
	{ wb_match },
	{ lm_match },
	{ def_match } /* Must be last */
};

struct lm_sensor lm78_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 40000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, lm_refresh_nvolts, 40000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_nvolts, 16667 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, lm_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, lm_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, lm_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83627hf_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volts, 10000 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83637hf_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 38000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16667 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x24, wb_refresh_n12volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volts, 16667 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volts, 10000 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83697hf_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V",SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volts, 10000 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83781d_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 15050 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000},
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, lm_refresh_nvolts, 34768 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_nvolts, 15050 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, lm_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, lm_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, lm_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83782d_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VINR0", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000},
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volts, 10000 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83783s_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83791d_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VINR0", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000},
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 0, 0xb0, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 0, 0xb1, lm_refresh_volts, 10000 },
	{ "VINR1", SENSOR_VOLTS_DC, 0, 0xb2, lm_refresh_volts, 10000 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 0, 0xc0, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 0, 0xc8, wb_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },
	{ "Fan4", SENSOR_FANRPM, 0, 0xba, wb_refresh_fanrpm },
	{ "Fan5", SENSOR_FANRPM, 0, 0xbb, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83792d_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x23, wb_refresh_n5volts, 10000 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000},
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_volts, 16800 },
	{ "5VSB", SENSOR_VOLTS_DC, 0, 0xb0, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 0, 0xb1, lm_refresh_volts, 10000 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 0, 0xc0, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 0, 0xc8, wb_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_w83792d_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_w83792d_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_w83792d_refresh_fanrpm },
	{ "Fan4", SENSOR_FANRPM, 0, 0xb8, wb_w83792d_refresh_fanrpm },
	{ "Fan5", SENSOR_FANRPM, 0, 0xb9, wb_w83792d_refresh_fanrpm },
	{ "Fan6", SENSOR_FANRPM, 0, 0xba, wb_w83792d_refresh_fanrpm },
	{ "Fan7", SENSOR_FANRPM, 0, 0xbe, wb_w83792d_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor as99127f_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000  },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },

	/* Temperature */
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, lm_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, lm_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, lm_refresh_fanrpm },

	{ NULL }
};

void
lm_attach(struct lm_softc *sc)
{
	u_int i, config;

	for (i = 0; i < sizeof(lm_chips) / sizeof(lm_chips[0]); i++)
		if (lm_chips[i].chip_match(sc))
			break;

	if (sensor_task_register(sc, lm_refresh, 5)) {
		printf("%s: unable to register update task\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* Start the monitoring loop */
	config = sc->lm_readreg(sc, LMD_CONFIG);
	sc->lm_writereg(sc, LMD_CONFIG, config | 0x01);

	/* Add sensors */
	for (i = 0; i < sc->numsensors; ++i)
		SENSOR_ADD(&sc->sensors[i]);
}

int
lm_match(struct lm_softc *sc)
{
	int chipid;

	/* See if we have an LM78 or LM79. */
	chipid = sc->lm_readreg(sc, LMD_CHIPID) & LM_ID_MASK;
	switch(chipid) {
	case LM_ID_LM78:
		printf(": LM78\n");
		break;
	case LM_ID_LM78J:
		printf(": LM78J\n");
		break;
	case LM_ID_LM79:
		printf(": LM79\n");
		break;
	case LM_ID_LM81:
		printf(": LM81\n");
		break;
	default:
		return 0;
	}

	lm_setup_sensors(sc, lm78_sensors);
	sc->refresh_sensor_data = lm_refresh_sensor_data;
	return 1;
}

int
def_match(struct lm_softc *sc)
{
	int chipid;

	chipid = sc->lm_readreg(sc, LMD_CHIPID) & LM_ID_MASK;
	printf(": unknown chip (ID %d)\n", chipid);

	lm_setup_sensors(sc, lm78_sensors);
	sc->refresh_sensor_data = lm_refresh_sensor_data;
	return 1;
}

int
wb_match(struct lm_softc *sc)
{
	int banksel, vendid, chipid, devid;

	/* Read vendor ID */
	banksel = sc->lm_readreg(sc, WB_BANKSEL);
	sc->lm_writereg(sc, WB_BANKSEL, WB_BANKSEL_HBAC);
	vendid = sc->lm_readreg(sc, WB_VENDID) << 8;
	sc->lm_writereg(sc, WB_BANKSEL, 0);
	vendid |= sc->lm_readreg(sc, WB_VENDID);
	sc->lm_writereg(sc, WB_BANKSEL, banksel);
	DPRINTF(("winbond vend id 0x%x\n", j));
	if (vendid != WB_VENDID_WINBOND && vendid != WB_VENDID_ASUS)
		return 0;

	/* Read device/chip ID */
	sc->lm_writereg(sc, WB_BANKSEL, WB_BANKSEL_B0);
	devid = sc->lm_readreg(sc, LMD_CHIPID);
	chipid = sc->lm_readreg(sc, WB_BANK0_CHIPID);
	sc->lm_writereg(sc, WB_BANKSEL, banksel);
	DPRINTF(("winbond chip id 0x%x\n", chipid));
	switch(chipid) {
	case WB_CHIPID_W83627HF:
		printf(": W83627HF\n");
		lm_setup_sensors(sc, w83627hf_sensors);
		break;
	case WB_CHIPID_W83627THF:
		printf(": W83627THF\n");
		lm_setup_sensors(sc, w83627hf_sensors);
		break;
	case WB_CHIPID_W83637HF:
		printf(": W83637HF\n");
		lm_setup_sensors(sc, w83637hf_sensors);
		break;
	case WB_CHIPID_W83697HF:
		printf(": W83697HF\n");
		lm_setup_sensors(sc, w83697hf_sensors);
		break;
	case WB_CHIPID_W83781D:
	case WB_CHIPID_W83781D_2:
		printf(": W83781D\n");
		lm_setup_sensors(sc, w83781d_sensors);
		break;
	case WB_CHIPID_W83782D:
		printf(": W83782D\n");
		lm_setup_sensors(sc, w83782d_sensors);
		break;
	case WB_CHIPID_W83783S:
		printf(": W83783S\n");
		lm_setup_sensors(sc, w83783s_sensors);
		break;
	case WB_CHIPID_W83791D:
	case WB_CHIPID_W83791D_2:
		printf(": W83791D\n");
		lm_setup_sensors(sc, w83791d_sensors);
		break;
	case WB_CHIPID_W83792D:
		if (devid >= 0x10 && devid <= 0x29)
			printf(": W83782D rev %c\n", 'A' + devid - 0x10);
		else
			printf(": W83782D rev 0x%x\n", devid);
		lm_setup_sensors(sc, w83792d_sensors);
		break;
	case WB_CHIPID_AS99127F:
		if (vendid == WB_VENDID_ASUS) {
			printf(": AS99127F\n");
			lm_setup_sensors(sc, w83781d_sensors);
		} else {
			printf(": AS99127F rev 2\n");
			lm_setup_sensors(sc, as99127f_sensors);
		}
		break;
	default:
		printf(": unknown Winbond chip (ID 0x%x)\n", chipid);
		/* Handle as a standard LM78. */
		lm_setup_sensors(sc, lm78_sensors);
		sc->refresh_sensor_data = lm_refresh_sensor_data;
		return 1;
	}

	sc->refresh_sensor_data = wb_refresh_sensor_data;
	return 1;
}

void
lm_setup_sensors(struct lm_softc *sc, struct lm_sensor *sensors)
{
	int i;

	for (i = 0; sensors[i].desc; i++) {
		strlcpy(sc->sensors[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sensors[i].device));
		sc->sensors[i].type = sensors[i].type;
		strlcpy(sc->sensors[i].desc, sensors[i].desc,
		     sizeof(sc->sensors[i].desc));
		sc->sensors[i].rfact = sensors[i].rfact;
		sc->numsensors++;
	}
	sc->lm_sensors = sensors;
}

void
lm_refresh(void *arg)
{
	struct lm_softc *sc = arg;

	sc->refresh_sensor_data(sc);
}

void
lm_refresh_sensor_data(struct lm_softc *sc)
{
	int i;

	for (i = 0; i < sc->numsensors; i++)
		sc->lm_sensors[i].refresh(sc, i);
}

void
lm_refresh_volts(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	sensor->value = (data << 4);
	sensor->value *= sensor->rfact;
	sensor->value /= 10;
}

void
lm_refresh_nvolts(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	sensor->value = (data << 4);
	sensor->value *= sensor->rfact;
	sensor->value /= 10;
	sensor->value *= -1;
}

void
lm_refresh_temp(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int sdata;

	sdata = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	if (sdata & 0x80)
		sdata -= 0x100;
	sensor->value = sdata * 1000000 + 273150000;
}

void
lm_refresh_fanrpm(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int data, divisor = 1;

	/*
	 * We might get more accurate fan readings by adjusting the
	 * divisor, but that might interfere with APM or other SMM
	 * BIOS code reading the fan speeds.
	 */

	/* FAN3 has a fixed fan divisor. */
	if (sc->lm_sensors[n].reg == LMD_FAN1 ||
	    sc->lm_sensors[n].reg == LMD_FAN2) {
		data = sc->lm_readreg(sc, LMD_VIDFAN);
		if (sc->lm_sensors[n].reg == LMD_FAN1)
			divisor = (data >> 4) & 0x03;
		else
			divisor = (data >> 6) & 0x03;
	}

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	if (data == 0xff || data == 0x00) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = 1350000 / (data << divisor);
	}
}

void
wb_refresh_sensor_data(struct lm_softc *sc)
{
	int banksel, bank, i;

	/*
	 * Properly save and restore bank selection register.
	 */

	banksel = bank = sc->lm_readreg(sc, WB_BANKSEL);
	for (i = 0; i < sc->numsensors; i++) {
		if (bank != sc->lm_sensors[i].bank) {
			bank = sc->lm_sensors[i].bank;
			sc->lm_writereg(sc, WB_BANKSEL, bank);
		}
		sc->lm_sensors[i].refresh(sc, i);
	}
	sc->lm_writereg(sc, WB_BANKSEL, banksel);
}

void
wb_refresh_n12volts(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	sensor->value = (((data << 4) * 1000) - (WB_VREF * 806)) / 194;
	sensor->value *= sensor->rfact;
	sensor->value /= 10;
}

void
wb_refresh_n5volts(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	sensor->value = (((data << 4) * 1000) - (WB_VREF * 682)) / 318;
	sensor->value *= sensor->rfact;
	sensor->value /= 10;
}

void
wb_refresh_temp(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int sdata;

	sdata = sc->lm_readreg(sc, sc->lm_sensors[n].reg) << 1;
	sdata += sc->lm_readreg(sc, sc->lm_sensors[n].reg + 1) >> 7;
	if (sdata & 0x100)
		sdata -= 0x200;
	sensor->value = sdata * 500000 + 273150000;
}

void
wb_refresh_fanrpm(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int fan, data, divisor = 0;

	/* 
	 * This is madness; the fan divisor bits are scattered all
	 * over the place.
	 */

	if (sc->lm_sensors[n].reg == LMD_FAN1 ||
	    sc->lm_sensors[n].reg == LMD_FAN2 ||
	    sc->lm_sensors[n].reg == LMD_FAN3) {
		data = sc->lm_readreg(sc, WB_BANK0_FANBAT);
		fan = (sc->lm_sensors[n].reg - LMD_FAN1);
		if ((data >> 5) & (1 << fan))
			divisor |= 0x04;
	}

	if (sc->lm_sensors[n].reg == LMD_FAN1 ||
	    sc->lm_sensors[n].reg == LMD_FAN2) {
		data = sc->lm_readreg(sc, LMD_VIDFAN);
		if (sc->lm_sensors[n].reg == LMD_FAN1)
			divisor |= (data >> 4) & 0x03;
		else
			divisor |= (data >> 6) & 0x03;
	} else if (sc->lm_sensors[n].reg == LMD_FAN3) {
		data = sc->lm_readreg(sc, WB_PIN);
		divisor |= (data >> 6) & 0x03;
	} else if (sc->lm_sensors[n].reg == WB_BANK0_FAN4 ||
		   sc->lm_sensors[n].reg == WB_BANK0_FAN5) {
		data = sc->lm_readreg(sc, WB_BANK0_FAN45);
		if (sc->lm_sensors[n].reg == WB_BANK0_FAN4)
			divisor |= (data >> 0) & 0x07;
		else
			divisor |= (data >> 4) & 0x07;
	}

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	if (data == 0xff || data == 0x00) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = 1350000 / (data << divisor);
	}
}

void
wb_w83792d_refresh_fanrpm(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int reg, shift, data, divisor = 1;

	switch (sc->lm_sensors[n].reg) {
	case 0x28:
		reg = 0x47; shift = 0;
		break;
	case 0x29:
		reg = 0x47; shift = 4;
		break;
	case 0x2a:
		reg = 0x5b; shift = 0;
		break;
	case 0xb8:
		reg = 0x5b; shift = 4;
		break;
	case 0xb9:
		reg = 0x5c; shift = 0;
		break;
	case 0xba:
		reg = 0x5c; shift = 4;
		break;
	case 0xbe:
		reg = 0x9e; shift = 0;
		break;
	default:
		reg = 0;
		break;
	}

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	if (data == 0xff || data == 0x00) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		if (reg != 0)
			divisor = (sc->lm_readreg(sc, reg) >> shift) & 0x7;
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = 1350000 / (data << divisor);
	}
}
@


1.18
log
@Garbage collect lm_probe.
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.17 2006/01/12 22:31:11 kettenis Exp $	*/
@


1.17
log
@Add W83792D support.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.16 2006/01/12 20:03:14 kettenis Exp $	*/
a328 28

/* XXX Not so bus-independent probe. */
int
lm_probe(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	u_int8_t cr;
	int rv;

	/* Check for some power-on defaults */
	bus_space_write_1(iot, ioh, LMC_ADDR, LMD_CONFIG);

	/* Perform LM78 reset */
	bus_space_write_1(iot, ioh, LMC_DATA, 0x80);

	/* XXX - Why do I have to reselect the register? */
	bus_space_write_1(iot, ioh, LMC_ADDR, LMD_CONFIG);
	cr = bus_space_read_1(iot, ioh, LMC_DATA);

	/* XXX - spec says *only* 0x08! */
	if ((cr == 0x08) || (cr == 0x01) || (cr == 0x03))
		rv = 1;
	else
		rv = 0;

	DPRINTF(("lm: rv = %d, cr = %x\n", rv, cr));

	return (rv);
}
@


1.16
log
@Fix typo.  Spotted by Oleg Safiullin.
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.15 2006/01/09 20:40:19 kettenis Exp $	*/
d78 1
d278 29
d427 1
a427 1
	int banksel, vendid, chipid;
d440 1
a440 1
	/* Read chip ID */
d442 1
d481 7
d713 45
@


1.15
log
@Reorganize, paying attention to the small differences between Winbond chips.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.14 2006/01/07 12:42:45 kettenis Exp $	*/
d425 1
a425 1
		printf(": W83627HF\n");
@


1.14
log
@Remove #ifdef'ed out prototypes for previously removed #ifdef'ed out code.
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.13 2006/01/03 19:30:09 kettenis Exp $	*/
a59 4
void setup_fan(struct lm_softc *, int, int);
void setup_temp(struct lm_softc *, int, int);
void wb_setup_volt(struct lm_softc *);

a62 1
void lm_common_match(struct lm_softc *);
d64 2
a65 3
void generic_stemp(struct lm_softc *, struct sensor *);
void generic_svolt(struct lm_softc *, struct sensor *);
void generic_fanrpm(struct lm_softc *, struct sensor *);
d68 10
a77 11

void wb_svolt(struct lm_softc *);
void wb_stemp(struct lm_softc *, struct sensor *, int);
void wb781_fanrpm(struct lm_softc *, struct sensor *);
void wb_fanrpm(struct lm_softc *, struct sensor *, int);

void wb781_refresh_sensor_data(struct lm_softc *);
void wb782_refresh_sensor_data(struct lm_softc *);
void wb697_refresh_sensor_data(struct lm_softc *);

void lm_refresh(void *);
d89 212
a300 3
/*
 * bus independent probe
 */
a327 3
/*
 * pre:  lmsc contains valid busspace tag and handle
 */
d329 1
a329 1
lm_attach(struct lm_softc *lmsc)
d334 1
a334 1
		if (lm_chips[i].chip_match(lmsc))
d337 1
a337 1
	if (sensor_task_register(lmsc, lm_refresh, 5)) {
d339 1
a339 1
		    lmsc->sc_dev.dv_xname);
d344 2
a345 2
	config = (*lmsc->lm_readreg)(lmsc, LMD_CONFIG);
	(*lmsc->lm_writereg)(lmsc, LMD_CONFIG, config | 0x01);
d347 3
a349 6
	/* Initialize sensors */
	for (i = 0; i < lmsc->numsensors; ++i) {
		strlcpy(lmsc->sensors[i].device, lmsc->sc_dev.dv_xname,
		    sizeof(lmsc->sensors[i].device));
		SENSOR_ADD(&lmsc->sensors[i]);
	}
d355 1
a355 1
	int i;
d357 3
a359 3
	/* See if we have an LM78 or LM79 */
	i = (*sc->lm_readreg)(sc, LMD_CHIPID) & LM_ID_MASK;
	switch(i) {
d375 3
a377 1
	lm_common_match(sc);
d384 1
a384 1
	int i;
d386 2
a387 5
	i = (*sc->lm_readreg)(sc, LMD_CHIPID) & LM_ID_MASK;
	printf(": unknown chip (ID %d)\n", i);
	lm_common_match(sc);
	return 1;
}
d389 1
a389 5
void
lm_common_match(struct lm_softc *sc)
{
	int i;
	sc->numsensors = LM_NUM_SENSORS;
d391 1
a391 19

	for (i = 0; i < 7; ++i) {
		sc->sensors[i].type = SENSOR_VOLTS_DC;
		snprintf(sc->sensors[i].desc, sizeof(sc->sensors[i].desc),
		    "IN%d", i);
	}

	/* default correction factors for resistors on higher voltage inputs */
	sc->sensors[0].rfact = sc->sensors[1].rfact =
	    sc->sensors[2].rfact = 10000;
	sc->sensors[3].rfact = (int)(( 90.9 / 60.4) * 10000);
	sc->sensors[4].rfact = (int)(( 38.0 / 10.0) * 10000);
	sc->sensors[5].rfact = (int)((210.0 / 60.4) * 10000);
	sc->sensors[6].rfact = (int)(( 90.9 / 60.4) * 10000);

	sc->sensors[7].type = SENSOR_TEMP;
	strlcpy(sc->sensors[7].desc, "Temp", sizeof(sc->sensors[7].desc));

	setup_fan(sc, 8, 3);
d397 1
a397 1
	int i, j, banksel;
d399 7
a405 6
	banksel = (*sc->lm_readreg)(sc, WB_BANKSEL);
	(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_HBAC);
	j = (*sc->lm_readreg)(sc, WB_VENDID) << 8;
	(*sc->lm_writereg)(sc, WB_BANKSEL, 0);
	j |= (*sc->lm_readreg)(sc, WB_VENDID);
	(*sc->lm_writereg)(sc, WB_BANKSEL, banksel);
d407 1
a407 1
	if (j != WB_VENDID_WINBOND && j != WB_VENDID_ASUS)
a408 13
	/* read device ID */
	(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_B0);
	j = (*sc->lm_readreg)(sc, WB_BANK0_CHIPID);
	(*sc->lm_writereg)(sc, WB_BANKSEL, banksel);
	DPRINTF(("winbond chip id 0x%x\n", j));
	switch(j) {
	case WB_CHIPID_83781:
	case WB_CHIPID_83781_2:
	case AS_CHIPID_99127:
		if (j == AS_CHIPID_99127)
			printf(": AS99127F\n");
		else
			printf(": W83781D\n");
d410 19
a428 21
		for (i = 0; i < 7; ++i) {
			sc->sensors[i].type = SENSOR_VOLTS_DC;
			snprintf(sc->sensors[i].desc,
			    sizeof(sc->sensors[i].desc), "IN%d", i);
		}

		/* default correction factors for higher voltage inputs */
		sc->sensors[0].rfact = sc->sensors[1].rfact =
		    sc->sensors[2].rfact = 10000;
		sc->sensors[3].rfact = (int)(( 90.9 / 60.4) * 10000);
		sc->sensors[4].rfact = (int)(( 38.0 / 10.0) * 10000);
		sc->sensors[5].rfact = (int)((210.0 / 60.4) * 10000);
		sc->sensors[6].rfact = (int)(( 90.9 / 60.4) * 10000);

		setup_temp(sc, 7, 3);
		setup_fan(sc, 10, 3);

		sc->numsensors = WB83781_NUM_SENSORS;
		sc->refresh_sensor_data = wb781_refresh_sensor_data;
		return 1;
	case WB_CHIPID_83697:
d430 8
a437 7
		wb_setup_volt(sc);
		setup_temp(sc, 9, 2);
		setup_fan(sc, 11, 2);
		sc->numsensors = WB83697_NUM_SENSORS;
		sc->refresh_sensor_data = wb697_refresh_sensor_data;
		return 1;
	case WB_CHIPID_83782:
d439 1
d441 3
a443 2
	case WB_CHIPID_83627:
		printf(": W83627HF\n");
d445 4
a448 2
	case WB_CHIPID_83627THF:
		printf(": W83627THF\n");
d450 8
a457 3
	case WB_CHIPID_83791:
	case WB_CHIPID_83791_2:
		printf(": W83791D\n");
d460 4
a463 3
		printf(": unknown winbond chip ID 0x%x\n", j);
		/* handle as a standart lm7x */
		lm_common_match(sc);
d466 2
a467 6
	/* common code for the W83782D and W83627HF */
	wb_setup_volt(sc);
	setup_temp(sc, 9, 3);
	setup_fan(sc, 12, 3);
	sc->numsensors = WB_NUM_SENSORS;
	sc->refresh_sensor_data = wb782_refresh_sensor_data;
d472 1
a472 33
wb_setup_volt(struct lm_softc *sc)
{
	sc->sensors[0].type = SENSOR_VOLTS_DC;
	snprintf(sc->sensors[0].desc, sizeof(sc->sensors[0].desc), "VCORE_A");
	sc->sensors[0].rfact = 10000;
	sc->sensors[1].type = SENSOR_VOLTS_DC;
	snprintf(sc->sensors[1].desc, sizeof(sc->sensors[1].desc), "VCORE_B");
	sc->sensors[1].rfact = 10000;
	sc->sensors[2].type = SENSOR_VOLTS_DC;
	snprintf(sc->sensors[2].desc, sizeof(sc->sensors[2].desc), "+3.3V");
	sc->sensors[2].rfact = 10000;
	sc->sensors[3].type = SENSOR_VOLTS_DC;
	snprintf(sc->sensors[3].desc, sizeof(sc->sensors[3].desc), "+5V");
	sc->sensors[3].rfact = 16778;
	sc->sensors[4].type = SENSOR_VOLTS_DC;
	snprintf(sc->sensors[4].desc, sizeof(sc->sensors[4].desc), "+12V");
	sc->sensors[4].rfact = 38000;
	sc->sensors[5].type = SENSOR_VOLTS_DC;
	snprintf(sc->sensors[5].desc, sizeof(sc->sensors[5].desc), "-12V");
	sc->sensors[5].rfact = 10000;
	sc->sensors[6].type = SENSOR_VOLTS_DC;
	snprintf(sc->sensors[6].desc, sizeof(sc->sensors[6].desc), "-5V");
	sc->sensors[6].rfact = 10000;
	sc->sensors[7].type = SENSOR_VOLTS_DC;
	snprintf(sc->sensors[7].desc, sizeof(sc->sensors[7].desc), "+5VSB");
	sc->sensors[7].rfact = 15151;
	sc->sensors[8].type = SENSOR_VOLTS_DC;
	snprintf(sc->sensors[8].desc, sizeof(sc->sensors[8].desc), "VBAT");
	sc->sensors[8].rfact = 10000;
}

void
setup_temp(struct lm_softc *sc, int start, int n)
d476 8
a483 4
	for (i = 0; i < n; i++) {
		sc->sensors[start + i].type = SENSOR_TEMP;
		snprintf(sc->sensors[start + i].desc,
		    sizeof(sc->sensors[start + i].desc), "Temp%d", i + 1);
d485 1
d489 1
a489 1
setup_fan(struct lm_softc *sc, int start, int n)
d491 1
a491 1
	int i;
d493 1
a493 5
	for (i = 0; i < n; ++i) {
		sc->sensors[start + i].type = SENSOR_FANRPM;
		snprintf(sc->sensors[start + i].desc,
		    sizeof(sc->sensors[start + i].desc), "Fan%d", i + 1);
	}
d497 1
a497 1
generic_stemp(struct lm_softc *sc, struct sensor *sensor)
d499 1
a499 1
	int sdata = (*sc->lm_readreg)(sc, LMD_SENSORBASE + 7);
d501 2
a502 3
	DPRINTF(("sdata[temp] 0x%x\n", sdata));
	/* temp is given in deg. C, we convert to uK */
	sensor->value = sdata * 1000000 + 273150000;
d506 1
a506 1
generic_svolt(struct lm_softc *sc, struct sensor *sensors)
d508 2
a509 1
	int i, sdata;
d511 4
a514 14
	for (i = 0; i < 7; i++) {
		sdata = (*sc->lm_readreg)(sc, LMD_SENSORBASE + i);
		DPRINTF(("sdata[volt%d] 0x%x\n", i, sdata));
		/* voltage returned as (mV >> 4), we convert to uVDC */
		sensors[i].value = (sdata << 4);
		/* rfact is (factor * 10^4) */
		sensors[i].value *= sensors[i].rfact;
		/* division by 10 gets us back to uVDC */
		sensors[i].value /= 10;

		/* these two are negative voltages */
		if ( (i == 5) || (i == 6) )
			sensors[i].value *= -1;
	}
d518 1
a518 1
generic_fanrpm(struct lm_softc *sc, struct sensor *sensors)
d520 2
a521 1
	int i, sdata, divisor, vidfan;
d523 5
a527 32
	for (i = 0; i < 3; i++) {
		sdata = (*sc->lm_readreg)(sc, LMD_SENSORBASE + 8 + i);
		vidfan = (*sc->lm_readreg)(sc, LMD_VIDFAN);
		DPRINTF(("sdata[fan%d] 0x%x", i, sdata));
		if (i == 2)
			divisor = 1;	/* Fixed divisor for FAN3 */
		else if (i == 1)	/* Bits 7 & 6 of VID/FAN  */
			divisor = (vidfan >> 6) & 0x3;
		else
			divisor = (vidfan >> 4) & 0x3;
		DPRINTF((", divisor %d\n", 2 << divisor));

		if (sdata == 0xff) {
			/* XXX Changing the fan divisor is too dangerous */
#if 0
			/* Fan can be too slow, try to adjust the divisor */
			if (i < 2 && divisor < 3) {
				divisor++;
				vidfan &= ~(0x3 << (i == 0 ? 4 : 6));
				vidfan |= (divisor & 0x3) << (i == 0 ? 4 : 6);
				(*sc->lm_writereg)(sc, LMD_VIDFAN, vidfan);
			}
#endif
			sensors[i].value = 0;
		} else if (sdata == 0x00) {
			sensors[i].flags |= SENSOR_FINVALID;
			sensors[i].value = 0;
		} else {
			sensors[i].flags &= ~SENSOR_FINVALID;
			sensors[i].value = 1350000 / (sdata << divisor);
		}
	}
a529 4
/*
 * pre:  last read occurred >= 1.5 seconds ago
 * post: sensors[] current data are the latest from the chip
 */
d531 1
a531 1
lm_refresh_sensor_data(struct lm_softc *sc)
d533 2
a534 5
	/* Refresh our stored data for every sensor */
	generic_stemp(sc, &sc->sensors[7]);
	generic_svolt(sc, &sc->sensors[0]);
	generic_fanrpm(sc, &sc->sensors[8]);
}
d536 4
a539 37
void
wb_svolt(struct lm_softc *sc)
{
	int i, sdata;

	for (i = 0; i < 9; ++i) {
		if (i < 7) {
			sdata = (*sc->lm_readreg)(sc, LMD_SENSORBASE + i);
		} else {
			/* from bank5 */
			(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_B5);
			sdata = (*sc->lm_readreg)(sc, (i == 7) ?
			    WB_BANK5_5VSB : WB_BANK5_VBAT);
			(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_B0);
		}
		DPRINTF(("sdata[volt%d] 0x%x\n", i, sdata));
		/* voltage returned as (mV >> 4), we convert to uV */
		sdata =  sdata << 4;
		/* special case for negative voltages */
		if (i == 5) {
			/*
			 * -12Vdc, assume Winbond recommended values for
			 * resistors
			 */
			sdata = ((sdata * 1000) - (3600 * 806)) / 194;
		} else if (i == 6) {
			/*
			 * -5Vdc, assume Winbond recommended values for
			 * resistors
			 */
			sdata = ((sdata * 1000) - (3600 * 682)) / 318;
		}
		/* rfact is (factor * 10^4) */
		sc->sensors[i].value = sdata * (int64_t)sc->sensors[i].rfact;
		/* division by 10 gets us back to uVDC */
		sc->sensors[i].value /= 10;
	}
d543 1
a543 1
wb_stemp(struct lm_softc *sc, struct sensor *sensors, int n)
d545 2
a546 23
	int sdata;

	/* temperatures. Given in dC, we convert to uK */
	sdata = (*sc->lm_readreg)(sc, LMD_SENSORBASE + 7);
	DPRINTF(("sdata[temp0] 0x%x\n", sdata));
	sensors[0].value = sdata * 1000000 + 273150000;
	/* from bank1 */
	(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_B1);
	sdata = (*sc->lm_readreg)(sc, WB_BANK1_T2H) << 1;
	sdata |=  ((*sc->lm_readreg)(sc, WB_BANK1_T2L) & 0x80) >> 7;
	(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_B0);
	DPRINTF(("sdata[temp1] 0x%x\n", sdata));
	sensors[1].value = (sdata * 1000000) / 2 + 273150000;
	if (n < 3)
		return;
	/* from bank2 */
	(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_B2);
	sdata = (*sc->lm_readreg)(sc, WB_BANK2_T3H) << 1;
	sdata |=  ((*sc->lm_readreg)(sc, WB_BANK2_T3L) & 0x80) >> 7;
	(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_B0);
	DPRINTF(("sdata[temp2] 0x%x\n", sdata));
	sensors[2].value = (sdata * 1000000) / 2 + 273150000;
}
d548 12
a559 14
void
wb781_fanrpm(struct lm_softc *sc, struct sensor *sensors)
{
	int i, divisor, sdata;

	for (i = 0; i < 3; i++) {
		sdata = (*sc->lm_readreg)(sc, LMD_SENSORBASE + i + 8);
		DPRINTF(("sdata[fan%d] 0x%x\n", i, sdata));
		if (i == 0)
			divisor = ((*sc->lm_readreg)(sc,
			    LMD_VIDFAN) >> 4) & 0x3;
		else if (i == 1)
			divisor = ((*sc->lm_readreg)(sc,
			    LMD_VIDFAN) >> 6) & 0x3;
d561 2
a562 1
			divisor = ((*sc->lm_readreg)(sc, WB_PIN) >> 6) & 0x3;
d564 7
a570 8
		DPRINTF(("sdata[%d] 0x%x div 0x%x\n", i, sdata, divisor));
		if (sdata == 0xff) {
			sensors[i].flags |= SENSOR_FINVALID;
		} else if (sdata == 0x00) {
			sensors[i].value = 0;
		} else {
			sensors[i].value = 1350000 / (sdata << divisor);
		}
d575 1
a575 1
wb_fanrpm(struct lm_softc *sc, struct sensor *sensors, int n)
d577 1
a577 1
	int i, divisor, sdata;
d579 9
a587 21
	for (i = 0; i < n; i++) {
		sdata = (*sc->lm_readreg)(sc, LMD_SENSORBASE + i + 8);
		DPRINTF(("sdata[fan%d] 0x%x\n", i, sdata));
		if (i == 0)
			divisor = ((*sc->lm_readreg)(sc,
			    LMD_VIDFAN) >> 4) & 0x3;
		else if (i == 1)
			divisor = ((*sc->lm_readreg)(sc,
			    LMD_VIDFAN) >> 6) & 0x3;
		else
			divisor = ((*sc->lm_readreg)(sc, WB_PIN) >> 6) & 0x3;
		divisor |= ((*sc->lm_readreg)(sc,
		    WB_BANK0_FANBAT) >> (i + 3)) & 0x4;

		DPRINTF(("sdata[%d] 0x%x div 0x%x\n", i, sdata, divisor));
		if (sdata == 0xff) {
			sensors[i].flags |= SENSOR_FINVALID;
		} else if (sdata == 0x00) {
			sensors[i].value = 0;
		} else {
			sensors[i].value = 1350000 / (sdata << divisor);
d589 1
d591 1
d595 1
a595 1
wb781_refresh_sensor_data(struct lm_softc *sc)
d597 2
a598 1
	int banksel;
d600 4
a603 7
	/* Refresh our stored data for every sensor */
	banksel = (*sc->lm_readreg)(sc, WB_BANKSEL);
	(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_B0);
	generic_svolt(sc, &sc->sensors[0]);
	wb_stemp(sc, &sc->sensors[7], 3);
	wb781_fanrpm(sc, &sc->sensors[10]);
	(*sc->lm_writereg)(sc, WB_BANKSEL, banksel);
d607 1
a607 1
wb782_refresh_sensor_data(struct lm_softc *sc)
d609 2
a610 1
	int banksel;
d612 4
a615 7
	/* Refresh our stored data for every sensor */
	banksel = (*sc->lm_readreg)(sc, WB_BANKSEL);
	(*sc->lm_writereg)(sc, WB_BANKSEL, WB_BANKSEL_B0);
	wb_svolt(sc);
	wb_stemp(sc, &sc->sensors[9], 3);
	wb_fanrpm(sc, &sc->sensors[12], 3);
	(*sc->lm_writereg)(sc, WB_BANKSEL, banksel);
d619 1
a619 1
wb697_refresh_sensor_data(struct lm_softc *sc)
d621 2
a622 1
	int banksel;
d624 5
a628 7
	/* Refresh our stored data for every sensor */
	banksel = (*sc->lm_readreg)(sc, WB_BANKSEL);
	(*sc->lm_writereg)(sc, WB_BANKSEL, 0);
	wb_svolt(sc);
	wb_stemp(sc, &sc->sensors[9], 2);
	wb_fanrpm(sc, &sc->sensors[11], 2);
	(*sc->lm_writereg)(sc, WB_BANKSEL, banksel);
d632 37
a668 3
lm_refresh(void *arg)
{
	struct lm_softc *sc = (struct lm_softc *)arg;
d670 8
a677 1
	sc->refresh_sensor_data(sc);
@


1.13
log
@Be careful not to change any registers.
ok grange@@, deraadt@@; tested by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.12 2005/12/30 19:47:39 kettenis Exp $	*/
a84 10

#if 0
int lm_gtredata(struct sysmon_envsys *, struct envsys_tre_data *);

int generic_streinfo_fan(struct lm_softc *, struct envsys_basic_info *,
	int, struct envsys_basic_info *);
int lm_streinfo(struct sysmon_envsys *, struct envsys_basic_info *);
int wb781_streinfo(struct sysmon_envsys *, struct envsys_basic_info *);
int wb782_streinfo(struct sysmon_envsys *, struct envsys_basic_info *);
#endif
@


1.12
log
@Properly detect AS99127F rev 1.
From Jonathan Fromer <jf@@daimi.au.dk>.
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.11 2005/12/30 09:45:20 kettenis Exp $	*/
a67 1
int  lm_generic_banksel(struct lm_softc *, int);
a105 7
int
lm_generic_banksel(struct lm_softc *lmsc, int bank)
{
	(*lmsc->lm_writereg)(lmsc, WB_BANKSEL, bank);
	return (0);
}

d142 1
a142 5
	u_int i;

	/* Install default bank selection routine, if none given. */
	if (lmsc->lm_banksel == NULL)
		lmsc->lm_banksel = lm_generic_banksel;
d155 2
a156 1
	(*lmsc->lm_writereg)(lmsc, LMD_CONFIG, 0x01);
d234 1
a234 1
	int i, j;
d236 1
d241 1
d246 1
a246 1
	(*sc->lm_banksel)(sc, 0);
d248 1
a370 238
#if 0
int
lm_gtredata(sme, tred)
	 struct sysmon_envsys *sme;
	 struct envsys_tre_data *tred;
{
	 static const struct timeval onepointfive = { 1, 500000 };
	 struct timeval t, mtv;
	 struct lm_softc *sc = sme->sme_cookie;
	 int i;

	 /* read new values at most once every 1.5 seconds */
	 timeradd(&sc->lastread, &onepointfive, &t);
	 getmicrouptime(&mtv);
	 i = timercmp(&mtv, &t, >);
	 if (i) {
		  sc->lastread = mtv;
		  sc->refresh_sensor_data(sc);
	 }

	 *tred = sc->sensors[tred->sensor];

	 return (0);
}

int
generic_streinfo_fan(sc, info, n, binfo)
	struct lm_softc *sc;
	struct envsys_basic_info *info;
	int n;
	struct envsys_basic_info *binfo;
{
	u_int8_t sdata;
	int divisor;

	/* FAN1 and FAN2 can have divisors set, but not FAN3 */
	if ((sc->sensors[binfo->sensor].type == SENSOR_FANRPM)
	    && (n < 2)) {
		if (binfo->rpms == 0) {
			binfo->validflags = 0;
			return (0);
		}

		/* write back the nominal FAN speed  */
		info->rpms = binfo->rpms;

		/* 153 is the nominal FAN speed value */
		divisor = 1350000 / (binfo->rpms * 153);

		/* ...but we need lg(divisor) */
		if (divisor <= 1)
		    divisor = 0;
		else if (divisor <= 2)
		    divisor = 1;
		else if (divisor <= 4)
		    divisor = 2;
		else
		    divisor = 3;

		/*
		 * FAN1 div is in bits <5:4>, FAN2 div is
		 * in <7:6>
		 */
		sdata = (*sc->lm_readreg)(sc, LMD_VIDFAN);
		if ( n == 0 ) {  /* FAN1 */
		    divisor <<= 4;
		    sdata = (sdata & 0xCF) | divisor;
		} else { /* FAN2 */
		    divisor <<= 6;
		    sdata = (sdata & 0x3F) | divisor;
		}

		(*sc->lm_writereg)(sc, LMD_VIDFAN, sdata);
	}
	return (0);

}

int
lm_streinfo(sme, binfo)
	 struct sysmon_envsys *sme;
	 struct envsys_basic_info *binfo;
{
	 struct lm_softc *sc = sme->sme_cookie;

	 if (sc->sensors[binfo->sensor].type == SENSOR_VOLTS_DC)
		  sc->sensors[binfo->sensor].rfact = binfo->rfact;
	 else {
		if (sc->sensors[binfo->sensor].type == SENSOR_FANRPM) {
			generic_streinfo_fan(sc, &sc->sensors[binfo->sensor],
			    binfo->sensor - 8, binfo);
		}
		memcpy(sc->sensors[binfo->sensor].desc, binfo->desc,
		    sizeof(sc->sensors[binfo->sensor].desc));
		sc->sensors[binfo->sensor].desc[
		    sizeof(sc->sensors[binfo->sensor].desc) - 1] = '\0';

		binfo->validflags = ENVSYS_FVALID;
	 }
	 return (0);
}

int
wb781_streinfo(sme, binfo)
	 struct sysmon_envsys *sme;
	 struct envsys_basic_info *binfo;
{
	 struct lm_softc *sc = sme->sme_cookie;
	 int divisor;
	 u_int8_t sdata;
	 int i;

	 if (sc->sensors[binfo->sensor].type == SENSOR_VOLTS_DC)
		  sc->sensors[binfo->sensor].rfact = binfo->rfact;
	 else {
		if (sc->sensors[binfo->sensor].type == SENSOR_FANRPM) {
			if (binfo->rpms == 0) {
				binfo->validflags = 0;
				return (0);
			}

			/* write back the nominal FAN speed  */
			sc->sensors[binfo->sensor].rpms = binfo->rpms;

			/* 153 is the nominal FAN speed value */
			divisor = 1350000 / (binfo->rpms * 153);

			/* ...but we need lg(divisor) */
			for (i = 0; i < 7; i++) {
				if (divisor <= (1 << i))
				 	break;
			}
			divisor = i;

			if (binfo->sensor == 10 || binfo->sensor == 11) {
				/*
				 * FAN1 div is in bits <5:4>, FAN2 div
				 * is in <7:6>
				 */
				sdata = (*sc->lm_readreg)(sc, LMD_VIDFAN);
				if ( binfo->sensor == 10 ) {  /* FAN1 */
					 sdata = (sdata & 0xCF) |
					     ((divisor & 0x3) << 4);
				} else { /* FAN2 */
					 sdata = (sdata & 0x3F) |
					     ((divisor & 0x3) << 6);
				}
				(*sc->lm_writereg)(sc, LMD_VIDFAN, sdata);
			} else {
				/* FAN3 is in WB_PIN <7:6> */
				sdata = (*sc->lm_readreg)(sc, WB_PIN);
				sdata = (sdata & 0x3F) |
				     ((divisor & 0x3) << 6);
				(*sc->lm_writereg)(sc, WB_PIN, sdata);
			}
		}
		memcpy(sc->sensors[binfo->sensor].desc, binfo->desc,
		    sizeof(sc->sensors[binfo->sensor].desc));
		sc->sensors[binfo->sensor].desc[
		    sizeof(sc->sensors[binfo->sensor].desc) - 1] = '\0';

		binfo->validflags = ENVSYS_FVALID;
	 }
	 return (0);
}

int
wb782_streinfo(sme, binfo)
	 struct sysmon_envsys *sme;
	 struct envsys_basic_info *binfo;
{
	 struct lm_softc *sc = sme->sme_cookie;
	 int divisor;
	 u_int8_t sdata;
	 int i;

	 if (sc->sensors[binfo->sensor].type == SENSOR_VOLTS_DC)
		  sc->sensors[binfo->sensor].rfact = binfo->rfact;
	 else {
	 	if (sc->sensors[binfo->sensor].type == SENSOR_FANRPM) {
			if (binfo->rpms == 0) {
				binfo->validflags = 0;
				return (0);
			}

			/* write back the nominal FAN speed  */
			sc->sensors[binfo->sensor].rpms = binfo->rpms;

			/* 153 is the nominal FAN speed value */
			divisor = 1350000 / (binfo->rpms * 153);

			/* ...but we need lg(divisor) */
			for (i = 0; i < 7; i++) {
				if (divisor <= (1 << i))
				 	break;
			}
			divisor = i;

			if (binfo->sensor == 12 || binfo->sensor == 13) {
				/*
				 * FAN1 div is in bits <5:4>, FAN2 div
				 * is in <7:6>
				 */
				sdata = (*sc->lm_readreg)(sc, LMD_VIDFAN);
				if ( binfo->sensor == 12 ) {  /* FAN1 */
					 sdata = (sdata & 0xCF) |
					     ((divisor & 0x3) << 4);
				} else { /* FAN2 */
					 sdata = (sdata & 0x3F) |
					     ((divisor & 0x3) << 6);
				}
				(*sc->lm_writereg)(sc, LMD_VIDFAN, sdata);
			} else {
				/* FAN3 is in WB_PIN <7:6> */
				sdata = (*sc->lm_readreg)(sc, WB_PIN);
				sdata = (sdata & 0x3F) |
				     ((divisor & 0x3) << 6);
				(*sc->lm_writereg)(sc, WB_PIN, sdata);
			}
			/* Bit 2 of divisor is in WB_BANK0_FANBAT */
			(*sc->lm_banksel)(sc, 0);
			sdata = (*sc->lm_readreg)(sc, WB_BANK0_FANBAT);
			sdata &= ~(0x20 << (binfo->sensor - 12));
			sdata |= (divisor & 0x4) << (binfo->sensor - 9);
			(*sc->lm_writereg)(sc, WB_BANK0_FANBAT, sdata);
		}

		memcpy(sc->sensors[binfo->sensor].desc, binfo->desc,
		    sizeof(sc->sensors[binfo->sensor].desc));
		sc->sensors[binfo->sensor].desc[
		    sizeof(sc->sensors[binfo->sensor].desc) - 1] = '\0';

		binfo->validflags = ENVSYS_FVALID;
	}
	return (0);
}
#endif

d420 2
d429 1
d464 1
a464 1
			(*sc->lm_banksel)(sc, 5);
d467 1
d503 6
a508 8
	if ((*sc->lm_banksel)(sc, 1)) {
		sensors[1].flags |= SENSOR_FINVALID;
	} else {
		sdata = (*sc->lm_readreg)(sc, WB_BANK1_T2H) << 1;
		sdata |=  ((*sc->lm_readreg)(sc, WB_BANK1_T2L) & 0x80) >> 7;
		DPRINTF(("sdata[temp1] 0x%x\n", sdata));
		sensors[1].value = (sdata * 1000000) / 2 + 273150000;
	}
d512 6
a517 8
	if ((*sc->lm_banksel)(sc, 2)) {
		sensors[2].flags |= SENSOR_FINVALID;
	} else {
		sdata = (*sc->lm_readreg)(sc, WB_BANK2_T3H) << 1;
		sdata |=  ((*sc->lm_readreg)(sc, WB_BANK2_T3L) & 0x80) >> 7;
		DPRINTF(("sdata[temp2] 0x%x\n", sdata));
		sensors[2].value = (sdata * 1000000) / 2 + 273150000;
	}
a524 1
	(*sc->lm_banksel)(sc, 0);
a552 1
	(*sc->lm_banksel)(sc, 0);
d581 2
d584 2
a585 2
	/* we need to reselect bank0 to access common registers */
	(*sc->lm_banksel)(sc, 0);
a586 1
	(*sc->lm_banksel)(sc, 0);
a587 1
	(*sc->lm_banksel)(sc, 0);
d589 1
d595 2
d598 2
d603 1
d609 2
d612 2
d617 1
@


1.11
log
@Initial W83791D support for lm(4).
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.10 2005/12/25 10:23:27 kettenis Exp $	*/
d252 1
a252 1
	if (j != WB_VENDID_WINBOND)
@


1.10
log
@Add support for AS99127F, an Asus W83781D clone.
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.9 2005/12/24 23:30:55 kettenis Exp $	*/
d303 4
@


1.9
log
@Use sensors thread instead of timeouts.
Update every 5 instead of 1.5 seconds.
ok grange@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.8 2004/06/24 19:35:23 tholo Exp $	*/
d261 5
a265 1
		printf(": W83781D\n");
@


1.8
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.7 2004/05/07 07:00:46 grange Exp $	*/
a45 1
#include <sys/timeout.h>
a106 2
struct timeout lm_timeout;

d160 6
a174 4

	/* Refresh sensors data every 1.5 seconds */
	timeout_set(&lm_timeout, lm_refresh, lmsc);
	timeout_add(&lm_timeout, (15 * hz) / 10);
a854 1
	timeout_add(&lm_timeout, (15 * hz) / 10);
@


1.7
log
@LM7x models improvements:

- correct divisor for fan3 (2 means 2^1, so the divisor is actually 1, not 2)
- fan1 and fan2 have adjastable divisors, use this feature to
  dynamically correct divisors for slow fans
- fix SENSOR_FINVALID usage

Based on the diff from Alexander Bluhm <alexander.bluhm@@gmx.net> in
PR 3719.
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.6 2004/02/10 19:58:16 grange Exp $	*/
d379 1
a379 1
	 struct timeval t;
d381 1
a381 1
	 int i, s;
d385 2
a386 2
	 s = splclock();
	 i = timercmp(&mono_time, &t, >);
d388 2
a389 2
		  sc->lastread.tv_sec  = mono_time.tv_sec;
		  sc->lastread.tv_usec = mono_time.tv_usec;
a390 4
	 splx(s);

	 if (i)
		  sc->refresh_sensor_data(sc);
@


1.6
log
@Use SENSOR_FINVALID.

help and ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.5 2004/01/13 22:07:09 deraadt Exp $	*/
d648 1
a648 1
	int i, sdata, divisor;
d652 2
a653 1
		DPRINTF(("sdata[fan%d] 0x%x\n", i, sdata));
d655 1
a655 1
			divisor = 2;	/* Fixed divisor for FAN3 */
d657 1
a657 2
			divisor = ((*sc->lm_readreg)(sc,
			    LMD_VIDFAN) >> 6) & 0x3;
d659 2
a660 2
			divisor = ((*sc->lm_readreg)(sc,
			    LMD_VIDFAN) >> 4) & 0x3;
d663 9
a672 1
		} else if (sdata == 0x00) {
d675 1
@


1.5
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.4 2004/01/12 14:10:53 grange Exp $	*/
d662 3
a664 1
		if (sdata == 0xff || sdata == 0x00) {
d734 1
a734 3
#if 0
		sensors[1].validflags &= ~ENVSYS_FCURVALID;
#endif
d745 1
a745 3
#if 0
		sensors[2].validflags &= ~ENVSYS_FCURVALID;
#endif
d773 3
a775 1
		if (sdata == 0xff || sdata == 0x00) {
d804 3
a806 1
		if (sdata == 0xff || sdata == 0x00) {
@


1.4
log
@Move sensors externs to sys/sensors.h and introduce a macro
SENSOR_ADD to hide all operations with these externs.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.3 2003/08/05 13:42:36 couderc Exp $	*/
d211 1
a211 1
	printf(": Unknown chip (ID %d)\n", i);
d302 1
a302 1
		printf(": unknow winbond chip ID 0x%x\n", j);
@


1.3
log
@Add support for Winbond 83627THF, ok grange@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.2 2003/06/29 21:21:25 grange Exp $	*/
a153 2
	extern int nsensors;
	extern struct sensors_head sensors;
d170 1
a170 2
		lmsc->sensors[i].num = nsensors++;
		SLIST_INSERT_HEAD(&sensors, &lmsc->sensors[i], list);
@


1.2
log
@- cast rfact to int64_t before multiplication to avoid sign overflow
- don't hardcode funrpm sensors number in wb_fanrpm(), instead pass
  it as a parameter since WB83697 actually has only 2 sensors, not 3

from Otto Moerbeek <otto@@drijf.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.1 2003/04/25 21:24:15 grange Exp $	*/
d137 1
a137 1
	if ((cr == 0x08) || (cr == 0x01))
d300 3
@


1.1
log
@lm(4) driver from NetBSD adapted for sysctl interface.
The lm driver provides support for the National Semiconductor LM series
hardware monitors and register compatible chips. It supports LM78,
LM78-J, LM79, Winbond W83697HF, W83627HF, W83781D and W83782D chips.

Tested and ok'ed by millert@@ and henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
void wb_fanrpm(struct lm_softc *, struct sensor *);
d291 1
a291 1
		setup_fan(sc, 11, 3);
d706 1
a706 1
			sdata = ((sdata * 1000) - (3600 * 805)) / 195;
d715 1
a715 1
		sc->sensors[i].value = sdata * sc->sensors[i].rfact;
d784 1
a784 1
wb_fanrpm(struct lm_softc *sc, struct sensor *sensors)
d789 1
a789 1
	for (i = 0; i < 3; i++) {
d831 1
a831 1
	wb_fanrpm(sc, &sc->sensors[12]);
d840 1
a840 1
	wb_fanrpm(sc, &sc->sensors[11]);
@


1.1.2.1
log
@Add new file to SMP branch
@
text
@@


1.1.2.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d80 1
a80 1
void wb_fanrpm(struct lm_softc *, struct sensor *, int);
d137 1
a137 1
	if ((cr == 0x08) || (cr == 0x01) || (cr == 0x03))
d154 2
d172 2
a173 1
		SENSOR_ADD(&lmsc->sensors[i]);
d214 1
a214 1
	printf(": unknown chip (ID %d)\n", i);
d291 1
a291 1
		setup_fan(sc, 11, 2);
a300 3
	case WB_CHIPID_83627THF:
		printf(": W83627THF\n");
		break;
d302 1
a302 1
		printf(": unknown winbond chip ID 0x%x\n", j);
d706 1
a706 1
			sdata = ((sdata * 1000) - (3600 * 806)) / 194;
d715 1
a715 1
		sc->sensors[i].value = sdata * (int64_t)sc->sensors[i].rfact;
d784 1
a784 1
wb_fanrpm(struct lm_softc *sc, struct sensor *sensors, int n)
d789 1
a789 1
	for (i = 0; i < n; i++) {
d831 1
a831 1
	wb_fanrpm(sc, &sc->sensors[12], 3);
d840 1
a840 1
	wb_fanrpm(sc, &sc->sensors[11], 2);
@


1.1.2.3
log
@Merge with the trunk
@
text
@d648 1
a648 1
	int i, sdata, divisor, vidfan;
d652 1
a652 2
		vidfan = (*sc->lm_readreg)(sc, LMD_VIDFAN);
		DPRINTF(("sdata[fan%d] 0x%x", i, sdata));
d654 1
a654 1
			divisor = 1;	/* Fixed divisor for FAN3 */
d656 2
a657 1
			divisor = (vidfan >> 6) & 0x3;
d659 2
a660 2
			divisor = (vidfan >> 4) & 0x3;
		DPRINTF((", divisor %d\n", 2 << divisor));
d662 1
a662 11
		if (sdata == 0xff) {
			/* Fan can be too slow, try to adjust the divisor */
			if (i < 2 && divisor < 3) {
				divisor++;
				vidfan &= ~(0x3 << (i == 0 ? 4 : 6));
				vidfan |= (divisor & 0x3) << (i == 0 ? 4 : 6);
				(*sc->lm_writereg)(sc, LMD_VIDFAN, vidfan);
			}
			sensors[i].value = 0;
		} else if (sdata == 0x00) {
			sensors[i].flags |= SENSOR_FINVALID;
a664 1
			sensors[i].flags &= ~SENSOR_FINVALID;
d732 3
a734 1
		sensors[1].flags |= SENSOR_FINVALID;
d745 3
a747 1
		sensors[2].flags |= SENSOR_FINVALID;
d775 1
a775 3
		if (sdata == 0xff) {
			sensors[i].flags |= SENSOR_FINVALID;
		} else if (sdata == 0x00) {
d804 1
a804 3
		if (sdata == 0xff) {
			sensors[i].flags |= SENSOR_FINVALID;
		} else if (sdata == 0x00) {
@


