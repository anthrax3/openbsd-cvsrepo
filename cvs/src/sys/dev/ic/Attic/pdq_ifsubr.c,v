head	1.21;
access;
symbols
	OPENBSD_5_4:1.19.0.30
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.28
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.24
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.26
	OPENBSD_5_0:1.19.0.22
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.20
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.18
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.14
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.16
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.12
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.10
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.8
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.6
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.13
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.20
	OPENBSD_2_8:1.6.0.18
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.16
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.14
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.21
date	2013.10.28.12.33.32;	author mpi;	state dead;
branches;
next	1.20;

1.20
date	2013.08.07.01.06.30;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.30.21.33.59;	author fkr;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.09.05.50.25;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.08.17.03.00;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.02.22.49.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.27.06.34.42;	author kjc;	state Exp;
branches;
next	1.6;

1.6
date	96.10.31.01.01.37;	author niklas;	state Exp;
branches
	1.6.14.1;
next	1.5;

1.5
date	96.10.16.12.41.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.21.22.27.41;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.00.27.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.10.12.41.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.23.47.23;	author niklas;	state Exp;
branches;
next	;

1.6.14.1
date	2001.07.04.10.41.03;	author niklas;	state Exp;
branches;
next	1.6.14.2;

1.6.14.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.6.14.3;

1.6.14.3
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.6.14.4;

1.6.14.4
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.6.14.5;

1.6.14.5
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.6.14.6;

1.6.14.6
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@tedu FDDI support and the 3 flavors the driver for DEC devices, even
miod@@ cannot find two boards using the same media.

With precious punctuation review from guenther@@, thanks!

ok deraadt@@, henning@@
@
text
@/*	$OpenBSD: pdq_ifsubr.c,v 1.20 2013/08/07 01:06:30 bluhm Exp $	*/
/*	$NetBSD: pdq_ifsubr.c,v 1.5 1996/05/20 00:26:21 thorpej Exp $	*/

/*-
 * Copyright (c) 1995, 1996 Matt Thomas <matt@@3am-software.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Id: pdq_ifsubr.c,v 1.6 1996/05/16 14:25:26 thomas Exp
 *
 */

/*
 * DEC PDQ FDDI Controller; code for BSD derived operating systems
 *
 *	This module provide bus independent BSD specific O/S functions.
 *	(ie. it provides an ifnet interface to the rest of the system)
 */


#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#if defined(__FreeBSD__)
#include <sys/devconf.h>
#elif defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/device.h>
#endif

#include <net/if.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/route.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif
#if defined(__FreeBSD__)
#include <netinet/if_fddi.h>
#else
#include <net/if_fddi.h>
#endif

#include <uvm/uvm_extern.h>

#include "pdqvar.h"
#include "pdqreg.h"

void
pdq_ifinit(
    pdq_softc_t *sc)
{
    if (sc->sc_if.if_flags & IFF_UP) {
	sc->sc_if.if_flags |= IFF_RUNNING;
	if (sc->sc_if.if_flags & IFF_PROMISC) {
	    sc->sc_pdq->pdq_flags |= PDQ_PROMISC;
	} else {
	    sc->sc_pdq->pdq_flags &= ~PDQ_PROMISC;
	}
	if (sc->sc_if.if_flags & IFF_ALLMULTI) {
	    sc->sc_pdq->pdq_flags |= PDQ_ALLMULTI;
	} else {
	    sc->sc_pdq->pdq_flags &= ~PDQ_ALLMULTI;
	}
	if (sc->sc_if.if_flags & IFF_LINK1) {
	    sc->sc_pdq->pdq_flags |= PDQ_PASS_SMT;
	} else {
	    sc->sc_pdq->pdq_flags &= ~PDQ_PASS_SMT;
	}
	sc->sc_pdq->pdq_flags |= PDQ_RUNNING;
	pdq_run(sc->sc_pdq);
    } else {
	sc->sc_if.if_flags &= ~IFF_RUNNING;
	sc->sc_pdq->pdq_flags &= ~PDQ_RUNNING;
	pdq_stop(sc->sc_pdq);
    }
}

void
pdq_ifwatchdog(
    struct ifnet *ifp)
{
    /*
     * No progress was made on the transmit queue for PDQ_OS_TX_TRANSMIT
     * seconds.  Remove all queued packets.
     */

    ifp->if_flags &= ~IFF_OACTIVE;
    ifp->if_timer = 0;
    IFQ_PURGE(&ifp->if_snd);
}

ifnet_ret_t
pdq_ifstart(
    struct ifnet *ifp)
{
    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_arpcom.ac_if));
    struct mbuf *m;
    int tx = 0;

    if ((ifp->if_flags & IFF_RUNNING) == 0)
	return;

    if (sc->sc_if.if_timer == 0)
	sc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;

    if ((sc->sc_pdq->pdq_flags & PDQ_TXOK) == 0) {
	sc->sc_if.if_flags |= IFF_OACTIVE;
	return;
    }
    for (;; tx = 1) {
	IFQ_POLL(&ifp->if_snd, m);
	if (m == NULL)
	    break;

	if (pdq_queue_transmit_data(sc->sc_pdq, m) == PDQ_FALSE) {
	    ifp->if_flags |= IFF_OACTIVE;
	    break;
	}

	IFQ_DEQUEUE(&ifp->if_snd, m);
    }
    if (tx)
	PDQ_DO_TYPE2_PRODUCER(sc->sc_pdq);
}

void
pdq_os_receive_pdu(
    pdq_t *pdq,
    struct mbuf *m,
    size_t pktlen)
{
    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;
    struct fddi_header *fh = mtod(m, struct fddi_header *);

    sc->sc_if.if_ipackets++;
#if NBPFILTER > 0
    if (sc->sc_bpf != NULL)
	PDQ_BPF_MTAP(sc, m, BPF_DIRECTION_IN);
    if ((fh->fddi_fc & (FDDIFC_L|FDDIFC_F)) != FDDIFC_LLC_ASYNC) {
	m_freem(m);
	return;
    }
#endif

    m->m_data += sizeof(struct fddi_header);
    m->m_len  -= sizeof(struct fddi_header);
    m->m_pkthdr.len = pktlen - sizeof(struct fddi_header);
    m->m_pkthdr.rcvif = &sc->sc_if;
    fddi_input(&sc->sc_if, fh, m);
}

void
pdq_os_restart_transmitter(
    pdq_t *pdq)
{
    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;
    sc->sc_if.if_flags &= ~IFF_OACTIVE;
    if (!IFQ_IS_EMPTY(&sc->sc_if.if_snd)) {
	sc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;
	pdq_ifstart(&sc->sc_if);
    } else {
	sc->sc_if.if_timer = 0;
    }
}

void
pdq_os_transmit_done(
    pdq_t *pdq,
    struct mbuf *m)
{
    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;
#if NBPFILTER > 0
    if (sc->sc_bpf != NULL)
	PDQ_BPF_MTAP(sc, m, BPF_DIRECTION_OUT);
#endif
    m_freem(m);
    sc->sc_if.if_opackets++;
}

void
pdq_os_addr_fill(
    pdq_t *pdq,
    pdq_lanaddr_t *addr,
    size_t num_addrs)
{
    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;
    struct ether_multistep step;
    struct ether_multi *enm;

    ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
    while (enm != NULL && num_addrs > 0) {
	((u_short *) addr->lanaddr_bytes)[0] = ((u_short *) enm->enm_addrlo)[0];
	((u_short *) addr->lanaddr_bytes)[1] = ((u_short *) enm->enm_addrlo)[1];
	((u_short *) addr->lanaddr_bytes)[2] = ((u_short *) enm->enm_addrlo)[2];
	ETHER_NEXT_MULTI(step, enm);
	addr++;
	num_addrs--;
    }
}

int
pdq_ifioctl(
    struct ifnet *ifp,
    ioctl_cmd_t cmd,
    caddr_t data)
{
    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_arpcom.ac_if));
    int s, error = 0;

    s = splnet();

    switch (cmd) {
	case SIOCSIFADDR: {
	    struct ifaddr *ifa = (struct ifaddr *)data;

	    ifp->if_flags |= IFF_UP;
	    switch(ifa->ifa_addr->sa_family) {
#if defined(INET)
		case AF_INET: {
		    pdq_ifinit(sc);
		    arp_ifinit(&sc->sc_arpcom, ifa);
		    break;
		}
#endif /* INET */

#if defined(NS)
		/* This magic copied from if_is.c; I don't use XNS,
		 * so I have no way of telling if this actually
		 * works or not.
		 */
		case AF_NS: {
		    struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);
		    if (ns_nullhost(*ina)) {
			ina->x_host = *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
		    } else {
			ifp->if_flags &= ~IFF_RUNNING;
			bcopy((caddr_t)ina->x_host.c_host,
			      (caddr_t)sc->sc_arpcom.ac_enaddr,
			      sizeof sc->sc_arpcom.ac_enaddr);
		    }

		    pdq_ifinit(sc);
		    break;
		}
#endif /* NS */

		default: {
		    pdq_ifinit(sc);
		    break;
		}
	    }
	    break;
	}

	case SIOCSIFFLAGS: {
	    pdq_ifinit(sc);
	    break;
	}

	case SIOCADDMULTI:
	case SIOCDELMULTI: {
	    /*
	     * Update multicast listeners
	     */
	    if (cmd == SIOCADDMULTI)
		error = ether_addmulti((struct ifreq *)data, &sc->sc_arpcom);
	    else
		error = ether_delmulti((struct ifreq *)data, &sc->sc_arpcom);

	    if (error == ENETRESET) {
		if (sc->sc_if.if_flags & IFF_RUNNING)
		    pdq_run(sc->sc_pdq);
		error = 0;
	    }
	    break;
	}

	default: {
	    error = EINVAL;
	    break;
	}
    }

    splx(s);
    return error;
}

#ifndef IFF_NOTRAILERS
#define	IFF_NOTRAILERS	0
#endif

void
pdq_ifattach(
    pdq_softc_t *sc,
    ifnet_ret_t (*ifwatchdog)(int unit))
{
    struct ifnet *ifp = &sc->sc_if;

    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;

#if (defined(__FreeBSD__) && BSD >= 199506) || defined(__NetBSD__) || \
	defined(__OpenBSD__)
    ifp->if_watchdog = pdq_ifwatchdog;
#else
    ifp->if_watchdog = ifwatchdog;
#endif

    ifp->if_ioctl = pdq_ifioctl;
    ifp->if_start = pdq_ifstart;
    IFQ_SET_READY(&ifp->if_snd);
  
    if_attach(ifp);
    fddi_ifattach(ifp);
#if NBPFILTER > 0
    PDQ_BPFATTACH(sc, DLT_FDDI, sizeof(struct fddi_header));
#endif
}
@


1.20
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.19 2006/05/30 21:33:59 fkr Exp $	*/
@


1.19
log
@removes the isavar.h include and the ifdef bsdi cruft
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.18 2006/03/25 22:41:43 djm Exp $	*/
a65 1
#include <netinet/in_var.h>
@


1.18
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.17 2005/11/09 05:50:25 brad Exp $	*/
d49 1
a49 1
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
a75 4
#if defined(__bsdi__) && _BSDI_VERSION < 199401
#include <i386/isa/isavar.h>
#endif

a79 15

#if defined(__bsdi__) && _BSDI_VERSION < 199506 /* XXX */
static void
arp_ifinit(
    struct arpcom *ac,
    struct ifaddr *ifa)
{
    sc->sc_arpcom.ac_ipaddr = IA_SIN(ifa)->sin_addr;
    arpwhohas(&sc->sc_arpcom, &IA_SIN(ifa)->sin_addr);
#if _BSDI_VERSION >= 199401
    ifa->ifa_rtrequest = arp_rtrequest;
    ifa->ifa_flags |= RTF_CLONING;
#endif
#endif

@


1.17
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.16 2005/06/08 17:03:00 henning Exp $	*/
d190 1
a190 1
	PDQ_BPF_MTAP(sc, m);
d226 1
a226 1
	PDQ_BPF_MTAP(sc, m);
@


1.16
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.15 2004/09/23 17:45:16 brad Exp $	*/
d262 1
a262 1
    s = splimp();
@


1.15
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.14 2004/05/12 06:35:10 tedu Exp $	*/
a77 5
#endif

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
@


1.14
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.13 2002/06/09 03:14:18 todd Exp $	*/
a365 1
    ifp->if_output = fddi_output;
@


1.13
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.12 2002/06/02 22:49:59 deraadt Exp $	*/
a60 1
#include <net/bpfdesc.h>
@


1.12
log
@withough -> without
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.11 2002/03/12 09:51:20 kjc Exp $	*/
d97 2
a98 2
    sc->sc_ac.ac_ipaddr = IA_SIN(ifa)->sin_addr;
    arpwhohas(&sc->sc_ac, &IA_SIN(ifa)->sin_addr);
d154 1
a154 1
    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_ac.ac_if));
d248 1
a248 1
    ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);
d265 1
a265 1
    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_ac.ac_if));
d279 1
a279 1
		    arp_ifinit(&sc->sc_ac, ifa);
d292 1
a292 1
			ina->x_host = *(union ns_host *)(sc->sc_ac.ac_enaddr);
d296 2
a297 2
			      (caddr_t)sc->sc_ac.ac_enaddr,
			      sizeof sc->sc_ac.ac_enaddr);
d324 1
a324 1
		error = ether_addmulti((struct ifreq *)data, &sc->sc_ac);
d326 1
a326 1
		error = ether_delmulti((struct ifreq *)data, &sc->sc_ac);
@


1.11
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.10 2001/11/06 19:53:18 miod Exp $	*/
d14 1
a14 1
 *    derived from this software withough specific prior written permission
@


1.10
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.9 2001/09/11 20:05:25 miod Exp $	*/
d147 1
a147 7
    for (;;) {
	struct mbuf *m;
	IFQ_DEQUEUE(&ifp->if_snd, m);
	if (m == NULL)
	    return;
	m_freem(m);
    }
a368 1
#ifdef notyet /* if_fddisubr.c hasn't been converted yet */
a369 1
#endif
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.10 2001/11/06 19:53:18 miod Exp $	*/
d14 1
a14 1
 *    derived from this software without specific prior written permission
d97 2
a98 2
    sc->sc_arpcom.ac_ipaddr = IA_SIN(ifa)->sin_addr;
    arpwhohas(&sc->sc_arpcom, &IA_SIN(ifa)->sin_addr);
d147 7
a153 1
    IFQ_PURGE(&ifp->if_snd);
d160 1
a160 1
    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_arpcom.ac_if));
d254 1
a254 1
    ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
d271 1
a271 1
    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_arpcom.ac_if));
d285 1
a285 1
		    arp_ifinit(&sc->sc_arpcom, ifa);
d298 1
a298 1
			ina->x_host = *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
d302 2
a303 2
			      (caddr_t)sc->sc_arpcom.ac_enaddr,
			      sizeof sc->sc_arpcom.ac_enaddr);
d330 1
a330 1
		error = ether_addmulti((struct ifreq *)data, &sc->sc_arpcom);
d332 1
a332 1
		error = ether_delmulti((struct ifreq *)data, &sc->sc_arpcom);
d375 1
d377 1
@


1.9
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.8 2001/08/12 20:33:50 mickey Exp $	*/
d86 1
a86 1
#include <vm/vm.h>
@


1.8
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.7 2001/06/27 06:34:42 kjc Exp $	*/
a86 1
#include <vm/vm_kern.h>
@


1.7
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.6 1996/10/31 01:01:37 niklas Exp $	*/
a87 1
#include <vm/vm_param.h>
@


1.6
log
@$OpenBSD RCSIDs
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.5 1996/05/20 00:26:21 thorpej Exp $	*/
d151 1
a151 1
	IF_DEQUEUE(&ifp->if_snd, m);
a162 1
    struct ifqueue *ifq = &ifp->if_snd;
d177 1
a177 1
	IF_DEQUEUE(ifq, m);
a182 1
	    IF_PREPEND(ifq, m);
d185 2
d224 1
a224 1
    if (sc->sc_if.if_snd.ifq_head != NULL) {
d377 3
@


1.6.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.6 1996/10/31 01:01:37 niklas Exp $	*/
d151 1
a151 1
	IFQ_DEQUEUE(&ifp->if_snd, m);
d163 1
d178 1
a178 1
	IFQ_POLL(&ifp->if_snd, m);
d184 1
a186 2

	IFQ_DEQUEUE(&ifp->if_snd, m);
d224 1
a224 1
    if (!IFQ_IS_EMPTY(&sc->sc_if.if_snd)) {
a376 3
#ifdef notyet /* if_fddisubr.c hasn't been converted yet */
    IFQ_SET_READY(&ifp->if_snd);
#endif
@


1.6.14.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.6.14.1 2001/07/04 10:41:03 niklas Exp $	*/
d87 2
@


1.6.14.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
a86 1
#include <uvm/uvm_extern.h>
@


1.6.14.4
log
@Merge in -current from about a week ago
@
text
@d147 7
a153 1
    IFQ_PURGE(&ifp->if_snd);
d375 1
d377 1
@


1.6.14.5
log
@Sync the SMP branch with 3.3
@
text
@d14 1
a14 1
 *    derived from this software without specific prior written permission
d97 2
a98 2
    sc->sc_arpcom.ac_ipaddr = IA_SIN(ifa)->sin_addr;
    arpwhohas(&sc->sc_arpcom, &IA_SIN(ifa)->sin_addr);
d154 1
a154 1
    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_arpcom.ac_if));
d248 1
a248 1
    ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
d265 1
a265 1
    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_arpcom.ac_if));
d279 1
a279 1
		    arp_ifinit(&sc->sc_arpcom, ifa);
d292 1
a292 1
			ina->x_host = *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
d296 2
a297 2
			      (caddr_t)sc->sc_arpcom.ac_enaddr,
			      sizeof sc->sc_arpcom.ac_enaddr);
d324 1
a324 1
		error = ether_addmulti((struct ifreq *)data, &sc->sc_arpcom);
d326 1
a326 1
		error = ether_delmulti((struct ifreq *)data, &sc->sc_arpcom);
@


1.6.14.6
log
@Merge with the trunk
@
text
@d61 1
@


1.5
log
@latest pdq from matt thomas
@
text
@d1 1
@


1.4
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@a0 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.3 1996/05/26 00:27:03 deraadt Exp $	*/
d366 2
a367 1
#if (defined(__FreeBSD__) && BSD >= 199506) || defined(__NetBSD__) || defined(__OpenBSD__)
@


1.3
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: pdq_ifsubr.c,v 1.2 1996/05/10 12:41:12 deraadt Exp $	*/
d49 1
a49 1
#elif defined(__bsdi__) || defined(__NetBSD__)
d367 1
a367 1
#if (defined(__FreeBSD__) && BSD >= 199506) || defined(__NetBSD__)
@


1.2
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pdq_ifsubr.c,v 1.3 1996/05/07 01:43:15 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995 Matt Thomas (thomas@@lkg.dec.com)
d27 1
a27 50
 * from Id: pdq_ifsubr.c,v 1.2 1995/08/20 18:59:00 thomas Exp
 *
 * Log: pdq_ifsubr.c,v
 * Revision 1.2  1995/08/20  18:59:00  thomas
 * Changes for NetBSD
 *
 * Revision 1.1  1995/08/20  15:43:49  thomas
 * Initial revision
 *
 * Revision 1.13  1995/08/04  21:54:56  thomas
 * Clean IRQ processing under BSD/OS.
 * A receive tweaks.  (print source of MAC CRC errors, etc.)
 *
 * Revision 1.12  1995/06/02  16:04:22  thomas
 * Use correct PCI defs for BSDI now that they have fixed them.
 * Increment the slot number 0x1000, not one! (*duh*)
 *
 * Revision 1.11  1995/04/21  13:23:55  thomas
 * Fix a few pub in the DEFPA BSDI support
 *
 * Revision 1.10  1995/04/20  21:46:42  thomas
 * Why???
 * ,
 *
 * Revision 1.9  1995/04/20  20:17:33  thomas
 * Add PCI support for BSD/OS.
 * Fix BSD/OS EISA support.
 * Set latency timer for DEFPA to recommended value if 0.
 *
 * Revision 1.8  1995/04/04  22:54:29  thomas
 * Fix DEFEA support
 *
 * Revision 1.7  1995/03/14  01:52:52  thomas
 * Update for new FreeBSD PCI Interrupt interface
 *
 * Revision 1.6  1995/03/10  17:06:59  thomas
 * Update for latest version of FreeBSD.
 * Compensate for the fast that the ifp will not be first thing
 * in softc on BSDI.
 *
 * Revision 1.5  1995/03/07  19:59:42  thomas
 * First pass at BSDI EISA support
 *
 * Revision 1.4  1995/03/06  17:06:03  thomas
 * Add transmit timeout support.
 * Add support DEFEA (untested).
 *
 * Revision 1.3  1995/03/03  13:48:35  thomas
 * more fixes
 *
d34 2
a35 13
 * Written by Matt Thomas
 *
 *   This driver supports the following FDDI controllers:
 *
 *	Device:			Config file entry:
 *	  DEC DEFPA (PCI)         device fpa0
 *	  DEC DEFEA (EISA)        device fea0 at isa0 net irq ? vector feaintr
 *
 *   Eventually, the following adapters will also be supported:
 *
 *	  DEC DEFTA (TC)	  device fta0 at tc? slot * vector ftaintr
 *	  DEC DEFQA (Q-Bus)	  device fta0 at uba? csr 0?? vector fqaintr
 *	  DEC DEFAA (FB+)	  device faa0 at fbus? slot * vector faaintr
a39 1
#include <sys/systm.h>
d77 4
d90 1
d92 13
a104 4
#if defined(__NetBSD__)
#include "pdqvar.h"
#else
#include "pdq_os.h"
d107 1
d140 1
a140 1
    pdq_softc_t *sc)
a141 1
    struct mbuf *m;
d147 2
a148 2
    sc->sc_if.if_flags &= ~IFF_OACTIVE;
    sc->sc_if.if_timer = 0;
d150 2
a151 1
	IF_DEQUEUE(&sc->sc_if.if_snd, m);
d204 1
a204 1
	bpf_mtap(sc->sc_bpf, m);
d240 1
a240 1
	bpf_mtap(sc->sc_bpf, m);
d284 1
a284 1
#ifdef INET
a285 1
		    sc->sc_ac.ac_ipaddr = IA_SIN(ifa)->sin_addr;
a286 1
#if !defined(__bsdi__)
a287 5
#else
		    arpwhohas(&sc->sc_ac, &IA_SIN(ifa)->sin_addr);
		    ifa->ifa_rtrequest = arp_rtrequest;
		    ifa->ifa_flags |= RTF_CLONING;
#endif
d292 1
a292 1
#ifdef NS
d354 4
d361 1
a361 2
    pdq_ifinit_t ifinit,
    pdq_ifwatchdog_t ifwatchdog)
d367 4
a370 2
#if !defined(__NetBSD__)
    ifp->if_init = ifinit;
a371 1
    ifp->if_watchdog = ifwatchdog;
d380 1
a380 1
    bpfattach(&sc->sc_bpf, ifp, DLT_FDDI, sizeof(struct fddi_header));
@


1.1
log
@NetBSD 960317 merge
@
text
@d2 1
a2 1
/*	$NetBSD: pdq_ifsubr.c,v 1.2 1996/03/11 21:41:32 thorpej Exp $	*/
d410 2
a411 2
    ifnet_ret_t (*ifinit)(int unit),
    ifnet_ret_t (*ifwatchdog)(int unit))
@
