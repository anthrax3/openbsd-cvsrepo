head	1.23;
access;
symbols
	OPENBSD_6_0:1.23.0.14
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.8
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.10
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.20.0.14
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.12
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.8
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2014.01.18.23.09.04;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.18.22.56.11;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.18.22.33.59;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.26.22.16.23;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.23.20.35.40;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.29.19.17.43;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.05.12.27.02;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.24.00.41.51;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.27.04.01.42;	author jason;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.08.21.14.22.27;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.21.11.20.34;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.17.18.03.11;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	98.09.02.06.09.28;	author deraadt;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	98.05.28.22.07.54;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	98.02.03.22.02.48;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	97.08.08.08.13.06;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.02.27.13.57.23;	author briggs;	state Exp;
branches;
next	;

1.5.8.1
date	2001.05.14.22.24.02;	author niklas;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.5.8.3;

1.5.8.3
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.5.8.4;

1.5.8.4
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	1.5.8.5;

1.5.8.5
date	2003.05.13.19.35.02;	author ho;	state Exp;
branches;
next	1.5.8.6;

1.5.8.6
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.5.8.7;

1.5.8.7
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.05.19.21.54.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@move the declaration of ncr53c9x_scsi_cmd into the .c file, its the only
place that uses it.
@
text
@/*	$OpenBSD: ncr53c9xvar.h,v 1.22 2014/01/18 22:56:11 dlg Exp $	*/
/*	$NetBSD: ncr53c9xvar.h,v 1.13 1998/05/26 23:17:34 thorpej Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 Peter Galbavy.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/timeout.h>

/* Set this to 1 for normal debug, or 2 for per-target tracing. */
#if !defined(SMALL_KERNEL)
#define NCR53C9X_DEBUG		1
#endif

/* Wide or differential can have 16 targets */
#define NCR_NTARG		16
#define NCR_NLUN		8

#define	NCR_ABORT_TIMEOUT	2000	/* time to wait for abort */
#define	NCR_SENSE_TIMEOUT	1000	/* time to wait for sense */

#define FREQTOCCF(freq)	(((freq + 4) / 5))

/*
 * NCR 53c9x variants.  Note, these values are used as indexes into
 * a table; don't modify them unless you know what you're doing.
 */
#define	NCR_VARIANT_ESP100		0
#define	NCR_VARIANT_ESP100A		1
#define	NCR_VARIANT_ESP200		2
#define	NCR_VARIANT_NCR53C94		3
#define	NCR_VARIANT_NCR53C96		4
#define	NCR_VARIANT_ESP406		5
#define	NCR_VARIANT_FAS408		6
#define	NCR_VARIANT_FAS216		7
#define	NCR_VARIANT_AM53C974		8
#define	NCR_VARIANT_FAS366		9
#define	NCR_VARIANT_MAX			10

/*
 * ECB. Holds additional information for each SCSI command Comments: We
 * need a separate scsi command block because we may need to overwrite it
 * with a request sense command.  Basicly, we refrain from fiddling with
 * the scsi_xfer struct (except do the expected updating of return values).
 * We'll generally update: xs->{flags,resid,error,sense,status} and
 * occasionally xs->retries.
 */
struct ncr53c9x_ecb {
	TAILQ_ENTRY(ncr53c9x_ecb) chain;
	struct scsi_xfer *xs;	/* SCSI xfer ctrl block from above */
	int flags;
#define	ECB_ALLOC		0x01
#define	ECB_READY		0x02
#define	ECB_SENSE		0x04
#define	ECB_ABORT		0x40
#define	ECB_RESET		0x80
#define	ECB_TENTATIVE_DONE	0x100
	int timeout;
	struct timeout to;

	struct {
		u_char	msg[3];			/* Selection Id msg */
		struct scsi_generic cmd;	/* SCSI command block */
	} cmd;
	char	*daddr;		/* Saved data pointer */
	int	clen;		/* Size of command in cmd.cmd */
	int	dleft;		/* Residue */
	u_char	stat;		/* SCSI status byte */
	u_char	tag[2];		/* TAG bytes */
	u_char	pad[1];

#if NCR53C9X_DEBUG > 1
	char trace[1000];
#endif
};
#if NCR53C9X_DEBUG > 1
#define ECB_TRACE(ecb, msg, a, b) do { \
	const char *f = "[" msg "]"; \
	int n = strlen((ecb)->trace); \
	if (n < (sizeof((ecb)->trace)-100)) \
		snprintf((ecb)->trace + n, sizeof((ecb)->trace) - n, f,  a, b); \
} while(0)
#else
#define ECB_TRACE(ecb, msg, a, b)
#endif

/*
 * Some info about ech (possible) target and LUN on the SCSI bus.
 *
 * SCSI I and II devices can have up to 8 LUNs, each with up to 256
 * outstanding tags.  SCSI III devices have 64-bit LUN identifiers
 * that can be sparsely allocated.
 *
 * Since SCSI II devices can have up to 8 LUNs, we use an array
 * of 8 pointers to ncr53c9x_linfo structures for fast lookup.
 * Longer LUNs need to traverse the linked list.
 */

struct ncr53c9x_linfo {
	int64_t			lun;
	LIST_ENTRY(ncr53c9x_linfo) link;
	time_t			last_used;
	unsigned char		used;	/* # slots in use */
	unsigned char		avail;	/* where to start scanning */
	unsigned char		busy;
	struct ncr53c9x_ecb	*untagged;
	struct ncr53c9x_ecb	*queued[256];
};

struct ncr53c9x_tinfo {
	int	cmds;		/* # of commands processed */
	int	dconns;		/* # of disconnects */
	int	touts;		/* # of timeouts */
	int	perrs;		/* # of parity errors */
	int	senses;		/* # of request sense commands sent */
	u_char  flags;
#define T_NEED_TO_RESET	0x01	/* Should send a BUS_DEV_RESET */
#define T_NEGOTIATE	0x02	/* (Re)Negotiate synchronous options */
#define T_BUSY		0x04	/* Target is busy, i.e. cmd in progress */
#define T_SYNCMODE	0x08	/* sync mode has been negotiated */
#define T_SYNCHOFF	0x10	/* .. */
#define T_RSELECTOFF	0x20	/* .. */
#define T_TAG		0x40	/* TAG QUEUEs are on */
#define T_WIDE		0x80	/* Negotiate wide options */
	u_char  period;		/* Period suggestion */
	u_char  offset;		/* Offset suggestion */
	u_char	cfg3;		/* per target config 3 */
	u_char	nextag;		/* Next available tag */
	u_char	width;		/* width suggestion */
	LIST_HEAD(lun_list, ncr53c9x_linfo) luns;
	struct ncr53c9x_linfo *lun[NCR_NLUN];	/* For speedy lookups */
};

/* Look up a lun in a tinfo */
#define TINFO_LUN(t, l)		((((l) < NCR_NLUN) && (((t)->lun[(l)]) != NULL)) ? \
    ((t)->lun[(l)]) : ncr53c9x_lunsearch((t), (int64_t)(l)))

/* Register a linenumber (for debugging) */
#define LOGLINE(p)

#define NCR_SHOWECBS	0x01
#define NCR_SHOWINTS	0x02
#define NCR_SHOWCMDS	0x04
#define NCR_SHOWMISC	0x08
#define NCR_SHOWTRAC	0x10
#define NCR_SHOWSTART	0x20
#define NCR_SHOWPHASE	0x40
#define NCR_SHOWDMA	0x80
#define NCR_SHOWCCMDS	0x100
#define NCR_SHOWMSGS	0x200

#ifdef NCR53C9X_DEBUG
extern int ncr53c9x_debug;
#define NCR_ECBS(str)	\
	do {if (ncr53c9x_debug & NCR_SHOWECBS) printf str;} while (0)
#define NCR_MISC(str)	\
	do {if (ncr53c9x_debug & NCR_SHOWMISC) printf str;} while (0)
#define NCR_INTS(str)	\
	do {if (ncr53c9x_debug & NCR_SHOWINTS) printf str;} while (0)
#define NCR_TRACE(str)	\
	do {if (ncr53c9x_debug & NCR_SHOWTRAC) printf str;} while (0)
#define NCR_CMDS(str)	\
	do {if (ncr53c9x_debug & NCR_SHOWCMDS) printf str;} while (0)
#define NCR_START(str)	\
	do {if (ncr53c9x_debug & NCR_SHOWSTART) printf str;}while (0)
#define NCR_PHASE(str)	\
	do {if (ncr53c9x_debug & NCR_SHOWPHASE) printf str;}while (0)
#define NCR_DMA(str)	\
	do {if (ncr53c9x_debug & NCR_SHOWDMA) printf str;}while (0)
#define NCR_MSGS(str)	\
	do {if (ncr53c9x_debug & NCR_SHOWMSGS) printf str;}while (0)
#else
#define NCR_ECBS(str)
#define NCR_MISC(str)
#define NCR_INTS(str)
#define NCR_TRACE(str)
#define NCR_CMDS(str)
#define NCR_START(str)
#define NCR_PHASE(str)
#define NCR_DMA(str)
#define NCR_MSGS(str)
#endif

#define NCR_MAX_MSG_LEN 8

struct ncr53c9x_softc;

/*
 * Function switch used as glue to MD code.
 */
struct ncr53c9x_glue {
	/* Mandatory entry points. */
	u_char	(*gl_read_reg)(struct ncr53c9x_softc *, int);
	void	(*gl_write_reg)(struct ncr53c9x_softc *, int, u_char);
	int	(*gl_dma_isintr)(struct ncr53c9x_softc *);
	void	(*gl_dma_reset)(struct ncr53c9x_softc *);
	int	(*gl_dma_intr)(struct ncr53c9x_softc *);
	int	(*gl_dma_setup)(struct ncr53c9x_softc *,
		    caddr_t *, size_t *, int, size_t *);
	void	(*gl_dma_go)(struct ncr53c9x_softc *);
	void	(*gl_dma_stop)(struct ncr53c9x_softc *);
	int	(*gl_dma_isactive)(struct ncr53c9x_softc *);

	/* Optional entry points. */
	void	(*gl_clear_latched_intr)(struct ncr53c9x_softc *);
};

struct ncr53c9x_softc {
	struct device sc_dev;			/* us as a device */

	struct scsi_link sc_link;		/* scsi link struct */

	struct ncr53c9x_glue *sc_glue;		/* glue to MD code */

	int	sc_ntarg;			/* number of targets */
	int	sc_cfflags;			/* Copy of config flags */

	/* register defaults */
	u_char	sc_cfg1;			/* Config 1 */
	u_char	sc_cfg2;			/* Config 2, not ESP100 */
	u_char	sc_cfg3;			/* Config 3, only ESP200 */
	u_char	sc_cfg3_fscsi;			/* Chip specific FSCSI bit */
	u_char	sc_cfg4;			/* Config 4 */
	u_char	sc_cfg5;			/* Config 5 */
	u_char	sc_ccf;				/* Clock Conversion */
	u_char	sc_timeout;

	/* register copies, see espreadregs() */
	u_char	sc_espintr;
	u_char	sc_espstat;
	u_char	sc_espstep;
	u_char	sc_espstat2;
	u_char	sc_espfflags;

	/* Lists of command blocks */
	TAILQ_HEAD(ecb_list, ncr53c9x_ecb) ready_list;

	struct ncr53c9x_ecb *sc_nexus;		/* Current command */
	struct ncr53c9x_tinfo sc_tinfo[NCR_NTARG];

	/* Data about the current nexus (updated for every cmd switch) */
	caddr_t	sc_dp;		/* Current data pointer */
	ssize_t	sc_dleft;	/* Data left to transfer */

	/* Adapter state */
	int	sc_phase;	/* Copy of what bus phase we are in */
	int	sc_prevphase;	/* Copy of what bus phase we were in */
	u_char	sc_state;	/* State applicable to the adapter */
	u_char	sc_flags;	/* See below */
	u_char	sc_selid;
	u_char	sc_lastcmd;

	/* Message stuff */
	u_short sc_msgify;	/* IDENTIFY message associated with this nexus */
	u_short sc_msgout;	/* What message is on its way out? */
	u_short sc_msgpriq;	/* One or more messages to send (encoded) */
	u_short sc_msgoutq;	/* What messages have been sent so far? */

	u_char	*sc_omess;	/* MSGOUT buffer */
	caddr_t	sc_omp;		/* Message pointer (for multibyte messages) */
	size_t	sc_omlen;
	u_char	*sc_imess;	/* MSGIN buffer */
	caddr_t	sc_imp;		/* Message pointer (for multibyte messages) */
	size_t	sc_imlen;

	caddr_t	sc_cmdp;	/* Command pointer (for DMAed commands) */
	size_t	sc_cmdlen;	/* Size of command in transit */

	/* Hardware attributes */
	int sc_freq;		/* SCSI bus frequency in MHz */
	int sc_id;		/* Our SCSI id */
	int sc_rev;		/* Chip revision */
	int sc_features;	/* Chip features */
	int sc_minsync;		/* Minimum sync period / 4 */
	int sc_maxxfer;		/* Maximum transfer size */
};

/* values for sc_state */
#define NCR_IDLE	1	/* waiting for something to do */
#define NCR_SELECTING	2	/* SCSI command is arbiting  */
#define NCR_RESELECTED	3	/* Has been reselected */
#define NCR_IDENTIFIED	4	/* Has gotten IFY but not TAG */
#define NCR_CONNECTED	5	/* Actively using the SCSI bus */
#define NCR_DISCONNECT	6	/* MSG_DISCONNECT received */
#define NCR_CMDCOMPLETE	7	/* MSG_CMDCOMPLETE received */
#define NCR_CLEANING	8
#define NCR_SBR		9	/* Expect a SCSI RST because we commanded it */

/* values for sc_flags */
#define NCR_DROP_MSGI	0x01	/* Discard all msgs (parity err detected) */
#define NCR_ABORTING	0x02	/* Bailing out */
#define NCR_DOINGDMA	0x04	/* The FIFO data path is active! */
#define NCR_SYNCHNEGO	0x08	/* Synch negotiation in progress. */
#define NCR_ICCS	0x10	/* Expect status phase results */
#define NCR_WAITI	0x20	/* Waiting for non-DMA data to arrive */
#define	NCR_ATN		0x40	/* ATN asserted */
#define	NCR_EXPECT_ILLCMD	0x80	/* Expect Illegal Command Interrupt */

/* values for sc_features */
#define	NCR_F_HASCFG3	0x01	/* chip has CFG3 register */
#define	NCR_F_FASTSCSI	0x02	/* chip supports Fast mode */
#define	NCR_F_DMASELECT	0x04	/* can do dma select */
#define	NCR_F_SELATN3	0x08	/* can do selatn3 */

/* values for sc_msgout */
#define SEND_DEV_RESET		0x0001
#define SEND_PARITY_ERROR	0x0002
#define SEND_INIT_DET_ERR	0x0004
#define SEND_REJECT		0x0008
#define SEND_IDENTIFY  		0x0010
#define SEND_ABORT		0x0020
#define SEND_WDTR		0x0040
#define SEND_SDTR		0x0080
#define SEND_TAG		0x0100

/* SCSI Status codes */
#define ST_MASK			0x3e /* bit 0,6,7 is reserved */

/* phase bits */
#define IOI			0x01
#define CDI			0x02
#define MSGI			0x04

/* Information transfer phases */
#define DATA_OUT_PHASE		(0)
#define DATA_IN_PHASE		(IOI)
#define COMMAND_PHASE		(CDI)
#define STATUS_PHASE		(CDI|IOI)
#define MESSAGE_OUT_PHASE	(MSGI|CDI)
#define MESSAGE_IN_PHASE	(MSGI|CDI|IOI)

#define PHASE_MASK		(MSGI|CDI|IOI)

/* Some pseudo phases for getphase()*/
#define BUSFREE_PHASE		0x100	/* Re/Selection no longer valid */
#define INVALID_PHASE		0x101	/* Re/Selection valid, but no REQ yet */
#define PSEUDO_PHASE		0x100	/* "pseudo" bit */

/*
 * Macros to read and write the chip's registers.
 */
#define	NCR_READ_REG(sc, reg)		\
				(*(sc)->sc_glue->gl_read_reg)((sc), (reg))
#define	NCR_WRITE_REG(sc, reg, val)	\
			(*(sc)->sc_glue->gl_write_reg)((sc), (reg), (val))

#ifdef NCR53C9X_DEBUG
#define	NCRCMD(sc, cmd) do {						\
	if (ncr53c9x_debug & NCR_SHOWCCMDS)				\
		printf("<cmd:0x%x %d>", (unsigned)cmd, __LINE__);	\
	sc->sc_lastcmd = cmd;						\
	NCR_WRITE_REG(sc, NCR_CMD, cmd);				\
} while (0)
#else
#define	NCRCMD(sc, cmd)		NCR_WRITE_REG(sc, NCR_CMD, cmd)
#endif

/*
 * DMA macros for NCR53c9x
 */
#define	NCRDMA_ISINTR(sc)	(*(sc)->sc_glue->gl_dma_isintr)((sc))
#define	NCRDMA_RESET(sc)	(*(sc)->sc_glue->gl_dma_reset)((sc))
#define	NCRDMA_INTR(sc)		(*(sc)->sc_glue->gl_dma_intr)((sc))
#define	NCRDMA_SETUP(sc, addr, len, datain, dmasize)	\
     (*(sc)->sc_glue->gl_dma_setup)((sc), (addr), (len), (datain), (dmasize))
#define	NCRDMA_GO(sc)		(*(sc)->sc_glue->gl_dma_go)((sc))
#define	NCRDMA_ISACTIVE(sc)	(*(sc)->sc_glue->gl_dma_isactive)((sc))

/*
 * Macro to convert the chip register Clock Per Byte value to
 * Synchronous Transfer Period.
 */
#define	ncr53c9x_cpb2stp(sc, cpb)	\
	((250 * (cpb)) / (sc)->sc_freq)

void	ncr53c9x_attach(struct ncr53c9x_softc *);
void	ncr53c9x_reset(struct ncr53c9x_softc *);
int	ncr53c9x_intr(void *);
void	ncr53c9x_init(struct ncr53c9x_softc *, int);
@


1.22
log
@get rid of a XS_NO_CCB thats caused by a failure to allocate the
thing that stores state for luns.

instead of checking and allocating it in the scsi_cmd path, and
doing weird things all over the place to free it (eg, there's a
timeout that ran every 10m to gc luns), use the scsi_probe and
scsi_free things the midlayer calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.21 2014/01/18 22:33:59 dlg Exp $	*/
a426 1
void	ncr53c9x_scsi_cmd(struct scsi_xfer *);
@


1.21
log
@instead of having every bit of glue set up and attach an identical
scsi_adapter struct, just do it once in the chip code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.20 2010/06/28 18:31:02 krw Exp $	*/
a260 1
	struct timeout sc_watchdog;		/* periodic timer */
@


1.20
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.19 2010/03/23 01:57:19 krw Exp $	*/
d427 1
a427 2
void	ncr53c9x_attach(struct ncr53c9x_softc *,
	    struct scsi_adapter *);
@


1.19
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.18 2008/06/26 05:42:15 ray Exp $	*/
d428 1
a428 1
	    struct scsi_adapter *, struct scsi_device *);
@


1.18
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.17 2006/06/26 22:16:23 miod Exp $	*/
d429 1
a429 1
int	ncr53c9x_scsi_cmd(struct scsi_xfer *);
@


1.17
log
@Enable wide targets on FAS366 esp; note that this changes the way esp
user-controllable device flags are parsed, be sure to rerun config(8) on your
next kernel compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.16 2006/05/23 20:35:40 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.16
log
@Do not define NCR53C9X_DEBUG if SMALL_KERNEL. Saves 7KB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.15 2004/09/29 19:17:43 miod Exp $	*/
d73 1
a73 1
#define NCR_NTARG		8
d273 1
@


1.15
log
@Ratibibugle now useless evcnt structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.14 2003/10/21 18:58:49 jmc Exp $	*/
d68 1
d70 1
@


1.14
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.13 2003/06/05 12:27:02 deraadt Exp $	*/
a265 1
	struct evcnt sc_intrcnt;		/* intr count */
@


1.13
log
@3/4 knockout for peter galbavy
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.12 2003/04/27 11:22:52 ho Exp $	*/
d427 1
a427 1
 * Sunchronous Transfer Period.
@


1.12
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.11 2003/02/24 00:41:51 miod Exp $	*/
a51 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Peter Galbavy.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.11
log
@Various typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.10 2002/03/14 01:26:55 millert Exp $	*/
d141 1
a141 1
		sprintf((ecb)->trace + n, f,  a, b); \
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.9 2001/09/27 04:01:42 jason Exp $	*/
d273 1
a273 1
	struct scsi_link sc_link;		/* scsi lint struct */
@


1.9
log
@Huge merge with NetBSD.  For full details look at their revision history (1.26 -> 1.83)...
Highlights:
o tag queue support
o fas366 support (doesn't work yet on sparc, but does on sparc64)
o tons more
(thanks to hugh, fgsch and beck for testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.8 2001/08/21 14:22:27 jason Exp $	*/
d253 10
a262 10
	u_char	(*gl_read_reg) __P((struct ncr53c9x_softc *, int));
	void	(*gl_write_reg) __P((struct ncr53c9x_softc *, int, u_char));
	int	(*gl_dma_isintr) __P((struct ncr53c9x_softc *));
	void	(*gl_dma_reset) __P((struct ncr53c9x_softc *));
	int	(*gl_dma_intr) __P((struct ncr53c9x_softc *));
	int	(*gl_dma_setup) __P((struct ncr53c9x_softc *,
		    caddr_t *, size_t *, int, size_t *));
	void	(*gl_dma_go) __P((struct ncr53c9x_softc *));
	void	(*gl_dma_stop) __P((struct ncr53c9x_softc *));
	int	(*gl_dma_isactive) __P((struct ncr53c9x_softc *));
d265 1
a265 1
	void	(*gl_clear_latched_intr) __P((struct ncr53c9x_softc *));
d437 6
a442 6
void	ncr53c9x_attach __P((struct ncr53c9x_softc *,
	    struct scsi_adapter *, struct scsi_device *));
int	ncr53c9x_scsi_cmd __P((struct scsi_xfer *));
void	ncr53c9x_reset __P((struct ncr53c9x_softc *));
int	ncr53c9x_intr __P((void *));
void	ncr53c9x_init __P((struct ncr53c9x_softc *, int));
@


1.9.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.9 2001/09/27 04:01:42 jason Exp $	*/
d253 10
a262 10
	u_char	(*gl_read_reg)(struct ncr53c9x_softc *, int);
	void	(*gl_write_reg)(struct ncr53c9x_softc *, int, u_char);
	int	(*gl_dma_isintr)(struct ncr53c9x_softc *);
	void	(*gl_dma_reset)(struct ncr53c9x_softc *);
	int	(*gl_dma_intr)(struct ncr53c9x_softc *);
	int	(*gl_dma_setup)(struct ncr53c9x_softc *,
		    caddr_t *, size_t *, int, size_t *);
	void	(*gl_dma_go)(struct ncr53c9x_softc *);
	void	(*gl_dma_stop)(struct ncr53c9x_softc *);
	int	(*gl_dma_isactive)(struct ncr53c9x_softc *);
d265 1
a265 1
	void	(*gl_clear_latched_intr)(struct ncr53c9x_softc *);
d437 6
a442 6
void	ncr53c9x_attach(struct ncr53c9x_softc *,
	    struct scsi_adapter *, struct scsi_device *);
int	ncr53c9x_scsi_cmd(struct scsi_xfer *);
void	ncr53c9x_reset(struct ncr53c9x_softc *);
int	ncr53c9x_intr(void *);
void	ncr53c9x_init(struct ncr53c9x_softc *, int);
@


1.9.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d141 1
a141 1
		snprintf((ecb)->trace + n, sizeof((ecb)->trace) - n, f,  a, b); \
d273 1
a273 1
	struct scsi_link sc_link;		/* scsi link struct */
@


1.8
log
@From NetBSD:
#define's for FAS366 (needed for compile of esp_sbus)
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.7 2000/07/21 11:20:34 art Exp $	*/
d75 4
d113 1
a113 1
#define	ECB_NEXUS		0x02
d122 1
a122 1
		u_char	id;			/* Selection Id msg */
a124 1
	int	 clen;		/* Size of command in cmd.cmd */
d126 5
a130 3
	int	 dleft;		/* Residue */
	u_char 	 stat;		/* SCSI status byte */
	u_char	pad[3];
d148 9
a156 3
 * Some info about each (possible) target on the SCSI bus.  This should
 * probably have been a "per target+lunit" structure, but we'll leave it at
 * this for now.  Is there a way to reliably hook it up to sc->fordriver??
d158 12
d171 5
a175 6
	int	cmds;		/* #commands processed */
	int	dconns;		/* #disconnects */
	int	touts;		/* #timeouts */
	int	perrs;		/* #parity errors */
	int	senses;		/* #request sense commands sent */
	ushort	lubusy;		/* What local units/subr. are busy? */
d183 2
d187 10
a196 2
	u_char	pad[3];
} tinfo_t;
d272 1
d293 1
d297 1
a297 3
	TAILQ_HEAD(ecb_list, ncr53c9x_ecb) free_list,
				      ready_list,
				      nexus_list;
d300 1
a300 2
	struct ncr53c9x_ecb sc_ecb[3*8];	/* Three per target */
	struct ncr53c9x_tinfo sc_tinfo[8];
d315 5
a319 3
	u_char	sc_msgpriq;	/* One or more messages to send (encoded) */
	u_char	sc_msgout;	/* What message is on its way out? */
	u_char	sc_msgoutq;	/* What messages have been sent so far? */
d343 6
a348 5
#define NCR_CONNECTED	4	/* Actively using the SCSI bus */
#define	NCR_DISCONNECT	5	/* MSG_DISCONNECT received */
#define	NCR_CMDCOMPLETE	6	/* MSG_CMDCOMPLETE received */
#define	NCR_CLEANING	7
#define NCR_SBR		8	/* Expect a SCSI RST because we commanded it */
d363 2
d367 9
a375 8
#define SEND_DEV_RESET		0x01
#define SEND_PARITY_ERROR	0x02
#define SEND_INIT_DET_ERR	0x04
#define SEND_REJECT		0x08
#define SEND_IDENTIFY  		0x10
#define SEND_ABORT		0x20
#define SEND_SDTR		0x40
#define SEND_WDTR		0x80
d409 5
a413 5
#define	NCRCMD(sc, cmd) do {				\
	if (ncr53c9x_debug & NCR_SHOWCCMDS)		\
		printf("<cmd:0x%x>", (unsigned)cmd);	\
	sc->sc_lastcmd = cmd;				\
	NCR_WRITE_REG(sc, NCR_CMD, cmd);		\
a442 2

extern	int ncr53c9x_dmaselect;
@


1.7
log
@Use new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.6 2000/06/17 18:03:11 fgsch Exp $	*/
d93 2
a94 1
#define	NCR_VARIANT_MAX			9
@


1.6
log
@Add support for AMD 53c974.
>From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.5 1998/09/02 06:09:28 deraadt Exp $	*/
d70 2
d114 1
@


1.5
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.4 1998/05/28 22:07:54 jason Exp $	*/
d90 2
a91 1
#define	NCR_VARIANT_MAX			8
d246 3
d263 2
a264 2
	struct ncr53c9x_ecb *sc_nexus;		/* current command */
	struct ncr53c9x_ecb sc_ecb[3*8];		/* three per target */
d268 2
a269 2
	caddr_t	sc_dp;				/* Current data pointer */
	ssize_t	sc_dleft;			/* Data left to transfer */
d272 4
a275 4
	int	sc_phase;		/* Copy of what bus phase we are in */
	int	sc_prevphase;		/* Copy of what bus phase we were in */
	u_char	sc_state;		/* State applicable to the adapter */
	u_char	sc_flags;
d293 7
a299 7
	/* hardware/openprom stuff */
	int sc_freq;				/* Freq in MHz */
	int sc_id;				/* our scsi id */
	int sc_rev;				/* esp revision */
	int sc_features;			/* chip features */
	int sc_minsync;				/* minimum sync period / 4 */
	int sc_maxxfer;				/* maximum transfer size */
d400 2
a401 1
int	ncr53c9x_intr __P((struct ncr53c9x_softc *));
@


1.5.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.7 2000/07/21 11:20:34 art Exp $	*/
a69 2
#include <sys/timeout.h>

d90 1
a90 2
#define	NCR_VARIANT_AM53C974		8
#define	NCR_VARIANT_MAX			9
a110 1
	struct timeout to;
a244 3
	u_char	sc_cfg3_fscsi;			/* Chip specific FSCSI bit */
	u_char	sc_cfg4;			/* Config 4 */
	u_char	sc_cfg5;			/* Config 5 */
d259 2
a260 2
	struct ncr53c9x_ecb *sc_nexus;		/* Current command */
	struct ncr53c9x_ecb sc_ecb[3*8];	/* Three per target */
d264 2
a265 2
	caddr_t	sc_dp;		/* Current data pointer */
	ssize_t	sc_dleft;	/* Data left to transfer */
d268 4
a271 4
	int	sc_phase;	/* Copy of what bus phase we are in */
	int	sc_prevphase;	/* Copy of what bus phase we were in */
	u_char	sc_state;	/* State applicable to the adapter */
	u_char	sc_flags;	/* See below */
d289 7
a295 7
	/* Hardware attributes */
	int sc_freq;		/* SCSI bus frequency in MHz */
	int sc_id;		/* Our SCSI id */
	int sc_rev;		/* Chip revision */
	int sc_features;	/* Chip features */
	int sc_minsync;		/* Minimum sync period / 4 */
	int sc_maxxfer;		/* Maximum transfer size */
d396 1
a396 2
int	ncr53c9x_intr __P((void *));
void	ncr53c9x_init __P((struct ncr53c9x_softc *, int));
@


1.5.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.5.8.1 2001/05/14 22:24:02 niklas Exp $	*/
a74 4
/* Wide or differential can have 16 targets */
#define NCR_NTARG		8
#define NCR_NLUN		8

d93 1
a93 2
#define	NCR_VARIANT_FAS366		9
#define	NCR_VARIANT_MAX			10
d108 1
a108 1
#define	ECB_READY		0x02
d117 1
a117 1
		u_char	msg[3];			/* Selection Id msg */
d120 1
d122 3
a124 5
	int	clen;		/* Size of command in cmd.cmd */
	int	dleft;		/* Residue */
	u_char	stat;		/* SCSI status byte */
	u_char	tag[2];		/* TAG bytes */
	u_char	pad[1];
d142 3
a144 9
 * Some info about ech (possible) target and LUN on the SCSI bus.
 *
 * SCSI I and II devices can have up to 8 LUNs, each with up to 256
 * outstanding tags.  SCSI III devices have 64-bit LUN identifiers
 * that can be sparsely allocated.
 *
 * Since SCSI II devices can have up to 8 LUNs, we use an array
 * of 8 pointers to ncr53c9x_linfo structures for fast lookup.
 * Longer LUNs need to traverse the linked list.
a145 12

struct ncr53c9x_linfo {
	int64_t			lun;
	LIST_ENTRY(ncr53c9x_linfo) link;
	time_t			last_used;
	unsigned char		used;	/* # slots in use */
	unsigned char		avail;	/* where to start scanning */
	unsigned char		busy;
	struct ncr53c9x_ecb	*untagged;
	struct ncr53c9x_ecb	*queued[256];
};

d147 6
a152 5
	int	cmds;		/* # of commands processed */
	int	dconns;		/* # of disconnects */
	int	touts;		/* # of timeouts */
	int	perrs;		/* # of parity errors */
	int	senses;		/* # of request sense commands sent */
a159 2
#define T_TAG		0x40	/* TAG QUEUEs are on */
#define T_WIDE		0x80	/* Negotiate wide options */
d162 2
a163 10
	u_char	cfg3;		/* per target config 3 */
	u_char	nextag;		/* Next available tag */
	u_char	width;		/* width suggestion */
	LIST_HEAD(lun_list, ncr53c9x_linfo) luns;
	struct ncr53c9x_linfo *lun[NCR_NLUN];	/* For speedy lookups */
};

/* Look up a lun in a tinfo */
#define TINFO_LUN(t, l)		((((l) < NCR_NLUN) && (((t)->lun[(l)]) != NULL)) ? \
    ((t)->lun[(l)]) : ncr53c9x_lunsearch((t), (int64_t)(l)))
a238 1
	struct timeout sc_watchdog;		/* periodic timer */
a258 1
	u_char	sc_espstat2;
d262 3
a264 1
	TAILQ_HEAD(ecb_list, ncr53c9x_ecb) ready_list;
d267 2
a268 1
	struct ncr53c9x_tinfo sc_tinfo[NCR_NTARG];
d283 3
a285 5
	u_short sc_msgify;	/* IDENTIFY message associated with this nexus */
	u_short sc_msgout;	/* What message is on its way out? */
	u_short sc_msgpriq;	/* One or more messages to send (encoded) */
	u_short sc_msgoutq;	/* What messages have been sent so far? */

d309 5
a313 6
#define NCR_IDENTIFIED	4	/* Has gotten IFY but not TAG */
#define NCR_CONNECTED	5	/* Actively using the SCSI bus */
#define NCR_DISCONNECT	6	/* MSG_DISCONNECT received */
#define NCR_CMDCOMPLETE	7	/* MSG_CMDCOMPLETE received */
#define NCR_CLEANING	8
#define NCR_SBR		9	/* Expect a SCSI RST because we commanded it */
a327 2
#define	NCR_F_DMASELECT	0x04	/* can do dma select */
#define	NCR_F_SELATN3	0x08	/* can do selatn3 */
d330 8
a337 9
#define SEND_DEV_RESET		0x0001
#define SEND_PARITY_ERROR	0x0002
#define SEND_INIT_DET_ERR	0x0004
#define SEND_REJECT		0x0008
#define SEND_IDENTIFY  		0x0010
#define SEND_ABORT		0x0020
#define SEND_WDTR		0x0040
#define SEND_SDTR		0x0080
#define SEND_TAG		0x0100
d371 5
a375 5
#define	NCRCMD(sc, cmd) do {						\
	if (ncr53c9x_debug & NCR_SHOWCCMDS)				\
		printf("<cmd:0x%x %d>", (unsigned)cmd, __LINE__);	\
	sc->sc_lastcmd = cmd;						\
	NCR_WRITE_REG(sc, NCR_CMD, cmd);				\
d405 2
@


1.5.8.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d253 10
a262 10
	u_char	(*gl_read_reg)(struct ncr53c9x_softc *, int);
	void	(*gl_write_reg)(struct ncr53c9x_softc *, int, u_char);
	int	(*gl_dma_isintr)(struct ncr53c9x_softc *);
	void	(*gl_dma_reset)(struct ncr53c9x_softc *);
	int	(*gl_dma_intr)(struct ncr53c9x_softc *);
	int	(*gl_dma_setup)(struct ncr53c9x_softc *,
		    caddr_t *, size_t *, int, size_t *);
	void	(*gl_dma_go)(struct ncr53c9x_softc *);
	void	(*gl_dma_stop)(struct ncr53c9x_softc *);
	int	(*gl_dma_isactive)(struct ncr53c9x_softc *);
d265 1
a265 1
	void	(*gl_clear_latched_intr)(struct ncr53c9x_softc *);
d437 6
a442 6
void	ncr53c9x_attach(struct ncr53c9x_softc *,
	    struct scsi_adapter *, struct scsi_device *);
int	ncr53c9x_scsi_cmd(struct scsi_xfer *);
void	ncr53c9x_reset(struct ncr53c9x_softc *);
int	ncr53c9x_intr(void *);
void	ncr53c9x_init(struct ncr53c9x_softc *, int);
@


1.5.8.4
log
@Sync the SMP branch with 3.3
@
text
@d273 1
a273 1
	struct scsi_link sc_link;		/* scsi link struct */
@


1.5.8.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.5.8.4 2003/03/28 00:38:14 niklas Exp $	*/
d141 1
a141 1
		snprintf((ecb)->trace + n, sizeof((ecb)->trace) - n, f,  a, b); \
@


1.5.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.5.8.5 2003/05/13 19:35:02 ho Exp $	*/
d52 5
@


1.5.8.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d427 1
a427 1
 * Synchronous Transfer Period.
@


1.4
log
@Sync with NetBSD:
Allocate SCSI message buffers in ncr53c9x_attach(), with a provision
for front-ends to override the allocation to avoid alignment
handling in their DMA engines. Note that that ncr53c9x_msgout()
can request a 1 byte DMA transfer that would be difficult to break up.

Eliminate the degenerate loop in `ncr53c9x_intr()'. Retain the delay heuristic
it implemented under the label `shortcut:' and only use it in these cases:
  (1) after successful re-relection,
  (2) after receiving command-complete status, and
  (3) during message-in handshake.

If we have an NCR53CF9x (indicated by the front-end by setting a flag
in the softc's new "features" word), set FSCSI bit in CFG3 if the sync
period is <= 200ns, or clear it otherwise.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9xvar.h,v 1.3 1998/02/03 22:02:48 jason Exp $	*/
d290 1
a290 1
	int sc_freq;				/* Freq in HZ */
@


1.3
log
@sync with netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr53c9xvar.h,v 1.2 1997/08/08 08:13:06 downsj Exp $	*/
/*	$NetBSD: ncr53c9xvar.h,v 1.11 1997/10/05 18:35:09 thorpej Exp $	*/
d279 2
a280 2
	u_char	sc_omess[NCR_MAX_MSG_LEN];
	caddr_t	sc_omp;	/* Message pointer (for multibyte messages) */
d282 2
a283 2
	u_char	sc_imess[NCR_MAX_MSG_LEN + 1];
	caddr_t	sc_imp;	/* Message pointer (for multibyte messages) */
d293 1
d317 4
@


1.2
log
@Mostly sync to NetBSD-current 970804.

Apologies if this breaks anyone else using the MI ESP driver...
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ncr53c9xvar.h,v 1.8 1997/07/30 11:48:32 pk Exp $	*/
d4 2
a5 2
/*
 * Copyright (c) 1997 Jason R. Thorpe.
d8 4
d22 5
a26 4
 *	This product includes software developed for the NetBSD Project
 *	by Jason R. Thorpe.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d28 11
a38 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d89 2
a90 1
#define	NCR_VARIANT_MAX			7
@


1.1
log
@M.I. NCR53c9x/ESP driver, derived from sparc/alpha esp.c.  From Jason Thorpe
and NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: ncr53c9xvar.h,v 1.1 1997/02/27 01:12:09 thorpej Exp $	*/
d64 2
a65 1
#define NCR53C9X_DEBUG		0
d68 1
d81 3
a83 1
#define	NCR_VARIANT_MAX			5
d97 6
a102 5
#define	ECB_ALLOC	0x01
#define	ECB_NEXUS	0x02
#define	ECB_SENSE	0x04
#define	ECB_ABORT	0x40
#define	ECB_RESET	0x80
d105 5
a109 2
	struct scsi_generic cmd;  /* SCSI command block */
	int	 clen;
d113 1
d115 1
a115 1
#if NCR53C9X_DEBUG > 0
d119 1
a119 1
#if NCR53C9X_DEBUG > 0
d151 1
d232 2
d279 3
d308 1
d385 2
@
