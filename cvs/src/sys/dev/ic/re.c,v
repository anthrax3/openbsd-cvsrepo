head	1.202;
access;
symbols
	OPENBSD_6_2:1.202.0.2
	OPENBSD_6_2_BASE:1.202
	OPENBSD_6_1:1.201.0.4
	OPENBSD_6_1_BASE:1.201
	OPENBSD_6_0:1.192.0.4
	OPENBSD_6_0_BASE:1.192
	OPENBSD_5_9:1.189.0.2
	OPENBSD_5_9_BASE:1.189
	OPENBSD_5_8:1.179.0.4
	OPENBSD_5_8_BASE:1.179
	OPENBSD_5_7:1.175.0.2
	OPENBSD_5_7_BASE:1.175
	OPENBSD_5_6:1.155.0.4
	OPENBSD_5_6_BASE:1.155
	OPENBSD_5_5:1.147.0.4
	OPENBSD_5_5_BASE:1.147
	OPENBSD_5_4:1.142.0.2
	OPENBSD_5_4_BASE:1.142
	OPENBSD_5_3:1.139.0.4
	OPENBSD_5_3_BASE:1.139
	OPENBSD_5_2:1.139.0.2
	OPENBSD_5_2_BASE:1.139
	OPENBSD_5_1_BASE:1.136
	OPENBSD_5_1:1.136.0.6
	OPENBSD_5_0:1.136.0.2
	OPENBSD_5_0_BASE:1.136
	OPENBSD_4_9:1.132.0.2
	OPENBSD_4_9_BASE:1.132
	OPENBSD_4_8:1.127.0.2
	OPENBSD_4_8_BASE:1.127
	OPENBSD_4_7:1.117.0.2
	OPENBSD_4_7_BASE:1.117
	OPENBSD_4_6:1.108.0.4
	OPENBSD_4_6_BASE:1.108
	OPENBSD_4_5:1.104.0.2
	OPENBSD_4_5_BASE:1.104
	OPENBSD_4_4:1.85.0.2
	OPENBSD_4_4_BASE:1.85
	OPENBSD_4_3:1.77.0.2
	OPENBSD_4_3_BASE:1.77
	OPENBSD_4_2:1.74.0.2
	OPENBSD_4_2_BASE:1.74
	OPENBSD_4_1:1.69.0.2
	OPENBSD_4_1_BASE:1.69
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.202
date	2017.06.19.09.36.27;	author mpi;	state Exp;
branches;
next	1.201;
commitid	INPmTWJVTQSeW0jj;

1.201
date	2017.01.24.03.57.34;	author dlg;	state Exp;
branches;
next	1.200;
commitid	PERtGPXCvlLRRBr8;

1.200
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.199;
commitid	VyLWTsbepAOk7VQM;

1.199
date	2017.01.04.01.47.32;	author dlg;	state Exp;
branches;
next	1.198;
commitid	212b2eQqJj82U7MW;

1.198
date	2016.11.16.06.06.04;	author dlg;	state Exp;
branches;
next	1.197;
commitid	jDLyC4gmRtCLIsoR;

1.197
date	2016.11.16.02.50.17;	author dlg;	state Exp;
branches;
next	1.196;
commitid	knfjAiYfxthHiW6j;

1.196
date	2016.11.16.01.55.10;	author dlg;	state Exp;
branches;
next	1.195;
commitid	sSsoZ4tJFXIUqbhg;

1.195
date	2016.11.16.01.27.45;	author dlg;	state Exp;
branches;
next	1.194;
commitid	xQXfkZeR3MsQw2Wf;

1.194
date	2016.11.16.01.15.37;	author dlg;	state Exp;
branches;
next	1.193;
commitid	CSqqHhDNt5fB7T3p;

1.193
date	2016.08.10.14.27.17;	author deraadt;	state Exp;
branches;
next	1.192;
commitid	nJ2GKPOeS3xtih2N;

1.192
date	2016.04.20.12.15.24;	author sthen;	state Exp;
branches;
next	1.191;
commitid	z2wRR15tm4E4bguy;

1.191
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.190;
commitid	QHiEhS9DHyE6oiIr;

1.190
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.189;
commitid	15xZY6veDWwRM6Iq;

1.189
date	2016.01.04.05.41.22;	author dlg;	state Exp;
branches;
next	1.188;
commitid	FcdlKl3qa5H9zsuF;

1.188
date	2015.12.28.05.49.15;	author jmatthew;	state Exp;
branches;
next	1.187;
commitid	3iekWyKLzVgfNIj7;

1.187
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.186;
commitid	B0kwmVGiD5DVx4kv;

1.186
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.185;
commitid	5gdEnqVoJuTuwdTu;

1.185
date	2015.11.24.15.43.15;	author mpi;	state Exp;
branches;
next	1.184;
commitid	4NlO6WfWlwA8ekGS;

1.184
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.183;
commitid	eYnPulzvLjDImPCa;

1.183
date	2015.11.14.17.54.57;	author mpi;	state Exp;
branches;
next	1.182;
commitid	Waft2RDjXAxr4qZ9;

1.182
date	2015.11.02.00.08.50;	author dlg;	state Exp;
branches;
next	1.181;
commitid	3h4FftdbNE7umRAE;

1.181
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.180;
commitid	p0v5tuE1Ch6fY0Nj;

1.180
date	2015.09.04.07.05.44;	author jsg;	state Exp;
branches;
next	1.179;
commitid	v8PHprKwtlUtXJqB;

1.179
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.178;
commitid	MVWrtktB46JRxFWT;

1.178
date	2015.04.13.20.45.49;	author sthen;	state Exp;
branches;
next	1.177;
commitid	OySFsqY24Pho9kSj;

1.177
date	2015.03.20.12.04.09;	author dlg;	state Exp;
branches;
next	1.176;
commitid	VrV6I9fEf1yjTS3Y;

1.176
date	2015.03.20.11.55.10;	author dlg;	state Exp;
branches;
next	1.175;
commitid	Um3KW6XQTJoygtvn;

1.175
date	2015.02.09.03.09.57;	author dlg;	state Exp;
branches;
next	1.174;
commitid	fE9MPAUoNdw8sZYO;

1.174
date	2015.02.08.06.55.28;	author mpi;	state Exp;
branches;
next	1.173;
commitid	KeaOliLMLrRwa9qN;

1.173
date	2015.01.21.10.00.42;	author brad;	state Exp;
branches;
next	1.172;
commitid	eT4HAzQlyXNwVq8m;

1.172
date	2015.01.21.09.52.55;	author brad;	state Exp;
branches;
next	1.171;
commitid	tQlGG2siYDiTIGNs;

1.171
date	2015.01.20.04.46.11;	author brad;	state Exp;
branches;
next	1.170;
commitid	n8BzRxDExUPNJ7g8;

1.170
date	2015.01.20.04.33.06;	author brad;	state Exp;
branches;
next	1.169;
commitid	PR9rT5rnaoFwMdGp;

1.169
date	2015.01.20.04.23.33;	author brad;	state Exp;
branches;
next	1.168;
commitid	XLp7lheo6IeaLVyl;

1.168
date	2015.01.15.23.06.08;	author brad;	state Exp;
branches;
next	1.167;
commitid	1cCWY81g8OwfIY0x;

1.167
date	2015.01.08.00.49.18;	author brad;	state Exp;
branches;
next	1.166;
commitid	VH7cwj1b7ZDYWwH1;

1.166
date	2015.01.04.07.14.41;	author brad;	state Exp;
branches;
next	1.165;
commitid	PH1BFn4KnilH6iBu;

1.165
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.164;
commitid	yM2VFFhpDTeFQlve;

1.164
date	2014.12.19.04.53.58;	author brad;	state Exp;
branches;
next	1.163;
commitid	4EaqjcslMrZh2RMV;

1.163
date	2014.11.24.10.33.37;	author brad;	state Exp;
branches;
next	1.162;
commitid	n3mk3gi6o2NDYPpC;

1.162
date	2014.11.24.02.03.37;	author brad;	state Exp;
branches;
next	1.161;
commitid	Wmnzf8bGQILqXRTG;

1.161
date	2014.11.23.10.03.49;	author brad;	state Exp;
branches;
next	1.160;
commitid	BWNFOSrwnYWdsEkP;

1.160
date	2014.11.19.02.37.41;	author brad;	state Exp;
branches;
next	1.159;
commitid	WKJHAIeAQjfthtO9;

1.159
date	2014.10.24.23.30.05;	author brad;	state Exp;
branches;
next	1.158;
commitid	iT3Zt8uqLKeewmiI;

1.158
date	2014.10.08.22.52.08;	author brad;	state Exp;
branches;
next	1.157;
commitid	e4QyrgXfK3xLPIMm;

1.157
date	2014.09.21.16.52.11;	author jsg;	state Exp;
branches;
next	1.156;
commitid	cjgafHg94v205IpS;

1.156
date	2014.09.06.04.46.58;	author brad;	state Exp;
branches;
next	1.155;
commitid	NjpaYKN1EE5jORe8;

1.155
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.154;
commitid	TGHgrLxu6sxZoiFt;

1.154
date	2014.07.08.05.35.18;	author dlg;	state Exp;
branches;
next	1.153;
commitid	0QJleeeWqZmC5anF;

1.153
date	2014.04.23.03.37.29;	author jsg;	state Exp;
branches;
next	1.152;

1.152
date	2014.04.23.03.20.55;	author jsg;	state Exp;
branches;
next	1.151;

1.151
date	2014.04.23.02.58.06;	author jsg;	state Exp;
branches;
next	1.150;

1.150
date	2014.04.23.02.39.28;	author jsg;	state Exp;
branches;
next	1.149;

1.149
date	2014.03.13.13.11.30;	author brad;	state Exp;
branches;
next	1.148;

1.148
date	2014.03.08.22.37.32;	author brad;	state Exp;
branches;
next	1.147;

1.147
date	2013.12.31.21.09.34;	author brad;	state Exp;
branches;
next	1.146;

1.146
date	2013.10.25.22.48.10;	author brad;	state Exp;
branches;
next	1.145;

1.145
date	2013.10.11.14.00.18;	author jsg;	state Exp;
branches;
next	1.144;

1.144
date	2013.10.05.22.59.57;	author kettenis;	state Exp;
branches;
next	1.143;

1.143
date	2013.08.07.01.06.30;	author bluhm;	state Exp;
branches;
next	1.142;

1.142
date	2013.03.17.20.47.23;	author brad;	state Exp;
branches;
next	1.141;

1.141
date	2013.03.11.23.42.19;	author brad;	state Exp;
branches;
next	1.140;

1.140
date	2013.03.09.17.17.12;	author bluhm;	state Exp;
branches;
next	1.139;

1.139
date	2012.05.09.13.30.12;	author jsg;	state Exp;
branches;
next	1.138;

1.138
date	2012.05.09.13.14.35;	author jsg;	state Exp;
branches;
next	1.137;

1.137
date	2012.04.08.08.34.55;	author jsg;	state Exp;
branches;
next	1.136;

1.136
date	2011.06.15.13.19.19;	author jsg;	state Exp;
branches;
next	1.135;

1.135
date	2011.04.14.21.06.37;	author jsg;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.133;

1.133
date	2011.03.13.15.35.20;	author stsp;	state Exp;
branches;
next	1.132;

1.132
date	2010.11.28.22.13.48;	author kettenis;	state Exp;
branches;
next	1.131;

1.131
date	2010.11.28.22.08.59;	author kettenis;	state Exp;
branches;
next	1.130;

1.130
date	2010.11.12.22.17.30;	author sthen;	state Exp;
branches;
next	1.129;

1.129
date	2010.10.05.08.57.34;	author mikeb;	state Exp;
branches;
next	1.128;

1.128
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.127;

1.127
date	2010.08.08.21.00.31;	author krw;	state Exp;
branches;
next	1.126;

1.126
date	2010.08.07.23.56.42;	author naddy;	state Exp;
branches;
next	1.125;

1.125
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.124;

1.124
date	2010.07.27.20.53.39;	author kettenis;	state Exp;
branches;
next	1.123;

1.123
date	2010.07.14.19.24.27;	author naddy;	state Exp;
branches;
next	1.122;

1.122
date	2010.07.10.21.00.34;	author naddy;	state Exp;
branches;
next	1.121;

1.121
date	2010.06.28.17.00.18;	author naddy;	state Exp;
branches;
next	1.120;

1.120
date	2010.06.28.16.04.09;	author sthen;	state Exp;
branches;
next	1.119;

1.119
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.118;

1.118
date	2010.04.03.22.24.05;	author sthen;	state Exp;
branches;
next	1.117;

1.117
date	2010.02.17.22.16.34;	author kettenis;	state Exp;
branches;
next	1.116;

1.116
date	2009.11.24.17.40.43;	author kettenis;	state Exp;
branches;
next	1.115;

1.115
date	2009.11.13.23.50.30;	author sthen;	state Exp;
branches;
next	1.114;

1.114
date	2009.08.09.11.40.58;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2009.07.23.20.15.32;	author kettenis;	state Exp;
branches;
next	1.112;

1.112
date	2009.07.18.13.21.32;	author sthen;	state Exp;
branches;
next	1.111;

1.111
date	2009.07.15.19.50.04;	author naddy;	state Exp;
branches;
next	1.110;

1.110
date	2009.07.11.16.51.58;	author sthen;	state Exp;
branches;
next	1.109;

1.109
date	2009.07.10.21.29.57;	author sthen;	state Exp;
branches;
next	1.108;

1.108
date	2009.07.03.16.55.27;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2009.06.04.04.48.24;	author naddy;	state Exp;
branches;
next	1.106;

1.106
date	2009.06.03.00.11.19;	author sthen;	state Exp;
branches;
next	1.105;

1.105
date	2009.05.23.09.39.23;	author jsg;	state Exp;
branches;
next	1.104;

1.104
date	2009.02.12.11.55.29;	author martynas;	state Exp;
branches;
next	1.103;

1.103
date	2008.11.30.06.01.45;	author brad;	state Exp;
branches;
next	1.102;

1.102
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.101;

1.101
date	2008.11.17.01.25.31;	author brad;	state Exp;
branches;
next	1.100;

1.100
date	2008.11.14.20.49.35;	author naddy;	state Exp;
branches;
next	1.99;

1.99
date	2008.11.09.15.08.25;	author naddy;	state Exp;
branches;
next	1.98;

1.98
date	2008.11.08.06.52.49;	author brad;	state Exp;
branches;
next	1.97;

1.97
date	2008.11.07.18.12.22;	author brad;	state Exp;
branches;
next	1.96;

1.96
date	2008.10.16.19.18.03;	author naddy;	state Exp;
branches;
next	1.95;

1.95
date	2008.10.16.19.16.21;	author naddy;	state Exp;
branches;
next	1.94;

1.94
date	2008.10.11.23.49.05;	author brad;	state Exp;
branches;
next	1.93;

1.93
date	2008.10.09.23.02.07;	author brad;	state Exp;
branches;
next	1.92;

1.92
date	2008.10.06.00.34.09;	author brad;	state Exp;
branches;
next	1.91;

1.91
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.90;

1.90
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.89;

1.89
date	2008.08.29.22.59.56;	author brad;	state Exp;
branches;
next	1.88;

1.88
date	2008.08.28.17.51.09;	author brad;	state Exp;
branches;
next	1.87;

1.87
date	2008.08.13.03.18.19;	author brad;	state Exp;
branches;
next	1.86;

1.86
date	2008.08.11.22.42.19;	author brad;	state Exp;
branches;
next	1.85;

1.85
date	2008.08.05.01.58.47;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2008.07.15.13.21.17;	author jsg;	state Exp;
branches;
next	1.83;

1.83
date	2008.07.13.05.24.05;	author jsg;	state Exp;
branches;
next	1.82;

1.82
date	2008.04.20.01.18.02;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2008.04.20.01.15.40;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2008.04.20.00.59.44;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2008.04.20.00.42.27;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2008.03.20.23.54.57;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2008.03.12.16.26.45;	author brad;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2008.02.17.05.29.25;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2008.01.16.09.52.34;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2007.07.16.19.15.01;	author millert;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2007.06.06.22.02.31;	author pvalchev;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.06.18.51.19;	author pvalchev;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.08.21.19.42;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.05.12.10.57;	author jsg;	state Exp;
branches;
next	1.69;

1.69
date	2007.03.02.17.49.51;	author krw;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2007.02.25.08.00.06;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2007.02.15.18.42.53;	author jason;	state Exp;
branches;
next	1.66;

1.66
date	2007.02.08.22.50.08;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.03.01.55.00;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2007.01.27.20.55.55;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2007.01.26.15.29.10;	author jason;	state Exp;
branches;
next	1.62;

1.62
date	2007.01.23.13.42.47;	author mglocker;	state Exp;
branches;
next	1.61;

1.61
date	2006.12.30.09.38.28;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2006.12.21.05.15.06;	author drahn;	state Exp;
branches;
next	1.59;

1.59
date	2006.12.20.23.26.52;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2006.12.12.10.24.37;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.01.01.13.01;	author todd;	state Exp;
branches;
next	1.56;

1.56
date	2006.11.28.23.00.13;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.28.20.04.02;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.24.04.27.17;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.18.15.54.29;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.01.23.25.18;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2006.10.31.22.45.15;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2006.10.31.07.04.25;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2006.10.22.21.19.22;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2006.10.16.20.37.25;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2006.09.29.17.35.45;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2006.09.18.21.33.32;	author dim;	state Exp;
branches;
next	1.45;

1.45
date	2006.09.17.18.18.57;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2006.09.15.23.39.24;	author drahn;	state Exp;
branches;
next	1.43;

1.43
date	2006.08.17.23.08.07;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2006.08.06.06.18.28;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.06.06.00.10;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.06.05.18.22;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.05.21.38.20;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.05.21.03.22;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.05.16.53.16;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.06.00.06.51;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2006.07.03.02.28.39;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.02.03.20.48;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.01.21.48.08;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.30.06.17.55;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.29.20.41.19;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.27.07.41.05;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.27.05.53.37;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.24.02.36.15;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.24.02.11.29;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.17.17.56.10;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.05.23.44.07;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.29.05.11.15;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.27.10.03.15;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.26.20.50.41;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.20.03.47.56;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.16.02.15.23;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.04.03.47.08;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.30.00.32.45;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.28.02.15.19;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.07.03.20.00;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.01.17.00.23;	author pvalchev;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2005.05.24.00.46.18;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.30.19.43.41;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.30.08.24.25;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.30.08.22.23;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.15.03.16.07;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.14.20.23.31;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.08.13.36.48;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.15.16.11.38;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.25.12.32.50;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.14.01.32.45;	author pvalchev;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.01.08.11;	author pvalchev;	state Exp;
branches;
next	;

1.14.2.1
date	2006.05.23.00.26.03;	author brad;	state Exp;
branches;
next	;

1.69.2.1
date	2008.03.21.20.33.12;	author brad;	state Exp;
branches;
next	;

1.74.2.1
date	2008.03.21.20.34.16;	author brad;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2008.05.23.03.58.24;	author brad;	state Exp;
branches;
next	;

1.77.2.1
date	2008.05.23.03.59.23;	author brad;	state Exp;
branches;
next	;


desc
@@


1.202
log
@Do not call txeof nor rxeof in the watchdog routine.

They cannot be serialized with the interrupt routine and are
useless because the driver is reinitialized right after.

Pointed by and ok mikeb@@
@
text
@/*	$OpenBSD: re.c,v 1.201 2017/01/24 03:57:34 dlg Exp $	*/
/*	$FreeBSD: if_re.c,v 1.31 2004/09/04 07:54:05 ru Exp $	*/
/*
 * Copyright (c) 1997, 1998-2003
 *	Bill Paul <wpaul@@windriver.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Realtek 8139C+/8169/8169S/8110S PCI NIC driver
 *
 * Written by Bill Paul <wpaul@@windriver.com>
 * Senior Networking Software Engineer
 * Wind River Systems
 */

/*
 * This driver is designed to support Realtek's next generation of
 * 10/100 and 10/100/1000 PCI ethernet controllers. There are currently
 * seven devices in this family: the RTL8139C+, the RTL8169, the RTL8169S,
 * RTL8110S, the RTL8168, the RTL8111 and the RTL8101E.
 *
 * The 8139C+ is a 10/100 ethernet chip. It is backwards compatible
 * with the older 8139 family, however it also supports a special
 * C+ mode of operation that provides several new performance enhancing
 * features. These include:
 *
 *	o Descriptor based DMA mechanism. Each descriptor represents
 *	  a single packet fragment. Data buffers may be aligned on
 *	  any byte boundary.
 *
 *	o 64-bit DMA
 *
 *	o TCP/IP checksum offload for both RX and TX
 *
 *	o High and normal priority transmit DMA rings
 *
 *	o VLAN tag insertion and extraction
 *
 *	o TCP large send (segmentation offload)
 *
 * Like the 8139, the 8139C+ also has a built-in 10/100 PHY. The C+
 * programming API is fairly straightforward. The RX filtering, EEPROM
 * access and PHY access is the same as it is on the older 8139 series
 * chips.
 *
 * The 8169 is a 64-bit 10/100/1000 gigabit ethernet MAC. It has almost the
 * same programming API and feature set as the 8139C+ with the following
 * differences and additions:
 *
 *	o 1000Mbps mode
 *
 *	o Jumbo frames
 *
 * 	o GMII and TBI ports/registers for interfacing with copper
 *	  or fiber PHYs
 *
 *      o RX and TX DMA rings can have up to 1024 descriptors
 *        (the 8139C+ allows a maximum of 64)
 *
 *	o Slight differences in register layout from the 8139C+
 *
 * The TX start and timer interrupt registers are at different locations
 * on the 8169 than they are on the 8139C+. Also, the status word in the
 * RX descriptor has a slightly different bit layout. The 8169 does not
 * have a built-in PHY. Most reference boards use a Marvell 88E1000 'Alaska'
 * copper gigE PHY.
 *
 * The 8169S/8110S 10/100/1000 devices have built-in copper gigE PHYs
 * (the 'S' stands for 'single-chip'). These devices have the same
 * programming API as the older 8169, but also have some vendor-specific
 * registers for the on-board PHY. The 8110S is a LAN-on-motherboard
 * part designed to be pin-compatible with the Realtek 8100 10/100 chip.
 * 
 * This driver takes advantage of the RX and TX checksum offload and
 * VLAN tag insertion/extraction features. It also implements TX
 * interrupt moderation using the timer interrupt registers, which
 * significantly reduces TX interrupt load. There is also support
 * for jumbo frames, however the 8169/8169S/8110S can not transmit
 * jumbo frames larger than 7440, so the max MTU possible with this
 * driver is 7422 bytes.
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/endian.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>
#include <sys/atomic.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/pci/pcidevs.h>

#include <dev/ic/rtl81x9reg.h>
#include <dev/ic/revar.h>

#ifdef RE_DEBUG
int redebug = 0;
#define DPRINTF(x)	do { if (redebug) printf x; } while (0)
#else
#define DPRINTF(x)
#endif

static inline void re_set_bufaddr(struct rl_desc *, bus_addr_t);

int	re_encap(struct rl_softc *, unsigned int, struct mbuf *);

int	re_newbuf(struct rl_softc *);
int	re_rx_list_init(struct rl_softc *);
void	re_rx_list_fill(struct rl_softc *);
int	re_tx_list_init(struct rl_softc *);
int	re_rxeof(struct rl_softc *);
int	re_txeof(struct rl_softc *);
void	re_tick(void *);
void	re_start(struct ifqueue *);
void	re_txstart(void *);
int	re_ioctl(struct ifnet *, u_long, caddr_t);
void	re_watchdog(struct ifnet *);
int	re_ifmedia_upd(struct ifnet *);
void	re_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void	re_set_jumbo(struct rl_softc *);

void	re_eeprom_putbyte(struct rl_softc *, int);
void	re_eeprom_getword(struct rl_softc *, int, u_int16_t *);
void	re_read_eeprom(struct rl_softc *, caddr_t, int, int);

int	re_gmii_readreg(struct device *, int, int);
void	re_gmii_writereg(struct device *, int, int, int);

int	re_miibus_readreg(struct device *, int, int);
void	re_miibus_writereg(struct device *, int, int, int);
void	re_miibus_statchg(struct device *);

void	re_iff(struct rl_softc *);

void	re_setup_hw_im(struct rl_softc *);
void	re_setup_sim_im(struct rl_softc *);
void	re_disable_hw_im(struct rl_softc *);
void	re_disable_sim_im(struct rl_softc *);
void	re_config_imtype(struct rl_softc *, int);
void	re_setup_intr(struct rl_softc *, int, int);
#ifndef SMALL_KERNEL
int	re_wol(struct ifnet*, int);
#endif

void	in_delayed_cksum(struct mbuf *);

struct cfdriver re_cd = {
	0, "re", DV_IFNET
};

extern char *hw_vendor, *hw_prod;

#define EE_SET(x)					\
	CSR_WRITE_1(sc, RL_EECMD,			\
		CSR_READ_1(sc, RL_EECMD) | x)

#define EE_CLR(x)					\
	CSR_WRITE_1(sc, RL_EECMD,			\
		CSR_READ_1(sc, RL_EECMD) & ~x)

#define RL_FRAMELEN(mtu)				\
	(mtu + ETHER_HDR_LEN + ETHER_CRC_LEN +		\
		ETHER_VLAN_ENCAP_LEN)

static const struct re_revision {
	u_int32_t		re_chipid;
	const char		*re_name;
} re_revisions[] = {
	{ RL_HWREV_8100,	"RTL8100" },
	{ RL_HWREV_8100E,	"RTL8100E" },
	{ RL_HWREV_8100E_SPIN2, "RTL8100E 2" },
	{ RL_HWREV_8101,	"RTL8101" },
	{ RL_HWREV_8101E,	"RTL8101E" },
	{ RL_HWREV_8102E,	"RTL8102E" },
	{ RL_HWREV_8106E,	"RTL8106E" },
	{ RL_HWREV_8401E,	"RTL8401E" },
	{ RL_HWREV_8402,	"RTL8402" },
	{ RL_HWREV_8411,	"RTL8411" },
	{ RL_HWREV_8411B,	"RTL8411B" },
	{ RL_HWREV_8102EL,	"RTL8102EL" },
	{ RL_HWREV_8102EL_SPIN1, "RTL8102EL 1" },
	{ RL_HWREV_8103E,       "RTL8103E" },
	{ RL_HWREV_8110S,	"RTL8110S" },
	{ RL_HWREV_8139CPLUS,	"RTL8139C+" },
	{ RL_HWREV_8168B_SPIN1,	"RTL8168 1" },
	{ RL_HWREV_8168B_SPIN2,	"RTL8168 2" },
	{ RL_HWREV_8168B_SPIN3,	"RTL8168 3" },
	{ RL_HWREV_8168C,	"RTL8168C/8111C" },
	{ RL_HWREV_8168C_SPIN2,	"RTL8168C/8111C" },
	{ RL_HWREV_8168CP,	"RTL8168CP/8111CP" },
	{ RL_HWREV_8168F,	"RTL8168F/8111F" },
	{ RL_HWREV_8168G,	"RTL8168G/8111G" },
	{ RL_HWREV_8168GU,	"RTL8168GU/8111GU" },
	{ RL_HWREV_8168H,	"RTL8168H/8111H" },
	{ RL_HWREV_8105E,	"RTL8105E" },
	{ RL_HWREV_8105E_SPIN1,	"RTL8105E" },
	{ RL_HWREV_8168D,	"RTL8168D/8111D" },
	{ RL_HWREV_8168DP,      "RTL8168DP/8111DP" },
	{ RL_HWREV_8168E,       "RTL8168E/8111E" },
	{ RL_HWREV_8168E_VL,	"RTL8168E/8111E-VL" },
	{ RL_HWREV_8168EP,	"RTL8168EP/8111EP" },
	{ RL_HWREV_8169,	"RTL8169" },
	{ RL_HWREV_8169_8110SB,	"RTL8169/8110SB" },
	{ RL_HWREV_8169_8110SBL, "RTL8169SBL" },
	{ RL_HWREV_8169_8110SCd, "RTL8169/8110SCd" },
	{ RL_HWREV_8169_8110SCe, "RTL8169/8110SCe" },
	{ RL_HWREV_8169S,	"RTL8169S" },

	{ 0, NULL }
};


static inline void
re_set_bufaddr(struct rl_desc *d, bus_addr_t addr)
{
	d->rl_bufaddr_lo = htole32((uint32_t)addr);
	if (sizeof(bus_addr_t) == sizeof(uint64_t))
		d->rl_bufaddr_hi = htole32((uint64_t)addr >> 32);
	else
		d->rl_bufaddr_hi = 0;
}

/*
 * Send a read command and address to the EEPROM, check for ACK.
 */
void
re_eeprom_putbyte(struct rl_softc *sc, int addr)
{
	int	d, i;

	d = addr | (RL_9346_READ << sc->rl_eewidth);

	/*
	 * Feed in each bit and strobe the clock.
	 */

	for (i = 1 << (sc->rl_eewidth + 3); i; i >>= 1) {
		if (d & i)
			EE_SET(RL_EE_DATAIN);
		else
			EE_CLR(RL_EE_DATAIN);
		DELAY(100);
		EE_SET(RL_EE_CLK);
		DELAY(150);
		EE_CLR(RL_EE_CLK);
		DELAY(100);
	}
}

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 */
void
re_eeprom_getword(struct rl_softc *sc, int addr, u_int16_t *dest)
{
	int		i;
	u_int16_t	word = 0;

	/*
	 * Send address of word we want to read.
	 */
	re_eeprom_putbyte(sc, addr);

	/*
	 * Start reading bits from EEPROM.
	 */
	for (i = 0x8000; i; i >>= 1) {
		EE_SET(RL_EE_CLK);
		DELAY(100);
		if (CSR_READ_1(sc, RL_EECMD) & RL_EE_DATAOUT)
			word |= i;
		EE_CLR(RL_EE_CLK);
		DELAY(100);
	}

	*dest = word;
}

/*
 * Read a sequence of words from the EEPROM.
 */
void
re_read_eeprom(struct rl_softc *sc, caddr_t dest, int off, int cnt)
{
	int		i;
	u_int16_t	word = 0, *ptr;

	CSR_SETBIT_1(sc, RL_EECMD, RL_EEMODE_PROGRAM);

	DELAY(100);

	for (i = 0; i < cnt; i++) {
		CSR_SETBIT_1(sc, RL_EECMD, RL_EE_SEL);
		re_eeprom_getword(sc, off + i, &word);
		CSR_CLRBIT_1(sc, RL_EECMD, RL_EE_SEL);
		ptr = (u_int16_t *)(dest + (i * 2));
		*ptr = word;
	}

	CSR_CLRBIT_1(sc, RL_EECMD, RL_EEMODE_PROGRAM);
}

int
re_gmii_readreg(struct device *self, int phy, int reg)
{
	struct rl_softc	*sc = (struct rl_softc *)self;
	u_int32_t	rval;
	int		i;

	if (phy != 7)
		return (0);

	/* Let the rgephy driver read the GMEDIASTAT register */

	if (reg == RL_GMEDIASTAT) {
		rval = CSR_READ_1(sc, RL_GMEDIASTAT);
		return (rval);
	}

	CSR_WRITE_4(sc, RL_PHYAR, reg << 16);

	for (i = 0; i < RL_PHY_TIMEOUT; i++) {
		rval = CSR_READ_4(sc, RL_PHYAR);
		if (rval & RL_PHYAR_BUSY)
			break;
		DELAY(25);
	}

	if (i == RL_PHY_TIMEOUT) {
		printf ("%s: PHY read failed\n", sc->sc_dev.dv_xname);
		return (0);
	}

	DELAY(20);

	return (rval & RL_PHYAR_PHYDATA);
}

void
re_gmii_writereg(struct device *dev, int phy, int reg, int data)
{
	struct rl_softc	*sc = (struct rl_softc *)dev;
	u_int32_t	rval;
	int		i;

	CSR_WRITE_4(sc, RL_PHYAR, (reg << 16) |
	    (data & RL_PHYAR_PHYDATA) | RL_PHYAR_BUSY);

	for (i = 0; i < RL_PHY_TIMEOUT; i++) {
		rval = CSR_READ_4(sc, RL_PHYAR);
		if (!(rval & RL_PHYAR_BUSY))
			break;
		DELAY(25);
	}

	if (i == RL_PHY_TIMEOUT)
		printf ("%s: PHY write failed\n", sc->sc_dev.dv_xname);

	DELAY(20);
}

int
re_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct rl_softc	*sc = (struct rl_softc *)dev;
	u_int16_t	rval = 0;
	u_int16_t	re8139_reg = 0;
	int		s;

	s = splnet();

	if (sc->sc_hwrev != RL_HWREV_8139CPLUS) {
		rval = re_gmii_readreg(dev, phy, reg);
		splx(s);
		return (rval);
	}

	/* Pretend the internal PHY is only at address 0 */
	if (phy) {
		splx(s);
		return (0);
	}
	switch(reg) {
	case MII_BMCR:
		re8139_reg = RL_BMCR;
		break;
	case MII_BMSR:
		re8139_reg = RL_BMSR;
		break;
	case MII_ANAR:
		re8139_reg = RL_ANAR;
		break;
	case MII_ANER:
		re8139_reg = RL_ANER;
		break;
	case MII_ANLPAR:
		re8139_reg = RL_LPAR;
		break;
	case MII_PHYIDR1:
	case MII_PHYIDR2:
		splx(s);
		return (0);
	/*
	 * Allow the rlphy driver to read the media status
	 * register. If we have a link partner which does not
	 * support NWAY, this is the register which will tell
	 * us the results of parallel detection.
	 */
	case RL_MEDIASTAT:
		rval = CSR_READ_1(sc, RL_MEDIASTAT);
		splx(s);
		return (rval);
	default:
		printf("%s: bad phy register %x\n", sc->sc_dev.dv_xname, reg);
		splx(s);
		return (0);
	}
	rval = CSR_READ_2(sc, re8139_reg);
	if (re8139_reg == RL_BMCR) {
		/* 8139C+ has different bit layout. */
		rval &= ~(BMCR_LOOP | BMCR_ISO);
	}
	splx(s);
	return (rval);
}

void
re_miibus_writereg(struct device *dev, int phy, int reg, int data)
{
	struct rl_softc	*sc = (struct rl_softc *)dev;
	u_int16_t	re8139_reg = 0;
	int		s;

	s = splnet();

	if (sc->sc_hwrev != RL_HWREV_8139CPLUS) {
		re_gmii_writereg(dev, phy, reg, data);
		splx(s);
		return;
	}

	/* Pretend the internal PHY is only at address 0 */
	if (phy) {
		splx(s);
		return;
	}
	switch(reg) {
	case MII_BMCR:
		re8139_reg = RL_BMCR;
		/* 8139C+ has different bit layout. */
		data &= ~(BMCR_LOOP | BMCR_ISO);
		break;
	case MII_BMSR:
		re8139_reg = RL_BMSR;
		break;
	case MII_ANAR:
		re8139_reg = RL_ANAR;
		break;
	case MII_ANER:
		re8139_reg = RL_ANER;
		break;
	case MII_ANLPAR:
		re8139_reg = RL_LPAR;
		break;
	case MII_PHYIDR1:
	case MII_PHYIDR2:
		splx(s);
		return;
		break;
	default:
		printf("%s: bad phy register %x\n", sc->sc_dev.dv_xname, reg);
		splx(s);
		return;
	}
	CSR_WRITE_2(sc, re8139_reg, data);
	splx(s);
}

void
re_miibus_statchg(struct device *dev)
{
	struct rl_softc		*sc = (struct rl_softc *)dev;
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
	struct mii_data		*mii = &sc->sc_mii;

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	sc->rl_flags &= ~RL_FLAG_LINK;
	if ((mii->mii_media_status & (IFM_ACTIVE | IFM_AVALID)) ==
	    (IFM_ACTIVE | IFM_AVALID)) {
		switch (IFM_SUBTYPE(mii->mii_media_active)) {
		case IFM_10_T:
		case IFM_100_TX:
			sc->rl_flags |= RL_FLAG_LINK;
			break;
		case IFM_1000_T:
			if ((sc->rl_flags & RL_FLAG_FASTETHER) != 0)
				break;
			sc->rl_flags |= RL_FLAG_LINK;
			break;
		default:
			break;
		}
	}

	/*
	 * Realtek controllers do not provide an interface to
	 * Tx/Rx MACs for resolved speed, duplex and flow-control
	 * parameters.
	 */
}

void
re_iff(struct rl_softc *sc)
{
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
	int			h = 0;
	u_int32_t		hashes[2];
	u_int32_t		rxfilt;
	struct arpcom		*ac = &sc->sc_arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;

	rxfilt = CSR_READ_4(sc, RL_RXCFG);
	rxfilt &= ~(RL_RXCFG_RX_ALLPHYS | RL_RXCFG_RX_BROAD |
	    RL_RXCFG_RX_INDIV | RL_RXCFG_RX_MULTI);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept frames destined to our station address.
	 * Always accept broadcast frames.
	 */
	rxfilt |= RL_RXCFG_RX_INDIV | RL_RXCFG_RX_BROAD;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxfilt |= RL_RXCFG_RX_MULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxfilt |= RL_RXCFG_RX_ALLPHYS;
		hashes[0] = hashes[1] = 0xFFFFFFFF;
	} else {
		rxfilt |= RL_RXCFG_RX_MULTI;
		/* Program new filter. */
		bzero(hashes, sizeof(hashes));

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) >> 26;

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	/*
	 * For some unfathomable reason, Realtek decided to reverse
	 * the order of the multicast hash registers in the PCI Express
	 * parts. This means we have to write the hash pattern in reverse
	 * order for those devices.
	 */
	if (sc->rl_flags & RL_FLAG_PCIE) {
		CSR_WRITE_4(sc, RL_MAR0, swap32(hashes[1]));
		CSR_WRITE_4(sc, RL_MAR4, swap32(hashes[0]));
	} else {
		CSR_WRITE_4(sc, RL_MAR0, hashes[0]);
		CSR_WRITE_4(sc, RL_MAR4, hashes[1]);
	}

	CSR_WRITE_4(sc, RL_RXCFG, rxfilt);
}

void
re_reset(struct rl_softc *sc)
{
	int	i;

	CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);

	for (i = 0; i < RL_TIMEOUT; i++) {
		DELAY(10);
		if (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))
			break;
	}
	if (i == RL_TIMEOUT)
		printf("%s: reset never completed!\n", sc->sc_dev.dv_xname);

	if (sc->rl_flags & RL_FLAG_MACRESET)
		CSR_WRITE_1(sc, RL_LDPS, 1);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
int
re_attach(struct rl_softc *sc, const char *intrstr)
{
	u_char		eaddr[ETHER_ADDR_LEN];
	u_int16_t	as[ETHER_ADDR_LEN / 2];
	struct ifnet	*ifp;
	u_int16_t	re_did = 0;
	int		error = 0, i;
	const struct re_revision *rr;
	const char	*re_name = NULL;

	sc->sc_hwrev = CSR_READ_4(sc, RL_TXCFG) & RL_TXCFG_HWREV;

	switch (sc->sc_hwrev) {
	case RL_HWREV_8139CPLUS:
		sc->rl_flags |= RL_FLAG_FASTETHER | RL_FLAG_AUTOPAD;
		sc->rl_max_mtu = RL_MTU;
		break;
	case RL_HWREV_8100E:
	case RL_HWREV_8100E_SPIN2:
	case RL_HWREV_8101E:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_FASTETHER;
		sc->rl_max_mtu = RL_MTU;
		break;
	case RL_HWREV_8103E:
		sc->rl_flags |= RL_FLAG_MACSLEEP;
		/* FALLTHROUGH */
	case RL_HWREV_8102E:
	case RL_HWREV_8102EL:
	case RL_HWREV_8102EL_SPIN1:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |
		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_FASTETHER |
		    RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD;
		sc->rl_max_mtu = RL_MTU;
		break;
	case RL_HWREV_8401E:
	case RL_HWREV_8105E:
	case RL_HWREV_8105E_SPIN1:
	case RL_HWREV_8106E:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PHYWAKE_PM |
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |
		    RL_FLAG_FASTETHER | RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD;
		sc->rl_max_mtu = RL_MTU;
		break;
	case RL_HWREV_8402:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PHYWAKE_PM |
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |
		    RL_FLAG_FASTETHER | RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD |
		    RL_FLAG_CMDSTOP_WAIT_TXQ;
		sc->rl_max_mtu = RL_MTU;
		break;
	case RL_HWREV_8168B_SPIN1:
	case RL_HWREV_8168B_SPIN2:
		sc->rl_flags |= RL_FLAG_WOLRXENB;
		/* FALLTHROUGH */
	case RL_HWREV_8168B_SPIN3:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_MACSTAT;
		sc->rl_max_mtu = RL_MTU;
		break;
	case RL_HWREV_8168C_SPIN2:
		sc->rl_flags |= RL_FLAG_MACSLEEP;
		/* FALLTHROUGH */
	case RL_HWREV_8168C:
	case RL_HWREV_8168CP:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |
		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |
		    RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 | RL_FLAG_WOL_MANLINK;
		sc->rl_max_mtu = RL_JUMBO_MTU_6K;
		break;
	case RL_HWREV_8168D:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PHYWAKE_PM |
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |
		    RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 |
		    RL_FLAG_WOL_MANLINK;
		sc->rl_max_mtu = RL_JUMBO_MTU_9K;
		break;
	case RL_HWREV_8168DP:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |
		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_AUTOPAD |
		    RL_FLAG_JUMBOV2 | RL_FLAG_WAIT_TXPOLL | RL_FLAG_WOL_MANLINK;
		sc->rl_max_mtu = RL_JUMBO_MTU_9K;
		break;
	case RL_HWREV_8168E:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PHYWAKE_PM |
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |
		    RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 |
		    RL_FLAG_WOL_MANLINK;
		sc->rl_max_mtu = RL_JUMBO_MTU_9K;
		break;
	case RL_HWREV_8168E_VL:
		sc->rl_flags |= RL_FLAG_EARLYOFF | RL_FLAG_PHYWAKE | RL_FLAG_PAR |
		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |
		    RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 | RL_FLAG_CMDSTOP_WAIT_TXQ |
		    RL_FLAG_WOL_MANLINK;
		sc->rl_max_mtu = RL_JUMBO_MTU_6K;
		break;
	case RL_HWREV_8168F:
		sc->rl_flags |= RL_FLAG_EARLYOFF;
		/* FALLTHROUGH */
	case RL_HWREV_8411:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |
		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |
		    RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 | RL_FLAG_CMDSTOP_WAIT_TXQ |
		    RL_FLAG_WOL_MANLINK;
		sc->rl_max_mtu = RL_JUMBO_MTU_9K;
		break;
	case RL_HWREV_8168EP:
	case RL_HWREV_8168G:
	case RL_HWREV_8168GU:
	case RL_HWREV_8168H:
	case RL_HWREV_8411B:
		if (sc->sc_product == PCI_PRODUCT_REALTEK_RT8101E) {
			/* RTL8106EUS */
			sc->rl_flags |= RL_FLAG_FASTETHER;
			sc->rl_max_mtu = RL_MTU;
		} else {
			sc->rl_flags |= RL_FLAG_JUMBOV2 | RL_FLAG_WOL_MANLINK;
			sc->rl_max_mtu = RL_JUMBO_MTU_9K;
		}

		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |
		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |
		    RL_FLAG_AUTOPAD | RL_FLAG_CMDSTOP_WAIT_TXQ |
		    RL_FLAG_EARLYOFFV2 | RL_FLAG_RXDV_GATED;
		break;
	case RL_HWREV_8169_8110SB:
	case RL_HWREV_8169_8110SBL:
	case RL_HWREV_8169_8110SCd:
	case RL_HWREV_8169_8110SCe:
		sc->rl_flags |= RL_FLAG_PHYWAKE;
		/* FALLTHROUGH */
	case RL_HWREV_8169:
	case RL_HWREV_8169S:
	case RL_HWREV_8110S:
		sc->rl_flags |= RL_FLAG_MACRESET;
		sc->rl_max_mtu = RL_JUMBO_MTU_7K;
		break;
	default:
		break;
	}

	if (sc->sc_hwrev == RL_HWREV_8139CPLUS) {
		sc->rl_cfg0 = RL_8139_CFG0;
		sc->rl_cfg1 = RL_8139_CFG1;
		sc->rl_cfg2 = 0;
		sc->rl_cfg3 = RL_8139_CFG3;
		sc->rl_cfg4 = RL_8139_CFG4;
		sc->rl_cfg5 = RL_8139_CFG5;
	} else {
		sc->rl_cfg0 = RL_CFG0;
		sc->rl_cfg1 = RL_CFG1;
		sc->rl_cfg2 = RL_CFG2;
		sc->rl_cfg3 = RL_CFG3;
		sc->rl_cfg4 = RL_CFG4;
		sc->rl_cfg5 = RL_CFG5;
	}

	/* Reset the adapter. */
	re_reset(sc);

	sc->rl_tx_time = 5;		/* 125us */
	sc->rl_rx_time = 2;		/* 50us */
	if (sc->rl_flags & RL_FLAG_PCIE)
		sc->rl_sim_time = 75;	/* 75us */
	else
		sc->rl_sim_time = 125;	/* 125us */
	sc->rl_imtype = RL_IMTYPE_SIM;	/* simulated interrupt moderation */

	if (sc->sc_hwrev == RL_HWREV_8139CPLUS)
		sc->rl_bus_speed = 33; /* XXX */
	else if (sc->rl_flags & RL_FLAG_PCIE)
		sc->rl_bus_speed = 125;
	else {
		u_int8_t cfg2;

		cfg2 = CSR_READ_1(sc, sc->rl_cfg2);
		switch (cfg2 & RL_CFG2_PCI_MASK) {
		case RL_CFG2_PCI_33MHZ:
 			sc->rl_bus_speed = 33;
			break;
		case RL_CFG2_PCI_66MHZ:
			sc->rl_bus_speed = 66;
			break;
		default:
			printf("%s: unknown bus speed, assume 33MHz\n",
			    sc->sc_dev.dv_xname);
			sc->rl_bus_speed = 33;
			break;
		}

		if (cfg2 & RL_CFG2_PCI_64BIT)
			sc->rl_flags |= RL_FLAG_PCI64;
	}

	re_config_imtype(sc, sc->rl_imtype);

	if (sc->rl_flags & RL_FLAG_PAR) {
		/*
		 * XXX Should have a better way to extract station
		 * address from EEPROM.
		 */
		for (i = 0; i < ETHER_ADDR_LEN; i++)
			eaddr[i] = CSR_READ_1(sc, RL_IDR0 + i);
	} else {
		sc->rl_eewidth = RL_9356_ADDR_LEN;
		re_read_eeprom(sc, (caddr_t)&re_did, 0, 1);
		if (re_did != 0x8129)
			sc->rl_eewidth = RL_9346_ADDR_LEN;

		/*
		 * Get station address from the EEPROM.
		 */
		re_read_eeprom(sc, (caddr_t)as, RL_EE_EADDR, 3);
		for (i = 0; i < ETHER_ADDR_LEN / 2; i++)
			as[i] = letoh16(as[i]);
		bcopy(as, eaddr, ETHER_ADDR_LEN);
	}

	/*
	 * Set RX length mask, TX poll request register
	 * and descriptor count.
	 */
	if (sc->sc_hwrev == RL_HWREV_8139CPLUS) {
		sc->rl_rxlenmask = RL_RDESC_STAT_FRAGLEN;
		sc->rl_txstart = RL_TXSTART;
		sc->rl_ldata.rl_tx_desc_cnt = RL_8139_TX_DESC_CNT;
		sc->rl_ldata.rl_rx_desc_cnt = RL_8139_RX_DESC_CNT;
		sc->rl_ldata.rl_tx_ndescs = RL_8139_NTXSEGS;
	} else {
		sc->rl_rxlenmask = RL_RDESC_STAT_GFRAGLEN;
		sc->rl_txstart = RL_GTXSTART;
		sc->rl_ldata.rl_tx_desc_cnt = RL_8169_TX_DESC_CNT;
		sc->rl_ldata.rl_rx_desc_cnt = RL_8169_RX_DESC_CNT;
		sc->rl_ldata.rl_tx_ndescs = RL_8169_NTXSEGS;
	}

	bcopy(eaddr, (char *)&sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);

	for (rr = re_revisions; rr->re_name != NULL; rr++) {
		if (rr->re_chipid == sc->sc_hwrev)
			re_name = rr->re_name;
	}

	if (re_name == NULL)
		printf(": unknown ASIC (0x%04x)", sc->sc_hwrev >> 16);
	else
		printf(": %s (0x%04x)", re_name, sc->sc_hwrev >> 16);

	printf(", %s, address %s\n", intrstr,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/* Allocate DMA'able memory for the TX ring */
	if ((error = bus_dmamem_alloc(sc->sc_dmat, RL_TX_LIST_SZ(sc),
		    RL_RING_ALIGN, 0, &sc->rl_ldata.rl_tx_listseg, 1,
		    &sc->rl_ldata.rl_tx_listnseg, BUS_DMA_NOWAIT |
		    BUS_DMA_ZERO)) != 0) {
		printf("%s: can't allocate tx listseg, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_0;
	}

	/* Load the map for the TX ring. */
	if ((error = bus_dmamem_map(sc->sc_dmat, &sc->rl_ldata.rl_tx_listseg,
		    sc->rl_ldata.rl_tx_listnseg, RL_TX_LIST_SZ(sc),
		    (caddr_t *)&sc->rl_ldata.rl_tx_list,
		    BUS_DMA_COHERENT | BUS_DMA_NOWAIT)) != 0) {
		printf("%s: can't map tx list, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_1;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, RL_TX_LIST_SZ(sc), 1,
		    RL_TX_LIST_SZ(sc), 0, 0,
		    &sc->rl_ldata.rl_tx_list_map)) != 0) {
		printf("%s: can't create tx list map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_2;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat,
		    sc->rl_ldata.rl_tx_list_map, sc->rl_ldata.rl_tx_list,
		    RL_TX_LIST_SZ(sc), NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: can't load tx list, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_3;
	}

	/* Create DMA maps for TX buffers */
	for (i = 0; i < sc->rl_ldata.rl_tx_desc_cnt; i++) {
		error = bus_dmamap_create(sc->sc_dmat,
		    RL_JUMBO_FRAMELEN, sc->rl_ldata.rl_tx_ndescs,
		    RL_JUMBO_FRAMELEN, 0, 0,
		    &sc->rl_ldata.rl_txq[i].txq_dmamap);
		if (error) {
			printf("%s: can't create DMA map for TX\n",
			    sc->sc_dev.dv_xname);
			goto fail_4;
		}
	}

        /* Allocate DMA'able memory for the RX ring */
	if ((error = bus_dmamem_alloc(sc->sc_dmat, RL_RX_DMAMEM_SZ(sc),
		    RL_RING_ALIGN, 0, &sc->rl_ldata.rl_rx_listseg, 1,
		    &sc->rl_ldata.rl_rx_listnseg, BUS_DMA_NOWAIT |
		    BUS_DMA_ZERO)) != 0) {
		printf("%s: can't allocate rx listnseg, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_4;
	}

        /* Load the map for the RX ring. */
	if ((error = bus_dmamem_map(sc->sc_dmat, &sc->rl_ldata.rl_rx_listseg,
		    sc->rl_ldata.rl_rx_listnseg, RL_RX_DMAMEM_SZ(sc),
		    (caddr_t *)&sc->rl_ldata.rl_rx_list,
		    BUS_DMA_COHERENT | BUS_DMA_NOWAIT)) != 0) {
		printf("%s: can't map rx list, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_5;

	}

	if ((error = bus_dmamap_create(sc->sc_dmat, RL_RX_DMAMEM_SZ(sc), 1,
		    RL_RX_DMAMEM_SZ(sc), 0, 0,
		    &sc->rl_ldata.rl_rx_list_map)) != 0) {
		printf("%s: can't create rx list map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_6;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat,
		    sc->rl_ldata.rl_rx_list_map, sc->rl_ldata.rl_rx_list,
		    RL_RX_DMAMEM_SZ(sc), NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: can't load rx list, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_7;
	}

	/* Create DMA maps for RX buffers */
	for (i = 0; i < sc->rl_ldata.rl_rx_desc_cnt; i++) {
		error = bus_dmamap_create(sc->sc_dmat,
		    RL_FRAMELEN(sc->rl_max_mtu), 1,
		    RL_FRAMELEN(sc->rl_max_mtu), 0, 0,
		    &sc->rl_ldata.rl_rxsoft[i].rxs_dmamap);
		if (error) {
			printf("%s: can't create DMA map for RX\n",
			    sc->sc_dev.dv_xname);
			goto fail_8;
		}
	}

	ifp = &sc->sc_arpcom.ac_if;
	ifp->if_softc = sc;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_xflags = IFXF_MPSAFE;
	ifp->if_ioctl = re_ioctl;
	ifp->if_qstart = re_start;
	ifp->if_watchdog = re_watchdog;
	ifp->if_hardmtu = sc->rl_max_mtu;
	IFQ_SET_MAXLEN(&ifp->if_snd, sc->rl_ldata.rl_tx_desc_cnt);

	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_CSUM_TCPv4 |
	    IFCAP_CSUM_UDPv4;

	/*
	 * RTL8168/8111C generates wrong IP checksummed frame if the
	 * packet has IP options so disable TX IP checksum offloading.
	 */
	switch (sc->sc_hwrev) {
	case RL_HWREV_8168C:
	case RL_HWREV_8168C_SPIN2:
	case RL_HWREV_8168CP:
		break;
	default:
		ifp->if_capabilities |= IFCAP_CSUM_IPv4;
	}

#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
#endif

#ifndef SMALL_KERNEL
	ifp->if_capabilities |= IFCAP_WOL;
	ifp->if_wol = re_wol;
	re_wol(ifp, 0);
#endif
	timeout_set(&sc->timer_handle, re_tick, sc);
	task_set(&sc->rl_start, re_txstart, sc);

	/* Take PHY out of power down mode. */
	if (sc->rl_flags & RL_FLAG_PHYWAKE_PM) {
		CSR_WRITE_1(sc, RL_PMCH, CSR_READ_1(sc, RL_PMCH) | 0x80);
		if (sc->sc_hwrev == RL_HWREV_8401E)
			CSR_WRITE_1(sc, 0xD1, CSR_READ_1(sc, 0xD1) & ~0x08);
	}
	if (sc->rl_flags & RL_FLAG_PHYWAKE) {
		re_gmii_writereg((struct device *)sc, 1, 0x1f, 0);
		re_gmii_writereg((struct device *)sc, 1, 0x0e, 0);
	}

	/* Do MII setup */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = re_miibus_readreg;
	sc->sc_mii.mii_writereg = re_miibus_writereg;
	sc->sc_mii.mii_statchg = re_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, IFM_IMASK, re_ifmedia_upd,
	    re_ifmedia_sts);
	mii_attach(&sc->sc_dev, &sc->sc_mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, MIIF_DOPAUSE);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		printf("%s: no PHY found!\n", sc->sc_dev.dv_xname);
		ifmedia_add(&sc->sc_mii.mii_media,
		    IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media,
		    IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	/*
	 * Call MI attach routine.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	return (0);

fail_8:
	/* Destroy DMA maps for RX buffers. */
	for (i = 0; i < sc->rl_ldata.rl_rx_desc_cnt; i++) {
		if (sc->rl_ldata.rl_rxsoft[i].rxs_dmamap != NULL)
			bus_dmamap_destroy(sc->sc_dmat,
			    sc->rl_ldata.rl_rxsoft[i].rxs_dmamap);
	}

	/* Free DMA'able memory for the RX ring. */
	bus_dmamap_unload(sc->sc_dmat, sc->rl_ldata.rl_rx_list_map);
fail_7:
	bus_dmamap_destroy(sc->sc_dmat, sc->rl_ldata.rl_rx_list_map);
fail_6:
	bus_dmamem_unmap(sc->sc_dmat,
	    (caddr_t)sc->rl_ldata.rl_rx_list, RL_RX_DMAMEM_SZ(sc));
fail_5:
	bus_dmamem_free(sc->sc_dmat,
	    &sc->rl_ldata.rl_rx_listseg, sc->rl_ldata.rl_rx_listnseg);

fail_4:
	/* Destroy DMA maps for TX buffers. */
	for (i = 0; i < sc->rl_ldata.rl_tx_desc_cnt; i++) {
		if (sc->rl_ldata.rl_txq[i].txq_dmamap != NULL)
			bus_dmamap_destroy(sc->sc_dmat,
			    sc->rl_ldata.rl_txq[i].txq_dmamap);
	}

	/* Free DMA'able memory for the TX ring. */
	bus_dmamap_unload(sc->sc_dmat, sc->rl_ldata.rl_tx_list_map);
fail_3:
	bus_dmamap_destroy(sc->sc_dmat, sc->rl_ldata.rl_tx_list_map);
fail_2:
	bus_dmamem_unmap(sc->sc_dmat,
	    (caddr_t)sc->rl_ldata.rl_tx_list, RL_TX_LIST_SZ(sc));
fail_1:
	bus_dmamem_free(sc->sc_dmat,
	    &sc->rl_ldata.rl_tx_listseg, sc->rl_ldata.rl_tx_listnseg);
fail_0:
 	return (1);
}


int
re_newbuf(struct rl_softc *sc)
{
	struct mbuf	*m;
	bus_dmamap_t	map;
	struct rl_desc	*d;
	struct rl_rxsoft *rxs;
	u_int32_t	cmdstat;
	int		error, idx;

	m = MCLGETI(NULL, M_DONTWAIT, NULL, RL_FRAMELEN(sc->rl_max_mtu));
	if (!m)
		return (ENOBUFS);

	/*
	 * Initialize mbuf length fields and fixup
	 * alignment so that the frame payload is
	 * longword aligned on strict alignment archs.
	 */
	m->m_len = m->m_pkthdr.len = RL_FRAMELEN(sc->rl_max_mtu);
	m->m_data += RE_ETHER_ALIGN;

	idx = sc->rl_ldata.rl_rx_prodidx;
	rxs = &sc->rl_ldata.rl_rxsoft[idx];
	map = rxs->rxs_dmamap;
	error = bus_dmamap_load_mbuf(sc->sc_dmat, map, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

	d = &sc->rl_ldata.rl_rx_list[idx];
	RL_RXDESCSYNC(sc, idx, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	cmdstat = letoh32(d->rl_cmdstat);
	RL_RXDESCSYNC(sc, idx, BUS_DMASYNC_PREREAD);
	if (cmdstat & RL_RDESC_STAT_OWN) {
		printf("%s: tried to map busy RX descriptor\n",
		    sc->sc_dev.dv_xname);
		m_freem(m);
		return (ENOBUFS);
	}

	rxs->rxs_mbuf = m;

	d->rl_vlanctl = 0;
	cmdstat = map->dm_segs[0].ds_len;
	if (idx == sc->rl_ldata.rl_rx_desc_cnt - 1)
		cmdstat |= RL_RDESC_CMD_EOR;
	re_set_bufaddr(d, map->dm_segs[0].ds_addr);
	d->rl_cmdstat = htole32(cmdstat);
	RL_RXDESCSYNC(sc, idx, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	cmdstat |= RL_RDESC_CMD_OWN;
	d->rl_cmdstat = htole32(cmdstat);
	RL_RXDESCSYNC(sc, idx, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	sc->rl_ldata.rl_rx_prodidx = RL_NEXT_RX_DESC(sc, idx);

	return (0);
}


int
re_tx_list_init(struct rl_softc *sc)
{
	int i;

	memset(sc->rl_ldata.rl_tx_list, 0, RL_TX_LIST_SZ(sc));
	for (i = 0; i < sc->rl_ldata.rl_tx_desc_cnt; i++) {
		sc->rl_ldata.rl_txq[i].txq_mbuf = NULL;
	}

	bus_dmamap_sync(sc->sc_dmat,
	    sc->rl_ldata.rl_tx_list_map, 0,
	    sc->rl_ldata.rl_tx_list_map->dm_mapsize,
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	sc->rl_ldata.rl_txq_prodidx = 0;
	sc->rl_ldata.rl_txq_considx = 0;
	sc->rl_ldata.rl_tx_free = sc->rl_ldata.rl_tx_desc_cnt;
	sc->rl_ldata.rl_tx_nextfree = 0;

	return (0);
}

int
re_rx_list_init(struct rl_softc *sc)
{
	bzero(sc->rl_ldata.rl_rx_list, RL_RX_LIST_SZ(sc));

	sc->rl_ldata.rl_rx_prodidx = 0;
	sc->rl_ldata.rl_rx_considx = 0;
	sc->rl_head = sc->rl_tail = NULL;

	if_rxr_init(&sc->rl_ldata.rl_rx_ring, 2,
	    sc->rl_ldata.rl_rx_desc_cnt - 1);
	re_rx_list_fill(sc);

	return (0);
}

void
re_rx_list_fill(struct rl_softc *sc)
{
	u_int slots;

	for (slots = if_rxr_get(&sc->rl_ldata.rl_rx_ring,
	    sc->rl_ldata.rl_rx_desc_cnt);
	    slots > 0; slots--) {
		if (re_newbuf(sc) == ENOBUFS)
			break;
	}
	if_rxr_put(&sc->rl_ldata.rl_rx_ring, slots);
}

/*
 * RX handler for C+ and 8169. For the gigE chips, we support
 * the reception of jumbo frames that have been fragmented
 * across multiple 2K mbuf cluster buffers.
 */
int
re_rxeof(struct rl_softc *sc)
{
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf	*m;
	struct ifnet	*ifp;
	int		i, total_len, rx = 0;
	struct rl_desc	*cur_rx;
	struct rl_rxsoft *rxs;
	u_int32_t	rxstat, rxvlan;

	ifp = &sc->sc_arpcom.ac_if;

	for (i = sc->rl_ldata.rl_rx_considx;
	    if_rxr_inuse(&sc->rl_ldata.rl_rx_ring) > 0;
	     i = RL_NEXT_RX_DESC(sc, i)) {
		cur_rx = &sc->rl_ldata.rl_rx_list[i];
		RL_RXDESCSYNC(sc, i,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		rxstat = letoh32(cur_rx->rl_cmdstat);
		rxvlan = letoh32(cur_rx->rl_vlanctl);
		RL_RXDESCSYNC(sc, i, BUS_DMASYNC_PREREAD);
		if ((rxstat & RL_RDESC_STAT_OWN) != 0)
			break;
		total_len = rxstat & sc->rl_rxlenmask;
		rxs = &sc->rl_ldata.rl_rxsoft[i];
		m = rxs->rxs_mbuf;
		rxs->rxs_mbuf = NULL;
		if_rxr_put(&sc->rl_ldata.rl_rx_ring, 1);
		rx = 1;

		/* Invalidate the RX mbuf and unload its map */

		bus_dmamap_sync(sc->sc_dmat,
		    rxs->rxs_dmamap, 0, rxs->rxs_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmat, rxs->rxs_dmamap);

		if ((sc->rl_flags & RL_FLAG_JUMBOV2) != 0 &&
		    (rxstat & (RL_RDESC_STAT_SOF | RL_RDESC_STAT_EOF)) !=
		    (RL_RDESC_STAT_SOF | RL_RDESC_STAT_EOF)) {
			continue;
		} else if (!(rxstat & RL_RDESC_STAT_EOF)) {
			m->m_len = RL_FRAMELEN(sc->rl_max_mtu);
			if (sc->rl_head == NULL)
				sc->rl_head = sc->rl_tail = m;
			else {
				m->m_flags &= ~M_PKTHDR;
				sc->rl_tail->m_next = m;
				sc->rl_tail = m;
			}
			continue;
		}

		/*
		 * NOTE: for the 8139C+, the frame length field
		 * is always 12 bits in size, but for the gigE chips,
		 * it is 13 bits (since the max RX frame length is 16K).
		 * Unfortunately, all 32 bits in the status word
		 * were already used, so to make room for the extra
		 * length bit, Realtek took out the 'frame alignment
		 * error' bit and shifted the other status bits
		 * over one slot. The OWN, EOR, FS and LS bits are
		 * still in the same places. We have already extracted
		 * the frame length and checked the OWN bit, so rather
		 * than using an alternate bit mapping, we shift the
		 * status bits one space to the right so we can evaluate
		 * them using the 8169 status as though it was in the
		 * same format as that of the 8139C+.
		 */
		if (sc->sc_hwrev != RL_HWREV_8139CPLUS)
			rxstat >>= 1;

		/*
		 * if total_len > 2^13-1, both _RXERRSUM and _GIANT will be
		 * set, but if CRC is clear, it will still be a valid frame.
		 */
		if ((rxstat & RL_RDESC_STAT_RXERRSUM) != 0 &&
	 	    !(rxstat & RL_RDESC_STAT_RXERRSUM && !(total_len > 8191 &&
		    (rxstat & RL_RDESC_STAT_ERRS) == RL_RDESC_STAT_GIANT))) {
			ifp->if_ierrors++;
			/*
			 * If this is part of a multi-fragment packet,
			 * discard all the pieces.
			 */
			if (sc->rl_head != NULL) {
				m_freem(sc->rl_head);
				sc->rl_head = sc->rl_tail = NULL;
			}
			continue;
		}

		if (sc->rl_head != NULL) {
			m->m_len = total_len % RL_FRAMELEN(sc->rl_max_mtu);
			if (m->m_len == 0)
				m->m_len = RL_FRAMELEN(sc->rl_max_mtu);
			/* 
			 * Special case: if there's 4 bytes or less
			 * in this buffer, the mbuf can be discarded:
			 * the last 4 bytes is the CRC, which we don't
			 * care about anyway.
			 */
			if (m->m_len <= ETHER_CRC_LEN) {
				sc->rl_tail->m_len -=
				    (ETHER_CRC_LEN - m->m_len);
				m_freem(m);
			} else {
				m->m_len -= ETHER_CRC_LEN;
				m->m_flags &= ~M_PKTHDR;
				sc->rl_tail->m_next = m;
			}
			m = sc->rl_head;
			sc->rl_head = sc->rl_tail = NULL;
			m->m_pkthdr.len = total_len - ETHER_CRC_LEN;
		} else
			m->m_pkthdr.len = m->m_len =
			    (total_len - ETHER_CRC_LEN);

		/* Do RX checksumming */

		if (sc->rl_flags & RL_FLAG_DESCV2) {
			/* Check IP header checksum */
			if ((rxvlan & RL_RDESC_IPV4) &&
			    !(rxstat & RL_RDESC_STAT_IPSUMBAD))
				m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;

			/* Check TCP/UDP checksum */
			if ((rxvlan & (RL_RDESC_IPV4|RL_RDESC_IPV6)) &&
			    (((rxstat & RL_RDESC_STAT_TCP) &&
			    !(rxstat & RL_RDESC_STAT_TCPSUMBAD)) ||
			    ((rxstat & RL_RDESC_STAT_UDP) &&
			    !(rxstat & RL_RDESC_STAT_UDPSUMBAD))))
				m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK |
				    M_UDP_CSUM_IN_OK;
		} else {
			/* Check IP header checksum */
			if ((rxstat & RL_RDESC_STAT_PROTOID) &&
			    !(rxstat & RL_RDESC_STAT_IPSUMBAD))
				m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;

			/* Check TCP/UDP checksum */
			if ((RL_TCPPKT(rxstat) &&
			    !(rxstat & RL_RDESC_STAT_TCPSUMBAD)) ||
			    (RL_UDPPKT(rxstat) &&
			    !(rxstat & RL_RDESC_STAT_UDPSUMBAD)))
				m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK |
				    M_UDP_CSUM_IN_OK;
		}
#if NVLAN > 0
		if (rxvlan & RL_RDESC_VLANCTL_TAG) {
			m->m_pkthdr.ether_vtag =
			    ntohs((rxvlan & RL_RDESC_VLANCTL_DATA));
			m->m_flags |= M_VLANTAG;
		}
#endif

		ml_enqueue(&ml, m);
	}

	sc->rl_ldata.rl_rx_considx = i;
	re_rx_list_fill(sc);

	if_input(ifp, &ml);

	return (rx);
}

int
re_txeof(struct rl_softc *sc)
{
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
	struct rl_txq	*txq;
	uint32_t	txstat;
	unsigned int	prod, cons;
	unsigned int	idx;
	int		free = 0;

	ifp = &sc->sc_arpcom.ac_if;

	prod = sc->rl_ldata.rl_txq_prodidx;
	cons = sc->rl_ldata.rl_txq_considx;

	while (prod != cons) {
		txq = &sc->rl_ldata.rl_txq[cons];

		idx = txq->txq_descidx;
		RL_TXDESCSYNC(sc, idx, BUS_DMASYNC_POSTREAD);
		txstat = letoh32(sc->rl_ldata.rl_tx_list[idx].rl_cmdstat);
		RL_TXDESCSYNC(sc, idx, BUS_DMASYNC_PREREAD);
		if (ISSET(txstat, RL_TDESC_CMD_OWN)) {
			free = 2;
			break;
		}

		bus_dmamap_sync(sc->sc_dmat, txq->txq_dmamap,
		    0, txq->txq_dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, txq->txq_dmamap);
		m_freem(txq->txq_mbuf);
		txq->txq_mbuf = NULL;

		if (txstat & (RL_TDESC_STAT_EXCESSCOL | RL_TDESC_STAT_COLCNT))
			ifp->if_collisions++;
		if (txstat & RL_TDESC_STAT_TXERRSUM)
			ifp->if_oerrors++;

		cons = RL_NEXT_TX_DESC(sc, idx);
		free = 1;
	}

	if (free == 0)
		return (0);

	sc->rl_ldata.rl_txq_considx = cons;

	/*
	 * Some chips will ignore a second TX request issued while an
	 * existing transmission is in progress. If the transmitter goes
	 * idle but there are still packets waiting to be sent, we need
	 * to restart the channel here to flush them out. This only
	 * seems to be required with the PCIe devices.
	 */
	if (ifq_is_oactive(&ifp->if_snd))
		ifq_restart(&ifp->if_snd);
	else if (free == 2)
		ifq_serialize(&ifp->if_snd, &sc->rl_start);
	else
		ifp->if_timer = 0;

	return (1);
}

void
re_tick(void *xsc)
{
	struct rl_softc	*sc = xsc;
	struct mii_data	*mii;
	int s;

	mii = &sc->sc_mii;

	s = splnet();

	mii_tick(mii);

	if ((sc->rl_flags & RL_FLAG_LINK) == 0)
		re_miibus_statchg(&sc->sc_dev);

	splx(s);

	timeout_add_sec(&sc->timer_handle, 1);
}

int
re_intr(void *arg)
{
	struct rl_softc	*sc = arg;
	struct ifnet	*ifp;
	u_int16_t	status;
	int		claimed = 0, rx, tx;

	ifp = &sc->sc_arpcom.ac_if;

	if (!(ifp->if_flags & IFF_RUNNING))
		return (0);

	/* Disable interrupts. */
	CSR_WRITE_2(sc, RL_IMR, 0);

	rx = tx = 0;
	status = CSR_READ_2(sc, RL_ISR);
	/* If the card has gone away the read returns 0xffff. */
	if (status == 0xffff)
		return (0);
	if (status)
		CSR_WRITE_2(sc, RL_ISR, status);

	if (status & RL_ISR_TIMEOUT_EXPIRED)
		claimed = 1;

	if (status & RL_INTRS_CPLUS) {
		if (status &
		    (sc->rl_rx_ack | RL_ISR_RX_ERR | RL_ISR_FIFO_OFLOW)) {
			rx |= re_rxeof(sc);
			claimed = 1;
		}

		if (status & (sc->rl_tx_ack | RL_ISR_TX_ERR)) {
			tx |= re_txeof(sc);
			claimed = 1;
		}

		if (status & RL_ISR_SYSTEM_ERR) {
			KERNEL_LOCK();
			re_init(ifp);
			KERNEL_UNLOCK();
			claimed = 1;
		}
	}

	if (sc->rl_imtype == RL_IMTYPE_SIM) {
		if (sc->rl_timerintr) {
			if ((tx | rx) == 0) {
				/*
				 * Nothing needs to be processed, fallback
				 * to use TX/RX interrupts.
				 */
				re_setup_intr(sc, 1, RL_IMTYPE_NONE);

				/*
				 * Recollect, mainly to avoid the possible
				 * race introduced by changing interrupt
				 * masks.
				 */
				re_rxeof(sc);
				re_txeof(sc);
			} else
				CSR_WRITE_4(sc, RL_TIMERCNT, 1); /* reload */
		} else if (tx | rx) {
			/*
			 * Assume that using simulated interrupt moderation
			 * (hardware timer based) could reduce the interrupt
			 * rate.
			 */
			re_setup_intr(sc, 1, RL_IMTYPE_SIM);
		}
	}

	CSR_WRITE_2(sc, RL_IMR, sc->rl_intrs);

	return (claimed);
}

int
re_encap(struct rl_softc *sc, unsigned int idx, struct mbuf *m)
{
	struct rl_txq	*txq;
	bus_dmamap_t	map;
	int		error, seg, nsegs, curidx, lastidx, pad;
	int		off;
	struct ip	*ip;
	struct rl_desc	*d;
	u_int32_t	cmdstat, vlanctl = 0, csum_flags = 0;

	/*
	 * Set up checksum offload. Note: checksum offload bits must
	 * appear in all descriptors of a multi-descriptor transmit
	 * attempt. This is according to testing done with an 8169
	 * chip. This is a requirement.
	 */

	/*
	 * Set RL_TDESC_CMD_IPCSUM if any checksum offloading
	 * is requested.  Otherwise, RL_TDESC_CMD_TCPCSUM/
	 * RL_TDESC_CMD_UDPCSUM does not take affect.
	 */

	if ((sc->rl_flags & RL_FLAG_JUMBOV2) &&
	    m->m_pkthdr.len > RL_MTU &&
	    (m->m_pkthdr.csum_flags &
	    (M_IPV4_CSUM_OUT|M_TCP_CSUM_OUT|M_UDP_CSUM_OUT)) != 0) {
		struct mbuf mh, *mp;

		mp = m_getptr(m, ETHER_HDR_LEN, &off);
		mh.m_flags = 0;
		mh.m_data = mtod(mp, caddr_t) + off;
		mh.m_next = mp->m_next;
		mh.m_pkthdr.len = mp->m_pkthdr.len - ETHER_HDR_LEN;
		mh.m_len = mp->m_len - off;
		ip = (struct ip *)mh.m_data;

		if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
			ip->ip_sum = in_cksum(&mh, sizeof(struct ip)); 
		if (m->m_pkthdr.csum_flags & (M_TCP_CSUM_OUT|M_UDP_CSUM_OUT))
			in_delayed_cksum(&mh);

		m->m_pkthdr.csum_flags &=
		    ~(M_IPV4_CSUM_OUT|M_TCP_CSUM_OUT|M_UDP_CSUM_OUT);
	}

	if ((m->m_pkthdr.csum_flags &
	    (M_IPV4_CSUM_OUT|M_TCP_CSUM_OUT|M_UDP_CSUM_OUT)) != 0) {
		if (sc->rl_flags & RL_FLAG_DESCV2) {
			vlanctl |= RL_TDESC_CMD_IPCSUMV2;
			if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT)
				vlanctl |= RL_TDESC_CMD_TCPCSUMV2;
			if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT)
				vlanctl |= RL_TDESC_CMD_UDPCSUMV2;
		} else {
			csum_flags |= RL_TDESC_CMD_IPCSUM;
			if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT)
				csum_flags |= RL_TDESC_CMD_TCPCSUM;
			if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT)
				csum_flags |= RL_TDESC_CMD_UDPCSUM;
		}
	}

	txq = &sc->rl_ldata.rl_txq[idx];
	map = txq->txq_dmamap;

	error = bus_dmamap_load_mbuf(sc->sc_dmat, map, m,
	    BUS_DMA_WRITE|BUS_DMA_NOWAIT);
	switch (error) {
	case 0:
		break;

	case EFBIG:
		if (m_defrag(m, M_DONTWAIT) == 0 &&
		    bus_dmamap_load_mbuf(sc->sc_dmat, map, m,
		    BUS_DMA_WRITE|BUS_DMA_NOWAIT) == 0)
			break;

		/* FALLTHROUGH */
	default:
		return (0);
	}

	bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	nsegs = map->dm_nsegs;
	pad = 0;

	/*
	 * With some of the RealTek chips, using the checksum offload
	 * support in conjunction with the autopadding feature results
	 * in the transmission of corrupt frames. For example, if we
	 * need to send a really small IP fragment that's less than 60
	 * bytes in size, and IP header checksumming is enabled, the
	 * resulting ethernet frame that appears on the wire will
	 * have garbled payload. To work around this, if TX IP checksum
	 * offload is enabled, we always manually pad short frames out
	 * to the minimum ethernet frame size.
	 */
	if ((sc->rl_flags & RL_FLAG_AUTOPAD) == 0 &&
	    m->m_pkthdr.len < RL_IP4CSUMTX_PADLEN &&
	    (m->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT) != 0) {
		pad = 1;
		nsegs++;
	}

	/*
	 * Set up hardware VLAN tagging. Note: vlan tag info must
	 * appear in all descriptors of a multi-descriptor
	 * transmission attempt.
	 */
#if NVLAN > 0
	if (m->m_flags & M_VLANTAG)
		vlanctl |= swap16(m->m_pkthdr.ether_vtag) |
		    RL_TDESC_VLANCTL_TAG;
#endif

	/*
	 * Map the segment array into descriptors. Note that we set the
	 * start-of-frame and end-of-frame markers for either TX or RX, but
	 * they really only have meaning in the TX case. (In the RX case,
	 * it's the chip that tells us where packets begin and end.)
	 * We also keep track of the end of the ring and set the
	 * end-of-ring bits as needed, and we set the ownership bits
	 * in all except the very first descriptor. (The caller will
	 * set this descriptor later when it start transmission or
	 * reception.)
	 */
	curidx = idx;
	cmdstat = RL_TDESC_CMD_SOF;

	for (seg = 0; seg < map->dm_nsegs; seg++) {
		d = &sc->rl_ldata.rl_tx_list[curidx];

		RL_TXDESCSYNC(sc, curidx, BUS_DMASYNC_POSTWRITE);

		d->rl_vlanctl = htole32(vlanctl);
		re_set_bufaddr(d, map->dm_segs[seg].ds_addr);
		cmdstat |= csum_flags | map->dm_segs[seg].ds_len;

		if (curidx == sc->rl_ldata.rl_tx_desc_cnt - 1)
			cmdstat |= RL_TDESC_CMD_EOR;

		d->rl_cmdstat = htole32(cmdstat);

		RL_TXDESCSYNC(sc, curidx, BUS_DMASYNC_PREWRITE);

		lastidx = curidx;
		cmdstat = RL_TDESC_CMD_OWN;
		curidx = RL_NEXT_TX_DESC(sc, curidx);
	}

	if (pad) {
		d = &sc->rl_ldata.rl_tx_list[curidx];

		RL_TXDESCSYNC(sc, curidx, BUS_DMASYNC_POSTWRITE);

		d->rl_vlanctl = htole32(vlanctl);
		re_set_bufaddr(d, RL_TXPADDADDR(sc));
		cmdstat = csum_flags |
		    RL_TDESC_CMD_OWN | RL_TDESC_CMD_EOF |
		    (RL_IP4CSUMTX_PADLEN + 1 - m->m_pkthdr.len);

		if (curidx == sc->rl_ldata.rl_tx_desc_cnt - 1)
			cmdstat |= RL_TDESC_CMD_EOR;

		d->rl_cmdstat = htole32(cmdstat);

		RL_TXDESCSYNC(sc, curidx, BUS_DMASYNC_PREWRITE);

		lastidx = curidx;
	}

	/* d is already pointing at the last descriptor */
	d->rl_cmdstat |= htole32(RL_TDESC_CMD_EOF);

	/* Transfer ownership of packet to the chip. */
	d = &sc->rl_ldata.rl_tx_list[idx];

	RL_TXDESCSYNC(sc, curidx, BUS_DMASYNC_POSTWRITE);
	d->rl_cmdstat |= htole32(RL_TDESC_CMD_OWN);
	RL_TXDESCSYNC(sc, curidx, BUS_DMASYNC_PREWRITE);

	/* update info of TX queue and descriptors */
	txq->txq_mbuf = m;
	txq->txq_descidx = lastidx;

	return (nsegs);
}

void
re_txstart(void *xsc)
{
	struct rl_softc *sc = xsc;

	CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START);
}

/*
 * Main transmit routine for C+ and gigE NICs.
 */

void
re_start(struct ifqueue *ifq)
{
	struct ifnet	*ifp = ifq->ifq_if;
	struct rl_softc	*sc = ifp->if_softc;
	struct mbuf	*m;
	unsigned int	idx;
	unsigned int	free, used;
	int		post = 0;

	if (!ISSET(sc->rl_flags, RL_FLAG_LINK)) {
		ifq_purge(ifq);
		return;
	}

	free = sc->rl_ldata.rl_txq_considx;
	idx = sc->rl_ldata.rl_txq_prodidx;
	if (free <= idx)
		free += sc->rl_ldata.rl_tx_desc_cnt;
	free -= idx;

	for (;;) {
		if (sc->rl_ldata.rl_tx_ndescs >= free + 2) {
			ifq_set_oactive(ifq);
			break;
		}

		m = ifq_dequeue(ifq);
		if (m == NULL)
			break;

		used = re_encap(sc, idx, m);
		if (used == 0) {
			m_freem(m);
			continue;
		}

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		KASSERT(used <= free);
		free -= used;

		idx += used;
		if (idx >= sc->rl_ldata.rl_tx_desc_cnt)
			idx -= sc->rl_ldata.rl_tx_desc_cnt;

		post = 1;
	}

	if (post == 0)
		return;

	ifp->if_timer = 5;
	sc->rl_ldata.rl_txq_prodidx = idx;
	ifq_serialize(ifq, &sc->rl_start);
}

int
re_init(struct ifnet *ifp)
{
	struct rl_softc *sc = ifp->if_softc;
	u_int16_t	cfg;
	uint32_t	rxcfg;
	int		s;
	union {
		u_int32_t align_dummy;
		u_char eaddr[ETHER_ADDR_LEN];
	} eaddr;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	re_stop(ifp);

	/* Put controller into known state. */
	re_reset(sc);

	/*
	 * Enable C+ RX and TX mode, as well as VLAN stripping and
	 * RX checksum offload. We must configure the C+ register
	 * before all others.
	 */
	cfg = RL_CPLUSCMD_TXENB | RL_CPLUSCMD_PCI_MRW |
	    RL_CPLUSCMD_RXCSUM_ENB;

	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		cfg |= RL_CPLUSCMD_VLANSTRIP;

	if (sc->rl_flags & RL_FLAG_MACSTAT)
		cfg |= RL_CPLUSCMD_MACSTAT_DIS;
	else
		cfg |= RL_CPLUSCMD_RXENB;

	CSR_WRITE_2(sc, RL_CPLUS_CMD, cfg);

	/*
	 * Init our MAC address.  Even though the chipset
	 * documentation doesn't mention it, we need to enter "Config
	 * register write enable" mode to modify the ID registers.
	 */
	bcopy(sc->sc_arpcom.ac_enaddr, eaddr.eaddr, ETHER_ADDR_LEN);
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_WRITECFG);
	CSR_WRITE_4(sc, RL_IDR4,
	    htole32(*(u_int32_t *)(&eaddr.eaddr[4])));
	CSR_WRITE_4(sc, RL_IDR0,
	    htole32(*(u_int32_t *)(&eaddr.eaddr[0])));
	/*
	 * Default on PC Engines APU1 is to have all LEDs off unless
	 * there is network activity. Override to provide a link status
	 * LED.
	 */
	if (sc->sc_hwrev == RL_HWREV_8168E &&
	    hw_vendor != NULL && hw_prod != NULL &&
	    strcmp(hw_vendor, "PC Engines") == 0 &&
	    strcmp(hw_prod, "APU") == 0) {
		CSR_SETBIT_1(sc, RL_CFG4, RL_CFG4_CUSTOM_LED);
		CSR_WRITE_1(sc, RL_LEDSEL, RL_LED_LINK | RL_LED_ACT << 4);
	}
	/*
	 * Protect config register again
	 */
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);

	if ((sc->rl_flags & RL_FLAG_JUMBOV2) != 0)
		re_set_jumbo(sc);

	/*
	 * For C+ mode, initialize the RX descriptors and mbufs.
	 */
	re_rx_list_init(sc);
	re_tx_list_init(sc);

	/*
	 * Load the addresses of the RX and TX lists into the chip.
	 */
	CSR_WRITE_4(sc, RL_RXLIST_ADDR_HI,
	    RL_ADDR_HI(sc->rl_ldata.rl_rx_list_map->dm_segs[0].ds_addr));
	CSR_WRITE_4(sc, RL_RXLIST_ADDR_LO,
	    RL_ADDR_LO(sc->rl_ldata.rl_rx_list_map->dm_segs[0].ds_addr));

	CSR_WRITE_4(sc, RL_TXLIST_ADDR_HI,
	    RL_ADDR_HI(sc->rl_ldata.rl_tx_list_map->dm_segs[0].ds_addr));
	CSR_WRITE_4(sc, RL_TXLIST_ADDR_LO,
	    RL_ADDR_LO(sc->rl_ldata.rl_tx_list_map->dm_segs[0].ds_addr));

	if (sc->rl_flags & RL_FLAG_RXDV_GATED)
		CSR_WRITE_4(sc, RL_MISC, CSR_READ_4(sc, RL_MISC) &
		    ~0x00080000);

	/*
	 * Set the initial TX and RX configuration.
	 */
	CSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);

	CSR_WRITE_1(sc, RL_EARLY_TX_THRESH, 16);

	rxcfg = RL_RXCFG_CONFIG;
	if (sc->rl_flags & RL_FLAG_EARLYOFF)
		rxcfg |= RL_RXCFG_EARLYOFF;
	else if (sc->rl_flags & RL_FLAG_EARLYOFFV2)
		rxcfg |= RL_RXCFG_EARLYOFFV2;
	CSR_WRITE_4(sc, RL_RXCFG, rxcfg);

	/*
	 * Enable transmit and receive.
	 */
	CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB | RL_CMD_RX_ENB);

	/* Program promiscuous mode and multicast filters. */
	re_iff(sc);

	/*
	 * Enable interrupts.
	 */
	re_setup_intr(sc, 1, sc->rl_imtype);
	CSR_WRITE_2(sc, RL_ISR, sc->rl_imtype);

	/* Start RX/TX process. */
	CSR_WRITE_4(sc, RL_MISSEDPKT, 0);

	/*
	 * For 8169 gigE NICs, set the max allowed RX packet
	 * size so we can receive jumbo frames.
	 */
	if (sc->sc_hwrev != RL_HWREV_8139CPLUS) {
		if (sc->rl_flags & RL_FLAG_PCIE &&
		    (sc->rl_flags & RL_FLAG_JUMBOV2) == 0)
			CSR_WRITE_2(sc, RL_MAXRXPKTLEN, RE_RX_DESC_BUFLEN);
		else
			CSR_WRITE_2(sc, RL_MAXRXPKTLEN, 16383);
	}

	CSR_WRITE_1(sc, sc->rl_cfg1, CSR_READ_1(sc, sc->rl_cfg1) |
	    RL_CFG1_DRVLOAD);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	sc->rl_flags &= ~RL_FLAG_LINK;
	mii_mediachg(&sc->sc_mii);

	timeout_add_sec(&sc->timer_handle, 1);

	return (0);
}

/*
 * Set media options.
 */
int
re_ifmedia_upd(struct ifnet *ifp)
{
	struct rl_softc	*sc;

	sc = ifp->if_softc;

	return (mii_mediachg(&sc->sc_mii));
}

/*
 * Report current media status.
 */
void
re_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct rl_softc	*sc;

	sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
}

int
re_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct rl_softc	*sc = ifp->if_softc;
	struct ifreq	*ifr = (struct ifreq *) data;
	int		s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			re_init(ifp);
		break;
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				re_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				re_stop(ifp);
		}
		break;
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
		break;
	case SIOCGIFRXR:
		error = if_rxr_ioctl((struct if_rxrinfo *)ifr->ifr_data,
		    NULL, RL_FRAMELEN(sc->rl_max_mtu), &sc->rl_ldata.rl_rx_ring);
 		break;
	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			re_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
re_watchdog(struct ifnet *ifp)
{
	struct rl_softc	*sc;
	int	s;

	sc = ifp->if_softc;
	s = splnet();
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);

	re_init(ifp);

	splx(s);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
re_stop(struct ifnet *ifp)
{
	struct rl_softc *sc;
	int	i;

	sc = ifp->if_softc;

	ifp->if_timer = 0;
	sc->rl_flags &= ~RL_FLAG_LINK;
	sc->rl_timerintr = 0;

	timeout_del(&sc->timer_handle);
	ifp->if_flags &= ~IFF_RUNNING;

	/*
	 * Disable accepting frames to put RX MAC into idle state.
	 * Otherwise it's possible to get frames while stop command
	 * execution is in progress and controller can DMA the frame
	 * to already freed RX buffer during that period.
	 */
	CSR_WRITE_4(sc, RL_RXCFG, CSR_READ_4(sc, RL_RXCFG) &
	    ~(RL_RXCFG_RX_ALLPHYS | RL_RXCFG_RX_BROAD | RL_RXCFG_RX_INDIV |
	    RL_RXCFG_RX_MULTI));

	if (sc->rl_flags & RL_FLAG_WAIT_TXPOLL) {
		for (i = RL_TIMEOUT; i > 0; i--) {
			if ((CSR_READ_1(sc, sc->rl_txstart) &
			    RL_TXSTART_START) == 0)
				break;
			DELAY(20);
		}
		if (i == 0)
			printf("%s: stopping TX poll timed out!\n",
			    sc->sc_dev.dv_xname);
		CSR_WRITE_1(sc, RL_COMMAND, 0x00);
	} else if (sc->rl_flags & RL_FLAG_CMDSTOP) {
		CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_STOPREQ | RL_CMD_TX_ENB |
		    RL_CMD_RX_ENB);
		if (sc->rl_flags & RL_FLAG_CMDSTOP_WAIT_TXQ) {
			for (i = RL_TIMEOUT; i > 0; i--) {
				if ((CSR_READ_4(sc, RL_TXCFG) &
				    RL_TXCFG_QUEUE_EMPTY) != 0)
					break;
				DELAY(100);
			}
			if (i == 0)
				printf("%s: stopping TXQ timed out!\n",
				    sc->sc_dev.dv_xname);
		}
	} else
		CSR_WRITE_1(sc, RL_COMMAND, 0x00);
	DELAY(1000);
	CSR_WRITE_2(sc, RL_IMR, 0x0000);
	CSR_WRITE_2(sc, RL_ISR, 0xFFFF);

	intr_barrier(sc->sc_ih);
	ifq_barrier(&ifp->if_snd);

	ifq_clr_oactive(&ifp->if_snd);
	mii_down(&sc->sc_mii);

	if (sc->rl_head != NULL) {
		m_freem(sc->rl_head);
		sc->rl_head = sc->rl_tail = NULL;
	}

	/* Free the TX list buffers. */
	for (i = 0; i < sc->rl_ldata.rl_tx_desc_cnt; i++) {
		if (sc->rl_ldata.rl_txq[i].txq_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat,
			    sc->rl_ldata.rl_txq[i].txq_dmamap);
			m_freem(sc->rl_ldata.rl_txq[i].txq_mbuf);
			sc->rl_ldata.rl_txq[i].txq_mbuf = NULL;
		}
	}

	/* Free the RX list buffers. */
	for (i = 0; i < sc->rl_ldata.rl_rx_desc_cnt; i++) {
		if (sc->rl_ldata.rl_rxsoft[i].rxs_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat,
			    sc->rl_ldata.rl_rxsoft[i].rxs_dmamap);
			m_freem(sc->rl_ldata.rl_rxsoft[i].rxs_mbuf);
			sc->rl_ldata.rl_rxsoft[i].rxs_mbuf = NULL;
		}
	}
}

void
re_setup_hw_im(struct rl_softc *sc)
{
	KASSERT(sc->rl_flags & RL_FLAG_HWIM);

	/*
	 * Interrupt moderation
	 *
	 * 0xABCD
	 * A - unknown (maybe TX related)
	 * B - TX timer (unit: 25us)
	 * C - unknown (maybe RX related)
	 * D - RX timer (unit: 25us)
	 *
	 *
	 * re(4)'s interrupt moderation is actually controlled by
	 * two variables, like most other NICs (bge, bnx etc.)
	 * o  timer
	 * o  number of packets [P]
	 *
	 * The logic relationship between these two variables is
	 * similar to other NICs too:
	 * if (timer expire || packets > [P])
	 *     Interrupt is delivered
	 *
	 * Currently we only know how to set 'timer', but not
	 * 'number of packets', which should be ~30, as far as I
	 * tested (sink ~900Kpps, interrupt rate is 30KHz)
	 */
	CSR_WRITE_2(sc, RL_IM,
		    RL_IM_RXTIME(sc->rl_rx_time) |
		    RL_IM_TXTIME(sc->rl_tx_time) |
		    RL_IM_MAGIC);
}

void
re_disable_hw_im(struct rl_softc *sc)
{
	if (sc->rl_flags & RL_FLAG_HWIM)
		CSR_WRITE_2(sc, RL_IM, 0);
}

void
re_setup_sim_im(struct rl_softc *sc)
{
	if (sc->sc_hwrev == RL_HWREV_8139CPLUS)
		CSR_WRITE_4(sc, RL_TIMERINT, 0x400); /* XXX */
	else {
		u_int32_t nticks;

		/*
		 * Datasheet says tick decreases at bus speed,
		 * but it seems the clock runs a little bit
		 * faster, so we do some compensation here.
		 */
		nticks = (sc->rl_sim_time * sc->rl_bus_speed * 8) / 5;
		CSR_WRITE_4(sc, RL_TIMERINT_8169, nticks);
	}
	CSR_WRITE_4(sc, RL_TIMERCNT, 1); /* reload */
	sc->rl_timerintr = 1;
}

void
re_disable_sim_im(struct rl_softc *sc)
{
	if (sc->sc_hwrev == RL_HWREV_8139CPLUS)
		CSR_WRITE_4(sc, RL_TIMERINT, 0);
	else 
		CSR_WRITE_4(sc, RL_TIMERINT_8169, 0);
	sc->rl_timerintr = 0;
}

void
re_config_imtype(struct rl_softc *sc, int imtype)
{
	switch (imtype) {
	case RL_IMTYPE_HW:
		KASSERT(sc->rl_flags & RL_FLAG_HWIM);
		/* FALLTHROUGH */
	case RL_IMTYPE_NONE:
		sc->rl_intrs = RL_INTRS_CPLUS;
		sc->rl_rx_ack = RL_ISR_RX_OK | RL_ISR_FIFO_OFLOW |
				RL_ISR_RX_OVERRUN;
		sc->rl_tx_ack = RL_ISR_TX_OK;
		break;

	case RL_IMTYPE_SIM:
		sc->rl_intrs = RL_INTRS_TIMER;
		sc->rl_rx_ack = RL_ISR_TIMEOUT_EXPIRED;
		sc->rl_tx_ack = RL_ISR_TIMEOUT_EXPIRED;
		break;

	default:
		panic("%s: unknown imtype %d",
		      sc->sc_dev.dv_xname, imtype);
	}
}

void
re_set_jumbo(struct rl_softc *sc)
{
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_WRITECFG);
	CSR_WRITE_1(sc, RL_CFG3, CSR_READ_1(sc, RL_CFG3) |
	    RL_CFG3_JUMBO_EN0);

	switch (sc->sc_hwrev) {
	case RL_HWREV_8168DP:
		break;
	case RL_HWREV_8168E:
		CSR_WRITE_1(sc, RL_CFG4, CSR_READ_1(sc, RL_CFG4) |
		    RL_CFG4_8168E_JUMBO_EN1);
		break;
	default:
		CSR_WRITE_1(sc, RL_CFG4, CSR_READ_1(sc, RL_CFG4) |
		    RL_CFG4_JUMBO_EN1);
		break;
	}

	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);
}

void
re_setup_intr(struct rl_softc *sc, int enable_intrs, int imtype)
{
	re_config_imtype(sc, imtype);

	if (enable_intrs)
		CSR_WRITE_2(sc, RL_IMR, sc->rl_intrs);
	else
		CSR_WRITE_2(sc, RL_IMR, 0); 

	switch (imtype) {
	case RL_IMTYPE_NONE:
		re_disable_sim_im(sc);
		re_disable_hw_im(sc);
		break;

	case RL_IMTYPE_HW:
		KASSERT(sc->rl_flags & RL_FLAG_HWIM);
		re_disable_sim_im(sc);
		re_setup_hw_im(sc);
		break;

	case RL_IMTYPE_SIM:
		re_disable_hw_im(sc);
		re_setup_sim_im(sc);
		break;

	default:
		panic("%s: unknown imtype %d",
		      sc->sc_dev.dv_xname, imtype);
	}
}

#ifndef SMALL_KERNEL
int
re_wol(struct ifnet *ifp, int enable)
{
	struct rl_softc *sc = ifp->if_softc;
	u_int8_t val;

	if (enable) {
		if ((CSR_READ_1(sc, sc->rl_cfg1) & RL_CFG1_PME) == 0) {
			printf("%s: power management is disabled, "
			    "cannot do WOL\n", sc->sc_dev.dv_xname);
			return (ENOTSUP);
		}
		if ((CSR_READ_1(sc, sc->rl_cfg2) & RL_CFG2_AUXPWR) == 0)
			printf("%s: no auxiliary power, cannot do WOL from D3 "
			    "(power-off) state\n", sc->sc_dev.dv_xname);
	}

	re_iff(sc);

	/* Temporarily enable write to configuration registers. */
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_WRITECFG);

	/* Always disable all wake events except magic packet. */
	if (enable) {
		val = CSR_READ_1(sc, sc->rl_cfg5);
		val &= ~(RL_CFG5_WOL_UCAST | RL_CFG5_WOL_MCAST |
		    RL_CFG5_WOL_BCAST);
		CSR_WRITE_1(sc, sc->rl_cfg5, val);

		val = CSR_READ_1(sc, sc->rl_cfg3);
		val |= RL_CFG3_WOL_MAGIC;
		val &= ~RL_CFG3_WOL_LINK;
		CSR_WRITE_1(sc, sc->rl_cfg3, val);
	} else {
		val = CSR_READ_1(sc, sc->rl_cfg5);
		val &= ~(RL_CFG5_WOL_UCAST | RL_CFG5_WOL_MCAST |
		    RL_CFG5_WOL_BCAST);
		CSR_WRITE_1(sc, sc->rl_cfg5, val);

		val = CSR_READ_1(sc, sc->rl_cfg3);
		val &= ~(RL_CFG3_WOL_MAGIC | RL_CFG3_WOL_LINK);
		CSR_WRITE_1(sc, sc->rl_cfg3, val);
	}

	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);

	return (0);
}
#endif
@


1.201
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.200 2017/01/22 10:17:38 dlg Exp $	*/
a2075 3

	re_txeof(sc);
	re_rxeof(sc);
@


1.200
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.199 2017/01/04 01:47:32 dlg Exp $	*/
d164 1
a164 1
void	re_start(struct ifnet *);
d1008 1
a1008 1
	ifp->if_start = re_start;
d1779 1
a1779 1
re_start(struct ifnet *ifp)
d1781 1
d1789 1
a1789 1
		IFQ_PURGE(&ifp->if_snd);
d1801 1
a1801 1
			ifq_set_oactive(&ifp->if_snd);
d1805 1
a1805 1
		m = ifq_dequeue(&ifp->if_snd);
d1835 1
a1835 1
	ifq_serialize(&ifp->if_snd, &sc->rl_start);
@


1.199
log
@better handle empty or full rx rings.

currently re appears to end up spinning on landisk. the most obvious
cause of this would be an inability to add entries on the rx ring
when we run out of mbufs. cope with this by calling rxeof from the
isr when the FIFO_OVERFLOW status bit is set. rxeof in turn
unconditionally tries to fill the rx ring, even if it doesnt dequeue
any packets off the ring.

while here limit the number of entries that can go on the rx ring
to 1 less than the size of the ring. a full ring looks the same as
an empty ring (cos the producer and consumer are the same in both
cases), so avoid letting this happen.

ok deraadt@@ who hit problems on his landisk and tested this diff
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.198 2016/11/16 06:06:04 dlg Exp $	*/
a1445 2
		else
			ifp->if_opackets++;
@


1.198
log
@rework re_start and re_txeof to be more like other drivers.

the important change is to no longer account for packets and
descriptors separately, instead we just deal with available descriptors
on the ring.

this allows us to guarantee that oactive will only be set after
re_start has queued at least one packet, which in turn guarantees
that the chip will interrupt in the future and run re_txeof to clear
oactive.

without this change it was possible for a call of re_start to almost
fill the descriptor ring, followed by a second call that could fail
to post a packet because it had run out of descriptors and would
then set oactive. if re_txeof ran concurrently it could complete
all the previously posted packets without noticing that oactive had
been set and therefore needed to be cleared. in that situation
oactive would be set, but nothing would be set up to clear it
in the immediate future.

this fixes a lockup reported by haesbaert.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.197 2016/11/16 02:50:17 dlg Exp $	*/
d1216 2
a1217 1
	if_rxr_init(&sc->rl_ldata.rl_rx_ring, 2, sc->rl_ldata.rl_rx_desc_cnt);
d1524 2
a1525 1
		if (status & (sc->rl_rx_ack | RL_ISR_RX_ERR)) {
@


1.197
log
@allocate dmamaps for every descriptor in the tx ring.

previously there was a limit of 64 packets on the tx ring. soon we
will use as many descriptors as we want to fill the ring.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.196 2016/11/16 01:55:10 dlg Exp $	*/
d155 1
a155 1
int	re_encap(struct rl_softc *, struct mbuf *, struct rl_txq *, int *);
d1011 1
a1011 1
	IFQ_SET_MAXLEN(&ifp->if_snd, RL_TX_QLEN);
d1411 1
a1411 1
	struct ifnet	*ifp;
d1414 3
a1416 1
	int		idx, descidx, tx_free, freed = 0;
d1420 5
a1424 3
	for (idx = sc->rl_ldata.rl_txq_considx;
	    idx != sc->rl_ldata.rl_txq_prodidx; idx = RL_NEXT_TXQ(sc, idx)) {
		txq = &sc->rl_ldata.rl_txq[idx];
d1426 6
a1431 8
		descidx = txq->txq_descidx;
		RL_TXDESCSYNC(sc, descidx,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		txstat =
		    letoh32(sc->rl_ldata.rl_tx_list[descidx].rl_cmdstat);
		RL_TXDESCSYNC(sc, descidx, BUS_DMASYNC_PREREAD);
		KASSERT((txstat & RL_TDESC_CMD_EOF) != 0);
		if (txstat & RL_TDESC_CMD_OWN)
d1433 1
a1434 1
		freed += txq->txq_nsegs;
d1447 3
d1452 1
a1452 1
	if (freed == 0)
d1455 1
a1455 4
	tx_free = atomic_add_int_nv(&sc->rl_ldata.rl_tx_free, freed);
	KASSERT(tx_free <= sc->rl_ldata.rl_tx_desc_cnt);

	sc->rl_ldata.rl_txq_considx = idx;
d1466 1
a1466 1
	else if (tx_free < sc->rl_ldata.rl_tx_desc_cnt)
d1575 1
a1575 1
re_encap(struct rl_softc *sc, struct mbuf *m, struct rl_txq *txq, int *used)
d1577 1
d1579 1
a1579 2
	struct mbuf	*mp, mh;
	int		error, seg, nsegs, uidx, startidx, curidx, lastidx, pad;
d1602 2
d1638 1
d1655 1
a1655 1
		return (ENOMEM);
d1658 3
a1681 12
	if (*used + nsegs + 1 >= sc->rl_ldata.rl_tx_free) {
		error = ENOBUFS;
		goto fail_unload;
	}

	/*
	 * Make sure that the caches are synchronized before we
	 * ask the chip to start DMA for the packet data.
	 */
	bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
		BUS_DMASYNC_PREWRITE);

d1704 4
a1707 4
	curidx = startidx = sc->rl_ldata.rl_tx_nextfree;
	lastidx = -1;
	for (seg = 0; seg < map->dm_nsegs;
	    seg++, curidx = RL_NEXT_TX_DESC(sc, curidx)) {
d1709 2
a1710 17
		RL_TXDESCSYNC(sc, curidx,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		cmdstat = letoh32(d->rl_cmdstat);
		RL_TXDESCSYNC(sc, curidx, BUS_DMASYNC_PREREAD);
		if (cmdstat & RL_TDESC_STAT_OWN) {
			printf("%s: tried to map busy TX descriptor\n",
			    sc->sc_dev.dv_xname);
			for (; seg > 0; seg --) {
				uidx = (curidx + sc->rl_ldata.rl_tx_desc_cnt -
				    seg) % sc->rl_ldata.rl_tx_desc_cnt;
				sc->rl_ldata.rl_tx_list[uidx].rl_cmdstat = 0;
				RL_TXDESCSYNC(sc, uidx,
				    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
			}
			error = EBUSY;
			goto fail_unload;
		}
d1714 2
a1715 5
		cmdstat = csum_flags | map->dm_segs[seg].ds_len;
		if (seg == 0)
			cmdstat |= RL_TDESC_CMD_SOF;
		else
			cmdstat |= RL_TDESC_CMD_OWN;
d1718 1
a1718 4
		if (seg == nsegs - 1) {
			cmdstat |= RL_TDESC_CMD_EOF;
			lastidx = curidx;
		}
d1720 6
a1725 2
		RL_TXDESCSYNC(sc, curidx,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1727 1
d1730 3
d1738 1
d1741 1
d1743 3
a1745 2
		RL_TXDESCSYNC(sc, curidx,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
a1746 1
		curidx = RL_NEXT_TX_DESC(sc, curidx);
d1748 3
a1750 1
	KASSERT(lastidx != -1);
d1753 1
d1755 3
a1757 3
	sc->rl_ldata.rl_tx_list[startidx].rl_cmdstat |=
	    htole32(RL_TDESC_CMD_OWN);
	RL_TXDESCSYNC(sc, startidx, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
a1761 5
	txq->txq_nsegs = nsegs;

	sc->rl_ldata.rl_tx_nextfree = curidx;

	*used += nsegs;
d1763 1
a1763 6
	return (0);

fail_unload:
	bus_dmamap_unload(sc->sc_dmat, map);

	return (error);
d1783 3
a1785 1
	int		idx, used = 0, txq_free, error;
d1792 1
a1792 1
	txq_free = sc->rl_ldata.rl_txq_considx;
d1794 3
a1796 3
	if (txq_free <= idx)
		txq_free += RL_TX_QLEN;
	txq_free -= idx;
d1799 1
a1799 1
		if (txq_free <= 1) {
d1804 1
a1804 1
		m = ifq_deq_begin(&ifp->if_snd);
d1808 2
a1809 9
		error = re_encap(sc, m, &sc->rl_ldata.rl_txq[idx], &used);
		if (error == 0)
			ifq_deq_commit(&ifp->if_snd, m);
		else if (error == ENOBUFS) {
			ifq_deq_rollback(&ifp->if_snd, m);
			ifq_set_oactive(&ifp->if_snd);
			break;
		} else {
			ifq_deq_commit(&ifp->if_snd, m);
a1810 1
			ifp->if_oerrors++;
d1818 9
a1826 2
		idx = RL_NEXT_TXQ(sc, idx);
		txq_free--;
d1829 1
a1829 1
	if (used == 0)
d1831 1
a1831 1
	
a1832 3
	atomic_sub_int(&sc->rl_ldata.rl_tx_free, used);
	KASSERT(sc->rl_ldata.rl_tx_free >= 0);

a1833 1

@


1.196
log
@dont restrict the number of tx descriptors to what can fit on a cpu page.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.195 2016/11/16 01:27:45 dlg Exp $	*/
d940 1
a940 1
	for (i = 0; i < RL_TX_QLEN; i++) {
d1099 1
a1099 1
	for (i = 0; i < RL_TX_QLEN; i++) {
d1191 1
a1191 1
	for (i = 0; i < RL_TX_QLEN; i++) {
d2181 1
a2181 1
	for (i = 0; i < RL_TX_QLEN; i++) {
@


1.195
log
@move toward having the a tx packet descriptor per tx ring entry.

previously you could have 64 packets on a ring with up to 1024
descriptors. this mismatch makes the accounting for free space
complicated and allows for a data race with OACTIVE being set.
it will also let us push more packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.194 2016/11/16 01:15:37 dlg Exp $	*/
a901 6

	if (sc->rl_ldata.rl_tx_desc_cnt >
	    PAGE_SIZE / sizeof(struct rl_desc)) {
		sc->rl_ldata.rl_tx_desc_cnt =
		    PAGE_SIZE / sizeof(struct rl_desc);
	}
@


1.194
log
@serialise posts to the txstart register.

without this it is possible for re_txeof to let the chip look at
and complete tx descriptors that re_start has written to the ring
but not accounted for in the software producer index. in this
situation no future interrupts may be generated for packets on the
ring, and tx will stall.

the serialisation is implemented by only doing the writes from tasks
via ifq_serialize.

this is part of a bigger diff that fixes lockups reported by haesbaert.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.193 2016/08/10 14:27:17 deraadt Exp $	*/
a661 1
	int		ntxsegs;
d879 1
a879 1
		ntxsegs = RL_8139_NTXSEGS;
d885 1
a885 1
		ntxsegs = RL_8169_NTXSEGS;
d948 3
a950 2
		    RL_JUMBO_FRAMELEN, ntxsegs, RL_JUMBO_FRAMELEN,
		    0, 0, &sc->rl_ldata.rl_txq[i].txq_dmamap);
@


1.193
log
@armish handled some early-gen arm machines, which required tons of
workarounds.  Some of them will soon stand in the way of armv7.
Off to the attic you go.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.192 2016/04/20 12:15:24 sthen Exp $	*/
d165 1
d1045 1
d1471 1
a1471 1
		CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START);
d1794 8
d1865 1
a1865 1
	CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START);
@


1.192
log
@If RTL8111E on PC Engines APU is detected, configure NIC LEDs to display link.
Normally this would be setup in the vendor-programmed eeprom, but in this case
it hasn't been done and the rather unfortunate default results in *only* a
normally-off light for network activity, nothing for ethernet link, so it's
too easy to mistake the machine for being powered down. hw.vendor/hw.machine
idea from naddy@@, testing jasper@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.191 2016/04/13 10:49:26 mpi Exp $	*/
a646 12
#ifdef __armish__ 
/*
 * Thecus N2100 doesn't store the full mac address in eeprom
 * so we read the old mac address from the device before the reset
 * in hopes that the proper mac address is already there.
 */
union {
	u_int32_t eaddr_word[2];
	u_char eaddr[ETHER_ADDR_LEN];
} boot_eaddr;
int boot_eaddr_valid;
#endif /* __armish__ */
a867 24

#ifdef __armish__
		/*
		 * On the Thecus N2100, the MAC address in the EEPROM is
		 * always 00:14:fd:10:00:00.  The proper MAC address is
		 * stored in flash.  Fortunately RedBoot configures the
		 * proper MAC address (for the first onboard interface)
		 * which we can read from the IDR.
		 */
		if (eaddr[0] == 0x00 && eaddr[1] == 0x14 &&
		    eaddr[2] == 0xfd && eaddr[3] == 0x10 &&
		    eaddr[4] == 0x00 && eaddr[5] == 0x00) {
			if (boot_eaddr_valid == 0) {
				boot_eaddr.eaddr_word[1] =
				    letoh32(CSR_READ_4(sc, RL_IDR4));
				boot_eaddr.eaddr_word[0] =
				    letoh32(CSR_READ_4(sc, RL_IDR0));
				boot_eaddr_valid = 1;
			}

			bcopy(boot_eaddr.eaddr, eaddr, sizeof(eaddr));
			eaddr[5] += sc->sc_dev.dv_unit;
		}
#endif
@


1.191
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.190 2016/03/19 11:34:22 mpi Exp $	*/
d201 2
d1945 15
@


1.190
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.189 2016/01/04 05:41:22 dlg Exp $	*/
a1050 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.189
log
@mark the driver MPSAFE. most of this is cleaning up the oactive handling.

if there's lingering bugs we'll deal with them in tree.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.187 2015/11/25 03:09:58 dlg Exp $	*/
d2265 1
a2265 1
		u_int32_t ticks;
d2272 2
a2273 2
		ticks = (sc->rl_sim_time * sc->rl_bus_speed * 8) / 5;
		CSR_WRITE_4(sc, RL_TIMERINT_8169, ticks);
@


1.188
log
@Rework re_start and re_txeof to only check the producer/consumer ring
positions when deciding how much work to do, and to adjust rl_tx_free with
atomic operations; split the flag that indicates whether we're using
timer based interrupts or not out into a separate field so it can be
changed from interrupt context without needing a lock; take the kernel
lock when calling re_init and re_start from interrupt context; add an
interrupt barrier in re_stop; and finally mark the interrupt handler
as mpsafe.

started by Jim Smith a while ago, mostly finished up at n2k15
tested by dlg@@, chris@@ and Dimitris Papastamos on various hardware
ok dlg@@
@
text
@d1045 1
d1501 3
a1503 1
	if (tx_free < sc->rl_ldata.rl_tx_desc_cnt)
d1505 1
a1505 2
	else {
		ifq_clr_oactive(&ifp->if_snd);
a1506 1
	}
d1593 1
a1593 1
				tx = re_txeof(sc);
a1605 6
	if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
		KERNEL_LOCK();
		re_start(ifp);
		KERNEL_UNLOCK();
	}

d1689 1
a1689 1
		return (ENOBUFS);
d1713 2
a1714 2
	if (sc->rl_ldata.rl_tx_free - (*used + nsegs) <= 1) {
		error = EFBIG;
d1838 2
a1839 3
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;
	if ((sc->rl_flags & RL_FLAG_LINK) == 0)
d1841 1
d1845 1
a1845 1
	if (idx >= txq_free)
d1849 6
a1854 1
	while (txq_free > 1) {
d1860 3
a1862 1
		if (error != 0 && error != ENOBUFS) {
d1866 1
a1866 1
		} else if (error != 0) {
a1872 2
		ifq_deq_commit(&ifp->if_snd, m);

a1884 1
	sc->rl_ldata.rl_txq_prodidx = idx;
d1888 2
a2115 1
	ifp->if_oerrors++;
a2142 1
	ifq_clr_oactive(&ifp->if_snd);
d2185 6
a2194 4

	intr_barrier(sc->sc_ih);

	mii_down(&sc->sc_mii);
@


1.187
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.186 2015/11/24 17:11:39 mpi Exp $	*/
d123 1
d155 1
a155 1
int	re_encap(struct rl_softc *, struct mbuf *, int *);
d1452 1
a1452 1
	int		idx, descidx, tx = 0;
d1456 2
a1457 1
	for (idx = sc->rl_ldata.rl_txq_considx;; idx = RL_NEXT_TXQ(sc, idx)) {
a1459 5
		if (txq->txq_mbuf == NULL) {
			KASSERT(idx == sc->rl_ldata.rl_txq_prodidx);
			break;
		}

d1470 1
a1470 3
		tx = 1;
		sc->rl_ldata.rl_tx_free += txq->txq_nsegs;
		KASSERT(sc->rl_ldata.rl_tx_free <= sc->rl_ldata.rl_tx_desc_cnt);
d1485 6
a1492 2
	ifq_clr_oactive(&ifp->if_snd);

d1500 1
a1500 1
	if (sc->rl_ldata.rl_tx_free < sc->rl_ldata.rl_tx_desc_cnt)
d1502 2
a1503 1
	else
d1505 1
d1507 1
a1507 1
	return (tx);
d1570 1
d1572 1
d1578 1
a1578 1
		if ((sc->rl_flags & RL_FLAG_TIMERINTR)) {
d1605 5
a1609 1
	re_start(ifp);
d1617 1
a1617 1
re_encap(struct rl_softc *sc, struct mbuf *m, int *idx)
a1625 1
	struct rl_txq	*txq;
a1677 1
	txq = &sc->rl_ldata.rl_txq[*idx];
d1718 1
a1718 1
	if (sc->rl_ldata.rl_tx_free - nsegs <= 1) {
a1819 1
	sc->rl_ldata.rl_tx_free -= nsegs;
d1822 1
a1822 1
	*idx = RL_NEXT_TXQ(sc, *idx);
d1841 1
a1841 1
	int		idx, queued = 0, error;
a1846 2
	if (IFQ_IS_EMPTY(&ifp->if_snd))
		return;
d1848 1
d1850 3
d1854 1
a1854 1
	for (;;) {
d1859 1
a1859 8
		if (sc->rl_ldata.rl_txq[idx].txq_mbuf != NULL) {
			KASSERT(idx == sc->rl_ldata.rl_txq_considx);
			ifq_deq_rollback(&ifp->if_snd, m);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		error = re_encap(sc, m, &idx);
a1870 1
		/* now we are committed to transmit the packet */
a1871 1
		queued++;
a1873 4
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
d1877 2
d1881 1
a1881 1
	if (queued == 0)
d1883 2
a1884 1

d1886 2
a1889 5

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
d2138 2
a2139 1
	sc->rl_flags &= ~(RL_FLAG_LINK|RL_FLAG_TIMERINTR);
a2144 2
	mii_down(&sc->sc_mii);

d2191 4
d2275 1
a2275 1
	sc->rl_flags |= RL_FLAG_TIMERINTR;
d2285 1
a2285 1
	sc->rl_flags &= ~RL_FLAG_TIMERINTR;
@


1.186
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.185 2015/11/24 15:43:15 mpi Exp $	*/
d1492 1
a1492 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1839 1
a1839 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1856 1
a1856 1
			ifp->if_flags |= IFF_OACTIVE;
d1863 1
a1863 1
			ifp->if_flags |= IFF_OACTIVE;
d2025 1
a2025 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2148 2
a2149 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.185
log
@You need <netinet/ip.h> if you use "struct ip" for hw checksum.

You never need <netinet/ip_var.h> nor <netinet/in_systm.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.184 2015/11/20 03:35:22 dlg Exp $	*/
a126 1
#include <net/if_dl.h>
@


1.184
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.183 2015/11/14 17:54:57 mpi Exp $	*/
a131 1
#include <netinet/ip_var.h>
@


1.183
log
@Do not include <net/if_vlan_var.h> when it's not necessary.

Because of the VLAN hacks in mpw(4) this file still contains the definition
of "struct ifvlan" which depends on <sys/refcnt.h> which in turns pull
<sys/atomic.h>...
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.182 2015/11/02 00:08:50 dlg Exp $	*/
d1851 1
a1851 1
		IFQ_POLL(&ifp->if_snd, m);
d1857 1
d1864 1
d1868 1
a1868 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
d1875 1
a1875 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.182
log
@later variants of these chips can support bigger rx and tx rings. this
diff expands them so devices that need more packets per interrupt can
use them.

this is all from brad@@
tested by jim smith and benjamin perrault on APUs
tested by me on 8139s (which dont support bit rings) on landisk, and
8169s
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.181 2015/10/25 12:48:46 mpi Exp $	*/
a133 5

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif
@


1.181
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.180 2015/09/04 07:05:44 jsg Exp $	*/
d677 1
d912 1
a912 1
	 * and TX descriptor count.
d917 3
a919 1
		sc->rl_ldata.rl_tx_desc_cnt = RL_TX_DESC_CNT_8139;
d923 3
a925 1
		sc->rl_ldata.rl_tx_desc_cnt = RL_TX_DESC_CNT_8169;
d988 1
a988 1
		    RL_JUMBO_FRAMELEN, RL_NTXSEGS, RL_JUMBO_FRAMELEN,
d998 1
a998 1
	if ((error = bus_dmamem_alloc(sc->sc_dmat, RL_RX_DMAMEM_SZ,
d1009 1
a1009 1
		    sc->rl_ldata.rl_rx_listnseg, RL_RX_DMAMEM_SZ,
d1018 2
a1019 2
	if ((error = bus_dmamap_create(sc->sc_dmat, RL_RX_DMAMEM_SZ, 1,
		    RL_RX_DMAMEM_SZ, 0, 0,
d1028 1
a1028 1
		    RL_RX_DMAMEM_SZ, NULL, BUS_DMA_NOWAIT)) != 0) {
d1035 1
a1035 1
	for (i = 0; i < RL_RX_DESC_CNT; i++) {
d1124 1
a1124 1
	for (i = 0; i < RL_RX_DESC_CNT; i++) {
d1136 1
a1136 1
	    (caddr_t)sc->rl_ldata.rl_rx_list, RL_RX_DMAMEM_SZ);
d1214 1
a1214 1
	if (idx == (RL_RX_DESC_CNT - 1))
d1245 1
a1245 1
	sc->rl_ldata.rl_tx_free = RL_TX_DESC_CNT(sc);
d1254 1
a1254 1
	bzero(sc->rl_ldata.rl_rx_list, RL_RX_LIST_SZ);
d1260 1
a1260 1
	if_rxr_init(&sc->rl_ldata.rl_rx_ring, 2, RL_RX_DESC_CNT);
d1271 2
a1272 1
	for (slots = if_rxr_get(&sc->rl_ldata.rl_rx_ring, RL_RX_DESC_CNT);
d1482 1
a1482 1
		KASSERT(sc->rl_ldata.rl_tx_free <= RL_TX_DESC_CNT(sc));
d1508 1
a1508 1
	if (sc->rl_ldata.rl_tx_free < RL_TX_DESC_CNT(sc))
d1767 2
a1768 2
				uidx = (curidx + RL_TX_DESC_CNT(sc) - seg) %
				    RL_TX_DESC_CNT(sc);
d1784 1
a1784 1
		if (curidx == (RL_TX_DESC_CNT(sc) - 1))
d1801 1
a1801 1
		if (curidx == (RL_TX_DESC_CNT(sc) - 1))
d2214 1
a2214 1
	for (i = 0; i < RL_RX_DESC_CNT; i++) {
@


1.180
log
@add support for RTL8168H

tedu tested an almost identical diff from brad that set the same flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.179 2015/06/24 09:40:54 mpi Exp $	*/
a2068 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a2077 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.179
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.178 2015/04/13 20:45:49 sthen Exp $	*/
d248 1
d775 2
a777 7
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |
		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |
		    RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 | RL_FLAG_CMDSTOP_WAIT_TXQ |
		    RL_FLAG_WOL_MANLINK | RL_FLAG_EARLYOFFV2 | RL_FLAG_RXDV_GATED;
		sc->rl_max_mtu = RL_JUMBO_MTU_9K;
		break;
	case RL_HWREV_8168GU:
@


1.178
log
@Initialize RX/TX on re(4) slightly later; it appears that newer chips
don't setup DMA correctly until more configuration has been done -
enabling RX too soon causes DMA to bad places. KVM corruption problems
reported by Adam Wolk on Lenovo G50-70 (RTL8111GU).

Diff derived by Brad from FreeBSD commit; see bz# 197535 and 193743, inspired by
https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=d6e572911a4cb2b9fcd1c26a38d5317a3971f2fd

Tested on the following by Brad, Adam Wolk, box963 at gmail, Jim Smith

re0 at pci4 dev 0 function 0 "Realtek 8168" rev 0x03: RTL8168D/8111D (0x2800), apic 2 int 16, address 00:0a:cd:1a:86:04
re0 at pci2 dev 0 function 0 "Realtek 8168" rev 0x0c: RTL8168G/8111G (0x4c00), msi, address 80:ee:73:76:8e:8a
re0 at pci0 dev 3 function 0 "Realtek 8169" rev 0x10: RTL8110S (0x0400), ivec 0x78c, address 00:22:3f:ee:fa:25
re0 at pci1 dev 0 function 0 "Realtek 8168" rev 0x06: RTL8168E/8111E (0x2c00), msi, address 00:0d:b9:31:2e:88
re0 at pci1 dev 0 function 0 "Realtek 8168" rev 0x10: RTL8168GU/8111GU (0x5080), msi, address 68:f7:28:18:35:8e

ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.177 2015/03/20 12:04:09 dlg Exp $	*/
a1399 2

		ifp->if_ipackets++;
@


1.177
log
@add support for jumbos on re(4).

this uses hints from the freebsd driver, but the implementation
differs.

freebsd manages two lists of rx descriptors. one for "normal" packets
and the other for jumbos. this continues to use a single list and
uses a per softc variable and MCLGETI to always allocate what the
chip is capable and uses it unconditionally.

other than that, we just need to enable some bits in some registers
to be able to do jumbos.

this relies on the previous commit to properly deal with checksum
offload for packets of different sizes.

from jim smith
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.176 2015/03/20 11:55:10 dlg Exp $	*/
a1983 5
	 * Enable transmit and receive.
	 */
	CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);

	/*
d1997 5
a2012 4
#ifdef notdef
	/* Enable receiver and transmitter. */
	CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);
#endif
@


1.176
log
@some re(4) chips can do jumbos, but none of them can checksum jumbo
packets.

rather than disable cksum offload for all packets, this sets things
up so we still advertise offload to the stack, but if the driver
gets a large packet it does the checksum itself in software.

small (normal sized) packets still get offloaded like now. if you're
doing a jumbo you'll be doing the cksum in software, but will
hopefully win overall cos you'll be doing a 6th of the work cos
you're doing more data in every packet.

diff from jim smith
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.175 2015/02/09 03:09:57 dlg Exp $	*/
d176 2
d215 4
d1035 4
a1038 2
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, 0, &sc->rl_ldata.rl_rxsoft[i].rxs_dmamap);
d1053 1
a1053 2
	if ((sc->rl_flags & RL_FLAG_JUMBOV2) == 0)
		ifp->if_hardmtu = sc->rl_max_mtu;
d1173 1
a1173 1
	m = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
d1182 1
a1182 1
	m->m_len = m->m_pkthdr.len = RE_RX_DESC_BUFLEN;
d1321 6
a1326 2
		if (!(rxstat & RL_RDESC_STAT_EOF)) {
			m->m_len = RE_RX_DESC_BUFLEN;
d1360 3
a1362 2
		if (rxstat & RL_RDESC_STAT_RXERRSUM && !(total_len > 8191 &&
		    (rxstat & RL_RDESC_STAT_ERRS) == RL_RDESC_STAT_GIANT)) {
d1376 1
a1376 1
			m->m_len = total_len % RE_RX_DESC_BUFLEN;
d1378 1
a1378 1
				m->m_len = RE_RX_DESC_BUFLEN;
d1957 3
d2023 2
a2024 1
		if (sc->rl_flags & RL_FLAG_PCIE)
d2109 1
a2109 1
		    NULL, MCLBYTES, &sc->rl_ldata.rl_rx_ring);
d2327 23
@


1.175
log
@tweak the new if_input function so it takes an mbuf_list instead
of a single mbuf. this forces us to batch work between the hardware
rx handlers and the stack.

this includes a converstion of bge from ether_input to if_input.

ok claudio@@ pelikan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.174 2015/02/08 06:55:28 mpi Exp $	*/
d131 2
d199 2
d1608 1
d1610 2
d1628 21
@


1.174
log
@Convert to if_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.173 2015/01/21 10:00:42 brad Exp $	*/
d1275 1
d1425 1
a1425 1
		if_input(ifp, m);
d1430 2
@


1.173
log
@Add a comment above the autopad checking.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.172 2015/01/21 09:52:55 brad Exp $	*/
a1384 1
		m->m_pkthdr.rcvif = ifp;
d1424 1
a1424 5
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
		ether_input_mbuf(ifp, m);
@


1.172
log
@Use the RL_FLAG_AUTOPAD flag when trying to determine when
to pad short frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.171 2015/01/20 04:46:11 brad Exp $	*/
d1663 12
@


1.171
log
@Fix size of the bcopy when extracting the MAC address.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.170 2015/01/20 04:33:06 brad Exp $	*/
d1663 3
a1665 3
	if ((sc->rl_flags & RL_FLAG_DESCV2) == 0 &&
	    m->m_pkthdr.len <= RL_IP4CSUMTX_PADLEN &&
	    (csum_flags & RL_TDESC_CMD_IPCSUM) != 0) {
@


1.170
log
@Remove use of the link change interrupt handling, not all controllers
support this interrupt. Link state changes are noticed via the PHY
status change callback or via the timeout for re_tick().

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.169 2015/01/20 04:23:33 brad Exp $	*/
d876 1
a876 1
		bcopy(as, eaddr, sizeof(eaddr));
@


1.169
log
@Some fixes for handling link state changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.168 2015/01/15 23:06:08 brad Exp $	*/
a1562 6
			claimed = 1;
		}

		if (status & RL_ISR_LINKCHG) {
			timeout_del(&sc->timer_handle);
			re_tick(sc);
@


1.168
log
@Remove a variable no longer used in re_tick().

From Fabian Raetz <fabian dot raetz at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.167 2015/01/08 00:49:18 brad Exp $	*/
d1601 1
a1601 2
	if (tx)
		re_start(ifp);
a1981 2
	mii_mediachg(&sc->sc_mii);

d1991 1
@


1.167
log
@Use the correct config registers for the RTL8139 family. Unlike the RTL8169
and RTL8168 family, the RTL8139 has different register map for config registers.

From FreeBSD

WoL bits reviewed and tested by stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.166 2015/01/04 07:14:41 brad Exp $	*/
a1506 1
	struct ifnet	*ifp;
a1508 1
	ifp = &sc->sc_arpcom.ac_if;
@


1.166
log
@Fix error handling for re_encap() within re_start() and some tidying up.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.165 2014/12/22 02:28:51 tedu Exp $	*/
d802 16
d836 1
a836 1
		cfg2 = CSR_READ_1(sc, RL_CFG2);
d1987 2
a1988 1
	CSR_WRITE_1(sc, RL_CFG1, CSR_READ_1(sc, RL_CFG1) | RL_CFG1_DRVLOAD);
a2322 1
	int i;
a2323 12
	struct re_wolcfg {
		u_int8_t	enable;
		u_int8_t	reg;
		u_int8_t	bit;
	} re_wolcfg[] = {
		/* Always disable all wake events expect magic packet. */
		{ 0,	RL_CFG5,	RL_CFG5_WOL_UCAST },
		{ 0,	RL_CFG5,	RL_CFG5_WOL_MCAST },
		{ 0,	RL_CFG5,	RL_CFG5_WOL_BCAST },
		{ 1,	RL_CFG3,	RL_CFG3_WOL_MAGIC },
		{ 0,	RL_CFG3,	RL_CFG3_WOL_LINK }
	};
d2326 1
a2326 1
		if ((CSR_READ_1(sc, RL_CFG1) & RL_CFG1_PME) == 0) {
d2331 1
a2331 1
		if ((CSR_READ_1(sc, RL_CFG2) & RL_CFG2_AUXPWR) == 0)
d2341 20
a2360 7
	for (i = 0; i < nitems(re_wolcfg); i++) {
		val = CSR_READ_1(sc, re_wolcfg[i].reg);
		if (enable && re_wolcfg[i].enable)
			val |= re_wolcfg[i].bit;
		else
			val &= ~re_wolcfg[i].bit;
		CSR_WRITE_1(sc, re_wolcfg[i].reg, val);
@


1.165
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.164 2014/12/19 04:53:58 brad Exp $	*/
d1587 1
a1587 1
	if (tx && !IFQ_IS_EMPTY(&ifp->if_snd))
d1644 3
a1646 3
		if ((error = m_defrag(m, M_DONTWAIT)) == 0 &&
		    (error = bus_dmamap_load_mbuf(sc->sc_dmat, map, m,
		    BUS_DMA_WRITE|BUS_DMA_NOWAIT)) == 0)
d1651 1
a1651 1
		return (error);
d1716 1
a1716 1
			error = ENOBUFS;
d1785 3
a1787 4
	struct rl_softc	*sc;
	int		idx, queued = 0;

	sc = ifp->if_softc;
d1789 1
a1789 1
	if (ifp->if_flags & IFF_OACTIVE)
d1793 2
d1797 1
a1798 3
		struct mbuf *m;
		int error;

d1810 4
a1813 2
		if (error == EFBIG &&
		    sc->rl_ldata.rl_tx_free == RL_TX_DESC_CNT(sc)) {
a1818 4
		if (error) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}
d1820 1
@


1.164
log
@Make use of m_defrag() in re_encap().
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.163 2014/11/24 10:33:37 brad Exp $	*/
a129 1
#ifdef INET
a131 1
#endif
a2029 1
#ifdef INET
a2031 1
#endif /* INET */
@


1.163
log
@rxr ioctl handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.162 2014/11/24 02:03:37 brad Exp $	*/
d1638 1
d1641 12
a1652 4
	if (error) {
		/* XXX try to defrag if EFBIG? */
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
@


1.162
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.161 2014/11/23 10:03:49 brad Exp $	*/
d2043 4
@


1.161
log
@Move link state handling into re_miibus_statchg().

From FreeBSD

Tested with 8168D / 8168G.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.160 2014/11/19 02:37:41 brad Exp $	*/
d36 1
a36 1
 * RealTek 8139C+/8169/8169S/8110S PCI NIC driver
d44 1
a44 1
 * This driver is designed to support RealTek's next generation of
d99 1
a99 1
 * part designed to be pin-compatible with the RealTek 8100 10/100 chip.
d553 1
a553 1
	 * RealTek controllers do not provide an interface to
d607 1
a607 1
	 * For some unfathomable reason, RealTek decided to reverse
d1313 1
a1313 1
		 * length bit, RealTek took out the 'frame alignment
@


1.160
log
@Add support for stopping the operation of the chipset within re_stop()
for newer generations of chipsets.

From FreeBSD

Tested with 8169, 8168C, 8168D, 8168G and by stsp@@ with WOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.159 2014/10/24 23:30:05 brad Exp $	*/
d527 30
d1502 4
a1505 11
	if (sc->rl_flags & RL_FLAG_LINK) {
		if (!(mii->mii_media_status & IFM_ACTIVE))
			sc->rl_flags &= ~RL_FLAG_LINK;
	} else {
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
			sc->rl_flags |= RL_FLAG_LINK;
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
				re_start(ifp);
		}
	}
@


1.159
log
@Always put controller into known state before device intialization.

From FreeBSD

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.158 2014/10/08 22:52:08 brad Exp $	*/
d2073 38
a2110 1
	CSR_WRITE_1(sc, RL_COMMAND, 0x00);
d2301 2
@


1.158
log
@Restrict what RL_MAXRXPKTLEN is being set to for any of the PCIe chipsets.
The driver currently doesn't implement jumbo frames for the newer chipsets
and it doesn't make sense allowing for a jumbo frame with a Fast Ethernet
chipset either. In theory its possible to do bad things with the driver
as is according to the FreeBSD/Linux drivers under the right conditions.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.157 2014/09/21 16:52:11 jsg Exp $	*/
a1060 1
	re_reset(sc);
a1526 1
			re_reset(sc);
d1837 3
@


1.157
log
@add a missing break statement in the RL_HWREV_8168E_VL case
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.156 2014/09/06 04:46:58 brad Exp $	*/
d1933 6
a1938 2
	if (sc->sc_hwrev != RL_HWREV_8139CPLUS)
		CSR_WRITE_2(sc, RL_MAXRXPKTLEN, 16383);
@


1.156
log
@Various changes to the re(4) feature flags..

Changed RL_FLAG_MACLDPS to RL_FLAG_MACRESET.
Removed RL_FLAG_INVMAR and RL_FLAG_NOJUMBO.
Added RL_FLAG_FASTETHER, RL_FLAG_CMDSTOP_WAIT_TXQ, RL_FLAG_JUMBOV2, RL_FLAG_WOL_MANLINK,
      RL_FLAG_WAIT_TXPOLL, RL_FLAG_WOLRXENB.

Also set in the softc the maximum MTU for the various generations of chips.

Input from and Ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.155 2014/07/22 13:12:12 mpi Exp $	*/
d723 1
@


1.155
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.154 2014/07/08 05:35:18 dlg Exp $	*/
d124 2
d147 1
a147 2
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
d582 1
a582 1
	if (sc->rl_flags & RL_FLAG_INVMAR) {
d608 1
a608 1
	if (sc->rl_flags & RL_FLAG_MACLDPS)
d643 2
a644 1
		sc->rl_flags |= RL_FLAG_NOJUMBO | RL_FLAG_AUTOPAD;
d649 2
a650 2
		sc->rl_flags |= RL_FLAG_NOJUMBO | RL_FLAG_INVMAR |
		    RL_FLAG_PHYWAKE;
d658 4
a661 3
		sc->rl_flags |= RL_FLAG_NOJUMBO | RL_FLAG_INVMAR |
		    RL_FLAG_PHYWAKE | RL_FLAG_PAR | RL_FLAG_DESCV2 |
		    RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD;
a663 1
	case RL_HWREV_8402:
d667 11
a677 4
		sc->rl_flags |= RL_FLAG_INVMAR | RL_FLAG_PHYWAKE |
		    RL_FLAG_PHYWAKE_PM | RL_FLAG_PAR | RL_FLAG_DESCV2 |
		    RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD |
		    RL_FLAG_NOJUMBO;
d681 2
d684 2
a685 2
		sc->rl_flags |= RL_FLAG_INVMAR | RL_FLAG_PHYWAKE |
		    RL_FLAG_MACSTAT | RL_FLAG_HWIM;
d692 12
d705 4
a708 14
		sc->rl_flags |= RL_FLAG_INVMAR | RL_FLAG_PHYWAKE |
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |
		    RL_FLAG_HWIM | RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD;
		/*
		 * These controllers support jumbo frame but it seems
		 * that enabling it requires touching additional magic
		 * registers. Depending on MAC revisions some
		 * controllers need to disable checksum offload. So
		 * disable jumbo frame until I have better idea what
		 * it really requires to make it support.
		 * RTL8168C/CP : supports up to 6KB jumbo frame.
		 * RTL8111C/CP : supports up to 9KB jumbo frame.
		 */
		sc->rl_flags |= RL_FLAG_NOJUMBO;
a709 1
	case RL_HWREV_8168D:
d711 5
a715 4
		sc->rl_flags |= RL_FLAG_INVMAR | RL_FLAG_PHYWAKE |
		    RL_FLAG_PHYWAKE_PM | RL_FLAG_PAR | RL_FLAG_DESCV2 |
		    RL_FLAG_MACSTAT | RL_FLAG_HWIM | RL_FLAG_CMDSTOP |
		    RL_FLAG_AUTOPAD | RL_FLAG_NOJUMBO;
d718 5
d727 5
a731 3
		sc->rl_flags |= RL_FLAG_INVMAR | RL_FLAG_PHYWAKE |
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |
		    RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD | RL_FLAG_NOJUMBO;
d736 6
d743 12
a754 3
		sc->rl_flags |= RL_FLAG_INVMAR | RL_FLAG_PHYWAKE |
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |
		    RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD | RL_FLAG_NOJUMBO |
d766 2
a767 1
		sc->rl_flags |= RL_FLAG_MACLDPS;
d996 2
a997 2
	if ((sc->rl_flags & RL_FLAG_NOJUMBO) == 0)
		ifp->if_hardmtu = RL_JUMBO_MTU;
@


1.154
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.153 2014/04/23 03:37:29 jsg Exp $	*/
a129 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.153
log
@rename some hardware revisions to match FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.152 2014/04/23 03:20:55 jsg Exp $	*/
a966 2
	m_clsetwms(ifp, MCLBYTES, 2, RL_RX_DESC_CNT);

d1084 1
a1084 1
	m = MCLGETI(NULL, M_DONTWAIT, &sc->sc_arpcom.ac_if, MCLBYTES);
a1133 1
	sc->rl_ldata.rl_rx_cnt++;
a1167 1
	sc->rl_ldata.rl_rx_cnt = 0;
d1170 1
d1179 4
a1182 1
	while (sc->rl_ldata.rl_rx_cnt < RL_RX_DESC_CNT) {
d1186 1
d1206 2
a1207 1
	for (i = sc->rl_ldata.rl_rx_considx; sc->rl_ldata.rl_rx_cnt > 0;
d1221 1
a1221 1
		sc->rl_ldata.rl_rx_cnt--;
@


1.152
log
@add support for RTL8168EP
From Edward O'Callaghan via FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.151 2014/04/23 02:58:06 jsg Exp $	*/
d217 1
a217 1
	{ RL_HWREV_8100E_SPIN1,	"RTL8100E 1" },
d226 1
d232 3
a234 3
	{ RL_HWREV_8168_SPIN1,	"RTL8168 1" },
	{ RL_HWREV_8168_SPIN2,	"RTL8168 2" },
	{ RL_HWREV_8168_SPIN3,	"RTL8168 3" },
a239 1
	{ RL_HWREV_8168G_SPIN4,	"RTL8168G/8111G" },
d646 1
a646 1
	case RL_HWREV_8100E_SPIN1:
d672 3
a674 3
	case RL_HWREV_8168_SPIN1:
	case RL_HWREV_8168_SPIN2:
	case RL_HWREV_8168_SPIN3:
d717 1
a717 1
	case RL_HWREV_8168G_SPIN4:
@


1.151
log
@While we always mask the revision with 0x7c800000 linux uses a table
that masks with either 0x7c800000 or 0x7cf00000 depending on the chip.

Some of the hardware revisions I previously added can't be matched with
the current mask, these are already handled by other revision defines
so remove them.

When masking the revision defines with 0x7c800000:

RL_HWREV_8106E_SPIN1 is the same as RL_HWREV_8106E
RL_HWREV_8168G_SPIN1 is the same as RL_HWREV_8168G
RL_HWREV_8168G_SPIN2 is the same as RL_HWREV_8168GU
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.150 2014/04/23 02:39:28 jsg Exp $	*/
d247 1
d715 1
@


1.150
log
@Add support for RTL8168GU
from Rafael Neves
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.149 2014/03/13 13:11:30 brad Exp $	*/
a222 1
	{ RL_HWREV_8106E_SPIN1,	"RTL8106E" },
a238 2
	{ RL_HWREV_8168G_SPIN1,	"RTL8168G/8111G" },
	{ RL_HWREV_8168G_SPIN2,	"RTL8168G/8111G" },
a665 1
	case RL_HWREV_8106E_SPIN1:
a714 1
	case RL_HWREV_8168G_SPIN1:
a716 6
		sc->rl_flags |= RL_FLAG_INVMAR | RL_FLAG_PHYWAKE |
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |
		    RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD | RL_FLAG_NOJUMBO |
		    RL_FLAG_EARLYOFFV2 | RL_FLAG_RXDV_GATED;
		break;
	case RL_HWREV_8168G_SPIN2:
@


1.149
log
@Missed removing some bits with rev 1.147.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.148 2014/03/08 22:37:32 brad Exp $	*/
d243 1
d721 1
@


1.148
log
@Add the RX earlyoff support for older chips (8168{E-VL,EP, F}) and RXDV GATED
bits for the 8168G controller. This fixes operation of the 8168G controllers.
This makes reception of packets work with the 8168G controllers in the Shuttle
DS47 and other systems.

From FreeBSD, based on the Realtek Linux driver.

ok sthen@@ giovani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.147 2013/12/31 21:09:34 brad Exp $	*/
d1872 1
a1872 9
	if (sc->rl_testmode) {
		if (sc->sc_hwrev == RL_HWREV_8139CPLUS)
			CSR_WRITE_4(sc, RL_TXCFG,
			    RL_TXCFG_CONFIG|RL_LOOPTEST_ON_CPLUS);
		else
			CSR_WRITE_4(sc, RL_TXCFG,
			    RL_TXCFG_CONFIG|RL_LOOPTEST_ON);
	} else
		CSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);
d1889 1
a1889 4
	if (sc->rl_testmode)
		CSR_WRITE_2(sc, RL_IMR, 0);
	else
		re_setup_intr(sc, 1, sc->rl_imtype);
a1904 5

	if (sc->rl_testmode) {
		splx(s);
		return (0);
	}
@


1.147
log
@tedu the diagnostic code to detect the presence of the defective Xterasys XN-152
32-bit PCI NIC in a 64-bit PCI slot. The code has never been enabled, never will
be and is unused / unmaintained. Update the man page to not indicate there is a
possibility of the driver detecting this hardware issue.

Input about the man page and Ok chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.146 2013/10/25 22:48:10 brad Exp $	*/
d710 2
d719 6
a725 1
	case RL_HWREV_8168G_SPIN4:
d729 1
a729 1
		    RL_FLAG_EARLYOFF;
d1860 4
d1887 2
@


1.146
log
@Fix/re-enable RX checksum offload for 8168C/8168CP revisions after revision rev 1.140.
The relevant code for enabling the HW's RX checksum offload support was checking
for the TX feature flag to know when to enable RX checksum offload but that flag
was removed/disabled with rev 1.140 which resulted in the RX checksum offload support
inadvertently being disabled.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.145 2013/10/11 14:00:18 jsg Exp $	*/
a199 4
#ifdef RE_DIAG
int	re_diag(struct rl_softc *);
#endif

a613 184
#ifdef RE_DIAG

/*
 * The following routine is designed to test for a defect on some
 * 32-bit 8169 cards. Some of these NICs have the REQ64# and ACK64#
 * lines connected to the bus, however for a 32-bit only card, they
 * should be pulled high. The result of this defect is that the
 * NIC will not work right if you plug it into a 64-bit slot: DMA
 * operations will be done with 64-bit transfers, which will fail
 * because the 64-bit data lines aren't connected.
 *
 * There's no way to work around this (short of talking a soldering
 * iron to the board), however we can detect it. The method we use
 * here is to put the NIC into digital loopback mode, set the receiver
 * to promiscuous mode, and then try to send a frame. We then compare
 * the frame data we sent to what was received. If the data matches,
 * then the NIC is working correctly, otherwise we know the user has
 * a defective NIC which has been mistakenly plugged into a 64-bit PCI
 * slot. In the latter case, there's no way the NIC can work correctly,
 * so we print out a message on the console and abort the device attach.
 */

int
re_diag(struct rl_softc *sc)
{
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
	struct mbuf		*m0;
	struct ether_header	*eh;
	struct rl_rxsoft	*rxs;
	struct rl_desc		*cur_rx;
	bus_dmamap_t		dmamap;
	u_int16_t		status;
	u_int32_t		rxstat;
	int			total_len, i, s, error = 0, phyaddr;
	u_int8_t		dst[] = { 0x00, 'h', 'e', 'l', 'l', 'o' };
	u_int8_t		src[] = { 0x00, 'w', 'o', 'r', 'l', 'd' };

	DPRINTF(("inside re_diag\n"));
	/* Allocate a single mbuf */

	MGETHDR(m0, M_DONTWAIT, MT_DATA);
	if (m0 == NULL)
		return (ENOBUFS);

	/*
	 * Initialize the NIC in test mode. This sets the chip up
	 * so that it can send and receive frames, but performs the
	 * following special functions:
	 * - Puts receiver in promiscuous mode
	 * - Enables digital loopback mode
	 * - Leaves interrupts turned off
	 */

	ifp->if_flags |= IFF_PROMISC;
	sc->rl_testmode = 1;
	re_reset(sc);
	re_init(ifp);
	sc->rl_flags |= RL_FLAG_LINK;
	if (sc->sc_hwrev == RL_HWREV_8139CPLUS)
		phyaddr = 0;
	else
		phyaddr = 1;

	re_miibus_writereg((struct device *)sc, phyaddr, MII_BMCR,
	    BMCR_RESET);
	for (i = 0; i < RL_TIMEOUT; i++) {
		status = re_miibus_readreg((struct device *)sc,
		    phyaddr, MII_BMCR);
		if (!(status & BMCR_RESET))
			break;
	}

	re_miibus_writereg((struct device *)sc, phyaddr, MII_BMCR,
	    BMCR_LOOP);
	CSR_WRITE_2(sc, RL_ISR, RL_INTRS);

	DELAY(100000);

	/* Put some data in the mbuf */

	eh = mtod(m0, struct ether_header *);
	bcopy ((char *)&dst, eh->ether_dhost, ETHER_ADDR_LEN);
	bcopy ((char *)&src, eh->ether_shost, ETHER_ADDR_LEN);
	eh->ether_type = htons(ETHERTYPE_IP);
	m0->m_pkthdr.len = m0->m_len = ETHER_MIN_LEN - ETHER_CRC_LEN;

	/*
	 * Queue the packet, start transmission.
	 */

	CSR_WRITE_2(sc, RL_ISR, 0xFFFF);
	s = splnet();
	IFQ_ENQUEUE(&ifp->if_snd, m0, NULL, error);
	re_start(ifp);
	splx(s);
	m0 = NULL;

	DPRINTF(("re_diag: transmission started\n"));

	/* Wait for it to propagate through the chip */

	DELAY(100000);
	for (i = 0; i < RL_TIMEOUT; i++) {
		status = CSR_READ_2(sc, RL_ISR);
		CSR_WRITE_2(sc, RL_ISR, status);
		if ((status & (RL_ISR_TIMEOUT_EXPIRED|RL_ISR_RX_OK)) ==
		    (RL_ISR_TIMEOUT_EXPIRED|RL_ISR_RX_OK))
			break;
		DELAY(10);
	}
	if (i == RL_TIMEOUT) {
		printf("%s: diagnostic failed, failed to receive packet "
		    "in loopback mode\n", sc->sc_dev.dv_xname);
		error = EIO;
		goto done;
	}

	/*
	 * The packet should have been dumped into the first
	 * entry in the RX DMA ring. Grab it from there.
	 */

	rxs = &sc->rl_ldata.rl_rxsoft[0];
	dmamap = rxs->rxs_dmamap;
	bus_dmamap_sync(sc->sc_dmat, dmamap, 0, dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD);
	bus_dmamap_unload(sc->sc_dmat, dmamap);

	m0 = rxs->rxs_mbuf;
	rxs->rxs_mbuf = NULL;
	eh = mtod(m0, struct ether_header *);

	RL_RXDESCSYNC(sc, 0, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	cur_rx = &sc->rl_ldata.rl_rx_list[0];
	rxstat = letoh32(cur_rx->rl_cmdstat);
	total_len = rxstat & sc->rl_rxlenmask;

	if (total_len != ETHER_MIN_LEN) {
		printf("%s: diagnostic failed, received short packet\n",
		    sc->sc_dev.dv_xname);
		error = EIO;
		goto done;
	}

	DPRINTF(("re_diag: packet received\n"));

	/* Test that the received packet data matches what we sent. */

	if (bcmp((char *)&eh->ether_dhost, (char *)&dst, ETHER_ADDR_LEN) ||
	    bcmp((char *)&eh->ether_shost, (char *)&src, ETHER_ADDR_LEN) ||
	    ntohs(eh->ether_type) != ETHERTYPE_IP) {
		printf("%s: WARNING, DMA FAILURE!\n", sc->sc_dev.dv_xname);
		printf("%s: expected TX data: %s",
		    sc->sc_dev.dv_xname, ether_sprintf(dst));
		printf("/%s/0x%x\n", ether_sprintf(src), ETHERTYPE_IP);
		printf("%s: received RX data: %s",
		    sc->sc_dev.dv_xname,
		    ether_sprintf(eh->ether_dhost));
		printf("/%s/0x%x\n", ether_sprintf(eh->ether_shost),
		    ntohs(eh->ether_type));
		printf("%s: You may have a defective 32-bit NIC plugged "
		    "into a 64-bit PCI slot.\n", sc->sc_dev.dv_xname);
		printf("%s: Please re-install the NIC in a 32-bit slot "
		    "for proper operation.\n", sc->sc_dev.dv_xname);
		printf("%s: Read the re(4) man page for more details.\n",
		    sc->sc_dev.dv_xname);
		error = EIO;
	}

done:
	/* Turn interface off, release resources */
	sc->rl_testmode = 0;
	sc->rl_flags &= ~RL_FLAG_LINK;
	ifp->if_flags &= ~IFF_PROMISC;
	re_stop(ifp);
	if (m0 != NULL)
		m_freem(m0);
	DPRINTF(("leaving re_diag\n"));

	return (error);
}

#endif

a1030 17

#ifdef RE_DIAG
	/*
	 * Perform hardware diagnostic on the original RTL8169.
	 * Some 32-bit cards were incorrectly wired and would
	 * malfunction if plugged into a 64-bit slot.
	 */
	if (sc->sc_hwrev == RL_HWREV_8169) {
		error = re_diag(sc);
		if (error) {
			printf("%s: attach aborted due to hardware diag failure\n",
			    sc->sc_dev.dv_xname);
			ether_ifdetach(ifp);
			goto fail_8;
		}
	}
#endif
@


1.145
log
@Add initial RTL8106E and RTL8168G/8111G support.
An earlier version didn't seem to work on a machine bmercer@@
had access to a few months ago but this seems to work
with the onboard Ethernet in an ASUS Z87 board RD Thrush has.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.144 2013/10/05 22:59:57 kettenis Exp $	*/
d2009 3
a2011 2
	 * Enable C+ RX and TX mode, as well as RX checksum offload.
	 * We must configure the C+ register before all others.
d2013 2
a2014 4
	cfg = RL_CPLUSCMD_TXENB | RL_CPLUSCMD_PCI_MRW;

	if (ifp->if_capabilities & IFCAP_CSUM_IPv4)
		cfg |= RL_CPLUSCMD_RXCSUM_ENB;
@


1.144
log
@Disable interrupts in the interrupt handler.  This is what FreeBSD does, and
it seems to fix the occasional watchdog timeout when using MSI.

tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.143 2013/08/07 01:06:30 bluhm Exp $	*/
d226 2
d243 4
d855 2
d903 9
d1994 1
d2079 4
a2082 1
	CSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);
@


1.143
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.142 2013/03/17 20:47:23 brad Exp $	*/
d1653 3
d1721 2
@


1.142
log
@- Remove the reserved number of TX descriptors. No limitation is mentioned in
  the 8139C+/8169/8110/8168/8101/8111 datasheets and it seems to work ok
  without reserving the descriptors.
- Change allowable number of TX DMA segments to 32.

From FreeBSD

ok chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.141 2013/03/11 23:42:19 brad Exp $	*/
a130 1
#include <netinet/in_var.h>
@


1.141
log
@Separate out the common capabilities flags from the switch statement
added in the last commit. No functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.140 2013/03/09 17:17:12 bluhm Exp $	*/
d1070 1
a1070 2
		    RL_JUMBO_FRAMELEN,
		    RL_TX_DESC_CNT(sc) - RL_NTXDESC_RSVD, RL_TDESC_CMD_FRAGLEN,
d1594 1
a1594 2
	if (sc->rl_ldata.rl_tx_free > RL_NTXDESC_RSVD)
		ifp->if_flags &= ~IFF_OACTIVE;
a1731 3
	if (sc->rl_ldata.rl_tx_free <= RL_NTXDESC_RSVD)
		return (EFBIG);

d1782 1
a1782 1
	if (nsegs > sc->rl_ldata.rl_tx_free - RL_NTXDESC_RSVD) {
@


1.140
log
@Calculating the IP header checksum on Realtek 8168 is broken if the
packet has IP options.  Disable IP checksum offloading for the
affected revisions.
From FreeBSD;  OK sthen@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.139 2012/05/09 13:30:12 jsg Exp $	*/
d1142 3
a1152 2
		ifp->if_capabilities = IFCAP_VLAN_MTU |
				       IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
d1155 1
a1155 2
		ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_CSUM_IPv4 |
				       IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
@


1.139
log
@8401E/8402/8105E/8105E_SPIN1 don't support jumbo frames
from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.138 2012/05/09 13:14:35 jsg Exp $	*/
d1142 15
a1156 2
	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_CSUM_IPv4 |
			       IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
@


1.138
log
@The 8168D chipset needs to have the PHY wake PM flag set to ensure
the PHY is woken up upon attachment. From FreeBSD via Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.137 2012/04/08 08:34:55 jsg Exp $	*/
d852 2
a853 1
		    RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD;
@


1.137
log
@additional adapter types from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.136 2011/06/15 13:19:19 jsg Exp $	*/
a864 1
	case RL_HWREV_8168D:
d881 1
@


1.136
log
@Set RL_FLAG_INVMAR for RTL8105E/RTL8401E/RTL8168E VL so multicast
will work and add PHY wake up code for RTL8401E.

From brad
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.135 2011/04/14 21:06:37 jsg Exp $	*/
d228 2
d241 1
d243 1
d847 1
d849 1
d889 2
@


1.135
log
@Add several additional adapter types and correct definition of
RTL8103E, from FreeBSD.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.134 2011/04/05 18:01:21 henning Exp $	*/
d844 3
a846 3
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PHYWAKE_PM |
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |
		    RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD;
d883 3
a885 3
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |
		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |
		    RL_FLAG_AUTOPAD | RL_FLAG_NOJUMBO;
d1148 1
a1148 1
	if (sc->rl_flags & RL_FLAG_PHYWAKE_PM)
d1150 3
@


1.134
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.133 2011/03/13 15:35:20 stsp Exp $	*/
d227 1
d229 1
d239 1
d243 1
d837 1
d842 6
d880 5
@


1.133
log
@Wake On LAN support for re(4).
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.132 2010/11/28 22:13:48 kettenis Exp $	*/
d1710 1
a1710 1
	    (M_IPV4_CSUM_OUT|M_TCPV4_CSUM_OUT|M_UDPV4_CSUM_OUT)) != 0) {
d1713 1
a1713 1
			if (m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
d1715 1
a1715 1
			if (m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
d1719 1
a1719 1
			if (m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
d1721 1
a1721 1
			if (m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
@


1.132
log
@Get rid of "forever" loop in the interrupt handler such that we drop out of the
interrupt handler if the "Rx Descriptor Unavailable" bit is set and no new
mbufs are available to populate descriptors.  Fixes hangs seen with MCLGETI.

ok sthen@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.131 2010/11/28 22:08:59 kettenis Exp $	*/
d197 3
d1124 5
d2346 49
@


1.131
log
@Bring back MCLGETI; a fix for the issue that was the reason for its previous
backout will be committed shortly.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.130 2010/11/12 22:17:30 sthen Exp $	*/
d1608 6
a1613 1
	for (;;) {
d1615 2
a1616 12
		status = CSR_READ_2(sc, RL_ISR);
		/* If the card has gone away the read returns 0xffff. */
		if (status == 0xffff)
			break;
		if (status)
			CSR_WRITE_2(sc, RL_ISR, status);

		if (status & RL_ISR_TIMEOUT_EXPIRED)
			claimed = 1;

		if ((status & RL_INTRS_CPLUS) == 0)
			break;
d1618 1
@


1.130
log
@revert MCLGETI for re(4) for now, it is causing hangs (in some cases
temporary, in others apparently permanent) with high rates of input
packets.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.112 2009/07/18 13:21:32 sthen Exp $	*/
d165 1
a165 1
int	re_newbuf(struct rl_softc *, int, struct mbuf *);
d167 1
d1112 2
d1218 1
a1218 1
re_newbuf(struct rl_softc *sc, int idx, struct mbuf *m)
d1220 1
a1220 1
	struct mbuf	*n = NULL;
d1225 1
a1225 1
	int		error;
d1227 3
a1229 13
	if (m == NULL) {
		MGETHDR(n, M_DONTWAIT, MT_DATA);
		if (n == NULL)
			return (ENOBUFS);

		MCLGET(n, M_DONTWAIT);
		if (!(n->m_flags & M_EXT)) {
			m_freem(n);
			return (ENOBUFS);
		}
		m = n;
	} else
		m->m_data = m->m_ext.ext_buf;
d1239 1
d1244 4
a1247 3

	if (error)
		goto out;
d1259 2
a1260 1
		goto out;
d1276 3
a1279 4
 out:
	if (n != NULL)
		m_freem(n);
	return (ENOMEM);
d1308 1
a1308 8
	int	i;

	memset((char *)sc->rl_ldata.rl_rx_list, 0, RL_RX_LIST_SZ);

	for (i = 0; i < RL_RX_DESC_CNT; i++) {
		if (re_newbuf(sc, i, NULL) == ENOBUFS)
			return (ENOBUFS);
	}
d1311 2
d1315 2
d1320 9
d1346 2
a1347 1
	for (i = sc->rl_ldata.rl_rx_prodidx;; i = RL_NEXT_RX_DESC(sc, i)) {
d1359 2
a1378 1
			re_newbuf(sc, i, NULL);
a1415 16
			re_newbuf(sc, i, m);
			continue;
		}

		/*
		 * If allocating a replacement mbuf fails,
		 * reload the current one.
		 */

		if (re_newbuf(sc, i, NULL)) {
			ifp->if_ierrors++;
			if (sc->rl_head != NULL) {
				m_freem(sc->rl_head);
				sc->rl_head = sc->rl_tail = NULL;
			}
			re_newbuf(sc, i, m);
d1493 2
a1494 1
	sc->rl_ldata.rl_rx_prodidx = i;
@


1.129
log
@add missing splx in the debug codepath.  nevertheless that
doesn't mean it should be wrong.

ok blambert, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.128 2010/08/27 17:08:00 jsg Exp $	*/
d165 1
a165 1
int	re_newbuf(struct rl_softc *);
a166 1
void	re_rx_list_fill(struct rl_softc *);
a1110 2
	m_clsetwms(ifp, MCLBYTES, 2, RL_RX_DESC_CNT);

d1215 1
a1215 1
re_newbuf(struct rl_softc *sc)
d1217 1
a1217 1
	struct mbuf	*m;
d1222 1
a1222 1
	int		error, idx;
d1224 13
a1236 3
	m = MCLGETI(NULL, M_DONTWAIT, &sc->sc_arpcom.ac_if, MCLBYTES);
	if (!m)
		return (ENOBUFS);
a1245 1
	idx = sc->rl_ldata.rl_rx_prodidx;
d1250 3
a1252 4
	if (error) {
		m_freem(m);
		return (ENOBUFS);
	}
d1264 1
a1264 2
		m_freem(m);
		return (ENOBUFS);
a1279 3
	sc->rl_ldata.rl_rx_prodidx = RL_NEXT_RX_DESC(sc, idx);
	sc->rl_ldata.rl_rx_cnt++;

d1281 4
d1313 8
a1320 1
	bzero(sc->rl_ldata.rl_rx_list, RL_RX_LIST_SZ);
a1322 2
	sc->rl_ldata.rl_rx_considx = 0;
	sc->rl_ldata.rl_rx_cnt = 0;
a1324 2
	re_rx_list_fill(sc);

a1327 9
void
re_rx_list_fill(struct rl_softc *sc)
{
	while (sc->rl_ldata.rl_rx_cnt < RL_RX_DESC_CNT) {
		if (re_newbuf(sc) == ENOBUFS)
			break;
	}
}

d1345 1
a1345 2
	for (i = sc->rl_ldata.rl_rx_considx; sc->rl_ldata.rl_rx_cnt > 0;
	     i = RL_NEXT_RX_DESC(sc, i)) {
a1356 2
		rxs->rxs_mbuf = NULL;
		sc->rl_ldata.rl_rx_cnt--;
d1375 1
d1413 16
d1506 1
a1506 2
	sc->rl_ldata.rl_rx_considx = i;
	re_rx_list_fill(sc);
@


1.128
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.127 2010/08/08 21:00:31 krw Exp $	*/
d2045 2
a2046 1
	if (sc->rl_testmode)
d2048 1
@


1.127
log
@Fix re_stop() invocation (normally #ifdef'd out) to use new parameter
list.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.126 2010/08/07 23:56:42 naddy Exp $	*/
a1106 1
	ifp->if_init = re_init;
@


1.126
log
@Revert 1.123.  Hangs RTL8168C/8111C (0x3c00) after
ifconfig re0 up
ifconfig re0 down
dhclient re0

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.125 2010/08/07 03:50:01 krw Exp $	*/
d776 1
a776 1
	re_stop(ifp, 1);
@


1.125
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.124 2010/07/27 20:53:39 kettenis Exp $	*/
d2181 1
a2181 6
	if (sc->rl_flags & RL_FLAG_CMDSTOP)
		CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_STOPREQ | RL_CMD_TX_ENB |
		    RL_CMD_RX_ENB);
	else
		CSR_WRITE_1(sc, RL_COMMAND, 0x00);
	DELAY(1000);
@


1.124
log
@Make sure we stop DMA before we suspend.  Remove unused argument to re_stop()
to avoid the dilemma what meaningless value to pass.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.123 2010/07/14 19:24:27 naddy Exp $	*/
d2309 1
a2309 1
		panic("%s: unknown imtype %d\n",
d2342 1
a2342 1
		panic("%s: unknown imtype %d\n",
@


1.123
log
@Newer 8168x and 810x chipsets have a different way of stopping the chipset.
From FreeBSD via Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.122 2010/07/10 21:00:34 naddy Exp $	*/
d1945 1
a1945 1
	re_stop(ifp, 0);
d2121 1
a2121 1
				re_stop(ifp, 1);
d2166 1
a2166 1
re_stop(struct ifnet *ifp, int disable)
@


1.122
log
@Reduce the delays a bit in the miibus read/write routines.

Although with aditional 20us delays added just before returning
from miibus read/writes as required by the hardware.

Based on the Linux r8169 driver; from Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.121 2010/06/28 17:00:18 naddy Exp $	*/
d2181 6
a2186 1
	CSR_WRITE_1(sc, RL_COMMAND, 0x00);
@


1.121
log
@fix typo; from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.120 2010/06/28 16:04:09 sthen Exp $	*/
a355 1
	DELAY(1000);
d357 1
a357 1
	for (i = 0; i < RL_TIMEOUT; i++) {
d361 1
a361 1
		DELAY(100);
d364 1
a364 1
	if (i == RL_TIMEOUT) {
d369 2
a382 1
	DELAY(1000);
d384 1
a384 1
	for (i = 0; i < RL_TIMEOUT; i++) {
d388 1
a388 1
		DELAY(100);
d391 1
a391 1
	if (i == RL_TIMEOUT)
d393 2
@


1.120
log
@Add initial support for RTL8168E, brokenness reported by Joe Gidi.
With help from Brad, ok jsg@@, closes system/6402
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.119 2010/05/19 15:27:35 oga Exp $	*/
d863 1
a863 1
		    RL_FLAG_MACSTAT | FL_FLAG_HWIM | RL_FLAG_CMDSTOP |
@


1.119
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.118 2010/04/03 22:24:05 sthen Exp $	*/
d236 1
d860 6
d1123 2
@


1.118
log
@Set the RL_FLAG_MACSLEEP flag for the RTL8103E chipset.
Currently a noop as the code for RL_FLAG_MACSLEEP hasn't been added yet.
From FreeBSD via Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.117 2010/02/17 22:16:34 kettenis Exp $	*/
d997 2
a998 1
		    &sc->rl_ldata.rl_tx_listnseg, BUS_DMA_NOWAIT)) != 0) {
a1012 1
	memset(sc->rl_ldata.rl_tx_list, 0, RL_TX_LIST_SZ(sc));
d1046 2
a1047 1
		    &sc->rl_ldata.rl_rx_listnseg, BUS_DMA_NOWAIT)) != 0) {
a1062 1
	memset(sc->rl_ldata.rl_rx_list, 0, RL_RX_DMAMEM_SZ);
@


1.117
log
@Make sure we claim the interrupt as ours if the time out bit is set in the
interrupt status register.  Fixes a problem with spurious interrupts on
the fuloong.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.116 2009/11/24 17:40:43 kettenis Exp $	*/
d822 3
a826 1
	case RL_HWREV_8103E:
@


1.116
log
@Reset the chip an re-initialise the interface after reset.  Resetting the
PHY doesn't seem to be necessary on re(4) so don't descend further for now.

Based on a diff from mlarkin@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.115 2009/11/13 23:50:30 sthen Exp $	*/
d1604 3
@


1.115
log
@Remove an unnecessary assignment. From NetBSD via Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.114 2009/08/09 11:40:58 deraadt Exp $	*/
a189 1
void	re_reset(struct rl_softc *);
@


1.114
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.113 2009/07/23 20:15:32 kettenis Exp $	*/
a1802 2
		bus_addr_t paddaddr;

d1805 1
a1805 2
		paddaddr = RL_TXPADDADDR(sc);
		re_set_bufaddr(d, paddaddr);
@


1.113
log
@Switch re(4) over to MCLGETI.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.112 2009/07/18 13:21:32 sthen Exp $	*/
d1216 2
a1217 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
a1218 6

	MCLGETI(m, M_DONTWAIT, &sc->sc_arpcom.ac_if, MCLBYTES);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}
@


1.112
log
@reorder a switch block, no functional change but reduces the diff
with FreeBSD. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.111 2009/07/15 19:50:04 naddy Exp $	*/
d165 1
a165 1
int	re_newbuf(struct rl_softc *, int, struct mbuf *);
d167 1
d1103 2
d1207 1
a1207 1
re_newbuf(struct rl_softc *sc, int idx, struct mbuf *m)
d1209 1
a1209 1
	struct mbuf	*n = NULL;
d1214 1
a1214 1
	int		error;
d1216 9
a1224 13
	if (m == NULL) {
		MGETHDR(n, M_DONTWAIT, MT_DATA);
		if (n == NULL)
			return (ENOBUFS);

		MCLGET(n, M_DONTWAIT);
		if (!(n->m_flags & M_EXT)) {
			m_freem(n);
			return (ENOBUFS);
		}
		m = n;
	} else
		m->m_data = m->m_ext.ext_buf;
d1234 1
d1239 4
a1242 3

	if (error)
		goto out;
d1254 2
a1255 1
		goto out;
d1271 3
a1274 4
 out:
	if (n != NULL)
		m_freem(n);
	return (ENOMEM);
d1303 1
a1303 8
	int	i;

	memset((char *)sc->rl_ldata.rl_rx_list, 0, RL_RX_LIST_SZ);

	for (i = 0; i < RL_RX_DESC_CNT; i++) {
		if (re_newbuf(sc, i, NULL) == ENOBUFS)
			return (ENOBUFS);
	}
d1306 2
d1310 2
d1315 9
d1341 2
a1342 1
	for (i = sc->rl_ldata.rl_rx_prodidx;; i = RL_NEXT_RX_DESC(sc, i)) {
d1354 2
a1373 1
			re_newbuf(sc, i, NULL);
a1410 16
			re_newbuf(sc, i, m);
			continue;
		}

		/*
		 * If allocating a replacement mbuf fails,
		 * reload the current one.
		 */

		if (re_newbuf(sc, i, NULL)) {
			ifp->if_ierrors++;
			if (sc->rl_head != NULL) {
				m_freem(sc->rl_head);
				sc->rl_head = sc->rl_tail = NULL;
			}
			re_newbuf(sc, i, m);
d1488 2
a1489 1
	sc->rl_ldata.rl_rx_prodidx = i;
@


1.111
log
@Removes the magic bit from re_init() and moves the common
flag to the top. No change with the actual cplus mode register
setting being used with the controllers.  From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.110 2009/07/11 16:51:58 sthen Exp $	*/
d857 6
a866 6
		break;
	case RL_HWREV_8169_8110SB:
	case RL_HWREV_8169_8110SBL:
	case RL_HWREV_8169_8110SCd:
	case RL_HWREV_8169_8110SCe:
		sc->rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_MACLDPS;
@


1.110
log
@- Add some new feature flags
- Add defines for newer chipsets

From FreeBSD via Brad. No functional change, needed for future work.
ok naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.109 2009/07/10 21:29:57 sthen Exp $	*/
d1951 2
a1952 1
	cfg = RL_CPLUSCMD_PCI_MRW;
d1955 1
d1958 2
a1959 1
	if (sc->rl_flags & RL_FLAG_MACSTAT) {
d1961 3
a1963 5
		/* XXX magic. */
		cfg |= 0x0001;
	} else {
		cfg |= RL_CPLUSCMD_RXENB | RL_CPLUSCMD_TXENB;
	}
@


1.109
log
@RL_HWREV_8168DP can be either RTL8168DP or RTL8111DP, so print both,
as done for other RTL8168 HWREVs. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.108 2009/07/03 16:55:27 deraadt Exp $	*/
d814 1
a814 1
		sc->rl_flags |= RL_FLAG_NOJUMBO;
d827 1
a827 1
		    RL_FLAG_MACSTAT;
d835 3
a838 1
	case RL_HWREV_8168C_SPIN2:
d844 1
a844 1
		    RL_FLAG_HWIM;
@


1.108
log
@Support RTL8103E and RTL8168DP which are starting to show up, from brad.
OK from kettenis and sthen after the diff was minimized to have no
potential impact on other chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.107 2009/06/04 04:48:24 naddy Exp $	*/
d235 1
a235 1
	{ RL_HWREV_8168DP,      "RTL8168DP" },
@


1.107
log
@Fix IPv4 rx checksumming for the non-TCP/UDP case.  DESCV2 chips
don't set RL_RDESC_STAT_PROTOID for non-TCP/UDP IP packets, only
RL_RDESC_IPV[46].

Also check RL_RDESC_IPV[46] before inspecting the TCP/UDP checksum
bits to make IPv6 TCP/UDP checksum offload work intentionally.

Gleaned from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.106 2009/06/03 00:11:19 sthen Exp $	*/
d225 1
d235 1
d824 1
d839 1
@


1.106
log
@from Brad; I've read and tested it, also reads ok to dlg@@.

- Further simplify the re(4) receive filter handling and
  have everything taken care of in re_iff(), eliminating
  a bit of code from re_init().
- Remove unused if_flags field.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.105 2009/05/23 09:39:23 jsg Exp $	*/
d1448 2
a1449 3
			if ((rxstat & RL_RDESC_STAT_PROTOID) &&
			    !(rxstat & RL_RDESC_STAT_IPSUMBAD) &&
			    (rxvlan & RL_RDESC_IPV4))
d1453 2
a1454 1
			if (((rxstat & RL_RDESC_STAT_TCP) &&
d1457 1
a1457 1
			    !(rxstat & RL_RDESC_STAT_UDPSUMBAD)))
@


1.105
log
@FALL THROUGH -> FALLTHROUGH to appease lint
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.104 2009/02/12 11:55:29 martynas Exp $	*/
d519 1
a519 1
	u_int32_t		hashes[2] = { 0, 0 };
a520 1
	int			mcnt = 0;
d526 2
a527 1
	rxfilt &= ~(RL_RXCFG_RX_ALLPHYS | RL_RXCFG_RX_MULTI);
d530 8
a537 3
	if (ifp->if_flags & IFF_PROMISC ||
	    ac->ac_multirangecnt > 0) {
		ifp ->if_flags |= IFF_ALLMULTI;
d543 3
a545 3
		/* first, zot all the existing hash bits */
		CSR_WRITE_4(sc, RL_MAR0, 0);
		CSR_WRITE_4(sc, RL_MAR4, 0);
a546 1
		/* now program new ones */
d551 1
d556 1
a556 1
			mcnt++;
a558 3

		if (mcnt)
			rxfilt |= RL_RXCFG_RX_MULTI;
a1926 1
	u_int32_t	rxcfg = 0;
a2012 14
	/* Set the individual bit to receive frames for this host only. */
	rxcfg = CSR_READ_4(sc, RL_RXCFG);
	rxcfg |= RL_RXCFG_RX_INDIV;

	/*
	 * Set capture broadcast bit to capture broadcast frames.
	 */
	if (ifp->if_flags & IFF_BROADCAST)
		rxcfg |= RL_RXCFG_RX_BROAD;
	else
		rxcfg &= ~RL_RXCFG_RX_BROAD;

	CSR_WRITE_4(sc, RL_RXCFG, rxcfg);

d2109 1
a2109 1
				re_iff(sc);
a2115 1
		sc->if_flags = ifp->if_flags;
@


1.104
log
@don't access undocumented register 0x82 for <= MAC06, since newer
realteks start to behave badly if we do.  this should fix the widely
reported re(4) issue.  makes my RTL8101E usable, fixes Thomas'
RTL8168C, and PR6023.  tested by many
this is a more conservative version of my diff from kettenis@@ (does
not clear PHY register 0x0b)
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.103 2008/11/30 06:01:45 brad Exp $	*/
d2296 1
a2296 1
		/* FALL THROUGH */
@


1.103
log
@Add initial 8168D/8111D support.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.102 2008/11/28 02:44:17 brad Exp $	*/
d591 2
a592 1
	CSR_WRITE_1(sc, RL_LDPS, 1);
a805 3
	/* Reset the adapter. */
	re_reset(sc);

a807 34
	sc->rl_tx_time = 5;		/* 125us */
	sc->rl_rx_time = 2;		/* 50us */
	if (sc->rl_flags & RL_FLAG_PCIE)
		sc->rl_sim_time = 75;	/* 75us */
	else
		sc->rl_sim_time = 125;	/* 125us */
	sc->rl_imtype = RL_IMTYPE_SIM;	/* simulated interrupt moderation */

	if (sc->sc_hwrev == RL_HWREV_8139CPLUS)
		sc->rl_bus_speed = 33; /* XXX */
	else if (sc->rl_flags & RL_FLAG_PCIE)
		sc->rl_bus_speed = 125;
	else {
		u_int8_t cfg2;

		cfg2 = CSR_READ_1(sc, RL_CFG2);
		switch (cfg2 & RL_CFG2_PCI_MASK) {
		case RL_CFG2_PCI_33MHZ:
 			sc->rl_bus_speed = 33;
			break;
		case RL_CFG2_PCI_66MHZ:
			sc->rl_bus_speed = 66;
			break;
		default:
			printf("%s: unknown bus speed, assume 33MHz\n",
			    sc->sc_dev.dv_xname);
			sc->rl_bus_speed = 33;
			break;
		}

		if (cfg2 & RL_CFG2_PCI_64BIT)
			sc->rl_flags |= RL_FLAG_PCI64;
	}

d849 5
d858 1
a858 1
		sc->rl_flags |= RL_FLAG_PHYWAKE;
d862 37
@


1.102
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.101 2008/11/17 01:25:31 brad Exp $	*/
d233 1
d869 1
@


1.101
log
@Sprinkle a few more tabs.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.100 2008/11/14 20:49:35 naddy Exp $	*/
a2110 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
a2122 15
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				re_iff(sc);
			error = 0;
		}
		break;
d2129 6
@


1.100
log
@Revert the reduction in the delays in the miibus read/write routines,
which broke on-board RTL8111C adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.99 2008/11/09 15:08:25 naddy Exp $	*/
d1062 7
a1068 7
        /* Create DMA maps for RX buffers */
        for (i = 0; i < RL_RX_DESC_CNT; i++) {
                error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
                    0, 0, &sc->rl_ldata.rl_rxsoft[i].rxs_dmamap);
                if (error) {
                        printf("%s: can't create DMA map for RX\n",
                            sc->sc_dev.dv_xname);
d1070 2
a1071 2
                }
        }
@


1.99
log
@Introduce bpf_mtap_ether(), which for the benefit of bpf listeners
creates the VLAN encapsulation from the tag stored in the mbuf
header.  Idea from FreeBSD, input from claudio@@ and canacar@@.

Switch all hardware VLAN enabled drivers to the new function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.98 2008/11/08 06:52:49 brad Exp $	*/
d345 1
d352 1
d354 1
a354 1
	for (i = 0; i < RL_PHY_TIMEOUT; i++) {
d358 1
a358 1
		DELAY(25);
d361 1
a361 1
	if (i == RL_PHY_TIMEOUT) {
d378 1
d380 1
a380 1
	for (i = 0; i < RL_PHY_TIMEOUT; i++) {
d384 1
a384 1
		DELAY(25);
d387 1
a387 1
	if (i == RL_PHY_TIMEOUT)
@


1.98
log
@Reduce the delay's a bit in the miibus read/write routines.

Based on the Linux r8169 driver.

Tested on PCI/CardBus and PCIe adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.97 2008/11/07 18:12:22 brad Exp $	*/
d1471 1
a1471 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1893 1
a1893 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
@


1.97
log
@Try recollecting RX/TX descriptors if we are going to switch back to TX/RX
interrupts.  There seems to be a race between turning on TX/RX interrupt and
asserting TX/RX interrupt by the hardware.

From Sephe@@DragonFly
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.96 2008/10/16 19:18:03 naddy Exp $	*/
a344 1

a350 1
	DELAY(1000);
d352 1
a352 1
	for (i = 0; i < RL_TIMEOUT; i++) {
d356 1
a356 1
		DELAY(100);
d359 1
a359 1
	if (i == RL_TIMEOUT) {
a375 1
	DELAY(1000);
d377 1
a377 1
	for (i = 0; i < RL_TIMEOUT; i++) {
d381 1
a381 1
		DELAY(100);
d384 1
a384 1
	if (i == RL_TIMEOUT)
@


1.96
log
@Switch the existing TX VLAN hardware support over to having the
tag in the header.  Convert TX tagging in the drivers.

Help and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.95 2008/10/16 19:16:21 naddy Exp $	*/
d1630 5
a1634 1
			if ((tx | rx) == 0)
d1636 9
a1644 1
			else
d1646 6
a1651 1
		} else if (tx | rx)
d1653 1
@


1.95
log
@Convert RX tag stripping to storing the tag in the mbuf header and
enable RX tag stripping for re(4).

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.94 2008/10/11 23:49:05 brad Exp $	*/
a1651 7
#if NVLAN > 0
	struct ifvlan	*ifv = NULL;

	if ((m->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m->m_pkthdr.rcvif != NULL)
		ifv = m->m_pkthdr.rcvif->if_softc;
#endif
d1724 3
a1726 2
	if (ifv != NULL)
		vlanctl |= swap16(ifv->ifv_tag) | RL_TDESC_VLANCTL_TAG;
@


1.94
log
@Use hardware timer to simulate interrupt moderation.  Old devices will no
longer be livelocked when they are receiving on GigE line.  Newer devices
also gain well controlled interrupt rate.

If hardware supports interrupt moderation (e.g. 8168B, 8168C), you could
also use hardware based interrupt moderation, however, due to lack of
necessary information it does not work as reliably as simulated interrupt
moderation.  It is _not_ recommended currently.

By default, PCIe devices' simulated interrupt moderation timer is set to
75us, while PCI devices' is set to 125us.

From sephe@@DragonFly
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.93 2008/10/09 23:02:07 brad Exp $	*/
d1464 7
d1927 2
@


1.93
log
@Set hardware timer according to bus clock speed.

From sephe@@DragonFly
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.92 2008/10/06 00:34:09 brad Exp $	*/
d168 2
a169 2
void	re_rxeof(struct rl_softc *);
void	re_txeof(struct rl_softc *);
d191 7
d809 34
d863 1
a863 1
		    RL_FLAG_MACSTAT;
d869 2
a870 1
		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT;
d893 2
a969 26
	if (sc->sc_hwrev == RL_HWREV_8139CPLUS) {
		sc->rl_bus_speed = 33; /* XXX */
	} else if (sc->rl_flags & RL_FLAG_PCIE) {
		sc->rl_bus_speed = 125;
	} else {
		u_int8_t cfg2;

		cfg2 = CSR_READ_1(sc, RL_CFG2);
		switch (cfg2 & RL_CFG2_PCI_MASK) {
		case RL_CFG2_PCI_33MHZ:
			sc->rl_bus_speed = 33;
			break;
		case RL_CFG2_PCI_66MHZ:
			sc->rl_bus_speed = 66;
			break;
		default:
			printf("%s: unknown bus speed, assume 33MHz\n",
			    sc->sc_dev.dv_xname);
			sc->rl_bus_speed = 33;
			break;
		}

		if (cfg2 & RL_CFG2_PCI_64BIT)
			sc->rl_flags |= RL_FLAG_PCI64;
	}

d1306 1
a1306 1
void
d1311 1
a1311 1
	int		i, total_len;
d1330 1
d1473 2
d1477 1
a1477 1
void
d1483 1
a1483 1
	int		idx, descidx;
d1505 1
d1527 8
a1534 8
	if (sc->rl_ldata.rl_tx_free < RL_TX_DESC_CNT(sc)) {
		/*
		 * Some chips will ignore a second TX request issued while an
		 * existing transmission is in progress. If the transmitter goes
		 * idle but there are still packets waiting to be sent, we need
		 * to restart the channel here to flush them out. This only
		 * seems to be required with the PCIe devices.
		 */
d1536 2
d1539 1
a1539 9
		/*
		 * If not all descriptors have been released reaped yet,
		 * reload the timer so that we will eventually get another
		 * interrupt that will cause us to re-enter this routine.
		 * This is done in case the transmitter has gone idle.
		 */
		CSR_WRITE_4(sc, RL_TIMERCNT, 1);
	} else
		ifp->if_timer = 0;
d1578 1
a1578 1
	int		claimed = 0;
d1582 1
a1582 1
	if (!(ifp->if_flags & IFF_UP))
d1585 1
d1598 2
a1599 2
		if (status & (RL_ISR_RX_OK | RL_ISR_RX_ERR)) {
			re_rxeof(sc);
d1603 2
a1604 3
		if (status & (RL_ISR_TIMEOUT_EXPIRED | RL_ISR_TX_ERR |
		    RL_ISR_TX_DESC_UNAVAIL)) {
			re_txeof(sc);
d1621 11
a1631 1
	if (claimed && !IFQ_IS_EMPTY(&ifp->if_snd))
d1881 1
a1881 3
	if (queued == 0) {
		if (sc->rl_ldata.rl_tx_free != RL_TX_DESC_CNT(sc))
			CSR_WRITE_4(sc, RL_TIMERCNT, 1);
a1882 1
	}
a1888 10
	 * Use the countdown timer for interrupt moderation.
	 * 'TX done' interrupts are disabled. Instead, we reset the
	 * countdown timer, which will begin counting until it hits
	 * the value in the TIMERINT register, and then trigger an
	 * interrupt. Each time we write to the TIMERCNT register,
	 * the timer count is reset to 0.
	 */
	CSR_WRITE_4(sc, RL_TIMERCNT, 1);

	/*
d2006 2
a2007 2
		CSR_WRITE_2(sc, RL_IMR, RL_INTRS_CPLUS);
	CSR_WRITE_2(sc, RL_ISR, RL_INTRS_CPLUS);
a2016 18
	 * Initialize the timer interrupt register so that
	 * a timer interrupt will be generated once the timer
	 * reaches a certain number of ticks. The timer is
	 * reloaded on each transmit. This gives us TX interrupt
	 * moderation, which dramatically improves TX frame rate.
	 */
	if (sc->sc_hwrev == RL_HWREV_8139CPLUS)
		CSR_WRITE_4(sc, RL_TIMERINT, 0x400);
	else {
		/*
		 * Set hardware timer to 125us
		 * XXX measurement showed me the actual value is ~76us,
		 * which is ~2/3 of the desired value
		 */
		CSR_WRITE_4(sc, RL_TIMERINT_8169, 125 * sc->rl_bus_speed);
	}

	/*
d2167 1
a2167 1
	sc->rl_flags &= ~RL_FLAG_LINK;
d2201 131
@


1.92
log
@Detect and store the PCI/PCIe bus speed.

From DragonFly
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.91 2008/10/02 20:21:13 brad Exp $	*/
d2012 8
a2019 2
	else
		CSR_WRITE_4(sc, RL_TIMERINT_8169, 0x800);
@


1.91
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.90 2008/09/10 14:01:22 blambert Exp $	*/
d925 26
@


1.90
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.89 2008/08/29 22:59:56 brad Exp $	*/
a2052 6
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command,
	    data)) > 0) {
		splx(s);
		return (error);
	}

d2101 1
a2101 2
		error = EINVAL;
		break;
a2104 1

@


1.89
log
@Take the PHY out of power down while attaching just before probing for
PHY. This helps with systems dual booting Windows XP/Vista where the
Windows drivers will put the PHY in power down mode when rebooting.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.88 2008/08/28 17:51:09 brad Exp $	*/
d1527 1
a1527 1
	timeout_add(&sc->timer_handle, hz);
d2010 1
a2010 1
	timeout_add(&sc->timer_handle, hz);
@


1.88
log
@Rewrite the multicast/promiscuous handling and in the process merge into
one function. Also fix reception of multicast packets when in promisuous
mode. The Realtek chips are a little different than most others in that
they will not receive multicast packets by enabling promiscuous mode
alone.

Tested by naddy@@ and sthen@@
ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.87 2008/08/13 03:18:19 brad Exp $	*/
d842 1
d844 1
a844 1
	case RL_HWREV_8169_8110SBL:
d1050 6
@


1.87
log
@Replace the use of a separate softc field to track the link
state with the newly minted link flag in the softc's rl_flags
field.

Tested by fkr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.86 2008/08/11 22:42:19 brad Exp $	*/
d188 1
a188 2
void	re_setmulti(struct rl_softc *);
void	re_setpromisc(struct rl_softc *);
a505 3
/*
 * Program the 64-bit multicast hash filter.
 */
d507 1
a507 1
re_setmulti(struct rl_softc *sc)
d509 1
a509 1
	struct ifnet		*ifp;
a516 2
	
	ifp = &sc->sc_arpcom.ac_if;
d519 2
d522 3
a524 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
d526 19
a544 16
		CSR_WRITE_4(sc, RL_RXCFG, rxfilt);
		CSR_WRITE_4(sc, RL_MAR0, 0xFFFFFFFF);
		CSR_WRITE_4(sc, RL_MAR4, 0xFFFFFFFF);
		return;
	}

	/* first, zot all the existing hash bits */
	CSR_WRITE_4(sc, RL_MAR0, 0);
	CSR_WRITE_4(sc, RL_MAR4, 0);

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			mcnt = MAX_NUM_MULTICAST_ADDRESSES;
a545 2
		if (mcnt == MAX_NUM_MULTICAST_ADDRESSES)
			break;
d547 2
a548 8
		h = (ether_crc32_be(enm->enm_addrlo,
		    ETHER_ADDR_LEN) >> 26) & 0x0000003F;
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h - 32));
		mcnt++;
		ETHER_NEXT_MULTI(step, enm);
a550 7
	if (mcnt)
		rxfilt |= RL_RXCFG_RX_MULTI;
	else
		rxfilt &= ~RL_RXCFG_RX_MULTI;

	CSR_WRITE_4(sc, RL_RXCFG, rxfilt);

a563 1
}
d565 1
a565 14
void
re_setpromisc(struct rl_softc *sc)
{
	struct ifnet	*ifp;
	u_int32_t	rxcfg = 0;

	ifp = &sc->sc_arpcom.ac_if;

	rxcfg = CSR_READ_4(sc, RL_RXCFG);
	if (ifp->if_flags & IFF_PROMISC) 
		rxcfg |= RL_RXCFG_RX_ALLPHYS;
        else
		rxcfg &= ~RL_RXCFG_RX_ALLPHYS;
	CSR_WRITE_4(sc, RL_RXCFG, rxcfg);
d1951 2
a1952 7
	/* Set promiscuous mode. */
	re_setpromisc(sc);

	/*
	 * Program the multicast filter, if necessary.
	 */
	re_setmulti(sc);
d2070 4
a2073 8
			if (ifp->if_flags & IFF_RUNNING &&
			    ((ifp->if_flags ^ sc->if_flags) &
			     IFF_PROMISC)) {
				re_setpromisc(sc);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					re_init(ifp);
			}
d2091 1
a2091 1
				re_setmulti(sc);
@


1.86
log
@Add support for TX/RX checksum offload for newer re(4) chipsets.

Tested by naddy@@

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.85 2008/08/05 01:58:47 brad Exp $	*/
d671 1
a671 1
	sc->rl_link = 1;
a784 1

d786 1
a786 1
	sc->rl_link = 0;
d1535 1
a1535 1
	if (sc->rl_link) {
d1537 1
a1537 1
			sc->rl_link = 0;
d1541 1
a1541 1
			sc->rl_link = 1;
d1804 3
a1806 1
	if (!sc->rl_link || ifp->if_flags & IFF_OACTIVE)
d2034 1
a2034 1
	sc->rl_link = 0;
d2178 1
a2178 1
	sc->rl_link = 0;
@


1.85
log
@Add support for reading the MAC address for newer re(4) chipsets.
The current method results in a MAC address of all zeros.

Tested by bernd@@/jcs@@ with 8102E and fkr@@ with 8168C.

From FreeBSD

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.84 2008/07/15 13:21:17 jsg Exp $	*/
d1070 2
a1071 5
	
	ifp->if_capabilities = IFCAP_VLAN_MTU;
	if ((sc->rl_flags & RL_FLAG_DESCV2) == 0)
		ifp->if_capabilities |= IFCAP_CSUM_IPv4 |
		    IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
d1292 1
a1292 1
	u_int32_t	rxstat;
d1301 1
d1414 13
a1426 1
			/* XXX V2 CSUM */
d1613 1
a1613 1
	u_int32_t	cmdstat, vlanctl, rl_flags = 0;
d1641 13
a1653 5
		rl_flags |= RL_TDESC_CMD_IPCSUM;
		if (m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
			rl_flags |= RL_TDESC_CMD_TCPCSUM;
		if (m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
			rl_flags |= RL_TDESC_CMD_UDPCSUM;
d1669 3
a1671 2
	if (m->m_pkthdr.len <= RL_IP4CSUMTX_PADLEN &&
	    (rl_flags & RL_TDESC_CMD_IPCSUM) != 0) {
a1692 1
	vlanctl = 0;
d1695 1
a1695 1
		vlanctl = swap16(ifv->ifv_tag) | RL_TDESC_VLANCTL_TAG;
d1734 1
a1734 1
		cmdstat = rl_flags | map->dm_segs[seg].ds_len;
d1756 1
a1756 1
		cmdstat = rl_flags |
@


1.84
log
@Adapt some code from the FreeBSD driver required to make
newer PCI Express adapters (ie 8168C*/8102*) work.

V2 Checksum offload format in RTL8102 devices not yet supported.

No objections from brad@@. Thanks to everyone who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.83 2008/07/13 05:24:05 jsg Exp $	*/
a828 33
	sc->rl_eewidth = RL_9356_ADDR_LEN;
	re_read_eeprom(sc, (caddr_t)&re_did, 0, 1);
	if (re_did != 0x8129)
		sc->rl_eewidth = RL_9346_ADDR_LEN;

	/*
	 * Get station address from the EEPROM.
	 */
	re_read_eeprom(sc, (caddr_t)as, RL_EE_EADDR, 3);
	for (i = 0; i < ETHER_ADDR_LEN / 2; i++)
		as[i] = letoh16(as[i]);
	bcopy(as, eaddr, sizeof(eaddr));
#ifdef __armish__
	/*
	 * On the Thecus N2100, the MAC address in the EEPROM is
	 * always 00:14:fd:10:00:00.  The proper MAC address is stored
	 * in flash.  Fortunately RedBoot configures the proper MAC
	 * address (for the first onboard interface) which we can read
	 * from the IDR.
	 */
	if (eaddr[0] == 0x00 && eaddr[1] == 0x14 && eaddr[2] == 0xfd &&
	    eaddr[3] == 0x10 && eaddr[4] == 0x00 && eaddr[5] == 0x00) {
		if (boot_eaddr_valid == 0) {
			boot_eaddr.eaddr_word[1] = letoh32(CSR_READ_4(sc, RL_IDR4));
			boot_eaddr.eaddr_word[0] = letoh32(CSR_READ_4(sc, RL_IDR0));
			boot_eaddr_valid = 1;
		}

		bcopy(boot_eaddr.eaddr, eaddr, sizeof(eaddr));
		eaddr[5] += sc->sc_dev.dv_unit;
	}
#endif

d844 2
a845 1
		    RL_FLAG_PHYWAKE | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT;
d877 46
@


1.83
log
@Add some additional hardware revisions from FreeBSD needed for
upcoming changes and sort list.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.82 2008/04/20 01:18:02 brad Exp $	*/
d571 1
a571 6
	switch (sc->sc_hwrev) {
	case RL_HWREV_8100E_SPIN1:
	case RL_HWREV_8100E_SPIN2:
	case RL_HWREV_8101E:
	case RL_HWREV_8168_SPIN1:
	case RL_HWREV_8168_SPIN2:
d574 1
a574 2
		break;
	default:
d864 47
d1051 1
a1051 1
	if (sc->sc_hwrev != RL_HWREV_8139CPLUS)
d1056 5
a1060 2
	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_CSUM_IPv4 |
			       IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
d1401 16
a1416 11
		/* Check IP header checksum */
		if ((rxstat & RL_RDESC_STAT_PROTOID) &&
		    !(rxstat & RL_RDESC_STAT_IPSUMBAD))
			m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;

		/* Check TCP/UDP checksum */
		if ((RL_TCPPKT(rxstat) &&
		    !(rxstat & RL_RDESC_STAT_TCPSUMBAD)) ||
		    (RL_UDPPKT(rxstat) &&
		    !(rxstat & RL_RDESC_STAT_UDPSUMBAD)))
			m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK | M_UDP_CSUM_IN_OK;
d1848 1
d1866 11
a1876 3
	CSR_WRITE_2(sc, RL_CPLUS_CMD, RL_CPLUSCMD_RXENB|
	    RL_CPLUSCMD_TXENB|RL_CPLUSCMD_PCI_MRW|
	    RL_CPLUSCMD_RXCSUM_ENB);
@


1.82
log
@Move the threshold fix from the re(4) code back into the header as
it was going to be before the release. No functional change.

prodded by kettenis@@ ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.81 2008/04/20 01:15:40 brad Exp $	*/
d212 7
a218 1
	{ RL_HWREV_8169,	"RTL8169" },
d220 1
a220 3
	{ RL_HWREV_8169S,	"RTL8169S" },
	{ RL_HWREV_8169_8110SB,	"RTL8169/8110SB" },
	{ RL_HWREV_8169_8110SCd, "RTL8169/8110SCd" },
a221 2
	{ RL_HWREV_8100E_SPIN1,	"RTL8100E 1" },
	{ RL_HWREV_8101E,	"RTL8101E" },
d224 7
a230 5
	{ RL_HWREV_8100E_SPIN2, "RTL8100E 2" },
	{ RL_HWREV_8168C,	"RTL8168C" },
	{ RL_HWREV_8139CPLUS,	"RTL8139C+" },
	{ RL_HWREV_8101,	"RTL8101" },
	{ RL_HWREV_8100,	"RTL8100" },
d232 1
@


1.81
log
@- Recognize the 8168C chipset.
- Add some more defines for the 8168C chipset.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.80 2008/04/20 00:59:44 brad Exp $	*/
d1867 1
a1867 2
	CSR_WRITE_4(sc, RL_RXCFG,
	    RL_RXFIFO_NOTHRESH|RL_RX_MAXDMA|RL_RX_BUF_SZ);
@


1.80
log
@Remove redundant checks for the 8139C+ chipset, this code can only
be reached if using the 8139C+ chipset.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.79 2008/04/20 00:42:27 brad Exp $	*/
d223 1
@


1.79
log
@- Add some more defines.
- Use one of the new defines in the re(4) code to remove a magic number.
- Correct a comment.
- Fix a typo.

Most of this is from NetBSD.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.78 2008/03/20 23:54:57 brad Exp $	*/
d436 1
a436 1
	if (sc->sc_hwrev == RL_HWREV_8139CPLUS && re8139_reg == RL_BMCR) {
d467 2
a468 4
		if (sc->sc_hwrev == RL_HWREV_8139CPLUS) {
			/* 8139C+ has different bit layout. */
			data &= ~(BMCR_LOOP | BMCR_ISO);
		}
@


1.78
log
@VLAN tag info must be inserted into all descriptors of a multi-descriptor
packet transmission.

From NetBSD

Fixes PR 5655.
Tested by Panagiotis Efstratiou <slasher at ee dot auth dot gr>, brad@@ and sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.77 2008/03/12 16:26:45 brad Exp $	*/
d613 1
a613 1
	CSR_WRITE_1(sc, 0x82, 1);
@


1.77
log
@Set the RX FIFO threshold to no RX threshold for re(4) adapters.
This resolves a number of various bad symptoms experienced by
numerous users especially with the adapters at Gig speed.

Tested by quite a few users.

From FreeBSD/NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.76 2008/02/17 05:29:25 brad Exp $	*/
d1536 1
a1536 1
	u_int32_t	cmdstat, rl_flags = 0;
d1603 11
d1647 1
a1647 1
		d->rl_vlanctl = 0;
d1668 1
a1668 1
		d->rl_vlanctl = 0;
a1682 14

	/*
	 * Set up hardware VLAN tagging. Note: vlan tag info must
	 * appear in the first descriptor of a multi-descriptor
	 * transmission attempt.
	 */

#if NVLAN > 0
	if (ifv != NULL) {
		sc->rl_ldata.rl_tx_list[startidx].rl_vlanctl =
		    htole32(swap16(ifv->ifv_tag) |
		    RL_TDESC_VLANCTL_TAG);
	}
#endif
@


1.77.2.1
log
@VLAN tag info must be inserted into all descriptors of a multi-descriptor
packet transmission.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.77 2008/03/12 16:26:45 brad Exp $	*/
d1536 1
a1536 1
	u_int32_t	cmdstat, vlanctl, rl_flags = 0;
a1602 11
	 * Set up hardware VLAN tagging. Note: vlan tag info must
	 * appear in all descriptors of a multi-descriptor
	 * transmission attempt.
	 */
	vlanctl = 0;
#if NVLAN > 0
	if (ifv != NULL)
		vlanctl = swap16(ifv->ifv_tag) | RL_TDESC_VLANCTL_TAG;
#endif

	/*
d1636 1
a1636 1
		d->rl_vlanctl = htole32(vlanctl);
d1657 1
a1657 1
		d->rl_vlanctl = htole32(vlanctl);
d1672 14
@


1.76
log
@Simplify the hw revision handling by removing the use of the
rl_type softc field and only relying on the sc_hwrev softc
field thoughout the driver.

Tested by a number of users from tech@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.75 2008/01/16 09:52:34 brad Exp $	*/
d1871 2
a1872 1
	CSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);
@


1.75
log
@- Store the hw revision into a new softc field in re_attach() and reference
the softc field wherever it is necessary.
- Use a switch case in re_setmulti() to make things a bit easier to read.

ok henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.74 2007/07/16 19:15:01 millert Exp $	*/
d389 1
a389 1
	if (sc->rl_type == RL_8169) {
d436 1
a436 1
	if (sc->rl_type == RL_8139CPLUS && re8139_reg == RL_BMCR) {
d453 1
a453 1
	if (sc->rl_type == RL_8169) {
d467 1
a467 1
		if (sc->rl_type == RL_8139CPLUS) {
d674 3
a676 1
	if (sc->rl_type == RL_8169)
a677 2
	else
		phyaddr = 0;
d864 2
d870 5
a874 1
	if (sc->rl_type == RL_8169) {
a877 4
	} else {
		sc->rl_rxlenmask = RL_RDESC_STAT_FRAGLEN;
		sc->rl_txstart = RL_TXSTART;
		sc->rl_ldata.rl_tx_desc_cnt = RL_TX_DESC_CNT_8139;
a881 1
	sc->sc_hwrev = CSR_READ_4(sc, RL_TXCFG) & RL_TXCFG_HWREV;
d1006 1
a1006 1
	if (sc->rl_type == RL_8169)
d1051 1
a1051 1
	if (sc->rl_type == RL_8169) {
d1285 1
a1285 1
		if (sc->rl_type == RL_8169)
d1860 1
a1860 1
		if (sc->rl_type == RL_8169)
d1862 1
a1862 1
			    RL_TXCFG_CONFIG|RL_LOOPTEST_ON);
d1865 1
a1865 1
			    RL_TXCFG_CONFIG|RL_LOOPTEST_ON_CPLUS);
d1918 3
a1920 1
	if (sc->rl_type == RL_8169)
a1921 2
	else
		CSR_WRITE_4(sc, RL_TIMERINT, 0x400);
d1927 1
a1927 1
	if (sc->rl_type == RL_8169)
@


1.74
log
@The logic determining the value of rl_eewidth for the 9346 and 9356
eeproms was backwards.  This resulted in a bogus MAC address being
read from the eeprom on certain cards.  From FreeBSD.  OK pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.73 2007/06/06 22:02:31 pvalchev Exp $	*/
d512 1
a512 1
	u_int32_t		hwrev, rxfilt;
d567 6
a572 4
	hwrev = CSR_READ_4(sc, RL_TXCFG) & RL_TXCFG_HWREV;
	if (hwrev == RL_HWREV_8100E_SPIN1 || hwrev == RL_HWREV_8100E_SPIN2 ||
	    hwrev == RL_HWREV_8101E || hwrev == RL_HWREV_8168_SPIN1 ||
	    hwrev == RL_HWREV_8168_SPIN2) {
d575 2
a576 1
	} else {
a824 1
	u_int32_t	hwrev;
d880 1
a880 1
	hwrev = CSR_READ_4(sc, RL_TXCFG) & RL_TXCFG_HWREV;
d882 1
a882 1
		if (rr->re_chipid == hwrev)
d887 1
a887 1
		printf(": unknown ASIC (0x%04x)", hwrev >> 16);
d889 1
a889 1
		printf(": %s (0x%04x)", re_name, hwrev >> 16);
@


1.74.2.1
log
@Set the RX FIFO threshold to no RX threshold for re(4) adapters.
This resolves a number of various bad symptoms experienced by
numerous users especially with the adapters at Gig speed.

From FreeBSD/NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.74 2007/07/16 19:15:01 millert Exp $	*/
d1868 1
a1868 2
	CSR_WRITE_4(sc, RL_RXCFG,
	    RL_RXFIFO_NOTHRESH|RL_RX_MAXDMA|RL_RX_BUF_SZ);
@


1.74.2.2
log
@VLAN tag info must be inserted into all descriptors of a multi-descriptor
packet transmission.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.74.2.1 2008/03/21 20:34:16 brad Exp $	*/
d1533 1
a1533 1
	u_int32_t	cmdstat, vlanctl, rl_flags = 0;
a1599 11
	 * Set up hardware VLAN tagging. Note: vlan tag info must
	 * appear in all descriptors of a multi-descriptor
	 * transmission attempt.
	 */
	vlanctl = 0;
#if NVLAN > 0
	if (ifv != NULL)
		vlanctl = swap16(ifv->ifv_tag) | RL_TDESC_VLANCTL_TAG;
#endif

	/*
d1633 1
a1633 1
		d->rl_vlanctl = htole32(vlanctl);
d1654 1
a1654 1
		d->rl_vlanctl = htole32(vlanctl);
d1669 14
@


1.73
log
@add another revision "RTL8168 3"; from NetBSD via Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.72 2007/06/06 18:51:19 pvalchev Exp $	*/
d829 1
a829 1
	sc->rl_eewidth = 6;
d832 1
a832 1
		sc->rl_eewidth = 8;
@


1.72
log
@- Recognize the 8110SCe 8169 revision in re(4)
- Rename the existing 8110SC revision to 8110SCd to be consistent
info from the linux driver via Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.71 2007/05/08 21:19:42 deraadt Exp $	*/
d221 1
@


1.71
log
@non-static inline functions waste space
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.70 2007/05/05 12:10:57 jsg Exp $	*/
d216 1
a216 1
	{ RL_HWREV_8169_8110SC,	"RTL8169/8110SC" },
d225 1
@


1.70
log
@Properly ifdef debug bits to save a bit of space.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.69 2007/03/02 17:49:51 krw Exp $	*/
d161 1
a161 1
inline void re_set_bufaddr(struct rl_desc *, bus_addr_t);
d230 1
a230 1
inline void
@


1.69
log
@Fix and enable HW VLAN tagging.

From brad@@, tested by brad on i386/amd64/sparc64 and by maja@@ and ian@@
on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.68 2007/02/25 08:00:06 deraadt Exp $	*/
d154 1
d156 4
a159 1
#define DPRINTF(x)	if (redebug) printf x
@


1.69.2.1
log
@Set the RX FIFO threshold to no RX threshold for re(4) adapters.
This resolves a number of various bad symptoms experienced by
numerous users especially with the adapters at Gig speed.

From FreeBSD/NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.69 2007/03/02 17:49:51 krw Exp $	*/
d1862 1
a1862 2
	CSR_WRITE_4(sc, RL_RXCFG,
	    RL_RXFIFO_NOTHRESH|RL_RX_MAXDMA|RL_RX_BUF_SZ);
@


1.68
log
@dmesg should look like    devN at busN locators: device info
the locators are printed by the bus drivers, rest by the device's driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.67 2007/02/15 18:42:53 jason Exp $	*/
d1005 1
a1005 1
#ifdef RE_VLAN
d1152 1
a1525 3
#ifdef RE_VLAN
	struct m_tag	*mtag;
#endif
d1529 7
d1627 1
d1648 1
d1670 4
a1673 5
#ifdef RE_VLAN
	if (sc->ethercom.ec_nvlans &&
	    (mtag = m_tag_find(m_head, PACKET_TAG_VLAN, NULL)) != NULL)
		sc->rl_ldata.rl_tx_list[*idx].rl_vlanctl =
		    htole32(htons(*(u_int *)(mtag + 1)) |
d1675 1
@


1.67
log
@from linux->freebsd->brad->me, tested by matthieu, brad, kettenis, others...
looks like realtek reversed the order of multicast stuff on the PCI-E cards
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.66 2007/02/08 22:50:08 kettenis Exp $	*/
d879 1
a879 1
		printf(", unknown ASIC (0x%04x)", hwrev >> 16);
d881 1
a881 1
		printf(", %s (0x%04x)", re_name, hwrev >> 16);
d883 1
a883 1
	printf(": %s, address %s\n", intrstr,
@


1.66
log
@Don't clear IFF_OACTIVE in re_txeof() unless there are at least 4 free
TX descriptors. Further down the road re_encap() will bail if there
aren't at least 4 free TX descriptors, causing re_start() to abort
and set IFF_OACTIVE again.

From marius@@FreeBSD
Tested by me, brad@@, otto@@ and Emilio Parea.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.65 2007/02/03 01:55:00 krw Exp $	*/
d506 1
a506 1
	u_int32_t		rxfilt;
d554 17
a570 2
	CSR_WRITE_4(sc, RL_MAR0, hashes[0]);
	CSR_WRITE_4(sc, RL_MAR4, hashes[1]);
@


1.65
log
@Don't set the RL_CFG1_FULLDUPLEX bit. The RL_CFG1_FULLDUPLEX bit in
config register 1 is only valid with the 8129 chipset.

The rtl81x9reg.h header has this bit marked with a comment indicating
it is for the 8129 chipset and the 8168/8169 datasheets confirm that
this bit is not valid for the newer chipsets.

From yongari@@FreeBSD via brad. Tested by brad, kettenis and otto.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.64 2007/01/27 20:55:55 miod Exp $	*/
d1394 3
a1396 2
	if (sc->rl_ldata.rl_tx_free) {
		sc->rl_ldata.rl_txq_considx = idx;
a1397 1
	}
@


1.64
log
@When flooding dmesg with ``can't read/write phy register'', be nice enough to
print the register number, so that someone gets a chance to investigate the
problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.63 2007/01/26 15:29:10 jason Exp $	*/
d1904 1
a1904 1
	CSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);
@


1.63
log
@remove duplicate test; from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.62 2007/01/23 13:42:47 mglocker Exp $	*/
d425 1
a425 1
		printf("%s: bad phy register\n", sc->sc_dev.dv_xname);
d484 1
a484 1
		printf("%s: bad phy register\n", sc->sc_dev.dv_xname);
@


1.62
log
@adjust m_data and m_len directly rather than calling m_adj().

From tsutsui@@NetBSD over brad, some corrections by claudio@@, tested
by brad on sparc64 and otto@@ on landisk.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.61 2006/12/30 09:38:28 kettenis Exp $	*/
d1399 9
a1407 9
	/*
	 * Some chips will ignore a second TX request issued while an
	 * existing transmission is in progress. If the transmitter goes
	 * idle but there are still packets waiting to be sent, we need
	 * to restart the channel here to flush them out. This only seems
	 * to be required with the PCIe devices.
	 */
	if (sc->rl_ldata.rl_tx_free < RL_TX_DESC_CNT(sc))
	    CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START);
d1409 8
a1416 9
	/*
	 * If not all descriptors have been released reaped yet,
	 * reload the timer so that we will eventually get another
	 * interrupt that will cause us to re-enter this routine.
	 * This is done in case the transmitter has gone idle.
	 */
	if (sc->rl_ldata.rl_tx_free < RL_TX_DESC_CNT(sc))
                CSR_WRITE_4(sc, RL_TIMERCNT, 1);
	else
@


1.61
log
@Add flow control support.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.60 2006/12/21 05:15:06 drahn Exp $	*/
a1105 2
	m->m_len = m->m_pkthdr.len = MCLBYTES;
#ifdef __STRICT_ALIGNMENT
d1107 3
a1109 9
	 * This is part of an evil trick to deal with strict alignment
	 * architectures. The RealTek chip requires RX buffers to be
	 * aligned on 64-bit boundaries, but that will hose strict
	 * alignment architectures. To get around this, we leave some
	 * empty space at the start of each buffer and for strict
	 * alignment architectures, we copy the buffer back six
	 * bytes to achieve word alignment. This is slightly more
	 * efficient than allocating a new buffer, copying the
	 * contents, and discarding the old buffer.
d1111 2
a1112 2
	m_adj(m, RE_ETHER_ALIGN);
#endif
@


1.60
log
@re_fixup_rx() is a no-op function, other than copying data to the same address, thus slowing down the driver on __STRICT_ALIGN archs, remove. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.59 2006/12/20 23:26:52 deraadt Exp $	*/
d1004 1
a1004 1
	    MII_OFFSET_ANY, 0);
@


1.59
log
@remove debug message inserted in last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.58 2006/12/12 10:24:37 reyk Exp $	*/
a163 3
#ifdef __STRICT_ALIGNMENT
void	re_fixup_rx(struct mbuf *);
#endif
a1161 16
#ifdef __STRICT_ALIGNMENT
void
re_fixup_rx(struct mbuf *m)
{
	int		i;
	uint16_t	*src, *dst;

	src = mtod(m, uint16_t *);
	dst = src - (RE_ETHER_ALIGN - ETHER_ALIGN) / sizeof *src;

	for (i = 0; i < (m->m_len / sizeof(uint16_t) + 1); i++)
		*dst++ = *src++;

	m->m_data -= RE_ETHER_ALIGN - ETHER_ALIGN;
}
#endif
a1330 3
#ifdef __STRICT_ALIGNMENT
		re_fixup_rx(m);
#endif
@


1.58
log
@add a workaround for hardware ip4csum-tx bug on re(4) chips. the
hardware checksum could be mangled with 28 byte or less IP packets.

>From tsutsui@@NetBSD
Tested by otto@@ brad@@ and Han Boetes <han at mijncomputer dot nl>
Tested by maja@@ with the 8139C+ chipset
Tested on amd64/i386/sparc64

ok mglocker@@ brad@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.57 2006/12/01 01:13:01 todd Exp $	*/
a1656 1
		printf("%s: re_encap: padding\n", sc->sc_dev.dv_xname);
@


1.57
log
@rename 8100E id to spin 1 and add the 8100E second spin chip id
chip id from Linux r8169 driver
from brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.56 2006/11/28 23:00:13 brad Exp $	*/
d157 2
d229 10
d930 1
a930 1
	if ((error = bus_dmamem_alloc(sc->sc_dmat, RL_RX_LIST_SZ,
d940 1
a940 1
		    sc->rl_ldata.rl_rx_listnseg, RL_RX_LIST_SZ,
d948 1
a948 1
	memset(sc->rl_ldata.rl_rx_list, 0, RL_RX_LIST_SZ);
d950 2
a951 2
	if ((error = bus_dmamap_create(sc->sc_dmat, RL_RX_LIST_SZ, 1,
		    RL_RX_LIST_SZ, 0, 0,
d960 1
a960 1
		    RL_RX_LIST_SZ, NULL, BUS_DMA_NOWAIT)) != 0) {
d990 2
a991 6
	ifp->if_capabilities = IFCAP_VLAN_MTU;

#ifdef RE_CSUM_OFFLOAD
	ifp->if_capabilities |= IFCAP_CSUM_IPv4|IFCAP_CSUM_TCPv4|
				IFCAP_CSUM_UDPv4;
#endif
d1057 1
a1057 1
	    (caddr_t)sc->rl_ldata.rl_rx_list, RL_RX_LIST_SZ);
d1151 1
a1151 2
	d->rl_bufaddr_lo = htole32(RL_ADDR_LO(map->dm_segs[0].ds_addr));
	d->rl_bufaddr_hi = htole32(RL_ADDR_HI(map->dm_segs[0].ds_addr));
d1408 1
a1408 1
		sc->rl_ldata.rl_tx_free += txq->txq_dmamap->dm_nsegs;
d1540 1
a1540 1
	int		error, seg, uidx, startidx, curidx, lastidx;
a1550 1
#ifdef RE_CSUM_OFFLOAD
a1571 1
#endif
d1584 9
a1592 1
	if (map->dm_nsegs > sc->rl_ldata.rl_tx_free - RL_NTXDESC_RSVD) {
d1638 2
a1639 1
		cmdstat = map->dm_segs[seg].ds_len;
d1644 3
a1646 1
		if (seg == map->dm_nsegs - 1) {
d1650 14
d1666 1
a1666 5
		d->rl_cmdstat = htole32(cmdstat | rl_flags);
		d->rl_bufaddr_lo =
		    htole32(RL_ADDR_LO(map->dm_segs[seg].ds_addr));
		d->rl_bufaddr_hi =
		    htole32(RL_ADDR_HI(map->dm_segs[seg].ds_addr));
d1669 2
d1697 1
d1699 1
a1699 1
	sc->rl_ldata.rl_tx_free -= map->dm_nsegs;
@


1.56
log
@identify the chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.55 2006/11/28 20:04:02 brad Exp $	*/
d215 1
a215 1
	{ RL_HWREV_8100E,	"RTL8100E" },
d218 1
@


1.55
log
@move printing of the interrupt string into re_attach().
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.54 2006/11/24 04:27:17 brad Exp $	*/
d205 21
d791 3
d846 11
@


1.54
log
@replace a magic number (reserved TX descs?) with macro

From tsutsui@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.53 2006/11/18 15:54:29 brad Exp $	*/
d763 1
a763 1
re_attach(struct rl_softc *sc)
d823 1
a823 1
	printf(", address %s\n",
@


1.53
log
@- set descriptor DMA addresses before enabling TX and RX
- set RL_EARLY_TX_THRESH before starting TX and RX
- clear a TX timeout only if all queued packets are handled
- declare struct rl_txq separately
- minor style tweaks in re_txeof()

From tsutsui@@NetBSD

Tested by brad@@, maja@@ and kettenis@@
Tested on amd64/armish/i386/sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.52 2006/11/01 23:25:18 brad Exp $	*/
d872 2
a873 3
		    RL_TX_DESC_CNT(sc) - 4, RL_TDESC_CMD_FRAGLEN,
		    0, 0,
		    &sc->rl_ldata.rl_txq[i].txq_dmamap);
d1505 1
a1505 1
	if (sc->rl_ldata.rl_tx_free <= 4)
d1543 1
a1543 1
	if (map->dm_nsegs > sc->rl_ldata.rl_tx_free - 4) {
@


1.52
log
@Put common data for each RX DMA descriptor into a new rxsoft structure.

From tsutsui@@NetBSD

Tested by brad@@ otto@@
Tested on amd64/i386/sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.51 2006/10/31 22:45:15 brad Exp $	*/
d1342 3
a1344 1
	int		idx;
a1346 1
	idx = sc->rl_ldata.rl_txq_considx;
d1348 2
a1349 4
	for (;;) {
		struct rl_txq *txq = &sc->rl_ldata.rl_txq[idx];
		int descidx;
		u_int32_t txstat;
a1379 2

		idx = RL_NEXT_TXQ(sc, idx);
a1381 2
	/* No changes made to the TX ring, so no flush needed */

a1384 1
		ifp->if_timer = 0;
d1403 1
a1403 1
	if (sc->rl_ldata.rl_tx_free != RL_TX_DESC_CNT(sc))
d1405 2
d1464 1
a1464 2
		if ((status & RL_ISR_RX_OK) ||
		    (status & RL_ISR_RX_ERR)) {
d1469 2
a1470 3
		if ((status & RL_ISR_TIMEOUT_EXPIRED) ||
		    (status & RL_ISR_TX_ERR) ||
		    (status & RL_ISR_TX_DESC_UNAVAIL)) {
d1488 1
a1488 1
	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
d1776 13
d1805 3
a1846 15
	/*
	 * Load the addresses of the RX and TX lists into the chip.
	 */

	CSR_WRITE_4(sc, RL_RXLIST_ADDR_HI,
	    RL_ADDR_HI(sc->rl_ldata.rl_rx_list_map->dm_segs[0].ds_addr));
	CSR_WRITE_4(sc, RL_RXLIST_ADDR_LO,
	    RL_ADDR_LO(sc->rl_ldata.rl_rx_list_map->dm_segs[0].ds_addr));

	CSR_WRITE_4(sc, RL_TXLIST_ADDR_HI,
	    RL_ADDR_HI(sc->rl_ldata.rl_tx_list_map->dm_segs[0].ds_addr));
	CSR_WRITE_4(sc, RL_TXLIST_ADDR_LO,
	    RL_ADDR_LO(sc->rl_ldata.rl_tx_list_map->dm_segs[0].ds_addr));

	CSR_WRITE_1(sc, RL_EARLY_TX_THRESH, 16);
@


1.51
log
@- Rename a variable to clarify meaning of index.
- Rename RL_[TR]X_DESC_INC() macro to RL_NEXT_[TR]X_DESC() and
change them to return rvalues to avoid possible side effects.
- Also define RL_NEXT_TXQ() for rl_txq index and use it as well.

From tsutsui@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.50 2006/10/31 07:04:25 brad Exp $	*/
d589 1
d683 3
a685 3
	dmamap = sc->rl_ldata.rl_rx_dmamap[0];
	bus_dmamap_sync(sc->sc_dmat,
	    dmamap, 0, dmamap->dm_mapsize,
d687 1
a687 2
	bus_dmamap_unload(sc->sc_dmat,
	    sc->rl_ldata.rl_rx_dmamap[0]);
d689 2
a690 2
	m0 = sc->rl_ldata.rl_rx_mbuf[0];
	sc->rl_ldata.rl_rx_mbuf[0] = NULL;
d922 1
a922 1
                    0, 0, &sc->rl_ldata.rl_rx_dmamap[i]);
d1003 1
a1003 1
		if (sc->rl_ldata.rl_rx_dmamap[i] != NULL)
d1005 1
a1005 1
			    sc->rl_ldata.rl_rx_dmamap[i]);
d1048 1
d1082 2
a1083 2
	map = sc->rl_ldata.rl_rx_dmamap[idx];

d1086 1
d1103 2
a1115 2
	sc->rl_ldata.rl_rx_mbuf[idx] = m;

a1167 2
	memset((char *)&sc->rl_ldata.rl_rx_mbuf, 0,
	    (RL_RX_DESC_CNT * sizeof(struct mbuf *)));
d1192 1
d1206 2
a1207 1
		m = sc->rl_ldata.rl_rx_mbuf[i];
d1212 1
a1212 2
		    sc->rl_ldata.rl_rx_dmamap[i],
		    0, sc->rl_ldata.rl_rx_dmamap[i]->dm_mapsize,
d1214 1
a1214 2
		bus_dmamap_unload(sc->sc_dmat,
		    sc->rl_ldata.rl_rx_dmamap[i]);
d2056 1
a2056 1
		if (sc->rl_ldata.rl_rx_mbuf[i] != NULL) {
d2058 3
a2060 3
			    sc->rl_ldata.rl_rx_dmamap[i]);
			m_freem(sc->rl_ldata.rl_rx_mbuf[i]);
			sc->rl_ldata.rl_rx_mbuf[i] = NULL;
@


1.50
log
@- Make DMA descripter members volatile
- Remove usage of BUS_DMA_ALLOCNOW with bus_dmamap_create
- Use BUS_DMA_COHERENT on mapping DMA memory for TX/RX descriptors
- Adjust m_data and m_len directly rather than calling m_adj
- Proper use of bus_dmamap_sync against DMA descriptors

From tsutsui@@NetBSD

Tested by kettenis@@ brad@@ otto@@
Tested on armish/amd64/i386/sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.49 2006/10/22 21:19:22 brad Exp $	*/
d1196 1
a1196 1
	for (i = sc->rl_ldata.rl_rx_prodidx;; RL_RX_DESC_INC(sc, i)) {
d1382 1
a1382 1
		idx = (idx + 1) % RL_TX_QLEN;
d1504 1
a1504 1
	int		error, i, uidx, startidx, curidx;
a1572 1
	i = 0;
d1574 3
a1576 1
	for (;;) {
d1585 2
a1586 2
			while (i > 0) {
				uidx = (curidx + RL_TX_DESC_CNT(sc) - i) %
a1590 1
				i--;
d1596 2
a1597 2
		cmdstat = map->dm_segs[i].ds_len;
		if (i == 0)
d1601 1
a1601 1
		if (i == map->dm_nsegs - 1)
d1603 2
d1609 1
a1609 1
		    htole32(RL_ADDR_LO(map->dm_segs[i].ds_addr));
d1611 1
a1611 1
		    htole32(RL_ADDR_HI(map->dm_segs[i].ds_addr));
a1613 4
		i++;
		if (i == map->dm_nsegs)
			break;
		RL_TX_DESC_INC(sc, curidx);
d1615 1
a1615 3

	txq->txq_mbuf = m;
	sc->rl_ldata.rl_tx_free -= map->dm_nsegs;
d1637 5
a1641 2
	txq->txq_descidx = curidx;
	RL_TX_DESC_INC(sc, curidx);
d1643 2
a1644 1
	*idx = (*idx + 1) % RL_TX_QLEN;
@


1.49
log
@DMA memory for the TX ring should be aligned at RL_RING_ALIGN,
not RE_ETHER_ALIGN.

From tsutsui@@NetBSD

Tested on alpha/amd64/armish/i386/sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.48 2006/10/16 20:37:25 brad Exp $	*/
a681 4
	dmamap = sc->rl_ldata.rl_rx_list_map;
	bus_dmamap_sync(sc->sc_dmat,
	    dmamap, 0, dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD);
d693 1
a694 1
	total_len = RL_RXBYTES(cur_rx);
d696 1
d845 1
a845 1
		    BUS_DMA_NOWAIT)) != 0) {
d853 1
a853 1
		    RL_TX_LIST_SZ(sc), 0, BUS_DMA_ALLOCNOW,
d873 1
a873 1
		    0, BUS_DMA_ALLOCNOW,
d895 1
a895 1
		    BUS_DMA_NOWAIT)) != 0) {
d904 1
a904 1
		    RL_RX_LIST_SZ, 0, BUS_DMA_ALLOCNOW,
d922 1
a922 1
                    0, BUS_DMA_ALLOCNOW, &sc->rl_ldata.rl_rx_dmamap[i]);
a1054 1
		m = n;
d1056 3
a1058 3
		MCLGET(m, M_DONTWAIT);
		if (! (m->m_flags & M_EXT)) {
			m_freem(m);
d1061 1
d1088 3
d1092 6
a1097 1
	if (letoh32(d->rl_cmdstat) & RL_RDESC_STAT_OWN)
d1099 1
d1102 2
a1105 2
	if (idx == (RL_RX_DESC_CNT - 1))
		cmdstat |= RL_RDESC_CMD_EOR;
d1107 4
a1111 1
	sc->rl_ldata.rl_rx_list[idx].rl_cmdstat |= htole32(RL_RDESC_CMD_OWN);
a1113 4
        bus_dmamap_sync(sc->sc_dmat, sc->rl_ldata.rl_rx_dmamap[idx], 0,
            sc->rl_ldata.rl_rx_dmamap[idx]->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

d1115 1
a1115 1
out:
d1150 2
a1151 1
	    sc->rl_ldata.rl_tx_list_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
a1173 7
	/* Flush the RX descriptors */

	bus_dmamap_sync(sc->sc_dmat,
	    sc->rl_ldata.rl_rx_list_map,
	    0, sc->rl_ldata.rl_rx_list_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

a1194 8
	i = sc->rl_ldata.rl_rx_prodidx;

	/* Invalidate the descriptor memory */

	bus_dmamap_sync(sc->sc_dmat,
	    sc->rl_ldata.rl_rx_list_map,
	    0, sc->rl_ldata.rl_rx_list_map->dm_mapsize,
	    BUS_DMASYNC_POSTREAD);
d1196 1
a1196 1
	while (!RL_OWN(&sc->rl_ldata.rl_rx_list[i])) {
d1198 7
a1205 2
		total_len = RL_RXBYTES(cur_rx);
		rxstat = letoh32(cur_rx->rl_cmdstat);
a1225 1
			RL_RX_DESC_INC(sc, i);
a1263 1
			RL_RX_DESC_INC(sc, i);
a1278 1
			RL_RX_DESC_INC(sc, i);
a1281 2
		RL_RX_DESC_INC(sc, i);

a1334 7
	/* Flush the RX DMA ring */

	bus_dmamap_sync(sc->sc_dmat,
	    sc->rl_ldata.rl_rx_list_map,
	    0, sc->rl_ldata.rl_rx_list_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

d1347 1
a1347 8
	/* Invalidate the TX descriptor list */

	bus_dmamap_sync(sc->sc_dmat,
	    sc->rl_ldata.rl_tx_list_map,
	    0, sc->rl_ldata.rl_tx_list_map->dm_mapsize,
	    BUS_DMASYNC_POSTREAD);

	while (/* CONSTCOND */ 1) {
d1358 2
d1362 1
d1369 2
d1504 1
a1504 1
	int		error, i, startidx, curidx;
d1575 1
a1575 1
	while (1) {
d1577 7
a1583 1
		if (letoh32(d->rl_cmdstat) & RL_TDESC_STAT_OWN) {
d1585 5
a1589 3
				sc->rl_ldata.rl_tx_list[
				    (curidx + RL_TX_DESC_CNT(sc) - i) %
				    RL_TX_DESC_CNT(sc)].rl_cmdstat = 0;
a1596 4
		d->rl_bufaddr_lo =
		    htole32(RL_ADDR_LO(map->dm_segs[i].ds_addr));
		d->rl_bufaddr_hi =
		    htole32(RL_ADDR_HI(map->dm_segs[i].ds_addr));
d1601 2
d1606 6
a1617 2
	d->rl_cmdstat |= htole32(RL_TDESC_CMD_EOF);

d1637 1
a1637 1
	sc->rl_ldata.rl_tx_list[curidx].rl_cmdstat |=
d1639 1
a1639 3
	if (startidx != curidx)
		sc->rl_ldata.rl_tx_list[startidx].rl_cmdstat |=
		    htole32(RL_TDESC_CMD_OWN);
d1670 1
a1670 1
	while (/* CONSTCOND */ 1) {
a1716 7

	/* Flush the TX descriptors */

	bus_dmamap_sync(sc->sc_dmat,
	    sc->rl_ldata.rl_tx_list_map,
	    0, sc->rl_ldata.rl_tx_list_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
@


1.48
log
@Fix for watchdog timeouts experienced with some Realtek adapters.

From wpaul@@FreeBSD

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.47 2006/09/29 17:35:45 brad Exp $	*/
d837 1
a837 1
		    RE_ETHER_ALIGN, 0, &sc->rl_ldata.rl_tx_listseg, 1,
@


1.47
log
@Only run the hardware diagnostic function re_diag() on adapters with
the 8169 chipset, it is disabled by default anyway.

Reset the TX interrupt mitigation counter in re_start() if no packets
were queued and there are still TX descriptors in use.

Write to the ISR and clear the link state in re_init().

From wpaul@@FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.46 2006/09/18 21:33:32 dim Exp $	*/
d1405 1
a1405 1
	if (idx != sc->rl_ldata.rl_txq_considx) {
@


1.46
log
@Fix for re_stop() being called from re_cardbus_shutdown() with the
wrong arguments, causing uvm_fault on halt/reboot, with a cardbus re
inserted.  While here, cleanup prototypes and use revar.h everywhere.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.45 2006/09/17 18:18:57 brad Exp $	*/
d990 8
a997 6
	error = re_diag(sc);
	if (error) {
		printf("%s: attach aborted due to hardware diag failure\n",
		    sc->sc_dev.dv_xname);
		ether_ifdetach(ifp);
		goto fail_8;
d1720 3
a1722 1
	if (queued == 0)
d1724 1
d1846 1
d1900 2
@


1.45
log
@Re-add the link state check to re_start(), which was added in rev 1.31 and
removed in rev 1.43 just before release, as a workaround for a link state
issue found with the 8139C+ chips. Due to the different bit layout used by
the 8139C+ chips rlphy(4) was not reporting the correct link status.

Fix from yongary@@FreeBSD
Tested by maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.44 2006/09/15 23:39:24 drahn Exp $	*/
d152 1
a156 2
int	re_attach(struct rl_softc *);

a166 1
int	re_intr(void *);
a169 2
int	re_init(struct ifnet *);
void	re_stop(struct ifnet *, int);
@


1.44
log
@Kettenis's polished version of diff to preserve the mac address on thecus,
if the hardware mac is a specific number (hardware doesn't provide
unique mac addresses except in redboot fconfig data). yes deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.43 2006/08/17 23:08:07 brad Exp $	*/
d403 4
d434 4
d1678 1
a1678 1
	if (ifp->if_flags & IFF_OACTIVE)
@


1.43
log
@Remove the link state check from re_start() for now. Allows the 8139C+
based adapters to work again.

Issue reported by and workaround tested by maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.42 2006/08/06 06:18:28 brad Exp $	*/
d745 12
d785 20
@


1.42
log
@fix swapping of the station address for big-endian archs.

From yongari@@FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.41 2006/08/06 06:00:10 brad Exp $	*/
d1638 1
a1638 1
	if (!sc->rl_link || ifp->if_flags & IFF_OACTIVE)
@


1.41
log
@fix the config space macro used with the TX start command.

From wpaul@@FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.40 2006/08/06 05:18:22 brad Exp $	*/
d283 1
a283 1
		*ptr = letoh16(word);
d753 1
a753 1
	u_int16_t	as[3];
d770 3
a772 4
	for (i = 0; i < 3; i++) {
		eaddr[(i * 2) + 0] = as[i] & 0xff;
		eaddr[(i * 2) + 1] = as[i] >> 8;
	}
@


1.40
log
@With the PCIe devices, it looks as if issuing a TX command while
there is already a transmission in progress has no effect. In other
words, if you send two packets in rapid succession, the second one may
end up sitting in the TX DMA ring until another transmit command is
issued later in the future. Basically, if re_txeof() sees that there
are still descriptors outstanding, it needs to manually resume the
TX DMA channel by issuing another TX command to make sure all
transmissions are flushed out. (The PCI devices seem to keep the
TX channel moving until all descriptors have been consumed. I'm not
sure why the PCIe devices behave differently.)

From wpaul@@FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.39 2006/08/05 21:38:20 brad Exp $	*/
d1695 1
a1695 1
	CSR_WRITE_2(sc, sc->rl_txstart, RL_TXSTART_START);
@


1.39
log
@- move the promiscuous mode handling code into re_setpromisc().
- have the NIC track the state and only set the promisc filter
if IFF_PROMISC is adjusted, otherwise only init the NIC if it
is not already running.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.38 2006/08/05 21:03:22 brad Exp $	*/
d1373 10
@


1.38
log
@- restructure the TX descriptor handling code to decouple the
  number of TX descriptors, the number of RX descriptors, and
  the number of mbufs.
- bump the number of TX descriptors for the rtl8169 chipset.

From yamt@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.37 2006/08/05 16:53:16 brad Exp $	*/
d190 1
d524 16
d906 1
a906 2
	if (sc->rl_type == RL_8169) {
		ifp->if_baudrate = 1000000000;
a907 2
	} else
		ifp->if_baudrate = 100000000;
a1770 7
	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		rxcfg |= RL_RXCFG_RX_ALLPHYS;
	else
		rxcfg &= ~RL_RXCFG_RX_ALLPHYS;
	CSR_WRITE_4(sc, RL_RXCFG, rxcfg);

d1778 1
d1781 3
d1902 2
a1903 1
		switch (ifa->ifa_addr->sa_family) {
d1905 1
a1905 2
		case AF_INET:
			re_init(ifp);
a1906 1
			break;
a1907 4
		default:
			re_init(ifp);
			break;
		}
d1910 1
a1910 5
		if (ifr->ifr_mtu < ETHERMIN ||
		    ((sc->rl_type == RL_8169 &&
		    ifr->ifr_mtu > RL_JUMBO_MTU) ||
		    (sc->rl_type == RL_8139 &&
		    ifr->ifr_mtu > ETHERMTU)))
d1917 8
a1924 1
			re_init(ifp);
d1929 1
a1929 1
		error = 0;
@


1.37
log
@Use IFQ_POLL/IFQ_DEQUEUE instead of IFQ_DEQUEUE/IF_PREPEND.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.36 2006/07/06 00:06:51 drahn Exp $	*/
d663 2
a664 1
	    dmamap, 0, dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
d666 3
a668 2
	bus_dmamap_sync(sc->sc_dmat, dmamap, 0, dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE);
d758 4
a761 1
	/* Set RX length mask */
d765 1
d769 1
d777 6
d784 1
a784 1
	if ((error = bus_dmamem_alloc(sc->sc_dmat, RL_TX_LIST_SZ,
d794 1
a794 1
		    sc->rl_ldata.rl_tx_listnseg, RL_TX_LIST_SZ,
d801 1
a801 1
	memset(sc->rl_ldata.rl_tx_list, 0, RL_TX_LIST_SZ);
d803 2
a804 2
	if ((error = bus_dmamap_create(sc->sc_dmat, RL_TX_LIST_SZ, 1,
		    RL_TX_LIST_SZ, 0, BUS_DMA_ALLOCNOW,
d813 1
a813 1
		    RL_TX_LIST_SZ, NULL, BUS_DMA_NOWAIT)) != 0) {
d820 6
a825 4
	for (i = 0; i < RL_TX_DESC_CNT; i++) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES * RL_NTXSEGS,
		    RL_NTXSEGS, MCLBYTES, 0, BUS_DMA_ALLOCNOW,
		    &sc->rl_ldata.rl_tx_dmamap[i]);
d894 1
a894 1
	IFQ_SET_MAXLEN(&ifp->if_snd, RL_IFQ_MAXLEN);
a916 1
	DPRINTF(("calling mii_attach\n"));
d950 1
a950 2
	DPRINTF(("leaving re_attach\n"));
	return (1);
d973 2
a974 2
	for (i = 0; i < RL_TX_DESC_CNT; i++) {
		if (sc->rl_ldata.rl_tx_dmamap[i] != NULL)
d976 1
a976 1
			    sc->rl_ldata.rl_tx_dmamap[i]);
d985 1
a985 1
	    (caddr_t)sc->rl_ldata.rl_tx_list, RL_TX_LIST_SZ);
d1035 2
a1036 1
	error = bus_dmamap_load_mbuf(sc->sc_dmat, map, m, BUS_DMA_NOWAIT);
a1046 1
	cmdstat |= RL_TDESC_CMD_SOF;
d1048 1
a1048 1
		cmdstat |= RL_TDESC_CMD_EOR;
a1050 2
	d->rl_cmdstat |= htole32(RL_TDESC_CMD_EOF);

d1085 6
a1090 3
	memset((char *)sc->rl_ldata.rl_tx_list, 0, RL_TX_LIST_SZ);
	memset((char *)&sc->rl_ldata.rl_tx_mbuf, 0,
	    (RL_TX_DESC_CNT * sizeof(struct mbuf *)));
d1095 4
a1098 3
	sc->rl_ldata.rl_tx_prodidx = 0;
	sc->rl_ldata.rl_tx_considx = 0;
	sc->rl_ldata.rl_tx_free = RL_TX_DESC_CNT;
d1165 1
a1165 1
		    BUS_DMASYNC_POSTWRITE);
d1179 1
a1179 1
			RL_DESC_INC(i);
d1218 1
a1218 1
			RL_DESC_INC(i);
d1234 1
a1234 1
			RL_DESC_INC(i);
d1238 1
a1238 1
		RL_DESC_INC(i);
a1306 1
	u_int32_t	txstat;
d1310 1
a1310 1
	idx = sc->rl_ldata.rl_tx_considx;
d1319 14
a1332 2
	while (idx != sc->rl_ldata.rl_tx_prodidx) {
		txstat = letoh32(sc->rl_ldata.rl_tx_list[idx].rl_cmdstat);
d1336 12
a1347 6
		/*
		 * We only stash mbufs in the last descriptor
		 * in a fragment chain, which also happens to
		 * be the only place where the TX status bits
		 * are valid.
		 */
d1349 1
a1349 15
		if (txstat & RL_TDESC_CMD_EOF) {
			m_freem(sc->rl_ldata.rl_tx_mbuf[idx]);
			sc->rl_ldata.rl_tx_mbuf[idx] = NULL;
			bus_dmamap_unload(sc->sc_dmat,
			    sc->rl_ldata.rl_tx_dmamap[idx]);
			if (txstat & (RL_TDESC_STAT_EXCESSCOL|
			    RL_TDESC_STAT_COLCNT))
				ifp->if_collisions++;
			if (txstat & RL_TDESC_STAT_TXERRSUM)
				ifp->if_oerrors++;
			else
				ifp->if_opackets++;
		}
		sc->rl_ldata.rl_tx_free++;
		RL_DESC_INC(idx);
d1354 2
a1355 2
	if (idx != sc->rl_ldata.rl_tx_considx) {
		sc->rl_ldata.rl_tx_considx = idx;
d1366 1
a1366 1
	if (sc->rl_ldata.rl_tx_free != RL_TX_DESC_CNT)
d1461 1
a1461 1
	int		error, i, curidx;
d1467 1
d1496 4
a1499 3
	map = sc->rl_ldata.rl_tx_dmamap[*idx];

	error = bus_dmamap_load_mbuf(sc->sc_dmat, map, m, BUS_DMA_NOWAIT);
d1513 7
d1531 1
a1531 1
	curidx = *idx;
d1534 1
a1534 1
		if (letoh32(d->rl_cmdstat) & RL_RDESC_STAT_OWN) {
d1537 2
a1538 2
				    (curidx + RL_TX_DESC_CNT - i) %
				    RL_TX_DESC_CNT].rl_cmdstat = 0;
d1554 1
a1554 1
		if (curidx == (RL_RX_DESC_CNT - 1))
d1560 1
a1560 1
		RL_DESC_INC(curidx);
d1565 1
a1565 9
	/*
	 * Ensure that the map for this transmission
	 * is placed at the array index of the last descriptor
	 * in this chain.  (Swap last and first dmamaps.)
	 */
	sc->rl_ldata.rl_tx_dmamap[*idx] =
	    sc->rl_ldata.rl_tx_dmamap[curidx];
	sc->rl_ldata.rl_tx_dmamap[curidx] = map;
	sc->rl_ldata.rl_tx_mbuf[curidx] = m;
a1583 5
	bus_dmamap_sync(sc->sc_dmat,
	    sc->rl_ldata.rl_tx_dmamap[curidx],
	    0, sc->rl_ldata.rl_tx_dmamap[curidx]->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

d1586 2
a1587 2
	if (*idx != curidx)
		sc->rl_ldata.rl_tx_list[*idx].rl_cmdstat |=
d1590 4
a1593 2
	RL_DESC_INC(curidx);
	*idx = curidx;
d1618 2
a1619 2
	idx = sc->rl_ldata.rl_tx_prodidx;
	while (sc->rl_ldata.rl_tx_mbuf[idx] == NULL) {
d1627 6
d1635 1
a1635 1
		    sc->rl_ldata.rl_tx_free == RL_TX_DESC_CNT) {
d1662 2
a1670 6
	sc->rl_ldata.rl_tx_prodidx = idx;

	/*
	 * RealTek put the TX poll request register in a different
	 * location on the 8169 gigE chip. I don't know why.
	 */
d2000 2
a2001 2
	for (i = 0; i < RL_TX_DESC_CNT; i++) {
		if (sc->rl_ldata.rl_tx_mbuf[i] != NULL) {
d2003 3
a2005 3
			    sc->rl_ldata.rl_tx_dmamap[i]);
			m_freem(sc->rl_ldata.rl_tx_mbuf[i]);
			sc->rl_ldata.rl_tx_mbuf[i] = NULL;
@


1.36
log
@Write the mac address into the registers CORRECTLY!
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.35 2006/07/03 02:28:39 brad Exp $	*/
a1594 1
	struct mbuf	*m_head = NULL;
d1604 1
d1607 2
a1608 2
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL)
d1611 1
a1611 1
		error = re_encap(sc, m_head, &idx);
d1614 2
a1616 1
			m_freem(m_head);
a1619 1
			IF_PREPEND(&ifp->if_snd, m_head);
d1623 4
d1633 1
a1633 1
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
a1634 1
		queued++;
@


1.35
log
@- re_attach(): Use bus_dma* directly instead of calling re_allocmem().
- re_attach(): Free bus_dma* resources if attach fails.
- re_newbuf(): Remove unnecessary error check.
- re_encap(): Better error handling.
- re_start(): Drop the packet if there are not enough TX descriptors.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.34 2006/07/02 03:20:48 brad Exp $	*/
d1702 2
a1704 2
	CSR_WRITE_4(sc, RL_IDR0,
	    htole32(*(u_int32_t *)(&eaddr.eaddr[4])));
@


1.34
log
@put writing of RL_IDR0 and RL_IDR4 back to how they should be.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.33 2006/07/01 21:48:08 brad Exp $	*/
d156 1
a156 1
void	re_attach(struct rl_softc *);
a159 1
int	re_allocmem(struct rl_softc *);
a725 90
int
re_allocmem(struct rl_softc *sc)
{
	int	error;
	int	nseg, rseg;
	int	i;

	nseg = 32;

	/* Allocate DMA'able memory for the TX ring */

	error = bus_dmamap_create(sc->sc_dmat, RL_TX_LIST_SZ, 1,
	    RL_TX_LIST_SZ, 0, BUS_DMA_ALLOCNOW,
	    &sc->rl_ldata.rl_tx_list_map);
        if (error)
                return (ENOMEM);
        error = bus_dmamem_alloc(sc->sc_dmat, RL_TX_LIST_SZ,
	    ETHER_ALIGN, 0, 
	    &sc->rl_ldata.rl_tx_listseg, 1, &rseg, BUS_DMA_NOWAIT);
        if (error)
                return (ENOMEM);

	/* Load the map for the TX ring. */
	error = bus_dmamem_map(sc->sc_dmat, &sc->rl_ldata.rl_tx_listseg,
	    1, RL_TX_LIST_SZ,
	    (caddr_t *)&sc->rl_ldata.rl_tx_list, BUS_DMA_NOWAIT);
        if (error)
                return (ENOMEM);
	memset(sc->rl_ldata.rl_tx_list, 0, RL_TX_LIST_SZ);

	error = bus_dmamap_load(sc->sc_dmat, sc->rl_ldata.rl_tx_list_map,
	    sc->rl_ldata.rl_tx_list, RL_TX_LIST_SZ, NULL, BUS_DMA_NOWAIT);
        if (error)
                return (ENOMEM);

	/* Create DMA maps for TX buffers */

	for (i = 0; i < RL_TX_DESC_CNT; i++) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES * nseg, nseg,
		    MCLBYTES, 0, BUS_DMA_ALLOCNOW,
		    &sc->rl_ldata.rl_tx_dmamap[i]);
		if (error) {
			printf("%s: can't create DMA map for TX\n",
			    sc->sc_dev.dv_xname);
			return (ENOMEM);
		}
	}

	/* Allocate DMA'able memory for the RX ring */

	error = bus_dmamap_create(sc->sc_dmat, RL_RX_LIST_SZ, 1,
	    RL_RX_LIST_SZ, 0, BUS_DMA_ALLOCNOW,
	    &sc->rl_ldata.rl_rx_list_map);
        if (error)
                return (ENOMEM);

        error = bus_dmamem_alloc(sc->sc_dmat, RL_RX_LIST_SZ, RL_RING_ALIGN,
	    0, &sc->rl_ldata.rl_rx_listseg, 1, &rseg, BUS_DMA_NOWAIT);
        if (error)
                return (ENOMEM);

	/* Load the map for the RX ring. */
	error = bus_dmamem_map(sc->sc_dmat, &sc->rl_ldata.rl_rx_listseg,
	    1, RL_RX_LIST_SZ,
	    (caddr_t *)&sc->rl_ldata.rl_rx_list, BUS_DMA_NOWAIT);
        if (error)
                return (ENOMEM);
	memset(sc->rl_ldata.rl_rx_list, 0, RL_RX_LIST_SZ);

	error = bus_dmamap_load(sc->sc_dmat, sc->rl_ldata.rl_rx_list_map,
	     sc->rl_ldata.rl_rx_list, RL_RX_LIST_SZ, NULL, BUS_DMA_NOWAIT);
        if (error)
                return (ENOMEM);

	/* Create DMA maps for RX buffers */

	for (i = 0; i < RL_RX_DESC_CNT; i++) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES * nseg, nseg,
		    MCLBYTES, 0, BUS_DMA_ALLOCNOW,
		    &sc->rl_ldata.rl_rx_dmamap[i]);
		if (error) {
			printf("%s: can't create DMA map for RX\n",
			    sc->sc_dev.dv_xname);
			return (ENOMEM);
		}
	}

	return (0);
}

d730 1
a730 1
void
d770 84
a853 1
	error = re_allocmem(sc);
d855 10
a864 2
	if (error)
		return;
d932 1
a932 1
		return;
d937 41
d1021 1
a1022 3

	if (map->dm_nsegs > 1)
		goto out;
d1440 1
a1440 1
re_encap(struct rl_softc *sc, struct mbuf *m_head, int *idx)
d1467 1
a1467 1
	if ((m_head->m_pkthdr.csum_flags &
d1470 1
a1470 1
		if (m_head->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
d1472 1
a1472 1
		if (m_head->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
a1477 2
	error = bus_dmamap_load_mbuf(sc->sc_dmat, map,
	    m_head, BUS_DMA_NOWAIT);
d1479 1
d1481 1
d1484 6
a1489 1
		return (ENOBUFS);
a1491 2
	if (map->dm_nsegs > sc->rl_ldata.rl_tx_free - 4)
		return (ENOBUFS);
d1507 10
a1516 2
		if (letoh32(d->rl_cmdstat) & RL_RDESC_STAT_OWN)
			return (ENOBUFS);
d1546 1
a1546 1
	sc->rl_ldata.rl_tx_mbuf[curidx] = m_head;
d1580 5
d1605 2
d1611 8
a1618 1
		if (re_encap(sc, m_head, &idx)) {
@


1.33
log
@(fxp/re)_attach_common -> (fxp/re)_attach
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.32 2006/06/30 06:17:55 brad Exp $	*/
d1637 2
a1639 2
	    htole32(*(u_int32_t *)(&eaddr.eaddr[0])));
	CSR_WRITE_4(sc, RL_IDR4,
@


1.32
log
@- add a disable argument for re_stop.
- call mii_down in re_stop.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.31 2006/06/29 20:41:19 brad Exp $	*/
d156 1
a156 1
void	re_attach_common(struct rl_softc *);
d822 1
a822 1
re_attach_common(struct rl_softc *sc)
@


1.31
log
@Finally fix the EEPROM reading code so that we can access the EEPROMs on all
devices. In order to access the EEPROM, we must select 'EEPROM programming'
mode, and then set the EEPROM chip select bit. Previously, we were setting
both bits simultaneously, which doesn't work: they must be set in the
right sequence.

Always obtain the station address from the EEPROM, now that EEPROM
reading works correctly.

Have re_tick() check for link state and set rl_link appropriately, if
there is a link then also check if the send queue is empty and if
not then try to send any queued packets.

Have re_start() check for the lack of link state or if OACTIVE is set,
if so then return.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.30 2006/06/27 07:41:05 brad Exp $	*/
d174 1
a174 1
void	re_stop(struct rl_softc *);
d717 1
a717 1
	re_stop(sc);
d1620 1
a1620 1
	re_stop(sc);
d1833 1
a1833 1
				re_stop(sc);
d1890 1
a1890 1
re_stop(struct rl_softc *sc)
d1892 1
a1892 1
	struct ifnet *ifp;
d1895 2
a1896 1
	ifp = &sc->sc_arpcom.ac_if;
a1897 1

d1903 2
a1914 1

a1924 1

@


1.30
log
@- Make re_diag() off by default.
- Update comment to mention newer chip revisions.

From wpaul FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.29 2006/06/27 05:53:37 brad Exp $	*/
d181 1
a181 1
void	re_read_eeprom(struct rl_softc *, caddr_t, int, int, int);
d217 1
a217 1
	d = addr | sc->rl_eecmd_read;
d222 2
a223 1
	for (i = 0x400; i; i >>= 1) {
a244 3
	/* Enter EEPROM access mode. */
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);

a249 2
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);

a261 3
	/* Turn off EEPROM access mode. */
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);

d269 1
a269 2
re_read_eeprom(struct rl_softc *sc, caddr_t dest, int off,
    int cnt, int swap)
d274 4
d279 1
d281 1
d283 1
a283 4
		if (swap)
			*ptr = ntohs(word);
		else
			*ptr = word;
d285 2
d833 15
a848 1
		/* Set RX length mask */
a849 1

a850 13

		/* Force station address autoload from the EEPROM */
		CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_AUTOLOAD);
		for (i = 0; i < RL_TIMEOUT; i++) {
			if (!(CSR_READ_1(sc, RL_EECMD) & RL_EEMODE_AUTOLOAD))
				break;
			DELAY(100);
		}
		if (i == RL_TIMEOUT)
			printf ("%s: eeprom autoload timed out\n", sc->sc_dev.dv_xname);

			for (i = 0; i < ETHER_ADDR_LEN; i++)
				eaddr[i] = CSR_READ_1(sc, RL_IDR0 + i);
a851 1
		/* Set RX length mask */
a852 1

a853 14

		sc->rl_eecmd_read = RL_EECMD_READ_6BIT;
		re_read_eeprom(sc, (caddr_t)&re_did, 0, 1, 0);
		if (re_did != 0x8129)
			sc->rl_eecmd_read = RL_EECMD_READ_8BIT;

		/*
		 * Get station address from the EEPROM.
		 */
		re_read_eeprom(sc, (caddr_t)as, RL_EE_EADDR, 3, 0);
		for (i = 0; i < 3; i++) {
			eaddr[(i * 2) + 0] = as[i] & 0xff;
			eaddr[(i * 2) + 1] = as[i] >> 8;
		}
d1317 2
d1321 3
d1325 13
a1337 1
	mii_tick(&sc->sc_mii);
d1545 3
a1608 1
	u_int32_t	reg;
d1610 4
d1635 1
d1637 4
a1640 8

	reg = 0;
	memcpy(&reg, LLADDR(ifp->if_sadl) + 4, 4);
	CSR_WRITE_4(sc, RL_IDR4, htole32(reg));

	memcpy(&reg, LLADDR(ifp->if_sadl), 4);
	CSR_WRITE_4(sc, RL_IDR0, htole32(reg));

@


1.29
log
@- add fixup code in the RX path for strict alignment architectures.
- add a workaround for reception of Jumbo frames.
- don't try to adjust alignment on non-strict alignment architectures,
  this resolves an issue with the PCI Express adapters.

From FreeBSD

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.28 2006/06/24 02:36:15 brad Exp $	*/
d46 2
a47 2
 * four devices in this family: the RTL8139C+, the RTL8169, the RTL8169S
 * and the RTL8110S.
d193 1
d195 1
d544 2
d576 1
a576 1
	int			total_len, i, s, error = 0;
d598 1
d600 19
a618 1
	re_stop(sc);
a619 1
	re_init(ifp);
d647 1
d718 1
d728 2
a836 1

d838 1
d840 1
a840 1
		sc->rl_rxlenmask = RL_RDESC_STAT_GFRAGLEN;
a842 1

a854 1

d856 1
d858 1
a858 1
		sc->rl_rxlenmask = RL_RDESC_STAT_FRAGLEN;
d940 6
a945 1
	/* Perform hardware diagnostic. */
a946 1

d953 1
d1364 1
a1364 1
		if (status) {
a1365 1
		}
d1585 1
a1585 5

	if (sc->rl_type == RL_8169)
		CSR_WRITE_2(sc, RL_GTXSTART, RL_TXSTART_START);
	else
		CSR_WRITE_2(sc, RL_TXSTART, RL_TXSTART_START);
d1897 2
d1904 1
@


1.28
log
@de-register, ANSI functions and a little cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.27 2006/06/24 02:11:29 brad Exp $	*/
d164 3
d952 2
d955 9
a963 3
	 * Initialize mbuf length fields and fixup
	 * alignment so that the frame payload is
	 * longword aligned.
d965 2
a966 2
	m->m_len = m->m_pkthdr.len = MCLBYTES;
	m_adj(m, ETHER_ALIGN);
d1004 17
d1105 1
a1105 1
			m->m_len = MCLBYTES - ETHER_ALIGN;
d1137 6
a1142 1
		if (rxstat & RL_RDESC_STAT_RXERRSUM) {
d1176 3
a1178 1
			m->m_len = total_len % (MCLBYTES - ETHER_ALIGN);
d1201 3
d1367 2
a1368 2
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		(*ifp->if_start)(ifp);
@


1.27
log
@some comment fixes.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.26 2006/06/17 17:56:10 brad Exp $	*/
d156 1
a156 1
void re_attach_common	(struct rl_softc *);
d158 1
a158 1
int re_encap		(struct rl_softc *, struct mbuf *, int *);
d160 26
a185 26
int re_allocmem		(struct rl_softc *);
int re_newbuf		(struct rl_softc *, int, struct mbuf *);
int re_rx_list_init	(struct rl_softc *);
int re_tx_list_init	(struct rl_softc *);
void re_rxeof		(struct rl_softc *);
void re_txeof		(struct rl_softc *);
int re_intr		(void *);
void re_tick		(void *);
void re_start		(struct ifnet *);
int re_ioctl		(struct ifnet *, u_long, caddr_t);
int re_init		(struct ifnet *);
void re_stop		(struct rl_softc *);
void re_watchdog	(struct ifnet *);
int re_ifmedia_upd	(struct ifnet *);
void re_ifmedia_sts	(struct ifnet *, struct ifmediareq *);

void re_eeprom_putbyte	(struct rl_softc *, int);
void re_eeprom_getword	(struct rl_softc *, int, u_int16_t *);
void re_read_eeprom	(struct rl_softc *, caddr_t, int, int, int);

int re_gmii_readreg	(struct device *, int, int);
void re_gmii_writereg	(struct device *, int, int, int);

int re_miibus_readreg	(struct device *, int, int);
void re_miibus_writereg	(struct device *, int, int, int);
void re_miibus_statchg	(struct device *);
d187 2
a188 2
void re_setmulti	(struct rl_softc *);
void re_reset		(struct rl_softc *);
d190 1
a190 1
int re_diag		(struct rl_softc *);
d208 1
a208 3
re_eeprom_putbyte(sc, addr)
	struct rl_softc		*sc;
	int			addr;
d210 1
a210 1
	register int		d, i;
d218 1
a218 1
		if (d & i) {
d220 1
a220 1
		} else {
a221 1
		}
d234 1
a234 4
re_eeprom_getword(sc, addr, dest)
	struct rl_softc		*sc;
	int			addr;
	u_int16_t		*dest;
d236 2
a237 2
	register int		i;
	u_int16_t		word = 0;
d271 2
a272 6
re_read_eeprom(sc, dest, off, cnt, swap)
	struct rl_softc		*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
	int			swap;
d274 2
a275 2
	int			i;
	u_int16_t		word = 0, *ptr;
d291 2
a292 2
	u_int32_t		rval;
	int			i;
d326 2
a327 2
	u_int32_t		rval;
	int			i;
d340 1
a340 1
	if (i == RL_TIMEOUT) {
a341 1
	}
d348 3
a350 3
	u_int16_t		rval = 0;
	u_int16_t		re8139_reg = 0;
	int			s;
d409 2
a410 2
	u_int16_t		re8139_reg = 0;
	int			s;
d464 1
a464 2
re_setmulti(sc)
	struct rl_softc		*sc;
d522 1
a522 2
re_reset(sc)
	struct rl_softc	*sc;
d524 1
a524 1
	register int		i;
d560 1
a560 2
re_diag(sc)
	struct rl_softc	*sc;
d704 3
a706 3
	int			error;
	int			nseg, rseg;
	int			i;
d798 5
a802 5
	u_char			eaddr[ETHER_ADDR_LEN];
	u_int16_t		as[3];
	struct ifnet		*ifp;
	u_int16_t		re_did = 0;
	int			error = 0, i;
d927 1
a927 4
re_newbuf(sc, idx, m)
	struct rl_softc	*sc;
	int			idx;
	struct mbuf		*m;
d929 5
a933 5
	struct mbuf		*n = NULL;
	bus_dmamap_t		map;
	struct rl_desc		*d;
	u_int32_t		cmdstat;
	int			error;
d958 1
a958 1
        error = bus_dmamap_load_mbuf(sc->sc_dmat, map, m, BUS_DMA_NOWAIT);
d994 1
a994 2
re_tx_list_init(sc)
	struct rl_softc	*sc;
d1011 1
a1011 2
re_rx_list_init(sc)
	struct rl_softc	*sc;
d1013 1
a1013 1
	int			i;
d1043 1
a1043 2
re_rxeof(sc)
	struct rl_softc	*sc;
d1045 5
a1049 5
	struct mbuf		*m;
	struct ifnet		*ifp;
	int			i, total_len;
	struct rl_desc		*cur_rx;
	u_int32_t		rxstat;
a1061 1

d1201 1
a1201 2
re_txeof(sc)
	struct rl_softc	*sc;
d1203 3
a1205 3
	struct ifnet		*ifp;
	u_int32_t		txstat;
	int			idx;
a1217 1

d1265 1
a1265 2
re_tick(xsc)
	void			*xsc;
d1268 1
a1268 1
	int s = splnet();
d1270 1
d1278 1
a1278 2
re_intr(arg)
	void			*arg;
d1281 3
a1283 3
	struct ifnet		*ifp;
	u_int16_t		status;
	int			claimed = 0;
d1336 1
a1336 4
re_encap(sc, m_head, idx)
	struct rl_softc	*sc;
	struct mbuf		*m_head;
	int			*idx;
d1338 2
a1339 2
	bus_dmamap_t		map;
	int			error, i, curidx;
d1341 1
a1341 1
	struct m_tag		*mtag;
d1343 2
a1344 2
	struct rl_desc		*d;
	u_int32_t		cmdstat, rl_flags = 0;
d1472 1
a1472 2
re_start(ifp)
	struct ifnet		*ifp;
d1475 2
a1476 2
	struct mbuf		*m_head = NULL;
	int			idx, queued = 0;
d1543 4
a1546 4
	struct rl_softc		*sc = ifp->if_softc;
	u_int32_t		rxcfg = 0;
	u_int32_t		reg;
	int			s;
d1699 1
a1699 2
re_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d1712 1
a1712 3
re_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d1724 1
a1724 4
re_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d1727 1
a1727 1
	struct ifreq		*ifr = (struct ifreq *) data;
d1729 1
a1729 1
	int			s, error = 0;
d1803 1
a1803 2
re_watchdog(ifp)
	struct ifnet		*ifp;
d1806 1
a1806 1
	int			s;
d1826 1
a1826 2
re_stop(sc)
	struct rl_softc	*sc;
d1828 2
a1829 2
	register int		i;
	struct ifnet		*ifp;
@


1.26
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.25 2006/06/05 23:44:07 drahn Exp $	*/
d106 2
a107 2
 * jumbo frames larger than 7.5K, so the max MTU possible with this
 * driver is 7500 bytes.
d1380 2
a1381 2
	 * attempt. (This is according to testing done with an 8169
	 * chip. I'm not sure if this is a requirement or a bug.)
d1453 1
a1453 1
	 * in this chain.
a1693 1

@


1.25
log
@Write the words of the mac address in reverse order to fix a MAC problem on
a Realtek 8169 found in a Thecus N2100, tested jsg, ok pval
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.24 2006/05/29 05:11:15 drahn Exp $	*/
d121 1
@


1.24
log
@Only claim an interrupt if a real interrupt event occured, prevents false
counts on shared interrupts.
Flush the tx data buffer before handing the buffer over to the hardware,
fixes tx on arm. ok pval@@ looked at by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.23 2006/05/27 10:03:15 brad Exp $	*/
d1596 1
a1596 2
	memcpy(&reg, LLADDR(ifp->if_sadl), 4);
	CSR_WRITE_4(sc, RL_IDR0, htole32(reg));
d1600 4
@


1.23
log
@remove IFCAP_JUMBO_MTU interface capabilities flag and set if_hardmtu in a few
more drivers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.22 2006/05/26 20:50:41 deraadt Exp $	*/
a1319 1
			claimed = 1;
d1327 1
a1327 1
		    (status & RL_ISR_RX_ERR))
d1329 2
d1334 1
a1334 1
		    (status & RL_ISR_TX_DESC_UNAVAIL))
d1336 2
d1342 1
d1348 1
d1475 5
@


1.22
log
@rename jumbo mtu to if_hardmtu; ok brad reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.21 2006/05/20 03:47:56 brad Exp $	*/
a880 1
		ifp->if_capabilities |= IFCAP_JUMBO_MTU;
d886 1
a886 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
@


1.21
log
@set if_jumbo_mtu and the IFCAP_JUMBO_MTU capabilities flag where
appropriate.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.20 2006/05/16 02:15:23 brad Exp $	*/
d880 1
a880 1
		ifp->if_jumbo_mtu = RL_JUMBO_MTU;
@


1.20
log
@only allow setting Jumbo MTU frame sizes with the 8169 chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.19 2006/03/25 22:41:43 djm Exp $	*/
d878 1
a878 1
	if (sc->rl_type == RL_8169)
d880 3
a882 1
	else
d887 1
a887 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
d895 1
a895 1
        ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
@


1.19
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.18 2006/03/04 03:47:08 brad Exp $	*/
d1775 5
a1779 1
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > RL_JUMBO_MTU)
@


1.18
log
@do not set the chip type in re_attach_common() as this is already
set in the appropriate bus-dependent front-end attach routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.17 2006/01/30 00:32:45 brad Exp $	*/
d1204 1
a1204 1
			bpf_mtap(ifp->if_bpf, m);
d1513 1
a1513 1
			bpf_mtap(ifp->if_bpf, m_head);
@


1.17
log
@only flush the TX descriptors in re_start() if there are packets
to be transmitted.

tested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.16 2006/01/28 02:15:19 brad Exp $	*/
a818 2

	sc->rl_type = RL_8169;
@


1.16
log
@Make sure that HW VLAN stripping is not enabled and remove unused code
for HW VLAN stripping.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.15 2005/11/07 03:20:00 brad Exp $	*/
d1494 1
a1494 1
	int			idx;
d1517 1
d1519 3
@


1.15
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.14 2005/08/01 17:00:23 pvalchev Exp $	*/
d1069 1
a1069 4
#ifdef RE_VLAN
	struct m_tag		*mtag;
#endif
	u_int32_t		rxstat, rxvlan;
a1086 1
		rxvlan = letoh32(cur_rx->rl_vlanctl);
a1203 14
#ifdef RE_VLAN
		if (rxvlan & RL_RDESC_VLANCTL_TAG) {
			mtag = m_tag_get(PACKET_TAG_VLAN, sizeof(u_int),
			    M_NOWAIT);
			if (mtag == NULL) {
				ifp->if_ierrors++;
				m_freem(m);
				continue;
			}
			*(u_int *)(mtag + 1) = 
			    be16toh(rxvlan & RL_RDESC_VLANCTL_DATA);
			m_tag_prepend(m, mtag);
		}
#endif
d1570 2
a1571 3
	 * Enable C+ RX and TX mode, as well as VLAN stripping and
	 * RX checksum offload. We must configure the C+ register
	 * before all others.
d1575 1
a1575 1
	    RL_CPLUSCMD_VLANSTRIP|RL_CPLUSCMD_RXCSUM_ENB);
@


1.14
log
@remove device polling leftovers from wpaul driver
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.13 2005/05/24 00:46:18 brad Exp $	*/
d362 1
a362 1
	s = splimp();
d422 1
a422 1
	s = splimp();
d1580 1
a1580 1
	s = splimp();
d1768 1
a1768 1
	s = splimp();
@


1.14.2.1
log
@MFC:
Fix by brad@@

Make sure that HW VLAN stripping is not enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.14 2005/08/01 17:00:23 pvalchev Exp $	*/
d1588 3
a1590 2
	 * Enable C+ RX and TX mode, as well as RX checksum offload.
	 * We must configure the C+ register before all others.
d1594 1
a1594 1
	    RL_CPLUSCMD_RXCSUM_ENB);
@


1.13
log
@disable TX HW checksumming, some revs of the chip can cause packet corruption.

Issue with NFS reported by Han Boetes <han at mijncomputer dot nl>

ok pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.12 2005/04/30 19:43:41 brad Exp $	*/
a1317 46
#ifdef DEVICE_POLLING
void
re_poll (struct ifnet *ifp, enum poll_cmd cmd, int count)
{
	struct rl_softc *sc = ifp->if_softc;

	RL_LOCK(sc);
	if (!(ifp->if_capenable & IFCAP_POLLING)) {
		ether_poll_deregister(ifp);
		cmd = POLL_DEREGISTER;
	}
	if (cmd == POLL_DEREGISTER) { /* final call, enable interrupts */
		CSR_WRITE_2(sc, RL_IMR, RL_INTRS_CPLUS);
		goto done;
	}

	sc->rxcycles = count;
	re_rxeof(sc);
	re_txeof(sc);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		(*ifp->if_start)(ifp);

	if (cmd == POLL_AND_CHECK_STATUS) { /* also check status register */
		u_int16_t       status;

		status = CSR_READ_2(sc, RL_ISR);
		if (status == 0xffff)
			goto done;
		if (status)
			CSR_WRITE_2(sc, RL_ISR, status);

		/*
		 * XXX check behaviour on receiver stalls.
		 */

		if (status & RL_ISR_SYSTEM_ERR) {
			re_reset(sc);
			re_init(ifp);
		}
	}
done:
	RL_UNLOCK(sc);
}
#endif /* DEVICE_POLLING */

a1331 11
#ifdef DEVICE_POLLING
	if  (ifp->if_flags & IFF_POLLING)
		goto done;
	if ((ifp->if_capenable & IFCAP_POLLING) &&
	    ether_poll_register(re_poll, ifp)) { /* ok, disable interrupts */
		CSR_WRITE_2(sc, RL_IMR, 0x0000);
		re_poll(ifp, 0, 1);
		goto done;
	}
#endif /* DEVICE_POLLING */

a1368 4
#ifdef DEVICE_POLLING
done:
#endif

a1658 8
#ifdef DEVICE_POLLING
	/*
	 * Disable interrupts if we are polling.
	 */
	if (ifp->if_flags & IFF_POLLING)
		CSR_WRITE_2(sc, RL_IMR, 0);
	else	/* otherwise ... */
#endif /* DEVICE_POLLING */
a1870 3
#ifdef DEVICE_POLLING
	ether_poll_deregister(ifp);
#endif /* DEVICE_POLLING */
@


1.12
log
@don't set MTU if its the same as what's currently being used.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.11 2005/04/30 08:24:25 pvalchev Exp $	*/
d887 1
a887 2
	ifp->if_capabilities = IFCAP_VLAN_MTU|IFCAP_CSUM_IPv4|
				IFCAP_CSUM_TCPv4|IFCAP_CSUM_UDPv4;
d889 6
a894 1
#ifdef VLANXXX
d1069 1
a1069 1
#ifdef VLANXXX
d1208 1
a1208 1
#ifdef VLANXXX
d1441 1
a1441 1
#ifdef VLANXXX
d1445 1
a1445 1
	u_int32_t		cmdstat, rl_flags;
d1450 1
a1463 2
	rl_flags = 0;

d1472 1
d1541 1
a1541 1
#ifdef VLANXXX
@


1.11
log
@check for ETHERMIN in SIOCSIFMTU ioctl; from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.10 2005/04/30 08:22:23 pvalchev Exp $	*/
d1859 1
a1859 1
		else
@


1.10
log
@From NetBSD, pt to by brad (might fix csum problems, else they may
need to be disabled after more testing):
re_encap: set RTK_TDESC_CMD_IPCSUM if any of checksum offloading is requested.
otherwise, RTK_TDESC_CMD_TCPCSUM/UDPCSUM don't seem to make any effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.9 2005/04/25 17:55:51 brad Exp $	*/
d1857 1
a1857 1
		if (ifr->ifr_mtu > RL_JUMBO_MTU)
d1859 2
a1860 1
		ifp->if_mtu = ifr->ifr_mtu;
@


1.9
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.8 2005/04/15 03:16:07 brad Exp $	*/
d1453 6
d1461 2
a1462 1
	if (m_head->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
d1464 5
a1468 4
	if (m_head->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
		rl_flags |= RL_TDESC_CMD_TCPCSUM;
	if (m_head->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
		rl_flags |= RL_TDESC_CMD_UDPCSUM;
@


1.8
log
@re(4) cannot handle a standard sized Jumbo frame.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.7 2005/04/14 20:23:31 brad Exp $	*/
d1195 1
a1195 1
			m->m_pkthdr.csum |= M_IPV4_CSUM_IN_OK;
d1202 1
a1202 1
			m->m_pkthdr.csum |= M_TCP_CSUM_IN_OK | M_UDP_CSUM_IN_OK;
d1455 1
a1455 1
	if (m_head->m_pkthdr.csum & M_IPV4_CSUM_OUT)
d1457 1
a1457 1
	if (m_head->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
d1459 1
a1459 1
	if (m_head->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
@


1.7
log
@enable HW transmit checksum offload

ok pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.6 2005/04/08 13:36:48 brad Exp $	*/
d1849 1
a1849 1
		if (ifr->ifr_mtu > ETHERMTU_JUMBO)
@


1.6
log
@- enable reception of VLAN sized frames
- enable HW receive checksum offload

ok pvlachev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.5 2005/03/15 16:11:38 henning Exp $	*/
a149 2
/*#define RE_CSUM_OFFLOAD */

d887 2
a888 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
d891 1
a891 5
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
#endif
#ifdef RE_CSUM_OFFLOAD
	ifp->if_capabilities |= IFCAP_CSUM_IPv4|IFCAP_CSUM_TCPv4|
				IFCAP_CSUM_UDPv4
d1455 1
a1455 2
#ifdef RE_CSUM_OFFLOAD
	if (m_head->m_pkthdr.csum_flags & M_CSUM_IPv4)
d1457 1
a1457 1
	if (m_head->m_pkthdr.csum_flags & M_CSUM_TCPv4)
d1459 1
a1459 1
	if (m_head->m_pkthdr.csum_flags & M_CSUM_UDPv4)
a1460 1
#endif
@


1.5
log
@use IFQ_* macros instead of hand-rolling or using IF_*, makes ALTQ work on
re, from Armin Wolfermann <aw@@osn.de>, ok dlg markus pval
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.4 2005/02/25 12:32:50 jsg Exp $	*/
a878 4
#ifdef VLANXXX
	sc->ethercom.ec_capabilities |=
	    ETHERCAP_VLAN_MTU | ETHERCAP_VLAN_HWTAGGING;
#endif
a879 4
#ifdef RE_CSUM_OFFLOAD
	ifp->if_capabilities |=
	    IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
#endif
d889 10
d1195 1
a1195 1
		/* Do RX checksumming if enabled */
d1197 4
a1200 9
#ifdef RE_CSUM_OFFLOAD
		if (ifp->if_capenable & IFCAP_CSUM_IPv4) {

			/* Check IP header checksum */
			if (rxstat & RL_RDESC_STAT_PROTOID)
				m->m_pkthdr.csum_flags |= M_CSUM_IPv4;;
			if (rxstat & RL_RDESC_STAT_IPSUMBAD)
                                m->m_pkthdr.csum_flags |= M_CSUM_IPv4_BAD;
		}
d1203 5
a1207 13
		if (RL_TCPPKT(rxstat) &&
		    (ifp->if_capenable & IFCAP_CSUM_TCPv4)) {
			m->m_pkthdr.csum_flags |= M_CSUM_TCPv4;
			if (rxstat & RL_RDESC_STAT_TCPSUMBAD)
				m->m_pkthdr.csum_flags |= M_CSUM_TCP_UDP_BAD;
		}
		if (RL_UDPPKT(rxstat) &&
		    (ifp->if_capenable & IFCAP_CSUM_UDPv4)) {
			m->m_pkthdr.csum_flags |= M_CSUM_UDPv4;
			if (rxstat & RL_RDESC_STAT_UDPSUMBAD)
				m->m_pkthdr.csum_flags |= M_CSUM_TCP_UDP_BAD;
		}
#endif
a1647 1
#ifdef RE_CSUM_OFFLOAD
d1650 1
a1650 9
	    RL_CPLUSCMD_VLANSTRIP|
	    (ifp->if_capenable &
	    (IFCAP_CSUM_IPv4 |IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4) ?
	    RL_CPLUSCMD_RXCSUM_ENB : 0));
#else
	CSR_WRITE_2(sc, RL_CPLUS_CMD, RL_CPLUSCMD_RXENB|
	    RL_CPLUSCMD_TXENB|RL_CPLUSCMD_PCI_MRW|
	    RL_CPLUSCMD_VLANSTRIP);
#endif
@


1.4
log
@Correct usage of bus_dma which makes re(4) work on alpha.

From NetBSD rtl8169.c -r 1.11

ok pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.3 2005/01/15 05:24:11 brad Exp $	*/
d625 1
a625 1
	IF_ENQUEUE(&ifp->if_snd, m0);
d894 1
a894 1
	ifp->if_snd.ifq_maxlen = RL_IFQ_MAXLEN;
d1350 1
a1350 1
	if (ifp->if_snd.ifq_head != NULL)
d1435 1
a1435 1
	if (ifp->if_snd.ifq_head != NULL)
d1585 1
a1585 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
@


1.3
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.2 2005/01/14 01:32:45 pvalchev Exp $	*/
d1762 1
a1762 1
	    RL_ADDR_HI(sc->rl_ldata.rl_rx_listseg.ds_addr));
d1764 1
a1764 1
	    RL_ADDR_LO(sc->rl_ldata.rl_rx_listseg.ds_addr));
d1767 1
a1767 1
	    RL_ADDR_HI(sc->rl_ldata.rl_tx_listseg.ds_addr));
d1769 1
a1769 1
	    RL_ADDR_LO(sc->rl_ldata.rl_tx_listseg.ds_addr));
@


1.2
log
@clean PCI leftovers
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.1 2005/01/14 01:08:11 pvalchev Exp $	*/
d1899 2
a1900 1
			re_setmulti(sc);
@


1.1
log
@split re(4) into bus-independent code (ic/re.c) and PCI front-end
(pci/if_re_pci.c) for soon-to-come cardbus support; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re.c,v 1.14 2004/12/11 06:27:49 pvalchev Exp $	*/
a148 1
#include <dev/pci/pcidevs.h>
a153 8
struct re_pci_softc {
	struct rl_softc sc_rl;

	void *sc_ih;
	pci_chipset_tag_t sc_pc;
	pcitag_t sc_pcitag;
};

a156 6
const struct pci_matchid re_devices[] = {
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8169 },
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CGLAPCIGT },
};

int re_probe		(struct device *, void *, void *);
a713 11
}

/*
 * Probe for a RealTek 8139C+/8169/8110 chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
re_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, re_devices,
	    sizeof(re_devices)/sizeof(re_devices[0])));
@

