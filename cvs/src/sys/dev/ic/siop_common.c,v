head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.8
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.10
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.4
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.12
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.10
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.6
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.4
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.10
	OPENBSD_5_0:1.34.0.6
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.4
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.4
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.30.0.6
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.15
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	SMP:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2;
locks; strict;
comment	@ * @;


1.36
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.35;
commitid	LS2TNeCue5R9L67C;

1.35
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.29.22.50.23;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.31.17.21.57;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.05.19.05.09;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.16.22.11.24;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.25.16.33.19;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.20.22.32.48;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.03.11.00.36;	author martin;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.31.19.02.06;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.10.16.27.23;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.08.23.46.11;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.08.19.21.10;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.21.19.55.30;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.12.22.22.26;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.15.17.51.42;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.27.03.07.39;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.29.18.52.53;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.01.17.15.06;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.09.23.43.11;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.16.00.53.12;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.30.00.02.55;	author krw;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.10.08.01.25.07;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.18.02.24.02;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.06.14.29.59;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.23.14.40;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.24.18.28.10;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.15.06.01.29;	author krw;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.03.10.05.04.06;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.06.16.29.32;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.01.17.14.28;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.20.00.32.29;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.15.04.07.58;	author krw;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.24.11;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.41.08;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2004.06.13.08.50.13;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@/*	$OpenBSD: siop_common.c,v 1.35 2012/02/24 06:19:00 guenther Exp $ */
/*	$NetBSD: siop_common.c,v 1.37 2005/02/27 00:27:02 perry Exp $	*/

/*
 * Copyright (c) 2000, 2002 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* SYM53c7/8xx PCI-SCSI I/O Processors driver */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/scsiio.h>
#include <sys/endian.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_message.h>
#include <scsi/scsiconf.h>

#define SIOP_NEEDS_PERIOD_TABLES
#include <dev/ic/siopreg.h>
#include <dev/ic/siopvar_common.h>
#include <dev/ic/siopvar.h>

#undef DEBUG
#undef DEBUG_DR
#undef DEBUG_NEG

int
siop_common_attach(sc)
	struct siop_common_softc *sc;
{
	int error, i;
	bus_dma_segment_t seg;
	int rseg;

	/*
	 * Allocate DMA-safe memory for the script and map it.
	 */
	if ((sc->features & SF_CHIP_RAM) == 0) {
		error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE,
		    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to allocate script DMA memory, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		error = bus_dmamem_map(sc->sc_dmat, &seg, rseg, PAGE_SIZE,
		    (caddr_t *)&sc->sc_script,
		    BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
		if (error) {
			printf("%s: unable to map script DMA memory, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1,
		    PAGE_SIZE, 0, BUS_DMA_NOWAIT, &sc->sc_scriptdma);
		if (error) {
			printf("%s: unable to create script DMA map, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		error = bus_dmamap_load(sc->sc_dmat, sc->sc_scriptdma,
		    sc->sc_script, PAGE_SIZE, NULL, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to load script DMA map, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		sc->sc_scriptaddr =
		    sc->sc_scriptdma->dm_segs[0].ds_addr;
		sc->ram_size = PAGE_SIZE;
	}

	/*
	 * sc->sc_link is the template for all device sc_link's
	 * for devices attached to this adapter. It is passed to
	 * the upper layers in config_found().
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_buswidth =
	    (sc->features & SF_BUS_WIDE) ? 16 : 8;
	sc->sc_link.adapter_target =
	    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SCID);
	if (sc->sc_link.adapter_target == 0 ||
	    sc->sc_link.adapter_target >=
	    sc->sc_link.adapter_buswidth)
		sc->sc_link.adapter_target = SIOP_DEFAULT_TARGET;

	for (i = 0; i < 16; i++)
		sc->targets[i] = NULL;

	/* find min/max sync period for this chip */
	sc->st_maxsync = 0;
	sc->dt_maxsync = 0;
	sc->st_minsync = 255;
	sc->dt_minsync = 255;
	for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]); i++) {
		if (sc->clock_period != scf_period[i].clock)
			continue;
		if (sc->st_maxsync < scf_period[i].period)
			sc->st_maxsync = scf_period[i].period;
		if (sc->st_minsync > scf_period[i].period)
			sc->st_minsync = scf_period[i].period;
	}
	if (sc->st_maxsync == 255 || sc->st_minsync == 0)
		panic("siop: can't find my sync parameters");
	for (i = 0; i < sizeof(dt_scf_period) / sizeof(dt_scf_period[0]); i++) {
		if (sc->clock_period != dt_scf_period[i].clock)
			continue;
		if (sc->dt_maxsync < dt_scf_period[i].period)
			sc->dt_maxsync = dt_scf_period[i].period;
		if (sc->dt_minsync > dt_scf_period[i].period)
			sc->dt_minsync = dt_scf_period[i].period;
	}
	if (sc->dt_maxsync == 255 || sc->dt_minsync == 0)
		panic("siop: can't find my sync parameters");
	return 0;
}

void
siop_common_reset(sc)
	struct siop_common_softc *sc;
{
	u_int32_t stest3;

	/* reset the chip */
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_ISTAT, ISTAT_SRST);
	delay(1000);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_ISTAT, 0);

	/* init registers */
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL0,
	    SCNTL0_ARB_MASK | SCNTL0_EPC | SCNTL0_AAP);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL1, 0);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL3, sc->clock_div);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SXFER, 0);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_DIEN, 0xff);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SIEN0,
	    0xff & ~(SIEN0_CMP | SIEN0_SEL | SIEN0_RSL));
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SIEN1,
	    0xff & ~(SIEN1_HTH | SIEN1_GEN));
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST2, 0);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST3, STEST3_TE);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STIME0,
	    (0xb << STIME0_SEL_SHIFT));
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCID,
	    sc->sc_link.adapter_target | SCID_RRE);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_RESPID0,
	    1 << sc->sc_link.adapter_target);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_DCNTL,
	    (sc->features & SF_CHIP_PF) ? DCNTL_COM | DCNTL_PFEN : DCNTL_COM);
	if (sc->features & SF_CHIP_AAIP)
		bus_space_write_1(sc->sc_rt, sc->sc_rh,
		    SIOP_AIPCNTL1, AIPCNTL1_DIS);

	/* enable clock doubler or quadrupler if appropriate */
	if (sc->features & (SF_CHIP_DBLR | SF_CHIP_QUAD)) {
		stest3 = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_STEST3);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST1,
		    STEST1_DBLEN);
		if (sc->features & SF_CHIP_QUAD) {
			/* wait for PPL to lock */
			while ((bus_space_read_1(sc->sc_rt, sc->sc_rh,
			    SIOP_STEST4) & STEST4_LOCK) == 0)
				delay(10);
		} else {
			/* data sheet says 20us - more won't hurt */
			delay(100);
		}
		/* halt scsi clock, select doubler/quad, restart clock */
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST3,
		    stest3 | STEST3_HSC);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST1,
		    STEST1_DBLEN | STEST1_DBLSEL);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST3, stest3);
	} else {
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST1, 0);
	}
	if (sc->features & SF_CHIP_FIFO)
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST5,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST5) |
		    CTEST5_DFS);
	if (sc->features & SF_CHIP_LED0) {
		/* Set GPIO0 as output if software LED control is required */
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_GPCNTL,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_GPCNTL) & 0xfe);
	}
	if (sc->features & SF_BUS_ULTRA3) {
		/* reset SCNTL4 */
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL4, 0);
	}
	sc->mode = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_STEST4) &
	    STEST4_MODE_MASK;

	/*
	 * initialise the RAM. Without this we may get scsi gross errors on
	 * the 1010
	 */
	if (sc->features & SF_CHIP_RAM)
		bus_space_set_region_4(sc->sc_ramt, sc->sc_ramh,
			0, 0, sc->ram_size / 4);
	sc->sc_reset(sc);
}

/* prepare tables before sending a cmd */
void
siop_setuptables(siop_cmd)
	struct siop_common_cmd *siop_cmd;
{
	int i;
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct scsi_xfer *xs = siop_cmd->xs;
	int target = xs->sc_link->target;
	int lun = xs->sc_link->lun;
	int msgoffset = 1;
	int *targ_flags = &sc->targets[target]->flags;
	int quirks;

	siop_cmd->siop_tables->id = siop_htoc32(sc, sc->targets[target]->id);
	memset(siop_cmd->siop_tables->msg_out, 0,
	    sizeof(siop_cmd->siop_tables->msg_out));
	/* request sense doesn't disconnect */
	if (siop_cmd->status == CMDST_SENSE)
		siop_cmd->siop_tables->msg_out[0] = MSG_IDENTIFY(lun, 0);
	else if ((sc->features & SF_CHIP_GEBUG) &&
	    (sc->targets[target]->flags & TARF_ISWIDE) == 0)
		/*
		 * 1010 bug: it seems that the 1010 has problems with reselect
		 * when not in wide mode (generate false SCSI gross error).
		 * The FreeBSD sym driver has comments about it but their
		 * workaround (disable SCSI gross error reporting) doesn't
		 * work with my adapter. So disable disconnect when not
		 * wide.
		 */
		siop_cmd->siop_tables->msg_out[0] = MSG_IDENTIFY(lun, 0);
	else
		siop_cmd->siop_tables->msg_out[0] = MSG_IDENTIFY(lun, 1);
	siop_cmd->siop_tables->t_msgout.count = siop_htoc32(sc, msgoffset);
	if (sc->targets[target]->status == TARST_ASYNC) {
		*targ_flags &= TARF_DT; /* Save TARF_DT 'cuz we don't set it here */
		quirks = xs->sc_link->quirks;

		if ((quirks & SDEV_NOTAGS) == 0)
			*targ_flags |= TARF_TAG;
		if (((quirks & SDEV_NOWIDE) == 0) &&
		    (sc->features & SF_BUS_WIDE))
			*targ_flags |= TARF_WIDE;
		if ((quirks & SDEV_NOSYNC) == 0)
			*targ_flags |= TARF_SYNC;

		if ((sc->features & SF_CHIP_GEBUG) &&
		    (*targ_flags & TARF_WIDE) == 0)
			/* 
			 * 1010 workaround: can't do disconnect if not wide,
			 * so can't do tag
			 */
			*targ_flags &= ~TARF_TAG;

		/* Safe to call siop_add_dev() multiple times */
		siop_add_dev((struct siop_softc *)sc, target, lun);

		if ((*targ_flags & TARF_DT) &&
		    (sc->mode == STEST4_MODE_LVD)) {
			sc->targets[target]->status = TARST_PPR_NEG;
			 siop_ppr_msg(siop_cmd, msgoffset, sc->dt_minsync,
			    sc->maxoff);
		} else if (*targ_flags & TARF_WIDE) {
			sc->targets[target]->status = TARST_WIDE_NEG;
			siop_wdtr_msg(siop_cmd, msgoffset,
			    MSG_EXT_WDTR_BUS_16_BIT);
		} else if (*targ_flags & TARF_SYNC) {
			sc->targets[target]->status = TARST_SYNC_NEG;
			siop_sdtr_msg(siop_cmd, msgoffset, sc->st_minsync,
			(sc->maxoff > 31) ? 31 :  sc->maxoff);
		} else {
			sc->targets[target]->status = TARST_OK;
			siop_update_xfer_mode(sc, target);
		}
	} else if (sc->targets[target]->status == TARST_OK &&
	    (*targ_flags & TARF_TAG) &&
	    siop_cmd->status != CMDST_SENSE) {
		siop_cmd->flags |= CMDFL_TAG;
	}
	siop_cmd->siop_tables->status =
	    siop_htoc32(sc, SCSI_SIOP_NOSTATUS); /* set invalid status */

	if ((xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) ||
	    siop_cmd->status == CMDST_SENSE) {
		bzero(siop_cmd->siop_tables->data,
		    sizeof(siop_cmd->siop_tables->data));
		for (i = 0; i < siop_cmd->dmamap_data->dm_nsegs; i++) {
			siop_cmd->siop_tables->data[i].count =
			    siop_htoc32(sc,
				siop_cmd->dmamap_data->dm_segs[i].ds_len);
			siop_cmd->siop_tables->data[i].addr =
			    siop_htoc32(sc,
				siop_cmd->dmamap_data->dm_segs[i].ds_addr);
		}
	}
}

int
siop_wdtr_neg(siop_cmd)
	struct siop_common_cmd *siop_cmd;
{
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct siop_common_target *siop_target = siop_cmd->siop_target;
	int target = siop_cmd->xs->sc_link->target;
	struct siop_common_xfer *tables = siop_cmd->siop_tables;

	if (siop_target->status == TARST_WIDE_NEG) {
		/* we initiated wide negotiation */
		switch (tables->msg_in[3]) {
		case MSG_EXT_WDTR_BUS_8_BIT:
			siop_target->flags &= ~TARF_ISWIDE;
			sc->targets[target]->id &= ~(SCNTL3_EWS << 24);
			break;
		case MSG_EXT_WDTR_BUS_16_BIT:
			if (siop_target->flags & TARF_WIDE) {
				siop_target->flags |= TARF_ISWIDE;
				sc->targets[target]->id |= (SCNTL3_EWS << 24);
				break;
			}
		/* FALLTHROUGH */
		default:
			/*
 			 * hum, we got more than what we can handle, shouldn't
			 * happen. Reject, and stay async
			 */
			siop_target->flags &= ~TARF_ISWIDE;
			siop_target->status = TARST_OK;
			siop_target->offset = siop_target->period = 0;
			siop_update_xfer_mode(sc, target);
			printf("%s: rejecting invalid wide negotiation from "
			    "target %d (%d)\n", sc->sc_dev.dv_xname, target,
			    tables->msg_in[3]);
			tables->t_msgout.count = siop_htoc32(sc, 1);
			tables->msg_out[0] = MSG_MESSAGE_REJECT;
			return SIOP_NEG_MSGOUT;
		}
		tables->id = siop_htoc32(sc, sc->targets[target]->id);
		bus_space_write_1(sc->sc_rt, sc->sc_rh,
		    SIOP_SCNTL3,
		    (sc->targets[target]->id >> 24) & 0xff);
		/* we now need to do sync */
		if (siop_target->flags & TARF_SYNC) {
			siop_target->status = TARST_SYNC_NEG;
			siop_sdtr_msg(siop_cmd, 0, sc->st_minsync,
			    (sc->maxoff > 31) ? 31 : sc->maxoff);
			return SIOP_NEG_MSGOUT;
		} else {
			siop_target->status = TARST_OK;
			siop_update_xfer_mode(sc, target);
			return SIOP_NEG_ACK;
		}
	} else {
		/* target initiated wide negotiation */
		if (tables->msg_in[3] >= MSG_EXT_WDTR_BUS_16_BIT
		    && (siop_target->flags & TARF_WIDE)) {
			siop_target->flags |= TARF_ISWIDE;
			sc->targets[target]->id |= SCNTL3_EWS << 24;
		} else {
			siop_target->flags &= ~TARF_ISWIDE;
			sc->targets[target]->id &= ~(SCNTL3_EWS << 24);
		}
		tables->id = siop_htoc32(sc, sc->targets[target]->id);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL3,
		    (sc->targets[target]->id >> 24) & 0xff);
		/*
		 * we did reset wide parameters, so fall back to async,
		 * but don't schedule a sync neg, target should initiate it
		 */
		siop_target->status = TARST_OK;
		siop_target->offset = siop_target->period = 0;
		siop_update_xfer_mode(sc, target);
		siop_wdtr_msg(siop_cmd, 0, (siop_target->flags & TARF_ISWIDE) ?
		    MSG_EXT_WDTR_BUS_16_BIT : MSG_EXT_WDTR_BUS_8_BIT);
		return SIOP_NEG_MSGOUT;
	}
}

int
siop_ppr_neg(siop_cmd)
	struct siop_common_cmd *siop_cmd;
{
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct siop_common_target *siop_target = siop_cmd->siop_target;
	int target = siop_cmd->xs->sc_link->target;
	struct siop_common_xfer *tables = siop_cmd->siop_tables;
	int sync, offset, options, scf = 0;
	int i;

#ifdef DEBUG_NEG
	printf("%s: answer on ppr negotiation:", sc->sc_dev.dv_xname);
	for (i = 0; i < 8; i++)
		printf(" 0x%x", tables->msg_in[i]);
	printf("\n");
#endif

	if (siop_target->status == TARST_PPR_NEG) {
		/* we initiated PPR negotiation */
		sync = tables->msg_in[3];
		offset = tables->msg_in[5];
		options = tables->msg_in[7];
		if (options != MSG_EXT_PPR_PROT_DT) {
			/* should't happen */
			printf("%s: ppr negotiation for target %d: "
			    "no DT option\n", sc->sc_dev.dv_xname, target);
			siop_target->status = TARST_ASYNC;
			siop_target->flags &= ~(TARF_DT | TARF_ISDT);
			siop_target->offset = 0;
			siop_target->period = 0;
			goto reject;
		}

		if (offset > sc->maxoff || sync < sc->dt_minsync ||
		    sync > sc->dt_maxsync) {
			printf("%s: ppr negotiation for target %d: "
			    "offset (%d) or sync (%d) out of range\n",
			    sc->sc_dev.dv_xname, target, offset, sync);
			/* should not happen */
			siop_target->status = TARST_ASYNC;
			siop_target->flags &= ~(TARF_DT | TARF_ISDT);
			siop_target->offset = 0;
			siop_target->period = 0;
			goto reject;
		} else {
			for (i = 0; i <
			    sizeof(dt_scf_period) / sizeof(dt_scf_period[0]);
			    i++) {
				if (sc->clock_period != dt_scf_period[i].clock)
					continue;
				if (dt_scf_period[i].period == sync) {
					/* ok, found it. we now are sync. */
					siop_target->offset = offset;
					siop_target->period = sync;
					scf = dt_scf_period[i].scf;
					siop_target->flags |= TARF_ISDT;
				}
			}
			if ((siop_target->flags & TARF_ISDT) == 0) {
				printf("%s: ppr negotiation for target %d: "
				    "sync (%d) incompatible with adapter\n",
				    sc->sc_dev.dv_xname, target, sync);
				/*
				 * we didn't find it in our table, do async
				 * send reject msg, start SDTR/WDTR neg
				 */
				siop_target->status = TARST_ASYNC;
				siop_target->flags &= ~(TARF_DT | TARF_ISDT);
				siop_target->offset = 0;
				siop_target->period = 0;
				goto reject;
			}
		}
		if (tables->msg_in[6] != 1) {
			printf("%s: ppr negotiation for target %d: "
			    "transfer width (%d) incompatible with dt\n",
			    sc->sc_dev.dv_xname, target, tables->msg_in[6]);
			/* DT mode can only be done with wide transfers */
			siop_target->status = TARST_ASYNC;
			siop_target->flags &= ~(TARF_DT | TARF_ISDT);
			siop_target->offset = 0;
			siop_target->period = 0;
			goto reject;
		} 
		siop_target->flags |= TARF_ISWIDE;
		sc->targets[target]->id |= (SCNTL3_EWS << 24);
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id |= scf << (24 + SCNTL3_SCF_SHIFT);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
		sc->targets[target]->id |=
		    (siop_target->offset & SXFER_MO_MASK) << 8;
		sc->targets[target]->id &= ~0xff;
		sc->targets[target]->id |= SCNTL4_U3EN;
		siop_target->status = TARST_OK;
		siop_update_xfer_mode(sc, target);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL3,
		    (sc->targets[target]->id >> 24) & 0xff);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SXFER,
		    (sc->targets[target]->id >> 8) & 0xff);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL4,
		    sc->targets[target]->id & 0xff);
		return SIOP_NEG_ACK;
	} else {
		/* target initiated PPR negotiation, shouldn't happen */
		printf("%s: rejecting invalid PPR negotiation from "
		    "target %d\n", sc->sc_dev.dv_xname, target);
reject:
		tables->t_msgout.count = siop_htoc32(sc, 1);
		tables->msg_out[0] = MSG_MESSAGE_REJECT;
		return SIOP_NEG_MSGOUT;
	}
}

int
siop_sdtr_neg(siop_cmd)
	struct siop_common_cmd *siop_cmd;
{
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct siop_common_target *siop_target = siop_cmd->siop_target;
	int target = siop_cmd->xs->sc_link->target;
	int sync, maxoffset, offset, i;
	int send_msgout = 0;
	struct siop_common_xfer *tables = siop_cmd->siop_tables;

	/* limit to Ultra/2 parameters, need PPR for Ultra/3 */
	maxoffset = (sc->maxoff > 31) ? 31 : sc->maxoff;

	sync = tables->msg_in[3];
	offset = tables->msg_in[4];

	if (siop_target->status == TARST_SYNC_NEG) {
		/* we initiated sync negotiation */
		siop_target->status = TARST_OK;
#ifdef DEBUG
		printf("sdtr: sync %d offset %d\n", sync, offset);
#endif
		if (offset > maxoffset || sync < sc->st_minsync ||
			sync > sc->st_maxsync)
			goto reject;
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]);
		    i++) {
			if (sc->clock_period != scf_period[i].clock)
				continue;
			if (scf_period[i].period == sync) {
				/* ok, found it. we now are sync. */
				siop_target->offset = offset;
				siop_target->period = sync;
				sc->targets[target]->id &=
				    ~(SCNTL3_SCF_MASK << 24);
				sc->targets[target]->id |= scf_period[i].scf
				    << (24 + SCNTL3_SCF_SHIFT);
				if (sync < 25 && /* Ultra */
				    (sc->features & SF_BUS_ULTRA3) == 0)
					sc->targets[target]->id |=
					    SCNTL3_ULTRA << 24;
				else
					sc->targets[target]->id &=
					    ~(SCNTL3_ULTRA << 24);
				sc->targets[target]->id &=
				    ~(SXFER_MO_MASK << 8);
				sc->targets[target]->id |=
				    (offset & SXFER_MO_MASK) << 8;
				sc->targets[target]->id &= ~0xff; /* scntl4 */
				goto end;
			}
		}
		/*
		 * we didn't find it in our table, do async and send reject
		 * msg
		 */
reject:
		send_msgout = 1;
		tables->t_msgout.count = siop_htoc32(sc, 1);
		tables->msg_out[0] = MSG_MESSAGE_REJECT;
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
		sc->targets[target]->id &= ~0xff; /* scntl4 */
		siop_target->offset = siop_target->period = 0;
	} else { /* target initiated sync neg */
#ifdef DEBUG
		printf("sdtr (target): sync %d offset %d\n", sync, offset);
#endif
		if (offset == 0 || sync > sc->st_maxsync) { /* async */
			goto async;
		}
		if (offset > maxoffset)
			offset = maxoffset;
		if (sync < sc->st_minsync)
			sync = sc->st_minsync;
		/* look for sync period */
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]);
		    i++) {
			if (sc->clock_period != scf_period[i].clock)
				continue;
			if (scf_period[i].period == sync) {
				/* ok, found it. we now are sync. */
				siop_target->offset = offset;
				siop_target->period = sync;
				sc->targets[target]->id &=
				    ~(SCNTL3_SCF_MASK << 24);
				sc->targets[target]->id |= scf_period[i].scf
				    << (24 + SCNTL3_SCF_SHIFT);
				if (sync < 25 && /* Ultra */
				    (sc->features & SF_BUS_ULTRA3) == 0)
					sc->targets[target]->id |=
					    SCNTL3_ULTRA << 24;
				else
					sc->targets[target]->id &=
					    ~(SCNTL3_ULTRA << 24);
				sc->targets[target]->id &=
				    ~(SXFER_MO_MASK << 8);
				sc->targets[target]->id |=
				    (offset & SXFER_MO_MASK) << 8;
				sc->targets[target]->id &= ~0xff; /* scntl4 */
				siop_sdtr_msg(siop_cmd, 0, sync, offset);
				send_msgout = 1;
				goto end;
			}
		}
async:
		siop_target->offset = siop_target->period = 0;
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
		sc->targets[target]->id &= ~0xff; /* scntl4 */
		siop_sdtr_msg(siop_cmd, 0, 0, 0);
		send_msgout = 1;
	}
end:
	if (siop_target->status == TARST_OK)
		siop_update_xfer_mode(sc, target);
#ifdef DEBUG
	printf("id now 0x%x\n", sc->targets[target]->id);
#endif
	tables->id = siop_htoc32(sc, sc->targets[target]->id);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL3,
	    (sc->targets[target]->id >> 24) & 0xff);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SXFER,
	    (sc->targets[target]->id >> 8) & 0xff);
	if (send_msgout) {
		return SIOP_NEG_MSGOUT;
	} else {
		return SIOP_NEG_ACK;
	}
}

void
siop_sdtr_msg(siop_cmd, offset, ssync, soff)
	struct siop_common_cmd *siop_cmd;
	int offset;
	int ssync, soff;
{
	siop_cmd->siop_tables->msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables->msg_out[offset + 1] = MSG_EXT_SDTR_LEN;
	siop_cmd->siop_tables->msg_out[offset + 2] = MSG_EXT_SDTR;
	siop_cmd->siop_tables->msg_out[offset + 3] = ssync;
	siop_cmd->siop_tables->msg_out[offset + 4] = soff;
	siop_cmd->siop_tables->t_msgout.count =
	    siop_htoc32(siop_cmd->siop_sc, offset + MSG_EXT_SDTR_LEN + 2);
}

void
siop_wdtr_msg(siop_cmd, offset, wide)
	struct siop_common_cmd *siop_cmd;
	int offset;
	int wide;
{
	siop_cmd->siop_tables->msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables->msg_out[offset + 1] = MSG_EXT_WDTR_LEN;
	siop_cmd->siop_tables->msg_out[offset + 2] = MSG_EXT_WDTR;
	siop_cmd->siop_tables->msg_out[offset + 3] = wide;
	siop_cmd->siop_tables->t_msgout.count =
	    siop_htoc32(siop_cmd->siop_sc, offset + MSG_EXT_WDTR_LEN + 2);
}

void
siop_ppr_msg(siop_cmd, offset, ssync, soff)
	struct siop_common_cmd *siop_cmd;
	int offset;
	int ssync, soff;
{
	siop_cmd->siop_tables->msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables->msg_out[offset + 1] = MSG_EXT_PPR_LEN;
	siop_cmd->siop_tables->msg_out[offset + 2] = MSG_EXT_PPR;
	siop_cmd->siop_tables->msg_out[offset + 3] = ssync;
	siop_cmd->siop_tables->msg_out[offset + 4] = 0; /* reserved */
	siop_cmd->siop_tables->msg_out[offset + 5] = soff;
	siop_cmd->siop_tables->msg_out[offset + 6] = 1; /* wide */
	siop_cmd->siop_tables->msg_out[offset + 7] = MSG_EXT_PPR_PROT_DT;
	siop_cmd->siop_tables->t_msgout.count =
	    siop_htoc32(siop_cmd->siop_sc, offset + MSG_EXT_PPR_LEN + 2);
}

void
siop_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > SIOP_MAXFER)
		bp->b_bcount = SIOP_MAXFER;

	minphys(bp);
}

void
siop_ma(siop_cmd)
	struct siop_common_cmd *siop_cmd;
{
	int offset, dbc, sstat;
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	scr_table_t *table; /* table with partial xfer */

	/*
	 * compute how much of the current table didn't get handled when
	 * a phase mismatch occurs
	 */
	if ((siop_cmd->xs->flags & (SCSI_DATA_OUT | SCSI_DATA_IN))
	    == 0)
	    return; /* no valid data transfer */

	offset = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SCRATCHA + 1);
	if (offset >= SIOP_NSG) {
		printf("%s: bad offset in siop_sdp (%d)\n",
		    sc->sc_dev.dv_xname, offset);
		return;
	}
	table = &siop_cmd->siop_tables->data[offset];
#ifdef DEBUG_DR
	printf("siop_ma: offset %d count=%d addr=0x%x ", offset,
	    table->count, table->addr);
#endif
	dbc = bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DBC) & 0x00ffffff;
	if (siop_cmd->xs->flags & SCSI_DATA_OUT) {
		if (sc->features & SF_CHIP_DFBC) {
			dbc +=
			    bus_space_read_2(sc->sc_rt, sc->sc_rh, SIOP_DFBC);
		} else {
			/* need to account stale data in FIFO */
			int dfifo =
			    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_DFIFO);
			if (sc->features & SF_CHIP_FIFO) {
				dfifo |= (bus_space_read_1(sc->sc_rt, sc->sc_rh,
				    SIOP_CTEST5) & CTEST5_BOMASK) << 8;
				dbc += (dfifo - (dbc & 0x3ff)) & 0x3ff;
			} else {
				dbc += (dfifo - (dbc & 0x7f)) & 0x7f;
			}
		}
		sstat = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SSTAT0);
		if (sstat & SSTAT0_OLF)
			dbc++;
		if ((sstat & SSTAT0_ORF) && (sc->features & SF_CHIP_DFBC) == 0)
			dbc++;
		if (siop_cmd->siop_target->flags & TARF_ISWIDE) {
			sstat = bus_space_read_1(sc->sc_rt, sc->sc_rh,
			    SIOP_SSTAT2);
			if (sstat & SSTAT2_OLF1)
				dbc++;
			if ((sstat & SSTAT2_ORF1) &&
			    (sc->features & SF_CHIP_DFBC) == 0)
				dbc++;
		}
		/* clear the FIFO */
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST3,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST3) |
		    CTEST3_CLF);
	}
	siop_cmd->flags |= CMDFL_RESID;
	siop_cmd->resid = dbc;
}

void
siop_sdp(siop_cmd, offset)
	struct siop_common_cmd *siop_cmd;
	int offset;
{
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	scr_table_t *table;
	
	if ((siop_cmd->xs->flags & (SCSI_DATA_OUT | SCSI_DATA_IN))
	    == 0)
	    return; /* no data pointers to save */

	/*
	 * offset == SIOP_NSG may be a valid condition if we get a Save data
	 * pointer when the xfer is done. Just ignore the Save data pointer
	 * in this case
	 */
	if (offset == SIOP_NSG)
		return;
#ifdef DIAGNOSTIC
	if (offset > SIOP_NSG) {
		sc_print_addr(siop_cmd->xs->sc_link);
		printf("offset %d > %d\n", offset, SIOP_NSG);
		panic("siop_sdp: offset");
	}
#endif
	/*
	 * Save data pointer. We do this by adjusting the tables to point
	 * at the beginning of the data not yet transferred.
	 * offset points to the first table with untransferred data.
	 */

	/*
	 * before doing that we decrease resid from the amount of data which
	 * has been transferred.
	 */
	siop_update_resid(siop_cmd, offset);

	/*
	 * First let see if we have a resid from a phase mismatch. If so,
	 * we have to adjst the table at offset to remove transferred data.
	 */
	if (siop_cmd->flags & CMDFL_RESID) {
		siop_cmd->flags &= ~CMDFL_RESID;
		table = &siop_cmd->siop_tables->data[offset];
		/* "cut" already transferred data from this table */
		table->addr =
		    siop_htoc32(sc, siop_ctoh32(sc, table->addr) +
		    siop_ctoh32(sc, table->count) - siop_cmd->resid);
		table->count = siop_htoc32(sc, siop_cmd->resid);
	}

	/*
	 * now we can remove entries which have been transferred.
	 * We just move the entries with data left at the beginning of the
	 * tables
	 */
	bcopy(&siop_cmd->siop_tables->data[offset],
	    &siop_cmd->siop_tables->data[0],
	    (SIOP_NSG - offset) * sizeof(scr_table_t));
}

void
siop_update_resid(siop_cmd, offset)
	struct siop_common_cmd *siop_cmd;
	int offset;
{
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	scr_table_t *table;
	int i;

	if ((siop_cmd->xs->flags & (SCSI_DATA_OUT | SCSI_DATA_IN))
	    == 0)
	    return; /* no data to transfer */

	/*
	 * update resid. First account for the table entries which have
	 * been fully completed.
	 */
	for (i = 0; i < offset; i++)
		siop_cmd->xs->resid -=
		    siop_ctoh32(sc, siop_cmd->siop_tables->data[i].count);
	/*
	 * if CMDFL_RESID is set, the last table (pointed by offset) is a
	 * partial transfers. If not, offset points to the entry folloing
	 * the last full transfer.
	 */
	if (siop_cmd->flags & CMDFL_RESID) {
		table = &siop_cmd->siop_tables->data[offset];
		siop_cmd->xs->resid -=
		    siop_ctoh32(sc, table->count) - siop_cmd->resid;
	}
}

int
siop_iwr(siop_cmd)
	struct siop_common_cmd *siop_cmd;
{
	int offset;
	scr_table_t *table; /* table with IWR */
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	/* handle ignore wide residue messages */

	/* if target isn't wide, reject */
	if ((siop_cmd->siop_target->flags & TARF_ISWIDE) == 0) {
		siop_cmd->siop_tables->t_msgout.count = siop_htoc32(sc, 1);
		siop_cmd->siop_tables->msg_out[0] = MSG_MESSAGE_REJECT;
		return SIOP_NEG_MSGOUT;
	}
	/* get index of current command in table */
	offset = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SCRATCHA + 1);
	/*
	 * if the current table did complete, we're now pointing at the
	 * next one. Go back one if we didn't see a phase mismatch.
	 */
	if ((siop_cmd->flags & CMDFL_RESID) == 0)
		offset--;
	table = &siop_cmd->siop_tables->data[offset];

	if ((siop_cmd->flags & CMDFL_RESID) == 0) {
		if (siop_ctoh32(sc, table->count) & 1) {
			/* we really got the number of bytes we expected */
			return SIOP_NEG_ACK;
		} else {
			/*
			 * now we really had a short xfer, by one byte.
			 * handle it just as if we had a phase mistmatch
			 * (there is a resid of one for this table).
			 * Update scratcha1 to reflect the fact that
			 * this xfer isn't complete.
			 */
			 siop_cmd->flags |= CMDFL_RESID;
			 siop_cmd->resid = 1;
			 bus_space_write_1(sc->sc_rt, sc->sc_rh,
			     SIOP_SCRATCHA + 1, offset);
			 return SIOP_NEG_ACK;
		}
	} else {
		/*
		 * we already have a short xfer for this table; it's
		 * just one byte less than we though it was
		 */
		siop_cmd->resid--;
		return SIOP_NEG_ACK;
	}
}

void
siop_clearfifo(sc)
	struct siop_common_softc *sc;
{
	int timeout = 0;
	int ctest3 = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST3);

#ifdef DEBUG_INTR
	printf("DMA fifo not empty !\n");
#endif
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST3,
	    ctest3 | CTEST3_CLF);
	while ((bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST3) &
	    CTEST3_CLF) != 0) {
		delay(1);
		if (++timeout > 1000) {
			printf("clear fifo failed\n");
			bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST3,
			    bus_space_read_1(sc->sc_rt, sc->sc_rh,
			    SIOP_CTEST3) & ~CTEST3_CLF);
			return;
		}
	}
}

int
siop_modechange(sc)
	struct siop_common_softc *sc;
{
	int retry;
	int sist0, sist1, stest2;
	for (retry = 0; retry < 5; retry++) {
		/*
		 * datasheet says to wait 100ms and re-read SIST1,
		 * to check that DIFFSENSE is stable.
		 * We may delay() 5 times for  100ms at interrupt time;
		 * hopefully this will not happen often.
		 */
		delay(100000);
		sist0 = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SIST0);
		sist1 = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SIST1);
		if (sist1 & SIEN1_SBMC)
			continue; /* we got an irq again */
		sc->mode = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_STEST4) &
		    STEST4_MODE_MASK;
		stest2 = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_STEST2);
		switch(sc->mode) {
		case STEST4_MODE_DIF:
			printf("%s: switching to differential mode\n",
			    sc->sc_dev.dv_xname);
			bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST2,
			    stest2 | STEST2_DIF);
			break;
		case STEST4_MODE_SE:
			printf("%s: switching to single-ended mode\n",
			    sc->sc_dev.dv_xname);
			bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST2,
			    stest2 & ~STEST2_DIF);
			break;
		case STEST4_MODE_LVD:
			printf("%s: switching to LVD mode\n",
			    sc->sc_dev.dv_xname);
			bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST2,
			    stest2 & ~STEST2_DIF);
			break;
		default:
			printf("%s: invalid SCSI mode 0x%x\n",
			    sc->sc_dev.dv_xname, sc->mode);
			return 0;
		}
		return 1;
	}
	printf("%s: timeout waiting for DIFFSENSE to stabilise\n",
	    sc->sc_dev.dv_xname);
	return 0;
}

void
siop_resetbus(sc)
	struct siop_common_softc *sc;
{
	int scntl1;
	scntl1 = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL1);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL1,
	    scntl1 | SCNTL1_RST);
	/* minimum 25 us, more time won't hurt */
	delay(100);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL1, scntl1);
}

void
siop_update_xfer_mode(sc, target)
        struct siop_common_softc *sc;
        int target;
{
	struct siop_common_target *siop_target;

	siop_target = sc->targets[target];
	
	printf("%s: target %d now using %s%s%d bit ",
            sc->sc_dev.dv_xname, target,
	    (siop_target->flags & TARF_TAG) ? "tagged " : "",
	    (siop_target->flags & TARF_ISDT) ? "DT " : "",
	    (siop_target->flags & TARF_ISWIDE) ? 16 : 8);

	if (siop_target->offset == 0)
		printf("async ");
	else {
		switch (siop_target->period) {
		case 9: /*   12.5ns cycle */
			printf("80.0");
			break;
		case 10: /*  25  ns cycle */
			printf("40.0");
			break;
		case 12: /*  48  ns cycle */
			printf("20.0");
			break;
		case 18: /*  72  ns cycle */
			printf("13.3");
			break;
		case 25: /* 100  ns cycle */
			printf("10.0");
			break;
		case 37: /* 118  ns cycle */
			printf("6.67");
			break;
		case 50: /* 200  ns cycle */
			printf("5.0");
			break;
		case 75: /* 300  ns cycle */
			printf("3.33");
			break;
		default:
			printf("??");
			break;
		}
		printf(" MHz %d REQ/ACK offset ", siop_target->offset);
	}
	
	printf("xfers\n");

	if ((sc->features & SF_CHIP_GEBUG) &&
	    (siop_target->flags & TARF_ISWIDE) == 0)
		/* 1010 workaround: can't do disconnect if not wide, so can't do tag */
		siop_target->flags &= ~TARF_TAG;
}
@


1.35
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.34 2010/07/23 07:47:13 jsg Exp $ */
d38 1
a39 1
#include <machine/endian.h>
@


1.34
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.33 2009/02/16 21:19:07 miod Exp $ */
d808 2
a809 2
	 * at the beginning of the data not yet transfered. 
	 * offset points to the first table with untransfered data.
d814 1
a814 1
	 * has been transfered.
d820 1
a820 1
	 * we have to adjst the table at offset to remove transfered data.
d825 1
a825 1
		/* "cut" already transfered data from this table */
d833 1
a833 1
	 * now we can remove entries which have been transfered.
@


1.33
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.32 2009/01/29 22:50:23 miod Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.32
log
@``beginning'' is spelled with 2 `g' and 3 `n'.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.31 2008/08/31 17:21:57 miod Exp $ */
d710 1
a710 2
siop_minphys(bp)
	struct buf *bp;
@


1.31
log
@Fix redundant device name and/or target printing after calling
sc_print_addr(); ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.30 2007/08/05 19:05:09 kettenis Exp $ */
d814 1
a814 1
	 * at the begginning of the data not yet transfered. 
d840 1
a840 1
	 * We just move the entries with data left at the beggining of the
@


1.30
log
@Add support for the (non-pci) NCR 53c720/770 in big-endian mode.

ok martin@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.29 2006/03/16 22:11:24 miod Exp $ */
d808 1
a808 1
		printf(": offset %d > %d\n", offset, SIOP_NSG);
@


1.29
log
@Comment out tekram_sync_table and only degine {,dt_}scf_period[] for
siop_common.c; shaves half a KB.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.28 2005/11/25 16:33:19 krw Exp $ */
d251 1
a251 1
	siop_cmd->siop_tables->id = htole32(sc->targets[target]->id);
d270 1
a270 1
	siop_cmd->siop_tables->t_msgout.count= htole32(msgoffset);
d317 1
a317 1
	    htole32(SCSI_SIOP_NOSTATUS); /* set invalid status */
d325 2
a326 1
			    htole32(siop_cmd->dmamap_data->dm_segs[i].ds_len);
d328 2
a329 1
			    htole32(siop_cmd->dmamap_data->dm_segs[i].ds_addr);
d369 1
a369 1
			tables->t_msgout.count= htole32(1);
d373 1
a373 1
		tables->id = htole32(sc->targets[target]->id);
d398 1
a398 1
		tables->id = htole32(sc->targets[target]->id);
d522 1
a522 1
		tables->t_msgout.count= htole32(1);
d587 1
a587 1
		tables->t_msgout.count= htole32(1);
d650 1
a650 1
	tables->id = htole32(sc->targets[target]->id);
d674 1
a674 1
	    htole32(offset + MSG_EXT_SDTR_LEN + 2);
d688 1
a688 1
	    htole32(offset + MSG_EXT_WDTR_LEN + 2);
d706 1
a706 1
	    htole32(offset + MSG_EXT_PPR_LEN + 2);
d791 1
d833 3
a835 3
		    htole32(letoh32(table->addr) +
		    letoh32(table->count) - siop_cmd->resid);
		table->count = htole32(siop_cmd->resid);
d853 1
d867 1
a867 1
		    letoh32(siop_cmd->siop_tables->data[i].count);
d875 2
a876 1
		siop_cmd->xs->resid -= letoh32(table->count) - siop_cmd->resid;
d891 1
a891 1
		siop_cmd->siop_tables->t_msgout.count= htole32(1);
d906 1
a906 1
		if (letoh32(table->count) & 1) {
@


1.28
log
@FALLTHROUH -> FALLTHROUGH for lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.27 2005/11/20 22:32:48 krw Exp $ */
d51 1
@


1.27
log
@Un-revert backout to 20051009 and add patches from Martin Bouyer to
close NetBSD PR#31990. Fixes interaction with some problematic drives
found by miod@@, martin@@, otto@@.

Tested martin@@ otto@@ miod@@

ok miod@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.26 2005/11/03 11:00:36 martin Exp $ */
d353 1
a353 1
		/* FALLTHROUH */
@


1.26
log
@revert to 20051009 for now, need to investigate strange behaviour with
some controllers

discussed with otto@@ and henning@@, first noted by miod@@
@
text
@d1 2
a2 2
/*	$OpenBSD: siop_common.c,v 1.22 2005/10/08 19:21:10 krw Exp $ */
/*	$NetBSD: siop_common.c,v 1.31 2002/09/27 15:37:18 provos Exp $	*/
d24 1
a24 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
d71 1
a71 1
		error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, 
d444 1
a444 1
			
d717 1
a717 1
siop_sdp(siop_cmd)
a719 1
	/* save data pointer. Handle async only for now */
d722 1
a722 1
	scr_table_t *table; /* table to patch */
d724 4
d730 2
a731 1
	    return; /* no data pointers to save */
d740 2
a741 2
	printf("sdp: offset %d count=%d addr=0x%x ", offset,
	    letoh32(table->count), letoh32(table->addr));
d779 28
a806 6
	table->addr =
	    htole32(letoh32(table->addr) + letoh32(table->count) - dbc);
	table->count = htole32(dbc);
#ifdef DEBUG_DR
	printf("now count=%d addr=0x%x\n",
	    letoh32(table->count), letoh32(table->addr));
d808 117
@


1.25
log
@ammount -> amount
@
text
@d1 2
a2 2
/*	$OpenBSD: siop_common.c,v 1.24 2005/10/10 16:27:23 krw Exp $ */
/*	$NetBSD: siop_common.c,v 1.37 2005/02/27 00:27:02 perry Exp $	*/
d24 1
a24 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
d71 1
a71 1
		error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE,
d444 1
a444 1

d717 1
a717 1
siop_ma(siop_cmd)
d720 1
d723 1
a723 1
	scr_table_t *table; /* table with partial xfer */
a724 4
	/*
	 * compute how much of the current table didn't get handled when
	 * a phase mismatch occurs
	 */
d727 1
a727 2
	    return; /* no valid data transfer */

d736 2
a737 2
	printf("siop_ma: offset %d count=%d addr=0x%x ", offset,
	    table->count, table->addr);
d775 6
a780 28
	siop_cmd->flags |= CMDFL_RESID;
	siop_cmd->resid = dbc;
}

void
siop_sdp(siop_cmd, offset)
	struct siop_common_cmd *siop_cmd;
	int offset;
{
	scr_table_t *table;
	
	if ((siop_cmd->xs->flags & (SCSI_DATA_OUT | SCSI_DATA_IN))
	    == 0)
	    return; /* no data pointers to save */

	/*
	 * offset == SIOP_NSG may be a valid condition if we get a Save data
	 * pointer when the xfer is done. Just ignore the Save data pointer
	 * in this case
	 */
	if (offset == SIOP_NSG)
		return;
#ifdef DIAGNOSTIC
	if (offset > SIOP_NSG) {
		sc_print_addr(siop_cmd->xs->sc_link);
		printf(": offset %d > %d\n", offset, SIOP_NSG);
		panic("siop_sdp: offset");
	}
a781 117
	/*
	 * Save data pointer. We do this by adjusting the tables to point
	 * at the begginning of the data not yet transfered. 
	 * offset points to the first table with untransfered data.
	 */

	/*
	 * before doing that we decrease resid from the amount of data which
	 * has been transfered.
	 */
	siop_update_resid(siop_cmd, offset);

	/*
	 * First let see if we have a resid from a phase mismatch. If so,
	 * we have to adjst the table at offset to remove transfered data.
	 */
	if (siop_cmd->flags & CMDFL_RESID) {
		siop_cmd->flags &= ~CMDFL_RESID;
		table = &siop_cmd->siop_tables->data[offset];
		/* "cut" already transfered data from this table */
		table->addr =
		    htole32(letoh32(table->addr) +
		    letoh32(table->count) - siop_cmd->resid);
		table->count = htole32(siop_cmd->resid);
	}

	/*
	 * now we can remove entries which have been transfered.
	 * We just move the entries with data left at the beggining of the
	 * tables
	 */
	bcopy(&siop_cmd->siop_tables->data[offset],
	    &siop_cmd->siop_tables->data[0],
	    (SIOP_NSG - offset) * sizeof(scr_table_t));
}

void
siop_update_resid(siop_cmd, offset)
	struct siop_common_cmd *siop_cmd;
	int offset;
{
	scr_table_t *table;
	int i;

	if ((siop_cmd->xs->flags & (SCSI_DATA_OUT | SCSI_DATA_IN))
	    == 0)
	    return; /* no data to transfer */

	/*
	 * update resid. First account for the table entries which have
	 * been fully completed.
	 */
	for (i = 0; i < offset; i++)
		siop_cmd->xs->resid -=
		    letoh32(siop_cmd->siop_tables->data[i].count);
	/*
	 * if CMDFL_RESID is set, the last table (pointed by offset) is a
	 * partial transfers. If not, offset points to the entry folloing
	 * the last full transfer.
	 */
	if (siop_cmd->flags & CMDFL_RESID) {
		table = &siop_cmd->siop_tables->data[offset];
		siop_cmd->xs->resid -= letoh32(table->count) - siop_cmd->resid;
	}
}

int
siop_iwr(siop_cmd)
	struct siop_common_cmd *siop_cmd;
{
	int offset;
	scr_table_t *table; /* table with IWR */
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	/* handle ignore wide residue messages */

	/* if target isn't wide, reject */
	if ((siop_cmd->siop_target->flags & TARF_ISWIDE) == 0) {
		siop_cmd->siop_tables->t_msgout.count= htole32(1);
		siop_cmd->siop_tables->msg_out[0] = MSG_MESSAGE_REJECT;
		return SIOP_NEG_MSGOUT;
	}
	/* get index of current command in table */
	offset = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SCRATCHA + 1);
	/*
	 * if the current table did complete, we're now pointing at the
	 * next one. Go back one if we didn't see a phase mismatch.
	 */
	if ((siop_cmd->flags & CMDFL_RESID) == 0)
		offset--;
	table = &siop_cmd->siop_tables->data[offset];

	if ((siop_cmd->flags & CMDFL_RESID) == 0) {
		if (letoh32(table->count) & 1) {
			/* we really got the number of bytes we expected */
			return SIOP_NEG_ACK;
		} else {
			/*
			 * now we really had a short xfer, by one byte.
			 * handle it just as if we had a phase mistmatch
			 * (there is a resid of one for this table).
			 * Update scratcha1 to reflect the fact that
			 * this xfer isn't complete.
			 */
			 siop_cmd->flags |= CMDFL_RESID;
			 siop_cmd->resid = 1;
			 bus_space_write_1(sc->sc_rt, sc->sc_rh,
			     SIOP_SCRATCHA + 1, offset);
			 return SIOP_NEG_ACK;
		}
	} else {
		/*
		 * we already have a short xfer for this table; it's
		 * just one byte less than we though it was
		 */
		siop_cmd->resid--;
		return SIOP_NEG_ACK;
	}
@


1.24
log
@Add handling for IGNORE WIDE RESIDUE messages. Actually calculate
resid instead of assuming it is always 0. From bouyer via NetBSD. Note
we are now sync'd with the latest (1.78 siop.c, 1.37 siop_common.c)
NetBSD code.

Tested by various people over the last year+. Didn't solve any of
their problems but didn't cause any regression either.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.23 2005/10/08 23:46:11 krw Exp $ */
d815 1
a815 1
	 * before doing that we decrease resid from the ammount of data which
@


1.23
log
@More trailing whitespace removal (perry via NetBSD).
@
text
@d1 2
a2 2
/*	$OpenBSD: siop_common.c,v 1.22 2005/10/08 19:21:10 krw Exp $ */
/*	$NetBSD: siop_common.c,v 1.31 2002/09/27 15:37:18 provos Exp $	*/
d717 1
a717 1
siop_sdp(siop_cmd)
a719 1
	/* save data pointer. Handle async only for now */
d722 1
a722 1
	scr_table_t *table; /* table to patch */
d724 4
d730 2
a731 1
	    return; /* no data pointers to save */
d740 2
a741 2
	printf("sdp: offset %d count=%d addr=0x%x ", offset,
	    letoh32(table->count), letoh32(table->addr));
d779 28
a806 6
	table->addr =
	    htole32(letoh32(table->addr) + letoh32(table->count) - dbc);
	table->count = htole32(dbc);
#ifdef DEBUG_DR
	printf("now count=%d addr=0x%x\n",
	    letoh32(table->count), letoh32(table->addr));
d808 117
@


1.22
log
@If SF_CHIP_AAIP is set then disable AIP to avoid confusing
pre-Ultra160 drives (bouyer via NetBSD from FreeBSD). Affects
1010-66 only.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.21 2004/07/21 19:55:30 mickey Exp $ */
d24 1
a24 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
d71 1
a71 1
		error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, 
d444 1
a444 1
			
@


1.21
log
@remove hppa workarounds; from jkunz@@ pr3861
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.20 2004/06/12 22:22:26 krw Exp $ */
d183 3
d187 1
a187 1
	/* enable clock doubler or quadruler if appropriate */
@


1.20
log
@Add check for bp->b_bcount in siop_minphys() as other drivers have.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.19 2004/01/15 17:51:42 miod Exp $ */
a270 1
#ifndef __hppa__
a272 1
#endif
@


1.19
log
@Provide explicit function argument declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.18 2003/10/27 03:07:39 mickey Exp $ */
d709 3
@


1.18
log
@disable tagging on hppa and thus effectively restrict to one command at a time processing; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.17 2003/09/29 18:52:53 mickey Exp $ */
d677 1
@


1.17
log
@e own SIOP_DEBUG define instea of the system-wide one;
bzero() the sgl before fillig it up;
avoid reading registers extra times where we have a copy in the vars;
on scsi_cmd timeout call siop_handle_reset() directly instead of
    relying on the RST interrupt which does not happen always it semms;
use bus_dmamap_load_raw().
krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.16 2003/07/01 17:15:06 krw Exp $ */
d271 1
d274 1
@


1.16
log
@Don't dma map the xs->cmd. Copy it to a safe buffer that is already
mapped and sync'ed appropriately, and is guaranteed to be in one
memory page.

Eliminate now unused dmamap_cmd and rs_cmd fields.

Fix another error message (adding active command to reset list) so
that it includes the adapter name.

Add missing letoh32() calls to debug code.

The evils of directly mapping *xs->cmd were pointed out by Mickey
during osiop development. In particular, *xs->cmd may start on one
memory page and run into the next. Since the dma logic in most
cards/drivers (including siop) only allocates one address/size pair to
map *xs->cmd, parts of a command could be lost or corrupted.

The large number of 6 byte dma mappings noted long ago by someone
(Henric?).  This change reduces the dma mapping activity per i/o by
1/3 to 1/2 and may give a performance boost of some kind.

Successfully tested on i386, sparc64 (ultra30 - thanks Jolan,
blade100), macppc and alpha.

Unfortunately these changes don't fix the Blade1000 siop problems.

**NOTE** If scsi_generic is ever upped to 16 bytes the offsets in
siop.ss must be updated!
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.15 2002/10/09 23:43:11 krw Exp $ */
d317 2
@


1.15
log
@Remove trailing '\n's from panic messages.

Started by a commit to siop from provos@@netbsd.org.

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.14 2002/09/16 00:53:12 krw Exp $ */
a314 4
	siop_cmd->siop_tables->cmd.count =
	    htole32(siop_cmd->dmamap_cmd->dm_segs[0].ds_len);
	siop_cmd->siop_tables->cmd.addr =
	    htole32(siop_cmd->dmamap_cmd->dm_segs[0].ds_addr);
d418 1
a418 1
	printf("%s: anserw on ppr negotiation:", sc->sc_dev.dv_xname);
d728 1
a728 1
	    table->count, table->addr);
d770 2
a771 1
	printf("now count=%d addr=0x%x\n", table->count, table->addr);
@


1.14
log
@Resync siop with NetBSD. Make strong effort to minimize
differences, undoing whitespace, spelling, etc. changes
and adopting the NetBSD code instead of equivalent home
grown code for PPR negotiation, etc.

siop.c            1.21 -> 1.64
siop_common.c     1.12 -> 1.30
siopreg.h         1.7  -> 1.13
siopvar.h         1.13 -> 1.18
siopvar_common.h  1.10 -> 1.21
ncr53cxxx.c       1.5  -> 1.10
siop.ss           1.12 -> 1.17
siop_pci.c        1.8  -> 1.11
siop_pci_common.c 1.6  -> 1.17
siop_pci_common.h 1.2  -> 1.4

Many fixes, add 1010-66 support, restructure things to prepare for
addition of esiop, osiop and oosiop drivers.

tested on various archs by art@@, millert@@, wilfried@@, jason@@,
Dan Weeks.

ok deraadt@@.
@
text
@d1 2
a2 2
/*	$OpenBSD: siop_common.c,v 1.13 2002/03/14 01:26:55 millert Exp $ */
/*	$NetBSD: siop_common.c,v 1.30 2002/08/29 18:23:52 bouyer Exp $	*/
d137 1
a137 1
		panic("siop: can't find my sync parameters\n");
d147 1
a147 1
		panic("siop: can't find my sync parameters\n");
@


1.13
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: siop_common.c,v 1.12 2001/10/30 00:02:55 krw Exp $ */
/*	$NetBSD: siop_common.c,v 1.12 2001/02/11 18:04:50 bouyer Exp $	*/
d5 1
a5 1
 * Copyright (c) 2000 Manuel Bouyer.
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer
d52 1
a53 1
#include <dev/ic/siopvar_common.h>
d57 9
d67 83
a149 1
int siop_find_lun0_quirks(struct siop_softc *, u_int8_t, u_int16_t);
d153 1
a153 1
	struct siop_softc *sc;
a166 2
	if (sc->features & SF_CHIP_C10)
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL4, 0);
d189 1
a189 1
		if ((sc->features & (SF_CHIP_QUAD | SF_CHIP_C10)) == SF_CHIP_QUAD) {
d211 19
a229 1
		
a232 20
int
siop_find_lun0_quirks(sc, bus, target)
	struct siop_softc *sc;
	u_int8_t bus;
	u_int16_t target;
{
	struct scsi_link *sc_link;
	struct device *dev;

	for (dev = TAILQ_FIRST(&alldevs); dev != NULL; dev = TAILQ_NEXT(dev, dv_list))
		if (dev->dv_parent == (struct device *)sc) {
			sc_link = ((struct scsibus_softc *)dev)->sc_link[target][0];
			if ((sc_link != NULL) && (sc_link->scsibus == bus))
				return sc_link->quirks;
		}

	/* If we can't find a quirks entry, assume the worst */
	return (SDEV_NOTAGS | SDEV_NOWIDE | SDEV_NOSYNC);
}

d236 1
a236 1
	struct siop_cmd *siop_cmd;
d239 1
a239 1
	struct siop_softc *sc = siop_cmd->siop_sc;
d243 1
d247 17
a263 4
	siop_cmd->siop_tables.id = htole32(sc->targets[target]->id);
	memset(siop_cmd->siop_tables.msg_out, 0, 8);
	if (siop_cmd->status != CMDST_SENSE)
		siop_cmd->siop_tables.msg_out[0] = MSG_IDENTIFY(lun, 1);
d265 2
a266 2
		siop_cmd->siop_tables.msg_out[0] = MSG_IDENTIFY(lun, 0);
	siop_cmd->siop_tables.t_msgout.count= htole32(1);
d268 2
a269 5
		*targ_flags = 0;
		if (lun == 0)
			quirks = xs->sc_link->quirks;
		else
			quirks = siop_find_lun0_quirks(sc, xs->sc_link->scsibus, target);
d271 1
a271 1
		if ((quirks & SDEV_NOTAGS) == 0) {
d273 2
a274 3
			xs->sc_link->openings += SIOP_NTAG - SIOP_OPENINGS;
		}
		if ((quirks & SDEV_NOWIDE) == 0)
d279 8
d288 1
a288 1
		siop_add_dev(sc, target, 0);
d290 2
a291 3
		if ((sc->features & SF_CHIP_C10)
		    && (*targ_flags & TARF_WIDE)
		    && (xs->sc_link->inquiry_flags2 & (SID_CLOCKING | SID_QAS | SID_IUS))) {
d293 2
a294 3
			siop_ppr_msg(siop_cmd, 1, 
				     (sc->min_dt_sync == 0) ? sc->min_st_sync : sc->min_dt_sync,
				     sc->maxoff);
d297 2
a298 1
			siop_wdtr_msg(siop_cmd, 1, MSG_EXT_WDTR_BUS_16_BIT);
d301 2
a302 1
			siop_sdtr_msg(siop_cmd, 1, sc->min_st_sync, sc->maxoff);
d305 1
a305 1
			siop_print_info(sc, target);
d312 1
a312 1
	siop_cmd->siop_tables.status =
d315 1
a315 1
	siop_cmd->siop_tables.cmd.count =
d317 1
a317 1
	siop_cmd->siop_tables.cmd.addr =
d322 1
a322 1
			siop_cmd->siop_tables.data[i].count =
d324 1
a324 1
			siop_cmd->siop_tables.data[i].addr =
a327 76
	siop_table_sync(siop_cmd, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
}

int
siop_ppr_neg(siop_cmd)
	struct siop_cmd *siop_cmd;
{
	struct siop_softc *sc = siop_cmd->siop_sc;
	struct siop_target *siop_target = siop_cmd->siop_target;
	int target = siop_cmd->xs->sc_link->target;
	struct siop_xfer_common *tables = &siop_cmd->siop_xfer->tables;
	int offset, sync, protocol, scf;

	sync     = tables->msg_in[3];
	offset   = tables->msg_in[5];
	protocol = tables->msg_in[7];

#ifdef DEBUG
	printf("%s: siop_ppr_neg: sync = %x, offset = %x, protocol = %x\n",
	    sc->sc_dev.dv_xname, sync, offset, protocol);
#endif
	/*
	 * Process protocol bits first, because finding the correct scf
	 * via siop_period_factor_to_scf() requires the TARF_ISDT flag
	 * to be correctly set.
	 */
	if (protocol & MSG_EXT_PPR_PROT_IUS)
		siop_target->flags |= TARF_ISIUS;

	if (protocol & MSG_EXT_PPR_PROT_DT) {
		siop_target->flags |= TARF_ISDT;
		sc->targets[target]->id |= SCNTL4_ULTRA3;
	}

	if (protocol & MSG_EXT_PPR_PROT_QAS)
		siop_target->flags |= TARF_ISQAS;

	scf = siop_period_factor_to_scf(sc, sync, siop_target->flags);

	if ((offset > sc->maxoff) ||
	    (scf == 0) ||
	    ((siop_target->flags & TARF_ISDT) && (offset == 1))) {
		tables->t_msgout.count= htole32(1);
		tables->msg_out[0] = MSG_MESSAGE_REJECT;
		return (SIOP_NEG_MSGOUT);
	}

	siop_target->id |= scf << (24 + SCNTL3_SCF_SHIFT);

	if (((sc->features & SF_CHIP_C10) == 0) && (sync < 25))
		siop_target->id |= SCNTL3_ULTRA << 24;

	siop_target->id |= (offset & 0xff) << 8;
	
	if (tables->msg_in[6] == MSG_EXT_WDTR_BUS_16_BIT) {
		siop_target->flags |= TARF_ISWIDE;
		sc->targets[target]->id |= (SCNTL3_EWS << 24);
	}

#ifdef DEBUG
	printf("%s: siop_ppr_neg: id now 0x%x, flags is now 0x%x\n",
	    sc->sc_dev.dv_xname, siop_target->id, siop_target->flags);
#endif
	tables->id = htole32(siop_target->id);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL3,
	    (siop_target->id >> 24) & 0xff);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SXFER,
	    (siop_target->id >> 8) & 0xff);
	/* Only cards with SCNTL4 can cause PPR negotiations, so ... */
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL4,
	    (siop_target->id & 0xff));

	siop_target->status = TARST_OK;
	siop_print_info(sc, target);
	
	return (SIOP_NEG_ACK);
d332 1
a332 1
	struct siop_cmd *siop_cmd;
d334 2
a335 2
	struct siop_softc *sc = siop_cmd->siop_sc;
	struct siop_target *siop_target = siop_cmd->siop_target;
d337 1
a337 13
	struct siop_xfer_common *tables = &siop_cmd->siop_xfer->tables;

	/* revert to narrow async until told otherwise */
	sc->targets[target]->id    &= 0x07ff0000; /* Keep SCNTL3.CCF and id */
	sc->targets[target]->flags &= ~(TARF_ISWIDE | TARF_ISDT | TARF_ISQAS | TARF_ISIUS);

	tables->id = htole32(sc->targets[target]->id);
	
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL3,
	    (sc->targets[target]->id >> 24) & 0xff);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SXFER,  0);
	if (sc->features & SF_CHIP_C10)
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL4, 0);
d352 1
a352 1
		/* FALLTHROUGH */
d355 2
a356 2
 			 * We got more than we can handle, which shouldn't
			 * happen. Reject, and stay async.
d360 2
a364 1
			siop_print_info(sc, target);
d376 2
a377 1
			siop_sdtr_msg(siop_cmd, 0, sc->min_st_sync, sc->maxoff);
d381 1
a381 1
			siop_print_info(sc, target);
d398 2
a399 1
		 * Don't schedule a sync neg, target should initiate it.
d401 3
a403 4
		if (siop_target->status != TARST_PROBING) {
			siop_target->status = TARST_OK;
			siop_print_info(sc, target);
		}
d411 114
d526 1
a526 1
	struct siop_cmd *siop_cmd;
d528 2
a529 2
	struct siop_softc *sc = siop_cmd->siop_sc;
	struct siop_target *siop_target = siop_cmd->siop_target;
d531 1
a531 1
	int sync, offset, scf;
d533 4
a536 1
	struct siop_xfer_common *tables = &siop_cmd->siop_xfer->tables;
a540 4
	/* revert to async until told otherwise */
	sc->targets[target]->id    &= 0x0fff0000; /* Keep SCNTL3.EWS, SCNTL3.CCF and id */
	sc->targets[target]->flags &= ~(TARF_ISDT | TARF_ISQAS | TARF_ISIUS);

d543 1
d545 1
a545 2
		printf("%s: sdtr for target %d: sync %d offset %d\n",
		    sc->sc_dev.dv_xname, target, sync, offset);
d547 2
a548 2
		scf = siop_period_factor_to_scf(sc, sync, sc->targets[target]->flags);
		if (offset > sc->maxoff || scf == 0)
d550 27
a576 5
		sc->targets[target]->id |= scf << (24 + SCNTL3_SCF_SHIFT);
		if (((sc->features & SF_CHIP_C10) == 0) && (sync < 25))
			sc->targets[target]->id |= SCNTL3_ULTRA << 24;
		sc->targets[target]->id |= (offset & 0xff) << 8;
		goto end;
d578 2
a579 2
		 * We didn't find it in our table, so stay async and send reject
		 * msg.
d585 5
a591 2
		printf("%s: target initiated sdtr for target %d: sync %d offset %d\n",
		    sc->sc_dev.dv_xname, target, sync, offset);
d594 1
a594 6
		if (sync < sc->min_st_sync)
			sync = sc->min_st_sync;
		scf = siop_period_factor_to_scf(sc, sync, sc->targets[target]->flags);
		if ((sc->targets[target]->flags & TARF_SYNC) == 0
		    || offset == 0
		    || scf == 0) {
d597 34
a630 12
		if ((offset > 31) && ((sc->targets[target]->flags & TARF_ISDT) == 0))
			offset = 31;
		if (offset > sc->maxoff)
			offset = sc->maxoff;

		sc->targets[target]->id |= scf << (24 + SCNTL3_SCF_SHIFT);
		if (((sc->features & SF_CHIP_C10) == 0) && (sync < 25))
			sc->targets[target]->id |= SCNTL3_ULTRA << 24;
		sc->targets[target]->id |= (offset & 0xff) << 8;
		siop_sdtr_msg(siop_cmd, 0, sync, offset);
		send_msgout = 1;
		goto end;
d632 5
d641 2
a650 6

	if (siop_target->status != TARST_PROBING) {
		siop_target->status = TARST_OK;
		siop_print_info(sc, target);
	}

a658 34
siop_ppr_msg(siop_cmd, offset, ssync, soff)
	struct siop_cmd *siop_cmd;
	int offset, ssync, soff;
{
	struct siop_softc *sc = siop_cmd->siop_sc;
	u_int8_t protocol;

	siop_cmd->siop_tables.msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables.msg_out[offset + 1] = MSG_EXT_PPR_LEN;
	siop_cmd->siop_tables.msg_out[offset + 2] = MSG_EXT_PPR;
	siop_cmd->siop_tables.msg_out[offset + 3] = ssync;
	siop_cmd->siop_tables.msg_out[offset + 4] = 0; /* RESERVED */
	siop_cmd->siop_tables.msg_out[offset + 5] = soff;
	siop_cmd->siop_tables.msg_out[offset + 6] = MSG_EXT_WDTR_BUS_16_BIT;

	protocol = 0;
	if (sc->min_dt_sync != 0)
		protocol |= MSG_EXT_PPR_PROT_DT;

	/* XXX - need tests for chip's capability to do QAS & IUS
	 *       
	 * if (test for QAS support)
	 *         protocol |= MSG_EXT_PPR_PROT_QAS;
	 * if (test for IUS support)
	 *         protocol |= MSG_EXT_PPR_PROT_IUS;
	 */

	siop_cmd->siop_tables.msg_out[offset + 7] = protocol;

	siop_cmd->siop_tables.t_msgout.count =
	    htole32(offset + MSG_EXT_PPR_LEN + 2);
}

void
d660 1
a660 1
	struct siop_cmd *siop_cmd;
d664 6
a669 10
	siop_cmd->siop_tables.msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables.msg_out[offset + 1] = MSG_EXT_SDTR_LEN;
	siop_cmd->siop_tables.msg_out[offset + 2] = MSG_EXT_SDTR;
	siop_cmd->siop_tables.msg_out[offset + 3] = ssync;

	if ((soff > 31) && ((siop_cmd->siop_target->flags & TARF_ISDT) == 0))
		soff = 31;

	siop_cmd->siop_tables.msg_out[offset + 4] = soff;
	siop_cmd->siop_tables.t_msgout.count =
d675 1
a675 1
	struct siop_cmd *siop_cmd;
d678 5
a682 5
	siop_cmd->siop_tables.msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables.msg_out[offset + 1] = MSG_EXT_WDTR_LEN;
	siop_cmd->siop_tables.msg_out[offset + 2] = MSG_EXT_WDTR;
	siop_cmd->siop_tables.msg_out[offset + 3] = wide;
	siop_cmd->siop_tables.t_msgout.count =
d687 18
d713 1
a713 1
	struct siop_cmd *siop_cmd;
d717 2
a718 2
	struct siop_softc *sc = siop_cmd->siop_sc;
	struct scr_table *table; /* table to patch */
d729 1
a729 1
	table = &siop_cmd->siop_xfer->tables.data[offset];
d736 7
a742 5
		/* need to account for stale data in FIFO */
		if (sc->features & SF_CHIP_C10)
			dbc += bus_space_read_2(sc->sc_rt, sc->sc_rh, SIOP_DFBC);
		else {
			int dfifo = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_DFIFO);
d745 1
a745 1
					      SIOP_CTEST5) & CTEST5_BOMASK) << 8;
d754 2
a755 3
		if ((sc->features & SF_CHIP_C10) == 0)
			if (sstat & SSTAT0_ORF)
				dbc++;
d761 3
a763 3
			if ((sc->features & SF_CHIP_C10) == 0)
				if (sstat & SSTAT2_ORF1)
					dbc++;
d780 1
a780 1
	struct siop_softc *sc;
d785 2
a786 2
#ifdef SIOP_DEBUG_INTR
	printf("DMA fifo not empty!\n");
d805 1
a805 1
	struct siop_softc *sc;
d808 1
a808 1
	int sist0, sist1, stest2, stest4;
d811 1
a811 1
		 * Datasheet says to wait 100ms and re-read SIST1,
d813 1
a813 1
		 * We may delay() 5 times for 100ms at interrupt time;
d821 1
a821 1
		stest4 = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_STEST4) &
d824 1
a824 1
		switch(stest4) {
d826 4
a829 10
			if (sc->features & SF_CHIP_C10) {
				printf("%s: invalid SCSI mode 0x%x\n",
				    sc->sc_dev.dv_xname, stest4);
				return 0;
			} else {
				printf("%s: switching to differential mode\n",
				    sc->sc_dev.dv_xname);
				bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST2,
				    stest2 | STEST2_DIF);
			}
d845 1
a845 1
			    sc->sc_dev.dv_xname, stest4);
a847 2
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST0,
		    stest4 >> 2);
d857 1
a857 1
	struct siop_softc *sc;
a867 6
/*
 * siop_print_info: print the current negotiated wide/sync xfer values for
 *                  a particular target. This function is called whenever
 *		    a wide/sync negotiation completes, i.e. whenever
 *		    target->status is set to TARST_OK.
 */
d869 2
a870 2
siop_print_info(sc, target)
        struct siop_softc *sc;
d873 1
a873 3
	struct siop_target *siop_target;
	u_int8_t scf, offset;
	int scf_index, factors, i;
d877 1
a877 1
	printf("%s: target %d now using %s%s%s%s%d bit ",
a880 2
	    (siop_target->flags & TARF_ISQAS) ? "QAS " : "",
	    (siop_target->flags & TARF_ISIUS) ? "IUS " : "",
d883 1
a883 3
	offset = ((siop_target->id >> 8) & 0xff) >> SXFER_MO_SHIFT;

	if (offset == 0)
d885 31
a915 20
	else { 
		factors = sizeof(period_factor) / sizeof(period_factor[0]);
		
		scf = ((siop_target->id >> 24) & SCNTL3_SCF_MASK) >> SCNTL3_SCF_SHIFT;
		scf_index = sc->scf_index;

		for (i = 0; i < factors; i++)
			if (siop_target->flags & TARF_ISDT) {
				if (period_factor[i].scf[scf_index].dt_scf == scf)
					break;
			}
			else if	(period_factor[i].scf[scf_index].st_scf == scf)
				break;

		if (i >= factors)
			printf("?? ");
		else
			printf("%s ", period_factor[i].rate);

		printf("MHz %d REQ/ACK offset ", offset);
a918 19
}

int
siop_period_factor_to_scf(sc, pf, flags)
	struct siop_softc *sc;
	int pf, flags;
{
	const int scf_index = sc->scf_index;
	int i;

	const int factors = sizeof(period_factor) / sizeof(period_factor[0]);

	for (i = 0; i < factors; i++)
		if (period_factor[i].factor == pf) {
			if (flags & TARF_ISDT)
				return (period_factor[i].scf[scf_index].dt_scf);
			else
				return (period_factor[i].scf[scf_index].st_scf);
		}
d920 4
a923 1
	return (0);
@


1.12
log
@From NetBSD: add __packed__ attribute to hardware structure that
lacked it (scr_table).

Also remove scr_table_t typedef and just use 'struct scr_table' to be
consistant with all other structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.11 2001/10/08 01:25:07 krw Exp $ */
d58 1
a58 1
int siop_find_lun0_quirks __P((struct siop_softc *, u_int8_t, u_int16_t));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.12 2001/10/30 00:02:55 krw Exp $ */
d58 1
a58 1
int siop_find_lun0_quirks(struct siop_softc *, u_int8_t, u_int16_t);
@


1.12.2.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: siop_common.c,v 1.31 2002/09/27 15:37:18 provos Exp $	*/
d5 1
a5 1
 * Copyright (c) 2000, 2002 Manuel Bouyer.
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
d52 1
a53 1
#include <dev/ic/siopvar.h>
a56 9
#undef DEBUG_NEG

int
siop_common_attach(sc)
	struct siop_common_softc *sc;
{
	int error, i;
	bus_dma_segment_t seg;
	int rseg;
d58 1
a58 83
	/*
	 * Allocate DMA-safe memory for the script and map it.
	 */
	if ((sc->features & SF_CHIP_RAM) == 0) {
		error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, 
		    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to allocate script DMA memory, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		error = bus_dmamem_map(sc->sc_dmat, &seg, rseg, PAGE_SIZE,
		    (caddr_t *)&sc->sc_script,
		    BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
		if (error) {
			printf("%s: unable to map script DMA memory, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1,
		    PAGE_SIZE, 0, BUS_DMA_NOWAIT, &sc->sc_scriptdma);
		if (error) {
			printf("%s: unable to create script DMA map, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		error = bus_dmamap_load(sc->sc_dmat, sc->sc_scriptdma,
		    sc->sc_script, PAGE_SIZE, NULL, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to load script DMA map, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		sc->sc_scriptaddr =
		    sc->sc_scriptdma->dm_segs[0].ds_addr;
		sc->ram_size = PAGE_SIZE;
	}

	/*
	 * sc->sc_link is the template for all device sc_link's
	 * for devices attached to this adapter. It is passed to
	 * the upper layers in config_found().
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_buswidth =
	    (sc->features & SF_BUS_WIDE) ? 16 : 8;
	sc->sc_link.adapter_target =
	    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SCID);
	if (sc->sc_link.adapter_target == 0 ||
	    sc->sc_link.adapter_target >=
	    sc->sc_link.adapter_buswidth)
		sc->sc_link.adapter_target = SIOP_DEFAULT_TARGET;

	for (i = 0; i < 16; i++)
		sc->targets[i] = NULL;

	/* find min/max sync period for this chip */
	sc->st_maxsync = 0;
	sc->dt_maxsync = 0;
	sc->st_minsync = 255;
	sc->dt_minsync = 255;
	for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]); i++) {
		if (sc->clock_period != scf_period[i].clock)
			continue;
		if (sc->st_maxsync < scf_period[i].period)
			sc->st_maxsync = scf_period[i].period;
		if (sc->st_minsync > scf_period[i].period)
			sc->st_minsync = scf_period[i].period;
	}
	if (sc->st_maxsync == 255 || sc->st_minsync == 0)
		panic("siop: can't find my sync parameters");
	for (i = 0; i < sizeof(dt_scf_period) / sizeof(dt_scf_period[0]); i++) {
		if (sc->clock_period != dt_scf_period[i].clock)
			continue;
		if (sc->dt_maxsync < dt_scf_period[i].period)
			sc->dt_maxsync = dt_scf_period[i].period;
		if (sc->dt_minsync > dt_scf_period[i].period)
			sc->dt_minsync = dt_scf_period[i].period;
	}
	if (sc->dt_maxsync == 255 || sc->dt_minsync == 0)
		panic("siop: can't find my sync parameters");
	return 0;
}
d62 1
a62 1
	struct siop_common_softc *sc;
d76 2
d100 1
a100 1
		if (sc->features & SF_CHIP_QUAD) {
d122 19
a140 11
	if (sc->features & SF_CHIP_LED0) {
		/* Set GPIO0 as output if software LED control is required */
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_GPCNTL,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_GPCNTL) & 0xfe);
	}
	if (sc->features & SF_BUS_ULTRA3) {
		/* reset SCNTL4 */
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL4, 0);
	}
	sc->mode = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_STEST4) &
	    STEST4_MODE_MASK;
d142 2
a143 8
	/*
	 * initialise the RAM. Without this we may get scsi gross errors on
	 * the 1010
	 */
	if (sc->features & SF_CHIP_RAM)
		bus_space_set_region_4(sc->sc_ramt, sc->sc_ramh,
			0, 0, sc->ram_size / 4);
	sc->sc_reset(sc);
d149 1
a149 1
	struct siop_common_cmd *siop_cmd;
d152 1
a152 1
	struct siop_common_softc *sc = siop_cmd->siop_sc;
a155 1
	int msgoffset = 1;
d159 4
a162 17
	siop_cmd->siop_tables->id = htole32(sc->targets[target]->id);
	memset(siop_cmd->siop_tables->msg_out, 0,
	    sizeof(siop_cmd->siop_tables->msg_out));
	/* request sense doesn't disconnect */
	if (siop_cmd->status == CMDST_SENSE)
		siop_cmd->siop_tables->msg_out[0] = MSG_IDENTIFY(lun, 0);
	else if ((sc->features & SF_CHIP_GEBUG) &&
	    (sc->targets[target]->flags & TARF_ISWIDE) == 0)
		/*
		 * 1010 bug: it seems that the 1010 has problems with reselect
		 * when not in wide mode (generate false SCSI gross error).
		 * The FreeBSD sym driver has comments about it but their
		 * workaround (disable SCSI gross error reporting) doesn't
		 * work with my adapter. So disable disconnect when not
		 * wide.
		 */
		siop_cmd->siop_tables->msg_out[0] = MSG_IDENTIFY(lun, 0);
d164 2
a165 2
		siop_cmd->siop_tables->msg_out[0] = MSG_IDENTIFY(lun, 1);
	siop_cmd->siop_tables->t_msgout.count= htole32(msgoffset);
d167 5
a171 2
		*targ_flags &= TARF_DT; /* Save TARF_DT 'cuz we don't set it here */
		quirks = xs->sc_link->quirks;
d173 1
a173 1
		if ((quirks & SDEV_NOTAGS) == 0)
d175 3
a177 2
		if (((quirks & SDEV_NOWIDE) == 0) &&
		    (sc->features & SF_BUS_WIDE))
a181 8
		if ((sc->features & SF_CHIP_GEBUG) &&
		    (*targ_flags & TARF_WIDE) == 0)
			/* 
			 * 1010 workaround: can't do disconnect if not wide,
			 * so can't do tag
			 */
			*targ_flags &= ~TARF_TAG;

d183 1
a183 1
		siop_add_dev((struct siop_softc *)sc, target, lun);
d185 3
a187 2
		if ((*targ_flags & TARF_DT) &&
		    (sc->mode == STEST4_MODE_LVD)) {
d189 3
a191 2
			 siop_ppr_msg(siop_cmd, msgoffset, sc->dt_minsync,
			    sc->maxoff);
d194 1
a194 2
			siop_wdtr_msg(siop_cmd, msgoffset,
			    MSG_EXT_WDTR_BUS_16_BIT);
d197 1
a197 2
			siop_sdtr_msg(siop_cmd, msgoffset, sc->st_minsync,
			(sc->maxoff > 31) ? 31 :  sc->maxoff);
d200 1
a200 1
			siop_update_xfer_mode(sc, target);
d207 1
a207 1
	siop_cmd->siop_tables->status =
d210 1
a210 1
	siop_cmd->siop_tables->cmd.count =
d212 1
a212 1
	siop_cmd->siop_tables->cmd.addr =
d217 1
a217 1
			siop_cmd->siop_tables->data[i].count =
d219 1
a219 1
			siop_cmd->siop_tables->data[i].addr =
d223 76
d303 1
a303 1
	struct siop_common_cmd *siop_cmd;
d305 2
a306 2
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct siop_common_target *siop_target = siop_cmd->siop_target;
d308 13
a320 1
	struct siop_common_xfer *tables = siop_cmd->siop_tables;
d335 1
a335 1
		/* FALLTHROUH */
d338 2
a339 2
 			 * hum, we got more than what we can handle, shouldn't
			 * happen. Reject, and stay async
a342 2
			siop_target->offset = siop_target->period = 0;
			siop_update_xfer_mode(sc, target);
d346 1
d358 1
a358 2
			siop_sdtr_msg(siop_cmd, 0, sc->st_minsync,
			    (sc->maxoff > 31) ? 31 : sc->maxoff);
d362 1
a362 1
			siop_update_xfer_mode(sc, target);
d379 1
a379 2
		 * we did reset wide parameters, so fall back to async,
		 * but don't schedule a sync neg, target should initiate it
d381 4
a384 3
		siop_target->status = TARST_OK;
		siop_target->offset = siop_target->period = 0;
		siop_update_xfer_mode(sc, target);
a391 114
siop_ppr_neg(siop_cmd)
	struct siop_common_cmd *siop_cmd;
{
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct siop_common_target *siop_target = siop_cmd->siop_target;
	int target = siop_cmd->xs->sc_link->target;
	struct siop_common_xfer *tables = siop_cmd->siop_tables;
	int sync, offset, options, scf = 0;
	int i;

#ifdef DEBUG_NEG
	printf("%s: anserw on ppr negotiation:", sc->sc_dev.dv_xname);
	for (i = 0; i < 8; i++)
		printf(" 0x%x", tables->msg_in[i]);
	printf("\n");
#endif

	if (siop_target->status == TARST_PPR_NEG) {
		/* we initiated PPR negotiation */
		sync = tables->msg_in[3];
		offset = tables->msg_in[5];
		options = tables->msg_in[7];
		if (options != MSG_EXT_PPR_PROT_DT) {
			/* should't happen */
			printf("%s: ppr negotiation for target %d: "
			    "no DT option\n", sc->sc_dev.dv_xname, target);
			siop_target->status = TARST_ASYNC;
			siop_target->flags &= ~(TARF_DT | TARF_ISDT);
			siop_target->offset = 0;
			siop_target->period = 0;
			goto reject;
		}
			
		if (offset > sc->maxoff || sync < sc->dt_minsync ||
		    sync > sc->dt_maxsync) {
			printf("%s: ppr negotiation for target %d: "
			    "offset (%d) or sync (%d) out of range\n",
			    sc->sc_dev.dv_xname, target, offset, sync);
			/* should not happen */
			siop_target->status = TARST_ASYNC;
			siop_target->flags &= ~(TARF_DT | TARF_ISDT);
			siop_target->offset = 0;
			siop_target->period = 0;
			goto reject;
		} else {
			for (i = 0; i <
			    sizeof(dt_scf_period) / sizeof(dt_scf_period[0]);
			    i++) {
				if (sc->clock_period != dt_scf_period[i].clock)
					continue;
				if (dt_scf_period[i].period == sync) {
					/* ok, found it. we now are sync. */
					siop_target->offset = offset;
					siop_target->period = sync;
					scf = dt_scf_period[i].scf;
					siop_target->flags |= TARF_ISDT;
				}
			}
			if ((siop_target->flags & TARF_ISDT) == 0) {
				printf("%s: ppr negotiation for target %d: "
				    "sync (%d) incompatible with adapter\n",
				    sc->sc_dev.dv_xname, target, sync);
				/*
				 * we didn't find it in our table, do async
				 * send reject msg, start SDTR/WDTR neg
				 */
				siop_target->status = TARST_ASYNC;
				siop_target->flags &= ~(TARF_DT | TARF_ISDT);
				siop_target->offset = 0;
				siop_target->period = 0;
				goto reject;
			}
		}
		if (tables->msg_in[6] != 1) {
			printf("%s: ppr negotiation for target %d: "
			    "transfer width (%d) incompatible with dt\n",
			    sc->sc_dev.dv_xname, target, tables->msg_in[6]);
			/* DT mode can only be done with wide transfers */
			siop_target->status = TARST_ASYNC;
			siop_target->flags &= ~(TARF_DT | TARF_ISDT);
			siop_target->offset = 0;
			siop_target->period = 0;
			goto reject;
		} 
		siop_target->flags |= TARF_ISWIDE;
		sc->targets[target]->id |= (SCNTL3_EWS << 24);
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id |= scf << (24 + SCNTL3_SCF_SHIFT);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
		sc->targets[target]->id |=
		    (siop_target->offset & SXFER_MO_MASK) << 8;
		sc->targets[target]->id &= ~0xff;
		sc->targets[target]->id |= SCNTL4_U3EN;
		siop_target->status = TARST_OK;
		siop_update_xfer_mode(sc, target);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL3,
		    (sc->targets[target]->id >> 24) & 0xff);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SXFER,
		    (sc->targets[target]->id >> 8) & 0xff);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL4,
		    sc->targets[target]->id & 0xff);
		return SIOP_NEG_ACK;
	} else {
		/* target initiated PPR negotiation, shouldn't happen */
		printf("%s: rejecting invalid PPR negotiation from "
		    "target %d\n", sc->sc_dev.dv_xname, target);
reject:
		tables->t_msgout.count= htole32(1);
		tables->msg_out[0] = MSG_MESSAGE_REJECT;
		return SIOP_NEG_MSGOUT;
	}
}

int
d393 1
a393 1
	struct siop_common_cmd *siop_cmd;
d395 2
a396 2
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct siop_common_target *siop_target = siop_cmd->siop_target;
d398 1
a398 1
	int sync, maxoffset, offset, i;
d400 1
a400 4
	struct siop_common_xfer *tables = siop_cmd->siop_tables;

	/* limit to Ultra/2 parameters, need PPR for Ultra/3 */
	maxoffset = (sc->maxoff > 31) ? 31 : sc->maxoff;
d405 4
a410 1
		siop_target->status = TARST_OK;
d412 2
a413 1
		printf("sdtr: sync %d offset %d\n", sync, offset);
d415 2
a416 2
		if (offset > maxoffset || sync < sc->st_minsync ||
			sync > sc->st_maxsync)
d418 5
a422 27
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]);
		    i++) {
			if (sc->clock_period != scf_period[i].clock)
				continue;
			if (scf_period[i].period == sync) {
				/* ok, found it. we now are sync. */
				siop_target->offset = offset;
				siop_target->period = sync;
				sc->targets[target]->id &=
				    ~(SCNTL3_SCF_MASK << 24);
				sc->targets[target]->id |= scf_period[i].scf
				    << (24 + SCNTL3_SCF_SHIFT);
				if (sync < 25 && /* Ultra */
				    (sc->features & SF_BUS_ULTRA3) == 0)
					sc->targets[target]->id |=
					    SCNTL3_ULTRA << 24;
				else
					sc->targets[target]->id &=
					    ~(SCNTL3_ULTRA << 24);
				sc->targets[target]->id &=
				    ~(SXFER_MO_MASK << 8);
				sc->targets[target]->id |=
				    (offset & SXFER_MO_MASK) << 8;
				sc->targets[target]->id &= ~0xff; /* scntl4 */
				goto end;
			}
		}
d424 2
a425 2
		 * we didn't find it in our table, do async and send reject
		 * msg
a430 5
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
		sc->targets[target]->id &= ~0xff; /* scntl4 */
		siop_target->offset = siop_target->period = 0;
d433 2
d437 6
a442 1
		if (offset == 0 || sync > sc->st_maxsync) { /* async */
d445 12
a456 34
		if (offset > maxoffset)
			offset = maxoffset;
		if (sync < sc->st_minsync)
			sync = sc->st_minsync;
		/* look for sync period */
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]);
		    i++) {
			if (sc->clock_period != scf_period[i].clock)
				continue;
			if (scf_period[i].period == sync) {
				/* ok, found it. we now are sync. */
				siop_target->offset = offset;
				siop_target->period = sync;
				sc->targets[target]->id &=
				    ~(SCNTL3_SCF_MASK << 24);
				sc->targets[target]->id |= scf_period[i].scf
				    << (24 + SCNTL3_SCF_SHIFT);
				if (sync < 25 && /* Ultra */
				    (sc->features & SF_BUS_ULTRA3) == 0)
					sc->targets[target]->id |=
					    SCNTL3_ULTRA << 24;
				else
					sc->targets[target]->id &=
					    ~(SCNTL3_ULTRA << 24);
				sc->targets[target]->id &=
				    ~(SXFER_MO_MASK << 8);
				sc->targets[target]->id |=
				    (offset & SXFER_MO_MASK) << 8;
				sc->targets[target]->id &= ~0xff; /* scntl4 */
				siop_sdtr_msg(siop_cmd, 0, sync, offset);
				send_msgout = 1;
				goto end;
			}
		}
a457 5
		siop_target->offset = siop_target->period = 0;
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
		sc->targets[target]->id &= ~0xff; /* scntl4 */
a461 2
	if (siop_target->status == TARST_OK)
		siop_update_xfer_mode(sc, target);
d470 6
d484 34
d519 1
a519 1
	struct siop_common_cmd *siop_cmd;
d523 10
a532 6
	siop_cmd->siop_tables->msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables->msg_out[offset + 1] = MSG_EXT_SDTR_LEN;
	siop_cmd->siop_tables->msg_out[offset + 2] = MSG_EXT_SDTR;
	siop_cmd->siop_tables->msg_out[offset + 3] = ssync;
	siop_cmd->siop_tables->msg_out[offset + 4] = soff;
	siop_cmd->siop_tables->t_msgout.count =
d538 1
a538 1
	struct siop_common_cmd *siop_cmd;
d541 5
a545 5
	siop_cmd->siop_tables->msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables->msg_out[offset + 1] = MSG_EXT_WDTR_LEN;
	siop_cmd->siop_tables->msg_out[offset + 2] = MSG_EXT_WDTR;
	siop_cmd->siop_tables->msg_out[offset + 3] = wide;
	siop_cmd->siop_tables->t_msgout.count =
a549 18
siop_ppr_msg(siop_cmd, offset, ssync, soff)
	struct siop_common_cmd *siop_cmd;
	int offset;
	int ssync, soff;
{
	siop_cmd->siop_tables->msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables->msg_out[offset + 1] = MSG_EXT_PPR_LEN;
	siop_cmd->siop_tables->msg_out[offset + 2] = MSG_EXT_PPR;
	siop_cmd->siop_tables->msg_out[offset + 3] = ssync;
	siop_cmd->siop_tables->msg_out[offset + 4] = 0; /* reserved */
	siop_cmd->siop_tables->msg_out[offset + 5] = soff;
	siop_cmd->siop_tables->msg_out[offset + 6] = 1; /* wide */
	siop_cmd->siop_tables->msg_out[offset + 7] = MSG_EXT_PPR_PROT_DT;
	siop_cmd->siop_tables->t_msgout.count =
	    htole32(offset + MSG_EXT_PPR_LEN + 2);
}

void
d558 1
a558 1
	struct siop_common_cmd *siop_cmd;
d562 2
a563 2
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	scr_table_t *table; /* table to patch */
d574 1
a574 1
	table = &siop_cmd->siop_tables->data[offset];
d581 5
a585 7
		if (sc->features & SF_CHIP_DFBC) {
			dbc +=
			    bus_space_read_2(sc->sc_rt, sc->sc_rh, SIOP_DFBC);
		} else {
			/* need to account stale data in FIFO */
			int dfifo =
			    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_DFIFO);
d588 1
a588 1
				    SIOP_CTEST5) & CTEST5_BOMASK) << 8;
d597 3
a599 2
		if ((sstat & SSTAT0_ORF) && (sc->features & SF_CHIP_DFBC) == 0)
			dbc++;
d605 3
a607 3
			if ((sstat & SSTAT2_ORF1) &&
			    (sc->features & SF_CHIP_DFBC) == 0)
				dbc++;
d624 1
a624 1
	struct siop_common_softc *sc;
d629 2
a630 2
#ifdef DEBUG_INTR
	printf("DMA fifo not empty !\n");
d649 1
a649 1
	struct siop_common_softc *sc;
d652 1
a652 1
	int sist0, sist1, stest2;
d655 1
a655 1
		 * datasheet says to wait 100ms and re-read SIST1,
d657 1
a657 1
		 * We may delay() 5 times for  100ms at interrupt time;
d665 1
a665 1
		sc->mode = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_STEST4) &
d668 1
a668 1
		switch(sc->mode) {
d670 10
a679 4
			printf("%s: switching to differential mode\n",
			    sc->sc_dev.dv_xname);
			bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST2,
			    stest2 | STEST2_DIF);
d695 1
a695 1
			    sc->sc_dev.dv_xname, sc->mode);
d698 2
d709 1
a709 1
	struct siop_common_softc *sc;
d720 6
d727 2
a728 2
siop_update_xfer_mode(sc, target)
        struct siop_common_softc *sc;
d731 3
a733 1
	struct siop_common_target *siop_target;
d737 1
a737 1
	printf("%s: target %d now using %s%s%d bit ",
d741 2
d745 3
a747 1
	if (siop_target->offset == 0)
d749 20
a768 31
	else {
		switch (siop_target->period) {
		case 9: /*   12.5ns cycle */
			printf("80.0");
			break;
		case 10: /*  25  ns cycle */
			printf("40.0");
			break;
		case 12: /*  48  ns cycle */
			printf("20.0");
			break;
		case 18: /*  72  ns cycle */
			printf("13.3");
			break;
		case 25: /* 100  ns cycle */
			printf("10.0");
			break;
		case 37: /* 118  ns cycle */
			printf("6.67");
			break;
		case 50: /* 200  ns cycle */
			printf("5.0");
			break;
		case 75: /* 300  ns cycle */
			printf("3.33");
			break;
		default:
			printf("??");
			break;
		}
		printf(" MHz %d REQ/ACK offset ", siop_target->offset);
d772 19
d792 1
a792 4
	if ((sc->features & SF_CHIP_GEBUG) &&
	    (siop_target->flags & TARF_ISWIDE) == 0)
		/* 1010 workaround: can't do disconnect if not wide, so can't do tag */
		siop_target->flags &= ~TARF_TAG;
@


1.11
log
@Complete (I hope) the changes to siop that make it pay attention
to the quirks table.

These latest changes, triggered by problems Dan Weeks was having
and developed with a lot of testing by Dan, should ensure that
siop is a) using the quirks of the correct LUN during wide/sync
negotiations and b) calling siop_add_dev() for all LUN's which
return valid information from an INQUIRY command.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.10 2001/08/18 02:24:02 krw Exp $ */
d563 1
a563 1
	scr_table_t *table; /* table to patch */
@


1.10
log
@Make siop pay attention to quirks table. This not only eliminates the
ugly INQUIRY snooping but avoids adding even uglier #ifdef's to turn
off stuff, e.g. tagged queuing.

Add two disk drives now known to lie about supporting tagged queuing
to quirks table. One from millert@@ (<MICROP, 4421-07 0329SJ, 0329>)
and one from Hakan Olsson (<SEAGATE, ST150176LW, 0002>).

Add field 'inquiry_flags2' to struct scsi_link to hold flags2 field
from struct scsi_inquiry_data. These flags relate to SCSI-3 specific
features.

Clean up some logic, eliminating need for TARF_PPR flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.9 2001/08/06 14:29:59 krw Exp $ */
d58 2
d126 20
d168 4
a171 1
		quirks = xs->sc_link->quirks;
d182 2
a183 2
		if (*targ_flags & (TARF_WIDE | TARF_SYNC))
			siop_add_dev(sc, target, lun);
@


1.9
log
@Fix errant reference to DEBUG_INTR to use correct SIOP_DEBUG_INTR.

Eliminates conflict with same name in wdc.c.

Spotted by Heikki Korpela.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.8 2001/06/25 23:14:40 krw Exp $ */
d134 2
a135 1
	int targ_flags = sc->targets[target]->flags;
d145 18
a162 1
		if (targ_flags & TARF_PPR) {
d164 4
a167 5
			if (sc->min_dt_sync != 0)
				siop_ppr_msg(siop_cmd, 1, sc->min_dt_sync, sc->maxoff);
			else
				siop_ppr_msg(siop_cmd, 1, sc->min_st_sync, sc->maxoff);
		} else if (targ_flags & TARF_WIDE) {
d170 1
a170 1
		} else if (targ_flags & TARF_SYNC) {
d178 1
a178 1
	    (targ_flags & TARF_TAG) &&
@


1.8
log
@Revert change to using sc_link in calls to siop_print_info().

sc_link->device_softc not necessarily available for devices like cd's
that don't issue SCSI commands after INQUIRY during probe, leaving
negotiation triggering to next LUN. Spotted by Nikolay Sturm.

Fixing this is not worth the effort and added complexity for a
cosmetic improvement.

Keep code cleanups done at the same time, and add a typo fix
(destiation -> destination).
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.7 2001/06/24 18:28:10 krw Exp $ */
d587 1
a587 1
#ifdef DEBUG_INTR
@


1.7
log
@Pass the device's scsi_link to siop_print_info(), instead of the
adapter's siop_softc. This allows easy access to the dv_xname of the
device whose negotiation results are being reported. This makes boot
probe and subsequent log messages clearer.

e.g. message will now read

   sd0: negotiated tagged 16 bit 20 MHz 16 REQ/ACK offset xfers

instead of

   siop0: target 0 now using tagged 16 bit 20 MHz 16 REQ/ACK offset xfers

Clean up siop_print_info() a bit as long as we are there.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.6 2001/04/15 06:01:29 krw Exp $ */
d158 1
a158 1
			siop_print_info(xs->sc_link);
d254 1
a254 1
	siop_print_info(siop_cmd->xs->sc_link);
d304 1
a304 1
			siop_print_info(siop_cmd->xs->sc_link);
d320 1
a320 1
			siop_print_info(siop_cmd->xs->sc_link);
d341 1
a341 1
			siop_print_info(siop_cmd->xs->sc_link);
d431 1
a431 1
		siop_print_info(siop_cmd->xs->sc_link);
d685 3
a687 2
siop_print_info(sc_link)
	struct scsi_link *sc_link;
a689 1
	struct siop_softc *sc;
d691 1
a691 4
	int scf_index, factors, target, i;

	sc = (struct siop_softc *)sc_link->adapter_softc;
	target = sc_link->target;
d695 2
a696 2
	printf("%s: negotiated %s%s%s%s%d bit ",
	    ((struct device *)sc_link->device_softc)->dv_xname,
@


1.6
log
@Support U160 on 53c1010 chips.

Add support for PPR negotiations and DT transfers,
and the preservation and restoration of the
SCNTL4 register which controls Ultra3 transfers.

Redo sync lookup, since the same period factor
can mean two things depending on whether you are
using DT or ST. Keep a minimum allowed ST period
factor, and a minimum allowd DT period factor for
each adapter.

Currently NO support for QAS or IUS or AIP.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.5 2001/03/10 05:04:06 krw Exp $ */
d158 1
a158 1
			siop_print_info(sc, target);
d254 1
a254 1
	siop_print_info(sc, target);
d304 1
a304 1
			siop_print_info(sc, target);
d320 1
a320 1
			siop_print_info(sc, target);
d341 1
a341 1
			siop_print_info(sc, target);
d431 1
a431 1
		siop_print_info(sc, target);
d685 4
a688 1
siop_print_info(sc, target)
a689 3
	int target;
{
	struct siop_target *siop_target = sc->targets[target];
d691 1
a691 1
	int scf_index, i;
d693 2
a694 1
	const int factors = sizeof(period_factor) / sizeof(period_factor[0]);
d696 4
a699 7
	offset = ((siop_target->id >> 8) & 0xff) >> SXFER_MO_SHIFT;

	scf = ((siop_target->id >> 24) & SCNTL3_SCF_MASK) >> SCNTL3_SCF_SHIFT;
	scf_index = sc->scf_index;

	printf("%s: target %d now using %s%s%s%s%d bit ",
	    sc->sc_dev.dv_xname, target,
d706 2
d711 5
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.6 2001/04/15 06:01:29 krw Exp $ */
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.6.4.1 2001/05/14 22:24:11 niklas Exp $ */
d686 2
a687 2
        struct siop_softc *sc;
        int target;
d689 1
a689 1
	struct siop_target *siop_target;
d691 8
a698 1
	int scf_index, factors, i;
a699 2
	siop_target = sc->targets[target];
	
d701 1
a701 1
            sc->sc_dev.dv_xname, target,
a707 2
	offset = ((siop_target->id >> 8) & 0xff) >> SXFER_MO_SHIFT;

a710 5
		factors = sizeof(period_factor) / sizeof(period_factor[0]);
		
		scf = ((siop_target->id >> 24) & SCNTL3_SCF_MASK) >> SCNTL3_SCF_SHIFT;
		scf_index = sc->scf_index;

@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.6.4.2 2001/07/04 10:41:08 niklas Exp $ */
a57 2
int siop_find_lun0_quirks __P((struct siop_softc *, u_int8_t, u_int16_t));

a123 20
int
siop_find_lun0_quirks(sc, bus, target)
	struct siop_softc *sc;
	u_int8_t bus;
	u_int16_t target;
{
	struct scsi_link *sc_link;
	struct device *dev;

	for (dev = TAILQ_FIRST(&alldevs); dev != NULL; dev = TAILQ_NEXT(dev, dv_list))
		if (dev->dv_parent == (struct device *)sc) {
			sc_link = ((struct scsibus_softc *)dev)->sc_link[target][0];
			if ((sc_link != NULL) && (sc_link->scsibus == bus))
				return sc_link->quirks;
		}

	/* If we can't find a quirks entry, assume the worst */
	return (SDEV_NOTAGS | SDEV_NOWIDE | SDEV_NOSYNC);
}

d134 1
a134 2
	int *targ_flags = &sc->targets[target]->flags;
	int quirks;
d144 1
a144 21
		*targ_flags = 0;
		if (lun == 0)
			quirks = xs->sc_link->quirks;
		else
			quirks = siop_find_lun0_quirks(sc, xs->sc_link->scsibus, target);

		if ((quirks & SDEV_NOTAGS) == 0) {
			*targ_flags |= TARF_TAG;
			xs->sc_link->openings += SIOP_NTAG - SIOP_OPENINGS;
		}
		if ((quirks & SDEV_NOWIDE) == 0)
			*targ_flags |= TARF_WIDE;
		if ((quirks & SDEV_NOSYNC) == 0)
			*targ_flags |= TARF_SYNC;

		/* Safe to call siop_add_dev() multiple times */
		siop_add_dev(sc, target, 0);

		if ((sc->features & SF_CHIP_C10)
		    && (*targ_flags & TARF_WIDE)
		    && (xs->sc_link->inquiry_flags2 & (SID_CLOCKING | SID_QAS | SID_IUS))) {
d146 5
a150 4
			siop_ppr_msg(siop_cmd, 1, 
				     (sc->min_dt_sync == 0) ? sc->min_st_sync : sc->min_dt_sync,
				     sc->maxoff);
		} else if (*targ_flags & TARF_WIDE) {
d153 1
a153 1
		} else if (*targ_flags & TARF_SYNC) {
d161 1
a161 1
	    (*targ_flags & TARF_TAG) &&
d587 1
a587 1
#ifdef SIOP_DEBUG_INTR
@


1.6.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d563 1
a563 1
	struct scr_table *table; /* table to patch */
@


1.6.4.5
log
@Merge in -current from about a week ago
@
text
@d58 1
a58 1
int siop_find_lun0_quirks(struct siop_softc *, u_int8_t, u_int16_t);
@


1.6.4.6
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: siop_common.c,v 1.31 2002/09/27 15:37:18 provos Exp $	*/
d5 1
a5 1
 * Copyright (c) 2000, 2002 Manuel Bouyer.
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
d52 1
a53 1
#include <dev/ic/siopvar.h>
a56 9
#undef DEBUG_NEG

int
siop_common_attach(sc)
	struct siop_common_softc *sc;
{
	int error, i;
	bus_dma_segment_t seg;
	int rseg;
d58 1
a58 83
	/*
	 * Allocate DMA-safe memory for the script and map it.
	 */
	if ((sc->features & SF_CHIP_RAM) == 0) {
		error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, 
		    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to allocate script DMA memory, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		error = bus_dmamem_map(sc->sc_dmat, &seg, rseg, PAGE_SIZE,
		    (caddr_t *)&sc->sc_script,
		    BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
		if (error) {
			printf("%s: unable to map script DMA memory, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1,
		    PAGE_SIZE, 0, BUS_DMA_NOWAIT, &sc->sc_scriptdma);
		if (error) {
			printf("%s: unable to create script DMA map, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		error = bus_dmamap_load(sc->sc_dmat, sc->sc_scriptdma,
		    sc->sc_script, PAGE_SIZE, NULL, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to load script DMA map, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return error;
		}
		sc->sc_scriptaddr =
		    sc->sc_scriptdma->dm_segs[0].ds_addr;
		sc->ram_size = PAGE_SIZE;
	}

	/*
	 * sc->sc_link is the template for all device sc_link's
	 * for devices attached to this adapter. It is passed to
	 * the upper layers in config_found().
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_buswidth =
	    (sc->features & SF_BUS_WIDE) ? 16 : 8;
	sc->sc_link.adapter_target =
	    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SCID);
	if (sc->sc_link.adapter_target == 0 ||
	    sc->sc_link.adapter_target >=
	    sc->sc_link.adapter_buswidth)
		sc->sc_link.adapter_target = SIOP_DEFAULT_TARGET;

	for (i = 0; i < 16; i++)
		sc->targets[i] = NULL;

	/* find min/max sync period for this chip */
	sc->st_maxsync = 0;
	sc->dt_maxsync = 0;
	sc->st_minsync = 255;
	sc->dt_minsync = 255;
	for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]); i++) {
		if (sc->clock_period != scf_period[i].clock)
			continue;
		if (sc->st_maxsync < scf_period[i].period)
			sc->st_maxsync = scf_period[i].period;
		if (sc->st_minsync > scf_period[i].period)
			sc->st_minsync = scf_period[i].period;
	}
	if (sc->st_maxsync == 255 || sc->st_minsync == 0)
		panic("siop: can't find my sync parameters");
	for (i = 0; i < sizeof(dt_scf_period) / sizeof(dt_scf_period[0]); i++) {
		if (sc->clock_period != dt_scf_period[i].clock)
			continue;
		if (sc->dt_maxsync < dt_scf_period[i].period)
			sc->dt_maxsync = dt_scf_period[i].period;
		if (sc->dt_minsync > dt_scf_period[i].period)
			sc->dt_minsync = dt_scf_period[i].period;
	}
	if (sc->dt_maxsync == 255 || sc->dt_minsync == 0)
		panic("siop: can't find my sync parameters");
	return 0;
}
d62 1
a62 1
	struct siop_common_softc *sc;
d76 2
d100 1
a100 1
		if (sc->features & SF_CHIP_QUAD) {
d122 19
a140 11
	if (sc->features & SF_CHIP_LED0) {
		/* Set GPIO0 as output if software LED control is required */
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_GPCNTL,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_GPCNTL) & 0xfe);
	}
	if (sc->features & SF_BUS_ULTRA3) {
		/* reset SCNTL4 */
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL4, 0);
	}
	sc->mode = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_STEST4) &
	    STEST4_MODE_MASK;
d142 2
a143 8
	/*
	 * initialise the RAM. Without this we may get scsi gross errors on
	 * the 1010
	 */
	if (sc->features & SF_CHIP_RAM)
		bus_space_set_region_4(sc->sc_ramt, sc->sc_ramh,
			0, 0, sc->ram_size / 4);
	sc->sc_reset(sc);
d149 1
a149 1
	struct siop_common_cmd *siop_cmd;
d152 1
a152 1
	struct siop_common_softc *sc = siop_cmd->siop_sc;
a155 1
	int msgoffset = 1;
d159 4
a162 17
	siop_cmd->siop_tables->id = htole32(sc->targets[target]->id);
	memset(siop_cmd->siop_tables->msg_out, 0,
	    sizeof(siop_cmd->siop_tables->msg_out));
	/* request sense doesn't disconnect */
	if (siop_cmd->status == CMDST_SENSE)
		siop_cmd->siop_tables->msg_out[0] = MSG_IDENTIFY(lun, 0);
	else if ((sc->features & SF_CHIP_GEBUG) &&
	    (sc->targets[target]->flags & TARF_ISWIDE) == 0)
		/*
		 * 1010 bug: it seems that the 1010 has problems with reselect
		 * when not in wide mode (generate false SCSI gross error).
		 * The FreeBSD sym driver has comments about it but their
		 * workaround (disable SCSI gross error reporting) doesn't
		 * work with my adapter. So disable disconnect when not
		 * wide.
		 */
		siop_cmd->siop_tables->msg_out[0] = MSG_IDENTIFY(lun, 0);
d164 2
a165 2
		siop_cmd->siop_tables->msg_out[0] = MSG_IDENTIFY(lun, 1);
	siop_cmd->siop_tables->t_msgout.count= htole32(msgoffset);
d167 5
a171 2
		*targ_flags &= TARF_DT; /* Save TARF_DT 'cuz we don't set it here */
		quirks = xs->sc_link->quirks;
d173 1
a173 1
		if ((quirks & SDEV_NOTAGS) == 0)
d175 3
a177 2
		if (((quirks & SDEV_NOWIDE) == 0) &&
		    (sc->features & SF_BUS_WIDE))
a181 8
		if ((sc->features & SF_CHIP_GEBUG) &&
		    (*targ_flags & TARF_WIDE) == 0)
			/* 
			 * 1010 workaround: can't do disconnect if not wide,
			 * so can't do tag
			 */
			*targ_flags &= ~TARF_TAG;

d183 1
a183 1
		siop_add_dev((struct siop_softc *)sc, target, lun);
d185 3
a187 2
		if ((*targ_flags & TARF_DT) &&
		    (sc->mode == STEST4_MODE_LVD)) {
d189 3
a191 2
			 siop_ppr_msg(siop_cmd, msgoffset, sc->dt_minsync,
			    sc->maxoff);
d194 1
a194 2
			siop_wdtr_msg(siop_cmd, msgoffset,
			    MSG_EXT_WDTR_BUS_16_BIT);
d197 1
a197 2
			siop_sdtr_msg(siop_cmd, msgoffset, sc->st_minsync,
			(sc->maxoff > 31) ? 31 :  sc->maxoff);
d200 1
a200 1
			siop_update_xfer_mode(sc, target);
d207 1
a207 1
	siop_cmd->siop_tables->status =
d210 1
a210 1
	siop_cmd->siop_tables->cmd.count =
d212 1
a212 1
	siop_cmd->siop_tables->cmd.addr =
d217 1
a217 1
			siop_cmd->siop_tables->data[i].count =
d219 1
a219 1
			siop_cmd->siop_tables->data[i].addr =
d223 76
d303 1
a303 1
	struct siop_common_cmd *siop_cmd;
d305 2
a306 2
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct siop_common_target *siop_target = siop_cmd->siop_target;
d308 13
a320 1
	struct siop_common_xfer *tables = siop_cmd->siop_tables;
d335 1
a335 1
		/* FALLTHROUH */
d338 2
a339 2
 			 * hum, we got more than what we can handle, shouldn't
			 * happen. Reject, and stay async
a342 2
			siop_target->offset = siop_target->period = 0;
			siop_update_xfer_mode(sc, target);
d346 1
d358 1
a358 2
			siop_sdtr_msg(siop_cmd, 0, sc->st_minsync,
			    (sc->maxoff > 31) ? 31 : sc->maxoff);
d362 1
a362 1
			siop_update_xfer_mode(sc, target);
d379 1
a379 2
		 * we did reset wide parameters, so fall back to async,
		 * but don't schedule a sync neg, target should initiate it
d381 4
a384 3
		siop_target->status = TARST_OK;
		siop_target->offset = siop_target->period = 0;
		siop_update_xfer_mode(sc, target);
a391 114
siop_ppr_neg(siop_cmd)
	struct siop_common_cmd *siop_cmd;
{
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct siop_common_target *siop_target = siop_cmd->siop_target;
	int target = siop_cmd->xs->sc_link->target;
	struct siop_common_xfer *tables = siop_cmd->siop_tables;
	int sync, offset, options, scf = 0;
	int i;

#ifdef DEBUG_NEG
	printf("%s: anserw on ppr negotiation:", sc->sc_dev.dv_xname);
	for (i = 0; i < 8; i++)
		printf(" 0x%x", tables->msg_in[i]);
	printf("\n");
#endif

	if (siop_target->status == TARST_PPR_NEG) {
		/* we initiated PPR negotiation */
		sync = tables->msg_in[3];
		offset = tables->msg_in[5];
		options = tables->msg_in[7];
		if (options != MSG_EXT_PPR_PROT_DT) {
			/* should't happen */
			printf("%s: ppr negotiation for target %d: "
			    "no DT option\n", sc->sc_dev.dv_xname, target);
			siop_target->status = TARST_ASYNC;
			siop_target->flags &= ~(TARF_DT | TARF_ISDT);
			siop_target->offset = 0;
			siop_target->period = 0;
			goto reject;
		}
			
		if (offset > sc->maxoff || sync < sc->dt_minsync ||
		    sync > sc->dt_maxsync) {
			printf("%s: ppr negotiation for target %d: "
			    "offset (%d) or sync (%d) out of range\n",
			    sc->sc_dev.dv_xname, target, offset, sync);
			/* should not happen */
			siop_target->status = TARST_ASYNC;
			siop_target->flags &= ~(TARF_DT | TARF_ISDT);
			siop_target->offset = 0;
			siop_target->period = 0;
			goto reject;
		} else {
			for (i = 0; i <
			    sizeof(dt_scf_period) / sizeof(dt_scf_period[0]);
			    i++) {
				if (sc->clock_period != dt_scf_period[i].clock)
					continue;
				if (dt_scf_period[i].period == sync) {
					/* ok, found it. we now are sync. */
					siop_target->offset = offset;
					siop_target->period = sync;
					scf = dt_scf_period[i].scf;
					siop_target->flags |= TARF_ISDT;
				}
			}
			if ((siop_target->flags & TARF_ISDT) == 0) {
				printf("%s: ppr negotiation for target %d: "
				    "sync (%d) incompatible with adapter\n",
				    sc->sc_dev.dv_xname, target, sync);
				/*
				 * we didn't find it in our table, do async
				 * send reject msg, start SDTR/WDTR neg
				 */
				siop_target->status = TARST_ASYNC;
				siop_target->flags &= ~(TARF_DT | TARF_ISDT);
				siop_target->offset = 0;
				siop_target->period = 0;
				goto reject;
			}
		}
		if (tables->msg_in[6] != 1) {
			printf("%s: ppr negotiation for target %d: "
			    "transfer width (%d) incompatible with dt\n",
			    sc->sc_dev.dv_xname, target, tables->msg_in[6]);
			/* DT mode can only be done with wide transfers */
			siop_target->status = TARST_ASYNC;
			siop_target->flags &= ~(TARF_DT | TARF_ISDT);
			siop_target->offset = 0;
			siop_target->period = 0;
			goto reject;
		} 
		siop_target->flags |= TARF_ISWIDE;
		sc->targets[target]->id |= (SCNTL3_EWS << 24);
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id |= scf << (24 + SCNTL3_SCF_SHIFT);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
		sc->targets[target]->id |=
		    (siop_target->offset & SXFER_MO_MASK) << 8;
		sc->targets[target]->id &= ~0xff;
		sc->targets[target]->id |= SCNTL4_U3EN;
		siop_target->status = TARST_OK;
		siop_update_xfer_mode(sc, target);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL3,
		    (sc->targets[target]->id >> 24) & 0xff);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SXFER,
		    (sc->targets[target]->id >> 8) & 0xff);
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SCNTL4,
		    sc->targets[target]->id & 0xff);
		return SIOP_NEG_ACK;
	} else {
		/* target initiated PPR negotiation, shouldn't happen */
		printf("%s: rejecting invalid PPR negotiation from "
		    "target %d\n", sc->sc_dev.dv_xname, target);
reject:
		tables->t_msgout.count= htole32(1);
		tables->msg_out[0] = MSG_MESSAGE_REJECT;
		return SIOP_NEG_MSGOUT;
	}
}

int
d393 1
a393 1
	struct siop_common_cmd *siop_cmd;
d395 2
a396 2
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	struct siop_common_target *siop_target = siop_cmd->siop_target;
d398 1
a398 1
	int sync, maxoffset, offset, i;
d400 1
a400 4
	struct siop_common_xfer *tables = siop_cmd->siop_tables;

	/* limit to Ultra/2 parameters, need PPR for Ultra/3 */
	maxoffset = (sc->maxoff > 31) ? 31 : sc->maxoff;
d405 4
a410 1
		siop_target->status = TARST_OK;
d412 2
a413 1
		printf("sdtr: sync %d offset %d\n", sync, offset);
d415 2
a416 2
		if (offset > maxoffset || sync < sc->st_minsync ||
			sync > sc->st_maxsync)
d418 5
a422 27
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]);
		    i++) {
			if (sc->clock_period != scf_period[i].clock)
				continue;
			if (scf_period[i].period == sync) {
				/* ok, found it. we now are sync. */
				siop_target->offset = offset;
				siop_target->period = sync;
				sc->targets[target]->id &=
				    ~(SCNTL3_SCF_MASK << 24);
				sc->targets[target]->id |= scf_period[i].scf
				    << (24 + SCNTL3_SCF_SHIFT);
				if (sync < 25 && /* Ultra */
				    (sc->features & SF_BUS_ULTRA3) == 0)
					sc->targets[target]->id |=
					    SCNTL3_ULTRA << 24;
				else
					sc->targets[target]->id &=
					    ~(SCNTL3_ULTRA << 24);
				sc->targets[target]->id &=
				    ~(SXFER_MO_MASK << 8);
				sc->targets[target]->id |=
				    (offset & SXFER_MO_MASK) << 8;
				sc->targets[target]->id &= ~0xff; /* scntl4 */
				goto end;
			}
		}
d424 2
a425 2
		 * we didn't find it in our table, do async and send reject
		 * msg
a430 5
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
		sc->targets[target]->id &= ~0xff; /* scntl4 */
		siop_target->offset = siop_target->period = 0;
d433 2
d437 6
a442 1
		if (offset == 0 || sync > sc->st_maxsync) { /* async */
d445 12
a456 34
		if (offset > maxoffset)
			offset = maxoffset;
		if (sync < sc->st_minsync)
			sync = sc->st_minsync;
		/* look for sync period */
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]);
		    i++) {
			if (sc->clock_period != scf_period[i].clock)
				continue;
			if (scf_period[i].period == sync) {
				/* ok, found it. we now are sync. */
				siop_target->offset = offset;
				siop_target->period = sync;
				sc->targets[target]->id &=
				    ~(SCNTL3_SCF_MASK << 24);
				sc->targets[target]->id |= scf_period[i].scf
				    << (24 + SCNTL3_SCF_SHIFT);
				if (sync < 25 && /* Ultra */
				    (sc->features & SF_BUS_ULTRA3) == 0)
					sc->targets[target]->id |=
					    SCNTL3_ULTRA << 24;
				else
					sc->targets[target]->id &=
					    ~(SCNTL3_ULTRA << 24);
				sc->targets[target]->id &=
				    ~(SXFER_MO_MASK << 8);
				sc->targets[target]->id |=
				    (offset & SXFER_MO_MASK) << 8;
				sc->targets[target]->id &= ~0xff; /* scntl4 */
				siop_sdtr_msg(siop_cmd, 0, sync, offset);
				send_msgout = 1;
				goto end;
			}
		}
a457 5
		siop_target->offset = siop_target->period = 0;
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
		sc->targets[target]->id &= ~0xff; /* scntl4 */
a461 2
	if (siop_target->status == TARST_OK)
		siop_update_xfer_mode(sc, target);
d470 6
d484 34
d519 1
a519 1
	struct siop_common_cmd *siop_cmd;
d523 10
a532 6
	siop_cmd->siop_tables->msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables->msg_out[offset + 1] = MSG_EXT_SDTR_LEN;
	siop_cmd->siop_tables->msg_out[offset + 2] = MSG_EXT_SDTR;
	siop_cmd->siop_tables->msg_out[offset + 3] = ssync;
	siop_cmd->siop_tables->msg_out[offset + 4] = soff;
	siop_cmd->siop_tables->t_msgout.count =
d538 1
a538 1
	struct siop_common_cmd *siop_cmd;
d541 5
a545 5
	siop_cmd->siop_tables->msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables->msg_out[offset + 1] = MSG_EXT_WDTR_LEN;
	siop_cmd->siop_tables->msg_out[offset + 2] = MSG_EXT_WDTR;
	siop_cmd->siop_tables->msg_out[offset + 3] = wide;
	siop_cmd->siop_tables->t_msgout.count =
a549 18
siop_ppr_msg(siop_cmd, offset, ssync, soff)
	struct siop_common_cmd *siop_cmd;
	int offset;
	int ssync, soff;
{
	siop_cmd->siop_tables->msg_out[offset + 0] = MSG_EXTENDED;
	siop_cmd->siop_tables->msg_out[offset + 1] = MSG_EXT_PPR_LEN;
	siop_cmd->siop_tables->msg_out[offset + 2] = MSG_EXT_PPR;
	siop_cmd->siop_tables->msg_out[offset + 3] = ssync;
	siop_cmd->siop_tables->msg_out[offset + 4] = 0; /* reserved */
	siop_cmd->siop_tables->msg_out[offset + 5] = soff;
	siop_cmd->siop_tables->msg_out[offset + 6] = 1; /* wide */
	siop_cmd->siop_tables->msg_out[offset + 7] = MSG_EXT_PPR_PROT_DT;
	siop_cmd->siop_tables->t_msgout.count =
	    htole32(offset + MSG_EXT_PPR_LEN + 2);
}

void
d558 1
a558 1
	struct siop_common_cmd *siop_cmd;
d562 2
a563 2
	struct siop_common_softc *sc = siop_cmd->siop_sc;
	scr_table_t *table; /* table to patch */
d574 1
a574 1
	table = &siop_cmd->siop_tables->data[offset];
d581 5
a585 7
		if (sc->features & SF_CHIP_DFBC) {
			dbc +=
			    bus_space_read_2(sc->sc_rt, sc->sc_rh, SIOP_DFBC);
		} else {
			/* need to account stale data in FIFO */
			int dfifo =
			    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_DFIFO);
d588 1
a588 1
				    SIOP_CTEST5) & CTEST5_BOMASK) << 8;
d597 3
a599 2
		if ((sstat & SSTAT0_ORF) && (sc->features & SF_CHIP_DFBC) == 0)
			dbc++;
d605 3
a607 3
			if ((sstat & SSTAT2_ORF1) &&
			    (sc->features & SF_CHIP_DFBC) == 0)
				dbc++;
d624 1
a624 1
	struct siop_common_softc *sc;
d629 2
a630 2
#ifdef DEBUG_INTR
	printf("DMA fifo not empty !\n");
d649 1
a649 1
	struct siop_common_softc *sc;
d652 1
a652 1
	int sist0, sist1, stest2;
d655 1
a655 1
		 * datasheet says to wait 100ms and re-read SIST1,
d657 1
a657 1
		 * We may delay() 5 times for  100ms at interrupt time;
d665 1
a665 1
		sc->mode = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_STEST4) &
d668 1
a668 1
		switch(sc->mode) {
d670 10
a679 4
			printf("%s: switching to differential mode\n",
			    sc->sc_dev.dv_xname);
			bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST2,
			    stest2 | STEST2_DIF);
d695 1
a695 1
			    sc->sc_dev.dv_xname, sc->mode);
d698 2
d709 1
a709 1
	struct siop_common_softc *sc;
d720 6
d727 2
a728 2
siop_update_xfer_mode(sc, target)
        struct siop_common_softc *sc;
d731 3
a733 1
	struct siop_common_target *siop_target;
d737 1
a737 1
	printf("%s: target %d now using %s%s%d bit ",
d741 2
d745 3
a747 1
	if (siop_target->offset == 0)
d749 20
a768 31
	else {
		switch (siop_target->period) {
		case 9: /*   12.5ns cycle */
			printf("80.0");
			break;
		case 10: /*  25  ns cycle */
			printf("40.0");
			break;
		case 12: /*  48  ns cycle */
			printf("20.0");
			break;
		case 18: /*  72  ns cycle */
			printf("13.3");
			break;
		case 25: /* 100  ns cycle */
			printf("10.0");
			break;
		case 37: /* 118  ns cycle */
			printf("6.67");
			break;
		case 50: /* 200  ns cycle */
			printf("5.0");
			break;
		case 75: /* 300  ns cycle */
			printf("3.33");
			break;
		default:
			printf("??");
			break;
		}
		printf(" MHz %d REQ/ACK offset ", siop_target->offset);
d772 19
d792 1
a792 4
	if ((sc->features & SF_CHIP_GEBUG) &&
	    (siop_target->flags & TARF_ISWIDE) == 0)
		/* 1010 workaround: can't do disconnect if not wide, so can't do tag */
		siop_target->flags &= ~TARF_TAG;
@


1.6.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a270 1
#ifndef __hppa__
a272 1
#endif
d315 4
a320 2
		bzero(siop_cmd->siop_tables->data,
		    sizeof(siop_cmd->siop_tables->data));
d422 1
a422 1
	printf("%s: answer on ppr negotiation:", sc->sc_dev.dv_xname);
a676 1
	int wide;
d732 1
a732 1
	    letoh32(table->count), letoh32(table->addr));
d774 1
a774 2
	printf("now count=%d addr=0x%x\n",
	    letoh32(table->count), letoh32(table->addr));
@


1.6.4.8
log
@sync to HEAD
@
text
@a708 3
	if (bp->b_bcount > SIOP_MAXFER)
		bp->b_bcount = SIOP_MAXFER;

@


1.5
log
@First support for 53c1010 chip. This enables support up to U2W for
either or both channels on the 53c1010. U3W/U160 support coming.

The particulars of 53c1010 support was derived from the FreeBSD/Linux
sym-2 driver under development by Gerard ROUDIER (groudier@@FreeBSD.org).

This first support ensures that registers and bits now reserved are
not used by the 53c1010. It uses the new DFBC register to obtain
DMA FIFO relics.

A single new feature (SF_CHIP_C10) was added, rather than a new
feature for each change the 53c1010 incorporates.

These changes were sufficient to get the imbedded 53c1010 on a Tyan
S2510U3NG board to support installation of OpenBSD to a Quantum Atlas
10K2 drive, and several subsequent 'make build' and 'make release'
cycles using disks on both channels, with and without
softupdates.

More 53c1010 specific code is yet to be extracted from sym-2,
including the changes necessary to enable U160.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.4 2001/03/06 16:29:32 krw Exp $ */
d74 2
d134 1
d144 7
a150 1
		if (sc->targets[target]->flags & TARF_WIDE) {
d153 1
a153 1
		} else if (sc->targets[target]->flags & TARF_SYNC) {
d155 1
a155 1
			siop_sdtr_msg(siop_cmd, 1, sc->minsync, sc->maxoff);
d161 1
a161 1
	    (sc->targets[target]->flags & TARF_TAG) &&
d185 75
d268 3
a270 4
	/* revert to async until told otherwise */
	sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
	sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
	sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
d276 3
a278 2
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_SXFER,
	    (sc->targets[target]->id >> 8) & 0xff);
d316 1
a316 1
			siop_sdtr_msg(siop_cmd, 0, sc->minsync, sc->maxoff);
d356 1
a356 1
	int sync, offset, i;
d364 2
a365 3
	sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
	sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
	sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
d370 2
a371 1
		printf("sdtr: sync %d offset %d\n", sync, offset);
d373 2
a374 2
		if (offset > sc->maxoff || sync < sc->minsync ||
			sync > sc->maxsync)
d376 5
a380 17
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]);
		    i++) {
			if (sc->clock_period != scf_period[i].clock)
				continue;
			if (scf_period[i].period == sync) {
				/* ok, found it. we now are sync. */
				sc->targets[target]->id |= scf_period[i].scf
				    << (24 + SCNTL3_SCF_SHIFT);
				if ((sync < 25)
				    && ((sc->features & SF_CHIP_C10) == 0))
					sc->targets[target]->id |=
					    SCNTL3_ULTRA << 24;
				sc->targets[target]->id |=
				    (offset & SXFER_MO_MASK) << 8;
				goto end;
			}
		}
d391 2
d395 3
d400 1
a400 1
		    || sync > sc->maxsync) {
d403 2
d407 8
a414 22
		if (sync < sc->minsync)
			sync = sc->minsync;
		/* look for sync period */
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]);
		    i++) {
			if (sc->clock_period != scf_period[i].clock)
				continue;
			if (scf_period[i].period == sync) {
				/* ok, found it. we now are sync. */
				sc->targets[target]->id |= scf_period[i].scf
				    << (24 + SCNTL3_SCF_SHIFT);
				if ((sync < 25)
				    && ((sc->features & SF_CHIP_C10) == 0))
					sc->targets[target]->id |=
					    SCNTL3_ULTRA << 24;
				sc->targets[target]->id |=
				    (offset & SXFER_MO_MASK) << 8;
				siop_sdtr_msg(siop_cmd, 0, sync, offset);
				send_msgout = 1;
				goto end;
			}
		}
d442 34
d485 4
d691 5
a695 1
	int clock, i;
a696 1
	offset = ((siop_target->id >> 8) & SXFER_MO_MASK) >> SXFER_MO_SHIFT;
d698 1
a698 1
	clock = sc->clock_period;
d700 1
a700 1
	printf("%s: target %d now using%s%d bit ",
d702 4
a705 1
	    (siop_target->flags & TARF_TAG) ? " tagged " : " ",
d710 7
a716 5
	else {
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]); i++)
			if ((scf_period[i].clock == clock) 
			    && (scf_period[i].scf == scf)) {
				printf("%s ", scf_period[i].rate);
d718 6
a723 3
			}
		if (i == sizeof(scf_period) / sizeof(scf_period[0]))
			printf("? ");
d728 21
@


1.4
log
@1) Enable tag queuing.

2) Negotiate and report wide/sync only after INQUIRY
   results known.

3) Clean up wide/sync negotiation code a bit, ensuring
   that an agressive target does not prematurely force
   negotiation before the INQUIRY is done. Seen by millert@@.

4) Ensure that a wide negotiation always resets the
   sync settings to async.

5) Some error message improvements from thorpej@@NetBSD.

6) Some KNF.

7) Print wide/sync negotiation results after each
   completed negotiation.

8) Print some relevant information just before a panic
   that should never happen. But does on PowerPC.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.3 2001/03/01 17:14:28 krw Exp $ */
d96 1
a96 1
		if (sc->features & SF_CHIP_QUAD) {
d300 2
a301 1
				if (sync < 25) /* Ultra */
d339 2
a340 1
				if (sync < 25) /* Ultra */
d437 11
a447 7
		int dfifo = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_DFIFO);
		if (sc->features & SF_CHIP_FIFO) {
			dfifo |= (bus_space_read_1(sc->sc_rt, sc->sc_rh,
			    SIOP_CTEST5) & CTEST5_BOMASK) << 8;
			dbc += (dfifo - (dbc & 0x3ff)) & 0x3ff;
		} else {
			dbc += (dfifo - (dbc & 0x7f)) & 0x7f;
d452 3
a454 2
		if (sstat & SSTAT0_ORF)
			dbc++;
d460 3
a462 2
			if (sstat & SSTAT2_ORF1)
				dbc++;
d525 10
a534 4
			printf("%s: switching to differential mode\n",
			    sc->sc_dev.dv_xname);
			bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STEST2,
			    stest2 | STEST2_DIF);
@


1.3
log
@Typo police: various misspelling, capitalizations, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.2 2001/02/20 00:32:29 krw Exp $ */
d149 1
d184 12
d220 1
d236 1
d253 1
a253 2
		 * we did reset wide parameters, so fall back to async,
		 * but don't schedule a sync neg, target should initiate it
d255 4
a258 1
		siop_target->status = TARST_OK;
d279 5
a285 1
		siop_target->status = TARST_OK;
a297 2
				sc->targets[target]->id &=
				    ~(SCNTL3_SCF_MASK << 24);
a302 5
				else
					sc->targets[target]->id &=
					    ~(SCNTL3_ULTRA << 24);
				sc->targets[target]->id &=
				    ~(SXFER_MO_MASK << 8);
d309 2
a310 2
		 * we didn't find it in our table, do async and send reject
		 * msg
a315 3
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
d320 3
a322 1
		if (offset == 0 || sync > sc->maxsync) { /* async */
a335 2
				sc->targets[target]->id &=
				    ~(SCNTL3_SCF_MASK << 24);
a340 5
				else
					sc->targets[target]->id &=
					    ~(SCNTL3_ULTRA << 24);
				sc->targets[target]->id &=
				    ~(SXFER_MO_MASK << 8);
a348 5
		printf("%s: target %d asynchronous\n",
		    sc->sc_dev.dv_xname, target);
		sc->targets[target]->id &= ~(SCNTL3_SCF_MASK << 24);
		sc->targets[target]->id &= ~(SCNTL3_ULTRA << 24);
		sc->targets[target]->id &= ~(SXFER_MO_MASK << 8);
d361 6
d559 41
@


1.2
log
@Tone down the verbosity level on the siop driver, print negotiation
results on one line, during boot polling only.

Force wide/sync negotiations for all targets during boot.

Delete extraneous name field and associated strings that duplicate
info provided in INQUIRY data.

Actually timeout during polling rather than wait forever for
ITSDONE.

Remove unneeded check for SCSI_POLL before calling scsi_done(). Makes
logic conform to other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_common.c,v 1.1 2001/02/15 04:07:58 krw Exp $ */
d196 1
a196 1
		/* FALLTHROUH */
d199 2
a200 2
 			 * hum, we got more than what we can handle, shoudn't
			 * happen. Reject, and stay async
d427 1
a427 1
		/* need to account stale data in FIFO */
d470 1
a470 1
	printf("DMA fifo not empty !\n");
d495 3
a497 3
		 * datasheet says to wait 100ms and re-read SIST1,
		 * to check that DIFFSENSE is srable.
		 * We may delay() 5 times for  100ms at interrupt time;
@


1.1
log
@Import siop, a replacement for the ncr SCSI driver, from NetBSD.

Written for NetBSD by Manuel Bouyer.

Tested with various cards on i386 and alpha.

Outstanding issue: doesn't work with PowerPC yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a186 2
			printf("%s: target %d using 8bit transfers\n",
			    sc->sc_dev.dv_xname, target);
a191 2
				printf("%s: target %d using 16bit transfers\n",
				    sc->sc_dev.dv_xname, target);
a227 2
			printf("%s: target %d using 16bit transfers\n",
			    sc->sc_dev.dv_xname, target);
a230 2
			printf("%s: target %d using 8bit transfers\n",
			    sc->sc_dev.dv_xname, target);
a276 3
				printf("%s: target %d now synchronous at "
				    "%sMhz, offset %d\n", sc->sc_dev.dv_xname,
				    target, scf_period[i].rate, offset);
a301 2
		printf("%s: target %d asynchronous\n", sc->sc_dev.dv_xname,
		    target);
a322 3
				printf("%s: target %d now synchronous at "
				    "%sMhz, offset %d\n", sc->sc_dev.dv_xname,
				    target, scf_period[i].rate, offset);
@

