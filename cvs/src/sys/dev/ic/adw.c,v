head	1.54;
access;
symbols
	OPENBSD_6_1:1.52.0.10
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.52.0.8
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.50.0.14
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.50.0.12
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.50.0.8
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.50.0.6
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.2
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.4
	OPENBSD_5_0:1.49.0.2
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.48.0.2
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.38.0.6
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.31.0.4
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.4
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.26.0.8
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.6
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.4
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.26
	UBC:1.25.0.2
	UBC_BASE:1.25
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.54
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.53;
commitid	zztPc3QpQPdWwQ6h;

1.53
date	2017.04.09.18.07.19;	author dhill;	state Exp;
branches;
next	1.52;
commitid	O6yENjmyJQKVKwHV;

1.52
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.51;
commitid	p4LJxGKbi0BU2cG6;

1.51
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.50;
commitid	uzzBR7hz9ncd4O6G;

1.50
date	2012.01.11.16.22.32;	author dhill;	state Exp;
branches;
next	1.49;

1.49
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2010.10.03.21.23.35;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2010.06.26.04.04.24;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.04.04.57.14;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.29.13.58.51;	author jasper;	state Exp;
branches;
next	1.38;

1.38
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.26.16.38.00;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.05.20.50.20;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.03.16.53.15;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.21.18.58.48;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.11.21.59.19;	author krw;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.26.02.39.05;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.11.17.31.24;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.16.19.19.28;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.16.12.51.48;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.11.04.05.15;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.22.17.17.32;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.20.00.52.58;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.22.06.29.20;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.15.16.27.53;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.08.00.03.30;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.10.04.24.50;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.15.12.22.15;	author krw;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.09.06.00.48.01;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.22.15.10.13;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.29.00.04.31;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.29.21.05.32;	author krw;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.04.02.23.19.26;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.19.16.44.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.05.22.20.39;	author deraadt;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.08.04.23.27.48;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.17.06.14.58;	author downsj;	state Exp;
branches;
next	;

1.3.2.1
date	2000.02.20.11.56.58;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.05.14.22.23.21;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.07.04.10.40.25;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2004.02.19.10.56.15;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2000.11.11.05.00.58;	author jason;	state Exp;
branches;
next	;

1.10.2.1
date	2000.11.11.04.59.44;	author jason;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@/*	$OpenBSD: adw.c,v 1.53 2017/04/09 18:07:19 dhill Exp $ */
/* $NetBSD: adw.c,v 1.23 2000/05/27 18:24:50 dante Exp $	 */

/*
 * Generic driver for the Advanced Systems Inc. SCSI controllers
 *
 * Copyright (c) 1998, 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Author: Baldassare Dante Profeta <dante@@mclink.it>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/timeout.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/adwlib.h>
#include <dev/microcode/adw/adwmcode.h>
#include <dev/ic/adw.h>

/******************************************************************************/


int adw_alloc_controls(ADW_SOFTC *);
int adw_alloc_carriers(ADW_SOFTC *);
int adw_create_ccbs(ADW_SOFTC *, ADW_CCB *, int);
void adw_ccb_free(void *, void *);
void adw_reset_ccb(ADW_CCB *);
int adw_init_ccb(ADW_SOFTC *, ADW_CCB *);
void *adw_ccb_alloc(void *);
int adw_queue_ccb(ADW_SOFTC *, ADW_CCB *, int);

void adw_scsi_cmd(struct scsi_xfer *);
int adw_build_req(struct scsi_xfer *, ADW_CCB *, int);
void adw_build_sglist(ADW_CCB *, ADW_SCSI_REQ_Q *, ADW_SG_BLOCK *);
void adw_minphys(struct buf *, struct scsi_link *);
void adw_isr_callback(ADW_SOFTC *, ADW_SCSI_REQ_Q *);
void adw_async_callback(ADW_SOFTC *, u_int8_t);

void adw_print_info(ADW_SOFTC *, int);

int adw_poll(ADW_SOFTC *, struct scsi_xfer *, int);
void adw_timeout(void *);
void adw_reset_bus(ADW_SOFTC *);


/******************************************************************************/


struct cfdriver adw_cd = {
	NULL, "adw", DV_DULL
};

/******************************************************************************/
/*                       DMA Mapping for Control Blocks                       */
/******************************************************************************/


int
adw_alloc_controls(ADW_SOFTC *sc)
{
	bus_dma_segment_t seg;
	int             error, rseg;

	/*
         * Allocate the control structure.
         */
	if ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adw_control),
	    NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO)) != 0) {
		printf("%s: unable to allocate control structures,"
		       " error = %d\n", sc->sc_dev.dv_xname, error);
		return (error);
	}
	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,
		   sizeof(struct adw_control), (caddr_t *) & sc->sc_control,
				 BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map control structures, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}

	/*
         * Create and load the DMA map used for the control blocks.
         */
	if ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adw_control),
			   1, sizeof(struct adw_control), 0, BUS_DMA_NOWAIT,
				       &sc->sc_dmamap_control)) != 0) {
		printf("%s: unable to create control DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,
			   sc->sc_control, sizeof(struct adw_control), NULL,
				     BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load control DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}

	return (0);
}


int
adw_alloc_carriers(ADW_SOFTC *sc)
{
	bus_dma_segment_t seg;
	int             error, rseg;

	/*
         * Allocate the control structure.
         */
	sc->sc_control->carriers = 
		malloc(ADW_MAX_CARRIER * sizeof(ADW_CARRIER), M_DEVBUF,
		       M_NOWAIT);
	if (sc->sc_control->carriers == NULL)
		return (ENOMEM);


	if ((error = bus_dmamem_alloc(sc->sc_dmat,
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER,
			0x10, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to allocate carrier structures,"
		       " error = %d\n", sc->sc_dev.dv_xname, error);
		return (error);
	}
	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER,
			(caddr_t *) &sc->sc_control->carriers,
			BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map carrier structures,"
			" error = %d\n", sc->sc_dev.dv_xname, error);
		return (error);
	}

	/*
         * Create and load the DMA map used for the control blocks.
         */
	if ((error = bus_dmamap_create(sc->sc_dmat,
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER, 1,
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER, 0,BUS_DMA_NOWAIT,
			&sc->sc_dmamap_carrier)) != 0) {
		printf("%s: unable to create carriers DMA map,"
			" error = %d\n", sc->sc_dev.dv_xname, error);
		return (error);
	}
	if ((error = bus_dmamap_load(sc->sc_dmat,
			sc->sc_dmamap_carrier, sc->sc_control->carriers,
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER, NULL,
			BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load carriers DMA map,"
			" error = %d\n", sc->sc_dev.dv_xname, error);
		return (error);
	}

	return (0);
}


/******************************************************************************/
/*                           Control Blocks routines                          */
/******************************************************************************/


/*
 * Create a set of ccbs and add them to the free list.  Called once
 * by adw_init().  We return the number of CCBs successfully created.
 */
int
adw_create_ccbs(ADW_SOFTC *sc, ADW_CCB *ccbstore, int count)
{
	ADW_CCB        *ccb;
	int             i, error;

	for (i = 0; i < count; i++) {
		ccb = &ccbstore[i];
		if ((error = adw_init_ccb(sc, ccb)) != 0) {
			printf("%s: unable to initialize ccb, error = %d\n",
			       sc->sc_dev.dv_xname, error);
			return (i);
		}
		TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);
	}

	return (i);
}


/*
 * A ccb is put onto the free list.
 */
void
adw_ccb_free(void *xsc, void *xccb)
{
	ADW_SOFTC *sc = xsc;
	ADW_CCB *ccb = xccb;

	adw_reset_ccb(ccb);

	mtx_enter(&sc->sc_ccb_mtx);
	TAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);
	mtx_leave(&sc->sc_ccb_mtx);
}


void
adw_reset_ccb(ADW_CCB *ccb)
{

	ccb->flags = 0;
}


int
adw_init_ccb(ADW_SOFTC *sc, ADW_CCB *ccb)
{
	int	hashnum, error;

	/*
         * Create the DMA map for this CCB.
         */
	error = bus_dmamap_create(sc->sc_dmat,
				  (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,
			 ADW_MAX_SG_LIST, (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,
		   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);
	if (error) {
		printf("%s: unable to create CCB DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}

	/*
	 * put in the phystokv hash table
	 * Never gets taken out.
	 */
	ccb->hashkey = sc->sc_dmamap_control->dm_segs[0].ds_addr +
	    ADW_CCB_OFF(ccb);
	hashnum = CCB_HASH(ccb->hashkey);
	ccb->nexthash = sc->sc_ccbhash[hashnum];
	sc->sc_ccbhash[hashnum] = ccb;
	adw_reset_ccb(ccb);
	return (0);
}


/*
 * Get a free ccb
 *
 * If there are none, see if we can allocate a new one
 */
void *
adw_ccb_alloc(void *xsc)
{
	ADW_SOFTC *sc = xsc;
	ADW_CCB *ccb;

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = TAILQ_FIRST(&sc->sc_free_ccb);
	if (ccb) {
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, chain);
		ccb->flags |= CCB_ALLOC;
	}
	mtx_leave(&sc->sc_ccb_mtx);

	return (ccb);
}


/*
 * Given a physical address, find the ccb that it corresponds to.
 */
ADW_CCB *
adw_ccb_phys_kv(ADW_SOFTC *sc, u_int32_t ccb_phys)
{
	int hashnum = CCB_HASH(ccb_phys);
	ADW_CCB *ccb = sc->sc_ccbhash[hashnum];

	while (ccb) {
		if (ccb->hashkey == ccb_phys)
			break;
		ccb = ccb->nexthash;
	}
	return (ccb);
}


/*
 * Queue a CCB to be sent to the controller, and send it if possible.
 */
int
adw_queue_ccb(ADW_SOFTC *sc, ADW_CCB *ccb, int retry)
{
	int		errcode = ADW_SUCCESS;

	if(!retry) {
		TAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);
	}

	while ((ccb = TAILQ_FIRST(&sc->sc_waiting_ccb)) != NULL) {

		errcode = AdwExeScsiQueue(sc, &ccb->scsiq);
		switch(errcode) {
		case ADW_SUCCESS:
			break;

		case ADW_BUSY:
			printf("ADW_BUSY\n");
			return(ADW_BUSY);

		case ADW_ERROR:
			printf("ADW_ERROR\n");
			TAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);
			return(ADW_ERROR);
		}

		TAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);
		TAILQ_INSERT_TAIL(&sc->sc_pending_ccb, ccb, chain);

		/* ALWAYS initialize stimeout, lest it contain garbage! */
		timeout_set(&ccb->xs->stimeout, adw_timeout, ccb);
		if ((ccb->xs->flags & SCSI_POLL) == 0)
			timeout_add_msec(&ccb->xs->stimeout, ccb->timeout);
	}

	return(errcode);
}


/******************************************************************************/
/*                       SCSI layer interfacing routines                      */
/******************************************************************************/


int
adw_init(ADW_SOFTC *sc)
{
	u_int16_t       warn_code;


	sc->cfg.lib_version = (ADW_LIB_VERSION_MAJOR << 8) |
		ADW_LIB_VERSION_MINOR;
	sc->cfg.chip_version =
		ADW_GET_CHIP_VERSION(sc->sc_iot, sc->sc_ioh, sc->bus_type);

	/*
	 * Reset the chip to start and allow register writes.
	 */
	if (ADW_FIND_SIGNATURE(sc->sc_iot, sc->sc_ioh) == 0) {
		panic("adw_init: adw_find_signature failed");
	} else {
		AdwResetChip(sc->sc_iot, sc->sc_ioh);

		warn_code = AdwInitFromEEPROM(sc);

		if (warn_code & ADW_WARN_EEPROM_CHKSUM)
			printf("%s: Bad checksum found. "
			       "Setting default values\n",
			       sc->sc_dev.dv_xname);
		if (warn_code & ADW_WARN_EEPROM_TERMINATION)
			printf("%s: Bad bus termination setting."
			       "Using automatic termination.\n",
			       sc->sc_dev.dv_xname);
	}

	sc->isr_callback = (ADW_CALLBACK) adw_isr_callback;
	sc->async_callback = (ADW_CALLBACK) adw_async_callback;

	return 0;
}


void
adw_attach(ADW_SOFTC *sc)
{
	struct scsibus_attach_args	saa;
	int				i, error;


	TAILQ_INIT(&sc->sc_free_ccb);
	TAILQ_INIT(&sc->sc_waiting_ccb);
	TAILQ_INIT(&sc->sc_pending_ccb);

	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, adw_ccb_alloc, adw_ccb_free);

	/*
         * Allocate the Control Blocks.
         */
	error = adw_alloc_controls(sc);
	if (error)
		return; /* (error) */ ;

	/*
	 * Create and initialize the Control Blocks.
	 */
	i = adw_create_ccbs(sc, sc->sc_control->ccbs, ADW_MAX_CCB);
	if (i == 0) {
		printf("%s: unable to create Control Blocks\n",
		       sc->sc_dev.dv_xname);
		return; /* (ENOMEM) */ ;
	} else if (i != ADW_MAX_CCB) {
		printf("%s: WARNING: only %d of %d Control Blocks"
		       " created\n",
		       sc->sc_dev.dv_xname, i, ADW_MAX_CCB);
	}

	/*
	 * Create and initialize the Carriers.
	 */
	error = adw_alloc_carriers(sc);
	if (error)
		return; /* (error) */ ;

	/*
	 * Zero's the freeze_device status
	 */
	 bzero(sc->sc_freeze_dev, sizeof(sc->sc_freeze_dev));

	/*
	 * Initialize the adapter
	 */
	switch (AdwInitDriver(sc)) {
	case ADW_IERR_BIST_PRE_TEST:
		panic("%s: BIST pre-test error",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_BIST_RAM_TEST:
		panic("%s: BIST RAM test error",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_MCODE_CHKSUM:
		panic("%s: Microcode checksum error",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_ILLEGAL_CONNECTION:
		panic("%s: All three connectors are in use",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_REVERSED_CABLE:
		panic("%s: Cable is reversed",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_HVD_DEVICE:
		panic("%s: HVD attached to LVD connector",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_SINGLE_END_DEVICE:
		panic("%s: single-ended device is attached to"
		      " one of the connectors",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_NO_CARRIER:
		panic("%s: unable to create Carriers",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_WARN_BUSRESET_ERROR:
		printf("%s: WARNING: Bus Reset Error\n",
		      sc->sc_dev.dv_xname);
		break;
	}

	/*
	 * Fill in the adapter.
	 */
	sc->sc_adapter.scsi_cmd = adw_scsi_cmd;
	sc->sc_adapter.scsi_minphys = adw_minphys;

	/*
         * fill in the prototype scsi_link.
         */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->chip_scsi_id;
	sc->sc_link.adapter = &sc->sc_adapter;
	sc->sc_link.openings = 4;
	sc->sc_link.adapter_buswidth = ADW_MAX_TID+1;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	config_found(&sc->sc_dev, &saa, scsiprint);
}


void
adw_minphys(struct buf *bp, struct scsi_link *sl)
{

	if (bp->b_bcount > ((ADW_MAX_SG_LIST - 1) * PAGE_SIZE))
		bp->b_bcount = ((ADW_MAX_SG_LIST - 1) * PAGE_SIZE);
	minphys(bp);
}


/*
 * start a scsi operation given the command and the data address.
 * Also needs the unit, target and lu.
 */
void
adw_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *sc_link = xs->sc_link;
	ADW_SOFTC      *sc = sc_link->adapter_softc;
	ADW_CCB        *ccb;
	int             s, nowait = 0, retry = 0;
	int		flags;

	/*
         * get a ccb to use. If the transfer
         * is from a buf (possibly from interrupt time)
         * then we can't allow it to sleep
         */

	flags = xs->flags;
	if (nowait)
		flags |= SCSI_NOSLEEP;
	ccb = xs->io;

	ccb->xs = xs;
	ccb->timeout = xs->timeout;

	if (adw_build_req(xs, ccb, flags)) {
retryagain:
		s = splbio();
		retry = adw_queue_ccb(sc, ccb, retry);
		splx(s);

		switch(retry) {
		case ADW_BUSY:
			goto retryagain;

		case ADW_ERROR:
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}

		/*
	         * Usually return SUCCESSFULLY QUEUED
	         */
		if ((xs->flags & SCSI_POLL) == 0)
			return;

		/*
	         * If we can't use interrupts, poll on completion
	         */
		if (adw_poll(sc, xs, ccb->timeout)) {
			adw_timeout(ccb);
			if (adw_poll(sc, xs, ccb->timeout))
				adw_timeout(ccb);
		}
	} else {
		/* adw_build_req() has set xs->error already */
		scsi_done(xs);
	}
}


/*
 * Build a request structure for the Wide Boards.
 */
int
adw_build_req(struct scsi_xfer *xs, ADW_CCB *ccb, int flags)
{
	struct scsi_link *sc_link = xs->sc_link;
	ADW_SOFTC      *sc = sc_link->adapter_softc;
	bus_dma_tag_t   dmat = sc->sc_dmat;
	ADW_SCSI_REQ_Q *scsiqp;
	int             error;

	scsiqp = &ccb->scsiq;
	bzero(scsiqp, sizeof(ADW_SCSI_REQ_Q));

	/*
	 * Set the ADW_SCSI_REQ_Q 'ccb_ptr' to point to the
	 * physical CCB structure.
	 */
	scsiqp->ccb_ptr = ccb->hashkey;

	/*
	 * Build the ADW_SCSI_REQ_Q request.
	 */

	/*
	 * Set CDB length and copy it to the request structure.
	 * For wide  boards a CDB length maximum of 16 bytes
	 * is supported.
	 */
	scsiqp->cdb_len = xs->cmdlen;
	bcopy((caddr_t)xs->cmd, &scsiqp->cdb, 12);
	bcopy((caddr_t)xs->cmd + 12, &scsiqp->cdb16, 4);

	scsiqp->target_id = sc_link->target;
	scsiqp->target_lun = sc_link->lun;

	scsiqp->vsense_addr = &ccb->scsi_sense;
	scsiqp->sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +
			ADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsi_sense);
	scsiqp->sense_len = sizeof(struct scsi_sense_data);

	/*
	 * Build ADW_SCSI_REQ_Q for a scatter-gather buffer command.
	 */
	if (xs->datalen) {
		/*
                 * Map the DMA transfer.
                 */
		error = bus_dmamap_load(dmat,
		      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,
			(flags & SCSI_NOSLEEP) ?
			BUS_DMA_NOWAIT : BUS_DMA_WAITOK);

		if (error) {
			if (error == EFBIG) {
				printf("%s: adw_scsi_cmd, more than %d dma"
				       " segments\n",
				       sc->sc_dev.dv_xname, ADW_MAX_SG_LIST);
			} else {
				printf("%s: adw_scsi_cmd, error %d loading"
				       " dma map\n",
				       sc->sc_dev.dv_xname, error);
			}

			xs->error = XS_DRIVER_STUFFUP;
			return (0);
		}
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
		    0, ccb->dmamap_xfer->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);

		/*
		 * Build scatter-gather list.
		 */
		scsiqp->data_cnt = xs->datalen;
		scsiqp->vdata_addr = xs->data;
		scsiqp->data_addr = ccb->dmamap_xfer->dm_segs[0].ds_addr;
		bzero(ccb->sg_block, sizeof(ADW_SG_BLOCK) * ADW_NUM_SG_BLOCK);
		adw_build_sglist(ccb, scsiqp, ccb->sg_block);
	} else {
		/*
                 * No data xfer, use non S/G values.
                 */
		scsiqp->data_cnt = 0;
		scsiqp->vdata_addr = 0;
		scsiqp->data_addr = 0;
	}

	return (1);
}


/*
 * Build scatter-gather list for Wide Boards.
 */
void
adw_build_sglist(ADW_CCB *ccb, ADW_SCSI_REQ_Q *scsiqp, ADW_SG_BLOCK *sg_block)
{
	u_long          sg_block_next_addr;	/* block and its next */
	u_int32_t       sg_block_physical_addr;
	int             i;	/* how many SG entries */
	bus_dma_segment_t *sg_list = &ccb->dmamap_xfer->dm_segs[0];
	int             sg_elem_cnt = ccb->dmamap_xfer->dm_nsegs;


	sg_block_next_addr = (u_long) sg_block;	/* allow math operation */
	sg_block_physical_addr = ccb->hashkey +
	    offsetof(struct adw_ccb, sg_block[0]);
	scsiqp->sg_real_addr = sg_block_physical_addr;

	/*
	 * If there are more than NO_OF_SG_PER_BLOCK dma segments (hw sg-list)
	 * then split the request into multiple sg-list blocks.
	 */

	do {
		for (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {
			sg_block->sg_list[i].sg_addr = sg_list->ds_addr;
			sg_block->sg_list[i].sg_count = sg_list->ds_len;

			if (--sg_elem_cnt == 0) {
				/* last entry, get out */
				sg_block->sg_cnt = i + 1;
				sg_block->sg_ptr = 0; /* next link = NULL */
				return;
			}
			sg_list++;
		}
		sg_block_next_addr += sizeof(ADW_SG_BLOCK);
		sg_block_physical_addr += sizeof(ADW_SG_BLOCK);

		sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
		sg_block->sg_ptr = sg_block_physical_addr;
		sg_block = (ADW_SG_BLOCK *) sg_block_next_addr;	/* virt. addr */
	} while (1);
}


/******************************************************************************/
/*                       Interrupts and TimeOut routines                      */
/******************************************************************************/


int
adw_intr(void *arg)
{
	ADW_SOFTC      *sc = arg;


	if(AdwISR(sc) != ADW_FALSE) {
		return (1);
	}

	return (0);
}


/*
 * Poll a particular unit, looking for a particular xs
 */
int
adw_poll(ADW_SOFTC *sc, struct scsi_xfer *xs, int count)
{
	int s;

	/* timeouts are in msec, so we loop in 1000 usec cycles */
	while (count > 0) {
		s = splbio();
		adw_intr(sc);
		splx(s);
		if (xs->flags & ITSDONE) {
			if ((xs->cmd->opcode == INQUIRY)
			    && (xs->sc_link->lun == 0)
			    && (xs->error == XS_NOERROR))
				adw_print_info(sc, xs->sc_link->target);
			return (0);
		}
		delay(1000);	/* only happens in boot so ok */
		count--;
	}
	return (1);
}


void
adw_timeout(void *arg)
{
	ADW_CCB        *ccb = arg;
	struct scsi_xfer *xs = ccb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	ADW_SOFTC      *sc = sc_link->adapter_softc;
	int             s;

	sc_print_addr(sc_link);
	printf("timed out");

	s = splbio();

	if (ccb->flags & CCB_ABORTED) {
	/*
	 * Abort Timed Out
	 *
	 * No more opportunities. Lets try resetting the bus and
	 * reinitialize the host adapter.
	 */
		timeout_del(&xs->stimeout);
		printf(" AGAIN. Resetting SCSI Bus\n");
		adw_reset_bus(sc);
		splx(s);
		return;
	} else if (ccb->flags & CCB_ABORTING) {
	/*
	 * Abort the operation that has timed out.
	 *
	 * Second opportunity.
	 */
		printf("\n");
		xs->error = XS_TIMEOUT;
		ccb->flags |= CCB_ABORTED;
#if 0
		/*
		 * - XXX - 3.3a microcode is BROKEN!!!
		 *
		 * We cannot abort a CCB, so we can only hope the command
		 * get completed before the next timeout, otherwise a
		 * Bus Reset will arrive inexorably.
		 */
		/*
		 * ADW_ABORT_CCB() makes the board to generate an interrupt
		 *
		 * - XXX - The above assertion MUST be verified (and this
		 *         code changed as well [callout_*()]), when the
		 *         ADW_ABORT_CCB will be working again
		 */
		ADW_ABORT_CCB(sc, ccb);
#endif
		/*
		 * waiting for multishot callout_reset() let's restart it
		 * by hand so the next time a timeout event will occur
		 * we will reset the bus.
		 */
		timeout_add_msec(&xs->stimeout, ccb->timeout);
	} else {
	/*
	 * Abort the operation that has timed out.
	 *
	 * First opportunity.
	 */
		printf("\n");
		xs->error = XS_TIMEOUT;
		ccb->flags |= CCB_ABORTING;
#if 0
		/*
		 * - XXX - 3.3a microcode is BROKEN!!!
		 *
		 * We cannot abort a CCB, so we can only hope the command
		 * get completed before the next 2 timeout, otherwise a
		 * Bus Reset will arrive inexorably.
		 */
		/*
		 * ADW_ABORT_CCB() makes the board to generate an interrupt
		 *
		 * - XXX - The above assertion MUST be verified (and this
		 *         code changed as well [callout_*()]), when the
		 *         ADW_ABORT_CCB will be working again
		 */
		ADW_ABORT_CCB(sc, ccb);
#endif
		/*
		 * waiting for multishot callout_reset() let's restart it
		 * by hand so to give a second opportunity to the command
		 * which timed-out.
		 */
		timeout_add_msec(&xs->stimeout, ccb->timeout);
	}

	splx(s);
}


void
adw_reset_bus(ADW_SOFTC *sc) 
{
	ADW_CCB	*ccb;
	int	 s;

	s = splbio();
	AdwResetSCSIBus(sc); /* XXX - should check return value? */
	while((ccb = TAILQ_LAST(&sc->sc_pending_ccb,
			adw_pending_ccb)) != NULL) {
	        timeout_del(&ccb->xs->stimeout);
		TAILQ_REMOVE(&sc->sc_pending_ccb, ccb, chain);
		TAILQ_INSERT_HEAD(&sc->sc_waiting_ccb, ccb, chain);
	}

	bzero(sc->sc_freeze_dev, sizeof(sc->sc_freeze_dev));
	adw_queue_ccb(sc, TAILQ_FIRST(&sc->sc_waiting_ccb), 1);

	splx(s);
}


/******************************************************************************/
/*              Host Adapter and Peripherals Information Routines             */
/******************************************************************************/


void
adw_print_info(ADW_SOFTC *sc, int tid)
{
	bus_space_handle_t ioh = sc->sc_ioh;
	bus_space_tag_t iot = sc->sc_iot;
	u_int16_t hshk_cfg, able_mask, period = 0;

	/* hshk/HSHK means 'handskake' */

	ADW_READ_WORD_LRAM(iot, ioh,
	    ADW_MC_DEVICE_HSHK_CFG_TABLE + (2 * tid), hshk_cfg);

	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, able_mask);
	if ((able_mask & ADW_TID_TO_TIDMASK(tid)) == 0)
		hshk_cfg &= ~HSHK_CFG_WIDE_XFR;

	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, able_mask);
	if ((able_mask & ADW_TID_TO_TIDMASK(tid)) == 0)
		hshk_cfg &= ~HSHK_CFG_OFFSET;

	printf("%s: target %d using %d bit ", sc->sc_dev.dv_xname, tid,
	    (hshk_cfg & HSHK_CFG_WIDE_XFR) ? 16 : 8);

	if ((hshk_cfg & HSHK_CFG_OFFSET) == 0)
		printf("async ");
	else {
		period = (hshk_cfg & 0x1f00) >> 8;
		switch (period) {
		case 0x11: 
			printf("80.0 ");
			break;
		case 0x10:
			printf("40.0 ");
			break;
		default:
			period = (period * 25) + 50;
			printf("%d.%d ", 1000/period, ADW_TENTHS(1000, period));
			break;
		}
		printf("MHz %d REQ/ACK offset ", hshk_cfg & HSHK_CFG_OFFSET);
	}

	printf("xfers\n");
}	


/******************************************************************************/
/*                        WIDE boards Interrupt callbacks                     */
/******************************************************************************/


/*
 * adw_isr_callback() - Second Level Interrupt Handler called by AdwISR()
 *
 * Interrupt callback function for the Wide SCSI Adw Library.
 *
 * Notice:
 * Interrupts are disabled by the caller (AdwISR() function), and will be
 * enabled at the end of the caller.
 */
void
adw_isr_callback(ADW_SOFTC *sc, ADW_SCSI_REQ_Q *scsiq)
{
	bus_dma_tag_t   dmat;
	ADW_CCB        *ccb;
	struct scsi_xfer *xs;
	struct scsi_sense_data *s1, *s2;


	ccb = adw_ccb_phys_kv(sc, scsiq->ccb_ptr);
	TAILQ_REMOVE(&sc->sc_pending_ccb, ccb, chain);

	if ((ccb->flags & CCB_ALLOC) == 0) {
		panic("%s: unallocated ccb found on pending list!",
		    sc->sc_dev.dv_xname);
		return;
	}

	xs = ccb->xs;
	timeout_del(&xs->stimeout);

	/*
         * If we were a data transfer, unload the map that described
         * the data buffer.
         */
	dmat = sc->sc_dmat;
	if (xs->datalen) {
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
		    0, ccb->dmamap_xfer->dm_mapsize,
		    ((xs->flags & SCSI_DATA_IN) ?
		        BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
		bus_dmamap_unload(dmat, ccb->dmamap_xfer);
	}

	/*
	 * 'done_status' contains the command's ending status.
	 * 'host_status' contains the host adapter status.
	 * 'scsi_status' contains the scsi peripheral status.
	 */

	sc->sc_freeze_dev[scsiq->target_id] = 0;
	xs->status = scsiq->scsi_status;

	switch (scsiq->done_status) {
	case QD_NO_ERROR: /* (scsi_status == 0) && (host_status == 0) */
NO_ERROR:
		xs->resid = scsiq->data_cnt;
		xs->error = XS_NOERROR;
		break;

	case QD_WITH_ERROR:
		switch (scsiq->host_status) {
		case QHSTA_NO_ERROR:
			switch (scsiq->scsi_status) {
			case SCSI_COND_MET:
			case SCSI_INTERM:
			case SCSI_INTERM_COND_MET:
				/*
				 * These non-zero status values are 
				 * not really error conditions.
				 *
				 * XXX - would it be too paranoid to 
				 *       add SCSI_OK here in
				 *       case the docs are wrong re
				 *       QD_NO_ERROR?
				 */
				goto NO_ERROR;

			case SCSI_CHECK:
			case SCSI_TERMINATED:
			case SCSI_ACA_ACTIVE:
				s1 = &ccb->scsi_sense;
				s2 = &xs->sense;
				*s2 = *s1;
				xs->error = XS_SENSE;
				break;

			case SCSI_BUSY:
			case SCSI_QUEUE_FULL:
			case SCSI_RESV_CONFLICT:
				sc->sc_freeze_dev[scsiq->target_id] = 1;
				xs->error = XS_BUSY;
				break;
		
			default: /* scsiq->scsi_status value */
				printf("%s: bad scsi_status: 0x%02x.\n"
				    ,sc->sc_dev.dv_xname
				    ,scsiq->scsi_status);
				xs->error = XS_DRIVER_STUFFUP;
				break;
			}
			break;
		
		case QHSTA_M_SEL_TIMEOUT:
			xs->error = XS_SELTIMEOUT;
			break;

		case QHSTA_M_DIRECTION_ERR:
		case QHSTA_M_SXFR_OFF_UFLW:
		case QHSTA_M_SXFR_OFF_OFLW:
		case QHSTA_M_SXFR_XFR_OFLW:
		case QHSTA_M_QUEUE_ABORTED:
		case QHSTA_M_INVALID_DEVICE:
		case QHSTA_M_SGBACKUP_ERROR:
		case QHSTA_M_SXFR_DESELECTED:
		case QHSTA_M_SXFR_XFR_PH_ERR:
		case QHSTA_M_BUS_DEVICE_RESET:
		case QHSTA_M_NO_AUTO_REQ_SENSE:
		case QHSTA_M_BAD_CMPL_STATUS_IN:
		case QHSTA_M_SXFR_UNKNOWN_ERROR:
		case QHSTA_M_AUTO_REQ_SENSE_FAIL:
		case QHSTA_M_UNEXPECTED_BUS_FREE:
			printf("%s: host adapter error 0x%02x."
			       " See adw(4).\n"
			    ,sc->sc_dev.dv_xname, scsiq->host_status);
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case QHSTA_M_RDMA_PERR:
		case QHSTA_M_SXFR_WD_TMO:
		case QHSTA_M_WTM_TIMEOUT:
		case QHSTA_M_FROZEN_TIDQ:
		case QHSTA_M_SXFR_SDMA_ERR:
		case QHSTA_M_SXFR_SXFR_PERR:
		case QHSTA_M_SCSI_BUS_RESET:
		case QHSTA_M_DIRECTION_ERR_HUNG:
		case QHSTA_M_SCSI_BUS_RESET_UNSOL:
			/*
			 * XXX - are all these cases really asking
			 *       for a card reset? _BUS_RESET and
			 *       _BUS_RESET_UNSOL added just to make
			 *       sure the pending queue is cleared out
			 *       in case card has lost track of them.
			 */
			printf("%s: host adapter error 0x%02x,"
			       " resetting bus. See adw(4).\n"
			    ,sc->sc_dev.dv_xname, scsiq->host_status);
			adw_reset_bus(sc);
			xs->error = XS_RESET;
			break;
			
		default: /* scsiq->host_status value */
			/*
			 * XXX - is a panic really appropriate here? If
			 *       not, would it be better to make the 
			 *       XS_DRIVER_STUFFUP case above the 
			 *       default behaviour? Or XS_RESET?
			 */
			panic("%s: bad host_status: 0x%02x"
			    ,sc->sc_dev.dv_xname, scsiq->host_status);
			break;      
		}
		break;

	case QD_ABORTED_BY_HOST:
		xs->error = XS_DRIVER_STUFFUP;
		break;

	default: /* scsiq->done_status value */
		/*
		 * XXX - would QD_NO_STATUS really mean the I/O is not
		 *       done? and would that mean it should somehow be
		 *       put back as a pending I/O?
		 */
		printf("%s: bad done_status: 0x%02x"
		       " (host_status: 0x%02x, scsi_status: 0x%02x)\n"
		    ,sc->sc_dev.dv_xname
		    ,scsiq->done_status
		    ,scsiq->host_status
		    ,scsiq->scsi_status);
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	scsi_done(xs);
}


/*
 * adw_async_callback() - Adw Library asynchronous event callback function.
 */
void
adw_async_callback(ADW_SOFTC *sc, u_int8_t code)
{
	switch (code) {
	case ADW_ASYNC_SCSI_BUS_RESET_DET:
		/* The firmware detected a SCSI Bus reset. */
		printf("%s: SCSI Bus reset detected\n", sc->sc_dev.dv_xname);
		break;

	case ADW_ASYNC_RDMA_FAILURE:
		/*
		 * Handle RDMA failure by resetting the SCSI Bus and
		 * possibly the chip if it is unresponsive.
		 */
		printf("%s: RDMA failure. Resetting the SCSI Bus and"
				" the adapter\n", sc->sc_dev.dv_xname);
		adw_reset_bus(sc);
		break;

	case ADW_HOST_SCSI_BUS_RESET:
		/* Host generated SCSI bus reset occurred. */
		printf("%s: Host generated SCSI bus reset occurred\n",
				sc->sc_dev.dv_xname);
		break;


	case ADW_ASYNC_CARRIER_READY_FAILURE:
		/* 
		 * Carrier Ready failure.
	         *
		 * A warning only - RISC too busy to realize it's been 
		 * tickled. Occurs in normal operation under heavy
		 * load, so a message is printed only when ADW_DEBUG'ing
		 */
#ifdef ADW_DEBUG
		printf("%s: Carrier Ready failure!\n", sc->sc_dev.dv_xname);
#endif
		break;

	default:
	        printf("%s: Unknown Async callback code (ignored): 0x%02x\n",
		    sc->sc_dev.dv_xname, code);
		break;
	}
}
@


1.53
log
@Convert some malloc(9) to mallocarray(9)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.52 2015/03/14 03:38:47 jsg Exp $ */
d147 1
a147 1
		mallocarray(ADW_MAX_CARRIER, sizeof(ADW_CARRIER), M_DEVBUF,
@


1.52
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.51 2014/09/14 14:17:24 jsg Exp $ */
d147 1
a147 1
		malloc(sizeof(ADW_CARRIER) * ADW_MAX_CARRIER, M_DEVBUF, 
@


1.51
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.50 2012/01/11 16:22:32 dhill Exp $ */
a38 1
#include <sys/ioctl.h>
@


1.50
log
@ansify and de'register some prototypes

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.49 2011/04/07 15:30:16 miod Exp $ */
a42 1
#include <sys/proc.h>
@


1.49
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.48 2010/10/03 21:23:35 krw Exp $ */
d95 1
a95 2
adw_alloc_controls(sc)
	ADW_SOFTC      *sc;
d140 1
a140 2
adw_alloc_carriers(sc)
	ADW_SOFTC      *sc;
d205 1
a205 4
adw_create_ccbs(sc, ccbstore, count)
	ADW_SOFTC      *sc;
	ADW_CCB        *ccbstore;
	int             count;
d228 1
a228 2
adw_ccb_free(xsc, xccb)
	void *xsc, *xccb;
d242 1
a242 2
adw_reset_ccb(ccb)
	ADW_CCB        *ccb;
d250 1
a250 3
adw_init_ccb(sc, ccb)
	ADW_SOFTC      *sc;
	ADW_CCB        *ccb;
d287 1
a287 2
adw_ccb_alloc(xsc)
	void *xsc;
d308 1
a308 3
adw_ccb_phys_kv(sc, ccb_phys)
	ADW_SOFTC	*sc;
	u_int32_t	ccb_phys;
d326 1
a326 4
adw_queue_ccb(sc, ccb, retry)
	ADW_SOFTC      *sc;
	ADW_CCB        *ccb;
	int		retry;
d370 1
a370 2
adw_init(sc)
	ADW_SOFTC      *sc;
d408 1
a408 2
adw_attach(sc)
	ADW_SOFTC      *sc;
d543 1
a543 2
adw_scsi_cmd(xs)
	struct scsi_xfer *xs;
d606 1
a606 4
adw_build_req(xs, ccb, flags)
	struct scsi_xfer *xs;
	ADW_CCB        *ccb;
	int		flags;
d700 1
a700 4
adw_build_sglist(ccb, scsiqp, sg_block)
	ADW_CCB        *ccb;
	ADW_SCSI_REQ_Q *scsiqp;
	ADW_SG_BLOCK   *sg_block;
d748 1
a748 2
adw_intr(arg)
	void           *arg;
d765 1
a765 4
adw_poll(sc, xs, count)
	ADW_SOFTC      *sc;
	struct scsi_xfer *xs;
	int             count;
d789 1
a789 2
adw_timeout(arg)
	void           *arg;
d885 1
a885 2
adw_reset_bus(sc) 
	ADW_SOFTC		*sc;
d912 1
a912 3
adw_print_info(sc, tid)
	ADW_SOFTC	*sc;
	int		 tid;
d972 1
a972 3
adw_isr_callback(sc, scsiq)
	ADW_SOFTC      *sc;
	ADW_SCSI_REQ_Q *scsiq;
d1153 1
a1153 3
adw_async_callback(sc, code)
	ADW_SOFTC	*sc;
	u_int8_t	code;
@


1.48
log
@iopoolification. Tested on my Advansys ASP-3940U2W. Various eyes
including miod@@, oga@@, dlg@@, matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.47 2010/08/07 03:50:01 krw Exp $ */
d751 1
a751 1
				sg_block->sg_ptr = NULL; /* next link = NULL */
@


1.47
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.46 2010/06/28 18:31:01 krw Exp $ */
d62 1
a62 1
void adw_free_ccb(ADW_SOFTC *, ADW_CCB *);
d65 1
a65 1
ADW_CCB *adw_get_ccb(ADW_SOFTC *, int);
d233 2
a234 3
adw_free_ccb(sc, ccb)
	ADW_SOFTC      *sc;
	ADW_CCB        *ccb;
d236 2
a237 1
	int             s;
d239 1
a239 1
	s = splbio();
d241 1
a241 1
	adw_reset_ccb(ccb);
d243 1
a243 9

	/*
         * If there were none, wake anybody waiting for one to come free,
         * starting with queued entries.
         */
	if (TAILQ_NEXT(ccb, chain) == NULL)
		wakeup(&sc->sc_free_ccb);

	splx(s);
d295 12
a306 24
ADW_CCB *
adw_get_ccb(sc, flags)
	ADW_SOFTC      *sc;
	int             flags;
{
	ADW_CCB        *ccb = 0;
	int             s;

	s = splbio();

	/*
         * If we can and have to, sleep waiting for one to come free
         * but only if we can't allocate a new one.
         */
	for (;;) {
		ccb = TAILQ_FIRST(&sc->sc_free_ccb);
		if (ccb) {
			TAILQ_REMOVE(&sc->sc_free_ccb, ccb, chain);
			break;
		}
		if ((flags & SCSI_NOSLEEP) != 0)
			goto out;

		tsleep(&sc->sc_free_ccb, PRIBIO, "adwccb", 0);
d308 1
a309 4
	ccb->flags |= CCB_ALLOC;

out:
	splx(s);
d435 2
d536 1
a568 2
	s = splbio();		/* protect the queue */

d578 1
a578 7
	if ((ccb = adw_get_ccb(sc, flags)) == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		splx(s);
		return;
	}
	splx(s);		/* done playing with the queue */
a688 1
			adw_free_ccb(sc, ccb);
a1019 1
		adw_free_ccb(sc, ccb);
a1177 2

	adw_free_ccb(sc, ccb);
@


1.46
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.45 2010/06/26 04:04:24 krw Exp $ */
d1047 1
a1047 1
		panic("%s: unallocated ccb found on pending list!\n",
@


1.45
log
@xs->cmd[n] doesn't mean the n'th byte, because xs->cmd is a struct
*scsi_generic. Change xs->cmd[0] references in sii.c to xs->cmd->opcode
and do (caddr_t) arithmetic when copying chunks into the adw adapter
struct.

Found by Matthew Dempsky, diff tweaked and tested by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.44 2010/05/20 00:55:17 krw Exp $ */
a88 10
/* the below structure is so we have a default dev struct for our link struct */
struct scsi_device adw_dev =
{
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};


a554 1
	sc->sc_link.device = &adw_dev;
@


1.44
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.43 2010/05/19 15:27:35 oga Exp $ */
a43 1
#include <sys/user.h>
d692 3
a694 4
	bcopy(xs->cmd, &scsiqp->cdb, ((scsiqp->cdb_len = xs->cmdlen) <= 12)?
			xs->cmdlen : 12 );
	if(xs->cmdlen > 12)
		bcopy(&(xs->cmd[12]),  &scsiqp->cdb16, xs->cmdlen - 12);
@


1.43
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.42 2010/03/23 01:57:19 krw Exp $ */
a634 1
			s = splbio();
a635 1
			splx(s);
a654 1
		s = splbio();
a655 1
		splx(s);
@


1.42
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.41 2010/01/10 00:10:23 krw Exp $ */
d116 1
a116 1
			   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
a475 2

	bzero(sc->sc_control, sizeof(struct adw_control));
@


1.41
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.40 2009/09/04 04:57:14 miod Exp $ */
d69 1
a69 1
int adw_scsi_cmd(struct scsi_xfer *);
d593 1
a593 1
int
d615 2
d618 1
a618 1
		return (NO_CCB);
d640 1
a640 1
			return (COMPLETE);
d647 1
a647 1
			return (SUCCESSFULLY_QUEUED);
a662 1
	return (COMPLETE);
@


1.40
log
@Missing scsi_done() in some error path returning COMPLETE; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.39 2009/08/29 13:58:51 jasper Exp $ */
a634 1
			xs->flags |= ITSDONE;
a656 1
		xs->flags |= ITSDONE;
a1228 1
	xs->flags |= ITSDONE;
@


1.39
log
@remove more unneeded Debugger() calls from dev/

agreed by deraadt@@
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.38 2009/02/16 21:19:06 miod Exp $ */
d635 4
d656 6
@


1.38
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.37 2009/01/21 21:53:59 grange Exp $ */
a56 4
#ifndef DDB
#define	Debugger()	panic("should call debugger here (adw.c)")
#endif				/* ! DDB */

d1057 1
a1057 1
		printf("%s: unallocated ccb found on pending list!\n",
a1058 1
		Debugger();
@


1.37
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.36 2008/11/26 16:38:00 krw Exp $ */
d76 1
a76 1
void adw_minphys(struct buf *);
d584 1
a584 2
adw_minphys(bp)
	struct buf     *bp;
@


1.36
log
@Stop maintaining internal queues of received scsi_xfer structures.

We can now just push unwanted ones back up into the SCSI layer
with NO_CCB like other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.35 2008/11/24 00:31:35 krw Exp $ */
d410 1
a410 1
			timeout_add(&ccb->xs->stimeout, (ccb->timeout * hz) / 1000);
d918 1
a918 1
		timeout_add(&xs->stimeout, (ccb->timeout * hz) / 1000);
d950 1
a950 1
		timeout_add(&xs->stimeout, (ccb->timeout * hz) / 1000);
@


1.35
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.34 2008/09/12 11:14:04 miod Exp $ */
a63 3
void adw_enqueue(ADW_SOFTC *, struct scsi_xfer *, int);
struct scsi_xfer *adw_dequeue(ADW_SOFTC *);

a104 45
/* scsi_xfer queue routines                                                   */
/******************************************************************************/

/*
 * Insert a scsi_xfer into the software queue.  We overload xs->free_list
 * to avoid having to allocate additional resources (since we're used
 * only during resource shortages anyhow.
 */
void
adw_enqueue(sc, xs, infront)
	ADW_SOFTC      *sc;
	struct scsi_xfer *xs;
	int             infront;
{

	if (infront || LIST_EMPTY(&sc->sc_queue)) {
		if (LIST_EMPTY(&sc->sc_queue))
			sc->sc_queuelast = xs;
		LIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);
		return;
	}
	LIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);
	sc->sc_queuelast = xs;
}


/*
 * Pull a scsi_xfer off the front of the software queue.
 */
struct scsi_xfer *
adw_dequeue(sc)
	ADW_SOFTC      *sc;
{
	struct scsi_xfer *xs;

	xs = LIST_FIRST(&sc->sc_queue);
	LIST_REMOVE(xs, free_list);

	if (LIST_EMPTY(&sc->sc_queue))
		sc->sc_queuelast = NULL;

	return (xs);
}

/******************************************************************************/
a471 1
	LIST_INIT(&sc->sc_queue);
d605 1
a605 1
	int             s, fromqueue = 1, dontqueue = 0, nowait = 0, retry = 0;
a610 43
         * If we're running the queue from adw_done(), we've been
         * called with the first queue entry as our argument.
         */
	if (xs == LIST_FIRST(&sc->sc_queue)) {
 		if(sc->sc_freeze_dev[xs->sc_link->target]) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}
		xs = adw_dequeue(sc);
		fromqueue = 1;
		nowait = 1;
	} else {
 		if(sc->sc_freeze_dev[xs->sc_link->target]) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}

		/* Polled requests can't be queued for later. */
		dontqueue = xs->flags & SCSI_POLL;

		/*
                 * If there are jobs in the queue, run them first.
                 */
		if (!LIST_EMPTY(&sc->sc_queue)) {
			/*
                         * If we can't queue, we have to abort, since
                         * we have to preserve order.
                         */
			if (dontqueue) {
				splx(s);
				return (TRY_AGAIN_LATER);
			}
			/*
                         * Swap with the first queue entry.
                         */
			adw_enqueue(sc, xs, 0);
			xs = adw_dequeue(sc);
			fromqueue = 1;
		}
	}


	/*
a619 12
		/*
                 * If we can't queue, we lose.
                 */
		if (dontqueue) {
			splx(s);
			return (NO_CCB);
		}
		/*
                 * Stuff ourselves into the queue, in front
                 * if we came off in the first place.
                 */
		adw_enqueue(sc, xs, fromqueue);
d621 1
a621 1
		return (SUCCESSFULLY_QUEUED);
a819 1
	struct scsi_xfer *xs;
a822 11
		/*
	         * If there are queue entries in the software queue, try to
	         * run the first one.  We should be more or less guaranteed
	         * to succeed, since we just freed a CCB.
	         *
	         * NOTE: adw_scsi_cmd() relies on our calling it with
	         * the first entry in the queue.
	         */
		if ((xs = LIST_FIRST(&sc->sc_queue)) != NULL)
			(void) adw_scsi_cmd(xs);

@


1.34
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.33 2008/06/26 05:42:15 ray Exp $ */
d717 1
a717 1
			return (TRY_AGAIN_LATER);
@


1.33
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.32 2007/11/05 20:50:20 krw Exp $ */
d819 4
a822 14
#ifdef TFS
		if (xs->flags & SCSI_DATA_UIO) {
			error = bus_dmamap_load_uio(dmat,
				ccb->dmamap_xfer, (struct uio *) xs->data,
				(flags & SCSI_NOSLEEP) ?
				BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		} else
#endif		/* TFS */
		{
			error = bus_dmamap_load(dmat,
			      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,
				(flags & SCSI_NOSLEEP) ?
				BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		}
@


1.32
log
@More scsi_done() at SPLBIO. Wrap more interrupt function calls while
polling in splbio/splx.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.31 2006/11/28 23:59:45 dlg Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.31
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.30 2005/12/03 16:53:15 krw Exp $ */
d972 1
d976 1
d978 1
@


1.30
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.29 2004/12/26 21:22:13 miod Exp $ */
d520 2
a521 1
	int             i, error;
d632 4
a635 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
@


1.29
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.28 2004/01/09 21:32:23 brad Exp $ */
a676 1
			xs->error = XS_DRIVER_STUFFUP;
a692 1
				xs->error = XS_DRIVER_STUFFUP;
a719 1
			xs->error = XS_DRIVER_STUFFUP;
@


1.28
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.27 2003/10/21 18:58:48 jmc Exp $ */
d130 2
a131 2
	if (infront || sc->sc_queue.lh_first == NULL) {
		if (sc->sc_queue.lh_first == NULL)
d150 1
a150 1
	xs = sc->sc_queue.lh_first;
d153 1
a153 1
	if (sc->sc_queue.lh_first == NULL)
d318 1
a318 1
	if (ccb->chain.tqe_next == 0)
d388 1
a388 1
		ccb = sc->sc_free_ccb.tqh_first;
d442 1
a442 1
	while ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {
d666 1
a666 1
	if (xs == sc->sc_queue.lh_first) {
d687 1
a687 1
		if (sc->sc_queue.lh_first != NULL) {
d952 1
a952 1
	        if ((xs = sc->sc_queue.lh_first) != NULL)
@


1.27
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.26 2002/03/14 01:26:53 millert Exp $ */
a55 2

#include <uvm/uvm_extern.h>
@


1.26
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.25 2001/11/11 21:59:19 krw Exp $ */
d1046 1
a1046 1
		 * by hand so the next time a timeout event will occour
d1218 1
a1218 1
	 * 'host_status' conatins the host adapter status.
@


1.25
log
@Remove local defines for SCSI status codes and use those now
defined in scsi_all.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.24 2001/11/06 19:53:18 miod Exp $ */
d73 2
a74 2
void adw_enqueue __P((ADW_SOFTC *, struct scsi_xfer *, int));
struct scsi_xfer *adw_dequeue __P((ADW_SOFTC *));
d76 21
a96 21
int adw_alloc_controls __P((ADW_SOFTC *));
int adw_alloc_carriers __P((ADW_SOFTC *));
int adw_create_ccbs __P((ADW_SOFTC *, ADW_CCB *, int));
void adw_free_ccb __P((ADW_SOFTC *, ADW_CCB *));
void adw_reset_ccb __P((ADW_CCB *));
int adw_init_ccb __P((ADW_SOFTC *, ADW_CCB *));
ADW_CCB *adw_get_ccb __P((ADW_SOFTC *, int));
int adw_queue_ccb __P((ADW_SOFTC *, ADW_CCB *, int));

int adw_scsi_cmd __P((struct scsi_xfer *));
int adw_build_req __P((struct scsi_xfer *, ADW_CCB *, int));
void adw_build_sglist __P((ADW_CCB *, ADW_SCSI_REQ_Q *, ADW_SG_BLOCK *));
void adw_minphys __P((struct buf *));
void adw_isr_callback __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));
void adw_async_callback __P((ADW_SOFTC *, u_int8_t));

void adw_print_info __P((ADW_SOFTC *, int));

int adw_poll __P((ADW_SOFTC *, struct scsi_xfer *, int));
void adw_timeout __P((void *));
void adw_reset_bus __P((ADW_SOFTC *));
@


1.25.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.25 2001/11/11 21:59:19 krw Exp $ */
d73 2
a74 2
void adw_enqueue(ADW_SOFTC *, struct scsi_xfer *, int);
struct scsi_xfer *adw_dequeue(ADW_SOFTC *);
d76 21
a96 21
int adw_alloc_controls(ADW_SOFTC *);
int adw_alloc_carriers(ADW_SOFTC *);
int adw_create_ccbs(ADW_SOFTC *, ADW_CCB *, int);
void adw_free_ccb(ADW_SOFTC *, ADW_CCB *);
void adw_reset_ccb(ADW_CCB *);
int adw_init_ccb(ADW_SOFTC *, ADW_CCB *);
ADW_CCB *adw_get_ccb(ADW_SOFTC *, int);
int adw_queue_ccb(ADW_SOFTC *, ADW_CCB *, int);

int adw_scsi_cmd(struct scsi_xfer *);
int adw_build_req(struct scsi_xfer *, ADW_CCB *, int);
void adw_build_sglist(ADW_CCB *, ADW_SCSI_REQ_Q *, ADW_SG_BLOCK *);
void adw_minphys(struct buf *);
void adw_isr_callback(ADW_SOFTC *, ADW_SCSI_REQ_Q *);
void adw_async_callback(ADW_SOFTC *, u_int8_t);

void adw_print_info(ADW_SOFTC *, int);

int adw_poll(ADW_SOFTC *, struct scsi_xfer *, int);
void adw_timeout(void *);
void adw_reset_bus(ADW_SOFTC *);
@


1.24
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.23 2001/11/05 17:25:58 art Exp $ */
d1236 3
a1238 3
			case SCSI_STATUS_CONDITION_MET:
			case SCSI_STATUS_INTERMID:
			case SCSI_STATUS_INTERMID_COND_MET:
d1244 1
a1244 1
				 *       add SCSI_STATUS_GOOD here in
d1250 3
a1252 3
			case SCSI_STATUS_CHECK_CONDITION:
			case SCSI_STATUS_CMD_TERMINATED:
			case SCSI_STATUS_ACA_ACTIVE:
d1259 3
a1261 3
			case SCSI_STATUS_TARGET_BUSY:
			case SCSI_STATUS_QUEUE_FULL:
			case SCSI_STATUS_RSERV_CONFLICT:
@


1.23
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.22 2001/09/21 17:55:43 miod Exp $ */
d57 1
a57 1
#include <vm/vm.h>
@


1.22
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.21 2001/08/26 02:39:05 krw Exp $ */
d857 1
a857 1
		adw_bus_dmamap_sync(dmat, ccb->dmamap_xfer,
d1209 1
a1209 1
		adw_bus_dmamap_sync(dmat, ccb->dmamap_xfer,
@


1.21
log
@Prepare for transition to 5-parameter bus_dmamap_sync() by creating and
using *_bus_dmamap_sync() defines that are defined appropriately
depending on __HAS_NEW_BUS_DMAMAP_SYNC.

Most of the code changes are simple reversions to the original NetBSD
code.

Slip in a siop_script_sync() instead of a manually done code section.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.20 2001/07/11 17:31:24 krw Exp $ */
d1408 2
a1409 2
	        printf("%s: Unknown Async callback code (ignored): 0x%02x\n"
		       ,sc->sc_dev.dv_xname );
@


1.20
log
@Eliminate use of static functions in line with normal OpenBSD
preferences. Having more debugging info available during
fixup of this driver to work on powerpc can't hurt either!

Change adwminphys() to adw_minphys() to make consistant with all
other function names in adw.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.19 2001/05/16 19:19:28 mickey Exp $ */
d857 4
a860 3
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
				(xs->flags & SCSI_DATA_IN) ?
				BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
d1209 4
a1212 3
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
		    (xs->flags & SCSI_DATA_IN) ?
		        BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
@


1.19
log
@allocate memory w/ NOWAIT during autoconf time and check for NULL return
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.18 2001/05/16 12:51:48 ho Exp $ */
d73 2
a74 2
static void adw_enqueue __P((ADW_SOFTC *, struct scsi_xfer *, int));
static struct scsi_xfer *adw_dequeue __P((ADW_SOFTC *));
d76 21
a96 21
static int adw_alloc_controls __P((ADW_SOFTC *));
static int adw_alloc_carriers __P((ADW_SOFTC *));
static int adw_create_ccbs __P((ADW_SOFTC *, ADW_CCB *, int));
static void adw_free_ccb __P((ADW_SOFTC *, ADW_CCB *));
static void adw_reset_ccb __P((ADW_CCB *));
static int adw_init_ccb __P((ADW_SOFTC *, ADW_CCB *));
static ADW_CCB *adw_get_ccb __P((ADW_SOFTC *, int));
static int adw_queue_ccb __P((ADW_SOFTC *, ADW_CCB *, int));

static int adw_scsi_cmd __P((struct scsi_xfer *));
static int adw_build_req __P((struct scsi_xfer *, ADW_CCB *, int));
static void adw_build_sglist __P((ADW_CCB *, ADW_SCSI_REQ_Q *, ADW_SG_BLOCK *));
static void adwminphys __P((struct buf *));
static void adw_isr_callback __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));
static void adw_async_callback __P((ADW_SOFTC *, u_int8_t));

static void adw_print_info __P((ADW_SOFTC *, int));

static int adw_poll __P((ADW_SOFTC *, struct scsi_xfer *, int));
static void adw_timeout __P((void *));
static void adw_reset_bus __P((ADW_SOFTC *));
d125 1
a125 1
static void
d146 1
a146 1
static struct scsi_xfer *
d166 1
a166 1
static int
d212 1
a212 1
static int
d278 1
a278 1
static int
d304 1
a304 1
static void
d327 1
a327 1
static void
d336 1
a336 1
static int
d375 1
a375 1
static ADW_CCB *
d432 1
a432 1
static int
d621 1
a621 1
	sc->sc_adapter.scsi_minphys = adwminphys;
d637 2
a638 2
static void
adwminphys(bp)
d652 1
a652 1
static int
d777 1
a777 1
static int
d885 1
a885 1
static void
d966 1
a966 1
static int
d990 1
a990 1
static void
d1087 1
a1087 1
static void
d1115 1
a1115 1
static void
d1177 1
a1177 1
static void
d1364 1
a1364 1
static void
@


1.18
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.17 2001/04/11 04:05:15 krw Exp $ */
d224 4
a227 1
		       M_WAITOK);
@


1.17
log
@Update the adw driver to use the latest version of firmware (3.3f).

Move the microcode files to dev/microcode/adw/*.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.16 2001/02/22 17:17:32 krw Exp $ */
d222 3
a224 7
	sc->sc_control->carriers = malloc(sizeof(ADW_CARRIER) * ADW_MAX_CARRIER,
			M_DEVBUF, M_WAITOK);
	if(!sc->sc_control->carriers) {
		printf("%s: malloc() failed in allocating carrier structures\n",
		       sc->sc_dev.dv_xname);
		return (ENOMEM);
	}
@


1.16
log
@Typo police:

Replace last ADV/ASC/Adv, etc. uses with ADW/Adw as appropriate.

Delete comments about non-existant structure members,
correct references to existing structure members to use
correct structure names or typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.15 2001/02/20 00:52:58 krw Exp $ */
d63 1
a63 1
#include <dev/ic/adwmcode.h>
@


1.15
log
@Tone down the verbosity level slightly on the adw driver, print
negotiation results on one line, during boot polling only, in same
format as now used in siop.

Move one check for probe INQUIRY commands to poll loop rather than
checking every good I/O twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.14 2001/01/22 06:29:20 krw Exp $ */
d1172 1
a1172 1
 * Interrupt callback function for the Wide SCSI Adv Library.
d1363 1
a1363 1
 * adw_async_callback() - Adv Library asynchronous event callback function.
d1371 1
a1371 1
	case ADV_ASYNC_SCSI_BUS_RESET_DET:
d1376 1
a1376 1
	case ADV_ASYNC_RDMA_FAILURE:
d1386 1
a1386 1
	case ADV_HOST_SCSI_BUS_RESET:
d1393 1
a1393 1
	case ADV_ASYNC_CARRIER_READY_FAILURE:
@


1.14
log
@Initialize xs->stimeout, even when polling
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.13 2001/01/15 16:27:53 krw Exp $ */
d975 1
a975 1
	while (count) {
d977 5
a981 1
		if (xs->flags & ITSDONE)
d983 1
d1121 1
d1123 6
a1128 22
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t wdtr_able, wdtr_done, wdtr;
    	u_int16_t sdtr_able, sdtr_done, sdtr, period;
	static int wdtr_reneg = 0, sdtr_reneg = 0;

	if (tid == 0){
		wdtr_reneg = sdtr_reneg = 0;
	}

	printf("%s: target %d ", sc->sc_dev.dv_xname, tid);

	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, wdtr_able);
	if(wdtr_able & ADW_TID_TO_TIDMASK(tid)) {
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE, wdtr_done);
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_DEVICE_HSHK_CFG_TABLE +
			(2 * tid), wdtr);
		printf("using %d-bits wide, ", (wdtr & 0x8000)? 16 : 8);
		if((wdtr_done & ADW_TID_TO_TIDMASK(tid)) == 0)
			wdtr_reneg = 1;
	} else {
		printf("wide transfers disabled, ");
	}
d1130 26
a1155 25
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, sdtr_able);
	if(sdtr_able & ADW_TID_TO_TIDMASK(tid)) {
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE, sdtr_done);
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_DEVICE_HSHK_CFG_TABLE +
			(2 * tid), sdtr);
		sdtr &=  ~0x8000;
		if((sdtr & 0x1F) != 0) {
			if((sdtr & 0x1F00) == 0x1100){
				printf("80.0 MHz");
			} else if((sdtr & 0x1F00) == 0x1000){
				printf("40.0 MHz");
			} else {
				/* <= 20.0 MHz */
				period = (((sdtr >> 8) * 25) + 50)/4;
				if(period == 0) {
					/* Should never happen. */
					printf("? MHz");
				} else {
					printf("%d.%d MHz", 250/period,
						ADW_TENTHS(250, period));
				}
			}
			printf(" synchronous transfers\n");
		} else {
			printf("asynchronous transfers\n");
d1157 1
a1157 4
		if((sdtr_done & ADW_TID_TO_TIDMASK(tid)) == 0)
			sdtr_reneg = 1;
	} else {
		printf("synchronous transfers disabled\n");
d1160 1
a1160 6
	if(wdtr_reneg || sdtr_reneg) {
		printf("%s: target %d %s", sc->sc_dev.dv_xname, tid,
			(wdtr_reneg)? ((sdtr_reneg)? "wide/sync" : "wide") :
			((sdtr_reneg)? "sync" : "") );
		printf(" renegotiation pending before next command.\n");
	}
a1225 7
		/*
		 * XXX - is there no better way to handle the inquiries
		 *       generated during boot time probes?
		 */
		if ((scsiq->cdb[0] == INQUIRY) &&
		    (scsiq->target_lun == 0))
			adw_print_info(sc, scsiq->target_id);
@


1.13
log
@Use xs->stimeout instead of adding a struct timeout to ccb
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.12 2000/12/08 00:03:30 krw Exp $ */
d465 3
a467 2
		if ((ccb->xs->flags & SCSI_POLL) == 0) {
			timeout_set(&ccb->xs->stimeout, adw_timeout, ccb);
a468 1
		}
@


1.12
log
@This update should cause the adw driver to:

 - actually check the returned scsi_status value and act accordingly
   instead of ALWAYS returning XS_NOERROR

 - always return the scsi status value in xs->status for completed
   requests

 - no longer reference ccb->xs and ccb->dmamap_xfer if an 'unallocated'
   ccb is encountered

 - immediately remove the ccb adw_isr_callback is working on from the
   pending list, leaving it in limbo until it is put on the free list
   just before any return

 - 'freeze' a target only when a scsi_status indicating it is busy is
   encountered, and 'thaw' a target whenever a bus reset is done or a
   request completes

 - check done_status, host_status and scsi_status in that order as is
   done in the linux driver and was done here until very recently, which
   seems cleaner to me. But opinions may vary. The only behaviour change
   that should result is that done_status of QD_NO_STATUS no longer
   causes a check of host_status values, but is an error causing a
   XS_DRIVER_STUFFUP

 - produce a more general error message with actual values for
   host_status, scsi_status and done_status values, with references to
   adw(4) for more details on the error where appropriate (man page
   update coming)

 - take what seems like appropriate action for all known host_status,
   scsi_status and done_status values with more use of XS_RESET where
   appropriate

 - use adw_reset_bus() instead of AdwResetSCSIBus() in
   adw_async_callback() so pending requests are requeued and devices left
   unfrozen when this happens

 - print an error message with the code # when adw_async_callback is
   called with an unknown code.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.11 2000/11/10 04:24:50 krw Exp $ */
a365 1
	timeout_set( &ccb->to, adw_timeout, ccb );
d465 4
a468 2
		if ((ccb->xs->flags & SCSI_POLL) == 0)
			timeout_add(&ccb->to, (ccb->timeout * hz) / 1000);
d1008 1
a1008 1
		timeout_del( &ccb->to );
d1044 1
a1044 1
		timeout_add( &ccb->to, (ccb->timeout * hz) / 1000);
d1076 1
a1076 1
		timeout_add( &ccb->to, (ccb->timeout * hz) / 1000);
d1094 1
a1094 1
	        timeout_del( &ccb->to );
a1206 1
	timeout_del(&ccb->to);
d1218 1
@


1.11
log
@This fixes a problem that caused DMA errors from shortly before
2.7 through the released 2.8.

As NetBSD describes the problem:

   DMA failure still arise when AdvanSys U[2]W host adapters
   are used in conjunction with Intel 82443BX Host
   Bridge/Controller (rev. 0x03).

With a correct sg_cnt, scatter/gather lists with >1 element
no longer reference random(?) memory. Now the mystery
is why this didn't cause more problems on other chipsets.

Installs of 2.7 and 2.8 to a drive on an adw bus now work even
if the motherboard uses the 82443BX.

So many problems from one character ...
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.10 2000/10/15 12:22:15 krw Exp $ */
a672 1

d1090 1
a1090 1
	AdwResetSCSIBus(sc);
d1097 2
d1100 1
d1199 1
a1199 1
	bus_dma_tag_t   dmat = sc->sc_dmat;
d1206 2
d1209 7
a1215 1
	timeout_del( &ccb->to );
d1223 1
d1226 2
a1227 2
			 (xs->flags & SCSI_DATA_IN) ?
			 BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
a1230 6
	if ((ccb->flags & CCB_ALLOC) == 0) {
		printf("%s: exiting ccb not allocated!\n", sc->sc_dev.dv_xname);
		Debugger();
		return;
	}

d1236 19
a1254 3
	if ((scsiq->host_status == QHSTA_NO_ERROR) &&
	   ((scsiq->done_status == QD_NO_ERROR) ||
	    (scsiq->done_status == QD_WITH_ERROR))) {
d1256 38
a1293 4
		case SCSI_STATUS_GOOD:
			if ((scsiq->cdb[0] == INQUIRY) &&
			    (scsiq->target_lun == 0)) {
				adw_print_info(sc, scsiq->target_id);
a1294 3
			xs->error = XS_NOERROR;
			xs->resid = scsiq->data_cnt;
			sc->sc_freeze_dev[scsiq->target_id] = 0;
d1296 1
a1296 19

		case SCSI_STATUS_CHECK_CONDITION:
		case SCSI_STATUS_CMD_TERMINATED:
			s1 = &ccb->scsi_sense;
			s2 = &xs->sense;
			*s2 = *s1;
			xs->error = XS_SENSE;
			sc->sc_freeze_dev[scsiq->target_id] = 1;
			break;

		default:
			xs->error = XS_BUSY;
			sc->sc_freeze_dev[scsiq->target_id] = 1;
			break;
		}
	} else if (scsiq->done_status == QD_ABORTED_BY_HOST) {
		xs->error = XS_DRIVER_STUFFUP;
	} else {
		switch (scsiq->host_status) {
d1301 1
d1304 4
a1307 6
		case QHSTA_M_DATA_OVER_RUN:
			printf("%s: Overrun/Overflow/Underflow condition\n",
				sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;

d1309 6
d1316 3
a1318 1
			printf("%s: Unexpected BUS free\n",sc->sc_dev.dv_xname);
d1322 6
d1329 1
a1330 17
			printf("%s: BUS Reset\n", sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case QHSTA_M_BUS_DEVICE_RESET:
			printf("%s: Device Reset\n", sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case QHSTA_M_QUEUE_ABORTED:
			printf("%s: Queue Aborted\n", sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case QHSTA_M_SXFR_SDMA_ERR:
		case QHSTA_M_SXFR_SXFR_PERR:
		case QHSTA_M_RDMA_PERR:
d1332 5
a1336 4
			 * DMA Error. This should *NEVER* happen!
			 *
			 * Lets try resetting the bus and reinitialize
			 * the host adapter.
d1338 3
a1340 3
			printf("%s: DMA Error. Resetting bus\n",
				sc->sc_dev.dv_xname);
			TAILQ_REMOVE(&sc->sc_pending_ccb, ccb, chain);
d1342 2
a1343 2
			xs->error = XS_BUSY;
			goto done;
d1345 1
a1345 33
		case QHSTA_M_WTM_TIMEOUT:
		case QHSTA_M_SXFR_WD_TMO:
			/* The SCSI bus hung in a phase */
			printf("%s: Watch Dog timer expired. Resetting bus\n",
				sc->sc_dev.dv_xname);
			TAILQ_REMOVE(&sc->sc_pending_ccb, ccb, chain);
			adw_reset_bus(sc);
			xs->error = XS_BUSY;
			goto done;

		case QHSTA_M_SXFR_XFR_PH_ERR:
			printf("%s: Transfer Error\n", sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case QHSTA_M_BAD_CMPL_STATUS_IN:
			/* No command complete after a status message */
			printf("%s: Bad Completion Status\n",
				sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case QHSTA_M_AUTO_REQ_SENSE_FAIL:
			printf("%s: Auto Sense Failed\n", sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case QHSTA_M_INVALID_DEVICE:
			printf("%s: Invalid Device\n", sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case QHSTA_M_NO_AUTO_REQ_SENSE:
d1347 4
a1350 2
			 * User didn't request sense, but we got a
			 * check condition.
d1352 5
a1356 4
			printf("%s: Unexpected Check Condition\n",
					sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;
d1358 3
a1360 4
		case QHSTA_M_SXFR_UNKNOWN_ERROR:
			printf("%s: Unknown Error\n", sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			break;
d1362 14
a1375 4
		default:
			panic("%s: Unhandled Host Status Error %x",
			      sc->sc_dev.dv_xname, scsiq->host_status);
		}
d1378 2
a1379 2
	TAILQ_REMOVE(&sc->sc_pending_ccb, ccb, chain);
done:	adw_free_ccb(sc, ccb);
d1406 1
a1406 1
		AdwResetSCSIBus(sc);
d1415 9
a1424 3
	case ADV_ASYNC_CARRIER_READY_FAILURE:
		/* Carrier Ready failure. */
	        /* Warning only - RISC too busy to realize it's been tickled */
d1426 1
a1427 1
#endif
d1430 2
@


1.10
log
@Reseting -> Resetting
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.9 2000/09/06 00:48:01 krw Exp $ */
d916 1
a916 1
				sg_block->sg_cnt = i + i;
@


1.10.2.1
log
@Pull in patch from current:
Fix (krw):
This fixes a problem that caused DMA errors from shortly before
2.7 through the released 2.8.

As NetBSD describes the problem:

   DMA failure still arise when AdvanSys U[2]W host adapters
   are used in conjunction with Intel 82443BX Host
   Bridge/Controller (rev. 0x03).

With a correct sg_cnt, scatter/gather lists with >1 element
no longer reference random(?) memory. Now the mystery
is why this didn't cause more problems on other chipsets.

Installs of 2.7 and 2.8 to a drive on an adw bus now work even
if the motherboard uses the 82443BX.

So many problems from one character ...
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.10 2000/10/15 12:22:15 krw Exp $ */
d916 1
a916 1
				sg_block->sg_cnt = i + 1;
@


1.9
log
@Remove #ifdef/#endif around various bits of INQUIRY response
information. Left over from old attempt to fit adw with U3W on
floppyxx.fs instead of floppyBxx.fs.

Puts 'sdx at ...' msgs back at the start of their own lines so
the drives can be found during (I)nstall or (U)pgrade!
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.8 2000/07/22 15:10:13 krw Exp $ */
d1306 1
a1306 1
			printf("%s: DMA Error. Reseting bus\n",
d1316 1
a1316 1
			printf("%s: Watch Dog timer expired. Reseting bus\n",
@


1.8
log
@sync to NetBSD:

   - remove #include <vm/vm_param.h>
        and #include <vm/pmap.h>
     as they are already included with
            #include <vm/vm.h>

   - more Adv -> Adw, ADV -> ADW adjustments & other
     minor formatting corrections

plus:

   - put 'Carrier Ready failure!' warning message inside
     #ifdef ADW_DEBUG/#endif as it appears under heavy load
     but is nothing but a reminder the card was too busy to
     notice a 'tickle' from the driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.7 2000/06/29 00:04:31 krw Exp $ */
a1112 1
#ifdef ADW_DEBUG
a1121 1
#endif
a1124 1
#ifdef ADW_DEBUG
a1174 1
#endif	
@


1.7
log
@Sync adw files with (almost) latest NetBSD versions:

adw.c     synched with v1.23 (from v1.14)
adw.h                  v1.9  (     v1.5 )
adwlib.c               v1.17 (     v1.7 )
adwlib.h               v1.13 (     v1.7 )
adwmcode.c             v1.5  (     v1.2 )
adwmcode.h             v1.5  (     v1.2 )

microcode for cards is updated to latest version,
loss of carrier problems are solved in a more
robust manner than before, lots of code cleanup.

first support for upcoming U3W cards added, as
a result of which the driver is now too large
for RAMDISK and has been moved to RAMDISKB.

Most of the work done by dante@@ NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.6 2000/04/29 21:05:32 krw Exp $ */
a57 2
#include <vm/vm_param.h>
#include <vm/pmap.h>
d1407 1
d1410 1
d1413 1
@


1.6
log
@add $ tag
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/* $NetBSD: adw.c,v 1.14 2000/02/12 19:19:42 thorpej Exp $	*/
d52 1
d65 1
a79 2
static int adw_create_carriers __P((ADW_SOFTC *));
static int adw_init_carrier __P((ADW_SOFTC *, ADW_CARRIER *));
d94 2
d98 1
d108 1
a108 1
/* the below structure is so we have a default dev struct for out link struct */
a117 4
#define ADW_ABORT_TIMEOUT       10000	/* time to wait for abort (mSec) */
#define ADW_WATCH_TIMEOUT       10000	/* time to wait for watchdog (mSec) */


d164 1
a164 1
/*                                Control Blocks routines                     */
d224 1
a224 1
	sc->sc_control->carriers = malloc(ADW_CARRIER_SIZE * ADW_MAX_CARRIER,
d227 3
a229 3
		printf("%s: malloc() failed in allocating carrier structures,"
		       " error = %d\n", sc->sc_dev.dv_xname, error);
		return (error);
d233 2
a234 2
			ADW_CARRIER_SIZE * ADW_MAX_CARRIER,
			NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d240 1
a240 1
			ADW_CARRIER_SIZE * ADW_MAX_CARRIER,
d252 2
a253 2
			ADW_CARRIER_SIZE * ADW_MAX_CARRIER, 1,
			ADW_CARRIER_SIZE * ADW_MAX_CARRIER, 0, BUS_DMA_NOWAIT,
d261 1
a261 1
			ADW_CARRIER_SIZE * ADW_MAX_CARRIER, NULL,
a267 10
	error = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE* ADW_MAX_CARRIER,
			1, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,
			0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
			&sc->sc_control->dmamap_xfer);
	if (error) {
		printf("%s: unable to create Carrier DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}

d272 3
a274 82
/*
 * Create a set of Carriers and add them to the free list.  Called once
 * by adw_init().  We return the number of Carriers successfully created.
 */
static int
adw_create_carriers(sc)
	ADW_SOFTC	*sc;
{
	ADW_CARRIER	*carr;
	u_int32_t	carr_next = NULL;
	int		i, error;

	for(i=0; i < ADW_MAX_CARRIER; i++) {
		carr = (ADW_CARRIER *)(((u_int8_t *)sc->sc_control->carriers) +
				(ADW_CARRIER_SIZE * i));
		if ((error = adw_init_carrier(sc, carr)) != 0) {
			printf("%s: unable to initialize carrier, error = %d\n",
			       sc->sc_dev.dv_xname, error);
			return (i);
		}
		carr->next_vpa = carr_next;
		carr_next = carr->carr_pa;
		carr->id = i;
	}
	sc->carr_freelist = carr;
	return (i);
}


static int
adw_init_carrier(sc, carr)
	ADW_SOFTC	*sc;
	ADW_CARRIER	*carr;
{
	u_int32_t	carr_pa;
	int		/*error, */hashnum;

	/*
         * Create the DMA map for all of the Carriers.
         */
/*	error = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE,
			1, ADW_CARRIER_SIZE,
			0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
			&carr->dmamap_xfer);
	if (error) {
		printf("%s: unable to create Carrier DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}
*/
	/*
	 * put in the phystokv hash table
	 * Never gets taken out.
	 */
	carr_pa = ADW_CARRIER_ADDR(sc, carr);
	carr->carr_pa = carr_pa;
	hashnum = CARRIER_HASH(carr_pa);
	carr->nexthash = sc->sc_carrhash[hashnum];
	sc->sc_carrhash[hashnum] = carr;

	return(0);
}


/*
 * Given a physical address, find the Carrier that it corresponds to.
 */
ADW_CARRIER *
adw_carrier_phys_kv(sc, carr_phys)
	ADW_SOFTC	*sc;
	u_int32_t	carr_phys;
{
	int hashnum = CARRIER_HASH(carr_phys);
	ADW_CARRIER *carr = sc->sc_carrhash[hashnum];

	while (carr) {
		if (carr->carr_pa == carr_phys)
			break;
		carr = carr->nexthash;
	}
	return (carr);
}
d368 1
d442 1
a442 1
	int		errcode;
d444 1
a444 1
	if(!retry)
d446 1
d450 1
a450 1
		errcode = AdvExeScsiQueue(sc, &ccb->scsiq);
d466 1
d469 1
a469 1
			timeout(adw_timeout, ccb, (ccb->timeout * hz) / 1000);
d477 1
a477 1
/*                           SCSI layer interfacing routines                  */
d499 1
a499 1
		AdvResetChip(sc->sc_iot, sc->sc_ioh);
d501 1
a501 3
		warn_code = (sc->chip_type == ADV_CHIP_ASC3550)?
				AdvInitFrom3550EEP(sc) :
				AdvInitFrom38C0800EEP(sc);
d503 1
a503 1
		if (warn_code & ASC_WARN_EEPROM_CHKSUM)
d507 1
a507 1
		if (warn_code & ASC_WARN_EEPROM_TERMINATION)
d516 1
a516 1
	return (0);
d529 1
d563 4
a566 1
	bzero(sc->sc_control->carriers, ADW_CARRIER_SIZE * ADW_MAX_CARRIER);
d568 8
a575 9
	i = adw_create_carriers(sc);
	if (i == 0) {
		printf("%s: unable to create Carriers\n",
		       sc->sc_dev.dv_xname);
		return; /* (ENOMEM) */ ;
	} else if (i != ADW_MAX_CARRIER) {
		printf("%s: WARNING: only %d of %d Carriers created\n",
		       sc->sc_dev.dv_xname, i, ADW_MAX_CARRIER);
	}
d577 4
d582 1
a582 8
	/*
	 * Initialize the ASC3550.
	 */
	error = (sc->chip_type == ADV_CHIP_ASC3550)?
			AdvInitAsc3550Driver(sc) :
			AdvInitAsc38C0800Driver(sc);
	switch (error) {
	case ASC_IERR_MCODE_CHKSUM:
d587 1
a587 1
	case ASC_IERR_ILLEGAL_CONNECTION:
d592 1
a592 1
	case ASC_IERR_REVERSED_CABLE:
d597 6
a602 1
	case ASC_IERR_SINGLE_END_DEVICE:
d608 2
a609 2
	case ASC_IERR_NO_CARRIER:
		panic("%s: no carrier",
d613 1
a613 1
	case ASC_WARN_BUSRESET_ERROR:
d671 5
d680 5
a755 1
			
d807 2
d810 4
a813 1
	bcopy(xs->cmd, &scsiqp->cdb, scsiqp->cdb_len = xs->cmdlen);
d821 1
a821 3
/*	scsiqp->sense_addr = ccb->hashkey +
	    offsetof(struct adw_ccb, scsi_sense);
*/	scsiqp->sense_len = sizeof(struct scsi_sense_data);
d934 5
d947 1
a947 1
	if(AdvISR(sc) != ADW_FALSE) {
a1002 4
	/*
         * If it has been through before, then a previous abort has failed,
         * don't try abort again, reset the bus instead.
         */
d1006 3
a1008 1
	 * Lets try resetting the bus!
d1010 1
d1012 35
a1046 3
		ccb->flags &= ~CCB_ABORTED;
		/* AdvResetSCSIBus() will call sbreset_callback() */
		AdvResetSCSIBus(sc);
d1049 3
a1051 1
	 * Abort the operation that has timed out
d1056 15
a1070 1
		/* ADW_ABORT_CCB() will implicitly call isr_callback() */
d1072 7
d1085 20
d1106 80
a1185 1
/*                           WIDE boards Interrupt callbacks                  */
d1190 1
a1190 1
 * adw_isr_callback() - Second Level Interrupt Handler called by AdvISR()
d1193 4
a1206 1
//	int		 s;
d1211 1
a1211 1
	untimeout(adw_timeout, ccb);
a1212 10
/*	if(ccb->flags & CCB_ABORTING) {
		printf("Retrying request\n");
		ccb->flags &= ~CCB_ABORTING;
		ccb->flags |= CCB_ABORTED;
		s = splbio();
		adw_queue_ccb(sc, ccb);
		splx(s);
		return;
	}
*/
d1225 1
d1231 1
a1231 8
	/*
	 * Check for an underrun condition.
	 */
	/*
	 * if (xs->request_bufflen != 0 && scsiqp->data_cnt != 0) {
	 * ASC_DBG1(1, "adw_isr_callback: underrun condition %lu bytes\n",
	 * scsiqp->data_cnt); underrun = ASC_TRUE; }
	 */
d1234 2
d1237 3
a1239 2
	switch (scsiq->done_status) {
	case QD_NO_ERROR:
d1241 5
a1245 1
		case QHSTA_NO_ERROR:
d1247 2
a1248 1
			xs->resid = 0;
d1250 10
d1261 77
a1337 1
			/* QHSTA error occurred. */
a1339 2
		}
		break;
d1341 3
a1343 24
	case QD_WITH_ERROR:
		switch (scsiq->host_status) {
		case QHSTA_NO_ERROR:
			switch(scsiq->scsi_status) {
			case SS_CHK_CONDITION:
			case SS_CMD_TERMINATED:
				s1 = &ccb->scsi_sense;
				s2 = &xs->sense;
				*s2 = *s1;
				xs->error = XS_SENSE;
				break;
			case SS_TARGET_BUSY:
			case SS_RSERV_CONFLICT:
			case SS_QUEUE_FULL:
				xs->error = XS_DRIVER_STUFFUP;
				break;
			case SS_CONDITION_MET:
			case SS_INTERMID:
			case SS_INTERMID_COND_MET:
				xs->error = XS_DRIVER_STUFFUP;
				break;
			case SS_GOOD:
				break;
			}
d1346 2
a1347 1
		case QHSTA_M_SEL_TIMEOUT:
d1351 7
a1357 2
		default:
			/* Some other QHSTA error occurred. */
a1359 2
		}
		break;
d1361 4
a1364 3
	case QD_ABORTED_BY_HOST:
		xs->error = XS_DRIVER_STUFFUP;
		break;
d1366 4
a1369 3
	default:
		xs->error = XS_DRIVER_STUFFUP;
		break;
d1372 2
a1373 1
	adw_free_ccb(sc, ccb);
d1380 1
a1380 1
 * adv_async_callback() - Adv Library asynchronous event callback function.
d1389 2
a1390 3
		/*
		 * The firmware detected a SCSI Bus reset.
		 */
d1396 1
a1396 2
		 * possibly the chip if it is unresponsive. Log the error
		 * with a unique code.
d1398 3
a1400 1
		AdvResetSCSIBus(sc);
d1404 9
a1412 4
               /*
                * Host generated SCSI bus reset occurred.
                */
              break;
@


1.6.2.1
log
@Pull in patch from current:
Fix (krw):
This fixes a problem that caused DMA errors from shortly before
2.7 through the released 2.8.

As NetBSD describes the problem:

   DMA failure still arise when AdvanSys U[2]W host adapters
   are used in conjunction with Intel 82443BX Host
   Bridge/Controller (rev. 0x03).

With a correct sg_cnt, scatter/gather lists with >1 element
no longer reference random(?) memory. Now the mystery
is why this didn't cause more problems on other chipsets.

Installs of 2.7 and 2.8 to a drive on an adw bus now work even
if the motherboard uses the 82443BX.

So many problems from one character ...
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.6 2000/04/29 21:05:32 krw Exp $ */
d990 1
a990 1
				sg_block->sg_cnt = i + 1;
@


1.5
log
@adw_intr should only claim adw interrupts. Two typos.
@
text
@d1 1
@


1.4
log
@If we got an xfer from our backlog queue, don't allow sleeping; we're in
interrupt context.  thorpej@@netbsd.org
@
text
@d304 1
a304 1
carr->id = i;
d1024 2
d1028 1
a1028 1
	return (1);
d1103 1
a1103 1
 * adw__isr_callback() - Second Level Interrupt Handler called by AdvISR()
@


1.3
log
@support new u2w cards; dante@@mclink.it, merged by kwesterback@@home.com
@
text
@d1 1
a1 1
/* $NetBSD: adw.c,v 1.13 2000/02/03 20:29:15 dante Exp $	 */
d87 1
a87 1
static int adw_build_req __P((struct scsi_xfer *, ADW_CCB *));
d744 2
a745 1
	int             s, fromqueue = 1, dontqueue = 0, retry = 0;
d756 1
d791 4
a794 1
	if ((ccb = adw_get_ccb(sc, xs->flags)) == NULL) {
d816 1
a816 1
	if (adw_build_req(xs, ccb)) {
d855 1
a855 1
adw_build_req(xs, ccb)
d858 1
d887 1
a887 1
	scsiqp->vsense_addr = & ccb->scsi_sense;
d905 1
a905 1
				(xs->flags & SCSI_NOSLEEP) ?
d912 1
a912 1
				(xs->flags & SCSI_NOSLEEP) ?
@


1.3.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/* $NetBSD: adw.c,v 1.14 2000/02/12 19:19:42 thorpej Exp $	*/
d87 1
a87 1
static int adw_build_req __P((struct scsi_xfer *, ADW_CCB *, int));
d744 1
a744 2
	int             s, fromqueue = 1, dontqueue = 0, nowait = 0, retry = 0;
	int		flags;
a754 1
		nowait = 1;
d789 1
a789 4
	flags = xs->flags;
	if (nowait)
		flags |= SCSI_NOSLEEP;
	if ((ccb = adw_get_ccb(sc, flags)) == NULL) {
d811 1
a811 1
	if (adw_build_req(xs, ccb, flags)) {
d850 1
a850 1
adw_build_req(xs, ccb, flags)
a852 1
	int		flags;
d881 1
a881 1
	scsiqp->vsense_addr = &ccb->scsi_sense;
d899 1
a899 1
				(flags & SCSI_NOSLEEP) ?
d906 1
a906 1
				(flags & SCSI_NOSLEEP) ?
@


1.3.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: adw.c,v 1.17 2001/04/11 04:05:15 krw Exp $ */
/* $NetBSD: adw.c,v 1.23 2000/05/27 18:24:50 dante Exp $	 */
a50 1
#include <sys/timeout.h>
d56 2
a62 1
#include <dev/microcode/adw/adwmcode.h>
d77 2
a92 2
static void adw_print_info __P((ADW_SOFTC *, int));

a94 1
static void adw_reset_bus __P((ADW_SOFTC *));
d104 1
a104 1
/* the below structure is so we have a default dev struct for our link struct */
d114 4
d164 1
a164 1
/*                       DMA Mapping for Control Blocks                       */
d224 1
a224 1
	sc->sc_control->carriers = malloc(sizeof(ADW_CARRIER) * ADW_MAX_CARRIER,
d227 3
a229 3
		printf("%s: malloc() failed in allocating carrier structures\n",
		       sc->sc_dev.dv_xname);
		return (ENOMEM);
d233 2
a234 2
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER,
			0x10, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d240 1
a240 1
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER,
d252 2
a253 2
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER, 1,
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER, 0,BUS_DMA_NOWAIT,
d261 1
a261 1
			sizeof(ADW_CARRIER) * ADW_MAX_CARRIER, NULL,
d268 10
d282 82
a363 3
/******************************************************************************/
/*                           Control Blocks routines                          */
/******************************************************************************/
d530 1
a530 1
	int		errcode = ADW_SUCCESS;
d532 1
a532 1
	if(!retry) {
a533 1
	}
d537 1
a537 1
		errcode = AdwExeScsiQueue(sc, &ccb->scsiq);
a552 1
		TAILQ_INSERT_TAIL(&sc->sc_pending_ccb, ccb, chain);
a553 2
		/* ALWAYS initialize stimeout, lest it contain garbage! */
		timeout_set(&ccb->xs->stimeout, adw_timeout, ccb);
d555 1
a555 1
			timeout_add(&ccb->xs->stimeout, (ccb->timeout * hz) / 1000);
d563 1
a563 1
/*                       SCSI layer interfacing routines                      */
d585 1
a585 1
		AdwResetChip(sc->sc_iot, sc->sc_ioh);
d587 3
a589 1
		warn_code = AdwInitFromEEPROM(sc);
d591 1
a591 1
		if (warn_code & ADW_WARN_EEPROM_CHKSUM)
d595 1
a595 1
		if (warn_code & ADW_WARN_EEPROM_TERMINATION)
d604 1
a604 1
	return 0;
a616 1
	TAILQ_INIT(&sc->sc_pending_ccb);
d650 12
a661 4
	/*
	 * Zero's the freeze_device status
	 */
	 bzero(sc->sc_freeze_dev, sizeof(sc->sc_freeze_dev));
d664 1
a664 1
	 * Initialize the adapter
d666 5
a670 12
	switch (AdwInitDriver(sc)) {
	case ADW_IERR_BIST_PRE_TEST:
		panic("%s: BIST pre-test error",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_BIST_RAM_TEST:
		panic("%s: BIST RAM test error",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_MCODE_CHKSUM:
d675 1
a675 1
	case ADW_IERR_ILLEGAL_CONNECTION:
d680 1
a680 1
	case ADW_IERR_REVERSED_CABLE:
d685 1
a685 6
	case ADW_IERR_HVD_DEVICE:
		panic("%s: HVD attached to LVD connector",
		      sc->sc_dev.dv_xname);
		break;

	case ADW_IERR_SINGLE_END_DEVICE:
d691 2
a692 2
	case ADW_IERR_NO_CARRIER:
		panic("%s: unable to create Carriers",
d696 1
a696 1
	case ADW_WARN_BUSRESET_ERROR:
a753 4
 		if(sc->sc_freeze_dev[xs->sc_link->target]) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}
a757 5
 		if(sc->sc_freeze_dev[xs->sc_link->target]) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
d829 1
a880 2
	 * For wide  boards a CDB length maximum of 16 bytes
	 * is supported.
d882 1
a882 4
	bcopy(xs->cmd, &scsiqp->cdb, ((scsiqp->cdb_len = xs->cmdlen) <= 12)?
			xs->cmdlen : 12 );
	if(xs->cmdlen > 12)
		bcopy(&(xs->cmd[12]),  &scsiqp->cdb16, xs->cmdlen - 12);
d890 3
a892 1
	scsiqp->sense_len = sizeof(struct scsi_sense_data);
d989 1
a989 1
				sg_block->sg_cnt = i + 1;
a1004 5
/******************************************************************************/
/*                       Interrupts and TimeOut routines                      */
/******************************************************************************/


d1013 1
a1013 1
	if(AdwISR(sc) != ADW_FALSE) {
a1023 2

		return (1);
d1026 1
a1026 1
	return (0);
d1041 1
a1041 1
	while (count > 0) {
d1043 1
a1043 5
		if (xs->flags & ITSDONE) {
			if ((xs->cmd->opcode == INQUIRY)
			    && (xs->sc_link->lun == 0)
			    && (xs->error == XS_NOERROR))
				adw_print_info(sc, xs->sc_link->target);
a1044 1
		}
d1067 4
d1074 1
a1074 3
	 *
	 * No more opportunities. Lets try resetting the bus and
	 * reinitialize the host adapter.
a1075 1
		timeout_del(&xs->stimeout);
d1077 3
a1079 35
		adw_reset_bus(sc);
		splx(s);
		return;
	} else if (ccb->flags & CCB_ABORTING) {
	/*
	 * Abort the operation that has timed out.
	 *
	 * Second opportunity.
	 */
		printf("\n");
		xs->error = XS_TIMEOUT;
		ccb->flags |= CCB_ABORTED;
#if 0
		/*
		 * - XXX - 3.3a microcode is BROKEN!!!
		 *
		 * We cannot abort a CCB, so we can only hope the command
		 * get completed before the next timeout, otherwise a
		 * Bus Reset will arrive inexorably.
		 */
		/*
		 * ADW_ABORT_CCB() makes the board to generate an interrupt
		 *
		 * - XXX - The above assertion MUST be verified (and this
		 *         code changed as well [callout_*()]), when the
		 *         ADW_ABORT_CCB will be working again
		 */
		ADW_ABORT_CCB(sc, ccb);
#endif
		/*
		 * waiting for multishot callout_reset() let's restart it
		 * by hand so the next time a timeout event will occour
		 * we will reset the bus.
		 */
		timeout_add(&xs->stimeout, (ccb->timeout * hz) / 1000);
d1082 1
a1082 3
	 * Abort the operation that has timed out.
	 *
	 * First opportunity.
d1087 1
a1087 15
#if 0
		/*
		 * - XXX - 3.3a microcode is BROKEN!!!
		 *
		 * We cannot abort a CCB, so we can only hope the command
		 * get completed before the next 2 timeout, otherwise a
		 * Bus Reset will arrive inexorably.
		 */
		/*
		 * ADW_ABORT_CCB() makes the board to generate an interrupt
		 *
		 * - XXX - The above assertion MUST be verified (and this
		 *         code changed as well [callout_*()]), when the
		 *         ADW_ABORT_CCB will be working again
		 */
a1088 7
#endif
		/*
		 * waiting for multishot callout_reset() let's restart it
		 * by hand so to give a second opportunity to the command
		 * which timed-out.
		 */
		timeout_add(&xs->stimeout, (ccb->timeout * hz) / 1000);
a1094 23
static void
adw_reset_bus(sc) 
	ADW_SOFTC		*sc;
{
	ADW_CCB	*ccb;
	int	 s;

	s = splbio();
	AdwResetSCSIBus(sc); /* XXX - should check return value? */
	while((ccb = TAILQ_LAST(&sc->sc_pending_ccb,
			adw_pending_ccb)) != NULL) {
	        timeout_del(&ccb->xs->stimeout);
		TAILQ_REMOVE(&sc->sc_pending_ccb, ccb, chain);
		TAILQ_INSERT_HEAD(&sc->sc_waiting_ccb, ccb, chain);
	}

	bzero(sc->sc_freeze_dev, sizeof(sc->sc_freeze_dev));
	adw_queue_ccb(sc, TAILQ_FIRST(&sc->sc_waiting_ccb), 1);

	splx(s);
}


d1096 1
a1096 54
/*              Host Adapter and Peripherals Information Routines             */
/******************************************************************************/


static void
adw_print_info(sc, tid)
	ADW_SOFTC	*sc;
	int		 tid;
{
	bus_space_handle_t ioh = sc->sc_ioh;
	bus_space_tag_t iot = sc->sc_iot;
	u_int16_t hshk_cfg, able_mask, period = 0;

	/* hshk/HSHK means 'handskake' */

	ADW_READ_WORD_LRAM(iot, ioh,
	    ADW_MC_DEVICE_HSHK_CFG_TABLE + (2 * tid), hshk_cfg);

	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, able_mask);
	if ((able_mask & ADW_TID_TO_TIDMASK(tid)) == 0)
		hshk_cfg &= ~HSHK_CFG_WIDE_XFR;

	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, able_mask);
	if ((able_mask & ADW_TID_TO_TIDMASK(tid)) == 0)
		hshk_cfg &= ~HSHK_CFG_OFFSET;

	printf("%s: target %d using %d bit ", sc->sc_dev.dv_xname, tid,
	    (hshk_cfg & HSHK_CFG_WIDE_XFR) ? 16 : 8);

	if ((hshk_cfg & HSHK_CFG_OFFSET) == 0)
		printf("async ");
	else {
		period = (hshk_cfg & 0x1f00) >> 8;
		switch (period) {
		case 0x11: 
			printf("80.0 ");
			break;
		case 0x10:
			printf("40.0 ");
			break;
		default:
			period = (period * 25) + 50;
			printf("%d.%d ", 1000/period, ADW_TENTHS(1000, period));
			break;
		}
		printf("MHz %d REQ/ACK offset ", hshk_cfg & HSHK_CFG_OFFSET);
	}

	printf("xfers\n");
}	


/******************************************************************************/
/*                        WIDE boards Interrupt callbacks                     */
d1101 1
a1101 3
 * adw_isr_callback() - Second Level Interrupt Handler called by AdwISR()
 *
 * Interrupt callback function for the Wide SCSI Adw Library.
d1103 1
a1103 3
 * Notice:
 * Interrupts are disabled by the caller (AdwISR() function), and will be
 * enabled at the end of the caller.
d1110 1
a1110 1
	bus_dma_tag_t   dmat;
d1114 1
a1117 1
	TAILQ_REMOVE(&sc->sc_pending_ccb, ccb, chain);
d1119 9
a1127 5
	if ((ccb->flags & CCB_ALLOC) == 0) {
		printf("%s: unallocated ccb found on pending list!\n",
		    sc->sc_dev.dv_xname);
		Debugger();
		adw_free_ccb(sc, ccb);
d1130 1
a1130 1

a1131 1
	timeout_del(&xs->stimeout);
a1136 1
	dmat = sc->sc_dmat;
d1139 2
a1140 2
		    (xs->flags & SCSI_DATA_IN) ?
		        BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
d1143 13
a1155 1

a1157 2
	 * 'host_status' conatins the host adapter status.
	 * 'scsi_status' contains the scsi peripheral status.
a1158 4

	sc->sc_freeze_dev[scsiq->target_id] = 0;
	xs->status = scsiq->scsi_status;

d1160 11
a1170 4
	case QD_NO_ERROR: /* (scsi_status == 0) && (host_status == 0) */
NO_ERROR:
		xs->resid = scsiq->data_cnt;
		xs->error = XS_NOERROR;
d1176 3
a1178 18
			switch (scsiq->scsi_status) {
			case SCSI_STATUS_CONDITION_MET:
			case SCSI_STATUS_INTERMID:
			case SCSI_STATUS_INTERMID_COND_MET:
				/*
				 * These non-zero status values are 
				 * not really error conditions.
				 *
				 * XXX - would it be too paranoid to 
				 *       add SCSI_STATUS_GOOD here in
				 *       case the docs are wrong re
				 *       QD_NO_ERROR?
				 */
				goto NO_ERROR;

			case SCSI_STATUS_CHECK_CONDITION:
			case SCSI_STATUS_CMD_TERMINATED:
			case SCSI_STATUS_ACA_ACTIVE:
d1184 4
a1187 6

			case SCSI_STATUS_TARGET_BUSY:
			case SCSI_STATUS_QUEUE_FULL:
			case SCSI_STATUS_RSERV_CONFLICT:
				sc->sc_freeze_dev[scsiq->target_id] = 1;
				xs->error = XS_BUSY;
d1189 3
a1191 5
		
			default: /* scsiq->scsi_status value */
				printf("%s: bad scsi_status: 0x%02x.\n"
				    ,sc->sc_dev.dv_xname
				    ,scsiq->scsi_status);
d1194 2
d1198 1
a1198 1
		
d1200 1
a1200 1
			xs->error = XS_SELTIMEOUT;
d1203 2
a1204 18
		case QHSTA_M_DIRECTION_ERR:
		case QHSTA_M_SXFR_OFF_UFLW:
		case QHSTA_M_SXFR_OFF_OFLW:
		case QHSTA_M_SXFR_XFR_OFLW:
		case QHSTA_M_QUEUE_ABORTED:
		case QHSTA_M_INVALID_DEVICE:
		case QHSTA_M_SGBACKUP_ERROR:
		case QHSTA_M_SXFR_DESELECTED:
		case QHSTA_M_SXFR_XFR_PH_ERR:
		case QHSTA_M_BUS_DEVICE_RESET:
		case QHSTA_M_NO_AUTO_REQ_SENSE:
		case QHSTA_M_BAD_CMPL_STATUS_IN:
		case QHSTA_M_SXFR_UNKNOWN_ERROR:
		case QHSTA_M_AUTO_REQ_SENSE_FAIL:
		case QHSTA_M_UNEXPECTED_BUS_FREE:
			printf("%s: host adapter error 0x%02x."
			       " See adw(4).\n"
			    ,sc->sc_dev.dv_xname, scsiq->host_status);
a1206 34

		case QHSTA_M_RDMA_PERR:
		case QHSTA_M_SXFR_WD_TMO:
		case QHSTA_M_WTM_TIMEOUT:
		case QHSTA_M_FROZEN_TIDQ:
		case QHSTA_M_SXFR_SDMA_ERR:
		case QHSTA_M_SXFR_SXFR_PERR:
		case QHSTA_M_SCSI_BUS_RESET:
		case QHSTA_M_DIRECTION_ERR_HUNG:
		case QHSTA_M_SCSI_BUS_RESET_UNSOL:
			/*
			 * XXX - are all these cases really asking
			 *       for a card reset? _BUS_RESET and
			 *       _BUS_RESET_UNSOL added just to make
			 *       sure the pending queue is cleared out
			 *       in case card has lost track of them.
			 */
			printf("%s: host adapter error 0x%02x,"
			       " resetting bus. See adw(4).\n"
			    ,sc->sc_dev.dv_xname, scsiq->host_status);
			adw_reset_bus(sc);
			xs->error = XS_RESET;
			break;
			
		default: /* scsiq->host_status value */
			/*
			 * XXX - is a panic really appropriate here? If
			 *       not, would it be better to make the 
			 *       XS_DRIVER_STUFFUP case above the 
			 *       default behaviour? Or XS_RESET?
			 */
			panic("%s: bad host_status: 0x%02x"
			    ,sc->sc_dev.dv_xname, scsiq->host_status);
			break;      
d1214 1
a1214 12
	default: /* scsiq->done_status value */
		/*
		 * XXX - would QD_NO_STATUS really mean the I/O is not
		 *       done? and would that mean it should somehow be
		 *       put back as a pending I/O?
		 */
		printf("%s: bad done_status: 0x%02x"
		       " (host_status: 0x%02x, scsi_status: 0x%02x)\n"
		    ,sc->sc_dev.dv_xname
		    ,scsiq->done_status
		    ,scsiq->host_status
		    ,scsiq->scsi_status);
a1219 1

d1226 1
a1226 1
 * adw_async_callback() - Adw Library asynchronous event callback function.
d1234 4
a1237 3
	case ADW_ASYNC_SCSI_BUS_RESET_DET:
		/* The firmware detected a SCSI Bus reset. */
		printf("%s: SCSI Bus reset detected\n", sc->sc_dev.dv_xname);
d1240 1
a1240 1
	case ADW_ASYNC_RDMA_FAILURE:
d1243 2
a1244 1
		 * possibly the chip if it is unresponsive.
d1246 1
a1246 3
		printf("%s: RDMA failure. Resetting the SCSI Bus and"
				" the adapter\n", sc->sc_dev.dv_xname);
		adw_reset_bus(sc);
d1249 5
a1253 19
	case ADW_HOST_SCSI_BUS_RESET:
		/* Host generated SCSI bus reset occurred. */
		printf("%s: Host generated SCSI bus reset occurred\n",
				sc->sc_dev.dv_xname);
		break;


	case ADW_ASYNC_CARRIER_READY_FAILURE:
		/* 
		 * Carrier Ready failure.
	         *
		 * A warning only - RISC too busy to realize it's been 
		 * tickled. Occurs in normal operation under heavy
		 * load, so a message is printed only when ADW_DEBUG'ing
		 */
#ifdef ADW_DEBUG
		printf("%s: Carrier Ready failure!\n", sc->sc_dev.dv_xname);
#endif
		break;
a1255 2
	        printf("%s: Unknown Async callback code (ignored): 0x%02x\n"
		       ,sc->sc_dev.dv_xname );
@


1.3.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.3.2.2 2001/05/14 22:23:21 niklas Exp $ */
d222 5
a226 4
	sc->sc_control->carriers = 
		malloc(sizeof(ADW_CARRIER) * ADW_MAX_CARRIER, M_DEVBUF, 
		       M_NOWAIT);
	if (sc->sc_control->carriers == NULL)
d228 1
a228 1

@


1.3.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.c,v 1.3.2.3 2001/07/04 10:40:25 niklas Exp $ */
d73 2
a74 2
void adw_enqueue __P((ADW_SOFTC *, struct scsi_xfer *, int));
struct scsi_xfer *adw_dequeue __P((ADW_SOFTC *));
d76 21
a96 21
int adw_alloc_controls __P((ADW_SOFTC *));
int adw_alloc_carriers __P((ADW_SOFTC *));
int adw_create_ccbs __P((ADW_SOFTC *, ADW_CCB *, int));
void adw_free_ccb __P((ADW_SOFTC *, ADW_CCB *));
void adw_reset_ccb __P((ADW_CCB *));
int adw_init_ccb __P((ADW_SOFTC *, ADW_CCB *));
ADW_CCB *adw_get_ccb __P((ADW_SOFTC *, int));
int adw_queue_ccb __P((ADW_SOFTC *, ADW_CCB *, int));

int adw_scsi_cmd __P((struct scsi_xfer *));
int adw_build_req __P((struct scsi_xfer *, ADW_CCB *, int));
void adw_build_sglist __P((ADW_CCB *, ADW_SCSI_REQ_Q *, ADW_SG_BLOCK *));
void adw_minphys __P((struct buf *));
void adw_isr_callback __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));
void adw_async_callback __P((ADW_SOFTC *, u_int8_t));

void adw_print_info __P((ADW_SOFTC *, int));

int adw_poll __P((ADW_SOFTC *, struct scsi_xfer *, int));
void adw_timeout __P((void *));
void adw_reset_bus __P((ADW_SOFTC *));
d125 1
a125 1
void
d146 1
a146 1
struct scsi_xfer *
d166 1
a166 1
int
d212 1
a212 1
int
d278 1
a278 1
int
d304 1
a304 1
void
d327 1
a327 1
void
d336 1
a336 1
int
d375 1
a375 1
ADW_CCB *
d432 1
a432 1
int
d621 1
a621 1
	sc->sc_adapter.scsi_minphys = adw_minphys;
d637 2
a638 2
void
adw_minphys(bp)
d652 1
a652 1
int
d777 1
a777 1
int
d857 3
a859 4
		adw_bus_dmamap_sync(dmat, ccb->dmamap_xfer,
		    0, ccb->dmamap_xfer->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
d885 1
a885 1
void
d966 1
a966 1
int
d990 1
a990 1
void
d1087 1
a1087 1
void
d1115 1
a1115 1
void
d1177 1
a1177 1
void
d1208 3
a1210 4
		adw_bus_dmamap_sync(dmat, ccb->dmamap_xfer,
		    0, ccb->dmamap_xfer->dm_mapsize,
		    ((xs->flags & SCSI_DATA_IN) ?
		        BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
d1364 1
a1364 1
void
d1406 2
a1407 2
	        printf("%s: Unknown Async callback code (ignored): 0x%02x\n",
		    sc->sc_dev.dv_xname, code);
@


1.3.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d57 1
a57 1
#include <uvm/uvm_extern.h>
d857 1
a857 1
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
d1209 1
a1209 1
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
d1236 3
a1238 3
			case SCSI_COND_MET:
			case SCSI_INTERM:
			case SCSI_INTERM_COND_MET:
d1244 1
a1244 1
				 *       add SCSI_OK here in
d1250 3
a1252 3
			case SCSI_CHECK:
			case SCSI_TERMINATED:
			case SCSI_ACA_ACTIVE:
d1259 3
a1261 3
			case SCSI_BUSY:
			case SCSI_QUEUE_FULL:
			case SCSI_RESV_CONFLICT:
@


1.3.2.6
log
@Merge in -current from about a week ago
@
text
@d73 2
a74 2
void adw_enqueue(ADW_SOFTC *, struct scsi_xfer *, int);
struct scsi_xfer *adw_dequeue(ADW_SOFTC *);
d76 8
a83 8
int adw_alloc_controls(ADW_SOFTC *);
int adw_alloc_carriers(ADW_SOFTC *);
int adw_create_ccbs(ADW_SOFTC *, ADW_CCB *, int);
void adw_free_ccb(ADW_SOFTC *, ADW_CCB *);
void adw_reset_ccb(ADW_CCB *);
int adw_init_ccb(ADW_SOFTC *, ADW_CCB *);
ADW_CCB *adw_get_ccb(ADW_SOFTC *, int);
int adw_queue_ccb(ADW_SOFTC *, ADW_CCB *, int);
d85 6
a90 6
int adw_scsi_cmd(struct scsi_xfer *);
int adw_build_req(struct scsi_xfer *, ADW_CCB *, int);
void adw_build_sglist(ADW_CCB *, ADW_SCSI_REQ_Q *, ADW_SG_BLOCK *);
void adw_minphys(struct buf *);
void adw_isr_callback(ADW_SOFTC *, ADW_SCSI_REQ_Q *);
void adw_async_callback(ADW_SOFTC *, u_int8_t);
d92 1
a92 1
void adw_print_info(ADW_SOFTC *, int);
d94 3
a96 3
int adw_poll(ADW_SOFTC *, struct scsi_xfer *, int);
void adw_timeout(void *);
void adw_reset_bus(ADW_SOFTC *);
@


1.3.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d57 2
d1046 1
a1046 1
		 * by hand so the next time a timeout event will occur
d1218 1
a1218 1
	 * 'host_status' contains the host adapter status.
@


1.2
log
@new bus_dma API, match it
@
text
@d1 1
a1 2
/*	$OpenBSD: adw.c,v 1.1 1998/11/17 06:14:58 downsj Exp $	*/
/* $NetBSD: adw.c,v 1.3 1998/10/10 00:28:33 thorpej Exp $	 */
d6 1
a6 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d66 1
a66 1
#define	Debugger()	panic("should call debugger here (adv.c)")
d75 4
a78 1
static int adw_alloc_ccbs __P((ADW_SOFTC *));
d84 1
a84 2
static void adw_queue_ccb __P((ADW_SOFTC *, ADW_CCB *));
static void adw_start_ccbs __P((ADW_SOFTC *));
d88 1
a88 1
static void adw_build_sglist __P((ADW_CCB *, ADW_SCSI_REQ_Q *));
d90 2
a91 1
static void adw_wide_isr_callback __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));
a94 1
static void adw_watchdog __P((void *));
a103 10

struct scsi_adapter adw_switch =
{
	adw_scsi_cmd,		/* called to start/enqueue a SCSI command */
	adwminphys,		/* to limit the transfer to max device can do */
	0,
	0,
};


d119 1
a119 1
/* scsi_xfer queue routines                      */
a162 1

d164 1
a164 1
/* Control Blocks routines                        */
d169 1
a169 1
adw_alloc_ccbs(sc)
d176 1
a176 1
         * Allocate the control blocks.
d191 1
d209 69
d283 84
a378 1
	bzero(ccbstore, sizeof(ADW_CCB) * count);
d433 1
a433 1
	int             error;
d443 1
a443 1
		printf("%s: unable to create DMA map, error = %d\n",
d447 10
d502 1
a502 1
 * Queue a CCB to be sent to the controller, and send it if possible.
d504 4
a507 4
static void
adw_queue_ccb(sc, ccb)
	ADW_SOFTC      *sc;
	ADW_CCB        *ccb;
d509 2
d512 6
a517 3
	TAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);

	adw_start_ccbs(sc);
d521 5
a525 2
static void
adw_start_ccbs(sc)
d527 2
d530 4
a533 1
	ADW_CCB        *ccb;
a535 2
		if (ccb->flags & CCB_WATCHDOG)
			untimeout(adw_watchdog, ccb);
d537 3
a539 4
		if (AdvExeScsiQueue(sc, &ccb->scsiq) == ADW_BUSY) {
			ccb->flags |= CCB_WATCHDOG;
			timeout(adw_watchdog, ccb,
				(ADW_WATCH_TIMEOUT * hz) / 1000);
d541 9
d551 1
d557 2
d563 1
a563 1
/* SCSI layer interfacing routines                    */
d587 4
a590 1
		warn_code = AdvInitFromEEP(sc);
a598 7

		/*
		 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
		 * Resets should be performed.
		 */
		if (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
			AdvResetSCSIBus(sc);
d601 2
a602 1
	sc->isr_callback = (ulong) adw_wide_isr_callback;
d615 48
d666 4
a669 1
	switch (AdvInitAsc3550Driver(sc)) {
d690 10
d702 5
d713 1
a713 1
	sc->sc_link.adapter = &adw_switch;
d716 1
a716 14
	sc->sc_link.adapter_buswidth = ADW_MAX_TID;


	TAILQ_INIT(&sc->sc_free_ccb);
	TAILQ_INIT(&sc->sc_waiting_ccb);
	LIST_INIT(&sc->sc_queue);


	/*
         * Allocate the Control Blocks.
         */
	error = adw_alloc_ccbs(sc);
	if (error)
		return; /* (error) */ ;
a717 13
	/*
	 * Create and initialize the Control Blocks.
	 */
	i = adw_create_ccbs(sc, sc->sc_control->ccbs, ADW_MAX_CCB);
	if (i == 0) {
		printf("%s: unable to create control blocks\n",
		       sc->sc_dev.dv_xname);
		return; /* (ENOMEM) */ ;
	} else if (i != ADW_MAX_CCB) {
		printf("%s: WARNING: only %d of %d control blocks"
		       " created\n",
		       sc->sc_dev.dv_xname, i, ADW_MAX_CCB);
	}
d744 1
a744 1
	int             s, fromqueue = 1, dontqueue = 0;
d812 1
d814 1
a814 1
		adw_queue_ccb(sc, ccb);
d817 10
d864 2
a865 1
	 * Set the ADW_SCSI_REQ_Q 'ccb_ptr' to point to the CCB structure.
d867 1
a867 2
	scsiqp->ccb_ptr = (ulong) ccb;

d881 1
a881 1
	scsiqp->vsense_addr = (ulong) & ccb->scsi_sense;
d883 4
a886 2
		ADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsi_sense);
	scsiqp->sense_len = sizeof(struct scsi_sense_data);
d899 2
a900 2
				(xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT :
					BUS_DMA_WAITOK);
d902 1
a902 1
#endif				/* TFS */
d906 2
a907 2
				(xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT :
					BUS_DMA_WAITOK);
d926 2
a927 2
			  (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
				BUS_DMASYNC_PREWRITE);
d933 1
a933 1
		scsiqp->vdata_addr = (ulong) xs->data;
d935 2
a936 4
		scsiqp->sg_list_ptr = &ccb->sg_block[0];
		bzero(scsiqp->sg_list_ptr,
				sizeof(ADW_SG_BLOCK) * ADW_NUM_SG_BLOCK);
		adw_build_sglist(ccb, scsiqp);
a943 1
		scsiqp->sg_list_ptr = NULL;
d954 1
a954 1
adw_build_sglist(ccb, scsiqp)
d957 1
d959 3
a961 6
	struct scsi_xfer *xs = ccb->xs;
	ADW_SOFTC      *sc = xs->sc_link->adapter_softc;
	ADW_SG_BLOCK   *sg_block = scsiqp->sg_list_ptr;
	ulong           sg_block_next_addr;	/* block and its next */
	ulong           sg_block_physical_addr;
	int             sg_block_index, i;	/* how many SG entries */
d966 3
a968 3
	sg_block_next_addr = (ulong) sg_block;	/* allow math operation */
	sg_block_physical_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +
		ADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, sg_block[0]);
a975 1
	sg_block_index = 0;
a976 1
		sg_block->first_entry_no = sg_block_index;
d983 1
a983 2
				scsiqp->sg_entry_cnt = sg_block_index + i + 1;
				sg_block->last_entry_no = sg_block_index + i;
d992 2
a993 3
		sg_block_index += NO_OF_SG_PER_BLOCK;
		sg_block->sg_ptr = (ADW_SG_BLOCK *) sg_block_physical_addr;
		sg_block->last_entry_no = sg_block_index - 1;
d995 1
a995 2
	}
	while (1);
d1007 12
a1018 12
	AdvISR(sc);

	/*
         * If there are queue entries in the software queue, try to
         * run the first one.  We should be more or less guaranteed
         * to succeed, since we just freed a CCB.
         *
         * NOTE: adw_scsi_cmd() relies on our calling it with
         * the first entry in the queue.
         */
	if ((xs = sc->sc_queue.lh_first) != NULL)
		(void) adw_scsi_cmd(xs);
d1065 8
a1072 4
	if (ccb->flags & CCB_ABORT) {
		/* abort timed out */
		printf(" AGAIN. Resetting Bus\n");
		/* Lets try resetting the bus! */
a1073 2
		ccb->timeout = ADW_ABORT_TIMEOUT;
		adw_queue_ccb(sc, ccb);
d1075 3
a1077 1
		/* abort the operation that has timed out */
d1079 3
a1082 4
		xs->error = XS_TIMEOUT;
		ccb->timeout = ADW_ABORT_TIMEOUT;
		ccb->flags |= CCB_ABORT;
		adw_queue_ccb(sc, ccb);
a1088 19
static void
adw_watchdog(arg)
	void           *arg;
{
	ADW_CCB        *ccb = arg;
	struct scsi_xfer *xs = ccb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	ADW_SOFTC      *sc = sc_link->adapter_softc;
	int             s;

	s = splbio();

	ccb->flags &= ~CCB_WATCHDOG;
	adw_start_ccbs(sc);

	splx(s);
}


d1090 1
a1090 1
/* NARROW and WIDE boards Interrupt callbacks                */
d1095 1
a1095 1
 * adw_wide_isr_callback() - Second Level Interrupt Handler called by AdvISR()
d1100 1
a1100 1
adw_wide_isr_callback(sc, scsiq)
d1105 2
a1106 2
	ADW_CCB        *ccb = (ADW_CCB *) scsiq->ccb_ptr;
	struct scsi_xfer *xs = ccb->xs;
d1108 2
a1109 1
	//int           underrun = ASC_FALSE;
d1111 1
d1115 12
d1133 2
a1134 2
			 (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
				BUS_DMASYNC_POSTWRITE);
d1165 1
a1165 11
		/*
		 * If there was an underrun without any other error,
		 * set DID_ERROR to indicate the underrun error.
		 *
		 * Note: There is no way yet to indicate the number
		 * of underrun bytes.
		 */
		/*
		 * if (xs->error == XS_NOERROR && underrun == ASC_TRUE) {
		 * scp->result = HOST_BYTE(DID_UNDERRUN); }
		 */ break;
d1170 3
a1172 1
			if (scsiq->scsi_status == SS_CHK_CONDITION) {
d1177 9
a1185 1
			} else {
d1187 3
d1193 4
d1205 3
a1212 1

d1216 36
@


1.1
log
@Add adw device driver, from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d196 1
a196 1
				 BUS_DMA_NOWAIT | BUS_DMAMEM_NOSYNC)) != 0) {
@

