head	1.56;
access;
symbols
	OPENBSD_6_2_BASE:1.56
	OPENBSD_6_1:1.55.0.8
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.6
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.54.0.10
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.54.0.6
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.52.0.10
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.52.0.8
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.52.0.4
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.6
	OPENBSD_5_0:1.52.0.2
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.46.0.2
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.42.0.8
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.4
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.41.0.4
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.39.0.4
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.4
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.25
	UBC:1.20.0.4
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.56
date	2017.07.12.13.40.59;	author mikeb;	state Exp;
branches;
next	1.55;
commitid	cTjozW3ysyPPIWCb;

1.55
date	2015.08.17.15.36.29;	author krw;	state Exp;
branches;
next	1.54;
commitid	Le3SuX5chjCNZy3I;

1.54
date	2014.01.22.06.05.21;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2014.01.18.20.50.24;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2011.07.15.16.44.17;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2011.05.09.22.33.54;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	2011.05.08.17.33.57;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	2011.04.18.04.16.14;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.15.20.53.28;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2011.04.05.19.57.40;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.29.18.40.33;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.09.15.46.17;	author jasper;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.05.20.01.40;	author jsg;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.08.16.07.03;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.08.16.01.52;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.03.02.18.47;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.10.21.45.41;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.17.17.50.48;	author grange;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.17.08.58.56;	author grange;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.17.08.42.41;	author grange;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.24.07.05.44;	author grange;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.02.18.55.08;	author grange;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.21.18.58.50;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.17.08.14.09;	author grange;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.16.14.18.34;	author grange;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.16.14.15.41;	author grange;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.28.21.01.43;	author grange;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.23.22.07.15;	author grange;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.05.14.41.56;	author grange;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.03.09.18.46;	author gluk;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.16.17.12.09;	author csapuntz;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.07.19.04.46;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.31.06.14.05;	author csapuntz;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2001.06.25.19.31.50;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.30.21.17.41;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.04.07.29.50;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.25.13.11.53;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.15.23.08.16;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.05.16.04.11;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.29.00.20.16;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.27.20.29.28;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.20.19.15.23;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.20.07.40.32;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.30.01.03.41;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.10.07.06.15;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	99.12.14.18.07.43;	author csapuntz;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.12.11.10.15.03;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	99.11.17.01.22.56;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.29.01.15.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.10.09.03.42.04;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	99.07.22.02.54.06;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.07.18.21.25.16;	author csapuntz;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.24.25;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.41.20;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2002.03.28.12.11.34;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.02.19.10.56.21;	author niklas;	state Exp;
branches;
next	1.7.2.8;

1.7.2.8
date	2004.06.05.23.12.44;	author niklas;	state Exp;
branches;
next	;

1.20.4.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Introduce two quirks to prevent attaching ATA and ATAPI devices

Hyper-V and Xen have varying support for detaching emulated IDE
devices ranging from none on Hyper-V to only IDE disks but not
CDROM (Xen). The quirk mechanism provides a way of enforcing the
desired behavior.

With suggestions and OK kettenis, tedu, mlarkin
@
text
@/*      $OpenBSD: wdcvar.h,v 1.55 2015/08/17 15:36:29 krw Exp $     */
/*	$NetBSD: wdcvar.h,v 1.17 1999/04/11 20:50:29 bouyer Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum, by Onno van der Linden and by Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *	notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *	notice, this list of conditions and the following disclaimer in the
 *	documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _DEV_IC_WDCVAR_H_
#define _DEV_IC_WDCVAR_H_

#include <sys/timeout.h>

struct channel_queue {  /* per channel queue (may be shared) */
	TAILQ_HEAD(xferhead, wdc_xfer) sc_xfer;
};

struct channel_softc_vtbl;


#define WDC_OPTION_PROBE_VERBOSE   0x10000

struct channel_softc { /* Per channel data */
	struct channel_softc_vtbl  *_vtbl;

	/* Our location */
	int channel;
	/* Our controller's softc */
	struct wdc_softc *wdc;
	/* Our registers */
	bus_space_tag_t       cmd_iot;
	bus_space_handle_t    cmd_ioh;
	bus_size_t            cmd_iosz;
	bus_space_tag_t       ctl_iot;
	bus_space_handle_t    ctl_ioh;
	bus_size_t            ctl_iosz;
	/* data32{iot,ioh} are only used for 32 bit xfers */
	bus_space_tag_t         data32iot;
	bus_space_handle_t      data32ioh;
	/* Our state */
	int ch_flags;
#define WDCF_ACTIVE		0x01 /* channel is active */
#define WDCF_ONESLAVE		0x02 /* slave-only channel */
#define WDCF_IRQ_WAIT		0x10 /* controller is waiting for irq */
#define WDCF_DMA_WAIT		0x20 /* controller is waiting for DMA */
#define WDCF_VERBOSE_PROBE	0x40 /* verbose probe */
#define WDCF_DMA_BEFORE_CMD	0x80 /* start dma before a command */
	u_int8_t ch_status;         /* copy of status register */
	u_int8_t ch_prev_log_status; /* previous logged value of status reg */
	u_int8_t ch_log_idx;
	u_int8_t ch_error;          /* copy of error register */
	/* per-drive infos */
	struct ata_drive_datas ch_drive[2];

	/*
	 * channel queues. May be the same for all channels, if hw channels
	 * are not independent.
	 */
	struct channel_queue *ch_queue;
	struct timeout ch_timo;

	int dying;
};

/*
 * Disk Controller register definitions.
 */
#define _WDC_REGMASK 7
#define _WDC_AUX     8
#define _WDC_RDONLY  16
#define _WDC_WRONLY  32
enum wdc_regs {
	wdr_error = _WDC_RDONLY | 1,
	wdr_features = _WDC_WRONLY | 1,
	wdr_seccnt = 2,
	wdr_ireason = 2,
	wdr_sector = 3,
	wdr_lba_lo = 3,
	wdr_cyl_lo = 4,
	wdr_lba_mi = 4,
	wdr_cyl_hi = 5,
	wdr_lba_hi = 5,
	wdr_sdh = 6,
	wdr_status = _WDC_RDONLY | 7,
	wdr_command = _WDC_WRONLY | 7,
	wdr_altsts = _WDC_RDONLY | _WDC_AUX,
	wdr_ctlr = _WDC_WRONLY | _WDC_AUX
};

#define WDC_NREG	8 /* number of command registers */
#define WDC_NSHADOWREG	2 /* number of command "shadow" registers */

struct channel_softc_vtbl {
	u_int8_t (*read_reg)(struct channel_softc *, enum wdc_regs reg);
	void (*write_reg)(struct channel_softc *, enum wdc_regs reg,
	    u_int8_t var);
	void (*lba48_write_reg)(struct channel_softc *, enum wdc_regs reg,
	    u_int16_t var);

	void (*read_raw_multi_2)(struct channel_softc *,
	    void *data, unsigned int nbytes);
	void (*write_raw_multi_2)(struct channel_softc *,
	    void *data, unsigned int nbytes);

	void (*read_raw_multi_4)(struct channel_softc *,
	    void *data, unsigned int nbytes);
	void (*write_raw_multi_4)(struct channel_softc *,
	    void *data, unsigned int nbytes);
};


#define CHP_READ_REG(chp, a)  ((chp)->_vtbl->read_reg)(chp, a)
#define CHP_WRITE_REG(chp, a, b)  ((chp)->_vtbl->write_reg)(chp, a, b)
#define CHP_LBA48_WRITE_REG(chp, a, b)	\
	((chp)->_vtbl->lba48_write_reg)(chp, a, b)

#define CHP_READ_RAW_MULTI_2(chp, a, b)  \
	((chp)->_vtbl->read_raw_multi_2)(chp, a, b)
#define CHP_WRITE_RAW_MULTI_2(chp, a, b)  \
	((chp)->_vtbl->write_raw_multi_2)(chp, a, b)
#define CHP_READ_RAW_MULTI_4(chp, a, b)  \
	((chp)->_vtbl->read_raw_multi_4)(chp, a, b)
#define CHP_WRITE_RAW_MULTI_4(chp, a, b)  \
	((chp)->_vtbl->write_raw_multi_4)(chp, a, b)

struct wdc_softc { /* Per controller state */
	struct device sc_dev;
	/* mandatory fields */
	int           cap;
/* Capabilities supported by the controller */
#define WDC_CAPABILITY_DATA16 0x0001	/* can do  16-bit data access */
#define WDC_CAPABILITY_DATA32 0x0002	/* can do 32-bit data access */
#define WDC_CAPABILITY_MODE   0x0004	/* controller knows its PIO/DMA modes */
#define WDC_CAPABILITY_DMA    0x0008	/* DMA */
#define WDC_CAPABILITY_UDMA   0x0010	/* Ultra-DMA/33 */
#define WDC_CAPABILITY_NO_EXTRA_RESETS 0x0100 /* only reset once */
#define WDC_CAPABILITY_PREATA 0x0200	/* ctrl can be a pre-ata one */
#define WDC_CAPABILITY_IRQACK 0x0400	/* callback to ack interrupt */
#define WDC_CAPABILITY_SINGLE_DRIVE 0x800 /* Don't proble second drive */
#define WDC_CAPABILITY_NO_ATAPI_DMA 0x1000 /* Don't do DMA with ATAPI */
#define WDC_CAPABILITY_SATA   0x2000	/* SATA controller */
	u_int8_t      PIO_cap; /* highest PIO mode supported */
	u_int8_t      DMA_cap; /* highest DMA mode supported */
	u_int8_t      UDMA_cap; /* highest UDMA mode supported */
	int nchannels;	/* Number of channels on this controller */
	struct channel_softc **channels;  /* channels-specific datas (array) */
	u_int16_t quirks;		/* per-device oddities */
#define WDC_QUIRK_NOSHORTDMA	0x0001	/* can't do short DMA transfers */
#define WDC_QUIRK_NOATA		0x0002	/* skip attaching ATA disks */
#define WDC_QUIRK_NOATAPI	0x0004	/* skip attaching ATAPI devices */

#if 0
	/*
	 * The reference count here is used for both IDE and ATAPI devices.
	 */
	struct scsipi_adapter sc_atapi_adapter;
#endif

	/* if WDC_CAPABILITY_DMA set in 'cap' */
	void            *dma_arg;
	int            (*dma_init)(void *, int, int, void *, size_t,
	                int);
	void           (*dma_start)(void *, int, int);
	int            (*dma_finish)(void *, int, int, int);
/* flags passed to DMA functions */
#define WDC_DMA_READ	0x01
#define WDC_DMA_IRQW	0x02
#define WDC_DMA_LBA48	0x04
	int             dma_status; /* status return from dma_finish() */
#define WDC_DMAST_NOIRQ	0x01 /* missing IRQ */
#define WDC_DMAST_ERR	0x02 /* DMA error */
#define WDC_DMAST_UNDER	0x04 /* DMA underrun */

	/* if WDC_CAPABILITY_MODE set in 'cap' */
	void            (*set_modes)(struct channel_softc *);

	/* if WDC_CAPABILITY_IRQACK set in 'cap' */
	void            (*irqack)(struct channel_softc *);

	void		(*reset)(struct channel_softc *);

	/* Driver callback to probe for drives */
	void (*drv_probe)(struct channel_softc *);
};

 /*
  * Description of a command to be handled by a controller.
  * These commands are queued in a list.
  */
struct atapi_return_args;

struct wdc_xfer {
	volatile u_int c_flags;
#define C_ATAPI		0x0002 /* xfer is ATAPI request */
#define C_TIMEOU	0x0004 /* xfer processing timed out */
#define C_NEEDDONE	0x0010 /* need to call upper-level done */
#define C_POLL		0x0020 /* cmd is polled */
#define C_DMA		0x0040 /* cmd uses DMA */
#define C_SENSE		0x0080 /* cmd is a internal command */
#define C_MEDIA_ACCESS	0x0100 /* is a media access command */
#define C_POLL_MACHINE	0x0200 /* machine has a poll handler */
#define C_PRIVATEXFER	0x0400 /* privately managed xfer */
#define C_SCSIXFER	0x0800 /* SCSI managed xfer */

	/* Informations about our location */
	struct channel_softc *chp;
	u_int8_t drive;

	/* Information about the current transfer  */
	void *cmd; /* wdc, ata or scsipi command structure */
	void *databuf;
	int c_bcount;      /* byte count left */
	int c_skip;        /* bytes already transferred */
	TAILQ_ENTRY(wdc_xfer) c_xferchain;
	LIST_ENTRY(wdc_xfer) free_list;
	void (*c_start)(struct channel_softc *, struct wdc_xfer *);
	int  (*c_intr)(struct channel_softc *, struct wdc_xfer *, int);
        void (*c_kill_xfer)(struct channel_softc *, struct wdc_xfer *);

	/* Used by ATAPISCSI */
	volatile int endticks;
	struct timeout atapi_poll_to;
	void (*next)(struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *);
	void (*c_done)(struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *);

	/* Used for tape devices */
	int  transfer_len;
};

/*
 * Public functions which can be called by ATA or ATAPI specific parts,
 * or bus-specific backends.
 */

int   wdcprobe(struct channel_softc *);
void  wdcattach(struct channel_softc *);
int   wdcdetach(struct channel_softc *, int);
int   wdcintr(void *);
struct channel_queue *wdc_alloc_queue(void);
void  wdc_free_queue(struct channel_queue *);
void  wdc_exec_xfer(struct channel_softc *, struct wdc_xfer *);
struct wdc_xfer *wdc_get_xfer(int); /* int = WDC_NOSLEEP/CANSLEEP */
#define WDC_CANSLEEP	0x00
#define WDC_NOSLEEP	0x01
void   wdc_scrub_xfer(struct wdc_xfer *);
void   wdc_free_xfer(struct channel_softc *, struct wdc_xfer *);
void  wdcstart(struct channel_softc *);
int   wdcreset(struct channel_softc *, int);
#define NOWAIT  0x02
#define VERBOSE	0x01
#define SILENT	0x00 /* wdcreset will not print errors */
int   wdc_wait_for_status(struct channel_softc *, int, int, int);
int   wdc_dmawait(struct channel_softc *, struct wdc_xfer *, int);
void  wdcbit_bucket(struct channel_softc *, int);

void  wdccommand(struct channel_softc *, u_int8_t, u_int8_t, u_int16_t,
	u_int8_t, u_int8_t, u_int8_t, u_int8_t);
void  wdccommandext(struct channel_softc *, u_int8_t, u_int8_t, u_int64_t,
	u_int16_t);
void  wdccommandshort(struct channel_softc *, int, int);
void  wdctimeout(void *arg);
void  wdc_do_reset(struct channel_softc *);

int   wdc_addref(struct channel_softc *);
void  wdc_delref(struct channel_softc *);

/*
 * ST506 spec says that if READY or SEEKCMPLT go off, then the read or write
 * command is aborted.
 */
#define wdcwait(chp, status, mask, timeout) ((wdc_wait_for_status((chp), (status), (mask), (timeout)) >= 0) ? 0 : -1)
#define wait_for_drq(chp, timeout) wdcwait((chp), WDCS_DRQ, WDCS_DRQ, (timeout))
#define wait_for_unbusy(chp, timeout) wdcwait((chp), 0, 0, (timeout))
#define wait_for_ready(chp, timeout) wdcwait((chp), WDCS_DRDY, \
	WDCS_DRDY, (timeout))

/* ATA/ATAPI specs says a device can take 31s to reset */
#define WDC_RESET_WAIT 31000

void wdc_disable_intr(struct channel_softc *);
void wdc_enable_intr(struct channel_softc *);
int wdc_select_drive(struct channel_softc *, int, int);
void wdc_set_drive(struct channel_softc *, int drive);
void wdc_output_bytes(struct ata_drive_datas *drvp, void *, unsigned int);
void wdc_input_bytes(struct ata_drive_datas *drvp, void *, unsigned int);

void wdc_print_current_modes(struct channel_softc *);

int wdc_ioctl(struct ata_drive_datas *, u_long, caddr_t, int, struct proc *);

u_int8_t wdc_default_read_reg(struct channel_softc *,
		enum wdc_regs);
void     wdc_default_write_reg(struct channel_softc *,
		enum wdc_regs, u_int8_t);
void     wdc_default_lba48_write_reg(struct channel_softc *,
		enum wdc_regs, u_int16_t);
void     wdc_default_read_raw_multi_2(struct channel_softc *,
		void *, unsigned int);
void     wdc_default_write_raw_multi_2(struct channel_softc *,
		void *, unsigned int);
void     wdc_default_read_raw_multi_4(struct channel_softc *,
		void *, unsigned int);
void     wdc_default_write_raw_multi_4(struct channel_softc *,
		void *, unsigned int);

#endif	/* !_DEV_IC_WDCVAR_H_ */
@


1.55
log
@The 80's called and want their interface back. Remove last fragments of
ST-506 support. Remove redundant 'precomp' variables/fields and rename
remaining few to 'features' to be consistant with the rest of the code.

Consensus that no ST-506 disks (requiring ISA cards, <120MB, usually
rife with bad sectors that can't be worked around) are still running
OpenBSD.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.54 2014/01/22 06:05:21 dlg Exp $     */
d173 2
@


1.54
log
@dont piggyback on C_PRIVATEXFER because it must not touch splx.
because im using it while the system is up and running i need the
xfer free path to take the right locks, which PRIVATEXFER doesnt.
invent a new C_SCSIXFER flag that provides the safety needed.

this fixes issues people have had installing from atapiscsi(4) cdrom
devices.

bug spelunking and tailq corruption identified by jsing@@
ok jsing@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.53 2014/01/18 20:50:24 dlg Exp $     */
a97 1
	wdr_precomp = _WDC_WRONLY | 1,
@


1.53
log
@move atapiscsi to iopools by making the entire ata layer use them too.

this would have been difficult before because the ata completion
paths try to be helfpul by freeing xfers on the adapters behalf,
whch doesn't work in the new world scsi model where the layer that
allocated the thing is responsible for freeing it, and expects to
get it back and maybe use it again. however, deraadt@@ added magic
flags for hibernate that im now using to keep ata xfers for the
scsi layers.

committing this now so itll be tested. i cant think of a better time
to handle fallout from diffs like this than hackathons.

discussed with deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.52 2011/07/15 16:44:17 deraadt Exp $     */
d226 1
@


1.52
log
@Cope with the start-dma-before-init errata and some other register setup
errata for the Serverworks SATA chipset found on the macppc xserve G5.
ok jmc
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.51 2011/05/09 22:33:54 matthew Exp $     */
d269 1
@


1.51
log
@Refactor queue allocation and initialization into a wdc_alloc_queue()
function, and let attachment code calls this rather than malloc(9).
This prevents re-initialization of the queue in shared queue chipsets.
Also, add wdc_free_queue() as a complementary function.

Earlier version (without wdc_free_queue()) tested by sthen@@ and Amit
Kulkarni on various pciide(4) chips.

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.50 2011/05/08 17:33:57 matthew Exp $     */
d71 1
@


1.50
log
@Eliminate a few unused wdc capability flags (WDC_CAPABILITY_HWLOCK,
WDC_CAPABILITY_ATA_NOSTREAM, and WDC_CAPABILITY_ATAPI_NOSTREAM).

ok dlg@@, jsg@@, krw@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.49 2011/04/18 04:16:14 deraadt Exp $     */
d262 2
@


1.49
log
@keep an eye out for wdc registers returning 0xff.  if they return 0xff,
this probably means the controller is dead -- as in, a hot plug eject
event.  in that case, mark the driver dead and try harder to return -1
in the interrupt handler.
tested by many
ok dlg, miod did not object
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.48 2011/04/15 20:53:28 miod Exp $     */
a159 3
#define WDC_CAPABILITY_HWLOCK 0x0020	/* Needs to lock HW */
#define WDC_CAPABILITY_ATA_NOSTREAM 0x0040 /* Don't use stream funcs on ATA */
#define WDC_CAPABILITY_ATAPI_NOSTREAM 0x0080 /* Don't use stream f on ATAPI */
a194 4

	/* if WDC_CAPABILITY_HWLOCK set in 'cap' */
	int             (*claim_hw)(void *, int);
	void            (*free_hw)(void *);
@


1.48
log
@Change wdc_reset_channel() to take a `no wait' argument. Pass in turn this
argument to wdcreset(), to have it skip waiting until active channels see
their BUSY bit clear in the status register.

Use this feature in the resume path, during the first reset operation. The
first reset is supposed to only wake up the controller, and the disks don't
come back until the second reset is issued, therefore waiting for them to
report themselves as ready after the first reset, but before the second, is
moot - and as a matter of fact some controllers, such as the AMD 754 and
clones/offspring (e.g. Geode) keep the BUSY bit asserted after the first
reset.

Last, but not least, make sure wd@@ata invokes wd_get_params() again before
returning from the resume code, as we will still be using polled transfers
for a short while.

This causes the Lemote Yeelong to resume within less than one second, instead
of the lousy 30 seconds wait between the two resets; and the wd_get_params()
voodoo prevents it from getting spurious ide interrupts afterwards.

wd_get_params() magic from dlg; rest of the work by yours truly after enough
prodding by dlg@@ and pirofti@@, among others. ok deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.47 2011/04/05 19:57:40 deraadt Exp $     */
d84 2
@


1.47
log
@wd_hibernate_io() is a standalone disk io writer which tries to not
damage kernel memory very much while doing the job.  It is not very
pretty yet, but improving it will need some MI work.
ok mlarkin jsg dlg
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.46 2010/08/29 18:40:33 deraadt Exp $     */
d274 3
a276 2
#define VERBOSE	1
#define SILENT	0 /* wdcreset will not print errors */
@


1.46
log
@pcmcia/wdc_pcmcia.c
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.45 2010/05/09 15:46:17 jasper Exp $     */
d229 1
@


1.45
log
@hander -> handler

ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.44 2009/10/13 19:33:16 pirofti Exp $     */
a264 1
int   wdcactivate(struct device *, int);
@


1.44
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.43 2009/10/05 20:01:40 jsg Exp $     */
d228 1
a228 1
#define C_POLL_MACHINE	0x0200 /* machine has a poll hander */
@


1.43
log
@Add some minimalistic detach/unmap bits for pciide,
done using a chipset unmap callback.

Still needs to work to distinguish between compat
register mappings and compat interrupts so we
don't get caught out.

Tested with a diskless sii3112 CardBus eSATA controller
by me, and testing and feedback by deraadt@@ with
a phison based expresscard SSD.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.42 2008/06/26 05:42:16 ray Exp $     */
d265 1
a265 1
int   wdcactivate(struct device *, enum devact);
@


1.42
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.41 2007/05/08 16:07:03 deraadt Exp $     */
d57 1
d60 1
@


1.41
log
@wdcrestart() is never used
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.40 2007/05/08 16:01:52 deraadt Exp $     */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.40
log
@atapi_print() is never used
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.39 2006/05/03 02:18:47 jsg Exp $     */
a277 1
void  wdcrestart(void *);
@


1.39
log
@Provide a function pointer that allows for the wdc reset
method to be changed as required.
This will be required for dealing with several chips in pciide.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.38 2006/02/10 21:45:41 kettenis Exp $     */
a308 2

int   atapi_print(void *, const char *);
@


1.38
log
@Fix LBA48 access for ServerWorks SATA.
ok grange@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.37 2004/10/17 17:50:48 grange Exp $     */
d212 2
d292 1
@


1.37
log
@Add a callback drv_probe() to allow underlying ata controller driver
to probe for drives in its own way. It's a no-op for now but will be
needed for native sata support.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.36 2004/10/17 08:58:56 grange Exp $     */
d124 2
d141 3
d324 2
@


1.36
log
@Move declaration of default _vtbl members (wdc_default_*) to
wdcvar.h.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.35 2004/10/17 08:42:41 grange Exp $     */
d206 3
@


1.35
log
@Define number of general and ``shadow'' (overlapping) ATA registers;
from NetBSD.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.34 2004/09/24 07:05:44 grange Exp $     */
d311 13
@


1.34
log
@Multiple inclusion protection.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.33 2004/06/02 18:55:08 grange Exp $     */
d116 3
@


1.33
log
@Add quirks field to the wdc softc and implement the first one:
WDC_QUIRK_NOSHORTDMA which disables DMA for the one-sector
transfers. Use this quirk for the Geode SC1100 IDE to fix
hanging during fdisk reported in PR 3729.
Thanks to Alexandre Belloni <abelloni@@nerim.net> for testing.

ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.32 2003/10/21 18:58:50 jmc Exp $     */
d40 3
d308 2
@


1.32
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.31 2003/10/17 08:14:09 grange Exp $     */
d166 2
@


1.31
log
@Merge an old fix from NetBSD:
- do not stop/unload current DMA operation if an IRQ was not detected
  by DMA engine unless the force flag was given, fixes DMA problems
  in shared IRQ setups;
- ack interrupt before entering DMA codepath

Tested by many.
Work by niklas@@ but he doesn't want to commit it for some reason.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.30 2003/10/16 14:18:34 grange Exp $     */
d82 1
a82 1
	 * are not independants
@


1.30
log
@New flag to mark SATA controllers
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.29 2003/10/16 14:15:41 grange Exp $     */
d71 1
d179 1
a179 1
	int            (*dma_finish)(void *, int, int);
@


1.29
log
@spaces/tabs cleanup
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.28 2003/09/28 21:01:43 grange Exp $     */
d159 1
@


1.28
log
@kill trailing spaces, no functional changes
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.27 2003/07/23 22:07:15 grange Exp $     */
d68 4
a71 4
#define WDCF_ACTIVE   0x01	/* channel is active */
#define WDCF_ONESLAVE 0x02      /* slave-only channel */
#define WDCF_IRQ_WAIT 0x10	/* controller is waiting for irq */
#define WDCF_VERBOSE_PROBE 0x40 /* verbose probe */
d91 1
a91 1
#define _WDC_AUX 8
d133 1
a133 1
        ((chp)->_vtbl->read_raw_multi_2)(chp, a, b)
d135 1
a135 1
        ((chp)->_vtbl->write_raw_multi_2)(chp, a, b)
d146 2
a147 2
#define	WDC_CAPABILITY_DATA16 0x0001    /* can do  16-bit data access */
#define	WDC_CAPABILITY_DATA32 0x0002    /* can do 32-bit data access */
d149 5
a153 5
#define	WDC_CAPABILITY_DMA    0x0008	/* DMA */
#define	WDC_CAPABILITY_UDMA   0x0010	/* Ultra-DMA/33 */
#define	WDC_CAPABILITY_HWLOCK 0x0020	/* Needs to lock HW */
#define	WDC_CAPABILITY_ATA_NOSTREAM 0x0040 /* Don't use stream funcs on ATA */
#define	WDC_CAPABILITY_ATAPI_NOSTREAM 0x0080 /* Don't use stream f on ATAPI */
d155 2
a156 2
#define WDC_CAPABILITY_PREATA 0x0200 /* ctrl can be a pre-ata one */
#define WDC_CAPABILITY_IRQACK 0x0400    /* callback to ack interrupt */
d183 3
a185 3
#define WDC_DMAST_NOIRQ 0x01    /* missing IRQ */
#define WDC_DMAST_ERR   0x02    /* DMA error */
#define WDC_DMAST_UNDER 0x04    /* DMA underrun */
d188 1
a188 1
	int            (*claim_hw)(void *, int);
d192 1
a192 1
	void 		(*set_modes)(struct channel_softc *);
d206 3
a208 3
#define C_ATAPI  	0x0002 /* xfer is ATAPI request */
#define C_TIMEOU  	0x0004 /* xfer processing timed out */
#define C_NEEDDONE  	0x0010 /* need to call upper-level done */
d212 2
a213 2
#define C_MEDIA_ACCESS  0x0100 /* is a media access command */
#define C_POLL_MACHINE  0x0200 /* machine has a poll hander */
d231 1
a231 1
 	volatile int endticks;
d254 2
a255 2
#define WDC_CANSLEEP 0x00
#define WDC_NOSLEEP 0x01
d260 2
a261 2
#define VERBOSE 1
#define SILENT 0 /* wdcreset will not print errors */
d267 1
a267 1
	                  u_int8_t, u_int8_t, u_int8_t, u_int8_t);
d269 2
a270 2
		    u_int16_t);
void   wdccommandshort(struct channel_softc *, int, int);
d273 2
a274 2
int	wdc_addref(struct channel_softc *);
void	wdc_delref(struct channel_softc *);
d282 1
a282 1
#define wait_for_unbusy(chp, timeout)	wdcwait((chp), 0, 0, (timeout))
a300 1

@


1.27
log
@Old Promise ATA controllers need some additional operations
during DMA transfers to work correctly with LBA48 drives.
Based on diff from Takeshi Nakayama <tn@@catvmics.ne.jp> for NetBSD
with some corrections from FreeBSD ATA driver.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.26 2003/07/05 14:41:56 grange Exp $     */
d94 1
a94 1
enum wdc_regs { 		
d115 1
a115 1
	void (*write_reg)(struct channel_softc *, enum wdc_regs reg, 
d117 2
a118 2
	
	void (*read_raw_multi_2)(struct channel_softc *, 
d205 1
a205 1
	volatile u_int c_flags;    
d237 1
a237 1
	
d260 1
a260 1
#define VERBOSE 1 
d276 1
a276 1
/*	
@


1.26
log
@better indent
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.25 2002/05/03 09:18:46 gluk Exp $     */
d181 1
@


1.25
log
@LBA48 support.
Adopted from NetBSD by Alexander Yurchenko <grange@@openbsd.ru>.

costa@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.24 2002/03/16 17:12:09 csapuntz Exp $     */
d179 2
a180 2
#define WDC_DMA_READ 0x01
#define WDC_DMA_IRQW 0x02
@


1.24
log
@The new code logs the control signals on the IDE bus. You can extract the log
using atactl <device> dump. The log will help us support more devices.
Send logs to csapuntz@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.23 2002/03/14 03:16:05 millert Exp $     */
d101 1
d103 1
d105 1
d267 2
@


1.23
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.22 2002/03/14 01:26:55 millert Exp $     */
d73 2
d288 1
a288 1

d295 1
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.21 2002/01/07 19:04:46 mickey Exp $     */
d252 1
a252 1
void  wdcrestart(void*);
@


1.21
log
@pass the proc* down the ioctl chain to controller; mjacob@@ csapuntz@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.20 2001/07/31 06:14:05 csapuntz Exp $     */
d169 4
a172 4
	int            (*dma_init) __P((void *, int, int, void *, size_t,
	                int));
	void           (*dma_start) __P((void *, int, int));
	int            (*dma_finish) __P((void *, int, int));
d182 2
a183 2
	int            (*claim_hw) __P((void *, int));
	void            (*free_hw) __P((void *));
d186 1
a186 1
	void 		(*set_modes) __P((struct channel_softc *));
d189 1
a189 1
	void            (*irqack) __P((struct channel_softc *));
d220 3
a222 3
	void (*c_start) __P((struct channel_softc *, struct wdc_xfer *));
	int  (*c_intr)  __P((struct channel_softc *, struct wdc_xfer *, int));
        void (*c_kill_xfer) __P((struct channel_softc *, struct wdc_xfer *));
d227 4
a230 4
	void (*next) __P((struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *));
	void (*c_done)  __P((struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *));
d241 7
a247 7
int   wdcprobe __P((struct channel_softc *));
void  wdcattach __P((struct channel_softc *));
int   wdcdetach __P((struct channel_softc *, int));
int   wdcactivate __P((struct device *, enum devact));
int   wdcintr __P((void *));
void  wdc_exec_xfer __P((struct channel_softc *, struct wdc_xfer *));
struct wdc_xfer *wdc_get_xfer __P((int)); /* int = WDC_NOSLEEP/CANSLEEP */
d250 4
a253 4
void   wdc_free_xfer  __P((struct channel_softc *, struct wdc_xfer *));
void  wdcstart __P((struct channel_softc *));
void  wdcrestart __P((void*));
int   wdcreset	__P((struct channel_softc *, int));
d256 8
a263 8
int   wdc_wait_for_status __P((struct channel_softc *, int, int, int));
int   wdc_dmawait __P((struct channel_softc *, struct wdc_xfer *, int));
void  wdcbit_bucket __P((struct channel_softc *, int));

void  wdccommand __P((struct channel_softc *, u_int8_t, u_int8_t, u_int16_t,
	                  u_int8_t, u_int8_t, u_int8_t, u_int8_t));
void   wdccommandshort __P((struct channel_softc *, int, int));
void  wdctimeout	__P((void *arg));
d265 2
a266 2
int	wdc_addref __P((struct channel_softc *));
void	wdc_delref __P((struct channel_softc *));
d281 1
a281 1
int   atapi_print       __P((void *, const char *));
d283 3
a285 3
void wdc_disable_intr __P((struct channel_softc *));
void wdc_enable_intr __P((struct channel_softc *));
int wdc_select_drive __P((struct channel_softc *, int, int));
d287 2
a288 2
void wdc_output_bytes __P((struct ata_drive_datas *drvp, void *, unsigned int));
void wdc_input_bytes __P((struct ata_drive_datas *drvp, void *, unsigned int));
d290 1
a290 1
void wdc_print_current_modes __P((struct channel_softc *));
d292 1
a292 1
int wdc_ioctl __P((struct ata_drive_datas *, u_long, caddr_t, int, struct proc *));
@


1.20
log
@

On DMA timeouts, stop busmaster PCIIDE and reset channel. Avoid reading
device registers as this may cause lock-ups on some chipsets

Clean-up in atapiscsi. Get rid of claim_irq. Instead, atapiscsi always
returns -1 (maybe) from the interrupt handler.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.19 2001/06/25 19:31:50 csapuntz Exp $     */
d292 1
a292 1
int wdc_ioctl __P((struct ata_drive_datas *, u_long, caddr_t, int));
@


1.20.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.21 2002/01/07 19:04:46 mickey Exp $     */
d292 1
a292 1
int wdc_ioctl __P((struct ata_drive_datas *, u_long, caddr_t, int, struct proc *));
@


1.20.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.20.4.1 2002/01/31 22:55:32 niklas Exp $     */
a72 2
	u_int8_t ch_prev_log_status; /* previous logged value of status reg */
	u_int8_t ch_log_idx;
a98 1
	wdr_lba_lo = 3,
a99 1
	wdr_lba_mi = 4,
a100 1
	wdr_lba_hi = 5,
d169 4
a172 4
	int            (*dma_init)(void *, int, int, void *, size_t,
	                int);
	void           (*dma_start)(void *, int, int);
	int            (*dma_finish)(void *, int, int);
d182 2
a183 2
	int            (*claim_hw)(void *, int);
	void            (*free_hw)(void *);
d186 1
a186 1
	void 		(*set_modes)(struct channel_softc *);
d189 1
a189 1
	void            (*irqack)(struct channel_softc *);
d220 3
a222 3
	void (*c_start)(struct channel_softc *, struct wdc_xfer *);
	int  (*c_intr)(struct channel_softc *, struct wdc_xfer *, int);
        void (*c_kill_xfer)(struct channel_softc *, struct wdc_xfer *);
d227 4
a230 4
	void (*next)(struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *);
	void (*c_done)(struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *);
d241 7
a247 7
int   wdcprobe(struct channel_softc *);
void  wdcattach(struct channel_softc *);
int   wdcdetach(struct channel_softc *, int);
int   wdcactivate(struct device *, enum devact);
int   wdcintr(void *);
void  wdc_exec_xfer(struct channel_softc *, struct wdc_xfer *);
struct wdc_xfer *wdc_get_xfer(int); /* int = WDC_NOSLEEP/CANSLEEP */
d250 4
a253 4
void   wdc_free_xfer(struct channel_softc *, struct wdc_xfer *);
void  wdcstart(struct channel_softc *);
void  wdcrestart(void *);
int   wdcreset(struct channel_softc *, int);
d256 8
a263 10
int   wdc_wait_for_status(struct channel_softc *, int, int, int);
int   wdc_dmawait(struct channel_softc *, struct wdc_xfer *, int);
void  wdcbit_bucket(struct channel_softc *, int);

void  wdccommand(struct channel_softc *, u_int8_t, u_int8_t, u_int16_t,
	                  u_int8_t, u_int8_t, u_int8_t, u_int8_t);
void  wdccommandext(struct channel_softc *, u_int8_t, u_int8_t, u_int64_t,
		    u_int16_t);
void   wdccommandshort(struct channel_softc *, int, int);
void  wdctimeout(void *arg);
d265 2
a266 2
int	wdc_addref(struct channel_softc *);
void	wdc_delref(struct channel_softc *);
d281 1
a281 1
int   atapi_print(void *, const char *);
d283 3
a285 6
void wdc_disable_intr(struct channel_softc *);
void wdc_enable_intr(struct channel_softc *);
int wdc_select_drive(struct channel_softc *, int, int);
void wdc_set_drive(struct channel_softc *, int drive);
void wdc_output_bytes(struct ata_drive_datas *drvp, void *, unsigned int);
void wdc_input_bytes(struct ata_drive_datas *drvp, void *, unsigned int);
d287 2
a288 1
void wdc_print_current_modes(struct channel_softc *);
d290 1
a290 1
int wdc_ioctl(struct ata_drive_datas *, u_long, caddr_t, int, struct proc *);
d292 1
@


1.19
log
@

Fix excessive resets and device probes by storing IDENTIFY results in the
drvp structure
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.18 2001/04/30 21:17:41 csapuntz Exp $     */
a70 1
#define WDCF_DMA_WAIT 0x20      /* controller is waiting for DMA */
@


1.18
log
@

Move ATA IOCTL commands to low-level WDC driver
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.17 2001/04/04 07:29:50 csapuntz Exp $     */
a281 1
void wdc_atapibus_attach __P((struct channel_softc *));
@


1.17
log
@

Lay the groundwork for disabling ATAPI DMA on controllers
where we have trouble. Note, in theory, ATAPI DMA is no different
than ATA DMA.

"Promise" not to tell anybody
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.16 2001/03/25 13:11:53 csapuntz Exp $     */
a41 3
#define	WAITTIME    (10 * hz)    /* time to wait for a completion */
	/* this is a lot for hard drives, but not for cdroms */

d293 2
@


1.16
log
@Minor mods to DMA interface - get rid of unnecessary args. Allow DMA functions to return status flags.

Note: Changing code to have DMA interface indicate when I/O is done (a la NetBSD) was considered. It was rejected due to questionable backward compatability
with ISA DMA and MAC obio DMA

Added irqack from NetBSD (though this feature should really be in the
PCI interrupt handlers)

Use pool
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.15 2001/03/15 23:08:16 csapuntz Exp $     */
d157 1
@


1.15
log
@Fix races between timeouts and interrupts.

Cleanup atapiscsi driver a bit by moving fields out of xfer.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.14 2001/03/05 16:04:11 ho Exp $     */
d72 1
d74 1
a74 1
#define WDCF_ONESLAVE 0x20      /* slave-only channel */
d155 2
d174 2
a175 2
	void           (*dma_start) __P((void *, int, int, int));
	int            (*dma_finish) __P((void *, int, int, int));
d178 5
a182 1
#define WDC_DMA_POLL 0x02
d190 3
a202 1
#define C_INUSE  	0x0001 /* xfer struct is in use */
d228 1
a228 1
 	int endticks;
d260 1
@


1.14
log
@Convert to new timeout API. costa@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.13 2001/01/29 00:20:16 csapuntz Exp $     */
d189 2
a215 1
	int (*c_done)  __P((struct channel_softc *, struct wdc_xfer *, int));
d219 1
a219 3
	int timeout;
	int endticks;
	int delay;
d221 4
a224 4
	unsigned int expect_irq:1;
	unsigned int claim_irq:1;

	int (*next) __P((struct channel_softc *, struct wdc_xfer *, int));
@


1.13
log
@


Add wdc_print_current_modes to print current transfer modes set on the
devices. Print after attach in wdc_isa, wdc_isapnp, wdc_pcmcia.
pciide_print_modes rewritten to use wdc_print_current_modes.

Disable wdc_print_caps since it's not as useful.

Inspired by NetBSD. Thanks to Dale and Theo for pointing out this improvement.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.12 2000/10/27 20:29:28 csapuntz Exp $     */
d221 1
@


1.12
log
@

Patch to get rid of ST506 phantoms. Thanks to Grigoriy Orlov for the design
and testing.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.11 2000/07/20 19:15:23 csapuntz Exp $     */
d284 1
@


1.11
log
@

chp->wdc can be NULL on probe.

Propagate verbose flag from cf_data to channel
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.10 2000/07/20 07:40:32 csapuntz Exp $     */
d250 1
a250 1
int   wdcwait __P((struct channel_softc *, int, int, int));
d264 2
a265 1
 */   
d270 1
@


1.10
log
@

Fix to ATA detect. Some devices seem to be comatose after reset
(return 0x00 status persistently). Send them identify to wake them up.

Flag value 0x10000 will enable probe messages for a channel/controller.
When UKC supports setting flags, this will be useful debugging
failing IDE detects without kernel recompiles.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.9 2000/06/30 01:03:41 art Exp $     */
d74 1
@


1.9
log
@Convert some parts to new timeouts.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.8 2000/04/10 07:06:15 csapuntz Exp $     */
d50 3
@


1.8
log
@

Added support for wd detach (merge from NetBSD). Support for
SCSI/ATAPI detach is not here yet.

Minor cleanup of wdc. Downgrade to UDMA mode 1 before going further.
Want to stay in UDMA modes because they're more error-resilient due to
a CRC.

Got rid of some of the ridiculous amount of softc sharing going on.
Hopefully, this will make the life of whoever goes in and fixes the
ref-counting to be correct easier.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.7 1999/12/14 18:07:43 csapuntz Exp $     */
d40 2
d81 1
@


1.7
log
@

Thanks aaron.

Changed time->ticks
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.6 1999/12/11 10:15:03 csapuntz Exp $     */
d73 1
a73 1
	
d208 1
d230 2
d244 2
a245 1
void  wdcbit_bucket __P(( struct channel_softc *, int));
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.17 2001/04/04 07:29:50 csapuntz Exp $     */
a39 2
#include <sys/timeout.h>

a48 3

#define WDC_OPTION_PROBE_VERBOSE   0x10000

a66 1
#define WDCF_ONESLAVE 0x02      /* slave-only channel */
d68 1
a68 2
#define WDCF_DMA_WAIT 0x20      /* controller is waiting for DMA */
#define WDCF_VERBOSE_PROBE 0x40 /* verbose probe */
d73 1
a73 1

a78 1
	struct timeout ch_timo;
a146 3
#define WDC_CAPABILITY_IRQACK 0x0400    /* callback to ack interrupt */
#define WDC_CAPABILITY_SINGLE_DRIVE 0x800 /* Don't proble second drive */
#define WDC_CAPABILITY_NO_ATAPI_DMA 0x1000 /* Don't do DMA with ATAPI */
d164 2
a165 2
	void           (*dma_start) __P((void *, int, int));
	int            (*dma_finish) __P((void *, int, int));
d168 1
a168 5
#define WDC_DMA_IRQW 0x02
	int             dma_status; /* status return from dma_finish() */
#define WDC_DMAST_NOIRQ 0x01    /* missing IRQ */
#define WDC_DMAST_ERR   0x02    /* DMA error */
#define WDC_DMAST_UNDER 0x04    /* DMA underrun */
a175 3

	/* if WDC_CAPABILITY_IRQACK set in 'cap' */
	void            (*irqack) __P((struct channel_softc *));
a181 2
struct atapi_return_args;

d184 1
d207 1
a207 1
        void (*c_kill_xfer) __P((struct channel_softc *, struct wdc_xfer *));
d210 7
a216 6
 	volatile int endticks;
	struct timeout atapi_poll_to;
	void (*next) __P((struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *));
	void (*c_done)  __P((struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *));
a228 2
int   wdcdetach __P((struct channel_softc *, int));
int   wdcactivate __P((struct device *, enum devact));
d240 2
a241 4
int   wdc_wait_for_status __P((struct channel_softc *, int, int, int));
int   wdc_dmawait __P((struct channel_softc *, struct wdc_xfer *, int));
void  wdcbit_bucket __P((struct channel_softc *, int));

d253 1
a253 2
 */
#define wdcwait(chp, status, mask, timeout) ((wdc_wait_for_status((chp), (status), (mask), (timeout)) >= 0) ? 0 : -1)
a257 1

a270 1
void wdc_print_current_modes __P((struct channel_softc *));
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.7.2.1 2001/05/14 22:24:25 niklas Exp $     */
d42 3
d285 1
a295 2

int wdc_ioctl __P((struct ata_drive_datas *, u_long, caddr_t, int));
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.7.2.2 2001/07/04 10:41:20 niklas Exp $     */
d71 1
@


1.7.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d292 1
a292 1
int wdc_ioctl __P((struct ata_drive_datas *, u_long, caddr_t, int, struct proc *));
@


1.7.2.5
log
@Merge in -current from about a week ago
@
text
@a72 2
	u_int8_t ch_prev_log_status; /* previous logged value of status reg */
	u_int8_t ch_log_idx;
d169 4
a172 4
	int            (*dma_init)(void *, int, int, void *, size_t,
	                int);
	void           (*dma_start)(void *, int, int);
	int            (*dma_finish)(void *, int, int);
d182 2
a183 2
	int            (*claim_hw)(void *, int);
	void            (*free_hw)(void *);
d186 1
a186 1
	void 		(*set_modes)(struct channel_softc *);
d189 1
a189 1
	void            (*irqack)(struct channel_softc *);
d220 3
a222 3
	void (*c_start)(struct channel_softc *, struct wdc_xfer *);
	int  (*c_intr)(struct channel_softc *, struct wdc_xfer *, int);
        void (*c_kill_xfer)(struct channel_softc *, struct wdc_xfer *);
d227 4
a230 4
	void (*next)(struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *);
	void (*c_done)(struct channel_softc *, struct wdc_xfer *, int,
			 struct atapi_return_args *);
d241 7
a247 7
int   wdcprobe(struct channel_softc *);
void  wdcattach(struct channel_softc *);
int   wdcdetach(struct channel_softc *, int);
int   wdcactivate(struct device *, enum devact);
int   wdcintr(void *);
void  wdc_exec_xfer(struct channel_softc *, struct wdc_xfer *);
struct wdc_xfer *wdc_get_xfer(int); /* int = WDC_NOSLEEP/CANSLEEP */
d250 4
a253 4
void   wdc_free_xfer(struct channel_softc *, struct wdc_xfer *);
void  wdcstart(struct channel_softc *);
void  wdcrestart(void *);
int   wdcreset(struct channel_softc *, int);
d256 8
a263 8
int   wdc_wait_for_status(struct channel_softc *, int, int, int);
int   wdc_dmawait(struct channel_softc *, struct wdc_xfer *, int);
void  wdcbit_bucket(struct channel_softc *, int);

void  wdccommand(struct channel_softc *, u_int8_t, u_int8_t, u_int16_t,
	                  u_int8_t, u_int8_t, u_int8_t, u_int8_t);
void   wdccommandshort(struct channel_softc *, int, int);
void  wdctimeout(void *arg);
d265 2
a266 2
int	wdc_addref(struct channel_softc *);
void	wdc_delref(struct channel_softc *);
d281 1
a281 1
int   atapi_print(void *, const char *);
d283 3
a285 6
void wdc_disable_intr(struct channel_softc *);
void wdc_enable_intr(struct channel_softc *);
int wdc_select_drive(struct channel_softc *, int, int);
void wdc_set_drive(struct channel_softc *, int drive);
void wdc_output_bytes(struct ata_drive_datas *drvp, void *, unsigned int);
void wdc_input_bytes(struct ata_drive_datas *drvp, void *, unsigned int);
d287 2
a288 1
void wdc_print_current_modes(struct channel_softc *);
d290 1
a290 1
int wdc_ioctl(struct ata_drive_datas *, u_long, caddr_t, int, struct proc *);
d292 1
@


1.7.2.6
log
@Sync the SMP branch with 3.3
@
text
@a100 1
	wdr_lba_lo = 3,
a101 1
	wdr_lba_mi = 4,
a102 1
	wdr_lba_hi = 5,
a263 2
void  wdccommandext(struct channel_softc *, u_int8_t, u_int8_t, u_int64_t,
		    u_int16_t);
@


1.7.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d68 4
a71 5
#define WDCF_ACTIVE		0x01 /* channel is active */
#define WDCF_ONESLAVE		0x02 /* slave-only channel */
#define WDCF_IRQ_WAIT		0x10 /* controller is waiting for irq */
#define WDCF_DMA_WAIT		0x20 /* controller is waiting for DMA */
#define WDCF_VERBOSE_PROBE	0x40 /* verbose probe */
d81 1
a81 1
	 * are not independent.
d91 1
a91 1
#define _WDC_AUX     8
d94 1
a94 1
enum wdc_regs {
d115 1
a115 1
	void (*write_reg)(struct channel_softc *, enum wdc_regs reg,
d117 2
a118 2

	void (*read_raw_multi_2)(struct channel_softc *,
d133 1
a133 1
	((chp)->_vtbl->read_raw_multi_2)(chp, a, b)
d135 1
a135 1
	((chp)->_vtbl->write_raw_multi_2)(chp, a, b)
d146 2
a147 2
#define WDC_CAPABILITY_DATA16 0x0001	/* can do  16-bit data access */
#define WDC_CAPABILITY_DATA32 0x0002	/* can do 32-bit data access */
d149 5
a153 5
#define WDC_CAPABILITY_DMA    0x0008	/* DMA */
#define WDC_CAPABILITY_UDMA   0x0010	/* Ultra-DMA/33 */
#define WDC_CAPABILITY_HWLOCK 0x0020	/* Needs to lock HW */
#define WDC_CAPABILITY_ATA_NOSTREAM 0x0040 /* Don't use stream funcs on ATA */
#define WDC_CAPABILITY_ATAPI_NOSTREAM 0x0080 /* Don't use stream f on ATAPI */
d155 2
a156 2
#define WDC_CAPABILITY_PREATA 0x0200	/* ctrl can be a pre-ata one */
#define WDC_CAPABILITY_IRQACK 0x0400	/* callback to ack interrupt */
a158 1
#define WDC_CAPABILITY_SATA   0x2000	/* SATA controller */
d177 1
a177 1
	int            (*dma_finish)(void *, int, int, int);
d179 2
a180 3
#define WDC_DMA_READ	0x01
#define WDC_DMA_IRQW	0x02
#define WDC_DMA_LBA48	0x04
d182 3
a184 3
#define WDC_DMAST_NOIRQ	0x01 /* missing IRQ */
#define WDC_DMAST_ERR	0x02 /* DMA error */
#define WDC_DMAST_UNDER	0x04 /* DMA underrun */
d187 1
a187 1
	int             (*claim_hw)(void *, int);
d191 1
a191 1
	void            (*set_modes)(struct channel_softc *);
d204 4
a207 4
	volatile u_int c_flags;
#define C_ATAPI		0x0002 /* xfer is ATAPI request */
#define C_TIMEOU	0x0004 /* xfer processing timed out */
#define C_NEEDDONE	0x0010 /* need to call upper-level done */
d211 2
a212 2
#define C_MEDIA_ACCESS	0x0100 /* is a media access command */
#define C_POLL_MACHINE	0x0200 /* machine has a poll hander */
d230 1
a230 1
	volatile int endticks;
d236 1
a236 1

d253 2
a254 2
#define WDC_CANSLEEP	0x00
#define WDC_NOSLEEP	0x01
d259 2
a260 2
#define VERBOSE	1
#define SILENT	0 /* wdcreset will not print errors */
d266 1
a266 1
	u_int8_t, u_int8_t, u_int8_t, u_int8_t);
d268 2
a269 2
	u_int16_t);
void  wdccommandshort(struct channel_softc *, int, int);
d272 2
a273 2
int   wdc_addref(struct channel_softc *);
void  wdc_delref(struct channel_softc *);
d275 1
a275 1
/*
d281 1
a281 1
#define wait_for_unbusy(chp, timeout) wdcwait((chp), 0, 0, (timeout))
d300 1
@


1.7.2.8
log
@Merge with the trunk
@
text
@a165 2
	u_int16_t quirks;		/* per-device oddities */
#define WDC_QUIRK_NOSHORTDMA	0x0001	/* can't do short DMA transfers */
@


1.6
log
@

ATAPI Tape drive support. Should be considered experimental.

Major restructuring of the code path that sends ATAPI packet commands.
One set of functions works in polling, process, and interrupt contexts.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.5 1999/11/17 01:22:56 csapuntz Exp $     */
d211 1
a211 1
	u_int64_t endtime;
@


1.5
log
@

New interface to ATA registers that goes through the lower-level device
driver (pciide, wdc, etc.)

Remove #define WDCDEBUG from top of files

More fixes to ATAPISCSI logic:

Not all devices transition correctly between phases. Devices are supposed
to keep BSY high until they've set the registers to the next sensible
state. Some devices drop BSY and leave the registers in an old or
nonsense state. Our polling code is extremely sensitive to this
(though an early itnerrupt could also observe this). So, if the device is
in an unexpected state, the new polling code waits for a while in the hope
that it enters a better state.

This seems to fix many of the problems reported.

Also, there was a horrible bug which would cause sense to fail on a ATAPI
command that sent data to the drive
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.4 1999/10/29 01:15:15 deraadt Exp $     */
d191 2
d207 13
@


1.4
log
@reliability fixes from csapuntz; commit message replaced later with details
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.3 1999/10/09 03:42:04 csapuntz Exp $     */
d47 2
d50 2
d80 51
@


1.3
log
@

wdc layer work:
Separate wdc_probe_caps into wdc_probe_caps and wdc_print_caps for more
flexibility in printing capability information.

Get rid of wdc_final_attach.

Include name of device (e.g. cd0), if possible, on errors.

atapiscsi layer work:
Put a pointer to the SCSI device into ata_drive_datas' drv_softc field

Simplify, simplify, simplify. Got rid of a bunch of fields in atapiscsi_softc

Delay printing capabilities until we know the real device name (e.g. st0)
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.2 1999/07/22 02:54:06 csapuntz Exp $     */
d197 4
@


1.2
log
@

Create wdc_enable_intr, wdc_disable_intr, wdc_select_drive.

wdc_select_drive implements the drive selection protocol
as documented in the ATA-5 preliminary specs.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdcvar.h,v 1.1 1999/07/18 21:25:16 csapuntz Exp $     */
a39 2
struct atapiscsi_softc;

d64 1
a69 2
	struct atapiscsi_softc *ch_as;

a158 1
void  wdc_final_attach __P((struct channel_softc *));
a191 2
void wdc_atapibus_final_attach __P((struct channel_softc *));

@


1.1
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 1
/*      $OpenBSD: $     */
a39 6
#if 0
/* XXX for scsipi_adapter */
#include <dev/scsipi/scsipi_all.h>
#include <dev/scsipi/scsipiconf.h>
#endif

d199 4
@

