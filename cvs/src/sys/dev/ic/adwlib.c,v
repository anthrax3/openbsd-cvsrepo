head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.24
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.22
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.16
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.18
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.10
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.14
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.12
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.8
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.6
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.6
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.16
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.14
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.12
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.10
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.8
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2012.01.11.16.22.32;	author dhill;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.02.03.24.50;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.24.09.07.39;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.21.18.58.48;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.07.11.17.31.25;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.11.04.05.16;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.22.17.17.32;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.08.00.03.31;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.22.15.10.13;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.29.00.04.31;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.29.21.07.17;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.03.00.04.01;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.02.23.51.16;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.02.23.32.13;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.19.16.44.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.07.01.06.58;	author krw;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.02.05.22.20.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.11.17.06.14.58;	author downsj;	state Exp;
branches;
next	;

1.3.2.1
date	2000.02.20.11.56.58;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.05.14.22.23.21;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2003.03.28.00.38.11;	author niklas;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2004.02.19.10.56.15;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.21.54.23;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@ansify and de'register some prototypes

ok miod@@
@
text
@/*	$OpenBSD: adwlib.c,v 1.23 2011/04/07 15:30:16 miod Exp $ */
/* $NetBSD: adwlib.c,v 1.20 2000/07/04 04:17:03 itojun Exp $        */

/*
 * Low level routines for the Advanced Systems Inc. SCSI controllers chips
 *
 * Copyright (c) 1998, 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Author: Baldassare Dante Profeta <dante@@mclink.it>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Ported from:
 */
/*
 * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters
 * 
 * Copyright (c) 1995-2000 Advanced System Products, Inc.
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that redistributions of source
 * code retain the above copyright notice and this comment without
 * modification.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/queue.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/pci/pcidevs.h>

#include <dev/ic/adwlib.h>
#include <dev/microcode/adw/adwmcode.h>
#include <dev/ic/adw.h>


int AdwRamSelfTest(bus_space_tag_t, bus_space_handle_t, u_int8_t);
int AdwLoadMCode(bus_space_tag_t, bus_space_handle_t, u_int16_t *,
								u_int8_t);
int AdwASC3550Cabling(bus_space_tag_t, bus_space_handle_t, ADW_DVC_CFG *);
int AdwASC38C0800Cabling(bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *);
int AdwASC38C1600Cabling(bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *);

u_int16_t AdwGetEEPROMConfig(bus_space_tag_t, bus_space_handle_t,
     							ADW_EEPROM *);
void AdwSetEEPROMConfig(bus_space_tag_t, bus_space_handle_t,
					                 ADW_EEPROM *);
u_int16_t AdwReadEEPWord(bus_space_tag_t, bus_space_handle_t, int);
void AdwWaitEEPCmd(bus_space_tag_t, bus_space_handle_t);

void AdwInquiryHandling(ADW_SOFTC *, ADW_SCSI_REQ_Q *);

void AdwSleepMilliSecond(u_int32_t);
void AdwDelayMicroSecond(u_int32_t);


/*
 * EEPROM Configuration.
 *
 * All drivers should use this structure to set the default EEPROM
 * configuration. The BIOS now uses this structure when it is built.
 * Additional structure information can be found in adwlib.h where
 * the structure is defined.
 */
const static ADW_EEPROM adw_3550_Default_EEPROM = {
	ADW_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
	0x0000,			/* 01 cfg_msw */
	0xFFFF,			/* 02 disc_enable */
	0xFFFF,			/* 03 wdtr_able */
	{ 0xFFFF },		/* 04 sdtr_able */
	0xFFFF,			/* 05 start_motor */
	0xFFFF,			/* 06 tagqng_able */
	0xFFFF,			/* 07 bios_scan */
	0,			/* 08 scam_tolerant */
	7,			/* 09 adapter_scsi_id */
	0,			/*    bios_boot_delay */
	3,			/* 10 scsi_reset_delay */
	0,			/*    bios_id_lun */
	0,			/* 11 termination */
	0,			/*    reserved1 */
	0xFFE7,			/* 12 bios_ctrl */
	{ 0xFFFF },		/* 13 ultra_able */
	{ 0 },			/* 14 reserved2 */
	ADW_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
	ADW_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
	0,			/* 16 dvc_cntl */
	{ 0 },			/* 17 bug_fix */
	{ 0,0,0 },		/* 18-20 serial_number[3] */
	0,			/* 21 check_sum */
	{			/* 22-29 oem_name[16] */
	  0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0
	},
	0,			/* 30 dvc_err_code */
	0,			/* 31 adw_err_code */
	0,			/* 32 adw_err_addr */
	0,			/* 33 saved_dvc_err_code */
	0,			/* 34 saved_adw_err_code */
	0			/* 35 saved_adw_err_addr */
};

const static ADW_EEPROM adw_38C0800_Default_EEPROM = {
	ADW_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
	0x0000,			/* 01 cfg_msw */
	0xFFFF,			/* 02 disc_enable */
	0xFFFF,			/* 03 wdtr_able */
	{ 0x4444 },		/* 04 sdtr_speed1 */
	0xFFFF,			/* 05 start_motor */
	0xFFFF,			/* 06 tagqng_able */
	0xFFFF,			/* 07 bios_scan */
	0,			/* 08 scam_tolerant */
	7,			/* 09 adapter_scsi_id */
	0,			/*    bios_boot_delay */
	3,			/* 10 scsi_reset_delay */
	0,			/*    bios_id_lun */
	0,			/* 11 termination_se */
	0,			/*    termination_lvd */
	0xFFE7,			/* 12 bios_ctrl */
	{ 0x4444 },		/* 13 sdtr_speed2 */
	{ 0x4444 },		/* 14 sdtr_speed3 */
	ADW_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
	ADW_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
	0,			/* 16 dvc_cntl */
	{ 0x4444 },		/* 17 sdtr_speed4 */
	{ 0,0,0 },		/* 18-20 serial_number[3] */
	0,			/* 21 check_sum */
	{			/* 22-29 oem_name[16] */
	  0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0
	},
	0,			/* 30 dvc_err_code */
	0,			/* 31 adw_err_code */
	0,			/* 32 adw_err_addr */
	0,			/* 33 saved_dvc_err_code */
	0,			/* 34 saved_adw_err_code */
	0,			/* 35 saved_adw_err_addr */
	{			/* 36-55 reserved1[16] */
	  0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0,0,0
	},
	0,			/* 56 cisptr_lsw */
	0,			/* 57 cisprt_msw */
	PCI_VENDOR_ADVSYS,	/* 58 subsysvid */
	PCI_PRODUCT_ADVSYS_U2W,	/* 59 subsysid */
	{ 0,0,0,0 }		/* 60-63 reserved2[4] */
};

const static ADW_EEPROM adw_38C1600_Default_EEPROM = {
	ADW_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
	0x0000,			/* 01 cfg_msw */
	0xFFFF,			/* 02 disc_enable */
	0xFFFF,			/* 03 wdtr_able */
	{ 0x5555 },		/* 04 sdtr_speed1 */
	0xFFFF,			/* 05 start_motor */
	0xFFFF,			/* 06 tagqng_able */
	0xFFFF,			/* 07 bios_scan */
	0,			/* 08 scam_tolerant */
	7,			/* 09 adapter_scsi_id */
	0,			/*    bios_boot_delay */
	3,			/* 10 scsi_reset_delay */
	0,			/*    bios_id_lun */
	0,			/* 11 termination_se */
	0,			/*    termination_lvd */
	0xFFE7,			/* 12 bios_ctrl */
	{ 0x5555 },		/* 13 sdtr_speed2 */
	{ 0x5555 },		/* 14 sdtr_speed3 */
	ADW_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
	ADW_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
	0,			/* 16 dvc_cntl */
	{ 0x5555 },		/* 17 sdtr_speed4 */
	{ 0,0,0 },		/* 18-20 serial_number[3] */
	0,			/* 21 check_sum */
	{			/* 22-29 oem_name[16] */
	  0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0
	},
	0,			/* 30 dvc_err_code */
	0,			/* 31 adw_err_code */
	0,			/* 32 adw_err_addr */
	0,			/* 33 saved_dvc_err_code */
	0,			/* 34 saved_adw_err_code */
	0,			/* 35 saved_adw_err_addr */
	{			/* 36-55 reserved1[16] */
	  0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0,0,0
	},
	0,			/* 56 cisptr_lsw */
	0,			/* 57 cisprt_msw */
	PCI_VENDOR_ADVSYS,	/* 58 subsysvid */
	PCI_PRODUCT_ADVSYS_U3W, /* 59 subsysid */
	{ 0,0,0,0 }		/* 60-63 reserved2[4] */
};


/*
 * Read the board's EEPROM configuration. Set fields in ADW_SOFTC and
 * ADW_DVC_CFG based on the EEPROM settings. The chip is stopped while
 * all of this is done.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 *
 * Note: Chip is stopped on entry.
 */
int
AdwInitFromEEPROM(ADW_SOFTC *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	ADW_EEPROM		eep_config;
	u_int16_t		warn_code;
	u_int16_t		sdtr_speed = 0;
	u_int8_t		tid, termination;
	int			i, j;


	warn_code = 0;

	/*
	 * Read the board's EEPROM configuration.
	 *
	 * Set default values if a bad checksum is found.
	 *
	 * XXX - Don't handle big-endian access to EEPROM yet.
	 */
	if (AdwGetEEPROMConfig(iot, ioh, &eep_config) != eep_config.check_sum) {
		warn_code |= ADW_WARN_EEPROM_CHKSUM;

		/*
		 * Set EEPROM default values.
		 */
		switch(sc->chip_type) {
		case ADW_CHIP_ASC3550:
			eep_config = adw_3550_Default_EEPROM;
			break;
		case ADW_CHIP_ASC38C0800:
			eep_config = adw_38C0800_Default_EEPROM;
			break;
		case ADW_CHIP_ASC38C1600:
			eep_config = adw_38C1600_Default_EEPROM;

// XXX	  TODO!!!	if (ASC_PCI_ID2FUNC(sc->cfg.pci_slot_info) != 0) {
			if (sc->cfg.pci_slot_info != 0) {
				u_int8_t lsw_msb;

				lsw_msb = eep_config.cfg_lsw >> 8;
				/*
				 * Set Function 1 EEPROM Word 0 MSB
				 *
				 * Clear the BIOS_ENABLE (bit 14) and
				 * INTAB (bit 11) EEPROM bits.
				 *
				 * Disable Bit 14 (BIOS_ENABLE) to fix
				 * SPARC Ultra 60 and old Mac system booting
				 * problem. The Expansion ROM must
				 * be disabled in Function 1 for these systems.
				 */
				lsw_msb &= ~(((ADW_EEPROM_BIOS_ENABLE |
						ADW_EEPROM_INTAB) >> 8) & 0xFF);
				/*
				 * Set the INTAB (bit 11) if the GPIO 0 input
				 * indicates the Function 1 interrupt line is
				 * wired to INTA.
				 *
				 * Set/Clear Bit 11 (INTAB) from
				 * the GPIO bit 0 input:
				 *   1 - Function 1 intr line wired to INT A.
				 *   0 - Function 1 intr line wired to INT B.
				 *
				 * Note: Adapter boards always have Function 0
				 * wired to INTA.
				 * Put all 5 GPIO bits in input mode and then
				 * read their input values.
				 */
				ADW_WRITE_BYTE_REGISTER(iot, ioh,
							IOPB_GPIO_CNTL, 0);
				if (ADW_READ_BYTE_REGISTER(iot, ioh,
						IOPB_GPIO_DATA) & 0x01) {
					/*
					 * Function 1 interrupt wired to INTA;
					 * Set EEPROM bit.
					 */
					lsw_msb |= (ADW_EEPROM_INTAB >> 8)
							 & 0xFF;
				 }
				 eep_config.cfg_lsw &= 0x00FF;
				 eep_config.cfg_lsw |= lsw_msb << 8;
			}
			break;
		}

		/*
		 * Assume the 6 byte board serial number that was read
		 * from EEPROM is correct even if the EEPROM checksum
		 * failed.
		 */
		for (i=2, j=1; i>=0; i--, j++) {
		eep_config.serial_number[i] =
			AdwReadEEPWord(iot, ioh, ADW_EEP_DVC_CFG_END - j);
		}

		AdwSetEEPROMConfig(iot, ioh, &eep_config);
	}
	/*
	 * Set sc and sc->cfg variables from the EEPROM configuration
	 * that was read.
	 *
	 * This is the mapping of EEPROM fields to Adw Library fields.
	 */
	sc->wdtr_able = eep_config.wdtr_able;
	if (sc->chip_type == ADW_CHIP_ASC3550) {
		sc->sdtr_able = eep_config.sdtr1.sdtr_able;
		sc->ultra_able = eep_config.sdtr2.ultra_able;
	} else {
		sc->sdtr_speed1 = eep_config.sdtr1.sdtr_speed1;
		sc->sdtr_speed2 = eep_config.sdtr2.sdtr_speed2;
		sc->sdtr_speed3 = eep_config.sdtr3.sdtr_speed3;
		sc->sdtr_speed4 = eep_config.sdtr4.sdtr_speed4;
	}
	sc->ppr_able = 0;
	sc->tagqng_able = eep_config.tagqng_able;
	sc->cfg.disc_enable = eep_config.disc_enable;
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;
	sc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);
	sc->start_motor = eep_config.start_motor;
	sc->scsi_reset_wait = eep_config.scsi_reset_delay;
	sc->bios_ctrl = eep_config.bios_ctrl;
	sc->no_scam = eep_config.scam_tolerant;
	sc->cfg.serial1 = eep_config.serial_number[0];
	sc->cfg.serial2 = eep_config.serial_number[1];
	sc->cfg.serial3 = eep_config.serial_number[2];

	if (sc->chip_type == ADW_CHIP_ASC38C0800 ||
	    sc->chip_type == ADW_CHIP_ASC38C1600) {
		sc->sdtr_able = 0;
		for (tid = 0; tid <= ADW_MAX_TID; tid++) {
			if (tid == 0) {
				sdtr_speed = sc->sdtr_speed1;
			} else if (tid == 4) {
				sdtr_speed = sc->sdtr_speed2;
			} else if (tid == 8) {
				sdtr_speed = sc->sdtr_speed3;
			} else if (tid == 12) {
				sdtr_speed = sc->sdtr_speed4;
			}
			if (sdtr_speed & ADW_MAX_TID) {
				sc->sdtr_able |= (1 << tid);
			}
			sdtr_speed >>= 4;
		}
	}

	/*
	 * Set the host maximum queuing (max. 253, min. 16) and the per device
	 * maximum queuing (max. 63, min. 4).
	 */
	if (eep_config.max_host_qng > ADW_DEF_MAX_HOST_QNG) {
		eep_config.max_host_qng = ADW_DEF_MAX_HOST_QNG;
	} else if (eep_config.max_host_qng < ADW_DEF_MIN_HOST_QNG)
	{
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_host_qng == 0) {
			eep_config.max_host_qng = ADW_DEF_MAX_HOST_QNG;
		} else {
			eep_config.max_host_qng = ADW_DEF_MIN_HOST_QNG;
		}
	}

	if (eep_config.max_dvc_qng > ADW_DEF_MAX_DVC_QNG) {
		eep_config.max_dvc_qng = ADW_DEF_MAX_DVC_QNG;
	} else if (eep_config.max_dvc_qng < ADW_DEF_MIN_DVC_QNG) {
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_dvc_qng == 0) {
			eep_config.max_dvc_qng = ADW_DEF_MAX_DVC_QNG;
		} else {
			eep_config.max_dvc_qng = ADW_DEF_MIN_DVC_QNG;
		}
	}

	/*
	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
	 * set 'max_dvc_qng' to 'max_host_qng'.
	 */
	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
		eep_config.max_dvc_qng = eep_config.max_host_qng;
	}

	/*
	 * Set ADW_SOFTC 'max_host_qng' and 'max_dvc_qng'
	 * values based on possibly adjusted EEPROM values.
	 */
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;


	/*
	 * If the EEPROM 'termination' field is set to automatic (0), then set
	 * the ADW_SOFTC.cfg 'termination' field to automatic also.
	 *
	 * If the termination is specified with a non-zero 'termination'
	 * value check that a legal value is set and set the ADW_SOFTC.cfg
	 * 'termination' field appropriately.
	 */

	switch(sc->chip_type) {
	case ADW_CHIP_ASC3550:
		sc->cfg.termination = 0;	/* auto termination */
		switch(eep_config.termination_se) {
		case 3:
			/* Enable manual control with low on / high on. */
			sc->cfg.termination |= ADW_TERM_CTL_L;
		case 2:
			/* Enable manual control with low off / high on. */
			sc->cfg.termination |= ADW_TERM_CTL_H;
		case 1:
			/* Enable manual control with low off / high off. */
			sc->cfg.termination |= ADW_TERM_CTL_SEL;
		case 0:
			break;
		default:
			warn_code |= ADW_WARN_EEPROM_TERMINATION;
		}
		break;

	case ADW_CHIP_ASC38C0800:
	case ADW_CHIP_ASC38C1600:
		switch(eep_config.termination_se) {
		case 0:
			/* auto termination for SE */
			termination = 0;
			break;
		case 1:
			/* Enable manual control with low off / high off. */
			termination = 0;
			break;
		case 2:
			/* Enable manual control with low off / high on. */
			termination = ADW_TERM_SE_HI;
			break;
		case 3:
			/* Enable manual control with low on / high on. */
			termination = ADW_TERM_SE;
			break;
		default:
			/*
			 * The EEPROM 'termination_se' field contains a
			 * bad value. Use automatic termination instead.
			 */
			termination = 0;
			warn_code |= ADW_WARN_EEPROM_TERMINATION;
		}

		switch(eep_config.termination_lvd) {
		case 0:
			/* auto termination for LVD */
			sc->cfg.termination = termination;
			break;
		case 1:
			/* Enable manual control with low off / high off. */
			sc->cfg.termination = termination;
			break;
		case 2:
			/* Enable manual control with low off / high on. */
			sc->cfg.termination = termination | ADW_TERM_LVD_HI;
			break;
		case 3:
			/* Enable manual control with low on / high on. */
			sc->cfg.termination = termination | ADW_TERM_LVD;
			break;
		default:
			/*
			 * The EEPROM 'termination_lvd' field contains a
			 * bad value. Use automatic termination instead.
			 */
			sc->cfg.termination = termination;
			warn_code |= ADW_WARN_EEPROM_TERMINATION;
		}
		break;
	}

	return warn_code;
}


/*
 * Initialize the ASC-3550/ASC-38C0800/ASC-38C1600.
 *
 * On failure return the error code.
 */
int
AdwInitDriver(ADW_SOFTC *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t	error_code;
	int		word;
	int		i;
	u_int16_t	bios_mem[ADW_MC_BIOSLEN/2];	/* BIOS RISC Memory
								0x40-0x8F. */
	u_int16_t	wdtr_able = 0, sdtr_able, ppr_able, tagqng_able;
	u_int8_t	max_cmd[ADW_MAX_TID + 1];
	u_int8_t	tid;


	error_code = 0;

	/*
	 * Save the RISC memory BIOS region before writing the microcode.
	 * The BIOS may already be loaded and using its RISC LRAM region
	 * so its region must be saved and restored.
	 *
	 * Note: This code makes the assumption, which is currently true,
	 * that a chip reset does not clear RISC LRAM.
	 */
	for (i = 0; i < ADW_MC_BIOSLEN/2; i++) {
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_BIOSMEM+(2*i), bios_mem[i]);
	}

	/*
	 * Save current per TID negotiated values.
	 */
	switch (sc->chip_type) {
	case ADW_CHIP_ASC3550:
		if (bios_mem[(ADW_MC_BIOS_SIGNATURE-ADW_MC_BIOSMEM)/2]==0x55AA){

			u_int16_t  bios_version, major, minor;

			bios_version = bios_mem[(ADW_MC_BIOS_VERSION -
					ADW_MC_BIOSMEM) / 2];
			major = (bios_version  >> 12) & 0xF;
			minor = (bios_version  >> 8) & 0xF;
			if (major < 3 || (major == 3 && minor == 1)) {
			    /*
			     * BIOS 3.1 and earlier location of
			     * 'wdtr_able' variable.
			     */
			    ADW_READ_WORD_LRAM(iot, ioh, 0x120, wdtr_able);
			} else {
			    ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE,
					    wdtr_able);
			}
		}
		break;

	case ADW_CHIP_ASC38C1600:
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE, ppr_able);
		/* FALLTHROUGH */
	case ADW_CHIP_ASC38C0800:
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, wdtr_able);
		break;
	}
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, sdtr_able);
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE, tagqng_able);
	for (tid = 0; tid <= ADW_MAX_TID; tid++) {
		ADW_READ_BYTE_LRAM(iot, ioh, ADW_MC_NUMBER_OF_MAX_CMD + tid,
			max_cmd[tid]);
	}

	/*
	 * Perform a RAM Built-In Self Test
	 */
	if((error_code = AdwRamSelfTest(iot, ioh, sc->chip_type))) {
		return error_code;
	}

	/*
	 * Load the Microcode
	 */
	;
	if((error_code = AdwLoadMCode(iot, ioh, bios_mem, sc->chip_type))) {
		return error_code;
	}

	/*
	 * Read microcode version and date.
	 */
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_VERSION_DATE, sc->cfg.mcode_date);
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_VERSION_NUM, sc->cfg.mcode_version);

	/*
	 * If the PCI Configuration Command Register "Parity Error Response
	 * Control" Bit was clear (0), then set the microcode variable
	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
	 * to ignore DMA parity errors.
	 */
	if (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CONTROL_FLAG, word);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_CONTROL_FLAG,
					word | CONTROL_FLAG_IGNORE_PERR);
	}

	switch (sc->chip_type) {
	case ADW_CHIP_ASC3550:
		/*
		 * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a
		 * FIFO threshold of 128 bytes.
		 * This register is only accessible to the host.
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,
				START_CTL_EMFU | READ_CMD_MRM);
		break;

	case ADW_CHIP_ASC38C0800:
		/*
		 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
		 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
		 * cable detection and then we are able to read C_DET[3:0].
		 *
		 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
		 * Microcode Default Value' section below.
		 */
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,
				ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1)
				| ADW_DIS_TERM_DRV);

		/*
		 * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and
		 * START_CTL_TH [3:2] bits for the default FIFO threshold.
		 *
		 * Note: ASC-38C0800 FIFO threshold has been changed to
		 * 256 bytes.
		 *
		 * For DMA Errata #4 set the BC_THRESH_ENB bit.
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,
						BC_THRESH_ENB | FIFO_THRESH_80B
						| START_CTL_TH | READ_CMD_MRM);
		break;

	case ADW_CHIP_ASC38C1600:
		/*
		 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
		 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
		 * cable detection and then we are able to read C_DET[3:0].
		 *
		 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
		 * Microcode Default Value' section below.
		 */
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,
				ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1)
				| ADW_DIS_TERM_DRV);

		/*
		 * If the BIOS control flag AIPP (Asynchronous Information
		 * Phase Protection) disable bit is not set, then set the
		 * firmware 'control_flag' CONTROL_FLAG_ENABLE_AIPP bit to
		 * enable AIPP checking and encoding.
		 */
		if ((sc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0) {
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CONTROL_FLAG, word);
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_CONTROL_FLAG,
					word | CONTROL_FLAG_ENABLE_AIPP);
		}

		/*
		 * For ASC-38C1600 use DMA_CFG0 default values:
		 * FIFO_THRESH_80B [6:4], and START_CTL_TH [3:2].
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,
				FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
		break;
	}

	/*
	 * Microcode operating variables for WDTR, SDTR, and command tag
	 * queuing will be set in AdwInquiryHandling() based on what a
	 * device reports it is capable of in Inquiry byte 7.
	 *
	 * If SCSI Bus Resets have been disabled, then directly set
	 * SDTR and WDTR from the EEPROM configuration. This will allow
	 * the BIOS and warm boot to work without a SCSI bus hang on
	 * the Inquiry caused by host and target mismatched DTR values.
	 * Without the SCSI Bus Reset, before an Inquiry a device can't
	 * be assumed to be in Asynchronous, Narrow mode.
	 */
	if ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, sc->wdtr_able);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, sc->sdtr_able);
	}

	/*
	 * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,
	 * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID
	 * bitmask. These values determine the maximum SDTR speed negotiated
	 * with a device.
	 *
	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
	 * without determining here whether the device supports SDTR.
	 */
	switch (sc->chip_type) {
	case ADW_CHIP_ASC3550:
		word = 0;
		for (tid = 0; tid <= ADW_MAX_TID; tid++) {
			if (ADW_TID_TO_TIDMASK(tid) & sc->ultra_able) {
				/* Set Ultra speed for TID 'tid'. */
				word |= (0x3 << (4 * (tid % 4)));
			} else {
				/* Set Fast speed for TID 'tid'. */
				word |= (0x2 << (4 * (tid % 4)));
			}
			/* Check if done with sdtr_speed1. */
			if (tid == 3) {
				ADW_WRITE_WORD_LRAM(iot, ioh,
						ADW_MC_SDTR_SPEED1, word);
				word = 0;
			/* Check if done with sdtr_speed2. */
			} else if (tid == 7) {
				ADW_WRITE_WORD_LRAM(iot, ioh,
						ADW_MC_SDTR_SPEED2, word);
				word = 0;
			/* Check if done with sdtr_speed3. */
			} else if (tid == 11) {
				ADW_WRITE_WORD_LRAM(iot, ioh,
						ADW_MC_SDTR_SPEED3, word);
				word = 0;
			/* Check if done with sdtr_speed4. */
			} else if (tid == 15) {
				ADW_WRITE_WORD_LRAM(iot, ioh,
						ADW_MC_SDTR_SPEED4, word);
				/* End of loop. */
			}
		}

		/*
		 * Set microcode operating variable for the
		 * disconnect per TID bitmask.
		 */
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DISC_ENABLE,
							sc->cfg.disc_enable);
		break;

	case ADW_CHIP_ASC38C0800:
		/* FALLTHROUGH */
	case ADW_CHIP_ASC38C1600:
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DISC_ENABLE,
							sc->cfg.disc_enable);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_SPEED1,
							sc->sdtr_speed1);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_SPEED2,
							sc->sdtr_speed2);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_SPEED3,
							sc->sdtr_speed3);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_SPEED4,
							sc->sdtr_speed4);
		break;
	}


	/*
	 * Set SCSI_CFG0 Microcode Default Value.
	 *
	 * The microcode will set the SCSI_CFG0 register using this value
	 * after it is started below.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SCSI_CFG0,
		ADW_PARITY_EN | ADW_QUEUE_128 | ADW_SEL_TMO_LONG |
		ADW_OUR_ID_EN | sc->chip_scsi_id);


	switch(sc->chip_type) {
	case ADW_CHIP_ASC3550:
		error_code = AdwASC3550Cabling(iot, ioh, &sc->cfg);
		break;

	case ADW_CHIP_ASC38C0800:
		error_code = AdwASC38C0800Cabling(iot, ioh, &sc->cfg);
		break;

	case ADW_CHIP_ASC38C1600:
		error_code = AdwASC38C1600Cabling(iot, ioh, &sc->cfg);
		break;
	}
	if(error_code) {
		return error_code;
	}

	/*
	 * Set SEL_MASK Microcode Default Value
	 *
	 * The microcode will set the SEL_MASK register using this value
	 * after it is started below.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SEL_MASK,
		ADW_TID_TO_TIDMASK(sc->chip_scsi_id));

	/*
	 * Create and Initialize Host->RISC Carrier lists
	 */
	sc->carr_freelist = AdwInitCarriers(sc->sc_dmamap_carrier,
						sc->sc_control->carriers);

	/*
	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
	 */

	if ((sc->icq_sp = sc->carr_freelist) == NULL) {
		return ADW_IERR_NO_CARRIER;
	}
	sc->carr_freelist = ADW_CARRIER_VADDR(sc,
			ADW_GET_CARRP(sc->icq_sp->next_ba));

	/*
	 * The first command issued will be placed in the stopper carrier.
	 */
	sc->icq_sp->next_ba = ADW_CQ_STOPPER;

	/*
	 * Set RISC ICQ physical address start value.
	 */
	ADW_WRITE_DWORD_LRAM(iot, ioh, ADW_MC_ICQ, sc->icq_sp->carr_ba);

	/*
	 * Initialize the COMMA register to the same value otherwise
	 * the RISC will prematurely detect a command is available.
	 */
	if(sc->chip_type == ADW_CHIP_ASC38C1600) {
		ADW_WRITE_DWORD_REGISTER(iot, ioh, IOPDW_COMMA,
							sc->icq_sp->carr_ba);
	}

	/*
	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
	 */
	if ((sc->irq_sp = sc->carr_freelist) == NULL) {
		return ADW_IERR_NO_CARRIER;
	}
	sc->carr_freelist = ADW_CARRIER_VADDR(sc,
			ADW_GET_CARRP(sc->irq_sp->next_ba));

	/*
	 * The first command completed by the RISC will be placed in
	 * the stopper.
	 *
	 * Note: Set 'next_ba' to ADW_CQ_STOPPER. When the request is
	 * completed the RISC will set the ADW_RQ_DONE bit.
	 */
	sc->irq_sp->next_ba = ADW_CQ_STOPPER;

	/*
	 * Set RISC IRQ physical address start value.
	 */
	ADW_WRITE_DWORD_LRAM(iot, ioh, ADW_MC_IRQ, sc->irq_sp->carr_ba);
	sc->carr_pending_cnt = 0;

	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,
		(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CODE_BEGIN_ADDR, word);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);

	/* finally, finally, gentlemen, start your engine */
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);

	/*
	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
	 * Resets should be performed. The RISC has to be running
	 * to issue a SCSI Bus Reset.
	 */
	if (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
	{
		/*
		 * If the BIOS Signature is present in memory, restore the
		 * BIOS Handshake Configuration Table and do not perform
		 * a SCSI Bus Reset.
		 */
		if (bios_mem[(ADW_MC_BIOS_SIGNATURE - ADW_MC_BIOSMEM)/2] ==
				0x55AA) {
			/*
			 * Restore per TID negotiated values.
			 */
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE,
					wdtr_able);
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE,
					sdtr_able);
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE,
					tagqng_able);
			for (tid = 0; tid <= ADW_MAX_TID; tid++) {
				ADW_WRITE_BYTE_LRAM(iot, ioh,
						ADW_MC_NUMBER_OF_MAX_CMD + tid,
						max_cmd[tid]);
			}
		} else {
			if (AdwResetCCB(sc) != ADW_TRUE) {
				error_code = ADW_WARN_BUSRESET_ERROR;
			}
		}
	}

	return error_code;
}


int
AdwRamSelfTest(bus_space_tag_t iot, bus_space_handle_t ioh, u_int8_t chip_type)
{
	int		i;
	u_int8_t	byte;


	if ((chip_type == ADW_CHIP_ASC38C0800) ||
	    (chip_type == ADW_CHIP_ASC38C1600)) {
		/*
		 * RAM BIST (RAM Built-In Self Test)
		 *
		 * Address : I/O base + offset 0x38h register (byte).
		 * Function: Bit 7-6(RW) : RAM mode
		 *			    Normal Mode   : 0x00
		 *			    Pre-test Mode : 0x40
		 *			    RAM Test Mode : 0x80
		 *	     Bit 5	 : unused
		 *	     Bit 4(RO)   : Done bit
		 *	     Bit 3-0(RO) : Status
		 *			    Host Error    : 0x08
		 *			    Int_RAM Error : 0x04
		 *			    RISC Error    : 0x02
		 *			    SCSI Error    : 0x01
		 *			    No Error	  : 0x00
		 *
		 * Note: RAM BIST code should be put right here, before loading
		 * the microcode and after saving the RISC memory BIOS region.
		 */

		/*
		 * LRAM Pre-test
		 *
		 * Write PRE_TEST_MODE (0x40) to register and wait for
		 * 10 milliseconds.
		 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05),
		 * return an error. Reset to NORMAL_MODE (0x00) and do again.
		 * If cannot reset to NORMAL_MODE, return an error too.
		 */
		for (i = 0; i < 2; i++) {
			ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST,
					PRE_TEST_MODE);
			 /* Wait for 10ms before reading back. */
			AdwSleepMilliSecond(10);
			byte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);
			if ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) !=
					PRE_TEST_VALUE) {
				return ADW_IERR_BIST_PRE_TEST;
			}

			ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST,
								NORMAL_MODE);
			/* Wait for 10ms before reading back. */
			AdwSleepMilliSecond(10);
			if (ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST)
			    != NORMAL_VALUE) {
				return ADW_IERR_BIST_PRE_TEST;
			}
		}

		/*
		 * LRAM Test - It takes about 1.5 ms to run through the test.
		 *
		 * Write RAM_TEST_MODE (0x80) to register and wait for
		 * 10 milliseconds.
		 * If Done bit not set or Status not 0, save register byte,
		 * set the err_code, and return an error.
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, RAM_TEST_MODE);
		/* Wait for 10ms before checking status. */
		AdwSleepMilliSecond(10);

		byte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);
		if ((byte & RAM_TEST_DONE)==0 || (byte & RAM_TEST_STATUS)!=0) {
			/* Get here if Done bit not set or Status not 0. */
			return ADW_IERR_BIST_RAM_TEST;
		}

		/* We need to reset back to normal mode after LRAM test passes*/
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);
	}

	return 0;
}


int
AdwLoadMCode(bus_space_tag_t iot, bus_space_handle_t ioh, u_int16_t *bios_mem,
    u_int8_t chip_type)
{
	u_int8_t	*mcode_data = NULL;
	u_int32_t	 mcode_chksum = 0;
	u_int16_t	 mcode_size = 0;
	u_int32_t	sum;
	u_int16_t	code_sum;
	int		begin_addr;
	int		end_addr;
	int		word;
	int		adw_memsize = 0;
	int		adw_mcode_expanded_size;
	int		i, j;


	switch(chip_type) {
	case ADW_CHIP_ASC3550:
		mcode_data = (u_int8_t *)adw_asc3550_mcode_data.mcode_data;
		mcode_chksum = (u_int32_t)adw_asc3550_mcode_data.mcode_chksum;
		mcode_size = (u_int16_t)adw_asc3550_mcode_data.mcode_size;
		adw_memsize = ADW_3550_MEMSIZE;
		break;

	case ADW_CHIP_ASC38C0800:
		mcode_data = (u_int8_t *)adw_asc38C0800_mcode_data.mcode_data;
		mcode_chksum =(u_int32_t)adw_asc38C0800_mcode_data.mcode_chksum;
		mcode_size = (u_int16_t)adw_asc38C0800_mcode_data.mcode_size;
		adw_memsize = ADW_38C0800_MEMSIZE;
		break;

	case ADW_CHIP_ASC38C1600:
		mcode_data = (u_int8_t *)adw_asc38C1600_mcode_data.mcode_data;
		mcode_chksum =(u_int32_t)adw_asc38C1600_mcode_data.mcode_chksum;
		mcode_size = (u_int16_t)adw_asc38C1600_mcode_data.mcode_size;
		adw_memsize = ADW_38C1600_MEMSIZE;
		break;
	}

	/*
	 * Write the microcode image to RISC memory starting at address 0.
	 */
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);

	/* Assume the following compressed format of the microcode buffer:
	 *
	 *  254 word (508 byte) table indexed by byte code followed
	 *  by the following byte codes:
	 *
	 *    1-Byte Code:
	 *	00: Emit word 0 in table.
	 *	01: Emit word 1 in table.
	 *	.
	 *	FD: Emit word 253 in table.
	 *
	 *    Multi-Byte Code:
	 *	FE WW WW: (3 byte code) Word to emit is the next word WW WW.
	 *	FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
	 */
	word = 0;
	for (i = 253 * 2; i < mcode_size; i++) {
		if (mcode_data[i] == 0xff) {
			for (j = 0; j < mcode_data[i + 1]; j++) {
				ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,
				  (((u_int16_t)mcode_data[i + 3] << 8) |
				  mcode_data[i + 2]));
				word++;
			}
			i += 3;
		} else if (mcode_data[i] == 0xfe) {
			ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,
			    (((u_int16_t)mcode_data[i + 2] << 8) |
			    mcode_data[i + 1]));
			i += 2;
			word++;
		} else {
			ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)
			 mcode_data[(mcode_data[i] * 2) + 1] <<8) |
			 mcode_data[mcode_data[i] * 2]));
			word++;
		}
	}

	/*
	 * Set 'word' for later use to clear the rest of memory and save
	 * the expanded mcode size.
	 */
	word *= 2;
	adw_mcode_expanded_size = word;

	/*
	 * Clear the rest of the Internal RAM.
	 */
	for (; word < adw_memsize; word += 2) {
		ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);
	}

	/*
	 * Verify the microcode checksum.
	 */
	sum = 0;
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);

	for (word = 0; word < adw_mcode_expanded_size; word += 2) {
		sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);
	}

	if (sum != mcode_chksum) {
		return ADW_IERR_MCODE_CHKSUM;
	}

	/*
	 * Restore the RISC memory BIOS region.
	 */
	for (i = 0; i < ADW_MC_BIOSLEN/2; i++) {
		if(chip_type == ADW_CHIP_ASC3550) {
			ADW_WRITE_BYTE_LRAM(iot, ioh, ADW_MC_BIOSMEM + (2 * i),
								bios_mem[i]);
		} else {
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_BIOSMEM + (2 * i),
								bios_mem[i]);
		}
	}

	/*
	 * Calculate and write the microcode code checksum to the microcode
	 * code checksum location ADW_MC_CODE_CHK_SUM (0x2C).
	 */
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CODE_BEGIN_ADDR, begin_addr);
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CODE_END_ADDR, end_addr);
	code_sum = 0;
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);
	for (word = begin_addr; word < end_addr; word += 2) {
		code_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);
	}
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_CODE_CHK_SUM, code_sum);

	/*
	 * Set the chip type.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_CHIP_TYPE, chip_type);

	return 0;
}


int
AdwASC3550Cabling(bus_space_tag_t iot, bus_space_handle_t ioh, ADW_DVC_CFG *cfg)
{
	u_int16_t	scsi_cfg1;


	/*
	 * Determine SCSI_CFG1 Microcode Default Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
	 */

	/* Read current SCSI_CFG1 Register value. */
	scsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);

	/*
	 * If all three connectors are in use in ASC3550, return an error.
	 */
	if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
	     (scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {
		return ADW_IERR_ILLEGAL_CONNECTION;
	}

	/*
	 * If the cable is reversed all of the SCSI_CTRL register signals
	 * will be set. Check for and return an error if this condition is
	 * found.
	 */
	if ((ADW_READ_WORD_REGISTER(iot,ioh, IOPW_SCSI_CTRL) & 0x3F07)==0x3F07){
		return ADW_IERR_REVERSED_CABLE;
	}

	/*
	 * If this is a differential board and a single-ended device
	 * is attached to one of the connectors, return an error.
	 */
	if ((scsi_cfg1 & ADW_DIFF_MODE) &&
	    (scsi_cfg1 & ADW_DIFF_SENSE) == 0) {
		return ADW_IERR_SINGLE_END_DEVICE;
	}

	/*
	 * If automatic termination control is enabled, then set the
	 * termination value based on a table listed in a_condor.h.
	 *
	 * If manual termination was specified with an EEPROM setting
	 * then 'termination' was set-up in AdwInitFromEEPROM() and
	 * is ready to be 'ored' into SCSI_CFG1.
	 */
	if (cfg->termination == 0) {
		/*
		 * The software always controls termination by setting
		 * TERM_CTL_SEL.
		 * If TERM_CTL_SEL were set to 0, the hardware would set
		 * termination.
		 */
		cfg->termination |= ADW_TERM_CTL_SEL;

		switch(scsi_cfg1 & ADW_CABLE_DETECT) {
			/* TERM_CTL_H: on, TERM_CTL_L: on */
			case 0x3: case 0x7: case 0xB:
			case 0xD: case 0xE: case 0xF:
				cfg->termination |=
				(ADW_TERM_CTL_H | ADW_TERM_CTL_L);
				break;

			/* TERM_CTL_H: on, TERM_CTL_L: off */
			case 0x1: case 0x5: case 0x9:
			case 0xA: case 0xC:
				cfg->termination |= ADW_TERM_CTL_H;
				break;

			/* TERM_CTL_H: off, TERM_CTL_L: off */
			case 0x2: case 0x6:
				break;
		}
	}

	/*
	 * Clear any set TERM_CTL_H and TERM_CTL_L bits.
	 */
	scsi_cfg1 &= ~ADW_TERM_CTL;

	/*
	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then
	 * set 'scsi_cfg1'. The TERM_POL bit does not need to be
	 * referenced, because the hardware internally inverts
	 * the Termination High and Low bits if TERM_POL is set.
	 */
	scsi_cfg1 |= (ADW_TERM_CTL_SEL | (~cfg->termination & ADW_TERM_CTL));

	/*
	 * Set SCSI_CFG1 Microcode Default Value
	 *
	 * Set filter value and possibly modified termination control
	 * bits in the Microcode SCSI_CFG1 Register Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SCSI_CFG1,
						ADW_FLTR_DISABLE | scsi_cfg1);

	/*
	 * Set MEM_CFG Microcode Default Value
	 *
	 * The microcode will set the MEM_CFG register using this value
	 * after it is started below.
	 *
	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
	 * are defined.
	 *
	 * ASC-3550 has 8KB internal memory.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_MEM_CFG,
						ADW_BIOS_EN | ADW_RAM_SZ_8KB);

	return 0;
}


int
AdwASC38C0800Cabling(bus_space_tag_t iot, bus_space_handle_t ioh,
    ADW_DVC_CFG *cfg)
{
	u_int16_t	scsi_cfg1;


	/*
	 * Determine SCSI_CFG1 Microcode Default Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
	 */

	/* Read current SCSI_CFG1 Register value. */
	scsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);

	/*
	 * If the cable is reversed all of the SCSI_CTRL register signals
	 * will be set. Check for and return an error if this condition is
	 * found.
	 */
	if ((ADW_READ_WORD_REGISTER(iot,ioh, IOPW_SCSI_CTRL) & 0x3F07)==0x3F07){
		return ADW_IERR_REVERSED_CABLE;
	}

	/*
	 * All kind of combinations of devices attached to one of four
	 * connectors are acceptable except HVD device attached.
	 * For example, LVD device can be attached to SE connector while
	 * SE device attached to LVD connector.
	 * If LVD device attached to SE connector, it only runs up to
	 * Ultra speed.
	 *
	 * If an HVD device is attached to one of LVD connectors, return
	 * an error.
	 * However, there is no way to detect HVD device attached to
	 * SE connectors.
	 */
	if (scsi_cfg1 & ADW_HVD) {
		return ADW_IERR_HVD_DEVICE;
	}

	/*
	 * If either SE or LVD automatic termination control is enabled, then
	 * set the termination value based on a table listed in a_condor.h.
	 *
	 * If manual termination was specified with an EEPROM setting then
	 * 'termination' was set-up in AdwInitFromEEPROM() and is ready
	 * to be 'ored' into SCSI_CFG1.
	 */
	if ((cfg->termination & ADW_TERM_SE) == 0) {
		/* SE automatic termination control is enabled. */
		switch(scsi_cfg1 & ADW_C_DET_SE) {
			/* TERM_SE_HI: on, TERM_SE_LO: on */
			case 0x1: case 0x2: case 0x3:
				cfg->termination |= ADW_TERM_SE;
				break;

			/* TERM_SE_HI: on, TERM_SE_LO: off */
			case 0x0:
				cfg->termination |= ADW_TERM_SE_HI;
				break;
		}
	}

	if ((cfg->termination & ADW_TERM_LVD) == 0) {
		/* LVD automatic termination control is enabled. */
		switch(scsi_cfg1 & ADW_C_DET_LVD) {
			/* TERM_LVD_HI: on, TERM_LVD_LO: on */
			case 0x4: case 0x8: case 0xC:
				cfg->termination |= ADW_TERM_LVD;
				break;

			/* TERM_LVD_HI: off, TERM_LVD_LO: off */
			case 0x0:
				break;
		}
	}

	/*
	 * Clear any set TERM_SE and TERM_LVD bits.
	 */
	scsi_cfg1 &= (~ADW_TERM_SE & ~ADW_TERM_LVD);

	/*
	 * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.
	 */
	scsi_cfg1 |= (~cfg->termination & 0xF0);

	/*
	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and
	 * HVD/LVD/SE bits and set possibly modified termination control bits
	 * in the Microcode SCSI_CFG1 Register Value.
	 */
	scsi_cfg1 &= (~ADW_BIG_ENDIAN & ~ADW_DIS_TERM_DRV &
					~ADW_TERM_POL & ~ADW_HVD_LVD_SE);

	/*
	 * Set SCSI_CFG1 Microcode Default Value
	 *
	 * Set possibly modified termination control and reset DIS_TERM_DRV
	 * bits in the Microcode SCSI_CFG1 Register Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);

	/*
	 * Set MEM_CFG Microcode Default Value
	 *
	 * The microcode will set the MEM_CFG register using this value
	 * after it is started below.
	 *
	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
	 * are defined.
	 *
	 * ASC-38C0800 has 16KB internal memory.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_MEM_CFG,
						ADW_BIOS_EN | ADW_RAM_SZ_16KB);

	return 0;
}


int
AdwASC38C1600Cabling(bus_space_tag_t iot, bus_space_handle_t ioh,
    ADW_DVC_CFG *cfg)
{
	u_int16_t	scsi_cfg1;


	/*
	 * Determine SCSI_CFG1 Microcode Default Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
	 * Each ASC-38C1600 function has only two cable detect bits.
	 * The bus mode override bits are in IOPB_SOFT_OVER_WR.
	 */

	/* Read current SCSI_CFG1 Register value. */
	scsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);

	/*
	 * If the cable is reversed all of the SCSI_CTRL register signals
	 * will be set. Check for and return an error if this condition is
	 * found.
	 */
	if ((ADW_READ_WORD_REGISTER(iot,ioh, IOPW_SCSI_CTRL) & 0x3F07)==0x3F07){
		return ADW_IERR_REVERSED_CABLE;
	}

	/*
	 * Each ASC-38C1600 function has two connectors. Only an HVD device
	 * cannot be connected to either connector. An LVD device or SE device
	 * may be connected to either connector. If an SE device is connected,
	 * then at most Ultra speed (20 MHz) can be used on both connectors.
	 *
	 * If an HVD device is attached, return an error.
	 */
	if (scsi_cfg1 & ADW_HVD) {
		return ADW_IERR_HVD_DEVICE;
	}

	/*
	 * Each function in the ASC-38C1600 uses only the SE cable detect and
	 * termination because there are two connectors for each function.
	 * Each function may use either LVD or SE mode.
	 * Corresponding the SE automatic termination control EEPROM bits are
	 * used for each function.
	 * Each function has its own EEPROM. If SE automatic control is enabled
	 * for the function, then set the termination value based on a table
	 * listed in adwlib.h.
	 *
	 * If manual termination is specified in the EEPROM for the function,
	 * then 'termination' was set-up in AdwInitFromEEPROM() and is
	 * ready to be 'ored' into SCSI_CFG1.
	 */
	if ((cfg->termination & ADW_TERM_SE) == 0) {
		/* SE automatic termination control is enabled. */
		switch(scsi_cfg1 & ADW_C_DET_SE) {
			/* TERM_SE_HI: on, TERM_SE_LO: on */
			case 0x1: case 0x2: case 0x3:
				cfg->termination |= ADW_TERM_SE;
				break;

			case 0x0:
	/* !!!!TODO!!!! */
//				if (ASC_PCI_ID2FUNC(cfg->pci_slot_info) == 0) {
				/* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */
//				}
//				else
//				{
				/* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */
					cfg->termination |= ADW_TERM_SE_HI;
//				}
				break;
			}
	}

	/*
	 * Clear any set TERM_SE bits.
	 */
	scsi_cfg1 &= ~ADW_TERM_SE;

	/*
	 * Invert the TERM_SE bits and then set 'scsi_cfg1'.
	 */
	scsi_cfg1 |= (~cfg->termination & ADW_TERM_SE);

	/*
	 * Clear Big Endian and Terminator Polarity bits and set possibly
	 * modified termination control bits in the Microcode SCSI_CFG1
	 * Register Value.
	 */
	scsi_cfg1 &= (~ADW_BIG_ENDIAN & ~ADW_DIS_TERM_DRV & ~ADW_TERM_POL);

	/*
	 * Set SCSI_CFG1 Microcode Default Value
	 *
	 * Set possibly modified termination control bits in the Microcode
	 * SCSI_CFG1 Register Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);

	/*
	 * Set MEM_CFG Microcode Default Value
	 *
	 * The microcode will set the MEM_CFG register using this value
	 * after it is started below.
	 *
	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
	 * are defined.
	 *
	 * ASC-38C1600 has 32KB internal memory.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_MEM_CFG,
						ADW_BIOS_EN | ADW_RAM_SZ_32KB);

	return 0;
}


/*
 * Read EEPROM configuration into the specified buffer.
 *
 * Return a checksum based on the EEPROM configuration read.
 */
u_int16_t
AdwGetEEPROMConfig(bus_space_tag_t iot, bus_space_handle_t ioh,
    ADW_EEPROM *cfg_buf)
{
	u_int16_t	       wval, chksum;
	u_int16_t	       *wbuf;
	int		    eep_addr;


	wbuf = (u_int16_t *) cfg_buf;
	chksum = 0;

	for (eep_addr = ADW_EEP_DVC_CFG_BEGIN;
		eep_addr < ADW_EEP_DVC_CFG_END;
		eep_addr++, wbuf++) {
		wval = AdwReadEEPWord(iot, ioh, eep_addr);
		chksum += wval;
		*wbuf = wval;
	}

	*wbuf = AdwReadEEPWord(iot, ioh, eep_addr);
	wbuf++;
	for (eep_addr = ADW_EEP_DVC_CTL_BEGIN;
			eep_addr < ADW_EEP_MAX_WORD_ADDR;
			eep_addr++, wbuf++) {
		*wbuf = AdwReadEEPWord(iot, ioh, eep_addr);
	}

	return chksum;
}


/*
 * Read the EEPROM from specified location
 */
u_int16_t
AdwReadEEPWord(bus_space_tag_t iot, bus_space_handle_t ioh, int eep_word_addr)
{
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,
		ADW_EEP_CMD_READ | eep_word_addr);
	AdwWaitEEPCmd(iot, ioh);

	return ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);
}


/*
 * Wait for EEPROM command to complete
 */
void
AdwWaitEEPCmd(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	int eep_delay_ms;


	for (eep_delay_ms = 0; eep_delay_ms < ADW_EEP_DELAY_MS; eep_delay_ms++){
		if (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &
				ADW_EEP_CMD_DONE) {
			break;
		}
		AdwSleepMilliSecond(1);
	}

	ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD);
}


/*
 * Write the EEPROM from 'cfg_buf'.
 */
void
AdwSetEEPROMConfig(bus_space_tag_t iot, bus_space_handle_t ioh,
    ADW_EEPROM *cfg_buf)
{
	u_int16_t *wbuf;
	u_int16_t addr, chksum;


	wbuf = (u_int16_t *) cfg_buf;
	chksum = 0;

	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ADW_EEP_CMD_WRITE_ABLE);
	AdwWaitEEPCmd(iot, ioh);

	/*
	 * Write EEPROM from word 0 to word 20
	 */
	for (addr = ADW_EEP_DVC_CFG_BEGIN;
	     addr < ADW_EEP_DVC_CFG_END; addr++, wbuf++) {
		chksum += *wbuf;
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,
				ADW_EEP_CMD_WRITE | addr);
		AdwWaitEEPCmd(iot, ioh);
		AdwSleepMilliSecond(ADW_EEP_DELAY_MS);
	}

	/*
	 * Write EEPROM checksum at word 21
	 */
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,
			ADW_EEP_CMD_WRITE | addr);
	AdwWaitEEPCmd(iot, ioh);
	wbuf++;        /* skip over check_sum */

	/*
	 * Write EEPROM OEM name at words 22 to 29
	 */
	for (addr = ADW_EEP_DVC_CTL_BEGIN;
	     addr < ADW_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,
				ADW_EEP_CMD_WRITE | addr);
		AdwWaitEEPCmd(iot, ioh);
	}

	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,
			ADW_EEP_CMD_WRITE_DISABLE);
	AdwWaitEEPCmd(iot, ioh);

	return;
}


/*
 * AdwExeScsiQueue() - Send a request to the RISC microcode program.
 *
 *   Allocate a carrier structure, point the carrier to the ADW_SCSI_REQ_Q,
 *   add the carrier to the ICQ (Initiator Command Queue), and tickle the
 *   RISC to notify it a new command is ready to be executed.
 *
 * If 'done_status' is not set to QD_DO_RETRY, then 'error_retry' will be
 * set to SCSI_MAX_RETRY.
 *
 * Return:
 *      ADW_SUCCESS(1) - The request was successfully queued.
 *      ADW_BUSY(0) -    Resource unavailable; Retry again after pending
 *                       request completes.
 *      ADW_ERROR(-1) -  Invalid ADW_SCSI_REQ_Q request structure
 *                       host IC error.
 */
int
AdwExeScsiQueue(ADW_SOFTC *sc, ADW_SCSI_REQ_Q *scsiq)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	ADW_CCB		*ccb;
	long		req_size;
	u_int32_t	req_paddr;
	ADW_CARRIER	*new_carrp;

	/*
	 * The ADW_SCSI_REQ_Q 'target_id' field should never exceed ADW_MAX_TID.
	 */
	if (scsiq->target_id > ADW_MAX_TID) {
		scsiq->host_status = QHSTA_M_INVALID_DEVICE;
		scsiq->done_status = QD_WITH_ERROR;
		return ADW_ERROR;
	}

	/*
	 * Beginning of CRITICAL SECTION: ASSUME splbio() in effect
	 */
	
	ccb = adw_ccb_phys_kv(sc, scsiq->ccb_ptr);

	/*
	 * Allocate a carrier and initialize fields.
	 */
	if ((new_carrp = sc->carr_freelist) == NULL) {
		return ADW_BUSY;
	}
	sc->carr_freelist = ADW_CARRIER_VADDR(sc,
			ADW_GET_CARRP(new_carrp->next_ba));
	sc->carr_pending_cnt++;

	/*
	 * Set the carrier to be a stopper by setting 'next_ba'
	 * to the stopper value. The current stopper will be changed
	 * below to point to the new stopper.
	 */
	new_carrp->next_ba = ADW_CQ_STOPPER;

	req_size = sizeof(ADW_SCSI_REQ_Q);
	req_paddr = sc->sc_dmamap_control->dm_segs[0].ds_addr +
		ADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsiq);

	/* Save physical address of ADW_SCSI_REQ_Q and Carrier. */
	scsiq->scsiq_rptr = req_paddr;

	/*
	 * Every ADW_SCSI_REQ_Q.carr_ba is byte swapped to little-endian
	 * order during initialization.
	 */
	scsiq->carr_ba = sc->icq_sp->carr_ba;
	scsiq->carr_va = sc->icq_sp->carr_ba;

	/*
	 * Use the current stopper to send the ADW_SCSI_REQ_Q command to
	 * the microcode. The newly allocated stopper will become the new
	 * stopper.
	 */
	sc->icq_sp->areq_ba = req_paddr;

	/*
	 * Set the 'next_ba' pointer for the old stopper to be the
	 * physical address of the new stopper. The RISC can only
	 * follow physical addresses.
	 */
	sc->icq_sp->next_ba = new_carrp->carr_ba;

#if ADW_DEBUG
	printf("icq 0x%x, 0x%x, 0x%x, 0x%x\n",
			sc->icq_sp->carr_id,
			sc->icq_sp->carr_ba,
			sc->icq_sp->areq_ba,
			sc->icq_sp->next_ba);
#endif
	/*
	 * Set the host adapter stopper pointer to point to the new carrier.
	 */
	sc->icq_sp = new_carrp;

	if (sc->chip_type == ADW_CHIP_ASC3550 ||
	    sc->chip_type == ADW_CHIP_ASC38C0800) {
		/*
		 * Tickle the RISC to tell it to read its Command Queue Head
		 * pointer.
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADW_TICKLE_A);
		if (sc->chip_type == ADW_CHIP_ASC3550) {
			/*
			 * Clear the tickle value. In the ASC-3550 the RISC flag
			 * command 'clr_tickle_a' does not work unless the host
			 * value is cleared.
			 */
			ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE,
					ADW_TICKLE_NOP);
		}
	} else if (sc->chip_type == ADW_CHIP_ASC38C1600) {
		/*
		 * Notify the RISC a carrier is ready by writing the physical
		 * address of the new carrier stopper to the COMMA register.
		 */
		ADW_WRITE_DWORD_REGISTER(iot, ioh, IOPDW_COMMA,
				new_carrp->carr_ba);
	}

	/*
	 * End of CRITICAL SECTION: Must be protected within splbio/splx pair
	 */
	
	return ADW_SUCCESS;
}


void
AdwResetChip(bus_space_tag_t iot, bus_space_handle_t ioh)
{

	/*
	 * Reset Chip.
	 */
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,
			ADW_CTRL_REG_CMD_RESET);
	AdwSleepMilliSecond(100);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,
			ADW_CTRL_REG_CMD_WR_IO_REG);
}


/*
 * Reset SCSI Bus and purge all outstanding requests.
 *
 * Return Value:
 *      ADW_TRUE(1) -   All requests are purged and SCSI Bus is reset.
 *      ADW_FALSE(0) -  Microcode command failed.
 *      ADW_ERROR(-1) - Microcode command timed-out. Microcode or IC
 *                      may be hung which requires driver recovery.
 */
int
AdwResetCCB(ADW_SOFTC *sc)
{
	int	    status;

	/*
	 * Send the SCSI Bus Reset idle start idle command which asserts
	 * the SCSI Bus Reset signal.
	 */
	status = AdwSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_START, 0L);
	if (status != ADW_TRUE) {
		return status;
	}

	/*
	 * Delay for the specified SCSI Bus Reset hold time.
	 *
	 * The hold time delay is done on the host because the RISC has no
	 * microsecond accurate timer.
	 */
	AdwDelayMicroSecond((u_int16_t) ADW_SCSI_RESET_HOLD_TIME_US);

	/*
	 * Send the SCSI Bus Reset end idle command which de-asserts
	 * the SCSI Bus Reset signal and purges any pending requests.
	 */
	status = AdwSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_END, 0L);
	if (status != ADW_TRUE) {
		return status;
	}

	AdwSleepMilliSecond((u_int32_t) sc->scsi_reset_wait * 1000);

	return status;
}


/*
 * Reset chip and SCSI Bus.
 *
 * Return Value:
 *      ADW_TRUE(1) -   Chip re-initialization and SCSI Bus Reset successful.
 *      ADW_FALSE(0) -  Chip re-initialization and SCSI Bus Reset failure.
 */
int
AdwResetSCSIBus(ADW_SOFTC *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int		status;
	u_int16_t	wdtr_able, sdtr_able, ppr_able = 0, tagqng_able;
	u_int8_t	tid, max_cmd[ADW_MAX_TID + 1];
	u_int16_t	bios_sig;


	/*
	 * Save current per TID negotiated values.
	 */
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, wdtr_able);
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, sdtr_able);
	if (sc->chip_type == ADW_CHIP_ASC38C1600) {
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE, ppr_able);
	}
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE, tagqng_able);
	for (tid = 0; tid <= ADW_MAX_TID; tid++) {
		ADW_READ_BYTE_LRAM(iot, ioh, ADW_MC_NUMBER_OF_MAX_CMD + tid,
			max_cmd[tid]);
	}

	/*
	 * Force the AdwInitAscDriver() function to perform a SCSI Bus Reset
	 * by clearing the BIOS signature word.
	 * The initialization functions assumes a SCSI Bus Reset is not
	 * needed if the BIOS signature word is present.
	 */
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_BIOS_SIGNATURE, bios_sig);
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_BIOS_SIGNATURE, 0);

	/*
	 * Stop chip and reset it.
	 */
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_STOP);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,
			ADW_CTRL_REG_CMD_RESET);
	AdwSleepMilliSecond(100);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,
			ADW_CTRL_REG_CMD_WR_IO_REG);

	/*
	 * Reset Adw Library error code, if any, and try
	 * re-initializing the chip.
	 * Then translate initialization return value to status value.
	 */
	status = (AdwInitDriver(sc) == 0)? ADW_TRUE : ADW_FALSE;

	/*
	 * Restore the BIOS signature word.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_BIOS_SIGNATURE, bios_sig);

	/*
	 * Restore per TID negotiated values.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, wdtr_able);
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, sdtr_able);
	if (sc->chip_type == ADW_CHIP_ASC38C1600) {
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE, ppr_able);
	}
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE, tagqng_able);
	for (tid = 0; tid <= ADW_MAX_TID; tid++) {
		ADW_WRITE_BYTE_LRAM(iot, ioh, ADW_MC_NUMBER_OF_MAX_CMD + tid,
			max_cmd[tid]);
	}

	return status;
}


/*
 * Adw Library Interrupt Service Routine
 *
 *  This function is called by a driver's interrupt service routine.
 *  The function disables and re-enables interrupts.
 *
 *  Note: AdwISR() can be called when interrupts are disabled or even
 *  when there is no hardware interrupt condition present. It will
 *  always check for completed idle commands and microcode requests.
 *  This is an important feature that shouldn't be changed because it
 *  allows commands to be completed from polling mode loops.
 *
 * Return:
 *   ADW_TRUE(1) - interrupt was pending
 *   ADW_FALSE(0) - no interrupt was pending
 */
int
AdwISR(ADW_SOFTC *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t	int_stat;
	u_int16_t	target_bit;
	ADW_CARRIER	*free_carrp/*, *ccb_carr*/;
	u_int32_t	irq_next_pa;
	ADW_SCSI_REQ_Q	*scsiq;
	ADW_CCB		*ccb;
	int		s;


	s = splbio();

	/* Reading the register clears the interrupt. */
	int_stat = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_INTR_STATUS_REG);

	if ((int_stat & (ADW_INTR_STATUS_INTRA | ADW_INTR_STATUS_INTRB |
	     ADW_INTR_STATUS_INTRC)) == 0) {
		splx(s);
		return ADW_FALSE;
	}

	/*
	 * Notify the driver of an asynchronous microcode condition by
	 * calling the ADW_SOFTC.async_callback function. The function
	 * is passed the microcode ADW_MC_INTRB_CODE byte value.
	 */
	if (int_stat & ADW_INTR_STATUS_INTRB) {
		u_int8_t intrb_code;

		ADW_READ_BYTE_LRAM(iot, ioh, ADW_MC_INTRB_CODE, intrb_code);

		if (sc->chip_type == ADW_CHIP_ASC3550 ||
	    	    sc->chip_type == ADW_CHIP_ASC38C0800) {
			if (intrb_code == ADW_ASYNC_CARRIER_READY_FAILURE &&
				sc->carr_pending_cnt != 0) {
				ADW_WRITE_BYTE_REGISTER(iot, ioh,
					IOPB_TICKLE, ADW_TICKLE_A);
				if (sc->chip_type == ADW_CHIP_ASC3550) {
					ADW_WRITE_BYTE_REGISTER(iot, ioh,
						IOPB_TICKLE, ADW_TICKLE_NOP);
				}
			}
		}

		if (sc->async_callback != 0) {
		    (*(ADW_ASYNC_CALLBACK)sc->async_callback)(sc, intrb_code);
		}
	}

	/*
	 * Check if the IRQ stopper carrier contains a completed request.
	 */
	while (((irq_next_pa = sc->irq_sp->next_ba) & ADW_RQ_DONE) != 0)
	{
#if ADW_DEBUG
		printf("irq 0x%x, 0x%x, 0x%x, 0x%x\n",
				sc->irq_sp->carr_id,
				sc->irq_sp->carr_ba,
				sc->irq_sp->areq_ba,
				sc->irq_sp->next_ba);
#endif
		/*
		 * Get a pointer to the newly completed ADW_SCSI_REQ_Q
		 * structure.
		 * The RISC will have set 'areq_ba' to a virtual address.
		 *
		 * The firmware will have copied the ADW_SCSI_REQ_Q.ccb_ptr
		 * field to the carrier ADW_CARRIER.areq_ba field.
		 * The conversion below complements the conversion of
		 * ADW_SCSI_REQ_Q.ccb_ptr' in AdwExeScsiQueue().
		 */
		ccb = adw_ccb_phys_kv(sc, sc->irq_sp->areq_ba);
		scsiq = &ccb->scsiq;
		scsiq->ccb_ptr = sc->irq_sp->areq_ba;

		/*
		 * Request finished with good status and the queue was not
		 * DMAed to host memory by the firmware. Set all status fields
		 * to indicate good status.
		 */
		if ((irq_next_pa & ADW_RQ_GOOD) != 0) {
			scsiq->done_status = QD_NO_ERROR;
			scsiq->host_status = scsiq->scsi_status = 0;
			scsiq->data_cnt = 0L;
		}

		/*
		 * Advance the stopper pointer to the next carrier
		 * ignoring the lower four bits. Free the previous
		 * stopper carrier.
		 */
		free_carrp = sc->irq_sp;
		sc->irq_sp = ADW_CARRIER_VADDR(sc, ADW_GET_CARRP(irq_next_pa));

		free_carrp->next_ba = (sc->carr_freelist == NULL) ? 0
					: sc->carr_freelist->carr_ba;
		sc->carr_freelist = free_carrp;
		sc->carr_pending_cnt--;

		target_bit = ADW_TID_TO_TIDMASK(scsiq->target_id);

		/*
		 * Clear request microcode control flag.
		 */
		scsiq->cntl = 0;

		/*
		 * Check Condition handling
		 */
		/*
		 * If the command that completed was a SCSI INQUIRY and
		 * LUN 0 was sent the command, then process the INQUIRY
		 * command information for the device.
		 */
		if (scsiq->done_status == QD_NO_ERROR &&
		    scsiq->cdb[0] == INQUIRY &&
		    scsiq->target_lun == 0) {
			AdwInquiryHandling(sc, scsiq);
		}

		/*
		 * Notify the driver of the completed request by passing
		 * the ADW_SCSI_REQ_Q pointer to its callback function.
		 */
		(*(ADW_ISR_CALLBACK)sc->isr_callback)(sc, scsiq);
		/*
		 * Note: After the driver callback function is called, 'scsiq'
		 * can no longer be referenced.
		 *
		 * Fall through and continue processing other completed
		 * requests...
		 */
	}

	splx(s);

	return ADW_TRUE;
}


/*
 * Send an idle command to the chip and wait for completion.
 *
 * Command completion is polled for once per microsecond.
 *
 * The function can be called from anywhere including an interrupt handler.
 * But the function is not re-entrant, so it uses the splbio/splx()
 * functions to prevent reentrancy.
 *
 * Return Values:
 *   ADW_TRUE - command completed successfully
 *   ADW_FALSE - command failed
 *   ADW_ERROR - command timed out
 */
int
AdwSendIdleCmd(ADW_SOFTC *sc, u_int16_t idle_cmd, u_int32_t idle_cmd_parameter)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t	result;
	u_int32_t	i, j, s;

	s = splbio();

	/*
	 * Clear the idle command status which is set by the microcode
	 * to a non-zero value to indicate when the command is completed.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_IDLE_CMD_STATUS, (u_int16_t) 0);

	/*
	 * Write the idle command value after the idle command parameter
	 * has been written to avoid a race condition. If the order is not
	 * followed, the microcode may process the idle command before the
	 * parameters have been written to LRAM.
	 */
	ADW_WRITE_DWORD_LRAM(iot, ioh, ADW_MC_IDLE_CMD_PARAMETER,
			idle_cmd_parameter);
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_IDLE_CMD, idle_cmd);

	/*
	 * Tickle the RISC to tell it to process the idle command.
	 */
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADW_TICKLE_B);
	if (sc->chip_type == ADW_CHIP_ASC3550) {
		/*
		 * Clear the tickle value. In the ASC-3550 the RISC flag
		 * command 'clr_tickle_b' does not work unless the host
		 * value is cleared.
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADW_TICKLE_NOP);
	}

	/* Wait for up to 100 millisecond for the idle command to timeout. */
	for (i = 0; i < SCSI_WAIT_100_MSEC; i++) {
		/* Poll once each microsecond for command completion. */
		for (j = 0; j < SCSI_US_PER_MSEC; j++) {
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_IDLE_CMD_STATUS,
									result);
			if (result != 0) {
				splx(s);
				return result;
			}
			AdwDelayMicroSecond(1);
		}
	}

	splx(s);
	return ADW_ERROR;
}


/*
 * Inquiry Information Byte 7 Handling
 *
 * Handle SCSI Inquiry Command information for a device by setting
 * microcode operating variables that affect WDTR, SDTR, and Tag
 * Queuing.
 */
void
AdwInquiryHandling(ADW_SOFTC *sc, ADW_SCSI_REQ_Q *scsiq)
{
#ifndef FAILSAFE
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t		tid;
	ADW_SCSI_INQUIRY	*inq;
	u_int16_t		tidmask;
	u_int16_t		cfg_word;


	/*
	 * AdwInquiryHandling() requires up to INQUIRY information Byte 7
	 * to be available.
	 *
	 * If less than 8 bytes of INQUIRY information were requested or less
	 * than 8 bytes were transferred, then return. cdb[4] is the request
	 * length and the ADW_SCSI_REQ_Q 'data_cnt' field is set by the
	 * microcode to the transfer residual count.
	 */

	if (scsiq->cdb[4] < 8 || (scsiq->cdb[4] - scsiq->data_cnt) < 8) {
		return;
	}

	tid = scsiq->target_id;

        inq = (ADW_SCSI_INQUIRY *) scsiq->vdata_addr;

	/*
	 * WDTR, SDTR, and Tag Queuing cannot be enabled for old devices.
	 */
	if ((inq->rsp_data_fmt < 2) /*SCSI-1 | CCS*/ &&
	    (inq->ansi_apr_ver < 2)) {
		return;
	} else {
		/*
		 * INQUIRY Byte 7 Handling
		 *
		 * Use a device's INQUIRY byte 7 to determine whether it
		 * supports WDTR, SDTR, and Tag Queuing. If the feature
		 * is enabled in the EEPROM and the device supports the
		 * feature, then enable it in the microcode.
		 */

		tidmask = ADW_TID_TO_TIDMASK(tid);

		/*
		 * Wide Transfers
		 *
		 * If the EEPROM enabled WDTR for the device and the device
		 * supports wide bus (16 bit) transfers, then turn on the
		 * device's 'wdtr_able' bit and write the new value to the
		 * microcode.
		 */
#ifdef SCSI_ADW_WDTR_DISABLE
	if(!(tidmask & SCSI_ADW_WDTR_DISABLE))
#endif /* SCSI_ADW_WDTR_DISABLE */
		if ((sc->wdtr_able & tidmask) && inq->WBus16) {
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE,
					cfg_word);
			if ((cfg_word & tidmask) == 0) {
				cfg_word |= tidmask;
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE,
						cfg_word);

				/*
				 * Clear the microcode "SDTR negotiation" and
				 * "WDTR negotiation" done indicators for the
				 * target to cause it to negotiate with the new
				 * setting set above.
				 * WDTR when accepted causes the target to enter
				 * asynchronous mode, so SDTR must be negotiated
				 */
				ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE,
						cfg_word);
				cfg_word &= ~tidmask;
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE,
						cfg_word);
				ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_DONE,
						cfg_word);
				cfg_word &= ~tidmask;
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_DONE,
						cfg_word);
			}
		}

		/*
		 * Synchronous Transfers
		 *
		 * If the EEPROM enabled SDTR for the device and the device
		 * supports synchronous transfers, then turn on the device's
		 * 'sdtr_able' bit. Write the new value to the microcode.
		 */
#ifdef SCSI_ADW_SDTR_DISABLE
	if(!(tidmask & SCSI_ADW_SDTR_DISABLE))
#endif /* SCSI_ADW_SDTR_DISABLE */
		if ((sc->sdtr_able & tidmask) && inq->Sync) {
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE,cfg_word);
			if ((cfg_word & tidmask) == 0) {
				cfg_word |= tidmask;
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE,
						cfg_word);

				/*
				 * Clear the microcode "SDTR negotiation"
				 * done indicator for the target to cause it
				 * to negotiate with the new setting set above.
				 */
				ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE,
						cfg_word);
				cfg_word &= ~tidmask;
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE,
						cfg_word);
			}
		}
		/*
		 * If the Inquiry data included enough space for the SPI-3
		 * Clocking field, then check if DT mode is supported.
		 */
		if (sc->chip_type == ADW_CHIP_ASC38C1600 &&
		   (scsiq->cdb[4] >= 57 ||
		   (scsiq->cdb[4] - scsiq->data_cnt) >= 57)) {
			/*
			 * PPR (Parallel Protocol Request) Capable
			 *
			 * If the device supports DT mode, then it must be
			 * PPR capable.
			 * The PPR message will be used in place of the SDTR
			 * and WDTR messages to negotiate synchronous speed
			 * and offset, transfer width, and protocol options.
			 */
                         if((inq->Clocking) & INQ_CLOCKING_DT_ONLY){
				ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE,
						sc->ppr_able);
				sc->ppr_able |= tidmask;
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE,
						sc->ppr_able);
			}
		}

		/*
		 * If the EEPROM enabled Tag Queuing for the device and the
		 * device supports Tag Queueing, then turn on the device's
		 * 'tagqng_enable' bit in the microcode and set the microcode
		 * maximum command count to the ADW_SOFTC 'max_dvc_qng'
		 * value.
		 *
		 * Tag Queuing is disabled for the BIOS which runs in polled
		 * mode and would see no benefit from Tag Queuing. Also by
		 * disabling Tag Queuing in the BIOS devices with Tag Queuing
		 * bugs will at least work with the BIOS.
		 */
#ifdef SCSI_ADW_TAGQ_DISABLE
	if(!(tidmask & SCSI_ADW_TAGQ_DISABLE))
#endif /* SCSI_ADW_TAGQ_DISABLE */
		if ((sc->tagqng_able & tidmask) && inq->CmdQue) {
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE,
					cfg_word);
			cfg_word |= tidmask;
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE,
					cfg_word);

			ADW_WRITE_BYTE_LRAM(iot, ioh,
					ADW_MC_NUMBER_OF_MAX_CMD + tid,
					sc->max_dvc_qng);
		}
	}
#endif /* FAILSAFE */
}


void
AdwSleepMilliSecond(u_int32_t n)
{

	DELAY(n * 1000);
}


void
AdwDelayMicroSecond(u_int32_t n)
{

	DELAY(n);
}

@


1.23
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.22 2010/07/02 03:24:50 tedu Exp $ */
d240 1
a240 2
AdwInitFromEEPROM(sc)
ADW_SOFTC      *sc;
d526 1
a526 2
AdwInitDriver(sc)
ADW_SOFTC      *sc;
d929 1
a929 4
AdwRamSelfTest(iot, ioh, chip_type)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t chip_type;
d1015 2
a1016 5
AdwLoadMCode(iot, ioh, bios_mem, chip_type)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int16_t *bios_mem;
	u_int8_t chip_type;
d1162 1
a1162 4
AdwASC3550Cabling(iot, ioh, cfg)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ADW_DVC_CFG *cfg;
d1284 2
a1285 4
AdwASC38C0800Cabling(iot, ioh, cfg)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ADW_DVC_CFG *cfg;
d1411 2
a1412 4
AdwASC38C1600Cabling(iot, ioh, cfg)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ADW_DVC_CFG *cfg;
d1538 2
a1539 4
AdwGetEEPROMConfig(iot, ioh, cfg_buf)
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;
	ADW_EEPROM		*cfg_buf;
d1573 1
a1573 4
AdwReadEEPWord(iot, ioh, eep_word_addr)
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;
	int			eep_word_addr;
d1587 1
a1587 3
AdwWaitEEPCmd(iot, ioh)
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;
d1608 2
a1609 4
AdwSetEEPROMConfig(iot, ioh, cfg_buf)
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;
	ADW_EEPROM		*cfg_buf;
d1680 1
a1680 3
AdwExeScsiQueue(sc, scsiq)
ADW_SOFTC	*sc;
ADW_SCSI_REQ_Q	*scsiq;
d1795 1
a1795 3
AdwResetChip(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d1819 1
a1819 2
AdwResetCCB(sc)
ADW_SOFTC	*sc;
d1863 1
a1863 2
AdwResetSCSIBus(sc)
ADW_SOFTC	*sc;
d1953 1
a1953 2
AdwISR(sc)
ADW_SOFTC	*sc;
d2111 1
a2111 4
AdwSendIdleCmd(sc, idle_cmd, idle_cmd_parameter)
ADW_SOFTC      *sc;
u_int16_t       idle_cmd;
u_int32_t       idle_cmd_parameter;
d2176 1
a2176 3
AdwInquiryHandling(sc, scsiq)
ADW_SOFTC	*sc;
ADW_SCSI_REQ_Q *scsiq;
d2349 1
a2349 2
AdwSleepMilliSecond(n)
u_int32_t	n;
d2357 1
a2357 2
AdwDelayMicroSecond(n)
u_int32_t	n;
@


1.22
log
@correctly init ppr_able in reset, and some others gcc complained about.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.21 2008/06/26 05:42:15 ray Exp $ */
d2081 1
a2081 1
		free_carrp->next_ba = (sc->carr_freelist == NULL) ? NULL
@


1.21
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.20 2004/06/24 09:07:39 itojun Exp $ */
d1026 3
a1028 3
	u_int8_t	*mcode_data;
	u_int32_t	 mcode_chksum;
	u_int16_t	 mcode_size;
d1034 1
a1034 1
	int		adw_memsize;
d1898 1
a1898 1
	u_int16_t	wdtr_able, sdtr_able, ppr_able, tagqng_able;
@


1.20
log
@ultra minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.19 2004/01/09 21:32:23 brad Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.19
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.18 2003/10/21 18:58:48 jmc Exp $ */
d2088 1
a2088 1
		free_carrp->next_ba = (sc->carr_freelist == NULL)? NULL
@


1.18
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.17 2003/02/11 19:20:27 mickey Exp $ */
a69 2

#include <uvm/uvm_extern.h>
@


1.17
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.16 2002/03/14 01:26:53 millert Exp $ */
d1464 2
a1465 2
	 * can not be connected to either connector. An LVD device or SE device
	 * may be connected to either connecor. If an SE device is connected,
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.15 2001/11/06 19:53:18 miod Exp $ */
d1466 1
a1466 1
	 * then at most Ultra speed (20 Mhz) can be used on both connectors.
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.14 2001/07/11 17:31:25 krw Exp $ */
d78 15
a92 15
int AdwRamSelfTest __P((bus_space_tag_t, bus_space_handle_t, u_int8_t));
int AdwLoadMCode __P((bus_space_tag_t, bus_space_handle_t, u_int16_t *,
								u_int8_t));
int AdwASC3550Cabling __P((bus_space_tag_t, bus_space_handle_t, ADW_DVC_CFG *));
int AdwASC38C0800Cabling __P((bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *));
int AdwASC38C1600Cabling __P((bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *));

u_int16_t AdwGetEEPROMConfig __P((bus_space_tag_t, bus_space_handle_t,
     							ADW_EEPROM *));
void AdwSetEEPROMConfig __P((bus_space_tag_t, bus_space_handle_t,
					                 ADW_EEPROM *));
u_int16_t AdwReadEEPWord __P((bus_space_tag_t, bus_space_handle_t, int));
void AdwWaitEEPCmd __P((bus_space_tag_t, bus_space_handle_t));
d94 1
a94 1
void AdwInquiryHandling __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));
d96 2
a97 2
void AdwSleepMilliSecond __P((u_int32_t));
void AdwDelayMicroSecond __P((u_int32_t));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.15 2001/11/06 19:53:18 miod Exp $ */
d78 15
a92 15
int AdwRamSelfTest(bus_space_tag_t, bus_space_handle_t, u_int8_t);
int AdwLoadMCode(bus_space_tag_t, bus_space_handle_t, u_int16_t *,
								u_int8_t);
int AdwASC3550Cabling(bus_space_tag_t, bus_space_handle_t, ADW_DVC_CFG *);
int AdwASC38C0800Cabling(bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *);
int AdwASC38C1600Cabling(bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *);

u_int16_t AdwGetEEPROMConfig(bus_space_tag_t, bus_space_handle_t,
     							ADW_EEPROM *);
void AdwSetEEPROMConfig(bus_space_tag_t, bus_space_handle_t,
					                 ADW_EEPROM *);
u_int16_t AdwReadEEPWord(bus_space_tag_t, bus_space_handle_t, int);
void AdwWaitEEPCmd(bus_space_tag_t, bus_space_handle_t);
d94 1
a94 1
void AdwInquiryHandling(ADW_SOFTC *, ADW_SCSI_REQ_Q *);
d96 2
a97 2
void AdwSleepMilliSecond(u_int32_t);
void AdwDelayMicroSecond(u_int32_t);
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1466 1
a1466 1
	 * then at most Ultra speed (20 MHz) can be used on both connectors.
@


1.14
log
@Eliminate use of static functions in line with normal OpenBSD
preferences. Having more debugging info available during
fixup of this driver to work on powerpc can't hurt either!

Change adwminphys() to adw_minphys() to make consistant with all
other function names in adw.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.13 2001/04/11 04:05:16 krw Exp $ */
d71 1
a71 1
#include <vm/vm.h>
@


1.13
log
@Update the adw driver to use the latest version of firmware (3.3f).

Move the microcode files to dev/microcode/adw/*.
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.12 2001/02/22 17:17:32 krw Exp $ */
a77 2
/* Static Functions */

d87 1
a87 1
static u_int16_t AdwGetEEPROMConfig __P((bus_space_tag_t, bus_space_handle_t,
d89 1
a89 1
static void AdwSetEEPROMConfig __P((bus_space_tag_t, bus_space_handle_t,
d91 2
a92 2
static u_int16_t AdwReadEEPWord __P((bus_space_tag_t, bus_space_handle_t, int));
static void AdwWaitEEPCmd __P((bus_space_tag_t, bus_space_handle_t));
d94 1
a94 1
static void AdwInquiryHandling __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));
d96 2
a97 2
static void AdwSleepMilliSecond __P((u_int32_t));
static void AdwDelayMicroSecond __P((u_int32_t));
d1561 1
a1561 1
static u_int16_t
d1598 1
a1598 1
static u_int16_t
d1615 1
a1615 1
static void
d1638 1
a1638 1
static void
d2218 1
a2218 1
static void
d2393 1
a2393 1
static void
d2402 1
a2402 1
static void
@


1.12
log
@Typo police:

Replace last ADV/ASC/Adv, etc. uses with ADW/Adw as appropriate.

Delete comments about non-existant structure members,
correct references to existing structure members to use
correct structure names or typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.11 2000/12/08 00:03:31 krw Exp $ */
d74 1
a74 1
#include <dev/ic/adwmcode.h>
@


1.11
log
@This update should cause the adw driver to:

 - actually check the returned scsi_status value and act accordingly
   instead of ALWAYS returning XS_NOERROR

 - always return the scsi status value in xs->status for completed
   requests

 - no longer reference ccb->xs and ccb->dmamap_xfer if an 'unallocated'
   ccb is encountered

 - immediately remove the ccb adw_isr_callback is working on from the
   pending list, leaving it in limbo until it is put on the free list
   just before any return

 - 'freeze' a target only when a scsi_status indicating it is busy is
   encountered, and 'thaw' a target whenever a bus reset is done or a
   request completes

 - check done_status, host_status and scsi_status in that order as is
   done in the linux driver and was done here until very recently, which
   seems cleaner to me. But opinions may vary. The only behaviour change
   that should result is that done_status of QD_NO_STATUS no longer
   causes a check of host_status values, but is an error causing a
   XS_DRIVER_STUFFUP

 - produce a more general error message with actual values for
   host_status, scsi_status and done_status values, with references to
   adw(4) for more details on the error where appropriate (man page
   update coming)

 - take what seems like appropriate action for all known host_status,
   scsi_status and done_status values with more use of XS_RESET where
   appropriate

 - use adw_reset_bus() instead of AdwResetSCSIBus() in
   adw_async_callback() so pending requests are requeued and devices left
   unfrozen when this happens

 - print an error message with the code # when adw_async_callback is
   called with an unknown code.
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.10 2000/07/22 15:10:13 krw Exp $ */
d140 2
a141 2
	0,			/* 31 adv_err_code */
	0,			/* 32 adv_err_addr */
d143 2
a144 2
	0,			/* 34 saved_adv_err_code */
	0			/* 35 saved_adv_err_addr */
d177 2
a178 2
	0,			/* 31 adv_err_code */
	0,			/* 32 adv_err_addr */
d180 2
a181 2
	0,			/* 34 saved_adv_err_code */
	0,			/* 35 saved_adv_err_addr */
d223 2
a224 2
	0,			/* 31 adv_err_code */
	0,			/* 32 adv_err_addr */
d226 2
a227 2
	0,			/* 34 saved_adv_err_code */
	0,			/* 35 saved_adv_err_addr */
d345 1
a345 1
			AdwReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - j);
d436 1
a436 1
	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
d445 1
a445 1
	 * the ADV_DVC_CFG 'termination' field to automatic also.
d448 1
a448 1
	 * value check that a legal value is set and set the ADV_DVC_CFG
d714 1
a714 1
	 * queuing will be set in AdvInquiryHandling() based on what a
d849 1
a849 1
			ASC_GET_CARRP(sc->icq_sp->next_ba));
d854 1
a854 1
	sc->icq_sp->next_ba = ASC_CQ_STOPPER;
d877 1
a877 1
			ASC_GET_CARRP(sc->irq_sp->next_ba));
d883 2
a884 2
	 * Note: Set 'next_ba' to ASC_CQ_STOPPER. When the request is
	 * completed the RISC will set the ASC_RQ_DONE bit.
d886 1
a886 1
	sc->irq_sp->next_ba = ASC_CQ_STOPPER;
d1577 2
a1578 2
	for (eep_addr = ASC_EEP_DVC_CFG_BEGIN;
		eep_addr < ASC_EEP_DVC_CFG_END;
d1587 2
a1588 2
	for (eep_addr = ASC_EEP_DVC_CTL_BEGIN;
			eep_addr < ASC_EEP_MAX_WORD_ADDR;
d1607 1
a1607 1
		ASC_EEP_CMD_READ | eep_word_addr);
d1625 1
a1625 1
	for (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++){
d1627 1
a1627 1
				ASC_EEP_CMD_DONE) {
d1653 1
a1653 1
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
d1659 2
a1660 2
	for (addr = ASC_EEP_DVC_CFG_BEGIN;
	     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {
d1664 1
a1664 1
				ASC_EEP_CMD_WRITE | addr);
d1666 1
a1666 1
		AdwSleepMilliSecond(ASC_EEP_DELAY_MS);
d1674 1
a1674 1
			ASC_EEP_CMD_WRITE | addr);
d1681 2
a1682 2
	for (addr = ASC_EEP_DVC_CTL_BEGIN;
	     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
d1685 1
a1685 1
				ASC_EEP_CMD_WRITE | addr);
d1690 1
a1690 1
			ASC_EEP_CMD_WRITE_DISABLE);
d1736 1
a1736 1
	 * Begin of CRITICAL SECTION: Must be protected within splbio/splx pair
d1748 1
a1748 1
			ASC_GET_CARRP(new_carrp->next_ba));
d1756 1
a1756 1
	new_carrp->next_ba = ASC_CQ_STOPPER;
d1766 1
a1766 1
	 * Every ADV_CARR_T.carr_ba is byte swapped to little-endian
d1878 1
a1878 1
	AdwDelayMicroSecond((u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US);
d1948 1
a1948 1
	 * Reset Adv Library error code, if any, and try
d1978 1
a1978 1
 * Adv Library Interrupt Service Routine
a1982 3
 *  When a microcode idle command is completed, the ADV_DVC_VAR
 *  'idle_cmd_done' field is set to ADW_TRUE.
 *
d2021 1
a2021 1
	 * calling the ADV_DVC_VAR.async_callback function. The function
d2031 1
a2031 1
			if (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&
d2050 1
a2050 1
	while (((irq_next_pa = sc->irq_sp->next_ba) & ASC_RQ_DONE) != 0)
d2064 2
a2065 2
		 * The firmware will have copied the ASC_SCSI_REQ_Q.ccb_ptr
		 * field to the carrier ADV_CARR_T.areq_ba field.
d2067 1
a2067 1
		 * ASC_SCSI_REQ_Q.scsiq_ptr' in AdwExeScsiQueue().
d2078 1
a2078 1
		if ((irq_next_pa & ASC_RQ_GOOD) != 0) {
d2090 1
a2090 1
		sc->irq_sp = ADW_CARRIER_VADDR(sc, ASC_GET_CARRP(irq_next_pa));
d2368 1
a2368 1
		 * maximum command count to the ADV_DVC_VAR 'max_dvc_qng'
@


1.10
log
@sync to NetBSD:

   - remove #include <vm/vm_param.h>
        and #include <vm/pmap.h>
     as they are already included with
            #include <vm/vm.h>

   - more Adv -> Adw, ADV -> ADW adjustments & other
     minor formatting corrections

plus:

   - put 'Carrier Ready failure!' warning message inside
     #ifdef ADW_DEBUG/#endif as it appears under heavy load
     but is nothing but a reminder the card was too busy to
     notice a 'tickle' from the driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.9 2000/06/29 00:04:31 krw Exp $ */
a2098 1

@


1.9
log
@Sync adw files with (almost) latest NetBSD versions:

adw.c     synched with v1.23 (from v1.14)
adw.h                  v1.9  (     v1.5 )
adwlib.c               v1.17 (     v1.7 )
adwlib.h               v1.13 (     v1.7 )
adwmcode.c             v1.5  (     v1.2 )
adwmcode.h             v1.5  (     v1.2 )

microcode for cards is updated to latest version,
loss of carrier problems are solved in a more
robust manner than before, lots of code cleanup.

first support for upcoming U3W cards added, as
a result of which the driver is now too large
for RAMDISK and has been moved to RAMDISKB.

Most of the work done by dante@@ NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: adwlib.c,v 1.8 2000/04/29 21:07:17 krw Exp $ */
/* $NetBSD: adwlib.c,v 1.17 2000/05/27 18:24:50 dante Exp $        */
a71 2
#include <vm/vm_param.h>
#include <vm/pmap.h>
d1804 1
a1804 1
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);
d1812 1
a1812 1
					ADV_TICKLE_NOP);
d2037 1
a2037 1
					IOPB_TICKLE, ADV_TICKLE_A);
d2040 1
a2040 1
						IOPB_TICKLE, ADV_TICKLE_NOP);
d2188 1
a2188 1
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_B);
d2195 1
a2195 1
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);
@


1.8
log
@add $ tag
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/* $NetBSD: adwlib.c,v 1.7 2000/02/03 20:29:15 dante Exp $        */
d46 1
a46 1
 * Copyright (c) 1995-1999 Advanced System Products, Inc.
d76 1
a77 1
#include <dev/ic/adwmcode.h>
d82 15
a96 11
static u_int16_t AdvGet3550EEPConfig __P((bus_space_tag_t, bus_space_handle_t,
     							ADW_EEP_3550_CONFIG *));
static u_int16_t AdvGet38C0800EEPConfig __P((bus_space_tag_t, bus_space_handle_t,
     							ADW_EEP_38C0800_CONFIG *));
static u_int16_t AdvReadEEPWord __P((bus_space_tag_t, bus_space_handle_t, int));
static void AdvWaitEEPCmd __P((bus_space_tag_t, bus_space_handle_t));
static void AdvSet3550EEPConfig __P((bus_space_tag_t, bus_space_handle_t,
					                 ADW_EEP_3550_CONFIG *));
static void AdvSet38C0800EEPConfig __P((bus_space_tag_t, bus_space_handle_t,
					                 ADW_EEP_38C0800_CONFIG *));
static void AdvInquiryHandling __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));
d98 4
a101 2
static void AdvSleepMilliSecond __P((u_int32_t));
static void AdvDelayMicroSecond __P((u_int32_t));
d112 35
a146 36
static ADW_EEP_3550_CONFIG
Default_3550_EEPROM_Config = {
	ADW_EEPROM_BIOS_ENABLE,	/* cfg_lsw */
	0x0000,			/* cfg_msw */
	0xFFFF,			/* disc_enable */
	0xFFFF,			/* wdtr_able */
	0xFFFF,			/* sdtr_able */
	0xFFFF,			/* start_motor */
	0xFFFF,			/* tagqng_able */
	0xFFFF,			/* bios_scan */
	0,			/* scam_tolerant */
	7,			/* adapter_scsi_id */
	0,			/* bios_boot_delay */
	3,			/* scsi_reset_delay */
	0,			/* bios_id_lun */
	0,			/* termination */
	0,			/* reserved1 */
	0xFFE7,			/* bios_ctrl */
	0xFFFF,			/* ultra_able */
	0,			/* reserved2 */
	ASC_DEF_MAX_HOST_QNG,	/* max_host_qng */
	ASC_DEF_MAX_DVC_QNG,	/* max_dvc_qng */
	0,			/* dvc_cntl */
	0,			/* bug_fix */
	0,			/* serial_number_word1 */
	0,			/* serial_number_word2 */
	0,			/* serial_number_word3 */
	0,			/* check_sum */
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /* oem_name[16] */
	0,			/* dvc_err_code */
	0,			/* adv_err_code */
	0,			/* adv_err_addr */
	0,			/* saved_dvc_err_code */
	0,			/* saved_adv_err_code */
	0,			/* saved_adv_err_addr */
	0			/* num_of_err */
d149 1
a149 2
static ADW_EEP_38C0800_CONFIG
Default_38C0800_EEPROM_Config = {
d154 1
a154 1
	0x4444,			/* 04 sdtr_speed1 */
d166 4
a169 4
	0x4444,			/* 13 sdtr_speed2 */
	0x4444,			/* 14 sdtr_speed3 */
	ASC_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
	ASC_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
d171 2
a172 4
	0x4444,			/* 17 sdtr_speed4 */
	0,			/* 18 serial_number_word1 */
	0,			/* 19 serial_number_word2 */
	0,			/* 20 serial_number_word3 */
d174 4
a177 1
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* 22-29 oem_name[16] */
d184 4
a187 20
	0,			/* 36 reserved */
	0,			/* 37 reserved */
	0,			/* 38 reserved */
	0,			/* 39 reserved */
	0,			/* 40 reserved */
	0,			/* 41 reserved */
	0,			/* 42 reserved */
	0,			/* 43 reserved */
	0,			/* 44 reserved */
	0,			/* 45 reserved */
	0,			/* 46 reserved */
	0,			/* 47 reserved */
	0,			/* 48 reserved */
	0,			/* 49 reserved */
	0,			/* 50 reserved */
	0,			/* 51 reserved */
	0,			/* 52 reserved */
	0,			/* 53 reserved */
	0,			/* 54 reserved */
	0,			/* 55 reserved */
d192 47
a238 4
	0,			/* 60 reserved */
	0,			/* 61 reserved */
	0,			/* 62 reserved */
	0			/* 63 reserved */
d241 1
d243 3
a245 3
 * Initialize the ASC3550.
 *
 * On failure set the ADW_SOFTC field 'err_code' and return ADW_ERROR.
d249 2
d253 1
a253 1
AdvInitAsc3550Driver(sc)
d258 5
a262 14
	u_int16_t	warn_code;
	u_int32_t	sum;
	int		begin_addr;
	int		end_addr;
	u_int16_t	code_sum;
	int		word;
	int		i, j;
	int		adv_asc3550_expanded_size;
	u_int16_t	scsi_cfg1;
	u_int8_t	tid;
	u_int16_t	bios_mem[ASC_MC_BIOSLEN/2];	/* BIOS RISC Memory
								0x40-0x8F. */
	u_int16_t	wdtr_able = 0, sdtr_able, tagqng_able;
	u_int8_t	max_cmd[ADW_MAX_TID + 1];
d268 3
a270 3
	 * Save the RISC memory BIOS region before writing the microcode.
	 * The BIOS may already be loaded and using its RISC LRAM region
	 * so its region must be saved and restored.
d272 1
a272 2
	 * Note: This code makes the assumption, which is currently true,
	 * that a chip reset does not clear RISC LRAM.
d274 15
a288 3
	for (i = 0; i < ASC_MC_BIOSLEN/2; i++) {
		ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2*i), bios_mem[i]);
	}
d290 3
a292 4
	/*
	 * Save current per TID negotiated values.
	 */
	if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA) {
d294 45
a338 1
		u_int16_t  bios_version, major, minor;
d340 8
a347 8
		bios_version = bios_mem[(ASC_MC_BIOS_VERSION-ASC_MC_BIOSMEM)/2];
		major = (bios_version  >> 12) & 0xF;
		minor = (bios_version  >> 8) & 0xF;
		if (major < 3 || (major == 3 && minor == 1)) {
		    /* BIOS 3.1 and earlier location of 'wdtr_able' variable. */
		    ADW_READ_WORD_LRAM(iot, ioh, 0x120, wdtr_able);
		} else {
		    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);
d349 18
d368 32
a399 5
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);
	for (tid = 0; tid <= ADW_MAX_TID; tid++) {
		ADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,
			max_cmd[tid]);
d403 2
a404 3
	 * Load the Microcode
	 *
	 * Write the microcode image to RISC memory starting at address 0.
d406 11
a416 1
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);
d418 6
a423 31
	/* Assume the following compressed format of the microcode buffer:
	 *
	 *  254 word (508 byte) table indexed by byte code followed
	 *  by the following byte codes:
	 *
	 *    1-Byte Code:
	 *	00: Emit word 0 in table.
	 *	01: Emit word 1 in table.
	 *	.
	 *	FD: Emit word 253 in table.
	 *
	 *    Multi-Byte Code:
	 *	FE WW WW: (3 byte code) Word to emit is the next word WW WW.
	 *	FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
	 */
	word = 0;
	for (i = 253 * 2; i < adv_asc3550_mcode_size; i++) {
		if (adv_asc3550_mcode[i] == 0xff) {
			for (j = 0; j < adv_asc3550_mcode[i + 1]; j++) {
				ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,
				  (((u_int16_t)adv_asc3550_mcode[i + 3] << 8) |
				  adv_asc3550_mcode[i + 2]));
				word++;
			}
			i += 3;
		} else if (adv_asc3550_mcode[i] == 0xfe) {
			ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,
			    (((u_int16_t)adv_asc3550_mcode[i + 2] << 8) |
			    adv_asc3550_mcode[i + 1]));
			i += 2;
			word++;
d425 1
a425 4
			ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)
			 adv_asc3550_mcode[(adv_asc3550_mcode[i] * 2) + 1] <<8) |
			 adv_asc3550_mcode[adv_asc3550_mcode[i] * 2]));
			word++;
d430 2
a431 2
	 * Set 'word' for later use to clear the rest of memory and save
	 * the expanded mcode size.
d433 3
a435 2
	word *= 2;
	adv_asc3550_expanded_size = word;
d438 2
a439 1
	 * Clear the rest of ASC-3550 Internal RAM (8KB).
d441 3
a443 3
	for (; word < ADV_3550_MEMSIZE; word += 2) {
		ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);
	}
d446 6
a451 1
	 * Verify the microcode checksum.
a452 2
	sum = 0;
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);
d454 74
a527 2
	for (word = 0; word < adv_asc3550_expanded_size; word += 2) {
		sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);
d530 37
a566 2
	if (sum != adv_asc3550_mcode_chksum) {
		return ASC_IERR_MCODE_CHKSUM;
d570 1
a570 1
	 * Restore the RISC memory BIOS region.
d572 35
a606 3
	for (i = 0; i < ASC_MC_BIOSLEN/2; i++) {
		ADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),
				bios_mem[i]);
d610 1
a610 2
	 * Calculate and write the microcode code checksum to the microcode
	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
d612 2
a613 6
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);
	code_sum = 0;
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);
	for (word = begin_addr; word < end_addr; word += 2) {
		code_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);
a614 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);
d617 1
a617 1
	 * Read and save microcode version and date.
d619 4
a622 4
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,
			sc->cfg.mcode_date);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,
			sc->cfg.mcode_version);
d625 1
a625 1
	 * Set the chip type to indicate the ASC3550.
d627 2
a628 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);
d637 56
d694 4
a697 3
		 * Note: Don't remove the use of a temporary variable in
		 * the following code, otherwise some  C compiler
		 * might turn the following lines into a no-op.
d699 13
a711 3
		ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);
		word |= CONTROL_FLAG_IGNORE_PERR;
		ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);
a714 7
	 * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO
	 * threshold of 128 bytes. This register is only accessible to the host.
	 */
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,
			START_CTL_EMFU | READ_CMD_MRM);

	/*
d719 1
a719 1
	 * If SCSI Bus Resets haev been disabled, then directly set
d727 2
a728 4
		ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,
				sc->wdtr_able);
		ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,
				sc->sdtr_able);
a739 12
	 *
	 * 4-bit speed  SDTR speed name
	 * ===========  ===============
	 * 0000b (0x0)  SDTR disabled
	 * 0001b (0x1)  5 Mhz
	 * 0010b (0x2)  10 Mhz
	 * 0011b (0x3)  20 Mhz (Ultra)
	 * 0100b (0x4)  40 Mhz (LVD/Ultra2)
	 * 0101b (0x5)  80 Mhz (LVD2/Ultra3)
	 * 0110b (0x6)  Undefined
	 * .
	 * 1111b (0xF)  Undefined
d741 32
a772 25
	word = 0;
	for (tid = 0; tid <= ADW_MAX_TID; tid++) {
		if (ADW_TID_TO_TIDMASK(tid) & sc->ultra_able) {
			/* Set Ultra speed for TID 'tid'. */
			word |= (0x3 << (4 * (tid % 4)));
		} else {
			/* Set Fast speed for TID 'tid'. */
			word |= (0x2 << (4 * (tid % 4)));
		}
		/* Check if done with sdtr_speed1. */
		if (tid == 3) {
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, word);
			word = 0;
		/* Check if done with sdtr_speed2. */
		} else if (tid == 7) {
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, word);
			word = 0;
		/* Check if done with sdtr_speed3. */
		} else if (tid == 11) {
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, word);
			word = 0;
		/* Check if done with sdtr_speed4. */
		} else if (tid == 15) {
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, word);
			/* End of loop. */
d774 23
a798 5
	/*
	 * Set microcode operating variable for the disconnect per TID bitmask.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);

d806 21
a826 3
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,
		ADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |
			sc->chip_scsi_id);
d829 1
a829 1
	 * Determine SCSI_CFG1 Microcode Default Value.
d831 1
a831 1
	 * The microcode will set the SCSI_CFG1 register using this value
d834 2
a835 3

	/* Read current SCSI_CFG1 Register value. */
	scsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);
d838 1
a838 1
	 * If all three connectors are in use, return an error.
d840 2
a841 4
	if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
		(scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {
		return ASC_IERR_ILLEGAL_CONNECTION;
	}
d844 1
a844 3
	 * If the internal narrow cable is reversed all of the SCSI_CTRL
	 * register signals will be set. Check for and return an error if
	 * this condition is found.
a845 4
	if ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==
			0x3F07) {
		return ASC_IERR_REVERSED_CABLE;
	}
d847 2
a848 6
	/*
	 * If this is a differential board and a single-ended device
	 * is attached to one of the connectors, return an error.
	 */
	if ((scsi_cfg1 & ADW_DIFF_MODE) && (scsi_cfg1 & ADW_DIFF_SENSE) == 0) {
		return ASC_IERR_SINGLE_END_DEVICE;
d850 2
d854 1
a854 6
	 * If automatic termination control is enabled, then set the
	 * termination value based on a table listed in a_condor.h.
	 *
	 * If manual termination was specified with an EEPROM setting
	 * then 'termination' was set-up in AdvInitFrom3550EEPROM() and
	 * is ready to be 'ored' into SCSI_CFG1.
d856 1
a856 23
	if (sc->cfg.termination == 0) {
		/*
		 * The software always controls termination by setting TERM_CTL_SEL.
		 * If TERM_CTL_SEL were set to 0, the hardware would set termination.
		 */
		sc->cfg.termination |= ADW_TERM_CTL_SEL;

		switch(scsi_cfg1 & ADW_CABLE_DETECT) {
			/* TERM_CTL_H: on, TERM_CTL_L: on */
			case 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:
				sc->cfg.termination |= (ADW_TERM_CTL_H | ADW_TERM_CTL_L);
				break;

			/* TERM_CTL_H: on, TERM_CTL_L: off */
			case 0x1: case 0x5: case 0x9: case 0xA: case 0xC:
				sc->cfg.termination |= ADW_TERM_CTL_H;
				break;

			/* TERM_CTL_H: off, TERM_CTL_L: off */
			case 0x2: case 0x6:
				break;
		}
	}
d859 1
a859 1
	 * Clear any set TERM_CTL_H and TERM_CTL_L bits.
d861 1
a861 1
	scsi_cfg1 &= ~ADW_TERM_CTL;
d864 2
a865 4
	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then
	 * set 'scsi_cfg1'. The TERM_POL bit does not need to be
	 * referenced, because the hardware internally inverts
	 * the Termination High and Low bits if TERM_POL is set.
d867 4
a870 1
	scsi_cfg1 |= (ADW_TERM_CTL_SEL | (~sc->cfg.termination & ADW_TERM_CTL));
d873 1
a873 7
	 * Set SCSI_CFG1 Microcode Default Value
	 *
	 * Set filter value and possibly modified termination control
	 * bits in the Microcode SCSI_CFG1 Register Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
d875 5
a879 2
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1,
		ADW_FLTR_DISABLE | scsi_cfg1);
d882 2
a883 4
	 * Set MEM_CFG Microcode Default Value
	 *
	 * The microcode will set the MEM_CFG register using this value
	 * after it is started below.
d885 2
a886 4
	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
	 * are defined.
	 *
	 * ASC-3550 has 8KB internal memory.
d888 1
a888 2
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,
		ADW_BIOS_EN | ADW_RAM_SZ_8KB);
d891 1
a891 13
	 * Set SEL_MASK Microcode Default Value
	 *
	 * The microcode will set the SEL_MASK register using this value
	 * after it is started below.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,
		ADW_TID_TO_TIDMASK(sc->chip_scsi_id));


	/*
	 * Set-up the Host->RISC Initiator Command Queue (ICQ) if
	 * one is not already set up, i.e. this is the first
	 * time through as opposed to a bus reset.
d893 2
a894 46

	if (sc->icq_sp == NULL) {
		sc->carr_pending_cnt = 0;
		if ((sc->icq_sp = sc->carr_freelist) == NULL) {
			return ASC_IERR_NO_CARRIER;
		}
		sc->carr_freelist = adw_carrier_phys_kv(sc,
				ASC_GET_CARRP(sc->icq_sp->next_vpa));

		/*
	 	 * The first command issued will be placed in the stopper carrier.
		 */
		sc->icq_sp->next_vpa = ASC_CQ_STOPPER;
	}

	/*
	 * Set RISC ICQ physical address start value.
	 */
	ADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);

	/*
	 * Set-up the RISC->Host Initiator Response Queue (IRQ) if
	 * one is not already set up, i.e. this is the first
	 * time through as opposed to a bus reset.
	 */
	if (sc->irq_sp == NULL) {
		if ((sc->irq_sp = sc->carr_freelist) == NULL) {
			return ASC_IERR_NO_CARRIER;
		}
		sc->carr_freelist = adw_carrier_phys_kv(sc,
				ASC_GET_CARRP(sc->irq_sp->next_vpa));

		/*
 	 	 * The first command completed by the RISC will be placed in
 	 	 * the stopper.
 	 	 *
 	 	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
 	 	 * completed the RISC will set the ASC_RQ_DONE bit.
 	 	 */
		sc->irq_sp->next_vpa = ASC_CQ_STOPPER;
	}

	/*
 	 * Set RISC IRQ physical address start value.
 	 */
	ADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);
d898 1
a898 7

	/*
	 * Note: Don't remove the use of a temporary variable in
	 * the following code, otherwise some C compiler
	 * might turn the following lines into a no-op.
	 */
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);
d916 1
a916 1
		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==
d921 1
a921 1
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,
d923 1
a923 1
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,
d925 1
a925 1
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,
d929 2
a930 2
					ASC_MC_NUMBER_OF_MAX_CMD + tid,
					max_cmd[tid]);
d933 2
a934 2
			if (AdvResetCCB(sc) != ADW_TRUE) {
				warn_code = ASC_WARN_BUSRESET_ERROR;
d939 1
a939 1
    return warn_code;
d942 1
a942 8
/*
 * Initialize the ASC-38C0800.
 *
 * On failure set the ADV_DVC_VAR field 'err_code' and return ADW_ERROR.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 */
d944 4
a947 2
AdvInitAsc38C0800Driver(sc)
ADW_SOFTC      *sc;
d949 1
a949 11
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t	warn_code;
	u_int32_t	sum;
	int	  	begin_addr;
	int	   	end_addr;
	u_int16_t	code_sum;
	int	   	word;
	int	   	i, j;
	int	   	adv_asc38C0800_expanded_size;
	u_int16_t	scsi_cfg1;
a950 5
	u_int8_t	tid;
	u_int16_t	bios_mem[ASC_MC_BIOSLEN/2];	/* BIOS RISC Memory
								0x40-0x8F. */
	u_int16_t	wdtr_able, sdtr_able, tagqng_able;
	u_int8_t	max_cmd[ADW_MAX_TID + 1];
d953 22
a974 1
	warn_code = 0;
d976 19
a994 11
	/*
	 * Save the RISC memory BIOS region before writing the microcode.
	 * The BIOS may already be loaded and using its RISC LRAM region
	 * so its region must be saved and restored.
	 *
	 * Note: This code makes the assumption, which is currently true,
	 * that a chip reset does not clear RISC LRAM.
	 */
	for (i = 0; i < ASC_MC_BIOSLEN/2; i++) {
	    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
	}
d996 9
a1004 10
	/*
	 * Save current per TID negotiated values.
	 */
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);
	for (tid = 0; tid <= ADW_MAX_TID; tid++) {
		ADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,
			max_cmd[tid]);
	}
d1006 11
a1016 20
	/*
	 * RAM BIST (RAM Built-In Self Test)
	 *
	 * Address : I/O base + offset 0x38h register (byte).
	 * Function: Bit 7-6(RW) : RAM mode
	 *			    Normal Mode   : 0x00
	 *			    Pre-test Mode : 0x40
	 *			    RAM Test Mode : 0x80
	 *	     Bit 5	 : unused
	 *	     Bit 4(RO)   : Done bit
	 *	     Bit 3-0(RO) : Status
	 *			    Host Error    : 0x08
	 *			    Int_RAM Error : 0x04
	 *			    RISC Error    : 0x02
	 *			    SCSI Error    : 0x01
	 *			    No Error	  : 0x00
	 *
	 * Note: RAM BIST code should be put right here, before loading the
	 * microcode and after saving the RISC memory BIOS region.
	 */
a1017 11
	/*
	 * LRAM Pre-test
	 *
	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
	 * to NORMAL_MODE, return an error too.
	 */
	for (i = 0; i < 2; i++) {
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, PRE_TEST_MODE);
		AdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
d1019 3
a1021 3
		if ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) !=
				PRE_TEST_VALUE) {
			return ASC_IERR_BIST_PRE_TEST;
d1024 1
a1025 5
		AdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
		if (ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST)
		    != NORMAL_VALUE) {
			return ASC_IERR_BIST_PRE_TEST;
		}
d1028 23
a1050 9
	/*
	 * LRAM Test - It takes about 1.5 ms to run through the test.
	 *
	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
	 * If Done bit not set or Status not 0, save register byte, set the
	 * err_code, and return an error.
	 */
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, RAM_TEST_MODE);
	AdvSleepMilliSecond(10);  /* Wait for 10ms before checking status. */
d1052 21
a1072 4
	byte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);
	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
		/* Get here if Done bit not set or Status not 0. */
		return ASC_IERR_BIST_RAM_TEST;
a1074 3
	/* We need to reset back to normal mode after LRAM test passes. */
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);

a1075 2
	 * Load the Microcode
	 *
a1076 1
	 *
d1096 3
a1098 3
	for (i = 253 * 2; i < adv_asc38C0800_mcode_size; i++) {
		if (adv_asc38C0800_mcode[i] == 0xff) {
			for (j = 0; j < adv_asc38C0800_mcode[i + 1]; j++) {
d1100 2
a1101 3
				    (((u_int16_t)
				    adv_asc38C0800_mcode[i + 3] << 8) |
				    adv_asc38C0800_mcode[i + 2]));
d1105 4
a1108 4
		} else if (adv_asc38C0800_mcode[i] == 0xfe) {
			ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)
			    adv_asc38C0800_mcode[i + 2] << 8) |
			    adv_asc38C0800_mcode[i + 1]));
d1113 2
a1114 2
			  adv_asc38C0800_mcode[(adv_asc38C0800_mcode[i] * 2) + 1] << 8) |
			  adv_asc38C0800_mcode[adv_asc38C0800_mcode[i] * 2]));
d1124 1
a1124 1
	adv_asc38C0800_expanded_size = word;
d1127 1
a1127 1
	 * Clear the rest of ASC-38C0800 Internal RAM (16KB).
d1129 1
a1129 1
	for (; word < ADV_38C0800_MEMSIZE; word += 2) {
d1139 1
a1139 1
	for (word = 0; word < adv_asc38C0800_expanded_size; word += 2) {
d1143 2
a1144 2
	if (sum != adv_asc38C0800_mcode_chksum) {
	    return ASC_IERR_MCODE_CHKSUM;
d1150 8
a1157 3
	for (i = 0; i < ASC_MC_BIOSLEN/2; i++) {
		ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),
				bios_mem[i]);
d1162 1
a1162 1
	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
d1164 2
a1165 2
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);
d1171 19
a1189 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);
d1192 11
a1202 1
	 * Read microcode version and date.
d1204 4
a1207 4
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,
			sc->cfg.mcode_date);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,
			sc->cfg.mcode_version);
d1210 3
a1212 1
	 * Set the chip type to indicate the ASC38C0800.
d1214 3
a1216 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);
d1219 2
a1220 6
	 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
	 * cable detection and then we are able to read C_DET[3:0].
	 *
	 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
	 * Microcode Default Value' section below.
d1222 4
a1225 3
	scsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,
			scsi_cfg1 | ADW_DIS_TERM_DRV);
d1228 6
a1233 4
	 * If the PCI Configuration Command Register "Parity Error Response
	 * Control" Bit was clear (0), then set the microcode variable
	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
	 * to ignore DMA parity errors.
d1235 1
a1235 1
	if (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {
d1237 4
a1240 3
		 * Note: Don't remove the use of a temporary variable in
		 * the following code, otherwise some C compiler
		 * might turn the following lines into a no-op.
d1242 20
a1261 3
		ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);
		word |= CONTROL_FLAG_IGNORE_PERR;
		ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);
d1265 1
a1265 6
	 * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]
	 * bits for the default FIFO threshold.
	 *
	 * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.
	 *
	 * For DMA Errata #4 set the BC_THRESH_ENB bit.
d1267 1
a1267 2
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,
		BC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
d1270 4
a1273 10
	 * Microcode operating variables for WDTR, SDTR, and command tag
	 * queuing will be set in AdvInquiryHandling() based on what a
	 * device reports it is capable of in Inquiry byte 7.
	 *
	 * If SCSI Bus Resets have been disabled, then directly set
	 * SDTR and WDTR from the EEPROM configuration. This will allow
	 * the BIOS and warm boot to work without a SCSI bus hang on
	 * the Inquiry caused by host and target mismatched DTR values.
	 * Without the SCSI Bus Reset, before an Inquiry a device can't
	 * be assumed to be in Asynchronous, Narrow mode.
d1275 1
a1275 4
	if ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
		ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, sc->wdtr_able);
		ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sc->sdtr_able);
	}
d1278 4
a1281 3
	 * Set microcode operating variables for DISC and SDTR_SPEED1,
	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
	 * configuration values.
d1283 2
a1284 3
	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
	 * without determining here whether the device supports SDTR.
d1286 2
a1287 5
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, sc->sdtr_speed1);
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, sc->sdtr_speed2);
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, sc->sdtr_speed3);
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, sc->sdtr_speed4);
d1290 1
a1290 1
	 * Set SCSI_CFG0 Microcode Default Value.
d1292 1
a1292 1
	 * The microcode will set the SCSI_CFG0 register using this value
d1294 5
d1300 15
a1314 3
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,
		ADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |
			sc->chip_scsi_id);
d1327 6
a1332 7
	 * If the internal narrow cable is reversed all of the SCSI_CTRL
	 * register signals will be set. Check for and return an error if
	 * this condition is found.
	 */
	if ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==
			0x3F07) {
		return ASC_IERR_REVERSED_CABLE;
d1336 11
a1346 7
	 * All kind of combinations of devices attached to one of four connectors
	 * are acceptable except HVD device attached. For example, LVD device can
	 * be attached to SE connector while SE device attached to LVD connector.
	 * If LVD device attached to SE connector, it only runs up to Ultra speed.
	 *
	 * If an HVD device is attached to one of LVD connectors, return an error.
	 * However, there is no way to detect HVD device attached to SE connectors.
d1349 1
a1349 1
		return ASC_IERR_HVD_DEVICE;
d1357 2
a1358 2
	 * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to
	 * be 'ored' into SCSI_CFG1.
d1360 1
a1360 1
	if ((sc->cfg.termination & ADW_TERM_SE) == 0) {
d1365 1
a1365 1
				sc->cfg.termination |= ADW_TERM_SE;
d1370 1
a1370 1
				sc->cfg.termination |= ADW_TERM_SE_HI;
d1375 1
a1375 1
	if ((sc->cfg.termination & ADW_TERM_LVD) == 0) {
d1380 1
a1380 1
				sc->cfg.termination |= ADW_TERM_LVD;
d1397 1
a1397 1
	scsi_cfg1 |= (~sc->cfg.termination & 0xF0);
d1400 3
a1402 3
	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits
	 * and set possibly modified termination control bits in the Microcode
	 * SCSI_CFG1 Register Value.
d1405 1
a1405 1
			~ADW_TERM_POL & ~ADW_HVD_LVD_SE);
d1416 1
a1416 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
d1427 1
a1427 307
	 * ASC-38C0800 has 16KB internal memory.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,
		ADW_BIOS_EN | ADW_RAM_SZ_16KB);

	/*
	 * Set SEL_MASK Microcode Default Value
	 *
	 * The microcode will set the SEL_MASK register using this value
	 * after it is started below.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,
		ADW_TID_TO_TIDMASK(sc->chip_scsi_id));


	/*
	 * Set-up the Host->RISC Initiator Command Queue (ICQ) if
	 * one is not already set up, i.e. this is the first
	 * time through as opposed to a bus reset.
	 */

	if (sc->icq_sp == NULL) {
		sc->carr_pending_cnt = 0;
		if ((sc->icq_sp = sc->carr_freelist) == NULL) {
			return ASC_IERR_NO_CARRIER;
		}
		sc->carr_freelist = adw_carrier_phys_kv(sc,
				ASC_GET_CARRP(sc->icq_sp->next_vpa));


		/*
	 	 * The first command issued will be placed in the stopper carrier.
	 	 */
		sc->icq_sp->next_vpa = ASC_CQ_STOPPER;
	}

	/*
	 * Set RISC ICQ physical address start value.
	 */
	ADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);

	/*
	 * Set-up the RISC->Host Initiator Response Queue (IRQ) if
	 * one is not already set up, i.e. this is the first
	 * time through as opposed to a bus reset.
	 */
	if (sc->irq_sp == NULL) {
		if ((sc->irq_sp = sc->carr_freelist) == NULL) {
			return ASC_IERR_NO_CARRIER;
		}
		sc->carr_freelist = adw_carrier_phys_kv(sc,
				ASC_GET_CARRP(sc->irq_sp->next_vpa));

		/*
	 	 * The first command completed by the RISC will be placed in
	 	 * the stopper.
	 	 *
	 	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
	 	 * completed the RISC will set the ASC_RQ_DONE bit.
	 	 */
		sc->irq_sp->next_vpa = ASC_CQ_STOPPER;
	}

	/*
	 * Set RISC IRQ physical address start value.
	 */
	ADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);

	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,
		(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));
	/*
	 * Note: Don't remove the use of a temporary variable in
	 * the following code, otherwise some C compiler
	 * might turn the following lines into a no-op.
	 */
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);

	/* finally, finally, gentlemen, start your engine */
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);

	/*
	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
	 * Resets should be performed. The RISC has to be running
	 * to issue a SCSI Bus Reset.
	 */
	if (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
		/*
		 * If the BIOS Signature is present in memory, restore the
		 * BIOS Handshake Configuration Table and do not perform
		 * a SCSI Bus Reset.
		 */
		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==
				0x55AA) {
			/*
			 * Restore per TID negotiated values.
			 */
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,
					tagqng_able);
			for (tid = 0; tid <= ADW_MAX_TID; tid++) {
				ADW_WRITE_BYTE_LRAM(iot, ioh,
						ASC_MC_NUMBER_OF_MAX_CMD + tid,
						max_cmd[tid]);
			}
		} else {
			if (AdvResetCCB(sc) != ADW_TRUE) {
				warn_code = ASC_WARN_BUSRESET_ERROR;
			}
		}
	}

	return warn_code;
}


/*
 * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
 * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
 * all of this is done.
 *
 * On failure set the ADV_DVC_VAR field 'err_code' and return ADW_ERROR.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 *
 * Note: Chip is stopped on entry.
 */
int
AdvInitFrom3550EEP(sc)
ADW_SOFTC      *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t		warn_code;
	ADW_EEP_3550_CONFIG	eep_config;
	int			i;


	warn_code = 0;

	/*
	 * Read the board's EEPROM configuration.
	 *
	 * Set default values if a bad checksum is found.
	 */
	if (AdvGet3550EEPConfig(iot, ioh, &eep_config) != eep_config.check_sum){
		warn_code |= ASC_WARN_EEPROM_CHKSUM;

		/*
		 * Set EEPROM default values.
		 */
		for (i = 0; i < sizeof(ADW_EEP_3550_CONFIG); i++) {
			*((u_int8_t *) &eep_config + i) =
				*((u_int8_t *) &Default_3550_EEPROM_Config + i);
		}

		/*
		 * Assume the 6 byte board serial number that was read
		 * from EEPROM is correct even if the EEPROM checksum
		 * failed.
		 */
		eep_config.serial_number_word3 =
			AdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);

		eep_config.serial_number_word2 =
			AdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);

		eep_config.serial_number_word1 =
			AdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);

		AdvSet3550EEPConfig(iot, ioh, &eep_config);
	}
	/*
	 * Set sc_VAR and sc_CFG variables from the
	 * EEPROM configuration that was read.
	 *
	 * This is the mapping of EEPROM fields to Adv Library fields.
	 */
	sc->wdtr_able = eep_config.wdtr_able;
	sc->sdtr_able = eep_config.sdtr_able;
	sc->ultra_able = eep_config.ultra_able;
	sc->tagqng_able = eep_config.tagqng_able;
	sc->cfg.disc_enable = eep_config.disc_enable;
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;
	sc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);
	sc->start_motor = eep_config.start_motor;
	sc->scsi_reset_wait = eep_config.scsi_reset_delay;
	sc->bios_ctrl = eep_config.bios_ctrl;
	sc->no_scam = eep_config.scam_tolerant;
	sc->cfg.serial1 = eep_config.serial_number_word1;
	sc->cfg.serial2 = eep_config.serial_number_word2;
	sc->cfg.serial3 = eep_config.serial_number_word3;

	/*
	 * Set the host maximum queuing (max. 253, min. 16) and the per device
	 * maximum queuing (max. 63, min. 4).
	 */
	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)
	{
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_host_qng == 0) {
			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
		} else {
			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
		}
	}

	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_dvc_qng == 0) {
			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
		} else {
			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
		}
	}

	/*
	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
	 * set 'max_dvc_qng' to 'max_host_qng'.
	 */
	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
		eep_config.max_dvc_qng = eep_config.max_host_qng;
	}

	/*
	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
	 * values based on possibly adjusted EEPROM values.
	 */
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;


	/*
	 * If the EEPROM 'termination' field is set to automatic (0), then set
	 * the ADV_DVC_CFG 'termination' field to automatic also.
	 *
	 * If the termination is specified with a non-zero 'termination'
	 * value check that a legal value is set and set the ADV_DVC_CFG
	 * 'termination' field appropriately.
	 */
	if (eep_config.termination == 0) {
		sc->cfg.termination = 0;    /* auto termination */
	} else {
		/* Enable manual control with low off / high off. */
		if (eep_config.termination == 1) {
			sc->cfg.termination = ADW_TERM_CTL_SEL;

		/* Enable manual control with low off / high on. */
		} else if (eep_config.termination == 2) {
			sc->cfg.termination = ADW_TERM_CTL_SEL | ADW_TERM_CTL_H;

		/* Enable manual control with low on / high on. */
		} else if (eep_config.termination == 3) {
			sc->cfg.termination = ADW_TERM_CTL_SEL |
					ADW_TERM_CTL_H | ADW_TERM_CTL_L;
		} else {
			/*
			 * The EEPROM 'termination' field contains a bad value. Use
			 * automatic termination instead.
			 */
			sc->cfg.termination = 0;
			warn_code |= ASC_WARN_EEPROM_TERMINATION;
		}
	}

	return warn_code;
}


/*
 * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
 * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
 * all of this is done.
 *
 * On failure set the ADV_DVC_VAR field 'err_code' and return ADW_ERROR.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 *
 * Note: Chip is stopped on entry.
 */
int
AdvInitFrom38C0800EEP(sc)
ADW_SOFTC      *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t		warn_code;
	ADW_EEP_38C0800_CONFIG	eep_config;
	int			i;
	u_int8_t		tid, termination;
	u_int16_t		sdtr_speed = 0;


	warn_code = 0;

	/*
	 * Read the board's EEPROM configuration.
	 *
	 * Set default values if a bad checksum is found.
d1429 2
a1430 3
	if (AdvGet38C0800EEPConfig(iot, ioh, &eep_config) != 
			eep_config.check_sum) {
		warn_code |= ASC_WARN_EEPROM_CHKSUM;
d1432 2
a1433 7
		/*
		 * Set EEPROM default values.
		 */
		for (i = 0; i < sizeof(ADW_EEP_38C0800_CONFIG); i++) {
			*((u_int8_t *) &eep_config + i) =
				*((u_int8_t *)&Default_38C0800_EEPROM_Config+i);
		}
a1434 7
		/*
		 * Assume the 6 byte board serial number that was read
		 * from EEPROM is correct even if the EEPROM checksum
		 * failed.
		 */
		eep_config.serial_number_word3 =
			AdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);
d1436 7
a1442 2
		eep_config.serial_number_word2 =
			AdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);
a1443 2
		eep_config.serial_number_word1 =
			AdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);
a1444 2
		AdvSet38C0800EEPConfig(iot, ioh, &eep_config);
	}
d1446 1
a1446 2
	 * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the
	 * EEPROM configuration that was read.
d1448 4
a1451 1
	 * This is the mapping of EEPROM fields to Adv Library fields.
d1453 3
a1455 17
	sc->wdtr_able = eep_config.wdtr_able;
	sc->sdtr_speed1 = eep_config.sdtr_speed1;
	sc->sdtr_speed2 = eep_config.sdtr_speed2;
	sc->sdtr_speed3 = eep_config.sdtr_speed3;
	sc->sdtr_speed4 = eep_config.sdtr_speed4;
	sc->tagqng_able = eep_config.tagqng_able;
	sc->cfg.disc_enable = eep_config.disc_enable;
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;
	sc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);
	sc->start_motor = eep_config.start_motor;
	sc->scsi_reset_wait = eep_config.scsi_reset_delay;
	sc->bios_ctrl = eep_config.bios_ctrl;
	sc->no_scam = eep_config.scam_tolerant;
	sc->cfg.serial1 = eep_config.serial_number_word1;
	sc->cfg.serial2 = eep_config.serial_number_word2;
	sc->cfg.serial3 = eep_config.serial_number_word3;
d1458 3
a1460 2
	 * For every Target ID if any of its 'sdtr_speed[1234]' bits
	 * are set, then set an 'sdtr_able' bit for it.
d1462 2
a1463 15
	sc->sdtr_able = 0;
	for (tid = 0; tid <= ADW_MAX_TID; tid++) {
		if (tid == 0) {
			sdtr_speed = sc->sdtr_speed1;
		} else if (tid == 4) {
			sdtr_speed = sc->sdtr_speed2;
		} else if (tid == 8) {
			sdtr_speed = sc->sdtr_speed3;
		} else if (tid == 12) {
			sdtr_speed = sc->sdtr_speed4;
		}
		if (sdtr_speed & ADW_MAX_TID) {
			sc->sdtr_able |= (1 << tid);
		}
		sdtr_speed >>= 4;
d1467 6
a1472 2
	 * Set the host maximum queuing (max. 253, min. 16) and the per device
	 * maximum queuing (max. 63, min. 4).
d1474 2
a1475 9
	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_host_qng == 0) {
			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
		} else {
			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
		}
d1478 34
a1511 9
	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_dvc_qng == 0) {
			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
		} else {
			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
		}
d1515 6
a1520 2
	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
	 * set 'max_dvc_qng' to 'max_host_qng'.
d1522 1
a1522 3
	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
		eep_config.max_dvc_qng = eep_config.max_host_qng;
	}
d1525 3
a1527 2
	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
	 * values based on possibly adjusted EEPROM values.
d1529 1
a1529 2
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;
d1532 4
a1535 2
	 * If the EEPROM 'termination' field is set to automatic (0), then set
	 * the ADV_DVC_CFG 'termination' field to automatic also.
d1537 2
a1538 3
	 * If the termination is specified with a non-zero 'termination'
	 * value check that a legal value is set and set the ADV_DVC_CFG
	 * 'termination' field appropriately.
d1540 1
a1540 6
	if (eep_config.termination_se == 0) {
		termination = 0;	/* auto termination for SE */
	} else {
		/* Enable manual control with low off / high off. */
		if (eep_config.termination_se == 1) {
			termination = 0;
d1542 13
a1554 26
		/* Enable manual control with low off / high on. */
		} else if (eep_config.termination_se == 2) {
			termination = ADW_TERM_SE_HI;

		/* Enable manual control with low on / high on. */
		} else if (eep_config.termination_se == 3) {
			termination = ADW_TERM_SE;
		} else {
			/*
			 * The EEPROM 'termination_se' field contains 
			 * a bad value.
			 * Use automatic termination instead.
			 */
			termination = 0;
			warn_code |= ASC_WARN_EEPROM_TERMINATION;
		}
	}

	if (eep_config.termination_lvd == 0) {
		/* auto termination for LVD */
		sc->cfg.termination = termination;
	} else
	{
		/* Enable manual control with low off / high off. */
		if (eep_config.termination_lvd == 1) {
			sc->cfg.termination = termination;
d1556 1
a1556 18
		/* Enable manual control with low off / high on. */
		} else if (eep_config.termination_lvd == 2) {
			sc->cfg.termination = termination | ADW_TERM_LVD_HI;

		/* Enable manual control with low on / high on. */
		} else if (eep_config.termination_lvd == 3) {
			sc->cfg.termination = termination | ADW_TERM_LVD;
		} else {
			/*
			 * The EEPROM 'termination_lvd' field contains a bad value.
			 * Use automatic termination instead.
			 */
			sc->cfg.termination = termination;
			warn_code |= ASC_WARN_EEPROM_TERMINATION;
		}
	}

	return warn_code;
d1566 1
a1566 1
AdvGet3550EEPConfig(iot, ioh, cfg_buf)
d1569 1
a1569 1
	ADW_EEP_3550_CONFIG	*cfg_buf;
d1580 3
a1582 42
			eep_addr < ASC_EEP_DVC_CFG_END;
			eep_addr++, wbuf++) {
		wval = AdvReadEEPWord(iot, ioh, eep_addr);
		chksum += wval;
		*wbuf = wval;
	}

	*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);
	wbuf++;
	for (eep_addr = ASC_EEP_DVC_CTL_BEGIN;
			eep_addr < ASC_EEP_MAX_WORD_ADDR;
			eep_addr++, wbuf++) {
		*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);
	}

	return chksum;
}


/*
 * Read EEPROM configuration into the specified buffer.
 *
 * Return a checksum based on the EEPROM configuration read.
 */
static u_int16_t
AdvGet38C0800EEPConfig(iot, ioh, cfg_buf)
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;
	ADW_EEP_38C0800_CONFIG	*cfg_buf;
{
	u_int16_t	wval, chksum;
	u_int16_t	*wbuf;
	int		eep_addr;


	wbuf = (u_int16_t *) cfg_buf;
	chksum = 0;

	for (eep_addr = ASC_EEP_DVC_CFG_BEGIN;
			eep_addr < ASC_EEP_DVC_CFG_END;
			eep_addr++, wbuf++) {
		wval = AdvReadEEPWord(iot, ioh, eep_addr);
d1587 1
a1587 1
	*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);
d1592 1
a1592 1
		*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);
d1603 1
a1603 1
AdvReadEEPWord(iot, ioh, eep_word_addr)
d1610 1
a1610 1
	AdvWaitEEPCmd(iot, ioh);
d1620 1
a1620 1
AdvWaitEEPCmd(iot, ioh)
d1632 1
a1632 1
		AdvSleepMilliSecond(1);
d1643 1
a1643 61
AdvSet3550EEPConfig(iot, ioh, cfg_buf)
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;
	ADW_EEP_3550_CONFIG	*cfg_buf;
{
	u_int16_t *wbuf;
	u_int16_t addr, chksum;


	wbuf = (u_int16_t *) cfg_buf;
	chksum = 0;

	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
	AdvWaitEEPCmd(iot, ioh);

	/*
	 * Write EEPROM from word 0 to word 20
	 */
	for (addr = ASC_EEP_DVC_CFG_BEGIN;
	     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {
		chksum += *wbuf;
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,
				ASC_EEP_CMD_WRITE | addr);
		AdvWaitEEPCmd(iot, ioh);
		AdvSleepMilliSecond(ASC_EEP_DELAY_MS);
	}

	/*
	 * Write EEPROM checksum at word 21
	 */
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,
			ASC_EEP_CMD_WRITE | addr);
	AdvWaitEEPCmd(iot, ioh);
	wbuf++;        /* skip over check_sum */

	/*
	 * Write EEPROM OEM name at words 22 to 29
	 */
	for (addr = ASC_EEP_DVC_CTL_BEGIN;
	     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,
				ASC_EEP_CMD_WRITE | addr);
		AdvWaitEEPCmd(iot, ioh);
	}

	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,
			ASC_EEP_CMD_WRITE_DISABLE);
	AdvWaitEEPCmd(iot, ioh);

	return;
}


/*
 * Write the EEPROM from 'cfg_buf'.
 */
static void
AdvSet38C0800EEPConfig(iot, ioh, cfg_buf)
d1646 1
a1646 1
	ADW_EEP_38C0800_CONFIG	*cfg_buf;
d1656 1
a1656 1
	AdvWaitEEPCmd(iot, ioh);
d1667 2
a1668 2
		AdvWaitEEPCmd(iot, ioh);
		AdvSleepMilliSecond(ASC_EEP_DELAY_MS);
d1677 1
a1677 1
	AdvWaitEEPCmd(iot, ioh);
d1688 1
a1688 1
		AdvWaitEEPCmd(iot, ioh);
d1693 1
a1693 1
	AdvWaitEEPCmd(iot, ioh);
d1700 1
a1700 1
 * AdvExeScsiQueue() - Send a request to the RISC microcode program.
d1717 1
a1717 1
AdvExeScsiQueue(sc, scsiq)
d1726 1
a1726 3
	ADW_CARRIER	*new_carrp, *new_freep/*, *ccb_carr;
	int		i*/;

d1737 4
a1741 1
	ccb->carr_list = sc->icq_sp;
d1744 1
a1744 2
	 * Allocate a carrier ensuring at least one carrier always
	 * remains on the freelist and initialize fields.
d1746 1
a1746 5
	new_carrp = sc->carr_freelist;
        new_freep = adw_carrier_phys_kv( sc, 
					 ASC_GET_CARRP( new_carrp->next_vpa) );

	if (new_freep == NULL) {
d1749 2
a1750 1
	sc->carr_freelist = new_freep;
d1754 1
a1754 1
	 * Set the carrier to be a stopper by setting 'next_vpa'
d1758 1
a1758 1
	new_carrp->next_vpa = ASC_CQ_STOPPER;
d1768 1
a1768 1
	 * Every ADV_CARR_T.carr_pa is byte swapped to little-endian
d1771 2
a1772 2
	scsiq->carr_pa = sc->icq_sp->carr_pa;
	scsiq->carr_va = sc->icq_sp->carr_pa;
d1779 1
a1779 1
	sc->icq_sp->areq_vpa = req_paddr;
d1782 1
a1782 1
	 * Set the 'next_vpa' pointer for the old stopper to be the
d1786 1
a1786 1
	sc->icq_sp->next_vpa = new_carrp->carr_pa;
d1788 7
d1800 17
a1816 36
/*	ccb_carr = ccb->carr_list;
	while(ccb_carr != ASC_CQ_STOPPER) {
		bus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,
				ccb_carr, ADW_CARRIER_SIZE,
				NULL, BUS_DMA_NOWAIT);
		bus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,
				ccb_carr->dmamap_xfer->dm_mapsize,
				BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		ccb_carr = adw_carrier_phys_kv(sc,
				ASC_GET_CARRP(ccb_carr->next_vpa));
	}

	ccb_carr = sc->irq_sp;
	for(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {
		bus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,
				ccb_carr, ADW_CARRIER_SIZE,
				NULL, BUS_DMA_NOWAIT);
		bus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,
				ccb_carr->dmamap_xfer->dm_mapsize,
				BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		ccb_carr = adw_carrier_phys_kv(sc,
				ASC_GET_CARRP(ccb_carr->next_vpa));
	}
*/
	bus_dmamap_load(sc->sc_dmat, sc->sc_control->dmamap_xfer,
			sc->sc_control->carriers, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,
			NULL, BUS_DMA_NOWAIT);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,
			BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	/*
	 * Tickle the RISC to tell it to read its Command Queue Head pointer.
	 */
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);
	if (sc->chip_type == ADV_CHIP_ASC3550)
	{
d1818 2
a1819 3
		 * Clear the tickle value. In the ASC-3550 the RISC flag
		 * command 'clr_tickle_a' does not work unless the host
		 * value is cleared.
d1821 2
a1822 1
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);
d1825 4
d1834 1
a1834 1
AdvResetChip(iot, ioh)
d1844 1
a1844 1
	AdvSleepMilliSecond(100);
d1860 1
a1860 1
AdvResetCCB(sc)
d1869 2
a1870 3
	status = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_START, 0L);
	if (status != ADW_TRUE)
	{
d1880 1
a1880 1
	AdvDelayMicroSecond((u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US);
d1886 2
a1887 3
	status = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_END, 0L);
	if (status != ADW_TRUE)
	{
d1891 1
a1891 1
	AdvSleepMilliSecond((u_int32_t) sc->scsi_reset_wait * 1000);
d1905 1
a1905 1
AdvResetSCSIBus(sc)
d1911 1
a1911 1
	u_int16_t	wdtr_able, sdtr_able, tagqng_able;
d1919 8
a1926 6
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);
	for (tid = 0; tid <= ADW_MAX_TID; tid++)
	{
		ADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,
d1931 2
a1932 2
	 * Force the AdvInitAsc3550/38C0800Driver() function to
	 * perform a SCSI Bus Reset by clearing the BIOS signature word.
d1936 2
a1937 2
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, 0);
d1945 1
a1945 1
	AdvSleepMilliSecond(100);
d1952 1
d1954 1
a1954 12
	if (sc->chip_type == ADV_CHIP_ASC38C0800) {
		status = AdvInitAsc38C0800Driver(sc);
	} else {
		status = AdvInitAsc3550Driver(sc);
	}

	/* Translate initialization return value to status value. */
	if (status == 0) {
		status = ADW_TRUE;
	} else {
		status = ADW_FALSE;
	}
d1959 1
a1959 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);
d1964 6
a1969 3
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);
d1971 1
a1971 1
		ADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,
d1988 1
a1988 1
 *  Note: AdvISR() can be called when interrupts are disabled or even
d1999 1
a1999 1
AdvISR(sc)
d2010 2
a2011 1
//	int		i;
d2013 1
d2020 1
a2023 14
	bus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,
		BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, sc->sc_control->dmamap_xfer);

/*	ccb_carr = sc->irq_sp;
	for(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {
		bus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,
			ccb_carr->dmamap_xfer->dm_mapsize,
			BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);
		ccb_carr = adw_carrier_phys_kv(sc,
			ASC_GET_CARRP(ccb_carr->next_vpa));
	}
*/
d2027 1
a2027 1
	 * is passed the microcode ASC_MC_INTRB_CODE byte value.
d2032 13
a2044 7
		ADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_INTRB_CODE, intrb_code);
		if (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&
		    sc->carr_pending_cnt != 0) {
		    ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);
		    if (sc->chip_type == ADV_CHIP_ASC3550) {
		    	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);
		    }
d2055 1
a2055 1
	while (((irq_next_pa = sc->irq_sp->next_vpa) & ASC_RQ_DONE) != 0)
d2057 11
a2067 3
		/*
		 * Get a pointer to the newly completed ADW_SCSI_REQ_Q structure.
		 * The RISC will have set 'areq_vpa' to a virtual address.
d2070 3
a2072 3
		 * field to the carrier ADV_CARR_T.areq_vpa field. The conversion
		 * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'
		 * in AdvExeScsiQueue().
d2074 1
a2074 1
		ccb = adw_ccb_phys_kv(sc, sc->irq_sp->areq_vpa);
d2076 12
a2087 1
		scsiq->ccb_ptr = sc->irq_sp->areq_vpa;
a2088 15
/*		ccb_carr = ccb->carr_list;
		while(ccb_carr != ASC_CQ_STOPPER) {
			bus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,
				ccb_carr->dmamap_xfer->dm_mapsize,
				BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);
			ccb_carr = adw_carrier_phys_kv(sc,
				ASC_GET_CARRP(ccb_carr->next_vpa));
		}

		bus_dmamap_sync(sc->sc_dmat, sc->irq_sp->dmamap_xfer, 0,
			sc->irq_sp->dmamap_xfer->dm_mapsize,
			BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, sc->irq_sp->dmamap_xfer);
*/
d2095 1
a2095 1
		sc->irq_sp = adw_carrier_phys_kv(sc, ASC_GET_CARRP(irq_next_pa));
d2097 2
a2098 1
		free_carrp->next_vpa = sc->carr_freelist->carr_pa;
d2119 3
a2121 3
		    	 scsiq->cdb[0] == INQUIRY &&
		    	 scsiq->target_lun == 0) {
			AdvInquiryHandling(sc, scsiq);
d2138 2
d2159 1
a2159 1
AdvSendIdleCmd(sc, idle_cmd, idle_cmd_parameter)
d2166 3
a2168 3
	int		result;
	u_int32_t	s, i, j;
 
a2173 2
	 * The non-zero result is one of the IDLE_CMD_STATUS_* values
	 * defined in a_advlib.h.
d2175 1
a2175 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, (u_int16_t) 0);
d2183 3
a2185 3
	ADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_PARAMETER,
	    idle_cmd_parameter);
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD, idle_cmd);
d2191 1
a2191 1
	if (sc->chip_type == ADV_CHIP_ASC3550) {
d2204 2
a2205 1
			ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, result);
d2210 1
a2210 1
			AdvDelayMicroSecond(1);
d2227 1
a2227 1
AdvInquiryHandling(sc, scsiq)
d2241 1
a2241 1
	 * AdvInquiryHandling() requires up to INQUIRY information Byte 7
d2256 1
a2256 1
	inq = (ADW_SCSI_INQUIRY *) scsiq->vdata_addr;
d2261 2
a2262 1
	if (inq->rsp_data_fmt < 2 && inq->ansi_apr_ver < 2) {
d2288 1
a2288 1
			ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,
d2292 1
a2292 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,
d2296 4
a2299 3
				 * Clear the microcode "SDTR negotiation" and "WDTR
				 * negotiation" done indicators for the target to cause
				 * it to negotiate with the new setting set above.
d2301 1
a2301 1
				 * asynchronous mode, so SDTR must be negotiated.
d2303 1
a2303 1
				ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_DONE,
d2306 1
a2306 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_DONE,
d2308 1
a2308 1
				ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_DONE,
d2311 1
a2311 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_DONE,
d2327 1
a2327 1
			ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, cfg_word);
d2330 1
a2330 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,
d2334 3
a2336 3
				 * Clear the microcode "SDTR negotiation" done indicator
				 * for the target to cause it to negotiate with the new
				 * setting set above.
d2338 1
a2338 1
				ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_DONE,
d2341 1
a2341 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_DONE,
d2345 24
d2386 1
a2386 1
			ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,
d2389 1
a2389 1
			ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,
d2393 1
a2393 1
					ASC_MC_NUMBER_OF_MAX_CMD + tid,
d2402 1
a2402 1
AdvSleepMilliSecond(n)
d2411 1
a2411 1
AdvDelayMicroSecond(n)
@


1.7
log
@Bring code into line with comment and ensure
that carr_freelist always has a carrier on
it. This should fix a problem where carr_freelist
has become NULL and then AdvISR() attempts to
put a carrier back on the list without checking
if carr_freelist is non-NULL.

This and the previous two changes to adwlib.c
and the change committed to adw.c at the same
time were derived in whole or part from work
done by/with dante@@ from NetBSD.
@
text
@d1 1
@


1.6
log
@Stop losing carriers during bus reset, by not re-init'ing icq_sp/irq_sp
@
text
@d1885 1
a1885 1
	ADW_CARRIER	*new_carrp/*, *ccb_carr;
d1905 5
a1909 1
	if ((new_carrp = sc->carr_freelist) == NULL) {
d1912 1
a1912 2
	sc->carr_freelist = adw_carrier_phys_kv(sc,
			ASC_GET_CARRP(new_carrp->next_vpa));
@


1.5
log
@AdvSendIdleCmd() not re-entrant - use splbio()/splx(). Two typos.
@
text
@d611 3
a613 1
	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
d616 12
a627 2
	if ((sc->icq_sp = sc->carr_freelist) == NULL) {
		return ASC_IERR_NO_CARRIER;
a628 7
	sc->carr_freelist = adw_carrier_phys_kv(sc,
			ASC_GET_CARRP(sc->icq_sp->next_vpa));

	/*
	 * The first command issued will be placed in the stopper carrier.
	 */
	sc->icq_sp->next_vpa = ASC_CQ_STOPPER;
d636 19
a654 4
	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
	 */
	if ((sc->irq_sp = sc->carr_freelist) == NULL) {
		return ASC_IERR_NO_CARRIER;
a655 11
	sc->carr_freelist = adw_carrier_phys_kv(sc,
			ASC_GET_CARRP(sc->irq_sp->next_vpa));

	/*
	 * The first command completed by the RISC will be placed in
	 * the stopper.
	 *
	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
	 * completed the RISC will set the ASC_RQ_STOPPER bit.
	 */
	sc->irq_sp->next_vpa = ASC_CQ_STOPPER;
d658 2
a659 2
	 * Set RISC IRQ physical address start value.
	 */
a660 1
	sc->carr_pending_cnt = 0;
d1151 3
a1153 1
	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
d1156 7
a1162 5
	if ((sc->icq_sp = sc->carr_freelist) == NULL) {
		return ASC_IERR_NO_CARRIER;
	}
	sc->carr_freelist = adw_carrier_phys_kv(sc,
			ASC_GET_CARRP(sc->icq_sp->next_vpa));
d1165 5
a1169 4
	/*
	 * The first command issued will be placed in the stopper carrier.
	 */
	sc->icq_sp->next_vpa = ASC_CQ_STOPPER;
d1177 19
a1195 4
	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
	 */
	if ((sc->irq_sp = sc->carr_freelist) == NULL) {
		return ASC_IERR_NO_CARRIER;
a1196 11
	sc->carr_freelist = adw_carrier_phys_kv(sc,
			ASC_GET_CARRP(sc->irq_sp->next_vpa));

	/*
	 * The first command completed by the RISC will be placed in
	 * the stopper.
	 *
	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
	 * completed the RISC will set the ASC_RQ_STOPPER bit.
	 */
	sc->irq_sp->next_vpa = ASC_CQ_STOPPER;
a1201 1
	sc->carr_pending_cnt = 0;
@


1.4
log
@From NetBSD:
    Check for SCSI_ADW_WDTR_DISABLE flag in tidmask not tid
@
text
@d102 1
a102 1
 * Additional structure information can be found in advlib.h where
d2306 1
a2306 1
 * But the function is not re-entrant, so it uses the DvcEnter/LeaveCritical()
d2323 3
a2325 2
	u_int32_t	i, j;

d2364 1
d2371 1
@


1.3
log
@sync with netbsd. ok @@deraadt
@
text
@d2438 1
a2438 1
	if(!(tid & SCSI_ADW_WDTR_DISABLE))
d2476 1
a2476 1
	if(!(tid & SCSI_ADW_SDTR_DISABLE))
d2511 1
a2511 1
	if(!(tid & SCSI_ADW_TAGQ_DISABLE))
@


1.3.2.1
log
@Merge in recent code from the trunk
@
text
@d2438 1
a2438 1
	if(!(tidmask & SCSI_ADW_WDTR_DISABLE))
d2476 1
a2476 1
	if(!(tidmask & SCSI_ADW_SDTR_DISABLE))
d2511 1
a2511 1
	if(!(tidmask & SCSI_ADW_TAGQ_DISABLE))
@


1.3.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: adwlib.c,v 1.13 2001/04/11 04:05:16 krw Exp $ */
/* $NetBSD: adwlib.c,v 1.20 2000/07/04 04:17:03 itojun Exp $        */
d45 1
a45 1
 * Copyright (c) 1995-2000 Advanced System Products, Inc.
d71 2
a74 1
#include <dev/microcode/adw/adwmcode.h>
d76 1
d81 11
a91 15
int AdwRamSelfTest __P((bus_space_tag_t, bus_space_handle_t, u_int8_t));
int AdwLoadMCode __P((bus_space_tag_t, bus_space_handle_t, u_int16_t *,
								u_int8_t));
int AdwASC3550Cabling __P((bus_space_tag_t, bus_space_handle_t, ADW_DVC_CFG *));
int AdwASC38C0800Cabling __P((bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *));
int AdwASC38C1600Cabling __P((bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *));

static u_int16_t AdwGetEEPROMConfig __P((bus_space_tag_t, bus_space_handle_t,
     							ADW_EEPROM *));
static void AdwSetEEPROMConfig __P((bus_space_tag_t, bus_space_handle_t,
					                 ADW_EEPROM *));
static u_int16_t AdwReadEEPWord __P((bus_space_tag_t, bus_space_handle_t, int));
static void AdwWaitEEPCmd __P((bus_space_tag_t, bus_space_handle_t));
d93 2
a94 4
static void AdwInquiryHandling __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));

static void AdwSleepMilliSecond __P((u_int32_t));
static void AdwDelayMicroSecond __P((u_int32_t));
d102 1
a102 1
 * Additional structure information can be found in adwlib.h where
d105 36
a140 35
const static ADW_EEPROM adw_3550_Default_EEPROM = {
	ADW_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
	0x0000,			/* 01 cfg_msw */
	0xFFFF,			/* 02 disc_enable */
	0xFFFF,			/* 03 wdtr_able */
	{ 0xFFFF },		/* 04 sdtr_able */
	0xFFFF,			/* 05 start_motor */
	0xFFFF,			/* 06 tagqng_able */
	0xFFFF,			/* 07 bios_scan */
	0,			/* 08 scam_tolerant */
	7,			/* 09 adapter_scsi_id */
	0,			/*    bios_boot_delay */
	3,			/* 10 scsi_reset_delay */
	0,			/*    bios_id_lun */
	0,			/* 11 termination */
	0,			/*    reserved1 */
	0xFFE7,			/* 12 bios_ctrl */
	{ 0xFFFF },		/* 13 ultra_able */
	{ 0 },			/* 14 reserved2 */
	ADW_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
	ADW_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
	0,			/* 16 dvc_cntl */
	{ 0 },			/* 17 bug_fix */
	{ 0,0,0 },		/* 18-20 serial_number[3] */
	0,			/* 21 check_sum */
	{			/* 22-29 oem_name[16] */
	  0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0
	},
	0,			/* 30 dvc_err_code */
	0,			/* 31 adw_err_code */
	0,			/* 32 adw_err_addr */
	0,			/* 33 saved_dvc_err_code */
	0,			/* 34 saved_adw_err_code */
	0			/* 35 saved_adw_err_addr */
d143 2
a144 1
const static ADW_EEPROM adw_38C0800_Default_EEPROM = {
d149 1
a149 1
	{ 0x4444 },		/* 04 sdtr_speed1 */
d161 4
a164 4
	{ 0x4444 },		/* 13 sdtr_speed2 */
	{ 0x4444 },		/* 14 sdtr_speed3 */
	ADW_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
	ADW_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
d166 4
a169 2
	{ 0x4444 },		/* 17 sdtr_speed4 */
	{ 0,0,0 },		/* 18-20 serial_number[3] */
d171 1
a171 4
	{			/* 22-29 oem_name[16] */
	  0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0
	},
d173 2
a174 2
	0,			/* 31 adw_err_code */
	0,			/* 32 adw_err_addr */
d176 22
a197 6
	0,			/* 34 saved_adw_err_code */
	0,			/* 35 saved_adw_err_addr */
	{			/* 36-55 reserved1[16] */
	  0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0,0,0
	},
d202 4
a205 1
	{ 0,0,0,0 }		/* 60-63 reserved2[4] */
a207 47
const static ADW_EEPROM adw_38C1600_Default_EEPROM = {
	ADW_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
	0x0000,			/* 01 cfg_msw */
	0xFFFF,			/* 02 disc_enable */
	0xFFFF,			/* 03 wdtr_able */
	{ 0x5555 },		/* 04 sdtr_speed1 */
	0xFFFF,			/* 05 start_motor */
	0xFFFF,			/* 06 tagqng_able */
	0xFFFF,			/* 07 bios_scan */
	0,			/* 08 scam_tolerant */
	7,			/* 09 adapter_scsi_id */
	0,			/*    bios_boot_delay */
	3,			/* 10 scsi_reset_delay */
	0,			/*    bios_id_lun */
	0,			/* 11 termination_se */
	0,			/*    termination_lvd */
	0xFFE7,			/* 12 bios_ctrl */
	{ 0x5555 },		/* 13 sdtr_speed2 */
	{ 0x5555 },		/* 14 sdtr_speed3 */
	ADW_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
	ADW_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
	0,			/* 16 dvc_cntl */
	{ 0x5555 },		/* 17 sdtr_speed4 */
	{ 0,0,0 },		/* 18-20 serial_number[3] */
	0,			/* 21 check_sum */
	{			/* 22-29 oem_name[16] */
	  0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0
	},
	0,			/* 30 dvc_err_code */
	0,			/* 31 adw_err_code */
	0,			/* 32 adw_err_addr */
	0,			/* 33 saved_dvc_err_code */
	0,			/* 34 saved_adw_err_code */
	0,			/* 35 saved_adw_err_addr */
	{			/* 36-55 reserved1[16] */
	  0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0,0,0
	},
	0,			/* 56 cisptr_lsw */
	0,			/* 57 cisprt_msw */
	PCI_VENDOR_ADVSYS,	/* 58 subsysvid */
	PCI_PRODUCT_ADVSYS_U3W, /* 59 subsysid */
	{ 0,0,0,0 }		/* 60-63 reserved2[4] */
};


d209 3
a211 3
 * Read the board's EEPROM configuration. Set fields in ADW_SOFTC and
 * ADW_DVC_CFG based on the EEPROM settings. The chip is stopped while
 * all of this is done.
a214 2
 *
 * Note: Chip is stopped on entry.
d217 1
a217 1
AdwInitFromEEPROM(sc)
d222 14
a235 5
	ADW_EEPROM		eep_config;
	u_int16_t		warn_code;
	u_int16_t		sdtr_speed = 0;
	u_int8_t		tid, termination;
	int			i, j;
d241 3
a243 1
	 * Read the board's EEPROM configuration.
d245 2
a246 3
	 * Set default values if a bad checksum is found.
	 *
	 * XXX - Don't handle big-endian access to EEPROM yet.
d248 3
a250 2
	if (AdwGetEEPROMConfig(iot, ioh, &eep_config) != eep_config.check_sum) {
		warn_code |= ADW_WARN_EEPROM_CHKSUM;
d252 4
a255 12
		/*
		 * Set EEPROM default values.
		 */
		switch(sc->chip_type) {
		case ADW_CHIP_ASC3550:
			eep_config = adw_3550_Default_EEPROM;
			break;
		case ADW_CHIP_ASC38C0800:
			eep_config = adw_38C0800_Default_EEPROM;
			break;
		case ADW_CHIP_ASC38C1600:
			eep_config = adw_38C1600_Default_EEPROM;
d257 1
a257 3
// XXX	  TODO!!!	if (ASC_PCI_ID2FUNC(sc->cfg.pci_slot_info) != 0) {
			if (sc->cfg.pci_slot_info != 0) {
				u_int8_t lsw_msb;
d259 8
a266 44
				lsw_msb = eep_config.cfg_lsw >> 8;
				/*
				 * Set Function 1 EEPROM Word 0 MSB
				 *
				 * Clear the BIOS_ENABLE (bit 14) and
				 * INTAB (bit 11) EEPROM bits.
				 *
				 * Disable Bit 14 (BIOS_ENABLE) to fix
				 * SPARC Ultra 60 and old Mac system booting
				 * problem. The Expansion ROM must
				 * be disabled in Function 1 for these systems.
				 */
				lsw_msb &= ~(((ADW_EEPROM_BIOS_ENABLE |
						ADW_EEPROM_INTAB) >> 8) & 0xFF);
				/*
				 * Set the INTAB (bit 11) if the GPIO 0 input
				 * indicates the Function 1 interrupt line is
				 * wired to INTA.
				 *
				 * Set/Clear Bit 11 (INTAB) from
				 * the GPIO bit 0 input:
				 *   1 - Function 1 intr line wired to INT A.
				 *   0 - Function 1 intr line wired to INT B.
				 *
				 * Note: Adapter boards always have Function 0
				 * wired to INTA.
				 * Put all 5 GPIO bits in input mode and then
				 * read their input values.
				 */
				ADW_WRITE_BYTE_REGISTER(iot, ioh,
							IOPB_GPIO_CNTL, 0);
				if (ADW_READ_BYTE_REGISTER(iot, ioh,
						IOPB_GPIO_DATA) & 0x01) {
					/*
					 * Function 1 interrupt wired to INTA;
					 * Set EEPROM bit.
					 */
					lsw_msb |= (ADW_EEPROM_INTAB >> 8)
							 & 0xFF;
				 }
				 eep_config.cfg_lsw &= 0x00FF;
				 eep_config.cfg_lsw |= lsw_msb << 8;
			}
			break;
d268 7
a275 12
		/*
		 * Assume the 6 byte board serial number that was read
		 * from EEPROM is correct even if the EEPROM checksum
		 * failed.
		 */
		for (i=2, j=1; i>=0; i--, j++) {
		eep_config.serial_number[i] =
			AdwReadEEPWord(iot, ioh, ADW_EEP_DVC_CFG_END - j);
		}

		AdwSetEEPROMConfig(iot, ioh, &eep_config);
	}
d277 1
a277 2
	 * Set sc and sc->cfg variables from the EEPROM configuration
	 * that was read.
d279 1
a279 1
	 * This is the mapping of EEPROM fields to Adw Library fields.
d281 1
a281 43
	sc->wdtr_able = eep_config.wdtr_able;
	if (sc->chip_type == ADW_CHIP_ASC3550) {
		sc->sdtr_able = eep_config.sdtr1.sdtr_able;
		sc->ultra_able = eep_config.sdtr2.ultra_able;
	} else {
		sc->sdtr_speed1 = eep_config.sdtr1.sdtr_speed1;
		sc->sdtr_speed2 = eep_config.sdtr2.sdtr_speed2;
		sc->sdtr_speed3 = eep_config.sdtr3.sdtr_speed3;
		sc->sdtr_speed4 = eep_config.sdtr4.sdtr_speed4;
	}
	sc->ppr_able = 0;
	sc->tagqng_able = eep_config.tagqng_able;
	sc->cfg.disc_enable = eep_config.disc_enable;
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;
	sc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);
	sc->start_motor = eep_config.start_motor;
	sc->scsi_reset_wait = eep_config.scsi_reset_delay;
	sc->bios_ctrl = eep_config.bios_ctrl;
	sc->no_scam = eep_config.scam_tolerant;
	sc->cfg.serial1 = eep_config.serial_number[0];
	sc->cfg.serial2 = eep_config.serial_number[1];
	sc->cfg.serial3 = eep_config.serial_number[2];

	if (sc->chip_type == ADW_CHIP_ASC38C0800 ||
	    sc->chip_type == ADW_CHIP_ASC38C1600) {
		sc->sdtr_able = 0;
		for (tid = 0; tid <= ADW_MAX_TID; tid++) {
			if (tid == 0) {
				sdtr_speed = sc->sdtr_speed1;
			} else if (tid == 4) {
				sdtr_speed = sc->sdtr_speed2;
			} else if (tid == 8) {
				sdtr_speed = sc->sdtr_speed3;
			} else if (tid == 12) {
				sdtr_speed = sc->sdtr_speed4;
			}
			if (sdtr_speed & ADW_MAX_TID) {
				sc->sdtr_able |= (1 << tid);
			}
			sdtr_speed >>= 4;
		}
	}
d283 14
a296 3
	/*
	 * Set the host maximum queuing (max. 253, min. 16) and the per device
	 * maximum queuing (max. 63, min. 4).
d298 16
a313 7
	if (eep_config.max_host_qng > ADW_DEF_MAX_HOST_QNG) {
		eep_config.max_host_qng = ADW_DEF_MAX_HOST_QNG;
	} else if (eep_config.max_host_qng < ADW_DEF_MIN_HOST_QNG)
	{
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_host_qng == 0) {
			eep_config.max_host_qng = ADW_DEF_MAX_HOST_QNG;
d315 4
a318 12
			eep_config.max_host_qng = ADW_DEF_MIN_HOST_QNG;
		}
	}

	if (eep_config.max_dvc_qng > ADW_DEF_MAX_DVC_QNG) {
		eep_config.max_dvc_qng = ADW_DEF_MAX_DVC_QNG;
	} else if (eep_config.max_dvc_qng < ADW_DEF_MIN_DVC_QNG) {
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_dvc_qng == 0) {
			eep_config.max_dvc_qng = ADW_DEF_MAX_DVC_QNG;
		} else {
			eep_config.max_dvc_qng = ADW_DEF_MIN_DVC_QNG;
d323 2
a324 2
	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
	 * set 'max_dvc_qng' to 'max_host_qng'.
d326 2
a327 3
	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
		eep_config.max_dvc_qng = eep_config.max_host_qng;
	}
d330 1
a330 2
	 * Set ADW_SOFTC 'max_host_qng' and 'max_dvc_qng'
	 * values based on possibly adjusted EEPROM values.
d332 3
a334 3
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;

d337 1
a337 6
	 * If the EEPROM 'termination' field is set to automatic (0), then set
	 * the ADW_SOFTC.cfg 'termination' field to automatic also.
	 *
	 * If the termination is specified with a non-zero 'termination'
	 * value check that a legal value is set and set the ADW_SOFTC.cfg
	 * 'termination' field appropriately.
d339 2
d342 2
a343 74
	switch(sc->chip_type) {
	case ADW_CHIP_ASC3550:
		sc->cfg.termination = 0;	/* auto termination */
		switch(eep_config.termination_se) {
		case 3:
			/* Enable manual control with low on / high on. */
			sc->cfg.termination |= ADW_TERM_CTL_L;
		case 2:
			/* Enable manual control with low off / high on. */
			sc->cfg.termination |= ADW_TERM_CTL_H;
		case 1:
			/* Enable manual control with low off / high off. */
			sc->cfg.termination |= ADW_TERM_CTL_SEL;
		case 0:
			break;
		default:
			warn_code |= ADW_WARN_EEPROM_TERMINATION;
		}
		break;

	case ADW_CHIP_ASC38C0800:
	case ADW_CHIP_ASC38C1600:
		switch(eep_config.termination_se) {
		case 0:
			/* auto termination for SE */
			termination = 0;
			break;
		case 1:
			/* Enable manual control with low off / high off. */
			termination = 0;
			break;
		case 2:
			/* Enable manual control with low off / high on. */
			termination = ADW_TERM_SE_HI;
			break;
		case 3:
			/* Enable manual control with low on / high on. */
			termination = ADW_TERM_SE;
			break;
		default:
			/*
			 * The EEPROM 'termination_se' field contains a
			 * bad value. Use automatic termination instead.
			 */
			termination = 0;
			warn_code |= ADW_WARN_EEPROM_TERMINATION;
		}

		switch(eep_config.termination_lvd) {
		case 0:
			/* auto termination for LVD */
			sc->cfg.termination = termination;
			break;
		case 1:
			/* Enable manual control with low off / high off. */
			sc->cfg.termination = termination;
			break;
		case 2:
			/* Enable manual control with low off / high on. */
			sc->cfg.termination = termination | ADW_TERM_LVD_HI;
			break;
		case 3:
			/* Enable manual control with low on / high on. */
			sc->cfg.termination = termination | ADW_TERM_LVD;
			break;
		default:
			/*
			 * The EEPROM 'termination_lvd' field contains a
			 * bad value. Use automatic termination instead.
			 */
			sc->cfg.termination = termination;
			warn_code |= ADW_WARN_EEPROM_TERMINATION;
		}
		break;
d346 2
a347 37
	return warn_code;
}


/*
 * Initialize the ASC-3550/ASC-38C0800/ASC-38C1600.
 *
 * On failure return the error code.
 */
int
AdwInitDriver(sc)
ADW_SOFTC      *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t	error_code;
	int		word;
	int		i;
	u_int16_t	bios_mem[ADW_MC_BIOSLEN/2];	/* BIOS RISC Memory
								0x40-0x8F. */
	u_int16_t	wdtr_able = 0, sdtr_able, ppr_able, tagqng_able;
	u_int8_t	max_cmd[ADW_MAX_TID + 1];
	u_int8_t	tid;


	error_code = 0;

	/*
	 * Save the RISC memory BIOS region before writing the microcode.
	 * The BIOS may already be loaded and using its RISC LRAM region
	 * so its region must be saved and restored.
	 *
	 * Note: This code makes the assumption, which is currently true,
	 * that a chip reset does not clear RISC LRAM.
	 */
	for (i = 0; i < ADW_MC_BIOSLEN/2; i++) {
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_BIOSMEM+(2*i), bios_mem[i]);
d351 1
a351 1
	 * Save current per TID negotiated values.
d353 3
a355 35
	switch (sc->chip_type) {
	case ADW_CHIP_ASC3550:
		if (bios_mem[(ADW_MC_BIOS_SIGNATURE-ADW_MC_BIOSMEM)/2]==0x55AA){

			u_int16_t  bios_version, major, minor;

			bios_version = bios_mem[(ADW_MC_BIOS_VERSION -
					ADW_MC_BIOSMEM) / 2];
			major = (bios_version  >> 12) & 0xF;
			minor = (bios_version  >> 8) & 0xF;
			if (major < 3 || (major == 3 && minor == 1)) {
			    /*
			     * BIOS 3.1 and earlier location of
			     * 'wdtr_able' variable.
			     */
			    ADW_READ_WORD_LRAM(iot, ioh, 0x120, wdtr_able);
			} else {
			    ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE,
					    wdtr_able);
			}
		}
		break;

	case ADW_CHIP_ASC38C1600:
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE, ppr_able);
		/* FALLTHROUGH */
	case ADW_CHIP_ASC38C0800:
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, wdtr_able);
		break;
	}
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, sdtr_able);
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE, tagqng_able);
	for (tid = 0; tid <= ADW_MAX_TID; tid++) {
		ADW_READ_BYTE_LRAM(iot, ioh, ADW_MC_NUMBER_OF_MAX_CMD + tid,
			max_cmd[tid]);
d359 2
a360 1
	 * Perform a RAM Built-In Self Test
d362 6
a367 2
	if((error_code = AdwRamSelfTest(iot, ioh, sc->chip_type))) {
		return error_code;
d369 1
d372 1
a372 1
	 * Load the Microcode
d374 4
a377 4
	;
	if((error_code = AdwLoadMCode(iot, ioh, bios_mem, sc->chip_type))) {
		return error_code;
	}
d380 1
a380 1
	 * Read microcode version and date.
d382 1
a382 2
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_VERSION_DATE, sc->cfg.mcode_date);
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_VERSION_NUM, sc->cfg.mcode_version);
a390 7
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CONTROL_FLAG, word);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_CONTROL_FLAG,
					word | CONTROL_FLAG_IGNORE_PERR);
	}

	switch (sc->chip_type) {
	case ADW_CHIP_ASC3550:
d392 3
a394 3
		 * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a
		 * FIFO threshold of 128 bytes.
		 * This register is only accessible to the host.
d396 4
a399 3
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,
				START_CTL_EMFU | READ_CMD_MRM);
		break;
d401 6
a406 60
	case ADW_CHIP_ASC38C0800:
		/*
		 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
		 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
		 * cable detection and then we are able to read C_DET[3:0].
		 *
		 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
		 * Microcode Default Value' section below.
		 */
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,
				ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1)
				| ADW_DIS_TERM_DRV);

		/*
		 * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and
		 * START_CTL_TH [3:2] bits for the default FIFO threshold.
		 *
		 * Note: ASC-38C0800 FIFO threshold has been changed to
		 * 256 bytes.
		 *
		 * For DMA Errata #4 set the BC_THRESH_ENB bit.
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,
						BC_THRESH_ENB | FIFO_THRESH_80B
						| START_CTL_TH | READ_CMD_MRM);
		break;

	case ADW_CHIP_ASC38C1600:
		/*
		 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
		 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
		 * cable detection and then we are able to read C_DET[3:0].
		 *
		 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
		 * Microcode Default Value' section below.
		 */
		ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,
				ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1)
				| ADW_DIS_TERM_DRV);

		/*
		 * If the BIOS control flag AIPP (Asynchronous Information
		 * Phase Protection) disable bit is not set, then set the
		 * firmware 'control_flag' CONTROL_FLAG_ENABLE_AIPP bit to
		 * enable AIPP checking and encoding.
		 */
		if ((sc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0) {
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CONTROL_FLAG, word);
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_CONTROL_FLAG,
					word | CONTROL_FLAG_ENABLE_AIPP);
		}

		/*
		 * For ASC-38C1600 use DMA_CFG0 default values:
		 * FIFO_THRESH_80B [6:4], and START_CTL_TH [3:2].
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,
				FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
		break;
	}
d410 1
a410 1
	 * queuing will be set in AdwInquiryHandling() based on what a
d413 1
a413 1
	 * If SCSI Bus Resets have been disabled, then directly set
d421 4
a424 2
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, sc->wdtr_able);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, sc->sdtr_able);
d436 12
d449 25
a473 32
	switch (sc->chip_type) {
	case ADW_CHIP_ASC3550:
		word = 0;
		for (tid = 0; tid <= ADW_MAX_TID; tid++) {
			if (ADW_TID_TO_TIDMASK(tid) & sc->ultra_able) {
				/* Set Ultra speed for TID 'tid'. */
				word |= (0x3 << (4 * (tid % 4)));
			} else {
				/* Set Fast speed for TID 'tid'. */
				word |= (0x2 << (4 * (tid % 4)));
			}
			/* Check if done with sdtr_speed1. */
			if (tid == 3) {
				ADW_WRITE_WORD_LRAM(iot, ioh,
						ADW_MC_SDTR_SPEED1, word);
				word = 0;
			/* Check if done with sdtr_speed2. */
			} else if (tid == 7) {
				ADW_WRITE_WORD_LRAM(iot, ioh,
						ADW_MC_SDTR_SPEED2, word);
				word = 0;
			/* Check if done with sdtr_speed3. */
			} else if (tid == 11) {
				ADW_WRITE_WORD_LRAM(iot, ioh,
						ADW_MC_SDTR_SPEED3, word);
				word = 0;
			/* Check if done with sdtr_speed4. */
			} else if (tid == 15) {
				ADW_WRITE_WORD_LRAM(iot, ioh,
						ADW_MC_SDTR_SPEED4, word);
				/* End of loop. */
			}
d475 1
d477 4
a480 23
		/*
		 * Set microcode operating variable for the
		 * disconnect per TID bitmask.
		 */
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DISC_ENABLE,
							sc->cfg.disc_enable);
		break;

	case ADW_CHIP_ASC38C0800:
		/* FALLTHROUGH */
	case ADW_CHIP_ASC38C1600:
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DISC_ENABLE,
							sc->cfg.disc_enable);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_SPEED1,
							sc->sdtr_speed1);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_SPEED2,
							sc->sdtr_speed2);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_SPEED3,
							sc->sdtr_speed3);
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_SPEED4,
							sc->sdtr_speed4);
		break;
	}
d489 30
a518 17
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SCSI_CFG0,
		ADW_PARITY_EN | ADW_QUEUE_128 | ADW_SEL_TMO_LONG |
		ADW_OUR_ID_EN | sc->chip_scsi_id);


	switch(sc->chip_type) {
	case ADW_CHIP_ASC3550:
		error_code = AdwASC3550Cabling(iot, ioh, &sc->cfg);
		break;

	case ADW_CHIP_ASC38C0800:
		error_code = AdwASC38C0800Cabling(iot, ioh, &sc->cfg);
		break;

	case ADW_CHIP_ASC38C1600:
		error_code = AdwASC38C1600Cabling(iot, ioh, &sc->cfg);
		break;
d520 39
a558 2
	if(error_code) {
		return error_code;
d562 39
d606 1
a606 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SEL_MASK,
a608 5
	/*
	 * Create and Initialize Host->RISC Carrier lists
	 */
	sc->carr_freelist = AdwInitCarriers(sc->sc_dmamap_carrier,
						sc->sc_control->carriers);
d615 1
a615 1
		return ADW_IERR_NO_CARRIER;
d617 2
a618 2
	sc->carr_freelist = ADW_CARRIER_VADDR(sc,
			ADW_GET_CARRP(sc->icq_sp->next_ba));
d623 1
a623 1
	sc->icq_sp->next_ba = ADW_CQ_STOPPER;
d628 1
a628 10
	ADW_WRITE_DWORD_LRAM(iot, ioh, ADW_MC_ICQ, sc->icq_sp->carr_ba);

	/*
	 * Initialize the COMMA register to the same value otherwise
	 * the RISC will prematurely detect a command is available.
	 */
	if(sc->chip_type == ADW_CHIP_ASC38C1600) {
		ADW_WRITE_DWORD_REGISTER(iot, ioh, IOPDW_COMMA,
							sc->icq_sp->carr_ba);
	}
d634 1
a634 1
		return ADW_IERR_NO_CARRIER;
d636 2
a637 2
	sc->carr_freelist = ADW_CARRIER_VADDR(sc,
			ADW_GET_CARRP(sc->irq_sp->next_ba));
d643 2
a644 2
	 * Note: Set 'next_ba' to ADW_CQ_STOPPER. When the request is
	 * completed the RISC will set the ADW_RQ_DONE bit.
d646 1
a646 1
	sc->irq_sp->next_ba = ADW_CQ_STOPPER;
d651 1
a651 1
	ADW_WRITE_DWORD_LRAM(iot, ioh, ADW_MC_IRQ, sc->irq_sp->carr_ba);
d656 7
a662 1
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CODE_BEGIN_ADDR, word);
d680 1
a680 1
		if (bios_mem[(ADW_MC_BIOS_SIGNATURE - ADW_MC_BIOSMEM)/2] ==
d685 1
a685 1
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE,
d687 1
a687 1
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE,
d689 1
a689 1
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE,
d693 2
a694 2
						ADW_MC_NUMBER_OF_MAX_CMD + tid,
						max_cmd[tid]);
d697 2
a698 2
			if (AdwResetCCB(sc) != ADW_TRUE) {
				error_code = ADW_WARN_BUSRESET_ERROR;
d703 1
a703 1
	return error_code;
d706 8
a713 1

d715 2
a716 4
AdwRamSelfTest(iot, ioh, chip_type)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t chip_type;
d718 11
a728 1
	int		i;
d730 5
d737 1
a737 22
	if ((chip_type == ADW_CHIP_ASC38C0800) ||
	    (chip_type == ADW_CHIP_ASC38C1600)) {
		/*
		 * RAM BIST (RAM Built-In Self Test)
		 *
		 * Address : I/O base + offset 0x38h register (byte).
		 * Function: Bit 7-6(RW) : RAM mode
		 *			    Normal Mode   : 0x00
		 *			    Pre-test Mode : 0x40
		 *			    RAM Test Mode : 0x80
		 *	     Bit 5	 : unused
		 *	     Bit 4(RO)   : Done bit
		 *	     Bit 3-0(RO) : Status
		 *			    Host Error    : 0x08
		 *			    Int_RAM Error : 0x04
		 *			    RISC Error    : 0x02
		 *			    SCSI Error    : 0x01
		 *			    No Error	  : 0x00
		 *
		 * Note: RAM BIST code should be put right here, before loading
		 * the microcode and after saving the RISC memory BIOS region.
		 */
d739 11
a749 19
		/*
		 * LRAM Pre-test
		 *
		 * Write PRE_TEST_MODE (0x40) to register and wait for
		 * 10 milliseconds.
		 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05),
		 * return an error. Reset to NORMAL_MODE (0x00) and do again.
		 * If cannot reset to NORMAL_MODE, return an error too.
		 */
		for (i = 0; i < 2; i++) {
			ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST,
					PRE_TEST_MODE);
			 /* Wait for 10ms before reading back. */
			AdwSleepMilliSecond(10);
			byte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);
			if ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) !=
					PRE_TEST_VALUE) {
				return ADW_IERR_BIST_PRE_TEST;
			}
d751 10
a760 9
			ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST,
								NORMAL_MODE);
			/* Wait for 10ms before reading back. */
			AdwSleepMilliSecond(10);
			if (ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST)
			    != NORMAL_VALUE) {
				return ADW_IERR_BIST_PRE_TEST;
			}
		}
d762 20
a781 11
		/*
		 * LRAM Test - It takes about 1.5 ms to run through the test.
		 *
		 * Write RAM_TEST_MODE (0x80) to register and wait for
		 * 10 milliseconds.
		 * If Done bit not set or Status not 0, save register byte,
		 * set the err_code, and return an error.
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, RAM_TEST_MODE);
		/* Wait for 10ms before checking status. */
		AdwSleepMilliSecond(10);
d783 11
d795 3
a797 3
		if ((byte & RAM_TEST_DONE)==0 || (byte & RAM_TEST_STATUS)!=0) {
			/* Get here if Done bit not set or Status not 0. */
			return ADW_IERR_BIST_RAM_TEST;
a799 1
		/* We need to reset back to normal mode after LRAM test passes*/
d801 5
d808 9
a816 22
	return 0;
}


int
AdwLoadMCode(iot, ioh, bios_mem, chip_type)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int16_t *bios_mem;
	u_int8_t chip_type;
{
	u_int8_t	*mcode_data;
	u_int32_t	 mcode_chksum;
	u_int16_t	 mcode_size;
	u_int32_t	sum;
	u_int16_t	code_sum;
	int		begin_addr;
	int		end_addr;
	int		word;
	int		adw_memsize;
	int		adw_mcode_expanded_size;
	int		i, j;
d818 5
d824 2
a825 22
	switch(chip_type) {
	case ADW_CHIP_ASC3550:
		mcode_data = (u_int8_t *)adw_asc3550_mcode_data.mcode_data;
		mcode_chksum = (u_int32_t)adw_asc3550_mcode_data.mcode_chksum;
		mcode_size = (u_int16_t)adw_asc3550_mcode_data.mcode_size;
		adw_memsize = ADW_3550_MEMSIZE;
		break;

	case ADW_CHIP_ASC38C0800:
		mcode_data = (u_int8_t *)adw_asc38C0800_mcode_data.mcode_data;
		mcode_chksum =(u_int32_t)adw_asc38C0800_mcode_data.mcode_chksum;
		mcode_size = (u_int16_t)adw_asc38C0800_mcode_data.mcode_size;
		adw_memsize = ADW_38C0800_MEMSIZE;
		break;

	case ADW_CHIP_ASC38C1600:
		mcode_data = (u_int8_t *)adw_asc38C1600_mcode_data.mcode_data;
		mcode_chksum =(u_int32_t)adw_asc38C1600_mcode_data.mcode_chksum;
		mcode_size = (u_int16_t)adw_asc38C1600_mcode_data.mcode_size;
		adw_memsize = ADW_38C1600_MEMSIZE;
		break;
	}
d828 2
d831 1
d851 3
a853 3
	for (i = 253 * 2; i < mcode_size; i++) {
		if (mcode_data[i] == 0xff) {
			for (j = 0; j < mcode_data[i + 1]; j++) {
d855 3
a857 2
				  (((u_int16_t)mcode_data[i + 3] << 8) |
				  mcode_data[i + 2]));
d861 4
a864 4
		} else if (mcode_data[i] == 0xfe) {
			ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,
			    (((u_int16_t)mcode_data[i + 2] << 8) |
			    mcode_data[i + 1]));
d869 2
a870 2
			 mcode_data[(mcode_data[i] * 2) + 1] <<8) |
			 mcode_data[mcode_data[i] * 2]));
d880 1
a880 1
	adw_mcode_expanded_size = word;
d883 1
a883 1
	 * Clear the rest of the Internal RAM.
d885 1
a885 1
	for (; word < adw_memsize; word += 2) {
d895 1
a895 1
	for (word = 0; word < adw_mcode_expanded_size; word += 2) {
d899 2
a900 2
	if (sum != mcode_chksum) {
		return ADW_IERR_MCODE_CHKSUM;
d906 3
a908 8
	for (i = 0; i < ADW_MC_BIOSLEN/2; i++) {
		if(chip_type == ADW_CHIP_ASC3550) {
			ADW_WRITE_BYTE_LRAM(iot, ioh, ADW_MC_BIOSMEM + (2 * i),
								bios_mem[i]);
		} else {
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_BIOSMEM + (2 * i),
								bios_mem[i]);
		}
d913 1
a913 1
	 * code checksum location ADW_MC_CODE_CHK_SUM (0x2C).
d915 2
a916 2
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CODE_BEGIN_ADDR, begin_addr);
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_CODE_END_ADDR, end_addr);
d922 1
a922 29
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_CODE_CHK_SUM, code_sum);

	/*
	 * Set the chip type.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_CHIP_TYPE, chip_type);

	return 0;
}


int
AdwASC3550Cabling(iot, ioh, cfg)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ADW_DVC_CFG *cfg;
{
	u_int16_t	scsi_cfg1;


	/*
	 * Determine SCSI_CFG1 Microcode Default Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
	 */

	/* Read current SCSI_CFG1 Register value. */
	scsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);
d925 1
a925 1
	 * If all three connectors are in use in ASC3550, return an error.
d927 4
a930 4
	if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
	     (scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {
		return ADW_IERR_ILLEGAL_CONNECTION;
	}
d933 1
a933 3
	 * If the cable is reversed all of the SCSI_CTRL register signals
	 * will be set. Check for and return an error if this condition is
	 * found.
d935 1
a935 3
	if ((ADW_READ_WORD_REGISTER(iot,ioh, IOPW_SCSI_CTRL) & 0x3F07)==0x3F07){
		return ADW_IERR_REVERSED_CABLE;
	}
d938 6
a943 2
	 * If this is a differential board and a single-ended device
	 * is attached to one of the connectors, return an error.
d945 3
a947 4
	if ((scsi_cfg1 & ADW_DIFF_MODE) &&
	    (scsi_cfg1 & ADW_DIFF_SENSE) == 0) {
		return ADW_IERR_SINGLE_END_DEVICE;
	}
d950 4
a953 6
	 * If automatic termination control is enabled, then set the
	 * termination value based on a table listed in a_condor.h.
	 *
	 * If manual termination was specified with an EEPROM setting
	 * then 'termination' was set-up in AdwInitFromEEPROM() and
	 * is ready to be 'ored' into SCSI_CFG1.
d955 1
a955 1
	if (cfg->termination == 0) {
d957 3
a959 4
		 * The software always controls termination by setting
		 * TERM_CTL_SEL.
		 * If TERM_CTL_SEL were set to 0, the hardware would set
		 * termination.
d961 3
a963 20
		cfg->termination |= ADW_TERM_CTL_SEL;

		switch(scsi_cfg1 & ADW_CABLE_DETECT) {
			/* TERM_CTL_H: on, TERM_CTL_L: on */
			case 0x3: case 0x7: case 0xB:
			case 0xD: case 0xE: case 0xF:
				cfg->termination |=
				(ADW_TERM_CTL_H | ADW_TERM_CTL_L);
				break;

			/* TERM_CTL_H: on, TERM_CTL_L: off */
			case 0x1: case 0x5: case 0x9:
			case 0xA: case 0xC:
				cfg->termination |= ADW_TERM_CTL_H;
				break;

			/* TERM_CTL_H: off, TERM_CTL_L: off */
			case 0x2: case 0x6:
				break;
		}
d967 6
a972 1
	 * Clear any set TERM_CTL_H and TERM_CTL_L bits.
d974 2
a975 1
	scsi_cfg1 &= ~ADW_TERM_CTL;
d978 10
a987 4
	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then
	 * set 'scsi_cfg1'. The TERM_POL bit does not need to be
	 * referenced, because the hardware internally inverts
	 * the Termination High and Low bits if TERM_POL is set.
d989 4
a992 1
	scsi_cfg1 |= (ADW_TERM_CTL_SEL | (~cfg->termination & ADW_TERM_CTL));
d995 3
a997 1
	 * Set SCSI_CFG1 Microcode Default Value
d999 3
a1001 5
	 * Set filter value and possibly modified termination control
	 * bits in the Microcode SCSI_CFG1 Register Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
d1003 5
a1007 2
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SCSI_CFG1,
						ADW_FLTR_DISABLE | scsi_cfg1);
d1010 1
a1010 1
	 * Set MEM_CFG Microcode Default Value
d1012 1
a1012 1
	 * The microcode will set the MEM_CFG register using this value
a1013 5
	 *
	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
	 * are defined.
	 *
	 * ASC-3550 has 8KB internal memory.
d1015 3
a1017 15
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_MEM_CFG,
						ADW_BIOS_EN | ADW_RAM_SZ_8KB);

	return 0;
}


int
AdwASC38C0800Cabling(iot, ioh, cfg)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ADW_DVC_CFG *cfg;
{
	u_int16_t	scsi_cfg1;

d1030 7
a1036 6
	 * If the cable is reversed all of the SCSI_CTRL register signals
	 * will be set. Check for and return an error if this condition is
	 * found.
	 */
	if ((ADW_READ_WORD_REGISTER(iot,ioh, IOPW_SCSI_CTRL) & 0x3F07)==0x3F07){
		return ADW_IERR_REVERSED_CABLE;
d1040 7
a1046 11
	 * All kind of combinations of devices attached to one of four
	 * connectors are acceptable except HVD device attached.
	 * For example, LVD device can be attached to SE connector while
	 * SE device attached to LVD connector.
	 * If LVD device attached to SE connector, it only runs up to
	 * Ultra speed.
	 *
	 * If an HVD device is attached to one of LVD connectors, return
	 * an error.
	 * However, there is no way to detect HVD device attached to
	 * SE connectors.
d1049 1
a1049 1
		return ADW_IERR_HVD_DEVICE;
d1057 2
a1058 2
	 * 'termination' was set-up in AdwInitFromEEPROM() and is ready
	 * to be 'ored' into SCSI_CFG1.
d1060 1
a1060 1
	if ((cfg->termination & ADW_TERM_SE) == 0) {
d1065 1
a1065 1
				cfg->termination |= ADW_TERM_SE;
d1070 1
a1070 1
				cfg->termination |= ADW_TERM_SE_HI;
d1075 1
a1075 1
	if ((cfg->termination & ADW_TERM_LVD) == 0) {
d1080 1
a1080 1
				cfg->termination |= ADW_TERM_LVD;
d1097 1
a1097 1
	scsi_cfg1 |= (~cfg->termination & 0xF0);
d1100 3
a1102 3
	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and
	 * HVD/LVD/SE bits and set possibly modified termination control bits
	 * in the Microcode SCSI_CFG1 Register Value.
d1105 1
a1105 1
					~ADW_TERM_POL & ~ADW_HVD_LVD_SE);
d1116 1
a1116 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
d1129 261
a1389 2
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_MEM_CFG,
						ADW_BIOS_EN | ADW_RAM_SZ_16KB);
d1391 1
a1391 1
	return 0;
d1395 12
d1408 2
a1409 4
AdwASC38C1600Cabling(iot, ioh, cfg)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ADW_DVC_CFG *cfg;
d1411 8
a1418 1
	u_int16_t	scsi_cfg1;
d1420 1
d1423 1
a1423 1
	 * Determine SCSI_CFG1 Microcode Default Value.
d1425 1
a1425 4
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
	 * Each ASC-38C1600 function has only two cable detect bits.
	 * The bus mode override bits are in IOPB_SOFT_OVER_WR.
d1427 3
d1431 21
a1451 2
	/* Read current SCSI_CFG1 Register value. */
	scsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);
d1453 2
d1456 4
a1459 3
	 * If the cable is reversed all of the SCSI_CTRL register signals
	 * will be set. Check for and return an error if this condition is
	 * found.
d1461 17
a1477 3
	if ((ADW_READ_WORD_REGISTER(iot,ioh, IOPW_SCSI_CTRL) & 0x3F07)==0x3F07){
		return ADW_IERR_REVERSED_CABLE;
	}
d1480 2
a1481 6
	 * Each ASC-38C1600 function has two connectors. Only an HVD device
	 * can not be connected to either connector. An LVD device or SE device
	 * may be connected to either connecor. If an SE device is connected,
	 * then at most Ultra speed (20 Mhz) can be used on both connectors.
	 *
	 * If an HVD device is attached, return an error.
d1483 15
a1497 2
	if (scsi_cfg1 & ADW_HVD) {
		return ADW_IERR_HVD_DEVICE;
d1501 2
a1502 12
	 * Each function in the ASC-38C1600 uses only the SE cable detect and
	 * termination because there are two connectors for each function.
	 * Each function may use either LVD or SE mode.
	 * Corresponding the SE automatic termination control EEPROM bits are
	 * used for each function.
	 * Each function has its own EEPROM. If SE automatic control is enabled
	 * for the function, then set the termination value based on a table
	 * listed in adwlib.h.
	 *
	 * If manual termination is specified in the EEPROM for the function,
	 * then 'termination' was set-up in AdwInitFromEEPROM() and is
	 * ready to be 'ored' into SCSI_CFG1.
d1504 10
a1513 7
	if ((cfg->termination & ADW_TERM_SE) == 0) {
		/* SE automatic termination control is enabled. */
		switch(scsi_cfg1 & ADW_C_DET_SE) {
			/* TERM_SE_HI: on, TERM_SE_LO: on */
			case 0x1: case 0x2: case 0x3:
				cfg->termination |= ADW_TERM_SE;
				break;
d1515 9
a1523 12
			case 0x0:
	/* !!!!TODO!!!! */
//				if (ASC_PCI_ID2FUNC(cfg->pci_slot_info) == 0) {
				/* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */
//				}
//				else
//				{
				/* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */
					cfg->termination |= ADW_TERM_SE_HI;
//				}
				break;
			}
d1527 2
a1528 1
	 * Clear any set TERM_SE bits.
d1530 3
a1532 1
	scsi_cfg1 &= ~ADW_TERM_SE;
d1535 2
a1536 1
	 * Invert the TERM_SE bits and then set 'scsi_cfg1'.
d1538 2
a1539 1
	scsi_cfg1 |= (~cfg->termination & ADW_TERM_SE);
d1542 6
a1547 3
	 * Clear Big Endian and Terminator Polarity bits and set possibly
	 * modified termination control bits in the Microcode SCSI_CFG1
	 * Register Value.
d1549 24
a1572 1
	scsi_cfg1 &= (~ADW_BIG_ENDIAN & ~ADW_DIS_TERM_DRV & ~ADW_TERM_POL);
d1574 12
a1585 10
	/*
	 * Set SCSI_CFG1 Microcode Default Value
	 *
	 * Set possibly modified termination control bits in the Microcode
	 * SCSI_CFG1 Register Value.
	 *
	 * The microcode will set the SCSI_CFG1 register using this value
	 * after it is started below.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
d1587 12
a1598 13
	/*
	 * Set MEM_CFG Microcode Default Value
	 *
	 * The microcode will set the MEM_CFG register using this value
	 * after it is started below.
	 *
	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
	 * are defined.
	 *
	 * ASC-38C1600 has 32KB internal memory.
	 */
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_DEFAULT_MEM_CFG,
						ADW_BIOS_EN | ADW_RAM_SZ_32KB);
d1600 1
a1600 1
	return 0;
d1610 1
a1610 1
AdwGetEEPROMConfig(iot, ioh, cfg_buf)
d1613 1
a1613 1
	ADW_EEPROM		*cfg_buf;
d1623 43
a1665 4
	for (eep_addr = ADW_EEP_DVC_CFG_BEGIN;
		eep_addr < ADW_EEP_DVC_CFG_END;
		eep_addr++, wbuf++) {
		wval = AdwReadEEPWord(iot, ioh, eep_addr);
d1670 1
a1670 1
	*wbuf = AdwReadEEPWord(iot, ioh, eep_addr);
d1672 2
a1673 2
	for (eep_addr = ADW_EEP_DVC_CTL_BEGIN;
			eep_addr < ADW_EEP_MAX_WORD_ADDR;
d1675 1
a1675 1
		*wbuf = AdwReadEEPWord(iot, ioh, eep_addr);
d1686 1
a1686 1
AdwReadEEPWord(iot, ioh, eep_word_addr)
d1692 2
a1693 2
		ADW_EEP_CMD_READ | eep_word_addr);
	AdwWaitEEPCmd(iot, ioh);
d1703 1
a1703 1
AdwWaitEEPCmd(iot, ioh)
d1710 1
a1710 1
	for (eep_delay_ms = 0; eep_delay_ms < ADW_EEP_DELAY_MS; eep_delay_ms++){
d1712 1
a1712 1
				ADW_EEP_CMD_DONE) {
d1715 1
a1715 1
		AdwSleepMilliSecond(1);
d1726 61
a1786 1
AdwSetEEPROMConfig(iot, ioh, cfg_buf)
d1789 1
a1789 1
	ADW_EEPROM		*cfg_buf;
d1798 2
a1799 2
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ADW_EEP_CMD_WRITE_ABLE);
	AdwWaitEEPCmd(iot, ioh);
d1804 2
a1805 2
	for (addr = ADW_EEP_DVC_CFG_BEGIN;
	     addr < ADW_EEP_DVC_CFG_END; addr++, wbuf++) {
d1809 3
a1811 3
				ADW_EEP_CMD_WRITE | addr);
		AdwWaitEEPCmd(iot, ioh);
		AdwSleepMilliSecond(ADW_EEP_DELAY_MS);
d1819 2
a1820 2
			ADW_EEP_CMD_WRITE | addr);
	AdwWaitEEPCmd(iot, ioh);
d1826 2
a1827 2
	for (addr = ADW_EEP_DVC_CTL_BEGIN;
	     addr < ADW_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
d1830 2
a1831 2
				ADW_EEP_CMD_WRITE | addr);
		AdwWaitEEPCmd(iot, ioh);
d1835 2
a1836 2
			ADW_EEP_CMD_WRITE_DISABLE);
	AdwWaitEEPCmd(iot, ioh);
d1843 1
a1843 1
 * AdwExeScsiQueue() - Send a request to the RISC microcode program.
d1860 1
a1860 1
AdwExeScsiQueue(sc, scsiq)
d1869 3
a1871 1
	ADW_CARRIER	*new_carrp;
a1881 4
	/*
	 * Beginning of CRITICAL SECTION: ASSUME splbio() in effect
	 */
	
d1883 1
d1886 2
a1887 1
	 * Allocate a carrier and initialize fields.
d1892 2
a1893 2
	sc->carr_freelist = ADW_CARRIER_VADDR(sc,
			ADW_GET_CARRP(new_carrp->next_ba));
d1897 1
a1897 1
	 * Set the carrier to be a stopper by setting 'next_ba'
d1901 1
a1901 1
	new_carrp->next_ba = ADW_CQ_STOPPER;
d1911 1
a1911 1
	 * Every ADW_SCSI_REQ_Q.carr_ba is byte swapped to little-endian
d1914 2
a1915 2
	scsiq->carr_ba = sc->icq_sp->carr_ba;
	scsiq->carr_va = sc->icq_sp->carr_ba;
d1922 1
a1922 1
	sc->icq_sp->areq_ba = req_paddr;
d1925 1
a1925 1
	 * Set the 'next_ba' pointer for the old stopper to be the
d1929 1
a1929 1
	sc->icq_sp->next_ba = new_carrp->carr_ba;
a1930 7
#if ADW_DEBUG
	printf("icq 0x%x, 0x%x, 0x%x, 0x%x\n",
			sc->icq_sp->carr_id,
			sc->icq_sp->carr_ba,
			sc->icq_sp->areq_ba,
			sc->icq_sp->next_ba);
#endif
d1936 36
a1971 2
	if (sc->chip_type == ADW_CHIP_ASC3550 ||
	    sc->chip_type == ADW_CHIP_ASC38C0800) {
d1973 3
a1975 17
		 * Tickle the RISC to tell it to read its Command Queue Head
		 * pointer.
		 */
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADW_TICKLE_A);
		if (sc->chip_type == ADW_CHIP_ASC3550) {
			/*
			 * Clear the tickle value. In the ASC-3550 the RISC flag
			 * command 'clr_tickle_a' does not work unless the host
			 * value is cleared.
			 */
			ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE,
					ADW_TICKLE_NOP);
		}
	} else if (sc->chip_type == ADW_CHIP_ASC38C1600) {
		/*
		 * Notify the RISC a carrier is ready by writing the physical
		 * address of the new carrier stopper to the COMMA register.
d1977 1
a1977 2
		ADW_WRITE_DWORD_REGISTER(iot, ioh, IOPDW_COMMA,
				new_carrp->carr_ba);
a1979 4
	/*
	 * End of CRITICAL SECTION: Must be protected within splbio/splx pair
	 */
	
d1985 1
a1985 1
AdwResetChip(iot, ioh)
d1995 1
a1995 1
	AdwSleepMilliSecond(100);
d2011 1
a2011 1
AdwResetCCB(sc)
d2020 3
a2022 2
	status = AdwSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_START, 0L);
	if (status != ADW_TRUE) {
d2032 1
a2032 1
	AdwDelayMicroSecond((u_int16_t) ADW_SCSI_RESET_HOLD_TIME_US);
d2038 3
a2040 2
	status = AdwSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_END, 0L);
	if (status != ADW_TRUE) {
d2044 1
a2044 1
	AdwSleepMilliSecond((u_int32_t) sc->scsi_reset_wait * 1000);
d2058 1
a2058 1
AdwResetSCSIBus(sc)
d2064 1
a2064 1
	u_int16_t	wdtr_able, sdtr_able, ppr_able, tagqng_able;
d2072 6
a2077 8
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, wdtr_able);
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, sdtr_able);
	if (sc->chip_type == ADW_CHIP_ASC38C1600) {
		ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE, ppr_able);
	}
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE, tagqng_able);
	for (tid = 0; tid <= ADW_MAX_TID; tid++) {
		ADW_READ_BYTE_LRAM(iot, ioh, ADW_MC_NUMBER_OF_MAX_CMD + tid,
d2082 2
a2083 2
	 * Force the AdwInitAscDriver() function to perform a SCSI Bus Reset
	 * by clearing the BIOS signature word.
d2087 2
a2088 2
	ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_BIOS_SIGNATURE, bios_sig);
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_BIOS_SIGNATURE, 0);
d2096 1
a2096 1
	AdwSleepMilliSecond(100);
d2101 1
a2101 1
	 * Reset Adw Library error code, if any, and try
a2102 1
	 * Then translate initialization return value to status value.
d2104 12
a2115 1
	status = (AdwInitDriver(sc) == 0)? ADW_TRUE : ADW_FALSE;
d2120 1
a2120 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_BIOS_SIGNATURE, bios_sig);
d2125 3
a2127 6
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE, wdtr_able);
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE, sdtr_able);
	if (sc->chip_type == ADW_CHIP_ASC38C1600) {
		ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE, ppr_able);
	}
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE, tagqng_able);
d2129 1
a2129 1
		ADW_WRITE_BYTE_LRAM(iot, ioh, ADW_MC_NUMBER_OF_MAX_CMD + tid,
d2138 1
a2138 1
 * Adw Library Interrupt Service Routine
d2143 4
a2146 1
 *  Note: AdwISR() can be called when interrupts are disabled or even
d2157 1
a2157 1
AdwISR(sc)
d2168 1
a2168 2
	int		s;

a2169 1
	s = splbio();
a2175 1
		splx(s);
d2179 14
d2195 2
a2196 2
	 * calling the ADW_SOFTC.async_callback function. The function
	 * is passed the microcode ADW_MC_INTRB_CODE byte value.
d2201 7
a2207 13
		ADW_READ_BYTE_LRAM(iot, ioh, ADW_MC_INTRB_CODE, intrb_code);

		if (sc->chip_type == ADW_CHIP_ASC3550 ||
	    	    sc->chip_type == ADW_CHIP_ASC38C0800) {
			if (intrb_code == ADW_ASYNC_CARRIER_READY_FAILURE &&
				sc->carr_pending_cnt != 0) {
				ADW_WRITE_BYTE_REGISTER(iot, ioh,
					IOPB_TICKLE, ADW_TICKLE_A);
				if (sc->chip_type == ADW_CHIP_ASC3550) {
					ADW_WRITE_BYTE_REGISTER(iot, ioh,
						IOPB_TICKLE, ADW_TICKLE_NOP);
				}
			}
d2218 1
a2218 1
	while (((irq_next_pa = sc->irq_sp->next_ba) & ADW_RQ_DONE) != 0)
d2220 3
a2222 11
#if ADW_DEBUG
		printf("irq 0x%x, 0x%x, 0x%x, 0x%x\n",
				sc->irq_sp->carr_id,
				sc->irq_sp->carr_ba,
				sc->irq_sp->areq_ba,
				sc->irq_sp->next_ba);
#endif
		/*
		 * Get a pointer to the newly completed ADW_SCSI_REQ_Q
		 * structure.
		 * The RISC will have set 'areq_ba' to a virtual address.
d2224 4
a2227 4
		 * The firmware will have copied the ADW_SCSI_REQ_Q.ccb_ptr
		 * field to the carrier ADW_CARRIER.areq_ba field.
		 * The conversion below complements the conversion of
		 * ADW_SCSI_REQ_Q.ccb_ptr' in AdwExeScsiQueue().
d2229 1
a2229 1
		ccb = adw_ccb_phys_kv(sc, sc->irq_sp->areq_ba);
d2231 1
a2231 12
		scsiq->ccb_ptr = sc->irq_sp->areq_ba;

		/*
		 * Request finished with good status and the queue was not
		 * DMAed to host memory by the firmware. Set all status fields
		 * to indicate good status.
		 */
		if ((irq_next_pa & ADW_RQ_GOOD) != 0) {
			scsiq->done_status = QD_NO_ERROR;
			scsiq->host_status = scsiq->scsi_status = 0;
			scsiq->data_cnt = 0L;
		}
d2233 15
d2254 1
a2254 1
		sc->irq_sp = ADW_CARRIER_VADDR(sc, ADW_GET_CARRP(irq_next_pa));
d2256 1
a2256 2
		free_carrp->next_ba = (sc->carr_freelist == NULL)? NULL
					: sc->carr_freelist->carr_ba;
d2260 1
d2277 3
a2279 3
		    scsiq->cdb[0] == INQUIRY &&
		    scsiq->target_lun == 0) {
			AdwInquiryHandling(sc, scsiq);
a2295 2
	splx(s);

d2306 1
a2306 1
 * But the function is not re-entrant, so it uses the splbio/splx()
d2315 1
a2315 1
AdwSendIdleCmd(sc, idle_cmd, idle_cmd_parameter)
d2322 2
a2323 2
	u_int16_t	result;
	u_int32_t	i, j, s;
a2324 1
	s = splbio();
d2329 2
d2332 1
a2332 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_IDLE_CMD_STATUS, (u_int16_t) 0);
d2340 3
a2342 3
	ADW_WRITE_DWORD_LRAM(iot, ioh, ADW_MC_IDLE_CMD_PARAMETER,
			idle_cmd_parameter);
	ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_IDLE_CMD, idle_cmd);
d2347 2
a2348 2
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADW_TICKLE_B);
	if (sc->chip_type == ADW_CHIP_ASC3550) {
d2354 1
a2354 1
		ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADW_TICKLE_NOP);
d2361 1
a2361 2
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_IDLE_CMD_STATUS,
									result);
a2362 1
				splx(s);
d2365 1
a2365 1
			AdwDelayMicroSecond(1);
a2368 1
	splx(s);
d2381 1
a2381 1
AdwInquiryHandling(sc, scsiq)
d2395 1
a2395 1
	 * AdwInquiryHandling() requires up to INQUIRY information Byte 7
d2410 1
a2410 1
        inq = (ADW_SCSI_INQUIRY *) scsiq->vdata_addr;
d2415 1
a2415 2
	if ((inq->rsp_data_fmt < 2) /*SCSI-1 | CCS*/ &&
	    (inq->ansi_apr_ver < 2)) {
d2441 1
a2441 1
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE,
d2445 1
a2445 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_ABLE,
d2449 3
a2451 4
				 * Clear the microcode "SDTR negotiation" and
				 * "WDTR negotiation" done indicators for the
				 * target to cause it to negotiate with the new
				 * setting set above.
d2453 1
a2453 1
				 * asynchronous mode, so SDTR must be negotiated
d2455 1
a2455 1
				ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE,
d2458 1
a2458 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE,
d2460 1
a2460 1
				ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_WDTR_DONE,
d2463 1
a2463 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_WDTR_DONE,
d2479 1
a2479 1
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE,cfg_word);
d2482 1
a2482 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_ABLE,
d2486 3
a2488 3
				 * Clear the microcode "SDTR negotiation"
				 * done indicator for the target to cause it
				 * to negotiate with the new setting set above.
d2490 1
a2490 1
				ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE,
d2493 1
a2493 1
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_SDTR_DONE,
a2496 24
		/*
		 * If the Inquiry data included enough space for the SPI-3
		 * Clocking field, then check if DT mode is supported.
		 */
		if (sc->chip_type == ADW_CHIP_ASC38C1600 &&
		   (scsiq->cdb[4] >= 57 ||
		   (scsiq->cdb[4] - scsiq->data_cnt) >= 57)) {
			/*
			 * PPR (Parallel Protocol Request) Capable
			 *
			 * If the device supports DT mode, then it must be
			 * PPR capable.
			 * The PPR message will be used in place of the SDTR
			 * and WDTR messages to negotiate synchronous speed
			 * and offset, transfer width, and protocol options.
			 */
                         if((inq->Clocking) & INQ_CLOCKING_DT_ONLY){
				ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE,
						sc->ppr_able);
				sc->ppr_able |= tidmask;
				ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_PPR_ABLE,
						sc->ppr_able);
			}
		}
d2502 1
a2502 1
		 * maximum command count to the ADW_SOFTC 'max_dvc_qng'
d2514 1
a2514 1
			ADW_READ_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE,
d2517 1
a2517 1
			ADW_WRITE_WORD_LRAM(iot, ioh, ADW_MC_TAGQNG_ABLE,
d2521 1
a2521 1
					ADW_MC_NUMBER_OF_MAX_CMD + tid,
d2530 1
a2530 1
AdwSleepMilliSecond(n)
d2539 1
a2539 1
AdwDelayMicroSecond(n)
@


1.3.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: adwlib.c,v 1.3.2.2 2001/05/14 22:23:21 niklas Exp $ */
d78 2
d89 1
a89 1
u_int16_t AdwGetEEPROMConfig __P((bus_space_tag_t, bus_space_handle_t,
d91 1
a91 1
void AdwSetEEPROMConfig __P((bus_space_tag_t, bus_space_handle_t,
d93 2
a94 2
u_int16_t AdwReadEEPWord __P((bus_space_tag_t, bus_space_handle_t, int));
void AdwWaitEEPCmd __P((bus_space_tag_t, bus_space_handle_t));
d96 1
a96 1
void AdwInquiryHandling __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));
d98 2
a99 2
void AdwSleepMilliSecond __P((u_int32_t));
void AdwDelayMicroSecond __P((u_int32_t));
d1563 1
a1563 1
u_int16_t
d1600 1
a1600 1
u_int16_t
d1617 1
a1617 1
void
d1640 1
a1640 1
void
d2220 1
a2220 1
void
d2395 1
a2395 1
void
d2404 1
a2404 1
void
@


1.3.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d71 1
a71 1
#include <uvm/uvm_extern.h>
@


1.3.2.5
log
@Merge in -current from about a week ago
@
text
@d78 8
a85 8
int AdwRamSelfTest(bus_space_tag_t, bus_space_handle_t, u_int8_t);
int AdwLoadMCode(bus_space_tag_t, bus_space_handle_t, u_int16_t *,
								u_int8_t);
int AdwASC3550Cabling(bus_space_tag_t, bus_space_handle_t, ADW_DVC_CFG *);
int AdwASC38C0800Cabling(bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *);
int AdwASC38C1600Cabling(bus_space_tag_t, bus_space_handle_t,
								ADW_DVC_CFG *);
d87 6
a92 6
u_int16_t AdwGetEEPROMConfig(bus_space_tag_t, bus_space_handle_t,
     							ADW_EEPROM *);
void AdwSetEEPROMConfig(bus_space_tag_t, bus_space_handle_t,
					                 ADW_EEPROM *);
u_int16_t AdwReadEEPWord(bus_space_tag_t, bus_space_handle_t, int);
void AdwWaitEEPCmd(bus_space_tag_t, bus_space_handle_t);
d94 1
a94 1
void AdwInquiryHandling(ADW_SOFTC *, ADW_SCSI_REQ_Q *);
d96 2
a97 2
void AdwSleepMilliSecond(u_int32_t);
void AdwDelayMicroSecond(u_int32_t);
@


1.3.2.6
log
@Sync the SMP branch with 3.3
@
text
@d1466 1
a1466 1
	 * then at most Ultra speed (20 MHz) can be used on both connectors.
@


1.3.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d71 2
d1464 2
a1465 2
	 * cannot be connected to either connector. An LVD device or SE device
	 * may be connected to either connector. If an SE device is connected,
@


1.2
log
@support new u2w cards; dante@@mclink.it, merged by kwesterback@@home.com
@
text
@d2385 1
a2436 1
#ifndef FAILSAFE
d2438 1
a2438 1
	if(!(tid & SCSI_ADW_WDTR_DISABLE)
d2476 1
a2476 1
	if(!(tid & SCSI_ADW_SDTR_DISABLE)
d2511 1
a2511 1
	if(!(tid & SCSI_ADW_TAGQ_DISABLE)
d2524 1
a2525 1
	}
@


1.1
log
@Add adw device driver, from NetBSD.
@
text
@d1 1
a1 1
/* $NetBSD: adwlib.c,v 1.2 1998/09/26 19:54:22 dante Exp $        */
d6 1
a6 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d44 2
a45 2
 *
 * Copyright (c) 1995-1998 Advanced System Products, Inc.
d68 2
d81 5
a85 4
static u_int16_t AdvGetEEPConfig __P((bus_space_tag_t, bus_space_handle_t,
     							ADWEEP_CONFIG *));
static u_int16_t AdvReadEEPWord __P((bus_space_tag_t, bus_space_handle_t,
							int));
d87 4
a90 3
static void AdvSetEEPConfig __P((bus_space_tag_t, bus_space_handle_t,
					                 ADWEEP_CONFIG *));
static int AdvSendScsiCmd __P((ADW_SOFTC *, ADW_SCSI_REQ_Q *));
d93 2
a94 2
static void DvcSleepMilliSecond __P((ulong));
static void DvcDelayMicroSecond __P((ulong));
d105 20
a124 20
static ADWEEP_CONFIG
Default_EEPROM_Config = {
	ADW_EEPROM_BIOS_ENABLE,	/* cfg_msw */
	0x0000,		/* cfg_lsw */
	0xFFFF,		/* disc_enable */
	0xFFFF,		/* wdtr_able */
	0xFFFF,		/* sdtr_able */
	0xFFFF,		/* start_motor */
	0xFFFF,		/* tagqng_able */
	0xFFFF,		/* bios_scan */
	0,		/* scam_tolerant */
	7,		/* adapter_scsi_id */
	0,		/* bios_boot_delay */
	3,		/* scsi_reset_delay */
	0,		/* bios_id_lun */
	0,		/* termination */
	0,		/* reserved1 */
	0xFFEF,		/* bios_ctrl */
	0xFFFF,		/* ultra_able */
	0,		/* reserved2 */
d127 6
a132 6
	0,		/* dvc_cntl */
	0,		/* bug_fix */
	0,		/* serial_number_word1 */
	0,		/* serial_number_word2 */
	0,		/* serial_number_word3 */
	0,		/* check_sum */
d134 72
a205 7
	0,		/* dvc_err_code */
	0,		/* adv_err_code */
	0,		/* adv_err_addr */
	0,		/* saved_dvc_err_code */
	0,		/* saved_adv_err_code */
	0,		/* saved_adv_err_addr */
	0		/* num_of_err */
d222 14
a235 11
	u_int16_t       warn_code;
	u_int32_t       sum;
	int             begin_addr;
	int             end_addr;
	int             code_sum;
	int             word;
	int             rql_addr;	/* RISC Queue List address */
	int             i;
	u_int16_t       scsi_cfg1;
	u_int8_t        biosmem[ASC_MC_BIOSLEN];	/* BIOS RISC Memory
							 * 0x40-0x8F */
d248 26
a273 2
	for (i = 0; i < ASC_MC_BIOSLEN; i++) {
		ADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_BIOSMEM + i, biosmem[i]);
d282 38
a319 3
	for (word = 0; word < adv_mcode_size; word += 2) {
		ADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,
				       *((u_int16_t *) (&adv_mcode[word])));
d323 8
a330 1
	 * Clear the rest of Condor's Internal RAM (8KB).
d332 1
a332 1
	for (; word < ADW_CONDOR_MEMSIZE; word += 2) {
d341 2
a342 1
	for (word = 0; word < adv_mcode_size; word += 2) {
d346 1
a346 1
	if (sum != adv_mcode_chksum)
d348 1
d353 3
a355 2
	for (i = 0; i < ASC_MC_BIOSLEN; i++) {
		ADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_BIOSMEM + i, biosmem[i]);
d365 1
d367 1
a367 1
		code_sum += *((u_int16_t *) (&adv_mcode[word]));
d372 1
a372 1
	 * Read microcode version and date.
d374 4
a377 2
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE, sc->cfg.mcode_date);
	ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM, sc->cfg.mcode_version);
d380 1
a380 1
	 * Initialize microcode operating variables
d382 1
a382 2
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_ADAPTER_SCSI_ID,
			    sc->chip_scsi_id);
d391 5
d400 1
d402 2
a403 6
	 * Set default microcode operating variables for WDTR, SDTR, and
	 * command tag queuing based on the EEPROM configuration values.
	 *
	 * These ADW_DVC_VAR fields and the microcode variables will be
	 * changed in AdvInquiryHandling() if it is found a device is
	 * incapable of a particular feature.
d405 71
d478 1
a478 10
	 * Set the microcode ULTRA target mask from EEPROM value. The
	 * SDTR target mask overrides the ULTRA target mask in the
	 * microcode so it is safe to set this value without determining
	 * whether the device supports SDTR.
	 *
	 * Note: There is no way to know whether a device supports ULTRA
	 * speed without attempting a SDTR ULTRA speed negotiation with
	 * the device. The device will reject the speed if it does not
	 * support it by responding with an SDTR message containing a
	 * slower speed.
a479 1
	ADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_ULTRA_ABLE, sc->ultra_able);
d490 2
a491 1
	ADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN | sc->chip_scsi_id);
d507 1
a507 1
	    (scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {
d510 1
a517 1
	
d525 1
a525 1
	if ((scsi_cfg1 & ADW_DIFF_MODE) && (scsi_cfg1 & ADW_DIFF_SENSE) == 0)
d527 1
d531 1
a531 1
	 * termination value based on a table listed in advlib.h.
d534 1
a534 1
	 * then 'termination' was set-up in AdvInitFromEEP() and
d539 2
a540 4
		 * The software always controls termination by setting
		 * ADW_TERM_CTL_SEL.
		 * If ADW_TERM_CTL_SEL were set to 0, the hardware would
		 * set termination.
d544 14
a557 25
		switch (scsi_cfg1 & ADW_CABLE_DETECT) {
			/* ADW_TERM_CTL_H: on, ADW_TERM_CTL_L: on */
		case 0x3:
		case 0x7:
		case 0xB:
		case 0xD:
		case 0xE:
		case 0xF:
			sc->cfg.termination |= (ADW_TERM_CTL_H |
					ADW_TERM_CTL_L);
			break;

			/* ADW_TERM_CTL_H: on, ADW_TERM_CTL_L: off */
		case 0x1:
		case 0x5:
		case 0x9:
		case 0xA:
		case 0xC:
			sc->cfg.termination |= ADW_TERM_CTL_H;
			break;

			/* ADW_TERM_CTL_H: off, ADW_TERM_CTL_L: off */
		case 0x2:
		case 0x6:
			break;
d560 1
d562 1
a562 1
	 * Clear any set ADW_TERM_CTL_H and ADW_TERM_CTL_L bits.
d567 2
a568 2
	 * Invert the ADW_TERM_CTL_H and ADW_TERM_CTL_L bits and then
	 * set 'scsi_cfg1'. The ADW_TERM_POL bit does not need to be
d570 1
a570 1
	 * the Termination High and Low bits if ADW_TERM_POL is set.
d584 15
a598 1
			    ADW_FLTR_11_TO_20NS | scsi_cfg1);
d607 17
a623 1
			    ADW_TID_TO_TIDMASK(sc->chip_scsi_id));
d626 6
a631 4
	 * Link all the RISC Queue Lists together in a doubly-linked
	 * NULL terminated list.
	 *
	 * Skip the NULL (0) queue which is not used.
d633 2
a634 12
	for (i = 1, rql_addr = ASC_MC_RISC_Q_LIST_BASE+ASC_MC_RISC_Q_LIST_SIZE;
	     i < ASC_MC_RISC_Q_TOTAL_CNT;
	     i++, rql_addr += ASC_MC_RISC_Q_LIST_SIZE) {
		/*
		 * Set the current RISC Queue List's RQL_FWD and
		 * RQL_BWD pointers in a one word write and set
		 * the state (RQL_STATE) to free.
		 */
		ADW_WRITE_WORD_LRAM(iot, ioh, rql_addr,
				((i + 1) + ((i - 1) << 8)));
		ADW_WRITE_BYTE_LRAM(iot, ioh, rql_addr + RQL_STATE,
				ASC_MC_QS_FREE);
d636 2
d640 2
a641 1
	 * Set the Host and RISC Queue List pointers.
d643 2
a644 2
	 * Both sets of pointers are initialized with the same values:
	 * ASC_MC_RISC_Q_FIRST(0x01) and ASC_MC_RISC_Q_LAST (0xFF).
d646 1
a646 9
	ADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_HOST_NEXT_READY,
			ASC_MC_RISC_Q_FIRST);
	ADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_HOST_NEXT_DONE,
			ASC_MC_RISC_Q_LAST);

	ADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_RISC_NEXT_READY,
			ASC_MC_RISC_Q_FIRST);
	ADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_RISC_NEXT_DONE,
			ASC_MC_RISC_Q_LAST);
d649 1
a649 2
	 * Finally, set up the last RISC Queue List (255) with
	 * a NULL forward pointer.
d651 2
a652 3
	ADW_WRITE_WORD_LRAM(iot, ioh, rql_addr,
			(ASC_MC_NULL_Q + ((i - 1) << 8)));
	ADW_WRITE_BYTE_LRAM(iot, ioh, rql_addr + RQL_STATE, ASC_MC_QS_FREE);
d655 1
a655 1
		 (ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));
d657 5
d668 36
a703 1
	return warn_code;
d707 1
a707 3
 * Read the board's EEPROM configuration. Set fields in ADW_SOFTC and
 * ADW_DVC_CFG based on the EEPROM settings. The chip is stopped while
 * all of this is done.
d709 1
a709 1
 * On failure set the ADW_DVC_VAR field 'err_code' and return ADW_ERROR.
a712 2
 *
 * Note: Chip is stopped on entry.
d715 2
a716 2
AdvInitFromEEP(sc)
	ADW_SOFTC      *sc;
d720 15
a734 3
	u_int16_t       warn_code;
	ADWEEP_CONFIG   eep_config;
	int             eep_chksum, i;
d740 3
a742 1
	 * Read the board's EEPROM configuration.
d744 9
a752 1
	 * Set default values if a bad checksum is found.
d754 7
a760 1
	eep_chksum = AdvGetEEPConfig(iot, ioh, &eep_config);
d762 20
a781 2
	if (eep_chksum != eep_config.check_sum) {
		warn_code |= ASC_WARN_EEPROM_CHKSUM;
d783 15
a797 6
		/*
		 * Set EEPROM default values.
		 */
		for (i = 0; i < sizeof(ADWEEP_CONFIG); i++) {
			*((u_int8_t *) & eep_config + i) =
				*((u_int8_t *) & Default_EEPROM_Config + i);
d800 6
a805 12
		/*
		 * Assume the 6 byte board serial number that was read
		 * from EEPROM is correct even if the EEPROM checksum
		 * failed.
		 */
		eep_config.serial_number_word3 =
			AdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);
		eep_config.serial_number_word2 =
			AdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);
		eep_config.serial_number_word1 =
			AdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);
		AdvSetEEPConfig(iot, ioh, &eep_config);
d807 1
d809 1
a809 2
	 * Set ADW_DVC_VAR and ADW_DVC_CFG variables from the
	 * EEPROM configuration that was read.
d811 3
a813 1
	 * This is the mapping of EEPROM fields to Adv Library fields.
d815 11
a825 16
	sc->wdtr_able = eep_config.wdtr_able;
	sc->sdtr_able = eep_config.sdtr_able;
	sc->ultra_able = eep_config.ultra_able;
	sc->tagqng_able = eep_config.tagqng_able;
	sc->cfg.disc_enable = eep_config.disc_enable;
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;
	sc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);
	sc->start_motor = eep_config.start_motor;
	sc->scsi_reset_wait = eep_config.scsi_reset_delay;
	sc->cfg.bios_boot_wait = eep_config.bios_boot_delay;
	sc->bios_ctrl = eep_config.bios_ctrl;
	sc->no_scam = eep_config.scam_tolerant;
	sc->cfg.serial1 = eep_config.serial_number_word1;
	sc->cfg.serial2 = eep_config.serial_number_word2;
	sc->cfg.serial3 = eep_config.serial_number_word3;
d828 4
a831 2
	 * Set the host maximum queuing (max. 253, min. 16) and the per device
	 * maximum queuing (max. 63, min. 4).
d833 34
a866 6
	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_host_qng == 0) {
			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
d868 4
a871 11
			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
		}
	}
	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
		/* If the value is zero, assume it is uninitialized. */
		if (eep_config.max_dvc_qng == 0) {
			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
		} else {
			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
d874 8
d883 1
a883 2
	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
	 * set 'max_dvc_qng' to 'max_host_qng'.
d885 2
a886 2
	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
		eep_config.max_dvc_qng = eep_config.max_host_qng;
d888 1
d890 1
a890 2
	 * Set ADW_DVC_VAR 'max_host_qng' and ADW_DVC_CFG 'max_dvc_qng'
	 * values based on possibly adjusted EEPROM values.
d892 6
a897 2
	sc->max_host_qng = eep_config.max_host_qng;
	sc->max_dvc_qng = eep_config.max_dvc_qng;
d899 3
d904 1
a904 6
	 * If the EEPROM 'termination' field is set to automatic (0), then set
	 * the ADW_DVC_CFG 'termination' field to automatic also.
	 *
	 * If the termination is specified with a non-zero 'termination'
	 * value check that a legal value is set and set the ADW_DVC_CFG
	 * 'termination' field appropriately.
d906 4
a909 6
	if (eep_config.termination == 0) {
		sc->cfg.termination = 0;	/* auto termination */
	} else {
		/* Enable manual control with low off / high off. */
		if (eep_config.termination == 1) {
			sc->cfg.termination = ADW_TERM_CTL_SEL;
d911 10
a920 16
			/* Enable manual control with low off / high on. */
		} else if (eep_config.termination == 2) {
			sc->cfg.termination = ADW_TERM_CTL_SEL | ADW_TERM_CTL_H;

			/* Enable manual control with low on / high on. */
		} else if (eep_config.termination == 3) {
			sc->cfg.termination = ADW_TERM_CTL_SEL |
					ADW_TERM_CTL_H | ADW_TERM_CTL_L;
		} else {
			/*
			 * The EEPROM 'termination' field contains a bad value.
			 * Use automatic termination instead.
			 */
			sc->cfg.termination = 0;
			warn_code |= ASC_WARN_EEPROM_TERMINATION;
		}
d922 1
d924 7
a930 2
	return warn_code;
}
d932 4
a935 14
/*
 * Read EEPROM configuration into the specified buffer.
 *
 * Return a checksum based on the EEPROM configuration read.
 */
static          u_int16_t
AdvGetEEPConfig(iot, ioh, cfg_buf)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ADWEEP_CONFIG  *cfg_buf;
{
	u_int16_t       wval, chksum;
	u_int16_t      *wbuf;
	int             eep_addr;
d937 724
a1660 2
	wbuf = (u_int16_t *) cfg_buf;
	chksum = 0;
d1663 2
a1664 2
	     eep_addr < ASC_EEP_DVC_CFG_END;
	     eep_addr++, wbuf++) {
d1666 106
a1771 9
		chksum += wval;
		*wbuf = wval;
	}
	*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);
	wbuf++;
	for (eep_addr = ASC_EEP_DVC_CTL_BEGIN;
	     eep_addr < ASC_EEP_MAX_WORD_ADDR;
	     eep_addr++, wbuf++) {
		*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);
a1772 2
	return chksum;
}
a1773 9
/*
 * Read the EEPROM from specified location
 */
static          u_int16_t
AdvReadEEPWord(iot, ioh, eep_word_addr)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int             eep_word_addr;
{
d1775 2
a1776 22
				ASC_EEP_CMD_READ | eep_word_addr);
	AdvWaitEEPCmd(iot, iot);
	return ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);
}

/*
 * Wait for EEPROM command to complete
 */
static void
AdvWaitEEPCmd(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
{
	DvcSleepMilliSecond(1);

	for (;;) {
		if (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &
		    ASC_EEP_CMD_DONE) {
			break;
		}
		DvcSleepMilliSecond(1);
	}
d1781 1
d1786 4
a1789 4
AdvSetEEPConfig(iot, ioh, cfg_buf)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ADWEEP_CONFIG  *cfg_buf;
d1791 3
a1793 2
	u_int16_t      *wbuf;
	u_int16_t       addr, chksum;
d1802 1
a1802 1
	 * Write EEPROM from word 0 to word 15
d1808 2
a1809 2
		ADW_WRITE_WORD_REGISTER(iot, ioh,
				     IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
d1811 1
a1811 1
		DvcSleepMilliSecond(ASC_EEP_DELAY_MS);
d1815 1
a1815 1
	 * Write EEPROM checksum at word 18
d1819 1
a1819 1
				ASC_EEP_CMD_WRITE | addr);
d1821 1
a1821 1
	wbuf++;			/* skip over check_sum */
d1824 1
a1824 1
	 * Write EEPROM OEM name at words 19 to 26
d1829 2
a1830 2
		ADW_WRITE_WORD_REGISTER(iot, ioh,
				     IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
d1833 1
d1835 1
a1835 1
				ASC_EEP_CMD_WRITE_DISABLE);
d1837 1
d1841 1
d1843 5
a1847 1
 * This function resets the chip and SCSI bus
d1849 2
a1850 2
 * It is up to the caller to add a delay to let the bus settle after
 * calling this function.
d1852 6
a1857 7
 * The SCSI_CFG0, SCSI_CFG1, and MEM_CFG registers are set-up in
 * AdvInitAsc3550Driver(). Here when doing a write to one of these
 * registers read first and then write.
 *
 * Note: A SCSI Bus Reset can not be done until after the EEPROM
 * configuration is read to determine whether SCSI Bus Resets
 * should be performed.
d1859 4
a1862 4
void
AdvResetChip(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d1864 31
a1894 2
	u_int16_t       word;
	u_int8_t        byte;
d1896 27
d1925 3
a1927 1
	 * Reset Chip.
d1929 1
a1929 5
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,
			ADW_CTRL_REG_CMD_RESET);
	DvcSleepMilliSecond(100);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,
			ADW_CTRL_REG_CMD_WR_IO_REG);
d1932 1
a1932 5
	 * Initialize Chip registers.
	 *
	 * Note: Don't remove the use of a temporary variable in the following
	 * code, otherwise the Microsoft C compiler will turn the following
	 * lines into a no-op.
d1934 13
a1946 3
	byte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_MEM_CFG);
	byte |= RAM_SZ_8KB;
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_MEM_CFG, byte);
d1948 17
a1964 3
	word = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);
	word &= ~BIG_ENDIAN;
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1, word);
d1967 1
a1967 2
	 * Setting the START_CTL_EMFU 3:2 bits sets a FIFO threshold
	 * of 128 bytes. This register is only accessible to the host.
d1969 12
a1980 2
	ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,
				START_CTL_EMFU | READ_CMD_MRM);
d1983 5
a1987 18
/*
 * Description:
 *      Send a SCSI request to the ASC3550 chip
 *
 * If there is no SG list for the request, set 'sg_entry_cnt' to 0.
 *
 * If 'sg_real_addr' is non-zero on entry, AscGetSGList() will not be
 * called. It is assumed the caller has already initialized 'sg_real_addr'.
 *
 * Return:
 *      ADW_SUCCESS(1) - the request is in the mailbox
 *      ADW_BUSY(0) - total request count > 253, try later
 *      ADW_ERROR(-1) - invalid scsi request Q
 */
int
AdvExeScsiQueue(sc, scsiq)
	ADW_SOFTC      *sc;
	ADW_SCSI_REQ_Q *scsiq;
d1989 9
a1997 1
	return AdvSendScsiCmd(sc, scsiq);
d2000 1
d2005 4
a2008 3
 *      ADW_TRUE(1) - All requests are purged and SCSI Bus is reset.
 *
 * Note: Should always return ADW_TRUE.
d2012 1
a2012 1
	ADW_SOFTC      *sc;
d2014 19
a2032 1
	int             status;
d2034 9
a2042 1
	status = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET, 0L, 0);
d2044 1
a2044 1
	AdvResetSCSIBus(sc);
d2049 1
d2051 5
a2055 1
 * Reset SCSI Bus and delay.
d2057 1
a2057 1
void
d2059 1
a2059 1
	ADW_SOFTC      *sc;
d2063 46
a2108 1
	u_int16_t       scsi_ctrl;
d2110 6
d2117 4
d2123 1
a2123 7
	 * The microcode currently sets the SCSI Bus Reset signal while
	 * handling the AdvSendIdleCmd() IDLE_CMD_SCSI_RESET command above.
	 * But the SCSI Bus Reset Hold Time in the uCode is not deterministic
	 * (it may in fact be for less than the SCSI Spec. minimum of 25 us).
	 * Therefore on return the Adv Library sets the SCSI Bus Reset signal
	 * for ASC_SCSI_RESET_HOLD_TIME_US, which is defined to be greater
	 * than 25 us.
d2125 7
a2131 6
	scsi_ctrl = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL,
				scsi_ctrl | ADW_SCSI_CTRL_RSTOUT);
	DvcDelayMicroSecond((u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US);
	ADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL,
				scsi_ctrl & ~ADW_SCSI_CTRL_RSTOUT);
d2133 1
a2133 1
	DvcSleepMilliSecond((ulong) sc->scsi_reset_wait * 1000);
d2143 1
a2143 1
 *  When a microcode idle command is completed, the ADW_DVC_VAR
d2158 1
a2158 1
	ADW_SOFTC      *sc;
d2162 7
a2168 6
	u_int8_t        int_stat;
	u_int16_t       next_done_loc, target_bit;
	int             completed_q;
	ADW_SCSI_REQ_Q *scsiq;
	ASC_REQ_SENSE  *sense_data;
	int             ret;
a2170 2
	ret = (ADW_IS_INT_PENDING(iot, ioh)) ? ADW_TRUE : ADW_FALSE;

d2174 3
a2176 2
	if (int_stat & ADW_INTR_STATUS_INTRB) {
		sc->idle_cmd_done = ADW_TRUE;
d2178 19
a2196 2
	/*
	 * Notify the driver of a hardware detected SCSI Bus Reset.
d2198 14
a2211 3
	if (int_stat & ADW_INTR_STATUS_INTRC) {
		if (sc->sbreset_callback) {
			(*(ADW_SBRESET_CALLBACK) sc->sbreset_callback) (sc);
d2214 1
d2216 1
a2216 3
	 * ASC_MC_HOST_NEXT_DONE (0x129) is actually the last completed RISC
	 * Queue List request. Its forward pointer (RQL_FWD) points to the
	 * current completed RISC Queue List request.
d2218 24
a2241 13
	ADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_HOST_NEXT_DONE, next_done_loc);
	next_done_loc = ASC_MC_RISC_Q_LIST_BASE +
		(next_done_loc * ASC_MC_RISC_Q_LIST_SIZE) + RQL_FWD;

	ADW_READ_BYTE_LRAM(iot, ioh, next_done_loc, completed_q);

	/* Loop until all completed Q's are processed. */
	while (completed_q != ASC_MC_NULL_Q) {
		ADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_HOST_NEXT_DONE,
				    completed_q);

		next_done_loc = ASC_MC_RISC_Q_LIST_BASE +
			(completed_q * ASC_MC_RISC_Q_LIST_SIZE);
d2243 5
d2249 3
a2251 6
		 * Read the ADW_SCSI_REQ_Q virtual address pointer from
		 * the RISC list entry. The microcode has changed the
		 * ADW_SCSI_REQ_Q physical address to its virtual address.
		 *
		 * Refer to comments at the end of AdvSendScsiCmd() for
		 * more information on the RISC list structure.
d2253 6
a2258 6
		{
			ushort          lsw, msw;
			ADW_READ_WORD_LRAM(iot, ioh,
					   next_done_loc + RQL_PHYADDR, lsw);
			ADW_READ_WORD_LRAM(iot, ioh,
				      next_done_loc + RQL_PHYADDR + 2, msw);
a2259 3
			scsiq = (ADW_SCSI_REQ_Q *)
				(((u_int32_t) msw << 16) | lsw);
		}
a2270 10
		if ((scsiq->done_status == QD_WITH_ERROR) &&
		    (scsiq->scsi_status == SS_CHK_CONDITION) &&
		 (sense_data = (ASC_REQ_SENSE *) scsiq->vsense_addr) != 0 &&
		    (scsiq->orig_sense_len - scsiq->sense_len) >=
			ASC_MIN_SENSE_LEN) {
			/*
			 * Command returned with a check condition and valid
			 * sense data.
			 */
		}
d2276 3
a2278 3
		else if (scsiq->done_status == QD_NO_ERROR &&
			 scsiq->cdb[0] == INQUIRY &&
			 scsiq->target_lun == 0) {
a2280 7
		/* Change the RISC Queue List state to free. */
		ADW_WRITE_BYTE_LRAM(iot, ioh,
				 next_done_loc + RQL_STATE, ASC_MC_QS_FREE);

		/* Get the RISC Queue List forward pointer. */
		ADW_READ_BYTE_LRAM(iot, ioh,
				   next_done_loc + RQL_FWD, completed_q);
d2286 1
a2286 3
		sc->cur_host_qng--;
		scsiq->a_flag |= ADW_SCSIQ_DONE;
		(*(ADW_ISR_CALLBACK) sc->isr_callback) (sc, scsiq);
d2295 2
a2296 1
	return ret;
d2299 1
d2303 5
a2307 1
 * Interrupts do not have to be enabled on entry.
d2312 1
d2315 4
a2318 5
AdvSendIdleCmd(sc, idle_cmd, idle_cmd_parameter, flags)
	ADW_SOFTC      *sc;
	u_int16_t       idle_cmd;
	u_int32_t       idle_cmd_parameter;
	int             flags;
d2322 3
a2324 2
	u_int32_t       i;
	int             ret;
d2326 7
a2332 1
	sc->idle_cmd_done = 0;
d2340 2
a2341 2
	ADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IDLE_PARA_STAT,
			     idle_cmd_parameter);
d2345 1
a2345 2
	 * If the 'flags' argument contains the ADW_NOWAIT flag, then
	 * return with success.
d2347 2
a2348 4
	if (flags & ADW_NOWAIT)
		return ADW_TRUE;

	for (i = 0; i < SCSI_WAIT_10_SEC * SCSI_MS_PER_SEC; i++) {
d2350 3
a2352 1
		 * 'idle_cmd_done' is set by AdvISR().
d2354 2
a2355 2
		if (sc->idle_cmd_done)
			break;
d2357 10
a2366 8
		DvcSleepMilliSecond(1);

		/*
		 * If interrupts were disabled on entry to AdvSendIdleCmd(),
		 * then they will still be disabled here. Call AdvISR() to
		 * check for the idle command completion.
		 */
		(void) AdvISR(sc);
d2369 1
a2369 6
	if (sc->idle_cmd_done == ADW_FALSE) {
		return ADW_FALSE;
	} else {
		ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_IDLE_PARA_STAT, ret);
		return ret;
	}
a2371 112
/*
 * Send the SCSI request block to the adapter
 *
 * Each of the 255 Adv Library/Microcode RISC Lists or mailboxes has the
 * following structure:
 *
 * 0: RQL_FWD - RISC list forward pointer (1 byte)
 * 1: RQL_BWD - RISC list backward pointer (1 byte)
 * 2: RQL_STATE - RISC list state byte - free, ready, done, aborted (1 byte)
 * 3: RQL_TID - request target id (1 byte)
 * 4: RQL_PHYADDR - ADW_SCSI_REQ_Q physical pointer (4 bytes)
 *
 * Return:
 *      ADW_SUCCESS(1) - the request is in the mailbox
 *      ADW_BUSY(0) - total request count > 253, try later
 */
static int
AdvSendScsiCmd(sc, scsiq)
	ADW_SOFTC      *sc;
	ADW_SCSI_REQ_Q *scsiq;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	ADW_CCB        *ccb = (ADW_CCB *) scsiq->ccb_ptr;
	u_int16_t       next_ready_loc;
	u_int8_t        next_ready_loc_fwd;
	long            req_size;
	u_int32_t       q_phy_addr;


	if (sc->cur_host_qng >= sc->max_host_qng) {
		return ADW_BUSY;
	} else {
		sc->cur_host_qng++;
	}

	/*
	 * Clear the ADW_SCSI_REQ_Q done flag.
	 */
	scsiq->a_flag &= ~ADW_SCSIQ_DONE;

	/*
	 * Save the original sense buffer length.
	 *
	 * After the request completes 'sense_len' will be set to the residual
	 * byte count of the Auto-Request Sense if a command returns CHECK
	 * CONDITION and the Sense Data is valid indicated by 'host_status' not
	 * being set to QHSTA_M_AUTO_REQ_SENSE_FAIL. To determine the valid
	 * Sense Data Length subtract 'sense_len' from 'orig_sense_len'.
	 */
	scsiq->orig_sense_len = scsiq->sense_len;

	ADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_HOST_NEXT_READY, next_ready_loc);
	next_ready_loc = ASC_MC_RISC_Q_LIST_BASE +
		(next_ready_loc * ASC_MC_RISC_Q_LIST_SIZE);

	/*
	 * Write the physical address of the Q to the mailbox.
	 * We need to skip the first four bytes, because the microcode
	 * uses them internally for linking Q's together.
	 */
	req_size = sizeof(ADW_SCSI_REQ_Q);
	q_phy_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +
		ADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsiq);

	scsiq->scsiq_ptr = scsiq;

	/*
	 * The RISC list structure, which 'next_ready_loc' is a pointer
	 * to in microcode LRAM, has the format detailed in the comment
	 * header for this function.
	 *
	 * Write the ADW_SCSI_REQ_Q physical pointer to
	 * 'next_ready_loc' request.
	 */
	ADW_WRITE_DWORD_LRAM(iot, ioh, next_ready_loc + RQL_PHYADDR,
			q_phy_addr);

	/* Write target_id to 'next_ready_loc' request. */
	ADW_WRITE_BYTE_LRAM(iot, ioh, next_ready_loc + RQL_TID,
			scsiq->target_id);

	/*
	 * Set the ASC_MC_HOST_NEXT_READY (0x128) microcode variable to
	 * the 'next_ready_loc' request forward pointer.
	 *
	 * Do this *before* changing the 'next_ready_loc' queue to QS_READY.
	 * After the state is changed to QS_READY 'RQL_FWD' will be changed
	 * by the microcode.
	 *
	 * NOTE: The temporary variable 'next_ready_loc_fwd' is required to
	 * prevent some compilers from optimizing out 'AdvReadByteLram()' if
	 * it were used as the 3rd argument to 'AdvWriteByteLram()'.
	 */
	ADW_READ_BYTE_LRAM(iot, ioh, next_ready_loc + RQL_FWD,
			   next_ready_loc_fwd);
	ADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_HOST_NEXT_READY,
			    next_ready_loc_fwd);

	/*
	 * Change the state of 'next_ready_loc' request from QS_FREE to
	 * QS_READY which will cause the microcode to pick it up and
	 * execute it.
	 *
	 * Can't reference 'next_ready_loc' after changing the request
	 * state to QS_READY. The microcode now owns the request.
	 */
	ADW_WRITE_BYTE_LRAM(iot, ioh, next_ready_loc + RQL_STATE,
			    ASC_MC_QS_READY);

	return ADW_SUCCESS;
}
d2382 2
a2383 2
	ADW_SOFTC      *sc;
	ADW_SCSI_REQ_Q *scsiq;
d2387 5
a2391 4
	ASC_SCSI_INQUIRY *inq;
	u_int16_t       cfg_word;
	u_int16_t       tidmask;
	u_int8_t        tid;
d2402 1
d2406 1
d2408 2
a2409 1
	inq = (ASC_SCSI_INQUIRY *) scsiq->vdata_addr;
d2414 1
a2414 1
	if (inq->byte3.rsp_data_fmt < 2 && inq->byte2.ansi_apr_ver < 2) {
d2427 1
d2436 5
a2440 1
		if ((sc->wdtr_able & tidmask) && inq->byte7.WBus16) {
d2442 1
a2442 1
					   cfg_word);
d2446 1
a2446 1
						    cfg_word);
d2449 5
a2453 3
				 * Clear the microcode "WDTR negotiation" done
				 * indicator for the target to cause it
				 * to negotiate with the new setting set above.
d2455 5
d2461 1
a2461 1
						   cfg_word);
d2464 1
a2464 1
						    cfg_word);
d2467 1
d2475 5
a2479 3
		if ((sc->sdtr_able & tidmask) && inq->byte7.Sync) {
			ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,
					   cfg_word);
d2483 1
a2483 1
						    cfg_word);
d2486 3
a2488 3
				 * Clear the microcode "SDTR negotiation" done
				 * indicator for the target to cause it
				 * to negotiate with the new setting set above.
d2491 1
a2491 1
						   cfg_word);
d2494 1
a2494 1
						    cfg_word);
d2497 1
d2499 2
a2500 2
		 * If the EEPROM enabled Tag Queuing for device and the
		 * device supports Tag Queuing, then turn on the device's
d2502 1
a2502 1
		 * maximum command count to the ADW_DVC_VAR 'max_dvc_qng'
d2510 4
a2513 1
		if ((sc->tagqng_able & tidmask) && inq->byte7.CmdQue) {
d2515 1
a2515 1
					   cfg_word);
d2518 2
a2519 1
					    cfg_word);
d2521 2
a2522 2
					    ASC_MC_NUMBER_OF_MAX_CMD + tid,
					    sc->max_dvc_qng);
d2524 1
d2528 1
d2530 2
a2531 2
DvcSleepMilliSecond(n)
	ulong           n;
d2537 1
d2539 2
a2540 2
DvcDelayMicroSecond(n)
	ulong           n;
d2545 1
@

