head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.10
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.4
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.6
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.36.0.8
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.4
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.35.0.6
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.8
	OPENBSD_5_0:1.35.0.4
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19;
locks; strict;
comment	@ * @;


1.39
date	2014.09.03.00.46.04;	author dlg;	state Exp;
branches;
next	1.38;
commitid	z6K8FSAT3J9gg3C0;

1.38
date	2014.09.01.07.52.30;	author blambert;	state Exp;
branches;
next	1.37;
commitid	pRnd0qMNwQQn0ntn;

1.37
date	2014.04.16.01.19.28;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2013.01.17.10.34.37;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.13.07.48.12;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.13.06.53.43;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.10.07.00.56;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.06.07.18.18;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.06.01.24.43;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.06.01.04.24;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.11.03.51.57;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.03.06.47.58;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.03.06.36.50;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.03.06.15.30;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.02.23.20.41;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.01.18.42.26;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.28.11.00.40;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.17.10.25.39;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.21.09.44.05;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.21.09.42.27;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2006.07.09.13.35.10;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.06.09.59.43;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.06.09.04.45;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.06.00.55.03;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.16.05.36.46;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.15.07.35.44;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.15.06.45.53;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.15.04.59.21;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.15.04.44.59;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.12.14.06.05;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.12.03.46.12;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.10.13.45.48;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.01.21.32.15;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.01.04.36.19;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.31.00.32.51;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.29.19.55.37;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.29.05.43.55;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.28.02.32.55;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.27.19.03.55;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.39
log
@tasks dont need a mutex and a semaphore to protect against multiple uses
of the task structure like workq tasks did.

tested on an fc929
@
text
@/*	$OpenBSD: mpivar.h,v 1.38 2014/09/01 07:52:30 blambert Exp $ */

/*
 * Copyright (c) 2005 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2005 Marco Peereboom <marco@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/task.h>

/* #define MPI_DEBUG */
#ifdef MPI_DEBUG
extern uint32_t			mpi_debug;
#define DPRINTF(x...)		do { if (mpi_debug) printf(x); } while(0)
#define DNPRINTF(n,x...)	do { if (mpi_debug & (n)) printf(x); } while(0)
#define	MPI_D_CMD		0x0001
#define	MPI_D_INTR		0x0002
#define	MPI_D_MISC		0x0004
#define	MPI_D_DMA		0x0008
#define	MPI_D_IOCTL		0x0010
#define	MPI_D_RW		0x0020
#define	MPI_D_MEM		0x0040
#define	MPI_D_CCB		0x0080
#define	MPI_D_PPR		0x0100
#define	MPI_D_RAID		0x0200
#define	MPI_D_EVT		0x0400
#else
#define DPRINTF(x...)
#define DNPRINTF(n,x...)
#endif

#define MPI_REQUEST_SIZE	512
#define MPI_REPLY_SIZE		80
#define MPI_REPLYQ_DEPTH	128
#define MPI_REPLY_COUNT		(PAGE_SIZE / MPI_REPLY_SIZE)

/*
 * this is the max number of sge's we can stuff in a request frame:
 * sizeof(scsi_io) + sizeof(sense) + sizeof(sge) * 32 = MPI_REQUEST_SIZE
 */
#define MPI_MAX_SGL		36

struct mpi_dmamem {
	bus_dmamap_t		mdm_map;
	bus_dma_segment_t	mdm_seg;
	size_t			mdm_size;
	caddr_t			mdm_kva;
};
#define MPI_DMA_MAP(_mdm)	((_mdm)->mdm_map)
#define MPI_DMA_DVA(_mdm)	((u_int64_t)(_mdm)->mdm_map->dm_segs[0].ds_addr)
#define MPI_DMA_KVA(_mdm)	((void *)(_mdm)->mdm_kva)

struct mpi_ccb_bundle {
	struct mpi_msg_scsi_io	mcb_io; /* sgl must follow */
	struct mpi_sge		mcb_sgl[MPI_MAX_SGL];
	struct scsi_sense_data	mcb_sense;
} __packed;

struct mpi_softc;

struct mpi_rcb {
	SIMPLEQ_ENTRY(mpi_rcb)	rcb_link;
	void			*rcb_reply;
	bus_addr_t		rcb_offset;
	u_int32_t		rcb_reply_dva;
};
SIMPLEQ_HEAD(mpi_rcb_list, mpi_rcb);

struct mpi_ccb {
	struct mpi_softc	*ccb_sc;
	int			ccb_id;

	void 			*ccb_cookie;
	bus_dmamap_t		ccb_dmamap;

	bus_addr_t		ccb_offset;
	void			*ccb_cmd;
	u_int64_t		ccb_cmd_dva;

	volatile enum {
		MPI_CCB_FREE,
		MPI_CCB_READY,
		MPI_CCB_QUEUED
	}			ccb_state;
	void			(*ccb_done)(struct mpi_ccb *);
	struct mpi_rcb		*ccb_rcb;

	SLIST_ENTRY(mpi_ccb)	ccb_link;
};

SLIST_HEAD(mpi_ccb_list, mpi_ccb);

struct mpi_softc {
	struct device		sc_dev;
	struct scsi_link	sc_link;

	int			sc_flags;
#define MPI_F_SPI			(1<<0)
#define MPI_F_RAID			(1<<1)

	struct scsibus_softc	*sc_scsibus;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	bus_dma_tag_t		sc_dmat;

	u_int8_t		sc_fw_maj;
	u_int8_t		sc_fw_min;
	u_int8_t		sc_fw_unit;
	u_int8_t		sc_fw_dev;

	u_int8_t		sc_porttype;
	int			sc_maxcmds;
	int			sc_maxchdepth;
	int			sc_first_sgl_len;
	int			sc_chain_len;
	int			sc_max_sgl_len;

	int			sc_buswidth;
	int			sc_target;
	int			sc_ioc_number;

	struct mpi_dmamem	*sc_requests;
	struct mpi_ccb		*sc_ccbs;
	struct mpi_ccb_list	sc_ccb_free;
	struct mutex		sc_ccb_mtx;
	struct scsi_iopool	sc_iopool;

	struct mpi_dmamem	*sc_replies;
	struct mpi_rcb		*sc_rcbs;
	int			sc_repq;

	struct mpi_ccb		*sc_evt_ccb;
	struct mpi_rcb_list	sc_evt_ack_queue;
	struct mutex		sc_evt_ack_mtx;
	struct scsi_iohandler	sc_evt_ack_handler;

	struct mpi_rcb_list	sc_evt_scan_queue;
	struct mutex		sc_evt_scan_mtx;
	struct scsi_iohandler	sc_evt_scan_handler;

	struct task		sc_evt_rescan;

	size_t			sc_fw_len;
	struct mpi_dmamem	*sc_fw;

	/* scsi ioctl from sd device */
	int			(*sc_ioctl)(struct device *, u_long, caddr_t);

	struct rwlock		sc_lock;
	struct mpi_cfg_hdr	sc_cfg_hdr;
	struct mpi_cfg_ioc_pg2	*sc_vol_page;
	struct mpi_cfg_raid_vol	*sc_vol_list;
	struct mpi_cfg_raid_vol_pg0 *sc_rpg0;

	struct ksensor		*sc_sensors;
	struct ksensordev	sc_sensordev;
};

int	mpi_attach(struct mpi_softc *);
void	mpi_detach(struct mpi_softc *);

int	mpi_intr(void *);
@


1.38
log
@move mpi(4) from workq to taskq

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.37 2014/04/16 01:19:28 dlg Exp $ */
a154 2
	struct mutex		sc_evt_rescan_mtx;
	u_int			sc_evt_rescan_sem;
@


1.37
log
@print the board name and firmware revision like we do on mpii and
nvme and other stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.36 2013/01/17 10:34:37 dlg Exp $ */
d20 2
d154 1
a154 1
	struct workq_task	sc_evt_rescan;
@


1.36
log
@forgot this file when committing the 64bit dva diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.35 2010/09/13 07:48:12 dlg Exp $ */
d116 5
@


1.35
log
@if a busy sas device is unplugged, the pending io on that device will
never complete.

when we get a detach event from the firmware, we currently deactivate the
device and then request the scsi midlayer attempt to detach the device.
this diff now deactivates the device and then resets the target, forcing
the ioc to complete the pending operations. once the reset has completed
we then request a detach of the kernel device.

this lets me hotplug busy sas disks without leaking scsi_xfers or bufs or
anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.34 2010/09/13 06:53:43 dlg Exp $ */
d59 1
a59 1
#define MPI_DMA_DVA(_mdm)	((_mdm)->mdm_map->dm_segs[0].ds_addr)
d87 1
a87 1
	bus_addr_t		ccb_cmd_dva;
@


1.34
log
@im not convinced we only have one outstanding event to ack at a time. this
steals^Wleverages the code used in mpii for handling a list of events to
acknowlede.

tested by hotplugging sas disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.33 2010/09/10 07:00:56 dlg Exp $ */
d142 4
@


1.33
log
@implement handling of rescan events on fc controllers. allows "hotplug" of
fc devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.32 2010/07/06 07:18:18 dlg Exp $ */
d71 1
d76 1
d139 3
a141 1
	struct scsi_iohandler	sc_evt_ack;
@


1.32
log
@if we get an event notification that requires acknowledgement while
we're busy, we might not be able to allocate a ccb via scsi_ioh_get
if the pool is empty. this means we wont ack the event, which in
turn means we wont receive further event notifications.

this cuts the event ack code over to using a scsi_iohandler. the
eventack iohandler will be called as soon as a ccb becomes available
for it to use. this guarantees reliable event handling and
acknowledgement, despite how busy the controller might be.

this has bugging me ever since i wrote the event handling code.
tested by hotplugging sata disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.31 2010/04/06 01:24:43 dlg Exp $ */
d138 4
@


1.31
log
@use SLISTs for managing the ccb free list rather than TAILQs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.30 2010/04/06 01:04:24 dlg Exp $ */
d137 1
@


1.30
log
@modify mpi to provide an iopool as a way for the midlayer to manage access
to its free ccbs.

this allows the midlayer to schedule access to the bus in a roundrobin
fashion for all consumers on the bus, including io from devices and even
the internal mpi management commands used to poll the state of raid
devices. the result is fairer sharing between disks on the bus and more
reliable sensor updates.

ok krw@@ beck@@ marco@@
tested by beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.29 2010/01/11 03:51:57 dlg Exp $ */
d95 1
a95 1
	TAILQ_ENTRY(mpi_ccb)	ccb_link;
d98 1
a98 1
TAILQ_HEAD(mpi_ccb_list, mpi_ccb);
@


1.29
log
@rework the polling code to use the semantic krw@@ proposed.

intercept the ccb_done handling so polled commands set a flag that mpi_poll
tests on. when ccb_done sets the variable, the poll loop breaks and
mpi_poll runs the original ccb_done handler for the ccb completion.

this is a lot simpler than the previous implementation and removes a
mutex.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.28 2010/01/03 06:47:58 dlg Exp $ */
d130 1
@


1.28
log
@rename ccb_xs to ccb_cookie, and switch it from a struct scsi_xfer * to a
void *. this will let me stash things other than scsi xfers in the ccb for
ccb_done handlers to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.27 2010/01/03 06:36:50 dlg Exp $ */
a113 2

	struct mutex		sc_reply_mtx;
@


1.27
log
@when getting a reply from the hw, only sync the dmamem for that one reply
rather than all the replies.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.26 2010/01/03 06:15:30 dlg Exp $ */
d80 1
a80 1
	struct scsi_xfer	*ccb_xs;
@


1.26
log
@switch mpi from using splbio to protect itself over to mutexes.

mpi only needs two mutexes, one for the list of free ccbs, and another to
protect the reply doorbell. the latter is necessary to allow polling for
command completion to work in smp systems.

tested on sas and fc hbas. this diff was written over 2 years ago now with
surprisingly few tweaks to handle changes that have occurred since then.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.25 2009/11/02 23:20:41 marco Exp $ */
d72 1
@


1.25
log
@Don't write bogus values to reply_fifo_host_signalling_addr.  This register
should remain untouched because it is only for interruptless drivers.

Honor reply queue depth per the spec instead of clipping it at 32.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.24 2008/11/01 18:42:26 marco Exp $ */
d114 2
d130 1
d135 2
@


1.24
log
@Oops forgot .h part.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.23 2008/10/28 11:00:40 marco Exp $ */
d42 2
a43 1
#define MPI_REPLY_SIZE		128
d131 1
@


1.23
log
@Add beginings of bio.  Disabled for now.

dlg "go go go"
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.22 2007/03/17 10:25:39 dlg Exp $ */
d141 1
@


1.22
log
@replace the VMWARE quirk that restricts the bus width to 16 targets with
one for all SPI controllers. krw has a sun machine with a 1030 that gets
the bus width wrong too, so since vmware emulates that type of hardware
too, we can just limit the lot of them and forget about it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.21 2006/09/21 09:44:05 dlg Exp $ */
a19 1

d133 11
@


1.21
log
@add a debug flag type thing for event handling
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.20 2006/09/21 09:42:27 dlg Exp $ */
d104 1
a104 1
#define MPI_F_VMWARE			(1<<0)
@


1.20
log
@wrap the hardware replies up in a structure called mpi_rcb which is
similair to the one used for requests. take the reply bits out of the ccb,
but point it at the rcb instead.

this lets us defer processing of the reply some time after we reuse or
free the ccb.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.19 2006/07/09 13:35:10 dlg Exp $ */
d36 1
@


1.19
log
@implement firmware upload. this frees up memory on some controllers so they
can do more io at a time. tested on the onboard controllers of a dell 2850
(which can do it) and a pci controller on my home box (which doesnt). this
was the last feature mpt had that mpi was behind on.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.18 2006/07/06 09:59:43 dlg Exp $ */
d43 1
d69 5
d91 1
a91 2
	void			*ccb_reply;
	u_int32_t		ccb_reply_dva;
d129 1
@


1.18
log
@fix debugging stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.17 2006/07/06 09:04:45 dlg Exp $ */
d124 3
@


1.17
log
@do not stash pages 2 and 3 (the volume and physdisk pages respectively)
of the ioc config in the softc. instead, we only walk page 2 when we get
the raid config and mark each disks scsi_link structure with the
SDEV_LOGICAL flag when we find volumes. while there we mark this instance
of the driver as being capable of doing raid so later on we can
conditionally hook up bio.

when we walk the devices attached to mpi to do ppr, we now skip the logical
disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.16 2006/07/06 00:55:03 dlg Exp $ */
d25 1
a25 1
#define DNPRINTF(n,x...)	do { if (mpi_debug & n) printf(x); } while(0)
@


1.16
log
@stash a pointer to the scsibus attached to us so we dont have to walk the
device tree all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.15 2006/06/16 05:36:46 dlg Exp $ */
d99 1
a123 4

	/* RAID pages */
	struct mpi_cfg_ioc_pg2	*sc_ioc_pg2;
	struct mpi_cfg_ioc_pg3  *sc_ioc_pg3;
@


1.15
log
@vmware emulates mpi, but it does a half arsed job of it. half the fields
we read off the hardware and use to configure the driver with are set to
zero, so things dont really work like we want them to.

one of these fields is the pci subsystem id which is something we can fetch
really early in the attach process. so if the subsys is 0 then we go on and
fix up some of the values we get off the "hardware". now we can attach
disks on vmware.

"sneaky" and ok marco@@ tested by and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.14 2006/06/15 07:35:44 marco Exp $ */
d99 2
@


1.14
log
@Add detection of RAID volume during PPR.  Doesn't fan out the ppr to individual
devices yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.13 2006/06/15 06:45:53 marco Exp $ */
d96 3
@


1.13
log
@Add IOC page 3 support.  Needed for RAID and bio.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.12 2006/06/15 04:59:21 marco Exp $ */
d111 1
@


1.12
log
@And now without a buffer overflow.  Pointed out by dlg.  No cookie for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.11 2006/06/15 04:44:59 marco Exp $ */
d118 1
d120 1
@


1.11
log
@Add structures and initial code to retrieve IOC page 2.  We need this for
RAID support and bio.  "go at it" dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.10 2006/06/12 14:06:05 dlg Exp $ */
d117 2
@


1.10
log
@fix sgl loading. there were a few issues, the main ones being:
- when the sgl grew too large it became bigger than the maximum frame size
that the ioc would deal with, and then it would just stop doing io. i was
using the wrong field from iocfacts to figure out how large an sgl should
be.
- chained sgls were broken cos i was including the current chain element in
the calculation of the offset to the next chain element.

big ok from marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.9 2006/06/12 03:46:12 marco Exp $ */
d35 1
@


1.9
log
@Initial version of dv for scsi.  Work based on dlg's code.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.8 2006/06/10 13:45:48 marco Exp $ */
d105 1
@


1.8
log
@Redo debug prints to make it less loud and more granular.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.7 2006/06/01 21:32:15 dlg Exp $ */
d34 1
@


1.7
log
@leave the reply_dva address alone so we can post it back to the ioc rather
than posting back the offset of the reply frame to the start of the reply
space.

nobody likes panics, even if theyre free.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.6 2006/06/01 04:36:19 dlg Exp $ */
d20 18
@


1.6
log
@fix the reply handling on crazy machines that give me bits in the high part
of the address.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.5 2006/05/31 00:32:51 dlg Exp $ */
d66 1
a66 1
	paddr_t			ccb_reply_dva;
@


1.5
log
@implement chained scatter gather lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.4 2006/05/29 19:55:37 dlg Exp $ */
d57 1
a57 1
	paddr_t			ccb_cmd_dva;
@


1.4
log
@limit the number of scatter gather entries sent with the scsi_io commands
so it fits in the maximum request frame size. this will do until i can
write sgl chaining in a nice way.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.3 2006/05/29 05:43:55 dlg Exp $ */
d82 1
d84 1
d86 1
a86 2
	int			sc_maxchdepth;
	u_int8_t		sc_porttype;
@


1.3
log
@bump mpi up to using 64bit for all dva
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.2 2006/05/28 02:32:55 dlg Exp $ */
a19 2
/* XXX */
#define MPI_MAX_SGL		32
d24 6
d83 1
@


1.2
log
@pass the reply from the hardware via the ccb rather than on the stack to
the function handling the completion. this means that the completion
function can do nothing with the reply, instead leaving it up to the
requester to deal with.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.1 2006/05/27 19:03:55 dlg Exp $ */
d38 1
a38 1
	struct mpi_sge32	mcb_sgl[MPI_MAX_SGL];
@


1.1
log
@add mpi(4), an alternative (replacement) driver for lsi logic fusion mpt
controllers currently supported by mpt(4).

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d60 3
a62 1
	void			(*ccb_done)(struct mpi_ccb *, void *, paddr_t);
d87 1
a87 1
	struct mpi_ccb_list	sc_ccb_free, sc_ccb_runq;
@

