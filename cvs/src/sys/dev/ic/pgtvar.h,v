head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.6
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.10
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.14.0.10
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.4
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.11.0.16
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.12
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.14
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.10
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.8
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.17
date	2015.12.11.16.07.01;	author mpi;	state Exp;
branches;
next	1.16;
commitid	fbhqfhfdKxBcsetK;

1.16
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.14.12.24.18;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.03.21.11.33;	author dhill;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.20.07.40.41;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.27.20.06.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.09.21.04.05;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.09.20.45.27;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2006.10.06.21.55.33;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.02.18.06.55;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.16.10.36.12;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.31.21.36.54;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.31.17.05.50;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.31.09.26.14;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.28.10.23.49;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.24.23.55.35;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.22.18.12.13;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@/*	$OpenBSD: pgtvar.h,v 1.16 2013/12/06 21:03:03 deraadt Exp $  */

/*
 * Copyright (c) 2006 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2006 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 2004 Fujitsu Laboratories of America, Inc.
 * Copyright (c) 2004 Brian Fundakowski Feldman
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef __PGTVAR_H__
#define __PGTVAR_H__

#define PGT_RX_RADIOTAP_PRESENT						\
	((1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL) |				\
	 (1 << IEEE80211_RADIOTAP_RSSI))

struct pgt_rx_radiotap_hdr {
	struct ieee80211_radiotap_header	wr_ihdr;
	uint8_t					wr_flags;
	uint16_t				wr_chan_freq;
	uint16_t				wr_chan_flags;
	uint8_t					wr_rssi;
	uint8_t					wr_max_rssi;
} __packed;

#define PGT_TX_RADIOTAP_PRESENT						\
	((1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_RATE) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL))

struct pgt_tx_radiotap_hdr {
	struct ieee80211_radiotap_header	wt_ihdr;
	uint8_t					wt_flags;
	uint8_t					wt_rate;
	uint16_t				wt_chan_freq;
	uint16_t				wt_chan_flags;
} __packed;

/*
 * The struct pgt_desc is used to either enqueue or dequeue pgt_frags
 * (packets) when either free or in flight.
 */
struct pgt_desc {
	TAILQ_ENTRY(pgt_desc)	pd_link;
	caddr_t		        pd_mem;
	bus_addr_t		pd_dmaaddr;
	bus_dmamap_t		pd_dmam;
	bus_dma_segment_t	pd_dmas;
	struct pgt_frag	       *pd_fragp;
	unsigned int		pd_fragnum;
};
TAILQ_HEAD(pgt_descq, pgt_desc);

/*
 * The struct pgt_mgmt_desc is used to enqueue a management request
 * and await response.
 */
struct pgt_mgmt_desc {
	TAILQ_ENTRY(pgt_mgmt_desc)	pmd_link;
	const void		       *pmd_sendbuf;	/* NULL = get op */
	void			       *pmd_recvbuf;	/* NULL = set op */
	size_t				pmd_len;
	uint32_t			pmd_oid;
	int				pmd_error;
};
TAILQ_HEAD(pgt_mgmt_descq, pgt_mgmt_desc);

/*
 * These events are put on the per-device kthread to be
 * able to trigger actions from inside the interrupt; as most
 * operations require waiting for another interrupt for response
 * (that is, management packets), this is common.
 */
struct pgt_async_trap {
	TAILQ_ENTRY(pgt_async_trap)	pa_link;
	struct mbuf		       *pa_mbuf;
	/* followed by the rest of the mbuf data */
};

struct pgt_ieee80211_node {
	struct ieee80211_node	pin_node;
	enum pin_dot1x_authorization {
		PIN_DOT1X_UNAUTHORIZED,
		PIN_DOT1X_AUTHORIZED
	}			pin_dot1x_auth_desired, pin_dot1x_auth;
	uint16_t		pin_mlme_state;
};

struct pgt_softc {
	struct device		sc_dev;
	struct ieee80211com	sc_ic;
	unsigned int		sc_flags;
#define	SC_NEEDS_FIRMWARE	0x00000001 /* do firmware upload on reset */
#define	SC_UNINITIALIZED	0x00000002 /* still awaiting initial intr */
#define	SC_DYING		0x00000004 /* going away */
#define	SC_NEEDS_RESET		0x00000008 /* going to reset when refcnt = 1 */
#define	SC_INTR_RESET		0x00000020 /* interrupt resets at end */
#define	SC_POWERSAVE		0x00000040 /* device is asleep */
#define	SC_NOFREE_ALLNODES	0x00000100 /* do not free assoc w/reinit */
#define	SC_START_DESIRED	0x00000200 /* tried to start during mgmt-crit */
#define	SC_KTHREAD		0x00000400 /* has a kthread around */
#define	SC_ISL3877		0x00000800 /* chipset */
	struct timeout		sc_chanscan_timer;
	/* configuration sysctls */
	int			sc_dot1x;
	int			sc_wds;
	/* cached values */
	int			sc_if_flags;
	int16_t			sc_80211_ioc_wep;
	int16_t			sc_80211_ioc_auth;
	uint32_t		sc_noise;
	unsigned int		sc_debug;
#define	SC_DEBUG_QUEUES		0x00000001
#define	SC_DEBUG_MGMT		0x00000002
#define	SC_DEBUG_UNEXPECTED	0x00000004
#define	SC_DEBUG_TRIGGER	0x00000008
#define	SC_DEBUG_EVENTS		0x00000010
#define	SC_DEBUG_POWER		0x00000020
#define	SC_DEBUG_TRAP		0x00000040
#define	SC_DEBUG_LINK		0x00000080
#define	SC_DEBUG_RXANNEX	0x00000100
#define	SC_DEBUG_RXFRAG		0x00000200
#define	SC_DEBUG_RXETHER	0x00000400
	bus_space_tag_t		sc_iotag;
	bus_space_handle_t	sc_iohandle; 
	bus_dma_tag_t		sc_dmat;

	bus_dmamap_t		sc_cbdmam;
	bus_dma_segment_t	sc_cbdmas;
	struct pgt_control_block *sc_cb;	/* DMA-mapped control block */

	bus_dmamap_t		sc_psmdmam;
	bus_dma_segment_t	sc_psmdmas;
	void		       *sc_psmbuf;	/* DMA-mapped psm frame area */

	int			(*sc_newstate)
				(struct ieee80211com *,
				 enum ieee80211_state, int);

	int			(*sc_enable)(struct pgt_softc *);
	void			(*sc_disable)(struct pgt_softc *);
	void			(*sc_power)(struct pgt_softc *, int);

	struct pgt_mgmt_descq	sc_mgmtinprog;
	struct pgt_descq	sc_freeq[PGT_QUEUE_COUNT];
	size_t			sc_freeq_count[PGT_QUEUE_COUNT];
	struct pgt_descq	sc_dirtyq[PGT_QUEUE_COUNT];
	size_t			sc_dirtyq_count[PGT_QUEUE_COUNT];
	int			sc_txtimer;
	struct pgt_softc_kthread {
		struct proc		       *sck_proc;
		int				sck_exit, sck_reset, sck_update;
		TAILQ_HEAD(, pgt_async_trap)	sck_traps;
	}			sc_kthread;

#if NBPFILTER > 0
	caddr_t			sc_drvbpf;

	union {
		struct pgt_rx_radiotap_hdr th;
                uint8_t pad[64];
	}			sc_rxtapu;
#define sc_rxtap		sc_rxtapu.th
	int			sc_rxtap_len;

	union {
		struct pgt_tx_radiotap_hdr th;
		uint8_t pad[64];
	}			sc_txtapu;
#define sc_txtap		sc_txtapu.th
	int			sc_txtap_len;
#endif
};

int	pgt_intr(void *);
void	pgt_attach(struct device *);
int	pgt_detach(struct pgt_softc *);
int	pgt_activate(struct device *, int);

static __inline int
pgt_queue_is_rx(enum pgt_queue pq)
{
	return (pq == PGT_QUEUE_DATA_LOW_RX ||
	    pq == PGT_QUEUE_DATA_HIGH_RX ||
	    pq == PGT_QUEUE_MGMT_RX);
}

static __inline int
pgt_queue_is_tx(enum pgt_queue pq)
{
	return (pq == PGT_QUEUE_DATA_LOW_TX ||
	    pq == PGT_QUEUE_DATA_HIGH_TX ||
	    pq == PGT_QUEUE_MGMT_TX);
}

static __inline int
pgt_queue_is_data(enum pgt_queue pq)
{
	return (pq == PGT_QUEUE_DATA_LOW_RX ||
	    pq == PGT_QUEUE_DATA_HIGH_RX ||
	    pq == PGT_QUEUE_DATA_LOW_TX ||
	    pq == PGT_QUEUE_DATA_HIGH_TX);
}

static __inline int
pgt_queue_is_mgmt(enum pgt_queue pq)
{
	return (pq == PGT_QUEUE_MGMT_RX ||
	    pq == PGT_QUEUE_MGMT_TX);
}

#endif
@


1.16
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: pgtvar.h,v 1.15 2013/11/14 12:24:18 dlg Exp $  */
d214 1
a214 1
void	pgt_attach(void *);
@


1.15
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: pgtvar.h,v 1.14 2011/07/03 21:11:33 dhill Exp $  */
a210 2

	struct task		sc_resume_t;
@


1.14
log
@change void * to a caddr_t

no change in binary

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgtvar.h,v 1.13 2010/09/20 07:40:41 deraadt Exp $  */
d212 1
a212 1
	struct workq_task	sc_resume_wqt;
@


1.13
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pgtvar.h,v 1.12 2010/08/27 20:06:39 deraadt Exp $  */
d83 1
a83 1
	void		       *pd_mem;
@


1.12
log
@Massage the powerhook function into an activate function, and since we do
not neccessarily have a working filesystem for the firmware yet, use a workq
to postpone resume.  Then make the powerhook function call the activate
function.  There remains some questions about the sc_power functions...
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pgtvar.h,v 1.11 2006/10/09 21:04:05 mglocker Exp $  */
a180 2
	void			*sc_shutdown_hook;	/* shutdown hook */
	void			*sc_power_hook;		/* power mgmt hook */
@


1.11
log
@Kill unused kthread struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgtvar.h,v 1.10 2006/10/09 20:45:27 mglocker Exp $  */
d213 2
d220 1
@


1.10
log
@Add powerhooks.  Tested with a Netgear WG511v1 on my X40.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgtvar.h,v 1.9 2006/10/06 21:55:33 mglocker Exp $  */
a191 1
//		struct cv			sck_needed;
@


1.9
log
@Fix cardbus support for pgt(4).  Tested with a Netgear WG511.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgtvar.h,v 1.8 2006/10/02 18:06:55 mglocker Exp $  */
d181 2
d218 1
a218 2
int	pgt_detach(struct pgt_softc *sc);
void	pgt_reboot(struct pgt_softc *);
@


1.8
log
@Simplify device attachment.  From brad@@ with a tiny correction.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgtvar.h,v 1.7 2006/09/16 10:36:12 mglocker Exp $  */
d177 4
@


1.7
log
@Bring pgt(4) in a working state.  Much work also done by claudio@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$  */
a209 1
void	pgt_attachhook(void *);
d211 1
a211 1
int	pgt_attach(struct pgt_softc *);
@


1.6
log
@Some first cleanup run.

ok deraadt@@
@
text
@d1 20
a20 1
/*-
d47 30
a126 18
struct pgt_ieee80211_radiotap {
	struct ieee80211_radiotap_header	pir_header;
	uint8_t					pir_flags;
	uint8_t					pir_rate;
	uint16_t				pir_channel;
	uint16_t				pir_channel_flags;
	uint8_t					pir_db_antsignal;
	uint8_t					pir_db_antnoise;
};
#define	PGT_IEEE80211_RADIOTAP_PRESENT			\
	(1 << IEEE80211_RADIOTAP_FLAGS |		\
	    1 << IEEE80211_RADIOTAP_RATE |		\
	    1 << IEEE80211_RADIOTAP_CHANNEL |		\
	    1 << IEEE80211_RADIOTAP_DB_ANTSIGNAL |	\
	    1 << IEEE80211_RADIOTAP_DB_ANTNOISE)

struct bpf_if;

a129 1
	struct bpf_if          *sc_drvbpf;
a136 1
#define	SC_GONE			0x00000080 /* device did not come back */
d141 1
a149 5
	unsigned int		sc_refcnt;	/* # sleeping with sc */
//	struct cv		sc_critical_cv;
	struct thread	       *sc_critical_thread;  /* allow mgmt recursion */
	int			sc_critical;	/* -1- = mgmt < 0 < 1+ data */
	struct thread	       *sc_drainer;	/* who's doing removal/reset? */
a161 3
	struct resource	       *sc_intres;	/* interrupt resource */
	void		       *sc_intcookie;
	struct resource	       *sc_iores;	/* IO memory resource */
d165 1
a165 1
	//bus_dma_tag_t		sc_cbdmat;	/* control block DMA */
a167 1
	bus_addr_t		sc_cbdmabusaddr;
d169 1
a169 1
	//bus_dma_tag_t		sc_psmdmat;	/* power save buffer DMA */
a171 1
	bus_addr_t		sc_psmdmabusaddr;
d173 5
a177 1
	//bus_dma_tag_t		sc_fragdmat;	/* tags for all queues */
d183 1
a183 1
	struct bintime		sc_data_tx_started;
d190 18
a214 2
/* Load one seg into the bus_addr_t * arg. */
//void	pgt_load_busaddr(void *, bus_dma_segment_t *, int, int);
d247 2
@


1.5
log
@Do proper chipset identification.

ok deraadt@@
@
text
@d87 1
a87 1
#define	PFF_IEEE80211_RADIOTAP_PRESENT			\
a99 1
//	struct mtx		sc_lock;
d155 4
a158 4
	struct pgt_descq	sc_freeq[PFF_QUEUE_COUNT];
	size_t			sc_freeq_count[PFF_QUEUE_COUNT];
	struct pgt_descq	sc_dirtyq[PFF_QUEUE_COUNT];
	size_t			sc_dirtyq_count[PFF_QUEUE_COUNT];
d179 3
a181 3
	return (pq == PFF_QUEUE_DATA_LOW_RX ||
	    pq == PFF_QUEUE_DATA_HIGH_RX ||
	    pq == PFF_QUEUE_MGMT_RX);
d187 3
a189 3
	return (pq == PFF_QUEUE_DATA_LOW_TX ||
	    pq == PFF_QUEUE_DATA_HIGH_TX ||
	    pq == PFF_QUEUE_MGMT_TX);
d195 4
a198 4
	return (pq == PFF_QUEUE_DATA_LOW_RX ||
	    pq == PFF_QUEUE_DATA_HIGH_RX ||
	    pq == PFF_QUEUE_DATA_LOW_TX ||
	    pq == PFF_QUEUE_DATA_HIGH_TX);
d204 2
a205 2
	return (pq == PFF_QUEUE_MGMT_RX ||
	    pq == PFF_QUEUE_MGMT_TX);
@


1.4
log
@Get firmware loaded.

ok deraadt@@
@
text
@d112 1
a137 5
	enum pgt_dev_type {
		PFF_DEV_ISL3877,
		PFF_DEV_ISL3890,
		PFF_DEV_3COM6001
	}			sc_dev_type;
@


1.3
log
@Move DMA mapping code from if_pgt_pci.c to pgt.c and port it as is for now.
Remove dead code chunk from if_pgt_pci.c.

For those who want to refer to the original code you can find it in
~mglocker/pgt/orig.
@
text
@d173 1
d179 1
a179 1
void pgt_load_busaddr(void *, bus_dma_segment_t *, int, int);
@


1.2
log
@Add some first PCI glue.
@
text
@d37 1
d147 2
a148 1
	bus_dma_tag_t		sc_cbdmat;	/* control block DMA */
d150 1
d153 1
a153 1
	bus_dma_tag_t		sc_psmdmat;	/* power save buffer DMA */
d155 1
d158 1
a158 1
	bus_dma_tag_t		sc_fragdmat;	/* tags for all queues */
@


1.1
log
@Very initial import to support the PrismGT chipset (FullMAC for now).

ok deraadt@@
@
text
@d144 1
a144 1
	bus_space_tag_t		sc_iotag; 
d169 1
@

