head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.32
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.30
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.24
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.26
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.18
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.22
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.20
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.16
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.12
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.21.0.18
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.14
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.12
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.10
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.8
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.6
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.20.11.13.57;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.30.11.41.00;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.09.21.19.47;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.20.22.42.29;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.28.04.37.32;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.05.07.58.55;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.21.18.58.48;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.26.01.29.55;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.19.04.21.41;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.14.22.48.50;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.09.21.26.26;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.25.19.48.49;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.02.18.26.28;	author mickey;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.10.24.16.20.20;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.29.21.54.00;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.25.21.11.17;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.27.06.43.10;	author tholo;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.02.26.06.19.34;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.03.01.01.59;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.23.31;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.07.04.10.40.38;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@/*	$OpenBSD: anvar.h,v 1.22 2009/08/10 20:29:54 deraadt Exp $	*/
/*	$NetBSD: anvar.h,v 1.10 2005/02/27 00:27:00 perry Exp $	*/
/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/an/if_aironet_ieee.h,v 1.2 2000/11/13 23:04:12 wpaul Exp $
 */

#ifndef _DEV_IC_ANVAR_H
#define _DEV_IC_ANVAR_H

#define AN_TIMEOUT	65536
#define	AN_MAGIC	0x414e

/* The interrupts we will handle */
#define AN_INTRS	(AN_EV_RX | AN_EV_TX | AN_EV_TX_EXC | AN_EV_LINKSTAT)

/*
 * register space access macros
 */
#define CSR_WRITE_2(sc, reg, val)	\
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, reg, val)

#define CSR_READ_2(sc, reg)		\
	bus_space_read_2(sc->sc_iot, sc->sc_ioh, reg)

#ifndef __BUS_SPACE_HAS_STREAM_METHODS
#define bus_space_write_multi_stream_2	bus_space_write_multi_2
#define bus_space_read_multi_stream_2	bus_space_read_multi_2
#endif

#define CSR_WRITE_MULTI_STREAM_2(sc, reg, val, count)	\
	bus_space_write_multi_stream_2(sc->sc_iot, sc->sc_ioh, reg, val, count)
#define CSR_READ_MULTI_STREAM_2(sc, reg, buf, count)	\
	bus_space_read_multi_stream_2(sc->sc_iot, sc->sc_ioh, reg, buf, count)

#define	AN_TX_MAX_LEN		\
		(sizeof(struct an_txframe) + ETHER_TYPE_LEN + ETHER_MAX_LEN)
#define AN_TX_RING_CNT		4
#define AN_INC(x, y)		(x) = (x + 1) % y

struct an_wepkey {
	int			an_wep_key[16];
	int			an_wep_keylen;
};

#define	AN_GAPLEN_MAX	8

#define AN_RX_RADIOTAP_PRESENT	((1 << IEEE80211_RADIOTAP_FLAGS) | \
				 (1 << IEEE80211_RADIOTAP_RATE) | \
				 (1 << IEEE80211_RADIOTAP_CHANNEL) | \
				 (1 << IEEE80211_RADIOTAP_DB_ANTSIGNAL))

struct an_rx_radiotap_header {
	struct ieee80211_radiotap_header	ar_ihdr;
	u_int8_t				ar_flags;
	u_int8_t				ar_rate;
	u_int16_t				ar_chan_freq;
	u_int16_t				ar_chan_flags;
	int8_t					ar_antsignal;
} __packed;

#define AN_TX_RADIOTAP_PRESENT	((1 << IEEE80211_RADIOTAP_FLAGS) | \
				 (1 << IEEE80211_RADIOTAP_RATE) | \
				 (1 << IEEE80211_RADIOTAP_CHANNEL))

struct an_tx_radiotap_header {
	struct ieee80211_radiotap_header	at_ihdr;
	u_int8_t				at_flags;
	u_int8_t				at_rate;
	u_int16_t				at_chan_freq;
	u_int16_t				at_chan_flags;
} __packed;


struct an_softc	{
	struct device		sc_dev;
	struct ieee80211com	sc_ic;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	void			*sc_ih;
	int			(*sc_enable)(struct an_softc *);
	void			(*sc_disable)(struct an_softc *);
	int			(*sc_newstate)(struct ieee80211com *,
				    enum ieee80211_state, int);

	int			sc_enabled;
	int			sc_invalid;
	int			sc_attached;

	int			sc_bap_id;
	int			sc_bap_off;

	int			sc_use_leap;
	struct an_wepkey 	sc_wepkeys[IEEE80211_WEP_NKID];
	int			sc_perskeylen[IEEE80211_WEP_NKID];
	int			sc_tx_key;
	int			sc_tx_perskey;
	int			sc_tx_timer;
	struct an_txdesc {
		int		d_fid;
		int		d_inuse;
	}			sc_txd[AN_TX_RING_CNT];
	int			sc_txnext;
	int			sc_txcur;

	struct an_rid_genconfig	sc_config;
	struct an_rid_caps	sc_caps;
	union {
		u_int16_t		sc_val[1];
		u_int8_t		sc_txbuf[AN_TX_MAX_LEN];
		struct an_rid_ssidlist	sc_ssidlist;
		struct an_rid_aplist	sc_aplist;
		struct an_rid_status	sc_status;
		struct an_rid_wepkey	sc_wepkey;
		struct an_rid_leapkey	sc_leapkey;
		struct an_rid_encap	sc_encap;
	}			sc_buf;

	caddr_t			sc_drvbpf;
	union {
		struct an_rx_radiotap_header	tap;
		u_int8_t			pad[64];
	} sc_rxtapu;
	union {
		struct an_tx_radiotap_header	tap;
		u_int8_t			pad[64];
	} sc_txtapu;
};

#define sc_rxtap	sc_rxtapu.tap
#define sc_txtap	sc_txtapu.tap

int	an_attach(struct an_softc *);
int	an_detach(struct an_softc *);
int	an_activate(struct device *, int);
void	an_power(int, void *);
int	an_intr(void *);
int	an_init(struct ifnet *);
void	an_stop(struct ifnet *, int);

#endif	/* _DEV_IC_ANVAR_H */
@


1.22
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.21 2006/02/20 11:13:57 jsg Exp $	*/
d164 1
a164 1
int	an_activate(struct device *, enum devact);
@


1.21
log
@Be sure to call shutdownhook_disestablish() as this is a removeable device.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.20 2006/01/30 11:41:00 jsg Exp $	*/
a117 2
	void			*sc_sdhook;

a165 1
void	an_shutdown(void *);
@


1.20
log
@Add basic radiotap support.  Modelled somewhat after
ral and NetBSD wi radiotap.
"looks ok" damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.19 2006/01/09 21:19:47 jsg Exp $	*/
d118 2
@


1.19
log
@Move an(4) to a driver based on the NetBSD one.
This brings net80211 support and support for newer hardware.
In addition ancontrol is no longer needed.

This driver does not yet work on big endian archs like the previous
one did.

"do it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 27
d147 10
d158 3
@


1.18
log
@Replace arpcom in the softc with ieee80211com in preparation for
further net80211 changes. ok mickey@@
@
text
@d1 2
a2 2
/*	$OpenBSD: anvar.h,v 1.17 2004/09/28 04:37:32 brad Exp $	*/

d34 1
a34 1
 * $FreeBSD: src/sys/dev/an/if_aironet_ieee.h,v 1.1 2000/01/14 20:40:55 wpaul Exp $
d37 5
a41 2
#ifndef _IF_AIRONET_IEEE_H
#define _IF_AIRONET_IEEE_H
d43 2
a44 1
#pragma pack(1)
d47 1
a47 5
 * This header defines a simple command interface to the FreeBSD
 * Aironet driver (an) driver, which is used to set certain
 * device-specific parameters which can't be easily managed through
 * ifconfig(8). No, sysctl(2) is not the answer. I said a _simple_
 * interface, didn't I.
d49 2
d52 2
a53 7
#ifndef SIOCSAIRONET
#ifdef __FreeBSD__
#define SIOCSAIRONET	SIOCSIFGENERIC
#else   /* !__FreeBSD__ */
#define SIOCSAIRONET	SIOCSIFASYNCMAP
#endif
#endif
d55 3
a57 6
#ifndef SIOCGAIRONET
#ifdef __FreeBSD__
#define SIOCGAIRONET	SIOCGIFGENERIC
#else   /* !__FreeBSD__ */
#define SIOCGAIRONET	SIOCGIFASYNCMAP
#endif
d60 4
a63 5
/*
 * This is a make-predend RID value used only by the driver
 * to allow the user to set the speed.
 */
#define AN_RID_TX_SPEED		0x1234
d65 4
a68 7
/*
 * Technically I don't think there's a limit to a record
 * length. The largest record is the one that contains the CIS
 * data, which is 240 words long, so 256 should be a safe
 * value.
 */
#define AN_MAX_DATALEN	512
d70 3
a72 4
struct an_req {
	u_int16_t	an_len;
	u_int16_t	an_type;
	u_int16_t	an_val[AN_MAX_DATALEN];
d75 1
a75 551
/*
 * Private LTV records (interpreted only by the driver). This is
 * a minor kludge to allow reading the interface statistics from
 * the driver.
 */
#define AN_RID_IFACE_STATS	0x0100
#define AN_RID_MGMT_XMIT	0x0200
#define AN_RID_ZERO_CACHE	0x0300
#define AN_RID_READ_CACHE	0x0400

struct an_80211_hdr {
	u_int16_t		frame_ctl;
	u_int16_t		dur_id;
	u_int8_t		addr1[6];
	u_int8_t		addr2[6];
	u_int8_t		addr3[6];
	u_int16_t		seq_ctl;
	u_int8_t		addr4[6];
};

#define AN_FCTL_VERS		0x0002
#define AN_FCTL_FTYPE		0x000C
#define AN_FCTL_STYPE		0x00F0
#define AN_FCTL_TODS		0x0100
#define AN_FCTL_FROMDS		0x0200
#define AN_FCTL_MOREFRAGS	0x0400
#define AN_FCTL_RETRY		0x0800
#define AN_FCTL_PM		0x1000
#define AN_FCTL_MOREDATA	0x2000
#define AN_FCTL_WEP		0x4000
#define AN_FCTL_ORDER		0x8000

#define AN_FTYPE_MGMT		0x0000
#define AN_FTYPE_CTL		0x0004
#define AN_FTYPE_DATA		0x0008

#define AN_STYPE_MGMT_ASREQ	0x0000	/* association request */
#define AN_STYPE_MGMT_ASRESP	0x0010	/* association response */
#define AN_STYPE_MGMT_REASREQ	0x0020	/* reassociation request */
#define AN_STYPE_MGMT_REASRESP	0x0030	/* reassociation response */
#define AN_STYPE_MGMT_PROBEREQ	0x0040	/* probe request */
#define AN_STYPE_MGMT_PROBERESP	0x0050	/* probe response */
#define AN_STYPE_MGMT_BEACON	0x0080	/* beacon */
#define AN_STYPE_MGMT_ATIM	0x0090	/* announcement traffic ind msg */
#define AN_STYPE_MGMT_DISAS	0x00A0	/* disassociation */
#define AN_STYPE_MGMT_AUTH	0x00B0	/* authentication */
#define AN_STYPE_MGMT_DEAUTH	0x00C0	/* deauthentication */

struct an_mgmt_hdr {
	u_int16_t		frame_ctl;
	u_int16_t		duration;
	u_int8_t		dst_addr[6];
	u_int8_t		src_addr[6];
	u_int8_t		bssid[6];
	u_int16_t		seq_ctl;
};

/*
 * Aironet IEEE signal strength cache
 *
 * driver keeps cache of last
 * MAXANCACHE packets to arrive including signal strength info.
 * daemons may read this via ioctl
 *
 * Each entry in the wi_sigcache has a unique macsrc.
 */
#define MAXANCACHE      16

struct an_sigcache {
	u_int8_t  macsrc[6];	/* unique MAC address for entry */
	u_int16_t signal;	/* quality of the packet */
	u_int32_t ipsrc;	/* ip address associated with packet */
};

struct an_ltv_key {
	u_int16_t		an_len;
	u_int16_t		an_type;
	u_int16_t		kindex;
	u_int8_t		mac[6];
	u_int16_t		klen;
	u_int8_t		key[16];
};

/*
 * Grrr. The manual says the statistics record is 384 bytes in length,
 * but the card says the record is 404 bytes. There's some padding left
 * at the end of this structure to account for any discrepancies.
 */
struct an_ltv_stats {
	u_int16_t		an_fudge;
	u_int16_t		an_len;			/* 0x00 */
	u_int16_t		an_type;		/* 0xXX */
	u_int16_t		an_spacer;		/* 0x02 */
	u_int32_t		an_rx_overruns;		/* 0x04 */
	u_int32_t		an_rx_plcp_csum_errs;	/* 0x08 */
	u_int32_t		an_rx_plcp_format_errs;	/* 0x0C */
	u_int32_t		an_rx_plcp_len_errs;	/* 0x10 */
	u_int32_t		an_rx_mac_crc_errs;	/* 0x14 */
	u_int32_t		an_rx_mac_crc_ok;	/* 0x18 */
	u_int32_t		an_rx_wep_errs;		/* 0x1C */
	u_int32_t		an_rx_wep_ok;		/* 0x20 */
	u_int32_t		an_retry_long;		/* 0x24 */
	u_int32_t		an_retry_short;		/* 0x28 */
	u_int32_t		an_retry_max;		/* 0x2C */
	u_int32_t		an_no_ack;		/* 0x30 */
	u_int32_t		an_no_cts;		/* 0x34 */
	u_int32_t		an_rx_ack_ok;		/* 0x38 */
	u_int32_t		an_rx_cts_ok;		/* 0x3C */
	u_int32_t		an_tx_ack_ok;		/* 0x40 */
	u_int32_t		an_tx_rts_ok;		/* 0x44 */
	u_int32_t		an_tx_cts_ok;		/* 0x48 */
	u_int32_t		an_tx_lmac_mcasts;	/* 0x4C */
	u_int32_t		an_tx_lmac_bcasts;	/* 0x50 */
	u_int32_t		an_tx_lmac_ucast_frags;	/* 0x54 */
	u_int32_t		an_tx_lmac_ucasts;	/* 0x58 */
	u_int32_t		an_tx_beacons;		/* 0x5C */
	u_int32_t		an_rx_beacons;		/* 0x60 */
	u_int32_t		an_tx_single_cols;	/* 0x64 */
	u_int32_t		an_tx_multi_cols;	/* 0x68 */
	u_int32_t		an_tx_defers_no;	/* 0x6C */
	u_int32_t		an_tx_defers_prot;	/* 0x70 */
	u_int32_t		an_tx_defers_energy;	/* 0x74 */
	u_int32_t		an_rx_dups;		/* 0x78 */
	u_int32_t		an_rx_partial;		/* 0x7C */
	u_int32_t		an_tx_too_old;		/* 0x80 */
	u_int32_t		an_rx_too_old;		/* 0x84 */
	u_int32_t		an_lostsync_max_retries;/* 0x88 */
	u_int32_t		an_lostsync_missed_beacons;/* 0x8C */
	u_int32_t		an_lostsync_arl_exceeded;/*0x90 */
	u_int32_t		an_lostsync_deauthed;	/* 0x94 */
	u_int32_t		an_lostsync_disassociated;/*0x98 */
	u_int32_t		an_lostsync_tsf_timing;	/* 0x9C */
	u_int32_t		an_tx_host_mcasts;	/* 0xA0 */
	u_int32_t		an_tx_host_bcasts;	/* 0xA4 */
	u_int32_t		an_tx_host_ucasts;	/* 0xA8 */
	u_int32_t		an_tx_host_failed;	/* 0xAC */
	u_int32_t		an_rx_host_mcasts;	/* 0xB0 */
	u_int32_t		an_rx_host_bcasts;	/* 0xB4 */
	u_int32_t		an_rx_host_ucasts;	/* 0xB8 */
	u_int32_t		an_rx_host_discarded;	/* 0xBC */
	u_int32_t		an_tx_hmac_mcasts;	/* 0xC0 */
	u_int32_t		an_tx_hmac_bcasts;	/* 0xC4 */
	u_int32_t		an_tx_hmac_ucasts;	/* 0xC8 */
	u_int32_t		an_tx_hmac_failed;	/* 0xCC */
	u_int32_t		an_rx_hmac_mcasts;	/* 0xD0 */
	u_int32_t		an_rx_hmac_bcasts;	/* 0xD4 */
	u_int32_t		an_rx_hmac_ucasts;	/* 0xD8 */
	u_int32_t		an_rx_hmac_discarded;	/* 0xDC */
	u_int32_t		an_tx_hmac_accepted;	/* 0xE0 */
	u_int32_t		an_ssid_mismatches;	/* 0xE4 */
	u_int32_t		an_ap_mismatches;	/* 0xE8 */
	u_int32_t		an_rates_mismatches;	/* 0xEC */
	u_int32_t		an_auth_rejects;	/* 0xF0 */
	u_int32_t		an_auth_timeouts;	/* 0xF4 */
	u_int32_t		an_assoc_rejects;	/* 0xF8 */
	u_int32_t		an_assoc_timeouts;	/* 0xFC */
	u_int32_t		an_reason_outside_table;/* 0x100 */
	u_int32_t		an_reason1;		/* 0x104 */
	u_int32_t		an_reason2;		/* 0x108 */
	u_int32_t		an_reason3;		/* 0x10C */
	u_int32_t		an_reason4;		/* 0x110 */
	u_int32_t		an_reason5;		/* 0x114 */
	u_int32_t		an_reason6;		/* 0x118 */
	u_int32_t		an_reason7;		/* 0x11C */
	u_int32_t		an_reason8;		/* 0x120 */
	u_int32_t		an_reason9;		/* 0x124 */
	u_int32_t		an_reason10;		/* 0x128 */
	u_int32_t		an_reason11;		/* 0x12C */
	u_int32_t		an_reason12;		/* 0x130 */
	u_int32_t		an_reason13;		/* 0x134 */
	u_int32_t		an_reason14;		/* 0x138 */
	u_int32_t		an_reason15;		/* 0x13C */
	u_int32_t		an_reason16;		/* 0x140 */
	u_int32_t		an_reason17;		/* 0x144 */
	u_int32_t		an_reason18;		/* 0x148 */
	u_int32_t		an_reason19;		/* 0x14C */
	u_int32_t		an_rx_mgmt_pkts;	/* 0x150 */
	u_int32_t		an_tx_mgmt_pkts;	/* 0x154 */
	u_int32_t		an_rx_refresh_pkts;	/* 0x158 */
	u_int32_t		an_tx_refresh_pkts;	/* 0x15C */
	u_int32_t		an_rx_poll_pkts;	/* 0x160 */
	u_int32_t		an_tx_poll_pkts;	/* 0x164 */
	u_int32_t		an_host_retries;	/* 0x168 */
	u_int32_t		an_lostsync_hostreq;	/* 0x16C */
	u_int32_t		an_host_tx_bytes;	/* 0x170 */
	u_int32_t		an_host_rx_bytes;	/* 0x174 */
	u_int32_t		an_uptime_usecs;	/* 0x178 */
	u_int32_t		an_uptime_secs;		/* 0x17C */
	u_int32_t		an_lostsync_better_ap;	/* 0x180 */
};

struct an_ltv_genconfig {
	/* General configuration. */
	u_int16_t		an_len;			/* 0x00 */
	u_int16_t		an_type;		/* XXXX */
	u_int16_t		an_opmode;		/* 0x02 */
	u_int16_t		an_rxmode;		/* 0x04 */
	u_int16_t		an_fragthresh;		/* 0x06 */
	u_int16_t		an_rtsthresh;		/* 0x08 */
	u_int8_t		an_macaddr[6];		/* 0x0A */
	u_int8_t		an_rates[8];		/* 0x10 */
	u_int16_t		an_shortretry_limit;	/* 0x18 */
	u_int16_t		an_longretry_limit;	/* 0x1A */
	u_int16_t		an_tx_msdu_lifetime;	/* 0x1C */
	u_int16_t		an_rx_msdu_lifetime;	/* 0x1E */
	u_int16_t		an_stationary;		/* 0x20 */
	u_int16_t		an_ordering;		/* 0x22 */
	u_int16_t		an_devtype;		/* 0x24 */
	u_int16_t		an_rsvd0[5];		/* 0x26 */
	/* Scanning associating. */
	u_int16_t		an_scanmode;		/* 0x30 */
	u_int16_t		an_probedelay;		/* 0x32 */
	u_int16_t		an_probe_energy_timeout;/* 0x34 */
	u_int16_t		an_probe_response_timeout;/*0x36 */
	u_int16_t		an_beacon_listen_timeout;/*0x38 */
	u_int16_t		an_ibss_join_net_timeout;/*0x3A */
	u_int16_t		an_auth_timeout;	/* 0x3C */
	u_int16_t		an_authtype;		/* 0x3E */
	u_int16_t		an_assoc_timeout;	/* 0x40 */
	u_int16_t		an_specified_ap_timeout;/* 0x42 */
	u_int16_t		an_offline_scan_interval;/*0x44 */
	u_int16_t		an_offline_scan_duration;/*0x46 */
	u_int16_t		an_link_loss_delay;	/* 0x48 */
	u_int16_t		an_max_beacon_lost_time;/* 0x4A */
	u_int16_t		an_refresh_interval;	/* 0x4C */
	u_int16_t		an_rsvd1;		/* 0x4E */
	/* Power save operation */
	u_int16_t		an_psave_mode;		/* 0x50 */
	u_int16_t		an_sleep_for_dtims;	/* 0x52 */
	u_int16_t		an_listen_interval;	/* 0x54 */
	u_int16_t		an_fast_listen_interval;/* 0x56 */
	u_int16_t		an_listen_decay;	/* 0x58 */
	u_int16_t		an_fast_listen_decay;	/* 0x5A */
	u_int16_t		an_rsvd2[2];		/* 0x5C */
	/* Ad-hoc (or AP) operation. */
	u_int16_t		an_beacon_period;	/* 0x60 */
	u_int16_t		an_atim_duration;	/* 0x62 */
	u_int16_t		an_rsvd3;		/* 0x64 */
	u_int16_t		an_ds_channel;		/* 0x66 */
	u_int16_t		an_rsvd4;		/* 0x68 */
	u_int16_t		an_dtim_period;		/* 0x6A */
	u_int16_t		an_rsvd5[2];		/* 0x6C */
	/* Radio operation. */
	u_int16_t		an_radiotype;		/* 0x70 */
	u_int16_t		an_diversity;		/* 0x72 */
	u_int16_t		an_tx_power;		/* 0x74 */
	u_int16_t		an_rss_thresh;		/* 0x76 */
	u_int16_t		an_modulation_type;	/* 0x78 */
	u_int16_t		an_short_preamble;	/* 0x7A */
	u_int16_t		an_home_product;	/* 0x7C */
	u_int16_t		an_rsvd6;		/* 0x7E */
	/* Aironet extensions. */
	u_int8_t		an_nodename[16];	/* 0x80 */
	u_int16_t		an_arl_thresh;		/* 0x90 */
	u_int16_t		an_arl_decay;		/* 0x92 */
	u_int16_t		an_arl_delay;		/* 0x94 */
	u_int8_t		an_rsvd7;		/* 0x96 */
	u_int8_t		an_rsvd8;		/* 0x97 */
	u_int8_t		an_magic_packet_action;	/* 0x98 */
	u_int8_t		an_magic_packet_ctl;	/* 0x99 */
	u_int16_t		an_rsvd9[2];		/* 0x9a */
};

#define AN_OPMODE_IBSS_ADHOC			0x0000
#define AN_OPMODE_INFRASTRUCTURE_STATION	0x0001
#define AN_OPMODE_AP				0x0002
#define AN_OPMODE_AP_REPEATER			0x0003
#define AN_OPMODE_UNMODIFIED_PAYLOAD		0x0100
#define AN_OPMODE_AIRONET_EXTENSIONS		0x0200
#define AN_OPMODE_AP_EXTENSIONS			0x0400

#define AN_RXMODE_BC_MC_ADDR			0x0000
#define AN_RXMODE_BC_ADDR			0x0001
#define AN_RXMODE_ADDR				0x0002
#define AN_RXMODE_80211_MONITOR_CURBSS		0x0003
#define AN_RXMODE_80211_MONITOR_ANYBSS		0x0004
#define AN_RXMODE_LAN_MONITOR_CURBSS		0x0005
#define AN_RXMODE_NO_8023_HEADER		0x0100

#define AN_RATE_1MBPS				0x0002
#define AN_RATE_2MBPS				0x0004
#define AN_RATE_5_5MBPS				0x000B
#define AN_RATE_11MBPS				0x0016

#define AN_DEVTYPE_PC4500			0x0065
#define AN_DEVTYPE_PC4800			0x006D

#define AN_SCANMODE_ACTIVE			0x0000
#define AN_SCANMODE_PASSIVE			0x0001
#define AN_SCANMODE_AIRONET_ACTIVE		0x0002

#define AN_AUTHTYPE_NONE			0x0000
#define AN_AUTHTYPE_OPEN			0x0001
#define AN_AUTHTYPE_SHAREDKEY			0x0002
#define AN_AUTHTYPE_MASK			0x00FF
#define AN_AUTHTYPE_PRIVACY_IN_USE		0x0100
#define AN_AUTHTYPE_ALLOW_UNENCRYPTED		0x0200

#define AN_PSAVE_NONE				0x0000
#define AN_PSAVE_CAM				0x0001
#define AN_PSAVE_PSP				0x0002
#define AN_PSAVE_PSP_CAM			0x0003

#define AN_RADIOTYPE_80211_FH			0x0001
#define AN_RADIOTYPE_80211_DS			0x0002
#define AN_RADIOTYPE_LM2000_DS			0x0004

#define AN_DIVERSITY_FACTORY_DEFAULT		0x0000
#define AN_DIVERSITY_ANTENNA_1_ONLY		0x0001
#define AN_DIVERSITY_ANTENNA_2_ONLY		0x0002
#define AN_DIVERSITY_ANTENNA_1_AND_2		0x0003

#define AN_TXPOWER_FACTORY_DEFAULT		0x0000
#define AN_TXPOWER_50MW				50
#define AN_TXPOWER_100MW			100
#define AN_TXPOWER_250MW			250

/*
 * Valid SSID list. You can specify up to three SSIDs denoting
 * the service sets that you want to join. The first SSID always
 * defaults to "tsunami" which is a handy way to detect the
 * card.
 */
struct an_ltv_ssidlist {
	u_int16_t		an_len;
	u_int16_t		an_type;
	u_int16_t		an_ssid1_len;
	char			an_ssid1[32];
	u_int16_t		an_ssid2_len;
	char			an_ssid2[32];
	u_int16_t		an_ssid3_len;
	char			an_ssid3[32];
};

/*
 * Valid AP list.
 */
struct an_ltv_aplist {
	u_int16_t		an_len;
	u_int16_t		an_type;
	u_int8_t		an_ap1[8];
	u_int8_t		an_ap2[8];
	u_int8_t		an_ap3[8];
	u_int8_t		an_ap4[8];
};

/*
 * Driver name.
 */
struct an_ltv_drvname {
	u_int16_t		an_len;
	u_int16_t		an_type;
	u_int8_t		an_drvname[16];
};

/*
 * Frame encapsulation.
 */
struct an_rid_encap {
	u_int16_t		an_len;
	u_int16_t		an_type;
	u_int16_t		an_ethertype_default;
	u_int16_t		an_action_default;
	u_int16_t		an_ethertype0;
	u_int16_t		an_action0;
	u_int16_t		an_ethertype1;
	u_int16_t		an_action1;
	u_int16_t		an_ethertype2;
	u_int16_t		an_action2;
	u_int16_t		an_ethertype3;
	u_int16_t		an_action3;
	u_int16_t		an_ethertype4;
	u_int16_t		an_action4;
	u_int16_t		an_ethertype5;
	u_int16_t		an_action5;
	u_int16_t		an_ethertype6;
	u_int16_t		an_action6;
};

#define AN_ENCAP_ACTION_RX	0x0001
#define AN_ENCAP_ACTION_TX	0x0002

#define AN_RXENCAP_NONE		0x0000
#define AN_RXENCAP_RFC1024	0x0001

#define AN_TXENCAP_RFC1024	0x0000
#define AN_TXENCAP_80211	0x0002

/*
 * Card capabilities (read only).
 */
struct an_ltv_caps {
	u_int16_t		an_len;			/* 0x00 */
	u_int16_t		an_type;		/* XXXX */
	u_int8_t		an_oui[3];		/* 0x02 */
	u_int8_t		an_rsvd0;		/* 0x05 */
	u_int16_t		an_prodnum;		/* 0x06 */
	u_int8_t		an_manufname[32];	/* 0x08 */
	u_int8_t		an_prodname[16];	/* 0x28 */
	u_int8_t		an_prodvers[8];		/* 0x38 */
	u_int8_t		an_oemaddr[6];		/* 0x40 */
	u_int8_t		an_aironetaddr[6];	/* 0x46 */
	u_int16_t		an_radiotype;		/* 0x4C */
	u_int16_t		an_regdomain;		/* 0x4E */
	u_int8_t		an_callid[6];		/* 0x50 */
	u_int8_t		an_rates[8];		/* 0x56 */
	u_int8_t		an_rx_diversity;	/* 0x5E */
	u_int8_t		an_tx_diversity;	/* 0x5F */
	u_int16_t		an_tx_powerlevels[8];	/* 0x60 */
	u_int16_t		an_hwrev;		/* 0x70 */
	u_int16_t		an_hwcaps;		/* 0x72 */
	u_int16_t		an_temprange;		/* 0x74 */
	u_int16_t		an_fwrev;		/* 0x76 */
	u_int16_t		an_fwsubrev;		/* 0x78 */
	u_int16_t		an_ifacerev;		/* 0x7A */
	u_int16_t		an_softcaps;		/* 0x7C */
	u_int16_t		an_bootblockrev;	/* 0x7E */
	u_int16_t		an_req_hw_support;	/* 0x80 */
};

/*
 * Access point (read only)
 */
struct an_ltv_apinfo {
	u_int16_t		an_len;
	u_int16_t		an_type;
	u_int16_t		an_tim_addr;
	u_int16_t		an_airo_addr;
};

/*
 * Radio info (read only).
 */
struct an_ltv_radioinfo {
	u_int16_t		an_len;
	u_int16_t		an_type;
	/* ??? */
};

/*
 * Status (read only). Note: the manual claims this RID is 108 bytes
 * long (0x6A is the last datum, which is 2 bytes long) however when
 * this RID is read from the NIC, it returns a length of 110. To be
 * on the safe side, this structure is padded with an extra 16-bit
 * word. (There is a misprint in the manual which says the macaddr
 * field is 8 bytes long.)
 *
 * Also, the channel_set and current_channel fields appear to be
 * reversed. Either that, or the hop_period field is unused.
 */
struct an_ltv_status {
	u_int16_t		an_len;			/* 0x00 */
	u_int16_t		an_type;		/* 0xXX */
	u_int8_t		an_macaddr[6];		/* 0x02 */
	u_int16_t		an_opmode;		/* 0x08 */
	u_int16_t		an_errcode;		/* 0x0A */
	u_int16_t		an_cur_signal_strength;	/* 0x0C */
	u_int16_t		an_ssidlen;		/* 0x0E */
	u_int8_t		an_ssid[32];		/* 0x10 */
	u_int8_t		an_ap_name[16];		/* 0x30 */
	u_int8_t		an_cur_bssid[6];	/* 0x40 */
	u_int8_t		an_prev_bssid1[6];	/* 0x46 */
	u_int8_t		an_prev_bssid2[6];	/* 0x4C */
	u_int8_t		an_prev_bssid3[6];	/* 0x52 */
	u_int16_t		an_beacon_period;	/* 0x58 */
	u_int16_t		an_dtim_period;		/* 0x5A */
	u_int16_t		an_atim_duration;	/* 0x5C */
	u_int16_t		an_hop_period;		/* 0x5E */
	u_int16_t		an_cur_channel;		/* 0x62 */
	u_int16_t		an_channel_set;		/* 0x60 */
	u_int16_t		an_hops_to_backbone;	/* 0x64 */
	u_int16_t		an_ap_total_load;	/* 0x66 */
	u_int16_t		an_our_generated_load;	/* 0x68 */
	u_int16_t		an_accumulated_arl;	/* 0x6A */
	u_int16_t		an_cur_signal_quality;	/* 0x6C */
	u_int16_t		an_current_tx_rate;	/* 0x6E */
	u_int16_t		an_ap_device;		/* 0x70 */
	u_int16_t		an_normalized_rssi;	/* 0x72 */
	u_int16_t		an_short_pre_in_use;	/* 0x74 */
	u_int8_t		an_ap_ip_addr[4];	/* 0x76 */
	u_int16_t		an_max_noise_prev_sec;	/* 0x7A */
	u_int16_t		an_avg_noise_prev_min;	/* 0x7C */
	u_int16_t		an_max_noise_prev_min;	/* 0x7E */
	u_int16_t		an_spare[5];		/* 0x80 */
};

#define AN_STATUS_OPMODE_CONFIGURED		0x0001
#define AN_STATUS_OPMODE_MAC_ENABLED		0x0002
#define AN_STATUS_OPMODE_RX_ENABLED		0x0004
#define AN_STATUS_OPMODE_IN_SYNC		0x0010
#define AN_STATUS_OPMODE_ASSOCIATED		0x0020
#define AN_STATUS_OPMODE_ERROR			0x8000

/*
 * WEP config
 */
struct an_ltv_wepkey {
	u_int16_t		an_len;			/* 0x00 */
	u_int16_t		an_type;		/* 0xXX */
	u_int16_t		an_key_index;		/* 0x02 */
	u_int8_t		an_mac_addr[6];		/* 0x04 */
	u_int16_t		an_key_len;		/* 0x0A */
	u_int8_t		an_key[13];		/* 0x0C */
};

/*
 * These are all the LTV record types that we can read or write
 * from the Aironet. Not all of them are tremendously useful, but I
 * list as many as I know about here for completeness.
 */

#pragma pack()

/*
 * Configuration (read/write)
 */
#define AN_RID_GENCONFIG	0xFF10	/* General configuration info */
#define AN_RID_SSIDLIST		0xFF11	/* Valid SSID list */
#define AN_RID_APLIST		0xFF12	/* Valid AP list */
#define AN_RID_DRVNAME		0xFF13	/* ID name of this node for diag */
#define AN_RID_ENCAP		0xFF14	/* Payload encapsulation type */
#define AN_RID_WEP_VOLATILE	0xFF15	/* Temporary WEP key configuration */
#define AN_RID_WEP_PERMANENT	0xFF16	/* Permanent WEP key configuration */
#define AN_RID_ACTUALCFG	0xFF20	/* Current configuration settings */

/*
 * Reporting (read only)
 */
#define AN_RID_CAPABILITIES	0xFF00	/* PC 4500/4800 capabilities */
#define AN_RID_APINFO		0xFF01	/* Access point info */
#define AN_RID_RADIOINFO	0xFF02	/* Radio info */
#define AN_RID_STATUS		0xFF50	/* Current status info */

/*
 * Statistics
 */
#define AN_RID_16BITS_CUM	0xFF60	/* Cumulative 16-bit stats counters */
#define AN_RID_16BITS_DELTA	0xFF61	/* 16-bit stats (since last clear) */
#define AN_RID_16BITS_DELTACLR	0xFF62	/* 16-bit stats, clear on read */
#define AN_RID_32BITS_CUM	0xFF68	/* Cumulative 32-bit stats counters */
#define AN_RID_32BITS_DELTA	0xFF69	/* 32-bit stats (since last clear) */
#define AN_RID_32BITS_DELTACLR	0xFF6A	/* 32-bit stats, clear on read */

#ifdef _KERNEL
#define AN_TX_RING_CNT	4
struct an_tx_ring_data {
	u_int16_t	an_tx_fids[AN_TX_RING_CNT];
	u_int16_t	an_tx_ring[AN_TX_RING_CNT];
	int		an_tx_prod;
	int		an_tx_cons;
};
d78 42
a119 30
	struct device	sc_dev;
	int	noise;		/* noise value */
	struct ieee80211com sc_ic;
	struct ifmedia	an_ifmedia;
	void		*sc_ih;
	struct timeout	an_stat_ch;

	bus_space_tag_t		an_btag;
	bus_space_handle_t	an_bhandle;

	struct an_ltv_genconfig	an_config;
	struct an_ltv_caps	an_caps;
	struct an_ltv_ssidlist	an_ssidlist;
	struct an_ltv_aplist	an_aplist;
	int			an_tx_rate;
	int			an_rxmode;
	int			an_gone;
	int			an_if_flags;
	u_int8_t		an_txbuf[ETHER_MAX_DIX_LEN];
	struct an_tx_ring_data	an_rdata;
	struct an_ltv_stats	an_stats;
	struct an_ltv_status	an_status;
	u_int8_t		an_associated;

	/* ANCACHE stuff */
	int			an_cache_iponly;
	int			an_cache_mcastonly;
	int			an_sigitems;
	struct an_sigcache	an_sigcache[MAXANCACHE];
	int			an_nextitem;
d122 4
a125 5
void	an_release_resources(struct device *);
int	an_alloc_port(struct device *, int, int);
int	an_alloc_memory(struct device *, int, int);
int	an_alloc_irq(struct device *, int, int);
int	an_probe(struct device *);
a126 3
int	an_attach(struct an_softc *);
void	an_init(struct an_softc *);
void	an_stop(struct an_softc *);
d128 2
a129 1
#endif
d131 1
a131 1
#endif
@


1.17
log
@Use ETHER_MAX_DIX_LEN/ETHER_MIN_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.16 2004/08/05 07:58:55 mickey Exp $	*/
d641 1
a641 1
	struct arpcom	sc_arpcom;
@


1.16
log
@allocate a cluster on rx after all possible failures had been checked for; repair sigcache misalignment
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.15 2003/10/21 18:58:48 jmc Exp $	*/
d657 1
a657 1
	u_int8_t		an_txbuf[1536];
@


1.15
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.14 2003/09/26 01:29:55 mickey Exp $	*/
d152 1
a152 1
#define MAXANCACHE      10
d155 3
a157 5
	char	macsrc[6];	/* unique MAC address for entry */
	int	ipsrc;		/* ip address associated with packet */
	int	signal;		/* signal strength of the packet */
	int	noise;		/* noise value */
	int	quality;	/* quality of the packet */
d640 1
@


1.14
log
@reading the record skip the remainder of data we do not need. we are still screwed on writes though
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.13 2003/08/19 04:21:41 mickey Exp $	*/
d595 1
a595 1
 * from the Aironet. Not all of them are temendously useful, but I
@


1.13
log
@pad some records some more; from Jon Olsson <jon@@abc.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.12 2003/07/14 22:48:50 mickey Exp $	*/
a276 1
	u_int32_t		an_rsvd[10];
a505 1
	u_int16_t		an_rsvd1[21];		/* 0x82 */
@


1.12
log
@uptimes in secs and usecs seem to be swapped w/ each other; also confirmed by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.11 2002/06/09 03:14:18 todd Exp $	*/
d349 1
a349 1
	u_int16_t		an_rsvd9;
d507 1
a507 1
	u_int16_t		an_rsvd1;		/* 0x82 */
@


1.11
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.10 2002/05/09 21:26:26 mickey Exp $	*/
d274 2
a275 2
	u_int32_t		an_uptime_secs;		/* 0x178 */
	u_int32_t		an_uptime_usecs;	/* 0x17C */
@


1.10
log
@an_ltv_caps has some more fluff at the tail (exatly 16bit more fluff); reported by xyntrix@@bitz.org
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.9 2002/03/25 19:48:49 mickey Exp $	*/
d644 1
a644 1
	struct arpcom	arpcom;
@


1.9
log
@some fw versions return even more data in the an_ltv_status; form Gabriel Kihlman <gk@@univits.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.8 2002/03/14 01:26:54 millert Exp $	*/
d507 1
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.7 2001/11/02 18:26:28 mickey Exp $	*/
d572 1
a572 1
	u_int16_t		an_spare[4];		/* 0x80 */
@


1.7
log
@new fw needs more space in an_ltv_status; from Gabriel Kihlman <gk@@univits.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.6 2001/10/24 16:20:20 mickey Exp $	*/
d673 10
a682 10
void	an_release_resources    __P((struct device *));
int	an_alloc_port           __P((struct device *, int, int));
int	an_alloc_memory         __P((struct device *, int, int));
int	an_alloc_irq            __P((struct device *, int, int));
int	an_probe                __P((struct device *));
void	an_shutdown             __P((void *));
int	an_attach               __P((struct an_softc *));
void	an_init                 __P((struct an_softc *));
void	an_stop                 __P((struct an_softc *));
int	an_intr                 __P((void *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.7 2001/11/02 18:26:28 mickey Exp $	*/
a506 1
	u_int16_t		an_rsvd1;		/* 0x82 */
d572 1
a572 1
	u_int16_t		an_spare[5];		/* 0x80 */
d643 1
a643 1
	struct arpcom	sc_arpcom;
d673 10
a682 10
void	an_release_resources(struct device *);
int	an_alloc_port(struct device *, int, int);
int	an_alloc_memory(struct device *, int, int);
int	an_alloc_irq(struct device *, int, int);
int	an_probe(struct device *);
void	an_shutdown(void *);
int	an_attach(struct an_softc *);
void	an_init(struct an_softc *);
void	an_stop(struct an_softc *);
int	an_intr(void *);
@


1.6
log
@do not #ifdef ANCACHE stuff makes softc constant; pointed out by dima@@m3d.dhs.org; fix by me
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.5 2001/09/29 21:54:00 mickey Exp $	*/
d572 1
a572 1
	u_int16_t		an_spare[3];		/* 0x80 */
@


1.5
log
@if_media support, from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.4 2001/06/25 21:11:17 mickey Exp $	*/
a92 1
#ifdef ANCACHE
a94 1
#endif
a151 1
#ifdef ANCACHE
a160 1
#endif
d646 1
d664 2
a665 1
#ifdef ANCACHE
a667 1

a670 2
#endif
	struct timeout		an_stat_ch;
@


1.4
log
@remove struct and contsts duplicated in between the files.
make it work on powerpc.
improve performance by using the bus_*_multi_* finctions instead of loops.
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.3 2001/02/27 06:43:10 tholo Exp $	*/
d648 1
@


1.3
log
@Sync with anreg.h -- this should be redone to not duplicate information...
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.2 2001/02/26 06:19:34 tholo Exp $	*/
d40 2
d145 1
a145 1
/* 
a165 1
#ifndef _KERNEL
d175 5
d278 2
a279 2
	u_int32_t		an_uptime_usecs;	/* 0x178 */
	u_int32_t		an_uptime_secs;		/* 0x17C */
d410 6
d427 3
d439 3
d448 3
d481 3
d513 3
d523 3
d532 11
d586 3
d604 2
d613 1
a613 1
#define AN_RID_ENCAPPROTO	0xFF14	/* Payload encapsulation type */
d622 2
a623 2
#define AN_RID_AP_INFO		0xFF01	/* Access point info */
#define AN_RID_RADIO_INFO	0xFF02	/* Radio info */
d635 38
d674 2
d677 11
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.3 2001/02/27 06:43:10 tholo Exp $	*/
@


1.3.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.3.4.1 2001/05/14 22:23:31 niklas Exp $	*/
a39 2
#pragma pack(1)

d143 1
a143 1
/*
d164 1
a173 5
/*
 * Grrr. The manual says the statistics record is 384 bytes in length,
 * but the card says the record is 404 bytes. There's some padding left
 * at the end of this structure to account for any discrepancies.
 */
d272 2
a273 2
	u_int32_t		an_uptime_secs;		/* 0x178 */
	u_int32_t		an_uptime_usecs;	/* 0x17C */
a403 6
/*
 * Valid SSID list. You can specify up to three SSIDs denoting
 * the service sets that you want to join. The first SSID always
 * defaults to "tsunami" which is a handy way to detect the
 * card.
 */
a414 3
/*
 * Valid AP list.
 */
a423 3
/*
 * Driver name.
 */
a429 3
/*
 * Frame encapsulation.
 */
a459 3
/*
 * Card capabilities (read only).
 */
a488 3
/*
 * Access point (read only)
 */
a495 3
/*
 * Radio info (read only).
 */
a501 11
/*
 * Status (read only). Note: the manual claims this RID is 108 bytes
 * long (0x6A is the last datum, which is 2 bytes long) however when
 * this RID is read from the NIC, it returns a length of 110. To be
 * on the safe side, this structure is padded with an extra 16-bit
 * word. (There is a misprint in the manual which says the macaddr
 * field is 8 bytes long.)
 *
 * Also, the channel_set and current_channel fields appear to be
 * reversed. Either that, or the hop_period field is unused.
 */
a544 3
/*
 * WEP config
 */
a559 2
#pragma pack()

d567 1
a567 1
#define AN_RID_ENCAP		0xFF14	/* Payload encapsulation type */
d576 2
a577 2
#define AN_RID_APINFO		0xFF01	/* Access point info */
#define AN_RID_RADIOINFO	0xFF02	/* Radio info */
a588 38

#ifdef _KERNEL
#define AN_TX_RING_CNT	4
struct an_tx_ring_data {
	u_int16_t	an_tx_fids[AN_TX_RING_CNT];
	u_int16_t	an_tx_ring[AN_TX_RING_CNT];
	int		an_tx_prod;
	int		an_tx_cons;
};

struct an_softc	{
	struct device	sc_dev;
	struct arpcom	arpcom;
	void		*sc_ih;

	bus_space_tag_t		an_btag;
	bus_space_handle_t	an_bhandle;

	struct an_ltv_genconfig	an_config;
	struct an_ltv_caps	an_caps;
	struct an_ltv_ssidlist	an_ssidlist;
	struct an_ltv_aplist	an_aplist;
	int			an_tx_rate;
	int			an_rxmode;
	int			an_gone;
	int			an_if_flags;
	u_int8_t		an_txbuf[1536];
	struct an_tx_ring_data	an_rdata;
	struct an_ltv_stats	an_stats;
	struct an_ltv_status	an_status;
	u_int8_t		an_associated;
#ifdef ANCACHE
	int			an_cache_iponly;
	int			an_cache_mcastonly;

	int			an_sigitems;
	struct an_sigcache	an_sigcache[MAXANCACHE];
	int			an_nextitem;
a589 2
	struct timeout		an_stat_ch;
};
a590 11
void	an_release_resources    __P((struct device *));
int	an_alloc_port           __P((struct device *, int, int));
int	an_alloc_memory         __P((struct device *, int, int));
int	an_alloc_irq            __P((struct device *, int, int));
int	an_probe                __P((struct device *));
void	an_shutdown             __P((void *));
int	an_attach               __P((struct an_softc *));
void	an_init                 __P((struct an_softc *));
void	an_stop                 __P((struct an_softc *));
int	an_intr                 __P((void *));
#endif
@


1.3.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.3.4.2 2001/07/04 10:40:38 niklas Exp $	*/
d93 1
d96 1
d154 1
d164 1
a647 1
	struct ifmedia	an_ifmedia;
a648 1
	struct timeout	an_stat_ch;
d666 1
a666 2

	/* ANCACHE stuff */
d669 1
d673 2
@


1.3.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d572 1
a572 1
	u_int16_t		an_spare[4];		/* 0x80 */
@


1.3.4.5
log
@Merge in -current from about a week ago
@
text
@d673 10
a682 10
void	an_release_resources(struct device *);
int	an_alloc_port(struct device *, int, int);
int	an_alloc_memory(struct device *, int, int);
int	an_alloc_irq(struct device *, int, int);
int	an_probe(struct device *);
void	an_shutdown(void *);
int	an_attach(struct an_softc *);
void	an_init(struct an_softc *);
void	an_stop(struct an_softc *);
int	an_intr(void *);
@


1.3.4.6
log
@Sync the SMP branch with 3.3
@
text
@a506 1
	u_int16_t		an_rsvd1;		/* 0x82 */
d572 1
a572 1
	u_int16_t		an_spare[5];		/* 0x80 */
d643 1
a643 1
	struct arpcom	sc_arpcom;
@


1.3.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d274 2
a275 2
	u_int32_t		an_uptime_usecs;	/* 0x178 */
	u_int32_t		an_uptime_secs;		/* 0x17C */
d277 1
d349 1
a349 1
	u_int16_t		an_rsvd9[2];		/* 0x9a */
d507 1
d597 1
a597 1
 * from the Aironet. Not all of them are tremendously useful, but I
@


1.2
log
@Allow configuration of WEP.  From FreeBSD; ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: anvar.h,v 1.1 2000/04/03 01:01:59 mickey Exp $	*/
d334 4
a337 1
	u_int16_t		an_rsvd6[4];		/* 0x78 */
a380 1
#define AN_AUTHTYPE_EXCLUDE_UNENCRYPTED		0x0004
d486 1
d508 1
a508 1
	u_int16_t		an_cur_signal_quality;	/* 0x0C */
d526 10
a535 1
	u_int16_t		an_rsvd0;		/* 0x6C */
d545 8
@


1.1
log
@aironet 802.11 ds driver from freebsd, isa and pci are missing
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d165 9
d379 3
d548 2
@

