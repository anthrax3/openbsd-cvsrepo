head	1.27;
access;
symbols
	OPENBSD_6_0:1.26.0.10
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.4
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.6
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.12
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.8
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.24
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.22
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.20
	OPENBSD_2_8:1.10.0.18
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.16
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.14
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.12
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.10
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.27
date	2016.09.04.18.20.34;	author tedu;	state Exp;
branches;
next	1.26;
commitid	5vdSYy8ueEhs20To;

1.26
date	2015.02.05.12.04.58;	author miod;	state Exp;
branches;
next	1.25;
commitid	nfEz66YvzGXJsIIq;

1.25
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	JtO5uXxVcnZfhUkR;

1.24
date	2013.04.21.14.44.16;	author sebastia;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.28.14.13.33;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.31.06.40.17;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.18.21.36.43;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.27.19.31.44;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.21.23.50.35;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.03.16.44.51;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.15.20.32.17;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.28.02;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.01.15.05.35.47;	author kstailey;	state Exp;
branches
	1.10.14.1
	1.10.24.1;
next	1.9;

1.9
date	96.12.16.00.11.58;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.12.03.05.21.46;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.11.28.23.27.57;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.06.18.10.23.03;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.07.34.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.00.27.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.21.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.23.47.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.31.07.01.09;	author deraadt;	state Exp;
branches;
next	;

1.10.14.1
date	2002.03.28.12.11.34;	author niklas;	state Exp;
branches;
next	1.10.14.2;

1.10.14.2
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.10.14.3;

1.10.14.3
date	2004.02.19.10.56.21;	author niklas;	state Exp;
branches;
next	;

1.10.24.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@remove some more sparc remnants. ok deraadt
@
text
@/*	$OpenBSD: z8530tty.c,v 1.26 2015/02/05 12:04:58 miod Exp $	*/
/*	$NetBSD: z8530tty.c,v 1.77 2001/05/30 15:24:24 lukem Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995, 1996, 1997, 1998, 1999
 *	Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)zs.c	8.1 (Berkeley) 7/19/93
 */

/*
 * Zilog Z8530 Dual UART driver (tty interface)
 *
 * This is the "slave" driver that will be attached to
 * the "zsc" driver for plain "tty" async. serial lines.
 *
 * Credits, history:
 *
 * The original version of this code was the sparc/dev/zs.c driver
 * as distributed with the Berkeley 4.4 Lite release.  Since then,
 * Gordon Ross reorganized the code into the current parent/child
 * driver scheme, separating the Sun keyboard and mouse support
 * into independent child drivers.
 *
 * RTS/CTS flow-control support was a collaboration of:
 *	Gordon Ross <gwr@@NetBSD.org>,
 *	Bill Studenmund <wrstuden@@loki.stanford.edu>
 *	Ian Dall <Ian.Dall@@dsto.defence.gov.au>
 *
 * The driver was massively overhauled in November 1997 by Charles Hannum,
 * fixing *many* bugs, and substantially improving performance.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <dev/ic/z8530reg.h>
#include <machine/z8530var.h>

#include <dev/cons.h>

/*
 * Allow the MD var.h to override the default CFLAG so that
 * console messages during boot come out with correct parity.
 */
#ifndef	ZSTTY_DEF_CFLAG
#define	ZSTTY_DEF_CFLAG	TTYDEF_CFLAG
#endif

/*
 * How many input characters we can buffer.
 * The port-specific var.h may override this.
 * Note: must be a power of two!
 */
#ifndef	ZSTTY_RING_SIZE
#define	ZSTTY_RING_SIZE	2048
#endif

struct cfdriver zstty_cd = {
	NULL, "zstty", DV_TTY
};

/*
 * Make this an option variable one can patch.
 * But be warned:  this must be a power of 2!
 */
u_int zstty_rbuf_size = ZSTTY_RING_SIZE;

/* Stop input when 3/4 of the ring is full; restart when only 1/4 is full. */
u_int zstty_rbuf_hiwat = (ZSTTY_RING_SIZE * 1) / 4;
u_int zstty_rbuf_lowat = (ZSTTY_RING_SIZE * 3) / 4;

struct zstty_softc {
	struct	device zst_dev;		/* required first: base device */
	struct  tty *zst_tty;
	struct	zs_chanstate *zst_cs;

	struct timeout zst_diag_ch;

	u_int zst_overflows,
	      zst_floods,
	      zst_errors;

	int zst_hwflags,	/* see z8530var.h */
	    zst_swflags;	/* TIOCFLAG_SOFTCAR, ... <ttycom.h> */

	u_int zst_r_hiwat,
	      zst_r_lowat;
	uint8_t *volatile zst_rbget,
		*volatile zst_rbput;
	volatile u_int zst_rbavail;
	uint8_t *zst_rbuf,
		*zst_ebuf;

	/*
	 * The transmit byte count and address are used for pseudo-DMA
	 * output in the hardware interrupt code.  PDMA can be suspended
	 * to get pending changes done; heldtbc is used for this.  It can
	 * also be stopped for ^S; this sets TS_TTSTOP in tp->t_state.
	 */
	uint8_t *zst_tba;		/* transmit buffer address */
	u_int zst_tbc,			/* transmit byte count */
	      zst_heldtbc;		/* held tbc while xmission stopped */

	/* Flags to communicate with zstty_softint() */
	volatile uint8_t zst_rx_flags,	/* receiver blocked */
#define	RX_TTY_BLOCKED		0x01
#define	RX_TTY_OVERFLOWED	0x02
#define	RX_IBUF_BLOCKED		0x04
#define	RX_IBUF_OVERFLOWED	0x08
#define	RX_ANY_BLOCK		0x0f
			zst_tx_busy,	/* working on an output chunk */
			zst_tx_done,	/* done with one output chunk */
			zst_tx_stopped,	/* H/W level stop (lost CTS) */
			zst_st_check,	/* got a status interrupt */
			zst_rx_ready;

	/* PPS signal on DCD, with or without inkernel clock disciplining */
	uint8_t  zst_ppsmask;			/* pps signal mask */
	uint8_t  zst_ppsassert;			/* pps leading edge */
	uint8_t  zst_ppsclear;			/* pps trailing edge */
};

/* Definition of the driver for autoconfig. */
int	zstty_match(struct device *, void *, void *);
void	zstty_attach(struct device *, struct device *, void *);

const struct cfattach zstty_ca = {
	sizeof(struct zstty_softc), zstty_match, zstty_attach
};

cdev_decl(zs);

struct zsops zsops_tty;

void zs_shutdown(struct zstty_softc *);
void	zsstart(struct tty *);
int	zsparam(struct tty *, struct termios *);
void zs_modem(struct zstty_softc *, int);
void tiocm_to_zs(struct zstty_softc *, u_long, int);
int  zs_to_tiocm(struct zstty_softc *);
int    zshwiflow(struct tty *, int);
void  zs_hwiflow(struct zstty_softc *);
void zs_maskintr(struct zstty_softc *);

struct zstty_softc *zs_device_lookup(struct cfdriver *, int);

/* Low-level routines. */
void zstty_rxint(struct zs_chanstate *);
void zstty_stint(struct zs_chanstate *, int);
void zstty_txint(struct zs_chanstate *);
void zstty_softint(struct zs_chanstate *);
void zstty_diag(void *);

#define	ZSUNIT(x)	(minor(x) & 0x7f)
#define	ZSDIALOUT(x)	(minor(x) & 0x80)

struct zstty_softc *
zs_device_lookup(struct cfdriver *cf, int unit)
{
	return (struct zstty_softc *)device_lookup(cf, unit);
}

/*
 * zstty_match: how is this zs channel configured?
 */
int
zstty_match(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct zsc_attach_args *args = aux;

	/* Exact match is better than wildcard. */
	if (cf->cf_loc[0] == args->channel)
		return 2;

	/* This driver accepts wildcard. */
	if (cf->cf_loc[0] == -1)
		return 1;

	return 0;
}

void
zstty_attach(struct device *parent, struct device *self, void *aux)
{
	struct zsc_softc *zsc = (struct zsc_softc *)parent;
	struct zstty_softc *zst = (struct zstty_softc *)self;
	struct cfdata *cf = self->dv_cfdata;
	struct zsc_attach_args *args = aux;
	struct zs_chanstate *cs;
	struct tty *tp;
	int channel, s, tty_unit;
	dev_t dev;
	const char *i, *o;
	int dtr_on;
	int resetbit;

	timeout_set(&zst->zst_diag_ch, zstty_diag, zst);

	tty_unit = zst->zst_dev.dv_unit;
	channel = args->channel;
	cs = zsc->zsc_cs[channel];
	cs->cs_private = zst;
	cs->cs_ops = &zsops_tty;

	zst->zst_cs = cs;
	zst->zst_swflags = cf->cf_flags;	/* softcar, etc. */
	zst->zst_hwflags = args->hwflags;
	dev = makedev(zs_major, tty_unit);

	if (zst->zst_swflags)
		printf(" flags 0x%x", zst->zst_swflags);

	if (ISSET(zst->zst_hwflags, ZS_HWFLAG_NO_DCD))
		SET(zst->zst_swflags, TIOCFLAG_SOFTCAR);

	/*
	 * Check whether we serve as a console device.
	 * XXX - split console input/output channels aren't
	 *	 supported yet on /dev/console
	 */
	i = o = NULL;
	if ((zst->zst_hwflags & ZS_HWFLAG_CONSOLE_INPUT) != 0) {
		i = " input";
		if ((args->hwflags & ZS_HWFLAG_USE_CONSDEV) != 0) {
			args->consdev->cn_dev = dev;
			cn_tab->cn_pollc = args->consdev->cn_pollc;
			cn_tab->cn_getc = args->consdev->cn_getc;
		}
		cn_tab->cn_dev = dev;
	}
	if ((zst->zst_hwflags & ZS_HWFLAG_CONSOLE_OUTPUT) != 0) {
		o = " output";
		if ((args->hwflags & ZS_HWFLAG_USE_CONSDEV) != 0) {
			cn_tab->cn_putc = args->consdev->cn_putc;
		}
		cn_tab->cn_dev = dev;
	}
	if (i != NULL || o != NULL) {
		printf(": console%s", i ? (o ? "" : i) : o);
	}

#ifdef KGDB
	if (zs_check_kgdb(cs, dev)) {
		/*
		 * Allow kgdb to "take over" this port.  Returns true
		 * if this serial port is in-use by kgdb.
		 */
		printf(": kgdb\n");
		/*
		 * This is the kgdb port (exclusive use)
		 * so skip the normal attach code.
		 */
		return;
	}
#endif

#if defined(__sparc64__)
	if (strcmp(args->type, "keyboard") == 0 ||
	    strcmp(args->type, "mouse") == 0)
		printf(": %s", args->type);
#endif

	printf("\n");

	tp = ttymalloc(0);
	tp->t_dev = dev;
	tp->t_oproc = zsstart;
	tp->t_param = zsparam;
	tp->t_hwiflow = zshwiflow;

	zst->zst_tty = tp;
	zst->zst_rbuf = mallocarray(zstty_rbuf_size, 2, M_DEVBUF, M_WAITOK);
	zst->zst_ebuf = zst->zst_rbuf + (zstty_rbuf_size * 2);
	/* Disable the high water mark. */
	zst->zst_r_hiwat = 0;
	zst->zst_r_lowat = 0;
	zst->zst_rbget = zst->zst_rbput = zst->zst_rbuf;
	zst->zst_rbavail = zstty_rbuf_size;

	/* if there are no enable/disable functions, assume the device
	   is always enabled */
	if (!cs->enable)
		cs->enabled = 1;

	/*
	 * Hardware init
	 */
	dtr_on = 0;
	resetbit = 0;
	if (ISSET(zst->zst_hwflags, ZS_HWFLAG_CONSOLE)) {
		/* Call zsparam similar to open. */
		struct termios t;

		/* Wait a while for previous console output to complete */
		DELAY(10000);

		/* Setup the "new" parameters in t. */
		t.c_ispeed = 0;
		t.c_ospeed = cs->cs_defspeed;
		t.c_cflag = cs->cs_defcflag;

		s = splzs();

		/*
		 * Turn on receiver and status interrupts.
		 * We defer the actual write of the register to zsparam(),
		 * but we must make sure status interrupts are turned on by
		 * the time zsparam() reads the initial rr0 state.
		 */
		SET(cs->cs_preg[1], ZSWR1_RIE | ZSWR1_TIE | ZSWR1_SIE);

		splx(s);

		/* Make sure zsparam will see changes. */
		tp->t_ospeed = 0;
		(void)zsparam(tp, &t);

		/* Make sure DTR is on now. */
		dtr_on = 1;
	} else if (!ISSET(zst->zst_hwflags, ZS_HWFLAG_NORESET)) {
		/* Not the console; may need reset. */
		resetbit = (channel == 0) ? ZSWR9_A_RESET : ZSWR9_B_RESET;
	}

	s = splzs();
	if (resetbit)
		zs_write_reg(cs, 9, resetbit);
	zs_modem(zst, dtr_on);
	splx(s);
}


/*
 * Return pointer to our tty.
 */
struct tty *
zstty(dev_t dev)
{
	struct zstty_softc *zst = zs_device_lookup(&zstty_cd, ZSUNIT(dev));

	return (zst->zst_tty);
}


void
zs_shutdown(struct zstty_softc *zst)
{
	struct zs_chanstate *cs = zst->zst_cs;
	struct tty *tp = zst->zst_tty;
	int s;

	s = splzs();

	/* If we were asserting flow control, then deassert it. */
	SET(zst->zst_rx_flags, RX_IBUF_BLOCKED);
	zs_hwiflow(zst);

	/* Clear any break condition set with TIOCSBRK. */
	zs_break(cs, 0);

	/* Turn off PPS capture on last close. */
	zst->zst_ppsmask = 0;

	/*
	 * Hang up if necessary.  Wait a bit, so the other side has time to
	 * notice even if we immediately open the port again.
	 */
	if (ISSET(tp->t_cflag, HUPCL) || ISSET(tp->t_state, TS_WOPEN)) {
		zs_modem(zst, 0);
		/* hold low for 1 second */
		(void)tsleep(cs, TTIPRI, ttclos, hz);
	}

	/* Turn off interrupts if not the console. */
	if (!ISSET(zst->zst_hwflags, ZS_HWFLAG_CONSOLE)) {
		CLR(cs->cs_preg[1], ZSWR1_RIE | ZSWR1_TIE | ZSWR1_SIE);
		cs->cs_creg[1] = cs->cs_preg[1];
		zs_write_reg(cs, 1, cs->cs_creg[1]);
	}

	/* Call the power management hook. */
	if (cs->disable) {
#ifdef DIAGNOSTIC
		if (!cs->enabled)
			panic("%s: not enabled?", __func__);
#endif
		(*cs->disable)(zst->zst_cs);
	}

	splx(s);
}

/*
 * Open a zs serial (tty) port.
 */
int
zsopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct zstty_softc *zst;
	struct zs_chanstate *cs;
	struct tty *tp;
	int s;
#if IPL_ZS != IPL_TTY
	int s2;
#endif
	int error;

	zst = zs_device_lookup(&zstty_cd, ZSUNIT(dev));
	if (zst == NULL)
		return (ENXIO);

	tp = zst->zst_tty;
	cs = zst->zst_cs;

	/* If KGDB took the line, then tp==NULL */
	if (tp == NULL)
		return (EBUSY);

	if (ISSET(tp->t_state, TS_ISOPEN) &&
	    ISSET(tp->t_state, TS_XCLUDE) &&
	    suser(p, 0) != 0)
		return (EBUSY);

	s = spltty();

	/*
	 * Do the following iff this is a first open.
	 */
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		struct termios t;

		tp->t_dev = dev;

		/* Call the power management hook. */
		if (cs->enable) {
			if ((*cs->enable)(cs)) {
				splx(s);
				printf("%s: device enable failed\n",
				    zst->zst_dev.dv_xname);
				return (EIO);
			}
		}

		/*
		 * Initialize the termios status to the defaults.  Add in the
		 * sticky bits from TIOCSFLAGS.
		 */
		t.c_ispeed = 0;
		t.c_ospeed = cs->cs_defspeed;
		t.c_cflag = cs->cs_defcflag;
		if (ISSET(zst->zst_swflags, TIOCFLAG_CLOCAL))
			SET(t.c_cflag, CLOCAL);
		if (ISSET(zst->zst_swflags, TIOCFLAG_CRTSCTS))
			SET(t.c_cflag, CRTSCTS);
		if (ISSET(zst->zst_swflags, TIOCFLAG_MDMBUF))
			SET(t.c_cflag, MDMBUF);

#if IPL_ZS != IPL_TTY
		s2 = splzs();
#endif

		/*
		 * Turn on receiver and status interrupts.
		 * We defer the actual write of the register to zsparam(),
		 * but we must make sure status interrupts are turned on by
		 * the time zsparam() reads the initial rr0 state.
		 */
		SET(cs->cs_preg[1], ZSWR1_RIE | ZSWR1_TIE | ZSWR1_SIE);

		/* Clear PPS capture state on first open. */
		zst->zst_ppsmask = 0;

#if IPL_ZS != IPL_TTY
		splx(s2);
#endif

		/* Make sure zsparam will see changes. */
		tp->t_ospeed = 0;
		(void)zsparam(tp, &t);

		/*
		 * Note: zsparam has done: cflag, ispeed, ospeed
		 * so we just need to do: iflag, oflag, lflag, cc
		 * For "raw" mode, just leave all zeros.
		 */
		if (!ISSET(zst->zst_hwflags, ZS_HWFLAG_RAW)) {
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
		} else {
			tp->t_iflag = 0;
			tp->t_oflag = 0;
			tp->t_lflag = 0;
		}
		ttychars(tp);
		ttsetwater(tp);

		if (ZSDIALOUT(dev))
			SET(tp->t_state, TS_CARR_ON);
		else
			CLR(tp->t_state, TS_CARR_ON);

#if IPL_ZS != IPL_TTY
		s2 = splzs();
#endif

		/* Clear the input ring, and unblock. */
		zst->zst_rbget = zst->zst_rbput = zst->zst_rbuf;
		zst->zst_rbavail = zstty_rbuf_size;
		zs_iflush(cs);
		CLR(zst->zst_rx_flags, RX_ANY_BLOCK);
		zs_hwiflow(zst);

#if IPL_ZS != IPL_TTY
		splx(s2);
#endif
	}

	if (ZSDIALOUT(dev)) {
		if (ISSET(tp->t_state, TS_ISOPEN)) {
			/* someone already is dialed in... */
			splx(s);
			return EBUSY;
		}
		cs->cs_cua = 1;
	}

	error = 0;
	/* wait for carrier if necessary */
	if (ISSET(flags, O_NONBLOCK)) {
		if (!ZSDIALOUT(dev) && cs->cs_cua) {
			/* Opening TTY non-blocking... but the CUA is busy */
			error = EBUSY;
		}
	} else
	  while (cs->cs_cua ||
	    (!ISSET(tp->t_cflag, CLOCAL) && !ISSET(tp->t_state, TS_CARR_ON))) {
		int rr0;

		error = 0;
		SET(tp->t_state, TS_WOPEN);

		if (!ZSDIALOUT(dev) && !cs->cs_cua) {
			/*
			 * Turn on DTR.  We must always do this on non-CUA
			 * devices, even if carrier is not present, because
			 * otherwise we'd have to use TIOCSDTR immediately
			 * after setting CLOCAL, which applications do not
			 * expect.  We always assert DTR while the device is
			 * open unless explicitly requested to deassert it.
			 */
#if IPL_ZS != IPL_TTY
			s2 = splzs();
#endif
			zs_modem(zst, 1);
			rr0 = zs_read_csr(cs);
#if IPL_ZS != IPL_TTY
			splx(s2);
#endif

			/* loop, turning on the device, until carrier present */
			if (ISSET(rr0, ZSRR0_DCD) ||
			    ISSET(zst->zst_swflags, TIOCFLAG_SOFTCAR))
				SET(tp->t_state, TS_CARR_ON);
		}

		if ((ISSET(tp->t_cflag, CLOCAL) ||
		    ISSET(tp->t_state, TS_CARR_ON)) && !cs->cs_cua)
			break;

		error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
		    ttopen, 0);

		if (!ZSDIALOUT(dev) && cs->cs_cua && error == EINTR) {
			error = 0;
			continue;
		}

		if (error) {
			if (!ISSET(tp->t_state, TS_ISOPEN)) {
#if IPL_ZS != IPL_TTY
				s2 = splzs();
#endif
				zs_modem(zst, 0);
#if IPL_ZS != IPL_TTY
				splx(s2);
#endif
				CLR(tp->t_state, TS_WOPEN);
				ttwakeup(tp);
			}
			if (ZSDIALOUT(dev))
				cs->cs_cua = 0;
			CLR(tp->t_state, TS_WOPEN);
			break;
		}
		if (!ZSDIALOUT(dev) && cs->cs_cua)
			continue;
	}

	splx(s);

	if (error == 0)
		error = ((*linesw[tp->t_line].l_open)(dev, tp, p));
	if (error)
		goto bad;

	return (0);

bad:
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		/*
		 * We failed to open the device, and nobody else had it opened.
		 * Clean up the state as appropriate.
		 */
		zs_shutdown(zst);
	}

	return (error);
}

/*
 * Close a zs serial port.
 */
int
zsclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct zstty_softc *zst = zs_device_lookup(&zstty_cd, ZSUNIT(dev));
	struct zs_chanstate *cs = zst->zst_cs;
	struct tty *tp = zst->zst_tty;
	int s;

	/* XXX This is for cons.c. */
	if (!ISSET(tp->t_state, TS_ISOPEN))
		return 0;

	(*linesw[tp->t_line].l_close)(tp, flags, p);

	s = spltty();
	cs->cs_cua = 0;
	ttyclose(tp);
	splx(s);

	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		/*
		 * Although we got a last close, the device may still be in
		 * use; e.g. if this was the dialout node, and there are still
		 * processes waiting for carrier on the non-dialout node.
		 */
		zs_shutdown(zst);
	}

	return (0);
}

/*
 * Read/write zs serial port.
 */
int
zsread(dev_t dev, struct uio *uio, int flags)
{
	struct zstty_softc *zst = zs_device_lookup(&zstty_cd, ZSUNIT(dev));
	struct tty *tp = zst->zst_tty;

	return (*linesw[tp->t_line].l_read)(tp, uio, flags);
}

int
zswrite(dev_t dev, struct uio *uio, int flags)
{
	struct zstty_softc *zst = zs_device_lookup(&zstty_cd, ZSUNIT(dev));
	struct tty *tp = zst->zst_tty;

	return (*linesw[tp->t_line].l_write)(tp, uio, flags);
}

int
zsioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct zstty_softc *zst = zs_device_lookup(&zstty_cd, ZSUNIT(dev));
	struct zs_chanstate *cs = zst->zst_cs;
	struct tty *tp = zst->zst_tty;
	int error;
	int s;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

#ifdef	ZS_MD_IOCTL
	error = ZS_MD_IOCTL;
	if (error >= 0)
		return (error);
#endif	/* ZS_MD_IOCTL */

	error = 0;

	s = splzs();

	switch (cmd) {
	case TIOCSBRK:
		zs_break(cs, 1);
		break;

	case TIOCCBRK:
		zs_break(cs, 0);
		break;

	case TIOCGFLAGS:
		*(int *)data = zst->zst_swflags;
		break;

	case TIOCSFLAGS:
		error = suser(p, 0);
		if (error)
			break;
		zst->zst_swflags = *(int *)data;
		if (ISSET(zst->zst_hwflags, ZS_HWFLAG_NO_DCD))
			SET(zst->zst_swflags, TIOCFLAG_SOFTCAR);
		break;

	case TIOCSDTR:
		zs_modem(zst, 1);
		break;

	case TIOCCDTR:
		zs_modem(zst, 0);
		break;

	case TIOCMSET:
	case TIOCMBIS:
	case TIOCMBIC:
		tiocm_to_zs(zst, cmd, *(int *)data);
		break;

	case TIOCMGET:
		*(int *)data = zs_to_tiocm(zst);
		break;

	default:
		error = ENOTTY;
		break;
	}

	splx(s);

	return (error);
}

/*
 * Start or restart transmission.
 */
void
zsstart(struct tty *tp)
{
	struct zstty_softc *zst = zs_device_lookup(&zstty_cd, ZSUNIT(tp->t_dev));
	struct zs_chanstate *cs = zst->zst_cs;
	u_char *tba;
	int tbc, rr0;
	int s;

	s = spltty();
	if (ISSET(tp->t_state, TS_BUSY | TS_TIMEOUT | TS_TTSTOP))
		goto out;
	if (zst->zst_tx_stopped)
		goto out;

	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0)
		goto out;

	/* Grab the first contiguous region of buffer space. */
	tba = tp->t_outq.c_cf;
	tbc = ndqb(&tp->t_outq, 0);

#if IPL_ZS != IPL_TTY
	(void)splzs();
#endif

	zst->zst_tba = tba;
	zst->zst_tbc = tbc;
	SET(tp->t_state, TS_BUSY);
	zst->zst_tx_busy = 1;

	do {
		rr0 = zs_read_csr(cs);
		if ((rr0 & ZSRR0_TX_READY) == 0)
			break;

		zs_write_data(cs, *zst->zst_tba);
		zst->zst_tbc--;
		zst->zst_tba++;
	} while (zst->zst_tbc > 0);

out:
	splx(s);
}

/*
 * Stop output, e.g., for ^S or output flush.
 */
int
zsstop(struct tty *tp, int flag)
{
	struct zstty_softc *zst = zs_device_lookup(&zstty_cd, ZSUNIT(tp->t_dev));
	int s;

	s = splzs();
	if (ISSET(tp->t_state, TS_BUSY)) {
		/* Stop transmitting at the next chunk. */
		zst->zst_tbc = 0;
		zst->zst_heldtbc = 0;
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);
	}
	splx(s);
	return 0;
}

/*
 * Set ZS tty parameters from termios.
 * XXX - Should just copy the whole termios after
 * making sure all the changes could be done.
 */
int
zsparam(struct tty *tp, struct termios *t)
{
	struct zstty_softc *zst = zs_device_lookup(&zstty_cd, ZSUNIT(tp->t_dev));
	struct zs_chanstate *cs = zst->zst_cs;
	int ospeed;
	tcflag_t cflag;
	uint8_t tmp3, tmp4, tmp5;
	int s, error;

	ospeed = t->c_ospeed;
	cflag = t->c_cflag;

	/* Check requested parameters. */
	if (ospeed < 0)
		return (EINVAL);
	if (t->c_ispeed && t->c_ispeed != ospeed)
		return (EINVAL);

	/*
	 * For the console, always force CLOCAL and !HUPCL, so that the port
	 * is always active.
	 */
	if (ISSET(zst->zst_swflags, TIOCFLAG_SOFTCAR) ||
	    ISSET(zst->zst_hwflags, ZS_HWFLAG_CONSOLE)) {
		SET(cflag, CLOCAL);
		CLR(cflag, HUPCL);
	}

	/*
	 * Only whack the UART when params change.
	 * Some callers need to clear tp->t_ospeed
	 * to make sure initialization gets done.
	 */
	if (tp->t_ospeed == ospeed &&
	    tp->t_cflag == cflag)
		return (0);

	/*
	 * Call MD functions to deal with changed
	 * clock modes or H/W flow control modes.
	 * The BRG divisor is set now. (reg 12,13)
	 */
	error = zs_set_speed(cs, ospeed);
	if (error)
		return (error);
	error = zs_set_modes(cs, cflag);
	if (error)
		return (error);

	/*
	 * Block interrupts so that state will not
	 * be altered until we are done setting it up.
	 *
	 * Initial values in cs_preg are set before
	 * our attach routine is called.  The master
	 * interrupt enable is handled by zsc.c
	 *
	 */
	s = splzs();

	/*
	 * Recalculate which status ints to enable.
	 */
	zs_maskintr(zst);

	/* Recompute character size bits. */
	tmp3 = cs->cs_preg[3];
	tmp5 = cs->cs_preg[5];
	CLR(tmp3, ZSWR3_RXSIZE);
	CLR(tmp5, ZSWR5_TXSIZE);
	switch (ISSET(cflag, CSIZE)) {
	case CS5:
		SET(tmp3, ZSWR3_RX_5);
		SET(tmp5, ZSWR5_TX_5);
		break;
	case CS6:
		SET(tmp3, ZSWR3_RX_6);
		SET(tmp5, ZSWR5_TX_6);
		break;
	case CS7:
		SET(tmp3, ZSWR3_RX_7);
		SET(tmp5, ZSWR5_TX_7);
		break;
	case CS8:
		SET(tmp3, ZSWR3_RX_8);
		SET(tmp5, ZSWR5_TX_8);
		break;
	}
	cs->cs_preg[3] = tmp3;
	cs->cs_preg[5] = tmp5;

	/*
	 * Recompute the stop bits and parity bits.  Note that
	 * zs_set_speed() may have set clock selection bits etc.
	 * in wr4, so those must preserved.
	 */
	tmp4 = cs->cs_preg[4];
	CLR(tmp4, ZSWR4_SBMASK | ZSWR4_PARMASK);
	if (ISSET(cflag, CSTOPB))
		SET(tmp4, ZSWR4_TWOSB);
	else
		SET(tmp4, ZSWR4_ONESB);
	if (!ISSET(cflag, PARODD))
		SET(tmp4, ZSWR4_EVENP);
	if (ISSET(cflag, PARENB))
		SET(tmp4, ZSWR4_PARENB);
	cs->cs_preg[4] = tmp4;

	/* And copy to tty. */
	tp->t_ispeed = 0;
	tp->t_ospeed = ospeed;
	tp->t_cflag = cflag;

	/*
	 * If nothing is being transmitted, set up new current values,
	 * else mark them as pending.
	 */
	if (!cs->cs_heldchange) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = 1;
		} else
			zs_loadchannelregs(cs);
	}

	/*
	 * If hardware flow control is disabled, turn off the buffer water
	 * marks and unblock any soft flow control state.  Otherwise, enable
	 * the water marks.
	 */
	if (!ISSET(cflag, CHWFLOW)) {
		zst->zst_r_hiwat = 0;
		zst->zst_r_lowat = 0;
		if (ISSET(zst->zst_rx_flags, RX_TTY_OVERFLOWED)) {
			CLR(zst->zst_rx_flags, RX_TTY_OVERFLOWED);
			zst->zst_rx_ready = 1;
			cs->cs_softreq = 1;
		}
		if (ISSET(zst->zst_rx_flags, RX_TTY_BLOCKED|RX_IBUF_BLOCKED)) {
			CLR(zst->zst_rx_flags, RX_TTY_BLOCKED|RX_IBUF_BLOCKED);
			zs_hwiflow(zst);
		}
	} else {
		zst->zst_r_hiwat = zstty_rbuf_hiwat;
		zst->zst_r_lowat = zstty_rbuf_lowat;
	}

	/*
	 * Force a recheck of the hardware carrier and flow control status,
	 * since we may have changed which bits we're looking at.
	 */
	zstty_stint(cs, 1);

	splx(s);

	/*
	 * If hardware flow control is disabled, unblock any hard flow control
	 * state.
	 */
	if (!ISSET(cflag, CHWFLOW)) {
		if (zst->zst_tx_stopped) {
			zst->zst_tx_stopped = 0;
			zsstart(tp);
		}
	}

	zstty_softint(cs);

	return (0);
}

/*
 * Compute interrupt enable bits and set in the pending bits. Called both
 * in zsparam() and when PPS (pulse per second timing) state changes.
 * Must be called at splzs().
 */
void
zs_maskintr(struct zstty_softc *zst)
{
	struct zs_chanstate *cs = zst->zst_cs;
	uint8_t tmp15;

	cs->cs_rr0_mask = cs->cs_rr0_cts | cs->cs_rr0_dcd;
	if (zst->zst_ppsmask != 0)
		cs->cs_rr0_mask |= cs->cs_rr0_pps;
	tmp15 = cs->cs_preg[15];
	if (ISSET(cs->cs_rr0_mask, ZSRR0_DCD))
		SET(tmp15, ZSWR15_DCD_IE);
	else
		CLR(tmp15, ZSWR15_DCD_IE);
	if (ISSET(cs->cs_rr0_mask, ZSRR0_CTS))
		SET(tmp15, ZSWR15_CTS_IE);
	else
		CLR(tmp15, ZSWR15_CTS_IE);
	cs->cs_preg[15] = tmp15;
}


/*
 * Raise or lower modem control (DTR/RTS) signals.  If a character is
 * in transmission, the change is deferred.
 * Called at splzs().
 */
void
zs_modem(struct zstty_softc *zst, int onoff)
{
	struct zs_chanstate *cs = zst->zst_cs, *ccs;

	if (cs->cs_wr5_dtr == 0)
		return;

	ccs = (cs->cs_ctl_chan != NULL ? cs->cs_ctl_chan : cs);

	if (onoff)
		SET(ccs->cs_preg[5], cs->cs_wr5_dtr);
	else
		CLR(ccs->cs_preg[5], cs->cs_wr5_dtr);

	if (!cs->cs_heldchange) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = 1;
		} else
			zs_loadchannelregs(cs);
	}
}

/*
 * Set modem bits.
 * Called at splzs().
 */
void
tiocm_to_zs(struct zstty_softc *zst, u_long how, int ttybits)
{
	struct zs_chanstate *cs = zst->zst_cs, *ccs;
	uint8_t zsbits;

	ccs = (cs->cs_ctl_chan != NULL ? cs->cs_ctl_chan : cs);

	zsbits = 0;
	if (ISSET(ttybits, TIOCM_DTR))
		SET(zsbits, ZSWR5_DTR);
	if (ISSET(ttybits, TIOCM_RTS))
		SET(zsbits, ZSWR5_RTS);

	switch (how) {
	case TIOCMBIC:
		CLR(ccs->cs_preg[5], zsbits);
		break;

	case TIOCMBIS:
		SET(ccs->cs_preg[5], zsbits);
		break;

	case TIOCMSET:
		CLR(ccs->cs_preg[5], ZSWR5_RTS | ZSWR5_DTR);
		SET(ccs->cs_preg[5], zsbits);
		break;
	}

	if (!cs->cs_heldchange) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = 1;
		} else
			zs_loadchannelregs(cs);
	}
}

/*
 * Get modem bits.
 * Called at splzs().
 */
int
zs_to_tiocm(struct zstty_softc *zst)
{
	struct zs_chanstate *cs = zst->zst_cs, *ccs;
	uint8_t zsbits;
	int ttybits = 0;

	ccs = (cs->cs_ctl_chan != NULL ? cs->cs_ctl_chan : cs);

	zsbits = ccs->cs_preg[5];
	if (ISSET(zsbits, ZSWR5_DTR))
		SET(ttybits, TIOCM_DTR);
	if (ISSET(zsbits, ZSWR5_RTS))
		SET(ttybits, TIOCM_RTS);

	zsbits = cs->cs_rr0;
	if (ISSET(zsbits, ZSRR0_DCD))
		SET(ttybits, TIOCM_CD);
	if (ISSET(zsbits, ZSRR0_CTS))
		SET(ttybits, TIOCM_CTS);

	return (ttybits);
}

/*
 * Try to block or unblock input using hardware flow-control.
 * This is called by kern/tty.c if MDMBUF|CRTSCTS is set, and
 * if this function returns non-zero, the TS_TBLOCK flag will
 * be set or cleared according to the "block" arg passed.
 */
int
zshwiflow(struct tty *tp, int block)
{
	struct zstty_softc *zst = zs_device_lookup(&zstty_cd, ZSUNIT(tp->t_dev));
	struct zs_chanstate *cs = zst->zst_cs;
	int s;

	if (cs->cs_wr5_rts == 0)
		return (0);

	s = splzs();
	if (block) {
		if (!ISSET(zst->zst_rx_flags, RX_TTY_BLOCKED)) {
			SET(zst->zst_rx_flags, RX_TTY_BLOCKED);
			zs_hwiflow(zst);
		}
	} else {
		if (ISSET(zst->zst_rx_flags, RX_TTY_OVERFLOWED)) {
			CLR(zst->zst_rx_flags, RX_TTY_OVERFLOWED);
			zst->zst_rx_ready = 1;
			cs->cs_softreq = 1;
		}
		if (ISSET(zst->zst_rx_flags, RX_TTY_BLOCKED)) {
			CLR(zst->zst_rx_flags, RX_TTY_BLOCKED);
			zs_hwiflow(zst);
		}
	}
	splx(s);
	return (1);
}

/*
 * Internal version of zshwiflow
 * Called at splzs()
 */
void
zs_hwiflow(struct zstty_softc *zst)
{
	struct zs_chanstate *cs = zst->zst_cs, *ccs;

	if (cs->cs_wr5_rts == 0)
		return;

	ccs = (cs->cs_ctl_chan != NULL ? cs->cs_ctl_chan : cs);

	if (ISSET(zst->zst_rx_flags, RX_ANY_BLOCK)) {
		CLR(ccs->cs_preg[5], cs->cs_wr5_rts);
		CLR(ccs->cs_creg[5], cs->cs_wr5_rts);
	} else {
		SET(ccs->cs_preg[5], cs->cs_wr5_rts);
		SET(ccs->cs_creg[5], cs->cs_wr5_rts);
	}
	zs_write_reg(ccs, 5, ccs->cs_creg[5]);
}


/****************************************************************
 * Interface to the lower layer (zscc)
 ****************************************************************/

void zstty_rxsoft(struct zstty_softc *, struct tty *);
void zstty_txsoft(struct zstty_softc *, struct tty *);
void zstty_stsoft(struct zstty_softc *, struct tty *);
void zstty_diag(void *);

/*
 * Receiver Ready interrupt.
 * Called at splzs().
 */
void
zstty_rxint(struct zs_chanstate *cs)
{
	struct zstty_softc *zst = cs->cs_private;
	uint8_t *put, *end;
	u_int cc;
	uint8_t rr0, rr1, c;

	end = zst->zst_ebuf;
	put = zst->zst_rbput;
	cc = zst->zst_rbavail;

	while (cc > 0) {
		/*
		 * First read the status, because reading the received char
		 * destroys the status of this char.
		 */
		rr1 = zs_read_reg(cs, 1);
		c = zs_read_data(cs);

		if (ISSET(rr1, ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {
			/* Clear the receive error. */
			zs_write_csr(cs, ZSWR0_RESET_ERRORS);
		}

		put[0] = c;
		put[1] = rr1;
		put += 2;
		if (put >= end)
			put = zst->zst_rbuf;
		cc--;

		rr0 = zs_read_csr(cs);
		if (!ISSET(rr0, ZSRR0_RX_READY))
			break;
	}

	/*
	 * Current string of incoming characters ended because
	 * no more data was available or we ran out of space.
	 * Schedule a receive event if any data was received.
	 * If we're out of space, turn off receive interrupts.
	 */
	zst->zst_rbput = put;
	zst->zst_rbavail = cc;
	if (!ISSET(zst->zst_rx_flags, RX_TTY_OVERFLOWED)) {
		zst->zst_rx_ready = 1;
		cs->cs_softreq = 1;
	}

	/*
	 * See if we are in danger of overflowing a buffer. If
	 * so, use hardware flow control to ease the pressure.
	 */
	if (!ISSET(zst->zst_rx_flags, RX_IBUF_BLOCKED) &&
	    cc < zst->zst_r_hiwat) {
		SET(zst->zst_rx_flags, RX_IBUF_BLOCKED);
		zs_hwiflow(zst);
	}

	/*
	 * If we're out of space, disable receive interrupts
	 * until the queue has drained a bit.
	 */
	if (!cc) {
		SET(zst->zst_rx_flags, RX_IBUF_OVERFLOWED);
		CLR(cs->cs_preg[1], ZSWR1_RIE);
		cs->cs_creg[1] = cs->cs_preg[1];
		zs_write_reg(cs, 1, cs->cs_creg[1]);
	}
}

/*
 * Transmitter Ready interrupt.
 * Called at splzs().
 */
void
zstty_txint(struct zs_chanstate *cs)
{
	struct zstty_softc *zst = cs->cs_private;
	int rr0;

	zs_write_csr(cs, ZSWR0_RESET_TXINT);

	/*
	 * If we've delayed a parameter change, do it now, and restart
	 * output.
	 */
	if (cs->cs_heldchange) {
		zs_loadchannelregs(cs);
		cs->cs_heldchange = 0;
		zst->zst_tbc = zst->zst_heldtbc;
		zst->zst_heldtbc = 0;
	}

	while (zst->zst_tbc > 0) {
		rr0 = zs_read_csr(cs);
		if ((rr0 & ZSRR0_TX_READY) == 0)
			break;

		zs_write_data(cs, *zst->zst_tba);
		zst->zst_tbc--;
		zst->zst_tba++;
	}

	if (zst->zst_tbc == 0) {
		if (zst->zst_tx_busy) {
			zst->zst_tx_busy = 0;
			zst->zst_tx_done = 1;
			cs->cs_softreq = 1;
		}
	}
}

#ifdef DDB
#include <ddb/db_var.h>
#define	DB_CONSOLE	db_console
#else
#define	DB_CONSOLE	0
#endif

/*
 * Status Change interrupt.
 * Called at splzs().
 */
void
zstty_stint(struct zs_chanstate *cs, int force)
{
	struct zstty_softc *zst = cs->cs_private;
	struct tty *tp = zst->zst_tty;
	uint8_t rr0, delta;

	rr0 = zs_read_csr(cs);
	zs_write_csr(cs, ZSWR0_RESET_STATUS);

	/*
	 * Check here for console break, so that we can abort
	 * even when interrupts are locking up the machine.
	 */
	if ((zst->zst_hwflags & ZS_HWFLAG_CONSOLE_INPUT) &&
	    ISSET(rr0, ZSRR0_BREAK) && DB_CONSOLE)
		zs_abort(cs);

	if (!force)
		delta = rr0 ^ cs->cs_rr0;
	else
		delta = cs->cs_rr0_mask;

	ttytstamp(tp, cs->cs_rr0 & ZSRR0_CTS, rr0 & ZSRR0_CTS,
	    cs->cs_rr0 & ZSRR0_DCD, rr0 & ZSRR0_DCD);

	cs->cs_rr0 = rr0;

	if (ISSET(delta, cs->cs_rr0_mask)) {
		SET(cs->cs_rr0_delta, delta);

		/*
		 * Stop output immediately if we lose the output
		 * flow control signal or carrier detect.
		 */
		if (ISSET(~rr0, cs->cs_rr0_mask)) {
			zst->zst_tbc = 0;
			zst->zst_heldtbc = 0;
		}

		zst->zst_st_check = 1;
		cs->cs_softreq = 1;
	}
}

void
zstty_diag(void *arg)
{
	struct zstty_softc *zst = arg;
	int overflows, floods;
	int s;

	s = splzs();
	overflows = zst->zst_overflows;
	zst->zst_overflows = 0;
	floods = zst->zst_floods;
	zst->zst_floods = 0;
	zst->zst_errors = 0;
	splx(s);

	log(LOG_WARNING, "%s: %d silo overflow%s, %d ibuf flood%s\n",
	    zst->zst_dev.dv_xname,
	    overflows, overflows == 1 ? "" : "s",
	    floods, floods == 1 ? "" : "s");
}

void
zstty_rxsoft(struct zstty_softc *zst, struct tty *tp)
{
	struct zs_chanstate *cs = zst->zst_cs;
	int (*rint)(int, struct tty *) = linesw[tp->t_line].l_rint;
	uint8_t *get, *end;
	u_int cc, scc;
	uint8_t rr1;
	int code;
	int s;

	end = zst->zst_ebuf;
	get = zst->zst_rbget;
	scc = cc = zstty_rbuf_size - zst->zst_rbavail;

	if (cc == zstty_rbuf_size) {
		zst->zst_floods++;
		if (zst->zst_errors++ == 0)
			timeout_add_sec(&zst->zst_diag_ch, 60);
	}

	/* If not yet open, drop the entire buffer content here */
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		get += cc << 1;
		if (get >= end)
			get -= zstty_rbuf_size << 1;
		cc = 0;
	}
	while (cc) {
		code = get[0];
		rr1 = get[1];
		if (ISSET(rr1, ZSRR1_DO | ZSRR1_FE | ZSRR1_PE)) {
			if (ISSET(rr1, ZSRR1_DO)) {
				zst->zst_overflows++;
				if (zst->zst_errors++ == 0)
					timeout_add_sec(&zst->zst_diag_ch, 60);
			}
			if (ISSET(rr1, ZSRR1_FE))
				SET(code, TTY_FE);
			if (ISSET(rr1, ZSRR1_PE))
				SET(code, TTY_PE);
		}
		if ((*rint)(code, tp) == -1) {
			/*
			 * The line discipline's buffer is out of space.
			 */
			if (!ISSET(zst->zst_rx_flags, RX_TTY_BLOCKED)) {
				/*
				 * We're either not using flow control, or the
				 * line discipline didn't tell us to block for
				 * some reason.  Either way, we have no way to
				 * know when there's more space available, so
				 * just drop the rest of the data.
				 */
				get += cc << 1;
				if (get >= end)
					get -= zstty_rbuf_size << 1;
				cc = 0;
			} else {
				/*
				 * Don't schedule any more receive processing
				 * until the line discipline tells us there's
				 * space available (through comhwiflow()).
				 * Leave the rest of the data in the input
				 * buffer.
				 */
				SET(zst->zst_rx_flags, RX_TTY_OVERFLOWED);
			}
			break;
		}
		get += 2;
		if (get >= end)
			get = zst->zst_rbuf;
		cc--;
	}

	if (cc != scc) {
		zst->zst_rbget = get;
		s = splzs();
		cc = zst->zst_rbavail += scc - cc;
		/* Buffers should be ok again, release possible block. */
		if (cc >= zst->zst_r_lowat) {
			if (ISSET(zst->zst_rx_flags, RX_IBUF_OVERFLOWED)) {
				CLR(zst->zst_rx_flags, RX_IBUF_OVERFLOWED);
				SET(cs->cs_preg[1], ZSWR1_RIE);
				cs->cs_creg[1] = cs->cs_preg[1];
				zs_write_reg(cs, 1, cs->cs_creg[1]);
			}
			if (ISSET(zst->zst_rx_flags, RX_IBUF_BLOCKED)) {
				CLR(zst->zst_rx_flags, RX_IBUF_BLOCKED);
				zs_hwiflow(zst);
			}
		}
		splx(s);
	}
}

void
zstty_txsoft(struct zstty_softc *zst, struct tty *tp)
{
	int s;

	CLR(tp->t_state, TS_BUSY);
	if (ISSET(tp->t_state, TS_FLUSH))
		CLR(tp->t_state, TS_FLUSH);
	else {
		s = splzs();
		ndflush(&tp->t_outq, (int)(zst->zst_tba - tp->t_outq.c_cf));
		splx(s);
	}
	(*linesw[tp->t_line].l_start)(tp);
}

void
zstty_stsoft(struct zstty_softc *zst, struct tty *tp)
{
	struct zs_chanstate *cs = zst->zst_cs;
	uint8_t rr0, delta;
	int s;

	s = splzs();
	rr0 = cs->cs_rr0;
	delta = cs->cs_rr0_delta;
	cs->cs_rr0_delta = 0;
	splx(s);

	if (ISSET(delta, cs->cs_rr0_dcd)) {
		/*
		 * Inform the tty layer that carrier detect changed.
		 */
		(void)(*linesw[tp->t_line].l_modem)(tp, ISSET(rr0, ZSRR0_DCD));
	}

	if (ISSET(delta, cs->cs_rr0_cts)) {
		/* Block or unblock output according to flow control. */
		if (ISSET(rr0, cs->cs_rr0_cts)) {
			zst->zst_tx_stopped = 0;
			(*linesw[tp->t_line].l_start)(tp);
		} else {
			zst->zst_tx_stopped = 1;
		}
	}
}

/*
 * Software interrupt.  Called at zssoft
 *
 * The main job to be done here is to empty the input ring
 * by passing its contents up to the tty layer.  The ring is
 * always emptied during this operation, therefore the ring
 * must not be larger than the space after "high water" in
 * the tty layer, or the tty layer might drop our input.
 *
 * Note: an "input blockage" condition is assumed to exist if
 * EITHER the TS_TBLOCK flag or zst_rx_blocked flag is set.
 */
void
zstty_softint(struct zs_chanstate *cs)
{
	struct zstty_softc *zst = cs->cs_private;
	struct tty *tp = zst->zst_tty;
	int s;

	s = spltty();

	if (zst->zst_rx_ready) {
		zst->zst_rx_ready = 0;
		zstty_rxsoft(zst, tp);
	}

	if (zst->zst_st_check) {
		zst->zst_st_check = 0;
		zstty_stsoft(zst, tp);
	}

	if (zst->zst_tx_done) {
		zst->zst_tx_done = 0;
		zstty_txsoft(zst, tp);
	}

	splx(s);
}

struct zsops zsops_tty = {
	zstty_rxint,	/* receive char available */
	zstty_stint,	/* external/status */
	zstty_txint,	/* xmit buffer empty */
	zstty_softint,	/* process software interrupt */
};
@


1.26
log
@Do what the comments suggest and check for port-[ab]-ignore-cd properties,
and if so, force soft carrier mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.25 2014/07/13 23:10:23 deraadt Exp $	*/
d333 1
a333 1
#if defined(__sparc__) || defined(__sparc64__)
@


1.25
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.24 2013/04/21 14:44:16 sebastia Exp $	*/
d289 3
d797 2
@


1.24
log
@Unify the zs tty driver.

Most of the hard work by mpi@@, who provided the initial diff.
Fixes for sparc from myself. Tested on sgi and sparc myself.
Compiles and detects zstty on my powerbook, compile tested on
sparc64 by me. Real testing with zs device on sparc64 by miod@@
who also gave a lot of help and feedback.

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.22 2010/07/02 17:27:01 nicm Exp $	*/
d345 2
a346 2
	zst->zst_rbuf = malloc(zstty_rbuf_size << 1, M_DEVBUF, M_WAITOK);
	zst->zst_ebuf = zst->zst_rbuf + (zstty_rbuf_size << 1);
@


1.23
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 32
a32 2
/*	$OpenBSD: z8530tty.c,v 1.22 2010/06/28 14:13:33 deraadt Exp $ */
/*	$NetBSD: z8530tty.c,v 1.13 1996/10/16 20:42:14 gwr Exp $	*/
d90 1
a90 1
 *	Gordon Ross <gwr@@netbsd.org>,
d93 3
d114 1
a114 3
#ifdef KGDB
extern int zs_check_kgdb();
#endif
d133 4
d141 1
a141 1
int zstty_rbuf_size = ZSTTY_RING_SIZE;
d143 3
a145 2
/* This should usually be 3/4 of ZSTTY_RING_SIZE */
int zstty_rbuf_hiwat = (ZSTTY_RING_SIZE - (ZSTTY_RING_SIZE >> 2));
d152 1
a152 17
	int zst_hwflags;	/* see z8530var.h */
	int zst_swflags;	/* TIOCFLAG_SOFTCAR, ... <ttycom.h> */

	/*
	 * Printing an overrun error message often takes long enough to
	 * cause another overrun, so we only print one per second.
	 */
	long	zst_rotime;		/* time of last ring overrun */
	long	zst_fotime;		/* time of last fifo overrun */

	/*
	 * The receive ring buffer.
	 */
	int	zst_rbget;	/* ring buffer `get' index */
	volatile int	zst_rbput;	/* ring buffer `put' index */
	int	zst_ringmask;
	int	zst_rbhiwat;
d154 14
a167 1
	u_short	*zst_rbuf; /* rr1, data pairs */
d175 3
a177 3
	int 	zst_tbc;			/* transmit byte count */
	caddr_t	zst_tba;			/* transmit buffer address */
	int 	zst_heldtbc;		/* held tbc while xmission stopped */
d180 16
a195 7
	volatile char zst_rx_blocked;	/* input block at ring */
	volatile char zst_rx_overrun;	/* ring overrun */
	volatile char zst_tx_busy;	/* working on an output chunk */
	volatile char zst_tx_done;	/* done with one output chunk */
	volatile char zst_tx_stopped;	/* H/W level stop (lost CTS) */
	volatile char zst_st_check;	/* got a status interrupt */
	char pad[2];
a197 1

d199 2
a200 2
static int	zstty_match(struct device *, void *, void *);
static void	zstty_attach(struct device *, struct device *, void *);
d202 1
a202 1
struct cfattach zstty_ca = {
d206 1
a206 3
struct cfdriver zstty_cd = {
	NULL, "zstty", DV_TTY
};
d210 27
a236 2
/* Routines called from other code. */
cdev_decl(zs);	/* open, close, read, write, ioctl, stop, ... */
a237 10
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);
static void	zs_modem(struct zstty_softc *zst, int onoff);
static int	zshwiflow(struct tty *, int);
static void	zs_hwiflow(struct zstty_softc *, int);
static void	zstty_rxint(register struct zs_chanstate *);
static void	zstty_txint(register struct zs_chanstate *);
static void	zstty_stint(register struct zs_chanstate *);
static void	zstty_softint(struct zs_chanstate *);
static void	zsoverrun(struct zstty_softc *, long *, char *);
d241 2
a242 4
int 
zstty_match(parent, match, aux)
	struct device *parent;
	void   *match, *aux;
d244 1
a244 1
	struct cfdata *cf = match;
d258 2
a259 5
void 
zstty_attach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;

d261 3
a263 2
	struct zsc_softc *zsc = (void *) parent;
	struct zstty_softc *zst = (void *) self;
a265 1
	struct cfdata *cf;
d267 1
a267 1
	int channel, tty_unit;
d269 5
a274 1
	cf = zst->zst_dev.dv_cfdata;
d277 1
a277 1
	cs = &zsc->zsc_cs[channel];
d284 1
a284 1
	dev = makedev(ZSTTY_MAJOR, tty_unit);
d289 26
a314 3
	if (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)
		printf(": console");
	else {
d316 1
d318 2
a319 4
		 * Allow kgdb to "take over" this port.  If this port is
		 * NOT the kgdb port, zs_check_kgdb() will return zero.
		 * If it IS the kgdb port, it will print "kgdb,...\n"
		 * and then return non-zero.
d321 13
a333 7
		if (zs_check_kgdb(cs, dev)) {
			/*
			 * This is the kgdb port (exclusive use)
			 * so skip the normal attach code.
			 */
			return;
		}
d335 1
a335 1
	}
d345 12
a356 4
	zst->zst_rbhiwat =  zstty_rbuf_size;	/* impossible value */
	zst->zst_ringmask = zstty_rbuf_size - 1;
	zst->zst_rbuf = malloc(zstty_rbuf_size * sizeof(zst->zst_rbuf[0]),
			      M_DEVBUF, M_WAITOK);
d361 14
a374 14
	if (zst->zst_hwflags & ZS_HWFLAG_CONSOLE) {
		/* This unit is the console. */
		zst->zst_swflags |= TIOCFLAG_SOFTCAR;
		/* Call _param so interrupts get enabled. */
		cs->cs_defspeed = zs_getspeed(cs);
		tp->t_ispeed = cs->cs_defspeed;
		tp->t_ospeed = cs->cs_defspeed;
		tp->t_cflag = ZSTTY_DEF_CFLAG;
		(void) zsparam(tp, &tp->t_termios);
	} else {
		/* Not the console; may need reset. */
		int reset, s;
		reset = (channel == 0) ?
			ZSWR9_A_RESET : ZSWR9_B_RESET;
d376 9
a384 1
		zs_write_reg(cs, 9, reset);
d386 10
d398 5
a402 7
	/*
	 * Initialize state of modem control lines (DTR).
	 * If softcar is set, turn on DTR now and leave it.
	 * otherwise, turn off DTR now, and raise in open.
	 * (Keeps modem from answering too early.)
	 */
	zs_modem(zst, (zst->zst_swflags & TIOCFLAG_SOFTCAR) ? 1 : 0);
d410 1
a410 2
zstty(dev)
	dev_t dev;
d412 1
a412 2
	struct zstty_softc *zst;
	int unit = minor(dev);
a413 5
#ifdef	DIAGNOSTIC
	if (unit >= zstty_cd.cd_ndevs)
		panic("zstty");
#endif
	zst = zstty_cd.cd_devs[unit];
d418 48
d470 1
a470 5
zsopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
a471 2
	register struct tty *tp;
	register struct zs_chanstate *cs;
d473 7
a479 1
	int error, s, unit;
d481 1
a481 4
	unit = minor(dev);
	if (unit >= zstty_cd.cd_ndevs)
		return (ENXIO);
	zst = zstty_cd.cd_devs[unit];
d484 1
d492 3
a494 5
	/* It's simpler to do this up here. */
	if (((tp->t_state & (TS_ISOPEN | TS_XCLUDE))
	     ==             (TS_ISOPEN | TS_XCLUDE))
	    && (suser(p, 0) != 0) )
	{
a495 1
	}
d499 69
a567 2
	if ((tp->t_state & TS_ISOPEN) == 0) {
		/* First open. */
a568 12
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = ZSTTY_DEF_CFLAG;
		if (zst->zst_swflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (zst->zst_swflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (zst->zst_swflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = cs->cs_defspeed;
		(void) zsparam(tp, &tp->t_termios);
d570 27
a596 7
		/* Flush any pending input. */
		zst->zst_rbget = zst->zst_rbput;
		zs_iflush(cs);	/* XXX */
		/* Turn on DTR */
		zs_modem(zst, 1);
		if (zst->zst_swflags & TIOCFLAG_SOFTCAR) {
			tp->t_state |= TS_CARR_ON;
d598 1
d600 1
d602 13
d616 17
a632 2
	/* Wait for carrier. */
	for (;;) {
d634 4
a637 5
		/* Might never get status intr if carrier already on. */
		cs->cs_rr0 = zs_read_csr(cs);
		if (cs->cs_rr0 & ZSRR0_DCD) {
			tp->t_state |= TS_CARR_ON;
			break;
d640 2
a641 4
		if ((tp->t_state & TS_CARR_ON) ||
		    (tp->t_cflag & CLOCAL) ||
		    (flags & O_NONBLOCK) )
		{
d643 7
a651 3
		tp->t_state |= TS_WOPEN;
		error = ttysleep(tp, (caddr_t)&tp->t_rawq,
			TTIPRI | PCATCH, ttopen, 0);
d653 4
a656 2
			if ((tp->t_state & TS_ISOPEN) == 0) {
				/* Never get here with softcar */
d658 4
a661 1
				tp->t_state &= ~TS_WOPEN;
d664 3
d669 2
d676 14
a689 1
		error = linesw[tp->t_line].l_open(dev, tp, p);
d698 1
a698 5
zsclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
d700 4
a703 8
	struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register struct tty *tp;
	int hup;

	zst = zstty_cd.cd_devs[minor(dev)];
	cs = zst->zst_cs;
	tp = zst->zst_tty;
d706 1
a706 1
	if ((tp->t_state & TS_ISOPEN) == 0)
d710 13
a722 7
	hup = tp->t_cflag & HUPCL;
	if (zst->zst_swflags & TIOCFLAG_SOFTCAR)
		hup = 0;
	if (hup) {
		zs_modem(zst, 0);
		/* hold low for 1 second */
		(void) tsleep((caddr_t)cs, TTIPRI, ttclos, hz);
a723 4
	if (cs->cs_creg[5] & ZSWR5_BREAK) {
		zs_break(cs, 0);
	}
	/* XXX - turn off interrupts? */
a724 1
	ttyclose(tp);
d732 1
a732 4
zsread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d734 2
a735 2
	register struct zstty_softc *zst;
	register struct tty *tp;
d737 1
a737 3
	zst = zstty_cd.cd_devs[minor(dev)];
	tp = zst->zst_tty;
	return (linesw[tp->t_line].l_read(tp, uio, flags));
d741 1
a741 4
zswrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d743 2
a744 2
	register struct zstty_softc *zst;
	register struct tty *tp;
d746 1
a746 3
	zst = zstty_cd.cd_devs[minor(dev)];
	tp = zst->zst_tty;
	return (linesw[tp->t_line].l_write(tp, uio, flags));
a748 3
#define TIOCFLAG_ALL (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | \
                      TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF )

d750 7
a756 15
zsioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	register struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register struct tty *tp;
	register int error, tmp;

	zst = zstty_cd.cd_devs[minor(dev)];
	cs = zst->zst_cs;
	tp = zst->zst_tty;
d761 1
d766 10
a776 1

d791 3
a793 11
		if (error != 0)
			return (EPERM);
		tmp = *(int *)data;
		/* Check for random bits... */
		if (tmp & ~TIOCFLAG_ALL)
			return(EINVAL);
		/* Silently enforce softcar on the console. */
		if (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)
			tmp |= TIOCFLAG_SOFTCAR;
		/* These flags take effect during open. */
		zst->zst_swflags = tmp;
d807 3
d811 3
d815 2
a816 1
		return (ENOTTY);
d818 4
a821 1
	return (0);
d827 8
a834 10
static void
zsstart(tp)
	register struct tty *tp;
{
	register struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register int s, nch;

	zst = zstty_cd.cd_devs[minor(tp->t_dev)];
	cs = zst->zst_cs;
d837 4
d842 2
a843 4
	/*
	 * If currently active or delaying, no need to do anything.
	 */
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))
d846 3
a848 6
	/*
	 * If under CRTSCTS hfc and halted, do nothing
	 */
	if (tp->t_cflag & CRTSCTS)
		if (zst->zst_tx_stopped)
			goto out;
d850 3
a852 5
	/*
	 * If there are sleepers, and output has drained below low
	 * water mark, awaken.
	 */
	ttwakeupwr(tp);
d854 9
a862 2
	nch = ndqb(&tp->t_outq, 0);	/* XXX */
	(void) splzs();
d864 4
a867 2
	if (nch) {
		register char *p = tp->t_outq.c_cf;
a868 18
		/* mark busy, enable tx done interrupts, & send first byte */
		tp->t_state |= TS_BUSY;
		zst->zst_tx_busy = 1;
		cs->cs_preg[1] |= ZSWR1_TIE;
		cs->cs_creg[1] = cs->cs_preg[1];
		zs_write_reg(cs, 1, cs->cs_creg[1]);
		zs_write_data(cs, *p);
		zst->zst_tba = p + 1;
		zst->zst_tbc = nch - 1;
	} else {
		/*
		 * Nothing to send, turn off transmit done interrupts.
		 * This is useful if something is doing polled output.
		 */
		cs->cs_preg[1] &= ~ZSWR1_TIE;
		cs->cs_creg[1] = cs->cs_preg[1];
		zs_write_reg(cs, 1, cs->cs_creg[1]);
	}
d877 1
a877 3
zsstop(tp, flag)
	struct tty *tp;
	int flag;
d879 2
a880 6
	register struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register int s;

	zst = zstty_cd.cd_devs[minor(tp->t_dev)];
	cs = zst->zst_cs;
d883 2
a884 6
	if (tp->t_state & TS_BUSY) {
		/*
		 * Device is transmitting; must stop it.
		 * Also clear _heldtbc to prevent any
		 * flow-control event from resuming.
		 */
d887 2
a888 2
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
d891 1
a891 1
	return (0);
a897 1
 * XXX - Only whack the UART when params change...
d899 9
a907 9
static int
zsparam(tp, t)
	register struct tty *tp;
	register struct termios *t;
{
	register struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register int s, bps, cflag, tconst;
	u_char tmp3, tmp4, tmp5;
d909 2
a910 2
	zst = zstty_cd.cd_devs[minor(tp->t_dev)];
	cs = zst->zst_cs;
d912 2
a913 3
	/* XXX: Need to use an MD function for this. */
	bps = t->c_ospeed;
	if (bps < 0 || (t->c_ispeed && t->c_ispeed != bps))
d915 1
a915 7
	if (bps == 0) {
		/* stty 0 => drop DTR and RTS */
		zs_modem(zst, 0);
		return (0);
	}
	tconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);
	if (tconst < 0)
d918 9
a926 5
	/* Convert back to make sure we can do it. */
	bps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);
	if (bps != t->c_ospeed)
		return (EINVAL);
	tp->t_ispeed = tp->t_ospeed = bps;
d928 8
a935 2
	cflag = t->c_cflag;
	tp->t_cflag = cflag;
d938 3
a940 2
	 * Block interrupts so that state will not
	 * be altered until we are done setting it up.
d942 6
a947 1
	s = splzs();
d950 3
d956 1
d958 1
d960 4
a963 2
	cs->cs_preg[12] = tconst;
	cs->cs_preg[13] = tconst >> 8;
d965 6
a970 1
	switch (cflag & CSIZE) {
d972 2
a973 2
		tmp3 = ZSWR3_RX_5;
		tmp5 = ZSWR5_TX_5;
d976 2
a977 2
		tmp3 = ZSWR3_RX_6;
		tmp5 = ZSWR5_TX_6;
d980 2
a981 2
		tmp3 = ZSWR3_RX_7;
		tmp5 = ZSWR5_TX_7;
d984 2
a985 3
	default:
		tmp3 = ZSWR3_RX_8;
		tmp5 = ZSWR5_TX_8;
d988 2
d991 15
a1005 8
	cs->cs_preg[3] = tmp3 | ZSWR3_RX_ENABLE;
	cs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;

	tmp4 = ZSWR4_CLK_X16 | (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);
	if ((cflag & PARODD) == 0)
		tmp4 |= ZSWR4_EVENP;
	if (cflag & PARENB)
		tmp4 |= ZSWR4_PARENB;
d1008 4
a1011 13
	/*
	 * Output hardware flow control on the chip is horrendous:
	 * if carrier detect drops, the receiver is disabled.
	 * Therefore, NEVER set the HFC bit, and instead use
	 * the status interrupts to detect CTS changes.
	 */
	if (cflag & CRTSCTS) {
		zst->zst_rbhiwat = zstty_rbuf_hiwat;
		cs->cs_preg[15] |= ZSWR15_CTS_IE;
	} else {
		zst->zst_rbhiwat = zstty_rbuf_size; /* impossible value */
		cs->cs_preg[15] &= ~ZSWR15_CTS_IE;
	}
d1017 1
a1017 1
	if (cs->cs_heldchange == 0) {
d1021 2
a1022 2
			cs->cs_heldchange = 0xFF; /* XXX */
		} else {
d1024 14
d1039 7
d1047 7
d1055 14
d1073 27
d1102 1
d1104 31
a1134 4
static void
zs_modem(zst, onoff)
	struct zstty_softc *zst;
	int onoff;
d1136 15
a1150 3
	struct zs_chanstate *cs;
	struct tty *tp;
	int s, bis, and;
d1152 3
a1154 2
	cs = zst->zst_cs;
	tp = zst->zst_tty;
d1156 4
a1159 6
	if (onoff) {
		bis = ZSWR5_DTR | ZSWR5_RTS;
		and = ~0;
	} else {
		bis = 0;
		and = ~(ZSWR5_DTR | ZSWR5_RTS);
d1161 2
a1162 3
	s = splzs();
	cs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;
	if (cs->cs_heldchange == 0) {
d1166 3
a1168 5
			cs->cs_heldchange = (1<<5);
		} else {
			cs->cs_creg[5] = cs->cs_preg[5];
			zs_write_reg(cs, 5, cs->cs_creg[5]);
		}
d1170 28
a1197 1
	splx(s);
d1204 1
a1204 1
 * be set or cleared according to the "stop" arg passed.
d1207 1
a1207 3
zshwiflow(tp, stop)
	struct tty *tp;
	int stop;
d1209 2
a1210 1
	register struct zstty_softc *zst;
d1213 2
a1214 1
	zst = zstty_cd.cd_devs[minor(tp->t_dev)];
d1217 5
a1221 8
	if (stop) {
		/*
		 * The tty layer is asking us to block input.
		 * If we already did it, just return TRUE.
		 */
		if (zst->zst_rx_blocked)
			goto out;
		zst->zst_rx_blocked = 1;
d1223 9
a1231 5
		/*
		 * The tty layer is asking us to resume input.
		 * The input ring is always empty by now.
		 */
		zst->zst_rx_blocked = 0;
a1232 2
	zs_hwiflow(zst, stop);
 out:
d1234 1
a1234 1
	return 1;
d1239 1
a1239 1
 * called at splzs
d1241 7
a1247 8
static void
zs_hwiflow(zst, stop)
	register struct zstty_softc *zst;
	int stop;
{
	register struct zs_chanstate *cs;
	register struct tty *tp;
	register int bis, and;
d1249 1
a1249 2
	cs = zst->zst_cs;
	tp = zst->zst_tty;
d1251 3
a1253 4
	if (stop) {
		/* Block input (Lower RTS) */
		bis = 0;
		and = ~ZSWR5_RTS;
d1255 2
a1256 15
		/* Unblock input (Raise RTS) */
		bis = ZSWR5_RTS;
		and = ~0;
	}

	cs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;
	if (cs->cs_heldchange == 0) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = (1<<5);
		} else {
			cs->cs_creg[5] = cs->cs_preg[5];
			zs_write_reg(cs, 5, cs->cs_creg[5]);
		}
d1258 1
d1266 4
d1272 2
a1273 2
 * receiver ready interrupt.
 * called at splzs
d1275 7
a1281 8
static void
zstty_rxint(cs)
	register struct zs_chanstate *cs;
{
	register struct zstty_softc *zst;
	register int cc, put, put_next, ringmask;
	register u_char c, rr0, rr1;
	register u_short ch_rr1;
d1283 1
a1283 1
	zst = cs->cs_private;
d1285 1
a1285 1
	ringmask = zst->zst_ringmask;
d1287 7
a1293 1
nextchar:
d1295 4
a1298 7
	/*
	 * First read the status, because reading the received char
	 * destroys the status of this char.
	 */
	rr1 = zs_read_reg(cs, 1);
	c = zs_read_data(cs);
	ch_rr1 = (c << 8) | rr1;
d1300 6
a1305 4
	if (ch_rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {
		/* Clear the receive error. */
		zs_write_csr(cs, ZSWR0_RESET_ERRORS);
	}
d1307 3
a1309 11
	/* XXX: Check for the stop character? */

	zst->zst_rbuf[put] = ch_rr1;
	put_next = (put + 1) & ringmask;

	/* Would overrun if increment makes (put==get). */
	if (put_next == zst->zst_rbget) {
		zst->zst_rx_overrun = 1;
	} else {
		/* OK, really increment. */
		put = put_next;
d1312 6
a1317 6
	/* Keep reading until the FIFO is empty. */
	rr0 = zs_read_csr(cs);
	if (rr0 & ZSRR0_RX_READY)
		goto nextchar;

	/* Done reading. */
d1319 5
d1326 2
a1327 1
	 * If ring is getting too full, try to block input.
d1329 4
a1332 6
	cc = put - zst->zst_rbget;
	if (cc < 0)
		cc += zstty_rbuf_size;
	if ((cc > zst->zst_rbhiwat) && (zst->zst_rx_blocked == 0)) {
		zst->zst_rx_blocked = 1;
		zs_hwiflow(zst, 1);
d1335 10
a1344 2
	/* Ask for softint() call. */
	cs->cs_softreq = 1;
d1348 2
a1349 1
 * transmitter ready interrupt.  (splzs)
d1351 2
a1352 3
static void
zstty_txint(cs)
	register struct zs_chanstate *cs;
d1354 2
a1355 2
	register struct zstty_softc *zst;
	register int count;
d1357 1
a1357 1
	zst = cs->cs_private;
d1360 2
a1361 6
	 * If we suspended output for a "held" change,
	 * then handle that now and resume.
	 * Do flow-control changes ASAP.
	 * When the only change is for flow control,
	 * avoid hitting other registers, because that
	 * often makes the stupid zs drop input...
d1364 1
a1364 6
		if (cs->cs_heldchange == (1<<5)) {
			/* Avoid whacking the chip... */
			cs->cs_creg[5] = cs->cs_preg[5];
			zs_write_reg(cs, 5, cs->cs_creg[5]);
		} else
			zs_loadchannelregs(cs);
d1366 8
a1373 3
		count = zst->zst_heldtbc;
	} else
		count = zst->zst_tbc;
a1374 7
	/*
	 * If our transmit buffer still has data,
	 * just send the next character.
	 */
	if (count > 0) {
		/* Send the next char. */
		zst->zst_tbc = --count;
d1376 1
a1377 1
		return;
d1380 8
a1387 1
	zs_write_csr(cs, ZSWR0_RESET_TXINT);
d1389 6
a1394 5
	/* Ask the softint routine for more output. */
	zst->zst_tx_busy = 0;
	zst->zst_tx_done = 1;
	cs->cs_softreq = 1;
}
d1397 2
a1398 1
 * status change interrupt.  (splzs)
d1400 2
a1401 3
static void
zstty_stint(cs)
	register struct zs_chanstate *cs;
d1403 3
a1405 6
	register struct zstty_softc *zst;
	register struct tty *tp;
	register u_char rr0;

	zst = cs->cs_private;
	tp  = zst->zst_tty;
d1414 28
a1441 5
	if ((rr0 & ZSRR0_BREAK) &&
		(zst->zst_hwflags & ZS_HWFLAG_CONSOLE))
	{
		zs_abort();
		return;
d1443 8
d1452 88
a1539 11
	/*
	 * Need to handle CTS output flow control here.
	 * Output remains stopped as long as either the
	 * zst_tx_stopped or TS_TTSTOP flag is set.
	 * Never restart here; the softint routine will
	 * do that after things are ready to move.
	 */
	if (((rr0 & ZSRR0_CTS) == 0) && (tp->t_cflag & CRTSCTS)) {
		zst->zst_tbc = 0;
		zst->zst_heldtbc = 0;
		zst->zst_tx_stopped = 1;
d1542 20
a1561 8
	/*
	 * We have to accumulate status line changes here.
	 * Otherwise, if we get multiple status interrupts
	 * before the softint runs, we could fail to notice
	 * some status line changes in the softint routine.
	 * Fix from Bill Studenmund, October 1996.
	 */
	cs->cs_rr0_delta |= (cs->cs_rr0 ^ rr0);
d1563 4
a1566 2
	ttytstamp(tp, cs->cs_rr0 & ZSRR0_CTS, rr0 & ZSRR0_CTS,
	    cs->cs_rr0 & ZSRR0_DCD, rr0 & ZSRR0_DCD);
d1568 9
a1576 5
	cs->cs_rr0 = rr0;
	zst->zst_st_check = 1;

	/* Ask for softint() call. */
	cs->cs_softreq = 1;
d1579 2
a1580 8
/*
 * Print out a ring or fifo overrun error message.
 */
static void
zsoverrun(zst, ptime, what)
	struct zstty_softc *zst;
	long *ptime;
	char *what;
d1582 16
d1599 8
a1606 4
	if (*ptime != time_second) {
		*ptime = time_second;
		log(LOG_WARNING, "%s: %s overrun\n",
			zst->zst_dev.dv_xname, what);
d1622 2
a1623 3
static void
zstty_softint(cs)
	struct zs_chanstate *cs;
d1625 3
a1627 13
	register struct zstty_softc *zst;
	register struct linesw *line;
	register struct tty *tp;
	register int get, c, s;
	int ringmask, overrun;
	register u_short ring_data;
	register u_char rr0, delta;

	zst  = cs->cs_private;
	tp   = zst->zst_tty;
	line = &linesw[tp->t_line];
	ringmask = zst->zst_ringmask;
	overrun = 0;
a1628 3
	/*
	 * Raise to tty priority while servicing the ring.
	 */
d1631 3
a1633 23
	if (zst->zst_rx_overrun) {
		zst->zst_rx_overrun = 0;
		zsoverrun(zst, &zst->zst_rotime, "ring");
	}

	/*
	 * Copy data from the receive ring into the tty layer.
	 */
	get = zst->zst_rbget;
	while (get != zst->zst_rbput) {
		ring_data = zst->zst_rbuf[get];
		get = (get + 1) & ringmask;

		if (ring_data & ZSRR1_DO)
			overrun++;
		/* low byte of ring_data is rr1 */
		c = (ring_data >> 8) & 0xff;
		if (ring_data & ZSRR1_FE)
			c |= TTY_FE;
		if (ring_data & ZSRR1_PE)
			c |= TTY_PE;

		line->l_rint(c, tp);
a1634 1
	zst->zst_rbget = get;
a1635 27
	/*
	 * If the overrun flag is set now, it was set while
	 * copying char/status pairs from the ring, which
	 * means this was a hardware (fifo) overrun.
	 */
	if (overrun) {
		zsoverrun(zst, &zst->zst_fotime, "fifo");
	}

	/*
	 * We have emptied the input ring.  Maybe unblock input.
	 * Note: an "input blockage" condition is assumed to exist
	 * when EITHER zst_rx_blocked or the TS_TBLOCK flag is set,
	 * so unblock here ONLY if TS_TBLOCK has not been set.
	 */
	if (zst->zst_rx_blocked && ((tp->t_state & TS_TBLOCK) == 0)) {
		(void) splzs();
		zst->zst_rx_blocked = 0;
		zs_hwiflow(zst, 0);	/* unblock input */
		(void) spltty();
	}

	/*
	 * Do any deferred work for status interrupts.
	 * The rr0 was saved in the h/w interrupt to
	 * avoid another splzs in here.
	 */
d1638 1
a1638 20

		rr0 = cs->cs_rr0;
		delta = cs->cs_rr0_delta;
		cs->cs_rr0_delta = 0;
		if (delta & ZSRR0_DCD) {
			c = ((rr0 & ZSRR0_DCD) != 0);
			if (line->l_modem(tp, c) == 0)
				zs_modem(zst, c);
		}
		if ((delta & ZSRR0_CTS) && (tp->t_cflag & CRTSCTS)) {
			/*
			 * Only do restart here.  Stop is handled
			 * at the h/w interrupt level.
			 */
			if (rr0 & ZSRR0_CTS) {
				zst->zst_tx_stopped = 0;
				tp->t_state &= ~TS_TTSTOP;
				(*line->l_start)(tp);
			}
		}
d1643 1
a1643 7
		tp->t_state &= ~TS_BUSY;
		if (tp->t_state & TS_FLUSH)
			tp->t_state &= ~TS_FLUSH;
		else
			ndflush(&tp->t_outq, zst->zst_tba -
				(caddr_t) tp->t_outq.c_cf);
		line->l_start(tp);
a1654 1

@


1.22
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.21 2010/04/12 12:57:52 tedu Exp $ */
d603 1
a603 7
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
@


1.21
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.20 2009/11/09 17:53:39 nicm Exp $ */
d257 1
a257 1
	tp = ttymalloc();
@


1.20
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.19 2009/10/31 12:00:08 fgsch Exp $ */
d419 1
a419 1
		error = linesw[tp->t_line].l_open(dev, tp);
d447 1
a447 1
	(*linesw[tp->t_line].l_close)(tp, flags);
@


1.19
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.18 2009/10/31 06:40:17 deraadt Exp $ */
a608 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.18
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.17 2008/01/18 21:36:43 kettenis Exp $ */
d351 1
a351 1
	    && (p->p_ucred->cr_uid != 0) )
@


1.17
log
@Print consoleness the canonical way.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.16 2006/04/27 19:31:44 deraadt Exp $ */
d609 1
@


1.16
log
@2 lines of code in most drivers, to do the timestamping; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.15 2004/06/21 23:50:35 tholo Exp $ */
d237 1
a237 1
		printf(" (console)");
@


1.15
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.14 2003/10/03 16:44:51 miod Exp $ */
d1077 4
@


1.14
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.13 2003/08/15 20:32:17 tedu Exp $ */
d1094 2
a1095 2
	if (*ptime != time.tv_sec) {
		*ptime = time.tv_sec;
@


1.13
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.12 2003/06/02 23:28:02 millert Exp $ */
a261 1
	tty_attach(tp);
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.11 2002/03/14 01:26:55 millert Exp $ */
d539 1
a539 1
		error = suser(p->p_ucred, &p->p_acflag);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.10 1997/01/15 05:35:47 kstailey Exp $ */
d26 1
a26 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@more missing prototypes and other warnings fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.9 1996/12/16 00:11:58 kstailey Exp $ */
d178 10
a187 10
static void	zsstart __P((struct tty *));
static int	zsparam __P((struct tty *, struct termios *));
static void	zs_modem __P((struct zstty_softc *zst, int onoff));
static int	zshwiflow __P((struct tty *, int));
static void	zs_hwiflow __P((struct zstty_softc *, int));
static void	zstty_rxint __P((register struct zs_chanstate *));
static void	zstty_txint __P((register struct zs_chanstate *));
static void	zstty_stint __P((register struct zs_chanstate *));
static void	zstty_softint __P((struct zs_chanstate *));
static void	zsoverrun __P((struct zstty_softc *, long *, char *));
@


1.10.24.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.10 1997/01/15 05:35:47 kstailey Exp $ */
d178 10
a187 10
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);
static void	zs_modem(struct zstty_softc *zst, int onoff);
static int	zshwiflow(struct tty *, int);
static void	zs_hwiflow(struct zstty_softc *, int);
static void	zstty_rxint(register struct zs_chanstate *);
static void	zstty_txint(register struct zs_chanstate *);
static void	zstty_stint(register struct zs_chanstate *);
static void	zstty_softint(struct zs_chanstate *);
static void	zsoverrun(struct zstty_softc *, long *, char *);
@


1.10.14.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d178 10
a187 10
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);
static void	zs_modem(struct zstty_softc *zst, int onoff);
static int	zshwiflow(struct tty *, int);
static void	zs_hwiflow(struct zstty_softc *, int);
static void	zstty_rxint(register struct zs_chanstate *);
static void	zstty_txint(register struct zs_chanstate *);
static void	zstty_stint(register struct zs_chanstate *);
static void	zstty_softint(struct zs_chanstate *);
static void	zsoverrun(struct zstty_softc *, long *, char *);
@


1.10.14.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.10.14.1 2002/03/28 12:11:34 niklas Exp $ */
d26 5
a30 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.14.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d262 1
d539 1
a539 1
		error = suser(p, 0);
@


1.9
log
@add "return (0)" to end of zsstop() since it's not a void function anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.8 1996/12/03 05:21:46 kstailey Exp $ */
d178 10
a187 6
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);
static void zs_modem(struct zstty_softc *zst, int onoff);
static int	zshwiflow(struct tty *, int);
static void zs_hwiflow(struct zstty_softc *, int);

d442 1
a442 2
	struct zsinfo *zi;
	int hup, s;
d689 1
a689 1
	u_char tmp3, tmp4, tmp5, reset;
d1128 1
a1128 1
	register u_char rr0, rr1, delta;
@


1.8
log
@void zsstop() -> int zsstop()
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.7 1996/11/28 23:27:57 niklas Exp $ */
d669 1
@


1.7
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.6 1996/06/18 10:23:03 deraadt Exp $ */
d644 1
a644 1
void
@


1.6
log
@fix a type mismatch
@
text
@d1 2
a2 2
/*	$OpenBSD: z8530tty.c,v 1.5 1996/06/10 07:34:14 deraadt Exp $ */
/*	$NetBSD: z8530tty.c,v 1.8.4.2 1996/06/13 23:11:56 gwr Exp $	*/
d644 1
a644 1
int
a668 1
	return (0);
d1070 9
a1078 1
	cs->cs_rr0_new = rr0;
d1193 3
a1195 3
		rr0 = cs->cs_rr0_new;
		delta = rr0 ^ cs->cs_rr0;
		cs->cs_rr0 = rr0;
@


1.5
log
@tty_attach()
@
text
@d1 2
a2 2
/*	$OpenBSD: z8530tty.c,v 1.4 1996/05/26 00:27:08 deraadt Exp $ */
/*	$NetBSD: z8530tty.c,v 1.8.4.1 1996/06/03 20:01:07 gwr Exp $	*/
d780 1
a780 1
			cs->cs_heldchange = 0xFFFF;
@


1.4
log
@sync 0521
@
text
@d1 2
a2 2
/*	$OpenBSD: z8530tty.c,v 1.3 1996/04/21 22:21:46 deraadt Exp $ */
/*	$NetBSD: z8530tty.c,v 1.8 1996/05/17 22:49:23 gwr Exp $	*/
d262 1
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: z8530tty.c,v 1.6 1996/04/10 21:44:47 gwr Exp $	*/
d54 13
d112 3
d123 16
a138 5
	/* Flags to communicate with zstty_softint() */
	volatile int zst_intr_flags;
#define	INTR_RX_OVERRUN 1
#define INTR_TX_EMPTY   2
#define INTR_ST_CHECK   4
d150 8
a157 14
	/*
	 * Printing an overrun error message often takes long enough to
	 * cause another overrun, so we only print one per second.
	 */
	long	zst_rotime;		/* time of last ring overrun */
	long	zst_fotime;		/* time of last fifo overrun */

	/*
	 * The receive ring buffer.
	 */
	u_int	zst_rbget;	/* ring buffer `get' index */
	volatile u_int	zst_rbput;	/* ring buffer `put' index */
	u_int	zst_ringmask;
	u_short	*zst_rbuf; /* rr1, data pairs */
d181 2
d261 1
d264 1
d594 7
d613 2
d620 1
a620 2
		(void) splzs();

d622 1
a622 1
		cs->cs_creg[1] |= ZSWR1_TIE;
a631 1
		(void) splzs();
d633 1
a633 1
		cs->cs_creg[1] &= ~ZSWR1_TIE;
d659 2
d663 1
d690 1
a690 6
	/*
	 * Because PCLK is only run at 4.9 MHz, the fastest we
	 * can go is 51200 baud (this corresponds to TC=1).
	 * This is somewhat unfortunate as there is no real
	 * reason we should not be able to handle higher rates.
	 */
d699 1
a699 1
	tconst = BPS_TO_TCONST(cs->cs_pclk_div16, bps);
d704 1
a704 1
	bps = TCONST_TO_BPS(cs->cs_pclk_div16, tconst);
d747 1
a747 12
	/*
	 * Output hardware flow control on the chip is horrendous: if
	 * carrier detect drops, the receiver is disabled.  Hence we
	 * can only do this when the carrier is on.
	 */
	tmp3 |= ZSWR3_RX_ENABLE;
	if (cflag & CCTS_OFLOW) {
		if (zs_read_csr(cs) & ZSRR0_DCD)
			tmp3 |= ZSWR3_HFC;
	}

	cs->cs_preg[3] = tmp3;
d758 14
d776 1
a776 1
		if (tp->t_state & TS_BUSY) {
d779 1
a779 1
			cs->cs_heldchange = 1;
d814 1
a814 1
		if (tp->t_state & TS_BUSY) {
d817 1
a817 1
			cs->cs_heldchange = 1;
d819 1
a819 1
			cs->cs_creg[5] = (cs->cs_creg[5] | bis) & and;
d826 77
a907 3
/*
 * XXX: need to do input flow-control to avoid ring overrun.
 */
d910 2
a911 1
 * receiver ready interrupt.  (splzs)
d918 1
a918 1
	register put, put_next, ringmask;
d920 1
d934 1
d936 1
a936 1
	if (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {
d941 3
a943 1
	zst->zst_rbuf[put] = (c << 8) | rr1;
d948 1
a948 1
		zst->zst_intr_flags |= INTR_RX_OVERRUN;
d962 11
d988 20
a1007 1
	count = zst->zst_tbc;
d1024 2
a1025 1
	zst->zst_intr_flags |= INTR_TX_EMPTY;
a1046 20
	 * The chip's hardware flow control is, as noted in zsreg.h,
	 * busted---if the DCD line goes low the chip shuts off the
	 * receiver (!).  If we want hardware CTS flow control but do
	 * not have it, and carrier is now on, turn HFC on; if we have
	 * HFC now but carrier has gone low, turn it off.
	 */
	if (rr0 & ZSRR0_DCD) {
		if (tp->t_cflag & CCTS_OFLOW &&
			(cs->cs_creg[3] & ZSWR3_HFC) == 0) {
			cs->cs_creg[3] |= ZSWR3_HFC;
			zs_write_reg(cs, 3, cs->cs_creg[3]);
		}
	} else {
		if (cs->cs_creg[3] & ZSWR3_HFC) {
			cs->cs_creg[3] &= ~ZSWR3_HFC;
			zs_write_reg(cs, 3, cs->cs_creg[3]);
		}
	}

	/*
d1057 13
d1071 1
a1071 1
	zst->zst_intr_flags |= INTR_ST_CHECK;
d1096 9
d1114 1
a1114 1
	int intr_flags, ringmask;
d1116 1
a1116 1
	register u_char rr0, rr1;
d1122 1
a1122 5

	/* Atomically get and clear flags. */
	s = splzs();
	intr_flags = zst->zst_intr_flags;
	zst->zst_intr_flags = 0;
d1125 1
a1125 1
	 * Lower to tty priority while servicing the ring.
d1127 1
a1127 1
	(void) spltty();
d1129 2
a1130 3
	if (intr_flags & INTR_RX_OVERRUN) {
		/* May turn this on again below. */
		intr_flags &= ~INTR_RX_OVERRUN;
d1143 1
a1143 1
			intr_flags |= INTR_RX_OVERRUN;
d1160 1
a1160 1
	if (intr_flags & INTR_RX_OVERRUN) {
d1164 38
a1201 22
	if (intr_flags & INTR_TX_EMPTY) {
		/*
		 * The transmitter output buffer count is zero.
		 * If we suspended output for a "held" change,
		 * then handle that now and resume.  Otherwise,
		 * try to start a new output chunk.
		 */
		if (cs->cs_heldchange) {
			(void) splzs();
			rr0 = zs_read_csr(cs);
			if ((rr0 & ZSRR0_DCD) == 0)
				cs->cs_preg[3] &= ~ZSWR3_HFC;
			zs_loadchannelregs(cs);
			(void) spltty();
			cs->cs_heldchange = 0;
			if (zst->zst_heldtbc &&
				(tp->t_state & TS_TTSTOP) == 0)
			{
				zst->zst_tbc = zst->zst_heldtbc - 1;
				zs_write_data(cs, *zst->zst_tba);
				zst->zst_tba++;
				goto tx_resumed;
d1204 4
d1213 1
a1213 1
					(caddr_t) tp->t_outq.c_cf);
a1214 16
	tx_resumed:
	}

	if (intr_flags & INTR_ST_CHECK) {
		/*
		 * Status line change.  HFC bit is run in
		 * hardware interrupt, to avoid locking
		 * at splzs here.
		 */
		rr0 = cs->cs_rr0_new;
		if ((rr0 ^ cs->cs_rr0) & ZSRR0_DCD) {
			c = ((rr0 & ZSRR0_DCD) != 0);
			if (line->l_modem(tp, c) == 0)
				zs_modem(zst, c);
		}
		cs->cs_rr0 = rr0;
@


1.2
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: z8530tty.c,v 1.1 1996/01/24 01:07:25 gwr Exp $	*/
d63 1
d90 1
a90 1
#define	ZSTTY_RING_SIZE	1024
d92 6
a97 1
#define ZSTTY_RING_MASK (ZSTTY_RING_SIZE-1)
d135 2
a136 1
	u_short	zst_rbuf[ZSTTY_RING_SIZE]; /* rr1, data pairs */
d144 6
a149 3
struct cfdriver zsttycd = {
	NULL, "zstty", zstty_match, zstty_attach,
	DV_TTY, sizeof(struct zstty_softc), NULL,
d234 1
a234 1
	tp = zst->zst_tty = ttymalloc();
d239 5
d262 1
a262 1
		ZS_WRITE(cs, 9, reset);
d287 1
a287 1
	if (unit >= zsttycd.cd_ndevs)
d290 1
a290 1
	zst = zsttycd.cd_devs[unit];
d311 1
a311 1
	if (unit >= zsttycd.cd_ndevs)
d313 1
a313 1
	zst = zsttycd.cd_devs[unit];
a361 1
		register int rr0;
d364 2
a365 3
		rr0 = *(cs->cs_reg_csr);
		ZS_DELAY();
		if (rr0 & ZSRR0_DCD) {
d415 1
a415 1
	zst = zsttycd.cd_devs[minor(dev)];
d453 1
a453 1
	zst = zsttycd.cd_devs[minor(dev)];
d467 1
a467 1
	zst = zsttycd.cd_devs[minor(dev)];
d488 1
a488 1
	zst = zsttycd.cd_devs[minor(dev)];
d557 1
a557 1
	zst = zsttycd.cd_devs[minor(tp->t_dev)];
d590 2
a591 3
		ZS_WRITE(cs, 1, cs->cs_creg[1]);
		*(cs->cs_reg_data) = *p;
		ZS_DELAY();
d602 1
a602 1
		ZS_WRITE(cs, 1, cs->cs_creg[1]);
d620 1
a620 1
	zst = zsttycd.cd_devs[minor(tp->t_dev)];
d652 1
a652 1
	zst = zsttycd.cd_devs[minor(tp->t_dev)];
d724 1
a724 1
		if (*(cs->cs_reg_csr) & ZSRR0_DCD)
a725 1
		ZS_DELAY();
d787 1
a787 1
			ZS_WRITE(cs, 5, cs->cs_creg[5]);
d802 4
a805 1
static int
d810 1
a810 1
	register put, put_next;
d815 1
a817 3
	/* Read the input data ASAP. */
	c = *(cs->cs_reg_data);
	ZS_DELAY();
d819 6
a824 2
	/* Save the status register too. */
	rr1 = ZS_READ(cs, 1);
d828 1
a828 2
		*(cs->cs_reg_csr) = ZSWR0_RESET_ERRORS;
		ZS_DELAY();
d832 1
a832 1
	put_next = (put + 1) & ZSTTY_RING_MASK;
d843 1
a843 2
	rr0 = *(cs->cs_reg_csr);
	ZS_DELAY();
a851 1
	return(1);
d854 4
a857 1
static int
d862 1
a862 1
	register int count, rval;
d867 4
a872 2
		*(cs->cs_reg_data) = *zst->zst_tba++;
		ZS_DELAY();
d874 3
a876 7
		rval = 0;
	} else {
		/* Nothing more to send. */
		*(cs->cs_reg_csr) = ZSWR0_RESET_TXINT;
		ZS_DELAY();
		zst->zst_intr_flags |= INTR_TX_EMPTY;
		rval = 1;	/* want softcall */
d879 5
a883 2
	cs->cs_softreq = rval;
	return (rval);
d886 4
a889 1
static int
d894 2
a895 1
	register int rr0;
d898 1
d900 2
a901 2
	rr0 = *(cs->cs_reg_csr);
	ZS_DELAY();
d903 19
a921 2
	*(cs->cs_reg_csr) = ZSWR0_RESET_STATUS;
	ZS_DELAY();
d923 5
a927 1
	if ((rr0 & ZSRR0_BREAK) && 
d931 1
a931 1
		return (0);
d934 1
d936 1
a938 1
	return (1);
d958 4
a961 1
static int
d969 1
a969 1
	int intr_flags;
d976 1
d982 5
a986 1
	splx(s);
d991 1
a991 1
		zsoverrun(zst, "ring");
d1000 1
a1000 1
		get = (get + 1) & ZSTTY_RING_MASK;
d1015 5
a1019 1
	/* If set, it is from the loop above. */
d1021 1
a1021 1
		zsoverrun(zst, "fifo");
d1026 4
a1029 2
		 * Transmit done.  Change registers and resume,
		 * or just clear BUSY.
d1032 2
a1033 3
			s = splzs();
			rr0 = *(cs->cs_reg_csr);
			ZS_DELAY();
d1037 1
a1037 1
			splx(s);
a1038 1

d1043 2
a1044 2
				*(cs->cs_reg_data) = *zst->zst_tba++;
				ZS_DELAY();
d1060 3
a1062 7
		 * Status line change.
		 *
		 * The chip's hardware flow control is, as noted in zsreg.h,
		 * busted---if the DCD line goes low the chip shuts off the
		 * receiver (!).  If we want hardware CTS flow control but do
		 * not have it, and carrier is now on, turn HFC on; if we have
		 * HFC now but carrier has gone low, turn it off.
d1064 1
a1064 17
		s = splzs();
		rr0 = *(cs->cs_reg_csr);
		if (rr0 & ZSRR0_DCD) {
			if (tp->t_cflag & CCTS_OFLOW &&
				(cs->cs_creg[3] & ZSWR3_HFC) == 0) {
				cs->cs_creg[3] |= ZSWR3_HFC;
				ZS_WRITE(cs, 3, cs->cs_creg[3]);
			}
		} else {
			if (cs->cs_creg[3] & ZSWR3_HFC) {
				cs->cs_creg[3] &= ~ZSWR3_HFC;
				ZS_WRITE(cs, 3, cs->cs_creg[3]);
			}
		}
		splx(s);

		/* Was there a change on DCD? */
d1073 1
a1073 1
	return (1);
d1082 1
@


1.1
log
@z8530 reorganization from gwr (which i think isn't nearly as machine
independent or correct as he thinks it is)
@
text
@d1 1
d189 1
a189 1
	tty_unit = cf->cf_unit;
a227 1
	tp->t_sc = zst; 	/* XXX - Quick access! */
d544 1
a544 1
	zst = tp->t_sc;
d608 1
a608 1
	zst = tp->t_sc;
d640 1
a640 1
	zst = tp->t_sc;
d787 4
a1045 1

@
