head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.28
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.26
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.24
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.18
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.20
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.12
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.16
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.14
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.10
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.8
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.4
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.6
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.4
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.26.0.4
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.6
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.23.0.6
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2;
locks; strict;
comment	@ * @;


1.29
date	2011.04.05.22.37.39;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2010.04.27.20.12.56;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.05.19.05.09;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.13.18.16.17;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.20.22.32.48;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.03.11.00.37;	author martin;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.10.16.27.23;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.08.17.30.18;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.12.22.22.26;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.16.20.30.06;	author avsm;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.14.22.37.48;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.06.22.24.14;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.01.17.15.06;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.16.04.37.29;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.16.00.53.12;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.05.17.25.58;	author art;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.10.30.00.02.55;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.26.02.39.05;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.25.23.14.40;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.24.18.28.10;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.15.06.01.29;	author krw;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.03.06.16.29.32;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.01.17.14.28;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.15.04.07.59;	author krw;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.24.14;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.10.41.10;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.4.4.7;

1.4.4.7
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	1.4.4.8;

1.4.4.8
date	2004.06.13.08.50.13;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.05.19.21.59.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@pull the dmamam wrapper in from all my other drivers and use it to replace
the siop command buffers and add dmaable buffers for sense data.

matthew@@ found that siop used to try to dma to the xs->sense bufer, which
is not guaranteed to be dma safe.
tested by matthew@@ kettenis@@
@
text
@/*	$OpenBSD: siopvar_common.h,v 1.28 2010/07/23 07:47:13 jsg Exp $ */
/*	$NetBSD: siopvar_common.h,v 1.33 2005/11/18 23:10:32 bouyer Exp $ */

/*
 * Copyright (c) 2000 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* common struct and routines used by siop and esiop */

#ifndef SIOP_DEFAULT_TARGET
#define SIOP_DEFAULT_TARGET 7
#endif

/* tables used by SCRIPT */
typedef struct scr_table {
	u_int32_t count;
	u_int32_t addr;
} __packed scr_table_t;

/* Number of scatter/gather entries */
/* XXX Ensure alignment of siop_xfer's. */
#define SIOP_NSG	17	/* XXX (MAXPHYS/PAGE_SIZE + 1) */
#define SIOP_MAXFER	((SIOP_NSG - 1) * PAGE_SIZE)

/*
 * This structure interfaces the SCRIPT with the driver; it describes a full
 * transfer. If you change something here, don't forget to update offsets in
 * {s,es}iop.ss
 */
struct siop_common_xfer {
	u_int8_t msg_out[16];		/*   0 */
	u_int8_t msg_in[16];		/*  16 */
	u_int32_t status;		/*  32 */
	u_int32_t pad1;			/*  36 */
	u_int32_t id;			/*  40 */
	struct scsi_generic xscmd; 	/*  44 */
	scr_table_t t_msgin;		/*  60 */
	scr_table_t t_extmsgin;		/*  68 */
	scr_table_t t_extmsgdata; 	/*  76 */
	scr_table_t t_msgout;		/*  84 */
	scr_table_t cmd;		/*  92 */
	scr_table_t t_status;		/* 100 */
	scr_table_t data[SIOP_NSG]; 	/* 108 */
} __packed;

/* status can hold the SCSI_* status values, and 2 additional values: */
#define SCSI_SIOP_NOCHECK	0xfe	/* don't check the scsi status */
#define SCSI_SIOP_NOSTATUS	0xff	/* device didn't report status */

/* offset is initialised to SIOP_NOOFFSET, used to check if it was updated */
#define SIOP_NOOFFSET 0xffffffff

/*
 * This describes a command handled by the SCSI controller
 */
struct siop_common_cmd {
	struct siop_common_softc *siop_sc; /* points back to our adapter */
	struct siop_common_target *siop_target; /* pointer to our target def */
	struct scsi_xfer *xs; /* xfer from the upper level */
	struct siop_common_xfer *siop_tables; /* tables for this cmd */
	struct scsi_sense_data *sense;
	bus_addr_t	dsa; /* DSA value to load */
	bus_dmamap_t	dmamap_data;
	int status;
	int flags;
	int tag;	/* tag used for tagged command queuing */
	int resid;	/* valid when CMDFL_RESID is set */
};

/* status defs */
#define CMDST_FREE		0 /* cmd slot is free */
#define CMDST_READY		1 /* cmd slot is waiting for processing */
#define CMDST_ACTIVE		2 /* cmd slot is being processed */
#define CMDST_SENSE		3 /* cmd slot is requesting sense */
#define CMDST_SENSE_ACTIVE	4 /* request sense active */
#define CMDST_SENSE_DONE 	5 /* request sense done */
#define CMDST_DONE		6 /* cmd slot has been processed */
/* flags defs */
#define CMDFL_TIMEOUT	0x0001 /* cmd timed out */
#define CMDFL_TAG	0x0002 /* tagged cmd */
#define CMDFL_RESID	0x0004 /* current offset in table is partial */

/* per-target struct */
struct siop_common_target {
	int status;	/* target status, see below */
	int flags;	/* target flags, see below */
	u_int32_t id;	/* for SELECT FROM */
	int period;
	int offset;
};

/* target status */
#define TARST_PROBING	0 /* target is being probed */
#define TARST_ASYNC	1 /* target needs sync/wide negotiation */
#define TARST_WIDE_NEG	2 /* target is doing wide negotiation */
#define TARST_SYNC_NEG	3 /* target is doing sync negotiation */
#define TARST_PPR_NEG	4 /* target is doing sync negotiation */
#define TARST_OK	5 /* sync/wide agreement is valid */

/* target flags */
#define TARF_SYNC	0x01 /* target can do sync */
#define TARF_WIDE	0x02 /* target can do wide */
#define TARF_TAG	0x04 /* target can do tags */
#define TARF_DT		0x08 /* target can do DT clocking */
#define TARF_ISWIDE	0x10 /* target is wide */
#define TARF_ISDT	0x20 /* target is doing DT clocking */

/* Driver internal state */
struct siop_common_softc {
	struct device sc_dev;
	struct scsi_link sc_link;	/* link to upper level */
	int features;			/* chip's features */
	int ram_size;
	int maxburst;
	int maxoff;
	int clock_div;			/* async. clock divider (scntl3) */
	int clock_period;		/* clock period (ns * 10) */
	int st_minsync;			/* min and max sync period, */
	int dt_minsync;
	int st_maxsync;			/* as sent in or PPR messages */
	int dt_maxsync;
	int mode;			/* current SE/LVD/HVD mode */
	bus_space_tag_t sc_rt;		/* bus_space registers tag */
	bus_space_handle_t sc_rh;	/* bus_space registers handle */
	bus_addr_t sc_raddr;		/* register addresses */
	bus_space_tag_t sc_ramt;	/* bus_space ram tag */
	bus_space_handle_t sc_ramh;	/* bus_space ram handle */
	bus_dma_tag_t sc_dmat;		/* bus DMA tag */
	void (*sc_reset)(struct siop_common_softc*); /* reset callback */
	bus_dmamap_t  sc_scriptdma;	/* DMA map for script */
	bus_addr_t sc_scriptaddr;	/* on-board ram or physical address */
	u_int32_t *sc_script;		/* script location in memory */
	struct siop_common_target *targets[16]; /* per-target states */
};

/* features */
#define SF_BUS_WIDE	0x00000001 /* wide bus */
#define SF_BUS_ULTRA	0x00000002 /* Ultra (20MHz) bus */
#define SF_BUS_ULTRA2	0x00000004 /* Ultra2 (40MHz) bus */
#define SF_BUS_ULTRA3	0x00000008 /* Ultra3 (80MHz) bus */
#define SF_BUS_DIFF	0x00000010 /* differential bus */

#define SF_CHIP_LED0	0x00000100 /* led on GPIO0 */
#define SF_CHIP_LEDC	0x00000200 /* led on GPIO0 with hardware control */
#define SF_CHIP_DBLR	0x00000400 /* clock doubler or quadrupler */
#define SF_CHIP_QUAD	0x00000800 /* clock quadrupler, with PPL */
#define SF_CHIP_FIFO	0x00001000 /* large fifo */
#define SF_CHIP_PF	0x00002000 /* Instructions prefetch */
#define SF_CHIP_RAM	0x00004000 /* on-board RAM */
#define SF_CHIP_LS	0x00008000 /* load/store instruction */
#define SF_CHIP_10REGS	0x00010000 /* 10 scratch registers */
#define SF_CHIP_DFBC	0x00020000 /* Use DFBC register */
#define SF_CHIP_DT	0x00040000 /* DT clocking */
#define SF_CHIP_GEBUG	0x00080000 /* SCSI gross error bug */
#define SF_CHIP_AAIP	0x00100000 /* Always generate AIP regardless of SNCTL4*/
#define SF_CHIP_BE	0x00200000 /* big-endian */

#define SF_PCI_RL	0x01000000 /* PCI read line */
#define SF_PCI_RM	0x02000000 /* PCI read multiple */
#define SF_PCI_BOF	0x04000000 /* PCI burst opcode fetch */
#define SF_PCI_CLS	0x08000000 /* PCI cache line size */
#define SF_PCI_WRI	0x10000000 /* PCI write and invalidate */

int	siop_common_attach(struct siop_common_softc *);
void	siop_common_reset(struct siop_common_softc *);
void	siop_setuptables(struct siop_common_cmd *);
int	siop_modechange(struct siop_common_softc *);

int	siop_wdtr_neg(struct siop_common_cmd *);
int	siop_sdtr_neg(struct siop_common_cmd *);
int     siop_ppr_neg(struct siop_common_cmd *);
void	siop_sdtr_msg(struct siop_common_cmd *, int, int, int);
void	siop_wdtr_msg(struct siop_common_cmd *, int, int);
void    siop_ppr_msg(struct siop_common_cmd *, int, int, int);
void	siop_update_xfer_mode(struct siop_common_softc *, int);
int	siop_iwr(struct siop_common_cmd *);
/* actions to take at return of siop_wdtr_neg() and siop_sdtr_neg() */
#define SIOP_NEG_NOP	0x0
#define SIOP_NEG_MSGOUT	0x1
#define SIOP_NEG_ACK	0x2

void	siop_minphys(struct buf *, struct scsi_link *);
void 	siop_ma(struct siop_common_cmd *);
void 	siop_sdp(struct siop_common_cmd *, int);
void 	siop_update_resid(struct siop_common_cmd *, int);
void	siop_clearfifo(struct siop_common_softc *);
void	siop_resetbus(struct siop_common_softc *);

#define siop_htoc32(sc, x) \
  (((sc)->features & SF_CHIP_BE) ? htobe32((x)) : htole32((x)))

#define siop_ctoh32(sc, x) \
  (((sc)->features & SF_CHIP_BE) ? betoh32((x)) : letoh32((x)))
@


1.28
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.27 2010/04/27 20:12:56 kettenis Exp $ */
d82 1
@


1.27
log
@__packed needs to be applied to the struct, not the typedef.
Makes gcc4 happier.

ok deraadt@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.26 2009/02/16 21:19:07 miod Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.26
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.25 2007/08/05 19:05:09 kettenis Exp $ */
d44 1
a44 1
} scr_table_t __packed;
@


1.25
log
@Add support for the (non-pci) NCR 53c720/770 in big-endian mode.

ok martin@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.24 2007/04/13 18:16:17 krw Exp $ */
d207 1
a207 1
void	siop_minphys(struct buf *);
@


1.24
log
@scsi_generic is now 16 bytes. Adjust offsets into structure being
passed to controller so they point where expected. Fixes martin@@'s
alpha and sparc machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.23 2005/11/20 22:32:48 krw Exp $ */
d181 1
d213 6
@


1.23
log
@Un-revert backout to 20051009 and add patches from Martin Bouyer to
close NetBSD PR#31990. Fixes interaction with some problematic drives
found by miod@@, martin@@, otto@@.

Tested martin@@ otto@@ miod@@

ok miod@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.22 2005/11/03 11:00:37 martin Exp $ */
d63 7
a69 7
	scr_table_t t_msgin;		/*  56 */
	scr_table_t t_extmsgin;		/*  64 */
	scr_table_t t_extmsgdata; 	/*  72 */
	scr_table_t t_msgout;		/*  80 */
	scr_table_t cmd;		/*  88 */
	scr_table_t t_status;		/*  96 */
	scr_table_t data[SIOP_NSG]; 	/* 104 */
@


1.22
log
@revert to 20051009 for now, need to investigate strange behaviour with
some controllers

discussed with otto@@ and henning@@, first noted by miod@@
@
text
@d1 2
a2 2
/*	$OpenBSD: siopvar_common.h,v 1.20 2005/10/08 17:30:18 krw Exp $ */
/*	$NetBSD: siopvar_common.h,v 1.32 2005/02/27 00:27:02 perry Exp $ */
d76 3
d92 1
d106 1
d200 1
d207 3
a209 1
void 	siop_sdp(struct siop_common_cmd *);
@


1.21
log
@Add handling for IGNORE WIDE RESIDUE messages. Actually calculate
resid instead of assuming it is always 0. From bouyer via NetBSD. Note
we are now sync'd with the latest (1.78 siop.c, 1.37 siop_common.c)
NetBSD code.

Tested by various people over the last year+. Didn't solve any of
their problems but didn't cause any regression either.
@
text
@a88 1
	int resid;	/* valid when CMDFL_RESID is set */
a101 1
#define CMDFL_RESID	0x0004 /* current offset in table is partial */
a194 1
int	siop_iwr(struct siop_common_cmd *);
d201 1
a201 3
void 	siop_ma(struct siop_common_cmd *);
void 	siop_sdp(struct siop_common_cmd *, int);
void 	siop_update_resid(struct siop_common_cmd *, int);
@


1.20
log
@Remove some trailing whitespace in license. From perry via NetBSD. Add
SF_CHIP_AAIP const which will be used later. From bouyer via NetBSD.
Note we are now sync'd up to latest (r1.32) NetBSD source, except
r1.28 and r1.29 will be sync'd separately since they actually do
something.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.19 2004/06/12 22:22:26 krw Exp $ */
d89 1
d103 1
d197 1
d204 3
a206 1
void 	siop_sdp(struct siop_common_cmd *);
@


1.19
log
@Add check for bp->b_bcount in siop_minphys() as other drivers have.

ok mickey@@
@
text
@d1 2
a2 2
/*	$OpenBSD: siopvar_common.h,v 1.18 2003/11/16 20:30:06 avsm Exp $ */
/*	$NetBSD: siopvar_common.h,v 1.22 2002/10/23 02:32:36 christos Exp $ */
d24 1
a24 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
d48 1
a48 1
#define SIOP_NSG	17	/* XXX (MAXPHYS/NBPG + 1) */
d175 1
@


1.18
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.17 2003/10/21 18:58:49 jmc Exp $ */
d49 1
@


1.17
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.16 2003/10/14 22:37:48 krw Exp $ */
d44 1
a44 1
} scr_table_t __attribute__((__packed__));
d69 1
a69 1
} __attribute__((__packed__));
@


1.16
log
@Align siop_xfer on 128 byte boundary for all architectures now that 3.4 is out.

ok (and from) mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.15 2003/09/06 22:24:14 krw Exp $ */
d71 1
a71 1
/* status can hold the SCSI_* status values, and 2 additionnal values: */
d76 1
a76 1
 * This decribes a command handled by the SCSI controller
d144 1
a144 1
	bus_addr_t sc_raddr;		/* register adresses */
d150 1
a150 1
	bus_addr_t sc_scriptaddr;	/* on-board ram or physical adress */
d167 1
a167 1
#define SF_CHIP_PF	0x00002000 /* Intructions prefetch */
@


1.15
log
@A couple of hppa-only changes, allowing siop to work on pci hppa
machines.

Align siop_xfer on 128 byte boundary, and don't use on-board RAM.
Aligning siop_xfer will be made general, post-3.4.

From mickey@@.

ok deraadt@@ mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.14 2003/07/01 17:15:06 krw Exp $ */
d47 1
a47 2
#ifdef __hppa__
/* XXX Ensure alignment of siop_xfer's. For hppa only at the moment. */
a48 3
#else
#define SIOP_NSG	(MAXPHYS/NBPG + 1)	/* XXX NBPG */
#endif
@


1.14
log
@Don't dma map the xs->cmd. Copy it to a safe buffer that is already
mapped and sync'ed appropriately, and is guaranteed to be in one
memory page.

Eliminate now unused dmamap_cmd and rs_cmd fields.

Fix another error message (adding active command to reset list) so
that it includes the adapter name.

Add missing letoh32() calls to debug code.

The evils of directly mapping *xs->cmd were pointed out by Mickey
during osiop development. In particular, *xs->cmd may start on one
memory page and run into the next. Since the dma logic in most
cards/drivers (including siop) only allocates one address/size pair to
map *xs->cmd, parts of a command could be lost or corrupted.

The large number of 6 byte dma mappings noted long ago by someone
(Henric?).  This change reduces the dma mapping activity per i/o by
1/3 to 1/2 and may give a performance boost of some kind.

Successfully tested on i386, sparc64 (ultra30 - thanks Jolan,
blade100), macppc and alpha.

Unfortunately these changes don't fix the Blade1000 siop problems.

**NOTE** If scsi_generic is ever upped to 16 bytes the offsets in
siop.ss must be updated!
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.13 2003/02/11 19:20:27 mickey Exp $ */
d47 4
d52 1
@


1.13
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.12 2002/11/16 04:37:29 krw Exp $ */
d51 2
a52 2
 * transfer. 
 * If you change something here, don't forget to update offsets in {s,es}iop.ss
d55 13
a67 13
	u_int8_t msg_out[16];	/* 0 */
	u_int8_t msg_in[16];	/* 16 */
	u_int32_t status;	/* 32 */
	u_int32_t pad1;		/* 36 */
	u_int32_t id;		/* 40 */
	u_int32_t pad2;		/* 44 */
	scr_table_t t_msgin;	/* 48 */
	scr_table_t t_extmsgin;	/* 56 */
	scr_table_t t_extmsgdata; /* 64 */
	scr_table_t t_msgout;	/* 72 */
	scr_table_t cmd;	/* 80 */
	scr_table_t t_status;	/* 88 */
	scr_table_t data[SIOP_NSG]; /* 96 */
a81 1
	struct scsi_sense rs_cmd; /* request sense command buffer */
a82 1
	bus_dmamap_t	dmamap_cmd;
@


1.12
log
@From NetBSD (bouyer@@):

In siop_reset(), reset sc_ntargets to 0. The number of targets will be
computed again in siop_add_reselsw().

In siop_reset(), reset the tag reseloff to 0, in addition to the lun
reseloff. If siop_add_dev() fails this time we would use the old
reseloff, clobbering memory now used for something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.11 2002/09/16 00:53:12 krw Exp $ */
d158 3
a160 3
#define SF_BUS_ULTRA	0x00000002 /* Ultra (20Mhz) bus */
#define SF_BUS_ULTRA2	0x00000004 /* Ultra2 (40Mhz) bus */
#define SF_BUS_ULTRA3	0x00000008 /* Ultra3 (80Mhz) bus */
@


1.11
log
@Resync siop with NetBSD. Make strong effort to minimize
differences, undoing whitespace, spelling, etc. changes
and adopting the NetBSD code instead of equivalent home
grown code for PPR negotiation, etc.

siop.c            1.21 -> 1.64
siop_common.c     1.12 -> 1.30
siopreg.h         1.7  -> 1.13
siopvar.h         1.13 -> 1.18
siopvar_common.h  1.10 -> 1.21
ncr53cxxx.c       1.5  -> 1.10
siop.ss           1.12 -> 1.17
siop_pci.c        1.8  -> 1.11
siop_pci_common.c 1.6  -> 1.17
siop_pci_common.h 1.2  -> 1.4

Many fixes, add 1010-66 support, restructure things to prepare for
addition of esiop, osiop and oosiop drivers.

tested on various archs by art@@, millert@@, wilfried@@, jason@@,
Dan Weeks.

ok deraadt@@.
@
text
@d1 2
a2 2
/*	$OpenBSD: siopvar_common.h,v 1.10 2002/03/14 01:26:55 millert Exp $ */
/*	$NetBSD: siopvar_common.h,v 1.21 2002/05/04 18:43:22 bouyer Exp $ */
@


1.10
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: siopvar_common.h,v 1.9 2001/11/05 17:25:58 art Exp $ */
/*	$NetBSD: siopvar_common.h,v 1.10 2001/01/26 21:58:56 bouyer Exp $	*/
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer
d41 1
a41 1
struct scr_table {
d44 1
a44 1
} __attribute__((__packed__));
a48 6
/* Number of tags, also number of openings if tags are used */
#define SIOP_NTAG 16

/* Number of openings if tags are not used */
#define SIOP_OPENINGS 2

d52 1
d54 14
a67 14
struct siop_xfer_common {
	u_int8_t msg_out[16];	         /*  0 */
	u_int8_t msg_in[16];	         /* 16 */
	u_int32_t status;	         /* 32 */
	u_int32_t pad1;		         /* 36 */
	u_int32_t id;		         /* 40 */
	u_int32_t pad2;		         /* 44 */
	struct scr_table t_msgin;	 /* 48 */
	struct scr_table t_extmsgin;	 /* 56 */
	struct scr_table t_extmsgdata;   /* 64 */
	struct scr_table t_msgout;	 /* 72 */
	struct scr_table cmd;	         /* 80 */
	struct scr_table t_status;	 /* 88 */
	struct scr_table data[SIOP_NSG]; /* 96 */
d70 1
a70 1
/* status can hold the SCSI_* status values, and 2 additional values: */
a73 7
/* xfer description of the script: tables and reselect script */
struct siop_xfer {
	struct siop_xfer_common tables;
	/* u_int32_t resel[sizeof(load_dsa) / sizeof(load_dsa[0])]; */
	u_int32_t resel[25];
} __attribute__((__packed__));

d75 1
a75 3
 * This describes a command handled by the SCSI controller.
 * These are chained in either a free list or a active list.
 * We have one queue per target.
d77 3
a79 4
struct siop_cmd {
	TAILQ_ENTRY (siop_cmd) next;
	struct siop_softc *siop_sc; /* points back to our adapter */
	struct siop_target *siop_target; /* pointer to our target def */
d81 2
a82 3
	struct siop_xfer *siop_xfer; /* tables dealing with this xfer */
#define siop_tables siop_xfer->tables
	struct siop_cbd *siop_cbdp; /* pointer to our siop_cbd */
a85 1
	struct scsi_sense rs_cmd; /* request sense command buffer */
a87 1
	int reselslot; /* the reselect slot used */
a90 9
/* command block descriptors: an array of siop_cmd + an array of siop_xfer */

struct siop_cbd {
	TAILQ_ENTRY (siop_cbd) next;
	struct siop_cmd *cmds;
	struct siop_xfer *xfers;
	bus_dmamap_t xferdma; /* DMA map for this block of xfers */
};

a102 15
/* per-tag struct */
struct siop_tag {
	struct siop_cmd *active; /* active command */
	u_int reseloff; /* XXX */
};

/* per lun struct */
struct siop_lun {
	struct siop_tag siop_tag[SIOP_NTAG]; /* tag array */
	int lun_flags; /* per-lun flags, see below */
	u_int reseloff; /* XXX */
};

#define SIOP_LUNF_FULL 0x01 /* queue full message */

d104 1
a104 1
struct siop_target {
d107 3
a109 9
	u_int32_t id;	/* for SELECT FROM
			 * 31-24 == SCNTL3
			 * 23-16 == SCSI id
			 * 15- 8 == SXFER
			 *  7- 0 == SCNTL4
			 */
	struct siop_lun *siop_lun[8]; /* per-lun state */
	u_int reseloff; /* XXX */
	struct siop_lunsw *lunsw; /* XXX */
d117 1
a117 1
#define TARST_PPR_NEG	4 /* target is doing PPR (Parallel Protocol Request) */
d121 74
a194 43
#define TARF_SYNC	0x01 /* target can do sync xfers      */
#define TARF_WIDE	0x02 /* target can do wide xfers      */
#define TARF_TAG	0x04 /* target can do taggged queuing */
#define TARF_PPR	0x08 /* target can do PPR negotiation */

#define TARF_ISWIDE	0x10 /* target is using wide xfers    */
#define TARF_ISIUS	0x20 /* target is using IUS           */
#define TARF_ISDT	0x40 /* target is using DT            */
#define TARF_ISQAS	0x80 /* target is using QAS           */

struct siop_lunsw {
	TAILQ_ENTRY (siop_lunsw) next;
	u_int32_t lunsw_off; /* offset of this lun sw, from sc_scriptaddr*/
	u_int32_t lunsw_size; /* size of this lun sw */
};

static __inline__ void siop_table_sync(struct siop_cmd *, int);
static __inline__ void
siop_table_sync(siop_cmd, ops)
	struct siop_cmd *siop_cmd;
	int ops;
{
	struct siop_softc *sc = siop_cmd->siop_sc;
        bus_addr_t offset;
        
        offset = siop_cmd->dsa -
		siop_cmd->siop_cbdp->xferdma->dm_segs[0].ds_addr;
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->siop_cbdp->xferdma, offset,
            sizeof(struct siop_xfer), ops);
}

void	siop_common_reset(struct siop_softc *);
void	siop_setuptables(struct siop_cmd *);
int	siop_modechange(struct siop_softc *);

int	siop_wdtr_neg(struct siop_cmd *);
int	siop_sdtr_neg(struct siop_cmd *);
int     siop_ppr_neg(struct siop_cmd *);
void	siop_sdtr_msg(struct siop_cmd *, int, int, int);
void	siop_wdtr_msg(struct siop_cmd *, int, int);
void    siop_ppr_msg(struct siop_cmd *, int, int, int);

/* actions to take at return of siop_<xxx>_neg() */
a197 1
#define SIOP_NEG_MSGREJ	0x3
a198 1
void	siop_print_info(struct siop_softc *, int);
d200 3
a202 10
void 	siop_sdp(struct siop_cmd *);
void	siop_clearfifo(struct siop_softc *);
void	siop_resetbus(struct siop_softc *);

int     siop_period_factor_to_scf(struct siop_softc *, int, int);
int     siop_scf_to_period_factor(struct siop_softc *, int, int);

/* XXXX should be  callbacks */
void	siop_add_dev(struct siop_softc *, int, int);
void	siop_del_dev(struct siop_softc *, int, int);
@


1.9
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.8 2001/10/30 00:02:55 krw Exp $ */
d185 1
a185 1
static __inline__ void siop_table_sync __P((struct siop_cmd *, int));
d200 10
a209 10
void	siop_common_reset __P((struct siop_softc *));
void	siop_setuptables __P((struct siop_cmd *));
int	siop_modechange __P((struct siop_softc *));

int	siop_wdtr_neg __P((struct siop_cmd *));
int	siop_sdtr_neg __P((struct siop_cmd *));
int     siop_ppr_neg  __P((struct siop_cmd *));
void	siop_sdtr_msg __P((struct siop_cmd *, int, int, int));
void	siop_wdtr_msg __P((struct siop_cmd *, int, int));
void    siop_ppr_msg  __P((struct siop_cmd *, int, int, int));
d217 5
a221 5
void	siop_print_info __P((struct siop_softc *, int));
void	siop_minphys __P((struct buf *));
void 	siop_sdp __P((struct siop_cmd *));
void	siop_clearfifo __P((struct siop_softc *));
void	siop_resetbus __P((struct siop_softc *));
d223 2
a224 2
int     siop_period_factor_to_scf __P((struct siop_softc *, int, int));
int     siop_scf_to_period_factor __P((struct siop_softc *, int, int));
d227 2
a228 2
void	siop_add_dev __P((struct siop_softc *, int, int));
void	siop_del_dev __P((struct siop_softc *, int, int));
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.9 2001/11/05 17:25:58 art Exp $ */
d185 1
a185 1
static __inline__ void siop_table_sync(struct siop_cmd *, int);
d200 10
a209 10
void	siop_common_reset(struct siop_softc *);
void	siop_setuptables(struct siop_cmd *);
int	siop_modechange(struct siop_softc *);

int	siop_wdtr_neg(struct siop_cmd *);
int	siop_sdtr_neg(struct siop_cmd *);
int     siop_ppr_neg(struct siop_cmd *);
void	siop_sdtr_msg(struct siop_cmd *, int, int, int);
void	siop_wdtr_msg(struct siop_cmd *, int, int);
void    siop_ppr_msg(struct siop_cmd *, int, int, int);
d217 5
a221 5
void	siop_print_info(struct siop_softc *, int);
void	siop_minphys(struct buf *);
void 	siop_sdp(struct siop_cmd *);
void	siop_clearfifo(struct siop_softc *);
void	siop_resetbus(struct siop_softc *);
d223 2
a224 2
int     siop_period_factor_to_scf(struct siop_softc *, int, int);
int     siop_scf_to_period_factor(struct siop_softc *, int, int);
d227 2
a228 2
void	siop_add_dev(struct siop_softc *, int, int);
void	siop_del_dev(struct siop_softc *, int, int);
@


1.9.2.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: siopvar_common.h,v 1.21 2002/05/04 18:43:22 bouyer Exp $ */
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
d41 1
a41 1
typedef struct scr_table {
d44 1
a44 1
} scr_table_t __attribute__((__packed__));
d49 6
a57 1
 * If you change something here, don't forget to update offsets in {s,es}iop.ss
d59 14
a72 14
struct siop_common_xfer {
	u_int8_t msg_out[16];	/* 0 */
	u_int8_t msg_in[16];	/* 16 */
	u_int32_t status;	/* 32 */
	u_int32_t pad1;		/* 36 */
	u_int32_t id;		/* 40 */
	u_int32_t pad2;		/* 44 */
	scr_table_t t_msgin;	/* 48 */
	scr_table_t t_extmsgin;	/* 56 */
	scr_table_t t_extmsgdata; /* 64 */
	scr_table_t t_msgout;	/* 72 */
	scr_table_t cmd;	/* 80 */
	scr_table_t t_status;	/* 88 */
	scr_table_t data[SIOP_NSG]; /* 96 */
d75 1
a75 1
/* status can hold the SCSI_* status values, and 2 additionnal values: */
d79 7
d87 3
a89 1
 * This decribes a command handled by the SCSI controller
d91 4
a94 3
struct siop_common_cmd {
	struct siop_common_softc *siop_sc; /* points back to our adapter */
	struct siop_common_target *siop_target; /* pointer to our target def */
d96 3
a98 2
	struct siop_common_xfer *siop_tables; /* tables for this cmd */
	struct scsi_sense rs_cmd; /* request sense command buffer */
d102 1
d105 1
d109 9
d130 15
d146 1
a146 1
struct siop_common_target {
d149 9
a157 3
	u_int32_t id;	/* for SELECT FROM */
	int period;
	int offset;
d165 1
a165 1
#define TARST_PPR_NEG	4 /* target is doing sync negotiation */
d169 43
a211 74
#define TARF_SYNC	0x01 /* target can do sync */
#define TARF_WIDE	0x02 /* target can do wide */
#define TARF_TAG	0x04 /* target can do tags */
#define TARF_DT		0x08 /* target can do DT clocking */
#define TARF_ISWIDE	0x10 /* target is wide */
#define TARF_ISDT	0x20 /* target is doing DT clocking */

/* Driver internal state */
struct siop_common_softc {
	struct device sc_dev;
	struct scsi_link sc_link;	/* link to upper level */
	int features;			/* chip's features */
	int ram_size;
	int maxburst;
	int maxoff;
	int clock_div;			/* async. clock divider (scntl3) */
	int clock_period;		/* clock period (ns * 10) */
	int st_minsync;			/* min and max sync period, */
	int dt_minsync;
	int st_maxsync;			/* as sent in or PPR messages */
	int dt_maxsync;
	int mode;			/* current SE/LVD/HVD mode */
	bus_space_tag_t sc_rt;		/* bus_space registers tag */
	bus_space_handle_t sc_rh;	/* bus_space registers handle */
	bus_addr_t sc_raddr;		/* register adresses */
	bus_space_tag_t sc_ramt;	/* bus_space ram tag */
	bus_space_handle_t sc_ramh;	/* bus_space ram handle */
	bus_dma_tag_t sc_dmat;		/* bus DMA tag */
	void (*sc_reset)(struct siop_common_softc*); /* reset callback */
	bus_dmamap_t  sc_scriptdma;	/* DMA map for script */
	bus_addr_t sc_scriptaddr;	/* on-board ram or physical adress */
	u_int32_t *sc_script;		/* script location in memory */
	struct siop_common_target *targets[16]; /* per-target states */
};

/* features */
#define SF_BUS_WIDE	0x00000001 /* wide bus */
#define SF_BUS_ULTRA	0x00000002 /* Ultra (20Mhz) bus */
#define SF_BUS_ULTRA2	0x00000004 /* Ultra2 (40Mhz) bus */
#define SF_BUS_ULTRA3	0x00000008 /* Ultra3 (80Mhz) bus */
#define SF_BUS_DIFF	0x00000010 /* differential bus */

#define SF_CHIP_LED0	0x00000100 /* led on GPIO0 */
#define SF_CHIP_LEDC	0x00000200 /* led on GPIO0 with hardware control */
#define SF_CHIP_DBLR	0x00000400 /* clock doubler or quadrupler */
#define SF_CHIP_QUAD	0x00000800 /* clock quadrupler, with PPL */
#define SF_CHIP_FIFO	0x00001000 /* large fifo */
#define SF_CHIP_PF	0x00002000 /* Intructions prefetch */
#define SF_CHIP_RAM	0x00004000 /* on-board RAM */
#define SF_CHIP_LS	0x00008000 /* load/store instruction */
#define SF_CHIP_10REGS	0x00010000 /* 10 scratch registers */
#define SF_CHIP_DFBC	0x00020000 /* Use DFBC register */
#define SF_CHIP_DT	0x00040000 /* DT clocking */
#define SF_CHIP_GEBUG	0x00080000 /* SCSI gross error bug */

#define SF_PCI_RL	0x01000000 /* PCI read line */
#define SF_PCI_RM	0x02000000 /* PCI read multiple */
#define SF_PCI_BOF	0x04000000 /* PCI burst opcode fetch */
#define SF_PCI_CLS	0x08000000 /* PCI cache line size */
#define SF_PCI_WRI	0x10000000 /* PCI write and invalidate */

int	siop_common_attach(struct siop_common_softc *);
void	siop_common_reset(struct siop_common_softc *);
void	siop_setuptables(struct siop_common_cmd *);
int	siop_modechange(struct siop_common_softc *);

int	siop_wdtr_neg(struct siop_common_cmd *);
int	siop_sdtr_neg(struct siop_common_cmd *);
int     siop_ppr_neg(struct siop_common_cmd *);
void	siop_sdtr_msg(struct siop_common_cmd *, int, int, int);
void	siop_wdtr_msg(struct siop_common_cmd *, int, int);
void    siop_ppr_msg(struct siop_common_cmd *, int, int, int);
void	siop_update_xfer_mode(struct siop_common_softc *, int);
/* actions to take at return of siop_wdtr_neg() and siop_sdtr_neg() */
d215 1
d217 1
d219 10
a228 3
void 	siop_sdp(struct siop_common_cmd *);
void	siop_clearfifo(struct siop_common_softc *);
void	siop_resetbus(struct siop_common_softc *);
@


1.9.2.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: siopvar_common.h,v 1.22 2002/10/23 02:32:36 christos Exp $ */
d158 3
a160 3
#define SF_BUS_ULTRA	0x00000002 /* Ultra (20MHz) bus */
#define SF_BUS_ULTRA2	0x00000004 /* Ultra2 (40MHz) bus */
#define SF_BUS_ULTRA3	0x00000008 /* Ultra3 (80MHz) bus */
@


1.8
log
@From NetBSD: add __packed__ attribute to hardware structure that
lacked it (scr_table).

Also remove scr_table_t typedef and just use 'struct scr_table' to be
consistant with all other structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.7 2001/08/26 02:39:05 krw Exp $ */
a184 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	siop_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (off), (len), (op))
#else
#define	siop_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (op))
#endif

d196 1
a196 1
	siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->siop_cbdp->xferdma, offset,
@


1.7
log
@Prepare for transition to 5-parameter bus_dmamap_sync() by creating and
using *_bus_dmamap_sync() defines that are defined appropriately
depending on __HAS_NEW_BUS_DMAMAP_SYNC.

Most of the code changes are simple reversions to the original NetBSD
code.

Slip in a siop_script_sync() instead of a manually done code section.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.6 2001/06/25 23:14:40 krw Exp $ */
d41 1
a41 1
typedef struct scr_table {
d44 1
a44 1
} scr_table_t ;
d60 13
a72 13
	u_int8_t msg_out[16];	    /*  0 */
	u_int8_t msg_in[16];	    /* 16 */
	u_int32_t status;	    /* 32 */
	u_int32_t pad1;		    /* 36 */
	u_int32_t id;		    /* 40 */
	u_int32_t pad2;		    /* 44 */
	scr_table_t t_msgin;	    /* 48 */
	scr_table_t t_extmsgin;	    /* 56 */
	scr_table_t t_extmsgdata;   /* 64 */
	scr_table_t t_msgout;	    /* 72 */
	scr_table_t cmd;	    /* 80 */
	scr_table_t t_status;	    /* 88 */
	scr_table_t data[SIOP_NSG]; /* 96 */
@


1.6
log
@Revert change to using sc_link in calls to siop_print_info().

sc_link->device_softc not necessarily available for devices like cd's
that don't issue SCSI commands after INQUIRY during probe, leaving
negotiation triggering to next LUN. Spotted by Nikolay Sturm.

Fixing this is not worth the effort and added complexity for a
cosmetic improvement.

Keep code cleanups done at the same time, and add a typo fix
(destiation -> destination).
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.5 2001/06/24 18:28:10 krw Exp $ */
d185 8
d200 6
a205 1
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->siop_cbdp->xferdma, ops);
@


1.5
log
@Pass the device's scsi_link to siop_print_info(), instead of the
adapter's siop_softc. This allows easy access to the dv_xname of the
device whose negotiation results are being reported. This makes boot
probe and subsequent log messages clearer.

e.g. message will now read

   sd0: negotiated tagged 16 bit 20 MHz 16 REQ/ACK offset xfers

instead of

   siop0: target 0 now using tagged 16 bit 20 MHz 16 REQ/ACK offset xfers

Clean up siop_print_info() a bit as long as we are there.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.4 2001/04/15 06:01:29 krw Exp $ */
d212 1
a212 1
void	siop_print_info __P((struct scsi_link *));
@


1.4
log
@Support U160 on 53c1010 chips.

Add support for PPR negotiations and DT transfers,
and the preservation and restoration of the
SCNTL4 register which controls Ultra3 transfers.

Redo sync lookup, since the same period factor
can mean two things depending on whether you are
using DT or ST. Keep a minimum allowed ST period
factor, and a minimum allowd DT period factor for
each adapter.

Currently NO support for QAS or IUS or AIP.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.3 2001/03/06 16:29:32 krw Exp $ */
d212 1
a212 1
void	siop_print_info __P((struct siop_softc *, int));
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.4 2001/04/15 06:01:29 krw Exp $ */
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.4.4.1 2001/05/14 22:24:14 niklas Exp $ */
@


1.4.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.4.4.2 2001/07/04 10:41:10 niklas Exp $ */
a184 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	siop_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (off), (len), (op))
#else
#define	siop_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (op))
#endif

d192 1
a192 6
        bus_addr_t offset;
        
        offset = siop_cmd->dsa -
		siop_cmd->siop_cbdp->xferdma->dm_segs[0].ds_addr;
	siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->siop_cbdp->xferdma, offset,
            sizeof(struct siop_xfer), ops);
@


1.4.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d41 1
a41 1
struct scr_table {
d44 1
a44 1
} __attribute__((__packed__));
d60 13
a72 13
	u_int8_t msg_out[16];	         /*  0 */
	u_int8_t msg_in[16];	         /* 16 */
	u_int32_t status;	         /* 32 */
	u_int32_t pad1;		         /* 36 */
	u_int32_t id;		         /* 40 */
	u_int32_t pad2;		         /* 44 */
	struct scr_table t_msgin;	 /* 48 */
	struct scr_table t_extmsgin;	 /* 56 */
	struct scr_table t_extmsgdata;   /* 64 */
	struct scr_table t_msgout;	 /* 72 */
	struct scr_table cmd;	         /* 80 */
	struct scr_table t_status;	 /* 88 */
	struct scr_table data[SIOP_NSG]; /* 96 */
d185 8
d204 1
a204 1
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->siop_cbdp->xferdma, offset,
@


1.4.4.5
log
@Merge in -current from about a week ago
@
text
@d185 1
a185 1
static __inline__ void siop_table_sync(struct siop_cmd *, int);
d200 10
a209 10
void	siop_common_reset(struct siop_softc *);
void	siop_setuptables(struct siop_cmd *);
int	siop_modechange(struct siop_softc *);

int	siop_wdtr_neg(struct siop_cmd *);
int	siop_sdtr_neg(struct siop_cmd *);
int     siop_ppr_neg(struct siop_cmd *);
void	siop_sdtr_msg(struct siop_cmd *, int, int, int);
void	siop_wdtr_msg(struct siop_cmd *, int, int);
void    siop_ppr_msg(struct siop_cmd *, int, int, int);
d217 5
a221 5
void	siop_print_info(struct siop_softc *, int);
void	siop_minphys(struct buf *);
void 	siop_sdp(struct siop_cmd *);
void	siop_clearfifo(struct siop_softc *);
void	siop_resetbus(struct siop_softc *);
d223 2
a224 2
int     siop_period_factor_to_scf(struct siop_softc *, int, int);
int     siop_scf_to_period_factor(struct siop_softc *, int, int);
d227 2
a228 2
void	siop_add_dev(struct siop_softc *, int, int);
void	siop_del_dev(struct siop_softc *, int, int);
@


1.4.4.6
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: siopvar_common.h,v 1.22 2002/10/23 02:32:36 christos Exp $ */
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
d41 1
a41 1
typedef struct scr_table {
d44 1
a44 1
} scr_table_t __attribute__((__packed__));
d49 6
a57 1
 * If you change something here, don't forget to update offsets in {s,es}iop.ss
d59 14
a72 14
struct siop_common_xfer {
	u_int8_t msg_out[16];	/* 0 */
	u_int8_t msg_in[16];	/* 16 */
	u_int32_t status;	/* 32 */
	u_int32_t pad1;		/* 36 */
	u_int32_t id;		/* 40 */
	u_int32_t pad2;		/* 44 */
	scr_table_t t_msgin;	/* 48 */
	scr_table_t t_extmsgin;	/* 56 */
	scr_table_t t_extmsgdata; /* 64 */
	scr_table_t t_msgout;	/* 72 */
	scr_table_t cmd;	/* 80 */
	scr_table_t t_status;	/* 88 */
	scr_table_t data[SIOP_NSG]; /* 96 */
d75 1
a75 1
/* status can hold the SCSI_* status values, and 2 additionnal values: */
d79 7
d87 3
a89 1
 * This decribes a command handled by the SCSI controller
d91 4
a94 3
struct siop_common_cmd {
	struct siop_common_softc *siop_sc; /* points back to our adapter */
	struct siop_common_target *siop_target; /* pointer to our target def */
d96 3
a98 2
	struct siop_common_xfer *siop_tables; /* tables for this cmd */
	struct scsi_sense rs_cmd; /* request sense command buffer */
d102 1
d105 1
d109 9
d130 15
d146 1
a146 1
struct siop_common_target {
d149 9
a157 3
	u_int32_t id;	/* for SELECT FROM */
	int period;
	int offset;
d165 1
a165 1
#define TARST_PPR_NEG	4 /* target is doing sync negotiation */
d169 43
a211 74
#define TARF_SYNC	0x01 /* target can do sync */
#define TARF_WIDE	0x02 /* target can do wide */
#define TARF_TAG	0x04 /* target can do tags */
#define TARF_DT		0x08 /* target can do DT clocking */
#define TARF_ISWIDE	0x10 /* target is wide */
#define TARF_ISDT	0x20 /* target is doing DT clocking */

/* Driver internal state */
struct siop_common_softc {
	struct device sc_dev;
	struct scsi_link sc_link;	/* link to upper level */
	int features;			/* chip's features */
	int ram_size;
	int maxburst;
	int maxoff;
	int clock_div;			/* async. clock divider (scntl3) */
	int clock_period;		/* clock period (ns * 10) */
	int st_minsync;			/* min and max sync period, */
	int dt_minsync;
	int st_maxsync;			/* as sent in or PPR messages */
	int dt_maxsync;
	int mode;			/* current SE/LVD/HVD mode */
	bus_space_tag_t sc_rt;		/* bus_space registers tag */
	bus_space_handle_t sc_rh;	/* bus_space registers handle */
	bus_addr_t sc_raddr;		/* register adresses */
	bus_space_tag_t sc_ramt;	/* bus_space ram tag */
	bus_space_handle_t sc_ramh;	/* bus_space ram handle */
	bus_dma_tag_t sc_dmat;		/* bus DMA tag */
	void (*sc_reset)(struct siop_common_softc*); /* reset callback */
	bus_dmamap_t  sc_scriptdma;	/* DMA map for script */
	bus_addr_t sc_scriptaddr;	/* on-board ram or physical adress */
	u_int32_t *sc_script;		/* script location in memory */
	struct siop_common_target *targets[16]; /* per-target states */
};

/* features */
#define SF_BUS_WIDE	0x00000001 /* wide bus */
#define SF_BUS_ULTRA	0x00000002 /* Ultra (20MHz) bus */
#define SF_BUS_ULTRA2	0x00000004 /* Ultra2 (40MHz) bus */
#define SF_BUS_ULTRA3	0x00000008 /* Ultra3 (80MHz) bus */
#define SF_BUS_DIFF	0x00000010 /* differential bus */

#define SF_CHIP_LED0	0x00000100 /* led on GPIO0 */
#define SF_CHIP_LEDC	0x00000200 /* led on GPIO0 with hardware control */
#define SF_CHIP_DBLR	0x00000400 /* clock doubler or quadrupler */
#define SF_CHIP_QUAD	0x00000800 /* clock quadrupler, with PPL */
#define SF_CHIP_FIFO	0x00001000 /* large fifo */
#define SF_CHIP_PF	0x00002000 /* Intructions prefetch */
#define SF_CHIP_RAM	0x00004000 /* on-board RAM */
#define SF_CHIP_LS	0x00008000 /* load/store instruction */
#define SF_CHIP_10REGS	0x00010000 /* 10 scratch registers */
#define SF_CHIP_DFBC	0x00020000 /* Use DFBC register */
#define SF_CHIP_DT	0x00040000 /* DT clocking */
#define SF_CHIP_GEBUG	0x00080000 /* SCSI gross error bug */

#define SF_PCI_RL	0x01000000 /* PCI read line */
#define SF_PCI_RM	0x02000000 /* PCI read multiple */
#define SF_PCI_BOF	0x04000000 /* PCI burst opcode fetch */
#define SF_PCI_CLS	0x08000000 /* PCI cache line size */
#define SF_PCI_WRI	0x10000000 /* PCI write and invalidate */

int	siop_common_attach(struct siop_common_softc *);
void	siop_common_reset(struct siop_common_softc *);
void	siop_setuptables(struct siop_common_cmd *);
int	siop_modechange(struct siop_common_softc *);

int	siop_wdtr_neg(struct siop_common_cmd *);
int	siop_sdtr_neg(struct siop_common_cmd *);
int     siop_ppr_neg(struct siop_common_cmd *);
void	siop_sdtr_msg(struct siop_common_cmd *, int, int, int);
void	siop_wdtr_msg(struct siop_common_cmd *, int, int);
void    siop_ppr_msg(struct siop_common_cmd *, int, int, int);
void	siop_update_xfer_mode(struct siop_common_softc *, int);
/* actions to take at return of siop_wdtr_neg() and siop_sdtr_neg() */
d215 1
d217 1
d219 10
a228 3
void 	siop_sdp(struct siop_common_cmd *);
void	siop_clearfifo(struct siop_common_softc *);
void	siop_resetbus(struct siop_common_softc *);
@


1.4.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d44 1
a44 1
} scr_table_t __packed;
d47 1
a47 2
/* XXX Ensure alignment of siop_xfer's. */
#define SIOP_NSG	17	/* XXX (MAXPHYS/NBPG + 1) */
d51 2
a52 2
 * transfer. If you change something here, don't forget to update offsets in
 * {s,es}iop.ss
d55 14
a68 14
	u_int8_t msg_out[16];		/*   0 */
	u_int8_t msg_in[16];		/*  16 */
	u_int32_t status;		/*  32 */
	u_int32_t pad1;			/*  36 */
	u_int32_t id;			/*  40 */
	struct scsi_generic xscmd; 	/*  44 */
	scr_table_t t_msgin;		/*  56 */
	scr_table_t t_extmsgin;		/*  64 */
	scr_table_t t_extmsgdata; 	/*  72 */
	scr_table_t t_msgout;		/*  80 */
	scr_table_t cmd;		/*  88 */
	scr_table_t t_status;		/*  96 */
	scr_table_t data[SIOP_NSG]; 	/* 104 */
} __packed;
d70 1
a70 1
/* status can hold the SCSI_* status values, and 2 additional values: */
d75 1
a75 1
 * This describes a command handled by the SCSI controller
d82 1
d84 1
d145 1
a145 1
	bus_addr_t sc_raddr;		/* register addresses */
d151 1
a151 1
	bus_addr_t sc_scriptaddr;	/* on-board ram or physical address */
d168 1
a168 1
#define SF_CHIP_PF	0x00002000 /* Instructions prefetch */
@


1.4.4.8
log
@sync to HEAD
@
text
@a48 1
#define SIOP_MAXFER	((SIOP_NSG - 1) * PAGE_SIZE)
@


1.3
log
@1) Enable tag queuing.

2) Negotiate and report wide/sync only after INQUIRY
   results known.

3) Clean up wide/sync negotiation code a bit, ensuring
   that an agressive target does not prematurely force
   negotiation before the INQUIRY is done. Seen by millert@@.

4) Ensure that a wide negotiation always resets the
   sync settings to async.

5) Some error message improvements from thorpej@@NetBSD.

6) Some KNF.

7) Print wide/sync negotiation results after each
   completed negotiation.

8) Print some relevant information just before a panic
   that should never happen. But does on PowerPC.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.2 2001/03/01 17:14:28 krw Exp $ */
d60 13
a72 13
	u_int8_t msg_out[8];	/* 0 */
	u_int8_t msg_in[8];	/* 8 */
	u_int32_t status;	/* 16 */
	u_int32_t pad1;		/* 20 */
	u_int32_t id;		/* 24 */
	u_int32_t pad2;		/* 28 */
	scr_table_t t_msgin;	/* 32 */
	scr_table_t t_extmsgin;	/* 40 */
	scr_table_t t_extmsgdata; /* 48 */
	scr_table_t t_msgout;	/* 56 */
	scr_table_t cmd;	/* 64 */
	scr_table_t t_status;	/* 72 */
	scr_table_t data[SIOP_NSG]; /* 80 */
d75 1
a75 1
/* status can hold the SCSI_* status values, and 2 additionnal values: */
d149 6
a154 1
	u_int32_t id;	/* for SELECT FROM */
d165 2
a166 1
#define TARST_OK	4 /* sync/wide agreement is valid */
d169 9
a177 4
#define TARF_SYNC	0x01 /* target can do sync */
#define TARF_WIDE	0x02 /* target can do wide */
#define TARF_TAG	0x04 /* target can do tags */
#define TARF_ISWIDE	0x08 /* target is wide */
d191 1
a191 1
	struct siop_softc *sc  = siop_cmd->siop_sc;
d201 1
d204 3
a206 1
/* actions to take at return of siop_wdtr_neg() and siop_sdtr_neg() */
d210 1
d217 4
@


1.2
log
@Typo police: various misspelling, capitalizations, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar_common.h,v 1.1 2001/02/15 04:07:59 krw Exp $ */
d49 1
a49 1
/* Number of tag */
d52 3
d197 1
@


1.1
log
@Import siop, a replacement for the ncr SCSI driver, from NetBSD.

Written for NetBSD by Manuel Bouyer.

Tested with various cards on i386 and alpha.

Outstanding issue: doesn't work with PowerPC yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d84 3
a86 3
 * This decribes a command handled by the SCSI controller
 * These are chained in either a free list or a active list
 * We have one queue per target
d119 1
a119 1
#define CMDST_SENSE		3 /* cmd slot is being requesting sense */
@

