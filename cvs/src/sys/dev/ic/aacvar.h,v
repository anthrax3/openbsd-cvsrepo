head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.8
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.10
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.14
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.16
	OPENBSD_5_0:1.8.0.12
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.10
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.3
	UBC:1.1.0.8
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.13
date	2016.04.01.04.16.27;	author jsg;	state Exp;
branches;
next	1.12;
commitid	WTSqUvNdQAxRpgFv;

1.12
date	2014.01.17.22.51.10;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2014.01.17.22.20.32;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.17.22.18.27;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.06.22.06.54;	author martynas;	state Exp;
branches;
next	1.8;

1.8
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.07.20.12.41;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.22.02.36.26;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.18.05.39.10;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.21.18.58.48;	author jmc;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.11.08.55.12;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.10.09.39.36;	author niklas;	state Exp;
branches
	1.1.4.1
	1.1.8.1;
next	;

1.1.4.1
date	2001.05.14.22.23.19;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.11;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.56.15;	author niklas;	state Exp;
branches;
next	;

1.1.8.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove outdated unused compat define.  mono_time no longer exists and
the kernel has had time_second since 2004.
@
text
@/*	$OpenBSD: aacvar.h,v 1.12 2014/01/17 22:51:10 dlg Exp $	*/

/*-
 * Copyright (c) 2000 Michael Smith
 * Copyright (c) 2000 BSDi
 * Copyright (c) 2000 Niklas Hallqvist
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: /c/ncvs/src/sys/dev/aac/aacvar.h,v 1.1 2000/09/13 03:20:34 msmith Exp $
 */

/*
 * This driver would not have rewritten for OpenBSD if it was not for the
 * hardware donation from Nocom.  I want to thank them for their support.
 * Of course, credit should go to Mike Smith for the original work he did
 * in the FreeBSD driver where I found lots of inspiration.
 * - Niklas Hallqvist
 */

/* Debugging */
// #define AAC_DEBUG 0x0

#ifdef AAC_DEBUG
#define AAC_DPRINTF(mask, args) if (aac_debug & (mask)) printf args
#define AAC_D_INTR	0x001
#define AAC_D_MISC	0x002
#define AAC_D_CMD	0x004
#define AAC_D_QUEUE	0x008
#define AAC_D_IO	0x010
#define AAC_D_IOCTL	0x020
#define AAC_D_LOCK	0x040
#define AAC_D_THREAD	0x080
#define AAC_D_FIB	0x100
extern int aac_debug;

#define AAC_PRINT_FIB(sc, fib)  do { \
	if (aac_debug & AAC_D_FIB) \
		aac_print_fib((sc), (fib), __func__); \
} while (0)
#else
#define AAC_DPRINTF(mask, args)
#define AAC_PRINT_FIB(sc, fib)
#endif

struct aac_code_lookup {
	char	*string;
	u_int32_t code;
};

struct aac_softc;

/*
 * We allocate a small set of FIBs for the adapter to use to send us messages.
 */
#define AAC_ADAPTER_FIBS	8

/*
 * FIBs are allocated in page-size chunks and can grow up to the 512
 * limit imposed by the hardware.
 */
#define AAC_FIB_COUNT		(PAGE_SIZE/sizeof(struct aac_fib))
#define AAC_MAX_FIBS		512
#define AAC_FIBMAP_SIZE		(PAGE_SIZE)

/*
 * The controller reports status events in AIFs.  We hang on to a number of
 * these in order to pass them out to user-space management tools.
 */
#define AAC_AIFQ_LENGTH		64

/*
 * Firmware messages are passed in the printf buffer.
 */
#define AAC_PRINTF_BUFSIZE	256

/*
 * We wait this many seconds for the adapter to come ready if it is still
 * booting.
 */
#define AAC_BOOT_TIMEOUT	(3 * 60)

/*
 * Timeout for immediate commands.
 */
#define AAC_IMMEDIATE_TIMEOUT	30

/*
 * Timeout for normal commands
 */
#define AAC_CMD_TIMEOUT		30		/* seconds */

/*
 * Rate at which we periodically check for timed out commands and kick the
 * controller.
 */
#define AAC_PERIODIC_INTERVAL	20		/* seconds */

/*
 * Wait this long for a lost interrupt to get detected.
 */
#define AAC_WATCH_TIMEOUT	10000		/* 10000 * 1ms = 10s */

/*
 * Delay 20ms after the qnotify in sync operations.  Experimentally deduced.
 */
#define AAC_SYNC_DELAY 20000

/*
 * The firmware interface allows for a 16-bit s/g list length.  We limit 
 * ourselves to a reasonable maximum and ensure alignment.
 */
#define AAC_MAXSGENTRIES	64	/* max S/G entries, limit 65535 */		

/*
 * We gather a number of adapter-visible items into a single structure.
 *
 * The ordering of this structure may be important; we copy the Linux driver:
 *
 * Adapter FIBs
 * Init struct
 * Queue headers (Comm Area)
 * Printf buffer
 *
 * In addition, we add:
 * Sync Fib
 */
struct aac_common {
	/* fibs for the controller to send us messages */
	struct aac_fib ac_fibs[AAC_ADAPTER_FIBS];

	/* the init structure */
	struct aac_adapter_init	ac_init;

	/* arena within which the queue structures are kept */
	u_int8_t ac_qbuf[sizeof(struct aac_queue_table) + AAC_QUEUE_ALIGN];

	/* buffer for text messages from the controller */
	char	ac_printf[AAC_PRINTF_BUFSIZE];
    
	/* fib for synchronous commands */
	struct aac_fib ac_sync_fib;
};
#define AAC_COMMON_ALLOCSIZE (8192 + sizeof(struct aac_common))

/*
 * Interface operations
 */
struct aac_interface {
	int	(*aif_get_fwstatus)(struct aac_softc *);
	void	(*aif_qnotify)(struct aac_softc *, int);
	int	(*aif_get_istatus)(struct aac_softc *);
	void	(*aif_set_istatus)(struct aac_softc *, int);
	void	(*aif_set_mailbox)(struct aac_softc *, u_int32_t,
	    u_int32_t, u_int32_t, u_int32_t, u_int32_t);
	int	(*aif_get_mailbox)(struct aac_softc *, int mb);
	void	(*aif_set_interrupts)(struct aac_softc *, int);
};
extern struct aac_interface aac_fa_interface;
extern struct aac_interface aac_sa_interface;
extern struct aac_interface aac_rx_interface;
extern struct aac_interface aac_rkt_interface;

#define AAC_GET_FWSTATUS(sc)		((sc)->aac_if.aif_get_fwstatus(sc))
#define AAC_QNOTIFY(sc, qbit) \
	((sc)->aac_if.aif_qnotify((sc), (qbit)))
#define AAC_GET_ISTATUS(sc)		((sc)->aac_if.aif_get_istatus(sc))
#define AAC_CLEAR_ISTATUS(sc, mask) \
	((sc)->aac_if.aif_set_istatus((sc), (mask)))
#define AAC_SET_MAILBOX(sc, command, arg0, arg1, arg2, arg3) \
	do {								\
		((sc)->aac_if.aif_set_mailbox((sc), (command), (arg0),	\
		    (arg1), (arg2), (arg3)));				\
	} while(0)
#define AAC_GET_MAILBOX(sc, mb) \
	((sc)->aac_if.aif_get_mailbox(sc, (mb)))
#define	AAC_MASK_INTERRUPTS(sc)	\
	((sc)->aac_if.aif_set_interrupts((sc), 0))
#define AAC_UNMASK_INTERRUPTS(sc) \
	((sc)->aac_if.aif_set_interrupts((sc), 1))

#define AAC_SETREG4(sc, reg, val) \
	bus_space_write_4((sc)->aac_memt, (sc)->aac_memh, (reg), (val))
#define AAC_GETREG4(sc, reg) \
	bus_space_read_4((sc)->aac_memt, (sc)->aac_memh, (reg))
#define AAC_SETREG2(sc, reg, val) \
	bus_space_write_2((sc)->aac_memt, (sc)->aac_memh, (reg), (val))
#define AAC_GETREG2(sc, reg) \
	bus_space_read_2((sc)->aac_memt, (sc)->aac_memh, (reg))
#define AAC_SETREG1(sc, reg, val) \
	bus_space_write_1((sc)->aac_memt, (sc)->aac_memh, (reg), (val))
#define AAC_GETREG1(sc, reg) \
	bus_space_read_1((sc)->aac_memt, (sc)->aac_memh, (reg))

/* Define the OS version specific locks */
typedef struct rwlock aac_lock_t;
#define AAC_LOCK_INIT(l, s)	do { \
    rw_init((l), "aaclock"); \
    AAC_DPRINTF(AAC_D_LOCK, ("%s: init lock @@%s: %d\n", \
	        sc->aac_dev.dv_xname, __FUNCTION__, __LINE__)); \
} while (0)

#define AAC_LOCK_ACQUIRE(l) do { \
    AAC_DPRINTF(AAC_D_LOCK, ("%s: lock @@%s: %d\n", \
	        sc->aac_dev.dv_xname, __FUNCTION__, __LINE__)); \
    rw_enter_write((l)); \
} while (0)

#define AAC_LOCK_RELEASE(l) do { \
    rw_exit_write((l)); \
    AAC_DPRINTF(AAC_D_LOCK, ("%s: unlock @@%s: %d\n", \
	        sc->aac_dev.dv_xname, __FUNCTION__, __LINE__)); \
} while (0)

/*
 * Per-container data structure
 */
struct aac_container
{
	struct aac_mntobj co_mntobj;
	int				co_found;
	TAILQ_ENTRY(aac_container)	co_link;
};

/*
 * A command contol block, one for each corresponding command index of the
 * controller.
 */
struct aac_command
{
	TAILQ_ENTRY(aac_command) cm_link;	/* list linkage */

	struct aac_softc	*cm_sc;		/* controller that owns us */

	struct aac_fib 		*cm_fib;	/* FIB for this command */
	bus_addr_t		cm_fibphys;	/* bus address of the FIB */
	void			*cm_data;
	size_t			cm_datalen;
	bus_dmamap_t		cm_datamap;
	struct aac_sg_table	*cm_sgtable;	/* pointer to s/g table */

	u_int			cm_flags;
#define AAC_CMD_MAPPED		(1<<0)	/* command has had its data mapped */
#define AAC_CMD_DATAIN		(1<<1)	/* command involves data moving
					 * from controller to host */
#define AAC_CMD_DATAOUT		(1<<2)	/* command involves data moving
					 * from host to controller */
#define AAC_CMD_COMPLETED	(1<<3)	/* command has been completed */
#define AAC_CMD_TIMEDOUT	(1<<4)	/* command taken too long */
#define AAC_ON_AACQ_FREE	(1<<5)
#define AAC_ON_AACQ_READY	(1<<6)
#define AAC_ON_AACQ_BUSY	(1<<7)
#define AAC_ON_AACQ_BIO		(1<<8)
#define AAC_ON_AACQ_MASK	((1<<5)|(1<<6)|(1<<7)|(1<<8))
#define AAC_QUEUE_FRZN		(1<<9)	/* Freeze the processing of
					 * commands on the queue. */
#define AAC_ACF_WATCHDOG 	(1<<10)

	void			(*cm_complete)(struct aac_command *);
	void			*cm_private;
	u_int32_t		cm_blkno;
	u_int32_t		cm_bcount;
	time_t			cm_timestamp;	/* command creation time */
	int			cm_queue;
	int			cm_index;
};

struct aac_fibmap {
	TAILQ_ENTRY(aac_fibmap) fm_link;	/* list linkage */
	struct aac_fib		*aac_fibs;
	bus_dmamap_t		aac_fibmap;
 	bus_dma_segment_t	aac_seg;
	int			aac_nsegs;
	struct aac_command	*aac_commands;
};

/*
 * Command queue statistics
 */
#define AACQ_FREE       0
#define AACQ_BIO        1
#define AACQ_READY      2
#define AACQ_BUSY       3
#define AACQ_COUNT      4       /* total number of queues */

struct aac_qstat {
        u_int32_t       q_length;
        u_int32_t       q_max;
};

/*
 * Per-controller structure.
 */
struct aac_softc
{
	struct device aac_dev;
	void   *aac_ih;
	struct	scsi_link aac_link;	/* Virtual SCSI bus for cache devs */

	bus_space_tag_t aac_memt;
	bus_space_handle_t aac_memh;
	bus_dma_tag_t aac_dmat;		/* parent DMA tag */

	/* controller features, limits and status */
	int	aac_state;
#define AAC_STATE_SUSPEND	(1<<0)
#define	AAC_STATE_OPEN		(1<<1)
#define AAC_STATE_INTERRUPTS_ON	(1<<2)
#define AAC_STATE_AIF_SLEEPER	(1<<3)
	struct FsaRevision aac_revision;

	int	aac_hwif;	/* controller hardware interface */
#define AAC_HWIF_I960RX		0
#define AAC_HWIF_STRONGARM	1
#define AAC_HWIF_FALCON		2
#define AAC_HWIF_RKT		3
#define AAC_HWIF_UNKNOWN	-1

	struct aac_common *aac_common;
	bus_dmamap_t		aac_common_map;
	u_int32_t aac_common_busaddr;
	struct aac_interface aac_if;

	/* command/fib resources */
	TAILQ_HEAD(,aac_fibmap)	aac_fibmap_tqh;
	u_int			total_fibs;
	struct aac_command	*aac_commands;
	struct scsi_iopool	aac_iopool;

	/* command management */
	struct mutex		 aac_free_mtx;
	TAILQ_HEAD(,aac_command) aac_free;	/* command structures 
						 * available for reuse */
	TAILQ_HEAD(,aac_command) aac_ready;	/* commands on hold for
						 * controller resources */
	TAILQ_HEAD(,aac_command) aac_busy;
	TAILQ_HEAD(,aac_command) aac_bio;

	/* command management */
	struct aac_queue_table *aac_queues;
	struct aac_queue_entry *aac_qentries[AAC_QUEUE_COUNT];

	struct aac_qstat	aac_qstat[AACQ_COUNT];	/* queue statistics */

	/* connected containters */
	TAILQ_HEAD(,aac_container)	aac_container_tqh;
	aac_lock_t		aac_container_lock;

	/* Protect the sync fib */
#define AAC_SYNC_LOCK_FORCE	(1 << 0)
	aac_lock_t		aac_sync_lock;

	aac_lock_t		aac_io_lock;

	struct {
		u_int8_t hd_present;
		u_int8_t hd_is_logdrv;
		u_int8_t hd_is_arraydrv;
		u_int8_t hd_is_master;
		u_int8_t hd_is_parity;
		u_int8_t hd_is_hotfix;
		u_int8_t hd_master_no;
		u_int8_t hd_lock;
		u_int8_t hd_heads;
		u_int8_t hd_secs;
		u_int16_t hd_devtype;
		u_int32_t hd_size;
		u_int8_t hd_ldr_no;
		u_int8_t hd_rw_attribs;
		u_int32_t hd_start_sec;
	} aac_hdr[AAC_MAX_CONTAINERS];
	int			aac_container_count;

	/* management interface */
	aac_lock_t		aac_aifq_lock;
	struct aac_aif_command	aac_aifq[AAC_AIFQ_LENGTH];
	int			aac_aifq_head;
	int			aac_aifq_tail;
	struct selinfo		aac_select;
	struct proc		*aifthread;
	int			aifflags;
#define AAC_AIFFLAGS_RUNNING	(1 << 0)
#define AAC_AIFFLAGS_AIF	(1 << 1)
#define	AAC_AIFFLAGS_EXIT	(1 << 2)
#define AAC_AIFFLAGS_EXITED	(1 << 3)
#define	AAC_AIFFLAGS_COMPLETE	(1 << 4)
#define AAC_AIFFLAGS_PRINTF	(1 << 5)
#define AAC_AIFFLAGS_PENDING	(AAC_AIFFLAGS_AIF | AAC_AIFFLAGS_COMPLETE | \
				 AAC_AIFFLAGS_PRINTF)

	u_int32_t		flags;
#define AAC_FLAGS_PERC2QC	(1 << 0)
#define	AAC_FLAGS_ENABLE_CAM	(1 << 1)	/* No SCSI passthrough */
#define	AAC_FLAGS_CAM_NORESET	(1 << 2)	/* Fake SCSI resets */
#define	AAC_FLAGS_CAM_PASSONLY	(1 << 3)	/* Only create pass devices */
#define	AAC_FLAGS_SG_64BIT	(1 << 4)	/* Use 64-bit S/G addresses */
#define	AAC_FLAGS_4GB_WINDOW	(1 << 5)	/* Device can access host mem
						 * 2GB-4GB range */
#define	AAC_FLAGS_NO4GB		(1 << 6)	/* Can't access host mem >2GB*/
#define	AAC_FLAGS_256FIBS	(1 << 7)	/* Can only do 256 commands */
#define	AAC_FLAGS_BROKEN_MEMMAP (1 << 8)	/* Broken HostPhysMemPages */

	u_int32_t		supported_options;
	int			aac_max_fibs;
	void			*aac_sdh;
};

int	aac_attach(struct aac_softc *);
int	aac_intr(void *);

/* These all require correctly aligned buffers */
static __inline__ void aac_enc16(u_int8_t *, u_int16_t);
static __inline__ void aac_enc32(u_int8_t *, u_int32_t);
static __inline__ u_int16_t aac_dec16(u_int8_t *);
static __inline__ u_int32_t aac_dec32(u_int8_t *);

static __inline__ void
aac_enc16(addr, value)
	u_int8_t *addr;
	u_int16_t value;
{
	*(u_int16_t *)addr = htole16(value);
}

static __inline__ void
aac_enc32(addr, value)
	u_int8_t *addr;
	u_int32_t value;
{
	*(u_int32_t *)addr = htole32(value);
}

static __inline__ u_int16_t
aac_dec16(addr)
	u_int8_t *addr;
{
	return letoh16(*(u_int16_t *)addr);
}

static __inline__ u_int32_t
aac_dec32(addr)
	u_int8_t *addr;
{
	return letoh32(*(u_int32_t *)addr);
}

/* Declarations copied from aac.c */
#ifdef AAC_DEBUG
void aac_print_fib(struct aac_softc *, struct aac_fib *, const char *);
void aac_print_aif(struct aac_softc *, struct aac_aif_command *);
#endif
void aac_handle_aif(struct aac_softc *, struct aac_fib *);





/*
 * Queue primitives for driver queues.
 */
#define AACQ_ADD(sc, qname)					\
	do {							\
		struct aac_qstat *qs;				\
								\
		qs = &(sc)->aac_qstat[qname];			\
								\
		qs->q_length++;					\
		if (qs->q_length > qs->q_max)			\
			qs->q_max = qs->q_length;		\
	} while (0)

#define AACQ_REMOVE(sc, qname)    (sc)->aac_qstat[qname].q_length--
#define AACQ_INIT(sc, qname)				\
	do {						\
		sc->aac_qstat[qname].q_length = 0;	\
		sc->aac_qstat[qname].q_max = 0;		\
	} while (0)


#define AACQ_COMMAND_QUEUE(name, index)					\
static __inline void							\
aac_initq_ ## name (struct aac_softc *sc)				\
{									\
	TAILQ_INIT(&sc->aac_ ## name);					\
	AACQ_INIT(sc, index);						\
}									\
static __inline void							\
aac_enqueue_ ## name (struct aac_command *cm)				\
{									\
	AAC_DPRINTF(AAC_D_CMD, (": enqueue " #name));			\
	if ((cm->cm_flags & AAC_ON_AACQ_MASK) != 0) {			\
		printf("command %p is on another queue, flags = %#x\n",	\
		       cm, cm->cm_flags);				\
		panic("command is on another queue");			\
	}								\
	TAILQ_INSERT_TAIL(&cm->cm_sc->aac_ ## name, cm, cm_link);	\
	cm->cm_flags |= AAC_ON_ ## index;				\
	AACQ_ADD(cm->cm_sc, index);					\
}									\
static __inline void							\
aac_requeue_ ## name (struct aac_command *cm)				\
{									\
	AAC_DPRINTF(AAC_D_CMD, (": requeue " #name));			\
	if ((cm->cm_flags & AAC_ON_AACQ_MASK) != 0) {			\
		printf("command %p is on another queue, flags = %#x\n",	\
		       cm, cm->cm_flags);				\
		panic("command is on another queue");			\
	}								\
	TAILQ_INSERT_HEAD(&cm->cm_sc->aac_ ## name, cm, cm_link);	\
	cm->cm_flags |= AAC_ON_ ## index;				\
	AACQ_ADD(cm->cm_sc, index);					\
}									\
static __inline struct aac_command *					\
aac_dequeue_ ## name (struct aac_softc *sc)				\
{									\
	struct aac_command *cm;						\
									\
	if ((cm = TAILQ_FIRST(&sc->aac_ ## name)) != NULL) {		\
		AAC_DPRINTF(AAC_D_CMD, (": dequeue " #name));		\
		if ((cm->cm_flags & AAC_ON_ ## index) == 0) {		\
			printf("dequeue - command %p not in queue, flags = %#x, "	\
		       	       "bit = %#x\n", cm, cm->cm_flags,		\
			       AAC_ON_ ## index);			\
			panic("command not in queue");			\
		}							\
		TAILQ_REMOVE(&sc->aac_ ## name, cm, cm_link);		\
		cm->cm_flags &= ~AAC_ON_ ## index;			\
		AACQ_REMOVE(sc, index);					\
	}								\
	return(cm);							\
}									\
static __inline void							\
aac_remove_ ## name (struct aac_command *cm)				\
{									\
	AAC_DPRINTF(AAC_D_CMD, (": remove " #name));			\
	if ((cm->cm_flags & AAC_ON_ ## index) == 0) {			\
		printf("remove - command %p not in queue, flags = %#x, "		\
		       "bit = %#x\n", cm, cm->cm_flags, 		\
		       AAC_ON_ ## index);				\
		panic("command not in queue");				\
	}								\
	TAILQ_REMOVE(&cm->cm_sc->aac_ ## name, cm, cm_link);		\
	cm->cm_flags &= ~AAC_ON_ ## index;				\
	AACQ_REMOVE(cm->cm_sc, index);					\
}									\
struct hack

AACQ_COMMAND_QUEUE(free, AACQ_FREE);
AACQ_COMMAND_QUEUE(ready, AACQ_READY);
AACQ_COMMAND_QUEUE(busy, AACQ_BUSY);
AACQ_COMMAND_QUEUE(bio, AACQ_BIO);

static __inline void
aac_print_printf(struct aac_softc *sc)
{
	/*
	 * XXX We have the ability to read the length of the printf string
	 * from out of the mailboxes.
	 */
	printf("** %s: %.*s", sc->aac_dev.dv_xname, AAC_PRINTF_BUFSIZE,
	       sc->aac_common->ac_printf);
	sc->aac_common->ac_printf[0] = 0;
	AAC_QNOTIFY(sc, AAC_DB_PRINTF);
}
@


1.12
log
@remove a XS_NO_CCB case by moving aac to iopools.

eyes and ok by krw@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.11 2014/01/17 22:20:32 dlg Exp $	*/
a39 3

/* compatibility */
#define time_second (mono_time.tv_sec)
@


1.11
log
@replace aacminphys with scsi_minphys. both are just wrappers around
minphys.
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.10 2014/01/17 22:18:27 dlg Exp $	*/
d351 1
d354 1
@


1.10
log
@aacvar advertises a public api which is only used inside aac.c. make it
"private" so i dont feel bad about changing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.9 2013/01/06 22:06:54 martynas Exp $	*/
a428 1
void	aacminphys(struct buf *, struct scsi_link *);
@


1.9
log
@acknowlege -> acknowledge
compatability -> compatibility

OK jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.8 2009/02/16 21:19:06 miod Exp $	*/
a427 11

/*
 * Public functions
 */
extern int	aac_wait_command(struct aac_command *, int);
extern int	aac_alloc_command(struct aac_softc *, struct aac_command **);
extern void	aac_release_command(struct aac_command *);
extern int	aac_alloc_sync_fib(struct aac_softc *, struct aac_fib **, int);
extern void	aac_release_sync_fib(struct aac_softc *);
extern int	aac_sync_fib(struct aac_softc *, u_int32_t, u_int32_t, 
			     struct aac_fib *, u_int16_t);
@


1.8
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.7 2006/05/07 20:12:41 tedu Exp $	*/
d41 1
a41 1
/* compatability */
@


1.7
log
@add a name to rwlock so that we can tell where procs are getting stuck
without breaking into ddb.  doubles the size of rwlock [1], but moving
forward this really helps.  ok/tested pedro fgsch millert krw
[1 - next person to add a field to this struct gets whipped with a wet noodle]
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.6 2006/04/22 02:36:26 brad Exp $	*/
d440 1
a440 1
void	aacminphys(struct buf *);
@


1.6
log
@Add support for the Adaptec RAID-On-Chip architecture.  This in turn
provides support for the Adaptec 2130S and 2230SLP adapters.

From FreeBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.5 2005/11/18 05:39:10 nate Exp $	*/
d221 1
a221 1
    rw_init((l)); \
@


1.5
log
@Major improvements to the aac(4) device driver.
- decouple the command structures from scsi structures, allowing non block
oriented commands (e.g. management commands) to be built.
- redesign the various command queues to remove race conditions and to allow
commands from multiple sources to coexist in the system
- move major processing of commands and messages to a dedicated kernel
thread to avoid spending too long in the interrupt handler
- add device data structures for various management commands to the header
file

Much code from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.4 2003/10/21 18:58:48 jmc Exp $	*/
d185 1
d338 2
a339 1
#define	AAC_HWIF_FALCON		2
@


1.4
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.3 2002/06/11 08:55:12 espie Exp $	*/
d41 3
d45 2
d49 9
a57 5
#define AAC_D_INTR	0x01
#define AAC_D_MISC	0x02
#define AAC_D_CMD	0x04
#define AAC_D_QUEUE	0x08
#define AAC_D_IO	0x10
d60 4
a63 1
#define AAC_PRINT_FIB(sc, fib)	aac_print_fib((sc), (fib), __func__)
d82 14
d107 12
a118 1
 * Wait this long for a lost interrupt to get detected.
d120 1
a120 1
#define AAC_WATCH_TIMEOUT	10000		/* 10000 * 1ms = 10s */
d123 1
a123 1
 * Timeout for immediate commands.
d125 1
a125 1
#define AAC_IMMEDIATE_TIMEOUT	30
d137 1
d167 1
d179 1
a179 1
	int	(*aif_get_mailboxstatus)(struct aac_softc *);
d182 2
a184 1
extern struct aac_interface aac_sa_interface;
d186 1
a186 1
#define AAC_GET_FWSTATUS(sc)		((sc)->sc_if.aif_get_fwstatus(sc))
d188 2
a189 2
	((sc)->sc_if.aif_qnotify((sc), (qbit)))
#define AAC_GET_ISTATUS(sc)		((sc)->sc_if.aif_get_istatus(sc))
d191 1
a191 1
	((sc)->sc_if.aif_set_istatus((sc), (mask)))
d194 1
a194 1
		((sc)->sc_if.aif_set_mailbox((sc), (command), (arg0),	\
d197 2
a198 2
#define AAC_GET_MAILBOXSTATUS(sc) \
	((sc)->sc_if.aif_get_mailboxstatus(sc))
d200 1
a200 1
	((sc)->sc_if.aif_set_interrupts((sc), 0))
d202 1
a202 1
	((sc)->sc_if.aif_set_interrupts((sc), 1))
d205 1
a205 1
	bus_space_write_4((sc)->sc_memt, (sc)->sc_memh, (reg), (val))
d207 1
a207 1
	bus_space_read_4((sc)->sc_memt, (sc)->sc_memh, (reg))
d209 1
a209 1
	bus_space_write_2((sc)->sc_memt, (sc)->sc_memh, (reg), (val))
d211 1
a211 1
	bus_space_read_2((sc)->sc_memt, (sc)->sc_memh, (reg))
d213 1
a213 1
	bus_space_write_1((sc)->sc_memt, (sc)->sc_memh, (reg), (val))
d215 21
a235 1
	bus_space_read_1((sc)->sc_memt, (sc)->sc_memh, (reg))
d243 2
a244 1
	struct device co_disk;
d251 60
a310 13
struct aac_ccb {
	TAILQ_ENTRY(aac_ccb) ac_chain;
	struct scsi_xfer *ac_xs;
	struct aac_fib *ac_fib;		/* FIB associated with this command */
	bus_addr_t ac_fibphys;		/* bus address of the FIB */
	bus_dmamap_t ac_dmamap_xfer;
	struct aac_sg_table *ac_sgtable;/* pointer to s/g table in command */
	int ac_timeout;
	u_int32_t ac_blockno;
	u_int32_t ac_blockcnt;
	u_int8_t ac_flags;
#define AAC_ACF_WATCHDOG 	0x1
#define AAC_ACF_COMPLETED 	0x2
d316 9
a324 8
struct aac_softc {
	struct device sc_dev;
	void   *sc_ih;
	struct	scsi_link sc_link;	/* Virtual SCSI bus for cache devs */

	bus_space_tag_t sc_memt;
	bus_space_handle_t sc_memh;
	bus_dma_tag_t sc_dmat;		/* parent DMA tag */
d327 1
a327 1
	int	sc_state;
d332 1
a332 1
	struct FsaRevision sc_revision;
d334 1
a334 1
	int	sc_hwif;	/* controller hardware interface */
d337 2
d340 17
a356 13
	struct aac_common *sc_common;
	u_int32_t sc_common_busaddr;
	struct aac_interface sc_if;

	/* XXX This should really be dynamic.  It is very wasteful now. */
	struct aac_ccb sc_ccbs[AAC_ADAP_NORM_CMD_ENTRIES];
	TAILQ_HEAD(, aac_ccb) sc_free_ccb, sc_ccbq;
	/* commands on hold for controller resources */
	TAILQ_HEAD(, aac_ccb) sc_ready;
	/* commands which have been returned by the controller */
	TAILQ_HEAD(, aac_ccb) sc_completed;
	LIST_HEAD(, scsi_xfer) sc_queue;
	struct scsi_xfer *sc_queuelast;
d359 14
a372 2
	struct aac_queue_table *sc_queues;
	struct aac_queue_entry *sc_qentries[AAC_QUEUE_COUNT];
d390 35
a424 1
	} sc_hdr[AAC_MAX_CONTAINERS];
d427 10
a436 4
/* XXX These have to become spinlocks in case of SMP */
#define AAC_LOCK(sc) splbio()
#define AAC_UNLOCK(sc, lock) splx(lock)
typedef int aac_lock_t;
a441 1
#ifdef __GNUC__
d478 11
d490 1
a490 3
 * Queue primitives
 *
 * These are broken out individually to make statistics gathering easier.
d492 91
d584 2
a585 2
static __inline__ void
aac_enqueue_completed(struct aac_ccb *ccb)
d587 8
a594 6
	struct aac_softc *sc = ccb->ac_xs->sc_link->adapter_softc;
	aac_lock_t lock;

	lock = AAC_LOCK(sc);
	TAILQ_INSERT_TAIL(&sc->sc_completed, ccb, ac_chain);
	AAC_UNLOCK(sc, lock);
a595 14

static __inline__ struct aac_ccb *
aac_dequeue_completed(struct aac_softc *sc)
{
	struct aac_ccb *ccb;
	aac_lock_t lock;

	lock = AAC_LOCK(sc);
	if ((ccb = TAILQ_FIRST(&sc->sc_completed)) != NULL)
		TAILQ_REMOVE(&sc->sc_completed, ccb, ac_chain);
	AAC_UNLOCK(sc, lock);
	return (ccb);
}
#endif
@


1.3
log
@kill __FUNCTION__
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.2 2002/03/14 01:26:53 millert Exp $	*/
d35 1
a35 1
 * hardware dontion from Nocom.  I want to thank them for their support.
d103 1
a103 1
 * The ordering of this strucure may be important; we copy the Linux driver:
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.1 2000/11/10 09:39:36 niklas Exp $	*/
d51 1
a51 1
#define AAC_PRINT_FIB(sc, fib)	aac_print_fib((sc), (fib), __FUNCTION__)
@


1.1
log
@Adaptec "FSA" RAID driver
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 8
a141 8
	int	(*aif_get_fwstatus) __P((struct aac_softc *));
	void	(*aif_qnotify) __P((struct aac_softc *, int));
	int	(*aif_get_istatus) __P((struct aac_softc *));
	void	(*aif_set_istatus) __P((struct aac_softc *, int));
	void	(*aif_set_mailbox) __P((struct aac_softc *, u_int32_t,
	    u_int32_t, u_int32_t, u_int32_t, u_int32_t));
	int	(*aif_get_mailboxstatus) __P((struct aac_softc *));
	void	(*aif_set_interrupts) __P((struct aac_softc *, int));
d271 3
a273 3
void	aacminphys __P((struct buf *));
int	aac_attach __P((struct aac_softc *));
int	aac_intr __P((void *));
d277 4
a280 4
static __inline__ void aac_enc16 __P((u_int8_t *, u_int16_t));
static __inline__ void aac_enc32 __P((u_int8_t *, u_int32_t));
static __inline__ u_int16_t aac_dec16 __P((u_int8_t *));
static __inline__ u_int32_t aac_dec32 __P((u_int8_t *));
@


1.1.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.1 2000/11/10 09:39:36 niklas Exp $	*/
d134 8
a141 8
	int	(*aif_get_fwstatus)(struct aac_softc *);
	void	(*aif_qnotify)(struct aac_softc *, int);
	int	(*aif_get_istatus)(struct aac_softc *);
	void	(*aif_set_istatus)(struct aac_softc *, int);
	void	(*aif_set_mailbox)(struct aac_softc *, u_int32_t,
	    u_int32_t, u_int32_t, u_int32_t, u_int32_t);
	int	(*aif_get_mailboxstatus)(struct aac_softc *);
	void	(*aif_set_interrupts)(struct aac_softc *, int);
d271 3
a273 3
void	aacminphys(struct buf *);
int	aac_attach(struct aac_softc *);
int	aac_intr(void *);
d277 4
a280 4
static __inline__ void aac_enc16(u_int8_t *, u_int16_t);
static __inline__ void aac_enc32(u_int8_t *, u_int32_t);
static __inline__ u_int16_t aac_dec16(u_int8_t *);
static __inline__ u_int32_t aac_dec32(u_int8_t *);
@


1.1.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.1.8.1 2002/06/11 03:42:16 art Exp $	*/
d51 1
a51 1
#define AAC_PRINT_FIB(sc, fib)	aac_print_fib((sc), (fib), __func__)
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: aacvar.h,v 1.1 2000/11/10 09:39:36 niklas Exp $	*/
@


1.1.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 8
a141 8
	int	(*aif_get_fwstatus)(struct aac_softc *);
	void	(*aif_qnotify)(struct aac_softc *, int);
	int	(*aif_get_istatus)(struct aac_softc *);
	void	(*aif_set_istatus)(struct aac_softc *, int);
	void	(*aif_set_mailbox)(struct aac_softc *, u_int32_t,
	    u_int32_t, u_int32_t, u_int32_t, u_int32_t);
	int	(*aif_get_mailboxstatus)(struct aac_softc *);
	void	(*aif_set_interrupts)(struct aac_softc *, int);
d271 3
a273 3
void	aacminphys(struct buf *);
int	aac_attach(struct aac_softc *);
int	aac_intr(void *);
d277 4
a280 4
static __inline__ void aac_enc16(u_int8_t *, u_int16_t);
static __inline__ void aac_enc32(u_int8_t *, u_int32_t);
static __inline__ u_int16_t aac_dec16(u_int8_t *);
static __inline__ u_int32_t aac_dec32(u_int8_t *);
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d51 1
a51 1
#define AAC_PRINT_FIB(sc, fib)	aac_print_fib((sc), (fib), __func__)
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d35 1
a35 1
 * hardware donation from Nocom.  I want to thank them for their support.
d103 1
a103 1
 * The ordering of this structure may be important; we copy the Linux driver:
@


