head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.16
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.10
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.12
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.4
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.4
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.2.0.28
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.26
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.24
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.22
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.20
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.18
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.16
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.14
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.12
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.10
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.8
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2
	SMP_BASE:1.1
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.11
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.21.20.23.49;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.26.22.55.58;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.26.22.46.25;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.26.18.05.12;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.20.20.46.18;	author mk;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.26.22.03.11;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.30.07.55.56;	author cmetz;	state Exp;
branches
	1.1.2.1
	1.1.12.1;
next	;

1.1.2.1
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	;

1.1.12.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@/*	$OpenBSD: dptvar.h,v 1.10 2011/06/21 20:23:49 matthew Exp $	*/
/*	$NetBSD: dptvar.h,v 1.5 1999/10/23 16:26:32 ad Exp $	*/

/*
 * Copyright (c) 1999 Andy Doran <ad@@NetBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _IC_DPTVAR_H_
#define _IC_DPTVAR_H_ 1
#ifdef _KERNEL

#define	CCB_OFF(sc,m)	((u_long)(m) - (u_long)((sc)->sc_ccbs))

#define CCB_ALLOC	0x01	/* CCB allocated */
#define CCB_ABORT	0x02	/* abort has been issued on this CCB */
#define CCB_INTR	0x04	/* HBA interrupted for this CCB */
#define CCB_PRIVATE	0x08	/* ours; don't talk to scsipi when done */ 

struct dpt_ccb {
	struct eata_cp	ccb_eata_cp;		/* EATA command packet */
	struct eata_sg	ccb_sg[DPT_SG_SIZE];	/* SG element list */
	volatile int	ccb_flg;		/* CCB flags */
	int		ccb_timeout;		/* timeout in ms */
	u_int32_t	ccb_ccbpa;		/* physical addr of this CCB */
	bus_dmamap_t	ccb_dmamap_xfer;	/* dmamap for data xfers */
	int		ccb_hba_status;		/* from status packet */
	int		ccb_scsi_status;	/* from status packet */
	int		ccb_id;			/* unique ID of this CCB */
	SLIST_ENTRY(dpt_ccb) ccb_chain;		/* link to next CCB */
	struct scsi_sense_data ccb_sense;
	struct scsi_xfer *ccb_xs;
};

struct dpt_channel {
	struct dpt_softc *ch_sc;
	int ch_index;
};

struct dpt_softc {
	struct device sc_dv;		/* generic device data */
	bus_space_handle_t sc_ioh;	/* bus space handle */
	struct scsi_link sc_link[3];	/* prototype link for each channel */
	struct dpt_channel sc_channel[3];
	struct eata_cfg sc_ec;		/* EATA configuration data */
	bus_space_tag_t	sc_iot;		/* bus space tag */
	bus_dma_tag_t	sc_dmat;	/* bus DMA tag */
	bus_dmamap_t	sc_dmamap_ccb;	/* maps the CCBs */
	void	 	*sc_ih;		/* interrupt handler cookie */
	struct dpt_ccb	*sc_ccbs;	/* all our CCBs */
	struct eata_sp	*sc_statpack;	/* EATA status packet */
	int		sc_spoff;	/* status packet offset in dmamap */
	u_int32_t	sc_sppa;	/* status packet physical address */
	caddr_t		sc_scr;		/* scratch area */
	int		sc_scrlen;	/* scratch area length */
	int		sc_scroff;	/* scratch area offset in dmamap */
	u_int32_t	sc_scrpa;	/* scratch area physical address */
	int		sc_hbaid[3];	/* ID of HBA on each channel */
	int		sc_nccbs;	/* number of CCBs available */
	int		sc_open;	/* device is open */
	SLIST_HEAD(, dpt_ccb) sc_free_ccb;/* free ccb list */
	struct mutex	sc_ccb_mtx;	/* free ccb list mutex */
	struct scsi_iopool sc_iopool;
};

int	dpt_intr(void *);
int	dpt_readcfg(struct dpt_softc *);
void	dpt_init(struct dpt_softc *, const char *);
void	dpt_shutdown(void *);
void	dpt_timeout(void *);
void	dpt_minphys(struct buf *, struct scsi_link *);
void	dpt_scsi_cmd(struct scsi_xfer *);
int	dpt_wait(struct dpt_softc *, u_int8_t, u_int8_t, int);
int	dpt_poll(struct dpt_softc *, struct dpt_ccb *);
int	dpt_cmd(struct dpt_softc *, struct eata_cp *, u_int32_t, int, int);
void	dpt_hba_inquire(struct dpt_softc *, struct eata_inquiry_data **);
void	dpt_reset_ccb(struct dpt_softc *, struct dpt_ccb *);
void	dpt_done_ccb(struct dpt_softc *, struct dpt_ccb *);
int	dpt_init_ccb(struct dpt_softc *, struct dpt_ccb *);
int	dpt_create_ccbs(struct dpt_softc *, struct dpt_ccb *, int);
#ifdef DEBUG
void	dpt_dump_sp(struct eata_sp *);
#endif

#endif	/* _KERNEL */
#endif	/* !defined _IC_DPTVAR_H_ */
@


1.10
log
@Two dpt(4) fixes:

  1. Change adapter_softc to point to a per-channel intermediary
     object instead of pointing to the dpt_softc directly.  This
     removes dpt(4) dependency on scsibus unit numbers.

  2. Fix dpt(4) to use a struct scsibus_attach_args instead of a
     struct scsi_link for attaching the scsibus.  (Evidently no one
     has tried using dpt(4) since Nov 2006...)

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.9 2011/04/26 22:55:58 matthew Exp $	*/
a71 1
	void		*sc_sdh;	/* shutdown hook */
@


1.9
log
@No point in a per-attachment scsi_adapter; move to global dpt_switch
like we do in other SCSI drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.8 2011/04/26 22:46:25 matthew Exp $	*/
d57 5
d66 1
@


1.8
log
@A plausible attempt at iopoolifying dpt(4).

ok dlg@@; miod@@ warns me to not hold my breath on anyone testing this
diff though...
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.7 2011/04/26 18:05:12 matthew Exp $	*/
a59 1
	struct scsi_adapter sc_adapter;/* scsipi adapter */
@


1.7
log
@Get rid of NetBSD/OpenBSD ifdefs; our SCSI stacks have diverged too
much for them to make sense anymore.

Diff prepared with sed; no change to dpt.o on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.6 2010/07/20 20:46:18 mk Exp $	*/
d80 2
a95 1
void	dpt_free_ccb(struct dpt_softc *, struct dpt_ccb *);
a98 1
struct dpt_ccb	*dpt_alloc_ccb(struct dpt_softc *, int);
@


1.6
log
@Use an SLIST rather than a TAILQ for the ccb free list.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.5 2010/03/23 01:57:19 krw Exp $	*/
a52 5
#ifdef __NetBSD__
	struct scsipi_sense_data ccb_sense;	/* SCSI sense data on error */
	struct scsipi_xfer *ccb_xs;		/* initiating SCSI command */
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a54 1
#endif /* __OpenBSD__ */
a59 5
#ifdef __NetBSD__
	struct scsipi_adapter sc_adapter;/* scsipi adapter */
	struct scsipi_link sc_link[3];	/* prototype link for each channel */
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a61 1
#endif /* __OpenBSD__ */
a87 4
#ifdef __NetBSD__
int	dpt_scsi_cmd(struct scsipi_xfer *);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a88 1
#endif /* __OpenBSD__ */
@


1.5
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.4 2009/02/16 21:19:06 miod Exp $	*/
d52 1
a52 1
	TAILQ_ENTRY(dpt_ccb) ccb_chain;		/* link to next CCB */
d91 1
a91 1
	TAILQ_HEAD(, dpt_ccb) sc_free_ccb;/* free ccb list */
@


1.4
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.3 2008/11/26 22:03:11 krw Exp $	*/
d104 1
a104 1
int	dpt_scsi_cmd(struct scsi_xfer *);
@


1.3
log
@Stop maintaining internal queues of received scsi_xfer structures.

We can now just push unwanted ones back up into the SCSI layer
with NO_CCB like other drivers.

"Please do so" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.2 2002/03/14 01:26:54 millert Exp $	*/
d99 1
a99 1
void	dpt_minphys(struct buf *);
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.1 1999/11/30 07:55:56 cmetz Exp $	*/
a91 7
#ifdef __NetBSD__
	TAILQ_HEAD(, scsipi_xfer) sc_queue;/* pending commands */
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
	LIST_HEAD(, scsi_xfer) sc_queue;/* pending commands */
	struct scsi_xfer *sc_queuelast;
#endif /* __NetBSD__ */
@


1.1
log
@Added port of the NetBSD (-current) DPT SmartCache III/IV PCI/EISA host adapter
driver to OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.0 1999/10/23 16:26:32 ad Exp $	*/
d101 6
a106 6
int	dpt_intr __P((void *));
int	dpt_readcfg __P((struct dpt_softc *));
void	dpt_init __P((struct dpt_softc *, const char *));
void	dpt_shutdown __P((void *));
void	dpt_timeout __P((void *));
void	dpt_minphys __P((struct buf *));
d108 1
a108 1
int	dpt_scsi_cmd __P((struct scsipi_xfer *));
d111 1
a111 1
int	dpt_scsi_cmd __P((struct scsi_xfer *));
d113 10
a122 10
int	dpt_wait __P((struct dpt_softc *, u_int8_t, u_int8_t, int));
int	dpt_poll __P((struct dpt_softc *, struct dpt_ccb *));
int	dpt_cmd __P((struct dpt_softc *, struct eata_cp *, u_int32_t, int, int));
void	dpt_hba_inquire __P((struct dpt_softc *, struct eata_inquiry_data **));
void	dpt_reset_ccb __P((struct dpt_softc *, struct dpt_ccb *));
void	dpt_free_ccb __P((struct dpt_softc *, struct dpt_ccb *));
void	dpt_done_ccb __P((struct dpt_softc *, struct dpt_ccb *));
int	dpt_init_ccb __P((struct dpt_softc *, struct dpt_ccb *));
int	dpt_create_ccbs __P((struct dpt_softc *, struct dpt_ccb *, int));
struct dpt_ccb	*dpt_alloc_ccb __P((struct dpt_softc *, int));
d124 1
a124 1
void	dpt_dump_sp __P((struct eata_sp *));
@


1.1.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dptvar.h,v 1.1 1999/11/30 07:55:56 cmetz Exp $	*/
d101 6
a106 6
int	dpt_intr(void *);
int	dpt_readcfg(struct dpt_softc *);
void	dpt_init(struct dpt_softc *, const char *);
void	dpt_shutdown(void *);
void	dpt_timeout(void *);
void	dpt_minphys(struct buf *);
d108 1
a108 1
int	dpt_scsi_cmd(struct scsipi_xfer *);
d111 1
a111 1
int	dpt_scsi_cmd(struct scsi_xfer *);
d113 10
a122 10
int	dpt_wait(struct dpt_softc *, u_int8_t, u_int8_t, int);
int	dpt_poll(struct dpt_softc *, struct dpt_ccb *);
int	dpt_cmd(struct dpt_softc *, struct eata_cp *, u_int32_t, int, int);
void	dpt_hba_inquire(struct dpt_softc *, struct eata_inquiry_data **);
void	dpt_reset_ccb(struct dpt_softc *, struct dpt_ccb *);
void	dpt_free_ccb(struct dpt_softc *, struct dpt_ccb *);
void	dpt_done_ccb(struct dpt_softc *, struct dpt_ccb *);
int	dpt_init_ccb(struct dpt_softc *, struct dpt_ccb *);
int	dpt_create_ccbs(struct dpt_softc *, struct dpt_ccb *, int);
struct dpt_ccb	*dpt_alloc_ccb(struct dpt_softc *, int);
d124 1
a124 1
void	dpt_dump_sp(struct eata_sp *);
@


1.1.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 6
a106 6
int	dpt_intr(void *);
int	dpt_readcfg(struct dpt_softc *);
void	dpt_init(struct dpt_softc *, const char *);
void	dpt_shutdown(void *);
void	dpt_timeout(void *);
void	dpt_minphys(struct buf *);
d108 1
a108 1
int	dpt_scsi_cmd(struct scsipi_xfer *);
d111 1
a111 1
int	dpt_scsi_cmd(struct scsi_xfer *);
d113 10
a122 10
int	dpt_wait(struct dpt_softc *, u_int8_t, u_int8_t, int);
int	dpt_poll(struct dpt_softc *, struct dpt_ccb *);
int	dpt_cmd(struct dpt_softc *, struct eata_cp *, u_int32_t, int, int);
void	dpt_hba_inquire(struct dpt_softc *, struct eata_inquiry_data **);
void	dpt_reset_ccb(struct dpt_softc *, struct dpt_ccb *);
void	dpt_free_ccb(struct dpt_softc *, struct dpt_ccb *);
void	dpt_done_ccb(struct dpt_softc *, struct dpt_ccb *);
int	dpt_init_ccb(struct dpt_softc *, struct dpt_ccb *);
int	dpt_create_ccbs(struct dpt_softc *, struct dpt_ccb *, int);
struct dpt_ccb	*dpt_alloc_ccb(struct dpt_softc *, int);
d124 1
a124 1
void	dpt_dump_sp(struct eata_sp *);
@


