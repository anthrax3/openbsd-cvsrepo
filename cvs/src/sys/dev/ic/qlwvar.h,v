head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.12
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10;
locks; strict;
comment	@ * @;


1.10
date	2014.03.15.13.08.52;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2014.03.13.10.31.53;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2014.03.08.18.30.54;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2014.03.08.16.56.29;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.08.15.13.12;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2014.03.07.22.39.07;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2014.03.07.22.17.03;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2014.03.07.12.45.49;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2014.03.07.00.20.55;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2014.03.05.23.10.41;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.10
log
@More ISP1000 (SBus) bits.
@
text
@/*	$OpenBSD: qlwvar.h,v 1.9 2014/03/13 10:31:53 kettenis Exp $ */

/*
 * Copyright (c) 2013, 2014 Jonathan Matthew <jmatthew@@openbsd.org>
 * Copyright (c) 2014 Mark Kettenis <kettenis@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/task.h>

#define QLW_MAX_TARGETS			16
#define QLW_MAX_LUNS			8

/* maximum number of segments allowed for in a single io */
#define QLW_MAX_SEGS			16

struct qlw_softc;

enum qlw_isp_gen {
	QLW_GEN_ISP1000 = 1,
	QLW_GEN_ISP1040,
	QLW_GEN_ISP1080,
	QLW_GEN_ISP12160,
};

enum qlw_isp_type {
	QLW_ISP1000 = 1,
	QLW_ISP1020,
	QLW_ISP1020A,
	QLW_ISP1040,
	QLW_ISP1040A,
	QLW_ISP1040B,
	QLW_ISP1040C,
	QLW_ISP1240,
	QLW_ISP1080,
	QLW_ISP1280,
	QLW_ISP10160,
	QLW_ISP12160,
};

/* request/response queue stuff */
#define QLW_QUEUE_ENTRY_SIZE		64

struct qlw_ccb {
	struct qlw_softc 	*ccb_sc;
	int			ccb_id;
	struct scsi_xfer	*ccb_xs;

	bus_dmamap_t		ccb_dmamap;

	SIMPLEQ_ENTRY(qlw_ccb)	ccb_link;
};

SIMPLEQ_HEAD(qlw_ccb_list, qlw_ccb);

struct qlw_dmamem {
	bus_dmamap_t		qdm_map;
	bus_dma_segment_t	qdm_seg;
	size_t			qdm_size;
	caddr_t			qdm_kva;
};
#define QLW_DMA_MAP(_qdm)	((_qdm)->qdm_map)
#define QLW_DMA_LEN(_qdm)	((_qdm)->qdm_size)
#define QLW_DMA_DVA(_qdm)	((u_int64_t)(_qdm)->qdm_map->dm_segs[0].ds_addr)
#define QLW_DMA_KVA(_qdm)	((void *)(_qdm)->qdm_kva)

struct qlw_target {
	u_int16_t		qt_params;
	u_int8_t		qt_exec_throttle;
	u_int8_t		qt_sync_period;
	u_int8_t		qt_sync_offset;
};

struct qlw_softc {
	struct device		sc_dev;

	int			sc_flags;
#define QLW_FLAG_INITIATOR	0x0001

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	bus_dma_tag_t		sc_dmat;

	struct scsi_link	sc_link[2];
	struct scsibus_softc	*sc_scsibus[2];
	int			sc_running;

	enum qlw_isp_type	sc_isp_type;
	enum qlw_isp_gen	sc_isp_gen;
	const u_int16_t		*sc_firmware;
	int			sc_numbusses;
	int			sc_clock;

	int			sc_host_cmd_ctrl;
	int			sc_mbox_base;
	u_int16_t		sc_mbox[8];
	int			sc_mbox_pending;

	int			sc_maxrequests;
	struct qlw_dmamem	*sc_requests;
	int			sc_maxresponses;
	struct qlw_dmamem	*sc_responses;
	int			sc_maxccbs;
	struct qlw_ccb		*sc_ccbs;
	struct qlw_ccb_list	sc_ccb_free;
	struct mutex		sc_ccb_mtx;
	struct mutex		sc_queue_mtx;
	struct scsi_iopool	sc_iopool;
	u_int16_t		sc_next_req_id;
	u_int16_t		sc_last_resp_id;
	int			sc_marker_required[2];
	u_int			sc_update_required[2];
	struct task		sc_update_task;

	struct qlw_nvram	sc_nvram;
	int			sc_nvram_size;
	int			sc_nvram_minversion;

	u_int16_t		sc_isp_config;
	u_int16_t		sc_fw_features;

	u_int8_t		sc_initiator[2];
	u_int8_t		sc_retry_count[2];
	u_int8_t		sc_retry_delay[2];
	u_int8_t		sc_reset_delay[2];
	u_int8_t		sc_tag_age_limit[2];
	u_int16_t		sc_selection_timeout[2];
	u_int16_t		sc_max_queue_depth[2];
	u_int8_t		sc_async_data_setup[2];
	u_int8_t		sc_req_ack_active_neg[2];
	u_int8_t		sc_data_line_active_neg[2];
	struct qlw_target	sc_target[2][QLW_MAX_TARGETS];
};
#define DEVNAME(_sc) ((_sc)->sc_dev.dv_xname)

int	qlw_attach(struct qlw_softc *);
int	qlw_detach(struct qlw_softc *, int);

int	qlw_intr(void *);
@


1.9
log
@Decouple the sizes of the request and response queues, and reduce the size of
the response queue to half the size of the request queue (with a minimum of
64 entries).  This matches what isp(4) is doing and seems to be necessary for
the onboard 1040B found on the Origin 200 (sgi).
@
text
@d1 1
a1 1
/*	$OpenBSD: qlwvar.h,v 1.8 2014/03/08 18:30:54 kettenis Exp $ */
d31 2
a32 1
	QLW_GEN_ISP1040 = 1,
d38 2
a39 1
	QLW_ISP1020 = 1,
d106 2
@


1.8
log
@Attempt to recover if wide and/or synchronous transfers fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: qlwvar.h,v 1.7 2014/03/08 16:56:29 kettenis Exp $ */
d107 1
a107 1
	int			sc_maxcmds;
d109 1
@


1.7
log
@A bit of spring cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: qlwvar.h,v 1.6 2014/03/08 15:13:12 kettenis Exp $ */
d20 1
d119 2
d139 1
a139 1
	struct qlw_target	sc_target[2][QLW_MAX_TARGETS];		
@


1.6
log
@Enable DMA bursting.  Not sure it actually makes things faster, but both
isp(4) and the linux qla1280 driver seem to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: qlwvar.h,v 1.5 2014/03/07 22:39:07 kettenis Exp $ */
d124 1
d130 1
@


1.5
log
@Make sure a SCSI initiator ID provided by Open Firmware overrides the value
read from nvram, just like we did for isp(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: qlwvar.h,v 1.4 2014/03/07 22:17:03 kettenis Exp $ */
d36 6
a41 1
	QLW_ISP1040 = 1,
d122 2
@


1.4
log
@Reduce the number of ccbs by a factor three since we need up to three request
entries per SCSI command.
@
text
@d1 1
a1 1
/*	$OpenBSD: qlwvar.h,v 1.3 2014/03/07 12:45:49 kettenis Exp $ */
d79 3
@


1.3
log
@Provide the appropriate default values for the SCSI initiaror ID on sgi and
sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: qlwvar.h,v 1.2 2014/03/07 00:20:55 kettenis Exp $ */
d101 1
@


1.2
log
@Duplicate enum values are a bad idea.
@
text
@d1 1
a1 1
/*	$OpenBSD: qlwvar.h,v 1.1 2014/03/05 23:10:41 kettenis Exp $ */
d114 1
@


1.1
log
@Introduce qlw(4), a new driver for QLogic ISP SCSI HBAs.  For now only
supports the PCI variants; SBUs support will follow.  Works reasonably
well now.  Others are encouraged to test it.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d40 1
a40 1
	QLW_ISP10160 = 2,
@

