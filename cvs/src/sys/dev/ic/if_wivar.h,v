head	1.30;
access;
symbols
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.28
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.26
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.20
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.22
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.14
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.18
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.16
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.12
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.10
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.6
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.16
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.12
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.10
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.8
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.6
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.20
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.30
date	2010.08.30.20.42.27;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.27.09.48.02;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.31.05.37.13;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.31.23.08.58;	author pascoe;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.15.19.44.15;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.18.16.16.10;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.02.21.59.29;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.26.15.34.15;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.06.20.53.57;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.27.16.20.48;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.10.20.27.46;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.09.11.00.27;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.22.22.10.38;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.22.16.41.43;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.21.06.48.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.15.18.49.04;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.02.16.11.41;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.26.19.20.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.11.00.08.25;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.07.23.23.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.06.23.48.38;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.06.20.31.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.28.18.21.06;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.19.01.24.58;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.20.17.48.25;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.09.20.17.21;	author millert;	state Exp;
branches
	1.3.2.1
	1.3.6.1;
next	1.2;

1.2
date	2001.06.07.05.07.27;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.15.02.40.36;	author millert;	state Exp;
branches;
next	;

1.3.2.1
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2004.06.05.23.12.42;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	;


desc
@@


1.30
log
@ioctl versus resume-workq exclusion; cloned from iwn
@
text
@/*	$OpenBSD: if_wivar.h,v 1.29 2009/08/10 20:29:54 deraadt Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	From: if_wireg.h,v 1.8.2.2 2001/08/25 00:48:25 nsayer Exp $
 */

#include <dev/ic/if_wi_hostap.h>

struct wi_softc	{
	struct device		sc_dev;
	struct ieee80211com	sc_ic;
	struct ifmedia		sc_media;
	bus_space_handle_t	wi_bhandle;
	bus_space_tag_t		wi_btag;
	bus_space_handle_t	wi_lhandle;
	bus_space_tag_t		wi_ltag;
	bus_size_t		wi_cor_offset;
	int			wi_tx_data_id;
	int			wi_tx_mgmt_id;
	int			wi_flags;
	int			wi_if_flags;
	int			wi_cmd_count;
	u_int16_t		wi_procframe;
	u_int16_t		wi_ptype;
	u_int16_t		wi_portnum;
	u_int16_t		wi_max_data_len;
	u_int16_t		wi_rts_thresh;
	u_int16_t		wi_ap_density;
	u_int16_t		wi_tx_rate;
	u_int16_t		wi_create_ibss;
	u_int16_t		wi_channel;
	u_int16_t		wi_pm_enabled;
	u_int16_t		wi_mor_enabled;
	u_int16_t		wi_max_sleep;
	u_int16_t		wi_authtype;
	u_int16_t		wi_roaming;
	u_int16_t		wi_supprates;
	u_int16_t		wi_diversity;

	u_int8_t		wi_rxbuf[1596];
	u_int8_t		wi_txbuf[1596];
	u_int8_t		wi_scanbuf[1596];
	int			wi_scan_lock;
	struct timeout		wi_scan_timeout;

	u_int8_t		wi_scanbuf_len;

	struct ieee80211_nwid	wi_node_name;
	struct ieee80211_nwid	wi_net_name;
	struct ieee80211_nwid	wi_ibss_name;

	int			wi_use_wep;
	int			wi_enh_security;
	int			wi_crypto_algorithm;
	int			wi_tx_key;
	struct wi_ltv_keys	wi_keys;
	struct wi_counters	wi_stats;
	void			*sc_ih;
	struct timeout		sc_timo;
	int			sc_firmware_type;
	int			sc_sta_firmware_ver;
	int			sc_pci;
	struct wihap_info	wi_hostap_info;
	u_int32_t		wi_icv;
	int			wi_icv_flag;
	int			wi_ibss_port;
	int16_t			wi_txpower;

	struct {
		u_int16_t		wi_sleep;
		u_int16_t		wi_delaysupp;
		u_int16_t		wi_txsupp;
		u_int16_t		wi_monitor;
		u_int16_t		wi_ledtest;
		u_int16_t		wi_ledtest_param0;
		u_int16_t		wi_ledtest_param1;
		u_int16_t		wi_conttx;
		u_int16_t		wi_conttx_param0;
		u_int16_t		wi_contrx;
		u_int16_t		wi_sigstate;
		u_int16_t		wi_sigstate_param0;
		u_int16_t		wi_confbits;
		u_int16_t		wi_confbits_param0;
	} wi_debug;
	struct wi_usb_softc		*wi_usb_cdata;

	struct wi_funcs			*sc_funcs;
};
#define wi_cmd		sc->sc_funcs->f_cmd
#define wi_read_record	sc->sc_funcs->f_read_record
#define wi_write_record	sc->sc_funcs->f_write_record
#define wi_alloc_nicmem	sc->sc_funcs->f_alloc_nicmem
#define wi_read_data	sc->sc_funcs->f_read_data
#define wi_write_data	sc->sc_funcs->f_write_data
#define wi_get_fid	sc->sc_funcs->f_get_fid
#define wi_init		sc->sc_funcs->f_init

/* Values for wi_flags. */
#define WI_FLAGS_ATTACHED		0x0001
#define WI_FLAGS_INITIALIZED		0x0002
#define WI_FLAGS_HAS_WEP		0x0004
#define WI_FLAGS_HAS_IBSS		0x0008
#define WI_FLAGS_HAS_CREATE_IBSS	0x0010
#define WI_FLAGS_HAS_MOR		0x0020
#define WI_FLAGS_HAS_ROAMING		0x0040
#define WI_FLAGS_HAS_DIVERSITY		0x0080
#define WI_FLAGS_HAS_HOSTAP		0x0100
#define WI_FLAGS_BUS_PCMCIA		0x0200
#define WI_FLAGS_BUS_USB		0x0400
#define WI_FLAGS_HAS_ENH_SECURITY	0x0800
#define WI_FLAGS_TXPOWER		0x1000
#define WI_FLAGS_BUSY			0x2000

#define WI_PRT_FMT "%s"
#define WI_PRT_ARG(sc)	(sc)->sc_dev.dv_xname

struct wi_funcs {
	int (*f_cmd)(struct wi_softc *sc, int cmd, int val0, int val1,
	    int val2);
	int (*f_read_record)(struct wi_softc *sc, struct wi_ltv_gen *ltv);
	int (*f_write_record)(struct wi_softc *sc,
	    struct wi_ltv_gen *ltv);
	int (*f_alloc_nicmem)(struct wi_softc *sc, int len, int *id);
	int (*f_read_data)(struct wi_softc *sc, int id, int off,
	    caddr_t buf, int len);
	int (*f_write_data)(struct wi_softc *sc, int id, int off,
	    caddr_t buf, int len);
	int (*f_get_fid)(struct wi_softc *sc, int fid);
	void (*f_init)(struct wi_softc *sc);

	void (*f_start)(struct ifnet *ifp);
	int (*f_ioctl)(struct ifnet *, u_long, caddr_t);
	void (*f_watchdog)(struct ifnet *ifp);
	void (*f_inquire)(void *xsc);
};

extern struct wi_funcs wi_func_io;

int	wi_attach(struct wi_softc *, struct wi_funcs *);
void	wi_detach(struct wi_softc *);
int	wi_intr(void *);
void	wi_stop(struct wi_softc *);
void	wi_cor_reset(struct wi_softc *);
int	wi_mgmt_xmit(struct wi_softc *, caddr_t, int);

void wi_update_stats(struct wi_softc *sc);
void wi_rxeof(struct wi_softc *sc);
void wi_txeof(struct wi_softc *sc, int status);
@


1.29
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.28 2006/06/27 09:48:02 reyk Exp $	*/
d142 1
@


1.28
log
@add some more net80211 compatibility glue:
- support scanning and node listing ("ifconfig -M"). this will replace
wicontrol -L in station mode and wicontrol -l in hostap mode.
- allow to print the BSSID

tested by quite a few people
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.27 2005/10/31 05:37:13 jsg Exp $	*/
a114 1
	void				*sc_sdhook;
@


1.27
log
@Move from arpcom to ieee80211com in wi softc.  This will be
required for net80211 support.
Updated version of a diff from dlg@@
similiar diff ok fgsch@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.26 2005/07/31 23:08:58 pascoe Exp $	*/
d73 2
@


1.26
log
@Move large receive/decryption buffer allocation from the stack into
wi_softc.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.25 2005/02/15 19:44:15 reyk Exp $	*/
a39 1
#ifndef __FreeBSD__
d41 1
a41 2
#endif	/* !__FreeBSD__ */
	struct arpcom		sc_arpcom;
@


1.25
log
@add the manual tx power option. this is supported by some prism2/2.5/3
cards in hostap mode but it depends on the firmware version. support
for other wireless chipsets will be added in the future using the
net80211-framework.

ok robert@@ bob@@ danh@@, tested by some others
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.24 2004/03/18 16:16:10 millert Exp $	*/
d72 1
@


1.24
log
@Starting with Prism firmware version 1.6.3, HostAP supports an
enhanced security mode whereby the SSID can be hidden from snoopers.
Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.23 2004/03/02 21:59:29 millert Exp $	*/
d96 1
d141 1
@


1.23
log
@Fix timing issues with newer Prism firmware and retry card reset up
to three times (only once for Symbol though).  This fixes intermittent
problems on Prism-based cards with newer firmware.  Tested with a
wide variety of cards and firmware revisions.  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.22 2003/10/26 15:34:15 drahn Exp $	*/
d82 1
d139 1
@


1.22
log
@Driver for PRISM 2.5/3 based (wifi) USB adapters. This is a work in progress,
it does not yet handle bulk data copies or hostap mode. Only one model
currently supported, however driver may support other PRISM based adapters.
ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.21 2003/09/06 20:53:57 drahn Exp $	*/
d54 1
@


1.21
log
@Add wi_detach, use it in pcmcia so that the shutdownhook is properly removed.
ok miod@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.20 2002/10/27 16:20:48 millert Exp $	*/
d112 3
d116 8
d136 1
d141 23
a163 1
int	wi_attach(struct wi_softc *);
a165 1
void	wi_init(struct wi_softc *);
d169 4
@


1.20
log
@Add an option to use software WEP now that we have a software decrypt
function.  Can be useful for cards that only support 40-bit WEP or
where the card firmware lacks weak IVs avoidance.  Prism/Symbol only.
In the future this will be expanded to support proposed WEP replacements.
Based on code from Jamison Adcock.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.19 2002/10/10 20:27:46 millert Exp $	*/
d111 1
d130 1
@


1.19
log
@Make wi_get_id() table driven, similar to NetBSD and FreeBSD but
make the table itself a #define so we can reuse it in wicontrol.
Also add a bunch of chip IDs from NetBSD/FreeBSD.
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.18 2002/07/09 11:00:27 fgsch Exp $	*/
d81 1
@


1.18
log
@move common declarations to if_wivar.h; mickey@@ and millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.17 2002/06/22 22:10:38 fgsch Exp $	*/
a122 5

/* Firmware types */
#define WI_LUCENT	0
#define WI_INTERSIL	1
#define WI_SYMBOL	2
@


1.17
log
@Add new flag, WI_FLAGS_BUS_PCMCIA and mark pcmcia attachment as such.
Replace ugly kludge with a macro that tests on sparc if it's pcmcia
and tries to deal with it correctly (card mapped as be).
This makes possible to have wi at pcmcia and pci on sparc64; from theo
and myself.  Tested with the PLX adapter and the SBus pcmcia bridge.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.16 2002/06/22 16:41:43 millert Exp $	*/
d132 6
a137 1
int wi_mgmt_xmit(struct wi_softc *, caddr_t, int);
@


1.16
log
@Fix typo in WI_FLAGS_HAS_ROAMING, noticed by fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.15 2002/06/21 06:48:18 deraadt Exp $	*/
d122 1
@


1.15
log
@put the objects in a better order, so that they align correctly.
whoever made struct ieee80211_nwid an odd-sized structure and created
this particular little corner of alignment hell surely deserves a boot
to the head.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.14 2002/06/15 18:49:04 millert Exp $	*/
d113 9
a121 9
#define WI_FLAGS_ATTACHED		0x01
#define WI_FLAGS_INITIALIZED		0x02
#define WI_FLAGS_HAS_WEP		0x04
#define WI_FLAGS_HAS_IBSS		0x08
#define WI_FLAGS_HAS_CREATE_IBSS	0x10
#define WI_FLAGS_HAS_MOR		0x20
#define WI_FLAGS_HAS_ROAMING		0x30
#define WI_FLAGS_HAS_DIVERSITY		0x40
#define WI_FLAGS_HAS_HOSTAP		0x80
@


1.14
log
@Don't advertise hostap as an allowed media type for firmware < 0.80
Hopefully this will confuse people with crufty firmware a little less
than the old behavior.  Supposedly it is possible to get hostap working
on prism firmware 0.7.6 but I'm not going to attempt that at this time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.13 2002/06/09 03:14:18 todd Exp $	*/
d71 5
a79 3
	u_int8_t		wi_txbuf[1596];
	u_int8_t		wi_scanbuf[1596];
	u_int8_t		wi_scanbuf_len;
@


1.13
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.12 2002/06/02 16:11:41 millert Exp $	*/
d119 1
@


1.12
log
@BSD air-tools 0.2 patches from dachb0den labs; h1kari@@dachb0den.com
The common.h include file has been incorporated into if_wi_ieee.h
similar to what is in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.11 2002/04/26 19:20:27 millert Exp $	*/
d43 1
a43 1
	struct arpcom		arpcom;
@


1.11
log
@We use wi_authtype, not wi_authmode to store the auth type (open system
or shared key).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.10 2002/04/11 00:08:25 millert Exp $	*/
d54 1
d76 2
d91 17
@


1.10
log
@o Set feature flags based on firmware type and version.
o Move the sc->has_wep flag into sc->wi_flags
o Only do the COR reset on Symbol cards just to play it safe.
o Remove unused sc->sc_enabled variable.
o Kill ibss_portmap array in favor of sc->wi_ibss_port, which is
stored in little endian.

mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.9 2002/04/07 23:23:49 millert Exp $	*/
a75 1
	int			wi_authmode;
@


1.9
log
@Don't reset COR in wi_reset(), break it out into its own function and
only call it from wi_attach() and wi_pcmcia_activate() (ie: just once).
It would be nicer to have the COR reset be part of the bus-specific
code but we need to know whether or not we have a Lucent card since
old Lucent firmware revs get messed up on a COR soft reset.

Even with the COR reset we still need to avoid initializing Symbol
cards more than once.  However, we *do* want to do a reset after
returning from suspend.  Therefore, rename wi_gone to wi_flags and
store both the attach and init status in it.  wi_reset() now checks
wi_flags to see if the card should be initialized in the Symbol case.

Info on initializing Symbol cards once from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.8 2002/04/06 23:48:38 millert Exp $	*/
a74 1
	int			wi_has_wep;
a81 1
	int			sc_enabled;
d88 1
d92 8
a99 2
#define WI_FLAGS_ATTACHED	0x01
#define WI_FLAGS_INITIALIZED	0x02
@


1.8
log
@Add support for setting antenna diversity on Symbol cards.
Also add some more Symbol-specific RID values I noticed in the
Linux orinoco driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.7 2002/04/06 20:31:56 millert Exp $	*/
d52 1
a52 1
	int			wi_gone;
d91 4
@


1.7
log
@Add support for Symbol cards and printing of the primary station
firmware version.  Adapted from NetBSD and the Linux orinoco driver.
The Symbol firmware requires that we do a COR soft reset before
initializing the card in wi_reset().  Also, setting WI_RID_ROAMING_MODE
caused the Symbol card to go into a strange (non-working) mode with
firmware 2.x.x.

There are some other Symbol additions/oddities that will need to be
addressed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.6 2002/03/28 18:21:06 mickey Exp $	*/
d68 1
@


1.6
log
@basic host-ap implementation, more work is needed; from Thomas Skibo <skibo@@pacbell.net>; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.5 2002/02/19 01:24:58 mickey Exp $	*/
d47 3
d83 2
a84 2
	int			sc_prism2;
	int			sc_prism2_ver;
d90 5
@


1.5
log
@add support for media and other generic 802.11 ioctls, elliminates need for wicontrol on the ramdisk floppy, pretty much; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.4 2001/12/20 17:48:25 mickey Exp $	*/
d34 1
a34 1
 *	From: if_wireg.h,v 1.5 1999/07/20 20:03:42 wpaul Exp $
d37 2
d64 1
d73 1
d79 1
d83 3
d90 2
@


1.4
log
@for mimi-pci cards registers are word in a dword, missed that in bringing over support from netbsd; partially successfully tested by ellidz@@eridu.uchicago.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.3 2001/06/09 20:17:21 millert Exp $	*/
d42 1
a42 1
	struct ifmedia		ifmedia;
d63 3
a65 3
	char			wi_node_name[32];
	char			wi_net_name[32];
	char			wi_ibss_name[32];
@


1.3
log
@Updates from NetBSD:
o Endian fixes
o Missing WI_RID_AUTH_CNTL and WI_RID_MICROWAVE_OVEN bits
o Move promisc mode setting to be before prism2 detect since
  some prism2 firmware revs need to have promisc to support WEP
  and it is useless to set promisc and then clear it again.
o Add missing clear of ifp->if_timer when IFF_OACTIVE is cleared
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.2 2001/06/07 05:07:27 mickey Exp $	*/
d77 1
@


1.3.2.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
	struct ifmedia		sc_media;
d63 3
a65 3
	struct ieee80211_nwid	wi_node_name;
	struct ieee80211_nwid	wi_net_name;
	struct ieee80211_nwid	wi_ibss_name;
a76 1
	int			sc_pci;
@


1.3.2.2
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a34 1
 *	From: if_wireg.h,v 1.8.2.2 2001/08/25 00:48:25 nsayer Exp $
a36 2
#include <dev/ic/if_wi_hostap.h>

d41 1
a41 1
	struct arpcom		sc_arpcom;
a44 3
	bus_space_handle_t	wi_lhandle;
	bus_space_tag_t		wi_ltag;
	bus_size_t		wi_cor_offset;
d47 1
a47 1
	int			wi_flags;
a48 1
	u_int16_t		wi_procframe;
a61 7
	u_int16_t		wi_supprates;
	u_int16_t		wi_diversity;

	u_int8_t		wi_txbuf[1596];
	u_int8_t		wi_scanbuf[1596];

	u_int8_t		wi_scanbuf_len;
d67 2
a69 1
	int			wi_crypto_algorithm;
d75 2
a76 2
	int			sc_firmware_type;
	int			sc_sta_firmware_ver;
a77 21
	struct wihap_info	wi_hostap_info;
	u_int32_t		wi_icv;
	int			wi_icv_flag;
	int			wi_ibss_port;

	struct {
		u_int16_t		wi_sleep;
		u_int16_t		wi_delaysupp;
		u_int16_t		wi_txsupp;
		u_int16_t		wi_monitor;
		u_int16_t		wi_ledtest;
		u_int16_t		wi_ledtest_param0;
		u_int16_t		wi_ledtest_param1;
		u_int16_t		wi_conttx;
		u_int16_t		wi_conttx_param0;
		u_int16_t		wi_contrx;
		u_int16_t		wi_sigstate;
		u_int16_t		wi_sigstate_param0;
		u_int16_t		wi_confbits;
		u_int16_t		wi_confbits_param0;
	} wi_debug;
a79 12
/* Values for wi_flags. */
#define WI_FLAGS_ATTACHED		0x0001
#define WI_FLAGS_INITIALIZED		0x0002
#define WI_FLAGS_HAS_WEP		0x0004
#define WI_FLAGS_HAS_IBSS		0x0008
#define WI_FLAGS_HAS_CREATE_IBSS	0x0010
#define WI_FLAGS_HAS_MOR		0x0020
#define WI_FLAGS_HAS_ROAMING		0x0040
#define WI_FLAGS_HAS_DIVERSITY		0x0080
#define WI_FLAGS_HAS_HOSTAP		0x0100
#define WI_FLAGS_BUS_PCMCIA		0x0200

a81 7

int	wi_attach(struct wi_softc *);
int	wi_intr(void *);
void	wi_init(struct wi_softc *);
void	wi_stop(struct wi_softc *);
void	wi_cor_reset(struct wi_softc *);
int	wi_mgmt_xmit(struct wi_softc *, caddr_t, int);
@


1.3.2.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a110 4
	void				*sc_sdhook;
	struct wi_usb_softc		*wi_usb_cdata;

	struct wi_funcs			*sc_funcs;
a111 8
#define wi_cmd		sc->sc_funcs->f_cmd
#define wi_read_record	sc->sc_funcs->f_read_record
#define wi_write_record	sc->sc_funcs->f_write_record
#define wi_alloc_nicmem	sc->sc_funcs->f_alloc_nicmem
#define wi_read_data	sc->sc_funcs->f_read_data
#define wi_write_data	sc->sc_funcs->f_write_data
#define wi_get_fid	sc->sc_funcs->f_get_fid
#define wi_init		sc->sc_funcs->f_init
a123 1
#define WI_FLAGS_BUS_USB		0x0400
d128 1
a128 24
struct wi_funcs {
	int (*f_cmd)(struct wi_softc *sc, int cmd, int val0, int val1,
	    int val2);
	int (*f_read_record)(struct wi_softc *sc, struct wi_ltv_gen *ltv);
	int (*f_write_record)(struct wi_softc *sc,
	    struct wi_ltv_gen *ltv);
	int (*f_alloc_nicmem)(struct wi_softc *sc, int len, int *id);
	int (*f_read_data)(struct wi_softc *sc, int id, int off,
	    caddr_t buf, int len);
	int (*f_write_data)(struct wi_softc *sc, int id, int off,
	    caddr_t buf, int len);
	int (*f_get_fid)(struct wi_softc *sc, int fid);
	void (*f_init)(struct wi_softc *sc);

	void (*f_start)(struct ifnet *ifp);
	int (*f_ioctl)(struct ifnet *, u_long, caddr_t);
	void (*f_watchdog)(struct ifnet *ifp);
	void (*f_inquire)(void *xsc);
};

extern struct wi_funcs wi_func_io;

int	wi_attach(struct wi_softc *, struct wi_funcs *);
void	wi_detach(struct wi_softc *);
d130 1
a133 4

void wi_update_stats(struct wi_softc *sc);
void wi_rxeof(struct wi_softc *sc);
void wi_txeof(struct wi_softc *sc, int status);
@


1.3.2.4
log
@Merge with the trunk
@
text
@a53 1
	int			wi_cmd_count;
a80 1
	int			wi_enh_security;
a136 1
#define WI_FLAGS_HAS_ENH_SECURITY	0x0800
@


1.3.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.4 2001/12/20 17:48:25 mickey Exp $	*/
a76 1
	int			sc_pci;
@


1.3.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.3.6.1 2002/01/31 22:55:31 niklas Exp $	*/
d34 1
a34 1
 *	From: if_wireg.h,v 1.8.2.2 2001/08/25 00:48:25 nsayer Exp $
a36 2
#include <dev/ic/if_wi_hostap.h>

d41 2
a42 2
	struct arpcom		sc_arpcom;
	struct ifmedia		sc_media;
a44 3
	bus_space_handle_t	wi_lhandle;
	bus_space_tag_t		wi_ltag;
	bus_size_t		wi_cor_offset;
d47 1
a47 1
	int			wi_flags;
a48 1
	u_int16_t		wi_procframe;
a61 2
	u_int16_t		wi_supprates;
	u_int16_t		wi_diversity;
d63 3
a65 3
	struct ieee80211_nwid	wi_node_name;
	struct ieee80211_nwid	wi_net_name;
	struct ieee80211_nwid	wi_ibss_name;
d68 1
a68 2
	u_int8_t		wi_scanbuf[1596];
	u_int8_t		wi_scanbuf_len;
d75 2
a76 2
	int			sc_firmware_type;
	int			sc_sta_firmware_ver;
a77 21
	struct wihap_info	wi_hostap_info;
	u_int32_t		wi_icv;
	int			wi_icv_flag;
	int			wi_ibss_port;

	struct {
		u_int16_t		wi_sleep;
		u_int16_t		wi_delaysupp;
		u_int16_t		wi_txsupp;
		u_int16_t		wi_monitor;
		u_int16_t		wi_ledtest;
		u_int16_t		wi_ledtest_param0;
		u_int16_t		wi_ledtest_param1;
		u_int16_t		wi_conttx;
		u_int16_t		wi_conttx_param0;
		u_int16_t		wi_contrx;
		u_int16_t		wi_sigstate;
		u_int16_t		wi_sigstate_param0;
		u_int16_t		wi_confbits;
		u_int16_t		wi_confbits_param0;
	} wi_debug;
a79 15
/* Values for wi_flags. */
#define WI_FLAGS_ATTACHED		0x01
#define WI_FLAGS_INITIALIZED		0x02
#define WI_FLAGS_HAS_WEP		0x04
#define WI_FLAGS_HAS_IBSS		0x08
#define WI_FLAGS_HAS_CREATE_IBSS	0x10
#define WI_FLAGS_HAS_MOR		0x20
#define WI_FLAGS_HAS_ROAMING		0x30
#define WI_FLAGS_HAS_DIVERSITY		0x40

/* Firmware types */
#define WI_LUCENT	0
#define WI_INTERSIL	1
#define WI_SYMBOL	2

a81 2

int wi_mgmt_xmit(struct wi_softc *, caddr_t, int);
@


1.3.6.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.3.6.2 2002/06/11 03:42:18 art Exp $	*/
a70 5
	u_int8_t		wi_txbuf[1596];
	u_int8_t		wi_scanbuf[1596];

	u_int8_t		wi_scanbuf_len;

d75 3
a78 1
	int			wi_crypto_algorithm;
d111 13
a123 10
#define WI_FLAGS_ATTACHED		0x0001
#define WI_FLAGS_INITIALIZED		0x0002
#define WI_FLAGS_HAS_WEP		0x0004
#define WI_FLAGS_HAS_IBSS		0x0008
#define WI_FLAGS_HAS_CREATE_IBSS	0x0010
#define WI_FLAGS_HAS_MOR		0x0020
#define WI_FLAGS_HAS_ROAMING		0x0040
#define WI_FLAGS_HAS_DIVERSITY		0x0080
#define WI_FLAGS_HAS_HOSTAP		0x0100
#define WI_FLAGS_BUS_PCMCIA		0x0200
d128 1
a128 6
int	wi_attach(struct wi_softc *);
int	wi_intr(void *);
void	wi_init(struct wi_softc *);
void	wi_stop(struct wi_softc *);
void	wi_cor_reset(struct wi_softc *);
int	wi_mgmt_xmit(struct wi_softc *, caddr_t, int);
@


1.2
log
@no, definately *wi.* does not work here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wivar.h,v 1.1 2001/05/15 02:40:36 millert Exp $	*/
d58 1
@


1.1
log
@Split wi(4) into bus-dependent and bus-independent bits similar to
an(4) -- no real code changes at this point.
Rename if_wavelan_ieee.h to if_wi_ieee.h while I'm at it and
create an if_wivar.h similar to NetBSD.
PCI adaptors exist that are not true PCMCIA controllers so
wi(4) @@ PCI is possible (though the code is not working yet ;-).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 3
d65 1
d75 1
@

