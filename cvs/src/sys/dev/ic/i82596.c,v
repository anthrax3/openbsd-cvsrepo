head	1.53;
access;
symbols
	OPENBSD_6_2:1.53.0.6
	OPENBSD_6_2_BASE:1.53
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.52.0.4
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.33.0.16
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.14
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.10
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.12
	OPENBSD_5_0:1.33.0.8
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.26.0.6
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.6
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.14
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.53
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.52;
commitid	VyLWTsbepAOk7VQM;

1.52
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.51;
commitid	QHiEhS9DHyE6oiIr;

1.51
date	2016.03.14.23.08.05;	author krw;	state Exp;
branches;
next	1.50;
commitid	kCz5QgxnxRMKOzNf;

1.50
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.49;
commitid	J9apD0jq2AjFmqZc;

1.49
date	2015.11.25.11.12.53;	author mpi;	state Exp;
branches;
next	1.48;
commitid	rr3Wi6PELxUfYlN5;

1.48
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.47;
commitid	B0kwmVGiD5DVx4kv;

1.47
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.46;
commitid	5gdEnqVoJuTuwdTu;

1.46
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.45;
commitid	5DvsamK0GblTp8ww;

1.45
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.44;
commitid	p0v5tuE1Ch6fY0Nj;

1.44
date	2015.09.18.09.54.08;	author miod;	state Exp;
branches;
next	1.43;
commitid	LqjITe5VmspY4HjZ;

1.43
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.42;
commitid	MVWrtktB46JRxFWT;

1.42
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.41;
commitid	hN5bFCE56DrAjl99;

1.41
date	2015.05.01.16.37.32;	author mpi;	state Exp;
branches;
next	1.40;
commitid	4569D426AtOcIA2c;

1.40
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.39;
commitid	yM2VFFhpDTeFQlve;

1.39
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.38;
commitid	TGHgrLxu6sxZoiFt;

1.38
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.37;
commitid	I19imNlAX05zJOED;

1.37
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	EF98ch02VpFassUi;

1.36
date	2013.11.27.06.48.50;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2013.08.07.01.06.29;	author bluhm;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.31.14.31.11;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.03.00.19.55;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.18.00.46.41;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.10.06.12.59;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.09.11.48.14;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.09.03.11.47;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.27.20.03.35;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.07.08.25.23;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.19.01.25.21;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.11.19.35.51;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.01.19.56.13;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.30.20.21.41;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.13.14.21.49;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.09.23.43.11;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.23.06.11.50;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.31.02.32.25;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.29.23.41.24;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.08.08.49.42;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.06.27.06.34.42;	author kjc;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.23.00.16.49;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.20.19.39.37;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.12.22.56.03;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.11.26.17.45.57;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.08.15.23.49.30;	author mickey;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.14.22.23.49;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.07.04.10.40.55;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2004.06.05.23.12.42;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.53
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: i82596.c,v 1.52 2016/04/13 10:49:26 mpi Exp $	*/
/*	$NetBSD: i82586.c,v 1.18 1998/08/15 04:42:42 mycroft Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg and Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1997 Paul Kranenburg.
 * Copyright (c) 1992, 1993, University of Vermont and State
 *  Agricultural College.
 * Copyright (c) 1992, 1993, Garrett A. Wollman.
 *
 * Portions:
 * Copyright (c) 1994, 1995, Rafal K. Boni
 * Copyright (c) 1990, 1991, William F. Jolitz
 * Copyright (c) 1990, The Regents of the University of California
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of Vermont
 *	and State Agricultural College and Garrett A. Wollman, by William F.
 *	Jolitz, and by the University of California, Berkeley, Lawrence
 *	Berkeley Laboratory, and its contributors.
 * 4. Neither the names of the Universities nor the names of the authors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR AUTHORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Intel 82586/82596 Ethernet chip
 * Register, bit, and structure definitions.
 *
 * Original StarLAN driver written by Garrett Wollman with reference to the
 * Clarkson Packet Driver code for this chip written by Russ Nelson and others.
 *
 * BPF support code taken from hpdev/if_le.c, supplied with tcpdump.
 *
 * 3C507 support is loosely based on code donated to NetBSD by Rafal Boni.
 *
 * Majorly cleaned up and 3C507 code merged by Charles Hannum.
 *
 * Converted to SUN ie driver by Charles D. Cranor,
 *		October 1994, January 1995.
 * This sun version based on i386 version 1.30.
 */
/*
 * The i82596 is a very painful chip, found in sun3's, sun-4/100's
 * sun-4/200's, and VME based suns.  The byte order is all wrong for a
 * SUN, making life difficult.  Programming this chip is mostly the same,
 * but certain details differ from system to system.  This driver is
 * written so that different "ie" interfaces can be controled by the same
 * driver.
 */

/*
Mode of operation:

   We run the 82596 in a standard Ethernet mode.  We keep NFRAMES
   received frame descriptors around for the receiver to use, and
   NRXBUF associated receive buffer descriptors, both in a circular
   list.  Whenever a frame is received, we rotate both lists as
   necessary.  (The 596 treats both lists as a simple queue.)  We also
   keep a transmit command around so that packets can be sent off
   quickly.

   We configure the adapter in AL-LOC = 1 mode, which means that the
   Ethernet/802.3 MAC header is placed at the beginning of the receive
   buffer rather than being split off into various fields in the RFD.
   This also means that we must include this header in the transmit
   buffer as well.

   By convention, all transmit commands, and only transmit commands,
   shall have the I (IE_CMD_INTR) bit set in the command.  This way,
   when an interrupt arrives at i82596_intr(), it is immediately possible
   to tell what precisely caused it.  ANY OTHER command-sending
   routines should run at splnet(), and should post an acknowledgement
   to every interrupt they generate.

   To save the expense of shipping a command to 82596 every time we
   want to send a frame, we use a linked list of commands consisting
   of alternate XMIT and NOP commands. The links of these elements
   are manipulated (in i82596_xmit()) such that the NOP command loops back
   to itself whenever the following XMIT command is not yet ready to
   go. Whenever an XMIT is ready, the preceding NOP link is pointed
   at it, while its own link field points to the following NOP command.
   Thus, a single transmit command sets off an interlocked traversal
   of the xmit command chain, with the host processor in control of
   the synchronization.
*/

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>

#include <dev/ic/i82596reg.h>
#include <dev/ic/i82596var.h>

static	char *padbuf;

void	i82596_reset(struct ie_softc *, int);
void	i82596_watchdog(struct ifnet *);
int	i82596_init(struct ie_softc *);
int	i82596_ioctl(struct ifnet *, u_long, caddr_t);
void	i82596_start(struct ifnet *);

int	i82596_rint(struct ie_softc *, int);
int	i82596_tint(struct ie_softc *, int);

int   	i82596_mediachange(struct ifnet *);
void  	i82596_mediastatus(struct ifnet *, struct ifmediareq *);

int 	i82596_readframe(struct ie_softc *, int);
int	i82596_get_rbd_list(struct ie_softc *,
					     u_int16_t *, u_int16_t *, int *);
void	i82596_release_rbd_list(struct ie_softc *, u_int16_t, u_int16_t);
int	i82596_drop_frames(struct ie_softc *);
int	i82596_chk_rx_ring(struct ie_softc *);

void	i82596_start_transceiver(struct ie_softc *);
void	i82596_stop(struct ie_softc *);
void 	i82596_xmit(struct ie_softc *);

void 	i82596_setup_bufs(struct ie_softc *);
void	i82596_simple_command(struct ie_softc *, int, int);
int 	ie_cfg_setup(struct ie_softc *, int, int, int);
int	ie_ia_setup(struct ie_softc *, int);
void 	ie_run_tdr(struct ie_softc *, int);
int 	ie_mc_setup(struct ie_softc *, int);
void 	ie_mc_reset(struct ie_softc *);
int	i82596_cmd_wait(struct ie_softc *);

#ifdef I82596_DEBUG
void 	print_rbd(struct ie_softc *, int);
#endif

struct cfdriver ie_cd = {
	NULL, "ie", DV_IFNET
};

/*
 * generic i82596 probe routine
 */
int
i82596_probe(sc)
	struct ie_softc *sc;
{
	int i;

	sc->scp = sc->sc_msize - IE_SCP_SZ;
	sc->iscp = 0;
	sc->scb = 32;

	(sc->ie_bus_write16)(sc, IE_ISCP_BUSY(sc->iscp), 1);
	(sc->ie_bus_write16)(sc, IE_ISCP_SCB(sc->iscp), sc->scb);
	(sc->ie_bus_write24)(sc, IE_ISCP_BASE(sc->iscp), sc->sc_maddr);
	(sc->ie_bus_write24)(sc, IE_SCP_ISCP(sc->scp), sc->sc_maddr);
	(sc->ie_bus_write16)(sc, IE_SCP_BUS_USE(sc->scp), sc->sysbus);

	(sc->hwreset)(sc, IE_CARD_RESET);

	if ((sc->ie_bus_read16)(sc, IE_ISCP_BUSY(sc->iscp))) {
#ifdef I82596_DEBUG
		printf("%s: ISCP set failed\n", sc->sc_dev.dv_xname);
#endif
		return 0;
	}

	if (sc->port) {
		(sc->ie_bus_write24)(sc, sc->scp, 0);
		(sc->ie_bus_write24)(sc, IE_SCP_TEST(sc->scp), -1);
		(sc->port)(sc, IE_PORT_TEST);
		for (i = 9000; i-- &&
			     (sc->ie_bus_read16)(sc, IE_SCP_TEST(sc->scp));
		     DELAY(100))
			;
	}

	return 1;
}

/*
 * Front-ends call this function to attach to the MI driver.
 *
 * The front-end has responsibility for managing the ICP and ISCP
 * structures. Both of these are opaque to us.  Also, the front-end
 * chooses a location for the SCB which is expected to be addressable
 * (through `sc->scb') as an offset against the shared-memory bus handle.
 *
 * The following MD interface function must be setup by the front-end
 * before calling here:
 *
 *	hwreset			- board dependent reset
 *	hwinit			- board dependent initialization
 *	chan_attn		- channel attention
 *	intrhook		- board dependent interrupt processing
 *	memcopyin		- shared memory copy: board to KVA
 *	memcopyout		- shared memory copy: KVA to board
 *	ie_bus_read16		- read a sixteen-bit i82596 pointer
 *	ie_bus_write16		- write a sixteen-bit i82596 pointer
 *	ie_bus_write24		- write a twenty-four-bit i82596 pointer
 *
 */
void
i82596_attach(struct ie_softc *sc, const char *name, u_int8_t *etheraddr,
    uint64_t *media, int nmedia, uint64_t defmedia)
{
	int i;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Setup SCP+ISCP */
	(sc->ie_bus_write16)(sc, IE_ISCP_BUSY(sc->iscp), 1);
	(sc->ie_bus_write16)(sc, IE_ISCP_SCB(sc->iscp), sc->scb);
	(sc->ie_bus_write24)(sc, IE_ISCP_BASE(sc->iscp), sc->sc_maddr);
	(sc->ie_bus_write24)(sc, IE_SCP_ISCP(sc->scp), sc->sc_maddr +sc->iscp);
	(sc->ie_bus_write16)(sc, IE_SCP_BUS_USE(sc->scp), sc->sysbus);
	(sc->hwreset)(sc, IE_CARD_RESET);

	/* Setup Iface */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = i82596_start;
	ifp->if_ioctl = i82596_ioctl;
	ifp->if_watchdog = i82596_watchdog;
	ifp->if_flags =
#ifdef I82596_DEBUG
		IFF_DEBUG |
#endif
		IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;

        /* Initialize media goo. */
        ifmedia_init(&sc->sc_media, 0, i82596_mediachange, i82596_mediastatus);
        if (media != NULL) {
                for (i = 0; i < nmedia; i++)
                        ifmedia_add(&sc->sc_media, media[i], 0, NULL);
                ifmedia_set(&sc->sc_media, defmedia);
        } else {
                ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);
                ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);
        }

	if (padbuf == NULL) {
		padbuf = malloc(ETHER_MIN_LEN - ETHER_CRC_LEN, M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (padbuf == NULL) {
			printf("%s: can't allocate pad buffer\n",
			    sc->sc_dev.dv_xname);
			return;
		}
	}

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	printf(" %s v%d.%d, address %s\n", name, sc->sc_vers / 10,
	       sc->sc_vers % 10, ether_sprintf(etheraddr));
}


/*
 * Device timeout/watchdog routine.
 * Entered if the device neglects to generate an interrupt after a
 * transmit has been started on it.
 */
void
i82596_watchdog(ifp)
	struct ifnet *ifp;
{
	struct ie_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++ifp->if_oerrors;

	i82596_reset(sc, 1);
}

int
i82596_cmd_wait(sc)
	struct ie_softc *sc;
{
	/* spin on i82596 command acknowledge; wait at most 0.9 (!) seconds */
	int i, off;

	for (i = 180000; i--; DELAY(5)) {
		/* Read the command word */
		off = IE_SCB_CMD(sc->scb);
		bus_space_barrier(sc->bt, sc->bh, off, 2,
				  BUS_SPACE_BARRIER_READ);
		if ((sc->ie_bus_read16)(sc, off) == 0) {
#ifdef I82596_DEBUG
			if (sc->sc_debug & IED_CMDS)
				printf("%s: cmd_wait after %d usec\n",
				    sc->sc_dev.dv_xname, (180000 - i) * 5);
#endif
			return (0);
		}
	}

#ifdef I82596_DEBUG
	if (sc->sc_debug & IED_CMDS)
		printf("i82596_cmd_wait: timo(%ssync): scb status: %b\n",
		    sc->async_cmd_inprogress? "a" : "",
		    sc->ie_bus_read16(sc, IE_SCB_STATUS(sc->scb)),
		    IE_STAT_BITS);
#endif
	return (1);	/* Timeout */
}

/*
 * Send a command to the controller and wait for it to either complete
 * or be accepted, depending on the command.  If the command pointer
 * is null, then pretend that the command is not an action command.
 * If the command pointer is not null, and the command is an action
 * command, wait for one of the MASK bits to turn on in the command's
 * status field.
 * If ASYNC is set, we just call the chip's attention and return.
 * We may have to wait for the command's acceptance later though.
 */
int
i82596_start_cmd(sc, cmd, iecmdbuf, mask, async)
	struct ie_softc *sc;
	int cmd;
	int iecmdbuf;
	int mask;
	int async;
{
	int i, off;

#ifdef I82596_DEBUG
	if (sc->sc_debug & IED_CMDS)
		printf("start_cmd: %p, %x, %x, %b, %ssync\n",
		       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?"a":"");
#endif
	if (sc->async_cmd_inprogress != 0) {
		/*
		 * If previous command was issued asynchronously, wait
		 * for it now.
		 */
		if (i82596_cmd_wait(sc) != 0)
			return (1);
		sc->async_cmd_inprogress = 0;
	}

	off = IE_SCB_CMD(sc->scb);
	(sc->ie_bus_write16)(sc, off, cmd);
	bus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);
	(sc->chan_attn)(sc);

	if (async) {
		sc->async_cmd_inprogress = 1;
		return (0);
	}

	if (IE_ACTION_COMMAND(cmd) && iecmdbuf) {
		int status;
		/*
		 * Now spin-lock waiting for status.  This is not a very nice
		 * thing to do, and can kill performance pretty well...
		 * According to the packet driver, the minimum timeout
		 * should be .369 seconds.
		 */
		for (i = 73800; i--; DELAY(5)) {
			/* Read the command status */
			off = IE_CMD_COMMON_STATUS(iecmdbuf);
			bus_space_barrier(sc->bt, sc->bh, off, 2,
			    BUS_SPACE_BARRIER_READ);
			status = (sc->ie_bus_read16)(sc, off);
			if (status & mask) {
#ifdef I82596_DEBUG
				if (sc->sc_debug & IED_CMDS)
					printf("%s: cmd status %b\n",
					    sc->sc_dev.dv_xname,
					    status, IE_STAT_BITS);
#endif
				return (0);
			}
		}

	} else {
		/*
		 * Otherwise, just wait for the command to be accepted.
		 */
		return (i82596_cmd_wait(sc));
	}

	/* Timeout */
	return (1);
}

/*
 * Transfer accumulated chip error counters to IF.
 */
static __inline void
i82596_count_errors(struct ie_softc *sc)
{
	int scb = sc->scb;

	sc->sc_arpcom.ac_if.if_ierrors +=
	    sc->ie_bus_read16(sc, IE_SCB_ERRCRC(scb)) +
	    sc->ie_bus_read16(sc, IE_SCB_ERRALN(scb)) +
	    sc->ie_bus_read16(sc, IE_SCB_ERRRES(scb)) +
	    sc->ie_bus_read16(sc, IE_SCB_ERROVR(scb));

	/* Clear error counters */
	sc->ie_bus_write16(sc, IE_SCB_ERRCRC(scb), 0);
	sc->ie_bus_write16(sc, IE_SCB_ERRALN(scb), 0);
	sc->ie_bus_write16(sc, IE_SCB_ERRRES(scb), 0);
	sc->ie_bus_write16(sc, IE_SCB_ERROVR(scb), 0);
}

static __inline void
i82596_rx_errors(struct ie_softc *sc, int fn, int status)
{
	log(LOG_ERR, "%s: rx error (frame# %d): %b\n", sc->sc_dev.dv_xname, fn,
	    status, IE_FD_STATUSBITS);
}

/*
 * i82596 interrupt entry point.
 */
int
i82596_intr(v)
	void *v;
{
	register struct ie_softc *sc = v;
	register u_int status;
	register int off;

	off = IE_SCB_STATUS(sc->scb);
	bus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_READ);
	status = sc->ie_bus_read16(sc, off) /* & IE_ST_WHENCE */;

	if ((status & IE_ST_WHENCE) == 0) {
		if (sc->intrhook)
			(sc->intrhook)(sc, IE_INTR_EXIT);

		return (0);
	}

loop:
	/* Ack interrupts FIRST in case we receive more during the ISR. */
	i82596_start_cmd(sc, status & IE_ST_WHENCE, 0, 0, 1);

	if (status & (IE_ST_FR | IE_ST_RNR)) {
		if (sc->intrhook)
			(sc->intrhook)(sc, IE_INTR_ENRCV);

		if (i82596_rint(sc, status) != 0)
			goto reset;
	}

	if (status & IE_ST_CX) {
		if (sc->intrhook)
			(sc->intrhook)(sc, IE_INTR_ENSND);

		if (i82596_tint(sc, status) != 0)
			goto reset;
	}

#ifdef I82596_DEBUG
	if ((status & IE_ST_CNA) && (sc->sc_debug & IED_CNA))
		printf("%s: cna; status=%b\n", sc->sc_dev.dv_xname,
			status, IE_ST_BITS);
#endif
	if (sc->intrhook)
		(sc->intrhook)(sc, IE_INTR_LOOP);

	/*
	 * Interrupt ACK was posted asynchronously; wait for
	 * completion here before reading SCB status again.
	 *
	 * If ACK fails, try to reset the chip, in hopes that
	 * it helps.
	 */
	if (i82596_cmd_wait(sc))
		goto reset;

	bus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_READ);
	status = sc->ie_bus_read16(sc, off);
	if ((status & IE_ST_WHENCE) != 0)
		goto loop;

out:
	if (sc->intrhook)
		(sc->intrhook)(sc, IE_INTR_EXIT);
	return (1);

reset:
	i82596_cmd_wait(sc);
	i82596_reset(sc, 1);
	goto out;
}

/*
 * Process a received-frame interrupt.
 */
int
i82596_rint(sc, scbstatus)
	struct	ie_softc *sc;
	int	scbstatus;
{
	static int timesthru = 1024;
	register int i, status, off;

#ifdef I82596_DEBUG
	if (sc->sc_debug & IED_RINT)
		printf("%s: rint: status %b\n",
			sc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);
#endif

	for (;;) {
		register int drop = 0;

		i = sc->rfhead;
		off = IE_RFRAME_STATUS(sc->rframes, i);
		bus_space_barrier(sc->bt, sc->bh, off, 2,
				  BUS_SPACE_BARRIER_READ);
		status = sc->ie_bus_read16(sc, off);

#ifdef I82596_DEBUG
		if (sc->sc_debug & IED_RINT)
			printf("%s: rint: frame(%d) status %b\n",
				sc->sc_dev.dv_xname, i, status, IE_ST_BITS);
#endif
		if ((status & IE_FD_COMPLETE) == 0) {
			if ((status & IE_FD_OK) != 0) {
				printf("%s: rint: weird: ",
					sc->sc_dev.dv_xname);
				i82596_rx_errors(sc, i, status);
				break;
			}
			if (--timesthru == 0) {
				/* Account the accumulated errors */
				i82596_count_errors(sc);
				timesthru = 1024;
			}
			break;
		} else if ((status & IE_FD_OK) == 0) {
			/*
			 * If the chip is configured to automatically
			 * discard bad frames, the only reason we can
			 * get here is an "out-of-resource" condition.
			 */
			i82596_rx_errors(sc, i, status);
			drop = 1;
		}

#ifdef I82596_DEBUG
		if ((status & IE_FD_BUSY) != 0)
			printf("%s: rint: frame(%d) busy; status=%x\n",
				sc->sc_dev.dv_xname, i, status, IE_ST_BITS);
#endif

		/*
		 * Advance the RFD list, since we're done with
		 * this descriptor.
		 */

		/* Clear frame status */
		sc->ie_bus_write16(sc, off, 0);

		/* Put fence at this frame (the head) */
		off = IE_RFRAME_LAST(sc->rframes, i);
		sc->ie_bus_write16(sc, off, IE_FD_EOL|IE_FD_SUSP);

		/* and clear RBD field */
		off = IE_RFRAME_BUFDESC(sc->rframes, i);
		sc->ie_bus_write16(sc, off, 0xffff);

		/* Remove fence from current tail */
		off = IE_RFRAME_LAST(sc->rframes, sc->rftail);
		sc->ie_bus_write16(sc, off, 0);

		if (++sc->rftail == sc->nframes)
			sc->rftail = 0;
		if (++sc->rfhead == sc->nframes)
			sc->rfhead = 0;

		/* Pull the frame off the board */
		if (drop) {
			i82596_drop_frames(sc);
			if ((status & IE_FD_RNR) != 0)
				sc->rnr_expect = 1;
			sc->sc_arpcom.ac_if.if_ierrors++;
		} else if (i82596_readframe(sc, i) != 0)
			return (1);
	}

	if ((scbstatus & IE_ST_RNR) != 0) {

		/*
		 * Receiver went "Not Ready". We try to figure out
		 * whether this was an expected event based on past
		 * frame status values.
		 */

		if ((scbstatus & IE_RUS_SUSPEND) != 0) {
			/*
			 * We use the "suspend on last frame" flag.
			 * Send a RU RESUME command in response, since
			 * we should have dealt with all completed frames
			 * by now.
			 */
			printf("RINT: SUSPENDED; scbstatus=%b\n",
				scbstatus, IE_ST_BITS);
			if (i82596_start_cmd(sc, IE_RUC_RESUME, 0, 0, 0) == 0)
				return (0);
			printf("%s: RU RESUME command timed out\n",
				sc->sc_dev.dv_xname);
			return (1);	/* Ask for a reset */
		}

		if (sc->rnr_expect != 0) {
			/*
			 * The RNR condition was announced in the previously
			 * completed frame.  Assume the receive ring is Ok,
			 * so restart the receiver without further delay.
			 */
			i82596_start_transceiver(sc);
			sc->rnr_expect = 0;
			return (0);

		} else if ((scbstatus & IE_RUS_NOSPACE) != 0) {
			/*
			 * We saw no previous IF_FD_RNR flag.
			 * We check our ring invariants and, if ok,
			 * just restart the receiver at the current
			 * point in the ring.
			 */
			if (i82596_chk_rx_ring(sc) != 0)
				return (1);

			i82596_start_transceiver(sc);
			sc->sc_arpcom.ac_if.if_ierrors++;
			return (0);
		} else
			printf("%s: receiver not ready; scbstatus=%b\n",
				sc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);

		sc->sc_arpcom.ac_if.if_ierrors++;
		return (1);	/* Ask for a reset */
	}

	return (0);
}

/*
 * Process a command-complete interrupt.  These are only generated by the
 * transmission of frames.  This routine is deceptively simple, since most
 * of the real work is done by i82596_start().
 */
int
i82596_tint(sc, scbstatus)
	struct ie_softc *sc;
	int	scbstatus;
{
	register struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	register int off, status;

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

#ifdef I82596_DEBUG
	if (sc->xmit_busy <= 0) {
		printf("%s: i82596_tint: WEIRD:"
		       "xmit_busy=%d, xctail=%d, xchead=%d\n",
		       sc->sc_dev.dv_xname,
		       sc->xmit_busy, sc->xctail, sc->xchead);
		return (0);
	}
#endif

	off = IE_CMD_XMIT_STATUS(sc->xmit_cmds, sc->xctail);
	status = sc->ie_bus_read16(sc, off);

#ifdef I82596_DEBUG
	if (sc->sc_debug & IED_TINT)
		printf("%s: tint: SCB status %b; xmit status %b\n",
			sc->sc_dev.dv_xname, scbstatus, IE_ST_BITS,
			status, IE_XS_BITS);
#endif

	if ((status & (IE_STAT_COMPL|IE_STAT_BUSY)) == IE_STAT_BUSY) {
		printf("%s: i82596_tint: command still busy;"
		       "status=%b; tail=%d\n", sc->sc_dev.dv_xname,
		       status, IE_XS_BITS, sc->xctail);
		printf("iestatus = %b\n", scbstatus, IE_ST_BITS);
	}

	if (status & IE_STAT_OK) {
		ifp->if_collisions += (status & IE_XS_MAXCOLL);
	} else {
		ifp->if_oerrors++;
		/*
		 * Check SQE and DEFERRED?
		 * What if more than one bit is set?
		 */
#ifdef I82596_DEBUG
		if (status & IE_STAT_ABORT)
			printf("%s: send aborted\n", sc->sc_dev.dv_xname);
		else if (status & IE_XS_NOCARRIER)
			printf("%s: no carrier\n", sc->sc_dev.dv_xname);
		else if (status & IE_XS_LOSTCTS)
			printf("%s: lost CTS\n", sc->sc_dev.dv_xname);
		else if (status & IE_XS_UNDERRUN)
			printf("%s: DMA underrun\n", sc->sc_dev.dv_xname);
		else
#endif /* I82596_DEBUG */
		if (status & IE_XS_EXCMAX) {
#ifdef I82596_DEBUG
			printf("%s: too many collisions\n",
				sc->sc_dev.dv_xname);
#endif /* I82596_DEBUG */
			sc->sc_arpcom.ac_if.if_collisions += 16;
		}
	}

	/*
	 * If multicast addresses were added or deleted while transmitting,
	 * ie_mc_reset() set the want_mcsetup flag indicating that we
	 * should do it.
	 */
	if (sc->want_mcsetup) {
		ie_mc_setup(sc, IE_XBUF_ADDR(sc, sc->xctail));
		sc->want_mcsetup = 0;
	}

	/* Done with the buffer. */
	sc->xmit_busy--;
	sc->xctail = (sc->xctail + 1) % NTXBUF;

	/* Start the next packet, if any, transmitting. */
	if (sc->xmit_busy > 0)
		i82596_xmit(sc);

	i82596_start(ifp);
	return (0);
}

/*
 * Get a range of receive buffer descriptors that represent one packet.
 */
int
i82596_get_rbd_list(sc, start, end, pktlen)
	struct ie_softc *sc;
	u_int16_t	*start;
	u_int16_t	*end;
	int		*pktlen;
{
	int	off, rbbase = sc->rbds;
	int	rbindex, count = 0;
	int	plen = 0;
	int	rbdstatus;

	*start = rbindex = sc->rbhead;

	do {
		off = IE_RBD_STATUS(rbbase, rbindex);
		bus_space_barrier(sc->bt, sc->bh, off, 2,
				  BUS_SPACE_BARRIER_READ);
		rbdstatus = sc->ie_bus_read16(sc, off);
		if ((rbdstatus & IE_RBD_USED) == 0) {
			/*
			 * This means we are somehow out of sync.  So, we
			 * reset the adapter.
			 */
#ifdef I82596_DEBUG
			print_rbd(sc, rbindex);
#endif
			log(LOG_ERR,
			    "%s: receive descriptors out of sync at %d\n",
			    sc->sc_dev.dv_xname, rbindex);
			return (0);
		}
		plen += (rbdstatus & IE_RBD_CNTMASK);

		if (++rbindex == sc->nrxbuf)
			rbindex = 0;

		++count;
	} while ((rbdstatus & IE_RBD_LAST) == 0);
	*end = rbindex;
	*pktlen = plen;
	return (count);
}


/*
 * Release a range of receive buffer descriptors after we've copied the packet.
 */
void
i82596_release_rbd_list(sc, start, end)
	struct ie_softc *sc;
	u_int16_t	start;
	u_int16_t	end;
{
	register int	off, rbbase = sc->rbds;
	register int	rbindex = start;

	do {
		/* Clear buffer status */
		off = IE_RBD_STATUS(rbbase, rbindex);
		sc->ie_bus_write16(sc, off, 0);
		if (++rbindex == sc->nrxbuf)
			rbindex = 0;
	} while (rbindex != end);

	/* Mark EOL at new tail */
	rbindex = ((rbindex == 0) ? sc->nrxbuf : rbindex) - 1;
	off = IE_RBD_BUFLEN(rbbase, rbindex);
	sc->ie_bus_write16(sc, off, IE_RBUF_SIZE|IE_RBD_EOL);

	/* Remove EOL from current tail */
	off = IE_RBD_BUFLEN(rbbase, sc->rbtail);
	sc->ie_bus_write16(sc, off, IE_RBUF_SIZE);

	/* New head & tail pointer */
/* hmm, why have both? head is always (tail + 1) % NRXBUF */
	sc->rbhead = end;
	sc->rbtail = rbindex;
}

/*
 * Drop the packet at the head of the RX buffer ring.
 * Called if the frame descriptor reports an error on this packet.
 * Returns 1 if the buffer descriptor ring appears to be corrupt;
 * and 0 otherwise.
 */
int
i82596_drop_frames(sc)
	struct ie_softc *sc;
{
	u_int16_t bstart, bend;
	int pktlen;

	if (!i82596_get_rbd_list(sc, &bstart, &bend, &pktlen))
		return (1);
	i82596_release_rbd_list(sc, bstart, bend);
	return (0);
}

/*
 * Check the RX frame & buffer descriptor lists for our invariants,
 * i.e.: EOL bit set iff. it is pointed at by the r*tail pointer.
 *
 * Called when the receive unit has stopped unexpectedly.
 * Returns 1 if an inconsistency is detected; 0 otherwise.
 *
 * The Receive Unit is expected to be NOT RUNNING.
 */
int
i82596_chk_rx_ring(sc)
	struct ie_softc *sc;
{
	int n, off, val;

	for (n = 0; n < sc->nrxbuf; n++) {
		off = IE_RBD_BUFLEN(sc->rbds, n);
		val = sc->ie_bus_read16(sc, off);
		if ((n == sc->rbtail) ^ ((val & IE_RBD_EOL) != 0)) {
			/* `rbtail' and EOL flag out of sync */
			log(LOG_ERR,
			    "%s: rx buffer descriptors out of sync at %d\n",
			    sc->sc_dev.dv_xname, n);
			return (1);
		}

		/* Take the opportunity to clear the status fields here ? */
	}

	for (n = 0; n < sc->nframes; n++) {
		off = IE_RFRAME_LAST(sc->rframes, n);
		val = sc->ie_bus_read16(sc, off);
		if ((n == sc->rftail) ^ ((val & (IE_FD_EOL|IE_FD_SUSP)) != 0)) {
			/* `rftail' and EOL flag out of sync */
			log(LOG_ERR,
			    "%s: rx frame list out of sync at %d\n",
			    sc->sc_dev.dv_xname, n);
			return (1);
		}
	}

	return (0);
}

/*
 * Read data off the interface, and turn it into an mbuf chain.
 *
 * This code is DRAMATICALLY different from the previous version; this
 * version tries to allocate the entire mbuf chain up front, given the
 * length of the data available.  This enables us to allocate mbuf
 * clusters in many situations where before we would have had a long
 * chain of partially-full mbufs.  This should help to speed up the
 * operation considerably.  (Provided that it works, of course.)
 */
static __inline__ struct mbuf *
i82596_get(struct ie_softc *sc, int head, int totlen)
{
	struct mbuf *m, *m0, *newm;
	int off, len, resid;
	int thisrboff, thismboff;
	struct ether_header eh;

	/*
	 * Snarf the Ethernet header.
	 */
	(sc->memcopyin)(sc, &eh, IE_RBUF_ADDR(sc, head),
	    sizeof(struct ether_header));

	resid = totlen;

	MGETHDR(m0, M_DONTWAIT, MT_DATA);
	if (m0 == NULL)
		return (0);
	m0->m_pkthdr.len = totlen;
	len = MHLEN;
	m = m0;

	/*
	 * This loop goes through and allocates mbufs for all the data we will
	 * be copying in.  It does not actually do the copying yet.
	 */
	while (totlen > 0) {
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0)
				goto bad;
			len = MCLBYTES;
		}

		if (m == m0) {
			caddr_t newdata = (caddr_t)
			    ALIGN(m->m_data + sizeof(struct ether_header)) -
			    sizeof(struct ether_header);
			len -= newdata - m->m_data;
			m->m_data = newdata;
		}

		m->m_len = len = min(totlen, len);

		totlen -= len;
		if (totlen > 0) {
			MGET(newm, M_DONTWAIT, MT_DATA);
			if (newm == NULL)
				goto bad;
			len = MLEN;
			m = m->m_next = newm;
		}
	}

	m = m0;
	thismboff = 0;

	/*
	 * Copy the Ethernet header into the mbuf chain.
	 */
	bcopy(&eh, mtod(m, caddr_t), sizeof(struct ether_header));
	thismboff = sizeof(struct ether_header);
	thisrboff = sizeof(struct ether_header);
	resid -= sizeof(struct ether_header);

	/*
	 * Now we take the mbuf chain (hopefully only one mbuf most of the
	 * time) and stuff the data into it.  There are no possible failures
	 * at or after this point.
	 */
	while (resid > 0) {
		int thisrblen = IE_RBUF_SIZE - thisrboff,
		    thismblen = m->m_len - thismboff;
		len = min(thisrblen, thismblen);

		off = IE_RBUF_ADDR(sc,head) + thisrboff;
		(sc->memcopyin)(sc, mtod(m, caddr_t) + thismboff, off, len);
		resid -= len;

		if (len == thismblen) {
			m = m->m_next;
			thismboff = 0;
		} else
			thismboff += len;

		if (len == thisrblen) {
			if (++head == sc->nrxbuf)
				head = 0;
			thisrboff = 0;
		} else
			thisrboff += len;
	}

	/*
	 * Unless something changed strangely while we were doing the copy,
	 * we have now copied everything in from the shared memory.
	 * This means that we are done.
	 */
	return (m0);

bad:
	m_freem(m0);
	return (NULL);
}

/*
 * Read frame NUM from unit UNIT (pre-cached as IE).
 *
 * This routine reads the RFD at NUM, and copies in the buffers from the list
 * of RBD, then rotates the RBD list so that the receiver doesn't start
 * complaining.  Trailers are DROPPED---there's no point in wasting time
 * on confusing code to deal with them.  Hopefully, this machine will
 * never ARP for trailers anyway.
 */
int
i82596_readframe(sc, num)
	struct ie_softc *sc;
	int num;		/* frame number to read */
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	u_int16_t bstart, bend;
	int pktlen;

	if (i82596_get_rbd_list(sc, &bstart, &bend, &pktlen) == 0) {
		ifp->if_ierrors++;
		return (1);
	}

	m = i82596_get(sc, bstart, pktlen);
	i82596_release_rbd_list(sc, bstart, bend);

	if (m == NULL) {
		sc->sc_arpcom.ac_if.if_ierrors++;
		return (0);
	}

#ifdef I82596_DEBUG
	if (sc->sc_debug & IED_READFRAME) {
		struct ether_header *eh = mtod(m, struct ether_header *);

		printf("%s: frame from ether %s type 0x%x len %d\n",
		    sc->sc_dev.dv_xname, ether_sprintf(eh->ether_shost),
		    (u_int)eh->ether_type, pktlen);
	}
#endif

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
	return (0);
}


/*
 * Setup all necessary artifacts for an XMIT command, and then pass the XMIT
 * command to the chip to be executed.
 */
void
i82596_xmit(sc)
	struct ie_softc *sc;
{
	int off, cur, prev;

	cur = sc->xctail;

#ifdef I82596_DEBUG
	if (sc->sc_debug & IED_XMIT)
		printf("%s: xmit buffer %d\n", sc->sc_dev.dv_xname, cur);
#endif

	/*
	 * Setup the transmit command.
	 */
	sc->ie_bus_write16(sc, IE_CMD_XMIT_DESC(sc->xmit_cmds, cur),
			       IE_XBD_ADDR(sc->xbds, cur));

	sc->ie_bus_write16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds, cur), 0);

	if (sc->do_xmitnopchain) {
		/*
		 * Gate this XMIT command to the following NOP
		 */
		sc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds, cur),
				       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));
		sc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),
				       IE_CMD_XMIT | IE_CMD_INTR);

		/*
		 * Loopback at following NOP
		 */
		sc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, cur), 0);
		sc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, cur),
				       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));

		/*
		 * Gate preceding NOP to this XMIT command
		 */
		prev = (cur + NTXBUF - 1) % NTXBUF;
		sc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, prev), 0);
		sc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, prev),
				       IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));

		off = IE_SCB_STATUS(sc->scb);
		bus_space_barrier(sc->bt, sc->bh, off, 2,
				  BUS_SPACE_BARRIER_READ);
		if ((sc->ie_bus_read16(sc, off) & IE_CUS_ACTIVE) == 0) {
			printf("i82596_xmit: CU not active\n");
			i82596_start_transceiver(sc);
		}
	} else {
		sc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds,cur),
				       0xffff);

		sc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),
				       IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST);

		off = IE_SCB_CMDLST(sc->scb);
		sc->ie_bus_write16(sc, off, IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));
		bus_space_barrier(sc->bt, sc->bh, off, 2,
				  BUS_SPACE_BARRIER_WRITE);

		if (i82596_start_cmd(sc, IE_CUC_START, 0, 0, 1)) {
#ifdef I82596_DEBUG
			if (sc->sc_debug & IED_XMIT)
				printf("%s: i82596_xmit: "
				    "start xmit command timed out\n",
				       sc->sc_dev.dv_xname);
#endif
		}
	}

	sc->sc_arpcom.ac_if.if_timer = 5;
}


/*
 * Start transmission on an interface.
 */
void
i82596_start(ifp)
	struct ifnet *ifp;
{
	struct ie_softc *sc = ifp->if_softc;
	struct mbuf *m0, *m;
	int	buffer, head, xbase;
	u_short	len;

#ifdef I82596_DEBUG
	if (sc->sc_debug & IED_ENQ)
		printf("i82596_start(%p)\n", ifp);
#endif

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->xmit_busy == NTXBUF) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;

		/* We need to use m->m_pkthdr.len, so require the header */
		if ((m0->m_flags & M_PKTHDR) == 0)
			panic("i82596_start: no header mbuf");

#if NBPFILTER > 0
		/* Tap off here if there is a BPF listener. */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

		if (m0->m_pkthdr.len > IE_TBUF_SIZE)
			printf("%s: tbuf overflow\n", sc->sc_dev.dv_xname);

		head = sc->xchead;
		sc->xchead = (head + 1) % NTXBUF;
		buffer = IE_XBUF_ADDR(sc, head);

#ifdef I82596_DEBUG
		if (sc->sc_debug & IED_ENQ)
			printf("%s: fill buffer %d offset %x",
			    sc->sc_dev.dv_xname, head, buffer);
#endif

		for (m = m0; m != 0; m = m->m_next) {
#ifdef I82596_DEBUG
			if (sc->sc_debug & IED_ENQ) {
				u_int8_t *e, *p = mtod(m, u_int8_t *);
				static int i;
				if (m == m0)
					i = 0;
				for (e = p + m->m_len; p < e; i++, p += 2) {
					if (!(i % 8))
						printf("\n%s:",
						    sc->sc_dev.dv_xname);
					printf(" %02x%02x", p[0], p[1]);
				}
			}
#endif
			(sc->memcopyout)(sc, mtod(m,caddr_t), buffer, m->m_len);
			buffer += m->m_len;
		}

		len = m0->m_pkthdr.len;
		if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
			(sc->memcopyout)(sc, padbuf, buffer,
			    ETHER_MIN_LEN - ETHER_CRC_LEN - len);
			buffer += ETHER_MIN_LEN - ETHER_CRC_LEN - len;
			len = ETHER_MIN_LEN - ETHER_CRC_LEN;
		}

#ifdef I82596_DEBUG
		if (sc->sc_debug & IED_ENQ)
			printf("\n");
#endif

		m_freem(m0);

		/*
		 * Setup the transmit buffer descriptor here, while we
		 * know the packet's length.
		 */
		xbase = sc->xbds;
		sc->ie_bus_write16(sc, IE_XBD_FLAGS(xbase, head),
				       len | IE_TBD_EOL);
		sc->ie_bus_write16(sc, IE_XBD_NEXT(xbase, head), 0xffff);
		sc->ie_bus_write24(sc, IE_XBD_BUF(xbase, head),
				       sc->sc_maddr + IE_XBUF_ADDR(sc, head));

		/* Start the first packet transmitting. */
		if (sc->xmit_busy++ == 0)
			i82596_xmit(sc);
	}
}

/*
 * Probe IE's ram setup   [ Move all this into MD front-end!? ]
 * Use only if SCP and ISCP represent offsets into shared ram space.
 */
int
i82596_proberam(sc)
	struct ie_softc *sc;
{
	int result, off;

	/* Put in 16-bit mode */
	off = IE_SCP_BUS_USE(sc->scp);
	(sc->ie_bus_write16)(sc, off, 0);
	bus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);

	/* Set the ISCP `busy' bit */
	off = IE_ISCP_BUSY(sc->iscp);
	(sc->ie_bus_write16)(sc, off, 1);
	bus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);

	if (sc->hwreset)
		(sc->hwreset)(sc, IE_CHIP_PROBE);

	(sc->chan_attn) (sc);

	DELAY(100);		/* wait a while... */

	/* Read back the ISCP `busy' bit; it should be clear by now */
	off = IE_ISCP_BUSY(sc->iscp);
	bus_space_barrier(sc->bt, sc->bh, off, 1, BUS_SPACE_BARRIER_READ);
	result = (sc->ie_bus_read16)(sc, off) == 0;

	/* Acknowledge any interrupts we may have caused. */
	ie_ack(sc, IE_ST_WHENCE);

	return (result);
}

void
i82596_reset(sc, hard)
	struct ie_softc *sc;
	int hard;
{
	int s = splnet();

#ifdef I82596_DEBUG
	if (hard)
		printf("%s: reset\n", sc->sc_dev.dv_xname);
#endif

	/* Clear OACTIVE in case we're called from watchdog (frozen xmit). */
	sc->sc_arpcom.ac_if.if_timer = 0;
	ifq_clr_oactive(&sc->sc_arpcom.ac_if.if_snd);

	/*
	 * Stop i82596 dead in its tracks.
	 */
	if (i82596_start_cmd(sc, IE_RUC_ABORT | IE_CUC_ABORT, 0, 0, 0)) {
#ifdef I82596_DEBUG
		printf("%s: abort commands timed out\n", sc->sc_dev.dv_xname);
#endif
	}

	/*
	 * This can really slow down the i82596_reset() on some cards, but it's
	 * necessary to unwedge other ones (eg, the Sun VME ones) from certain
	 * lockups.
	 */
	if (hard && sc->hwreset)
		(sc->hwreset)(sc, IE_CARD_RESET);

	DELAY(100);
	ie_ack(sc, IE_ST_WHENCE);

	if ((sc->sc_arpcom.ac_if.if_flags & IFF_UP) != 0) {
		int retries=0;	/* XXX - find out why init sometimes fails */
		while (retries++ < 2)
			if (i82596_init(sc) == 1)
				break;
	}

	splx(s);
}

void
i82596_simple_command(sc, cmd, cmdbuf)
	struct ie_softc *sc;
	int cmd;
	int cmdbuf;
{
	/* Setup a simple command */
	sc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);
	sc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);
	sc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);

	/* Assign the command buffer to the SCB command list */
	sc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);
}

/*
 * Run the time-domain reflectometer.
 */
void
ie_run_tdr(sc, cmd)
	struct ie_softc *sc;
	int cmd;
{
	int result, clocks;

	i82596_simple_command(sc, IE_CMD_TDR, cmd);
	(sc->ie_bus_write16)(sc, IE_CMD_TDR_TIME(cmd), 0);

	if (i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0) ||
	    !(sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd)) & IE_STAT_OK))
		result = 0x10000; /* XXX */
	else
		result = sc->ie_bus_read16(sc, IE_CMD_TDR_TIME(cmd));

	/* Squash any pending interrupts */
	ie_ack(sc, IE_ST_WHENCE);

	if (result & IE_TDR_SUCCESS)
		return;

	clocks = result & IE_TDR_TIME;
	if (result & 0x10000)
		printf("%s: TDR command failed\n", sc->sc_dev.dv_xname);
	else if (result & IE_TDR_XCVR) {
#ifdef I82596_DEBUG
		printf("%s: transceiver problem\n", sc->sc_dev.dv_xname);
#endif
	} else if (result & IE_TDR_OPEN)
		printf("%s: TDR detected an open %d clock%s away\n",
		    sc->sc_dev.dv_xname, clocks, clocks == 1? "":"s");
	else if (result & IE_TDR_SHORT)
		printf("%s: TDR detected a short %d clock%s away\n",
		    sc->sc_dev.dv_xname, clocks, clocks == 1? "":"s");
	else
		printf("%s: TDR returned unknown status 0x%x\n",
		    sc->sc_dev.dv_xname, result);
}

/*
 * i82596_setup_bufs: set up the buffers
 *
 * We have a block of KVA at sc->buf_area which is of size sc->buf_area_sz.
 * this is to be used for the buffers.  The chip indexs its control data
 * structures with 16 bit offsets, and it indexes actual buffers with
 * 24 bit addresses.   So we should allocate control buffers first so that
 * we don't overflow the 16 bit offset field.   The number of transmit
 * buffers is fixed at compile time.
 *
 */
void
i82596_setup_bufs(sc)
	struct ie_softc *sc;
{
	int n, r, ptr = sc->buf_area;	/* memory pool */
	int cl = 32;

	/*
	 * step 0: zero memory and figure out how many recv buffers and
	 * frames we can have.
	 */
	ptr = (ptr + cl - 1) & ~(cl - 1); /* set alignment and stick with it */

	/*
	 *  step 1: lay out data structures in the shared-memory area
	 */

	/* The no-op commands; used if "nop-chaining" is in effect */
	ptr += cl;
	sc->nop_cmds = ptr - 2;
	ptr += NTXBUF * 32;

	/* The transmit commands */
	ptr += cl;
	sc->xmit_cmds = ptr - 2;
	ptr += NTXBUF * 32;

	/* The transmit buffers descriptors */
	ptr += cl;
	sc->xbds = ptr - 2;
	ptr += NTXBUF * 32;

	/* The transmit buffers */
	sc->xbufs = ptr;
	ptr += NTXBUF * IE_TBUF_SIZE;

	ptr = (ptr + cl - 1) & ~(cl - 1);	/* re-align.. just in case */

	/* Compute free space for RECV stuff */
	n = sc->buf_area_sz - (ptr - sc->buf_area);

	/* Compute size of one RECV frame */
	r = 64 + ((32 + IE_RBUF_SIZE) * B_PER_F);

	sc->nframes = n / r;

	if (sc->nframes <= 8)
		panic("ie: bogus buffer calc");

	sc->nrxbuf = sc->nframes * B_PER_F;

	/* The receive frame descriptors */
	ptr += cl;
	sc->rframes = ptr - 2;
	ptr += sc->nframes * 64;

	/* The receive buffer descriptors */
	ptr += cl;
	sc->rbds = ptr - 2;
	ptr += sc->nrxbuf * 32;

	/* The receive buffers */
	sc->rbufs = ptr;
	ptr += sc->nrxbuf * IE_RBUF_SIZE;

#ifdef I82596_DEBUG
	printf("%s: %d frames %d bufs\n", sc->sc_dev.dv_xname, sc->nframes,
		sc->nrxbuf);
#endif

	/*
	 * step 2: link together the recv frames and set EOL on last one
	 */
	for (n = 0; n < sc->nframes; n++) {
		int m = (n == sc->nframes - 1) ? 0 : n + 1;

		/* Clear status */
		sc->ie_bus_write16(sc, IE_RFRAME_STATUS(sc->rframes,n), 0);

		/* RBD link = NULL */
		sc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,n),
				       0xffff);

		/* Make a circular list */
		sc->ie_bus_write16(sc, IE_RFRAME_NEXT(sc->rframes,n),
				       IE_RFRAME_ADDR(sc->rframes,m));

		/* Mark last as EOL */
		sc->ie_bus_write16(sc, IE_RFRAME_LAST(sc->rframes,n),
				       ((m==0)? (IE_FD_EOL|IE_FD_SUSP) : 0));
	}

	/*
	 * step 3: link the RBDs and set EOL on last one
	 */
	for (n = 0; n < sc->nrxbuf; n++) {
		int m = (n == sc->nrxbuf - 1) ? 0 : n + 1;

		/* Clear status */
		sc->ie_bus_write16(sc, IE_RBD_STATUS(sc->rbds,n), 0);

		/* Make a circular list */
		sc->ie_bus_write16(sc, IE_RBD_NEXT(sc->rbds,n),
				       IE_RBD_ADDR(sc->rbds,m));

		/* Link to data buffers */
		sc->ie_bus_write24(sc, IE_RBD_BUFADDR(sc->rbds, n),
				       sc->sc_maddr + IE_RBUF_ADDR(sc, n));
		sc->ie_bus_write16(sc, IE_RBD_BUFLEN(sc->rbds,n),
				       IE_RBUF_SIZE | ((m==0)?IE_RBD_EOL:0));
	}

	/*
	 * step 4: all xmit no-op commands loopback onto themselves
	 */
	for (n = 0; n < NTXBUF; n++) {
		(sc->ie_bus_write16)(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, n), 0);

		(sc->ie_bus_write16)(sc, IE_CMD_NOP_CMD(sc->nop_cmds, n),
					 IE_CMD_NOP);

		(sc->ie_bus_write16)(sc, IE_CMD_NOP_LINK(sc->nop_cmds, n),
					 IE_CMD_NOP_ADDR(sc->nop_cmds, n));
	}


	/*
	 * step 6: set the head and tail pointers on receive to keep track of
	 * the order in which RFDs and RBDs are used.
	 */

	/* Pointers to last packet sent and next available transmit buffer. */
	sc->xchead = sc->xctail = 0;

	/* Clear transmit-busy flag and set number of free transmit buffers. */
	sc->xmit_busy = 0;

	/*
	 * Pointers to first and last receive frame.
	 * The RFD pointed to by rftail is the only one that has EOL set.
	 */
	sc->rfhead = 0;
	sc->rftail = sc->nframes - 1;

	/*
	 * Pointers to first and last receive descriptor buffer.
	 * The RBD pointed to by rbtail is the only one that has EOL set.
	 */
	sc->rbhead = 0;
	sc->rbtail = sc->nrxbuf - 1;

/* link in recv frames * and buffer into the scb. */
#ifdef I82596_DEBUG
	printf("%s: reserved %d bytes\n",
		sc->sc_dev.dv_xname, ptr - sc->buf_area);
#endif
}

int
ie_cfg_setup(sc, cmd, promiscuous, manchester)
	struct ie_softc *sc;
	int cmd;
	int promiscuous, manchester;
{
	int cmdresult, status;

	i82596_simple_command(sc, IE_CMD_CONFIG, cmd);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CNT(cmd), 0x0c);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_FIFO(cmd), 8);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SAVEBAD(cmd), 0x40);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_ADDRLEN(cmd), 0x2e);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PRIORITY(cmd), 0);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_IFS(cmd), 0x60);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_LOW(cmd), 0);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_HIGH(cmd), 0xf2);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PROMISC(cmd),
					  !!promiscuous | manchester << 2);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CRSCDT(cmd), 0);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_MINLEN(cmd), 64);
	bus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_JUNK(cmd), 0xff);
	bus_space_barrier(sc->bt, sc->bh, cmd, IE_CMD_CFG_SZ,
			  BUS_SPACE_BARRIER_WRITE);

	cmdresult = i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0);
	status = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd));
	if (cmdresult != 0) {
		printf("%s: configure command timed out; status %b\n",
			sc->sc_dev.dv_xname, status, IE_STAT_BITS);
		return (0);
	}
	if ((status & IE_STAT_OK) == 0) {
		printf("%s: configure command failed; status %b\n",
			sc->sc_dev.dv_xname, status, IE_STAT_BITS);
		return (0);
	}

	/* Squash any pending interrupts */
	ie_ack(sc, IE_ST_WHENCE);
	return (1);
}

int
ie_ia_setup(sc, cmdbuf)
	struct ie_softc *sc;
	int cmdbuf;
{
	int cmdresult, status;

	i82596_simple_command(sc, IE_CMD_IASETUP, cmdbuf);

	(sc->memcopyout)(sc, sc->sc_arpcom.ac_enaddr,
			 IE_CMD_IAS_EADDR(cmdbuf), ETHER_ADDR_LEN);

	cmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);
	status = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));
	if (cmdresult != 0) {
		printf("%s: individual address command timed out; status %b\n",
			sc->sc_dev.dv_xname, status, IE_STAT_BITS);
		return (0);
	}
	if ((status & IE_STAT_OK) == 0) {
		printf("%s: individual address command failed; status %b\n",
			sc->sc_dev.dv_xname, status, IE_STAT_BITS);
		return (0);
	}

	/* Squash any pending interrupts */
	ie_ack(sc, IE_ST_WHENCE);
	return (1);
}

/*
 * Run the multicast setup command.
 * Called at splnet().
 */
int
ie_mc_setup(sc, cmdbuf)
	struct ie_softc *sc;
	int cmdbuf;
{
	int cmdresult, status;

	if (sc->mcast_count == 0)
		return (1);

	i82596_simple_command(sc, IE_CMD_MCAST, cmdbuf);

	(sc->memcopyout)(sc, (caddr_t)sc->mcast_addrs,
			 IE_CMD_MCAST_MADDR(cmdbuf),
			 sc->mcast_count * ETHER_ADDR_LEN);

	sc->ie_bus_write16(sc, IE_CMD_MCAST_BYTES(cmdbuf),
			       sc->mcast_count * ETHER_ADDR_LEN);

	/* Start the command */
	cmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);
	status = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));
	if (cmdresult != 0) {
		printf("%s: multicast setup command timed out; status %b\n",
			sc->sc_dev.dv_xname, status, IE_STAT_BITS);
		return (0);
	}
	if ((status & IE_STAT_OK) == 0) {
		printf("%s: multicast setup command failed; status %b\n",
			sc->sc_dev.dv_xname, status, IE_STAT_BITS);
		return (0);
	}

	/* Squash any pending interrupts */
	ie_ack(sc, IE_ST_WHENCE);
	return (1);
}

/*
 * This routine takes the environment generated by check_ie_present() and adds
 * to it all the other structures we need to operate the adapter.  This
 * includes executing the CONFIGURE, IA-SETUP, and MC-SETUP commands, starting
 * the receiver unit, and clearing interrupts.
 *
 * THIS ROUTINE MUST BE CALLED AT splnet() OR HIGHER.
 */
int
i82596_init(sc)
	struct ie_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int cmd;

	sc->async_cmd_inprogress = 0;

	cmd = sc->buf_area;

	/*
	 * Send the configure command first.
	 */
	if (ie_cfg_setup(sc, cmd, sc->promisc, 0) == 0)
		return (0);

	/*
	 * Send the Individual Address Setup command.
	 */
	if (ie_ia_setup(sc, cmd) == 0)
		return (0);

	/*
	 * Run the time-domain reflectometer.
	 */
	ie_run_tdr(sc, cmd);

	/*
	 * Set the multi-cast filter, if any
	 */
	if (ie_mc_setup(sc, cmd) == 0)
		return (0);

	/*
	 * Acknowledge any interrupts we have generated thus far.
	 */
	ie_ack(sc, IE_ST_WHENCE);

	/*
	 * Set up the transmit and recv buffers.
	 */
	i82596_setup_bufs(sc);

	if (sc->hwinit)
		(sc->hwinit)(sc);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (NTXBUF < 2)
		sc->do_xmitnopchain = 0;

	i82596_start_transceiver(sc);
	return (1);
}

/*
 * Start the RU and possibly the CU unit
 */
void
i82596_start_transceiver(sc)
	struct ie_softc *sc;
{

	/*
	 * Start RU at current position in frame & RBD lists.
	 */
	sc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),
			       IE_RBD_ADDR(sc->rbds, sc->rbhead));

	sc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),
			       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));

	if (sc->do_xmitnopchain) {
		/* Stop transmit command chain */
		if (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))
			printf("%s: CU/RU stop command timed out\n",
				sc->sc_dev.dv_xname);

		/* Start the receiver & transmitter chain */
		/* sc->scb->ie_command_list =
			IEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/
		sc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),
				   IE_CMD_NOP_ADDR(
					sc->nop_cmds,
					(sc->xctail + NTXBUF - 1) % NTXBUF));

		if (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))
			printf("%s: CU/RU command timed out\n",
				sc->sc_dev.dv_xname);
	} else {
		if (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))
			printf("%s: RU command timed out\n",
				sc->sc_dev.dv_xname);
	}
}

void
i82596_stop(sc)
	struct ie_softc *sc;
{

	if (i82596_start_cmd(sc, IE_RUC_SUSPEND | IE_CUC_SUSPEND, 0, 0, 0))
		printf("%s: i82596_stop: disable commands timed out\n",
			sc->sc_dev.dv_xname);
}

int
i82596_ioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ie_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch(cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		i82596_init(sc);
		break;

	case SIOCSIFFLAGS:
		sc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			i82596_stop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			i82596_init(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			i82596_stop(sc);
			i82596_init(sc);
		}
#ifdef I82596_DEBUG
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = IED_ALL;
		else
			sc->sc_debug = 0;
#endif
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			ie_mc_reset(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
ie_mc_reset(sc)
	struct ie_softc *sc;
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	int size;

	if (ac->ac_multicnt >= IE_MAXMCAST || ac->ac_multirangecnt > 0) {
		ac->ac_if.if_flags |= IFF_ALLMULTI;
		i82596_ioctl(&ac->ac_if, SIOCSIFFLAGS, NULL);
		return;
	}

	/*
	 * Step through the list of addresses.
	 */
	size = 0;
	sc->mcast_count = 0;
	ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
	while (enm) {
		size += ETHER_ADDR_LEN;
		sc->mcast_count++;
		ETHER_NEXT_MULTI(step, enm);
	}

	if (size > sc->mcast_addrs_size) {
		/* Need to allocate more space */
		if (sc->mcast_addrs_size)
			free(sc->mcast_addrs, M_IFMADDR, 0);
		sc->mcast_addrs = (char *)
			malloc(size, M_IFMADDR, M_WAITOK);
		sc->mcast_addrs_size = size;
	}

	/*
	 * We've got the space; now copy the addresses
	 */
	sc->mcast_count = 0;
	ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
	while (enm) {
		bcopy(enm->enm_addrlo,
		   &sc->mcast_addrs[sc->mcast_count * ETHER_ADDR_LEN],
		   ETHER_ADDR_LEN);
		sc->mcast_count++;
		ETHER_NEXT_MULTI(step, enm);
	}
	sc->want_mcsetup = 1;
}

/*
 * Media change callback.
 */
int
i82596_mediachange(ifp)
        struct ifnet *ifp;
{
        struct ie_softc *sc = ifp->if_softc;

        if (sc->sc_mediachange)
                return ((*sc->sc_mediachange)(sc));
        return (EINVAL);
}

/*
 * Media status callback.
 */
void
i82596_mediastatus(ifp, ifmr)
        struct ifnet *ifp;
        struct ifmediareq *ifmr;
{
        struct ie_softc *sc = ifp->if_softc;

        if (sc->sc_mediastatus)
                (*sc->sc_mediastatus)(sc, ifmr);
}

#ifdef I82596_DEBUG
void
print_rbd(sc, n)
	struct ie_softc *sc;
	int n;
{

	printf("RBD at %08x:\n  status %b, next %04x, buffer %lx\n"
		"length/EOL %04x\n", IE_RBD_ADDR(sc->rbds,n),
		sc->ie_bus_read16(sc, IE_RBD_STATUS(sc->rbds,n)), IE_STAT_BITS,
		sc->ie_bus_read16(sc, IE_RBD_NEXT(sc->rbds,n)),
		(u_long)0,/*bus_space_read_4(sc->bt, sc->bh, IE_RBD_BUFADDR(sc->rbds,n)),-* XXX */
		sc->ie_bus_read16(sc, IE_RBD_BUFLEN(sc->rbds,n)));
}
#endif
@


1.52
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.51 2016/03/14 23:08:05 krw Exp $	*/
a755 1
		ifp->if_opackets++;
@


1.51
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.50 2015/12/08 13:34:22 tedu Exp $	*/
a293 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.50
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.49 2015/11/25 11:12:53 mpi Exp $	*/
d1927 1
a1927 1
		i82596_ioctl(&ac->ac_if, SIOCSIFFLAGS, (void *)0);
@


1.49
log
@Small fixes related to the IFF_OACTIVE removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.48 2015/11/25 03:09:58 dlg Exp $	*/
d293 1
a293 1
		IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.48
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.47 2015/11/24 17:11:39 mpi Exp $	*/
d1356 1
a1356 1
	ifq_clr_oactive(sc->sc_arpcom.ac_if.if_snd);
@


1.47
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.46 2015/11/24 13:33:17 mpi Exp $	*/
d727 1
a727 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1217 1
a1217 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1222 1
a1222 1
			ifp->if_flags |= IFF_OACTIVE;
d1356 1
a1356 1
	sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;
d1786 1
a1786 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.46
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.45 2015/10/25 12:48:46 mpi Exp $	*/
a148 1
#include <net/if_dl.h>
@


1.45
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.44 2015/09/18 09:54:08 miod Exp $	*/
a149 1
#include <net/if_types.h>
@


1.44
log
@More ifmedia64 fallout.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.43 2015/06/24 09:40:54 mpi Exp $	*/
a1854 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d1863 1
a1863 10

		switch(ifa->ifa_addr->sa_family) {
		case AF_INET:
			i82596_init(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			i82596_init(sc);
			break;
		}
@


1.43
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.42 2015/05/13 10:42:46 jsg Exp $	*/
d271 2
a272 5
i82596_attach(sc, name, etheraddr, media, nmedia, defmedia)
	struct ie_softc *sc;
	const char *name;
	u_int8_t *etheraddr;
        int *media, nmedia, defmedia;
@


1.42
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.41 2015/05/01 16:37:32 mpi Exp $	*/
a1117 2
	ifp->if_ipackets++;

@


1.41
log
@Convert to if_input(), ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.40 2014/12/22 02:28:51 tedu Exp $	*/
d985 1
a985 1
	if (m0 == 0)
d1016 1
a1016 1
			if (newm == 0)
d1102 1
a1102 1
	if (m == 0) {
d1234 1
a1234 1
		if (m0 == 0)
@


1.40
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.39 2014/07/22 13:12:12 mpi Exp $	*/
a986 1
	m0->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
d1090 1
d1117 2
a1118 5
#if NBPFILTER > 0
	/* Check for a BPF filter; if so, hand it up. */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif /* NBPFILTER > 0 */
d1120 1
a1120 5
	/*
	 * Finally pass this packet up to higher layers.
	 */
	ether_input_mbuf(ifp, m);
	ifp->if_ipackets++;
@


1.39
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.38 2014/07/12 18:48:17 tedu Exp $	*/
a156 1
#ifdef INET
a158 1
#endif
a1877 1
#ifdef INET
a1881 1
#endif
@


1.38
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.37 2014/07/08 17:19:25 deraadt Exp $	*/
a158 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.37
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.36 2013/11/27 06:48:50 deraadt Exp $	*/
d1976 1
a1976 1
			free(sc->mcast_addrs, M_IFMADDR);
@


1.36
log
@fix typo
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.35 2013/11/26 09:50:33 mpi Exp $	*/
a162 2

#include <uvm/uvm_extern.h>
@


1.35
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.34 2013/08/07 01:06:29 bluhm Exp $	*/
d1959 1
a1959 1
		i82596_ioctl(&ac->.ac_if, SIOCSIFFLAGS, (void *)0);
@


1.34
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.33 2009/10/31 14:31:11 deraadt Exp $	*/
d1952 1
d1957 6
a1970 8
		if (sc->mcast_count >= IE_MAXMCAST ||
		    bcmp(enm->enm_addrlo, enm->enm_addrhi,
		        ETHER_ADDR_LEN) != 0) {
			sc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;
			i82596_ioctl(&sc->sc_arpcom.ac_if,
				     SIOCSIFFLAGS, (void *)0);
			return;
		}
@


1.33
log
@in the absense of link state handling, drivers should still be silent; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.32 2008/11/28 02:44:17 brad Exp $	*/
a159 1
#include <netinet/in_var.h>
@


1.32
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.31 2008/10/03 00:19:55 brad Exp $	*/
d777 1
d786 4
a789 1
		else if (status & IE_XS_EXCMAX) {
d792 1
d1452 2
a1453 1
	else if (result & IE_TDR_XCVR)
d1455 2
a1456 1
	else if (result & IE_TDR_OPEN)
@


1.31
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.30 2008/10/02 20:21:13 brad Exp $	*/
a1922 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom):
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				ie_mc_reset(sc);
			error = 0;
		}
		break;

d1930 6
@


1.30
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.29 2008/06/26 05:42:15 ray Exp $	*/
d1940 4
a1943 4
        case SIOCGIFMEDIA:
        case SIOCSIFMEDIA:
                error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
                break;
@


1.29
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.28 2007/09/18 00:46:41 krw Exp $	*/
a1872 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}

a1873 1

d1946 1
a1946 1
		error = EINVAL;
d1948 1
@


1.28
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.27 2007/09/10 06:12:59 kettenis Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.27
log
@Fix setting up the multicast filter.  Fixes PR 5474.

"looks right" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.26 2006/03/25 22:41:43 djm Exp $	*/
d328 1
a328 1
		    M_NOWAIT);
a333 1
		bzero(padbuf, ETHER_MIN_LEN - ETHER_CRC_LEN);
@


1.26
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.25 2005/01/15 05:24:11 brad Exp $	*/
a1976 1
again:
d1981 1
a1981 1
		size += 6;
d1983 2
a1984 1
		    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {
d1990 1
d2006 1
d2009 3
a2011 4
		if (sc->mcast_count >= IE_MAXMCAST)
			goto again; /* Just in case */

		bcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);
@


1.25
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.24 2004/05/12 06:35:10 tedu Exp $	*/
d1130 1
a1130 1
		bpf_mtap(ifp->if_bpf, m);
d1261 1
a1261 1
			bpf_mtap(ifp->if_bpf, m0);
@


1.24
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.23 2003/12/09 11:48:14 mickey Exp $	*/
d1948 2
a1949 1
			ie_mc_reset(sc);
@


1.23
log
@missing arg; from Erick Borsboom <erick@@bonzai.space-ei.nl>
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.22 2003/10/21 18:58:49 jmc Exp $	*/
a161 1
#include <net/bpfdesc.h>
@


1.22
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.21 2003/08/09 03:11:47 mickey Exp $	*/
d331 2
a332 1
			printf("%s: can't allocate pad buffer\n");
@


1.21
log
@need to include bpfilter.h for bpf to work (noticed by weissmanndude). put some non-fatal printfs into ifdef debug
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.20 2003/01/27 20:03:35 jason Exp $	*/
d1530 1
a1530 1
	/* The receice frame descriptors */
@


1.20
log
@pad tx buffer on < minimum length frames; based on NetBSD; tested on hppa.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.19 2003/01/07 08:25:23 mickey Exp $	*/
d144 2
d385 7
a391 3
	printf("i82596_cmd_wait: timo(%ssync): scb status: %b\n",
	    sc->async_cmd_inprogress?"a":"",
	    sc->ie_bus_read16(sc, IE_SCB_STATUS(sc->scb)), IE_STAT_BITS);
a577 1

d1129 1
a1129 2
	if (ifp->if_bpf) {
		/* Pass it up. */
a1130 1
	}
d1210 8
a1217 3
		if (i82596_start_cmd(sc, IE_CUC_START, 0, 0, 1))
			printf("%s: i82596_xmit: start xmit command timed out\n",
			       sc->sc_dev.dv_xname);
d1373 1
d1376 1
d1385 2
a1386 1
	if (i82596_start_cmd(sc, IE_RUC_ABORT | IE_CUC_ABORT, 0, 0, 0))
d1388 2
@


1.19
log
@do the busy wait loops my favourite style and merry xmas
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.18 2002/12/19 01:25:21 mickey Exp $	*/
d178 2
d325 10
d1288 8
a1300 1
		len = max(m0->m_pkthdr.len, ETHER_MIN_LEN);
@


1.18
log
@fix a debugging printf on cmd wait timeout
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.17 2002/12/11 19:35:51 mickey Exp $	*/
d356 1
a356 1
	for (i = 0; i < 180000; i++) {
a368 1
		DELAY(5);
d430 1
a430 1
		for (i = 0; i < 73800; i++) {
d434 1
a434 1
					  BUS_SPACE_BARRIER_READ);
a444 1
			DELAY(5);
@


1.17
log
@smaller delays, unneeded spls
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.16 2002/11/01 19:56:13 mickey Exp $	*/
d362 1
a362 1
#ifdef I82596_DEBUG1
d365 1
a365 1
				    sc->sc_dev.dv_xname, (90000 - i) * 10);
@


1.16
log
@fight the grammar in the tdr messages
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.15 2002/10/30 20:21:41 mickey Exp $	*/
d354 1
a354 1
	register int i, off;
d356 1
a356 1
	for (i = 0; i < 90000; i++) {
d369 1
a369 1
		delay(10);
d396 1
a396 1
	register int i, off;
d431 1
a431 1
		for (i = 0; i < 36900; i++) {
d446 1
a446 1
			delay(10);
a511 3
#if 0
	ie_ack(sc, status & IE_ST_WHENCE);
#endif
a624 1

a1216 1
	int	s;
a1296 1
		s = splnet();
d1298 1
a1298 1
		if (sc->xmit_busy == 0)
a1299 3

		sc->xmit_busy++;
		splx(s);
d1328 1
a1328 1
	delay(100);		/* wait a while... */
d1369 1
a1369 1
	delay(100);
@


1.15
log
@bring on a few changes from netbsd, such as better rx mbuf calculation, ram probe fix in byte vs word, M_IFMADDR vs M_IPMADDR. some knf
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.14 2002/10/13 14:21:49 mickey Exp $	*/
d1414 1
a1414 1
	int result;
d1431 1
d1437 2
a1438 2
		printf("%s: TDR detected an open %d clocks away\n",
			sc->sc_dev.dv_xname, result & IE_TDR_TIME);
d1440 2
a1441 2
		printf("%s: TDR detected a short %d clocks away\n",
			sc->sc_dev.dv_xname, result & IE_TDR_TIME);
d1444 1
a1444 1
			sc->sc_dev.dv_xname, result);
a1445 1

@


1.14
log
@do not flush cache here, better support for intrhook, increase number of transmit cmds and properly align the rings
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.13 2002/10/09 23:43:11 krw Exp $	*/
a146 2
#include <sys/buf.h>
#include <sys/protosw.h>
d241 1
a241 1
		printf ("%s: ISCP set failed\n", sc->sc_dev.dv_xname);
a253 6

#ifdef I82596_DEBUG
		printf ("%s: test %x:%x\n", sc->sc_dev.dv_xname,
			*((volatile int32_t *)(sc->bh + sc->scp)),
			*(int32_t *)(sc->bh + IE_SCP_TEST(sc->scp)));
#endif
d364 2
a365 2
				printf ("%s: cmd_wait after %d usec\n",
					sc->sc_dev.dv_xname, (90000 - i) * 10);
d372 3
a374 3
	printf ("i82596_cmd_wait: timo(%ssync): scb status: %b\n",
		sc->async_cmd_inprogress?"a":"",
		sc->ie_bus_read16(sc, off), IE_STAT_BITS);
d440 3
a442 3
					printf ("%s: cmd status %b\n",
						sc->sc_dev.dv_xname,
						status, IE_STAT_BITS);
d544 3
d549 1
a549 1
		goto out;
d970 1
a970 1
	struct mbuf *top, **mp, *m;
d983 2
a984 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
d986 2
a987 2
	m->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
	m->m_pkthdr.len = totlen;
d989 1
a989 2
	top = 0;
	mp = &top;
a995 8
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return (0);
			}
			len = MLEN;
		}
d998 2
a999 4
			if ((m->m_flags & M_EXT) == 0) {
				m_freem(top);
				return (0);
			}
d1002 2
a1003 1
		if (mp == &top) {
d1010 1
d1012 1
d1014 7
a1020 2
		*mp = m;
		mp = &m->m_next;
d1023 1
a1023 1
	m = top;
d1067 5
a1071 1
	return (top);
d1225 1
a1225 1
		printf ("i82596_start(%p)\n", ifp);
d1324 2
a1325 2
	bus_space_write_1(sc->bt, sc->bh, off, 0);
	bus_space_barrier(sc->bt, sc->bh, off, 1, BUS_SPACE_BARRIER_WRITE);
d1329 2
a1330 2
	bus_space_write_1(sc->bt, sc->bh, off, 1);
	bus_space_barrier(sc->bt, sc->bh, off, 1, BUS_SPACE_BARRIER_WRITE);
d1342 1
a1342 1
	result = bus_space_read_1(sc->bt, sc->bh, off) == 0;
d1974 1
a1974 1
			free(sc->mcast_addrs, M_IPMADDR);
d1976 1
a1976 1
			malloc(size, M_IPMADDR, M_WAITOK);
@


1.13
log
@Remove trailing '\n's from panic messages.

Started by a commit to siop from provos@@netbsd.org.

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.12 2002/09/23 06:11:50 mickey Exp $	*/
a179 9
/* So far only hppa, but in case other archs */
#ifdef MD_CACHE_CTL
#define	FLUSH(addr,size)	MD_CACHE_CTL((vaddr_t)addr,size,MD_CACHE_FLUSH)
#define	PURGE(addr,size)	MD_CACHE_CTL((vaddr_t)addr,size,MD_CACHE_PURGE)
#else
#define	FLUSH(addr,size)
#define	PURGE(addr,size)
#endif

a238 1
	FLUSH(sc->sc_maddr, sc->sc_msize);
a240 1
	PURGE(sc->sc_maddr, sc->sc_msize);
a250 1
		FLUSH(sc->sc_maddr, sc->sc_msize);
d255 1
a255 1
			PURGE(sc->sc_maddr, sc->sc_msize);
a304 1
	FLUSH(sc->sc_maddr, sc->sc_msize);
a305 1
	PURGE(sc->sc_maddr, sc->sc_msize);
a368 1
		PURGE(sc->sc_maddr, sc->sc_msize);
a382 1
	PURGE(sc->sc_maddr, sc->sc_msize);
a422 1
	FLUSH(sc->bh + off, 2);
a441 1
			PURGE(sc->bh + off, 2);
a486 1
	FLUSH(sc->bh + sc->scb, IE_SCB_SZ);
a507 1
	PURGE(sc->bh + off, 2);
a555 1
	PURGE(sc->bh + off, 2);
a594 1
		PURGE(sc->bh + off, 2);
a640 1
		PURGE(sc->bh + off, 2);
a652 1
		PURGE(sc->bh + off, 2);
a754 1
	PURGE(sc->bh + off, 2);
a837 1
		PURGE(sc->bh + off, 2);
a887 1
	FLUSH(sc->bh + off, 2);
a891 1
	FLUSH(sc->bh + off, 2);
a935 1
		PURGE(sc->bh + off, 2);
a949 1
		PURGE(sc->bh + off, 2);
a1054 1
		PURGE(sc->bh + off, len);
d1467 1
a1467 1
	int cl = 16;
d1504 1
a1504 1
	r = 48 + ((32 + IE_RBUF_SIZE) * B_PER_F);
d1508 1
a1508 1
	if (sc->nframes <= 0)
d1516 1
a1516 1
	ptr += sc->nframes * 48;
@


1.12
log
@make the leds blink (on those machines where we have 'em).
simple logic is to light up the led in the intrhook and dim in the
heartbeat always, makes a believable impression.
upper four bits represent a cpu usage w/in the last Hz/8
made up from the cp_time[] times.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.11 2002/07/31 02:32:25 mickey Exp $	*/
d1540 1
a1540 1
		panic("ie: bogus buffer calc\n");
@


1.11
log
@mop up after federico who is not capable of comitting the same diffs he sents for testing or compiling code before he commits it even
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.10 2002/07/29 23:41:24 fgsch Exp $	*/
a525 6
        /*
         * Implementation dependent interrupt handling.
         */
	if (sc->intrhook)
		(sc->intrhook)(sc, IE_INTR_ENTER);

d545 4
a548 1
	if (status & (IE_ST_FR | IE_ST_RNR))
d551 5
a556 1
	if (status & IE_ST_CX)
d559 1
@


1.10
log
@switch to ether_input_mbuf(); mickey@@ tested and ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.9 2002/03/14 01:26:54 millert Exp $	*/
d1046 1
a1046 1
		if (mp == top) {
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.8 2002/03/08 08:49:42 mickey Exp $	*/
d1001 1
a1001 1
i82596_get(struct ie_softc *sc, struct ether_header *ehp, int head, int totlen)
d1006 1
d1011 2
a1012 1
	(sc->memcopyin)(sc, ehp, IE_RBUF_ADDR(sc,head), sizeof *ehp);
d1014 1
a1014 1
	resid = totlen -= (thisrboff = sizeof *ehp);
d1046 7
d1063 8
a1122 1
	struct ether_header eh;
d1131 1
a1131 1
	m = i82596_get(sc, &eh, bstart, pktlen);
d1140 3
a1142 1
	if (sc->sc_debug & IED_READFRAME)
d1144 3
a1146 3
		       sc->sc_dev.dv_xname,
		       ether_sprintf(eh.ether_shost),
		       (u_int)eh.ether_type, pktlen);
d1150 1
a1150 8
	/*
	 * Check for a BPF filter; if so, hand it up.
	 * Note that we have to stick an extra mbuf up front, because bpf_mtap
	 * expects to have the ether header at the front.
	 * It doesn't matter that this results in an ill-formatted mbuf chain,
	 * since BPF just looks at the data.  (It doesn't try to free the mbuf,
	 * tho' it will make a copy for tcpdump.)
	 */
a1151 5
		struct mbuf m0;
		m0.m_len = sizeof eh;
		m0.m_data = (caddr_t)&eh;
		m0.m_next = m;

d1153 1
a1153 2
		bpf_mtap(ifp->if_bpf, &m0);

d1160 1
a1160 1
	ether_input(ifp, &eh, m);
@


1.8
log
@do not add maddr twice, break out of the loop if cmd post fails
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.7 2001/11/06 19:53:18 miod Exp $	*/
d189 31
a219 31
void	i82596_reset 	__P((struct ie_softc *, int));
void	i82596_watchdog	__P((struct ifnet *));
int	i82596_init 	__P((struct ie_softc *));
int	i82596_ioctl 	__P((struct ifnet *, u_long, caddr_t));
void	i82596_start 	__P((struct ifnet *));

int	i82596_rint 	__P((struct ie_softc *, int));
int	i82596_tint 	__P((struct ie_softc *, int));

int   	i82596_mediachange 	__P((struct ifnet *));
void  	i82596_mediastatus 	__P((struct ifnet *, struct ifmediareq *));

int 	i82596_readframe	__P((struct ie_softc *, int));
int	i82596_get_rbd_list	__P((struct ie_softc *,
					     u_int16_t *, u_int16_t *, int *));
void	i82596_release_rbd_list	__P((struct ie_softc *, u_int16_t, u_int16_t));
int	i82596_drop_frames	__P((struct ie_softc *));
int	i82596_chk_rx_ring	__P((struct ie_softc *));

void	i82596_start_transceiver __P((struct ie_softc *));
void	i82596_stop 		__P((struct ie_softc *));
void 	i82596_xmit 		__P((struct ie_softc *));

void 	i82596_setup_bufs	__P((struct ie_softc *));
void	i82596_simple_command	__P((struct ie_softc *, int, int));
int 	ie_cfg_setup		__P((struct ie_softc *, int, int, int));
int	ie_ia_setup		__P((struct ie_softc *, int));
void 	ie_run_tdr		__P((struct ie_softc *, int));
int 	ie_mc_setup 		__P((struct ie_softc *, int));
void 	ie_mc_reset 		__P((struct ie_softc *));
int	i82596_cmd_wait		__P((struct ie_softc *));
d222 1
a222 1
void 	print_rbd	__P((struct ie_softc *, int));
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.6 2001/06/27 06:34:42 kjc Exp $	*/
d260 1
a260 1
		(sc->ie_bus_write24)(sc, sc->sc_maddr + sc->scp, 0);
d571 2
a572 1
	i82596_cmd_wait(sc);
d786 1
a786 1
	if ((status & IE_STAT_COMPL) == 0 || (status & IE_STAT_BUSY)) {
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.7 2001/11/06 19:53:18 miod Exp $	*/
d189 31
a219 31
void	i82596_reset(struct ie_softc *, int);
void	i82596_watchdog(struct ifnet *);
int	i82596_init(struct ie_softc *);
int	i82596_ioctl(struct ifnet *, u_long, caddr_t);
void	i82596_start(struct ifnet *);

int	i82596_rint(struct ie_softc *, int);
int	i82596_tint(struct ie_softc *, int);

int   	i82596_mediachange(struct ifnet *);
void  	i82596_mediastatus(struct ifnet *, struct ifmediareq *);

int 	i82596_readframe(struct ie_softc *, int);
int	i82596_get_rbd_list(struct ie_softc *,
					     u_int16_t *, u_int16_t *, int *);
void	i82596_release_rbd_list(struct ie_softc *, u_int16_t, u_int16_t);
int	i82596_drop_frames(struct ie_softc *);
int	i82596_chk_rx_ring(struct ie_softc *);

void	i82596_start_transceiver(struct ie_softc *);
void	i82596_stop(struct ie_softc *);
void 	i82596_xmit(struct ie_softc *);

void 	i82596_setup_bufs(struct ie_softc *);
void	i82596_simple_command(struct ie_softc *, int, int);
int 	ie_cfg_setup(struct ie_softc *, int, int, int);
int	ie_ia_setup(struct ie_softc *, int);
void 	ie_run_tdr(struct ie_softc *, int);
int 	ie_mc_setup(struct ie_softc *, int);
void 	ie_mc_reset(struct ie_softc *);
int	i82596_cmd_wait(struct ie_softc *);
d222 1
a222 1
void 	print_rbd(struct ie_softc *, int);
d260 1
a260 1
		(sc->ie_bus_write24)(sc, sc->scp, 0);
d571 1
a571 2
	if (i82596_cmd_wait(sc))
		goto out;
d785 1
a785 1
	if ((status & (IE_STAT_COMPL|IE_STAT_BUSY)) == IE_STAT_BUSY) {
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.7.2.1 2002/06/11 03:42:18 art Exp $	*/
d180 9
d248 1
d251 1
d262 1
d267 1
a267 1
			;
d317 1
d319 1
d383 1
d398 1
d439 1
d459 1
d505 1
d526 6
d533 1
d551 1
a551 4
	if (status & (IE_ST_FR | IE_ST_RNR)) {
		if (sc->intrhook)
			(sc->intrhook)(sc, IE_INTR_ENRCV);

a553 5
	}

	if (status & IE_ST_CX) {
		if (sc->intrhook)
			(sc->intrhook)(sc, IE_INTR_ENSND);
d555 1
a557 1
	}
d574 1
d614 1
d661 1
d674 1
d777 1
d861 1
d912 1
d917 1
d962 1
d977 1
d1001 1
a1001 1
i82596_get(struct ie_softc *sc, int head, int totlen)
a1005 1
	struct ether_header eh;
d1010 1
a1010 2
	(sc->memcopyin)(sc, &eh, IE_RBUF_ADDR(sc, head),
	    sizeof(struct ether_header));
d1012 1
a1012 1
	resid = totlen;
a1043 7
		if (mp == &top) {
			caddr_t newdata = (caddr_t)
			    ALIGN(m->m_data + sizeof(struct ether_header)) -
			    sizeof(struct ether_header);
			len -= newdata - m->m_data;
			m->m_data = newdata;
		}
a1053 8
	 * Copy the Ethernet header into the mbuf chain.
	 */
	bcopy(&eh, mtod(m, caddr_t), sizeof(struct ether_header));
	thismboff = sizeof(struct ether_header);
	thisrboff = sizeof(struct ether_header);
	resid -= sizeof(struct ether_header);

	/*
d1066 1
d1106 1
d1115 1
a1115 1
	m = i82596_get(sc, bstart, pktlen);
d1124 1
a1124 3
	if (sc->sc_debug & IED_READFRAME) {
		struct ether_header *eh = mtod(m, struct ether_header *);

d1126 3
a1128 3
		    sc->sc_dev.dv_xname, ether_sprintf(eh->ether_shost),
		    (u_int)eh->ether_type, pktlen);
	}
d1132 8
a1139 1
	/* Check for a BPF filter; if so, hand it up. */
d1141 5
d1147 2
a1148 1
		bpf_mtap(ifp->if_bpf, m);
d1155 1
a1155 1
	ether_input_mbuf(ifp, m);
d1491 1
a1491 1
	int cl = 32;
d1528 1
a1528 1
	r = 64 + ((32 + IE_RBUF_SIZE) * B_PER_F);
d1532 2
a1533 2
	if (sc->nframes <= 8)
		panic("ie: bogus buffer calc");
d1540 1
a1540 1
	ptr += sc->nframes * 64;
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d147 2
a179 2
static	char *padbuf;

d243 1
a243 1
		printf("%s: ISCP set failed\n", sc->sc_dev.dv_xname);
d256 6
a330 10
	if (padbuf == NULL) {
		padbuf = malloc(ETHER_MIN_LEN - ETHER_CRC_LEN, M_DEVBUF,
		    M_NOWAIT);
		if (padbuf == NULL) {
			printf("%s: can't allocate pad buffer\n");
			return;
		}
		bzero(padbuf, ETHER_MIN_LEN - ETHER_CRC_LEN);
	}

d362 1
a362 1
	int i, off;
d364 1
a364 1
	for (i = 180000; i--; DELAY(5)) {
d370 1
a370 1
#ifdef I82596_DEBUG
d372 2
a373 2
				printf("%s: cmd_wait after %d usec\n",
				    sc->sc_dev.dv_xname, (180000 - i) * 5);
d377 1
d380 3
a382 3
	printf("i82596_cmd_wait: timo(%ssync): scb status: %b\n",
	    sc->async_cmd_inprogress?"a":"",
	    sc->ie_bus_read16(sc, IE_SCB_STATUS(sc->scb)), IE_STAT_BITS);
d404 1
a404 1
	int i, off;
d439 1
a439 1
		for (i = 73800; i--; DELAY(5)) {
d443 1
a443 1
			    BUS_SPACE_BARRIER_READ);
d448 3
a450 3
					printf("%s: cmd status %b\n",
					    sc->sc_dev.dv_xname,
					    status, IE_STAT_BITS);
d454 1
d520 3
a551 3
	 *
	 * If ACK fails, try to reset the chip, in hopes that
	 * it helps.
d554 1
a554 1
		goto reset;
d633 1
d975 1
a975 1
	struct mbuf *m, *m0, *newm;
d988 2
a989 2
	MGETHDR(m0, M_DONTWAIT, MT_DATA);
	if (m0 == 0)
d991 2
a992 2
	m0->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
	m0->m_pkthdr.len = totlen;
d994 2
a995 1
	m = m0;
d1002 8
d1012 4
a1015 2
			if ((m->m_flags & M_EXT) == 0)
				goto bad;
d1018 1
a1018 2

		if (m == m0) {
a1024 1

a1025 1

d1027 2
a1028 7
		if (totlen > 0) {
			MGET(newm, M_DONTWAIT, MT_DATA);
			if (newm == 0)
				goto bad;
			len = MLEN;
			m = m->m_next = newm;
		}
d1031 1
a1031 1
	m = m0;
d1075 1
a1075 5
	return (m0);

bad:
	m_freem(m0);
	return (NULL);
d1225 1
d1229 1
a1229 1
		printf("i82596_start(%p)\n", ifp);
a1286 8
		len = m0->m_pkthdr.len;
		if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
			(sc->memcopyout)(sc, padbuf, buffer,
			    ETHER_MIN_LEN - ETHER_CRC_LEN - len);
			buffer += ETHER_MIN_LEN - ETHER_CRC_LEN - len;
			len = ETHER_MIN_LEN - ETHER_CRC_LEN;
		}

d1292 1
d1306 1
d1308 1
a1308 1
		if (sc->xmit_busy++ == 0)
d1310 3
d1328 2
a1329 2
	(sc->ie_bus_write16)(sc, off, 0);
	bus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);
d1333 2
a1334 2
	(sc->ie_bus_write16)(sc, off, 1);
	bus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);
d1341 1
a1341 1
	DELAY(100);		/* wait a while... */
d1346 1
a1346 1
	result = (sc->ie_bus_read16)(sc, off) == 0;
d1382 1
a1382 1
	DELAY(100);
d1418 1
a1418 1
	int result, clocks;
a1434 1
	clocks = result & IE_TDR_TIME;
d1440 2
a1441 2
		printf("%s: TDR detected an open %d clock%s away\n",
		    sc->sc_dev.dv_xname, clocks, clocks == 1? "":"s");
d1443 2
a1444 2
		printf("%s: TDR detected a short %d clock%s away\n",
		    sc->sc_dev.dv_xname, clocks, clocks == 1? "":"s");
d1447 1
a1447 1
		    sc->sc_dev.dv_xname, result);
d1450 1
d1978 1
a1978 1
			free(sc->mcast_addrs, M_IFMADDR);
d1980 1
a1980 1
			malloc(size, M_IFMADDR, M_WAITOK);
@


1.6
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.5 2001/03/23 00:16:49 mickey Exp $	*/
d173 1
a173 1
#include <vm/vm.h>
@


1.5
log
@cache alignment games
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.4 2001/02/20 19:39:37 mickey Exp $	*/
d332 1
d1264 1
a1264 1
		IF_DEQUEUE(&ifp->if_snd, m0);
@


1.4
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.3 2001/01/12 22:56:03 mickey Exp $	*/
a1262 3
		head = sc->xchead;
		xbase = sc->xbds;

d1277 7
d1286 2
a1287 2
			printf("%s: fill buffer %d\n", sc->sc_dev.dv_xname,
				sc->xchead);
a1289 4
		if (m0->m_pkthdr.len > IE_TBUF_SIZE)
			printf("%s: tbuf overflow\n", sc->sc_dev.dv_xname);

		buffer = IE_XBUF_ADDR(sc, head);
d1291 14
d1309 5
d1321 1
a1327 4
		if (++head == NTXBUF)
			head = 0;
		sc->xchead = head;

d1488 2
a1489 1
	register int n, r, ptr = sc->buf_area;	/* memory pool */
d1495 1
a1495 2
	ptr = (ptr + 3) & ~3;	/* set alignment and stick with it */

d1502 3
a1504 2
	sc->nop_cmds = ptr;
	ptr += NTXBUF * IE_CMD_NOP_SZ;
d1507 3
a1509 2
	sc->xmit_cmds = ptr;
	ptr += NTXBUF * IE_CMD_XMIT_SZ;
d1512 3
a1514 2
	sc->xbds = ptr;
	ptr += NTXBUF * IE_XBD_SZ;
d1520 1
a1520 1
	ptr = (ptr + 3) & ~3;		/* re-align.. just in case */
d1526 1
a1526 1
	r = IE_RFRAME_SZ + ((IE_RBD_SZ + IE_RBUF_SIZE) * B_PER_F);
d1536 3
a1538 2
	sc->rframes = ptr;
	ptr += sc->nframes * IE_RFRAME_SZ;
d1541 3
a1543 2
	sc->rbds = ptr;
	ptr += sc->nrxbuf * IE_RBD_SZ;
@


1.3
log
@this is an ugly quick hack, but it works; theo helped (;
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.2 1999/11/26 17:45:57 mickey Exp $	*/
a349 4

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.2
log
@provide general "probing" routine, also used in isa cards memory sizing;
also utilize port commands (if provided by the md backend);
prefix macros w/ IE_;
build control structures here, providing sysbus byte in the softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.1 1999/08/15 23:49:30 mickey Exp $	*/
d173 2
d180 9
d248 1
a249 2
	(sc->chan_attn)(sc);
	DELAY(1000);
d251 1
d260 1
d262 1
d266 2
a267 1
		     DELAY(100));
a272 1

d317 1
d319 1
d386 1
d401 1
d442 1
d462 1
d508 1
d536 1
d576 1
d616 1
d663 1
d676 1
d762 1
a762 1
	register int status;
d777 3
a779 2
	status = sc->ie_bus_read16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds,
							  sc->xctail));
d863 1
d914 1
d919 1
d964 1
d979 1
d1006 1
a1006 1
	int len, resid;
d1065 2
a1066 3
		(sc->memcopyin)(sc, mtod(m, caddr_t) + thismboff,
				IE_RBUF_ADDR(sc,head) + thisrboff,
				(u_int)len);
d1068 1
@


1.2.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.5 2001/03/23 00:16:49 mickey Exp $	*/
a172 2
#include <vm/vm.h>

a177 9
/* So far only hppa, but in case other archs */
#ifdef MD_CACHE_CTL
#define	FLUSH(addr,size)	MD_CACHE_CTL((vaddr_t)addr,size,MD_CACHE_FLUSH)
#define	PURGE(addr,size)	MD_CACHE_CTL((vaddr_t)addr,size,MD_CACHE_PURGE)
#else
#define	FLUSH(addr,size)
#define	PURGE(addr,size)
#endif

a236 1
	FLUSH(sc->sc_maddr, sc->sc_msize);
d238 2
a240 1
	PURGE(sc->sc_maddr, sc->sc_msize);
a248 1
		(sc->ie_bus_write24)(sc, sc->sc_maddr + sc->scp, 0);
a249 1
		FLUSH(sc->sc_maddr, sc->sc_msize);
d253 1
a253 2
		     DELAY(100))
			PURGE(sc->sc_maddr, sc->sc_msize);
d259 1
a303 1
	FLUSH(sc->sc_maddr, sc->sc_msize);
a304 1
	PURGE(sc->sc_maddr, sc->sc_msize);
d335 4
a370 1
		PURGE(sc->sc_maddr, sc->sc_msize);
a384 1
	PURGE(sc->sc_maddr, sc->sc_msize);
a424 1
	FLUSH(sc->bh + off, 2);
a443 1
			PURGE(sc->bh + off, 2);
a488 1
	FLUSH(sc->bh + sc->scb, IE_SCB_SZ);
a515 1
	PURGE(sc->bh + off, 2);
a554 1
	PURGE(sc->bh + off, 2);
a593 1
		PURGE(sc->bh + off, 2);
a639 1
		PURGE(sc->bh + off, 2);
a651 1
		PURGE(sc->bh + off, 2);
d737 1
a737 1
	register int off, status;
d752 2
a753 3
	off = IE_CMD_XMIT_STATUS(sc->xmit_cmds, sc->xctail);
	status = sc->ie_bus_read16(sc, off);
	PURGE(sc->bh + off, 2);
a836 1
		PURGE(sc->bh + off, 2);
a886 1
	FLUSH(sc->bh + off, 2);
a890 1
	FLUSH(sc->bh + off, 2);
a934 1
		PURGE(sc->bh + off, 2);
a948 1
		PURGE(sc->bh + off, 2);
d975 1
a975 1
	int off, len, resid;
d1034 3
a1036 2
		off = IE_RBUF_ADDR(sc,head) + thisrboff;
		(sc->memcopyin)(sc, mtod(m, caddr_t) + thismboff, off, len);
a1037 1
		PURGE(sc->bh + off, len);
d1236 3
d1253 6
a1261 2
		head = sc->xchead;
		sc->xchead = (head + 1) % NTXBUF;
a1262 7

#ifdef I82596_DEBUG
		if (sc->sc_debug & IED_ENQ)
			printf("%s: fill buffer %d offset %x",
			    sc->sc_dev.dv_xname, head, buffer);
#endif

a1263 14
#ifdef I82596_DEBUG
			if (sc->sc_debug & IED_ENQ) {
				u_int8_t *e, *p = mtod(m, u_int8_t *);
				static int i;
				if (m == m0)
					i = 0;
				for (e = p + m->m_len; p < e; i++, p += 2) {
					if (!(i % 8))
						printf("\n%s:",
						    sc->sc_dev.dv_xname);
					printf(" %02x%02x", p[0], p[1]);
				}
			}
#endif
a1267 5
#ifdef I82596_DEBUG
		if (sc->sc_debug & IED_ENQ)
			printf("\n");
#endif

a1274 1
		xbase = sc->xbds;
d1281 4
d1445 1
a1445 2
	int n, r, ptr = sc->buf_area;	/* memory pool */
	int cl = 16;
d1451 2
a1452 1
	ptr = (ptr + cl - 1) & ~(cl - 1); /* set alignment and stick with it */
d1459 2
a1460 3
	ptr += cl;
	sc->nop_cmds = ptr - 2;
	ptr += NTXBUF * 32;
d1463 2
a1464 3
	ptr += cl;
	sc->xmit_cmds = ptr - 2;
	ptr += NTXBUF * 32;
d1467 2
a1468 3
	ptr += cl;
	sc->xbds = ptr - 2;
	ptr += NTXBUF * 32;
d1474 1
a1474 1
	ptr = (ptr + cl - 1) & ~(cl - 1);	/* re-align.. just in case */
d1480 1
a1480 1
	r = 48 + ((32 + IE_RBUF_SIZE) * B_PER_F);
d1490 2
a1491 3
	ptr += cl;
	sc->rframes = ptr - 2;
	ptr += sc->nframes * 48;
d1494 2
a1495 3
	ptr += cl;
	sc->rbds = ptr - 2;
	ptr += sc->nrxbuf * 32;
@


1.2.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82596.c,v 1.2.2.1 2001/05/14 22:23:49 niklas Exp $	*/
a331 1
	IFQ_SET_READY(&ifp->if_snd);
d1263 1
a1263 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.2.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d173 1
a173 1
#include <uvm/uvm_extern.h>
@


1.2.2.4
log
@Merge in -current from about a week ago
@
text
@d189 31
a219 31
void	i82596_reset(struct ie_softc *, int);
void	i82596_watchdog(struct ifnet *);
int	i82596_init(struct ie_softc *);
int	i82596_ioctl(struct ifnet *, u_long, caddr_t);
void	i82596_start(struct ifnet *);

int	i82596_rint(struct ie_softc *, int);
int	i82596_tint(struct ie_softc *, int);

int   	i82596_mediachange(struct ifnet *);
void  	i82596_mediastatus(struct ifnet *, struct ifmediareq *);

int 	i82596_readframe(struct ie_softc *, int);
int	i82596_get_rbd_list(struct ie_softc *,
					     u_int16_t *, u_int16_t *, int *);
void	i82596_release_rbd_list(struct ie_softc *, u_int16_t, u_int16_t);
int	i82596_drop_frames(struct ie_softc *);
int	i82596_chk_rx_ring(struct ie_softc *);

void	i82596_start_transceiver(struct ie_softc *);
void	i82596_stop(struct ie_softc *);
void 	i82596_xmit(struct ie_softc *);

void 	i82596_setup_bufs(struct ie_softc *);
void	i82596_simple_command(struct ie_softc *, int, int);
int 	ie_cfg_setup(struct ie_softc *, int, int, int);
int	ie_ia_setup(struct ie_softc *, int);
void 	ie_run_tdr(struct ie_softc *, int);
int 	ie_mc_setup(struct ie_softc *, int);
void 	ie_mc_reset(struct ie_softc *);
int	i82596_cmd_wait(struct ie_softc *);
d222 1
a222 1
void 	print_rbd(struct ie_softc *, int);
d260 1
a260 1
		(sc->ie_bus_write24)(sc, sc->scp, 0);
d571 1
a571 2
	if (i82596_cmd_wait(sc))
		goto out;
d785 1
a785 1
	if ((status & (IE_STAT_COMPL|IE_STAT_BUSY)) == IE_STAT_BUSY) {
@


1.2.2.5
log
@Sync the SMP branch with 3.3
@
text
@d147 2
d180 8
a187 1
static	char *padbuf;
d248 1
d251 1
d254 1
a254 1
		printf("%s: ISCP set failed\n", sc->sc_dev.dv_xname);
d262 1
d267 7
a273 1
			;
d317 1
d319 1
a344 10
	if (padbuf == NULL) {
		padbuf = malloc(ETHER_MIN_LEN - ETHER_CRC_LEN, M_DEVBUF,
		    M_NOWAIT);
		if (padbuf == NULL) {
			printf("%s: can't allocate pad buffer\n");
			return;
		}
		bzero(padbuf, ETHER_MIN_LEN - ETHER_CRC_LEN);
	}

d376 1
a376 1
	int i, off;
d378 1
a378 1
	for (i = 180000; i--; DELAY(5)) {
d383 1
d385 1
a385 1
#ifdef I82596_DEBUG
d387 2
a388 2
				printf("%s: cmd_wait after %d usec\n",
				    sc->sc_dev.dv_xname, (180000 - i) * 5);
d392 1
d395 4
a398 3
	printf("i82596_cmd_wait: timo(%ssync): scb status: %b\n",
	    sc->async_cmd_inprogress?"a":"",
	    sc->ie_bus_read16(sc, IE_SCB_STATUS(sc->scb)), IE_STAT_BITS);
d420 1
a420 1
	int i, off;
d439 1
d456 1
a456 1
		for (i = 73800; i--; DELAY(5)) {
d459 1
d461 1
a461 1
			    BUS_SPACE_BARRIER_READ);
d466 3
a468 3
					printf("%s: cmd status %b\n",
					    sc->sc_dev.dv_xname,
					    status, IE_STAT_BITS);
d472 1
d505 1
d526 6
d533 1
d546 3
d551 1
a551 4
	if (status & (IE_ST_FR | IE_ST_RNR)) {
		if (sc->intrhook)
			(sc->intrhook)(sc, IE_INTR_ENRCV);

a553 5
	}

	if (status & IE_ST_CX) {
		if (sc->intrhook)
			(sc->intrhook)(sc, IE_INTR_ENSND);
d555 1
a557 1
	}
a569 3
	 *
	 * If ACK fails, try to reset the chip, in hopes that
	 * it helps.
d572 1
a572 1
		goto reset;
d574 1
d614 1
d653 1
d661 1
d674 1
d777 1
d861 1
d912 1
d917 1
d962 1
d977 1
d1001 1
a1001 1
i82596_get(struct ie_softc *sc, int head, int totlen)
d1003 1
a1003 1
	struct mbuf *m, *m0, *newm;
a1005 1
	struct ether_header eh;
d1010 1
a1010 2
	(sc->memcopyin)(sc, &eh, IE_RBUF_ADDR(sc, head),
	    sizeof(struct ether_header));
d1012 1
a1012 1
	resid = totlen;
d1014 2
a1015 2
	MGETHDR(m0, M_DONTWAIT, MT_DATA);
	if (m0 == 0)
d1017 2
a1018 2
	m0->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
	m0->m_pkthdr.len = totlen;
d1020 2
a1021 1
	m = m0;
d1028 8
d1038 4
a1041 2
			if ((m->m_flags & M_EXT) == 0)
				goto bad;
a1043 9

		if (m == m0) {
			caddr_t newdata = (caddr_t)
			    ALIGN(m->m_data + sizeof(struct ether_header)) -
			    sizeof(struct ether_header);
			len -= newdata - m->m_data;
			m->m_data = newdata;
		}

a1044 1

d1046 2
a1047 7
		if (totlen > 0) {
			MGET(newm, M_DONTWAIT, MT_DATA);
			if (newm == 0)
				goto bad;
			len = MLEN;
			m = m->m_next = newm;
		}
d1050 1
a1050 1
	m = m0;
a1053 8
	 * Copy the Ethernet header into the mbuf chain.
	 */
	bcopy(&eh, mtod(m, caddr_t), sizeof(struct ether_header));
	thismboff = sizeof(struct ether_header);
	thisrboff = sizeof(struct ether_header);
	resid -= sizeof(struct ether_header);

	/*
d1066 1
d1087 1
a1087 5
	return (m0);

bad:
	m_freem(m0);
	return (NULL);
d1106 1
d1115 1
a1115 1
	m = i82596_get(sc, bstart, pktlen);
d1124 1
a1124 3
	if (sc->sc_debug & IED_READFRAME) {
		struct ether_header *eh = mtod(m, struct ether_header *);

d1126 3
a1128 3
		    sc->sc_dev.dv_xname, ether_sprintf(eh->ether_shost),
		    (u_int)eh->ether_type, pktlen);
	}
d1132 8
a1139 1
	/* Check for a BPF filter; if so, hand it up. */
d1141 5
d1147 2
a1148 1
		bpf_mtap(ifp->if_bpf, m);
d1155 1
a1155 1
	ether_input_mbuf(ifp, m);
d1249 1
d1253 1
a1253 1
		printf("i82596_start(%p)\n", ifp);
a1310 8
		len = m0->m_pkthdr.len;
		if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
			(sc->memcopyout)(sc, padbuf, buffer,
			    ETHER_MIN_LEN - ETHER_CRC_LEN - len);
			buffer += ETHER_MIN_LEN - ETHER_CRC_LEN - len;
			len = ETHER_MIN_LEN - ETHER_CRC_LEN;
		}

d1316 1
d1330 1
d1332 1
a1332 1
		if (sc->xmit_busy++ == 0)
d1334 3
d1352 2
a1353 2
	(sc->ie_bus_write16)(sc, off, 0);
	bus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);
d1357 2
a1358 2
	(sc->ie_bus_write16)(sc, off, 1);
	bus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);
d1365 1
a1365 1
	DELAY(100);		/* wait a while... */
d1370 1
a1370 1
	result = (sc->ie_bus_read16)(sc, off) == 0;
d1406 1
a1406 1
	DELAY(100);
d1442 1
a1442 1
	int result, clocks;
a1458 1
	clocks = result & IE_TDR_TIME;
d1464 2
a1465 2
		printf("%s: TDR detected an open %d clock%s away\n",
		    sc->sc_dev.dv_xname, clocks, clocks == 1? "":"s");
d1467 2
a1468 2
		printf("%s: TDR detected a short %d clock%s away\n",
		    sc->sc_dev.dv_xname, clocks, clocks == 1? "":"s");
d1471 1
a1471 1
		    sc->sc_dev.dv_xname, result);
d1474 1
d1491 1
a1491 1
	int cl = 32;
d1528 1
a1528 1
	r = 64 + ((32 + IE_RBUF_SIZE) * B_PER_F);
d1532 2
a1533 2
	if (sc->nframes <= 8)
		panic("ie: bogus buffer calc");
d1540 1
a1540 1
	ptr += sc->nframes * 64;
d2002 1
a2002 1
			free(sc->mcast_addrs, M_IFMADDR);
d2004 1
a2004 1
			malloc(size, M_IFMADDR, M_WAITOK);
@


1.2.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a143 2
#include "bpfilter.h"

d329 1
a329 2
			printf("%s: can't allocate pad buffer\n",
			    sc->sc_dev.dv_xname);
d383 3
a385 7
#ifdef I82596_DEBUG
	if (sc->sc_debug & IED_CMDS)
		printf("i82596_cmd_wait: timo(%ssync): scb status: %b\n",
		    sc->async_cmd_inprogress? "a" : "",
		    sc->ie_bus_read16(sc, IE_SCB_STATUS(sc->scb)),
		    IE_STAT_BITS);
#endif
d572 1
d1124 2
a1125 1
	if (ifp->if_bpf)
d1127 1
d1207 3
a1209 8
		if (i82596_start_cmd(sc, IE_CUC_START, 0, 0, 1)) {
#ifdef I82596_DEBUG
			if (sc->sc_debug & IED_XMIT)
				printf("%s: i82596_xmit: "
				    "start xmit command timed out\n",
				       sc->sc_dev.dv_xname);
#endif
		}
a1364 1
#ifdef I82596_DEBUG
a1366 1
#endif
d1375 1
a1375 2
	if (i82596_start_cmd(sc, IE_RUC_ABORT | IE_CUC_ABORT, 0, 0, 0)) {
#ifdef I82596_DEBUG
a1376 2
#endif
	}
d1517 1
a1517 1
	/* The receive frame descriptors */
@


1.2.2.7
log
@Merge with the trunk
@
text
@d162 1
@


1.1
log
@i82586/96 MI stuff currently in 586 mode, tested on hppa; from netbsd i82586
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a211 2

int spurious_intrs = 0;
d225 1
a225 25
#ifdef rewrite_also_do_the_test_command
	volatile struct ie_sys_conf_ptr *scp;
	volatile struct ie_int_sys_conf_ptr *iscp;
	volatile struct ie_sys_ctl_block *scb;
	u_long realbase;
	int s;

	s = splnet();

	realbase = (u_long)where + size - (1 << 24);

	scp = (volatile struct ie_sys_conf_ptr *)(realbase + IE_SCP_ADDR);
	bzero((char *)scp, sizeof *scp);

	/*
	 * First we put the ISCP at the bottom of memory; this tests to make
	 * sure that our idea of the size of memory is the same as the
	 * controller's.  This is NOT where the ISCP will be in normal
	 * operation.
	 */
	iscp = (volatile struct ie_int_sys_conf_ptr *)where;
	bzero((char *)iscp, sizeof *iscp);

	scb = (volatile struct ie_sys_ctl_block *)where;
	bzero((char *)scb, sizeof *scb);
d227 9
a235 3
	scp->ie_bus_use = 0;		/* 16-bit */
	scp->ie_iscp_ptr = (caddr_t)((volatile caddr_t)iscp -
	    (volatile caddr_t)realbase);
d237 1
a237 4
	iscp->ie_busy = 1;
	iscp->ie_scb_offset = MK_16(realbase, scb) + 256;

	(sc->reset)(sc);
d239 1
d241 4
a244 4
	delay(100);			/* wait a while... */

	if (iscp->ie_busy) {
		splx(s);
d248 6
a253 6
	/*
	 * Now relocate the ISCP to its real home, and reset the controller
	 * again.
	 */
	iscp = (void *)ALIGN(realbase + IE_SCP_ADDR - sizeof(*iscp));
	bzero((char *)iscp, sizeof *iscp);
d255 4
a258 1
	scp->ie_iscp_ptr = (caddr_t)((caddr_t)iscp - (caddr_t)realbase);
d260 1
a260 11
	iscp->ie_busy = 1;
	iscp->ie_scb_offset = MK_16(realbase, scb);

	(sc->reset)(sc);
	(sc->chan_attn)(sc);

	delay(100);

	if (iscp->ie_busy) {
		splx(s);
		return 0;
a262 12
	sc->sc_msize = size;
	sc->sc_maddr = (caddr_t)realbase;

	sc->iscp = iscp;
	sc->scb = scb;

	/*
	 * Acknowledge any interrupts we may have caused...
	 */
	ie_ack(sc, IE_ST_WHENCE);
	splx(s);
#endif
d298 9
d333 2
a334 1
	printf(" address %s, type %s\n", ether_sprintf(etheraddr), name);
d513 1
a513 1
		(sc->intrhook)(sc, INTR_ENTER);
a519 5
#ifdef I82596_DEBUG
		if ((spurious_intrs++ % 25) == 0)
			printf("%s: i82596_intr: %d spurious interrupts\n",
			       sc->sc_dev.dv_xname, spurious_intrs);
#endif
d521 1
a521 1
			(sc->intrhook)(sc, INTR_EXIT);
d547 1
a547 1
		(sc->intrhook)(sc, INTR_LOOP);
d562 1
a562 1
		(sc->intrhook)(sc, INTR_EXIT);
d1316 1
a1316 1
		(sc->hwreset)(sc, CHIP_PROBE);
d1359 1
a1359 1
		(sc->hwreset)(sc, CARD_RESET);
@

