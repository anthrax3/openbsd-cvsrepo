head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.22
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.20
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.14
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.16
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.8
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.12
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.10
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.20
	OPENBSD_5_0:1.13.0.16
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.14
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.12
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.8
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.8
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.2.0.8
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2012.04.03.23.39.09;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.21.03.58.07;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.09.04.04.05;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.04.03.48.37;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.25.01.23.30;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.24.20.41.34;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.14.18.14.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.08.22.35.13;	author pascoe;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.04.19.42.30;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.17.15.12.12;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.09.21.12.51;	author jason;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2000.04.26.19.12.08;	author chris;	state Exp;
branches
	1.2.8.1;
next	1.1;

1.1
date	2000.04.18.18.44.27;	author jason;	state Exp;
branches;
next	;

1.2.8.1
date	2001.05.14.22.23.47;	author niklas;	state Exp;
branches;
next	1.2.8.2;

1.2.8.2
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.2.8.3;

1.2.8.3
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.2.8.4;

1.2.8.4
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@After suspend/resume, reload the firmware.  Skip firmware on
FXP_REV_82550_C with server extensions.
@
text
@/*	$OpenBSD: fxpreg.h,v 1.13 2008/02/21 03:58:07 brad Exp $	*/

/*
 * Copyright (c) 1995, David Greenman
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: if_fxpreg.h,v 1.13 1998/06/08 09:47:46 bde Exp $
 */

#define FXP_VENDORID_INTEL	0x8086
#define FXP_DEVICEID_i82557	0x1229

#define FXP_PCI_MMBA	0x10
#define FXP_PCI_IOBA	0x14

/*
 * Control/status registers.
 */
#define	FXP_CSR_SCB_STATUS	0	/* scb_status (2 byte) */
#define	FXP_CSR_SCB_COMMAND	2	/* scb_command (2 byte) */
#define	FXP_CSR_SCB_GENERAL	4	/* scb_general (4 bytes) */
#define	FXP_CSR_PORT		8	/* port (4 bytes) */
#define	FXP_CSR_FLASHCONTROL	12	/* flash control (2 bytes) */
#define	FXP_CSR_EEPROMCONTROL	14	/* eeprom control (2 bytes) */
#define	FXP_CSR_MDICONTROL	16	/* mdi control (4 bytes) */

/*
 * FOR REFERENCE ONLY, the old definition of FXP_CSR_SCB_RUSCUS:
 *
 *	volatile u_int8_t	:2,
 *				scb_rus:4,
 *				scb_cus:2;
 */

#define FXP_PORT_SOFTWARE_RESET		0
#define FXP_PORT_SELFTEST		1
#define FXP_PORT_SELECTIVE_RESET	2
#define FXP_PORT_DUMP			3

#define FXP_SCB_RUS_IDLE		0x0000
#define FXP_SCB_RUS_SUSPENDED		0x0001
#define FXP_SCB_RUS_NORESOURCES		0x0002
#define FXP_SCB_RUS_READY		0x0004
#define FXP_SCB_RUS_SUSP_NORBDS		0x0009
#define FXP_SCB_RUS_NORES_NORBDS	0x000a
#define FXP_SCB_RUS_READY_NORBDS	0x000c

#define FXP_SCB_CUS_IDLE		0x0000
#define FXP_SCB_CUS_SUSPENDED		0x0040
#define FXP_SCB_CUS_ACTIVE		0x0080
#define FXP_SCB_CUS_MASK		0x00c0

#define FXP_SCB_STATACK_SWI		0x0400
#define FXP_SCB_STATACK_MDI		0x0800
#define FXP_SCB_STATACK_RNR		0x1000
#define FXP_SCB_STATACK_CNA		0x2000
#define FXP_SCB_STATACK_FR		0x4000
#define FXP_SCB_STATACK_CXTNO		0x8000
#define FXP_SCB_STATACK_MASK		0xfc00

#define FXP_SCB_COMMAND_CU_NOP		0x0000
#define FXP_SCB_COMMAND_CU_START	0x0010
#define FXP_SCB_COMMAND_CU_RESUME	0x0020
#define FXP_SCB_COMMAND_CU_DUMP_ADR	0x0040
#define FXP_SCB_COMMAND_CU_DUMP		0x0050
#define FXP_SCB_COMMAND_CU_BASE		0x0060
#define FXP_SCB_COMMAND_CU_DUMPRESET	0x0070

#define FXP_SCB_COMMAND_RU_NOP		0x0000
#define FXP_SCB_COMMAND_RU_START	0x0001
#define FXP_SCB_COMMAND_RU_RESUME	0x0002
#define FXP_SCB_COMMAND_RU_ABORT	0x0004
#define FXP_SCB_COMMAND_RU_LOADHDS	0x0005
#define FXP_SCB_COMMAND_RU_BASE		0x0006
#define FXP_SCB_COMMAND_RU_RBDRESUME	0x0007

#define	FXP_SCB_INTRCNTL_REQUEST_SWI	0x0200

#define	FXP_CMD_TMO	(10000)

/*
 * Command block definitions
 */
struct fxp_cb_nop {
	void *fill[2];
	volatile u_int16_t cb_status;
	volatile u_int16_t cb_command;
	volatile u_int32_t link_addr;
};
struct fxp_cb_ias {
	volatile u_int16_t cb_status;
	volatile u_int16_t cb_command;
	volatile u_int32_t link_addr;
	volatile u_int8_t macaddr[6];
};
/* I hate bit-fields :-( */ /* SO WHY USE IT, EH? */

/*
 *  Bitfields cleaned out since it is not endian compatible. OK
 *  you can define a big endian structure but can never be 100% safe...
 *
 *  ANY PROGRAMER TRYING THE STUNT WITH BITFIELDS IN A DEVICE DRIVER
 *  SHOULD BE PUT UP AGAINST THE WALL, BLINDFOLDED AND SHOT!
 */
struct fxp_cb_config {
        volatile u_int16_t      cb_status;
        volatile u_int16_t      cb_command;
        volatile u_int32_t      link_addr;
        volatile u_int8_t       byte_count;
        volatile u_int8_t       fifo_limit;
        volatile u_int8_t       adaptive_ifs;
        volatile u_int8_t       ctrl0;
        volatile u_int8_t       rx_dma_bytecount;
        volatile u_int8_t       tx_dma_bytecount;
        volatile u_int8_t       ctrl1;
        volatile u_int8_t       ctrl2;
        volatile u_int8_t       mediatype;
        volatile u_int8_t       void2;
        volatile u_int8_t       ctrl3;
        volatile u_int8_t       linear_priority;
        volatile u_int8_t       interfrm_spacing;
        volatile u_int8_t       void3;
        volatile u_int8_t       void4;
        volatile u_int8_t       promiscuous;
        volatile u_int8_t       void5;
        volatile u_int8_t       void6;
        volatile u_int8_t       stripping;
        volatile u_int8_t       fdx_pin;
        volatile u_int8_t       multi_ia;
        volatile u_int8_t       mc_all;
};

#define MAXMCADDR 80
struct fxp_cb_mcs {
	volatile u_int16_t cb_status;
	volatile u_int16_t cb_command;
	volatile u_int32_t link_addr;
	volatile u_int16_t mc_cnt;
	volatile u_int8_t mc_addr[MAXMCADDR][6];
};

/*
 * Number of DMA segments in a TxCB. Note that this is carefully
 * chosen to make the total struct size an even power of two. It's
 * critical that no TxCB be split across a page boundary since
 * no attempt is made to allocate physically contiguous memory.
 */
#define	SZ_TXCB		16	/* TX control block head size = 4 32 bit words */
#define	SZ_TBD		8	/* Fragment ptr/size block size */
#define FXP_NTXSEG      ((256 - SZ_TXCB) / SZ_TBD)

struct fxp_tbd {
	volatile u_int32_t tb_addr;
	volatile u_int32_t tb_size;
};
struct fxp_cb_tx {
	volatile u_int16_t cb_status;
	volatile u_int16_t cb_command;
	volatile u_int32_t link_addr;
	volatile u_int32_t tbd_array_addr;
	volatile u_int16_t byte_count;
	volatile u_int8_t tx_threshold;
	volatile u_int8_t tbd_number;
	/*
	 * The following isn't actually part of the TxCB.
	 */
	volatile struct fxp_tbd tbd[FXP_NTXSEG];
};

/*
 * Control Block (CB) definitions
 */

/* status */
#define FXP_CB_STATUS_OK	0x2000
#define FXP_CB_STATUS_C		0x8000
/* commands */
#define FXP_CB_COMMAND_NOP	0x0
#define FXP_CB_COMMAND_IAS	0x1
#define FXP_CB_COMMAND_CONFIG	0x2
#define FXP_CB_COMMAND_MCAS	0x3
#define FXP_CB_COMMAND_XMIT	0x4
#define FXP_CB_COMMAND_UCODE	0x5
#define FXP_CB_COMMAND_DUMP	0x6
#define FXP_CB_COMMAND_DIAG	0x7
/* command flags */
#define FXP_CB_COMMAND_SF	0x0008	/* simple/flexible mode */
#define FXP_CB_COMMAND_I	0x2000	/* generate interrupt on completion */
#define FXP_CB_COMMAND_S	0x4000	/* suspend on completion */
#define FXP_CB_COMMAND_EL	0x8000	/* end of list */

/*
 * RFA definitions
 */

struct fxp_rfa {
	volatile u_int16_t rfa_status;
	volatile u_int16_t rfa_control;
	volatile u_int32_t link_addr;
	volatile u_int32_t rbd_addr;
	volatile u_int16_t actual_size;
	volatile u_int16_t size;
};
#define FXP_RFA_STATUS_RCOL	0x0001	/* receive collision */
#define FXP_RFA_STATUS_IAMATCH	0x0002	/* 0 = matches station address */
#define FXP_RFA_STATUS_S4	0x0010	/* receive error from PHY */
#define FXP_RFA_STATUS_TL	0x0020	/* type/length */
#define FXP_RFA_STATUS_FTS	0x0080	/* frame too short */
#define FXP_RFA_STATUS_OVERRUN	0x0100	/* DMA overrun */
#define FXP_RFA_STATUS_RNR	0x0200	/* RU not ready */
#define FXP_RFA_STATUS_ALIGN	0x0400	/* alignment error */
#define FXP_RFA_STATUS_CRC	0x0800	/* CRC error */
#define FXP_RFA_STATUS_OK	0x2000	/* packet received okay */
#define FXP_RFA_STATUS_C	0x8000	/* packet reception complete */
#define FXP_RFA_CONTROL_SF	0x08	/* simple/flexible memory mode */
#define FXP_RFA_CONTROL_H	0x10	/* header RFD */
#define FXP_RFA_CONTROL_S	0x4000	/* suspend after reception */
#define FXP_RFA_CONTROL_EL	0x8000	/* end of list */

/*
 * Statistics dump area definitions
 */
struct fxp_stats {
	volatile u_int32_t tx_good;
	volatile u_int32_t tx_maxcols;
	volatile u_int32_t tx_latecols;
	volatile u_int32_t tx_underruns;
	volatile u_int32_t tx_lostcrs;
	volatile u_int32_t tx_deffered;
	volatile u_int32_t tx_single_collisions;
	volatile u_int32_t tx_multiple_collisions;
	volatile u_int32_t tx_total_collisions;
	volatile u_int32_t rx_good;
	volatile u_int32_t rx_crc_errors;
	volatile u_int32_t rx_alignment_errors;
	volatile u_int32_t rx_rnr_errors;
	volatile u_int32_t rx_overrun_errors;
	volatile u_int32_t rx_cdt_errors;
	volatile u_int32_t rx_shortframes;
	volatile u_int32_t completion_status;
};
#define FXP_STATS_DUMP_COMPLETE	0xa005
#define FXP_STATS_DR_COMPLETE	0xa007
	
/*
 * Serial EEPROM control register bits
 */
/* shift clock */
#define FXP_EEPROM_EESK		0x01
/* chip select */
#define FXP_EEPROM_EECS		0x02
/* data in */
#define FXP_EEPROM_EEDI		0x04
/* data out */
#define FXP_EEPROM_EEDO		0x08

/*
 * Serial EEPROM opcodes, including start bit
 */
#define FXP_EEPROM_OPC_ERASE	0x4
#define FXP_EEPROM_OPC_WRITE	0x5
#define FXP_EEPROM_OPC_READ	0x6

/*
 * Serial EEPROM registers.  A subset of them from Intel's
 * "82559 EEPROM Map and Programming Information" document.
 */
#define FXP_EEPROM_REG_MAC		0x00
#define FXP_EEPROM_REG_COMPAT		0x03
#define  FXP_EEPROM_REG_COMPAT_MC10	0x0001
#define  FXP_EEPROM_REG_COMPAT_MC100	0x0002
#define  FXP_EEPROM_REG_COMPAT_SRV	0x0400
#define FXP_EEPROM_REG_PHY		0x06
#define FXP_EEPROM_REG_ID		0x0a
#define  FXP_EEPROM_REG_ID_STB		0x0002

/*
 * Management Data Interface opcodes
 */
#define FXP_MDI_WRITE		0x1
#define FXP_MDI_READ		0x2

/*
 * PHY device types
 */
#define FXP_PHY_DEVICE_MASK	0x3f00
#define FXP_PHY_SERIAL_ONLY	0x8000
#define FXP_PHY_NONE		0
#define FXP_PHY_82553A		1
#define FXP_PHY_82553C		2
#define FXP_PHY_82503		3
#define FXP_PHY_DP83840		4
#define FXP_PHY_80C240		5
#define FXP_PHY_80C24		6
#define FXP_PHY_82555		7
#define FXP_PHY_DP83840A	10
#define FXP_PHY_82555B		11

/*
 * PHY BMCR Basic Mode Control Register
 */
#define FXP_PHY_BMCR			0x0
#define FXP_PHY_BMCR_FULLDUPLEX		0x0100
#define FXP_PHY_BMCR_AUTOEN		0x1000
#define FXP_PHY_BMCR_SPEED_100M		0x2000

/*
 * DP84830 PHY, PCS Configuration Register
 */
#define FXP_DP83840_PCR			0x17
#define FXP_DP83840_PCR_LED4_MODE	0x0002	/* 1 = LED4 always indicates full duplex */
#define FXP_DP83840_PCR_F_CONNECT	0x0020	/* 1 = force link disconnect function bypass */
#define FXP_DP83840_PCR_BIT8		0x0100
#define FXP_DP83840_PCR_BIT10		0x0400

#define	MAXUCODESIZE 192
struct fxp_cb_ucode {
	volatile u_int16_t cb_status;
	volatile u_int16_t cb_command;
	volatile u_int32_t link_addr;
	volatile u_int32_t ucode[MAXUCODESIZE];
};

/* 
 * Chip revision values.
 */
#define FXP_REV_82557_A		0	/* 82557 A */
#define FXP_REV_82557_B		1	/* 82557 B */
#define FXP_REV_82557_C		2	/* 82557 C */
#define FXP_REV_82558_A4	4	/* 82558 A4 stepping */
#define FXP_REV_82558_B0	5	/* 82558 B0 stepping */
#define FXP_REV_82559_A0	8	/* 82559 A0 stepping */
#define FXP_REV_82559S_A	9	/* 82559S A stepping */
#define FXP_REV_82550		12
#define FXP_REV_82550_C		13	/* 82550 C stepping */
#define FXP_REV_82551_E		14	/* 82551 */
#define FXP_REV_82551_F		15	/* 82551 */
#define FXP_REV_82551_10	16	/* 82551 */
@


1.13
log
@Some fxp(4) chips do not like having their status/command registers accessed
as 8-bit reads/writes even though they are 16-bit. This can cause the
respective interfaces to lock up until the system is hard rebooted. Having
the driver read/write to these registers as 16-bit entities resolves the
instability.

From mickey@@

ok krw@@ sthen@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.12 2006/06/09 04:04:05 brad Exp $	*/
d285 13
@


1.12
log
@some more fxp revisions.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.11 2006/03/04 03:48:37 brad Exp $	*/
d41 2
a42 4
#define	FXP_CSR_SCB_RUSCUS	0	/* scb_rus/scb_cus (1 byte) */
#define	FXP_CSR_SCB_STATACK	1	/* scb_statack (1 byte) */
#define	FXP_CSR_SCB_COMMAND	2	/* scb_command (1 byte) */
#define	FXP_CSR_SCB_INTRCNTL	3	/* scb_intrcntl (1 byte) */
d62 36
a97 34
#define FXP_SCB_RUS_IDLE		0
#define FXP_SCB_RUS_SUSPENDED		1
#define FXP_SCB_RUS_NORESOURCES		2
#define FXP_SCB_RUS_READY		4
#define FXP_SCB_RUS_SUSP_NORBDS		9
#define FXP_SCB_RUS_NORES_NORBDS	10
#define FXP_SCB_RUS_READY_NORBDS	12

#define FXP_SCB_CUS_IDLE		0
#define FXP_SCB_CUS_SUSPENDED		1
#define FXP_SCB_CUS_ACTIVE		2

#define FXP_SCB_STATACK_SWI		0x04
#define FXP_SCB_STATACK_MDI		0x08
#define FXP_SCB_STATACK_RNR		0x10
#define FXP_SCB_STATACK_CNA		0x20
#define FXP_SCB_STATACK_FR		0x40
#define FXP_SCB_STATACK_CXTNO		0x80

#define FXP_SCB_COMMAND_CU_NOP		0x00
#define FXP_SCB_COMMAND_CU_START	0x10
#define FXP_SCB_COMMAND_CU_RESUME	0x20
#define FXP_SCB_COMMAND_CU_DUMP_ADR	0x40
#define FXP_SCB_COMMAND_CU_DUMP		0x50
#define FXP_SCB_COMMAND_CU_BASE		0x60
#define FXP_SCB_COMMAND_CU_DUMPRESET	0x70

#define FXP_SCB_COMMAND_RU_NOP		0
#define FXP_SCB_COMMAND_RU_START	1
#define FXP_SCB_COMMAND_RU_RESUME	2
#define FXP_SCB_COMMAND_RU_ABORT	4
#define FXP_SCB_COMMAND_RU_LOADHDS	5
#define FXP_SCB_COMMAND_RU_BASE		6
#define FXP_SCB_COMMAND_RU_RBDRESUME	7
d99 3
a101 1
#define	FXP_SCB_INTRCNTL_REQUEST_SWI	0x02
@


1.11
log
@some defines for PHY detection.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.10 2005/04/25 01:23:30 brad Exp $	*/
d334 3
a336 1
#define FXP_REV_82557		1	/* catchall 82557 */
@


1.10
log
@remove the stepping info since this isn't right
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.9 2005/04/24 20:41:34 brad Exp $	*/
d293 2
@


1.9
log
@add microcode to support interrupt mitigation on the
82551 F stepping chipset.

From FreeBSD via Dmitry Bogdan <dsb at imcs dot dvgu dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.8 2005/01/14 18:14:12 deraadt Exp $	*/
d339 2
a340 2
#define FXP_REV_82551_E		14	/* 82551 E stepping */
#define FXP_REV_82551_F		15	/* 82551 F stepping */
@


1.8
log
@use PCI Memory Write and Invalidate; from bogdan@@eastonline.ru, ok pascoe
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.7 2004/12/08 22:35:13 pascoe Exp $	*/
d332 5
a336 5
#define FXP_REV_82557		1
#define FXP_REV_82558_A4	4
#define FXP_REV_82558_B0	5
#define FXP_REV_82559_A0	8
#define FXP_REV_82559S_A	9
d338 4
a341 1
#define FXP_REV_82550_C		13
@


1.7
log
@Defer reinitialisation of the RU until after the interrupt handler has had
a chance to process all pending packets, otherwise the chip may overwrite
their mbuf clusters after we have freed them.

Eliminates a race that can cause random pool corruption when reconfiguring
an interface under heavy network load.

ok brad@@ mcbride@@ beck@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.6 2004/08/04 19:42:30 mickey Exp $	*/
d132 1
a132 1
        volatile u_int8_t       void1;
@


1.6
log
@interrupt coalescing on post 82557 chips; from freebsd via Dmitry Bogdan <dsb@@poi.dvo.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.5 2003/10/21 18:58:49 jmc Exp $	*/
d98 2
@


1.5
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.4 2002/10/17 15:12:12 drahn Exp $	*/
d201 1
a201 1
#define FXP_CB_COMMAND_RESRV	0x5
d228 1
a228 1
#define FXP_RFA_STATUS_RNR	0x0200	/* no resources */
d318 19
@


1.4
log
@Bigendian support for fxp, work from pefo with cleanups, ok art@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.3 2001/08/09 21:12:51 jason Exp $	*/
d163 1
a163 1
 * critical that no TxCB be split across a page boundry since
a164 1
 * 
@


1.3
log
@- scb_wait() is now time based (not cpu speed based)
- rearrange multicast setup to be part of init
- convert cu operations to bus_dma(9) (still have to do RFA ops).
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.2 2000/04/26 19:12:08 chris Exp $	*/
d114 9
a122 1
/* I hate bit-fields :-( */
d124 25
a148 57
	volatile u_int16_t	cb_status;
	volatile u_int16_t	cb_command;
	volatile u_int32_t	link_addr;
	volatile u_int		byte_count:6,
				:2;
	volatile u_int		rx_fifo_limit:4,
				tx_fifo_limit:3,
				:1;
	volatile u_int8_t	adaptive_ifs;
	volatile u_int		:8;
	volatile u_int		rx_dma_bytecount:7,
				:1;
	volatile u_int		tx_dma_bytecount:7,
				dma_bce:1;
	volatile u_int		late_scb:1,
				:1,
				tno_int:1,
				ci_int:1,
				:3,
				save_bf:1;
	volatile u_int		disc_short_rx:1,
				underrun_retry:2,
				:5;
	volatile u_int		mediatype:1,
				:7;
	volatile u_int		:8;
	volatile u_int		:3,
				nsai:1,
				preamble_length:2,
				loopback:2;
	volatile u_int		linear_priority:3,
				:5;
	volatile u_int		linear_pri_mode:1,
				:3,
				interfrm_spacing:4;
	volatile u_int		:8;
	volatile u_int		:8;
	volatile u_int		promiscuous:1,
				bcast_disable:1,
				:5,
				crscdt:1;
	volatile u_int		:8;
	volatile u_int		:8;
	volatile u_int		stripping:1,
				padding:1,
				rcv_crc_xfer:1,
				long_rx:1,		/* 82558/82559 */
				:4;
	volatile u_int		:6,
				force_fdx:1,
				fdx_pin_en:1;
	volatile u_int		:6,
				multi_ia:1,
				:1;
	volatile u_int		:3,
				mc_all:1,
				:4;
d167 3
a169 5
#ifdef __alpha__ /* XXX - should be conditional on pointer size */
#define FXP_NTXSEG      30
#else
#define FXP_NTXSEG      31
#endif
@


1.3.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.3 2001/08/09 21:12:51 jason Exp $	*/
d114 1
a114 9
/* I hate bit-fields :-( */ /* SO WHY USE IT, EH? */

/*
 *  Bitfields cleaned out since it is not endian compatible. OK
 *  you can define a big endian structure but can never be 100% safe...
 *
 *  ANY PROGRAMER TRYING THE STUNT WITH BITFIELDS IN A DEVICE DRIVER
 *  SHOULD BE PUT UP AGAINST THE WALL, BLINDFOLDED AND SHOT!
 */
d116 57
a172 25
        volatile u_int16_t      cb_status;
        volatile u_int16_t      cb_command;
        volatile u_int32_t      link_addr;
        volatile u_int8_t       byte_count;
        volatile u_int8_t       fifo_limit;
        volatile u_int8_t       adaptive_ifs;
        volatile u_int8_t       void1;
        volatile u_int8_t       rx_dma_bytecount;
        volatile u_int8_t       tx_dma_bytecount;
        volatile u_int8_t       ctrl1;
        volatile u_int8_t       ctrl2;
        volatile u_int8_t       mediatype;
        volatile u_int8_t       void2;
        volatile u_int8_t       ctrl3;
        volatile u_int8_t       linear_priority;
        volatile u_int8_t       interfrm_spacing;
        volatile u_int8_t       void3;
        volatile u_int8_t       void4;
        volatile u_int8_t       promiscuous;
        volatile u_int8_t       void5;
        volatile u_int8_t       void6;
        volatile u_int8_t       stripping;
        volatile u_int8_t       fdx_pin;
        volatile u_int8_t       multi_ia;
        volatile u_int8_t       mc_all;
d191 5
a195 3
#define	SZ_TXCB		16	/* TX control block head size = 4 32 bit words */
#define	SZ_TBD		8	/* Fragment ptr/size block size */
#define FXP_NTXSEG      ((256 - SZ_TXCB) / SZ_TBD)
@


1.2
log
@Turn on a bit (for 82558/82559 only) which disables the chip's
builin feature to discard frames >1500 bytes (useful for jumbo frames,
also 802.1Q VLANs)

ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.1 2000/04/18 18:44:27 jason Exp $	*/
a108 1
	void *fill[2];
a115 1
	void *fill[2];
a176 2
	struct fxp_cb_tx *next;
	struct mbuf *mb_head;
d192 1
a192 1
#define FXP_NTXSEG      28
d194 1
a194 1
#define FXP_NTXSEG      29
a201 2
	struct fxp_cb_tx *next;
	struct mbuf *mb_head;
@


1.2.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.2 2000/04/26 19:12:08 chris Exp $	*/
@


1.2.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: fxpreg.h,v 1.2.8.1 2001/05/14 22:23:47 niklas Exp $	*/
d109 1
d117 1
d179 2
d196 1
a196 1
#define FXP_NTXSEG      30
d198 1
a198 1
#define FXP_NTXSEG      31
d206 2
@


1.2.8.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 1
a114 9
/* I hate bit-fields :-( */ /* SO WHY USE IT, EH? */

/*
 *  Bitfields cleaned out since it is not endian compatible. OK
 *  you can define a big endian structure but can never be 100% safe...
 *
 *  ANY PROGRAMER TRYING THE STUNT WITH BITFIELDS IN A DEVICE DRIVER
 *  SHOULD BE PUT UP AGAINST THE WALL, BLINDFOLDED AND SHOT!
 */
d116 57
a172 25
        volatile u_int16_t      cb_status;
        volatile u_int16_t      cb_command;
        volatile u_int32_t      link_addr;
        volatile u_int8_t       byte_count;
        volatile u_int8_t       fifo_limit;
        volatile u_int8_t       adaptive_ifs;
        volatile u_int8_t       void1;
        volatile u_int8_t       rx_dma_bytecount;
        volatile u_int8_t       tx_dma_bytecount;
        volatile u_int8_t       ctrl1;
        volatile u_int8_t       ctrl2;
        volatile u_int8_t       mediatype;
        volatile u_int8_t       void2;
        volatile u_int8_t       ctrl3;
        volatile u_int8_t       linear_priority;
        volatile u_int8_t       interfrm_spacing;
        volatile u_int8_t       void3;
        volatile u_int8_t       void4;
        volatile u_int8_t       promiscuous;
        volatile u_int8_t       void5;
        volatile u_int8_t       void6;
        volatile u_int8_t       stripping;
        volatile u_int8_t       fdx_pin;
        volatile u_int8_t       multi_ia;
        volatile u_int8_t       mc_all;
d191 5
a195 3
#define	SZ_TXCB		16	/* TX control block head size = 4 32 bit words */
#define	SZ_TBD		8	/* Fragment ptr/size block size */
#define FXP_NTXSEG      ((256 - SZ_TXCB) / SZ_TBD)
@


1.2.8.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d163 1
a163 1
 * critical that no TxCB be split across a page boundary since
d165 1
@


1.1
log
@split fxp into bus independent and dependent (pci) parts (cardbus to come)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxpreg.h,v 1.5 1998/07/02 21:15:46 downsj Exp $	*/
d164 2
a165 1
				:5;
@

