head	1.36;
access;
symbols
	OPENBSD_6_0:1.36.0.10
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.4
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.16
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.14
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.10
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.8
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.4
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.6
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.36
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.35;
commitid	uzzBR7hz9ncd4O6G;

1.35
date	2011.07.04.07.47.43;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.03.12.42.36;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.19.15.27.34;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.04.04.57.14;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.29.13.58.51;	author jasper;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.26.16.38.00;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.05.20.50.20;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.29.01.00.47;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.03.16.53.15;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.26.18.03.07;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.12.20.12.11;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.13.15.49.15;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.08.04.23.27.48;	author niklas;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	98.11.17.06.08.15;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.04.25.21;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	98.09.28.01.56.56;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	98.09.27.03.36.13;	author downsj;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.23.20;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2004.02.19.10.56.15;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@/*	$OpenBSD: adv.c,v 1.35 2011/07/04 07:47:43 jsg Exp $	*/
/*	$NetBSD: adv.c,v 1.6 1998/10/28 20:39:45 dante Exp $	*/

/*
 * Generic driver for the Advanced Systems Inc. Narrow SCSI controllers
 *
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Author: Baldassare Dante Profeta <dante@@mclink.it>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/adv.h>
#include <dev/ic/advlib.h>

/* #define ASC_DEBUG */

/******************************************************************************/


static int adv_alloc_ccbs(ASC_SOFTC *);
static int adv_create_ccbs(ASC_SOFTC *, ADV_CCB *, int);
void adv_ccb_free(void *, void *);
static void adv_reset_ccb(ADV_CCB *);
static int adv_init_ccb(ASC_SOFTC *, ADV_CCB *);
void *adv_ccb_alloc(void *);
static void adv_queue_ccb(ASC_SOFTC *, ADV_CCB *);
static void adv_start_ccbs(ASC_SOFTC *);

static u_int8_t *adv_alloc_overrunbuf(char *dvname, bus_dma_tag_t);

static void adv_scsi_cmd(struct scsi_xfer *);
static void advminphys(struct buf *, struct scsi_link *);
static void adv_narrow_isr_callback(ASC_SOFTC *, ASC_QDONE_INFO *);

static int adv_poll(ASC_SOFTC *, struct scsi_xfer *, int);
static void adv_timeout(void *);
static void adv_watchdog(void *);


/******************************************************************************/


struct cfdriver adv_cd = {
	NULL, "adv", DV_DULL
};


struct scsi_adapter adv_switch =
{
	adv_scsi_cmd,		/* called to start/enqueue a SCSI command */
	advminphys,		/* to limit the transfer to max device can do */
	0,			/* IT SEEMS IT IS NOT USED YET */
	0,			/* as above... */
};


#define ADV_ABORT_TIMEOUT       2000	/* time to wait for abort (mSec) */
#define ADV_WATCH_TIMEOUT       1000	/* time to wait for watchdog (mSec) */


/******************************************************************************/
/*                             Control Blocks routines                        */
/******************************************************************************/


static int
adv_alloc_ccbs(sc)
	ASC_SOFTC      *sc;
{
	bus_dma_segment_t seg;
	int             error, rseg;

	/*
         * Allocate the control blocks.
         */
	if ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adv_control),
			   NBPG, 0, &seg, 1, &rseg,
			   BUS_DMA_NOWAIT | BUS_DMA_ZERO)) != 0) {
		printf("%s: unable to allocate control structures,"
		       " error = %d\n", sc->sc_dev.dv_xname, error);
		return (error);
	}
	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,
		   sizeof(struct adv_control), (caddr_t *) & sc->sc_control,
				 BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map control structures, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}
	/*
         * Create and load the DMA map used for the control blocks.
         */
	if ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adv_control),
			   1, sizeof(struct adv_control), 0, BUS_DMA_NOWAIT,
				       &sc->sc_dmamap_control)) != 0) {
		printf("%s: unable to create control DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,
			   sc->sc_control, sizeof(struct adv_control), NULL,
				     BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load control DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}
	return (0);
}


/*
 * Create a set of ccbs and add them to the free list.  Called once
 * by adv_init().  We return the number of CCBs successfully created.
 * CCB data is already zeroed on allocation.
 */
static int
adv_create_ccbs(sc, ccbstore, count)
	ASC_SOFTC      *sc;
	ADV_CCB        *ccbstore;
	int             count;
{
	ADV_CCB        *ccb;
	int             i, error;

	for (i = 0; i < count; i++) {
		ccb = &ccbstore[i];
		if ((error = adv_init_ccb(sc, ccb)) != 0) {
			printf("%s: unable to initialize ccb, error = %d\n",
			       sc->sc_dev.dv_xname, error);
			return (i);
		}
		TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);
	}

	return (i);
}


/*
 * A ccb is put onto the free list.
 */
void
adv_ccb_free(xsc, xccb)
	void *xsc, *xccb;
{
	ASC_SOFTC *sc = xsc;
	ADV_CCB *ccb = xccb;

	adv_reset_ccb(ccb);

	mtx_enter(&sc->sc_ccb_mtx);
	TAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);
	mtx_leave(&sc->sc_ccb_mtx);
}


static void
adv_reset_ccb(ccb)
	ADV_CCB        *ccb;
{

	ccb->flags = 0;
}


static int
adv_init_ccb(sc, ccb)
	ASC_SOFTC      *sc;
	ADV_CCB        *ccb;
{
	int             error;

	/*
         * Create the DMA map for this CCB.
         */
	error = bus_dmamap_create(sc->sc_dmat,
				  (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,
			 ASC_MAX_SG_LIST, (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,
		   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);
	if (error) {
		printf("%s: unable to create DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}
	adv_reset_ccb(ccb);
	return (0);
}


/*
 * Get a free ccb
 */
void *
adv_ccb_alloc(xsc)
	void *xsc;
{
	ASC_SOFTC *sc = xsc;
	ADV_CCB *ccb;

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = TAILQ_FIRST(&sc->sc_free_ccb);
	if (ccb) {
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, chain);
		ccb->flags |= CCB_ALLOC;
	}
	mtx_leave(&sc->sc_ccb_mtx);

	return (ccb);
}

/*
 * Queue a CCB to be sent to the controller, and send it if possible.
 */
static void
adv_queue_ccb(sc, ccb)
	ASC_SOFTC      *sc;
	ADV_CCB        *ccb;
{

	timeout_set(&ccb->xs->stimeout, adv_timeout, ccb);
	TAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);

	adv_start_ccbs(sc);
}


static void
adv_start_ccbs(sc)
	ASC_SOFTC      *sc;
{
	ADV_CCB        *ccb;
	struct scsi_xfer *xs;

	while ((ccb = TAILQ_FIRST(&sc->sc_waiting_ccb)) != NULL) {

		xs = ccb->xs;
		if (ccb->flags & CCB_WATCHDOG)
			timeout_del(&xs->stimeout);

		if (AscExeScsiQueue(sc, &ccb->scsiq) == ASC_BUSY) {
			ccb->flags |= CCB_WATCHDOG;
			timeout_set(&xs->stimeout, adv_watchdog, ccb);
			timeout_add_msec(&xs->stimeout, ADV_WATCH_TIMEOUT);
			break;
		}
		TAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);

		if ((ccb->xs->flags & SCSI_POLL) == 0) {
			timeout_set(&xs->stimeout, adv_timeout, ccb);
			timeout_add_msec(&xs->stimeout, ccb->timeout);
		}
	}
}


/******************************************************************************/
/*                      DMA able memory allocation routines                   */
/******************************************************************************/


/*
 * Allocate a DMA able memory for overrun_buffer.
 * This memory can be safely shared among all the AdvanSys boards.
 */
u_int8_t       *
adv_alloc_overrunbuf(dvname, dmat)
	char           *dvname;
	bus_dma_tag_t   dmat;
{
	static u_int8_t *overrunbuf = NULL;

	bus_dmamap_t    ovrbuf_dmamap;
	bus_dma_segment_t seg;
	int             rseg, error;


	/*
         * if an overrun buffer has been already allocated don't allocate it
         * again. Instead return the address of the allocated buffer.
         */
	if (overrunbuf)
		return (overrunbuf);


	if ((error = bus_dmamem_alloc(dmat, ASC_OVERRUN_BSIZE,
			   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to allocate overrun buffer, error = %d\n",
		       dvname, error);
		return (0);
	}
	if ((error = bus_dmamem_map(dmat, &seg, rseg, ASC_OVERRUN_BSIZE,
	(caddr_t *) & overrunbuf, BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map overrun buffer, error = %d\n",
		       dvname, error);

		bus_dmamem_free(dmat, &seg, 1);
		return (0);
	}
	if ((error = bus_dmamap_create(dmat, ASC_OVERRUN_BSIZE, 1,
	      ASC_OVERRUN_BSIZE, 0, BUS_DMA_NOWAIT, &ovrbuf_dmamap)) != 0) {
		printf("%s: unable to create overrun buffer DMA map,"
		       " error = %d\n", dvname, error);

		bus_dmamem_unmap(dmat, overrunbuf, ASC_OVERRUN_BSIZE);
		bus_dmamem_free(dmat, &seg, 1);
		return (0);
	}
	if ((error = bus_dmamap_load(dmat, ovrbuf_dmamap, overrunbuf,
			   ASC_OVERRUN_BSIZE, NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load overrun buffer DMA map,"
		       " error = %d\n", dvname, error);

		bus_dmamap_destroy(dmat, ovrbuf_dmamap);
		bus_dmamem_unmap(dmat, overrunbuf, ASC_OVERRUN_BSIZE);
		bus_dmamem_free(dmat, &seg, 1);
		return (0);
	}
	return (overrunbuf);
}


/******************************************************************************/
/*                         SCSI layer interfacing routines                    */
/******************************************************************************/


int
adv_init(sc)
	ASC_SOFTC      *sc;
{
	int             warn;

	if (!AscFindSignature(sc->sc_iot, sc->sc_ioh))
		panic("adv_init: adv_find_signature failed");

	/*
         * Read the board configuration
         */
	AscInitASC_SOFTC(sc);
	warn = AscInitFromEEP(sc);
	if (warn) {
		printf("%s -get: ", sc->sc_dev.dv_xname);
		switch (warn) {
		case -1:
			printf("Chip is not halted\n");
			break;

		case -2:
			printf("Couldn't get MicroCode Start"
			       " address\n");
			break;

		case ASC_WARN_IO_PORT_ROTATE:
			printf("I/O port address modified\n");
			break;

		case ASC_WARN_AUTO_CONFIG:
			printf("I/O port increment switch enabled\n");
			break;

		case ASC_WARN_EEPROM_CHKSUM:
			printf("EEPROM checksum error\n");
			break;

		case ASC_WARN_IRQ_MODIFIED:
			printf("IRQ modified\n");
			break;

		case ASC_WARN_CMD_QNG_CONFLICT:
			printf("tag queuing enabled w/o disconnects\n");
			break;

		default:
			printf("unknown warning %d\n", warn);
		}
	}
	if (sc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)
		sc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;

	/*
         * Modify the board configuration
         */
	warn = AscInitFromASC_SOFTC(sc);
	if (warn) {
		printf("%s -set: ", sc->sc_dev.dv_xname);
		switch (warn) {
		case ASC_WARN_CMD_QNG_CONFLICT:
			printf("tag queuing enabled w/o disconnects\n");
			break;

		case ASC_WARN_AUTO_CONFIG:
			printf("I/O port increment switch enabled\n");
			break;

		default:
			printf("unknown warning %d\n", warn);
		}
	}
	sc->isr_callback = (ulong) adv_narrow_isr_callback;

	if (!(sc->overrun_buf = adv_alloc_overrunbuf(sc->sc_dev.dv_xname,
						     sc->sc_dmat))) {
		return (1);
	}

	return (0);
}


void
adv_attach(sc)
	ASC_SOFTC      *sc;
{
	struct scsibus_attach_args	saa;
	int				i, error;

	/*
         * Initialize board RISC chip and enable interrupts.
         */
	switch (AscInitDriver(sc)) {
	case 0:
		/* AllOK */
		break;

	case 1:
		panic("%s: bad signature", sc->sc_dev.dv_xname);
		break;

	case 2:
		panic("%s: unable to load MicroCode",
		      sc->sc_dev.dv_xname);
		break;

	case 3:
		panic("%s: unable to initialize MicroCode",
		      sc->sc_dev.dv_xname);
		break;

	default:
		panic("%s: unable to initialize board RISC chip",
		      sc->sc_dev.dv_xname);
	}

	TAILQ_INIT(&sc->sc_free_ccb);
	TAILQ_INIT(&sc->sc_waiting_ccb);

	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, adv_ccb_alloc, adv_ccb_free);

	/*
         * fill in the prototype scsi_link.
         */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->chip_scsi_id;
	sc->sc_link.adapter = &adv_switch;
	sc->sc_link.openings = 4;
	sc->sc_link.pool = &sc->sc_iopool;
	sc->sc_link.adapter_buswidth = 7;

	/*
         * Allocate the Control Blocks.
         */
	error = adv_alloc_ccbs(sc);
	if (error)
		return; /* (error) */ ;

	/*
         * Create and initialize the Control Blocks.
         */
	i = adv_create_ccbs(sc, sc->sc_control->ccbs, ADV_MAX_CCB);
	if (i == 0) {
		printf("%s: unable to create control blocks\n",
		       sc->sc_dev.dv_xname);
		return; /* (ENOMEM) */ ;
	} else if (i != ADV_MAX_CCB) {
		printf("%s: WARNING: only %d of %d control blocks created\n",
		       sc->sc_dev.dv_xname, i, ADV_MAX_CCB);
	}

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;
	config_found(&sc->sc_dev, &saa, scsiprint);
}


static void
advminphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > ((ASC_MAX_SG_LIST - 1) * PAGE_SIZE))
		bp->b_bcount = ((ASC_MAX_SG_LIST - 1) * PAGE_SIZE);
	minphys(bp);
}


/*
 * start a scsi operation given the command and the data address.  Also needs
 * the unit, target and lu.
 */
static void
adv_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *sc_link = xs->sc_link;
	ASC_SOFTC      *sc = sc_link->adapter_softc;
	bus_dma_tag_t   dmat = sc->sc_dmat;
	ADV_CCB        *ccb;
	int             flags, error, nsegs;

	/*
         * get a ccb to use. If the transfer
         * is from a buf (possibly from interrupt time)
         * then we can't allow it to sleep
         */

	flags = xs->flags;
	ccb = xs->io;

	ccb->xs = xs;
	ccb->timeout = xs->timeout;

	/*
         * Build up the request
         */
	memset(&ccb->scsiq, 0, sizeof(ASC_SCSI_Q));

	ccb->scsiq.q2.ccb_ptr = (ulong) ccb;

	ccb->scsiq.cdbptr = &xs->cmd->opcode;
	ccb->scsiq.q2.cdb_len = xs->cmdlen;
	ccb->scsiq.q1.target_id = ASC_TID_TO_TARGET_ID(sc_link->target);
	ccb->scsiq.q1.target_lun = sc_link->lun;
	ccb->scsiq.q2.target_ix = ASC_TIDLUN_TO_IX(sc_link->target,
						   sc_link->lun);
	ccb->scsiq.q1.sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +
		ADV_CCB_OFF(ccb) + offsetof(struct adv_ccb, scsi_sense);
	ccb->scsiq.q1.sense_len = sizeof(struct scsi_sense_data);

	/*
         * If  there  are  any  outstanding  requests  for  the  current target,
         * then  every  255th request  send an  ORDERED request.  This heuristic
         * tries  to  retain  the  benefit  of request  sorting while preventing
         * request starvation. 255 is the max number of tags or pending commands
         * a device may have outstanding.
         */
	sc->reqcnt[sc_link->target]++;
	if ((sc->reqcnt[sc_link->target] > 0) &&
	    (sc->reqcnt[sc_link->target] % 255) == 0) {
		ccb->scsiq.q2.tag_code = M2_QTAG_MSG_ORDERED;
	} else {
		ccb->scsiq.q2.tag_code = M2_QTAG_MSG_SIMPLE;
	}


	if (xs->datalen) {
		/*
                 * Map the DMA transfer.
                 */
		error = bus_dmamap_load(dmat,
		      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,
					(flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);

		if (error) {
			if (error == EFBIG) {
				printf("%s: adv_scsi_cmd, more than %d dma"
				       " segments\n",
				       sc->sc_dev.dv_xname, ASC_MAX_SG_LIST);
			} else {
				printf("%s: adv_scsi_cmd, error %d loading"
				       " dma map\n",
				       sc->sc_dev.dv_xname, error);
			}

			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
		    0, ccb->dmamap_xfer->dm_mapsize,
		    ((flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
			BUS_DMASYNC_PREWRITE));


		memset(&ccb->sghead, 0, sizeof(ASC_SG_HEAD));

		for (nsegs = 0; nsegs < ccb->dmamap_xfer->dm_nsegs; nsegs++) {

			ccb->sghead.sg_list[nsegs].addr =
				ccb->dmamap_xfer->dm_segs[nsegs].ds_addr;
			ccb->sghead.sg_list[nsegs].bytes =
				ccb->dmamap_xfer->dm_segs[nsegs].ds_len;
		}

		ccb->sghead.entry_cnt = ccb->scsiq.q1.sg_queue_cnt =
			ccb->dmamap_xfer->dm_nsegs;

		ccb->scsiq.q1.cntl |= ASC_QC_SG_HEAD;
		ccb->scsiq.sg_head = &ccb->sghead;
		ccb->scsiq.q1.data_addr = 0;
		ccb->scsiq.q1.data_cnt = 0;
	} else {
		/*
                 * No data xfer, use non S/G values.
                 */
		ccb->scsiq.q1.data_addr = 0;
		ccb->scsiq.q1.data_cnt = 0;
	}

#ifdef ASC_DEBUG
	printf("id = %d, lun = %d, cmd = %d, ccb = 0x%lX \n",
			sc_link->scsipi_scsi.target,
			sc_link->scsipi_scsi.lun, xs->cmd->opcode,
			(unsigned long)ccb);
#endif
	/*
         * Usually return SUCCESSFULLY QUEUED
         */
	if ((flags & SCSI_POLL) == 0)
		return;

	/*
         * If we can't use interrupts, poll on completion
         */
	if (adv_poll(sc, xs, ccb->timeout)) {
		adv_timeout(ccb);
		if (adv_poll(sc, xs, ccb->timeout))
			adv_timeout(ccb);
	}
}


int
adv_intr(arg)
	void           *arg;
{
	ASC_SOFTC      *sc = arg;

#ifdef ASC_DEBUG
	int int_pend = FALSE;

	if(ASC_IS_INT_PENDING(sc->sc_iot, sc->sc_ioh))
	{
		int_pend = TRUE;
		printf("ISR - ");
	}
#endif
	AscISR(sc);
#ifdef ASC_DEBUG
	if(int_pend)
		printf("\n");
#endif

	return (1);
}


/*
 * Poll a particular unit, looking for a particular xs
 */
static int
adv_poll(sc, xs, count)
	ASC_SOFTC      *sc;
	struct scsi_xfer *xs;
	int             count;
{
	int s;

	/* timeouts are in msec, so we loop in 1000 usec cycles */
	while (count) {
		s = splbio();
		adv_intr(sc);
		splx(s);
		if (xs->flags & ITSDONE)
			return (0);
		delay(1000);	/* only happens in boot so ok */
		count--;
	}
	return (1);
}


static void
adv_timeout(arg)
	void           *arg;
{
	ADV_CCB        *ccb = arg;
	struct scsi_xfer *xs = ccb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	ASC_SOFTC      *sc = sc_link->adapter_softc;
	int             s;

	sc_print_addr(sc_link);
	printf("timed out");

	s = splbio();

	/*
         * If it has been through before, then a previous abort has failed,
         * don't try abort again, reset the bus instead.
         */
	if (ccb->flags & CCB_ABORT) {
		/* abort timed out */
		printf(" AGAIN. Resetting Bus\n");
		/* Lets try resetting the bus! */
		if (AscResetBus(sc) == ASC_ERROR) {
			ccb->timeout = sc->scsi_reset_wait;
			adv_queue_ccb(sc, ccb);
		}
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		AscAbortCCB(sc, (u_int32_t) ccb);
		ccb->xs->error = XS_TIMEOUT;
		ccb->timeout = ADV_ABORT_TIMEOUT;
		ccb->flags |= CCB_ABORT;
		adv_queue_ccb(sc, ccb);
	}

	splx(s);
}


static void
adv_watchdog(arg)
	void           *arg;
{
	ADV_CCB        *ccb = arg;
	struct scsi_xfer *xs = ccb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	ASC_SOFTC      *sc = sc_link->adapter_softc;
	int             s;

	s = splbio();

	ccb->flags &= ~CCB_WATCHDOG;
	adv_start_ccbs(sc);

	splx(s);
}


/******************************************************************************/
/*                  NARROW and WIDE boards Interrupt callbacks                */
/******************************************************************************/


/*
 * adv_narrow_isr_callback() - Second Level Interrupt Handler called by AscISR()
 *
 * Interrupt callback function for the Narrow SCSI Asc Library.
 */
static void
adv_narrow_isr_callback(sc, qdonep)
	ASC_SOFTC      *sc;
	ASC_QDONE_INFO *qdonep;
{
	bus_dma_tag_t   dmat = sc->sc_dmat;
	ADV_CCB        *ccb = (ADV_CCB *) qdonep->d2.ccb_ptr;
	struct scsi_xfer *xs = ccb->xs;
	struct scsi_sense_data *s1, *s2;


#ifdef ASC_DEBUG
	printf(" - ccb=0x%lx, id=%d, lun=%d, cmd=%d, ",
			(unsigned long)ccb,
			xs->sc_link->scsipi_scsi.target,
			xs->sc_link->scsipi_scsi.lun, xs->cmd->opcode);
#endif
	timeout_del(&xs->stimeout);

	/*
         * If we were a data transfer, unload the map that described
         * the data buffer.
         */
	if (xs->datalen) {
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
		    0, ccb->dmamap_xfer->dm_mapsize,
		    ((xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
			BUS_DMASYNC_POSTWRITE));
		bus_dmamap_unload(dmat, ccb->dmamap_xfer);
	}
	if ((ccb->flags & CCB_ALLOC) == 0) {
		panic("%s: exiting ccb not allocated!", sc->sc_dev.dv_xname);
		return;
	}
	/*
         * 'qdonep' contains the command's ending status.
         */
#ifdef ASC_DEBUG
	printf("d_s=%d, h_s=%d", qdonep->d3.done_stat, qdonep->d3.host_stat);
#endif
	switch (qdonep->d3.done_stat) {
	case ASC_QD_NO_ERROR:
		switch (qdonep->d3.host_stat) {
		case ASC_QHSTA_NO_ERROR:
			xs->error = XS_NOERROR;
			xs->resid = 0;
			break;

		default:
			/* QHSTA error occurred */
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}

		/*
                 * If an INQUIRY command completed successfully, then call
                 * the AscInquiryHandling() function to patch bugged boards.
                 */
		if ((xs->cmd->opcode == SCSICMD_Inquiry) &&
		    (xs->sc_link->lun == 0) &&
		    (xs->datalen - qdonep->remain_bytes) >= 8) {
			AscInquiryHandling(sc,
				      xs->sc_link->target & 0x7,
					   (ASC_SCSI_INQUIRY *) xs->data);
		}
		break;

	case ASC_QD_WITH_ERROR:
		switch (qdonep->d3.host_stat) {
		case ASC_QHSTA_NO_ERROR:
			if (qdonep->d3.scsi_stat == SS_CHK_CONDITION) {
				s1 = &ccb->scsi_sense;
				s2 = &xs->sense;
				*s2 = *s1;
				xs->error = XS_SENSE;
			} else {
				xs->error = XS_DRIVER_STUFFUP;
			}
			break;

		default:
			/* QHSTA error occurred */
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		break;

	case ASC_QD_ABORTED_BY_HOST:
	default:
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	scsi_done(xs);
}
@


1.35
log
@Remove orphaned splbios that have no matching splx,
this has been a problem since internal xfer queues got
removed back in 2008.

ok matthew@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.34 2011/04/03 12:42:36 krw Exp $	*/
a42 1
#include <sys/proc.h>
@


1.34
log
@Iopoolification of some less common scsi drivers.

ok dlg@@ ("miod will not object" dlg@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.33 2010/08/07 03:50:01 krw Exp $	*/
d546 1
a546 3
	int             s, flags, error, nsegs;

	s = splbio();		/* protect the queue */
@


1.33
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.32 2010/06/28 18:31:01 krw Exp $	*/
d61 1
a61 1
static void adv_free_ccb(ASC_SOFTC *, ADV_CCB *);
d64 1
a64 1
static ADV_CCB *adv_get_ccb(ASC_SOFTC *, int);
d181 3
a183 4
static void
adv_free_ccb(sc, ccb)
	ASC_SOFTC      *sc;
	ADV_CCB        *ccb;
d185 2
a186 1
	int             s;
d188 1
a188 1
	s = splbio();
d190 1
a190 1
	adv_reset_ccb(ccb);
d192 1
a192 9

	/*
         * If there were none, wake anybody waiting for one to come free,
         * starting with queued entries.
         */
	if (TAILQ_NEXT(ccb, chain) == NULL)
		wakeup(&sc->sc_free_ccb);

	splx(s);
a230 2
 *
 * If there are none, see if we can allocate a new one
d232 12
a243 24
static ADV_CCB *
adv_get_ccb(sc, flags)
	ASC_SOFTC      *sc;
	int             flags;
{
	ADV_CCB        *ccb = 0;
	int             s;

	s = splbio();

	/*
         * If we can and have to, sleep waiting for one to come free
         * but only if we can't allocate a new one.
         */
	for (;;) {
		ccb = TAILQ_FIRST(&sc->sc_free_ccb);
		if (ccb) {
			TAILQ_REMOVE(&sc->sc_free_ccb, ccb, chain);
			break;
		}
		if ((flags & SCSI_NOSLEEP) != 0)
			goto out;

		tsleep(&sc->sc_free_ccb, PRIBIO, "advccb", 0);
d245 1
a246 4
	ccb->flags |= CCB_ALLOC;

out:
	splx(s);
a249 1

d483 5
d496 1
a498 5

	TAILQ_INIT(&sc->sc_free_ccb);
	TAILQ_INIT(&sc->sc_waiting_ccb);


d557 1
a557 7
	if ((ccb = adv_get_ccb(sc, flags)) == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		splx(s);
		return;
	}
	splx(s);		/* done playing with the queue */
a614 1
			adv_free_ccb(sc, ccb);
a884 2

	adv_free_ccb(sc, ccb);
@


1.32
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.31 2010/06/26 23:24:44 guenther Exp $	*/
d855 1
a855 1
		panic("%s: exiting ccb not allocated!\n", sc->sc_dev.dv_xname);
@


1.31
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.30 2010/05/20 00:55:17 krw Exp $	*/
a95 10
/* the below structure is so we have a default dev struct for out link struct */
struct scsi_device adv_dev =
{
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};


a515 1
	sc->sc_link.device = &adv_dev;
@


1.30
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.29 2010/05/19 15:27:34 oga Exp $	*/
a43 1
#include <sys/user.h>
@


1.29
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.28 2010/03/23 01:57:19 krw Exp $	*/
a658 1
			s = splbio();
a659 1
			splx(s);
@


1.28
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.27 2010/01/10 00:10:23 krw Exp $	*/
d127 2
a128 1
			   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d164 1
a174 1
	bzero(ccbstore, sizeof(ADV_CCB) * count);
@


1.27
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.26 2009/09/04 04:57:14 miod Exp $	*/
d71 1
a71 1
static int adv_scsi_cmd(struct scsi_xfer *);
d574 1
a574 1
static int
d594 2
d597 1
a597 1
		return (NO_CCB);
d661 1
a661 1
			return (COMPLETE);
d704 1
a704 1
		return (SUCCESSFULLY_QUEUED);
a713 2

	return (COMPLETE);
@


1.26
log
@Missing scsi_done() in some error path returning COMPLETE; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.25 2009/08/29 13:58:51 jasper Exp $	*/
a655 1
			xs->flags |= ITSDONE;
a931 1
	xs->flags |= ITSDONE;
@


1.25
log
@remove more unneeded Debugger() calls from dev/

agreed by deraadt@@
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.24 2009/02/16 21:19:06 miod Exp $	*/
d656 4
d713 1
@


1.24
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.23 2009/01/21 21:53:59 grange Exp $	*/
a54 5
#ifndef DDB
#define	Debugger()	panic("should call debugger here (adv.c)")
#endif /* ! DDB */


d864 1
a864 2
		printf("%s: exiting ccb not allocated!\n", sc->sc_dev.dv_xname);
		Debugger();
@


1.23
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.22 2008/11/26 16:38:00 krw Exp $	*/
d77 1
a77 1
static void advminphys(struct buf *);
d567 1
a567 2
advminphys(bp)
	struct buf     *bp;
a568 1

@


1.22
log
@Stop maintaining internal queues of received scsi_xfer structures.

We can now just push unwanted ones back up into the SCSI layer
with NO_CCB like other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.21 2008/11/24 00:31:35 krw Exp $	*/
d323 1
a323 2
			timeout_add(&xs->stimeout,
				(ADV_WATCH_TIMEOUT * hz) / 1000);
d330 1
a330 1
			timeout_add(&xs->stimeout, (ccb->timeout * hz) / 1000);
@


1.21
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.20 2008/09/12 11:14:04 miod Exp $	*/
a64 3
static void adv_enqueue(ASC_SOFTC *, struct scsi_xfer *, int);
static struct scsi_xfer *adv_dequeue(ASC_SOFTC *);

a116 47
/*                            scsi_xfer queue routines                      */
/******************************************************************************/


/*
 * Insert a scsi_xfer into the software queue.  We overload xs->free_list
 * to avoid having to allocate additional resources (since we're used
 * only during resource shortages anyhow.
 */
static void
adv_enqueue(sc, xs, infront)
	ASC_SOFTC      *sc;
	struct scsi_xfer *xs;
	int             infront;
{

	if (infront || LIST_EMPTY(&sc->sc_queue)) {
		if (LIST_EMPTY(&sc->sc_queue))
			sc->sc_queuelast = xs;
		LIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);
		return;
	}
	LIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);
	sc->sc_queuelast = xs;
}


/*
 * Pull a scsi_xfer off the front of the software queue.
 */
static struct scsi_xfer *
adv_dequeue(sc)
	ASC_SOFTC      *sc;
{
	struct scsi_xfer *xs;

	xs = LIST_FIRST(&sc->sc_queue);
	LIST_REMOVE(xs, free_list);

	if (LIST_EMPTY(&sc->sc_queue))
		sc->sc_queuelast = NULL;

	return (xs);
}


/******************************************************************************/
a538 1
	LIST_INIT(&sc->sc_queue);
a590 2
	int             fromqueue = 1, dontqueue = 0;

a594 34
         * If we're running the queue from adv_done(), we've been
         * called with the first queue entry as our argument.
         */
	if (xs == LIST_FIRST(&sc->sc_queue)) {
		xs = adv_dequeue(sc);
		fromqueue = 1;
	} else {

		/* Polled requests can't be queued for later. */
		dontqueue = xs->flags & SCSI_POLL;

		/*
                 * If there are jobs in the queue, run them first.
                 */
		if (!LIST_EMPTY(&sc->sc_queue)) {
			/*
                         * If we can't queue, we have to abort, since
                         * we have to preserve order.
                         */
			if (dontqueue) {
				splx(s);
				return (TRY_AGAIN_LATER);
			}
			/*
                         * Swap with the first queue entry.
                         */
			adv_enqueue(sc, xs, 0);
			xs = adv_dequeue(sc);
			fromqueue = 1;
		}
	}


	/*
a601 12
		/*
                 * If we can't queue, we lose.
                 */
		if (dontqueue) {
			splx(s);
			return (NO_CCB);
		}
		/*
                 * Stuff ourselves into the queue, in front
                 * if we came off in the first place.
                 */
		adv_enqueue(sc, xs, fromqueue);
d603 1
a603 1
		return (SUCCESSFULLY_QUEUED);
a702 4
	s = splbio();
	adv_queue_ccb(sc, ccb);
	splx(s);

a725 1
	struct scsi_xfer *xs;
a740 11

	/*
         * If there are queue entries in the software queue, try to
         * run the first one.  We should be more or less guaranteed
         * to succeed, since we just freed a CCB.
         *
         * NOTE: adv_scsi_cmd() relies on our calling it with
         * the first entry in the queue.
         */
	if ((xs = LIST_FIRST(&sc->sc_queue)) != NULL)
		(void) adv_scsi_cmd(xs);
@


1.20
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.19 2008/06/26 05:42:15 ray Exp $	*/
d694 1
a694 1
			return (TRY_AGAIN_LATER);
@


1.19
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.18 2007/11/05 20:50:20 krw Exp $	*/
d746 3
a748 12
#ifdef TFS
		if (flags & SCSI_DATA_UIO) {
			error = bus_dmamap_load_uio(dmat,
				  ccb->dmamap_xfer, (struct uio *) xs->data,
						    (flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		} else
#endif				/* TFS */
		{
			error = bus_dmamap_load(dmat,
			      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,
						(flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		}
@


1.18
log
@More scsi_done() at SPLBIO. Wrap more interrupt function calls while
polling in splbio/splx.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.17 2006/11/29 01:00:47 grange Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.17
log
@Unbreak. No cookie for dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.16 2006/11/28 23:59:45 dlg Exp $	*/
d886 1
d890 1
d892 1
@


1.16
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.15 2005/12/03 16:53:15 krw Exp $	*/
d620 1
a620 1
	saa->sa_sc_link = &sc->sc_link;
@


1.15
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.14 2004/12/26 21:22:13 miod Exp $	*/
d552 2
a553 1
	int             i, error;
d618 4
a621 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
@


1.14
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.13 2004/01/09 21:32:23 brad Exp $	*/
a671 1
				xs->error = XS_DRIVER_STUFFUP;
a696 1
			xs->error = XS_DRIVER_STUFFUP;
@


1.13
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.12 2002/03/14 01:26:53 millert Exp $	*/
d143 2
a144 2
	if (infront || sc->sc_queue.lh_first == NULL) {
		if (sc->sc_queue.lh_first == NULL)
d163 1
a163 1
	xs = sc->sc_queue.lh_first;
d166 1
a166 1
	if (sc->sc_queue.lh_first == NULL)
d269 1
a269 1
	if (ccb->chain.tqe_next == 0)
d329 1
a329 1
		ccb = sc->sc_free_ccb.tqh_first;
d371 1
a371 1
	while ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {
d654 1
a654 1
	if (xs == sc->sc_queue.lh_first) {
d665 1
a665 1
		if (sc->sc_queue.lh_first != NULL) {
d868 1
a868 1
	if ((xs = sc->sc_queue.lh_first) != NULL)
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.11 2001/11/06 19:53:18 miod Exp $	*/
a54 2

#include <uvm/uvm_extern.h>
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.10 2001/11/05 17:25:58 art Exp $	*/
d74 2
a75 2
static void adv_enqueue __P((ASC_SOFTC *, struct scsi_xfer *, int));
static struct scsi_xfer *adv_dequeue __P((ASC_SOFTC *));
d77 18
a94 18
static int adv_alloc_ccbs __P((ASC_SOFTC *));
static int adv_create_ccbs __P((ASC_SOFTC *, ADV_CCB *, int));
static void adv_free_ccb __P((ASC_SOFTC *, ADV_CCB *));
static void adv_reset_ccb __P((ADV_CCB *));
static int adv_init_ccb __P((ASC_SOFTC *, ADV_CCB *));
static ADV_CCB *adv_get_ccb __P((ASC_SOFTC *, int));
static void adv_queue_ccb __P((ASC_SOFTC *, ADV_CCB *));
static void adv_start_ccbs __P((ASC_SOFTC *));

static u_int8_t *adv_alloc_overrunbuf __P((char *dvname, bus_dma_tag_t));

static int adv_scsi_cmd __P((struct scsi_xfer *));
static void advminphys __P((struct buf *));
static void adv_narrow_isr_callback __P((ASC_SOFTC *, ASC_QDONE_INFO *));

static int adv_poll __P((ASC_SOFTC *, struct scsi_xfer *, int));
static void adv_timeout __P((void *));
static void adv_watchdog __P((void *));
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.11 2001/11/06 19:53:18 miod Exp $	*/
d74 2
a75 2
static void adv_enqueue(ASC_SOFTC *, struct scsi_xfer *, int);
static struct scsi_xfer *adv_dequeue(ASC_SOFTC *);
d77 18
a94 18
static int adv_alloc_ccbs(ASC_SOFTC *);
static int adv_create_ccbs(ASC_SOFTC *, ADV_CCB *, int);
static void adv_free_ccb(ASC_SOFTC *, ADV_CCB *);
static void adv_reset_ccb(ADV_CCB *);
static int adv_init_ccb(ASC_SOFTC *, ADV_CCB *);
static ADV_CCB *adv_get_ccb(ASC_SOFTC *, int);
static void adv_queue_ccb(ASC_SOFTC *, ADV_CCB *);
static void adv_start_ccbs(ASC_SOFTC *);

static u_int8_t *adv_alloc_overrunbuf(char *dvname, bus_dma_tag_t);

static int adv_scsi_cmd(struct scsi_xfer *);
static void advminphys(struct buf *);
static void adv_narrow_isr_callback(ASC_SOFTC *, ASC_QDONE_INFO *);

static int adv_poll(ASC_SOFTC *, struct scsi_xfer *, int);
static void adv_timeout(void *);
static void adv_watchdog(void *);
@


1.10
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.9 2001/08/26 18:03:07 krw Exp $	*/
d56 1
a56 1
#include <vm/vm.h>
@


1.9
log
@Prepare for transition to 5-parameter bus_dmamap_sync() by creating and
using adv_bus_dmamap_sync() defines that are defined appropriately
depending on __HAS_NEW_BUS_DMAMAP_SYNC.

The code changes are simple reversions to the original NetBSD code.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.8 2001/08/12 20:33:50 mickey Exp $	*/
d781 1
a781 1
		adv_bus_dmamap_sync(dmat, ccb->dmamap_xfer,
d993 1
a993 1
		adv_bus_dmamap_sync(dmat, ccb->dmamap_xfer,
@


1.8
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.7 2001/08/12 20:12:11 mickey Exp $	*/
d781 4
a784 3
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
			      (flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
				BUS_DMASYNC_PREWRITE);
d993 4
a996 3
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
			 (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
				BUS_DMASYNC_POSTWRITE);
@


1.7
log
@remove some of the redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.6 2000/12/13 15:49:15 mickey Exp $	*/
a56 1
#include <vm/vm_param.h>
@


1.6
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.5 1999/08/04 23:27:48 niklas Exp $	*/
a57 1
#include <vm/pmap.h>
@


1.5
log
@new bus_dma API, match it
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.4 1998/11/17 06:08:15 downsj Exp $	*/
d361 1
d373 1
d376 2
d379 1
a379 1
			untimeout(adv_watchdog, ccb);
d383 2
a384 1
			timeout(adv_watchdog, ccb,
d390 4
a393 2
		if ((ccb->xs->flags & SCSI_POLL) == 0)
			timeout(adv_timeout, ccb, (ccb->timeout * hz) / 1000);
d987 1
a987 1
	untimeout(adv_timeout, ccb);
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.6 2000/12/13 15:49:15 mickey Exp $	*/
a360 1
	timeout_set(&ccb->xs->stimeout, adv_timeout, ccb);
a371 1
	struct scsi_xfer *xs;
a373 2

		xs = ccb->xs;
d375 1
a375 1
			timeout_del(&xs->stimeout);
d379 1
a379 2
			timeout_set(&xs->stimeout, adv_watchdog, ccb);
			timeout_add(&xs->stimeout,
d385 2
a386 4
		if ((ccb->xs->flags & SCSI_POLL) == 0) {
			timeout_set(&xs->stimeout, adv_timeout, ccb);
			timeout_add(&xs->stimeout, (ccb->timeout * hz) / 1000);
		}
d980 1
a980 1
	timeout_del(&xs->stimeout);
@


1.5.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.5.4.1 2001/05/14 22:23:20 niklas Exp $	*/
d57 2
d783 3
a785 4
		adv_bus_dmamap_sync(dmat, ccb->dmamap_xfer,
		    0, ccb->dmamap_xfer->dm_mapsize,
		    ((flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
			BUS_DMASYNC_PREWRITE));
d994 3
a996 4
		adv_bus_dmamap_sync(dmat, ccb->dmamap_xfer,
		    0, ccb->dmamap_xfer->dm_mapsize,
		    ((xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
			BUS_DMASYNC_POSTWRITE));
@


1.5.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
#include <uvm/uvm_extern.h>
d781 1
a781 1
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
d993 1
a993 1
		bus_dmamap_sync(dmat, ccb->dmamap_xfer,
@


1.5.4.4
log
@Merge in -current from about a week ago
@
text
@d74 2
a75 2
static void adv_enqueue(ASC_SOFTC *, struct scsi_xfer *, int);
static struct scsi_xfer *adv_dequeue(ASC_SOFTC *);
d77 8
a84 8
static int adv_alloc_ccbs(ASC_SOFTC *);
static int adv_create_ccbs(ASC_SOFTC *, ADV_CCB *, int);
static void adv_free_ccb(ASC_SOFTC *, ADV_CCB *);
static void adv_reset_ccb(ADV_CCB *);
static int adv_init_ccb(ASC_SOFTC *, ADV_CCB *);
static ADV_CCB *adv_get_ccb(ASC_SOFTC *, int);
static void adv_queue_ccb(ASC_SOFTC *, ADV_CCB *);
static void adv_start_ccbs(ASC_SOFTC *);
d86 1
a86 1
static u_int8_t *adv_alloc_overrunbuf(char *dvname, bus_dma_tag_t);
d88 3
a90 3
static int adv_scsi_cmd(struct scsi_xfer *);
static void advminphys(struct buf *);
static void adv_narrow_isr_callback(ASC_SOFTC *, ASC_QDONE_INFO *);
d92 3
a94 3
static int adv_poll(ASC_SOFTC *, struct scsi_xfer *, int);
static void adv_timeout(void *);
static void adv_watchdog(void *);
@


1.5.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d56 2
@


1.4
log
@Move offsetof define.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.3 1998/11/17 04:25:21 downsj Exp $	*/
d200 1
a200 1
				 BUS_DMA_NOWAIT | BUS_DMAMEM_NOSYNC)) != 0) {
d427 1
a427 1
	(caddr_t *) & overrunbuf, BUS_DMA_NOWAIT | BUS_DMAMEM_NOSYNC)) != 0) {
@


1.3
log
@Sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: adv.c,v 1.2 1998/09/28 01:56:56 downsj Exp $	*/
a723 1
#define offsetof(type, member) ((size_t)(&((type *)0)->member))
a725 1
#undef offsetof
@


1.2
log
@Sync w/ NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: adv.c,v 1.1 1998/09/27 03:36:13 downsj Exp $	*/
/*	$NetBSD: adv.c,v 1.4 1998/09/26 16:02:56 dante Exp $	*/
d70 3
d808 6
d843 9
d853 4
d976 6
d1002 3
@


1.1
log
@AdvanSys SCSI driver from NetBSD, by dante@@mclink.it.  Based on the Linux
driver.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: adv.c,v 1.3 1998/09/09 05:28:58 thorpej Exp $	*/
d5 1
a5 1
 * Generic driver for the Advanced Systems Inc. SCSI controllers
d22 2
a23 2
 *    This product includes software developed by the NetBSD
 *    Foundation, Inc. and its contributors.
d465 2
a466 3
	if (ASC_IS_NARROW_BOARD(sc)) {
		if (!AscFindSignature(sc->sc_iot, sc->sc_ioh))
			panic("adv_init: adv_find_signature failed");
d468 36
a503 36
		/*
                 * Read the board configuration
                 */
		AscInitASC_SOFTC(sc);
		warn = AscInitFromEEP(sc);
		if (warn) {
			printf("%s -get: ", sc->sc_dev.dv_xname);
			switch (warn) {
			case -1:
				printf("Chip is not halted\n");
				break;

			case -2:
				printf("Couldn't get MicroCode Start"
				       " address\n");
				break;

			case ASC_WARN_IO_PORT_ROTATE:
				printf("I/O port address modified\n");
				break;

			case ASC_WARN_AUTO_CONFIG:
				printf("I/O port increment switch enabled\n");
				break;

			case ASC_WARN_EEPROM_CHKSUM:
				printf("EEPROM checksum error\n");
				break;

			case ASC_WARN_IRQ_MODIFIED:
				printf("IRQ modified\n");
				break;

			case ASC_WARN_CMD_QNG_CONFLICT:
				printf("tag queuing enabled w/o disconnects\n");
				break;
d505 2
a506 3
			default:
				printf("unknown warning %d\n", warn);
			}
d508 14
a521 2
		if (sc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)
			sc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;
d523 3
a525 14
		/*
                 * Modify the board configuration
                 */
		warn = AscInitFromASC_SOFTC(sc);
		if (warn) {
			printf("%s -set: ", sc->sc_dev.dv_xname);
			switch (warn) {
			case ASC_WARN_CMD_QNG_CONFLICT:
				printf("tag queuing enabled w/o disconnects\n");
				break;

			case ASC_WARN_AUTO_CONFIG:
				printf("I/O port increment switch enabled\n");
				break;
d527 2
a528 3
			default:
				printf("unknown warning %d\n", warn);
			}
d530 2
a531 1
		sc->isr_callback = (ulong) adv_narrow_isr_callback;
d533 2
a534 9
		if (!(sc->overrun_buf = adv_alloc_overrunbuf(sc->sc_dev.dv_xname,
							     sc->sc_dmat))) {
			return (1);
		}
	} else
		//IS_WIDE_BOARD
	{
		printf("%s: Wide boards are not supported yet\n",
		       sc->sc_dev.dv_xname);
d548 7
a554 8
	if (ASC_IS_NARROW_BOARD(sc)) {
		/*
                 * Initialize board RISC chip and enable interrupts.
                 */
		switch (AscInitDriver(sc)) {
		case 0:
			/* AllOK */
			break;
d556 3
a558 3
		case 1:
			panic("%s: bad signature", sc->sc_dev.dv_xname);
			break;
d560 4
a563 4
		case 2:
			panic("%s: unable to load MicroCode",
			      sc->sc_dev.dv_xname);
			break;
d565 4
a568 4
		case 3:
			panic("%s: unable to initialize MicroCode",
			      sc->sc_dev.dv_xname);
			break;
d570 3
a572 8
		default:
			panic("%s: unable to initialize board RISC chip",
			      sc->sc_dev.dv_xname);
		}
	} else
		//Wide Boards
	{
		/* ToDo */
d584 1
a584 1
	sc->sc_link.adapter_buswidth = ASC_IS_NARROW_BOARD(sc) ? 7 : 15;
d834 1
a834 7
	if (ASC_IS_NARROW_BOARD(sc)) {
		AscISR(sc);
	} else
		//Wide Boards
	{
		/* ToDo AdvISR */
	}
d1009 1
a1009 1
			} else
d1011 1
@

