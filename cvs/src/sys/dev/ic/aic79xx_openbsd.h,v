head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.6
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.10
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.8
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.30
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.28
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.24
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.22
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.18
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.20
	OPENBSD_5_0:1.17.0.16
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.14
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.12
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.8
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.19
date	2015.07.17.21.42.49;	author krw;	state Exp;
branches;
next	1.18;
commitid	bEhopXwWgYXDvWRJ;

1.18
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.17;
commitid	uzzBR7hz9ncd4O6G;

1.17
date	2007.10.01.12.10.55;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.10.11.45.43;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.30.17.29.55;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.24.22.17.56;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.20.20.56.32;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.18.18.29.56;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.16.01.33.26;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.13.04.07.26;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.23.05.15.35;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.18.01.33.28;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.14.01.25.14;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.24.04.40.06;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.23.20.16.01;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.06.01.29.19;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.23.05.29.31;	author marco;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.05.20.04.35.47;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.03.11.45;	author marco;	state Exp;
branches;
next	;

1.3.2.1
date	2004.06.05.23.12.39;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Nuke a bunch of leading and trailing whitespace so I don't go blind
reading this code. No intentional functional change.
@
text
@/*	$OpenBSD: aic79xx_openbsd.h,v 1.18 2014/09/14 14:17:24 jsg Exp $	*/

/*
 * Copyright (c) 2004 Milos Urbanek, Kenneth R. Westerback & Marco Peereboom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * FreeBSD platform specific driver option settings, data structures,
 * function declarations and includes.
 *
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2001-2002 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aic79xx_osm.h,v 1.13 2003/12/17 00:02:09 gibbs Exp $
 *
 */

#ifndef _AIC79XX_OPENBSD_H_
#define _AIC79XX_OPENBSD_H_

#include "pci.h"		/* for config options */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/queue.h>

#define AIC_PCI_CONFIG 1
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_message.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>

#include <uvm/uvm_extern.h>

#ifdef DEBUG
#define bootverbose     1
#else
#define bootverbose     0
#endif
/****************************** Platform Macros *******************************/
#define	SCSI_IS_SCSIBUS_B(ahd, sc_link)	\
	(0)
#define	SCSI_CHANNEL(ahd, sc_link)	\
	('A')
#define	SCSI_SCSI_ID(ahd, sc_link)	\
	(ahd->our_id)
#define BUILD_SCSIID(ahd, sc_link, target_id, our_id) \
	((((target_id) << TID_SHIFT) & TID) | (our_id))

#ifndef offsetof
#define offsetof(type, member)  ((size_t)(&((type *)0)->member))
#endif

/************************* Forward Declarations *******************************/
typedef struct pci_attach_args * ahd_dev_softc_t;

/***************************** Bus Space/DMA **********************************/

/* XXX Need to update Bus DMA for partial map syncs */
#define ahd_dmamap_sync(ahc, dma_tag, dmamap, offset, len, op)		\
	bus_dmamap_sync(dma_tag, dmamap, offset, len, op)

/************************ Tunable Driver Parameters  **************************/
/*
 * The number of dma segments supported.  The sequencer can handle any number
 * of physically contiguous S/G entries.  To reduce the driver's memory
 * consumption, we limit the number supported to be sufficient to handle
 * the largest mapping supported by the kernel, MAXPHYS.  Assuming the
 * transfer is as fragmented as possible and unaligned, this turns out to
 * be the number of paged sized transfers in MAXPHYS plus an extra element
 * to handle any unaligned residual.  The sequencer fetches SG elements
 * in cacheline sized chucks, so make the number per-transaction an even
 * multiple of 16 which should align us on even the largest of cacheline
 * boundaries.
 */
#define AHD_NSEG (roundup(atop(MAXPHYS) + 1, 16))

/* This driver supports target mode */
// #define AHD_TARGET_MODE 1

/************************** Softc/SCB Platform Data ***************************/
struct ahd_platform_data {
};

struct scb_platform_data {
};

/************************** Timer DataStructures ******************************/
typedef struct timeout aic_timer_t;

/***************************** Core Includes **********************************/

#if AHD_REG_PRETTY_PRINT
#define AIC_DEBUG_REGISTERS 1
#else
#define AIC_DEBUG_REGISTERS 0
#endif
#include <dev/ic/aic79xx.h>

/***************************** Timer Facilities *******************************/
void ahd_timeout(void*);
void aic_timer_reset(aic_timer_t *, u_int, ahd_callback_t *, void *);
void aic_scb_timer_reset(struct scb *, u_int);

#define aic_timer_stop timeout_del
#define aic_get_timeout(scb) ((scb)->xs->timeout)
/*************************** Device Access ************************************/
#define ahd_inb(ahd, port)					\
	bus_space_read_1((ahd)->tags[(port) >> 8],		\
			 (ahd)->bshs[(port) >> 8], (port) & 0xFF)

#define ahd_outb(ahd, port, value)				\
	bus_space_write_1((ahd)->tags[(port) >> 8],		\
			  (ahd)->bshs[(port) >> 8], (port) & 0xFF, value)

#define ahd_inw_atomic(ahd, port)				\
	aic_le16toh(bus_space_read_2((ahd)->tags[(port) >> 8],	\
				     (ahd)->bshs[(port) >> 8], (port) & 0xFF))

#define ahd_outw_atomic(ahd, port, value)			\
	bus_space_write_2((ahd)->tags[(port) >> 8],		\
			  (ahd)->bshs[(port) >> 8],		\
			  (port & 0xFF), aic_htole16(value))

#define ahd_outsb(ahd, port, valp, count)			\
	bus_space_write_multi_1((ahd)->tags[(port) >> 8],	\
				(ahd)->bshs[(port) >> 8],	\
				(port & 0xFF), valp, count)

#define ahd_insb(ahd, port, valp, count)			\
	bus_space_read_multi_1((ahd)->tags[(port) >> 8],	\
			       (ahd)->bshs[(port) >> 8],	\
			       (port & 0xFF), valp, count)

void ahd_flush_device_writes(struct ahd_softc *);

/**************************** Locking Primitives ******************************/
/* Lock protecting internal data structures */
#define ahd_lockinit(ahd)
#define ahd_lock(ahd, flags) *(flags) = splbio()
#define ahd_unlock(ahd, flags) splx(*(flags))

/* Lock held during command completion to the upper layer */
#define ahd_done_lockinit(ahd)
#define ahd_done_lock(ahd, flags)
#define ahd_done_unlock(ahd, flags)

/* Lock held during ahd_list manipulation and ahd softc frees */
#define ahd_list_lockinit(x)
#define ahd_list_lock(flags) *(flags) = splbio()
#define ahd_list_unlock(flags) splx(*(flags))

/****************************** OS Primitives *********************************/
#define scsi_4btoul(b)	(_4btol(b))

/************************** Transaction Operations ****************************/
#define aic_set_transaction_status(scb, status) (scb)->xs->error = (status)
#define aic_set_scsi_status(scb, status) (scb)->xs->xs_status = (status)
#define aic_set_transaction_tag(scb, enabled, type)
#define aic_set_residual(scb, residual) (scb)->xs->resid = (residual)
#define aic_set_sense_residual(scb, residual) (scb)->xs->resid = (residual)

#define aic_get_transaction_status(scb) \
	(((scb)->xs->flags & ITSDONE) ? CAM_REQ_CMP : (scb)->xs->error)
#define aic_get_scsi_status(scb) ((scb)->xs->status)
#define aic_get_transfer_length(scb) ((scb)->xs->datalen)
#define aic_get_transfer_dir(scb) \
	((scb)->xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT))
#define aic_get_residual(scb) ((scb)->xs->resid)
#define aic_get_sense_bufsize(ahd, scb) (sizeof(struct scsi_sense_data))

#define aic_perform_autosense(scb) (1)

#define aic_freeze_simq(ahd)
#define aic_release_simq(ahd)
#define aic_freeze_scb(scb)
#define ahd_platform_freeze_devq(ahd, scb)
#define ahd_platform_abort_scbs(ahd, target, channel, lun, tag, role, status)

void aic_platform_scb_free(struct ahd_softc *, struct scb *);

/********************************** PCI ***************************************/
/*#if AHD_PCI_CONFIG > 0*/
#define aic_get_pci_function(pci) ((pci)->pa_function)
#define aic_get_pci_slot(pci) ((pci)->pa_device)
#define aic_get_pci_bus(pci) ((pci)->pa_bus)

int			ahd_pci_map_registers(struct ahd_softc *);
int			ahd_pci_map_int(struct ahd_softc *);
/*#endif*/

typedef enum
{
	AHD_POWER_STATE_D0,
	AHD_POWER_STATE_D1,
	AHD_POWER_STATE_D2,
	AHD_POWER_STATE_D3
} ahd_power_state;

void ahd_power_state_change(struct ahd_softc *, ahd_power_state);

/********************************* Debug **************************************/
void	ahd_print_path(struct ahd_softc *, struct scb *);
void	ahd_platform_dump_card_state(struct ahd_softc *ahd);

/**************************** Transfer Settings *******************************/
void	  ahd_notify_xfer_settings_change(struct ahd_softc *,
					  struct ahd_devinfo *);
void	  ahd_platform_set_tags(struct ahd_softc *, struct ahd_devinfo *,
				ahd_queue_alg);

/************************* Initialization/Teardown ****************************/
int	  ahd_platform_alloc(struct ahd_softc *, void *);
void	  ahd_platform_free(struct ahd_softc *);
int	  ahd_attach(struct ahd_softc *);
int	  ahd_softc_comp(struct ahd_softc *lahd, struct ahd_softc *rahd);
int	  ahd_detach(struct device *, int);

#define	ahd_platform_init(ahd)

/****************************** Interrupts ************************************/
int			ahd_platform_intr(void *);
void	ahd_platform_flushwork(struct ahd_softc *ahd);
/************************ Misc Function Declarations **************************/
void	  ahd_done(struct ahd_softc *, struct scb *);
void	  ahd_send_async(struct ahd_softc *, char /*channel*/,
			 u_int /*target*/, u_int /*lun*/, ac_code, void *arg);
#endif  /* _AIC79XX_OPENBSD_H_ */
@


1.18
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.17 2007/10/01 12:10:55 martin Exp $	*/
d95 1
a95 1
#else 
d132 1
a132 1
 * boundaries. 
d229 1
a229 1
	
@


1.17
log
@more btoc -> atop
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.16 2005/12/10 11:45:43 miod Exp $	*/
a76 1
#include <sys/proc.h>
@


1.16
log
@{en,re}trys -> {en,re}tries; eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.15 2004/12/30 17:29:55 krw Exp $	*/
d135 1
a135 1
#define AHD_NSEG (roundup(btoc(MAXPHYS) + 1, 16))
@


1.15
log
@Current ahd timeout code does nothing. Add fbsd style timeout
handling which will at least try to recover.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.14 2004/12/24 22:17:56 krw Exp $	*/
d125 1
a125 1
 * of physically contiguous S/G entrys.  To reduce the driver's memory
@


1.14
log
@Kill bit of ahc cruft. Elminate lots of leading spaces. Other KNF. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.13 2004/12/20 20:56:32 krw Exp $	*/
d165 1
a165 1

@


1.13
log
@Activate packetized status handling.

ok tdeval@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.12 2004/12/18 18:29:56 krw Exp $	*/
d107 2
a108 2
        ((((target_id) << TID_SHIFT) & TID) | (our_id))
        
@


1.12
log
@Use SIU_TASKMGMT_* defines from scsi_all.h rather than local duplicates.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.11 2004/12/16 01:33:26 krw Exp $	*/
d213 1
@


1.11
log
@Delete VL/EISA cruft left over from ahc.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.10 2004/12/13 04:07:26 krw Exp $	*/
a285 8
/************************ SCSI task management **************************/
#define SIU_TASKMGMT_NONE               0x00
#define SIU_TASKMGMT_ABORT_TASK         0x01
#define SIU_TASKMGMT_ABORT_TASK_SET     0x02
#define SIU_TASKMGMT_CLEAR_TASK_SET     0x04
#define SIU_TASKMGMT_LUN_RESET          0x08
#define SIU_TASKMGMT_TARGET_RESET       0x20
#define SIU_TASKMGMT_CLEAR_ACA          0x40
@


1.10
log
@Use millisends rather than microseconds in parameters to timer
functions, and ultra-conservative calculations, to avoid possible
overflow issues. Also consistant with values passed in scsi requests.

Whitespace and comment tweaks.

Update FreeBSD tags now that we are sync'd to the latest version.

From FreeBSD aic79xx.c r1.33, aic79xx.h r1.23, aic_osm_lib.h r1.4.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.9 2004/11/23 05:15:35 krw Exp $	*/
a258 4

/******************************** VL/EISA *************************************/
int aic7770_map_registers(struct ahd_softc *);
int aic7770_map_int(struct ahd_softc *, int);
@


1.9
log
@More FreeBSD delta reduction. Use aic_* defines rather than ahd_* one
line and zero line functions. Fix a potential bug
(ahd_set_transaction_status was used where ahd_set_scsi_status was
intended) inside a currently #ifdef 0/#endif section of code.

No functional changes intended except for a bit of extra locking via
ahd_list_lock*.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.8 2004/11/18 01:33:28 krw Exp $	*/
d161 1
a164 1
#define aic_timer_reset callout_reset
@


1.8
log
@More NetBSD cruft removal/FreeBSD delta reduction. Whitespace, function and variable shuffle. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.7 2004/11/14 01:25:14 krw Exp $	*/
d148 1
a148 1
typedef struct timeout ahd_timer_t;
d161 1
a161 2
void ahd_timer_reset(ahd_timer_t *, u_int, ahd_callback_t *, void *);
void ahd_scb_timer_reset(struct scb *, u_int);
d163 2
a164 2
#define ahd_timer_init callout_init
#define ahd_timer_stop callout_stop
d198 8
a205 8
void ahd_lockinit(struct ahd_softc *);
void ahd_lock(struct ahd_softc *, int *flags);
void ahd_unlock(struct ahd_softc *, int *flags);

/* Lock held during command compeletion to the upper layer */
void ahd_done_lockinit(struct ahd_softc *);
void ahd_done_lock(struct ahd_softc *, int *flags);
void ahd_done_unlock(struct ahd_softc *, int *flags);
d208 3
a210 3
void ahd_list_lockinit(void);
void ahd_list_lock(int *flags);
void ahd_list_unlock(int *flags);
d215 24
a238 19
void ahd_set_transaction_status(struct scb *, uint32_t);
void ahd_set_scsi_status(struct scb *, uint32_t);
uint32_t ahd_get_transaction_status(struct scb *);
uint32_t ahd_get_scsi_status(struct scb *);
void ahd_set_transaction_tag(struct scb *, int, u_int);
u_long ahd_get_transfer_length(struct scb *);
int ahd_get_transfer_dir(struct scb *);
void ahd_set_residual(struct scb *, u_long);
void ahd_set_sense_residual(struct scb *, u_long);
u_long ahd_get_residual(struct scb *);
int ahd_perform_autosense(struct scb *);
uint32_t ahd_get_sense_bufsize(struct ahd_softc*, struct scb*);
void ahd_freeze_simq(struct ahd_softc *);
void ahd_release_simq(struct ahd_softc *);
void ahd_freeze_scb(struct scb *);
void ahd_platform_freeze_devq(struct ahd_softc *, struct scb *);
int  ahd_platform_abort_scbs(struct ahd_softc *, int,
		    char, int, u_int, role_t, uint32_t);
void ahd_platform_scb_free(struct ahd_softc *, struct scb *);
d242 3
a244 3
int	ahd_get_pci_function(ahd_dev_softc_t);
int	ahd_get_pci_slot(ahd_dev_softc_t);
int	ahd_get_pci_bus(ahd_dev_softc_t);
d280 2
a281 1
#define	ahd_platform_init
@


1.7
log
@More NetBSD cruft removal, starting with 'struct ahd_pci_busdata' and
the fallout from that. Ensure pcireg_t variables are being used with
pci_conf_read/write functions - found one uint16_t variable
(pcix_status) being used to store and restore (32 bit) pcireg_t
values.

Some KNF.

No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.6 2004/10/24 04:40:06 krw Exp $	*/
a162 3

ahd_callback_t  ahd_reset_poll;
ahd_callback_t  ahd_stat_timer;
@


1.6
log
@Missed file from previous aic diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.5 2004/08/23 20:16:01 marco Exp $	*/
a240 3
uint32_t ahd_pci_read_config(ahd_dev_softc_t, int, int);
void	ahd_pci_write_config(ahd_dev_softc_t, int,
		uint32_t, int);
@


1.5
log
@Fix license.  ok krw@@, deraadt@@ tedu@@ & Milos Urbanek <urbanek at zoom-int.cz>
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.4 2004/08/06 01:29:19 marco Exp $	*/
a146 15
/********************************* Byte Order *********************************/
#define ahd_htobe16(x) htobe16(x)
#define ahd_htobe32(x) htobe32(x)
#define ahd_htobe64(x) htobe64(x)
#define ahd_htole16(x) htole16(x)
#define ahd_htole32(x) htole32(x)
#define ahd_htole64(x) htole64(x)

#define ahd_be16toh(x) be16toh(x)
#define ahd_be32toh(x) be32toh(x)
#define ahd_be64toh(x) be64toh(x)
#define ahd_le16toh(x) letoh16(x)
#define ahd_le32toh(x) letoh32(x)
#define ahd_le64toh(x) letoh64(x)

d180 1
a180 1
	ahd_le16toh(bus_space_read_2((ahd)->tags[(port) >> 8],	\
d186 1
a186 1
			  (port & 0xFF), ahd_htole16(value))
a216 1
#define ahd_delay DELAY
@


1.4
log
@Remove __static inline to make the kernel ~24k smaller on i386 and make the debug sessions bearable.

ok krw@@ deraadt@@
@
text
@d1 29
a29 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.3 2004/05/23 05:29:31 marco Exp $	*/
a62 5
 *
 * Additional copyrights by:
 * Milos Urbanek
 * Kenneth R. Westerback
 * Marco Peereboom
@


1.3
log
@Hack to prevent uvm_fault when timeout_del deletes a non-existing timer during boot.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.2 2004/05/20 04:35:47 marco Exp $	*/
d153 2
a161 15
static __inline void
ahd_timer_reset(ahd_timer_t *timer, u_int usec, ahd_callback_t *func, void *arg)
{
	callout_reset(timer, (usec * hz)/1000000, func, arg);
}

static __inline void
ahd_scb_timer_reset(struct scb *scb, u_int usec)
{
	if (!(scb->xs->xs_control & XS_CTL_POLL)) {
		callout_reset(&scb->xs->xs_callout,
		    (usec * hz)/1000000, ahd_timeout, scb);
	}
}

d190 1
a190 8
static __inline void ahd_flush_device_writes(struct ahd_softc *);

static __inline void
ahd_flush_device_writes(struct ahd_softc *ahd)
{
	/* XXX Is this sufficient for all architectures??? */
	ahd_inb(ahd, INTSTAT);
}
d194 3
a196 3
static __inline void ahd_lockinit(struct ahd_softc *);
static __inline void ahd_lock(struct ahd_softc *, int *flags);
static __inline void ahd_unlock(struct ahd_softc *, int *flags);
d199 3
a201 41
static __inline void ahd_done_lockinit(struct ahd_softc *);
static __inline void ahd_done_lock(struct ahd_softc *, int *flags);
static __inline void ahd_done_unlock(struct ahd_softc *, int *flags);

/* Lock held during ahd_list manipulation and ahd softc frees */
static __inline void ahd_list_lockinit(void);
static __inline void ahd_list_lock(int *flags);
static __inline void ahd_list_unlock(int *flags);

static __inline void
ahd_lockinit(struct ahd_softc *ahd)
{
}

static __inline void
ahd_lock(struct ahd_softc *ahd, int *flags)
{
	*flags = splbio();
}

static __inline void
ahd_unlock(struct ahd_softc *ahd, int *flags)
{
	splx(*flags);
}

/* Lock held during command compeletion to the upper layer */
static __inline void
ahd_done_lockinit(struct ahd_softc *ahd)
{
}

static __inline void
ahd_done_lock(struct ahd_softc *ahd, int *flags)
{
}

static __inline void
ahd_done_unlock(struct ahd_softc *ahd, int *flags)
{
}
d204 3
a206 14
static __inline void
ahd_list_lockinit(void)
{
}

static __inline void
ahd_list_lock(int *flags)
{
}

static __inline void
ahd_list_unlock(int *flags)
{
}
d212 17
a228 17
static __inline void ahd_set_transaction_status(struct scb *, uint32_t);
static __inline void ahd_set_scsi_status(struct scb *, uint32_t);
static __inline uint32_t ahd_get_transaction_status(struct scb *);
static __inline uint32_t ahd_get_scsi_status(struct scb *);
static __inline void ahd_set_transaction_tag(struct scb *, int, u_int);
static __inline u_long ahd_get_transfer_length(struct scb *);
static __inline int ahd_get_transfer_dir(struct scb *);
static __inline void ahd_set_residual(struct scb *, u_long);
static __inline void ahd_set_sense_residual(struct scb *, u_long);
static __inline u_long ahd_get_residual(struct scb *);
static __inline int ahd_perform_autosense(struct scb *);
static __inline uint32_t ahd_get_sense_bufsize(struct ahd_softc*, struct scb*);
static __inline void ahd_freeze_simq(struct ahd_softc *);
static __inline void ahd_release_simq(struct ahd_softc *);
static __inline void ahd_freeze_scb(struct scb *);
static __inline void ahd_platform_freeze_devq(struct ahd_softc *, struct scb *);
static __inline int  ahd_platform_abort_scbs(struct ahd_softc *, int,
d230 1
a230 132

static __inline
void ahd_set_transaction_status(struct scb *scb, uint32_t status)
{
	scb->xs->error = status;
}

static __inline
void ahd_set_scsi_status(struct scb *scb, uint32_t status)
{
	scb->xs->xs_status = status;
}

static __inline
uint32_t ahd_get_transaction_status(struct scb *scb)
{
	if (scb->xs->flags & ITSDONE)
		return CAM_REQ_CMP;
	else
		return scb->xs->error;
}

static __inline
uint32_t ahd_get_scsi_status(struct scb *scb)
{
	return (scb->xs->status);
}

static __inline
void ahd_set_transaction_tag(struct scb *scb, int enabled, u_int type)
{
}

static __inline
u_long ahd_get_transfer_length(struct scb *scb)
{
	return (scb->xs->datalen);
}

static __inline
int ahd_get_transfer_dir(struct scb *scb)
{
	return (scb->xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT));
}

static __inline
void ahd_set_residual(struct scb *scb, u_long resid)
{
	scb->xs->resid = resid;
}

static __inline
void ahd_set_sense_residual(struct scb *scb, u_long resid)
{
	scb->xs->resid = resid;
}

static __inline
u_long ahd_get_residual(struct scb *scb)
{
	return (scb->xs->resid);
}

static __inline
int ahd_perform_autosense(struct scb *scb)
{
	/* Return true for OpenBSD */
	return (1);
}

static __inline uint32_t
ahd_get_sense_bufsize(struct ahd_softc *ahd, struct scb *scb)
{
	return (sizeof(struct scsi_sense_data));
}

static __inline void
ahd_freeze_simq(struct ahd_softc *ahd)
{
        /* do nothing for now */
}

static __inline void
ahd_release_simq(struct ahd_softc *ahd)
{
        /* do nothing for now */
}

static __inline void
ahd_freeze_scb(struct scb *scb)
{
	struct scsi_xfer *xs = scb->xs;
	int target;

	target = xs->sc_link->target;
	if (!(scb->flags & SCB_FREEZE_QUEUE)) {
		scb->flags |= SCB_FREEZE_QUEUE;
	}
}

static __inline void
ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb)
{
}

static __inline int
ahd_platform_abort_scbs(struct ahd_softc *ahd, int target,
			char channel, int lun, u_int tag,
			role_t role, uint32_t status)
{
	return (0);
}

static __inline void
ahd_platform_scb_free(struct ahd_softc *ahd, struct scb *scb)
{
	int s;

	ahd_lock(ahd, &s);

	if ((ahd->flags & AHD_RESOURCE_SHORTAGE) != 0 ||
	    (scb->flags & SCB_RECOVERY_SCB) != 0) {
		ahd->flags &= ~AHD_RESOURCE_SHORTAGE;
	}

	if (!cold) {
		/* we are no longer in autoconf */
		timeout_del(&scb->xs->stimeout);
	}

	ahd_unlock(ahd, &s);
}
d233 3
a235 3
#if AHD_PCI_CONFIG > 0
static __inline uint32_t ahd_pci_read_config(ahd_dev_softc_t, int, int);
static __inline void	ahd_pci_write_config(ahd_dev_softc_t, int,
d237 3
a239 3
static __inline int	ahd_get_pci_function(ahd_dev_softc_t);
static __inline int	ahd_get_pci_slot(ahd_dev_softc_t);
static __inline int	ahd_get_pci_bus(ahd_dev_softc_t);
d243 1
a243 32

static __inline uint32_t
ahd_pci_read_config(ahd_dev_softc_t pci, int reg, int width)
{
	return (pci_conf_read(pci->pa_pc, pci->pa_tag, reg));
}

static __inline void
ahd_pci_write_config(ahd_dev_softc_t pci, int reg, uint32_t value, int width)
{
	pci_conf_write(pci->pa_pc, pci->pa_tag, reg, value);
}

static __inline int
ahd_get_pci_function(ahd_dev_softc_t pci)
{
	return (pci->pa_function);
}

static __inline int
ahd_get_pci_slot(ahd_dev_softc_t pci)
{
	return (pci->pa_device);
}


static __inline int
ahd_get_pci_bus(ahd_dev_softc_t pci)
{
	return (pci->pa_bus);
}
#endif
d260 2
a261 2
static __inline void	ahd_print_path(struct ahd_softc *, struct scb *);
static __inline void	ahd_platform_dump_card_state(struct ahd_softc *ahd);
a262 13
static __inline void
ahd_print_path(struct ahd_softc *ahd, struct scb *scb)
{
	sc_print_addr(scb->xs->sc_link);
}

static __inline void
ahd_platform_dump_card_state(struct ahd_softc *ahd)
{
	/* Nothing to do here for OpenBSD */
	printf("FEATURES = 0x%x, FLAGS = 0x%x, CHIP = 0x%x BUGS =0x%x\n",
		ahd->features, ahd->flags, ahd->chip, ahd->bugs);
}
d279 1
a279 6
static __inline void	ahd_platform_flushwork(struct ahd_softc *ahd);
static __inline void
ahd_platform_flushwork(struct ahd_softc *ahd)
{
}

@


1.3.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@Remove bogus $Id.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.h,v 1.1 2004/05/20 03:11:45 marco Exp $	*/
d90 2
a91 1
/************************* Forward Declarations *******************************/typedef struct pci_attach_args * ahd_dev_softc_t;
d424 4
a427 1
	timeout_del(&scb->xs->stimeout);
@


1.1
log
@Add ahd.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a32 2
 *
 * $Id: aic79xx_openbsd.h,v 1.2 2004/05/18 08:04:34 openbsd-devel Exp $
@

