head	1.63;
access;
symbols
	OPENBSD_6_0:1.63.0.12
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.6
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.8
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.63.0.4
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.62.0.6
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.62.0.2
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.61.0.2
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.60.0.4
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.6
	OPENBSD_5_0:1.60.0.2
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.45.0.6
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.42.0.4
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.42.0.2
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.22
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.2
	SMP_BASE:1.4;
locks; strict;
comment	@ * @;


1.63
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	EF98ch02VpFassUi;

1.62
date	2013.03.04.00.41.54;	author dlg;	state Exp;
branches;
next	1.61;

1.61
date	2012.08.15.02.38.14;	author jsg;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.09.01.50.41;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.19.23.59.11;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2011.04.19.21.17.07;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2010.08.12.00.26.55;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2010.08.11.02.18.25;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2010.03.29.23.33.39;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.11.14.03.35;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.17.03.21.16;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.28.00.35.16;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.28.00.34.25;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.08.19.52.13;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.07.23.18.59;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.07.20.46.00;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.07.20.34.08;	author marco;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.03.16.53.16;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.03.16.22.24;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.15.05.33.39;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.03.22.31.27;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.12.05.33.04;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.16.09.27.45;	author niklas;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2003.06.28.23.56.40;	author avsm;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2003.06.03.20.49.28;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.25.09.12.39;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.11.03.34.53;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.08.21.26.00;	author nordin;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.05.07.51.06;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.05.07.46.44;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.05.06.58.54;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.12.20.12.12;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.03.15.21.40;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.04.06.43.18;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.13.16.03.11;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.13.15.32.39;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.10.09.42.14;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.19.14.25.15;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.05.18.52.34;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.16.21.47.13;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.01.22.38.51;	author niklas;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.02.13.11.23.15;	author niklas;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.02.13.10.56.41;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.12.09.45.49;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.33.02;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2000.03.02.07.04.38;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.05.14.22.23.48;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2003.05.13.19.35.00;	author ho;	state Exp;
branches;
next	1.4.2.9;

1.4.2.9
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.4.2.10;

1.4.2.10
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	1.4.2.11;

1.4.2.11
date	2004.06.05.23.12.42;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2000.10.20.18.29.26;	author jason;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;

1.26.2.1
date	2004.04.30.23.30.40;	author brad;	state Exp;
branches;
next	;

1.27.2.1
date	2004.04.30.21.54.27;	author brad;	state Exp;
branches;
next	;

1.47.2.1
date	2010.08.19.10.48.53;	author stephan;	state Exp;
branches;
next	;


desc
@@


1.63
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@/*	$OpenBSD: gdt_common.c,v 1.62 2013/03/04 00:41:54 dlg Exp $	*/

/*
 * Copyright (c) 1999, 2000, 2003 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This driver would not have written if it was not for the hardware donations
 * from both ICP-Vortex and Öko.neT.  I want to thank them for their support.
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/biovar.h>
#include <dev/ic/gdtreg.h>
#include <dev/ic/gdtvar.h>

#include "bio.h"

#ifdef GDT_DEBUG
int gdt_maxcmds = GDT_MAXCMDS;
#undef GDT_MAXCMDS
#define GDT_MAXCMDS gdt_maxcmds
#endif

#define GDT_DRIVER_VERSION 1
#define GDT_DRIVER_SUBVERSION 2

int	gdt_async_event(struct gdt_softc *, int);
void	gdt_chain(struct gdt_softc *);
void	gdt_clear_events(struct gdt_softc *);
void	gdt_copy_internal_data(struct scsi_xfer *, u_int8_t *, size_t);
struct scsi_xfer *gdt_dequeue(struct gdt_softc *);
void	gdt_enqueue(struct gdt_softc *, struct scsi_xfer *, int);
void	gdt_enqueue_ccb(struct gdt_softc *, struct gdt_ccb *);
void	gdt_eval_mapping(u_int32_t, int *, int *, int *);
int	gdt_exec_ccb(struct gdt_ccb *);
void	gdt_ccb_free(void *, void *);
void   *gdt_ccb_alloc(void *);
void	gdt_internal_cache_cmd(struct scsi_xfer *);
int	gdt_internal_cmd(struct gdt_softc *, u_int8_t, u_int16_t,
    u_int32_t, u_int32_t, u_int32_t);
#if NBIO > 0
int	gdt_ioctl(struct device *, u_long, caddr_t);
int	gdt_ioctl_inq(struct gdt_softc *, struct bioc_inq *);
int	gdt_ioctl_vol(struct gdt_softc *, struct bioc_vol *);
int	gdt_ioctl_disk(struct gdt_softc *, struct bioc_disk *);
int	gdt_ioctl_alarm(struct gdt_softc *, struct bioc_alarm *);
int	gdt_ioctl_setstate(struct gdt_softc *, struct bioc_setstate *);
#endif /* NBIO > 0 */
void	gdt_scsi_cmd(struct scsi_xfer *);
void	gdt_start_ccbs(struct gdt_softc *);
int	gdt_sync_event(struct gdt_softc *, int, u_int8_t,
    struct scsi_xfer *);
void	gdt_timeout(void *);
int	gdt_wait(struct gdt_softc *, struct gdt_ccb *, int);
void	gdt_watchdog(void *);

struct cfdriver gdt_cd = {
	NULL, "gdt", DV_DULL
};

struct scsi_adapter gdt_switch = {
	gdt_scsi_cmd, gdtminphys, 0, 0,
};

int gdt_cnt = 0;
u_int8_t gdt_polling;
u_int8_t gdt_from_wait;
struct gdt_softc *gdt_wait_gdt;
int	gdt_wait_index;
#ifdef GDT_DEBUG
int	gdt_debug = GDT_DEBUG;
#endif

int
gdt_attach(struct gdt_softc *sc)
{
	struct scsibus_attach_args saa;
	u_int16_t cdev_cnt;
	int i, id, drv_cyls, drv_hds, drv_secs, error, nsegs;

	gdt_polling = 1;
	gdt_from_wait = 0;

	if (bus_dmamem_alloc(sc->sc_dmat, GDT_SCRATCH_SZ, PAGE_SIZE, 0,
	    &sc->sc_scratch_seg, 1, &nsegs, BUS_DMA_NOWAIT))
	    panic("%s: bus_dmamem_alloc failed", DEVNAME(sc));
	if (bus_dmamem_map(sc->sc_dmat, &sc->sc_scratch_seg, 1,
	    GDT_SCRATCH_SZ, &sc->sc_scratch, BUS_DMA_NOWAIT))
	    panic("%s: bus_dmamem_map failed", DEVNAME(sc));

	gdt_clear_events(sc);

	TAILQ_INIT(&sc->sc_free_ccb);
	TAILQ_INIT(&sc->sc_ccbq);
	TAILQ_INIT(&sc->sc_ucmdq);
	SIMPLEQ_INIT(&sc->sc_queue);

	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, gdt_ccb_alloc, gdt_ccb_free);

	/* Initialize the ccbs */
	for (i = 0; i < GDT_MAXCMDS; i++) {
		sc->sc_ccbs[i].gc_cmd_index = i + 2;
		error = bus_dmamap_create(sc->sc_dmat,
		    (GDT_MAXOFFSETS - 1) << PGSHIFT, GDT_MAXOFFSETS,
		    (GDT_MAXOFFSETS - 1) << PGSHIFT, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &sc->sc_ccbs[i].gc_dmamap_xfer);
		if (error) {
			printf("%s: cannot create ccb dmamap (%d)",
			    DEVNAME(sc), error);
			return (1);
		}
		(void)gdt_ccb_set_cmd(sc->sc_ccbs + i, GDT_GCF_UNUSED);
		TAILQ_INSERT_TAIL(&sc->sc_free_ccb, &sc->sc_ccbs[i],
		    gc_chain);
	}

	/* Fill in the prototype scsi_link. */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &gdt_switch;
	/* openings will be filled in later. */
	sc->sc_link.adapter_buswidth =
	    (sc->sc_class & GDT_FC) ? GDT_MAXID : GDT_MAX_HDRIVES;
	sc->sc_link.adapter_target = sc->sc_link.adapter_buswidth;
	sc->sc_link.pool = &sc->sc_iopool;

	if (!gdt_internal_cmd(sc, GDT_SCREENSERVICE, GDT_INIT, 0, 0, 0)) {
		printf("screen service initialization error %d\n",
		     sc->sc_status);
		return (1);
	}

	if (!gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,
	    0)) {
		printf("cache service initialization error %d\n",
		    sc->sc_status);
		return (1);
	}

	cdev_cnt = (u_int16_t)sc->sc_info;

	/* Detect number of busses */
	gdt_enc32(sc->sc_scratch + GDT_IOC_VERSION, GDT_IOC_NEWEST);
	sc->sc_scratch[GDT_IOC_LIST_ENTRIES] = GDT_MAXBUS;
	sc->sc_scratch[GDT_IOC_FIRST_CHAN] = 0;
	sc->sc_scratch[GDT_IOC_LAST_CHAN] = GDT_MAXBUS - 1;
	gdt_enc32(sc->sc_scratch + GDT_IOC_LIST_OFFSET, GDT_IOC_HDR_SZ);
	if (gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_IOCTL,
	    GDT_IOCHAN_RAW_DESC, GDT_INVALID_CHANNEL,
	    GDT_IOC_HDR_SZ + GDT_RAWIOC_SZ)) {
		sc->sc_bus_cnt = sc->sc_scratch[GDT_IOC_CHAN_COUNT];
		for (i = 0; i < sc->sc_bus_cnt; i++) {
			id = sc->sc_scratch[GDT_IOC_HDR_SZ +
			    i * GDT_RAWIOC_SZ + GDT_RAWIOC_PROC_ID];
			sc->sc_bus_id[id] = id < GDT_MAXBUS ? id : 0xff;
		}

	} else {
		/* New method failed, use fallback. */
		gdt_enc32(sc->sc_scratch + GDT_GETCH_CHANNEL_NO, i);
		for (i = 0; i < GDT_MAXBUS; i++) {
			if (!gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_IOCTL,
			    GDT_SCSI_CHAN_CNT | GDT_L_CTRL_PATTERN,
			    GDT_IO_CHANNEL | GDT_INVALID_CHANNEL,
			    GDT_GETCH_SZ)) {
				if (i == 0) {
					printf("cannot get channel count, "
					    "error %d\n", sc->sc_status);
					return (1);
				}
				break;
			}
			sc->sc_bus_id[i] =
			    (sc->sc_scratch[GDT_GETCH_SIOP_ID] < GDT_MAXID) ?
			    sc->sc_scratch[GDT_GETCH_SIOP_ID] : 0xff;
		}
		sc->sc_bus_cnt = i;
	}

	/* Read cache configuration */
	if (!gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_IOCTL, GDT_CACHE_INFO,
	    GDT_INVALID_CHANNEL, GDT_CINFO_SZ)) {
		printf("cannot get cache info, error %d\n", sc->sc_status);
		return (1);
	}
	sc->sc_cpar.cp_version =
	    gdt_dec32(sc->sc_scratch + GDT_CPAR_VERSION);
	sc->sc_cpar.cp_state = gdt_dec16(sc->sc_scratch + GDT_CPAR_STATE);
	sc->sc_cpar.cp_strategy =
	    gdt_dec16(sc->sc_scratch + GDT_CPAR_STRATEGY);
	sc->sc_cpar.cp_write_back =
	    gdt_dec16(sc->sc_scratch + GDT_CPAR_WRITE_BACK);
	sc->sc_cpar.cp_block_size =
	    gdt_dec16(sc->sc_scratch + GDT_CPAR_BLOCK_SIZE);

	/* Read board information and features */
	sc->sc_more_proc = 0;
	if (gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_IOCTL, GDT_BOARD_INFO,
	    GDT_INVALID_CHANNEL, GDT_BINFO_SZ)) {
		/* XXX A lot of these assignments can probably go later */
		sc->sc_binfo.bi_ser_no =
		    gdt_dec32(sc->sc_scratch + GDT_BINFO_SER_NO);
		bcopy(sc->sc_scratch + GDT_BINFO_OEM_ID,
		    sc->sc_binfo.bi_oem_id, sizeof sc->sc_binfo.bi_oem_id);
		sc->sc_binfo.bi_ep_flags =
		    gdt_dec16(sc->sc_scratch + GDT_BINFO_EP_FLAGS);
		sc->sc_binfo.bi_proc_id =
		    gdt_dec32(sc->sc_scratch + GDT_BINFO_PROC_ID);
		sc->sc_binfo.bi_memsize =
		    gdt_dec32(sc->sc_scratch + GDT_BINFO_MEMSIZE);
		sc->sc_binfo.bi_mem_banks =
		    sc->sc_scratch[GDT_BINFO_MEM_BANKS];
		sc->sc_binfo.bi_chan_type =
		    sc->sc_scratch[GDT_BINFO_CHAN_TYPE];
		sc->sc_binfo.bi_chan_count =
		    sc->sc_scratch[GDT_BINFO_CHAN_COUNT];
		sc->sc_binfo.bi_rdongle_pres =
		    sc->sc_scratch[GDT_BINFO_RDONGLE_PRES];
		sc->sc_binfo.bi_epr_fw_ver =
		    gdt_dec32(sc->sc_scratch + GDT_BINFO_EPR_FW_VER);
		sc->sc_binfo.bi_upd_fw_ver =
		    gdt_dec32(sc->sc_scratch + GDT_BINFO_UPD_FW_VER);
		sc->sc_binfo.bi_upd_revision =
		    gdt_dec32(sc->sc_scratch + GDT_BINFO_UPD_REVISION);
		bcopy(sc->sc_scratch + GDT_BINFO_TYPE_STRING,
		    sc->sc_binfo.bi_type_string,
		    sizeof sc->sc_binfo.bi_type_string);
		bcopy(sc->sc_scratch + GDT_BINFO_RAID_STRING,
		    sc->sc_binfo.bi_raid_string,
		    sizeof sc->sc_binfo.bi_raid_string);
		sc->sc_binfo.bi_update_pres =
		    sc->sc_scratch[GDT_BINFO_UPDATE_PRES];
		sc->sc_binfo.bi_xor_pres =
		    sc->sc_scratch[GDT_BINFO_XOR_PRES];
		sc->sc_binfo.bi_prom_type =
		    sc->sc_scratch[GDT_BINFO_PROM_TYPE];
		sc->sc_binfo.bi_prom_count =
		    sc->sc_scratch[GDT_BINFO_PROM_COUNT];
		sc->sc_binfo.bi_dup_pres =
		    gdt_dec32(sc->sc_scratch + GDT_BINFO_DUP_PRES);
		sc->sc_binfo.bi_chan_pres =
		    gdt_dec32(sc->sc_scratch + GDT_BINFO_CHAN_PRES);
		sc->sc_binfo.bi_mem_pres =
		    gdt_dec32(sc->sc_scratch + GDT_BINFO_MEM_PRES);
		sc->sc_binfo.bi_ft_bus_system =
		    sc->sc_scratch[GDT_BINFO_FT_BUS_SYSTEM];
		sc->sc_binfo.bi_subtype_valid =
		    sc->sc_scratch[GDT_BINFO_SUBTYPE_VALID];
		sc->sc_binfo.bi_board_subtype =
		    sc->sc_scratch[GDT_BINFO_BOARD_SUBTYPE];
		sc->sc_binfo.bi_rampar_pres =
		    sc->sc_scratch[GDT_BINFO_RAMPAR_PRES];

		if (gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_IOCTL,
		    GDT_BOARD_FEATURES, GDT_INVALID_CHANNEL, GDT_BFEAT_SZ)) {
			sc->sc_bfeat.bf_chaining =
			    sc->sc_scratch[GDT_BFEAT_CHAINING];
			sc->sc_bfeat.bf_striping =
			    sc->sc_scratch[GDT_BFEAT_STRIPING];
			sc->sc_bfeat.bf_mirroring =
			    sc->sc_scratch[GDT_BFEAT_MIRRORING];
			sc->sc_bfeat.bf_raid =
			    sc->sc_scratch[GDT_BFEAT_RAID];
			sc->sc_more_proc = 1;
		}
	} else {
		/* XXX Not implemented yet */
	}

	/* Read more information */
	if (sc->sc_more_proc) {
		int bus, j;
		/* physical drives, channel addresses */
		/* step 1: get magical bus number from firmware */
		gdt_enc32(sc->sc_scratch + GDT_IOC_VERSION, GDT_IOC_NEWEST);
		sc->sc_scratch[GDT_IOC_LIST_ENTRIES] = GDT_MAXBUS;
		sc->sc_scratch[GDT_IOC_FIRST_CHAN] = 0;
		sc->sc_scratch[GDT_IOC_LAST_CHAN] = GDT_MAXBUS - 1;
		gdt_enc32(sc->sc_scratch + GDT_IOC_LIST_OFFSET, GDT_IOC_HDR_SZ);
		if (gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_IOCTL,
		    GDT_IOCHAN_DESC, GDT_INVALID_CHANNEL,
		    GDT_IOC_HDR_SZ + GDT_IOC_SZ * GDT_MAXBUS)) {
			GDT_DPRINTF(GDT_D_INFO, ("method 1\n"));
			for (bus = 0; bus < sc->sc_bus_cnt; bus++) {
				sc->sc_raw[bus].ra_address =
				    gdt_dec32(sc->sc_scratch +
				    GDT_IOC_HDR_SZ +
				    GDT_IOC_SZ * bus +
				    GDT_IOC_ADDRESS);
				sc->sc_raw[bus].ra_local_no =
				    gdt_dec8(sc->sc_scratch +
				    GDT_IOC_HDR_SZ +
				    GDT_IOC_SZ * bus +
				    GDT_IOC_LOCAL_NO);
				GDT_DPRINTF(GDT_D_INFO, (
				    "bus: %d address: %x local: %x\n",
				    bus,
				    sc->sc_raw[bus].ra_address,
				    sc->sc_raw[bus].ra_local_no));
			}
		} else {
			GDT_DPRINTF(GDT_D_INFO, ("method 2\n"));
			for (bus = 0; bus < sc->sc_bus_cnt; bus++) {
				sc->sc_raw[bus].ra_address = GDT_IO_CHANNEL;
				sc->sc_raw[bus].ra_local_no = bus;
				GDT_DPRINTF(GDT_D_INFO, (
				    "bus: %d address: %x local: %x\n",
				    bus,
				    sc->sc_raw[bus].ra_address,
				    sc->sc_raw[bus].ra_local_no));
			}
		}
		/* step 2: use magical bus number to get nr of phys disks */
		for (bus = 0; bus < sc->sc_bus_cnt; bus++) {
			gdt_enc32(sc->sc_scratch + GDT_GETCH_CHANNEL_NO,
			    sc->sc_raw[bus].ra_local_no);
			if (gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_IOCTL,
			    GDT_SCSI_CHAN_CNT | GDT_L_CTRL_PATTERN,
			    sc->sc_raw[bus].ra_address | GDT_INVALID_CHANNEL,
			    GDT_GETCH_SZ)) {
				sc->sc_raw[bus].ra_phys_cnt =
				    gdt_dec32(sc->sc_scratch +
				    GDT_GETCH_DRIVE_CNT);
				GDT_DPRINTF(GDT_D_INFO, ("chan: %d disks: %d\n",
				    bus, sc->sc_raw[bus].ra_phys_cnt));
			}

			/* step 3: get scsi disk nr */
			if (sc->sc_raw[bus].ra_phys_cnt > 0) {
				gdt_enc32(sc->sc_scratch +
				    GDT_GETSCSI_CHAN,
				    sc->sc_raw[bus].ra_local_no);
				gdt_enc32(sc->sc_scratch +
				    GDT_GETSCSI_CNT,
				    sc->sc_raw[bus].ra_phys_cnt);
				if (gdt_internal_cmd(sc, GDT_CACHESERVICE,
				    GDT_IOCTL,
				    GDT_SCSI_DR_LIST | GDT_L_CTRL_PATTERN,
				    sc->sc_raw[bus].ra_address |
				    GDT_INVALID_CHANNEL,
				    GDT_GETSCSI_SZ))
					for (j = 0;
					    j < sc->sc_raw[bus].ra_phys_cnt;
					    j++) {
						sc->sc_raw[bus].ra_id_list[j] =
						    gdt_dec32(sc->sc_scratch +
						    GDT_GETSCSI_LIST +
						    GDT_GETSCSI_LIST_SZ * j);
						GDT_DPRINTF(GDT_D_INFO,
						    ("  diskid: %d\n",
						    sc->sc_raw[bus].ra_id_list[j]));
					}
				else
					sc->sc_raw[bus].ra_phys_cnt = 0;
			}
			/* add found disks to grand total */
			sc->sc_total_disks += sc->sc_raw[bus].ra_phys_cnt;
		}
	} /* if (sc->sc_more_proc) */

	if (!gdt_internal_cmd(sc, GDT_SCSIRAWSERVICE, GDT_INIT, 0, 0, 0)) {
		printf("raw service initialization error %d\n",
		    sc->sc_status);
		return (1);
	}

	/* Set/get features raw service (scatter/gather) */
	sc->sc_raw_feat = 0;
	if (gdt_internal_cmd(sc, GDT_SCSIRAWSERVICE, GDT_SET_FEAT,
	    GDT_SCATTER_GATHER, 0, 0))
		if (gdt_internal_cmd(sc, GDT_SCSIRAWSERVICE, GDT_GET_FEAT, 0,
		    0, 0))
			sc->sc_raw_feat = sc->sc_info;

	/* Set/get features cache service (scatter/gather) */
	sc->sc_cache_feat = 0;
	if (gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_SET_FEAT, 0,
	    GDT_SCATTER_GATHER, 0))
		if (gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_GET_FEAT, 0, 0,
		    0))
			sc->sc_cache_feat = sc->sc_info;

	/* XXX Linux reserve drives here, potentially */

	sc->sc_ndevs = 0;
	/* Scan for cache devices */
	for (i = 0; i < cdev_cnt && i < GDT_MAX_HDRIVES; i++)
		if (gdt_internal_cmd(sc, GDT_CACHESERVICE, GDT_INFO, i, 0,
		    0)) {
			sc->sc_hdr[i].hd_present = 1;
			sc->sc_hdr[i].hd_size = sc->sc_info;

			if (sc->sc_hdr[i].hd_size > 0)
				sc->sc_ndevs++;

			/*
			 * Evaluate mapping (sectors per head, heads per cyl)
			 */
			sc->sc_hdr[i].hd_size &= ~GDT_SECS32;
			if (sc->sc_info2 == 0)
				gdt_eval_mapping(sc->sc_hdr[i].hd_size,
				    &drv_cyls, &drv_hds, &drv_secs);
			else {
				drv_hds = sc->sc_info2 & 0xff;
				drv_secs = (sc->sc_info2 >> 8) & 0xff;
				drv_cyls = sc->sc_hdr[i].hd_size / drv_hds /
				    drv_secs;
			}
			sc->sc_hdr[i].hd_heads = drv_hds;
			sc->sc_hdr[i].hd_secs = drv_secs;
			/* Round the size */
			sc->sc_hdr[i].hd_size = drv_cyls * drv_hds * drv_secs;

			if (gdt_internal_cmd(sc, GDT_CACHESERVICE,
			    GDT_DEVTYPE, i, 0, 0))
				sc->sc_hdr[i].hd_devtype = sc->sc_info;
		}

	if (sc->sc_ndevs == 0)
		sc->sc_link.openings = 0;
	else
		sc->sc_link.openings = (GDT_MAXCMDS - GDT_CMD_RESERVE) /
		    sc->sc_ndevs;

	printf("dpmem %llx %d-bus %d cache device%s\n",
	    (long long)sc->sc_dpmembase,
	    sc->sc_bus_cnt, cdev_cnt, cdev_cnt == 1 ? "" : "s");
	printf("%s: ver %x, cache %s, strategy %d, writeback %s, blksz %d\n",
	    DEVNAME(sc), sc->sc_cpar.cp_version,
	    sc->sc_cpar.cp_state ? "on" : "off", sc->sc_cpar.cp_strategy,
	    sc->sc_cpar.cp_write_back ? "on" : "off",
	    sc->sc_cpar.cp_block_size);
#if 1
	printf("%s: raw feat %x cache feat %x\n", DEVNAME(sc),
	    sc->sc_raw_feat, sc->sc_cache_feat);
#endif

#if NBIO > 0
	if (bio_register(&sc->sc_dev, gdt_ioctl) != 0)
		panic("%s: controller registration failed", DEVNAME(sc));
#endif
	gdt_cnt++;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	config_found(&sc->sc_dev, &saa, scsiprint);

	gdt_polling = 0;
	return (0);
}

void
gdt_eval_mapping(u_int32_t size, int *cyls, int *heads, int *secs)
{
	*cyls = size / GDT_HEADS / GDT_SECS;
	if (*cyls < GDT_MAXCYLS) {
		*heads = GDT_HEADS;
		*secs = GDT_SECS;
	} else {
		/* Too high for 64 * 32 */
		*cyls = size / GDT_MEDHEADS / GDT_MEDSECS;
		if (*cyls < GDT_MAXCYLS) {
			*heads = GDT_MEDHEADS;
			*secs = GDT_MEDSECS;
		} else {
			/* Too high for 127 * 63 */
			*cyls = size / GDT_BIGHEADS / GDT_BIGSECS;
			*heads = GDT_BIGHEADS;
			*secs = GDT_BIGSECS;
		}
	}
}

/*
 * Insert a command into the driver queue, either at the front or at the tail.
 * It's ok to overload the freelist link as these structures are never on
 * the freelist at this time.
 */
void
gdt_enqueue(struct gdt_softc *sc, struct scsi_xfer *xs, int infront)
{
	if (infront)
		SIMPLEQ_INSERT_HEAD(&sc->sc_queue, xs, xfer_list);
	else
		SIMPLEQ_INSERT_TAIL(&sc->sc_queue, xs, xfer_list);
}

/*
 * Pull a command off the front of the driver queue.
 */
struct scsi_xfer *
gdt_dequeue(struct gdt_softc *sc)
{
	struct scsi_xfer *xs;

	xs = SIMPLEQ_FIRST(&sc->sc_queue);
	if (xs != NULL)
		SIMPLEQ_REMOVE_HEAD(&sc->sc_queue, xfer_list);

	return (xs);
}

/*
 * Start a SCSI operation on a cache device.
 * XXX Polled operation is not yet complete.  What kind of locking do we need?
 */
void
gdt_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct gdt_softc *sc = link->adapter_softc;
	u_int8_t target = link->target;
	struct gdt_ccb *ccb;
	u_int32_t blockno, blockcnt;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	bus_dmamap_t xfer;
	int error;
	int s;
	int polled;

	GDT_DPRINTF(GDT_D_CMD, ("gdt_scsi_cmd "));

	s = splbio();

	xs->error = XS_NOERROR;

	if (target >= GDT_MAX_HDRIVES || !sc->sc_hdr[target].hd_present ||
	    link->lun != 0) {
		/*
		 * XXX Should be XS_SENSE but that would require setting up a
		 * faked sense too.
		 */
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		splx(s);
		return;
	}

	/* Don't double enqueue if we came from gdt_chain. */
	if (xs != SIMPLEQ_FIRST(&sc->sc_queue))
		gdt_enqueue(sc, xs, 0);

	while ((xs = gdt_dequeue(sc)) != NULL) {
		xs->error = XS_NOERROR;
		ccb = NULL;
		link = xs->sc_link;
		target = link->target;
		polled = ISSET(xs->flags, SCSI_POLL);
 
		if (!gdt_polling && !(xs->flags & SCSI_POLL) &&
		    sc->sc_test_busy(sc)) {
			/*
			 * Put it back in front.  XXX Should we instead
			 * set xs->error to XS_BUSY?
			 */
			gdt_enqueue(sc, xs, 1);
			break;
		}

		switch (xs->cmd->opcode) {
		case TEST_UNIT_READY:
		case REQUEST_SENSE:
		case INQUIRY:
		case MODE_SENSE:
		case START_STOP:
		case READ_CAPACITY:
#if 0
		case VERIFY:
#endif
			gdt_internal_cache_cmd(xs);
			scsi_done(xs);
			goto ready;

		case PREVENT_ALLOW:
			GDT_DPRINTF(GDT_D_CMD, ("PREVENT/ALLOW "));
			/* XXX Not yet implemented */
			xs->error = XS_NOERROR;
			scsi_done(xs);
			goto ready;

		default:
			GDT_DPRINTF(GDT_D_CMD,
			    ("unknown opc %d ", xs->cmd->opcode));
			/* XXX Not yet implemented */
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			goto ready;

		case READ_COMMAND:
		case READ_BIG:
		case WRITE_COMMAND:
		case WRITE_BIG:
		case SYNCHRONIZE_CACHE:
			/*
			 * A new command chain, start from the beginning.
			 */
			sc->sc_cmd_off = 0;

			if (xs->cmd->opcode == SYNCHRONIZE_CACHE) {
				 blockno = blockcnt = 0;
			} else {
				/* A read or write operation. */
				if (xs->cmdlen == 6) {
					rw = (struct scsi_rw *)xs->cmd;
					blockno = _3btol(rw->addr) &
					    (SRW_TOPADDR << 16 | 0xffff);
					blockcnt =
					    rw->length ? rw->length : 0x100;
				} else {
					rwb = (struct scsi_rw_big *)xs->cmd;
					blockno = _4btol(rwb->addr);
					blockcnt = _2btol(rwb->length);
				}
				if (blockno >= sc->sc_hdr[target].hd_size ||
				    blockno + blockcnt >
				    sc->sc_hdr[target].hd_size) {
					printf(
					    "%s: out of bounds %u-%u >= %u\n",
					    DEVNAME(sc), blockno,
					    blockcnt,
					    sc->sc_hdr[target].hd_size);
					/*
					 * XXX Should be XS_SENSE but that
					 * would require setting up a faked
					 * sense too.
					 */
					xs->error = XS_DRIVER_STUFFUP;
					scsi_done(xs);
					goto ready;
				}
			}

			ccb = xs->io;
			ccb->gc_blockno = blockno;
			ccb->gc_blockcnt = blockcnt;
			ccb->gc_xs = xs;
			ccb->gc_timeout = xs->timeout;
			ccb->gc_service = GDT_CACHESERVICE;
			ccb->gc_flags = 0;
			gdt_ccb_set_cmd(ccb, GDT_GCF_SCSI);

			if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
				xfer = ccb->gc_dmamap_xfer;
				error = bus_dmamap_load(sc->sc_dmat, xfer,
				    xs->data, xs->datalen, NULL,
				    (xs->flags & SCSI_NOSLEEP) ?
				    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
				if (error) {
					printf("%s: gdt_scsi_cmd: ",
					    DEVNAME(sc));
					if (error == EFBIG)
						printf(
						    "more than %d dma segs\n",
						    GDT_MAXOFFSETS);
					else
						printf("error %d "
						    "loading dma map\n",
						    error);

					xs->error = XS_DRIVER_STUFFUP;
					scsi_done(xs);
					goto ready;
				}
				bus_dmamap_sync(sc->sc_dmat, xfer, 0,
				    xfer->dm_mapsize,
				    (xs->flags & SCSI_DATA_IN) ?
				    BUS_DMASYNC_PREREAD :
				    BUS_DMASYNC_PREWRITE);
			}

			gdt_enqueue_ccb(sc, ccb);
			/* XXX what if enqueue did not start a transfer? */
			if (gdt_polling || (xs->flags & SCSI_POLL)) {
				if (!gdt_wait(sc, ccb, ccb->gc_timeout)) {
					printf("%s: command %d timed out\n",
					    DEVNAME(sc),
					    ccb->gc_cmd_index);
					xs->error = XS_TIMEOUT;
					scsi_done(xs);
					splx(s);
					return;
				}
			}
		}

	ready:
		/*
		 * Don't process the queue if we are polling.
		 */
		if (polled) {
			break;
		}
	}

	splx(s);
}

/* XXX Currently only for cacheservice, returns 0 if busy */
int
gdt_exec_ccb(struct gdt_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->gc_xs;
	struct scsi_link *link = xs->sc_link;
	struct gdt_softc *sc = link->adapter_softc;
	u_int8_t target = link->target;
	u_int32_t sg_canz;
	bus_dmamap_t xfer;
	int i;
#if 1 /* XXX */
	static int __level = 0;

	if (__level++ > 0)
		panic("level > 0");
#endif
	GDT_DPRINTF(GDT_D_CMD, ("gdt_exec_ccb(%p, %p) ", xs, ccb));

	sc->sc_cmd_cnt = 0;

	/*
	 * XXX Yeah I know it's an always-true condition, but that may change
	 * later.
	 */
	if (sc->sc_cmd_cnt == 0)
		sc->sc_set_sema0(sc);

	gdt_enc32(sc->sc_cmd + GDT_CMD_COMMANDINDEX, ccb->gc_cmd_index);
	gdt_enc32(sc->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);
	gdt_enc16(sc->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DEVICENO,
	    target);

	switch (xs->cmd->opcode) {
	case PREVENT_ALLOW:
	case SYNCHRONIZE_CACHE:
		if (xs->cmd->opcode == PREVENT_ALLOW) {
			/* XXX PREVENT_ALLOW support goes here */
		} else {
			GDT_DPRINTF(GDT_D_CMD,
			    ("SYNCHRONIZE CACHE tgt %d ", target));
			sc->sc_cmd[GDT_CMD_OPCODE] = GDT_FLUSH;
		}
		gdt_enc32(sc->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,
		    1);
		sg_canz = 0;
		break;

	case WRITE_COMMAND:
	case WRITE_BIG:
		/* XXX WRITE_THR could be supported too */
		sc->sc_cmd[GDT_CMD_OPCODE] = GDT_WRITE;
		break;

	case READ_COMMAND:
	case READ_BIG:
		sc->sc_cmd[GDT_CMD_OPCODE] = GDT_READ;
		break;
	}

	if (xs->cmd->opcode != PREVENT_ALLOW &&
	    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
		gdt_enc32(sc->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,
		    ccb->gc_blockno);
		gdt_enc32(sc->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKCNT,
		    ccb->gc_blockcnt);

		xfer = ccb->gc_dmamap_xfer;
		if (sc->sc_cache_feat & GDT_SCATTER_GATHER) {
			gdt_enc32(
			    sc->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
			    0xffffffff);
			for (i = 0; i < xfer->dm_nsegs; i++) {
				gdt_enc32(sc->sc_cmd + GDT_CMD_UNION +
				    GDT_CACHE_SG_LST + i * GDT_SG_SZ +
				    GDT_SG_PTR,
				    xfer->dm_segs[i].ds_addr);
				gdt_enc32(sc->sc_cmd + GDT_CMD_UNION +
				    GDT_CACHE_SG_LST + i * GDT_SG_SZ +
				    GDT_SG_LEN,
				    xfer->dm_segs[i].ds_len);
				GDT_DPRINTF(GDT_D_IO,
				    ("#%d va %p pa %p len %x\n", i, buf,
				    xfer->dm_segs[i].ds_addr,
				    xfer->dm_segs[i].ds_len));
			}
			sg_canz = xfer->dm_nsegs;
			gdt_enc32(
			    sc->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_LST +
			    sg_canz * GDT_SG_SZ + GDT_SG_LEN, 0);
		} else {
			/* XXX Hardly correct */
			gdt_enc32(
			    sc->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
			    xfer->dm_segs[0].ds_addr);
			sg_canz = 0;
		}
	}
	gdt_enc32(sc->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_CANZ, sg_canz);

	sc->sc_cmd_len =
	    roundup(GDT_CMD_UNION + GDT_CACHE_SG_LST + sg_canz * GDT_SG_SZ,
	    sizeof (u_int32_t));

	if (sc->sc_cmd_cnt > 0 &&
	    sc->sc_cmd_off + sc->sc_cmd_len + GDT_DPMEM_COMMAND_OFFSET >
	    sc->sc_ic_all_size) {
		printf("%s: DPMEM overflow\n", DEVNAME(sc));
		xs->error = XS_BUSY;
#if 1 /* XXX */
		__level--;
#endif
		return (0);
	}

	sc->sc_copy_cmd(sc, ccb);
	sc->sc_release_event(sc, ccb);

	xs->error = XS_NOERROR;
	xs->resid = 0;
#if 1 /* XXX */
	__level--;
#endif
	return (1);
}

void
gdt_copy_internal_data(struct scsi_xfer *xs, u_int8_t *data, size_t size)
{
	size_t copy_cnt;

	GDT_DPRINTF(GDT_D_MISC, ("gdt_copy_internal_data "));

	if (!xs->datalen)
		printf("uio move not yet supported\n");
	else {
		copy_cnt = MIN(size, xs->datalen);
		bcopy(data, xs->data, copy_cnt);
	}
}

/* Emulated SCSI operation on cache device */
void
gdt_internal_cache_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct gdt_softc *sc = link->adapter_softc;
	struct scsi_inquiry_data inq;
	struct scsi_sense_data sd;
	struct scsi_read_cap_data rcd;
	u_int8_t target = link->target;

	GDT_DPRINTF(GDT_D_CMD, ("gdt_internal_cache_cmd "));

	switch (xs->cmd->opcode) {
	case TEST_UNIT_READY:
	case START_STOP:
#if 0
	case VERIFY:
#endif
		GDT_DPRINTF(GDT_D_CMD, ("opc %d tgt %d ", xs->cmd->opcode,
		    target));
		break;

	case REQUEST_SENSE:
		GDT_DPRINTF(GDT_D_CMD, ("REQUEST SENSE tgt %d ", target));
		bzero(&sd, sizeof sd);
		sd.error_code = SSD_ERRCODE_CURRENT;
		sd.segment = 0;
		sd.flags = SKEY_NO_SENSE;
		gdt_enc32(sd.info, 0);
		sd.extra_len = 0;
		gdt_copy_internal_data(xs, (u_int8_t *)&sd, sizeof sd);
		break;

	case INQUIRY:
		GDT_DPRINTF(GDT_D_CMD, ("INQUIRY tgt %d devtype %x ", target,
		    sc->sc_hdr[target].hd_devtype));
		bzero(&inq, sizeof inq);
		inq.device =
		    (sc->sc_hdr[target].hd_devtype & 4) ? T_CDROM : T_DIRECT;
		inq.dev_qual2 =
		    (sc->sc_hdr[target].hd_devtype & 1) ? SID_REMOVABLE : 0;
		inq.version = 2;
		inq.response_format = 2;
		inq.additional_length = 32;
		inq.flags |= SID_CmdQue;
		strlcpy(inq.vendor, "ICP	   ", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Host drive  #%02d",
		    target);
		strlcpy(inq.revision, "	 ", sizeof inq.revision);
		gdt_copy_internal_data(xs, (u_int8_t *)&inq, sizeof inq);
		break;

	case READ_CAPACITY:
		GDT_DPRINTF(GDT_D_CMD, ("READ CAPACITY tgt %d ", target));
		bzero(&rcd, sizeof rcd);
		_lto4b(sc->sc_hdr[target].hd_size - 1, rcd.addr);
		_lto4b(GDT_SECTOR_SIZE, rcd.length);
		gdt_copy_internal_data(xs, (u_int8_t *)&rcd, sizeof rcd);
		break;

	default:
		GDT_DPRINTF(GDT_D_CMD, ("unsupported scsi command %#x tgt %d ",
		    xs->cmd->opcode, target));
		xs->error = XS_DRIVER_STUFFUP;
		return;
	}

	xs->error = XS_NOERROR;
}

void
gdt_clear_events(struct gdt_softc *sc)
{
	GDT_DPRINTF(GDT_D_MISC, ("gdt_clear_events(%p) ", sc));

	/* XXX To be implemented */
}

int
gdt_async_event(struct gdt_softc *sc, int service)
{
	GDT_DPRINTF(GDT_D_INTR, ("gdt_async_event(%p, %d) ", sc, service));

	if (service == GDT_SCREENSERVICE) {
		/* XXX To be implemented */
	} else {
		/* XXX To be implemented */
	}

	return (0);
}

int
gdt_sync_event(struct gdt_softc *sc, int service, u_int8_t index,
    struct scsi_xfer *xs)
{
	GDT_DPRINTF(GDT_D_INTR,
	    ("gdt_sync_event(%p, %d, %d, %p) ", sc, service, index, xs));

	if (service == GDT_SCREENSERVICE) {
		GDT_DPRINTF(GDT_D_INTR, ("service == GDT_SCREENSERVICE "));
		/* XXX To be implemented */
		return (0);
	} else {
		switch (sc->sc_status) {
		case GDT_S_OK:
			GDT_DPRINTF(GDT_D_INTR, ("sc_status == GDT_S_OK "));
			/* XXX To be implemented */
			break;
		case GDT_S_BSY:
			GDT_DPRINTF(GDT_D_INTR, ("sc_status == GDT_S_BSY "));
			/* XXX To be implemented */
			return (2);
		default:
			GDT_DPRINTF(GDT_D_INTR, ("sc_status is %d ",
			    sc->sc_status));
			/* XXX To be implemented */
			return (0);
		}
	}

	return (1);
}

int
gdt_intr(void *arg)
{
	struct gdt_softc *sc = arg;
	struct gdt_intr_ctx ctx;
	int chain = 1;
	int sync_val = 0;
	struct scsi_xfer *xs = NULL;
	int prev_cmd;
	struct gdt_ccb *ccb;

	GDT_DPRINTF(GDT_D_INTR, ("gdt_intr(%p) ", sc));

	/* If polling and we were not called from gdt_wait, just return */
	if (gdt_polling && !gdt_from_wait)
		return (0);

	ctx.istatus = sc->sc_get_status(sc);
	if (!ctx.istatus) {
		sc->sc_status = GDT_S_NO_STATUS;
		return (0);
	}

	gdt_wait_index = 0;
	ctx.service = ctx.info2 = 0;

	sc->sc_intr(sc, &ctx);

	sc->sc_status = ctx.cmd_status;
	sc->sc_info = ctx.info;
	sc->sc_info2 = ctx.info2;

	if (gdt_from_wait) {
		gdt_wait_gdt = sc;
		gdt_wait_index = ctx.istatus;
	}

	switch (ctx.istatus) {
	case GDT_ASYNCINDEX:
		gdt_async_event(sc, ctx.service);
		goto finish;

	case GDT_SPEZINDEX:
		printf("%s: uninitialized or unknown service (%d %d)\n",
		    DEVNAME(sc), ctx.info, ctx.info2);
		chain = 0;
		goto finish;
	}

	ccb = &sc->sc_ccbs[ctx.istatus - 2];
	xs = ccb->gc_xs;
	if (!gdt_polling)
		timeout_del(&xs->stimeout);
	ctx.service = ccb->gc_service;
	prev_cmd = ccb->gc_flags & GDT_GCF_CMD_MASK;
	if (xs && xs->cmd->opcode != PREVENT_ALLOW &&
	    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
		bus_dmamap_sync(sc->sc_dmat, ccb->gc_dmamap_xfer, 0,
		    ccb->gc_dmamap_xfer->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ccb->gc_dmamap_xfer);
	}
	switch (prev_cmd) {
	case GDT_GCF_UNUSED:
		/* XXX Not yet implemented */
		chain = 0;
		goto finish;
	case GDT_GCF_INTERNAL:
		chain = 0;
		goto finish;
	}

	sync_val = gdt_sync_event(sc, ctx.service, ctx.istatus, xs);

 finish:
	switch (sync_val) {
	case 0:
		if (xs && gdt_from_wait)
			scsi_done(xs);
		break;
	case 1:
		scsi_done(xs);
		break;

	case 2:
		gdt_enqueue(sc, xs, 0);
	}

	if (chain)
		gdt_chain(sc);

	return (1);
}

void
gdtminphys(struct buf *bp, struct scsi_link *sl)
{
	GDT_DPRINTF(GDT_D_MISC, ("gdtminphys(0x%x) ", bp));

	/* As this is way more than MAXPHYS it's really not necessary. */
	if ((GDT_MAXOFFSETS - 1) * PAGE_SIZE < MAXPHYS &&
	    bp->b_bcount > ((GDT_MAXOFFSETS - 1) * PAGE_SIZE))
		bp->b_bcount = ((GDT_MAXOFFSETS - 1) * PAGE_SIZE);

	minphys(bp);
}

int
gdt_wait(struct gdt_softc *sc, struct gdt_ccb *ccb, int timeout)
{
	int s, rslt, rv = 0;

	GDT_DPRINTF(GDT_D_MISC,
	    ("gdt_wait(%p, %p, %d) ", sc, ccb, timeout));

	gdt_from_wait = 1;
	do {
		s = splbio();
		rslt = gdt_intr(sc);
		splx(s);
		if (rslt && sc == gdt_wait_gdt &&
		    ccb->gc_cmd_index == gdt_wait_index) {
			rv = 1;
			break;
		}
		DELAY(1000); /* 1 millisecond */
	} while (--timeout);
	gdt_from_wait = 0;

	while (sc->sc_test_busy(sc))
		DELAY(0);		/* XXX correct? */

	return (rv);
}

int
gdt_internal_cmd(struct gdt_softc *sc, u_int8_t service, u_int16_t opcode,
    u_int32_t arg1, u_int32_t arg2, u_int32_t arg3)
{
	int retries, rslt;
	struct gdt_ccb *ccb;

	GDT_DPRINTF(GDT_D_CMD, ("gdt_internal_cmd(%p, %d, %d, %d, %d, %d) ",
	    sc, service, opcode, arg1, arg2, arg3));

	bzero(sc->sc_cmd, GDT_CMD_SZ);

	for (retries = GDT_RETRIES; ; ) {
		ccb = scsi_io_get(&sc->sc_iopool, SCSI_NOSLEEP);
		if (ccb == NULL) {
			printf("%s: no free command index found\n",
			    DEVNAME(sc));
			return (0);
		}
		ccb->gc_service = service;
		ccb->gc_xs = NULL;
		ccb->gc_blockno = ccb->gc_blockcnt = 0;
		ccb->gc_timeout = ccb->gc_flags = 0;
		ccb->gc_service = GDT_CACHESERVICE;
		gdt_ccb_set_cmd(ccb, GDT_GCF_INTERNAL);

		sc->sc_set_sema0(sc);
		gdt_enc32(sc->sc_cmd + GDT_CMD_COMMANDINDEX,
		    ccb->gc_cmd_index);
		gdt_enc16(sc->sc_cmd + GDT_CMD_OPCODE, opcode);
		gdt_enc32(sc->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);

		switch (service) {
		case GDT_CACHESERVICE:
			if (opcode == GDT_IOCTL) {
				gdt_enc32(sc->sc_cmd + GDT_CMD_UNION +
				    GDT_IOCTL_SUBFUNC, arg1);
				gdt_enc32(sc->sc_cmd + GDT_CMD_UNION +
				    GDT_IOCTL_CHANNEL, arg2);
				gdt_enc16(sc->sc_cmd + GDT_CMD_UNION +
				    GDT_IOCTL_PARAM_SIZE, (u_int16_t)arg3);
				gdt_enc32(sc->sc_cmd + GDT_CMD_UNION +
				    GDT_IOCTL_P_PARAM,
				    sc->sc_scratch_seg.ds_addr);
			} else {
				gdt_enc16(sc->sc_cmd + GDT_CMD_UNION +
				    GDT_CACHE_DEVICENO, (u_int16_t)arg1);
				gdt_enc32(sc->sc_cmd + GDT_CMD_UNION +
				    GDT_CACHE_BLOCKNO, arg2);
			}
			break;

		case GDT_SCSIRAWSERVICE:
			gdt_enc32(sc->sc_cmd + GDT_CMD_UNION +
			    GDT_RAW_DIRECTION, arg1);
			sc->sc_cmd[GDT_CMD_UNION + GDT_RAW_BUS] =
			    (u_int8_t)arg2;
			sc->sc_cmd[GDT_CMD_UNION + GDT_RAW_TARGET] =
			    (u_int8_t)arg3;
			sc->sc_cmd[GDT_CMD_UNION + GDT_RAW_LUN] =
			    (u_int8_t)(arg3 >> 8);
		}

		sc->sc_cmd_len = GDT_CMD_SZ;
		sc->sc_cmd_off = 0;
		sc->sc_cmd_cnt = 0;
		sc->sc_copy_cmd(sc, ccb);
		sc->sc_release_event(sc, ccb);
		DELAY(20);

		rslt = gdt_wait(sc, ccb, GDT_POLL_TIMEOUT);
		scsi_io_put(&sc->sc_iopool, ccb);

		if (!rslt)
			return (0);
		if (sc->sc_status != GDT_S_BSY || --retries == 0)
			break;
		DELAY(1);
	}
	return (sc->sc_status == GDT_S_OK);
}

void *
gdt_ccb_alloc(void *xsc)
{
	struct gdt_softc *sc = xsc;
	struct gdt_ccb *ccb;

	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_ccb_alloc(%p) ", sc));

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = TAILQ_FIRST(&sc->sc_free_ccb);
	if (ccb != NULL)
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, gc_chain);
	mtx_leave(&sc->sc_ccb_mtx);

	return (ccb);
}

void
gdt_ccb_free(void *xsc, void *xccb)
{
	struct gdt_softc *sc = xsc;
	struct gdt_ccb *ccb = xccb;
	int wake = 0;

	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_ccb_free(%p, %p) ", sc, ccb));

	mtx_enter(&sc->sc_ccb_mtx);
	TAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, gc_chain);
	/* If the free list was empty, wake up potential waiters. */
	if (TAILQ_NEXT(ccb, gc_chain) == NULL)
		wake = 1;
	mtx_leave(&sc->sc_ccb_mtx);

	if (wake)
		wakeup(&sc->sc_free_ccb);
}

void
gdt_enqueue_ccb(struct gdt_softc *sc, struct gdt_ccb *ccb)
{
	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_enqueue_ccb(%p, %p) ", sc, ccb));

	timeout_set(&ccb->gc_xs->stimeout, gdt_timeout, ccb);
	TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, gc_chain);
	gdt_start_ccbs(sc);
}

void
gdt_start_ccbs(struct gdt_softc *sc)
{
	struct gdt_ccb *ccb;
	struct scsi_xfer *xs;

	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_start_ccbs(%p) ", sc));

	while ((ccb = TAILQ_FIRST(&sc->sc_ccbq)) != NULL) {

		xs = ccb->gc_xs;
		if (ccb->gc_flags & GDT_GCF_WATCHDOG)
			timeout_del(&xs->stimeout);

		if (gdt_exec_ccb(ccb) == 0) {
			ccb->gc_flags |= GDT_GCF_WATCHDOG;
			timeout_set(&ccb->gc_xs->stimeout, gdt_watchdog, ccb);
			timeout_add_msec(&xs->stimeout, GDT_WATCH_TIMEOUT);
			break;
		}
		TAILQ_REMOVE(&sc->sc_ccbq, ccb, gc_chain);

		if ((xs->flags & SCSI_POLL) == 0) {
			timeout_set(&ccb->gc_xs->stimeout, gdt_timeout, ccb);
			timeout_add_msec(&xs->stimeout, ccb->gc_timeout);
		}
	}
}

void
gdt_chain(struct gdt_softc *sc)
{
	GDT_DPRINTF(GDT_D_INTR, ("gdt_chain(%p) ", sc));

	if (!SIMPLEQ_EMPTY(&sc->sc_queue))
		gdt_scsi_cmd(SIMPLEQ_FIRST(&sc->sc_queue));
}

void
gdt_timeout(void *arg)
{
	struct gdt_ccb *ccb = arg;
	struct scsi_link *link = ccb->gc_xs->sc_link;
	struct gdt_softc *sc = link->adapter_softc;
	int s;

	sc_print_addr(link);
	printf("timed out\n");

	/* XXX Test for multiple timeouts */

	ccb->gc_xs->error = XS_TIMEOUT;
	s = splbio();
	gdt_enqueue_ccb(sc, ccb);
	splx(s);
}

void
gdt_watchdog(void *arg)
{
	struct gdt_ccb *ccb = arg;
	struct scsi_link *link = ccb->gc_xs->sc_link;
	struct gdt_softc *sc = link->adapter_softc;
	int s;

	s = splbio();
	ccb->gc_flags &= ~GDT_GCF_WATCHDOG;
	gdt_start_ccbs(sc);
	splx(s);
}

#if NBIO > 0
int
gdt_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct gdt_softc *sc = (struct gdt_softc *)dev;
	int error = 0;

	GDT_DPRINTF(GDT_D_IOCTL, ("%s: ioctl ", DEVNAME(sc)));

	switch (cmd) {
	case BIOCINQ:
		GDT_DPRINTF(GDT_D_IOCTL, ("inq "));
		error = gdt_ioctl_inq(sc, (struct bioc_inq *)addr);
		break;

	case BIOCVOL:
		GDT_DPRINTF(GDT_D_IOCTL, ("vol "));
		error = gdt_ioctl_vol(sc, (struct bioc_vol *)addr);
		break;

	case BIOCDISK:
		GDT_DPRINTF(GDT_D_IOCTL, ("disk "));
		error = gdt_ioctl_disk(sc, (struct bioc_disk *)addr);
		break;

	case BIOCALARM:
		GDT_DPRINTF(GDT_D_IOCTL, ("alarm "));
		error = gdt_ioctl_alarm(sc, (struct bioc_alarm *)addr);
		break;

	case BIOCSETSTATE:
		GDT_DPRINTF(GDT_D_IOCTL, ("setstate "));
		error = gdt_ioctl_setstate(sc, (struct bioc_setstate *)addr);
		break;

	default:
		GDT_DPRINTF(GDT_D_IOCTL, (" invalid ioctl\n"));
		error = EINVAL;
	}

	return (error);
}

int
gdt_ioctl_inq(struct gdt_softc *sc, struct bioc_inq *bi)
{
	bi->bi_novol = sc->sc_ndevs;
	bi->bi_nodisk = sc->sc_total_disks;

	strlcpy(bi->bi_dev, DEVNAME(sc), sizeof(bi->bi_dev));

	return (0);
}

int
gdt_ioctl_vol(struct gdt_softc *sc, struct bioc_vol *bv)
{
	return (1); /* XXX not yet */
}

int
gdt_ioctl_disk(struct gdt_softc *sc, struct bioc_disk *bd)
{
	return (1); /* XXX not yet */
}

int
gdt_ioctl_alarm(struct gdt_softc *sc, struct bioc_alarm *ba)
{
	return (1); /* XXX not yet */
}

int
gdt_ioctl_setstate(struct gdt_softc *sc, struct bioc_setstate *bs)
{
	return (1); /* XXX not yet */
}
#endif /* NBIO > 0 */
@


1.62
log
@replace the LIST_ENTRY in scsi_xfer with a SIMPLEQ_ENTRY. the things that
use it want something they can add to the end of they do horrible things
to be able to do that with the LIST_ENTRY.

this makes those horrible things a bit less horrible, and makes it easier
to use lists of scsi_xfers in other things.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.61 2012/08/15 02:38:14 jsg Exp $	*/
a40 2

#include <uvm/uvm_extern.h>
@


1.61
log
@Remove the old ioctl interface which has been disabled for over
six years (since bioctl support was added).

ok krw@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.60 2011/07/17 22:46:48 matthew Exp $	*/
d132 1
a132 1
	LIST_INIT(&sc->sc_queue);
d520 4
a523 8
	if (infront || LIST_FIRST(&sc->sc_queue) == NULL) {
		if (LIST_FIRST(&sc->sc_queue) == NULL)
			sc->sc_queuelast = xs;
		LIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);
		return;
	}
	LIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);
	sc->sc_queuelast = xs;
d534 3
a536 7
	xs = LIST_FIRST(&sc->sc_queue);
	if (xs == NULL)
		return (NULL);
	LIST_REMOVE(xs, free_list);

	if (LIST_FIRST(&sc->sc_queue) == NULL)
		sc->sc_queuelast = NULL;
d579 1
a579 1
	if (xs != LIST_FIRST(&sc->sc_queue))
d1302 2
a1303 2
	if (LIST_FIRST(&sc->sc_queue))
		gdt_scsi_cmd(LIST_FIRST(&sc->sc_queue));
@


1.60
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.59 2011/07/09 01:50:41 matthew Exp $	*/
a559 3
#if 0
	struct gdt_ucmd *ucmd;
#endif
a1423 124

#if 0
int
gdt_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	int error = 0;
	struct gdt_dummy *dummy;

	switch (cmd) {
	case GDT_IOCTL_DUMMY:
		dummy = (struct gdt_dummy *)addr;
		printf("%s: GDT_IOCTL_DUMMY %d\n", dev->dv_xname, dummy->x++);
		break;

	case GDT_IOCTL_GENERAL: {
		gdt_ucmd_t *ucmd;
		struct gdt_softc *sc = (struct gdt_softc *)dev;
		int s;

		ucmd = (gdt_ucmd_t *)addr;
		s = splbio();
		TAILQ_INSERT_TAIL(&sc->sc_ucmdq, ucmd, links);
		ucmd->complete_flag = FALSE;
		splx(s);
		gdt_chain(sc);
		if (!ucmd->complete_flag)
			(void)tsleep((void *)ucmd, PCATCH | PRIBIO, "gdtucw",
			    0);
		break;
	}

	case GDT_IOCTL_DRVERS:
		((gdt_drvers_t *)addr)->vers = 
		    (GDT_DRIVER_VERSION << 8) | GDT_DRIVER_SUBVERSION;
		break;

	case GDT_IOCTL_CTRCNT:
		((gdt_ctrcnt_t *)addr)->cnt = gdt_cnt;
		break;

#ifdef notyet
	case GDT_IOCTL_CTRTYPE: {
		gdt_ctrt_t *p;
		struct gdt_softc *sc = (struct gdt_softc *)dev;
	    
		p = (gdt_ctrt_t *)addr;
		p->oem_id = 0x8000;
		p->type = 0xfd;
		p->info = (sc->sc_bus << 8) | (sc->sc_slot << 3);
		p->ext_type = 0x6000 | sc->sc_subdevice;
		p->device_id = sc->sc_device;
		p->sub_device_id = sc->sc_subdevice;
		break;
	}
#endif

	case GDT_IOCTL_OSVERS: {
		gdt_osv_t *p;

		p = (gdt_osv_t *)addr;
		p->oscode = 10;
		p->version = osrelease[0] - '0';
		if (osrelease[1] == '.')
			p->subversion = osrelease[2] - '0';
		else
			p->subversion = 0;
		if (osrelease[3] == '.')
			p->revision = osrelease[4] - '0';
		else
			p->revision = 0;
		strlcpy(p->name, ostype, sizeof p->name);
		break;
	}

#ifdef notyet
	case GDT_IOCTL_EVENT: {
		gdt_event_t *p;
		int s;

		p = (gdt_event_t *)addr;
		if (p->erase == 0xff) {
			if (p->dvr.event_source == GDT_ES_TEST)
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.test);
			else if (p->dvr.event_source == GDT_ES_DRIVER)
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.driver);
			else if (p->dvr.event_source == GDT_ES_SYNC)
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.sync);
			else
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.async);
			s = splbio();
			gdt_store_event(p->dvr.event_source, p->dvr.event_idx,
			    &p->dvr.event_data);
			splx(s);
		} else if (p->erase == 0xfe) {
			s = splbio();
			gdt_clear_events();
			splx(s);
		} else if (p->erase == 0) {
			p->handle = gdt_read_event(p->handle, &p->dvr);
		} else {
			gdt_readapp_event((u_int8_t)p->erase, &p->dvr);
		}
		break;
	}
#endif

	case GDT_IOCTL_STATIST:
#if 0
		bcopy(&gdt_stat, (gdt_statist_t *)addr, sizeof gdt_stat);
#else
		error = EOPNOTSUPP;
#endif
		break;

	default:
		error = EINVAL;
	}
	return (error);
}
#endif /* 0 */
@


1.59
log
@Fix fallout from my previous SCSI refactoring diff (moving
adapter_buswidth to sc_targets): gdt(4) and atascsi(4) still used it
in other ways.

Apply appropriate fixes; tested on ahci(4).

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.58 2011/07/08 22:09:27 matthew Exp $	*/
d159 3
a161 1
	sc->sc_link.adapter_target = SCSI_NO_ADAPTER_TARGET;
a482 1
	saa.saa_targets = (sc->sc_class & GDT_FC) ? GDT_MAXID : GDT_MAX_HDRIVES;
@


1.58
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.57 2011/04/19 23:59:11 krw Exp $	*/
d159 1
a159 1
	sc->sc_link.adapter_target = sc->sc_link.adapter_buswidth;
@


1.57
log
@Iopoolification. Much simpler version than the one revived at k2k11.
This one works. For me at least.

Botch spotted by matthew@@.

ok matthew@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.56 2011/04/19 21:17:07 krw Exp $	*/
a158 2
	sc->sc_link.adapter_buswidth =
	    (sc->sc_class & GDT_FC) ? GDT_MAXID : GDT_MAX_HDRIVES;
d481 1
@


1.56
log
@Cease to pretend RAW SCSI mode exists. Eradicate all traces.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.55 2010/10/12 00:53:32 krw Exp $	*/
d72 2
a73 2
void	gdt_free_ccb(struct gdt_softc *, struct gdt_ccb *);
struct gdt_ccb *gdt_get_ccb(struct gdt_softc *, int);
d134 3
d162 1
d683 1
a683 11
			ccb = gdt_get_ccb(sc, xs->flags);
			/*
			 * We are out of commands, try again in a little while.
			 */
			if (ccb == NULL) {
				xs->error = XS_NO_CCB;
				scsi_done(xs);
				splx(s);
				return;
			}

d689 1
a709 1
					gdt_free_ccb(sc, ccb);
d728 1
a728 1
					xs->error = XS_NO_CCB;
a855 1
		gdt_free_ccb(sc, ccb);
a1076 1
	gdt_free_ccb(sc, ccb);
d1154 1
a1154 1
	int retries;
d1163 1
a1163 1
		ccb = gdt_get_ccb(sc, SCSI_NOSLEEP);
d1170 4
d1219 5
a1223 1
		if (!gdt_wait(sc, ccb, GDT_POLL_TIMEOUT))
d1232 2
a1233 2
struct gdt_ccb *
gdt_get_ccb(struct gdt_softc *sc, int flags)
d1235 1
a1236 1
	int s;
d1238 1
a1238 1
	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_get_ccb(%p, 0x%x) ", sc, flags));
d1240 5
a1244 1
	s = splbio();
a1245 13
	for (;;) {
		ccb = TAILQ_FIRST(&sc->sc_free_ccb);
		if (ccb != NULL)
			break;
		if (flags & SCSI_NOSLEEP)
			goto bail_out;
		tsleep(&sc->sc_free_ccb, PRIBIO, "gdt_ccb", 0);
	}

	TAILQ_REMOVE(&sc->sc_free_ccb, ccb, gc_chain);

 bail_out:
	splx(s);
d1250 1
a1250 1
gdt_free_ccb(struct gdt_softc *sc, struct gdt_ccb *ccb)
d1252 3
a1254 3
	int s;

	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_free_ccb(%p, %p) ", sc, ccb));
d1256 1
a1256 1
	s = splbio();
d1258 1
a1259 1

d1262 4
a1266 2

	splx(s);
@


1.55
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.54 2010/09/20 06:17:49 krw Exp $	*/
a84 1
void	gdt_raw_scsi_cmd(struct scsi_xfer *);
a100 4
struct scsi_adapter gdt_raw_switch = {
	gdt_raw_scsi_cmd, gdtminphys, 0, 0,
};

a481 20
	sc->sc_raw_link = malloc(sc->sc_bus_cnt * sizeof (struct scsi_link),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_raw_link == NULL)
		panic("gdt_attach");

	for (i = 0; i < sc->sc_bus_cnt; i++) {
		/* Fill in the prototype scsi_link. */
		sc->sc_raw_link[i].adapter_softc = sc;
		sc->sc_raw_link[i].adapter = &gdt_raw_switch;
		sc->sc_raw_link[i].adapter_target = 7;
		sc->sc_raw_link[i].openings = 4;	/* XXX a guess */
		sc->sc_raw_link[i].adapter_buswidth =
		    (sc->sc_class & GDT_FC) ? GDT_MAXID : 16;	/* XXX */

		bzero(&saa, sizeof(saa));
		saa.saa_sc_link = &sc->sc_raw_link[i];

		config_found(&sc->sc_dev, &saa, scsiprint);
	}

a964 37
}

/* Start a raw SCSI operation */
void
gdt_raw_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct gdt_softc *sc = link->adapter_softc;
	struct gdt_ccb *ccb;
	int s;

	GDT_DPRINTF(GDT_D_CMD, ("gdt_raw_scsi_cmd "));

	if (xs->cmdlen > 12 /* XXX create #define */) {
		GDT_DPRINTF(GDT_D_CMD, ("CDB too big %p ", xs));
		bzero(&xs->sense, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | SSD_ERRCODE_CURRENT;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* illcmd, 0x24 illfield */
		xs->error = XS_SENSE;
		scsi_done(xs);
		return;
	}

	if ((ccb = gdt_get_ccb(sc, xs->flags)) == NULL) {
		GDT_DPRINTF(GDT_D_CMD, ("no ccb available for %p ", xs));
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	xs->error = XS_DRIVER_STUFFUP;
	s = splbio();
	scsi_done(xs);
	gdt_free_ccb(sc, ccb);

	splx(s);
@


1.54
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.53 2010/08/12 00:26:55 matthew Exp $	*/
d966 1
@


1.53
log
@Initialize xs to NULL in gdt_intr() since it now might be used before
otherwise assigned.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.52 2010/08/11 02:18:25 krw Exp $	*/
d947 1
a947 1
		sd.error_code = 0x70;
d1005 1
a1005 1
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
@


1.52
log
@Fix two problems in gdt, introduced in 4.7. Eliminate a use-after-free
of xs for xs->flags. Avoid calling scsi_done() twice when sync'ing
disks during shut down.

scsi_done() problem found by Federico Giannici. Feedback and fixes
from matthew@@ and dlg@@. Testing of various versions by Federico and
sthen@@ via Pierre Berthier.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.51 2010/06/28 18:31:02 krw Exp $	*/
d1089 1
a1089 1
	struct scsi_xfer *xs;
@


1.51
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.50 2010/05/20 00:55:17 krw Exp $	*/
d590 1
d619 1
a763 1
				scsi_done(xs);
d771 1
a771 1
		if (xs->flags & SCSI_POLL) {
a1158 1

d1160 4
@


1.50
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.49 2010/03/29 23:33:39 krw Exp $	*/
a105 4
struct scsi_device gdt_dev = {
	NULL, NULL, NULL, NULL
};

a159 1
	sc->sc_link.device = &gdt_dev;
a496 1
		sc->sc_raw_link[i].device = &gdt_dev;
@


1.49
log
@Initialize various uninitialized variables. Found by jsg@@ via Clang.

Feedback from miod@@ and kettenis@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.48 2010/03/23 01:57:19 krw Exp $	*/
a1013 1
		s = splbio();
a1014 1
		splx(s);
a1020 1
		s = splbio();
a1021 1
		splx(s);
@


1.48
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.47 2010/01/09 23:15:06 krw Exp $	*/
d674 3
a676 1
			if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
@


1.47
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.46 2009/11/22 14:14:10 krw Exp $	*/
d85 2
a86 2
int	gdt_raw_scsi_cmd(struct scsi_xfer *);
int	gdt_scsi_cmd(struct scsi_xfer *);
d580 1
a580 1
int
d594 1
a594 1
	int error, retval = SUCCESSFULLY_QUEUED;
d612 1
a612 1
		return (COMPLETE);
d711 2
d714 1
a714 1
				return (NO_CCB);
a757 1
					splx(s);
d761 4
a764 1
					return (NO_CCB);
a774 1
			retval = COMPLETE;
a779 1
	return (retval);
d995 1
a995 1
int
d1015 1
a1015 1
		return (COMPLETE);
d1024 1
a1024 1
		return (COMPLETE);
a1032 2

	return (COMPLETE);
@


1.47.2.1
log
@MFC, original commits from a) krw@@:
----------------------------------------------------------------------
Fix two problems in gdt, introduced in 4.7. Eliminate a use-after-free
of xs for xs->flags. Avoid calling scsi_done() twice when sync'ing
disks during shut down.

scsi_done() problem found by Federico Giannici. Feedback and fixes
from matthew@@ and dlg@@. Testing of various versions by Federico and
sthen@@ via Pierre Berthier.

ok matthew@@ deraadt@@
----------------------------------------------------------------------

... and b) matthew@@:
----------------------------------------------------------------------
Initialize xs to NULL in gdt_intr() since it now might be used before
otherwise assigned.

ok krw@@
----------------------------------------------------------------------

ok matthew@@ and krw@@, re-tested by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.47 2010/01/09 23:15:06 krw Exp $	*/
a595 1
	int polled;
a623 1
		polled = ISSET(xs->flags, SCSI_POLL);
d762 1
d770 1
a770 1
		if (polled) {
d1096 1
a1096 1
	struct scsi_xfer *xs = NULL;
a1167 4
	case 0:
		if (xs && gdt_from_wait)
			scsi_done(xs);
		break;
@


1.46
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.45 2009/02/16 21:19:06 miod Exp $	*/
a609 1
		xs->flags |= ITSDONE;
a645 1
			xs->flags |= ITSDONE;
a652 1
			xs->flags |= ITSDONE;
a660 1
			xs->flags |= ITSDONE;
a700 1
					xs->flags |= ITSDONE;
a741 1
					xs->flags |= ITSDONE;
a761 1
				xs->flags |= ITSDONE;
a1025 1
	xs->flags |= ITSDONE;
a1168 1
		xs->flags |= ITSDONE;
@


1.45
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.44 2009/01/21 21:53:59 grange Exp $	*/
d766 1
a766 1
					return (TRY_AGAIN_LATER);
@


1.44
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.43 2008/11/24 00:31:35 krw Exp $	*/
d1192 1
a1192 1
gdtminphys(struct buf *bp)
@


1.43
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.42 2007/11/11 14:03:35 krw Exp $	*/
d1377 1
a1377 2
			timeout_add(&xs->stimeout,
			    (GDT_WATCH_TIMEOUT * hz) / 1000);
d1384 1
a1384 2
			timeout_add(&xs->stimeout,
			    (ccb->gc_timeout * hz) / 1000);
@


1.42
log
@The interrupt routine doesn't need to explicity invoke splbio/splx.
But the polling routine needs to wraps its call of the interrupt
routine with splbio/splx. This ensures scsi_done() is properly
protected.

While in the polling routine, fix the timing code so milliseconds are
not treated as microseconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.41 2007/10/17 03:21:16 fgsch Exp $	*/
d717 1
a717 1
				return (TRY_AGAIN_LATER);
@


1.41
log
@use ansi declarations and rename gdt to sc to avoid shadows and follow
what other drivers do; no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.40 2007/10/01 04:03:51 krw Exp $	*/
d599 2
a610 1
		s = splbio();
a615 2
	s = splbio();

a1106 1
	int s;
a1113 3
	if (!gdt_polling)
		s = splbio();

a1115 2
		if (!gdt_polling)
			splx(s);
a1173 2
	if (!gdt_polling)
		splx(s);
d1187 1
d1207 1
a1207 1
	int rv = 0;
d1214 4
a1217 1
		if (gdt_intr(sc) && sc == gdt_wait_gdt &&
d1222 1
a1222 1
		DELAY(1);
@


1.40
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.39 2007/04/28 00:35:16 deraadt Exp $	*/
d120 1
a120 2
gdt_attach(gdt)
	struct gdt_softc *gdt;
d129 13
a141 13
	if (bus_dmamem_alloc(gdt->sc_dmat, GDT_SCRATCH_SZ, PAGE_SIZE, 0,
	    &gdt->sc_scratch_seg, 1, &nsegs, BUS_DMA_NOWAIT))
	    panic("%s: bus_dmamem_alloc failed", DEVNAME(gdt));
	if (bus_dmamem_map(gdt->sc_dmat, &gdt->sc_scratch_seg, 1,
	    GDT_SCRATCH_SZ, &gdt->sc_scratch, BUS_DMA_NOWAIT))
	    panic("%s: bus_dmamem_map failed", DEVNAME(gdt));

	gdt_clear_events(gdt);

	TAILQ_INIT(&gdt->sc_free_ccb);
	TAILQ_INIT(&gdt->sc_ccbq);
	TAILQ_INIT(&gdt->sc_ucmdq);
	LIST_INIT(&gdt->sc_queue);
d145 2
a146 2
		gdt->sc_ccbs[i].gc_cmd_index = i + 2;
		error = bus_dmamap_create(gdt->sc_dmat,
d150 1
a150 1
		    &gdt->sc_ccbs[i].gc_dmamap_xfer);
d153 1
a153 1
			    DEVNAME(gdt), error);
d156 2
a157 2
		(void)gdt_ccb_set_cmd(gdt->sc_ccbs + i, GDT_GCF_UNUSED);
		TAILQ_INSERT_TAIL(&gdt->sc_free_ccb, &gdt->sc_ccbs[i],
d162 3
a164 3
	gdt->sc_link.adapter_softc = gdt;
	gdt->sc_link.adapter = &gdt_switch;
	gdt->sc_link.device = &gdt_dev;
d166 3
a168 3
	gdt->sc_link.adapter_buswidth =
	    (gdt->sc_class & GDT_FC) ? GDT_MAXID : GDT_MAX_HDRIVES;
	gdt->sc_link.adapter_target = gdt->sc_link.adapter_buswidth;
d170 1
a170 1
	if (!gdt_internal_cmd(gdt, GDT_SCREENSERVICE, GDT_INIT, 0, 0, 0)) {
d172 1
a172 1
		     gdt->sc_status);
d176 1
a176 1
	if (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,
d179 1
a179 1
		    gdt->sc_status);
d183 1
a183 1
	cdev_cnt = (u_int16_t)gdt->sc_info;
d186 6
a191 6
	gdt_enc32(gdt->sc_scratch + GDT_IOC_VERSION, GDT_IOC_NEWEST);
	gdt->sc_scratch[GDT_IOC_LIST_ENTRIES] = GDT_MAXBUS;
	gdt->sc_scratch[GDT_IOC_FIRST_CHAN] = 0;
	gdt->sc_scratch[GDT_IOC_LAST_CHAN] = GDT_MAXBUS - 1;
	gdt_enc32(gdt->sc_scratch + GDT_IOC_LIST_OFFSET, GDT_IOC_HDR_SZ);
	if (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,
d194 3
a196 3
		gdt->sc_bus_cnt = gdt->sc_scratch[GDT_IOC_CHAN_COUNT];
		for (i = 0; i < gdt->sc_bus_cnt; i++) {
			id = gdt->sc_scratch[GDT_IOC_HDR_SZ +
d198 1
a198 1
			gdt->sc_bus_id[id] = id < GDT_MAXBUS ? id : 0xff;
d203 1
a203 1
		gdt_enc32(gdt->sc_scratch + GDT_GETCH_CHANNEL_NO, i);
d205 1
a205 1
			if (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,
d211 1
a211 1
					    "error %d\n", gdt->sc_status);
d216 3
a218 3
			gdt->sc_bus_id[i] =
			    (gdt->sc_scratch[GDT_GETCH_SIOP_ID] < GDT_MAXID) ?
			    gdt->sc_scratch[GDT_GETCH_SIOP_ID] : 0xff;
d220 1
a220 1
		gdt->sc_bus_cnt = i;
d224 1
a224 1
	if (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_CACHE_INFO,
d226 1
a226 1
		printf("cannot get cache info, error %d\n", gdt->sc_status);
d229 9
a237 9
	gdt->sc_cpar.cp_version =
	    gdt_dec32(gdt->sc_scratch + GDT_CPAR_VERSION);
	gdt->sc_cpar.cp_state = gdt_dec16(gdt->sc_scratch + GDT_CPAR_STATE);
	gdt->sc_cpar.cp_strategy =
	    gdt_dec16(gdt->sc_scratch + GDT_CPAR_STRATEGY);
	gdt->sc_cpar.cp_write_back =
	    gdt_dec16(gdt->sc_scratch + GDT_CPAR_WRITE_BACK);
	gdt->sc_cpar.cp_block_size =
	    gdt_dec16(gdt->sc_scratch + GDT_CPAR_BLOCK_SIZE);
d240 2
a241 2
	gdt->sc_more_proc = 0;
	if (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_BOARD_INFO,
d244 52
a295 52
		gdt->sc_binfo.bi_ser_no =
		    gdt_dec32(gdt->sc_scratch + GDT_BINFO_SER_NO);
		bcopy(gdt->sc_scratch + GDT_BINFO_OEM_ID,
		    gdt->sc_binfo.bi_oem_id, sizeof gdt->sc_binfo.bi_oem_id);
		gdt->sc_binfo.bi_ep_flags =
		    gdt_dec16(gdt->sc_scratch + GDT_BINFO_EP_FLAGS);
		gdt->sc_binfo.bi_proc_id =
		    gdt_dec32(gdt->sc_scratch + GDT_BINFO_PROC_ID);
		gdt->sc_binfo.bi_memsize =
		    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEMSIZE);
		gdt->sc_binfo.bi_mem_banks =
		    gdt->sc_scratch[GDT_BINFO_MEM_BANKS];
		gdt->sc_binfo.bi_chan_type =
		    gdt->sc_scratch[GDT_BINFO_CHAN_TYPE];
		gdt->sc_binfo.bi_chan_count =
		    gdt->sc_scratch[GDT_BINFO_CHAN_COUNT];
		gdt->sc_binfo.bi_rdongle_pres =
		    gdt->sc_scratch[GDT_BINFO_RDONGLE_PRES];
		gdt->sc_binfo.bi_epr_fw_ver =
		    gdt_dec32(gdt->sc_scratch + GDT_BINFO_EPR_FW_VER);
		gdt->sc_binfo.bi_upd_fw_ver =
		    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_FW_VER);
		gdt->sc_binfo.bi_upd_revision =
		    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_REVISION);
		bcopy(gdt->sc_scratch + GDT_BINFO_TYPE_STRING,
		    gdt->sc_binfo.bi_type_string,
		    sizeof gdt->sc_binfo.bi_type_string);
		bcopy(gdt->sc_scratch + GDT_BINFO_RAID_STRING,
		    gdt->sc_binfo.bi_raid_string,
		    sizeof gdt->sc_binfo.bi_raid_string);
		gdt->sc_binfo.bi_update_pres =
		    gdt->sc_scratch[GDT_BINFO_UPDATE_PRES];
		gdt->sc_binfo.bi_xor_pres =
		    gdt->sc_scratch[GDT_BINFO_XOR_PRES];
		gdt->sc_binfo.bi_prom_type =
		    gdt->sc_scratch[GDT_BINFO_PROM_TYPE];
		gdt->sc_binfo.bi_prom_count =
		    gdt->sc_scratch[GDT_BINFO_PROM_COUNT];
		gdt->sc_binfo.bi_dup_pres =
		    gdt_dec32(gdt->sc_scratch + GDT_BINFO_DUP_PRES);
		gdt->sc_binfo.bi_chan_pres =
		    gdt_dec32(gdt->sc_scratch + GDT_BINFO_CHAN_PRES);
		gdt->sc_binfo.bi_mem_pres =
		    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEM_PRES);
		gdt->sc_binfo.bi_ft_bus_system =
		    gdt->sc_scratch[GDT_BINFO_FT_BUS_SYSTEM];
		gdt->sc_binfo.bi_subtype_valid =
		    gdt->sc_scratch[GDT_BINFO_SUBTYPE_VALID];
		gdt->sc_binfo.bi_board_subtype =
		    gdt->sc_scratch[GDT_BINFO_BOARD_SUBTYPE];
		gdt->sc_binfo.bi_rampar_pres =
		    gdt->sc_scratch[GDT_BINFO_RAMPAR_PRES];
d297 1
a297 1
		if (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,
d299 9
a307 9
			gdt->sc_bfeat.bf_chaining =
			    gdt->sc_scratch[GDT_BFEAT_CHAINING];
			gdt->sc_bfeat.bf_striping =
			    gdt->sc_scratch[GDT_BFEAT_STRIPING];
			gdt->sc_bfeat.bf_mirroring =
			    gdt->sc_scratch[GDT_BFEAT_MIRRORING];
			gdt->sc_bfeat.bf_raid =
			    gdt->sc_scratch[GDT_BFEAT_RAID];
			gdt->sc_more_proc = 1;
d314 1
a314 1
	if (gdt->sc_more_proc) {
d318 6
a323 6
		gdt_enc32(gdt->sc_scratch + GDT_IOC_VERSION, GDT_IOC_NEWEST);
		gdt->sc_scratch[GDT_IOC_LIST_ENTRIES] = GDT_MAXBUS;
		gdt->sc_scratch[GDT_IOC_FIRST_CHAN] = 0;
		gdt->sc_scratch[GDT_IOC_LAST_CHAN] = GDT_MAXBUS - 1;
		gdt_enc32(gdt->sc_scratch + GDT_IOC_LIST_OFFSET, GDT_IOC_HDR_SZ);
		if (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,
d327 3
a329 3
			for (bus = 0; bus < gdt->sc_bus_cnt; bus++) {
				gdt->sc_raw[bus].ra_address =
				    gdt_dec32(gdt->sc_scratch +
d333 2
a334 2
				gdt->sc_raw[bus].ra_local_no =
				    gdt_dec8(gdt->sc_scratch +
d341 2
a342 2
				    gdt->sc_raw[bus].ra_address,
				    gdt->sc_raw[bus].ra_local_no));
d346 3
a348 3
			for (bus = 0; bus < gdt->sc_bus_cnt; bus++) {
				gdt->sc_raw[bus].ra_address = GDT_IO_CHANNEL;
				gdt->sc_raw[bus].ra_local_no = bus;
d352 2
a353 2
				    gdt->sc_raw[bus].ra_address,
				    gdt->sc_raw[bus].ra_local_no));
d357 4
a360 4
		for (bus = 0; bus < gdt->sc_bus_cnt; bus++) {
			gdt_enc32(gdt->sc_scratch + GDT_GETCH_CHANNEL_NO,
			    gdt->sc_raw[bus].ra_local_no);
			if (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,
d362 1
a362 1
			    gdt->sc_raw[bus].ra_address | GDT_INVALID_CHANNEL,
d364 2
a365 2
				gdt->sc_raw[bus].ra_phys_cnt =
				    gdt_dec32(gdt->sc_scratch +
d368 1
a368 1
				    bus, gdt->sc_raw[bus].ra_phys_cnt));
d372 2
a373 2
			if (gdt->sc_raw[bus].ra_phys_cnt > 0) {
				gdt_enc32(gdt->sc_scratch +
d375 2
a376 2
				    gdt->sc_raw[bus].ra_local_no);
				gdt_enc32(gdt->sc_scratch +
d378 2
a379 2
				    gdt->sc_raw[bus].ra_phys_cnt);
				if (gdt_internal_cmd(gdt, GDT_CACHESERVICE,
d382 1
a382 1
				    gdt->sc_raw[bus].ra_address |
d386 1
a386 1
					    j < gdt->sc_raw[bus].ra_phys_cnt;
d388 2
a389 2
						gdt->sc_raw[bus].ra_id_list[j] =
						    gdt_dec32(gdt->sc_scratch +
d394 1
a394 1
						    gdt->sc_raw[bus].ra_id_list[j]));
d397 1
a397 1
					gdt->sc_raw[bus].ra_phys_cnt = 0;
d400 1
a400 1
			gdt->sc_total_disks += gdt->sc_raw[bus].ra_phys_cnt;
d402 1
a402 1
	} /* if (gdt->sc_more_proc) */
d404 1
a404 1
	if (!gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_INIT, 0, 0, 0)) {
d406 1
a406 1
		    gdt->sc_status);
d411 2
a412 2
	gdt->sc_raw_feat = 0;
	if (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_SET_FEAT,
d414 1
a414 1
		if (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_GET_FEAT, 0,
d416 1
a416 1
			gdt->sc_raw_feat = gdt->sc_info;
d419 2
a420 2
	gdt->sc_cache_feat = 0;
	if (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_SET_FEAT, 0,
d422 1
a422 1
		if (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_GET_FEAT, 0, 0,
d424 1
a424 1
			gdt->sc_cache_feat = gdt->sc_info;
d428 1
a428 1
	gdt->sc_ndevs = 0;
d431 1
a431 1
		if (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INFO, i, 0,
d433 2
a434 2
			gdt->sc_hdr[i].hd_present = 1;
			gdt->sc_hdr[i].hd_size = gdt->sc_info;
d436 2
a437 2
			if (gdt->sc_hdr[i].hd_size > 0)
				gdt->sc_ndevs++;
d442 3
a444 3
			gdt->sc_hdr[i].hd_size &= ~GDT_SECS32;
			if (gdt->sc_info2 == 0)
				gdt_eval_mapping(gdt->sc_hdr[i].hd_size,
d447 3
a449 3
				drv_hds = gdt->sc_info2 & 0xff;
				drv_secs = (gdt->sc_info2 >> 8) & 0xff;
				drv_cyls = gdt->sc_hdr[i].hd_size / drv_hds /
d452 2
a453 2
			gdt->sc_hdr[i].hd_heads = drv_hds;
			gdt->sc_hdr[i].hd_secs = drv_secs;
d455 1
a455 1
			gdt->sc_hdr[i].hd_size = drv_cyls * drv_hds * drv_secs;
d457 1
a457 1
			if (gdt_internal_cmd(gdt, GDT_CACHESERVICE,
d459 1
a459 1
				gdt->sc_hdr[i].hd_devtype = gdt->sc_info;
d462 2
a463 2
	if (gdt->sc_ndevs == 0)
		gdt->sc_link.openings = 0;
d465 2
a466 2
		gdt->sc_link.openings = (GDT_MAXCMDS - GDT_CMD_RESERVE) /
		    gdt->sc_ndevs;
d469 2
a470 2
	    (long long)gdt->sc_dpmembase,
	    gdt->sc_bus_cnt, cdev_cnt, cdev_cnt == 1 ? "" : "s");
d472 4
a475 4
	    DEVNAME(gdt), gdt->sc_cpar.cp_version,
	    gdt->sc_cpar.cp_state ? "on" : "off", gdt->sc_cpar.cp_strategy,
	    gdt->sc_cpar.cp_write_back ? "on" : "off",
	    gdt->sc_cpar.cp_block_size);
d477 2
a478 2
	printf("%s: raw feat %x cache feat %x\n", DEVNAME(gdt),
	    gdt->sc_raw_feat, gdt->sc_cache_feat);
d482 2
a483 2
	if (bio_register(&gdt->sc_dev, gdt_ioctl) != 0)
		panic("%s: controller registration failed", DEVNAME(gdt));
d488 1
a488 1
	saa.saa_sc_link = &gdt->sc_link;
d490 1
a490 1
	config_found(&gdt->sc_dev, &saa, scsiprint);
d492 1
a492 1
	gdt->sc_raw_link = malloc(gdt->sc_bus_cnt * sizeof (struct scsi_link),
d494 1
a494 1
	if (gdt->sc_raw_link == NULL)
d497 1
a497 1
	for (i = 0; i < gdt->sc_bus_cnt; i++) {
d499 7
a505 7
		gdt->sc_raw_link[i].adapter_softc = gdt;
		gdt->sc_raw_link[i].adapter = &gdt_raw_switch;
		gdt->sc_raw_link[i].adapter_target = 7;
		gdt->sc_raw_link[i].device = &gdt_dev;
		gdt->sc_raw_link[i].openings = 4;	/* XXX a guess */
		gdt->sc_raw_link[i].adapter_buswidth =
		    (gdt->sc_class & GDT_FC) ? GDT_MAXID : 16;	/* XXX */
d508 1
a508 1
		saa.saa_sc_link = &gdt->sc_raw_link[i];
d510 1
a510 1
		config_found(&gdt->sc_dev, &saa, scsiprint);
d518 1
a518 3
gdt_eval_mapping(size, cyls, heads, secs)
	u_int32_t size;
	int *cyls, *heads, *secs;
d545 1
a545 4
gdt_enqueue(gdt, xs, infront)
	struct gdt_softc *gdt;
	struct scsi_xfer *xs;
	int infront;
d547 4
a550 4
	if (infront || LIST_FIRST(&gdt->sc_queue) == NULL) {
		if (LIST_FIRST(&gdt->sc_queue) == NULL)
			gdt->sc_queuelast = xs;
		LIST_INSERT_HEAD(&gdt->sc_queue, xs, free_list);
d553 2
a554 2
	LIST_INSERT_AFTER(gdt->sc_queuelast, xs, free_list);
	gdt->sc_queuelast = xs;
d561 1
a561 2
gdt_dequeue(gdt)
	struct gdt_softc *gdt;
d565 1
a565 1
	xs = LIST_FIRST(&gdt->sc_queue);
d570 2
a571 2
	if (LIST_FIRST(&gdt->sc_queue) == NULL)
		gdt->sc_queuelast = NULL;
d581 1
a581 2
gdt_scsi_cmd(xs)
	struct scsi_xfer *xs;
d584 1
a584 1
	struct gdt_softc *gdt = link->adapter_softc;
d601 1
a601 1
	if (target >= GDT_MAX_HDRIVES || !gdt->sc_hdr[target].hd_present ||
d618 2
a619 2
	if (xs != LIST_FIRST(&gdt->sc_queue))
		gdt_enqueue(gdt, xs, 0);
d621 1
a621 1
	while ((xs = gdt_dequeue(gdt)) != NULL) {
d628 1
a628 1
		    gdt->sc_test_busy(gdt)) {
d633 1
a633 1
			gdt_enqueue(gdt, xs, 1);
d677 1
a677 1
			gdt->sc_cmd_off = 0;
d692 1
a692 1
				if (blockno >= gdt->sc_hdr[target].hd_size ||
d694 1
a694 1
				    gdt->sc_hdr[target].hd_size) {
d697 1
a697 1
					    DEVNAME(gdt), blockno,
d699 1
a699 1
					    gdt->sc_hdr[target].hd_size);
d712 1
a712 1
			ccb = gdt_get_ccb(gdt, xs->flags);
d730 1
a730 1
				error = bus_dmamap_load(gdt->sc_dmat, xfer,
d736 1
a736 1
					    DEVNAME(gdt));
d746 1
a746 1
					gdt_free_ccb(gdt, ccb);
d752 1
a752 1
				bus_dmamap_sync(gdt->sc_dmat, xfer, 0,
d759 1
a759 1
			gdt_enqueue_ccb(gdt, ccb);
d762 1
a762 1
				if (!gdt_wait(gdt, ccb, ccb->gc_timeout)) {
d765 1
a765 1
					    DEVNAME(gdt),
d790 1
a790 2
gdt_exec_ccb(ccb)
	struct gdt_ccb *ccb;
d794 1
a794 1
	struct gdt_softc *gdt = link->adapter_softc;
d807 1
a807 1
	gdt->sc_cmd_cnt = 0;
d813 2
a814 2
	if (gdt->sc_cmd_cnt == 0)
		gdt->sc_set_sema0(gdt);
d816 3
a818 3
	gdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX, ccb->gc_cmd_index);
	gdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);
	gdt_enc16(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DEVICENO,
d829 1
a829 1
			gdt->sc_cmd[GDT_CMD_OPCODE] = GDT_FLUSH;
d831 1
a831 1
		gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,
d839 1
a839 1
		gdt->sc_cmd[GDT_CMD_OPCODE] = GDT_WRITE;
d844 1
a844 1
		gdt->sc_cmd[GDT_CMD_OPCODE] = GDT_READ;
d850 1
a850 1
		gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,
d852 1
a852 1
		gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKCNT,
d856 1
a856 1
		if (gdt->sc_cache_feat & GDT_SCATTER_GATHER) {
d858 1
a858 1
			    gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
d861 1
a861 1
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
d865 1
a865 1
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
d876 1
a876 1
			    gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_LST +
d881 1
a881 1
			    gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
d886 1
a886 1
	gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_CANZ, sg_canz);
d888 1
a888 1
	gdt->sc_cmd_len =
d892 5
a896 5
	if (gdt->sc_cmd_cnt > 0 &&
	    gdt->sc_cmd_off + gdt->sc_cmd_len + GDT_DPMEM_COMMAND_OFFSET >
	    gdt->sc_ic_all_size) {
		printf("%s: DPMEM overflow\n", DEVNAME(gdt));
		gdt_free_ccb(gdt, ccb);
d904 2
a905 2
	gdt->sc_copy_cmd(gdt, ccb);
	gdt->sc_release_event(gdt, ccb);
d916 1
a916 4
gdt_copy_internal_data(xs, data, size)
	struct scsi_xfer *xs;
	u_int8_t *data;
	size_t size;
d932 1
a932 2
gdt_internal_cache_cmd(xs)
	struct scsi_xfer *xs;
d935 1
a935 1
	struct gdt_softc *gdt = link->adapter_softc;
d966 1
a966 1
		    gdt->sc_hdr[target].hd_devtype));
d969 1
a969 1
		    (gdt->sc_hdr[target].hd_devtype & 4) ? T_CDROM : T_DIRECT;
d971 1
a971 1
		    (gdt->sc_hdr[target].hd_devtype & 1) ? SID_REMOVABLE : 0;
d985 1
a985 1
		_lto4b(gdt->sc_hdr[target].hd_size - 1, rcd.addr);
d1002 1
a1002 2
gdt_raw_scsi_cmd(xs)
	struct scsi_xfer *xs;
d1005 1
a1005 1
	struct gdt_softc *gdt = link->adapter_softc;
d1024 1
a1024 1
	if ((ccb = gdt_get_ccb(gdt, xs->flags)) == NULL) {
d1037 1
a1037 1
	gdt_free_ccb(gdt, ccb);
d1045 1
a1045 2
gdt_clear_events(gdt)
	struct gdt_softc *gdt;
d1047 1
a1047 1
	GDT_DPRINTF(GDT_D_MISC, ("gdt_clear_events(%p) ", gdt));
d1053 1
a1053 3
gdt_async_event(gdt, service)
	struct gdt_softc *gdt;
	int service;
d1055 1
a1055 1
	GDT_DPRINTF(GDT_D_INTR, ("gdt_async_event(%p, %d) ", gdt, service));
d1067 2
a1068 5
gdt_sync_event(gdt, service, index, xs)
	struct gdt_softc *gdt;
	int service;
	u_int8_t index;
	struct scsi_xfer *xs;
d1071 1
a1071 1
	    ("gdt_sync_event(%p, %d, %d, %p) ", gdt, service, index, xs));
d1078 1
a1078 1
		switch (gdt->sc_status) {
d1089 1
a1089 1
			    gdt->sc_status));
d1099 1
a1099 2
gdt_intr(arg)
	void *arg;
d1101 1
a1101 1
	struct gdt_softc *gdt = arg;
d1110 1
a1110 1
	GDT_DPRINTF(GDT_D_INTR, ("gdt_intr(%p) ", gdt));
d1119 1
a1119 1
	ctx.istatus = gdt->sc_get_status(gdt);
d1123 1
a1123 1
		gdt->sc_status = GDT_S_NO_STATUS;
d1130 1
a1130 1
	gdt->sc_intr(gdt, &ctx);
d1132 3
a1134 3
	gdt->sc_status = ctx.cmd_status;
	gdt->sc_info = ctx.info;
	gdt->sc_info2 = ctx.info2;
d1137 1
a1137 1
		gdt_wait_gdt = gdt;
d1143 1
a1143 1
		gdt_async_event(gdt, ctx.service);
d1148 1
a1148 1
		    DEVNAME(gdt), ctx.info, ctx.info2);
d1153 1
a1153 1
	ccb = &gdt->sc_ccbs[ctx.istatus - 2];
d1161 1
a1161 1
		bus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer, 0,
d1165 1
a1165 1
		bus_dmamap_unload(gdt->sc_dmat, ccb->gc_dmamap_xfer);
d1167 1
a1167 1
	gdt_free_ccb(gdt, ccb);
d1178 1
a1178 1
	sync_val = gdt_sync_event(gdt, ctx.service, ctx.istatus, xs);
d1191 1
a1191 1
		gdt_enqueue(gdt, xs, 0);
d1195 1
a1195 1
		gdt_chain(gdt);
d1200 1
a1200 2
gdtminphys(bp)
	struct buf *bp;
d1213 1
a1213 4
gdt_wait(gdt, ccb, timeout)
	struct gdt_softc *gdt;
	struct gdt_ccb *ccb;
	int timeout;
d1218 1
a1218 1
	    ("gdt_wait(%p, %p, %d) ", gdt, ccb, timeout));
d1222 1
a1222 1
		if (gdt_intr(gdt) && gdt == gdt_wait_gdt &&
d1231 1
a1231 1
	while (gdt->sc_test_busy(gdt))
d1238 2
a1239 5
gdt_internal_cmd(gdt, service, opcode, arg1, arg2, arg3)
	struct gdt_softc *gdt;
	u_int8_t service;
	u_int16_t opcode;
	u_int32_t arg1, arg2, arg3;
d1245 1
a1245 1
	    gdt, service, opcode, arg1, arg2, arg3));
d1247 1
a1247 1
	bzero(gdt->sc_cmd, GDT_CMD_SZ);
d1250 1
a1250 1
		ccb = gdt_get_ccb(gdt, SCSI_NOSLEEP);
d1253 1
a1253 1
			    DEVNAME(gdt));
d1259 2
a1260 2
		gdt->sc_set_sema0(gdt);
		gdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX,
d1262 2
a1263 2
		gdt_enc16(gdt->sc_cmd + GDT_CMD_OPCODE, opcode);
		gdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);
d1268 1
a1268 1
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
d1270 1
a1270 1
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
d1272 1
a1272 1
				gdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +
d1274 1
a1274 1
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
d1276 1
a1276 1
				    gdt->sc_scratch_seg.ds_addr);
d1278 1
a1278 1
				gdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +
d1280 1
a1280 1
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
d1286 1
a1286 1
			gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
d1288 1
a1288 1
			gdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_BUS] =
d1290 1
a1290 1
			gdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_TARGET] =
d1292 1
a1292 1
			gdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_LUN] =
d1296 5
a1300 5
		gdt->sc_cmd_len = GDT_CMD_SZ;
		gdt->sc_cmd_off = 0;
		gdt->sc_cmd_cnt = 0;
		gdt->sc_copy_cmd(gdt, ccb);
		gdt->sc_release_event(gdt, ccb);
d1302 1
a1302 1
		if (!gdt_wait(gdt, ccb, GDT_POLL_TIMEOUT))
d1304 1
a1304 1
		if (gdt->sc_status != GDT_S_BSY || --retries == 0)
d1308 1
a1308 1
	return (gdt->sc_status == GDT_S_OK);
d1312 1
a1312 3
gdt_get_ccb(gdt, flags)
	struct gdt_softc *gdt;
	int flags;
d1317 1
a1317 1
	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_get_ccb(%p, 0x%x) ", gdt, flags));
d1322 1
a1322 1
		ccb = TAILQ_FIRST(&gdt->sc_free_ccb);
d1327 1
a1327 1
		tsleep(&gdt->sc_free_ccb, PRIBIO, "gdt_ccb", 0);
d1330 1
a1330 1
	TAILQ_REMOVE(&gdt->sc_free_ccb, ccb, gc_chain);
d1338 1
a1338 3
gdt_free_ccb(gdt, ccb)
	struct gdt_softc *gdt;
	struct gdt_ccb *ccb;
d1342 1
a1342 1
	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_free_ccb(%p, %p) ", gdt, ccb));
d1346 1
a1346 1
	TAILQ_INSERT_HEAD(&gdt->sc_free_ccb, ccb, gc_chain);
d1350 1
a1350 1
		wakeup(&gdt->sc_free_ccb);
d1356 1
a1356 3
gdt_enqueue_ccb(gdt, ccb)
	struct gdt_softc *gdt;
	struct gdt_ccb *ccb;
d1358 1
a1358 1
	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_enqueue_ccb(%p, %p) ", gdt, ccb));
d1361 2
a1362 2
	TAILQ_INSERT_TAIL(&gdt->sc_ccbq, ccb, gc_chain);
	gdt_start_ccbs(gdt);
d1366 1
a1366 2
gdt_start_ccbs(gdt)
	struct gdt_softc *gdt;
d1371 1
a1371 1
	GDT_DPRINTF(GDT_D_QUEUE, ("gdt_start_ccbs(%p) ", gdt));
d1373 1
a1373 1
	while ((ccb = TAILQ_FIRST(&gdt->sc_ccbq)) != NULL) {
d1386 1
a1386 1
		TAILQ_REMOVE(&gdt->sc_ccbq, ccb, gc_chain);
d1397 1
a1397 2
gdt_chain(gdt)
	struct gdt_softc *gdt;
d1399 1
a1399 1
	GDT_DPRINTF(GDT_D_INTR, ("gdt_chain(%p) ", gdt));
d1401 2
a1402 2
	if (LIST_FIRST(&gdt->sc_queue))
		gdt_scsi_cmd(LIST_FIRST(&gdt->sc_queue));
d1406 1
a1406 2
gdt_timeout(arg)
	void *arg;
d1410 1
a1410 1
	struct gdt_softc *gdt = link->adapter_softc;
d1420 1
a1420 1
	gdt_enqueue_ccb(gdt, ccb);
d1425 1
a1425 2
gdt_watchdog(arg)
	void *arg;
d1429 1
a1429 1
	struct gdt_softc *gdt = link->adapter_softc;
d1434 1
a1434 1
	gdt_start_ccbs(gdt);
d1518 1
a1518 4
gdt_ioctl(dev, cmd, addr)
	struct device *dev;
	u_long cmd;
	caddr_t addr;
d1531 1
a1531 1
		struct gdt_softc *gdt = (struct gdt_softc *)dev;
d1536 1
a1536 1
		TAILQ_INSERT_TAIL(&gdt->sc_ucmdq, ucmd, links);
d1539 1
a1539 1
		gdt_chain(gdt);
d1558 1
a1558 1
		struct gdt_softc *gdt = (struct gdt_softc *)dev;
d1563 4
a1566 4
		p->info = (gdt->sc_bus << 8) | (gdt->sc_slot << 3);
		p->ext_type = 0x6000 | gdt->sc_subdevice;
		p->device_id = gdt->sc_device;
		p->sub_device_id = gdt->sc_subdevice;
@


1.39
log
@missing splbio/splx pair (which splasserted me per-device probe) in
polling mode code; ok dlg marco krw
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.37 2006/11/28 23:59:45 dlg Exp $	*/
d494 1
a494 1
				  M_DEVBUF, M_NOWAIT);
a496 1
	bzero(gdt->sc_raw_link, gdt->sc_bus_cnt * sizeof (struct scsi_link));
@


1.38
log
@remove abstraction around splbio/splx; they just confuse things; ok dlg marco krw
@
text
@d618 1
d620 1
@


1.37
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.36 2006/05/08 19:52:13 deraadt Exp $	*/
d604 1
a604 1
	gdt_lock_t lock;
d622 1
a622 1
	lock = GDT_LOCK_GDT(lock);
d724 1
a724 1
				GDT_UNLOCK_GDT(gdt, lock);
d770 1
a770 1
					GDT_UNLOCK_GDT(gdt, lock);
d791 1
a791 1
	GDT_UNLOCK_GDT(gdt, lock);
a1023 2
	s = GDT_LOCK_GDT(gdt);

d1031 1
d1033 1
a1033 1
		GDT_UNLOCK_GDT(gdt, s);
d1040 1
d1042 1
a1042 1
		GDT_UNLOCK_GDT(gdt, s);
d1048 1
d1052 1
a1052 1
	GDT_UNLOCK_GDT(gdt, s);
d1128 1
a1128 1
	gdt_lock_t lock;
d1137 1
a1137 1
		lock = GDT_LOCK_GDT(gdt);
d1142 1
a1142 1
			GDT_UNLOCK_GDT(gdt, lock);
d1202 1
a1202 1
		GDT_UNLOCK_GDT(gdt, lock);
d1344 1
a1344 1
	gdt_lock_t lock;
d1348 1
a1348 1
	lock = GDT_LOCK_GDT(gdt);
d1362 1
a1362 1
	GDT_UNLOCK_GDT(gdt, lock);
d1371 1
a1371 1
	gdt_lock_t lock;
d1375 1
a1375 1
	lock = GDT_LOCK_GDT(gdt);
d1383 1
a1383 1
	GDT_UNLOCK_GDT(gdt, lock);
d1447 1
a1447 1
	gdt_lock_t lock;
d1455 1
a1455 1
	lock = GDT_LOCK_GDT(gdt);
d1457 1
a1457 1
	GDT_UNLOCK_GDT(gdt, lock);
d1467 1
a1467 1
	gdt_lock_t lock;
d1469 1
a1469 1
	lock = GDT_LOCK_GDT(gdt);
d1472 1
a1472 1
	GDT_UNLOCK_GDT(gdt, lock);
d1572 1
a1572 1
		gdt_lock_t lock;
d1575 1
a1575 1
		lock = GDT_LOCK_GDT(gdt);
d1578 1
a1578 1
		GDT_UNLOCK_GDT(gdt, lock);
d1632 1
a1632 1
		gdt_lock_t lock;
d1648 1
a1648 1
			lock = GDT_LOCK_GDT(gdt);
d1651 1
a1651 1
			GDT_UNLOCK_GDT(gdt, lock);
d1653 1
a1653 1
			lock = GDT_LOCK_GDT(gdt);
d1655 1
a1655 1
			GDT_UNLOCK_GDT(gdt, lock);
@


1.36
log
@silence a debug message; from kili@@outback.escape.de; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.35 2006/05/07 23:18:59 marco Exp $	*/
d123 1
d488 4
a491 1
	config_found(&gdt->sc_dev, &gdt->sc_link, scsiprint);
d509 4
a512 1
		config_found(&gdt->sc_dev, &gdt->sc_raw_link[i], scsiprint);
@


1.35
log
@Add remaining glue for physical disk count.
Fix a bugglet in the size of GDT_IOCHAN_DESC structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.34 2006/05/07 20:46:00 marco Exp $	*/
d468 2
a469 1
	printf("dpmem %x %d-bus %d cache device%s\n", gdt->sc_dpmembase,
@


1.34
log
@oops, use correct size for GET_IOC_CHAN_DESC
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.33 2006/05/07 20:34:08 marco Exp $	*/
d315 1
a315 1
		int bus;
d325 1
a325 1
		    GDT_IOC_HDR_SZ + GDT_IOC_SZ)) {
d356 46
d1513 1
a1513 1
	bi->bi_nodisk = 0;
@


1.33
log
@Add bio framework (not functional yet).
Replace index into struct for device name with DEVNAME macro.
Started translating linux driver back into swedish for gdt->sc_more_proc part.
Added initial scsi passthrough magic.
Added 2 new debug bits.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.32 2005/12/03 16:53:16 krw Exp $	*/
d317 1
d325 1
a325 1
		    GDT_IOC_HDR_SZ + GDT_RAWIOC_SZ)) {
a355 1

@


1.32
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.31 2005/12/03 16:22:24 krw Exp $	*/
d79 6
a84 1
#endif
d131 1
a131 1
	    panic("%s: bus_dmamem_alloc failed", gdt->sc_dev.dv_xname);
d134 1
a134 1
	    panic("%s: bus_dmamem_map failed", gdt->sc_dev.dv_xname);
d153 1
a153 1
			    gdt->sc_dev.dv_xname, error);
d315 42
a356 2
		/* XXX Not implemented yet */
	}
d425 1
a425 1
	    gdt->sc_dev.dv_xname, gdt->sc_cpar.cp_version,
d430 1
a430 1
	printf("%s: raw feat %x cache feat %x\n", gdt->sc_dev.dv_xname,
d436 1
a436 1
		panic("%s: controller registration failed", gdt->sc_dev.dv_xname);
d650 1
a650 1
					    gdt->sc_dev.dv_xname, blockno,
d689 1
a689 1
					    gdt->sc_dev.dv_xname);
d718 1
a718 1
					    gdt->sc_dev.dv_xname,
d849 1
a849 1
		printf("%s: DPMEM overflow\n", gdt->sc_dev.dv_xname);
d963 5
d970 22
a991 1
	/* XXX Not yet implemented */
d993 6
d1113 1
a1113 1
		    gdt->sc_dev.dv_xname, ctx.info, ctx.info2);
d1225 1
a1225 1
			    gdt->sc_dev.dv_xname);
d1422 78
d1623 2
a1624 1
#endif
@


1.31
log
@Don't retry unsupported SCSI commands by returning TRY_AGAIN_LATER.
They aren't going to be magically supported the next time. Elminates a
long delay at boot time, since TRY_AGAIN_LATER code was recently fixed
to delay a second before retrying and MODE SENSE commands were
reclassified as unsupported.

ok tdeval@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.30 2005/09/15 05:33:39 krw Exp $	*/
a624 1
				xs->error = XS_DRIVER_STUFFUP;
a674 1
					xs->error = XS_TIMEOUT;
@


1.30
log
@Don't fake MODE SENSE page 4 info inside raid drivers, just let sd
fake a geometry. Page 4 info does not get used for size information.
Eliminate now unused union scsi_disk_pages.

ok marco@@ mickey@@ pre-lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.29 2005/07/03 22:31:27 krw Exp $	*/
d74 1
a74 1
int	gdt_internal_cache_cmd(struct scsi_xfer *);
d555 1
a555 4
			if (!gdt_internal_cache_cmd(xs)) {
				GDT_UNLOCK_GDT(gdt, lock);
				return (TRY_AGAIN_LATER);
			}
d845 1
a845 1
int
d909 1
a909 1
		return (0);
a912 1
	return (1);
@


1.29
log
@Fix data_length values in simulationed MODE SENSE page 4 responses so
that scsi_do_mode_sense() accepts them.

The data_length value does not include itself, and the pg_length value
in a mode page does not include itself or the page_code fields. We
were +1 on the former and -2 on the latter resulting in a data_length
value that was too small by one.

Eliminates 'mode sense page 5 not simulated' messages.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.28 2004/04/12 05:33:04 deraadt Exp $	*/
a855 5
	struct {
		struct scsi_mode_header hd;
		struct scsi_blk_desc bd;
		union scsi_disk_pages dp;
	} mpd;
a899 37
	case MODE_SENSE:
		GDT_DPRINTF(GDT_D_CMD, ("MODE SENSE tgt %d ", target));

		bzero(&mpd, sizeof mpd);
		switch (((struct scsi_mode_sense *)xs->cmd)->page) {
		case 4:
			/* scsi_disk.h says this should be 0x16 */
			mpd.dp.rigid_geometry.pg_length = 0x16;
			mpd.hd.data_length = sizeof mpd.hd -
			    sizeof mpd.hd.data_length + sizeof mpd.bd +
			    sizeof mpd.dp.rigid_geometry;
			mpd.hd.blk_desc_len = sizeof mpd.bd;

			/* XXX */
			mpd.hd.dev_spec =
			    (gdt->sc_hdr[target].hd_devtype & 2) ? 0x80 : 0;
			_lto3b(GDT_SECTOR_SIZE, mpd.bd.blklen);
			mpd.dp.rigid_geometry.pg_code = 4;
			_lto3b(gdt->sc_hdr[target].hd_size /
			    gdt->sc_hdr[target].hd_heads /
			    gdt->sc_hdr[target].hd_secs,
			    mpd.dp.rigid_geometry.ncyl);
			mpd.dp.rigid_geometry.nheads =
			    gdt->sc_hdr[target].hd_heads;
			gdt_copy_internal_data(xs, (u_int8_t *)&mpd,
			    sizeof mpd);
			break;

		default:
			printf("%s: mode sense page %d not simulated\n",
			    gdt->sc_dev.dv_xname,
			    ((struct scsi_mode_sense *)xs->cmd)->page);
			xs->error = XS_DRIVER_STUFFUP;
			return (0);
		}
		break;

d909 2
a910 2
		printf("gdt_internal_cache_cmd got bad opcode: %d\n",
		    xs->cmd->opcode);
@


1.28
log
@This has been a pain in the ass for about 8 months which made new ICP
cards lock up under load: skip two initializations that we were
previously told to use by ICP themselves (ie. from their linux
driver).  now we are not supposed to use those APIs, because the new
firmwares for their new cards become unrealiable.  and that is all we
have been able to find out.  sigh.

For some cards, you must also be sure to get a new boot firmware from
ICP because they made another mistake: Any bootblock that tried to
switch back and forth between real and protected mode ended up with
corrupted registers.

from Achim_Leubner@@adaptec.com, via niklas, tested on a few cards
by a few people.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.27 2003/12/16 09:27:45 niklas Exp $	*/
d913 3
a915 2
			mpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +
			    mpd.dp.rigid_geometry.pg_length;
@


1.27
log
@Compute openings value, out of boot-time count of devices.
Add reentrancy check of gdt_exec_ccb.  The latter change changes timing enough
to not trigger a timing bug on really fast machines too often.
A real fix is being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.26 2003/06/28 23:56:40 avsm Exp $	*/
d61 1
a61 1
#define GDT_DRIVER_SUBVERSION 1
a177 13
	if (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_MOUNT, 0xffff, 1,
	    0)) {
		printf("cache service mount error %d\n",
		    gdt->sc_status);
		return (1);
	}

	if (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,
	    0)) {
		printf("cache service post-mount initialization error %d\n",
		    gdt->sc_status);
		return (1);
	}
@


1.27.2.1
log
@MFC:
Fix by deraadt@@

This has been a pain in the ass for about 8 months which made new ICP
cards lock up under load: skip two initializations that we were
previously told to use by ICP themselves (ie. from their linux
driver).  now we are not supposed to use those APIs, because the new
firmwares for their new cards become unrealiable.  and that is all we
have been able to find out.  sigh.

For some cards, you must also be sure to get a new boot firmware from
ICP because they made another mistake: Any bootblock that tried to
switch back and forth between real and protected mode ended up with
corrupted registers.

from Achim_Leubner@@adaptec.com, via niklas, tested on a few cards
by a few people.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.27 2003/12/16 09:27:45 niklas Exp $	*/
d61 1
a61 1
#define GDT_DRIVER_SUBVERSION 2
d178 13
@


1.26
log
@supply missing argument to a panic string; ok tedu, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.25 2003/06/03 20:49:28 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
d160 1
a160 2
	/* XXX what is optimal? */
	gdt->sc_link.openings = GDT_MAXCMDS;
d350 1
d358 3
d384 6
d726 2
d729 3
d825 3
d836 3
@


1.26.2.1
log
@MFC:
Fix by deraadt@@

This has been a pain in the ass for about 8 months which made new ICP
cards lock up under load: skip two initializations that we were
previously told to use by ICP themselves (ie. from their linux
driver).  now we are not supposed to use those APIs, because the new
firmwares for their new cards become unrealiable.  and that is all we
have been able to find out.  sigh.

For some cards, you must also be sure to get a new boot firmware from
ICP because they made another mistake: Any bootblock that tried to
switch back and forth between real and protected mode ended up with
corrupted registers.

from Achim_Leubner@@adaptec.com, via niklas, tested on a few cards
by a few people.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.26 2003/06/28 23:56:40 avsm Exp $	*/
d61 1
a61 1
#define GDT_DRIVER_SUBVERSION 2
d179 13
@


1.25
log
@fix various 3/4 licenses according to "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.24 2003/04/27 11:22:52 ho Exp $	*/
d395 1
a395 1
		panic("%s: controller registration failed");
@


1.24
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.23 2003/02/25 09:12:39 tedu Exp $	*/
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.23
log
@correct bounds check.  yichen xie's bounds checker catch.

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.22 2002/06/11 03:34:53 niklas Exp $	*/
d896 4
a899 3
		strcpy(inq.vendor, "ICP	   ");
		sprintf(inq.product, "Host drive  #%02d", target);
		strcpy(inq.revision, "	 ");
d1460 1
a1460 1
		strcpy(p->name, ostype);
@


1.22
log
@Checkpoint my work.  Register with bio, implement part of
the FreeBSD iir driver ioctl set.  Remove vtophys.  Some style.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.21 2002/06/08 21:26:00 nordin Exp $	*/
d212 1
a212 1
			gdt->sc_bus_id[id] = id < GDT_MAXID ? id : 0xff;
@


1.21
log
@Check result from malloc(9) when using M_NOWAIT. ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.20 2002/03/14 01:26:54 millert Exp $	*/
a37 1
#include <sys/systm.h>
d40 1
d43 1
d53 1
d57 2
d65 3
d82 3
d110 1
d124 1
a124 1
	int i, id, drv_cyls, drv_hds, drv_secs, error;
d128 8
d140 1
d398 6
d506 3
d538 1
a538 1
	while ((xs = gdt_dequeue(gdt))) {
d896 1
a896 1
		strcpy(inq.vendor, "ICP    ");
d898 1
a898 1
		strcpy(inq.revision, "   ");
a1134 6
#if 0
	u_int8_t *buf = bp->b_data;
	paddr_t pa;
	long off;
#endif

a1136 1
#if 1
d1138 2
a1139 1
	if (bp->b_bcount > ((GDT_MAXOFFSETS - 1) * PAGE_SIZE))
d1141 1
a1141 8
#else
	for (off = PAGE_SIZE, pa = vtophys(buf); off < bp->b_bcount;
	    off += PAGE_SIZE)
		if (pa + off != vtophys(buf + off)) {
			bp->b_bcount = off;
			break;
		}
#endif
d1215 1
a1215 1
				    vtophys(gdt->sc_scratch));
d1386 127
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.19 2002/03/05 07:51:06 niklas Exp $	*/
d382 2
@


1.19
log
@It is clear that I have not committed in a long time!!!!
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.18 2002/03/05 07:46:44 niklas Exp $	*/
d61 22
a82 22
int	gdt_async_event __P((struct gdt_softc *, int));
void	gdt_chain __P((struct gdt_softc *));
void	gdt_clear_events __P((struct gdt_softc *));
void	gdt_copy_internal_data __P((struct scsi_xfer *, u_int8_t *, size_t));
struct scsi_xfer *gdt_dequeue __P((struct gdt_softc *));
void	gdt_enqueue __P((struct gdt_softc *, struct scsi_xfer *, int));
void	gdt_enqueue_ccb __P((struct gdt_softc *, struct gdt_ccb *));
void	gdt_eval_mapping __P((u_int32_t, int *, int *, int *));
int	gdt_exec_ccb __P((struct gdt_ccb *));
void	gdt_free_ccb __P((struct gdt_softc *, struct gdt_ccb *));
struct gdt_ccb *gdt_get_ccb __P((struct gdt_softc *, int));
int	gdt_internal_cache_cmd __P((struct scsi_xfer *));
int	gdt_internal_cmd __P((struct gdt_softc *, u_int8_t, u_int16_t,
    u_int32_t, u_int32_t, u_int32_t));
int	gdt_raw_scsi_cmd __P((struct scsi_xfer *));
int	gdt_scsi_cmd __P((struct scsi_xfer *));
void	gdt_start_ccbs __P((struct gdt_softc *));
int	gdt_sync_event __P((struct gdt_softc *, int, u_int8_t,
    struct scsi_xfer *));
void	gdt_timeout __P((void *));
int	gdt_wait __P((struct gdt_softc *, struct gdt_ccb *, int));
void	gdt_watchdog __P((void *));
@


1.18
log
@doh, thanks mickey!
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.17 2002/03/05 06:58:54 niklas Exp $	*/
d607 1
a607 1
				AAC_UNLOCK(sc, lock);
@


1.17
log
@Deal gracefully with ccb starvation
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.16 2001/11/06 19:53:18 miod Exp $	*/
d607 2
a608 2
				xs->flags |= TRY_AGAIN_LATER;
				goto ready;
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.15 2001/11/05 17:25:58 art Exp $	*/
d603 1
a603 2
			 * Are we out of commands, something is wrong.
			 * 
a605 2
				printf("%s: no ccb in gdt_scsi_cmd",
				    gdt->sc_dev.dv_xname);
d607 1
a607 2
				xs->flags |= ITSDONE;
				scsi_done(xs);
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.16 2001/11/06 19:53:18 miod Exp $	*/
d61 22
a82 22
int	gdt_async_event(struct gdt_softc *, int);
void	gdt_chain(struct gdt_softc *);
void	gdt_clear_events(struct gdt_softc *);
void	gdt_copy_internal_data(struct scsi_xfer *, u_int8_t *, size_t);
struct scsi_xfer *gdt_dequeue(struct gdt_softc *);
void	gdt_enqueue(struct gdt_softc *, struct scsi_xfer *, int);
void	gdt_enqueue_ccb(struct gdt_softc *, struct gdt_ccb *);
void	gdt_eval_mapping(u_int32_t, int *, int *, int *);
int	gdt_exec_ccb(struct gdt_ccb *);
void	gdt_free_ccb(struct gdt_softc *, struct gdt_ccb *);
struct gdt_ccb *gdt_get_ccb(struct gdt_softc *, int);
int	gdt_internal_cache_cmd(struct scsi_xfer *);
int	gdt_internal_cmd(struct gdt_softc *, u_int8_t, u_int16_t,
    u_int32_t, u_int32_t, u_int32_t);
int	gdt_raw_scsi_cmd(struct scsi_xfer *);
int	gdt_scsi_cmd(struct scsi_xfer *);
void	gdt_start_ccbs(struct gdt_softc *);
int	gdt_sync_event(struct gdt_softc *, int, u_int8_t,
    struct scsi_xfer *);
void	gdt_timeout(void *);
int	gdt_wait(struct gdt_softc *, struct gdt_ccb *, int);
void	gdt_watchdog(void *);
a381 2
	if (gdt->sc_raw_link == NULL)
		panic("gdt_attach");
d603 2
a604 1
			 * We are out of commands, try again in a little while.
d607 2
d610 3
a612 2
				GDT_UNLOCK_GDT(gdt, lock);
				return (TRY_AGAIN_LATER);
@


1.16.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.16.2.1 2002/06/11 03:42:18 art Exp $	*/
d38 1
a40 1
#include <sys/ioctl.h>
a42 1
#include <sys/systm.h>
a51 1
#include <dev/biovar.h>
a54 2
#include "bio.h"

a60 3
#define GDT_DRIVER_VERSION 1
#define GDT_DRIVER_SUBVERSION 1

a74 3
#if NBIO > 0
int	gdt_ioctl(struct device *, u_long, caddr_t);
#endif
a99 1
int gdt_cnt = 0;
d113 1
a113 1
	int i, id, drv_cyls, drv_hds, drv_secs, error, nsegs;
a116 8

	if (bus_dmamem_alloc(gdt->sc_dmat, GDT_SCRATCH_SZ, PAGE_SIZE, 0,
	    &gdt->sc_scratch_seg, 1, &nsegs, BUS_DMA_NOWAIT))
	    panic("%s: bus_dmamem_alloc failed", gdt->sc_dev.dv_xname);
	if (bus_dmamem_map(gdt->sc_dmat, &gdt->sc_scratch_seg, 1,
	    GDT_SCRATCH_SZ, &gdt->sc_scratch, BUS_DMA_NOWAIT))
	    panic("%s: bus_dmamem_map failed", gdt->sc_dev.dv_xname);

a120 1
	TAILQ_INIT(&gdt->sc_ucmdq);
a377 6
#if NBIO > 0
	if (bio_register(&gdt->sc_dev, gdt_ioctl) != 0)
		panic("%s: controller registration failed");
#endif
	gdt_cnt++;

a479 3
#if 0
	struct gdt_ucmd *ucmd;
#endif
d509 1
a509 1
	while ((xs = gdt_dequeue(gdt)) != NULL) {
d867 1
a867 1
		strcpy(inq.vendor, "ICP	   ");
d869 1
a869 1
		strcpy(inq.revision, "	 ");
d1106 6
d1114 1
d1116 1
a1116 2
	if ((GDT_MAXOFFSETS - 1) * PAGE_SIZE < MAXPHYS &&
	    bp->b_bcount > ((GDT_MAXOFFSETS - 1) * PAGE_SIZE))
d1118 8
a1125 1

d1199 1
a1199 1
				    gdt->sc_scratch_seg.ds_addr);
a1369 127

#if NBIO > 0
int
gdt_ioctl(dev, cmd, addr)
	struct device *dev;
	u_long cmd;
	caddr_t addr;
{
	int error = 0;
	struct gdt_dummy *dummy;

	switch (cmd) {
	case GDT_IOCTL_DUMMY:
		dummy = (struct gdt_dummy *)addr;
		printf("%s: GDT_IOCTL_DUMMY %d\n", dev->dv_xname, dummy->x++);
		break;

	case GDT_IOCTL_GENERAL: {
		gdt_ucmd_t *ucmd;
		struct gdt_softc *gdt = (struct gdt_softc *)dev;
		gdt_lock_t lock;

		ucmd = (gdt_ucmd_t *)addr;
		lock = GDT_LOCK_GDT(gdt);
		TAILQ_INSERT_TAIL(&gdt->sc_ucmdq, ucmd, links);
		ucmd->complete_flag = FALSE;
		GDT_UNLOCK_GDT(gdt, lock);
		gdt_chain(gdt);
		if (!ucmd->complete_flag)
			(void)tsleep((void *)ucmd, PCATCH | PRIBIO, "gdtucw",
			    0);
		break;
	}

	case GDT_IOCTL_DRVERS:
		((gdt_drvers_t *)addr)->vers = 
		    (GDT_DRIVER_VERSION << 8) | GDT_DRIVER_SUBVERSION;
		break;

	case GDT_IOCTL_CTRCNT:
		((gdt_ctrcnt_t *)addr)->cnt = gdt_cnt;
		break;

#ifdef notyet
	case GDT_IOCTL_CTRTYPE: {
		gdt_ctrt_t *p;
		struct gdt_softc *gdt = (struct gdt_softc *)dev;
	    
		p = (gdt_ctrt_t *)addr;
		p->oem_id = 0x8000;
		p->type = 0xfd;
		p->info = (gdt->sc_bus << 8) | (gdt->sc_slot << 3);
		p->ext_type = 0x6000 | gdt->sc_subdevice;
		p->device_id = gdt->sc_device;
		p->sub_device_id = gdt->sc_subdevice;
		break;
	}
#endif

	case GDT_IOCTL_OSVERS: {
		gdt_osv_t *p;

		p = (gdt_osv_t *)addr;
		p->oscode = 10;
		p->version = osrelease[0] - '0';
		if (osrelease[1] == '.')
			p->subversion = osrelease[2] - '0';
		else
			p->subversion = 0;
		if (osrelease[3] == '.')
			p->revision = osrelease[4] - '0';
		else
			p->revision = 0;
		strcpy(p->name, ostype);
		break;
	}

#ifdef notyet
	case GDT_IOCTL_EVENT: {
		gdt_event_t *p;
		gdt_lock_t lock;

		p = (gdt_event_t *)addr;
		if (p->erase == 0xff) {
			if (p->dvr.event_source == GDT_ES_TEST)
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.test);
			else if (p->dvr.event_source == GDT_ES_DRIVER)
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.driver);
			else if (p->dvr.event_source == GDT_ES_SYNC)
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.sync);
			else
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.async);
			lock = GDT_LOCK_GDT(gdt);
			gdt_store_event(p->dvr.event_source, p->dvr.event_idx,
			    &p->dvr.event_data);
			GDT_UNLOCK_GDT(gdt, lock);
		} else if (p->erase == 0xfe) {
			lock = GDT_LOCK_GDT(gdt);
			gdt_clear_events();
			GDT_UNLOCK_GDT(gdt, lock);
		} else if (p->erase == 0) {
			p->handle = gdt_read_event(p->handle, &p->dvr);
		} else {
			gdt_readapp_event((u_int8_t)p->erase, &p->dvr);
		}
		break;
	}
#endif

	case GDT_IOCTL_STATIST:
#if 0
		bcopy(&gdt_stat, (gdt_statist_t *)addr, sizeof gdt_stat);
#else
		error = EOPNOTSUPP;
#endif
		break;

	default:
		error = EINVAL;
	}
	return (error);
}
#endif
@


1.16.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d212 1
a212 1
			gdt->sc_bus_id[id] = id < GDT_MAXBUS ? id : 0xff;
d896 3
a898 4
		strlcpy(inq.vendor, "ICP	   ", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Host drive  #%02d",
		    target);
		strlcpy(inq.revision, "	 ", sizeof inq.revision);
d1459 1
a1459 1
		strlcpy(p->name, ostype, sizeof p->name);
@


1.15
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.14 2001/08/12 20:12:12 mickey Exp $	*/
d46 1
a46 1
#include <vm/vm.h>
@


1.14
log
@remove some of the redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.13 2001/08/03 15:21:40 fgsch Exp $	*/
d646 2
a647 1
				bus_dmamap_sync(gdt->sc_dmat, xfer,
d1066 2
a1067 1
		bus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer,
@


1.13
log
@confgiuration -> configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.12 2001/07/04 06:43:18 niklas Exp $	*/
a46 1
#include <vm/pmap.h>
@


1.12
log
@Use the right target when checking for out of bounds.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.11 2000/12/13 16:03:11 mickey Exp $	*/
d218 1
a218 1
	/* Read cache confgiuration */
@


1.11
log
@better new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.10 2000/12/13 15:32:39 mickey Exp $	*/
d511 3
a513 1

@


1.10
log
@new timwouts; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.9 2000/11/10 09:42:14 niklas Exp $	*/
d1310 1
d1317 2
a1318 1
		if ((xs->flags & SCSI_POLL) == 0)
d1321 1
@


1.9
log
@improved queue handling + some small bug fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.8 2000/08/19 14:25:15 nate Exp $	*/
d1059 1
a1059 1
		untimeout(gdt_timeout, ccb);
d1288 1
d1298 1
d1303 2
d1306 1
a1306 1
			untimeout(gdt_watchdog, ccb);
d1310 1
a1310 1
			timeout(gdt_watchdog, ccb,
d1316 2
a1317 2
		if ((ccb->gc_xs->flags & SCSI_POLL) == 0)
			timeout(gdt_timeout, ccb,
@


1.8
log
@MALLOC/FREE -> malloc/free ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.7 2000/08/05 18:52:34 niklas Exp $	*/
d56 6
a144 1
	gdt->sc_link.adapter_target = 7;
d146 2
a147 1
	gdt->sc_link.openings = GDT_MAXCMDS;	/* XXX what is optimal? */
d150 1
d305 1
a305 1
		/* XXX Not implemented yet */		
d310 1
a310 1
		/* XXX Not implemented yet */		
d457 2
d467 4
a470 1
/* Start a SCSI operation on a cache device */
a478 1
	int dontqueue = 0;
d483 1
a483 1
	int error;
d488 2
d492 4
d497 2
d502 1
a502 2
	xs->error = XS_NOERROR;
	ccb = NULL;
d504 3
a506 10
	lock = GDT_LOCK_GDT(gdt);
	if (!gdt_polling && !(xs->flags & SCSI_POLL) &&
	    gdt->sc_test_busy(gdt)) {
		/* Don't double enqueue if we came from gdt_chain. */
		if (xs != LIST_FIRST(&gdt->sc_queue))
			gdt_enqueue(gdt, xs, 0);
		GDT_UNLOCK_GDT(gdt, lock);
		return (SUCCESSFULLY_QUEUED);
	}
	GDT_UNLOCK_GDT(gdt, lock);
d508 1
a508 16
	switch (xs->cmd->opcode) {
	case TEST_UNIT_READY:
	case REQUEST_SENSE:
	case INQUIRY:
	case MODE_SENSE:
	case START_STOP:
	case READ_CAPACITY:
#if 0
	case VERIFY:
#endif
		return (gdt_internal_cache_cmd(xs) ? COMPLETE :
		    TRY_AGAIN_LATER);

	case PREVENT_ALLOW:
		GDT_DPRINTF(GDT_D_CMD, ("PREVENT/ALLOW "));
		/* XXX Not yet implemented */
d510 1
a510 1
		return (COMPLETE);
d512 9
a520 6
	case READ_COMMAND:
	case READ_BIG:
	case WRITE_COMMAND:
	case WRITE_BIG:
	case SYNCHRONIZE_CACHE:
		lock = GDT_LOCK_GDT(gdt);
d522 25
a546 13
		/*
		 * When chaining commands we may get called with the
		 * first command in the queue, recognize this case
		 * easily.
		 */
		if (xs == LIST_FIRST(&gdt->sc_queue))
			xs = gdt_dequeue(gdt);
		else {
			/* A new command chain, start from the beginning.  */
			gdt->sc_cmd_off = 0;

			/* Don't resort to queuing if we are polling.  */
			dontqueue = xs->flags & SCSI_POLL;
d548 14
d563 1
a563 2
			 * The queue, if existent, must be processed first,
			 * before the new command can be run.
d565 28
a592 4
			if (LIST_FIRST(&gdt->sc_queue) != NULL) {
				/* If order cannot be preserved, punt.  */
				if (dontqueue) {
					GDT_UNLOCK_GDT(gdt, lock);
d594 3
a596 1
					return (TRY_AGAIN_LATER);
a597 7

				/*
				 * Enqueue the new command, ponder on the front
				 * command of the queue instead.
				 */
				gdt_enqueue(gdt, xs, 0);
				xs = gdt_dequeue(gdt);
a598 1
		}
d600 8
a607 19
		if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			/* A read or write operation. */
			if (xs->cmdlen == 6) {
				rw = (struct scsi_rw *)xs->cmd;
				blockno = _3btol(rw->addr) &
				    (SRW_TOPADDR << 16 | 0xffff);
				blockcnt = rw->length ? rw->length : 0x100;
			} else {
				rwb = (struct scsi_rw_big *)xs->cmd;
				blockno = _4btol(rwb->addr);
				blockcnt = _2btol(rwb->length);
			}
			if (blockno >= gdt->sc_hdr[target].hd_size ||
			    blockno + blockcnt > gdt->sc_hdr[target].hd_size) {
				GDT_UNLOCK_GDT(gdt, lock);
				printf("%s: out of bounds %u-%u >= %u\n",
				    gdt->sc_dev.dv_xname, blockno, blockcnt,
				    gdt->sc_hdr[target].hd_size);
				scsi_done(xs);
d609 1
a609 19
				return (COMPLETE);
			}
		}

		ccb = gdt_get_ccb(gdt, xs->flags);

		/*
		 * Are we out of commands, then queue.  If we cannot queue,
		 * then punt.
		 */
		if (ccb == NULL) {
			if (dontqueue) {
				GDT_UNLOCK_GDT(gdt, lock);
				scsi_done(xs);
				xs->error = XS_DRIVER_STUFFUP;
				return (COMPLETE);
			}
			if (xs->error) {
				GDT_UNLOCK_GDT(gdt, lock);
d611 1
a611 1
				return (COMPLETE);
d614 24
a637 5
			/* Put back on the queue, in the front.  */
			gdt_enqueue(gdt, xs, 1);
			GDT_UNLOCK_GDT(gdt, lock);
			return (SUCCESSFULLY_QUEUED);
		}
d639 10
a648 25
		ccb->gc_blockno = blockno;
		ccb->gc_blockcnt = blockcnt;
		ccb->gc_xs = xs;
		ccb->gc_timeout = xs->timeout;
		ccb->gc_service = GDT_CACHESERVICE;
		gdt_ccb_set_cmd(ccb, GDT_GCF_SCSI);

		if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			xfer = ccb->gc_dmamap_xfer;
			error = bus_dmamap_load(gdt->sc_dmat, xfer, xs->data, 
			    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? 
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
			if (error) {
				printf("%s: gdt_scsi_cmd: ",
				    gdt->sc_dev.dv_xname); 
				if (error == EFBIG)
					printf("more than %d dma segs\n",
					    GDT_MAXOFFSETS);
				else
					printf("error %d loading dma map\n",
					    error);
		
				xs->error = XS_DRIVER_STUFFUP;
				gdt_free_ccb(gdt, ccb);
				return (COMPLETE);
a649 4
			bus_dmamap_sync(gdt->sc_dmat, xfer,
			    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
			    BUS_DMASYNC_PREWRITE);
		}
d651 13
a663 9
		gdt_enqueue_ccb(gdt, ccb);
		/* XXX what if enqueue did not start a transfer? */
		if (gdt_polling || (xs->flags & SCSI_POLL)) {
			if (!gdt_wait(gdt, ccb, ccb->gc_timeout)) {
				GDT_UNLOCK_GDT(gdt, lock);
				printf("%s: command %d timed out\n",
				    gdt->sc_dev.dv_xname, ccb->gc_cmd_index);
				xs->error = XS_TIMEOUT;
				return (TRY_AGAIN_LATER);
d667 7
a673 5
		GDT_UNLOCK_GDT(gdt, lock);

		if (gdt_polling || (xs->flags & SCSI_POLL)) {
 			scsi_done(xs);
			return (COMPLETE);
d675 1
a675 1
		return (SUCCESSFULLY_QUEUED);
d677 2
a678 6
	default:
		GDT_DPRINTF(GDT_D_CMD, ("unknown opc %d ", xs->cmd->opcode));
		/* XXX Not yet implemented */
		xs->error = XS_DRIVER_STUFFUP;
		return (COMPLETE);
	}
d697 1
d699 1
a699 1
	 * XXX Yeah I know it's a always-true condition, but that may change
a813 2

	
d903 1
a903 1
       			    ((struct scsi_mode_sense *)xs->cmd)->page);
d976 1
d980 7
a986 1
		if (gdt->sc_status == GDT_S_OK) {
d988 4
a991 1
		} else {
d1006 2
a1007 1
	int chain = 1, sync_val = 0;
d1050 2
a1051 1
		/* XXX Not yet implemented */
@


1.7
log
@Use better (working) locking macros around critical regions.  Implement
SCSI_POLL operations.  Implement SYNCHRONIZE_CACHE scsi operation emulation .
Do not call busdma operations unless we are really either a READ or WRITE
operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.6 2000/06/16 21:47:13 provos Exp $	*/
d374 2
a375 2
	MALLOC(gdt->sc_raw_link, struct scsi_link *,
	    gdt->sc_bus_cnt * sizeof (struct scsi_link), M_DEVBUF, M_NOWAIT);
@


1.6
log
@take MIN/MAX from param.h, okay theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.5 2000/03/01 22:38:51 niklas Exp $	*/
d473 1
d486 3
a488 2
	GDT_LOCK_GDT(gdt);
	if (!gdt_polling && gdt->sc_test_busy(gdt)) {
d492 1
a492 1
		GDT_UNLOCK_GDT(gdt);
d495 1
a495 1
	GDT_UNLOCK_GDT(gdt);
a503 1
	case SYNCHRONIZE_CACHE:
d520 2
a521 1
		GDT_LOCK_GDT(gdt);
d544 1
a544 1
					GDT_UNLOCK_GDT(gdt);
d558 22
a579 19
		if (xs->cmdlen == 6) {
			rw = (struct scsi_rw *)xs->cmd;
			blockno =
			    _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);
			blockcnt = rw->length ? rw->length : 0x100;
		} else {
			rwb = (struct scsi_rw_big *)xs->cmd;
			blockno = _4btol(rwb->addr);
			blockcnt = _2btol(rwb->length);
		}
		if (blockno >= gdt->sc_hdr[target].hd_size ||
		    blockno + blockcnt > gdt->sc_hdr[target].hd_size) {
			GDT_UNLOCK_GDT(gdt);
			printf("%s: out of bounds %u-%u >= %u\n",
			    gdt->sc_dev.dv_xname, blockno, blockcnt,
			    gdt->sc_hdr[target].hd_size);
			scsi_done(xs);
			xs->error = XS_DRIVER_STUFFUP;
			return (COMPLETE);
d590 1
a590 1
				GDT_UNLOCK_GDT(gdt);
d596 1
a596 1
				GDT_UNLOCK_GDT(gdt);
d603 1
a603 1
			GDT_UNLOCK_GDT(gdt);
d614 14
a627 11
		xfer = ccb->gc_dmamap_xfer;
		error = bus_dmamap_load(gdt->sc_dmat, xfer, xs->data, 
		    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? 
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			printf("%s: gdt_scsi_cmd: ", gdt->sc_dev.dv_xname); 
			if (error == EFBIG)
				printf("more than %d dma segs\n",
				    GDT_MAXOFFSETS);
			else
				printf("error %d loading dma map\n", error);
d629 7
a635 3
			xs->error = XS_DRIVER_STUFFUP;
			gdt_free_ccb(gdt, ccb);
			return (COMPLETE);
a636 3
		bus_dmamap_sync(gdt->sc_dmat, xfer,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
		    BUS_DMASYNC_PREWRITE);
d640 1
a640 1
		if (gdt_polling) {
d642 1
a642 1
				GDT_UNLOCK_GDT(gdt);
d650 1
a650 1
		GDT_UNLOCK_GDT(gdt);
d652 1
a652 1
		if (gdt_polling) {
d696 8
a703 2
		/* XXX PREVENT_ALLOW support goes here */

d721 2
a722 1
	if (xs->cmd->opcode != PREVENT_ALLOW) {
a726 1
	}
d728 30
a757 23
	xfer = ccb->gc_dmamap_xfer;
	if (gdt->sc_cache_feat & GDT_SCATTER_GATHER) {
		gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
		    0xffffffff);
		for (i = 0; i < xfer->dm_nsegs; i++) {
			gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
			    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_PTR,
			    xfer->dm_segs[i].ds_addr);
			gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
			    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_LEN,
			    xfer->dm_segs[i].ds_len);
			GDT_DPRINTF(GDT_D_IO, ("#%d va %p pa %p len %x\n", i,
			    buf, xfer->dm_segs[i].ds_addr,
			    xfer->dm_segs[i].ds_len));
		}
		sg_canz = xfer->dm_nsegs;
		gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_LST +
		    sg_canz * GDT_SG_SZ + GDT_SG_LEN, 0);
	} else {
		/* XXX Hardly correct */
		gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
		    xfer->dm_segs[0].ds_addr);
		sg_canz = 0;
a830 4
	case SYNCHRONIZE_CACHE:
		GDT_DPRINTF(GDT_D_CMD, ("SYNCHRONIZE CACHE tgt %d ", target));
		break;

d986 1
d995 1
a995 1
		GDT_LOCK_GDT(gdt);
d999 2
a1000 1
		GDT_UNLOCK_GDT(gdt);
d1036 7
a1042 4
	bus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer,
	    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(gdt->sc_dmat, ccb->gc_dmamap_xfer);
d1058 1
a1058 1
		GDT_UNLOCK_GDT(gdt);
d1213 1
d1217 1
a1217 1
	GDT_LOCK_GDT(gdt);
d1231 1
a1231 1
	GDT_UNLOCK_GDT(gdt);
d1240 2
d1244 1
a1244 1
	GDT_LOCK_GDT(gdt);
d1252 1
a1252 1
	GDT_UNLOCK_GDT(gdt);
d1309 1
d1317 1
a1317 1
	GDT_LOCK_GDT(gdt);
d1319 1
a1319 1
	GDT_UNLOCK_GDT(gdt);
d1329 1
d1331 1
a1331 1
	GDT_LOCK_GDT(gdt);
d1334 1
a1334 1
	GDT_UNLOCK_GDT(gdt);
@


1.5
log
@Proper bus_dma usage, fixes cache incosistencies
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.4 2000/02/13 11:23:15 niklas Exp $	*/
a54 2

#define MIN(x, y) (((x) < (y)) ? (x) : (y))
@


1.5.2.1
log
@Pull in patch from current:
Fix (niklas):
Use better (working) locking macros around critical regions.  Implement
SCSI_POLL operations.  Implement SYNCHRONIZE_CACHE scsi operation emulation .
Do not call busdma operations unless we are really either a READ or WRITE
operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.7 2000/08/05 18:52:34 niklas Exp $	*/
a474 1
	gdt_lock_t lock;
d487 2
a488 3
	lock = GDT_LOCK_GDT(gdt);
	if (!gdt_polling && !(xs->flags & SCSI_POLL) &&
	    gdt->sc_test_busy(gdt)) {
d492 1
a492 1
		GDT_UNLOCK_GDT(gdt, lock);
d495 1
a495 1
	GDT_UNLOCK_GDT(gdt, lock);
d504 1
d521 1
a521 2
	case SYNCHRONIZE_CACHE:
		lock = GDT_LOCK_GDT(gdt);
d544 1
a544 1
					GDT_UNLOCK_GDT(gdt, lock);
d558 19
a576 22
		if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			/* A read or write operation. */
			if (xs->cmdlen == 6) {
				rw = (struct scsi_rw *)xs->cmd;
				blockno = _3btol(rw->addr) &
				    (SRW_TOPADDR << 16 | 0xffff);
				blockcnt = rw->length ? rw->length : 0x100;
			} else {
				rwb = (struct scsi_rw_big *)xs->cmd;
				blockno = _4btol(rwb->addr);
				blockcnt = _2btol(rwb->length);
			}
			if (blockno >= gdt->sc_hdr[target].hd_size ||
			    blockno + blockcnt > gdt->sc_hdr[target].hd_size) {
				GDT_UNLOCK_GDT(gdt, lock);
				printf("%s: out of bounds %u-%u >= %u\n",
				    gdt->sc_dev.dv_xname, blockno, blockcnt,
				    gdt->sc_hdr[target].hd_size);
				scsi_done(xs);
				xs->error = XS_DRIVER_STUFFUP;
				return (COMPLETE);
			}
d587 1
a587 1
				GDT_UNLOCK_GDT(gdt, lock);
d593 1
a593 1
				GDT_UNLOCK_GDT(gdt, lock);
d600 1
a600 1
			GDT_UNLOCK_GDT(gdt, lock);
d611 11
a621 14
		if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			xfer = ccb->gc_dmamap_xfer;
			error = bus_dmamap_load(gdt->sc_dmat, xfer, xs->data, 
			    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? 
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
			if (error) {
				printf("%s: gdt_scsi_cmd: ",
				    gdt->sc_dev.dv_xname); 
				if (error == EFBIG)
					printf("more than %d dma segs\n",
					    GDT_MAXOFFSETS);
				else
					printf("error %d loading dma map\n",
					    error);
d623 3
a625 7
				xs->error = XS_DRIVER_STUFFUP;
				gdt_free_ccb(gdt, ccb);
				return (COMPLETE);
			}
			bus_dmamap_sync(gdt->sc_dmat, xfer,
			    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
			    BUS_DMASYNC_PREWRITE);
d627 3
d633 1
a633 1
		if (gdt_polling || (xs->flags & SCSI_POLL)) {
d635 1
a635 1
				GDT_UNLOCK_GDT(gdt, lock);
d643 1
a643 1
		GDT_UNLOCK_GDT(gdt, lock);
d645 1
a645 1
		if (gdt_polling || (xs->flags & SCSI_POLL)) {
d689 2
a690 8
	case SYNCHRONIZE_CACHE:
		if (xs->cmd->opcode == PREVENT_ALLOW) {
			/* XXX PREVENT_ALLOW support goes here */
		} else {
			GDT_DPRINTF(GDT_D_CMD,
			    ("SYNCHRONIZE CACHE tgt %d ", target));
			gdt->sc_cmd[GDT_CMD_OPCODE] = GDT_FLUSH;
		}
d708 1
a708 2
	if (xs->cmd->opcode != PREVENT_ALLOW &&
	    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
d713 1
d715 23
a737 30
		xfer = ccb->gc_dmamap_xfer;
		if (gdt->sc_cache_feat & GDT_SCATTER_GATHER) {
			gdt_enc32(
			    gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
			    0xffffffff);
			for (i = 0; i < xfer->dm_nsegs; i++) {
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
				    GDT_CACHE_SG_LST + i * GDT_SG_SZ +
				    GDT_SG_PTR,
				    xfer->dm_segs[i].ds_addr);
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
				    GDT_CACHE_SG_LST + i * GDT_SG_SZ +
				    GDT_SG_LEN,
				    xfer->dm_segs[i].ds_len);
				GDT_DPRINTF(GDT_D_IO,
				    ("#%d va %p pa %p len %x\n", i, buf,
				    xfer->dm_segs[i].ds_addr,
				    xfer->dm_segs[i].ds_len));
			}
			sg_canz = xfer->dm_nsegs;
			gdt_enc32(
			    gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_LST +
			    sg_canz * GDT_SG_SZ + GDT_SG_LEN, 0);
		} else {
			/* XXX Hardly correct */
			gdt_enc32(
			    gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
			    xfer->dm_segs[0].ds_addr);
			sg_canz = 0;
		}
d811 4
a969 1
	gdt_lock_t lock;
d978 1
a978 1
		lock = GDT_LOCK_GDT(gdt);
d982 1
a982 2
		if (!gdt_polling)
			GDT_UNLOCK_GDT(gdt, lock);
d1018 4
a1021 7
	if (xs && xs->cmd->opcode != PREVENT_ALLOW &&
	    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
		bus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(gdt->sc_dmat, ccb->gc_dmamap_xfer);
	}
d1037 1
a1037 1
		GDT_UNLOCK_GDT(gdt, lock);
a1191 1
	gdt_lock_t lock;
d1195 1
a1195 1
	lock = GDT_LOCK_GDT(gdt);
d1209 1
a1209 1
	GDT_UNLOCK_GDT(gdt, lock);
a1217 2
	gdt_lock_t lock;

d1220 1
a1220 1
	lock = GDT_LOCK_GDT(gdt);
d1228 1
a1228 1
	GDT_UNLOCK_GDT(gdt, lock);
a1284 1
	gdt_lock_t lock;
d1292 1
a1292 1
	lock = GDT_LOCK_GDT(gdt);
d1294 1
a1294 1
	GDT_UNLOCK_GDT(gdt, lock);
a1303 1
	gdt_lock_t lock;
d1305 1
a1305 1
	lock = GDT_LOCK_GDT(gdt);
d1308 1
a1308 1
	GDT_UNLOCK_GDT(gdt, lock);
@


1.4
log
@Handle out-of-bounds errors correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.3 2000/02/13 10:56:41 niklas Exp $	*/
d110 1
a110 1
	int i, id, drv_cyls, drv_hds, drv_secs;
d123 10
d473 2
d611 20
d669 2
a670 3
	int i, len, off;
	u_int8_t *buf;
	paddr_t pa;
d715 1
d719 1
a719 8
		len = xs->datalen;
		buf = xs->data;
		for (i = 0; len > 0; i++) {
			for (off = PAGE_SIZE, pa = vtophys(buf); off < len;
			    off += PAGE_SIZE)
				if (pa + off != vtophys(buf + off))
					break;

d721 2
a722 1
			    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_PTR, pa);
d725 1
a725 1
			    MIN(off, len));
d727 2
a728 4
			    buf, (void *)pa, MIN(off, len)));

			len -= off;
			buf += off;
d730 1
a730 1
		sg_canz = i;
d734 1
d736 1
a736 1
		    vtophys(xs->data));
d1018 4
@


1.4.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.4 2000/02/13 11:23:15 niklas Exp $	*/
d110 1
a110 1
	int i, id, drv_cyls, drv_hds, drv_secs, error;
a122 10
		error = bus_dmamap_create(gdt->sc_dmat,
		    (GDT_MAXOFFSETS - 1) << PGSHIFT, GDT_MAXOFFSETS,
		    (GDT_MAXOFFSETS - 1) << PGSHIFT, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &gdt->sc_ccbs[i].gc_dmamap_xfer);
		if (error) {
			printf("%s: cannot create ccb dmamap (%d)",
			    gdt->sc_dev.dv_xname, error);
			return (1);
		}
a462 2
	bus_dmamap_t xfer;
	int error;
a598 20
		xfer = ccb->gc_dmamap_xfer;
		error = bus_dmamap_load(gdt->sc_dmat, xfer, xs->data, 
		    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? 
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			printf("%s: gdt_scsi_cmd: ", gdt->sc_dev.dv_xname); 
			if (error == EFBIG)
				printf("more than %d dma segs\n",
				    GDT_MAXOFFSETS);
			else
				printf("error %d loading dma map\n", error);
		
			xs->error = XS_DRIVER_STUFFUP;
			gdt_free_ccb(gdt, ccb);
			return (COMPLETE);
		}
		bus_dmamap_sync(gdt->sc_dmat, xfer,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
		    BUS_DMASYNC_PREWRITE);

d637 3
a639 2
	bus_dmamap_t xfer;
	int i;
a683 1
	xfer = ccb->gc_dmamap_xfer;
d687 8
a694 1
		for (i = 0; i < xfer->dm_nsegs; i++) {
d696 1
a696 2
			    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_PTR,
			    xfer->dm_segs[i].ds_addr);
d699 1
a699 1
			    xfer->dm_segs[i].ds_len);
d701 4
a704 2
			    buf, xfer->dm_segs[i].ds_addr,
			    xfer->dm_segs[i].ds_len));
d706 1
a706 1
		sg_canz = xfer->dm_nsegs;
a709 1
		/* XXX Hardly correct */
d711 1
a711 1
		    xfer->dm_segs[0].ds_addr);
a992 4
	bus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer,
	    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(gdt->sc_dmat, ccb->gc_dmamap_xfer);
@


1.4.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.11 2000/12/13 16:03:11 mickey Exp $	*/
d56 1
a56 5
#ifdef GDT_DEBUG
int gdt_maxcmds = GDT_MAXCMDS;
#undef GDT_MAXCMDS
#define GDT_MAXCMDS gdt_maxcmds
#endif
d141 1
d143 1
a143 2
	/* XXX what is optimal? */
	gdt->sc_link.openings = GDT_MAXCMDS;
a145 1
	gdt->sc_link.adapter_target = gdt->sc_link.adapter_buswidth;
d300 1
a300 1
		/* XXX Not implemented yet */
d305 1
a305 1
		/* XXX Not implemented yet */
d376 2
a377 2
	gdt->sc_raw_link = malloc(gdt->sc_bus_cnt * sizeof (struct scsi_link),
				  M_DEVBUF, M_NOWAIT);
a451 2
	if (xs == NULL)
		return (NULL);
d460 1
a460 4
/*
 * Start a SCSI operation on a cache device.
 * XXX Polled operation is not yet complete.  What kind of locking do we need?
 */
d469 1
d474 1
a474 2
	int error, retval = SUCCESSFULLY_QUEUED;
	gdt_lock_t lock;
a477 2
	xs->error = XS_NOERROR;

a479 4
		/*
		 * XXX Should be XS_SENSE but that would require setting up a
		 * faked sense too.
		 */
a480 2
		xs->flags |= ITSDONE;
		scsi_done(xs);
d484 12
a495 1
	lock = GDT_LOCK_GDT(lock);
d497 13
a509 3
	/* Don't double enqueue if we came from gdt_chain. */
	if (xs != LIST_FIRST(&gdt->sc_queue))
		gdt_enqueue(gdt, xs, 0);
d511 3
a513 1
	while ((xs = gdt_dequeue(gdt))) {
d515 21
a535 1
		ccb = NULL;
a536 2
		if (!gdt_polling && !(xs->flags & SCSI_POLL) &&
		    gdt->sc_test_busy(gdt)) {
d538 2
a539 2
			 * Put it back in front.  XXX Should we instead
			 * set xs->error to XS_BUSY?
d541 7
a547 3
			gdt_enqueue(gdt, xs, 1);
			break;
		}
d549 6
a554 13
		switch (xs->cmd->opcode) {
		case TEST_UNIT_READY:
		case REQUEST_SENSE:
		case INQUIRY:
		case MODE_SENSE:
		case START_STOP:
		case READ_CAPACITY:
#if 0
		case VERIFY:
#endif
			if (!gdt_internal_cache_cmd(xs)) {
				GDT_UNLOCK_GDT(gdt, lock);
				return (TRY_AGAIN_LATER);
d556 1
a556 3
			xs->flags |= ITSDONE;
			scsi_done(xs);
			goto ready;
d558 16
a573 5
		case PREVENT_ALLOW:
			GDT_DPRINTF(GDT_D_CMD, ("PREVENT/ALLOW "));
			/* XXX Not yet implemented */
			xs->error = XS_NOERROR;
			xs->flags |= ITSDONE;
a574 6
			goto ready;

		default:
			GDT_DPRINTF(GDT_D_CMD,
			    ("unknown opc %d ", xs->cmd->opcode));
			/* XXX Not yet implemented */
d576 2
a577 3
			xs->flags |= ITSDONE;
			scsi_done(xs);
			goto ready;
d579 1
a579 9
		case READ_COMMAND:
		case READ_BIG:
		case WRITE_COMMAND:
		case WRITE_BIG:
		case SYNCHRONIZE_CACHE:
			/*
			 * A new command chain, start from the beginning.
			 */
			gdt->sc_cmd_off = 0;
d581 10
a590 31
			if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
				/* A read or write operation. */
				if (xs->cmdlen == 6) {
					rw = (struct scsi_rw *)xs->cmd;
					blockno = _3btol(rw->addr) &
					    (SRW_TOPADDR << 16 | 0xffff);
					blockcnt =
					    rw->length ? rw->length : 0x100;
				} else {
					rwb = (struct scsi_rw_big *)xs->cmd;
					blockno = _4btol(rwb->addr);
					blockcnt = _2btol(rwb->length);
				}
				if (blockno >= gdt->sc_hdr[target].hd_size ||
				    blockno + blockcnt >
				    gdt->sc_hdr[target].hd_size) {
					printf(
					    "%s: out of bounds %u-%u >= %u\n",
					    gdt->sc_dev.dv_xname, blockno,
					    blockcnt,
					    gdt->sc_hdr[target].hd_size);
					/*
					 * XXX Should be XS_SENSE but that
					 * would require setting up a faked
					 * sense too.
					 */
					xs->error = XS_DRIVER_STUFFUP;
					xs->flags |= ITSDONE;
					scsi_done(xs);
					goto ready;
				}
d592 2
a593 11

			ccb = gdt_get_ccb(gdt, xs->flags);
			/*
			 * Are we out of commands, something is wrong.
			 * 
			 */
			if (ccb == NULL) {
				printf("%s: no ccb in gdt_scsi_cmd",
				    gdt->sc_dev.dv_xname);
				xs->error = XS_DRIVER_STUFFUP;
				xs->flags |= ITSDONE;
d595 1
a595 1
				goto ready;
d598 5
a602 24
			ccb->gc_blockno = blockno;
			ccb->gc_blockcnt = blockcnt;
			ccb->gc_xs = xs;
			ccb->gc_timeout = xs->timeout;
			ccb->gc_service = GDT_CACHESERVICE;
			gdt_ccb_set_cmd(ccb, GDT_GCF_SCSI);

			if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
				xfer = ccb->gc_dmamap_xfer;
				error = bus_dmamap_load(gdt->sc_dmat, xfer,
				    xs->data, xs->datalen, NULL,
				    (xs->flags & SCSI_NOSLEEP) ?
				    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
				if (error) {
					printf("%s: gdt_scsi_cmd: ",
					    gdt->sc_dev.dv_xname);
					if (error == EFBIG)
						printf(
						    "more than %d dma segs\n",
						    GDT_MAXOFFSETS);
					else
						printf("error %d "
						    "loading dma map\n",
						    error);
d604 6
a609 11
					gdt_free_ccb(gdt, ccb);
					xs->error = XS_DRIVER_STUFFUP;
					xs->flags |= ITSDONE;
					scsi_done(xs);
					goto ready;
				}
				bus_dmamap_sync(gdt->sc_dmat, xfer,
				    (xs->flags & SCSI_DATA_IN) ?
				    BUS_DMASYNC_PREREAD :
				    BUS_DMASYNC_PREWRITE);
			}
d611 29
a639 13
			gdt_enqueue_ccb(gdt, ccb);
			/* XXX what if enqueue did not start a transfer? */
			if (gdt_polling || (xs->flags & SCSI_POLL)) {
				if (!gdt_wait(gdt, ccb, ccb->gc_timeout)) {
					GDT_UNLOCK_GDT(gdt, lock);
					printf("%s: command %d timed out\n",
					    gdt->sc_dev.dv_xname,
					    ccb->gc_cmd_index);
					xs->error = XS_TIMEOUT;
					return (TRY_AGAIN_LATER);
				}
				xs->flags |= ITSDONE;
				scsi_done(xs);
d643 5
a647 7
	ready:
		/*
		 * Don't process the queue if we are polling.
		 */
		if (xs->flags & SCSI_POLL) {
			retval = COMPLETE;
			break;
d649 7
a656 3

	GDT_UNLOCK_GDT(gdt, lock);
	return (retval);
a674 1

d676 1
a676 1
	 * XXX Yeah I know it's an always-true condition, but that may change
d689 2
a690 8
	case SYNCHRONIZE_CACHE:
		if (xs->cmd->opcode == PREVENT_ALLOW) {
			/* XXX PREVENT_ALLOW support goes here */
		} else {
			GDT_DPRINTF(GDT_D_CMD,
			    ("SYNCHRONIZE CACHE tgt %d ", target));
			gdt->sc_cmd[GDT_CMD_OPCODE] = GDT_FLUSH;
		}
d708 1
a708 2
	if (xs->cmd->opcode != PREVENT_ALLOW &&
	    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
d713 1
d715 14
a728 29
		xfer = ccb->gc_dmamap_xfer;
		if (gdt->sc_cache_feat & GDT_SCATTER_GATHER) {
			gdt_enc32(
			    gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
			    0xffffffff);
			for (i = 0; i < xfer->dm_nsegs; i++) {
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
				    GDT_CACHE_SG_LST + i * GDT_SG_SZ +
				    GDT_SG_PTR,
				    xfer->dm_segs[i].ds_addr);
				gdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +
				    GDT_CACHE_SG_LST + i * GDT_SG_SZ +
				    GDT_SG_LEN,
				    xfer->dm_segs[i].ds_len);
				GDT_DPRINTF(GDT_D_IO,
				    ("#%d va %p pa %p len %x\n", i, buf,
				    xfer->dm_segs[i].ds_addr,
				    xfer->dm_segs[i].ds_len));
			}
			sg_canz = xfer->dm_nsegs;
			gdt_enc32(
			    gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_LST +
			    sg_canz * GDT_SG_SZ + GDT_SG_LEN, 0);
		} else {
			/* XXX Hardly correct */
			gdt_enc32(
			    gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,
			    xfer->dm_segs[0].ds_addr);
			sg_canz = 0;
d730 8
d778 2
d811 4
d873 1
a873 1
			    ((struct scsi_mode_sense *)xs->cmd)->page);
a945 1
		GDT_DPRINTF(GDT_D_INTR, ("service == GDT_SCREENSERVICE "));
d949 1
a949 3
		switch (gdt->sc_status) {
		case GDT_S_OK:
			GDT_DPRINTF(GDT_D_INTR, ("sc_status == GDT_S_OK "));
d951 1
a951 8
			break;
		case GDT_S_BSY:
			GDT_DPRINTF(GDT_D_INTR, ("sc_status == GDT_S_BSY "));
			/* XXX To be implemented */
			return (2);
		default:
			GDT_DPRINTF(GDT_D_INTR, ("sc_status is %d ",
			    gdt->sc_status));
d966 1
a966 2
	int chain = 1;
	int sync_val = 0;
a969 1
	gdt_lock_t lock;
d978 1
a978 1
		lock = GDT_LOCK_GDT(gdt);
d982 1
a982 2
		if (!gdt_polling)
			GDT_UNLOCK_GDT(gdt, lock);
d1007 1
a1007 2
		printf("%s: uninitialized or unknown service (%d %d)\n",
		    gdt->sc_dev.dv_xname, ctx.info, ctx.info2);
d1015 1
a1015 1
		timeout_del(&xs->stimeout);
d1018 4
a1021 7
	if (xs && xs->cmd->opcode != PREVENT_ALLOW &&
	    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
		bus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(gdt->sc_dmat, ccb->gc_dmamap_xfer);
	}
d1037 1
a1037 1
		GDT_UNLOCK_GDT(gdt, lock);
a1191 1
	gdt_lock_t lock;
d1195 1
a1195 1
	lock = GDT_LOCK_GDT(gdt);
d1209 1
a1209 1
	GDT_UNLOCK_GDT(gdt, lock);
a1217 2
	gdt_lock_t lock;

d1220 1
a1220 1
	lock = GDT_LOCK_GDT(gdt);
d1228 1
a1228 1
	GDT_UNLOCK_GDT(gdt, lock);
a1237 1
	timeout_set(&ccb->gc_xs->stimeout, gdt_timeout, ccb);
a1246 1
	struct scsi_xfer *xs;
a1250 2

		xs = ccb->gc_xs;
d1252 1
a1252 1
			timeout_del(&xs->stimeout);
d1256 1
a1256 2
			timeout_set(&ccb->gc_xs->stimeout, gdt_watchdog, ccb);
			timeout_add(&xs->stimeout,
d1262 2
a1263 3
		if ((xs->flags & SCSI_POLL) == 0) {
			timeout_set(&ccb->gc_xs->stimeout, gdt_timeout, ccb);
			timeout_add(&xs->stimeout,
a1264 1
		}
a1284 1
	gdt_lock_t lock;
d1292 1
a1292 1
	lock = GDT_LOCK_GDT(gdt);
d1294 1
a1294 1
	GDT_UNLOCK_GDT(gdt, lock);
a1303 1
	gdt_lock_t lock;
d1305 1
a1305 1
	lock = GDT_LOCK_GDT(gdt);
d1308 1
a1308 1
	GDT_UNLOCK_GDT(gdt, lock);
@


1.4.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.4.2.2 2001/05/14 22:23:48 niklas Exp $	*/
d47 1
d218 1
a218 1
	/* Read cache configuration */
d511 1
a511 3
		link = xs->sc_link;
		target = link->target;
 
@


1.4.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
#include <uvm/uvm_extern.h>
d646 1
a646 2
				bus_dmamap_sync(gdt->sc_dmat, xfer, 0,
				    xfer->dm_mapsize,
d1065 1
a1065 2
		bus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer, 0,
		    ccb->gc_dmamap_xfer->dm_mapsize,
@


1.4.2.5
log
@Merge in trunk
@
text
@d603 2
a604 1
			 * We are out of commands, try again in a little while.
d607 2
d610 3
a612 2
				GDT_UNLOCK_GDT(gdt, lock);
				return (TRY_AGAIN_LATER);
@


1.4.2.6
log
@Merge in -current from about a week ago
@
text
@d61 22
a82 22
int	gdt_async_event(struct gdt_softc *, int);
void	gdt_chain(struct gdt_softc *);
void	gdt_clear_events(struct gdt_softc *);
void	gdt_copy_internal_data(struct scsi_xfer *, u_int8_t *, size_t);
struct scsi_xfer *gdt_dequeue(struct gdt_softc *);
void	gdt_enqueue(struct gdt_softc *, struct scsi_xfer *, int);
void	gdt_enqueue_ccb(struct gdt_softc *, struct gdt_ccb *);
void	gdt_eval_mapping(u_int32_t, int *, int *, int *);
int	gdt_exec_ccb(struct gdt_ccb *);
void	gdt_free_ccb(struct gdt_softc *, struct gdt_ccb *);
struct gdt_ccb *gdt_get_ccb(struct gdt_softc *, int);
int	gdt_internal_cache_cmd(struct scsi_xfer *);
int	gdt_internal_cmd(struct gdt_softc *, u_int8_t, u_int16_t,
    u_int32_t, u_int32_t, u_int32_t);
int	gdt_raw_scsi_cmd(struct scsi_xfer *);
int	gdt_scsi_cmd(struct scsi_xfer *);
void	gdt_start_ccbs(struct gdt_softc *);
int	gdt_sync_event(struct gdt_softc *, int, u_int8_t,
    struct scsi_xfer *);
void	gdt_timeout(void *);
int	gdt_wait(struct gdt_softc *, struct gdt_ccb *, int);
void	gdt_watchdog(void *);
@


1.4.2.7
log
@Sync the SMP branch with 3.3
@
text
@d38 1
a40 1
#include <sys/ioctl.h>
a42 1
#include <sys/systm.h>
a51 1
#include <dev/biovar.h>
a54 2
#include "bio.h"

a60 3
#define GDT_DRIVER_VERSION 1
#define GDT_DRIVER_SUBVERSION 1

a74 3
#if NBIO > 0
int	gdt_ioctl(struct device *, u_long, caddr_t);
#endif
a99 1
int gdt_cnt = 0;
d113 1
a113 1
	int i, id, drv_cyls, drv_hds, drv_secs, error, nsegs;
a116 8

	if (bus_dmamem_alloc(gdt->sc_dmat, GDT_SCRATCH_SZ, PAGE_SIZE, 0,
	    &gdt->sc_scratch_seg, 1, &nsegs, BUS_DMA_NOWAIT))
	    panic("%s: bus_dmamem_alloc failed", gdt->sc_dev.dv_xname);
	if (bus_dmamem_map(gdt->sc_dmat, &gdt->sc_scratch_seg, 1,
	    GDT_SCRATCH_SZ, &gdt->sc_scratch, BUS_DMA_NOWAIT))
	    panic("%s: bus_dmamem_map failed", gdt->sc_dev.dv_xname);

a120 1
	TAILQ_INIT(&gdt->sc_ucmdq);
d192 1
a192 1
			gdt->sc_bus_id[id] = id < GDT_MAXBUS ? id : 0xff;
a377 6
#if NBIO > 0
	if (bio_register(&gdt->sc_dev, gdt_ioctl) != 0)
		panic("%s: controller registration failed");
#endif
	gdt_cnt++;

a381 2
	if (gdt->sc_raw_link == NULL)
		panic("gdt_attach");
a477 3
#if 0
	struct gdt_ucmd *ucmd;
#endif
d507 1
a507 1
	while ((xs = gdt_dequeue(gdt)) != NULL) {
d865 1
a865 1
		strcpy(inq.vendor, "ICP	   ");
d867 1
a867 1
		strcpy(inq.revision, "	 ");
d1104 6
d1112 1
d1114 1
a1114 2
	if ((GDT_MAXOFFSETS - 1) * PAGE_SIZE < MAXPHYS &&
	    bp->b_bcount > ((GDT_MAXOFFSETS - 1) * PAGE_SIZE))
d1116 8
a1123 1

d1197 1
a1197 1
				    gdt->sc_scratch_seg.ds_addr);
a1367 127

#if NBIO > 0
int
gdt_ioctl(dev, cmd, addr)
	struct device *dev;
	u_long cmd;
	caddr_t addr;
{
	int error = 0;
	struct gdt_dummy *dummy;

	switch (cmd) {
	case GDT_IOCTL_DUMMY:
		dummy = (struct gdt_dummy *)addr;
		printf("%s: GDT_IOCTL_DUMMY %d\n", dev->dv_xname, dummy->x++);
		break;

	case GDT_IOCTL_GENERAL: {
		gdt_ucmd_t *ucmd;
		struct gdt_softc *gdt = (struct gdt_softc *)dev;
		gdt_lock_t lock;

		ucmd = (gdt_ucmd_t *)addr;
		lock = GDT_LOCK_GDT(gdt);
		TAILQ_INSERT_TAIL(&gdt->sc_ucmdq, ucmd, links);
		ucmd->complete_flag = FALSE;
		GDT_UNLOCK_GDT(gdt, lock);
		gdt_chain(gdt);
		if (!ucmd->complete_flag)
			(void)tsleep((void *)ucmd, PCATCH | PRIBIO, "gdtucw",
			    0);
		break;
	}

	case GDT_IOCTL_DRVERS:
		((gdt_drvers_t *)addr)->vers = 
		    (GDT_DRIVER_VERSION << 8) | GDT_DRIVER_SUBVERSION;
		break;

	case GDT_IOCTL_CTRCNT:
		((gdt_ctrcnt_t *)addr)->cnt = gdt_cnt;
		break;

#ifdef notyet
	case GDT_IOCTL_CTRTYPE: {
		gdt_ctrt_t *p;
		struct gdt_softc *gdt = (struct gdt_softc *)dev;
	    
		p = (gdt_ctrt_t *)addr;
		p->oem_id = 0x8000;
		p->type = 0xfd;
		p->info = (gdt->sc_bus << 8) | (gdt->sc_slot << 3);
		p->ext_type = 0x6000 | gdt->sc_subdevice;
		p->device_id = gdt->sc_device;
		p->sub_device_id = gdt->sc_subdevice;
		break;
	}
#endif

	case GDT_IOCTL_OSVERS: {
		gdt_osv_t *p;

		p = (gdt_osv_t *)addr;
		p->oscode = 10;
		p->version = osrelease[0] - '0';
		if (osrelease[1] == '.')
			p->subversion = osrelease[2] - '0';
		else
			p->subversion = 0;
		if (osrelease[3] == '.')
			p->revision = osrelease[4] - '0';
		else
			p->revision = 0;
		strcpy(p->name, ostype);
		break;
	}

#ifdef notyet
	case GDT_IOCTL_EVENT: {
		gdt_event_t *p;
		gdt_lock_t lock;

		p = (gdt_event_t *)addr;
		if (p->erase == 0xff) {
			if (p->dvr.event_source == GDT_ES_TEST)
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.test);
			else if (p->dvr.event_source == GDT_ES_DRIVER)
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.driver);
			else if (p->dvr.event_source == GDT_ES_SYNC)
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.sync);
			else
				p->dvr.event_data.size =
				    sizeof(p->dvr.event_data.eu.async);
			lock = GDT_LOCK_GDT(gdt);
			gdt_store_event(p->dvr.event_source, p->dvr.event_idx,
			    &p->dvr.event_data);
			GDT_UNLOCK_GDT(gdt, lock);
		} else if (p->erase == 0xfe) {
			lock = GDT_LOCK_GDT(gdt);
			gdt_clear_events();
			GDT_UNLOCK_GDT(gdt, lock);
		} else if (p->erase == 0) {
			p->handle = gdt_read_event(p->handle, &p->dvr);
		} else {
			gdt_readapp_event((u_int8_t)p->erase, &p->dvr);
		}
		break;
	}
#endif

	case GDT_IOCTL_STATIST:
#if 0
		bcopy(&gdt_stat, (gdt_statist_t *)addr, sizeof gdt_stat);
#else
		error = EOPNOTSUPP;
#endif
		break;

	default:
		error = EINVAL;
	}
	return (error);
}
#endif
@


1.4.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.4.2.7 2003/03/28 00:38:13 niklas Exp $	*/
d896 3
a898 4
		strlcpy(inq.vendor, "ICP	   ", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Host drive  #%02d",
		    target);
		strlcpy(inq.revision, "	 ", sizeof inq.revision);
d1459 1
a1459 1
		strlcpy(p->name, ostype, sizeof p->name);
@


1.4.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.4.2.8 2003/05/13 19:35:00 ho Exp $	*/
d14 5
@


1.4.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1999, 2000, 2003 Niklas Hallqvist.  All rights reserved.
d160 2
a161 1
	/* openings will be filled in later. */
a350 1
	gdt->sc_ndevs = 0;
a357 3
			if (gdt->sc_hdr[i].hd_size > 0)
				gdt->sc_ndevs++;

a380 6
	if (gdt->sc_ndevs == 0)
		gdt->sc_link.openings = 0;
	else
		gdt->sc_link.openings = (GDT_MAXCMDS - GDT_CMD_RESERVE) /
		    gdt->sc_ndevs;

d395 1
a395 1
		panic("%s: controller registration failed", gdt->sc_dev.dv_xname);
a716 2
#if 1 /* XXX */
	static int __level = 0;
a717 3
	if (__level++ > 0)
		panic("level > 0");
#endif
a810 3
#if 1 /* XXX */
		__level--;
#endif
a818 3
#if 1 /* XXX */
	__level--;
#endif
@


1.4.2.11
log
@Merge with the trunk
@
text
@d61 1
a61 1
#define GDT_DRIVER_SUBVERSION 2
d178 13
@


1.3
log
@%u for unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.2 2000/02/12 09:45:49 niklas Exp $	*/
d558 1
d562 1
@


1.2
log
@Fix a locking bug, and a size boundary condition
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_common.c,v 1.1 2000/02/07 00:33:02 niklas Exp $	*/
d558 1
a558 1
			printf("%s: out of bounds %d-%d >= %d\n",
@


1.1
log
@Rough but working driver for ICP-Vortex RAID
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d124 1
a124 1
		TAILQ_INSERT_HEAD(&gdt->sc_free_ccb, &gdt->sc_ccbs[i],
d483 1
a483 1
	GDT_LOCK_GDT(gdt);
d557 1
a557 1
		    blockno + blockcnt >= gdt->sc_hdr[target].hd_size) {
@

