head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.2
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.35.0.10
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.33.0.4
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.31.0.2
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.37
date	2017.01.12.16.32.28;	author stsp;	state Exp;
branches;
next	1.36;
commitid	1Zd7y0b8dZf1uELZ;

1.36
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.35;
commitid	2QagMjdMhQhIaQgu;

1.35
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2013.10.21.16.13.49;	author stsp;	state Exp;
branches;
next	1.33;

1.33
date	2012.10.20.09.54.20;	author stsp;	state Exp;
branches;
next	1.32;

1.32
date	2012.08.25.12.14.31;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2012.06.10.21.23.36;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.08.15.05.24;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.06.07.27.15;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.01.10.48.31;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.31.21.23.55;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.31.14.06.05;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2010.11.10.21.06.44;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2010.10.18.16.37.12;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.03.15.40.08;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.12.16.51.30;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.12.16.32.31;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2010.07.21.14.01.58;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.15.20.37.38;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.22.19.44.22;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.21.19.54.28;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.21.19.46.50;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.05.18.43.57;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.16.14.34.19;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.16.09.42.04;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.16.09.19.48;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.11.19.34.20;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.10.17.44.21;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.05.19.28.15;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.15.17.16.36;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.27.18.26.45;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.22.08.52.45;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.19.19.19.59;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.17.18.21.07;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.17.18.01.40;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.15.14.04.02;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.14.16.55.11;	author damien;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Finish initial 11n support for athn(4).

The heavy lifting was done by damien@@ years ago. I didn't even have
to figure out what the hardware expects, the code was already there.

This driver now supports MCS 0-15 in client and hostap mode.
No Tx aggregation and no 40 MHz channels yet.

tested by vgross@@, bmercer@@, tb@@, jmc@@, Vadim Vygonets, Peter Kay
ok bmercer@@ tb@@ phessler@@
@
text
@/*	$OpenBSD: athnvar.h,v 1.36 2016/01/05 18:41:15 stsp Exp $	*/

/*-
 * Copyright (c) 2009 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef notyet
#define ATHN_BT_COEXISTENCE	1
#endif

#ifdef ATHN_DEBUG
#define DPRINTF(x)	do { if (athn_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (athn_debug >= (n)) printf x; } while (0)
extern int athn_debug;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

#define LE_READ_4(p)	((p)[0] | (p)[1] << 8 | (p)[2] << 16 | (p)[3] << 24)
#define LE_READ_2(p)	((p)[0] | (p)[1] << 8)

#define ATHN_RXBUFSZ	3872
#define ATHN_TXBUFSZ	4096

#define ATHN_NRXBUFS	64
#define ATHN_NTXBUFS	64	/* Shared between all Tx queues. */

struct athn_rx_radiotap_header {
	struct ieee80211_radiotap_header wr_ihdr;
	uint64_t	wr_tsft;
	uint8_t		wr_flags;
	uint8_t		wr_rate;
	uint16_t	wr_chan_freq;
	uint16_t	wr_chan_flags;
	int8_t		wr_dbm_antsignal;
	uint8_t		wr_antenna;
} __packed;

#define ATHN_RX_RADIOTAP_PRESENT						\
	(1 << IEEE80211_RADIOTAP_TSFT |					\
	 1 << IEEE80211_RADIOTAP_FLAGS |				\
	 1 << IEEE80211_RADIOTAP_RATE |					\
	 1 << IEEE80211_RADIOTAP_CHANNEL |				\
	 1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL |			\
	 1 << IEEE80211_RADIOTAP_ANTENNA)

struct athn_tx_radiotap_header {
	struct ieee80211_radiotap_header wt_ihdr;
	uint8_t		wt_flags;
	uint8_t		wt_rate;
	uint16_t	wt_chan_freq;
	uint16_t	wt_chan_flags;
	uint8_t		wt_hwqueue;
} __packed;

#define ATHN_TX_RADIOTAP_PRESENT						\
	(1 << IEEE80211_RADIOTAP_FLAGS |				\
	 1 << IEEE80211_RADIOTAP_RATE |					\
	 1 << IEEE80211_RADIOTAP_CHANNEL |				\
	 1 << IEEE80211_RADIOTAP_HWQUEUE)

struct athn_tx_buf {
	SIMPLEQ_ENTRY(athn_tx_buf)	bf_list;

	void				*bf_descs;
	bus_dmamap_t			bf_map;
	bus_addr_t			bf_daddr;

	struct mbuf			*bf_m;
	struct ieee80211_node		*bf_ni;
	int				bf_txflags;
#define ATHN_TXFLAG_PAPRD	(1 << 0)
#define ATHN_TXFLAG_CAB		(1 << 1) 
};

struct athn_txq {
	SIMPLEQ_HEAD(, athn_tx_buf)	head;
	void				*lastds;
	struct athn_tx_buf		*wait;
	int				queued;
};

struct athn_rx_buf {
	SIMPLEQ_ENTRY(athn_rx_buf)	bf_list;

	void				*bf_desc;
	bus_dmamap_t			bf_map;

	struct mbuf			*bf_m;
	bus_addr_t			bf_daddr;
};

struct athn_rxq {
	struct athn_rx_buf		*bf;

	void				*descs;
	void				*lastds;
	bus_dmamap_t			map;
	bus_dma_segment_t		seg;
	int				count;

	SIMPLEQ_HEAD(, athn_rx_buf)	head;
};

/* Software rate indexes. */
#define ATHN_RIDX_CCK1	0
#define ATHN_RIDX_CCK2	1
#define ATHN_RIDX_OFDM6	4
#define ATHN_RIDX_MCS0	12
#define ATHN_RIDX_MCS8	(ATHN_RIDX_MCS0 + 8)
#define ATHN_RIDX_MCS15	27
#define ATHN_RIDX_MAX	27
#define ATHN_MCS_MAX	15
#define ATHN_NUM_MCS	(ATHN_MCS_MAX + 1)
#define ATHN_IS_HT_RIDX(ridx)	((ridx) >= ATHN_RIDX_MCS0)
#define ATHN_IS_MIMO_RIDX(ridx)	((ridx) >= ATHN_RIDX_MCS8)

static const struct athn_rate {
	uint16_t	rate;		/* Rate in 500Kbps unit. */
	uint8_t		hwrate;		/* HW representation. */
	uint8_t		rspridx;	/* Control Response Frame rate index. */
	enum	ieee80211_phytype phy;
} athn_rates[] = {
	{    2, 0x1b, 0, IEEE80211_T_DS },
	{    4, 0x1a, 1, IEEE80211_T_DS },
	{   11, 0x19, 1, IEEE80211_T_DS },
	{   22, 0x18, 1, IEEE80211_T_DS },
	{   12, 0x0b, 4, IEEE80211_T_OFDM },
	{   18, 0x0f, 4, IEEE80211_T_OFDM },
	{   24, 0x0a, 6, IEEE80211_T_OFDM },
	{   36, 0x0e, 6, IEEE80211_T_OFDM },
	{   48, 0x09, 8, IEEE80211_T_OFDM },
	{   72, 0x0d, 8, IEEE80211_T_OFDM },
	{   96, 0x08, 8, IEEE80211_T_OFDM },
	{  108, 0x0c, 8, IEEE80211_T_OFDM },
	{   13, 0x80, 4, IEEE80211_T_OFDM },
	{   26, 0x81, 6, IEEE80211_T_OFDM },
	{   39, 0x82, 6, IEEE80211_T_OFDM },
	{   52, 0x83, 8, IEEE80211_T_OFDM },
	{   78, 0x84, 8, IEEE80211_T_OFDM },
	{  104, 0x85, 8, IEEE80211_T_OFDM },
	{  117, 0x86, 8, IEEE80211_T_OFDM },
	{  130, 0x87, 8, IEEE80211_T_OFDM },
	{   26, 0x88, 4, IEEE80211_T_OFDM },
	{   52, 0x89, 6, IEEE80211_T_OFDM },
	{   78, 0x8a, 8, IEEE80211_T_OFDM },
	{  104, 0x8b, 8, IEEE80211_T_OFDM },
	{  156, 0x8c, 8, IEEE80211_T_OFDM },
	{  208, 0x8d, 8, IEEE80211_T_OFDM },
	{  234, 0x8e, 8, IEEE80211_T_OFDM },
	{  260, 0x8f, 8, IEEE80211_T_OFDM }
};

struct athn_series {
	uint16_t	dur;
	uint8_t		hwrate;
};

struct athn_pier {
	uint8_t		fbin;
	const uint8_t	*pwr[AR_PD_GAINS_IN_MASK];
	const uint8_t	*vpd[AR_PD_GAINS_IN_MASK];
};

/*
 * Structures used to store initialization values.
 */
struct athn_ini {
	int		nregs;
	const uint16_t	*regs;
	const uint32_t	*vals_5g20;
	const uint32_t	*vals_5g40;
	const uint32_t	*vals_2g40;
	const uint32_t	*vals_2g20;
	int		ncmregs;
	const uint16_t	*cmregs;
	const uint32_t	*cmvals;
	int		nfastregs;
	const uint16_t	*fastregs;
	const uint32_t	*fastvals_5g20;
	const uint32_t	*fastvals_5g40;
};

struct athn_gain {
	int		nregs;
	const uint16_t	*regs;
	const uint32_t	*vals_5g;
	const uint32_t	*vals_2g;
};

struct athn_addac {
	int		nvals;
	const uint32_t	*vals;
};

struct athn_serdes {
	int		nvals;
	const uint32_t	*regs;
	const uint32_t	*vals;
};

/* Rx queue software indexes. */
#define ATHN_QID_LP		0
#define ATHN_QID_HP		1

/* Tx queue software indexes. */
#define ATHN_QID_AC_BE		0
#define ATHN_QID_PSPOLL		1
#define ATHN_QID_AC_BK		2
#define ATHN_QID_AC_VI		3
#define ATHN_QID_AC_VO		4
#define ATHN_QID_UAPSD		5
#define ATHN_QID_CAB		6
#define ATHN_QID_BEACON		7
#define ATHN_QID_COUNT		8

/* Map Access Category to Tx queue Id. */
static const uint8_t athn_ac2qid[EDCA_NUM_AC] = {
	ATHN_QID_AC_BE,	/* EDCA_AC_BE */
	ATHN_QID_AC_BK,	/* EDCA_AC_BK */
	ATHN_QID_AC_VI,	/* EDCA_AC_VI */
	ATHN_QID_AC_VO	/* EDCA_AC_VO */
};

static const uint8_t athn_5ghz_chans[] = {
	/* UNII 1. */
	36, 40, 44, 48,
	/* UNII 2. */
	52, 56, 60, 64,
	/* Middle band. */
	100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140,
	/* UNII 3. */
	149, 153, 157, 161, 165
};

/* Number of data bits per OFDM symbol for MCS[0-15]. */
/* See tables 20-29, 20-30, 20-33, 20-34. */
static const uint16_t ar_mcs_ndbps[][2] = {
	/* 20MHz  40MHz */
	{     26,    54 },	/* MCS0 */
	{     52,   108 },	/* MCS1 */
	{     78,   162 },	/* MCS2 */
	{    104,   216 },	/* MCS3 */
	{    156,   324 },	/* MCS4 */
	{    208,   432 },	/* MCS5 */
	{    234,   486 },	/* MCS6 */
	{    260,   540 },	/* MCS7 */
	{     26,   108 },	/* MCS8 */
	{     52,   216 },	/* MCS9 */
	{     78,   324 },	/* MCS10 */
	{    104,   432 },	/* MCS11 */
	{    156,   648 },	/* MCS12 */
	{    208,   864 },	/* MCS13 */
	{    234,   972 },	/* MCS14 */
	{    260,  1080 }	/* MCS15 */
};

#define ATHN_POWER_OFDM6	0
#define ATHN_POWER_OFDM9	1
#define ATHN_POWER_OFDM12	2
#define ATHN_POWER_OFDM18	3
#define ATHN_POWER_OFDM24	4
#define ATHN_POWER_OFDM36	5
#define ATHN_POWER_OFDM48	6
#define ATHN_POWER_OFDM54	7
#define ATHN_POWER_CCK1_LP	8
#define ATHN_POWER_CCK2_LP	9
#define ATHN_POWER_CCK2_SP	10
#define ATHN_POWER_CCK55_LP	11
#define ATHN_POWER_CCK55_SP	12
#define ATHN_POWER_CCK11_LP	13
#define ATHN_POWER_CCK11_SP	14
#define ATHN_POWER_XR		15
#define ATHN_POWER_HT20(mcs)	(16 + (mcs))
#define ATHN_POWER_HT40(mcs)	(40 + (mcs))
#define ATHN_POWER_CCK_DUP	64
#define ATHN_POWER_OFDM_DUP	65
#define ATHN_POWER_CCK_EXT	66
#define ATHN_POWER_OFDM_EXT	67
#define ATHN_POWER_COUNT	68

#define ATHN_NUM_LEGACY_RATES	IEEE80211_RATE_MAXSIZE
#define ATHN_NUM_RATES		(ATHN_NUM_LEGACY_RATES + ATHN_NUM_MCS)
struct athn_node {
	struct ieee80211_node		ni;
	struct ieee80211_amrr_node	amn;
	struct ieee80211_mira_node	mn;
	uint8_t				ridx[ATHN_NUM_RATES];
	uint8_t				fallback[ATHN_NUM_RATES];
	uint8_t				sta_index;
};

/*
 * Adaptive noise immunity state.
 */
#define ATHN_ANI_PERIOD		100
#define ATHN_ANI_RSSI_THR_HIGH	40
#define ATHN_ANI_RSSI_THR_LOW	7
struct athn_ani {
	uint8_t		noise_immunity_level;
	uint8_t		spur_immunity_level;
	uint8_t		firstep_level;
	uint8_t		ofdm_weak_signal;
	uint8_t		cck_weak_signal;

	uint32_t	listen_time;

	uint32_t	ofdm_trig_high;
	uint32_t	ofdm_trig_low;

	int32_t		cck_trig_high;
	int32_t		cck_trig_low;

	uint32_t	ofdm_phy_err_base;
	uint32_t	cck_phy_err_base;
	uint32_t	ofdm_phy_err_count;
	uint32_t	cck_phy_err_count;

	uint32_t	cyccnt;
	uint32_t	txfcnt;
	uint32_t	rxfcnt;
};

struct athn_iq_cal {
	uint32_t	pwr_meas_i;
	uint32_t	pwr_meas_q;
	int32_t		iq_corr_meas;
};

struct athn_adc_cal {
	uint32_t	pwr_meas_odd_i;
	uint32_t	pwr_meas_even_i;
	uint32_t	pwr_meas_odd_q;
	uint32_t	pwr_meas_even_q;
};

struct athn_calib {
	int			nsamples;
	struct athn_iq_cal	iq[AR_MAX_CHAINS];
	struct athn_adc_cal	adc_gain[AR_MAX_CHAINS];
	struct athn_adc_cal	adc_dc_offset[AR_MAX_CHAINS];
};

#define ATHN_NF_CAL_HIST_MAX	5

struct athn_softc;

struct athn_ops {
	/* Bus callbacks. */
	uint32_t	(*read)(struct athn_softc *, uint32_t);
	void		(*write)(struct athn_softc *, uint32_t, uint32_t);
	void		(*write_barrier)(struct athn_softc *);

	void	(*setup)(struct athn_softc *);
	void	(*set_txpower)(struct athn_softc *, struct ieee80211_channel *,
		    struct ieee80211_channel *);
	void	(*spur_mitigate)(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
	const struct ar_spur_chan *
		(*get_spur_chans)(struct athn_softc *, int);
	void	(*init_from_rom)(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
	int	(*set_synth)(struct athn_softc *, struct ieee80211_channel *,
		    struct ieee80211_channel *);
	int	(*read_rom_data)(struct athn_softc *, uint32_t, void *, int);
	const uint8_t *
		(*get_rom_template)(struct athn_softc *, uint8_t);
	void	(*swap_rom)(struct athn_softc *);
	void	(*olpc_init)(struct athn_softc *);
	void	(*olpc_temp_compensation)(struct athn_softc *);
	/* GPIO callbacks. */
	int	(*gpio_read)(struct athn_softc *, int);
	void	(*gpio_write)(struct athn_softc *, int, int);
	void	(*gpio_config_input)(struct athn_softc *, int);
	void	(*gpio_config_output)(struct athn_softc *, int, int);
	void	(*rfsilent_init)(struct athn_softc *);
	/* DMA callbacks. */
	int	(*dma_alloc)(struct athn_softc *);
	void	(*dma_free)(struct athn_softc *);
	void	(*rx_enable)(struct athn_softc *);
	int	(*intr)(struct athn_softc *);
	int	(*tx)(struct athn_softc *, struct mbuf *,
		    struct ieee80211_node *, int);
	/* PHY callbacks. */
	void	(*set_rf_mode)(struct athn_softc *,
		    struct ieee80211_channel *);
	int	(*rf_bus_request)(struct athn_softc *);
	void	(*rf_bus_release)(struct athn_softc *);
	void	(*set_phy)(struct athn_softc *, struct ieee80211_channel *,
		    struct ieee80211_channel *);
	void	(*set_delta_slope)(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
	void	(*enable_antenna_diversity)(struct athn_softc *);
	void	(*init_baseband)(struct athn_softc *);
	void	(*disable_phy)(struct athn_softc *);
	void	(*set_rxchains)(struct athn_softc *);
	void	(*noisefloor_calib)(struct athn_softc *);
	void	(*do_calib)(struct athn_softc *);
	void	(*next_calib)(struct athn_softc *);
	void	(*hw_init)(struct athn_softc *, struct ieee80211_channel *,
		    struct ieee80211_channel *);
	void	(*get_paprd_masks)(struct athn_softc *sc,
		    struct ieee80211_channel *, uint32_t *, uint32_t *);
	/* ANI callbacks. */
	void	(*set_noise_immunity_level)(struct athn_softc *, int);
	void	(*enable_ofdm_weak_signal)(struct athn_softc *);
	void	(*disable_ofdm_weak_signal)(struct athn_softc *);
	void	(*set_cck_weak_signal)(struct athn_softc *, int);
	void	(*set_firstep_level)(struct athn_softc *, int);
	void	(*set_spur_immunity_level)(struct athn_softc *, int);
};

struct athn_softc {
	struct device			sc_dev;
	struct ieee80211com		sc_ic;

	int				(*sc_enable)(struct athn_softc *);
	void				(*sc_disable)(struct athn_softc *);
	void				(*sc_power)(struct athn_softc *, int);
	void				(*sc_disable_aspm)(struct athn_softc *);
	void				(*sc_enable_extsynch)(
					    struct athn_softc *);

	int				(*sc_newstate)(struct ieee80211com *,
					    enum ieee80211_state, int);

	bus_dma_tag_t			sc_dmat;

	struct timeout			scan_to;
	struct timeout			calib_to;
	struct ieee80211_amrr		amrr;

	u_int				flags;
#define ATHN_FLAG_PCIE			(1 << 0)
#define ATHN_FLAG_USB			(1 << 1)
#define ATHN_FLAG_OLPC			(1 << 2)
#define ATHN_FLAG_PAPRD			(1 << 3)
#define ATHN_FLAG_FAST_PLL_CLOCK	(1 << 4)
#define ATHN_FLAG_RFSILENT		(1 << 5)
#define ATHN_FLAG_RFSILENT_REVERSED	(1 << 6)
#define ATHN_FLAG_BTCOEX2WIRE		(1 << 7)
#define ATHN_FLAG_BTCOEX3WIRE		(1 << 8)
/* Shortcut. */
#define ATHN_FLAG_BTCOEX	(ATHN_FLAG_BTCOEX2WIRE | ATHN_FLAG_BTCOEX3WIRE)
#define ATHN_FLAG_11A			(1 << 9)
#define ATHN_FLAG_11G			(1 << 10)
#define ATHN_FLAG_11N			(1 << 11)
#define ATHN_FLAG_AN_TOP2_FIXUP		(1 << 12)
#define ATHN_FLAG_NON_ENTERPRISE	(1 << 13)
#define ATHN_FLAG_3TREDUCE_CHAIN	(1 << 14)

	uint8_t				ngpiopins;
	int				led_pin;
	int				rfsilent_pin;
	int				led_state;
	uint32_t			isync;
	uint32_t			imask;

	uint16_t			mac_ver;
	uint8_t				mac_rev;
	uint8_t				rf_rev;
	uint16_t			eep_rev;

	uint8_t				txchainmask;
	uint8_t				rxchainmask;
	uint8_t				ntxchains;
	uint8_t				nrxchains;

	uint8_t				sup_calib_mask;
	uint8_t				cur_calib_mask;
#define ATHN_CAL_IQ		(1 << 0)
#define ATHN_CAL_ADC_GAIN	(1 << 1)
#define ATHN_CAL_ADC_DC		(1 << 2)
#define ATHN_CAL_TEMP		(1 << 3)

	struct ieee80211_channel	*curchan;
	struct ieee80211_channel	*curchanext;

	/* Open Loop Power Control. */
	int8_t				tx_gain_tbl[AR9280_TX_GAIN_TABLE_SIZE];
	int8_t				pdadc;
	int8_t				tcomp;
	int				olpc_ticks;

	/* PA predistortion. */
	uint16_t			gain1[AR_MAX_CHAINS];
	uint32_t			txgain[AR9003_TX_GAIN_TABLE_SIZE];
	int16_t				pa_in[AR_MAX_CHAINS]
					     [AR9003_PAPRD_MEM_TAB_SIZE];
	int16_t				angle[AR_MAX_CHAINS]
					     [AR9003_PAPRD_MEM_TAB_SIZE];
	int32_t				trainpow;
	uint8_t				paprd_curchain;

	uint32_t			rwbuf[64];

	int				kc_entries;

	void				*eep;
	const void			*eep_def;
	uint32_t			eep_base;
	uint32_t			eep_size;

	struct athn_rxq			rxq[2];
	struct athn_txq			txq[31];

	void				*descs;
	bus_dmamap_t			map;
	bus_dma_segment_t		seg;
	SIMPLEQ_HEAD(, athn_tx_buf)	txbufs;
	struct athn_tx_buf		*bcnbuf;
	struct athn_tx_buf		txpool[ATHN_NTXBUFS];

	bus_dmamap_t			txsmap;
	bus_dma_segment_t		txsseg;
	void				*txsring;
	int				txscur;

	int				sc_if_flags;
	int				sc_tx_timer;

	const struct athn_ini		*ini;
	const struct athn_gain		*rx_gain;
	const struct athn_gain		*tx_gain;
	const struct athn_addac		*addac;
	const struct athn_serdes	*serdes;
	uint32_t			workaround;
	uint32_t			obs_off;
	uint32_t			gpio_input_en_off;

	struct athn_ops			ops;

	int				fixed_ridx;

	int16_t				cca_min_2g;
	int16_t				cca_max_2g;
	int16_t				cca_min_5g;
	int16_t				cca_max_5g;
	int16_t				def_nf;
	struct {
		int16_t	nf[AR_MAX_CHAINS];
		int16_t	nf_ext[AR_MAX_CHAINS];
	}				nf_hist[ATHN_NF_CAL_HIST_MAX];
	int				nf_hist_cur;
	int16_t				nf_priv[AR_MAX_CHAINS];
	int16_t				nf_ext_priv[AR_MAX_CHAINS];
	int				pa_calib_ticks;

	struct athn_calib		calib;
	struct athn_ani			ani;

#if NBPFILTER > 0
	caddr_t				sc_drvbpf;

	union {
		struct athn_rx_radiotap_header th;
		uint8_t pad[IEEE80211_RADIOTAP_HDRLEN];
	} sc_rxtapu;
#define sc_rxtap			sc_rxtapu.th
	int				sc_rxtap_len;

	union {
		struct athn_tx_radiotap_header th;
		uint8_t pad[IEEE80211_RADIOTAP_HDRLEN];
	} sc_txtapu;
#define sc_txtap			sc_txtapu.th
	int				sc_txtap_len;
#endif
};

extern int	athn_attach(struct athn_softc *);
extern void	athn_detach(struct athn_softc *);
extern void	athn_suspend(struct athn_softc *);
extern void	athn_wakeup(struct athn_softc *);
extern int	athn_intr(void *);
@


1.36
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.35 2013/12/06 21:03:02 deraadt Exp $	*/
d123 1
d126 2
d129 1
d132 3
a134 3
	uint8_t	rate;		/* Rate in 500Kbps unit or MCS if 0x80. */
	uint8_t	hwrate;		/* HW representation. */
	uint8_t	rspridx;	/* Control Response Frame rate index. */
d149 16
a164 16
	{ 0x80, 0x80, 8, IEEE80211_T_OFDM },
	{ 0x81, 0x81, 8, IEEE80211_T_OFDM },
	{ 0x82, 0x82, 8, IEEE80211_T_OFDM },
	{ 0x83, 0x83, 8, IEEE80211_T_OFDM },
	{ 0x84, 0x84, 8, IEEE80211_T_OFDM },
	{ 0x85, 0x85, 8, IEEE80211_T_OFDM },
	{ 0x86, 0x86, 8, IEEE80211_T_OFDM },
	{ 0x87, 0x87, 8, IEEE80211_T_OFDM },
	{ 0x88, 0x88, 8, IEEE80211_T_OFDM },
	{ 0x89, 0x89, 8, IEEE80211_T_OFDM },
	{ 0x8a, 0x8a, 8, IEEE80211_T_OFDM },
	{ 0x8b, 0x8b, 8, IEEE80211_T_OFDM },
	{ 0x8c, 0x8c, 8, IEEE80211_T_OFDM },
	{ 0x8d, 0x8d, 8, IEEE80211_T_OFDM },
	{ 0x8e, 0x8e, 8, IEEE80211_T_OFDM },
	{ 0x8f, 0x8f, 8, IEEE80211_T_OFDM }
d295 2
d300 3
a302 2
	uint8_t				ridx[IEEE80211_RATE_MAXSIZE];
	uint8_t				fallback[IEEE80211_RATE_MAXSIZE];
@


1.35
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.34 2013/10/21 16:13:49 stsp Exp $	*/
a180 1
#ifndef IEEE80211_NO_HT
a182 1
#endif
a189 1
#ifndef IEEE80211_NO_HT
a190 1
#endif
@


1.34
log
@Fix values of AR9003 Rx queue software indexes. Both indexes were zero,
which is obviously not intended given how they are used in the ar9003 code.
No currently working athn(4) devices are affected by this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.33 2012/10/20 09:54:20 stsp Exp $	*/
d584 1
a584 1
extern void	athn_resume(struct athn_softc *);
@


1.33
log
@Init values for the AR9485 were for version 1.0 of this chip, which according
to Atheros Linux developers was never sold. So update initvals to what Linux
is using for the 1.1 generation. Because the serdes values are written to
different registers on the AR9485 this involves tweaking the serdes init code
for all athn(4) chip families. This commit doesn't make AR9485 devices work
yet but is a step in the right direction.

Tested by krw, kettenis, and Andrew Ngo.  ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.32 2012/08/25 12:14:31 kettenis Exp $	*/
d217 1
a217 1
#define ATHN_QID_HP		0
@


1.32
log
@Add support for power saving in Host AP mode.

ok stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.31 2012/06/10 21:23:36 kettenis Exp $	*/
d211 1
@


1.31
log
@Allow a variable number of words for the Serializer/Deserializer programming.
Probably not enought to make the AR9380 chips to work, but at least the kernel
shouldn't crash anymore when we see one.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.30 2011/01/08 15:05:24 damien Exp $	*/
d86 1
@


1.30
log
@fix LEDs handling.
do not read back the LED GPIO pin since it is configured in output
only mode.
makes the link LED blink on the WiFiStation EXT when scanning (the
LEDs indicating the signal strength are not working yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.29 2011/01/06 07:27:15 damien Exp $	*/
d208 5
d534 1
a534 1
	const uint32_t			*serdes;
@


1.29
log
@"athn* at uhub? port ?"
this adds preliminary support for the Atheros AR9271 chipset and
probably the AR9280+AR7010 and AR9287+AR7010 too though those were
not tested.
scanning still takes a very long time (~1 sec per channel) but
otherwise, operation in STA mode seems stable.
will implement fast channel change soon.

committed over the Ubiquiti WifiStation EXT (AR9271) on i386 with WPA.
requires firmware (see man page for details)

ok deraadt@@ (who checked the .h files)
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.28 2011/01/01 10:48:31 damien Exp $	*/
d458 1
@


1.28
log
@add code to read OTPROM on the AR9485
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.27 2010/12/31 21:23:55 damien Exp $	*/
d293 1
@


1.27
log
@limit the number of Tx chains used on some 3-stream AR9380 chips
for MCS0~15 to not exceed the PCIe power requirements.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.26 2010/12/31 14:06:05 damien Exp $	*/
d367 1
@


1.26
log
@Make the athn(4) back-end more bus agnostic by moving read and write
operations to callbacks in the PCI and CardBus front-ends.
This will allow support of other buses like USB.
Assume the following memory model:
- writes are ordered but may be buffered and require explicit flush
- a read always flushes all buffered writes
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.25 2010/11/10 21:06:44 damien Exp $	*/
d422 2
d451 1
@


1.25
log
@Several updates for the Osprey (AR9380):
- Add the different ROM templates for the different chips
- Fix AR_PHY_65NM_CH0_TOP_XPABIASLVL definition
- Apply attenuation settings from the ROM
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.24 2010/10/18 16:37:12 damien Exp $	*/
d19 3
a21 1
/*#define ATHN_BT_COEXISTENCE	1*/
d351 5
a426 2
	bus_space_tag_t			sc_st;
	bus_space_handle_t		sc_sh;
d434 8
a441 7
#define ATHN_FLAG_OLPC			(1 << 1)
#define ATHN_FLAG_PAPRD			(1 << 2)
#define ATHN_FLAG_FAST_PLL_CLOCK	(1 << 3)
#define ATHN_FLAG_RFSILENT		(1 << 4)
#define ATHN_FLAG_RFSILENT_REVERSED	(1 << 5)
#define ATHN_FLAG_BTCOEX2WIRE		(1 << 6)
#define ATHN_FLAG_BTCOEX3WIRE		(1 << 7)
d444 5
a448 5
#define ATHN_FLAG_11A			(1 << 8)
#define ATHN_FLAG_11G			(1 << 9)
#define ATHN_FLAG_11N			(1 << 10)
#define ATHN_FLAG_AN_TOP2_FIXUP		(1 << 11)
#define ATHN_FLAG_NON_ENTERPRISE	(1 << 12)
@


1.24
log
@Stop compiling with ATHN_DEBUG defined by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.23 2010/09/03 15:40:08 damien Exp $	*/
d360 2
d442 1
@


1.23
log
@fix initialization value of analog register AR_AN_TOP2 on some high
power AR9220 adapters.
this should fix at least Ubiquiti SR71-12 and Winstron DMNA92 adapters.

problem reported by Giuseppe Scalzi and Alex Dervish
fix tested by Giuseppe Scalzi with a Winstron DMNA92
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.22 2010/08/12 16:51:30 damien Exp $	*/
a18 1
#define ATHN_DEBUG		1
@


1.22
log
@Enable periodic (every 4 minutes) power amplifier calibration
on AR9285 and AR9287.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.21 2010/08/12 16:32:31 damien Exp $	*/
d440 1
@


1.21
log
@For chips in open-loop power control mode, periodically (every 30 secs)
compensate Tx gain for temperature changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.20 2010/07/21 14:01:58 kettenis Exp $	*/
d535 1
@


1.20
log
@Add suspend/unsuspend logic.

ok damien@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.19 2010/07/15 20:37:38 damien Exp $	*/
d363 1
d471 1
@


1.19
log
@According to Linux ath9k, the AR9280 1.0 was never sold.
Since this is the only chip revision that requires split TKIP MIC keys,
remove code that deal with that.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.18 2010/06/22 19:44:22 damien Exp $	*/
d558 2
@


1.18
log
@cleanup/fix PA predistortion code.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.17 2010/06/21 19:54:28 damien Exp $	*/
d428 1
a428 1
#define ATHN_FLAG_SPLIT_MMIC		(1 << 2)
a438 2
#define ATHN_FLAG_SPLIT_TKIP_MIC	(1 << 11)
#define ATHN_FLAG_PAPRD			(1 << 12)
@


1.17
log
@Implement PA linearization on adapters with digital predistorters
(AR9003 family only).

The power amplifier predistortion state machine works as follows:
1) Disable digital predistorters for all Tx chains
2) Repeat steps 3~7 for all Tx chains
3)   Force Tx gain to that of training signal
4)   Send training signal (asynchronous)
5)   Wait for training signal to complete (asynchronous)
6)   Read PA measurements (input power, output power, output phase)
7)   Compute the predistortion function that linearizes PA output
8) Write predistortion functions to hardware tables for all Tx chains
9) Enable digital predistorters for all Tx chains

from ath9k (though implementation differs a lot)
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.15 2010/06/05 18:43:57 damien Exp $	*/
d476 3
a478 1
	uint32_t			paprd[AR_MAX_CHAINS]
@


1.16
log
@allow Tx flags to be passed to the tx() routine.
@
text
@d84 1
d394 2
d440 1
d472 8
@


1.15
log
@- fix athn_set_key() on big-endian machines (function is not used yet)
- change sign extension such that we do not rely on >> being an
  arithmetic shift on signed integers
- various changes to AR9003 code, fix Tx path, enable Tx IQ calibration
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.14 2010/05/16 14:34:19 damien Exp $	*/
d83 1
d374 1
a374 1
		    struct ieee80211_node *);
@


1.14
log
@cleanup hardware key cache management (not used yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.13 2010/05/16 09:42:04 damien Exp $	*/
d31 3
d88 2
@


1.13
log
@cleanup calibration bits (not everything is enabled yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.12 2010/05/16 09:19:48 damien Exp $	*/
d430 1
@


1.12
log
@initial Host AP bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.11 2010/05/11 19:34:20 damien Exp $	*/
d447 2
a448 1
	uint8_t				calib_mask;
@


1.11
log
@enable fast PLL clock for 5GHz on AR9280 >=2.0 (unless EEPROM says the
opposite) and on AR9380 2.0.

tested on my AR9280 2.1 with a NETGEAR WNHDE111 AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.10 2010/05/10 17:44:21 damien Exp $	*/
d477 1
@


1.10
log
@athn(4) is going to support a new family of Atheros 802.11n
chips (AR9003), which differs from the currently supported
families (AR5008, AR9001 and AR9002).

The main differences (from a driver point of view) are:

* DMA:
Tx and Rx descriptors have changed.
A single Tx descriptor can now reference up to 4 scatter/gather
DMA segments.
There is now a DMA ring for reporting Tx status with separate
Tx status descriptors (this ring is used to report Tx status for
all the Tx FIFOs).
Rx status descriptors are now put at the beginning of Rx buffers
and do not need to be allocated separately from buffers.
There are two Rx FIFOs (low priority and high priority) instead
of one.

* ROM:
The AR9003 family uses OTP-ROM instead of EEPROM.
Reading the ROM is totally insane since vendors can provide only
the chunks of ROM that differ from a default image (and thus the
default image has to be stored in the driver).
This is referenced as "compressed ROM" in the Linux driver, though
there is no real compression involved, at least for the moment.

* PHY registers:
All PHY registers have changed.
Some registers offsets do not fit on 16 bits anymore, but
since they are 32-bit aligned, we can still make them fit on
16 bits to save .rodata space in initialization tables.

* MAC registers:
Some MAC registers offsets have changed (GPIO, interrupt masks)
which is quite annoying (though ~98% remain the same.)

* Initialization values:
Initialization values are now split in mac/soc/bb/radio blocks
and pre/core/post phases in the Linux driver.  I have chosen to
not go that road and merge these blocks in modal and non-modal
initialization values (similar to the other families).
The initialization order remains exactly the same as the Linux
driver though.

To manage these differences, I have split athn.c in two backends:
ar5008.c contains the bits that are specific to the AR5008,
AR9001 and AR9002 families (used by ar5416.c, ar9280.c,
ar9285.c and ar9287.c) and that were previously in athn.c.

ar9003.c contains the bits that are specific to the new
AR9003 family (used by ar9380.c only for now.)

I have introduced a thin hardware abstraction layer (actually
a set of pointers to functions) that is used in athn.c.
My intent is to keep this abstraction layer as thin as possible
and not to create another ugly pile of abstraction layers a la
MadWifi.

I think I've managed to keep things sane, probably at the expense
of duplicating some code in both ar5008.c and ar9003.c, but at
least we do not have to dig through layers and layers of virtual
descriptors to figure out what is mapped to the hardware.

Tested for non-regression on various AR5416 (sparc64+i386), AR9281
and AR9285 (i386 only) adapters.
AR9380 part is not tested (hardware is not available to the general
public yet).

Committed over my AR9285 2.0.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.8 2010/02/15 17:16:36 damien Exp $	*/
d180 6
@


1.9
log
@disable bluetooth coexistence as I suspect this is what is causing
troubles to some people with AR9285+AR3011 combo adapters.
@
text
@d34 2
a35 3
#define ATHN_NRXBUFS		64
#define ATHN_NTXBUFS		64	/* Shared between all Tx queues. */
#define ATHN_MAX_SCATTER	16
d74 1
a74 1
	struct ar_tx_desc		*bf_descs;
d84 1
a84 1
	struct ar_tx_desc		*lastds;
d90 1
a90 1
	struct ar_rx_desc		*bf_desc;
d98 1
a98 1
	struct athn_rx_buf		bf[ATHN_NRXBUFS];
d100 2
a101 2
	struct ar_rx_desc		*descs;
	struct ar_rx_desc		*lastds;
d104 1
d194 4
d267 6
a272 6
#define ATHN_POWER_HT40(mcs)	(24 + (mcs))
#define ATHN_POWER_CCK_DUP	32
#define ATHN_POWER_OFDM_DUP	33
#define ATHN_POWER_CCK_EXT	34
#define ATHN_POWER_OFDM_EXT	35
#define ATHN_POWER_COUNT	36
d281 3
d306 1
a306 1
	
d342 2
a343 1
	const struct ar_spur_chan *(*get_spur_chans)(struct athn_softc *, int);
d350 38
d414 5
a418 4
#define ATHN_FLAG_RFSILENT		(1 << 3)
#define ATHN_FLAG_RFSILENT_REVERSED	(1 << 4)
#define ATHN_FLAG_BTCOEX2WIRE		(1 << 5)
#define ATHN_FLAG_BTCOEX3WIRE		(1 << 6)
d421 3
a434 1
	uint32_t			phy_rev;
d445 1
d460 1
d464 2
a465 2
	struct athn_rxq			rxq;
	struct athn_txq			txq[31];	/* 0x1f ??? */
d467 1
a467 1
	struct ar_tx_desc		*descs;
d473 5
d487 2
d494 4
a531 49
extern int	ar5416_attach(struct athn_softc *);
extern int	ar9280_attach(struct athn_softc *);
extern int	ar9285_attach(struct athn_softc *);
extern int	ar9287_attach(struct athn_softc *);
extern uint8_t	athn_reverse_bits(uint8_t, int);
extern uint8_t	athn_chan2fbin(struct ieee80211_channel *);
extern void	athn_set_viterbi_mask(struct athn_softc *, int);
extern void	athn_write_txpower(struct athn_softc *, int16_t[]);
extern void	athn_get_lg_tpow(struct athn_softc *,
		    struct ieee80211_channel *, uint8_t,
		    const struct ar_cal_target_power_leg *, int, uint8_t[]);
extern void	athn_get_ht_tpow(struct athn_softc *,
		    struct ieee80211_channel *, uint8_t,
		    const struct ar_cal_target_power_ht *, int, uint8_t[]);
extern void	athn_get_pdadcs(struct athn_softc *, uint8_t,
		    struct athn_pier *, struct athn_pier *, int, int, uint8_t,
		    uint8_t *, uint8_t *);
extern void	athn_get_pier_ival(uint8_t, const uint8_t *, int, int *,
		    int *);
/* XXX not here. */
extern void	ar5416_set_txpower(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
extern void	ar5416_swap_rom(struct athn_softc *);
extern void	ar9280_2_0_olpc_get_pdadcs(struct athn_softc *,
		    struct ieee80211_channel *, int, uint8_t[], uint8_t[],
		    uint8_t *);
extern int	ar9280_set_synth(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
extern void	ar9280_spur_mitigate(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
extern void	ar9287_1_2_enable_async_fifo(struct athn_softc *);
extern void	ar9287_1_2_setup_async_fifo(struct athn_softc *);
extern const	struct ar_spur_chan *ar5416_get_spur_chans(struct athn_softc *,
		    int);
extern int	ar5416_init_calib(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
extern int	ar9285_1_2_init_calib(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
extern void	ar9285_pa_calib(struct athn_softc *);
extern void	ar9280_reset_rx_gain(struct athn_softc *,
		    struct ieee80211_channel *);
extern void	ar9280_reset_tx_gain(struct athn_softc *,
		    struct ieee80211_channel *);
extern void	ar5416_reset_addac(struct athn_softc *,
		    struct ieee80211_channel *);
extern void	ar5416_reset_bb_gain(struct athn_softc *,
		    struct ieee80211_channel *);
extern void	ar5416_rf_reset(struct athn_softc *,
		    struct ieee80211_channel *);
@


1.8
log
@Properly detect when the band changes from 2GHz to 5GHz and
vice-versa, and do a full reset of the chip when it happens.
This does not affect the AR9280 since a full reset is always
necessary when the channel changes.

Should fix dual-band AR5416 devices (problem reported by Rivo Nurges).
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.7 2010/01/27 18:26:45 damien Exp $	*/
d20 1
a20 1
#define ATHN_BT_COEXISTENCE	1
@


1.7
log
@change the MRR pattern from 1/1/1/1 to 2/2/2/4
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.6 2009/11/22 08:52:45 damien Exp $	*/
d396 3
@


1.6
log
@fix RTS/CTS and CTS-to-self protection modes.
fix 802.11a TXTIME computation (802.11a has a 16us SIFS interval
but does not have the 6us signal extension that ERP-OFDM has so
we can use the same code for 11a and 11g provided that we add
the SIFS nterval in the athn_txtime() function itself.)
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.5 2009/11/19 19:19:59 damien Exp $	*/
d155 1
a155 1
	uint8_t		tries;
a156 1
	uint16_t	dur;
@


1.5
log
@if a radio switch exists, configure the GPIO pin to which it is
connected to raise an interrupt when the pin goes low (or high
depending on the polarity of the radio switch.)
turn the interface down when the interrupt occurs.
this is the same behaviour as in wpi(4) and iwn(4).

cleanup interrupts processing while i'm here.
remove ATHN_INTR_MITIGATION compile option (it is set by default.)
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.4 2009/11/17 18:21:07 damien Exp $	*/
d111 1
a115 1
#define ATHN_IS_OFDM_RIDX(ridx)	(athn_rates[ridx].phy == IEEE80211_T_OFDM)
d121 1
d124 28
a151 28
	{    2, 0x1b, IEEE80211_T_DS },
	{    4, 0x1a, IEEE80211_T_DS },
	{   11, 0x19, IEEE80211_T_DS },
	{   22, 0x18, IEEE80211_T_DS },
	{   12, 0x0b, IEEE80211_T_OFDM },
	{   18, 0x0f, IEEE80211_T_OFDM },
	{   24, 0x0a, IEEE80211_T_OFDM },
	{   36, 0x0e, IEEE80211_T_OFDM },
	{   48, 0x09, IEEE80211_T_OFDM },
	{   72, 0x0d, IEEE80211_T_OFDM },
	{   96, 0x08, IEEE80211_T_OFDM },
	{  108, 0x0c, IEEE80211_T_OFDM },
	{ 0x80, 0x80, IEEE80211_T_OFDM },
	{ 0x81, 0x81, IEEE80211_T_OFDM },
	{ 0x82, 0x82, IEEE80211_T_OFDM },
	{ 0x83, 0x83, IEEE80211_T_OFDM },
	{ 0x84, 0x84, IEEE80211_T_OFDM },
	{ 0x85, 0x85, IEEE80211_T_OFDM },
	{ 0x86, 0x86, IEEE80211_T_OFDM },
	{ 0x87, 0x87, IEEE80211_T_OFDM },
	{ 0x88, 0x88, IEEE80211_T_OFDM },
	{ 0x89, 0x89, IEEE80211_T_OFDM },
	{ 0x8a, 0x8a, IEEE80211_T_OFDM },
	{ 0x8b, 0x8b, IEEE80211_T_OFDM },
	{ 0x8c, 0x8c, IEEE80211_T_OFDM },
	{ 0x8d, 0x8d, IEEE80211_T_OFDM },
	{ 0x8e, 0x8e, IEEE80211_T_OFDM },
	{ 0x8f, 0x8f, IEEE80211_T_OFDM }
a432 1
	int				sifs;
@


1.4
log
@update hardware multicast filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.3 2009/11/17 18:01:40 damien Exp $	*/
a19 1
#define ATHN_INTR_MITIGATION	1
d378 2
a427 1

@


1.3
log
@add short interframe space to duration since the athn_txtime
function does not take it into account. oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: athnvar.h,v 1.2 2009/11/15 14:04:02 damien Exp $	*/
d418 1
@


1.2
log
@AR9287 uses GPIO pin 8 for LED, not 1.
Turn link LED on while associated.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d431 1
@


1.1
log
@athn(4), a driver for Atheros 802.11a/g/n devices.
written from scratch based on the vendor driver for Linux (ath9k).
AR9285 and AR9287 parts are 100% untested.
only basic functionnalities are enabled for now.

committed over an AR9281.

"commit" deraadt
@
text
@d377 1
@

