head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.22
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.26
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.24
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.18
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.20
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.12
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.16
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.14
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.10
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.8
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.4
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.6
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.32
date	2011.04.27.16.06.13;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.27.19.44.43;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.02.06.06.30;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.24.17.22.37;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.29.11.15.32;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.29.00.18.25;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.14.02.28.14;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.13.07.31.57;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.06.21.41.32;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.13.14.44.41;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.23.21.53.01;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.20.21.44.42;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.23.20.06.50;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.22.10.17.04;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.17.13.14.17;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.30.17.13.17;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.28.23.45.10;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.28.00.46.46;	author robert;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.27.09.53.55;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.27.04.10.06;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.24.21.46.18;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.18.18.42.56;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.11.17.45.28;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.03.16.39.54;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.17.21.02.24;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.18.03.40.59;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.23.09.39.29;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.02.02.45.37;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.32
log
@kill a !__NetBSD__ ifdef which just confuses
@
text
@/*      $OpenBSD: athvar.h,v 1.31 2010/09/07 16:21:42 deraadt Exp $  */
/*	$NetBSD: athvar.h,v 1.10 2004/08/10 01:03:53 dyoung Exp $	*/

/*-
 * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
 *    redistribution must be conditioned upon including a substantially
 *    similar Disclaimer requirement for further binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGES.
 *
 * $FreeBSD: src/sys/dev/ath/if_athvar.h,v 1.14 2004/04/03 03:33:02 sam Exp $
 */

/*
 * Definitions for the Atheros Wireless LAN controller driver.
 */
#ifndef _DEV_ATH_ATHVAR_H
#define _DEV_ATH_ATHVAR_H

#ifdef _KERNEL

#include <net80211/ieee80211_radiotap.h>
#include <dev/ic/ar5xxx.h>

#include "bpfilter.h"

#ifdef notyet
#include "gpio.h"
#endif

#define	ATH_TIMEOUT		1000

#define	ATH_RXBUF	40		/* number of RX buffers */
#define	ATH_TXBUF	60		/* number of TX buffers */
#define	ATH_TXDESC	8		/* number of descriptors per buffer */
#define ATH_MAXGPIO	10		/* maximal number of gpio pins */

struct ath_recv_hist {
	int		arh_ticks;	/* sample time by system clock */
	u_int8_t	arh_rssi;	/* rssi */
	u_int8_t	arh_antenna;	/* antenna */
};
#define	ATH_RHIST_SIZE		16	/* number of samples */
#define	ATH_RHIST_NOTIME	(~0)

/*
 * Ioctl-related definitions for the Atheros Wireless LAN controller driver.
 */
struct ath_stats {
	u_int32_t	ast_watchdog;	/* device reset by watchdog */
	u_int32_t	ast_hardware;	/* fatal hardware error interrupts */
	u_int32_t	ast_bmiss;	/* beacon miss interrupts */
	u_int32_t	ast_mib;	/* MIB counter interrupts */
	u_int32_t	ast_rxorn;	/* rx overrun interrupts */
	u_int32_t	ast_rxeol;	/* rx eol interrupts */
	u_int32_t	ast_txurn;	/* tx underrun interrupts */
	u_int32_t	ast_intrcoal;	/* interrupts coalesced */
	u_int32_t	ast_tx_mgmt;	/* management frames transmitted */
	u_int32_t	ast_tx_discard;	/* frames discarded prior to assoc */
	u_int32_t	ast_tx_qstop;	/* output stopped 'cuz no buffer */
	u_int32_t	ast_tx_encap;	/* tx encapsulation failed */
	u_int32_t	ast_tx_nonode;	/* tx failed 'cuz no node */
	u_int32_t	ast_tx_nombuf;	/* tx failed 'cuz no mbuf */
	u_int32_t	ast_tx_nomcl;	/* tx failed 'cuz no cluster */
	u_int32_t	ast_tx_linear;	/* tx linearized to cluster */
	u_int32_t	ast_tx_nodata;	/* tx discarded empty frame */
	u_int32_t	ast_tx_busdma;	/* tx failed for dma resrcs */
	u_int32_t	ast_tx_xretries;/* tx failed 'cuz too many retries */
	u_int32_t	ast_tx_fifoerr;	/* tx failed 'cuz FIFO underrun */
	u_int32_t	ast_tx_filtered;/* tx failed 'cuz xmit filtered */
	u_int32_t	ast_tx_shortretry;/* tx on-chip retries (short) */
	u_int32_t	ast_tx_longretry;/* tx on-chip retries (long) */
	u_int32_t	ast_tx_badrate;	/* tx failed 'cuz bogus xmit rate */
	u_int32_t	ast_tx_noack;	/* tx frames with no ack marked */
	u_int32_t	ast_tx_rts;	/* tx frames with rts enabled */
	u_int32_t	ast_tx_cts;	/* tx frames with cts enabled */
	u_int32_t	ast_tx_shortpre;/* tx frames with short preamble */
	u_int32_t	ast_tx_altrate;	/* tx frames with alternate rate */
	u_int32_t	ast_tx_protect;	/* tx frames with protection */
	u_int32_t	ast_rx_nombuf;	/* rx setup failed 'cuz no mbuf */
	u_int32_t	ast_rx_busdma;	/* rx setup failed for dma resrcs */
	u_int32_t	ast_rx_orn;	/* rx failed 'cuz of desc overrun */
	u_int32_t	ast_rx_crcerr;	/* rx failed 'cuz of bad CRC */
	u_int32_t	ast_rx_fifoerr;	/* rx failed 'cuz of FIFO overrun */
	u_int32_t	ast_rx_badcrypt;/* rx failed 'cuz decryption */
	u_int32_t	ast_rx_phyerr;	/* rx failed 'cuz of PHY err */
	u_int32_t	ast_rx_phy[32];	/* rx PHY error per-code counts */
	u_int32_t	ast_rx_tooshort;/* rx discarded 'cuz frame too short */
	u_int32_t	ast_rx_toobig;	/* rx discarded 'cuz frame too large */
	u_int32_t	ast_rx_ctl;	/* rx discarded 'cuz ctl frame */
	u_int32_t	ast_be_nombuf;	/* beacon setup failed 'cuz no mbuf */
	u_int32_t	ast_per_cal;	/* periodic calibration calls */
	u_int32_t	ast_per_calfail;/* periodic calibration failed */
	u_int32_t	ast_per_rfgain;	/* periodic calibration rfgain reset */
	u_int32_t	ast_rate_calls;	/* rate control checks */
	u_int32_t	ast_rate_raise;	/* rate control raised xmit rate */
	u_int32_t	ast_rate_drop;	/* rate control dropped xmit rate */
};

/*
 * Radio capture format.
 */
#define ATH_RX_RADIOTAP_PRESENT (		\
	(1 << IEEE80211_RADIOTAP_FLAGS)		| \
	(1 << IEEE80211_RADIOTAP_RATE)		| \
	(1 << IEEE80211_RADIOTAP_CHANNEL)	| \
	(1 << IEEE80211_RADIOTAP_ANTENNA)	| \
	(1 << IEEE80211_RADIOTAP_RSSI)		| \
	0)

struct ath_rx_radiotap_header {
	struct ieee80211_radiotap_header wr_ihdr;
	u_int8_t	wr_flags;
	u_int8_t	wr_rate;
	u_int16_t	wr_chan_freq;
	u_int16_t	wr_chan_flags;
	u_int8_t	wr_antenna;
	u_int8_t	wr_rssi;
	u_int8_t	wr_max_rssi;
} __packed;

#define ATH_TX_RADIOTAP_PRESENT (		\
	(1 << IEEE80211_RADIOTAP_FLAGS)		| \
	(1 << IEEE80211_RADIOTAP_RATE)		| \
	(1 << IEEE80211_RADIOTAP_CHANNEL)	| \
	(1 << IEEE80211_RADIOTAP_DBM_TX_POWER)	| \
	(1 << IEEE80211_RADIOTAP_ANTENNA)	| \
	(1 << IEEE80211_RADIOTAP_HWQUEUE)	| \
	0)

struct ath_tx_radiotap_header {
	struct ieee80211_radiotap_header wt_ihdr;
	u_int8_t	wt_flags;
	u_int8_t	wt_rate;
	u_int16_t	wt_chan_freq;
	u_int16_t	wt_chan_flags;
	u_int8_t	wt_txpower;
	u_int8_t	wt_antenna;
	u_int8_t	wt_hwqueue;
} __packed;

/* 
 * driver-specific node 
 */
struct ath_node {
	struct ieee80211_node		an_node;	/* base class */
	struct ieee80211_rssadapt	an_rssadapt;	/* rate adaption */
	u_int				an_tx_antenna;	/* antenna for last good frame */
	u_int				an_rx_antenna;	/* antenna for last rcvd frame */
	struct ath_recv_hist		an_rx_hist[ATH_RHIST_SIZE];
	u_int				an_rx_hist_next;/* index of next ``free entry'' */
};
#define	ATH_NODE(_n)	((struct ath_node *)(_n))

struct ath_buf {
	TAILQ_ENTRY(ath_buf)		bf_list;
	bus_dmamap_t			bf_dmamap;	/* DMA map of the buffer */
#define bf_nseg				bf_dmamap->dm_nsegs
#define bf_mapsize			bf_dmamap->dm_mapsize
#define bf_segs				bf_dmamap->dm_segs
	struct ath_desc			*bf_desc;	/* virtual addr of desc */
	bus_addr_t			bf_daddr;	/* physical addr of desc */
	struct mbuf			*bf_m;		/* mbuf for buf */
	struct ieee80211_node		*bf_node;	/* pointer to the node */
	struct ieee80211_rssdesc	bf_id;
#define	ATH_MAX_SCATTER			64
};

typedef struct ath_task {
	void	(*t_func)(void*, int);
	void	*t_context;
} ath_task_t;

struct ath_softc {
#ifndef __FreeBSD__
	struct device		sc_dev;
#endif
	struct ieee80211com	sc_ic;		/* IEEE 802.11 common */
#ifndef __FreeBSD__
	int			(*sc_enable)(struct ath_softc *);
	void			(*sc_disable)(struct ath_softc *);
	void			(*sc_power)(struct ath_softc *, int);
#endif
	int			(*sc_newstate)(struct ieee80211com *,
					enum ieee80211_state, int);
	void			(*sc_node_free)(struct ieee80211com *,
					struct ieee80211_node *);
	void			(*sc_node_copy)(struct ieee80211com *,
					struct ieee80211_node *,
					const struct ieee80211_node *);
	void			(*sc_recv_mgmt)(struct ieee80211com *,
				    struct mbuf *, struct ieee80211_node *,
				    struct ieee80211_rxinfo *, int);
#ifdef __FreeBSD__
	device_t		sc_dev;
#endif
	bus_space_tag_t		sc_st;		/* bus space tag */
	bus_space_handle_t	sc_sh;		/* bus space handle */
	bus_size_t		sc_ss;		/* bus space size */
	bus_dma_tag_t		sc_dmat;	/* bus DMA tag */
#ifdef __FreeBSD__
	struct mtx		sc_mtx;		/* master lock (recursive) */
#endif
	struct ath_hal		*sc_ah;		/* Atheros HAL */
	unsigned int		sc_invalid : 1,	/* disable hardware accesses */
				sc_doani : 1,	/* dynamic noise immunity */
				sc_veol : 1,	/* tx VEOL support */
				sc_softled : 1,	/* GPIO software LED */
				sc_probing : 1,	/* probing AP on beacon miss */
				sc_pcie : 1;	/* indicates PCI Express */
	u_int			sc_nchan;	/* number of valid channels */
	const HAL_RATE_TABLE	*sc_rates[IEEE80211_MODE_MAX];
	const HAL_RATE_TABLE	*sc_currates;	/* current rate table */
	enum ieee80211_phymode	sc_curmode;	/* current phy mode */
	u_int8_t		sc_rixmap[256];	/* IEEE to h/w rate table ix */
	u_int8_t		sc_hwmap[32];	/* h/w rate ix to IEEE table */
	HAL_INT			sc_imask;	/* interrupt mask copy */

#if NBPFILTER > 0
	caddr_t			sc_drvbpf;

	union {
		struct ath_rx_radiotap_header	th;
		uint8_t				pad[IEEE80211_RADIOTAP_HDRLEN];
	}			sc_rxtapu;
#define sc_rxtap		sc_rxtapu.th
	int			sc_rxtap_len;

	union {
		struct ath_tx_radiotap_header	th;
		uint8_t				pad[IEEE80211_RADIOTAP_HDRLEN];
	}			sc_txtapu;
#define sc_txtap		sc_txtapu.th
	int			sc_txtap_len;
#endif

	struct ath_desc		*sc_desc;	/* TX/RX descriptors */
	bus_dma_segment_t	sc_dseg;
	int			sc_dnseg;	/* number of segments */
	bus_dmamap_t		sc_ddmamap;	/* DMA map for descriptors */
	bus_addr_t		sc_desc_paddr;	/* physical addr of sc_desc */
	bus_addr_t		sc_desc_len;	/* size of sc_desc */

	ath_task_t		sc_fataltask;	/* fatal int processing */
	ath_task_t		sc_rxorntask;	/* rxorn int processing */

	TAILQ_HEAD(, ath_buf)	sc_rxbuf;	/* receive buffer */
	u_int32_t		*sc_rxlink;	/* link ptr in last RX desc */
	ath_task_t		sc_rxtask;	/* rx int processing */

	u_int			sc_txhalq[HAL_NUM_TX_QUEUES];	/* HAL q for outgoing frames */
	u_int32_t		*sc_txlink;	/* link ptr in last TX desc */
	int			sc_tx_timer;	/* transmit timeout */
	TAILQ_HEAD(, ath_buf)	sc_txbuf;	/* transmit buffer */
#ifdef __FreeBSD__
	struct mtx		sc_txbuflock;	/* txbuf lock */
#endif
	TAILQ_HEAD(, ath_buf)	sc_txq;		/* transmitting queue */
#ifdef __FreeBSD__
	struct mtx		sc_txqlock;	/* lock on txq and txlink */
#endif
	ath_task_t		sc_txtask;	/* tx int processing */

	u_int			sc_bhalq;	/* HAL q for outgoing beacons */
	struct ath_buf		*sc_bcbuf;	/* beacon buffer */
	struct ath_buf		*sc_bufptr;	/* allocated buffer ptr */
	ath_task_t		sc_swbatask;	/* swba int processing */
	ath_task_t		sc_bmisstask;	/* bmiss int processing */

#ifdef __OpenBSD__
	struct timeval		sc_last_ch;
	struct timeout		sc_cal_to;
	struct timeval		sc_last_beacon;
	struct timeout		sc_scan_to;
	struct timeout		sc_rssadapt_to;
#else
	struct callout		sc_cal_ch;	/* callout handle for cals */
	struct callout		sc_scan_ch;	/* callout handle for scan */
#endif
	struct ath_stats	sc_stats;	/* interface statistics */
	HAL_MIB_STATS		sc_mib_stats;	/* MIB counter statistics */

#ifndef __FreeBSD__
	u_int			sc_flags;	/* misc flags */
#endif

	u_int8_t                sc_broadcast_addr[IEEE80211_ADDR_LEN];

	struct gpio_chipset_tag sc_gpio_gc;	/* gpio(4) framework */
	gpio_pin_t		sc_gpio_pins[ATH_MAXGPIO];
};

/* unaligned little endian access */     
#define LE_READ_2(p)							\
	((u_int16_t)							\
	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1] <<  8)))
#define LE_READ_4(p)							\
	((u_int32_t)							\
	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1] <<  8) |	\
	 (((u_int8_t *)(p))[2] << 16) | (((u_int8_t *)(p))[3] << 24)))

#ifdef AR_DEBUG
enum {
	ATH_DEBUG_XMIT		= 0x00000001,	/* basic xmit operation */
	ATH_DEBUG_XMIT_DESC	= 0x00000002,	/* xmit descriptors */
	ATH_DEBUG_RECV		= 0x00000004,	/* basic recv operation */
	ATH_DEBUG_RECV_DESC	= 0x00000008,	/* recv descriptors */
	ATH_DEBUG_RATE		= 0x00000010,	/* rate control */
	ATH_DEBUG_RESET		= 0x00000020,	/* reset processing */
	ATH_DEBUG_MODE		= 0x00000040,	/* mode init/setup */
	ATH_DEBUG_BEACON	= 0x00000080,	/* beacon handling */
	ATH_DEBUG_WATCHDOG	= 0x00000100,	/* watchdog timeout */
	ATH_DEBUG_INTR		= 0x00001000,	/* ISR */
	ATH_DEBUG_TX_PROC	= 0x00002000,	/* tx ISR proc */
	ATH_DEBUG_RX_PROC	= 0x00004000,	/* rx ISR proc */
	ATH_DEBUG_BEACON_PROC	= 0x00008000,	/* beacon ISR proc */
	ATH_DEBUG_CALIBRATE	= 0x00010000,	/* periodic calibration */
	ATH_DEBUG_ANY		= 0xffffffff
};
#define	IFF_DUMPPKTS(_ifp, _m) \
	((ath_debug & _m) || \
	    ((_ifp)->if_flags & (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
#define	DPRINTF(_m,X)	if (ath_debug & (_m)) printf X
#else
#define	IFF_DUMPPKTS(_ifp, _m) \
	(((_ifp)->if_flags & (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
#define	DPRINTF(_m, X)
#endif

/*
 * Wrapper code
 */
#ifndef __FreeBSD__
#undef KASSERT
#define KASSERT(cond, complaint) if (!(cond)) panic complaint

#define	ATH_ATTACHED		0x0001		/* attach has succeeded */
#define ATH_ENABLED		0x0002		/* chip is enabled */
#define ATH_GPIO		0x0004		/* gpio device attached */

#define	ATH_IS_ENABLED(sc)	((sc)->sc_flags & ATH_ENABLED)
#endif

#define	ATH_LOCK_INIT(_sc) \
	mtx_init(&(_sc)->sc_mtx, device_get_nameunit((_sc)->sc_dev), \
		 MTX_NETWORK_LOCK, MTX_DEF | MTX_RECURSE)
#define	ATH_LOCK_DESTROY(_sc)	mtx_destroy(&(_sc)->sc_mtx)
#define	ATH_LOCK(_sc)		mtx_lock(&(_sc)->sc_mtx)
#define	ATH_UNLOCK(_sc)		mtx_unlock(&(_sc)->sc_mtx)
#define	ATH_LOCK_ASSERT(_sc)	mtx_assert(&(_sc)->sc_mtx, MA_OWNED)

#define	ATH_TXBUF_LOCK_INIT(_sc) \
	mtx_init(&(_sc)->sc_txbuflock, \
		device_get_nameunit((_sc)->sc_dev), "xmit buf q", MTX_DEF)
#define	ATH_TXBUF_LOCK_DESTROY(_sc)	mtx_destroy(&(_sc)->sc_txbuflock)
#define	ATH_TXBUF_LOCK(_sc)		mtx_lock(&(_sc)->sc_txbuflock)
#define	ATH_TXBUF_UNLOCK(_sc)		mtx_unlock(&(_sc)->sc_txbuflock)
#define	ATH_TXBUF_LOCK_ASSERT(_sc) \
	mtx_assert(&(_sc)->sc_txbuflock, MA_OWNED)

#define	ATH_TXQ_LOCK_INIT(_sc) \
	mtx_init(&(_sc)->sc_txqlock, \
		device_get_nameunit((_sc)->sc_dev), "xmit q", MTX_DEF)
#define	ATH_TXQ_LOCK_DESTROY(_sc)	mtx_destroy(&(_sc)->sc_txqlock)
#define	ATH_TXQ_LOCK(_sc)		mtx_lock(&(_sc)->sc_txqlock)
#define	ATH_TXQ_UNLOCK(_sc)		mtx_unlock(&(_sc)->sc_txqlock)
#define	ATH_TXQ_LOCK_ASSERT(_sc)	mtx_assert(&(_sc)->sc_txqlock, MA_OWNED)

#define ATH_TICKS() (tick)
#define ATH_CALLOUT_INIT(chp) callout_init((chp))
#define ATH_TASK_INIT(task, func, context)	\
	do {					\
		(task)->t_func = (func);	\
		(task)->t_context = (context);	\
	} while (0)
#define ATH_TASK_RUN_OR_ENQUEUE(task) ((*(task)->t_func)((task)->t_context, 1))

typedef unsigned long u_intptr_t;

int	ath_attach(u_int16_t, struct ath_softc *);
int	ath_detach(struct ath_softc *, int);
int	ath_enable(struct ath_softc *);
int	ath_activate(struct device *, int);
int	ath_intr(void *);
int	ath_enable(struct ath_softc *);

/*
 * HAL definitions to comply with local coding convention.
 */
#define	ath_hal_reset(_ah, _opmode, _chan, _outdoor, _pstatus) \
	((*(_ah)->ah_reset)((_ah), (_opmode), (_chan), (_outdoor), (_pstatus)))
#define	ath_hal_get_rate_table(_ah, _mode) \
	((*(_ah)->ah_get_rate_table)((_ah), (_mode)))
#define	ath_hal_get_lladdr(_ah, _mac) \
	((*(_ah)->ah_get_lladdr)((_ah), (_mac)))
#define	ath_hal_set_lladdr(_ah, _mac) \
	((*(_ah)->ah_set_lladdr)((_ah), (_mac)))
#define	ath_hal_set_intr(_ah, _mask) \
	((*(_ah)->ah_set_intr)((_ah), (_mask)))
#define	ath_hal_get_intr(_ah) \
	((*(_ah)->ah_get_intr)((_ah)))
#define	ath_hal_is_intr_pending(_ah) \
	((*(_ah)->ah_is_intr_pending)((_ah)))
#define	ath_hal_get_isr(_ah, _pmask) \
	((*(_ah)->ah_get_isr)((_ah), (_pmask)))
#define	ath_hal_update_tx_triglevel(_ah, _inc) \
	((*(_ah)->ah_update_tx_triglevel)((_ah), (_inc)))
#define	ath_hal_set_power(_ah, _mode, _sleepduration) \
	((*(_ah)->ah_set_power)((_ah), (_mode), AH_TRUE, (_sleepduration)))
#define	ath_hal_reset_key(_ah, _ix) \
	((*(_ah)->ah_reset_key)((_ah), (_ix)))
#define	ath_hal_set_key(_ah, _ix, _pk) \
	((*(_ah)->ah_set_key)((_ah), (_ix), (_pk), NULL, AH_FALSE))
#define	ath_hal_is_key_valid(_ah, _ix) \
	(((*(_ah)->ah_is_key_valid)((_ah), (_ix))))
#define	ath_hal_set_key_lladdr(_ah, _ix, _mac) \
	((*(_ah)->ah_set_key_lladdr)((_ah), (_ix), (_mac)))
#define	ath_hal_softcrypto(_ah, _val ) \
	((*(_ah)->ah_softcrypto)((_ah), (_val)))
#define	ath_hal_get_rx_filter(_ah) \
	((*(_ah)->ah_get_rx_filter)((_ah)))
#define	ath_hal_set_rx_filter(_ah, _filter) \
	((*(_ah)->ah_set_rx_filter)((_ah), (_filter)))
#define	ath_hal_set_mcast_filter(_ah, _mfilt0, _mfilt1) \
	((*(_ah)->ah_set_mcast_filter)((_ah), (_mfilt0), (_mfilt1)))
#define	ath_hal_wait_for_beacon(_ah, _bf) \
	((*(_ah)->ah_wait_for_beacon)((_ah), (_bf)->bf_daddr))
#define	ath_hal_put_rx_buf(_ah, _bufaddr) \
	((*(_ah)->ah_put_rx_buf)((_ah), (_bufaddr)))
#define	ath_hal_get_tsf32(_ah) \
	((*(_ah)->ah_get_tsf32)((_ah)))
#define	ath_hal_get_tsf64(_ah) \
	((*(_ah)->ah_get_tsf64)((_ah)))
#define	ath_hal_reset_tsf(_ah) \
	((*(_ah)->ah_reset_tsf)((_ah)))
#define	ath_hal_start_rx(_ah) \
	((*(_ah)->ah_start_rx)((_ah)))
#define	ath_hal_put_tx_buf(_ah, _q, _bufaddr) \
	((*(_ah)->ah_put_tx_buf)((_ah), (_q), (_bufaddr)))
#define	ath_hal_get_tx_buf(_ah, _q) \
	((*(_ah)->ah_get_tx_buf)((_ah), (_q)))
#define	ath_hal_get_rx_buf(_ah) \
	((*(_ah)->ah_get_rx_buf)((_ah)))
#define	ath_hal_tx_start(_ah, _q) \
	((*(_ah)->ah_tx_start)((_ah), (_q)))
#define	ath_hal_setchannel(_ah, _chan) \
	((*(_ah)->ah_setchannel)((_ah), (_chan)))
#define	ath_hal_calibrate(_ah, _chan) \
	((*(_ah)->ah_calibrate)((_ah), (_chan)))
#define	ath_hal_set_ledstate(_ah, _state) \
	((*(_ah)->ah_set_ledstate)((_ah), (_state)))
#define	ath_hal_init_beacon(_ah, _nextb, _bperiod) \
	((*(_ah)->ah_init_beacon)((_ah), (_nextb), (_bperiod)))
#define	ath_hal_reset_beacon(_ah) \
	((*(_ah)->ah_reset_beacon)((_ah)))
#define	ath_hal_set_beacon_timers(_ah, _bs, _tsf, _dc, _cc) \
	((*(_ah)->ah_set_beacon_timers)((_ah), (_bs), (_tsf), \
	 (_dc), (_cc)))
#define	ath_hal_set_associd(_ah, _bss, _associd) \
	((*(_ah)->ah_set_associd)((_ah), (_bss), (_associd), 0))
#define	ath_hal_get_regdomain(_ah, _prd) \
	(*(_prd) = (_ah)->ah_get_regdomain(_ah))
#define	ath_hal_detach(_ah) \
	((*(_ah)->ah_detach)(_ah))
#define ath_hal_set_slot_time(_ah, _t) \
	((*(_ah)->ah_set_slot_time)(_ah, _t))
#define ath_hal_set_gpio_output(_ah, _gpio) \
	((*(_ah)->ah_set_gpio_output)((_ah), (_gpio)))
#define ath_hal_set_gpio_input(_ah, _gpio) \
	((*(_ah)->ah_set_gpio_input)((_ah), (_gpio)))
#define ath_hal_get_gpio(_ah, _gpio) \
	((*(_ah)->ah_get_gpio)((_ah), (_gpio)))
#define ath_hal_set_gpio(_ah, _gpio, _b) \
	((*(_ah)->ah_set_gpio)((_ah), (_gpio), (_b)))
#define ath_hal_set_gpio_intr(_ah, _gpio, _b) \
	((*(_ah)->ah_set_gpio_intr)((_ah), (_gpio), (_b)))

#define	ath_hal_set_opmode(_ah) \
	((*(_ah)->ah_set_opmode)((_ah)))
#define	ath_hal_stop_tx_dma(_ah, _qnum) \
	((*(_ah)->ah_stop_tx_dma)((_ah), (_qnum)))
#define	ath_hal_stop_pcu_recv(_ah) \
	((*(_ah)->ah_stop_pcu_recv)((_ah)))
#define	ath_hal_start_rx_pcu(_ah) \
	((*(_ah)->ah_start_rx_pcu)((_ah)))
#define	ath_hal_stop_rx_dma(_ah) \
	((*(_ah)->ah_stop_rx_dma)((_ah)))
#define	ath_hal_get_diag_state(_ah, _id, _indata, _insize, _outdata, _outsize) \
	((*(_ah)->ah_get_diag_state)((_ah), (_id), \
	 (_indata), (_insize), (_outdata), (_outsize)))

#define	ath_hal_setup_tx_queue(_ah, _type, _qinfo) \
	((*(_ah)->ah_setup_tx_queue)((_ah), (_type), (_qinfo)))
#define	ath_hal_reset_tx_queue(_ah, _q) \
	((*(_ah)->ah_reset_tx_queue)((_ah), (_q)))
#define	ath_hal_release_tx_queue(_ah, _q) \
	((*(_ah)->ah_release_tx_queue)((_ah), (_q)))
#define	ath_hal_has_veol(_ah) \
	((*(_ah)->ah_has_veol)((_ah)))
#define ath_hal_update_mib_counters(_ah, _stats) \
	((*(_ah)->ah_update_mib_counters)((_ah), (_stats)))
#define	ath_hal_get_rf_gain(_ah) \
	((*(_ah)->ah_get_rf_gain)((_ah)))
#define	ath_hal_set_rx_signal(_ah) \
	((*(_ah)->ah_set_rx_signal)((_ah)))

#define	ath_hal_setup_rx_desc(_ah, _ds, _size, _intreq) \
	((*(_ah)->ah_setup_rx_desc)((_ah), (_ds), (_size), (_intreq)))
#define	ath_hal_proc_rx_desc(_ah, _ds, _dspa, _dsnext) \
	((*(_ah)->ah_proc_rx_desc)((_ah), (_ds), (_dspa), (_dsnext)))
#define	ath_hal_setup_tx_desc(_ah, _ds, _plen, _hlen, _atype, _txpow, \
	    _txr0, _txtr0, _keyix, _ant, _flags, \
	    _rtsrate, _rtsdura) \
	((*(_ah)->ah_setup_tx_desc)((_ah), (_ds), (_plen), (_hlen), (_atype), \
	    (_txpow), (_txr0), (_txtr0), (_keyix), (_ant), \
	    (_flags), (_rtsrate), (_rtsdura)))
#define	ath_hal_setup_xtx_desc(_ah, _ds, \
	    _txr1, _txtr1, _txr2, _txtr2, _txr3, _txtr3) \
	((*(_ah)->ah_setup_xtx_desc)((_ah), (_ds), \
	    (_txr1), (_txtr1), (_txr2), (_txtr2), (_txr3), (_txtr3)))
#define	ath_hal_fill_tx_desc(_ah, _ds, _l, _first, _last) \
	((*(_ah)->ah_fill_tx_desc)((_ah), (_ds), (_l), (_first), (_last)))
#define	ath_hal_proc_tx_desc(_ah, _ds) \
	((*(_ah)->ah_proc_tx_desc)((_ah), (_ds)))

#endif /* _KERNEL */

#define	SIOCGATHSTATS	_IOWR('i', 137, struct ifreq)

#endif /* _DEV_ATH_ATHVAR_H */
@


1.31
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.30 2010/08/27 19:44:43 deraadt Exp $  */
a262 1
#ifndef __NetBSD__
a263 1
#endif
@


1.30
log
@Get rid of the clumsy pci_activate function and do this job inside ath.c
so that the powerhook wrapper can get at it
ok kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.29 2010/07/02 06:06:30 reyk Exp $  */
a309 1
	void			*sc_powerhook;	/* power management hook */
a409 1
void	ath_powerhook(int, void *);
@


1.29
log
@cleanup and remove some #ifdef junk in the power hooks.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.28 2009/10/13 19:33:16 pirofti Exp $  */
d410 2
a411 3
void	ath_resume(struct ath_softc *, int);
void	ath_suspend(struct ath_softc *, int);
void	ath_power(int, void *);
@


1.28
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.27 2009/08/10 20:29:54 deraadt Exp $  */
a411 2
#ifdef __NetBSD__
int	ath_activate(struct device *, int);
a412 1
#endif
@


1.27
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.26 2009/07/24 17:22:37 jsg Exp $  */
d413 1
a413 1
int	ath_activate(struct device *, enum devact);
@


1.26
log
@wrap the kernel specific parts in an _KERNEL ifdef.
ok reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.25 2008/08/29 11:15:32 reyk Exp $  */
a309 1
	void			*sc_sdhook;	/* shutdown hook */
a415 1
void	ath_shutdown(void *);
@


1.25
log
@add support for software crypto to allow WPA/WPA2/RSN.  it is disabled
for now because it needs more testing, but basic WPA/WPA2 and WEP
seems to work.  to enable it, set the compiled-in ath_softcrypto
variable to 1.

this is based on a previous diff from damien@@ with some changes to
disable the hardware crypto engine if softcrypto is enabled and to
keeps the hardware crypto code in place to allow later work on
hardware WPA/WPA2.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.24 2008/07/29 00:18:25 reyk Exp $  */
d44 2
a123 2
#define	SIOCGATHSTATS	_IOWR('i', 137, struct ifreq)

d559 4
@


1.24
log
@- fix FIFO overruns on PCI-E chipsets by setting the DMA size
RX/TX configuration registers to 128 instead of 512 bytes.
- add a few more MAC/RF id strings for the dmesg.
- check for PCI-E instead of single chip variants in a few places.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.23 2008/07/21 18:43:19 damien Exp $  */
d452 2
@


1.23
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.22 2008/06/14 02:28:14 jsing Exp $  */
d234 1
a234 1
				sc_64bit : 1;	/* indicates PCI Express */
@


1.22
log
@Allow ath(4) to detach cleanly when attaching via PCI. Also
complete/cleanup the attachment cleanup code.

ok reyk@@ jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.21 2008/06/13 07:31:57 jsg Exp $  */
d217 1
a217 1
				    int, int, u_int32_t);
@


1.21
log
@If you have #if FOO > 0 parts of your softc be
sure to #include "foo.h" in all code that uses the softc,
otherwise some object files will have a different idea of how
big the softc struct is.

This will result in things like part of the softc, say the interrupt
handler being overridden by other data.  Putting printfs in the
main object file will look fine as it has the right idea as to
what the size is.  It is only after several hours debugging
that you start to figure out what the hell is going on.

jsing started trying to figure out the problem and got hints
from kettenis that it likely wasn't an interrupt problem,
after quite a bit of head scratching with joel I eventually spotted
the problem.

ok reyk@@ jsing@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.20 2007/06/06 21:41:32 reyk Exp $  */
d223 1
@


1.20
log
@the copyright holder changed the license from "dual bsd/gpl" to be
2-clause bsd-only. good.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.19 2007/04/13 14:44:41 reyk Exp $  */
d46 2
@


1.19
log
@The integrated Atheros NICs found in IBM/Lenovo ThinkPads use the same
device ID for old AR5212-based 32bit and new AR5424-based 64bit (PCI
Express Mini Card) interfaces.  Use an extra check to look if the card
is 64bit and attach it as a single chip device.  This prevents a panic
when attaching the device on some laptops like the T60.

Tested on a T42 (old AR5212 Mini PCI interface),
Tested on a T60 (new AR5424 Mini Card interface)

Nevertheless, the AR5424 does not work yet.

Thanks to Stefan Konrath
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.18 2006/06/23 21:53:01 reyk Exp $  */
a20 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.18
log
@set the RSSI Max value in ath(4) and use the new RSSI radiotap header
instead of the old db signal header. also allow tcpdump and hostapd to
print the new RSSI radiotap header values current/max rssi.

ok damien@@ jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.17 2005/10/20 21:44:42 jmc Exp $  */
d234 2
a235 1
				sc_probing : 1;	/* probing AP on beacon miss */
@


1.17
log
@defintion -> definition;
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.16 2005/09/23 20:06:50 reyk Exp $  */
d134 1
a134 1
	(1 << IEEE80211_RADIOTAP_DB_ANTSIGNAL)	| \
d144 2
a145 1
	u_int8_t	wr_antsignal;
@


1.16
log
@cleanup and simplify the regulation domain handling. some devices are
known to have a broken/unsupported regulation domain stored in their
EEPROM, we use the default instead (Canada). there's no need to
manually define COUNTRYCODE in ar5xxx.c anymore for invalid EEPROMs
but it's still possible to force a specific country - your choice.

ok aanriot@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.15 2005/09/22 10:17:04 reyk Exp $  */
d43 1
a43 1
 * Defintions for the Atheros Wireless LAN controller driver.
d71 1
a71 1
 * Ioctl-related defintions for the Atheros Wireless LAN controller driver.
@


1.15
log
@remove the very basic ath(4) rate control implementation and use
rssadapt(9) instead. this may need some further work but now it's in
the right place and shared with other drivers (like ral(4)).

yes jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.14 2005/08/17 13:14:17 reyk Exp $  */
a493 2
#define	ath_hal_getcountrycode(_ah, _pcc) \
	(*(_pcc) = (_ah)->ah_getcountrycode)
@


1.14
log
@fix led states and knf. this also enables support for the software led
in some thinkpads - turn it on in the ASSOC and RUN states.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.13 2005/07/30 17:13:17 reyk Exp $  */
d171 6
a176 9
	struct ieee80211_node an_node;	/* base class */
	u_int		an_tx_ok;	/* tx ok pkt */
	u_int		an_tx_err;	/* tx !ok pkt */
	u_int		an_tx_retr;	/* tx retry count */
	int		an_tx_upper;	/* tx upper rate req cnt */
	u_int		an_tx_antenna;	/* antenna for last good frame */
	u_int		an_rx_antenna;	/* antenna for last rcvd frame */
	struct ath_recv_hist an_rx_hist[ATH_RHIST_SIZE];
	u_int		an_rx_hist_next;/* index of next ``free entry'' */
d181 11
a191 10
	TAILQ_ENTRY(ath_buf)	bf_list;
	bus_dmamap_t		bf_dmamap;	/* DMA map of the buffer */
#define bf_nseg			bf_dmamap->dm_nsegs
#define bf_mapsize		bf_dmamap->dm_mapsize
#define bf_segs			bf_dmamap->dm_segs
	struct ath_desc		*bf_desc;	/* virtual addr of desc */
	bus_addr_t		bf_daddr;	/* physical addr of desc */
	struct mbuf		*bf_m;		/* mbuf for buf */
	struct ieee80211_node	*bf_node;	/* pointer to the node */
#define	ATH_MAX_SCATTER		64
d300 1
@


1.13
log
@remove a useless timeout after tx (decrease nasty delays while
scanning) and fix various other minor things in the ath(4) driver.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.12 2005/05/28 23:45:10 reyk Exp $  */
d231 5
a235 5
	unsigned int		sc_invalid  : 1,/* disable hardware accesses */
				sc_doani    : 1,/* dynamic noise immunity */
				sc_has_veol  : 1,/* tx VEOL support */
				sc_probing  : 1;/* probing AP on beacon miss */
						/* rate tables */
@


1.12
log
@fix hostap mode
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.11 2005/05/28 00:46:46 robert Exp $  */
d153 1
d164 1
d278 1
a278 1
	u_int			sc_txhalq;	/* HAL q for outgoing frames */
a329 1
#define AR_DEBUG
d499 2
a500 1

@


1.11
log
@make sure to enable socket on resume.
in order for the enable to work disable the socket on suspend.

ok jsg@@, mickey@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.10 2005/05/27 09:53:55 reyk Exp $  */
d77 1
d305 1
d328 1
d418 1
d532 2
@


1.10
log
@re-enable gpio init even without using the gpio(4) framework
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.9 2005/05/27 04:10:06 reyk Exp $  */
d406 1
@


1.9
log
@- disable the gpio user interface for now, it's just an unimportant
button which is not yet available on non-i386 platforms
- fix endianess and attachement on big endian platforms (tested on
macppc - ath attaches correctly, receives frames but assoc still
fails)
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.8 2005/05/24 21:46:18 reyk Exp $  */
a312 1
#if NGPIO > 0
a314 1
#endif
@


1.8
log
@ath_hal_rx_monitor should be used for link state monitoring instead of
setting the promisc mode. rename it to ath_hal_rx_signal and remove
the incorrect promisc flag. this should fix some problems with ath
running in forwarding mode.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.7 2005/04/18 18:42:56 reyk Exp $  */
d51 1
d53 1
@


1.7
log
@beautify the code by renaming HAL functions with capitalized words (i
always wanted to do that). this breaks HAL compatibility but porting
should be easy, have a look at athvar.h. no functional changes.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.6 2005/03/11 17:45:28 reyk Exp $  */
d529 2
a530 2
#define	ath_hal_set_rx_monitor(_ah) \
	((*(_ah)->ah_set_rx_monitor)((_ah)))
@


1.6
log
@fix channel initialisation. thanks to simon slater.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.5 2005/03/03 16:39:54 reyk Exp $  */
d228 1
a228 1
				sc_hasveol  : 1,/* tx VEOL support */
d420 52
a471 52
#define	ath_hal_getratetable(_ah, _mode) \
	((*(_ah)->ah_getRateTable)((_ah), (_mode)))
#define	ath_hal_getmac(_ah, _mac) \
	((*(_ah)->ah_getMacAddress)((_ah), (_mac)))
#define	ath_hal_setmac(_ah, _mac) \
	((*(_ah)->ah_setMacAddress)((_ah), (_mac)))
#define	ath_hal_intrset(_ah, _mask) \
	((*(_ah)->ah_setInterrupts)((_ah), (_mask)))
#define	ath_hal_intrget(_ah) \
	((*(_ah)->ah_getInterrupts)((_ah)))
#define	ath_hal_intrpend(_ah) \
	((*(_ah)->ah_isInterruptPending)((_ah)))
#define	ath_hal_getisr(_ah, _pmask) \
	((*(_ah)->ah_getPendingInterrupts)((_ah), (_pmask)))
#define	ath_hal_updatetxtriglevel(_ah, _inc) \
	((*(_ah)->ah_updateTxTrigLevel)((_ah), (_inc)))
#define	ath_hal_setpower(_ah, _mode, _sleepduration) \
	((*(_ah)->ah_setPowerMode)((_ah), (_mode), AH_TRUE, (_sleepduration)))
#define	ath_hal_keyreset(_ah, _ix) \
	((*(_ah)->ah_resetKeyCacheEntry)((_ah), (_ix)))
#define	ath_hal_keyset(_ah, _ix, _pk) \
	((*(_ah)->ah_setKeyCacheEntry)((_ah), (_ix), (_pk), NULL, AH_FALSE))
#define	ath_hal_keyisvalid(_ah, _ix) \
	(((*(_ah)->ah_isKeyCacheEntryValid)((_ah), (_ix))))
#define	ath_hal_keysetmac(_ah, _ix, _mac) \
	((*(_ah)->ah_setKeyCacheEntryMac)((_ah), (_ix), (_mac)))
#define	ath_hal_getrxfilter(_ah) \
	((*(_ah)->ah_getRxFilter)((_ah)))
#define	ath_hal_setrxfilter(_ah, _filter) \
	((*(_ah)->ah_setRxFilter)((_ah), (_filter)))
#define	ath_hal_setmcastfilter(_ah, _mfilt0, _mfilt1) \
	((*(_ah)->ah_setMulticastFilter)((_ah), (_mfilt0), (_mfilt1)))
#define	ath_hal_waitforbeacon(_ah, _bf) \
	((*(_ah)->ah_waitForBeaconDone)((_ah), (_bf)->bf_daddr))
#define	ath_hal_putrxbuf(_ah, _bufaddr) \
	((*(_ah)->ah_setRxDP)((_ah), (_bufaddr)))
#define	ath_hal_gettsf32(_ah) \
	((*(_ah)->ah_getTsf32)((_ah)))
#define	ath_hal_gettsf64(_ah) \
	((*(_ah)->ah_getTsf64)((_ah)))
#define	ath_hal_resettsf(_ah) \
	((*(_ah)->ah_resetTsf)((_ah)))
#define	ath_hal_rxena(_ah) \
	((*(_ah)->ah_enableReceive)((_ah)))
#define	ath_hal_puttxbuf(_ah, _q, _bufaddr) \
	((*(_ah)->ah_setTxDP)((_ah), (_q), (_bufaddr)))
#define	ath_hal_gettxbuf(_ah, _q) \
	((*(_ah)->ah_getTxDP)((_ah), (_q)))
#define	ath_hal_getrxbuf(_ah) \
	((*(_ah)->ah_getRxDP)((_ah)))
#define	ath_hal_txstart(_ah, _q) \
	((*(_ah)->ah_startTxDma)((_ah), (_q)))
d473 1
a473 1
	((*(_ah)->ah_setChannel)((_ah), (_chan)))
d475 9
a483 9
	((*(_ah)->ah_perCalibration)((_ah), (_chan)))
#define	ath_hal_setledstate(_ah, _state) \
	((*(_ah)->ah_setLedState)((_ah), (_state)))
#define	ath_hal_beaconinit(_ah, _nextb, _bperiod) \
	((*(_ah)->ah_beaconInit)((_ah), (_nextb), (_bperiod)))
#define	ath_hal_beaconreset(_ah) \
	((*(_ah)->ah_resetStationBeaconTimers)((_ah)))
#define	ath_hal_beacontimers(_ah, _bs, _tsf, _dc, _cc) \
	((*(_ah)->ah_setStationBeaconTimers)((_ah), (_bs), (_tsf), \
d485 4
a488 4
#define	ath_hal_setassocid(_ah, _bss, _associd) \
	((*(_ah)->ah_writeAssocid)((_ah), (_bss), (_associd), 0))
#define	ath_hal_getregdomain(_ah, _prd) \
	(*(_prd) = (_ah)->ah_getRegDomain(_ah))
d490 1
a490 1
	(*(_pcc) = (_ah)->ah_countryCode)
d494 23
a516 23
#define ath_hal_gpiocfgoutput(_ah, _gpio) \
	((*(_ah)->ah_gpioCfgOutput)((_ah), (_gpio)))
#define ath_hal_gpiocfginput(_ah, _gpio) \
	((*(_ah)->ah_gpioCfgInput)((_ah), (_gpio)))
#define ath_hal_gpioget(_ah, _gpio) \
	((*(_ah)->ah_gpioGet)((_ah), (_gpio)))
#define ath_hal_gpioset(_ah, _gpio, _b) \
	((*(_ah)->ah_gpioSet)((_ah), (_gpio), (_b)))
#define ath_hal_gpiosetintr(_ah, _gpio, _b) \
	((*(_ah)->ah_gpioSetIntr)((_ah), (_gpio), (_b)))

#define	ath_hal_setopmode(_ah) \
	((*(_ah)->ah_setPCUConfig)((_ah)))
#define	ath_hal_stoptxdma(_ah, _qnum) \
	((*(_ah)->ah_stopTxDma)((_ah), (_qnum)))
#define	ath_hal_stoppcurecv(_ah) \
	((*(_ah)->ah_stopPcuReceive)((_ah)))
#define	ath_hal_startpcurecv(_ah) \
	((*(_ah)->ah_startPcuReceive)((_ah)))
#define	ath_hal_stopdmarecv(_ah) \
	((*(_ah)->ah_stopDmaReceive)((_ah)))
#define	ath_hal_getdiagstate(_ah, _id, _indata, _insize, _outdata, _outsize) \
	((*(_ah)->ah_getDiagState)((_ah), (_id), \
d519 18
a536 18
#define	ath_hal_setuptxqueue(_ah, _type, _qinfo) \
	((*(_ah)->ah_setupTxQueue)((_ah), (_type), (_qinfo)))
#define	ath_hal_resettxqueue(_ah, _q) \
	((*(_ah)->ah_resetTxQueue)((_ah), (_q)))
#define	ath_hal_releasetxqueue(_ah, _q) \
	((*(_ah)->ah_releaseTxQueue)((_ah), (_q)))
#define	ath_hal_hasveol(_ah) \
	((*(_ah)->ah_hasVEOL)((_ah)))
#define	ath_hal_getrfgain(_ah) \
	((*(_ah)->ah_getRfGain)((_ah)))
#define	ath_hal_rxmonitor(_ah) \
	((*(_ah)->ah_rxMonitor)((_ah)))

#define	ath_hal_setuprxdesc(_ah, _ds, _size, _intreq) \
	((*(_ah)->ah_setupRxDesc)((_ah), (_ds), (_size), (_intreq)))
#define	ath_hal_rxprocdesc(_ah, _ds, _dspa, _dsnext) \
	((*(_ah)->ah_procRxDesc)((_ah), (_ds), (_dspa), (_dsnext)))
#define	ath_hal_setuptxdesc(_ah, _ds, _plen, _hlen, _atype, _txpow, \
d539 1
a539 1
	((*(_ah)->ah_setupTxDesc)((_ah), (_ds), (_plen), (_hlen), (_atype), \
d542 1
a542 1
#define	ath_hal_setupxtxdesc(_ah, _ds, \
d544 1
a544 1
	((*(_ah)->ah_setupXTxDesc)((_ah), (_ds), \
d546 4
a549 4
#define	ath_hal_filltxdesc(_ah, _ds, _l, _first, _last) \
	((*(_ah)->ah_fillTxDesc)((_ah), (_ds), (_l), (_first), (_last)))
#define	ath_hal_txprocdesc(_ah, _ds) \
	((*(_ah)->ah_procTxDesc)((_ah), (_ds)))
@


1.5
log
@improve radiotap support, fix some minor bugs.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.4 2005/02/17 21:02:24 reyk Exp $  */
d231 1
@


1.4
log
@mostly cosmetic changes: knf, get rid of unneeded sysctls, cleanup the
code.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.3 2004/12/18 03:40:59 reyk Exp $  */
d136 1
a136 1
	u_int8_t	wr_flags;		/* XXX for padding */
d142 1
a142 1
};
d154 1
a154 1
	u_int8_t	wt_flags;		/* XXX for padding */
d160 1
a160 1
};
d238 1
a238 3
#ifdef __FreeBSD__
	struct bpf_if		*sc_drvbpf;
#else
d240 1
a240 1
#endif
d242 6
a247 4
		struct ath_tx_radiotap_header th;
		u_int8_t	pad[64];
	} u_tx_rt;
	int			sc_tx_th_len;
d249 6
a254 4
		struct ath_rx_radiotap_header th;
		u_int8_t	pad[64];
	} u_rx_rt;
	int			sc_rx_th_len;
a365 3

#define	sc_tx_th		u_tx_rt.th
#define	sc_rx_th		u_rx_rt.th
@


1.3
log
@use tick instead of ticks. thanks to hannes at mehnert dot org.
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.2 2004/11/23 09:39:29 reyk Exp $  */
a48 1

a122 16
struct ath_diag {
	char	ad_name[IFNAMSIZ];	/* if name, e.g. "ath0" */
	u_int16_t ad_id;
#define	ATH_DIAG_DYN	0x8000		/* allocate buffer in caller */
#define	ATH_DIAG_IN	0x4000		/* copy in parameters */
#define	ATH_DIAG_OUT	0x0000		/* copy out results (always) */
#define	ATH_DIAG_ID	0x0fff
	u_int16_t ad_in_size;		/* pack to fit, yech */
	caddr_t	ad_in_data;
	caddr_t	ad_out_data;
	u_int	ad_out_size;

};

#define	SIOCGATHDIAG	_IOWR('i', 138, struct ath_diag)

d181 3
a183 9
#ifdef __FreeBSD__
	int			bf_nseg;
	bus_dma_segment_t	bf_segs[ATH_MAX_SCATTER];
	bus_size_t		bf_mapsize;
#else
#define bf_nseg		bf_dmamap->dm_nsegs
#define bf_mapsize	bf_dmamap->dm_mapsize
#define bf_segs		bf_dmamap->dm_segs
#endif
d208 1
a208 1
	void 			(*sc_node_free)(struct ieee80211com *,
d228 1
d290 4
a293 4
	struct timeval		sc_last_ch;	
	struct timeout		sc_cal_to;	
	struct timeval		sc_last_beacon;	
        struct timeout		sc_scan_to;
d306 1
a306 1
        u_int8_t                sc_broadcast_addr[IEEE80211_ADDR_LEN];
d314 36
a349 1

a411 4
#ifdef __FreeBSD__
void	ath_shutdown(struct ath_softc *);
void	ath_intr(void *);
#else
a413 1
#endif
d484 1
a484 1
		(_dc), (_cc)))
d495 1
a495 1
        ((*(_ah)->ah_gpioCfgOutput)((_ah), (_gpio)))
d497 1
a497 1
        ((*(_ah)->ah_gpioCfgInput)((_ah), (_gpio)))
d499 1
a499 1
        ((*(_ah)->ah_gpioGet)((_ah), (_gpio)))
d501 1
a501 1
        ((*(_ah)->ah_gpioSet)((_ah), (_gpio), (_b)))
d503 1
a503 1
        ((*(_ah)->ah_gpioSetIntr)((_ah), (_gpio), (_b)))
d517 1
a517 1
		(_indata), (_insize), (_outdata), (_outsize)))
d537 2
a538 2
		_txr0, _txtr0, _keyix, _ant, _flags, \
		_rtsrate, _rtsdura) \
d540 2
a541 2
		(_txpow), (_txr0), (_txtr0), (_keyix), (_ant), \
		(_flags), (_rtsrate), (_rtsdura)))
d543 1
a543 1
		_txr1, _txtr1, _txr2, _txtr2, _txr3, _txtr3) \
d545 1
a545 1
		(_txr1), (_txtr1), (_txr2), (_txtr2), (_txr3), (_txtr3)))
@


1.2
log
@support the gpio found on ath(4) devices.
ok grange@@
@
text
@d1 1
a1 1
/*      $OpenBSD: athvar.h,v 1.1 2004/11/02 02:45:37 reyk Exp $  */
d380 1
a380 1
#define ATH_TICKS() (ticks)
@


1.1
log
@imported Sam Leffler's ath driver for atheros multimode wireless nics
from NetBSD and FreeBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD$  */
d52 2
d59 1
d329 5
d336 2
d347 1
d392 1
a392 1
int	ath_detach(struct ath_softc *);
d486 1
a486 2
#ifdef SOFTLED
#define ath_hal_gpioCfgOutput(_ah, _gpio) \
d488 1
a488 1
#define ath_hal_gpioCfgInput(_ah, _gpio) \
d490 1
a490 1
#define ath_hal_gpioGet(_ah, _gpio) \
d492 1
a492 1
#define ath_hal_gpioSet(_ah, _gpio, _b) \
d494 2
a495 3
#define ath_hal_gpioSetIntr(_ah, _gpioSel, _b) \
        ((*(_ah)->ah_gpioSetIntr)((_ah), (_sel), (_b)))
#endif
@

