head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.9.0.12
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2017.08.21.21.43.46;	author jmatthew;	state Exp;
branches;
next	1.9;
commitid	gbJGSjN8i9iU7KFP;

1.9
date	2014.12.03.04.33.06;	author jsg;	state Exp;
branches;
next	1.8;
commitid	i5Lgbixkn1sRpeFj;

1.8
date	2014.04.14.04.42.22;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2014.03.31.06.58.10;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.31.04.46.59;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2014.03.31.03.38.46;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2014.03.31.00.19.30;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2014.01.02.08.00.35;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2013.07.09.11.55.55;	author jmatthew;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.21.11.17.48;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Split up ahci_port_portreset into a few smaller bits, and also slightly
adjust port multiplier detection so it doesn't call ahci_port_portreset
again directly, but instead restarts the loop for the current call.

During attach, poll for device detection across all ports until either all
ports have detected a device, or one second has passed, rather than doing
them sequentially.  Devices are still attached in order of port number,
so disk unit numbers won't change.

ok visa@@
@
text
@/*	$OpenBSD: ahcivar.h,v 1.9 2014/12/03 04:33:06 jsg Exp $ */

/*
 * Copyright (c) 2006 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2010 Conformal Systems LLC <info@@conformal.com>
 * Copyright (c) 2010 Jonathan Matthew <jonathan@@d14n.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/timeout.h>
#include <dev/ata/atascsi.h>
#include <dev/ata/pmreg.h>

/* change to AHCI_DEBUG for dmesg spam */
#define NO_AHCI_DEBUG

struct ahci_dmamem {
	bus_dmamap_t		adm_map;
	bus_dma_segment_t	adm_seg;
	size_t			adm_size;
	caddr_t			adm_kva;
};
#define AHCI_DMA_MAP(_adm)	((_adm)->adm_map)
#define AHCI_DMA_DVA(_adm)	((u_int64_t)(_adm)->adm_map->dm_segs[0].ds_addr)
#define AHCI_DMA_KVA(_adm)	((void *)(_adm)->adm_kva)

struct ahci_softc;
struct ahci_port;

struct ahci_ccb {
	/* ATA xfer associated with this CCB.  Must be 1st struct member. */
	struct ata_xfer		ccb_xa;

	int			ccb_slot;
	struct ahci_port	*ccb_port;

	bus_dmamap_t		ccb_dmamap;
	struct ahci_cmd_hdr	*ccb_cmd_hdr;
	struct ahci_cmd_table	*ccb_cmd_table;

	void			(*ccb_done)(struct ahci_ccb *);

	TAILQ_ENTRY(ahci_ccb)	ccb_entry;
};

struct ahci_port {
	struct ahci_softc	*ap_sc;
	bus_space_handle_t	ap_ioh;

#ifdef AHCI_COALESCE
	int			ap_num;
#endif

	struct ahci_rfis	*ap_rfis;
	struct ahci_dmamem	*ap_dmamem_rfis;

	struct ahci_dmamem	*ap_dmamem_cmd_list;
	struct ahci_dmamem	*ap_dmamem_cmd_table;

	volatile u_int32_t	ap_active;
	volatile u_int32_t	ap_active_cnt;
	volatile u_int32_t	ap_sactive;
	volatile u_int32_t	ap_pmp_ncq_port;
	struct ahci_ccb		*ap_ccbs;

	TAILQ_HEAD(, ahci_ccb)	ap_ccb_free;
	TAILQ_HEAD(, ahci_ccb)	ap_ccb_pending;
	struct mutex		ap_ccb_mtx;
	struct ahci_ccb		*ap_ccb_err;

	u_int32_t		ap_state;
#define AP_S_NORMAL			0
#define AP_S_PMP_PROBE			1
#define AP_S_PMP_PORT_PROBE		2
#define AP_S_ERROR_RECOVERY		3
#define AP_S_FATAL_ERROR		4

	int			ap_pmp_ports;
	int			ap_port;
	int			ap_pmp_ignore_ifs;

	/* For error recovery. */
#ifdef DIAGNOSTIC
	int			ap_err_busy;
#endif
	u_int32_t		ap_err_saved_sactive;
	u_int32_t		ap_err_saved_active;
	u_int32_t		ap_err_saved_active_cnt;
	u_int32_t		ap_saved_cmd;

	u_int8_t		*ap_err_scratch;

#ifdef AHCI_DEBUG
	char			ap_name[16];
#define PORTNAME(_ap)	((_ap)->ap_name)
#else
#define PORTNAME(_ap)	DEVNAME((_ap)->ap_sc)
#endif
};

struct ahci_softc {
	struct device		sc_dev;

	void			*sc_ih;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	bus_dma_tag_t		sc_dmat;

	int			sc_flags;
#define AHCI_F_NO_NCQ			(1<<0)
#define AHCI_F_IPMS_PROBE		(1<<1)	/* IPMS on failed PMP probe */
#define AHCI_F_NO_PMP			(1<<2)	/* ignore PMP capability */
#define AHCI_F_NO_MSI			(1<<3)	/* disable MSI */

	u_int			sc_ncmds;

	struct ahci_port	*sc_ports[AHCI_MAX_PORTS];

	struct atascsi		*sc_atascsi;

	u_int32_t		sc_cap;

#ifdef AHCI_COALESCE
	u_int32_t		sc_ccc_mask;
	u_int32_t		sc_ccc_ports;
	u_int32_t		sc_ccc_ports_cur;
#endif

	int			(*sc_port_start)(struct ahci_port *, int);
};

#define DEVNAME(_s)		((_s)->sc_dev.dv_xname)
#define ahci_port_start(_p, _f)	((_p)->ap_sc->sc_port_start((_p), (_f)))

int			ahci_attach(struct ahci_softc *);
int			ahci_detach(struct ahci_softc *, int);
int			ahci_activate(struct device *, int);

int			ahci_intr(void *);
@


1.9
log
@Turn ahci port start into a callback so sxiahci can do some magic to
setup dma.  Modified version of a patch from Edwin Amsler which was
based on changes made in Bitrig by Artturi Alm.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahcivar.h,v 1.8 2014/04/14 04:42:22 dlg Exp $ */
d100 1
@


1.8
log
@move the hardware structures into ahcireg.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahcivar.h,v 1.7 2014/03/31 06:58:10 dlg Exp $ */
d140 2
d145 1
@


1.7
log
@the hardware expects ahci_cmd_table to be 128 byte aligned
@
text
@d1 1
a1 1
/*	$OpenBSD: ahcivar.h,v 1.6 2014/03/31 04:46:59 dlg Exp $ */
a26 52

struct ahci_cmd_hdr {
	u_int16_t		flags;
#define AHCI_CMD_LIST_FLAG_CFL		0x001f /* Command FIS Length */
#define AHCI_CMD_LIST_FLAG_A		(1<<5) /* ATAPI */
#define AHCI_CMD_LIST_FLAG_W		(1<<6) /* Write */
#define AHCI_CMD_LIST_FLAG_P		(1<<7) /* Prefetchable */
#define AHCI_CMD_LIST_FLAG_R		(1<<8) /* Reset */
#define AHCI_CMD_LIST_FLAG_B		(1<<9) /* BIST */
#define AHCI_CMD_LIST_FLAG_C		(1<<10) /* Clear Busy upon R_OK */
#define AHCI_CMD_LIST_FLAG_PMP		0xf000 /* Port Multiplier Port */
#define AHCI_CMD_LIST_FLAG_PMP_SHIFT	12
	u_int16_t		prdtl; /* sgl len */

	u_int32_t		prdbc; /* transferred byte count */

	u_int64_t		ctba;

	u_int32_t		reserved[4];
} __packed __aligned(8);

struct ahci_rfis {
	u_int8_t		dsfis[28];
	u_int8_t		reserved1[4];
	u_int8_t		psfis[24];
	u_int8_t		reserved2[8];
	u_int8_t		rfis[24];
	u_int8_t		reserved3[4];
	u_int8_t		sdbfis[4];
	u_int8_t		ufis[64];
	u_int8_t		reserved4[96];
} __packed;

struct ahci_prdt {
	u_int64_t		dba;
	u_int32_t		reserved;
	u_int32_t		flags;
#define AHCI_PRDT_FLAG_INTR		(1<<31) /* interrupt on completion */
} __packed __aligned(8);

/* this makes ahci_cmd_table 512 bytes, supporting 128-byte alignment */
#define AHCI_MAX_PRDT		24

struct ahci_cmd_table {
	u_int8_t		cfis[64];	/* Command FIS */
	u_int8_t		acmd[16];	/* ATAPI Command */
	u_int8_t		reserved[48];

	struct ahci_prdt	prdt[AHCI_MAX_PRDT];
} __packed __aligned(128);

#define AHCI_MAX_PORTS		32
@


1.6
log
@ahci dva things are 64bit and surprisingly aligned nicely to 64bit too.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahcivar.h,v 1.4 2014/03/31 00:19:30 dlg Exp $ */
d76 1
a76 1
} __packed;
@


1.5
log
@massage the prdt (what an sgl is on every other chip) loading with
better ops and alignment.

ok jmatthew@@ who was cruel and made me test hibernate before he oked it.
@
text
@d43 1
a43 2
	u_int32_t		ctba_lo;
	u_int32_t		ctba_hi;
d46 1
a46 1
} __packed;
@


1.4
log
@dva on ahci is 64bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ahcivar.h,v 1.3 2014/01/02 08:00:35 gilles Exp $ */
d62 1
a62 2
	u_int32_t		dba_lo;
	u_int32_t		dba_hi;
d66 1
a66 1
} __packed;
@


1.3
log
@disable MSI for Samsung XP941.
This is so I can use the machine to figure out the others things on it,
the quirk will go away when interrupt routing gets fixed.

ok dlg@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahcivar.h,v 1.2 2013/07/09 11:55:55 jmatthew Exp $ */
d89 1
a89 1
#define AHCI_DMA_DVA(_adm)	((_adm)->adm_map->dm_segs[0].ds_addr)
@


1.2
log
@move AHCI_DEBUG stuff into ahci.c so we can build with it enabled again

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahcivar.h,v 1.1 2013/01/21 11:17:48 patrick Exp $ */
d179 1
@


1.1
log
@Split AHCI in order to support devices which are not attached via pci.
Tested on a few machines, including JMicron and Intel AHCIs.

ok dlg@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.194 2012/10/08 21:47:50 deraadt Exp $ */
a26 12

#ifdef AHCI_DEBUG
#define DPRINTF(m, f...) do { if ((ahcidebug & (m)) == (m)) printf(f); } \
    while (0)
#define AHCI_D_TIMEOUT		0x00
#define AHCI_D_VERBOSE		0x01
#define AHCI_D_INTR		0x02
#define AHCI_D_XFER		0x08
int ahcidebug = AHCI_D_VERBOSE;
#else
#define DPRINTF(m, f...)
#endif
@

