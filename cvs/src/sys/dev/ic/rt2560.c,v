head	1.83;
access;
symbols
	OPENBSD_6_2:1.83.0.4
	OPENBSD_6_2_BASE:1.83
	OPENBSD_6_1:1.82.0.4
	OPENBSD_6_1_BASE:1.82
	OPENBSD_6_0:1.80.0.4
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.79.0.2
	OPENBSD_5_9_BASE:1.79
	OPENBSD_5_8:1.71.0.4
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.70.0.2
	OPENBSD_5_7_BASE:1.70
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.62.0.4
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.60.0.6
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.60.0.4
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.60.0.2
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.8
	OPENBSD_5_0:1.58.0.4
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.58.0.2
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.43.0.4
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12;
locks; strict;
comment	@ * @;


1.83
date	2017.07.03.09.21.09;	author kevlo;	state Exp;
branches;
next	1.82;
commitid	Ssa221KhuyTS2oq4;

1.82
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.81;
commitid	VyLWTsbepAOk7VQM;

1.81
date	2016.10.06.15.18.48;	author stsp;	state Exp;
branches;
next	1.80;
commitid	YZrqUqZ787MJqaKL;

1.80
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.79;
commitid	QHiEhS9DHyE6oiIr;

1.79
date	2015.12.05.12.13.55;	author dlg;	state Exp;
branches;
next	1.78;
commitid	UEqM5OF20KRbAVEL;

1.78
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.77;
commitid	B0kwmVGiD5DVx4kv;

1.77
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.76;
commitid	5DvsamK0GblTp8ww;

1.76
date	2015.11.20.12.41.29;	author mpi;	state Exp;
branches;
next	1.75;
commitid	be9Ys4hrOFYlfa34;

1.75
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.74;
commitid	eYnPulzvLjDImPCa;

1.74
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.73;
commitid	YT6fyIEviv9qwbl6;

1.73
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.72;
commitid	p0v5tuE1Ch6fY0Nj;

1.72
date	2015.09.09.19.26.05;	author deraadt;	state Exp;
branches;
next	1.71;
commitid	XlGeAMTUDUJVt1tj;

1.71
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.70;
commitid	p4LJxGKbi0BU2cG6;

1.70
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.69;
commitid	Hly9lJn6CNMylcFu;

1.69
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.68;
commitid	yM2VFFhpDTeFQlve;

1.68
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.67;
commitid	LS2TNeCue5R9L67C;

1.67
date	2014.09.06.05.41.35;	author jsg;	state Exp;
branches;
next	1.66;
commitid	TZ6gfz2Iz0CRv2Rz;

1.66
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.65;
commitid	TGHgrLxu6sxZoiFt;

1.65
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	JtO5uXxVcnZfhUkR;

1.64
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.63;
commitid	I19imNlAX05zJOED;

1.63
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2013.08.07.01.06.30;	author bluhm;	state Exp;
branches;
next	1.60;

1.60
date	2012.07.13.10.08.15;	author stsp;	state Exp;
branches;
next	1.59;

1.59
date	2012.07.13.07.48.31;	author stsp;	state Exp;
branches;
next	1.58;

1.58
date	2011.02.22.20.05.03;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2010.09.06.19.20.21;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.06.18.22.00;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2010.08.28.18.08.07;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2010.08.27.16.06.25;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2010.08.27.04.09.18;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2010.08.25.21.37.59;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2010.08.04.19.48.33;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.01.12.08.36;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.10.17.47.23;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2009.07.29.17.46.31;	author blambert;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.22.18.20.47;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.21.18.19.58;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.25.21.43.57;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.14.16.02.24;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.17.14.29.11;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.15.01.37.49;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.08.21.58.27;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.24.17.56.24;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.03.18.16.43;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2006.12.17.16.24.00;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.03.16.39.13;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.26.11.14.18;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.22.20.54.56;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.13.20.06.38;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.22.12.14.44;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2006.09.18.16.20.20;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.18.16.40.30;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.18.18.44.04;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.18.12.32.46;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.14.19.31.47;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.10.20.30.00;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.02.04.30.40;	author robert;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.01.16.52.54;	author robert;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.27.20.54.15;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.25.13.02.10;	author damien;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2006.02.18.09.41.41;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.14.12.43.27;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.14.08.50.38;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.13.21.06.09;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.13.17.48.22;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.11.21.02.17;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.10.21.20.46;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.10.17.47.15;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.10.17.45.06;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.10.17.40.29;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.09.20.03.34;	author damien;	state Exp;
branches;
next	;

1.12.2.1
date	2006.05.03.03.43.49;	author brad;	state Exp;
branches;
next	;


desc
@@


1.83
log
@Replace slot time durations with macros.

ok stsp@@
@
text
@/*	$OpenBSD: rt2560.c,v 1.82 2017/01/22 10:17:38 dlg Exp $  */

/*-
 * Copyright (c) 2005, 2006
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Ralink Technology RT2560 chipset driver
 * http://www.ralinktech.com/
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/rt2560reg.h>
#include <dev/ic/rt2560var.h>

#ifdef RAL_DEBUG
#define DPRINTF(x)	do { if (rt2560_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (rt2560_debug >= (n)) printf x; } while (0)
int rt2560_debug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

int		rt2560_alloc_tx_ring(struct rt2560_softc *,
		    struct rt2560_tx_ring *, int);
void		rt2560_reset_tx_ring(struct rt2560_softc *,
		    struct rt2560_tx_ring *);
void		rt2560_free_tx_ring(struct rt2560_softc *,
		    struct rt2560_tx_ring *);
int		rt2560_alloc_rx_ring(struct rt2560_softc *,
		    struct rt2560_rx_ring *, int);
void		rt2560_reset_rx_ring(struct rt2560_softc *,
		    struct rt2560_rx_ring *);
void		rt2560_free_rx_ring(struct rt2560_softc *,
		    struct rt2560_rx_ring *);
struct		ieee80211_node *rt2560_node_alloc(struct ieee80211com *);
int		rt2560_media_change(struct ifnet *);
void		rt2560_next_scan(void *);
void		rt2560_iter_func(void *, struct ieee80211_node *);
void		rt2560_amrr_timeout(void *);
void		rt2560_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
int		rt2560_newstate(struct ieee80211com *, enum ieee80211_state,
		    int);
uint16_t	rt2560_eeprom_read(struct rt2560_softc *, uint8_t);
void		rt2560_encryption_intr(struct rt2560_softc *);
void		rt2560_tx_intr(struct rt2560_softc *);
void		rt2560_prio_intr(struct rt2560_softc *);
void		rt2560_decryption_intr(struct rt2560_softc *);
void		rt2560_rx_intr(struct rt2560_softc *);
#ifndef IEEE80211_STA_ONLY
void		rt2560_beacon_expire(struct rt2560_softc *);
#endif
void		rt2560_wakeup_expire(struct rt2560_softc *);
#if NBPFILTER > 0
uint8_t		rt2560_rxrate(const struct rt2560_rx_desc *);
#endif
int		rt2560_ack_rate(struct ieee80211com *, int);
uint16_t	rt2560_txtime(int, int, uint32_t);
uint8_t		rt2560_plcp_signal(int);
void		rt2560_setup_tx_desc(struct rt2560_softc *,
		    struct rt2560_tx_desc *, uint32_t, int, int, int,
		    bus_addr_t);
#ifndef IEEE80211_STA_ONLY
int		rt2560_tx_bcn(struct rt2560_softc *, struct mbuf *,
		    struct ieee80211_node *);
#endif
int		rt2560_tx_mgt(struct rt2560_softc *, struct mbuf *,
		    struct ieee80211_node *);
int		rt2560_tx_data(struct rt2560_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		rt2560_start(struct ifnet *);
void		rt2560_watchdog(struct ifnet *);
int		rt2560_ioctl(struct ifnet *, u_long, caddr_t);
void		rt2560_bbp_write(struct rt2560_softc *, uint8_t, uint8_t);
uint8_t		rt2560_bbp_read(struct rt2560_softc *, uint8_t);
void		rt2560_rf_write(struct rt2560_softc *, uint8_t, uint32_t);
void		rt2560_set_chan(struct rt2560_softc *,
		    struct ieee80211_channel *);
void		rt2560_disable_rf_tune(struct rt2560_softc *);
void		rt2560_enable_tsf_sync(struct rt2560_softc *);
void		rt2560_update_plcp(struct rt2560_softc *);
void		rt2560_updateslot(struct ieee80211com *);
void		rt2560_set_slottime(struct rt2560_softc *);
void		rt2560_set_basicrates(struct rt2560_softc *);
void		rt2560_update_led(struct rt2560_softc *, int, int);
void		rt2560_set_bssid(struct rt2560_softc *, uint8_t *);
void		rt2560_set_macaddr(struct rt2560_softc *, uint8_t *);
void		rt2560_get_macaddr(struct rt2560_softc *, uint8_t *);
void		rt2560_update_promisc(struct rt2560_softc *);
void		rt2560_set_txantenna(struct rt2560_softc *, int);
void		rt2560_set_rxantenna(struct rt2560_softc *, int);
const char	*rt2560_get_rf(int);
void		rt2560_read_eeprom(struct rt2560_softc *);
int		rt2560_bbp_init(struct rt2560_softc *);
int		rt2560_init(struct ifnet *);
void		rt2560_stop(struct ifnet *, int);

static const struct {
	uint32_t	reg;
	uint32_t	val;
} rt2560_def_mac[] = {
	RT2560_DEF_MAC
};

static const struct {
	uint8_t	reg;
	uint8_t	val;
} rt2560_def_bbp[] = {
	RT2560_DEF_BBP
};

static const uint32_t rt2560_rf2522_r2[]    = RT2560_RF2522_R2;
static const uint32_t rt2560_rf2523_r2[]    = RT2560_RF2523_R2;
static const uint32_t rt2560_rf2524_r2[]    = RT2560_RF2524_R2;
static const uint32_t rt2560_rf2525_r2[]    = RT2560_RF2525_R2;
static const uint32_t rt2560_rf2525_hi_r2[] = RT2560_RF2525_HI_R2;
static const uint32_t rt2560_rf2525e_r2[]   = RT2560_RF2525E_R2;
static const uint32_t rt2560_rf2526_r2[]    = RT2560_RF2526_R2;
static const uint32_t rt2560_rf2526_hi_r2[] = RT2560_RF2526_HI_R2;

int
rt2560_attach(void *xsc, int id)
{
	struct rt2560_softc *sc = xsc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int error, i;

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 15;
	timeout_set(&sc->amrr_to, rt2560_amrr_timeout, sc);
	timeout_set(&sc->scan_to, rt2560_next_scan, sc);

	/* retrieve RT2560 rev. no */
	sc->asic_rev = RAL_READ(sc, RT2560_CSR0);

	/* retrieve MAC address */
	rt2560_get_macaddr(sc, ic->ic_myaddr);
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	/* retrieve RF rev. no and various other things from EEPROM */
	rt2560_read_eeprom(sc);

	printf("%s: MAC/BBP RT2560 (rev 0x%02x), RF %s\n", sc->sc_dev.dv_xname,
	    sc->asic_rev, rt2560_get_rf(sc->rf_rev));

	/*
	 * Allocate Tx and Rx rings.
	 */
	error = rt2560_alloc_tx_ring(sc, &sc->txq, RT2560_TX_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Tx ring\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}
	error = rt2560_alloc_tx_ring(sc, &sc->atimq, RT2560_ATIM_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate ATIM ring\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}
	error = rt2560_alloc_tx_ring(sc, &sc->prioq, RT2560_PRIO_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Prio ring\n",
		    sc->sc_dev.dv_xname);
		goto fail3;
	}
	error = rt2560_alloc_tx_ring(sc, &sc->bcnq, RT2560_BEACON_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Beacon ring\n",
		    sc->sc_dev.dv_xname);
		goto fail4;
	}
	error = rt2560_alloc_rx_ring(sc, &sc->rxq, RT2560_RX_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Rx ring\n",
		    sc->sc_dev.dv_xname);
		goto fail5;
	}

	ic->ic_phytype = IEEE80211_T_OFDM; /* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA; /* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
#ifndef IEEE80211_STA_ONLY
	    IEEE80211_C_IBSS |		/* IBSS mode supported */
	    IEEE80211_C_HOSTAP |	/* HostAp mode supported */
#endif
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_WEP |		/* s/w WEP */
	    IEEE80211_C_RSN;		/* WPA/RSN */

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = rt2560_ioctl;
	ifp->if_start = rt2560_start;
	ifp->if_watchdog = rt2560_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_node_alloc = rt2560_node_alloc;
	ic->ic_newassoc = rt2560_newassoc;
	ic->ic_updateslot = rt2560_updateslot;

	/* XXX RTS causes throughput problems -- where is the bug? */
	ic->ic_rtsthreshold = IEEE80211_RTS_MAX;

	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = rt2560_newstate;
	ieee80211_media_init(ifp, rt2560_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + 64);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(RT2560_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(RT2560_TX_RADIOTAP_PRESENT);
#endif
	return 0;

fail5:	rt2560_free_tx_ring(sc, &sc->bcnq);
fail4:	rt2560_free_tx_ring(sc, &sc->prioq);
fail3:	rt2560_free_tx_ring(sc, &sc->atimq);
fail2:	rt2560_free_tx_ring(sc, &sc->txq);
fail1:	return ENXIO;
}

int
rt2560_detach(void *xsc)
{
	struct rt2560_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);

	ieee80211_ifdetach(ifp);	/* free all nodes */
	if_detach(ifp);

	rt2560_free_tx_ring(sc, &sc->txq);
	rt2560_free_tx_ring(sc, &sc->atimq);
	rt2560_free_tx_ring(sc, &sc->prioq);
	rt2560_free_tx_ring(sc, &sc->bcnq);
	rt2560_free_rx_ring(sc, &sc->rxq);

	return 0;
}

void
rt2560_suspend(void *xsc)
{
	struct rt2560_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (ifp->if_flags & IFF_RUNNING)
		rt2560_stop(ifp, 1);
}

void
rt2560_wakeup(void *xsc)
{
	struct rt2560_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (ifp->if_flags & IFF_UP)
		rt2560_init(ifp);
}

int
rt2560_alloc_tx_ring(struct rt2560_softc *sc, struct rt2560_tx_ring *ring,
    int count)
{
	int i, nsegs, error;

	ring->count = count;
	ring->queued = 0;
	ring->cur = ring->next = 0;
	ring->cur_encrypt = ring->next_encrypt = 0;

	error = bus_dmamap_create(sc->sc_dmat, count * RT2560_TX_DESC_SIZE, 1,
	    count * RT2560_TX_DESC_SIZE, 0, BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, count * RT2560_TX_DESC_SIZE,
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    count * RT2560_TX_DESC_SIZE, (caddr_t *)&ring->desc,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    count * RT2560_TX_DESC_SIZE, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ring->physaddr = ring->map->dm_segs->ds_addr;

	ring->data = mallocarray(count, sizeof (struct rt2560_tx_data),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ring->data == NULL) {
		printf("%s: could not allocate soft data\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}

	for (i = 0; i < count; i++) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    RT2560_MAX_SCATTER, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &ring->data[i].map);
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	return 0;

fail:	rt2560_free_tx_ring(sc, ring);
	return error;
}

void
rt2560_reset_tx_ring(struct rt2560_softc *sc, struct rt2560_tx_ring *ring)
{
	int i;

	for (i = 0; i < ring->count; i++) {
		struct rt2560_tx_desc *desc = &ring->desc[i];
		struct rt2560_tx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}

		/*
		 * The node has already been freed at that point so don't call
		 * ieee80211_release_node() here.
		 */
		data->ni = NULL;

		desc->flags = 0;
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ring->queued = 0;
	ring->cur = ring->next = 0;
	ring->cur_encrypt = ring->next_encrypt = 0;
}

void
rt2560_free_tx_ring(struct rt2560_softc *sc, struct rt2560_tx_ring *ring)
{
	int i;

	if (ring->desc != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    ring->count * RT2560_TX_DESC_SIZE);
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}

	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			struct rt2560_tx_data *data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    data->map->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}

			/*
			 * The node has already been freed at that point so
			 * don't call ieee80211_release_node() here.
			 */
			data->ni = NULL;

			if (data->map != NULL)
				bus_dmamap_destroy(sc->sc_dmat, data->map);
		}
		free(ring->data, M_DEVBUF, ring->count * sizeof *ring->data);
	}
}

int
rt2560_alloc_rx_ring(struct rt2560_softc *sc, struct rt2560_rx_ring *ring,
    int count)
{
	int i, nsegs, error;

	ring->count = count;
	ring->cur = ring->next = 0;
	ring->cur_decrypt = 0;

	error = bus_dmamap_create(sc->sc_dmat, count * RT2560_RX_DESC_SIZE, 1,
	    count * RT2560_RX_DESC_SIZE, 0, BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, count * RT2560_RX_DESC_SIZE,
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    count * RT2560_RX_DESC_SIZE, (caddr_t *)&ring->desc,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    count * RT2560_RX_DESC_SIZE, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ring->physaddr = ring->map->dm_segs->ds_addr;

	ring->data = mallocarray(count, sizeof (struct rt2560_rx_data),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ring->data == NULL) {
		printf("%s: could not allocate soft data\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}

	/*
	 * Pre-allocate Rx buffers and populate Rx ring.
	 */
	for (i = 0; i < count; i++) {
		struct rt2560_rx_desc *desc = &sc->rxq.desc[i];
		struct rt2560_rx_data *data = &sc->rxq.data[i];

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &data->map);
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: could not load rx buf DMA map",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		desc->flags = htole32(RT2560_RX_BUSY);
		desc->physaddr = htole32(data->map->dm_segs->ds_addr);
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	return 0;

fail:	rt2560_free_rx_ring(sc, ring);
	return error;
}

void
rt2560_reset_rx_ring(struct rt2560_softc *sc, struct rt2560_rx_ring *ring)
{
	int i;

	for (i = 0; i < ring->count; i++) {
		ring->desc[i].flags = htole32(RT2560_RX_BUSY);
		ring->data[i].drop = 0;
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ring->cur = ring->next = 0;
	ring->cur_decrypt = 0;
}

void
rt2560_free_rx_ring(struct rt2560_softc *sc, struct rt2560_rx_ring *ring)
{
	int i;

	if (ring->desc != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    ring->count * RT2560_RX_DESC_SIZE);
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}

	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			struct rt2560_rx_data *data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    data->map->dm_mapsize,
				    BUS_DMASYNC_POSTREAD);
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}

			if (data->map != NULL)
				bus_dmamap_destroy(sc->sc_dmat, data->map);
		}
		free(ring->data, M_DEVBUF, ring->count * sizeof *ring->data);
	}
}

struct ieee80211_node *
rt2560_node_alloc(struct ieee80211com *ic)
{
	return malloc(sizeof (struct rt2560_node), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
}

int
rt2560_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		rt2560_init(ifp);

	return 0;
}

/*
 * This function is called periodically (every 200ms) during scanning to
 * switch from one channel to another.
 */
void
rt2560_next_scan(void *arg)
{
	struct rt2560_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	s = splnet();
	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
	splx(s);
}

/*
 * This function is called for each neighbor node.
 */
void
rt2560_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct rt2560_softc *sc = arg;
	struct rt2560_node *rn = (struct rt2560_node *)ni;

	ieee80211_amrr_choose(&sc->amrr, ni, &rn->amn);
}

void
rt2560_amrr_timeout(void *arg)
{
	struct rt2560_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	s = splnet();
	if (ic->ic_opmode == IEEE80211_M_STA)
		rt2560_iter_func(sc, ic->ic_bss);
#ifndef IEEE80211_STA_ONLY
	else
		ieee80211_iterate_nodes(ic, rt2560_iter_func, sc);
#endif
	splx(s);

	timeout_add_msec(&sc->amrr_to, 500);
}

void
rt2560_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct rt2560_softc *sc = ic->ic_softc;
	int i;

	ieee80211_amrr_node_init(&sc->amrr, &((struct rt2560_node *)ni)->amn);

	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;
}

int
rt2560_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct rt2560_softc *sc = ic->ic_if.if_softc;
	enum ieee80211_state ostate;
	struct ieee80211_node *ni;
	int error = 0;

	ostate = ic->ic_state;
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);

	switch (nstate) {
	case IEEE80211_S_INIT:
		if (ostate == IEEE80211_S_RUN) {
			/* abort TSF synchronization */
			RAL_WRITE(sc, RT2560_CSR14, 0);

			/* turn association led off */
			rt2560_update_led(sc, 0, 0);
		}
		break;

	case IEEE80211_S_SCAN:
		rt2560_set_chan(sc, ic->ic_bss->ni_chan);
		timeout_add_msec(&sc->scan_to, 200);
		break;

	case IEEE80211_S_AUTH:
		rt2560_set_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_ASSOC:
		rt2560_set_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_RUN:
		rt2560_set_chan(sc, ic->ic_bss->ni_chan);

		ni = ic->ic_bss;

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			rt2560_update_plcp(sc);
			rt2560_set_slottime(sc);
			rt2560_set_basicrates(sc);
			rt2560_set_bssid(sc, ni->ni_bssid);
		}

#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
		    ic->ic_opmode == IEEE80211_M_IBSS) {
			struct mbuf *m = ieee80211_beacon_alloc(ic, ni);
			if (m == NULL) {
				printf("%s: could not allocate beacon\n",
				    sc->sc_dev.dv_xname);
				error = ENOBUFS;
				break;
			}

			error = rt2560_tx_bcn(sc, m, ni);
			if (error != 0)
				break;
		}
#endif

		/* turn assocation led on */
		rt2560_update_led(sc, 1, 0);

		if (ic->ic_opmode == IEEE80211_M_STA) {
			/* fake a join to init the tx rate */
			rt2560_newassoc(ic, ni, 1);
		}

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			/* start automatic rate control timer */
			if (ic->ic_fixed_rate == -1)
				timeout_add_msec(&sc->amrr_to, 500);

			rt2560_enable_tsf_sync(sc);
		}
		break;
	}

	return (error != 0) ? error : sc->sc_newstate(ic, nstate, arg);
}

/*
 * Read 16 bits at address 'addr' from the serial EEPROM (either 93C46 or
 * 93C66).
 */
uint16_t
rt2560_eeprom_read(struct rt2560_softc *sc, uint8_t addr)
{
	uint32_t tmp;
	uint16_t val;
	int n;

	/* clock C once before the first command */
	RT2560_EEPROM_CTL(sc, 0);

	RT2560_EEPROM_CTL(sc, RT2560_S);
	RT2560_EEPROM_CTL(sc, RT2560_S | RT2560_C);
	RT2560_EEPROM_CTL(sc, RT2560_S);

	/* write start bit (1) */
	RT2560_EEPROM_CTL(sc, RT2560_S | RT2560_D);
	RT2560_EEPROM_CTL(sc, RT2560_S | RT2560_D | RT2560_C);

	/* write READ opcode (10) */
	RT2560_EEPROM_CTL(sc, RT2560_S | RT2560_D);
	RT2560_EEPROM_CTL(sc, RT2560_S | RT2560_D | RT2560_C);
	RT2560_EEPROM_CTL(sc, RT2560_S);
	RT2560_EEPROM_CTL(sc, RT2560_S | RT2560_C);

	/* write address (A5-A0 or A7-A0) */
	n = (RAL_READ(sc, RT2560_CSR21) & RT2560_93C46) ? 5 : 7;
	for (; n >= 0; n--) {
		RT2560_EEPROM_CTL(sc, RT2560_S |
		    (((addr >> n) & 1) << RT2560_SHIFT_D));
		RT2560_EEPROM_CTL(sc, RT2560_S |
		    (((addr >> n) & 1) << RT2560_SHIFT_D) | RT2560_C);
	}

	RT2560_EEPROM_CTL(sc, RT2560_S);

	/* read data Q15-Q0 */
	val = 0;
	for (n = 15; n >= 0; n--) {
		RT2560_EEPROM_CTL(sc, RT2560_S | RT2560_C);
		tmp = RAL_READ(sc, RT2560_CSR21);
		val |= ((tmp & RT2560_Q) >> RT2560_SHIFT_Q) << n;
		RT2560_EEPROM_CTL(sc, RT2560_S);
	}

	RT2560_EEPROM_CTL(sc, 0);

	/* clear Chip Select and clock C */
	RT2560_EEPROM_CTL(sc, RT2560_S);
	RT2560_EEPROM_CTL(sc, 0);
	RT2560_EEPROM_CTL(sc, RT2560_C);

	return val;
}

/*
 * Some frames were processed by the hardware cipher engine and are ready for
 * transmission.
 */
void
rt2560_encryption_intr(struct rt2560_softc *sc)
{
	int hw;

	/* retrieve last descriptor index processed by cipher engine */
	hw = (RAL_READ(sc, RT2560_SECCSR1) - sc->txq.physaddr) /
	    RT2560_TX_DESC_SIZE;

	for (; sc->txq.next_encrypt != hw;) {
		struct rt2560_tx_desc *desc =
		    &sc->txq.desc[sc->txq.next_encrypt];

		bus_dmamap_sync(sc->sc_dmat, sc->txq.map,
		    sc->txq.next_encrypt * RT2560_TX_DESC_SIZE,
		    RT2560_TX_DESC_SIZE, BUS_DMASYNC_POSTREAD);

		if (letoh32(desc->flags) &
		    (RT2560_TX_BUSY | RT2560_TX_CIPHER_BUSY))
			break;

		/* for TKIP, swap eiv field to fix a bug in ASIC */
		if ((letoh32(desc->flags) & RT2560_TX_CIPHER_MASK) ==
		    RT2560_TX_CIPHER_TKIP)
			desc->eiv = swap32(desc->eiv);

		/* mark the frame ready for transmission */
		desc->flags |= htole32(RT2560_TX_BUSY | RT2560_TX_VALID);

		bus_dmamap_sync(sc->sc_dmat, sc->txq.map,
		    sc->txq.next_encrypt * RT2560_TX_DESC_SIZE,
		    RT2560_TX_DESC_SIZE, BUS_DMASYNC_PREWRITE);

		DPRINTFN(15, ("encryption done idx=%u\n",
		    sc->txq.next_encrypt));

		sc->txq.next_encrypt =
		    (sc->txq.next_encrypt + 1) % RT2560_TX_RING_COUNT;
	}

	/* kick Tx */
	RAL_WRITE(sc, RT2560_TXCSR0, RT2560_KICK_TX);
}

void
rt2560_tx_intr(struct rt2560_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	for (;;) {
		struct rt2560_tx_desc *desc = &sc->txq.desc[sc->txq.next];
		struct rt2560_tx_data *data = &sc->txq.data[sc->txq.next];
		struct rt2560_node *rn;

		bus_dmamap_sync(sc->sc_dmat, sc->txq.map,
		    sc->txq.next * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
		    BUS_DMASYNC_POSTREAD);

		if ((letoh32(desc->flags) & RT2560_TX_BUSY) ||
		    (letoh32(desc->flags) & RT2560_TX_CIPHER_BUSY) ||
		    !(letoh32(desc->flags) & RT2560_TX_VALID))
			break;

		rn = (struct rt2560_node *)data->ni;

		switch (letoh32(desc->flags) & RT2560_TX_RESULT_MASK) {
		case RT2560_TX_SUCCESS:
			DPRINTFN(10, ("data frame sent successfully\n"));
			rn->amn.amn_txcnt++;
			break;

		case RT2560_TX_SUCCESS_RETRY:
			DPRINTFN(9, ("data frame sent after %u retries\n",
			    (letoh32(desc->flags) >> 5) & 0x7));
			rn->amn.amn_txcnt++;
			rn->amn.amn_retrycnt++;
			break;

		case RT2560_TX_FAIL_RETRY:
			DPRINTFN(9, ("sending data frame failed (too much "
			    "retries)\n"));
			rn->amn.amn_txcnt++;
			rn->amn.amn_retrycnt++;
			ifp->if_oerrors++;
			break;

		case RT2560_TX_FAIL_INVALID:
		case RT2560_TX_FAIL_OTHER:
		default:
			DPRINTF(("%s: sending data frame failed 0x%08x\n",
			    sc->sc_dev.dv_xname, letoh32(desc->flags)));
			ifp->if_oerrors++;
			break;
		}

		/* descriptor is no longer valid */
		desc->flags &= ~htole32(RT2560_TX_VALID);

		bus_dmamap_sync(sc->sc_dmat, sc->txq.map,
		    sc->txq.next * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
		    BUS_DMASYNC_PREWRITE);

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		data->m = NULL;
		ieee80211_release_node(ic, data->ni);
		data->ni = NULL;

		DPRINTFN(15, ("tx done idx=%u\n", sc->txq.next));

		sc->txq.queued--;
		sc->txq.next = (sc->txq.next + 1) % RT2560_TX_RING_COUNT;
	}

	if (sc->txq.queued == 0 && sc->prioq.queued == 0)
		sc->sc_tx_timer = 0;
	if (sc->txq.queued < RT2560_TX_RING_COUNT - 1) {
		sc->sc_flags &= ~RT2560_DATA_OACTIVE;
		if (!(sc->sc_flags & (RT2560_DATA_OACTIVE|RT2560_PRIO_OACTIVE)))
			ifq_clr_oactive(&ifp->if_snd);
		rt2560_start(ifp);
	}
}

void
rt2560_prio_intr(struct rt2560_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	for (;;) {
		struct rt2560_tx_desc *desc = &sc->prioq.desc[sc->prioq.next];
		struct rt2560_tx_data *data = &sc->prioq.data[sc->prioq.next];

		bus_dmamap_sync(sc->sc_dmat, sc->prioq.map,
		    sc->prioq.next * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
		    BUS_DMASYNC_POSTREAD);

		if ((letoh32(desc->flags) & RT2560_TX_BUSY) ||
		    !(letoh32(desc->flags) & RT2560_TX_VALID))
			break;

		switch (letoh32(desc->flags) & RT2560_TX_RESULT_MASK) {
		case RT2560_TX_SUCCESS:
			DPRINTFN(10, ("mgt frame sent successfully\n"));
			break;

		case RT2560_TX_SUCCESS_RETRY:
			DPRINTFN(9, ("mgt frame sent after %u retries\n",
			    (letoh32(desc->flags) >> 5) & 0x7));
			break;

		case RT2560_TX_FAIL_RETRY:
			DPRINTFN(9, ("sending mgt frame failed (too much "
			    "retries)\n"));
			break;

		case RT2560_TX_FAIL_INVALID:
		case RT2560_TX_FAIL_OTHER:
		default:
			DPRINTF(("%s: sending mgt frame failed 0x%08x\n",
			    sc->sc_dev.dv_xname, letoh32(desc->flags)));
			break;
		}

		/* descriptor is no longer valid */
		desc->flags &= ~htole32(RT2560_TX_VALID);

		bus_dmamap_sync(sc->sc_dmat, sc->prioq.map,
		    sc->prioq.next * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
		    BUS_DMASYNC_PREWRITE);

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		data->m = NULL;
		ieee80211_release_node(ic, data->ni);
		data->ni = NULL;

		DPRINTFN(15, ("prio done idx=%u\n", sc->prioq.next));

		sc->prioq.queued--;
		sc->prioq.next = (sc->prioq.next + 1) % RT2560_PRIO_RING_COUNT;
	}

	if (sc->txq.queued == 0 && sc->prioq.queued == 0)
		sc->sc_tx_timer = 0;
	if (sc->prioq.queued < RT2560_PRIO_RING_COUNT) {
		sc->sc_flags &= ~RT2560_PRIO_OACTIVE;
		if (!(sc->sc_flags & (RT2560_DATA_OACTIVE|RT2560_PRIO_OACTIVE)))
			ifq_clr_oactive(&ifp->if_snd);
		rt2560_start(ifp);
	}
}

/*
 * Some frames were processed by the hardware cipher engine and are ready for
 * transmission to the IEEE802.11 layer.
 */
void
rt2560_decryption_intr(struct rt2560_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *mnew, *m;
	int hw, error;

	/* retrieve last decriptor index processed by cipher engine */
	hw = (RAL_READ(sc, RT2560_SECCSR0) - sc->rxq.physaddr) /
	    RT2560_RX_DESC_SIZE;

	for (; sc->rxq.cur_decrypt != hw;) {
		struct rt2560_rx_desc *desc =
		    &sc->rxq.desc[sc->rxq.cur_decrypt];
		struct rt2560_rx_data *data =
		    &sc->rxq.data[sc->rxq.cur_decrypt];

		bus_dmamap_sync(sc->sc_dmat, sc->rxq.map,
		    sc->rxq.cur_decrypt * RT2560_TX_DESC_SIZE,
		    RT2560_TX_DESC_SIZE, BUS_DMASYNC_POSTREAD);

		if (letoh32(desc->flags) &
		    (RT2560_RX_BUSY | RT2560_RX_CIPHER_BUSY))
			break;

		if (data->drop) {
			ifp->if_ierrors++;
			goto skip;
		}

		if ((letoh32(desc->flags) & RT2560_RX_CIPHER_MASK) != 0 &&
		    (letoh32(desc->flags) & RT2560_RX_ICV_ERROR)) {
			ifp->if_ierrors++;
			goto skip;
		}

		/*
		 * Try to allocate a new mbuf for this ring element and load it
		 * before processing the current mbuf.  If the ring element
		 * cannot be loaded, drop the received packet and reuse the old
		 * mbuf.  In the unlikely case that the old mbuf can't be
		 * reloaded either, explicitly panic.
		 */
		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
			ifp->if_ierrors++;
			goto skip;
		}
		MCLGET(mnew, M_DONTWAIT);
		if (!(mnew->m_flags & M_EXT)) {
			m_freem(mnew);
			ifp->if_ierrors++;
			goto skip;
		}

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmat, data->map);

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(mnew, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			m_freem(mnew);

			/* try to reload the old mbuf */
			error = bus_dmamap_load(sc->sc_dmat, data->map,
			    mtod(data->m, void *), MCLBYTES, NULL,
			    BUS_DMA_NOWAIT);
			if (error != 0) {
				/* very unlikely that it will fail... */
				panic("%s: could not load old rx mbuf",
				    sc->sc_dev.dv_xname);
			}
			/* physical address may have changed */
			desc->physaddr = htole32(data->map->dm_segs->ds_addr);
			ifp->if_ierrors++;
			goto skip;
		}

		/*
		 * New mbuf successfully loaded, update Rx ring and continue
		 * processing.
		 */
		m = data->m;
		data->m = mnew;
		desc->physaddr = htole32(data->map->dm_segs->ds_addr);

		/* finalize mbuf */
		m->m_pkthdr.len = m->m_len =
		    (letoh32(desc->flags) >> 16) & 0xfff;

#if NBPFILTER > 0
		if (sc->sc_drvbpf != NULL) {
			struct mbuf mb;
			struct rt2560_rx_radiotap_header *tap = &sc->sc_rxtap;
			uint32_t tsf_lo, tsf_hi;

			/* get timestamp (low and high 32 bits) */
			tsf_hi = RAL_READ(sc, RT2560_CSR17);
			tsf_lo = RAL_READ(sc, RT2560_CSR16);

			tap->wr_tsf =
			    htole64(((uint64_t)tsf_hi << 32) | tsf_lo);
			tap->wr_flags = 0;
			tap->wr_rate = rt2560_rxrate(desc);
			tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
			tap->wr_chan_flags =
			    htole16(ic->ic_ibss_chan->ic_flags);
			tap->wr_antenna = sc->rx_ant;
			tap->wr_antsignal = desc->rssi;

			mb.m_data = (caddr_t)tap;
			mb.m_len = sc->sc_txtap_len;
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
		}
#endif
		wh = mtod(m, struct ieee80211_frame *);
		ni = ieee80211_find_rxnode(ic, wh);

		/* send the frame to the 802.11 layer */
		rxi.rxi_flags = 0;
		rxi.rxi_rssi = desc->rssi;
		rxi.rxi_tstamp = 0;	/* unused */
		ieee80211_input(ifp, m, ni, &rxi);

		/* node is no longer needed */
		ieee80211_release_node(ic, ni);

skip:		desc->flags = htole32(RT2560_RX_BUSY);

		bus_dmamap_sync(sc->sc_dmat, sc->rxq.map,
		    sc->rxq.cur_decrypt * RT2560_TX_DESC_SIZE,
		    RT2560_TX_DESC_SIZE, BUS_DMASYNC_PREWRITE);

		DPRINTFN(15, ("decryption done idx=%u\n", sc->rxq.cur_decrypt));

		sc->rxq.cur_decrypt =
		    (sc->rxq.cur_decrypt + 1) % RT2560_RX_RING_COUNT;
	}
}

/*
 * Some frames were received. Pass them to the hardware cipher engine before
 * sending them to the 802.11 layer.
 */
void
rt2560_rx_intr(struct rt2560_softc *sc)
{
	for (;;) {
		struct rt2560_rx_desc *desc = &sc->rxq.desc[sc->rxq.cur];
		struct rt2560_rx_data *data = &sc->rxq.data[sc->rxq.cur];

		bus_dmamap_sync(sc->sc_dmat, sc->rxq.map,
		    sc->rxq.cur * RT2560_RX_DESC_SIZE, RT2560_RX_DESC_SIZE,
		    BUS_DMASYNC_POSTREAD);

		if (letoh32(desc->flags) &
		    (RT2560_RX_BUSY | RT2560_RX_CIPHER_BUSY))
			break;

		data->drop = 0;

		if (letoh32(desc->flags) &
		    (RT2560_RX_PHY_ERROR | RT2560_RX_CRC_ERROR)) {
			/*
			 * This should not happen since we did not request
			 * to receive those frames when we filled RXCSR0.
			 */
			DPRINTFN(5, ("PHY or CRC error flags 0x%08x\n",
			    letoh32(desc->flags)));
			data->drop = 1;
		}

		if (((letoh32(desc->flags) >> 16) & 0xfff) > MCLBYTES) {
			DPRINTFN(5, ("bad length\n"));
			data->drop = 1;
		}

		/* mark the frame for decryption */
		desc->flags |= htole32(RT2560_RX_CIPHER_BUSY);

		bus_dmamap_sync(sc->sc_dmat, sc->rxq.map,
		    sc->rxq.cur * RT2560_RX_DESC_SIZE, RT2560_RX_DESC_SIZE,
		    BUS_DMASYNC_PREWRITE);

		DPRINTFN(15, ("rx done idx=%u\n", sc->rxq.cur));

		sc->rxq.cur = (sc->rxq.cur + 1) % RT2560_RX_RING_COUNT;
	}

	/* kick decrypt */
	RAL_WRITE(sc, RT2560_SECCSR0, RT2560_KICK_DECRYPT);
}

#ifndef IEEE80211_STA_ONLY
/*
 * This function is called in HostAP or IBSS modes when it's time to send a
 * new beacon (every ni_intval milliseconds).
 */
void
rt2560_beacon_expire(struct rt2560_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rt2560_tx_data *data;

	if (ic->ic_opmode != IEEE80211_M_IBSS &&
	    ic->ic_opmode != IEEE80211_M_HOSTAP)
		return;

	data = &sc->bcnq.data[sc->bcnq.next];

	if (sc->sc_flags & RT2560_UPDATE_SLOT) {
		sc->sc_flags &= ~RT2560_UPDATE_SLOT;
		sc->sc_flags |= RT2560_SET_SLOTTIME;
	} else if (sc->sc_flags & RT2560_SET_SLOTTIME) {
		sc->sc_flags &= ~RT2560_SET_SLOTTIME;
		rt2560_set_slottime(sc);
	}

	if (ic->ic_curmode == IEEE80211_MODE_11G) {
		/* update ERP Information Element */
		*sc->erp = ic->ic_bss->ni_erp;
		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_PREWRITE);
	}

#if defined(RT2560_DEBUG) && NBPFILTER > 0
	if (ic->ic_rawbpf != NULL)
		bpf_mtap(ic->ic_rawbpf, data->m, BPF_DIRECTION_OUT);
#endif

	DPRINTFN(15, ("beacon expired\n"));
}
#endif

void
rt2560_wakeup_expire(struct rt2560_softc *sc)
{
	DPRINTFN(15, ("wakeup expired\n"));
}

int
rt2560_intr(void *arg)
{
	struct rt2560_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t r;

	r = RAL_READ(sc, RT2560_CSR7);
	if (__predict_false(r == 0xffffffff))
		return 0;	/* device likely went away */
	if (r == 0)
		return 0;	/* not for us */

	/* disable interrupts */
	RAL_WRITE(sc, RT2560_CSR8, 0xffffffff);

	/* acknowledge interrupts */
	RAL_WRITE(sc, RT2560_CSR7, r);

	/* don't re-enable interrupts if we're shutting down */
	if (!(ifp->if_flags & IFF_RUNNING))
		return 0;

#ifndef IEEE80211_STA_ONLY
	if (r & RT2560_BEACON_EXPIRE)
		rt2560_beacon_expire(sc);
#endif

	if (r & RT2560_WAKEUP_EXPIRE)
		rt2560_wakeup_expire(sc);

	if (r & RT2560_ENCRYPTION_DONE)
		rt2560_encryption_intr(sc);

	if (r & RT2560_TX_DONE)
		rt2560_tx_intr(sc);

	if (r & RT2560_PRIO_DONE)
		rt2560_prio_intr(sc);

	if (r & RT2560_DECRYPTION_DONE)
		rt2560_decryption_intr(sc);

	if (r & RT2560_RX_DONE)
		rt2560_rx_intr(sc);

	/* re-enable interrupts */
	RAL_WRITE(sc, RT2560_CSR8, RT2560_INTR_MASK);

	return 1;
}

/* quickly determine if a given rate is CCK or OFDM */
#define RAL_RATE_IS_OFDM(rate) ((rate) >= 12 && (rate) != 22)

#define RAL_ACK_SIZE	14	/* 10 + 4(FCS) */
#define RAL_CTS_SIZE	14	/* 10 + 4(FCS) */

#define RAL_SIFS		10	/* us */

#define RT2560_RXTX_TURNAROUND	10	/* us */

/*
 * This function is only used by the Rx radiotap code. It returns the rate at
 * which a given frame was received.
 */
#if NBPFILTER > 0
uint8_t
rt2560_rxrate(const struct rt2560_rx_desc *desc)
{
	if (letoh32(desc->flags) & RT2560_RX_OFDM) {
		/* reverse function of rt2560_plcp_signal */
		switch (desc->rate) {
		case 0xb:	return 12;
		case 0xf:	return 18;
		case 0xa:	return 24;
		case 0xe:	return 36;
		case 0x9:	return 48;
		case 0xd:	return 72;
		case 0x8:	return 96;
		case 0xc:	return 108;
		}
	} else {
		if (desc->rate == 10)
			return 2;
		if (desc->rate == 20)
			return 4;
		if (desc->rate == 55)
			return 11;
		if (desc->rate == 110)
			return 22;
	}
	return 2;	/* should not get there */
}
#endif

/*
 * Return the expected ack rate for a frame transmitted at rate `rate'.
 */
int
rt2560_ack_rate(struct ieee80211com *ic, int rate)
{
	switch (rate) {
	/* CCK rates */
	case 2:
		return 2;
	case 4:
	case 11:
	case 22:
		return (ic->ic_curmode == IEEE80211_MODE_11B) ? 4 : rate;

	/* OFDM rates */
	case 12:
	case 18:
		return 12;
	case 24:
	case 36:
		return 24;
	case 48:
	case 72:
	case 96:
	case 108:
		return 48;
	}

	/* default to 1Mbps */
	return 2;
}

/*
 * Compute the duration (in us) needed to transmit `len' bytes at rate `rate'.
 * The function automatically determines the operating mode depending on the
 * given rate. `flags' indicates whether short preamble is in use or not.
 */
uint16_t
rt2560_txtime(int len, int rate, uint32_t flags)
{
	uint16_t txtime;

	if (RAL_RATE_IS_OFDM(rate)) {
		/* IEEE Std 802.11g-2003, pp. 44 */
		txtime = (8 + 4 * len + 3 + rate - 1) / rate;
		txtime = 16 + 4 + 4 * txtime + 6;
	} else {
		/* IEEE Std 802.11b-1999, pp. 28 */
		txtime = (16 * len + rate - 1) / rate;
		if (rate != 2 && (flags & IEEE80211_F_SHPREAMBLE))
			txtime +=  72 + 24;
		else
			txtime += 144 + 48;
	}
	return txtime;
}

uint8_t
rt2560_plcp_signal(int rate)
{
	switch (rate) {
	/* CCK rates (returned values are device-dependent) */
	case 2:		return 0x0;
	case 4:		return 0x1;
	case 11:	return 0x2;
	case 22:	return 0x3;

	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
	case 12:	return 0xb;
	case 18:	return 0xf;
	case 24:	return 0xa;
	case 36:	return 0xe;
	case 48:	return 0x9;
	case 72:	return 0xd;
	case 96:	return 0x8;
	case 108:	return 0xc;

	/* unsupported rates (should not get there) */
	default:	return 0xff;
	}
}

void
rt2560_setup_tx_desc(struct rt2560_softc *sc, struct rt2560_tx_desc *desc,
    uint32_t flags, int len, int rate, int encrypt, bus_addr_t physaddr)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t plcp_length;
	int remainder;

	desc->flags = htole32(flags);
	desc->flags |= htole32(len << 16);
	desc->flags |= encrypt ? htole32(RT2560_TX_CIPHER_BUSY) :
	    htole32(RT2560_TX_BUSY | RT2560_TX_VALID);

	desc->physaddr = htole32(physaddr);
	desc->wme = htole16(
	    RT2560_AIFSN(2) |
	    RT2560_LOGCWMIN(3) |
	    RT2560_LOGCWMAX(8));

	/* setup PLCP fields */
	desc->plcp_signal  = rt2560_plcp_signal(rate);
	desc->plcp_service = 4;

	len += IEEE80211_CRC_LEN;
	if (RAL_RATE_IS_OFDM(rate)) {
		desc->flags |= htole32(RT2560_TX_OFDM);

		plcp_length = len & 0xfff;
		desc->plcp_length_hi = plcp_length >> 6;
		desc->plcp_length_lo = plcp_length & 0x3f;
	} else {
		plcp_length = (16 * len + rate - 1) / rate;
		if (rate == 22) {
			remainder = (16 * len) % 22;
			if (remainder != 0 && remainder < 7)
				desc->plcp_service |= RT2560_PLCP_LENGEXT;
		}
		desc->plcp_length_hi = plcp_length >> 8;
		desc->plcp_length_lo = plcp_length & 0xff;

		if (rate != 2 && (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
			desc->plcp_signal |= 0x08;
	}
}

#ifndef IEEE80211_STA_ONLY
int
rt2560_tx_bcn(struct rt2560_softc *sc, struct mbuf *m0,
    struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rt2560_tx_desc *desc;
	struct rt2560_tx_data *data;
	int rate = 2, error;

	desc = &sc->bcnq.desc[sc->bcnq.cur];
	data = &sc->bcnq.data[sc->bcnq.cur];

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return error;
	}

	data->m = m0;
	data->ni = ni;

	rt2560_setup_tx_desc(sc, desc, RT2560_TX_IFS_NEWBACKOFF |
	    RT2560_TX_TIMESTAMP, m0->m_pkthdr.len, rate, 0,
	    data->map->dm_segs->ds_addr);

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->bcnq.map,
	    sc->bcnq.cur * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
	    BUS_DMASYNC_PREWRITE);

	/*
	 * Store pointer to ERP Information Element so that we can update it
	 * dynamically when the slot time changes.
	 * XXX: this is ugly since it depends on how net80211 builds beacon
	 * frames but ieee80211_beacon_alloc() don't store offsets for us.
	 */
	if (ic->ic_curmode == IEEE80211_MODE_11G) {
		sc->erp =
		    mtod(m0, uint8_t *) +
		    sizeof (struct ieee80211_frame) +
		    8 + 2 + 2 +
		    ((ic->ic_flags & IEEE80211_F_HIDENWID) ?
			1 : 2 + ni->ni_esslen) +
		    2 + min(ni->ni_rates.rs_nrates, IEEE80211_RATE_SIZE) +
		    2 + 1 +
		    ((ic->ic_opmode == IEEE80211_M_IBSS) ? 4 : 6) +
		    2;
	}

	return 0;
}
#endif

int
rt2560_tx_mgt(struct rt2560_softc *sc, struct mbuf *m0,
    struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rt2560_tx_desc *desc;
	struct rt2560_tx_data *data;
	struct ieee80211_frame *wh;
	uint16_t dur;
	uint32_t flags = 0;
	int rate = 2, error;

	desc = &sc->prioq.desc[sc->prioq.cur];
	data = &sc->prioq.data[sc->prioq.cur];

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return error;
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct rt2560_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
		tap->wt_antenna = sc->tx_ant;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	data->m = m0;
	data->ni = ni;

	wh = mtod(m0, struct ieee80211_frame *);

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RT2560_TX_NEED_ACK;

		dur = rt2560_txtime(RAL_ACK_SIZE, rate, ic->ic_flags) +
		    RAL_SIFS;
		*(uint16_t *)wh->i_dur = htole16(dur);

#ifndef IEEE80211_STA_ONLY
		/* tell hardware to set timestamp for probe responses */
		if ((wh->i_fc[0] &
		    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
		    (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
			flags |= RT2560_TX_TIMESTAMP;
#endif
	}

	rt2560_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate, 0,
	    data->map->dm_segs->ds_addr);

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->prioq.map,
	    sc->prioq.cur * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
	    BUS_DMASYNC_PREWRITE);

	DPRINTFN(10, ("sending mgt frame len=%u idx=%u rate=%u\n",
	    m0->m_pkthdr.len, sc->prioq.cur, rate));

	/* kick prio */
	sc->prioq.queued++;
	sc->prioq.cur = (sc->prioq.cur + 1) % RT2560_PRIO_RING_COUNT;
	RAL_WRITE(sc, RT2560_TXCSR0, RT2560_KICK_PRIO);

	return 0;
}

int
rt2560_tx_data(struct rt2560_softc *sc, struct mbuf *m0,
    struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rt2560_tx_ring *txq = &sc->txq;
	struct rt2560_tx_desc *desc;
	struct rt2560_tx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct mbuf *m1;
	uint16_t dur;
	uint32_t flags = 0;
	int pktlen, rate, needcts = 0, needrts = 0, error;

	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

	/* compute actual packet length (including CRC and crypto overhead) */
	pktlen = m0->m_pkthdr.len + IEEE80211_CRC_LEN;

	/* pickup a rate */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	     IEEE80211_FC0_TYPE_MGT)) {
		/* mgmt/multicast frames are sent at the lowest avail. rate */
		rate = ni->ni_rates.rs_rates[0];
	} else if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
	} else
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	if (rate == 0)
		rate = 2;	/* XXX should not happen */
	rate &= IEEE80211_RATE_VAL;

	/*
	 * Packet Bursting: backoff after ppb=8 frames to give other STAs a
	 * chance to contend for the wireless medium.
	 */
	if (ic->ic_opmode == IEEE80211_M_STA && (ni->ni_txseq & 7))
		flags |= RT2560_TX_IFS_SIFS;

	/* check if RTS/CTS or CTS-to-self protection must be used */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* multicast frames are not sent at OFDM rates in 802.11b/g */
		if (pktlen > ic->ic_rtsthreshold) {
			needrts = 1;	/* RTS/CTS based on frame length */
		} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
		    RAL_RATE_IS_OFDM(rate)) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				needcts = 1;	/* CTS-to-self */
			else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				needrts = 1;	/* RTS/CTS */
		}
	}
	if (needrts || needcts) {
		struct mbuf *mprot;
		int protrate, ackrate;

		protrate = 2;	/* XXX */
		ackrate  = rt2560_ack_rate(ic, rate);

		dur = rt2560_txtime(pktlen, rate, ic->ic_flags) +
		      rt2560_txtime(RAL_ACK_SIZE, ackrate, ic->ic_flags) +
		      2 * RAL_SIFS;
		if (needrts) {
			dur += rt2560_txtime(RAL_CTS_SIZE, rt2560_ack_rate(ic,
			    protrate), ic->ic_flags) + RAL_SIFS;
			mprot = ieee80211_get_rts(ic, wh, dur);
		} else {
			mprot = ieee80211_get_cts_to_self(ic, dur);
		}
		if (mprot == NULL) {
			printf("%s: could not allocate protection frame\n",
			    sc->sc_dev.dv_xname);
			m_freem(m0);
			return ENOBUFS;
		}

		desc = &txq->desc[txq->cur_encrypt];
		data = &txq->data[txq->cur_encrypt];

		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, mprot,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(mprot);
			m_freem(m0);
			return error;
		}

		data->m = mprot;
		/* avoid multiple free() of the same node for each fragment */
		data->ni = ieee80211_ref_node(ni);

		/* XXX may want to pass the protection frame to BPF */

		rt2560_setup_tx_desc(sc, desc,
		    (needrts ? RT2560_TX_NEED_ACK : 0) | RT2560_TX_MORE_FRAG,
		    mprot->m_pkthdr.len, protrate, 1,
		    data->map->dm_segs->ds_addr);

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, txq->map,
		    txq->cur_encrypt * RT2560_TX_DESC_SIZE,
		    RT2560_TX_DESC_SIZE, BUS_DMASYNC_PREWRITE);

		txq->queued++;
		if (++txq->cur_encrypt >= txq->count)
			txq->cur_encrypt = 0;

		flags |= RT2560_TX_LONG_RETRY | RT2560_TX_IFS_SIFS;
	}

	data = &txq->data[txq->cur_encrypt];
	desc = &txq->desc[txq->cur_encrypt];

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0 && error != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return error;
	}
	if (error != 0) {
		/* too many fragments, linearize */
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
			m_freem(m0);
			return ENOBUFS;
		}
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(m1);
				return ENOBUFS;
			}
		}
		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_pkthdr.len = m1->m_len = m0->m_pkthdr.len;
		m_freem(m0);
		m0 = m1;

		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m0);
			return error;
		}

		/* packet header have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct rt2560_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
		tap->wt_antenna = sc->tx_ant;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	data->m = m0;
	data->ni = ni;

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RT2560_TX_NEED_ACK;

		dur = rt2560_txtime(RAL_ACK_SIZE, rt2560_ack_rate(ic, rate),
		    ic->ic_flags) + RAL_SIFS;
		*(uint16_t *)wh->i_dur = htole16(dur);
	}

	rt2560_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate, 1,
	    data->map->dm_segs->ds_addr);

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, txq->map,
	    txq->cur_encrypt * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
	    BUS_DMASYNC_PREWRITE);

	DPRINTFN(10, ("sending frame len=%u idx=%u rate=%u\n",
	    m0->m_pkthdr.len, txq->cur_encrypt, rate));

	/* kick encrypt */
	txq->queued++;
	if (++txq->cur_encrypt >= txq->count)
		txq->cur_encrypt = 0;
	RAL_WRITE(sc, RT2560_SECCSR1, RT2560_KICK_ENCRYPT);

	return 0;
}

void
rt2560_start(struct ifnet *ifp)
{
	struct rt2560_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct mbuf *m0;
	struct ieee80211_node *ni;

	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (mq_len(&ic->ic_mgtq) > 0) {
			if (sc->prioq.queued >= RT2560_PRIO_RING_COUNT) {
				ifq_set_oactive(&ifp->if_snd);
				sc->sc_flags |= RT2560_PRIO_OACTIVE;
				break;
			}

			m0 = mq_dequeue(&ic->ic_mgtq);
			if (m0 == NULL)
				continue;
			ni = m0->m_pkthdr.ph_cookie;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (rt2560_tx_mgt(sc, m0, ni) != 0)
				break;

		} else {
			/* Because RTS/CTS requires an extra frame we need
			 * space for 2 frames on the regular Tx queue. */
			if (sc->txq.queued >= RT2560_TX_RING_COUNT - 1) {
				ifq_set_oactive(&ifp->if_snd);
				sc->sc_flags |= RT2560_DATA_OACTIVE;
				break;
			}

			if (ic->ic_state != IEEE80211_S_RUN)
				break;

			IFQ_DEQUEUE(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (rt2560_tx_data(sc, m0, ni) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
rt2560_watchdog(struct ifnet *ifp)
{
	struct rt2560_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			rt2560_init(ifp);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
rt2560_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct rt2560_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				rt2560_update_promisc(sc);
			else
				rt2560_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				rt2560_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCS80211CHANNEL:
		/*
		 * This allows for fast channel switching in monitor mode
		 * (used by kismet). In IBSS mode, we must explicitly reset
		 * the interface to generate a new beacon frame.
		 */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING))
				rt2560_set_chan(sc, ic->ic_ibss_chan);
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			rt2560_init(ifp);
		error = 0;
	}

	splx(s);

	return error;
}

void
rt2560_bbp_write(struct rt2560_softc *sc, uint8_t reg, uint8_t val)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2560_BBPCSR) & RT2560_BBP_BUSY))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not write to BBP\n", sc->sc_dev.dv_xname);
		return;
	}

	tmp = RT2560_BBP_WRITE | RT2560_BBP_BUSY | reg << 8 | val;
	RAL_WRITE(sc, RT2560_BBPCSR, tmp);

	DPRINTFN(15, ("BBP R%u <- 0x%02x\n", reg, val));
}

uint8_t
rt2560_bbp_read(struct rt2560_softc *sc, uint8_t reg)
{
	uint32_t val;
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2560_BBPCSR) & RT2560_BBP_BUSY))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not read from BBP\n", sc->sc_dev.dv_xname);
		return 0;
	}

	val = RT2560_BBP_BUSY | reg << 8;
	RAL_WRITE(sc, RT2560_BBPCSR, val);

	for (ntries = 0; ntries < 100; ntries++) {
		val = RAL_READ(sc, RT2560_BBPCSR);
		if (!(val & RT2560_BBP_BUSY))
			return val & 0xff;
		DELAY(1);
	}

	printf("%s: could not read from BBP\n", sc->sc_dev.dv_xname);
	return 0;
}

void
rt2560_rf_write(struct rt2560_softc *sc, uint8_t reg, uint32_t val)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2560_RFCSR) & RT2560_RF_BUSY))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not write to RF\n", sc->sc_dev.dv_xname);
		return;
	}

	tmp = RT2560_RF_BUSY | RT2560_RF_20BIT | (val & 0xfffff) << 2 |
	    (reg & 0x3);
	RAL_WRITE(sc, RT2560_RFCSR, tmp);

	/* remember last written value in sc */
	sc->rf_regs[reg] = val;

	DPRINTFN(15, ("RF R[%u] <- 0x%05x\n", reg & 0x3, val & 0xfffff));
}

void
rt2560_set_chan(struct rt2560_softc *sc, struct ieee80211_channel *c)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t power, tmp;
	u_int chan;

	chan = ieee80211_chan2ieee(ic, c);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return;

	power = min(sc->txpow[chan - 1], 31);

	DPRINTFN(2, ("setting channel to %u, txpower to %u\n", chan, power));

	switch (sc->rf_rev) {
	case RT2560_RF_2522:
		rt2560_rf_write(sc, RT2560_RF1, 0x00814);
		rt2560_rf_write(sc, RT2560_RF2, rt2560_rf2522_r2[chan - 1]);
		rt2560_rf_write(sc, RT2560_RF3, power << 7 | 0x00040);
		break;

	case RT2560_RF_2523:
		rt2560_rf_write(sc, RT2560_RF1, 0x08804);
		rt2560_rf_write(sc, RT2560_RF2, rt2560_rf2523_r2[chan - 1]);
		rt2560_rf_write(sc, RT2560_RF3, power << 7 | 0x38044);
		rt2560_rf_write(sc, RT2560_RF4,
		    (chan == 14) ? 0x00280 : 0x00286);
		break;

	case RT2560_RF_2524:
		rt2560_rf_write(sc, RT2560_RF1, 0x0c808);
		rt2560_rf_write(sc, RT2560_RF2, rt2560_rf2524_r2[chan - 1]);
		rt2560_rf_write(sc, RT2560_RF3, power << 7 | 0x00040);
		rt2560_rf_write(sc, RT2560_RF4,
		    (chan == 14) ? 0x00280 : 0x00286);
		break;

	case RT2560_RF_2525:
		rt2560_rf_write(sc, RT2560_RF1, 0x08808);
		rt2560_rf_write(sc, RT2560_RF2, rt2560_rf2525_hi_r2[chan - 1]);
		rt2560_rf_write(sc, RT2560_RF3, power << 7 | 0x18044);
		rt2560_rf_write(sc, RT2560_RF4,
		    (chan == 14) ? 0x00280 : 0x00286);

		rt2560_rf_write(sc, RT2560_RF1, 0x08808);
		rt2560_rf_write(sc, RT2560_RF2, rt2560_rf2525_r2[chan - 1]);
		rt2560_rf_write(sc, RT2560_RF3, power << 7 | 0x18044);
		rt2560_rf_write(sc, RT2560_RF4,
		    (chan == 14) ? 0x00280 : 0x00286);
		break;

	case RT2560_RF_2525E:
		rt2560_rf_write(sc, RT2560_RF1, 0x08808);
		rt2560_rf_write(sc, RT2560_RF2, rt2560_rf2525e_r2[chan - 1]);
		rt2560_rf_write(sc, RT2560_RF3, power << 7 | 0x18044);
		rt2560_rf_write(sc, RT2560_RF4,
		    (chan == 14) ? 0x00286 : 0x00282);
		break;

	case RT2560_RF_2526:
		rt2560_rf_write(sc, RT2560_RF2, rt2560_rf2526_hi_r2[chan - 1]);
		rt2560_rf_write(sc, RT2560_RF4,
		   (chan & 1) ? 0x00386 : 0x00381);
		rt2560_rf_write(sc, RT2560_RF1, 0x08804);

		rt2560_rf_write(sc, RT2560_RF2, rt2560_rf2526_r2[chan - 1]);
		rt2560_rf_write(sc, RT2560_RF3, power << 7 | 0x18044);
		rt2560_rf_write(sc, RT2560_RF4,
		    (chan & 1) ? 0x00386 : 0x00381);
		break;
	}

	if (ic->ic_opmode != IEEE80211_M_MONITOR &&
	    ic->ic_state != IEEE80211_S_SCAN) {
		/* set Japan filter bit for channel 14 */
		tmp = rt2560_bbp_read(sc, 70);

		tmp &= ~RT2560_JAPAN_FILTER;
		if (chan == 14)
			tmp |= RT2560_JAPAN_FILTER;

		rt2560_bbp_write(sc, 70, tmp);

		DELAY(1000); /* RF needs a 1ms delay here */
		rt2560_disable_rf_tune(sc);

		/* clear CRC errors */
		RAL_READ(sc, RT2560_CNT0);
	}
}

/*
 * Disable RF auto-tuning.
 */
void
rt2560_disable_rf_tune(struct rt2560_softc *sc)
{
	uint32_t tmp;

	if (sc->rf_rev != RT2560_RF_2523) {
		tmp = sc->rf_regs[RT2560_RF1] & ~RT2560_RF1_AUTOTUNE;
		rt2560_rf_write(sc, RT2560_RF1, tmp);
	}

	tmp = sc->rf_regs[RT2560_RF3] & ~RT2560_RF3_AUTOTUNE;
	rt2560_rf_write(sc, RT2560_RF3, tmp);

	DPRINTFN(2, ("disabling RF autotune\n"));
}

/*
 * Refer to IEEE Std 802.11-1999 pp. 123 for more information on TSF
 * synchronization.
 */
void
rt2560_enable_tsf_sync(struct rt2560_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t logcwmin, preload;
	uint32_t tmp;

	/* first, disable TSF synchronization */
	RAL_WRITE(sc, RT2560_CSR14, 0);

	tmp = 16 * ic->ic_bss->ni_intval;
	RAL_WRITE(sc, RT2560_CSR12, tmp);

	RAL_WRITE(sc, RT2560_CSR13, 0);

	logcwmin = 5;
	preload = (ic->ic_opmode == IEEE80211_M_STA) ? 384 : 1024;
	tmp = logcwmin << 16 | preload;
	RAL_WRITE(sc, RT2560_BCNOCSR, tmp);

	/* finally, enable TSF synchronization */
	tmp = RT2560_ENABLE_TSF | RT2560_ENABLE_TBCN;
	if (ic->ic_opmode == IEEE80211_M_STA)
		tmp |= RT2560_ENABLE_TSF_SYNC(1);
#ifndef IEEE80211_STA_ONLY
	else
		tmp |= RT2560_ENABLE_TSF_SYNC(2) |
		       RT2560_ENABLE_BEACON_GENERATOR;
#endif
	RAL_WRITE(sc, RT2560_CSR14, tmp);

	DPRINTF(("enabling TSF synchronization\n"));
}

void
rt2560_update_plcp(struct rt2560_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	/* no short preamble for 1Mbps */
	RAL_WRITE(sc, RT2560_PLCP1MCSR, 0x00700400);

	if (!(ic->ic_flags & IEEE80211_F_SHPREAMBLE)) {
		/* values taken from the reference driver */
		RAL_WRITE(sc, RT2560_PLCP2MCSR,   0x00380401);
		RAL_WRITE(sc, RT2560_PLCP5p5MCSR, 0x00150402);
		RAL_WRITE(sc, RT2560_PLCP11MCSR,  0x000b8403);
	} else {
		/* same values as above or'ed 0x8 */
		RAL_WRITE(sc, RT2560_PLCP2MCSR,   0x00380409);
		RAL_WRITE(sc, RT2560_PLCP5p5MCSR, 0x0015040a);
		RAL_WRITE(sc, RT2560_PLCP11MCSR,  0x000b840b);
	}

	DPRINTF(("updating PLCP for %s preamble\n",
	    (ic->ic_flags & IEEE80211_F_SHPREAMBLE) ? "short" : "long"));
}

void
rt2560_updateslot(struct ieee80211com *ic)
{
	struct rt2560_softc *sc = ic->ic_if.if_softc;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
		/*
		 * In HostAP mode, we defer setting of new slot time until
		 * updated ERP Information Element has propagated to all
		 * associated STAs.
		 */
		sc->sc_flags |= RT2560_UPDATE_SLOT;
	} else
#endif
		rt2560_set_slottime(sc);
}

/*
 * IEEE 802.11a (and possibly 802.11g) use short slot time. Refer to
 * IEEE Std 802.11-1999 pp. 85 to know how these values are computed.
 */
void
rt2560_set_slottime(struct rt2560_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t slottime;
	uint16_t sifs, pifs, difs, eifs;
	uint32_t tmp;

	slottime = (ic->ic_flags & IEEE80211_F_SHSLOT) ?
	    IEEE80211_DUR_DS_SHSLOT : IEEE80211_DUR_DS_SLOT;

	/* define the MAC slot boundaries */
	sifs = RAL_SIFS - RT2560_RXTX_TURNAROUND;
	pifs = sifs + slottime;
	difs = sifs + 2 * slottime;
	eifs = (ic->ic_curmode == IEEE80211_MODE_11B) ? 364 : 60;

	tmp = RAL_READ(sc, RT2560_CSR11);
	tmp = (tmp & ~0x1f00) | slottime << 8;
	RAL_WRITE(sc, RT2560_CSR11, tmp);

	tmp = pifs << 16 | sifs;
	RAL_WRITE(sc, RT2560_CSR18, tmp);

	tmp = eifs << 16 | difs;
	RAL_WRITE(sc, RT2560_CSR19, tmp);

	DPRINTF(("setting slottime to %uus\n", slottime));
}

void
rt2560_set_basicrates(struct rt2560_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	/* update basic rate set */
	if (ic->ic_curmode == IEEE80211_MODE_11B) {
		/* 11b basic rates: 1, 2Mbps */
		RAL_WRITE(sc, RT2560_ARSP_PLCP_1, 0x3);
	} else {
		/* 11b/g basic rates: 1, 2, 5.5, 11Mbps */
		RAL_WRITE(sc, RT2560_ARSP_PLCP_1, 0xf);
	}
}

void
rt2560_update_led(struct rt2560_softc *sc, int led1, int led2)
{
	uint32_t tmp;

	/* set ON period to 70ms and OFF period to 30ms */
	tmp = led1 << 16 | led2 << 17 | 70 << 8 | 30;
	RAL_WRITE(sc, RT2560_LEDCSR, tmp);
}

void
rt2560_set_bssid(struct rt2560_softc *sc, uint8_t *bssid)
{
	uint32_t tmp;

	tmp = bssid[0] | bssid[1] << 8 | bssid[2] << 16 | bssid[3] << 24;
	RAL_WRITE(sc, RT2560_CSR5, tmp);

	tmp = bssid[4] | bssid[5] << 8;
	RAL_WRITE(sc, RT2560_CSR6, tmp);

	DPRINTF(("setting BSSID to %s\n", ether_sprintf(bssid)));
}

void
rt2560_set_macaddr(struct rt2560_softc *sc, uint8_t *addr)
{
	uint32_t tmp;

	tmp = addr[0] | addr[1] << 8 | addr[2] << 16 | addr[3] << 24;
	RAL_WRITE(sc, RT2560_CSR3, tmp);

	tmp = addr[4] | addr[5] << 8;
	RAL_WRITE(sc, RT2560_CSR4, tmp);

	DPRINTF(("setting MAC address to %s\n", ether_sprintf(addr)));
}

void
rt2560_get_macaddr(struct rt2560_softc *sc, uint8_t *addr)
{
	uint32_t tmp;

	tmp = RAL_READ(sc, RT2560_CSR3);
	addr[0] = tmp & 0xff;
	addr[1] = (tmp >>  8) & 0xff;
	addr[2] = (tmp >> 16) & 0xff;
	addr[3] = (tmp >> 24);

	tmp = RAL_READ(sc, RT2560_CSR4);
	addr[4] = tmp & 0xff;
	addr[5] = (tmp >> 8) & 0xff;
}

void
rt2560_update_promisc(struct rt2560_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t tmp;

	tmp = RAL_READ(sc, RT2560_RXCSR0);

	tmp &= ~RT2560_DROP_NOT_TO_ME;
	if (!(ifp->if_flags & IFF_PROMISC))
		tmp |= RT2560_DROP_NOT_TO_ME;

	RAL_WRITE(sc, RT2560_RXCSR0, tmp);

	DPRINTF(("%s promiscuous mode\n", (ifp->if_flags & IFF_PROMISC) ?
	    "entering" : "leaving"));
}

void
rt2560_set_txantenna(struct rt2560_softc *sc, int antenna)
{
	uint32_t tmp;
	uint8_t tx;

	tx = rt2560_bbp_read(sc, RT2560_BBP_TX) & ~RT2560_BBP_ANTMASK;
	if (antenna == 1)
		tx |= RT2560_BBP_ANTA;
	else if (antenna == 2)
		tx |= RT2560_BBP_ANTB;
	else
		tx |= RT2560_BBP_DIVERSITY;

	/* need to force I/Q flip for RF 2525e, 2526 and 5222 */
	if (sc->rf_rev == RT2560_RF_2525E || sc->rf_rev == RT2560_RF_2526 ||
	    sc->rf_rev == RT2560_RF_5222)
		tx |= RT2560_BBP_FLIPIQ;

	rt2560_bbp_write(sc, RT2560_BBP_TX, tx);

	/* update values for CCK and OFDM in BBPCSR1 */
	tmp = RAL_READ(sc, RT2560_BBPCSR1) & ~0x00070007;
	tmp |= (tx & 0x7) << 16 | (tx & 0x7);
	RAL_WRITE(sc, RT2560_BBPCSR1, tmp);
}

void
rt2560_set_rxantenna(struct rt2560_softc *sc, int antenna)
{
	uint8_t rx;

	rx = rt2560_bbp_read(sc, RT2560_BBP_RX) & ~RT2560_BBP_ANTMASK;
	if (antenna == 1)
		rx |= RT2560_BBP_ANTA;
	else if (antenna == 2)
		rx |= RT2560_BBP_ANTB;
	else
		rx |= RT2560_BBP_DIVERSITY;

	/* need to force no I/Q flip for RF 2525e and 2526 */
	if (sc->rf_rev == RT2560_RF_2525E || sc->rf_rev == RT2560_RF_2526)
		rx &= ~RT2560_BBP_FLIPIQ;

	rt2560_bbp_write(sc, RT2560_BBP_RX, rx);
}

const char *
rt2560_get_rf(int rev)
{
	switch (rev) {
	case RT2560_RF_2522:	return "RT2522";
	case RT2560_RF_2523:	return "RT2523";
	case RT2560_RF_2524:	return "RT2524";
	case RT2560_RF_2525:	return "RT2525";
	case RT2560_RF_2525E:	return "RT2525e";
	case RT2560_RF_2526:	return "RT2526";
	case RT2560_RF_5222:	return "RT5222";
	default:		return "unknown";
	}
}

void
rt2560_read_eeprom(struct rt2560_softc *sc)
{
	uint16_t val;
	int i;

	val = rt2560_eeprom_read(sc, RT2560_EEPROM_CONFIG0);
	sc->rf_rev =   (val >> 11) & 0x1f;
	sc->hw_radio = (val >> 10) & 0x1;
	sc->led_mode = (val >> 6)  & 0x7;
	sc->rx_ant =   (val >> 4)  & 0x3;
	sc->tx_ant =   (val >> 2)  & 0x3;
	sc->nb_ant =   val & 0x3;

	/* read default values for BBP registers */
	for (i = 0; i < 16; i++) {
		val = rt2560_eeprom_read(sc, RT2560_EEPROM_BBP_BASE + i);
		sc->bbp_prom[i].reg = val >> 8;
		sc->bbp_prom[i].val = val & 0xff;
	}

	/* read Tx power for all b/g channels */
	for (i = 0; i < 14 / 2; i++) {
		val = rt2560_eeprom_read(sc, RT2560_EEPROM_TXPOWER + i);
		sc->txpow[i * 2] = val >> 8;
		sc->txpow[i * 2 + 1] = val & 0xff;
	}
}

int
rt2560_bbp_init(struct rt2560_softc *sc)
{
	int i, ntries;

	/* wait for BBP to be ready */
	for (ntries = 0; ntries < 100; ntries++) {
		if (rt2560_bbp_read(sc, RT2560_BBP_VERSION) != 0)
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for BBP\n", sc->sc_dev.dv_xname);
		return EIO;
	}

	/* initialize BBP registers to default values */
	for (i = 0; i < nitems(rt2560_def_bbp); i++) {
		rt2560_bbp_write(sc, rt2560_def_bbp[i].reg,
		    rt2560_def_bbp[i].val);
	}
#if 0
	/* initialize BBP registers to values stored in EEPROM */
	for (i = 0; i < 16; i++) {
		if (sc->bbp_prom[i].reg == 0xff)
			continue;
		rt2560_bbp_write(sc, sc->bbp_prom[i].reg, sc->bbp_prom[i].val);
	}
#endif

	return 0;
}

int
rt2560_init(struct ifnet *ifp)
{
	struct rt2560_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;
	int i;

	/* for CardBus, power on the socket */
	if (!(sc->sc_flags & RT2560_ENABLED)) {
		if (sc->sc_enable != NULL && (*sc->sc_enable)(sc) != 0) {
			printf("%s: could not enable device\n",
			    sc->sc_dev.dv_xname);
			return EIO;
		}
		sc->sc_flags |= RT2560_ENABLED;
	}

	rt2560_stop(ifp, 0);

	/* setup tx rings */
	tmp = RT2560_PRIO_RING_COUNT << 24 |
	      RT2560_ATIM_RING_COUNT << 16 |
	      RT2560_TX_RING_COUNT   <<  8 |
	      RT2560_TX_DESC_SIZE;

	/* rings _must_ be initialized in this _exact_ order! */
	RAL_WRITE(sc, RT2560_TXCSR2, tmp);
	RAL_WRITE(sc, RT2560_TXCSR3, sc->txq.physaddr);
	RAL_WRITE(sc, RT2560_TXCSR5, sc->prioq.physaddr);
	RAL_WRITE(sc, RT2560_TXCSR4, sc->atimq.physaddr);
	RAL_WRITE(sc, RT2560_TXCSR6, sc->bcnq.physaddr);

	/* setup rx ring */
	tmp = RT2560_RX_RING_COUNT << 8 | RT2560_RX_DESC_SIZE;

	RAL_WRITE(sc, RT2560_RXCSR1, tmp);
	RAL_WRITE(sc, RT2560_RXCSR2, sc->rxq.physaddr);

	/* initialize MAC registers to default values */
	for (i = 0; i < nitems(rt2560_def_mac); i++)
		RAL_WRITE(sc, rt2560_def_mac[i].reg, rt2560_def_mac[i].val);

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	rt2560_set_macaddr(sc, ic->ic_myaddr);

	/* set basic rate set (will be updated later) */
	RAL_WRITE(sc, RT2560_ARSP_PLCP_1, 0x153);

	rt2560_set_slottime(sc);
	rt2560_update_plcp(sc);
	rt2560_update_led(sc, 0, 0);

	RAL_WRITE(sc, RT2560_CSR1, RT2560_RESET_ASIC);
	RAL_WRITE(sc, RT2560_CSR1, RT2560_HOST_READY);

	if (rt2560_bbp_init(sc) != 0) {
		rt2560_stop(ifp, 1);
		return EIO;
	}

	rt2560_set_txantenna(sc, 1);
	rt2560_set_rxantenna(sc, 1);

	/* set default BSS channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	rt2560_set_chan(sc, ic->ic_bss->ni_chan);

	/* kick Rx */
	tmp = RT2560_DROP_PHY_ERROR | RT2560_DROP_CRC_ERROR;
	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
		tmp |= RT2560_DROP_CTL | RT2560_DROP_VERSION_ERROR;
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode != IEEE80211_M_HOSTAP)
#endif
			tmp |= RT2560_DROP_TODS;
		if (!(ifp->if_flags & IFF_PROMISC))
			tmp |= RT2560_DROP_NOT_TO_ME;
	}
	RAL_WRITE(sc, RT2560_RXCSR0, tmp);

	/* clear old FCS and Rx FIFO errors */
	RAL_READ(sc, RT2560_CNT0);
	RAL_READ(sc, RT2560_CNT4);

	/* clear any pending interrupts */
	RAL_WRITE(sc, RT2560_CSR7, 0xffffffff);

	/* enable interrupts */
	RAL_WRITE(sc, RT2560_CSR8, RT2560_INTR_MASK);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	return 0;
}

void
rt2560_stop(struct ifnet *ifp, int disable)
{
	struct rt2560_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	sc->sc_tx_timer = 0;
	sc->sc_flags &= ~(RT2560_PRIO_OACTIVE|RT2560_DATA_OACTIVE);
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);	/* free all nodes */

	/* abort Tx */
	RAL_WRITE(sc, RT2560_TXCSR0, RT2560_ABORT_TX);

	/* disable Rx */
	RAL_WRITE(sc, RT2560_RXCSR0, RT2560_DISABLE_RX);

	/* reset ASIC (and thus, BBP) */
	RAL_WRITE(sc, RT2560_CSR1, RT2560_RESET_ASIC);
	RAL_WRITE(sc, RT2560_CSR1, 0);

	/* disable interrupts */
	RAL_WRITE(sc, RT2560_CSR8, 0xffffffff);

	/* clear any pending interrupt */
	RAL_WRITE(sc, RT2560_CSR7, 0xffffffff);

	/* reset Tx and Rx rings */
	rt2560_reset_tx_ring(sc, &sc->txq);
	rt2560_reset_tx_ring(sc, &sc->atimq);
	rt2560_reset_tx_ring(sc, &sc->prioq);
	rt2560_reset_tx_ring(sc, &sc->bcnq);
	rt2560_reset_rx_ring(sc, &sc->rxq);

	/* for CardBus, power down the socket */
	if (disable && sc->sc_disable != NULL) {
		if (sc->sc_flags & RT2560_ENABLED) {
			(*sc->sc_disable)(sc);
			sc->sc_flags &= ~RT2560_ENABLED;
		}
	}
}

struct cfdriver ral_cd = {
	NULL, "ral", DV_IFNET
};
@


1.82
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.81 2016/10/06 15:18:48 stsp Exp $  */
d2359 2
a2360 1
	slottime = (ic->ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;
@


1.81
log
@Disable RTS for long frames in ral(4) for rt2560 chips.
On these chips RTS causes bad performance in hostap mode for unknown reasons.

Convert some debug printfs to DPRINTF.
Add a comment which explains why 2 free slots are needed on the Tx queue.

ok phessler@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.80 2016/04/13 10:49:26 mpi Exp $  */
a942 1
			ifp->if_opackets++;
a949 1
			ifp->if_opackets++;
@


1.80
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.79 2015/12/05 12:13:55 dlg Exp $  */
d269 3
d965 2
a966 2
			printf("%s: sending data frame failed 0x%08x\n",
			    sc->sc_dev.dv_xname, letoh32(desc->flags));
d968 1
d1038 3
a1040 2
			printf("%s: sending mgt frame failed 0x%08x\n",
			    sc->sc_dev.dv_xname, letoh32(desc->flags));
d1953 2
@


1.79
log
@ifq_deq_rollback without a preceding ifq_deq_begin is fail.

caused by a badly managed merge.

found by and testing by sebastia@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.78 2015/11/25 03:09:58 dlg Exp $  */
a260 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.78
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.77 2015/11/24 13:33:17 mpi Exp $  */
a1949 1
				ifq_deq_rollback(&ifp->if_snd, m0);
@


1.77
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.76 2015/11/20 12:41:29 mpi Exp $  */
d994 1
a994 1
			ifp->if_flags &= ~IFF_OACTIVE;
d1065 1
a1065 1
			ifp->if_flags &= ~IFF_OACTIVE;
d1926 1
a1926 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1932 1
a1932 1
				ifp->if_flags |= IFF_OACTIVE;
d1951 1
a1951 1
				ifp->if_flags |= IFF_OACTIVE;
a2678 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2680 1
d2699 2
a2700 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.76
log
@Check for space on the ring before dequeuing packets.

Allows us to get rid of mq_requeue(9) and IFQ_POLL(9) because wireless
drivers use a special queue for management frames.

Tested by stsp@@, ok dlg@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.75 2015/11/20 03:35:22 dlg Exp $  */
a47 1
#include <net/if_types.h>
@


1.75
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.74 2015/11/04 12:11:59 dlg Exp $  */
d1931 1
a1931 2
		m0 = mq_dequeue(&ic->ic_mgtq);
		if (m0 != NULL) {
a1934 1
				mq_requeue(&ic->ic_mgtq, m0);
d1938 3
a1949 5
			if (ic->ic_state != IEEE80211_S_RUN)
				break;
			m0 = ifq_deq_begin(&ifp->if_snd);
			if (m0 == NULL)
				break;
d1956 7
a1962 1
			ifq_deq_commit(&ifp->if_snd, m0);
@


1.74
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.73 2015/10/25 12:48:46 mpi Exp $  */
d1951 1
a1951 1
			IFQ_POLL(&ifp->if_snd, m0);
d1955 1
d1960 1
a1960 1
			IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.73
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.72 2015/09/09 19:26:05 deraadt Exp $  */
d1931 1
a1931 1
		IF_POLL(&ic->ic_mgtq, m0);
d1936 1
a1938 1
			IF_DEQUEUE(&ic->ic_mgtq, m0);
@


1.72
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.71 2015/03/14 03:38:47 jsg Exp $  */
a2008 1
	struct ifaddr *ifa;
a2015 1
		ifa = (struct ifaddr *)data;
a2016 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.71
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.70 2015/02/10 23:25:46 mpi Exp $  */
d479 1
a479 1
		free(ring->data, M_DEVBUF, 0);
d634 1
a634 1
		free(ring->data, M_DEVBUF, 0);
@


1.70
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.69 2014/12/22 02:28:51 tedu Exp $  */
a45 1
#include <net/if_arp.h>
@


1.69
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.68 2014/12/19 22:44:58 guenther Exp $  */
a1167 1
		m->m_pkthdr.rcvif = ifp;
@


1.68
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.67 2014/09/06 05:41:35 jsg Exp $  */
a2020 1
#ifdef INET
a2022 1
#endif
@


1.67
log
@reduce the amount of pci includes
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.66 2014/07/22 13:12:12 mpi Exp $  */
d37 1
a39 1
#include <machine/endian.h>
@


1.66
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.65 2014/07/13 23:10:23 deraadt Exp $  */
a59 4

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
@


1.65
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.64 2014/07/12 18:48:17 tedu Exp $  */
a51 1
#include <netinet/in_systm.h>
a52 1
#include <netinet/ip.h>
@


1.64
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.63 2014/03/19 10:09:19 mpi Exp $  */
d391 2
a392 2
	ring->data = malloc(count * sizeof (struct rt2560_tx_data), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
d535 2
a536 2
	ring->data = malloc(count * sizeof (struct rt2560_rx_data), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
@


1.63
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.62 2013/12/06 21:03:03 deraadt Exp $  */
d486 1
a486 1
		free(ring->data, M_DEVBUF);
d641 1
a641 1
		free(ring->data, M_DEVBUF);
@


1.62
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.61 2013/08/07 01:06:30 bluhm Exp $  */
d1948 1
a1948 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
@


1.61
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.60 2012/07/13 10:08:15 stsp Exp $  */
d336 1
a336 1
rt2560_resume(void *xsc)
@


1.60
log
@Keep separate OACTIVE flags to mark full management/data tx queues,
and set the interface's IFF_OACTIVE flag if either queue is full and
clear it only if both queues have free slots. Before this change both
queues were setting/clearing the same flag with no regard for the
other queue's state.

Also, don't reset the tx watchdog counter if either queue still has frames
queued when we exit the frame-processing loop in the per-queue interrupt
handlers.

Both changes originally from sephe@@dragonfly.

Tested by myself and edd on a slow busy soekris which before this
change required occasional 'ifconfig ral0 down up' to recover.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.59 2012/07/13 07:48:31 stsp Exp $  */
a52 1
#include <netinet/in_var.h>
@


1.59
log
@Init the baseband processor before selecting antennas since selecting antennas
involves tweaking of BBP registers. Wait for BBP to stop being busy before
reading from it.

Originally from sephe@@dragonfly. ok kettenis sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.58 2011/02/22 20:05:03 kettenis Exp $  */
d998 8
a1005 3
	sc->sc_tx_timer = 0;
	ifp->if_flags &= ~IFF_OACTIVE;
	rt2560_start(ifp);
d1069 8
a1076 3
	sc->sc_tx_timer = 0;
	ifp->if_flags &= ~IFF_OACTIVE;
	rt2560_start(ifp);
d1944 1
d1966 1
d2711 1
@


1.58
log
@Mark descriptors as invalid *before* unmapping the associated mbuf.
Might prevent the unrecoverable DMA error mentioned in PR 6557.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.57 2010/09/07 16:21:42 deraadt Exp $  */
d2105 10
a2638 2
	rt2560_set_txantenna(sc, 1);
	rt2560_set_rxantenna(sc, 1);
d2650 3
@


1.57
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.56 2010/09/06 19:20:21 deraadt Exp $  */
d977 7
a991 7
		/* descriptor is no longer valid */
		desc->flags &= ~htole32(RT2560_TX_VALID);

		bus_dmamap_sync(sc->sc_dmat, sc->txq.map,
		    sc->txq.next * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
		    BUS_DMASYNC_PREWRITE);

d1043 7
a1056 7

		/* descriptor is no longer valid */
		desc->flags &= ~htole32(RT2560_TX_VALID);

		bus_dmamap_sync(sc->sc_dmat, sc->prioq.map,
		    sc->prioq.next * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
		    BUS_DMASYNC_PREWRITE);
@


1.56
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.55 2010/09/06 18:22:00 kettenis Exp $  */
a150 1
void		rt2560_powerhook(int, void *);
a295 6

	sc->sc_powerhook = powerhook_establish(rt2560_powerhook, sc);
	if (sc->sc_powerhook == NULL) {
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);
	}
a313 3
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);

a2722 18
}

void
rt2560_powerhook(int why, void *arg)
{
	struct rt2560_softc *sc = arg;
	int s;

	s = splnet();
	switch (why) {
	case DVACT_SUSPEND:
		rt2560_suspend(sc);
		break;
	case DVACT_RESUME:
		rt2560_resume(sc);
		break;
	}
	splx(s);
@


1.55
log
@Make the interrupt handler bail out early if the device wen away.  Fixes
freezes that occur when removing CardBus cards when the interface is up.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.54 2010/08/28 18:08:07 deraadt Exp $  */
d2743 1
a2743 1
	case PWR_SUSPEND:
d2746 1
a2746 1
	case PWR_RESUME:
@


1.54
log
@rename the *_power functions to *_powerhook to indicate that we've been
here already for the activate/powerhook cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.53 2010/08/27 17:08:00 jsg Exp $  */
d1340 4
a1343 1
	if ((r = RAL_READ(sc, RT2560_CSR7)) == 0)
@


1.53
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.52 2010/08/27 16:06:25 kettenis Exp $  */
d151 1
a151 1
void		rt2560_power(int, void *);
d298 1
a298 1
	sc->sc_powerhook = powerhook_establish(rt2560_power, sc);
d2733 1
a2733 1
rt2560_power(int why, void *arg)
@


1.52
log
@Stop calling xxx_power() from xxx_resume(); instead do it the other way around.
Get rid of the sc_power() callback, which isn't used anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.51 2010/08/27 04:09:18 deraadt Exp $  */
a267 1
	ifp->if_init = rt2560_init;
@


1.51
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.50 2010/08/25 21:37:59 kettenis Exp $  */
d351 1
d353 2
a354 1
	rt2560_power(PWR_RESUME, sc);
a2736 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d2742 1
a2742 3
		rt2560_stop(ifp, 0);
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
d2745 1
a2745 5
		if (ifp->if_flags & IFF_UP) {
			rt2560_init(ifp);
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, why);
		}
@


1.50
log
@Make CardBus ral(4) suspend and resume properly on machines that keep the
CardBus bridge powered up during suspend.  Step zero on the long road
towards fully suspending CardBus on all machines.

ok deraadt@@, damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.49 2010/08/04 19:48:33 damien Exp $  */
a2740 1
	case PWR_STANDBY:
@


1.49
log
@add suspend/resume support for PCI ral(4) devices.

ok deraadt@@, sthen@@

tested by matthew@@ (RT2560), dcoppa@@ (RT2790), okan@@ (RT2860), todd@@ (RT2560)
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.48 2010/05/19 15:27:35 oga Exp $  */
d344 1
a344 1
		rt2560_stop(ifp, 0);
@


1.48
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.47 2010/04/20 22:05:43 tedu Exp $  */
d337 18
a2737 2
	DPRINTF(("%s: rt2560_power(%d)\n", sc->sc_dev.dv_xname, why));

d2742 1
a2742 1
		rt2560_stop(ifp, 1);
a2750 2
			if (ifp->if_flags & IFF_RUNNING)
				rt2560_start(ifp);
@


1.47
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.46 2009/11/01 12:08:36 damien Exp $  */
d357 1
a357 1
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a380 1
	memset(ring->desc, 0, count * RT2560_TX_DESC_SIZE);
d501 1
a501 1
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a524 1
	memset(ring->desc, 0, count * RT2560_RX_DESC_SIZE);
@


1.46
log
@call powerhook_disestablish() and pci_intr_disestablish() earlier.

diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.45 2009/08/10 17:47:23 damien Exp $  */
a28 1
#include <sys/sysctl.h>
@


1.45
log
@three more shutdown hooks bite the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.44 2009/07/29 17:46:31 blambert Exp $  */
d323 3
a327 3
	
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);
@


1.44
log
@timeout_add -> timeout_add_msec

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.43 2009/03/29 21:53:52 sthen Exp $  */
a299 8
	/*
	 * Make sure the interface is shutdown during reboot.
	 */
	sc->sc_sdhook = shutdownhook_establish(rt2560_shutdown, sc);
	if (sc->sc_sdhook == NULL) {
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    sc->sc_dev.dv_xname);
	}
a327 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
a2743 8
}

void
rt2560_shutdown(void *arg)
{
	struct rt2560_softc *sc = arg;

	rt2560_stop(&sc->sc_ic.ic_if, 1);
@


1.43
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.42 2008/12/22 18:20:47 damien Exp $  */
d718 1
a718 1
	timeout_add(&sc->amrr_to, hz / 2);
d761 1
a761 1
		timeout_add(&sc->scan_to, hz / 5);
d812 1
a812 1
				timeout_add(&sc->amrr_to, hz / 2);
@


1.42
log
@I swapped MGETHDR arguments in my m_defrag removal commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.41 2008/12/21 18:19:58 damien Exp $  */
d379 1
a379 1
		printf("%s: could not map desc DMA memory\n",
d524 1
a524 1
		printf("%s: could not map desc DMA memory\n",
d1564 1
a1564 1
		printf("%s: could not map mbuf (error %d)\n",
d1624 1
a1624 1
		printf("%s: could not map mbuf (error %d)\n",
d1787 1
a1787 1
			printf("%s: could not map mbuf (error %d)\n",
d1824 1
a1824 1
		printf("%s: could not map mbuf (error %d)\n",
d1852 1
a1852 1
			printf("%s: could not map mbuf (error %d)\n",
@


1.41
log
@Undo m_defrag().

m_defrag() does not work.  It seems to assume that if the length of
the mbuf passed as parameter is less than MHLEN, then it is an mbuf
header and not a cluster (or something like that.)
It thus fails miserably in the bcopy path.
I don't have the time to investigate further into this.

Thanks to Okan Demirmen for reporting the issue on a ral(4) RT2560.
The RT2560 chipset does not support TX scatter and thus m_defrag()
was called much more often than in other drivers using m_defrag()
where it was less noticeable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.40 2008/11/25 21:43:57 damien Exp $  */
d1831 1
a1831 1
		MGETHDR(m1, MT_DATA, M_DONTWAIT);
@


1.40
log
@use shiny new m_defrag() and nitems() instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.39 2008/08/27 09:05:03 damien Exp $  */
d1702 1
d1831 2
a1832 1
		if (m_defrag(m0, M_DONTWAIT) != 0) {
d1834 9
a1842 1
			return ENOMEM;
d1844 5
@


1.39
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.38 2008/08/14 16:02:24 damien Exp $  */
a1701 1
	struct mbuf *mnew;
d1830 1
a1830 3

		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
a1833 15
		M_DUP_PKTHDR(mnew, m0);
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(mnew, M_DONTWAIT);
			if (!(mnew->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(mnew);
				return ENOMEM;
			}
		}

		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(mnew, caddr_t));
		m_freem(m0);
		mnew->m_len = mnew->m_pkthdr.len;
		m0 = mnew;

a2535 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d2550 1
a2550 1
	for (i = 0; i < N(rt2560_def_bbp); i++) {
a2563 1
#undef N
a2568 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d2606 1
a2606 1
	for (i = 0; i < N(rt2560_def_mac); i++)
a2664 1
#undef N
@


1.38
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.37 2008/07/21 18:43:19 damien Exp $  */
d105 1
d107 1
d118 1
d121 1
d243 2
a245 1
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
d247 1
d712 1
d715 1
a741 1
	struct mbuf *m;
d784 1
d787 1
a787 1
			m = ieee80211_beacon_alloc(ic, ni);
d799 1
d1280 1
d1319 1
d1347 1
d1350 1
d1548 1
d1604 1
d1663 1
d1669 1
d2288 1
d2292 1
d2327 1
d2336 1
d2658 1
d2660 1
@


1.37
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.36 2008/04/16 18:32:15 damien Exp $  */
a1215 7

	/*
	 * In HostAP mode, ieee80211_input() will enqueue packets in if_snd
	 * without calling if_start().
	 */
	if (!IFQ_IS_EMPTY(&ifp->if_snd) && !(ifp->if_flags & IFF_OACTIVE))
		rt2560_start(ifp);
@


1.36
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.35 2007/11/17 14:29:11 damien Exp $  */
d1074 1
d1197 4
a1200 1
		ieee80211_input(ifp, m, ni, desc->rssi, 0);
@


1.35
log
@RT2560+RT2661: update the physical address in the RX descriptor after
bus_dmamap_load() in the case where the same mbuf is reloaded.
RT2661: remove a 2x prototype, fix an error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.34 2007/10/15 01:37:49 fgsch Exp $  */
d245 2
a246 1
	    IEEE80211_C_WEP;		/* s/w WEP */
a1598 1
	struct ifnet *ifp = &ic->ic_if;
a1608 11
	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

a1682 1
	struct ifnet *ifp = &ic->ic_if;
d1687 1
d1695 4
a1698 3
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
@


1.34
log
@more remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.33 2007/09/07 19:05:05 damien Exp $  */
d1143 2
@


1.33
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.32 2007/03/08 21:58:27 deraadt Exp $  */
a1753 1
		uint16_t dur;
@


1.32
log
@XXX commit a workaround (as found in a few other drivers) for the
divide by zero rate bug.  Someone has to find the source of this
bug one day; from jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.31 2007/01/24 17:56:24 damien Exp $  */
d389 1
a389 1
	    M_NOWAIT);
a396 1
	memset(ring->data, 0, count * sizeof (struct rt2560_tx_data));
d534 1
a534 1
	    M_NOWAIT);
a544 1
	memset(ring->data, 0, count * sizeof (struct rt2560_rx_data));
d646 2
a647 6
	struct rt2560_node *rn;

	rn = malloc(sizeof (struct rt2560_node), M_DEVBUF, M_NOWAIT);
	if (rn != NULL)
		bzero(rn, sizeof (struct rt2560_node));
	return (struct ieee80211_node *)rn;
@


1.31
log
@revert changes committed between r1.25 and 1.26.
this breaks some RT2560 adapters.

pointed out by krw@@ and Pierre Riteau.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.30 2007/01/03 18:16:43 claudio Exp $  */
d1733 2
@


1.30
log
@M_DUP_PKTHDR() cleanup. On static buffers M_DUP_PKTHDR() will leak mbuf tags.
See similar rum(4) commit for more info. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.29 2006/12/17 16:24:00 damien Exp $  */
d2631 2
a2643 3

	rt2560_set_txantenna(sc, 1);
	rt2560_set_rxantenna(sc, 1);
@


1.29
log
@fix index of ERP information element in beacons.
still ugly, but correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.28 2006/12/03 16:39:13 damien Exp $  */
a1185 1
			M_DUP_PKTHDR(&mb, m);
d1189 3
a1191 1
			mb.m_pkthdr.len += mb.m_len;
a1643 1
		M_DUP_PKTHDR(&mb, m0);
d1647 3
a1649 1
		mb.m_pkthdr.len += mb.m_len;
a1874 1
		M_DUP_PKTHDR(&mb, m0);
d1878 3
a1880 1
		mb.m_pkthdr.len += mb.m_len;
@


1.28
log
@fix handling of the SIOCS80211CHANNEL ioctl in monitor mode:
don't call xxx_set_chan() if the interface is not up&running.

patch from Steffen Schuetz (st dot sch at gmx dot net) with
minor modifications by me.

closes kernel/5313
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.27 2006/11/26 11:14:18 deraadt Exp $  */
d1584 6
a1589 4
		    8 + 2 + 2 + 2 + ni->ni_esslen + 2 + 1 +
		    ((ic->ic_opmode == IEEE80211_M_IBSS) ? 3 : 6) +
		    2 + ni->ni_rates.rs_nrates +
		    ((ni->ni_rates.rs_nrates > IEEE80211_RATE_SIZE) ? 2 : 0) +
@


1.27
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.26 2006/11/22 20:54:56 damien Exp $  */
d2052 3
a2054 1
			rt2560_set_chan(sc, ic->ic_ibss_chan);
@


1.26
log
@don't write to BBP before it is ready and fully initialized
-> move rt2560_set{tx,rx}antenna() after rt2560_bbp_init().

from <sephe at dragonflybsd dot org>
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.25 2006/11/13 20:06:38 damien Exp $  */
a149 9
/*
 * Supported rates for 802.11b/g modes (in 500Kbps unit).
 */
static const struct ieee80211_rateset rt2560_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

static const struct ieee80211_rateset rt2560_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d248 2
a249 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = rt2560_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = rt2560_rateset_11g;
@


1.25
log
@first round of commits for proper 11b/g protection support:
- use the newly introduced ieee80211_get_rts() and
  ieee80211_get_cts_to_self() functions.
- use CTS-to-self instead of RTS/CTS to protect OFDM frames in
  a mixed 11b/g BSS.
- make sure multicast frames are sent using CCK modulation.

remove support for 5GHz radios in ral(4) RT2560 and ural(4).
i'm not aware of any such adapters on the market and 11a code
is known to be broken.

some cleanup while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.24 2006/10/22 12:14:44 damien Exp $  */
a2632 2
	rt2560_set_txantenna(sc, 1);
	rt2560_set_rxantenna(sc, 1);
d2644 3
@


1.24
log
@replace rssadapt(9) with amrr for automatic rate control.
as a side-effect, this should fix all the "bogus xmit rate" panics
users have been complaining about for some time when operating in
HostAP mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.23 2006/09/18 16:20:20 damien Exp $  */
d108 1
a108 1
uint8_t		rt2560_rxrate(struct rt2560_rx_desc *);
a119 2
struct		mbuf *rt2560_get_rts(struct rt2560_softc *,
		    struct ieee80211_frame *, uint16_t);
d151 1
a151 1
 * Supported rates for 802.11a/b/g modes (in 500Kbps unit).
a152 3
static const struct ieee80211_rateset rt2560_rateset_11a =
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };

a181 7
static const struct {
	uint8_t		chan;
	uint32_t	r1, r2, r4;
} rt2560_rf5222[] = {
	RT2560_RF5222
};

a216 1

a222 1

a228 1

a234 1

a255 22
	if (sc->rf_rev == RT2560_RF_5222) {
		/* set supported .11a rates */
		ic->ic_sup_rates[IEEE80211_MODE_11A] = rt2560_rateset_11a;

		/* set supported .11a channels */
		for (i = 36; i <= 64; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 100; i <= 140; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 149; i <= 161; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
	}

a309 1

a426 2
	struct rt2560_tx_desc *desc;
	struct rt2560_tx_data *data;
d430 2
a431 2
		desc = &ring->desc[i];
		data = &ring->data[i];
a460 1
	struct rt2560_tx_data *data;
d474 1
a474 1
			data = &ring->data[i];
a500 2
	struct rt2560_rx_desc *desc;
	struct rt2560_rx_data *data;
d557 2
a558 2
		desc = &sc->rxq.desc[i];
		data = &sc->rxq.data[i];
a574 1

a623 1
	struct rt2560_rx_data *data;
d637 1
a637 1
			data = &ring->data[i];
d753 1
a756 2
		timeout_del(&sc->amrr_to);

a891 1
	struct rt2560_tx_desc *desc;
d899 2
a900 1
		desc = &sc->txq.desc[sc->txq.next_encrypt];
a937 3
	struct rt2560_tx_desc *desc;
	struct rt2560_tx_data *data;
	struct rt2560_node *rn;
d940 3
a942 2
		desc = &sc->txq.desc[sc->txq.next];
		data = &sc->txq.data[sc->txq.next];
a1016 2
	struct rt2560_tx_desc *desc;
	struct rt2560_tx_data *data;
d1019 2
a1020 2
		desc = &sc->prioq.desc[sc->prioq.next];
		data = &sc->prioq.data[sc->prioq.next];
a1086 2
	struct rt2560_rx_desc *desc;
	struct rt2560_rx_data *data;
d1097 4
a1100 2
		desc = &sc->rxq.desc[sc->rxq.cur_decrypt];
		data = &sc->rxq.data[sc->rxq.cur_decrypt];
a1132 1

a1238 3
	struct rt2560_rx_desc *desc;
	struct rt2560_rx_data *data;

d1240 2
a1241 2
		desc = &sc->rxq.desc[sc->rxq.cur];
		data = &sc->rxq.data[sc->rxq.cur];
d1393 1
a1393 1
rt2560_rxrate(struct rt2560_rx_desc *desc)
a1422 1
 * XXX: this should depend on the destination node basic rate set.
d1556 1
a1556 1
	int rate, error;
a1560 2
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;

d1614 1
a1614 1
	int rate, error;
a1618 2
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;

d1665 1
a1665 1
		flags |= RT2560_TX_ACK;
a1697 32
/*
 * Build a RTS control frame.
 */
struct mbuf *
rt2560_get_rts(struct rt2560_softc *sc, struct ieee80211_frame *wh,
    uint16_t dur)
{
	struct ieee80211_frame_rts *rts;
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		sc->sc_ic.ic_stats.is_tx_nombuf++;
		printf("%s: could not allocate RTS frame\n",
		    sc->sc_dev.dv_xname);
		return NULL;
	}

	rts = mtod(m, struct ieee80211_frame_rts *);

	rts->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_CTL |
	    IEEE80211_FC0_SUBTYPE_RTS;
	rts->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	*(uint16_t *)rts->i_dur = htole16(dur);
	IEEE80211_ADDR_COPY(rts->i_ra, wh->i_addr1);
	IEEE80211_ADDR_COPY(rts->i_ta, wh->i_addr2);

	m->m_pkthdr.len = m->m_len = sizeof (struct ieee80211_frame_rts);

	return m;
}

d1704 1
d1711 1
a1711 1
	int rate, useprot, error;
a1714 7
	if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
	} else
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	rate &= IEEE80211_RATE_VAL;

d1724 16
d1747 16
a1762 14
	/*-
	 * IEEE Std 802.11-1999, pp 82: "A STA shall use an RTS/CTS exchange
	 * for directed frames only when the length of the MPDU is greater
	 * than the length threshold indicated by" ic_rtsthreshold.
	 *
	 * IEEE Std 802.11-2003g, pp 13: "ERP STAs shall use protection
	 * mechanism (such as RTS/CTS or CTS-to-self) for ERP-OFDM MPDUs of
	 * type Data or an MMPDU".
	 */
	useprot = !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (m0->m_pkthdr.len + IEEE80211_CRC_LEN > ic->ic_rtsthreshold ||
	     ((ic->ic_flags & IEEE80211_F_USEPROT) && RAL_RATE_IS_OFDM(rate)));
	if (useprot) {
		struct mbuf *m;
a1763 1
		int rtsrate, ackrate;
d1765 2
a1766 2
		rtsrate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;
		ackrate = rt2560_ack_rate(ic, rate);
d1768 1
a1768 2
		dur = rt2560_txtime(m0->m_pkthdr.len + 4, rate, ic->ic_flags) +
		      rt2560_txtime(RAL_CTS_SIZE, rtsrate, ic->ic_flags) +
d1770 10
a1779 5
		      3 * RAL_SIFS;

		m = rt2560_get_rts(sc, wh, dur);
		if (m == NULL) {
			printf("%s: could not allocate RTS frame\n",
d1785 2
a1786 2
		desc = &sc->txq.desc[sc->txq.cur_encrypt];
		data = &sc->txq.data[sc->txq.cur_encrypt];
d1788 1
a1788 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
d1793 1
a1793 1
			m_freem(m);
d1798 1
d1800 1
a1800 1
		ieee80211_ref_node(ni);
d1802 1
a1802 2
		data->m = m;
		data->ni = ni;
d1804 3
a1806 2
		rt2560_setup_tx_desc(sc, desc, RT2560_TX_ACK |
		    RT2560_TX_MORE_FRAG, m->m_pkthdr.len, rtsrate, 1,
d1811 2
a1812 2
		bus_dmamap_sync(sc->sc_dmat, sc->txq.map,
		    sc->txq.cur_encrypt * RT2560_TX_DESC_SIZE,
d1815 3
a1817 3
		sc->txq.queued++;
		sc->txq.cur_encrypt =
		    (sc->txq.cur_encrypt + 1) % RT2560_TX_RING_COUNT;
d1822 2
a1823 2
	data = &sc->txq.data[sc->txq.cur_encrypt];
	desc = &sc->txq.desc[sc->txq.cur_encrypt];
a1840 1

d1893 1
a1893 1
		flags |= RT2560_TX_ACK;
d1905 2
a1906 2
	bus_dmamap_sync(sc->sc_dmat, sc->txq.map,
	    sc->txq.cur_encrypt * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
d1909 2
a1910 2
	DPRINTFN(10, ("sending data frame len=%u idx=%u rate=%u\n",
	    m0->m_pkthdr.len, sc->txq.cur_encrypt, rate));
d1913 3
a1915 2
	sc->txq.queued++;
	sc->txq.cur_encrypt = (sc->txq.cur_encrypt + 1) % RT2560_TX_RING_COUNT;
d2155 1
a2155 1
	u_int i, chan;
d2161 1
a2161 4
	if (IEEE80211_IS_CHAN_2GHZ(c))
		power = min(sc->txpow[chan - 1], 31);
	else
		power = 31;
a2220 10

	/* dual-band RF */
	case RT2560_RF_5222:
		for (i = 0; rt2560_rf5222[i].chan != chan; i++);

		rt2560_rf_write(sc, RT2560_RF1, rt2560_rf5222[i].r1);
		rt2560_rf_write(sc, RT2560_RF2, rt2560_rf5222[i].r2);
		rt2560_rf_write(sc, RT2560_RF3, power << 7 | 0x00040);
		rt2560_rf_write(sc, RT2560_RF4, rt2560_rf5222[i].r4);
		break;
a2378 3
	} else if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
		/* 11a basic rates: 6, 12, 24Mbps */
		RAL_WRITE(sc, RT2560_ARSP_PLCP_1, 0x150);
d2380 2
a2381 2
		/* 11g basic rates: 1, 2, 5.5, 11, 6, 12, 24Mbps */
		RAL_WRITE(sc, RT2560_ARSP_PLCP_1, 0x15f);
@


1.23
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.22 2006/07/18 16:40:30 damien Exp $  */
d59 1
a59 1
#include <net80211/ieee80211_rssadapt.h>
a90 2
void		rt2560_node_copy(struct ieee80211com *ic,
		    struct ieee80211_node *, const struct ieee80211_node *);
d94 3
a96 1
void		rt2560_rssadapt_updatestats(void *);
d202 4
a205 2
	timeout_set(&sc->scan_ch, rt2560_next_scan, sc);
	timeout_set(&sc->rssadapt_ch, rt2560_rssadapt_updatestats, sc);
d319 1
a319 1
	ic->ic_node_copy = rt2560_node_copy;
d369 2
a370 2
	timeout_del(&sc->scan_ch);
	timeout_del(&sc->rssadapt_ch);
d706 3
a708 13
	if (rn == NULL)
		return NULL;

	memset(rn, 0, sizeof (struct rt2560_node));

	return &rn->ni;
}

void
rt2560_node_copy(struct ieee80211com *ic, struct ieee80211_node *dst,
    const struct ieee80211_node *src)
{
	*(struct rt2560_node *)dst = *(const struct rt2560_node *)src;
d736 1
d738 1
d741 1
d750 1
d753 1
a753 1
	ieee80211_rssadapt_updatestats(&rn->rssadapt);
a755 4
/*
 * This function is called periodically (every 100ms) in RUN state to update
 * the rate control statistics.
 */
d757 1
a757 1
rt2560_rssadapt_updatestats(void *arg)
d761 17
d779 1
a779 1
	ieee80211_iterate_nodes(ic, rt2560_iter_func, arg);
d781 5
a785 1
	timeout_add(&sc->rssadapt_ch, hz / 10);
d798 1
a798 1
	timeout_del(&sc->scan_ch);
d802 1
a802 1
		timeout_del(&sc->rssadapt_ch);
d815 1
a815 1
		timeout_add(&sc->scan_ch, hz / 5);
d856 5
d862 4
a865 1
			timeout_add(&sc->rssadapt_ch, hz / 10);
d1007 1
a1007 4
			if (data->id.id_node != NULL) {
				ieee80211_rssadapt_raise_rate(ic,
				    &rn->rssadapt, &data->id);
			}
d1014 2
d1022 2
a1023 4
			if (data->id.id_node != NULL) {
				ieee80211_rssadapt_lower_rate(ic, data->ni,
				    &rn->rssadapt, &data->id);
			}
a1139 1
	struct rt2560_node *rn;
a1254 1

a1260 4
		/* give rssi to the rate control algorithm */
		rn = (struct rt2560_node *)ni;
		ieee80211_rssadapt_input(ic, ni, &rn->rssadapt, desc->rssi);

a1797 2
	struct rt2560_node *rn;
	struct ieee80211_rateset *rs;
a1805 1
	/* XXX this should be reworked! */
d1807 4
a1810 13
		if (ic->ic_curmode != IEEE80211_MODE_AUTO)
			rs = &ic->ic_sup_rates[ic->ic_curmode];
		else
			rs = &ic->ic_sup_rates[IEEE80211_MODE_11G];

		rate = rs->rs_rates[ic->ic_fixed_rate];
	} else {
		rs = &ni->ni_rates;
		rn = (struct rt2560_node *)ni;
		ni->ni_txrate = ieee80211_rssadapt_choose(&rn->rssadapt, rs,
		    wh, m0->m_pkthdr.len, -1, NULL, 0);
		rate = rs->rs_rates[ni->ni_txrate];
	}
a1811 2
	if (rate == 0)
		rate = 2;	/* fallback to 1Mbps; should not happen */
a1880 3
		/* RTS frames are not taken into account for rssadapt */
		data->id.id_node = NULL;

a1967 9

	/* remember link conditions for rate adaptation algorithm */
	if (ic->ic_fixed_rate == -1) {
		data->id.id_len = m0->m_pkthdr.len;
		data->id.id_rateidx = ni->ni_txrate;
		data->id.id_node = ni;
		data->id.id_rssi = ni->ni_rssi;
	} else
		data->id.id_node = NULL;
@


1.22
log
@modify interrupt handlers to exit early and return 0 on shared interrupts.

pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.21 2006/06/18 18:44:04 damien Exp $  */
d2047 1
a2047 1
			IFQ_DEQUEUE(&ifp->if_snd, m0);
a2050 1
				IF_PREPEND(&ifp->if_snd, m0);
d2054 1
@


1.21
log
@- implement new ic_updateslot() callback.
- in hostap mode, we defer update of the slot time until all associated
  STAs are notified with updated beacons.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.20 2006/06/18 12:32:46 damien Exp $  */
d1380 3
d1386 3
a1391 3

	r = RAL_READ(sc, RT2560_CSR7);
	RAL_WRITE(sc, RT2560_CSR7, r);
@


1.20
log
@enable packet bursting when operating as a STA.
limit bursts to 8 frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.19 2006/06/14 19:31:47 damien Exp $  */
d135 2
a136 1
void		rt2560_update_slot(struct rt2560_softc *);
d318 1
d342 5
a346 2
	if (sc->sc_sdhook == NULL)
		printf(": WARNING: unable to establish shutdown hook\n");
d348 4
a351 3
	if (sc->sc_powerhook == NULL)
		printf(": WARNING: unable to establish power hook\n");

d819 2
a820 1
			rt2560_update_slot(sc);
d1329 2
a1330 2
 * This function is called periodically in IBSS mode when a new beacon must be
 * sent out.
d1344 16
a1359 1
#if NBPFILTER > 0
d1506 1
a1506 1
		/* IEEE Std 802.11a-1999, pp. 37 */
d1594 1
d1626 17
d2421 16
d2438 2
a2439 2
 * IEEE 802.11a uses short slot time. Refer to IEEE Std 802.11-1999 pp. 85 to
 * know how these values are computed.
d2442 1
a2442 1
rt2560_update_slot(struct rt2560_softc *sc)
d2738 1
a2738 1
	rt2560_update_slot(sc);
@


1.19
log
@must use RTS/CTS protection when sending frames at OFDM rates in a BSS
with non-ERP STAs.  some bits are missing in net80211 though, so this
code won't be triggered yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.18 2006/06/10 20:30:00 damien Exp $  */
d1781 7
a1856 5
		/*
		 * IEEE Std 802.11-1999: "when an RTS/CTS exchange is used, the
		 * asynchronous data frame shall be transmitted after the CTS
		 * frame and a SIFS period".
		 */
@


1.18
log
@- fix checking of WEP flags
- encrypt mgmt frames when they need to (shared authmode)
- move default MAC/BBP/RF settings from rt2560.c to rt2560reg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.17 2006/06/02 04:30:40 robert Exp $  */
d1676 1
a1676 1
		/* tell hardware to add timestamp for probe responses */
d1749 1
a1749 1
	int rate, error;
d1781 1
a1781 1
	/*
d1784 5
a1788 1
	 * than the length threshold indicated by [...]" ic_rtsthreshold.
d1790 4
a1793 2
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    m0->m_pkthdr.len > ic->ic_rtsthreshold) {
d1807 6
d1851 1
a1851 1
		 * IEEE Std 802.11-1999: when an RTS/CTS exchange is used, the
d1853 1
a1853 1
		 * frame and a SIFS period.
d1994 1
a1994 2
				bpf_mtap(ic->ic_rawbpf, m0,
				    BPF_DIRECTION_OUT);
d2019 1
a2019 2
				bpf_mtap(ic->ic_rawbpf, m0,
				    BPF_DIRECTION_OUT);
d2812 1
a2812 1
	0, "ral", DV_IFNET
@


1.17
log
@add powerhooks for ral(4) cards with the RT2560 chipset;

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.16 2006/06/01 16:52:54 robert Exp $  */
a162 3
/*
 * Default values for MAC registers; values taken from the reference driver.
 */
d167 1
a167 28
	{ RT2560_PSCSR0,      0x00020002 },
	{ RT2560_PSCSR1,      0x00000002 },
	{ RT2560_PSCSR2,      0x00020002 },
	{ RT2560_PSCSR3,      0x00000002 },
	{ RT2560_TIMECSR,     0x00003f21 },
	{ RT2560_CSR9,        0x00000780 },
	{ RT2560_CSR11,       0x07041483 },
	{ RT2560_CNT3,        0x00000000 },
	{ RT2560_TXCSR1,      0x07614562 },
	{ RT2560_ARSP_PLCP_0, 0x8c8d8b8a },
	{ RT2560_ACKPCTCSR,   0x7038140a },
	{ RT2560_ARTCSR1,     0x1d21252d },
	{ RT2560_ARTCSR2,     0x1919191d },
	{ RT2560_RXCSR0,      0xffffffff },
	{ RT2560_RXCSR3,      0xb3aab3af },
	{ RT2560_PCICSR,      0x000003b8 },
	{ RT2560_PWRCSR0,     0x3f3b3100 },
	{ RT2560_GPIOCSR,     0x0000ff00 },
	{ RT2560_TESTCSR,     0x000000f0 },
	{ RT2560_PWRCSR1,     0x000001ff },
	{ RT2560_MACCSR0,     0x00213223 },
	{ RT2560_MACCSR1,     0x00235518 },
	{ RT2560_RLPWCSR,     0x00000040 },
	{ RT2560_RALINKCSR,   0x9a009a11 },
	{ RT2560_CSR7,        0xffffffff },
	{ RT2560_BBPCSR1,     0x82188200 },
	{ RT2560_TXACKCSR0,   0x00000020 },
	{ RT2560_SECCSR3,     0x0000e78f }
a169 3
/*
 * Default values for BBP registers; values taken from the reference driver.
 */
d174 1
a174 41
	{  3, 0x02 },
	{  4, 0x19 },
	{ 14, 0x1c },
	{ 15, 0x30 },
	{ 16, 0xac },
	{ 17, 0x48 },
	{ 18, 0x18 },
	{ 19, 0xff },
	{ 20, 0x1e },
	{ 21, 0x08 },
	{ 22, 0x08 },
	{ 23, 0x08 },
	{ 24, 0x80 },
	{ 25, 0x50 },
	{ 26, 0x08 },
	{ 27, 0x23 },
	{ 30, 0x10 },
	{ 31, 0x2b },
	{ 32, 0xb9 },
	{ 34, 0x12 },
	{ 35, 0x50 },
	{ 39, 0xc4 },
	{ 40, 0x02 },
	{ 41, 0x60 },
	{ 53, 0x10 },
	{ 54, 0x18 },
	{ 56, 0x08 },
	{ 57, 0x10 },
	{ 58, 0x08 },
	{ 61, 0x60 },
	{ 62, 0x10 },
	{ 75, 0xff }
};

/*
 * Default values for RF register R2 indexed by channel numbers; values taken
 * from the reference driver.
 */
static const uint32_t rt2560_rf2522_r2[] = {
	0x307f6, 0x307fb, 0x30800, 0x30805, 0x3080a, 0x3080f, 0x30814,
	0x30819, 0x3081e, 0x30823, 0x30828, 0x3082d, 0x30832, 0x3083e
d177 8
a184 19
static const uint32_t rt2560_rf2523_r2[] = {
	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,
	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346
};

static const uint32_t rt2560_rf2524_r2[] = {
	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,
	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346
};

static const uint32_t rt2560_rf2525_r2[] = {
	0x20327, 0x20328, 0x20329, 0x2032a, 0x2032b, 0x2032c, 0x2032d,
	0x2032e, 0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20346
};

static const uint32_t rt2560_rf2525_hi_r2[] = {
	0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20344, 0x20345,
	0x20346, 0x20347, 0x20348, 0x20349, 0x2034a, 0x2034b, 0x2034e
};
a185 19
static const uint32_t rt2560_rf2525e_r2[] = {
	0x2044d, 0x2044e, 0x2044f, 0x20460, 0x20461, 0x20462, 0x20463,
	0x20464, 0x20465, 0x20466, 0x20467, 0x20468, 0x20469, 0x2046b
};

static const uint32_t rt2560_rf2526_hi_r2[] = {
	0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d, 0x0022d,
	0x0022e, 0x0022e, 0x0022f, 0x0022d, 0x00240, 0x00240, 0x00241
};

static const uint32_t rt2560_rf2526_r2[] = {
	0x00226, 0x00227, 0x00227, 0x00228, 0x00228, 0x00229, 0x00229,
	0x0022a, 0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d
};

/*
 * For dual-band RF, RF registers R1 and R4 also depend on channel number;
 * values taken from the reference driver.
 */
d188 1
a188 3
	uint32_t	r1;
	uint32_t	r2;
	uint32_t	r4;
d190 1
a190 40
	{   1, 0x08808, 0x0044d, 0x00282 },
	{   2, 0x08808, 0x0044e, 0x00282 },
	{   3, 0x08808, 0x0044f, 0x00282 },
	{   4, 0x08808, 0x00460, 0x00282 },
	{   5, 0x08808, 0x00461, 0x00282 },
	{   6, 0x08808, 0x00462, 0x00282 },
	{   7, 0x08808, 0x00463, 0x00282 },
	{   8, 0x08808, 0x00464, 0x00282 },
	{   9, 0x08808, 0x00465, 0x00282 },
	{  10, 0x08808, 0x00466, 0x00282 },
	{  11, 0x08808, 0x00467, 0x00282 },
	{  12, 0x08808, 0x00468, 0x00282 },
	{  13, 0x08808, 0x00469, 0x00282 },
	{  14, 0x08808, 0x0046b, 0x00286 },

	{  36, 0x08804, 0x06225, 0x00287 },
	{  40, 0x08804, 0x06226, 0x00287 },
	{  44, 0x08804, 0x06227, 0x00287 },
	{  48, 0x08804, 0x06228, 0x00287 },
	{  52, 0x08804, 0x06229, 0x00287 },
	{  56, 0x08804, 0x0622a, 0x00287 },
	{  60, 0x08804, 0x0622b, 0x00287 },
	{  64, 0x08804, 0x0622c, 0x00287 },

	{ 100, 0x08804, 0x02200, 0x00283 },
	{ 104, 0x08804, 0x02201, 0x00283 },
	{ 108, 0x08804, 0x02202, 0x00283 },
	{ 112, 0x08804, 0x02203, 0x00283 },
	{ 116, 0x08804, 0x02204, 0x00283 },
	{ 120, 0x08804, 0x02205, 0x00283 },
	{ 124, 0x08804, 0x02206, 0x00283 },
	{ 128, 0x08804, 0x02207, 0x00283 },
	{ 132, 0x08804, 0x02208, 0x00283 },
	{ 136, 0x08804, 0x02209, 0x00283 },
	{ 140, 0x08804, 0x0220a, 0x00283 },

	{ 149, 0x08808, 0x02429, 0x00281 },
	{ 153, 0x08808, 0x0242b, 0x00281 },
	{ 157, 0x08808, 0x0242d, 0x00281 },
	{ 161, 0x08808, 0x0242f, 0x00281 }
d756 1
a756 1
 * the rate adaptation statistics.
d1238 1
a1238 1
		/* give rssi to the rate adatation algorithm */
d1611 1
d1624 11
d1772 1
a1772 1
	if (ic->ic_flags & IEEE80211_F_WEPON) {
@


1.16
log
@Make the debug printfs work if RAL_DEBUG is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.15 2006/04/20 20:31:12 miod Exp $  */
d149 1
d480 10
d510 5
d2893 38
@


1.15
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.14 2006/03/27 20:54:15 damien Exp $  */
d72 1
a72 1
int rt2560_debug = 0;
@


1.14
log
@fixes interrupts processing.

should fix a panic reported by Karel Gardas.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.13 2006/03/25 22:41:43 djm Exp $  */
d2746 2
a2747 1
			printf("%s: could not enable device\n");
@


1.13
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.12 2006/02/25 13:02:10 damien Exp $  */
d1483 1
d1489 4
d2858 3
@


1.12
log
@instead of panicing when tx rate is zero, fallback to 1Mbps.
this is a temporary workaround since we should really not see any node
with an empty rate set but it seems to happen in hostap mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.11 2006/02/18 09:41:41 damien Exp $  */
d1356 1
a1356 1
			bpf_mtap(sc->sc_drvbpf, &mb);
d1467 1
a1467 1
		bpf_mtap(ic->ic_rawbpf, data->m);
d1771 1
a1771 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d2021 1
a2021 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d2093 2
a2094 1
				bpf_mtap(ic->ic_rawbpf, m0);
d2112 1
a2112 1
				bpf_mtap(ifp->if_bpf, m0);
d2119 2
a2120 1
				bpf_mtap(ic->ic_rawbpf, m0);
@


1.12.2.1
log
@MFC:
Fix by damien@@

fixes interrupts processing.

should fix a panic reported by Karel Gardas.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.12 2006/02/25 13:02:10 damien Exp $  */
a1482 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
a1487 4
	/* don't re-enable interrupts if we're shutting down */
	if (!(ifp->if_flags & IFF_RUNNING))
		return 0;

a2850 3

	/* clear any pending interrupt */
	RAL_WRITE(sc, RT2560_CSR7, 0xffffffff);
@


1.11
log
@don't try to release references to nodes that have been freed by net80211.
in HostAP mode, when switching to the INIT state, net80211 sends a DISASSOC
and a DEAUTH frame to all associated stations and immediately free all the
nodes while we may still hold references to them in our Tx queues.

hopefully, this should fix PRs 4469/kernel and 4953/kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.10 2006/01/14 12:43:27 damien Exp $  */
d1880 2
a1881 3

	/* assert tx rate is non-null so we don't end up dividing by zero */
	KASSERT(rate != 0);
@


1.10
log
@- give rate to rx radiotap
- read TSF high 32bit word before low 32bit word to avoid wraparounds
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.7 2006/01/13 17:48:22 damien Exp $  */
d497 1
a497 1
	ieee80211_ifdetach(ifp);
a585 1
	struct ieee80211com *ic = &sc->sc_ic;
d602 5
a606 4
		if (data->ni != NULL) {
			ieee80211_release_node(ic, data->ni);
			data->ni = NULL;
		}
a621 1
	struct ieee80211com *ic = &sc->sc_ic;
d646 5
a650 2
			if (data->ni != NULL)
				ieee80211_release_node(ic, data->ni);
d2074 7
a2833 2
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

d2837 2
@


1.9
log
@Correct the length of the rx radiotap to be that of the rx not tx
struct.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.8 2006/01/13 21:06:09 damien Exp $  */
d107 3
d1336 1
a1337 1
			tsf_hi = RAL_READ(sc, RT2560_CSR17);
d1342 1
d1351 1
a1351 1
			mb.m_len = sc->sc_rxtap_len;
d1525 34
@


1.8
log
@fix short slot time + cosmetic
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.7 2006/01/13 17:48:22 damien Exp $  */
d1347 1
a1347 1
			mb.m_len = sc->sc_txtap_len;
@


1.7
log
@- simplify lookup of 802.11a channels (we know they exist)
- kill two stupid comments while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.6 2006/01/11 21:02:17 damien Exp $  */
d133 1
d400 8
a407 3
	ic->ic_caps = IEEE80211_C_MONITOR | IEEE80211_C_IBSS |
	    IEEE80211_C_HOSTAP | IEEE80211_C_SHPREAMBLE | IEEE80211_C_PMGT |
	    IEEE80211_C_TXPMGT | IEEE80211_C_WEP;
d897 1
d933 1
a933 11
		/* update basic rate set */
		if (ic->ic_curmode == IEEE80211_MODE_11B) {
			/* 11b basic rates: 1, 2Mbps */
			RAL_WRITE(sc, RT2560_ARSP_PLCP_1, 0x3);
		} else if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
			/* 11a basic rates: 6, 12, 24Mbps */
			RAL_WRITE(sc, RT2560_ARSP_PLCP_1, 0x150);
		} else {
			/* 11g basic rates: 1, 2, 5.5, 11, 6, 12, 24Mbps */
			RAL_WRITE(sc, RT2560_ARSP_PLCP_1, 0x15f);
		}
a935 1
			rt2560_set_bssid(sc, ic->ic_bss->ni_bssid);
d937 2
d943 1
a943 1
			m = ieee80211_beacon_alloc(ic, ic->ic_bss);
d951 1
a951 1
			error = rt2560_tx_bcn(sc, m, ic->ic_bss);
d2444 1
a2444 1
	slottime = (ic->ic_curmode == IEEE80211_MODE_11A) ? 9 : 20;
d2463 18
@


1.6
log
@fix RTS protection mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.5 2006/01/10 21:20:46 damien Exp $  */
a289 1
	/* channels in the 2.4GHz band */
a304 1
	/* channels in the 5.2GHz band */
a2252 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d2327 1
a2327 3
		for (i = 0; i < N(rt2560_rf5222); i++)
			if (rt2560_rf5222[i].chan == chan)
				break;
d2329 4
a2332 6
		if (i < N(rt2560_rf5222)) {
			rt2560_rf_write(sc, RT2560_RF1, rt2560_rf5222[i].r1);
			rt2560_rf_write(sc, RT2560_RF2, rt2560_rf5222[i].r2);
			rt2560_rf_write(sc, RT2560_RF3, power << 7 | 0x00040);
			rt2560_rf_write(sc, RT2560_RF4, rt2560_rf5222[i].r4);
		}
a2352 1
#undef N
@


1.5
log
@- use rssadapt(9) as rate control algorithm
- add 802.11 radiotap support
- read 802.11a channels tx power from EEPROM
- read vendor-specific BBP settings from EEPROM
- fix setting of beacons (xflags)
- fix DMA sync in rt2661_rx_intr
- indicate whether RF supports MIMO in dmesg
- add short slot time support
- many cleanups while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.4 2006/01/10 17:47:15 damien Exp $  */
d1881 1
a1881 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
@


1.4
log
@fix reading of EEPROM content on big endian arches.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.3 2006/01/10 17:45:06 damien Exp $  */
d117 1
a117 1
struct mbuf	*rt2560_get_rts(struct rt2560_softc *,
@


1.3
log
@send management, control and beacon frames at the lowest possible rate
(1Mbps for 802.11b/g, 6Mbps for 802.11a)
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.2 2006/01/10 17:40:29 damien Exp $  */
d1028 1
a1028 1
	return letoh16(val);
@


1.2
log
@cleanup rt2560_setup_tx_desc().
fix contention window.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560.c,v 1.1 2006/01/09 20:03:34 damien Exp $  */
d1666 1
a1666 1
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 4;
d1708 1
a1708 1
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 4;
d1868 1
a1868 1
		rtsrate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 4;
@


1.1
log
@- add preliminary support for Ralink Technology RT2561, RT2561S and RT2661
  chipsets in ral(4).
- restructure the code a bit; split ic/ral.c into ic/rt2560.c and ic/rt2661.c
- import the 8051 microcode files required by these chipsets.
- more to come;  there is currently no automatic rate control and some
  features are untested (hostap and ibss modes for instance).  most of
  the pre-802.11n capabilities of the RT2661 chipset are not supported
  (like frame aggregation, piggy-back).  MIMO should work though the
  performance/range gain has not been measured.
@
text
@d1 1
a1 1
/*	$OpenBSD: ral.c,v 1.66 2006/01/04 06:04:41 canacar Exp $  */
a1621 2
	if (RAL_RATE_IS_OFDM(rate))
		desc->flags |= htole32(RT2560_TX_OFDM);
d1625 3
a1627 3
	    RT2560_AIFSN(3) |
	    RT2560_LOGCWMIN(4) |
	    RT2560_LOGCWMAX(6));
d1629 2
a1630 3
	/*
	 * Fill PLCP fields.
	 */
d1633 1
a1633 1
	len += 4; /* account for FCS */
d1635 2
a1636 4
		/*
		 * PLCP length field (LENGTH).
		 * From IEEE Std 802.11a-1999, pp. 14.
		 */
d1638 2
a1639 2
		desc->plcp_length = htole16((plcp_length >> 6) << 8 |
		    (plcp_length & 0x3f));
a1640 4
		/*
		 * Long PLCP LENGTH field.
		 * From IEEE Std 802.11b-1999, pp. 16.
		 */
d1647 5
a1651 1
		desc->plcp_length = htole16(plcp_length);
a1652 4

	desc->plcp_signal = rt2560_plcp_signal(rate);
	if (rate != 2 && (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
		desc->plcp_signal |= 0x08;
@

