head	1.126;
access;
symbols
	OPENBSD_6_1:1.124.0.4
	OPENBSD_6_1_BASE:1.124
	OPENBSD_6_0:1.123.0.4
	OPENBSD_6_0_BASE:1.123
	OPENBSD_5_9:1.122.0.2
	OPENBSD_5_9_BASE:1.122
	OPENBSD_5_8:1.116.0.6
	OPENBSD_5_8_BASE:1.116
	OPENBSD_5_7:1.116.0.2
	OPENBSD_5_7_BASE:1.116
	OPENBSD_5_6:1.108.0.4
	OPENBSD_5_6_BASE:1.108
	OPENBSD_5_5:1.100.0.4
	OPENBSD_5_5_BASE:1.100
	OPENBSD_5_4:1.97.0.4
	OPENBSD_5_4_BASE:1.97
	OPENBSD_5_3:1.97.0.2
	OPENBSD_5_3_BASE:1.97
	OPENBSD_5_2:1.95.0.6
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.95
	OPENBSD_5_1:1.95.0.8
	OPENBSD_5_0:1.95.0.4
	OPENBSD_5_0_BASE:1.95
	OPENBSD_4_9:1.95.0.2
	OPENBSD_4_9_BASE:1.95
	OPENBSD_4_8:1.94.0.2
	OPENBSD_4_8_BASE:1.94
	OPENBSD_4_7:1.91.0.2
	OPENBSD_4_7_BASE:1.91
	OPENBSD_4_6:1.87.0.4
	OPENBSD_4_6_BASE:1.87
	OPENBSD_4_5:1.85.0.2
	OPENBSD_4_5_BASE:1.85
	OPENBSD_4_4:1.77.0.2
	OPENBSD_4_4_BASE:1.77
	OPENBSD_4_3:1.74.0.2
	OPENBSD_4_3_BASE:1.74;
locks; strict;
comment	@ * @;


1.126
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.125;
commitid	uRv5pa9QDlZaYgwD;

1.125
date	2017.07.03.09.21.09;	author kevlo;	state Exp;
branches;
next	1.124;
commitid	Ssa221KhuyTS2oq4;

1.124
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.123;
commitid	VyLWTsbepAOk7VQM;

1.123
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.122;
commitid	QHiEhS9DHyE6oiIr;

1.122
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.121;
commitid	B0kwmVGiD5DVx4kv;

1.121
date	2015.11.12.10.25.03;	author dlg;	state Exp;
branches;
next	1.120;
commitid	htWQd3W7cA1HNsG7;

1.120
date	2015.11.11.10.07.25;	author mpi;	state Exp;
branches;
next	1.119;
commitid	9FpLdI4B7Tx69D1N;

1.119
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.118;
commitid	YT6fyIEviv9qwbl6;

1.118
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.117;
commitid	p0v5tuE1Ch6fY0Nj;

1.117
date	2015.08.29.20.55.34;	author deraadt;	state Exp;
branches;
next	1.116;
commitid	pUbB7iMiclIsR7nA;

1.116
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.115;
commitid	Hly9lJn6CNMylcFu;

1.115
date	2015.01.10.10.45.46;	author stsp;	state Exp;
branches;
next	1.114;
commitid	7XL9PGhkW5Qkl2p2;

1.114
date	2015.01.10.10.38.12;	author stsp;	state Exp;
branches;
next	1.113;
commitid	5YYn0wueEtry1fSW;

1.113
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.112;
commitid	yM2VFFhpDTeFQlve;

1.112
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.111;
commitid	LS2TNeCue5R9L67C;

1.111
date	2014.12.16.18.03.17;	author miod;	state Exp;
branches;
next	1.110;
commitid	Tb51y9yL6aBh8ROZ;

1.110
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.109;
commitid	uzzBR7hz9ncd4O6G;

1.109
date	2014.09.06.05.41.35;	author jsg;	state Exp;
branches;
next	1.108;
commitid	TZ6gfz2Iz0CRv2Rz;

1.108
date	2014.08.03.14.23.59;	author jsg;	state Exp;
branches;
next	1.107;
commitid	vWCFh2BjIljYigSf;

1.107
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.106;
commitid	TGHgrLxu6sxZoiFt;

1.106
date	2014.07.20.11.59.12;	author stsp;	state Exp;
branches;
next	1.105;
commitid	hPCwB7yoKDSfJ35n;

1.105
date	2014.07.20.11.57.49;	author stsp;	state Exp;
branches;
next	1.104;
commitid	eqC96SxEDoY30Jpe;

1.104
date	2014.07.20.11.57.05;	author stsp;	state Exp;
branches;
next	1.103;
commitid	kjl8G5jdOQ0mCa4U;

1.103
date	2014.07.20.11.56.15;	author stsp;	state Exp;
branches;
next	1.102;
commitid	o4JPMEbjYARyNJZW;

1.102
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.101;
commitid	I19imNlAX05zJOED;

1.101
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.100;

1.100
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2013.11.14.12.10.04;	author dlg;	state Exp;
branches;
next	1.98;

1.98
date	2013.10.01.20.05.59;	author sf;	state Exp;
branches;
next	1.97;

1.97
date	2012.12.31.10.07.51;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2012.12.05.23.20.16;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.94;

1.94
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.93;

1.93
date	2010.08.06.05.26.24;	author mglocker;	state Exp;
branches;
next	1.92;

1.92
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.91;

1.91
date	2009.09.13.14.42.52;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2009.08.02.19.33.01;	author blambert;	state Exp;
branches;
next	1.89;

1.89
date	2009.07.25.18.49.54;	author krw;	state Exp;
branches;
next	1.88;

1.88
date	2009.07.19.11.35.38;	author jsg;	state Exp;
branches;
next	1.87;

1.87
date	2009.06.02.11.54.00;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.24.11.27.32;	author jsg;	state Exp;
branches;
next	1.85;

1.85
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.07.01.07.03;	author jsg;	state Exp;
branches;
next	1.83;

1.83
date	2008.11.26.18.01.43;	author dlg;	state Exp;
branches;
next	1.82;

1.82
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.81;

1.81
date	2008.08.27.10.03.47;	author damien;	state Exp;
branches;
next	1.80;

1.80
date	2008.08.27.09.14.36;	author damien;	state Exp;
branches;
next	1.79;

1.79
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.78;

1.78
date	2008.08.22.19.58.21;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.11.00.17.17;	author jsg;	state Exp;
branches;
next	1.75;

1.75
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.25.21.13.30;	author mglocker;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.25.20.36.54;	author mglocker;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.16.23.17.15;	author mglocker;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.16.22.06.44;	author mglocker;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.16.20.09.05;	author mglocker;	state Exp;
branches;
next	1.69;

1.69
date	2008.02.16.17.52.28;	author mglocker;	state Exp;
branches;
next	1.68;

1.68
date	2008.02.16.17.29.21;	author mglocker;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.16.16.45.28;	author mglocker;	state Exp;
branches;
next	1.66;

1.66
date	2008.02.16.14.56.00;	author mglocker;	state Exp;
branches;
next	1.65;

1.65
date	2008.02.16.12.36.07;	author mglocker;	state Exp;
branches;
next	1.64;

1.64
date	2008.02.16.10.09.23;	author mglocker;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.17.16.50.02;	author mglocker;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.18.05.56.15;	author mglocker;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.04.05.44.42;	author mglocker;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.01.20.48.37;	author mglocker;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.01.19.48.10;	author mglocker;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.01.14.37.51;	author jsg;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.01.12.58.41;	author jsg;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.01.12.44.33;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.01.11.27.11;	author mglocker;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.30.22.28.45;	author mglocker;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.30.22.12.43;	author mglocker;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.30.17.11.58;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.29.22.27.59;	author mglocker;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.27.22.17.32;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.27.22.10.25;	author mglocker;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.27.09.19.21;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.27.05.58.57;	author mglocker;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.24.19.51.18;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.23.22.59.44;	author mglocker;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.23.22.10.53;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.23.22.02.33;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.23.21.45.37;	author mglocker;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.23.14.12.18;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.23.13.44.39;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.18.17.35.38;	author mglocker;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.17.20.43.18;	author mglocker;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.17.14.26.51;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.17.13.58.10;	author mglocker;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.16.19.08.42;	author mglocker;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.16.19.02.36;	author mglocker;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.16.12.33.26;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.16.12.15.57;	author mglocker;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.16.11.52.40;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.16.11.30.53;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.16.11.12.38;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.16.09.58.04;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.16.04.38.16;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.16.02.20.35;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.15.23.36.30;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.15.22.47.14;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.15.15.08.07;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.15.13.38.22;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.15.12.17.39;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.15.11.55.55;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.15.11.00.24;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.15.09.08.53;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.15.08.55.29;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.15.07.20.51;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.15.05.47.53;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.14.20.26.04;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.14.13.08.31;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.14.13.00.41;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.14.09.29.00;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.13.20.37.19;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.13.18.40.24;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.13.12.33.18;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.13.12.31.47;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.13.08.28.37;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.12.22.22.05;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.12.20.30.09;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.12.15.04.07;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.12.14.19.42;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.12.13.13.12;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.126
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: bwi.c,v 1.125 2017/07/03 09:21:09 kevlo Exp $	*/

/*
 * Copyright (c) 2007 The DragonFly Project.  All rights reserved.
 * 
 * This code is derived from software contributed to The DragonFly Project
 * by Sepherosa Ziehau <sepherosa@@gmail.com>
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of The DragonFly Project nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific, prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * $DragonFly: src/sys/dev/netif/bwi/bwimac.c,v 1.1 2007/09/08 06:15:54 sephe Exp $
 */

#include "bpfilter.h"

#include <sys/param.h>

#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/systm.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/bwireg.h>
#include <dev/ic/bwivar.h>

#include <uvm/uvm_extern.h>

#ifdef BWI_DEBUG
int bwi_debug = 1;
#define DPRINTF(l, x...)	do { if ((l) <= bwi_debug) printf(x); } while (0)
#else
#define DPRINTF(l, x...)
#endif

/* XXX temporary porting goop */
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

/* XXX does not belong here */
#define IEEE80211_OFDM_PLCP_RATE_MASK	0x0000000f
#define IEEE80211_OFDM_PLCP_LEN_MASK	0x0001ffe0

/*
 * Contention window (slots).
 */
#define IEEE80211_CW_MAX	1023	/* aCWmax */
#define IEEE80211_CW_MIN_0	31	/* DS/CCK aCWmin, ERP aCWmin(0) */
#define IEEE80211_CW_MIN_1	15	/* OFDM aCWmin, ERP aCWmin(1) */

#define __unused __attribute__((__unused__))

extern int ticks;

/* XXX end porting goop */

/* MAC */
struct bwi_retry_lim {
	uint16_t	shretry;
	uint16_t	shretry_fb;
	uint16_t	lgretry;
	uint16_t	lgretry_fb;
};

struct bwi_clock_freq {
	uint		clkfreq_min;
	uint		clkfreq_max;
};

/* XXX does not belong here */
struct ieee80211_ds_plcp_hdr {
	uint8_t		i_signal;
	uint8_t		i_service;
	uint16_t	i_length;
	uint16_t	i_crc;
} __packed;

enum bwi_modtype {
	IEEE80211_MODTYPE_DS	= 0,	/* DS/CCK modulation */
	IEEE80211_MODTYPE_PBCC	= 1,	/* PBCC modulation */
	IEEE80211_MODTYPE_OFDM	= 2	/* OFDM modulation */
};
#define IEEE80211_MODTYPE_CCK   IEEE80211_MODTYPE_DS

/* MAC */
void		 bwi_tmplt_write_4(struct bwi_mac *, uint32_t, uint32_t);
void		 bwi_hostflags_write(struct bwi_mac *, uint64_t);
uint64_t	 bwi_hostflags_read(struct bwi_mac *);
uint16_t	 bwi_memobj_read_2(struct bwi_mac *, uint16_t, uint16_t);
uint32_t	 bwi_memobj_read_4(struct bwi_mac *, uint16_t, uint16_t);
void		 bwi_memobj_write_2(struct bwi_mac *, uint16_t, uint16_t,
		     uint16_t);
void		 bwi_memobj_write_4(struct bwi_mac *, uint16_t, uint16_t,
		     uint32_t);
int		 bwi_mac_lateattach(struct bwi_mac *);
int		 bwi_mac_init(struct bwi_mac *);
void		 bwi_mac_reset(struct bwi_mac *, int);
void		 bwi_mac_set_tpctl_11bg(struct bwi_mac *,
		     const struct bwi_tpctl *);
int		 bwi_mac_test(struct bwi_mac *);
void		 bwi_mac_setup_tpctl(struct bwi_mac *);
void		 bwi_mac_dummy_xmit(struct bwi_mac *);
void		 bwi_mac_init_tpctl_11bg(struct bwi_mac *);
void		 bwi_mac_detach(struct bwi_mac *);
int		 bwi_get_firmware(const char *, const uint8_t *, size_t,
		     size_t *, size_t *);
int		 bwi_fwimage_is_valid(struct bwi_softc *, uint8_t *,
		     size_t, char *, uint8_t);
int		 bwi_mac_fw_alloc(struct bwi_mac *);
void		 bwi_mac_fw_free(struct bwi_mac *);
int		 bwi_mac_fw_load(struct bwi_mac *);
int		 bwi_mac_gpio_init(struct bwi_mac *);
int		 bwi_mac_gpio_fini(struct bwi_mac *);
int		 bwi_mac_fw_load_iv(struct bwi_mac *, uint8_t *, size_t);
int		 bwi_mac_fw_init(struct bwi_mac *);
void		 bwi_mac_opmode_init(struct bwi_mac *);
void		 bwi_mac_hostflags_init(struct bwi_mac *);
void		 bwi_mac_bss_param_init(struct bwi_mac *);
void		 bwi_mac_set_retry_lim(struct bwi_mac *,
		     const struct bwi_retry_lim *);
void		 bwi_mac_set_ackrates(struct bwi_mac *,
		     const struct ieee80211_rateset *);
int		 bwi_mac_start(struct bwi_mac *);
int		 bwi_mac_stop(struct bwi_mac *);
int		 bwi_mac_config_ps(struct bwi_mac *);
void		 bwi_mac_reset_hwkeys(struct bwi_mac *);
void		 bwi_mac_shutdown(struct bwi_mac *);
int		 bwi_mac_get_property(struct bwi_mac *);
void		 bwi_mac_updateslot(struct bwi_mac *, int);
int		 bwi_mac_attach(struct bwi_softc *, int, uint8_t);
void		 bwi_mac_balance_atten(int *, int *);
void		 bwi_mac_adjust_tpctl(struct bwi_mac *, int, int);
void		 bwi_mac_calibrate_txpower(struct bwi_mac *,
		     enum bwi_txpwrcb_type);
void		 bwi_mac_lock(struct bwi_mac *);
void		 bwi_mac_unlock(struct bwi_mac *);
void		 bwi_mac_set_promisc(struct bwi_mac *, int);

/* PHY */
void		 bwi_phy_write(struct bwi_mac *, uint16_t, uint16_t);
uint16_t	 bwi_phy_read(struct bwi_mac *, uint16_t);
int		 bwi_phy_attach(struct bwi_mac *);
void		 bwi_phy_set_bbp_atten(struct bwi_mac *, uint16_t);
int		 bwi_phy_calibrate(struct bwi_mac *);
void		 bwi_tbl_write_2(struct bwi_mac *mac, uint16_t, uint16_t);
void		 bwi_tbl_write_4(struct bwi_mac *mac, uint16_t, uint32_t);
void		 bwi_nrssi_write(struct bwi_mac *, uint16_t, int16_t);
int16_t		 bwi_nrssi_read(struct bwi_mac *, uint16_t);
void		 bwi_phy_init_11a(struct bwi_mac *);
void		 bwi_phy_init_11g(struct bwi_mac *);
void		 bwi_phy_init_11b_rev2(struct bwi_mac *);
void		 bwi_phy_init_11b_rev4(struct bwi_mac *);
void		 bwi_phy_init_11b_rev5(struct bwi_mac *);
void		 bwi_phy_init_11b_rev6(struct bwi_mac *);
void		 bwi_phy_config_11g(struct bwi_mac *);
void		 bwi_phy_config_agc(struct bwi_mac *);
void		 bwi_set_gains(struct bwi_mac *, const struct bwi_gains *);
void		 bwi_phy_clear_state(struct bwi_phy *);

/* RF */
int16_t		 bwi_nrssi_11g(struct bwi_mac *);
struct bwi_rf_lo
		*bwi_get_rf_lo(struct bwi_mac *, uint16_t, uint16_t);
int		 bwi_rf_lo_isused(struct bwi_mac *, const struct bwi_rf_lo *);
void		 bwi_rf_write(struct bwi_mac *, uint16_t, uint16_t);
uint16_t	 bwi_rf_read(struct bwi_mac *, uint16_t);
int		 bwi_rf_attach(struct bwi_mac *);
void		 bwi_rf_set_chan(struct bwi_mac *, uint, int);
void		 bwi_rf_get_gains(struct bwi_mac *);
void		 bwi_rf_init(struct bwi_mac *);
void		 bwi_rf_off_11a(struct bwi_mac *);
void		 bwi_rf_off_11bg(struct bwi_mac *);
void		 bwi_rf_off_11g_rev5(struct bwi_mac *);
void		 bwi_rf_workaround(struct bwi_mac *, uint);
struct bwi_rf_lo
		*bwi_rf_lo_find(struct bwi_mac *, const struct bwi_tpctl *);
void		 bwi_rf_lo_adjust(struct bwi_mac *, const struct bwi_tpctl *);
void		 bwi_rf_lo_write(struct bwi_mac *, const struct bwi_rf_lo *);
int		 bwi_rf_gain_max_reached(struct bwi_mac *, int);
uint16_t	 bwi_bitswap4(uint16_t);
uint16_t	 bwi_phy812_value(struct bwi_mac *, uint16_t);
void		 bwi_rf_init_bcm2050(struct bwi_mac *);
uint16_t	 bwi_rf_calibval(struct bwi_mac *);
int32_t		 _bwi_adjust_devide(int32_t, int32_t);
int		 bwi_rf_calc_txpower(int8_t *, uint8_t, const int16_t[]);
int		 bwi_rf_map_txpower(struct bwi_mac *);
void		 bwi_rf_lo_update_11g(struct bwi_mac *);
uint32_t	 bwi_rf_lo_devi_measure(struct bwi_mac *, uint16_t);
uint16_t	 bwi_rf_get_tp_ctrl2(struct bwi_mac *);
uint8_t		 _bwi_rf_lo_update_11g(struct bwi_mac *, uint16_t);
void		 bwi_rf_lo_measure_11g(struct bwi_mac *,
		     const struct bwi_rf_lo *, struct bwi_rf_lo *, uint8_t);
void		 bwi_rf_calc_nrssi_slope_11b(struct bwi_mac *);
void		 bwi_rf_set_nrssi_ofs_11g(struct bwi_mac *);
void		 bwi_rf_calc_nrssi_slope_11g(struct bwi_mac *);
void		 bwi_rf_init_sw_nrssi_table(struct bwi_mac *);
void		 bwi_rf_init_hw_nrssi_table(struct bwi_mac *, uint16_t);
void		 bwi_rf_set_nrssi_thr_11b(struct bwi_mac *);
int32_t		 _nrssi_threshold(const struct bwi_rf *, int32_t);
void		 bwi_rf_set_nrssi_thr_11g(struct bwi_mac *);
void		 bwi_rf_clear_tssi(struct bwi_mac *);
void		 bwi_rf_clear_state(struct bwi_rf *);
void		 bwi_rf_on_11a(struct bwi_mac *);
void		 bwi_rf_on_11bg(struct bwi_mac *);
void		 bwi_rf_set_ant_mode(struct bwi_mac *, int);
int		 bwi_rf_get_latest_tssi(struct bwi_mac *, int8_t[], uint16_t);
int		 bwi_rf_tssi2dbm(struct bwi_mac *, int8_t, int8_t *);
int		 bwi_rf_calc_rssi_bcm2050(struct bwi_mac *,
		     const struct bwi_rxbuf_hdr *);
int		 bwi_rf_calc_rssi_bcm2053(struct bwi_mac *,
		     const struct bwi_rxbuf_hdr *);
int		 bwi_rf_calc_rssi_bcm2060(struct bwi_mac *,
		     const struct bwi_rxbuf_hdr *);
uint16_t	 bwi_rf_lo_measure_11b(struct bwi_mac *);
void		 bwi_rf_lo_update_11b(struct bwi_mac *);

/* INTERFACE */
uint16_t	 bwi_read_sprom(struct bwi_softc *, uint16_t);
void		 bwi_setup_desc32(struct bwi_softc *, struct bwi_desc32 *, int,
		     int, bus_addr_t, int, int);
void		 bwi_power_on(struct bwi_softc *, int);
int		 bwi_power_off(struct bwi_softc *, int);
int		 bwi_regwin_switch(struct bwi_softc *, struct bwi_regwin *,
		     struct bwi_regwin **);
int		 bwi_regwin_select(struct bwi_softc *, int);
void		 bwi_regwin_info(struct bwi_softc *, uint16_t *, uint8_t *);
void		 bwi_led_attach(struct bwi_softc *);
void		 bwi_led_newstate(struct bwi_softc *, enum ieee80211_state);
uint16_t	 bwi_led_onoff(struct bwi_led *, uint16_t, int);
void		 bwi_led_event(struct bwi_softc *, int);
void		 bwi_led_blink_start(struct bwi_softc *, int, int);
void		 bwi_led_blink_next(void *);
void		 bwi_led_blink_end(void *);
int		 bwi_bbp_attach(struct bwi_softc *);
int		 bwi_bus_init(struct bwi_softc *, struct bwi_mac *);
void		 bwi_get_card_flags(struct bwi_softc *);
void		 bwi_get_eaddr(struct bwi_softc *, uint16_t, uint8_t *);
void		 bwi_get_clock_freq(struct bwi_softc *,
		     struct bwi_clock_freq *);
int		 bwi_set_clock_mode(struct bwi_softc *, enum bwi_clock_mode);
int		 bwi_set_clock_delay(struct bwi_softc *);
int		 bwi_ioctl(struct ifnet *, u_long, caddr_t);
void		 bwi_start(struct ifnet *);
void		 bwi_watchdog(struct ifnet *);
void		 bwi_newstate_begin(struct bwi_softc *, enum ieee80211_state);
void		 bwi_init_statechg(struct bwi_softc *, int);
int		 bwi_newstate(struct ieee80211com *, enum ieee80211_state, int);
int		 bwi_media_change(struct ifnet *);
void		 bwi_iter_func(void *, struct ieee80211_node *);
void		 bwi_amrr_timeout(void *);
void		 bwi_newassoc(struct ieee80211com *, struct ieee80211_node *,
		     int);
struct ieee80211_node
		*bwi_node_alloc(struct ieee80211com *ic);
int		 bwi_dma_alloc(struct bwi_softc *);
void		 bwi_dma_free(struct bwi_softc *);
int		 bwi_dma_ring_alloc(struct bwi_softc *,
		     struct bwi_ring_data *, bus_size_t, uint32_t);
int		 bwi_dma_txstats_alloc(struct bwi_softc *, uint32_t,
		     bus_size_t);
void		 bwi_dma_txstats_free(struct bwi_softc *);
int		 bwi_dma_mbuf_create30(struct bwi_softc *);
int		 bwi_dma_mbuf_create(struct bwi_softc *);
void		 bwi_dma_mbuf_destroy(struct bwi_softc *, int, int);
void		 bwi_enable_intrs(struct bwi_softc *, uint32_t);
void		 bwi_disable_intrs(struct bwi_softc *, uint32_t);
int		 bwi_init_tx_ring32(struct bwi_softc *, int);
void		 bwi_init_rxdesc_ring32(struct bwi_softc *, uint32_t,
		     bus_addr_t, int, int);
int		 bwi_init_rx_ring32(struct bwi_softc *);
int		 bwi_init_txstats32(struct bwi_softc *);
void		 bwi_setup_rx_desc32(struct bwi_softc *, int, bus_addr_t, int);
void		 bwi_setup_tx_desc32(struct bwi_softc *, struct bwi_ring_data *,
		     int, bus_addr_t, int);
int		 bwi_newbuf30(struct bwi_softc *, int, int);
int		 bwi_newbuf(struct bwi_softc *, int, int);
void		 bwi_set_addr_filter(struct bwi_softc *, uint16_t,
		     const uint8_t *);
int		 bwi_set_chan(struct bwi_softc *, uint8_t);
void		 bwi_next_scan(void *);
int		 bwi_rxeof(struct bwi_softc *, int);
int		 bwi_rxeof32(struct bwi_softc *);
void		 bwi_reset_rx_ring32(struct bwi_softc *, uint32_t);
void		 bwi_free_txstats32(struct bwi_softc *);
void		 bwi_free_rx_ring32(struct bwi_softc *);
void		 bwi_free_tx_ring32(struct bwi_softc *, int);
uint8_t		 bwi_plcp2rate(uint32_t, enum ieee80211_phymode);
void		 bwi_ofdm_plcp_header(uint32_t *, int, uint8_t);
void		 bwi_ds_plcp_header(struct ieee80211_ds_plcp_hdr *, int,
		     uint8_t);
void		 bwi_plcp_header(void *, int, uint8_t);
int		 bwi_encap(struct bwi_softc *, int, struct mbuf *,
		     struct ieee80211_node *);
void		 bwi_start_tx32(struct bwi_softc *, uint32_t, int);
void		 bwi_txeof_status32(struct bwi_softc *);
void		 _bwi_txeof(struct bwi_softc *, uint16_t);
void		 bwi_txeof_status(struct bwi_softc *, int);
void		 bwi_txeof(struct bwi_softc *);
int		 bwi_bbp_power_on(struct bwi_softc *, enum bwi_clock_mode);
void		 bwi_bbp_power_off(struct bwi_softc *);
int		 bwi_get_pwron_delay(struct bwi_softc *sc);
int		 bwi_bus_attach(struct bwi_softc *);
const char 	*bwi_regwin_name(const struct bwi_regwin *);
int		 bwi_regwin_is_enabled(struct bwi_softc *, struct bwi_regwin *);
uint32_t	 bwi_regwin_disable_bits(struct bwi_softc *);
void		 bwi_regwin_enable(struct bwi_softc *, struct bwi_regwin *,
		     uint32_t);
void		 bwi_regwin_disable(struct bwi_softc *, struct bwi_regwin *,
		     uint32_t);
void		 bwi_set_bssid(struct bwi_softc *, const uint8_t *);
void		 bwi_updateslot(struct ieee80211com *);
void		 bwi_calibrate(void *);
int		 bwi_calc_rssi(struct bwi_softc *,
		     const struct bwi_rxbuf_hdr *);
uint8_t		 bwi_ack_rate(struct ieee80211_node *, uint8_t);
uint16_t	 bwi_txtime(struct ieee80211com *, struct ieee80211_node *,
		     uint, uint8_t, uint32_t);
enum bwi_modtype
		 bwi_rate2modtype(uint8_t);


static const uint8_t bwi_sup_macrev[] = { 2, 4, 5, 6, 7, 9, 10 };

#define SUP_BPHY(num)	{ .rev = num, .init = bwi_phy_init_11b_rev##num }

static const struct {
	uint8_t	rev;
	void	(*init)(struct bwi_mac *);
} bwi_sup_bphy[] = {
	SUP_BPHY(2),
	SUP_BPHY(4),
	SUP_BPHY(5),
	SUP_BPHY(6)
};

#undef SUP_BPHY

#define BWI_PHYTBL_WRSSI	0x1000
#define BWI_PHYTBL_NOISE_SCALE	0x1400
#define BWI_PHYTBL_NOISE	0x1800
#define BWI_PHYTBL_ROTOR	0x2000
#define BWI_PHYTBL_DELAY	0x2400
#define BWI_PHYTBL_RSSI		0x4000
#define BWI_PHYTBL_SIGMA_SQ	0x5000
#define BWI_PHYTBL_WRSSI_REV1	0x5400
#define BWI_PHYTBL_FREQ		0x5800

static const uint16_t	bwi_phy_freq_11g_rev1[] =
	{ BWI_PHY_FREQ_11G_REV1 };
static const uint16_t	bwi_phy_noise_11g_rev1[] =
	{ BWI_PHY_NOISE_11G_REV1 };
static const uint16_t	bwi_phy_noise_11g[] =
	{ BWI_PHY_NOISE_11G };
static const uint32_t	bwi_phy_rotor_11g_rev1[] =
	{ BWI_PHY_ROTOR_11G_REV1 };
static const uint16_t	bwi_phy_noise_scale_11g_rev2[] =
	{ BWI_PHY_NOISE_SCALE_11G_REV2 };
static const uint16_t	bwi_phy_noise_scale_11g_rev7[] =
	{ BWI_PHY_NOISE_SCALE_11G_REV7 };
static const uint16_t	bwi_phy_noise_scale_11g[] =
	{ BWI_PHY_NOISE_SCALE_11G };
static const uint16_t	bwi_phy_sigma_sq_11g_rev2[] =
	{ BWI_PHY_SIGMA_SQ_11G_REV2 };
static const uint16_t	bwi_phy_sigma_sq_11g_rev7[] =
	{ BWI_PHY_SIGMA_SQ_11G_REV7 };
static const uint32_t	bwi_phy_delay_11g_rev1[] =
	{ BWI_PHY_DELAY_11G_REV1 };

/* RF */
#define RF_LO_WRITE(mac, lo)	bwi_rf_lo_write((mac), (lo))

#define BWI_RF_2GHZ_CHAN(chan) \
	(ieee80211_ieee2mhz((chan), IEEE80211_CHAN_2GHZ) - 2400)

#define BWI_DEFAULT_IDLE_TSSI	52

struct rf_saveregs {
	uint16_t	phy_01;
	uint16_t	phy_03;
	uint16_t	phy_0a;
	uint16_t	phy_15;
	uint16_t	phy_2a;
	uint16_t	phy_30;
	uint16_t	phy_35;
	uint16_t	phy_60;
	uint16_t	phy_429;
	uint16_t	phy_802;
	uint16_t	phy_811;
	uint16_t	phy_812;
	uint16_t	phy_814;
	uint16_t	phy_815;

	uint16_t	rf_43;
	uint16_t	rf_52;
	uint16_t	rf_7a;
};

#define SAVE_RF_REG(mac, regs, n)	(regs)->rf_##n = RF_READ((mac), 0x##n)
#define RESTORE_RF_REG(mac, regs, n)	RF_WRITE((mac), 0x##n, (regs)->rf_##n)

#define SAVE_PHY_REG(mac, regs, n)	(regs)->phy_##n = PHY_READ((mac), 0x##n)
#define RESTORE_PHY_REG(mac, regs, n)	PHY_WRITE((mac), 0x##n, (regs)->phy_##n)

static const int8_t	bwi_txpower_map_11b[BWI_TSSI_MAX] =
	{ BWI_TXPOWER_MAP_11B };
static const int8_t	bwi_txpower_map_11g[BWI_TSSI_MAX] =
	{ BWI_TXPOWER_MAP_11G };

/* IF_BWI */

struct bwi_myaddr_bssid {
	uint8_t		myaddr[IEEE80211_ADDR_LEN];
	uint8_t		bssid[IEEE80211_ADDR_LEN];
} __packed;

#define IEEE80211_DS_PLCP_SERVICE_LOCKED	0x04
#define IEEE80211_DS_PLCL_SERVICE_PBCC		0x08
#define IEEE80211_DS_PLCP_SERVICE_LENEXT5	0x20
#define IEEE80211_DS_PLCP_SERVICE_LENEXT6	0x40
#define IEEE80211_DS_PLCP_SERVICE_LENEXT7	0x80

struct cfdriver bwi_cd = {
	NULL, "bwi", DV_IFNET
};

static const struct {
	uint16_t	did_min;
	uint16_t	did_max;
	uint16_t	bbp_id;
} bwi_bbpid_map[] = {
	{ 0x4301, 0x4301, 0x4301 },
	{ 0x4305, 0x4307, 0x4307 },
	{ 0x4402, 0x4403, 0x4402 },
	{ 0x4610, 0x4615, 0x4610 },
	{ 0x4710, 0x4715, 0x4710 },
	{ 0x4720, 0x4725, 0x4309 }
};

static const struct {
	uint16_t	bbp_id;
	int		nregwin;
} bwi_regwin_count[] = {
	{ 0x4301, 5 },
	{ 0x4306, 6 },
	{ 0x4307, 5 },
	{ 0x4310, 8 },
	{ 0x4401, 3 },
	{ 0x4402, 3 },
	{ 0x4610, 9 },
	{ 0x4704, 9 },
	{ 0x4710, 9 },
	{ 0x5365, 7 }
};

#define CLKSRC(src) 				\
[BWI_CLKSRC_ ## src] = {			\
	.freq_min = BWI_CLKSRC_ ##src## _FMIN,	\
	.freq_max = BWI_CLKSRC_ ##src## _FMAX	\
}

static const struct {
	uint	freq_min;
	uint	freq_max;
} bwi_clkfreq[BWI_CLKSRC_MAX] = {
	CLKSRC(LP_OSC),
	CLKSRC(CS_OSC),
	CLKSRC(PCI)
};

#undef CLKSRC

#define VENDOR_LED_ACT(vendor)				\
{							\
	.vid = PCI_VENDOR_##vendor,			\
	.led_act = { BWI_VENDOR_LED_ACT_##vendor }	\
}

const struct {
	uint16_t	vid;
	uint8_t		led_act[BWI_LED_MAX];
} bwi_vendor_led_act[] = {
	VENDOR_LED_ACT(COMPAQ),
	VENDOR_LED_ACT(LINKSYS)
};

const uint8_t bwi_default_led_act[BWI_LED_MAX] =
	{ BWI_VENDOR_LED_ACT_DEFAULT };

#undef VENDOR_LED_ACT

const struct {
	int	on_dur;
	int	off_dur;
} bwi_led_duration[109] = {
	{ 400, 100 }, {   0,   0 }, { 150 ,  75 }, {   0,   0 }, {  90,  45 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {  66,  34 }, {  53,   26 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {  42,  21 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {  35,   17 }, {   0,   0 }, {  32,  16 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {  21,  10 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {  16,   8 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {  11,    5 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   9,   4 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   0,   0 }, {   0,   0 },
	{   0,   0 }, {   0,   0 }, {   0,    0 }, {   7,   3 }
};

static const uint8_t bwi_zero_addr[IEEE80211_ADDR_LEN];


/* CODE */

int
bwi_intr(void *xsc)
{
	struct bwi_softc *sc = xsc;
	struct bwi_mac *mac;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t intr_status;
	uint32_t txrx_intr_status[BWI_TXRX_NRING];
	int i, txrx_error, tx = 0, rx_data = -1;

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return (0);

	/*
	 * Get interrupt status
	 */
	intr_status = CSR_READ_4(sc, BWI_MAC_INTR_STATUS);
	if (intr_status == 0xffffffff)	/* Not for us */
		return (0);

	intr_status &= CSR_READ_4(sc, BWI_MAC_INTR_MASK);
	if (intr_status == 0)		/* Nothing is interesting */
		return (0);

	DPRINTF(2, "%s: intr status 0x%08x\n",
	    sc->sc_dev.dv_xname, intr_status);

	KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
	mac = (struct bwi_mac *)sc->sc_cur_regwin;

	txrx_error = 0;

	for (i = 0; i < BWI_TXRX_NRING; ++i) {
		uint32_t mask;

		if (BWI_TXRX_IS_RX(i))
			mask = BWI_TXRX_RX_INTRS;
		else
			mask = BWI_TXRX_TX_INTRS;

		txrx_intr_status[i] =
		    CSR_READ_4(sc, BWI_TXRX_INTR_STATUS(i)) & mask;

		if (txrx_intr_status[i] & BWI_TXRX_INTR_ERROR) {
			printf("%s: intr fatal TX/RX (%d) error 0x%08x\n",
			    sc->sc_dev.dv_xname, i, txrx_intr_status[i]);
			txrx_error = 1;
		}
	}

	/*
	 * Acknowledge interrupt
	 */
	CSR_WRITE_4(sc, BWI_MAC_INTR_STATUS, intr_status);

	for (i = 0; i < BWI_TXRX_NRING; ++i)
		CSR_WRITE_4(sc, BWI_TXRX_INTR_STATUS(i), txrx_intr_status[i]);

	/* Disable all interrupts */
	bwi_disable_intrs(sc, BWI_ALL_INTRS);

	if (intr_status & BWI_INTR_PHY_TXERR) {
		if (mac->mac_flags & BWI_MAC_F_PHYE_RESET) {
			printf("intr PHY TX error\n");
			/* XXX to netisr0? */
			bwi_init_statechg(sc, 0);
			return (1);
		}
	}

	if (txrx_error) {
		/* TODO: reset device */
	}

	if (intr_status & BWI_INTR_TBTT)
		bwi_mac_config_ps(mac);

	if (intr_status & BWI_INTR_EO_ATIM)
		printf("%s: EO_ATIM\n", sc->sc_dev.dv_xname);

	if (intr_status & BWI_INTR_PMQ) {
		for (;;) {
			if ((CSR_READ_4(sc, BWI_MAC_PS_STATUS) & 0x8) == 0)
				break;
		}
		CSR_WRITE_2(sc, BWI_MAC_PS_STATUS, 0x2);
	}

	if (intr_status & BWI_INTR_NOISE)
		printf("%s: intr noise\n", sc->sc_dev.dv_xname);

	if (txrx_intr_status[0] & BWI_TXRX_INTR_RX)
		rx_data = sc->sc_rxeof(sc);

	if (txrx_intr_status[3] & BWI_TXRX_INTR_RX) {
		sc->sc_txeof_status(sc);
		tx = 1;
	}

	if (intr_status & BWI_INTR_TX_DONE) {
		bwi_txeof(sc);
		tx = 1;
	}

	/* Re-enable interrupts */
	bwi_enable_intrs(sc, BWI_INIT_INTRS);

	if (sc->sc_blink_led != NULL && sc->sc_led_blink) {
		int evt = BWI_LED_EVENT_NONE;

		if (tx && rx_data > 0) {
			if (sc->sc_rx_rate > sc->sc_tx_rate)
				evt = BWI_LED_EVENT_RX;
			else
				evt = BWI_LED_EVENT_TX;
		} else if (tx) {
			evt = BWI_LED_EVENT_TX;
		} else if (rx_data > 0) {
			evt = BWI_LED_EVENT_RX;
		} else if (rx_data == 0) {
			evt = BWI_LED_EVENT_POLL;
		}

		if (evt != BWI_LED_EVENT_NONE)
			bwi_led_event(sc, evt);
	}

	return (1);
}

int
bwi_attach(struct bwi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct bwi_mac *mac;
	struct bwi_phy *phy;
	int i, error;

	DPRINTF(1, "\n");

	/* Initialize LED vars */
	sc->sc_led_idle = (2350 * hz) / 1000;
	sc->sc_led_blink = 1;

	/* AMRR rate control */
	sc->sc_amrr.amrr_min_success_threshold = 1;
	sc->sc_amrr.amrr_max_success_threshold = 15;
	timeout_set(&sc->sc_amrr_ch, bwi_amrr_timeout, sc);

	timeout_set(&sc->sc_scan_ch, bwi_next_scan, sc);
	timeout_set(&sc->sc_calib_ch, bwi_calibrate, sc);

	bwi_power_on(sc, 1);

	error = bwi_bbp_attach(sc);
	if (error)
		goto fail;

	error = bwi_bbp_power_on(sc, BWI_CLOCK_MODE_FAST);
	if (error)
		goto fail;

	if (BWI_REGWIN_EXIST(&sc->sc_com_regwin)) {
		error = bwi_set_clock_delay(sc);
		if (error)
			goto fail;

		error = bwi_set_clock_mode(sc, BWI_CLOCK_MODE_FAST);
		if (error)
			goto fail;

		error = bwi_get_pwron_delay(sc);
		if (error)
			goto fail;
	}

	error = bwi_bus_attach(sc);
	if (error)
		goto fail;

	bwi_get_card_flags(sc);

	bwi_led_attach(sc);

	for (i = 0; i < sc->sc_nmac; ++i) {
		struct bwi_regwin *old;

		mac = &sc->sc_mac[i];
		error = bwi_regwin_switch(sc, &mac->mac_regwin, &old);
		if (error)
			goto fail;

		error = bwi_mac_lateattach(mac);
		if (error)
			goto fail;

		error = bwi_regwin_switch(sc, old, NULL);
		if (error)
			goto fail;
	}

	/*
	 * XXX First MAC is known to exist
	 * TODO2
	 */
	mac = &sc->sc_mac[0];
	phy = &mac->mac_phy;

	bwi_bbp_power_off(sc);

	error = bwi_dma_alloc(sc);
	if (error)
		goto fail;

	/* setup interface */
	ifp->if_softc = sc;
	ifp->if_ioctl = bwi_ioctl;
	ifp->if_start = bwi_start;
	ifp->if_watchdog = bwi_watchdog;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

	/* Get locale */
	sc->sc_locale = __SHIFTOUT(bwi_read_sprom(sc, BWI_SPROM_CARD_INFO),
	    BWI_SPROM_CARD_INFO_LOCALE);
	DPRINTF(1, "%s: locale: %d\n", sc->sc_dev.dv_xname, sc->sc_locale);

	/*
	 * Setup ratesets, phytype, channels and get MAC address
	 */
	if (phy->phy_mode == IEEE80211_MODE_11B ||
	    phy->phy_mode == IEEE80211_MODE_11G) {
	    	uint16_t chan_flags;

		ic->ic_sup_rates[IEEE80211_MODE_11B] =
		    ieee80211_std_rateset_11b;

		if (phy->phy_mode == IEEE80211_MODE_11B) {
			chan_flags = IEEE80211_CHAN_B;
			ic->ic_phytype = IEEE80211_T_DS;
		} else {
			chan_flags = IEEE80211_CHAN_CCK |
			    IEEE80211_CHAN_OFDM |
			    IEEE80211_CHAN_DYN |
			    IEEE80211_CHAN_2GHZ;
			ic->ic_phytype = IEEE80211_T_OFDM;
			ic->ic_sup_rates[IEEE80211_MODE_11G] =
			    ieee80211_std_rateset_11g;
		}

		/* XXX depend on locale */
		for (i = 1; i <= 14; ++i) {
			ic->ic_channels[i].ic_freq =
				ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
			ic->ic_channels[i].ic_flags = chan_flags;
		}

		bwi_get_eaddr(sc, BWI_SPROM_11BG_EADDR, ic->ic_myaddr);
		if (IEEE80211_IS_MULTICAST(ic->ic_myaddr)) {
			bwi_get_eaddr(sc, BWI_SPROM_11A_EADDR, ic->ic_myaddr);
			if (IEEE80211_IS_MULTICAST(ic->ic_myaddr)) {
				printf("%s: invalid MAC address: %s\n",
				    sc->sc_dev.dv_xname,
				    ether_sprintf(ic->ic_myaddr));
			}
		}
	} else if (phy->phy_mode == IEEE80211_MODE_11A) {
		/* TODO: 11A */
		error = ENXIO;
		goto fail;
	} else
		panic("unknown phymode %d", phy->phy_mode);

	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	sc->sc_fw_version = BWI_FW_VERSION3;
	sc->sc_dwell_time = 200;

	ic->ic_caps = IEEE80211_C_SHSLOT |
	    IEEE80211_C_SHPREAMBLE |
	    IEEE80211_C_WEP |
	    IEEE80211_C_RSN |
	    IEEE80211_C_MONITOR;
	ic->ic_state = IEEE80211_S_INIT;
	ic->ic_opmode = IEEE80211_M_STA;

	ic->ic_updateslot = bwi_updateslot;

	if_attach(ifp);
	ieee80211_ifattach(ifp);

	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = bwi_newstate;
	ic->ic_newassoc = bwi_newassoc;
	ic->ic_node_alloc = bwi_node_alloc;

	ieee80211_media_init(ifp, bwi_media_change, ieee80211_media_status);

	if (error) {
		ieee80211_ifdetach(ifp);
		goto fail;
	}

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + 64);

	sc->sc_rxtap_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(BWI_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(BWI_TX_RADIOTAP_PRESENT);
#endif

	return (0);
fail:
	return (error);
}

int
bwi_detach(void *arg)
{
	struct bwi_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s, i;

	bwi_stop(sc, 1);
	ieee80211_ifdetach(ifp);
	if_detach(ifp);

	for (i = 0; i < sc->sc_nmac; ++i)
		bwi_mac_detach(&sc->sc_mac[i]);

	s = splvm();
	bwi_dma_free(sc);
	splx(s);
	bwi_dma_mbuf_destroy(sc, BWI_TX_NRING, 1);

	return (0);
}

/* MAC */

void
bwi_tmplt_write_4(struct bwi_mac *mac, uint32_t ofs, uint32_t val)
{
	struct bwi_softc *sc = mac->mac_sc;

	if (mac->mac_flags & BWI_MAC_F_BSWAP)
		val = swap32(val);

	CSR_WRITE_4(sc, BWI_MAC_TMPLT_CTRL, ofs);
	CSR_WRITE_4(sc, BWI_MAC_TMPLT_DATA, val);
}

void
bwi_hostflags_write(struct bwi_mac *mac, uint64_t flags)
{
	uint64_t val;

	val = flags & 0xffff;
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_HFLAGS_LO, val);

	val = (flags >> 16) & 0xffff;
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_HFLAGS_MI, val);

	/* HI has unclear meaning, so leave it as it is */
}

uint64_t
bwi_hostflags_read(struct bwi_mac *mac)
{
	uint64_t flags, val;

	/* HI has unclear meaning, so don't touch it */
	flags = 0;

	val = MOBJ_READ_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_HFLAGS_MI);
	flags |= val << 16;

	val = MOBJ_READ_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_HFLAGS_LO);
	flags |= val;

	return (flags);
}

uint16_t
bwi_memobj_read_2(struct bwi_mac *mac, uint16_t obj_id, uint16_t ofs0)
{
	struct bwi_softc *sc = mac->mac_sc;
	uint32_t data_reg;
	int ofs;

	data_reg = BWI_MOBJ_DATA;
	ofs = ofs0 / 4;

	if (ofs0 % 4 != 0)
		data_reg = BWI_MOBJ_DATA_UNALIGN;

	CSR_WRITE_4(sc, BWI_MOBJ_CTRL, BWI_MOBJ_CTRL_VAL(obj_id, ofs));
	return (CSR_READ_2(sc, data_reg));
}

uint32_t
bwi_memobj_read_4(struct bwi_mac *mac, uint16_t obj_id, uint16_t ofs0)
{
	struct bwi_softc *sc = mac->mac_sc;
	int ofs;

	ofs = ofs0 / 4;
	if (ofs0 % 4 != 0) {
		uint32_t ret;

		CSR_WRITE_4(sc, BWI_MOBJ_CTRL, BWI_MOBJ_CTRL_VAL(obj_id, ofs));
		ret = CSR_READ_2(sc, BWI_MOBJ_DATA_UNALIGN);
		ret <<= 16;

		CSR_WRITE_4(sc, BWI_MOBJ_CTRL,
		    BWI_MOBJ_CTRL_VAL(obj_id, ofs + 1));
		ret |= CSR_READ_2(sc, BWI_MOBJ_DATA);

		return (ret);
	} else {
		CSR_WRITE_4(sc, BWI_MOBJ_CTRL, BWI_MOBJ_CTRL_VAL(obj_id, ofs));
		return (CSR_READ_4(sc, BWI_MOBJ_DATA));
	}
}

void
bwi_memobj_write_2(struct bwi_mac *mac, uint16_t obj_id, uint16_t ofs0,
    uint16_t v)
{
	struct bwi_softc *sc = mac->mac_sc;
	uint32_t data_reg;
	int ofs;

	data_reg = BWI_MOBJ_DATA;
	ofs = ofs0 / 4;

	if (ofs0 % 4 != 0)
		data_reg = BWI_MOBJ_DATA_UNALIGN;

	CSR_WRITE_4(sc, BWI_MOBJ_CTRL, BWI_MOBJ_CTRL_VAL(obj_id, ofs));
	CSR_WRITE_2(sc, data_reg, v);
}

void
bwi_memobj_write_4(struct bwi_mac *mac, uint16_t obj_id, uint16_t ofs0,
    uint32_t v)
{
	struct bwi_softc *sc = mac->mac_sc;
	int ofs;

	ofs = ofs0 / 4;
	if (ofs0 % 4 != 0) {
		CSR_WRITE_4(sc, BWI_MOBJ_CTRL, BWI_MOBJ_CTRL_VAL(obj_id, ofs));
		CSR_WRITE_2(sc, BWI_MOBJ_DATA_UNALIGN, v >> 16);
		CSR_WRITE_4(sc, BWI_MOBJ_CTRL,
		    BWI_MOBJ_CTRL_VAL(obj_id, ofs + 1));
		CSR_WRITE_2(sc, BWI_MOBJ_DATA, v & 0xffff);
	} else {
		CSR_WRITE_4(sc, BWI_MOBJ_CTRL, BWI_MOBJ_CTRL_VAL(obj_id, ofs));
		CSR_WRITE_4(sc, BWI_MOBJ_DATA, v);
	}
}

int
bwi_mac_lateattach(struct bwi_mac *mac)
{
	int error;

	if (mac->mac_rev >= 5)
		CSR_READ_4(mac->mac_sc, BWI_STATE_HI); /* dummy read */

	bwi_mac_reset(mac, 1);

	error = bwi_phy_attach(mac);
	if (error)
		return (error);

	error = bwi_rf_attach(mac);
	if (error)
		return (error);

	/* Link 11B/G PHY, unlink 11A PHY */
	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11A)
		bwi_mac_reset(mac, 0);
	else
		bwi_mac_reset(mac, 1);

	error = bwi_mac_test(mac);
	if (error)
		return (error);

	error = bwi_mac_get_property(mac);
	if (error)
		return (error);

	error = bwi_rf_map_txpower(mac);
	if (error)
		return (error);

	bwi_rf_off(mac);
	CSR_WRITE_2(mac->mac_sc, BWI_BBP_ATTEN, BWI_BBP_ATTEN_MAGIC);
	bwi_regwin_disable(mac->mac_sc, &mac->mac_regwin, 0);

	return (0);
}

int
bwi_mac_init(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	int error, i;

	/* Clear MAC/PHY/RF states */
	bwi_mac_setup_tpctl(mac);
	bwi_rf_clear_state(&mac->mac_rf);
	bwi_phy_clear_state(&mac->mac_phy);

	/* Enable MAC and linked it to PHY */
	if (!bwi_regwin_is_enabled(sc, &mac->mac_regwin))
		bwi_mac_reset(mac, 1);

	/* Initialize backplane */
	error = bwi_bus_init(sc, mac);
	if (error)
		return (error);

	/* XXX work around for hardware bugs? */
	if (sc->sc_bus_regwin.rw_rev <= 5 &&
	    sc->sc_bus_regwin.rw_type != BWI_REGWIN_T_BUSPCIE) {
		CSR_SETBITS_4(sc, BWI_CONF_LO,
		__SHIFTIN(BWI_CONF_LO_SERVTO, BWI_CONF_LO_SERVTO_MASK) |
		__SHIFTIN(BWI_CONF_LO_REQTO, BWI_CONF_LO_REQTO_MASK));
	}

	/* Calibrate PHY */
	error = bwi_phy_calibrate(mac);
	if (error) {
		printf("%s: PHY calibrate failed\n", sc->sc_dev.dv_xname);
		return (error);
	}

	/* Prepare to initialize firmware */
	CSR_WRITE_4(sc, BWI_MAC_STATUS,
	    BWI_MAC_STATUS_UCODE_JUMP0 |
	    BWI_MAC_STATUS_IHREN);

	/*
	 * Load and initialize firmwares
	 */
	error = bwi_mac_fw_alloc(mac);
	if (error)
		return (error);

	error = bwi_mac_fw_load(mac);
	if (error)
		return (error);

	error = bwi_mac_gpio_init(mac);
	if (error)
		return (error);

	error = bwi_mac_fw_init(mac);
	if (error)
		return (error);

	/*
	 * Turn on RF
	 */
	bwi_rf_on(mac);

	/* TODO: LED, hardware rf enabled is only related to LED setting */

	/*
	 * Initialize PHY
	 */
	CSR_WRITE_2(sc, BWI_BBP_ATTEN, 0);
	bwi_phy_init(mac);

	/* TODO: interference mitigation */

	/*
	 * Setup antenna mode
	 */
	bwi_rf_set_ant_mode(mac, mac->mac_rf.rf_ant_mode);

	/*
	 * Initialize operation mode (RX configuration)
	 */
	bwi_mac_opmode_init(mac);

	/* XXX what's these */
	if (mac->mac_rev < 3) {
		CSR_WRITE_2(sc, 0x60e, 0);
		CSR_WRITE_2(sc, 0x610, 0x8000);
		CSR_WRITE_2(sc, 0x604, 0);
		CSR_WRITE_2(sc, 0x606, 0x200);
	} else {
		CSR_WRITE_4(sc, 0x188, 0x80000000);
		CSR_WRITE_4(sc, 0x18c, 0x2000000);
	}

	/*
	 * Initialize TX/RX interrupts' mask
	 */
	CSR_WRITE_4(sc, BWI_MAC_INTR_STATUS, BWI_INTR_TIMER1);
	for (i = 0; i < BWI_TXRX_NRING; ++i) {
		uint32_t intrs;

		if (BWI_TXRX_IS_RX(i))
			intrs = BWI_TXRX_RX_INTRS;
		else
			intrs = BWI_TXRX_TX_INTRS;
		CSR_WRITE_4(sc, BWI_TXRX_INTR_MASK(i), intrs);
	}

	/* XXX what's this */
	CSR_SETBITS_4(sc, BWI_STATE_LO, 0x100000);

	/* Setup MAC power up delay */
	CSR_WRITE_2(sc, BWI_MAC_POWERUP_DELAY, sc->sc_pwron_delay);

	/* Set MAC regwin revision */
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_MACREV, mac->mac_rev);

	/*
	 * Initialize host flags
	 */
	bwi_mac_hostflags_init(mac);

	/*
	 * Initialize BSS parameters
	 */
	bwi_mac_bss_param_init(mac);

	/*
	 * Initialize TX rings
	 */
	for (i = 0; i < BWI_TX_NRING; ++i) {
		error = sc->sc_init_tx_ring(sc, i);
		if (error) {
			printf("%s: can't initialize %dth TX ring\n",
			    sc->sc_dev.dv_xname, i);
			return (error);
		}
	}

	/*
	 * Initialize RX ring
	 */
	error = sc->sc_init_rx_ring(sc);
	if (error) {
		printf("%s: can't initialize RX ring\n", sc->sc_dev.dv_xname);
		return (error);
	}

	/*
	 * Initialize TX stats if the current MAC uses that
	 */
	if (mac->mac_flags & BWI_MAC_F_HAS_TXSTATS) {
		error = sc->sc_init_txstats(sc);
		if (error) {
			printf("%s: can't initialize TX stats ring\n",
			    sc->sc_dev.dv_xname);
			return (error);
		}
	}

	/* XXX what's these */
	CSR_WRITE_2(sc, 0x612, 0x50);	/* Force Pre-TBTT to 80? */
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, 0x416, 0x50);
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, 0x414, 0x1f4);

	mac->mac_flags |= BWI_MAC_F_INITED;

	return (0);
}

void
bwi_mac_reset(struct bwi_mac *mac, int link_phy)
{
	struct bwi_softc *sc = mac->mac_sc;
	uint32_t flags, state_lo, status;

	flags = BWI_STATE_LO_FLAG_PHYRST | BWI_STATE_LO_FLAG_PHYCLKEN;
	if (link_phy)
		flags |= BWI_STATE_LO_FLAG_PHYLNK;
	bwi_regwin_enable(sc, &mac->mac_regwin, flags);
	DELAY(2000);

	state_lo = CSR_READ_4(sc, BWI_STATE_LO);
	state_lo |= BWI_STATE_LO_GATED_CLOCK;
	state_lo &= ~__SHIFTIN(BWI_STATE_LO_FLAG_PHYRST,
			       BWI_STATE_LO_FLAGS_MASK);
	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);
	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_STATE_LO);
	DELAY(1000);

	state_lo &= ~BWI_STATE_LO_GATED_CLOCK;
	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);
	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_STATE_LO);
	DELAY(1000);

	CSR_WRITE_2(sc, BWI_BBP_ATTEN, 0);

	status = CSR_READ_4(sc, BWI_MAC_STATUS);
	status |= BWI_MAC_STATUS_IHREN;
	if (link_phy)
		status |= BWI_MAC_STATUS_PHYLNK;
	else
		status &= ~BWI_MAC_STATUS_PHYLNK;
	CSR_WRITE_4(sc, BWI_MAC_STATUS, status);

	if (link_phy) {
		DPRINTF(1, "%s: PHY is linked\n", sc->sc_dev.dv_xname);
		mac->mac_phy.phy_flags |= BWI_PHY_F_LINKED;
	} else {
		DPRINTF(1, "%s: PHY is unlinked\n", sc->sc_dev.dv_xname);
		mac->mac_phy.phy_flags &= ~BWI_PHY_F_LINKED;
	}
}

void
bwi_mac_set_tpctl_11bg(struct bwi_mac *mac, const struct bwi_tpctl *new_tpctl)
{
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_tpctl *tpctl = &mac->mac_tpctl;

	if (new_tpctl != NULL) {
		KASSERT(new_tpctl->bbp_atten <= BWI_BBP_ATTEN_MAX);
		KASSERT(new_tpctl->rf_atten <=
		    (rf->rf_rev < 6 ? BWI_RF_ATTEN_MAX0
		    : BWI_RF_ATTEN_MAX1));
		KASSERT(new_tpctl->tp_ctrl1 <= BWI_TPCTL1_MAX);

		tpctl->bbp_atten = new_tpctl->bbp_atten;
		tpctl->rf_atten = new_tpctl->rf_atten;
		tpctl->tp_ctrl1 = new_tpctl->tp_ctrl1;
	}

	/* Set BBP attenuation */
	bwi_phy_set_bbp_atten(mac, tpctl->bbp_atten);

	/* Set RF attenuation */
	RF_WRITE(mac, BWI_RFR_ATTEN, tpctl->rf_atten);
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_RF_ATTEN,
	    tpctl->rf_atten);

	/* Set TX power */
	if (rf->rf_type == BWI_RF_T_BCM2050) {
		RF_FILT_SETBITS(mac, BWI_RFR_TXPWR, ~BWI_RFR_TXPWR1_MASK,
		    __SHIFTIN(tpctl->tp_ctrl1, BWI_RFR_TXPWR1_MASK));
	}

	/* Adjust RF Local Oscillator */
	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11G)
		bwi_rf_lo_adjust(mac, tpctl);
}

int
bwi_mac_test(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	uint32_t orig_val, val;

#define TEST_VAL1	0xaa5555aa
#define TEST_VAL2	0x55aaaa55
	/* Save it for later restoring */
	orig_val = MOBJ_READ_4(mac, BWI_COMM_MOBJ, 0);

	/* Test 1 */
	MOBJ_WRITE_4(mac, BWI_COMM_MOBJ, 0, TEST_VAL1);
	val = MOBJ_READ_4(mac, BWI_COMM_MOBJ, 0);
	if (val != TEST_VAL1) {
		printf("%s: TEST1 failed\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	/* Test 2 */
	MOBJ_WRITE_4(mac, BWI_COMM_MOBJ, 0, TEST_VAL2);
	val = MOBJ_READ_4(mac, BWI_COMM_MOBJ, 0);
	if (val != TEST_VAL2) {
		printf("%s: TEST2 failed\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	/* Restore to the original value */
	MOBJ_WRITE_4(mac, BWI_COMM_MOBJ, 0, orig_val);

	val = CSR_READ_4(sc, BWI_MAC_STATUS);
	if ((val & ~BWI_MAC_STATUS_PHYLNK) != BWI_MAC_STATUS_IHREN) {
		printf("%s: %s failed, MAC status 0x%08x\n",
		    sc->sc_dev.dv_xname, __func__, val);
		return (ENXIO);
	}

	val = CSR_READ_4(sc, BWI_MAC_INTR_STATUS);
	if (val != 0) {
		printf("%s: %s failed, intr status %08x\n",
		    sc->sc_dev.dv_xname, __func__, val);
		return (ENXIO);
	}
#undef TEST_VAL2
#undef TEST_VAL1

	return (0);
}

void
bwi_mac_setup_tpctl(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_tpctl *tpctl = &mac->mac_tpctl;

	/* Calc BBP attenuation */
	if (rf->rf_type == BWI_RF_T_BCM2050 && rf->rf_rev < 6)
		tpctl->bbp_atten = 0;
	else
		tpctl->bbp_atten = 2;

	/* Calc TX power CTRL1?? */
	tpctl->tp_ctrl1 = 0;
	if (rf->rf_type == BWI_RF_T_BCM2050) {
		if (rf->rf_rev == 1)
			tpctl->tp_ctrl1 = 3;
		else if (rf->rf_rev < 6)
			tpctl->tp_ctrl1 = 2;
		else if (rf->rf_rev == 8)
			tpctl->tp_ctrl1 = 1;
	}

	/* Empty TX power CTRL2?? */
	tpctl->tp_ctrl2 = 0xffff;

	/*
	 * Calc RF attenuation
	 */
	if (phy->phy_mode == IEEE80211_MODE_11A) {
		tpctl->rf_atten = 0x60;
		goto back;
	}

	if (BWI_IS_BRCM_BCM4309G(sc) && sc->sc_pci_revid < 0x51) {
		tpctl->rf_atten = sc->sc_pci_revid < 0x43 ? 2 : 3;
		goto back;
	}

	tpctl->rf_atten = 5;

	if (rf->rf_type != BWI_RF_T_BCM2050) {
		if (rf->rf_type == BWI_RF_T_BCM2053 && rf->rf_rev == 1)
			tpctl->rf_atten = 6;
		goto back;
	}

	/*
	 * NB: If we reaches here and the card is BRCM_BCM4309G,
	 *     then the card's PCI revision must >= 0x51
	 */

	/* BCM2050 RF */
	switch (rf->rf_rev) {
	case 1:
		if (phy->phy_mode == IEEE80211_MODE_11G) {
			if (BWI_IS_BRCM_BCM4309G(sc) || BWI_IS_BRCM_BU4306(sc))
				tpctl->rf_atten = 3;
			else
				tpctl->rf_atten = 1;
		} else {
			if (BWI_IS_BRCM_BCM4309G(sc))
				tpctl->rf_atten = 7;
			else
				tpctl->rf_atten = 6;
		}
		break;
	case 2:
		if (phy->phy_mode == IEEE80211_MODE_11G) {
			/*
			 * NOTE: Order of following conditions is critical
			 */
			if (BWI_IS_BRCM_BCM4309G(sc))
				tpctl->rf_atten = 3;
			else if (BWI_IS_BRCM_BU4306(sc))
				tpctl->rf_atten = 5;
			else if (sc->sc_bbp_id == BWI_BBPID_BCM4320)
				tpctl->rf_atten = 4;
			else
				tpctl->rf_atten = 3;
		} else {
			tpctl->rf_atten = 6;
		}
		break;
	case 4:
	case 5:
		tpctl->rf_atten = 1;
		break;
	case 8:
		tpctl->rf_atten = 0x1a;
		break;
	}
back:
	DPRINTF(1, "%s: bbp atten: %u, rf atten: %u, ctrl1: %u, ctrl2: %u\n",
	    sc->sc_dev.dv_xname, tpctl->bbp_atten, tpctl->rf_atten,
	    tpctl->tp_ctrl1, tpctl->tp_ctrl2);
}

void
bwi_mac_dummy_xmit(struct bwi_mac *mac)
{
#define PACKET_LEN	5
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	const uint32_t *packet;
	uint16_t val_50c;
	int wait_max, i;

	static const uint32_t	packet_11a[PACKET_LEN] =
	    { 0x000201cc, 0x00d40000, 0x00000000, 0x01000000, 0x00000000 };
	static const uint32_t	packet_11bg[PACKET_LEN] =
	    { 0x000b846e, 0x00d40000, 0x00000000, 0x01000000, 0x00000000 };

	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11A) {
		wait_max = 30;
		packet = packet_11a;
		val_50c = 1;
	} else {
		wait_max = 250;
		packet = packet_11bg;
		val_50c = 0;
	}

	for (i = 0; i < PACKET_LEN; ++i)
		TMPLT_WRITE_4(mac, i * 4, packet[i]);

	CSR_READ_4(sc, BWI_MAC_STATUS);	/* dummy read */

	CSR_WRITE_2(sc, 0x568, 0);
	CSR_WRITE_2(sc, 0x7c0, 0);
	CSR_WRITE_2(sc, 0x50c, val_50c);
	CSR_WRITE_2(sc, 0x508, 0);
	CSR_WRITE_2(sc, 0x50a, 0);
	CSR_WRITE_2(sc, 0x54c, 0);
	CSR_WRITE_2(sc, 0x56a, 0x14);
	CSR_WRITE_2(sc, 0x568, 0x826);
	CSR_WRITE_2(sc, 0x500, 0);
	CSR_WRITE_2(sc, 0x502, 0x30);

	if (rf->rf_type == BWI_RF_T_BCM2050 && rf->rf_rev <= 5)
		RF_WRITE(mac, 0x51, 0x17);

	for (i = 0; i < wait_max; ++i) {
		if (CSR_READ_2(sc, 0x50e) & 0x80)
			break;
		DELAY(10);
	}
	for (i = 0; i < 10; ++i) {
		if (CSR_READ_2(sc, 0x50e) & 0x400)
			break;
		DELAY(10);
	}
	for (i = 0; i < 10; ++i) {
		if ((CSR_READ_2(sc, 0x690) & 0x100) == 0)
			break;
		DELAY(10);
	}

	if (rf->rf_type == BWI_RF_T_BCM2050 && rf->rf_rev <= 5)
		RF_WRITE(mac, 0x51, 0x37);
#undef PACKET_LEN
}

void
bwi_mac_init_tpctl_11bg(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_tpctl tpctl_orig;
	int restore_tpctl = 0;

	KASSERT(phy->phy_mode != IEEE80211_MODE_11A);

	if (BWI_IS_BRCM_BU4306(sc))
		return;

	PHY_WRITE(mac, 0x28, 0x8018);
	CSR_CLRBITS_2(sc, BWI_BBP_ATTEN, 0x20);

	if (phy->phy_mode == IEEE80211_MODE_11G) {
		if ((phy->phy_flags & BWI_PHY_F_LINKED) == 0)
			return;
		PHY_WRITE(mac, 0x47a, 0xc111);
	}
	if (mac->mac_flags & BWI_MAC_F_TPCTL_INITED)
		return;

	if (phy->phy_mode == IEEE80211_MODE_11B && phy->phy_rev >= 2 &&
	    rf->rf_type == BWI_RF_T_BCM2050) {
		RF_SETBITS(mac, 0x76, 0x84);
	} else {
		struct bwi_tpctl tpctl;

		/* Backup original TX power control variables */
		bcopy(&mac->mac_tpctl, &tpctl_orig, sizeof(tpctl_orig));
		restore_tpctl = 1;

		bcopy(&mac->mac_tpctl, &tpctl, sizeof(tpctl));
		tpctl.bbp_atten = 11;
		tpctl.tp_ctrl1 = 0;
#ifdef notyet
		if (rf->rf_rev >= 6 && rf->rf_rev <= 8)
			tpctl.rf_atten = 31;
		else
#endif
			tpctl.rf_atten = 9;

		bwi_mac_set_tpctl_11bg(mac, &tpctl);
	}

	bwi_mac_dummy_xmit(mac);

	mac->mac_flags |= BWI_MAC_F_TPCTL_INITED;
	rf->rf_base_tssi = PHY_READ(mac, 0x29);
	DPRINTF(1, "%s: base tssi %d\n", sc->sc_dev.dv_xname, rf->rf_base_tssi);

	if (abs(rf->rf_base_tssi - rf->rf_idle_tssi) >= 20) {
		printf("%s: base tssi measure failed\n", sc->sc_dev.dv_xname);
		mac->mac_flags |= BWI_MAC_F_TPCTL_ERROR;
	}

	if (restore_tpctl)
		bwi_mac_set_tpctl_11bg(mac, &tpctl_orig);
	else
		RF_CLRBITS(mac, 0x76, 0x84);

	bwi_rf_clear_tssi(mac);
}

void
bwi_mac_detach(struct bwi_mac *mac)
{
	bwi_mac_fw_free(mac);
}

int
bwi_get_firmware(const char *name, const uint8_t *ucode, size_t size_ucode,
    size_t *size, size_t *offset)
{
	int i, nfiles, off = 0, ret = 1;
	struct fwheader *h;

	if ((h = malloc(sizeof(struct fwheader), M_DEVBUF, M_NOWAIT)) == NULL)
		return (ret);

	/* get number of firmware files */
	bcopy(ucode, &nfiles, sizeof(nfiles));
	nfiles = ntohl(nfiles);
	off += sizeof(nfiles);

	/* parse header and search the firmware */
	for (i = 0; i < nfiles && off < size_ucode; i++) {
		bzero(h, sizeof(struct fwheader));
		bcopy(ucode + off, h, sizeof(struct fwheader));
		off += sizeof(struct fwheader);

		if (strcmp(name, h->filename) == 0) {
			ret = 0;
			*size = ntohl(h->filesize);
			*offset = ntohl(h->fileoffset);
			break;
		}
	}

	free(h, M_DEVBUF, sizeof *h);

	return (ret);
}

int
bwi_fwimage_is_valid(struct bwi_softc *sc, uint8_t *fw, size_t fw_len,
    char *fw_name, uint8_t fw_type)
{
	const struct bwi_fwhdr *hdr;

	if (fw_len < sizeof(*hdr)) {
		printf("%s: invalid firmware (%s): invalid size %zu\n",
		    sc->sc_dev.dv_xname, fw_name, fw_len);
		return (1);
	}

	hdr = (const struct bwi_fwhdr *)fw;

	if (fw_type != BWI_FW_T_IV) {
		/*
		 * Don't verify IV's size, it has different meaning
		 */
		if (betoh32(hdr->fw_size) != fw_len - sizeof(*hdr)) {
			printf("%s: invalid firmware (%s): size mismatch, "
			    "fw %u, real %zu\n",
			    sc->sc_dev.dv_xname,
			    fw_name,
			    betoh32(hdr->fw_size),
			    fw_len - sizeof(*hdr));
			return (1);
		}
	}

	if (hdr->fw_type != fw_type) {
		printf("%s: invalid firmware (%s): type mismatch, "
		    "fw \'%c\', target \'%c\'\n",
		    sc->sc_dev.dv_xname, fw_name, hdr->fw_type, fw_type);
		return (1);
	}

	if (hdr->fw_gen != BWI_FW_GEN_1) {
		printf("%s: invalid firmware (%s): wrong generation, "
		    "fw %d, target %d\n",
		    sc->sc_dev.dv_xname, fw_name, hdr->fw_gen, BWI_FW_GEN_1);
		return (1);
	}

	return (0);
}

int
bwi_mac_fw_alloc(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	char *name = "bwi-airforce";
	size_t offset;
	char fwname[64];
	int idx, error;

	if (mac->mac_fw == NULL) {
		error = loadfirmware(name, &mac->mac_fw, &mac->mac_fw_size);
		if (error != 0) {
			printf("%s: error %d, could not read firmware %s\n",
			    sc->sc_dev.dv_xname, error, name);
			mac->mac_fw = NULL;
			return (EIO);
		}
	}

	if (mac->mac_ucode == NULL) {
		snprintf(fwname, sizeof(fwname), "ucode%d.fw",
		    mac->mac_rev >= 5 ? 5 : mac->mac_rev);

		error = bwi_get_firmware(fwname, mac->mac_fw, mac->mac_fw_size,
		    &mac->mac_ucode_size, &offset);
		if (error != 0) {
			printf("%s: error %d, could not read firmware %s!\n",
			    sc->sc_dev.dv_xname, error, fwname);
			return (ENOMEM);
		}
		mac->mac_ucode = (mac->mac_fw + offset);
		DPRINTF(1, "%s: loaded firmware file %s\n",
		    sc->sc_dev.dv_xname, fwname);

		if (bwi_fwimage_is_valid(sc, mac->mac_ucode,
		    mac->mac_ucode_size, fwname, BWI_FW_T_UCODE))
			return (EINVAL);
	}

	if (mac->mac_pcm == NULL) {
		snprintf(fwname, sizeof(fwname), "pcm%d.fw",
		    mac->mac_rev < 5 ? 4 : 5);

		error = bwi_get_firmware(fwname, mac->mac_fw, mac->mac_fw_size,
		    &mac->mac_pcm_size, &offset);
		if (error != 0) {
			printf("%s: error %d, could not read firmware %s!\n",
			    sc->sc_dev.dv_xname, error, fwname);
			return (ENOMEM);
		}
		mac->mac_pcm = (mac->mac_fw + offset);
		DPRINTF(1, "%s: loaded firmware file %s\n",
		    sc->sc_dev.dv_xname, fwname);

		if (bwi_fwimage_is_valid(sc, mac->mac_pcm,
		    mac->mac_pcm_size, fwname, BWI_FW_T_PCM))
			return (EINVAL);
	}

	if (mac->mac_iv == NULL) {
		/* TODO: 11A */
		if (mac->mac_rev == 2 || mac->mac_rev == 4) {
			idx = 2;
		} else if (mac->mac_rev >= 5 && mac->mac_rev <= 10) {
			idx = 5;
		} else {
			printf("%s: no suitable IV for MAC rev %d\n",
			    sc->sc_dev.dv_xname, mac->mac_rev);
			return (ENODEV);
		}

		snprintf(fwname, sizeof(fwname), "b0g0initvals%d.fw", idx);

		error = bwi_get_firmware(fwname, mac->mac_fw, mac->mac_fw_size,
		    &mac->mac_iv_size, &offset);
		if (error != 0) {
			printf("%s: error %d, could not read firmware %s!\n",
			    sc->sc_dev.dv_xname, error, fwname);
			return (ENOMEM);
		}
		mac->mac_iv = (mac->mac_fw + offset);
		DPRINTF(1, "%s: loaded firmware file %s\n",
		    sc->sc_dev.dv_xname, fwname);

		if (bwi_fwimage_is_valid(sc, mac->mac_iv,
		    mac->mac_iv_size, fwname, BWI_FW_T_IV))
			return (EINVAL);
	}

	if (mac->mac_iv_ext == NULL) {
		/* TODO: 11A */
		if (mac->mac_rev == 2 || mac->mac_rev == 4 ||
		    mac->mac_rev >= 11) {
			/* No extended IV */
			goto back;
		} else if (mac->mac_rev >= 5 && mac->mac_rev <= 10) {
			idx = 5;
		} else {
			printf("%s: no suitable ExtIV for MAC rev %d\n",
			    sc->sc_dev.dv_xname, mac->mac_rev);
			return (ENODEV);
		}

		snprintf(fwname, sizeof(fwname), "b0g0bsinitvals%d.fw", idx);

		error = bwi_get_firmware(fwname, mac->mac_fw, mac->mac_fw_size,
		    &mac->mac_iv_ext_size, &offset);
		if (error != 0) {
			printf("%s: error %d, could not read firmware %s!\n",
			    sc->sc_dev.dv_xname, error, fwname);
			return (ENOMEM);
		}
		mac->mac_iv_ext = (mac->mac_fw + offset);
		DPRINTF(1, "%s: loaded firmware file %s\n",
		    sc->sc_dev.dv_xname, fwname);

		if (bwi_fwimage_is_valid(sc, mac->mac_iv_ext,
		    mac->mac_iv_ext_size, fwname, BWI_FW_T_IV))
			return (EINVAL);
	}

back:
	return (0);
}

void
bwi_mac_fw_free(struct bwi_mac *mac)
{
	if (mac->mac_fw != NULL) {
		free(mac->mac_fw, M_DEVBUF, mac->mac_fw_size);
		mac->mac_fw = NULL;
	}
}

int
bwi_mac_fw_load(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	uint16_t fw_rev;
	const uint32_t *fw;
	int fw_len, i, error = 0;

	/*
	 * Load FW image
	 */
	fw = (const uint32_t *)(mac->mac_ucode + BWI_FWHDR_SZ);
	fw_len = (mac->mac_ucode_size - BWI_FWHDR_SZ) / sizeof(uint32_t);

	CSR_WRITE_4(sc, BWI_MOBJ_CTRL,
	    BWI_MOBJ_CTRL_VAL(BWI_FW_UCODE_MOBJ | BWI_WR_MOBJ_AUTOINC, 0));
	for (i = 0; i < fw_len; ++i) {
		CSR_WRITE_4(sc, BWI_MOBJ_DATA, betoh32(fw[i]));
		DELAY(10);
	}

	/*
	 * Load PCM image
	 */
	fw = (const uint32_t *)(mac->mac_pcm + BWI_FWHDR_SZ);
	fw_len = (mac->mac_pcm_size - BWI_FWHDR_SZ) / sizeof(uint32_t);

	CSR_WRITE_4(sc, BWI_MOBJ_CTRL,
	    BWI_MOBJ_CTRL_VAL(BWI_FW_PCM_MOBJ, 0x01ea));
	CSR_WRITE_4(sc, BWI_MOBJ_DATA, 0x4000);

	CSR_WRITE_4(sc, BWI_MOBJ_CTRL,
	    BWI_MOBJ_CTRL_VAL(BWI_FW_PCM_MOBJ, 0x01eb));
	for (i = 0; i < fw_len; ++i) {
		CSR_WRITE_4(sc, BWI_MOBJ_DATA, betoh32(fw[i]));
		DELAY(10);
	}

	CSR_WRITE_4(sc, BWI_MAC_INTR_STATUS, BWI_ALL_INTRS);
	CSR_WRITE_4(sc, BWI_MAC_STATUS,
	    BWI_MAC_STATUS_UCODE_START |
	    BWI_MAC_STATUS_IHREN |
	    BWI_MAC_STATUS_INFRA);

#define NRETRY	200
	for (i = 0; i < NRETRY; ++i) {
		uint32_t intr_status;

		intr_status = CSR_READ_4(sc, BWI_MAC_INTR_STATUS);
		if (intr_status == BWI_INTR_READY)
			break;
		DELAY(10);
	}
	if (i == NRETRY) {
		printf("%s: firmware (fw & pcm) loading timed out\n",
		    sc->sc_dev.dv_xname);
		error = ETIMEDOUT;
		goto out;
	}
#undef NRETRY

	CSR_READ_4(sc, BWI_MAC_INTR_STATUS);	/* dummy read */

	fw_rev = MOBJ_READ_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_FWREV);
	if (fw_rev > BWI_FW_VERSION3_REVMAX) {
		printf("%s: firmware version 4 is not supported yet\n",
		    sc->sc_dev.dv_xname);
		error = ENODEV;
		goto out;
	}

	DPRINTF(1, "%s: firmware rev 0x%04x, patch level 0x%04x\n",
	    sc->sc_dev.dv_xname, fw_rev,
	    MOBJ_READ_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_FWPATCHLV));

out:
	return (error);
}

int
bwi_mac_gpio_init(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_regwin *old, *gpio_rw;
	uint32_t filt, bits;
	int error;

	CSR_CLRBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_GPOSEL_MASK);
	/* TODO: LED */

	CSR_SETBITS_2(sc, BWI_MAC_GPIO_MASK, 0xf);

	filt = 0x1f;
	bits = 0xf;
	if (sc->sc_bbp_id == BWI_BBPID_BCM4301) {
		filt |= 0x60;
		bits |= 0x60;
	}
	if (sc->sc_card_flags & BWI_CARD_F_PA_GPIO9) {
		CSR_SETBITS_2(sc, BWI_MAC_GPIO_MASK, 0x200);
		filt |= 0x200;
		bits |= 0x200;
	}

	gpio_rw = BWI_GPIO_REGWIN(sc);
	error = bwi_regwin_switch(sc, gpio_rw, &old);
	if (error)
		return (error);

	CSR_FILT_SETBITS_4(sc, BWI_GPIO_CTRL, filt, bits);

	return (bwi_regwin_switch(sc, old, NULL));
}

int
bwi_mac_gpio_fini(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_regwin *old, *gpio_rw;
	int error;

	gpio_rw = BWI_GPIO_REGWIN(sc);
	error = bwi_regwin_switch(sc, gpio_rw, &old);
	if (error)
		return (error);

	CSR_WRITE_4(sc, BWI_GPIO_CTRL, 0);

	return (bwi_regwin_switch(sc, old, NULL));
}

int
bwi_mac_fw_load_iv(struct bwi_mac *mac, uint8_t *fw, size_t fw_len)
{
	struct bwi_softc *sc = mac->mac_sc;
	const struct bwi_fwhdr *hdr;
	const struct bwi_fw_iv *iv;
	int n, i, iv_img_size;

	/* Get the number of IVs in the IV image */
	hdr = (const struct bwi_fwhdr *)fw;
	n = betoh32(hdr->fw_iv_cnt);
	DPRINTF(1, "%s: IV count %d\n", sc->sc_dev.dv_xname, n);

	/* Calculate the IV image size, for later sanity check */
	iv_img_size = fw_len - sizeof(*hdr);

	/* Locate the first IV */
	iv = (const struct bwi_fw_iv *)(fw + sizeof(*hdr));

	for (i = 0; i < n; ++i) {
		uint16_t iv_ofs, ofs;
		int sz = 0;

		if (iv_img_size < sizeof(iv->iv_ofs)) {
			printf("%s: invalid IV image, ofs\n",
			    sc->sc_dev.dv_xname);
			return (EINVAL);
		}
		iv_img_size -= sizeof(iv->iv_ofs);
		sz += sizeof(iv->iv_ofs);

		iv_ofs = betoh16(iv->iv_ofs);

		ofs = __SHIFTOUT(iv_ofs, BWI_FW_IV_OFS_MASK);
		if (ofs >= 0x1000) {
			printf("%s: invalid ofs (0x%04x) for %dth iv\n",
			    sc->sc_dev.dv_xname, ofs, i);
			return (EINVAL);
		}

		if (iv_ofs & BWI_FW_IV_IS_32BIT) {
			uint32_t val32;

			if (iv_img_size < sizeof(iv->iv_val.val32)) {
				printf("%s: invalid IV image, val32\n",
				    sc->sc_dev.dv_xname);
				return (EINVAL);
			}
			iv_img_size -= sizeof(iv->iv_val.val32);
			sz += sizeof(iv->iv_val.val32);

			val32 = betoh32(iv->iv_val.val32);
			CSR_WRITE_4(sc, ofs, val32);
		} else {
			uint16_t val16;

			if (iv_img_size < sizeof(iv->iv_val.val16)) {
				printf("%s: invalid IV image, val16\n",
				    sc->sc_dev.dv_xname);
				return (EINVAL);
			}
			iv_img_size -= sizeof(iv->iv_val.val16);
			sz += sizeof(iv->iv_val.val16);

			val16 = betoh16(iv->iv_val.val16);
			CSR_WRITE_2(sc, ofs, val16);
		}

		iv = (const struct bwi_fw_iv *)((const uint8_t *)iv + sz);
	}

	if (iv_img_size != 0) {
		printf("%s: invalid IV image, size left %d\n",
		    sc->sc_dev.dv_xname, iv_img_size);
		return (EINVAL);
	}

	return (0);
}

int
bwi_mac_fw_init(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	int error;

	error = bwi_mac_fw_load_iv(mac, mac->mac_iv, mac->mac_iv_size);
	if (error) {
		printf("%s: load IV failed\n", sc->sc_dev.dv_xname);
		return (error);
	}

	if (mac->mac_iv_ext != NULL) {
		error = bwi_mac_fw_load_iv(mac, mac->mac_iv_ext,
		    mac->mac_iv_ext_size);
		if (error)
			printf("%s: load ExtIV failed\n", sc->sc_dev.dv_xname);
	}

	return (error);
}

void
bwi_mac_opmode_init(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t mac_status;
	uint16_t pre_tbtt;

	CSR_CLRBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_INFRA);
	CSR_SETBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_INFRA);
	CSR_SETBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_PASS_BCN);

	/* Set probe resp timeout to infinite */
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_PROBE_RESP_TO, 0);

	/*
	 * TODO: factor out following part
	 */

	mac_status = CSR_READ_4(sc, BWI_MAC_STATUS);
	mac_status &= ~(BWI_MAC_STATUS_OPMODE_HOSTAP |
	    BWI_MAC_STATUS_PASS_CTL |
	    BWI_MAC_STATUS_PASS_BADPLCP |
	    BWI_MAC_STATUS_PASS_BADFCS |
	    BWI_MAC_STATUS_PROMISC);
	mac_status |= BWI_MAC_STATUS_INFRA;

	/* Always turn on PROMISC on old hardware */
	if (mac->mac_rev < 5)
		mac_status |= BWI_MAC_STATUS_PROMISC;

	switch (ic->ic_opmode) {
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		mac_status &= ~BWI_MAC_STATUS_INFRA;
		break;
	case IEEE80211_M_HOSTAP:
		mac_status |= BWI_MAC_STATUS_OPMODE_HOSTAP;
		break;
#endif
	case IEEE80211_M_MONITOR:
#if 0
		/* Do you want data from your microwave oven? */
		mac_status |= BWI_MAC_STATUS_PASS_CTL |
			      BWI_MAC_STATUS_PASS_BADPLCP |
			      BWI_MAC_STATUS_PASS_BADFCS;
#else
		mac_status |= BWI_MAC_STATUS_PASS_CTL;
#endif
		/* Promisc? */
		break;
	default:
		break;
	}

	if (ic->ic_if.if_flags & IFF_PROMISC)
		mac_status |= BWI_MAC_STATUS_PROMISC;

	CSR_WRITE_4(sc, BWI_MAC_STATUS, mac_status);

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode != IEEE80211_M_IBSS &&
	    ic->ic_opmode != IEEE80211_M_HOSTAP) {
#endif
		if (sc->sc_bbp_id == BWI_BBPID_BCM4306 && sc->sc_bbp_rev == 3)
			pre_tbtt = 100;
		else
			pre_tbtt = 50;
#ifndef IEEE80211_STA_ONLY
	} else
		pre_tbtt = 2;
#endif
	CSR_WRITE_2(sc, BWI_MAC_PRE_TBTT, pre_tbtt);
}

void
bwi_mac_hostflags_init(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_rf *rf = &mac->mac_rf;
	uint64_t host_flags;

	if (phy->phy_mode == IEEE80211_MODE_11A)
		return;

	host_flags = HFLAGS_READ(mac);
	host_flags |= BWI_HFLAG_SYM_WA;

	if (phy->phy_mode == IEEE80211_MODE_11G) {
		if (phy->phy_rev == 1)
			host_flags |= BWI_HFLAG_GDC_WA;
		if (sc->sc_card_flags & BWI_CARD_F_PA_GPIO9)
			host_flags |= BWI_HFLAG_OFDM_PA;
	} else if (phy->phy_mode == IEEE80211_MODE_11B) {
		if (phy->phy_rev >= 2 && rf->rf_type == BWI_RF_T_BCM2050)
			host_flags &= ~BWI_HFLAG_GDC_WA;
	} else {
		panic("unknown PHY mode %u", phy->phy_mode);
	}

	HFLAGS_WRITE(mac, host_flags);
}

void
bwi_mac_bss_param_init(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_retry_lim lim;
	uint16_t cw_min;

	/*
	 * Set short/long retry limits
	 */
	bzero(&lim, sizeof(lim));
	lim.shretry = BWI_SHRETRY;
	lim.shretry_fb = BWI_SHRETRY_FB;
	lim.lgretry = BWI_LGRETRY;
	lim.lgretry_fb = BWI_LGRETRY_FB;
	bwi_mac_set_retry_lim(mac, &lim);

	/*
	 * Implicitly prevent firmware from sending probe response
	 * by setting its "probe response timeout" to 1us.
	 */
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_PROBE_RESP_TO, 1);

	/*
	 * XXX MAC level acknowledge and CW min/max should depend
	 * on the char rateset of the IBSS/BSS to join.
	 */

	/*
	 * Set MAC level acknowledge rates
	 */
	bwi_mac_set_ackrates(mac, &sc->sc_ic.ic_sup_rates[phy->phy_mode]);

	/*
	 * Set CW min
	 */
	if (phy->phy_mode == IEEE80211_MODE_11B)
		cw_min = IEEE80211_CW_MIN_0;
	else
		cw_min = IEEE80211_CW_MIN_1;
	MOBJ_WRITE_2(mac, BWI_80211_MOBJ, BWI_80211_MOBJ_CWMIN, cw_min);

	/*
	 * Set CW max
	 */
	MOBJ_WRITE_2(mac, BWI_80211_MOBJ, BWI_80211_MOBJ_CWMAX,
	    IEEE80211_CW_MAX);
}

void
bwi_mac_set_retry_lim(struct bwi_mac *mac, const struct bwi_retry_lim *lim)
{
	/* Short/Long retry limit */
	MOBJ_WRITE_2(mac, BWI_80211_MOBJ, BWI_80211_MOBJ_SHRETRY,
	    lim->shretry);
	MOBJ_WRITE_2(mac, BWI_80211_MOBJ, BWI_80211_MOBJ_LGRETRY,
	    lim->lgretry);

	/* Short/Long retry fallback limit */
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_SHRETRY_FB,
	    lim->shretry_fb);
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_LGRETEY_FB,
	    lim->lgretry_fb);
}

void
bwi_mac_set_ackrates(struct bwi_mac *mac, const struct ieee80211_rateset *rs)
{
	struct bwi_softc *sc;
	int i;

	sc = mac->mac_sc;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	/* XXX not standard conforming */
	for (i = 0; i < rs->rs_nrates; ++i) {
		enum bwi_modtype modtype;
		uint16_t ofs;

		modtype = bwi_rate2modtype(rs->rs_rates[i]);
		switch (modtype) {
		case IEEE80211_MODTYPE_DS:
			ofs = 0x4c0;
			ofs += (ieee80211_rate2plcp(rs->rs_rates[i],
			    IEEE80211_MODE_11B) & 0xf) * 2;
			break;
		case IEEE80211_MODTYPE_OFDM:
			ofs = 0x480;
			ofs += (ieee80211_rate2plcp(rs->rs_rates[i],
			    IEEE80211_MODE_11G) & 0xf) * 2;
			break;
		default:
			panic("unsupported modtype %u", modtype);
		}

		MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, ofs + 0x20,
		    MOBJ_READ_2(mac, BWI_COMM_MOBJ, ofs));
	}
}

int
bwi_mac_start(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;

	CSR_SETBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_ENABLE);
	CSR_WRITE_4(sc, BWI_MAC_INTR_STATUS, BWI_INTR_READY);

	/* Flush pending bus writes */
	CSR_READ_4(sc, BWI_MAC_STATUS);
	CSR_READ_4(sc, BWI_MAC_INTR_STATUS);

	return (bwi_mac_config_ps(mac));
}

int
bwi_mac_stop(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	int error, i;

	error = bwi_mac_config_ps(mac);
	if (error)
		return (error);

	CSR_CLRBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_ENABLE);

	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_MAC_STATUS);

#define NRETRY	10000
	for (i = 0; i < NRETRY; ++i) {
		if (CSR_READ_4(sc, BWI_MAC_INTR_STATUS) & BWI_INTR_READY)
			break;
		DELAY(1);
	}
	if (i == NRETRY) {
		printf("%s: can't stop MAC\n", sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}
#undef NRETRY

	return (0);
}

int
bwi_mac_config_ps(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	uint32_t status;

	status = CSR_READ_4(sc, BWI_MAC_STATUS);

	status &= ~BWI_MAC_STATUS_HW_PS;
	status |= BWI_MAC_STATUS_WAKEUP;
	CSR_WRITE_4(sc, BWI_MAC_STATUS, status);

	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_MAC_STATUS);

	if (mac->mac_rev >= 5) {
		int i;

#define NRETRY	100
		for (i = 0; i < NRETRY; ++i) {
			if (MOBJ_READ_2(mac, BWI_COMM_MOBJ,
			    BWI_COMM_MOBJ_UCODE_STATE) != BWI_UCODE_STATE_PS)
				break;
			DELAY(10);
		}
		if (i == NRETRY) {
			printf("%s: config PS failed\n", sc->sc_dev.dv_xname);
			return (ETIMEDOUT);
		}
#undef NRETRY
	}
	return (0);
}

void
bwi_mac_reset_hwkeys(struct bwi_mac *mac)
{
	/* TODO: firmware crypto */
	MOBJ_READ_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_KEYTABLE_OFS);
}

void
bwi_mac_shutdown(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	int i;

	if (mac->mac_flags & BWI_MAC_F_HAS_TXSTATS)
		sc->sc_free_txstats(sc);

	sc->sc_free_rx_ring(sc);

	for (i = 0; i < BWI_TX_NRING; ++i)
		sc->sc_free_tx_ring(sc, i);

	bwi_rf_off(mac);

	/* TODO: LED */

	bwi_mac_gpio_fini(mac);

	bwi_rf_off(mac); /* XXX again */
	CSR_WRITE_2(sc, BWI_BBP_ATTEN, BWI_BBP_ATTEN_MAGIC);
	bwi_regwin_disable(sc, &mac->mac_regwin, 0);

	mac->mac_flags &= ~BWI_MAC_F_INITED;
}

int
bwi_mac_get_property(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	enum bwi_bus_space old_bus_space;
	uint32_t val;

	/*
	 * Byte swap
	 */
	val = CSR_READ_4(sc, BWI_MAC_STATUS);
	if (val & BWI_MAC_STATUS_BSWAP) {
		DPRINTF(1, "%s: need byte swap\n", sc->sc_dev.dv_xname);
		mac->mac_flags |= BWI_MAC_F_BSWAP;
	}

	/*
	 * DMA address space
	 */
	old_bus_space = sc->sc_bus_space;

	val = CSR_READ_4(sc, BWI_STATE_HI);
	if (__SHIFTOUT(val, BWI_STATE_HI_FLAGS_MASK) &
	    BWI_STATE_HI_FLAG_64BIT) {
		/* 64bit address */
		sc->sc_bus_space = BWI_BUS_SPACE_64BIT;
		printf(": 64bit bus space not supported\n");
		return (ENODEV);
	} else {
		uint32_t txrx_reg = BWI_TXRX_CTRL_BASE + BWI_TX32_CTRL;

		CSR_WRITE_4(sc, txrx_reg, BWI_TXRX32_CTRL_ADDRHI_MASK);
		if (CSR_READ_4(sc, txrx_reg) & BWI_TXRX32_CTRL_ADDRHI_MASK) {
			/* 32bit address */
			sc->sc_bus_space = BWI_BUS_SPACE_32BIT;
			DPRINTF(1, "%s: 32bit bus space\n",
			    sc->sc_dev.dv_xname);
		} else {
			/* 30bit address */
			sc->sc_bus_space = BWI_BUS_SPACE_30BIT;
			DPRINTF(1, "%s: 30bit bus space\n",
			    sc->sc_dev.dv_xname);
		}
	}

	if (old_bus_space != 0 && old_bus_space != sc->sc_bus_space) {
		printf("%s: MACs bus space mismatch!\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	return (0);
}

void
bwi_mac_updateslot(struct bwi_mac *mac, int shslot)
{
	struct bwi_softc *sc;
	uint16_t slot_time;

	sc = mac->mac_sc;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11B)
		return;

	if (shslot)
		slot_time = IEEE80211_DUR_DS_SHSLOT;
	else
		slot_time = IEEE80211_DUR_DS_SLOT;

	CSR_WRITE_2(mac->mac_sc, BWI_MAC_SLOTTIME,
	    slot_time + BWI_MAC_SLOTTIME_ADJUST);
	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_SLOTTIME, slot_time);
}

int
bwi_mac_attach(struct bwi_softc *sc, int id, uint8_t rev)
{
	struct bwi_mac *mac;
	int i;

	KASSERT(sc->sc_nmac <= BWI_MAC_MAX && sc->sc_nmac >= 0);

	if (sc->sc_nmac == BWI_MAC_MAX) {
		printf("%s: too many MACs\n", sc->sc_dev.dv_xname);
		return (0);
	}

	/*
	 * More than one MAC is only supported by BCM4309
	 */
	if (sc->sc_nmac != 0 &&
	    sc->sc_pci_did != PCI_PRODUCT_BROADCOM_BCM4309) {
		DPRINTF(1, "%s: ignore second MAC\n", sc->sc_dev.dv_xname);
		return (0);
	}

	mac = &sc->sc_mac[sc->sc_nmac];

	/* XXX will this happen? */
	if (BWI_REGWIN_EXIST(&mac->mac_regwin)) {
		printf("%s: %dth MAC already attached\n",
		    sc->sc_dev.dv_xname, sc->sc_nmac);
		return (0);
	}

	/*
	 * Test whether the revision of this MAC is supported
	 */
	for (i = 0; i < nitems(bwi_sup_macrev); ++i) {
		if (bwi_sup_macrev[i] == rev)
			break;
	}
	if (i == nitems(bwi_sup_macrev)) {
		printf("%s: MAC rev %u is not supported\n",
		    sc->sc_dev.dv_xname, rev);
		return (ENXIO);
	}

	BWI_CREATE_MAC(mac, sc, id, rev);
	sc->sc_nmac++;

	if (mac->mac_rev < 5) {
		mac->mac_flags |= BWI_MAC_F_HAS_TXSTATS;
		DPRINTF(1, "%s: has TX stats\n", sc->sc_dev.dv_xname);
	} else {
		mac->mac_flags |= BWI_MAC_F_PHYE_RESET;
	}

	return (0);
}

void
bwi_mac_balance_atten(int *bbp_atten0, int *rf_atten0)
{
	int bbp_atten, rf_atten, rf_atten_lim = -1;

	bbp_atten = *bbp_atten0;
	rf_atten = *rf_atten0;

	/*
	 * RF attenuation affects TX power BWI_RF_ATTEN_FACTOR times
	 * as much as BBP attenuation, so we try our best to keep RF
	 * attenuation within range.  BBP attenuation will be clamped
	 * later if it is out of range during balancing.
	 *
	 * BWI_RF_ATTEN_MAX0 is used as RF attenuation upper limit.
	 */

	/*
	 * Use BBP attenuation to balance RF attenuation
	 */
	if (rf_atten < 0)
		rf_atten_lim = 0;
	else if (rf_atten > BWI_RF_ATTEN_MAX0)
		rf_atten_lim = BWI_RF_ATTEN_MAX0;

	if (rf_atten_lim >= 0) {
		bbp_atten += (BWI_RF_ATTEN_FACTOR * (rf_atten - rf_atten_lim));
		rf_atten = rf_atten_lim;
	}

	/*
	 * If possible, use RF attenuation to balance BBP attenuation
	 * NOTE: RF attenuation is still kept within range.
	 */
	while (rf_atten < BWI_RF_ATTEN_MAX0 && bbp_atten > BWI_BBP_ATTEN_MAX) {
		bbp_atten -= BWI_RF_ATTEN_FACTOR;
		++rf_atten;
	}
	while (rf_atten > 0 && bbp_atten < 0) {
		bbp_atten += BWI_RF_ATTEN_FACTOR;
		--rf_atten;
	}

	/* RF attenuation MUST be within range */
	KASSERT(rf_atten >= 0 && rf_atten <= BWI_RF_ATTEN_MAX0);

	/*
	 * Clamp BBP attenuation
	 */
	if (bbp_atten < 0)
		bbp_atten = 0;
	else if (bbp_atten > BWI_BBP_ATTEN_MAX)
		bbp_atten = BWI_BBP_ATTEN_MAX;

	*rf_atten0 = rf_atten;
	*bbp_atten0 = bbp_atten;
}

void
bwi_mac_adjust_tpctl(struct bwi_mac *mac, int rf_atten_adj, int bbp_atten_adj)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_tpctl tpctl;
	int bbp_atten, rf_atten, tp_ctrl1;

	bcopy(&mac->mac_tpctl, &tpctl, sizeof(tpctl));

	/* NOTE: Use signed value to do calculation */
	bbp_atten = tpctl.bbp_atten;
	rf_atten = tpctl.rf_atten;
	tp_ctrl1 = tpctl.tp_ctrl1;

	bbp_atten += bbp_atten_adj;
	rf_atten += rf_atten_adj;

	bwi_mac_balance_atten(&bbp_atten, &rf_atten);

	if (rf->rf_type == BWI_RF_T_BCM2050 && rf->rf_rev == 2) {
		if (rf_atten <= 1) {
			if (tp_ctrl1 == 0) {
				tp_ctrl1 = 3;
				bbp_atten += 2;
				rf_atten += 2;
			} else if (sc->sc_card_flags & BWI_CARD_F_PA_GPIO9) {
				bbp_atten +=
				(BWI_RF_ATTEN_FACTOR * (rf_atten - 2));
				rf_atten = 2;
			}
		} else if (rf_atten > 4 && tp_ctrl1 != 0) {
			tp_ctrl1 = 0;
			if (bbp_atten < 3) {
				bbp_atten += 2;
				rf_atten -= 3;
			} else {
				bbp_atten -= 2;
				rf_atten -= 2;
			}
		}
		bwi_mac_balance_atten(&bbp_atten, &rf_atten);
	}

	tpctl.bbp_atten = bbp_atten;
	tpctl.rf_atten = rf_atten;
	tpctl.tp_ctrl1 = tp_ctrl1;

	bwi_mac_lock(mac);
	bwi_mac_set_tpctl_11bg(mac, &tpctl);
	bwi_mac_unlock(mac);
}

/*
 * http://bcm-specs.sipsolutions.net/RecalculateTransmissionPower
 */
void
bwi_mac_calibrate_txpower(struct bwi_mac *mac, enum bwi_txpwrcb_type type)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	int8_t tssi[4], tssi_avg, cur_txpwr;
	int error, i, ofdm_tssi;
	int txpwr_diff, rf_atten_adj, bbp_atten_adj;

	if (mac->mac_flags & BWI_MAC_F_TPCTL_ERROR) {
		DPRINTF(1, "%s: tpctl error happened, can't set txpower\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	if (BWI_IS_BRCM_BU4306(sc)) {
		DPRINTF(1, "%s: BU4306, can't set txpower\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Save latest TSSI and reset the related memory objects
	 */
	ofdm_tssi = 0;
	error = bwi_rf_get_latest_tssi(mac, tssi, BWI_COMM_MOBJ_TSSI_DS);
	if (error) {
		DPRINTF(1, "%s: no DS tssi\n", sc->sc_dev.dv_xname);

		if (mac->mac_phy.phy_mode == IEEE80211_MODE_11B) {
			if (type == BWI_TXPWR_FORCE) {
				rf_atten_adj = 0;
				bbp_atten_adj = 1;
				goto calib;
			} else {
				return;
			}
		}

		error = bwi_rf_get_latest_tssi(mac, tssi,
		    BWI_COMM_MOBJ_TSSI_OFDM);
		if (error) {
			DPRINTF(1, "%s: no OFDM tssi\n", sc->sc_dev.dv_xname);
			if (type == BWI_TXPWR_FORCE) {
				rf_atten_adj = 0;
				bbp_atten_adj = 1;
				goto calib;
			} else {
				return;
			}
		}

		for (i = 0; i < 4; ++i) {
			tssi[i] += 0x20;
			tssi[i] &= 0x3f;
		}
		ofdm_tssi = 1;
	}
	bwi_rf_clear_tssi(mac);

	DPRINTF(1, "%s: tssi0 %d, tssi1 %d, tssi2 %d, tssi3 %d\n",
	    sc->sc_dev.dv_xname, tssi[0], tssi[1], tssi[2], tssi[3]);

	/*
	 * Calculate RF/BBP attenuation adjustment based on
	 * the difference between desired TX power and sampled
	 * TX power.
	 */
	/* +8 == "each incremented by 1/2" */
	tssi_avg = (tssi[0] + tssi[1] + tssi[2] + tssi[3] + 8) / 4;
	if (ofdm_tssi && (HFLAGS_READ(mac) & BWI_HFLAG_PWR_BOOST_DS))
		tssi_avg -= 13;

	DPRINTF(1, "%s: tssi avg %d\n", sc->sc_dev.dv_xname, tssi_avg);

	error = bwi_rf_tssi2dbm(mac, tssi_avg, &cur_txpwr);
	if (error)
		return;
	DPRINTF(1, "%s: current txpower %d\n", sc->sc_dev.dv_xname, cur_txpwr);

	txpwr_diff = rf->rf_txpower_max - cur_txpwr; /* XXX ni_txpower */

	rf_atten_adj = -howmany(txpwr_diff, 8);

	if (type == BWI_TXPWR_INIT) {
		/*
		 * Move toward EEPROM max TX power as fast as we can
		 */
		bbp_atten_adj = -txpwr_diff;
	} else {
		bbp_atten_adj = -(txpwr_diff / 2);
	}
	bbp_atten_adj -= (BWI_RF_ATTEN_FACTOR * rf_atten_adj);

	if (rf_atten_adj == 0 && bbp_atten_adj == 0) {
		DPRINTF(1, "%s: no need to adjust RF/BBP attenuation\n",
		    sc->sc_dev.dv_xname);
		/* TODO: LO */
		return;
	}

calib:
	DPRINTF(1, "%s: rf atten adjust %d, bbp atten adjust %d\n",
	    sc->sc_dev.dv_xname, rf_atten_adj, bbp_atten_adj);
	bwi_mac_adjust_tpctl(mac, rf_atten_adj, bbp_atten_adj);
	/* TODO: LO */
}

void
bwi_mac_lock(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;

	KASSERT((mac->mac_flags & BWI_MAC_F_LOCKED) == 0);

	if (mac->mac_rev < 3)
		bwi_mac_stop(mac);
	else
#ifndef IEEE80211_STA_ONLY
	if (sc->sc_ic.ic_opmode != IEEE80211_M_HOSTAP)
#endif
		bwi_mac_config_ps(mac);

	CSR_SETBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_RFLOCK);

	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_MAC_STATUS);
	DELAY(10);

	mac->mac_flags |= BWI_MAC_F_LOCKED;
}

void
bwi_mac_unlock(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;

	KASSERT(mac->mac_flags & BWI_MAC_F_LOCKED);

	CSR_READ_2(sc, BWI_PHYINFO); /* dummy read */

	CSR_CLRBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_RFLOCK);

	if (mac->mac_rev < 3)
		bwi_mac_start(mac);
	else
#ifndef IEEE80211_STA_ONLY
	if (sc->sc_ic.ic_opmode != IEEE80211_M_HOSTAP)
#endif
		bwi_mac_config_ps(mac);

	mac->mac_flags &= ~BWI_MAC_F_LOCKED;
}

void
bwi_mac_set_promisc(struct bwi_mac *mac, int promisc)
{
	struct bwi_softc *sc = mac->mac_sc;

	if (mac->mac_rev < 5) /* Promisc is always on */
		return;

	if (promisc)
		CSR_SETBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_PROMISC);
	else
		CSR_CLRBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_PROMISC);
}

/* PHY */

void
bwi_phy_write(struct bwi_mac *mac, uint16_t ctrl, uint16_t data)
{
	struct bwi_softc *sc = mac->mac_sc;

	/* TODO: 11A */
	CSR_WRITE_2(sc, BWI_PHY_CTRL, ctrl);
	CSR_WRITE_2(sc, BWI_PHY_DATA, data);
}

uint16_t
bwi_phy_read(struct bwi_mac *mac, uint16_t ctrl)
{
	struct bwi_softc *sc = mac->mac_sc;

	/* TODO: 11A */
	CSR_WRITE_2(sc, BWI_PHY_CTRL, ctrl);
	return (CSR_READ_2(sc, BWI_PHY_DATA));
}

int
bwi_phy_attach(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	uint8_t phyrev, phytype, phyver;
	uint16_t val;
	int i;

	/* Get PHY type/revision/version */
	val = CSR_READ_2(sc, BWI_PHYINFO);
	phyrev = __SHIFTOUT(val, BWI_PHYINFO_REV_MASK);
	phytype = __SHIFTOUT(val, BWI_PHYINFO_TYPE_MASK);
	phyver = __SHIFTOUT(val, BWI_PHYINFO_VER_MASK);
	DPRINTF(1, "%s: PHY type %d, rev %d, ver %d\n",
	    sc->sc_dev.dv_xname, phytype, phyrev, phyver);

	/*
	 * Verify whether the revision of the PHY type is supported
	 * Convert PHY type to ieee80211_phymode
	 */
	switch (phytype) {
	case BWI_PHYINFO_TYPE_11A:
		if (phyrev >= 4) {
			printf("%s: unsupported 11A PHY, rev %u\n",
			    sc->sc_dev.dv_xname, phyrev);
			return (ENXIO);
		}
		phy->phy_init = bwi_phy_init_11a;
		phy->phy_mode = IEEE80211_MODE_11A;
		phy->phy_tbl_ctrl = BWI_PHYR_TBL_CTRL_11A;
		phy->phy_tbl_data_lo = BWI_PHYR_TBL_DATA_LO_11A;
		phy->phy_tbl_data_hi = BWI_PHYR_TBL_DATA_HI_11A;
		break;
	case BWI_PHYINFO_TYPE_11B:
		for (i = 0; i < nitems(bwi_sup_bphy); ++i) {
			if (phyrev == bwi_sup_bphy[i].rev) {
				phy->phy_init = bwi_sup_bphy[i].init;
				break;
			}
		}
		if (i == nitems(bwi_sup_bphy)) {
			printf("%s: unsupported 11B PHY, rev %u\n",
			    sc->sc_dev.dv_xname, phyrev);
			return (ENXIO);
		}
		phy->phy_mode = IEEE80211_MODE_11B;
		break;
	case BWI_PHYINFO_TYPE_11G:
		if (phyrev > 8) {
			printf("%s: unsupported 11G PHY, rev %u\n",
			    sc->sc_dev.dv_xname, phyrev);
			return (ENXIO);
		}
		phy->phy_init = bwi_phy_init_11g;
		phy->phy_mode = IEEE80211_MODE_11G;
		phy->phy_tbl_ctrl = BWI_PHYR_TBL_CTRL_11G;
		phy->phy_tbl_data_lo = BWI_PHYR_TBL_DATA_LO_11G;
		phy->phy_tbl_data_hi = BWI_PHYR_TBL_DATA_HI_11G;
		break;
	default:
		printf("%s: unsupported PHY type %d\n",
		    sc->sc_dev.dv_xname, phytype);
		return (ENXIO);
	}
	phy->phy_rev = phyrev;
	phy->phy_version = phyver;

	return (0);
}

void
bwi_phy_set_bbp_atten(struct bwi_mac *mac, uint16_t bbp_atten)
{
	struct bwi_phy *phy = &mac->mac_phy;
	uint16_t mask = 0x000f;

	if (phy->phy_version == 0) {
		CSR_FILT_SETBITS_2(mac->mac_sc, BWI_BBP_ATTEN, ~mask,
		    __SHIFTIN(bbp_atten, mask));
	} else {
		if (phy->phy_version > 1)
			mask <<= 2;
		else
			mask <<= 3;
		PHY_FILT_SETBITS(mac, BWI_PHYR_BBP_ATTEN, ~mask,
		    __SHIFTIN(bbp_atten, mask));
	}
}

int
bwi_phy_calibrate(struct bwi_mac *mac)
{
	struct bwi_phy *phy = &mac->mac_phy;

	/* Dummy read */
	CSR_READ_4(mac->mac_sc, BWI_MAC_STATUS);

	/* Don't re-init */
	if (phy->phy_flags & BWI_PHY_F_CALIBRATED)
		return (0);

	if (phy->phy_mode == IEEE80211_MODE_11G && phy->phy_rev == 1) {
		bwi_mac_reset(mac, 0);
		bwi_phy_init_11g(mac);
		bwi_mac_reset(mac, 1);
	}

	phy->phy_flags |= BWI_PHY_F_CALIBRATED;

	return (0);
}

void
bwi_tbl_write_2(struct bwi_mac *mac, uint16_t ofs, uint16_t data)
{
	struct bwi_phy *phy = &mac->mac_phy;

	KASSERT(phy->phy_tbl_ctrl != 0 && phy->phy_tbl_data_lo != 0);
	PHY_WRITE(mac, phy->phy_tbl_ctrl, ofs);
	PHY_WRITE(mac, phy->phy_tbl_data_lo, data);
}

void
bwi_tbl_write_4(struct bwi_mac *mac, uint16_t ofs, uint32_t data)
{
	struct bwi_phy *phy = &mac->mac_phy;

	KASSERT(phy->phy_tbl_data_lo != 0 && phy->phy_tbl_data_hi != 0 &&
	    phy->phy_tbl_ctrl != 0);

	PHY_WRITE(mac, phy->phy_tbl_ctrl, ofs);
	PHY_WRITE(mac, phy->phy_tbl_data_hi, data >> 16);
	PHY_WRITE(mac, phy->phy_tbl_data_lo, data & 0xffff);
}

void
bwi_nrssi_write(struct bwi_mac *mac, uint16_t ofs, int16_t data)
{
	PHY_WRITE(mac, BWI_PHYR_NRSSI_CTRL, ofs);
	PHY_WRITE(mac, BWI_PHYR_NRSSI_DATA, (uint16_t)data);
}

int16_t
bwi_nrssi_read(struct bwi_mac *mac, uint16_t ofs)
{
	PHY_WRITE(mac, BWI_PHYR_NRSSI_CTRL, ofs);
	return ((int16_t)PHY_READ(mac, BWI_PHYR_NRSSI_DATA));
}

void
bwi_phy_init_11a(struct bwi_mac *mac)
{
	/* TODO: 11A */
}

void
bwi_phy_init_11g(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_rf *rf = &mac->mac_rf;
	const struct bwi_tpctl *tpctl = &mac->mac_tpctl;

	if (phy->phy_rev == 1)
		bwi_phy_init_11b_rev5(mac);
	else
		bwi_phy_init_11b_rev6(mac);

	if (phy->phy_rev >= 2 || (phy->phy_flags & BWI_PHY_F_LINKED))
		bwi_phy_config_11g(mac);

	if (phy->phy_rev >= 2) {
		PHY_WRITE(mac, 0x814, 0);
		PHY_WRITE(mac, 0x815, 0);

		if (phy->phy_rev == 2) {
			PHY_WRITE(mac, 0x811, 0);
			PHY_WRITE(mac, 0x15, 0xc0);
		} else if (phy->phy_rev > 5) {
			PHY_WRITE(mac, 0x811, 0x400);
			PHY_WRITE(mac, 0x15, 0xc0);
		}
	}

	if (phy->phy_rev >= 2 || (phy->phy_flags & BWI_PHY_F_LINKED)) {
		uint16_t val;

		val = PHY_READ(mac, 0x400) & 0xff;
		if (val == 3 || val == 5) {
			PHY_WRITE(mac, 0x4c2, 0x1816);
			PHY_WRITE(mac, 0x4c3, 0x8006);
			if (val == 5) {
				PHY_FILT_SETBITS(mac, 0x4cc,
						 0xff, 0x1f00);
			}
		}
	}

	if ((phy->phy_rev <= 2 && (phy->phy_flags & BWI_PHY_F_LINKED)) ||
	    phy->phy_rev >= 2)
		PHY_WRITE(mac, 0x47e, 0x78);

	if (rf->rf_rev == 8) {
		PHY_SETBITS(mac, 0x801, 0x80);
		PHY_SETBITS(mac, 0x43e, 0x4);
	}

	if (phy->phy_rev >= 2 && (phy->phy_flags & BWI_PHY_F_LINKED))
		bwi_rf_get_gains(mac);

	if (rf->rf_rev != 8)
		bwi_rf_init(mac);

	if (tpctl->tp_ctrl2 == 0xffff) {
		bwi_rf_lo_update(mac);
	} else {
		if (rf->rf_type == BWI_RF_T_BCM2050 && rf->rf_rev == 8) {
			RF_WRITE(mac, 0x52,
			    (tpctl->tp_ctrl1 << 4) | tpctl->tp_ctrl2);
		} else {
			RF_FILT_SETBITS(mac, 0x52, 0xfff0, tpctl->tp_ctrl2);
		}

		if (phy->phy_rev >= 6) {
			PHY_FILT_SETBITS(mac, 0x36, 0xfff,
			    tpctl->tp_ctrl2 << 12);
		}

		if (sc->sc_card_flags & BWI_CARD_F_PA_GPIO9)
			PHY_WRITE(mac, 0x2e, 0x8075);
		else
			PHY_WRITE(mac, 0x2e, 0x807f);

		if (phy->phy_rev < 2)
			PHY_WRITE(mac, 0x2f, 0x101);
		else
			PHY_WRITE(mac, 0x2f, 0x202);
	}

	if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
		bwi_rf_lo_adjust(mac, tpctl);
		PHY_WRITE(mac, 0x80f, 0x8078);
	}

	if ((sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) == 0) {
		bwi_rf_init_hw_nrssi_table(mac, 0xffff /* XXX */);
		bwi_rf_set_nrssi_thr(mac);
	} else if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
		if (rf->rf_nrssi[0] == BWI_INVALID_NRSSI) {
			KASSERT(rf->rf_nrssi[1] == BWI_INVALID_NRSSI);
			bwi_rf_calc_nrssi_slope(mac);
		} else {
			KASSERT(rf->rf_nrssi[1] != BWI_INVALID_NRSSI);
			bwi_rf_set_nrssi_thr(mac);
		}
	}

	if (rf->rf_rev == 8)
		PHY_WRITE(mac, 0x805, 0x3230);

	bwi_mac_init_tpctl_11bg(mac);

	if (sc->sc_bbp_id == BWI_BBPID_BCM4306 && sc->sc_bbp_pkg == 2) {
		PHY_CLRBITS(mac, 0x429, 0x4000);
		PHY_CLRBITS(mac, 0x4c3, 0x8000);
	}
}

void
bwi_phy_init_11b_rev2(struct bwi_mac *mac)
{
	struct bwi_softc *sc;

	sc = mac->mac_sc;

	/* TODO: 11B */
	printf("%s: %s is not implemented yet\n",
	    sc->sc_dev.dv_xname, __func__);
}

void
bwi_phy_init_11b_rev4(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	uint16_t val, ofs;
	u_int chan;

	CSR_WRITE_2(sc, BWI_BPHY_CTRL, BWI_BPHY_CTRL_INIT);

	PHY_WRITE(mac, 0x20, 0x301c);
	PHY_WRITE(mac, 0x26, 0);
	PHY_WRITE(mac, 0x30, 0xc6);
	PHY_WRITE(mac, 0x88, 0x3e00);

	for (ofs = 0, val = 0x3c3d; ofs < 30; ++ofs, val -= 0x202)
		PHY_WRITE(mac, 0x89 + ofs, val);

	CSR_WRITE_2(sc, BWI_PHY_MAGIC_REG1, BWI_PHY_MAGIC_REG1_VAL1);

	chan = rf->rf_curchan;
	if (chan == IEEE80211_CHAN_ANY)
		chan = 6;	/* Force to channel 6 */
	bwi_rf_set_chan(mac, chan, 0);

	if (rf->rf_type != BWI_RF_T_BCM2050) {
		RF_WRITE(mac, 0x75, 0x80);
		RF_WRITE(mac, 0x79, 0x81);
	}

	RF_WRITE(mac, 0x50, 0x20);
	RF_WRITE(mac, 0x50, 0x23);

	if (rf->rf_type == BWI_RF_T_BCM2050) {
		RF_WRITE(mac, 0x50, 0x20);
		RF_WRITE(mac, 0x5a, 0x70);
		RF_WRITE(mac, 0x5b, 0x7b);
		RF_WRITE(mac, 0x5c, 0xb0);
		RF_WRITE(mac, 0x7a, 0xf);
		PHY_WRITE(mac, 0x38, 0x677);
		bwi_rf_init_bcm2050(mac);
	}

	PHY_WRITE(mac, 0x14, 0x80);
	PHY_WRITE(mac, 0x32, 0xca);
	if (rf->rf_type == BWI_RF_T_BCM2050)
		PHY_WRITE(mac, 0x32, 0xe0);
	PHY_WRITE(mac, 0x35, 0x7c2);

	bwi_rf_lo_update(mac);

	PHY_WRITE(mac, 0x26, 0xcc00);
	if (rf->rf_type == BWI_RF_T_BCM2050)
		PHY_WRITE(mac, 0x26, 0xce00);

	CSR_WRITE_2(sc, BWI_RF_CHAN_EX, 0x1100);

	PHY_WRITE(mac, 0x2a, 0x88a3);
	if (rf->rf_type == BWI_RF_T_BCM2050)
		PHY_WRITE(mac, 0x2a, 0x88c2);

	bwi_mac_set_tpctl_11bg(mac, NULL);
	if (sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) {
		bwi_rf_calc_nrssi_slope(mac);
		bwi_rf_set_nrssi_thr(mac);
	}
	bwi_mac_init_tpctl_11bg(mac);
}

void
bwi_phy_init_11b_rev5(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_phy *phy = &mac->mac_phy;
	uint orig_chan;

	if (phy->phy_version == 1)
		RF_SETBITS(mac, 0x7a, 0x50);

	if (sc->sc_pci_subvid != PCI_VENDOR_BROADCOM &&
	    sc->sc_pci_subdid != BWI_PCI_SUBDEVICE_BU4306) {
		uint16_t ofs, val;

		val = 0x2120;
		for (ofs = 0xa8; ofs < 0xc7; ++ofs) {
			PHY_WRITE(mac, ofs, val);
			val += 0x202;
		}
	}

	PHY_FILT_SETBITS(mac, 0x35, 0xf0ff, 0x700);

	if (rf->rf_type == BWI_RF_T_BCM2050)
		PHY_WRITE(mac, 0x38, 0x667);

	if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
		if (rf->rf_type == BWI_RF_T_BCM2050) {
			RF_SETBITS(mac, 0x7a, 0x20);
			RF_SETBITS(mac, 0x51, 0x4);
		}

		CSR_WRITE_2(sc, BWI_RF_ANTDIV, 0);

		PHY_SETBITS(mac, 0x802, 0x100);
		PHY_SETBITS(mac, 0x42b, 0x2000);
		PHY_WRITE(mac, 0x1c, 0x186a);

		PHY_FILT_SETBITS(mac, 0x13, 0xff, 0x1900);
		PHY_FILT_SETBITS(mac, 0x35, 0xffc0, 0x64);
		PHY_FILT_SETBITS(mac, 0x5d, 0xff80, 0xa);
	}

	/* TODO: bad_frame_preempt? */

	if (phy->phy_version == 1) {
	    	PHY_WRITE(mac, 0x26, 0xce00);
		PHY_WRITE(mac, 0x21, 0x3763);
		PHY_WRITE(mac, 0x22, 0x1bc3);
		PHY_WRITE(mac, 0x23, 0x6f9);
		PHY_WRITE(mac, 0x24, 0x37e);
	} else
		PHY_WRITE(mac, 0x26, 0xcc00);
	PHY_WRITE(mac, 0x30, 0xc6);

	CSR_WRITE_2(sc, BWI_BPHY_CTRL, BWI_BPHY_CTRL_INIT);

	if (phy->phy_version == 1)
		PHY_WRITE(mac, 0x20, 0x3e1c);
	else
		PHY_WRITE(mac, 0x20, 0x301c);

	if (phy->phy_version == 0)
		CSR_WRITE_2(sc, BWI_PHY_MAGIC_REG1, BWI_PHY_MAGIC_REG1_VAL1);

	/* Force to channel 7 */
	orig_chan = rf->rf_curchan;
	bwi_rf_set_chan(mac, 7, 0);

	if (rf->rf_type != BWI_RF_T_BCM2050) {
		RF_WRITE(mac, 0x75, 0x80);
		RF_WRITE(mac, 0x79, 0x81);
	}

	RF_WRITE(mac, 0x50, 0x20);
	RF_WRITE(mac, 0x50, 0x23);

	if (rf->rf_type == BWI_RF_T_BCM2050) {
		RF_WRITE(mac, 0x50, 0x20);
		RF_WRITE(mac, 0x5a, 0x70);
	}

	RF_WRITE(mac, 0x5b, 0x7b);
	RF_WRITE(mac, 0x5c, 0xb0);
	RF_SETBITS(mac, 0x7a, 0x7);

	bwi_rf_set_chan(mac, orig_chan, 0);

	PHY_WRITE(mac, 0x14, 0x80);
	PHY_WRITE(mac, 0x32, 0xca);
	PHY_WRITE(mac, 0x2a, 0x88a3);

	bwi_mac_set_tpctl_11bg(mac, NULL);

	if (rf->rf_type == BWI_RF_T_BCM2050)
		RF_WRITE(mac, 0x5d, 0xd);

	CSR_FILT_SETBITS_2(sc, BWI_PHY_MAGIC_REG1, 0xffc0, 0x4);
}

void
bwi_phy_init_11b_rev6(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_phy *phy = &mac->mac_phy;
	uint16_t val, ofs;
	uint orig_chan;

	PHY_WRITE(mac, 0x3e, 0x817a);
	RF_SETBITS(mac, 0x7a, 0x58);

	if (rf->rf_rev == 4 || rf->rf_rev == 5) {
		RF_WRITE(mac, 0x51, 0x37);
		RF_WRITE(mac, 0x52, 0x70);
		RF_WRITE(mac, 0x53, 0xb3);
		RF_WRITE(mac, 0x54, 0x9b);
		RF_WRITE(mac, 0x5a, 0x88);
		RF_WRITE(mac, 0x5b, 0x88);
		RF_WRITE(mac, 0x5d, 0x88);
		RF_WRITE(mac, 0x5e, 0x88);
		RF_WRITE(mac, 0x7d, 0x88);
		HFLAGS_SETBITS(mac, BWI_HFLAG_MAGIC1);
	} else if (rf->rf_rev == 8) {
		RF_WRITE(mac, 0x51, 0);
		RF_WRITE(mac, 0x52, 0x40);
		RF_WRITE(mac, 0x53, 0xb7);
		RF_WRITE(mac, 0x54, 0x98);
		RF_WRITE(mac, 0x5a, 0x88);
		RF_WRITE(mac, 0x5b, 0x6b);
		RF_WRITE(mac, 0x5c, 0xf);
		if (sc->sc_card_flags & BWI_CARD_F_ALT_IQ) {
			RF_WRITE(mac, 0x5d, 0xfa);
			RF_WRITE(mac, 0x5e, 0xd8);
		} else {
			RF_WRITE(mac, 0x5d, 0xf5);
			RF_WRITE(mac, 0x5e, 0xb8);
		}
		RF_WRITE(mac, 0x73, 0x3);
		RF_WRITE(mac, 0x7d, 0xa8);
		RF_WRITE(mac, 0x7c, 0x1);
		RF_WRITE(mac, 0x7e, 0x8);
	}

	val = 0x1e1f;
	for (ofs = 0x88; ofs < 0x98; ++ofs) {
		PHY_WRITE(mac, ofs, val);
		val -= 0x202;
	}

	val = 0x3e3f;
	for (ofs = 0x98; ofs < 0xa8; ++ofs) {
		PHY_WRITE(mac, ofs, val);
		val -= 0x202;
	}

	val = 0x2120;
	for (ofs = 0xa8; ofs < 0xc8; ++ofs) {
		PHY_WRITE(mac, ofs, (val & 0x3f3f));
		val += 0x202;

		/* XXX: delay 10 us to avoid PCI parity errors with BCM4318 */
		DELAY(10);
	}

	if (phy->phy_mode == IEEE80211_MODE_11G) {
		RF_SETBITS(mac, 0x7a, 0x20);
		RF_SETBITS(mac, 0x51, 0x4);
		PHY_SETBITS(mac, 0x802, 0x100);
		PHY_SETBITS(mac, 0x42b, 0x2000);
		PHY_WRITE(mac, 0x5b, 0);
		PHY_WRITE(mac, 0x5c, 0);
	}

	/* Force to channel 7 */
	orig_chan = rf->rf_curchan;
	if (orig_chan >= 8)
		bwi_rf_set_chan(mac, 1, 0);
	else
		bwi_rf_set_chan(mac, 13, 0);

	RF_WRITE(mac, 0x50, 0x20);
	RF_WRITE(mac, 0x50, 0x23);

	DELAY(40);

	if (rf->rf_rev < 6 || rf->rf_rev == 8) {
		RF_SETBITS(mac, 0x7c, 0x2);
		RF_WRITE(mac, 0x50, 0x20);
	}
	if (rf->rf_rev <= 2) {
		RF_WRITE(mac, 0x7c, 0x20);
		RF_WRITE(mac, 0x5a, 0x70);
		RF_WRITE(mac, 0x5b, 0x7b);
		RF_WRITE(mac, 0x5c, 0xb0);
	}

	RF_FILT_SETBITS(mac, 0x7a, 0xf8, 0x7);

	bwi_rf_set_chan(mac, orig_chan, 0);

	PHY_WRITE(mac, 0x14, 0x200);
	if (rf->rf_rev >= 6)
		PHY_WRITE(mac, 0x2a, 0x88c2);
	else
		PHY_WRITE(mac, 0x2a, 0x8ac0);
	PHY_WRITE(mac, 0x38, 0x668);

	bwi_mac_set_tpctl_11bg(mac, NULL);

	if (rf->rf_rev <= 5) {
		PHY_FILT_SETBITS(mac, 0x5d, 0xff80, 0x3);
		if (rf->rf_rev <= 2)
			RF_WRITE(mac, 0x5d, 0xd);
	}

	if (phy->phy_version == 4) {
		CSR_WRITE_2(sc, BWI_PHY_MAGIC_REG1, BWI_PHY_MAGIC_REG1_VAL2);
		PHY_CLRBITS(mac, 0x61, 0xf000);
	} else {
		PHY_FILT_SETBITS(mac, 0x2, 0xffc0, 0x4);
	}

	if (phy->phy_mode == IEEE80211_MODE_11B) {
		CSR_WRITE_2(sc, BWI_BBP_ATTEN, BWI_BBP_ATTEN_MAGIC2);
		PHY_WRITE(mac, 0x16, 0x410);
		PHY_WRITE(mac, 0x17, 0x820);
		PHY_WRITE(mac, 0x62, 0x7);

		bwi_rf_init_bcm2050(mac);
		bwi_rf_lo_update(mac);
		if (sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) {
			bwi_rf_calc_nrssi_slope(mac);
			bwi_rf_set_nrssi_thr(mac);
		}
		bwi_mac_init_tpctl_11bg(mac);
	} else
		CSR_WRITE_2(sc, BWI_BBP_ATTEN, 0);
}

void
bwi_phy_config_11g(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	const uint16_t *tbl;
	uint16_t wrd_ofs1, wrd_ofs2;
	int i, n;

	if (phy->phy_rev == 1) {
		PHY_WRITE(mac, 0x406, 0x4f19);
		PHY_FILT_SETBITS(mac, 0x429, 0xfc3f, 0x340);
		PHY_WRITE(mac, 0x42c, 0x5a);
		PHY_WRITE(mac, 0x427, 0x1a);

		/* Fill frequency table */
		for (i = 0; i < nitems(bwi_phy_freq_11g_rev1); ++i) {
			bwi_tbl_write_2(mac, BWI_PHYTBL_FREQ + i,
			    bwi_phy_freq_11g_rev1[i]);
		}

		/* Fill noise table */
		for (i = 0; i < nitems(bwi_phy_noise_11g_rev1); ++i) {
			bwi_tbl_write_2(mac, BWI_PHYTBL_NOISE + i,
			    bwi_phy_noise_11g_rev1[i]);
		}

		/* Fill rotor table */
		for (i = 0; i < nitems(bwi_phy_rotor_11g_rev1); ++i) {
			/* NB: data length is 4 bytes */
			bwi_tbl_write_4(mac, BWI_PHYTBL_ROTOR + i,
			    bwi_phy_rotor_11g_rev1[i]);
		}
	} else {
		bwi_nrssi_write(mac, 0xba98, (int16_t)0x7654); /* XXX */

		if (phy->phy_rev == 2) {
			PHY_WRITE(mac, 0x4c0, 0x1861);
			PHY_WRITE(mac, 0x4c1, 0x271);
		} else if (phy->phy_rev > 2) {
			PHY_WRITE(mac, 0x4c0, 0x98);
			PHY_WRITE(mac, 0x4c1, 0x70);
			PHY_WRITE(mac, 0x4c9, 0x80);
		}
		PHY_SETBITS(mac, 0x42b, 0x800);

		/* Fill RSSI table */
		for (i = 0; i < 64; ++i)
			bwi_tbl_write_2(mac, BWI_PHYTBL_RSSI + i, i);

		/* Fill noise table */
		for (i = 0; i < nitems(bwi_phy_noise_11g); ++i) {
			bwi_tbl_write_2(mac, BWI_PHYTBL_NOISE + i,
			    bwi_phy_noise_11g[i]);
		}
	}

	/*
	 * Fill noise scale table
	 */
	if (phy->phy_rev <= 2) {
		tbl = bwi_phy_noise_scale_11g_rev2;
		n = nitems(bwi_phy_noise_scale_11g_rev2);
	} else if (phy->phy_rev >= 7 && (PHY_READ(mac, 0x449) & 0x200)) {
		tbl = bwi_phy_noise_scale_11g_rev7;
		n = nitems(bwi_phy_noise_scale_11g_rev7);
	} else {
		tbl = bwi_phy_noise_scale_11g;
		n = nitems(bwi_phy_noise_scale_11g);
	}
	for (i = 0; i < n; ++i)
		bwi_tbl_write_2(mac, BWI_PHYTBL_NOISE_SCALE + i, tbl[i]);

	/*
	 * Fill sigma square table
	 */
	if (phy->phy_rev == 2) {
		tbl = bwi_phy_sigma_sq_11g_rev2;
		n = nitems(bwi_phy_sigma_sq_11g_rev2);
	} else if (phy->phy_rev > 2 && phy->phy_rev <= 8) {
		tbl = bwi_phy_sigma_sq_11g_rev7;
		n = nitems(bwi_phy_sigma_sq_11g_rev7);
	} else {
		tbl = NULL;
		n = 0;
	}
	for (i = 0; i < n; ++i)
		bwi_tbl_write_2(mac, BWI_PHYTBL_SIGMA_SQ + i, tbl[i]);

	if (phy->phy_rev == 1) {
		/* Fill delay table */
		for (i = 0; i < nitems(bwi_phy_delay_11g_rev1); ++i) {
			bwi_tbl_write_4(mac, BWI_PHYTBL_DELAY + i,
			    bwi_phy_delay_11g_rev1[i]);
		}

		/* Fill WRSSI (Wide-Band RSSI) table */
		for (i = 4; i < 20; ++i)
			bwi_tbl_write_2(mac, BWI_PHYTBL_WRSSI_REV1 + i, 0x20);

		bwi_phy_config_agc(mac);

		wrd_ofs1 = 0x5001;
		wrd_ofs2 = 0x5002;
	} else {
		/* Fill WRSSI (Wide-Band RSSI) table */
		for (i = 0; i < 0x20; ++i)
			bwi_tbl_write_2(mac, BWI_PHYTBL_WRSSI + i, 0x820);

		bwi_phy_config_agc(mac);

		PHY_READ(mac, 0x400);	/* Dummy read */
		PHY_WRITE(mac, 0x403, 0x1000);
		bwi_tbl_write_2(mac, 0x3c02, 0xf);
		bwi_tbl_write_2(mac, 0x3c03, 0x14);

		wrd_ofs1 = 0x401;
		wrd_ofs2 = 0x402;
	}

	if (!(BWI_IS_BRCM_BU4306(sc) && sc->sc_pci_revid == 0x17)) {
		bwi_tbl_write_2(mac, wrd_ofs1, 0x2);
		bwi_tbl_write_2(mac, wrd_ofs2, 0x1);
	}

	/* phy->phy_flags & BWI_PHY_F_LINKED ? */
	if (sc->sc_card_flags & BWI_CARD_F_PA_GPIO9)
		PHY_WRITE(mac, 0x46e, 0x3cf);
}
#undef N

/*
 * Configure Automatic Gain Controller
 */
void
bwi_phy_config_agc(struct bwi_mac *mac)
{
	struct bwi_phy *phy = &mac->mac_phy;
	uint16_t ofs;

	ofs = phy->phy_rev == 1 ? 0x4c00 : 0;

	bwi_tbl_write_2(mac, ofs, 0xfe);
	bwi_tbl_write_2(mac, ofs + 1, 0xd);
	bwi_tbl_write_2(mac, ofs + 2, 0x13);
	bwi_tbl_write_2(mac, ofs + 3, 0x19);

	if (phy->phy_rev == 1) {
		bwi_tbl_write_2(mac, 0x1800, 0x2710);
		bwi_tbl_write_2(mac, 0x1801, 0x9b83);
		bwi_tbl_write_2(mac, 0x1802, 0x9b83);
		bwi_tbl_write_2(mac, 0x1803, 0xf8d);
		PHY_WRITE(mac, 0x455, 0x4);
	}

	PHY_FILT_SETBITS(mac, 0x4a5, 0xff, 0x5700);
	PHY_FILT_SETBITS(mac, 0x41a, 0xff80, 0xf);
	PHY_FILT_SETBITS(mac, 0x41a, 0xc07f, 0x2b80);
	PHY_FILT_SETBITS(mac, 0x48c, 0xf0ff, 0x300);

	RF_SETBITS(mac, 0x7a, 0x8);

	PHY_FILT_SETBITS(mac, 0x4a0, 0xfff0, 0x8);
	PHY_FILT_SETBITS(mac, 0x4a1, 0xf0ff, 0x600);
	PHY_FILT_SETBITS(mac, 0x4a2, 0xf0ff, 0x700);
	PHY_FILT_SETBITS(mac, 0x4a0, 0xf0ff, 0x100);

	if (phy->phy_rev == 1)
		PHY_FILT_SETBITS(mac, 0x4a2, 0xfff0, 0x7);

	PHY_FILT_SETBITS(mac, 0x488, 0xff00, 0x1c);
	PHY_FILT_SETBITS(mac, 0x488, 0xc0ff, 0x200);
	PHY_FILT_SETBITS(mac, 0x496, 0xff00, 0x1c);
	PHY_FILT_SETBITS(mac, 0x489, 0xff00, 0x20);
	PHY_FILT_SETBITS(mac, 0x489, 0xc0ff, 0x200);
	PHY_FILT_SETBITS(mac, 0x482, 0xff00, 0x2e);
	PHY_FILT_SETBITS(mac, 0x496, 0xff, 0x1a00);
	PHY_FILT_SETBITS(mac, 0x481, 0xff00, 0x28);
	PHY_FILT_SETBITS(mac, 0x481, 0xff, 0x2c00);

	if (phy->phy_rev == 1) {
		PHY_WRITE(mac, 0x430, 0x92b);
		PHY_FILT_SETBITS(mac, 0x41b, 0xffe1, 0x2);
	} else {
		PHY_CLRBITS(mac, 0x41b, 0x1e);
		PHY_WRITE(mac, 0x41f, 0x287a);
		PHY_FILT_SETBITS(mac, 0x420, 0xfff0, 0x4);

		if (phy->phy_rev >= 6) {
			PHY_WRITE(mac, 0x422, 0x287a);
			PHY_FILT_SETBITS(mac, 0x420, 0xfff, 0x3000);
		}
	}

	PHY_FILT_SETBITS(mac, 0x4a8, 0x8080, 0x7874);
	PHY_WRITE(mac, 0x48e, 0x1c00);

	if (phy->phy_rev == 1) {
		PHY_FILT_SETBITS(mac, 0x4ab, 0xf0ff, 0x600);
		PHY_WRITE(mac, 0x48b, 0x5e);
		PHY_FILT_SETBITS(mac, 0x48c, 0xff00, 0x1e);
		PHY_WRITE(mac, 0x48d, 0x2);
	}

	bwi_tbl_write_2(mac, ofs + 0x800, 0);
	bwi_tbl_write_2(mac, ofs + 0x801, 7);
	bwi_tbl_write_2(mac, ofs + 0x802, 16);
	bwi_tbl_write_2(mac, ofs + 0x803, 28);

	if (phy->phy_rev >= 6) {
		PHY_CLRBITS(mac, 0x426, 0x3);
		PHY_CLRBITS(mac, 0x426, 0x1000);
	}
}

void
bwi_set_gains(struct bwi_mac *mac, const struct bwi_gains *gains)
{
	struct bwi_phy *phy = &mac->mac_phy;
	uint16_t tbl_gain_ofs1, tbl_gain_ofs2, tbl_gain;
	int i;

	if (phy->phy_rev <= 1) {
		tbl_gain_ofs1 = 0x5000;
		tbl_gain_ofs2 = tbl_gain_ofs1 + 16;
	} else {
		tbl_gain_ofs1 = 0x400;
		tbl_gain_ofs2 = tbl_gain_ofs1 + 8;
	}

	for (i = 0; i < 4; ++i) {
		if (gains != NULL) {
			tbl_gain = gains->tbl_gain1;
		} else {
			/* Bit swap */
			tbl_gain = (i & 0x1) << 1;
			tbl_gain |= (i & 0x2) >> 1;
		}
		bwi_tbl_write_2(mac, tbl_gain_ofs1 + i, tbl_gain);
	}

	for (i = 0; i < 16; ++i) {
		if (gains != NULL)
			tbl_gain = gains->tbl_gain2;
		else
			tbl_gain = i;
		bwi_tbl_write_2(mac, tbl_gain_ofs2 + i, tbl_gain);
	}

	if (gains == NULL || (gains != NULL && gains->phy_gain != -1)) {
		uint16_t phy_gain1, phy_gain2;

		if (gains != NULL) {
			phy_gain1 =
			((uint16_t)gains->phy_gain << 14) |
			((uint16_t)gains->phy_gain << 6);
			phy_gain2 = phy_gain1;
		} else {
			phy_gain1 = 0x4040;
			phy_gain2 = 0x4000;
		}
		PHY_FILT_SETBITS(mac, 0x4a0, 0xbfbf, phy_gain1);
		PHY_FILT_SETBITS(mac, 0x4a1, 0xbfbf, phy_gain1);
		PHY_FILT_SETBITS(mac, 0x4a2, 0xbfbf, phy_gain2);
	}
	bwi_mac_dummy_xmit(mac);
}

void
bwi_phy_clear_state(struct bwi_phy *phy)
{
	phy->phy_flags &= ~BWI_CLEAR_PHY_FLAGS;
}

/* RF */

int16_t
bwi_nrssi_11g(struct bwi_mac *mac)
{
	int16_t val;

#define NRSSI_11G_MASK		0x3f00
	val = (int16_t)__SHIFTOUT(PHY_READ(mac, 0x47f), NRSSI_11G_MASK);
	if (val >= 32)
		val -= 64;

	return (val);
#undef NRSSI_11G_MASK
}

struct bwi_rf_lo *
bwi_get_rf_lo(struct bwi_mac *mac, uint16_t rf_atten, uint16_t bbp_atten)
{
	int n;

	n = rf_atten + (14 * (bbp_atten / 2));
	KASSERT(n < BWI_RFLO_MAX);

	return (&mac->mac_rf.rf_lo[n]);
}

int
bwi_rf_lo_isused(struct bwi_mac *mac, const struct bwi_rf_lo *lo)
{
	struct bwi_rf *rf = &mac->mac_rf;
	int idx;

	idx = lo - rf->rf_lo;
	KASSERT(idx >= 0 && idx < BWI_RFLO_MAX);

	return (isset(rf->rf_lo_used, idx));
}

void
bwi_rf_write(struct bwi_mac *mac, uint16_t ctrl, uint16_t data)
{
	struct bwi_softc *sc = mac->mac_sc;

	CSR_WRITE_2(sc, BWI_RF_CTRL, ctrl);
	CSR_WRITE_2(sc, BWI_RF_DATA_LO, data);
}

uint16_t
bwi_rf_read(struct bwi_mac *mac, uint16_t ctrl)
{
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_softc *sc = mac->mac_sc;

	ctrl |= rf->rf_ctrl_rd;
	if (rf->rf_ctrl_adj) {
		/* XXX */
		if (ctrl < 0x70)
			ctrl += 0x80;
		else if (ctrl < 0x80)
			ctrl += 0x70;
	}

	CSR_WRITE_2(sc, BWI_RF_CTRL, ctrl);
	return (CSR_READ_2(sc, BWI_RF_DATA_LO));
}

int
bwi_rf_attach(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_rf *rf = &mac->mac_rf;
	uint16_t type, manu;
	uint8_t rev;

	/*
	 * Get RF manufacture/type/revision
	 */
	if (sc->sc_bbp_id == BWI_BBPID_BCM4317) {
		/*
		 * Fake a BCM2050 RF
		 */
		manu = BWI_RF_MANUFACT_BCM;
		type = BWI_RF_T_BCM2050;
		if (sc->sc_bbp_rev == 0)
			rev = 3;
		else if (sc->sc_bbp_rev == 1)
			rev = 4;
		else
			rev = 5;
	} else {
		uint32_t val;

		CSR_WRITE_2(sc, BWI_RF_CTRL, BWI_RF_CTRL_RFINFO);
		val = CSR_READ_2(sc, BWI_RF_DATA_HI);
		val <<= 16;

		CSR_WRITE_2(sc, BWI_RF_CTRL, BWI_RF_CTRL_RFINFO);
		val |= CSR_READ_2(sc, BWI_RF_DATA_LO);

		manu = __SHIFTOUT(val, BWI_RFINFO_MANUFACT_MASK);
		type = __SHIFTOUT(val, BWI_RFINFO_TYPE_MASK);
		rev = __SHIFTOUT(val, BWI_RFINFO_REV_MASK);
	}
	DPRINTF(1, "%s: RF manu 0x%03x, type 0x%04x, rev %u\n",
	    sc->sc_dev.dv_xname, manu, type, rev);

	/*
	 * Verify whether the RF is supported
	 */
	rf->rf_ctrl_rd = 0;
	rf->rf_ctrl_adj = 0;
	switch (phy->phy_mode) {
	case IEEE80211_MODE_11A:
		if (manu != BWI_RF_MANUFACT_BCM ||
		    type != BWI_RF_T_BCM2060 ||
		    rev != 1) {
			printf("%s: only BCM2060 rev 1 RF is supported for "
			    "11A PHY\n", sc->sc_dev.dv_xname);
			return (ENXIO);
		}
		rf->rf_ctrl_rd = BWI_RF_CTRL_RD_11A;
		rf->rf_on = bwi_rf_on_11a;
		rf->rf_off = bwi_rf_off_11a;
		rf->rf_calc_rssi = bwi_rf_calc_rssi_bcm2060;
		break;
	case IEEE80211_MODE_11B:
		if (type == BWI_RF_T_BCM2050) {
			rf->rf_ctrl_rd = BWI_RF_CTRL_RD_11BG;
			rf->rf_calc_rssi = bwi_rf_calc_rssi_bcm2050;
		} else if (type == BWI_RF_T_BCM2053) {
			rf->rf_ctrl_adj = 1;
			rf->rf_calc_rssi = bwi_rf_calc_rssi_bcm2053;
		} else {
			printf("%s: only BCM2050/BCM2053 RF is supported "
			    "for supported for 11B PHY\n", sc->sc_dev.dv_xname);
			return (ENXIO);
		}
		rf->rf_on = bwi_rf_on_11bg;
		rf->rf_off = bwi_rf_off_11bg;
		rf->rf_calc_nrssi_slope = bwi_rf_calc_nrssi_slope_11b;
		rf->rf_set_nrssi_thr = bwi_rf_set_nrssi_thr_11b;
		if (phy->phy_rev == 6)
			rf->rf_lo_update = bwi_rf_lo_update_11g;
		else
			rf->rf_lo_update = bwi_rf_lo_update_11b;
		break;
	case IEEE80211_MODE_11G:
		if (type != BWI_RF_T_BCM2050) {
			printf("%s: only BCM2050 RF is supported for 11G "
			    "PHY\n", sc->sc_dev.dv_xname);
			return (ENXIO);
		}
		rf->rf_ctrl_rd = BWI_RF_CTRL_RD_11BG;
		rf->rf_on = bwi_rf_on_11bg;
		if (mac->mac_rev >= 5)
			rf->rf_off = bwi_rf_off_11g_rev5;
		else
			rf->rf_off = bwi_rf_off_11bg;
		rf->rf_calc_nrssi_slope = bwi_rf_calc_nrssi_slope_11g;
		rf->rf_set_nrssi_thr = bwi_rf_set_nrssi_thr_11g;
		rf->rf_calc_rssi = bwi_rf_calc_rssi_bcm2050;
		rf->rf_lo_update = bwi_rf_lo_update_11g;
		break;
	default:
		printf("%s: unsupported PHY mode\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	rf->rf_type = type;
	rf->rf_rev = rev;
	rf->rf_manu = manu;
	rf->rf_curchan = IEEE80211_CHAN_ANY;
	rf->rf_ant_mode = BWI_ANT_MODE_AUTO;

	return (0);
}

void
bwi_rf_set_chan(struct bwi_mac *mac, uint chan, int work_around)
{
	struct bwi_softc *sc = mac->mac_sc;

	if (chan == IEEE80211_CHAN_ANY)
		return;

	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_CHAN, chan);

	/* TODO: 11A */

	if (work_around)
		bwi_rf_workaround(mac, chan);

	CSR_WRITE_2(sc, BWI_RF_CHAN, BWI_RF_2GHZ_CHAN(chan));

	if (chan == 14) {
		if (sc->sc_locale == BWI_SPROM_LOCALE_JAPAN)
			HFLAGS_CLRBITS(mac, BWI_HFLAG_NOT_JAPAN);
		else
			HFLAGS_SETBITS(mac, BWI_HFLAG_NOT_JAPAN);
		CSR_SETBITS_2(sc, BWI_RF_CHAN_EX, (1 << 11)); /* XXX */
	} else {
		CSR_CLRBITS_2(sc, BWI_RF_CHAN_EX, 0x840); /* XXX */
	}
	DELAY(8000);	/* DELAY(2000); */

	mac->mac_rf.rf_curchan = chan;
}

void
bwi_rf_get_gains(struct bwi_mac *mac)
{
#define SAVE_PHY_MAX	15
#define SAVE_RF_MAX	3
	struct bwi_softc *sc;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_rf *rf = &mac->mac_rf;
	uint16_t save_phy[SAVE_PHY_MAX];
	uint16_t save_rf[SAVE_RF_MAX];
	uint16_t trsw;
	int i, j, loop1_max, loop1, loop2;

	static const uint16_t save_rf_regs[SAVE_RF_MAX] =
	    { 0x52, 0x43, 0x7a };
	static const uint16_t save_phy_regs[SAVE_PHY_MAX] = {
	    0x0429, 0x0001, 0x0811, 0x0812,
	    0x0814, 0x0815, 0x005a, 0x0059,
	    0x0058, 0x000a, 0x0003, 0x080f,
	    0x0810, 0x002b, 0x0015
	};

	sc = mac->mac_sc;

	/*
	 * Save PHY/RF registers for later restoration
	 */
	for (i = 0; i < SAVE_PHY_MAX; ++i)
		save_phy[i] = PHY_READ(mac, save_phy_regs[i]);
	PHY_READ(mac, 0x2d); /* dummy read */

	for (i = 0; i < SAVE_RF_MAX; ++i)
		save_rf[i] = RF_READ(mac, save_rf_regs[i]);

	PHY_CLRBITS(mac, 0x429, 0xc000);
	PHY_SETBITS(mac, 0x1, 0x8000);

	PHY_SETBITS(mac, 0x811, 0x2);
	PHY_CLRBITS(mac, 0x812, 0x2);
	PHY_SETBITS(mac, 0x811, 0x1);
	PHY_CLRBITS(mac, 0x812, 0x1);

	PHY_SETBITS(mac, 0x814, 0x1);
	PHY_CLRBITS(mac, 0x815, 0x1);
	PHY_SETBITS(mac, 0x814, 0x2);
	PHY_CLRBITS(mac, 0x815, 0x2);

	PHY_SETBITS(mac, 0x811, 0xc);
	PHY_SETBITS(mac, 0x812, 0xc);
	PHY_SETBITS(mac, 0x811, 0x30);
	PHY_FILT_SETBITS(mac, 0x812, 0xffcf, 0x10);

	PHY_WRITE(mac, 0x5a, 0x780);
	PHY_WRITE(mac, 0x59, 0xc810);
	PHY_WRITE(mac, 0x58, 0xd);
	PHY_SETBITS(mac, 0xa, 0x2000);

	PHY_SETBITS(mac, 0x814, 0x4);
	PHY_CLRBITS(mac, 0x815, 0x4);

	PHY_FILT_SETBITS(mac, 0x3, 0xff9f, 0x40);

	if (rf->rf_rev == 8) {
		loop1_max = 15;
		RF_WRITE(mac, 0x43, loop1_max);
	} else {
		loop1_max = 9;
	    	RF_WRITE(mac, 0x52, 0x0);
		RF_FILT_SETBITS(mac, 0x43, 0xfff0, loop1_max);
	}

	bwi_phy_set_bbp_atten(mac, 11);

	if (phy->phy_rev >= 3)
		PHY_WRITE(mac, 0x80f, 0xc020);
	else
		PHY_WRITE(mac, 0x80f, 0x8020);
	PHY_WRITE(mac, 0x810, 0);

	PHY_FILT_SETBITS(mac, 0x2b, 0xffc0, 0x1);
	PHY_FILT_SETBITS(mac, 0x2b, 0xc0ff, 0x800);
	PHY_SETBITS(mac, 0x811, 0x100);
	PHY_CLRBITS(mac, 0x812, 0x3000);

	if ((mac->mac_sc->sc_card_flags & BWI_CARD_F_EXT_LNA) &&
	    phy->phy_rev >= 7) {
		PHY_SETBITS(mac, 0x811, 0x800);
		PHY_SETBITS(mac, 0x812, 0x8000);
	}
	RF_CLRBITS(mac, 0x7a, 0xff08);

	/*
	 * Find out 'loop1/loop2', which will be used to calculate
	 * max loopback gain later
	 */
	j = 0;
	for (i = 0; i < loop1_max; ++i) {
		for (j = 0; j < 16; ++j) {
			RF_WRITE(mac, 0x43, i);

			if (bwi_rf_gain_max_reached(mac, j))
				goto loop1_exit;
		}
	}
loop1_exit:
	loop1 = i;
	loop2 = j;

	/*
	 * Find out 'trsw', which will be used to calculate
	 * TRSW(TX/RX switch) RX gain later
	 */
	if (loop2 >= 8) {
		PHY_SETBITS(mac, 0x812, 0x30);
		trsw = 0x1b;
		for (i = loop2 - 8; i < 16; ++i) {
			trsw -= 3;
			if (bwi_rf_gain_max_reached(mac, i))
				break;
		}
	} else {
		trsw = 0x18;
	}

	/*
	 * Restore saved PHY/RF registers
	 */
	/* First 4 saved PHY registers need special processing */
	for (i = 4; i < SAVE_PHY_MAX; ++i)
		PHY_WRITE(mac, save_phy_regs[i], save_phy[i]);

	bwi_phy_set_bbp_atten(mac, mac->mac_tpctl.bbp_atten);

	for (i = 0; i < SAVE_RF_MAX; ++i)
		RF_WRITE(mac, save_rf_regs[i], save_rf[i]);

	PHY_WRITE(mac, save_phy_regs[2], save_phy[2] | 0x3);
	DELAY(10);
	PHY_WRITE(mac, save_phy_regs[2], save_phy[2]);
	PHY_WRITE(mac, save_phy_regs[3], save_phy[3]);
	PHY_WRITE(mac, save_phy_regs[0], save_phy[0]);
	PHY_WRITE(mac, save_phy_regs[1], save_phy[1]);

	/*
	 * Calculate gains
	 */
	rf->rf_lo_gain = (loop2 * 6) - (loop1 * 4) - 11;
	rf->rf_rx_gain = trsw * 2;
	DPRINTF(1, "%s: lo gain: %u, rx gain: %u\n",
	    sc->sc_dev.dv_xname, rf->rf_lo_gain, rf->rf_rx_gain);

#undef SAVE_RF_MAX
#undef SAVE_PHY_MAX
}

void
bwi_rf_init(struct bwi_mac *mac)
{
	struct bwi_rf *rf = &mac->mac_rf;

	if (rf->rf_type == BWI_RF_T_BCM2060) {
		/* TODO: 11A */
	} else {
		if (rf->rf_flags & BWI_RF_F_INITED)
			RF_WRITE(mac, 0x78, rf->rf_calib);
		else
			bwi_rf_init_bcm2050(mac);
	}
}

void
bwi_rf_off_11a(struct bwi_mac *mac)
{
	RF_WRITE(mac, 0x4, 0xff);
	RF_WRITE(mac, 0x5, 0xfb);

	PHY_SETBITS(mac, 0x10, 0x8);
	PHY_SETBITS(mac, 0x11, 0x8);

	PHY_WRITE(mac, 0x15, 0xaa00);
}

void
bwi_rf_off_11bg(struct bwi_mac *mac)
{
	PHY_WRITE(mac, 0x15, 0xaa00);
}

void
bwi_rf_off_11g_rev5(struct bwi_mac *mac)
{
	PHY_SETBITS(mac, 0x811, 0x8c);
	PHY_CLRBITS(mac, 0x812, 0x8c);
}

void
bwi_rf_workaround(struct bwi_mac *mac, uint chan)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;

	if (chan == IEEE80211_CHAN_ANY) {
		printf("%s: %s invalid channel!\n",
		    sc->sc_dev.dv_xname, __func__);
		return;
	}

	if (rf->rf_type != BWI_RF_T_BCM2050 || rf->rf_rev >= 6)
		return;

	if (chan <= 10)
		CSR_WRITE_2(sc, BWI_RF_CHAN, BWI_RF_2GHZ_CHAN(chan + 4));
	else
		CSR_WRITE_2(sc, BWI_RF_CHAN, BWI_RF_2GHZ_CHAN(1));
	DELAY(1000);
	CSR_WRITE_2(sc, BWI_RF_CHAN, BWI_RF_2GHZ_CHAN(chan));
}

struct bwi_rf_lo *
bwi_rf_lo_find(struct bwi_mac *mac, const struct bwi_tpctl *tpctl)
{
	uint16_t rf_atten, bbp_atten;
	int remap_rf_atten;

	remap_rf_atten = 1;
	if (tpctl == NULL) {
		bbp_atten = 2;
		rf_atten = 3;
	} else {
		if (tpctl->tp_ctrl1 == 3)
			remap_rf_atten = 0;

		bbp_atten = tpctl->bbp_atten;
		rf_atten = tpctl->rf_atten;

		if (bbp_atten > 6)
			bbp_atten = 6;
	}

	if (remap_rf_atten) {
#define MAP_MAX	10
		static const uint16_t map[MAP_MAX] =
		{ 11, 10, 11, 12, 13, 12, 13, 12, 13, 12 };
#if 0
		KASSERT(rf_atten < MAP_MAX);
		rf_atten = map[rf_atten];
#else
		if (rf_atten >= MAP_MAX) {
			rf_atten = 0;	/* XXX */
		} else {
			rf_atten = map[rf_atten];
		}
#endif
#undef MAP_MAX
	}

	return (bwi_get_rf_lo(mac, rf_atten, bbp_atten));
}

void
bwi_rf_lo_adjust(struct bwi_mac *mac, const struct bwi_tpctl *tpctl)
{
	const struct bwi_rf_lo *lo;

	lo = bwi_rf_lo_find(mac, tpctl);
	RF_LO_WRITE(mac, lo);
}

void
bwi_rf_lo_write(struct bwi_mac *mac, const struct bwi_rf_lo *lo)
{
	uint16_t val;

	val = (uint8_t)lo->ctrl_lo;
	val |= ((uint8_t)lo->ctrl_hi) << 8;

	PHY_WRITE(mac, BWI_PHYR_RF_LO, val);
}

int
bwi_rf_gain_max_reached(struct bwi_mac *mac, int idx)
{
	PHY_FILT_SETBITS(mac, 0x812, 0xf0ff, idx << 8);
	PHY_FILT_SETBITS(mac, 0x15, 0xfff, 0xa000);
	PHY_SETBITS(mac, 0x15, 0xf000);

	DELAY(20);

	return ((PHY_READ(mac, 0x2d) >= 0xdfc));
}

/* XXX use bitmap array */
uint16_t
bwi_bitswap4(uint16_t val)
{
	uint16_t ret;

	ret = (val & 0x8) >> 3;
	ret |= (val & 0x4) >> 1;
	ret |= (val & 0x2) << 1;
	ret |= (val & 0x1) << 3;

	return (ret);
}

uint16_t
bwi_phy812_value(struct bwi_mac *mac, uint16_t lpd)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_rf *rf = &mac->mac_rf;
	uint16_t lo_gain, ext_lna, loop;

	if ((phy->phy_flags & BWI_PHY_F_LINKED) == 0)
		return (0);

	lo_gain = rf->rf_lo_gain;
	if (rf->rf_rev == 8)
		lo_gain += 0x3e;
	else
		lo_gain += 0x26;

	if (lo_gain >= 0x46) {
		lo_gain -= 0x46;
		ext_lna = 0x3000;
	} else if (lo_gain >= 0x3a) {
		lo_gain -= 0x3a;
		ext_lna = 0x1000;
	} else if (lo_gain >= 0x2e) {
		lo_gain -= 0x2e;
		ext_lna = 0x2000;
	} else {
		lo_gain -= 0x10;
		ext_lna = 0;
	}

	for (loop = 0; loop < 16; ++loop) {
		lo_gain -= (6 * loop);
		if (lo_gain < 6)
			break;
	}

	if (phy->phy_rev >= 7 && (sc->sc_card_flags & BWI_CARD_F_EXT_LNA)) {
		if (ext_lna)
			ext_lna |= 0x8000;
		ext_lna |= (loop << 8);
		switch (lpd) {
		case 0x011:
			return (0x8f92);
		case 0x001:
			return ((0x8092 | ext_lna));
		case 0x101:
			return ((0x2092 | ext_lna));
		case 0x100:
			return ((0x2093 | ext_lna));
		default:
			panic("unsupported lpd");
		}
	} else {
		ext_lna |= (loop << 8);
		switch (lpd) {
		case 0x011:
			return (0xf92);
		case 0x001:
		case 0x101:
			return ((0x92 | ext_lna));
		case 0x100:
			return ((0x93 | ext_lna));
		default:
			panic("unsupported lpd");
		}
	}

	panic("never reached");

	return (0);
}

void
bwi_rf_init_bcm2050(struct bwi_mac *mac)
{
#define SAVE_RF_MAX		3
#define SAVE_PHY_COMM_MAX	4
#define SAVE_PHY_11G_MAX	6
	uint16_t save_rf[SAVE_RF_MAX];
	uint16_t save_phy_comm[SAVE_PHY_COMM_MAX];
	uint16_t save_phy_11g[SAVE_PHY_11G_MAX];
	uint16_t phyr_35, phyr_30 = 0, rfr_78, phyr_80f = 0, phyr_810 = 0;
	uint16_t bphy_ctrl = 0, bbp_atten, rf_chan_ex;
	uint16_t phy812_val;
	uint16_t calib;
	uint32_t test_lim, test;
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_rf *rf = &mac->mac_rf;
	int i;

	static const uint16_t save_rf_regs[SAVE_RF_MAX] =
	    { 0x0043, 0x0051, 0x0052 };
	static const uint16_t save_phy_regs_comm[SAVE_PHY_COMM_MAX] =
	    { 0x0015, 0x005a, 0x0059, 0x0058 };
	static const uint16_t save_phy_regs_11g[SAVE_PHY_11G_MAX] =
	    { 0x0811, 0x0812, 0x0814, 0x0815, 0x0429, 0x0802 };

	/*
	 * Save registers for later restoring
	 */
	for (i = 0; i < SAVE_RF_MAX; ++i)
		save_rf[i] = RF_READ(mac, save_rf_regs[i]);
	for (i = 0; i < SAVE_PHY_COMM_MAX; ++i)
		save_phy_comm[i] = PHY_READ(mac, save_phy_regs_comm[i]);

	if (phy->phy_mode == IEEE80211_MODE_11B) {
		phyr_30 = PHY_READ(mac, 0x30);
		bphy_ctrl = CSR_READ_2(sc, BWI_BPHY_CTRL);

		PHY_WRITE(mac, 0x30, 0xff);
		CSR_WRITE_2(sc, BWI_BPHY_CTRL, 0x3f3f);
	} else if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
		for (i = 0; i < SAVE_PHY_11G_MAX; ++i) {
			save_phy_11g[i] =
			    PHY_READ(mac, save_phy_regs_11g[i]);
		}

		PHY_SETBITS(mac, 0x814, 0x3);
		PHY_CLRBITS(mac, 0x815, 0x3);
		PHY_CLRBITS(mac, 0x429, 0x8000);
		PHY_CLRBITS(mac, 0x802, 0x3);

		phyr_80f = PHY_READ(mac, 0x80f);
		phyr_810 = PHY_READ(mac, 0x810);

		if (phy->phy_rev >= 3)
			PHY_WRITE(mac, 0x80f, 0xc020);
		else
			PHY_WRITE(mac, 0x80f, 0x8020);
		PHY_WRITE(mac, 0x810, 0);

		phy812_val = bwi_phy812_value(mac, 0x011);
		PHY_WRITE(mac, 0x812, phy812_val);
		if (phy->phy_rev < 7 ||
		    (sc->sc_card_flags & BWI_CARD_F_EXT_LNA) == 0)
			PHY_WRITE(mac, 0x811, 0x1b3);
		else
			PHY_WRITE(mac, 0x811, 0x9b3);
	}
	CSR_SETBITS_2(sc, BWI_RF_ANTDIV, 0x8000);

	phyr_35 = PHY_READ(mac, 0x35);
	PHY_CLRBITS(mac, 0x35, 0x80);

	bbp_atten = CSR_READ_2(sc, BWI_BBP_ATTEN);
	rf_chan_ex = CSR_READ_2(sc, BWI_RF_CHAN_EX);

	if (phy->phy_version == 0) {
		CSR_WRITE_2(sc, BWI_BBP_ATTEN, 0x122);
	} else {
		if (phy->phy_version >= 2)
			PHY_FILT_SETBITS(mac, 0x3, 0xffbf, 0x40);
		CSR_SETBITS_2(sc, BWI_RF_CHAN_EX, 0x2000);
	}

	calib = bwi_rf_calibval(mac);

	if (phy->phy_mode == IEEE80211_MODE_11B)
		RF_WRITE(mac, 0x78, 0x26);

	if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
		phy812_val = bwi_phy812_value(mac, 0x011);
		PHY_WRITE(mac, 0x812, phy812_val);
	}

	PHY_WRITE(mac, 0x15, 0xbfaf);
	PHY_WRITE(mac, 0x2b, 0x1403);

	if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
		phy812_val = bwi_phy812_value(mac, 0x001);
		PHY_WRITE(mac, 0x812, phy812_val);
	}

	PHY_WRITE(mac, 0x15, 0xbfa0);

	RF_SETBITS(mac, 0x51, 0x4);
	if (rf->rf_rev == 8)
		RF_WRITE(mac, 0x43, 0x1f);
	else {
		RF_WRITE(mac, 0x52, 0);
		RF_FILT_SETBITS(mac, 0x43, 0xfff0, 0x9);
	}

	test_lim = 0;
	PHY_WRITE(mac, 0x58, 0);
	for (i = 0; i < 16; ++i) {
		PHY_WRITE(mac, 0x5a, 0x480);
		PHY_WRITE(mac, 0x59, 0xc810);

		PHY_WRITE(mac, 0x58, 0xd);
		if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
			phy812_val = bwi_phy812_value(mac, 0x101);
			PHY_WRITE(mac, 0x812, phy812_val);
		}
		PHY_WRITE(mac, 0x15, 0xafb0);
		DELAY(10);

		if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
			phy812_val = bwi_phy812_value(mac, 0x101);
			PHY_WRITE(mac, 0x812, phy812_val);
		}
		PHY_WRITE(mac, 0x15, 0xefb0);
		DELAY(10);

		if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
			phy812_val = bwi_phy812_value(mac, 0x100);
			PHY_WRITE(mac, 0x812, phy812_val);
		}
		PHY_WRITE(mac, 0x15, 0xfff0);
		DELAY(20);

		test_lim += PHY_READ(mac, 0x2d);

		PHY_WRITE(mac, 0x58, 0);
		if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
			phy812_val = bwi_phy812_value(mac, 0x101);
			PHY_WRITE(mac, 0x812, phy812_val);
		}
		PHY_WRITE(mac, 0x15, 0xafb0);
	}
	++test_lim;
	test_lim >>= 9;

	DELAY(10);

	test = 0;
	PHY_WRITE(mac, 0x58, 0);
	for (i = 0; i < 16; ++i) {
		int j;

		rfr_78 = (bwi_bitswap4(i) << 1) | 0x20;
		RF_WRITE(mac, 0x78, rfr_78);
		DELAY(10);

		/* NB: This block is slight different than the above one */
		for (j = 0; j < 16; ++j) {
			PHY_WRITE(mac, 0x5a, 0xd80);
			PHY_WRITE(mac, 0x59, 0xc810);

			PHY_WRITE(mac, 0x58, 0xd);
			if ((phy->phy_flags & BWI_PHY_F_LINKED) ||
			    phy->phy_rev >= 2) {
				phy812_val = bwi_phy812_value(mac, 0x101);
				PHY_WRITE(mac, 0x812, phy812_val);
			}
			PHY_WRITE(mac, 0x15, 0xafb0);
			DELAY(10);

			if ((phy->phy_flags & BWI_PHY_F_LINKED) ||
			    phy->phy_rev >= 2) {
				phy812_val = bwi_phy812_value(mac, 0x101);
				PHY_WRITE(mac, 0x812, phy812_val);
			}
			PHY_WRITE(mac, 0x15, 0xefb0);
			DELAY(10);

			if ((phy->phy_flags & BWI_PHY_F_LINKED) ||
			    phy->phy_rev >= 2) {
				phy812_val = bwi_phy812_value(mac, 0x100);
				PHY_WRITE(mac, 0x812, phy812_val);
			}
			PHY_WRITE(mac, 0x15, 0xfff0);
			DELAY(10);

			test += PHY_READ(mac, 0x2d);

			PHY_WRITE(mac, 0x58, 0);
			if ((phy->phy_flags & BWI_PHY_F_LINKED) ||
			    phy->phy_rev >= 2) {
				phy812_val = bwi_phy812_value(mac, 0x101);
				PHY_WRITE(mac, 0x812, phy812_val);
			}
			PHY_WRITE(mac, 0x15, 0xafb0);
		}

		++test;
		test >>= 8;

		if (test > test_lim)
			break;
	}
	if (i > 15)
		rf->rf_calib = rfr_78;
	else
		rf->rf_calib = calib;
	if (rf->rf_calib != 0xffff) {
		DPRINTF(1, "%s: RF calibration value: 0x%04x\n",
		    sc->sc_dev.dv_xname, rf->rf_calib);
		rf->rf_flags |= BWI_RF_F_INITED;
	}

	/*
	 * Restore trashes registers
	 */
	PHY_WRITE(mac, save_phy_regs_comm[0], save_phy_comm[0]);

	for (i = 0; i < SAVE_RF_MAX; ++i) {
		int pos = (i + 1) % SAVE_RF_MAX;

		RF_WRITE(mac, save_rf_regs[pos], save_rf[pos]);
	}
	for (i = 1; i < SAVE_PHY_COMM_MAX; ++i)
		PHY_WRITE(mac, save_phy_regs_comm[i], save_phy_comm[i]);

	CSR_WRITE_2(sc, BWI_BBP_ATTEN, bbp_atten);
	if (phy->phy_version != 0)
		CSR_WRITE_2(sc, BWI_RF_CHAN_EX, rf_chan_ex);

	PHY_WRITE(mac, 0x35, phyr_35);
	bwi_rf_workaround(mac, rf->rf_curchan);

	if (phy->phy_mode == IEEE80211_MODE_11B) {
		PHY_WRITE(mac, 0x30, phyr_30);
		CSR_WRITE_2(sc, BWI_BPHY_CTRL, bphy_ctrl);
	} else if ((phy->phy_flags & BWI_PHY_F_LINKED) || phy->phy_rev >= 2) {
		/* XXX Spec only says when PHY is linked (gmode) */
		CSR_CLRBITS_2(sc, BWI_RF_ANTDIV, 0x8000);

		for (i = 0; i < SAVE_PHY_11G_MAX; ++i) {
			PHY_WRITE(mac, save_phy_regs_11g[i],
				  save_phy_11g[i]);
		}

		PHY_WRITE(mac, 0x80f, phyr_80f);
		PHY_WRITE(mac, 0x810, phyr_810);
	}

#undef SAVE_PHY_11G_MAX
#undef SAVE_PHY_COMM_MAX
#undef SAVE_RF_MAX
}

uint16_t
bwi_rf_calibval(struct bwi_mac *mac)
{
	uint16_t val, calib;
	int idx;

	/* http://bcm-specs.sipsolutions.net/RCCTable */
	static const uint16_t rf_calibvals[] = {
		0x2, 0x3, 0x1, 0xf, 0x6, 0x7, 0x5, 0xf,
		0xa, 0xb, 0x9, 0xf, 0xe, 0xf, 0xd, 0xf
	};

	val = RF_READ(mac, BWI_RFR_BBP_ATTEN);
	idx = __SHIFTOUT(val, BWI_RFR_BBP_ATTEN_CALIB_IDX);
	KASSERT(idx < (int)(sizeof(rf_calibvals) / sizeof(rf_calibvals[0])));

	calib = rf_calibvals[idx] << 1;
	if (val & BWI_RFR_BBP_ATTEN_CALIB_BIT)
		calib |= 0x1;
	calib |= 0x20;

	return (calib);
}

int32_t
_bwi_adjust_devide(int32_t num, int32_t den)
{
	if (num < 0)
		return ((num / den));
	else
		return ((num + den / 2) / den);
}

/*
 * http://bcm-specs.sipsolutions.net/TSSI_to_DBM_Table
 * "calculating table entries"
 */
int
bwi_rf_calc_txpower(int8_t *txpwr, uint8_t idx, const int16_t pa_params[])
{
	int32_t m1, m2, f, dbm;
	int i;

	m1 = _bwi_adjust_devide(16 * pa_params[0] + idx * pa_params[1], 32);
	m2 = imax(_bwi_adjust_devide(32768 + idx * pa_params[2], 256), 1);

#define ITER_MAX	16
	f = 256;
	for (i = 0; i < ITER_MAX; ++i) {
		int32_t q, d;

		q = _bwi_adjust_devide(
		    f * 4096 - _bwi_adjust_devide(m2 * f, 16) * f, 2048);
		d = abs(q - f);
		f = q;

		if (d < 2)
			break;
	}
	if (i == ITER_MAX)
		return (EINVAL);
#undef ITER_MAX

	dbm = _bwi_adjust_devide(m1 * f, 8192);
	if (dbm < -127)
		dbm = -127;
	else if (dbm > 128)
		dbm = 128;

	*txpwr = dbm;

	return (0);
}

int
bwi_rf_map_txpower(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_phy *phy = &mac->mac_phy;
	uint16_t sprom_ofs, val, mask;
	int16_t pa_params[3];
	int error = 0, i, ant_gain, reg_txpower_max;

	/*
	 * Find out max TX power
	 */
	val = bwi_read_sprom(sc, BWI_SPROM_MAX_TXPWR);
	if (phy->phy_mode == IEEE80211_MODE_11A) {
		rf->rf_txpower_max = __SHIFTOUT(val,
		    BWI_SPROM_MAX_TXPWR_MASK_11A);
	} else {
		rf->rf_txpower_max = __SHIFTOUT(val,
		    BWI_SPROM_MAX_TXPWR_MASK_11BG);

		if ((sc->sc_card_flags & BWI_CARD_F_PA_GPIO9) &&
		    phy->phy_mode == IEEE80211_MODE_11G)
			rf->rf_txpower_max -= 3;
	}
	if (rf->rf_txpower_max <= 0) {
		printf("%s: invalid max txpower in sprom\n",
		    sc->sc_dev.dv_xname);
		rf->rf_txpower_max = 74;
	}
	DPRINTF(1, "%s: max txpower from sprom: %d dBm\n",
	    sc->sc_dev.dv_xname, rf->rf_txpower_max);

	/*
	 * Find out region/domain max TX power, which is adjusted
	 * by antenna gain and 1.5 dBm fluctuation as mentioned
	 * in v3 spec.
	 */
	val = bwi_read_sprom(sc, BWI_SPROM_ANT_GAIN);
	if (phy->phy_mode == IEEE80211_MODE_11A)
		ant_gain = __SHIFTOUT(val, BWI_SPROM_ANT_GAIN_MASK_11A);
	else
		ant_gain = __SHIFTOUT(val, BWI_SPROM_ANT_GAIN_MASK_11BG);
	if (ant_gain == 0xff) {
		/* XXX why this always invalid? */
		DPRINTF(1, "%s: invalid antenna gain in sprom\n",
		    sc->sc_dev.dv_xname);
		ant_gain = 2;
	}
	ant_gain *= 4;
	DPRINTF(1, "%s: ant gain %d dBm\n", sc->sc_dev.dv_xname, ant_gain);

	reg_txpower_max = 90 - ant_gain - 6;	/* XXX magic number */
	DPRINTF(1, "%s: region/domain max txpower %d dBm\n",
	    sc->sc_dev.dv_xname, reg_txpower_max);

	/*
	 * Force max TX power within region/domain TX power limit
	 */
	if (rf->rf_txpower_max > reg_txpower_max)
		rf->rf_txpower_max = reg_txpower_max;
	DPRINTF(1, "%s: max txpower %d dBm\n",
	    sc->sc_dev.dv_xname, rf->rf_txpower_max);

	/*
	 * Create TSSI to TX power mapping
	 */

	if (sc->sc_bbp_id == BWI_BBPID_BCM4301 &&
	    rf->rf_type != BWI_RF_T_BCM2050) {
		rf->rf_idle_tssi0 = BWI_DEFAULT_IDLE_TSSI;
		bcopy(bwi_txpower_map_11b, rf->rf_txpower_map0,
		      sizeof(rf->rf_txpower_map0));
		goto back;
	}

#define IS_VALID_PA_PARAM(p)	((p) != 0 && (p) != -1)
	/*
	 * Extract PA parameters
	 */
	if (phy->phy_mode == IEEE80211_MODE_11A)
		sprom_ofs = BWI_SPROM_PA_PARAM_11A;
	else
		sprom_ofs = BWI_SPROM_PA_PARAM_11BG;
	for (i = 0; i < nitems(pa_params); ++i)
		pa_params[i] = (int16_t)bwi_read_sprom(sc, sprom_ofs + (i * 2));

	for (i = 0; i < nitems(pa_params); ++i) {
		/*
		 * If one of the PA parameters from SPROM is not valid,
		 * fall back to the default values, if there are any.
		 */
		if (!IS_VALID_PA_PARAM(pa_params[i])) {
			const int8_t *txpower_map;

			if (phy->phy_mode == IEEE80211_MODE_11A) {
				printf("%s: no tssi2dbm table for 11a PHY\n",
				    sc->sc_dev.dv_xname);
				return (ENXIO);
			}

			if (phy->phy_mode == IEEE80211_MODE_11G) {
				DPRINTF(1, "%s: use default 11g TSSI map\n",
				    sc->sc_dev.dv_xname);
				txpower_map = bwi_txpower_map_11g;
			} else {
				txpower_map = bwi_txpower_map_11b;
			}

			rf->rf_idle_tssi0 = BWI_DEFAULT_IDLE_TSSI;
			bcopy(txpower_map, rf->rf_txpower_map0,
			      sizeof(rf->rf_txpower_map0));
			goto back;
		}
	}

	/*
	 * All of the PA parameters from SPROM are valid.
	 */

	/*
	 * Extract idle TSSI from SPROM.
	 */
	val = bwi_read_sprom(sc, BWI_SPROM_IDLE_TSSI);
	DPRINTF(1, "%s: sprom idle tssi: 0x%04x\n", sc->sc_dev.dv_xname, val);

	if (phy->phy_mode == IEEE80211_MODE_11A)
		mask = BWI_SPROM_IDLE_TSSI_MASK_11A;
	else
		mask = BWI_SPROM_IDLE_TSSI_MASK_11BG;

	rf->rf_idle_tssi0 = (int)__SHIFTOUT(val, mask);
	if (!IS_VALID_PA_PARAM(rf->rf_idle_tssi0))
		rf->rf_idle_tssi0 = 62;

#undef IS_VALID_PA_PARAM

	/*
	 * Calculate TX power map, which is indexed by TSSI
	 */
	DPRINTF(1, "%s: TSSI-TX power map:\n", sc->sc_dev.dv_xname);
	for (i = 0; i < BWI_TSSI_MAX; ++i) {
		error = bwi_rf_calc_txpower(&rf->rf_txpower_map0[i], i,
					    pa_params);
		if (error) {
			printf("%s: bwi_rf_calc_txpower failed\n",
			    sc->sc_dev.dv_xname);
			break;
		}
		if (i != 0 && i % 8 == 0)
			DPRINTF(1, "\n");
		DPRINTF(1, "%d ", rf->rf_txpower_map0[i]);
	}
	DPRINTF(1, "\n");
back:
	DPRINTF(1, "%s: idle tssi0: %d\n",
	    sc->sc_dev.dv_xname, rf->rf_idle_tssi0);

	return (error);
}

void
bwi_rf_lo_update_11g(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_tpctl *tpctl = &mac->mac_tpctl;
	struct rf_saveregs regs;
	uint16_t ant_div, chan_ex;
	uint8_t devi_ctrl;
	uint orig_chan;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	/*
	 * Save RF/PHY registers for later restoration
	 */
	orig_chan = rf->rf_curchan;
	bzero(&regs, sizeof(regs));

	if (phy->phy_flags & BWI_PHY_F_LINKED) {
		SAVE_PHY_REG(mac, &regs, 429);
		SAVE_PHY_REG(mac, &regs, 802);

		PHY_WRITE(mac, 0x429, regs.phy_429 & 0x7fff);
		PHY_WRITE(mac, 0x802, regs.phy_802 & 0xfffc);
	}

	ant_div = CSR_READ_2(sc, BWI_RF_ANTDIV);
	CSR_WRITE_2(sc, BWI_RF_ANTDIV, ant_div | 0x8000);
	chan_ex = CSR_READ_2(sc, BWI_RF_CHAN_EX);

	SAVE_PHY_REG(mac, &regs, 15);
	SAVE_PHY_REG(mac, &regs, 2a);
	SAVE_PHY_REG(mac, &regs, 35);
	SAVE_PHY_REG(mac, &regs, 60);
	SAVE_RF_REG(mac, &regs, 43);
	SAVE_RF_REG(mac, &regs, 7a);
	SAVE_RF_REG(mac, &regs, 52);
	if (phy->phy_flags & BWI_PHY_F_LINKED) {
		SAVE_PHY_REG(mac, &regs, 811);
		SAVE_PHY_REG(mac, &regs, 812);
		SAVE_PHY_REG(mac, &regs, 814);
		SAVE_PHY_REG(mac, &regs, 815);
	}

	/* Force to channel 6 */
	bwi_rf_set_chan(mac, 6, 0);

	if (phy->phy_flags & BWI_PHY_F_LINKED) {
		PHY_WRITE(mac, 0x429, regs.phy_429 & 0x7fff);
		PHY_WRITE(mac, 0x802, regs.phy_802 & 0xfffc);
		bwi_mac_dummy_xmit(mac);
	}
	RF_WRITE(mac, 0x43, 0x6);

	bwi_phy_set_bbp_atten(mac, 2);

	CSR_WRITE_2(sc, BWI_RF_CHAN_EX, 0);

	PHY_WRITE(mac, 0x2e, 0x7f);
	PHY_WRITE(mac, 0x80f, 0x78);
	PHY_WRITE(mac, 0x35, regs.phy_35 & 0xff7f);
	RF_WRITE(mac, 0x7a, regs.rf_7a & 0xfff0);
	PHY_WRITE(mac, 0x2b, 0x203);
	PHY_WRITE(mac, 0x2a, 0x8a3);

	if (phy->phy_flags & BWI_PHY_F_LINKED) {
		PHY_WRITE(mac, 0x814, regs.phy_814 | 0x3);
		PHY_WRITE(mac, 0x815, regs.phy_815 & 0xfffc);
		PHY_WRITE(mac, 0x811, 0x1b3);
		PHY_WRITE(mac, 0x812, 0xb2);
	}

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		tpctl->tp_ctrl2 = bwi_rf_get_tp_ctrl2(mac);
	PHY_WRITE(mac, 0x80f, 0x8078);

	/*
	 * Measure all RF LO
	 */
	devi_ctrl = _bwi_rf_lo_update_11g(mac, regs.rf_7a);

	/*
	 * Restore saved RF/PHY registers
	 */
	if (phy->phy_flags & BWI_PHY_F_LINKED) {
		PHY_WRITE(mac, 0x15, 0xe300);
		PHY_WRITE(mac, 0x812, (devi_ctrl << 8) | 0xa0);
		DELAY(5);
		PHY_WRITE(mac, 0x812, (devi_ctrl << 8) | 0xa2);
		DELAY(2);
		PHY_WRITE(mac, 0x812, (devi_ctrl << 8) | 0xa3);
	} else
		PHY_WRITE(mac, 0x15, devi_ctrl | 0xefa0);

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		tpctl = NULL;
	bwi_rf_lo_adjust(mac, tpctl);

	PHY_WRITE(mac, 0x2e, 0x807f);
	if (phy->phy_flags & BWI_PHY_F_LINKED)
		PHY_WRITE(mac, 0x2f, 0x202);
	else
		PHY_WRITE(mac, 0x2f, 0x101);

	CSR_WRITE_2(sc, BWI_RF_CHAN_EX, chan_ex);

	RESTORE_PHY_REG(mac, &regs, 15);
	RESTORE_PHY_REG(mac, &regs, 2a);
	RESTORE_PHY_REG(mac, &regs, 35);
	RESTORE_PHY_REG(mac, &regs, 60);

	RESTORE_RF_REG(mac, &regs, 43);
	RESTORE_RF_REG(mac, &regs, 7a);

	regs.rf_52 &= 0xf0;
	regs.rf_52 |= (RF_READ(mac, 0x52) & 0xf);
	RF_WRITE(mac, 0x52, regs.rf_52);

	CSR_WRITE_2(sc, BWI_RF_ANTDIV, ant_div);

	if (phy->phy_flags & BWI_PHY_F_LINKED) {
		RESTORE_PHY_REG(mac, &regs, 811);
		RESTORE_PHY_REG(mac, &regs, 812);
		RESTORE_PHY_REG(mac, &regs, 814);
		RESTORE_PHY_REG(mac, &regs, 815);
		RESTORE_PHY_REG(mac, &regs, 429);
		RESTORE_PHY_REG(mac, &regs, 802);
	}

	bwi_rf_set_chan(mac, orig_chan, 1);
}

uint32_t
bwi_rf_lo_devi_measure(struct bwi_mac *mac, uint16_t ctrl)
{
	struct bwi_phy *phy = &mac->mac_phy;
	uint32_t devi = 0;
	int i;

	if (phy->phy_flags & BWI_PHY_F_LINKED)
		ctrl <<= 8;

	for (i = 0; i < 8; ++i) {
		if (phy->phy_flags & BWI_PHY_F_LINKED) {
			PHY_WRITE(mac, 0x15, 0xe300);
			PHY_WRITE(mac, 0x812, ctrl | 0xb0);
			DELAY(5);
			PHY_WRITE(mac, 0x812, ctrl | 0xb2);
			DELAY(2);
			PHY_WRITE(mac, 0x812, ctrl | 0xb3);
			DELAY(4);
			PHY_WRITE(mac, 0x15, 0xf300);
		} else {
			PHY_WRITE(mac, 0x15, ctrl | 0xefa0);
			DELAY(2);
			PHY_WRITE(mac, 0x15, ctrl | 0xefe0);
			DELAY(4);
			PHY_WRITE(mac, 0x15, ctrl | 0xffe0);
		}
		DELAY(8);
		devi += PHY_READ(mac, 0x2d);
	}

	return (devi);
}

uint16_t
bwi_rf_get_tp_ctrl2(struct bwi_mac *mac)
{
	uint32_t devi_min;
	uint16_t tp_ctrl2 = 0;
	int i;

	RF_WRITE(mac, 0x52, 0);
	DELAY(10);
	devi_min = bwi_rf_lo_devi_measure(mac, 0);

	for (i = 0; i < 16; ++i) {
		uint32_t devi;

		RF_WRITE(mac, 0x52, i);
		DELAY(10);
		devi = bwi_rf_lo_devi_measure(mac, 0);

		if (devi < devi_min) {
			devi_min = devi;
			tp_ctrl2 = i;
		}
	}

	return (tp_ctrl2);
}

uint8_t
_bwi_rf_lo_update_11g(struct bwi_mac *mac, uint16_t orig_rf7a)
{
#define RF_ATTEN_LISTSZ	14
#define BBP_ATTEN_MAX	4	/* half */
	struct ifnet *ifp = &mac->mac_sc->sc_ic.ic_if;
	struct bwi_rf_lo lo_save, *lo;
	uint8_t devi_ctrl = 0;
	int idx, adj_rf7a = 0;

	static const int rf_atten_list[RF_ATTEN_LISTSZ] =
	    { 3, 1, 5, 7, 9, 2, 0, 4, 6, 8, 1, 2, 3, 4 };
	static const int rf_atten_init_list[RF_ATTEN_LISTSZ] =
            { 0, 3, 1, 5, 7, 3, 2, 0, 4, 6, -1, -1, -1, -1 };
	static const int rf_lo_measure_order[RF_ATTEN_LISTSZ] =
	    { 3, 1, 5, 7, 9, 2, 0, 4, 6, 8, 10, 11, 12, 13 };

	bzero(&lo_save, sizeof(lo_save));
	for (idx = 0; idx < RF_ATTEN_LISTSZ; ++idx) {
		int init_rf_atten = rf_atten_init_list[idx];
		int rf_atten = rf_atten_list[idx];
		int bbp_atten;

		for (bbp_atten = 0; bbp_atten < BBP_ATTEN_MAX; ++bbp_atten) {
			uint16_t tp_ctrl2, rf7a;

			if ((ifp->if_flags & IFF_RUNNING) == 0) {
				if (idx == 0) {
					bzero(&lo_save, sizeof(lo_save));
				} else if (init_rf_atten < 0) {
					lo = bwi_get_rf_lo(mac,
					    rf_atten, 2 * bbp_atten);
					bcopy(lo, &lo_save, sizeof(lo_save));
				} else {
					lo = bwi_get_rf_lo(mac,
					    init_rf_atten, 0);
					bcopy(lo, &lo_save, sizeof(lo_save));
				}

				devi_ctrl = 0;
				adj_rf7a = 0;

				/*
				 * XXX
				 * Linux driver overflows 'val'
				 */
				if (init_rf_atten >= 0) {
					int val;

					val = rf_atten * 2 + bbp_atten;
					if (val > 14) {
						adj_rf7a = 1;
						if (val > 17)
							devi_ctrl = 1;
						if (val > 19)
							devi_ctrl = 2;
					}
				}
			} else {
				lo = bwi_get_rf_lo(mac,
					rf_atten, 2 * bbp_atten);
				if (!bwi_rf_lo_isused(mac, lo))
					continue;
				bcopy(lo, &lo_save, sizeof(lo_save));

				devi_ctrl = 3;
				adj_rf7a = 0;
			}

			RF_WRITE(mac, BWI_RFR_ATTEN, rf_atten);

			tp_ctrl2 = mac->mac_tpctl.tp_ctrl2;
			if (init_rf_atten < 0)
				tp_ctrl2 |= (3 << 4);
			RF_WRITE(mac, BWI_RFR_TXPWR, tp_ctrl2);

			DELAY(10);

			bwi_phy_set_bbp_atten(mac, bbp_atten * 2);

			rf7a = orig_rf7a & 0xfff0;
			if (adj_rf7a)
				rf7a |= 0x8;
			RF_WRITE(mac, 0x7a, rf7a);

			lo = bwi_get_rf_lo(mac,
				rf_lo_measure_order[idx], bbp_atten * 2);
			bwi_rf_lo_measure_11g(mac, &lo_save, lo, devi_ctrl);
		}
	}

	return (devi_ctrl);

#undef RF_ATTEN_LISTSZ
#undef BBP_ATTEN_MAX
}

void
bwi_rf_lo_measure_11g(struct bwi_mac *mac, const struct bwi_rf_lo *src_lo,
    struct bwi_rf_lo *dst_lo, uint8_t devi_ctrl)
{
#define LO_ADJUST_MIN	1
#define LO_ADJUST_MAX	8
#define LO_ADJUST(hi, lo)	{ .ctrl_hi = hi, .ctrl_lo = lo }
	static const struct bwi_rf_lo rf_lo_adjust[LO_ADJUST_MAX] = {
		LO_ADJUST(1,	1),
		LO_ADJUST(1,	0),
		LO_ADJUST(1,	-1),
		LO_ADJUST(0,	-1),
		LO_ADJUST(-1,	-1),
		LO_ADJUST(-1,	0),
		LO_ADJUST(-1,	1),
		LO_ADJUST(0,	1)
	};
#undef LO_ADJUST

	struct bwi_rf_lo lo_min;
	uint32_t devi_min;
	int found, loop_count, adjust_state;

	bcopy(src_lo, &lo_min, sizeof(lo_min));
	RF_LO_WRITE(mac, &lo_min);
	devi_min = bwi_rf_lo_devi_measure(mac, devi_ctrl);

	loop_count = 12;	/* XXX */
	adjust_state = 0;
	do {
		struct bwi_rf_lo lo_base;
		int i, fin;

		found = 0;
		if (adjust_state == 0) {
			i = LO_ADJUST_MIN;
			fin = LO_ADJUST_MAX;
		} else if (adjust_state % 2 == 0) {
			i = adjust_state - 1;
			fin = adjust_state + 1;
		} else {
			i = adjust_state - 2;
			fin = adjust_state + 2;
		}

		if (i < LO_ADJUST_MIN)
			i += LO_ADJUST_MAX;
		KASSERT(i <= LO_ADJUST_MAX && i >= LO_ADJUST_MIN);

		if (fin > LO_ADJUST_MAX)
			fin -= LO_ADJUST_MAX;
		KASSERT(fin <= LO_ADJUST_MAX && fin >= LO_ADJUST_MIN);

		bcopy(&lo_min, &lo_base, sizeof(lo_base));
		for (;;) {
			struct bwi_rf_lo lo;

			lo.ctrl_hi = lo_base.ctrl_hi +
				rf_lo_adjust[i - 1].ctrl_hi;
			lo.ctrl_lo = lo_base.ctrl_lo +
				rf_lo_adjust[i - 1].ctrl_lo;

			if (abs(lo.ctrl_lo) < 9 && abs(lo.ctrl_hi) < 9) {
				uint32_t devi;

				RF_LO_WRITE(mac, &lo);
				devi = bwi_rf_lo_devi_measure(mac, devi_ctrl);
				if (devi < devi_min) {
					devi_min = devi;
					adjust_state = i;
					found = 1;
					bcopy(&lo, &lo_min, sizeof(lo_min));
				}
			}
			if (i == fin)
				break;
			if (i == LO_ADJUST_MAX)
				i = LO_ADJUST_MIN;
			else
				++i;
		}
	} while (loop_count-- && found);

	bcopy(&lo_min, dst_lo, sizeof(*dst_lo));

#undef LO_ADJUST_MIN
#undef LO_ADJUST_MAX
}

void
bwi_rf_calc_nrssi_slope_11b(struct bwi_mac *mac)
{
#define SAVE_RF_MAX	3
#define SAVE_PHY_MAX	8
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	struct bwi_phy *phy = &mac->mac_phy;
	uint16_t save_rf[SAVE_RF_MAX];
	uint16_t save_phy[SAVE_PHY_MAX];
	uint16_t ant_div, bbp_atten, chan_ex;
	int16_t nrssi[2];
	int i;

	static const uint16_t save_rf_regs[SAVE_RF_MAX] =
	    { 0x7a, 0x52, 0x43 };
	static const uint16_t save_phy_regs[SAVE_PHY_MAX] =
	    { 0x30, 0x26, 0x15, 0x2a, 0x20, 0x5a, 0x59, 0x58 };

	/*
	 * Save RF/PHY registers for later restoration
	 */
	for (i = 0; i < SAVE_RF_MAX; ++i)
		save_rf[i] = RF_READ(mac, save_rf_regs[i]);
	for (i = 0; i < SAVE_PHY_MAX; ++i)
		save_phy[i] = PHY_READ(mac, save_phy_regs[i]);

	ant_div = CSR_READ_2(sc, BWI_RF_ANTDIV);
	bbp_atten = CSR_READ_2(sc, BWI_BBP_ATTEN);
	chan_ex = CSR_READ_2(sc, BWI_RF_CHAN_EX);

	/*
	 * Calculate nrssi0
	 */
	if (phy->phy_rev >= 5)
		RF_CLRBITS(mac, 0x7a, 0xff80);
	else
		RF_CLRBITS(mac, 0x7a, 0xfff0);
	PHY_WRITE(mac, 0x30, 0xff);

	CSR_WRITE_2(sc, BWI_BPHY_CTRL, 0x7f7f);

	PHY_WRITE(mac, 0x26, 0);
	PHY_SETBITS(mac, 0x15, 0x20);
	PHY_WRITE(mac, 0x2a, 0x8a3);
	RF_SETBITS(mac, 0x7a, 0x80);

	nrssi[0] = (int16_t)PHY_READ(mac, 0x27);

	/*
	 * Calculate nrssi1
	 */
	RF_CLRBITS(mac, 0x7a, 0xff80);
	if (phy->phy_version >= 2)
		CSR_WRITE_2(sc, BWI_BBP_ATTEN, 0x40);
	else if (phy->phy_version == 0)
		CSR_WRITE_2(sc, BWI_BBP_ATTEN, 0x122);
	else
		CSR_CLRBITS_2(sc, BWI_RF_CHAN_EX, 0xdfff);

	PHY_WRITE(mac, 0x20, 0x3f3f);
	PHY_WRITE(mac, 0x15, 0xf330);

	RF_WRITE(mac, 0x5a, 0x60);
	RF_CLRBITS(mac, 0x43, 0xff0f);

	PHY_WRITE(mac, 0x5a, 0x480);
	PHY_WRITE(mac, 0x59, 0x810);
	PHY_WRITE(mac, 0x58, 0xd);

	DELAY(20);

	nrssi[1] = (int16_t)PHY_READ(mac, 0x27);

	/*
	 * Restore saved RF/PHY registers
	 */
	PHY_WRITE(mac, save_phy_regs[0], save_phy[0]);
	RF_WRITE(mac, save_rf_regs[0], save_rf[0]);

	CSR_WRITE_2(sc, BWI_RF_ANTDIV, ant_div);

	for (i = 1; i < 4; ++i)
		PHY_WRITE(mac, save_phy_regs[i], save_phy[i]);

	bwi_rf_workaround(mac, rf->rf_curchan);

	if (phy->phy_version != 0)
		CSR_WRITE_2(sc, BWI_RF_CHAN_EX, chan_ex);

	for (; i < SAVE_PHY_MAX; ++i)
		PHY_WRITE(mac, save_phy_regs[i], save_phy[i]);

	for (i = 1; i < SAVE_RF_MAX; ++i)
		RF_WRITE(mac, save_rf_regs[i], save_rf[i]);

	/*
	 * Install calculated narrow RSSI values
	 */
	if (nrssi[0] == nrssi[1])
		rf->rf_nrssi_slope = 0x10000;
	else
		rf->rf_nrssi_slope = 0x400000 / (nrssi[0] - nrssi[1]);
	if (nrssi[0] <= -4) {
		rf->rf_nrssi[0] = nrssi[0];
		rf->rf_nrssi[1] = nrssi[1];
	}

#undef SAVE_RF_MAX
#undef SAVE_PHY_MAX
}

void
bwi_rf_set_nrssi_ofs_11g(struct bwi_mac *mac)
{
#define SAVE_RF_MAX		2
#define SAVE_PHY_COMM_MAX	10
#define SAVE_PHY6_MAX		8
	struct bwi_phy *phy = &mac->mac_phy;
	uint16_t save_rf[SAVE_RF_MAX];
	uint16_t save_phy_comm[SAVE_PHY_COMM_MAX];
	uint16_t save_phy6[SAVE_PHY6_MAX];
	uint16_t rf7b = 0xffff;
	int16_t nrssi;
	int i, phy6_idx = 0;

	static const uint16_t save_rf_regs[SAVE_RF_MAX] = { 0x7a, 0x43 };
	static const uint16_t save_phy_comm_regs[SAVE_PHY_COMM_MAX] = {
		0x0001, 0x0811, 0x0812, 0x0814,
		0x0815, 0x005a, 0x0059, 0x0058,
		0x000a, 0x0003
	};
	static const uint16_t save_phy6_regs[SAVE_PHY6_MAX] = {
		0x002e, 0x002f, 0x080f, 0x0810,
		0x0801, 0x0060, 0x0014, 0x0478
	};

	for (i = 0; i < SAVE_PHY_COMM_MAX; ++i)
		save_phy_comm[i] = PHY_READ(mac, save_phy_comm_regs[i]);
	for (i = 0; i < SAVE_RF_MAX; ++i)
		save_rf[i] = RF_READ(mac, save_rf_regs[i]);

	PHY_CLRBITS(mac, 0x429, 0x8000);
	PHY_FILT_SETBITS(mac, 0x1, 0x3fff, 0x4000);
	PHY_SETBITS(mac, 0x811, 0xc);
	PHY_FILT_SETBITS(mac, 0x812, 0xfff3, 0x4);
	PHY_CLRBITS(mac, 0x802, 0x3);

	if (phy->phy_rev >= 6) {
		for (i = 0; i < SAVE_PHY6_MAX; ++i)
			save_phy6[i] = PHY_READ(mac, save_phy6_regs[i]);

		PHY_WRITE(mac, 0x2e, 0);
		PHY_WRITE(mac, 0x2f, 0);
		PHY_WRITE(mac, 0x80f, 0);
		PHY_WRITE(mac, 0x810, 0);
		PHY_SETBITS(mac, 0x478, 0x100);
		PHY_SETBITS(mac, 0x801, 0x40);
		PHY_SETBITS(mac, 0x60, 0x40);
		PHY_SETBITS(mac, 0x14, 0x200);
	}

	RF_SETBITS(mac, 0x7a, 0x70);
	RF_SETBITS(mac, 0x7a, 0x80);

	DELAY(30);

	nrssi = bwi_nrssi_11g(mac);
	if (nrssi == 31) {
		for (i = 7; i >= 4; --i) {
			RF_WRITE(mac, 0x7b, i);
			DELAY(20);
			nrssi = bwi_nrssi_11g(mac);
			if (nrssi < 31 && rf7b == 0xffff)
				rf7b = i;
		}
		if (rf7b == 0xffff)
			rf7b = 4;
	} else {
		struct bwi_gains gains;

		RF_CLRBITS(mac, 0x7a, 0xff80);

		PHY_SETBITS(mac, 0x814, 0x1);
		PHY_CLRBITS(mac, 0x815, 0x1);
		PHY_SETBITS(mac, 0x811, 0xc);
		PHY_SETBITS(mac, 0x812, 0xc);
		PHY_SETBITS(mac, 0x811, 0x30);
		PHY_SETBITS(mac, 0x812, 0x30);
		PHY_WRITE(mac, 0x5a, 0x480);
		PHY_WRITE(mac, 0x59, 0x810);
		PHY_WRITE(mac, 0x58, 0xd);
		if (phy->phy_version == 0)
			PHY_WRITE(mac, 0x3, 0x122);
		else
			PHY_SETBITS(mac, 0xa, 0x2000);
		PHY_SETBITS(mac, 0x814, 0x4);
		PHY_CLRBITS(mac, 0x815, 0x4);
		PHY_FILT_SETBITS(mac, 0x3, 0xff9f, 0x40);
		RF_SETBITS(mac, 0x7a, 0xf);

		bzero(&gains, sizeof(gains));
		gains.tbl_gain1 = 3;
		gains.tbl_gain2 = 0;
		gains.phy_gain = 1;
		bwi_set_gains(mac, &gains);

		RF_FILT_SETBITS(mac, 0x43, 0xf0, 0xf);
		DELAY(30);

		nrssi = bwi_nrssi_11g(mac);
		if (nrssi == -32) {
			for (i = 0; i < 4; ++i) {
				RF_WRITE(mac, 0x7b, i);
				DELAY(20);
				nrssi = bwi_nrssi_11g(mac);
				if (nrssi > -31 && rf7b == 0xffff)
					rf7b = i;
			}
			if (rf7b == 0xffff)
				rf7b = 3;
		} else {
			rf7b = 0;
		}
	}
	RF_WRITE(mac, 0x7b, rf7b);

	/*
	 * Restore saved RF/PHY registers
	 */
	if (phy->phy_rev >= 6) {
		for (phy6_idx = 0; phy6_idx < 4; ++phy6_idx) {
			PHY_WRITE(mac, save_phy6_regs[phy6_idx],
			    save_phy6[phy6_idx]);
		}
	}

	/* Saved PHY registers 0, 1, 2 are handled later */
	for (i = 3; i < SAVE_PHY_COMM_MAX; ++i)
		PHY_WRITE(mac, save_phy_comm_regs[i], save_phy_comm[i]);

	for (i = SAVE_RF_MAX - 1; i >= 0; --i)
		RF_WRITE(mac, save_rf_regs[i], save_rf[i]);

	PHY_SETBITS(mac, 0x802, 0x3);
	PHY_SETBITS(mac, 0x429, 0x8000);

	bwi_set_gains(mac, NULL);

	if (phy->phy_rev >= 6) {
		for (; phy6_idx < SAVE_PHY6_MAX; ++phy6_idx) {
			PHY_WRITE(mac, save_phy6_regs[phy6_idx],
			    save_phy6[phy6_idx]);
		}
	}

	PHY_WRITE(mac, save_phy_comm_regs[0], save_phy_comm[0]);
	PHY_WRITE(mac, save_phy_comm_regs[2], save_phy_comm[2]);
	PHY_WRITE(mac, save_phy_comm_regs[1], save_phy_comm[1]);

#undef SAVE_RF_MAX
#undef SAVE_PHY_COMM_MAX
#undef SAVE_PHY6_MAX
}

void
bwi_rf_calc_nrssi_slope_11g(struct bwi_mac *mac)
{
#define SAVE_RF_MAX		3
#define SAVE_PHY_COMM_MAX	4
#define SAVE_PHY3_MAX		8
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	struct bwi_rf *rf = &mac->mac_rf;
	uint16_t save_rf[SAVE_RF_MAX];
	uint16_t save_phy_comm[SAVE_PHY_COMM_MAX];
	uint16_t save_phy3[SAVE_PHY3_MAX];
	uint16_t ant_div, bbp_atten, chan_ex;
	struct bwi_gains gains;
	int16_t nrssi[2];
	int i, phy3_idx = 0;

	static const uint16_t save_rf_regs[SAVE_RF_MAX] =
	    { 0x7a, 0x52, 0x43 };
	static const uint16_t save_phy_comm_regs[SAVE_PHY_COMM_MAX] =
	    { 0x15, 0x5a, 0x59, 0x58 };
	static const uint16_t save_phy3_regs[SAVE_PHY3_MAX] = {
		0x002e, 0x002f, 0x080f, 0x0810,
		0x0801, 0x0060, 0x0014, 0x0478
	};

	if (rf->rf_rev >= 9)
		return;
	else if (rf->rf_rev == 8)
		bwi_rf_set_nrssi_ofs_11g(mac);

	PHY_CLRBITS(mac, 0x429, 0x8000);
	PHY_CLRBITS(mac, 0x802, 0x3);

	/*
	 * Save RF/PHY registers for later restoration
	 */
	ant_div = CSR_READ_2(sc, BWI_RF_ANTDIV);
	CSR_SETBITS_2(sc, BWI_RF_ANTDIV, 0x8000);

	for (i = 0; i < SAVE_RF_MAX; ++i)
		save_rf[i] = RF_READ(mac, save_rf_regs[i]);
	for (i = 0; i < SAVE_PHY_COMM_MAX; ++i)
		save_phy_comm[i] = PHY_READ(mac, save_phy_comm_regs[i]);

	bbp_atten = CSR_READ_2(sc, BWI_BBP_ATTEN);
	chan_ex = CSR_READ_2(sc, BWI_RF_CHAN_EX);

	if (phy->phy_rev >= 3) {
		for (i = 0; i < SAVE_PHY3_MAX; ++i)
			save_phy3[i] = PHY_READ(mac, save_phy3_regs[i]);

		PHY_WRITE(mac, 0x2e, 0);
		PHY_WRITE(mac, 0x810, 0);

		if (phy->phy_rev == 4 || phy->phy_rev == 6 ||
		    phy->phy_rev == 7) {
			PHY_SETBITS(mac, 0x478, 0x100);
			PHY_SETBITS(mac, 0x810, 0x40);
		} else if (phy->phy_rev == 3 || phy->phy_rev == 5)
			PHY_CLRBITS(mac, 0x810, 0x40);

		PHY_SETBITS(mac, 0x60, 0x40);
		PHY_SETBITS(mac, 0x14, 0x200);
	}

	/*
	 * Calculate nrssi0
	 */
	RF_SETBITS(mac, 0x7a, 0x70);

	bzero(&gains, sizeof(gains));
	gains.tbl_gain1 = 0;
	gains.tbl_gain2 = 8;
	gains.phy_gain = 0;
	bwi_set_gains(mac, &gains);

	RF_CLRBITS(mac, 0x7a, 0xff08);
	if (phy->phy_rev >= 2) {
		PHY_FILT_SETBITS(mac, 0x811, 0xffcf, 0x30);
		PHY_FILT_SETBITS(mac, 0x812, 0xffcf, 0x10);
	}

	RF_SETBITS(mac, 0x7a, 0x80);
	DELAY(20);
	nrssi[0] = bwi_nrssi_11g(mac);

	/*
	 * Calculate nrssi1
	 */
	RF_CLRBITS(mac, 0x7a, 0xff80);
	if (phy->phy_version >= 2)
		PHY_FILT_SETBITS(mac, 0x3, 0xff9f, 0x40);
	CSR_SETBITS_2(sc, BWI_RF_CHAN_EX, 0x2000);

	RF_SETBITS(mac, 0x7a, 0xf);
	PHY_WRITE(mac, 0x15, 0xf330);
	if (phy->phy_rev >= 2) {
		PHY_FILT_SETBITS(mac, 0x812, 0xffcf, 0x20);
		PHY_FILT_SETBITS(mac, 0x811, 0xffcf, 0x20);
	}

	bzero(&gains, sizeof(gains));
	gains.tbl_gain1 = 3;
	gains.tbl_gain2 = 0;
	gains.phy_gain = 1;
	bwi_set_gains(mac, &gains);

	if (rf->rf_rev == 8) {
		RF_WRITE(mac, 0x43, 0x1f);
	} else {
		RF_FILT_SETBITS(mac, 0x52, 0xff0f, 0x60);
		RF_FILT_SETBITS(mac, 0x43, 0xfff0, 0x9);
	}
	PHY_WRITE(mac, 0x5a, 0x480);
	PHY_WRITE(mac, 0x59, 0x810);
	PHY_WRITE(mac, 0x58, 0xd);
	DELAY(20);

	nrssi[1] = bwi_nrssi_11g(mac);

	/*
	 * Install calculated narrow RSSI values
	 */
	if (nrssi[1] == nrssi[0])
		rf->rf_nrssi_slope = 0x10000;
	else
		rf->rf_nrssi_slope = 0x400000 / (nrssi[0] - nrssi[1]);
	if (nrssi[0] >= -4) {
		rf->rf_nrssi[0] = nrssi[1];
		rf->rf_nrssi[1] = nrssi[0];
	}

	/*
	 * Restore saved RF/PHY registers
	 */
	if (phy->phy_rev >= 3) {
		for (phy3_idx = 0; phy3_idx < 4; ++phy3_idx) {
			PHY_WRITE(mac, save_phy3_regs[phy3_idx],
				  save_phy3[phy3_idx]);
		}
	}
	if (phy->phy_rev >= 2) {
		PHY_CLRBITS(mac, 0x812, 0x30);
		PHY_CLRBITS(mac, 0x811, 0x30);
	}

	for (i = 0; i < SAVE_RF_MAX; ++i)
		RF_WRITE(mac, save_rf_regs[i], save_rf[i]);

	CSR_WRITE_2(sc, BWI_RF_ANTDIV, ant_div);
	CSR_WRITE_2(sc, BWI_BBP_ATTEN, bbp_atten);
	CSR_WRITE_2(sc, BWI_RF_CHAN_EX, chan_ex);

	for (i = 0; i < SAVE_PHY_COMM_MAX; ++i)
		PHY_WRITE(mac, save_phy_comm_regs[i], save_phy_comm[i]);

	bwi_rf_workaround(mac, rf->rf_curchan);
	PHY_SETBITS(mac, 0x802, 0x3);
	bwi_set_gains(mac, NULL);
	PHY_SETBITS(mac, 0x429, 0x8000);

	if (phy->phy_rev >= 3) {
		for (; phy3_idx < SAVE_PHY3_MAX; ++phy3_idx) {
			PHY_WRITE(mac, save_phy3_regs[phy3_idx],
			    save_phy3[phy3_idx]);
		}
	}

	bwi_rf_init_sw_nrssi_table(mac);
	bwi_rf_set_nrssi_thr_11g(mac);

#undef SAVE_RF_MAX
#undef SAVE_PHY_COMM_MAX
#undef SAVE_PHY3_MAX
}

void
bwi_rf_init_sw_nrssi_table(struct bwi_mac *mac)
{
	struct bwi_rf *rf = &mac->mac_rf;
	int d, i;

	d = 0x1f - rf->rf_nrssi[0];
	for (i = 0; i < BWI_NRSSI_TBLSZ; ++i) {
		int val;

		val = (((i - d) * rf->rf_nrssi_slope) / 0x10000) + 0x3a;
		if (val < 0)
			val = 0;
		else if (val > 0x3f)
			val = 0x3f;

		rf->rf_nrssi_table[i] = val;
	}
}

void
bwi_rf_init_hw_nrssi_table(struct bwi_mac *mac, uint16_t adjust)
{
	int i;

	for (i = 0; i < BWI_NRSSI_TBLSZ; ++i) {
		int16_t val;

		val = bwi_nrssi_read(mac, i);

		val -= adjust;
		if (val < -32)
			val = -32;
		else if (val > 31)
			val = 31;

		bwi_nrssi_write(mac, i, val);
	}
}

void
bwi_rf_set_nrssi_thr_11b(struct bwi_mac *mac)
{
	struct bwi_rf *rf = &mac->mac_rf;
	int32_t thr;

	if (rf->rf_type != BWI_RF_T_BCM2050 ||
	    (mac->mac_sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) == 0)
		return;

	/*
	 * Calculate nrssi threshold
	 */
	if (rf->rf_rev >= 6) {
		thr = (rf->rf_nrssi[1] - rf->rf_nrssi[0]) * 32;
		thr += 20 * (rf->rf_nrssi[0] + 1);
		thr /= 40;
	} else {
		thr = rf->rf_nrssi[1] - 5;
	}
	if (thr < 0)
		thr = 0;
	else if (thr > 0x3e)
		thr = 0x3e;

	PHY_READ(mac, BWI_PHYR_NRSSI_THR_11B);	/* dummy read */
	PHY_WRITE(mac, BWI_PHYR_NRSSI_THR_11B, (((uint16_t)thr) << 8) | 0x1c);

	if (rf->rf_rev >= 6) {
		PHY_WRITE(mac, 0x87, 0xe0d);
		PHY_WRITE(mac, 0x86, 0xc0b);
		PHY_WRITE(mac, 0x85, 0xa09);
		PHY_WRITE(mac, 0x84, 0x808);
		PHY_WRITE(mac, 0x83, 0x808);
		PHY_WRITE(mac, 0x82, 0x604);
		PHY_WRITE(mac, 0x81, 0x302);
		PHY_WRITE(mac, 0x80, 0x100);
	}
}

int32_t
_nrssi_threshold(const struct bwi_rf *rf, int32_t val)
{
	val *= (rf->rf_nrssi[1] - rf->rf_nrssi[0]);
	val += (rf->rf_nrssi[0] << 6);
	if (val < 32)
		val += 31;
	else
		val += 32;
	val >>= 6;
	if (val < -31)
		val = -31;
	else if (val > 31)
		val = 31;

	return (val);
}

void
bwi_rf_set_nrssi_thr_11g(struct bwi_mac *mac)
{
	int32_t thr1, thr2;
	uint16_t thr;

	/*
	 * Find the two nrssi thresholds
	 */
	if ((mac->mac_phy.phy_flags & BWI_PHY_F_LINKED) == 0 ||
	    (mac->mac_sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) == 0) {
	    	int16_t nrssi;

		nrssi = bwi_nrssi_read(mac, 0x20);
		if (nrssi >= 32)
			nrssi -= 64;

		if (nrssi < 3) {
			thr1 = 0x2b;
			thr2 = 0x27;
		} else {
			thr1 = 0x2d;
			thr2 = 0x2b;
		}
	} else {
		/* TODO Interfere mode */
		thr1 = _nrssi_threshold(&mac->mac_rf, 0x11);
		thr2 = _nrssi_threshold(&mac->mac_rf, 0xe);
	}

#define NRSSI_THR1_MASK		0x003f
#define NRSSI_THR2_MASK		0x0fc0
	thr = __SHIFTIN((uint32_t)thr1, NRSSI_THR1_MASK) |
	    __SHIFTIN((uint32_t)thr2, NRSSI_THR2_MASK);
	PHY_FILT_SETBITS(mac, BWI_PHYR_NRSSI_THR_11G, 0xf000, thr);
#undef NRSSI_THR1_MASK
#undef NRSSI_THR2_MASK
}

void
bwi_rf_clear_tssi(struct bwi_mac *mac)
{
	/* XXX use function pointer */
	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11A) {
		/* TODO: 11A */
	} else {
		uint16_t val;
		int i;

		val = __SHIFTIN(BWI_INVALID_TSSI, BWI_LO_TSSI_MASK) |
		    __SHIFTIN(BWI_INVALID_TSSI, BWI_HI_TSSI_MASK);

		for (i = 0; i < 2; ++i) {
			MOBJ_WRITE_2(mac, BWI_COMM_MOBJ,
			    BWI_COMM_MOBJ_TSSI_DS + (i * 2), val);
		}

		for (i = 0; i < 2; ++i) {
			MOBJ_WRITE_2(mac, BWI_COMM_MOBJ,
			    BWI_COMM_MOBJ_TSSI_OFDM + (i * 2), val);
		}
	}
}

void
bwi_rf_clear_state(struct bwi_rf *rf)
{
	int i;

	rf->rf_flags &= ~BWI_RF_CLEAR_FLAGS;
	bzero(rf->rf_lo, sizeof(rf->rf_lo));
	bzero(rf->rf_lo_used, sizeof(rf->rf_lo_used));

	rf->rf_nrssi_slope = 0;
	rf->rf_nrssi[0] = BWI_INVALID_NRSSI;
	rf->rf_nrssi[1] = BWI_INVALID_NRSSI;

	for (i = 0; i < BWI_NRSSI_TBLSZ; ++i)
		rf->rf_nrssi_table[i] = i;

	rf->rf_lo_gain = 0;
	rf->rf_rx_gain = 0;

	bcopy(rf->rf_txpower_map0, rf->rf_txpower_map,
	      sizeof(rf->rf_txpower_map));
	rf->rf_idle_tssi = rf->rf_idle_tssi0;
}

void
bwi_rf_on_11a(struct bwi_mac *mac)
{
	/* TODO: 11A */
}

void
bwi_rf_on_11bg(struct bwi_mac *mac)
{
	struct bwi_phy *phy = &mac->mac_phy;

	PHY_WRITE(mac, 0x15, 0x8000);
	PHY_WRITE(mac, 0x15, 0xcc00);
	if (phy->phy_flags & BWI_PHY_F_LINKED)
		PHY_WRITE(mac, 0x15, 0xc0);
	else
		PHY_WRITE(mac, 0x15, 0);

	bwi_rf_set_chan(mac, 6 /* XXX */, 1);
}

void
bwi_rf_set_ant_mode(struct bwi_mac *mac, int ant_mode)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_phy *phy = &mac->mac_phy;
	uint16_t val;

	KASSERT(ant_mode == BWI_ANT_MODE_0 ||
	    ant_mode == BWI_ANT_MODE_1 ||
	    ant_mode == BWI_ANT_MODE_AUTO);

	HFLAGS_CLRBITS(mac, BWI_HFLAG_AUTO_ANTDIV);

	if (phy->phy_mode == IEEE80211_MODE_11B) {
		/* NOTE: v4/v3 conflicts, take v3 */
		if (mac->mac_rev == 2)
			val = BWI_ANT_MODE_AUTO;
		else
			val = ant_mode;
		val <<= 7;
		PHY_FILT_SETBITS(mac, 0x3e2, 0xfe7f, val);
	} else {	/* 11a/g */
		/* XXX reg/value naming */
		val = ant_mode << 7;
		PHY_FILT_SETBITS(mac, 0x401, 0x7e7f, val);

		if (ant_mode == BWI_ANT_MODE_AUTO)
			PHY_CLRBITS(mac, 0x42b, 0x100);

		if (phy->phy_mode == IEEE80211_MODE_11A) {
			/* TODO: 11A */
		} else {	/* 11g */
			if (ant_mode == BWI_ANT_MODE_AUTO)
				PHY_SETBITS(mac, 0x48c, 0x2000);
			else
				PHY_CLRBITS(mac, 0x48c, 0x2000);

			if (phy->phy_rev >= 2) {
				PHY_SETBITS(mac, 0x461, 0x10);
				PHY_FILT_SETBITS(mac, 0x4ad, 0xff00, 0x15);
				if (phy->phy_rev == 2) {
					PHY_WRITE(mac, 0x427, 0x8);
				} else {
					PHY_FILT_SETBITS(mac, 0x427,
							 0xff00, 0x8);
				}

				if (phy->phy_rev >= 6)
					PHY_WRITE(mac, 0x49b, 0xdc);
			}
		}
	}

	/* XXX v4 set AUTO_ANTDIV unconditionally */
	if (ant_mode == BWI_ANT_MODE_AUTO)
		HFLAGS_SETBITS(mac, BWI_HFLAG_AUTO_ANTDIV);

	val = ant_mode << 8;
	MOBJ_FILT_SETBITS_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_TX_BEACON,
	    0xfc3f, val);
	MOBJ_FILT_SETBITS_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_TX_ACK,
	    0xfc3f, val);
	MOBJ_FILT_SETBITS_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_TX_PROBE_RESP,
	    0xfc3f, val);

	/* XXX what's these */
	if (phy->phy_mode == IEEE80211_MODE_11B)
		CSR_SETBITS_2(sc, 0x5e, 0x4);

	CSR_WRITE_4(sc, 0x100, 0x1000000);
	if (mac->mac_rev < 5)
		CSR_WRITE_4(sc, 0x10c, 0x1000000);

	mac->mac_rf.rf_ant_mode = ant_mode;
}

int
bwi_rf_get_latest_tssi(struct bwi_mac *mac, int8_t tssi[], uint16_t ofs)
{
	int i;

	for (i = 0; i < 4; ) {
		uint16_t val;

		val = MOBJ_READ_2(mac, BWI_COMM_MOBJ, ofs + i);
		tssi[i++] = (int8_t)__SHIFTOUT(val, BWI_LO_TSSI_MASK);
		tssi[i++] = (int8_t)__SHIFTOUT(val, BWI_HI_TSSI_MASK);
	}

	for (i = 0; i < 4; ++i) {
		if (tssi[i] == BWI_INVALID_TSSI)
			return (EINVAL);
	}

	return (0);
}

int
bwi_rf_tssi2dbm(struct bwi_mac *mac, int8_t tssi, int8_t *txpwr)
{
	struct bwi_rf *rf = &mac->mac_rf;
	int pwr_idx;

	pwr_idx = rf->rf_idle_tssi + (int)tssi - rf->rf_base_tssi;
#if 0
	if (pwr_idx < 0 || pwr_idx >= BWI_TSSI_MAX)
		return EINVAL;
#else
	if (pwr_idx < 0)
		pwr_idx = 0;
	else if (pwr_idx >= BWI_TSSI_MAX)
		pwr_idx = BWI_TSSI_MAX - 1;
#endif
	*txpwr = rf->rf_txpower_map[pwr_idx];

	return (0);
}

int
bwi_rf_calc_rssi_bcm2050(struct bwi_mac *mac, const struct bwi_rxbuf_hdr *hdr)
{
	uint16_t flags1, flags3;
	int rssi, lna_gain;

	rssi = hdr->rxh_rssi;
	flags1 = letoh16(hdr->rxh_flags1);
	flags3 = letoh16(hdr->rxh_flags3);

#define NEW_BCM2050_RSSI
#ifdef NEW_BCM2050_RSSI
	if (flags1 & BWI_RXH_F1_OFDM) {
		if (rssi > 127)
			rssi -= 256;
		if (flags3 & BWI_RXH_F3_BCM2050_RSSI)
			rssi += 17;
		else
			rssi -= 4;
		return (rssi);
	}

	if (mac->mac_sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) {
		struct bwi_rf *rf = &mac->mac_rf;

		if (rssi >= BWI_NRSSI_TBLSZ)
			rssi = BWI_NRSSI_TBLSZ - 1;

		rssi = ((31 - (int)rf->rf_nrssi_table[rssi]) * -131) / 128;
		rssi -= 67;
	} else {
		rssi = ((31 - rssi) * -149) / 128;
		rssi -= 68;
	}

	if (mac->mac_phy.phy_mode != IEEE80211_MODE_11G)
		return (rssi);

	if (flags3 & BWI_RXH_F3_BCM2050_RSSI)
		rssi += 20;

	lna_gain = __SHIFTOUT(letoh16(hdr->rxh_phyinfo),
	    BWI_RXH_PHYINFO_LNAGAIN);
	DPRINTF(3, "lna_gain %d, phyinfo 0x%04x\n",
	    lna_gain, letoh16(hdr->rxh_phyinfo));
	switch (lna_gain) {
	case 0:
		rssi += 27;
		break;
	case 1:
		rssi += 6;
		break;
	case 2:
		rssi += 12;
		break;
	case 3:
		/*
		 * XXX
		 * According to v3 spec, we should do _nothing_ here,
		 * but it seems that the result RSSI will be too low
		 * (relative to what ath(4) says).  Raise it a little
		 * bit.
		 */
		rssi += 5;
		break;
	default:
		panic("impossible lna gain %d", lna_gain);
	}
#else	/* !NEW_BCM2050_RSSI */
	lna_gain = 0; /* shut up gcc warning */

	if (flags1 & BWI_RXH_F1_OFDM) {
		if (rssi > 127)
			rssi -= 256;
		rssi = (rssi * 73) / 64;

		if (flags3 & BWI_RXH_F3_BCM2050_RSSI)
			rssi += 25;
		else
			rssi -= 3;
		return (rssi);
	}

	if (mac->mac_sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) {
		struct bwi_rf *rf = &mac->mac_rf;

		if (rssi >= BWI_NRSSI_TBLSZ)
			rssi = BWI_NRSSI_TBLSZ - 1;

		rssi = ((31 - (int)rf->rf_nrssi_table[rssi]) * -131) / 128;
		rssi -= 57;
	} else {
		rssi = ((31 - rssi) * -149) / 128;
		rssi -= 68;
	}

	if (mac->mac_phy.phy_mode != IEEE80211_MODE_11G)
		return (rssi);

	if (flags3 & BWI_RXH_F3_BCM2050_RSSI)
		rssi += 25;
#endif	/* NEW_BCM2050_RSSI */
	return (rssi);
}

int
bwi_rf_calc_rssi_bcm2053(struct bwi_mac *mac, const struct bwi_rxbuf_hdr *hdr)
{
	uint16_t flags1;
	int rssi;

	rssi = (((int)hdr->rxh_rssi - 11) * 103) / 64;

	flags1 = letoh16(hdr->rxh_flags1);
	if (flags1 & BWI_RXH_F1_BCM2053_RSSI)
		rssi -= 109;
	else
		rssi -= 83;

	return (rssi);
}

int
bwi_rf_calc_rssi_bcm2060(struct bwi_mac *mac, const struct bwi_rxbuf_hdr *hdr)
{
	int rssi;

	rssi = hdr->rxh_rssi;
	if (rssi > 127)
		rssi -= 256;

	return (rssi);
}

uint16_t
bwi_rf_lo_measure_11b(struct bwi_mac *mac)
{
	uint16_t val;
	int i;

	val = 0;
	for (i = 0; i < 10; ++i) {
		PHY_WRITE(mac, 0x15, 0xafa0);
		DELAY(1);
		PHY_WRITE(mac, 0x15, 0xefa0);
		DELAY(10);
		PHY_WRITE(mac, 0x15, 0xffa0);
		DELAY(40);

		val += PHY_READ(mac, 0x2c);
	}

	return (val);
}

void
bwi_rf_lo_update_11b(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct bwi_rf *rf = &mac->mac_rf;
	struct rf_saveregs regs;
	uint16_t rf_val, phy_val, min_val, val;
	uint16_t rf52, bphy_ctrl;
	int i;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	bzero(&regs, sizeof(regs));
	bphy_ctrl = 0;

	/*
	 * Save RF/PHY registers for later restoration
	 */
	SAVE_PHY_REG(mac, &regs, 15);
	rf52 = RF_READ(mac, 0x52) & 0xfff0;
	if (rf->rf_type == BWI_RF_T_BCM2050) {
		SAVE_PHY_REG(mac, &regs, 0a);
		SAVE_PHY_REG(mac, &regs, 2a);
		SAVE_PHY_REG(mac, &regs, 35);
		SAVE_PHY_REG(mac, &regs, 03);
		SAVE_PHY_REG(mac, &regs, 01);
		SAVE_PHY_REG(mac, &regs, 30);

		SAVE_RF_REG(mac, &regs, 43);
		SAVE_RF_REG(mac, &regs, 7a);

		bphy_ctrl = CSR_READ_2(sc, BWI_BPHY_CTRL);

		SAVE_RF_REG(mac, &regs, 52);
		regs.rf_52 &= 0xf0;

		PHY_WRITE(mac, 0x30, 0xff);
		CSR_WRITE_2(sc, BWI_PHY_CTRL, 0x3f3f);
		PHY_WRITE(mac, 0x35, regs.phy_35 & 0xff7f);
		RF_WRITE(mac, 0x7a, regs.rf_7a & 0xfff0);
	}

	PHY_WRITE(mac, 0x15, 0xb000);

	if (rf->rf_type == BWI_RF_T_BCM2050) {
		PHY_WRITE(mac, 0x2b, 0x203);
 		PHY_WRITE(mac, 0x2a, 0x8a3);
 	} else {
		PHY_WRITE(mac, 0x2b, 0x1402);
	}

	/*
	 * Setup RF signal
	 */
	rf_val = 0;
	min_val = 65535;

	for (i = 0; i < 4; ++i) {
		RF_WRITE(mac, 0x52, rf52 | i);
		bwi_rf_lo_measure_11b(mac);	/* Ignore return value */
	}
	for (i = 0; i < 10; ++i) {
 		RF_WRITE(mac, 0x52, rf52 | i);

  		val = bwi_rf_lo_measure_11b(mac) / 10;
		if (val < min_val) {
			min_val = val;
			rf_val = i;
		}
	}
	RF_WRITE(mac, 0x52, rf52 | rf_val);

	/*
	 * Setup PHY signal
	*/
	phy_val = 0;
	min_val = 65535;

	for (i = -4; i < 5; i += 2) {
		int j;

		for (j = -4; j < 5; j += 2) {
			uint16_t phy2f;

			phy2f = (0x100 * i) + j;
			if (j < 0)
				phy2f += 0x100;
			PHY_WRITE(mac, 0x2f, phy2f);

			val = bwi_rf_lo_measure_11b(mac) / 10;
			if (val < min_val) {
				min_val = val;
				phy_val = phy2f;
			}
		}
	}
	PHY_WRITE(mac, 0x2f, phy_val + 0x101);

	/*
	 * Restore saved RF/PHY registers
	 */
	if (rf->rf_type == BWI_RF_T_BCM2050) {
		RESTORE_PHY_REG(mac, &regs, 0a);
		RESTORE_PHY_REG(mac, &regs, 2a);
		RESTORE_PHY_REG(mac, &regs, 35);
		RESTORE_PHY_REG(mac, &regs, 03);
		RESTORE_PHY_REG(mac, &regs, 01);
		RESTORE_PHY_REG(mac, &regs, 30);

		RESTORE_RF_REG(mac, &regs, 43);
		RESTORE_RF_REG(mac, &regs, 7a);

		RF_FILT_SETBITS(mac, 0x52, 0xf, regs.rf_52);

		CSR_WRITE_2(sc, BWI_BPHY_CTRL, bphy_ctrl);
	}
	RESTORE_PHY_REG(mac, &regs, 15);

	bwi_rf_workaround(mac, rf->rf_curchan);
}

/* INTERFACE */

uint16_t
bwi_read_sprom(struct bwi_softc *sc, uint16_t ofs)
{
	return (CSR_READ_2(sc, ofs + BWI_SPROM_START));
}

void
bwi_setup_desc32(struct bwi_softc *sc, struct bwi_desc32 *desc_array,
    int ndesc, int desc_idx, bus_addr_t paddr, int buf_len, int tx)
{
	struct bwi_desc32 *desc = &desc_array[desc_idx];
	uint32_t ctrl, addr, addr_hi, addr_lo;

	if (sc->sc_bus_space == BWI_BUS_SPACE_30BIT && paddr >= 0x40000000)
		panic("bad paddr 0x%lx\n", (long)paddr);

	addr_lo = __SHIFTOUT(paddr, BWI_DESC32_A_ADDR_MASK);
	addr_hi = __SHIFTOUT(paddr, BWI_DESC32_A_FUNC_MASK);

	addr = __SHIFTIN(addr_lo, BWI_DESC32_A_ADDR_MASK) |
	    __SHIFTIN(BWI_DESC32_A_FUNC_TXRX, BWI_DESC32_A_FUNC_MASK);

	ctrl = __SHIFTIN(buf_len, BWI_DESC32_C_BUFLEN_MASK) |
	     __SHIFTIN(addr_hi, BWI_DESC32_C_ADDRHI_MASK);
	if (desc_idx == ndesc - 1)
		ctrl |= BWI_DESC32_C_EOR;
	if (tx) {
		/* XXX */
		ctrl |= BWI_DESC32_C_FRAME_START |
		    BWI_DESC32_C_FRAME_END |
		    BWI_DESC32_C_INTR;
	}

	desc->addr = htole32(addr);
	desc->ctrl = htole32(ctrl);
}

void
bwi_power_on(struct bwi_softc *sc, int with_pll)
{
	uint32_t gpio_in, gpio_out, gpio_en, status;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	gpio_in = (sc->sc_conf_read)(sc, BWI_PCIR_GPIO_IN);
	if (gpio_in & BWI_PCIM_GPIO_PWR_ON)
		goto back;

	gpio_out = (sc->sc_conf_read)(sc, BWI_PCIR_GPIO_OUT);
	gpio_en = (sc->sc_conf_read)(sc, BWI_PCIR_GPIO_ENABLE);

	gpio_out |= BWI_PCIM_GPIO_PWR_ON;
	gpio_en |= BWI_PCIM_GPIO_PWR_ON;
	if (with_pll) {
		/* Turn off PLL first */
		gpio_out |= BWI_PCIM_GPIO_PLL_PWR_OFF;
		gpio_en |= BWI_PCIM_GPIO_PLL_PWR_OFF;
	}

	(sc->sc_conf_write)(sc, BWI_PCIR_GPIO_OUT, gpio_out);
	(sc->sc_conf_write)(sc, BWI_PCIR_GPIO_ENABLE, gpio_en);
	DELAY(1000);

	if (with_pll) {
		/* Turn on PLL */
		gpio_out &= ~BWI_PCIM_GPIO_PLL_PWR_OFF;
		(sc->sc_conf_write)(sc, BWI_PCIR_GPIO_OUT, gpio_out);
		DELAY(5000);
	}

back:
	/* Clear "Signaled Target Abort" */
	status = (sc->sc_conf_read)(sc, PCI_COMMAND_STATUS_REG);
	status &= ~PCI_STATUS_TARGET_TARGET_ABORT;
	(sc->sc_conf_write)(sc, PCI_COMMAND_STATUS_REG, status);
}

int
bwi_power_off(struct bwi_softc *sc, int with_pll)
{
	uint32_t gpio_out, gpio_en;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	(sc->sc_conf_read)(sc, BWI_PCIR_GPIO_IN); /* dummy read */
	gpio_out = (sc->sc_conf_read)(sc, BWI_PCIR_GPIO_OUT);
	gpio_en = (sc->sc_conf_read)(sc, BWI_PCIR_GPIO_ENABLE);

	gpio_out &= ~BWI_PCIM_GPIO_PWR_ON;
	gpio_en |= BWI_PCIM_GPIO_PWR_ON;
	if (with_pll) {
		gpio_out |= BWI_PCIM_GPIO_PLL_PWR_OFF;
		gpio_en |= BWI_PCIM_GPIO_PLL_PWR_OFF;
	}

	(sc->sc_conf_write)(sc, BWI_PCIR_GPIO_OUT, gpio_out);
	(sc->sc_conf_write)(sc, BWI_PCIR_GPIO_ENABLE, gpio_en);

	return (0);
}

int
bwi_regwin_switch(struct bwi_softc *sc, struct bwi_regwin *rw,
    struct bwi_regwin **old_rw)
{
	int error;

	if (old_rw != NULL)
		*old_rw = NULL;

	if (!BWI_REGWIN_EXIST(rw))
		return (EINVAL);

	if (sc->sc_cur_regwin != rw) {
		error = bwi_regwin_select(sc, rw->rw_id);
		if (error) {
			printf("%s: can't select regwin %d\n",
			    sc->sc_dev.dv_xname, rw->rw_id);
			return (error);
		}
	}

	if (old_rw != NULL)
		*old_rw = sc->sc_cur_regwin;
	sc->sc_cur_regwin = rw;

	return (0);
}

int
bwi_regwin_select(struct bwi_softc *sc, int id)
{
	uint32_t win = BWI_PCIM_REGWIN(id);
	int i;

#define RETRY_MAX	50
	for (i = 0; i < RETRY_MAX; ++i) {
		(sc->sc_conf_write)(sc, BWI_PCIR_SEL_REGWIN, win);
		if ((sc->sc_conf_read)(sc, BWI_PCIR_SEL_REGWIN) == win)
			return (0);
		DELAY(10);
	}
#undef RETRY_MAX

	return (ENXIO);
}

void
bwi_regwin_info(struct bwi_softc *sc, uint16_t *type, uint8_t *rev)
{
	uint32_t val;

	val = CSR_READ_4(sc, BWI_ID_HI);
	*type = BWI_ID_HI_REGWIN_TYPE(val);
	*rev = BWI_ID_HI_REGWIN_REV(val);

	DPRINTF(1, "%s: regwin: type 0x%03x, rev %d, vendor 0x%04x\n",
	    sc->sc_dev.dv_xname,
	    *type, *rev, __SHIFTOUT(val, BWI_ID_HI_REGWIN_VENDOR_MASK));
}

void
bwi_led_attach(struct bwi_softc *sc)
{
	const uint8_t *led_act = NULL;
	uint16_t gpio, val[BWI_LED_MAX];
	int i;

	for (i = 0; i < nitems(bwi_vendor_led_act); ++i) {
		if (sc->sc_pci_subvid == bwi_vendor_led_act[i].vid) {
			led_act = bwi_vendor_led_act[i].led_act;
				break;
		}
	}
	if (led_act == NULL)
		led_act = bwi_default_led_act;

	gpio = bwi_read_sprom(sc, BWI_SPROM_GPIO01);
	val[0] = __SHIFTOUT(gpio, BWI_SPROM_GPIO_0);
	val[1] = __SHIFTOUT(gpio, BWI_SPROM_GPIO_1);

	gpio = bwi_read_sprom(sc, BWI_SPROM_GPIO23);
	val[2] = __SHIFTOUT(gpio, BWI_SPROM_GPIO_2);
	val[3] = __SHIFTOUT(gpio, BWI_SPROM_GPIO_3);

	for (i = 0; i < BWI_LED_MAX; ++i) {
		struct bwi_led *led = &sc->sc_leds[i];

		if (val[i] == 0xff) {
			led->l_act = led_act[i];
		} else {
			if (val[i] & BWI_LED_ACT_LOW)
				led->l_flags |= BWI_LED_F_ACTLOW;
			led->l_act = __SHIFTOUT(val[i], BWI_LED_ACT_MASK);
		}
		led->l_mask = (1 << i);

		if (led->l_act == BWI_LED_ACT_BLINK_SLOW ||
		    led->l_act == BWI_LED_ACT_BLINK_POLL ||
		    led->l_act == BWI_LED_ACT_BLINK) {
		    led->l_flags |= BWI_LED_F_BLINK;
			if (led->l_act == BWI_LED_ACT_BLINK_POLL)
				led->l_flags |= BWI_LED_F_POLLABLE;
			else if (led->l_act == BWI_LED_ACT_BLINK_SLOW)
				led->l_flags |= BWI_LED_F_SLOW;

			if (sc->sc_blink_led == NULL) {
				sc->sc_blink_led = led;
				if (led->l_flags & BWI_LED_F_SLOW)
					BWI_LED_SLOWDOWN(sc->sc_led_idle);
			}
		}

		DPRINTF(1, "%s: %dth led, act %d, lowact %d\n",
		    sc->sc_dev.dv_xname, i, led->l_act,
		    led->l_flags & BWI_LED_F_ACTLOW);
	}
	timeout_set(&sc->sc_led_blink_next_ch, bwi_led_blink_next, sc);
	timeout_set(&sc->sc_led_blink_end_ch, bwi_led_blink_end, sc);
}

uint16_t
bwi_led_onoff(struct bwi_led *led, uint16_t val, int on)
{
	if (led->l_flags & BWI_LED_F_ACTLOW)
		on = !on;
	if (on)
		val |= led->l_mask;
	else
		val &= ~led->l_mask;

	return (val);
}

void
bwi_led_newstate(struct bwi_softc *sc, enum ieee80211_state nstate)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t val;
	int i;

	if (nstate == IEEE80211_S_INIT) {
		timeout_del(&sc->sc_led_blink_next_ch);
		timeout_del(&sc->sc_led_blink_end_ch);
		sc->sc_led_blinking = 0;
	}

	if ((ic->ic_if.if_flags & IFF_RUNNING) == 0)
		return;

	val = CSR_READ_2(sc, BWI_MAC_GPIO_CTRL);
	for (i = 0; i < BWI_LED_MAX; ++i) {
		struct bwi_led *led = &sc->sc_leds[i];
		int on;

		if (led->l_act == BWI_LED_ACT_UNKN ||
		    led->l_act == BWI_LED_ACT_NULL)
			continue;

		if ((led->l_flags & BWI_LED_F_BLINK) &&
			nstate != IEEE80211_S_INIT)
			continue;

		switch (led->l_act) {
		case BWI_LED_ACT_ON:	/* Always on */
			on = 1;
			break;
		case BWI_LED_ACT_OFF:	/* Always off */
		case BWI_LED_ACT_5GHZ:	/* TODO: 11A */
			on = 0;
			break;
		default:
			on = 1;
			switch (nstate) {
			case IEEE80211_S_INIT:
				on = 0;
				break;
			case IEEE80211_S_RUN:
				if (led->l_act == BWI_LED_ACT_11G &&
				    ic->ic_curmode != IEEE80211_MODE_11G)
					on = 0;
				break;
			default:
				if (led->l_act == BWI_LED_ACT_ASSOC)
					on = 0;
				break;
			}
			break;
		}

		val = bwi_led_onoff(led, val, on);
	}
	CSR_WRITE_2(sc, BWI_MAC_GPIO_CTRL, val);
}

void
bwi_led_event(struct bwi_softc *sc, int event)
{
	struct bwi_led *led = sc->sc_blink_led;
	int rate;

	if (event == BWI_LED_EVENT_POLL) {
		if ((led->l_flags & BWI_LED_F_POLLABLE) == 0)
			return;
		if (ticks - sc->sc_led_ticks < sc->sc_led_idle)
			return;
	}

	sc->sc_led_ticks = ticks;
	if (sc->sc_led_blinking)
		return;

	switch (event) {
	case BWI_LED_EVENT_RX:
		rate = sc->sc_rx_rate;
		break;
	case BWI_LED_EVENT_TX:
		rate = sc->sc_tx_rate;
		break;
	case BWI_LED_EVENT_POLL:
		rate = 0;
		break;
	default:
		panic("unknown LED event %d", event);
		break;
	}
	bwi_led_blink_start(sc, bwi_led_duration[rate].on_dur,
	    bwi_led_duration[rate].off_dur);
}

void
bwi_led_blink_start(struct bwi_softc *sc, int on_dur, int off_dur)
{
	struct bwi_led *led = sc->sc_blink_led;
	uint16_t val;

	val = CSR_READ_2(sc, BWI_MAC_GPIO_CTRL);
	val = bwi_led_onoff(led, val, 1);
	CSR_WRITE_2(sc, BWI_MAC_GPIO_CTRL, val);

	if (led->l_flags & BWI_LED_F_SLOW) {
		BWI_LED_SLOWDOWN(on_dur);
		BWI_LED_SLOWDOWN(off_dur);
	}

	sc->sc_led_blinking = 1;
	sc->sc_led_blink_offdur = off_dur;

	timeout_add(&sc->sc_led_blink_next_ch, on_dur);
}

void
bwi_led_blink_next(void *xsc)
{
	struct bwi_softc *sc = xsc;
	uint16_t val;

	val = CSR_READ_2(sc, BWI_MAC_GPIO_CTRL);
	val = bwi_led_onoff(sc->sc_blink_led, val, 0);
	CSR_WRITE_2(sc, BWI_MAC_GPIO_CTRL, val);

	timeout_add(&sc->sc_led_blink_end_ch, sc->sc_led_blink_offdur);
}

void
bwi_led_blink_end(void *xsc)
{
	struct bwi_softc *sc = xsc;

	sc->sc_led_blinking = 0;
}

int
bwi_bbp_attach(struct bwi_softc *sc)
{
	uint16_t bbp_id, rw_type;
	uint8_t rw_rev;
	uint32_t info;
	int error, nregwin, i;

	/*
	 * Get 0th regwin information
	 * NOTE: 0th regwin should exist
	 */
	error = bwi_regwin_select(sc, 0);
	if (error) {
		printf("%s: can't select regwin 0\n", sc->sc_dev.dv_xname);
		return (error);
	}
	bwi_regwin_info(sc, &rw_type, &rw_rev);

	/*
	 * Find out BBP id
	 */
	bbp_id = 0;
	info = 0;
	if (rw_type == BWI_REGWIN_T_COM) {
		info = CSR_READ_4(sc, BWI_INFO);
		bbp_id = __SHIFTOUT(info, BWI_INFO_BBPID_MASK);

		BWI_CREATE_REGWIN(&sc->sc_com_regwin, 0, rw_type, rw_rev);

		sc->sc_cap = CSR_READ_4(sc, BWI_CAPABILITY);
	} else {
		uint16_t did = sc->sc_pci_did;
		uint8_t revid = sc->sc_pci_revid;

		for (i = 0; i < nitems(bwi_bbpid_map); ++i) {
			if (did >= bwi_bbpid_map[i].did_min &&
			    did <= bwi_bbpid_map[i].did_max) {
				bbp_id = bwi_bbpid_map[i].bbp_id;
				break;
			}
		}
		if (bbp_id == 0) {
			printf("%s: no BBP id for device id 0x%04x\n",
			    sc->sc_dev.dv_xname, did);
			return (ENXIO);
		}

		info = __SHIFTIN(revid, BWI_INFO_BBPREV_MASK) |
		    __SHIFTIN(0, BWI_INFO_BBPPKG_MASK);
	}

	/*
	 * Find out number of regwins
	 */
	nregwin = 0;
	if (rw_type == BWI_REGWIN_T_COM && rw_rev >= 4) {
		nregwin = __SHIFTOUT(info, BWI_INFO_NREGWIN_MASK);
	} else {
		for (i = 0; i < nitems(bwi_regwin_count); ++i) {
			if (bwi_regwin_count[i].bbp_id == bbp_id) {
				nregwin = bwi_regwin_count[i].nregwin;
				break;
			}
		}
		if (nregwin == 0) {
			printf("%s: no number of win for BBP id 0x%04x\n",
			    sc->sc_dev.dv_xname, bbp_id);
			return (ENXIO);
		}
	}

	/* Record BBP id/rev for later using */
	sc->sc_bbp_id = bbp_id;
	sc->sc_bbp_rev = __SHIFTOUT(info, BWI_INFO_BBPREV_MASK);
	sc->sc_bbp_pkg = __SHIFTOUT(info, BWI_INFO_BBPPKG_MASK);
	DPRINTF(1, "%s: BBP id 0x%04x, BBP rev 0x%x, BBP pkg %d\n",
	    sc->sc_dev.dv_xname, sc->sc_bbp_id, sc->sc_bbp_rev, sc->sc_bbp_pkg);
	DPRINTF(1, "%s: nregwin %d, cap 0x%08x\n",
	    sc->sc_dev.dv_xname, nregwin, sc->sc_cap);

	/*
	 * Create rest of the regwins
	 */

	/* Don't re-create common regwin, if it is already created */
	i = BWI_REGWIN_EXIST(&sc->sc_com_regwin) ? 1 : 0;

	for (; i < nregwin; ++i) {
		/*
		 * Get regwin information
		 */
		error = bwi_regwin_select(sc, i);
		if (error) {
			printf("%s: can't select regwin %d\n",
			    sc->sc_dev.dv_xname, i);
			return (error);
		}
		bwi_regwin_info(sc, &rw_type, &rw_rev);

		/*
		 * Try attach:
		 * 1) Bus (PCI/PCIE) regwin
		 * 2) MAC regwin
		 * Ignore rest types of regwin
		 */
		if (rw_type == BWI_REGWIN_T_BUSPCI ||
		    rw_type == BWI_REGWIN_T_BUSPCIE) {
			if (BWI_REGWIN_EXIST(&sc->sc_bus_regwin)) {
				printf("%s: bus regwin already exists\n",
				    sc->sc_dev.dv_xname);
			} else {
				BWI_CREATE_REGWIN(&sc->sc_bus_regwin, i,
				    rw_type, rw_rev);
			}
		} else if (rw_type == BWI_REGWIN_T_MAC) {
			/* XXX ignore return value */
			bwi_mac_attach(sc, i, rw_rev);
		}
	}

	/* At least one MAC shold exist */
	if (!BWI_REGWIN_EXIST(&sc->sc_mac[0].mac_regwin)) {
		printf("%s: no MAC was found\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}
	KASSERT(sc->sc_nmac > 0);

	/* Bus regwin must exist */
	if (!BWI_REGWIN_EXIST(&sc->sc_bus_regwin)) {
		printf("%s: no bus regwin was found\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	/* Start with first MAC */
	error = bwi_regwin_switch(sc, &sc->sc_mac[0].mac_regwin, NULL);
	if (error)
		return (error);

	return (0);
}

int
bwi_bus_init(struct bwi_softc *sc, struct bwi_mac *mac)
{
	struct bwi_regwin *old, *bus;
	uint32_t val;
	int error;

	bus = &sc->sc_bus_regwin;
	KASSERT(sc->sc_cur_regwin == &mac->mac_regwin);

	/*
	 * Tell bus to generate requested interrupts
	 */
	if (bus->rw_rev < 6 && bus->rw_type == BWI_REGWIN_T_BUSPCI) {
		/*
		 * NOTE: Read BWI_FLAGS from MAC regwin
		 */
		val = CSR_READ_4(sc, BWI_FLAGS);

		error = bwi_regwin_switch(sc, bus, &old);
		if (error)
			return (error);

		CSR_SETBITS_4(sc, BWI_INTRVEC, (val & BWI_FLAGS_INTR_MASK));
	} else {
		uint32_t mac_mask;

		mac_mask = 1 << mac->mac_id;

		error = bwi_regwin_switch(sc, bus, &old);
		if (error)
			return (error);

		val = (sc->sc_conf_read)(sc, BWI_PCIR_INTCTL);
		val |= mac_mask << 8;
		(sc->sc_conf_write)(sc, BWI_PCIR_INTCTL, val);
	}

	if (sc->sc_flags & BWI_F_BUS_INITED)
		goto back;

	if (bus->rw_type == BWI_REGWIN_T_BUSPCI) {
		/*
		 * Enable prefetch and burst
		 */
		CSR_SETBITS_4(sc, BWI_BUS_CONFIG,
		    BWI_BUS_CONFIG_PREFETCH | BWI_BUS_CONFIG_BURST);

		if (bus->rw_rev < 5) {
			struct bwi_regwin *com = &sc->sc_com_regwin;

			/*
			 * Configure timeouts for bus operation
			 */

			/*
			 * Set service timeout and request timeout
			 */
			CSR_SETBITS_4(sc, BWI_CONF_LO,
			    __SHIFTIN(BWI_CONF_LO_SERVTO,
			    BWI_CONF_LO_SERVTO_MASK) |
			    __SHIFTIN(BWI_CONF_LO_REQTO,
			    BWI_CONF_LO_REQTO_MASK));

			/*
			 * If there is common regwin, we switch to that regwin
			 * and switch back to bus regwin once we have done.
			 */
			if (BWI_REGWIN_EXIST(com)) {
				error = bwi_regwin_switch(sc, com, NULL);
				if (error)
					return (error);
			}

			/* Let bus know what we have changed */
			CSR_WRITE_4(sc, BWI_BUS_ADDR, BWI_BUS_ADDR_MAGIC);
			CSR_READ_4(sc, BWI_BUS_ADDR); /* Flush */
			CSR_WRITE_4(sc, BWI_BUS_DATA, 0);
			CSR_READ_4(sc, BWI_BUS_DATA); /* Flush */

			if (BWI_REGWIN_EXIST(com)) {
				error = bwi_regwin_switch(sc, bus, NULL);
				if (error)
					return (error);
			}
		} else if (bus->rw_rev >= 11) {
			/*
			 * Enable memory read multiple
			 */
			CSR_SETBITS_4(sc, BWI_BUS_CONFIG, BWI_BUS_CONFIG_MRM);
		}
	} else {
		/* TODO: PCIE */
	}

	sc->sc_flags |= BWI_F_BUS_INITED;
back:
	return (bwi_regwin_switch(sc, old, NULL));
}

void
bwi_get_card_flags(struct bwi_softc *sc)
{
	sc->sc_card_flags = bwi_read_sprom(sc, BWI_SPROM_CARD_FLAGS);
	if (sc->sc_card_flags == 0xffff)
		sc->sc_card_flags = 0;

	if (sc->sc_pci_subvid == PCI_VENDOR_APPLE &&
	    sc->sc_pci_subdid == 0x4e && /* XXX */
	    sc->sc_pci_revid > 0x40)
		sc->sc_card_flags |= BWI_CARD_F_PA_GPIO9;

	DPRINTF(1, "%s: card flags 0x%04x\n",
	    sc->sc_dev.dv_xname, sc->sc_card_flags);
}

void
bwi_get_eaddr(struct bwi_softc *sc, uint16_t eaddr_ofs, uint8_t *eaddr)
{
	int i;

	for (i = 0; i < 3; ++i) {
		*((uint16_t *)eaddr + i) =
		    htobe16(bwi_read_sprom(sc, eaddr_ofs + 2 * i));
	}
}

void
bwi_get_clock_freq(struct bwi_softc *sc, struct bwi_clock_freq *freq)
{
	struct bwi_regwin *com;
	uint32_t val;
	uint div;
	int src;

	bzero(freq, sizeof(*freq));
	com = &sc->sc_com_regwin;

	KASSERT(BWI_REGWIN_EXIST(com));
	KASSERT(sc->sc_cur_regwin == com);
	KASSERT(sc->sc_cap & BWI_CAP_CLKMODE);

	/*
	 * Calculate clock frequency
	 */
	src = -1;
	div = 0;
	if (com->rw_rev < 6) {
		val = (sc->sc_conf_read)(sc, BWI_PCIR_GPIO_OUT);
		if (val & BWI_PCIM_GPIO_OUT_CLKSRC) {
			src = BWI_CLKSRC_PCI;
			div = 64;
		} else {
			src = BWI_CLKSRC_CS_OSC;
			div = 32;
		}
	} else if (com->rw_rev < 10) {
		val = CSR_READ_4(sc, BWI_CLOCK_CTRL);

		src = __SHIFTOUT(val, BWI_CLOCK_CTRL_CLKSRC);
		if (src == BWI_CLKSRC_LP_OSC)
			div = 1;
		else {
			div = (__SHIFTOUT(val, BWI_CLOCK_CTRL_FDIV) + 1) << 2;

			/* Unknown source */
			if (src >= BWI_CLKSRC_MAX)
				src = BWI_CLKSRC_CS_OSC;
		}
	} else {
		val = CSR_READ_4(sc, BWI_CLOCK_INFO);

		src = BWI_CLKSRC_CS_OSC;
		div = (__SHIFTOUT(val, BWI_CLOCK_INFO_FDIV) + 1) << 2;
	}

	KASSERT(src >= 0 && src < BWI_CLKSRC_MAX);
	KASSERT(div != 0);

	DPRINTF(1, "%s: clksrc %s\n",
	    sc->sc_dev.dv_xname,
	    src == BWI_CLKSRC_PCI ? "PCI" :
	    (src == BWI_CLKSRC_LP_OSC ? "LP_OSC" : "CS_OSC"));

	freq->clkfreq_min = bwi_clkfreq[src].freq_min / div;
	freq->clkfreq_max = bwi_clkfreq[src].freq_max / div;

	DPRINTF(1, "%s: clkfreq min %u, max %u\n",
	    sc->sc_dev.dv_xname, freq->clkfreq_min, freq->clkfreq_max);
}

int
bwi_set_clock_mode(struct bwi_softc *sc, enum bwi_clock_mode clk_mode)
{
	struct bwi_regwin *old, *com;
	uint32_t clk_ctrl, clk_src;
	int error, pwr_off = 0;

	com = &sc->sc_com_regwin;
	if (!BWI_REGWIN_EXIST(com))
		return (0);

	if (com->rw_rev >= 10 || com->rw_rev < 6)
		return (0);

	/*
	 * For common regwin whose rev is [6, 10), the chip
	 * must be capable to change clock mode.
	 */
	if ((sc->sc_cap & BWI_CAP_CLKMODE) == 0)
		return (0);

	error = bwi_regwin_switch(sc, com, &old);
	if (error)
		return (error);

	if (clk_mode == BWI_CLOCK_MODE_FAST)
		bwi_power_on(sc, 0);	/* Don't turn on PLL */

	clk_ctrl = CSR_READ_4(sc, BWI_CLOCK_CTRL);
	clk_src = __SHIFTOUT(clk_ctrl, BWI_CLOCK_CTRL_CLKSRC);

	switch (clk_mode) {
	case BWI_CLOCK_MODE_FAST:
		clk_ctrl &= ~BWI_CLOCK_CTRL_SLOW;
		clk_ctrl |= BWI_CLOCK_CTRL_IGNPLL;
		break;
	case BWI_CLOCK_MODE_SLOW:
		clk_ctrl |= BWI_CLOCK_CTRL_SLOW;
		break;
	case BWI_CLOCK_MODE_DYN:
		clk_ctrl &= ~(BWI_CLOCK_CTRL_SLOW |
		    BWI_CLOCK_CTRL_IGNPLL |
		    BWI_CLOCK_CTRL_NODYN);
		if (clk_src != BWI_CLKSRC_CS_OSC) {
			clk_ctrl |= BWI_CLOCK_CTRL_NODYN;
			pwr_off = 1;
		}
		break;
	}
	CSR_WRITE_4(sc, BWI_CLOCK_CTRL, clk_ctrl);

	if (pwr_off)
		bwi_power_off(sc, 0);	/* Leave PLL as it is */

	return (bwi_regwin_switch(sc, old, NULL));
}

int
bwi_set_clock_delay(struct bwi_softc *sc)
{
	struct bwi_regwin *old, *com;
	int error;

	com = &sc->sc_com_regwin;
	if (!BWI_REGWIN_EXIST(com))
		return (0);

	error = bwi_regwin_switch(sc, com, &old);
	if (error)
		return (error);

	if (sc->sc_bbp_id == BWI_BBPID_BCM4321) {
		if (sc->sc_bbp_rev == 0)
			CSR_WRITE_4(sc, BWI_CONTROL, BWI_CONTROL_MAGIC0);
		else if (sc->sc_bbp_rev == 1)
			CSR_WRITE_4(sc, BWI_CONTROL, BWI_CONTROL_MAGIC1);
	}

	if (sc->sc_cap & BWI_CAP_CLKMODE) {
		if (com->rw_rev >= 10)
			CSR_FILT_SETBITS_4(sc, BWI_CLOCK_INFO, 0xffff, 0x40000);
		else {
			struct bwi_clock_freq freq;

			bwi_get_clock_freq(sc, &freq);
			CSR_WRITE_4(sc, BWI_PLL_ON_DELAY,
			    howmany(freq.clkfreq_max * 150, 1000000));
			CSR_WRITE_4(sc, BWI_FREQ_SEL_DELAY,
			    howmany(freq.clkfreq_max * 15, 1000000));
		}
	}

	return (bwi_regwin_switch(sc, old, NULL));
}

int
bwi_init(struct ifnet *ifp)
{
	struct bwi_softc *sc = ifp->if_softc;

	bwi_init_statechg(sc, 1);

	return (0);
}

void
bwi_init_statechg(struct bwi_softc *sc, int statechg)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct bwi_mac *mac;
	int error;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	error = bwi_stop(sc, statechg);
	if (error) {
		DPRINTF(1, "%s: can't stop\n", sc->sc_dev.dv_xname);
		return;
	}

	/* power on cardbus socket */
	if (sc->sc_enable != NULL)
		(*sc->sc_enable)(sc);

	bwi_bbp_power_on(sc, BWI_CLOCK_MODE_FAST);

	/* TODO: 2 MAC */

	mac = &sc->sc_mac[0];
	error = bwi_regwin_switch(sc, &mac->mac_regwin, NULL);
	if (error)
		goto back;

	error = bwi_mac_init(mac);
	if (error)
		goto back;

	bwi_bbp_power_on(sc, BWI_CLOCK_MODE_DYN);
	
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));

	bwi_set_bssid(sc, bwi_zero_addr);	/* Clear BSSID */
	bwi_set_addr_filter(sc, BWI_ADDR_FILTER_MYADDR, ic->ic_myaddr);

	bwi_mac_reset_hwkeys(mac);

	if ((mac->mac_flags & BWI_MAC_F_HAS_TXSTATS) == 0) {
		int i;

#define NRETRY	1000
		/*
		 * Drain any possible pending TX status
		 */
		for (i = 0; i < NRETRY; ++i) {
			if ((CSR_READ_4(sc, BWI_TXSTATUS_0) &
			     BWI_TXSTATUS_0_MORE) == 0)
				break;
			CSR_READ_4(sc, BWI_TXSTATUS_1);
		}
		if (i == NRETRY)
			printf("%s: can't drain TX status\n",
			    sc->sc_dev.dv_xname);
#undef NRETRY
	}

	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11G)
		bwi_mac_updateslot(mac, 1);

	/* Start MAC */
	error = bwi_mac_start(mac);
	if (error)
		goto back;

	/* Enable intrs */
	bwi_enable_intrs(sc, BWI_INIT_INTRS);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (statechg) {
		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
		} else {
			ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
		}
	} else {
		ieee80211_new_state(ic, ic->ic_state, -1);
	}

back:
	if (error)
		bwi_stop(sc, 1);
	else
		bwi_start(ifp);
}

int
bwi_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct bwi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;
	uint8_t chan;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) == 0)
				bwi_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				bwi_stop(sc, 1);
		}
		break;
        case SIOCADDMULTI:
        case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;
	case SIOCS80211CHANNEL:
		/* allow fast channel switching in monitor mode */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING)) {
				ic->ic_bss->ni_chan = ic->ic_ibss_chan;
				chan = ieee80211_chan2ieee(ic,
				    ic->ic_bss->ni_chan);
				bwi_set_chan(sc, chan);
			}
			error = 0;
		}
		break;
	default:
		error = ieee80211_ioctl(ifp, cmd, data);
		break;
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			bwi_init(ifp);
		error = 0;
	}

	splx(s);

	return (error);
}

void
bwi_start(struct ifnet *ifp)
{
	struct bwi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct bwi_txbuf_data *tbd = &sc->sc_tx_bdata[BWI_TX_DATA_RING];
	int trans, idx;

	if (ifq_is_oactive(&ifp->if_snd) || (ifp->if_flags & IFF_RUNNING) == 0)
		return;

	trans = 0;
	idx = tbd->tbd_idx;

	while (tbd->tbd_buf[idx].tb_mbuf == NULL) {
		struct ieee80211_frame *wh;
		struct ieee80211_node *ni;
		struct ieee80211_key *k;
		struct mbuf *m;
		int mgt_pkt = 0;

		m = mq_dequeue(&ic->ic_mgtq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;

			mgt_pkt = 1;
		} else {
			struct ether_header *eh;

			if (ic->ic_state != IEEE80211_S_RUN)
				break;

			IFQ_DEQUEUE(&ifp->if_snd, m);
			if (m == NULL)
				break;

			if (m->m_len < sizeof(*eh)) {
				m = m_pullup(m, sizeof(*eh));
				if (m == NULL) {
					ifp->if_oerrors++;
					continue;
				}
			}
			eh = mtod(m, struct ether_header *);

			ni = ieee80211_find_txnode(ic, eh->ether_dhost);
			if (ni == NULL) {
				m_freem(m);
				ifp->if_oerrors++;
				continue;
			}

			/* TODO: PS */
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
			m = ieee80211_encap(ifp, m, &ni);
			if (m == NULL)
				continue;
		}
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		wh = mtod(m, struct ieee80211_frame *);
		if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
			k = ieee80211_get_txkey(ic, wh, ni);
			if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
				return;
		}
		wh = NULL;	/* Catch any invalid use */

		if (mgt_pkt) {
			ieee80211_release_node(ic, ni);
			ni = NULL;
		}

		if (bwi_encap(sc, idx, m, ni) != 0) {
			/* 'm' is freed in bwi_encap() if we reach here */
			if (ni != NULL)
				ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		trans = 1;
		tbd->tbd_used++;
		idx = (idx + 1) % BWI_TX_NDESC;

		if (tbd->tbd_used + BWI_TX_NSPRDESC >= BWI_TX_NDESC) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
	}
	tbd->tbd_idx = idx;

	if (trans)
		sc->sc_tx_timer = 5;
	ifp->if_timer = 1;
}

void
bwi_watchdog(struct ifnet *ifp)
{
	struct bwi_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	if (sc->sc_tx_timer) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: watchdog timeout\n",
			    sc->sc_dev.dv_xname);
			ifp->if_oerrors++;
			/* TODO */
		} else
			ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

void
bwi_newstate_begin(struct bwi_softc *sc, enum ieee80211_state nstate)
{
	timeout_del(&sc->sc_scan_ch);
	timeout_del(&sc->sc_calib_ch);

	bwi_led_newstate(sc, nstate);

	if (nstate == IEEE80211_S_INIT)
		sc->sc_txpwrcb_type = BWI_TXPWR_INIT;
}

int
bwi_stop(struct bwi_softc *sc, int state_chg)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct bwi_mac *mac;
	int i, error, pwr_off = 0;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	if (state_chg)
		ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
	else
		bwi_newstate_begin(sc, IEEE80211_S_INIT);

	if (ifp->if_flags & IFF_RUNNING) {
		KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
		mac = (struct bwi_mac *)sc->sc_cur_regwin;

		bwi_disable_intrs(sc, BWI_ALL_INTRS);
		CSR_READ_4(sc, BWI_MAC_INTR_MASK);
		bwi_mac_stop(mac);
	}

	for (i = 0; i < sc->sc_nmac; ++i) {
		struct bwi_regwin *old_rw;

		mac = &sc->sc_mac[i];
		if ((mac->mac_flags & BWI_MAC_F_INITED) == 0)
			continue;

		error = bwi_regwin_switch(sc, &mac->mac_regwin, &old_rw);
		if (error)
			continue;

		bwi_mac_shutdown(mac);
		pwr_off = 1;

		bwi_regwin_switch(sc, old_rw, NULL);
	}

	if (pwr_off)
		bwi_bbp_power_off(sc);

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* power off cardbus socket */
	if (sc->sc_disable)
		sc->sc_disable(sc);

	return (0);
}

int
bwi_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct bwi_softc *sc = ic->ic_if.if_softc;
	struct ieee80211_node *ni;
	int error;
	uint8_t chan;

	timeout_del(&sc->sc_amrr_ch);

	bwi_newstate_begin(sc, nstate);

	if (nstate == IEEE80211_S_INIT)
		goto back;

	chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
	error = bwi_set_chan(sc, chan);
	if (error) {
		printf("%s: can't set channel to %u\n",
		    sc->sc_dev.dv_xname,
		    ieee80211_chan2ieee(ic, ic->ic_des_chan));
		return (error);
	}

	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		/* Nothing to do */
	} else if (nstate == IEEE80211_S_RUN) {
		struct bwi_mac *mac;

		ni = ic->ic_bss;

		bwi_set_bssid(sc, ic->ic_bss->ni_bssid);

		KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
		mac = (struct bwi_mac *)sc->sc_cur_regwin;

		/* Initial TX power calibration */
		bwi_mac_calibrate_txpower(mac, BWI_TXPWR_INIT);
#ifdef notyet
		sc->sc_txpwrcb_type = BWI_TXPWR_FORCE;
#else
		sc->sc_txpwrcb_type = BWI_TXPWR_CALIB;
#endif
		if (ic->ic_opmode == IEEE80211_M_STA) {
			/* fake a join to init the tx rate */
			bwi_newassoc(ic, ni, 1);
		}

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			/* start automatic rate control timer */
			if (ic->ic_fixed_rate == -1)
				timeout_add_msec(&sc->sc_amrr_ch, 500);
		}
	} else
		bwi_set_bssid(sc, bwi_zero_addr);

back:
	error = sc->sc_newstate(ic, nstate, arg);

	if (nstate == IEEE80211_S_SCAN) {
		timeout_add_msec(&sc->sc_scan_ch, sc->sc_dwell_time);
	} else if (nstate == IEEE80211_S_RUN) {
		/* XXX 15 seconds */
		timeout_add_sec(&sc->sc_calib_ch, 1);
	}

	return (error);
}

int
bwi_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return (error);

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		bwi_init(ifp);

	return (0);
}

void
bwi_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct bwi_softc *sc = arg;
	struct bwi_node *bn = (struct bwi_node *)ni;

	ieee80211_amrr_choose(&sc->sc_amrr, ni, &bn->amn);
}

void
bwi_amrr_timeout(void *arg)
{
	struct bwi_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;

	if (ic->ic_opmode == IEEE80211_M_STA)
		bwi_iter_func(sc, ic->ic_bss);
#ifndef IEEE80211_STA_ONLY
	else
		ieee80211_iterate_nodes(ic, bwi_iter_func, sc);
#endif

	timeout_add_msec(&sc->sc_amrr_ch, 500);
}

void
bwi_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct bwi_softc *sc = ic->ic_if.if_softc;
	int i;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	ieee80211_amrr_node_init(&sc->sc_amrr, &((struct bwi_node *)ni)->amn);

	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	    i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	    i--);

	ni->ni_txrate = i;
}

struct ieee80211_node *
bwi_node_alloc(struct ieee80211com *ic)
{
	struct bwi_node *bn;

	bn = malloc(sizeof(*bn), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (bn == NULL)
		return (NULL);

	return ((struct ieee80211_node *)bn);
}

struct uvm_constraint_range bwi_constraint = { 0x0, (0x40000000 - 1) };
struct kmem_pa_mode bwi_pa_mode = {
	.kp_align = BWI_RING_ALIGN,
	.kp_constraint = &bwi_constraint,
	.kp_zero = 1
};

int
bwi_dma_alloc(struct bwi_softc *sc)
{
	int error, i, has_txstats;
	bus_size_t tx_ring_sz, rx_ring_sz, desc_sz = 0;
	uint32_t txrx_ctrl_step = 0;
	int s;

	has_txstats = 0;
	for (i = 0; i < sc->sc_nmac; ++i) {
		if (sc->sc_mac[i].mac_flags & BWI_MAC_F_HAS_TXSTATS) {
			has_txstats = 1;
			break;
		}
	}

	switch (sc->sc_bus_space) {
	case BWI_BUS_SPACE_30BIT:
		/* 
		 * 30bit devices must use bounce buffers but
		 * otherwise work like 32bit devices.
		 */
		sc->sc_newbuf = bwi_newbuf30;

		/* XXX implement txstats for 30bit? */
		has_txstats = 0;

		/* FALLTHROUGH */
	case BWI_BUS_SPACE_32BIT:
		desc_sz = sizeof(struct bwi_desc32);
		txrx_ctrl_step = 0x20;

		sc->sc_init_tx_ring = bwi_init_tx_ring32;
		sc->sc_free_tx_ring = bwi_free_tx_ring32;
		sc->sc_init_rx_ring = bwi_init_rx_ring32;
		sc->sc_free_rx_ring = bwi_free_rx_ring32;
		if (sc->sc_newbuf == NULL)
			sc->sc_newbuf = bwi_newbuf;
		sc->sc_setup_rxdesc = bwi_setup_rx_desc32;
		sc->sc_setup_txdesc = bwi_setup_tx_desc32;
		sc->sc_rxeof = bwi_rxeof32;
		sc->sc_start_tx = bwi_start_tx32;
		if (has_txstats) {
			sc->sc_init_txstats = bwi_init_txstats32;
			sc->sc_free_txstats = bwi_free_txstats32;
			sc->sc_txeof_status = bwi_txeof_status32;
		}
		break;

	default:
		panic("unsupported bus space type %d", sc->sc_bus_space);
	}

	KASSERT(desc_sz != 0);
	KASSERT(txrx_ctrl_step != 0);

	tx_ring_sz = roundup(desc_sz * BWI_TX_NDESC, BWI_RING_ALIGN);
	rx_ring_sz = roundup(desc_sz * BWI_RX_NDESC, BWI_RING_ALIGN);

	s = splvm();

#define TXRX_CTRL(idx)	(BWI_TXRX_CTRL_BASE + (idx) * txrx_ctrl_step)
	/*
	 * Create TX ring DMA stuffs
	 */
	for (i = 0; i < BWI_TX_NRING; ++i) {
		error = bwi_dma_ring_alloc(sc,
		    &sc->sc_tx_rdata[i], tx_ring_sz, TXRX_CTRL(i));
		if (error) {
			printf("%s: %dth TX ring DMA alloc failed\n",
			    sc->sc_dev.dv_xname, i);
			bwi_dma_free(sc);
			splx(s);
			return (error);
		}
	}

	/*
	 * Create RX ring DMA stuffs
	 */
	error = bwi_dma_ring_alloc(sc, &sc->sc_rx_rdata,
	    rx_ring_sz, TXRX_CTRL(0));
	if (error) {
		printf("%s: RX ring DMA alloc failed\n", sc->sc_dev.dv_xname);
		bwi_dma_free(sc);
		splx(s);
		return (error);
	}

	if (has_txstats) {
		error = bwi_dma_txstats_alloc(sc, TXRX_CTRL(3), desc_sz);
		if (error) {
			printf("%s: TX stats DMA alloc failed\n",
			    sc->sc_dev.dv_xname);
			bwi_dma_free(sc);
			splx(s);
			return (error);
		}
	}
#undef TXRX_CTRL

	if (sc->sc_bus_space == BWI_BUS_SPACE_30BIT)
		error = bwi_dma_mbuf_create30(sc);
	else
		error = bwi_dma_mbuf_create(sc);
	if (error)
		bwi_dma_free(sc);

	splx(s);

	return (error);
}

void
bwi_dma_free(struct bwi_softc *sc)
{
	struct bwi_ring_data *rd;
	int i;

	for (i = 0; i < BWI_TX_NRING; ++i) {
		rd = &sc->sc_tx_rdata[i];

		if (rd->rdata_desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, rd->rdata_dmap);
			km_free(rd->rdata_desc, rd->rdata_ring_sz,
			    &kv_intrsafe, &bwi_pa_mode);
			rd->rdata_desc = NULL;
		}
	}

	rd = &sc->sc_rx_rdata;

	if (rd->rdata_desc != NULL) {
		bus_dmamap_unload(sc->sc_dmat, rd->rdata_dmap);
		km_free(rd->rdata_desc, rd->rdata_ring_sz,
		    &kv_intrsafe, &bwi_pa_mode);
		rd->rdata_desc = NULL;
	}

	bwi_dma_txstats_free(sc);

	if (sc->sc_bus_space == BWI_BUS_SPACE_30BIT) {
		for (i = 0; i < BWI_TX_NRING; ++i) {
			if (sc->sc_bounce_tx_data[i] != NULL) {
				km_free(sc->sc_bounce_tx_data[i],
				    BWI_TX_NDESC * MCLBYTES,
				    &kv_intrsafe, &bwi_pa_mode);
				sc->sc_bounce_tx_data[i] = NULL;
			}
		}

		if (sc->sc_bounce_rx_data != NULL) {
			km_free(sc->sc_bounce_rx_data, BWI_RX_NDESC * MCLBYTES,
			    &kv_intrsafe, &bwi_pa_mode);
			sc->sc_bounce_rx_data = NULL;
		}
	}
}

int
bwi_dma_ring_alloc(struct bwi_softc *sc,
    struct bwi_ring_data *rd, bus_size_t size, uint32_t txrx_ctrl)
{
	int error;

	/* Allocate rings below 1GB so 30bit devices can access them.*/
	rd->rdata_desc = (caddr_t)km_alloc(size, &kv_intrsafe, &bwi_pa_mode,
	    &kd_nowait);
	if (rd->rdata_desc == NULL) {
		printf(": could not allocate ring DMA memory\n");
		return (ENOMEM);
	}

	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &rd->rdata_dmap);
	if (error) {
		printf(": cannot create ring DMA map (error %d)\n", error);
		km_free(rd->rdata_desc, size, &kv_intrsafe, &bwi_pa_mode);
		rd->rdata_desc = NULL;
		return (error);
	}

	error = bus_dmamap_load(sc->sc_dmat, rd->rdata_dmap, rd->rdata_desc,
	    size, NULL, BUS_DMA_WAITOK);
	if (error) {
		printf("%s: can't load DMA mem\n", sc->sc_dev.dv_xname);
		bus_dmamap_destroy(sc->sc_dmat, rd->rdata_dmap);
		km_free(rd->rdata_desc, size, &kv_intrsafe, &bwi_pa_mode);
		rd->rdata_desc = NULL;
		return (error);
	}

	rd->rdata_ring_sz = size;
	rd->rdata_paddr = rd->rdata_dmap->dm_segs[0].ds_addr;
	rd->rdata_txrx_ctrl = txrx_ctrl;

	return (0);
}

int
bwi_dma_txstats_alloc(struct bwi_softc *sc, uint32_t ctrl_base,
    bus_size_t desc_sz)
{
	struct bwi_txstats_data *st;
	bus_size_t dma_size;
	int error, nsegs;

	st = malloc(sizeof(*st), M_DEVBUF, M_WAITOK | M_ZERO);
	sc->sc_txstats = st;

	/*
	 * Create TX stats descriptor DMA stuffs
	 */
	dma_size = roundup(desc_sz * BWI_TXSTATS_NDESC, BWI_RING_ALIGN);

	error = bus_dmamap_create(sc->sc_dmat, dma_size, 1, dma_size, 0,
	    BUS_DMA_NOWAIT, &st->stats_ring_dmap);
	if (error) {
		printf("%s: can't create txstats ring DMA mem\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamem_alloc(sc->sc_dmat, dma_size, BWI_RING_ALIGN, 0,
	     &st->stats_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error) {
		printf("%s: can't allocate txstats ring DMA mem\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamem_map(sc->sc_dmat, &st->stats_ring_seg, nsegs,
	    dma_size, (caddr_t *)&st->stats_ring, BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: can't map txstats ring DMA mem\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamap_load(sc->sc_dmat, st->stats_ring_dmap,
	    st->stats_ring, dma_size, NULL, BUS_DMA_WAITOK);
	if (error) {
		printf("%s: can't load txstats ring DMA mem\n",
		    sc->sc_dev.dv_xname);
		bus_dmamem_free(sc->sc_dmat, &st->stats_ring_seg, nsegs);
		return (error);
	}

	st->stats_ring_paddr = st->stats_ring_dmap->dm_segs[0].ds_addr;

	/*
	 * Create TX stats DMA stuffs
	 */
	dma_size = roundup(sizeof(struct bwi_txstats) * BWI_TXSTATS_NDESC,
	    BWI_ALIGN);

	error = bus_dmamap_create(sc->sc_dmat, dma_size, 1, dma_size, 0,
	    BUS_DMA_NOWAIT, &st->stats_dmap);
	if (error) {
		printf("%s: can't create txstats ring DMA mem\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}
	error = bus_dmamem_alloc(sc->sc_dmat, dma_size, BWI_ALIGN, 0,
	    &st->stats_seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error) {
		printf("%s: can't allocate txstats DMA mem\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamem_map(sc->sc_dmat, &st->stats_seg, nsegs,
	    dma_size, (caddr_t *)&st->stats, BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: can't map txstats DMA mem\n", sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamap_load(sc->sc_dmat, st->stats_dmap, st->stats,
	    dma_size, NULL, BUS_DMA_WAITOK);
	if (error) {
		printf("%s: can't load txstats DMA mem\n", sc->sc_dev.dv_xname);
		bus_dmamem_free(sc->sc_dmat, &st->stats_seg, nsegs);
		return (error);
	}

	st->stats_paddr = st->stats_dmap->dm_segs[0].ds_addr;
	st->stats_ctrl_base = ctrl_base;

	return (0);
}

void
bwi_dma_txstats_free(struct bwi_softc *sc)
{
	struct bwi_txstats_data *st;

	if (sc->sc_txstats == NULL)
		return;
	st = sc->sc_txstats;

	bus_dmamap_unload(sc->sc_dmat, st->stats_ring_dmap);
	bus_dmamem_free(sc->sc_dmat, &st->stats_ring_seg, 1);

	bus_dmamap_unload(sc->sc_dmat, st->stats_dmap);
	bus_dmamem_free(sc->sc_dmat, &st->stats_seg, 1);

	free(st, M_DEVBUF, sizeof *st);
}

int
bwi_dma_mbuf_create30(struct bwi_softc *sc)
{
	int i, j, k, error;

	for (i = 0; i < BWI_TX_NRING; ++i) {
		struct bwi_txbuf_data *tbd = &sc->sc_tx_bdata[i];

		sc->sc_bounce_tx_data[i] = (caddr_t)km_alloc(
		    BWI_TX_NDESC * MCLBYTES, &kv_intrsafe,
		    &bwi_pa_mode, &kd_waitok);
		if (sc->sc_bounce_tx_data[i] == NULL) {
			printf(": could not allocate TX mbuf bounce buffer\n");
			error = ENOMEM;
			break;
		}

		for (j = 0; j < BWI_TX_NDESC; ++j) {
			error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
			    1, MCLBYTES, 0, BUS_DMA_NOWAIT,
			    &tbd->tbd_buf[j].tb_dmap);
			if (error) {
				printf(": cannot create TX mbuf DMA map\n");
				for (k = 0; k < j; ++k) {
					bus_dmamap_destroy(sc->sc_dmat,
					    tbd->tbd_buf[k].tb_dmap);
				}
				break;
			}
		}
	}
	if (error) {
		bwi_dma_mbuf_destroy(sc, i, 0);
		for (j = 0; j < i; ++j)
			km_free(sc->sc_bounce_tx_data[j], BWI_TX_NDESC,
			    &kv_intrsafe, &bwi_pa_mode);
		return (error);
	}

	for (i = 0; i < BWI_TX_NRING; ++i) {
		struct bwi_txbuf_data *tbd = &sc->sc_tx_bdata[i];

		for (j = 0; j < BWI_TX_NDESC; ++j) {
			struct bwi_txbuf *tb = &tbd->tbd_buf[j];

			error = bus_dmamap_load(sc->sc_dmat, tb->tb_dmap,
			    sc->sc_bounce_tx_data[i] + (MCLBYTES * j),
			    MCLBYTES, NULL, BUS_DMA_NOWAIT);
			if (error) {
				printf(": cannot create TX mbuf DMA map\n");
				for (k = 0; k < j; ++k) {
					bus_dmamap_destroy(sc->sc_dmat,
					    tbd->tbd_buf[k].tb_dmap);
				}
				break;
			}
		}
	}
	if (error) {
		bwi_dma_mbuf_destroy(sc, BWI_TX_NRING, 0);
		for (i = 0; i < BWI_TX_NRING; ++i)
			km_free(sc->sc_bounce_tx_data[i], BWI_TX_NDESC,
			    &kv_intrsafe, &bwi_pa_mode);
		return (error);
	}

	sc->sc_bounce_rx_data = (caddr_t)km_alloc(BWI_RX_NDESC * MCLBYTES,
	    &kv_intrsafe, &bwi_pa_mode, &kd_waitok);
	if (sc->sc_bounce_rx_data == NULL) {
		printf(": could not allocate RX mbuf bounce buffer\n");
		bwi_dma_mbuf_destroy(sc, BWI_TX_NRING, 0);
		for (i = 0; i < BWI_TX_NRING; ++i)
			km_free(sc->sc_bounce_tx_data[i], BWI_TX_NDESC,
			    &kv_intrsafe, &bwi_pa_mode);
		return (ENOMEM);
	}

	for (i = 0; i < BWI_RX_NDESC; ++i) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
		    MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->sc_rx_bdata.rbd_buf[i].rb_dmap);
		if (error) {
			printf(": cannot create RX mbuf DMA map\n");
			for (j = 0; j < i; ++j) {
				bus_dmamap_destroy(sc->sc_dmat,
				    sc->sc_rx_bdata.rbd_buf[j].rb_dmap);
			}
			break;
		}
	}
	if (error) {
		bwi_dma_mbuf_destroy(sc, BWI_TX_NRING, 0);
		for (i = 0; i < BWI_TX_NRING; ++i)
			km_free(sc->sc_bounce_tx_data[i], BWI_TX_NDESC,
			    &kv_intrsafe, &bwi_pa_mode);
		km_free(sc->sc_bounce_rx_data, BWI_RX_NDESC * MCLBYTES,
		    &kv_intrsafe, &bwi_pa_mode);
		return (error);
	}

	for (i = 0; i < BWI_RX_NDESC; ++i) {
		error = bwi_newbuf30(sc, i, 1);
		if (error) {
			printf(": cannot create RX mbuf DMA map\n");
			break;
		}
	}
	if (error) {
		bwi_dma_mbuf_destroy(sc, BWI_TX_NRING, 1);
		for (i = 0; i < BWI_TX_NRING; ++i)
			km_free(sc->sc_bounce_tx_data[i], BWI_TX_NDESC,
			    &kv_intrsafe, &bwi_pa_mode);
		km_free(sc->sc_bounce_rx_data, BWI_RX_NDESC * MCLBYTES,
		    &kv_intrsafe, &bwi_pa_mode);
		return (error);
	}

	return (0);
}

int
bwi_dma_mbuf_create(struct bwi_softc *sc)
{
	struct bwi_rxbuf_data *rbd = &sc->sc_rx_bdata;
	int i, j, k, ntx, error;

	ntx = 0;

	/*
	 * Create TX mbuf DMA map
	 */
	for (i = 0; i < BWI_TX_NRING; ++i) {
		struct bwi_txbuf_data *tbd = &sc->sc_tx_bdata[i];

		for (j = 0; j < BWI_TX_NDESC; ++j) {
			error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
			    0, BUS_DMA_NOWAIT, &tbd->tbd_buf[j].tb_dmap);
			if (error) {
				printf(
				    "%s: can't create %dth tbd, %dth DMA map\n",
				    sc->sc_dev.dv_xname, i, j);
				ntx = i;
				for (k = 0; k < j; ++k) {
					bus_dmamap_destroy(sc->sc_dmat,
					    tbd->tbd_buf[k].tb_dmap);
				}
				goto fail;
			}
		}
	}
	ntx = BWI_TX_NRING;

	/*
	 * Create RX mbuf DMA map and a spare DMA map
	 */
	error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
	    BUS_DMA_NOWAIT, &rbd->rbd_tmp_dmap);
	if (error) {
		printf("%s: can't create spare RX buf DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	for (j = 0; j < BWI_RX_NDESC; ++j) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_NOWAIT, &rbd->rbd_buf[j].rb_dmap);
		if (error) {
			printf("%s: can't create %dth RX buf DMA map\n",
			    sc->sc_dev.dv_xname, j);

			for (k = 0; k < j; ++k) {
				bus_dmamap_destroy(sc->sc_dmat,
				    rbd->rbd_buf[k].rb_dmap);
			}
			bus_dmamap_destroy(sc->sc_dmat,
			    rbd->rbd_tmp_dmap);
			goto fail;
		}
	}

	return 0;
fail:
	bwi_dma_mbuf_destroy(sc, ntx, 0);

	return (error);
}

void
bwi_dma_mbuf_destroy(struct bwi_softc *sc, int ntx, int nrx)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int i, j;

	for (i = 0; i < ntx; ++i) {
		struct bwi_txbuf_data *tbd = &sc->sc_tx_bdata[i];

		for (j = 0; j < BWI_TX_NDESC; ++j) {
			struct bwi_txbuf *tb = &tbd->tbd_buf[j];

			if (tb->tb_mbuf != NULL) {
				bus_dmamap_unload(sc->sc_dmat,
				    tb->tb_dmap);
				m_freem(tb->tb_mbuf);
			}
			if (tb->tb_ni != NULL)
				ieee80211_release_node(ic, tb->tb_ni);
			bus_dmamap_destroy(sc->sc_dmat, tb->tb_dmap);
		}
	}

	if (nrx) {
		struct bwi_rxbuf_data *rbd = &sc->sc_rx_bdata;

		bus_dmamap_destroy(sc->sc_dmat, rbd->rbd_tmp_dmap);
		for (j = 0; j < BWI_RX_NDESC; ++j) {
			struct bwi_rxbuf *rb = &rbd->rbd_buf[j];

			if (rb->rb_mbuf != NULL) {
				bus_dmamap_unload(sc->sc_dmat,
						  rb->rb_dmap);
				m_freem(rb->rb_mbuf);
			}
			bus_dmamap_destroy(sc->sc_dmat, rb->rb_dmap);
		}
	}
}

void
bwi_enable_intrs(struct bwi_softc *sc, uint32_t enable_intrs)
{
	CSR_SETBITS_4(sc, BWI_MAC_INTR_MASK, enable_intrs);
}

void
bwi_disable_intrs(struct bwi_softc *sc, uint32_t disable_intrs)
{
	CSR_CLRBITS_4(sc, BWI_MAC_INTR_MASK, disable_intrs);
}

int
bwi_init_tx_ring32(struct bwi_softc *sc, int ring_idx)
{
	struct bwi_ring_data *rd;
	struct bwi_txbuf_data *tbd;
	uint32_t val, addr_hi, addr_lo;

	KASSERT(ring_idx < BWI_TX_NRING);
	rd = &sc->sc_tx_rdata[ring_idx];
	tbd = &sc->sc_tx_bdata[ring_idx];

	tbd->tbd_idx = 0;
	tbd->tbd_used = 0;

	bzero(rd->rdata_desc, sizeof(struct bwi_desc32) * BWI_TX_NDESC);
	bus_dmamap_sync(sc->sc_dmat, rd->rdata_dmap, 0,
	    rd->rdata_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	addr_lo = __SHIFTOUT(rd->rdata_paddr, BWI_TXRX32_RINGINFO_ADDR_MASK);
	addr_hi = __SHIFTOUT(rd->rdata_paddr, BWI_TXRX32_RINGINFO_FUNC_MASK);

	val = __SHIFTIN(addr_lo, BWI_TXRX32_RINGINFO_ADDR_MASK) |
	    __SHIFTIN(BWI_TXRX32_RINGINFO_FUNC_TXRX,
	    BWI_TXRX32_RINGINFO_FUNC_MASK);
	CSR_WRITE_4(sc, rd->rdata_txrx_ctrl + BWI_TX32_RINGINFO, val);

	val = __SHIFTIN(addr_hi, BWI_TXRX32_CTRL_ADDRHI_MASK) |
	      BWI_TXRX32_CTRL_ENABLE;
	CSR_WRITE_4(sc, rd->rdata_txrx_ctrl + BWI_TX32_CTRL, val);

	return (0);
}

void
bwi_init_rxdesc_ring32(struct bwi_softc *sc, uint32_t ctrl_base,
    bus_addr_t paddr, int hdr_size, int ndesc)
{
	uint32_t val, addr_hi, addr_lo;

	addr_lo = __SHIFTOUT(paddr, BWI_TXRX32_RINGINFO_ADDR_MASK);
	addr_hi = __SHIFTOUT(paddr, BWI_TXRX32_RINGINFO_FUNC_MASK);

	val = __SHIFTIN(addr_lo, BWI_TXRX32_RINGINFO_ADDR_MASK) |
	    __SHIFTIN(BWI_TXRX32_RINGINFO_FUNC_TXRX,
	      		BWI_TXRX32_RINGINFO_FUNC_MASK);
	CSR_WRITE_4(sc, ctrl_base + BWI_RX32_RINGINFO, val);

	val = __SHIFTIN(hdr_size, BWI_RX32_CTRL_HDRSZ_MASK) |
	    __SHIFTIN(addr_hi, BWI_TXRX32_CTRL_ADDRHI_MASK) |
	    BWI_TXRX32_CTRL_ENABLE;
	CSR_WRITE_4(sc, ctrl_base + BWI_RX32_CTRL, val);

	CSR_WRITE_4(sc, ctrl_base + BWI_RX32_INDEX,
	    (ndesc - 1) * sizeof(struct bwi_desc32));
}

int
bwi_init_rx_ring32(struct bwi_softc *sc)
{
	struct bwi_ring_data *rd = &sc->sc_rx_rdata;
	int i, error;

	sc->sc_rx_bdata.rbd_idx = 0;
	bzero(rd->rdata_desc, sizeof(struct bwi_desc32) * BWI_RX_NDESC);

	for (i = 0; i < BWI_RX_NDESC; ++i) {
		error = sc->sc_newbuf(sc, i, 1);
		if (error) {
			printf("%s: can't allocate %dth RX buffer\n",
			    sc->sc_dev.dv_xname, i);
			return (error);
		}
	}
	bus_dmamap_sync(sc->sc_dmat, rd->rdata_dmap, 0,
	    rd->rdata_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	bwi_init_rxdesc_ring32(sc, rd->rdata_txrx_ctrl, rd->rdata_paddr,
	    sizeof(struct bwi_rxbuf_hdr), BWI_RX_NDESC);
	return (0);
}

int
bwi_init_txstats32(struct bwi_softc *sc)
{
	struct bwi_txstats_data *st = sc->sc_txstats;
	bus_addr_t stats_paddr;
	int i;

	bzero(st->stats, BWI_TXSTATS_NDESC * sizeof(struct bwi_txstats));
	bus_dmamap_sync(sc->sc_dmat, st->stats_dmap, 0,
	    st->stats_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	st->stats_idx = 0;

	stats_paddr = st->stats_paddr;
	for (i = 0; i < BWI_TXSTATS_NDESC; ++i) {
		bwi_setup_desc32(sc, st->stats_ring, BWI_TXSTATS_NDESC, i,
				 stats_paddr, sizeof(struct bwi_txstats), 0);
		stats_paddr += sizeof(struct bwi_txstats);
	}
	bus_dmamap_sync(sc->sc_dmat, st->stats_ring_dmap, 0,
	    st->stats_ring_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	bwi_init_rxdesc_ring32(sc, st->stats_ctrl_base,
	    st->stats_ring_paddr, 0, BWI_TXSTATS_NDESC);

	return (0);
}

void
bwi_setup_rx_desc32(struct bwi_softc *sc, int buf_idx, bus_addr_t paddr,
    int buf_len)
{
	struct bwi_ring_data *rd = &sc->sc_rx_rdata;

	KASSERT(buf_idx < BWI_RX_NDESC);
	bwi_setup_desc32(sc, rd->rdata_desc, BWI_RX_NDESC, buf_idx,
	    paddr, buf_len, 0);
}

void
bwi_setup_tx_desc32(struct bwi_softc *sc, struct bwi_ring_data *rd,
    int buf_idx, bus_addr_t paddr, int buf_len)
{
	KASSERT(buf_idx < BWI_TX_NDESC);
	bwi_setup_desc32(sc, rd->rdata_desc, BWI_TX_NDESC, buf_idx,
	    paddr, buf_len, 1);
}

int
bwi_newbuf30(struct bwi_softc *sc, int buf_idx, int init)
{
	struct bwi_rxbuf_data *rbd = &sc->sc_rx_bdata;
	struct bwi_rxbuf *rb = &rbd->rbd_buf[buf_idx];
	struct mbuf *m;
	struct bwi_rxbuf_hdr *hdr;
	int error;

	KASSERT(buf_idx < BWI_RX_NDESC);

	/* Create host-side mbuf. */
	MGETHDR(m, init ? M_WAITOK : M_NOWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);
	MCLGET(m, init ? M_WAITOK : M_NOWAIT);
	if (m == NULL)
		return (ENOBUFS);
	m->m_len = m->m_pkthdr.len = MCLBYTES;

	if (init) {
		/* Load device-side RX DMA buffer. */
		error = bus_dmamap_load(sc->sc_dmat, rb->rb_dmap,
		    sc->sc_bounce_rx_data + (MCLBYTES * buf_idx),
		    MCLBYTES, NULL, BUS_DMA_WAITOK);
		if (error) {
			m_freem(m);
			return (error);
		}
	}

	rb->rb_mbuf = m;
	rb->rb_paddr = rb->rb_dmap->dm_segs[0].ds_addr;

	/*
	 * Clear RX buf header
	 */
	hdr = (struct bwi_rxbuf_hdr *)(sc->sc_bounce_rx_data +
	    (MCLBYTES * buf_idx));
	bzero(hdr, sizeof(*hdr));
	bus_dmamap_sync(sc->sc_dmat, rb->rb_dmap, 0,
	    rb->rb_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	/*
	 * Setup RX buf descriptor
	 */
	sc->sc_setup_rxdesc(sc, buf_idx, rb->rb_paddr,
	    m->m_len - sizeof(*hdr));

	return (0);
}

int
bwi_newbuf(struct bwi_softc *sc, int buf_idx, int init)
{
	struct bwi_rxbuf_data *rbd = &sc->sc_rx_bdata;
	struct bwi_rxbuf *rxbuf = &rbd->rbd_buf[buf_idx];
	struct bwi_rxbuf_hdr *hdr;
	bus_dmamap_t map;
	bus_addr_t paddr;
	struct mbuf *m;
	int error;

	KASSERT(buf_idx < BWI_RX_NDESC);

	MGETHDR(m, init ? M_WAITOK : M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);
	MCLGET(m, init ? M_WAITOK : M_DONTWAIT);
	if (m == NULL) {
		error = ENOBUFS;

		/*
		 * If the NIC is up and running, we need to:
		 * - Clear RX buffer's header.
		 * - Restore RX descriptor settings.
		 */
		if (init)
			return error;
		else
			goto back;
	}
	m->m_len = m->m_pkthdr.len = MCLBYTES;

	/*
	 * Try to load RX buf into temporary DMA map
	 */
	error = bus_dmamap_load_mbuf(sc->sc_dmat, rbd->rbd_tmp_dmap, m,
	    init ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);

		/*
		 * See the comment above
		 */
		if (init)
			return error;
		else
			goto back;
	}

	if (!init)
		bus_dmamap_unload(sc->sc_dmat, rxbuf->rb_dmap);
	rxbuf->rb_mbuf = m;

	/*
	 * Swap RX buf's DMA map with the loaded temporary one
	 */
	map = rxbuf->rb_dmap;
	rxbuf->rb_dmap = rbd->rbd_tmp_dmap;
	rbd->rbd_tmp_dmap = map;
	paddr = rxbuf->rb_dmap->dm_segs[0].ds_addr;
	rxbuf->rb_paddr = paddr;

back:
	/*
	 * Clear RX buf header
	 */
	hdr = mtod(rxbuf->rb_mbuf, struct bwi_rxbuf_hdr *);
	bzero(hdr, sizeof(*hdr));
	bus_dmamap_sync(sc->sc_dmat, rxbuf->rb_dmap, 0,
	    rxbuf->rb_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	/*
	 * Setup RX buf descriptor
	 */
	sc->sc_setup_rxdesc(sc, buf_idx, rxbuf->rb_paddr,
	    rxbuf->rb_mbuf->m_len - sizeof(*hdr));
	return error;
}

void
bwi_set_addr_filter(struct bwi_softc *sc, uint16_t addr_ofs,
    const uint8_t *addr)
{
	int i;

	CSR_WRITE_2(sc, BWI_ADDR_FILTER_CTRL,
	    BWI_ADDR_FILTER_CTRL_SET | addr_ofs);

	for (i = 0; i < (IEEE80211_ADDR_LEN / 2); ++i) {
		uint16_t addr_val;

		addr_val = (uint16_t)addr[i * 2] |
		    (((uint16_t)addr[(i * 2) + 1]) << 8);
		CSR_WRITE_2(sc, BWI_ADDR_FILTER_DATA, addr_val);
	}
}

int
bwi_set_chan(struct bwi_softc *sc, uint8_t chan)
{
	struct bwi_mac *mac;

	KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
	mac = (struct bwi_mac *)sc->sc_cur_regwin;

	bwi_rf_set_chan(mac, chan, 0);

	return (0);
}

void
bwi_next_scan(void *xsc)
{
	struct bwi_softc *sc = xsc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	s = splnet();

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);

	splx(s);
}

int
bwi_rxeof(struct bwi_softc *sc, int end_idx)
{
	struct bwi_ring_data *rd = &sc->sc_rx_rdata;
	struct bwi_rxbuf_data *rbd = &sc->sc_rx_bdata;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int idx, rx_data = 0;

	idx = rbd->rbd_idx;
	while (idx != end_idx) {
		struct bwi_rxbuf *rb = &rbd->rbd_buf[idx];
		struct bwi_rxbuf_hdr *hdr;
		struct ieee80211_frame *wh;
		struct ieee80211_rxinfo rxi;
		struct ieee80211_node *ni;
		struct mbuf *m;
		uint32_t plcp;
		uint16_t flags2;
		int buflen, wh_ofs, hdr_extra, rssi, type, rate;

		bus_dmamap_sync(sc->sc_dmat, rb->rb_dmap, 0,
		    rb->rb_dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);

		if (sc->sc_bus_space == BWI_BUS_SPACE_30BIT) {
			/* Bounce for 30bit devices. */
			if (m_copyback(rb->rb_mbuf, 0, MCLBYTES,
			    sc->sc_bounce_rx_data + (MCLBYTES * idx),
			    M_NOWAIT) == ENOBUFS) {
				ifp->if_ierrors++;
				goto next;
			}
		}

		m = rb->rb_mbuf;

		if (sc->sc_newbuf(sc, idx, 0)) {
			ifp->if_ierrors++;
			goto next;
		}

		hdr = mtod(m, struct bwi_rxbuf_hdr *);
		flags2 = letoh16(hdr->rxh_flags2);

		hdr_extra = 0;
		if (flags2 & BWI_RXH_F2_TYPE2FRAME)
			hdr_extra = 2;
		wh_ofs = hdr_extra + 6;

		buflen = letoh16(hdr->rxh_buflen);
		if (buflen <= wh_ofs) {
			printf("%s: zero length data, hdr_extra %d\n",
			    sc->sc_dev.dv_xname, hdr_extra);
			ifp->if_ierrors++;
			m_freem(m);
			goto next;
		}

		bcopy((uint8_t *)(hdr + 1) + hdr_extra, &plcp, sizeof(plcp));
		rssi = bwi_calc_rssi(sc, hdr);

		m->m_len = m->m_pkthdr.len = buflen + sizeof(*hdr);
		m_adj(m, sizeof(*hdr) + wh_ofs);

		if (htole16(hdr->rxh_flags1) & BWI_RXH_F1_OFDM)
			rate = bwi_plcp2rate(plcp, IEEE80211_MODE_11G);
		else
			rate = bwi_plcp2rate(plcp, IEEE80211_MODE_11B);

#if NBPFILTER > 0
		/* RX radio tap */
		if (sc->sc_drvbpf != NULL) {
			struct mbuf mb;
			struct bwi_rx_radiotap_hdr *tap = &sc->sc_rxtap;

			tap->wr_tsf = hdr->rxh_tsf;
			tap->wr_flags = IEEE80211_RADIOTAP_F_FCS;
			tap->wr_rate = rate;
			tap->wr_chan_freq =
			    htole16(ic->ic_bss->ni_chan->ic_freq);
			tap->wr_chan_flags =
			    htole16(ic->ic_bss->ni_chan->ic_flags);
			tap->wr_antsignal = rssi;
			tap->wr_antnoise = BWI_NOISE_FLOOR;

			mb.m_data = (caddr_t)tap;
			mb.m_len = sc->sc_rxtap_len;
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
		}
#endif

		m_adj(m, -IEEE80211_CRC_LEN);

		wh = mtod(m, struct ieee80211_frame *);
		ni = ieee80211_find_rxnode(ic, wh);
		type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;

		rxi.rxi_rssi = hdr->rxh_rssi;
		rxi.rxi_tstamp = letoh16(hdr->rxh_tsf);
		ieee80211_input(ifp, m, ni, &rxi);

		ieee80211_release_node(ic, ni);

		if (type == IEEE80211_FC0_TYPE_DATA) {
			rx_data = 1;
			sc->sc_rx_rate = rate;
		}
next:
		idx = (idx + 1) % BWI_RX_NDESC;
	}

	rbd->rbd_idx = idx;
	bus_dmamap_sync(sc->sc_dmat, rd->rdata_dmap, 0,
	    rd->rdata_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	return (rx_data);
}

int
bwi_rxeof32(struct bwi_softc *sc)
{
	uint32_t val, rx_ctrl;
	int end_idx, rx_data;

	rx_ctrl = sc->sc_rx_rdata.rdata_txrx_ctrl;

	val = CSR_READ_4(sc, rx_ctrl + BWI_RX32_STATUS);
	end_idx = __SHIFTOUT(val, BWI_RX32_STATUS_INDEX_MASK) /
	    sizeof(struct bwi_desc32);

	rx_data = bwi_rxeof(sc, end_idx);

	CSR_WRITE_4(sc, rx_ctrl + BWI_RX32_INDEX,
	    end_idx * sizeof(struct bwi_desc32));

	return (rx_data);
}

void
bwi_reset_rx_ring32(struct bwi_softc *sc, uint32_t rx_ctrl)
{
	int i;

	CSR_WRITE_4(sc, rx_ctrl + BWI_RX32_CTRL, 0);

#define NRETRY 10
	for (i = 0; i < NRETRY; ++i) {
		uint32_t status;

		status = CSR_READ_4(sc, rx_ctrl + BWI_RX32_STATUS);
		if (__SHIFTOUT(status, BWI_RX32_STATUS_STATE_MASK) ==
		    BWI_RX32_STATUS_STATE_DISABLED)
			break;

		DELAY(1000);
	}
	if (i == NRETRY)
		printf("%s: reset rx ring timedout\n", sc->sc_dev.dv_xname);
#undef NRETRY

	CSR_WRITE_4(sc, rx_ctrl + BWI_RX32_RINGINFO, 0);
}

void
bwi_free_txstats32(struct bwi_softc *sc)
{
	bwi_reset_rx_ring32(sc, sc->sc_txstats->stats_ctrl_base);
}

void
bwi_free_rx_ring32(struct bwi_softc *sc)
{
	struct bwi_ring_data *rd = &sc->sc_rx_rdata;
	struct bwi_rxbuf_data *rbd = &sc->sc_rx_bdata;
	int i;

	bwi_reset_rx_ring32(sc, rd->rdata_txrx_ctrl);

	for (i = 0; i < BWI_RX_NDESC; ++i) {
		struct bwi_rxbuf *rb = &rbd->rbd_buf[i];

		if (rb->rb_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat, rb->rb_dmap);
			m_freem(rb->rb_mbuf);
			rb->rb_mbuf = NULL;
		}
	}
}

void
bwi_free_tx_ring32(struct bwi_softc *sc, int ring_idx)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct bwi_ring_data *rd;
	struct bwi_txbuf_data *tbd;
	uint32_t state, val;
	int i;

	KASSERT(ring_idx < BWI_TX_NRING);
	rd = &sc->sc_tx_rdata[ring_idx];
	tbd = &sc->sc_tx_bdata[ring_idx];

#define NRETRY 10
	for (i = 0; i < NRETRY; ++i) {
		val = CSR_READ_4(sc, rd->rdata_txrx_ctrl + BWI_TX32_STATUS);
		state = __SHIFTOUT(val, BWI_TX32_STATUS_STATE_MASK);
		if (state == BWI_TX32_STATUS_STATE_DISABLED ||
		    state == BWI_TX32_STATUS_STATE_IDLE ||
		    state == BWI_TX32_STATUS_STATE_STOPPED)
			break;

		DELAY(1000);
	}
	if (i == NRETRY) {
		printf("%s: wait for TX ring(%d) stable timed out\n",
		    sc->sc_dev.dv_xname, ring_idx);
	}

	CSR_WRITE_4(sc, rd->rdata_txrx_ctrl + BWI_TX32_CTRL, 0);
	for (i = 0; i < NRETRY; ++i) {
		val = CSR_READ_4(sc, rd->rdata_txrx_ctrl + BWI_TX32_STATUS);
		state = __SHIFTOUT(val, BWI_TX32_STATUS_STATE_MASK);
		if (state == BWI_TX32_STATUS_STATE_DISABLED)
			break;

		DELAY(1000);
	}
	if (i == NRETRY)
		printf("%s: reset TX ring (%d) timed out\n",
		    sc->sc_dev.dv_xname, ring_idx);
#undef NRETRY

	DELAY(1000);

	CSR_WRITE_4(sc, rd->rdata_txrx_ctrl + BWI_TX32_RINGINFO, 0);

	for (i = 0; i < BWI_TX_NDESC; ++i) {
		struct bwi_txbuf *tb = &tbd->tbd_buf[i];

		if (tb->tb_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat, tb->tb_dmap);
			m_freem(tb->tb_mbuf);
			tb->tb_mbuf = NULL;
		}
		if (tb->tb_ni != NULL) {
			ieee80211_release_node(ic, tb->tb_ni);
			tb->tb_ni = NULL;
		}
	}
}

uint8_t
bwi_plcp2rate(uint32_t plcp0, enum ieee80211_phymode phymode)
{
	uint32_t plcp = letoh32(plcp0) & IEEE80211_OFDM_PLCP_RATE_MASK;
	return (ieee80211_plcp2rate(plcp, phymode));
}

void
bwi_ofdm_plcp_header(uint32_t *plcp0, int pkt_len, uint8_t rate)
{
	uint32_t plcp;

	plcp = __SHIFTIN(ieee80211_rate2plcp(rate, IEEE80211_MODE_11G),
	    IEEE80211_OFDM_PLCP_RATE_MASK) |
	    __SHIFTIN(pkt_len, IEEE80211_OFDM_PLCP_LEN_MASK);
	*plcp0 = htole32(plcp);
}

void
bwi_ds_plcp_header(struct ieee80211_ds_plcp_hdr *plcp, int pkt_len,
    uint8_t rate)
{
	int len, service, pkt_bitlen;

	pkt_bitlen = pkt_len * NBBY;
	len = howmany(pkt_bitlen * 2, rate);

	service = IEEE80211_DS_PLCP_SERVICE_LOCKED;
	if (rate == (11 * 2)) {
		int pkt_bitlen1;

		/*
		 * PLCP service field needs to be adjusted,
		 * if TX rate is 11Mbytes/s
		 */
		pkt_bitlen1 = len * 11;
		if (pkt_bitlen1 - pkt_bitlen >= NBBY)
			service |= IEEE80211_DS_PLCP_SERVICE_LENEXT7;
	}

	plcp->i_signal = ieee80211_rate2plcp(rate, IEEE80211_MODE_11B);
	plcp->i_service = service;
	plcp->i_length = htole16(len);
	/* NOTE: do NOT touch i_crc */
}

void
bwi_plcp_header(void *plcp, int pkt_len, uint8_t rate)
{
	enum bwi_modtype modtype;

	/*
	 * Assume caller has zeroed 'plcp'
	 */

	modtype = bwi_rate2modtype(rate);
	if (modtype == IEEE80211_MODTYPE_OFDM)
		bwi_ofdm_plcp_header(plcp, pkt_len, rate);
	else if (modtype == IEEE80211_MODTYPE_DS)
		bwi_ds_plcp_header(plcp, pkt_len, rate);
	else
		panic("unsupport modulation type %u", modtype);
}

enum bwi_modtype
bwi_rate2modtype(uint8_t rate)
{
	rate &= IEEE80211_RATE_VAL;

	if (rate == 44)
		return IEEE80211_MODTYPE_PBCC;
	else if (rate == 22 || rate < 12)
		return IEEE80211_MODTYPE_DS;
	else
		return IEEE80211_MODTYPE_OFDM;
}

uint8_t
bwi_ack_rate(struct ieee80211_node *ni, uint8_t rate)
{
	const struct ieee80211_rateset *rs = &ni->ni_rates;
	uint8_t ack_rate = 0;
	enum bwi_modtype modtype;
	int i;

	rate &= IEEE80211_RATE_VAL;

	modtype = bwi_rate2modtype(rate);

	for (i = 0; i < rs->rs_nrates; ++i) {
		uint8_t rate1 = rs->rs_rates[i] & IEEE80211_RATE_VAL;
		
		if (rate1 > rate) {
			if (ack_rate != 0)
				return ack_rate;
			else
				break;
		}

		if ((rs->rs_rates[i] & IEEE80211_RATE_BASIC) &&
		    bwi_rate2modtype(rate1) == modtype)
			ack_rate = rate1;
	}

	switch (rate) {
	/* CCK */
	case 2:
	case 4:
	case 11:
	case 22:
		ack_rate = rate;
		break;
	/* PBCC */
	case 44:
		ack_rate = 22;
		break;

	/* OFDM */
	case 12:
	case 18:
		ack_rate = 12;
		break;
	case 24:
	case 36:
		ack_rate = 24;
		break;
	case 48:
	case 72:
	case 96:
	case 108:
		ack_rate = 48;
		break;
	default:
		panic("unsupported rate %d", rate);
	}
	return ack_rate;
}

#define IEEE80211_OFDM_TXTIME(kbps, frmlen)	\
	(IEEE80211_OFDM_PREAMBLE_TIME +		\
	 IEEE80211_OFDM_SIGNAL_TIME +		\
	(IEEE80211_OFDM_NSYMS((kbps), (frmlen)) * IEEE80211_OFDM_SYM_TIME))

#define IEEE80211_OFDM_SYM_TIME			4
#define IEEE80211_OFDM_PREAMBLE_TIME		16
#define IEEE80211_OFDM_SIGNAL_EXT_TIME		6
#define IEEE80211_OFDM_SIGNAL_TIME		4

#define IEEE80211_OFDM_PLCP_SERVICE_NBITS	16
#define IEEE80211_OFDM_TAIL_NBITS		6	

#define IEEE80211_OFDM_NBITS(frmlen)		\
	(IEEE80211_OFDM_PLCP_SERVICE_NBITS +	\
	 ((frmlen) * NBBY) +			\
	 IEEE80211_OFDM_TAIL_NBITS)

#define IEEE80211_OFDM_NBITS_PER_SYM(kbps)	\
	(((kbps) * IEEE80211_OFDM_SYM_TIME) / 1000)

#define IEEE80211_OFDM_NSYMS(kbps, frmlen)	\
	howmany(IEEE80211_OFDM_NBITS((frmlen)),	\
	IEEE80211_OFDM_NBITS_PER_SYM((kbps)))

#define IEEE80211_CCK_TXTIME(kbps, frmlen)	\
	(((IEEE80211_CCK_NBITS((frmlen)) * 1000) + (kbps) - 1) / (kbps))

#define IEEE80211_CCK_PREAMBLE_LEN		144
#define IEEE80211_CCK_PLCP_HDR_TIME		48
#define IEEE80211_CCK_SHPREAMBLE_LEN		72
#define IEEE80211_CCK_SHPLCP_HDR_TIME		24

#define IEEE80211_CCK_NBITS(frmlen)		((frmlen) * NBBY)

uint16_t
bwi_txtime(struct ieee80211com *ic, struct ieee80211_node *ni, uint len,
    uint8_t rs_rate, uint32_t flags)
{
	enum bwi_modtype modtype;
	uint16_t txtime;
	int rate;

	rs_rate &= IEEE80211_RATE_VAL;

	rate = rs_rate * 500;	/* ieee80211 rate -> kbps */

	modtype = bwi_rate2modtype(rs_rate);
	if (modtype == IEEE80211_MODTYPE_OFDM) {
		/*
		 * IEEE Std 802.11a-1999, page 37, equation (29)
		 * IEEE Std 802.11g-2003, page 44, equation (42)
		 */
		txtime = IEEE80211_OFDM_TXTIME(rate, len);
		if (ic->ic_curmode == IEEE80211_MODE_11G)
			txtime += IEEE80211_OFDM_SIGNAL_EXT_TIME;
	} else {
		/*
		 * IEEE Std 802.11b-1999, page 28, subclause 18.3.4
		 * IEEE Std 802.11g-2003, page 45, equation (43)
		 */
		if (modtype == IEEE80211_MODTYPE_PBCC)
			++len;
		txtime = IEEE80211_CCK_TXTIME(rate, len);

		/*
		 * Short preamble is not applicable for DS 1Mbits/s
		 */
		if (rs_rate != 2 && (flags & IEEE80211_F_SHPREAMBLE)) {
			txtime += IEEE80211_CCK_SHPREAMBLE_LEN +
				  IEEE80211_CCK_SHPLCP_HDR_TIME;
		} else {
			txtime += IEEE80211_CCK_PREAMBLE_LEN +
				  IEEE80211_CCK_PLCP_HDR_TIME;
		}
	}
	return txtime;
}

int
bwi_encap(struct bwi_softc *sc, int idx, struct mbuf *m,
    struct ieee80211_node *ni)
{
	DPRINTF(2, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	struct ieee80211com *ic = &sc->sc_ic;
	struct bwi_ring_data *rd = &sc->sc_tx_rdata[BWI_TX_DATA_RING];
	struct bwi_txbuf_data *tbd = &sc->sc_tx_bdata[BWI_TX_DATA_RING];
	struct bwi_txbuf *tb = &tbd->tbd_buf[idx];
	struct bwi_mac *mac;
	struct bwi_txbuf_hdr *hdr;
	struct ieee80211_frame *wh;
	uint8_t rate;
	uint32_t mac_ctrl;
	uint16_t phy_ctrl;
	bus_addr_t paddr;
	int pkt_len, error = 0;
#if 0
	const uint8_t *p;
	int i;
#endif

	KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
	mac = (struct bwi_mac *)sc->sc_cur_regwin;

	wh = mtod(m, struct ieee80211_frame *);

	/* Get 802.11 frame len before prepending TX header */
	pkt_len = m->m_pkthdr.len + IEEE80211_CRC_LEN;

	/*
	 * Find TX rate
	 */
	bzero(tb->tb_rate_idx, sizeof(tb->tb_rate_idx));
	if (ni != NULL) {
		if (ic->ic_fixed_rate != -1) {
			rate = ic->ic_sup_rates[ic->ic_curmode].
			    rs_rates[ic->ic_fixed_rate];
		} else {
			/* AMRR rate control */
			rate = ni->ni_rates.rs_rates[ni->ni_txrate];
		}
	} else {
		/* Fixed at 1Mbytes/s for mgt frames */
		rate = (1 * 2);
	}

	rate &= IEEE80211_RATE_VAL;

	if (IEEE80211_IS_MULTICAST(wh->i_addr1))
		rate = (1 * 2);

	if (rate == 0) {
		printf("%s: invalid rate %u or fallback rate",
		    sc->sc_dev.dv_xname, rate);
		rate = (1 * 2); /* Force 1Mbytes/s */
	}
	sc->sc_tx_rate = rate;

#if NBPFILTER > 0
	/* TX radio tap */
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct bwi_tx_radiotap_hdr *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq =
		    htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags =
		    htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	/*
	 * Setup the embedded TX header
	 */
	M_PREPEND(m, sizeof(*hdr), M_DONTWAIT);
	if (m == NULL) {
		printf("%s: prepend TX header failed\n", sc->sc_dev.dv_xname);
		return (ENOBUFS);
	}
	hdr = mtod(m, struct bwi_txbuf_hdr *);

	bzero(hdr, sizeof(*hdr));

	bcopy(wh->i_fc, hdr->txh_fc, sizeof(hdr->txh_fc));
	bcopy(wh->i_addr1, hdr->txh_addr1, sizeof(hdr->txh_addr1));

	if (ni != NULL && !IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		uint16_t dur;
		uint8_t ack_rate;

		ack_rate = bwi_ack_rate(ni, rate);
		dur = bwi_txtime(ic, ni,
		    sizeof(struct ieee80211_frame_ack) + IEEE80211_CRC_LEN,
		    ack_rate, ic->ic_flags & IEEE80211_F_SHPREAMBLE);

		hdr->txh_fb_duration = htole16(dur);
	}

	hdr->txh_id = __SHIFTIN(BWI_TX_DATA_RING, BWI_TXH_ID_RING_MASK) |
	    __SHIFTIN(idx, BWI_TXH_ID_IDX_MASK);

	bwi_plcp_header(hdr->txh_plcp, pkt_len, rate);
	bwi_plcp_header(hdr->txh_fb_plcp, pkt_len, rate);

	phy_ctrl = __SHIFTIN(mac->mac_rf.rf_ant_mode,
	    BWI_TXH_PHY_C_ANTMODE_MASK);
	if (bwi_rate2modtype(rate) == IEEE80211_MODTYPE_OFDM)
		phy_ctrl |= BWI_TXH_PHY_C_OFDM;
	else if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) && rate != (2 * 1))
		phy_ctrl |= BWI_TXH_PHY_C_SHPREAMBLE;

	mac_ctrl = BWI_TXH_MAC_C_HWSEQ | BWI_TXH_MAC_C_FIRST_FRAG;
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1))
		mac_ctrl |= BWI_TXH_MAC_C_ACK;
	if (bwi_rate2modtype(rate) == IEEE80211_MODTYPE_OFDM)
		mac_ctrl |= BWI_TXH_MAC_C_FB_OFDM;

	hdr->txh_mac_ctrl = htole32(mac_ctrl);
	hdr->txh_phy_ctrl = htole16(phy_ctrl);

	/* Catch any further usage */
	hdr = NULL;
	wh = NULL;

	if (sc->sc_bus_space == BWI_BUS_SPACE_30BIT) {
		/* Bounce for 30bit devices. */
		m_copydata(m, 0, m->m_pkthdr.len,
		    sc->sc_bounce_tx_data[BWI_TX_DATA_RING] +
		    (MCLBYTES * idx));
	} else {
		/* DMA load */
		error = bus_dmamap_load_mbuf(sc->sc_dmat, tb->tb_dmap, m,
		    BUS_DMA_NOWAIT);
		if (error && error != EFBIG) {
			printf("%s: can't load TX buffer (1) %d\n",
			    sc->sc_dev.dv_xname, error);
			goto back;
		}

		if (error) {	/* error == EFBIG */
			if (m_defrag(m, M_DONTWAIT)) {
				printf("%s: can't defrag TX buffer\n",
				    sc->sc_dev.dv_xname);
				goto back;
			}
			error = bus_dmamap_load_mbuf(sc->sc_dmat, tb->tb_dmap,
			    m, BUS_DMA_NOWAIT);
			if (error) {
				printf("%s: can't load TX buffer (2) %d\n",
				    sc->sc_dev.dv_xname, error);
				goto back;
			}
		}
		error = 0;
	}

	bus_dmamap_sync(sc->sc_dmat, tb->tb_dmap, 0,
	    tb->tb_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	tb->tb_mbuf = m;
	tb->tb_ni = ni;

#if 0
	p = mtod(m, const uint8_t *);
	for (i = 0; i < m->m_pkthdr.len; ++i) {
		if (i != 0 && i % 8 == 0)
			printf("\n");
		printf("%02x ", p[i]);
	}
	printf("\n");

	DPRINTF(1, "%s: idx %d, pkt_len %d, buflen %d\n",
	    sc->sc_dev.dv_xname, idx, pkt_len, m->m_pkthdr.len);
#endif

	/* Setup TX descriptor */
	paddr = tb->tb_dmap->dm_segs[0].ds_addr;
	sc->sc_setup_txdesc(sc, rd, idx, paddr, m->m_pkthdr.len);
	bus_dmamap_sync(sc->sc_dmat, rd->rdata_dmap, 0,
	    rd->rdata_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	/* Kick start */
	sc->sc_start_tx(sc, rd->rdata_txrx_ctrl, idx);

back:
	if (error)
		m_freem(m);
	return (error);
}

void
bwi_start_tx32(struct bwi_softc *sc, uint32_t tx_ctrl, int idx)
{
	idx = (idx + 1) % BWI_TX_NDESC;
	CSR_WRITE_4(sc, tx_ctrl + BWI_TX32_INDEX,
	    idx * sizeof(struct bwi_desc32));
}

void
bwi_txeof_status32(struct bwi_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t val, ctrl_base;
	int end_idx;

	ctrl_base = sc->sc_txstats->stats_ctrl_base;

	val = CSR_READ_4(sc, ctrl_base + BWI_RX32_STATUS);
	end_idx = __SHIFTOUT(val, BWI_RX32_STATUS_INDEX_MASK) /
	    sizeof(struct bwi_desc32);

	bwi_txeof_status(sc, end_idx);

	CSR_WRITE_4(sc, ctrl_base + BWI_RX32_INDEX,
	    end_idx * sizeof(struct bwi_desc32));

	if (ifq_is_oactive(&ifp->if_snd) == 0)
		ifp->if_start(ifp);
}

void
_bwi_txeof(struct bwi_softc *sc, uint16_t tx_id)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct bwi_txbuf_data *tbd;
	struct bwi_txbuf *tb;
	int ring_idx, buf_idx;

	if (tx_id == 0) {
		printf("%s: zero tx id\n", sc->sc_dev.dv_xname);
		return;
	}

	ring_idx = __SHIFTOUT(tx_id, BWI_TXH_ID_RING_MASK);
	buf_idx = __SHIFTOUT(tx_id, BWI_TXH_ID_IDX_MASK);

	KASSERT(ring_idx == BWI_TX_DATA_RING);
	KASSERT(buf_idx < BWI_TX_NDESC);
#if 0
	DPRINTF(1, "%s: txeof idx %d\n", sc->sc_dev.dv_xname, buf_idx);
#endif
	tbd = &sc->sc_tx_bdata[ring_idx];
	KASSERT(tbd->tbd_used > 0);
	tbd->tbd_used--;

	tb = &tbd->tbd_buf[buf_idx];

	bus_dmamap_unload(sc->sc_dmat, tb->tb_dmap);
	m_freem(tb->tb_mbuf);
	tb->tb_mbuf = NULL;

	if (tb->tb_ni != NULL) {
		ieee80211_release_node(ic, tb->tb_ni);
		tb->tb_ni = NULL;
	}

	if (tbd->tbd_used == 0)
		sc->sc_tx_timer = 0;

	ifq_clr_oactive(&ifp->if_snd);
}

void
bwi_txeof_status(struct bwi_softc *sc, int end_idx)
{
	struct bwi_txstats_data *st = sc->sc_txstats;
	int idx;

	bus_dmamap_sync(sc->sc_dmat, st->stats_dmap, 0,
	    st->stats_dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);

	idx = st->stats_idx;
	while (idx != end_idx) {
		_bwi_txeof(sc, letoh16(st->stats[idx].txs_id));
		idx = (idx + 1) % BWI_TXSTATS_NDESC;
	}
	st->stats_idx = idx;
}

void
bwi_txeof(struct bwi_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	for (;;) {
		uint32_t tx_status0, tx_status1;
		uint16_t tx_id, tx_info;

		tx_status0 = CSR_READ_4(sc, BWI_TXSTATUS_0);
		if (tx_status0 == 0)
			break;
		tx_status1 = CSR_READ_4(sc, BWI_TXSTATUS_1);

		tx_id = __SHIFTOUT(tx_status0, BWI_TXSTATUS_0_TXID_MASK);
		tx_info = BWI_TXSTATUS_0_INFO(tx_status0);

		if (tx_info & 0x30) /* XXX */
			continue;

		_bwi_txeof(sc, letoh16(tx_id));
	}

	if (ifq_is_oactive(&ifp->if_snd) == 0)
		ifp->if_start(ifp);
}

int
bwi_bbp_power_on(struct bwi_softc *sc, enum bwi_clock_mode clk_mode)
{
	bwi_power_on(sc, 1);

	return (bwi_set_clock_mode(sc, clk_mode));
}

void
bwi_bbp_power_off(struct bwi_softc *sc)
{
	bwi_set_clock_mode(sc, BWI_CLOCK_MODE_SLOW);
	bwi_power_off(sc, 1);
}

int
bwi_get_pwron_delay(struct bwi_softc *sc)
{
	struct bwi_regwin *com, *old;
	struct bwi_clock_freq freq;
	uint32_t val;
	int error;

	com = &sc->sc_com_regwin;
	KASSERT(BWI_REGWIN_EXIST(com));

	if ((sc->sc_cap & BWI_CAP_CLKMODE) == 0)
		return (0);

	error = bwi_regwin_switch(sc, com, &old);
	if (error)
		return (error);

	bwi_get_clock_freq(sc, &freq);

	val = CSR_READ_4(sc, BWI_PLL_ON_DELAY);
	sc->sc_pwron_delay = howmany((val + 2) * 1000000, freq.clkfreq_min);
	DPRINTF(1, "%s: power on delay %u\n",
	    sc->sc_dev.dv_xname, sc->sc_pwron_delay);

	return (bwi_regwin_switch(sc, old, NULL));
}

int
bwi_bus_attach(struct bwi_softc *sc)
{
	struct bwi_regwin *bus, *old;
	int error;

	bus = &sc->sc_bus_regwin;

	error = bwi_regwin_switch(sc, bus, &old);
	if (error)
		return (error);

	if (!bwi_regwin_is_enabled(sc, bus))
		bwi_regwin_enable(sc, bus, 0);

	/* Disable interripts */
	CSR_WRITE_4(sc, BWI_INTRVEC, 0);

	return (bwi_regwin_switch(sc, old, NULL));
}

const char *
bwi_regwin_name(const struct bwi_regwin *rw)
{
	switch (rw->rw_type) {
	case BWI_REGWIN_T_COM:
		return ("COM");
	case BWI_REGWIN_T_BUSPCI:
		return ("PCI");
	case BWI_REGWIN_T_MAC:
		return ("MAC");
	case BWI_REGWIN_T_BUSPCIE:
		return ("PCIE");
	}
	panic("unknown regwin type 0x%04x", rw->rw_type);

	return (NULL);
}

uint32_t
bwi_regwin_disable_bits(struct bwi_softc *sc)
{
	uint32_t busrev;

	/* XXX cache this */
	busrev = __SHIFTOUT(CSR_READ_4(sc, BWI_ID_LO), BWI_ID_LO_BUSREV_MASK);
	DPRINTF(1, "%s: bus rev %u\n", sc->sc_dev.dv_xname, busrev);

	if (busrev == BWI_BUSREV_0)
		return (BWI_STATE_LO_DISABLE1);
	else if (busrev == BWI_BUSREV_1)
		return (BWI_STATE_LO_DISABLE2);
	else
		return ((BWI_STATE_LO_DISABLE1 | BWI_STATE_LO_DISABLE2));
}

int
bwi_regwin_is_enabled(struct bwi_softc *sc, struct bwi_regwin *rw)
{
	uint32_t val, disable_bits;

	disable_bits = bwi_regwin_disable_bits(sc);
	val = CSR_READ_4(sc, BWI_STATE_LO);

	if ((val & (BWI_STATE_LO_CLOCK |
	    BWI_STATE_LO_RESET |
	    disable_bits)) == BWI_STATE_LO_CLOCK) {
		DPRINTF(1, "%s: %s is enabled\n",
		    sc->sc_dev.dv_xname, bwi_regwin_name(rw));
		return (1);
	} else {
		DPRINTF(1, "%s: %s is disabled\n",
		    sc->sc_dev.dv_xname, bwi_regwin_name(rw));
		return (0);
	}
}

void
bwi_regwin_disable(struct bwi_softc *sc, struct bwi_regwin *rw, uint32_t flags)
{
	uint32_t state_lo, disable_bits;
	int i;

	state_lo = CSR_READ_4(sc, BWI_STATE_LO);

	/*
	 * If current regwin is in 'reset' state, it was already disabled.
	 */
	if (state_lo & BWI_STATE_LO_RESET) {
		DPRINTF(1, "%s: %s was already disabled\n",
		    sc->sc_dev.dv_xname, bwi_regwin_name(rw));
		return;
	}

	disable_bits = bwi_regwin_disable_bits(sc);

	/*
	 * Disable normal clock
	 */
	state_lo = BWI_STATE_LO_CLOCK | disable_bits;
	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);

	/*
	 * Wait until normal clock is disabled
	 */
#define NRETRY	1000
	for (i = 0; i < NRETRY; ++i) {
		state_lo = CSR_READ_4(sc, BWI_STATE_LO);
		if (state_lo & disable_bits)
			break;
		DELAY(10);
	}
	if (i == NRETRY) {
		printf("%s: %s disable clock timeout\n",
		    sc->sc_dev.dv_xname, bwi_regwin_name(rw));
	}

	for (i = 0; i < NRETRY; ++i) {
		uint32_t state_hi;

		state_hi = CSR_READ_4(sc, BWI_STATE_HI);
		if ((state_hi & BWI_STATE_HI_BUSY) == 0)
			break;
		DELAY(10);
	}
	if (i == NRETRY) {
		printf("%s: %s wait BUSY unset timeout\n",
		    sc->sc_dev.dv_xname, bwi_regwin_name(rw));
	}
#undef NRETRY

	/*
	 * Reset and disable regwin with gated clock
	 */
	state_lo = BWI_STATE_LO_RESET | disable_bits |
	    BWI_STATE_LO_CLOCK | BWI_STATE_LO_GATED_CLOCK |
	    __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);
	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);

	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_STATE_LO);
	DELAY(1);

	/* Reset and disable regwin */
	state_lo = BWI_STATE_LO_RESET | disable_bits |
		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);
	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);

	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_STATE_LO);
	DELAY(1);
}

void
bwi_regwin_enable(struct bwi_softc *sc, struct bwi_regwin *rw, uint32_t flags)
{
	uint32_t state_lo, state_hi, imstate;

	bwi_regwin_disable(sc, rw, flags);

	/* Reset regwin with gated clock */
	state_lo = BWI_STATE_LO_RESET |
	    BWI_STATE_LO_CLOCK |
	    BWI_STATE_LO_GATED_CLOCK |
	    __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);
	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);

	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_STATE_LO);
	DELAY(1);

	state_hi = CSR_READ_4(sc, BWI_STATE_HI);
	if (state_hi & BWI_STATE_HI_SERROR)
		CSR_WRITE_4(sc, BWI_STATE_HI, 0);

	imstate = CSR_READ_4(sc, BWI_IMSTATE);
	if (imstate & (BWI_IMSTATE_INBAND_ERR | BWI_IMSTATE_TIMEOUT)) {
		imstate &= ~(BWI_IMSTATE_INBAND_ERR | BWI_IMSTATE_TIMEOUT);
		CSR_WRITE_4(sc, BWI_IMSTATE, imstate);
	}

	/* Enable regwin with gated clock */
	state_lo = BWI_STATE_LO_CLOCK |
	    BWI_STATE_LO_GATED_CLOCK |
	    __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);
	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);

	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_STATE_LO);
	DELAY(1);

	/* Enable regwin with normal clock */
	state_lo = BWI_STATE_LO_CLOCK |
	    __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);
	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);

	/* Flush pending bus write */
	CSR_READ_4(sc, BWI_STATE_LO);
	DELAY(1);
}

void
bwi_set_bssid(struct bwi_softc *sc, const uint8_t *bssid)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct bwi_mac *mac;
	struct bwi_myaddr_bssid buf;
	const uint8_t *p;
	uint32_t val;
	int n, i;

	KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
	mac = (struct bwi_mac *)sc->sc_cur_regwin;

	bwi_set_addr_filter(sc, BWI_ADDR_FILTER_BSSID, bssid);

	bcopy(ic->ic_myaddr, buf.myaddr, sizeof(buf.myaddr));
	bcopy(bssid, buf.bssid, sizeof(buf.bssid));

	n = sizeof(buf) / sizeof(val);
	p = (const uint8_t *)&buf;
	for (i = 0; i < n; ++i) {
		int j;

		val = 0;
		for (j = 0; j < sizeof(val); ++j)
			val |= ((uint32_t)(*p++)) << (j * 8);

		TMPLT_WRITE_4(mac, 0x20 + (i * sizeof(val)), val);
	}
}

void
bwi_updateslot(struct ieee80211com *ic)
{
	struct bwi_softc *sc = ic->ic_if.if_softc;
	struct bwi_mac *mac;
	struct ifnet *ifp = &ic->ic_if;

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	DPRINTF(2, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
	mac = (struct bwi_mac *)sc->sc_cur_regwin;

	bwi_mac_updateslot(mac, (ic->ic_flags & IEEE80211_F_SHSLOT));
}

void
bwi_calibrate(void *xsc)
{
	struct bwi_softc *sc = xsc;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	s = splnet();

	if (ic->ic_state == IEEE80211_S_RUN) {
		struct bwi_mac *mac;

		KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
		mac = (struct bwi_mac *)sc->sc_cur_regwin;

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			bwi_mac_calibrate_txpower(mac, sc->sc_txpwrcb_type);
			sc->sc_txpwrcb_type = BWI_TXPWR_CALIB;
		}

		/* XXX 15 seconds */
		timeout_add_sec(&sc->sc_calib_ch, 15);
	}

	splx(s);
}

int
bwi_calc_rssi(struct bwi_softc *sc, const struct bwi_rxbuf_hdr *hdr)
{
	struct bwi_mac *mac;

	KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
	mac = (struct bwi_mac *)sc->sc_cur_regwin;

	return (bwi_rf_calc_rssi(mac, hdr));
}
@


1.125
log
@Replace slot time durations with macros.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.124 2017/01/22 10:17:37 dlg Exp $	*/
a41 1
#include <sys/types.h>
@


1.124
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.123 2016/04/13 10:49:26 mpi Exp $	*/
a2443 3
#define IEEE80211_DUR_SLOT	20	/* DS/CCK slottime, ERP long slottime */
#define IEEE80211_DUR_SHSLOT	9	/* ERP short slottime */

d2458 1
a2458 1
		slot_time = IEEE80211_DUR_SHSLOT;
d2460 1
a2460 1
		slot_time = IEEE80211_DUR_SLOT;
@


1.123
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.122 2015/11/25 03:09:58 dlg Exp $	*/
a9154 2

		ifp->if_opackets++;
@


1.122
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.121 2015/11/12 10:25:03 dlg Exp $	*/
a793 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.121
log
@two newlines in the middle of a func doenst look right.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.120 2015/11/11 10:07:25 mpi Exp $	*/
d7091 1
a7091 1
	ifp->if_flags &= ~IFF_OACTIVE;
d7184 1
a7184 1
	if ((ifp->if_flags & IFF_OACTIVE) || (ifp->if_flags & IFF_RUNNING) == 0)
d7267 1
a7267 1
			ifp->if_flags |= IFF_OACTIVE;
d7359 2
a7360 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d9071 1
a9071 1
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
d9115 1
a9115 1
	ifp->if_flags &= ~IFF_OACTIVE;
d9160 1
a9160 1
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
@


1.120
log
@Kill useless IFQ_POLL().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.119 2015/11/04 12:11:59 dlg Exp $	*/
a7210 1

@


1.119
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.118 2015/10/25 12:48:46 mpi Exp $	*/
d7208 1
a7208 1
			IFQ_POLL(&ifp->if_snd, m);
a7211 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.118
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.117 2015/08/29 20:55:34 deraadt Exp $	*/
d7197 1
a7197 1
		IF_POLL(&ic->ic_mgtq, m);
a7198 2
			IF_DEQUEUE(&ic->ic_mgtq, m);

@


1.117
log
@firmware sizes are known; use them for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.116 2015/02/10 23:25:46 mpi Exp $	*/
a7114 1
	struct ifaddr *ifa;
a7122 1
		ifa = (struct ifaddr *)data;
a7123 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.116
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.115 2015/01/10 10:45:46 stsp Exp $	*/
d1655 1
a1655 1
	free(h, M_DEVBUF, 0);
d1835 1
a1835 1
		free(mac->mac_fw, M_DEVBUF, 0);
d7829 1
a7829 1
	free(st, M_DEVBUF, 0);
@


1.115
log
@Remove pointless empty 64bit support code stubs from bwi(4).
It seems no 64bit bus space support is forthcoming. Nothing
has happened in DragonflyBSD for several years and FreeBSD
has a different driver for 64bit chips called bwn(4).
ok mpi@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.114 2015/01/10 10:38:12 stsp Exp $	*/
a8438 1
		m->m_pkthdr.rcvif = ifp;
@


1.114
log
@Merge two bwi(4) fixes from FreeBSD:

------------------------------------------------------------------------
r192306 | imp | 2009-05-18 17:31:26 +0200 (Mon, 18 May 2009) | 10 lines

Fix a typo from the original driver.  We need to write ctrl2 into RF
register 0x52, not ctrl1.  This appears to be a mistake in the bcm
reverse engineering page, and has been corrected there.  Tracing
through the code, this is more in keeping with the "documented"
register. Sephe thinks it looks interesting and may be worth
fixing. :)

Submitted by:	ddkprog at yahoo com
Reviewed by:	Sepherosa Ziehau

------------------------------------------------------------------------
r192042 | nwhitehorn | 2009-05-13 16:25:55 +0200 (Wed, 13 May 2009) | 4 lines

Add a short delay after programming PHY registers to give some time for
the engine to catch up. This prevents a machine check exception from
illegal memory requests with a BCM4318.

------------------------------------------------------------------------

No regressions observed by myself, miod@@, and Vesa Norrman (vesbula at gmail).
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.113 2014/12/22 02:28:51 tedu Exp $	*/
a321 6
int		 bwi_init_tx_ring64(struct bwi_softc *, int);
int		 bwi_init_rx_ring64(struct bwi_softc *);
int		 bwi_init_txstats64(struct bwi_softc *);
void		 bwi_setup_rx_desc64(struct bwi_softc *, int, bus_addr_t, int);
void		 bwi_setup_tx_desc64(struct bwi_softc *, struct bwi_ring_data *,
		     int, bus_addr_t, int);
a329 1
int		 bwi_rxeof64(struct bwi_softc *);
a333 3
void		 bwi_free_txstats64(struct bwi_softc *);
void		 bwi_free_rx_ring64(struct bwi_softc *);
void		 bwi_free_tx_ring64(struct bwi_softc *, int);
a341 1
void		 bwi_start_tx64(struct bwi_softc *, uint32_t, int);
a342 1
void		 bwi_txeof_status64(struct bwi_softc *);
d2418 2
a2419 1
		DPRINTF(1, "%s: 64bit bus space\n", sc->sc_dev.dv_xname);
a7570 19
	case BWI_BUS_SPACE_64BIT:
		desc_sz = sizeof(struct bwi_desc64);
		txrx_ctrl_step = 0x40;

		sc->sc_init_tx_ring = bwi_init_tx_ring64;
		sc->sc_free_tx_ring = bwi_free_tx_ring64;
		sc->sc_init_rx_ring = bwi_init_rx_ring64;
		sc->sc_free_rx_ring = bwi_free_rx_ring64;
		sc->sc_newbuf = bwi_newbuf;
		sc->sc_setup_rxdesc = bwi_setup_rx_desc64;
		sc->sc_setup_txdesc = bwi_setup_tx_desc64;
		sc->sc_rxeof = bwi_rxeof64;
		sc->sc_start_tx = bwi_start_tx64;
		if (has_txstats) {
			sc->sc_init_txstats = bwi_init_txstats64;
			sc->sc_free_txstats = bwi_free_txstats64;
			sc->sc_txeof_status = bwi_txeof_status64;
		}
		break;
a8200 35
bwi_init_tx_ring64(struct bwi_softc *sc, int ring_idx)
{
	/* TODO: 64 */
	return (EOPNOTSUPP);
}

int
bwi_init_rx_ring64(struct bwi_softc *sc)
{
	/* TODO: 64 */
	return (EOPNOTSUPP);
}

int
bwi_init_txstats64(struct bwi_softc *sc)
{
	/* TODO: 64 */
	return (EOPNOTSUPP);
}

void
bwi_setup_rx_desc64(struct bwi_softc *sc, int buf_idx, bus_addr_t paddr,
    int buf_len)
{
	/* TODO: 64 */
}

void
bwi_setup_tx_desc64(struct bwi_softc *sc, struct bwi_ring_data *rd,
    int buf_idx, bus_addr_t paddr, int buf_len)
{
	/* TODO: 64 */
}

int
a8520 7
int
bwi_rxeof64(struct bwi_softc *sc)
{
	/* TODO: 64 */
	return (0);
}

a8633 18
void
bwi_free_txstats64(struct bwi_softc *sc)
{
	/* TODO: 64 */
}

void
bwi_free_rx_ring64(struct bwi_softc *sc)
{
	/* TODO: 64 */
}

void
bwi_free_tx_ring64(struct bwi_softc *sc, int ring_idx)
{
	/* TODO: 64 */
}

a9061 6
bwi_start_tx64(struct bwi_softc *sc, uint32_t tx_ctrl, int idx)
{
	/* TODO: 64 */
}

void
a9080 6
}

void
bwi_txeof_status64(struct bwi_softc *sc)
{
	/* TODO: 64 */
@


1.113
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.112 2014/12/19 22:44:58 guenther Exp $	*/
d3064 1
a3064 1
			RF_FILT_SETBITS(mac, 0x52, 0xfff0, tpctl->tp_ctrl1);
d3354 3
@


1.112
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.111 2014/12/16 18:03:17 miod Exp $	*/
a7133 1
#ifdef INET
a7135 1
#endif
@


1.111
log
@Protect memory allocation and disposal with splvm(); gets rid of splassert
complaints during boot on i386.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.110 2014/09/14 14:17:24 jsg Exp $	*/
d51 1
a53 1
#include <machine/endian.h>
@


1.110
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.109 2014/09/06 05:41:35 jsg Exp $	*/
d912 1
a912 1
	int i;
d921 1
d923 1
d7538 1
d7610 2
d7623 1
d7636 1
d7646 1
d7658 2
@


1.109
log
@reduce the amount of pci includes
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.108 2014/08/03 14:23:59 jsg Exp $	*/
a47 1
#include <sys/proc.h>
@


1.108
log
@When stsp changed bwi_encap() for 30 bit addresses in rev 1.106 code
that used to always initialise the error variable is no longer run.

And at the end of bwi_encap() there is:

	if (error)
		m_freem(m);
	return (error);

Fixing this prevents packet loss stsp was seeing.

ok stsp@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.107 2014/07/22 13:12:11 mpi Exp $	*/
a85 1
#include <dev/pci/pcivar.h>
@


1.107
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.106 2014/07/20 11:59:12 stsp Exp $	*/
d8949 1
a8949 1
	int pkt_len, error;
@


1.106
log
@Always allocate bwi(4) ring descriptors below the 1GB boundary to give 30bit
devices a chance to work. Use bounce buffers for mbufs on 30bit devices.

This fixes "intr fatal TX/RX" errors that render the internal wifi on many
macppc machines unusable. However, packet loss problems remain. In my testing
the device works fine sometimes, but experiences packet loss rates of up
to 80% at other times. Still, this is a step forward.

Helpful hints from claudio@@ and dlg@@
Tested on macppc by mpi@@ and myself
"go ahead" kettenis@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.105 2014/07/20 11:57:49 stsp Exp $	*/
a65 1
#include <netinet/in_systm.h>
@


1.105
log
@In bwi(4), don't declare an interrupt as unhandled in case the PHY TX error
bit is set. This interrupt condition is handled by resetting the device.
ok mpi@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.104 2014/07/20 11:57:05 stsp Exp $	*/
d76 2
d312 1
d331 1
d925 1
d6230 3
d7526 7
d7550 10
d7568 2
d7589 1
d7600 2
a7614 8
		error = bus_dmamap_create(sc->sc_dmat, tx_ring_sz, 1,
		    tx_ring_sz, 0, BUS_DMA_NOWAIT,
		    &sc->sc_tx_rdata[i].rdata_dmap);
		if (error) {
			printf("%s: %dth TX ring DMA create failed\n",
			    sc->sc_dev.dv_xname, i);
			return (error);
		}
d7620 1
a7627 8
	error = bus_dmamap_create(sc->sc_dmat, rx_ring_sz, 1,
	    rx_ring_sz, 0, BUS_DMA_NOWAIT,
	    &sc->sc_rx_rdata.rdata_dmap);
	if (error) {
		printf("%s: RX ring DMA create failed\n", sc->sc_dev.dv_xname);
		return (error);
	}

d7632 1
d7641 1
d7647 8
a7654 1
	return (bwi_dma_mbuf_create(sc));
d7667 4
a7670 4
			bus_dmamap_unload(sc->sc_dmat,
			    rd->rdata_dmap);
			bus_dmamem_free(sc->sc_dmat,
			    &rd->rdata_seg, 1);
d7678 3
a7680 1
		bus_dmamem_free(sc->sc_dmat, &rd->rdata_seg, 1);
d7684 17
a7700 1
	bwi_dma_mbuf_destroy(sc, BWI_TX_NRING, 1);
d7707 1
a7707 1
	int error, nsegs;
d7709 6
a7714 5
	error = bus_dmamem_alloc(sc->sc_dmat, size, BWI_ALIGN, 0,
	    &rd->rdata_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: can't allocate DMA mem\n", sc->sc_dev.dv_xname);
		return (error);
d7717 2
a7718 2
	error = bus_dmamem_map(sc->sc_dmat, &rd->rdata_seg, nsegs,
	    size, (caddr_t *)&rd->rdata_desc, BUS_DMA_NOWAIT);
d7720 3
a7722 1
		printf("%s: can't map DMA mem\n", sc->sc_dev.dv_xname);
d7730 2
a7731 1
		bus_dmamem_free(sc->sc_dmat, &rd->rdata_seg, nsegs);
d7736 1
d7855 120
d8156 1
d8159 1
a8159 1
		error = bwi_newbuf(sc, i, 1);
d8258 52
a8455 1
		m = rb->rb_mbuf;
d8459 13
a8471 1
		if (bwi_newbuf(sc, idx, 0)) {
d9069 7
a9075 15
	/* DMA load */
	error = bus_dmamap_load_mbuf(sc->sc_dmat, tb->tb_dmap, m,
	    BUS_DMA_NOWAIT);
	if (error && error != EFBIG) {
		printf("%s: can't load TX buffer (1) %d\n",
		    sc->sc_dev.dv_xname, error);
		goto back;
	}

	if (error) {	/* error == EFBIG */
		if (m_defrag(m, M_DONTWAIT)) {
			printf("%s: can't defrag TX buffer\n",
			    sc->sc_dev.dv_xname);
			goto back;
		}
d9078 2
a9079 2
		if (error) {
			printf("%s: can't load TX buffer (2) %d\n",
d9083 16
a9099 1
	error = 0;
@


1.104
log
@Make bwi_dma_mbuf_create() use the correct loop counter in error case.
Bug inherited from DragonFly BSD.
ok mpi@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.103 2014/07/20 11:56:15 stsp Exp $	*/
d648 1
a648 1
			return (0);
@


1.103
log
@Load bwi(4) firmware once, not every time the interface is brought up.
Fixes a panic if the interrupt handler decides to reset the device.
Firmware cannot be loaded in interrupt context.
ok mpi@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.102 2014/07/12 18:48:17 tedu Exp $	*/
d7859 1
a7859 1
				    rbd->rbd_buf[j].rb_dmap);
@


1.102
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.101 2014/03/19 10:09:19 mpi Exp $	*/
d1723 8
a1730 5
	error = loadfirmware(name, &mac->mac_fw, &mac->mac_fw_size);
	if (error != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, name);
		return (EIO);
@


1.101
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.100 2013/12/06 21:03:02 deraadt Exp $	*/
d1663 1
a1663 1
	free(h, M_DEVBUF);
d1840 1
a1840 1
		free(mac->mac_fw, M_DEVBUF);
d7801 1
a7801 1
	free(st, M_DEVBUF);
@


1.100
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.99 2013/11/14 12:10:04 dlg Exp $	*/
d7205 1
a7205 2
			ni = (struct ieee80211_node *)m->m_pkthdr.rcvif;
			m->m_pkthdr.rcvif = NULL;
@


1.99
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.98 2013/10/01 20:05:59 sf Exp $	*/
a46 1
#include <sys/task.h>
@


1.98
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.97 2012/12/31 10:07:51 miod Exp $	*/
d47 1
a47 1
#include <sys/workq.h>
@


1.97
log
@Spell `calculation' correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.96 2012/12/05 23:20:16 deraadt Exp $	*/
d1676 1
a1676 1
		printf("%s: invalid firmware (%s): invalid size %u\n",
d1689 1
a1689 1
			    "fw %u, real %u\n",
@


1.96
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.95 2010/08/27 17:08:00 jsg Exp $	*/
d2601 1
a2601 1
	/* NOTE: Use signed value to do calulation */
@


1.95
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.94 2010/08/07 03:50:01 krw Exp $	*/
a40 1
#include <sys/cdefs.h>
@


1.94
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.93 2010/08/06 05:26:24 mglocker Exp $	*/
a800 1
	ifp->if_init = bwi_init;
@


1.93
log
@ACPI suspend/resume for bwi(4).  Initial diff from todd@@, finished and
tested by me on X40 with a BCM4306.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.92 2010/05/19 15:27:35 oga Exp $	*/
d859 1
a859 1
		panic("unknown phymode %d\n", phy->phy_mode);
d2179 1
a2179 1
		panic("unknown PHY mode %u\n", phy->phy_mode);
d2279 1
a2279 1
			panic("unsupported modtype %u\n", modtype);
d4267 1
a4267 1
			panic("unsupported lpd\n");
d4280 1
a4280 1
			panic("unsupported lpd\n");
d4284 1
a4284 1
	panic("never reached\n");
d6532 1
a6532 1
		panic("unknown LED event %d\n", event);
d8547 1
a8547 1
		panic("unsupport modulation type %u\n", modtype);
d8619 1
a8619 1
		panic("unsupported rate %d\n", rate);
d9106 1
a9106 1
	panic("unknown regwin type 0x%04x\n", rw->rw_type);
@


1.92
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.91 2009/09/13 14:42:52 krw Exp $	*/
d48 1
a291 1
int		 bwi_init(struct ifnet *);
a296 1
int		 bwi_stop(struct bwi_softc *, int);
@


1.91
log
@M_DUP_PKTHDR() define -> m_dup_pkthdr() function to properly deal
with m_tag_copy_chain() failures.

Use m_defrag() to eliminate hand rolled defragging of mbufs and
some uses of M_DUP_PKTHDR().

Original diff from thib@@, claudio@@'s feedback integrated by me.

Tests kevlo@@ claudio@@, "reads ok" blambert@@

ok thib@@ claudio@@, "m_defrag() bits ok" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.90 2009/08/02 19:33:01 blambert Exp $	*/
d7723 1
a7723 1
	     &st->stats_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT);
a7746 1
	bzero(st->stats_ring, dma_size);
d7763 1
a7763 1
	    &st->stats_seg, 1, &nsegs, BUS_DMA_NOWAIT);
a7784 1
	bzero(st->stats, dma_size);
@


1.90
log
@timeout_add -> timeout_add_msec

ok mglocker@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.89 2009/07/25 18:49:54 krw Exp $	*/
d8852 1
a8852 8
		struct mbuf *m_new;

		error = 0;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			m_freem(m);
			error = ENOBUFS;
a8856 22

		M_DUP_PKTHDR(m_new, m);
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m_new, M_DONTWAIT);
			if (!(m_new->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(m_new);
				error = ENOBUFS;
			}
		}
		
		if (error) {
			printf("%s: can't defrag TX buffer\n",
			    sc->sc_dev.dv_xname);
			goto back;
		}

		m_copydata(m, 0, m->m_pkthdr.len, mtod(m_new, caddr_t));
		m_freem(m);
		m_new->m_len = m_new->m_pkthdr.len;
		m = m_new;
		
@


1.89
log
@Fix crash in bwi on armish by properly aligning a 32-bit value. Not
to say it works great yet. Might fix bwi on any other alignment
sensitive archs we have.

My original hack generalized and made sane by jsg@@. Didn't affect
operation on my macppc. Problem first noted by ian@@ a long time
ago.

ok jsg@@ (whose tree is currently unavailable to commit from)
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.88 2009/07/19 11:35:38 jsg Exp $	*/
d7432 1
a7432 1
				timeout_add(&sc->sc_amrr_ch, hz / 2);
d7487 1
a7487 1
	timeout_add(&sc->sc_amrr_ch, hz / 2);
@


1.88
log
@Include 0x4402 in the bbp id mapping table used on older
devices.
http://bcm-specs.sipsolutions.net/BackPlane agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.87 2009/06/02 11:54:00 deraadt Exp $	*/
d346 1
a346 2
uint8_t		 bwi_ofdm_plcp2rate(uint32_t *);
uint8_t		 bwi_ds_plcp2rate(struct ieee80211_ds_plcp_hdr *);
d8236 1
a8236 1
		void *plcp;
d8266 1
a8266 1
		plcp = ((uint8_t *)(hdr + 1) + hdr_extra);
d8274 1
a8274 1
			rate = bwi_ofdm_plcp2rate(plcp);
d8276 1
a8276 1
			rate = bwi_ds_plcp2rate(plcp);
d8490 1
a8490 1
bwi_ofdm_plcp2rate(uint32_t *plcp0)
d8492 2
a8493 13
	uint32_t plcp;
	uint8_t plcp_rate;

	plcp = letoh32(*plcp0);
	plcp_rate = __SHIFTOUT(plcp, IEEE80211_OFDM_PLCP_RATE_MASK);

	return (ieee80211_plcp2rate(plcp_rate, IEEE80211_MODE_11G));
}

uint8_t
bwi_ds_plcp2rate(struct ieee80211_ds_plcp_hdr *hdr)
{
	return (ieee80211_plcp2rate(hdr->i_signal, IEEE80211_MODE_11B));
@


1.87
log
@change a sizeof() to nitems() because the array subtype is a short.
change all the N() macros to our favorite new macro nitems()
found by Parfait
ok oga guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.86 2009/05/24 11:27:32 jsg Exp $	*/
d495 1
a495 1
	{ 0x4403, 0x4403, 0x4402 },
@


1.86
log
@declare a variable at the start of bwi_dma_free() instead
of several times throughout the function, in and outside
of a loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.85 2009/01/21 21:53:59 grange Exp $	*/
d2514 1
a2514 2
#define N(arr)	(int)(sizeof(arr) / sizeof(arr[0]))
	for (i = 0; i < N(bwi_sup_macrev); ++i) {
d2518 1
a2518 1
	if (i == N(bwi_sup_macrev)) {
a2522 1
#undef N
d2876 1
a2876 2
#define N(arr)	(int)(sizeof(arr) / sizeof(arr[0]))
		for (i = 0; i < N(bwi_sup_bphy); ++i) {
d2882 1
a2882 1
		if (i == N(bwi_sup_bphy)) {
a2886 1
#undef N
a3428 1
#define N(arr)	(int)(sizeof(arr) / sizeof(arr[0]))
d3445 1
a3445 1
		for (i = 0; i < N(bwi_phy_freq_11g_rev1); ++i) {
d3451 1
a3451 1
		for (i = 0; i < N(bwi_phy_noise_11g_rev1); ++i) {
d3457 1
a3457 1
		for (i = 0; i < N(bwi_phy_rotor_11g_rev1); ++i) {
d3480 1
a3480 1
		for (i = 0; i < sizeof(bwi_phy_noise_11g); ++i) {
d3491 1
a3491 1
		n = N(bwi_phy_noise_scale_11g_rev2);
d3494 1
a3494 1
		n = N(bwi_phy_noise_scale_11g_rev7);
d3497 1
a3497 1
		n = N(bwi_phy_noise_scale_11g);
d3507 1
a3507 1
		n = N(bwi_phy_sigma_sq_11g_rev2);
d3510 1
a3510 1
		n = N(bwi_phy_sigma_sq_11g_rev7);
d3520 1
a3520 1
		for (i = 0; i < N(bwi_phy_delay_11g_rev1); ++i) {
a4702 1
#define N(arr)	(int)(sizeof(arr) / sizeof(arr[0]))
d4710 1
a4710 1
	for (i = 0; i < N(pa_params); ++i)
d4713 1
a4713 1
	for (i = 0; i < N(pa_params); ++i) {
a4740 1
#undef N
d6379 1
a6379 3
#define N(arr) (int)(sizeof(arr) / sizeof(arr[0]))

	for (i = 0; i < N(bwi_vendor_led_act); ++i) {
a6387 2
#undef N

a6585 1
#define N(arr)	(int)(sizeof(arr) / sizeof(arr[0]))
d6618 1
a6618 1
		for (i = 0; i < N(bwi_bbpid_map); ++i) {
d6642 1
a6642 1
		for (i = 0; i < N(bwi_regwin_count); ++i) {
a6722 1
#undef N
@


1.85
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.84 2009/01/07 01:07:03 jsg Exp $	*/
d7652 1
d7656 1
a7656 1
		struct bwi_ring_data *rd = &sc->sc_tx_rdata[i];
d7666 1
a7666 1
	struct bwi_ring_data *rd = &sc->sc_rx_rdata;
@


1.84
log
@declare bwi_modtype enum before it is used in function prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.83 2008/11/26 18:01:43 dlg Exp $	*/
d7455 1
a7455 1
		timeout_add(&sc->sc_scan_ch, (sc->sc_dwell_time * hz) / 1000);
@


1.83
log
@dont have bpf.h expose the kernel ticks variable wherever it is includeing.

it is very confusing like this.

ok deraadt@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.82 2008/10/15 19:12:19 blambert Exp $	*/
d127 7
a582 7

enum bwi_modtype {
	IEEE80211_MODTYPE_DS	= 0,	/* DS/CCK modulation */
	IEEE80211_MODTYPE_PBCC	= 1,	/* PBCC modulation */
	IEEE80211_MODTYPE_OFDM	= 2	/* OFDM modulation */
};
#define IEEE80211_MODTYPE_CCK   IEEE80211_MODTYPE_DS
@


1.82
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.81 2008/08/27 10:03:47 damien Exp $	*/
d101 2
@


1.81
log
@another IEEE80211_RADIOTAP_F_FCS candidate.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.80 2008/08/27 09:14:36 damien Exp $	*/
d7456 1
a7456 1
		timeout_add(&sc->sc_calib_ch, hz);
d9397 1
a9397 1
		timeout_add(&sc->sc_calib_ch, hz * 15);
@


1.80
log
@override net80211's ic_node_alloc function to allocate a full
bwi_node structure (containing the rate control state).
because bwi(4) does not support HostAP or IBSS modes there is
no need to maintain a per-node rate control state, so we could
as well store it in bwi_softc but that will allow for future
improvements.

pointed out by Taylor R Campbell (campbell AT mumble DOT net)
on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.79 2008/08/27 09:05:03 damien Exp $	*/
d8296 1
a8296 1
			tap->wr_flags = 0;
@


1.79
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.78 2008/08/22 19:58:21 deraadt Exp $	*/
d295 2
d882 1
d7518 12
@


1.78
log
@a ; in a bad place; dragonfly; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.77 2008/07/21 18:43:19 damien Exp $	*/
d2110 1
d2117 1
d2138 1
d2141 1
d2146 1
d2149 1
a2759 1
	struct ieee80211com *ic = &sc->sc_ic;
d2765 4
a2768 1
	else if (ic->ic_opmode != IEEE80211_M_HOSTAP)
a2783 1
	struct ieee80211com *ic = &sc->sc_ic;
d2793 4
a2796 1
	else if (ic->ic_opmode != IEEE80211_M_HOSTAP)
d7491 1
d7494 1
@


1.77
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.76 2008/06/11 00:17:17 jsg Exp $	*/
d5636 1
a5636 1
		else if (val > 31);
@


1.76
log
@Don't get the address of the txstats pointers when doing bzero,
just use the actual pointers.

Debugged into the early hours of the morning with todd, without
being able to use a keyboard with ddb. Fixes a panic seen on his
powerbook.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.75 2008/04/16 18:32:15 damien Exp $	*/
d8217 1
d8294 3
a8296 2
		ieee80211_input(ifp, m, ni, hdr->rxh_rssi,
		    letoh16(hdr->rxh_tsf));
@


1.75
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.74 2008/02/25 21:13:30 mglocker Exp $	*/
d7731 1
a7731 1
	bzero(&st->stats_ring, dma_size);
d7770 1
a7770 1
	bzero(&st->stats, dma_size);
@


1.74
log
@Make bwi compile in debug mode again.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.73 2008/02/25 20:36:54 mglocker Exp $	*/
d867 1
d7200 1
d7254 3
a7256 3
		if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
			m = ieee80211_wep_crypt(ifp, m, 1);
			if (m == NULL)
@


1.73
log
@Sync up with DragonFlyBSD driver.  Please read their commit message
for details:

http://leaf.dragonflybsd.org/mailarchive/commits/2008-02/msg00165.html

Tested and OK brad@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.72 2008/02/16 23:17:15 mglocker Exp $	*/
d5970 2
a5971 3
	DPRINTF(mac->mac_sc, BWI_DBG_RF | BWI_DBG_RX,
		"lna_gain %d, phyinfo 0x%04x\n",
		lna_gain, le16toh(hdr->rxh_phyinfo));
d6655 1
a6655 1
	DPRINTF("%s: BBP id 0x%04x, BBP rev 0x%x, BBP pkg %d\n",
@


1.72
log
@Zap KKASSERT porting macro and use KASSERT instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.71 2008/02/16 22:06:44 mglocker Exp $	*/
d173 2
a174 1
void		 bwi_mac_calibrate_txpower(struct bwi_mac *);
d286 3
a288 1
int		 bwi_stop(struct bwi_softc *);
d586 1
d609 3
d643 8
a650 2
	if (intr_status & BWI_INTR_PHY_TXERR)
		printf("%s: intr PHY TX error\n", sc->sc_dev.dv_xname);
d656 2
a657 4
	if (intr_status & BWI_INTR_TBTT) {
		KASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
		bwi_mac_config_ps((struct bwi_mac *)sc->sc_cur_regwin);
	}
d912 1
a912 1
	bwi_stop(sc);
d2520 2
d2642 1
a2642 1
bwi_mac_calibrate_txpower(struct bwi_mac *mac)
d2670 9
a2678 2
		if (mac->mac_phy.phy_mode == IEEE80211_MODE_11B)
			return;
d2684 7
a2690 1
			return;
d2724 10
a2733 2
	bbp_atten_adj = -(txpwr_diff / 2) -
	    (BWI_RF_ATTEN_FACTOR * rf_atten_adj);
d2742 1
d7013 9
d7023 1
d7029 1
a7029 1
	error = bwi_stop(sc);
d7032 1
a7032 1
		return (1);
d7094 10
a7103 6
	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		/* start background scanning */
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	else
		/* in monitor mode change directly into run state */
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
d7106 3
a7108 3
		bwi_stop(sc);

	return (0);
d7138 1
a7138 1
				bwi_stop(sc);
d7312 12
d7325 1
a7325 1
bwi_stop(struct bwi_softc *sc)
d7334 4
a7337 1
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
a7387 2
	timeout_del(&sc->sc_scan_ch);
	timeout_del(&sc->sc_calib_ch);
d7389 1
a7389 1
	bwi_led_newstate(sc, nstate);
d7416 6
a7421 2
		bwi_mac_calibrate_txpower(mac);

d7442 1
a7442 1
		timeout_add(&sc->sc_calib_ch, hz * 15);
d8803 1
a8803 1
		    ack_rate, ic->ic_flags & ~IEEE80211_F_SHPREAMBLE);
d9361 4
a9364 2
		if (ic->ic_opmode != IEEE80211_M_MONITOR)
			bwi_mac_calibrate_txpower(mac);
@


1.71
log
@Count output packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.70 2008/02/16 20:09:05 mglocker Exp $	*/
a84 4
#define KKASSERT(cond) if (!(cond)) panic("KKASSERT: %s in %s", #cond, __func__)
#undef KASSERT
#define KASSERT(cond, complaint) if (!(cond)) panic complaint

d644 1
a644 1
		KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
d1305 2
a1306 2
		KKASSERT(new_tpctl->bbp_atten <= BWI_BBP_ATTEN_MAX);
		KKASSERT(new_tpctl->rf_atten <=
d1309 1
a1309 1
		KKASSERT(new_tpctl->tp_ctrl1 <= BWI_TPCTL1_MAX);
d1558 1
a1558 1
	KKASSERT(phy->phy_mode != IEEE80211_MODE_11A);
d2463 1
a2463 1
	KKASSERT(sc->sc_nmac <= BWI_MAC_MAX && sc->sc_nmac >= 0);
d2558 1
a2558 1
	KKASSERT(rf_atten >= 0 && rf_atten <= BWI_RF_ATTEN_MAX0);
d2720 1
a2720 1
	KKASSERT((mac->mac_flags & BWI_MAC_F_LOCKED) == 0);
d2742 1
a2742 1
	KKASSERT(mac->mac_flags & BWI_MAC_F_LOCKED);
d2912 1
a2912 1
	KKASSERT(phy->phy_tbl_ctrl != 0 && phy->phy_tbl_data_lo != 0);
d2922 1
a2922 1
	KKASSERT(phy->phy_tbl_data_lo != 0 && phy->phy_tbl_data_hi != 0 &&
d3044 1
a3044 1
			KKASSERT(rf->rf_nrssi[1] == BWI_INVALID_NRSSI);
d3047 1
a3047 1
			KKASSERT(rf->rf_nrssi[1] != BWI_INVALID_NRSSI);
d3679 1
a3679 1
	KKASSERT(n < BWI_RFLO_MAX);
d3691 1
a3691 1
	KKASSERT(idx >= 0 && idx < BWI_RFLO_MAX);
d4111 1
a4111 1
		KKASSERT(rf_atten < MAP_MAX);
d4520 1
a4520 1
	KKASSERT(idx < (int)(sizeof(rf_calibvals) / sizeof(rf_calibvals[0])));
d5083 1
a5083 1
		KKASSERT(i <= LO_ADJUST_MAX && i >= LO_ADJUST_MIN);
d5087 1
a5087 1
		KKASSERT(fin <= LO_ADJUST_MAX && fin >= LO_ADJUST_MIN);
d5781 1
a5781 1
	KKASSERT(ant_mode == BWI_ANT_MODE_0 ||
d6671 1
a6671 1
	KKASSERT(sc->sc_nmac > 0);
d6696 1
a6696 1
	KKASSERT(sc->sc_cur_regwin == &mac->mac_regwin);
d6826 3
a6828 3
	KKASSERT(BWI_REGWIN_EXIST(com));
	KKASSERT(sc->sc_cur_regwin == com);
	KKASSERT(sc->sc_cap & BWI_CAP_CLKMODE);
d6864 2
a6865 2
	KKASSERT(src >= 0 && src < BWI_CLKSRC_MAX);
	KKASSERT(div != 0);
d7276 1
a7276 1
		KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
d7350 1
a7350 1
		KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
d7494 2
a7495 2
	KKASSERT(desc_sz != 0);
	KKASSERT(txrx_ctrl_step != 0);
d7854 1
a7854 1
	KKASSERT(ring_idx < BWI_TX_NRING);
d7961 1
a7961 1
	KKASSERT(buf_idx < BWI_RX_NDESC);
d7970 1
a7970 1
	KKASSERT(buf_idx < BWI_TX_NDESC);
d8021 1
a8021 1
	KKASSERT(buf_idx < BWI_RX_NDESC);
d8112 1
a8112 1
	KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
d8333 1
a8333 1
	KKASSERT(ring_idx < BWI_TX_NRING);
d8655 1
a8655 1
	KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
d8915 2
a8916 2
	KKASSERT(ring_idx == BWI_TX_DATA_RING);
	KKASSERT(buf_idx < BWI_TX_NDESC);
d8921 1
a8921 1
	KKASSERT(tbd->tbd_used > 0);
d9011 1
a9011 1
	KKASSERT(BWI_REGWIN_EXIST(com));
d9241 1
a9241 1
	KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
d9274 1
a9274 1
	KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
d9292 1
a9292 1
		KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
d9310 1
a9310 1
	KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
@


1.70
log
@Replace bwi_rate2plcp() with ieee80211_rate2plcp().
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.69 2008/02/16 17:52:28 mglocker Exp $	*/
d8983 2
@


1.69
log
@Fix spacing / comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.68 2008/02/16 17:29:21 mglocker Exp $	*/
a335 1
uint8_t		 bwi_rate2plcp(uint8_t); /* XXX belongs to 802.11 */
d2253 2
d2258 2
a2263 1
		ofs += (bwi_rate2plcp(rs->rs_rates[i]) & 0xf) * 2;
d2266 1
a2266 1
			     MOBJ_READ_2(mac, BWI_COMM_MOBJ, ofs));
a8407 27
/* XXX does not belong here */
uint8_t
bwi_rate2plcp(uint8_t rate)
{
	rate &= IEEE80211_RATE_VAL;

	switch (rate) {
	case 2:		return (0xa);
	case 4:		return (0x14);
	case 11:	return (0x37);
	case 22:	return (0x6e);
	case 44:	return (0xdc);

	case 12:	return (0xb);
	case 18:	return (0xf);
	case 24:	return (0xa);
	case 36:	return (0xe);
	case 48:	return (0x9);
	case 72:	return (0xd);
	case 96:	return (0x8);
	case 108:	return (0xc);

	default:
		panic("unsupported rate %u\n", rate);
	}
}

d8431 2
a8432 1
	plcp = __SHIFTIN(bwi_rate2plcp(rate), IEEE80211_OFDM_PLCP_RATE_MASK) |
d8459 1
a8459 1
	plcp->i_signal = bwi_rate2plcp(rate);
@


1.68
log
@While importing the driver a lot of printf's have been converted to
DPRINTF's by mistake.  Fix this so we can see fatal errors without beeing
in DEBUG mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.67 2008/02/16 16:45:28 mglocker Exp $	*/
d129 1
d152 1
a152 1
		    size_t fw_len, char *, uint8_t);
d181 2
d202 2
a229 1

a235 1

d260 1
d918 2
d2772 1
a2772 1
/* BWIPHY */
d3659 1
a3659 1
/* BWIRF */
d6171 1
a6171 1
/* IF_BWI */
d8463 1
a8463 1
		   uint8_t rate)
@


1.67
log
@Report rssi and rate in rx radio tap.

From the DragonFlyBSD driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.66 2008/02/16 14:56:00 mglocker Exp $	*/
d620 1
a620 1
			DPRINTF(1, "%s: intr fatal TX/RX (%d) error 0x%08x\n",
d638 1
a638 1
		DPRINTF(1, "%s: intr PHY TX error\n", sc->sc_dev.dv_xname);
d650 1
a650 1
		DPRINTF(1, "%s: EO_ATIM\n", sc->sc_dev.dv_xname);
d661 1
a661 1
		DPRINTF(1, "%s: intr noise\n", sc->sc_dev.dv_xname);
d837 1
a837 1
				DPRINTF(1, "%s: invalid MAC address: %s\n",
d1225 1
a1225 2
		DPRINTF(1, "%s: can't initialize RX ring\n",
		    sc->sc_dev.dv_xname);
d1235 1
a1235 1
			DPRINTF(1, "%s: can't initialize TX stats ring\n",
d1349 1
a1349 1
		DPRINTF(1, "%s: TEST1 failed\n", sc->sc_dev.dv_xname);
d1357 1
a1357 1
		DPRINTF(1, "%s: TEST2 failed\n", sc->sc_dev.dv_xname);
d1366 1
a1366 1
		DPRINTF(1, "%s: %s failed, MAC status 0x%08x\n",
d1373 1
a1373 1
		DPRINTF(1, "%s: %s failed, intr status %08x\n",
d1764 1
a1764 1
			DPRINTF(1, "%s: no suitable IV for MAC rev %d\n",
d1886 1
a1886 1
		DPRINTF(1, "%s: firmware (fw & pcm) loading timed out\n",
d1897 1
a1897 1
		DPRINTF(1, "%s: firmware version 4 is not supported yet\n",
d2299 1
a2299 1
		DPRINTF(1, "%s: can't stop MAC\n", sc->sc_dev.dv_xname);
d2333 1
a2333 2
			DPRINTF(1, "%s: config PS failed\n",
			    sc->sc_dev.dv_xname);
d2462 1
a2462 1
		DPRINTF(1, "%s: too many MACs\n", sc->sc_dev.dv_xname);
d2493 1
a2493 1
		DPRINTF(1, "%s: MAC rev %u is not supported\n",
d2812 1
a2812 1
			DPRINTF(1, "%s: unsupported 11A PHY, rev %u\n",
d2831 1
a2831 1
			DPRINTF(1, "%s: unsupported 11B PHY, rev %u\n",
d2840 1
a2840 1
			DPRINTF(1, "%s: unsupported 11G PHY, rev %u\n",
d2851 1
a2851 1
		DPRINTF(1, "%s: unsupported PHY type %d\n",
d3067 1
a3067 1
	DPRINTF(1, "%s: %s is not implemented yet\n",
d3771 1
a3771 1
			DPRINTF(1, "%s: only BCM2060 rev 1 RF is supported for "
d3788 1
a3788 1
			DPRINTF(1, "%s: only BCM2050/BCM2053 RF is supported "
d3803 1
a3803 1
			DPRINTF(1, "%s: only BCM2050 RF is supported for 11G "
d3819 1
a3819 1
		DPRINTF(1, "%s: unsupported PHY mode\n", sc->sc_dev.dv_xname);
d4065 1
a4065 1
		DPRINTF(1, "%s: %s invalid channel!\n",
d4602 1
a4602 1
		DPRINTF(1, "%s: invalid max txpower in sprom\n",
d4620 1
d4723 1
a4723 1
			DPRINTF(1, "%s: bwi_rf_calc_txpower failed\n",
d6280 1
a6280 1
			DPRINTF(1, "%s: can't select regwin %d\n",
d6555 1
a6555 1
		DPRINTF(1, "%s: can't select regwin 0\n", sc->sc_dev.dv_xname);
d6584 1
a6584 1
			DPRINTF(1, "%s: no BBP id for device id 0x%04x\n",
d6607 1
a6607 1
			DPRINTF(1, "%s: no number of win for BBP id 0x%04x\n",
d6617 1
a6617 1
	DPRINTF(1, "%s: BBP id 0x%04x, BBP rev 0x%x, BBP pkg %d\n",
d6635 1
a6635 1
			DPRINTF(1, "%s: can't select regwin %d\n",
d6650 1
a6650 1
				DPRINTF(1, "%s: bus regwin already exists\n",
d6664 1
a6664 1
		DPRINTF(1, "%s: no MAC was found\n", sc->sc_dev.dv_xname);
d6671 1
a6671 2
		DPRINTF(1, "%s: no bus regwin was found\n",
		    sc->sc_dev.dv_xname);
d7026 1
a7026 1
			DPRINTF(1, "%s: can't drain TX status\n",
d7248 1
a7248 1
			DPRINTF(1, "%s: watchdog timeout\n",
d7331 1
a7331 1
		DPRINTF(1, "%s: can't set channel to %u\n",
d7505 1
a7505 1
			DPRINTF(1, "%s: %dth TX ring DMA create failed\n",
d7512 1
a7512 1
			DPRINTF(1, "%s: %dth TX ring DMA alloc failed\n",
d7525 1
a7525 2
		DPRINTF(1, "%s: RX ring DMA create failed\n",
		    sc->sc_dev.dv_xname);
d7532 1
a7532 2
		DPRINTF(1, "%s: RX ring DMA alloc failed\n",
		    sc->sc_dev.dv_xname);
d7539 1
a7539 1
			DPRINTF(1, "%s: TX stats DMA alloc failed\n",
d7585 1
a7585 1
		DPRINTF(1, "%s: can't allocate DMA mem\n", sc->sc_dev.dv_xname);
d7592 1
a7592 1
		DPRINTF(1, "%s: can't map DMA mem\n", sc->sc_dev.dv_xname);
d7599 1
a7599 1
		DPRINTF(1, "%s: can't load DMA mem\n", sc->sc_dev.dv_xname);
d7630 1
a7630 1
		DPRINTF(1, "%s: can't create txstats ring DMA mem\n",
d7638 1
a7638 1
		DPRINTF(1, "%s: can't allocate txstats ring DMA mem\n",
d7646 1
a7646 1
		DPRINTF(1, "%s: can't map txstats ring DMA mem\n",
d7654 1
a7654 1
		DPRINTF(1, "%s: can't load txstats ring DMA mem\n",
d7672 1
a7672 1
		DPRINTF(1, "%s: can't create txstats ring DMA mem\n",
d7679 1
a7679 1
		DPRINTF(1, "%s: can't allocate txstats DMA mem\n",
d7687 1
a7687 2
		DPRINTF(1, "%s: can't map txstats DMA mem\n",
		    sc->sc_dev.dv_xname);
d7694 1
a7694 2
		DPRINTF(1, "%s: can't load txstats DMA mem\n",
		    sc->sc_dev.dv_xname);
d7742 1
a7742 1
				DPRINTF(1,
d7762 1
a7762 1
		DPRINTF(1, "%s: can't create spare RX buf DMA map\n",
d7771 1
a7771 1
			DPRINTF(1, "%s: can't create %dth RX buf DMA map\n",
d7910 1
a7910 1
			DPRINTF(1, "%s: can't allocate %dth RX buffer\n",
d8171 1
a8171 1
			DPRINTF(1, "%s: zero length data, hdr_extra %d\n",
d8288 1
a8288 1
		DPRINTF(1, "%s: reset rx ring timedout\n", sc->sc_dev.dv_xname);
d8345 1
a8345 1
		DPRINTF(1, "%s: wait for TX ring(%d) stable timed out\n",
d8359 1
a8359 1
		DPRINTF(1, "%s: reset TX ring (%d) timed out\n",
d8708 1
a8708 1
		DPRINTF(1, "%s: invalid rate %u or fallback rate",
d8742 1
a8742 2
		DPRINTF(1, "%s: prepend TX header failed\n",
		    sc->sc_dev.dv_xname);
d8794 1
a8794 1
		DPRINTF(1, "%s: can't load TX buffer (1) %d\n",
d8837 1
a8837 1
			DPRINTF(1, "%s: can't load TX buffer (2) %d\n",
d8930 1
a8930 1
		DPRINTF(1, "%s: zero tx id\n", sc->sc_dev.dv_xname);
d9163 1
a9163 1
		DPRINTF(1, "%s: %s disable clock timeout\n",
d9176 1
a9176 1
		DPRINTF(1, "%s: %s wait BUSY unset timeout\n",
@


1.66
log
@Better support for 11b mode.

From the DragonFlyBSD driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.65 2008/02/16 12:36:07 mglocker Exp $	*/
d248 6
d362 2
d3780 1
d3785 1
d3788 1
d3817 1
d5889 135
d8156 1
a8156 1
		int buflen, wh_ofs, hdr_extra, type, rate;
d8185 1
a8201 1
			/* TODO: calculate rate and signal */
d8204 1
a8204 1
			tap->wr_rate = 0;
d8209 2
a8210 2
			tap->wr_antsignal = 0;
			tap->wr_antnoise = 0;
d9330 11
@


1.65
log
@Remove some double prototype definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.64 2008/02/16 10:09:23 mglocker Exp $	*/
d212 1
a212 1
void		 bwi_rf_work_around(struct bwi_mac *, uint);
d225 2
a226 1
void		 bwi_rf_lo_update(struct bwi_mac *);
d229 2
a230 2
uint8_t		 _bwi_rf_lo_update(struct bwi_mac *, uint16_t);
void		 bwi_rf_lo_measure(struct bwi_mac *,
d232 1
d248 3
d419 3
d424 1
d3068 53
a3120 1
	struct bwi_softc *sc;
d3122 3
a3124 1
	sc = mac->mac_sc;
d3126 6
a3131 3
	/* TODO: 11B */
	DPRINTF(1, "%s: %s is not implemented yet\n",
	    sc->sc_dev.dv_xname, __func__);
d3718 1
d3760 1
a3760 1
	switch (mac->mac_phy.phy_mode) {
d3787 4
d3806 1
d3835 1
a3835 1
		bwi_rf_work_around(mac, chan);
d4049 1
a4049 1
bwi_rf_work_around(struct bwi_mac *mac, uint chan)
d4469 1
a4469 1
	bwi_rf_work_around(mac, rf->rf_curchan);
d4729 1
a4729 1
bwi_rf_lo_update(struct bwi_mac *mac)
d4741 2
d4810 1
a4810 1
	devi_ctrl = _bwi_rf_lo_update(mac, regs.rf_7a);
d4925 1
a4925 1
_bwi_rf_lo_update(struct bwi_mac *mac, uint16_t orig_rf7a)
d5011 1
a5011 1
			bwi_rf_lo_measure(mac, &lo_save, lo, devi_ctrl);
d5022 1
a5022 1
bwi_rf_lo_measure(struct bwi_mac *mac, const struct bwi_rf_lo *src_lo,
d5195 1
a5195 1
	bwi_rf_work_around(mac, rf->rf_curchan);
d5532 1
a5532 1
	bwi_rf_work_around(mac, rf->rf_curchan);
d5875 142
@


1.64
log
@Always print device name in front of debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.63 2007/11/17 16:50:02 mglocker Exp $	*/
a233 10
void		 bwi_rf_off_11a(struct bwi_mac *);
void		 bwi_rf_off_11bg(struct bwi_mac *);
void		 bwi_rf_off_11g_rev5(struct bwi_mac *);
int		 bwi_rf_attach(struct bwi_mac *);
int		 bwi_rf_map_txpower(struct bwi_mac *);
void		 bwi_rf_lo_adjust(struct bwi_mac *, const struct bwi_tpctl *);
void		 bwi_rf_set_chan(struct bwi_mac *, uint, int);
void		 bwi_rf_get_gains(struct bwi_mac *);
void		 bwi_rf_init(struct bwi_mac *);
void		 bwi_rf_init_bcm2050(struct bwi_mac *);
@


1.63
log
@- Add more LED support, like activity blinking (though just supporting
some devices yet).
- Calculate RX rate which can be used later in bpf_mtap().

Diff ported from DragonFlyBSD, tested by some.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.62 2007/10/18 05:56:15 mglocker Exp $	*/
d704 2
d1218 2
a1219 1
		DPRINTF(1, "can't initialize RX ring\n");
d2226 4
a2229 1
	DPRINTF(1, "%s\n", __func__);
d2231 1
a2231 1
	int i;
d2428 2
a2429 1
	DPRINTF(1, "%s\n", __func__);
d2431 3
a2433 1
	uint16_t slot_time;
d2444 1
a2444 1
		    slot_time + BWI_MAC_SLOTTIME_ADJUST);
d3993 1
a3993 1
		DPRINTF(1, "%s: %s invalid channel!!\n",
d5854 1
a5854 1
	DPRINTF(1, "%s\n", __func__);
d5894 1
a5894 1
	DPRINTF(1, "%s\n", __func__);
d6029 3
a6031 2
		DPRINTF(1, "%dth led, act %d, lowact %d\n",
		    i, led->l_act, led->l_flags & BWI_LED_F_ACTLOW);
d6627 1
a6627 1
	DPRINTF(1, "%s\n", __func__);
d6916 1
a6916 1
	DPRINTF(1, "%s\n", __func__);
d7071 1
a7071 1
	DPRINTF(1, "%s\n", __func__);
d8311 1
a8311 1
	DPRINTF(2, "%s\n", __func__);
d8946 1
a8946 1
	DPRINTF(2, "%s\n", __func__);
@


1.62
log
@Add some first LEDs support.  Tested on my cardbus Linksys WPC54G Ver 3.

Diff ported from DragonFlyBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.61 2007/10/04 05:44:42 mglocker Exp $	*/
d93 4
d267 5
d321 3
a323 3
void		 bwi_rxeof(struct bwi_softc *, int);
void		 bwi_rxeof32(struct bwi_softc *);
void		 bwi_rxeof64(struct bwi_softc *);
d332 2
d514 47
d580 1
a580 1
	int i, txrx_error;
d657 1
a657 1
		sc->sc_rxeof(sc);
d659 1
a659 1
	if (txrx_intr_status[3] & BWI_TXRX_INTR_RX)
d661 2
d664 1
a664 1
	if (intr_status & BWI_INTR_TX_DONE)
d666 2
a667 2

	/* TODO: LED */
d672 20
d704 4
d5967 1
a5967 7
	const static uint8_t led_default_act[BWI_LED_MAX] = {
		BWI_LED_ACT_ACTIVE,
		BWI_LED_ACT_2GHZ,
		BWI_LED_ACT_5GHZ,
		BWI_LED_ACT_OFF
	};

d5971 13
d5996 1
a5996 3
			led->l_act = led_default_act[i];
			if (i == 0 && sc->sc_pci_subvid == PCI_VENDOR_COMPAQ)
				led->l_act = BWI_LED_ACT_RFEN;
d6002 17
d6020 1
a6020 1
		DPRINTF("%dth led, act %d, lowact %d\n",
d6023 15
d6047 6
d6062 5
a6066 2
		    led->l_act == BWI_LED_ACT_NULL) {
			/* Don't touch it */
a6067 1
		}
a6074 2
		case BWI_LED_ACT_MID:	/* Blinking ones */
		case BWI_LED_ACT_FAST:
d6089 1
a6089 2
				if (led->l_act == BWI_LED_ACT_RUN ||
				    led->l_act == BWI_LED_ACT_ACTIVE)
d6096 39
a6134 2
		if (led->l_flags & BWI_LED_F_ACTLOW)
			on = !on;
d6136 13
a6148 4
		if (on)
			val |= (1 << i);
		else
			val &= ~(1 << i);
d6150 15
d6166 10
d7775 1
a7775 1
void
d7782 1
a7782 1
	int idx;
d7791 1
a7791 1
		uint8_t plcp_signal;
d7793 1
a7793 1
		int buflen, wh_ofs, hdr_extra;
d7821 1
a7821 1
		plcp_signal = *((uint8_t *)(hdr + 1) + hdr_extra);
d7827 5
d7863 1
d7869 5
d7881 2
d7885 1
a7885 1
void
d7889 1
a7889 1
	int end_idx;
d7897 1
a7897 1
	bwi_rxeof(sc, end_idx);
d7901 2
d7905 1
a7905 1
void
d7909 1
d8070 18
a8090 4
/* XXX does not belong here */
#define IEEE80211_OFDM_PLCP_SIG_MASK	0x0000000f
#define IEEE80211_OFDM_PLCP_LEN_MASK	0x0001ffe0

d8093 1
a8093 1
	plcp = __SHIFTIN(bwi_rate2plcp(rate), IEEE80211_OFDM_PLCP_SIG_MASK) |
d8355 1
@


1.61
log
@Since we know the firmware load works, merge the single firmware files
together to one single, finally.

You need to bump the firmware package to version 1.3!

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.60 2007/10/01 20:48:37 mglocker Exp $	*/
d261 2
d662 1
a662 1
	/* TODO: LED */
d5880 101
d6764 2
@


1.60
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.59 2007/10/01 19:48:10 mglocker Exp $	*/
d1610 2
d1615 7
d1626 2
a1627 2
		error = loadfirmware(fwname, &mac->mac_ucode,
		    &mac->mac_ucode_size);
d1633 1
d1646 2
a1647 2
		error = loadfirmware(fwname, &mac->mac_pcm,
		    &mac->mac_pcm_size);
d1653 1
d1676 2
a1677 2
		error = loadfirmware(fwname, &mac->mac_iv,
		    &mac->mac_iv_size);
d1683 1
d1708 2
a1709 2
		error = loadfirmware(fwname, &mac->mac_iv_ext,
		    &mac->mac_iv_ext_size);
d1715 1
d1731 3
a1733 18
	if (mac->mac_ucode != NULL) {
		free(mac->mac_ucode, M_DEVBUF);
		mac->mac_ucode = NULL;
	}

	if (mac->mac_pcm != NULL) {
		free(mac->mac_pcm, M_DEVBUF);
		mac->mac_pcm = NULL;
	}

	if (mac->mac_iv != NULL) {
		free(mac->mac_iv, M_DEVBUF);
		mac->mac_iv = NULL;
	}

	if (mac->mac_iv_ext != NULL) {
		free(mac->mac_iv_ext, M_DEVBUF);
		mac->mac_iv_ext = NULL;
@


1.59
log
@Fix `bogus xmit rate setup' panic, which mostly happened while associating
to an 11b AP due to not correct initialized tx rates.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.58 2007/10/01 14:37:51 jsg Exp $	*/
d6708 1
a6708 2
		timeout_add(&sc->sc_scan_ch,
			      (sc->sc_dwell_time * hz) / 1000);
@


1.58
log
@remove rate_fb variable as it always gets set to the same value
as rate anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.57 2007/10/01 12:58:41 jsg Exp $	*/
d6656 1
d6681 2
d6690 11
a6712 6

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			/* start automatic rate control timer */
			if (ic->ic_fixed_rate == -1)
				timeout_add(&sc->sc_amrr_ch, hz / 2);
		}
d6768 2
a6769 1
	    i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72; i--);
@


1.57
log
@Print the MAC address.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.56 2007/10/01 12:44:33 jsg Exp $	*/
d7972 1
a7972 1
	uint8_t rate, rate_fb;
d8000 1
a8000 1
			rate = rate_fb = ni->ni_rates.rs_rates[ni->ni_txrate];
d8004 1
a8004 1
		rate = rate_fb = (1 * 2);
d8010 1
a8010 1
		rate = rate_fb = (1 * 2);
d8012 4
a8015 4
	if (rate == 0 || rate_fb == 0) {
		DPRINTF(1, "%s: invalid rate %u or fallback rate %u",
		    sc->sc_dev.dv_xname, rate, rate_fb);
		rate = rate_fb = (1 * 2); /* Force 1Mbytes/s */
d8061 1
a8061 1
		ack_rate = bwi_ack_rate(ni, rate_fb);
d8073 1
a8073 1
	bwi_plcp_header(hdr->txh_fb_plcp, pkt_len, rate_fb);
d8085 1
a8085 1
	if (bwi_rate2modtype(rate_fb) == IEEE80211_MODTYPE_OFDM)
@


1.56
log
@Disable default debug setting, make tx power map printing debug only.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.55 2007/10/01 11:27:11 mglocker Exp $	*/
a621 2
	printf("\n");

d753 2
@


1.55
log
@Use uint_* consistent.

Agreed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.54 2007/09/30 22:28:45 mglocker Exp $	*/
a76 2
#define BWI_DEBUG

d4562 2
a4563 2
			printf("\n");
		printf("%d ", rf->rf_txpower_map0[i]);
d4565 1
a4565 1
	printf("\n");
@


1.54
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.53 2007/09/30 22:12:43 mglocker Exp $	*/
d115 2
a116 2
	u_int		clkfreq_min;
	u_int		clkfreq_max;
d204 1
a204 1
void		 bwi_rf_set_chan(struct bwi_mac *, u_int, int);
d210 1
a210 1
void		 bwi_rf_work_around(struct bwi_mac *, u_int);
d238 1
a238 1
void		 bwi_rf_set_chan(struct bwi_mac *, u_int, int);
d310 1
a310 1
int		 bwi_set_chan(struct bwi_softc *, u_int8_t);
d350 5
a354 4
u_int8_t	 bwi_ack_rate(struct ieee80211_node *, u_int8_t);
u_int16_t	 bwi_txtime(struct ieee80211com *, struct ieee80211_node *,
		     u_int, u_int8_t, uint32_t);
enum bwi_modtype	 bwi_rate2modtype(u_int8_t);
d493 2
a494 2
	u_int	freq_min;
	u_int	freq_max;
d2993 1
a2993 1
	u_int orig_chan;
d3095 1
a3095 1
	u_int orig_chan;
d3670 1
a3670 1
bwi_rf_set_chan(struct bwi_mac *mac, u_int chan, int work_around)
d3896 1
a3896 1
bwi_rf_work_around(struct bwi_mac *mac, u_int chan)
d4586 1
a4586 1
	u_int orig_chan;
d6159 1
a6159 1
	u_int div;
d7441 1
a7441 1
bwi_set_chan(struct bwi_softc *sc, u_int8_t chan)
d7809 1
a7809 1
bwi_rate2modtype(u_int8_t rate)
d7821 2
a7822 2
u_int8_t
bwi_ack_rate(struct ieee80211_node *ni, u_int8_t rate)
d7825 1
a7825 1
	u_int8_t ack_rate = 0;
d7834 1
a7834 1
		u_int8_t rate1 = rs->rs_rates[i] & IEEE80211_RATE_VAL;
d7917 3
a7919 3
u_int16_t
bwi_txtime(struct ieee80211com *ic, struct ieee80211_node *ni, u_int len,
    u_int8_t rs_rate, uint32_t flags)
d7922 1
a7922 1
	u_int16_t txtime;
@


1.53
log
@Don't count interrupts with state "not of interest".

From Oleg Safiullin.  OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.52 2007/09/30 17:11:58 kettenis Exp $	*/
d2772 1
a2772 1
				   __SHIFTIN(bbp_atten, mask));
d2779 1
a2779 1
				 __SHIFTIN(bbp_atten, mask));
@


1.52
log
@BWI_BBP_ATTEN is a 16-bit register, so use CSR_WRITE_2 to access it.
Fixes unaligned access on strict-alignment architectures.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.51 2007/09/29 22:27:59 mglocker Exp $	*/
d535 1
a535 1
		return (1);
@


1.51
log
@Fix two panic's on macppc.  Allows me first network communication over
my PowerBook G4 internal BCM4306 device.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.50 2007/09/27 22:17:32 mglocker Exp $	*/
d1055 1
a1055 1
	CSR_WRITE_4(sc, BWI_BBP_ATTEN, 0);
@


1.50
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.49 2007/09/27 22:10:25 mglocker Exp $	*/
d8001 1
a8001 1
			rate = ni->ni_rates.rs_rates[ni->ni_txrate];
d8306 1
a8306 1
		_bwi_txeof(sc, tx_id);
@


1.49
log
@Add automatic rate control (AMRR).
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.48 2007/09/27 09:19:21 mglocker Exp $	*/
d606 1
a606 1
	/* TODO:LED */
d751 1
a751 1
		/* TODO:11A */
d1828 1
a1828 1
	/* TODO:LED */
d2270 1
a2270 1
	/* TODO:LED */
d2846 1
a2846 1
	/* TODO:11A */
d2969 1
a2969 1
	/* TODO:11B */
d2981 1
a2981 1
	/* TODO:11B */
d5538 1
a5538 1
		/* TODO:11A */
d5585 1
a5585 1
	/* TODO:11A */
d5633 1
a5633 1
			/* TODO:11A */
d6118 1
a6118 1
		/* TODO:PCIE */
d7310 1
a7310 1
	/* TODO:64 */
d7317 1
a7317 1
	/* TODO:64 */
d7324 1
a7324 1
	/* TODO:64 */
d7332 1
a7332 1
	/* TODO:64 */
d7339 1
a7339 1
	/* TODO:64 */
d7586 1
a7586 1
	/* TODO:64 */
d7705 1
a7705 1
	/* TODO:64 */
d7711 1
a7711 1
	/* TODO:64 */
d7717 1
a7717 1
	/* TODO:64 */
d8195 1
a8195 1
	/* TODO:64 */
d8223 1
a8223 1
	/* TODO:64 */
@


1.48
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.47 2007/09/27 05:58:57 mglocker Exp $	*/
d71 1
d278 4
d625 5
d774 1
d6660 1
d6700 6
d6726 40
d8000 2
a8001 2
			/* TODO: TX rate control */
			rate = rate_fb = (1 * 2);
@


1.47
log
@Kill __BIT* macros.

Help and OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.46 2007/09/24 19:51:18 mglocker Exp $	*/
d401 1
a401 1
#define BWI_RF_2GHZ_CHAN(chan)			\
a3930 1

d7823 3
a7825 3
#define IEEE80211_OFDM_TXTIME(kbps, frmlen) \
	(IEEE80211_OFDM_PREAMBLE_TIME + \
	 IEEE80211_OFDM_SIGNAL_TIME + \
d7836 3
a7838 3
#define IEEE80211_OFDM_NBITS(frmlen) \
	(IEEE80211_OFDM_PLCP_SERVICE_NBITS + \
	 ((frmlen) * NBBY) + \
d7841 1
a7841 1
#define IEEE80211_OFDM_NBITS_PER_SYM(kbps) \
d7844 3
a7846 3
#define IEEE80211_OFDM_NSYMS(kbps, frmlen) \
	howmany(IEEE80211_OFDM_NBITS((frmlen)), \
		IEEE80211_OFDM_NBITS_PER_SYM((kbps)))
d7848 1
a7848 1
#define IEEE80211_CCK_TXTIME(kbps, frmlen) \
@


1.46
log
@Add radio tap support.  We still need to calculate correct RX rate and
RX signal strength.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.45 2007/09/23 22:59:44 mglocker Exp $	*/
d2757 1
a2757 1
	uint16_t mask = __BITS(3, 0);
d3495 1
a3495 1
#define NRSSI_11G_MASK		__BITS(13, 8)
d5514 2
a5515 2
#define NRSSI_THR1_MASK	__BITS(5, 0)
#define NRSSI_THR2_MASK	__BITS(11, 6)
d7694 2
a7695 2
#define IEEE80211_OFDM_PLCP_SIG_MASK	__BITS(3, 0)
#define IEEE80211_OFDM_PLCP_LEN_MASK	__BITS(16, 5)
@


1.45
log
@Fix page fault kernel crash when changing media and device is up.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.44 2007/09/23 22:10:53 mglocker Exp $	*/
d772 13
a7391 2
	/* TODO: radio tap */

d7463 26
a7488 1
		/* TODO: radio tap */
d7962 22
a7983 1
	/* TODO: radio tap */
@


1.44
log
@Add missing device name printf arguments for firmware load error output.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.43 2007/09/23 22:02:33 mglocker Exp $	*/
d6691 1
a6691 1
		bwi_init(ifp->if_softc);
@


1.43
log
@More debug ouput cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.42 2007/09/23 21:45:37 mglocker Exp $	*/
d1544 2
a1545 2
		printf("invalid firmware (%s): invalid size %u\n",
		    fw_name, fw_len);
d1556 1
a1556 1
			printf("invalid firmware (%s): size mismatch, "
d1558 3
a1560 1
			    fw_name, betoh32(hdr->fw_size),
d1567 1
a1567 1
		printf("invalid firmware (%s): type mismatch, "
d1569 1
a1569 1
		    fw_name, hdr->fw_type, fw_type);
d1574 1
a1574 1
		printf("invalid firmware (%s): wrong generation, "
d1576 1
a1576 1
		    fw_name, hdr->fw_gen, BWI_FW_GEN_1);
a6761 2


a6782 1

@


1.42
log
@Correctly clear PCI_STATUS_TARGET_TARGET_ABORT bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.41 2007/09/23 14:12:18 jsg Exp $	*/
a517 2
	DPRINTF(2, "%s\n", __func__);

d527 1
a527 4
#if 0
	DPRINTF(1, "%s: intr status 0x%08x\n",
	    sc->sc_dev.dv_xname, intr_status);
#endif
d532 3
d536 1
a536 3
#if 0
	DPRINTF(1, "%s: TX/RX intr", sc->sc_dev.dv_xname);
#endif
d546 2
a547 4
		CSR_READ_4(sc, BWI_TXRX_INTR_STATUS(i)) & mask;
#if 0
		printf(", %d 0x%08x", i, txrx_intr_status[i]);
#endif
a553 3
#if 0
	printf("\n");
#endif
d5777 1
a5777 1
	printf("%s\n", __func__);
@


1.41
log
@Properly handle the physical address in bwi_encap() as well.
With this change I can now scan, associate and ssh via bwi(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.40 2007/09/23 13:44:39 jsg Exp $	*/
d5744 1
a5744 2
	uint32_t gpio_in, gpio_out, gpio_en;
	uint16_t status;
@


1.40
log
@Make sure to set physical address in bwi_newbuf()
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.39 2007/09/18 17:35:38 mglocker Exp $	*/
d8067 1
@


1.39
log
@Drag back the original DragonFlyBSD firmware loading routines, so we can
load the same firmware revision as they do.  Our previously used firmware
images seem to contain the wrong revision.  You need to bump your firmware
package to version 1.2.

Other than expected, loading the right firmware revision still doesn't fix
a fatal chip error at initialization time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.38 2007/09/17 20:43:18 mglocker Exp $	*/
a7334 1
	rxbuf->rb_paddr = paddr;
d7342 2
@


1.38
log
@If device is down, don't handle any interrupts.  Even don't read the
interrupt status register instead return directly.  This fixes the machine
freeze on amd64 and let me receive proper interrupts if device is up.
This bit was originaly in the DragonFly code, and must have sneaked out
while porting ...
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.37 2007/09/17 14:26:51 mglocker Exp $	*/
d147 4
d154 1
a154 1
int		 bwi_mac_fw_load_iv(struct bwi_mac *, uint8_t *, int);
d1014 4
d1509 1
a1509 1

d1547 45
a1591 1
bwi_mac_fw_load(struct bwi_mac *mac)
d1594 112
a1705 7
	char *name = "bwi-airforce";
	char filename[64];
	uint8_t *ucode;
	uint16_t fw_rev;
	uint32_t *fw;
	size_t size_ucode, size_fw, size_pcm, off_fw, off_pcm;
	int fw_len, i, error = 0;
d1707 3
a1709 7
	/*
	 * Load FW file
	 */
	if ((error = loadfirmware(name, &ucode, &size_ucode)) != 0) {
		printf("%s: error %d, could not read firmware %s!\n",
		    sc->sc_dev.dv_xname, error, name);
		return (EIO);
a1710 1
	DPRINTF(1, "%s: successfully read %s\n", sc->sc_dev.dv_xname, name);
d1712 4
a1715 11
	/*
	 * Get FW file offset
	 */
	snprintf(filename, sizeof(filename), "bwi_microcode%d.fw",
	    mac->mac_rev >= 5 ? 5 : mac->mac_rev);
	if (bwi_get_firmware(filename, ucode, size_ucode, &size_fw, &off_fw)) {
		printf("%s: get offset for firmware file %s failed!\n",
		    sc->sc_dev.dv_xname, filename);
		error = ENOMEM;
		goto out;
        }
d1717 3
a1719 11
	/*
	 * Get PCM file offset
	 */
	snprintf(filename, sizeof(filename), "bwi_pcm%d.fw",
	    mac->mac_rev < 5 ? 4 : 5);
	if (bwi_get_firmware(filename, ucode, size_ucode, &size_pcm,
	    &off_pcm)) {
		printf("%s: get offset for firmware file %s failed!\n",
		    sc->sc_dev.dv_xname, filename);
		error = ENOMEM;
		goto out;
d1721 9
d1734 2
a1735 2
	fw = (uint32_t *)(ucode + off_fw);
	fw_len = size_fw / sizeof(uint32_t);
d1747 2
a1748 2
	fw = (uint32_t *)(ucode + off_pcm);
	fw_len = size_pcm / sizeof(uint32_t);
a1798 1
	free(ucode, M_DEVBUF);
d1855 1
a1855 1
bwi_mac_fw_load_iv(struct bwi_mac *mac, uint8_t *fw_image, int fw_len)
d1858 1
d1860 1
a1860 3
	uint16_t offset, size;
	uint32_t val;
	int iv_len, i, error = 0;
d1863 6
a1868 2
	iv_len = fw_len / sizeof(struct bwi_fw_iv);
	DPRINTF(1, "%s: IV count %d\n", sc->sc_dev.dv_xname, iv_len);
d1871 5
a1875 1
	iv = (const struct bwi_fw_iv *)fw_image;
d1877 15
a1891 8
	for (i = 0; i < iv_len; i++, iv++) {
		offset = betoh16(iv->offset);
		size = betoh16(iv->size);
		val = betoh32(iv->val);

		if (offset >= 0x1000) {
			error = ENODEV;
			goto error;
d1894 20
a1913 4
		if (size == sizeof(uint16_t)) {
			if (val & 0xffff0000) {
				error = ENODEV;
				goto error;
d1915 5
a1919 6
			CSR_WRITE_2(sc, offset, (uint16_t)val);
		} else if (size == sizeof(uint32_t))
			CSR_WRITE_4(sc, offset, val);
		else {
			error = ENODEV;
			goto error;
d1921 2
d1925 5
a1929 1
	return (error);
d1931 1
a1931 3
error:
	printf("%s: bad IV format!\n", sc->sc_dev.dv_xname);
	return (error);
d1938 1
a1938 41
	char *name = "bwi-airforce";
	char fwname[64];
	uint8_t *ucode;
	size_t size_ucode, size_iv, off_iv;
	int idx, error = 0;

	/*
	 * Load FW file
	 */
	if ((error = loadfirmware(name, &ucode, &size_ucode)) != 0) {
		printf("%s: error %d, could not read firmware %s!\n",
		    sc->sc_dev.dv_xname, error, name);
		return (EIO);
	}
	DPRINTF(1, "%s: successfully read %s\n", sc->sc_dev.dv_xname, name);

	/*
	 * Load IV
	 *
	 * TODO: 11A
	 */
	if (mac->mac_rev == 2 || mac->mac_rev == 4)
		idx = 2;
	else if (mac->mac_rev >= 5 && mac->mac_rev <= 10)
		idx = 5;
	else {
		printf("%s: no suitable IV for MAC rev %d\n",
		    sc->sc_dev.dv_xname, mac->mac_rev);
		error = ENODEV;
		goto out;
	}
	snprintf(fwname, sizeof(fwname), "bwi_initval%02d.fw", idx);

	DPRINTF(1, "%s: IV image is %s\n", sc->sc_dev.dv_xname, fwname);

	if (bwi_get_firmware(fwname, ucode, size_ucode, &size_iv, &off_iv)) {
		printf("%s: IV image %s not found!\n",
		    sc->sc_dev.dv_xname, fwname);
		error = ENOMEM;
		goto out;
	}
d1940 1
a1940 1
	error = bwi_mac_fw_load_iv(mac, (ucode + off_iv), size_iv);
d1942 2
a1943 2
		printf("%s: load IV failed!\n", sc->sc_dev.dv_xname);
		goto out;
d1946 5
a1950 15
	/*
	 * Load extended IV
	 *
	 * TODO: 11A
	 */
	if (mac->mac_rev == 2 || mac->mac_rev == 4 || mac->mac_rev >= 11)
		/* No extended IV */
		goto out;
	else if (mac->mac_rev >= 5 && mac->mac_rev <= 10)
		idx = 5;
	else {
		printf("%s: no suitable extended IV for MAC rev %d\n",
		    sc->sc_dev.dv_xname, mac->mac_rev);
		error = ENODEV;
		goto out;
a1951 1
	snprintf(fwname, sizeof(fwname), "bwi_initval%02d.fw", idx);
a1952 16
	DPRINTF(1, "%s: extended IV image is %s\n",
	    sc->sc_dev.dv_xname, fwname);

	if (bwi_get_firmware(fwname, ucode, size_ucode, &size_iv, &off_iv)) {
		printf("%s: extended IV image %s not found!\n",
		    sc->sc_dev.dv_xname, fwname);
		error = ENOMEM;
		goto out;
	}

	error = bwi_mac_fw_load_iv(mac, (ucode + off_iv), size_iv);
	if (error)
		printf("%s: load extended IV failed!\n", sc->sc_dev.dv_xname);

out:
	free(ucode, M_DEVBUF);
@


1.37
log
@Several DPRINTF arguments was missing, which can lead to ugly kernel
crashes.  Fix them.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.36 2007/09/17 13:58:10 mglocker Exp $	*/
d509 1
d515 3
@


1.36
log
@In case of IV load failure free ucode.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.35 2007/09/16 19:08:42 mglocker Exp $	*/
d1228 1
a1228 1
		DPRINTF(1, "TEST1 failed\n", sc->sc_dev.dv_xname);
d1236 1
a1236 1
		DPRINTF(1, "TEST2 failed\n", sc->sc_dev.dv_xname);
d1252 1
a1252 1
		DPRINTF(1, "%s failed, intr status %08x\n",
d1638 1
a1638 1
		DPRINTF(1, "firmware version 4 is not supported yet\n",
d4311 2
a4312 2
	DPRINTF(1, "%s: max txpower from sprom: %d dBm\n", sc->sc_dev.dv_xname,
	    rf->rf_txpower_max);
d4341 2
a4342 2
	DPRINTF(1, "%s: max txpower %d dBm\n", sc->sc_dev.dv_xname,
	    rf->rf_txpower_max);
d4437 2
a4438 2
	DPRINTF(1, "%s: idle tssi0: %d\n", sc->sc_dev.dv_xname,
	    rf->rf_idle_tssi0);
d6075 4
a6078 3
	DPRINTF(1, "%s: clksrc %s\n", sc->sc_dev.dv_xname,
		src == BWI_CLKSRC_PCI ? "PCI" :
		(src == BWI_CLKSRC_LP_OSC ? "LP_OSC" : "CS_OSC"));
d6699 1
a6699 1
			DPRINTF(1, "TX stats DMA alloc failed\n",
d8130 2
a8131 2
	DPRINTF(1, "%s: power on delay %u\n", sc->sc_dev.dv_xname,
	    sc->sc_pwron_delay);
d8203 2
a8204 2
		DPRINTF(1, "%s: %s is enabled\n", sc->sc_dev.dv_xname,
		    bwi_regwin_name(rw));
d8207 2
a8208 2
		DPRINTF(1, "%s: %s is disabled\n", sc->sc_dev.dv_xname,
		    bwi_regwin_name(rw));
d8225 2
a8226 2
		DPRINTF(1, "%s: %s was already disabled\n", sc->sc_dev.dv_xname,
		    bwi_regwin_name(rw));
@


1.35
log
@Remove more obsolete firmware specific bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.34 2007/09/16 19:02:36 mglocker Exp $	*/
d1784 2
a1785 1
			return (ENODEV);
@


1.34
log
@Remove obsolete firmware specific bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.33 2007/09/16 12:33:26 jsg Exp $	*/
a1005 6
#if 0
	error = bwi_mac_fw_alloc(mac);
	if (error)
		return (error);
#endif

@


1.33
log
@Better version of fake KKASSERT until they are changed properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.32 2007/09/16 12:15:57 mglocker Exp $	*/
a144 6
#if 0
int		 bwi_fwimage_is_valid(struct bwi_softc *,
		     const struct fw_image *, uint8_t);
int		 bwi_mac_fw_alloc(struct bwi_mac *);
void		 bwi_mac_fw_free(struct bwi_mac *);
#endif
a1502 162
	//bwi_mac_fw_free(mac);
}

#if 0
int
bwi_fwimage_is_valid(struct bwi_softc *sc, const struct fw_image *fw,
    uint8_t fw_type)
{
	const struct bwi_fwhdr *hdr;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (fw->fw_imglen < sizeof(*hdr)) {
		DPRINTF(1, "%s: invalid firmware (%s): invalid size %u\n",
		    sc->sc_dev.dv_xname, fw->fw_name, fw->fw_imglen);
		return (0);
	}

	hdr = (const struct bwi_fwhdr *)fw->fw_image;

	if (fw_type != BWI_FW_T_IV) {
		/*
		 * Don't verify IV's size, it has different meaning
		 */
		if (betoh32(hdr->fw_size) != fw->fw_imglen - sizeof(*hdr)) {
			DPRINTF(1, "%s: invalid firmware (%s): size mismatch, "
			    "fw %u, real %u\n",
			    sc->sc_dev.dv_xname, fw->fw_name,
			    betoh32(hdr->fw_size),
			    fw->fw_imglen - sizeof(*hdr));
			return (0);
		}
	}

	if (hdr->fw_type != fw_type) {
		DPRINTF(1, "%s: invalid firmware (%s): type mismatch, "
		    "fw \'%c\', target \'%c\'\n",
		    fw->fw_name, sc->sc_dev.dv_xname, hdr->fw_type, fw_type);
		return (0);
	}

	if (hdr->fw_gen != BWI_FW_GEN_1) {
		DPRINTF(1, "%s: invalid firmware (%s): wrong generation, "
		    "fw %d, target %d\n",
		    sc->sc_dev.dv_xname, fw->fw_name, hdr->fw_gen,
		    BWI_FW_GEN_1);
		return (0);
	}

	return (1);
}
#endif

#if 0
int
bwi_mac_fw_alloc(struct bwi_mac *mac)
{
	struct bwi_softc *sc = mac->mac_sc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	char fwname[64];
	int idx;

	if (mac->mac_ucode == NULL) {
		snprintf(fwname, sizeof(fwname), BWI_FW_UCODE_PATH,
			  sc->sc_fw_version,
			  mac->mac_rev >= 5 ? 5 : mac->mac_rev);

		mac->mac_ucode = firmware_image_load(fwname);
		if (mac->mac_ucode == NULL) {
			DPRINTF(1, "%s: request firmware %s failed\n",
			    sc->sc_dev.dv_xname, fwname);
			return (ENOMEM);
		}

		if (!bwi_fwimage_is_valid(sc, mac->mac_ucode, BWI_FW_T_UCODE))
			return EINVAL;
	}

	if (mac->mac_pcm == NULL) {
		snprintf(fwname, sizeof(fwname), BWI_FW_PCM_PATH,
			  sc->sc_fw_version,
			  mac->mac_rev < 5 ? 4 : 5);

		mac->mac_pcm = firmware_image_load(fwname);
		if (mac->mac_pcm == NULL) {
			DPRINTF(1, "%s: request firmware %s failed\n",
			    sc->sc_dev.dv_xname, fwname);
			return (ENOMEM);
		}

		if (!bwi_fwimage_is_valid(sc, mac->mac_pcm, BWI_FW_T_PCM))
			return EINVAL;
	}

	if (mac->mac_iv == NULL) {
		/* TODO: 11A */
		if (mac->mac_rev == 2 || mac->mac_rev == 4) {
			idx = 2;
		} else if (mac->mac_rev >= 5 && mac->mac_rev <= 10) {
			idx = 5;
		} else {
			DPRINTF(1, "%s: no suitable IV for MAC rev %d\n",
			    sc->sc_dev.dv_xname, mac->mac_rev);
			return (ENODEV);
		}

		snprintf(fwname, sizeof(fwname), BWI_FW_IV_PATH,
			  sc->sc_fw_version, idx);

		mac->mac_iv = firmware_image_load(fwname);
		if (mac->mac_iv == NULL) {
			DPRINTF(1, "%s: request firmware %s failed\n",
			    sc->sc_dev.dv_xname, fwname);
			return (ENOMEM);
		}
		if (!bwi_fwimage_is_valid(sc, mac->mac_iv, BWI_FW_T_IV))
			return EINVAL;
	}

	if (mac->mac_iv_ext == NULL) {
		/* TODO: 11A */
		if (mac->mac_rev == 2 || mac->mac_rev == 4 ||
		    mac->mac_rev >= 11) {
			/* No extended IV */
			goto back;
		} else if (mac->mac_rev >= 5 && mac->mac_rev <= 10) {
			idx = 5;
		} else {
			DPRINTF(1, "%s: no suitable ExtIV for MAC rev %d\n",
			    sc->sc_dev.dv_xname, mac->mac_rev);
			return (ENODEV);
		}

		snprintf(fwname, sizeof(fwname), BWI_FW_IV_EXT_PATH,
			  sc->sc_fw_version, idx);

		mac->mac_iv_ext = firmware_image_load(fwname);
		if (mac->mac_iv_ext == NULL) {
			DPRINTF(1, "%s: request firmware %s failed\n",
			    sc->sc_dev.dv_xname, fwname);
			return (ENOMEM);
		}
		if (!bwi_fwimage_is_valid(sc, mac->mac_iv_ext, BWI_FW_T_IV))
			return EINVAL;
	}
back:
	return (0);
}
#endif

#if 0
void
bwi_mac_fw_free(struct bwi_mac *mac)
{
	if (mac->mac_ucode != NULL) {
		firmware_image_unload(mac->mac_ucode);
		mac->mac_ucode = NULL;
	}

	if (mac->mac_pcm != NULL) {
		firmware_image_unload(mac->mac_pcm);
		mac->mac_pcm = NULL;
	}
a1503 9
	if (mac->mac_iv != NULL) {
		firmware_image_unload(mac->mac_iv);
		mac->mac_iv = NULL;
	}

	if (mac->mac_iv_ext != NULL) {
		firmware_image_unload(mac->mac_iv_ext);
		mac->mac_iv_ext = NULL;
	}
a1504 1
#endif
@


1.32
log
@Do sc_disable when device gets stopped.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.31 2007/09/16 11:52:40 jsg Exp $	*/
d86 1
a86 1
#define KKASSERT(cond) if (!(cond)) panic("bwi KKASSERT!\n")
@


1.31
log
@Clear error before starting m_defrag() equivalent.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.30 2007/09/16 11:30:53 jsg Exp $	*/
d6380 1
d6697 4
@


1.30
log
@Move some noisy debug printfs to higher levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.29 2007/09/16 11:12:38 jsg Exp $	*/
d8065 2
@


1.29
log
@CardBus works much better when sc_enable is called.
Remove some safety returns while here.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.28 2007/09/16 09:58:04 mglocker Exp $	*/
a7347 2
	DPRINTF(1, "%s\n", __func__);

a7474 2
	DPRINTF(1, "%s\n", __func__);

a7770 2
	printf("%s\n", __func__);

d7943 1
a7943 1
	printf("%s\n", __func__);
d8553 1
a8553 1
	DPRINTF(1, "%s\n", __func__);
@


1.28
log
@Free ucode if an error happens while FW / IV load.  Always return a proper
code in case of error.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.27 2007/09/16 04:38:16 jsg Exp $	*/
d519 1
a519 1
	return (0);
a1029 2
	return (0);

d6379 3
@


1.27
log
@Convert most of the remaining non firmware handling code.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.26 2007/09/16 02:20:35 jsg Exp $	*/
d1736 1
a1736 1
		printf("%s: error %d, could not read microcode %s!\n",
d1747 1
a1747 2
	if (bwi_get_firmware(filename, ucode, size_ucode, &size_fw, &off_fw)
	    != 0) {
d1750 2
a1751 1
		goto error;
d1759 2
a1760 2
	if (bwi_get_firmware(filename, ucode, size_ucode, &size_pcm, &off_pcm)
	    != 0) {
d1763 2
a1764 1
		goto error;
d1816 1
a1816 1
		goto error;
d1827 1
a1827 1
		goto error;
d1834 1
a1834 1
error:
d1898 1
a1898 1
	int len, i;
d1901 2
a1902 2
	len = fw_len / sizeof(struct bwi_fw_iv);
	DPRINTF(1, "%s: IV count %d\n", sc->sc_dev.dv_xname, len);
d1907 1
a1907 1
	for (i = 0; i < len; i++, iv++) {
d1912 2
a1913 1
		if (offset >= 0x1000)
d1915 1
d1918 2
a1919 1
			if (val & 0xffff0000)
d1921 1
d1925 2
a1926 1
		else
d1928 1
d1931 1
a1931 1
	return (0);
d1935 1
a1935 1
	return (1);
d1946 1
a1946 1
	int idx, error;
d1952 1
a1952 1
		printf("%s: error %d, could not read microcode %s!\n",
d1963 1
a1963 1
	if (mac->mac_rev == 2 || mac->mac_rev == 4) {
d1965 1
a1965 1
	} else if (mac->mac_rev >= 5 && mac->mac_rev <= 10) {
d1967 1
a1967 1
	} else {
d1979 2
a1980 1
		return (ENOMEM);
d1986 1
a1986 1
		return (error);
d1994 1
a1994 1
	if (mac->mac_rev == 2 || mac->mac_rev == 4 || mac->mac_rev >= 11) {
d1996 2
a1997 2
		goto back;
	} else if (mac->mac_rev >= 5 && mac->mac_rev <= 10) {
d1999 1
a1999 1
	} else {
d2002 2
a2003 1
		return (ENODEV);
d2013 2
a2014 1
		return (ENOMEM);
d2021 1
a2021 1
back:
a2022 1

@


1.26
log
@Remove most of the __unused due to to code being enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.25 2007/09/15 23:36:30 mglocker Exp $	*/
d323 1
a323 1
void		 bwi_plcp_header(void *, int, uint8_t) __unused;
d347 5
d501 8
a2184 1
#if 0
d2190 1
a2190 1
		enum ieee80211_modtype modtype;
d2193 1
a2193 1
		modtype = ieee80211_rate2modtype(rs->rs_rates[i]);
a2208 1
#endif
d2377 3
d2384 1
a2384 1
#if 0
a2397 1
#endif
d7339 1
a7339 1
#if 0
d7350 4
a7353 1
	m = m_getcl(init ? MB_WAIT : MB_DONTWAIT, MT_DATA, M_PKTHDR);
a7412 2
#endif
	return (0);
d7468 1
a7468 1
#if 0
d7479 1
a7479 1
		struct ieee80211_frame_min *wh;
d7522 1
a7522 1
		wh = mtod(m, struct ieee80211_frame_min *);
d7525 1
a7525 1
		ieee80211_input(ic, m, ni, hdr->rxh_rssi,
a7535 1
#endif
d7766 2
a7767 2
#if 0
	enum ieee80211_modtype modtype;
d7773 1
a7773 1
	modtype = ieee80211_rate2modtype(rate);
d7780 153
a7932 1
#endif
d7940 1
a7940 1
#if 0
d7971 3
a7973 11
		if (ic->ic_fixed_rate != IEEE80211_FIXED_RATE_NONE) {
			int idx;

			rate = IEEE80211_RS_RATE(&ni->ni_rates,
					ic->ic_fixed_rate);

			if (ic->ic_fixed_rate >= 1)
				idx = ic->ic_fixed_rate - 1;
			else
				idx = 0;
			rate_fb = IEEE80211_RS_RATE(&ni->ni_rates, idx);
d7983 2
d7986 1
a7986 1
		rate = rate_fb = ic->ic_mcast_rate;
d7999 1
a7999 1
	M_PREPEND(m, sizeof(*hdr), MB_DONTWAIT);
d8016 2
a8017 2
		ack_rate = ieee80211_ack_rate(ni, rate_fb);
		dur = ieee80211_txtime(ni,
d8032 1
a8032 1
	if (ieee80211_rate2modtype(rate) == IEEE80211_MODTYPE_OFDM)
d8040 1
a8040 1
	if (ieee80211_rate2modtype(rate_fb) == IEEE80211_MODTYPE_OFDM)
d8062 1
a8062 1
		m_new = m_defrag(m, MB_DONTWAIT);
d8064 19
a8082 1
			DPRINTF(1, "%s: can't defrag TX buffer\n",
a8083 1
			error = ENOBUFS;
a8084 2
		} else {
			m = m_new;
d8087 5
a8132 2
#endif
	return (1);
@


1.25
log
@Adapt firmware images prefix to driver name.  Needs bump to firmware
package version 1.1.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.24 2007/09/15 22:47:14 mglocker Exp $	*/
d282 6
a287 6
		     struct bwi_ring_data *, bus_size_t, uint32_t) __unused;
int		 bwi_dma_txstats_alloc(struct bwi_softc *, uint32_t, bus_size_t)
		     __unused;
void		 bwi_dma_txstats_free(struct bwi_softc *) __unused;
int		 bwi_dma_mbuf_create(struct bwi_softc *) __unused;
void		 bwi_dma_mbuf_destroy(struct bwi_softc *, int, int) __unused;
d290 1
a290 1
int		 bwi_init_tx_ring32(struct bwi_softc *, int) __unused;
d292 4
a295 5
		     bus_addr_t, int, int) __unused;
int		 bwi_init_rx_ring32(struct bwi_softc *) __unused;
int		 bwi_init_txstats32(struct bwi_softc *) __unused;
void		 bwi_setup_rx_desc32(struct bwi_softc *, int, bus_addr_t, int)
		     __unused;
d297 5
a301 6
		     int, bus_addr_t, int) __unused;
int		 bwi_init_tx_ring64(struct bwi_softc *, int) __unused;
int		 bwi_init_rx_ring64(struct bwi_softc *) __unused;
int		 bwi_init_txstats64(struct bwi_softc *) __unused;
void		 bwi_setup_rx_desc64(struct bwi_softc *, int, bus_addr_t, int)
		     __unused;
d303 2
a304 2
		     int, bus_addr_t, int) __unused;
int		 bwi_newbuf(struct bwi_softc *, int, int) __unused;
d309 3
a311 3
void		 bwi_rxeof(struct bwi_softc *, int) __unused;
void		 bwi_rxeof32(struct bwi_softc *) __unused;
void		 bwi_rxeof64(struct bwi_softc *) __unused;
d313 6
a318 6
void		 bwi_free_txstats32(struct bwi_softc *) __unused;
void		 bwi_free_rx_ring32(struct bwi_softc *) __unused;
void		 bwi_free_tx_ring32(struct bwi_softc *, int) __unused;
void		 bwi_free_txstats64(struct bwi_softc *) __unused;
void		 bwi_free_rx_ring64(struct bwi_softc *) __unused;
void		 bwi_free_tx_ring64(struct bwi_softc *, int) __unused;
d326 4
a329 4
void		 bwi_start_tx32(struct bwi_softc *, uint32_t, int) __unused;
void		 bwi_start_tx64(struct bwi_softc *, uint32_t, int) __unused;
void		 bwi_txeof_status32(struct bwi_softc *) __unused;
void		 bwi_txeof_status64(struct bwi_softc *) __unused;
d337 1
a337 1
const char 	*bwi_regwin_name(const struct bwi_regwin *) __unused;
@


1.24
log
@Get IV load working.  Simplified IV loading routine (mainly a rewrite).
Adapted IV loading routines so we can use it with our one file firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.23 2007/09/15 15:08:07 jsg Exp $	*/
d1734 1
a1734 1
	snprintf(filename, sizeof(filename), "bcm43xx_microcode%d.fw",
d1746 1
a1746 1
	snprintf(filename, sizeof(filename), "bcm43xx_pcm%d.fw",
d1954 1
a1954 1
	snprintf(fwname, sizeof(fwname), "bcm43xx_initval%02d.fw", idx);
d1985 1
a1985 1
	snprintf(fwname, sizeof(fwname), "bcm43xx_initval%02d.fw", idx);
@


1.23
log
@Give hardware physical addresses and add some missing
bus_dmamap_create() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.22 2007/09/15 13:38:22 jsg Exp $	*/
d156 1
a156 1
int		 bwi_mac_fw_load_iv(struct bwi_mac *, const struct fw_image *);
a1014 2
	return (0);

d1019 2
d1880 1
a1880 1
bwi_mac_fw_load_iv(struct bwi_mac *mac, const struct fw_image *fw)
a1881 2
	DPRINTF(1, "%s\n", __func__);
#if 0
a1882 2
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	const struct bwi_fwhdr *hdr;
d1884 3
a1886 1
	int n, i, iv_img_size;
d1889 2
a1890 6
	hdr = (const struct bwi_fwhdr *)fw->fw_image;
	n = betoh32(hdr->fw_iv_cnt);
	DPRINTF(1, "%s: IV count %d\n", sc->sc_dev.dv_xname, n);

	/* Calculate the IV image size, for later sanity check */
	iv_img_size = fw->fw_imglen - sizeof(*hdr);
d1893 1
a1893 2
	iv = (const struct bwi_fw_iv *)
	     ((const uint8_t *)fw->fw_image + sizeof(*hdr));
d1895 17
a1911 3
	for (i = 0; i < n; ++i) {
		uint16_t iv_ofs, ofs;
		int sz = 0;
d1913 1
a1913 7
		if (iv_img_size < sizeof(iv->iv_ofs)) {
			DPRINTF(1, "%s: invalid IV image, ofs\n",
			    sc->sc_dev.dv_xname);
			return (EINVAL);
		}
		iv_img_size -= sizeof(iv->iv_ofs);
		sz += sizeof(iv->iv_ofs);
d1915 4
a1918 1
		iv_ofs = betoh16(iv->iv_ofs);
d1920 9
a1928 6
		ofs = __SHIFTOUT(iv_ofs, BWI_FW_IV_OFS_MASK);
		if (ofs >= 0x1000) {
			DPRINTF(1, "%s: invalid ofs (0x%04x) for %dth iv\n",
			    sc->sc_dev.dv_xname, ofs, i);
			return (EINVAL);
		}
d1930 9
a1938 2
		if (iv_ofs & BWI_FW_IV_IS_32BIT) {
			uint32_t val32;
d1940 15
a1954 7
			if (iv_img_size < sizeof(iv->iv_val.val32)) {
				DPRINTF(1, "%s: invalid IV image, val32\n",
				    sc->sc_dev.dv_xname);
				return (EINVAL);
			}
			iv_img_size -= sizeof(iv->iv_val.val32);
			sz += sizeof(iv->iv_val.val32);
d1956 1
a1956 4
			val32 = betoh32(iv->iv_val.val32);
			CSR_WRITE_4(sc, ofs, val32);
		} else {
			uint16_t val16;
d1958 5
a1962 7
			if (iv_img_size < sizeof(iv->iv_val.val16)) {
				DPRINTF(1, "%s: invalid IV image, val16\n",
				    sc->sc_dev.dv_xname);
				return (EINVAL);
			}
			iv_img_size -= sizeof(iv->iv_val.val16);
			sz += sizeof(iv->iv_val.val16);
d1964 4
a1967 5
			val16 = betoh16(iv->iv_val.val16);
			CSR_WRITE_2(sc, ofs, val16);
		}

		iv = (const struct bwi_fw_iv *)((const uint8_t *)iv + sz);
d1970 14
a1983 4
	if (iv_img_size != 0) {
		DPRINTF(1, "%s: invalid IV image, size left %d\n",
		    sc->sc_dev.dv_xname, iv_img_size);
		return (EINVAL);
d1985 1
d1987 2
a1988 4
	return (0);
#endif
	return (0);
}
d1990 5
a1994 5
int
bwi_mac_fw_init(struct bwi_mac *mac)
{
	struct bwi_softc *sc;
	int error;
d1996 3
a1998 1
	sc = mac->mac_sc;
d2000 2
a2001 5
	error = bwi_mac_fw_load_iv(mac, mac->mac_iv);
	if (error) {
		DPRINTF(1, "%s: load IV failed\n", sc->sc_dev.dv_xname);
		return (error);
	}
a2002 6
	if (mac->mac_iv_ext != NULL) {
		error = bwi_mac_fw_load_iv(mac, mac->mac_iv_ext);
		if (error)
			DPRINTF(1, "%s: load ExtIV failed\n",
			    sc->sc_dev.dv_xname);
	}
@


1.22
log
@most of the remaining bus_dma conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.21 2007/09/15 12:17:39 jsg Exp $	*/
a6729 2
	DPRINTF(1, "%s\n", __func__);
#if 0
a6730 1
	bus_addr_t lowaddr = 0;
a6744 4
		if (sc->sc_bus_space == BWI_BUS_SPACE_30BIT)
			lowaddr = BWI_BUS_SPACE_MAXADDR;
		else
			lowaddr = BUS_SPACE_MAXADDR_32BIT;
a6763 1
		lowaddr = BUS_SPACE_MAXADDR;	/* XXX */
a6782 1
	KKASSERT(lowaddr != 0);
d6794 1
d6796 8
d6817 9
a6844 2
#endif
	return (0);
d6903 1
d6925 8
d6958 3
d6967 7
d6999 2
@


1.21
log
@Convert bus_dmamap_sync() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.20 2007/09/15 11:55:55 jsg Exp $	*/
d281 1
a281 1
int		 bwi_dma_ring_alloc(struct bwi_softc *, bus_dma_tag_t,
a285 2
void		 bwi_dma_ring_addr(void *, bus_dma_segment_t *, int, int)
		     __unused;
a6797 16
	/*
	 * Create top level DMA tag
	 */
	error = bus_dma_tag_create(NULL, BWI_ALIGN, 0,
	    lowaddr, BUS_SPACE_MAXADDR,
	    NULL, NULL,
	    MAXBSIZE,
	    BUS_SPACE_UNRESTRICTED,
	    BUS_SPACE_MAXSIZE_32BIT,
	    0, &sc->sc_parent_dtag);
	if (error) {
		DPRINTF(1, "%s: can't create parent DMA tag\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

a6801 10
	error = bus_dma_tag_create(sc->sc_parent_dtag, BWI_RING_ALIGN, 0,
	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
	    NULL, NULL,
	    tx_ring_sz, 1, BUS_SPACE_MAXSIZE_32BIT,
	    0, &sc->sc_txring_dtag);
	if (error) {
		DPRINTF(1, "%s: can't create TX ring DMA tag\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}
d6804 1
a6804 1
		error = bwi_dma_ring_alloc(sc, sc->sc_txring_dtag,
a6815 10
	error = bus_dma_tag_create(sc->sc_parent_dtag, BWI_RING_ALIGN, 0,
	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
	    NULL, NULL,
	    rx_ring_sz, 1, BUS_SPACE_MAXSIZE_32BIT,
	    0, &sc->sc_rxring_dtag);
	if (error) {
		DPRINTF(1, "%s: can't create RX ring DMA tag\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}
d6817 1
a6817 1
	error = bwi_dma_ring_alloc(sc, sc->sc_rxring_dtag, &sc->sc_rx_rdata,
d6843 1
a6843 4
	DPRINTF(1, "%s\n", __func__);
#if 0
	if (sc->sc_txring_dtag != NULL) {
		int i;
d6845 2
a6846 2
		for (i = 0; i < BWI_TX_NRING; ++i) {
			struct bwi_ring_data *rd = &sc->sc_tx_rdata[i];
d6848 5
a6852 7
			if (rd->rdata_desc != NULL) {
				bus_dmamap_unload(sc->sc_dmat,
				    rd->rdata_dmap);
				bus_dmamem_free(sc->sc_txring_dtag,
				    rd->rdata_desc,
				    rd->rdata_dmap);
			}
d6856 1
a6856 2
	if (sc->sc_rxring_dtag != NULL) {
		struct bwi_ring_data *rd = &sc->sc_rx_rdata;
d6858 3
a6860 5
		if (rd->rdata_desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, rd->rdata_dmap);
			bus_dmamem_free(sc->sc_rxring_dtag, rd->rdata_desc,
			    rd->rdata_dmap);
		}
a6864 1
#endif
d6868 1
a6868 1
bwi_dma_ring_alloc(struct bwi_softc *sc, bus_dma_tag_t dtag,
d6871 1
a6871 3
	DPRINTF(1, "%s\n", __func__);
#if 0
	int error;
d6873 2
a6874 2
	error = bus_dmamem_alloc(dtag, &rd->rdata_desc,
	    BUS_DMA_WAITOK | BUS_DMA_ZERO, &rd->rdata_dmap);
d6880 7
d6891 1
a6891 1
		bus_dmamem_free(dtag, rd->rdata_desc, rd->rdata_dmap);
a6898 2
#endif
	return (0);
a6904 2
	DPRINTF(1, "%s\n", __func__);
#if 0
d6907 1
a6907 1
	int error;
d6909 1
a6909 1
	st = kmalloc(sizeof(*st), M_DEVBUF, M_WAITOK | M_ZERO);
d6917 2
a6918 5
	error = bus_dma_tag_create(sc->sc_parent_dtag, BWI_RING_ALIGN, 0,
	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
	    NULL, NULL,
	    dma_size, 1, BUS_SPACE_MAXSIZE_32BIT,
	    0, &st->stats_ring_dtag);
d6920 1
a6920 1
		DPRINTF(sc, "%s: can't create txstats ring DMA tag\n"
d6925 2
a6926 3
	error = bus_dmamem_alloc(st->stats_ring_dtag, &st->stats_ring,
	    BUS_DMA_WAITOK | BUS_DMA_ZERO,
	    &st->stats_ring_dmap);
d6928 1
a6928 1
		DPRINTF(1, "%s: can't allocate txstats ring DMA mem\n",
a6929 1
		st->stats_ring_dtag = NULL;
d6938 1
a6938 3
		bus_dmamem_free(st->stats_ring_dtag, st->stats_ring,
		    st->stats_ring_dmap);
		st->stats_ring_dtag = NULL;
d6948 2
a6949 5
	error = bus_dma_tag_create(sc->sc_parent_dtag, BWI_ALIGN, 0,
	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
	    NULL, NULL,
	    dma_size, 1, BUS_SPACE_MAXSIZE_32BIT,
	    0, &st->stats_dtag);
d6951 1
a6951 1
		DPRINTF(1, "%s: can't create txstats DMA tag\n",
d6956 2
a6957 3
	error = bus_dmamem_alloc(st->stats_dtag, (void **)&st->stats,
	    BUS_DMA_WAITOK | BUS_DMA_ZERO,
	    &st->stats_dmap);
d6959 1
a6959 1
		DPRINTF(1, "%s: can't allocate txstats DMA mem\n",
a6960 1
		st->stats_dtag = NULL;
d6967 1
a6967 1
		DRPINTF(1, "%s: can't load txstats DMA mem\n",
d6969 1
a6969 2
		bus_dmamem_free(st->stats_dtag, st->stats, st->stats_dmap);
		st->stats_dtag = NULL;
a6975 2
#endif
	return (0);
a6980 2
	DPRINTF(1, "%s\n", __func__);
#if 0
d6987 2
a6988 10
	if (st->stats_ring_dtag != NULL) {
		bus_dmamap_unload(sc->sc_dmat, st->stats_ring_dmap);
		bus_dmamem_free(st->stats_ring_dtag, st->stats_ring,
		    st->stats_ring_dmap);
	}

	if (st->stats_dtag != NULL) {
		bus_dmamap_unload(sc->sc_dmat, st->stats_dmap);
		bus_dmamem_free(st->stats_dtag, st->stats, st->stats_dmap);
	}
d6990 2
a6991 3
	kfree(st, M_DEVBUF);
#endif
}
d6993 1
a6993 5
void
bwi_dma_ring_addr(void *arg, bus_dma_segment_t *seg, int nseg, int error)
{
	KASSERT(nseg == 1, ("too many segments\n"));
	*((bus_addr_t *)arg) = seg->ds_addr;
a6998 2
	DPRINTF(1, "%s\n", __func__);
#if 0
a7001 14
	/*
	 * Create TX/RX mbuf DMA tag
	 */
	error = bus_dma_tag_create(sc->sc_parent_dtag, 1, 0,
	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
	    NULL, NULL, MCLBYTES, 1,
	    BUS_SPACE_MAXSIZE_32BIT,
	    0, &sc->sc_buf_dtag);
	if (error) {
		DPRINTF(1, "%s: can't create mbuf DMA tag\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

d7011 2
a7012 2
			error = bus_dmamap_create(sc->sc_buf_dtag, 0,
						  &tbd->tbd_buf[j].tb_dmap);
d7014 3
a7016 2
				DPRINTF(sc, "%s: can't create %dth tbd, %dth "
				    "DMA map\n", sc->sc_dev.dv_xname), i, j);
d7019 1
a7019 1
					bus_dmamap_destroy(sc->sc_buf_dtag,
d7031 2
a7032 1
	error = bus_dmamap_create(sc->sc_buf_dtag, 0, &rbd->rbd_tmp_dmap);
d7040 2
a7041 2
		error = bus_dmamap_create(sc->sc_buf_dtag, 0,
		    &rbd->rbd_buf[j].rb_dmap);
d7047 1
a7047 1
				bus_dmamap_destroy(sc->sc_buf_dtag,
d7050 1
a7050 1
			bus_dmamap_destroy(sc->sc_buf_dtag,
a7060 2
#endif
	return (1);
d7066 1
a7066 2
	DPRINTF(1, "%s\n", __func__);
#if 0
a7068 3
	if (sc->sc_buf_dtag == NULL)
		return;

d7081 2
a7082 2
				ieee80211_free_node(tb->tb_ni);
			bus_dmamap_destroy(sc->sc_buf_dtag, tb->tb_dmap);
d7089 1
a7089 1
		bus_dmamap_destroy(sc->sc_buf_dtag, rbd->rbd_tmp_dmap);
d7098 1
a7098 1
			bus_dmamap_destroy(sc->sc_buf_dtag, rb->rb_dmap);
a7100 3

	sc->sc_buf_dtag = NULL;
#endif
d7470 1
a7470 1
		ieee80211_free_node(ni);
d7559 1
a7559 2
	DPRINTF(1, "%s\n", __func__);
#if 0
d7612 1
a7612 1
			ieee80211_free_node(tb->tb_ni);
a7615 1
#endif
@


1.20
log
@Convert bus_dma_load_mbuf() calls and remove unrequired callback
code previously used.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.19 2007/09/15 11:00:24 brad Exp $	*/
a7216 2
	DPRINTF(1, "%s\n", __func__);
#if 0
d7229 2
a7230 2
	bus_dmamap_sync(sc->sc_txring_dtag, rd->rdata_dmap,
	    BUS_DMASYNC_PREWRITE);
a7244 2
#endif
	return (1);
a7272 2
	DPRINTF(1, "%s\n", __func__);
#if 0
d7286 2
a7287 2
	bus_dmamap_sync(sc->sc_rxring_dtag, rd->rdata_dmap,
	    BUS_DMASYNC_PREWRITE);
a7291 2
#endif
	return (1);
a7296 2
	DPRINTF(1, "%s\n", __func__);
#if 0
d7302 2
a7303 1
	bus_dmamap_sync(st->stats_dtag, st->stats_dmap, BUS_DMASYNC_PREWRITE);
d7313 2
a7314 2
	bus_dmamap_sync(st->stats_ring_dtag, st->stats_ring_dmap,
	    BUS_DMASYNC_PREWRITE);
a7319 2
#endif
	return (1);
d7443 2
a7444 1
	bus_dmamap_sync(sc->sc_buf_dtag, rxbuf->rb_dmap, BUS_DMASYNC_PREWRITE);
d7528 2
a7529 2
		bus_dmamap_sync(sc->sc_buf_dtag, rb->rb_dmap,
				BUS_DMASYNC_POSTREAD);
d7575 2
a7576 2
	bus_dmamap_sync(sc->sc_rxring_dtag, rd->rdata_dmap,
	    BUS_DMASYNC_PREWRITE);
d7980 2
a7981 1
	bus_dmamap_sync(sc->sc_buf_dtag, tb->tb_dmap, BUS_DMASYNC_PREWRITE);
d8001 2
a8002 2
	bus_dmamap_sync(sc->sc_txring_dtag, rd->rdata_dmap,
			BUS_DMASYNC_PREWRITE);
a8102 2
	printf("%s\n", __func__);
#if 0
d8106 2
a8107 1
	bus_dmamap_sync(st->stats_dtag, st->stats_dmap, BUS_DMASYNC_POSTREAD);
a8114 1
#endif
@


1.19
log
@suitible -> suitable

ok mglocker@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.18 2007/09/15 09:08:53 jsg Exp $	*/
a307 2
void		 bwi_dma_buf_addr(void *, bus_dma_segment_t *, int,
		     bus_size_t, int) __unused;
a7387 10
void
bwi_dma_buf_addr(void *arg, bus_dma_segment_t *seg, int nseg,
    bus_size_t mapsz, int error)
{
        if (!error) {
		KASSERT(nseg == 1, ("too many segments(%d)\n", nseg));
		*((bus_addr_t *)arg) = seg->ds_addr;
	}
}

d7422 1
a7422 2
	error = bus_dmamap_load_mbuf(sc->sc_buf_dtag, rbd->rbd_tmp_dmap, m,
	    bwi_dma_buf_addr, &paddr,
d7959 2
a7960 2
	error = bus_dmamap_load_mbuf(sc->sc_buf_dtag, tb->tb_dmap, m,
	    bwi_dma_buf_addr, &paddr, BUS_DMA_NOWAIT);
d7980 2
a7981 2
		error = bus_dmamap_load_mbuf(sc->sc_buf_dtag, tb->tb_dmap, m,
		    bwi_dma_buf_addr, &paddr, BUS_DMA_NOWAIT);
@


1.18
log
@convert bus_dmamap_unload() calls
remove bus_dma_tag_destroy() calls as we don't use/require them.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.17 2007/09/15 08:55:29 jsg Exp $	*/
d1604 1
a1604 1
			DPRINTF(1, "%s: no suitible IV for MAC rev %d\n",
d1631 1
a1631 1
			DPRINTF(1, "%s: no suitible ExtIV for MAC rev %d\n",
@


1.17
log
@convert bus_dmamap_load() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.16 2007/09/15 07:20:51 jsg Exp $	*/
d6892 1
a6892 1
				bus_dmamap_unload(sc->sc_txring_dtag,
a6898 1
		bus_dma_tag_destroy(sc->sc_txring_dtag);
d6905 1
a6905 1
			bus_dmamap_unload(sc->sc_rxring_dtag, rd->rdata_dmap);
a6908 1
		bus_dma_tag_destroy(sc->sc_rxring_dtag);
a6912 3

	if (sc->sc_parent_dtag != NULL)
		bus_dma_tag_destroy(sc->sc_parent_dtag);
a6981 1
		bus_dma_tag_destroy(st->stats_ring_dtag);
a6992 1
		bus_dma_tag_destroy(st->stats_ring_dtag);
a7019 1
		bus_dma_tag_destroy(st->stats_dtag);
a7029 1
		bus_dma_tag_destroy(st->stats_dtag);
d7053 1
a7053 1
		bus_dmamap_unload(st->stats_ring_dtag, st->stats_ring_dmap);
a7055 1
		bus_dma_tag_destroy(st->stats_ring_dtag);
d7059 1
a7059 1
		bus_dmamap_unload(st->stats_dtag, st->stats_dmap);
a7060 1
		bus_dma_tag_destroy(st->stats_dtag);
d7174 1
a7174 1
				bus_dmamap_unload(sc->sc_buf_dtag,
d7192 1
a7192 1
				bus_dmamap_unload(sc->sc_buf_dtag,
a7199 1
	bus_dma_tag_destroy(sc->sc_buf_dtag);
d7450 1
a7450 1
		bus_dmamap_unload(sc->sc_buf_dtag, rxbuf->rb_dmap);
d7671 1
a7671 1
			bus_dmamap_unload(sc->sc_buf_dtag, rb->rb_dmap);
d7730 1
a7730 1
			bus_dmamap_unload(sc->sc_buf_dtag, tb->tb_dmap);
d8107 1
a8107 1
	bus_dmamap_unload(sc->sc_buf_dtag, tb->tb_dmap);
@


1.16
log
@Properly fill in some of the pci information the driver uses internally.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.15 2007/09/15 05:47:53 jsg Exp $	*/
d6936 2
a6937 2
	error = bus_dmamap_load(dtag, rd->rdata_dmap, rd->rdata_desc, size,
	    bwi_dma_ring_addr, &rd->rdata_paddr, BUS_DMA_WAITOK);
d6992 2
a6993 4
	error = bus_dmamap_load(st->stats_ring_dtag, st->stats_ring_dmap,
	    st->stats_ring, dma_size,
	    bwi_dma_ring_addr, &st->stats_ring_paddr,
	    BUS_DMA_WAITOK);
d7032 2
a7033 3
	error = bus_dmamap_load(st->stats_dtag, st->stats_dmap, st->stats,
	    dma_size, bwi_dma_ring_addr, &st->stats_paddr,
	    BUS_DMA_WAITOK);
@


1.15
log
@define BWI_DEBUG to make things easier
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.14 2007/09/14 20:26:04 mglocker Exp $	*/
a93 3
#define pci_get_device(dev)			(0)
#define pci_get_revid(dev)			(0)

d2392 1
a2392 1
	    pci_get_device(sc->sc_dev) != PCI_PRODUCT_BROADCOM_BCM4309) {
d5935 2
a5936 2
		uint16_t did = pci_get_device(sc->sc_dev);
		uint8_t revid = pci_get_revid(sc->sc_dev);
@


1.14
log
@Get firmware load working.  Adapt firmware routines that way so we can
use our one file firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.13 2007/09/14 13:08:31 mglocker Exp $	*/
d75 2
@


1.13
log
@Use our standard ratesets from ieee80211 instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.12 2007/09/14 13:00:41 mglocker Exp $	*/
d146 1
d151 3
d1006 1
d1010 1
d1020 2
d1505 1
a1505 1
	bwi_mac_fw_free(mac);
d1508 1
a1512 2
	DPRINTF(1, "%s\n", __func__);
#if 0
d1554 1
a1555 2
	return (0);
}
d1557 1
a1557 3
/*
 * XXX Error cleanup
 */
a1560 2
	DPRINTF(1, "%s\n", __func__);
#if 0
d1651 1
a1652 2
	return (0);
}
d1654 1
a1657 2
	printf("%s\n", __func__);
#if 0
d1677 1
d1679 33
a1716 2
	DPRINTF(1, "%s\n", __func__);
#ifdef notyet
d1718 3
a1720 2
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	const uint32_t *fw;
d1722 13
a1734 1
	int fw_len, i;
d1737 1
a1737 1
	 * Load ucode image
d1739 26
a1764 3
	fw = (const uint32_t *)
	     ((const uint8_t *)mac->mac_ucode->fw_image + BWI_FWHDR_SZ);
	fw_len = (mac->mac_ucode->fw_imglen - BWI_FWHDR_SZ) / sizeof(uint32_t);
d1767 1
a1767 2
	    BWI_MOBJ_CTRL_VAL(
	    BWI_FW_UCODE_MOBJ | BWI_WR_MOBJ_AUTOINC, 0));
d1776 2
a1777 3
	fw = (const uint32_t *)
	     ((const uint8_t *)mac->mac_pcm->fw_image + BWI_FWHDR_SZ);
	fw_len = (mac->mac_pcm->fw_imglen - BWI_FWHDR_SZ) / sizeof(uint32_t);
d1806 1
a1806 1
		DPRINTF(1, "%s: firmware (ucode&pcm) loading timed out\n",
d1808 2
a1809 1
		return (ETIMEDOUT);
d1819 2
a1820 1
		return (ENODEV);
d1823 7
a1829 6
	DPRINTF(1, "firmware rev 0x%04x, patch level 0x%04x\n",
	    sc->sc_dev.dc_xname, fw_rev, MOBJ_READ_2(mac, BWI_COMM_MOBJ,
	    BWI_COMM_MOBJ_FWPATCHLV));
	return (0);
#endif
	return (0);
@


1.12
log
@Sort prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.11 2007/09/14 09:29:00 mglocker Exp $	*/
a498 5
static const struct ieee80211_rateset bwi_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };
static const struct ieee80211_rateset bwi_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d705 2
a706 1
		ic->ic_sup_rates[IEEE80211_MODE_11B] = bwi_rateset_11b;
d717 2
a718 1
			ic->ic_sup_rates[IEEE80211_MODE_11G] = bwi_rateset_11g;
@


1.11
log
@Another cleanup run.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.10 2007/09/13 20:37:19 mglocker Exp $	*/
d114 236
a349 20
int		bwi_mac_test(struct bwi_mac *);
int		bwi_mac_get_property(struct bwi_mac *);
void		bwi_mac_set_retry_lim(struct bwi_mac *,
		    const struct bwi_retry_lim *);
void		bwi_mac_set_ackrates(struct bwi_mac *,
		    const struct ieee80211_rateset *);
int		bwi_mac_gpio_init(struct bwi_mac *);
int		bwi_mac_gpio_fini(struct bwi_mac *);
void		bwi_mac_opmode_init(struct bwi_mac *);
void		bwi_mac_hostflags_init(struct bwi_mac *);
void		bwi_mac_bss_param_init(struct bwi_mac *);
int		bwi_mac_fw_alloc(struct bwi_mac *);
void		bwi_mac_fw_free(struct bwi_mac *);
int		bwi_mac_fw_load(struct bwi_mac *);
int		bwi_mac_fw_init(struct bwi_mac *);
int		bwi_mac_fw_load_iv(struct bwi_mac *, const struct fw_image *);
void		bwi_mac_setup_tpctl(struct bwi_mac *);
void		bwi_mac_adjust_tpctl(struct bwi_mac *, int, int);
void		bwi_mac_lock(struct bwi_mac *);
void		bwi_mac_unlock(struct bwi_mac *);
a352 13
/* PHY */
void		bwi_phy_init_11a(struct bwi_mac *);
void		bwi_phy_init_11g(struct bwi_mac *);
void		bwi_phy_init_11b_rev2(struct bwi_mac *);
void		bwi_phy_init_11b_rev4(struct bwi_mac *);
void		bwi_phy_init_11b_rev5(struct bwi_mac *);
void		bwi_phy_init_11b_rev6(struct bwi_mac *);
void		bwi_phy_config_11g(struct bwi_mac *);
void		bwi_phy_config_agc(struct bwi_mac *);
void		bwi_tbl_write_2(struct bwi_mac *mac, uint16_t, uint16_t);
void		bwi_tbl_write_4(struct bwi_mac *mac, uint16_t, uint32_t);
void		bwi_plcp_header(void *, int, uint8_t) __unused;

a428 21
int		bwi_rf_calc_txpower(int8_t *, uint8_t, const int16_t[]);
void		bwi_rf_work_around(struct bwi_mac *, u_int);
int		bwi_rf_gain_max_reached(struct bwi_mac *, int);
uint16_t	bwi_rf_calibval(struct bwi_mac *);
uint16_t	bwi_rf_get_tp_ctrl2(struct bwi_mac *);
uint32_t	bwi_rf_lo_devi_measure(struct bwi_mac *, uint16_t);
void		bwi_rf_lo_measure(struct bwi_mac *,
		    const struct bwi_rf_lo *, struct bwi_rf_lo *, uint8_t);
void		bwi_rf_lo_write(struct bwi_mac *, const struct bwi_rf_lo *);
void		bwi_rf_set_nrssi_ofs_11g(struct bwi_mac *);
void		bwi_rf_calc_nrssi_slope_11b(struct bwi_mac *);
void		bwi_rf_calc_nrssi_slope_11g(struct bwi_mac *);
void		bwi_rf_set_nrssi_thr_11b(struct bwi_mac *);
void		bwi_rf_set_nrssi_thr_11g(struct bwi_mac *);
void		bwi_rf_init_sw_nrssi_table(struct bwi_mac *);
void		bwi_rf_on_11a(struct bwi_mac *);
void		bwi_rf_on_11bg(struct bwi_mac *);
void		bwi_rf_off_11a(struct bwi_mac *);
void		bwi_rf_off_11bg(struct bwi_mac *);
void		bwi_rf_off_11g_rev5(struct bwi_mac *);

a435 5
struct bwi_clock_freq {
	u_int		clkfreq_min;
	u_int		clkfreq_max;
};

a440 8
/* XXX does not belong here */
struct ieee80211_ds_plcp_hdr {
	uint8_t		i_signal;
	uint8_t		i_service;
	uint16_t	i_length;
	uint16_t	i_crc;
} __packed;

a446 105
int		bwi_init(struct ifnet *);
int		bwi_ioctl(struct ifnet *, u_long, caddr_t);
void		bwi_start(struct ifnet *);
void		bwi_watchdog(struct ifnet *);
int		bwi_newstate(struct ieee80211com *, enum ieee80211_state, int);
void		bwi_updateslot(struct ieee80211com *);
int		bwi_media_change(struct ifnet *);
void		bwi_next_scan(void *);
void		bwi_calibrate(void *);
int		bwi_stop(struct bwi_softc *);
int		bwi_newbuf(struct bwi_softc *, int, int) __unused;
int		bwi_encap(struct bwi_softc *, int, struct mbuf *,
		    struct ieee80211_node *);
void		bwi_init_rxdesc_ring32(struct bwi_softc *, uint32_t,
		    bus_addr_t, int, int) __unused;
void		bwi_reset_rx_ring32(struct bwi_softc *, uint32_t);
int		bwi_init_tx_ring32(struct bwi_softc *, int) __unused;
int		bwi_init_rx_ring32(struct bwi_softc *) __unused;
int		bwi_init_txstats32(struct bwi_softc *) __unused;
void		bwi_free_tx_ring32(struct bwi_softc *, int) __unused;
void		bwi_free_rx_ring32(struct bwi_softc *) __unused;
void		bwi_free_txstats32(struct bwi_softc *) __unused;
void		bwi_setup_rx_desc32(struct bwi_softc *, int, bus_addr_t, int)
		    __unused;
void		bwi_setup_tx_desc32(struct bwi_softc *, struct bwi_ring_data *,
		    int, bus_addr_t, int) __unused;
void		bwi_rxeof32(struct bwi_softc *) __unused;
void		bwi_start_tx32(struct bwi_softc *, uint32_t, int) __unused;
void		bwi_txeof_status32(struct bwi_softc *) __unused;
int		bwi_init_tx_ring64(struct bwi_softc *, int) __unused;
int		bwi_init_rx_ring64(struct bwi_softc *) __unused;
int		bwi_init_txstats64(struct bwi_softc *) __unused;
void		bwi_free_tx_ring64(struct bwi_softc *, int) __unused;
void		bwi_free_rx_ring64(struct bwi_softc *) __unused;
void		bwi_free_txstats64(struct bwi_softc *) __unused;
void		bwi_setup_rx_desc64(struct bwi_softc *, int, bus_addr_t, int)
		    __unused;
void		bwi_setup_tx_desc64(struct bwi_softc *, struct bwi_ring_data *,
		    int, bus_addr_t, int) __unused;
void		bwi_rxeof64(struct bwi_softc *) __unused;
void		bwi_start_tx64(struct bwi_softc *, uint32_t, int) __unused;
void		bwi_txeof_status64(struct bwi_softc *) __unused;
void		bwi_rxeof(struct bwi_softc *, int);
void		_bwi_txeof(struct bwi_softc *, uint16_t);
void		bwi_txeof(struct bwi_softc *);
void		bwi_txeof_status(struct bwi_softc *, int);
void		bwi_enable_intrs(struct bwi_softc *, uint32_t);
void		bwi_disable_intrs(struct bwi_softc *, uint32_t);
int		bwi_dma_alloc(struct bwi_softc *);
void		bwi_dma_free(struct bwi_softc *);
int		bwi_dma_ring_alloc(struct bwi_softc *, bus_dma_tag_t,
		    struct bwi_ring_data *, bus_size_t, uint32_t) __unused;
int		bwi_dma_mbuf_create(struct bwi_softc *) __unused;
void		bwi_dma_mbuf_destroy(struct bwi_softc *, int, int) __unused;
int		bwi_dma_txstats_alloc(struct bwi_softc *, uint32_t, bus_size_t)
		    __unused;
void		bwi_dma_txstats_free(struct bwi_softc *) __unused;
void		bwi_dma_ring_addr(void *, bus_dma_segment_t *, int, int)
		    __unused;
void		bwi_dma_buf_addr(void *, bus_dma_segment_t *, int,
		    bus_size_t, int) __unused;
void		bwi_power_on(struct bwi_softc *, int);
int		bwi_power_off(struct bwi_softc *, int);
int		bwi_set_clock_mode(struct bwi_softc *, enum bwi_clock_mode);
int		bwi_set_clock_delay(struct bwi_softc *);
void		bwi_get_clock_freq(struct bwi_softc *,
		    struct bwi_clock_freq *);
int		bwi_get_pwron_delay(struct bwi_softc *sc);
void		bwi_set_addr_filter(struct bwi_softc *, uint16_t,
		    const uint8_t *);
void		bwi_set_bssid(struct bwi_softc *, const uint8_t *);
int		bwi_set_chan(struct bwi_softc *, u_int8_t);
void		bwi_get_card_flags(struct bwi_softc *);
void		bwi_get_eaddr(struct bwi_softc *, uint16_t, uint8_t *);
int		bwi_bus_attach(struct bwi_softc *);
int		bwi_bbp_attach(struct bwi_softc *);
int		bwi_bbp_power_on(struct bwi_softc *, enum bwi_clock_mode);
void		bwi_bbp_power_off(struct bwi_softc *);
const char *	bwi_regwin_name(const struct bwi_regwin *) __unused;
uint32_t	bwi_regwin_disable_bits(struct bwi_softc *);
void		bwi_regwin_info(struct bwi_softc *, uint16_t *, uint8_t *);
int		bwi_regwin_select(struct bwi_softc *, int);

/* misc unsorted */
int			bwi_fwimage_is_valid(struct bwi_softc *,
		 	    const struct fw_image *, uint8_t);
void			bwi_mac_balance_atten(int *, int *);
int16_t			bwi_nrssi_11g(struct bwi_mac *);
struct bwi_rf_lo *	bwi_get_rf_lo(struct bwi_mac *, uint16_t, uint16_t);
struct bwi_rf_lo *	bwi_rf_lo_find(struct bwi_mac *,
			    const struct bwi_tpctl *);
int			bwi_rf_lo_isused(struct bwi_mac *,
			    const struct bwi_rf_lo *);
uint8_t			_bwi_rf_lo_update(struct bwi_mac *, uint16_t);
uint16_t		bwi_bitswap4(uint16_t);
uint16_t		bwi_phy812_value(struct bwi_mac *, uint16_t);
int32_t			_bwi_adjust_devide(int32_t, int32_t);
int32_t			_nrssi_threshold(const struct bwi_rf *, int32_t);
void			bwi_setup_desc32(struct bwi_softc *,
			    struct bwi_desc32 *, int, int, bus_addr_t, int,
			    int);
void			bwi_ofdm_plcp_header(uint32_t *, int, uint8_t);
void			bwi_ds_plcp_header(struct ieee80211_ds_plcp_hdr *, int,
			    uint8_t);

d461 310
a770 2
	{ 0x4720, 0x4725, 0x4309 }
};
d772 3
a774 20
static const struct {
	uint16_t	bbp_id;
	int		nregwin;
} bwi_regwin_count[] = {
	{ 0x4301, 5 },
	{ 0x4306, 6 },
	{ 0x4307, 5 },
	{ 0x4310, 8 },
	{ 0x4401, 3 },
	{ 0x4402, 3 },
	{ 0x4610, 9 },
	{ 0x4704, 9 },
	{ 0x4710, 9 },
	{ 0x5365, 7 }
};

#define CLKSRC(src) 				\
[BWI_CLKSRC_ ## src] = {			\
	.freq_min = BWI_CLKSRC_ ##src## _FMIN,	\
	.freq_max = BWI_CLKSRC_ ##src## _FMAX	\
d777 6
a782 8
static const struct {
	u_int	freq_min;
	u_int	freq_max;
} bwi_clkfreq[BWI_CLKSRC_MAX] = {
	CLKSRC(LP_OSC),
	CLKSRC(CS_OSC),
	CLKSRC(PCI)
};
d784 3
a786 1
#undef CLKSRC
d788 2
a789 1
static const uint8_t bwi_zero_addr[IEEE80211_ADDR_LEN];
d791 1
a791 4
static const struct ieee80211_rateset bwi_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };
static const struct ieee80211_rateset bwi_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };
d793 2
a794 1
/* CODE */
d5605 3
a5607 218
				if (phy->phy_rev >= 6)
					PHY_WRITE(mac, 0x49b, 0xdc);
			}
		}
	}

	/* XXX v4 set AUTO_ANTDIV unconditionally */
	if (ant_mode == BWI_ANT_MODE_AUTO)
		HFLAGS_SETBITS(mac, BWI_HFLAG_AUTO_ANTDIV);

	val = ant_mode << 8;
	MOBJ_FILT_SETBITS_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_TX_BEACON,
	    0xfc3f, val);
	MOBJ_FILT_SETBITS_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_TX_ACK,
	    0xfc3f, val);
	MOBJ_FILT_SETBITS_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_TX_PROBE_RESP,
	    0xfc3f, val);

	/* XXX what's these */
	if (phy->phy_mode == IEEE80211_MODE_11B)
		CSR_SETBITS_2(sc, 0x5e, 0x4);

	CSR_WRITE_4(sc, 0x100, 0x1000000);
	if (mac->mac_rev < 5)
		CSR_WRITE_4(sc, 0x10c, 0x1000000);

	mac->mac_rf.rf_ant_mode = ant_mode;
}

int
bwi_rf_get_latest_tssi(struct bwi_mac *mac, int8_t tssi[], uint16_t ofs)
{
	int i;

	for (i = 0; i < 4; ) {
		uint16_t val;

		val = MOBJ_READ_2(mac, BWI_COMM_MOBJ, ofs + i);
		tssi[i++] = (int8_t)__SHIFTOUT(val, BWI_LO_TSSI_MASK);
		tssi[i++] = (int8_t)__SHIFTOUT(val, BWI_HI_TSSI_MASK);
	}

	for (i = 0; i < 4; ++i) {
		if (tssi[i] == BWI_INVALID_TSSI)
			return (EINVAL);
	}

	return (0);
}

int
bwi_rf_tssi2dbm(struct bwi_mac *mac, int8_t tssi, int8_t *txpwr)
{
	struct bwi_rf *rf = &mac->mac_rf;
	int pwr_idx;

	pwr_idx = rf->rf_idle_tssi + (int)tssi - rf->rf_base_tssi;
#if 0
	if (pwr_idx < 0 || pwr_idx >= BWI_TSSI_MAX)
		return EINVAL;
#else
	if (pwr_idx < 0)
		pwr_idx = 0;
	else if (pwr_idx >= BWI_TSSI_MAX)
		pwr_idx = BWI_TSSI_MAX - 1;
#endif
	*txpwr = rf->rf_txpower_map[pwr_idx];

	return (0);
}

/* IF_BWI */

uint16_t
bwi_read_sprom(struct bwi_softc *sc, uint16_t ofs)
{
	return (CSR_READ_2(sc, ofs + BWI_SPROM_START));
}

void
bwi_setup_desc32(struct bwi_softc *sc, struct bwi_desc32 *desc_array,
    int ndesc, int desc_idx, bus_addr_t paddr, int buf_len, int tx)
{
	struct bwi_desc32 *desc = &desc_array[desc_idx];
	uint32_t ctrl, addr, addr_hi, addr_lo;

	addr_lo = __SHIFTOUT(paddr, BWI_DESC32_A_ADDR_MASK);
	addr_hi = __SHIFTOUT(paddr, BWI_DESC32_A_FUNC_MASK);

	addr = __SHIFTIN(addr_lo, BWI_DESC32_A_ADDR_MASK) |
	    __SHIFTIN(BWI_DESC32_A_FUNC_TXRX, BWI_DESC32_A_FUNC_MASK);

	ctrl = __SHIFTIN(buf_len, BWI_DESC32_C_BUFLEN_MASK) |
	     __SHIFTIN(addr_hi, BWI_DESC32_C_ADDRHI_MASK);
	if (desc_idx == ndesc - 1)
		ctrl |= BWI_DESC32_C_EOR;
	if (tx) {
		/* XXX */
		ctrl |= BWI_DESC32_C_FRAME_START |
		    BWI_DESC32_C_FRAME_END |
		    BWI_DESC32_C_INTR;
	}

	desc->addr = htole32(addr);
	desc->ctrl = htole32(ctrl);
}

int
bwi_attach(struct bwi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct bwi_mac *mac;
	struct bwi_phy *phy;
	int i, error;

	printf("\n");

	timeout_set(&sc->sc_scan_ch, bwi_next_scan, sc);
	timeout_set(&sc->sc_calib_ch, bwi_calibrate, sc);

	bwi_power_on(sc, 1);

	error = bwi_bbp_attach(sc);
	if (error)
		goto fail;

	error = bwi_bbp_power_on(sc, BWI_CLOCK_MODE_FAST);
	if (error)
		goto fail;

	if (BWI_REGWIN_EXIST(&sc->sc_com_regwin)) {
		error = bwi_set_clock_delay(sc);
		if (error)
			goto fail;

		error = bwi_set_clock_mode(sc, BWI_CLOCK_MODE_FAST);
		if (error)
			goto fail;

		error = bwi_get_pwron_delay(sc);
		if (error)
			goto fail;
	}

	error = bwi_bus_attach(sc);
	if (error)
		goto fail;

	bwi_get_card_flags(sc);

	/* TODO: LED */

	for (i = 0; i < sc->sc_nmac; ++i) {
		struct bwi_regwin *old;

		mac = &sc->sc_mac[i];
		error = bwi_regwin_switch(sc, &mac->mac_regwin, &old);
		if (error)
			goto fail;

		error = bwi_mac_lateattach(mac);
		if (error)
			goto fail;

		error = bwi_regwin_switch(sc, old, NULL);
		if (error)
			goto fail;
	}

	/*
	 * XXX First MAC is known to exist
	 * TODO2
	 */
	mac = &sc->sc_mac[0];
	phy = &mac->mac_phy;

	bwi_bbp_power_off(sc);

	error = bwi_dma_alloc(sc);
	if (error)
		goto fail;

	/* setup interface */
	ifp->if_softc = sc;
	ifp->if_init = bwi_init;
	ifp->if_ioctl = bwi_ioctl;
	ifp->if_start = bwi_start;
	ifp->if_watchdog = bwi_watchdog;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
	IFQ_SET_READY(&ifp->if_snd);

	/* Get locale */
	sc->sc_locale = __SHIFTOUT(bwi_read_sprom(sc, BWI_SPROM_CARD_INFO),
	    BWI_SPROM_CARD_INFO_LOCALE);
	DPRINTF(1, "%s: locale: %d\n", sc->sc_dev.dv_xname, sc->sc_locale);

	/*
	 * Setup ratesets, phytype, channels and get MAC address
	 */
	if (phy->phy_mode == IEEE80211_MODE_11B ||
	    phy->phy_mode == IEEE80211_MODE_11G) {
	    	uint16_t chan_flags;

		ic->ic_sup_rates[IEEE80211_MODE_11B] = bwi_rateset_11b;

		if (phy->phy_mode == IEEE80211_MODE_11B) {
			chan_flags = IEEE80211_CHAN_B;
			ic->ic_phytype = IEEE80211_T_DS;
		} else {
			chan_flags = IEEE80211_CHAN_CCK |
			    IEEE80211_CHAN_OFDM |
			    IEEE80211_CHAN_DYN |
			    IEEE80211_CHAN_2GHZ;
			ic->ic_phytype = IEEE80211_T_OFDM;
			ic->ic_sup_rates[IEEE80211_MODE_11G] = bwi_rateset_11g;
d5609 1
d5611 3
a5613 6
		/* XXX depend on locale */
		for (i = 1; i <= 14; ++i) {
			ic->ic_channels[i].ic_freq =
				ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
			ic->ic_channels[i].ic_flags = chan_flags;
		}
d5615 7
a5621 15
		bwi_get_eaddr(sc, BWI_SPROM_11BG_EADDR, ic->ic_myaddr);
		if (IEEE80211_IS_MULTICAST(ic->ic_myaddr)) {
			bwi_get_eaddr(sc, BWI_SPROM_11A_EADDR, ic->ic_myaddr);
			if (IEEE80211_IS_MULTICAST(ic->ic_myaddr)) {
				DPRINTF(1, "%s: invalid MAC address: %s\n",
				    sc->sc_dev.dv_xname,
				    ether_sprintf(ic->ic_myaddr));
			}
		}
	} else if (phy->phy_mode == IEEE80211_MODE_11A) {
		/* TODO:11A */
		error = ENXIO;
		goto fail;
	} else
		panic("unknown phymode %d\n", phy->phy_mode);
d5623 3
a5625 2
	sc->sc_fw_version = BWI_FW_VERSION3;
	sc->sc_dwell_time = 200;
d5627 3
a5629 6
	ic->ic_caps = IEEE80211_C_SHSLOT |
	    IEEE80211_C_SHPREAMBLE |
	    IEEE80211_C_WEP |
	    IEEE80211_C_MONITOR;
	ic->ic_state = IEEE80211_S_INIT;
	ic->ic_opmode = IEEE80211_M_STA;
d5631 2
a5632 1
	ic->ic_updateslot = bwi_updateslot;
d5634 4
a5637 2
	if_attach(ifp);
	ieee80211_ifattach(ifp);
d5639 2
a5640 2
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = bwi_newstate;
d5642 4
a5645 1
	ieee80211_media_init(ifp, bwi_media_change, ieee80211_media_status);
d5647 3
a5649 3
	if (error) {
		ieee80211_ifdetach(ifp);
		goto fail;
a5652 2
fail:
	return (error);
d5656 31
a5686 1
bwi_detach(void *arg)
d5688 2
a5689 3
	struct bwi_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int i;
d5691 2
a5692 3
	bwi_stop(sc);
	ieee80211_ifdetach(ifp);
	if_detach(ifp);
d5694 2
a5695 2
	for (i = 0; i < sc->sc_nmac; ++i)
		bwi_mac_detach(&sc->sc_mac[i]);
d5697 10
a5706 1
	bwi_dma_free(sc);
d5708 2
a5709 1
	return (0);
a6597 105
}

int
bwi_intr(void *xsc)
{
	struct bwi_softc *sc = xsc;
	uint32_t intr_status;
	uint32_t txrx_intr_status[BWI_TXRX_NRING];
	int i, txrx_error;

	return (0);

	/*
	 * Get interrupt status
	 */
	intr_status = CSR_READ_4(sc, BWI_MAC_INTR_STATUS);
	if (intr_status == 0xffffffff)	/* Not for us */
		return (0);
#if 0
	DPRINTF(1, "%s: intr status 0x%08x\n",
	    sc->sc_dev.dv_xname, intr_status);
#endif
	intr_status &= CSR_READ_4(sc, BWI_MAC_INTR_MASK);
	if (intr_status == 0)		/* Nothing is interesting */
		return (1);

	txrx_error = 0;
#if 0
	DPRINTF(1, "%s: TX/RX intr", sc->sc_dev.dv_xname);
#endif
	for (i = 0; i < BWI_TXRX_NRING; ++i) {
		uint32_t mask;

		if (BWI_TXRX_IS_RX(i))
			mask = BWI_TXRX_RX_INTRS;
		else
			mask = BWI_TXRX_TX_INTRS;

		txrx_intr_status[i] =
		CSR_READ_4(sc, BWI_TXRX_INTR_STATUS(i)) & mask;
#if 0
		printf(", %d 0x%08x", i, txrx_intr_status[i]);
#endif
		if (txrx_intr_status[i] & BWI_TXRX_INTR_ERROR) {
			DPRINTF(1, "%s: intr fatal TX/RX (%d) error 0x%08x\n",
			    sc->sc_dev.dv_xname, i, txrx_intr_status[i]);
			txrx_error = 1;
		}
	}
#if 0
	printf("\n");
#endif

	/*
	 * Acknowledge interrupt
	 */
	CSR_WRITE_4(sc, BWI_MAC_INTR_STATUS, intr_status);

	for (i = 0; i < BWI_TXRX_NRING; ++i)
		CSR_WRITE_4(sc, BWI_TXRX_INTR_STATUS(i), txrx_intr_status[i]);

	/* Disable all interrupts */
	bwi_disable_intrs(sc, BWI_ALL_INTRS);

	if (intr_status & BWI_INTR_PHY_TXERR)
		DPRINTF(1, "%s: intr PHY TX error\n", sc->sc_dev.dv_xname);

	if (txrx_error) {
		/* TODO: reset device */
	}

	if (intr_status & BWI_INTR_TBTT) {
		KKASSERT(sc->sc_cur_regwin->rw_type == BWI_REGWIN_T_MAC);
		bwi_mac_config_ps((struct bwi_mac *)sc->sc_cur_regwin);
	}

	if (intr_status & BWI_INTR_EO_ATIM)
		DPRINTF(1, "%s: EO_ATIM\n", sc->sc_dev.dv_xname);

	if (intr_status & BWI_INTR_PMQ) {
		for (;;) {
			if ((CSR_READ_4(sc, BWI_MAC_PS_STATUS) & 0x8) == 0)
				break;
		}
		CSR_WRITE_2(sc, BWI_MAC_PS_STATUS, 0x2);
	}

	if (intr_status & BWI_INTR_NOISE)
		DPRINTF(1, "%s: intr noise\n", sc->sc_dev.dv_xname);

	if (txrx_intr_status[0] & BWI_TXRX_INTR_RX)
		sc->sc_rxeof(sc);

	if (txrx_intr_status[3] & BWI_TXRX_INTR_RX)
		sc->sc_txeof_status(sc);

	if (intr_status & BWI_INTR_TX_DONE)
		bwi_txeof(sc);

	/* TODO:LED */

	/* Re-enable interrupts */
	bwi_enable_intrs(sc, BWI_INIT_INTRS);

	return (1);
@


1.10
log
@Move all debug lines to DPRINTF.  KNF.  Fix some tweaks while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.9 2007/09/13 18:40:24 mglocker Exp $	*/
d529 1
a529 1
		   uint16_t v)
a869 1

a904 1

a1014 5
	static const uint32_t	packet_11a[PACKET_LEN] =
	{ 0x000201cc, 0x00d40000, 0x00000000, 0x01000000, 0x00000000 };
	static const uint32_t	packet_11bg[PACKET_LEN] =
	{ 0x000b846e, 0x00d40000, 0x00000000, 0x01000000, 0x00000000 };

d1021 5
d1153 1
a1153 1
	printf("%s\n", __func__);
d1206 1
a1206 1
	printf("%s\n", __func__);
d1297 1
a1297 1
	return 0;
d1332 1
a1332 1
	printf("%s\n", __func__);
d1467 1
a1467 1
	printf("%s\n", __func__);
d1637 1
a1637 1
	} else {
a1638 1
	}
d1740 1
a1740 1
	printf("%s\n", __func__);
d1938 1
a1938 1
	printf("%s\n", __func__);
d2638 1
a2638 1
	} else {
a2639 1
	}
d2820 1
a2820 1
	} else {
a2821 1
	}
a3303 10

	static const uint16_t save_rf_regs[SAVE_RF_MAX] =
	{ 0x52, 0x43, 0x7a };
	static const uint16_t save_phy_regs[SAVE_PHY_MAX] = {
		0x0429, 0x0001, 0x0811, 0x0812,
		0x0814, 0x0815, 0x005a, 0x0059,
		0x0058, 0x000a, 0x0003, 0x080f,
		0x0810, 0x002b, 0x0015
	};

d3312 9
a3683 8

	static const uint16_t save_rf_regs[SAVE_RF_MAX] =
	{ 0x0043, 0x0051, 0x0052 };
	static const uint16_t save_phy_regs_comm[SAVE_PHY_COMM_MAX] =
	{ 0x0015, 0x005a, 0x0059, 0x0058 };
	static const uint16_t save_phy_regs_11g[SAVE_PHY_11G_MAX] =
	{ 0x0811, 0x0812, 0x0814, 0x0815, 0x0429, 0x0802 };

d3697 7
d3721 1
a3721 1
				PHY_READ(mac, save_phy_regs_11g[i]);
d3783 1
a3783 1
	if (rf->rf_rev == 8) {
d3785 1
a3785 1
	} else {
d3942 3
a3949 2
	uint16_t val, calib;
	int idx;
d3991 1
a3991 1
			f * 4096 - _bwi_adjust_devide(m2 * f, 16) * f, 2048);
d4029 1
a4029 1
				     BWI_SPROM_MAX_TXPWR_MASK_11A);
d4032 1
a4032 1
				     BWI_SPROM_MAX_TXPWR_MASK_11BG);
a4089 1

a4127 1

d4267 1
a4267 1
	} else {
a4268 1
	}
d4374 4
d4380 1
a4380 1
	{ 3, 1, 5, 7, 9, 2, 0, 4, 6, 8, 1, 2, 3, 4 };
d4382 1
a4382 1
        { 0, 3, 1, 5, 7, 3, 2, 0, 4, 6, -1, -1, -1, -1 };
d4384 1
a4384 6
	{ 3, 1, 5, 7, 9, 2, 0, 4, 6, 8, 10, 11, 12, 13 };

	struct ifnet *ifp = &mac->mac_sc->sc_ic.ic_if;
	struct bwi_rf_lo lo_save, *lo;
	uint8_t devi_ctrl = 0;
	int idx, adj_rf7a = 0;
d4468 1
a4468 1
	struct bwi_rf_lo *dst_lo, uint8_t devi_ctrl)
a4559 6

	static const uint16_t save_rf_regs[SAVE_RF_MAX] =
	{ 0x7a, 0x52, 0x43 };
	static const uint16_t save_phy_regs[SAVE_PHY_MAX] =
	{ 0x30, 0x26, 0x15, 0x2a, 0x20, 0x5a, 0x59, 0x58 };

d4569 5
d4673 7
d4681 1
a4681 2
	static const uint16_t save_rf_regs[SAVE_RF_MAX] =
	{ 0x7a, 0x43 };
a4691 8
	struct bwi_phy *phy = &mac->mac_phy;
	uint16_t save_rf[SAVE_RF_MAX];
	uint16_t save_phy_comm[SAVE_PHY_COMM_MAX];
	uint16_t save_phy6[SAVE_PHY6_MAX];
	uint16_t rf7b = 0xffff;
	int16_t nrssi;
	int i, phy6_idx = 0;

d4788 1
a4788 1
				  save_phy6[phy6_idx]);
d4807 1
a4807 1
				  save_phy6[phy6_idx]);
a4825 10

	static const uint16_t save_rf_regs[SAVE_RF_MAX] =
	{ 0x7a, 0x52, 0x43 };
	static const uint16_t save_phy_comm_regs[SAVE_PHY_COMM_MAX] =
	{ 0x15, 0x5a, 0x59, 0x58 };
	static const uint16_t save_phy3_regs[SAVE_PHY3_MAX] = {
		0x002e, 0x002f, 0x080f, 0x0810,
		0x0801, 0x0060, 0x0014, 0x0478
	};

d4837 9
d4879 1
a4879 1
		} else if (phy->phy_rev == 3 || phy->phy_rev == 5) {
a4880 1
		}
d4985 1
a4985 1
				  save_phy3[phy3_idx]);
a5126 1

d5128 1
a5128 1
	      __SHIFTIN((uint32_t)thr2, NRSSI_THR2_MASK);
a5129 1

d5145 1
a5145 1
		      __SHIFTIN(BWI_INVALID_TSSI, BWI_HI_TSSI_MASK);
a5316 1

d5341 1
a5341 1
	       __SHIFTIN(BWI_DESC32_A_FUNC_TXRX, BWI_DESC32_A_FUNC_MASK);
d5344 1
a5344 1
	       __SHIFTIN(addr_hi, BWI_DESC32_C_ADDRHI_MASK);
d5447 1
a5447 1
				   BWI_SPROM_CARD_INFO_LOCALE);
d5464 3
a5466 3
				     IEEE80211_CHAN_OFDM |
				     IEEE80211_CHAN_DYN |
				     IEEE80211_CHAN_2GHZ;
d5468 1
a5468 2
			ic->ic_sup_rates[IEEE80211_MODE_11G] =
				bwi_rateset_11g;
d5491 1
a5491 1
	} else {
a5492 1
	}
d5549 1
a5549 1
	printf("%s\n", __func__);
d5718 1
a5718 1
		       __SHIFTIN(0, BWI_INFO_BBPPKG_MASK);
a5746 1

d5872 4
a5875 2
			__SHIFTIN(BWI_CONF_LO_SERVTO, BWI_CONF_LO_SERVTO_MASK) |
			__SHIFTIN(BWI_CONF_LO_REQTO, BWI_CONF_LO_REQTO_MASK));
d5925 2
a5926 2
	DPRINTF(1, "%s: card flags 0x%04x\n", sc->sc_dev.dv_xname,
	    sc->sc_card_flags);
d5973 1
a5973 1
		if (src == BWI_CLKSRC_LP_OSC) {
d5975 1
a5975 1
		} else {
d5999 2
a6000 2
	DPRINTF(1, "%s: clkfreq min %u, max %u\n", sc->sc_dev.dv_xname,
		freq->clkfreq_min, freq->clkfreq_max);
d6082 1
a6082 1
		if (com->rw_rev >= 10) {
d6084 1
a6084 1
		} else {
d6262 1
a6262 2
	if ((ifp->if_flags & IFF_OACTIVE) ||
	    (ifp->if_flags & IFF_RUNNING) == 0)
a6310 1

a6314 1

a6318 1

a6322 1

d6376 1
a6376 1
		} else {
a6377 1
		}
d6379 1
d6570 1
a6570 1
	} else {
a6571 1
	}
d6605 1
a6605 1
	printf("%s\n", __func__);
a6689 1

d6706 1
a6706 2
					   &sc->sc_tx_rdata[i], tx_ring_sz,
					   TXRX_CTRL(i));
a6743 1

d6746 1
a6746 1
	return bwi_dma_mbuf_create(sc);
d6754 1
a6754 1
	printf("%s\n", __func__);
d6794 1
a6794 2
		   struct bwi_ring_data *rd, bus_size_t size,
		   uint32_t txrx_ctrl)
d6796 1
a6796 1
	printf("%s\n", __func__);
d6801 1
a6801 2
				 BUS_DMA_WAITOK | BUS_DMA_ZERO,
				 &rd->rdata_dmap);
d6825 1
a6825 1
		      bus_size_t desc_sz)
d6827 1
a6827 1
	printf("%s\n", __func__);
d6918 2
a6919 1
	return 0;
d6927 1
a6927 1
	printf("%s\n", __func__);
d6962 1
a6962 1
	printf("%s\n", __func__);
a6994 1

d6998 1
a6998 1
						tbd->tbd_buf[k].tb_dmap);
d7009 1
a7009 2
	error = bus_dmamap_create(sc->sc_buf_dtag, 0,
				  &rbd->rbd_tmp_dmap);
d7036 2
a7037 1
	return error;
d7045 1
a7045 1
	printf("%s\n", __func__);
d7105 1
a7105 1
	printf("%s\n", __func__);
d7134 1
a7134 1
	return 0;
d7141 1
a7141 1
		       bus_addr_t paddr, int hdr_size, int ndesc)
d7165 1
a7165 1
	printf("%s\n", __func__);
d7181 1
a7181 1
			BUS_DMASYNC_PREWRITE);
d7184 2
a7185 2
			       sizeof(struct bwi_rxbuf_hdr), BWI_RX_NDESC);
	return 0;
d7193 1
a7193 1
	printf("%s\n", __func__);
d7211 1
a7211 1
			BUS_DMASYNC_PREWRITE);
d7214 3
a7216 2
			       st->stats_ring_paddr, 0, BWI_TXSTATS_NDESC);
	return 0;
d7264 1
a7264 1
		    int buf_len)
d7271 1
a7271 1
		    int buf_idx, bus_addr_t paddr, int buf_len)
d7278 1
a7278 1
		 bus_size_t mapsz, int error)
d7289 1
a7289 1
	printf("%s\n", __func__);
d7367 1
a7367 1
		    const uint8_t *addr)
d7378 1
a7378 1
			   (((uint16_t)addr[(i * 2) + 1]) << 8);
d7417 1
a7417 1
	printf("%s\n", __func__);
d7476 1
a7476 1
				letoh16(hdr->rxh_tsf));
d7485 1
a7485 1
			BUS_DMASYNC_PREWRITE);
d7567 1
a7567 1
	printf("%s\n", __func__);
a7578 1

a7605 1

d7738 1
a7738 1
	  struct ieee80211_node *ni)
d7825 2
a7826 2
		sizeof(struct ieee80211_frame_ack) + IEEE80211_CRC_LEN,
		ack_rate, ic->ic_flags & ~IEEE80211_F_SHPREAMBLE);
d7832 1
a7832 1
		      __SHIFTIN(idx, BWI_TXH_ID_IDX_MASK);
d7838 1
a7838 1
			     BWI_TXH_PHY_C_ANTMODE_MASK);
d7859 1
a7859 1
				     bwi_dma_buf_addr, &paddr, BUS_DMA_NOWAIT);
d7880 1
a7880 2
					     bwi_dma_buf_addr, &paddr,
					     BUS_DMA_NOWAIT);
d8162 2
a8163 2
		    BWI_STATE_LO_RESET |
		    disable_bits)) == BWI_STATE_LO_CLOCK) {
d8232 2
a8233 2
		   BWI_STATE_LO_CLOCK | BWI_STATE_LO_GATED_CLOCK |
		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);
@


1.9
log
@Add if_detach().  Fixes kernel crash when detaching cardbus device.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.8 2007/09/13 12:33:18 mglocker Exp $	*/
a87 3
#define if_printf(ifp, str, ...)	do { printf(str); } while (0)
#define device_printf(dev, str, ...)	do { printf(str); } while (0)

d482 1
a482 1
	return flags;
d499 1
a499 1
	return CSR_READ_2(sc, data_reg);
d520 1
a520 1
		return ret;
d523 1
a523 1
		return CSR_READ_4(sc, BWI_MOBJ_DATA);
d577 1
a577 1
		return error;
d581 1
a581 1
		return error;
d591 1
a591 1
		return error;
d595 1
a595 1
		return error;
d599 1
a599 1
		return error;
d605 1
a605 1
	return 0;
d626 1
a626 1
		return error;
d640 1
a640 1
		return error;
d653 1
a653 1
		return error;
d657 1
a657 1
		return error;
d661 1
a661 1
		return error;
d665 1
a665 1
		return error;
d744 1
a744 1
			return error;
d753 2
a754 2
		if_printf(&sc->sc_ic.ic_if, "can't initialize RX ring\n");
		return error;
d763 3
a765 3
			if_printf(&sc->sc_ic.ic_if,
				  "can't initialize TX stats ring\n");
			return error;
d775 2
a776 1
	return 0;
d878 2
a879 2
		device_printf(sc->sc_dev, "TEST1 failed\n");
		return ENXIO;
d886 2
a887 2
		device_printf(sc->sc_dev, "TEST2 failed\n");
		return ENXIO;
d895 3
a897 3
		device_printf(sc->sc_dev, "%s failed, MAC status 0x%08x\n",
		    __func__, val);
		return ENXIO;
d902 3
a904 3
		device_printf(sc->sc_dev, "%s failed, intr status %08x\n",
		    __func__, val);
		return ENXIO;
d910 1
a910 1
	return 0;
d1161 3
a1163 3
		if_printf(ifp, "invalid firmware (%s): invalid size %u\n",
			  fw->fw_name, fw->fw_imglen);
		return 0;
d1173 6
a1178 5
			if_printf(ifp, "invalid firmware (%s): size mismatch, "
				  "fw %u, real %u\n", fw->fw_name,
				  betoh32(hdr->fw_size),
				  fw->fw_imglen - sizeof(*hdr));
			return 0;
d1183 4
a1186 4
		if_printf(ifp, "invalid firmware (%s): type mismatch, "
			  "fw \'%c\', target \'%c\'\n", fw->fw_name,
			  hdr->fw_type, fw_type);
		return 0;
d1190 5
a1194 4
		if_printf(ifp, "invalid firmware (%s): wrong generation, "
			  "fw %d, target %d\n", fw->fw_name,
			  hdr->fw_gen, BWI_FW_GEN_1);
		return 0;
d1196 2
a1197 1
	return 1;
d1222 3
a1224 2
			if_printf(ifp, "request firmware %s failed\n", fwname);
			return ENOMEM;
d1238 3
a1240 2
			if_printf(ifp, "request firmware %s failed\n", fwname);
			return ENOMEM;
d1254 3
a1256 3
			if_printf(ifp, "no suitible IV for MAC rev %d\n",
				  mac->mac_rev);
			return ENODEV;
d1264 3
a1266 2
			if_printf(ifp, "request firmware %s failed\n", fwname);
			return ENOMEM;
d1281 3
a1283 3
			if_printf(ifp, "no suitible ExtIV for MAC rev %d\n",
				  mac->mac_rev);
			return ENODEV;
d1291 3
a1293 2
			if_printf(ifp, "request firmware %s failed\n", fwname);
			return ENOMEM;
d1391 3
a1393 2
		if_printf(ifp, "firmware (ucode&pcm) loading timed out\n");
		return ETIMEDOUT;
d1401 3
a1403 2
		if_printf(ifp, "firmware version 4 is not supported yet\n");
		return ENODEV;
d1406 4
a1409 3
	if_printf(ifp, "firmware rev 0x%04x, patch level 0x%04x\n", fw_rev,
	    MOBJ_READ_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_FWPATCHLV));
	return 0;
d1442 1
a1442 1
		return error;
d1446 1
a1446 1
	return bwi_regwin_switch(sc, old, NULL);
d1459 1
a1459 1
		return error;
d1463 1
a1463 1
	return bwi_regwin_switch(sc, old, NULL);
d1494 3
a1496 2
			if_printf(ifp, "invalid IV image, ofs\n");
			return EINVAL;
d1505 3
a1507 3
			if_printf(ifp, "invalid ofs (0x%04x) "
				  "for %dth iv\n", ofs, i);
			return EINVAL;
d1514 3
a1516 2
				if_printf(ifp, "invalid IV image, val32\n");
				return EINVAL;
d1527 3
a1529 2
				if_printf(ifp, "invalid IV image, val16\n");
				return EINVAL;
d1542 3
a1544 2
		if_printf(ifp, "invalid IV image, size left %d\n", iv_img_size);
		return EINVAL;
d1546 2
a1547 1
	return 0;
d1555 1
d1558 2
d1562 2
a1563 2
		if_printf(0, "load IV failed\n");
		return error;
d1569 2
a1570 1
			if_printf(0, "load ExtIV failed\n");
d1572 1
a1572 1
	return error;
d1784 1
a1784 1
	return bwi_mac_config_ps(mac);
d1795 1
a1795 1
		return error;
d1809 2
a1810 2
		if_printf(&sc->sc_ic.ic_if, "can't stop MAC\n");
		return ETIMEDOUT;
d1814 1
a1814 1
	return 0;
d1843 3
a1845 2
			if_printf(&sc->sc_ic.ic_if, "config PS failed\n");
			return ETIMEDOUT;
d1849 1
a1849 1
	return 0;
d1932 1
a1932 1
		return ENXIO;
d1934 2
a1935 1
	return 0;
d1968 2
a1969 2
		device_printf(sc->sc_dev, "too many MACs\n");
		return 0;
d1978 1
a1978 1
		return 0;
d1987 1
a1987 1
		return 0;
d1999 3
a2001 3
		device_printf(sc->sc_dev, "MAC rev %u is "
			      "not supported\n", rev);
		return ENXIO;
d2013 1
a2013 1
	return 0;
d2291 1
a2291 1
	return CSR_READ_2(sc, BWI_PHY_DATA);
d2308 2
a2309 2
	device_printf(sc->sc_dev, "PHY: type %d, rev %d, ver %d\n",
	    phytype, phyrev, phyver);
d2318 3
a2320 3
			device_printf(sc->sc_dev, "unsupported 11A PHY, "
				      "rev %u\n", phyrev);
			return ENXIO;
d2337 3
a2339 3
			device_printf(sc->sc_dev, "unsupported 11B PHY, "
				      "rev %u\n", phyrev);
			return ENXIO;
d2346 3
a2348 3
			device_printf(sc->sc_dev, "unsupported 11G PHY, "
				      "rev %u\n", phyrev);
			return ENXIO;
d2357 3
a2359 3
		device_printf(sc->sc_dev, "unsupported PHY type %d\n",
			      phytype);
		return ENXIO;
d2363 2
a2364 1
	return 0;
d2396 1
a2396 1
		return 0;
d2405 2
a2406 1
	return 0;
d2443 1
a2443 1
	return (int16_t)PHY_READ(mac, BWI_PHYR_NRSSI_DATA);
d2567 5
a2571 1
{ 
d2573 2
a2574 2
	if_printf(&mac->mac_sc->sc_ic.ic_if,
		  "%s is not implemented yet\n", __func__);
d2580 4
d2585 2
a2586 2
	if_printf(&mac->mac_sc->sc_ic.ic_if,
	    "%s is not implemented yet\n", __func__);
d3115 2
a3116 1
	return val;
d3128 1
a3128 1
	return &mac->mac_rf.rf_lo[n];
d3140 1
a3140 1
	return isset(rf->rf_lo_used, idx);
d3168 1
a3168 1
	return CSR_READ_2(sc, BWI_RF_DATA_LO);
d3208 2
a3209 2
	device_printf(sc->sc_dev, "RF: manu 0x%03x, type 0x%04x, rev %u\n",
	    manu, type, rev);
d3221 3
a3223 3
			device_printf(sc->sc_dev, "only BCM2060 rev 1 RF "
				      "is supported for 11A PHY\n");
			return ENXIO;
d3235 3
a3237 3
			device_printf(sc->sc_dev, "only BCM2050/BCM2053 RF "
			    "is supported for 11B PHY\n");
			return ENXIO;
d3246 3
a3248 3
			device_printf(sc->sc_dev, "only BCM2050 RF "
			    "is supported for 11G PHY\n");
			return ENXIO;
d3260 2
a3261 2
		device_printf(sc->sc_dev, "unsupported PHY mode\n");
		return ENXIO;
d3269 2
a3270 1
	return 0;
d3319 1
d3327 2
d3507 2
a3508 2
		if_printf(&mac->mac_sc->sc_ic.ic_if,
			  "%s invalid channel!!\n", __func__);
d3562 1
a3562 1
	return bwi_get_rf_lo(mac, rf_atten, bbp_atten);
d3594 1
a3594 1
	return (PHY_READ(mac, 0x2d) >= 0xdfc);
d3607 2
a3608 1
	return ret;
d3620 1
a3620 1
		return 0;
d3654 1
a3654 1
			return 0x8f92;
d3656 1
a3656 1
			return (0x8092 | ext_lna);
d3658 1
a3658 1
			return (0x2092 | ext_lna);
d3660 1
a3660 1
			return (0x2093 | ext_lna);
d3668 1
a3668 1
			return 0xf92;
d3671 1
a3671 1
			return (0x92 | ext_lna);
d3673 1
a3673 1
			return (0x93 | ext_lna);
d3680 2
a3681 1
	return 0;
d3966 1
a3966 1
	return calib;
d3973 1
a3973 1
		return (num / den);
d3975 1
a3975 1
		return (num + den / 2) / den;
d4005 1
a4005 1
		return EINVAL;
d4015 2
a4016 1
	return 0;
d4045 2
a4046 1
		device_printf(sc->sc_dev, "invalid max txpower in sprom\n");
d4063 2
a4064 1
		device_printf(sc->sc_dev, "invalid antenna gain in sprom\n");
d4118 1
a4118 1
				return ENXIO;
d4162 1
a4162 1
	device_printf(sc->sc_dev, "TSSI-TX power map:\n");
d4167 2
a4168 2
			if_printf(&sc->sc_ic.ic_if,
				  "bwi_rf_calc_txpower failed\n");
d4179 2
a4180 1
	return error;
d4347 2
a4348 1
	return devi;
d4374 2
a4375 1
	return tp_ctrl2;
d4469 2
a4470 1
	return devi_ctrl;
d5106 2
a5107 1
	return val;
d5312 1
a5312 1
			return EINVAL;
d5314 2
a5315 1
	return 0;
d5336 2
a5337 1
	return 0;
d5345 1
a5345 1
	return CSR_READ_2(sc, ofs + BWI_SPROM_START);
d5501 3
a5503 2
				device_printf(dev, "invalid MAC address: "
					"%6D\n", ic->ic_myaddr, ":");
d5539 1
a5539 1
	return 0;
d5541 1
a5541 1
	return error;
d5560 1
a5560 1
	return 0;
d5638 1
a5638 1
		return EINVAL;
d5643 3
a5645 3
			if_printf(&sc->sc_ic.ic_if, "can't select regwin %d\n",
				  rw->rw_id);
			return error;
d5652 2
a5653 1
	return 0;
d5666 1
a5666 1
			return 0;
d5671 1
a5671 1
	return ENXIO;
d5703 2
a5704 2
		device_printf(sc->sc_dev, "can't select regwin 0\n");
		return error;
d5732 3
a5734 3
			device_printf(sc->sc_dev, "no BBP id for device id "
				      "0x%04x\n", did);
			return ENXIO;
d5755 3
a5757 3
			device_printf(sc->sc_dev, "no number of win for "
				      "BBP id 0x%04x\n", bbp_id);
			return ENXIO;
d5765 2
a5766 2
	device_printf(sc->sc_dev, "BBP id 0x%04x, BBP rev 0x%x, BBP pkg %d\n",
	    sc->sc_bbp_id, sc->sc_bbp_rev, sc->sc_bbp_pkg);
d5768 2
a5769 2
	DPRINTF(1, "%s: nregwin %d, cap 0x%08x\n", sc->sc_dev.dv_xname, nregwin,
	    sc->sc_cap);
d5784 3
a5786 3
			device_printf(sc->sc_dev,
				      "can't select regwin %d\n", i);
			return error;
d5799 2
a5800 2
				device_printf(sc->sc_dev,
				    "bus regwin already exists\n");
d5813 2
a5814 2
		device_printf(sc->sc_dev, "no MAC was found\n");
		return ENXIO;
d5820 3
a5822 2
		device_printf(sc->sc_dev, "no bus regwin was found\n");
		return ENXIO;
d5828 1
a5828 1
		return error;
d5830 1
a5830 1
	return 0;
d5855 1
a5855 1
			return error;
d5865 1
a5865 1
			return error;
d5903 1
a5903 1
					return error;
d5915 1
a5915 1
					return error;
d5929 1
a5929 1
	return bwi_regwin_switch(sc, old, NULL);
d6031 1
a6031 1
		return 0;
d6034 1
a6034 1
		return 0;
d6041 1
a6041 1
		return 0;
d6045 1
a6045 1
		return error;
d6076 1
a6076 1
	return bwi_regwin_switch(sc, old, NULL);
d6087 1
a6087 1
		return 0;
d6091 1
a6091 1
		return error;
d6114 1
a6114 1
	return bwi_regwin_switch(sc, old, NULL);
d6129 1
a6129 1
		if_printf(ifp, "can't stop\n");
d6169 2
a6170 1
			if_printf(ifp, "can't drain TX status\n");
d6197 1
d6396 2
a6397 1
			if_printf(ifp, "watchdog timeout\n");
d6451 2
a6452 1
	return 0;
a6470 1

d6472 2
a6473 1
	if_printf(ifp, "intr status 0x%08x\n", intr_status);
a6474 1

d6481 1
a6481 1
	if_printf(ifp, "TX/RX intr");
a6492 1

a6495 1

d6497 2
a6498 2
			if_printf(ifp, "intr fatal TX/RX (%d) error 0x%08x\n",
			    i, txrx_intr_status[i]);
d6518 1
a6518 1
		if_printf(ifp, "intr PHY TX error\n");
d6530 1
a6530 1
		if_printf(ifp, "EO_ATIM\n");
d6541 1
a6541 1
		if_printf(ifp, "intr noise\n");
d6576 4
a6579 3
		if_printf(0, "can't set channel to %u\n",
		    ieee80211_chan2ieee(ic, ic->ic_curchan));
		return error;
d6608 2
a6609 1
	return error;
d6619 1
a6619 1
		return error;
d6623 2
a6624 1
	return 0;
d6709 3
a6711 2
		device_printf(sc->sc_dev, "can't create parent DMA tag\n");
		return error;
d6725 3
a6727 2
		device_printf(sc->sc_dev, "can't create TX ring DMA tag\n");
		return error;
d6735 3
a6737 3
			device_printf(sc->sc_dev, "%dth TX ring "
				      "DMA alloc failed\n", i);
			return error;
d6750 3
a6752 2
		device_printf(sc->sc_dev, "can't create RX ring DMA tag\n");
		return error;
d6758 3
a6760 2
		device_printf(sc->sc_dev, "RX ring DMA alloc failed\n");
		return error;
d6766 3
a6768 3
			device_printf(sc->sc_dev,
			    "TX stats DMA alloc failed\n");
			return error;
d6833 2
a6834 2
		device_printf(sc->sc_dev, "can't allocate DMA mem\n");
		return error;
d6838 1
a6838 2
				bwi_dma_ring_addr, &rd->rdata_paddr,
				BUS_DMA_WAITOK);
d6840 1
a6840 1
		device_printf(sc->sc_dev, "can't load DMA mem\n");
d6843 1
a6843 1
		return error;
d6847 2
a6848 1
	return 0;
d6877 3
a6879 3
		device_printf(sc->sc_dev, "can't create txstats ring "
		    "DMA tag\n");
		return error;
d6886 2
a6887 2
		device_printf(sc->sc_dev, "can't allocate txstats ring "
		    "DMA mem\n");
d6890 1
a6890 1
		return error;
d6898 2
a6899 1
		device_printf(sc->sc_dev, "can't load txstats ring DMA mem\n");
d6904 1
a6904 1
		return error;
d6919 3
a6921 2
		device_printf(sc->sc_dev, "can't create txstats DMA tag\n");
		return error;
d6928 2
a6929 1
		device_printf(sc->sc_dev, "can't allocate txstats DMA mem\n");
d6932 1
a6932 1
		return error;
d6939 2
a6940 1
		device_printf(sc->sc_dev, "can't load txstats DMA mem\n");
d6944 1
a6944 1
		return error;
d7005 3
a7007 2
		device_printf(sc->sc_dev, "can't create mbuf DMA tag\n");
		return error;
d7022 2
a7023 2
				device_printf(sc->sc_dev, "can't create "
					      "%dth tbd, %dth DMA map\n", i, j);
d7042 2
a7043 2
		device_printf(sc->sc_dev,
		    "can't create spare RX buf DMA map\n");
d7051 2
a7052 2
			device_printf(sc->sc_dev, "can't create %dth "
			    "RX buf DMA map\n", j);
d7205 3
a7207 3
			if_printf(&sc->sc_ic.ic_if,
				  "can't allocate %dth RX buffer\n", i);
			return error;
d7274 1
a7274 1
	return EOPNOTSUPP;
d7281 1
a7281 1
	return EOPNOTSUPP;
d7288 1
a7288 1
	return EOPNOTSUPP;
d7424 1
a7424 1
	return 0;
d7484 2
a7485 2
			if_printf(ifp, "zero length data, hdr_extra %d\n",
				  hdr_extra);
d7561 1
a7561 1
		if_printf(0, "reset rx ring timedout\n");
d7620 2
a7621 2
		if_printf(0, "wait for TX ring(%d) stable timed out\n",
			  ring_idx);
d7634 2
a7635 1
		if_printf(0, "reset TX ring (%d) timed out\n", ring_idx);
d7684 14
a7697 14
	case 2:		return 0xa;
	case 4:		return 0x14;
	case 11:	return 0x37;
	case 22:	return 0x6e;
	case 44:	return 0xdc;

	case 12:	return 0xb;
	case 18:	return 0xf;
	case 24:	return 0xa;
	case 36:	return 0xe;
	case 48:	return 0x9;
	case 72:	return 0xd;
	case 96:	return 0x8;
	case 108:	return 0xc;
d7827 2
a7828 2
		if_printf(&ic->ic_if, "invalid rate %u or fallback rate %u",
			  rate, rate_fb);
d7839 3
a7841 2
		if_printf(&ic->ic_if, "prepend TX header failed\n");
		return ENOBUFS;
d7892 2
a7893 1
		if_printf(&ic->ic_if, "can't load TX buffer (1) %d\n", error);
d7902 2
a7903 1
			if_printf(&ic->ic_if, "can't defrag TX buffer\n");
d7914 2
a7915 2
			if_printf(&ic->ic_if, "can't load TX buffer (2) %d\n",
				  error);
d7935 2
a7936 2
	if_printf(&ic->ic_if, "idx %d, pkt_len %d, buflen %d\n",
		  idx, pkt_len, m->m_pkthdr.len);
d7950 1
a7950 1
	return error;
d8007 1
a8007 1
		if_printf(ifp, "zero tx id\n");
d8017 1
a8017 1
	if_printf(ifp, "txeof idx %d\n", buf_idx);
a8018 1

d8090 2
a8091 1
	return bwi_set_clock_mode(sc, clk_mode);
d8113 1
a8113 1
		return 0;
d8117 1
a8117 1
		return error;
d8126 1
a8126 1
	return bwi_regwin_switch(sc, old, NULL);
d8139 1
a8139 1
		return error;
d8147 1
a8147 1
	return bwi_regwin_switch(sc, old, NULL);
d8155 1
a8155 1
		return "COM";
d8157 1
a8157 1
		return "PCI";
d8159 1
a8159 1
		return "MAC";
d8161 1
a8161 1
		return "PCIE";
d8164 2
a8165 1
	return NULL;
d8178 1
a8178 1
		return BWI_STATE_LO_DISABLE1;
d8180 1
a8180 1
		return BWI_STATE_LO_DISABLE2;
d8182 1
a8182 1
		return (BWI_STATE_LO_DISABLE1 | BWI_STATE_LO_DISABLE2);
d8198 1
a8198 1
		return 1;
d8202 1
a8202 1
		return 0;
d8242 2
a8243 2
		device_printf(sc->sc_dev, "%s disable clock timeout\n",
			      bwi_regwin_name(rw));
d8255 2
a8256 2
		device_printf(sc->sc_dev, "%s wait BUSY unset timeout\n",
			      bwi_regwin_name(rw));
@


1.8
log
@Ops, remove temporary debug line.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.7 2007/09/13 12:31:47 mglocker Exp $	*/
d5506 1
@


1.7
log
@Forgot to set psc->psc_pcitag.  Replace all PCI/Cardbus config space
functions with our new one.  Attachment seems to work now mainly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.6 2007/09/13 08:28:37 mglocker Exp $	*/
a5490 2

	printf("YEAH\n");
@


1.6
log
@Enable access to PCI and Cardbus config space from the driver.  Lets us
power on the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.5 2007/09/12 22:22:05 mglocker Exp $	*/
a95 2
#define pci_write_config(dev, reg, val, width)
#define pci_read_config(dev, reg, width)	(0)
d5492 2
d5561 2
a5563 2
#if 0
	uint32_t gpio_out, gpio_en;
d5565 3
a5567 3
	pci_read_config(sc->sc_dev, BWI_PCIR_GPIO_IN, 4); /* dummy read */
	gpio_out = pci_read_config(sc->sc_dev, BWI_PCIR_GPIO_OUT, 4);
	gpio_en = pci_read_config(sc->sc_dev, BWI_PCIR_GPIO_ENABLE, 4);
d5576 4
a5579 5
	pci_write_config(sc->sc_dev, BWI_PCIR_GPIO_OUT, gpio_out, 4);
	pci_write_config(sc->sc_dev, BWI_PCIR_GPIO_ENABLE, gpio_en, 4);
	return 0;
#endif
	return (1);
d5617 2
a5618 2
		pci_write_config(sc->sc_dev, BWI_PCIR_SEL_REGWIN, win, 4);
		if (pci_read_config(sc->sc_dev, BWI_PCIR_SEL_REGWIN, 4) == win)
d5819 1
a5819 1
		val = pci_read_config(sc->sc_dev, BWI_PCIR_INTCTL, 4);
d5821 1
a5821 1
		pci_write_config(sc->sc_dev, BWI_PCIR_INTCTL, val, 4);
d5932 1
a5932 1
		val = pci_read_config(sc->sc_dev, BWI_PCIR_GPIO_OUT, 4);
@


1.5
log
@Spacing run.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.4 2007/09/12 20:30:09 mglocker Exp $	*/
a5519 2
	printf("%s\n", __func__);
#if 0
d5523 3
a5525 1
	gpio_in = pci_read_config(sc->sc_dev, BWI_PCIR_GPIO_IN, 4);
d5529 2
a5530 2
	gpio_out = pci_read_config(sc->sc_dev, BWI_PCIR_GPIO_OUT, 4);
	gpio_en = pci_read_config(sc->sc_dev, BWI_PCIR_GPIO_ENABLE, 4);
d5540 2
a5541 2
	pci_write_config(sc->sc_dev, BWI_PCIR_GPIO_OUT, gpio_out, 4);
	pci_write_config(sc->sc_dev, BWI_PCIR_GPIO_ENABLE, gpio_en, 4);
d5547 1
a5547 1
		pci_write_config(sc->sc_dev, BWI_PCIR_GPIO_OUT, gpio_out, 4);
d5553 3
a5555 4
	status = pci_read_config(sc->sc_dev, PCIR_STATUS, 2);
	status &= ~PCIM_STATUS_STABORT;
	pci_write_config(sc->sc_dev, PCIR_STATUS, status, 2);
#endif
@


1.4
log
@For now just return directly from the interrupt handler, or my amd64 will
crash badly.
@
text
@d1 2
a2 1
/*	$OpenBSD: bwi.c,v 1.3 2007/09/12 15:04:07 jsg Exp $	*/
d119 20
a138 25
int		 bwi_mac_test(struct bwi_mac *);
int		 bwi_mac_get_property(struct bwi_mac *);

void		 bwi_mac_set_retry_lim(struct bwi_mac *,
			const struct bwi_retry_lim *);
void		 bwi_mac_set_ackrates(struct bwi_mac *,
			const struct ieee80211_rateset *);

int		 bwi_mac_gpio_init(struct bwi_mac *);
int		 bwi_mac_gpio_fini(struct bwi_mac *);
void		 bwi_mac_opmode_init(struct bwi_mac *);
void		 bwi_mac_hostflags_init(struct bwi_mac *);
void		 bwi_mac_bss_param_init(struct bwi_mac *);

int		 bwi_mac_fw_alloc(struct bwi_mac *);
void		 bwi_mac_fw_free(struct bwi_mac *);
int		 bwi_mac_fw_load(struct bwi_mac *);
int		 bwi_mac_fw_init(struct bwi_mac *);
int		 bwi_mac_fw_load_iv(struct bwi_mac *, const struct fw_image *);

void		 bwi_mac_setup_tpctl(struct bwi_mac *);
void		 bwi_mac_adjust_tpctl(struct bwi_mac *, int, int);

void		 bwi_mac_lock(struct bwi_mac *);
void		 bwi_mac_unlock(struct bwi_mac *);
d143 11
a153 15
void		 bwi_phy_init_11a(struct bwi_mac *);
void		 bwi_phy_init_11g(struct bwi_mac *);
void		 bwi_phy_init_11b_rev2(struct bwi_mac *);
void		 bwi_phy_init_11b_rev4(struct bwi_mac *);
void		 bwi_phy_init_11b_rev5(struct bwi_mac *);
void		 bwi_phy_init_11b_rev6(struct bwi_mac *);

void		 bwi_phy_config_11g(struct bwi_mac *);
void		 bwi_phy_config_agc(struct bwi_mac *);

void		 bwi_tbl_write_2(struct bwi_mac *mac, uint16_t, uint16_t);
void		 bwi_tbl_write_4(struct bwi_mac *mac, uint16_t, uint32_t);

void		 bwi_plcp_header(void *, int, uint8_t) __unused;

d231 20
a250 25
int		 bwi_rf_calc_txpower(int8_t *, uint8_t, const int16_t[]);
void		 bwi_rf_work_around(struct bwi_mac *, u_int);
int		 bwi_rf_gain_max_reached(struct bwi_mac *, int);
uint16_t	 bwi_rf_calibval(struct bwi_mac *);
uint16_t	 bwi_rf_get_tp_ctrl2(struct bwi_mac *);
uint32_t	 bwi_rf_lo_devi_measure(struct bwi_mac *, uint16_t);
void		 bwi_rf_lo_measure(struct bwi_mac *,
			const struct bwi_rf_lo *, struct bwi_rf_lo *, uint8_t);

void		 bwi_rf_lo_write(struct bwi_mac *, const struct bwi_rf_lo *);

void		 bwi_rf_set_nrssi_ofs_11g(struct bwi_mac *);
void		 bwi_rf_calc_nrssi_slope_11b(struct bwi_mac *);
void		 bwi_rf_calc_nrssi_slope_11g(struct bwi_mac *);
void		 bwi_rf_set_nrssi_thr_11b(struct bwi_mac *);
void		 bwi_rf_set_nrssi_thr_11g(struct bwi_mac *);

void		 bwi_rf_init_sw_nrssi_table(struct bwi_mac *);

void		 bwi_rf_on_11a(struct bwi_mac *);
void		 bwi_rf_on_11bg(struct bwi_mac *);

void		 bwi_rf_off_11a(struct bwi_mac *);
void		 bwi_rf_off_11bg(struct bwi_mac *);
void		 bwi_rf_off_11g_rev5(struct bwi_mac *);
a258 1

d283 82
a364 90

int		 bwi_init(struct ifnet *);
int		 bwi_ioctl(struct ifnet *, u_long, caddr_t);
void		 bwi_start(struct ifnet *);
void		 bwi_watchdog(struct ifnet *);
int		 bwi_newstate(struct ieee80211com *, enum ieee80211_state, int);
void		 bwi_updateslot(struct ieee80211com *);
int		 bwi_media_change(struct ifnet *);

void		 bwi_next_scan(void *);
void		 bwi_calibrate(void *);

int		 bwi_stop(struct bwi_softc *);
int		 bwi_newbuf(struct bwi_softc *, int, int) __unused;
int		 bwi_encap(struct bwi_softc *, int, struct mbuf *,
			  struct ieee80211_node *);

void		 bwi_init_rxdesc_ring32(struct bwi_softc *, uint32_t,
				       bus_addr_t, int, int) __unused;
void		 bwi_reset_rx_ring32(struct bwi_softc *, uint32_t);

int		 bwi_init_tx_ring32(struct bwi_softc *, int) __unused;
int		 bwi_init_rx_ring32(struct bwi_softc *) __unused;
int		 bwi_init_txstats32(struct bwi_softc *) __unused;
void		 bwi_free_tx_ring32(struct bwi_softc *, int) __unused;
void		 bwi_free_rx_ring32(struct bwi_softc *) __unused;
void		 bwi_free_txstats32(struct bwi_softc *) __unused;
void		 bwi_setup_rx_desc32(struct bwi_softc *, int, bus_addr_t, int) __unused;
void		 bwi_setup_tx_desc32(struct bwi_softc *, struct bwi_ring_data *,
				    int, bus_addr_t, int) __unused;
void		 bwi_rxeof32(struct bwi_softc *) __unused;
void		 bwi_start_tx32(struct bwi_softc *, uint32_t, int) __unused;
void		 bwi_txeof_status32(struct bwi_softc *) __unused;

int		 bwi_init_tx_ring64(struct bwi_softc *, int) __unused;
int		 bwi_init_rx_ring64(struct bwi_softc *) __unused;
int		 bwi_init_txstats64(struct bwi_softc *) __unused;
void		 bwi_free_tx_ring64(struct bwi_softc *, int) __unused;
void		 bwi_free_rx_ring64(struct bwi_softc *) __unused;
void		 bwi_free_txstats64(struct bwi_softc *) __unused;
void		 bwi_setup_rx_desc64(struct bwi_softc *, int, bus_addr_t, int) __unused;
void		 bwi_setup_tx_desc64(struct bwi_softc *, struct bwi_ring_data *,
				    int, bus_addr_t, int) __unused;
void		 bwi_rxeof64(struct bwi_softc *) __unused;
void		 bwi_start_tx64(struct bwi_softc *, uint32_t, int) __unused;
void		 bwi_txeof_status64(struct bwi_softc *) __unused;

void		 bwi_rxeof(struct bwi_softc *, int);
void		 _bwi_txeof(struct bwi_softc *, uint16_t);
void		 bwi_txeof(struct bwi_softc *);
void		 bwi_txeof_status(struct bwi_softc *, int);
void		 bwi_enable_intrs(struct bwi_softc *, uint32_t);
void		 bwi_disable_intrs(struct bwi_softc *, uint32_t);

int		 bwi_dma_alloc(struct bwi_softc *);
void		 bwi_dma_free(struct bwi_softc *);
int		 bwi_dma_ring_alloc(struct bwi_softc *, bus_dma_tag_t,
				   struct bwi_ring_data *, bus_size_t,
				   uint32_t) __unused;
int		 bwi_dma_mbuf_create(struct bwi_softc *) __unused;
void		 bwi_dma_mbuf_destroy(struct bwi_softc *, int, int) __unused;
int		 bwi_dma_txstats_alloc(struct bwi_softc *, uint32_t, bus_size_t) __unused;
void		 bwi_dma_txstats_free(struct bwi_softc *) __unused;
void		 bwi_dma_ring_addr(void *, bus_dma_segment_t *, int, int) __unused;
void		 bwi_dma_buf_addr(void *, bus_dma_segment_t *, int,
				 bus_size_t, int) __unused;

void		 bwi_power_on(struct bwi_softc *, int);
int		 bwi_power_off(struct bwi_softc *, int);
int		 bwi_set_clock_mode(struct bwi_softc *, enum bwi_clock_mode);
int		 bwi_set_clock_delay(struct bwi_softc *);
void		 bwi_get_clock_freq(struct bwi_softc *, struct bwi_clock_freq *);
int		 bwi_get_pwron_delay(struct bwi_softc *sc);
void		 bwi_set_addr_filter(struct bwi_softc *, uint16_t,
				    const uint8_t *);
void		 bwi_set_bssid(struct bwi_softc *, const uint8_t *);
int		 bwi_set_chan(struct bwi_softc *, u_int8_t);

void		 bwi_get_card_flags(struct bwi_softc *);
void		 bwi_get_eaddr(struct bwi_softc *, uint16_t, uint8_t *);

int		 bwi_bus_attach(struct bwi_softc *);
int		 bwi_bbp_attach(struct bwi_softc *);
int		 bwi_bbp_power_on(struct bwi_softc *, enum bwi_clock_mode);
void		 bwi_bbp_power_off(struct bwi_softc *);

const char 	*bwi_regwin_name(const struct bwi_regwin *) __unused;
uint32_t	 bwi_regwin_disable_bits(struct bwi_softc *);
void		 bwi_regwin_info(struct bwi_softc *, uint16_t *, uint8_t *);
int		 bwi_regwin_select(struct bwi_softc *, int);
d367 4
a370 5
int		 bwi_fwimage_is_valid(struct bwi_softc *,
		     const struct fw_image *, uint8_t);
void		 bwi_mac_balance_atten(int *, int *);
int16_t		 bwi_nrssi_11g(struct bwi_mac *);

d374 13
a386 15
int		 bwi_rf_lo_isused(struct bwi_mac *, const struct bwi_rf_lo *);
uint8_t		 _bwi_rf_lo_update(struct bwi_mac *, uint16_t);


uint16_t	 bwi_bitswap4(uint16_t);
uint16_t	 bwi_phy812_value(struct bwi_mac *, uint16_t);
int32_t		 _bwi_adjust_devide(int32_t, int32_t);
int32_t		 _nrssi_threshold(const struct bwi_rf *, int32_t);

void		 bwi_setup_desc32(struct bwi_softc *, struct bwi_desc32 *,
		     int, int, bus_addr_t, int, int);
void		 bwi_ofdm_plcp_header(uint32_t *, int, uint8_t);
void		 bwi_ds_plcp_header(struct ieee80211_ds_plcp_hdr *, int,
		     uint8_t);

a444 2


d522 1
a522 1
			    BWI_MOBJ_CTRL_VAL(obj_id, ofs + 1));
d552 1
a552 1
		   uint32_t v)
a560 1

d562 1
a562 1
			    BWI_MOBJ_CTRL_VAL(obj_id, ofs + 1));
d650 2
a651 2
		    BWI_MAC_STATUS_UCODE_JUMP0 |
		    BWI_MAC_STATUS_IHREN);
d838 2
a839 2
			 (rf->rf_rev < 6 ? BWI_RF_ATTEN_MAX0
			 		 : BWI_RF_ATTEN_MAX1));
d853 1
a853 1
		     tpctl->rf_atten);
d858 1
a858 1
			__SHIFTIN(tpctl->tp_ctrl1, BWI_RFR_TXPWR1_MASK));
d900 1
a900 1
			      __func__, val);
d907 1
a907 1
			      __func__, val);
d1157 1
a1157 1
		     uint8_t fw_type)
d1347 2
a1348 2
		    BWI_MOBJ_CTRL_VAL(
		    BWI_FW_UCODE_MOBJ | BWI_WR_MOBJ_AUTOINC, 0));
d1362 1
a1362 1
		    BWI_MOBJ_CTRL_VAL(BWI_FW_PCM_MOBJ, 0x01ea));
d1366 1
a1366 1
		    BWI_MOBJ_CTRL_VAL(BWI_FW_PCM_MOBJ, 0x01eb));
d1374 3
a1376 3
		    BWI_MAC_STATUS_UCODE_START |
		    BWI_MAC_STATUS_IHREN |
		    BWI_MAC_STATUS_INFRA);
a1378 1

a1390 1

d1402 1
a1402 1
		  MOBJ_READ_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_FWPATCHLV));
d1581 4
a1584 4
			BWI_MAC_STATUS_PASS_CTL |
			BWI_MAC_STATUS_PASS_BADPLCP |
			BWI_MAC_STATUS_PASS_BADFCS |
			BWI_MAC_STATUS_PROMISC);
d1706 1
a1706 1
		     IEEE80211_CW_MAX);
d1714 1
a1714 1
		     lim->shretry);
d1716 1
a1716 1
		     lim->lgretry);
d1720 1
a1720 1
		     lim->shretry_fb);
d1722 1
a1722 1
		     lim->lgretry_fb);
d1904 2
a1905 1
			DPRINTF(1, "%s: 32bit bus space\n", sc->sc_dev.dv_xname);
d1909 2
a1910 1
			DPRINTF(1, "%s: 30bit bus space\n", sc->sc_dev.dv_xname);
d2146 1
a2146 1
				BWI_COMM_MOBJ_TSSI_OFDM);
d2184 1
a2184 1
			(BWI_RF_ATTEN_FACTOR * rf_atten_adj);
d2292 1
a2292 1
		      phytype, phyrev, phyver);
d2406 1
a2406 1
		 phy->phy_tbl_ctrl != 0);
d2496 1
a2496 1
				 (tpctl->tp_ctrl1 << 4) | tpctl->tp_ctrl2);
d2503 1
a2503 1
					 tpctl->tp_ctrl2 << 12);
d2559 1
a2559 1
		  "%s is not implemented yet\n", __func__);
a2802 1

d2821 1
a2821 1
					bwi_phy_freq_11g_rev1[i]);
d2827 1
a2827 1
					bwi_phy_noise_11g_rev1[i]);
d2834 1
a2834 1
					bwi_phy_rotor_11g_rev1[i]);
d2856 1
a2856 1
					bwi_phy_noise_11g[i]);
d2896 1
a2896 1
					bwi_phy_delay_11g_rev1[i]);
a2931 1

a3084 1

a3088 1

d3181 1
a3181 1
		      manu, type, rev);
d3208 1
a3208 1
				      "is supported for 11B PHY\n");
d3219 1
a3219 1
				      "is supported for 11G PHY\n");
a3957 1

a3971 1

d4370 1
a4370 1
						rf_atten, 2 * bbp_atten);
d4374 1
a4374 1
						init_rf_atten, 0);
d5124 1
a5124 1
				BWI_COMM_MOBJ_TSSI_DS + (i * 2), val);
d5129 1
a5129 1
				BWI_COMM_MOBJ_TSSI_OFDM + (i * 2), val);
d5187 2
a5188 2
		 ant_mode == BWI_ANT_MODE_1 ||
		 ant_mode == BWI_ANT_MODE_AUTO);
d5238 1
a5238 1
			    0xfc3f, val);
d5240 1
a5240 1
			    0xfc3f, val);
d5242 1
a5242 1
			    0xfc3f, val);
d5306 1
a5306 2
		 int ndesc, int desc_idx, bus_addr_t paddr, int buf_len,
		 int tx)
d5324 2
a5325 2
			BWI_DESC32_C_FRAME_END |
			BWI_DESC32_C_INTR;
d5473 3
a5475 3
		      IEEE80211_C_SHPREAMBLE |
		      IEEE80211_C_WEP |
		      IEEE80211_C_MONITOR;
d5586 1
a5586 1
		  struct bwi_regwin **old_rw)
d5639 2
a5640 2
		sc->sc_dev.dv_xname,
		*type, *rev, __SHIFTOUT(val, BWI_ID_HI_REGWIN_VENDOR_MASK));
d5721 1
a5721 1
		      sc->sc_bbp_id, sc->sc_bbp_rev, sc->sc_bbp_pkg);
d5755 1
a5755 1
					      "bus regwin already exists\n");
d5758 1
a5758 1
						  rw_type, rw_rev);
d5834 1
a5834 1
			      BWI_BUS_CONFIG_PREFETCH | BWI_BUS_CONFIG_BURST);
d5909 1
a5909 1
			htobe16(bwi_read_sprom(sc, eaddr_ofs + 2 * i));
d6017 2
a6018 2
			      BWI_CLOCK_CTRL_IGNPLL |
			      BWI_CLOCK_CTRL_NODYN);
d6062 1
a6062 1
				howmany(freq.clkfreq_max * 150, 1000000));
d6064 1
a6064 1
				howmany(freq.clkfreq_max * 15, 1000000));
d6451 1
a6451 1
				  i, txrx_intr_status[i]);
d6530 1
a6530 1
			  ieee80211_chan2ieee(ic, ic->ic_curchan));
d6652 6
a6657 6
				   lowaddr, BUS_SPACE_MAXADDR,
				   NULL, NULL,
				   MAXBSIZE,
				   BUS_SPACE_UNRESTRICTED,
				   BUS_SPACE_MAXSIZE_32BIT,
				   0, &sc->sc_parent_dtag);
d6669 4
a6672 4
				   BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
				   NULL, NULL,
				   tx_ring_sz, 1, BUS_SPACE_MAXSIZE_32BIT,
				   0, &sc->sc_txring_dtag);
d6693 4
a6696 4
				   BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
				   NULL, NULL,
				   rx_ring_sz, 1, BUS_SPACE_MAXSIZE_32BIT,
				   0, &sc->sc_rxring_dtag);
d6703 1
a6703 1
				   rx_ring_sz, TXRX_CTRL(0));
d6713 1
a6713 1
				      "TX stats DMA alloc failed\n");
d6738 1
a6738 1
						  rd->rdata_dmap);
d6740 2
a6741 2
						rd->rdata_desc,
						rd->rdata_dmap);
d6753 1
a6753 1
					rd->rdata_dmap);
d6818 4
a6821 4
				   BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
				   NULL, NULL,
				   dma_size, 1, BUS_SPACE_MAXSIZE_32BIT,
				   0, &st->stats_ring_dtag);
d6824 1
a6824 1
			      "DMA tag\n");
d6829 2
a6830 2
				 BUS_DMA_WAITOK | BUS_DMA_ZERO,
				 &st->stats_ring_dmap);
d6833 1
a6833 1
			      "DMA mem\n");
d6840 3
a6842 3
				st->stats_ring, dma_size,
				bwi_dma_ring_addr, &st->stats_ring_paddr,
				BUS_DMA_WAITOK);
d6846 1
a6846 1
				st->stats_ring_dmap);
d6856 1
a6856 1
			   BWI_ALIGN);
d6859 4
a6862 4
				   BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
				   NULL, NULL,
				   dma_size, 1, BUS_SPACE_MAXSIZE_32BIT,
				   0, &st->stats_dtag);
d6869 2
a6870 2
				 BUS_DMA_WAITOK | BUS_DMA_ZERO,
				 &st->stats_dmap);
d6879 2
a6880 2
				dma_size, bwi_dma_ring_addr, &st->stats_paddr,
				BUS_DMA_WAITOK);
d6909 1
a6909 1
				st->stats_ring_dmap);
d6942 4
a6945 4
				   BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR,
				   NULL, NULL, MCLBYTES, 1,
				   BUS_SPACE_MAXSIZE_32BIT,
				   0, &sc->sc_buf_dtag);
d6984 1
a6984 1
			      "can't create spare RX buf DMA map\n");
d6990 1
a6990 1
					  &rbd->rbd_buf[j].rb_dmap);
d6993 1
a6993 1
				      "RX buf DMA map\n", j);
d6997 1
a6997 1
					rbd->rbd_buf[j].rb_dmap);
d7000 1
a7000 1
					   rbd->rbd_tmp_dmap);
d7031 1
a7031 1
						  tb->tb_dmap);
d7091 1
a7091 1
			BUS_DMASYNC_PREWRITE);
d7097 2
a7098 2
	      __SHIFTIN(BWI_TXRX32_RINGINFO_FUNC_TXRX,
	      		BWI_TXRX32_RINGINFO_FUNC_MASK);
d7120 1
a7120 1
	      __SHIFTIN(BWI_TXRX32_RINGINFO_FUNC_TXRX,
d7125 2
a7126 2
	      __SHIFTIN(addr_hi, BWI_TXRX32_CTRL_ADDRHI_MASK) |
	      BWI_TXRX32_CTRL_ENABLE;
d7130 1
a7130 1
		    (ndesc - 1) * sizeof(struct bwi_desc32));
d7193 1
a7193 1
		    int buf_len)
d7199 1
a7199 1
			 paddr, buf_len, 0);
d7204 1
a7204 1
		    int buf_idx, bus_addr_t paddr, int buf_len)
d7208 1
a7208 1
			 paddr, buf_len, 1);
d7291 2
a7292 2
				     bwi_dma_buf_addr, &paddr,
				     init ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT);
d7329 1
a7329 1
			    rxbuf->rb_mbuf->m_len - sizeof(*hdr));
d7342 1
a7342 1
		    BWI_ADDR_FILTER_CTRL_SET | addr_ofs);
d7469 1
a7469 1
		  sizeof(struct bwi_desc32);
d7474 1
a7474 1
		    end_idx * sizeof(struct bwi_desc32));
a7490 1

a7502 1

d7654 1
a7654 1
	       __SHIFTIN(pkt_len, IEEE80211_OFDM_PLCP_LEN_MASK);
d7897 1
a7897 1
		    idx * sizeof(struct bwi_desc32));
d7917 1
a7917 1
		  sizeof(struct bwi_desc32);
d7922 1
a7922 1
		    end_idx * sizeof(struct bwi_desc32));
d8227 3
a8229 3
		   BWI_STATE_LO_CLOCK |
		   BWI_STATE_LO_GATED_CLOCK |
		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);
d8248 2
a8249 2
		   BWI_STATE_LO_GATED_CLOCK |
		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);
d8258 1
a8258 1
		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);
@


1.3
log
@Tweak bwi_attach() a little.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.2 2007/09/12 14:19:42 jsg Exp $	*/
d6447 2
@


1.2
log
@destatic/deinline
@
text
@d1 1
a1 1
/*	$OpenBSD: bwi.c,v 1.1 2007/09/12 13:13:12 jsg Exp $	*/
d5376 2
d5516 1
a5530 1
	bwi_detach(sc);
@


1.1
log
@Initial port of Sepherosa Ziehau's DragonFlyBSD driver
for Broadcom AirForce wireless devices.

Not yet functional, things like DMA and firmware handling
haven't been converted yet.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d118 2
a119 2
static int	bwi_mac_test(struct bwi_mac *);
static int	bwi_mac_get_property(struct bwi_mac *);
d121 1
a121 1
static void	bwi_mac_set_retry_lim(struct bwi_mac *,
d123 1
a123 1
static void	bwi_mac_set_ackrates(struct bwi_mac *,
d126 11
a136 11
static int	bwi_mac_gpio_init(struct bwi_mac *);
static int	bwi_mac_gpio_fini(struct bwi_mac *);
static void	bwi_mac_opmode_init(struct bwi_mac *);
static void	bwi_mac_hostflags_init(struct bwi_mac *);
static void	bwi_mac_bss_param_init(struct bwi_mac *);

static int	bwi_mac_fw_alloc(struct bwi_mac *);
static void	bwi_mac_fw_free(struct bwi_mac *);
static int	bwi_mac_fw_load(struct bwi_mac *);
static int	bwi_mac_fw_init(struct bwi_mac *);
static int	bwi_mac_fw_load_iv(struct bwi_mac *, const struct fw_image *);
d138 2
a139 2
static void	bwi_mac_setup_tpctl(struct bwi_mac *);
static void	bwi_mac_adjust_tpctl(struct bwi_mac *, int, int);
d141 2
a142 2
static void	bwi_mac_lock(struct bwi_mac *);
static void	bwi_mac_unlock(struct bwi_mac *);
d147 6
a152 6
static void	bwi_phy_init_11a(struct bwi_mac *);
static void	bwi_phy_init_11g(struct bwi_mac *);
static void	bwi_phy_init_11b_rev2(struct bwi_mac *);
static void	bwi_phy_init_11b_rev4(struct bwi_mac *);
static void	bwi_phy_init_11b_rev5(struct bwi_mac *);
static void	bwi_phy_init_11b_rev6(struct bwi_mac *);
d154 2
a155 2
static void	bwi_phy_config_11g(struct bwi_mac *);
static void	bwi_phy_config_agc(struct bwi_mac *);
d157 2
a158 2
static void	bwi_tbl_write_2(struct bwi_mac *mac, uint16_t, uint16_t);
static void	bwi_tbl_write_4(struct bwi_mac *mac, uint16_t, uint32_t);
d160 1
a160 1
static void	bwi_plcp_header(void *, int, uint8_t) __unused;
d239 7
a245 7
static int	bwi_rf_calc_txpower(int8_t *, uint8_t, const int16_t[]);
static void	bwi_rf_work_around(struct bwi_mac *, u_int);
static int	bwi_rf_gain_max_reached(struct bwi_mac *, int);
static uint16_t	bwi_rf_calibval(struct bwi_mac *);
static uint16_t	bwi_rf_get_tp_ctrl2(struct bwi_mac *);
static uint32_t	bwi_rf_lo_devi_measure(struct bwi_mac *, uint16_t);
static void	bwi_rf_lo_measure(struct bwi_mac *,
a246 1
static uint8_t	_bwi_rf_lo_update(struct bwi_mac *, uint16_t);
d248 1
a248 1
static void	bwi_rf_lo_write(struct bwi_mac *, const struct bwi_rf_lo *);
d250 14
a263 14
static void	bwi_rf_set_nrssi_ofs_11g(struct bwi_mac *);
static void	bwi_rf_calc_nrssi_slope_11b(struct bwi_mac *);
static void	bwi_rf_calc_nrssi_slope_11g(struct bwi_mac *);
static void	bwi_rf_set_nrssi_thr_11b(struct bwi_mac *);
static void	bwi_rf_set_nrssi_thr_11g(struct bwi_mac *);

static void	bwi_rf_init_sw_nrssi_table(struct bwi_mac *);

static void	bwi_rf_on_11a(struct bwi_mac *);
static void	bwi_rf_on_11bg(struct bwi_mac *);

static void	bwi_rf_off_11a(struct bwi_mac *);
static void	bwi_rf_off_11bg(struct bwi_mac *);
static void	bwi_rf_off_11g_rev5(struct bwi_mac *);
d283 29
a311 14
static int	bwi_init(struct ifnet *);
static int	bwi_ioctl(struct ifnet *, u_long, caddr_t);
static void	bwi_start(struct ifnet *);
static void	bwi_watchdog(struct ifnet *);
static int	bwi_newstate(struct ieee80211com *, enum ieee80211_state, int);
static void	bwi_updateslot(struct ieee80211com *);
static int	bwi_media_change(struct ifnet *);

static void	bwi_next_scan(void *);
static void	bwi_calibrate(void *);

static int	bwi_stop(struct bwi_softc *);
static int	bwi_newbuf(struct bwi_softc *, int, int) __unused;
static int	bwi_encap(struct bwi_softc *, int, struct mbuf *,
d314 1
a314 1
static void	bwi_init_rxdesc_ring32(struct bwi_softc *, uint32_t,
d316 1
a316 1
static void	bwi_reset_rx_ring32(struct bwi_softc *, uint32_t);
d318 8
a325 8
static int	bwi_init_tx_ring32(struct bwi_softc *, int) __unused;
static int	bwi_init_rx_ring32(struct bwi_softc *) __unused;
static int	bwi_init_txstats32(struct bwi_softc *) __unused;
static void	bwi_free_tx_ring32(struct bwi_softc *, int) __unused;
static void	bwi_free_rx_ring32(struct bwi_softc *) __unused;
static void	bwi_free_txstats32(struct bwi_softc *) __unused;
static void	bwi_setup_rx_desc32(struct bwi_softc *, int, bus_addr_t, int) __unused;
static void	bwi_setup_tx_desc32(struct bwi_softc *, struct bwi_ring_data *,
d327 12
a338 12
static void	bwi_rxeof32(struct bwi_softc *) __unused;
static void	bwi_start_tx32(struct bwi_softc *, uint32_t, int) __unused;
static void	bwi_txeof_status32(struct bwi_softc *) __unused;

static int	bwi_init_tx_ring64(struct bwi_softc *, int) __unused;
static int	bwi_init_rx_ring64(struct bwi_softc *) __unused;
static int	bwi_init_txstats64(struct bwi_softc *) __unused;
static void	bwi_free_tx_ring64(struct bwi_softc *, int) __unused;
static void	bwi_free_rx_ring64(struct bwi_softc *) __unused;
static void	bwi_free_txstats64(struct bwi_softc *) __unused;
static void	bwi_setup_rx_desc64(struct bwi_softc *, int, bus_addr_t, int) __unused;
static void	bwi_setup_tx_desc64(struct bwi_softc *, struct bwi_ring_data *,
d340 14
a353 14
static void	bwi_rxeof64(struct bwi_softc *) __unused;
static void	bwi_start_tx64(struct bwi_softc *, uint32_t, int) __unused;
static void	bwi_txeof_status64(struct bwi_softc *) __unused;

static void	bwi_rxeof(struct bwi_softc *, int);
static void	_bwi_txeof(struct bwi_softc *, uint16_t);
static void	bwi_txeof(struct bwi_softc *);
static void	bwi_txeof_status(struct bwi_softc *, int);
static void	bwi_enable_intrs(struct bwi_softc *, uint32_t);
static void	bwi_disable_intrs(struct bwi_softc *, uint32_t);

static int	bwi_dma_alloc(struct bwi_softc *);
static void	bwi_dma_free(struct bwi_softc *);
static int	bwi_dma_ring_alloc(struct bwi_softc *, bus_dma_tag_t,
d356 6
a361 6
static int	bwi_dma_mbuf_create(struct bwi_softc *) __unused;
static void	bwi_dma_mbuf_destroy(struct bwi_softc *, int, int) __unused;
static int	bwi_dma_txstats_alloc(struct bwi_softc *, uint32_t, bus_size_t) __unused;
static void	bwi_dma_txstats_free(struct bwi_softc *) __unused;
static void	bwi_dma_ring_addr(void *, bus_dma_segment_t *, int, int) __unused;
static void	bwi_dma_buf_addr(void *, bus_dma_segment_t *, int,
d364 7
a370 7
static void	bwi_power_on(struct bwi_softc *, int);
static int	bwi_power_off(struct bwi_softc *, int);
static int	bwi_set_clock_mode(struct bwi_softc *, enum bwi_clock_mode);
static int	bwi_set_clock_delay(struct bwi_softc *);
static void	bwi_get_clock_freq(struct bwi_softc *, struct bwi_clock_freq *);
static int	bwi_get_pwron_delay(struct bwi_softc *sc);
static void	bwi_set_addr_filter(struct bwi_softc *, uint16_t,
d372 2
a373 2
static void	bwi_set_bssid(struct bwi_softc *, const uint8_t *);
static int	bwi_set_chan(struct bwi_softc *, u_int8_t);
d375 36
a410 2
static void	bwi_get_card_flags(struct bwi_softc *);
static void	bwi_get_eaddr(struct bwi_softc *, uint16_t, uint8_t *);
a411 9
static int	bwi_bus_attach(struct bwi_softc *);
static int	bwi_bbp_attach(struct bwi_softc *);
static int	bwi_bbp_power_on(struct bwi_softc *, enum bwi_clock_mode);
static void	bwi_bbp_power_off(struct bwi_softc *);

static const char *bwi_regwin_name(const struct bwi_regwin *) __unused;
static uint32_t	bwi_regwin_disable_bits(struct bwi_softc *);
static void	bwi_regwin_info(struct bwi_softc *, uint16_t *, uint8_t *);
static int	bwi_regwin_select(struct bwi_softc *, int);
d894 1
a894 1
static int
d945 1
a945 1
static void
d1183 1
a1183 1
static __inline int
d1234 1
a1234 1
static int
d1329 1
a1329 1
static void
d1356 1
a1356 1
static int
d1438 1
a1438 1
static int
d1473 1
a1473 1
static int
d1490 1
a1490 1
static int
d1571 1
a1571 1
static int
d1590 1
a1590 1
static void
d1660 1
a1660 1
static void
d1689 1
a1689 1
static void
d1739 1
a1739 1
static void
d1755 1
a1755 1
static void
d1900 1
a1900 1
static int
d2027 1
a2027 1
static __inline void
d2085 1
a2085 1
static void
d2227 1
a2227 1
static void
d2249 1
a2249 1
static void
d2418 1
a2418 1
static void
d2428 1
a2428 1
static void
d2455 1
a2455 1
static void
d2461 1
a2461 1
static void
d2574 1
a2574 1
static void
d2582 1
a2582 1
static void
d2590 1
a2590 1
static void
d2692 1
a2692 1
static void
d2832 1
a2832 1
static void
d2967 1
a2967 1
static void
d3109 1
a3109 1
static __inline int16_t
d3124 1
a3124 1
static __inline struct bwi_rf_lo *
d3135 1
a3135 1
static __inline int
d3475 1
a3475 1
static void
d3487 1
a3487 1
static void
d3493 1
a3493 1
static void
d3500 1
a3500 1
static void
d3523 1
a3523 1
static __inline struct bwi_rf_lo *
d3574 1
a3574 1
static void
d3585 1
a3585 1
static int
d3598 2
a3599 2
static __inline uint16_t
bitswap4(uint16_t val)
d3610 1
a3610 1
static __inline uint16_t
d3842 1
a3842 1
		rfr_78 = (bitswap4(i) << 1) | 0x20;
d3944 1
a3944 1
static uint16_t
d3967 1
a3967 1
static __inline int32_t
d3980 1
a3980 1
static int
d4313 1
a4313 1
static uint32_t
d4346 1
a4346 1
static uint16_t
d4372 1
a4372 1
static uint8_t
d4469 1
a4469 1
static void
d4558 1
a4558 1
static void
d4671 1
a4671 1
static void
d4826 1
a4826 1
static void
d5005 1
a5005 1
static void
d5045 1
a5045 1
static void
d5085 1
a5085 1
static __inline int32_t
d5102 1
a5102 1
static void
d5192 1
a5192 1
static void
d5198 1
a5198 1
static void
d5338 1
a5338 1
static __inline void
d5550 1
a5550 1
static void
d5592 1
a5592 1
static int
d5644 1
a5644 1
static int
d5662 1
a5662 1
static void
d5676 1
a5676 1
static int
d5919 1
a5919 1
static void
d5935 1
a5935 1
static void
d5946 1
a5946 1
static void
d6009 1
a6009 1
static int
d6066 1
a6066 1
static int
d6186 1
a6186 1
static int
d6258 1
a6258 1
static void
d6369 1
a6369 1
static void
d6391 1
a6391 1
static int
d6544 1
a6544 1
static int
d6594 1
a6594 1
static int
d6608 1
a6608 1
static int
d6756 1
a6756 1
static void
d6797 1
a6797 1
static int
d6830 1
a6830 1
static int
d6926 1
a6926 1
static void
d6954 1
a6954 1
static void
d6961 1
a6961 1
static int
d7044 1
a7044 1
static void
d7092 1
a7092 1
static void
d7098 1
a7098 1
static void
d7104 1
a7104 1
static int
d7141 1
a7141 1
static void
d7164 1
a7164 1
static int
d7192 1
a7192 1
static int
d7222 1
a7222 1
static void
d7233 1
a7233 1
static void
d7242 1
a7242 1
static int
d7249 1
a7249 1
static int
d7256 1
a7256 1
static int
d7263 1
a7263 1
static void
d7270 1
a7270 1
static void
d7277 1
a7277 1
static void
d7287 1
a7287 1
static int
d7366 1
a7366 1
static void
d7384 1
a7384 1
static int
d7399 1
a7399 1
static void
d7415 1
a7415 1
static void
d7490 1
a7490 1
static void
d7508 1
a7508 1
static void
d7514 1
a7514 1
static void
d7541 1
a7541 1
static void
d7547 1
a7547 1
static void
d7567 1
a7567 1
static void
d7632 1
a7632 1
static void
d7638 1
a7638 1
static void
d7644 1
a7644 1
static void
d7677 1
a7677 1
static __inline void
d7691 1
a7691 15
/* XXX does not belong here */
struct ieee80211_ds_plcp_hdr {
	uint8_t		i_signal;
	uint8_t		i_service;
	uint16_t	i_length;
	uint16_t	i_crc;
} __packed;

#define IEEE80211_DS_PLCP_SERVICE_LOCKED	0x04
#define IEEE80211_DS_PLCL_SERVICE_PBCC		0x08
#define IEEE80211_DS_PLCP_SERVICE_LENEXT5	0x20
#define IEEE80211_DS_PLCP_SERVICE_LENEXT6	0x40
#define IEEE80211_DS_PLCP_SERVICE_LENEXT7	0x80

static __inline void
d7719 1
a7719 1
static void
d7740 1
a7740 1
static int
d7925 1
a7925 1
static void
d7933 1
a7933 1
static void
d7939 1
a7939 1
static void
d7961 1
a7961 1
static void
d7967 1
a7967 1
static void
d8011 1
a8011 1
static void
d8030 1
a8030 1
static void
d8057 1
a8057 1
static int
d8064 1
a8064 1
static void
d8071 1
a8071 1
static int
d8099 1
a8099 1
static int
d8120 1
a8120 1
static const char *
d8137 1
a8137 1
static uint32_t
d8299 1
a8299 1
static void
d8330 1
a8330 1
static void
d8348 1
a8348 1
static void
@

