head	1.55;
access;
symbols
	OPENBSD_6_1:1.55.0.4
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.54.0.4
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30;
locks; strict;
comment	@ * @;


1.55
date	2017.01.24.02.28.17;	author visa;	state Exp;
branches;
next	1.54;
commitid	Co0ej12l7nGroAdw;

1.54
date	2016.05.10.11.16.18;	author dlg;	state Exp;
branches;
next	1.53;
commitid	H4MSobHACgtapYZu;

1.53
date	2015.09.07.01.37.59;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	tqMlRDmXgyyNcOZC;

1.52
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	NdgfPIGUgJxQPnT7;

1.51
date	2015.06.19.11.12.24;	author jmatthew;	state Exp;
branches;
next	1.50;
commitid	I5HMIEQiHPSVn0jd;

1.50
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.49;
commitid	p4LJxGKbi0BU2cG6;

1.49
date	2015.02.09.07.43.08;	author jmatthew;	state Exp;
branches;
next	1.48;
commitid	KrS4uBblroppruhE;

1.48
date	2015.02.09.03.15.41;	author dlg;	state Exp;
branches;
next	1.47;
commitid	jVd0KngVszV2FEfg;

1.47
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.46;
commitid	MyKPm9Q3dQu92BiX;

1.46
date	2014.12.19.07.23.57;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	cV4v1OA8Ccwr5fwb;

1.45
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.44;
commitid	uzzBR7hz9ncd4O6G;

1.44
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.43;
commitid	jdBY2kKXhfcoQitp;

1.43
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	JtO5uXxVcnZfhUkR;

1.42
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.41;
commitid	I19imNlAX05zJOED;

1.41
date	2014.05.21.23.01.43;	author jmatthew;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.17.11.51.21;	author jmatthew;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.27.08.40.13;	author jmatthew;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.21.04.17.07;	author jmatthew;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.14.04.14.11;	author jmatthew;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.13.12.48.01;	author jmatthew;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.07.08.43.54;	author jmatthew;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.07.00.38.43;	author jmatthew;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.05.12.49.27;	author jmatthew;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.04.11.27.41;	author jmatthew;	state Exp;
branches;
next	1.31;

1.31
date	2014.03.31.11.25.45;	author jmatthew;	state Exp;
branches;
next	1.30;

1.30
date	2014.02.23.10.40.19;	author jmatthew;	state Exp;
branches;
next	1.29;

1.29
date	2014.02.22.15.36.10;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2014.02.20.20.20.28;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2014.02.20.11.09.48;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2014.02.20.03.39.07;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2014.02.20.00.42.44;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2014.02.20.00.23.00;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2014.02.19.13.41.23;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2014.02.19.06.29.08;	author jmatthew;	state Exp;
branches;
next	1.21;

1.21
date	2014.02.18.11.48.09;	author jmatthew;	state Exp;
branches;
next	1.20;

1.20
date	2014.02.11.11.41.46;	author jmatthew;	state Exp;
branches;
next	1.19;

1.19
date	2014.02.10.22.41.27;	author jmatthew;	state Exp;
branches;
next	1.18;

1.18
date	2014.02.06.09.51.42;	author jmatthew;	state Exp;
branches;
next	1.17;

1.17
date	2014.02.05.07.58.05;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2014.02.05.07.56.10;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2014.02.03.14.16.34;	author jmatthew;	state Exp;
branches;
next	1.14;

1.14
date	2014.02.02.07.53.33;	author jmatthew;	state Exp;
branches;
next	1.13;

1.13
date	2014.02.02.06.28.18;	author jmatthew;	state Exp;
branches;
next	1.12;

1.12
date	2014.02.01.09.11.30;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2014.01.30.23.58.41;	author jmatthew;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.30.23.43.53;	author jmatthew;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.30.19.39.23;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2014.01.22.21.42.18;	author jmatthew;	state Exp;
branches;
next	1.7;

1.7
date	2014.01.21.06.10.14;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.21.02.40.02;	author jmatthew;	state Exp;
branches;
next	1.5;

1.5
date	2014.01.21.02.14.14;	author jmatthew;	state Exp;
branches;
next	1.4;

1.4
date	2014.01.21.02.03.33;	author jmatthew;	state Exp;
branches;
next	1.3;

1.3
date	2014.01.20.21.20.46;	author jmatthew;	state Exp;
branches;
next	1.2;

1.2
date	2014.01.19.10.30.13;	author jmatthew;	state Exp;
branches;
next	1.1;

1.1
date	2014.01.19.06.04.03;	author jmatthew;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Use header <sys/atomic.h> rather than <machine/atomic.h> in MI code.

OK mpi@@ deraadt@@
@
text
@/*	$OpenBSD: qla.c,v 1.54 2016/05/10 11:16:18 dlg Exp $ */

/*
 * Copyright (c) 2011 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2013, 2014 Jonathan Matthew <jmatthew@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/atomic.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/mutex.h>
#include <sys/rwlock.h>
#include <sys/sensors.h>
#include <sys/queue.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/qlareg.h>
#include <dev/ic/qlavar.h>

#ifdef QLA_DEBUG
#define DPRINTF(m, f...) do { if ((qladebug & (m)) == (m)) printf(f); } \
    while (0)
#define QLA_D_MBOX		0x01
#define QLA_D_INTR		0x02
#define QLA_D_PORT		0x04
#define QLA_D_IO		0x08
#define QLA_D_IOCB		0x10
int qladebug = QLA_D_PORT;
#else
#define DPRINTF(m, f...)
#endif


#ifndef ISP_NOFIRMWARE
#include <dev/microcode/isp/asm_2100.h>
#include <dev/microcode/isp/asm_2200.h>
#include <dev/microcode/isp/asm_2300.h>
#endif

struct cfdriver qla_cd = {
	NULL,
	"qla",
	DV_DULL
};

void		qla_scsi_cmd(struct scsi_xfer *);
int		qla_scsi_probe(struct scsi_link *);

u_int16_t	qla_read(struct qla_softc *, bus_size_t);
void		qla_write(struct qla_softc *, bus_size_t, u_int16_t);
void		qla_host_cmd(struct qla_softc *sc, u_int16_t);

u_int16_t	qla_read_queue_2100(struct qla_softc *, bus_size_t);

int		qla_mbox(struct qla_softc *, int);
int		qla_sns_req(struct qla_softc *, struct qla_dmamem *, int);
void		qla_mbox_putaddr(u_int16_t *, struct qla_dmamem *);
u_int16_t	qla_read_mbox(struct qla_softc *, int);
void		qla_write_mbox(struct qla_softc *, int, u_int16_t);

void		qla_handle_intr(struct qla_softc *, u_int16_t, u_int16_t);
void		qla_set_ints(struct qla_softc *, int);
int		qla_read_isr_1G(struct qla_softc *, u_int16_t *, u_int16_t *);
int		qla_read_isr_2G(struct qla_softc *, u_int16_t *, u_int16_t *);
void		qla_clear_isr(struct qla_softc *, u_int16_t);

void		qla_update_start(struct qla_softc *, int);
void		qla_update_done(struct qla_softc *, int);
void		qla_do_update(void *);

void		qla_put_marker(struct qla_softc *, void *);
void		qla_put_cmd(struct qla_softc *, void *, struct scsi_xfer *,
		    struct qla_ccb *);
struct qla_ccb *qla_handle_resp(struct qla_softc *, u_int16_t);
void		qla_put_data_seg(struct qla_iocb_seg *, bus_dmamap_t, int);

int		qla_get_port_name_list(struct qla_softc *, u_int32_t);
struct qla_fc_port *qla_next_fabric_port(struct qla_softc *, u_int32_t *,
		    u_int32_t *);
int		qla_get_port_db(struct qla_softc *c, u_int16_t,
		    struct qla_dmamem *);
int		qla_add_loop_port(struct qla_softc *, struct qla_fc_port *);
int		qla_add_fabric_port(struct qla_softc *, struct qla_fc_port *);
int		qla_add_logged_in_port(struct qla_softc *, int, u_int32_t);
int		qla_classify_port(struct qla_softc *, u_int32_t, u_int64_t,
		    u_int64_t, struct qla_fc_port **);
int		qla_get_loop_id(struct qla_softc *sc, int);
void		qla_clear_port_lists(struct qla_softc *);
int		qla_softreset(struct qla_softc *);
void		qla_update_topology(struct qla_softc *);
int		qla_update_fabric(struct qla_softc *);
int		qla_fabric_plogi(struct qla_softc *, struct qla_fc_port *);
void		qla_fabric_plogo(struct qla_softc *, struct qla_fc_port *);

void		qla_update_start(struct qla_softc *, int);
int		qla_async(struct qla_softc *, u_int16_t);

int		qla_verify_firmware(struct qla_softc *sc, u_int16_t);
int		qla_load_firmware_words(struct qla_softc *, const u_int16_t *,
		    u_int16_t);
int		qla_load_firmware_2100(struct qla_softc *);
int		qla_load_firmware_2200(struct qla_softc *);
int		qla_load_fwchunk_2300(struct qla_softc *,
		    struct qla_dmamem *, const u_int16_t *, u_int32_t);
int		qla_load_firmware_2300(struct qla_softc *);
int		qla_load_firmware_2322(struct qla_softc *);
int		qla_read_nvram(struct qla_softc *);

struct qla_dmamem *qla_dmamem_alloc(struct qla_softc *, size_t);
void		qla_dmamem_free(struct qla_softc *, struct qla_dmamem *);

int		qla_alloc_ccbs(struct qla_softc *);
void		qla_free_ccbs(struct qla_softc *);
void		*qla_get_ccb(void *);
void		qla_put_ccb(void *, void *);

void		qla_dump_iocb(struct qla_softc *, void *);
void		qla_dump_iocb_segs(struct qla_softc *, void *, int);

static const struct qla_regs qla_regs_2100 = {
	qla_read_queue_2100,
	qla_read_isr_1G,
	QLA_MBOX_BASE_2100 + 0x8,
	QLA_MBOX_BASE_2100 + 0x8,
	QLA_MBOX_BASE_2100 + 0xa,
	QLA_MBOX_BASE_2100 + 0xa
};

static const struct qla_regs qla_regs_2200 = {
	qla_read,
	qla_read_isr_1G,
	QLA_MBOX_BASE_2200 + 0x8,
	QLA_MBOX_BASE_2200 + 0x8,
	QLA_MBOX_BASE_2200 + 0xa,
	QLA_MBOX_BASE_2200 + 0xa
};

static const struct qla_regs qla_regs_23XX = {
	qla_read,
	qla_read_isr_2G,
	QLA_REQ_IN,
	QLA_REQ_OUT,
	QLA_RESP_IN,
	QLA_RESP_OUT
};

#define qla_queue_read(_sc, _r) ((*(_sc)->sc_regs->read)((_sc), (_r)))
#define qla_queue_write(_sc, _r, _v) qla_write((_sc), (_r), (_v))

#define qla_read_isr(_sc, _isr, _info) \
    ((*(_sc)->sc_regs->read_isr)((_sc), (_isr), (_info)))

struct scsi_adapter qla_switch = {
	qla_scsi_cmd,
	scsi_minphys,
	qla_scsi_probe,
	NULL,	/* scsi_free */
	NULL	/* ioctl */
};

int
qla_classify_port(struct qla_softc *sc, u_int32_t location,
    u_int64_t port_name, u_int64_t node_name, struct qla_fc_port **prev)
{
	struct qla_fc_port *port, *locmatch, *wwnmatch;
	locmatch = NULL;
	wwnmatch = NULL;

	/* make sure we don't try to add a port or location twice */
	TAILQ_FOREACH(port, &sc->sc_ports_new, update) {
		if ((port->port_name == port_name &&
		    port->node_name == node_name) ||
		    port->location == location) {
			*prev = port;
			return (QLA_PORT_DISP_DUP);
		}
	}

	/* if we're attaching, everything is new */
	if (sc->sc_scsibus == NULL) {
		*prev = NULL;
		return (QLA_PORT_DISP_NEW);
	}

	TAILQ_FOREACH(port, &sc->sc_ports, ports) {
		if (port->location == location)
			locmatch = port;

		if (port->port_name == port_name &&
		    port->node_name == node_name)
			wwnmatch = port;
	}

	if (locmatch == NULL && wwnmatch == NULL) {
		*prev = NULL;
		return (QLA_PORT_DISP_NEW);
	} else if (locmatch == wwnmatch) {
		*prev = locmatch;
		return (QLA_PORT_DISP_SAME);
	} else if (wwnmatch != NULL) {
		*prev = wwnmatch;
		return (QLA_PORT_DISP_MOVED);
	} else {
		*prev = locmatch;
		return (QLA_PORT_DISP_CHANGED);
	}
}

int
qla_get_loop_id(struct qla_softc *sc, int start)
{
	int i, last;

	if (sc->sc_2k_logins) {
		i = QLA_2KL_MIN_HANDLE;
		last = QLA_2KL_MAX_HANDLE;
	} else {
		/* if we're an F port, we can have two ranges, but meh */
		i = QLA_MIN_HANDLE;
		last = QLA_MAX_HANDLE;
	}
	if (i < start)
		i = start;

	for (; i <= last; i++) {
		if (sc->sc_targets[i] == NULL)
			return (i);
	}

	return (-1);
}

int
qla_get_port_db(struct qla_softc *sc, u_int16_t loopid, struct qla_dmamem *mem)
{
	sc->sc_mbox[0] = QLA_MBOX_GET_PORT_DB;
	if (sc->sc_2k_logins) {
		sc->sc_mbox[1] = loopid;
	} else {
		sc->sc_mbox[1] = loopid << 8;
	}

	memset(QLA_DMA_KVA(mem), 0, sizeof(struct qla_get_port_db));
	qla_mbox_putaddr(sc->sc_mbox, mem);
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(mem), 0,
	    sizeof(struct qla_get_port_db), BUS_DMASYNC_PREREAD);
	if (qla_mbox(sc, 0x00cf)) {
		DPRINTF(QLA_D_PORT, "%s: get port db %d failed: %x\n",
		    DEVNAME(sc), loopid, sc->sc_mbox[0]);
		return (1);
	}

	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(mem), 0,
	    sizeof(struct qla_get_port_db), BUS_DMASYNC_POSTREAD);
	return (0);
}

int
qla_add_loop_port(struct qla_softc *sc, struct qla_fc_port *port)
{
	struct qla_get_port_db *pdb;
	struct qla_fc_port *pport = NULL;
	int disp;

	if (qla_get_port_db(sc, port->loopid, sc->sc_scratch)) {
		return (1);
	}
	pdb = QLA_DMA_KVA(sc->sc_scratch);

	if (letoh16(pdb->prli_svc_word3) & QLA_SVC3_TARGET_ROLE)
		port->flags |= QLA_PORT_FLAG_IS_TARGET;

	port->port_name = betoh64(pdb->port_name);
	port->node_name = betoh64(pdb->node_name);
	port->portid = (letoh16(pdb->port_id[0]) << 16) |
	    letoh16(pdb->port_id[1]);

	mtx_enter(&sc->sc_port_mtx);
	disp = qla_classify_port(sc, port->location, port->port_name,
	    port->node_name, &pport);
	switch (disp) {
	case QLA_PORT_DISP_CHANGED:
	case QLA_PORT_DISP_MOVED:
	case QLA_PORT_DISP_NEW:
		TAILQ_INSERT_TAIL(&sc->sc_ports_new, port, update);
		sc->sc_targets[port->loopid] = port;
		break;
	case QLA_PORT_DISP_DUP:
		free(port, M_DEVBUF, sizeof *port);
		break;
	case QLA_PORT_DISP_SAME:
		TAILQ_REMOVE(&sc->sc_ports_gone, pport, update);
		free(port, M_DEVBUF, sizeof *port);
		break;
	}
	mtx_leave(&sc->sc_port_mtx);

	switch (disp) {
	case QLA_PORT_DISP_CHANGED:
	case QLA_PORT_DISP_MOVED:
	case QLA_PORT_DISP_NEW:
		DPRINTF(QLA_D_PORT, "%s: %s %d; name %llx, port %06x\n",
		    DEVNAME(sc), ISSET(port->flags, QLA_PORT_FLAG_IS_TARGET) ?
		    "target" : "non-target", port->loopid, port->port_name,
		    port->portid);
		break;
	}
	return (0);
}

int
qla_add_fabric_port(struct qla_softc *sc, struct qla_fc_port *port)
{
	struct qla_get_port_db *pdb;
	
	if (qla_get_port_db(sc, port->loopid, sc->sc_scratch)) {
		return (1);
	}
	pdb = QLA_DMA_KVA(sc->sc_scratch);

	if (letoh16(pdb->prli_svc_word3) & QLA_SVC3_TARGET_ROLE)
		port->flags |= QLA_PORT_FLAG_IS_TARGET;

	/*
	 * if we only know about this port because qla_get_port_name_list
	 * returned it, we don't have its port id or node name, so fill
	 * those in and update its location.
	 */
	if (port->location == QLA_LOCATION_FABRIC) {
		port->node_name = betoh64(pdb->node_name);
		port->port_name = betoh64(pdb->port_name);
		port->portid = (letoh16(pdb->port_id[0]) << 16) |
		    letoh16(pdb->port_id[1]);
		port->location = QLA_LOCATION_PORT_ID(port->portid);
	}

	mtx_enter(&sc->sc_port_mtx);
	TAILQ_INSERT_TAIL(&sc->sc_ports_new, port, update);
	sc->sc_targets[port->loopid] = port;
	mtx_leave(&sc->sc_port_mtx);

	DPRINTF(QLA_D_PORT, "%s: %s %d; name %llx\n",
	    DEVNAME(sc), ISSET(port->flags, QLA_PORT_FLAG_IS_TARGET) ?
	    "target" : "non-target", port->loopid, port->port_name);
	return (0);
}

int
qla_add_logged_in_port(struct qla_softc *sc, int loopid, u_int32_t portid)
{
	struct qla_fc_port *port;
	struct qla_get_port_db *pdb;
	u_int64_t node_name, port_name;
	int flags, ret;
	
	ret = qla_get_port_db(sc, loopid, sc->sc_scratch);
	mtx_enter(&sc->sc_port_mtx);
	if (ret != 0) {
		/* put in a fake port to prevent use of this loop id */
		printf("%s: loop id %d used, but can't see what's using it\n",
		    DEVNAME(sc), loopid);
		node_name = 0;
		port_name = 0;
		flags = 0;
	} else {
		pdb = QLA_DMA_KVA(sc->sc_scratch);
		node_name = betoh64(pdb->node_name);
		port_name = betoh64(pdb->port_name);
		flags = 0;
		if (letoh16(pdb->prli_svc_word3) & QLA_SVC3_TARGET_ROLE)
			flags |= QLA_PORT_FLAG_IS_TARGET;

		/* see if we've already found this port */
		TAILQ_FOREACH(port, &sc->sc_ports_found, update) {
			if ((port->node_name == node_name) &&
			    (port->port_name == port_name) &&
			    (port->portid == portid)) {
				mtx_leave(&sc->sc_port_mtx);
				DPRINTF(QLA_D_PORT, "%s: already found port "
				    "%06x\n", DEVNAME(sc), portid);
				return (0);
			}
		}
	}

	port = malloc(sizeof(*port), M_DEVBUF, M_ZERO | M_NOWAIT);
	if (port == NULL) {
		mtx_leave(&sc->sc_port_mtx);
		printf("%s: failed to allocate a port structure\n",
		    DEVNAME(sc));
		return (1);
	}
	port->location = QLA_LOCATION_PORT_ID(portid);
	port->port_name = port_name;
	port->node_name = node_name;
	port->loopid = loopid;
	port->portid = portid;
	port->flags = flags;

	TAILQ_INSERT_TAIL(&sc->sc_ports, port, ports);
	sc->sc_targets[port->loopid] = port;
	mtx_leave(&sc->sc_port_mtx);

	DPRINTF(QLA_D_PORT, "%s: added logged in port %06x at %d\n",
	    DEVNAME(sc), portid, loopid);
	return (0);
}

int
qla_attach(struct qla_softc *sc)
{
	struct scsibus_attach_args saa;
	struct qla_init_cb *icb;
#ifndef ISP_NOFIRMWARE
	int (*loadfirmware)(struct qla_softc *) = NULL;
#endif
	u_int16_t firmware_addr = 0;
	int i, rv;

	TAILQ_INIT(&sc->sc_ports);
	TAILQ_INIT(&sc->sc_ports_new);
	TAILQ_INIT(&sc->sc_ports_gone);
	TAILQ_INIT(&sc->sc_ports_found);

	switch (sc->sc_isp_gen) {
	case QLA_GEN_ISP2100:
		sc->sc_mbox_base = QLA_MBOX_BASE_2100;
		sc->sc_regs = &qla_regs_2100;
#ifndef ISP_NOFIRMWARE
		loadfirmware = qla_load_firmware_2100;
#endif
		firmware_addr = QLA_2100_CODE_ORG;
		break;

	case QLA_GEN_ISP2200:
		sc->sc_mbox_base = QLA_MBOX_BASE_2200;
		sc->sc_regs = &qla_regs_2200;
#ifndef ISP_NOFIRMWARE
		loadfirmware = qla_load_firmware_2200;
#endif
		firmware_addr = QLA_2200_CODE_ORG;
		break;

	case QLA_GEN_ISP23XX:
		sc->sc_mbox_base = QLA_MBOX_BASE_23XX;
		sc->sc_regs = &qla_regs_23XX;
#ifndef ISP_NOFIRMWARE
		if (sc->sc_isp_type != QLA_ISP2322)
			loadfirmware = qla_load_firmware_2300;
#endif
		firmware_addr = QLA_2300_CODE_ORG;
		break;

	default:
		printf("unknown isp type\n");
		return (ENXIO);
	}

	/* after reset, mbox registers 1-3 should contain the string "ISP   " */
	if (qla_read_mbox(sc, 1) != 0x4953 ||
	    qla_read_mbox(sc, 2) != 0x5020 ||
	    qla_read_mbox(sc, 3) != 0x2020) {
		/* try releasing the risc processor */
		qla_host_cmd(sc, QLA_HOST_CMD_RELEASE);
	}

	qla_host_cmd(sc, QLA_HOST_CMD_PAUSE);
	if (qla_softreset(sc) != 0) {
		printf("softreset failed\n");
		return (ENXIO);
	}

	if (qla_read_nvram(sc) == 0) {
		sc->sc_nvram_valid = 1;
		if (sc->sc_port_name == 0)
			sc->sc_port_name = betoh64(sc->sc_nvram.port_name);
		if (sc->sc_node_name == 0)
			sc->sc_node_name = betoh64(sc->sc_nvram.node_name);
	}

	if (sc->sc_port_name == 0)
		sc->sc_port_name = QLA_DEFAULT_PORT_NAME;

#ifdef ISP_NOFIRMWARE
	if (qla_verify_firmware(sc, firmware_addr)) {
		printf("%s: no firmware loaded\n", DEVNAME(sc));
		return (ENXIO);
	}
#else
	if (loadfirmware && (loadfirmware)(sc)) {
		printf("%s: firmware load failed\n", DEVNAME(sc));
		return (ENXIO);
	}
#endif

	/* execute firmware */
	sc->sc_mbox[0] = QLA_MBOX_EXEC_FIRMWARE;
	sc->sc_mbox[1] = firmware_addr;
#ifdef ISP_NOFIRMWARE
	sc->sc_mbox[2] = 1;
#else
	if (loadfirmware)
		sc->sc_mbox[2] = 0;
	else
		sc->sc_mbox[2] = 1;
#endif
	if (qla_mbox(sc, 0x0007)) {
		printf("ISP couldn't exec firmware: %x\n", sc->sc_mbox[0]);
		return (ENXIO);
	}

	delay(250000);		/* from isp(4) */

	sc->sc_mbox[0] = QLA_MBOX_ABOUT_FIRMWARE;
	if (qla_mbox(sc, 0x0001)) {
		printf("ISP not talking after firmware exec: %x\n",
		    sc->sc_mbox[0]);
		return (ENXIO);
	}
	printf("%s: firmware rev %d.%d.%d, attrs 0x%x\n", DEVNAME(sc),
	    sc->sc_mbox[1], sc->sc_mbox[2], sc->sc_mbox[3], sc->sc_mbox[6]);

	if (sc->sc_mbox[6] & QLA_FW_ATTR_EXPANDED_LUN)
		sc->sc_expanded_lun = 1;
	if (sc->sc_mbox[6] & QLA_FW_ATTR_FABRIC)
		sc->sc_fabric = 1;
	if (sc->sc_mbox[6] & QLA_FW_ATTR_2K_LOGINS)
		sc->sc_2k_logins = 1;

	/* work out how many ccbs to allocate */
	sc->sc_mbox[0] = QLA_MBOX_GET_FIRMWARE_STATUS;
	if (qla_mbox(sc, 0x0001)) {
		printf("couldn't get firmware status: %x\n", sc->sc_mbox[0]);
		return (ENXIO);
	}
	sc->sc_maxcmds = sc->sc_mbox[2];

	if (qla_alloc_ccbs(sc)) {
		/* error already printed */
		return (ENOMEM);
	}
	sc->sc_scratch = qla_dmamem_alloc(sc, QLA_SCRATCH_SIZE);
	if (sc->sc_scratch == NULL) {
		printf("%s: unable to allocate scratch\n", DEVNAME(sc));
		goto free_ccbs;
	}

	/* build init buffer thing */
	icb = (struct qla_init_cb *)QLA_DMA_KVA(sc->sc_scratch);
	memset(icb, 0, sizeof(*icb));
	icb->icb_version = QLA_ICB_VERSION;
	/* port and node names are big-endian in the icb */
	icb->icb_portname = htobe64(sc->sc_port_name);
	icb->icb_nodename = htobe64(sc->sc_node_name);
	if (sc->sc_nvram_valid) {
		icb->icb_fw_options = sc->sc_nvram.fw_options;
		icb->icb_max_frame_len = sc->sc_nvram.frame_payload_size;
		icb->icb_max_alloc = sc->sc_nvram.max_iocb_allocation;
		icb->icb_exec_throttle = sc->sc_nvram.execution_throttle;
		icb->icb_retry_count = sc->sc_nvram.retry_count;
		icb->icb_retry_delay = sc->sc_nvram.retry_delay;
		icb->icb_hardaddr = sc->sc_nvram.hard_address;
		icb->icb_inquiry_data = sc->sc_nvram.inquiry_data;
		icb->icb_login_timeout = sc->sc_nvram.login_timeout;
		icb->icb_xfwoptions = sc->sc_nvram.add_fw_options;
		icb->icb_zfwoptions = sc->sc_nvram.special_options;
	} else {
		/* defaults copied from isp(4) */
		icb->icb_retry_count = 3;
		icb->icb_retry_delay = 5;
		icb->icb_exec_throttle = htole16(16);
		icb->icb_max_alloc = htole16(256);
		icb->icb_max_frame_len = htole16(1024);
		icb->icb_fw_options = htole16(QLA_ICB_FW_FAIRNESS |
		    QLA_ICB_FW_ENABLE_PDB_CHANGED | QLA_ICB_FW_HARD_ADDR |
		    QLA_ICB_FW_FULL_DUPLEX);
	}
	/* target mode stuff that we don't care about */
	icb->icb_lun_enables = 0;
	icb->icb_cmd_count = 0;
	icb->icb_notify_count = 0;
	icb->icb_lun_timeout = 0;

	/* "zero interrupt operation" */
	icb->icb_int_delaytimer = 0;

	icb->icb_req_out = 0;
	icb->icb_resp_in = 0;
	icb->icb_req_queue_len = htole16(sc->sc_maxcmds);
	icb->icb_resp_queue_len = htole16(sc->sc_maxcmds);
	icb->icb_req_queue_addr = htole64(QLA_DMA_DVA(sc->sc_requests));
	icb->icb_resp_queue_addr = htole64(QLA_DMA_DVA(sc->sc_responses));

	/* adjust firmware options a bit */
	icb->icb_fw_options |= htole16(QLA_ICB_FW_EXTENDED_INIT_CB);
	icb->icb_fw_options &= ~htole16(QLA_ICB_FW_FAST_POST);

	sc->sc_mbox[0] = QLA_MBOX_INIT_FIRMWARE;
	sc->sc_mbox[4] = 0;
	sc->sc_mbox[5] = 0;
	qla_mbox_putaddr(sc->sc_mbox, sc->sc_scratch);
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_scratch), 0,
	    sizeof(*icb), BUS_DMASYNC_PREWRITE);
	rv = qla_mbox(sc, 0x00fd);
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_scratch), 0,
	    sizeof(*icb), BUS_DMASYNC_POSTWRITE);

	if (rv != 0) {
		printf("%s: ISP firmware init failed: %x\n", DEVNAME(sc),
		    sc->sc_mbox[0]);
		goto free_scratch;
	}

	/* enable some more notifications */
	sc->sc_mbox[0] = QLA_MBOX_SET_FIRMWARE_OPTIONS;
	sc->sc_mbox[1] = QLA_FW_OPTION1_ASYNC_LIP_F8 |
	    QLA_FW_OPTION1_ASYNC_LIP_RESET |
	    QLA_FW_OPTION1_ASYNC_LIP_ERROR |
	    QLA_FW_OPTION1_ASYNC_LOGIN_RJT;
	sc->sc_mbox[2] = 0;
	sc->sc_mbox[3] = 0;
	if (qla_mbox(sc, 0x000f)) {
		printf("%s: setting firmware options failed: %x\n",
		    DEVNAME(sc), sc->sc_mbox[0]);
		goto free_scratch;
	}

	sc->sc_update_taskq = taskq_create(DEVNAME(sc), 1, IPL_BIO, 0);
	task_set(&sc->sc_update_task, qla_do_update, sc);

	/* wait a bit for link to come up so we can scan and attach devices */
	for (i = 0; i < QLA_WAIT_FOR_LOOP * 10000; i++) {
		u_int16_t isr, info;

		delay(100);

		if (qla_read_isr(sc, &isr, &info) == 0)
			continue;

		qla_handle_intr(sc, isr, info);

		if (sc->sc_loop_up)
			break;
	}

	if (sc->sc_loop_up) {
		qla_do_update(sc);
	} else {
		DPRINTF(QLA_D_PORT, "%s: loop still down, giving up\n",
		    DEVNAME(sc));
	}

	/* we should be good to go now, attach scsibus */
	sc->sc_link.adapter = &qla_switch;
	sc->sc_link.adapter_softc = sc;
	if (sc->sc_2k_logins) {
		sc->sc_link.adapter_buswidth = QLA_2KL_BUSWIDTH;
	} else {
		sc->sc_link.adapter_buswidth = QLA_BUSWIDTH;
	}
	sc->sc_link.adapter_target = sc->sc_link.adapter_buswidth;
	sc->sc_link.openings = sc->sc_maxcmds;
	sc->sc_link.pool = &sc->sc_iopool;
	sc->sc_link.port_wwn = sc->sc_port_name;
	sc->sc_link.node_wwn = sc->sc_node_name;
	if (sc->sc_link.node_wwn == 0) {
		/*
		 * mask out the port number from the port name to get
		 * the node name.
		 */
		sc->sc_link.node_wwn = sc->sc_link.port_wwn;
		sc->sc_link.node_wwn &= ~(0xfULL << 56);
	}

	memset(&saa, 0, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	/* config_found() returns the scsibus attached to us */
	sc->sc_scsibus = (struct scsibus_softc *)config_found(&sc->sc_dev,
	    &saa, scsiprint);

	return(0);

free_scratch:
	qla_dmamem_free(sc, sc->sc_scratch);
free_ccbs:
	qla_free_ccbs(sc);
	return (ENXIO);
}

int
qla_detach(struct qla_softc *sc, int flags)
{
	return (0);
}

struct qla_ccb *
qla_handle_resp(struct qla_softc *sc, u_int16_t id)
{
	struct qla_ccb *ccb;
	struct qla_iocb_status *status;
	struct scsi_xfer *xs;
	u_int32_t handle;
	u_int8_t *entry;

	ccb = NULL;
	entry = QLA_DMA_KVA(sc->sc_responses) + (id * QLA_QUEUE_ENTRY_SIZE);

	bus_dmamap_sync(sc->sc_dmat,
	    QLA_DMA_MAP(sc->sc_responses), id * QLA_QUEUE_ENTRY_SIZE,
	    QLA_QUEUE_ENTRY_SIZE, BUS_DMASYNC_POSTREAD);

	qla_dump_iocb(sc, entry);
	switch (entry[0]) {
	case QLA_IOCB_STATUS:
		status = (struct qla_iocb_status *)entry;
		handle = status->handle;
		if (handle > sc->sc_maxcmds) {
			panic("bad completed command handle: %d (> %d)",
			    handle, sc->sc_maxcmds);
		}

		ccb = &sc->sc_ccbs[handle];
		xs = ccb->ccb_xs;
		if (xs == NULL) {
			DPRINTF(QLA_D_INTR, "%s: got status for inactive"
			    " ccb %d\n", DEVNAME(sc), handle);
			ccb = NULL;
			break;
		}
		if (xs->io != ccb) {
			panic("completed command handle doesn't match xs "
			    "(handle %d, ccb %p, xs->io %p)", handle, ccb,
			    xs->io);
		}

		if (xs->datalen > 0) {
			if (ccb->ccb_dmamap->dm_nsegs >
			    QLA_IOCB_SEGS_PER_CMD) {
				bus_dmamap_sync(sc->sc_dmat,
				    QLA_DMA_MAP(sc->sc_segments),
				    ccb->ccb_seg_offset,
				    sizeof(*ccb->ccb_t4segs) *
				    ccb->ccb_dmamap->dm_nsegs,
				    BUS_DMASYNC_POSTWRITE);
			}

			bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize,
			    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
		}

		xs->status = letoh16(status->scsi_status);
		switch (letoh16(status->completion)) {
		case QLA_IOCB_STATUS_COMPLETE:
			if (letoh16(status->scsi_status) &
			    QLA_SCSI_STATUS_SENSE_VALID) {
				memcpy(&xs->sense, status->sense_data,
				    sizeof(xs->sense));
				xs->error = XS_SENSE;
			} else {
				xs->error = XS_NOERROR;
			}
			xs->resid = 0;
			break;

		case QLA_IOCB_STATUS_DMA_ERROR:
			DPRINTF(QLA_D_INTR, "%s: dma error\n", DEVNAME(sc));
			/* set resid apparently? */
			break;

		case QLA_IOCB_STATUS_RESET:
			DPRINTF(QLA_D_IO, "%s: reset destroyed command\n",
			    DEVNAME(sc));
			sc->sc_marker_required = 1;
			xs->error = XS_RESET;
			break;

		case QLA_IOCB_STATUS_ABORTED:
			DPRINTF(QLA_D_IO, "%s: aborted\n", DEVNAME(sc));
			sc->sc_marker_required = 1;
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case QLA_IOCB_STATUS_TIMEOUT:
			DPRINTF(QLA_D_IO, "%s: command timed out\n",
			    DEVNAME(sc));
			xs->error = XS_TIMEOUT;
			break;

		case QLA_IOCB_STATUS_DATA_OVERRUN:
		case QLA_IOCB_STATUS_DATA_UNDERRUN:
			xs->resid = letoh32(status->resid);
			xs->error = XS_NOERROR;
			break;

		case QLA_IOCB_STATUS_QUEUE_FULL:
			DPRINTF(QLA_D_IO, "%s: queue full\n", DEVNAME(sc));
			xs->error = XS_BUSY;
			break;

		case QLA_IOCB_STATUS_PORT_UNAVAIL:
		case QLA_IOCB_STATUS_PORT_LOGGED_OUT:
		case QLA_IOCB_STATUS_PORT_CHANGED:
			DPRINTF(QLA_D_IO, "%s: dev gone\n", DEVNAME(sc));
			xs->error = XS_SELTIMEOUT;
			break;

		default:
			DPRINTF(QLA_D_INTR, "%s: unexpected completion"
			    " status %x\n", DEVNAME(sc), status->completion);
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		break;

	case QLA_IOCB_STATUS_CONT:
		DPRINTF(QLA_D_INTR, "%s: ignoring status continuation iocb\n",
		    DEVNAME(sc));
		break;

		/* check for requests that bounce back? */
	default:
		DPRINTF(QLA_D_INTR, "%s: unexpected response entry type %x\n",
		    DEVNAME(sc), entry[0]);
		break;
	}

	return (ccb);
}

void
qla_handle_intr(struct qla_softc *sc, u_int16_t isr, u_int16_t info)
{
	int i;
	u_int16_t rspin;
	struct qla_ccb *ccb;

	switch (isr) {
	case QLA_INT_TYPE_ASYNC:
		qla_async(sc, info);
		break;

	case QLA_INT_TYPE_IO:
		rspin = qla_queue_read(sc, sc->sc_regs->res_in);
		if (rspin == sc->sc_last_resp_id) {
			/* seems to happen a lot on 2200s when mbox commands
			 * complete but it doesn't want to give us the register
			 * semaphore, or something.
			 *
			 * if we're waiting on a mailbox command, don't ack
			 * the interrupt yet.
			 */
			if (sc->sc_mbox_pending) {
				DPRINTF(QLA_D_MBOX, "%s: ignoring premature"
				    " mbox int\n", DEVNAME(sc));
				return;
			}

			break;
		}

		if (sc->sc_responses == NULL)
			break;

		DPRINTF(QLA_D_IO, "%s: response queue %x=>%x\n",
		    DEVNAME(sc), sc->sc_last_resp_id, rspin);

		do {
			ccb = qla_handle_resp(sc, sc->sc_last_resp_id);
			if (ccb)
				scsi_done(ccb->ccb_xs);

			sc->sc_last_resp_id++;
			sc->sc_last_resp_id %= sc->sc_maxcmds;
		} while (sc->sc_last_resp_id != rspin);

		qla_queue_write(sc, sc->sc_regs->res_out, rspin);
		break;

	case QLA_INT_TYPE_MBOX:
		mtx_enter(&sc->sc_mbox_mtx);
		if (sc->sc_mbox_pending) {
			DPRINTF(QLA_D_MBOX, "%s: mbox response %x\n",
			    DEVNAME(sc), info);
			for (i = 0; i < nitems(sc->sc_mbox); i++) {
				sc->sc_mbox[i] = qla_read_mbox(sc, i);
			}
			sc->sc_mbox_pending = 2;
			wakeup(sc->sc_mbox);
			mtx_leave(&sc->sc_mbox_mtx);
		} else {
			mtx_leave(&sc->sc_mbox_mtx);
			DPRINTF(QLA_D_MBOX, "%s: unexpected mbox interrupt:"
			    " %x\n", DEVNAME(sc), info);
		}
		break;

	default:
		/* maybe log something? */
		break;
	}

	qla_clear_isr(sc, isr);
}

int
qla_intr(void *xsc)
{
	struct qla_softc *sc = xsc;
	u_int16_t isr;
	u_int16_t info;

	if (qla_read_isr(sc, &isr, &info) == 0)
		return (0);

	qla_handle_intr(sc, isr, info);
	return (1);
}

int
qla_scsi_probe(struct scsi_link *link)
{
	struct qla_softc *sc = link->adapter_softc;
	int rv = 0;

	mtx_enter(&sc->sc_port_mtx);
	if (sc->sc_targets[link->target] == NULL)
		rv = ENXIO;
	else if (!ISSET(sc->sc_targets[link->target]->flags,
	    QLA_PORT_FLAG_IS_TARGET))
		rv = ENXIO;
	else {
		link->port_wwn = sc->sc_targets[link->target]->port_name;
		link->node_wwn = sc->sc_targets[link->target]->node_name;
	}
	mtx_leave(&sc->sc_port_mtx);

	return (rv);
}

void
qla_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct qla_softc	*sc = link->adapter_softc;
	struct qla_ccb		*ccb;
	struct qla_iocb_req34	*iocb;
	struct qla_ccb_list	list;
	u_int16_t		req, rspin;
	int			offset, error, done;
	bus_dmamap_t		dmap;

	if (xs->cmdlen > sizeof(iocb->req_cdb)) {
		DPRINTF(QLA_D_IO, "%s: cdb too big (%d)\n", DEVNAME(sc),
		    xs->cmdlen);
		memset(&xs->sense, 0, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | SSD_ERRCODE_CURRENT;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20;
		xs->error = XS_SENSE;
		scsi_done(xs);
		return;
	}

	ccb = xs->io;
	dmap = ccb->ccb_dmamap;
	if (xs->datalen > 0) {
		error = bus_dmamap_load(sc->sc_dmat, dmap, xs->data,
		    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}

		bus_dmamap_sync(sc->sc_dmat, dmap, 0,
		    dmap->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
		    BUS_DMASYNC_PREWRITE);
	}

	mtx_enter(&sc->sc_queue_mtx);

	/* put in a sync marker if required */
	if (sc->sc_marker_required) {
		req = sc->sc_next_req_id++;
		if (sc->sc_next_req_id == sc->sc_maxcmds)
			sc->sc_next_req_id = 0;

		DPRINTF(QLA_D_IO, "%s: writing marker at request %d\n",
		    DEVNAME(sc), req);
		offset = (req * QLA_QUEUE_ENTRY_SIZE);
		iocb = QLA_DMA_KVA(sc->sc_requests) + offset;
		bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_requests),
		    offset, QLA_QUEUE_ENTRY_SIZE, BUS_DMASYNC_POSTWRITE);
		qla_put_marker(sc, iocb);
		qla_queue_write(sc, sc->sc_regs->req_in, sc->sc_next_req_id);
		sc->sc_marker_required = 0;
	}

	req = sc->sc_next_req_id++;
	if (sc->sc_next_req_id == sc->sc_maxcmds)
		sc->sc_next_req_id = 0;

	offset = (req * QLA_QUEUE_ENTRY_SIZE);
	iocb = QLA_DMA_KVA(sc->sc_requests) + offset;
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_requests), offset,
	    QLA_QUEUE_ENTRY_SIZE, BUS_DMASYNC_POSTWRITE);

	ccb->ccb_xs = xs;

	DPRINTF(QLA_D_IO, "%s: writing cmd at request %d\n", DEVNAME(sc), req);
	qla_put_cmd(sc, iocb, xs, ccb);

	qla_queue_write(sc, sc->sc_regs->req_in, sc->sc_next_req_id);

	if (!ISSET(xs->flags, SCSI_POLL)) {
		mtx_leave(&sc->sc_queue_mtx);
		return;
	}

	done = 0;
	SIMPLEQ_INIT(&list);
	do {
		u_int16_t isr, info;

		delay(100);

		if (qla_read_isr(sc, &isr, &info) == 0) {
			continue;
		}

		if (isr != QLA_INT_TYPE_IO) {
			qla_handle_intr(sc, isr, info);
			continue;
		}

		rspin = qla_queue_read(sc, sc->sc_regs->res_in);
		while (rspin != sc->sc_last_resp_id) {
			ccb = qla_handle_resp(sc, sc->sc_last_resp_id);

			sc->sc_last_resp_id++;
			if (sc->sc_last_resp_id == sc->sc_maxcmds)
				sc->sc_last_resp_id = 0;

			if (ccb != NULL)
				SIMPLEQ_INSERT_TAIL(&list, ccb, ccb_link);
			if (ccb == xs->io)
				done = 1;
		}
		qla_queue_write(sc, sc->sc_regs->res_out, rspin);
		qla_clear_isr(sc, isr);
	} while (done == 0);

	mtx_leave(&sc->sc_queue_mtx);

	while ((ccb = SIMPLEQ_FIRST(&list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&list, ccb_link);
		scsi_done(ccb->ccb_xs);
	}
}

u_int16_t
qla_read(struct qla_softc *sc, bus_size_t offset)
{
	u_int16_t v;
	v = bus_space_read_2(sc->sc_iot, sc->sc_ioh, offset);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, offset, 2,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	return (v);
}

void
qla_write(struct qla_softc *sc, bus_size_t offset, u_int16_t value)
{
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, offset, value);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, offset, 2,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
}

u_int16_t
qla_read_mbox(struct qla_softc *sc, int mbox)
{
	/* could range-check mboxes according to chip type? */
	return (qla_read(sc, sc->sc_mbox_base + (mbox * 2)));
}

void
qla_write_mbox(struct qla_softc *sc, int mbox, u_int16_t value)
{
	qla_write(sc, sc->sc_mbox_base + (mbox * 2), value);
}

void
qla_host_cmd(struct qla_softc *sc, u_int16_t cmd)
{
	qla_write(sc, QLA_HOST_CMD_CTRL, cmd << QLA_HOST_CMD_SHIFT);
}

#define MBOX_COMMAND_TIMEOUT	4000

int
qla_mbox(struct qla_softc *sc, int maskin)
{
	int i;
	int result = 0;
	int rv;

	sc->sc_mbox_pending = 1;
	for (i = 0; i < nitems(sc->sc_mbox); i++) {
		if (maskin & (1 << i)) {
			qla_write_mbox(sc, i, sc->sc_mbox[i]);
		}
	}
	qla_host_cmd(sc, QLA_HOST_CMD_SET_HOST_INT);

	if (sc->sc_scsibus != NULL) {
		mtx_enter(&sc->sc_mbox_mtx);
		sc->sc_mbox_pending = 1;
		while (sc->sc_mbox_pending == 1) {
			msleep(sc->sc_mbox, &sc->sc_mbox_mtx, PRIBIO,
			    "qlambox", 0);
		}
		result = sc->sc_mbox[0];
		sc->sc_mbox_pending = 0;
		mtx_leave(&sc->sc_mbox_mtx);
		return (result == QLA_MBOX_COMPLETE ? 0 : result);
	}

	for (i = 0; i < MBOX_COMMAND_TIMEOUT && result == 0; i++) {
		u_int16_t isr, info;

		delay(100);

		if (qla_read_isr(sc, &isr, &info) == 0)
			continue;

		switch (isr) {
		case QLA_INT_TYPE_MBOX:
			result = info;
			break;

		default:
			qla_handle_intr(sc, isr, info);
			break;
		}
	}

	if (result == 0) {
		/* timed out; do something? */
		DPRINTF(QLA_D_MBOX, "%s: mbox timed out\n", DEVNAME(sc));
		rv = 1;
	} else {
		for (i = 0; i < nitems(sc->sc_mbox); i++) {
			sc->sc_mbox[i] = qla_read_mbox(sc, i);
		}
		rv = (result == QLA_MBOX_COMPLETE ? 0 : result);
	}

	qla_clear_isr(sc, QLA_INT_TYPE_MBOX);
	sc->sc_mbox_pending = 0;
	return (rv);
}

void
qla_mbox_putaddr(u_int16_t *mbox, struct qla_dmamem *mem)
{
	mbox[2] = (QLA_DMA_DVA(mem) >> 16) & 0xffff;
	mbox[3] = (QLA_DMA_DVA(mem) >> 0) & 0xffff;
	mbox[6] = (QLA_DMA_DVA(mem) >> 48) & 0xffff;
	mbox[7] = (QLA_DMA_DVA(mem) >> 32) & 0xffff;
}

int
qla_sns_req(struct qla_softc *sc, struct qla_dmamem *mem, int reqsize)
{
	struct qla_sns_req_hdr *header;
	int rv;

	memset(&sc->sc_mbox, 0, sizeof(sc->sc_mbox));
	sc->sc_mbox[0] = QLA_MBOX_SEND_SNS;
	sc->sc_mbox[1] = reqsize / 2;
	qla_mbox_putaddr(sc->sc_mbox, mem);

	header = QLA_DMA_KVA(mem);
	header->resp_len = htole16((QLA_DMA_LEN(mem) - reqsize) / 2);
	header->resp_addr = htole64(QLA_DMA_DVA(mem) + reqsize);
	header->subcmd_len = htole16((reqsize - sizeof(*header)) / 2);

	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(mem), 0, QLA_DMA_LEN(mem),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	rv = qla_mbox(sc, 0x00cf);
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(mem), 0, QLA_DMA_LEN(mem),
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	return (rv);
}

void
qla_set_ints(struct qla_softc *sc, int enabled)
{
	u_int16_t v = enabled ? (QLA_INT_REQ | QLA_RISC_INT_REQ) : 0;
	qla_write(sc, QLA_INT_CTRL, v);
}

int
qla_read_isr_1G(struct qla_softc *sc, u_int16_t *isr, u_int16_t *info)
{
	u_int16_t int_status;

	if (qla_read(sc, QLA_SEMA) & QLA_SEMA_LOCK) {
		*info = qla_read_mbox(sc, 0);
		if (*info & QLA_MBOX_HAS_STATUS)
			*isr = QLA_INT_TYPE_MBOX;
		else
			*isr = QLA_INT_TYPE_ASYNC;
	} else {
		int_status = qla_read(sc, QLA_INT_STATUS);
		if ((int_status & QLA_INT_REQ) == 0)
			return (0);

		*isr = QLA_INT_TYPE_IO;
	}

	return (1);
}

int
qla_read_isr_2G(struct qla_softc *sc, u_int16_t *isr, u_int16_t *info)
{
	u_int32_t v;

	if ((qla_read(sc, QLA_INT_STATUS) & QLA_INT_REQ) == 0)
		return (0);

	v = bus_space_read_4(sc->sc_iot, sc->sc_ioh, QLA_RISC_STATUS_LOW);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, QLA_RISC_STATUS_LOW,
	    4, BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);

	switch (v & QLA_INT_STATUS_MASK) {
	case QLA_23XX_INT_ROM_MBOX:
	case QLA_23XX_INT_ROM_MBOX_FAIL:
	case QLA_23XX_INT_MBOX:
	case QLA_23XX_INT_MBOX_FAIL:
		*isr = QLA_INT_TYPE_MBOX;
		break;

	case QLA_23XX_INT_ASYNC:
		*isr = QLA_INT_TYPE_ASYNC;
		break;

	case QLA_23XX_INT_RSPQ:
		*isr = QLA_INT_TYPE_IO;
		break;

	default:
		*isr = QLA_INT_TYPE_OTHER;
		break;
	}

	*info = (v >> QLA_INT_INFO_SHIFT);

	return (1);
}

void
qla_clear_isr(struct qla_softc *sc, u_int16_t isr)
{
	qla_host_cmd(sc, QLA_HOST_CMD_CLR_RISC_INT);
	switch (isr) {
	case QLA_INT_TYPE_MBOX:
	case QLA_INT_TYPE_ASYNC:
		qla_write(sc, QLA_SEMA, 0);
		break;
	default:
		break;
	}
}

u_int16_t
qla_read_queue_2100(struct qla_softc *sc, bus_size_t queue)
{
	u_int16_t a, b, i;

	for (i = 0; i < 1000; i++) {
		a = qla_read(sc, queue);
		b = qla_read(sc, queue);

		if (a == b)
			return (a);
	}

	DPRINTF(QLA_D_INTR, "%s: queue ptr unstable\n", DEVNAME(sc));

	return (a);
}

int
qla_softreset(struct qla_softc *sc)
{
	int i;
	qla_set_ints(sc, 0);

	/* reset */
	qla_write(sc, QLA_CTRL_STATUS, QLA_CTRL_RESET);
	delay(100);
	/* clear data and control dma engines? */

	/* wait for soft reset to clear */
	for (i = 0; i < 1000; i++) {
		if ((qla_read(sc, QLA_CTRL_STATUS) & QLA_CTRL_RESET) == 0)
			break;

		delay(100);
	}

	if (i == 1000) {
		DPRINTF(QLA_D_INTR, "%s: reset didn't clear\n", DEVNAME(sc));
		qla_set_ints(sc, 0);
		return (ENXIO);
	}

	/* reset FPM */
	qla_write(sc, QLA_CTRL_STATUS, QLA_CTRL_FPM0_REGS);
	qla_write(sc, QLA_FPM_DIAG, QLA_FPM_RESET);
	qla_write(sc, QLA_FPM_DIAG, 0);	/* isp(4) doesn't do this? */
	qla_write(sc, QLA_CTRL_STATUS, QLA_CTRL_RISC_REGS);

	/* reset risc processor */
	qla_host_cmd(sc, QLA_HOST_CMD_RESET);
	delay(100);
	qla_write(sc, QLA_SEMA, 0);
	qla_host_cmd(sc, QLA_HOST_CMD_MASK_PARITY);	/* from isp(4) */
	qla_host_cmd(sc, QLA_HOST_CMD_RELEASE);

	/* reset queue pointers */
	qla_queue_write(sc, sc->sc_regs->req_in, 0);
	qla_queue_write(sc, sc->sc_regs->req_out, 0);
	qla_queue_write(sc, sc->sc_regs->res_in, 0);
	qla_queue_write(sc, sc->sc_regs->res_out, 0);

	qla_set_ints(sc, 1);
	/* isp(4) sends QLA_HOST_CMD_BIOS here.. not documented? */

	/* do a basic mailbox operation to check we're alive */
	sc->sc_mbox[0] = QLA_MBOX_NOP;
	if (qla_mbox(sc, 0x0001)) {
		DPRINTF(QLA_D_INTR, "%s: ISP not responding after reset\n",
		    DEVNAME(sc));
		return (ENXIO);
	}

	return (0);
}

void
qla_update_topology(struct qla_softc *sc)
{
	sc->sc_mbox[0] = QLA_MBOX_GET_LOOP_ID;
	if (qla_mbox(sc, 0x0001)) {
		DPRINTF(QLA_D_PORT, "%s: unable to get loop id\n", DEVNAME(sc));
		sc->sc_topology = QLA_TOPO_N_PORT_NO_TARGET;
	} else {
		sc->sc_topology = sc->sc_mbox[6];
		sc->sc_loop_id = sc->sc_mbox[1];

		switch (sc->sc_topology) {
		case QLA_TOPO_NL_PORT:
		case QLA_TOPO_N_PORT:
			DPRINTF(QLA_D_PORT, "%s: loop id %d\n", DEVNAME(sc),
			    sc->sc_loop_id);
			break;

		case QLA_TOPO_FL_PORT:
		case QLA_TOPO_F_PORT:
			sc->sc_port_id = sc->sc_mbox[2] |
			    (sc->sc_mbox[3] << 16);
			DPRINTF(QLA_D_PORT, "%s: fabric port id %06x\n",
			    DEVNAME(sc), sc->sc_port_id);
			break;

		case QLA_TOPO_N_PORT_NO_TARGET:
		default:
			DPRINTF(QLA_D_PORT, "%s: not connected\n", DEVNAME(sc));
			break;
		}

		switch (sc->sc_topology) {
		case QLA_TOPO_NL_PORT:
		case QLA_TOPO_FL_PORT:
			sc->sc_loop_max_id = 126;
			break;

		case QLA_TOPO_N_PORT:
			sc->sc_loop_max_id = 2;
			break;

		default:
			sc->sc_loop_max_id = 0;
			break;
		}
	}
}

int
qla_update_fabric(struct qla_softc *sc)
{
	struct qla_sns_rft_id *rft;

	if (sc->sc_fabric == 0)
		return (0);

	switch (sc->sc_topology) {
	case QLA_TOPO_F_PORT:
	case QLA_TOPO_FL_PORT:
		break;

	default:
		return (0);
	}

	/* get the name server's port db entry */
	sc->sc_mbox[0] = QLA_MBOX_GET_PORT_DB;
	if (sc->sc_2k_logins) {
		sc->sc_mbox[1] = QLA_F_PORT_HANDLE;
	} else {
		sc->sc_mbox[1] = QLA_F_PORT_HANDLE << 8;
	}
	qla_mbox_putaddr(sc->sc_mbox, sc->sc_scratch);
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_scratch), 0,
	    sizeof(struct qla_get_port_db), BUS_DMASYNC_PREREAD);
	if (qla_mbox(sc, 0x00cf)) {
		DPRINTF(QLA_D_PORT, "%s: get port db for SNS failed: %x\n",
		    DEVNAME(sc), sc->sc_mbox[0]);
		sc->sc_sns_port_name = 0;
	} else {
		struct qla_get_port_db *pdb;
		bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_scratch), 0,
		    sizeof(struct qla_get_port_db), BUS_DMASYNC_POSTREAD);
		pdb = QLA_DMA_KVA(sc->sc_scratch);
		DPRINTF(QLA_D_PORT, "%s: SNS port name %llx\n", DEVNAME(sc),
		    betoh64(pdb->port_name));
		sc->sc_sns_port_name = betoh64(pdb->port_name);
	}

	/*
	 * register fc4 types with the fabric
	 * some switches do this automatically, but apparently
	 * some don't.
	 */
	rft = QLA_DMA_KVA(sc->sc_scratch);
	memset(rft, 0, sizeof(*rft) + sizeof(struct qla_sns_req_hdr));
	rft->subcmd = htole16(QLA_SNS_RFT_ID);
	rft->max_word = htole16(sizeof(struct qla_sns_req_hdr) / 4);
	rft->port_id = htole32(sc->sc_port_id);
	rft->fc4_types[0] = htole32(1 << QLA_FC4_SCSI);
	if (qla_sns_req(sc, sc->sc_scratch, sizeof(*rft))) {
		DPRINTF(QLA_D_PORT, "%s: RFT_ID failed\n", DEVNAME(sc));
		/* we might be able to continue after this fails */
	}

	return (1);
}

int
qla_get_port_name_list(struct qla_softc *sc, u_int32_t match)
{
	int i;
	struct qla_port_name_list *l;
	struct qla_fc_port *port;

	sc->sc_mbox[0] = QLA_MBOX_GET_PORT_NAME_LIST;
	sc->sc_mbox[1] = 0x08;	/* include initiators */
	if (match & QLA_LOCATION_FABRIC)
		sc->sc_mbox[1] |= 0x02;	 /* return all loop ids */
	qla_mbox_putaddr(sc->sc_mbox, sc->sc_scratch);
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_scratch), 0,
	    QLA_DMA_LEN(sc->sc_scratch), BUS_DMASYNC_PREREAD);
	if (qla_mbox(sc, 0x04f)) {
		DPRINTF(QLA_D_PORT, "%s: get port name list failed: %x\n",
		    DEVNAME(sc), sc->sc_mbox[0]);
		return (1);
	}
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_scratch), 0,
	    QLA_DMA_LEN(sc->sc_scratch), BUS_DMASYNC_PREREAD);

	i = 0;
	l = QLA_DMA_KVA(sc->sc_scratch);
	mtx_enter(&sc->sc_port_mtx);
	while (i * sizeof(*l) < sc->sc_mbox[1]) {
		u_int16_t loopid;
		u_int32_t loc;

		loopid = letoh16(l[i].loop_id);
		/* skip special ports */
		switch (loopid) {
		case QLA_F_PORT_HANDLE:
		case QLA_SNS_HANDLE:
		case QLA_FABRIC_CTRL_HANDLE:
			loc = 0;
			break;
		default:
			if (loopid <= sc->sc_loop_max_id) {
				loc = QLA_LOCATION_LOOP_ID(loopid);
			} else {
				/*
				 * we don't have the port id here, so just
				 * indicate it's a fabric port.
				 */
				loc = QLA_LOCATION_FABRIC;
			}
		}

		if (match & loc) {
			port = malloc(sizeof(*port), M_DEVBUF, M_ZERO |
			    M_NOWAIT);
			if (port == NULL) {
				printf("%s: failed to allocate port struct\n",
				    DEVNAME(sc));
				break;
			}
			port->location = loc;
			port->loopid = loopid;
			port->port_name = letoh64(l[i].port_name);
			DPRINTF(QLA_D_PORT, "%s: loop id %d, port name %llx\n",
			    DEVNAME(sc), port->loopid, port->port_name);
			TAILQ_INSERT_TAIL(&sc->sc_ports_found, port, update);
		}
		i++;
	}
	mtx_leave(&sc->sc_port_mtx);

	return (0);
}

struct qla_fc_port *
qla_next_fabric_port(struct qla_softc *sc, u_int32_t *firstport,
    u_int32_t *lastport)
{
	struct qla_sns_ga_nxt *ga;
	struct qla_sns_ga_nxt_resp *gar;
	struct qla_fc_port *fport;
	int result;

	/* get the next port from the fabric nameserver */
	ga = QLA_DMA_KVA(sc->sc_scratch);
	memset(ga, 0, sizeof(*ga) + sizeof(*gar));
	ga->subcmd = htole16(QLA_SNS_GA_NXT);
	ga->max_word = htole16(sizeof(*gar) / 4);
	ga->port_id = htole32(*lastport);
	result = qla_sns_req(sc, sc->sc_scratch, sizeof(*ga));
	if (result) {
		DPRINTF(QLA_D_PORT, "%s: GA_NXT %06x failed: %x\n", DEVNAME(sc),
		    *lastport, result);
		*lastport = 0xffffffff;
		return (NULL);
	}

	gar = (struct qla_sns_ga_nxt_resp *)(ga + 1);
	/* if the response is all zeroes, try again */
	if (gar->port_type_id == 0 && gar->port_name == 0 &&
	    gar->node_name == 0) {
		DPRINTF(QLA_D_PORT, "%s: GA_NXT returned junk\n", DEVNAME(sc));
		return (NULL);
	}

	/* are we back at the start? */
	*lastport = betoh32(gar->port_type_id) & 0xffffff;
	if (*lastport == *firstport) {
		*lastport = 0xffffffff;
		return (NULL);
	}
	if (*firstport == 0xffffffff)
		*firstport = *lastport;

	DPRINTF(QLA_D_PORT, "%s: GA_NXT: port id: %06x, wwpn %llx, wwnn %llx\n",
	    DEVNAME(sc), *lastport, betoh64(gar->port_name),
	    betoh64(gar->node_name));

	/* don't try to log in to ourselves */
	if (*lastport == sc->sc_port_id) {
		return (NULL);
	}

	fport = malloc(sizeof(*fport), M_DEVBUF, M_ZERO | M_NOWAIT);
	if (fport == NULL) {
		printf("%s: failed to allocate a port struct\n",
		    DEVNAME(sc));
		*lastport = 0xffffffff;
		return (NULL);
	}
	fport->port_name = betoh64(gar->port_name);
	fport->node_name = betoh64(gar->node_name);
	fport->location = QLA_LOCATION_PORT_ID(*lastport);
	fport->portid = *lastport;
	return (fport);
}

int
qla_fabric_plogi(struct qla_softc *sc, struct qla_fc_port *port)
{
	int loopid, mboxin, err;
	u_int32_t id;

	loopid = 0;
retry:
	if (port->loopid == 0) {
		mtx_enter(&sc->sc_port_mtx);
		loopid = qla_get_loop_id(sc, loopid);
		mtx_leave(&sc->sc_port_mtx);
		if (loopid == -1) {
			DPRINTF(QLA_D_PORT, "%s: ran out of loop ids\n",
			    DEVNAME(sc));
			return (1);
		}
	}

	mboxin = 0x000f;
	sc->sc_mbox[0] = QLA_MBOX_FABRIC_PLOGI;
	sc->sc_mbox[2] = (port->portid >> 16) & 0xff;
	sc->sc_mbox[3] = port->portid & 0xffff;
	if (sc->sc_2k_logins) {
		sc->sc_mbox[1] = loopid;
		sc->sc_mbox[10] = 0;
		mboxin |= (1 << 10);
	} else {
		sc->sc_mbox[1] = loopid << 8;
	}

	err = qla_mbox(sc, mboxin);
	switch (err) {
	case 0:
		DPRINTF(QLA_D_PORT, "%s: logged in to %06x as %d\n",
		    DEVNAME(sc), port->portid, loopid);
		port->flags &= ~QLA_PORT_FLAG_NEEDS_LOGIN;
		port->loopid = loopid;
		return (0);

	case QLA_MBOX_PORT_USED:
		DPRINTF(QLA_D_PORT, "%s: already logged in to %06x as %d\n",
		    DEVNAME(sc), port->portid, sc->sc_mbox[1]);
		port->flags &= ~QLA_PORT_FLAG_NEEDS_LOGIN;
		port->loopid = sc->sc_mbox[1];
		return (0);

	case QLA_MBOX_LOOP_USED:
		id = (sc->sc_mbox[1] << 16) | sc->sc_mbox[2];
		if (qla_add_logged_in_port(sc, loopid, id)) {
			return (1);
		}
		port->loopid = 0;
		loopid++;
		goto retry;

	default:
		DPRINTF(QLA_D_PORT, "%s: error %x logging in to port %06x\n",
		    DEVNAME(sc), err, port->portid);
		port->loopid = 0;
		return (1);
	}
}

void
qla_fabric_plogo(struct qla_softc *sc, struct qla_fc_port *port)
{
	int mboxin = 0x0003;
	sc->sc_mbox[0] = QLA_MBOX_FABRIC_PLOGO;
	if (sc->sc_2k_logins) {
		sc->sc_mbox[1] = port->loopid;
		sc->sc_mbox[10] = 0;
		mboxin |= (1 << 10);
	} else {
		sc->sc_mbox[1] = port->loopid << 8;
	}

	if (qla_mbox(sc, mboxin))
		DPRINTF(QLA_D_PORT, "%s: loop id %d logout failed\n",
		    DEVNAME(sc), port->loopid);
}

void
qla_update_done(struct qla_softc *sc, int task)
{
	atomic_clearbits_int(&sc->sc_update_tasks, task);
}

void
qla_update_start(struct qla_softc *sc, int task)
{
	atomic_setbits_int(&sc->sc_update_tasks, task);
	task_add(sc->sc_update_taskq, &sc->sc_update_task);
}

void
qla_clear_port_lists(struct qla_softc *sc)
{
	struct qla_fc_port *p;

	while (!TAILQ_EMPTY(&sc->sc_ports_found)) {
		p = TAILQ_FIRST(&sc->sc_ports_found);
		TAILQ_REMOVE(&sc->sc_ports_found, p, update);
		free(p, M_DEVBUF, sizeof *p);
	}

	while (!TAILQ_EMPTY(&sc->sc_ports_new)) {
		p = TAILQ_FIRST(&sc->sc_ports_new);
		TAILQ_REMOVE(&sc->sc_ports_new, p, update);
		free(p, M_DEVBUF, sizeof *p);
	}

	while (!TAILQ_EMPTY(&sc->sc_ports_gone)) {
		p = TAILQ_FIRST(&sc->sc_ports_gone);
		TAILQ_REMOVE(&sc->sc_ports_gone, p, update);
	}
}

void
qla_do_update(void *xsc)
{
	struct qla_softc *sc = xsc;
	int firstport, lastport;
	struct qla_fc_port *port, *fport;

	DPRINTF(QLA_D_PORT, "%s: updating\n", DEVNAME(sc));
	while (sc->sc_update_tasks != 0) {
		if (sc->sc_update_tasks & QLA_UPDATE_TASK_CLEAR_ALL) {
			TAILQ_HEAD(, qla_fc_port) detach;
			DPRINTF(QLA_D_PORT, "%s: detaching everything\n",
			    DEVNAME(sc));

			mtx_enter(&sc->sc_port_mtx);
			qla_clear_port_lists(sc);
			TAILQ_INIT(&detach);
			while (!TAILQ_EMPTY(&sc->sc_ports)) {
				port = TAILQ_FIRST(&sc->sc_ports);
				TAILQ_REMOVE(&sc->sc_ports, port, ports);
				TAILQ_INSERT_TAIL(&detach, port, ports);
			}
			mtx_leave(&sc->sc_port_mtx);

			while (!TAILQ_EMPTY(&detach)) {
				port = TAILQ_FIRST(&detach);
				TAILQ_REMOVE(&detach, port, ports);
				if (port->flags & QLA_PORT_FLAG_IS_TARGET) {
					scsi_detach_target(sc->sc_scsibus,
					    port->loopid, -1);
				}
				sc->sc_targets[port->loopid] = NULL;
				if (port->location & QLA_LOCATION_FABRIC)
					qla_fabric_plogo(sc, port);

				free(port, M_DEVBUF, sizeof *port);
			}

			qla_update_done(sc, QLA_UPDATE_TASK_CLEAR_ALL);
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_SOFTRESET) {
			/* what no */
			qla_update_done(sc, QLA_UPDATE_TASK_SOFTRESET);
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_UPDATE_TOPO) {
			DPRINTF(QLA_D_PORT, "%s: updating topology\n",
			    DEVNAME(sc));
			qla_update_topology(sc);
			qla_update_done(sc, QLA_UPDATE_TASK_UPDATE_TOPO);
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_GET_PORT_LIST) {
			DPRINTF(QLA_D_PORT, "%s: getting port name list\n",
			    DEVNAME(sc));
			mtx_enter(&sc->sc_port_mtx);
			qla_clear_port_lists(sc);
			mtx_leave(&sc->sc_port_mtx);

			qla_get_port_name_list(sc, QLA_LOCATION_LOOP |
			    QLA_LOCATION_FABRIC);
			mtx_enter(&sc->sc_port_mtx);
			TAILQ_FOREACH(port, &sc->sc_ports, ports) {
				TAILQ_INSERT_TAIL(&sc->sc_ports_gone, port,
				    update);
				if (port->location & QLA_LOCATION_FABRIC) {
					port->flags |=
					    QLA_PORT_FLAG_NEEDS_LOGIN;
				}
			}

			/* take care of ports that haven't changed first */
			TAILQ_FOREACH(fport, &sc->sc_ports_found, update) {
				port = sc->sc_targets[fport->loopid];
				if (port == NULL || fport->port_name !=
				    port->port_name) {
					/* new or changed port, handled later */
					continue;
				}

				/*
				 * the port hasn't been logged out, which
				 * means we don't need to log in again, and,
				 * for loop ports, that the port still exists.
				 */
				port->flags &= ~QLA_PORT_FLAG_NEEDS_LOGIN;
				if (port->location & QLA_LOCATION_LOOP)
					TAILQ_REMOVE(&sc->sc_ports_gone,
					    port, update);

				fport->location = 0;
			}
			mtx_leave(&sc->sc_port_mtx);
			qla_update_start(sc, QLA_UPDATE_TASK_PORT_LIST);
			qla_update_done(sc, QLA_UPDATE_TASK_GET_PORT_LIST);
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_PORT_LIST) {
			mtx_enter(&sc->sc_port_mtx);
			fport = TAILQ_FIRST(&sc->sc_ports_found);
			if (fport != NULL) {
				TAILQ_REMOVE(&sc->sc_ports_found, fport,
				    update);
			}
			mtx_leave(&sc->sc_port_mtx);

			if (fport == NULL) {
				DPRINTF(QLA_D_PORT, "%s: done with ports\n",
				    DEVNAME(sc));
				qla_update_done(sc,
				    QLA_UPDATE_TASK_PORT_LIST);
				qla_update_start(sc,
				    QLA_UPDATE_TASK_SCAN_FABRIC);
			} else if (fport->location & QLA_LOCATION_LOOP) {
				DPRINTF(QLA_D_PORT, "%s: loop port %d\n",
				    DEVNAME(sc), fport->loopid);
				if (qla_add_loop_port(sc, fport) != 0)
					free(fport, M_DEVBUF, sizeof *fport);
			} else if (fport->location & QLA_LOCATION_FABRIC) {
				qla_add_fabric_port(sc, fport);
			} else {
				/* already processed */
				free(fport, M_DEVBUF, sizeof *fport);
			}
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_SCAN_FABRIC) {
			DPRINTF(QLA_D_PORT, "%s: starting fabric scan\n",
			    DEVNAME(sc));
			lastport = sc->sc_port_id;
			firstport = 0xffffffff;
			if (qla_update_fabric(sc))
				qla_update_start(sc,
				    QLA_UPDATE_TASK_SCANNING_FABRIC);
			qla_update_done(sc, QLA_UPDATE_TASK_SCAN_FABRIC);
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_SCANNING_FABRIC) {
			fport = qla_next_fabric_port(sc, &firstport, &lastport);
			if (fport != NULL) {
				int disp;

				mtx_enter(&sc->sc_port_mtx);
				disp = qla_classify_port(sc, fport->location,
				    fport->port_name, fport->node_name, &port);
				switch (disp) {
				case QLA_PORT_DISP_CHANGED:
				case QLA_PORT_DISP_MOVED:
					/* we'll log out the old port later */
				case QLA_PORT_DISP_NEW:
					DPRINTF(QLA_D_PORT, "%s: new port "
					    "%06x\n", DEVNAME(sc),
					    fport->portid);
					TAILQ_INSERT_TAIL(&sc->sc_ports_found,
					    fport, update);
					break;
				case QLA_PORT_DISP_DUP:
					free(fport, M_DEVBUF, sizeof *fport);
					break;
				case QLA_PORT_DISP_SAME:
					DPRINTF(QLA_D_PORT, "%s: existing port"
					    " %06x\n", DEVNAME(sc),
					    fport->portid);
					TAILQ_REMOVE(&sc->sc_ports_gone, port,
					    update);
					free(fport, M_DEVBUF, sizeof *fport);
					break;
				}
				mtx_leave(&sc->sc_port_mtx);
			}
			if (lastport == 0xffffffff) {
				DPRINTF(QLA_D_PORT, "%s: finished\n",
				    DEVNAME(sc));
				qla_update_done(sc,
				    QLA_UPDATE_TASK_SCANNING_FABRIC);
				qla_update_start(sc,
				    QLA_UPDATE_TASK_FABRIC_LOGIN);
			}
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_FABRIC_LOGIN) {
			mtx_enter(&sc->sc_port_mtx);
			port = TAILQ_FIRST(&sc->sc_ports_found);
			if (port != NULL) {
				TAILQ_REMOVE(&sc->sc_ports_found, port, update);
			}
			mtx_leave(&sc->sc_port_mtx);

			if (port != NULL) {
				DPRINTF(QLA_D_PORT, "%s: found port %06x\n",
				    DEVNAME(sc), port->portid);
				if (qla_fabric_plogi(sc, port) == 0) {
					qla_add_fabric_port(sc, port);
				} else {
					free(port, M_DEVBUF, sizeof *port);
				}
			} else {
				DPRINTF(QLA_D_PORT, "%s: done with logins\n",
				    DEVNAME(sc));
				qla_update_done(sc,
				    QLA_UPDATE_TASK_FABRIC_LOGIN);
				qla_update_start(sc,
				    QLA_UPDATE_TASK_ATTACH_TARGET |
				    QLA_UPDATE_TASK_DETACH_TARGET);
			}
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_FABRIC_RELOGIN) {
			TAILQ_FOREACH(port, &sc->sc_ports, ports) {
				if (port->flags & QLA_PORT_FLAG_NEEDS_LOGIN) {
					qla_fabric_plogi(sc, port);
					break;
				}
			}

			if (port == NULL)
				qla_update_done(sc,
				    QLA_UPDATE_TASK_FABRIC_RELOGIN);
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_DETACH_TARGET) {
			mtx_enter(&sc->sc_port_mtx);
			port = TAILQ_FIRST(&sc->sc_ports_gone);
			if (port != NULL) {
				sc->sc_targets[port->loopid] = NULL;
				TAILQ_REMOVE(&sc->sc_ports_gone, port, update);
				TAILQ_REMOVE(&sc->sc_ports, port, ports);
			}
			mtx_leave(&sc->sc_port_mtx);

			if (port != NULL) {
				DPRINTF(QLA_D_PORT, "%s: detaching target %d\n",
				    DEVNAME(sc), port->loopid);
				if (sc->sc_scsibus != NULL)
					scsi_detach_target(sc->sc_scsibus,
					    port->loopid, -1);

				if (port->location & QLA_LOCATION_FABRIC)
					qla_fabric_plogo(sc, port);

				free(port, M_DEVBUF, sizeof *port);
			} else {
				qla_update_done(sc,
				    QLA_UPDATE_TASK_DETACH_TARGET);
			}
			continue;
		}

		if (sc->sc_update_tasks & QLA_UPDATE_TASK_ATTACH_TARGET) {
			mtx_enter(&sc->sc_port_mtx);
			port = TAILQ_FIRST(&sc->sc_ports_new);
			if (port != NULL) {
				TAILQ_REMOVE(&sc->sc_ports_new, port, update);
				TAILQ_INSERT_TAIL(&sc->sc_ports, port, ports);
			}
			mtx_leave(&sc->sc_port_mtx);

			if (port != NULL) {
				if (sc->sc_scsibus != NULL)
					scsi_probe_target(sc->sc_scsibus,
					    port->loopid);
			} else {
				qla_update_done(sc,
				    QLA_UPDATE_TASK_ATTACH_TARGET);
			}
			continue;
		}

	}

	DPRINTF(QLA_D_PORT, "%s: done updating\n", DEVNAME(sc));
}

int
qla_async(struct qla_softc *sc, u_int16_t info)
{
	u_int16_t id, exp;

	switch (info) {
	case QLA_ASYNC_SYSTEM_ERROR:
		qla_update_start(sc, QLA_UPDATE_TASK_SOFTRESET);
		break;

	case QLA_ASYNC_REQ_XFER_ERROR:
		qla_update_start(sc, QLA_UPDATE_TASK_SOFTRESET);
		break;

	case QLA_ASYNC_RSP_XFER_ERROR:
		qla_update_start(sc, QLA_UPDATE_TASK_SOFTRESET);
		break;

	case QLA_ASYNC_LIP_OCCURRED:
		DPRINTF(QLA_D_PORT, "%s: lip occurred\n", DEVNAME(sc));
		break;

	case QLA_ASYNC_LOOP_UP:
		DPRINTF(QLA_D_PORT, "%s: loop up\n", DEVNAME(sc));
		sc->sc_loop_up = 1;
		sc->sc_marker_required = 1;
		qla_update_start(sc, QLA_UPDATE_TASK_UPDATE_TOPO |
		    QLA_UPDATE_TASK_GET_PORT_LIST);
		break;

	case QLA_ASYNC_LOOP_DOWN:
		DPRINTF(QLA_D_PORT, "%s: loop down\n", DEVNAME(sc));
		sc->sc_loop_up = 0;
		qla_update_start(sc, QLA_UPDATE_TASK_CLEAR_ALL);
		break;

	case QLA_ASYNC_LIP_RESET:
		DPRINTF(QLA_D_PORT, "%s: lip reset\n", DEVNAME(sc));
		sc->sc_marker_required = 1;
		qla_update_start(sc, QLA_UPDATE_TASK_FABRIC_RELOGIN);
		break;

	case QLA_ASYNC_PORT_DB_CHANGE:
		DPRINTF(QLA_D_PORT, "%s: port db changed %x\n", DEVNAME(sc),
		    qla_read_mbox(sc, 1));
		qla_update_start(sc, QLA_UPDATE_TASK_GET_PORT_LIST);
		break;

	case QLA_ASYNC_CHANGE_NOTIFY:
		DPRINTF(QLA_D_PORT, "%s: name server change (%02x:%02x)\n",
		    DEVNAME(sc), qla_read_mbox(sc, 1), qla_read_mbox(sc, 2));
		qla_update_start(sc, QLA_UPDATE_TASK_GET_PORT_LIST);
		break;

	case QLA_ASYNC_LIP_F8:
		DPRINTF(QLA_D_PORT, "%s: lip f8\n", DEVNAME(sc));
		break;

	case QLA_ASYNC_LOOP_INIT_ERROR:
		DPRINTF(QLA_D_PORT, "%s: loop initialization error: %x\n",
		    DEVNAME(sc), qla_read_mbox(sc, 1));
		break;

	case QLA_ASYNC_LOGIN_REJECT:
		id = qla_read_mbox(sc, 1);
		exp = qla_read_mbox(sc, 2);
		DPRINTF(QLA_D_PORT, "%s: login reject from %x (reason %d,"
		    " explanation %x)\n", DEVNAME(sc), id >> 8, id & 0xff, exp);
		break;

	case QLA_ASYNC_SCSI_CMD_COMPLETE:
		/* shouldn't happen, we disable fast posting */
		break;

	case QLA_ASYNC_CTIO_COMPLETE:
		/* definitely shouldn't happen, we don't do target mode */
		break;

	case QLA_ASYNC_POINT_TO_POINT:
		DPRINTF(QLA_D_PORT, "%s: connected in point-to-point mode\n",
		    DEVNAME(sc));
		/* we get stuck handling these if we have the wrong loop
		 * topology; should somehow reinit with different things
		 * somehow.
		 */
		break;

	case QLA_ASYNC_ZIO_RESP_UPDATE:
		/* shouldn't happen, we don't do zio */
		break;

	case QLA_ASYNC_RND_ERROR:
		/* do nothing? */
		break;

	case QLA_ASYNC_QUEUE_FULL:
		break;

	default:
		DPRINTF(QLA_D_INTR, "%s: unknown async %x\n", DEVNAME(sc),
		    info);
		break;
	}
	return (1);
}

void
qla_dump_iocb(struct qla_softc *sc, void *buf)
{
#ifdef QLA_DEBUG
	u_int8_t *iocb = buf;
	int l;
	int b;

	if ((qladebug & QLA_D_IOCB) == 0)
		return;

	printf("%s: iocb:\n", DEVNAME(sc));
	for (l = 0; l < 4; l++) {
		for (b = 0; b < 16; b++) {
			printf(" %2.2x", iocb[(l*16)+b]);
		}
		printf("\n");
	}
#endif
}

void
qla_dump_iocb_segs(struct qla_softc *sc, void *segs, int n)
{
#ifdef QLA_DEBUG
	u_int8_t *buf = segs;
	int s, b;
	if ((qladebug & QLA_D_IOCB) == 0)
		return;

	printf("%s: iocb segs:\n", DEVNAME(sc));
	for (s = 0; s < n; s++) {
		for (b = 0; b < sizeof(struct qla_iocb_seg); b++) {
			printf(" %2.2x", buf[(s*(sizeof(struct qla_iocb_seg)))
			    + b]);
		}
		printf("\n");
	}
#endif
}

void
qla_put_marker(struct qla_softc *sc, void *buf)
{
	struct qla_iocb_marker *marker = buf;

	marker->entry_type = QLA_IOCB_MARKER;
	marker->entry_count = 1;
	marker->seqno = 0;
	marker->flags = 0;

	/* could be more specific here; isp(4) isn't */
	marker->target = 0;
	marker->modifier = QLA_IOCB_MARKER_SYNC_ALL;
	qla_dump_iocb(sc, buf);
}

void
qla_put_data_seg(struct qla_iocb_seg *seg, bus_dmamap_t dmap, int num)
{
	uint64_t addr = dmap->dm_segs[num].ds_addr;

	htolem32(&seg->seg_addr_lo, addr);
	htolem32(&seg->seg_addr_hi, addr >> 32);
	htolem32(&seg->seg_len, dmap->dm_segs[num].ds_len);
}

void
qla_put_cmd(struct qla_softc *sc, void *buf, struct scsi_xfer *xs,
    struct qla_ccb *ccb)
{
	struct qla_iocb_req34 *req = buf;
	u_int16_t dir;
	int seg;
	int target = xs->sc_link->target;

	req->seqno = 0;
	req->flags = 0;
	req->entry_count = 1;

	if (xs->datalen == 0) {
		dir = QLA_IOCB_CMD_NO_DATA;
		req->req_seg_count = 0;
		req->entry_type = QLA_IOCB_CMD_TYPE_3;
	} else {
		dir = xs->flags & SCSI_DATA_IN ? QLA_IOCB_CMD_READ_DATA :
		    QLA_IOCB_CMD_WRITE_DATA;
		req->req_seg_count = htole16(ccb->ccb_dmamap->dm_nsegs);
		if (ccb->ccb_dmamap->dm_nsegs > QLA_IOCB_SEGS_PER_CMD) {
			req->entry_type = QLA_IOCB_CMD_TYPE_4;
			for (seg = 0; seg < ccb->ccb_dmamap->dm_nsegs; seg++) {
				qla_put_data_seg(&ccb->ccb_t4segs[seg],
				    ccb->ccb_dmamap, seg);
			}
			req->req_type.req4.req4_seg_type = htole16(1);
			req->req_type.req4.req4_seg_base = 0;
			req->req_type.req4.req4_seg_addr =
			    htole64(QLA_DMA_DVA(sc->sc_segments) +
			    ccb->ccb_seg_offset);
			memset(req->req_type.req4.req4_reserved, 0,
			    sizeof(req->req_type.req4.req4_reserved));
			bus_dmamap_sync(sc->sc_dmat,
			    QLA_DMA_MAP(sc->sc_segments), ccb->ccb_seg_offset,
			    sizeof(*ccb->ccb_t4segs) * ccb->ccb_dmamap->dm_nsegs,
			    BUS_DMASYNC_PREWRITE);
		} else {
			req->entry_type = QLA_IOCB_CMD_TYPE_3;
			for (seg = 0; seg < ccb->ccb_dmamap->dm_nsegs; seg++) {
				qla_put_data_seg(&req->req_type.req3_segs[seg],
				    ccb->ccb_dmamap, seg);
			}
		}
	}

	/* isp(4) uses head of queue for 'request sense' commands */
	req->req_flags = htole16(QLA_IOCB_CMD_SIMPLE_QUEUE | dir);

	/*
	 * timeout is in seconds.  make sure it's at least 1 if a timeout
	 * was specified in xs
	 */
	if (xs->timeout != 0)
		req->req_time = htole16(MAX(1, xs->timeout/1000));

	/* lun and target layout vary with firmware attributes */
	if (sc->sc_expanded_lun) {
		if (sc->sc_2k_logins) {
			req->req_target = htole16(target);
		} else {
			req->req_target = htole16(target << 8);
		}
		req->req_scclun = htole16(xs->sc_link->lun);
	} else {
		req->req_target = htole16(target << 8 | xs->sc_link->lun);
	}
	memcpy(req->req_cdb, xs->cmd, xs->cmdlen);
	req->req_totalcnt = htole32(xs->datalen);

	req->req_handle = ccb->ccb_id;

	qla_dump_iocb(sc, buf);
}

int
qla_verify_firmware(struct qla_softc *sc, u_int16_t addr)
{
	sc->sc_mbox[0] = QLA_MBOX_VERIFY_CSUM;
	sc->sc_mbox[1] = addr;
	return (qla_mbox(sc, 0x0003));
}

#ifndef ISP_NOFIRMWARE
int
qla_load_firmware_words(struct qla_softc *sc, const u_int16_t *src,
    u_int16_t dest)
{
	u_int16_t i;

	for (i = 0; i < src[3]; i++) {
		sc->sc_mbox[0] = QLA_MBOX_WRITE_RAM_WORD;
		sc->sc_mbox[1] = i + dest;
		sc->sc_mbox[2] = src[i];
		if (qla_mbox(sc, 0x07)) {
			printf("firmware load failed\n");
			return (1);
		}
	}

	return (qla_verify_firmware(sc, dest));
}

int
qla_load_firmware_2100(struct qla_softc *sc)
{
	return qla_load_firmware_words(sc, isp_2100_risc_code,
	    QLA_2100_CODE_ORG);
}

int
qla_load_firmware_2200(struct qla_softc *sc)
{
	return qla_load_firmware_words(sc, isp_2200_risc_code,
	    QLA_2200_CODE_ORG);
}

int
qla_load_fwchunk_2300(struct qla_softc *sc, struct qla_dmamem *mem,
    const u_int16_t *src, u_int32_t dest)
{
	u_int16_t origin, done, total;
	int i;

	origin = dest;
	done = 0;
	total = src[3];

	while (done < total) {
		u_int16_t *copy;
		u_int32_t words;

		/* limit transfer size otherwise it just doesn't work */
		words = MIN(total - done, 1 << 10);
		copy = QLA_DMA_KVA(mem);
		for (i = 0; i < words; i++) {
			copy[i] = htole16(src[done++]);
		}
		bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(mem), 0, words * 2,
		    BUS_DMASYNC_PREWRITE);

		sc->sc_mbox[0] = QLA_MBOX_LOAD_RAM_EXT;
		sc->sc_mbox[1] = dest;
		sc->sc_mbox[4] = words;
		sc->sc_mbox[8] = dest >> 16;
		qla_mbox_putaddr(sc->sc_mbox, mem);
		if (qla_mbox(sc, 0x01ff)) {
			printf("firmware load failed\n");
			return (1);
		}
		bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(mem), 0, words * 2,
		    BUS_DMASYNC_POSTWRITE);

		dest += words;
	}

	return (qla_verify_firmware(sc, origin));
}

int
qla_load_firmware_2300(struct qla_softc *sc)
{
	struct qla_dmamem *mem;
	const u_int16_t *fw = isp_2300_risc_code;
	int rv;

	mem = qla_dmamem_alloc(sc, 65536);
	rv = qla_load_fwchunk_2300(sc, mem, fw, QLA_2300_CODE_ORG);
	qla_dmamem_free(sc, mem);

	return (rv);
}

int
qla_load_firmware_2322(struct qla_softc *sc)
{
	/* we don't have the 2322 firmware image yet */
#if 0
	struct qla_dmamem *mem;
	const u_int16_t *fw = isp_2322_risc_code;
	u_int32_t addr;
	int i;

	mem = qla_dmamem_alloc(sc, 65536);
	if (qla_load_fwchunk_2300(sc, mem, fw, QLA_2300_CODE_ORG)) {
		qla_dmamem_free(sc, mem);
		return (1);
	}

	for (i = 0; i < 2; i++) {
		fw += fw[3];
		addr = fw[5] | ((fw[4] & 0x3f) << 16);
		if (qla_load_fwchunk_2300(sc, mem, fw, addr)) {
			qla_dmamem_free(sc, mem);
			return (1);
		}
	}

	qla_dmamem_free(sc, mem);
#endif
	return (0);
}

#endif	/* !ISP_NOFIRMWARE */

int
qla_read_nvram(struct qla_softc *sc)
{
	u_int16_t data[sizeof(sc->sc_nvram) >> 1];
	u_int16_t req, cmd, val;
	u_int8_t csum;
	int i, base, bit;

	base = sc->sc_port * 0x80;

	qla_write(sc, QLA_NVRAM, QLA_NVRAM_CHIP_SEL);
	delay(10);
	qla_write(sc, QLA_NVRAM, QLA_NVRAM_CHIP_SEL | QLA_NVRAM_CLOCK);
	delay(10);

	for (i = 0; i < nitems(data); i++) {
		req = (i + base) | (QLA_NVRAM_CMD_READ << 8);

		/* write each bit out through the nvram register */
		for (bit = 10; bit >= 0; bit--) {
			cmd = QLA_NVRAM_CHIP_SEL;
			if ((req >> bit) & 1) {
				cmd |= QLA_NVRAM_DATA_OUT;
			}
			qla_write(sc, QLA_NVRAM, cmd);
			delay(10);
			qla_read(sc, QLA_NVRAM);

			qla_write(sc, QLA_NVRAM, cmd | QLA_NVRAM_CLOCK);
			delay(10);
			qla_read(sc, QLA_NVRAM);

			qla_write(sc, QLA_NVRAM, cmd);
			delay(10);
			qla_read(sc, QLA_NVRAM);
		}

		/* read the result back */
		val = 0;
		for (bit = 0; bit < 16; bit++) {
			val <<= 1;
			qla_write(sc, QLA_NVRAM, QLA_NVRAM_CHIP_SEL |
			    QLA_NVRAM_CLOCK);
			delay(10);
			if (qla_read(sc, QLA_NVRAM) & QLA_NVRAM_DATA_IN)
				val |= 1;
			delay(10);

			qla_write(sc, QLA_NVRAM, QLA_NVRAM_CHIP_SEL);
			delay(10);
			qla_read(sc, QLA_NVRAM);
		}

		qla_write(sc, QLA_NVRAM, 0);
		delay(10);
		qla_read(sc, QLA_NVRAM);

		data[i] = letoh16(val);
	}

	csum = 0;
	for (i = 0; i < nitems(data); i++) {
		csum += data[i] & 0xff;
		csum += data[i] >> 8;
	}

	memcpy(&sc->sc_nvram, data, sizeof(sc->sc_nvram));
	/* id field should be 'ISP ', version should be at least 1 */
	if (sc->sc_nvram.id[0] != 'I' || sc->sc_nvram.id[1] != 'S' ||
	    sc->sc_nvram.id[2] != 'P' || sc->sc_nvram.id[3] != ' ' ||
	    sc->sc_nvram.nvram_version < 1 || (csum != 0)) {
		/*
		 * onboard 2200s on Sun hardware don't have an nvram
		 * fitted, but will provide us with node and port name
		 * through Open Firmware; don't complain in that case.
		 */
		if (sc->sc_node_name == 0 || sc->sc_port_name == 0)
			printf("%s: nvram corrupt\n", DEVNAME(sc));
		return (1);
	}
	return (0);
}

struct qla_dmamem *
qla_dmamem_alloc(struct qla_softc *sc, size_t size)
{
	struct qla_dmamem *m;
	int nsegs;

	m = malloc(sizeof(*m), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (m == NULL)
		return (NULL);

	m->qdm_size = size;

	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &m->qdm_map) != 0)
		goto qdmfree;

	if (bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &m->qdm_seg, 1,
	    &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(sc->sc_dmat, &m->qdm_seg, nsegs, size, &m->qdm_kva,
	    BUS_DMA_NOWAIT) != 0)
		goto free;

	if (bus_dmamap_load(sc->sc_dmat, m->qdm_map, m->qdm_kva, size, NULL,
	    BUS_DMA_NOWAIT) != 0)
		goto unmap;

	return (m);

unmap:
	bus_dmamem_unmap(sc->sc_dmat, m->qdm_kva, m->qdm_size);
free:
	bus_dmamem_free(sc->sc_dmat, &m->qdm_seg, 1);
destroy:
	bus_dmamap_destroy(sc->sc_dmat, m->qdm_map);
qdmfree:
	free(m, M_DEVBUF, sizeof(*m));

	return (NULL);
}

void
qla_dmamem_free(struct qla_softc *sc, struct qla_dmamem *m)
{
	bus_dmamap_unload(sc->sc_dmat, m->qdm_map);
	bus_dmamem_unmap(sc->sc_dmat, m->qdm_kva, m->qdm_size);
	bus_dmamem_free(sc->sc_dmat, &m->qdm_seg, 1);
	bus_dmamap_destroy(sc->sc_dmat, m->qdm_map);
	free(m, M_DEVBUF, sizeof(*m));
}

int
qla_alloc_ccbs(struct qla_softc *sc)
{
	struct qla_ccb		*ccb;
	u_int8_t		*cmd;
	int			i;

	SIMPLEQ_INIT(&sc->sc_ccb_free);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	mtx_init(&sc->sc_queue_mtx, IPL_BIO);
	mtx_init(&sc->sc_port_mtx, IPL_BIO);
	mtx_init(&sc->sc_mbox_mtx, IPL_BIO);

	sc->sc_ccbs = mallocarray(sc->sc_maxcmds, sizeof(struct qla_ccb),
	    M_DEVBUF, M_WAITOK | M_CANFAIL | M_ZERO);
	if (sc->sc_ccbs == NULL) {
		printf("%s: unable to allocate ccbs\n", DEVNAME(sc));
		return (1);
	}

	sc->sc_requests = qla_dmamem_alloc(sc, sc->sc_maxcmds *
	    QLA_QUEUE_ENTRY_SIZE);
	if (sc->sc_requests == NULL) {
		printf("%s: unable to allocate ccb dmamem\n", DEVNAME(sc));
		goto free_ccbs;
	}
	sc->sc_responses = qla_dmamem_alloc(sc, sc->sc_maxcmds *
	    QLA_QUEUE_ENTRY_SIZE);
	if (sc->sc_responses == NULL) {
		printf("%s: unable to allocate rcb dmamem\n", DEVNAME(sc));
		goto free_req;
	}
	sc->sc_segments = qla_dmamem_alloc(sc, sc->sc_maxcmds * QLA_MAX_SEGS *
	    sizeof(struct qla_iocb_seg));
	if (sc->sc_segments == NULL) {
		printf("%s: unable to allocate iocb segments\n", DEVNAME(sc));
		goto free_res;
	}

	cmd = QLA_DMA_KVA(sc->sc_requests);
	memset(cmd, 0, QLA_QUEUE_ENTRY_SIZE * sc->sc_maxcmds);
	for (i = 0; i < sc->sc_maxcmds; i++) {
		ccb = &sc->sc_ccbs[i];

		if (bus_dmamap_create(sc->sc_dmat, MAXPHYS,
		    QLA_MAX_SEGS, MAXPHYS, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &ccb->ccb_dmamap) != 0) {
			printf("%s: unable to create dma map\n", DEVNAME(sc));
			goto free_maps;
		}

		ccb->ccb_sc = sc;
		ccb->ccb_id = i;

		ccb->ccb_seg_offset = i * QLA_MAX_SEGS *
		    sizeof(struct qla_iocb_seg);
		ccb->ccb_t4segs = QLA_DMA_KVA(sc->sc_segments) +
		    ccb->ccb_seg_offset;

		qla_put_ccb(sc, ccb);
	}

	scsi_iopool_init(&sc->sc_iopool, sc, qla_get_ccb, qla_put_ccb);
	return (0);

free_maps:
	while ((ccb = qla_get_ccb(sc)) != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);

	qla_dmamem_free(sc, sc->sc_segments);
free_res:
	qla_dmamem_free(sc, sc->sc_responses);
free_req:
	qla_dmamem_free(sc, sc->sc_requests);
free_ccbs:
	free(sc->sc_ccbs, M_DEVBUF, 0);

	return (1);
}

void
qla_free_ccbs(struct qla_softc *sc)
{
	struct qla_ccb		*ccb;

	scsi_iopool_destroy(&sc->sc_iopool);
	while ((ccb = qla_get_ccb(sc)) != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);
	qla_dmamem_free(sc, sc->sc_segments);
	qla_dmamem_free(sc, sc->sc_responses);
	qla_dmamem_free(sc, sc->sc_requests);
	free(sc->sc_ccbs, M_DEVBUF, 0);
}

void *
qla_get_ccb(void *xsc)
{
	struct qla_softc	*sc = xsc;
	struct qla_ccb		*ccb;

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = SIMPLEQ_FIRST(&sc->sc_ccb_free);
	if (ccb != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_free, ccb_link);
	}
	mtx_leave(&sc->sc_ccb_mtx);
	return (ccb);
}

void
qla_put_ccb(void *xsc, void *io)
{
	struct qla_softc	*sc = xsc;
	struct qla_ccb		*ccb = io;

	ccb->ccb_xs = NULL;
	mtx_enter(&sc->sc_ccb_mtx);
	SIMPLEQ_INSERT_HEAD(&sc->sc_ccb_free, ccb, ccb_link);
	mtx_leave(&sc->sc_ccb_mtx);
}
@


1.54
log
@make qla_iocb_seg structs 4 byte aligned and use htolem32 to set it.

shaves ~256 bytes off of qla_put_data_seg on sparc64

ok kettenis@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.53 2015/09/07 01:37:59 deraadt Exp $ */
d22 1
a31 1
#include <machine/atomic.h>
@


1.53
log
@sizes for free(); ok jmatthew
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.52 2015/08/28 00:03:53 deraadt Exp $ */
d2190 5
a2194 2
	seg->seg_addr = htole64(dmap->dm_segs[num].ds_addr);
	seg->seg_len = htole32(dmap->dm_segs[num].ds_len);
@


1.52
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.51 2015/06/19 11:12:24 jmatthew Exp $ */
d309 1
a309 1
		free(port, M_DEVBUF, 0);
d313 1
a313 1
		free(port, M_DEVBUF, 0);
d1722 1
d1726 1
a1726 1
		free(p, M_DEVBUF, 0);
d1732 1
a1732 1
		free(p, M_DEVBUF, 0);
d1776 1
a1776 1
				free(port, M_DEVBUF, 0);
d1863 1
a1863 1
					free(fport, M_DEVBUF, 0);
d1868 1
a1868 1
				free(fport, M_DEVBUF, 0);
d1905 1
a1905 1
					free(fport, M_DEVBUF, 0);
d1913 1
a1913 1
					free(fport, M_DEVBUF, 0);
d1943 1
a1943 1
					free(port, M_DEVBUF, 0);
d1991 1
a1991 1
				free(port, M_DEVBUF, 0);
@


1.51
log
@remove isp(4) now that the ql* family have replaced it
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.50 2015/03/14 03:38:47 jsg Exp $ */
d2519 1
a2519 1
	free(m, M_DEVBUF, 0);
d2531 1
a2531 1
	free(m, M_DEVBUF, 0);
@


1.50
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.49 2015/02/09 07:43:08 jmatthew Exp $ */
d55 3
a57 3
extern const u_int16_t isp_2100_risc_code[];
extern const u_int16_t isp_2200_risc_code[];
extern const u_int16_t isp_2300_risc_code[];
@


1.49
log
@turn off QLA_DEBUG noise, requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.48 2015/02/09 03:15:41 dlg Exp $ */
a21 1
#include <sys/buf.h>
@


1.48
log
@we want to defer work traditionally (in openbsd) handled in an
interrupt context to a taskq running in a thread. however, there
is a concern that if we do that then we allow accidental use of
sleeping APIs in this work, which will make it harder to move the
work back to interrupts in the future.

guenther and kettenis came up with the idea of marking a proc with
CANTSLEEP which the sleep paths can check and panic on.

this builds on that so you create taskqs that run with CANTSLEEP
set except when they need to sleep for more tasks to run.

the taskq_create api is changed to take a flags argument so users
can specify CANTSLEEP. MPSAFE is also passed via this flags field
now.  this means archs that defined IPL_MPSAFE to 0 can now create
mpsafe taskqs too.

lots of discussion at s2k15
ok guenther@@ miod@@ mpi@@ tedu@@ pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.47 2015/01/27 03:17:36 dlg Exp $ */
a39 2

#define QLA_DEBUG
@


1.47
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.46 2014/12/19 07:23:57 deraadt Exp $ */
d651 1
a651 1
	sc->sc_update_taskq = taskq_create(DEVNAME(sc), 1, IPL_BIO);
@


1.46
log
@another handful of bcopy -> memcpy because there is no overlap
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.45 2014/09/14 14:17:24 jsg Exp $ */
d92 1
a92 1
void		qla_do_update(void *, void*);
d652 1
a652 1
	task_set(&sc->sc_update_task, qla_do_update, sc, NULL);
d670 1
a670 1
		qla_do_update(sc, NULL);
d1744 1
a1744 1
qla_do_update(void *xsc, void *x)
@


1.45
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.44 2014/09/13 16:06:37 doug Exp $ */
d2468 1
a2468 1
	bcopy(data, &sc->sc_nvram, sizeof(sc->sc_nvram));
@


1.44
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.43 2014/07/13 23:10:23 deraadt Exp $ */
a24 1
#include <sys/proc.h>
d32 1
@


1.43
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.42 2014/07/12 18:48:17 tedu Exp $ */
d1967 1
a1967 1
			if (port == TAILQ_END(&sc->sc_ports))
@


1.42
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.41 2014/05/21 23:01:43 jmatthew Exp $ */
d2550 1
a2550 1
	sc->sc_ccbs = malloc(sizeof(struct qla_ccb) * sc->sc_maxcmds,
@


1.41
log
@We only have one possible location to use for a logged in port, so only set
it in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.40 2014/05/17 11:51:21 jmatthew Exp $ */
d312 1
a312 1
		free(port, M_DEVBUF);
d316 1
a316 1
		free(port, M_DEVBUF);
d1728 1
a1728 1
		free(p, M_DEVBUF);
d1734 1
a1734 1
		free(p, M_DEVBUF);
d1778 1
a1778 1
				free(port, M_DEVBUF);
d1865 1
a1865 1
					free(fport, M_DEVBUF);
d1870 1
a1870 1
				free(fport, M_DEVBUF);
d1907 1
a1907 1
					free(fport, M_DEVBUF);
d1915 1
a1915 1
					free(fport, M_DEVBUF);
d1945 1
a1945 1
					free(port, M_DEVBUF);
d1993 1
a1993 1
				free(port, M_DEVBUF);
d2522 1
a2522 1
	free(m, M_DEVBUF);
d2534 1
a2534 1
	free(m, M_DEVBUF);
d2613 1
a2613 1
	free(sc->sc_ccbs, M_DEVBUF);
d2629 1
a2629 1
	free(sc->sc_ccbs, M_DEVBUF);
@


1.40
log
@When the firmware tells us a loop id is already in use, add the device
there to our port lists, then find the next available loop id and carry on
rather than restarting.  This way, we're less likely to get stuck looping
when the firmware behaves inconsistently.  We also don't need to treat domain
controller logins specially.

additional complications discovered by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.39 2014/04/27 08:40:13 jmatthew Exp $ */
a376 1
	u_int32_t location;
a384 1
		location = QLA_LOCATION_PORT_ID(portid);
a389 1
		location = QLA_LOCATION_PORT_ID(portid);
d416 1
a416 1
	port->location = location;
@


1.39
log
@transplant hotplug code over from qle(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.38 2014/04/21 04:17:07 jmatthew Exp $ */
d107 1
a107 1
int		qla_add_domain_ctrl_port(struct qla_softc *, int, u_int32_t);
d110 1
a110 1
int		qla_get_loop_id(struct qla_softc *sc);
d233 1
a233 1
qla_get_loop_id(struct qla_softc *sc)
d245 3
d354 1
d372 1
a372 1
qla_add_domain_ctrl_port(struct qla_softc *sc, int loopid, u_int32_t portid)
d375 36
d414 1
d419 3
a421 3
	port->location = QLA_LOCATION_PORT_ID(portid);
	port->port_name = 0;
	port->node_name = 0;
d424 1
a425 1
	mtx_enter(&sc->sc_port_mtx);
d430 1
a430 1
	DPRINTF(QLA_D_PORT, "%s: added domain controller port %06x at %d\n",
d1635 1
a1635 1
	loopid = port->loopid;
d1637 1
a1637 1
	if (loopid == 0) {
d1639 1
a1639 1
		loopid = qla_get_loop_id(sc);
a1676 6
		/*
		 * domain controller ids (fffcDD, where DD is the domain id)
		 * get special treatment here because we can't find out about
		 * them any other way.  otherwise, we restart the update
		 * process to add the port at this loopid normally.
		 */
d1678 2
a1679 6
		if ((id & QLA_DOMAIN_CTRL_MASK) == QLA_DOMAIN_CTRL) {
			if (qla_add_domain_ctrl_port(sc, loopid, id)) {
				return (1);
			}
			loopid = 0;
			goto retry;
a1680 3
		DPRINTF(QLA_D_PORT, "%s: loop id %d used for port %06x\n",
		    DEVNAME(sc), loopid, id);
		qla_update_start(sc, QLA_UPDATE_TASK_GET_PORT_LIST);
d1682 2
a1683 1
		return (1);
@


1.38
log
@In qla_get_port_name_list, handle malloc failure, skip special fabric ports,
and set location on ports as best we can.  Take the port mutex too.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.37 2014/04/14 04:14:11 jmatthew Exp $ */
d90 4
a93 1
void		qla_update(struct qla_softc *, int);
d103 5
a107 2
int		qla_add_port(struct qla_softc *, u_int16_t, u_int32_t,
		    u_int32_t);
d109 1
a109 1
		    u_int64_t);
d186 1
a186 1
    u_int64_t port_name, u_int64_t node_name)
d196 2
a197 1
		    port->location == location)
d199 1
d203 2
a204 1
	if (sc->sc_scan_taskq == NULL)
d206 1
d208 1
a208 1
	TAILQ_FOREACH(port, &sc->sc_ports_gone, update) {
d218 1
d221 1
d224 1
d227 1
d254 1
a254 2
qla_add_port(struct qla_softc *sc, u_int16_t loopid, u_int32_t portid,
    u_int32_t location)
a255 3
	struct qla_get_port_db *pdb;
	struct qla_fc_port *port;

a261 2
	pdb = QLA_DMA_KVA(sc->sc_scratch);
	memset(pdb, 0, sizeof(*pdb));
d263 3
a265 2
	qla_mbox_putaddr(sc->sc_mbox, sc->sc_scratch);
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_scratch), 0,
d268 2
a269 3
		if (portid != 0)
			DPRINTF(QLA_D_PORT, "%s: get port db %d failed: %x\n",
			    DEVNAME(sc), loopid, sc->sc_mbox[0]);
d273 4
a276 2
	bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_scratch), 0,
	    sizeof(*pdb), BUS_DMASYNC_POSTREAD);
d278 6
a283 3
	/* could also check that the port/node names match what we thought we
	 * logged in to?
	 */
d285 1
a285 4
	port = malloc(sizeof(*port), M_DEVBUF, M_ZERO | M_NOWAIT);
	if (port == NULL) {
		printf("%s: failed to allocate a port structure\n",
		    DEVNAME(sc));
d288 1
d295 86
a380 1
	port->location = location;
d385 2
a386 2
	TAILQ_INSERT_TAIL(&sc->sc_ports_new, port, update);
	sc->sc_targets[loopid] = port;
d389 2
a390 5
	DPRINTF(QLA_D_PORT, "%s: %s %d; port id %06x, name %llx\n",
	    DEVNAME(sc), ISSET(port->flags, QLA_PORT_FLAG_IS_TARGET) ?
	    "target" : "non-target", loopid,
	    (letoh16(pdb->port_id[0]) << 16) | letoh16(pdb->port_id[1]),
	    betoh64(pdb->port_name));
d613 3
d632 1
a632 35
		struct qla_fc_port *port;

		qla_update_topology(sc);
		qla_get_port_name_list(sc, QLA_LOCATION_LOOP);
		while (!TAILQ_EMPTY(&sc->sc_ports_found)) {
			port = TAILQ_FIRST(&sc->sc_ports_found);
			TAILQ_REMOVE(&sc->sc_ports_found, port, update);
			qla_add_port(sc, port->loopid, port->portid,
			    QLA_LOCATION_LOOP_ID(port->loopid));
			free(port, M_DEVBUF);
		}

		if (qla_update_fabric(sc) == 0) {
			u_int32_t firstport = 0xffffffff;
			u_int32_t lastport;

			lastport = sc->sc_port_id;
			do {
				port = qla_next_fabric_port(sc, &firstport,
				    &lastport);
				if (port != NULL)
					TAILQ_INSERT_TAIL(&sc->sc_ports_found,
					    port, update);
			} while (lastport != 0xffffffff);

			while (!TAILQ_EMPTY(&sc->sc_ports_found)) {
				port = TAILQ_FIRST(&sc->sc_ports_found);
				if (qla_fabric_plogi(sc, port) == 0) {
					qla_add_port(sc, port->loopid,
					    port->portid, port->location);
				}
				TAILQ_REMOVE(&sc->sc_ports_found, port, update);
				free(port, M_DEVBUF);
			}
		}
d1400 1
a1400 1
		return (1);
d1408 1
a1408 1
		return (1);
d1451 1
a1451 1
	return (0);
a1587 1

d1591 2
a1592 2
	int loopid;
	int mboxin;
d1594 11
a1604 8
	mtx_enter(&sc->sc_port_mtx);
	loopid = qla_get_loop_id(sc);
	mtx_leave(&sc->sc_port_mtx);

	if (loopid == -1) {
		DPRINTF(QLA_D_PORT, "%s: ran out of loop ids\n",
		    DEVNAME(sc));
		return (1);
d1619 41
a1659 4
	if (qla_mbox(sc, mboxin)) {
		DPRINTF(QLA_D_PORT, "%s: port %06x login %d failed: %x %x %x\n",
		    DEVNAME(sc), port->portid, loopid, sc->sc_mbox[0],
		    sc->sc_mbox[1], sc->sc_mbox[2]);
a1661 2
	port->loopid = loopid;
	return (0);
d1683 1
a1683 1
qla_update(struct qla_softc *sc, int task)
d1685 313
a1997 1
	/* do things */
d2007 1
a2007 1
		qla_update(sc, QLA_UPDATE_SOFTRESET);
d2011 1
a2011 1
		qla_update(sc, QLA_UPDATE_SOFTRESET);
d2015 1
a2015 1
		qla_update(sc, QLA_UPDATE_SOFTRESET);
d2026 2
a2027 1
		qla_update(sc, QLA_UPDATE_FULL_SCAN);
d2033 1
a2033 1
		qla_update(sc, QLA_UPDATE_DISCARD);
d2039 1
a2039 1
		qla_update(sc, QLA_UPDATE_FABRIC_RELOGIN);
d2045 1
a2045 1
		qla_update(sc, QLA_UPDATE_LOOP_SCAN);
d2051 1
a2051 1
		qla_update(sc, QLA_UPDATE_FABRIC_SCAN);
@


1.37
log
@Always copy out all mailbox registers and use msleep in a loop to ensure that
post-attach mailbox operations work reliably.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.36 2014/04/13 12:48:01 jmatthew Exp $ */
d1416 1
d1422 18
a1440 2
		loc = (loopid < QLA_MIN_HANDLE) ? QLA_LOCATION_LOOP :
		    QLA_LOCATION_FABRIC;
d1444 6
d1458 1
@


1.36
log
@In debug output, print loop ids as decimals and port ids as 24bit hex.
Fix some parameters and wording too.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.35 2014/04/07 08:43:54 jmatthew Exp $ */
d78 1
a78 1
int		qla_mbox(struct qla_softc *, int, int);
d258 1
a258 1
	if (qla_mbox(sc, 0x00cf, 0x0001)) {
d399 1
a399 1
	if (qla_mbox(sc, 0x0007, 0x0001)) {
d407 1
a407 2
	if (qla_mbox(sc, QLA_MBOX_ABOUT_FIRMWARE_IN,
	    QLA_MBOX_ABOUT_FIRMWARE_OUT)) {
d424 1
a424 1
	if (qla_mbox(sc, 0x0001, 0x0007)) {
d496 1
a496 1
	rv = qla_mbox(sc, QLA_MBOX_INIT_FIRMWARE_IN, 0x0001);
d514 1
a514 1
	if (qla_mbox(sc, QLA_MBOX_SET_FIRMWARE_OPTIONS_IN, 0x0001)) {
d807 1
d809 4
a812 6
			if (info == QLA_MBOX_COMPLETE) {
				for (i = 1; i < nitems(sc->sc_mbox); i++) {
					sc->sc_mbox[i] = qla_read_mbox(sc, i);
				}
			} else {
				sc->sc_mbox[0] = info;
d814 1
d816 1
d818 1
d1030 1
a1030 1
qla_mbox(struct qla_softc *sc, int maskin, int maskout)
d1044 6
a1049 18
	if (sc->sc_scsibus == NULL) {
		for (i = 0; i < MBOX_COMMAND_TIMEOUT && result == 0; i++) {
			u_int16_t isr, info;

			delay(100);

			if (qla_read_isr(sc, &isr, &info) == 0)
				continue;

			switch (isr) {
			case QLA_INT_TYPE_MBOX:
				result = info;
				break;

			default:
				qla_handle_intr(sc, isr, info);
				break;
			}
a1050 2
	} else {
		tsleep(sc->sc_mbox, PRIBIO, "qla_mbox", 0);
d1052 3
d1057 16
a1072 5
	switch (result) {
	case QLA_MBOX_COMPLETE:
		for (i = 1; i < nitems(sc->sc_mbox); i++) {
			sc->sc_mbox[i] = (maskout & (1 << i)) ?
			    qla_read_mbox(sc, i) : 0;
d1074 1
a1074 2
		rv = 0;
		break;
d1076 1
a1076 1
	case 0:
d1080 5
a1084 6
		break;

	default:
		sc->sc_mbox[0] = result;
		rv = result;
		break;
d1119 1
a1119 1
	rv = qla_mbox(sc, 0x00cf, 0x0003);
d1274 1
a1274 1
	if (qla_mbox(sc, 0x0001, 0x0001)) {
d1287 1
a1287 1
	if (qla_mbox(sc, 0x0001, QLA_MBOX_GET_LOOP_ID_OUT)) {
d1359 1
a1359 1
	if (qla_mbox(sc, 0x00cf, 0x0001)) {
d1406 1
a1406 1
	if (qla_mbox(sc, 0x04f, 0x003)) {
d1531 1
a1531 1
	if (qla_mbox(sc, mboxin, 0x00c7)) {
d1554 1
a1554 1
	if (qla_mbox(sc, mboxin, 0x03))
d1815 1
a1815 1
	return (qla_mbox(sc, 0x0003, 0x0003));
d1829 1
a1829 1
		if (qla_mbox(sc, 0x07, 0x01)) {
d1881 1
a1881 1
		if (qla_mbox(sc, 0x01ff, 0x0001)) {
d2086 1
@


1.35
log
@When iterating through fabric ports, start at our own port ID.  It doesn't
matter if we don't see ourselves, and if we pick another starting point, the
first port we see might disappear half way through (I have seen this happen),
which makes it more complicated to identify when we're back at the start.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.34 2014/04/07 00:38:43 jmatthew Exp $ */
d260 1
a260 1
			DPRINTF(QLA_D_PORT, "%s: get port db %x failed: %x\n",
d1457 2
a1458 2
		DPRINTF(QLA_D_PORT, "%s: GA_NXT %x failed: %x\n", DEVNAME(sc),
		    lastport, result);
d1480 1
a1480 1
	DPRINTF(QLA_D_PORT, "%s: GA_NXT: port id: %x, wwpn %llx, wwnn %llx\n",
d1533 3
a1535 4
		DPRINTF(QLA_D_PORT, "%s: port %x login failed: %x %x %x %x\n",
		    DEVNAME(sc), port->portid, sc->sc_mbox[0],
		    sc->sc_mbox[1], sc->sc_mbox[2],
		    sc->sc_mbox[6]);
d1556 1
a1556 1
		DPRINTF(QLA_D_PORT, "%s: port %x logout failed\n",
@


1.34
log
@ISP2322 chips need a different firmware image to other 2300s, so until we
add that, don't try loading firmware for them.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.33 2014/04/05 12:49:27 jmatthew Exp $ */
d551 1
a551 1
			u_int32_t lastport = 0;
d553 1
@


1.33
log
@set adapter buswidth according to the number of loop ids supported by the
firmware (2048 for 2k login firmware, 256 otherwise)

pointed out by deraadt@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.32 2014/04/04 11:27:41 jmatthew Exp $ */
d123 1
d340 2
a341 1
		loadfirmware = qla_load_firmware_2300;
d391 9
a399 1
	if (qla_mbox(sc, 0x0003, 0x0001)) {
d1900 18
d1925 6
a1930 12
	/* additional firmware chunks for 2322 */
	if (sc->sc_isp_type == QLA_ISP2322) {
		u_int32_t addr;
		int i;

		for (i = 0; i < 2; i++) {
			fw += fw[3];
			addr = fw[5] | ((fw[4] & 0x3f) << 16);
			if (qla_load_fwchunk_2300(sc, mem, fw, addr)) {
				qla_dmamem_free(sc, mem);
				return (1);
			}
d1935 1
@


1.32
log
@Rework the command polling loop so it can handle multiple responses in a single
interrupt.  With this we can talk to Hitachi disk arrays, which sometimes
return so much sense data that a status continuation response is generated
in addition to the normal status response.

tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.31 2014/03/31 11:25:45 jmatthew Exp $ */
d569 7
a575 3
	sc->sc_link.adapter_target = QLA_MAX_TARGETS;
	sc->sc_link.adapter_buswidth = QLA_MAX_TARGETS;
	sc->sc_link.openings = sc->sc_maxcmds; /* / sc->sc_buswidth? */
@


1.31
log
@Rather than scanning local loop ids sequentially, just ask the chip which
local devices it has logged in to.  This will also be useful for hotplug
later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.30 2014/02/23 10:40:19 jmatthew Exp $ */
a69 1
struct qla_ccb *qla_scsi_cmd_poll(struct qla_softc *);
d859 2
a860 2
	u_int16_t		req;
	int			offset, error;
d933 1
a935 19
		ccb = qla_scsi_cmd_poll(sc);
		SIMPLEQ_INSERT_TAIL(&list, ccb, ccb_link);
	} while (xs->io != ccb);

	mtx_leave(&sc->sc_queue_mtx);

	while ((ccb = SIMPLEQ_FIRST(&list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&list, ccb_link);
		scsi_done(ccb->ccb_xs);
	}
}

struct qla_ccb *
qla_scsi_cmd_poll(struct qla_softc *sc)
{
	u_int16_t rspin;
	struct qla_ccb *ccb = NULL;

	while (ccb == NULL) {
d950 1
a950 1
		if (rspin != sc->sc_last_resp_id) {
d957 4
a960 2
			qla_queue_write(sc, sc->sc_regs->res_out,
			    sc->sc_last_resp_id);
d962 3
d966 5
a970 1
		qla_clear_isr(sc, isr);
a971 2

	return (ccb);
@


1.30
log
@when built without firmware, check that the chip already has firmware
before trying to boot it, so we can explain why it's not working rather
than printing cryptic errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.29 2014/02/22 15:36:10 deraadt Exp $ */
d98 1
d315 1
d528 1
a528 1
		int i;
d531 7
a537 5
		for (i = 0; i < sc->sc_loop_max_id; i++) {
			if (i != sc->sc_loop_id) {
				qla_add_port(sc, i, 0,
				    QLA_LOCATION_LOOP_ID(i));
			}
a540 1
			TAILQ_HEAD(, qla_fc_port) found;
a542 1
			struct qla_fc_port *port;
a543 1
			TAILQ_INIT(&found);
d548 2
a549 1
					TAILQ_INSERT_TAIL(&found, port, update);
d552 2
a553 2
			while (!TAILQ_EMPTY(&found)) {
				port = TAILQ_FIRST(&found);
d558 1
a558 1
				TAILQ_REMOVE(&found, port, update);
d1385 47
@


1.29
log
@refactor firmware loading with a function pointer
ok jmatthew
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.28 2014/02/20 20:20:28 kettenis Exp $ */
d115 1
d308 1
d322 1
d331 1
d340 1
d373 6
a378 1
#ifndef ISP_NOFIRMWARE
d380 1
a380 1
		printf("firmware load failed\n");
d387 1
a387 9
	switch (sc->sc_isp_gen) {
	case QLA_GEN_ISP2100:
	case QLA_GEN_ISP2200:
		sc->sc_mbox[1] = QLA_2200_CODE_ORG;
		break;
	case QLA_GEN_ISP23XX:
		sc->sc_mbox[1] = QLA_2300_CODE_ORG;
		break;
	}
d1760 8
d1785 1
a1785 9
	sc->sc_mbox[0] = QLA_MBOX_VERIFY_CSUM;
	sc->sc_mbox[1] = dest;
	if (qla_mbox(sc, 0x0003, 0x0003)) {
		printf("verification of chunk at %x failed: %x\n",
		    dest, sc->sc_mbox[1]);
		return (1);
	}

	return (0);
d1841 1
a1841 9
	sc->sc_mbox[0] = QLA_MBOX_VERIFY_CSUM;
	sc->sc_mbox[1] = origin;
	if (qla_mbox(sc, 0x0003, 0x0003)) {
		printf("verification of chunk at %x failed: %x\n", origin,
		    sc->sc_mbox[1]);
		return (1);
	}

	return (0);
d1851 4
a1854 1
	qla_load_fwchunk_2300(sc, mem, fw, QLA_2300_CODE_ORG);
d1864 4
a1867 1
			qla_load_fwchunk_2300(sc, mem, fw, addr);
@


1.28
log
@More turd shining; cleanup the message that prints the firmware revision and
attributes.

ok dlg@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.27 2014/02/20 11:09:48 kettenis Exp $ */
d304 3
d317 3
d325 3
d333 3
d368 4
a371 22
	switch (sc->sc_isp_gen) {
	case QLA_GEN_ISP2100:
		if (qla_load_firmware_2100(sc)) {
			printf("firmware load failed\n");
			return (ENXIO);
		}
		break;

	case QLA_GEN_ISP2200:
		if (qla_load_firmware_2200(sc)) {
			printf("firmware load failed\n");
			return (ENXIO);
		}
		break;

	case QLA_GEN_ISP23XX:
		if (qla_load_firmware_2300(sc)) {
			printf("firmware load failed\n");
			return (ENXIO);
		}
		break;

d373 1
d614 1
a614 1
	
d692 1
a692 1
		
d917 1
a917 1
	    
d1758 1
a1758 28
#ifdef ISP_NOFIRMWARE

int
qla_load_firmware_words(struct qla_softc *sc, const u_int16_t *)
{
	return (0);
}

int
qla_load_firmware_2100(struct qla_softc *sc)
{
	return (0);
}

int
qla_load_firmware_2200(struct qla_softc *sc)
{
	return (0);
}

int
qla_load_firmware_2300(struct qla_softc *sc)
{
	return (0);
}

#else

d1875 1
a1875 1
#endif	/* ISP_NOFIRMWARE */
d1891 1
a1891 1
	
d2109 1
a2109 1
	struct qla_softc 	*sc = xsc;
@


1.27
log
@Avoid printing the "nvram corrupt" message for onboard 2200s found on Sun
hardware.

ok dlg@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.26 2014/02/20 03:39:07 dlg Exp $ */
d405 2
a406 2
	printf("firmware v%d.%d.%d, attrs %x\n", sc->sc_mbox[1], sc->sc_mbox[2],
	    sc->sc_mbox[3], sc->sc_mbox[6]);
@


1.26
log
@jsg@@ pointed out i am bad at loops.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.25 2014/02/20 00:42:44 dlg Exp $ */
d1980 7
a1986 1
		printf("%s: nvram corrupt\n", DEVNAME(sc));
@


1.25
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.24 2014/02/20 00:23:00 dlg Exp $ */
d1211 1
a1211 1
	do {
d1217 1
d1219 1
a1219 4
	} while (++i < 1000);

	DPRINTF(QLA_D_INTR, "%s: queue ptr unstable\n",
	    DEVNAME(sc));
@


1.24
log
@pull the isr reads out into per chip variants we get to via pointers
in a per generation structure. this avoids code on every isr to figure
out what version of the chip we are, which is silly since we know that
at attach time.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.22 2014/02/19 06:29:08 jmatthew Exp $ */
d625 1
a625 1
	switch(entry[0]) {
@


1.23
log
@tweak the response queue handling so it looks like qle. the important
bit is to post to the resp_out register once outside the loop rather
than inside every loop.

rework the code for finding the queue registers so its done once
on attach by pointing the sc at a map, rather than running big
conditionals in code on every register operation based on teh chip
version.

tested on 2200s by me and 2312s by jmatthew@@
ok jmatthew@@
@
text
@d87 2
a88 1
int		qla_read_isr(struct qla_softc *, u_int16_t *, u_int16_t *);
d135 1
a135 1
static const struct qla_queue_regs qla_queue_regs_2100 = {
d137 1
d144 1
a144 1
static const struct qla_queue_regs qla_queue_regs_2200 = {
d146 1
d153 1
a153 1
static const struct qla_queue_regs qla_queue_regs_23XX = {
d155 1
d162 1
a162 1
#define qla_queue_read(_sc, _r) ((*(_sc)->sc_q->read)((_sc), (_r)))
d165 3
d313 1
a313 1
		sc->sc_q = &qla_queue_regs_2100;
d318 1
a318 1
		sc->sc_q = &qla_queue_regs_2200;
d323 1
a323 1
		sc->sc_q = &qla_queue_regs_23XX;
d758 1
a758 4
		/* apparently can't read the out ptr with <2300 chips,
		 * and apparently also need to debounce the in ptr reads
		 */
		rspin = qla_queue_read(sc, sc->sc_q->res_in);
d791 1
a791 1
		qla_queue_write(sc, sc->sc_q->res_out, rspin);
d910 1
a910 1
		qla_queue_write(sc, sc->sc_q->req_in, sc->sc_next_req_id);
d928 1
a928 1
	qla_queue_write(sc, sc->sc_q->req_in, sc->sc_next_req_id);
d969 1
a969 1
		rspin = qla_queue_read(sc, sc->sc_q->res_in);
d977 1
a977 1
			qla_queue_write(sc, sc->sc_q->res_out,
d1133 1
a1133 1
qla_read_isr(struct qla_softc *sc, u_int16_t *isr, u_int16_t *info)
a1135 1
	u_int32_t v;
d1137 10
a1146 13
	switch (sc->sc_isp_gen) {
	case QLA_GEN_ISP2100:
	case QLA_GEN_ISP2200:
		if (qla_read(sc, QLA_SEMA) & QLA_SEMA_LOCK) {
			*info = qla_read_mbox(sc, 0);
			if (*info & QLA_MBOX_HAS_STATUS)
				*isr = QLA_INT_TYPE_MBOX;
			else
				*isr = QLA_INT_TYPE_ASYNC;
		} else {
			int_status = qla_read(sc, QLA_INT_STATUS);
			if ((int_status & QLA_INT_REQ) == 0)
				return (0);
d1148 2
a1149 3
			*isr = QLA_INT_TYPE_IO;
		}
		return (1);
d1151 2
a1152 3
	case QLA_GEN_ISP23XX:
		if ((qla_read(sc, QLA_INT_STATUS) & QLA_INT_REQ) == 0)
			return (0);
d1154 4
a1157 12
		v = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    QLA_RISC_STATUS_LOW);
		bus_space_barrier(sc->sc_iot, sc->sc_ioh, QLA_RISC_STATUS_LOW,
		    4, BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);

		switch (v & QLA_INT_STATUS_MASK) {
		case QLA_23XX_INT_ROM_MBOX:
		case QLA_23XX_INT_ROM_MBOX_FAIL:
		case QLA_23XX_INT_MBOX:
		case QLA_23XX_INT_MBOX_FAIL:
			*isr = QLA_INT_TYPE_MBOX;
			break;
d1159 2
a1160 3
		case QLA_23XX_INT_ASYNC:
			*isr = QLA_INT_TYPE_ASYNC;
			break;
d1162 11
a1172 3
		case QLA_23XX_INT_RSPQ:
			*isr = QLA_INT_TYPE_IO;
			break;
d1174 3
a1176 4
		default:
			*isr = QLA_INT_TYPE_OTHER;
			break;
		}
d1178 3
a1180 2
		*info = (v >> QLA_INT_INFO_SHIFT);
		return (1);
d1183 2
a1184 1
		return (0);
d1186 4
d1265 4
a1268 4
	qla_queue_write(sc, sc->sc_q->req_in, 0);
	qla_queue_write(sc, sc->sc_q->req_out, 0);
	qla_queue_write(sc, sc->sc_q->res_in, 0);
	qla_queue_write(sc, sc->sc_q->res_out, 0);
@


1.22
log
@remove some dead code - all the chips we handle can do type 4 commands,
which means we don't need to use sgl continuation command buffers.
this keeps things much simpler on the iopool side of things.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.21 2014/02/18 11:48:09 jmatthew Exp $ */
d73 2
a74 2
u_int16_t	qla_read(struct qla_softc *, int);
void		qla_write(struct qla_softc *, int, u_int16_t);
d77 2
a89 4
int		qla_queue_reg(struct qla_softc *, enum qla_qptr);
u_int16_t	qla_read_queue_ptr(struct qla_softc *, enum qla_qptr);
void		qla_write_queue_ptr(struct qla_softc *, enum qla_qptr,
		    u_int16_t);
d134 27
d306 1
d311 1
d316 1
d754 1
a754 1
		rspin = qla_read_queue_ptr(sc, QLA_RESP_QUEUE_IN);
d769 13
a781 6
			/* isp(4) has some weird magic for this case */
			DPRINTF(QLA_D_INTR, "%s: nonsense interrupt (%x)\n",
			    DEVNAME(sc), rspin);
		} else {
			if (sc->sc_responses == NULL)
				break;
d783 3
a785 11
			DPRINTF(QLA_D_IO, "%s: response queue %x=>%x\n",
			    DEVNAME(sc), sc->sc_last_resp_id, rspin);
			while (sc->sc_last_resp_id != rspin) {
				ccb = qla_handle_resp(sc, sc->sc_last_resp_id);
				if (ccb)
					scsi_done(ccb->ccb_xs);

				sc->sc_last_resp_id++;
				if (sc->sc_last_resp_id == sc->sc_maxcmds)
					sc->sc_last_resp_id = 0;
			}
d787 1
a787 3
			qla_write_queue_ptr(sc, QLA_RESP_QUEUE_OUT,
			    sc->sc_last_resp_id);
		}
d906 1
a906 1
		qla_write_queue_ptr(sc, QLA_REQ_QUEUE_IN, sc->sc_next_req_id);
d924 1
a924 1
	qla_write_queue_ptr(sc, QLA_REQ_QUEUE_IN, sc->sc_next_req_id);
d965 1
a965 1
		rspin = qla_read_queue_ptr(sc, QLA_RESP_QUEUE_IN);
d973 1
a973 1
			qla_write_queue_ptr(sc, QLA_RESP_QUEUE_OUT,
d984 1
a984 1
qla_read(struct qla_softc *sc, int offset)
d994 1
a994 1
qla_write(struct qla_softc *sc, int offset, u_int16_t value)
d1204 2
a1205 2
int
qla_queue_reg(struct qla_softc *sc, enum qla_qptr queue)
d1207 1
a1207 12
	switch (sc->sc_isp_gen) {
	case QLA_GEN_ISP2100:
	case QLA_GEN_ISP2200:
		switch (queue) {
		case QLA_REQ_QUEUE_IN:
		case QLA_REQ_QUEUE_OUT:
			return (sc->sc_mbox_base + 8);
		case QLA_RESP_QUEUE_IN:
		case QLA_RESP_QUEUE_OUT:
			return (sc->sc_mbox_base + 10);
		}
		break;
d1209 3
a1211 13
	case QLA_GEN_ISP23XX:
		switch (queue) {
		case QLA_REQ_QUEUE_IN:
			return (QLA_REQ_IN);
		case QLA_REQ_QUEUE_OUT:
			return (QLA_REQ_OUT);
		case QLA_RESP_QUEUE_IN:
			return (QLA_RESP_IN);
		case QLA_RESP_QUEUE_OUT:
			return (QLA_RESP_OUT);
		}
		break;
	}
d1213 2
a1214 2
	panic("unknown queue");
}
d1216 1
a1216 14
u_int16_t
qla_read_queue_ptr(struct qla_softc *sc, enum qla_qptr queue)
{
	u_int16_t a, b, i;
	switch (sc->sc_isp_gen) {
	case QLA_GEN_ISP2100:
		do {
			a = qla_read(sc, qla_queue_reg(sc, queue));
			b = qla_read(sc, qla_queue_reg(sc, queue));
		} while (a != b && ++i < 1000);
		if (i == 1000)
			DPRINTF(QLA_D_INTR, "%s: queue ptr unstable\n",
			    DEVNAME(sc));
		return (a);
d1218 2
a1219 4
	default:
		return (qla_read(sc, qla_queue_reg(sc, queue)));
	}
}
d1221 1
a1221 5
void
qla_write_queue_ptr(struct qla_softc *sc, enum qla_qptr queue,
    u_int16_t value)
{
	qla_write(sc, qla_queue_reg(sc, queue), value);
d1263 4
a1266 4
	qla_write_queue_ptr(sc, QLA_REQ_QUEUE_IN, 0);
	qla_write_queue_ptr(sc, QLA_REQ_QUEUE_OUT, 0);
	qla_write_queue_ptr(sc, QLA_RESP_QUEUE_IN, 0);
	qla_write_queue_ptr(sc, QLA_RESP_QUEUE_OUT, 0);
@


1.21
log
@convert printfs into a few different debug categories, leaving port
discovery stuff enabled for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.20 2014/02/11 11:41:46 jmatthew Exp $ */
a95 4
#if 0
void		qla_put_cmd_cont(struct qla_softc *, void *,
		    struct scsi_xfer *, bus_dmamap_t, int);
#endif
a1776 17

#if 0
void
qla_put_cmd_cont(struct qla_softc *sc, void *buf, struct scsi_xfer *xs,
    bus_dmamap_t dmap, int offset)
{
	int seg;
	struct qla_iocb_cont1 *cont1 = buf;
	cont1->entry_type = QLA_IOCB_CONT_TYPE_1;
	cont1->entry_count = 1;
	for (seg = 0; seg < QLA_IOCB_SEGS_PER_CMD_CONT; seg++) {
		if (seg + offset == dmap->dm_nsegs)
			break;
		qla_put_data_seg(&cont1->segs[seg], dmap, seg + offset);
	}
}
#endif
@


1.20
log
@fix endianness of fc4 type registration (again), and don't bother printing
the fc4 types for fabric ports we find
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.19 2014/02/10 22:41:27 jmatthew Exp $ */
d41 16
d230 1
a230 1
			printf("%s: get port db for %x failed: %x\n",
d263 1
a263 1
	printf("%s: %s %d; port id %06x, name %llx\n",
d533 2
a534 1
		printf("%s: loop still down, giving up\n", DEVNAME(sc));
d593 1
a593 1
	/*qla_dump_iocb(sc, entry);*/
d606 2
a607 2
			printf("%s: got status for inactive ccb %d\n",
			    DEVNAME(sc), handle);
d650 1
a650 1
			printf("%s: dma error\n", DEVNAME(sc));
d655 2
a656 1
			printf("%s: reset destroyed command\n", DEVNAME(sc));
d662 1
a662 1
			printf("%s: aborted\n", DEVNAME(sc));
d668 2
a669 1
			printf("%s: command timed out\n", DEVNAME(sc));
d680 1
a680 1
			printf("%s: queue full\n", DEVNAME(sc));
d687 1
a687 1
			printf("%s: dev gone\n", DEVNAME(sc));
d692 2
a693 2
			printf("%s: unexpected completion status %x\n",
			    DEVNAME(sc), status->completion);
d700 1
a700 1
		printf("%s: ignoring status continuation iocb\n",
a703 5
	case QLA_IOCB_MAILBOX:
		printf("%s: eat mailbox?\n", DEVNAME(sc));
		/* ok */
		break;

d706 1
a706 1
		printf("%s: unexpected response entry type %x\n",
d740 2
a741 2
				printf("%s: ignoring premature mbox int\n",
				    DEVNAME(sc));
d746 2
a747 2
			printf("%s: nonsense interrupt (%x)\n", DEVNAME(sc),
			    rspin);
d752 2
d780 2
a781 2
			printf("%s: unexpected mbox interrupt: %x\n",
			    DEVNAME(sc), info);
d841 2
a842 1
		printf("%s: too fat (%d)\n", DEVNAME(sc), xs->cmdlen);
d878 2
a879 1
		printf("%s: writing marker at request %d\n", DEVNAME(sc), req);
d900 1
d1051 1
a1051 1
		printf("mbox timed out\n");
a1055 1
		/* log a thing? */
d1227 2
a1228 1
			printf("%s: queue ptr unstable\n", DEVNAME(sc));
d1263 1
a1263 1
		printf("reset didn't clear\n");
d1293 2
a1294 1
		printf("ISP not responding after reset\n");
d1306 1
a1306 1
		printf("%s: unable to get loop id\n", DEVNAME(sc));
d1315 1
a1315 1
			printf("%s: loop id %d\n", DEVNAME(sc),
d1323 2
a1324 2
			printf("%s: fabric port id %06x\n", DEVNAME(sc), 
			    sc->sc_port_id);
d1329 1
a1329 1
			printf("%s: not useful\n", DEVNAME(sc));
d1378 1
a1378 1
		printf("%s: get port db for SNS failed: %x\n",
d1386 1
a1386 1
		printf("%s: SNS port name %llx\n", DEVNAME(sc),
d1403 1
a1403 1
		printf("%s: RFT_ID failed\n", DEVNAME(sc));
d1427 2
a1428 2
		printf("%s: GA_NXT %x failed: %x\n", DEVNAME(sc), lastport,
		    result);
d1437 1
a1437 1
		printf("%s: GA_NXT returned junk\n", DEVNAME(sc));
d1450 1
a1450 1
	printf("%s: GA_NXT: port type/id: %x, wwpn %llx, wwnn %llx\n",
d1485 1
a1485 1
		printf("%s: ran out of loop ids\n",
d1503 1
a1503 1
		printf("%s: port %x login failed: %x %x %x %x\n",
d1527 2
a1528 1
		printf("%s: PLOGO %x failed\n", DEVNAME(sc), port->loopid);
d1556 1
a1556 1
		printf("%s: lip occurred\n", DEVNAME(sc));
d1560 1
a1560 1
		printf("%s: loop up\n", DEVNAME(sc));
d1567 1
a1567 1
		printf("%s: loop down\n", DEVNAME(sc));
d1573 1
a1573 1
		printf("%s: lip reset\n", DEVNAME(sc));
d1579 1
a1579 1
		printf("%s: port db changed %x\n", DEVNAME(sc),
d1585 2
a1586 2
		printf("%s: name server change (%02x:%02x)\n", DEVNAME(sc),
		    qla_read_mbox(sc, 1), qla_read_mbox(sc, 2));
d1591 1
a1591 1
		printf("%s: lip f8\n", DEVNAME(sc));
d1595 2
a1596 2
		printf("%s: loop initialization error: %x", DEVNAME(sc), 
		    qla_read_mbox(sc, 1));
d1602 2
a1603 2
		printf("%s: login reject from %x (reason %d, explanation %x)",
		    DEVNAME(sc), id >> 8, id & 0xff, exp);
d1615 2
a1616 1
		printf("%s: connected in point-to-point mode\n", DEVNAME(sc));
d1635 2
a1636 1
		printf("%s: unknown async %x\n", DEVNAME(sc), info);
d1645 1
d1650 3
d1660 1
d1666 1
d1669 3
d1680 1
d1696 1
d1778 2
@


1.19
log
@Build isp2xxx firmware into separate object files so we only include
one copy when both isp(4) and qla(4) are enabled.  This is a temporary
measure until qla(4) takes over completely.

looked at by miod@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.18 2014/02/06 09:51:42 jmatthew Exp $ */
d1381 1
a1381 1
	rft->fc4_types[0] = (1 << QLA_FC4_SCSI);
d1430 1
a1430 1
	printf("%s: GA_NXT: port type/id: %x, wwpn %llx, wwnn %llx, fct: %x\n",
d1432 1
a1432 1
	    betoh64(gar->node_name), gar->fc4_types[0]);
@


1.18
log
@Almost-working QLA2100 support.  This appears to be the best I can do for
now.  The one 2100 card I have doesn't work at all with isp(4).  I can get
it to see devices on the fabric, but it can't log in to them, and it can't
see loop devices at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.17 2014/02/05 07:58:05 kettenis Exp $ */
d42 3
a44 3
#include <dev/microcode/isp/asm_2100.h>
#include <dev/microcode/isp/asm_2200.h>
#include <dev/microcode/isp/asm_2300.h>
@


1.17
log
@Avoid calling delay(9) between checking and clearing the interrupt status bits.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.16 2014/02/05 07:56:10 kettenis Exp $ */
d42 1
d104 3
d268 2
a269 2
		printf("not supported yet\n");
		return (ENXIO);
d311 4
a314 1
		panic("not yet");
d1096 1
d1201 14
a1214 1
	return (qla_read(sc, qla_queue_reg(sc, queue)));
d1766 12
d1792 2
a1793 1
qla_load_firmware_2200(struct qla_softc *sc)
a1794 1
	const u_int16_t *src = isp_2200_risc_code;
d1799 1
a1799 1
		sc->sc_mbox[1] = i + QLA_2200_CODE_ORG;
d1808 1
a1808 1
	sc->sc_mbox[1] = QLA_2200_CODE_ORG;
d1811 1
a1811 1
		    QLA_2200_CODE_ORG, sc->sc_mbox[1]);
d1816 14
@


1.16
log
@Punt on handling responses if we haven't allocated the response queue yet.
Otherwise a spurious interrupt might make us dereference a null-pointer.
This is especially important for ISP2200 cards with Open Firmware, where the
card is running a full firmware and the response queue "in" pointer is
non-zero when we take over.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.15 2014/02/03 14:16:34 jmatthew Exp $ */
d907 2
a909 1
			delay(1000);
a927 2
		} else {
			delay(1000);
@


1.15
log
@use the same option as isp(4) to build without firmware.
stub out the firmware loading code and don't include the firmware files
when ISP_NOFIRMWARE is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.14 2014/02/02 07:53:33 jmatthew Exp $ */
d728 3
@


1.14
log
@carve up qla_attach() into bits we can use to process loop and fabric changes
later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.13 2014/02/02 06:28:18 jmatthew Exp $ */
d41 1
a41 1
/* firmware */
d44 1
d1740 16
d1857 2
@


1.13
log
@Rearrange interrupt register processing for 2200s.  The mailbox semaphore
seems to be disconnected from the interrupt status register, so we shouldn't
wait until the interrupt status is nonzero to check it.  This makes onboard
FC controllers in Sun systems work better.

tested on a blade1k (by kettenis@@) and a v880.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.12 2014/02/01 09:11:30 kettenis Exp $ */
a54 2
void		qla_handle_intr(struct qla_softc *, u_int16_t, u_int16_t);

d64 2
d69 1
a74 1
int		qla_async(struct qla_softc *, u_int16_t);
d85 17
a110 6
int		qla_add_port(struct qla_softc *, u_int16_t, u_int32_t,
		    u_int32_t);
int		qla_classify_port(struct qla_softc *, u_int32_t, u_int64_t,
		    u_int64_t);
int		qla_get_loop_id(struct qla_softc *sc);

d201 3
d214 2
a215 5
	bus_dmamap_sync(sc->sc_dmat,
	    QLA_DMA_MAP(sc->sc_scratch), 0,
	    sizeof(struct qla_get_port_db),
	    BUS_DMASYNC_POSTREAD);
	pdb = QLA_DMA_KVA(sc->sc_scratch);
a254 1
	int scan_limit, scan;
d288 2
a289 47
	qla_set_ints(sc, 0);

	/* reset */
	qla_write(sc, QLA_CTRL_STATUS, QLA_CTRL_RESET);
	delay(100);
	/* clear data and control dma engines? */

	/* wait for soft reset to clear */
	for (i = 0; i < 1000; i++) {
		if ((qla_read(sc, QLA_CTRL_STATUS) & QLA_CTRL_RESET) == 0)
			break;

		delay(100);
	}

	if (i == 1000) {
		printf("reset didn't clear\n");
		qla_set_ints(sc, 0);
		return (ENXIO);
	}

	/* reset FPM */
	qla_write(sc, QLA_CTRL_STATUS, QLA_CTRL_FPM0_REGS);
	qla_write(sc, QLA_FPM_DIAG, QLA_FPM_RESET);
	qla_write(sc, QLA_FPM_DIAG, 0);	/* isp(4) doesn't do this? */
	qla_write(sc, QLA_CTRL_STATUS, QLA_CTRL_RISC_REGS);

	/* reset risc processor */
	qla_host_cmd(sc, QLA_HOST_CMD_RESET);
	delay(100);
	qla_write(sc, QLA_SEMA, 0);
	qla_host_cmd(sc, QLA_HOST_CMD_MASK_PARITY);	/* from isp(4) */
	qla_host_cmd(sc, QLA_HOST_CMD_RELEASE);

	/* reset queue pointers */
	qla_write_queue_ptr(sc, QLA_REQ_QUEUE_IN, 0);
	qla_write_queue_ptr(sc, QLA_REQ_QUEUE_OUT, 0);
	qla_write_queue_ptr(sc, QLA_RESP_QUEUE_IN, 0);
	qla_write_queue_ptr(sc, QLA_RESP_QUEUE_OUT, 0);

	qla_set_ints(sc, 1);
	/* isp(4) sends QLA_HOST_CMD_BIOS here.. not documented? */

	/* do a basic mailbox operation to check we're alive */
	sc->sc_mbox[0] = QLA_MBOX_NOP;
	if (qla_mbox(sc, 0x0001, 0x0001)) {
		printf("ISP not responding after reset\n");
d473 2
a474 4
	if (sc->sc_loop_up == 0) {
		printf("%s: loop still down, giving up\n", DEVNAME(sc));
		return (0);
	}
d476 6
a481 28
	/* connection topology tells us what to scan */
	sc->sc_mbox[0] = QLA_MBOX_GET_LOOP_ID;
	if (qla_mbox(sc, 0x0001, QLA_MBOX_GET_LOOP_ID_OUT)) {
		printf("%s: unable to get loop id\n", DEVNAME(sc));
		sc->sc_topology = QLA_TOPO_N_PORT_NO_TARGET;
	} else {
		sc->sc_topology = sc->sc_mbox[6];
		sc->sc_loop_id = sc->sc_mbox[1];

		switch (sc->sc_topology) {
		case QLA_TOPO_NL_PORT:
		case QLA_TOPO_N_PORT:
			printf("%s: loop id %d\n", DEVNAME(sc),
			    sc->sc_loop_id);
			break;

		case QLA_TOPO_FL_PORT:
		case QLA_TOPO_F_PORT:
			sc->sc_port_id = sc->sc_mbox[2] |
			    (sc->sc_mbox[3] << 16);
			printf("%s: fabric port id %06x\n", DEVNAME(sc), 
			    sc->sc_port_id);
			break;

		case QLA_TOPO_N_PORT_NO_TARGET:
		default:
			printf("%s: not useful\n", DEVNAME(sc));
			break;
a482 1
	}
d484 22
a505 127
	/* scan loop */
	switch (sc->sc_topology) {
	case QLA_TOPO_NL_PORT:
	case QLA_TOPO_FL_PORT:
		scan_limit = 126;
		break;

	case QLA_TOPO_N_PORT:
		scan_limit = 2;
		break;

	default:
		scan_limit = 0;
		break;
	}

	for (scan = 0; scan < scan_limit; scan++) {
		if (scan == sc->sc_loop_id)
			continue;

		qla_add_port(sc, scan, 0, QLA_LOCATION_LOOP_ID(scan));
	}

	/* scan fabric, if there is one */
	if (sc->sc_fabric && (sc->sc_topology == QLA_TOPO_F_PORT ||
	    sc->sc_topology == QLA_TOPO_FL_PORT)) {
		struct qla_sns_rft_id *rft;
		struct qla_sns_ga_nxt *ga;
		struct qla_sns_ga_nxt_resp *gar;
		struct qla_fc_port *fport;
		u_int32_t lastport, firstport;
		TAILQ_HEAD(, qla_fc_port) found;

		/* get the name server's port db entry */
		sc->sc_mbox[0] = QLA_MBOX_GET_PORT_DB;
		if (sc->sc_2k_logins) {
			sc->sc_mbox[1] = QLA_F_PORT_HANDLE;
		} else {
			sc->sc_mbox[1] = QLA_F_PORT_HANDLE << 8;
		}
		qla_mbox_putaddr(sc->sc_mbox, sc->sc_scratch);
		bus_dmamap_sync(sc->sc_dmat, QLA_DMA_MAP(sc->sc_scratch), 0,
		    sizeof(struct qla_get_port_db), BUS_DMASYNC_PREREAD);
		if (qla_mbox(sc, 0x00cf, 0x0001)) {
			printf("%s: get port db for SNS failed: %x\n",
			    DEVNAME(sc), sc->sc_mbox[0]);
			/* what now? */
		} else {
			struct qla_get_port_db *pdb;
			bus_dmamap_sync(sc->sc_dmat,
			    QLA_DMA_MAP(sc->sc_scratch), 0,
			    sizeof(struct qla_get_port_db),
			    BUS_DMASYNC_POSTREAD);
			pdb = QLA_DMA_KVA(sc->sc_scratch);
			printf("%s: SNS; port id %06x, name %llx\n",
			    DEVNAME(sc), ((letoh16(pdb->port_id[0]) << 16) |
			    letoh16(pdb->port_id[1])) & 0xffffff,
			    betoh64(pdb->port_name));
		}

		/*
		 * register fc4 types with the fabric
		 * some switches do this automatically, but apparently
		 * some don't.
		 */
		rft = QLA_DMA_KVA(sc->sc_scratch);
		memset(rft, 0, sizeof(*rft) + sizeof(struct qla_sns_req_hdr));
		rft->subcmd = htole16(QLA_SNS_RFT_ID);
		rft->max_word = htole16(sizeof(struct qla_sns_req_hdr) / 4);
		rft->port_id = htole32(sc->sc_port_id);
		rft->fc4_types[0] = htole16(1 << QLA_FC4_SCSI);
		if (qla_sns_req(sc, sc->sc_scratch, sizeof(*rft))) {
			printf("%s: RFT_ID failed\n", DEVNAME(sc));
			/* we might be able to continue after this fails */
		}

		TAILQ_INIT(&found);
		lastport = 0;
		firstport = -1;
		i = 0;
		do {
			int result;

			/* get the next port from the fabric nameserver */
			ga = QLA_DMA_KVA(sc->sc_scratch);
			memset(ga, 0, sizeof(*ga) + sizeof(*gar));
			ga->subcmd = htole16(QLA_SNS_GA_NXT);
			ga->max_word = htole16(sizeof(*gar) / 4);
			ga->port_id = htole32(lastport);
			result = qla_sns_req(sc, sc->sc_scratch, sizeof(*ga));
			if (result) {
				printf("%s: GA_NXT %x failed: %x\n",
				    DEVNAME(sc), lastport, result);
				break;
			}

			gar = (struct qla_sns_ga_nxt_resp *)(ga + 1);
			/* if the response is all zeroes, try again */
			if (gar->port_type_id == 0 && gar->port_name == 0 &&
			    gar->node_name == 0) {
				printf("%s: GA_NXT returned junk\n",
				    DEVNAME(sc));
				continue;
			}

			/* are we back at the start? */
			lastport = betoh32(gar->port_type_id) & 0xffffff;
			if (lastport == firstport)
				break;
			if (firstport == -1)
				firstport = lastport;

			/*
			printf("%s: GA_NXT: port type/id: %x, wwpn %llx, wwnn %llx, fct: %x\n", DEVNAME(sc), lastport, betoh64(gar->port_name), betoh64(gar->node_name), gar->fc4_types[0]);
			*/

			/* don't try to log in to ourselves */
			if (lastport == sc->sc_port_id) {
				continue;
			}

			fport = malloc(sizeof(*fport), M_DEVBUF,
			    M_ZERO | M_NOWAIT);
			if (fport == NULL) {
				printf("%s: failed to allocate a port struct\n",
				    DEVNAME(sc));
				break;
a506 44
			fport->port_name = betoh64(gar->port_name);
			fport->node_name = betoh64(gar->node_name);
			fport->location = QLA_LOCATION_PORT_ID(lastport);
			fport->portid = lastport;
			TAILQ_INSERT_TAIL(&found, fport, update);
		} while (1);

		while (!TAILQ_EMPTY(&found)) {
			int loopid;
			int mboxin;

			mtx_enter(&sc->sc_port_mtx);
			loopid = qla_get_loop_id(sc);
			mtx_leave(&sc->sc_port_mtx);

			if (loopid == -1) {
				printf("%s: ran out of loop ids\n",
				    DEVNAME(sc));
				break;
			}
			fport = TAILQ_FIRST(&found);
			TAILQ_REMOVE(&found, fport, update);

			mboxin = 0x000f;
			sc->sc_mbox[0] = QLA_MBOX_FABRIC_PLOGI;
			sc->sc_mbox[2] = (fport->portid >> 16) & 0xff;
			sc->sc_mbox[3] = fport->portid & 0xffff;
			if (sc->sc_2k_logins) {
				sc->sc_mbox[1] = loopid;
				sc->sc_mbox[10] = 0;
				mboxin |= (1 << 10);
			} else {
				sc->sc_mbox[1] = loopid << 8;
			}
			if (qla_mbox(sc, mboxin, 0x00c7)) {
				printf("%s: port %x login failed: %x %x %x %x\n",
				    DEVNAME(sc), fport->portid, sc->sc_mbox[0],
				    sc->sc_mbox[1], sc->sc_mbox[2],
				    sc->sc_mbox[6]);
			} else {
				qla_add_port(sc, loopid, fport->portid,
				    fport->location);
			}
			free(fport, M_DEVBUF);
d508 2
a509 5

		/* firmware implicitly registers for change notification for
		 * events detected by the controller.  we might want full
		 * registration instead.
		 */
d1198 286
@


1.12
log
@On sparc64, use the WWNs from Open Firmware, as the onboard ISP2200 that can
be found on some Sun hardware doesn't have an NVRAM.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.11 2014/01/30 23:58:41 jmatthew Exp $ */
a1298 5
		int_status = qla_read(sc, QLA_INT_STATUS);
		if ((int_status & QLA_INT_REQ) == 0) {
			return (0);
		}

d1306 4
@


1.11
log
@the option bit for controlling fast posting is in icb_fw_options, not
icb_xfwoptions.  one of my qla2200 cards seems to have this enabled
in its nvram, so it wasn't getting io completions.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.10 2014/01/30 23:43:53 jmatthew Exp $ */
d328 1
a328 1
	if (qla_read_nvram(sc) == 0)
d330 8
d417 3
a426 1
		icb->icb_portname = sc->sc_nvram.port_name;
a429 1
		icb->icb_nodename = sc->sc_nvram.node_name;
a438 4
		/* port name is big-endian in the icb */
		icb->icb_portname = htobe64(QLA_DEFAULT_PORT_NAME);
		icb->icb_nodename = 0;

d731 2
a732 7
	if (sc->sc_nvram_valid) {
		sc->sc_link.port_wwn = betoh64(sc->sc_nvram.port_name);
		sc->sc_link.node_wwn = betoh64(sc->sc_nvram.node_name);
	} else {
		sc->sc_link.port_wwn = QLA_DEFAULT_PORT_NAME;
		sc->sc_link.node_wwn = 0;
	}
@


1.10
log
@don't do a register test mailbox command before resetting the chip.
kettenis@@ found that this causes problems on sparc64 machines that boot off
isp2200s.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.9 2014/01/30 19:39:23 kettenis Exp $ */
d456 1
a456 1
	icb->icb_xfwoptions &= htole16(~QLA_ICB_FW_FAST_POST);
@


1.9
log
@Set port and node WWN in scsi_link structure when we successfully probe a
target.

ok jmatthew@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.8 2014/01/22 21:42:18 jmatthew Exp $ */
a274 14
	}

	sc->sc_mbox[0] = QLA_MBOX_REGISTER_TEST;
	sc->sc_mbox[1] = 0x1234;
	sc->sc_mbox[2] = 0x4321;
	sc->sc_mbox[3] = 0xaaa5;
	sc->sc_mbox[4] = 0xbbbb;
	if (qla_mbox(sc, 0x001f, 0x001f)) {
		printf("register test command failed\n");
		return (ENXIO);
	} else if (sc->sc_mbox[1] != 0x1234 || sc->sc_mbox[2] != 0x4321 ||
		    sc->sc_mbox[3] != 0xaaa5 || sc->sc_mbox[4] != 0xbbbb) {
		printf("register test command failed\n");
		return (ENXIO);
@


1.8
log
@fix endianness for FC4 type registration
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.7 2014/01/21 06:10:14 jsg Exp $ */
d1018 4
@


1.7
log
@add a missing printf argument
ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.6 2014/01/21 02:40:02 jmatthew Exp $ */
d623 1
a623 1
		rft->fc4_types[0] = (1 << QLA_FC4_SCSI);
@


1.6
log
@Add support for ISP2200 based adapters.

This involves a bit of a hack in the interrupt processing path, where we
ignore the interrupt status if we're expecting a mailbox command to complete,
but we don't have the mailbox semaphore and the response ring hasn't moved.
Typically next time through, the interrupt status is the same and we have the
semaphore so we can read the results.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.5 2014/01/21 02:14:14 jmatthew Exp $ */
d1495 1
a1495 1
		    id >> 8, id & 0xff, exp);
@


1.5
log
@The semaphore register does need to be cleared when clearing interrupts,
but only for interrupts that return information through mailbox registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.4 2014/01/21 02:03:33 jmatthew Exp $ */
d42 1
d85 1
a252 1
	case QLA_GEN_ISP2200:
d256 4
d344 20
a363 3
	if (qla_load_firmware_2300(sc)) {
		printf("firmware load failed\n");
		return (ENXIO);
d368 9
a376 1
	sc->sc_mbox[1] = QLA_2300_CODE_ORG;
d936 13
a976 1
			sc->sc_mbox_pending = 0;
d1201 1
a1228 1
		sc->sc_mbox_pending = 1;
d1256 1
d1304 1
d1307 34
a1340 3
	if ((qla_read(sc, QLA_INT_STATUS) & QLA_INT_REQ) == 0) {
		return (0);
	}
d1342 3
a1344 3
	v = bus_space_read_4(sc->sc_iot, sc->sc_ioh, QLA_RISC_STATUS_LOW);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, QLA_RISC_STATUS_LOW, 4,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
d1346 3
a1348 7
	switch (v & QLA_INT_STATUS_MASK) {
	case QLA_23XX_INT_ROM_MBOX:
	case QLA_23XX_INT_ROM_MBOX_FAIL:
	case QLA_23XX_INT_MBOX:
	case QLA_23XX_INT_MBOX_FAIL:
		*isr = QLA_INT_TYPE_MBOX;
		break;
d1350 4
a1353 3
	case QLA_23XX_INT_ASYNC:
		*isr = QLA_INT_TYPE_ASYNC;
		break;
d1355 2
a1356 3
	case QLA_23XX_INT_RSPQ:
		*isr = QLA_INT_TYPE_IO;
		break;
d1359 1
a1359 2
		*isr = QLA_INT_TYPE_OTHER;
		break;
a1360 3

	*info = (v >> QLA_INT_INFO_SHIFT);
	return (1);
d1380 25
a1404 11
	switch (queue) {
	case QLA_REQ_QUEUE_IN:
		return (QLA_REQ_IN);
	case QLA_REQ_QUEUE_OUT:
		return (QLA_REQ_OUT);
	case QLA_RESP_QUEUE_IN:
		return (QLA_RESP_IN);
	case QLA_RESP_QUEUE_OUT:
		return (QLA_RESP_OUT);
	default:
		panic("unknown queue");
d1406 2
d1677 29
a1705 1
qla_load_fwchunk_2300(struct qla_softc *sc, struct qla_dmamem *mem, const u_int16_t *src, u_int32_t dest)
@


1.4
log
@Stop using 23xx-specific interrupt status codes everywhere.  Instead, classify
into one of 4 types in qla_read_isr.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.3 2014/01/20 21:20:46 jmatthew Exp $ */
d67 1
a67 1
void		qla_clear_isr(struct qla_softc *);
d947 1
a947 1
	qla_clear_isr(sc);
d1107 1
a1107 1
		qla_clear_isr(sc);
d1213 1
a1213 1
	qla_clear_isr(sc);
d1297 1
a1297 1
qla_clear_isr(struct qla_softc *sc)
d1300 8
a1307 1
	qla_write(sc, QLA_SEMA, 0);	/* necessary? */
@


1.3
log
@With 2K login firmware, the login option bits are in mbox register 10.
These need to be explicitly set to 0, otherwise the firmware might not do
the process login and so leave us unable to talk to the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.2 2014/01/19 10:30:13 jmatthew Exp $ */
d896 1
a896 1
	case QLA_INT_ASYNC:
d900 1
a900 1
	case QLA_INT_RSPQ:
d925 1
a925 4
	case QLA_INT_MBOX:
	case QLA_INT_ROM_MBOX:
	case QLA_INT_MBOX_FAIL:
	case QLA_INT_ROM_MBOX_FAIL:
d1088 1
a1088 1
		if (isr != QLA_INT_RSPQ) {
d1176 1
a1176 4
			case QLA_INT_MBOX:
			case QLA_INT_ROM_MBOX:
			case QLA_INT_MBOX_FAIL:
			case QLA_INT_ROM_MBOX_FAIL:
d1271 20
a1290 3
	*isr = (v & QLA_INT_STATUS_MASK);
	if (*isr == 0)
		return (0);
@


1.2
log
@Better interrupt handler return values.  1 if the chip said it wanted an
interrupt, 0 if it didn't.

"makes sense" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qla.c,v 1.1 2014/01/19 06:04:03 jmatthew Exp $ */
d660 1
d674 1
d681 1
d685 1
a685 1
			if (qla_mbox(sc, 0x000f, 0x00c7)) {
@


1.1
log
@Introduce qla(4), a new driver for Qlogic fibre channel HBAs (only ISP23xx
so far).  Works reasonably well now, so it's going in the tree so others can
try it out.

with some help and fixes from dlg@@, general encouragement from basically
everyone
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d54 1
a54 1
int		qla_handle_intr(struct qla_softc *, u_int16_t, u_int16_t);
d885 1
a885 1
int
d888 1
a888 1
	int rv, i;
d894 1
a894 1
		rv = qla_async(sc, info);
a919 1
		rv = 1;
a939 5
		rv = 1;
		break;

	case 0:
		rv = 0;
d944 1
a944 1
		rv = 1;
a947 1
	return (rv);
d960 2
a961 1
	return (qla_handle_intr(sc, isr, info));
@

