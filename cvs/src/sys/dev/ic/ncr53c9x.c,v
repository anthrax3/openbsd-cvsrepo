head	1.64;
access;
symbols
	OPENBSD_6_2_BASE:1.64
	OPENBSD_6_1:1.63.0.4
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.61.0.6
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.61.0.2
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.57.0.4
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.52.0.8
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.52.0.6
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.52.0.2
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.4
	OPENBSD_5_0:1.50.0.4
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.40.0.6
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.17
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.10
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.8
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.64
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	uRv5pa9QDlZaYgwD;

1.63
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.62;
commitid	RlO92XR575sygHqm;

1.62
date	2016.08.23.03.28.01;	author guenther;	state Exp;
branches;
next	1.61;
commitid	sVHD5kblxhZITIq0;

1.61
date	2015.11.08.22.27.10;	author miod;	state Exp;
branches;
next	1.60;
commitid	5naa4AXYNsKnudf9;

1.60
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.59;
commitid	p4LJxGKbi0BU2cG6;

1.59
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.58;
commitid	uzzBR7hz9ncd4O6G;

1.58
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.57;
commitid	I19imNlAX05zJOED;

1.57
date	2014.01.26.17.26.55;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2014.01.18.23.09.04;	author dlg;	state Exp;
branches;
next	1.55;

1.55
date	2014.01.18.23.07.28;	author dlg;	state Exp;
branches;
next	1.54;

1.54
date	2014.01.18.22.56.11;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2014.01.18.22.33.59;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2011.11.08.18.18.41;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2011.08.29.17.25.28;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2010.11.11.17.47.00;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2010.09.28.01.50.08;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2010.01.13.06.09.44;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.06.17.24.28;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.01.23.06.03;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.31.17.21.57;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2008.05.27.09.43.26;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.05.22.30.25;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.15.01.37.49;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2007.08.06.08.28.09;	author tom;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.26.22.16.23;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.23.20.35.12;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.09.23.11.49;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.09.23.09.41;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.04.22.22.09;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.04.20.49.32;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.28.08.11.09;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.29.19.17.43;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.21.23.50.35;	author tholo;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.15.17.51.42;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.25.03.35.13;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.05.12.27.02;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.25.17.44.52;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.09.23.43.11;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.04.22.08.06;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.19.04.40.54;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.23.00.39.47;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.17.23.13.41;	author nordin;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.09.27.04.01.42;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.21.11.20.35;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.17.18.03.11;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.12.06.10.45;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	98.05.28.22.07.52;	author jason;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	98.04.30.01.43.46;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	98.02.10.05.03.30;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	98.02.03.22.02.46;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	97.08.08.08.13.05;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.02.27.13.57.21;	author briggs;	state Exp;
branches;
next	;

1.6.8.1
date	2001.05.14.22.24.01;	author niklas;	state Exp;
branches;
next	1.6.8.2;

1.6.8.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.6.8.3;

1.6.8.3
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.6.8.4;

1.6.8.4
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.6.8.5;

1.6.8.5
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	1.6.8.6;

1.6.8.6
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.6.8.7;

1.6.8.7
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2003.05.19.21.54.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.64
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: ncr53c9x.c,v 1.63 2016/09/15 02:00:17 dlg Exp $	*/
/*     $NetBSD: ncr53c9x.c,v 1.56 2000/11/30 14:41:46 thorpej Exp $    */

/*
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 Peter Galbavy
 * Copyright (c) 1995 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Based on aic6360 by Jarle Greipsland
 *
 * Acknowledgements: Many of the algorithms used in this driver are
 * inspired by the work of Julian Elischer (julian@@tfs.com) and
 * Charles Hannum (mycroft@@duality.gnu.ai.mit.edu).  Thanks a million!
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/pool.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <machine/cpu.h>

#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>

#ifdef NCR53C9X_DEBUG
int ncr53c9x_debug = 0; /*NCR_SHOWPHASE|NCR_SHOWMISC|NCR_SHOWTRAC|NCR_SHOWCMDS;*/
#endif
#ifdef DEBUG
int ncr53c9x_notag = 0;
#endif

/*static*/ void	ncr53c9x_readregs(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_select(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
/*static*/ int ncr53c9x_reselect(struct ncr53c9x_softc *, int, int, int);
/*static*/ void	ncr53c9x_scsi_reset(struct ncr53c9x_softc *);
/*static*/ int	ncr53c9x_poll(struct ncr53c9x_softc *,
					    struct scsi_xfer *, int);
/*static*/ void	ncr53c9x_sched(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_done(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
/*static*/ void	ncr53c9x_msgin(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_msgout(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_timeout(void *arg);
/*static*/ void	ncr53c9x_abort(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
/*static*/ void ncr53c9x_dequeue(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);

void ncr53c9x_sense(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
void ncr53c9x_free_ecb(void *, void *);
void *ncr53c9x_get_ecb(void *);

static inline int ncr53c9x_stp2cpb(struct ncr53c9x_softc *, int);
static inline void ncr53c9x_setsync(struct ncr53c9x_softc *,
					    struct ncr53c9x_tinfo *);
static struct ncr53c9x_linfo *ncr53c9x_lunsearch(struct ncr53c9x_tinfo *,
    int64_t lun);

static void ncr53c9x_wrfifo(struct ncr53c9x_softc *, u_char *, int);
static int ncr53c9x_rdfifo(struct ncr53c9x_softc *, int);
#define NCR_RDFIFO_START	0
#define NCR_RDFIFO_CONTINUE	1

#define NCR_SET_COUNT(sc, size) do {						\
			NCR_WRITE_REG((sc), NCR_TCL, (size));			\
			NCR_WRITE_REG((sc), NCR_TCM, (size) >> 8);		\
			if ((sc->sc_cfg2 & NCRCFG2_FE) ||			\
			    (sc->sc_rev == NCR_VARIANT_FAS366)) {		\
				NCR_WRITE_REG((sc), NCR_TCH, (size) >> 16);	\
			}							\
			if (sc->sc_rev == NCR_VARIANT_FAS366) {			\
				NCR_WRITE_REG(sc, NCR_RCH, 0);			\
			}							\
} while (0)

static int ecb_pool_initialized = 0;
static struct scsi_iopool ecb_iopool;
static struct pool ecb_pool;

struct cfdriver esp_cd = {
	NULL, "esp", DV_DULL
};

void	ncr53c9x_scsi_cmd(struct scsi_xfer *);
int	ncr53c9x_scsi_probe(struct scsi_link *);
void	ncr53c9x_scsi_free(struct scsi_link *);

struct scsi_adapter ncr53c9x_adapter = {
	ncr53c9x_scsi_cmd,	/* cmd */
	scsi_minphys,		/* minphys */
	ncr53c9x_scsi_probe,	/* lun probe */
	ncr53c9x_scsi_free,	/* lun free */
	NULL			/* ioctl */
};

/*
 * Names for the NCR53c9x variants, corresponding to the variant tags
 * in ncr53c9xvar.h.
 */
const char *ncr53c9x_variant_names[] = {
	"ESP100",
	"ESP100A",
	"ESP200",
	"NCR53C94",
	"NCR53C96",
	"ESP406",
	"FAS408",
	"FAS216",
	"AM53C974",
	"FAS366/HME",
};

/*
 * Search linked list for LUN info by LUN id.
 */
static struct ncr53c9x_linfo *
ncr53c9x_lunsearch(ti, lun)
	struct ncr53c9x_tinfo *ti;
	int64_t lun;
{
	struct ncr53c9x_linfo *li;
	LIST_FOREACH(li, &ti->luns, link)
	    if (li->lun == lun)
		    return (li);
	return (NULL);
}

/*
 * Attach this instance, and then all the sub-devices
 */
void
ncr53c9x_attach(sc)
	struct ncr53c9x_softc *sc;
{
	struct scsibus_attach_args saa;

	/*
	 * Allocate SCSI message buffers.
	 * Front-ends can override allocation to avoid alignment
	 * handling in the DMA engines. Note that ncr53c9x_msgout()
	 * can request a 1 byte DMA transfer.
	 */
	if (sc->sc_omess == NULL)
		sc->sc_omess = malloc(NCR_MAX_MSG_LEN, M_DEVBUF, M_NOWAIT);

	if (sc->sc_imess == NULL)
		sc->sc_imess = malloc(NCR_MAX_MSG_LEN+1, M_DEVBUF, M_NOWAIT);

	if (sc->sc_omess == NULL || sc->sc_imess == NULL) {
		printf("out of memory\n");
		return;
	}

	/*
	 * Note, the front-end has set us up to print the chip variation.
	 */
	if (sc->sc_rev >= NCR_VARIANT_MAX) {
		printf("\n%s: unknown variant %d, devices not attached\n",
		    sc->sc_dev.dv_xname, sc->sc_rev);
		return;
	}

	printf(": %s, %dMHz\n", ncr53c9x_variant_names[sc->sc_rev],
	    sc->sc_freq);

	sc->sc_ccf = FREQTOCCF(sc->sc_freq);

	/* The value *must not* be == 1. Make it 2 */
	if (sc->sc_ccf == 1)
		sc->sc_ccf = 2;

	/*
	 * The recommended timeout is 250ms. This register is loaded
	 * with a value calculated as follows, from the docs:
	 *
	 *		(timout period) x (CLK frequency)
	 *	reg = -------------------------------------
	 *		 8192 x (Clock Conversion Factor)
	 *
	 * Since CCF has a linear relation to CLK, this generally computes
	 * to the constant of 153.
	 */
	sc->sc_timeout = ((250 * 1000) * sc->sc_freq) / (8192 * sc->sc_ccf);

	/* CCF register only has 3 bits; 0 is actually 8 */
	sc->sc_ccf &= 7;

	/* Find how many targets we need to support */
	switch (sc->sc_rev) {
	case NCR_VARIANT_FAS366:
		sc->sc_ntarg = 16;
		break;
	default:
		sc->sc_ntarg = 8;
		break;
	}

	/* Reset state & bus */
	sc->sc_cfflags = sc->sc_dev.dv_cfdata->cf_flags;
	sc->sc_state = 0;
	ncr53c9x_init(sc, 1);

	/*
	 * fill in the prototype scsi_link.
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->sc_id;
	sc->sc_link.adapter = &ncr53c9x_adapter;
	sc->sc_link.openings = 2;
	sc->sc_link.adapter_buswidth = sc->sc_ntarg;
	sc->sc_link.pool = &ecb_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	/*
	 * Now try to attach all the sub-devices
	 */
	config_found(&sc->sc_dev, &saa, scsiprint);
}

/*
 * This is the generic ncr53c9x reset function. It does not reset the SCSI bus,
 * only this controller, but kills any on-going commands, and also stops
 * and resets the DMA.
 *
 * After reset, registers are loaded with the defaults from the attach
 * routine above.
 */
void
ncr53c9x_reset(sc)
	struct ncr53c9x_softc *sc;
{

	/* reset DMA first */
	NCRDMA_RESET(sc);

	/* reset SCSI chip */
	NCRCMD(sc, NCRCMD_RSTCHIP);
	NCRCMD(sc, NCRCMD_NOP);
	DELAY(500);

	/* do these backwards, and fall through */
	switch (sc->sc_rev) {
	case NCR_VARIANT_ESP406:
	case NCR_VARIANT_FAS408:
		NCR_WRITE_REG(sc, NCR_CFG5, sc->sc_cfg5 | NCRCFG5_SINT);
		NCR_WRITE_REG(sc, NCR_CFG4, sc->sc_cfg4);
	case NCR_VARIANT_AM53C974:
	case NCR_VARIANT_FAS216:
	case NCR_VARIANT_NCR53C94:
	case NCR_VARIANT_NCR53C96:
	case NCR_VARIANT_ESP200:
		sc->sc_features |= NCR_F_HASCFG3;
		NCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);
	case NCR_VARIANT_ESP100A:
		sc->sc_features |= NCR_F_SELATN3;
		NCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);
	case NCR_VARIANT_ESP100:
		NCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);
		NCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);
		NCR_WRITE_REG(sc, NCR_SYNCOFF, 0);
		NCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);
		break;
	case NCR_VARIANT_FAS366:
		sc->sc_features |=
		    NCR_F_SELATN3 | NCR_F_HASCFG3 | NCR_F_FASTSCSI;
		sc->sc_cfg3 = NCRFASCFG3_FASTCLK | NCRFASCFG3_OBAUTO;
		sc->sc_cfg3_fscsi = NCRFASCFG3_FASTSCSI;
		NCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);
		sc->sc_cfg2 = 0; /* NCRCFG2_HMEFE | NCRCFG2_HME32 */
		NCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);
		NCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);
		NCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);
		NCR_WRITE_REG(sc, NCR_SYNCOFF, 0);
		NCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);
		break;
	default:
		printf("%s: unknown revision code, assuming ESP100\n",
		    sc->sc_dev.dv_xname);
		NCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);
		NCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);
		NCR_WRITE_REG(sc, NCR_SYNCOFF, 0);
		NCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);
	}

	if (sc->sc_rev == NCR_VARIANT_AM53C974)
		NCR_WRITE_REG(sc, NCR_AMDCFG4, sc->sc_cfg4);

#if 0
	printf("%s: ncr53c9x_reset: revision %d\n",
	    sc->sc_dev.dv_xname, sc->sc_rev);
	printf("%s: ncr53c9x_reset: cfg1 0x%x, cfg2 0x%x, cfg3 0x%x, ccf 0x%x, timeout 0x%x\n",
	    sc->sc_dev.dv_xname,
	    sc->sc_cfg1, sc->sc_cfg2, sc->sc_cfg3,
	    sc->sc_ccf, sc->sc_timeout);
#endif
}

/*
 * Reset the SCSI bus, but not the chip
 */
void
ncr53c9x_scsi_reset(sc)
	struct ncr53c9x_softc *sc;
{

	(*sc->sc_glue->gl_dma_stop)(sc);

	printf("%s: resetting SCSI bus\n", sc->sc_dev.dv_xname);
	NCRCMD(sc, NCRCMD_RSTSCSI);
}

/*
 * Initialize ncr53c9x state machine
 */
void
ncr53c9x_init(sc, doreset)
	struct ncr53c9x_softc *sc;
	int doreset;
{
	struct ncr53c9x_ecb *ecb;
	struct ncr53c9x_linfo *li;
	int r, i;

	NCR_TRACE(("[NCR_INIT(%d) %d] ", doreset, sc->sc_state));

	if (!ecb_pool_initialized) {
		/* All instances share this pool */
		pool_init(&ecb_pool, sizeof(struct ncr53c9x_ecb), 0, IPL_BIO,
		    0, "ncr53c9x_ecb", NULL);
		scsi_iopool_init(&ecb_iopool, NULL,
		    ncr53c9x_get_ecb, ncr53c9x_free_ecb);
		ecb_pool_initialized = 1;
	}

	if (sc->sc_state == 0) {
		/* First time through; initialize. */

		TAILQ_INIT(&sc->ready_list);
		sc->sc_nexus = NULL;
		bzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));
		for (r = 0; r < sc->sc_ntarg; r++) {
			LIST_INIT(&sc->sc_tinfo[r].luns);
		}
	} else {
		/* Cancel any active commands. */
		sc->sc_state = NCR_CLEANING;
		sc->sc_msgify = 0;
		if ((ecb = sc->sc_nexus) != NULL) {
			ecb->xs->error = XS_TIMEOUT;
			ncr53c9x_done(sc, ecb);
		}
		for (r = 0; r < sc->sc_ntarg; r++) {
			LIST_FOREACH(li, &sc->sc_tinfo[r].luns, link) {
				if ((ecb = li->untagged)) {
					li->untagged = NULL;
					/*
					 * XXXXXXX
					 * Should we terminate a command
					 * that never reached the disk?
					 */
					li->busy = 0;
					ecb->xs->error = XS_TIMEOUT;
					ncr53c9x_done(sc, ecb);
				}
				for (i = 0; i < 256; i++)
					if ((ecb = li->queued[i])) {
						li->queued[i] = NULL;
						ecb->xs->error = XS_TIMEOUT;
						ncr53c9x_done(sc, ecb);
					}
				li->used = 0;
			}
		}
	}

	/*
	 * reset the chip to a known state
	 */
	ncr53c9x_reset(sc);

	sc->sc_phase = sc->sc_prevphase = INVALID_PHASE;
	for (r = 0; r < sc->sc_ntarg; r++) {
		struct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];
/* XXX - config flags per target: low bits: no reselect; high bits: no synch */

                ti->flags = ((!(sc->sc_cfflags & (1 << (r + 16))) &&
		    sc->sc_minsync) ? 0 : T_SYNCHOFF) |
		    ((sc->sc_cfflags & (1 << r)) ?  T_RSELECTOFF : 0) |
		    T_NEED_TO_RESET;
#ifdef DEBUG
		 if (ncr53c9x_notag)
			 ti->flags &= ~T_TAG;
#endif 
		ti->period = sc->sc_minsync;
		ti->offset = 0;
		ti->cfg3 = 0;
	}

	if (doreset) {
		sc->sc_state = NCR_SBR;
		NCRCMD(sc, NCRCMD_RSTSCSI);
		/*
		 * XXX gross...
		 * On some systems, commands issued too close to a reset
		 * do not work correctly. We'll force a short delay on
		 * known-to-be-sensitive chips.
		 */
		switch (sc->sc_rev) {
		case NCR_VARIANT_NCR53C94:
			DELAY(600000);	/* 600ms */
			break;
		case NCR_VARIANT_NCR53C96:
			DELAY(100000);	/* 100ms */
			break;
		}
	} else {
		sc->sc_state = NCR_IDLE;
		ncr53c9x_sched(sc);
	}
}

/*
 * Read the NCR registers, and save their contents for later use.
 * NCR_STAT, NCR_STEP & NCR_INTR are mostly zeroed out when reading
 * NCR_INTR - so make sure it is the last read.
 *
 * I think that (from reading the docs) most bits in these registers
 * only make sense when he DMA CSR has an interrupt showing. Call only
 * if an interrupt is pending.
 */
__inline__ void
ncr53c9x_readregs(sc)
	struct ncr53c9x_softc *sc;
{

	sc->sc_espstat = NCR_READ_REG(sc, NCR_STAT);
	/* Only the stepo bits are of interest */
	sc->sc_espstep = NCR_READ_REG(sc, NCR_STEP) & NCRSTEP_MASK;

	if (sc->sc_rev == NCR_VARIANT_FAS366)
		sc->sc_espstat2 = NCR_READ_REG(sc, NCR_STAT2);

	sc->sc_espintr = NCR_READ_REG(sc, NCR_INTR);

	if (sc->sc_glue->gl_clear_latched_intr != NULL)
		(*sc->sc_glue->gl_clear_latched_intr)(sc);

	/*
	 * Determine the SCSI bus phase, return either a real SCSI bus phase
	 * or some pseudo phase we use to detect certain exceptions.
	 */

	sc->sc_phase = (sc->sc_espintr & NCRINTR_DIS)
			? /* Disconnected */ BUSFREE_PHASE
			: sc->sc_espstat & NCRSTAT_PHASE;

	NCR_MISC(("regs[intr=%02x,stat=%02x,step=%02x,stat2=%02x] ",
		sc->sc_espintr, sc->sc_espstat, sc->sc_espstep, sc->sc_espstat2));
}

/*
 * Convert Synchronous Transfer Period to chip register Clock Per Byte value.
 */
static inline int
ncr53c9x_stp2cpb(sc, period)
	struct ncr53c9x_softc *sc;
	int period;
{
	int v;
	v = (sc->sc_freq * period) / 250;
	if (ncr53c9x_cpb2stp(sc, v) < period)
		/* Correct round-down error */
		v++;
	return (v);
}

static inline void
ncr53c9x_setsync(sc, ti)
	struct ncr53c9x_softc *sc;
	struct ncr53c9x_tinfo *ti;
{
	u_char syncoff, synctp;
	u_char cfg3 = sc->sc_cfg3 | ti->cfg3;

	if (ti->flags & T_SYNCMODE) {
		syncoff = ti->offset;
		synctp = ncr53c9x_stp2cpb(sc, ti->period);
		if (sc->sc_features & NCR_F_FASTSCSI) {
			/*
			 * If the period is 200ns or less (ti->period <= 50),
			 * put the chip in Fast SCSI mode.
			 */
			if (ti->period <= 50)
				/*
				 * There are (at least) 4 variations of the
				 * configuration 3 register.  The drive attach
				 * routine sets the appropriate bit to put the
				 * chip into Fast SCSI mode so that it doesn't
				 * have to be figured out here each time.
				 */
				cfg3 |= (sc->sc_rev == NCR_VARIANT_AM53C974) ?
				    NCRAMDCFG3_FSCSI : NCRCFG3_FSCSI;
		}

		/*
		 * Am53c974 requires different SYNCTP values when the
		 * FSCSI bit is off.
		 */
		if (sc->sc_rev == NCR_VARIANT_AM53C974 &&
		    (cfg3 & NCRAMDCFG3_FSCSI) == 0)
			synctp--;
	} else {
		syncoff = 0;
		synctp = 0;
	}

	if (sc->sc_features & NCR_F_HASCFG3)
		NCR_WRITE_REG(sc, NCR_CFG3, cfg3);

	NCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);
	NCR_WRITE_REG(sc, NCR_SYNCTP, synctp);
}

/*
 * Send a command to a target, set the driver state to NCR_SELECTING
 * and let the caller take care of the rest.
 *
 * Keeping this as a function allows me to say that this may be done
 * by DMA instead of programmed I/O soon.
 */
void
ncr53c9x_select(sc, ecb)
	struct ncr53c9x_softc *sc;
	struct ncr53c9x_ecb *ecb;
{
	struct scsi_link *sc_link = ecb->xs->sc_link;
	int target = sc_link->target;
	int lun = sc_link->lun;
	struct ncr53c9x_tinfo *ti = &sc->sc_tinfo[target];
	int tiflags = ti->flags;
	u_char *cmd;
	int clen;
	int selatn3, selatns;
	size_t dmasize;

	NCR_TRACE(("[ncr53c9x_select(t%d,l%d,cmd:%x,tag%x,%x)] ",
		   target, lun, ecb->cmd.cmd.opcode, ecb->tag[0], ecb->tag[1]));

	sc->sc_state = NCR_SELECTING;
	/*
	 * Schedule the timeout now, the first time we will go away
	 * expecting to come back due to an interrupt, because it is
	 * always possible that the interrupt may never happen.
	 */
	if ((ecb->xs->flags & SCSI_POLL) == 0) {
		int timeout = ecb->timeout;

		if (timeout > 1000000)
			timeout = (timeout / 1000) * hz;
		else
			timeout = (timeout * hz) / 1000;
		timeout_add(&ecb->to, timeout);
	}

	/*
	 * The docs say the target register is never reset, and I
	 * can't think of a better place to set it
	 */
	if (sc->sc_rev == NCR_VARIANT_FAS366) {
		NCRCMD(sc, NCRCMD_FLUSH);
		NCR_WRITE_REG(sc, NCR_SELID, target | NCR_BUSID_HME);
	} else {
		NCR_WRITE_REG(sc, NCR_SELID, target);
	}
	ncr53c9x_setsync(sc, ti);

	if ((ecb->flags & ECB_SENSE) != 0) {
		/*
		 * For REQUEST SENSE, we should not send an IDENTIFY or
		 * otherwise mangle the target.  There should be no MESSAGE IN
		 * phase.
		 */
		if (sc->sc_features & NCR_F_DMASELECT) {
			/* setup DMA transfer for command */
			dmasize = clen = ecb->clen;
			sc->sc_cmdlen = clen;
			sc->sc_cmdp = (caddr_t)&ecb->cmd.cmd;

			NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0,
			    &dmasize);
			/* Program the SCSI counter */
			NCR_SET_COUNT(sc, dmasize);

			if (sc->sc_rev != NCR_VARIANT_FAS366)
				NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);

			/* And get the targets attention */
			NCRCMD(sc, NCRCMD_SELNATN | NCRCMD_DMA);
			NCRDMA_GO(sc);
		} else {
			ncr53c9x_wrfifo(sc, (u_char *)&ecb->cmd.cmd, ecb->clen);
			sc->sc_cmdlen = 0;
			NCRCMD(sc, NCRCMD_SELNATN);
		}
		return;
	}

	selatn3 = selatns = 0;
	if (ecb->tag[0] != 0) {
		if (sc->sc_features & NCR_F_SELATN3)
			/* use SELATN3 to send tag messages */
			selatn3 = 1;
		else
			/* We don't have SELATN3; use SELATNS to send tags */
			selatns = 1;
	}

	if (ti->flags & T_NEGOTIATE) {
		/* We have to use SELATNS to send sync/wide messages */
		selatn3 = 0;
		selatns = 1;
	}

	cmd = (u_char *)&ecb->cmd.cmd;

	if (selatn3) {
		/* We'll use tags with SELATN3 */
		clen = ecb->clen + 3;
		cmd -= 3;
		cmd[0] = MSG_IDENTIFY(lun, 1);	/* msg[0] */
		cmd[1] = ecb->tag[0];		/* msg[1] */
		cmd[2] = ecb->tag[1];		/* msg[2] */
	} else {
		/* We don't have tags, or will send messages with SELATNS */
		clen = ecb->clen + 1;
		cmd -= 1;
		cmd[0] = MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF) == 0);
	}

	if ((sc->sc_features & NCR_F_DMASELECT) && !selatns) {

		/* setup DMA transfer for command */
		dmasize = clen;
		sc->sc_cmdlen = clen;
		sc->sc_cmdp = cmd;

		NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);
		/* Program the SCSI counter */
		NCR_SET_COUNT(sc, dmasize);

		/* load the count in */
		/* if (sc->sc_rev != NCR_VARIANT_FAS366) */
			NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);

		/* And get the targets attention */
		if (selatn3) {
			sc->sc_msgout = SEND_TAG;
			sc->sc_flags |= NCR_ATN;
			NCRCMD(sc, NCRCMD_SELATN3 | NCRCMD_DMA);
		} else
			NCRCMD(sc, NCRCMD_SELATN | NCRCMD_DMA);
		NCRDMA_GO(sc);
		return;
	}

	/*
	 * Who am I. This is where we tell the target that we are
	 * happy for it to disconnect etc.
	 */

	/* Now get the command into the FIFO */
	sc->sc_cmdlen = 0;
	ncr53c9x_wrfifo(sc, cmd, clen);

	/* And get the targets attention */
	if (selatns) {
		NCR_MISC(("SELATNS \n"));
		/* Arbitrate, select and stop after IDENTIFY message */
		NCRCMD(sc, NCRCMD_SELATNS);
	} else if (selatn3) {
		sc->sc_msgout = SEND_TAG;
		sc->sc_flags |= NCR_ATN;
		NCRCMD(sc, NCRCMD_SELATN3);
	} else
		NCRCMD(sc, NCRCMD_SELATN);
}

/*
 * DRIVER FUNCTIONS CALLABLE FROM HIGHER LEVEL DRIVERS
 */

void *
ncr53c9x_get_ecb(void *null)
{
	struct ncr53c9x_ecb *ecb;

	ecb = pool_get(&ecb_pool, M_NOWAIT|M_ZERO);
	if (ecb == NULL)
		return (NULL);

	timeout_set(&ecb->to, ncr53c9x_timeout, ecb);
	ecb->flags |= ECB_ALLOC;

	return (ecb);
}

void
ncr53c9x_free_ecb(void *null, void *ecb)
{
	pool_put(&ecb_pool, ecb);
}

int
ncr53c9x_scsi_probe(struct scsi_link *sc_link)
{
	struct ncr53c9x_softc *sc = sc_link->adapter_softc;
	struct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];
	struct ncr53c9x_linfo *li;
	int64_t lun = sc_link->lun;
	int s;

	/* Initialize LUN info and add to list. */
	li = malloc(sizeof(*li), M_DEVBUF, M_WAITOK | M_ZERO);
	if (li == NULL)
		return (ENOMEM);

	li->last_used = time_second;
	li->lun = lun;

	s = splbio();
	LIST_INSERT_HEAD(&ti->luns, li, link);
	if (lun < NCR_NLUN)
		ti->lun[lun] = li;
	splx(s);

	return (0);

}

void
ncr53c9x_scsi_free(struct scsi_link *sc_link)
{
	struct ncr53c9x_softc *sc = sc_link->adapter_softc;
	struct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];
	struct ncr53c9x_linfo *li;
	int64_t lun = sc_link->lun;
	int s;

	s = splbio();
	li = TINFO_LUN(ti, lun);

	LIST_REMOVE(li, link);
	if (lun < NCR_NLUN)
		ti->lun[lun] = NULL;
	splx(s);

	free(li, M_DEVBUF, 0);
}

/*
 * Start a SCSI-command
 * This function is called by the higher level SCSI-driver to queue/run
 * SCSI-commands.
 */
void
ncr53c9x_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *sc_link = xs->sc_link;
	struct ncr53c9x_softc *sc = sc_link->adapter_softc;
	struct ncr53c9x_ecb *ecb;
	struct ncr53c9x_tinfo *ti;
	struct ncr53c9x_linfo *li;
	int64_t lun = sc_link->lun;
	int s, flags;

	NCR_TRACE(("[ncr53c9x_scsi_cmd] "));
	NCR_CMDS(("[0x%x, %d]->%d ", (int)xs->cmd->opcode, xs->cmdlen,
	    sc_link->target));

	/*
	 * Commands larger than 12 bytes seem to confuse the chip
	 * (at least on FAS366 flavours).
	 */
	if (xs->cmdlen > 12) {
		memset(&xs->sense, 0, sizeof(xs->sense));
		/* sense data borrowed from gdt(4) */
		xs->sense.error_code = SSD_ERRCODE_VALID | SSD_ERRCODE_CURRENT;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* illcmd */
		xs->error = XS_SENSE;
		scsi_done(xs);
		return;
	}

	flags = xs->flags;
	ti = &sc->sc_tinfo[sc_link->target];
	li = TINFO_LUN(ti, lun);

	/* Initialize ecb */
	ecb = xs->io;
	ecb->xs = xs;
	ecb->timeout = xs->timeout;

	if (flags & SCSI_RESET) {
		ecb->flags |= ECB_RESET;
		ecb->clen = 0;
		ecb->dleft = 0;
	} else {
		bcopy(xs->cmd, &ecb->cmd.cmd, xs->cmdlen);
		ecb->clen = xs->cmdlen;
		ecb->daddr = xs->data;
		ecb->dleft = xs->datalen;
	}
	ecb->stat = 0;

	s = splbio();

	TAILQ_INSERT_TAIL(&sc->ready_list, ecb, chain);
	ecb->flags |= ECB_READY;
	if (sc->sc_state == NCR_IDLE)
		ncr53c9x_sched(sc);

	splx(s);

	if ((flags & SCSI_POLL) == 0)
		return;

	/* Not allowed to use interrupts, use polling instead */
	if (ncr53c9x_poll(sc, xs, ecb->timeout)) {
		ncr53c9x_timeout(ecb);
		if (ncr53c9x_poll(sc, xs, ecb->timeout))
			ncr53c9x_timeout(ecb);
	}
}

/*
 * Used when interrupt driven I/O isn't allowed, e.g. during boot.
 */
int
ncr53c9x_poll(sc, xs, count)
	struct ncr53c9x_softc *sc;
	struct scsi_xfer *xs;
	int count;
{
	int s;

	NCR_TRACE(("[ncr53c9x_poll] "));
	while (count) {
		if (NCRDMA_ISINTR(sc)) {
			s = splbio();
			ncr53c9x_intr(sc);
			splx(s);
		}
#if alternatively
		if (NCR_READ_REG(sc, NCR_STAT) & NCRSTAT_INT) {
			s = splbio();
			ncr53c9x_intr(sc);
			splx(s);
		}
#endif
		if ((xs->flags & ITSDONE) != 0)
			return (0);
		s = splbio();
		if (sc->sc_state == NCR_IDLE) {
			NCR_TRACE(("[ncr53c9x_poll: rescheduling] "));
			ncr53c9x_sched(sc);
		}
		splx(s);
		DELAY(1000);
		count--;
	}
	return (1);
}


/*
 * LOW LEVEL SCSI UTILITIES
 */

/*
 * Schedule a scsi operation.  This has now been pulled out of the interrupt
 * handler so that we may call it from ncr53c9x_scsi_cmd and ncr53c9x_done.
 * This may save us an unnecessary interrupt just to get things going.
 * Should only be called when state == NCR_IDLE and at bio pl.
 */
void
ncr53c9x_sched(sc)
	struct ncr53c9x_softc *sc;
{
	struct ncr53c9x_ecb *ecb;
	struct scsi_link *sc_link;
	struct ncr53c9x_tinfo *ti;
	int lun;
	struct ncr53c9x_linfo *li;
	int s, tag;

	NCR_TRACE(("[ncr53c9x_sched] "));
	if (sc->sc_state != NCR_IDLE)
		panic("ncr53c9x_sched: not IDLE (state=%d)", sc->sc_state);

	/*
	 * Find first ecb in ready queue that is for a target/lunit
	 * combinations that is not busy.
	 */
	TAILQ_FOREACH(ecb, &sc->ready_list, chain) {
		sc_link = ecb->xs->sc_link;
		ti = &sc->sc_tinfo[sc_link->target];
		lun = sc_link->lun;

		/* Select type of tag for this command */
		if ((ti->flags & (T_RSELECTOFF)) != 0)
			tag = 0;
		else if ((ti->flags & T_TAG) == 0)
			tag = 0;
		else if ((ecb->flags & ECB_SENSE) != 0)
			tag = 0;
		else
			tag = MSG_SIMPLE_Q_TAG;
#if 0
		/* XXXX Use tags for polled commands? */
		if (ecb->xs->flags & SCSI_POLL)
			tag = 0;
#endif
		s = splbio();
		li = TINFO_LUN(ti, lun);
		if (!li) {
			/* Initialize LUN info and add to list. */
			if ((li = malloc(sizeof(*li), M_DEVBUF,
			    M_NOWAIT | M_ZERO)) == NULL) {
				splx(s);
				continue;
			}
			li->lun = lun;

			LIST_INSERT_HEAD(&ti->luns, li, link);
			if (lun < NCR_NLUN)
				ti->lun[lun] = li;
		}
		li->last_used = time_second;
		if (!tag) {
			/* Try to issue this as an un-tagged command */
			if (!li->untagged)
				li->untagged = ecb;
		}
		if (li->untagged) {
			tag = 0;
			if ((li->busy != 1) && !li->used) {
				/* We need to issue this untagged command now */
				ecb = li->untagged;
				sc_link = ecb->xs->sc_link;
			}
			else {
				/* Not ready yet */
				splx(s);
				continue;
			}
		}
		ecb->tag[0] = tag;
		if (tag) {
			int i;

			/* Allocate a tag */
			if (li->used == 255) {
				/* no free tags */
				splx(s);
				continue;
			}
			/* Start from the last used location */
			for (i=li->avail; i<256; i++) {
				if (li->queued[i] == NULL)
					break;
			}
			/* Couldn't find one, start again from the beginning */
			if (i == 256) {
				for (i = 0; i<256; i++) {
					if (li->queued[i] == NULL)
						break;
				}
			}
#ifdef DIAGNOSTIC
			if (i == 256)
				panic("ncr53c9x_sched: tag alloc failure");
#endif

			/* Save where to start next time. */
			li->avail = i+1;
			li->used++;

			li->queued[i] = ecb;
			ecb->tag[1] = i;
		}
		splx(s);
		if (li->untagged && (li->busy != 1)) {
			li->busy = 1;
			TAILQ_REMOVE(&sc->ready_list, ecb, chain);
			ecb->flags &= ~ECB_READY;
			sc->sc_nexus = ecb;
			ncr53c9x_select(sc, ecb);
			break;
		}
		if (!li->untagged && tag) {
			TAILQ_REMOVE(&sc->ready_list, ecb, chain);
			ecb->flags &= ~ECB_READY;
			sc->sc_nexus = ecb;
			ncr53c9x_select(sc, ecb);
			break;
		} else
			NCR_MISC(("%d:%d busy\n",
				  sc_link->target,
				  sc_link->lun));
	}
}

void
ncr53c9x_sense(sc, ecb)
	struct ncr53c9x_softc *sc;
	struct ncr53c9x_ecb *ecb;
{
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];
	struct scsi_sense *ss = (void *)&ecb->cmd.cmd;
	struct ncr53c9x_linfo *li;
	int lun = sc_link->lun;

	NCR_MISC(("requesting sense "));
	/* Next, setup a request sense command block */
	bzero(ss, sizeof(*ss));
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = sc_link->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);
	ecb->clen = sizeof(*ss);
	ecb->daddr = (char *)&xs->sense;
	ecb->dleft = sizeof(struct scsi_sense_data);
	ecb->flags |= ECB_SENSE;
	ecb->timeout = NCR_SENSE_TIMEOUT;
	ti->senses++;
	li = TINFO_LUN(ti, lun);
	if (li->busy) li->busy = 0;
	ncr53c9x_dequeue(sc, ecb);
	li->untagged = ecb;
	li->busy = 2;
	if (ecb == sc->sc_nexus) {
		ncr53c9x_select(sc, ecb);
	} else {
		TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
		ecb->flags |= ECB_READY;
		if (sc->sc_state == NCR_IDLE)
			ncr53c9x_sched(sc);
	}
}

/*
 * POST PROCESSING OF SCSI_CMD (usually current)
 */
void
ncr53c9x_done(sc, ecb)
	struct ncr53c9x_softc *sc;
	struct ncr53c9x_ecb *ecb;
{
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];
	int lun = sc_link->lun;
	struct ncr53c9x_linfo *li = TINFO_LUN(ti, lun);

	NCR_TRACE(("[ncr53c9x_done(error:%x)] ", xs->error));

	timeout_del(&ecb->to);

	if (ecb->stat == SCSI_QUEUE_FULL) {
		/*
		 * Set current throttle -- we should reset
		 * this periodically
		 */
		sc_link->openings = li->used - 1;
		printf("\n%s: QFULL -- throttling to %d commands\n",
		    sc->sc_dev.dv_xname, sc_link->openings);
	}

	/*
	 * Now, if we've come here with no error code, i.e. we've kept the
	 * initial XS_NOERROR, and the status code signals that we should
	 * check sense, we'll need to set up a request sense cmd block and
	 * push the command back into the ready queue *before* any other
	 * commands for this target/lunit, else we lose the sense info.
	 * We don't support chk sense conditions for the request sense cmd.
	 */
	if (xs->error == XS_NOERROR) {
		xs->status = ecb->stat;
		if ((ecb->flags & ECB_ABORT) != 0) {
			xs->error = XS_TIMEOUT;
		} else if ((ecb->flags & ECB_SENSE) != 0) {
			xs->error = XS_SENSE;
		} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {
			/* First, save the return values */
			xs->resid = ecb->dleft;
			ncr53c9x_sense(sc, ecb);
			return;
		} else {
			xs->resid = ecb->dleft;
		}
	}

#ifdef NCR53C9X_DEBUG
	if (ncr53c9x_debug & NCR_SHOWMISC) {
		if (xs->resid != 0)
			printf("resid=%lu ", (unsigned long)xs->resid);
		if (xs->error == XS_SENSE)
			printf("sense=0x%02x\n", xs->sense.error_code);
		else
			printf("error=%d\n", xs->error);
	}
#endif

	/*
	 * Remove the ECB from whatever queue it's on.
	 */
	ncr53c9x_dequeue(sc, ecb);
	if (ecb == sc->sc_nexus) {
		sc->sc_nexus = NULL;
		if (sc->sc_state != NCR_CLEANING) {
			sc->sc_state = NCR_IDLE;
			ncr53c9x_sched(sc);
		}
	}

	ti->cmds++;
	scsi_done(xs);
}

void
ncr53c9x_dequeue(sc, ecb)
	struct ncr53c9x_softc *sc;
	struct ncr53c9x_ecb *ecb;
{
	struct ncr53c9x_tinfo *ti = 
	    &sc->sc_tinfo[ecb->xs->sc_link->target];
	struct ncr53c9x_linfo *li;
	int64_t lun = ecb->xs->sc_link->lun;
       
	li = TINFO_LUN(ti, lun);
#ifdef DIAGNOSTIC
	if ((!li) || (li->lun != lun))
		panic("ncr53c9x_dequeue: lun %llx for ecb %p does not exist",
		    (long long)lun, ecb);
#endif
	if (li->untagged == ecb) {
		li->busy = 0;
		li->untagged = NULL;
	}
	if (ecb->tag[0] && li->queued[ecb->tag[1]]) {
#ifdef DIAGNOSTIC
		if (li->queued[ecb->tag[1]] && (li->queued[ecb->tag[1]] != ecb))
			panic("ncr53c9x_dequeue: slot %d for lun %llx has %p "
			    "instead of ecb %p", ecb->tag[1],
			    (long long)lun,
			    li->queued[ecb->tag[1]], ecb);
#endif
		li->queued[ecb->tag[1]] = NULL;
		li->used --;

	}
	if (ecb->flags & ECB_READY) {
		ecb->flags &= ~ECB_READY;
		TAILQ_REMOVE(&sc->ready_list, ecb, chain);
	}
 }

/*
 * INTERRUPT/PROTOCOL ENGINE
 */

/*
 * Schedule an outgoing message by prioritizing it, and asserting
 * attention on the bus. We can only do this when we are the initiator
 * else there will be an illegal command interrupt.
 */
#define ncr53c9x_sched_msgout(m) \
	do {							\
		NCR_MISC(("ncr53c9x_sched_msgout %x %d ", m, __LINE__));	\
		NCRCMD(sc, NCRCMD_SETATN);			\
		sc->sc_flags |= NCR_ATN;			\
		sc->sc_msgpriq |= (m);				\
	} while (0)

static void
ncr53c9x_flushfifo(struct ncr53c9x_softc *sc)
{
	NCR_MISC(("[flushfifo] "));

	NCRCMD(sc, NCRCMD_FLUSH);

	if (sc->sc_phase == COMMAND_PHASE ||
	    sc->sc_phase == MESSAGE_OUT_PHASE)
		DELAY(2);
}

static int
ncr53c9x_rdfifo(struct ncr53c9x_softc *sc, int how)
{
	int i, n;
	u_char *buf;

	switch(how) {
	case NCR_RDFIFO_START:
		buf = sc->sc_imess;
		sc->sc_imlen = 0;
		break;
	case NCR_RDFIFO_CONTINUE:
		buf = sc->sc_imess + sc->sc_imlen;
		break;
	default:
		panic("ncr53c9x_rdfifo: bad flag");
		break;
	}

	/*
	 * XXX buffer (sc_imess) size for message
	 */

	n = NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF;

	if (sc->sc_rev == NCR_VARIANT_FAS366) {
		n *= 2;

		for (i = 0; i < n; i++)
			buf[i] = NCR_READ_REG(sc, NCR_FIFO);

		if (sc->sc_espstat2 & FAS_STAT2_ISHUTTLE) {

			NCR_WRITE_REG(sc, NCR_FIFO, 0);
			buf[i++] = NCR_READ_REG(sc, NCR_FIFO);

			NCR_READ_REG(sc, NCR_FIFO);

			ncr53c9x_flushfifo(sc);
		}
	} else {
		for (i = 0; i < n; i++)
			buf[i] = NCR_READ_REG(sc, NCR_FIFO);
	}

	sc->sc_imlen += i;

#ifdef NCR53C9X_DEBUG
	{
		int j;

		NCR_TRACE(("\n[rdfifo %s (%d):",
		    (how == NCR_RDFIFO_START) ? "start" : "cont",
		    (int)sc->sc_imlen));
		if (ncr53c9x_debug & NCR_SHOWTRAC) {
			for (j = 0; j < sc->sc_imlen; j++)
				printf(" %02x", sc->sc_imess[j]);
			printf("]\n");
		}
	}
#endif
	return sc->sc_imlen;
}

static void
ncr53c9x_wrfifo(struct ncr53c9x_softc *sc, u_char *p, int len)
{
	int i;

#ifdef NCR53C9X_DEBUG
	NCR_MISC(("[wrfifo(%d):", len));
	if (ncr53c9x_debug & NCR_SHOWTRAC) {
		for (i = 0; i < len; i++)
			printf(" %02x", p[i]);
		printf("]\n");
	}
#endif

	for (i = 0; i < len; i++) {
		NCR_WRITE_REG(sc, NCR_FIFO, p[i]);

		if (sc->sc_rev == NCR_VARIANT_FAS366)
			NCR_WRITE_REG(sc, NCR_FIFO, 0);
	}
}

int
ncr53c9x_reselect(sc, message, tagtype, tagid)
	struct ncr53c9x_softc *sc;
	int message;
	int tagtype;
	int tagid;
{
	u_char selid, target, lun;
	struct ncr53c9x_ecb *ecb = NULL;
	struct ncr53c9x_tinfo *ti;
	struct ncr53c9x_linfo *li;

	if (sc->sc_rev == NCR_VARIANT_FAS366) {
		target = sc->sc_selid;
	} else {
		/*
		 * The SCSI chip made a snapshot of the data bus while the reselection
		 * was being negotiated.  This enables us to determine which target did
		 * the reselect.
		 */
		selid = sc->sc_selid & ~(1 << sc->sc_id);
		if (selid & (selid - 1)) {
			printf("%s: reselect with invalid selid %02x;"
			    " sending DEVICE RESET\n", sc->sc_dev.dv_xname, selid);
			goto reset;

		}
		target = ffs(selid) - 1;
	}
	lun = message & 0x07;

	/*
	 * Search wait queue for disconnected cmd
	 * The list should be short, so I haven't bothered with
	 * any more sophisticated structures than a simple
	 * singly linked list.
	 */
	ti = &sc->sc_tinfo[target];
	li = TINFO_LUN(ti, lun);

	/*
	 * We can get as far as the LUN with the IDENTIFY
	 * message.  Check to see if we're running an
	 * un-tagged command.  Otherwise ack the IDENTIFY
	 * and wait for a tag message.
	 */
	if (li != NULL) {
		if (li->untagged != NULL && li->busy)
			ecb = li->untagged;
		else if (tagtype != MSG_SIMPLE_Q_TAG) {
			/* Wait for tag to come by */
			sc->sc_state = NCR_IDENTIFIED;
			return (0);
		} else if (tagtype) ecb = li->queued[tagid];
	}
	if (ecb == NULL) {
		printf("%s: reselect from target %d lun %d tag %x:%x with no nexus;"
		    " sending ABORT\n", sc->sc_dev.dv_xname, target, lun, tagtype, tagid);
		goto abort;
	}

	/* Make this nexus active again. */
	sc->sc_state = NCR_CONNECTED;
	sc->sc_nexus = ecb;
	ncr53c9x_setsync(sc, ti);

	if (ecb->flags & ECB_RESET)
		ncr53c9x_sched_msgout(SEND_DEV_RESET);
	else if (ecb->flags & ECB_ABORT)
		ncr53c9x_sched_msgout(SEND_ABORT);

	/* Do an implicit RESTORE POINTERS. */
	sc->sc_dp = ecb->daddr;
	sc->sc_dleft = ecb->dleft;

	return (0);

reset:
	ncr53c9x_sched_msgout(SEND_DEV_RESET);
	return (1);

abort:
	ncr53c9x_sched_msgout(SEND_ABORT);
	return (1);
}

static inline int
__verify_msg_format(u_char *p, int len)
{

	if (len == 1 && IS1BYTEMSG(p[0]))
		return 1;
	if (len == 2 && IS2BYTEMSG(p[0]))
		return 1;
	if (len >= 3 && ISEXTMSG(p[0]) &&
	    len == p[1] + 2)
		return 1;

	return 0;
}

/*
 * Get an incoming message as initiator.
 *
 * The SCSI bus must already be in MESSAGE_IN_PHASE and there is a
 * byte in the FIFO
 */
void
ncr53c9x_msgin(sc)
	struct ncr53c9x_softc *sc;
{

	NCR_TRACE(("[ncr53c9x_msgin(curmsglen:%ld)] ", (long)sc->sc_imlen));

	if (sc->sc_imlen == 0) {
		printf("%s: msgin: no msg byte available\n", sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Prepare for a new message.  A message should (according
	 * to the SCSI standard) be transmitted in one single
	 * MESSAGE_IN_PHASE. If we have been in some other phase,
	 * then this is a new message.
	 */
	if (sc->sc_prevphase != MESSAGE_IN_PHASE && sc->sc_state != NCR_RESELECTED) {
		printf("%s: phase change, dropping message, prev %d, state %d\n",
		    sc->sc_dev.dv_xname, sc->sc_prevphase, sc->sc_state);
		sc->sc_flags &= ~NCR_DROP_MSGI;
		sc->sc_imlen = 0;
	}

	NCR_TRACE(("<msgbyte:0x%02x>", sc->sc_imess[0]));

	/*
	 * If we're going to reject the message, don't bother storing
	 * the incoming bytes.  But still, we need to ACK them.
	 */
	if ((sc->sc_flags & NCR_DROP_MSGI)) {
		NCRCMD(sc, NCRCMD_MSGOK);
		printf("<dropping msg byte %x>",
			sc->sc_imess[sc->sc_imlen]);
		return;
	}

	if (sc->sc_imlen >= NCR_MAX_MSG_LEN) {
		ncr53c9x_sched_msgout(SEND_REJECT);
		sc->sc_flags |= NCR_DROP_MSGI;
	} else {
		u_char *pb;
		int plen;

		switch (sc->sc_state) {
			/*
			 * if received message is the first of reselection
			 * then first byte is selid, and then message
			 */
		case NCR_RESELECTED:
			pb = sc->sc_imess + 1;
			plen = sc->sc_imlen - 1;
			break;
		default:
			pb = sc->sc_imess;
			plen = sc->sc_imlen;
			break;
		}

		if (__verify_msg_format(pb, plen))
			goto gotit;
	}

	/* Ack what we have so far */
	NCRCMD(sc, NCRCMD_MSGOK);
	return;

gotit:
	NCR_MSGS(("gotmsg(%x) state %d", sc->sc_imess[0], sc->sc_state));
	/* we got complete message, flush the imess, XXX nobody uses imlen below */
	sc->sc_imlen = 0;

	/*
	 * Now we should have a complete message (1 byte, 2 byte
	 * and moderately long extended messages).  We only handle
	 * extended messages which total length is shorter than
	 * NCR_MAX_MSG_LEN.  Longer messages will be amputated.
	 */
	switch (sc->sc_state) {
		struct ncr53c9x_ecb *ecb;
		struct ncr53c9x_tinfo *ti;
		struct ncr53c9x_linfo *li;
		int lun;

	case NCR_CONNECTED:
		ecb = sc->sc_nexus;
		ti = &sc->sc_tinfo[ecb->xs->sc_link->target];

		switch (sc->sc_imess[0]) {
		case MSG_CMDCOMPLETE:
			NCR_MSGS(("cmdcomplete "));
			if (sc->sc_dleft < 0) {
				sc_print_addr(ecb->xs->sc_link);
				printf("got %ld extra bytes\n",
				    -(long)sc->sc_dleft);
				sc->sc_dleft = 0;
			}
			ecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)
				? 0
				: sc->sc_dleft;
			if ((ecb->flags & ECB_SENSE) == 0)
				ecb->xs->resid = ecb->dleft;
			sc->sc_state = NCR_CMDCOMPLETE;
			break;

		case MSG_MESSAGE_REJECT:
			NCR_MSGS(("msg reject (msgout=%x) ", sc->sc_msgout));
			switch (sc->sc_msgout) {
			case SEND_TAG:
				/* Target does not like tagged queuing.
				 *  - Flush the command queue
				 *  - Disable tagged queuing for the target
				 *  - Dequeue ecb from the queued array.
				 */
				printf("%s: tagged queuing rejected: target %d\n",
				    sc->sc_dev.dv_xname, ecb->xs->sc_link->target);
				
				NCR_MSGS(("(rejected sent tag)"));
				NCRCMD(sc, NCRCMD_FLUSH);
				DELAY(1);
				ti->flags &= ~T_TAG;
				lun = ecb->xs->sc_link->lun;
				li = TINFO_LUN(ti, lun);
				if (ecb->tag[0] &&
				    li->queued[ecb->tag[1]] != NULL) {
					li->queued[ecb->tag[1]] = NULL;
					li->used--;
				}
				ecb->tag[0] = ecb->tag[1] = 0;
				li->untagged = ecb;
				li->busy = 1;
				break;

			case SEND_SDTR:
				printf("%s: sync transfer rejected: target %d\n",
				    sc->sc_dev.dv_xname, ecb->xs->sc_link->target);
				sc->sc_flags &= ~NCR_SYNCHNEGO;
				ti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);
				ncr53c9x_setsync(sc, ti);
				break;

			case SEND_WDTR:
				printf("%s: wide transfer rejected: target %d\n",
				    sc->sc_dev.dv_xname, ecb->xs->sc_link->target);
				ti->flags &= ~T_WIDE;
				ti->width = 0;
				break;

			case SEND_INIT_DET_ERR:
				goto abort;
			}
			break;

		case MSG_NOOP:
			NCR_MSGS(("noop "));
			break;

		case MSG_HEAD_OF_Q_TAG:
		case MSG_SIMPLE_Q_TAG:
		case MSG_ORDERED_Q_TAG:
			NCR_MSGS(("TAG %x:%x", sc->sc_imess[0], sc->sc_imess[1]));
			break;

		case MSG_DISCONNECT:
			NCR_MSGS(("disconnect "));
			ti->dconns++;
			sc->sc_state = NCR_DISCONNECT;

			/*
			 * Mark the fact that all bytes have moved. The
			 * target may not bother to do a SAVE POINTERS
			 * at this stage. This flag will set the residual
			 * count to zero on MSG COMPLETE.
			 */
			if (sc->sc_dleft == 0)
				ecb->flags |= ECB_TENTATIVE_DONE;

			break;

		case MSG_SAVEDATAPOINTER:
			NCR_MSGS(("save datapointer "));
			ecb->daddr = sc->sc_dp;
			ecb->dleft = sc->sc_dleft;
			break;

		case MSG_RESTOREPOINTERS:
			NCR_MSGS(("restore datapointer "));
			sc->sc_dp = ecb->daddr;
			sc->sc_dleft = ecb->dleft;
			break;

		case MSG_EXTENDED:
			NCR_MSGS(("extended(%x) ", sc->sc_imess[2]));
			switch (sc->sc_imess[2]) {
			case MSG_EXT_SDTR:
				NCR_MSGS(("SDTR period %d, offset %d ",
					sc->sc_imess[3], sc->sc_imess[4]));
				if (sc->sc_imess[1] != 3)
					goto reject;
				ti->period = sc->sc_imess[3];
				ti->offset = sc->sc_imess[4];
				ti->flags &= ~T_NEGOTIATE;
				if (sc->sc_minsync == 0 ||
				    ti->offset == 0 ||
				    ti->period > 124) {
#ifdef NCR53C9X_DEBUG
					sc_print_addr(ecb->xs->sc_link);
					printf("async mode\n");
#endif
					if ((sc->sc_flags&NCR_SYNCHNEGO)
					    == 0) {
						/*
						 * target initiated negotiation
						 */
						ti->offset = 0;
						ti->flags &= ~T_SYNCMODE;
						ncr53c9x_sched_msgout(
						    SEND_SDTR);
					} else {
						/* we are async */
						ti->flags &= ~T_SYNCMODE;
					}
				} else {
#ifdef NCR53C9X_DEBUG
					int r, s;
#endif
					int p;

					p = ncr53c9x_stp2cpb(sc, ti->period);
					ti->period = ncr53c9x_cpb2stp(sc, p);
#ifdef NCR53C9X_DEBUG
					sc_print_addr(ecb->xs->sc_link);
					r = 250/ti->period;
					s = (100*250)/ti->period - 100*r;
					printf("max sync rate %d.%02dMB/s\n",
						r, s);
#endif
					if ((sc->sc_flags&NCR_SYNCHNEGO) == 0) {
						/*
						 * target initiated negotiation
						 */
						if (ti->period <
						    sc->sc_minsync)
							ti->period =
							    sc->sc_minsync;
						if (ti->offset > 15)
							ti->offset = 15;
						ti->flags &= ~T_SYNCMODE;
						ncr53c9x_sched_msgout(
						    SEND_SDTR);
					} else {
						/* we are sync */
						ti->flags |= T_SYNCMODE;
					}
				}
				sc->sc_flags &= ~NCR_SYNCHNEGO;
				ncr53c9x_setsync(sc, ti);
				break;

			case MSG_EXT_WDTR:
				printf("%s: wide mode %d\n",
				    sc->sc_dev.dv_xname, sc->sc_imess[3]);
				if (sc->sc_imess[3] == 1) {
					ti->cfg3 |= NCRFASCFG3_EWIDE;
					ncr53c9x_setsync(sc, ti);
				} else
					ti->width = 0;
				ti->flags &= ~T_WIDE;
				break;
			default:
				sc_print_addr(ecb->xs->sc_link);
				printf("unrecognized MESSAGE EXTENDED;"
				    " sending REJECT\n");
				goto reject;
			}
			break;

		default:
			NCR_MSGS(("ident "));
			sc_print_addr(ecb->xs->sc_link);
			printf("unrecognized MESSAGE; sending REJECT\n");
		reject:
			ncr53c9x_sched_msgout(SEND_REJECT);
			break;
		}
		break;

	case NCR_IDENTIFIED:
		/*
		 * IDENTIFY message was received and queue tag is expected now
		 */
		if ((sc->sc_imess[0] != MSG_SIMPLE_Q_TAG) ||
		    (sc->sc_msgify == 0)) {
			printf("%s: TAG reselect without IDENTIFY;"
			    " MSG %x;"
			    " sending DEVICE RESET\n",
			    sc->sc_dev.dv_xname,
			    sc->sc_imess[0]);
			goto reset;
		}
		(void) ncr53c9x_reselect(sc, sc->sc_msgify,
		    sc->sc_imess[0], sc->sc_imess[1]);
		break;

	case NCR_RESELECTED:
		if (MSG_ISIDENTIFY(sc->sc_imess[1])) {
			sc->sc_msgify = sc->sc_imess[1];
		} else {
			printf("%s: reselect without IDENTIFY;"
			    " MSG %x;"
			    " sending DEVICE RESET\n",
			    sc->sc_dev.dv_xname,
			    sc->sc_imess[1]);
			goto reset;
		}
		(void) ncr53c9x_reselect(sc, sc->sc_msgify, 0, 0);
		break;

	default:
		printf("%s: unexpected MESSAGE IN; sending DEVICE RESET\n",
		    sc->sc_dev.dv_xname);
	reset:
		ncr53c9x_sched_msgout(SEND_DEV_RESET);
		break;

	abort:
		ncr53c9x_sched_msgout(SEND_ABORT);
		break;
	}

	/* if we have more messages to send set ATN */
	if (sc->sc_msgpriq)
		NCRCMD(sc, NCRCMD_SETATN);

	/* Ack last message byte */
	NCRCMD(sc, NCRCMD_MSGOK);

	/* Done, reset message pointer. */
	sc->sc_flags &= ~NCR_DROP_MSGI;
	sc->sc_imlen = 0;
}


/*
 * Send the highest priority, scheduled message
 */
void
ncr53c9x_msgout(sc)
	struct ncr53c9x_softc *sc;
{
	struct ncr53c9x_tinfo *ti;
	struct ncr53c9x_ecb *ecb;
	size_t size;

	NCR_TRACE(("[ncr53c9x_msgout(priq:%x, prevphase:%x)]",
	    sc->sc_msgpriq, sc->sc_prevphase));

	/*
	 * XXX - the NCR_ATN flag is not in sync with the actual ATN
	 *	 condition on the SCSI bus. The 53c9x chip
	 *	 automatically turns off ATN before sending the
	 *	 message byte.  (see also the comment below in the
	 *	 default case when picking out a message to send)
	 */
	if (sc->sc_flags & NCR_ATN) {
		if (sc->sc_prevphase != MESSAGE_OUT_PHASE) {
		new:
			NCRCMD(sc, NCRCMD_FLUSH);
/*			DELAY(1); */
			sc->sc_msgoutq = 0;
			sc->sc_omlen = 0;
		}
	} else {
		if (sc->sc_prevphase == MESSAGE_OUT_PHASE) {
			ncr53c9x_sched_msgout(sc->sc_msgoutq);
			goto new;
		} else {
			printf("%s at line %d: unexpected MESSAGE OUT phase\n",
			    sc->sc_dev.dv_xname, __LINE__);
		}
	}
			
	if (sc->sc_omlen == 0) {
		/* Pick up highest priority message */
		sc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;
		sc->sc_msgoutq |= sc->sc_msgout;
		sc->sc_msgpriq &= ~sc->sc_msgout;
		sc->sc_omlen = 1;		/* "Default" message len */
		switch (sc->sc_msgout) {
		case SEND_SDTR:
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			sc->sc_omess[0] = MSG_EXTENDED;
			sc->sc_omess[1] = 3;
			sc->sc_omess[2] = MSG_EXT_SDTR;
			sc->sc_omess[3] = ti->period;
			sc->sc_omess[4] = ti->offset;
			sc->sc_omlen = 5;
			if ((sc->sc_flags & NCR_SYNCHNEGO) == 0) {
				ti->flags |= T_SYNCMODE;
				ncr53c9x_setsync(sc, ti);
			}
			break;
		case SEND_WDTR:
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			sc->sc_omess[0] = MSG_EXTENDED;
			sc->sc_omess[1] = 2;
			sc->sc_omess[2] = MSG_EXT_WDTR;
			sc->sc_omess[3] = ti->width;
			sc->sc_omlen = 4;
			break;
		case SEND_IDENTIFY:
			if (sc->sc_state != NCR_CONNECTED) {
				printf("%s at line %d: no nexus\n",
				    sc->sc_dev.dv_xname, __LINE__);
			}
			ecb = sc->sc_nexus;
			sc->sc_omess[0] =
			    MSG_IDENTIFY(ecb->xs->sc_link->lun, 0);
			break;
		case SEND_TAG:
			if (sc->sc_state != NCR_CONNECTED) {
				printf("%s at line %d: no nexus\n",
				    sc->sc_dev.dv_xname, __LINE__);
			}
			ecb = sc->sc_nexus;
			sc->sc_omess[0] = ecb->tag[0];
			sc->sc_omess[1] = ecb->tag[1];
			sc->sc_omlen = 2;
			break;
		case SEND_DEV_RESET:
			sc->sc_flags |= NCR_ABORTING;
			sc->sc_omess[0] = MSG_BUS_DEV_RESET;
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			ti->flags &= ~T_SYNCMODE;
			if ((ti->flags & T_SYNCHOFF) == 0)
				/* We can re-start sync negotiation */
				ti->flags |= T_NEGOTIATE;
			break;
		case SEND_PARITY_ERROR:
			sc->sc_omess[0] = MSG_PARITY_ERROR;
			break;
		case SEND_ABORT:
			sc->sc_flags |= NCR_ABORTING;
			sc->sc_omess[0] = MSG_ABORT;
			break;
		case SEND_INIT_DET_ERR:
			sc->sc_omess[0] = MSG_INITIATOR_DET_ERR;
			break;
		case SEND_REJECT:
			sc->sc_omess[0] = MSG_MESSAGE_REJECT;
			break;
		default:
			/*
			 * We normally do not get here, since the chip
			 * automatically turns off ATN before the last
			 * byte of a message is sent to the target.
			 * However, if the target rejects our (multi-byte)
			 * message early by switching to MSG IN phase
			 * ATN remains on, so the target may return to
			 * MSG OUT phase. If there are no scheduled messages
			 * left we send a NO-OP.
			 *
			 * XXX - Note that this leaves no useful purpose for
			 * the NCR_ATN flag.
			 */
			sc->sc_flags &= ~NCR_ATN;
			sc->sc_omess[0] = MSG_NOOP;
			break;
		}
		sc->sc_omp = sc->sc_omess;
	}

#ifdef DEBUG
	{
		int i;

		for (i = 0; i<sc->sc_omlen; i++)
			NCR_MISC(("<msgbyte:0x%02x>", sc->sc_omess[i]));
	}
#endif
	if (sc->sc_rev == NCR_VARIANT_FAS366) {
		/*      
		 * XXX fifo size
		 */
		ncr53c9x_flushfifo(sc);
		ncr53c9x_wrfifo(sc, sc->sc_omp, sc->sc_omlen);
		sc->sc_cmdlen = 0;
		NCRCMD(sc, NCRCMD_TRANS);
	} else {
		/* (re)send the message */
		size = min(sc->sc_omlen, sc->sc_maxxfer);
		NCRDMA_SETUP(sc, &sc->sc_omp, &sc->sc_omlen, 0, &size);
		/* Program the SCSI counter */
		NCR_SET_COUNT(sc, size);

               /* Load the count in and start the message-out transfer */
		NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);
		NCRCMD(sc, NCRCMD_TRANS|NCRCMD_DMA);
		NCRDMA_GO(sc);
	}
}

/*
 * This is the most critical part of the driver, and has to know
 * how to deal with *all* error conditions and phases from the SCSI
 * bus. If there are no errors and the DMA was active, then call the
 * DMA pseudo-interrupt handler. If this returns 1, then that was it
 * and we can return from here without further processing.
 *
 * Most of this needs verifying.
 */
int sdebug = 0;
int
ncr53c9x_intr(arg)
	void *arg;
{
	struct ncr53c9x_softc *sc = arg;
	struct ncr53c9x_ecb *ecb;
	struct scsi_link *sc_link;
	struct ncr53c9x_tinfo *ti;
	size_t size;
	int nfifo;

	NCR_TRACE(("[ncr53c9x_intr: state %d] ", sc->sc_state));

	if (!NCRDMA_ISINTR(sc))
		return (0);

again:
	/* and what do the registers say... */
	ncr53c9x_readregs(sc);

	/*
	 * At the moment, only a SCSI Bus Reset or Illegal
	 * Command are classed as errors. A disconnect is a
	 * valid condition, and we let the code check is the
	 * "NCR_BUSFREE_OK" flag was set before declaring it
	 * and error.
	 * 
	 * Also, the status register tells us about "Gross
	 * Errors" and "Parity errors". Only the Gross Error
	 * is really bad, and the parity errors are dealt   
	 * with later
	 * 
	 * TODO
	 *      If there are too many parity error, go to slow
	 *      cable mode ?
	 */

	/* SCSI Reset */
	if (sc->sc_espintr & NCRINTR_SBR) {
		if (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {
			NCRCMD(sc, NCRCMD_FLUSH);
			DELAY(1);
		}
		if (sc->sc_state != NCR_SBR) {
			printf("%s: SCSI bus reset\n",
				sc->sc_dev.dv_xname);
			ncr53c9x_init(sc, 0); /* Restart everything */
			return (1);
		}
#if 0
/*XXX*/		printf("<expected bus reset: "
			"[intr %x, stat %x, step %d]>\n",
			sc->sc_espintr, sc->sc_espstat,
			sc->sc_espstep);
#endif
		if (sc->sc_nexus)
			panic("%s: nexus in reset state",
		      sc->sc_dev.dv_xname);
		goto sched;
	}

	ecb = sc->sc_nexus;

#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)
	if (sc->sc_espintr & NCRINTR_ERR ||
	    sc->sc_espstat & NCRSTAT_GE) {

		if (sc->sc_espstat & NCRSTAT_GE) {
			/* Gross Error; no target ? */
			if (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {
				NCRCMD(sc, NCRCMD_FLUSH);
				DELAY(1);
			}
			if (sc->sc_state == NCR_CONNECTED ||
			    sc->sc_state == NCR_SELECTING) {
				ecb->xs->error = XS_TIMEOUT;
				ncr53c9x_done(sc, ecb);
			}
			return (1);
		}

		if (sc->sc_espintr & NCRINTR_ILL) {
			if (sc->sc_flags & NCR_EXPECT_ILLCMD) {
				/*
				 * Eat away "Illegal command" interrupt
				 * on a ESP100 caused by a re-selection
				 * while we were trying to select
				 * another target.
				 */
#ifdef DEBUG
				printf("%s: ESP100 work-around activated\n",
					sc->sc_dev.dv_xname);
#endif
				sc->sc_flags &= ~NCR_EXPECT_ILLCMD;
				return (1);
			}
			/* illegal command, out of sync ? */
			printf("%s: illegal command: 0x%x "
			    "(state %d, phase %x, prevphase %x)\n",
				sc->sc_dev.dv_xname, sc->sc_lastcmd,
				sc->sc_state, sc->sc_phase,
				sc->sc_prevphase);
			if (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {
				NCRCMD(sc, NCRCMD_FLUSH);
				DELAY(1);
			}
			ncr53c9x_init(sc, 1); /* Restart everything */
			return (1);
		}
	}
	sc->sc_flags &= ~NCR_EXPECT_ILLCMD;

	/*
	 * Call if DMA is active.
	 *
	 * If DMA_INTR returns true, then maybe go 'round the loop
	 * again in case there is no more DMA queued, but a phase
	 * change is expected.
	 */
	if (NCRDMA_ISACTIVE(sc)) {
		int r = NCRDMA_INTR(sc);
		if (r == -1) {
			printf("%s: DMA error; resetting\n",
				sc->sc_dev.dv_xname);
			ncr53c9x_init(sc, 1);
			return (1);
		}
		/* If DMA active here, then go back to work... */
		if (NCRDMA_ISACTIVE(sc))
			return (1);

		if ((sc->sc_espstat & NCRSTAT_TC) == 0) {
			/*
			 * DMA not completed.  If we can not find a
			 * acceptable explanation, print a diagnostic.
			 */
			if (sc->sc_state == NCR_SELECTING)
				/*
				 * This can happen if we are reselected
				 * while using DMA to select a target.
				 */
				/*void*/;
			else if (sc->sc_prevphase == MESSAGE_OUT_PHASE){
				/*
				 * Our (multi-byte) message (eg SDTR)
				 * was interrupted by the target to
				 * send a MSG REJECT.
				 * Print diagnostic if current phase
				 * is not MESSAGE IN.
				 */
				if (sc->sc_phase != MESSAGE_IN_PHASE)
				    printf("%s: !TC on MSG OUT"
				       " [intr %x, stat %x, step %d]"
				       " prevphase %x, resid %lx\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr,
					sc->sc_espstat,
					sc->sc_espstep,
					sc->sc_prevphase,
					(u_long)sc->sc_omlen);
			} else if (sc->sc_dleft == 0) {
				/*
				 * The DMA operation was started for
				 * a DATA transfer. Print a diagnostic
				 * if the DMA counter and TC bit
				 * appear to be out of sync.
				 */
				printf("%s: !TC on DATA XFER"
				       " [intr %x, stat %x, step %d]"
				       " prevphase %x, resid %x\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr,
					sc->sc_espstat,
					sc->sc_espstep,
					sc->sc_prevphase,
					ecb?ecb->dleft:-1);
			}
		}
	}

	/*
	 * check for less serious errors
	 */
	if (sc->sc_espstat & NCRSTAT_PE) {
		printf("%s: SCSI bus parity error\n", sc->sc_dev.dv_xname);
		if (sc->sc_prevphase == MESSAGE_IN_PHASE)
			ncr53c9x_sched_msgout(SEND_PARITY_ERROR);
		else
			ncr53c9x_sched_msgout(SEND_INIT_DET_ERR);
	}

	if (sc->sc_espintr & NCRINTR_DIS) {
		sc->sc_msgify = 0;
		NCR_MISC(("<DISC [intr %x, stat %x, step %d]>",
			sc->sc_espintr,sc->sc_espstat,sc->sc_espstep));
		if (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {
			NCRCMD(sc, NCRCMD_FLUSH);
/*			DELAY(1); */
		}
		/*
		 * This command must (apparently) be issued within
		 * 250mS of a disconnect. So here you are...
		 */
		NCRCMD(sc, NCRCMD_ENSEL);

		switch (sc->sc_state) {
		case NCR_RESELECTED:
			goto sched;

		case NCR_SELECTING:
			ecb->xs->error = XS_SELTIMEOUT;
			goto finish;

		case NCR_CONNECTED:
			if ((sc->sc_flags & NCR_SYNCHNEGO)) {
#ifdef NCR53C9X_DEBUG
				if (ecb)
					sc_print_addr(ecb->xs->sc_link);
				printf("sync nego not completed!\n");
#endif
				ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
				sc->sc_flags &= ~NCR_SYNCHNEGO;
				ti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);
			}

			/* it may be OK to disconnect */
			if ((sc->sc_flags & NCR_ABORTING) == 0) {
				/*  
				 * Section 5.1.1 of the SCSI 2 spec
				 * suggests issuing a REQUEST SENSE
				 * following an unexpected disconnect.
				 * Some devices go into a contingent
				 * allegiance condition when
				 * disconnecting, and this is necessary
				 * to clean up their state.
				 */     
				printf("%s: unexpected disconnect; ",
				    sc->sc_dev.dv_xname);
				if (ecb->flags & ECB_SENSE) {
					printf("resetting\n");
					goto reset;
				}
				printf("sending REQUEST SENSE\n");
				timeout_del(&ecb->to);
				ncr53c9x_sense(sc, ecb);
				goto out;
			}

			ecb->xs->error = XS_TIMEOUT;
			goto finish;

		case NCR_DISCONNECT:
			sc->sc_nexus = NULL;
			goto sched;

		case NCR_CMDCOMPLETE:
			goto finish;
		}
	}

	switch (sc->sc_state) {

	case NCR_SBR:
		printf("%s: waiting for SCSI Bus Reset to happen\n",
			sc->sc_dev.dv_xname);
		return (1);

	case NCR_RESELECTED:
		/*
		 * we must be continuing a message ?
		 */
		if (sc->sc_phase != MESSAGE_IN_PHASE) {
			printf("%s: target didn't identify\n",
				sc->sc_dev.dv_xname);
			ncr53c9x_init(sc, 1);
			return (1);
		}
printf("<<RESELECT CONT'd>>");
#if XXXX
		ncr53c9x_msgin(sc);
		if (sc->sc_state != NCR_CONNECTED) {
			/* IDENTIFY fail?! */
			printf("%s: identify failed\n",
				sc->sc_dev.dv_xname);
			ncr53c9x_init(sc, 1);
			return (1);
		}
#endif
		break;

	case NCR_IDENTIFIED:
		ecb = sc->sc_nexus;
		if (sc->sc_phase != MESSAGE_IN_PHASE) {
			int i = (NCR_READ_REG(sc, NCR_FFLAG)
			    & NCRFIFO_FF);
			/*
			 * Things are seriously fucked up.
			 * Pull the brakes, i.e. reset
			 */
			printf("%s: target didn't send tag: %d bytes in fifo\n",
			    sc->sc_dev.dv_xname, i);
			/* Drain and display fifo */
			while (i-- > 0)
				printf("[%d] ", NCR_READ_REG(sc, NCR_FIFO));
			ncr53c9x_init(sc, 1);
			return (1);
		} else
			goto msgin;

		break;
	case NCR_IDLE:
	case NCR_SELECTING:
		ecb = sc->sc_nexus;
		if (sc->sc_espintr & NCRINTR_RESEL) {
			sc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;
			sc->sc_flags = 0;
			/*
			 * If we're trying to select a
			 * target ourselves, push our command
			 * back into the ready list.
			 */
			if (sc->sc_state == NCR_SELECTING) {
				NCR_MISC(("backoff selector "));
				timeout_del(&ecb->to);
				ncr53c9x_dequeue(sc, ecb);
				TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
				ecb->flags |= ECB_READY;
				ecb = sc->sc_nexus = NULL;
			}
			sc->sc_state = NCR_RESELECTED;
			if (sc->sc_phase != MESSAGE_IN_PHASE) {
				/*
				 * Things are seriously fucked up.
				 * Pull the brakes, i.e. reset
				 */
				printf("%s: target didn't identify\n",
					sc->sc_dev.dv_xname);
				ncr53c9x_init(sc, 1);
				return (1);
			}
			/*
			 * The C90 only inhibits FIFO writes until
			 * reselection is complete, instead of
			 * waiting until the interrupt status register
			 * has been read. So, if the reselect happens
			 * while we were entering a command bytes (for
			 * another target) some of those bytes can
			 * appear in the FIFO here, after the
			 * interrupt is taken.
			 */
			nfifo = ncr53c9x_rdfifo(sc, NCR_RDFIFO_START);

			if (nfifo < 2 ||
			    (nfifo > 2 &&
			     sc->sc_rev != NCR_VARIANT_ESP100)) {
				printf("%s: RESELECT: "
				    "%d bytes in FIFO! "
				    "[intr %x, stat %x, step %d, prevphase %x]\n",
					sc->sc_dev.dv_xname,
					nfifo,
					sc->sc_espintr,
					sc->sc_espstat,
					sc->sc_espstep,
					sc->sc_prevphase);
				ncr53c9x_init(sc, 1);
				return (1);
			}
			sc->sc_selid = sc->sc_imess[0];
			NCR_MISC(("selid=%2x ", sc->sc_selid));

			/* Handle identify message */
			ncr53c9x_msgin(sc);
			if (nfifo != 2) {
				/*
				 * Note: this should not happen
				 * with `dmaselect' on.
				 */
				sc->sc_flags |= NCR_EXPECT_ILLCMD;
				NCRCMD(sc, NCRCMD_FLUSH);
			} else if (sc->sc_features & NCR_F_DMASELECT &&
				   sc->sc_rev == NCR_VARIANT_ESP100) {
				sc->sc_flags |= NCR_EXPECT_ILLCMD;
			}

			if (sc->sc_state != NCR_CONNECTED &&
			    sc->sc_state != NCR_IDENTIFIED) {
				/* IDENTIFY fail?! */
				printf("%s: identify failed, state %d, intr %02x\n",
					sc->sc_dev.dv_xname, sc->sc_state,
				    sc->sc_espintr);
				ncr53c9x_init(sc, 1);
				return (1);
			}
			goto shortcut; /* ie. next phase expected soon */
		}

#define	NCRINTR_DONE	(NCRINTR_FC|NCRINTR_BS)
		if ((sc->sc_espintr & NCRINTR_DONE) == NCRINTR_DONE) {
			/*
			 * Arbitration won; examine the `step' register
			 * to determine how far the selection could progress.
			 */
			ecb = sc->sc_nexus;
			if (!ecb)
				panic("ncr53c9x: no nexus");

			sc_link = ecb->xs->sc_link;
			ti = &sc->sc_tinfo[sc_link->target];

			switch (sc->sc_espstep) {
			case 0:
				/*
				 * The target did not respond with a
				 * message out phase - probably an old
				 * device that doesn't recognize ATN.
				 * Clear ATN and just continue, the
				 * target should be in the command
				 * phase.
				 * XXXX check for command phase?
				 */
				NCRCMD(sc, NCRCMD_RSTATN);
				break;
			case 1:
				if ((ti->flags & T_NEGOTIATE) == 0 &&
				    ecb->tag[0] == 0) {
					printf("%s: step 1 & !NEG\n",
						sc->sc_dev.dv_xname);
					goto reset;
				}
				if (sc->sc_phase != MESSAGE_OUT_PHASE) {
					printf("%s: !MSGOUT\n",
						sc->sc_dev.dv_xname);
					goto reset;
				}
				if (ti->flags & T_WIDE) {
					ncr53c9x_sched_msgout(SEND_WDTR);
				}
				if (ti->flags & T_NEGOTIATE) {
					/* Start negotiating */
					ti->period = sc->sc_minsync;
					ti->offset = 15;
					sc->sc_flags |= NCR_SYNCHNEGO;
					if (ecb->tag[0])
						ncr53c9x_sched_msgout(SEND_TAG|SEND_SDTR);
					else
						ncr53c9x_sched_msgout(SEND_SDTR);
				} else {
					/* Could not do ATN3 so send TAG */
					ncr53c9x_sched_msgout(SEND_TAG);
				}
				sc->sc_prevphase = MESSAGE_OUT_PHASE; /* XXXX */
				break;
			case 3:
				/*
				 * Grr, this is supposed to mean
				 * "target left command phase  prematurely".
				 * It seems to happen regularly when
				 * sync mode is on.
				 * Look at FIFO to see if command went out.
				 * (Timing problems?)
				 */
				if (sc->sc_features & NCR_F_DMASELECT) {
					if (sc->sc_cmdlen == 0)
						/* Hope for the best.. */
						break;
				} else if ((NCR_READ_REG(sc, NCR_FFLAG)
					    & NCRFIFO_FF) == 0) {
					/* Hope for the best.. */
					break;
				}
				printf("(%s:%d:%d): selection failed;"
					" %d left in FIFO "
					"[intr %x, stat %x, step %d]\n",
					sc->sc_dev.dv_xname,
					sc_link->target,
					sc_link->lun,
					NCR_READ_REG(sc, NCR_FFLAG)
					 & NCRFIFO_FF,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
				NCRCMD(sc, NCRCMD_FLUSH);
				ncr53c9x_sched_msgout(SEND_ABORT);
				return (1);
			case 2:
				/* Select stuck at Command Phase */
				NCRCMD(sc, NCRCMD_FLUSH);
				break;
			case 4:
				if (sc->sc_features & NCR_F_DMASELECT &&
				    sc->sc_cmdlen != 0)
					printf("(%s:%d:%d): select; "
					       "%lu left in DMA buffer "
					"[intr %x, stat %x, step %d]\n",
						sc->sc_dev.dv_xname,
						sc_link->target,
						sc_link->lun,
						(u_long)sc->sc_cmdlen,
						sc->sc_espintr,
						sc->sc_espstat,
						sc->sc_espstep);
				/* So far, everything went fine */
				break;
			}

			sc->sc_prevphase = INVALID_PHASE; /* ?? */
			/* Do an implicit RESTORE POINTERS. */
			sc->sc_dp = ecb->daddr;
			sc->sc_dleft = ecb->dleft;
			sc->sc_state = NCR_CONNECTED;
			break;

		} else {

			printf("%s: unexpected status after select"
				": [intr %x, stat %x, step %x]\n",
				sc->sc_dev.dv_xname,
				sc->sc_espintr, sc->sc_espstat,
				sc->sc_espstep);
			NCRCMD(sc, NCRCMD_FLUSH);
			DELAY(1);
			goto reset;
		}
		if (sc->sc_state == NCR_IDLE) {
			printf("%s: stray interrupt\n",
			    sc->sc_dev.dv_xname);
				return (0);
		}
		break;

	case NCR_CONNECTED:
		if (sc->sc_flags & NCR_ICCS) {
			/* "Initiate Command Complete Steps" in progress */
			u_char msg;

			sc->sc_flags &= ~NCR_ICCS;

			if (!(sc->sc_espintr & NCRINTR_DONE)) {
				printf("%s: ICCS: "
				      ": [intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
			}
			ncr53c9x_rdfifo(sc, NCR_RDFIFO_START);
			if (sc->sc_imlen < 2)
				printf("%s: can't get status, only %d bytes\n",
				    sc->sc_dev.dv_xname, (int)sc->sc_imlen);
			ecb->stat = sc->sc_imess[sc->sc_imlen - 2];
			msg = sc->sc_imess[sc->sc_imlen - 1];
			NCR_PHASE(("<stat:(%x,%x)>", ecb->stat, msg));
			if (msg == MSG_CMDCOMPLETE) {
				ecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)
					? 0
					: sc->sc_dleft;
				if ((ecb->flags & ECB_SENSE) == 0)
					ecb->xs->resid = ecb->dleft;
				sc->sc_state = NCR_CMDCOMPLETE;
			} else
				printf("%s: STATUS_PHASE: msg %d\n",
					sc->sc_dev.dv_xname, msg);
			sc->sc_imlen = 0;
			NCRCMD(sc, NCRCMD_MSGOK);
			goto shortcut; /* ie. wait for disconnect */
		}
		break;
	default:
		/* Don't panic: reset. */
		printf("%s: invalid state: %d\n",
		      sc->sc_dev.dv_xname,
		      sc->sc_state);
		ncr53c9x_scsi_reset(sc);
		goto out;
		break;
	}

	/*
	 * Driver is now in state NCR_CONNECTED, i.e. we
	 * have a current command working the SCSI bus.
	 */
	if (sc->sc_state != NCR_CONNECTED || ecb == NULL) {
		panic("ncr53c9x no nexus");
	}

	switch (sc->sc_phase) {
	case MESSAGE_OUT_PHASE:
		NCR_PHASE(("MESSAGE_OUT_PHASE "));
		ncr53c9x_msgout(sc);
		sc->sc_prevphase = MESSAGE_OUT_PHASE;
		break;
	case MESSAGE_IN_PHASE:
msgin:
		NCR_PHASE(("MESSAGE_IN_PHASE "));
		if (sc->sc_espintr & NCRINTR_BS) {
			if ((sc->sc_rev != NCR_VARIANT_FAS366) ||
			    !(sc->sc_espstat2 & FAS_STAT2_EMPTY)) {
				NCRCMD(sc, NCRCMD_FLUSH);
			}
			sc->sc_flags |= NCR_WAITI;
			NCRCMD(sc, NCRCMD_TRANS);
		} else if (sc->sc_espintr & NCRINTR_FC) {
			if ((sc->sc_flags & NCR_WAITI) == 0) {
				printf("%s: MSGIN: unexpected FC bit: "
					"[intr %x, stat %x, step %x]\n",
				sc->sc_dev.dv_xname,
				sc->sc_espintr, sc->sc_espstat,
				sc->sc_espstep);
			}
			sc->sc_flags &= ~NCR_WAITI;
			ncr53c9x_rdfifo(sc,
			    (sc->sc_prevphase == sc->sc_phase) ?
			    NCR_RDFIFO_CONTINUE : NCR_RDFIFO_START);
			ncr53c9x_msgin(sc);
		} else {
			printf("%s: MSGIN: weird bits: "
				"[intr %x, stat %x, step %x]\n",
				sc->sc_dev.dv_xname,
				sc->sc_espintr, sc->sc_espstat,
				sc->sc_espstep);
		}
		sc->sc_prevphase = MESSAGE_IN_PHASE;
		goto shortcut;	/* i.e. expect data to be ready */
		break;
	case COMMAND_PHASE:
		/*
		 * Send the command block. Normally we don't see this
		 * phase because the SEL_ATN command takes care of
		 * all this. However, we end up here if either the
		 * target or we wanted to exchange some more messages
		 * first (e.g. to start negotiations).
		 */

		NCR_PHASE(("COMMAND_PHASE 0x%02x (%d) ",
			ecb->cmd.cmd.opcode, ecb->clen));
		if (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {
			NCRCMD(sc, NCRCMD_FLUSH);
/*			DELAY(1); */
		}
		if (sc->sc_features & NCR_F_DMASELECT) {
			/* setup DMA transfer for command */
			size = ecb->clen;
			sc->sc_cmdlen = size;
			sc->sc_cmdp = (caddr_t)&ecb->cmd.cmd;
			NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen,
				     0, &size);
			/* Program the SCSI counter */
			NCR_SET_COUNT(sc, size);

			/* load the count in */
			NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);

			/* start the command transfer */
			NCRCMD(sc, NCRCMD_TRANS | NCRCMD_DMA);
			NCRDMA_GO(sc);
		} else {
			ncr53c9x_wrfifo(sc, (u_char *)&ecb->cmd.cmd, ecb->clen);
			sc->sc_cmdlen = 0;
			NCRCMD(sc, NCRCMD_TRANS);
		}
		sc->sc_prevphase = COMMAND_PHASE;
		break;
	case DATA_OUT_PHASE:
		NCR_PHASE(("DATA_OUT_PHASE [%ld] ",(long)sc->sc_dleft));
		NCRCMD(sc, NCRCMD_FLUSH);
		size = min(sc->sc_dleft, sc->sc_maxxfer);
		NCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,
			  0, &size);
		sc->sc_prevphase = DATA_OUT_PHASE;
		goto setup_xfer;
	case DATA_IN_PHASE:
		NCR_PHASE(("DATA_IN_PHASE "));
		if (sc->sc_rev == NCR_VARIANT_ESP100)
			NCRCMD(sc, NCRCMD_FLUSH);
		size = min(sc->sc_dleft, sc->sc_maxxfer);
		NCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,
			  1, &size);
		sc->sc_prevphase = DATA_IN_PHASE;
	setup_xfer:
		/* Target returned to data phase: wipe "done" memory */
		ecb->flags &= ~ECB_TENTATIVE_DONE;

		/* Program the SCSI counter */
		NCR_SET_COUNT(sc, size);

		/* load the count in */
		NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);

		/*
		 * Note that if `size' is 0, we've already transceived
		 * all the bytes we want but we're still in DATA PHASE.
		 * Apparently, the device needs padding. Also, a
		 * transfer size of 0 means "maximum" to the chip
		 * DMA logic.
		 */
		NCRCMD(sc,
		       (size==0?NCRCMD_TRPAD:NCRCMD_TRANS)|NCRCMD_DMA);
		NCRDMA_GO(sc);
		return (1);
	case STATUS_PHASE:
		NCR_PHASE(("STATUS_PHASE "));
		sc->sc_flags |= NCR_ICCS;
		NCRCMD(sc, NCRCMD_ICCS);
		sc->sc_prevphase = STATUS_PHASE;
		goto shortcut;	/* i.e. expect status results soon */
		break;
	case INVALID_PHASE:
		break;
	default:
		printf("%s: unexpected bus phase; resetting\n",
		    sc->sc_dev.dv_xname);
		goto reset;
	}

out:
	return (1);

reset:
	ncr53c9x_init(sc, 1);
	goto out;

finish:
	ncr53c9x_done(sc, ecb);
	goto out;

sched:
	sc->sc_state = NCR_IDLE;
	ncr53c9x_sched(sc);
	goto out;

shortcut:
	/*
	 * The idea is that many of the SCSI operations take very little
	 * time, and going away and getting interrupted is too high an
	 * overhead to pay. For example, selecting, sending a message
	 * and command and then doing some work can be done in one "pass".
	 *
	 * The delay is a heuristic. It is 2 when at 20MHz, 2 at 25MHz and 1
	 * at 40MHz. This needs testing.
	 */
	{
		struct timeval wait, cur;

		microtime(&wait);
		wait.tv_usec += 50/sc->sc_freq;
		if (wait.tv_usec > 1000000) {
			wait.tv_sec++;
			wait.tv_usec -= 1000000;
		}
		do {
			if (NCRDMA_ISINTR(sc))
				goto again;
			microtime(&cur);
		} while (timercmp(&cur, &wait, <=));
	}
	goto out;
}

void
ncr53c9x_abort(sc, ecb)
	struct ncr53c9x_softc *sc;
	struct ncr53c9x_ecb *ecb;
{

	/* 2 secs for the abort */
	ecb->timeout = NCR_ABORT_TIMEOUT;
	ecb->flags |= ECB_ABORT;

	if (ecb == sc->sc_nexus) {
		int timeout = ecb->timeout;

		/*
		 * If we're still selecting, the message will be scheduled
		 * after selection is complete.
		 */
		if (sc->sc_state == NCR_CONNECTED)
			ncr53c9x_sched_msgout(SEND_ABORT);

		/*
		 * Reschedule timeout.
		 */
		if (timeout > 1000000)
			timeout = (timeout / 1000) * hz;
		else
			timeout = (timeout * hz) / 1000;
		timeout_add(&ecb->to, timeout);
	} else {
		/*
		 * Just leave the command where it is.
		 * XXX - what choice do we have but to reset the SCSI
		 *	 eventually?
		 */
		if (sc->sc_state == NCR_IDLE)
			ncr53c9x_sched(sc);
	}
}

void
ncr53c9x_timeout(arg)
	void *arg;
{
	struct ncr53c9x_ecb *ecb = arg;
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct ncr53c9x_softc *sc = sc_link->adapter_softc;
	struct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];
	int s;

	sc_print_addr(sc_link);
	printf("timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], "
	       "<state %d, nexus %p, phase(l %x, c %x, p %x), resid %lx, "
	       "msg(q %x,o %x) %s>",
		ecb, ecb->flags, ecb->dleft, ecb->stat,
		sc->sc_state, sc->sc_nexus,
		NCR_READ_REG(sc, NCR_STAT),
		sc->sc_phase, sc->sc_prevphase,
		(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,
		NCRDMA_ISACTIVE(sc) ? "DMA active" : "");
#if NCR53C9X_DEBUG > 1
	printf("TRACE: %s.", ecb->trace);
#endif

	s = splbio();

	if (ecb->flags & ECB_ABORT) {
		/* abort timed out */
		printf(" AGAIN\n");

		ncr53c9x_init(sc, 1);
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		xs->error = XS_TIMEOUT;
		ncr53c9x_abort(sc, ecb);

		/* Disable sync mode if stuck in a data phase */
		if (ecb == sc->sc_nexus &&
		    (ti->flags & T_SYNCMODE) != 0 &&
		    (sc->sc_phase & (MSGI|CDI)) == 0) {
			sc_print_addr(sc_link);
			printf("sync negotiation disabled\n");
			sc->sc_cfflags |= (1 << (sc_link->target + 16));
		}
	}

	splx(s);
}
@


1.63
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.62 2016/08/23 03:28:01 guenther Exp $	*/
a67 1
#include <sys/types.h>
@


1.62
log
@Convert %q to %ll in format strings

ok natano@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.61 2015/11/08 22:27:10 miod Exp $	*/
d395 2
a396 3
		pool_init(&ecb_pool, sizeof(struct ncr53c9x_ecb), 0, 0, 0,
		    "ncr53c9x_ecb", NULL);
		pool_setipl(&ecb_pool, IPL_BIO);
@


1.61
log
@Merge NetBSD 1.145:
When issuing a non-dma command, make sure to set the "remaining length of
command to be transfered via dma" (sc_cmdlen) to zero upfront, otherwise we
might get confused on command completition interrupt (no dma active but still
data left to transfer).
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.60 2015/03/14 03:38:47 jsg Exp $	*/
d1214 1
a1214 1
		panic("ncr53c9x_dequeue: lun %qx for ecb %p does not exist",
d1224 1
a1224 1
			panic("ncr53c9x_dequeue: slot %d for lun %qx has %p "
@


1.60
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.59 2014/09/14 14:17:24 jsg Exp $	*/
d670 1
d740 1
d1951 1
d2632 1
@


1.59
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.58 2014/07/12 18:48:17 tedu Exp $	*/
a74 1
#include <sys/buf.h>
@


1.58
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.57 2014/01/26 17:26:55 miod Exp $	*/
a76 1
#include <sys/proc.h>
@


1.57
log
@Quoting an old commit message:

``Callers of scsi_iopool_init() ought to set up the pool member in struct
scsi_link accordingly, for bad things will happen without (and this was a
real pita to debug).''
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.56 2014/01/18 23:09:04 dlg Exp $	*/
d825 1
a825 1
	free(li, M_DEVBUF);
@


1.56
log
@move the declaration of ncr53c9x_scsi_cmd into the .c file, its the only
place that uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.55 2014/01/18 23:07:28 dlg Exp $	*/
d278 1
@


1.55
log
@replace XS_NO_CCB with an iopool around the ecb_pool.

take advantage of pool_setipl while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.54 2014/01/18 22:56:11 dlg Exp $	*/
d151 1
@


1.54
log
@get rid of a XS_NO_CCB thats caused by a failure to allocate the
thing that stores state for luns.

instead of checking and allocating it in the scsi_cmd path, and
doing weird things all over the place to free it (eg, there's a
timeout that ran every 10m to gc luns), use the scsi_probe and
scsi_free things the midlayer calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.53 2014/01/18 22:33:59 dlg Exp $	*/
d117 2
a118 3
void ncr53c9x_free_ecb(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *, int);
struct ncr53c9x_ecb *ncr53c9x_get_ecb(struct ncr53c9x_softc *, int);
d144 1
d397 3
d754 3
a756 7
void
ncr53c9x_free_ecb(sc, ecb, flags)
	struct ncr53c9x_softc *sc;
	struct ncr53c9x_ecb *ecb;
	int flags;
{
	int s;
d758 2
a759 10
	s = splbio();
	ecb->flags = 0;
	pool_put(&ecb_pool, (void *)ecb);
	splx(s);
}

struct ncr53c9x_ecb *
ncr53c9x_get_ecb(sc, flags)
	struct ncr53c9x_softc *sc;
	int flags;
a761 4
	int s, wait = PR_NOWAIT;

	if ((curproc != NULL) && ((flags & SCSI_NOSLEEP) == 0))
		wait = PR_WAITOK;
d763 1
a763 3
	s = splbio();
	ecb = (struct ncr53c9x_ecb *)pool_get(&ecb_pool, wait);
	splx(s);
d766 1
a766 1
	bzero(ecb, sizeof(*ecb));
d769 1
d773 5
a777 3
/*
 * DRIVER FUNCTIONS CALLABLE FROM HIGHER LEVEL DRIVERS
 */
a865 6
	if ((ecb = ncr53c9x_get_ecb(sc, flags)) == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}

d867 1
a1194 1
	ncr53c9x_free_ecb(sc, ecb, xs->flags);
@


1.53
log
@instead of having every bit of glue set up and attach an identical
scsi_adapter struct, just do it once in the chip code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.52 2011/11/08 18:18:41 krw Exp $	*/
a109 1
/*static*/ void ncr53c9x_watch(void *arg);
d151 3
d157 2
a158 2
	NULL,			/* lun probe */
	NULL,			/* lun free */
a202 1
	timeout_set(&sc->sc_watchdog, ncr53c9x_watch, sc);
a284 1
	timeout_add(&sc->sc_watchdog, 60*hz);
d791 47
a876 16
	if (li == NULL) {
		/* Initialize LUN info and add to list. */
		if ((li = malloc(sizeof(*li), M_DEVBUF,
		    M_NOWAIT | M_ZERO)) == NULL) {
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			return;
		}
		li->last_used = time_second;
		li->lun = lun;
		s = splbio();
		LIST_INSERT_HEAD(&ti->luns, li, link);
		if (lun < NCR_NLUN)
			ti->lun[lun] = li;
		splx(s);
	}
a1211 10
	if (xs->error == XS_SELTIMEOUT) {
		/* Selection timeout -- discard this LUN if empty */
		if (!li->untagged && !li->used) {
			if (lun < NCR_NLUN)
				ti->lun[lun] = NULL;
			LIST_REMOVE(li, link);
			free(li, M_DEVBUF);
		}
	}

a2201 3
		{
			struct ncr53c9x_linfo *li;

d2203 1
a2204 18
			/* Selection timeout -- discard all LUNs if empty */
			sc_link = ecb->xs->sc_link;
			ti = &sc->sc_tinfo[sc_link->target];
			for (li = LIST_FIRST(&ti->luns);
			    li != LIST_END(&ti->luns); ) {
				if (!li->untagged && !li->used) {
					if (li->lun < NCR_NLUN)
						ti->lun[li->lun] = NULL;
					LIST_REMOVE(li, link);
					free(li, M_DEVBUF);
					/* Restart the search at the beginning */
					li = LIST_FIRST(&ti->luns);
					continue;
				}
				li = LIST_NEXT(li, link);
			}
			goto finish;
		}
a2834 31
}

void
ncr53c9x_watch(arg)
	void *arg;
{
	struct ncr53c9x_softc *sc = (struct ncr53c9x_softc *)arg;
	struct ncr53c9x_tinfo *ti;
	struct ncr53c9x_linfo *li;
	int t, s;
	/* Delete any structures that have not been used in 10min. */
	time_t old = time_second - (10*60);

	s = splbio();
	for (t = 0; t < sc->sc_ntarg; t++) {
		ti = &sc->sc_tinfo[t];
		for (li = LIST_FIRST(&ti->luns); li != LIST_END(&ti->luns); ) {
			if (li->last_used < old && !li->untagged && !li->used) {
				if (li->lun < NCR_NLUN)
					ti->lun[li->lun] = NULL;
				LIST_REMOVE(li, link);
				free(li, M_DEVBUF);
				/* Restart the search at the beginning */
				li = LIST_FIRST(&ti->luns);
				continue; 
			}
			li = LIST_NEXT(li, link);
		}
	}
	splx(s);
	timeout_add_sec(&sc->sc_watchdog, 60);
@


1.52
log
@ncr53c9x (a.k.a. esp on sparc64) does not like 16-byte SCSI commands
such as READ_CAPACITY_16. So plugging SCSI-3 devices onto such a bus
can be problematic.

Cap the acceptable xs->cmdlen at 12 in ncr53c9x.c.

Problem noted and fix tested by Kurt Mosiejczuk. Thanks! Diff mostly
from miod@@ with kibitzing from me.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.51 2011/08/29 17:25:28 miod Exp $	*/
d152 8
d196 1
a196 1
ncr53c9x_attach(sc, adapter)
a197 1
	struct scsi_adapter *adapter;
d273 1
a273 1
	sc->sc_link.adapter = adapter;
@


1.51
log
@protect sc->sc_state access and ncr53c9x_sched() call with splbio in
ncr53c9x_poll(). Fixes a race causing *some* drives to trigger a
panic in ncr53c9x_sched() at attach time on vax.
ok dlg@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.50 2010/11/11 17:47:00 miod Exp $	*/
d804 15
@


1.50
log
@Pass a few more M_ZERO to malloc() or its wrappers, when useful; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.49 2010/09/28 01:50:08 deraadt Exp $	*/
d894 1
d899 1
@


1.49
log
@do not assume PR_NOWAIT is 0; it is not anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.48 2010/06/28 18:31:02 krw Exp $	*/
d810 2
a811 1
		if ((li = malloc(sizeof(*li), M_DEVBUF, M_NOWAIT)) == NULL) {
a815 1
		bzero(li, sizeof(*li));
d957 2
a958 1
			if ((li = malloc(sizeof(*li), M_DEVBUF, M_NOWAIT)) == NULL) {
a961 1
			bzero(li, sizeof(*li));
@


1.48
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.47 2010/06/26 23:24:44 guenther Exp $	*/
d764 1
a764 1
	int s, wait = 0;
@


1.47
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.46 2010/05/20 00:55:17 krw Exp $	*/
d188 1
a188 1
ncr53c9x_attach(sc, adapter, dev)
a190 1
	struct scsi_device *dev;
a266 1
	sc->sc_link.device = dev;
@


1.46
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.45 2010/03/23 01:57:19 krw Exp $	*/
a77 1
#include <sys/user.h>
@


1.45
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.44 2010/01/13 06:09:44 krw Exp $	*/
a814 1
			s = splbio();
a815 1
			splx(s);
a829 1
		s = splbio();
a830 1
		splx(s);
d1096 1
a1096 1
	int s, lun = sc_link->lun;
a1171 1
	s = splbio();
a1172 1
	splx(s);
@


1.44
log
@Remove a few more settings of ITSDONE in drivers. Only a couple
more to go. Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.43 2009/12/06 17:24:28 krw Exp $	*/
d792 1
a792 1
int
d814 5
a818 1
			return (NO_CCB);
d830 7
a836 2
	if ((ecb = ncr53c9x_get_ecb(sc, flags)) == NULL)
		return (NO_CCB);
d864 1
a864 1
		return (SUCCESSFULLY_QUEUED);
a871 1
	return (COMPLETE);
@


1.43
log
@Nuke SCSI_URGENT after removing its only use, in ncr53c9x.c. That use
was to try to play dangerous games with tagged queuing.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.42 2009/11/22 14:14:10 krw Exp $	*/
a1131 2

	xs->flags |= ITSDONE;
@


1.42
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.41 2009/11/01 23:06:03 fgsch Exp $	*/
a944 2
		else if (ecb->xs->flags & SCSI_URGENT)
			tag = MSG_HEAD_OF_Q_TAG;
@


1.41
log
@Move IS[12]BYTEMSG and ISEXTMSG defines to a common place.
Pointed out by miod@@. krw@@ miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.40 2008/11/24 00:31:35 krw Exp $	*/
d814 1
a814 1
			return (TRY_AGAIN_LATER);
@


1.40
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.39 2008/09/10 14:01:22 blambert Exp $	*/
a1414 4

#define IS1BYTEMSG(m) (((m) != 1 && (m) < 0x20) || (m) & 0x80)
#define IS2BYTEMSG(m) (((m) & 0xf0) == 0x20)
#define ISEXTMSG(m) ((m) == 1)
@


1.39
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.38 2008/08/31 17:21:57 miod Exp $	*/
d827 1
a827 1
		return (TRY_AGAIN_LATER);
@


1.38
log
@Fix redundant device name and/or target printing after calling
sc_print_addr(); ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.37 2008/05/27 09:43:26 kettenis Exp $	*/
d2849 1
a2849 1
	timeout_add(&sc->sc_watchdog, 60*hz);
@


1.37
log
@Don't print SCSI ID, it's redundant now that scsibus(4) prints the same
information.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.36 2007/11/05 22:30:25 krw Exp $	*/
d2782 1
a2782 1
	printf("%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], "
a2784 1
		sc->sc_dev.dv_xname,
@


1.36
log
@More scsi_done() at SPLBIO. Wrap more interrupt function calls while
polling in splbio/splx. Put belts and suspenders splbio/splx around
the scsi_done() call since it may be possible to get there other ways.

Partly from thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.35 2007/10/15 01:37:49 fgsch Exp $	*/
d223 2
a224 2
	printf(": %s, %dMHz, SCSI ID %d\n",
	    ncr53c9x_variant_names[sc->sc_rev], sc->sc_freq, sc->sc_id);
@


1.35
log
@more remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.34 2007/08/06 08:28:09 tom Exp $	*/
d875 1
d880 1
d882 1
d885 2
a886 1
		if (NCR_READ_REG(sc, NCR_STAT) & NCRSTAT_INT)
d888 2
d1094 1
a1094 1
	int lun = sc_link->lun;
d1172 1
d1174 1
@


1.34
log
@Fix some "that that"s.

ok miod@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.33 2006/11/28 23:59:45 dlg Exp $	*/
a2605 1
			size_t size;
@


1.33
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.32 2006/06/26 22:16:23 miod Exp $	*/
d200 1
a200 1
	 * handling in the DMA engines. Note that that ncr53c9x_msgout()
@


1.32
log
@Enable wide targets on FAS366 esp; note that this changes the way esp
user-controllable device flags are parsed, be sure to rerun config(8) on your
next kernel compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.31 2006/05/23 20:35:12 miod Exp $	*/
d194 2
d273 3
d279 1
a279 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
@


1.31
log
@In NCR53C9X_DEBUG code, compute debug values after the values they depend on
have been computed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.30 2006/03/05 21:48:56 miod Exp $	*/
d246 10
d269 1
d397 1
a397 1
		for (r = 0; r < NCR_NTARG; r++) {
d408 1
a408 1
		for (r = 0; r < 8; r++) {
d421 1
a421 1
				for (i = 0; i<256; i++)
d438 1
a438 1
	for (r = 0; r < 8; r++) {
d442 3
a444 3
                ti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))
		    ? 0 : T_SYNCHOFF) |
		    ((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |
d2803 1
a2803 1
			sc->sc_cfflags |= (1<<(sc_link->target+8));
d2822 1
a2822 1
	for (t=0; t<NCR_NTARG; t++) {
@


1.30
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.29 2006/01/09 23:11:49 miod Exp $	*/
d91 1
d93 1
d1641 3
a1643 2
					int r = 250/ti->period;
					int s = (100*250)/ti->period - 100*r;
d1650 2
@


1.29
log
@Delay a bit after sending a reset command if the chip is an 53C94 or a 53C96;
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.28 2006/01/09 23:09:41 brad Exp $	*/
d909 1
a909 1
	for (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {
d2145 2
a2146 2
			li = ti->luns.lh_first;
			while (li) {
d2153 1
a2153 1
					li = ti->luns.lh_first;
d2156 1
a2156 1
				li = li->link.le_next;
d2808 1
a2808 2
		li = ti->luns.lh_first;
		while (li) {
d2815 1
a2815 1
				li = ti->luns.lh_first;
d2818 1
a2818 1
			li = li->link.le_next;
@


1.28
log
@NCRDMA_SETUP() should be called before NCR_SET_COUNT() and NCRCMD_DMA command
in ncr53c9x_select().

From tsutsui NetBSD

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.27 2006/01/04 22:22:09 brad Exp $	*/
d445 14
@


1.27
log
@Return from interrupt handler after chip init(reset).

From petrov NetBSD

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.26 2006/01/04 20:49:32 miod Exp $	*/
d618 2
a627 1
			NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);
d675 1
a689 1
		NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);
@


1.26
log
@People doing time comparisons without using the time{r,spec}cmp macros are
doomed to do them incorrectly; ok krw@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.25 2004/10/28 08:11:09 xsa Exp $	*/
d2037 1
@


1.25
log
@add \n in 'invalid state' message; from Martin Reindl; ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.24 2004/09/29 19:17:43 miod Exp $	*/
d2682 1
a2682 2
		} while (cur.tv_sec <= wait.tv_sec &&
		    cur.tv_usec <= wait.tv_usec);
@


1.24
log
@Ratibibugle now useless evcnt structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.23 2004/06/21 23:50:35 tholo Exp $	*/
d2498 1
a2498 1
		printf("%s: invalid state: %d",
@


1.23
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.22 2004/01/15 17:51:42 miod Exp $	*/
a1930 2

	sc->sc_intrcnt.ev_count++;
@


1.22
log
@Provide explicit function argument declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.21 2003/10/21 18:58:49 jmc Exp $	*/
d784 1
a784 1
		li->last_used = time.tv_sec;
d930 1
a930 1
		li->last_used = time.tv_sec;
d2790 1
a2790 1
	time_t old = time.tv_sec - (10*60);
@


1.21
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.20 2003/07/25 03:35:13 jason Exp $	*/
d1293 2
@


1.20
log
@cast and %lu for size_t variable printf
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.19 2003/06/05 12:27:02 deraadt Exp $	*/
d152 1
a152 1
 * Names for the NCR53c9x variants, correspnding to the variant tags
d872 1
a872 1
 * This may save us an unecessary interrupt just to get things going.
d1685 1
a1685 1
		 * IDENTIFY message was recived and queue tag is expected now
@


1.19
log
@3/4 knockout for peter galbavy
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.18 2003/02/11 19:20:27 mickey Exp $	*/
d1101 1
a1101 1
			printf("resid=%d ", xs->resid);
@


1.18
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.17 2002/10/25 17:44:52 fgsch Exp $	*/
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Peter Galbavy
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.17
log
@remove dead code; krw@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.15 2002/09/04 22:08:06 fgsch Exp $	*/
d2671 2
a2672 2
	 * The delay is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1
	 * at 40Mhz. This needs testing.
@


1.16
log
@Remove trailing '\n's from panic messages.

Started by a commit to siop from provos@@netbsd.org.

ok miod@@ millert@@
@
text
@a783 2
		int wait = M_NOWAIT;

a784 2
		if ((curproc != NULL) && ((flags & SCSI_NOSLEEP) == 0))
			wait = M_WAITOK;
a922 3
			int wait = M_NOWAIT;
			int flags = ecb->flags;

a923 2
			if ((curproc != NULL) && ((flags & SCSI_NOSLEEP) == 0))
				wait = M_WAITOK;
@


1.15
log
@don't dereference ecb on default case, it's uninitialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.13 2002/02/19 04:40:54 jason Exp $	*/
d987 1
a987 1
				panic("ncr53c9x_sched: tag alloc failure\n");
d1163 1
a1163 1
		panic("ncr53c9x_dequeue: lun %qx for ecb %p does not exist\n",
d1174 1
a1174 1
			    "instead of ecb %p\n", ecb->tag[1],
d1232 1
a1232 1
		panic("ncr53c9x_rdfifo: bad flag\n");
@


1.14
log
@First round of __P removal in sys
@
text
@a1728 1
		sc_print_addr(ecb->xs->sc_link);
@


1.13
log
@From NetBSD:
Fix timeout overflow caused by "scsictl format" on machines HZ==100.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.12 2002/01/23 00:39:47 art Exp $	*/
d101 30
a130 30
/*static*/ void	ncr53c9x_readregs	__P((struct ncr53c9x_softc *));
/*static*/ void	ncr53c9x_select		__P((struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *));
/*static*/ int ncr53c9x_reselect	__P((struct ncr53c9x_softc *, int, int, int));
/*static*/ void	ncr53c9x_scsi_reset	__P((struct ncr53c9x_softc *));
/*static*/ int	ncr53c9x_poll		__P((struct ncr53c9x_softc *,
					    struct scsi_xfer *, int));
/*static*/ void	ncr53c9x_sched		__P((struct ncr53c9x_softc *));
/*static*/ void	ncr53c9x_done		__P((struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *));
/*static*/ void	ncr53c9x_msgin		__P((struct ncr53c9x_softc *));
/*static*/ void	ncr53c9x_msgout		__P((struct ncr53c9x_softc *));
/*static*/ void	ncr53c9x_timeout	__P((void *arg));
/*static*/ void ncr53c9x_watch		__P((void *arg));
/*static*/ void	ncr53c9x_abort		__P((struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *));
/*static*/ void ncr53c9x_dequeue	__P((struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *));

void ncr53c9x_sense			__P((struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *));
void ncr53c9x_free_ecb			__P((struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *, int));
struct ncr53c9x_ecb *ncr53c9x_get_ecb	__P((struct ncr53c9x_softc *, int));

static inline int ncr53c9x_stp2cpb	__P((struct ncr53c9x_softc *, int));
static inline void ncr53c9x_setsync	__P((struct ncr53c9x_softc *,
					    struct ncr53c9x_tinfo *));
static struct ncr53c9x_linfo *ncr53c9x_lunsearch __P((struct ncr53c9x_tinfo *,
    int64_t lun));
@


1.12
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.11 2001/12/17 23:13:41 nordin Exp $	*/
d592 1
a592 1
		if (hz > 100 && timeout > 1000)
d2726 1
a2726 1
		if (hz > 100 && timeout > 1000)
@


1.11
log
@Initialize variable before use. ok fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.10 2001/09/27 04:01:42 jason Exp $	*/
d379 1
a379 1
		    "ncr53c9x_ecb", 0, NULL, NULL, 0);
@


1.11.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.12 2002/01/23 00:39:47 art Exp $	*/
d379 1
a379 1
		    "ncr53c9x_ecb", NULL);
@


1.11.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.11.2.1 2002/01/31 22:55:31 niklas Exp $	*/
d101 30
a130 30
/*static*/ void	ncr53c9x_readregs(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_select(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
/*static*/ int ncr53c9x_reselect(struct ncr53c9x_softc *, int, int, int);
/*static*/ void	ncr53c9x_scsi_reset(struct ncr53c9x_softc *);
/*static*/ int	ncr53c9x_poll(struct ncr53c9x_softc *,
					    struct scsi_xfer *, int);
/*static*/ void	ncr53c9x_sched(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_done(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
/*static*/ void	ncr53c9x_msgin(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_msgout(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_timeout(void *arg);
/*static*/ void ncr53c9x_watch(void *arg);
/*static*/ void	ncr53c9x_abort(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
/*static*/ void ncr53c9x_dequeue(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);

void ncr53c9x_sense(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
void ncr53c9x_free_ecb(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *, int);
struct ncr53c9x_ecb *ncr53c9x_get_ecb(struct ncr53c9x_softc *, int);

static inline int ncr53c9x_stp2cpb(struct ncr53c9x_softc *, int);
static inline void ncr53c9x_setsync(struct ncr53c9x_softc *,
					    struct ncr53c9x_tinfo *);
static struct ncr53c9x_linfo *ncr53c9x_lunsearch(struct ncr53c9x_tinfo *,
    int64_t lun);
d592 1
a592 1
		if (timeout > 1000000)
d2726 1
a2726 1
		if (timeout > 1000000)
@


1.11.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.11.2.2 2002/06/11 03:42:19 art Exp $	*/
d784 2
d787 2
d927 3
d931 2
d987 1
a987 1
				panic("ncr53c9x_sched: tag alloc failure");
d1163 1
a1163 1
		panic("ncr53c9x_dequeue: lun %qx for ecb %p does not exist",
d1174 1
a1174 1
			    "instead of ecb %p", ecb->tag[1],
d1232 1
a1232 1
		panic("ncr53c9x_rdfifo: bad flag");
d1729 1
@


1.11.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2671 2
a2672 2
	 * The delay is a heuristic. It is 2 when at 20MHz, 2 at 25MHz and 1
	 * at 40MHz. This needs testing.
@


1.10
log
@Huge merge with NetBSD.  For full details look at their revision history (1.26 -> 1.83)...
Highlights:
o tag queue support
o fas366 support (doesn't work yet on sparc, but does on sparc64)
o tons more
(thanks to hugh, fgsch and beck for testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.9 2000/07/21 11:20:35 art Exp $	*/
d2714 1
a2714 1
		int timeout;
@


1.9
log
@Use new timeouts.
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr53c9x.c,v 1.8 2000/06/17 18:03:11 fgsch Exp $	*/
/*	$NetBSD: ncr53c9x.c,v 1.26 1998/05/26 23:17:34 thorpej Exp $	*/
d85 1
d97 3
d104 1
a104 1
/*static*/ int ncr53c9x_reselect	__P((struct ncr53c9x_softc *, int));
a105 1
/*static*/ void	ncr53c9x_init		__P((struct ncr53c9x_softc *, int));
d114 1
d129 22
d170 1
d174 15
d197 1
a197 1

d267 1
d271 2
a272 2
 * This is the generic esp reset function. It does not reset the SCSI bus,
 * only this controllers, but kills any on-going commands, and also stops
d305 1
d313 13
d337 9
d363 1
a363 1
 * Initialize esp state machine
d371 2
a372 1
	int r;
d374 8
a381 1
	NCR_TRACE(("[NCR_INIT(%d)] ", doreset));
d385 1
a386 2
		TAILQ_INIT(&sc->nexus_list);
		TAILQ_INIT(&sc->free_list);
d388 3
a390 6
		ecb = sc->sc_ecb;
		bzero(ecb, sizeof(sc->sc_ecb));
		for (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {
			timeout_set(&ecb->to, ncr53c9x_timeout, ecb);
			TAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);
			ecb++;
a391 1
		bzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));
d395 1
d400 21
a420 3
		while ((ecb = sc->nexus_list.tqh_first) != NULL) {
			ecb->xs->error = XS_TIMEOUT;
			ncr53c9x_done(sc, ecb);
d434 8
a441 4
		ti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))
				? T_NEGOTIATE : 0) |
				((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |
				T_NEED_TO_RESET;
d444 1
d473 4
d491 2
a492 2
	NCR_MISC(("regs[intr=%02x,stat=%02x,step=%02x] ",
		sc->sc_espintr, sc->sc_espstat, sc->sc_espstep));
d516 2
a517 1
	u_char syncoff, synctp, cfg3 = sc->sc_cfg3;
d535 2
a536 1
				cfg3 |= sc->sc_cfg3_fscsi;
a557 1
int ncr53c9x_dmaselect = 0;
d577 1
d580 2
a581 2
	NCR_TRACE(("[ncr53c9x_select(t%d,l%d,cmd:%x)] ",
		   target, lun, ecb->cmd.cmd.opcode));
a583 1

d589 9
a597 2
	if ((ecb->xs->flags & SCSI_POLL) == 0)
		timeout_add(&ecb->to, (ecb->timeout * hz) / 1000);
d603 6
a608 1
	NCR_WRITE_REG(sc, NCR_SELID, target);
d611 1
a611 1
	if (ecb->flags & ECB_SENSE) {
d617 1
a617 1
		if (ncr53c9x_dmaselect) {
d621 1
a621 3
			sc->sc_cmdp = (caddr_t)&ecb->cmd + 1;
			NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0,
			    &dmasize);
d624 1
a624 5
			NCR_WRITE_REG(sc, NCR_TCL, dmasize);
			NCR_WRITE_REG(sc, NCR_TCM, dmasize >> 8);
			if (sc->sc_cfg2 & NCRCFG2_FE) {
				NCR_WRITE_REG(sc, NCR_TCH, dmasize >> 16);
			}
d626 2
a627 2
			/* load the count in */
			NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);
d631 1
d634 1
a634 6
			/* Now the command into the FIFO */
			cmd = (u_char *)&ecb->cmd.cmd;
			clen = ecb->clen;
			while (clen--)
				NCR_WRITE_REG(sc, NCR_FIFO, *cmd++);

d640 33
a672 3
	if (ncr53c9x_dmaselect && (tiflags & T_NEGOTIATE) == 0) {
		ecb->cmd.id = 
		    MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1);
d675 1
a675 1
		dmasize = clen = ecb->clen + 1;
d677 1
a677 2
		sc->sc_cmdp = (caddr_t)&ecb->cmd;
		NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);
d680 1
a680 5
		NCR_WRITE_REG(sc, NCR_TCL, dmasize);
		NCR_WRITE_REG(sc, NCR_TCM, dmasize >> 8);
		if (sc->sc_cfg2 & NCRCFG2_FE) {
			NCR_WRITE_REG(sc, NCR_TCH, dmasize >> 16);
		}
d683 2
a684 1
		NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);
d687 7
a693 1
		NCRCMD(sc, NCRCMD_SELATN | NCRCMD_DMA);
a701 2
	NCR_WRITE_REG(sc, NCR_FIFO,
			MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1));
d703 6
a708 1
	if (ti->flags & T_NEGOTIATE) {
d711 6
a716 11
		return;
	}

	/* Now the command into the FIFO */
	cmd = (u_char *)&ecb->cmd.cmd;
	clen = ecb->clen;
	while (clen--)
		NCR_WRITE_REG(sc, NCR_FIFO, *cmd++);

	/* And get the targets attention */
	NCRCMD(sc, NCRCMD_SELATN);
a727 1

d729 1
a729 9
	TAILQ_INSERT_HEAD(&sc->free_list, ecb, chain);

	/*
	 * If there were none, wake anybody waiting for one to come free,
	 * starting with queued entries.
	 */
	if (ecb->chain.tqe_next == 0)
		wakeup(&sc->free_list);

d739 4
a742 1
	int s;
d745 1
a745 9

	while ((ecb = sc->free_list.tqh_first) == NULL &&
	       (flags & SCSI_NOSLEEP) == 0)
		tsleep(&sc->free_list, PRIBIO, "especb", 0);
	if (ecb) {
		TAILQ_REMOVE(&sc->free_list, ecb, chain);
		ecb->flags |= ECB_ALLOC;
	}

d747 5
d771 3
d781 21
d824 1
d891 3
d906 101
a1006 1
		if ((ti->lubusy & (1 << sc_link->lun)) == 0) {
d1008 1
d1028 2
d1043 5
a1047 2
	if (ecb->flags & ECB_NEXUS)
		ti->lubusy &= ~(1 << sc_link->lun);
a1048 1
		ecb->flags &= ~ECB_NEXUS;
a1050 1
		ncr53c9x_dequeue(sc, ecb);
d1052 1
d1069 2
d1076 10
d1126 1
a1126 2
	if (ecb->flags & ECB_NEXUS)
		ti->lubusy &= ~(1 << sc_link->lun);
d1133 12
a1144 3
	} else
		ncr53c9x_dequeue(sc, ecb);
		
d1155 25
d1181 3
a1183 4
	if (ecb->flags & ECB_NEXUS) {
		TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
		ecb->flags &= ~ECB_NEXUS;
	} else {
d1186 1
a1186 1
}
d1199 1
a1199 1
		NCR_MISC(("ncr53c9x_sched_msgout %d ", m));	\
d1205 98
d1304 1
a1304 1
ncr53c9x_reselect(sc, message)
d1309 1
a1309 2
	struct ncr53c9x_ecb *ecb;
	struct scsi_link *sc_link;
d1311 1
d1313 16
a1328 10
	/*
	 * The SCSI chip made a snapshot of the data bus while the reselection
	 * was being negotiated.  This enables us to determine which target did
	 * the reselect.
	 */
	selid = sc->sc_selid & ~(1 << sc->sc_id);
	if (selid & (selid - 1)) {
		printf("%s: reselect with invalid selid %02x;"
		    " sending DEVICE RESET\n", sc->sc_dev.dv_xname, selid);
		goto reset;
d1330 1
d1338 17
a1354 8
	target = ffs(selid) - 1;
	lun = message & 0x07;
	for (ecb = sc->nexus_list.tqh_first; ecb != NULL;
	     ecb = ecb->chain.tqe_next) {
		sc_link = ecb->xs->sc_link;
		if (sc_link->target == target &&
		    sc_link->lun == lun)
			break;
d1357 2
a1358 2
		printf("%s: reselect from target %d lun %d with no nexus;"
		    " sending ABORT\n", sc->sc_dev.dv_xname, target, lun);
a1362 1
	TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
a1364 8
	ti = &sc->sc_tinfo[target];
#ifdef NCR53C9X_DEBUG
	if ((ti->lubusy & (1 << lun)) == 0) {
		printf("%s: reselect: target %d, lun %d: should be busy\n",
			sc->sc_dev.dv_xname, target, lun);
		ti->lubusy |= (1 << lun);
	}
#endif
d1391 15
d1414 1
a1414 1
	register struct ncr53c9x_softc *sc;
a1415 1
	register int v;
d1419 2
a1420 3
	if ((NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) == 0) {
		printf("%s: msgin: no msg byte available\n",
			sc->sc_dev.dv_xname);
d1430 3
a1432 1
	if (sc->sc_prevphase != MESSAGE_IN_PHASE) {
d1437 1
a1437 15
	v = NCR_READ_REG(sc, NCR_FIFO);
	NCR_MISC(("<msgbyte:0x%02x>", v));

#if 0
	if (sc->sc_state == NCR_RESELECTED && sc->sc_imlen == 0) {
		/*
		 * Which target is reselecting us? (The ID bit really)
		 */
		sc->sc_selid = v;
		NCR_MISC(("selid=0x%2x ", sc->sc_selid));
		return;
	}
#endif

	sc->sc_imess[sc->sc_imlen] = v;
a1442 1

d1454 19
a1472 13
		sc->sc_imlen++;
		/*
		 * This testing is suboptimal, but most
		 * messages will be of the one byte variety, so
		 * it should not effect performance
		 * significantly.
		 */
		if (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))
			goto gotit;
		if (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))
			goto gotit;
		if (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&
		    sc->sc_imlen == sc->sc_imess[1] + 2)
d1475 1
d1481 4
a1484 1
	NCR_MSGS(("gotmsg(%x)", sc->sc_imess[0]));
d1494 2
d1505 3
a1507 4
				struct scsi_link *sc_link = ecb->xs->sc_link;
				printf("%s: %ld extra bytes from %d:%d\n",
				    sc->sc_dev.dv_xname, -(long)sc->sc_dleft,
				    sc_link->target, sc_link->lun);
d1521 25
d1547 2
d1553 8
d1570 6
d1618 4
a1621 2
					printf("%s:%d: async\n", "esp",
						ecb->xs->sc_link->target);
d1644 1
a1644 1
					printf("max sync rate %d.%02dMb/s\n",
d1669 10
d1680 3
a1682 2
				printf("%s: unrecognized MESSAGE EXTENDED;"
				    " sending REJECT\n", sc->sc_dev.dv_xname);
d1689 2
a1690 2
			printf("%s: unrecognized MESSAGE; sending REJECT\n",
			    sc->sc_dev.dv_xname);
d1697 17
d1715 3
a1717 1
		if (!MSG_ISIDENTIFY(sc->sc_imess[0])) {
d1719 4
a1722 1
			    " sending DEVICE RESET\n", sc->sc_dev.dv_xname);
d1725 1
a1725 2

		(void) ncr53c9x_reselect(sc, sc->sc_imess[0]);
d1729 1
d1741 4
d1759 1
a1759 1
	register struct ncr53c9x_softc *sc;
d1779 1
a1779 1
			DELAY(1);
d1814 9
d1832 10
d1848 3
a1850 1
			ti->flags |= T_NEGOTIATE;
d1886 27
a1912 13
	/* (re)send the message */
	size = min(sc->sc_omlen, sc->sc_maxxfer);
	NCRDMA_SETUP(sc, &sc->sc_omp, &sc->sc_omlen, 0, &size);
	/* Program the SCSI counter */
	NCR_WRITE_REG(sc, NCR_TCL, size);
	NCR_WRITE_REG(sc, NCR_TCM, size >> 8);
	if (sc->sc_cfg2 & NCRCFG2_FE) {
		NCR_WRITE_REG(sc, NCR_TCH, size >> 16);
	}
	/* Load the count in and start the message-out transfer */
	NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);
	NCRCMD(sc, NCRCMD_TRANS|NCRCMD_DMA);
	NCRDMA_GO(sc);
d1929 3
a1931 3
	register struct ncr53c9x_softc *sc = arg;
	register struct ncr53c9x_ecb *ecb;
	register struct scsi_link *sc_link;
d1936 1
a1936 1
	NCR_TRACE(("[ncr53c9x_intr] "));
d2079 1
a2079 1
				       " prevphase %x, resid %x\n",
d2085 1
a2085 1
					sc->sc_omlen);
d2118 1
d2123 1
a2123 1
			DELAY(1);
d2136 3
d2140 17
d2158 1
a2158 1

a2197 1
			TAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);
d2236 20
a2257 2
		sc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;
		sc->sc_flags = 0;
a2258 5
		if (ecb != NULL && (ecb->flags & ECB_NEXUS)) {
			sc_print_addr(ecb->xs->sc_link);
			printf("ECB_NEXUS while in state %x\n", sc->sc_state);
		}

d2260 2
d2270 1
a2270 2
				sc_link = ecb->xs->sc_link;
				ti = &sc->sc_tinfo[sc_link->target];
d2272 1
d2296 2
a2297 1
			nfifo = NCR_READ_REG(sc,NCR_FFLAG) & NCRFIFO_FF;
d2313 2
a2314 2
			sc->sc_selid = NCR_READ_REG(sc, NCR_FIFO);
			NCR_MISC(("selid=0x%2x ", sc->sc_selid));
d2325 1
a2325 1
			} else if (ncr53c9x_dmaselect &&
d2330 2
a2331 1
			if (sc->sc_state != NCR_CONNECTED) {
d2333 3
a2335 2
				printf("%s: identify failed\n",
					sc->sc_dev.dv_xname);
d2350 1
a2350 1
				panic("esp: no nexus");
d2369 2
a2370 1
				if ((ti->flags & T_NEGOTIATE) == 0) {
d2380 17
a2396 5
				/* Start negotiating */
				ti->period = sc->sc_minsync;
				ti->offset = 15;
				sc->sc_flags |= NCR_SYNCHNEGO;
				ncr53c9x_sched_msgout(SEND_SDTR);
d2407 1
a2407 1
				if (ncr53c9x_dmaselect) {
d2434 1
a2434 1
				if (ncr53c9x_dmaselect &&
d2437 1
a2437 1
					       "%d left in DMA buffer "
d2442 1
a2442 1
						sc->sc_cmdlen,
a2449 3
			ecb->flags |= ECB_NEXUS;
			ti->lubusy |= (1 << sc_link->lun);

d2489 6
a2494 10
			if ((NCR_READ_REG(sc, NCR_FFLAG)
			    & NCRFIFO_FF) != 2) {
				/* Drop excess bytes from the queue */
				int i = (NCR_READ_REG(sc, NCR_FFLAG)
					    & NCRFIFO_FF) - 2;
				while (i-- > 0)
					(void) NCR_READ_REG(sc, NCR_FIFO);
			}
			ecb->stat = NCR_READ_REG(sc, NCR_FIFO);
			msg = NCR_READ_REG(sc, NCR_FIFO);
d2506 1
d2512 2
a2513 1
		panic("%s: invalid state: %d",
d2516 3
d2526 1
a2526 1
		panic("esp no nexus");
d2536 1
a2537 1
		sc->sc_prevphase = MESSAGE_IN_PHASE;
d2539 4
a2542 1
			NCRCMD(sc, NCRCMD_FLUSH);
d2554 3
d2565 1
d2581 1
a2581 1
			DELAY(1);
d2583 1
a2583 1
		if (ncr53c9x_dmaselect) {
d2592 1
a2592 5
			NCR_WRITE_REG(sc, NCR_TCL, size);
			NCR_WRITE_REG(sc, NCR_TCM, size >> 8);
			if (sc->sc_cfg2 & NCRCFG2_FE) {
				NCR_WRITE_REG(sc, NCR_TCH, size >> 16);
			}
d2601 1
a2601 5
			u_char *cmd = (u_char *)&ecb->cmd.cmd;
			int i;
			/* Now the command into the FIFO */
			for (i = 0; i < ecb->clen; i++)
				NCR_WRITE_REG(sc, NCR_FIFO, *cmd++);
d2627 2
a2628 5
		NCR_WRITE_REG(sc, NCR_TCL, size);
		NCR_WRITE_REG(sc, NCR_TCM, size >> 8);
		if (sc->sc_cfg2 & NCRCFG2_FE) {
			NCR_WRITE_REG(sc, NCR_TCH, size >> 16);
		}
d2684 16
a2699 3
	DELAY(50/sc->sc_freq);
	if (NCRDMA_ISINTR(sc))
		goto again;
d2714 2
d2726 5
a2730 1
		timeout_add(&ecb->to, (ecb->timeout * hz) / 1000);
a2731 6
		/* The command should be on the nexus list */
		if ((ecb->flags & ECB_NEXUS) == 0) {
			sc_print_addr(ecb->xs->sc_link);
			printf("ncr53c9x_abort: not NEXUS\n");
			ncr53c9x_init(sc, 1);
		}
d2733 1
a2733 1
		 * Just leave the command on the nexus list.
d2792 32
@


1.8
log
@Add support for AMD 53c974.
>From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.7 2000/06/12 06:10:45 fgsch Exp $	*/
d318 1
d492 1
a492 2
		timeout(ncr53c9x_timeout, ecb,
		    (ecb->timeout * hz) / 1000);
d818 1
a818 1
	untimeout(ncr53c9x_timeout, ecb);
d1639 1
a1639 1
				untimeout(ncr53c9x_timeout, ecb);
d1705 1
a1705 1
				untimeout(ncr53c9x_timeout, ecb);
d2135 1
a2135 3
		 * Reschedule timeout. First, cancel a queued timeout (if any)
		 * in case someone decides to call ncr53c9x_abort() from
		 * elsewhere.
d2137 1
a2137 2
		untimeout(ncr53c9x_timeout, ecb);
		timeout(ncr53c9x_timeout, ecb, (ecb->timeout * hz) / 1000);
@


1.7
log
@move cfdriver to ncr53c9x.c and device declaration to conf/files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.6 1998/05/28 22:07:52 jason Exp $	*/
d143 1
a224 12

	/*
	 * Enable interupts from the SCSI core
	 */
	if ((sc->sc_rev == NCR_VARIANT_ESP406) ||
	    (sc->sc_rev == NCR_VARIANT_FAS408)) {
		NCR_PIOREGS(sc);
		NCR_WRITE_REG(sc, NCR_CFG5, NCRCFG5_SINT |
		    NCR_READ_REG(sc, NCR_CFG5));
		NCR_SCSIREGS(sc);
	}

d252 3
a254 1
		NCR_SCSIREGS(sc);
d277 3
d429 8
a436 1
				cfg3 |= NCRCFG3_FSCSI;
d438 8
d478 1
d501 39
a540 2
		size_t dmasize;

d1397 2
a1398 2
ncr53c9x_intr(sc)
	register struct ncr53c9x_softc *sc;
d1400 1
d1413 1
a1413 1
	/* and what do the registers day... */
d1419 1
d1476 1
a1476 1
				return (1);
d1662 1
a1662 1
			return (1);
d1745 1
a1745 1
					ncr53c9x_init(sc, 1);
d1833 2
a1834 2
						/* Hope for the best.. */
						break;
d1852 1
d1914 1
d1917 1
a1917 1
				while (i--)
d2074 1
@


1.6
log
@Sync with NetBSD:
Allocate SCSI message buffers in ncr53c9x_attach(), with a provision
for front-ends to override the allocation to avoid alignment
handling in their DMA engines. Note that that ncr53c9x_msgout()
can request a 1 byte DMA transfer that would be difficult to break up.

Eliminate the degenerate loop in `ncr53c9x_intr()'. Retain the delay heuristic
it implemented under the label `shortcut:' and only use it in these cases:
  (1) after successful re-relection,
  (2) after receiving command-complete status, and
  (3) during message-in handshake.

If we have an NCR53CF9x (indicated by the front-end by setting a flag
in the softc's new "features" word), set FSCSI bit in CFG3 if the sync
period is <= 200ns, or clear it otherwise.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.5 1998/04/30 01:43:46 jason Exp $	*/
d125 4
@


1.6.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.9 2000/07/21 11:20:35 art Exp $	*/
a125 4
struct cfdriver esp_cd = {
	NULL, "esp", DV_DULL
};

a138 1
	"AM53C974",
d220 12
d259 1
a259 3
		NCR_WRITE_REG(sc, NCR_CFG5, sc->sc_cfg5 | NCRCFG5_SINT);
		NCR_WRITE_REG(sc, NCR_CFG4, sc->sc_cfg4);
	case NCR_VARIANT_AM53C974:
a281 3

	if (sc->sc_rev == NCR_VARIANT_AM53C974)
		NCR_WRITE_REG(sc, NCR_AMDCFG4, sc->sc_cfg4);
a319 1
			timeout_set(&ecb->to, ncr53c9x_timeout, ecb);
d431 1
a431 8
				/*
				 * There are (at least) 4 variations of the
				 * configuration 3 register.  The drive attach
				 * routine sets the appropriate bit to put the
				 * chip into Fast SCSI mode so that it doesn't
				 * have to be figured out here each time.
				 */
				cfg3 |= sc->sc_cfg3_fscsi;
a432 8

		/*
		 * Am53c974 requires different SYNCTP values when the
		 * FSCSI bit is off.
		 */
		if (sc->sc_rev == NCR_VARIANT_AM53C974 &&
		    (cfg3 & NCRAMDCFG3_FSCSI) == 0)
			synctp--;
a464 1
	size_t dmasize;
d477 2
a478 1
		timeout_add(&ecb->to, (ecb->timeout * hz) / 1000);
d487 2
a488 20
	if (ecb->flags & ECB_SENSE) {
		/*
		 * For REQUEST SENSE, we should not send an IDENTIFY or
		 * otherwise mangle the target.  There should be no MESSAGE IN
		 * phase.
		 */
		if (ncr53c9x_dmaselect) {
			/* setup DMA transfer for command */
			dmasize = clen = ecb->clen;
			sc->sc_cmdlen = clen;
			sc->sc_cmdp = (caddr_t)&ecb->cmd + 1;
			NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0,
			    &dmasize);

			/* Program the SCSI counter */
			NCR_WRITE_REG(sc, NCR_TCL, dmasize);
			NCR_WRITE_REG(sc, NCR_TCM, dmasize >> 8);
			if (sc->sc_cfg2 & NCRCFG2_FE) {
				NCR_WRITE_REG(sc, NCR_TCH, dmasize >> 16);
			}
a489 19
			/* load the count in */
			NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);

			/* And get the targets attention */
			NCRCMD(sc, NCRCMD_SELNATN | NCRCMD_DMA);
			NCRDMA_GO(sc);
		} else {
			/* Now the command into the FIFO */
			cmd = (u_char *)&ecb->cmd.cmd;
			clen = ecb->clen;
			while (clen--)
				NCR_WRITE_REG(sc, NCR_FIFO, *cmd++);

			NCRCMD(sc, NCRCMD_SELNATN);
		}
		return;
	}

	if (ncr53c9x_dmaselect && (tiflags & T_NEGOTIATE) == 0) {
d767 1
a767 1
	timeout_del(&ecb->to);
d1346 2
a1347 2
ncr53c9x_intr(arg)
	void *arg;
a1348 1
	register struct ncr53c9x_softc *sc = arg;
d1361 1
a1361 1
	/* and what do the registers say... */
a1366 1
	 * At the moment, only a SCSI Bus Reset or Illegal
d1423 1
a1423 1
			return (1);
d1586 1
a1586 1
				timeout_del(&ecb->to);
d1609 1
a1609 1
		return (1);
d1652 1
a1652 1
				timeout_del(&ecb->to);
d1692 1
a1692 1
				ncr53c9x_init(sc, 1);
d1780 2
a1781 2
					/* Hope for the best.. */
					break;
a1798 1
				break;
a1859 1
				/* Drop excess bytes from the queue */
d1862 1
a1862 1
				while (i-- > 0)
a2018 1
		goto shortcut;	/* i.e. expect status results soon */
d2079 3
a2081 1
		 * Reschedule timeout.
d2083 2
a2084 1
		timeout_add(&ecb->to, (ecb->timeout * hz) / 1000);
@


1.6.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr53c9x.c,v 1.6.8.1 2001/05/14 22:24:01 niklas Exp $	*/
/*     $NetBSD: ncr53c9x.c,v 1.56 2000/11/30 14:41:46 thorpej Exp $    */
a84 1
#include <sys/pool.h>
a95 3
#ifdef DEBUG
int ncr53c9x_notag = 0;
#endif
d100 1
a100 1
/*static*/ int ncr53c9x_reselect	__P((struct ncr53c9x_softc *, int, int, int));
d102 1
a110 1
/*static*/ void ncr53c9x_watch		__P((void *arg));
a124 22
static struct ncr53c9x_linfo *ncr53c9x_lunsearch __P((struct ncr53c9x_tinfo *,
    int64_t lun));

static void ncr53c9x_wrfifo(struct ncr53c9x_softc *, u_char *, int);
static int ncr53c9x_rdfifo(struct ncr53c9x_softc *, int);
#define NCR_RDFIFO_START	0
#define NCR_RDFIFO_CONTINUE	1

#define NCR_SET_COUNT(sc, size) do {						\
			NCR_WRITE_REG((sc), NCR_TCL, (size));			\
			NCR_WRITE_REG((sc), NCR_TCM, (size) >> 8);		\
			if ((sc->sc_cfg2 & NCRCFG2_FE) ||			\
			    (sc->sc_rev == NCR_VARIANT_FAS366)) {		\
				NCR_WRITE_REG((sc), NCR_TCH, (size) >> 16);	\
			}							\
			if (sc->sc_rev == NCR_VARIANT_FAS366) {			\
				NCR_WRITE_REG(sc, NCR_RCH, 0);			\
			}							\
} while (0)

static int ecb_pool_initialized = 0;
static struct pool ecb_pool;
a143 1
	"FAS366/HME",
a146 15
 * Search linked list for LUN info by LUN id.
 */
static struct ncr53c9x_linfo *
ncr53c9x_lunsearch(ti, lun)
	struct ncr53c9x_tinfo *ti;
	int64_t lun;
{
	struct ncr53c9x_linfo *li;
	LIST_FOREACH(li, &ti->luns, link)
	    if (li->lun == lun)
		    return (li);
	return (NULL);
}

/*
d155 1
a155 1
	timeout_set(&sc->sc_watchdog, ncr53c9x_watch, sc);
a224 1
	timeout_add(&sc->sc_watchdog, 60*hz);
d228 2
a229 2
 * This is the generic ncr53c9x reset function. It does not reset the SCSI bus,
 * only this controller, but kills any on-going commands, and also stops
a261 1
		sc->sc_features |= NCR_F_SELATN3;
a268 13
	case NCR_VARIANT_FAS366:
		sc->sc_features |=
		    NCR_F_SELATN3 | NCR_F_HASCFG3 | NCR_F_FASTSCSI;
		sc->sc_cfg3 = NCRFASCFG3_FASTCLK | NCRFASCFG3_OBAUTO;
		sc->sc_cfg3_fscsi = NCRFASCFG3_FASTSCSI;
		NCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);
		sc->sc_cfg2 = 0; /* NCRCFG2_HMEFE | NCRCFG2_HME32 */
		NCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);
		NCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);
		NCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);
		NCR_WRITE_REG(sc, NCR_SYNCOFF, 0);
		NCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);
		break;
a279 9

#if 0
	printf("%s: ncr53c9x_reset: revision %d\n",
	    sc->sc_dev.dv_xname, sc->sc_rev);
	printf("%s: ncr53c9x_reset: cfg1 0x%x, cfg2 0x%x, cfg3 0x%x, ccf 0x%x, timeout 0x%x\n",
	    sc->sc_dev.dv_xname,
	    sc->sc_cfg1, sc->sc_cfg2, sc->sc_cfg3,
	    sc->sc_ccf, sc->sc_timeout);
#endif
d297 1
a297 1
 * Initialize ncr53c9x state machine
d305 1
a305 2
	struct ncr53c9x_linfo *li;
	int r, i;
d307 1
a307 8
	NCR_TRACE(("[NCR_INIT(%d) %d] ", doreset, sc->sc_state));

	if (!ecb_pool_initialized) {
		/* All instances share this pool */
		pool_init(&ecb_pool, sizeof(struct ncr53c9x_ecb), 0, 0, 0,
		    "ncr53c9x_ecb", 0, NULL, NULL, 0);
		ecb_pool_initialized = 1;
	}
a310 1

d312 2
d315 7
a322 3
		for (r = 0; r < NCR_NTARG; r++) {
			LIST_INIT(&sc->sc_tinfo[r].luns);
		}
a325 1
		sc->sc_msgify = 0;
d330 3
a332 21
		for (r = 0; r < 8; r++) {
			LIST_FOREACH(li, &sc->sc_tinfo[r].luns, link) {
				if ((ecb = li->untagged)) {
					li->untagged = NULL;
					/*
					 * XXXXXXX
					 * Should we terminate a command
					 * that never reached the disk?
					 */
					li->busy = 0;
					ecb->xs->error = XS_TIMEOUT;
					ncr53c9x_done(sc, ecb);
				}
				for (i = 0; i<256; i++)
					if ((ecb = li->queued[i])) {
						li->queued[i] = NULL;
						ecb->xs->error = XS_TIMEOUT;
						ncr53c9x_done(sc, ecb);
					}
				li->used = 0;
			}
d346 4
a349 8
                ti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))
		    ? 0 : T_SYNCHOFF) |
		    ((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |
		    T_NEED_TO_RESET;
#ifdef DEBUG
		 if (ncr53c9x_notag)
			 ti->flags &= ~T_TAG;
#endif 
a351 1
		ti->cfg3 = 0;
a379 4

	if (sc->sc_rev == NCR_VARIANT_FAS366)
		sc->sc_espstat2 = NCR_READ_REG(sc, NCR_STAT2);

d394 2
a395 2
	NCR_MISC(("regs[intr=%02x,stat=%02x,step=%02x,stat2=%02x] ",
		sc->sc_espintr, sc->sc_espstat, sc->sc_espstep, sc->sc_espstat2));
d419 1
a419 2
	u_char syncoff, synctp;
	u_char cfg3 = sc->sc_cfg3 | ti->cfg3;
d437 1
a437 2
				cfg3 |= (sc->sc_rev == NCR_VARIANT_AM53C974) ?
				    NCRAMDCFG3_FSCSI : NCRCFG3_FSCSI;
d459 1
a478 1
	int selatn3, selatns;
d481 2
a482 2
	NCR_TRACE(("[ncr53c9x_select(t%d,l%d,cmd:%x,tag%x,%x)] ",
		   target, lun, ecb->cmd.cmd.opcode, ecb->tag[0], ecb->tag[1]));
d485 1
d491 2
a492 9
	if ((ecb->xs->flags & SCSI_POLL) == 0) {
		int timeout = ecb->timeout;

		if (hz > 100 && timeout > 1000)
			timeout = (timeout / 1000) * hz;
		else
			timeout = (timeout * hz) / 1000;
		timeout_add(&ecb->to, timeout);
	}
d498 1
a498 6
	if (sc->sc_rev == NCR_VARIANT_FAS366) {
		NCRCMD(sc, NCRCMD_FLUSH);
		NCR_WRITE_REG(sc, NCR_SELID, target | NCR_BUSID_HME);
	} else {
		NCR_WRITE_REG(sc, NCR_SELID, target);
	}
d501 1
a501 1
	if ((ecb->flags & ECB_SENSE) != 0) {
d507 1
a507 1
		if (sc->sc_features & NCR_F_DMASELECT) {
d511 3
a513 1
			sc->sc_cmdp = (caddr_t)&ecb->cmd.cmd;
d516 5
a520 1
			NCR_SET_COUNT(sc, dmasize);
d522 2
a523 2
			if (sc->sc_rev != NCR_VARIANT_FAS366)
				NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);
a526 1
			NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);
d529 6
a534 1
			ncr53c9x_wrfifo(sc, (u_char *)&ecb->cmd.cmd, ecb->clen);
d540 3
a542 33
	selatn3 = selatns = 0;
	if (ecb->tag[0] != 0) {
		if (sc->sc_features & NCR_F_SELATN3)
			/* use SELATN3 to send tag messages */
			selatn3 = 1;
		else
			/* We don't have SELATN3; use SELATNS to send tags */
			selatns = 1;
	}

	if (ti->flags & T_NEGOTIATE) {
		/* We have to use SELATNS to send sync/wide messages */
		selatn3 = 0;
		selatns = 1;
	}

	cmd = (u_char *)&ecb->cmd.cmd;

	if (selatn3) {
		/* We'll use tags with SELATN3 */
		clen = ecb->clen + 3;
		cmd -= 3;
		cmd[0] = MSG_IDENTIFY(lun, 1);	/* msg[0] */
		cmd[1] = ecb->tag[0];		/* msg[1] */
		cmd[2] = ecb->tag[1];		/* msg[2] */
	} else {
		/* We don't have tags, or will send messages with SELATNS */
		clen = ecb->clen + 1;
		cmd -= 1;
		cmd[0] = MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF) == 0);
	}

	if ((sc->sc_features & NCR_F_DMASELECT) && !selatns) {
d545 1
a545 1
		dmasize = clen;
d547 2
a548 1
		sc->sc_cmdp = cmd;
d551 5
a555 1
		NCR_SET_COUNT(sc, dmasize);
d558 1
a558 2
		/* if (sc->sc_rev != NCR_VARIANT_FAS366) */
			NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);
d561 1
a561 7
		if (selatn3) {
			sc->sc_msgout = SEND_TAG;
			sc->sc_flags |= NCR_ATN;
			NCRCMD(sc, NCRCMD_SELATN3 | NCRCMD_DMA);
		} else
			NCRCMD(sc, NCRCMD_SELATN | NCRCMD_DMA);
		NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);
d570 8
d579 5
a583 2
	/* Now get the command into the FIFO */
	ncr53c9x_wrfifo(sc, cmd, clen);
d586 1
a586 10
	if (selatns) {
		NCR_MISC(("SELATNS \n"));
		/* Arbitrate, select and stop after IDENTIFY message */
		NCRCMD(sc, NCRCMD_SELATNS);
	} else if (selatn3) {
		sc->sc_msgout = SEND_TAG;
		sc->sc_flags |= NCR_ATN;
		NCRCMD(sc, NCRCMD_SELATN3);
	} else
		NCRCMD(sc, NCRCMD_SELATN);
d598 1
d600 9
a608 1
	pool_put(&ecb_pool, (void *)ecb);
d618 3
a620 1
	int s, wait = 0;
d622 7
a628 2
	if ((curproc != NULL) && ((flags & SCSI_NOSLEEP) == 0))
		wait = PR_WAITOK;
a629 2
	s = splbio();
	ecb = (struct ncr53c9x_ecb *)pool_get(&ecb_pool, wait);
a630 5
	if (ecb == NULL)
		return (NULL);
	bzero(ecb, sizeof(*ecb));
	timeout_set(&ecb->to, ncr53c9x_timeout, ecb);
	ecb->flags |= ECB_ALLOC;
a649 3
	struct ncr53c9x_tinfo *ti;
	struct ncr53c9x_linfo *li;
	int64_t lun = sc_link->lun;
a656 21
	ti = &sc->sc_tinfo[sc_link->target];
	li = TINFO_LUN(ti, lun);
	if (li == NULL) {
		int wait = M_NOWAIT;

		/* Initialize LUN info and add to list. */
		if ((curproc != NULL) && ((flags & SCSI_NOSLEEP) == 0))
			wait = M_WAITOK;
		if ((li = malloc(sizeof(*li), M_DEVBUF, M_NOWAIT)) == NULL) {
			return (TRY_AGAIN_LATER);
		}
		bzero(li, sizeof(*li));
		li->last_used = time.tv_sec;
		li->lun = lun;
		s = splbio();
		LIST_INSERT_HEAD(&ti->luns, li, link);
		if (lun < NCR_NLUN)
			ti->lun[lun] = li;
		splx(s);
	}

a678 1
	ecb->flags |= ECB_READY;
a744 3
	int lun;
	struct ncr53c9x_linfo *li;
	int s, tag;
d757 1
a757 101
		lun = sc_link->lun;

		/* Select type of tag for this command */
		if ((ti->flags & (T_RSELECTOFF)) != 0)
			tag = 0;
		else if ((ti->flags & T_TAG) == 0)
			tag = 0;
		else if ((ecb->flags & ECB_SENSE) != 0)
			tag = 0;
		else if (ecb->xs->flags & SCSI_URGENT)
			tag = MSG_HEAD_OF_Q_TAG;
		else
			tag = MSG_SIMPLE_Q_TAG;
#if 0
		/* XXXX Use tags for polled commands? */
		if (ecb->xs->flags & SCSI_POLL)
			tag = 0;
#endif
		s = splbio();
		li = TINFO_LUN(ti, lun);
		if (!li) {
			int wait = M_NOWAIT;
			int flags = ecb->flags;

			/* Initialize LUN info and add to list. */
			if ((curproc != NULL) && ((flags & SCSI_NOSLEEP) == 0))
				wait = M_WAITOK;
			if ((li = malloc(sizeof(*li), M_DEVBUF, M_NOWAIT)) == NULL) {
				splx(s);
				continue;
			}
			bzero(li, sizeof(*li));
			li->lun = lun;

			LIST_INSERT_HEAD(&ti->luns, li, link);
			if (lun < NCR_NLUN)
				ti->lun[lun] = li;
		}
		li->last_used = time.tv_sec;
		if (!tag) {
			/* Try to issue this as an un-tagged command */
			if (!li->untagged)
				li->untagged = ecb;
		}
		if (li->untagged) {
			tag = 0;
			if ((li->busy != 1) && !li->used) {
				/* We need to issue this untagged command now */
				ecb = li->untagged;
				sc_link = ecb->xs->sc_link;
			}
			else {
				/* Not ready yet */
				splx(s);
				continue;
			}
		}
		ecb->tag[0] = tag;
		if (tag) {
			int i;

			/* Allocate a tag */
			if (li->used == 255) {
				/* no free tags */
				splx(s);
				continue;
			}
			/* Start from the last used location */
			for (i=li->avail; i<256; i++) {
				if (li->queued[i] == NULL)
					break;
			}
			/* Couldn't find one, start again from the beginning */
			if (i == 256) {
				for (i = 0; i<256; i++) {
					if (li->queued[i] == NULL)
						break;
				}
			}
#ifdef DIAGNOSTIC
			if (i == 256)
				panic("ncr53c9x_sched: tag alloc failure\n");
#endif

			/* Save where to start next time. */
			li->avail = i+1;
			li->used++;

			li->queued[i] = ecb;
			ecb->tag[1] = i;
		}
		splx(s);
		if (li->untagged && (li->busy != 1)) {
			li->busy = 1;
			TAILQ_REMOVE(&sc->ready_list, ecb, chain);
			ecb->flags &= ~ECB_READY;
			sc->sc_nexus = ecb;
			ncr53c9x_select(sc, ecb);
			break;
		}
		if (!li->untagged && tag) {
a758 1
			ecb->flags &= ~ECB_READY;
a777 2
	struct ncr53c9x_linfo *li;
	int lun = sc_link->lun;
d791 2
a792 5
	li = TINFO_LUN(ti, lun);
	if (li->busy) li->busy = 0;
	ncr53c9x_dequeue(sc, ecb);
	li->untagged = ecb;
	li->busy = 2;
d794 1
d797 1
a798 1
		ecb->flags |= ECB_READY;
a814 2
	int lun = sc_link->lun;
	struct ncr53c9x_linfo *li = TINFO_LUN(ti, lun);
a819 10
	if (ecb->stat == SCSI_QUEUE_FULL) {
		/*
		 * Set current throttle -- we should reset
		 * this periodically
		 */
		sc_link->openings = li->used - 1;
		printf("\n%s: QFULL -- throttling to %d commands\n",
		    sc->sc_dev.dv_xname, sc_link->openings);
	}

d860 2
a861 1
	ncr53c9x_dequeue(sc, ecb);
d868 3
a870 12
	}

	if (xs->error == XS_SELTIMEOUT) {
		/* Selection timeout -- discard this LUN if empty */
		if (!li->untagged && !li->used) {
			if (lun < NCR_NLUN)
				ti->lun[lun] = NULL;
			LIST_REMOVE(li, link);
			free(li, M_DEVBUF);
		}
	}

a880 25
	struct ncr53c9x_tinfo *ti = 
	    &sc->sc_tinfo[ecb->xs->sc_link->target];
	struct ncr53c9x_linfo *li;
	int64_t lun = ecb->xs->sc_link->lun;
       
	li = TINFO_LUN(ti, lun);
#ifdef DIAGNOSTIC
	if ((!li) || (li->lun != lun))
		panic("ncr53c9x_dequeue: lun %qx for ecb %p does not exist\n",
		    (long long)lun, ecb);
#endif
	if (li->untagged == ecb) {
		li->busy = 0;
		li->untagged = NULL;
	}
	if (ecb->tag[0] && li->queued[ecb->tag[1]]) {
#ifdef DIAGNOSTIC
		if (li->queued[ecb->tag[1]] && (li->queued[ecb->tag[1]] != ecb))
			panic("ncr53c9x_dequeue: slot %d for lun %qx has %p "
			    "instead of ecb %p\n", ecb->tag[1],
			    (long long)lun,
			    li->queued[ecb->tag[1]], ecb);
#endif
		li->queued[ecb->tag[1]] = NULL;
		li->used --;
d882 4
a885 3
	}
	if (ecb->flags & ECB_READY) {
		ecb->flags &= ~ECB_READY;
d888 1
a888 1
 }
d901 1
a901 1
		NCR_MISC(("ncr53c9x_sched_msgout %x %d ", m, __LINE__));	\
a906 98
static void
ncr53c9x_flushfifo(struct ncr53c9x_softc *sc)
{
	NCR_MISC(("[flushfifo] "));

	NCRCMD(sc, NCRCMD_FLUSH);

	if (sc->sc_phase == COMMAND_PHASE ||
	    sc->sc_phase == MESSAGE_OUT_PHASE)
		DELAY(2);
}

static int
ncr53c9x_rdfifo(struct ncr53c9x_softc *sc, int how)
{
	int i, n;
	u_char *buf;

	switch(how) {
	case NCR_RDFIFO_START:
		buf = sc->sc_imess;
		sc->sc_imlen = 0;
		break;
	case NCR_RDFIFO_CONTINUE:
		buf = sc->sc_imess + sc->sc_imlen;
		break;
	default:
		panic("ncr53c9x_rdfifo: bad flag\n");
		break;
	}

	/*
	 * XXX buffer (sc_imess) size for message
	 */

	n = NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF;

	if (sc->sc_rev == NCR_VARIANT_FAS366) {
		n *= 2;

		for (i = 0; i < n; i++)
			buf[i] = NCR_READ_REG(sc, NCR_FIFO);

		if (sc->sc_espstat2 & FAS_STAT2_ISHUTTLE) {

			NCR_WRITE_REG(sc, NCR_FIFO, 0);
			buf[i++] = NCR_READ_REG(sc, NCR_FIFO);

			NCR_READ_REG(sc, NCR_FIFO);

			ncr53c9x_flushfifo(sc);
		}
	} else {
		for (i = 0; i < n; i++)
			buf[i] = NCR_READ_REG(sc, NCR_FIFO);
	}

	sc->sc_imlen += i;

#ifdef NCR53C9X_DEBUG
	{
		int j;

		NCR_TRACE(("\n[rdfifo %s (%d):",
		    (how == NCR_RDFIFO_START) ? "start" : "cont",
		    (int)sc->sc_imlen));
		if (ncr53c9x_debug & NCR_SHOWTRAC) {
			for (j = 0; j < sc->sc_imlen; j++)
				printf(" %02x", sc->sc_imess[j]);
			printf("]\n");
		}
	}
#endif
	return sc->sc_imlen;
}

static void
ncr53c9x_wrfifo(struct ncr53c9x_softc *sc, u_char *p, int len)
{
	int i;

#ifdef NCR53C9X_DEBUG
	NCR_MISC(("[wrfifo(%d):", len));
	if (ncr53c9x_debug & NCR_SHOWTRAC) {
		for (i = 0; i < len; i++)
			printf(" %02x", p[i]);
		printf("]\n");
	}
#endif

	for (i = 0; i < len; i++) {
		NCR_WRITE_REG(sc, NCR_FIFO, p[i]);

		if (sc->sc_rev == NCR_VARIANT_FAS366)
			NCR_WRITE_REG(sc, NCR_FIFO, 0);
	}
}

d908 1
a908 1
ncr53c9x_reselect(sc, message, tagtype, tagid)
d913 2
a914 1
	struct ncr53c9x_ecb *ecb = NULL;
a915 1
	struct ncr53c9x_linfo *li;
d917 10
a926 16
	if (sc->sc_rev == NCR_VARIANT_FAS366) {
		target = sc->sc_selid;
	} else {
		/*
		 * The SCSI chip made a snapshot of the data bus while the reselection
		 * was being negotiated.  This enables us to determine which target did
		 * the reselect.
		 */
		selid = sc->sc_selid & ~(1 << sc->sc_id);
		if (selid & (selid - 1)) {
			printf("%s: reselect with invalid selid %02x;"
			    " sending DEVICE RESET\n", sc->sc_dev.dv_xname, selid);
			goto reset;

		}
		target = ffs(selid) - 1;
a927 1
	lun = message & 0x07;
d935 8
a942 17
	ti = &sc->sc_tinfo[target];
	li = TINFO_LUN(ti, lun);

	/*
	 * We can get as far as the LUN with the IDENTIFY
	 * message.  Check to see if we're running an
	 * un-tagged command.  Otherwise ack the IDENTIFY
	 * and wait for a tag message.
	 */
	if (li != NULL) {
		if (li->untagged != NULL && li->busy)
			ecb = li->untagged;
		else if (tagtype != MSG_SIMPLE_Q_TAG) {
			/* Wait for tag to come by */
			sc->sc_state = NCR_IDENTIFIED;
			return (0);
		} else if (tagtype) ecb = li->queued[tagid];
d945 2
a946 2
		printf("%s: reselect from target %d lun %d tag %x:%x with no nexus;"
		    " sending ABORT\n", sc->sc_dev.dv_xname, target, lun, tagtype, tagid);
d951 1
d954 8
a987 15
static inline int
__verify_msg_format(u_char *p, int len)
{

	if (len == 1 && IS1BYTEMSG(p[0]))
		return 1;
	if (len == 2 && IS2BYTEMSG(p[0]))
		return 1;
	if (len >= 3 && ISEXTMSG(p[0]) &&
	    len == p[1] + 2)
		return 1;

	return 0;
}

d996 1
a996 1
	struct ncr53c9x_softc *sc;
d998 1
d1002 3
a1004 2
	if (sc->sc_imlen == 0) {
		printf("%s: msgin: no msg byte available\n", sc->sc_dev.dv_xname);
d1014 1
a1014 3
	if (sc->sc_prevphase != MESSAGE_IN_PHASE && sc->sc_state != NCR_RESELECTED) {
		printf("%s: phase change, dropping message, prev %d, state %d\n",
		    sc->sc_dev.dv_xname, sc->sc_prevphase, sc->sc_state);
d1019 15
a1033 1
	NCR_TRACE(("<msgbyte:0x%02x>", sc->sc_imess[0]));
d1039 1
d1051 13
a1063 19
		u_char *pb;
		int plen;

		switch (sc->sc_state) {
			/*
			 * if received message is the first of reselection
			 * then first byte is selid, and then message
			 */
		case NCR_RESELECTED:
			pb = sc->sc_imess + 1;
			plen = sc->sc_imlen - 1;
			break;
		default:
			pb = sc->sc_imess;
			plen = sc->sc_imlen;
			break;
		}

		if (__verify_msg_format(pb, plen))
a1065 1

d1071 1
a1071 4
	NCR_MSGS(("gotmsg(%x) state %d", sc->sc_imess[0], sc->sc_state));
	/* we got complete message, flush the imess, XXX nobody uses imlen below */
	sc->sc_imlen = 0;

a1080 2
		struct ncr53c9x_linfo *li;
		int lun;
d1090 4
a1093 3
				sc_print_addr(ecb->xs->sc_link);
				printf("got %ld extra bytes\n",
				    -(long)sc->sc_dleft);
a1106 25
			case SEND_TAG:
				/* Target does not like tagged queuing.
				 *  - Flush the command queue
				 *  - Disable tagged queuing for the target
				 *  - Dequeue ecb from the queued array.
				 */
				printf("%s: tagged queuing rejected: target %d\n",
				    sc->sc_dev.dv_xname, ecb->xs->sc_link->target);
				
				NCR_MSGS(("(rejected sent tag)"));
				NCRCMD(sc, NCRCMD_FLUSH);
				DELAY(1);
				ti->flags &= ~T_TAG;
				lun = ecb->xs->sc_link->lun;
				li = TINFO_LUN(ti, lun);
				if (ecb->tag[0] &&
				    li->queued[ecb->tag[1]] != NULL) {
					li->queued[ecb->tag[1]] = NULL;
					li->used--;
				}
				ecb->tag[0] = ecb->tag[1] = 0;
				li->untagged = ecb;
				li->busy = 1;
				break;

a1107 2
				printf("%s: sync transfer rejected: target %d\n",
				    sc->sc_dev.dv_xname, ecb->xs->sc_link->target);
a1111 8

			case SEND_WDTR:
				printf("%s: wide transfer rejected: target %d\n",
				    sc->sc_dev.dv_xname, ecb->xs->sc_link->target);
				ti->flags &= ~T_WIDE;
				ti->width = 0;
				break;

a1120 6
		case MSG_HEAD_OF_Q_TAG:
		case MSG_SIMPLE_Q_TAG:
		case MSG_ORDERED_Q_TAG:
			NCR_MSGS(("TAG %x:%x", sc->sc_imess[0], sc->sc_imess[1]));
			break;

d1163 2
a1164 4
#ifdef NCR53C9X_DEBUG
					sc_print_addr(ecb->xs->sc_link);
					printf("async mode\n");
#endif
d1187 1
a1187 1
					printf("max sync rate %d.%02dMB/s\n",
a1211 10
			case MSG_EXT_WDTR:
				printf("%s: wide mode %d\n",
				    sc->sc_dev.dv_xname, sc->sc_imess[3]);
				if (sc->sc_imess[3] == 1) {
					ti->cfg3 |= NCRFASCFG3_EWIDE;
					ncr53c9x_setsync(sc, ti);
				} else
					ti->width = 0;
				ti->flags &= ~T_WIDE;
				break;
d1213 2
a1214 3
				sc_print_addr(ecb->xs->sc_link);
				printf("unrecognized MESSAGE EXTENDED;"
				    " sending REJECT\n");
d1221 2
a1222 2
			sc_print_addr(ecb->xs->sc_link);
			printf("unrecognized MESSAGE; sending REJECT\n");
a1228 17
	case NCR_IDENTIFIED:
		/*
		 * IDENTIFY message was recived and queue tag is expected now
		 */
		if ((sc->sc_imess[0] != MSG_SIMPLE_Q_TAG) ||
		    (sc->sc_msgify == 0)) {
			printf("%s: TAG reselect without IDENTIFY;"
			    " MSG %x;"
			    " sending DEVICE RESET\n",
			    sc->sc_dev.dv_xname,
			    sc->sc_imess[0]);
			goto reset;
		}
		(void) ncr53c9x_reselect(sc, sc->sc_msgify,
		    sc->sc_imess[0], sc->sc_imess[1]);
		break;

d1230 1
a1230 3
		if (MSG_ISIDENTIFY(sc->sc_imess[1])) {
			sc->sc_msgify = sc->sc_imess[1];
		} else {
d1232 1
a1232 4
			    " MSG %x;"
			    " sending DEVICE RESET\n",
			    sc->sc_dev.dv_xname,
			    sc->sc_imess[1]);
d1235 2
a1236 1
		(void) ncr53c9x_reselect(sc, sc->sc_msgify, 0, 0);
a1239 1
		sc_print_addr(ecb->xs->sc_link);
a1250 4
	/* if we have more messages to send set ATN */
	if (sc->sc_msgpriq)
		NCRCMD(sc, NCRCMD_SETATN);

d1265 1
a1265 1
	struct ncr53c9x_softc *sc;
d1285 1
a1285 1
/*			DELAY(1); */
a1319 9
		case SEND_WDTR:
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			sc->sc_omess[0] = MSG_EXTENDED;
			sc->sc_omess[1] = 2;
			sc->sc_omess[2] = MSG_EXT_WDTR;
			sc->sc_omess[3] = ti->width;
			sc->sc_omlen = 4;
			break;
a1328 10
		case SEND_TAG:
			if (sc->sc_state != NCR_CONNECTED) {
				printf("%s at line %d: no nexus\n",
				    sc->sc_dev.dv_xname, __LINE__);
			}
			ecb = sc->sc_nexus;
			sc->sc_omess[0] = ecb->tag[0];
			sc->sc_omess[1] = ecb->tag[1];
			sc->sc_omlen = 2;
			break;
d1335 1
a1335 3
			if ((ti->flags & T_SYNCHOFF) == 0)
				/* We can re-start sync negotiation */
				ti->flags |= T_NEGOTIATE;
d1371 13
a1383 27
#ifdef DEBUG
	{
		int i;

		for (i = 0; i<sc->sc_omlen; i++)
			NCR_MISC(("<msgbyte:0x%02x>", sc->sc_omess[i]));
	}
#endif
	if (sc->sc_rev == NCR_VARIANT_FAS366) {
		/*      
		 * XXX fifo size
		 */
		ncr53c9x_flushfifo(sc);
		ncr53c9x_wrfifo(sc, sc->sc_omp, sc->sc_omlen);
		NCRCMD(sc, NCRCMD_TRANS);
	} else {
		/* (re)send the message */
		size = min(sc->sc_omlen, sc->sc_maxxfer);
		NCRDMA_SETUP(sc, &sc->sc_omp, &sc->sc_omlen, 0, &size);
		/* Program the SCSI counter */
		NCR_SET_COUNT(sc, size);

               /* Load the count in and start the message-out transfer */
		NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);
		NCRCMD(sc, NCRCMD_TRANS|NCRCMD_DMA);
		NCRDMA_GO(sc);
	}
d1400 3
a1402 3
	struct ncr53c9x_softc *sc = arg;
	struct ncr53c9x_ecb *ecb;
	struct scsi_link *sc_link;
d1407 1
a1407 1
	NCR_TRACE(("[ncr53c9x_intr: state %d] ", sc->sc_state));
d1550 1
a1550 1
				       " prevphase %x, resid %lx\n",
d1556 1
a1556 1
					(u_long)sc->sc_omlen);
a1588 1
		sc->sc_msgify = 0;
d1593 1
a1593 1
/*			DELAY(1); */
a1605 3
		{
			struct ncr53c9x_linfo *li;

d1607 1
a1608 18
			/* Selection timeout -- discard all LUNs if empty */
			sc_link = ecb->xs->sc_link;
			ti = &sc->sc_tinfo[sc_link->target];
			li = ti->luns.lh_first;
			while (li) {
				if (!li->untagged && !li->used) {
					if (li->lun < NCR_NLUN)
						ti->lun[li->lun] = NULL;
					LIST_REMOVE(li, link);
					free(li, M_DEVBUF);
					/* Restart the search at the beginning */
					li = ti->luns.lh_first;
					continue;
				}
				li = li->link.le_next;
			}
			goto finish;
		}
d1648 1
a1686 20
	case NCR_IDENTIFIED:
		ecb = sc->sc_nexus;
		if (sc->sc_phase != MESSAGE_IN_PHASE) {
			int i = (NCR_READ_REG(sc, NCR_FFLAG)
			    & NCRFIFO_FF);
			/*
			 * Things are seriously fucked up.
			 * Pull the brakes, i.e. reset
			 */
			printf("%s: target didn't send tag: %d bytes in fifo\n",
			    sc->sc_dev.dv_xname, i);
			/* Drain and display fifo */
			while (i-- > 0)
				printf("[%d] ", NCR_READ_REG(sc, NCR_FIFO));
			ncr53c9x_init(sc, 1);
			return (1);
		} else
			goto msgin;

		break;
d1689 2
d1692 5
a1697 2
			sc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;
			sc->sc_flags = 0;
d1706 2
a1707 1
				ncr53c9x_dequeue(sc, ecb);
a1708 1
				ecb->flags |= ECB_READY;
d1732 1
a1732 2
			nfifo = ncr53c9x_rdfifo(sc, NCR_RDFIFO_START);

d1748 2
a1749 2
			sc->sc_selid = sc->sc_imess[0];
			NCR_MISC(("selid=%2x ", sc->sc_selid));
d1760 1
a1760 1
			} else if (sc->sc_features & NCR_F_DMASELECT &&
d1765 1
a1765 2
			if (sc->sc_state != NCR_CONNECTED &&
			    sc->sc_state != NCR_IDENTIFIED) {
d1767 2
a1768 3
				printf("%s: identify failed, state %d, intr %02x\n",
					sc->sc_dev.dv_xname, sc->sc_state,
				    sc->sc_espintr);
d1783 1
a1783 1
				panic("ncr53c9x: no nexus");
d1802 1
a1802 2
				if ((ti->flags & T_NEGOTIATE) == 0 &&
				    ecb->tag[0] == 0) {
d1812 5
a1816 17
				if (ti->flags & T_WIDE) {
					ncr53c9x_sched_msgout(SEND_WDTR);
				}
				if (ti->flags & T_NEGOTIATE) {
					/* Start negotiating */
					ti->period = sc->sc_minsync;
					ti->offset = 15;
					sc->sc_flags |= NCR_SYNCHNEGO;
					if (ecb->tag[0])
						ncr53c9x_sched_msgout(SEND_TAG|SEND_SDTR);
					else
						ncr53c9x_sched_msgout(SEND_SDTR);
				} else {
					/* Could not do ATN3 so send TAG */
					ncr53c9x_sched_msgout(SEND_TAG);
				}
				sc->sc_prevphase = MESSAGE_OUT_PHASE; /* XXXX */
d1827 1
a1827 1
				if (sc->sc_features & NCR_F_DMASELECT) {
d1854 1
a1854 1
				if (sc->sc_features & NCR_F_DMASELECT &&
d1857 1
a1857 1
					       "%lu left in DMA buffer "
d1862 1
a1862 1
						(u_long)sc->sc_cmdlen,
d1870 3
d1912 10
a1921 6
			ncr53c9x_rdfifo(sc, NCR_RDFIFO_START);
			if (sc->sc_imlen < 2)
				printf("%s: can't get status, only %d bytes\n",
				    sc->sc_dev.dv_xname, (int)sc->sc_imlen);
			ecb->stat = sc->sc_imess[sc->sc_imlen - 2];
			msg = sc->sc_imess[sc->sc_imlen - 1];
a1932 1
			sc->sc_imlen = 0;
d1938 1
a1938 2
		/* Don't panic: reset. */
		printf("%s: invalid state: %d",
a1940 3
		ncr53c9x_scsi_reset(sc);
		goto out;
		break;
d1948 1
a1948 1
		panic("ncr53c9x no nexus");
a1957 1
msgin:
d1959 1
d1961 1
a1961 4
			if ((sc->sc_rev != NCR_VARIANT_FAS366) ||
			    !(sc->sc_espstat2 & FAS_STAT2_EMPTY)) {
				NCRCMD(sc, NCRCMD_FLUSH);
			}
a1972 3
			ncr53c9x_rdfifo(sc,
			    (sc->sc_prevphase == sc->sc_phase) ?
			    NCR_RDFIFO_CONTINUE : NCR_RDFIFO_START);
a1980 1
		sc->sc_prevphase = MESSAGE_IN_PHASE;
d1996 1
a1996 1
/*			DELAY(1); */
d1998 1
a1998 1
		if (sc->sc_features & NCR_F_DMASELECT) {
d2007 5
a2011 1
			NCR_SET_COUNT(sc, size);
d2020 5
a2024 1
			ncr53c9x_wrfifo(sc, (u_char *)&ecb->cmd.cmd, ecb->clen);
d2050 5
a2054 2
		NCR_SET_COUNT(sc, size);

d2110 3
a2112 16
	{
		struct timeval wait, cur;

		microtime(&wait);
		wait.tv_usec += 50/sc->sc_freq;
		if (wait.tv_usec > 1000000) {
			wait.tv_sec++;
			wait.tv_usec -= 1000000;
		}
		do {
			if (NCRDMA_ISINTR(sc))
				goto again;
			microtime(&cur);
		} while (cur.tv_sec <= wait.tv_sec &&
		    cur.tv_usec <= wait.tv_usec);
	}
a2126 2
		int timeout;

d2137 1
a2137 5
		if (hz > 100 && timeout > 1000)
			timeout = (timeout / 1000) * hz;
		else
			timeout = (timeout * hz) / 1000;
		timeout_add(&ecb->to, timeout);
d2139 6
d2146 1
a2146 1
		 * Just leave the command where it is.
a2204 32
}

void
ncr53c9x_watch(arg)
	void *arg;
{
	struct ncr53c9x_softc *sc = (struct ncr53c9x_softc *)arg;
	struct ncr53c9x_tinfo *ti;
	struct ncr53c9x_linfo *li;
	int t, s;
	/* Delete any structures that have not been used in 10min. */
	time_t old = time.tv_sec - (10*60);

	s = splbio();
	for (t=0; t<NCR_NTARG; t++) {
		ti = &sc->sc_tinfo[t];
		li = ti->luns.lh_first;
		while (li) {
			if (li->last_used < old && !li->untagged && !li->used) {
				if (li->lun < NCR_NLUN)
					ti->lun[li->lun] = NULL;
				LIST_REMOVE(li, link);
				free(li, M_DEVBUF);
				/* Restart the search at the beginning */
				li = ti->luns.lh_first;
				continue; 
			}
			li = li->link.le_next;
		}
	}
	splx(s);
	timeout_add(&sc->sc_watchdog, 60*hz);
@


1.6.8.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d379 1
a379 1
		    "ncr53c9x_ecb", NULL);
d592 1
a592 1
		if (timeout > 1000000)
d2714 1
a2714 1
		int timeout = ecb->timeout;
d2726 1
a2726 1
		if (timeout > 1000000)
@


1.6.8.4
log
@Merge in -current from about a week ago
@
text
@d101 18
a118 18
/*static*/ void	ncr53c9x_readregs(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_select(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
/*static*/ int ncr53c9x_reselect(struct ncr53c9x_softc *, int, int, int);
/*static*/ void	ncr53c9x_scsi_reset(struct ncr53c9x_softc *);
/*static*/ int	ncr53c9x_poll(struct ncr53c9x_softc *,
					    struct scsi_xfer *, int);
/*static*/ void	ncr53c9x_sched(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_done(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
/*static*/ void	ncr53c9x_msgin(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_msgout(struct ncr53c9x_softc *);
/*static*/ void	ncr53c9x_timeout(void *arg);
/*static*/ void ncr53c9x_watch(void *arg);
/*static*/ void	ncr53c9x_abort(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
/*static*/ void ncr53c9x_dequeue(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
d120 5
a124 5
void ncr53c9x_sense(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *);
void ncr53c9x_free_ecb(struct ncr53c9x_softc *,
					    struct ncr53c9x_ecb *, int);
struct ncr53c9x_ecb *ncr53c9x_get_ecb(struct ncr53c9x_softc *, int);
d126 5
a130 5
static inline int ncr53c9x_stp2cpb(struct ncr53c9x_softc *, int);
static inline void ncr53c9x_setsync(struct ncr53c9x_softc *,
					    struct ncr53c9x_tinfo *);
static struct ncr53c9x_linfo *ncr53c9x_lunsearch(struct ncr53c9x_tinfo *,
    int64_t lun);
@


1.6.8.5
log
@Sync the SMP branch with 3.3
@
text
@d784 2
d787 2
d927 3
d931 2
d987 1
a987 1
				panic("ncr53c9x_sched: tag alloc failure");
d1163 1
a1163 1
		panic("ncr53c9x_dequeue: lun %qx for ecb %p does not exist",
d1174 1
a1174 1
			    "instead of ecb %p", ecb->tag[1],
d1232 1
a1232 1
		panic("ncr53c9x_rdfifo: bad flag");
d1729 1
d2681 2
a2682 2
	 * The delay is a heuristic. It is 2 when at 20MHz, 2 at 25MHz and 1
	 * at 40MHz. This needs testing.
@


1.6.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.6.8.5 2003/03/28 00:38:14 niklas Exp $	*/
d46 5
@


1.6.8.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d152 1
a152 1
 * Names for the NCR53c9x variants, corresponding to the variant tags
d872 1
a872 1
 * This may save us an unnecessary interrupt just to get things going.
d1101 1
a1101 1
			printf("resid=%lu ", (unsigned long)xs->resid);
a1292 2
	int tagtype;
	int tagid;
d1685 1
a1685 1
		 * IDENTIFY message was received and queue tag is expected now
@


1.5
log
@Fix a few missing changes from the last NetBSD merge.
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr53c9x.c,v 1.4 1998/02/10 05:03:30 jason Exp $	*/
/*	$NetBSD: ncr53c9x.c,v 1.23 1998/01/31 23:37:51 pk Exp $	*/
d81 1
d152 17
a170 1

d231 1
d264 1
d373 1
a373 1
void
d412 1
a412 1
	return v;
d420 1
d423 10
a432 3
		NCR_WRITE_REG(sc, NCR_SYNCOFF, ti->offset);
		NCR_WRITE_REG(sc, NCR_SYNCTP,
		    ncr53c9x_stp2cpb(sc, ti->period));
d434 2
a435 2
		NCR_WRITE_REG(sc, NCR_SYNCOFF, 0);
		NCR_WRITE_REG(sc, NCR_SYNCTP, 0);
d437 6
d580 1
a580 1
	return ecb;
d607 1
a607 1
		return TRY_AGAIN_LATER;
d634 1
a634 1
		return SUCCESSFULLY_QUEUED;
d642 1
a642 1
	return COMPLETE;
d665 1
a665 1
			return 0;
d673 1
a673 1
	return 1;
d1344 1
a1351 1
	int loop;
d1357 37
a1393 23
	/*
	 * I have made some (maybe seriously flawed) assumptions here,
	 * but basic testing (uncomment the printf() below), show that
	 * certainly something happens when this loop is here.
	 *
	 * The idea is that many of the SCSI operations take very little
	 * time, and going away and getting interrupted is too high an
	 * overhead to pay. For example, selecting, sending a message
	 * and command and then doing some work can be done in one "pass".
	 *
	 * The DELAY is not variable because I do not understand that the
	 * DELAY loop should be fixed-time regardless of CPU speed, but
	 * I am *assuming* that the faster SCSI processors get things done
	 * quicker (sending a command byte etc), and so there is no
	 * need to be too slow.
	 *
	 * This is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1
	 * at 40Mhz. This needs testing.
	 */
	for (loop = 0; 1;loop++, DELAY(50/sc->sc_freq)) {
		/* a feeling of deja-vu */
		if (!NCRDMA_ISINTR(sc))
			return (loop != 0);
d1395 4
a1398 2
		if (loop)
			printf("*");
d1400 5
d1406 1
a1406 2
		/* and what do the registers say... */
		ncr53c9x_readregs(sc);
d1408 3
a1410 18
		sc->sc_intrcnt.ev_count++;

		/*
		 * At the moment, only a SCSI Bus Reset or Illegal
		 * Command are classed as errors. A disconnect is a
		 * valid condition, and we let the code check is the
		 * "NCR_BUSFREE_OK" flag was set before declaring it
		 * and error.
		 *
		 * Also, the status register tells us about "Gross
		 * Errors" and "Parity errors". Only the Gross Error
		 * is really bad, and the parity errors are dealt
		 * with later
		 *
		 * TODO
		 *	If there are too many parity error, go to slow
		 *	cable mode ?
		 */
d1412 2
a1413 2
		/* SCSI Reset */
		if (sc->sc_espintr & NCRINTR_SBR) {
d1418 4
a1421 5
			if (sc->sc_state != NCR_SBR) {
				printf("%s: SCSI bus reset\n",
					sc->sc_dev.dv_xname);
				ncr53c9x_init(sc, 0); /* Restart everything */
				return 1;
d1423 1
a1423 10
#if 0
	/*XXX*/		printf("<expected bus reset: "
				"[intr %x, stat %x, step %d]>\n",
				sc->sc_espintr, sc->sc_espstat,
				sc->sc_espstep);
#endif
			if (sc->sc_nexus)
				panic("%s: nexus in reset state",
				      sc->sc_dev.dv_xname);
			goto sched;
d1426 8
a1433 28
		ecb = sc->sc_nexus;

#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)
		if (sc->sc_espintr & NCRINTR_ERR ||
		    sc->sc_espstat & NCRSTAT_GE) {

			if (sc->sc_espstat & NCRSTAT_GE) {
				/* no target ? */
				if (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {
					NCRCMD(sc, NCRCMD_FLUSH);
					DELAY(1);
				}
				if (sc->sc_state == NCR_CONNECTED ||
				    sc->sc_state == NCR_SELECTING) {
					ecb->xs->error = XS_TIMEOUT;
					ncr53c9x_done(sc, ecb);
				}
				return 1;
			}

			if (sc->sc_espintr & NCRINTR_ILL) {
				if (sc->sc_flags & NCR_EXPECT_ILLCMD) {
					/*
					 * Eat away "Illegal command" interrupt
					 * on a ESP100 caused by a re-selection
					 * while we were trying to select
					 * another target.
					 */
d1435 2
a1436 2
					printf("%s: ESP100 work-around activated\n",
						sc->sc_dev.dv_xname);
d1438 12
a1449 15
					sc->sc_flags &= ~NCR_EXPECT_ILLCMD;
					continue;
				}
				/* illegal command, out of sync ? */
				printf("%s: illegal command: 0x%x "
				    "(state %d, phase %x, prevphase %x)\n",
					sc->sc_dev.dv_xname, sc->sc_lastcmd,
					sc->sc_state, sc->sc_phase,
					sc->sc_prevphase);
				if (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {
					NCRCMD(sc, NCRCMD_FLUSH);
					DELAY(1);
				}
				ncr53c9x_init(sc, 1); /* Restart everything */
				return 1;
d1451 2
d1454 2
a1455 1
		sc->sc_flags &= ~NCR_EXPECT_ILLCMD;
d1457 17
a1473 17
		/*
		 * Call if DMA is active.
		 *
		 * If DMA_INTR returns true, then maybe go 'round the loop
		 * again in case there is no more DMA queued, but a phase
		 * change is expected.
		 */
		if (NCRDMA_ISACTIVE(sc)) {
			int r = NCRDMA_INTR(sc);
			if (r == -1) {
				printf("%s: DMA error; resetting\n",
					sc->sc_dev.dv_xname);
				ncr53c9x_init(sc, 1);
			}
			/* If DMA active here, then go back to work... */
			if (NCRDMA_ISACTIVE(sc))
				return 1;
d1475 12
a1486 1
			if ((sc->sc_espstat & NCRSTAT_TC) == 0) {
d1488 5
a1492 2
				 * DMA not completed.  If we can not find a
				 * acceptable explanation, print a diagnostic.
d1494 26
a1519 41
				if (sc->sc_state == NCR_SELECTING)
					/*
					 * This can happen if we are reselected
					 * while using DMA to select a target.
					 */
					/*void*/;
				else if (sc->sc_prevphase == MESSAGE_OUT_PHASE){
					/*
					 * Our (multi-byte) message (eg SDTR)
					 * was interrupted by the target to
					 * send a MSG REJECT.
					 * Print diagnostic if current phase
					 * is not MESSAGE IN.
					 */
					if (sc->sc_phase != MESSAGE_IN_PHASE)
					    printf("%s: !TC on MSG OUT"
					       " [intr %x, stat %x, step %d]"
					       " prevphase %x, resid %x\n",
						sc->sc_dev.dv_xname,
						sc->sc_espintr,
						sc->sc_espstat,
						sc->sc_espstep,
						sc->sc_prevphase,
						sc->sc_omlen);
				} else if (sc->sc_dleft == 0) {
					/*
					 * The DMA operation was started for
					 * a DATA transfer. Print a diagnostic
					 * if the DMA counter and TC bit
					 * appear to be out of sync.
					 */
					printf("%s: !TC on DATA XFER"
					       " [intr %x, stat %x, step %d]"
					       " prevphase %x, resid %x\n",
						sc->sc_dev.dv_xname,
						sc->sc_espintr,
						sc->sc_espstat,
						sc->sc_espstep,
						sc->sc_prevphase,
						ecb?ecb->dleft:-1);
				}
d1522 1
d1524 17
a1540 5
#if 0	/* Unreliable on some NCR revisions? */
		if ((sc->sc_espstat & NCRSTAT_INT) == 0) {
			printf("%s: spurious interrupt\n",
			    sc->sc_dev.dv_xname);
			return 1;
a1541 2
#endif

d1543 2
a1544 1
		 * check for less serious errors
d1546 1
a1546 8
		if (sc->sc_espstat & NCRSTAT_PE) {
			printf("%s: SCSI bus parity error\n",
				sc->sc_dev.dv_xname);
			if (sc->sc_prevphase == MESSAGE_IN_PHASE)
				ncr53c9x_sched_msgout(SEND_PARITY_ERROR);
			else
				ncr53c9x_sched_msgout(SEND_INIT_DET_ERR);
		}
d1548 3
a1550 12
		if (sc->sc_espintr & NCRINTR_DIS) {
			NCR_MISC(("<DISC [intr %x, stat %x, step %d]>",
				sc->sc_espintr,sc->sc_espstat,sc->sc_espstep));
			if (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {
				NCRCMD(sc, NCRCMD_FLUSH);
				DELAY(1);
			}
			/*
			 * This command must (apparently) be issued within
			 * 250mS of a disconnect. So here you are...
			 */
			NCRCMD(sc, NCRCMD_ENSEL);
d1552 3
a1554 7
			switch (sc->sc_state) {
			case NCR_RESELECTED:
				goto sched;

			case NCR_SELECTING:
				ecb->xs->error = XS_SELTIMEOUT;
				goto finish;
d1556 2
a1557 2
			case NCR_CONNECTED:
				if ((sc->sc_flags & NCR_SYNCHNEGO)) {
d1559 3
a1561 3
					if (ecb)
						sc_print_addr(ecb->xs->sc_link);
					printf("sync nego not completed!\n");
d1563 4
a1566 5
					ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
					sc->sc_flags &= ~NCR_SYNCHNEGO;
					ti->flags &=
					    ~(T_NEGOTIATE | T_SYNCMODE);
				}
d1568 16
a1583 21
				/* it may be OK to disconnect */
				if ((sc->sc_flags & NCR_ABORTING) == 0) {
					/*  
					 * Section 5.1.1 of the SCSI 2 spec
					 * suggests issuing a REQUEST SENSE
					 * following an unexpected disconnect.
					 * Some devices go into a contingent
					 * allegiance condition when
					 * disconnecting, and this is necessary
					 * to clean up their state.
					 */     
					printf("%s: unexpected disconnect; ",
					    sc->sc_dev.dv_xname);
					if (ecb->flags & ECB_SENSE) {
						printf("resetting\n");
						goto reset;
					}
					printf("sending REQUEST SENSE\n");
					untimeout(ncr53c9x_timeout, ecb);
					ncr53c9x_sense(sc, ecb);
					goto out;
d1585 5
d1591 2
a1592 2
				ecb->xs->error = XS_TIMEOUT;
				goto finish;
d1594 4
a1597 4
			case NCR_DISCONNECT:
				TAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);
				sc->sc_nexus = NULL;
				goto sched;
d1599 2
a1600 3
			case NCR_CMDCOMPLETE:
				goto finish;
			}
d1602 3
d1606 4
a1609 1
		switch (sc->sc_state) {
d1611 6
a1616 2
		case NCR_SBR:
			printf("%s: waiting for SCSI Bus Reset to happen\n",
d1618 25
a1642 1
			return 1;
d1644 1
a1644 1
		case NCR_RESELECTED:
d1646 3
a1648 1
			 * we must be continuing a message ?
d1650 9
d1660 4
d1667 27
a1693 1
				return 1;
d1695 4
a1698 2
printf("<<RESELECT CONT'd>>");
#if XXXX
d1700 12
d1717 1
a1717 1
				return 1;
d1719 2
a1720 2
#endif
			break;
d1722 6
a1727 4
		case NCR_IDLE:
		case NCR_SELECTING:
			sc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;
			sc->sc_flags = 0;
d1729 5
a1733 5
			if (ecb != NULL && (ecb->flags & ECB_NEXUS)) {
				sc_print_addr(ecb->xs->sc_link);
				printf("ECB_NEXUS while in state %x\n",
					sc->sc_state);
			}
d1735 2
a1736 1
			if (sc->sc_espintr & NCRINTR_RESEL) {
d1738 7
a1744 3
				 * If we're trying to select a
				 * target ourselves, push our command
				 * back into the ready list.
d1746 7
a1752 8
				if (sc->sc_state == NCR_SELECTING) {
					NCR_MISC(("backoff selector "));
					untimeout(ncr53c9x_timeout, ecb);
					sc_link = ecb->xs->sc_link;
					ti = &sc->sc_tinfo[sc_link->target];
					TAILQ_INSERT_HEAD(&sc->ready_list,
					    ecb, chain);
					ecb = sc->sc_nexus = NULL;
d1754 2
a1755 7
				sc->sc_state = NCR_RESELECTED;
				if (sc->sc_phase != MESSAGE_IN_PHASE) {
					/*
					 * Things are seriously fucked up.
					 * Pull the brakes, i.e. reset
					 */
					printf("%s: target didn't identify\n",
d1757 1
a1757 2
					ncr53c9x_init(sc, 1);
					return 1;
d1759 7
d1767 6
a1772 8
				 * The C90 only inhibits FIFO writes until
				 * reselection is complete, instead of
				 * waiting until the interrupt status register
				 * has been read. So, if the reselect happens
				 * while we were entering a command bytes (for
				 * another target) some of those bytes can
				 * appear in the FIFO here, after the
				 * interrupt is taken.
d1774 2
a1775 94
				nfifo = NCR_READ_REG(sc,NCR_FFLAG) & NCRFIFO_FF;
				if (nfifo < 2 ||
				    (nfifo > 2 &&
				     sc->sc_rev != NCR_VARIANT_ESP100)) {
					printf("%s: RESELECT: "
					    "%d bytes in FIFO! "
					    "[intr %x, stat %x, step %d, prevphase %x]\n",
						sc->sc_dev.dv_xname,
						nfifo,
						sc->sc_espintr,
						sc->sc_espstat,
						sc->sc_espstep,
						sc->sc_prevphase);
					ncr53c9x_init(sc, 1);
					return 1;
				}
				sc->sc_selid = NCR_READ_REG(sc, NCR_FIFO);
				NCR_MISC(("selid=0x%2x ", sc->sc_selid));

				/* Handle identify message */
				ncr53c9x_msgin(sc);
				if (nfifo != 2) {
					/*
					 * Note: this should not happen
					 * with `dmaselect' on.
					 */
					sc->sc_flags |= NCR_EXPECT_ILLCMD;
					NCRCMD(sc, NCRCMD_FLUSH);
				} else if (ncr53c9x_dmaselect &&
					   sc->sc_rev == NCR_VARIANT_ESP100) {
					sc->sc_flags |= NCR_EXPECT_ILLCMD;
				}

				if (sc->sc_state != NCR_CONNECTED) {
					/* IDENTIFY fail?! */
					printf("%s: identify failed\n",
						sc->sc_dev.dv_xname);
					ncr53c9x_init(sc, 1);
					return 1;
				}
				continue; /* ie. next phase expected soon */
			}

#define	NCRINTR_DONE	(NCRINTR_FC|NCRINTR_BS)
			if ((sc->sc_espintr & NCRINTR_DONE) == NCRINTR_DONE) {
				ecb = sc->sc_nexus;
				if (!ecb)
					panic("esp: not nexus at sc->sc_nexus");

				sc_link = ecb->xs->sc_link;
				ti = &sc->sc_tinfo[sc_link->target];

				switch (sc->sc_espstep) {
				case 0:
					/*
					 * The target did not respond with a
					 * message out phase - probably an old
					 * device that doesn't recognize ATN.
					 * Clear ATN and just continue, the
					 * target should be in the command
					 * phase.
					 * XXXX check for command phase?
					 */
					NCRCMD(sc, NCRCMD_RSTATN);
					break;
				case 1:
					if ((ti->flags & T_NEGOTIATE) == 0) {
						printf("%s: step 1 & !NEG\n",
							sc->sc_dev.dv_xname);
						goto reset;
					}
					if (sc->sc_phase != MESSAGE_OUT_PHASE) {
						printf("%s: !MSGOUT\n",
							sc->sc_dev.dv_xname);
						goto reset;
					}
					/* Start negotiating */
					ti->period = sc->sc_minsync;
					ti->offset = 15;
					sc->sc_flags |= NCR_SYNCHNEGO;
					ncr53c9x_sched_msgout(SEND_SDTR);
					break;
				case 3:
					/*
					 * Grr, this is supposed to mean
					 * "target left command phase
					 *  prematurely". It seems to happen
					 * regularly when sync mode is on.
					 * Look at FIFO to see if command
					 * went out.
					 * (Timing problems?)
					 */
					if (ncr53c9x_dmaselect) {
					    if (sc->sc_cmdlen == 0)
d1778 1
a1778 1
					} else if ((NCR_READ_REG(sc, NCR_FFLAG)
d1782 23
a1804 4
					}
					printf("(%s:%d:%d): selection failed;"
						" %d left in FIFO "
						"[intr %x, stat %x, step %d]\n",
d1808 3
a1810 3
						NCR_READ_REG(sc, NCR_FFLAG)
						 & NCRFIFO_FF,
						sc->sc_espintr, sc->sc_espstat,
d1812 3
a1814 31
					NCRCMD(sc, NCRCMD_FLUSH);
					ncr53c9x_sched_msgout(SEND_ABORT);
					return 1;
				case 2:
					/* Select stuck at Command Phase */
					NCRCMD(sc, NCRCMD_FLUSH);
				case 4:
					if (ncr53c9x_dmaselect &&
					    sc->sc_cmdlen != 0)
						printf("(%s:%d:%d): select; "
						       "%d left in DMA buffer "
						"[intr %x, stat %x, step %d]\n",
							sc->sc_dev.dv_xname,
							sc_link->target,
							sc_link->lun,
							sc->sc_cmdlen,
							sc->sc_espintr,
							sc->sc_espstat,
							sc->sc_espstep);
					/* So far, everything went fine */
					break;
				}
#if 0
				if (ecb->xs->flags & SCSI_RESET)
					ncr53c9x_sched_msgout(SEND_DEV_RESET);
				else if (ti->flags & T_NEGOTIATE)
					ncr53c9x_sched_msgout(
					    SEND_IDENTIFY | SEND_SDTR);
				else
					ncr53c9x_sched_msgout(SEND_IDENTIFY);
#endif
d1816 2
a1817 2
				ecb->flags |= ECB_NEXUS;
				ti->lubusy |= (1 << sc_link->lun);
d1819 5
a1823 21
				sc->sc_prevphase = INVALID_PHASE; /* ?? */
				/* Do an implicit RESTORE POINTERS. */
				sc->sc_dp = ecb->daddr;
				sc->sc_dleft = ecb->dleft;
				sc->sc_state = NCR_CONNECTED;
				break;
			} else {
				printf("%s: unexpected status after select"
					": [intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
				NCRCMD(sc, NCRCMD_FLUSH);
				DELAY(1);
				goto reset;
			}
			if (sc->sc_state == NCR_IDLE) {
				printf("%s: stray interrupt\n",
				    sc->sc_dev.dv_xname);
					return 0;
			}
d1826 1
a1826 3
		case NCR_CONNECTED:
			if (sc->sc_flags & NCR_ICCS) {
				u_char msg;
d1828 8
a1835 39
				sc->sc_flags &= ~NCR_ICCS;

				if (!(sc->sc_espintr & NCRINTR_DONE)) {
					printf("%s: ICCS: "
					      ": [intr %x, stat %x, step %x]\n",
						sc->sc_dev.dv_xname,
						sc->sc_espintr, sc->sc_espstat,
						sc->sc_espstep);
				}
				if ((NCR_READ_REG(sc, NCR_FFLAG)
				    & NCRFIFO_FF) != 2) {
					int i = (NCR_READ_REG(sc, NCR_FFLAG)
					    & NCRFIFO_FF) - 2;
					while (i--)
						(void) NCR_READ_REG(sc,
								    NCR_FIFO);
				}
				ecb->stat = NCR_READ_REG(sc, NCR_FIFO);
				msg = NCR_READ_REG(sc, NCR_FIFO);
				NCR_PHASE(("<stat:(%x,%x)>", ecb->stat, msg));
				if (msg == MSG_CMDCOMPLETE) {
					ecb->dleft =
					  (ecb->flags & ECB_TENTATIVE_DONE)
						? 0
						: sc->sc_dleft;
					if ((ecb->flags & ECB_SENSE) == 0)
						ecb->xs->resid = ecb->dleft;
					sc->sc_state = NCR_CMDCOMPLETE;
				} else
					printf("%s: STATUS_PHASE: msg %d\n",
						sc->sc_dev.dv_xname, msg);
				NCRCMD(sc, NCRCMD_MSGOK);
				continue; /* ie. wait for disconnect */
			}
			break;
		default:
			panic("%s: invalid state: %d",
			      sc->sc_dev.dv_xname,
			      sc->sc_state);
d1837 4
a1840 7

		/*
		 * Driver is now in state NCR_CONNECTED, i.e. we
		 * have a current command working the SCSI bus.
		 */
		if (sc->sc_state != NCR_CONNECTED || ecb == NULL) {
			panic("esp no nexus");
d1842 1
d1844 10
a1853 25
		switch (sc->sc_phase) {
		case MESSAGE_OUT_PHASE:
			NCR_PHASE(("MESSAGE_OUT_PHASE "));
			ncr53c9x_msgout(sc);
			sc->sc_prevphase = MESSAGE_OUT_PHASE;
			break;
		case MESSAGE_IN_PHASE:
			NCR_PHASE(("MESSAGE_IN_PHASE "));
			if (sc->sc_espintr & NCRINTR_BS) {
				NCRCMD(sc, NCRCMD_FLUSH);
				sc->sc_flags |= NCR_WAITI;
				NCRCMD(sc, NCRCMD_TRANS);
			} else if (sc->sc_espintr & NCRINTR_FC) {
				if ((sc->sc_flags & NCR_WAITI) == 0) {
					printf("%s: MSGIN: unexpected FC bit: "
						"[intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
				}
				sc->sc_flags &= ~NCR_WAITI;
				ncr53c9x_msgin(sc);
			} else {
				printf("%s: MSGIN: weird bits: "
					"[intr %x, stat %x, step %x]\n",
d1858 6
a1863 16
			sc->sc_prevphase = MESSAGE_IN_PHASE;
			break;
		case COMMAND_PHASE:
			/*
			 * Send the command block. Normally we don't see this
			 * phase because the SEL_ATN command takes care of
			 * all this. However, we end up here if either the
			 * target or we wanted to exchange some more messages
			 * first (e.g. to start negotiations).
			 */

			NCR_PHASE(("COMMAND_PHASE 0x%02x (%d) ",
				ecb->cmd.cmd.opcode, ecb->clen));
			if (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {
				NCRCMD(sc, NCRCMD_FLUSH);
				DELAY(1);
d1865 22
a1886 14
			if (ncr53c9x_dmaselect) {
				size_t size;
				/* setup DMA transfer for command */
				size = ecb->clen;
				sc->sc_cmdlen = size;
				sc->sc_cmdp = (caddr_t)&ecb->cmd.cmd;
				NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen,
					     0, &size);
				/* Program the SCSI counter */
				NCR_WRITE_REG(sc, NCR_TCL, size);
				NCR_WRITE_REG(sc, NCR_TCM, size >> 8);
				if (sc->sc_cfg2 & NCRCFG2_FE) {
					NCR_WRITE_REG(sc, NCR_TCH, size >> 16);
				}
d1888 7
a1894 2
				/* load the count in */
				NCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);
d1896 20
a1915 10
				/* start the command transfer */
				NCRCMD(sc, NCRCMD_TRANS | NCRCMD_DMA);
				NCRDMA_GO(sc);
			} else {
				u_char *cmd = (u_char *)&ecb->cmd.cmd;
				int i;
				/* Now the command into the FIFO */
				for (i = 0; i < ecb->clen; i++)
					NCR_WRITE_REG(sc, NCR_FIFO, *cmd++);
				NCRCMD(sc, NCRCMD_TRANS);
d1917 23
a1939 4
			sc->sc_prevphase = COMMAND_PHASE;
			break;
		case DATA_OUT_PHASE:
			NCR_PHASE(("DATA_OUT_PHASE [%ld] ",(long)sc->sc_dleft));
d1941 10
a1950 17
			size = min(sc->sc_dleft, sc->sc_maxxfer);
			NCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,
				  0, &size);
			sc->sc_prevphase = DATA_OUT_PHASE;
			goto setup_xfer;
		case DATA_IN_PHASE:
			NCR_PHASE(("DATA_IN_PHASE "));
			if (sc->sc_rev == NCR_VARIANT_ESP100)
				NCRCMD(sc, NCRCMD_FLUSH);
			size = min(sc->sc_dleft, sc->sc_maxxfer);
			NCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,
				  1, &size);
			sc->sc_prevphase = DATA_IN_PHASE;
		setup_xfer:
			/* Target returned to data phase: wipe "done" memory */
			ecb->flags &= ~ECB_TENTATIVE_DONE;

d1957 1
d1961 2
a1962 9
			/*
			 * Note that if `size' is 0, we've already transceived
			 * all the bytes we want but we're still in DATA PHASE.
			 * Apparently, the device needs padding. Also, a
			 * transfer size of 0 means "maximum" to the chip
			 * DMA logic.
			 */
			NCRCMD(sc,
			       (size==0?NCRCMD_TRPAD:NCRCMD_TRANS)|NCRCMD_DMA);
d1964 35
a1998 13
			return 1;
		case STATUS_PHASE:
			NCR_PHASE(("STATUS_PHASE "));
			sc->sc_flags |= NCR_ICCS;
			NCRCMD(sc, NCRCMD_ICCS);
			sc->sc_prevphase = STATUS_PHASE;
			break;
		case INVALID_PHASE:
			break;
		default:
			printf("%s: unexpected bus phase; resetting\n",
			    sc->sc_dev.dv_xname);
			goto reset;
d2000 26
d2027 3
a2029 1
	panic("esp: should not get here..");
d2033 1
a2033 1
	return 1;
d2044 14
a2057 2
out:
	return 1;
@


1.4
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c9x.c,v 1.3 1998/02/03 22:02:46 jason Exp $	*/
d458 1
a458 1
		    MSG_IDENTIFY(lun, (ti->flags & T_RSELECTOFF)?0:1);
d487 1
a487 1
		MSG_IDENTIFY(lun, (ti->flags & T_RSELECTOFF)?0:1));
d856 2
a857 1
		if (sc_link->target == target && sc_link->lun == lun)
@


1.3
log
@sync with netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr53c9x.c,v 1.2 1997/08/08 08:13:05 downsj Exp $	*/
/*	$NetBSD: ncr53c9x.c,v 1.22 1998/01/24 15:33:35 pk Exp $	*/
d427 1
d434 1
a434 1
		   sc_link->target, sc_link->lun, ecb->cmd.cmd.opcode));
d458 1
a458 1
		    MSG_IDENTIFY(sc_link->lun, (ti->flags & T_RSELECTOFF)?0:1);
d487 1
a487 1
		MSG_IDENTIFY(sc_link->lun, (ti->flags & T_RSELECTOFF)?0:1));
d710 1
d800 1
d870 7
a876 1
	ti->lubusy |= (1 << lun);
d1020 1
a1020 3
			if (ncr53c9x_debug & NCR_SHOWMSGS)
				printf("%s: our msg rejected by target\n",
				    sc->sc_dev.dv_xname);
d1640 5
d2080 11
a2090 2
		ncr53c9x_dequeue(sc, ecb);
		TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
d2109 1
a2109 1
	       "<state %d, nexus %p, phase(c %x, p %x), resid %lx, "
d2113 3
a2115 1
		sc->sc_state, sc->sc_nexus, sc->sc_phase, sc->sc_prevphase,
@


1.2
log
@Mostly sync to NetBSD-current 970804.

Apologies if this breaks anyone else using the MI ESP driver...
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ncr53c9x.c,v 1.16 1997/07/30 12:01:53 pk Exp $	*/
d137 1
d242 1
d428 1
d433 1
a433 1
	    sc_link->target, sc_link->lun, ecb->cmd.cmd.opcode));
a434 1
	/* new state NCR_SELECTING */
a445 2
	NCRCMD(sc, NCRCMD_FLUSH);

d453 3
a455 2
	if (ncr53c9x_dmaselect && (ti->flags & T_NEGOTIATE) == 0) {
		size_t dmacl;
d460 1
a460 1
		clen = ecb->clen + 1;
d463 2
a464 2
		dmacl = clen;
		NCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmacl);
d466 2
a467 2
		NCR_WRITE_REG(sc, NCR_TCL, clen);
		NCR_WRITE_REG(sc, NCR_TCM, clen >> 8);
d469 1
a469 1
			NCR_WRITE_REG(sc, NCR_TCH, clen >> 16);
d472 3
d480 1
d679 2
a680 1
			    sc_link->target, sc_link->lun));
d1098 1
a1098 2
					if ((sc->sc_flags&NCR_SYNCHNEGO)
					    == 0) {
d1182 7
d1259 13
a1271 1
			NCRCMD(sc, NCRCMD_RSTATN);
a1278 1
#if 1
d1288 1
a1288 1
	/* load the count in */
a1291 8
#else
	{	int i;
		for (i = 0; i < sc->sc_omlen; i++)
			NCR_WRITE_REG(sc, FIFO, sc->sc_omess[i]);
		NCRCMD(sc, NCRCMD_TRANS);
		sc->sc_omlen = 0;
	}
#endif
d1412 10
a1421 1
printf("%s: ILL: ESP100 work-around activated\n", sc->sc_dev.dv_xname);
d1459 47
a1505 17
			/*
			 * Note that this can happen during normal operation
			 * if we are reselected while using DMA to select
			 * a target.  If this is the case, don't issue the
			 * warning.
			 */
			if (sc->sc_dleft == 0 &&
			    (sc->sc_espstat & NCRSTAT_TC) == 0 &&
			    sc->sc_state != NCR_SELECTING)
				printf("%s: !TC [intr %x, stat %x, step %d]"
				       " prevphase %x, resid %x\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr,
					sc->sc_espstat,
					sc->sc_espstep,
					sc->sc_prevphase,
					ecb?ecb->dleft:-1);
d1540 1
a1628 1
if (sc->sc_flags & NCR_ICCS) printf("[[esp: BUMMER]]");
d1692 4
d1698 3
d1724 11
a1734 5
					printf("%s: select timeout/no "
					    "disconnect\n",
					    sc->sc_dev.dv_xname);
					ecb->xs->error = XS_SELTIMEOUT;
					goto finish;
d1791 2
a1792 1
						      "%d left in DMA buffer\n",
d1796 4
a1799 1
							sc->sc_cmdlen);
d1928 1
a1928 1
			 * target or we wanted exchange some more messages
d1953 4
@


1.1
log
@M.I. NCR53c9x/ESP driver, derived from sparc/alpha esp.c.  From Jason Thorpe
and NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: ncr53c9x.c,v 1.1 1997/02/27 01:12:07 thorpej Exp $	*/
d135 2
d185 1
d202 11
d238 3
d307 1
a307 2
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(ncr53c9x_timeout, ecb);
d311 1
a311 2
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(ncr53c9x_timeout, ecb);
a324 1
		int fl = sc->sc_dev.dv_cfdata->cf_flags;
d326 1
a326 1
		ti->flags = ((sc->sc_minsync && !(fl & (1<<(r+8))))
d328 1
a328 1
				((fl & (1<<r)) ? T_RSELECTOFF : 0) |
d339 1
d410 1
d430 1
a430 1
	    sc_link->target, sc_link->lun, ecb->cmd.opcode));
d435 9
d453 23
d490 1
a490 1
	cmd = (u_char *)&ecb->cmd;
d567 1
a567 2
	if ((ecb = ncr53c9x_get_ecb(sc, flags)) == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
a568 1
	}
d574 1
a574 1
	if (xs->flags & SCSI_RESET) {
d579 1
a579 1
		bcopy(xs->cmd, &ecb->cmd, xs->cmdlen);
d686 1
a686 1
	struct scsi_sense *ss = (void *)&ecb->cmd;
d698 1
d726 2
d737 1
d739 1
a739 1
			xs->error = XS_DRIVER_STUFFUP;
a744 1
			xs->status = ecb->stat;
d772 4
a775 2
		sc->sc_state = NCR_IDLE;
		ncr53c9x_sched(sc);
d996 5
a1000 1
			ecb->xs->resid = ecb->dleft = sc->sc_dleft;
d1027 11
a1037 3
			if ((ecb->xs->sc_link->quirks & SDEV_AUTOSAVE) == 0)
				break;
			/*FALLTHROUGH*/
d1297 1
d1299 1
a1299 1
	NCR_TRACE(("[ncr53c9x_intr]"));
d1389 1
a1389 1
					ecb->xs->error = XS_DRIVER_STUFFUP;
d1396 5
d1411 1
a1411 1
				ncr53c9x_init(sc, 0); /* Restart everything */
d1415 1
d1435 6
d1442 2
a1443 1
			    (sc->sc_espstat & NCRSTAT_TC) == 0)
d1525 1
d1530 1
a1530 1
				ecb->xs->error = XS_DRIVER_STUFFUP;
d1578 1
d1588 2
a1589 1
					sc_link = sc->sc_nexus->xs->sc_link;
d1592 1
a1592 1
					    sc->sc_nexus, chain);
d1606 14
a1619 2
				if ((NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF)
				    != 2) {
d1621 2
a1622 1
					    "%d bytes in FIFO!\n",
d1624 5
a1628 2
						NCR_READ_REG(sc, NCR_FFLAG) &
						NCRFIFO_FF);
d1637 4
d1695 5
a1699 1
					if ((NCR_READ_REG(sc, NCR_FFLAG)
d1721 8
a1748 6

				/* On our first connection, schedule a timeout. */
				if ((ecb->xs->flags & SCSI_POLL) == 0)
					timeout(ncr53c9x_timeout, ecb,
					    (ecb->timeout * hz) / 1000);

d1787 1
a1787 1
						    NCR_FIFO);
d1793 6
a1798 2
					ecb->xs->resid = ecb->dleft =
					    sc->sc_dleft;
d1852 8
a1859 4
		case COMMAND_PHASE: {
			/* well, this means send the command again */
			u_char *cmd = (u_char *)&ecb->cmd;
			int i;
d1862 1
a1862 1
				ecb->cmd.opcode, ecb->clen));
d1867 25
a1891 4
			/* Now the command into the FIFO */
			for (i = 0; i < ecb->clen; i++)
				NCR_WRITE_REG(sc, NCR_FIFO, *cmd++);
			NCRCMD(sc, NCRCMD_TRANS);
a1892 1
			}
d1911 3
a1954 1
	untimeout(ncr53c9x_timeout, ecb);
d2008 1
d2020 1
a2020 1
#if NCR53C9X_DEBUG > 0
d2029 1
d2036 9
@
