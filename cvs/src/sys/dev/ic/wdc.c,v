head	1.131;
access;
symbols
	OPENBSD_6_1:1.131.0.4
	OPENBSD_6_1_BASE:1.131
	OPENBSD_6_0:1.130.0.6
	OPENBSD_6_0_BASE:1.130
	OPENBSD_5_9:1.130.0.2
	OPENBSD_5_9_BASE:1.130
	OPENBSD_5_8:1.128.0.4
	OPENBSD_5_8_BASE:1.128
	OPENBSD_5_7:1.127.0.2
	OPENBSD_5_7_BASE:1.127
	OPENBSD_5_6:1.125.0.4
	OPENBSD_5_6_BASE:1.125
	OPENBSD_5_5:1.123.0.4
	OPENBSD_5_5_BASE:1.123
	OPENBSD_5_4:1.119.0.10
	OPENBSD_5_4_BASE:1.119
	OPENBSD_5_3:1.119.0.8
	OPENBSD_5_3_BASE:1.119
	OPENBSD_5_2:1.119.0.4
	OPENBSD_5_2_BASE:1.119
	OPENBSD_5_1_BASE:1.119
	OPENBSD_5_1:1.119.0.6
	OPENBSD_5_0:1.119.0.2
	OPENBSD_5_0_BASE:1.119
	OPENBSD_4_9:1.109.0.2
	OPENBSD_4_9_BASE:1.109
	OPENBSD_4_8:1.107.0.2
	OPENBSD_4_8_BASE:1.107
	OPENBSD_4_7:1.105.0.2
	OPENBSD_4_7_BASE:1.105
	OPENBSD_4_6:1.102.0.6
	OPENBSD_4_6_BASE:1.102
	OPENBSD_4_5:1.102.0.2
	OPENBSD_4_5_BASE:1.102
	OPENBSD_4_4:1.100.0.2
	OPENBSD_4_4_BASE:1.100
	OPENBSD_4_3:1.97.0.2
	OPENBSD_4_3_BASE:1.97
	OPENBSD_4_2:1.96.0.2
	OPENBSD_4_2_BASE:1.96
	OPENBSD_4_1:1.93.0.4
	OPENBSD_4_1_BASE:1.93
	OPENBSD_4_0:1.93.0.2
	OPENBSD_4_0_BASE:1.93
	OPENBSD_3_9:1.89.0.2
	OPENBSD_3_9_BASE:1.89
	OPENBSD_3_8:1.86.0.4
	OPENBSD_3_8_BASE:1.86
	OPENBSD_3_7:1.86.0.2
	OPENBSD_3_7_BASE:1.86
	OPENBSD_3_6:1.83.0.4
	OPENBSD_3_6_BASE:1.83
	SMP_SYNC_A:1.83
	SMP_SYNC_B:1.83
	OPENBSD_3_5:1.83.0.2
	OPENBSD_3_5_BASE:1.83
	OPENBSD_3_4:1.62.0.2
	OPENBSD_3_4_BASE:1.62
	UBC_SYNC_A:1.60
	OPENBSD_3_3:1.60.0.2
	OPENBSD_3_3_BASE:1.60
	OPENBSD_3_2:1.52.0.2
	OPENBSD_3_2_BASE:1.52
	OPENBSD_3_1:1.48.0.2
	OPENBSD_3_1_BASE:1.48
	UBC_SYNC_B:1.54
	UBC:1.43.0.2
	UBC_BASE:1.43
	OPENBSD_3_0:1.42.0.2
	OPENBSD_3_0_BASE:1.42
	OPENBSD_2_9_BASE:1.30
	OPENBSD_2_9:1.30.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	SMP:1.15.0.2
	SMP_BASE:1.15
	kame_19991208:1.14
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12;
locks; strict;
comment	@ * @;


1.131
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.130;
commitid	RlO92XR575sygHqm;

1.130
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.129;
commitid	NdgfPIGUgJxQPnT7;

1.129
date	2015.08.17.15.36.29;	author krw;	state Exp;
branches;
next	1.128;
commitid	Le3SuX5chjCNZy3I;

1.128
date	2015.03.09.18.50.08;	author miod;	state Exp;
branches;
next	1.127;
commitid	jLXGkn59kqqDcdQ6;

1.127
date	2014.09.29.00.07.55;	author dlg;	state Exp;
branches;
next	1.126;
commitid	ySl7oQohlGa1L94O;

1.126
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.125;
commitid	uzzBR7hz9ncd4O6G;

1.125
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.124;
commitid	I19imNlAX05zJOED;

1.124
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.123;
commitid	EF98ch02VpFassUi;

1.123
date	2014.01.24.06.21.59;	author dlg;	state Exp;
branches;
next	1.122;

1.122
date	2014.01.22.06.05.21;	author dlg;	state Exp;
branches;
next	1.121;

1.121
date	2014.01.18.20.50.24;	author dlg;	state Exp;
branches;
next	1.120;

1.120
date	2014.01.18.04.24.11;	author dlg;	state Exp;
branches;
next	1.119;

1.119
date	2011.06.10.01.38.46;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2011.05.25.03.26.20;	author matthew;	state Exp;
branches;
next	1.117;

1.117
date	2011.05.24.23.18.47;	author matthew;	state Exp;
branches;
next	1.116;

1.116
date	2011.05.09.22.33.54;	author matthew;	state Exp;
branches;
next	1.115;

1.115
date	2011.05.09.22.25.50;	author matthew;	state Exp;
branches;
next	1.114;

1.114
date	2011.05.08.17.33.56;	author matthew;	state Exp;
branches;
next	1.113;

1.113
date	2011.04.18.04.16.13;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2011.04.15.20.53.28;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2011.04.05.19.57.40;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2011.04.05.12.06.09;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.21.03.33.32;	author matthew;	state Exp;
branches;
next	1.108;

1.108
date	2010.08.29.18.40.33;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.106;

1.106
date	2010.07.22.21.52.17;	author jsg;	state Exp;
branches;
next	1.105;

1.105
date	2009.11.23.23.48.37;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2009.11.22.12.51.09;	author jsg;	state Exp;
branches;
next	1.103;

1.103
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.102;

1.102
date	2009.02.07.08.07.28;	author grange;	state Exp;
branches;
next	1.101;

1.101
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.100;

1.100
date	2008.07.02.03.00.55;	author fgsch;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.30.00.13.30;	author fgsch;	state Exp;
branches;
next	1.98;

1.98
date	2008.06.27.06.03.08;	author ray;	state Exp;
branches;
next	1.97;

1.97
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2007.05.08.16.07.03;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2007.05.08.16.01.52;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2007.04.16.18.18.21;	author grange;	state Exp;
branches;
next	1.93;

1.93
date	2006.05.22.05.21.57;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2006.05.08.00.18.40;	author jsg;	state Exp;
branches;
next	1.91;

1.91
date	2006.05.07.03.00.14;	author jsg;	state Exp;
branches;
next	1.90;

1.90
date	2006.05.03.02.18.47;	author jsg;	state Exp;
branches;
next	1.89;

1.89
date	2006.02.10.21.45.41;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2005.11.09.19.05.48;	author uwe;	state Exp;
branches;
next	1.87;

1.87
date	2005.10.21.08.50.50;	author grange;	state Exp;
branches;
next	1.86;

1.86
date	2004.10.17.17.50.48;	author grange;	state Exp;
branches;
next	1.85;

1.85
date	2004.10.17.08.58.56;	author grange;	state Exp;
branches;
next	1.84;

1.84
date	2004.09.15.17.58.25;	author grange;	state Exp;
branches;
next	1.83;

1.83
date	2004.02.19.21.16.21;	author grange;	state Exp;
branches;
next	1.82;

1.82
date	2004.01.23.20.48.33;	author grange;	state Exp;
branches;
next	1.81;

1.81
date	2003.12.16.03.37.37;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2003.11.19.21.30.43;	author grange;	state Exp;
branches;
next	1.79;

1.79
date	2003.11.17.22.44.55;	author grange;	state Exp;
branches;
next	1.78;

1.78
date	2003.11.17.21.50.13;	author grange;	state Exp;
branches;
next	1.77;

1.77
date	2003.11.13.23.29.14;	author grange;	state Exp;
branches;
next	1.76;

1.76
date	2003.11.05.20.45.18;	author grange;	state Exp;
branches;
next	1.75;

1.75
date	2003.10.31.11.46.53;	author grange;	state Exp;
branches;
next	1.74;

1.74
date	2003.10.29.19.01.11;	author matthieu;	state Exp;
branches;
next	1.73;

1.73
date	2003.10.27.20.58.17;	author grange;	state Exp;
branches;
next	1.72;

1.72
date	2003.10.26.14.39.59;	author grange;	state Exp;
branches;
next	1.71;

1.71
date	2003.10.26.14.29.47;	author grange;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.21.18.58.50;	author jmc;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.20.07.12.39;	author grange;	state Exp;
branches;
next	1.68;

1.68
date	2003.10.19.21.33.20;	author grange;	state Exp;
branches;
next	1.67;

1.67
date	2003.10.17.08.14.09;	author grange;	state Exp;
branches;
next	1.66;

1.66
date	2003.10.16.11.58.16;	author grange;	state Exp;
branches;
next	1.65;

1.65
date	2003.10.16.11.30.00;	author grange;	state Exp;
branches;
next	1.64;

1.64
date	2003.10.16.10.07.59;	author grange;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.28.21.01.43;	author grange;	state Exp;
branches;
next	1.62;

1.62
date	2003.07.06.08.25.16;	author grange;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.25.17.53.10;	author henric;	state Exp;
branches;
next	1.60;

1.60
date	2003.02.21.20.10.33;	author grange;	state Exp;
branches;
next	1.59;

1.59
date	2003.02.13.20.54.59;	author grange;	state Exp;
branches;
next	1.58;

1.58
date	2002.12.22.18.28.06;	author grange;	state Exp;
branches;
next	1.57;

1.57
date	2002.12.22.18.24.45;	author grange;	state Exp;
branches;
next	1.56;

1.56
date	2002.12.19.16.32.59;	author grange;	state Exp;
branches;
next	1.55;

1.55
date	2002.12.12.10.26.26;	author grange;	state Exp;
branches;
next	1.54;

1.54
date	2002.10.16.21.43.39;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2002.10.09.23.43.11;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.02.15.26.19;	author csapuntz;	state Exp;
branches;
next	1.51;

1.51
date	2002.05.24.09.33.29;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.24.09.24.36;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.03.09.18.46;	author gluk;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.16.17.12.09;	author csapuntz;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.01.23.00.39.47;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2002.01.12.05.36.09;	author jason;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.07.19.04.46;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2001.08.23.13.23.28;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.31.07.07.00;	author csapuntz;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.27.04.54.06;	author csapuntz;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.21.09.08.48;	author csapuntz;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.19.19.45.01;	author csapuntz;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.12.01.45.43;	author csapuntz;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.25.19.31.49;	author csapuntz;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.24.20.59.40;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.06.04.12.19;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.05.22.03.25;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.01.02.26.42;	author csapuntz;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.30.21.17.41;	author csapuntz;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.04.07.29.50;	author csapuntz;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.02.19.01.18;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.25.13.11.51;	author csapuntz;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.15.23.08.16;	author csapuntz;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.29.02.18.33;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.29.00.20.16;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.23.08.50.28;	author aaron;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.29.18.42.49;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.28.18.08.46;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.27.20.29.27;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.20.19.15.23;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.20.07.40.32;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.30.01.03.41;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.13.04.12.02;	author chris;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.10.07.06.14;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	99.12.14.08.28.15;	author csapuntz;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	99.11.17.01.22.56;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	99.10.29.16.40.22;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	99.10.29.01.15.15;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.10.28.19.59.27;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	99.10.09.03.42.04;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	99.09.05.21.43.30;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.08.05.00.12.09;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.07.23.08.34.15;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.07.23.08.04.27;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.07.22.22.42.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.07.22.04.36.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.07.22.02.54.06;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	99.07.18.22.44.48;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.07.18.21.25.16;	author csapuntz;	state Exp;
branches;
next	;

1.15.2.1
date	2001.05.14.22.24.24;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.07.04.10.41.17;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2002.03.28.12.09.41;	author niklas;	state Exp;
branches;
next	1.15.2.7;

1.15.2.7
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.15.2.8;

1.15.2.8
date	2004.02.19.10.56.21;	author niklas;	state Exp;
branches;
next	1.15.2.9;

1.15.2.9
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;

1.43.2.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.43.2.3;

1.43.2.3
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.43.2.4;

1.43.2.4
date	2003.05.19.21.59.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.131
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@/*	$OpenBSD: wdc.c,v 1.130 2015/08/28 00:03:53 deraadt Exp $	*/
/*	$NetBSD: wdc.c,v 1.68 1999/06/23 19:00:17 bouyer Exp $	*/
/*
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum, by Onno van der Linden and by Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/disk.h>
#include <sys/pool.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/ata/atavar.h>
#include <dev/ata/atareg.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>
#include <dev/ic/wdcevent.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#define WDCDELAY  100 /* 100 microseconds */
#define WDCNDELAY_RST (WDC_RESET_WAIT * 1000 / WDCDELAY)
#if 0
/* If you enable this, it will report any delays more than WDCDELAY * N long. */
#define WDCNDELAY_DEBUG	50
#endif /* 0 */

struct pool wdc_xfer_pool;
struct scsi_iopool wdc_xfer_iopool;

void *	wdc_xfer_get(void *);
void	wdc_xfer_put(void *, void *);

void  __wdcerror(struct channel_softc *, char *);
int   __wdcwait_reset(struct channel_softc *, int);
void  __wdccommand_done(struct channel_softc *, struct wdc_xfer *);
void  __wdccommand_start(struct channel_softc *, struct wdc_xfer *);
int   __wdccommand_intr(struct channel_softc *, struct wdc_xfer *, int);
int   wdprint(void *, const char *);
void  wdc_kill_pending(struct channel_softc *);

#define DEBUG_INTR    0x01
#define DEBUG_XFERS   0x02
#define DEBUG_STATUS  0x04
#define DEBUG_FUNCS   0x08
#define DEBUG_PROBE   0x10
#define DEBUG_STATUSX 0x20
#define DEBUG_SDRIVE  0x40
#define DEBUG_DETACH  0x80

#ifdef WDCDEBUG
#ifndef WDCDEBUG_MASK
#define WDCDEBUG_MASK 0x00
#endif
int wdcdebug_mask = WDCDEBUG_MASK;
int wdc_nxfer = 0;
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_mask & (level)) != 0)	\
		printf args;			\
} while (0)
#else
#define WDCDEBUG_PRINT(args, level)
#endif /* WDCDEBUG */

int at_poll = AT_POLL;

int wdc_floating_bus(struct channel_softc *, int);
int wdc_preata_drive(struct channel_softc *, int);
int wdc_ata_present(struct channel_softc *, int);

struct cfdriver wdc_cd = {
	NULL, "wdc", DV_DULL
};

struct channel_softc_vtbl wdc_default_vtbl = {
	wdc_default_read_reg,
	wdc_default_write_reg,
	wdc_default_lba48_write_reg,
	wdc_default_read_raw_multi_2,
	wdc_default_write_raw_multi_2,
	wdc_default_read_raw_multi_4,
	wdc_default_write_raw_multi_4
};

#ifdef WDCDEBUG
static char *wdc_log_buf = NULL;
static unsigned int wdc_tail = 0;
static unsigned int wdc_head = 0;
static unsigned int wdc_log_cap = 16 * 1024;
static int chp_idx = 1;

void
wdc_log(struct channel_softc *chp, enum wdcevent_type type,
    unsigned int size, char val[])
{
	unsigned int request_size;
	char *ptr;
	int log_size;
	unsigned int head = wdc_head;
	unsigned int tail = wdc_tail;

#ifdef DIAGNOSTIC
	if (head < 0 || head > wdc_log_cap ||
	    tail < 0 || tail > wdc_log_cap) {
		printf ("wdc_log: head %x wdc_tail %x\n", head,
		    tail);
		return;
	}

	if (size > wdc_log_cap / 2) {
		printf ("wdc_log: type %d size %x\n", type, size);
		return;
	}
#endif

	if (wdc_log_buf == NULL) {
		wdc_log_buf = malloc(wdc_log_cap, M_DEVBUF, M_NOWAIT);
		if (wdc_log_buf == NULL)
			return;
	}
	if (chp->ch_log_idx == 0)
		chp->ch_log_idx = chp_idx++;

	request_size = size + 2;

	/* Check how many bytes are left */
	log_size = head - tail;
	if (log_size < 0) log_size += wdc_log_cap;

	if (log_size + request_size >= wdc_log_cap) {
		int nb = 0; 
		int rec_size;

		while (nb <= (request_size * 2)) {
			if (wdc_log_buf[tail] == 0)
				rec_size = 1;
			else
				rec_size = (wdc_log_buf[tail + 1] & 0x1f) + 2;
			tail = (tail + rec_size) % wdc_log_cap;
			nb += rec_size;
		}
	}

	/* Avoid wrapping in the middle of a request */
	if (head + request_size >= wdc_log_cap) {
		memset(&wdc_log_buf[head], 0, wdc_log_cap - head);
		head = 0;
	}

	ptr = &wdc_log_buf[head];
	*ptr++ = type & 0xff;
	*ptr++ = ((chp->ch_log_idx & 0x7) << 5) | (size & 0x1f);
	memcpy(ptr, val, size);

	wdc_head = (head + request_size) % wdc_log_cap;
	wdc_tail = tail;
}

char *wdc_get_log(unsigned int *, unsigned int *);

char *
wdc_get_log(unsigned int * size, unsigned int *left)
{
	int  log_size;
	char *retbuf = NULL;
	int  nb, tocopy;
	int  s;
	unsigned int head = wdc_head;
	unsigned int tail = wdc_tail;

	s = splbio();

	log_size = (head - tail);
	if (left != NULL)
		*left = 0;

	if (log_size < 0)
		log_size += wdc_log_cap;

	tocopy = log_size;
	if ((u_int)tocopy > *size)
		tocopy = *size;

	if (wdc_log_buf == NULL) {
		*size = 0;
		*left = 0;
		goto out;
	}

#ifdef DIAGNOSTIC
	if (head < 0 || head > wdc_log_cap ||
	    tail < 0 || tail > wdc_log_cap) {
		printf ("wdc_log: head %x tail %x\n", head,
		    tail);
		*size = 0;
		*left = 0;
		goto out;
	}
#endif

	retbuf = malloc(tocopy, M_TEMP, M_NOWAIT);
	if (retbuf == NULL) {
		*size = 0;
		*left = log_size;
		goto out;
	}

	nb = 0;
	for (;;) {
		int rec_size;

		if (wdc_log_buf[tail] == 0)
			rec_size = 1;
		else
			rec_size = (wdc_log_buf[tail + 1] & 0x1f) + 2;

		if ((nb + rec_size) >= tocopy)
			break;

		memcpy(&retbuf[nb], &wdc_log_buf[tail], rec_size);
		tail = (tail + rec_size) % wdc_log_cap;
		nb += rec_size;
	}

	wdc_tail = tail;
	*size = nb;
	*left = log_size - nb;

 out:
	splx(s);
	return (retbuf);
}
#endif /* WDCDEBUG */

u_int8_t
wdc_default_read_reg(struct channel_softc *chp, enum wdc_regs reg)
{
#ifdef DIAGNOSTIC
	if (reg & _WDC_WRONLY) {
		printf ("wdc_default_read_reg: reading from a write-only register %d\n", reg);
	}
#endif /* DIAGNOSTIC */

	if (reg & _WDC_AUX)
		return (bus_space_read_1(chp->ctl_iot, chp->ctl_ioh,
		    reg & _WDC_REGMASK));
	else
		return (bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
		    reg & _WDC_REGMASK));
}

void
wdc_default_write_reg(struct channel_softc *chp, enum wdc_regs reg, u_int8_t val)
{
#ifdef DIAGNOSTIC
	if (reg & _WDC_RDONLY) {
		printf ("wdc_default_write_reg: writing to a read-only register %d\n", reg);
	}
#endif /* DIAGNOSTIC */

	if (reg & _WDC_AUX)
		bus_space_write_1(chp->ctl_iot, chp->ctl_ioh,
		    reg & _WDC_REGMASK, val);
	else
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh,
		    reg & _WDC_REGMASK, val);
}

void
wdc_default_lba48_write_reg(struct channel_softc *chp, enum wdc_regs reg,
    u_int16_t val)
{
	/* All registers are two byte deep FIFOs. */
	CHP_WRITE_REG(chp, reg, val >> 8);
	CHP_WRITE_REG(chp, reg, val);
}

void
wdc_default_read_raw_multi_2(struct channel_softc *chp, void *data,
    unsigned int nbytes)
{
	if (data == NULL) {
		unsigned int i;

		for (i = 0; i < nbytes; i += 2) {
			bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, 0);
		}

		return;
	}

	bus_space_read_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0,
	    data, nbytes);
}


void
wdc_default_write_raw_multi_2(struct channel_softc *chp, void *data,
    unsigned int nbytes)
{
	if (data == NULL) {
		unsigned int i;

		for (i = 0; i < nbytes; i += 2) {
			bus_space_write_2(chp->cmd_iot, chp->cmd_ioh, 0, 0);
		}

		return;
	}

	bus_space_write_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0,
	    data, nbytes);
}


void
wdc_default_write_raw_multi_4(struct channel_softc *chp, void *data,
    unsigned int nbytes)
{
	if (data == NULL) {
		unsigned int i;

		for (i = 0; i < nbytes; i += 4) {
			bus_space_write_4(chp->cmd_iot, chp->cmd_ioh, 0, 0);
		}

		return;
	}

	bus_space_write_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0,
	    data, nbytes);
}


void
wdc_default_read_raw_multi_4(struct channel_softc *chp, void *data,
    unsigned int nbytes)
{
	if (data == NULL) {
		unsigned int i;

		for (i = 0; i < nbytes; i += 4) {
			bus_space_read_4(chp->cmd_iot, chp->cmd_ioh, 0);
		}

		return;
	}

	bus_space_read_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0,
	    data, nbytes);
}

int
wdprint(void *aux, const char *pnp)
{
	struct ata_atapi_attach *aa_link = aux;
	if (pnp)
		printf("drive at %s", pnp);
	printf(" channel %d drive %d", aa_link->aa_channel,
	    aa_link->aa_drv_data->drive);
	return (UNCONF);
}

void
wdc_disable_intr(struct channel_softc *chp)
{
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
}

void
wdc_enable_intr(struct channel_softc *chp)
{
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
}

void
wdc_set_drive(struct channel_softc *chp, int drive)
{
	CHP_WRITE_REG(chp, wdr_sdh, (drive << 4) | WDSD_IBM);
	WDC_LOG_SET_DRIVE(chp, drive);
}

int
wdc_floating_bus(struct channel_softc *chp, int drive)
{
	u_int8_t cumulative_status, status;
	int      iter;

	wdc_set_drive(chp, drive);
	delay(10);

	/* Stolen from Phoenix BIOS Drive Autotyping document */
	cumulative_status = 0;
	for (iter = 0; iter < 100; iter++) {
		CHP_WRITE_REG(chp, wdr_seccnt, 0x7f);
		delay (1);

		status = CHP_READ_REG(chp, wdr_status);

		/* The other bits are meaningless if BSY is set */
		if (status & WDCS_BSY)
			continue;

		cumulative_status |= status;

#define BAD_BIT_COMBO  (WDCS_DRDY | WDCS_DSC | WDCS_DRQ | WDCS_ERR)
		if ((cumulative_status & BAD_BIT_COMBO) == BAD_BIT_COMBO)
			return 1;
	}


	return 0;
}

int
wdc_preata_drive(struct channel_softc *chp, int drive)
{
	if (wdc_floating_bus(chp, drive)) {
		WDCDEBUG_PRINT(("%s:%d:%d: floating bus detected\n",
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	wdc_set_drive(chp, drive);
	delay(100);
	if (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY, 10000) != 0) {
		WDCDEBUG_PRINT(("%s:%d:%d: not ready\n",
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	CHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);
	WDC_LOG_ATA_CMDSHORT(chp, WDCC_RECAL);
	if (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY, 10000) != 0) {
		WDCDEBUG_PRINT(("%s:%d:%d: WDCC_RECAL failed\n",
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	return 1;
}

int
wdc_ata_present(struct channel_softc *chp, int drive)
{
	int time_to_done;
	int retry_cnt = 0;

	wdc_set_drive(chp, drive);
	delay(10);

retry:
	/*
	   You're actually supposed to wait up to 10 seconds
	   for DRDY. However, as a practical matter, most
	   drives assert DRDY very quickly after dropping BSY.

	   The 10 seconds wait is sub-optimal because, according
	   to the ATA standard, the master should reply with 00
	   for any reads to a non-existent slave.
	*/
	time_to_done = wdc_wait_for_status(chp,
	    (WDCS_DRDY | WDCS_DSC | WDCS_DRQ),
	    (WDCS_DRDY | WDCS_DSC), 1000);
	if (time_to_done == -1) {
		if (retry_cnt == 0 && chp->ch_status == 0x00) {
			/* At least one flash card needs to be kicked */
			wdccommandshort(chp, drive, WDCC_CHECK_PWR);
			retry_cnt++;
			goto retry;
		}
		WDCDEBUG_PRINT(("%s:%d:%d: DRDY test timed out with status"
		    " %02x\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive, chp->ch_status),
		    DEBUG_PROBE);
		return 0;
	}

	if ((chp->ch_status & 0xfc) != (WDCS_DRDY | WDCS_DSC)) {
		WDCDEBUG_PRINT(("%s:%d:%d: status test for 0x50 failed with"
		    " %02x\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive, chp->ch_status),
		    DEBUG_PROBE);

		return 0;
	}

	WDCDEBUG_PRINT(("%s:%d:%d: waiting for ready %d msec\n",
	    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
	    chp->channel, drive, time_to_done), DEBUG_PROBE);

	/*
	 * Test register writability
	 */
	CHP_WRITE_REG(chp, wdr_cyl_lo, 0xaa);
	CHP_WRITE_REG(chp, wdr_cyl_hi, 0x55);
	CHP_WRITE_REG(chp, wdr_seccnt, 0xff);
	DELAY(10);

	if (CHP_READ_REG(chp, wdr_cyl_lo) != 0xaa &&
	    CHP_READ_REG(chp, wdr_cyl_hi) != 0x55) {
		WDCDEBUG_PRINT(("%s:%d:%d: register writability failed\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	return 1;
}


/*
 * Test to see controller with at least one attached drive is there.
 * Returns a bit for each possible drive found (0x01 for drive 0,
 * 0x02 for drive 1).
 * Logic:
 * - If a status register is at 0x7f or 0xff, assume there is no drive here
 *   (ISA has pull-up resistors).  Similarly if the status register has
 *   the value we last wrote to the bus (for IDE interfaces without pullups).
 *   If no drive at all -> return.
 * - reset the controller, wait for it to complete (may take up to 31s !).
 *   If timeout -> return.
 * - test ATA/ATAPI signatures. If at last one drive found -> return.
 * - try an ATA command on the master.
 */

int
wdcprobe(struct channel_softc *chp)
{
	u_int8_t st0, st1, sc, sn, cl, ch;
	u_int8_t ret_value = 0x03;
	u_int8_t drive;
#ifdef WDCDEBUG
	int savedmask = wdcdebug_mask;
#endif

	if (chp->_vtbl == 0) {
		int s = splbio();
		chp->_vtbl = &wdc_default_vtbl;
		splx(s);
	}

#ifdef WDCDEBUG
	if ((chp->ch_flags & WDCF_VERBOSE_PROBE) ||
	    (chp->wdc &&
	    (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)))
		wdcdebug_mask |= DEBUG_PROBE;
#endif /* WDCDEBUG */

	if (chp->wdc == NULL ||
	    (chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {
		/* Sample the statuses of drive 0 and 1 into st0 and st1 */
		wdc_set_drive(chp, 0);
		delay(10);
		st0 = CHP_READ_REG(chp, wdr_status);
		WDC_LOG_STATUS(chp, st0);
		wdc_set_drive(chp, 1);
		delay(10);
		st1 = CHP_READ_REG(chp, wdr_status);
		WDC_LOG_STATUS(chp, st1);

		WDCDEBUG_PRINT(("%s:%d: before reset, st0=0x%b, st1=0x%b\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, st0, WDCS_BITS, st1, WDCS_BITS),
		    DEBUG_PROBE);

		if (st0 == 0xff || st0 == WDSD_IBM)
			ret_value &= ~0x01;
		if (st1 == 0xff || st1 == (WDSD_IBM | 0x10))
			ret_value &= ~0x02;
		if (ret_value == 0)
			return 0;
	}

	/* reset the channel */
	wdc_do_reset(chp);

	ret_value = __wdcwait_reset(chp, ret_value);
	WDCDEBUG_PRINT(("%s:%d: after reset, ret_value=0x%d\n",
	    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", chp->channel,
	    ret_value), DEBUG_PROBE);

	if (ret_value == 0)
		return 0;

	/*
	 * Use signatures to find potential ATAPI drives
	 */
	for (drive = 0; drive < 2; drive++) {
 		if ((ret_value & (0x01 << drive)) == 0)
			continue;
		wdc_set_drive(chp, drive);
		delay(10);
		/* Save registers contents */
		st0 = CHP_READ_REG(chp, wdr_status);
		sc = CHP_READ_REG(chp, wdr_seccnt);
		sn = CHP_READ_REG(chp, wdr_sector);
		cl = CHP_READ_REG(chp, wdr_cyl_lo);
		ch = CHP_READ_REG(chp, wdr_cyl_hi);
		WDC_LOG_REG(chp, wdr_cyl_lo, (ch << 8) | cl);

		WDCDEBUG_PRINT(("%s:%d:%d: after reset, st=0x%b, sc=0x%x"
		    " sn=0x%x cl=0x%x ch=0x%x\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive, st0, WDCS_BITS, sc, sn, cl, ch),
		    DEBUG_PROBE);
		/*
		 * This is a simplification of the test in the ATAPI
		 * spec since not all drives seem to set the other regs
		 * correctly.
		 */
		if (cl == 0x14 && ch == 0xeb)
			chp->ch_drive[drive].drive_flags |= DRIVE_ATAPI;
	}

	/*
	 * Detect ATA drives by poking around the registers
	 */
	for (drive = 0; drive < 2; drive++) {
 		if ((ret_value & (0x01 << drive)) == 0)
			continue;
		if (chp->ch_drive[drive].drive_flags & DRIVE_ATAPI)
			continue;

		wdc_disable_intr(chp);
		/* ATA detect */
		if (wdc_ata_present(chp, drive)) {
			chp->ch_drive[drive].drive_flags |= DRIVE_ATA;
			if (chp->wdc == NULL ||
			    (chp->wdc->cap & WDC_CAPABILITY_PREATA) != 0)
				chp->ch_drive[drive].drive_flags |= DRIVE_OLD;
		} else {
			ret_value &= ~(1 << drive);
		}
		wdc_enable_intr(chp);
	}

#ifdef WDCDEBUG
	wdcdebug_mask = savedmask;
#endif
	return (ret_value);
}

struct channel_queue *
wdc_alloc_queue(void)
{
	static int inited = 0;
	struct channel_queue *queue;

	/* Initialize global data. */
	if (inited == 0) {
		/* Initialize the wdc_xfer pool. */
		pool_init(&wdc_xfer_pool, sizeof(struct wdc_xfer), 0, IPL_BIO,
		    0, "wdcxfer", NULL);
		scsi_iopool_init(&wdc_xfer_iopool, NULL,
		    wdc_xfer_get, wdc_xfer_put);
		inited = 1;
	}

	queue = malloc(sizeof(*queue), M_DEVBUF, M_NOWAIT);
	if (queue != NULL) {
		TAILQ_INIT(&queue->sc_xfer);
	}
	return (queue);
}

void
wdc_free_queue(struct channel_queue *queue)
{
	free(queue, M_DEVBUF, sizeof(*queue));
}

void
wdcattach(struct channel_softc *chp)
{
	int i;
	struct ata_atapi_attach aa_link;
#ifdef WDCDEBUG
	int    savedmask = wdcdebug_mask;
#endif

	if (!cold)
		at_poll = AT_WAIT;

	if (chp->wdc->reset == NULL)
		chp->wdc->reset = wdc_do_reset;

	timeout_set(&chp->ch_timo, wdctimeout, chp);

	if (!chp->_vtbl)
		chp->_vtbl = &wdc_default_vtbl;

	for (i = 0; i < 2; i++) {
		chp->ch_drive[i].chnl_softc = chp;
		chp->ch_drive[i].drive = i;
	}

	if (chp->wdc->drv_probe != NULL) {
		chp->wdc->drv_probe(chp);
	} else {
		if (wdcprobe(chp) == 0)
			/* If no drives, abort attach here. */
			return;
	}

	/* ATAPI drives need settling time. Give them 250ms */
	if ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||
	    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {
		delay(250 * 1000);
	}

#ifdef WDCDEBUG
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_mask |= DEBUG_PROBE;

	if ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||
	    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {
		wdcdebug_mask = DEBUG_PROBE;
	}
#endif /* WDCDEBUG */

	for (i = 0; i < 2; i++) {
		struct ata_drive_datas *drvp = &chp->ch_drive[i];

		/* If controller can't do 16bit flag the drives as 32bit */
		if ((chp->wdc->cap &
		    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==
		    WDC_CAPABILITY_DATA32)
			drvp->drive_flags |= DRIVE_CAP32;

		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		if (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))
			chp->ch_flags |= WDCF_ONESLAVE;
		/*
		 * Wait a bit, some devices are weird just after a reset.
		 * Then issue a IDENTIFY command, to try to detect slave ghost.
		 */
		delay(5000);
		if (ata_get_params(&chp->ch_drive[i], at_poll, &drvp->id) ==
		    CMD_OK) {
			/* If IDENTIFY succeeded, this is not an OLD ctrl */
			drvp->drive_flags &= ~DRIVE_OLD;
		} else {
			bzero(&drvp->id, sizeof(struct ataparams));
			drvp->drive_flags &=
			    ~(DRIVE_ATA | DRIVE_ATAPI);
			WDCDEBUG_PRINT(("%s:%d:%d: IDENTIFY failed\n",
			    chp->wdc->sc_dev.dv_xname,
			    chp->channel, i), DEBUG_PROBE);

			if ((drvp->drive_flags & DRIVE_OLD) &&
			    !wdc_preata_drive(chp, i))
				drvp->drive_flags &= ~DRIVE_OLD;
		}
	}

	WDCDEBUG_PRINT(("wdcattach: ch_drive_flags 0x%x 0x%x\n",
	    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),
	    DEBUG_PROBE);

	/* If no drives, abort here */
	if ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&
	    (chp->ch_drive[1].drive_flags & DRIVE) == 0)
		goto exit;

	for (i = 0; i < 2; i++) {
		if ((chp->ch_drive[i].drive_flags & DRIVE) == 0) {
			continue;
		}
		bzero(&aa_link, sizeof(struct ata_atapi_attach));
		if (chp->ch_drive[i].drive_flags & DRIVE_ATAPI)
			aa_link.aa_type = T_ATAPI;
		else
			aa_link.aa_type = T_ATA;
		aa_link.aa_channel = chp->channel;
		aa_link.aa_openings = 1;
		aa_link.aa_drv_data = &chp->ch_drive[i];
		config_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);
	}

	/*
	 * reset drive_flags for unattached devices, reset state for attached
	 *  ones
	 */
	for (i = 0; i < 2; i++) {
		if (chp->ch_drive[i].drive_name[0] == 0)
			chp->ch_drive[i].drive_flags = 0;
	}

exit:
#ifdef WDCDEBUG
	wdcdebug_mask = savedmask;
#endif
	return;	/* for the ``exit'' label above */
}

/*
 * Start I/O on a controller, for the given channel.
 * The first xfer may be not for our channel if the channel queues
 * are shared.
 */
void
wdcstart(struct channel_softc *chp)
{
	struct wdc_xfer *xfer;

	splassert(IPL_BIO);

	/* is there a xfer ? */
	if ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) == NULL) {
		return;
	}

	/* adjust chp, in case we have a shared queue */
	chp = xfer->chp;

	if ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {
		return; /* channel already active */
	}
#ifdef DIAGNOSTIC
	if ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)
		panic("wdcstart: channel waiting for irq");
#endif /* DIAGNOSTIC */

	WDCDEBUG_PRINT(("wdcstart: xfer %p channel %d drive %d\n", xfer,
	    chp->channel, xfer->drive), DEBUG_XFERS);
	chp->ch_flags |= WDCF_ACTIVE;
	if (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {
		chp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;
		chp->ch_drive[xfer->drive].state = 0;
	}
	xfer->c_start(chp, xfer);
}

int
wdcdetach(struct channel_softc *chp, int flags)
{
	int s, rv;

	s = splbio();
	chp->dying = 1;

	wdc_kill_pending(chp);
	timeout_del(&chp->ch_timo);

	rv = config_detach_children((struct device *)chp->wdc, flags);
	splx(s);

	return (rv);
}

/*
 * Interrupt routine for the controller.  Acknowledge the interrupt, check for
 * errors on the current operation, mark it done if necessary, and start the
 * next request.  Also check for a partially done transfer, and continue with
 * the next chunk if so.
 */
int
wdcintr(void *arg)
{
	struct channel_softc *chp = arg;
	struct wdc_xfer *xfer;
	u_int8_t st = 0;
	int ret = 0;

	if ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {
		/* Acknowledge interrupt by reading status */
		if (chp->_vtbl == 0)
			st = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
			    wdr_status & _WDC_REGMASK);
		else
			st = CHP_READ_REG(chp, wdr_status);
		if (st == 0xff)
			return (-1);

		WDCDEBUG_PRINT(("wdcintr: inactive controller\n"), DEBUG_INTR);
		return ret;
	}

	WDCDEBUG_PRINT(("wdcintr\n"), DEBUG_INTR);
	xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
	if (chp->ch_flags & WDCF_DMA_WAIT) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, chp->channel,
		    xfer->drive, 0);
		if (chp->wdc->dma_status == 0xff)
			return (-1);
		if (chp->wdc->dma_status & WDC_DMAST_NOIRQ) {
			/* IRQ not for us, not detected by DMA engine */
			return 0;
		}
		chp->ch_flags &= ~WDCF_DMA_WAIT;
	}
		
	chp->ch_flags &= ~WDCF_IRQ_WAIT;
	ret = xfer->c_intr(chp, xfer, 1);
	if (ret == 0)	/* irq was not for us, still waiting for irq */
		chp->ch_flags |= WDCF_IRQ_WAIT;
	return (ret);
}

/* Put all disk in RESET state */
void
wdc_reset_channel(struct ata_drive_datas *drvp, int nowait)
{
	struct channel_softc *chp = drvp->chnl_softc;
	int drive;

	WDCDEBUG_PRINT(("ata_reset_channel %s:%d for drive %d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),
	    DEBUG_FUNCS);
	(void) wdcreset(chp, nowait ? NOWAIT : VERBOSE);
	for (drive = 0; drive < 2; drive++) {
		chp->ch_drive[drive].state = 0;
	}
}

int
wdcreset(struct channel_softc *chp, int flags)
{
	int drv_mask1, drv_mask2;

	if (!chp->_vtbl)
		chp->_vtbl = &wdc_default_vtbl;

	chp->wdc->reset(chp);

	if (flags & NOWAIT)
		return 0;

	drv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;
	drv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;
	drv_mask2 = __wdcwait_reset(chp, drv_mask1);

	if ((flags & VERBOSE) && drv_mask2 != drv_mask1) {
		printf("%s channel %d: reset failed for",
		    chp->wdc->sc_dev.dv_xname, chp->channel);
		if ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)
			printf(" drive 0");
		if ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)
			printf(" drive 1");
		printf("\n");
	}

	return (drv_mask1 != drv_mask2) ? 1 : 0;
}

void
wdc_do_reset(struct channel_softc *chp)
{
	wdc_set_drive(chp, 0);
	DELAY(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT | WDCTL_RST);
	delay(10000);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
	delay(10000);
}

int
__wdcwait_reset(struct channel_softc *chp, int drv_mask)
{
	int timeout;
	u_int8_t st0, er0, st1, er1;

	/* wait for BSY to deassert */
	for (timeout = 0; timeout < WDCNDELAY_RST; timeout++) {
		wdc_set_drive(chp, 0);
		delay(10);
		st0 = CHP_READ_REG(chp, wdr_status);
		er0 = CHP_READ_REG(chp, wdr_error);
		wdc_set_drive(chp, 1);
		delay(10);
		st1 = CHP_READ_REG(chp, wdr_status);
		er1 = CHP_READ_REG(chp, wdr_error);

		if ((drv_mask & 0x01) == 0) {
			/* no master */
			if ((drv_mask & 0x02) != 0 && (st1 & WDCS_BSY) == 0) {
				/* No master, slave is ready, it's done */
				goto end;
			}
		} else if ((drv_mask & 0x02) == 0) {
			/* no slave */
			if ((drv_mask & 0x01) != 0 && (st0 & WDCS_BSY) == 0) {
				/* No slave, master is ready, it's done */
				goto end;
			}
		} else {
			/* Wait for both master and slave to be ready */
			if ((st0 & WDCS_BSY) == 0 && (st1 & WDCS_BSY) == 0) {
				goto end;
			}
		}
		delay(WDCDELAY);
	}
	/* Reset timed out. Maybe it's because drv_mask was not right */
	if (st0 & WDCS_BSY)
		drv_mask &= ~0x01;
	if (st1 & WDCS_BSY)
		drv_mask &= ~0x02;
end:
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%b, er0=0x%x, "
	    "st1=0x%b, er1=0x%x, reset time=%d msec\n",
	    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", chp->channel,
	    st0, WDCS_BITS, er0, st1, WDCS_BITS, er1,
	    timeout * WDCDELAY / 1000), DEBUG_PROBE);

	return drv_mask;
}

/*
 * Wait for a drive to be !BSY, and have mask in its status register.
 * return -1 for a timeout after "timeout" ms.
 */
int
wdc_wait_for_status(struct channel_softc *chp, int mask, int bits, int timeout)
{
	u_char status;
	int time = 0;

	WDCDEBUG_PRINT(("wdcwait %s:%d\n", chp->wdc ?chp->wdc->sc_dev.dv_xname
	    :"none", chp->channel), DEBUG_STATUS);
	chp->ch_error = 0;

	timeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */

	for (;;) {
		chp->ch_status = status = CHP_READ_REG(chp, wdr_status);
		WDC_LOG_STATUS(chp, chp->ch_status);

		if (status == 0xff) {
			if ((chp->ch_flags & WDCF_ONESLAVE)) {
				wdc_set_drive(chp, 1);
				chp->ch_status = status =
				    CHP_READ_REG(chp, wdr_status);
				WDC_LOG_STATUS(chp, chp->ch_status);
			}
		}
		if ((status & WDCS_BSY) == 0 && (status & mask) == bits)
			break;
		if (++time > timeout) {
			WDCDEBUG_PRINT(("wdcwait: timeout, status 0x%b "
			    "error 0x%x\n", status, WDCS_BITS,
			    CHP_READ_REG(chp, wdr_error)),
			    DEBUG_STATUSX | DEBUG_STATUS);
			return -1;
		}
		delay(WDCDELAY);
	}
	if (status & WDCS_ERR) {
		chp->ch_error = CHP_READ_REG(chp, wdr_error);
		WDC_LOG_ERROR(chp, chp->ch_error);

		WDCDEBUG_PRINT(("wdcwait: error %x\n", chp->ch_error),
			       DEBUG_STATUSX | DEBUG_STATUS);
	}

#ifdef WDCNDELAY_DEBUG
	/* After autoconfig, there should be no long delays. */
	if (!cold && time > WDCNDELAY_DEBUG) {
		struct wdc_xfer *xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
		if (xfer == NULL)
			printf("%s channel %d: warning: busy-wait took %dus\n",
			    chp->wdc->sc_dev.dv_xname, chp->channel,
			    WDCDELAY * time);
		else
			printf("%s:%d:%d: warning: busy-wait took %dus\n",
			    chp->wdc->sc_dev.dv_xname, chp->channel,
			    xfer->drive,
			    WDCDELAY * time);
	}
#endif /* WDCNDELAY_DEBUG */
	return time;
}

/*
 * Busy-wait for DMA to complete
 */
int
wdc_dmawait(struct channel_softc *chp, struct wdc_xfer *xfer, int timeout)
{
	int time;
	for (time = 0; time < timeout * 1000 / WDCDELAY; time++) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
		    chp->channel, xfer->drive, 0);
		if ((chp->wdc->dma_status & WDC_DMAST_NOIRQ) == 0)
			return 0;
		if (chp->wdc->dma_status == 0xff) {
			chp->dying = 1;
			return -1;
		}
		delay(WDCDELAY);
	}
	/* timeout, force a DMA halt */
	chp->wdc->dma_status = (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
	    chp->channel, xfer->drive, 1);
	return 1;
}

void
wdctimeout(void *arg)
{
	struct channel_softc *chp = (struct channel_softc *)arg;
	struct wdc_xfer *xfer;
	int s;

	WDCDEBUG_PRINT(("wdctimeout\n"), DEBUG_FUNCS);

	s = splbio();
	xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);

	/* Did we lose a race with the interrupt? */
	if (xfer == NULL ||
	    !timeout_triggered(&chp->ch_timo)) {
		splx(s);
		return;
	}
	if ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {
		__wdcerror(chp, "timeout");
		printf("\ttype: %s\n", (xfer->c_flags & C_ATAPI) ?
		    "atapi":"ata");
		printf("\tc_bcount: %d\n", xfer->c_bcount);
		printf("\tc_skip: %d\n", xfer->c_skip);
		if (chp->ch_flags & WDCF_DMA_WAIT) {
			chp->wdc->dma_status =
			    (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
			    chp->channel, xfer->drive, 1);
			chp->ch_flags &= ~WDCF_DMA_WAIT;
		}
		/*
		 * Call the interrupt routine. If we just missed and interrupt,
		 * it will do what's needed. Else, it will take the needed
		 * action (reset the device).
		 */
		xfer->c_flags |= C_TIMEOU;
		chp->ch_flags &= ~WDCF_IRQ_WAIT;
		xfer->c_intr(chp, xfer, 1);
	} else
		__wdcerror(chp, "missing untimeout");
	splx(s);
}

/*
 * Probe drive's capabilities, for use by the controller later.
 * Assumes drvp points to an existing drive.
 * XXX this should be a controller-indep function
 */
void
wdc_probe_caps(struct ata_drive_datas *drvp, struct ataparams *params)
{
	struct channel_softc *chp = drvp->chnl_softc;
	struct wdc_softc *wdc = chp->wdc;
	int i, valid_mode_found;
	int cf_flags = drvp->cf_flags;

	if ((wdc->cap & (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==
	    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) {
		struct ataparams params2;

		/*
		 * Controller claims 16 and 32 bit transfers.
		 * Re-do an IDENTIFY with 32-bit transfers,
		 * and compare results.
		 */
		drvp->drive_flags |= DRIVE_CAP32;
		ata_get_params(drvp, at_poll, &params2);
		if (bcmp(params, &params2, sizeof(struct ataparams)) != 0) {
			/* Not good. fall back to 16bits */
			drvp->drive_flags &= ~DRIVE_CAP32;
		}
	}
#if 0 /* Some ultra-DMA drives claims to only support ATA-3. sigh */
	if (params->atap_ata_major > 0x01 &&
	    params->atap_ata_major != 0xffff) {
		for (i = 14; i > 0; i--) {
			if (params->atap_ata_major & (1 << i)) {
				printf("%sATA version %d\n", sep, i);
				drvp->ata_vers = i;
				break;
			}
		}
	} else
#endif /* 0 */
	/* Use PIO mode 3 as a default value for ATAPI devices */
	if (drvp->drive_flags & DRIVE_ATAPI)
		drvp->PIO_mode = 3;

	WDCDEBUG_PRINT(("wdc_probe_caps: wdc_cap 0x%x cf_flags 0x%x\n",
	    wdc->cap, cf_flags), DEBUG_PROBE);

	valid_mode_found = 0;

	WDCDEBUG_PRINT(("%s: atap_oldpiotiming=%d\n", __func__,
	    params->atap_oldpiotiming), DEBUG_PROBE);
	/*
	 * ATA-4 compliant devices contain PIO mode
	 * number in atap_oldpiotiming.
	 */
	if (params->atap_oldpiotiming <= 2) {
		drvp->PIO_cap = params->atap_oldpiotiming;
		valid_mode_found = 1;
		drvp->drive_flags |= DRIVE_MODE;
	} else if (params->atap_oldpiotiming > 180) {
		/*
		 * ATA-2 compliant devices contain cycle
		 * time in atap_oldpiotiming.
		 * A device with a cycle time of 180ns
		 * or less is at least PIO mode 3 and
		 * should be reporting that in
		 * atap_piomode_supp, so ignore it here.
		 */
		if (params->atap_oldpiotiming <= 240) {
			drvp->PIO_cap = 2;
		} else {
			drvp->PIO_cap = 1;
		}
		valid_mode_found = 1;
		drvp->drive_flags |= DRIVE_MODE;
	}
	if (valid_mode_found)
		drvp->PIO_mode = drvp->PIO_cap;

	WDCDEBUG_PRINT(("%s: atap_extensions=0x%x, atap_piomode_supp=0x%x, "
	    "atap_dmamode_supp=0x%x, atap_udmamode_supp=0x%x\n",
	    __func__, params->atap_extensions, params->atap_piomode_supp,
	    params->atap_dmamode_supp, params->atap_udmamode_supp),
	    DEBUG_PROBE);

	/*
	 * It's not in the specs, but it seems that some drive
	 * returns 0xffff in atap_extensions when this field is invalid
	 */
	if (params->atap_extensions != 0xffff &&
	    (params->atap_extensions & WDC_EXT_MODES)) {
		/*
		 * XXX some drives report something wrong here (they claim to
		 * support PIO mode 8 !). As mode is coded on 3 bits in
		 * SET FEATURE, limit it to 7 (so limit i to 4).
		 * If higher mode than 7 is found, abort.
		 */
		for (i = 7; i >= 0; i--) {
			if ((params->atap_piomode_supp & (1 << i)) == 0)
				continue;
			if (i > 4)
				return;

			valid_mode_found = 1;

			if ((wdc->cap & WDC_CAPABILITY_MODE) == 0) {
				drvp->PIO_cap = i + 3;
				continue;
			}

			/*
			 * See if mode is accepted.
			 * If the controller can't set its PIO mode,
			 * assume the BIOS set it up correctly
			 */
			if (ata_set_mode(drvp, 0x08 | (i + 3),
			    at_poll) != CMD_OK)
				continue;

			/*
			 * If controller's driver can't set its PIO mode,
			 * set the highest one the controller supports
			 */
			if (wdc->PIO_cap >= i + 3) {
				drvp->PIO_mode = i + 3;
				drvp->PIO_cap = i + 3;
				break;
			}
		}
		if (!valid_mode_found) {
			/*
			 * We didn't find a valid PIO mode.
			 * Assume the values returned for DMA are buggy too
			 */
			return;
		}
		drvp->drive_flags |= DRIVE_MODE;

		/* Some controllers don't support ATAPI DMA */
		if ((drvp->drive_flags & DRIVE_ATAPI) &&
		    (wdc->cap & WDC_CAPABILITY_NO_ATAPI_DMA))
			return;

		valid_mode_found = 0;
		for (i = 7; i >= 0; i--) {
			if ((params->atap_dmamode_supp & (1 << i)) == 0)
				continue;
			if ((wdc->cap & WDC_CAPABILITY_DMA) &&
			    (wdc->cap & WDC_CAPABILITY_MODE))
				if (ata_set_mode(drvp, 0x20 | i, at_poll)
				    != CMD_OK)
					continue;

			valid_mode_found = 1;

			if (wdc->cap & WDC_CAPABILITY_DMA) {
				if ((wdc->cap & WDC_CAPABILITY_MODE) &&
				    wdc->DMA_cap < i)
					continue;
				drvp->DMA_mode = i;
				drvp->DMA_cap = i;
				drvp->drive_flags |= DRIVE_DMA;
			}
			break;
		}
		if (params->atap_extensions & WDC_EXT_UDMA_MODES) {
			for (i = 7; i >= 0; i--) {
				if ((params->atap_udmamode_supp & (1 << i))
				    == 0)
					continue;
				if ((wdc->cap & WDC_CAPABILITY_MODE) &&
				    (wdc->cap & WDC_CAPABILITY_UDMA))
					if (ata_set_mode(drvp, 0x40 | i,
					    at_poll) != CMD_OK)
						continue;
				if (wdc->cap & WDC_CAPABILITY_UDMA) {
					if ((wdc->cap & WDC_CAPABILITY_MODE) &&
					    wdc->UDMA_cap < i)
						continue;
					drvp->UDMA_mode = i;
					drvp->UDMA_cap = i;
					drvp->drive_flags |= DRIVE_UDMA;
				}
				break;
			}
		}
	}

	/* Try to guess ATA version here, if it didn't get reported */
	if (drvp->ata_vers == 0) {
		if (drvp->drive_flags & DRIVE_UDMA)
			drvp->ata_vers = 4; /* should be at last ATA-4 */
		else if (drvp->PIO_cap > 2)
			drvp->ata_vers = 2; /* should be at last ATA-2 */
	}
	if (cf_flags & ATA_CONFIG_PIO_SET) {
		drvp->PIO_mode =
		    (cf_flags & ATA_CONFIG_PIO_MODES) >> ATA_CONFIG_PIO_OFF;
		drvp->drive_flags |= DRIVE_MODE;
	}
	if ((wdc->cap & WDC_CAPABILITY_DMA) == 0) {
		/* don't care about DMA modes */
		return;
	}
	if (cf_flags & ATA_CONFIG_DMA_SET) {
		if ((cf_flags & ATA_CONFIG_DMA_MODES) ==
		    ATA_CONFIG_DMA_DISABLE) {
			drvp->drive_flags &= ~DRIVE_DMA;
		} else {
			drvp->DMA_mode = (cf_flags & ATA_CONFIG_DMA_MODES) >>
			    ATA_CONFIG_DMA_OFF;
			drvp->drive_flags |= DRIVE_DMA | DRIVE_MODE;
		}
	}
	if ((wdc->cap & WDC_CAPABILITY_UDMA) == 0) {
		/* don't care about UDMA modes */
		return;
	}
	if (cf_flags & ATA_CONFIG_UDMA_SET) {
		if ((cf_flags & ATA_CONFIG_UDMA_MODES) ==
		    ATA_CONFIG_UDMA_DISABLE) {
			drvp->drive_flags &= ~DRIVE_UDMA;
		} else {
			drvp->UDMA_mode = (cf_flags & ATA_CONFIG_UDMA_MODES) >>
			    ATA_CONFIG_UDMA_OFF;
			drvp->drive_flags |= DRIVE_UDMA | DRIVE_MODE;
		}
	}
}

void
wdc_output_bytes(struct ata_drive_datas *drvp, void *bytes, unsigned int buflen)
{
	struct channel_softc *chp = drvp->chnl_softc;
	unsigned int off = 0;
	unsigned int len = buflen, roundlen;

	if (drvp->drive_flags & DRIVE_CAP32) {
		roundlen = len & ~3;

		CHP_WRITE_RAW_MULTI_4(chp,
		    (void *)((u_int8_t *)bytes + off), roundlen);

		off += roundlen;
		len -= roundlen;
	}

	if (len > 0) {
		roundlen = (len + 1) & ~0x1;

		CHP_WRITE_RAW_MULTI_2(chp,
		    (void *)((u_int8_t *)bytes + off), roundlen);
	}
}

void
wdc_input_bytes(struct ata_drive_datas *drvp, void *bytes, unsigned int buflen)
{
	struct channel_softc *chp = drvp->chnl_softc;
	unsigned int off = 0;
	unsigned int len = buflen, roundlen;

	if (drvp->drive_flags & DRIVE_CAP32) {
		roundlen = len & ~3;

		CHP_READ_RAW_MULTI_4(chp,
		    (void *)((u_int8_t *)bytes + off), roundlen);

		off += roundlen;
		len -= roundlen;
	}

	if (len > 0) {
		roundlen = (len + 1) & ~0x1;

		CHP_READ_RAW_MULTI_2(chp,
		    (void *)((u_int8_t *)bytes + off), roundlen);
	}
}

void
wdc_print_caps(struct ata_drive_datas *drvp)
{
	/* This is actually a lie until we fix the _probe_caps
	   algorithm. Don't print out lies */
#if 0
 	printf("%s: can use ", drvp->drive_name);

	if (drvp->drive_flags & DRIVE_CAP32) {
		printf("32-bit");
	} else
		printf("16-bit");

	printf(", PIO mode %d", drvp->PIO_cap);

	if (drvp->drive_flags & DRIVE_DMA) {
		printf(", DMA mode %d", drvp->DMA_cap);
	}

	if (drvp->drive_flags & DRIVE_UDMA) {
		printf(", Ultra-DMA mode %d", drvp->UDMA_cap);
	}

	printf("\n");
#endif /* 0 */
}

void
wdc_print_current_modes(struct channel_softc *chp)
{
	int drive;
	struct ata_drive_datas *drvp;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		printf("%s(%s:%d:%d):",
 		    drvp->drive_name,
		    chp->wdc->sc_dev.dv_xname, chp->channel, drive);

		if ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0 &&
		    !(drvp->cf_flags & ATA_CONFIG_PIO_SET))
			printf(" using BIOS timings");
		else
			printf(" using PIO mode %d", drvp->PIO_mode);
		if (drvp->drive_flags & DRIVE_DMA)
			printf(", DMA mode %d", drvp->DMA_mode);
		if (drvp->drive_flags & DRIVE_UDMA)
			printf(", Ultra-DMA mode %d", drvp->UDMA_mode);
		printf("\n");
	}
}

/*
 * downgrade the transfer mode of a drive after an error. return 1 if
 * downgrade was possible, 0 otherwise.
 */
int
wdc_downgrade_mode(struct ata_drive_datas *drvp)
{
	struct channel_softc *chp = drvp->chnl_softc;
	struct wdc_softc *wdc = chp->wdc;
	int cf_flags = drvp->cf_flags;

	/* if drive or controller don't know its mode, we can't do much */
	if ((drvp->drive_flags & DRIVE_MODE) == 0 ||
	    (wdc->cap & WDC_CAPABILITY_MODE) == 0)
		return 0;
	/* current drive mode was set by a config flag, let it this way */
	if ((cf_flags & ATA_CONFIG_PIO_SET) ||
	    (cf_flags & ATA_CONFIG_DMA_SET) ||
	    (cf_flags & ATA_CONFIG_UDMA_SET))
		return 0;

	/*
	 * We'd ideally like to use an Ultra DMA mode since they have the
	 * protection of a CRC. So we try each Ultra DMA mode and see if
	 * we can find any working combo
	 */
	if ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode > 0) {
		drvp->UDMA_mode = drvp->UDMA_mode - 1;
		printf("%s: transfer error, downgrading to Ultra-DMA mode %d\n",
		    drvp->drive_name, drvp->UDMA_mode);
	} else 	if ((drvp->drive_flags & DRIVE_UDMA) &&
	    (drvp->drive_flags & DRIVE_DMAERR) == 0) {
		/*
		 * If we were using ultra-DMA, don't downgrade to
		 * multiword DMA if we noticed a CRC error. It has
		 * been noticed that CRC errors in ultra-DMA lead to
		 * silent data corruption in multiword DMA.  Data
		 * corruption is less likely to occur in PIO mode.
		 */
		drvp->drive_flags &= ~DRIVE_UDMA;
		drvp->drive_flags |= DRIVE_DMA;
		drvp->DMA_mode = drvp->DMA_cap;
		printf("%s: transfer error, downgrading to DMA mode %d\n",
		    drvp->drive_name, drvp->DMA_mode);
	} else if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {
		drvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);
		drvp->PIO_mode = drvp->PIO_cap;
		printf("%s: transfer error, downgrading to PIO mode %d\n",
		    drvp->drive_name, drvp->PIO_mode);
	} else /* already using PIO, can't downgrade */
		return 0;

	wdc->set_modes(chp);
	/* reset the channel, which will schedule all drives for setup */
	wdc_reset_channel(drvp, 0);
	return 1;
}

int
wdc_exec_command(struct ata_drive_datas *drvp, struct wdc_command *wdc_c)
{
	struct channel_softc *chp = drvp->chnl_softc;
	struct wdc_xfer *xfer;
	int s, ret;

	WDCDEBUG_PRINT(("wdc_exec_command %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),
	    DEBUG_FUNCS);

	/* set up an xfer and queue. Wait for completion */
	xfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :
	    WDC_NOSLEEP);
	if (xfer == NULL) {
		return WDC_TRY_AGAIN;
	}

	if (wdc_c->flags & AT_POLL)
		xfer->c_flags |= C_POLL;
	xfer->drive = drvp->drive;
	xfer->databuf = wdc_c->data;
	xfer->c_bcount = wdc_c->bcount;
	xfer->cmd = wdc_c;
	xfer->c_start = __wdccommand_start;
	xfer->c_intr = __wdccommand_intr;
	xfer->c_kill_xfer = __wdccommand_done;

	s = splbio();
	wdc_exec_xfer(chp, xfer);
#ifdef DIAGNOSTIC
	if ((wdc_c->flags & AT_POLL) != 0 &&
	    (wdc_c->flags & AT_DONE) == 0)
		panic("wdc_exec_command: polled command not done");
#endif /* DIAGNOSTIC */
	if (wdc_c->flags & AT_DONE) {
		ret = WDC_COMPLETE;
	} else {
		if (wdc_c->flags & AT_WAIT) {
			WDCDEBUG_PRINT(("wdc_exec_command sleeping\n"),
				       DEBUG_FUNCS);

			while ((wdc_c->flags & AT_DONE) == 0) {
				tsleep(wdc_c, PRIBIO, "wdccmd", 0);
			}
			ret = WDC_COMPLETE;
		} else {
			ret = WDC_QUEUED;
		}
	}
	splx(s);
	return ret;
}

void
__wdccommand_start(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	int drive = xfer->drive;
	struct wdc_command *wdc_c = xfer->cmd;

	WDCDEBUG_PRINT(("__wdccommand_start %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),
	    DEBUG_FUNCS);

	/*
	 * Disable interrupts if we're polling
	 */
	if (xfer->c_flags & C_POLL) {
		wdc_disable_intr(chp);
	}

	wdc_set_drive(chp, drive);
	DELAY(1);

	/*
	 * For resets, we don't really care to make sure that
	 * the bus is free
	 */
	if (wdc_c->r_command != ATAPI_SOFT_RESET) {
		if (wdcwait(chp, wdc_c->r_st_bmask | WDCS_DRQ,
		    wdc_c->r_st_bmask, wdc_c->timeout) != 0) {
			goto timeout;
		}
	} else
		DELAY(10);

	wdccommand(chp, drive, wdc_c->r_command, wdc_c->r_cyl, wdc_c->r_head,
	    wdc_c->r_sector, wdc_c->r_count, wdc_c->r_features);

	if ((wdc_c->flags & AT_WRITE) == AT_WRITE) {
		/* wait at least 400ns before reading status register */
		DELAY(10);
		if (wait_for_unbusy(chp, wdc_c->timeout) != 0)
			goto timeout;

		if ((chp->ch_status & (WDCS_DRQ | WDCS_ERR)) == WDCS_ERR) {
			__wdccommand_done(chp, xfer);
			return;
		}

		if (wait_for_drq(chp, wdc_c->timeout) != 0)
			goto timeout;

		wdc_output_bytes(&chp->ch_drive[drive],
		    wdc_c->data, wdc_c->bcount);
	}

	if ((wdc_c->flags & AT_POLL) == 0) {
		chp->ch_flags |= WDCF_IRQ_WAIT; /* wait for interrupt */
		timeout_add_msec(&chp->ch_timo, wdc_c->timeout);
		return;
	}

	/*
	 * Polled command. Wait for drive ready or drq. Done in intr().
	 * Wait for at last 400ns for status bit to be valid.
	 */
	delay(10);
	__wdccommand_intr(chp, xfer, 0);
	return;

timeout:	
	wdc_c->flags |= AT_TIMEOU;
	__wdccommand_done(chp, xfer);
}

int
__wdccommand_intr(struct channel_softc *chp, struct wdc_xfer *xfer, int irq)
{
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	struct wdc_command *wdc_c = xfer->cmd;
	int bcount = wdc_c->bcount;
	char *data = wdc_c->data;

	WDCDEBUG_PRINT(("__wdccommand_intr %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_INTR);
	if (wdcwait(chp, wdc_c->r_st_pmask, wdc_c->r_st_pmask,
	    (irq == 0) ? wdc_c->timeout : 0)) {
		if (chp->dying) {
			__wdccommand_done(chp, xfer);
			return -1;
		}
		if (irq && (xfer->c_flags & C_TIMEOU) == 0)
			return 0; /* IRQ was not for us */
		wdc_c->flags |= AT_TIMEOU;
		goto out;
	}
	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);
	if (wdc_c->flags & AT_READ) {
		if ((chp->ch_status & WDCS_DRQ) == 0) {
			wdc_c->flags |= AT_TIMEOU;
			goto out;
		}
		wdc_input_bytes(drvp, data, bcount);
		/* Should we wait for device to indicate idle? */
	}
out:
	__wdccommand_done(chp, xfer);
	WDCDEBUG_PRINT(("__wdccommand_intr returned\n"), DEBUG_INTR);
	return 1;
}

void
__wdccommand_done(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	struct wdc_command *wdc_c = xfer->cmd;

	WDCDEBUG_PRINT(("__wdccommand_done %s:%d:%d %02x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    chp->ch_status), DEBUG_FUNCS);
	if (chp->dying)
		goto killit;
	if (chp->ch_status & WDCS_DWF)
		wdc_c->flags |= AT_DF;
	if (chp->ch_status & WDCS_ERR) {
		wdc_c->flags |= AT_ERROR;
		wdc_c->r_error = chp->ch_error;
	}
	wdc_c->flags |= AT_DONE;
	if ((wdc_c->flags & AT_READREG) != 0 &&
	    (wdc_c->flags & (AT_ERROR | AT_DF)) == 0) {
		wdc_c->r_head = CHP_READ_REG(chp, wdr_sdh);
		wdc_c->r_cyl = CHP_READ_REG(chp, wdr_cyl_hi) << 8;
		wdc_c->r_cyl |= CHP_READ_REG(chp, wdr_cyl_lo);
		wdc_c->r_sector = CHP_READ_REG(chp, wdr_sector);
		wdc_c->r_count = CHP_READ_REG(chp, wdr_seccnt);
		wdc_c->r_error = CHP_READ_REG(chp, wdr_error);
		wdc_c->r_features = wdc_c->r_error;
	}

killit:
	if (xfer->c_flags & C_POLL) {
		wdc_enable_intr(chp);
	} else
		timeout_del(&chp->ch_timo);

	wdc_free_xfer(chp, xfer);
	WDCDEBUG_PRINT(("__wdccommand_done before callback\n"), DEBUG_INTR);

	if (chp->dying)
		return;

	if (wdc_c->flags & AT_WAIT)
		wakeup(wdc_c);
	else
		if (wdc_c->callback)
			wdc_c->callback(wdc_c->callback_arg);
	wdcstart(chp);
	WDCDEBUG_PRINT(("__wdccommand_done returned\n"), DEBUG_INTR);
}

/*
 * Send a command. The drive should be ready.
 * Assumes interrupts are blocked.
 */
void
wdccommand(struct channel_softc *chp, u_int8_t drive, u_int8_t command,
    u_int16_t cylin, u_int8_t head, u_int8_t sector, u_int8_t count,
    u_int8_t features)
{
	WDCDEBUG_PRINT(("wdccommand %s:%d:%d: command=0x%x cylin=%d head=%d "
	    "sector=%d count=%d features=%d\n", chp->wdc->sc_dev.dv_xname,
	    chp->channel, drive, command, cylin, head, sector, count, features),
	    DEBUG_FUNCS);
	WDC_LOG_ATA_CMDLONG(chp, head, features, cylin, cylin >> 8, sector,
	    count, command);

	/* Select drive, head, and addressing mode. */
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4) | head);

	/* Load parameters. */
	CHP_WRITE_REG(chp, wdr_features, features);
	CHP_WRITE_REG(chp, wdr_cyl_lo, cylin);
	CHP_WRITE_REG(chp, wdr_cyl_hi, cylin >> 8);
	CHP_WRITE_REG(chp, wdr_sector, sector);
	CHP_WRITE_REG(chp, wdr_seccnt, count);

	/* Send command. */
	CHP_WRITE_REG(chp, wdr_command, command);
}

/*
 * Send a 48-bit addressing command. The drive should be ready.
 * Assumes interrupts are blocked.
 */
void
wdccommandext(struct channel_softc *chp, u_int8_t drive, u_int8_t command,
    u_int64_t blkno, u_int16_t count)
{
	WDCDEBUG_PRINT(("wdccommandext %s:%d:%d: command=0x%x blkno=%llu "
	    "count=%d\n", chp->wdc->sc_dev.dv_xname,
	    chp->channel, drive, command, blkno, count),
	    DEBUG_FUNCS);
	WDC_LOG_ATA_CMDEXT(chp, blkno >> 40, blkno >> 16, blkno >> 32,
	    blkno >> 8, blkno >> 24, blkno, count >> 8, count, command);

	/* Select drive and LBA mode. */
	CHP_WRITE_REG(chp, wdr_sdh, (drive << 4) | WDSD_LBA);

	/* Load parameters. */
	CHP_LBA48_WRITE_REG(chp, wdr_lba_hi,
	    ((blkno >> 32) & 0xff00) | ((blkno >> 16) & 0xff));
	CHP_LBA48_WRITE_REG(chp, wdr_lba_mi,
	    ((blkno >> 24) & 0xff00) | ((blkno >> 8) & 0xff));
	CHP_LBA48_WRITE_REG(chp, wdr_lba_lo,
	    ((blkno >> 16) & 0xff00) | (blkno & 0xff));
	CHP_LBA48_WRITE_REG(chp, wdr_seccnt, count);

	/* Send command. */
	CHP_WRITE_REG(chp, wdr_command, command);
}

/*
 * Simplified version of wdccommand().  Unbusy/ready/drq must be
 * tested by the caller.
 */
void
wdccommandshort(struct channel_softc *chp, int drive, int command)
{

	WDCDEBUG_PRINT(("wdccommandshort %s:%d:%d command 0x%x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),
	    DEBUG_FUNCS);
	WDC_LOG_ATA_CMDSHORT(chp, command);

	/* Select drive. */
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
	CHP_WRITE_REG(chp, wdr_command, command);
}

/* Add a command to the queue and start controller. Must be called at splbio */

void
wdc_exec_xfer(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	WDCDEBUG_PRINT(("wdc_exec_xfer %p flags 0x%x channel %d drive %d\n",
	    xfer, xfer->c_flags, chp->channel, xfer->drive), DEBUG_XFERS);

	/* complete xfer setup */
	xfer->chp = chp;

	/*
	 * If we are a polled command, and the list is not empty,
	 * we are doing a dump. Drop the list to allow the polled command
	 * to complete, we're going to reboot soon anyway.
	 */
	if ((xfer->c_flags & C_POLL) != 0 &&
	    !TAILQ_EMPTY(&chp->ch_queue->sc_xfer)) {
		TAILQ_INIT(&chp->ch_queue->sc_xfer);
	}
	/* insert at the end of command list */
	TAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);
	WDCDEBUG_PRINT(("wdcstart from wdc_exec_xfer, flags 0x%x\n",
	    chp->ch_flags), DEBUG_XFERS);
	wdcstart(chp);
}

void *
wdc_xfer_get(void *null)
{
	return (pool_get(&wdc_xfer_pool, PR_NOWAIT | PR_ZERO));
}

void
wdc_scrub_xfer(struct wdc_xfer *xfer)
{
	memset(xfer, 0, sizeof(*xfer));
	xfer->c_flags = C_SCSIXFER;
}

void
wdc_xfer_put(void *null, void *xxfer)
{
	struct wdc_xfer *xfer = xxfer;
	int put = 0;
	int s;

	s = splbio();
	if (ISSET(xfer->c_flags, C_SCSIXFER))
		CLR(xfer->c_flags, C_SCSIXFER);
	else
		put = 1;
	splx(s);

	if (put)
		pool_put(&wdc_xfer_pool, xfer);
}

struct wdc_xfer *
wdc_get_xfer(int flags)
{
	return (scsi_io_get(&wdc_xfer_iopool,
	    ISSET(flags, WDC_NOSLEEP) ? SCSI_NOSLEEP : 0));
}

void
wdc_free_xfer(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	int put = 0;
	int s;

	if (xfer->c_flags & C_PRIVATEXFER) {
		chp->ch_flags &= ~WDCF_ACTIVE;
		TAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);
		return;
	}

	s = splbio();
	chp->ch_flags &= ~WDCF_ACTIVE;
	TAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);
	if (ISSET(xfer->c_flags, C_SCSIXFER))
		CLR(xfer->c_flags, C_SCSIXFER);
	else
		put = 1;
	splx(s);

	if (put)
		scsi_io_put(&wdc_xfer_iopool, xfer);
}


/*
 * Kill off all pending xfers for a channel_softc.
 *
 * Must be called at splbio().
 */
void
wdc_kill_pending(struct channel_softc *chp)
{
	struct wdc_xfer *xfer;

	while ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) != NULL) {
		chp = xfer->chp;
		(*xfer->c_kill_xfer)(chp, xfer);
	}
}

void
__wdcerror(struct channel_softc *chp, char *msg)
{
	struct wdc_xfer *xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
	if (xfer == NULL)
		printf("%s:%d: %s\n", chp->wdc->sc_dev.dv_xname, chp->channel,
		    msg);
	else
		printf("%s(%s:%d:%d): %s\n",
		    chp->ch_drive[xfer->drive].drive_name,
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, xfer->drive, msg);
}

/*
 * the bit bucket
 */
void
wdcbit_bucket(struct channel_softc *chp, int size)
{
	CHP_READ_RAW_MULTI_2(chp, NULL, size);
}


#include <sys/ataio.h>
#include <sys/file.h>

int wdc_ioc_ata_cmd(struct ata_drive_datas *, atareq_t *);

int
wdc_ioc_ata_cmd(struct ata_drive_datas *drvp, atareq_t *atareq)
{
	struct wdc_command wdc_c;
	int err = 0;

	/*
	 * Make sure a timeout was supplied in the ioctl request
	 */
	if (atareq->timeout == 0)
		return (EINVAL);

	if (atareq->datalen > MAXPHYS)
		return (EINVAL);

	bzero(&wdc_c, sizeof(wdc_c));

	if (atareq->datalen > 0) {
		wdc_c.data = dma_alloc(atareq->datalen, PR_NOWAIT | PR_ZERO);
		if (wdc_c.data == NULL) {
			err = ENOMEM;
			goto err;
		}
		wdc_c.bcount = atareq->datalen;
	}

	wdc_c.flags = AT_WAIT;
	if (atareq->flags & ATACMD_READ)
		wdc_c.flags |= AT_READ;
	if (atareq->flags & ATACMD_WRITE) {
		if (atareq->datalen > 0) {
			err = copyin(atareq->databuf, wdc_c.data,
			    atareq->datalen);
			if (err != 0)
				goto err;
		}
		wdc_c.flags |= AT_WRITE;
	}
	if (atareq->flags & ATACMD_READREG)
		wdc_c.flags |= AT_READREG;

	wdc_c.timeout = atareq->timeout;
	wdc_c.r_command = atareq->command;
	wdc_c.r_head = atareq->head & 0x0f;
	wdc_c.r_cyl = atareq->cylinder;
	wdc_c.r_sector = atareq->sec_num;
	wdc_c.r_count = atareq->sec_count;
	wdc_c.r_features = atareq->features;
	if (drvp->drive_flags & DRIVE_ATAPI) {
		if (wdc_c.r_command == WDCC_IDENTIFY)
			wdc_c.r_command = ATAPI_IDENTIFY_DEVICE;
	} else {
		wdc_c.r_st_bmask = WDCS_DRDY;
		wdc_c.r_st_pmask = WDCS_DRDY;
	}

	if (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE) {
		atareq->retsts = ATACMD_ERROR;
		goto copyout;
	}

	if (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {
		if (wdc_c.flags & AT_ERROR) {
			atareq->retsts = ATACMD_ERROR;
			atareq->error = wdc_c.r_error;
		} else if (wdc_c.flags & AT_DF)
			atareq->retsts = ATACMD_DF;
		else
			atareq->retsts = ATACMD_TIMEOUT;
	} else {
		atareq->retsts = ATACMD_OK;
		if (atareq->flags & ATACMD_READREG) {
			atareq->head = wdc_c.r_head;
			atareq->cylinder = wdc_c.r_cyl;
			atareq->sec_num = wdc_c.r_sector;
			atareq->sec_count = wdc_c.r_count;
			atareq->features = wdc_c.r_features;
			atareq->error = wdc_c.r_error;
		}
	}

copyout:
	if (atareq->datalen > 0 && atareq->flags & ATACMD_READ) {
		err = copyout(wdc_c.data, atareq->databuf, atareq->datalen);
		if (err != 0)
			goto err;
	}

err:
	if (wdc_c.data)
		dma_free(wdc_c.data, atareq->datalen);
	return (err);
}

int
wdc_ioctl(struct ata_drive_datas *drvp, u_long xfer, caddr_t addr, int flag,
    struct proc *p)
{
	int error = 0;

	switch (xfer) {
#ifdef WDCDEBUG
	case ATAIOGETTRACE: {
		atagettrace_t *agt = (atagettrace_t *)addr;
		unsigned int size = 0;
		char *log_to_copy;

		size = agt->buf_size;
		if (size > 65536) {
			size = 65536;
		}

		log_to_copy = wdc_get_log(&size, &agt->bytes_left);

		if (log_to_copy != NULL) {
			error = copyout(log_to_copy, agt->buf, size);
			free(log_to_copy, M_TEMP, 0);
		}

		agt->bytes_copied = size;
		break;
	}
#endif /* WDCDEBUG */

	case ATAIOCCOMMAND: {
		atareq_t *atareq = (atareq_t *)addr;

		/*
		 * Make sure this command is (relatively) safe first
		 */
		if ((flag & FWRITE) == 0 && atareq->flags & ATACMD_WRITE)
			error = EPERM;
		else
			error = wdc_ioc_ata_cmd(drvp, atareq);
		break;
	}

	default:
		error = ENOTTY;
		goto exit;
	}

exit:
	return (error);
}
@


1.130
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.129 2015/08/17 15:36:29 krw Exp $	*/
d716 2
a717 3
		pool_init(&wdc_xfer_pool, sizeof(struct wdc_xfer), 0,
		    0, 0, "wdcxfer", NULL);
		pool_setipl(&wdc_xfer_pool, IPL_BIO);
@


1.129
log
@The 80's called and want their interface back. Remove last fragments of
ST-506 support. Remove redundant 'precomp' variables/fields and rename
remaining few to 'features' to be consistant with the rest of the code.

Consensus that no ST-506 disks (requiring ISA cards, <120MB, usually
rife with bad sectors that can't be worked around) are still running
OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.128 2015/03/09 18:50:08 miod Exp $	*/
d734 1
a734 1
	free(queue, M_DEVBUF, 0);
@


1.128
log
@In wdcintr, do not attempt to read the status register unless WDCF_IRQ_WAIT
is not set; this used to be the case but got broken in 1.113.
Fixes
  pciide0 at pci0 dev 2 function 0 "Acard ATP865-R" rev 0x07: DMA
on armish (I/O Data).
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.127 2014/09/29 00:07:55 dlg Exp $	*/
d1691 1
a1691 1
	    wdc_c->r_sector, wdc_c->r_count, wdc_c->r_precomp);
d1792 1
a1792 3
		wdc_c->r_precomp = wdc_c->r_error;
		/* XXX CHP_READ_REG(chp, wdr_precomp); - precomp
		   isn't a readable register */
d1823 1
a1823 1
    u_int8_t precomp)
d1826 2
a1827 2
	    "sector=%d count=%d precomp=%d\n", chp->wdc->sc_dev.dv_xname,
	    chp->channel, drive, command, cylin, head, sector, count, precomp),
d1829 1
a1829 1
	WDC_LOG_ATA_CMDLONG(chp, head, precomp, cylin, cylin >> 8, sector,
d1835 2
a1836 2
	/* Load parameters. wdr_features(ATA/ATAPI) = wdr_precomp(ST506) */
	CHP_WRITE_REG(chp, wdr_precomp, precomp);
d2078 1
a2078 1
	wdc_c.r_precomp = atareq->features;
d2107 1
a2107 1
			atareq->features = wdc_c.r_precomp;
@


1.127
log
@correctly decrement the C_SCSIXFER reference count in wdc_xfer flags
if the ata stack xfer free path is called before teh scsi xfer free
path. this fixes a leak.

in the vast majority of uses (eg, filesystems mounted on cd(4) via
atapiscsi(4)) the scsi xfer free is always done first. however, if
you're doing ioctls (eg, cdio(1)), the scsi ref is held over to the
ioctl completion path, so the ata xfer free happens first.

problem found by patrick keshishian who did some excellent work
debugging this and providing the right fix for it.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.126 2014/09/14 14:17:25 jsg Exp $	*/
d932 9
a940 8
	/* Acknowledge interrupt by reading status */
	if (chp->_vtbl == 0)
		st = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
		    wdr_status & _WDC_REGMASK);
	else
		st = CHP_READ_REG(chp, wdr_status);
	if (st == 0xff)
		return (-1);
a941 1
	if ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {
@


1.126
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.125 2014/07/12 18:48:17 tedu Exp $	*/
d1977 4
a1980 1
	put = !ISSET(xfer->c_flags, C_SCSIXFER);
@


1.125
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.124 2014/07/08 17:19:25 deraadt Exp $	*/
a63 1
#include <sys/proc.h>
@


1.124
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.123 2014/01/24 06:21:59 dlg Exp $	*/
d735 1
a735 1
	free(queue, M_DEVBUF);
d2147 1
a2147 1
			free(log_to_copy, M_TEMP);
@


1.123
log
@treat C_SCSIXFER as a reference count and use it as a guard to pool_put.

fixes cd panics where the free_xfer path is called after scsi_done calls
xfer_put.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.122 2014/01/22 06:05:21 dlg Exp $	*/
a66 1
#include <uvm/uvm_extern.h>
@


1.122
log
@dont piggyback on C_PRIVATEXFER because it must not touch splx.
because im using it while the system is up and running i need the
xfer free path to take the right locks, which PRIVATEXFER doesnt.
invent a new C_SCSIXFER flag that provides the safety needed.

this fixes issues people have had installing from atapiscsi(4) cdrom
devices.

bug spelunking and tailq corruption identified by jsing@@
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.121 2014/01/18 20:50:24 dlg Exp $	*/
d1940 1
a1940 1
wdc_xfer_put(void *null, void *xfer)
d1942 13
a1954 1
	pool_put(&wdc_xfer_pool, xfer);
d1967 1
d1979 1
d1982 1
a1982 1
	if (!ISSET(xfer->c_flags, C_SCSIXFER))
@


1.121
log
@move atapiscsi to iopools by making the entire ata layer use them too.

this would have been difficult before because the ata completion
paths try to be helfpul by freeing xfers on the adapters behalf,
whch doesn't work in the new world scsi model where the layer that
allocated the thing is responsible for freeing it, and expects to
get it back and maybe use it again. however, deraadt@@ added magic
flags for hibernate that im now using to keep ata xfers for the
scsi layers.

committing this now so itll be tested. i cant think of a better time
to handle fallout from diffs like this than hackathons.

discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.120 2014/01/18 04:24:11 dlg Exp $	*/
d1936 1
a1936 1
	xfer->c_flags = C_PRIVATEXFER;
d1968 2
a1969 1
	scsi_io_put(&wdc_xfer_iopool, xfer);
@


1.120
log
@take advantage of pool_setipl and PR_ZERO to avoid doing work the
subsystem provides for us now when dealing with the xfer pool.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.119 2011/06/10 01:38:46 deraadt Exp $	*/
d78 3
d89 4
d721 2
d1926 19
d1948 2
a1949 2
	return (pool_get(&wdc_xfer_pool, PR_ZERO |
	    ((flags & WDC_NOSLEEP) != 0 ? PR_NOWAIT : PR_WAITOK)));
d1968 1
a1968 1
	pool_put(&wdc_xfer_pool, xfer);
@


1.119
log
@Do not set the dying flag in wdc_wait_for_status, since there is at
least one chip sii3112 or sii314, owned by henning) that spuriously
returns failure.  This is only backing out one of the dying cases.

As well, I have found one other case where attempts are made to advance
IO even after obvious failure.  I suspect that I should find that issue
next.

discussed with henning, kettenis, and matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.118 2011/05/25 03:26:20 matthew Exp $	*/
d712 2
a713 1
		    0, 0, "wdcspl", NULL);
d1920 2
a1921 10
	struct wdc_xfer *xfer;
	int s;

	s = splbio();
	xfer = pool_get(&wdc_xfer_pool,
	    ((flags & WDC_NOSLEEP) != 0 ? PR_NOWAIT : PR_WAITOK));
	splx(s);
	if (xfer != NULL)
		memset(xfer, 0, sizeof(struct wdc_xfer));
	return xfer;
d1938 2
a1940 1
	splx(s);
@


1.118
log
@wdc.c doesn't use NATAPISCSI, so no point in including atapiscsi.h.
It's the last file referencing atapiscsi.h too, so might as well get
rid of the need-flags in files.atapiscsi.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.117 2011/05/24 23:18:47 matthew Exp $	*/
a1094 3
			} else {
				chp->dying = 1;
				return -1;
@


1.117
log
@Move wdc_cd from ata/ata_wdc.c to ic/wdc.c so that you can compile a
kernel without the former.  Also, eliminate two dead stores in
wdcattach().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.116 2011/05/09 22:33:54 matthew Exp $	*/
a76 2

#include "atapiscsi.h"
@


1.116
log
@Refactor queue allocation and initialization into a wdc_alloc_queue()
function, and let attachment code calls this rather than malloc(9).
This prevents re-initialization of the queue in shared queue chipsets.
Also, add wdc_free_queue() as a complementary function.

Earlier version (without wdc_free_queue()) tested by sthen@@ and Amit
Kulkarni on various pciide(4) chips.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.115 2011/05/09 22:25:50 matthew Exp $	*/
d126 4
d734 1
a734 1
	int channel_flags, ctrl_flags, i;
a815 2
	ctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;
	channel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;
@


1.115
log
@Initialize the wdc ata_drive_datas structs earlier in wdcattach() so
that chip-specific drv_probe routines can assume they've already been
initialized.

Tested by sthen@@ on i386, armish, and amd64, with both affected and
non-affected pciide(4) chips.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.114 2011/05/08 17:33:56 matthew Exp $	*/
d700 27
a731 1
	static int inited = 0, s;
a774 11

	/* initialise global data */
	s = splbio();
	if (inited == 0) {
		/* Initialize the wdc_xfer pool. */
		pool_init(&wdc_xfer_pool, sizeof(struct wdc_xfer), 0,
		    0, 0, "wdcspl", NULL);
		inited++;
	}
	TAILQ_INIT(&chp->ch_queue->sc_xfer);
	splx(s);
@


1.114
log
@Eliminate a few unused wdc capability flags (WDC_CAPABILITY_HWLOCK,
WDC_CAPABILITY_ATA_NOSTREAM, and WDC_CAPABILITY_ATAPI_NOSTREAM).

ok dlg@@, jsg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.113 2011/04/18 04:16:13 deraadt Exp $	*/
d721 5
a763 2
		drvp->chnl_softc = chp;
		drvp->drive = i;
@


1.113
log
@keep an eye out for wdc registers returning 0xff.  if they return 0xff,
this probably means the controller is dead -- as in, a hot plug eject
event.  in that case, mark the driver dead and try harder to return -1
in the interrupt handler.
tested by many
ok dlg, miod did not object
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.112 2011/04/15 20:53:28 miod Exp $	*/
a863 3
	if (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)
		if (!(chp->wdc->claim_hw)(chp, 0))
			return;
a1918 1
	struct wdc_softc *wdc = chp->wdc;
a1926 2
	if (wdc->cap & WDC_CAPABILITY_HWLOCK)
		(*wdc->free_hw)(chp);
@


1.112
log
@Change wdc_reset_channel() to take a `no wait' argument. Pass in turn this
argument to wdcreset(), to have it skip waiting until active channels see
their BUSY bit clear in the status register.

Use this feature in the resume path, during the first reset operation. The
first reset is supposed to only wake up the controller, and the disks don't
come back until the second reset is issued, therefore waiting for them to
report themselves as ready after the first reset, but before the second, is
moot - and as a matter of fact some controllers, such as the AMD 754 and
clones/offspring (e.g. Geode) keep the BUSY bit asserted after the first
reset.

Last, but not least, make sure wd@@ata invokes wd_get_params() again before
returning from the resume code, as we will still be using polled transfers
for a short while.

This causes the Lemote Yeelong to resume within less than one second, instead
of the lousy 30 seconds wait between the two resets; and the wd_get_params()
voodoo prevents it from getting spurious ide interrupts afterwards.

wd_get_params() magic from dlg; rest of the work by yours truly after enough
prodding by dlg@@ and pirofti@@, among others. ok deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.111 2011/04/05 19:57:40 deraadt Exp $	*/
d705 1
a705 1
	static int inited = 0;
d746 1
d754 1
d884 2
d887 1
d906 11
a916 1
	int ret;
a918 8
		/* Acknowledge interrupt by reading status */
		if (chp->_vtbl == 0) {
			bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
			    wdr_status & _WDC_REGMASK);
		} else {
			CHP_READ_REG(chp, wdr_status);
		}

d920 1
a920 1
		return 0;
d929 2
d937 1
d1074 10
a1083 5
		if (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {
			wdc_set_drive(chp, 1);
			chp->ch_status = status =
			    CHP_READ_REG(chp, wdr_status);
			WDC_LOG_STATUS(chp, chp->ch_status);
d1135 4
d1722 4
d1755 2
d1777 1
d1780 2
a1781 1
	}
d1785 3
@


1.111
log
@wd_hibernate_io() is a standalone disk io writer which tries to not
damage kernel memory very much while doing the job.  It is not very
pretty yet, but improving it will need some MI work.
ok mlarkin jsg dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.110 2011/04/05 12:06:09 deraadt Exp $	*/
d937 1
a937 1
wdc_reset_channel(struct ata_drive_datas *drvp)
d945 1
a945 1
	(void) wdcreset(chp, VERBOSE);
d952 1
a952 1
wdcreset(struct channel_softc *chp, int verb)
d961 3
d967 2
a968 1
	if (verb && drv_mask2 != drv_mask1) {
d1561 1
a1561 1
	wdc_reset_channel(drvp);
@


1.110
log
@Deep below wdc_ioc_ata_cmd() it is possible that some controller (present or
future) will try to dma the command buffer to the disk in some way.  Use
dma_alloc() to get ahead of this potential failure path.
ok dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.109 2010/09/21 03:33:32 matthew Exp $	*/
d65 1
d1890 6
@


1.109
log
@Get rid of physio(9) in wdc(4)'s ioctl(2) handler.  Based on similar
changes to the SCSI subsystem ioctl(2) handlers.

ok dlg@@; ok and tweaks krw@@; no objections jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.108 2010/08/29 18:40:33 deraadt Exp $	*/
d1963 1
a1963 3
		/* XXX dma accessible */
		wdc_c.data = malloc(atareq->datalen, M_TEMP,
		    M_WAITOK | M_CANFAIL | M_ZERO);
d2035 1
a2035 1
		free(wdc_c.data, M_TEMP);
@


1.108
log
@pcmcia/wdc_pcmcia.c
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.107 2010/07/23 07:47:13 jsg Exp $	*/
a1941 1
#include <sys/buf.h>
d1943 1
a1943 3
/*
 * Glue necessary to hook ATAIOCCOMMAND into physio
 */
d1945 2
a1946 54
struct wdc_ioctl {
	LIST_ENTRY(wdc_ioctl) wi_list;
	struct buf wi_bp;
	struct uio wi_uio;
	struct iovec wi_iov;
	atareq_t wi_atareq;
	struct ata_drive_datas *wi_drvp;
};

struct	wdc_ioctl *wdc_ioctl_find(struct buf *);
void	wdc_ioctl_free(struct wdc_ioctl *);
struct	wdc_ioctl *wdc_ioctl_get(void);
void	wdc_ioctl_strategy(struct buf *);

LIST_HEAD(, wdc_ioctl) wi_head;

/*
 * Allocate space for a ioctl queue structure.  Mostly taken from
 * scsipi_ioctl.c
 */
struct wdc_ioctl *
wdc_ioctl_get(void)
{
	struct wdc_ioctl *wi;
	int s;

	wi = malloc(sizeof(*wi), M_TEMP, M_WAITOK | M_ZERO);
	s = splbio();
	LIST_INSERT_HEAD(&wi_head, wi, wi_list);
	splx(s);
	return (wi);
}

/*
 * Free an ioctl structure and remove it from our list
 */

void
wdc_ioctl_free(struct wdc_ioctl *wi)
{
	int s;

	s = splbio();
	LIST_REMOVE(wi, wi_list);
	splx(s);
	free(wi, M_TEMP);
}

/*
 * Find a wdc_ioctl structure based on the struct buf.
 */

struct wdc_ioctl *
wdc_ioctl_find(struct buf *bp)
a1947 37
	struct wdc_ioctl *wi;
	int s;

	s = splbio();
	LIST_FOREACH(wi, &wi_head, wi_list)
		if (bp == &wi->wi_bp)
			break;
	splx(s);
	return (wi);
}

/*
 * Ioctl pseudo strategy routine
 *
 * This is mostly stolen from scsipi_ioctl.c:scsistrategy().  What
 * happens here is:
 *
 * - wdioctl() queues a wdc_ioctl structure.
 *
 * - wdioctl() calls physio/wdc_ioctl_strategy based on whether or not
 *   user space I/O is required.  If physio() is called, physio() eventually
 *   calls wdc_ioctl_strategy().
 *
 * - In either case, wdc_ioctl_strategy() calls wdc_exec_command()
 *   to perform the actual command
 *
 * The reason for the use of the pseudo strategy routine is because
 * when doing I/O to/from user space, physio _really_ wants to be in
 * the loop.  We could put the entire buffer into the ioctl request
 * structure, but that won't scale if we want to do things like download
 * microcode.
 */

void
wdc_ioctl_strategy(struct buf *bp)
{
	struct wdc_ioctl *wi;
d1949 1
a1949 11
	int error = 0;
	int s;

	wi = wdc_ioctl_find(bp);
	if (wi == NULL) {
		printf("user_strat: No ioctl\n");
		error = EINVAL;
		goto bad;
	}

	bzero(&wdc_c, sizeof(wdc_c));
d1952 1
a1952 1
	 * Abort if physio broke up the transfer
d1954 2
d1957 2
a1958 5
	if ((u_long)bp->b_bcount != wi->wi_atareq.datalen) {
		printf("physio split wd ioctl request... cannot proceed\n");
		error = EIO;
		goto bad;
	}
d1960 1
a1960 3
	/*
	 * Make sure a timeout was supplied in the ioctl request
	 */
d1962 9
a1970 3
	if (wi->wi_atareq.timeout == 0) {
		error = EINVAL;
		goto bad;
d1973 2
a1974 1
	if (wi->wi_atareq.flags & ATACMD_READ)
d1976 7
a1982 1
	else if (wi->wi_atareq.flags & ATACMD_WRITE)
d1984 2
a1985 2

	if (wi->wi_atareq.flags & ATACMD_READREG)
d1988 8
a1995 12
	wdc_c.flags |= AT_WAIT;

	wdc_c.timeout = wi->wi_atareq.timeout;
	wdc_c.r_command = wi->wi_atareq.command;
	wdc_c.r_head = wi->wi_atareq.head & 0x0f;
	wdc_c.r_cyl = wi->wi_atareq.cylinder;
	wdc_c.r_sector = wi->wi_atareq.sec_num;
	wdc_c.r_count = wi->wi_atareq.sec_count;
	wdc_c.r_precomp = wi->wi_atareq.features;
	if (wi->wi_drvp->drive_flags & DRIVE_ATAPI) {
		wdc_c.r_st_bmask = 0;
		wdc_c.r_st_pmask = 0;
a2001 2
	wdc_c.data = wi->wi_bp.b_data;
	wdc_c.bcount = wi->wi_bp.b_bcount;
d2003 3
a2005 3
	if (wdc_exec_command(wi->wi_drvp, &wdc_c) != WDC_COMPLETE) {
		wi->wi_atareq.retsts = ATACMD_ERROR;
		goto bad;
d2010 2
a2011 2
			wi->wi_atareq.retsts = ATACMD_ERROR;
			wi->wi_atareq.error = wdc_c.r_error;
d2013 1
a2013 1
			wi->wi_atareq.retsts = ATACMD_DF;
d2015 1
a2015 1
			wi->wi_atareq.retsts = ATACMD_TIMEOUT;
d2017 8
a2024 8
		wi->wi_atareq.retsts = ATACMD_OK;
		if (wi->wi_atareq.flags & ATACMD_READREG) {
			wi->wi_atareq.head = wdc_c.r_head ;
			wi->wi_atareq.cylinder = wdc_c.r_cyl;
			wi->wi_atareq.sec_num = wdc_c.r_sector;
			wi->wi_atareq.sec_count = wdc_c.r_count;
			wi->wi_atareq.features = wdc_c.r_precomp;
			wi->wi_atareq.error = wdc_c.r_error;
d2028 11
a2038 11
	bp->b_error = 0;
	s = splbio();
	biodone(bp);
	splx(s);
	return;
bad:
	bp->b_flags |= B_ERROR;
	bp->b_error = error;
	s = splbio();
	biodone(bp);
	splx(s);
d2071 3
a2073 1
	case ATAIOCCOMMAND:
d2077 7
a2083 44
		if ((((atareq_t *) addr)->flags & ATACMD_READ) == 0 &&
		    (flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
		{
		struct wdc_ioctl *wi;
		atareq_t *atareq = (atareq_t *) addr;

		wi = wdc_ioctl_get();
		wi->wi_drvp = drvp;
		wi->wi_atareq = *atareq;

		if (atareq->datalen && atareq->flags &
		    (ATACMD_READ | ATACMD_WRITE)) {
			wi->wi_iov.iov_base = atareq->databuf;
			wi->wi_iov.iov_len = atareq->datalen;
			wi->wi_uio.uio_iov = &wi->wi_iov;
			wi->wi_uio.uio_iovcnt = 1;
			wi->wi_uio.uio_resid = atareq->datalen;
			wi->wi_uio.uio_offset = 0;
			wi->wi_uio.uio_segflg = UIO_USERSPACE;
			wi->wi_uio.uio_rw =
			    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE;
			wi->wi_uio.uio_procp = curproc;
			error = physio(wdc_ioctl_strategy, &wi->wi_bp, 0,
			    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE,
			    minphys, &wi->wi_uio);
		} else {
			/* No need to call physio if we don't have any
			   user data */
			wi->wi_bp.b_flags = 0;
			wi->wi_bp.b_data = 0;
			wi->wi_bp.b_bcount = 0;
			wi->wi_bp.b_dev = 0;
			wi->wi_bp.b_proc = curproc;
			LIST_INIT(&wi->wi_bp.b_dep);
			wdc_ioctl_strategy(&wi->wi_bp);
			error = wi->wi_bp.b_error;
		}
		*atareq = wi->wi_atareq;
		wdc_ioctl_free(wi);
		goto exit;
		}
@


1.107
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.106 2010/07/22 21:52:17 jsg Exp $	*/
a696 16
}

/*
 * Call activate routine of underlying devices.
 */
int
wdcactivate(struct device *self, int act)
{
	int error = 0;
	int s;

	s = splbio();
	config_activate_children(self, act);
	splx(s);

	return (error);
@


1.106
log
@ansi. no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.105 2009/11/23 23:48:37 deraadt Exp $	*/
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.105
log
@little annoying knf
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.104 2009/11/22 12:51:09 jsg Exp $	*/
d291 1
a291 3
wdc_default_read_reg(chp, reg)
	struct channel_softc *chp;
	enum wdc_regs reg;
d308 1
a308 4
wdc_default_write_reg(chp, reg, val)
	struct channel_softc *chp;
	enum wdc_regs reg;
	u_int8_t val;
d325 2
a326 4
wdc_default_lba48_write_reg(chp, reg, val)
	struct channel_softc *chp;
	enum wdc_regs reg;
	u_int16_t val;
d334 2
a335 4
wdc_default_read_raw_multi_2(chp, data, nbytes)
	struct channel_softc *chp;
	void *data;
	unsigned int nbytes;
d353 2
a354 4
wdc_default_write_raw_multi_2(chp, data, nbytes)
	struct channel_softc *chp;
	void *data;
	unsigned int nbytes;
d372 2
a373 4
wdc_default_write_raw_multi_4(chp, data, nbytes)
	struct channel_softc *chp;
	void *data;
	unsigned int nbytes;
d391 2
a392 4
wdc_default_read_raw_multi_4(chp, data, nbytes)
	struct channel_softc *chp;
	void *data;
	unsigned int nbytes;
a407 1

d409 1
a409 3
wdprint(aux, pnp)
	void *aux;
	const char *pnp;
d420 1
a420 2
wdc_disable_intr(chp)
	struct channel_softc *chp;
d426 1
a426 2
wdc_enable_intr(chp)
	struct channel_softc *chp;
d439 1
a439 4
wdc_floating_bus(chp, drive)
	struct channel_softc *chp;
	int drive;

a469 1

d471 1
a471 4
wdc_preata_drive(chp, drive)
	struct channel_softc *chp;
	int drive;

d502 1
a502 3
wdc_ata_present(chp, drive)
	struct channel_softc *chp;
	int drive;
d588 1
a588 2
wdcprobe(chp)
	struct channel_softc *chp;
d708 1
a708 3
wdcactivate(self, act)
	struct device *self;
	int act;
d721 1
a721 2
wdcattach(chp)
	struct channel_softc *chp;
d861 1
a861 2
wdcstart(chp)
	struct channel_softc *chp;
d897 1
a897 3
wdcdetach(chp, flags)
	struct channel_softc *chp;
	int flags;
d917 1
a917 2
wdcintr(arg)
	void *arg;
d957 1
a957 2
wdc_reset_channel(drvp)
	struct ata_drive_datas *drvp;
d972 1
a972 3
wdcreset(chp, verb)
	struct channel_softc *chp;
	int verb;
d1009 1
a1009 3
__wdcwait_reset(chp, drv_mask)
	struct channel_softc *chp;
	int drv_mask;
d1065 1
a1065 3
wdc_wait_for_status(chp, mask, bits, timeout)
	struct channel_softc *chp;
	int mask, bits, timeout;
d1127 1
a1127 4
wdc_dmawait(chp, xfer, timeout)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
d1145 1
a1145 2
wdctimeout(arg)
	void *arg;
d1193 1
a1193 3
wdc_probe_caps(drvp, params)
	struct ata_drive_datas *drvp;
	struct ataparams *params;
d1419 1
a1419 4
wdc_output_bytes(drvp, bytes, buflen)
	struct ata_drive_datas *drvp;
	void *bytes;
	unsigned int buflen;
d1444 1
a1444 4
wdc_input_bytes(drvp, bytes, buflen)
	struct ata_drive_datas *drvp;
	void *bytes;
	unsigned int buflen;
d1469 1
a1469 2
wdc_print_caps(drvp)
	struct ata_drive_datas *drvp;
d1496 1
a1496 2
wdc_print_current_modes(chp)
	struct channel_softc *chp;
d1528 1
a1528 2
wdc_downgrade_mode(drvp)
	struct ata_drive_datas *drvp;
d1582 1
a1582 3
wdc_exec_command(drvp, wdc_c)
	struct ata_drive_datas *drvp;
	struct wdc_command *wdc_c;
d1636 1
a1636 3
__wdccommand_start(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d1708 1
a1708 4
__wdccommand_intr(chp, xfer, irq)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int irq;
d1741 1
a1741 3
__wdccommand_done(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d1789 3
a1791 6
wdccommand(chp, drive, command, cylin, head, sector, count, precomp)
	struct channel_softc *chp;
	u_int8_t drive;
	u_int8_t command;
	u_int16_t cylin;
	u_int8_t head, sector, count, precomp;
d1819 2
a1820 6
wdccommandext(chp, drive, command, blkno, count)
	struct channel_softc *chp;
	u_int8_t drive;
	u_int8_t command;
	u_int64_t blkno;
	u_int16_t count;
d1850 1
a1850 4
wdccommandshort(chp, drive, command)
	struct channel_softc *chp;
	int drive;
	int command;
d1866 1
a1866 3
wdc_exec_xfer(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d1891 1
a1891 2
wdc_get_xfer(flags)
	int flags;
d1906 1
a1906 3
wdc_free_xfer(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d1927 1
a1927 2
wdc_kill_pending(chp)
	struct channel_softc *chp;
d1938 1
a1938 3
__wdcerror(chp, msg)
	struct channel_softc *chp;
	char *msg;
d1955 1
a1955 3
wdcbit_bucket(chp, size)
	struct channel_softc *chp;
	int size;
d1990 1
a1990 1
wdc_ioctl_get()
d2007 1
a2007 2
wdc_ioctl_free(wi)
	struct wdc_ioctl *wi;
d2022 1
a2022 2
wdc_ioctl_find(bp)
	struct buf *bp;
d2058 1
a2058 2
wdc_ioctl_strategy(bp)
	struct buf *bp;
d2161 2
a2162 6
wdc_ioctl(drvp, xfer, addr, flag, p)
	struct ata_drive_datas *drvp;
	u_long xfer;
	caddr_t addr;
	int flag;
	struct proc *p;
@


1.104
log
@Probe modes for SATA disks, makes CF behind SATA work and gives
more speed to things like SSDs that do UDMA 6.
Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.103 2009/10/13 19:33:16 pirofti Exp $	*/
d993 2
a994 1
void wdc_reset_channel(drvp)
d999 1
@


1.103
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.102 2009/02/07 08:07:28 grange Exp $	*/
a1246 15

	if ((wdc->cap & WDC_CAPABILITY_SATA) != 0 &&
	    (params->atap_sata_caps != 0x0000 &&
	    params->atap_sata_caps != 0xffff)) {
		WDCDEBUG_PRINT(("%s: atap_sata_caps=0x%x\n", __func__,
		    params->atap_sata_caps), DEBUG_PROBE);

		/* Skip ATA modes detection for native SATA drives */
		drvp->PIO_mode = drvp->PIO_cap = 4;
		drvp->DMA_mode = drvp->DMA_cap = 2;
		drvp->UDMA_mode = drvp->UDMA_cap = 5;
		drvp->drive_flags |= DRIVE_SATA | DRIVE_MODE | DRIVE_UDMA;
		drvp->ata_vers = 4;
		return;
	}
@


1.102
log
@Unifdef __OpenBSD__, these defines don't help us to sync with NetBSD
anymore but make reading the code harder.

ok sthen@@ miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.101 2009/01/21 21:54:00 grange Exp $	*/
d740 1
a740 1
	enum devact act;
@


1.101
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.100 2008/07/02 03:00:55 fgsch Exp $	*/
a756 3
#ifndef __OpenBSD__
	int error;
#endif
a770 7
#ifndef __OpenBSD__
	if ((error = wdc_addref(chp)) != 0) {
		printf("%s: unable to enable controller\n",
		    chp->wdc->sc_dev.dv_xname);
		return;
	}
#endif /* __OpenBSD__ */
d777 1
a777 1
		if (wdcprobe(chp) == 0) {
a778 3
#ifndef __OpenBSD__
			wdc_delref(chp);
#endif
a779 1
		}
a879 4

#ifndef __OpenBSD__
	wdc_delref(chp);
#endif
@


1.100
log
@unify using WDCDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.99 2008/06/30 00:13:30 fgsch Exp $	*/
d1784 1
a1784 1
		timeout_add(&chp->ch_timo, wdc_c->timeout / 1000 * hz);
@


1.99
log
@wrap logging code around WDC_DEBUG. shrinks kernel by ~4k.
jsg@@ krw@@ miod@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.98 2008/06/27 06:03:08 ray Exp $	*/
d140 1
a140 1
#ifdef WDC_DEBUG
d288 1
a288 1
#endif /* WDC_DEBUG */
d2293 1
a2293 1
#ifdef WDC_DEBUG
d2314 1
a2314 1
#endif
@


1.98
log
@More removal of clauses 3 and 4 from NetBSD licenses.

OK deraadt@@ and millert@@
@
text
@d1 2
a2 4
/*      $OpenBSD: wdc.c,v 1.97 2007/10/01 04:03:51 krw Exp $     */
/*	$NetBSD: wdc.c,v 1.68 1999/06/23 19:00:17 bouyer Exp $ */


d140 1
d288 1
a288 1

d2293 1
d2314 1
@


1.97
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.96 2007/05/08 16:07:03 deraadt Exp $     */
a48 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.96
log
@wdcrestart() is never used
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.95 2007/05/08 16:01:52 deraadt Exp $     */
d2122 1
a2122 2
	wi = malloc(sizeof(struct wdc_ioctl), M_TEMP, M_WAITOK);
	bzero(wi, sizeof (struct wdc_ioctl));
@


1.95
log
@atapi_print() is never used
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.94 2007/04/16 18:18:21 grange Exp $     */
a970 14

/* restart an interrupted I/O */
void
wdcrestart(v)
	void *v;
{
	struct channel_softc *chp = v;
	int s;

	s = splbio();
	wdcstart(chp);
	splx(s);
}

@


1.94
log
@During the drives detection only check the status register to be not
0xff, this will allow to detect some certain microdrives plugged
into soekris.
Patch from Jochen <jochen@@penguin-breeder.org> via PR 5340.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.93 2006/05/22 05:21:57 miod Exp $     */
a441 12
	return (UNCONF);
}

int
atapi_print(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct ata_atapi_attach *aa_link = aux;
	if (pnp)
		printf("atapiscsi at %s", pnp);
	printf(" channel %d", aa_link->aa_channel);
@


1.93
log
@In wdcprobe(), directly invoke wdc_do_reset() instead of using the reset
reset function pointer, as this can cause a NULL pointer dereference on
some systems.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.92 2006/05/08 00:18:40 jsg Exp $     */
d677 1
a677 1
		if ((st0 & 0x7f) == 0x7f || st0 == WDSD_IBM)
d679 1
a679 1
		if ((st1 & 0x7f) == 0x7f || st1 == (WDSD_IBM | 0x10))
@


1.92
log
@Revert last commit till a better method can be found.
At least one system (Ben Lovett's) had issues with the change.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.91 2006/05/07 03:00:14 jsg Exp $     */
d686 1
a686 1
	chp->wdc->reset(chp);
@


1.91
log
@Default to Ultra DMA Mode 6 not 5 when we know we have a native
SATA drive.

ok grange@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.90 2006/05/03 02:18:47 jsg Exp $     */
d1309 1
a1309 1
		drvp->UDMA_mode = drvp->UDMA_cap = 6;
@


1.90
log
@Provide a function pointer that allows for the wdc reset
method to be changed as required.
This will be required for dealing with several chips in pciide.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.89 2006/02/10 21:45:41 kettenis Exp $     */
d1309 1
a1309 1
		drvp->UDMA_mode = drvp->UDMA_cap = 5;
@


1.89
log
@Fix LBA48 access for ServerWorks SATA.
ok grange@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.88 2005/11/09 19:05:48 uwe Exp $     */
a102 1
void  __wdcdo_reset(struct channel_softc *);
d686 1
a686 1
	__wdcdo_reset(chp);
d789 3
d1069 1
a1069 1
	__wdcdo_reset(chp);
d1088 1
a1088 1
__wdcdo_reset(struct channel_softc *chp)
@


1.88
log
@Don't fall back to fake geometry if ata_get_params() fails.
"looks sane" grange@@; tested by niall@@ krw@@ jmc@@ jolan@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.87 2005/10/21 08:50:50 grange Exp $     */
d143 1
d338 10
d1970 8
a1977 9
	/* Load parameters. All registers are two byte deep FIFOs. */
	CHP_WRITE_REG(chp, wdr_lba_hi, blkno >> 40);
	CHP_WRITE_REG(chp, wdr_lba_hi, blkno >> 16);
	CHP_WRITE_REG(chp, wdr_lba_mi, blkno >> 32);
	CHP_WRITE_REG(chp, wdr_lba_mi, blkno >> 8);
	CHP_WRITE_REG(chp, wdr_lba_lo, blkno >> 24);
	CHP_WRITE_REG(chp, wdr_lba_lo, blkno);
	CHP_WRITE_REG(chp, wdr_seccnt, count >> 8);
	CHP_WRITE_REG(chp, wdr_seccnt, count);
@


1.87
log
@Zap return at the end of a void function. No binary change.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.86 2004/10/17 17:50:48 grange Exp $     */
d854 1
@


1.86
log
@Add a callback drv_probe() to allow underlying ata controller driver
to probe for drives in its own way. It's a no-op for now but will be
needed for native sata support.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.85 2004/10/17 08:58:56 grange Exp $     */
a355 1
	return;
a376 1
	return;
a397 1
	return;
a418 1
	return;
d909 1
a909 1
	return;
a1544 2

	return;
a1572 2

	return;
a1933 1
	return;
a1969 1
	return;
@


1.85
log
@Move declaration of default _vtbl members (wdc_default_*) to
wdcvar.h.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.84 2004/09/15 17:58:25 grange Exp $     */
d795 5
a799 2
	if (wdcprobe(chp) == 0) {
		/* If no drives, abort attach here. */
d801 1
a801 1
		wdc_delref(chp);
d803 2
a804 1
		return;
@


1.84
log
@Better debug printfs: missing \n and show xfer flags in
wdc_exec_xfer().
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.83 2004/02/19 21:16:21 grange Exp $     */
a134 11

u_int8_t wdc_default_read_reg(struct channel_softc *, enum wdc_regs);
void wdc_default_write_reg(struct channel_softc *, enum wdc_regs, u_int8_t);
void wdc_default_read_raw_multi_2(struct channel_softc *,
    void *, unsigned int);
void wdc_default_write_raw_multi_2(struct channel_softc *,
    void *, unsigned int);
void wdc_default_read_raw_multi_4(struct channel_softc *,
    void *, unsigned int);
void wdc_default_write_raw_multi_4(struct channel_softc *,
    void *, unsigned int);
@


1.83
log
@wdc logs fixes from costa@@:

1) wdc_get_log is at splbio() to prevent interrupt handlers from
updating the log
2) work hard to ensure that wdc_tail and wdc_head are between 0 and
wdc_log_cap, even if wdc_log or wdc_get_log is run concurrently against
itself. With this patch, running concurrent wdc_log's may corrupt the
log, but it should not cause any panics.
3) Make sure the buffer always starts on a record boundary. Otherwise
said, wdc_tail should always be on a record boundary.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.82 2004/01/23 20:48:33 grange Exp $     */
d1747 1
a1747 1
			WDCDEBUG_PRINT(("wdc_exec_command sleeping"),
d2017 2
a2018 2
	WDCDEBUG_PRINT(("wdc_exec_xfer %p channel %d drive %d\n", xfer,
	    chp->channel, xfer->drive), DEBUG_XFERS);
@


1.82
log
@Use %b to display status register, this will make bug reports more
informative. Also convert WDCS_BITS string to caps.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.81 2003/12/16 03:37:37 millert Exp $     */
d163 1
a163 1
static unsigned int wdc_size = 16 * 1024;
a170 1
	int idx;
d172 9
a180 6
	int nbytes;

	if (wdc_head < 0 || wdc_head > wdc_size ||
	    wdc_tail < 0 || wdc_tail > wdc_size) {
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head,
		    wdc_tail);
d184 1
a184 1
	if (size > wdc_size / 2) {
d186 1
d188 1
d191 1
a191 1
		wdc_log_buf = malloc(wdc_size, M_DEVBUF, M_NOWAIT);
d201 2
a202 2
	nbytes = wdc_head - wdc_tail;
	if (nbytes < 0) nbytes += wdc_size;
d204 12
a215 2
	if (nbytes + request_size >= wdc_size) {
		wdc_tail = (wdc_tail + request_size * 2) % wdc_size;
d219 3
a221 3
	if (wdc_head + request_size >= wdc_size) {
		memset(&wdc_log_buf[wdc_head], 0, wdc_size - wdc_head);
		wdc_head = 0;
d224 1
a224 1
	ptr = &wdc_log_buf[wdc_head];
d227 1
d229 2
a230 6
	idx = 0;
	while (size--) {
		*ptr++ = val[idx];
		idx++;
	}
	wdc_head += request_size;
d238 8
a245 3
	int  bytes = (wdc_head - wdc_tail);
	char *retbuf;
	int  ot, c1, c2;
d247 1
d251 6
a256 8
	if (bytes < 0)
		bytes += wdc_size;
	if ((u_int)bytes > *size) {
		if (left != NULL) {
			*left = bytes - *size;
		}
		bytes = *size;
	}
d261 1
a261 1
		return (NULL);
d264 5
a268 4
	if (wdc_head < 0 || wdc_head > wdc_size ||
	    wdc_tail < 0 || wdc_tail > wdc_size) {
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head,
		    wdc_tail);
d271 1
a271 1
		return (NULL);
d273 1
d275 1
a275 1
	retbuf = malloc(bytes, M_TEMP, M_NOWAIT);
d278 2
a279 2
		*left = bytes;
		return (NULL);
d282 11
a292 1
	*size = bytes;
d294 3
a296 9
	ot = wdc_tail;
	wdc_tail += bytes;
	if (wdc_tail > wdc_size) {
		wdc_tail -= wdc_size;
		c2 = wdc_tail;
		c1 = bytes - wdc_tail;
	} else {
		c1 = bytes;
		c2 = 0;
d299 3
a301 2
	memcpy(retbuf, &wdc_log_buf[ot], c1);
	memcpy(&retbuf[c1], &wdc_log_buf[0], c2);
d303 2
@


1.81
log
@Pass gcc -Wsign-compare; ok grange@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.80 2003/11/19 21:30:43 grange Exp $     */
d653 1
a653 1
		WDCDEBUG_PRINT(("%s:%d: before reset, st0=0x%x, st1=0x%x\n",
d655 2
a656 1
		    chp->channel, st0, st1), DEBUG_PROBE);
d693 1
a693 1
		WDCDEBUG_PRINT(("%s:%d:%d: after reset, st=0x%x, sc=0x%x"
d696 2
a697 1
		    chp->channel, drive, st0, sc, sn, cl, ch), DEBUG_PROBE);
d1116 2
a1117 2
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%x, er0=0x%x, "
	    "st1=0x%x, er1=0x%x, reset time=%d msec\n",
d1119 2
a1120 1
	    st0, er0, st1, er1, timeout * WDCDELAY / 1000), DEBUG_PROBE);
d1156 2
a1157 2
			WDCDEBUG_PRINT(("wdcwait: timeout, status 0x%x "
			    "error 0x%x\n", status,
@


1.80
log
@Sync with NetBSD probe code: deal with non-pullups ide bus when
testing status register and a better comments on probe logic.
Tested on i386, sparc64 and macppc by me, jmc@@, matthieu@@, sturm@@ and
drahn@@.

ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.79 2003/11/17 22:44:55 grange Exp $     */
d161 3
a163 3
static int wdc_tail = 0;
static int wdc_head = 0;
static int wdc_size = 16 * 1024;
d236 1
a236 1
	if (bytes > *size) {
d332 1
a332 1
		int i;
d354 1
a354 1
		int i;
d376 1
a376 1
		int i;
d398 1
a398 1
		int i;
d2212 1
a2212 1
	if (bp->b_bcount != wi->wi_atareq.datalen) {
@


1.79
log
@Various cleanups, knf, better debug messages.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.78 2003/11/17 21:50:13 grange Exp $     */
d603 12
a614 3
   Test to see controller with at least one attached drive is there.
   Returns a bit for each possible drive found (0x01 for drive 0,
   0x02 for drive 1).
d657 1
a657 5
		/*
		   If the status is 0x7f or 0xff, then it's
		   an empty channel with pull-up resistors.
		*/
		if ((st0 & 0x7f) == 0x7f)
d659 1
a659 1
		if ((st1 & 0x7f) == 0x7f)
@


1.78
log
@Don't wait for DRQ after issuing IDENTIFY command; instead check for DRQ
asserted after BSY is cleared in data read codepath. Solves delays in
probe.
The first version of this diff was done by costa@@ a long time ago but
had some issues. This one is a partial sync with NetBSD.

ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.77 2003/11/13 23:29:14 grange Exp $     */
d540 1
a540 1
 retry:
d885 1
a885 1
 exit:
d1148 2
a1149 2
			WDCDEBUG_PRINT(("wdcwait: timeout, status %x "
			    "error %x\n", status,
d1347 6
d1384 1
a1384 1
				at_poll) != CMD_OK)
d1768 2
a1769 1
		delay(10);
d1799 1
a1799 1
 timeout:
a1801 1
	return;
d1857 2
a1858 2
	if (wdc_c->flags & AT_READREG && (wdc_c->flags & (AT_ERROR | AT_DF))
								== 0) {
a1883 1
	return;
d2374 1
a2374 1
 exit:
@


1.77
log
@One byte can't hold a value > 255.
Spotted by Mr. GCC3.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.76 2003/11/05 20:45:18 grange Exp $     */
d1816 1
a1816 3
		__wdccommand_done(chp, xfer);
		WDCDEBUG_PRINT(("__wdccommand_intr returned\n"), DEBUG_INTR);
		return 1;
d1820 5
a1824 2

	if ((wdc_c->flags & AT_READ) && (chp->ch_status & WDCS_DRQ)) {
d1828 1
@


1.76
log
@Back wdc reset change, now in more careful variant.
Tested on matthieu's U5.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.75 2003/10/31 11:46:53 grange Exp $     */
d1327 1
a1327 2
	} else if (params->atap_oldpiotiming > 180 &&
	    params->atap_oldpiotiming <= 600) {
a1334 2
		 * A cycle time greater than 600ns seems
		 * to be invalid.
d1338 1
a1338 1
		} else if (params->atap_oldpiotiming <= 480) {
a1339 2
		} else {
			drvp->PIO_cap = 0;
@


1.75
log
@Back all the changes except the wdc reset part, this will come later.
Tested on matthieu's U5.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.70 2003/10/21 18:58:50 jmc Exp $     */
d103 1
d661 1
a661 4
	CHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_4BIT);
	delay(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
	delay(2000);
d1035 1
a1035 4
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_4BIT);
	delay(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
	delay(2000);
d1051 11
@


1.74
log
@Revert to 1.70 for now which is the last working version on my u5.
ok deraadt@@
@
text
@d827 2
a828 2
		 * Issue an IDENTIFY command in order to distinct ATA from OLD.
		 * This also kill ATAPI ghost.
d830 1
d1064 1
a1064 1
	u_int8_t st0, st1;
d1071 1
d1075 1
d1103 2
a1104 2
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x, "
			"reset time=%d msec\n",
d1106 1
a1106 1
	    st0, st1, timeout*WDCDELAY/1000), DEBUG_PROBE);
d1258 15
@


1.73
log
@Skip ATA modes detection for SATA drives, it's useless and some
SATA drives really don't like it.
Add a delay between drive reset and issuing IDENTIFY command,
some drives need it (from NetBSD).

This fixes problems with SATA drives reported by
Jonathon Fletcher <jonathon.fletcher@@pobox.com>. He also
provided access to the test machine.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.72 2003/10/26 14:39:59 grange Exp $     */
a102 1
void  __wdcdo_reset(struct channel_softc *);
d660 4
a663 1
	__wdcdo_reset(chp);
d827 2
a828 2
		 * Wait a bit, some devices are weird just after a reset.
		 * Then issue a IDENTIFY command, to try to detect slave ghost.
a829 1
		delay(5000);
d1036 4
a1039 1
	__wdcdo_reset(chp);
a1056 11
void
__wdcdo_reset(struct channel_softc *chp)
{
	wdc_set_drive(chp, 0);
	DELAY(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS | WDCTL_RST);
	delay(10000);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
	delay(10000);
}

d1063 1
a1063 1
	u_int8_t st0, er0, st1, er1;
a1069 1
		er0 = CHP_READ_REG(chp, wdr_error);
a1072 1
		er1 = CHP_READ_REG(chp, wdr_error);
d1100 2
a1101 2
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%x, er0=0x%x, "
	    "st1=0x%x, er1=0x%x, reset time=%d msec\n",
d1103 1
a1103 1
	    st0, er0, st1, er1, timeout * WDCDELAY / 1000), DEBUG_PROBE);
a1254 15

	if ((wdc->cap & WDC_CAPABILITY_SATA) != 0 &&
	    (params->atap_sata_caps != 0x0000 &&
	    params->atap_sata_caps != 0xffff)) {
		WDCDEBUG_PRINT(("%s: atap_sata_caps=0x%x\n", __func__,
		    params->atap_sata_caps), DEBUG_PROBE);

		/* Skip ATA modes detection for native SATA drives */
		drvp->PIO_mode = drvp->PIO_cap = 4;
		drvp->DMA_mode = drvp->DMA_cap = 2;
		drvp->UDMA_mode = drvp->UDMA_cap = 5;
		drvp->drive_flags |= DRIVE_SATA | DRIVE_MODE | DRIVE_UDMA;
		drvp->ata_vers = 4;
		return;
	}
@


1.72
log
@Print error registers values in debug message after reset  too.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.71 2003/10/26 14:29:47 grange Exp $     */
d825 2
a826 2
		 * Issue an IDENTIFY command in order to distinct ATA from OLD.
		 * This also kill ATAPI ghost.
d828 1
d1264 15
@


1.71
log
@Device reset improvements:
- put the reset protocol itself in the separate function __wdcdo_reset()
  so we don't need anymore to keep in sync two reset code paths;
- change the reset protocol to something like FreeBSD and NetBSD do,
  this fixes slave ATA drive detect with weird ATAPI master (reported
  by fgsch@@);

Discussed with costa@@.
Tested by me, fgsch@@, millert@@, canacar@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.70 2003/10/21 18:58:50 jmc Exp $     */
d1069 1
a1069 1
	u_int8_t st0, st1;
d1076 1
d1080 1
d1108 2
a1109 2
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x, "
			"reset time=%d msec\n",
d1111 1
a1111 1
	    st0, st1, timeout*WDCDELAY/1000), DEBUG_PROBE);
@


1.70
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.69 2003/10/20 07:12:39 grange Exp $     */
d103 1
d661 1
a661 4
	CHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_4BIT);
	delay(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
	delay(2000);
d1034 1
a1034 4
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_4BIT);
	delay(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
	delay(2000);
d1050 11
@


1.69
log
@typo; netbsd
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.68 2003/10/19 21:33:20 grange Exp $     */
d547 1
a547 1
	   for any reads to a non-existant slave.
d832 1
a832 1
			/* If IDENTIFY succeded, this is not an OLD ctrl */
d874 1
a874 1
	 * reset drive_flags for unnatached devices, reset state for attached
d1242 1
a1242 1
 * Probe drive's capabilites, for use by the controller later
@


1.68
log
@KNF
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.67 2003/10/17 08:14:09 grange Exp $     */
d1338 1
a1338 1
		 * If higther mode than 7 is found, abort.
@


1.67
log
@Merge an old fix from NetBSD:
- do not stop/unload current DMA operation if an IRQ was not detected
  by DMA engine unless the force flag was given, fixes DMA problems
  in shared IRQ setups;
- ack interrupt before entering DMA codepath

Tested by many.
Work by niklas@@ but he doesn't want to commit it for some reason.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.66 2003/10/16 11:58:16 grange Exp $     */
d110 5
a114 5
#define DEBUG_INTR   0x01
#define DEBUG_XFERS  0x02
#define DEBUG_STATUS 0x04
#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10
d116 2
a117 2
#define DEBUG_SDRIVE 0x40
#define DEBUG_DETACH 0x80
d176 2
a177 1
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head, wdc_tail);
d226 3
a228 3
        int  bytes = (wdc_head - wdc_tail);
        char *retbuf;
        int  ot, c1, c2;
d233 2
a234 1
        if (bytes < 0) bytes += wdc_size;
d250 2
a251 1
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head, wdc_tail);
d257 1
a257 1
        retbuf = malloc(bytes, M_TEMP, M_NOWAIT);
d266 10
a275 10
        ot = wdc_tail;
        wdc_tail += bytes;
        if (wdc_tail > wdc_size) {
                wdc_tail -= wdc_size;
                c2 = wdc_tail;
                c1 = bytes - wdc_tail;
        } else {
                c1 = bytes;
                c2 = 0;
        }
d277 2
a278 2
        memcpy(retbuf, &wdc_log_buf[ot], c1);
        memcpy(&retbuf[c1], &wdc_log_buf[0], c2);
d280 1
a280 1
        return (retbuf);
d439 1
a439 1
        struct channel_softc *chp;
d441 1
a441 1
        CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
d446 1
a446 1
        struct channel_softc *chp;
d448 1
a448 1
        CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
d552 1
a552 1
      	if (time_to_done == -1) {
d587 1
a587 1
       	DELAY(10);
d592 2
a593 2
		  chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
	          chp->channel, drive), DEBUG_PROBE);
d692 1
a692 1
	    	    chp->channel, drive, st0, sc, sn, cl, ch), DEBUG_PROBE);
d1005 1
a1005 1
        ret = xfer->c_intr(chp, xfer, 1);
d1054 1
a1054 1
	return  (drv_mask1 != drv_mask2) ? 1 : 0;
d1183 1
a1183 1
	for (time = 0;  time < timeout * 1000 / WDCDELAY; time++) {
d1289 1
a1289 1
		    wdc->cap, cf_flags), DEBUG_PROBE);
d1353 1
a1353 1
                        /*
d1496 1
a1496 1
	        CHP_WRITE_RAW_MULTI_2(chp,
d1732 2
a1733 2
		if (wdcwait(chp, wdc_c->r_st_bmask | WDCS_DRQ, wdc_c->r_st_bmask,
		    wdc_c->timeout) != 0) {
d1793 1
a1793 1
	     (irq == 0)  ? wdc_c->timeout : 0)) {
d1801 2
a1802 2
        if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
                chp->wdc->irqack(chp);
d1821 2
a1822 1
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, chp->ch_status), DEBUG_FUNCS);
@


1.66
log
@Cleanup a bit, more pretty debug messages.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.65 2003/10/16 11:30:00 grange Exp $     */
d991 10
d1170 24
d1219 6
@


1.65
log
@Allow setting of wdcdebug*_mask variables via preprocessor defines.
This makes creating debug kernels be much more easy.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.64 2003/10/16 10:07:59 grange Exp $     */
d1245 1
a1245 1
	WDCDEBUG_PRINT(("wdc_probe_caps: wdc_cap %d cf_flags %d\n",
d1624 1
a1624 1
	 }
@


1.64
log
@Kill two static function declarations.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.63 2003/09/28 21:01:43 grange Exp $     */
d120 4
a123 1
int wdcdebug_mask = 0;
@


1.63
log
@kill trailing spaces, no functional changes
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.62 2003/07/06 08:25:16 grange Exp $     */
d102 2
a103 2
static void  __wdcerror(struct channel_softc*, char *);
static int   __wdcwait_reset(struct channel_softc *, int);
d1041 1
a1041 1
static int
d1985 1
a1985 1
static void
@


1.62
log
@trailing spaces
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.61 2003/06/25 17:53:10 henric Exp $     */
d105 1
a105 1
void  __wdccommand_start(struct channel_softc *, struct wdc_xfer *);	
d206 1
a206 1
	*ptr++ = type & 0xff;		
d283 1
a283 1
#ifdef DIAGNOSTIC	
d303 1
a303 1
#ifdef DIAGNOSTIC	
d456 1
a456 1
	
d509 1
a509 1
	
d622 1
a622 1
		wdcdebug_mask |= DEBUG_PROBE;	
d721 1
a721 1
	return (ret_value);	
d803 1
a803 1
	
d957 1
a957 1
	
d972 1
a972 1
	
d1175 1
a1175 1
	}	
d1435 1
a1435 1
	unsigned int len = buflen, roundlen;	
d1510 1
a1510 1
			
d1700 1
a1700 1
		
d2231 1
a2231 1
		
@


1.61
log
@Restore the original wdcdebug_mask instead of clearing DEBUG_PROBE when
done with it.  This makes "wdcprobe()" consistent with "wdcattach()".

ok grange@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.60 2003/02/21 20:10:33 grange Exp $     */
d134 1
a134 1
void wdc_default_read_raw_multi_2(struct channel_softc *, 
d136 1
a136 1
void wdc_default_write_raw_multi_2(struct channel_softc *, 
d138 1
a138 1
void wdc_default_read_raw_multi_4(struct channel_softc *, 
d140 1
a140 1
void wdc_default_write_raw_multi_4(struct channel_softc *, 
d163 2
a164 2
wdc_log(struct channel_softc *chp, enum wdcevent_type type, 
    unsigned int size, char val[]) 
d183 1
a183 1
		if (wdc_log_buf == NULL) 
d208 1
a208 1
				  
d230 1
a230 1
	if (bytes > *size) { 
d289 1
a289 1
	if (reg & _WDC_AUX) 
d309 1
a309 1
	if (reg & _WDC_AUX) 
d334 1
a334 1
	bus_space_read_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0, 
d356 1
a356 1
	bus_space_write_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0, 
d378 1
a378 1
	bus_space_write_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0, 
d400 1
a400 1
	bus_space_read_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0, 
d446 1
a446 1
wdc_set_drive(struct channel_softc *chp, int drive) 
d534 1
a534 1
	/* 
d541 1
a541 1
	   for any reads to a non-existant slave. 
d544 1
a544 1
	    (WDCS_DRDY | WDCS_DSC | WDCS_DRQ), 
d554 2
a555 2
		    " %02x\n", 
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", 
d563 2
a564 2
		    " %02x\n", 
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", 
d595 1
a595 1
/* 
d641 1
a641 1
		/* 
d649 1
a649 1
		if (ret_value == 0) 
d654 1
a654 1
	CHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_4BIT); 
d696 1
a696 1
	/* 
d698 1
a698 1
	 */ 
d835 1
a835 1
			if ((drvp->drive_flags & DRIVE_OLD) && 
d976 1
a976 1
			bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, 
d1116 1
a1116 1
			chp->ch_status = status = 
d1126 1
a1126 1
			    DEBUG_STATUSX | DEBUG_STATUS); 
d1147 1
a1147 1
		else 
d1197 1
a1197 1
 * Assumes drvp points to an existing drive. 
d1227 1
a1227 1
	if (params->atap_ata_major > 0x01 && 
d1236 1
a1236 1
	} else 
d1242 1
a1242 1
	WDCDEBUG_PRINT(("wdc_probe_caps: wdc_cap %d cf_flags %d\n", 
d1283 1
a1283 1
	 * It's not in the specs, but it seems that some drive 
d1327 1
a1327 1
			/* 
d1440 1
a1440 1
		CHP_WRITE_RAW_MULTI_4(chp, 
d1498 1
a1498 1
	} else 
d1577 1
a1577 1
		/* 
d1582 1
a1582 1
		 * corruption is less likely to occur in PIO mode.  
d1663 1
a1663 1
{   
d1709 1
a1709 1
		wdc_output_bytes(&chp->ch_drive[drive], 
d1748 1
a1748 1
		if (irq && (xfer->c_flags & C_TIMEOU) == 0) 
d1791 1
a1791 1
		wdc_c->r_precomp = wdc_c->r_error; 
d1986 1
a1986 1
__wdcerror(chp, msg) 
d1994 2
a1995 2
	else 
		printf("%s(%s:%d:%d): %s\n", 
d2001 1
a2001 1
/* 
d2006 1
a2006 1
	struct channel_softc *chp; 
d2197 3
a2199 3
			wi->wi_atareq.sec_count = wdc_c.r_count; 
			wi->wi_atareq.features = wdc_c.r_precomp; 
			wi->wi_atareq.error = wdc_c.r_error; 
@


1.60
log
@Fix Manuel Bouyer's copyright, from NetBSD
ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.59 2003/02/13 20:54:59 grange Exp $     */
d98 1
a98 1
#endif
d128 1
a128 1
#endif
d287 1
a287 1
#endif
d307 1
a307 1
#endif
d608 3
d623 1
a623 1
#endif
d719 1
a719 4
	if ((chp->ch_flags & WDCF_VERBOSE_PROBE) ||
	    (chp->wdc &&
	    (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)))
		wdcdebug_mask &= ~DEBUG_PROBE;
d767 1
a767 1
#endif
d793 1
a793 1
#endif
a881 3
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_mask &= ~DEBUG_PROBE;

d914 1
a914 1
#endif
d1153 1
a1153 1
#endif
d1237 1
a1237 1
#endif
d1512 1
a1512 1
#endif
d1639 1
a1639 1
#endif
@


1.59
log
@Don't force all ATAPI devices to PIO mode 3, there are
devices which only support PIO mode 2 or less. Use
atap_oldpiotiming to obtain supported mode for such devices.
Also use SET FEATURES only for PIO mode > 2.

Work by Alec Skelly <alec@@dtkco.com> with my little help.

ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.58 2002/12/22 18:28:06 grange Exp $     */
d6 1
a6 1
 * Copyright (c) 1998 Manuel Bouyer.  All rights reserved.
@


1.58
log
@Define atagettrace_t type and use it instead of struct atagettrace.
ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.57 2002/12/22 18:24:45 grange Exp $     */
d1241 1
a1241 1
	/* An ATAPI device is at last PIO mode 3 */
d1248 37
a1290 1
		valid_mode_found = 0;
@


1.57
log
@No more magic wdc events types, give them names.
ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.56 2002/12/19 16:32:59 grange Exp $     */
d2195 1
a2195 1
		struct atagettrace *agt = (struct atagettrace *)addr;
@


1.56
log
@Protect WDCDEBUG_PRINT macro with do {} while (0)
ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.55 2002/12/12 10:26:26 grange Exp $     */
d163 1
a163 1
wdc_log(struct channel_softc *chp, int type, 
@


1.55
log
@Always use queue(3) macros.
ok chris@@ gluk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.54 2002/10/16 21:43:39 art Exp $     */
d122 4
a125 1
#define WDCDEBUG_PRINT(args, level)  if (wdcdebug_mask & (level)) printf args
@


1.54
log
@minor formatting.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.53 2002/10/09 23:43:11 krw Exp $     */
d901 1
a901 1
	if ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {
d987 1
a987 1
	xfer = chp->ch_queue->sc_xfer.tqh_first;
d1142 1
a1142 1
		struct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;
d1888 1
a1888 1
	    chp->ch_queue->sc_xfer.tqh_first != NULL) {
d1954 1
a1954 1
	struct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;
d2047 1
a2047 1
	for (wi = wi_head.lh_first; wi != 0; wi = wi->wi_list.le_next)
@


1.53
log
@Remove trailing '\n's from panic messages.

Started by a commit to siop from provos@@netbsd.org.

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.52 2002/07/02 15:26:19 csapuntz Exp $     */
d1050 1
a1050 1
	for (timeout = 0; timeout < WDCNDELAY_RST;timeout++) {
@


1.52
log
@Fix PIO write state machine. This has been totally broken since 2.5, but since
this code path is only executed for IOCTLs, and all of our IOCTLs only read
from the device, nobody noticed.

Thanks to grange and gluk for finding this one.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.51 2002/05/24 09:33:29 art Exp $     */
d913 1
a913 1
		panic("wdcstart: channel waiting for irq\n");
d1602 1
a1602 1
		panic("wdc_exec_command: polled command not done\n");
@


1.51
log
@protect biodone with splbio (this is the first time the splbio is
not really needed, just added to satisfy the assert).
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.50 2002/05/24 09:24:36 art Exp $     */
d1652 1
a1652 3
			wdc_c->flags |= AT_TIMEOU;
			__wdccommand_done(chp, xfer);
			return;
d1659 18
d1682 1
d1689 6
d1721 2
a1722 1
	if (wdc_c->flags & AT_READ) {
d1724 1
a1724 2
	} else if (wdc_c->flags & AT_WRITE) {
		wdc_output_bytes(drvp, data, bcount);
@


1.50
log
@Replace a home-grown splassert-like thing with the real stuff.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.49 2002/05/03 09:18:46 gluk Exp $     */
d2060 1
d2145 1
d2147 1
d2152 1
d2154 1
@


1.49
log
@LBA48 support.
Adopted from NetBSD by Alexander Yurchenko <grange@@openbsd.ru>.

costa@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.48 2002/03/16 17:12:09 csapuntz Exp $     */
d898 1
a898 12
#ifdef WDC_DIAGNOSTIC
	int spl1, spl2;

	spl1 = splbio();
	spl2 = splbio();
	if (spl2 != spl1) {
		printf("wdcstart: not at splbio()\n");
		panic("wdcstart");
	}
	splx(spl2);
	splx(spl1);
#endif /* WDC_DIAGNOSTIC */
@


1.48
log
@The new code logs the control signals on the IDE bus. You can extract the log
using atactl <device> dump. The log will help us support more devices.
Send logs to csapuntz@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.47 2002/03/14 01:26:55 millert Exp $     */
d1792 37
@


1.47
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.46 2002/01/23 00:39:47 art Exp $     */
d89 1
d153 122
d442 7
d458 1
a458 1
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
d498 1
a498 1
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
d508 1
d527 1
a527 1
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
d622 1
a622 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);
d625 2
a626 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);
d629 1
d667 1
a667 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
d675 1
d1062 1
a1062 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */
d1065 1
a1065 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10); /* slave */
d1123 1
d1126 1
a1126 1
			CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);
d1129 1
d1144 2
d1653 1
a1653 1
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
d1781 2
d1813 1
d2137 21
@


1.46
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.45 2002/01/12 05:36:09 jason Exp $     */
d101 7
a107 7
static void  __wdcerror	  __P((struct channel_softc*, char *));
static int   __wdcwait_reset  __P((struct channel_softc *, int));
void  __wdccommand_done __P((struct channel_softc *, struct wdc_xfer *));
void  __wdccommand_start __P((struct channel_softc *, struct wdc_xfer *));	
int   __wdccommand_intr __P((struct channel_softc *, struct wdc_xfer *, int));
int   wdprint __P((void *, const char *));
void  wdc_kill_pending __P((struct channel_softc *));
d128 14
a141 14
u_int8_t wdc_default_read_reg __P((struct channel_softc *, enum wdc_regs));
void wdc_default_write_reg __P((struct channel_softc *, enum wdc_regs, u_int8_t));
void wdc_default_read_raw_multi_2 __P((struct channel_softc *, 
    void *, unsigned int));
void wdc_default_write_raw_multi_2 __P((struct channel_softc *, 
    void *, unsigned int));
void wdc_default_read_raw_multi_4 __P((struct channel_softc *, 
    void *, unsigned int));
void wdc_default_write_raw_multi_4 __P((struct channel_softc *, 
    void *, unsigned int));

int wdc_floating_bus __P((struct channel_softc *, int));
int wdc_preata_drive __P((struct channel_softc *, int));
int wdc_ata_present __P((struct channel_softc *, int));
d1804 4
a1807 4
struct	wdc_ioctl *wdc_ioctl_find __P((struct buf *));
void	wdc_ioctl_free __P((struct wdc_ioctl *));
struct	wdc_ioctl *wdc_ioctl_get __P((void));
void	wdc_ioctl_strategy __P((struct buf *));
@


1.45
log
@Don't try UDMA modes if they aren't supported by the controller
even if the flags enable it.  chris@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.44 2002/01/07 19:04:46 mickey Exp $     */
d662 1
a662 1
		    0, 0, "wdcspl", 0, NULL, NULL, M_DEVBUF);
@


1.44
log
@pass the proc* down the ioctl chain to controller; mjacob@@ csapuntz@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.43 2001/11/06 19:53:18 miod Exp $     */
d1247 4
@


1.43
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.42 2001/08/23 13:23:28 art Exp $     */
d1982 1
a1982 1
wdc_ioctl(drvp, xfer, addr, flag)
d1987 1
@


1.43.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.46 2002/01/23 00:39:47 art Exp $     */
d662 1
a662 1
		    0, 0, "wdcspl", NULL);
a1247 4
	if ((wdc->cap & WDC_CAPABILITY_UDMA) == 0) {
		/* don't care about UDMA modes */
		return;
	}
d1982 1
a1982 1
wdc_ioctl(drvp, xfer, addr, flag, p)
a1986 1
	struct proc *p;
@


1.43.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.43.2.1 2002/01/31 22:55:32 niklas Exp $     */
a88 1
#include <dev/ic/wdcevent.h>
d101 7
a107 7
static void  __wdcerror(struct channel_softc*, char *);
static int   __wdcwait_reset(struct channel_softc *, int);
void  __wdccommand_done(struct channel_softc *, struct wdc_xfer *);
void  __wdccommand_start(struct channel_softc *, struct wdc_xfer *);	
int   __wdccommand_intr(struct channel_softc *, struct wdc_xfer *, int);
int   wdprint(void *, const char *);
void  wdc_kill_pending(struct channel_softc *);
d128 14
a141 14
u_int8_t wdc_default_read_reg(struct channel_softc *, enum wdc_regs);
void wdc_default_write_reg(struct channel_softc *, enum wdc_regs, u_int8_t);
void wdc_default_read_raw_multi_2(struct channel_softc *, 
    void *, unsigned int);
void wdc_default_write_raw_multi_2(struct channel_softc *, 
    void *, unsigned int);
void wdc_default_read_raw_multi_4(struct channel_softc *, 
    void *, unsigned int);
void wdc_default_write_raw_multi_4(struct channel_softc *, 
    void *, unsigned int);

int wdc_floating_bus(struct channel_softc *, int);
int wdc_preata_drive(struct channel_softc *, int);
int wdc_ata_present(struct channel_softc *, int);
a151 122
static char *wdc_log_buf = NULL;
static int wdc_tail = 0;
static int wdc_head = 0;
static int wdc_size = 16 * 1024;
static int chp_idx = 1;

void
wdc_log(struct channel_softc *chp, int type, 
    unsigned int size, char val[]) 
{
	unsigned int request_size;
	int idx;
	char *ptr;
	int nbytes;

	if (wdc_head < 0 || wdc_head > wdc_size ||
	    wdc_tail < 0 || wdc_tail > wdc_size) {
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head, wdc_tail);
		return;
	}

	if (size > wdc_size / 2) {
		printf ("wdc_log: type %d size %x\n", type, size);
	}

	if (wdc_log_buf == NULL) {
		wdc_log_buf = malloc(wdc_size, M_DEVBUF, M_NOWAIT);
		if (wdc_log_buf == NULL) 
			return;
	}
	if (chp->ch_log_idx == 0)
		chp->ch_log_idx = chp_idx++;

	request_size = size + 2;

	/* Check how many bytes are left */
	nbytes = wdc_head - wdc_tail;
	if (nbytes < 0) nbytes += wdc_size;

	if (nbytes + request_size >= wdc_size) {
		wdc_tail = (wdc_tail + request_size * 2) % wdc_size;
	}

	/* Avoid wrapping in the middle of a request */
	if (wdc_head + request_size >= wdc_size) {
		memset(&wdc_log_buf[wdc_head], 0, wdc_size - wdc_head);
		wdc_head = 0;
	}

	ptr = &wdc_log_buf[wdc_head];
	*ptr++ = type & 0xff;		
	*ptr++ = ((chp->ch_log_idx & 0x7) << 5) | (size & 0x1f);
				  
	idx = 0;
	while (size--) {
		*ptr++ = val[idx];
		idx++;
	}
	wdc_head += request_size;
}

char *wdc_get_log(unsigned int *, unsigned int *);

char *
wdc_get_log(unsigned int * size, unsigned int *left)
{
        int  bytes = (wdc_head - wdc_tail);
        char *retbuf;
        int  ot, c1, c2;

	if (left != NULL)
		*left = 0;

        if (bytes < 0) bytes += wdc_size;
	if (bytes > *size) { 
		if (left != NULL) {
			*left = bytes - *size;
		}
		bytes = *size;
	}

	if (wdc_log_buf == NULL) {
		*size = 0;
		*left = 0;
		return (NULL);
	}

	if (wdc_head < 0 || wdc_head > wdc_size ||
	    wdc_tail < 0 || wdc_tail > wdc_size) {
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head, wdc_tail);
		*size = 0;
		*left = 0;
		return (NULL);
	}

        retbuf = malloc(bytes, M_TEMP, M_NOWAIT);
	if (retbuf == NULL) {
		*size = 0;
		*left = bytes;
		return (NULL);
	}

	*size = bytes;

        ot = wdc_tail;
        wdc_tail += bytes;
        if (wdc_tail > wdc_size) {
                wdc_tail -= wdc_size;
                c2 = wdc_tail;
                c1 = bytes - wdc_tail;
        } else {
                c1 = bytes;
                c2 = 0;
        }

        memcpy(retbuf, &wdc_log_buf[ot], c1);
        memcpy(&retbuf[c1], &wdc_log_buf[0], c2);

        return (retbuf);
}


a318 7
void
wdc_set_drive(struct channel_softc *chp, int drive) 
{
	CHP_WRITE_REG(chp, wdr_sdh, (drive << 4) | WDSD_IBM);
	WDC_LOG_SET_DRIVE(chp, drive);
}

d328 1
a328 1
	wdc_set_drive(chp, drive);
d368 1
a368 1
	wdc_set_drive(chp, drive);
a377 1
	WDC_LOG_ATA_CMDSHORT(chp, WDCC_RECAL);
d396 1
a396 1
	wdc_set_drive(chp, drive);
d491 1
a491 1
		wdc_set_drive(chp, 0);
d494 1
a494 2
		WDC_LOG_STATUS(chp, st0);
		wdc_set_drive(chp, 1);
a496 1
		WDC_LOG_STATUS(chp, st1);
d534 1
a534 1
		wdc_set_drive(chp, drive);
a541 1
		WDC_LOG_REG(chp, wdr_cyl_lo, (ch << 8) | cl);
d764 12
a775 1
	splassert(IPL_BIO);
d928 1
a928 1
		wdc_set_drive(chp, 0);
d931 1
a931 1
		wdc_set_drive(chp, 1);
a988 1
		WDC_LOG_STATUS(chp, chp->ch_status);
d991 1
a991 1
			wdc_set_drive(chp, 1);
a993 1
			WDC_LOG_STATUS(chp, chp->ch_status);
a1007 2
		WDC_LOG_ERROR(chp, chp->ch_error);

d1515 1
a1515 1
	wdc_set_drive(chp, drive);
a1642 2
	WDC_LOG_ATA_CMDLONG(chp, head, precomp, cylin, cylin >> 8, sector,
	    count, command);
a1659 37
 * Send a 48-bit addressing command. The drive should be ready.
 * Assumes interrupts are blocked.
 */
void
wdccommandext(chp, drive, command, blkno, count)
	struct channel_softc *chp;
	u_int8_t drive;
	u_int8_t command;
	u_int64_t blkno;
	u_int16_t count;
{
	WDCDEBUG_PRINT(("wdccommandext %s:%d:%d: command=0x%x blkno=%llu "
	    "count=%d\n", chp->wdc->sc_dev.dv_xname,
	    chp->channel, drive, command, blkno, count),
	    DEBUG_FUNCS);
	WDC_LOG_ATA_CMDEXT(chp, blkno >> 40, blkno >> 16, blkno >> 32,
	    blkno >> 8, blkno >> 24, blkno, count >> 8, count, command);

	/* Select drive and LBA mode. */
	CHP_WRITE_REG(chp, wdr_sdh, (drive << 4) | WDSD_LBA);

	/* Load parameters. All registers are two byte deep FIFOs. */
	CHP_WRITE_REG(chp, wdr_lba_hi, blkno >> 40);
	CHP_WRITE_REG(chp, wdr_lba_hi, blkno >> 16);
	CHP_WRITE_REG(chp, wdr_lba_mi, blkno >> 32);
	CHP_WRITE_REG(chp, wdr_lba_mi, blkno >> 8);
	CHP_WRITE_REG(chp, wdr_lba_lo, blkno >> 24);
	CHP_WRITE_REG(chp, wdr_lba_lo, blkno);
	CHP_WRITE_REG(chp, wdr_seccnt, count >> 8);
	CHP_WRITE_REG(chp, wdr_seccnt, count);

	/* Send command. */
	CHP_WRITE_REG(chp, wdr_command, command);
	return;
}

/*
a1672 1
	WDC_LOG_ATA_CMDSHORT(chp, command);
d1804 4
a1807 4
struct	wdc_ioctl *wdc_ioctl_find(struct buf *);
void	wdc_ioctl_free(struct wdc_ioctl *);
struct	wdc_ioctl *wdc_ioctl_get(void);
void	wdc_ioctl_strategy(struct buf *);
a1892 1
	int s;
a1976 1
	s = splbio();
a1977 1
	splx(s);
a1981 1
	s = splbio();
a1982 1
	splx(s);
a1995 21
	case ATAIOGETTRACE: {
		struct atagettrace *agt = (struct atagettrace *)addr;
		unsigned int size = 0;
		char *log_to_copy;
		
		size = agt->buf_size;
		if (size > 65536) {
			size = 65536;
		}

		log_to_copy = wdc_get_log(&size, &agt->bytes_left);

		if (log_to_copy != NULL) {
			error = copyout(log_to_copy, agt->buf, size);
			free(log_to_copy, M_TEMP);
		}

		agt->bytes_copied = size;
		break;
	}

@


1.43.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.43.2.2 2002/06/11 03:42:20 art Exp $     */
d913 1
a913 1
		panic("wdcstart: channel waiting for irq");
d1050 1
a1050 1
	for (timeout = 0; timeout < WDCNDELAY_RST; timeout++) {
d1602 1
a1602 1
		panic("wdc_exec_command: polled command not done");
d1652 3
a1654 1
			goto timeout;
a1660 18

	if ((wdc_c->flags & AT_WRITE) == AT_WRITE) {
		delay(10);
		if (wait_for_unbusy(chp, wdc_c->timeout) != 0)
			goto timeout;
		
		if ((chp->ch_status & (WDCS_DRQ | WDCS_ERR)) == WDCS_ERR) {
			__wdccommand_done(chp, xfer);
			return;
		}

		if (wait_for_drq(chp, wdc_c->timeout) != 0)
			goto timeout;

		wdc_output_bytes(&chp->ch_drive[drive], 
		    wdc_c->data, wdc_c->bcount);
	}

a1665 1

a1671 6
	return;

 timeout:
	wdc_c->flags |= AT_TIMEOU;
	__wdccommand_done(chp, xfer);
	return;
d1698 1
a1698 2

	if ((wdc_c->flags & AT_READ) && (chp->ch_status & WDCS_DRQ)) {
d1700 2
a1701 1
		/* Should we wait for device to indicate idle? */
@


1.43.2.4
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d6 1
a6 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
d122 1
a122 4
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_mask & (level)) != 0)	\
		printf args;			\
} while (0)
d160 1
a160 1
wdc_log(struct channel_softc *chp, enum wdcevent_type type, 
d901 1
a901 1
	if ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) == NULL) {
d987 1
a987 1
	xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
d1142 1
a1142 1
		struct wdc_xfer *xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
d1238 1
a1238 1
	/* Use PIO mode 3 as a default value for ATAPI devices */
a1244 37
	valid_mode_found = 0;

	WDCDEBUG_PRINT(("%s: atap_oldpiotiming=%d\n", __func__,
	    params->atap_oldpiotiming), DEBUG_PROBE);
	/*
	 * ATA-4 compliant devices contain PIO mode
	 * number in atap_oldpiotiming.
	 */
	if (params->atap_oldpiotiming <= 2) {
		drvp->PIO_cap = params->atap_oldpiotiming;
		valid_mode_found = 1;
		drvp->drive_flags |= DRIVE_MODE;
	} else if (params->atap_oldpiotiming > 180 &&
	    params->atap_oldpiotiming <= 600) {
		/*
		 * ATA-2 compliant devices contain cycle
		 * time in atap_oldpiotiming.
		 * A device with a cycle time of 180ns
		 * or less is at least PIO mode 3 and
		 * should be reporting that in
		 * atap_piomode_supp, so ignore it here.
		 * A cycle time greater than 600ns seems
		 * to be invalid.
		 */
		if (params->atap_oldpiotiming <= 240) {
			drvp->PIO_cap = 2;
		} else if (params->atap_oldpiotiming <= 480) {
			drvp->PIO_cap = 1;
		} else {
			drvp->PIO_cap = 0;
		}
		valid_mode_found = 1;
		drvp->drive_flags |= DRIVE_MODE;
	}
	if (valid_mode_found)
		drvp->PIO_mode = drvp->PIO_cap;

d1251 1
d1888 1
a1888 1
	    !TAILQ_EMPTY(&chp->ch_queue->sc_xfer)) {
d1954 1
a1954 1
	struct wdc_xfer *xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
d2047 1
a2047 1
	LIST_FOREACH(wi, &wi_head, wi_list)
d2192 1
a2192 1
		atagettrace_t *agt = (atagettrace_t *)addr;
@


1.42
log
@initialize the channel timeout earlier.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.41 2001/07/31 07:07:00 csapuntz Exp $     */
d80 1
a80 1
#include <vm/vm.h>
@


1.41
log
@
Go down only one Ultra DMA mode at a time. Thanks to Matt Evans for
suggesting this fix.

Update atapiscsi Ultra DMA downgrade logic.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.40 2001/07/27 04:54:06 csapuntz Exp $     */
d622 2
a665 1
	timeout_set(&chp->ch_timo, wdctimeout, chp);
@


1.40
log
@Yet another probe fix. Switch to the right drive before looking at registers
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.39 2001/07/21 09:08:48 csapuntz Exp $     */
d1399 3
a1401 2
	 * If we were using Ultra-DMA mode > 2, downgrade to mode 2 first.
	 * Maybe we didn't properly notice the cable type
d1403 2
a1404 2
	if ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode >= 2) {
		drvp->UDMA_mode = (drvp->UDMA_mode == 2) ? 1 : 2;
@


1.39
log
@Undo last fix to ata_wdc.c. Don't deregister timeout in generic code
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.38 2001/07/19 19:45:01 csapuntz Exp $     */
d396 3
d419 5
d427 7
a433 1
	if ((chp->ch_status & 0xfc) != (WDCS_DRDY | WDCS_DSC))
d435 1
d450 4
a453 1
	    CHP_READ_REG(chp, wdr_cyl_hi) != 0x55)
d455 1
@


1.38
log
@Fix slave ATAPI device detect broken by last patch
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.37 2001/07/12 01:45:43 csapuntz Exp $     */
a845 1
	timeout_del(&chp->ch_timo);
@


1.37
log
@

Rework of probe code. Try better to deal with floating buses. Depending
on the value floating on the bus, we would occasionally skip the register
writability tests. Whoops...

Move fix for a flash device that doesn't wake up until a command is sent

Try to supress spurious interrupts. However, if one does happen, acknowledge
it anyway by reading status. This prevents the interrupt condition from
persisting.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.36 2001/06/25 19:31:49 csapuntz Exp $     */
d510 1
a510 3
	 * Use signatures to find ATAPI drives
	 *
	 * Also detect presence of ATA drive (wdc_ata_present)
d513 1
a513 1
		if ((ret_value & (0x01 << drive)) == 0)
d533 1
a533 1
		if (cl == 0x14 && ch == 0xeb) {
d535 9
a544 1
		} 
@


1.36
log
@

Fix excessive resets and device probes by storing IDENTIFY results in the
drvp structure
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.35 2001/06/24 20:59:40 fgsch Exp $     */
a349 10
	/*
	 * Test register writability
	 */
	CHP_WRITE_REG(chp, wdr_cyl_lo, 0xaa);
	CHP_WRITE_REG(chp, wdr_cyl_hi, 0x55);
	CHP_WRITE_REG(chp, wdr_seccnt, 0xff);

	if (CHP_READ_REG(chp, wdr_cyl_lo) == 0xaa &&
	    CHP_READ_REG(chp, wdr_cyl_hi) == 0x55)
		return 0;
d351 1
a351 3
	CHP_WRITE_REG(chp, wdr_seccnt, 0x58);

	return 1;
d394 1
d396 1
d406 12
d419 2
a420 2
	time_to_done = wdc_wait_for_status(chp, WDCS_DRDY, WDCS_DRDY, 1000);
      	if (time_to_done == -1) return 0;
d426 7
a432 19
	/* 
	   This section has been disabled because my Promise Ultra/66
	   starts interrupting like crazy when I issue a NOP. This
	   needs to be researched. - csapuntz@@openbsd.org
	*/
#if 0
	/* 
	   The NOP command always aborts.

	   If a drive doesn't understand NOP, it will abort the
	   command.

	   If a drive does understand NOP, it will abort the command.

	   If a drive is not present, we may get random crud on
	   register reads which will hopefully not pass the test.

	   Thanks to gluk@@ptci.ru for designing this check.
	*/
d434 2
a435 22
	CHP_WRITE_REG(chp, wdr_features, 0);
	CHP_WRITE_REG(chp, wdr_command, WDCC_NOP);
      	delay(10);

	time_to_done = wdc_wait_for_status(chp, 0, 0, 1000);

	if (time_to_done == -1) {
		WDCDEBUG_PRINT(("%s:%d:%d: timeout waiting for NOP to complete\n", 
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	WDCDEBUG_PRINT(("%s:%d:%d: NOP completed in %d msec\n",
	    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
	    chp->channel, drive, time_to_done), DEBUG_PROBE);

	if (!(chp->ch_status & WDCS_ERR) &&
	    !(chp->ch_error & WDCE_ABRT)) {
		WDCDEBUG_PRINT(("%s:%d:%d: NOP command did not ABORT command\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive), DEBUG_PROBE);
a436 2
	}
#endif
d455 3
a457 2
	
	if (!chp->_vtbl)
d459 2
d466 1
a466 3
		wdcdebug_mask |= DEBUG_PROBE;

	
d537 6
a542 1
		} else if (wdc_ata_present(chp, drive)) {
d550 1
d823 9
a832 1
	if ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {
@


1.35
log
@remove cold.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.34 2001/06/06 04:12:19 angelos Exp $     */
a613 1
	struct ataparams params;
d667 4
a670 2
		chp->ch_drive[i].chnl_softc = chp;
		chp->ch_drive[i].drive = i;
d675 1
a675 1
			chp->ch_drive[i].drive_flags |= DRIVE_CAP32;
d677 1
a677 1
		if ((chp->ch_drive[i].drive_flags & DRIVE) == 0)
d686 1
a686 1
		if (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==
d689 1
a689 1
			chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;
d691 1
a691 1
			chp->ch_drive[i].drive_flags &=
d697 1
a697 1
			if ((chp->ch_drive[i].drive_flags & DRIVE_OLD) && 
d699 1
a699 1
				chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;
a713 24
	/*
	 * Attach an ATAPI bus, if needed.
	 */
	if ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||
	    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {
#if NATAPISCSI > 0
		wdc_atapibus_attach(chp);
#else
		/*
		 * Fills in a fake aa_link and call config_found, so that
		 * the config machinery will print
		 * "atapibus at xxx not configured"
		 */
		bzero(&aa_link, sizeof(struct ata_atapi_attach));
		aa_link.aa_type = T_ATAPI;
		aa_link.aa_channel = chp->channel;
		aa_link.aa_openings = 1;
		aa_link.aa_drv_data = 0;
		aa_link.aa_bus_private = NULL;
		(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,
		    atapi_print);
#endif
	}

d715 1
a715 2
		if ((chp->ch_drive[i].drive_flags &
		    (DRIVE_ATA | DRIVE_OLD)) == 0) {
d719 4
a722 1
		aa_link.aa_type = T_ATA;
a735 2
		else
			chp->ch_drive[i].state = 0;
@


1.34
log
@Don't forget to make it compile.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.33 2001/06/05 22:03:25 art Exp $     */
a615 1
	extern int cold;
a994 4

#ifdef WDCNDELAY_DEBUG
	extern int cold;
#endif
@


1.33
log
@Don't forget to init b_dep.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.32 2001/05/01 02:26:42 csapuntz Exp $     */
d2050 1
a2050 1
			LIST_INIT(&wi->wi_bp->b_dep);
@


1.32
log
@

Add a 250ms wait in attach if ATAPI drives present on channel. Some
ATAPI devices need a while to boot their firmware, esp. if there is a
CD in the drive. Sending them commands early causes them to wedge or
abort those commands.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.31 2001/04/30 21:17:41 csapuntz Exp $     */
d2050 1
@


1.31
log
@

Move ATA IOCTL commands to low-level WDC driver
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.30 2001/04/04 07:29:50 csapuntz Exp $     */
d640 6
@


1.30
log
@

Lay the groundwork for disabling ATAPI DMA on controllers
where we have trouble. Note, in theory, ATAPI DMA is no different
than ATA DMA.

"Promise" not to tell anybody
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.29 2001/04/02 19:01:18 art Exp $     */
a69 5
/*
 * CODE UNTESTED IN THE CURRENT REVISION:
 *   
 */

a108 1

d307 1
a307 1
	struct channel_softc *chp;
d309 1
a309 1
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
d314 1
a314 10
	struct channel_softc *chp;
{
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
}

int
wdc_select_drive(chp, drive, howlong)
	struct channel_softc *chp;
	int drive;
	int howlong;
d316 1
a316 16
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
	
	delay(1);

	if (wdcwait(chp, WDCS_DRQ, 0, howlong)) {
		WDCDEBUG_PRINT(("wdc_select_drive %s:%d:%d waiting for %d"
				"after\n",
				chp->wdc->sc_dev.dv_xname, chp->channel, drive,
				howlong),
			       DEBUG_SDRIVE);
		
		
		return -1;
	}

	return 0;
d327 1
a327 1
	
d487 1
a487 1

d496 2
d617 3
d645 5
d691 2
a692 1
			if (!wdc_preata_drive(chp, i))
a755 21
	/*
	 * Reset channel. The probe, with some combinations of ATA/ATAPI
	 * devices keep it in a mostly working, but strange state (with busy
	 * led on)
	 */
	if ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {
		wdcreset(chp, VERBOSE);
		/*
		 * Read status registers to avoid spurious interrupts.
		 */
		for (i = 1; i >= 0; i--) {
			if (chp->ch_drive[i].drive_flags & DRIVE) {
				CHP_WRITE_REG(chp,
				    wdr_sdh, WDSD_IBM | (i << 4));
				if (wait_for_unbusy(chp, 10000) < 0)
					printf("%s:%d:%d: device busy\n",
					    chp->wdc->sc_dev.dv_xname,
					    chp->channel, i);
			}
		}
	}
d764 2
a1001 3
#ifdef TEST_ALTSTS
		chp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);
#else
d1003 1
a1003 1
#endif
a1005 4
#ifdef TEST_ALTSTS
			chp->ch_status = status = 
			    CHP_READ_REG(chp, wdr_altsts);
#else
a1007 1
#endif
d1009 1
a1009 1
		if ((status & WDCS_BSY) == 0 && (status & mask) == bits) 
a1019 4
#ifdef TEST_ALTSTS
	/* Acknowledge any pending interrupts */
	CHP_READ_REG(chp, wdr_status);
#endif
d1094 1
a1094 1
	int i, printed;
d1129 3
d1138 1
a1138 1
		printed = 0;
d1148 1
a1148 1
			if (i > 4) {
d1150 6
d1158 1
a1158 1
			/*
d1161 1
a1161 2
			 * assume the defaults are good, so don't try
			 * to set it
d1163 4
a1166 7
			if ((wdc->cap & WDC_CAPABILITY_MODE) != 0)
				if (ata_set_mode(drvp, 0x08 | (i + 3),
				   at_poll) != CMD_OK)
					continue;
			if (!printed) { 
				printed = 1;
			}
d1169 1
a1169 1
			 * get the highter one for the drive.
d1171 1
a1171 2
			if ((wdc->cap & WDC_CAPABILITY_MODE) == 0 ||
			    wdc->PIO_cap >= i + 3) {
d1177 1
a1177 1
		if (!printed) {
d1191 1
a1191 1
		printed = 0;
d1200 3
a1202 3
			if (!printed) {
				printed = 1;
			}
d1373 10
a1382 4
		printf("%s(%s:%d:%d): using PIO mode %d",
		    drvp->drive_name,
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive, drvp->PIO_mode);
a1519 1
#if 0
d1523 4
a1526 1
#endif
a1530 2
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));

d1618 1
a1618 1
#if 0
d1622 1
a1622 1
#endif
d1795 31
a1825 4
#ifndef __OpenBSD__
int
wdc_addref(chp)
	struct channel_softc *chp;
d1827 2
a1828 3
	struct wdc_softc *wdc = chp->wdc; 
	struct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;
	int s, error = 0;
d1830 2
d1833 1
a1833 6
	if (adapter->scsipi_refcnt++ == 0 &&
	    adapter->scsipi_enable != NULL) {
		error = (*adapter->scsipi_enable)(wdc, 1);
		if (error)
			adapter->scsipi_refcnt--;
	}
d1835 1
a1835 1
	return (error);
d1838 4
d1843 18
a1860 2
wdc_delref(chp)
	struct channel_softc *chp;
d1862 1
a1862 2
	struct wdc_softc *wdc = chp->wdc;
	struct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;
d1866 3
a1868 3
	if (adapter->scsipi_refcnt-- == 1 &&
	    adapter->scsipi_enable != NULL)
		(void) (*adapter->scsipi_enable)(wdc, 0);
d1870 188
a2058 1
#endif
@


1.29
log
@pool_get with PR_NOWAIT can fail. Handle that.
(the old code could return NULL and the callers check for that, so it
should be ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.28 2001/03/25 13:11:51 csapuntz Exp $     */
d1231 6
@


1.28
log
@Minor mods to DMA interface - get rid of unnecessary args. Allow DMA functions to return status flags.

Note: Changing code to have DMA interface indicate when I/O is done (a la NetBSD) was considered. It was rejected due to questionable backward compatability
with ISA DMA and MAC obio DMA

Added irqack from NetBSD (though this feature should really be in the
PCI interrupt handlers)

Use pool
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.27 2001/03/15 23:08:16 csapuntz Exp $     */
d1762 2
a1763 1
	memset(xfer, 0, sizeof(struct wdc_xfer));
@


1.27
log
@Fix races between timeouts and interrupts.

Cleanup atapiscsi driver a bit by moving fields out of xfer.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.26 2001/01/29 02:18:33 niklas Exp $     */
d84 1
a84 1

d104 1
a104 1
LIST_HEAD(xfer_free_list, wdc_xfer) xfer_free_list;
d672 1
a672 1
	/* init list only once */
d674 3
a676 1
		LIST_INIT(&xfer_free_list);
d911 2
a913 2
	chp->ch_flags &= ~WDCF_IRQ_WAIT;
	xfer = chp->ch_queue->sc_xfer.tqh_first;
d1527 2
a1528 7
			while (!(wdc_c->flags & AT_DONE)) {
				int error;
				error = tsleep(wdc_c, PRIBIO, "wdccmd", 0);

				if (error) {
					printf ("tsleep error: %d\n", error);
				}
a1529 4

			WDCDEBUG_PRINT(("wdc_exec_command waking"),
				       DEBUG_FUNCS);

d1554 1
a1554 1

d1558 1
a1558 1

d1612 2
d1652 1
d1656 1
d1759 4
a1762 27
	if ((xfer = xfer_free_list.lh_first) != NULL) {
		LIST_REMOVE(xfer, free_list);
		splx(s);
#ifdef DIAGNOSTIC
		if ((xfer->c_flags & C_INUSE) != 0)
			panic("wdc_get_xfer: xfer already in use\n");
#endif
	} else {
		splx(s);
		WDCDEBUG_PRINT(("wdc:making xfer %d\n",wdc_nxfer), DEBUG_XFERS);
		xfer = malloc(sizeof(*xfer), M_DEVBUF,
		    ((flags & WDC_NOSLEEP) != 0 ? M_NOWAIT : M_WAITOK));
		if (xfer == NULL)
			return 0;
#ifdef DIAGNOSTIC
		xfer->c_flags &= ~C_INUSE;
#endif
#ifdef WDCDEBUG
		wdc_nxfer++;
#endif
	}
#ifdef DIAGNOSTIC
	if ((xfer->c_flags & C_INUSE) != 0)
		panic("wdc_get_xfer: xfer already in use\n");
#endif
	bzero(xfer, sizeof(struct wdc_xfer));
	xfer->c_flags = C_INUSE;
d1779 1
a1779 2
	xfer->c_flags &= ~C_INUSE;
	LIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);
@


1.26
log
@Fix bug where timeouts triggered too early, caused panic on ATAPI tapes.
Removed hardcoded WDCDEBUG definitions.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.25 2001/01/29 00:20:16 csapuntz Exp $     */
d1097 1
a1097 1
	struct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;
d1103 8
@


1.25
log
@


Add wdc_print_current_modes to print current transfer modes set on the
devices. Print after attach in wdc_isa, wdc_isapnp, wdc_pcmcia.
pciide_print_modes rewritten to use wdc_print_current_modes.

Disable wdc_print_caps since it's not as useful.

Inspired by NetBSD. Thanks to Dale and Theo for pointing out this improvement.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.24 2001/01/23 08:50:28 aaron Exp $     */
a95 2

#define WDCDEBUG
@


1.24
log
@Restore the WDCF_IRQ_WAIT flag if the lower-level interrupt handler rejects
the interrupt. Fixes hangs seen with CompactFlash cards in CardBus slots.
Thanks to csapuntz@@ for some pointers. Note: this was NetBSD PR/8639.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.23 2000/10/29 18:42:49 deraadt Exp $     */
d1370 3
d1391 24
@


1.23
log
@undo this; adds files, unacceptable at this point in release
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.21 2000/10/27 20:29:27 csapuntz Exp $     */
d915 1
a915 2
#if notyet
	if (ret == 0)
a916 1
#endif
@


1.22
log
@

Reduce footprint of ATA driver by only having PROBE debug messages compiled
in by default.
@
text
@d94 1
a95 1
#include <dev/ic/wdcdbg.h>
d97 1
d116 11
d128 5
d406 1
a406 1
		WDCDEBUG_PRINT_PROBE(("%s:%d:%d: floating bus detected\n",
d408 1
a408 1
		    chp->channel, drive));
d415 1
a415 1
		WDCDEBUG_PRINT_PROBE(("%s:%d:%d: not ready\n",
d417 1
a417 1
		    chp->channel, drive));
d423 1
a423 1
		WDCDEBUG_PRINT_PROBE(("%s:%d:%d: WDCC_RECAL failed\n",
d425 1
a425 1
		    chp->channel, drive));
d452 1
a452 1
	WDCDEBUG_PRINT_PROBE(("%s:%d:%d: waiting for ready %d msec\n",
d454 1
a454 1
	    chp->channel, drive, time_to_done));
d483 1
a483 2
		WDCDEBUG_PRINT_PROBE((
		    "%s:%d:%d: timeout waiting for NOP to complete\n", 
d485 1
a485 1
		    chp->channel, drive));
d489 1
a489 1
	WDCDEBUG_PRINT_PROBE(("%s:%d:%d: NOP completed in %d msec\n",
d491 1
a491 1
	    chp->channel, drive, time_to_done));
d495 1
a495 1
		WDCDEBUG_PRINT_PROBE(("%s:%d:%d: NOP command did not ABORT command\n",
d497 1
a497 1
		    chp->channel, drive));
d540 1
a540 1
		WDCDEBUG_PRINT_PROBE(("%s:%d: before reset, st0=0x%x, st1=0x%x\n",
d542 1
a542 1
		    chp->channel, st0, st1));
d563 1
a563 1
	WDCDEBUG_PRINT_PROBE(("%s:%d: after reset, ret_value=0x%d\n",
d565 1
a565 1
	    ret_value));
d587 1
a587 1
		WDCDEBUG_PRINT_PROBE(("%s:%d:%d: after reset, st=0x%x, sc=0x%x"
d590 1
a590 1
	    	    chp->channel, drive, st0, sc, sn, cl, ch));
d608 1
a608 1

d613 1
a613 1

d669 1
a669 1

d672 1
a672 1

d707 1
a707 1
			WDCDEBUG_PRINT_PROBE(("%s:%d:%d: IDENTIFY failed\n",
d709 1
a709 1
			    chp->channel, i));
d718 3
a720 2
	WDCDEBUG_PRINT_PROBE(("wdcattach: ch_drive_flags 0x%x 0x%x\n",
	    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags));
d801 1
a801 1

d804 1
a804 1

d1011 1
a1011 1
	WDCDEBUG_PRINT_PROBE(("%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x, "
d1014 1
a1014 1
	    st0, st1, timeout*WDCDELAY/1000));
@


1.21
log
@

Patch to get rid of ST506 phantoms. Thanks to Grigoriy Orlov for the design
and testing.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.20 2000/07/20 19:15:23 csapuntz Exp $     */
a93 1

d95 1
a96 1
#define WDCDEBUG
a114 11

#define DEBUG_INTR   0x01
#define DEBUG_XFERS  0x02
#define DEBUG_STATUS 0x04
#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10
#define DEBUG_STATUSX 0x20
#define DEBUG_SDRIVE 0x40
#define DEBUG_DETACH 0x80

#ifdef WDCDEBUG
a115 5
int wdc_nxfer = 0;
#define WDCDEBUG_PRINT(args, level)  if (wdcdebug_mask & (level)) printf args
#else
#define WDCDEBUG_PRINT(args, level)
#endif
d389 1
a389 1
		WDCDEBUG_PRINT(("%s:%d:%d: floating bus detected\n",
d391 1
a391 1
		    chp->channel, drive), DEBUG_PROBE);
d398 1
a398 1
		WDCDEBUG_PRINT(("%s:%d:%d: not ready\n",
d400 1
a400 1
		    chp->channel, drive), DEBUG_PROBE);
d406 1
a406 1
		WDCDEBUG_PRINT(("%s:%d:%d: WDCC_RECAL failed\n",
d408 1
a408 1
		    chp->channel, drive), DEBUG_PROBE);
d435 1
a435 1
	WDCDEBUG_PRINT(("%s:%d:%d: waiting for ready %d msec\n",
d437 1
a437 1
	    chp->channel, drive, time_to_done), DEBUG_PROBE);
d466 2
a467 1
		WDCDEBUG_PRINT(("%s:%d:%d: timeout waiting for NOP to complete\n", 
d469 1
a469 1
		    chp->channel, drive), DEBUG_PROBE);
d473 1
a473 1
	WDCDEBUG_PRINT(("%s:%d:%d: NOP completed in %d msec\n",
d475 1
a475 1
	    chp->channel, drive, time_to_done), DEBUG_PROBE);
d479 1
a479 1
		WDCDEBUG_PRINT(("%s:%d:%d: NOP command did not ABORT command\n",
d481 1
a481 1
		    chp->channel, drive), DEBUG_PROBE);
d524 1
a524 1
		WDCDEBUG_PRINT(("%s:%d: before reset, st0=0x%x, st1=0x%x\n",
d526 1
a526 1
		    chp->channel, st0, st1), DEBUG_PROBE);
d547 1
a547 1
	WDCDEBUG_PRINT(("%s:%d: after reset, ret_value=0x%d\n",
d549 1
a549 1
	    ret_value), DEBUG_PROBE);
d571 1
a571 1
		WDCDEBUG_PRINT(("%s:%d:%d: after reset, st=0x%x, sc=0x%x"
d574 1
a574 1
	    	    chp->channel, drive, st0, sc, sn, cl, ch), DEBUG_PROBE);
d592 1
a592 1
#ifdef WDCDEBUG
d597 1
a597 1
#endif
d653 1
a653 1
#ifdef WDCDEBUG
d656 1
a656 1
#endif
d691 1
a691 1
			WDCDEBUG_PRINT(("%s:%d:%d: IDENTIFY failed\n",
d693 1
a693 1
			    chp->channel, i), DEBUG_PROBE);
d702 2
a703 3
	WDCDEBUG_PRINT(("wdcattach: ch_drive_flags 0x%x 0x%x\n",
	    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),
	    DEBUG_PROBE);
d784 1
a784 1
#ifdef WDCDEBUG
d787 1
a787 1
#endif
d994 1
a994 1
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x, "
d997 1
a997 1
	    st0, st1, timeout*WDCDELAY/1000), DEBUG_PROBE);
@


1.20
log
@

chp->wdc can be NULL on probe.

Propagate verbose flag from cf_data to channel
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.19 2000/07/20 07:40:32 csapuntz Exp $     */
d147 4
d308 1
a308 1
		printf("atapibus at %s", pnp);
d351 154
d506 4
a509 10
/* Test to see controller with at last one attached drive is there.
 * Returns a bit for each possible drive found (0x01 for drive 0,
 * 0x02 for drive 1).
 * Logic:
 * - If a status register is at 0xff, assume there is no drive here
 *   (ISA has pull-up resistors). If no drive at all -> return.
 * - reset the controller, wait for it to complete (may take up to 31s !).
 *   If timeout -> return.
 * - test ATA/ATAPI signatures. If at last one drive found -> return.
 * - try an ATA command on the master.
d529 1
a529 3
	/*
	 * Sanity check to see if the wdc channel responds at all.
	 */
d532 1
d544 5
a548 1
		if (st0 == 0xff)
d550 1
a550 1
		if (st1 == 0xff)
d556 2
a557 2
	/* assert SRST, wait for reset to complete */
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);
a558 5
	CHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_IDS); 
	DELAY(1000);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
	delay(1000);
	(void) CHP_READ_REG(chp, wdr_error);
d560 1
a560 1
	delay(10);
a566 1
	/* if reset failed, there's nothing here */
d571 3
a573 4
	 * Test presence of drives. First test register signatures looking for
	 * ATAPI devices. If it's not an ATAPI and reset said there may be
	 * something here assume it's ATA or OLD. Ghost will be killed later in
	 * attach routine.
d587 2
a588 2
		WDCDEBUG_PRINT(("%s:%d:%d: after reset, st=0x%x, sc=0x%x sn=0x%x "
		    "cl=0x%x ch=0x%x\n",
d598 1
a598 1
		} else {
d603 2
d690 1
d696 4
a699 2

		/* Issue a IDENTIFY command, to try to detect slave ghost */
d703 1
a703 2
			chp->ch_drive[0].drive_flags &= ~DRIVE_OLD;
			chp->ch_drive[1].drive_flags &= ~DRIVE_OLD;
d710 2
a711 33
			if ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)
				continue;
			/*
			 * Pre-ATA drive ?
			 * Test registers writability (Error register not
			 * writable, but cyllo is), then try an ATA command.
			 */
			CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));
			delay(10);
			CHP_WRITE_REG(chp, wdr_features, 0x58);
			CHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);
			if ((CHP_READ_REG(chp, wdr_error) == 0x58) ||
			    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {
				WDCDEBUG_PRINT(("%s:%d:%d: register "
				    "writability failed\n",
				    chp->wdc->sc_dev.dv_xname,
				    chp->channel, i), DEBUG_PROBE);
				    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;
			}
			CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));
			delay(100);
			if (wait_for_ready(chp, 10000) != 0) {
				WDCDEBUG_PRINT(("%s:%d:%d: not ready\n",
				    chp->wdc->sc_dev.dv_xname,
				    chp->channel, i), DEBUG_PROBE);
				chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;
				continue;
			}
			CHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);
			if (wait_for_ready(chp, 10000) != 0) {
				WDCDEBUG_PRINT(("%s:%d:%d: WDCC_RECAL failed\n",
				    chp->wdc->sc_dev.dv_xname,
				    chp->channel, i), DEBUG_PROBE);
a712 1
			}
d947 3
a949 4
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);
	delay(1000);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
a950 2
	(void) CHP_READ_REG(chp,wdr_error);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
a975 3
	/* Wait 50ms for drive firmware to settle */
	delay(50000);

d1005 1
a1005 1
	/* Reset timed out. Maybe it's because drv_mask was not rigth */
d1011 2
a1012 1
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x\n",
d1014 1
a1014 1
	    st0, st1), DEBUG_PROBE);
d1024 1
a1024 1
wdcwait(chp, mask, bits, timeout)
d1093 1
a1093 1
	return 0;
@


1.19
log
@

Fix to ATA detect. Some devices seem to be comatose after reset
(return 0x00 status persistently). Send them identify to wake them up.

Flag value 0x10000 will enable probe messages for a channel/controller.
When UKC supports setting flags, this will be useful debugging
failing IDE detects without kernel recompiles.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.18 2000/06/30 01:03:41 art Exp $     */
d372 3
a374 1
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
d459 3
a461 1
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
@


1.18
log
@Convert some parts to new timeouts.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.17 2000/06/13 04:12:02 chris Exp $     */
d97 2
d371 4
d431 1
d437 1
a437 1
		WDCDEBUG_PRINT(("%s:%d:%d: after reset, sc=0x%x sn=0x%x "
d440 1
a440 1
	    	    chp->channel, drive, sc, sn, cl, ch), DEBUG_PROBE);
d455 5
d515 5
d601 1
a601 1
		return;
d675 7
d1486 2
a1487 2
	WDCDEBUG_PRINT(("__wdccommand_done %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_FUNCS);
@


1.17
log
@Fix from Manuel Bouyer
Don't falsely detect nonexistent drives
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.16 2000/04/10 07:06:14 csapuntz Exp $     */
d509 1
d763 1
a763 1
	untimeout(wdctimeout, chp);
d1412 1
a1412 1
		timeout(wdctimeout, chp, wdc_c->timeout / 1000 * hz);
@


1.16
log
@

Added support for wd detach (merge from NetBSD). Support for
SCSI/ATAPI detach is not here yet.

Minor cleanup of wdc. Downgrade to UDMA mode 1 before going further.
Want to stay in UDMA modes because they're more error-resilient due to
a CRC.

Got rid of some of the ridiculous amount of softc sharing going on.
Hopefully, this will make the life of whoever goes in and fixes the
ref-counting to be correct easier.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.15 1999/12/14 08:28:15 csapuntz Exp $     */
d1398 1
a1398 1
		if (wdcwait(chp, wdc_c->r_st_bmask, wdc_c->r_st_bmask,
@


1.15
log
@

Change error diagnostic from "lost interrupt" to "timeout"

Interrupt may not actually be lost. Maybe the application sent an unreasonably
low timeout.

To conclude lost interrupt, the device driver needs to check that the device
actually transitioned to a new state. It is a bit premature to say this
here.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.14 1999/11/17 01:22:56 csapuntz Exp $     */
d112 1
d122 1
d132 1
a371 1

d389 1
a389 1
		if (ret_value == 0)
d451 18
d480 4
d509 1
a509 1

d525 1
a525 1
		if (ata_get_params(&chp->ch_drive[i], AT_POLL, &params) ==
d627 1
a627 1
		if (chp->ch_drive[i].drv_softc == NULL)
d712 16
d754 1
d765 6
a770 1
	return xfer->c_intr(chp, xfer, 1);
d795 3
a992 1
	struct device *drv_dev = drvp->drv_softc;
d995 1
a995 1
	int cf_flags;
d1007 1
a1007 1
		ata_get_params(drvp, AT_POLL, &params2);
d1057 1
a1057 1
				   AT_POLL) != CMD_OK)
d1087 1
a1087 1
				if (ata_set_mode(drvp, 0x20 | i, AT_POLL)
d1111 1
a1111 1
					    AT_POLL) != CMD_OK)
a1132 1
	cf_flags = drv_dev->dv_cfdata->cf_flags;
d1228 1
a1228 3
	struct device *drv_dev = drvp->drv_softc;

 	printf("%s: can use ", drv_dev->dv_xname);
a1256 1
	struct device *drv_dev = drvp->drv_softc;
d1258 1
a1258 1
	int cf_flags = drv_dev->dv_cfdata->cf_flags;
d1274 5
a1278 14
	if ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode > 2) {
		drvp->UDMA_mode = 2;
		printf("%s: transfer error, downgrading to DMA mode %d\n",
		    drv_dev->dv_xname, drvp->UDMA_mode);
	}

	/*
	 * If we were using ultra-DMA, don't downgrade to multiword DMA
	 * if we noticed a CRC error. It has been noticed that CRC errors
	 * in ultra-DMA lead to silent data corruption in multiword DMA.
	 * Data corruption is less likely to occur in PIO mode.
	 */

	if ((drvp->drive_flags & DRIVE_UDMA) &&
d1280 7
d1291 1
a1291 1
		    drv_dev->dv_xname, drvp->DMA_mode);
d1296 1
a1296 1
		    drv_dev->dv_xname, drvp->PIO_mode);
d1334 1
a1458 1
	int needdone = xfer->c_flags & C_NEEDDONE;
d1487 5
a1491 4
	if (needdone) {
		if (wdc_c->flags & AT_WAIT)
			wakeup(wdc_c);
		else
a1492 1
	}
a1576 1
	xfer->c_flags |= C_NEEDDONE; /* we can now call upper level done() */
d1635 18
d1662 5
a1666 12
	else {
		struct device *drv_dev = chp->ch_drive[xfer->drive].drv_softc;

		if (drv_dev) {
			printf("%s(%s:%d:%d): %s\n", drv_dev->dv_xname,
			       chp->wdc->sc_dev.dv_xname,
			       chp->channel, xfer->drive, msg);
		} else {
			printf("%s:%d:%d: %s\n", chp->wdc->sc_dev.dv_xname,
			       chp->channel, xfer->drive, msg);
		}
	}
@


1.15.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.30 2001/04/04 07:29:50 csapuntz Exp $     */
d84 1
a84 1
#include <sys/pool.h>
d104 1
a104 1
struct pool wdc_xfer_pool;
a111 1
void  wdc_kill_pending __P((struct channel_softc *));
a120 1
#define DEBUG_DETACH 0x80
a129 1
int at_poll = AT_POLL;
a141 4
int wdc_floating_bus __P((struct channel_softc *, int));
int wdc_preata_drive __P((struct channel_softc *, int));
int wdc_ata_present __P((struct channel_softc *, int));

d299 1
a299 1
		printf("atapiscsi at %s", pnp);
a341 154
int
wdc_floating_bus(chp, drive)
	struct channel_softc *chp;
	int drive;
	
{
	u_int8_t cumulative_status, status;
	int      iter;
	
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
	delay(10);

	/* Stolen from Phoenix BIOS Drive Autotyping document */
	cumulative_status = 0;
	for (iter = 0; iter < 100; iter++) {
		CHP_WRITE_REG(chp, wdr_seccnt, 0x7f);
		delay (1);

		status = CHP_READ_REG(chp, wdr_status);

		/* The other bits are meaningless if BSY is set */
		if (status & WDCS_BSY)
			continue;

		cumulative_status |= status;

#define BAD_BIT_COMBO  (WDCS_DRDY | WDCS_DSC | WDCS_DRQ | WDCS_ERR)
		if ((cumulative_status & BAD_BIT_COMBO) == BAD_BIT_COMBO)
			return 1;
	}

	/*
	 * Test register writability
	 */
	CHP_WRITE_REG(chp, wdr_cyl_lo, 0xaa);
	CHP_WRITE_REG(chp, wdr_cyl_hi, 0x55);
	CHP_WRITE_REG(chp, wdr_seccnt, 0xff);

	if (CHP_READ_REG(chp, wdr_cyl_lo) == 0xaa &&
	    CHP_READ_REG(chp, wdr_cyl_hi) == 0x55)
		return 0;

	CHP_WRITE_REG(chp, wdr_seccnt, 0x58);

	return 1;
}


int
wdc_preata_drive(chp, drive)
	struct channel_softc *chp;
	int drive;

{
	if (wdc_floating_bus(chp, drive)) {
		WDCDEBUG_PRINT(("%s:%d:%d: floating bus detected\n",
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
	delay(100);
	if (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY, 10000) != 0) {
		WDCDEBUG_PRINT(("%s:%d:%d: not ready\n",
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}
	
	CHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);
	if (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY, 10000) != 0) {
		WDCDEBUG_PRINT(("%s:%d:%d: WDCC_RECAL failed\n",
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	return 1;
}

int
wdc_ata_present(chp, drive)
	struct channel_softc *chp;
	int drive;
{
	int time_to_done;

	/* 
	   You're actually supposed to wait up to 10 seconds
	   for DRDY. However, as a practical matter, most
	   drives assert DRDY very quickly after dropping BSY.

	   The 10 seconds wait is sub-optimal because, according
	   to the ATA standard, the master should reply with 00
	   for any reads to a non-existant slave. 
	*/

	time_to_done = wdc_wait_for_status(chp, WDCS_DRDY, WDCS_DRDY, 1000);
      	if (time_to_done == -1) return 0;

	WDCDEBUG_PRINT(("%s:%d:%d: waiting for ready %d msec\n",
	    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
	    chp->channel, drive, time_to_done), DEBUG_PROBE);

	/* 
	   This section has been disabled because my Promise Ultra/66
	   starts interrupting like crazy when I issue a NOP. This
	   needs to be researched. - csapuntz@@openbsd.org
	*/
#if 0
	/* 
	   The NOP command always aborts.

	   If a drive doesn't understand NOP, it will abort the
	   command.

	   If a drive does understand NOP, it will abort the command.

	   If a drive is not present, we may get random crud on
	   register reads which will hopefully not pass the test.

	   Thanks to gluk@@ptci.ru for designing this check.
	*/

	CHP_WRITE_REG(chp, wdr_features, 0);
	CHP_WRITE_REG(chp, wdr_command, WDCC_NOP);
      	delay(10);

	time_to_done = wdc_wait_for_status(chp, 0, 0, 1000);

	if (time_to_done == -1) {
		WDCDEBUG_PRINT(("%s:%d:%d: timeout waiting for NOP to complete\n", 
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	WDCDEBUG_PRINT(("%s:%d:%d: NOP completed in %d msec\n",
	    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
	    chp->channel, drive, time_to_done), DEBUG_PROBE);

	if (!(chp->ch_status & WDCS_ERR) &&
	    !(chp->ch_error & WDCE_ABRT)) {
		WDCDEBUG_PRINT(("%s:%d:%d: NOP command did not ABORT command\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}
#endif

	return 1;
}

d343 10
a352 4
/* 
   Test to see controller with at least one attached drive is there.
   Returns a bit for each possible drive found (0x01 for drive 0,
   0x02 for drive 1).
d366 3
a368 6
#ifdef WDCDEBUG
	if ((chp->ch_flags & WDCF_VERBOSE_PROBE) ||
	    (chp->wdc &&
	    (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)))
		wdcdebug_mask |= DEBUG_PROBE;
#endif
a371 1
		/* Sample the statuses of drive 0 and 1 into st0 and st1 */
d383 1
a383 5
		/* 
		   If the status is 0x7f or 0xff, then it's
		   an empty channel with pull-up resistors.
		*/
		if ((st0 & 0x7f) == 0x7f)
d385 1
a385 1
		if ((st1 & 0x7f) == 0x7f)
d387 1
a387 1
		if (ret_value == 0) 
d391 2
a392 2
	/* reset the channel */
	CHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_4BIT); 
d394 5
d400 1
a400 1
	delay(2000);
d407 1
d412 4
a415 3
	 * Use signatures to find ATAPI drives
	 *
	 * Also detect presence of ATA drive (wdc_ata_present)
a422 1
		st0 = CHP_READ_REG(chp, wdr_status);
d428 2
a429 2
		WDCDEBUG_PRINT(("%s:%d:%d: after reset, st=0x%x, sc=0x%x"
		    " sn=0x%x cl=0x%x ch=0x%x\n",
d431 1
a431 1
	    	    chp->channel, drive, st0, sc, sn, cl, ch), DEBUG_PROBE);
d439 1
a439 1
		} else if (wdc_ata_present(chp, drive)) {
a443 2
		} else {
			ret_value &= ~(1 << drive);
a445 7

#ifdef WDCDEBUG
	if ((chp->ch_flags & WDCF_VERBOSE_PROBE) ||
	    (chp->wdc &&
	    (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)))
		wdcdebug_mask &= ~DEBUG_PROBE;
#endif
a448 18
/*
 * Call activate routine of underlying devices.
 */
int
wdcactivate(self, act)
	struct device *self;
	enum devact act;
{
	int error = 0;
	int s;

	s = splbio();
	config_activate_children(self, act);
	splx(s);

	return (error);
}

a459 4
	extern int cold;

	if (!cold)
		at_poll = AT_WAIT;
d479 1
a479 6
#ifdef WDCDEBUG
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_mask |= DEBUG_PROBE;
#endif

	/* initialise global data */
d481 1
a481 3
		/* Initialize the wdc_xfer pool. */
		pool_init(&wdc_xfer_pool, sizeof(struct wdc_xfer), 0,
		    0, 0, "wdcspl", 0, NULL, NULL, M_DEVBUF);
d485 1
a485 2
	timeout_set(&chp->ch_timo, wdctimeout, chp);
	
a493 1

d499 3
a501 5
		/*
		 * Issue an IDENTIFY command in order to distinct ATA from OLD.
		 * This also kill ATAPI ghost.
		 */
		if (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==
d504 2
a505 1
			chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;
d512 33
a544 2

			if (!wdc_preata_drive(chp, i))
d546 1
d559 1
a559 1
		goto exit;
d603 1
a603 1
		if (chp->ch_drive[i].drive_name[0] == 0)
a632 7

 exit:
#ifdef WDCDEBUG
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_mask &= ~DEBUG_PROBE;
#endif
	return;
a687 16
int
wdcdetach(chp, flags)
	struct channel_softc *chp;
	int flags;
{
	int s, rv;

	s = splbio();
	wdc_kill_pending(chp);

	rv = config_detach_children((struct device *)chp->wdc, flags);
	splx(s);

	return (rv);
}

a713 1
	int ret;
d721 2
d724 1
a724 6
	chp->ch_flags &= ~WDCF_IRQ_WAIT;
	timeout_del(&chp->ch_timo);
        ret = xfer->c_intr(chp, xfer, 1);
	if (ret == 0)	/* irq was not for us, still waiting for irq */
		chp->ch_flags |= WDCF_IRQ_WAIT;
	return (ret);
d749 6
a754 5
	if (!chp->_vtbl)
		chp->_vtbl = &wdc_default_vtbl;

	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_4BIT);
	delay(10);
a755 1
	delay(2000);
d781 3
d813 1
a813 1
	/* Reset timed out. Maybe it's because drv_mask was not right */
d819 1
a819 2
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x, "
			"reset time=%d msec\n",
d821 1
a821 1
	    st0, st1, timeout*WDCDELAY/1000), DEBUG_PROBE);
d831 1
a831 1
wdc_wait_for_status(chp, mask, bits, timeout)
d900 1
a900 1
	return time;
d908 1
a908 1
	struct wdc_xfer *xfer;
a913 8
	xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);

	/* Did we lose a race with the interrupt? */
	if (xfer == NULL ||
	    !timeout_triggered(&chp->ch_timo)) {
		splx(s);
		return;
	}	
d944 1
d947 1
a947 1
	int cf_flags = drvp->cf_flags;
d959 1
a959 1
		ata_get_params(drvp, at_poll, &params2);
d1009 1
a1009 1
				   at_poll) != CMD_OK)
a1032 6

		/* Some controllers don't support ATAPI DMA */
		if ((drvp->drive_flags & DRIVE_ATAPI) &&
		    (wdc->cap & WDC_CAPABILITY_NO_ATAPI_DMA))
			return;

d1039 1
a1039 1
				if (ata_set_mode(drvp, 0x20 | i, at_poll)
d1063 1
a1063 1
					    at_poll) != CMD_OK)
d1085 1
d1181 3
a1183 4
	/* This is actually a lie until we fix the _probe_caps
	   algorithm. Don't print out lies */
#if 0
 	printf("%s: can use ", drvp->drive_name);
a1200 24
#endif
}

void
wdc_print_current_modes(chp)
	struct channel_softc *chp;
{
	int drive;
	struct ata_drive_datas *drvp;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		printf("%s(%s:%d:%d): using PIO mode %d",
		    drvp->drive_name,
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive, drvp->PIO_mode);
		if (drvp->drive_flags & DRIVE_DMA)
			printf(", DMA mode %d", drvp->DMA_mode);
		if (drvp->drive_flags & DRIVE_UDMA)
			printf(", Ultra-DMA mode %d", drvp->UDMA_mode);
		printf("\n");
	}
d1212 1
d1214 1
a1214 1
	int cf_flags = drvp->cf_flags;
d1230 14
a1243 5
	if ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode >= 2) {
		drvp->UDMA_mode = (drvp->UDMA_mode == 2) ? 1 : 2;
		printf("%s: transfer error, downgrading to Ultra-DMA mode %d\n",
		    drvp->drive_name, drvp->UDMA_mode);
	} else 	if ((drvp->drive_flags & DRIVE_UDMA) &&
a1244 7
		/* 
		 * If we were using ultra-DMA, don't downgrade to
		 * multiword DMA if we noticed a CRC error. It has
		 * been noticed that CRC errors in ultra-DMA lead to
		 * silent data corruption in multiword DMA.  Data
		 * corruption is less likely to occur in PIO mode.  
		 */
d1249 1
a1249 1
		    drvp->drive_name, drvp->DMA_mode);
d1254 1
a1254 1
		    drvp->drive_name, drvp->PIO_mode);
a1291 1
	xfer->c_kill_xfer = __wdccommand_done;
d1307 7
a1313 2
			while ((wdc_c->flags & AT_DONE) == 0) {
				tsleep(wdc_c, PRIBIO, "wdccmd", 0);
d1315 4
d1343 1
a1343 1
#if 0
d1347 1
a1347 1
#endif
d1355 1
a1355 1
		if (wdcwait(chp, wdc_c->r_st_bmask | WDCS_DRQ, wdc_c->r_st_bmask,
d1368 1
a1368 1
		timeout_add(&chp->ch_timo, wdc_c->timeout / 1000 * hz);
a1400 2
        if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
                chp->wdc->irqack(chp);
d1416 1
d1419 2
a1420 2
	WDCDEBUG_PRINT(("__wdccommand_done %s:%d:%d %02x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, chp->ch_status), DEBUG_FUNCS);
a1439 1
#if 0
a1442 1
#endif
d1445 4
a1448 5

	if (wdc_c->flags & AT_WAIT)
		wakeup(wdc_c);
	else
		if (wdc_c->callback)
d1450 1
d1535 1
d1546 27
a1572 5
	xfer = pool_get(&wdc_xfer_pool,
	    ((flags & WDC_NOSLEEP) != 0 ? PR_NOWAIT : PR_WAITOK));
	splx(s);
	if (xfer != NULL)
		memset(xfer, 0, sizeof(struct wdc_xfer));
d1589 2
a1590 1
	pool_put(&wdc_xfer_pool, xfer);
a1593 18

/*
 * Kill off all pending xfers for a channel_softc.
 *
 * Must be called at splbio().
 */
void
wdc_kill_pending(chp)
	struct channel_softc *chp;
{
	struct wdc_xfer *xfer;

	while ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) != NULL) {
		chp = xfer->chp;
		(*xfer->c_kill_xfer)(chp, xfer);
	}
}

d1603 12
a1614 5
	else 
		printf("%s(%s:%d:%d): %s\n", 
		    chp->ch_drive[xfer->drive].drive_name,
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, xfer->drive, msg);
@


1.15.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.15.2.1 2001/05/14 22:24:24 niklas Exp $     */
d70 5
d114 1
d313 1
a313 1
        struct channel_softc *chp;
d315 1
a315 1
        CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
d320 1
a320 1
        struct channel_softc *chp;
d322 25
a346 1
        CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
d357 1
a357 1

d517 1
a517 1
	
a525 2

	
d642 1
d644 1
a644 3
#ifdef WDCDEBUG
	int    savedmask = wdcdebug_mask;
#endif
a666 6
	/* ATAPI drives need settling time. Give them 250ms */
	if ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||
	    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {
		delay(250 * 1000);
	}

a669 5

	if ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||
	    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {
		wdcdebug_mask = DEBUG_PROBE;
	}
d683 2
a684 4
		struct ata_drive_datas *drvp = &chp->ch_drive[i];

		drvp->chnl_softc = chp;
		drvp->drive = i;
d689 1
a689 1
			drvp->drive_flags |= DRIVE_CAP32;
d691 1
a691 1
		if ((drvp->drive_flags & DRIVE) == 0)
d700 1
a700 1
		if (ata_get_params(&chp->ch_drive[i], at_poll, &drvp->id) ==
d703 1
a703 1
			drvp->drive_flags &= ~DRIVE_OLD;
d705 1
a705 1
			drvp->drive_flags &=
d711 2
a712 3
			if ((drvp->drive_flags & DRIVE_OLD) && 
			    !wdc_preata_drive(chp, i))
				drvp->drive_flags &= ~DRIVE_OLD;
d727 24
d752 2
a753 1
		if ((chp->ch_drive[i].drive_flags & DRIVE) == 0) {
d757 1
a757 4
		if (chp->ch_drive[i].drive_flags & DRIVE_ATAPI)
			aa_link.aa_type = T_ATAPI;
		else
			aa_link.aa_type = T_ATA;
d771 2
d775 21
a803 2

	wdcdebug_mask = savedmask;
d1029 4
d1040 3
d1044 1
a1044 1

d1047 4
d1053 1
d1055 1
a1055 1
		if ((status & WDCS_BSY) == 0 && (status & mask) == bits)
d1066 4
d1144 1
a1144 1
	int i, valid_mode_found;
a1178 3
	WDCDEBUG_PRINT(("wdc_probe_caps: wdc_cap %d cf_flags %d\n", 
		    wdc->cap, cf_flags), DEBUG_PROBE);

d1185 1
a1185 1
		valid_mode_found = 0;
d1195 1
a1195 1
			if (i > 4)
a1196 6

			valid_mode_found = 1;

			if ((wdc->cap & WDC_CAPABILITY_MODE) == 0) {
				drvp->PIO_cap = i + 3;
				continue;
d1199 1
a1199 1
                        /*
d1202 2
a1203 1
			 * assume the BIOS set it up correctly
d1205 7
a1211 4
			if (ata_set_mode(drvp, 0x08 | (i + 3),
				at_poll) != CMD_OK)
				continue;

d1214 1
a1214 1
			 * set the highest one the controller supports
d1216 2
a1217 1
			if (wdc->PIO_cap >= i + 3) {
d1223 1
a1223 1
		if (!valid_mode_found) {
d1237 1
a1237 1
		valid_mode_found = 0;
d1246 3
a1248 3

			valid_mode_found = 1;

d1419 4
a1422 10

		printf("%s(%s:%d:%d):",
 		    drvp->drive_name,
		    chp->wdc->sc_dev.dv_xname, chp->channel, drive);

		if ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0 &&
		    !(drvp->cf_flags & ATA_CONFIG_PIO_SET))
			printf(" using BIOS timings");
		else
			printf(" using PIO mode %d", drvp->PIO_mode);
d1560 1
d1564 1
a1564 4

	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
	DELAY(1);

d1569 2
d1658 1
a1658 1

d1662 1
a1662 1

d1835 4
a1838 31

#include <sys/ataio.h>
#include <sys/file.h>
#include <sys/buf.h>

/*
 * Glue necessary to hook ATAIOCCOMMAND into physio
 */

struct wdc_ioctl {
	LIST_ENTRY(wdc_ioctl) wi_list;
	struct buf wi_bp;
	struct uio wi_uio;
	struct iovec wi_iov;
	atareq_t wi_atareq;
	struct ata_drive_datas *wi_drvp;
};

struct	wdc_ioctl *wdc_ioctl_find __P((struct buf *));
void	wdc_ioctl_free __P((struct wdc_ioctl *));
struct	wdc_ioctl *wdc_ioctl_get __P((void));
void	wdc_ioctl_strategy __P((struct buf *));

LIST_HEAD(, wdc_ioctl) wi_head;

/*
 * Allocate space for a ioctl queue structure.  Mostly taken from
 * scsipi_ioctl.c
 */
struct wdc_ioctl *
wdc_ioctl_get()
d1840 3
a1842 2
	struct wdc_ioctl *wi;
	int s;
a1843 2
	wi = malloc(sizeof(struct wdc_ioctl), M_TEMP, M_WAITOK);
	bzero(wi, sizeof (struct wdc_ioctl));
d1845 6
a1850 1
	LIST_INSERT_HEAD(&wi_head, wi, wi_list);
d1852 1
a1852 1
	return (wi);
a1854 4
/*
 * Free an ioctl structure and remove it from our list
 */

d1856 2
a1857 2
wdc_ioctl_free(wi)
	struct wdc_ioctl *wi;
d1859 2
d1864 3
a1866 1
	LIST_REMOVE(wi, wi_list);
a1867 208
	free(wi, M_TEMP);
}

/*
 * Find a wdc_ioctl structure based on the struct buf.
 */

struct wdc_ioctl *
wdc_ioctl_find(bp)
	struct buf *bp;
{
	struct wdc_ioctl *wi;
	int s;

	s = splbio();
	for (wi = wi_head.lh_first; wi != 0; wi = wi->wi_list.le_next)
		if (bp == &wi->wi_bp)
			break;
	splx(s);
	return (wi);
}

/*
 * Ioctl pseudo strategy routine
 *
 * This is mostly stolen from scsipi_ioctl.c:scsistrategy().  What
 * happens here is:
 *
 * - wdioctl() queues a wdc_ioctl structure.
 *
 * - wdioctl() calls physio/wdc_ioctl_strategy based on whether or not
 *   user space I/O is required.  If physio() is called, physio() eventually
 *   calls wdc_ioctl_strategy().
 *
 * - In either case, wdc_ioctl_strategy() calls wdc_exec_command()
 *   to perform the actual command
 *
 * The reason for the use of the pseudo strategy routine is because
 * when doing I/O to/from user space, physio _really_ wants to be in
 * the loop.  We could put the entire buffer into the ioctl request
 * structure, but that won't scale if we want to do things like download
 * microcode.
 */

void
wdc_ioctl_strategy(bp)
	struct buf *bp;
{
	struct wdc_ioctl *wi;
	struct wdc_command wdc_c;
	int error = 0;

	wi = wdc_ioctl_find(bp);
	if (wi == NULL) {
		printf("user_strat: No ioctl\n");
		error = EINVAL;
		goto bad;
	}

	bzero(&wdc_c, sizeof(wdc_c));

	/*
	 * Abort if physio broke up the transfer
	 */

	if (bp->b_bcount != wi->wi_atareq.datalen) {
		printf("physio split wd ioctl request... cannot proceed\n");
		error = EIO;
		goto bad;
	}

	/*
	 * Make sure a timeout was supplied in the ioctl request
	 */

	if (wi->wi_atareq.timeout == 0) {
		error = EINVAL;
		goto bad;
	}

	if (wi->wi_atareq.flags & ATACMD_READ)
		wdc_c.flags |= AT_READ;
	else if (wi->wi_atareq.flags & ATACMD_WRITE)
		wdc_c.flags |= AT_WRITE;

	if (wi->wi_atareq.flags & ATACMD_READREG)
		wdc_c.flags |= AT_READREG;

	wdc_c.flags |= AT_WAIT;

	wdc_c.timeout = wi->wi_atareq.timeout;
	wdc_c.r_command = wi->wi_atareq.command;
	wdc_c.r_head = wi->wi_atareq.head & 0x0f;
	wdc_c.r_cyl = wi->wi_atareq.cylinder;
	wdc_c.r_sector = wi->wi_atareq.sec_num;
	wdc_c.r_count = wi->wi_atareq.sec_count;
	wdc_c.r_precomp = wi->wi_atareq.features;
	if (wi->wi_drvp->drive_flags & DRIVE_ATAPI) {
		wdc_c.r_st_bmask = 0;
		wdc_c.r_st_pmask = 0;
		if (wdc_c.r_command == WDCC_IDENTIFY)
			wdc_c.r_command = ATAPI_IDENTIFY_DEVICE;
	} else {
		wdc_c.r_st_bmask = WDCS_DRDY;
		wdc_c.r_st_pmask = WDCS_DRDY;
	}
	wdc_c.data = wi->wi_bp.b_data;
	wdc_c.bcount = wi->wi_bp.b_bcount;

	if (wdc_exec_command(wi->wi_drvp, &wdc_c) != WDC_COMPLETE) {
		wi->wi_atareq.retsts = ATACMD_ERROR;
		goto bad;
	}

	if (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {
		if (wdc_c.flags & AT_ERROR) {
			wi->wi_atareq.retsts = ATACMD_ERROR;
			wi->wi_atareq.error = wdc_c.r_error;
		} else if (wdc_c.flags & AT_DF)
			wi->wi_atareq.retsts = ATACMD_DF;
		else
			wi->wi_atareq.retsts = ATACMD_TIMEOUT;
	} else {
		wi->wi_atareq.retsts = ATACMD_OK;
		if (wi->wi_atareq.flags & ATACMD_READREG) {
			wi->wi_atareq.head = wdc_c.r_head ;
			wi->wi_atareq.cylinder = wdc_c.r_cyl;
			wi->wi_atareq.sec_num = wdc_c.r_sector;
			wi->wi_atareq.sec_count = wdc_c.r_count; 
			wi->wi_atareq.features = wdc_c.r_precomp; 
			wi->wi_atareq.error = wdc_c.r_error; 
		}
	}

	bp->b_error = 0;
	biodone(bp);
	return;
bad:
	bp->b_flags |= B_ERROR;
	bp->b_error = error;
	biodone(bp);
}

int
wdc_ioctl(drvp, xfer, addr, flag)
	struct ata_drive_datas *drvp;
	u_long xfer;
	caddr_t addr;
	int flag;
{
	int error = 0;

	switch (xfer) {
	case ATAIOCCOMMAND:
		/*
		 * Make sure this command is (relatively) safe first
		 */
		if ((((atareq_t *) addr)->flags & ATACMD_READ) == 0 &&
		    (flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
		{
		struct wdc_ioctl *wi;
		atareq_t *atareq = (atareq_t *) addr;

		wi = wdc_ioctl_get();
		wi->wi_drvp = drvp;
		wi->wi_atareq = *atareq;

		if (atareq->datalen && atareq->flags &
		    (ATACMD_READ | ATACMD_WRITE)) {
			wi->wi_iov.iov_base = atareq->databuf;
			wi->wi_iov.iov_len = atareq->datalen;
			wi->wi_uio.uio_iov = &wi->wi_iov;
			wi->wi_uio.uio_iovcnt = 1;
			wi->wi_uio.uio_resid = atareq->datalen;
			wi->wi_uio.uio_offset = 0;
			wi->wi_uio.uio_segflg = UIO_USERSPACE;
			wi->wi_uio.uio_rw =
			    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE;
			wi->wi_uio.uio_procp = curproc;
			error = physio(wdc_ioctl_strategy, &wi->wi_bp, 0,
			    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE,
			    minphys, &wi->wi_uio);
		} else {
			/* No need to call physio if we don't have any
			   user data */
			wi->wi_bp.b_flags = 0;
			wi->wi_bp.b_data = 0;
			wi->wi_bp.b_bcount = 0;
			wi->wi_bp.b_dev = 0;
			wi->wi_bp.b_proc = curproc;
			LIST_INIT(&wi->wi_bp.b_dep);
			wdc_ioctl_strategy(&wi->wi_bp);
			error = wi->wi_bp.b_error;
		}
		*atareq = wi->wi_atareq;
		wdc_ioctl_free(wi);
		goto exit;
		}
	default:
		error = ENOTTY;
		goto exit;
	}

 exit:
	return (error);
d1869 1
@


1.15.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.15.2.2 2001/07/04 10:41:17 niklas Exp $     */
d350 12
d363 1
a363 1
	return 0;
a405 4
	int retry_cnt = 0;

	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
	delay(10);
a406 1
 retry:
a415 17
	time_to_done = wdc_wait_for_status(chp,
	    (WDCS_DRDY | WDCS_DSC | WDCS_DRQ), 
	    (WDCS_DRDY | WDCS_DSC), 1000);
      	if (time_to_done == -1) {
		if (retry_cnt == 0 && chp->ch_status == 0x00) {
			/* At least one flash card needs to be kicked */
			wdccommandshort(chp, drive, WDCC_CHECK_PWR);
			retry_cnt++;
			goto retry;
		}
		WDCDEBUG_PRINT(("%s:%d:%d: DRDY test timed out with status"
		    " %02x\n", 
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", 
		    chp->channel, drive, chp->ch_status),
		    DEBUG_PROBE);
		return 0;
	}
d417 32
a448 6
	if ((chp->ch_status & 0xfc) != (WDCS_DRDY | WDCS_DSC)) {
		WDCDEBUG_PRINT(("%s:%d:%d: status test for 0x50 failed with"
		    " %02x\n", 
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", 
		    chp->channel, drive, chp->ch_status),
		    DEBUG_PROBE);
d450 4
d457 1
a457 1
	WDCDEBUG_PRINT(("%s:%d:%d: waiting for ready %d msec\n",
d461 5
a465 13
	/*
	 * Test register writability
	 */
	CHP_WRITE_REG(chp, wdr_cyl_lo, 0xaa);
	CHP_WRITE_REG(chp, wdr_cyl_hi, 0x55);
	CHP_WRITE_REG(chp, wdr_seccnt, 0xff);
       	DELAY(10);

	if (CHP_READ_REG(chp, wdr_cyl_lo) != 0xaa &&
	    CHP_READ_REG(chp, wdr_cyl_hi) != 0x55) {
		WDCDEBUG_PRINT(("%s:%d:%d: register writability failed\n",
		  chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
	          chp->channel, drive), DEBUG_PROBE);
d468 1
d487 2
a488 3

	if (chp->_vtbl == 0) {
		int s = splbio();
a489 2
		splx(s);
	}
d495 3
a497 1
		wdcdebug_mask |= DEBUG_PROBE;	
d541 3
a543 1
	 * Use signatures to find potential ATAPI drives
d546 1
a546 1
 		if ((ret_value & (0x01 << drive)) == 0)
d566 1
a566 1
		if (cl == 0x14 && ch == 0xeb)
d568 1
a568 14
	}

	/* 
	 * Detect ATA drives by poking around the registers
	 */ 
	for (drive = 0; drive < 2; drive++) {
 		if ((ret_value & (0x01 << drive)) == 0)
			continue;
		if (chp->ch_drive[drive].drive_flags & DRIVE_ATAPI)
			continue;

		wdc_disable_intr(chp);
		/* ATA detect */
		if (wdc_ata_present(chp, drive)) {
a575 1
		wdc_enable_intr(chp);
a621 2
	timeout_set(&chp->ch_timo, wdctimeout, chp);

d664 1
d848 1
a848 1
	
a849 8
		/* Acknowledge interrupt by reading status */
		if (chp->_vtbl == 0) {
			bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, 
			    wdr_status & _WDC_REGMASK);
		} else {
			CHP_READ_REG(chp, wdr_status);
		}

d857 1
d1392 2
a1393 3
	 * We'd ideally like to use an Ultra DMA mode since they have the
	 * protection of a CRC. So we try each Ultra DMA mode and see if
	 * we can find any working combo
d1395 2
a1396 2
	if ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode > 0) {
		drvp->UDMA_mode = drvp->UDMA_mode - 1;
@


1.15.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d80 1
a80 1
#include <uvm/uvm_extern.h>
@


1.15.2.5
log
@Merge in trunk
@
text
@d662 1
a662 1
		    0, 0, "wdcspl", NULL);
a1247 4
	if ((wdc->cap & WDC_CAPABILITY_UDMA) == 0) {
		/* don't care about UDMA modes */
		return;
	}
d1982 1
a1982 1
wdc_ioctl(drvp, xfer, addr, flag, p)
a1986 1
	struct proc *p;
@


1.15.2.6
log
@Merge in -current from about a week ago
@
text
@a88 1
#include <dev/ic/wdcevent.h>
d101 7
a107 7
static void  __wdcerror(struct channel_softc*, char *);
static int   __wdcwait_reset(struct channel_softc *, int);
void  __wdccommand_done(struct channel_softc *, struct wdc_xfer *);
void  __wdccommand_start(struct channel_softc *, struct wdc_xfer *);	
int   __wdccommand_intr(struct channel_softc *, struct wdc_xfer *, int);
int   wdprint(void *, const char *);
void  wdc_kill_pending(struct channel_softc *);
d128 14
a141 14
u_int8_t wdc_default_read_reg(struct channel_softc *, enum wdc_regs);
void wdc_default_write_reg(struct channel_softc *, enum wdc_regs, u_int8_t);
void wdc_default_read_raw_multi_2(struct channel_softc *, 
    void *, unsigned int);
void wdc_default_write_raw_multi_2(struct channel_softc *, 
    void *, unsigned int);
void wdc_default_read_raw_multi_4(struct channel_softc *, 
    void *, unsigned int);
void wdc_default_write_raw_multi_4(struct channel_softc *, 
    void *, unsigned int);

int wdc_floating_bus(struct channel_softc *, int);
int wdc_preata_drive(struct channel_softc *, int);
int wdc_ata_present(struct channel_softc *, int);
a151 122
static char *wdc_log_buf = NULL;
static int wdc_tail = 0;
static int wdc_head = 0;
static int wdc_size = 16 * 1024;
static int chp_idx = 1;

void
wdc_log(struct channel_softc *chp, int type, 
    unsigned int size, char val[]) 
{
	unsigned int request_size;
	int idx;
	char *ptr;
	int nbytes;

	if (wdc_head < 0 || wdc_head > wdc_size ||
	    wdc_tail < 0 || wdc_tail > wdc_size) {
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head, wdc_tail);
		return;
	}

	if (size > wdc_size / 2) {
		printf ("wdc_log: type %d size %x\n", type, size);
	}

	if (wdc_log_buf == NULL) {
		wdc_log_buf = malloc(wdc_size, M_DEVBUF, M_NOWAIT);
		if (wdc_log_buf == NULL) 
			return;
	}
	if (chp->ch_log_idx == 0)
		chp->ch_log_idx = chp_idx++;

	request_size = size + 2;

	/* Check how many bytes are left */
	nbytes = wdc_head - wdc_tail;
	if (nbytes < 0) nbytes += wdc_size;

	if (nbytes + request_size >= wdc_size) {
		wdc_tail = (wdc_tail + request_size * 2) % wdc_size;
	}

	/* Avoid wrapping in the middle of a request */
	if (wdc_head + request_size >= wdc_size) {
		memset(&wdc_log_buf[wdc_head], 0, wdc_size - wdc_head);
		wdc_head = 0;
	}

	ptr = &wdc_log_buf[wdc_head];
	*ptr++ = type & 0xff;		
	*ptr++ = ((chp->ch_log_idx & 0x7) << 5) | (size & 0x1f);
				  
	idx = 0;
	while (size--) {
		*ptr++ = val[idx];
		idx++;
	}
	wdc_head += request_size;
}

char *wdc_get_log(unsigned int *, unsigned int *);

char *
wdc_get_log(unsigned int * size, unsigned int *left)
{
        int  bytes = (wdc_head - wdc_tail);
        char *retbuf;
        int  ot, c1, c2;

	if (left != NULL)
		*left = 0;

        if (bytes < 0) bytes += wdc_size;
	if (bytes > *size) { 
		if (left != NULL) {
			*left = bytes - *size;
		}
		bytes = *size;
	}

	if (wdc_log_buf == NULL) {
		*size = 0;
		*left = 0;
		return (NULL);
	}

	if (wdc_head < 0 || wdc_head > wdc_size ||
	    wdc_tail < 0 || wdc_tail > wdc_size) {
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head, wdc_tail);
		*size = 0;
		*left = 0;
		return (NULL);
	}

        retbuf = malloc(bytes, M_TEMP, M_NOWAIT);
	if (retbuf == NULL) {
		*size = 0;
		*left = bytes;
		return (NULL);
	}

	*size = bytes;

        ot = wdc_tail;
        wdc_tail += bytes;
        if (wdc_tail > wdc_size) {
                wdc_tail -= wdc_size;
                c2 = wdc_tail;
                c1 = bytes - wdc_tail;
        } else {
                c1 = bytes;
                c2 = 0;
        }

        memcpy(retbuf, &wdc_log_buf[ot], c1);
        memcpy(&retbuf[c1], &wdc_log_buf[0], c2);

        return (retbuf);
}


a318 7
void
wdc_set_drive(struct channel_softc *chp, int drive) 
{
	CHP_WRITE_REG(chp, wdr_sdh, (drive << 4) | WDSD_IBM);
	WDC_LOG_SET_DRIVE(chp, drive);
}

d328 1
a328 1
	wdc_set_drive(chp, drive);
d368 1
a368 1
	wdc_set_drive(chp, drive);
a377 1
	WDC_LOG_ATA_CMDSHORT(chp, WDCC_RECAL);
d396 1
a396 1
	wdc_set_drive(chp, drive);
d491 1
a491 1
		wdc_set_drive(chp, 0);
d494 1
a494 2
		WDC_LOG_STATUS(chp, st0);
		wdc_set_drive(chp, 1);
a496 1
		WDC_LOG_STATUS(chp, st1);
d534 1
a534 1
		wdc_set_drive(chp, drive);
a541 1
		WDC_LOG_REG(chp, wdr_cyl_lo, (ch << 8) | cl);
d928 1
a928 1
		wdc_set_drive(chp, 0);
d931 1
a931 1
		wdc_set_drive(chp, 1);
a988 1
		WDC_LOG_STATUS(chp, chp->ch_status);
d991 1
a991 1
			wdc_set_drive(chp, 1);
a993 1
			WDC_LOG_STATUS(chp, chp->ch_status);
a1007 2
		WDC_LOG_ERROR(chp, chp->ch_error);

d1515 1
a1515 1
	wdc_set_drive(chp, drive);
a1642 2
	WDC_LOG_ATA_CMDLONG(chp, head, precomp, cylin, cylin >> 8, sector,
	    count, command);
a1672 1
	WDC_LOG_ATA_CMDSHORT(chp, command);
d1804 4
a1807 4
struct	wdc_ioctl *wdc_ioctl_find(struct buf *);
void	wdc_ioctl_free(struct wdc_ioctl *);
struct	wdc_ioctl *wdc_ioctl_get(void);
void	wdc_ioctl_strategy(struct buf *);
a1995 21
	case ATAIOGETTRACE: {
		struct atagettrace *agt = (struct atagettrace *)addr;
		unsigned int size = 0;
		char *log_to_copy;
		
		size = agt->buf_size;
		if (size > 65536) {
			size = 65536;
		}

		log_to_copy = wdc_get_log(&size, &agt->bytes_left);

		if (log_to_copy != NULL) {
			error = copyout(log_to_copy, agt->buf, size);
			free(log_to_copy, M_TEMP);
		}

		agt->bytes_copied = size;
		break;
	}

@


1.15.2.7
log
@Sync the SMP branch with 3.3
@
text
@d6 1
a6 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
d122 1
a122 4
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_mask & (level)) != 0)	\
		printf args;			\
} while (0)
d160 1
a160 1
wdc_log(struct channel_softc *chp, enum wdcevent_type type, 
d898 12
a909 1
	splassert(IPL_BIO);
d912 1
a912 1
	if ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) == NULL) {
d924 1
a924 1
		panic("wdcstart: channel waiting for irq");
d998 1
a998 1
	xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
d1061 1
a1061 1
	for (timeout = 0; timeout < WDCNDELAY_RST; timeout++) {
d1153 1
a1153 1
		struct wdc_xfer *xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
d1249 1
a1249 1
	/* Use PIO mode 3 as a default value for ATAPI devices */
a1255 37
	valid_mode_found = 0;

	WDCDEBUG_PRINT(("%s: atap_oldpiotiming=%d\n", __func__,
	    params->atap_oldpiotiming), DEBUG_PROBE);
	/*
	 * ATA-4 compliant devices contain PIO mode
	 * number in atap_oldpiotiming.
	 */
	if (params->atap_oldpiotiming <= 2) {
		drvp->PIO_cap = params->atap_oldpiotiming;
		valid_mode_found = 1;
		drvp->drive_flags |= DRIVE_MODE;
	} else if (params->atap_oldpiotiming > 180 &&
	    params->atap_oldpiotiming <= 600) {
		/*
		 * ATA-2 compliant devices contain cycle
		 * time in atap_oldpiotiming.
		 * A device with a cycle time of 180ns
		 * or less is at least PIO mode 3 and
		 * should be reporting that in
		 * atap_piomode_supp, so ignore it here.
		 * A cycle time greater than 600ns seems
		 * to be invalid.
		 */
		if (params->atap_oldpiotiming <= 240) {
			drvp->PIO_cap = 2;
		} else if (params->atap_oldpiotiming <= 480) {
			drvp->PIO_cap = 1;
		} else {
			drvp->PIO_cap = 0;
		}
		valid_mode_found = 1;
		drvp->drive_flags |= DRIVE_MODE;
	}
	if (valid_mode_found)
		drvp->PIO_mode = drvp->PIO_cap;

d1262 1
d1613 1
a1613 1
		panic("wdc_exec_command: polled command not done");
d1663 3
a1665 1
			goto timeout;
a1671 18

	if ((wdc_c->flags & AT_WRITE) == AT_WRITE) {
		delay(10);
		if (wait_for_unbusy(chp, wdc_c->timeout) != 0)
			goto timeout;
		
		if ((chp->ch_status & (WDCS_DRQ | WDCS_ERR)) == WDCS_ERR) {
			__wdccommand_done(chp, xfer);
			return;
		}

		if (wait_for_drq(chp, wdc_c->timeout) != 0)
			goto timeout;

		wdc_output_bytes(&chp->ch_drive[drive], 
		    wdc_c->data, wdc_c->bcount);
	}

a1676 1

a1682 6
	return;

 timeout:
	wdc_c->flags |= AT_TIMEOU;
	__wdccommand_done(chp, xfer);
	return;
d1709 1
a1709 2

	if ((wdc_c->flags & AT_READ) && (chp->ch_status & WDCS_DRQ)) {
d1711 2
a1712 1
		/* Should we wait for device to indicate idle? */
a1799 37
 * Send a 48-bit addressing command. The drive should be ready.
 * Assumes interrupts are blocked.
 */
void
wdccommandext(chp, drive, command, blkno, count)
	struct channel_softc *chp;
	u_int8_t drive;
	u_int8_t command;
	u_int64_t blkno;
	u_int16_t count;
{
	WDCDEBUG_PRINT(("wdccommandext %s:%d:%d: command=0x%x blkno=%llu "
	    "count=%d\n", chp->wdc->sc_dev.dv_xname,
	    chp->channel, drive, command, blkno, count),
	    DEBUG_FUNCS);
	WDC_LOG_ATA_CMDEXT(chp, blkno >> 40, blkno >> 16, blkno >> 32,
	    blkno >> 8, blkno >> 24, blkno, count >> 8, count, command);

	/* Select drive and LBA mode. */
	CHP_WRITE_REG(chp, wdr_sdh, (drive << 4) | WDSD_LBA);

	/* Load parameters. All registers are two byte deep FIFOs. */
	CHP_WRITE_REG(chp, wdr_lba_hi, blkno >> 40);
	CHP_WRITE_REG(chp, wdr_lba_hi, blkno >> 16);
	CHP_WRITE_REG(chp, wdr_lba_mi, blkno >> 32);
	CHP_WRITE_REG(chp, wdr_lba_mi, blkno >> 8);
	CHP_WRITE_REG(chp, wdr_lba_lo, blkno >> 24);
	CHP_WRITE_REG(chp, wdr_lba_lo, blkno);
	CHP_WRITE_REG(chp, wdr_seccnt, count >> 8);
	CHP_WRITE_REG(chp, wdr_seccnt, count);

	/* Send command. */
	CHP_WRITE_REG(chp, wdr_command, command);
	return;
}

/*
d1839 1
a1839 1
	    !TAILQ_EMPTY(&chp->ch_queue->sc_xfer)) {
d1905 1
a1905 1
	struct wdc_xfer *xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
d1998 1
a1998 1
	LIST_FOREACH(wi, &wi_head, wi_list)
a2033 1
	int s;
a2117 1
	s = splbio();
a2118 1
	splx(s);
a2122 1
	s = splbio();
a2123 1
	splx(s);
d2138 1
a2138 1
		atagettrace_t *agt = (atagettrace_t *)addr;
@


1.15.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d98 1
a98 1
#endif /* 0 */
d102 2
a103 3
void  __wdcerror(struct channel_softc *, char *);
void  __wdcdo_reset(struct channel_softc *);
int   __wdcwait_reset(struct channel_softc *, int);
d105 1
a105 1
void  __wdccommand_start(struct channel_softc *, struct wdc_xfer *);
d110 5
a114 5
#define DEBUG_INTR    0x01
#define DEBUG_XFERS   0x02
#define DEBUG_STATUS  0x04
#define DEBUG_FUNCS   0x08
#define DEBUG_PROBE   0x10
d116 2
a117 2
#define DEBUG_SDRIVE  0x40
#define DEBUG_DETACH  0x80
d120 1
a120 4
#ifndef WDCDEBUG_MASK
#define WDCDEBUG_MASK 0x00
#endif
int wdcdebug_mask = WDCDEBUG_MASK;
d128 1
a128 1
#endif /* WDCDEBUG */
d134 1
a134 1
void wdc_default_read_raw_multi_2(struct channel_softc *,
d136 1
a136 1
void wdc_default_write_raw_multi_2(struct channel_softc *,
d138 1
a138 1
void wdc_default_read_raw_multi_4(struct channel_softc *,
d140 1
a140 1
void wdc_default_write_raw_multi_4(struct channel_softc *,
d157 3
a159 3
static unsigned int wdc_tail = 0;
static unsigned int wdc_head = 0;
static unsigned int wdc_size = 16 * 1024;
d163 2
a164 2
wdc_log(struct channel_softc *chp, enum wdcevent_type type,
    unsigned int size, char val[])
d173 1
a173 2
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head,
		    wdc_tail);
d183 1
a183 1
		if (wdc_log_buf == NULL)
d206 1
a206 1
	*ptr++ = type & 0xff;
d208 1
a208 1

d222 3
a224 3
	int  bytes = (wdc_head - wdc_tail);
	char *retbuf;
	int  ot, c1, c2;
d229 2
a230 3
	if (bytes < 0)
		bytes += wdc_size;
	if ((u_int)bytes > *size) {
d245 1
a245 2
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head,
		    wdc_tail);
d251 1
a251 1
	retbuf = malloc(bytes, M_TEMP, M_NOWAIT);
d260 10
a269 10
	ot = wdc_tail;
	wdc_tail += bytes;
	if (wdc_tail > wdc_size) {
		wdc_tail -= wdc_size;
		c2 = wdc_tail;
		c1 = bytes - wdc_tail;
	} else {
		c1 = bytes;
		c2 = 0;
	}
d271 2
a272 2
	memcpy(retbuf, &wdc_log_buf[ot], c1);
	memcpy(&retbuf[c1], &wdc_log_buf[0], c2);
d274 1
a274 1
	return (retbuf);
d283 1
a283 1
#ifdef DIAGNOSTIC
d287 1
a287 1
#endif /* DIAGNOSTIC */
d289 1
a289 1
	if (reg & _WDC_AUX)
d303 1
a303 1
#ifdef DIAGNOSTIC
d307 1
a307 1
#endif /* DIAGNOSTIC */
d309 1
a309 1
	if (reg & _WDC_AUX)
d325 1
a325 1
		unsigned int i;
d334 1
a334 1
	bus_space_read_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0,
d347 1
a347 1
		unsigned int i;
d356 1
a356 1
	bus_space_write_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0,
d369 1
a369 1
		unsigned int i;
d378 1
a378 1
	bus_space_write_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0,
d391 1
a391 1
		unsigned int i;
d400 1
a400 1
	bus_space_read_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0,
d433 1
a433 1
	struct channel_softc *chp;
d435 1
a435 1
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
d440 1
a440 1
	struct channel_softc *chp;
d442 1
a442 1
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
d446 1
a446 1
wdc_set_drive(struct channel_softc *chp, int drive)
d456 1
a456 1

d509 1
a509 1

d533 2
a534 2
retry:
	/*
d541 1
a541 1
	   for any reads to a non-existent slave.
d544 1
a544 1
	    (WDCS_DRDY | WDCS_DSC | WDCS_DRQ),
d546 1
a546 1
	if (time_to_done == -1) {
d554 2
a555 2
		    " %02x\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
d563 2
a564 2
		    " %02x\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
d581 1
a581 1
	DELAY(10);
d586 2
a587 2
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive), DEBUG_PROBE);
d595 4
a598 13
/*
 * Test to see controller with at least one attached drive is there.
 * Returns a bit for each possible drive found (0x01 for drive 0,
 * 0x02 for drive 1).
 * Logic:
 * - If a status register is at 0x7f or 0xff, assume there is no drive here
 *   (ISA has pull-up resistors).  Similarly if the status register has
 *   the value we last wrote to the bus (for IDE interfaces without pullups).
 *   If no drive at all -> return.
 * - reset the controller, wait for it to complete (may take up to 31s !).
 *   If timeout -> return.
 * - test ATA/ATAPI signatures. If at last one drive found -> return.
 * - try an ATA command on the master.
a607 3
#ifdef WDCDEBUG
	int savedmask = wdcdebug_mask;
#endif
d619 2
a620 2
		wdcdebug_mask |= DEBUG_PROBE;
#endif /* WDCDEBUG */
d634 1
a634 1
		WDCDEBUG_PRINT(("%s:%d: before reset, st0=0x%b, st1=0x%b\n",
d636 1
a636 2
		    chp->channel, st0, WDCS_BITS, st1, WDCS_BITS),
		    DEBUG_PROBE);
d638 5
a642 1
		if ((st0 & 0x7f) == 0x7f || st0 == WDSD_IBM)
d644 1
a644 1
		if ((st1 & 0x7f) == 0x7f || st1 == (WDSD_IBM | 0x10))
d646 1
a646 1
		if (ret_value == 0)
d651 4
a654 1
	__wdcdo_reset(chp);
d680 1
a680 1
		WDCDEBUG_PRINT(("%s:%d:%d: after reset, st=0x%b, sc=0x%x"
d683 1
a683 2
		    chp->channel, drive, st0, WDCS_BITS, sc, sn, cl, ch),
		    DEBUG_PROBE);
d693 1
a693 1
	/*
d695 1
a695 1
	 */
d716 4
a719 1
	wdcdebug_mask = savedmask;
d721 1
a721 1
	return (ret_value);
d767 1
a767 1
#endif /* __OpenBSD__ */
d793 1
a793 1
#endif /* WDCDEBUG */
d803 1
a803 1

d821 2
a822 2
		 * Wait a bit, some devices are weird just after a reset.
		 * Then issue a IDENTIFY command, to try to detect slave ghost.
a823 1
		delay(5000);
d826 1
a826 1
			/* If IDENTIFY succeeded, this is not an OLD ctrl */
d835 1
a835 1
			if ((drvp->drive_flags & DRIVE_OLD) &&
d868 1
a868 1
	 * reset drive_flags for unattached devices, reset state for attached
d880 1
a880 1
exit:
d882 3
d917 1
a917 1
#endif /* DIAGNOSTIC */
d960 1
a960 1

d975 1
a975 1

d979 1
a979 1
			bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
a990 10
	if (chp->ch_flags & WDCF_DMA_WAIT) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, chp->channel,
		    xfer->drive, 0);
		if (chp->wdc->dma_status & WDC_DMAST_NOIRQ) {
			/* IRQ not for us, not detected by DMA engine */
			return 0;
		}
		chp->ch_flags &= ~WDCF_DMA_WAIT;
	}
d992 1
a992 1
	ret = xfer->c_intr(chp, xfer, 1);
d1023 4
a1026 1
	__wdcdo_reset(chp);
d1041 1
a1041 1
	return (drv_mask1 != drv_mask2) ? 1 : 0;
d1044 1
a1044 12
void
__wdcdo_reset(struct channel_softc *chp)
{
	wdc_set_drive(chp, 0);
	DELAY(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT | WDCTL_RST);
	delay(10000);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
	delay(10000);
}

int
d1050 1
a1050 1
	u_int8_t st0, er0, st1, er1;
a1056 1
		er0 = CHP_READ_REG(chp, wdr_error);
a1059 1
		er1 = CHP_READ_REG(chp, wdr_error);
d1087 2
a1088 2
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%b, er0=0x%x, "
	    "st1=0x%b, er1=0x%x, reset time=%d msec\n",
d1090 1
a1090 2
	    st0, WDCS_BITS, er0, st1, WDCS_BITS, er1,
	    timeout * WDCDELAY / 1000), DEBUG_PROBE);
d1119 1
a1119 1
			chp->ch_status = status =
d1126 2
a1127 2
			WDCDEBUG_PRINT(("wdcwait: timeout, status 0x%b "
			    "error 0x%x\n", status, WDCS_BITS,
d1129 1
a1129 1
			    DEBUG_STATUSX | DEBUG_STATUS);
d1150 1
a1150 1
		else
d1156 1
a1156 1
#endif /* WDCNDELAY_DEBUG */
a1159 24
/*
 * Busy-wait for DMA to complete
 */
int
wdc_dmawait(chp, xfer, timeout)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
{
	int time;
	for (time = 0; time < timeout * 1000 / WDCDELAY; time++) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
		    chp->channel, xfer->drive, 0);
		if ((chp->wdc->dma_status & WDC_DMAST_NOIRQ) == 0)
			return 0;
		delay(WDCDELAY);
	}
	/* timeout, force a DMA halt */
	chp->wdc->dma_status = (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
	    chp->channel, xfer->drive, 1);
	return 1;
}

d1178 1
a1178 1
	}
a1184 6
		if (chp->ch_flags & WDCF_DMA_WAIT) {
			chp->wdc->dma_status =
			    (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
			    chp->channel, xfer->drive, 1);
			chp->ch_flags &= ~WDCF_DMA_WAIT;
		}
d1199 2
a1200 2
 * Probe drive's capabilities, for use by the controller later.
 * Assumes drvp points to an existing drive.
a1212 15
	if ((wdc->cap & WDC_CAPABILITY_SATA) != 0 &&
	    (params->atap_sata_caps != 0x0000 &&
	    params->atap_sata_caps != 0xffff)) {
		WDCDEBUG_PRINT(("%s: atap_sata_caps=0x%x\n", __func__,
		    params->atap_sata_caps), DEBUG_PROBE);

		/* Skip ATA modes detection for native SATA drives */
		drvp->PIO_mode = drvp->PIO_cap = 4;
		drvp->DMA_mode = drvp->DMA_cap = 2;
		drvp->UDMA_mode = drvp->UDMA_cap = 5;
		drvp->drive_flags |= DRIVE_SATA | DRIVE_MODE | DRIVE_UDMA;
		drvp->ata_vers = 4;
		return;
	}

d1230 1
a1230 1
	if (params->atap_ata_major > 0x01 &&
d1239 2
a1240 2
	} else
#endif /* 0 */
d1245 2
a1246 2
	WDCDEBUG_PRINT(("wdc_probe_caps: wdc_cap 0x%x cf_flags 0x%x\n",
	    wdc->cap, cf_flags), DEBUG_PROBE);
d1260 2
a1261 1
	} else if (params->atap_oldpiotiming > 180) {
d1269 2
d1274 2
d1277 1
a1277 1
			drvp->PIO_cap = 1;
a1284 6
	WDCDEBUG_PRINT(("%s: atap_extensions=0x%x, atap_piomode_supp=0x%x, "
	    "atap_dmamode_supp=0x%x, atap_udmamode_supp=0x%x\n",
	    __func__, params->atap_extensions, params->atap_piomode_supp,
	    params->atap_dmamode_supp, params->atap_udmamode_supp),
	    DEBUG_PROBE);

d1286 1
a1286 1
	 * It's not in the specs, but it seems that some drive
d1295 1
a1295 1
		 * If higher mode than 7 is found, abort.
d1310 1
a1310 1
			/*
d1316 1
a1316 1
			    at_poll) != CMD_OK)
d1330 1
a1330 1
			/*
d1438 1
a1438 1
	unsigned int len = buflen, roundlen;
d1443 1
a1443 1
		CHP_WRITE_RAW_MULTI_4(chp,
d1453 1
a1453 1
		CHP_WRITE_RAW_MULTI_2(chp,
d1501 1
a1501 1
	} else
d1513 1
a1513 1

d1515 1
a1515 1
#endif /* 0 */
d1580 1
a1580 1
		/*
d1585 1
a1585 1
		 * corruption is less likely to occur in PIO mode.
d1624 1
a1624 1
	}
d1642 1
a1642 1
#endif /* DIAGNOSTIC */
d1666 1
a1666 1
{
d1689 2
a1690 2
		if (wdcwait(chp, wdc_c->r_st_bmask | WDCS_DRQ,
		    wdc_c->r_st_bmask, wdc_c->timeout) != 0) {
d1700 1
a1700 2
		/* wait at least 400ns before reading status register */
		DELAY(10);
d1703 1
a1703 1

d1712 1
a1712 1
		wdc_output_bytes(&chp->ch_drive[drive],
d1730 1
a1730 1
timeout:	
d1733 1
d1750 2
a1751 2
	    (irq == 0) ? wdc_c->timeout : 0)) {
		if (irq && (xfer->c_flags & C_TIMEOU) == 0)
d1754 3
a1756 1
		goto out;
d1758 4
a1761 7
	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);
	if (wdc_c->flags & AT_READ) {
		if ((chp->ch_status & WDCS_DRQ) == 0) {
			wdc_c->flags |= AT_TIMEOU;
			goto out;
		}
a1764 1
out:
d1778 1
a1778 2
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    chp->ch_status), DEBUG_FUNCS);
d1786 2
a1787 2
	if ((wdc_c->flags & AT_READREG) != 0 &&
	    (wdc_c->flags & (AT_ERROR | AT_DF)) == 0) {
d1794 1
a1794 1
		wdc_c->r_precomp = wdc_c->r_error;
d1813 1
d1988 2
a1989 2
void
__wdcerror(chp, msg)
d1997 2
a1998 2
	else
		printf("%s(%s:%d:%d): %s\n",
d2004 1
a2004 1
/*
d2009 1
a2009 1
	struct channel_softc *chp;
d2137 1
a2137 1
	if ((u_long)bp->b_bcount != wi->wi_atareq.datalen) {
d2200 3
a2202 3
			wi->wi_atareq.sec_count = wdc_c.r_count;
			wi->wi_atareq.features = wdc_c.r_precomp;
			wi->wi_atareq.error = wdc_c.r_error;
d2234 1
a2234 1

d2304 1
a2304 1
exit:
@


1.15.2.9
log
@Merge with the trunk
@
text
@d163 1
a163 1
static unsigned int wdc_log_cap = 16 * 1024;
d171 1
d173 6
a178 9
	int log_size;
	unsigned int head = wdc_head;
	unsigned int tail = wdc_tail;

#ifdef DIAGNOSTIC
	if (head < 0 || head > wdc_log_cap ||
	    tail < 0 || tail > wdc_log_cap) {
		printf ("wdc_log: head %x wdc_tail %x\n", head,
		    tail);
d182 1
a182 1
	if (size > wdc_log_cap / 2) {
a183 1
		return;
a184 1
#endif
d187 1
a187 1
		wdc_log_buf = malloc(wdc_log_cap, M_DEVBUF, M_NOWAIT);
d197 2
a198 2
	log_size = head - tail;
	if (log_size < 0) log_size += wdc_log_cap;
d200 2
a201 12
	if (log_size + request_size >= wdc_log_cap) {
		int nb = 0; 
		int rec_size;

		while (nb <= (request_size * 2)) {
			if (wdc_log_buf[tail] == 0)
				rec_size = 1;
			else
				rec_size = (wdc_log_buf[tail + 1] & 0x1f) + 2;
			tail = (tail + rec_size) % wdc_log_cap;
			nb += rec_size;
		}
d205 3
a207 3
	if (head + request_size >= wdc_log_cap) {
		memset(&wdc_log_buf[head], 0, wdc_log_cap - head);
		head = 0;
d210 1
a210 1
	ptr = &wdc_log_buf[head];
a212 1
	memcpy(ptr, val, size);
d214 6
a219 2
	wdc_head = (head + request_size) % wdc_log_cap;
	wdc_tail = tail;
d227 3
a229 8
	int  log_size;
	char *retbuf = NULL;
	int  nb, tocopy;
	int  s;
	unsigned int head = wdc_head;
	unsigned int tail = wdc_tail;

	s = splbio();
a230 1
	log_size = (head - tail);
d234 8
a241 6
	if (log_size < 0)
		log_size += wdc_log_cap;

	tocopy = log_size;
	if ((u_int)tocopy > *size)
		tocopy = *size;
d246 1
a246 1
		goto out;
d249 4
a252 5
#ifdef DIAGNOSTIC
	if (head < 0 || head > wdc_log_cap ||
	    tail < 0 || tail > wdc_log_cap) {
		printf ("wdc_log: head %x tail %x\n", head,
		    tail);
d255 1
a255 1
		goto out;
a256 1
#endif
d258 1
a258 1
	retbuf = malloc(tocopy, M_TEMP, M_NOWAIT);
d261 2
a262 2
		*left = log_size;
		goto out;
d265 1
a265 11
	nb = 0;
	for (;;) {
		int rec_size;

		if (wdc_log_buf[tail] == 0)
			rec_size = 1;
		else
			rec_size = (wdc_log_buf[tail + 1] & 0x1f) + 2;

		if ((nb + rec_size) >= tocopy)
			break;
d267 9
a275 3
		memcpy(&retbuf[nb], &wdc_log_buf[tail], rec_size);
		tail = (tail + rec_size) % wdc_log_cap;
		nb += rec_size;
d278 2
a279 3
	wdc_tail = tail;
	*size = nb;
	*left = log_size - nb;
a280 2
 out:
	splx(s);
@


1.14
log
@

New interface to ATA registers that goes through the lower-level device
driver (pciide, wdc, etc.)

Remove #define WDCDEBUG from top of files

More fixes to ATAPISCSI logic:

Not all devices transition correctly between phases. Devices are supposed
to keep BSY high until they've set the registers to the next sensible
state. Some devices drop BSY and leave the registers in an old or
nonsense state. Our polling code is extremely sensitive to this
(though an early itnerrupt could also observe this). So, if the device is
in an unexpected state, the new polling code waits for a while in the hope
that it enters a better state.

This seems to fix many of the problems reported.

Also, there was a horrible bug which would cause sense to fail on a ATAPI
command that sent data to the drive
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.13 1999/10/29 16:40:22 csapuntz Exp $     */
d915 1
a915 1
		__wdcerror(chp, "lost interrupt");
@


1.13
log
@

Change wdc_input_bytes and wdc_output_bytes to use
bus_space_{read,write}_raw_* instead of the byte-swapping API. For
PowerPC and other big-endian architectures.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.12 1999/10/29 01:15:15 deraadt Exp $     */
a74 4
#ifndef WDCDEBUG
#define WDCDEBUG
#endif /* WDCDEBUG */

a89 7
#ifndef __BUS_SPACE_HAS_STREAM_METHODS
#define bus_space_write_multi_stream_2	bus_space_write_multi_2
#define bus_space_write_multi_stream_4	bus_space_write_multi_4
#define bus_space_read_multi_stream_2	bus_space_read_multi_2
#define bus_space_read_multi_stream_4	bus_space_read_multi_4
#endif /* __BUS_SPACE_HAS_STREAM_METHODS */

d130 149
d308 1
a308 2
	bus_space_write_1(chp->ctl_iot, chp->ctl_ioh, wd_aux_ctlr,
			  WDCTL_IDS);
d315 1
a315 2
	bus_space_write_1(chp->ctl_iot, chp->ctl_ioh, wd_aux_ctlr,
			  WDCTL_4BIT);
d324 1
a324 2
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM | (drive << 4));
d363 3
d372 1
a372 2
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
		    WDSD_IBM);
d374 2
a375 3
		st0 = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_status);
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
		    WDSD_IBM | 0x10);
d377 1
a377 1
		st1 = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_status);
d392 1
a392 2
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM);
d394 1
a394 2
	bus_space_write_1(chp->ctl_iot, chp->ctl_ioh, wd_aux_ctlr,
	    WDCTL_RST | WDCTL_IDS); 
d396 1
a396 2
	bus_space_write_1(chp->ctl_iot, chp->ctl_ioh, wd_aux_ctlr,
	    WDCTL_IDS);
d398 2
a399 2
	(void) bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_error);
	bus_space_write_1(chp->ctl_iot, chp->ctl_ioh, wd_aux_ctlr, WDCTL_4BIT);
d420 1
a420 2
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
		    WDSD_IBM | (drive << 4));
d423 4
a426 4
		sc = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_seccnt);
		sn = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_sector);
		cl = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_cyl_lo);
		ch = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_cyl_hi);
d468 2
d519 1
a519 2
			bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
			    WDSD_IBM | (i << 4));
d521 4
a524 8
			bus_space_write_1(chp->cmd_iot, chp->cmd_ioh,
			    wd_error, 0x58);
			bus_space_write_1(chp->cmd_iot, chp->cmd_ioh,
			    wd_cyl_lo, 0xa5);
			if (bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
			        wd_error == 0x58) ||
			    bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
				wd_cyl_lo) != 0xa5) {
d531 1
a531 2
			bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
			    WDSD_IBM | (i << 4));
d540 1
a540 2
			bus_space_write_1(chp->cmd_iot, chp->cmd_ioh,
			    wd_command, WDCC_RECAL);
d621 2
a622 2
				bus_space_write_1(chp->cmd_iot, chp->cmd_ioh,
				    wd_sdh, WDSD_IBM | (i << 4));
d675 1
a675 1
		if (!(*chp->wdc->claim_hw)(chp, 0))
d749 2
a750 4
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM); /* master */
	bus_space_write_1(chp->ctl_iot, chp->ctl_ioh, wd_aux_ctlr,
	    WDCTL_RST | WDCTL_IDS);
d752 1
a752 2
	bus_space_write_1(chp->ctl_iot, chp->ctl_ioh, wd_aux_ctlr,
	    WDCTL_IDS);
d754 2
a755 3
	(void) bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_error);
	bus_space_write_1(chp->ctl_iot, chp->ctl_ioh, wd_aux_ctlr,
	    WDCTL_4BIT);
d786 1
a786 2
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
		    WDSD_IBM); /* master */
d788 2
a789 3
		st0 = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_status);
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
		    WDSD_IBM | 0x10); /* slave */
d791 1
a791 1
		st1 = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_status);
d850 1
a850 3
		chp->ch_status = status =
		    bus_space_read_1(chp->ctl_iot, chp->ctl_ioh, 
				     wd_aux_altsts);
d852 1
a852 3
		chp->ch_status = status =
		    bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, 
				     wd_status);
d855 1
a855 2
			bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
			    WDSD_IBM | 0x10);
d858 1
a858 2
			    bus_space_read_1(chp->ctl_iot, chp->ctl_ioh,
				wd_aux_altsts);
d861 1
a861 2
			    bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
				wd_status);
d869 1
a869 2
			    bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
				wd_error)),
d877 1
a877 1
	bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_status);
d880 1
a880 2
		chp->ch_error = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
		    wd_error);
d1130 2
a1131 4
		bus_space_write_raw_multi_4(chp->data32iot,
		    chp->data32ioh, wd_data,
		    (void *)((u_int8_t *)bytes + off), 
		    roundlen);
d1140 2
a1141 4
		bus_space_write_raw_multi_2(chp->cmd_iot,
		    chp->cmd_ioh, wd_data,
		    (void *)((u_int8_t *)bytes + off), 
		    roundlen);
d1160 2
a1161 4
		bus_space_read_raw_multi_4(chp->data32iot,
		    chp->data32ioh, wd_data,
		    (void *)((u_int8_t *)bytes + off), 
		    roundlen);
d1170 2
a1171 4
		bus_space_read_raw_multi_2(chp->cmd_iot,
		    chp->cmd_ioh, wd_data,
		    (void *)((u_int8_t *)bytes + off), 
		    roundlen);
d1352 1
a1352 2
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM | (drive << 4));
d1430 9
a1438 14
		wdc_c->r_head = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
						 wd_sdh);
		wdc_c->r_cyl = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
						wd_cyl_hi) << 8;
		wdc_c->r_cyl |= bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
						 wd_cyl_lo);
		wdc_c->r_sector = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
						   wd_sector);
		wdc_c->r_count = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
						  wd_seccnt);
		wdc_c->r_error = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
						  wd_error);
		wdc_c->r_precomp = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
						    wd_precomp);
d1474 1
a1474 2
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM | (drive << 4) | head);
d1476 6
a1481 7
	/* Load parameters. wd_features(ATA/ATAPI) = wd_precomp(ST506) */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_precomp,
	    precomp);
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_cyl_lo, cylin);
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_cyl_hi, cylin >> 8);
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sector, sector);
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_seccnt, count);
d1484 1
a1484 1
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_command, command);
d1504 2
a1505 4
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM | (drive << 4));

	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_command, command);
d1625 1
a1625 5

	for (; size >= 2; size -= 2)
		(void)bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, wd_data);
	if (size)
		(void)bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_data);
@


1.12
log
@reliability fixes from csapuntz; commit message replaced later with details
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.11 1999/10/28 19:59:27 fgsch Exp $     */
d1013 1
a1013 1
	unsigned int len = buflen;
d1016 3
a1018 1
		bus_space_write_multi_4(chp->data32iot,
d1021 1
a1021 1
		    len >> 2);
d1023 2
a1024 2
		off += ((len >> 2) << 2);
		len = len & 0x03;
d1028 3
a1030 1
		bus_space_write_multi_2(chp->cmd_iot,
d1033 1
a1033 1
		    (len + 1) >> 1);
d1047 1
a1047 1
	unsigned int len = buflen;
d1050 3
a1052 1
		bus_space_read_multi_4(chp->data32iot,
d1055 4
a1058 3
		    len >> 2);
		off += ((len >> 2) << 2);
		len = len & 0x03;
d1062 3
a1064 1
		bus_space_read_multi_2(chp->cmd_iot,
d1067 1
a1067 1
		    (len + 1) >> 1);
@


1.11
log
@Downgrade to mode 2 first if we were udma > 2; from NetBSD. costa@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.10 1999/10/09 03:42:04 csapuntz Exp $     */
d131 1
a187 3
	if (wait_for_unbusy (chp, howlong))
		return -1;

d193 8
a200 1
	if (wdcwait(chp, WDCS_DRQ, 0, howlong))
d202 1
d533 1
a533 1
	if ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL)
d535 1
d1006 59
d1236 2
a1237 1
	 * Make sure the bus isn't busy
d1239 12
a1250 5
	if (wdc_select_drive(chp, drive, wdc_c->timeout) != 0) {
		wdc_c->flags |= AT_TIMEOU;
		__wdccommand_done(chp, xfer);
		return;
	}
d1273 1
d1290 1
a1290 9
		if (chp->ch_drive[xfer->drive].drive_flags & DRIVE_CAP32) {
			bus_space_read_multi_4(chp->data32iot, chp->data32ioh,
			    0, (u_int32_t*)data, bcount >> 2);
			data += bcount & 0xfffffffc;
			bcount = bcount & 0x03;
		}
		if (bcount > 0)
			bus_space_read_multi_2(chp->cmd_iot, chp->cmd_ioh,
			    wd_data, (u_int16_t *)data, bcount >> 1);
d1292 1
a1292 9
		if (chp->ch_drive[xfer->drive].drive_flags & DRIVE_CAP32) {
			bus_space_write_multi_4(chp->data32iot, chp->data32ioh,
			    0, (u_int32_t*)data, bcount >> 2);
			data += bcount & 0xfffffffc;
			bcount = bcount & 0x03;
		}
		if (bcount > 0)
			bus_space_write_multi_2(chp->cmd_iot, chp->cmd_ioh,
			    wd_data, (u_int16_t *)data, bcount >> 1);
@


1.10
log
@

wdc layer work:
Separate wdc_probe_caps into wdc_probe_caps and wdc_print_caps for more
flexibility in printing capability information.

Get rid of wdc_final_attach.

Include name of device (e.g. cd0), if possible, on errors.

atapiscsi layer work:
Put a pointer to the SCSI device into ata_drive_datas' drv_softc field

Simplify, simplify, simplify. Got rid of a bunch of fields in atapiscsi_softc

Delay printing capabilities until we know the real device name (e.g. st0)
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.9 1999/09/05 21:43:30 niklas Exp $     */
d1046 10
@


1.9
log
@style
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.8 1999/08/05 00:12:09 niklas Exp $     */
d130 2
d295 3
a297 2
		 * sc is supposted to be 0x1 for ATAPI but at last one drive
		 * set it to 0x0 - or maybe it's the controller.
d299 1
a299 2
		if ((sc == 0x00 || sc == 0x01) && sn == 0x01 &&
		    cl == 0x14 && ch == 0xeb) {
d357 3
d462 1
a462 2
		if (config_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint))
			wdc_probe_caps(&chp->ch_drive[i]);
a501 9
void
wdc_final_attach(chp)
	struct channel_softc *chp;
{
#if NATAPISCSI > 0
	wdc_atapibus_final_attach(chp);
#endif
}

d721 5
d727 16
a742 1
		    bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_status);
d750 1
a750 1
			    DEBUG_STATUS);
d755 5
a759 1
	if (status & WDCS_ERR)
d762 4
d820 1
a820 1
wdc_probe_caps(drvp)
d822 1
a823 1
	struct ataparams params, params2;
a827 1
	char *sep = "";
a829 5
	if (ata_get_params(drvp, AT_POLL, &params) != CMD_OK) {
		/* IDENTIFY failed. Can't tell more about the device */
		return;
	}
	printf("%s: ", drv_dev->dv_xname);
d832 2
d841 1
a841 1
		if (bcmp(&params, &params2, sizeof(struct ataparams)) != 0) {
d844 1
a844 4
			printf("16-bit");
		} else
			printf("32-bit");
		sep = ", ";
d847 2
a848 2
	if (params.atap_ata_major > 0x01 && 
	    params.atap_ata_major != 0xffff) {
d850 1
a850 1
			if (params.atap_ata_major & (1 << i)) {
d866 2
a867 2
	if (params.atap_extensions != 0xffff &&
	    (params.atap_extensions & WDC_EXT_MODES)) {
d876 1
a876 1
			if ((params.atap_piomode_supp & (1 << i)) == 0)
a878 1
				printf("\n");
a892 2
				printf("%ssupports PIO mode %d", sep, i + 3);
				sep = ", ";
a910 1
			printf("\n");
d916 1
a916 1
			if ((params.atap_dmamode_supp & (1 << i)) == 0)
a923 2
				printf("%sDMA mode %d", sep, i);
				sep = ", ";
d936 1
a936 1
		if (params.atap_extensions & WDC_EXT_UDMA_MODES) {
d938 1
a938 1
				if ((params.atap_udmamode_supp & (1 << i))
a945 2
				printf("%sUltra-DMA mode %d", sep, i);
				sep = ", ";
a957 1
	printf("\n");
d998 26
d1431 12
a1442 3
	else
		printf("%s:%d:%d: %s\n", chp->wdc->sc_dev.dv_xname,
		    chp->channel, xfer->drive, msg);
@


1.8
log
@Make IDE compile on alpha again:
use b* instead of mem* functions, adhere to NISADMA for DMA support.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.7 1999/07/23 08:34:15 deraadt Exp $     */
d185 1
a185 2
	
	if (wait_for_unbusy(chp, howlong)) {
a186 1
	}
d193 1
a193 1
	if (wdcwait(chp, WDCS_DRQ, 0, howlong)) {
a194 1
	}
d539 1
a539 1
		return; /* channel aleady active */
@


1.7
log
@doesn't end does it...
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.6 1999/07/23 08:04:27 deraadt Exp $     */
d439 1
a439 1
		memset(&aa_link, 0, sizeof(struct ata_atapi_attach));
d455 1
a455 1
		memset(&aa_link, 0, sizeof(struct ata_atapi_attach));
d825 1
a825 1
		if (memcmp(&params, &params2, sizeof(struct ataparams)) != 0) {
d1369 1
a1369 1
	memset(xfer, 0, sizeof(struct wdc_xfer));
@


1.6
log
@more slight dmesg formatting for some a really stupid drive
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.5 1999/07/22 22:42:47 deraadt Exp $     */
d828 4
a831 4
		} else {
			printf("32-bit", drv_dev->dv_xname);
			sep = ", ";
		}
d1040 1
a1040 1
	/* reset the channel, which will shedule all drives for setup */
@


1.5
log
@shorten dmesg output
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.4 1999/07/22 04:36:33 deraadt Exp $     */
d865 2
a866 1
			if (i > 4)
d868 2
d901 1
@


1.4
log
@shorten dmesg output
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.3 1999/07/22 02:54:06 csapuntz Exp $     */
d815 1
d829 2
a830 1
			printf("%s: 32-bit data port", drv_dev->dv_xname);
d838 1
a838 5
				if ((drvp->drive_flags & DRIVE_CAP32) == 0)
					printf("%s: ", drv_dev->dv_xname);
				else
					printf(", ");
				printf("ATA version %d\n", i);
a844 3
	if (drvp->drive_flags & DRIVE_CAP32)
		printf("\n");

d878 2
a879 3
				printf("%s: supports PIO mode %d",
				    drv_dev->dv_xname, i + 3);
				sep = ",";
d911 2
a912 2
				printf("%s DMA mode %d", sep, i);
				sep = ",";
d935 2
a936 2
				printf("%s Ultra-DMA mode %d", sep, i);
				sep = ",";
a947 1
		printf("\n");
d949 1
@


1.3
log
@

Create wdc_enable_intr, wdc_disable_intr, wdc_select_drive.

wdc_select_drive implements the drive selection protocol
as documented in the ATA-5 preliminary specs.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.2 1999/07/18 22:44:48 csapuntz Exp $     */
d828 1
a828 1
			printf("%s: 32-bits data port", drv_dev->dv_xname);
d883 1
a883 1
				printf("%s: drive supports PIO mode %d",
@


1.2
log
@

NATAPIBUS -> NATAPISCSI
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.1 1999/07/18 21:25:16 csapuntz Exp $     */
d163 40
d630 1
a630 1
	delay(1000);
d647 1
d658 4
d717 1
d731 1
a731 1
		if ((status & WDCS_BSY) == 0 && (status & mask) == bits)
d1123 12
a1134 4
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM | (drive << 4));
	if (wdcwait(chp, wdc_c->r_st_bmask, wdc_c->r_st_bmask,
	    wdc_c->timeout) != 0) {
d1139 1
d1236 3
d1272 1
@


1.1
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 1
/*      $OpenBSD: $     */
d106 1
a106 1
#include "atapibus.h"
d391 1
a391 1
#if NATAPIBUS > 0
d465 1
a465 1
#if NATAPIBUS > 0
@

