head	1.36;
access;
symbols
	OPENBSD_6_0:1.35.0.10
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.4
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.33.0.18
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.16
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.12
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.10
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.8
	OPENBSD_5_0:1.33.0.4
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.25.0.18
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.14
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.12
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.10
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.8
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.6
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.8
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.6
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.20
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.36
date	2017.02.01.16.46.57;	author bluhm;	state Exp;
branches;
next	1.35;
commitid	h07Hqri5qtvDm9xu;

1.35
date	2014.10.31.09.45.27;	author jsg;	state Exp;
branches;
next	1.34;
commitid	Ti5jq0WzBjJqS8jH;

1.34
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.33;
commitid	uzzBR7hz9ncd4O6G;

1.33
date	2010.11.18.21.15.15;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.28.14.13.32;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.31.06.40.17;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.21.18.16.39;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.03.16.44.51;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.15.20.32.17;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.05.16.14.47;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.05.22.41.35;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.15.21.30.25;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.14.15.00.02;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.09.00.05.21;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.30.20.45.34;	author nordin;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.20.04.41.39;	author smart;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.08.19.19.58.56;	author smart;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.23.10.55.46;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.25.11.54.00;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.03.06.33.37;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.10.11.12.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.11.30.23.54.07;	author aaron;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	97.08.04.09.57.19;	author dgregor;	state Exp;
branches;
next	1.7;

1.7
date	96.12.03.11.08.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.03.05.28.21;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.11.28.23.27.48;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.11.12.20.30.17;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.16.12.38.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.23.20.20.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.07.27.07.20.03;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2001.05.14.22.23.39;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.07.04.10.40.47;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	;

1.15.4.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	1.15.4.4;

1.15.4.4
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Fix format strings in cy(4), allows to compile with CY_DEBUG.
From Jan Klemkow
@
text
@/*	$OpenBSD: cy.c,v 1.35 2014/10/31 09:45:27 jsg Exp $	*/
/*
 * Copyright (c) 1996 Timo Rossi.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * cy.c
 *
 * Driver for Cyclades Cyclom-8/16/32 multiport serial cards
 * (currently not tested with Cyclom-32 cards)
 *
 * Timo Rossi, 1996
 *
 * Supports both ISA and PCI Cyclom cards
 *
 * Uses CD1400 automatic CTS flow control, and
 * if CY_HW_RTS is defined, uses CD1400 automatic input flow control.
 * This requires a special cable that exchanges the RTS and DTR lines.
 *
 * Lots of debug output can be enabled by defining CY_DEBUG
 * Some debugging counters (number of receive/transmit interrupts etc.)
 * can be enabled by defining CY_DEBUG1
 *
 * This version uses the bus_space/io_??() stuff
 *
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/fcntl.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/selinfo.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/ic/cd1400reg.h>
#include <dev/ic/cyreg.h>


int	cy_intr(void *);
int	cyparam(struct tty *, struct termios *);
void	cystart(struct tty *);
void	cy_poll(void *);
int	cy_modem_control(struct cy_port *, int, int);
void	cy_enable_transmitter(struct cy_port *);
void	cd1400_channel_cmd(struct cy_port *, int);
int	cy_speed(speed_t, int *, int *, int);

struct cfdriver cy_cd = {
	NULL, "cy", DV_TTY
};

/*
 * Common probe routine
 *
 * returns the number of chips found.
 */
int
cy_probe_common(bus_space_tag_t memt, bus_space_handle_t memh, int bustype)
{
	int cy_chip, chip_offs;
	u_char firmware_ver;
	int nchips;

	/* Cyclom card hardware reset */
	bus_space_write_1(memt, memh, CY16_RESET<<bustype, 0);
	DELAY(500); /* wait for reset to complete */
	bus_space_write_1(memt, memh, CY_CLEAR_INTR<<bustype, 0);

#ifdef CY_DEBUG
	printf("cy: card reset done\n");
#endif

	nchips = 0;

	for (cy_chip = 0, chip_offs = 0;
	    cy_chip < CY_MAX_CD1400s;
	    cy_chip++, chip_offs += (CY_CD1400_MEMSPACING << bustype)) {
		int i;

		/* the last 4 cd1400s are 'interleaved'
		   with the first 4 on 32-port boards */
		if (cy_chip == 4)
			chip_offs -= (CY32_ADDR_FIX << bustype);

#ifdef CY_DEBUG
		printf("cy: probe chip %d offset 0x%x ... ",
		    cy_chip, chip_offs);
#endif

		/* wait until the chip is ready for command */
		DELAY(1000);
		if (bus_space_read_1(memt, memh, chip_offs +
		    ((CD1400_CCR << 1) << bustype)) != 0) {
#ifdef CY_DEBUG
			printf("not ready for command\n");
#endif
			break;
		}

		/* clear the firmware version reg. */
		bus_space_write_1(memt, memh, chip_offs +
		    ((CD1400_GFRCR << 1) << bustype), 0);

		/*
		 * On Cyclom-16 references to non-existent chip 4
		 * actually access chip 0 (address line 9 not decoded).
		 * Here we check if the clearing of chip 4 GFRCR actually
		 * cleared chip 0 GFRCR. In that case we have a 16 port card.
		 */
		if (cy_chip == 4 &&
		    bus_space_read_1(memt, memh, chip_offs +
			((CD1400_GFRCR << 1) << bustype)) == 0)
			break;

		/* reset the chip */
		bus_space_write_1(memt, memh, chip_offs +
		    ((CD1400_CCR << 1) << bustype),
		    CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);

		/* wait for the chip to initialize itself */
		for (i = 0; i < 200; i++) {
			DELAY(50);
			firmware_ver = bus_space_read_1(memt, memh, chip_offs +
			    ((CD1400_GFRCR << 1) << bustype));
			if ((firmware_ver & 0xf0) == 0x40) /* found a CD1400 */
				break;
		}
#ifdef CY_DEBUG
		printf("firmware version 0x%x\n", firmware_ver);
#endif      

		if ((firmware_ver & 0xf0) != 0x40)
			break;

		/* firmware version OK, CD1400 found */
		nchips++;
	}

	if (nchips == 0) {
#ifdef CY_DEBUG
		printf("no CD1400s found\n");
#endif
		return (0);
	}

#ifdef CY_DEBUG
	printf("found %d CD1400s\n", nchips);
#endif

	return (nchips);
}

void
cy_attach(parent, self)
	struct device *parent, *self;
{
	int card, port, cy_chip, num_chips, cdu, chip_offs, cy_clock;
	struct cy_softc *sc = (void *)self;

	card = sc->sc_dev.dv_unit;
	num_chips = sc->sc_nr_cd1400s;
	if (num_chips == 0)
		return;

	timeout_set(&sc->sc_poll_to, cy_poll, sc);
	bzero(sc->sc_ports, sizeof(sc->sc_ports));
	sc->sc_nports = num_chips * CD1400_NO_OF_CHANNELS;

	port = 0;
	for (cy_chip = 0, chip_offs = 0;
	    cy_chip < num_chips;
	    cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<sc->sc_bustype)) {
		if (cy_chip == 4)
			chip_offs -= (CY32_ADDR_FIX<<sc->sc_bustype);

#ifdef CY_DEBUG
		printf("attach CD1400 #%d offset 0x%x\n", cy_chip, chip_offs);
#endif
		sc->sc_cd1400_offs[cy_chip] = chip_offs;

		/* configure port 0 as serial port
		   (should already be after reset) */
		cd_write_reg_sc(sc, cy_chip, CD1400_GCR, 0);

		/* Set cy_clock depending on firmware version */
		if (cd_read_reg_sc(sc, cy_chip, CD1400_GFRCR) <= 0x46)
			cy_clock = CY_CLOCK;
		else 
			cy_clock = CY_CLOCK_60;

		/* set up a receive timeout period (1ms) */
		cd_write_reg_sc(sc, cy_chip, CD1400_PPR,
		    (cy_clock / CD1400_PPR_PRESCALER / 1000) + 1);

		for (cdu = 0; cdu < CD1400_NO_OF_CHANNELS; cdu++) {
			sc->sc_ports[port].cy_port_num = port;
			sc->sc_ports[port].cy_memt = sc->sc_memt;
			sc->sc_ports[port].cy_memh = sc->sc_memh;
			sc->sc_ports[port].cy_chip_offs = chip_offs;
			sc->sc_ports[port].cy_bustype = sc->sc_bustype;
			sc->sc_ports[port].cy_clock = cy_clock;

			/* should we initialize anything else here? */
			port++;
		} /* for(each port on one CD1400...) */

	} /* for(each CD1400 on a card... ) */

	printf(": %d ports\n", port);

	/* ensure an edge for the next interrupt */
	bus_space_write_1(sc->sc_memt, sc->sc_memh,
	    CY_CLEAR_INTR<<sc->sc_bustype, 0);
}

/*
 * open routine. returns zero if successful, else error code
 */
int cyopen(dev_t, int, int, struct proc *);
int cyclose(dev_t, int, int, struct proc *);
int cyread(dev_t, struct uio *, int);
int cywrite(dev_t, struct uio *, int);
struct tty *cytty(dev_t);
int cyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int cystop(struct tty *, int flag);

int
cyopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc;
	struct cy_port *cy;
	struct tty *tp;
	int s, error;

	if (card >= cy_cd.cd_ndevs ||
	    (sc = cy_cd.cd_devs[card]) == NULL) {
		return (ENXIO);
	}

#ifdef CY_DEBUG
	printf("%s open port %d flag 0x%x mode 0x%x\n", sc->sc_dev.dv_xname,
	    port, flag, mode);
#endif

	cy = &sc->sc_ports[port];

	s = spltty();
	if (cy->cy_tty == NULL) {
		cy->cy_tty = ttymalloc(0);
	}
	splx(s);

	tp = cy->cy_tty;
	tp->t_oproc = cystart;
	tp->t_param = cyparam;
	tp->t_dev = dev;

	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_WOPEN);
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		if (ISSET(cy->cy_openflags, TIOCFLAG_CLOCAL))
			SET(tp->t_cflag, CLOCAL);
		if (ISSET(cy->cy_openflags, TIOCFLAG_CRTSCTS))
			SET(tp->t_cflag, CRTSCTS);
		if (ISSET(cy->cy_openflags, TIOCFLAG_MDMBUF))
			SET(tp->t_cflag, MDMBUF);
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;

		s = spltty();

		/*
		 * Allocate input ring buffer if we don't already have one
		 */
		if (cy->cy_ibuf == NULL) {
			cy->cy_ibuf = malloc(IBUF_SIZE, M_DEVBUF, M_NOWAIT);
			if (cy->cy_ibuf == NULL) {
				printf("%s: (port %d) can't allocate input buffer\n",
				       sc->sc_dev.dv_xname, port);
				splx(s);
				return (ENOMEM);
			}
			cy->cy_ibuf_end = cy->cy_ibuf + IBUF_SIZE;
		}

		/* mark the ring buffer as empty */
		cy->cy_ibuf_rd_ptr = cy->cy_ibuf_wr_ptr = cy->cy_ibuf;

		/* select CD1400 channel */
		cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN);
		/* reset the channel */
		cd1400_channel_cmd(cy, CD1400_CCR_CMDRESET);
		/* encode unit (port) number in LIVR */
		/* there is just enough space for 5 bits (32 ports) */
		cd_write_reg(cy, CD1400_LIVR, port << 3);

		cy->cy_channel_control = 0;

		if (!timeout_pending(&sc->sc_poll_to))
			timeout_add(&sc->sc_poll_to, 1);

		/* this sets parameters and raises DTR */
		cyparam(tp, &tp->t_termios);

		ttsetwater(tp);

		/* raise RTS too */
		cy_modem_control(cy, TIOCM_RTS, DMBIS);

		cy->cy_carrier_stat = cd_read_reg(cy, CD1400_MSVR2);

		/* enable receiver and modem change interrupts */
		cd_write_reg(cy, CD1400_SRER,
		    CD1400_SRER_MDMCH | CD1400_SRER_RXDATA);

		if (CY_DIALOUT(dev) ||
		    ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR) ||
		    ISSET(tp->t_cflag, MDMBUF) ||
		    ISSET(cy->cy_carrier_stat, CD1400_MSVR2_CD))
			SET(tp->t_state, TS_CARR_ON);
		else
			CLR(tp->t_state, TS_CARR_ON);
	} else if (ISSET(tp->t_state, TS_XCLUDE) && suser(p, 0) != 0) {
		return (EBUSY);
	} else {
		s = spltty();
	}

	/* wait for carrier if necessary */
	if (!ISSET(flag, O_NONBLOCK)) {
		while (!ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON)) {
			SET(tp->t_state, TS_WOPEN);
			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
			    "cydcd", 0);
			if (error != 0) {
				splx(s);
				CLR(tp->t_state, TS_WOPEN);
				return (error);
			}
		}
	}

	splx(s);

	return (*linesw[tp->t_line].l_open)(dev, tp, p);
}

/*
 * close routine. returns zero if successful, else error code
 */
int
cyclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;
	int s;

#ifdef CY_DEBUG
	printf("%s close port %d, flag 0x%x, mode 0x%x\n", sc->sc_dev.dv_xname,
	    port, flag, mode);
#endif

	(*linesw[tp->t_line].l_close)(tp, flag, p);
	s = spltty();

	if (ISSET(tp->t_cflag, HUPCL) &&
	    !ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR)) {
		/* drop DTR and RTS
		   (should we wait for output buffer to become empty first?) */
		cy_modem_control(cy, 0, DMSET);
	}

	/*
	 * XXX should we disable modem change and
	 * receive interrupts here or somewhere ?
	 */
	CLR(tp->t_state, TS_BUSY | TS_FLUSH);

	splx(s);
	ttyclose(tp);

	return (0);
}

/*
 * Read routine
 */
int
cyread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;

#ifdef CY_DEBUG
	printf("%s read port %d uio %p flag 0x%x\n", sc->sc_dev.dv_xname,
	    port, uio, flag);
#endif

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

/*
 * Write routine
 */
int
cywrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;

#ifdef CY_DEBUG
	printf("%s write port %d uio %p flag 0x%x\n", sc->sc_dev.dv_xname,
	    port, uio, flag);
#endif

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

/*
 * return tty pointer
 */
struct tty *
cytty(dev)
	dev_t dev;
{
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;

	return (tp);
}

/*
 * ioctl routine
 */
int
cyioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;
	int error;

#ifdef CY_DEBUG
	printf("%s port %d ioctl cmd 0x%lx data %p flag 0x%x\n",
	    sc->sc_dev.dv_xname, port, cmd, data, flag);
#endif

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	/* XXX should not allow dropping DTR when dialin? */

	switch (cmd) {
	case TIOCSBRK:		/* start break */
		SET(cy->cy_flags, CYF_START_BREAK);
		cy_enable_transmitter(cy);
		break;

	case TIOCCBRK:		/* stop break */
		SET(cy->cy_flags, CYF_END_BREAK);
		cy_enable_transmitter(cy);
		break;

	case TIOCSDTR:		/* DTR on */
		cy_modem_control(cy, TIOCM_DTR, DMBIS);
		break;

	case TIOCCDTR:		/* DTR off */
		cy_modem_control(cy, TIOCM_DTR, DMBIC);
		break;

	case TIOCMSET:		/* set new modem control line values */
		cy_modem_control(cy, *((int *)data), DMSET);
		break;

	case TIOCMBIS:		/* turn modem control bits on */
		cy_modem_control(cy, *((int *)data), DMBIS);
		break;

	case TIOCMBIC:		/* turn modem control bits off */
		cy_modem_control(cy, *((int *)data), DMBIC);
		break;

	case TIOCMGET:		/* get modem control/status line state */
		*((int *)data) = cy_modem_control(cy, 0, DMGET);
		break;

	case TIOCGFLAGS:
		*((int *)data) = cy->cy_openflags |
		    (CY_DIALOUT(dev) ? TIOCFLAG_SOFTCAR : 0);
		break;

	case TIOCSFLAGS:
		error = suser(p, 0);
		if (error != 0)
			return (EPERM);

		cy->cy_openflags = *((int *)data) &
		    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL |
		     TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF);
		break;

	default:
		return (ENOTTY);
	}

	return (0);
}

/*
 * start output
 */
void
cystart(tp)
	struct tty *tp;
{
	int card = CY_CARD(tp->t_dev);
	int port = CY_PORT(tp->t_dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	int s;

#ifdef CY_DEBUG
	printf("%s port %d start, tty %p\n", sc->sc_dev.dv_xname, port, tp);
#endif

	s = spltty();

#ifdef CY_DEBUG1
	cy->cy_start_count++;
#endif

	if (!ISSET(tp->t_state, TS_TTSTOP | TS_TIMEOUT | TS_BUSY)) {
		ttwakeupwr(tp);
		if (tp->t_outq.c_cc == 0)
			goto out;

		SET(tp->t_state, TS_BUSY);
		cy_enable_transmitter(cy);
	}
out:

	splx(s);
}

/*
 * stop output
 */
int
cystop(tp, flag)
	struct tty *tp;
	int flag;
{
	int card = CY_CARD(tp->t_dev);
	int port = CY_PORT(tp->t_dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	int s;

#ifdef CY_DEBUG
	printf("%s port %d stop tty %p flag 0x%x\n", sc->sc_dev.dv_xname,
	    port, tp, flag);
#endif

	s = spltty();

	if (ISSET(tp->t_state, TS_BUSY)) {
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);

		/*
		 * the transmit interrupt routine will disable transmit when it
		 * notices that CYF_STOP has been set.
		 */
		SET(cy->cy_flags, CYF_STOP);
	}
	splx(s);
	return (0);
}

/*
 * parameter setting routine.
 * returns 0 if successful, else returns error code
 */
int
cyparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	int card = CY_CARD(tp->t_dev);
	int port = CY_PORT(tp->t_dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	int ibpr, obpr, i_clk_opt, o_clk_opt;
	int s, opt;

#ifdef CY_DEBUG
	printf("%s port %d param tty %p termios %p\n", sc->sc_dev.dv_xname,
	    port, tp, t);
	printf("ispeed %d ospeed %d\n", t->c_ispeed, t->c_ospeed);
#endif

	if (t->c_ospeed != 0 &&
	    cy_speed(t->c_ospeed, &o_clk_opt, &obpr, cy->cy_clock) < 0)
		return (EINVAL);

	if (t->c_ispeed != 0 &&
	    cy_speed(t->c_ispeed, &i_clk_opt, &ibpr, cy->cy_clock) < 0)
		return (EINVAL);

	s = spltty();

	/* hang up the line is ospeed is zero, else turn DTR on */
	cy_modem_control(cy, TIOCM_DTR, (t->c_ospeed == 0 ? DMBIC : DMBIS));

	/* channel was selected by the above call to cy_modem_control() */
	/* cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN); */

	/* set transmit speed */
	if (t->c_ospeed != 0) {
		cd_write_reg(cy, CD1400_TCOR, o_clk_opt);
		cd_write_reg(cy, CD1400_TBPR, obpr);
	}
	/* set receive speed */
	if (t->c_ispeed != 0) {
		cd_write_reg(cy, CD1400_RCOR, i_clk_opt);
		cd_write_reg(cy, CD1400_RBPR, ibpr);
	}

	opt = CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN
	    | (ISSET(t->c_cflag, CREAD) ? CD1400_CCR_RCVEN : CD1400_CCR_RCVDIS);

	if (opt != cy->cy_channel_control) {
		cy->cy_channel_control = opt;
		cd1400_channel_cmd(cy, opt);
	}

	/* compute COR1 contents */
	opt = 0;
	if (ISSET(t->c_cflag, PARENB)) {
		if (ISSET(t->c_cflag, PARODD))
			opt |= CD1400_COR1_PARODD;
		opt |= CD1400_COR1_PARNORMAL;
	}

	if (!ISSET(t->c_iflag, INPCK))
		opt |= CD1400_COR1_NOINPCK;	/* no parity checking */

	if (ISSET(t->c_cflag, CSTOPB))
		opt |= CD1400_COR1_STOP2;

	switch (t->c_cflag & CSIZE) {
	case CS5:
		opt |= CD1400_COR1_CS5;
		break;

	case CS6:
		opt |= CD1400_COR1_CS6;
		break;

	case CS7:
		opt |= CD1400_COR1_CS7;
		break;

	default:
		opt |= CD1400_COR1_CS8;
		break;
	}

	cd_write_reg(cy, CD1400_COR1, opt);

#ifdef CY_DEBUG
	printf("cor1 = 0x%x...", opt);
#endif

	/*
	 * use the CD1400 automatic CTS flow control if CRTSCTS is set
	 *
	 * CD1400_COR2_ETC is used because breaks are generated with
	 * embedded transmit commands
	 */
	cd_write_reg(cy, CD1400_COR2,
	    CD1400_COR2_ETC |
	    (ISSET(t->c_cflag, CRTSCTS) ? CD1400_COR2_CCTS_OFLOW : 0));

	cd_write_reg(cy, CD1400_COR3, RX_FIFO_THRESHOLD);

	cd1400_channel_cmd(cy,
	    CD1400_CCR_CMDCORCHG |
	    CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3);

	cd_write_reg(cy, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);
	cd_write_reg(cy, CD1400_COR5, 0);

	/*
	 * set modem change option registers to generate interrupts
	 * on carrier detect changes.
	 *
	 * if hardware RTS handshaking is used (CY_HW_RTS, DTR and RTS lines
	 * exchanged), also set the handshaking threshold.
	 */
#ifdef CY_HW_RTS
	cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd |
	    (ISSET(t->c_cflag, CRTSCTS) ? RX_DTR_THRESHOLD : 0));
#else
	cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd);
#endif /* CY_HW_RTS */

	cd_write_reg(cy, CD1400_MCOR2, CD1400_MCOR2_CDod);

	/*
	 * set receive timeout to approx. 2ms
	 * could use more complex logic here...
	 * (but is it actually needed or even useful?)
	 */
	cd_write_reg(cy, CD1400_RTPR, 2);

	/*
	 * should do anything else here?
	 * XXX check MDMBUF handshaking like in com.c?
	 */

	splx(s);
	return (0);
}

/*
 * set/get modem line status
 *
 * bits can be: TIOCM_DTR, TIOCM_RTS, TIOCM_CTS, TIOCM_CD, TIOCM_RI, TIOCM_DSR
 *
 * RTS and DTR are exchanged if CY_HW_RTS is set
 *
 */
int
cy_modem_control(cy, bits, howto)
	struct cy_port *cy;
	int bits;
	int howto;
{
	int s, msvr;

	s = spltty();

	/* select channel */
	cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);

/* does not manipulate RTS if it is used for flow control */
	switch (howto) {
	case DMGET:
		bits = 0;
		if (cy->cy_channel_control & CD1400_CCR_RCVEN)
			bits |= TIOCM_LE;
		msvr = cd_read_reg(cy, CD1400_MSVR2);
#ifdef CY_HW_RTS
		if (cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)
			bits |= TIOCM_DTR;
		if (msvr & CD1400_MSVR2_DTR)
			bits |= TIOCM_RTS;
#else
		if (cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)
			bits |= TIOCM_RTS;
		if (msvr & CD1400_MSVR2_DTR)
			bits |= TIOCM_DTR;
#endif /* CY_HW_RTS */
		if (msvr & CD1400_MSVR2_CTS)
			bits |= TIOCM_CTS;
		if (msvr & CD1400_MSVR2_CD)
			bits |= TIOCM_CD;
		if (msvr & CD1400_MSVR2_DSR)	/* not connected on some
						   Cyclom cards? */
			bits |= TIOCM_DSR;
		if (msvr & CD1400_MSVR2_RI)	/* not connected on
						   Cyclom-8Y cards? */
			bits |= TIOCM_RI;
		splx(s);
		return (bits);

	case DMSET: /* replace old values with new ones */
#ifdef CY_HW_RTS
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS))
			cd_write_reg(cy, CD1400_MSVR2,
			    ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));
		cd_write_reg(cy, CD1400_MSVR1,
		    ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));
#else
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS))
			cd_write_reg(cy, CD1400_MSVR1,
			    ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));
		cd_write_reg(cy, CD1400_MSVR2,
		    ((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));
#endif /* CY_HW_RTS */
		break;

	case DMBIS: /* set bits */
#ifdef CY_HW_RTS
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
		    (bits & TIOCM_RTS) != 0)
			cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);
		if (bits & TIOCM_DTR)
			cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);
#else
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
		    (bits & TIOCM_RTS) != 0)
			cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);
		if (bits & TIOCM_DTR)
			cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);
#endif /* CY_HW_RTS */
		break;

	case DMBIC: /* clear bits */
#ifdef CY_HW_RTS
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
		    (bits & TIOCM_RTS))
			cd_write_reg(cy, CD1400_MSVR2, 0);
		if (bits & TIOCM_DTR)
			cd_write_reg(cy, CD1400_MSVR1, 0);
#else
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
		    (bits & TIOCM_RTS))
			cd_write_reg(cy, CD1400_MSVR1, 0);
		if (bits & TIOCM_DTR)
			cd_write_reg(cy, CD1400_MSVR2, 0);
#endif /* CY_HW_RTS */
		break;
	}
	splx(s);
	return (0);
}

/*
 * Upper-level handler loop (called from timer interrupt?)
 * This routine is common for multiple cards
 */
void
cy_poll(void *arg)
{
	int port;
	struct cy_softc *sc = arg;
	struct cy_port *cy;
	struct tty *tp;
	static int counter = 0;
#ifdef CY_DEBUG1
	int did_something;
#endif

	int s;

	s = spltty();

	if (sc->sc_events == 0 && ++counter < 200) {
		splx(s);
		goto out;
	}

	sc->sc_events = 0;
	splx(s);

#ifdef CY_DEBUG1
	sc->sc_poll_count1++;
	did_something = 0;
#endif

	for (port = 0; port < sc->sc_nports; port++) {
		cy = &sc->sc_ports[port];
		if ((tp = cy->cy_tty) == NULL || cy->cy_ibuf == NULL ||
		    !ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN))
			continue;

		/*
		 * handle received data
		 */
		while (cy->cy_ibuf_rd_ptr != cy->cy_ibuf_wr_ptr) {
			u_char line_stat;
			int chr;

			line_stat = cy->cy_ibuf_rd_ptr[0];
			chr = cy->cy_ibuf_rd_ptr[1];

			if (line_stat &
			    (CD1400_RDSR_BREAK|CD1400_RDSR_FE))
				chr |= TTY_FE;
			if (line_stat & CD1400_RDSR_PE)
				chr |= TTY_PE;

			/*
			 * on an overrun error the data is treated as
			 * good just as it should be.
			 */

#ifdef CY_DEBUG
			printf("%s port %d ttyinput 0x%x\n",
			    sc->sc_dev.dv_xname, port, chr);
#endif

			(*linesw[tp->t_line].l_rint)(chr, tp);

			s = spltty(); /* really necessary? */
			if ((cy->cy_ibuf_rd_ptr += 2) ==
			    cy->cy_ibuf_end)
				cy->cy_ibuf_rd_ptr = cy->cy_ibuf;
			splx(s);

#ifdef CY_DEBUG1
			did_something = 1;
#endif
		}

#ifndef CY_HW_RTS
		/*
		 * If we don't have any received data in ibuf and
		 * CRTSCTS is on and RTS is turned off, it is time
		 * to turn RTS back on
		 */
		if (ISSET(tp->t_cflag, CRTSCTS)) {
			/* we can't use cy_modem_control() here as it
			    doesn't change RTS if RTSCTS is on */
			cd_write_reg(cy, CD1400_CAR,
			    port & CD1400_CAR_CHAN);
	      
			if ((cd_read_reg(cy,
			    CD1400_MSVR1) & CD1400_MSVR1_RTS) == 0) {
				cd_write_reg(cy, CD1400_MSVR1,
				    CD1400_MSVR1_RTS);
#ifdef CY_DEBUG1
				did_something = 1;
#endif
			}
		}
#endif /* CY_HW_RTS */

		/*
		 * handle carrier changes
		 */
		s = spltty();
		if (ISSET(cy->cy_flags, CYF_CARRIER_CHANGED)) {
			int carrier;

			CLR(cy->cy_flags, CYF_CARRIER_CHANGED);
			splx(s);

			carrier = ((cy->cy_carrier_stat &
			    CD1400_MSVR2_CD) != 0);

#ifdef CY_DEBUG
			printf("%s: cy_poll: carrier change "
			    "(port %d, carrier %d)\n",
			    sc->sc_dev.dv_xname, port, carrier);
#endif
			if (CY_DIALIN(tp->t_dev) &&
			    !(*linesw[tp->t_line].l_modem)(tp, carrier))
				cy_modem_control(cy, TIOCM_DTR, DMBIC);

#ifdef CY_DEBUG1
			did_something = 1;
#endif
		} else {
			splx(s);
		}

		s = spltty();
		if (ISSET(cy->cy_flags, CYF_START)) {
			CLR(cy->cy_flags, CYF_START);
			splx(s);

			(*linesw[tp->t_line].l_start)(tp);

#ifdef CY_DEBUG1
			did_something = 1;
#endif
		} else {
			splx(s);
		}

		/* could move this to even upper level... */
		if (cy->cy_fifo_overruns) {
			cy->cy_fifo_overruns = 0;
			/* doesn't report overrun count,
			   but shouldn't really matter */
			log(LOG_WARNING, "%s: port %d fifo overrun\n",
			    sc->sc_dev.dv_xname, port);
		}
		if (cy->cy_ibuf_overruns) {
			cy->cy_ibuf_overruns = 0;
			log(LOG_WARNING, "%s: port %d ibuf overrun\n",
			    sc->sc_dev.dv_xname, port);
		}
	} /* for(port...) */
#ifdef CY_DEBUG1
	if (did_something && counter >= 200)
		sc->sc_poll_count2++;
#endif

	counter = 0;

out:
	timeout_add(&sc->sc_poll_to, 1);
}

/*
 * hardware interrupt routine
 */
int
cy_intr(arg)
	void *arg;
{
	struct cy_softc *sc = arg;
	struct cy_port *cy;
	int cy_chip, stat;
	int int_serviced = -1;

	/*
	 * Check interrupt status of each CD1400 chip on this card
	 * (multiple cards cannot share the same interrupt)
	 */
	for (cy_chip = 0; cy_chip < sc->sc_nr_cd1400s; cy_chip++) {

		stat = cd_read_reg_sc(sc, cy_chip, CD1400_SVRR);
		if (stat == 0)
			continue;

		if (ISSET(stat, CD1400_SVRR_RXRDY)) {
			u_char save_car, save_rir, serv_type;
			u_char line_stat, recv_data, n_chars;
			u_char *buf_p;

			save_rir = cd_read_reg_sc(sc, cy_chip, CD1400_RIR);
			save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);
			/* enter rx service */
			cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_rir);

			serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_RIVR);
			cy = &sc->sc_ports[serv_type >> 3];

#ifdef CY_DEBUG1
			cy->cy_rx_int_count++;
#endif

			buf_p = cy->cy_ibuf_wr_ptr;

			if (ISSET(serv_type, CD1400_RIVR_EXCEPTION)) {
				line_stat = cd_read_reg(cy, CD1400_RDSR);
				recv_data = cd_read_reg(cy, CD1400_RDSR);

				if (cy->cy_tty == NULL ||
				    !ISSET(cy->cy_tty->t_state, TS_ISOPEN))
					goto end_rx_serv;

#ifdef CY_DEBUG
				printf("%s port %d recv exception, "
				    "line_stat 0x%x, char 0x%x\n",
				    sc->sc_dev.dv_xname, cy->cy_port_num,
				    line_stat, recv_data);
#endif
				if (ISSET(line_stat, CD1400_RDSR_OE))
					cy->cy_fifo_overruns++;

				*buf_p++ = line_stat;
				*buf_p++ = recv_data;
				if (buf_p == cy->cy_ibuf_end)
					buf_p = cy->cy_ibuf;

				if (buf_p == cy->cy_ibuf_rd_ptr) {
					if (buf_p == cy->cy_ibuf)
						buf_p = cy->cy_ibuf_end;
					buf_p -= 2;
					cy->cy_ibuf_overruns++;
				}
				sc->sc_events = 1;
			} else { /* no exception, received data OK */
				n_chars = cd_read_reg(cy, CD1400_RDCR);

				/* If no tty or not open, discard data */
				if (cy->cy_tty == NULL ||
				    !ISSET(cy->cy_tty->t_state, TS_ISOPEN)) {
					while (n_chars--)
						cd_read_reg(cy, CD1400_RDSR);
					goto end_rx_serv;
				}

#ifdef CY_DEBUG
				printf("%s port %d receive ok %d chars\n",
				    sc->sc_dev.dv_xname, cy->cy_port_num,
				    n_chars);
#endif
				while (n_chars--) {
					*buf_p++ = 0; /* status: OK */
					*buf_p++ = cd_read_reg(cy,
					    CD1400_RDSR); /* data byte */
					if (buf_p == cy->cy_ibuf_end)
						buf_p = cy->cy_ibuf;
					if (buf_p == cy->cy_ibuf_rd_ptr) {
						if (buf_p == cy->cy_ibuf)
							buf_p = cy->cy_ibuf_end;
						buf_p -= 2;
						cy->cy_ibuf_overruns++;
						break;
					}
				}
				sc->sc_events = 1;
			}

			cy->cy_ibuf_wr_ptr = buf_p;

#ifndef CY_HW_RTS
			/* RTS handshaking for incoming data */
			if (ISSET(cy->cy_tty->t_cflag, CRTSCTS)) {
				int bf;

				bf = buf_p - cy->cy_ibuf_rd_ptr;
				if (bf < 0)
					bf += IBUF_SIZE;

				if (bf > (IBUF_SIZE/2))	/* turn RTS off */
					cd_write_reg(cy, CD1400_MSVR1, 0);
			}
#endif /* CY_HW_RTS */

		end_rx_serv:
			/* terminate service context */
			cd_write_reg(cy, CD1400_RIR, save_rir & 0x3f);
			cd_write_reg(cy, CD1400_CAR, save_car);
			int_serviced = 1;
		} /* if(rx_service...) */

		if (ISSET(stat, CD1400_SVRR_MDMCH)) {
			u_char save_car, save_mir, serv_type, modem_stat;

			save_mir = cd_read_reg_sc(sc, cy_chip, CD1400_MIR);
			save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);
			/* enter modem service */
			cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_mir);

			serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_MIVR);
			cy = &sc->sc_ports[serv_type >> 3];

#ifdef CY_DEBUG1
			cy->cy_modem_int_count++;
#endif

			modem_stat = cd_read_reg(cy, CD1400_MSVR2);

#ifdef CY_DEBUG
			printf("%s port %d modem line change, new stat 0x%x\n",
			    sc->sc_dev.dv_xname, cy->cy_port_num, modem_stat);
#endif
			if (ISSET((cy->cy_carrier_stat ^ modem_stat),
			    CD1400_MSVR2_CD)) {
				SET(cy->cy_flags, CYF_CARRIER_CHANGED);
				sc->sc_events = 1;
			}

			cy->cy_carrier_stat = modem_stat;

			/* terminate service context */
			cd_write_reg(cy, CD1400_MIR, save_mir & 0x3f);
			cd_write_reg(cy, CD1400_CAR, save_car);
			int_serviced = 1;
		} /* if(modem_service...) */

		if (ISSET(stat, CD1400_SVRR_TXRDY)) {
			u_char save_car, save_tir, serv_type, count, ch;
			struct tty *tp;

			save_tir = cd_read_reg_sc(sc, cy_chip, CD1400_TIR);
			save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);
			/* enter tx service */
			cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_tir);

			serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_TIVR);
			cy = &sc->sc_ports[serv_type >> 3];

#ifdef CY_DEBUG1
			cy->cy_tx_int_count++;
#endif
#ifdef CY_DEBUG
			printf("%s port %d tx service\n", sc->sc_dev.dv_xname,
			    cy->cy_port_num);
#endif

			/* stop transmitting if no tty or CYF_STOP set */
			tp = cy->cy_tty;
			if (tp == NULL || ISSET(cy->cy_flags, CYF_STOP))
				goto txdone;

			count = 0;
			if (ISSET(cy->cy_flags, CYF_SEND_NUL)) {
				cd_write_reg(cy, CD1400_TDR, 0);
				cd_write_reg(cy, CD1400_TDR, 0);
				count += 2;
				CLR(cy->cy_flags, CYF_SEND_NUL);
			}

			if (tp->t_outq.c_cc > 0) {
				SET(tp->t_state, TS_BUSY);
				while (tp->t_outq.c_cc > 0 &&
				    count < CD1400_TX_FIFO_SIZE) {
					ch = getc(&tp->t_outq);
					/* remember to double NUL characters
					   because embedded transmit commands
					   are enabled */
					if (ch == 0) {
						if (count >=
						    CD1400_TX_FIFO_SIZE-2) {
							SET(cy->cy_flags,
							    CYF_SEND_NUL);
							break;
						}

						cd_write_reg(cy, CD1400_TDR, ch);
						count++;
					}

					cd_write_reg(cy, CD1400_TDR, ch);
					count++;
				}
			} else {
				/* no data to send -- check if we should
				   start/stop a break */
				/* XXX does this cause too much delay before
				   breaks? */
				if (ISSET(cy->cy_flags, CYF_START_BREAK)) {
					cd_write_reg(cy, CD1400_TDR, 0);
					cd_write_reg(cy, CD1400_TDR, 0x81);
					CLR(cy->cy_flags, CYF_START_BREAK);
				}
				if (ISSET(cy->cy_flags, CYF_END_BREAK)) {
					cd_write_reg(cy, CD1400_TDR, 0);
					cd_write_reg(cy, CD1400_TDR, 0x83);
					CLR(cy->cy_flags, CYF_END_BREAK);
				}
			}

			if (tp->t_outq.c_cc == 0) {
txdone:
				/*
				 * No data to send or requested to stop.
				 * Disable transmit interrupt
				 */
				cd_write_reg(cy, CD1400_SRER,
				    cd_read_reg(cy, CD1400_SRER)
				    & ~CD1400_SRER_TXRDY);
				CLR(cy->cy_flags, CYF_STOP);
				CLR(tp->t_state, TS_BUSY);
			}

			if (tp->t_outq.c_cc <= tp->t_lowat) {
				SET(cy->cy_flags, CYF_START);
				sc->sc_events = 1;
			}

			/* terminate service context */
			cd_write_reg(cy, CD1400_TIR, save_tir & 0x3f);
			cd_write_reg(cy, CD1400_CAR, save_car);
			int_serviced = 1;
		} /* if(tx_service...) */
	} /* for(...all CD1400s on a card) */

	/* ensure an edge for next interrupt */
	bus_space_write_1(sc->sc_memt, sc->sc_memh,
	    CY_CLEAR_INTR<<sc->sc_bustype, 0);
	return (int_serviced);
}

/*
 * subroutine to enable CD1400 transmitter
 */
void
cy_enable_transmitter(cy)
	struct cy_port *cy;
{
	int s;
	s = spltty();
	cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);
	cd_write_reg(cy, CD1400_SRER, cd_read_reg(cy, CD1400_SRER)
	    | CD1400_SRER_TXRDY);
	splx(s);
}

/*
 * Execute a CD1400 channel command
 */
void
cd1400_channel_cmd(cy, cmd)
	struct cy_port *cy;
	int cmd;
{
	u_int waitcnt = 5 * 8 * 1024; /* approx 5 ms */

#ifdef CY_DEBUG
	printf("c1400_channel_cmd cy %p command 0x%x\n", cy, cmd);
#endif

	/* wait until cd1400 is ready to process a new command */
	while (cd_read_reg(cy, CD1400_CCR) != 0 && waitcnt-- > 0)
		;

	if (waitcnt == 0)
		log(LOG_ERR, "cy: channel command timeout\n");

	cd_write_reg(cy, CD1400_CCR, cmd);
}

/*
 * Compute clock option register and baud rate register values
 * for a given speed. Return 0 on success, -1 on failure.
 *
 * The error between requested and actual speed seems
 * to be well within allowed limits (less than 3%)
 * with every speed value between 50 and 150000 bps.
 */
int
cy_speed(speed_t speed, int *cor, int *bpr, int cy_clock)
{
	int c, co, br;

	if (speed < 50 || speed > 150000)
		return (-1);

	for (c = 0, co = 8; co <= 2048; co <<= 2, c++) {
		br = (cy_clock + (co * speed) / 2) / (co * speed);
		if (br < 0x100) {
			*bpr = br;
			*cor = c;
			return (0);
		}
	}

	return (-1);
}
@


1.35
log
@remove unused and uneeded includes under NCY_ISA > 0 and NCY_PCI > 0
where cy.h is not included.
discovered with a script from guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.34 2014/09/14 14:17:24 jsg Exp $	*/
d119 1
a119 1
		printf("cy: probe chip %d offset 0x%lx ... ",
d449 1
a449 1
	printf("%s read port %d uio 0x%x flag 0x%x\n", sc->sc_dev.dv_xname,
d472 1
a472 1
	printf("%s write port %d uio 0x%x flag 0x%x\n", sc->sc_dev.dv_xname,
d514 1
a514 1
	printf("%s port %d ioctl cmd 0x%x data 0x%x flag 0x%x\n",
d599 1
a599 1
	printf("%s port %d start, tty 0x%x\n", sc->sc_dev.dv_xname, port, tp);
d636 1
a636 1
	printf("%s port %d stop tty 0x%x flag 0x%x\n", sc->sc_dev.dv_xname,
d673 1
a673 1
	printf("%s port %d param tty 0x%x termios 0x%x\n", sc->sc_dev.dv_xname,
d1366 1
a1366 1
	printf("c1400_channel_cmd cy 0x%x command 0x%x\n", cy, cmd);
@


1.34
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.33 2010/11/18 21:15:15 miod Exp $	*/
a66 10

#if NCY_ISA > 0	
#include <dev/isa/isavar.h>
#include <dev/isa/isareg.h>
#endif /* NCY_ISA > 0 */
#if NCY_PCI > 0
#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#endif /* NCY_PCI > 0 */
@


1.33
log
@Don't
  #include "foo.h"
  #if NFOO > 0
  (whole file)
  #endif
since config(8) file inclusion rules already do it for you.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.32 2010/07/02 17:27:01 nicm Exp $	*/
a58 1
#include <sys/proc.h>
@


1.32
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.31 2010/06/28 14:13:32 deraadt Exp $	*/
a52 4
/* NCY is the number of Cyclom cards in the machine */
#include "cy.h"
#if NCY > 0

a1416 2

#endif /* NCY > 0 */
@


1.31
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.30 2010/06/26 23:24:44 guenther Exp $	*/
d624 3
a626 11
		if (tp->t_outq.c_cc <= tp->t_lowat) {
			if (ISSET(tp->t_state, TS_ASLEEP)) {
				CLR(tp->t_state, TS_ASLEEP);
				wakeup(&tp->t_outq);
			}

			selwakeup(&tp->t_wsel);

			if (tp->t_outq.c_cc == 0)
				goto out;
		}
@


1.30
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.29 2010/04/12 12:57:52 tedu Exp $	*/
d302 1
a302 1
		cy->cy_tty = ttymalloc();
@


1.29
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.28 2009/11/09 17:53:39 nicm Exp $	*/
a64 1
#include <sys/user.h>
@


1.28
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.27 2009/10/31 12:00:07 fgsch Exp $	*/
d403 1
a403 1
	return (*linesw[tp->t_line].l_open)(dev, tp);
d427 1
a427 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.27
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.26 2009/10/31 06:40:17 deraadt Exp $	*/
a631 1
			KNOTE(&tp->t_wsel.si_note, 0);
@


1.26
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.25 2005/11/21 18:16:39 millert Exp $	*/
d380 1
a380 1
	} else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {
@


1.25
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.24 2003/10/03 16:44:51 miod Exp $	*/
d632 1
@


1.24
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.23 2003/08/15 20:32:17 tedu Exp $	*/
d66 1
a66 1
#include <sys/select.h>
@


1.23
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.22 2003/08/05 16:14:47 markus Exp $	*/
d303 1
a303 6
		if ((cy->cy_tty = ttymalloc()) == NULL) {
			splx(s);
			printf("%s port %d open: can't allocate tty\n",
			    sc->sc_dev.dv_xname, port);
			return (ENOMEM);
		}
a306 2
	tp = cy->cy_tty;
	tty_attach(tp);
@


1.22
log
@print dv_xname instead of the uninitialized variable card; ok miod/henning/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.21 2003/01/05 22:41:35 deraadt Exp $	*/
d592 1
a592 1
		error = suser(p->p_ucred, &p->p_acflag);
@


1.21
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.20 2002/09/15 21:30:25 art Exp $	*/
d944 1
a944 1
	int card, port;
d1052 3
a1054 3
			printf("cy_poll: carrier change "
			    "(card %d, port %d, carrier %d)\n",
			    card, port, carrier);
d1086 2
a1087 2
			log(LOG_WARNING, "cy%d port %d fifo overrun\n",
			    card, port);
d1091 2
a1092 2
			log(LOG_WARNING, "cy%d port %d ibuf overrun\n",
			    card, port);
@


1.20
log
@Add a license from the author Timo Rossi <trossi@@co.jyu.fi>
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.19 2002/09/14 15:00:02 art Exp $	*/
d266 1
a266 1
 * open routine. returns zero if successfull, else error code
d414 1
a414 1
 * close routine. returns zero if successfull, else error code
d689 1
a689 1
 * returns 0 if successfull, else returns error code
@


1.19
log
@Various fixes and cleanups in the cy driver.
Finally my "Cyclades Cyclom-8Y" works correctly.

Cleanups:
 - no more stupid arrays, we have softc structs, use them.
 - no more global poll timeout that walks an array, timeouts are now cheap,
   one poll per softc.
 - sc_dev.dv_xname is the correct thing to print in diagnostic printfs.
 - don't have bus-specific code in the generic attach for @@#%$! sake, it
   took 20 seconds to fix (I suspect that the workaround took much more
   time to write).
 - spltty, not splhigh.
 - use pci_mapreg_map, not pci_{io,mem}_find + bus_space_map.
 - use defines, not magic constants in a few places.
 - KNF in a few places (much more work needed).
Now the interesting parts:
 - when handling the interrupt, don't just ignore it when the tty is not
   open. Read and discard the data. If we don't read it, the card will
   interrupt again and again and again and ... (inspired by NetBSD).
 - actually enable interrupts on PLX9050
 - From FreeBSD: "Work around a PLX9050 bug that causes system lockup in
   certain systems"

deraadt@@ ok
@
text
@d1 29
a29 1
/*	$OpenBSD: cy.c,v 1.18 2002/09/09 00:05:21 art Exp $	*/
@


1.18
log
@Correctly printf on attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.17 2002/03/14 01:26:54 millert Exp $	*/
a59 2
void	cy_attach(struct device *, struct device *, void *);
int	cy_probe_common(int, bus_space_tag_t, bus_space_handle_t, int);
a72 8
static int cy_nr_cd1400s[NCY];
static int cy_bus_types[NCY];
static bus_space_handle_t cy_card_memh[NCY];
static int cy_open = 0;
static int cy_events = 0;

struct timeout cy_poll_to;

d75 2
d79 1
a79 4
cy_probe_common(card, memt, memh, bustype)
	int card, bustype;
	bus_space_tag_t memt;
	bus_space_handle_t memh;
d83 1
d94 1
a94 1
	cy_nr_cd1400s[card] = 0;
d107 2
a108 2
		printf("cy%d probe chip %d offset 0x%lx ... ",
		    card, cy_chip, chip_offs);
d157 1
a157 1
		cy_nr_cd1400s[card]++;
d160 1
a160 1
	if (cy_nr_cd1400s[card] == 0) {
d168 1
a168 1
	printf("found %d CD1400s\n", cy_nr_cd1400s[card]);
d171 1
a171 4
	cy_card_memh[card] = memh;
	cy_bus_types[card] = bustype;

	return (1);
d175 1
a175 1
cy_attach(parent, self, aux)
a176 1
	void *aux;
d182 1
a182 1
	num_chips = cy_nr_cd1400s[card];
d186 1
a186 17
	sc->sc_bustype = cy_bus_types[card];
	sc->sc_memh = cy_card_memh[card];
	switch (sc->sc_bustype) {
#if NCY_ISA > 0
	case CY_BUSTYPE_ISA:
		sc->sc_memt = ((struct isa_attach_args *)(aux))->ia_memt;
		break;
#endif
#if NCY_PCI > 0
	case CY_BUSTYPE_PCI:
		sc->sc_memt = ((struct pci_attach_args *)aux)->pa_memt;
		break;
#endif
	}

	if (!timeout_initialized(&cy_poll_to))
		timeout_set(&cy_poll_to, cy_poll, NULL);
a234 18

	switch (sc->sc_bustype) {
#if NCY_ISA > 0
	case CY_BUSTYPE_ISA:
	{
		struct isa_attach_args *ia = aux;

		sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq,
		    IST_EDGE, IPL_TTY, cy_intr, sc, sc->sc_dev.dv_xname);

		if (sc->sc_ih == NULL)
			panic("cy: couldn't establish interrupt");
	}
	break;
#endif /* NCY_ISA > 0 */
	case CY_BUSTYPE_PCI:
		break;
	}
a260 5
#ifdef CY_DEBUG
	printf("cy%d open port %d flag 0x%x mode 0x%x\n",
	    card, port, flag, mode);
#endif

d266 5
d277 2
a278 2
			printf("cy%d port %d open: can't allocate tty\n",
			    card, port);
d314 2
a315 2
				printf("cy%d: (port %d) can't allocate input buffer\n",
				       card, port);
d335 2
a336 5
		/* hmm... need spltty() here? */
		if (cy_open == 0) {
			cy_open = 1;
			timeout_add(&cy_poll_to, 1);
		}
d402 2
a403 2
	printf("cy%d close port %d, flag 0x%x, mode 0x%x\n",
	    card, port, flag, mode);
d444 2
a445 2
	printf("cy%d read port %d uio 0x%x flag 0x%x\n",
	    card, port, uio, flag);
d467 2
a468 2
	printf("cy%d write port %d uio 0x%x flag 0x%x\n",
	    card, port, uio, flag);
a486 5
#ifdef CY_DEBUG
	printf("cy%d tty port %d tp 0x%x\n",
	    card, port, tp);
#endif

d509 2
a510 2
	printf("cy%d port %d ioctl cmd 0x%x data 0x%x flag 0x%x\n",
	    card, port, cmd, data, flag);
d594 1
a594 1
	printf("cy%d port %d start, tty 0x%x\n", card, port, tp);
d639 2
a640 2
	printf("cy%d port %d stop tty 0x%x flag 0x%x\n",
	    card, port, tp, flag);
d676 2
a677 2
	printf("cy%d port %d param tty 0x%x termios 0x%x\n",
	    card, port, tp, t);
d914 1
a914 2
cy_poll(arg)
	void *arg;
d917 1
a917 1
	struct cy_softc *sc;
d927 1
a927 1
	s = splhigh();
d929 1
a929 1
	if (cy_events == 0 && ++counter < 200) {
d934 1
a934 1
	cy_events = 0;
a936 5
	for (card = 0; card < cy_cd.cd_ndevs; card++) {
		sc = cy_cd.cd_devs[card];
		if (sc == NULL)
			continue;

d938 2
a939 2
		sc->sc_poll_count1++;
		did_something = 0;
d942 21
a962 5
		for (port = 0; port < sc->sc_nports; port++) {
			cy = &sc->sc_ports[port];
			if ((tp = cy->cy_tty) == NULL || cy->cy_ibuf == NULL ||
			    !ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN))
				continue;
d965 2
a966 1
			 * handle received data
a967 17
			while (cy->cy_ibuf_rd_ptr != cy->cy_ibuf_wr_ptr) {
				u_char line_stat;
				int chr;

				line_stat = cy->cy_ibuf_rd_ptr[0];
				chr = cy->cy_ibuf_rd_ptr[1];

				if (line_stat &
				    (CD1400_RDSR_BREAK|CD1400_RDSR_FE))
					chr |= TTY_FE;
				if (line_stat & CD1400_RDSR_PE)
					chr |= TTY_PE;

				/*
				 * on an overrun error the data is treated as
				 * good just as it should be.
				 */
d970 2
a971 2
				printf("cy%d port %d ttyinput 0x%x\n",
				    card, port, chr);
d974 1
a974 1
				(*linesw[tp->t_line].l_rint)(chr, tp);
d976 5
a980 5
				s = splhigh(); /* really necessary? */
				if ((cy->cy_ibuf_rd_ptr += 2) ==
				    cy->cy_ibuf_end)
					cy->cy_ibuf_rd_ptr = cy->cy_ibuf;
				splx(s);
d983 1
a983 1
				did_something = 1;
d985 1
a985 1
			}
d988 10
a997 9
			/* If we don't have any received data in ibuf and
			 * CRTSCTS is on and RTS is turned off, it is time
			 * to turn RTS back on
			 */
			if (ISSET(tp->t_cflag, CRTSCTS)) {
				/* we can't use cy_modem_control() here as it
				    doesn't change RTS if RTSCTS is on */
				cd_write_reg(cy, CD1400_CAR,
				    port & CD1400_CAR_CHAN);
d999 4
a1002 4
				if ((cd_read_reg(cy,
				    CD1400_MSVR1) & CD1400_MSVR1_RTS) == 0) {
					cd_write_reg(cy, CD1400_MSVR1,
					    CD1400_MSVR1_RTS);
d1004 1
a1004 1
					did_something = 1;
a1005 1
				}
d1007 1
d1010 6
a1015 6
			/*
			 * handle carrier changes
			 */
			s = splhigh();
			if (ISSET(cy->cy_flags, CYF_CARRIER_CHANGED)) {
				int carrier;
d1017 2
a1018 2
				CLR(cy->cy_flags, CYF_CARRIER_CHANGED);
				splx(s);
d1020 2
a1021 2
				carrier = ((cy->cy_carrier_stat &
				    CD1400_MSVR2_CD) != 0);
d1024 3
a1026 3
				printf("cy_poll: carrier change "
				    "(card %d, port %d, carrier %d)\n",
				    card, port, carrier);
d1028 3
a1030 3
				if (CY_DIALIN(tp->t_dev) &&
				    !(*linesw[tp->t_line].l_modem)(tp, carrier))
					cy_modem_control(cy, TIOCM_DTR, DMBIC);
d1033 1
a1033 1
				did_something = 1;
d1035 3
a1037 3
			} else {
				splx(s);
			}
d1039 4
a1042 4
			s = splhigh();
			if (ISSET(cy->cy_flags, CYF_START)) {
				CLR(cy->cy_flags, CYF_START);
				splx(s);
d1044 1
a1044 1
				(*linesw[tp->t_line].l_start)(tp);
d1047 1
a1047 1
				did_something = 1;
d1049 3
a1051 3
			} else {
				splx(s);
			}
d1053 14
a1066 14
			/* could move this to even upper level... */
			if (cy->cy_fifo_overruns) {
				cy->cy_fifo_overruns = 0;
				/* doesn't report overrun count,
				   but shouldn't really matter */
				log(LOG_WARNING, "cy%d port %d fifo overrun\n",
				    card, port);
			}
			if (cy->cy_ibuf_overruns) {
				cy->cy_ibuf_overruns = 0;
				log(LOG_WARNING, "cy%d port %d ibuf overrun\n",
				    card, port);
			}
		} /* for(port...) */
d1068 2
a1069 2
		if (did_something && counter >= 200)
			sc->sc_poll_count2++;
a1070 1
	} /* for(card...) */
d1075 1
a1075 1
	timeout_add(&cy_poll_to, 1);
a1086 1
	int card = sc->sc_dev.dv_unit;
d1088 1
a1088 1
	int int_serviced = 0;
d1094 1
a1094 1
	for (cy_chip = 0; cy_chip < cy_nr_cd1400s[card]; cy_chip++) {
a1116 4
			if (cy->cy_tty == NULL ||
			    !ISSET(cy->cy_tty->t_state, TS_ISOPEN))
				goto end_rx_serv;

d1123 4
d1128 1
a1128 1
				printf("cy%d port %d recv exception, "
d1130 2
a1131 1
				    card, cy->cy_port_num, line_stat, recv_data);
d1147 1
a1147 1
				cy_events = 1;
d1150 9
d1160 3
a1162 2
				printf("cy%d port %d receive ok %d chars\n",
				    card, cy->cy_port_num, n_chars);
d1178 1
a1178 1
				cy_events = 1;
d1222 2
a1223 2
			printf("cy%d port %d modem line change, new stat 0x%x\n",
			    card, cy->cy_port_num, modem_stat);
d1228 1
a1228 1
				cy_events = 1;
d1255 2
a1256 2
			printf("cy%d port %d tx service\n",
			    card, cy->cy_port_num);
d1327 1
a1327 1
				cy_events = 1;
d1351 1
a1351 1
	s = splhigh();
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.16 2002/01/30 20:45:34 nordin Exp $	*/
d260 1
a260 3
#if CY_DEBUG
	printf("cy: %d ports\n", port);
#endif
d315 1
a315 1
	    (sc = cy_cd.cd_devs[card]) == NULL)
d317 1
@


1.16
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.15 2001/08/20 04:41:39 smart Exp $	*/
d60 10
a69 10
void	cy_attach __P((struct device *, struct device *, void *));
int	cy_probe_common __P((int, bus_space_tag_t, bus_space_handle_t, int));
int	cy_intr __P((void *));
int	cyparam __P((struct tty *, struct termios *));
void	cystart __P((struct tty *));
void	cy_poll __P((void *));
int	cy_modem_control __P((struct cy_port *, int, int));
void	cy_enable_transmitter __P((struct cy_port *));
void	cd1400_channel_cmd __P((struct cy_port *, int));
int	cy_speed __P((speed_t, int *, int *, int));
d290 7
a296 7
int cyopen __P((dev_t, int, int, struct proc *));
int cyclose __P((dev_t, int, int, struct proc *));
int cyread __P((dev_t, struct uio *, int));
int cywrite __P((dev_t, struct uio *, int));
struct tty *cytty __P((dev_t));
int cyioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int cystop __P((struct tty *, int flag));
@


1.15
log
@Allow driver to recognize Cyclades 4Y and 8Y cards.

Not finished yet, but cleaned up and moved around code for
better organization.  Inspired by NetBSD and other PCI drivers.

From my dmesg:
     cy1 at pci0 dev 10 function 0 "Cyclades Cyclom-8Y" rev 0x01
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.14 2001/08/19 19:58:56 smart Exp $	*/
a57 6


/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))
@


1.15.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.16 2002/01/30 20:45:34 nordin Exp $	*/
d58 6
@


1.15.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.15.4.1 2002/01/31 22:55:31 niklas Exp $	*/
d60 10
a69 10
void	cy_attach(struct device *, struct device *, void *);
int	cy_probe_common(int, bus_space_tag_t, bus_space_handle_t, int);
int	cy_intr(void *);
int	cyparam(struct tty *, struct termios *);
void	cystart(struct tty *);
void	cy_poll(void *);
int	cy_modem_control(struct cy_port *, int, int);
void	cy_enable_transmitter(struct cy_port *);
void	cd1400_channel_cmd(struct cy_port *, int);
int	cy_speed(speed_t, int *, int *, int);
d290 7
a296 7
int cyopen(dev_t, int, int, struct proc *);
int cyclose(dev_t, int, int, struct proc *);
int cyread(dev_t, struct uio *, int);
int cywrite(dev_t, struct uio *, int);
struct tty *cytty(dev_t);
int cyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int cystop(struct tty *, int flag);
@


1.15.4.3
log
@sync to -current
@
text
@d1 1
a1 29
/*	$OpenBSD$	*/
/*
 * Copyright (c) 1996 Timo Rossi.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
d60 2
d75 8
a84 2
 *
 * returns the number of chips found.
d87 4
a90 1
cy_probe_common(bus_space_tag_t memt, bus_space_handle_t memh, int bustype)
a93 1
	int nchips;
d104 1
a104 1
	nchips = 0;
d117 2
a118 2
		printf("cy: probe chip %d offset 0x%lx ... ",
		    cy_chip, chip_offs);
d167 1
a167 1
		nchips++;
d170 1
a170 1
	if (nchips == 0) {
d178 1
a178 1
	printf("found %d CD1400s\n", nchips);
d181 4
a184 1
	return (nchips);
d188 1
a188 1
cy_attach(parent, self)
d190 1
d196 1
a196 1
	num_chips = sc->sc_nr_cd1400s;
d200 17
a216 1
	timeout_set(&sc->sc_poll_to, cy_poll, sc);
d260 3
a262 1
	printf(": %d ports\n", port);
d267 18
d311 5
d317 1
a317 1
	    (sc = cy_cd.cd_devs[card]) == NULL) {
a318 6
	}

#ifdef CY_DEBUG
	printf("%s open port %d flag 0x%x mode 0x%x\n", sc->sc_dev.dv_xname,
	    port, flag, mode);
#endif
d326 2
a327 2
			printf("%s port %d open: can't allocate tty\n",
			    sc->sc_dev.dv_xname, port);
d363 2
a364 2
				printf("%s: (port %d) can't allocate input buffer\n",
				       sc->sc_dev.dv_xname, port);
d384 5
a388 2
		if (!timeout_pending(&sc->sc_poll_to))
			timeout_add(&sc->sc_poll_to, 1);
d454 2
a455 2
	printf("%s close port %d, flag 0x%x, mode 0x%x\n", sc->sc_dev.dv_xname,
	    port, flag, mode);
d496 2
a497 2
	printf("%s read port %d uio 0x%x flag 0x%x\n", sc->sc_dev.dv_xname,
	    port, uio, flag);
d519 2
a520 2
	printf("%s write port %d uio 0x%x flag 0x%x\n", sc->sc_dev.dv_xname,
	    port, uio, flag);
d539 5
d566 2
a567 2
	printf("%s port %d ioctl cmd 0x%x data 0x%x flag 0x%x\n",
	    sc->sc_dev.dv_xname, port, cmd, data, flag);
d651 1
a651 1
	printf("%s port %d start, tty 0x%x\n", sc->sc_dev.dv_xname, port, tp);
d696 2
a697 2
	printf("%s port %d stop tty 0x%x flag 0x%x\n", sc->sc_dev.dv_xname,
	    port, tp, flag);
d733 2
a734 2
	printf("%s port %d param tty 0x%x termios 0x%x\n", sc->sc_dev.dv_xname,
	    port, tp, t);
d971 2
a972 1
cy_poll(void *arg)
d975 1
a975 1
	struct cy_softc *sc = arg;
d985 1
a985 1
	s = spltty();
d987 1
a987 1
	if (sc->sc_events == 0 && ++counter < 200) {
d992 1
a992 1
	sc->sc_events = 0;
d995 5
d1001 2
a1002 2
	sc->sc_poll_count1++;
	did_something = 0;
d1005 5
a1009 21
	for (port = 0; port < sc->sc_nports; port++) {
		cy = &sc->sc_ports[port];
		if ((tp = cy->cy_tty) == NULL || cy->cy_ibuf == NULL ||
		    !ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN))
			continue;

		/*
		 * handle received data
		 */
		while (cy->cy_ibuf_rd_ptr != cy->cy_ibuf_wr_ptr) {
			u_char line_stat;
			int chr;

			line_stat = cy->cy_ibuf_rd_ptr[0];
			chr = cy->cy_ibuf_rd_ptr[1];

			if (line_stat &
			    (CD1400_RDSR_BREAK|CD1400_RDSR_FE))
				chr |= TTY_FE;
			if (line_stat & CD1400_RDSR_PE)
				chr |= TTY_PE;
d1012 1
a1012 2
			 * on an overrun error the data is treated as
			 * good just as it should be.
d1014 17
d1033 2
a1034 2
			printf("%s port %d ttyinput 0x%x\n",
			    sc->sc_dev.dv_xname, port, chr);
d1037 1
a1037 1
			(*linesw[tp->t_line].l_rint)(chr, tp);
d1039 5
a1043 5
			s = spltty(); /* really necessary? */
			if ((cy->cy_ibuf_rd_ptr += 2) ==
			    cy->cy_ibuf_end)
				cy->cy_ibuf_rd_ptr = cy->cy_ibuf;
			splx(s);
d1046 1
a1046 1
			did_something = 1;
d1048 1
a1048 1
		}
d1051 9
a1059 10
		/*
		 * If we don't have any received data in ibuf and
		 * CRTSCTS is on and RTS is turned off, it is time
		 * to turn RTS back on
		 */
		if (ISSET(tp->t_cflag, CRTSCTS)) {
			/* we can't use cy_modem_control() here as it
			    doesn't change RTS if RTSCTS is on */
			cd_write_reg(cy, CD1400_CAR,
			    port & CD1400_CAR_CHAN);
d1061 4
a1064 4
			if ((cd_read_reg(cy,
			    CD1400_MSVR1) & CD1400_MSVR1_RTS) == 0) {
				cd_write_reg(cy, CD1400_MSVR1,
				    CD1400_MSVR1_RTS);
d1066 1
a1066 1
				did_something = 1;
d1068 1
a1069 1
		}
d1072 6
a1077 6
		/*
		 * handle carrier changes
		 */
		s = spltty();
		if (ISSET(cy->cy_flags, CYF_CARRIER_CHANGED)) {
			int carrier;
d1079 2
a1080 2
			CLR(cy->cy_flags, CYF_CARRIER_CHANGED);
			splx(s);
d1082 2
a1083 2
			carrier = ((cy->cy_carrier_stat &
			    CD1400_MSVR2_CD) != 0);
d1086 3
a1088 3
			printf("cy_poll: carrier change "
			    "(card %d, port %d, carrier %d)\n",
			    card, port, carrier);
d1090 3
a1092 3
			if (CY_DIALIN(tp->t_dev) &&
			    !(*linesw[tp->t_line].l_modem)(tp, carrier))
				cy_modem_control(cy, TIOCM_DTR, DMBIC);
d1095 1
a1095 1
			did_something = 1;
d1097 3
a1099 3
		} else {
			splx(s);
		}
d1101 4
a1104 4
		s = spltty();
		if (ISSET(cy->cy_flags, CYF_START)) {
			CLR(cy->cy_flags, CYF_START);
			splx(s);
d1106 1
a1106 1
			(*linesw[tp->t_line].l_start)(tp);
d1109 1
a1109 1
			did_something = 1;
d1111 3
a1113 3
		} else {
			splx(s);
		}
d1115 14
a1128 14
		/* could move this to even upper level... */
		if (cy->cy_fifo_overruns) {
			cy->cy_fifo_overruns = 0;
			/* doesn't report overrun count,
			   but shouldn't really matter */
			log(LOG_WARNING, "cy%d port %d fifo overrun\n",
			    card, port);
		}
		if (cy->cy_ibuf_overruns) {
			cy->cy_ibuf_overruns = 0;
			log(LOG_WARNING, "cy%d port %d ibuf overrun\n",
			    card, port);
		}
	} /* for(port...) */
d1130 2
a1131 2
	if (did_something && counter >= 200)
		sc->sc_poll_count2++;
d1133 1
d1138 1
a1138 1
	timeout_add(&sc->sc_poll_to, 1);
d1150 1
d1152 1
a1152 1
	int int_serviced = -1;
d1158 1
a1158 1
	for (cy_chip = 0; cy_chip < sc->sc_nr_cd1400s; cy_chip++) {
d1181 4
a1190 4
				if (cy->cy_tty == NULL ||
				    !ISSET(cy->cy_tty->t_state, TS_ISOPEN))
					goto end_rx_serv;

d1192 1
a1192 1
				printf("%s port %d recv exception, "
d1194 1
a1194 2
				    sc->sc_dev.dv_xname, cy->cy_port_num,
				    line_stat, recv_data);
d1210 1
a1210 1
				sc->sc_events = 1;
a1212 9

				/* If no tty or not open, discard data */
				if (cy->cy_tty == NULL ||
				    !ISSET(cy->cy_tty->t_state, TS_ISOPEN)) {
					while (n_chars--)
						cd_read_reg(cy, CD1400_RDSR);
					goto end_rx_serv;
				}

d1214 2
a1215 3
				printf("%s port %d receive ok %d chars\n",
				    sc->sc_dev.dv_xname, cy->cy_port_num,
				    n_chars);
d1231 1
a1231 1
				sc->sc_events = 1;
d1275 2
a1276 2
			printf("%s port %d modem line change, new stat 0x%x\n",
			    sc->sc_dev.dv_xname, cy->cy_port_num, modem_stat);
d1281 1
a1281 1
				sc->sc_events = 1;
d1308 2
a1309 2
			printf("%s port %d tx service\n", sc->sc_dev.dv_xname,
			    cy->cy_port_num);
d1380 1
a1380 1
				sc->sc_events = 1;
d1404 1
a1404 1
	s = spltty();
@


1.15.4.4
log
@sync
@
text
@d266 1
a266 1
 * open routine. returns zero if successful, else error code
d414 1
a414 1
 * close routine. returns zero if successful, else error code
d689 1
a689 1
 * returns 0 if successful, else returns error code
@


1.14
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.13 2001/04/23 10:55:46 art Exp $	*/
a24 3
#undef CY_DEBUG
#undef CY_DEBUG1

d66 1
a66 1
void	cyattach __P((struct device *, struct device *, void *));
d68 1
a68 1
int	cyintr __P((void *));
d114 1
a114 1
	    cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<bustype)) {
d120 1
a120 1
			chip_offs -= (CY32_ADDR_FIX<<bustype);
d130 1
a130 1
		    ((CD1400_CCR<<1) << bustype)) != 0) {
d139 1
a139 1
		    ((CD1400_GFRCR<<1) << bustype), 0);
d149 1
a149 1
			((CD1400_GFRCR<<1) << bustype)) == 0)
d154 1
a154 1
		    ((CD1400_CCR<<1) << bustype),
d161 1
a161 1
			    ((CD1400_GFRCR<<1) << bustype));
a192 3
/*
 * Attach (ISA/PCI)
 */
d194 1
a194 1
cyattach(parent, self, aux)
d198 1
a199 1
	int card, port, cy_chip, num_chips, cdu, chip_offs, cy_clock;
d266 3
a268 1
	printf(" (%d ports)\n", port);
d281 4
a284 1
		    IST_EDGE, IPL_TTY, cyintr, sc, sc->sc_dev.dv_xname);
a287 1
#if NCY_PCI > 0
d289 1
a289 13
	{
		pci_intr_handle_t intrhandle;
		struct pci_attach_args *pa = aux;

		if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
		    pa->pa_intrline, &intrhandle) != 0)
			panic("cy: couldn't map PCI interrupt");

		sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle,
		    IPL_TTY, cyintr, sc, sc->sc_dev.dv_xname);
	}
	break;
#endif /* NCY_PCI > 0 */
a290 3

	if (sc->sc_ih == NULL)
		panic("cy: couldn't establish interrupt");
a292 2
#undef CY_DEBUG /*!!*/

d1151 1
a1151 1
cyintr(arg)
@


1.13
log
@double splx
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.12 2001/03/25 11:54:00 art Exp $	*/
d81 1
a81 1
  NULL, "cy", DV_TTY
d97 3
a99 3
     int card, bustype;
     bus_space_tag_t memt;
     bus_space_handle_t memh;
d101 2
a102 2
  int cy_chip, chip_offs;
  u_char firmware_ver;
d104 4
a107 4
  /* Cyclom card hardware reset */
  bus_space_write_1(memt, memh, CY16_RESET<<bustype, 0);
  DELAY(500); /* wait for reset to complete */
  bus_space_write_1(memt, memh, CY_CLEAR_INTR<<bustype, 0);
d110 1
a110 1
  printf("cy: card reset done\n");
d113 1
a113 1
  cy_nr_cd1400s[card] = 0;
d115 4
a118 4
  for(cy_chip = 0, chip_offs = 0;
      cy_chip < CY_MAX_CD1400s;
      cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<bustype)) {
    int i;
d120 4
a123 4
    /* the last 4 cd1400s are 'interleaved'
       with the first 4 on 32-port boards */
    if(cy_chip == 4)
      chip_offs -= (CY32_ADDR_FIX<<bustype);
d126 2
a127 2
    printf("cy%d probe chip %d offset 0x%lx ... ",
	   card, cy_chip, chip_offs);
d130 4
a133 4
    /* wait until the chip is ready for command */
    DELAY(1000);
    if(bus_space_read_1(memt, memh, chip_offs +
		      ((CD1400_CCR<<1) << bustype)) != 0) {
d135 1
a135 1
      printf("not ready for command\n");
d137 2
a138 2
      break;
    }
d140 2
a141 2
    /* clear the firmware version reg. */
    bus_space_write_1(memt, memh, chip_offs +
d144 10
a153 10
    /*
     * On Cyclom-16 references to non-existent chip 4
     * actually access chip 0 (address line 9 not decoded).
     * Here we check if the clearing of chip 4 GFRCR actually
     * cleared chip 0 GFRCR. In that case we have a 16 port card.
     */
    if(cy_chip == 4 &&
       bus_space_read_1(memt, memh, chip_offs +
		      ((CD1400_GFRCR<<1) << bustype)) ==0)
      break;
d155 2
a156 2
    /* reset the chip */
    bus_space_write_1(memt, memh, chip_offs +
d160 8
a167 9
    /* wait for the chip to initialize itself */
    for(i = 0; i < 200; i++) {
      DELAY(50);
      firmware_ver =
	bus_space_read_1(memt, memh, chip_offs +
		       ((CD1400_GFRCR<<1) << bustype));
      if((firmware_ver & 0xf0) == 0x40) /* found a CD1400 */
	break;
    }
d169 1
a169 1
    printf("firmware version 0x%x\n", firmware_ver);
d172 2
a173 2
    if((firmware_ver & 0xf0) != 0x40)
      break;
d175 3
a177 3
    /* firmware version OK, CD1400 found */
    cy_nr_cd1400s[card]++;
  }
d179 1
a179 1
  if(cy_nr_cd1400s[card] == 0) {
d181 1
a181 1
    printf("no CD1400s found\n");
d183 2
a184 2
    return 0;
  }
d187 1
a187 1
  printf("found %d CD1400s\n", cy_nr_cd1400s[card]);
d190 2
a191 2
  cy_card_memh[card] = memh;
  cy_bus_types[card] = bustype;
d193 1
a193 1
  return 1;
d201 2
a202 2
     struct device *parent, *self;
     void *aux;
d204 2
a205 2
  struct cy_softc *sc = (void *)self;
  int card, port, cy_chip, num_chips, cdu, chip_offs, cy_clock;
d207 8
a214 8
  card = sc->sc_dev.dv_unit;
  num_chips = cy_nr_cd1400s[card];
  if(num_chips == 0)
    return;

  sc->sc_bustype = cy_bus_types[card];
  sc->sc_memh = cy_card_memh[card];
  switch(sc->sc_bustype) {
d216 3
a218 3
    case CY_BUSTYPE_ISA:
      sc->sc_memt = ((struct isa_attach_args *)(aux))->ia_memt;
      break;
d221 3
a223 3
    case CY_BUSTYPE_PCI:
      sc->sc_memt = ((struct pci_attach_args *)aux)->pa_memt;
      break;
d225 1
a225 11
  }

  if (!timeout_initialized(&cy_poll_to))
    timeout_set(&cy_poll_to, cy_poll, NULL);
  bzero(sc->sc_ports, sizeof(sc->sc_ports));
  sc->sc_nports = num_chips * CD1400_NO_OF_CHANNELS;

  port = 0;
  for(cy_chip = 0, chip_offs = 0;
      cy_chip < num_chips; cy_chip++,
      chip_offs += (CY_CD1400_MEMSPACING<<sc->sc_bustype)) {
d227 26
a252 2
    if(cy_chip == 4)
      chip_offs -= (CY32_ADDR_FIX<<sc->sc_bustype);
d254 2
a255 16
#ifdef CY_DEBUG
    printf("attach CD1400 #%d offset 0x%x\n", cy_chip, chip_offs);
#endif
    sc->sc_cd1400_offs[cy_chip] = chip_offs;

    /* configure port 0 as serial port (should already be after reset) */
    cd_write_reg_sc(sc, cy_chip, CD1400_GCR, 0);

    /* Set cy_clock depending on firmware version */
    if (cd_read_reg_sc(sc, cy_chip, CD1400_GFRCR) <= 0x46)
        cy_clock = CY_CLOCK;
    else 
        cy_clock = CY_CLOCK_60;

    /* set up a receive timeout period (1ms) */
    cd_write_reg_sc(sc, cy_chip, CD1400_PPR,
d258 19
a276 19
    for(cdu = 0; cdu < CD1400_NO_OF_CHANNELS; cdu++) {
      sc->sc_ports[port].cy_port_num = port;
      sc->sc_ports[port].cy_memt = sc->sc_memt;
      sc->sc_ports[port].cy_memh = sc->sc_memh;
      sc->sc_ports[port].cy_chip_offs = chip_offs;
      sc->sc_ports[port].cy_bustype = sc->sc_bustype;
      sc->sc_ports[port].cy_clock = cy_clock;

      /* should we initialize anything else here? */
      port++;
    } /* for(each port on one CD1400...) */

  } /* for(each CD1400 on a card... ) */

  printf(" (%d ports)\n", port);

  /* ensure an edge for the next interrupt */
  bus_space_write_1(sc->sc_memt, sc->sc_memh,
		  CY_CLEAR_INTR<<sc->sc_bustype, 0);
d278 1
a278 1
  switch(sc->sc_bustype) {
d280 8
a287 9
    case CY_BUSTYPE_ISA:
      {
	struct isa_attach_args *ia = aux;

	sc->sc_ih =
	  isa_intr_establish(ia->ia_ic, ia->ia_irq,
	    IST_EDGE, IPL_TTY, cyintr, sc, sc->sc_dev.dv_xname);
      }
      break;
d290 13
a302 13
    case CY_BUSTYPE_PCI:
      {
	pci_intr_handle_t intrhandle;
	struct pci_attach_args *pa = aux;

	if(pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
			pa->pa_intrline, &intrhandle) != 0)
	  panic("cy: couldn't map PCI interrupt");

	sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle,
	  IPL_TTY, cyintr, sc, sc->sc_dev.dv_xname);
      }
      break;
d304 1
a304 1
  }
d306 2
a307 2
  if(sc->sc_ih == NULL)
    panic("cy: couldn't establish interrupt");
d325 3
a327 3
     dev_t dev;
     int flag, mode;
     struct proc *p;
d329 17
a345 49
    int card = CY_CARD(dev);
    int port = CY_PORT(dev);
    struct cy_softc *sc;
    struct cy_port *cy;
    struct tty *tp;
    int s, error;

#ifdef CY_DEBUG
    printf("cy%d open port %d flag 0x%x mode 0x%x\n",
	   card, port, flag, mode);
#endif

    if(card >= cy_cd.cd_ndevs ||
       (sc = cy_cd.cd_devs[card]) == NULL)
      return ENXIO;

    cy = &sc->sc_ports[port];

    s = spltty();
    if(cy->cy_tty == NULL) {
	if((cy->cy_tty = ttymalloc()) == NULL) {
	    splx(s);
	    printf("cy%d port %d open: can't allocate tty\n", card, port);
	    return ENOMEM;
	}
    }
    splx(s);

    tp = cy->cy_tty;
    tty_attach(tp);
    tp = cy->cy_tty;
    tp->t_oproc = cystart;
    tp->t_param = cyparam;
    tp->t_dev = dev;

    if(!ISSET(tp->t_state, TS_ISOPEN)) {
	SET(tp->t_state, TS_WOPEN);
	ttychars(tp);
	tp->t_iflag = TTYDEF_IFLAG;
	tp->t_oflag = TTYDEF_OFLAG;
	tp->t_cflag = TTYDEF_CFLAG;
	if(ISSET(cy->cy_openflags, TIOCFLAG_CLOCAL))
	  SET(tp->t_cflag, CLOCAL);
	if(ISSET(cy->cy_openflags, TIOCFLAG_CRTSCTS))
	  SET(tp->t_cflag, CRTSCTS);
	if(ISSET(cy->cy_openflags, TIOCFLAG_MDMBUF))
	  SET(tp->t_cflag, MDMBUF);
	tp->t_lflag = TTYDEF_LFLAG;
	tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
d348 74
d423 18
a440 60
	/*
	 * Allocate input ring buffer if we don't already have one
	 */
	if(cy->cy_ibuf == NULL) {
	    cy->cy_ibuf = malloc(IBUF_SIZE, M_DEVBUF, M_NOWAIT);
	    if(cy->cy_ibuf == NULL) {
		printf("cy%d: (port %d) can't allocate input buffer\n",
		       card, port);
		splx(s);
		return ENOMEM;
	    }
	    cy->cy_ibuf_end = cy->cy_ibuf + IBUF_SIZE;
	}

	/* mark the ring buffer as empty */
	cy->cy_ibuf_rd_ptr = cy->cy_ibuf_wr_ptr = cy->cy_ibuf;

	/* select CD1400 channel */
	cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN);
	/* reset the channel */
	cd1400_channel_cmd(cy, CD1400_CCR_CMDRESET);
	/* encode unit (port) number in LIVR */
	/* there is just enough space for 5 bits (32 ports) */
	cd_write_reg(cy, CD1400_LIVR, port << 3);

	cy->cy_channel_control = 0;

	/* hmm... need spltty() here? */
	if(cy_open == 0)
	  {
	    cy_open = 1;
	    timeout_add(&cy_poll_to, 1);
	  }

	/* this sets parameters and raises DTR */
	cyparam(tp, &tp->t_termios);

	ttsetwater(tp);

	/* raise RTS too */
	cy_modem_control(cy, TIOCM_RTS, DMBIS);

	cy->cy_carrier_stat =
	  cd_read_reg(cy, CD1400_MSVR2);

	/* enable receiver and modem change interrupts */
	cd_write_reg(cy, CD1400_SRER, CD1400_SRER_MDMCH | CD1400_SRER_RXDATA);

	if(CY_DIALOUT(dev) ||
	   ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR) ||
	   ISSET(tp->t_cflag, MDMBUF) ||
	   ISSET(cy->cy_carrier_stat, CD1400_MSVR2_CD))
	  SET(tp->t_state, TS_CARR_ON);
	else
	  CLR(tp->t_state, TS_CARR_ON);
    } else if(ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {
	return EBUSY;
    } else {
	s = spltty();
    }
d442 13
a454 11
    /* wait for carrier if necessary */
    if(!ISSET(flag, O_NONBLOCK)) {
	while(!ISSET(tp->t_cflag, CLOCAL) &&
	    !ISSET(tp->t_state, TS_CARR_ON)) {
	    SET(tp->t_state, TS_WOPEN);
	    error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH, "cydcd", 0);
	    if(error != 0) {
		splx(s);
		CLR(tp->t_state, TS_WOPEN);
		return error;
	    }
a455 1
    }
d457 1
a457 1
    splx(s);
d459 1
a459 1
    return (*linesw[tp->t_line].l_open)(dev, tp);
d467 3
a469 3
     dev_t dev;
     int flag, mode;
     struct proc *p;
d471 21
a491 21
    int card = CY_CARD(dev);
    int port = CY_PORT(dev);
    struct cy_softc *sc = cy_cd.cd_devs[card];
    struct cy_port *cy = &sc->sc_ports[port];
    struct tty *tp = cy->cy_tty;
    int s;

#ifdef CY_DEBUG
    printf("cy%d close port %d, flag 0x%x, mode 0x%x\n",
	 card, port, flag, mode);
#endif

    (*linesw[tp->t_line].l_close)(tp, flag);
    s = spltty();

    if(ISSET(tp->t_cflag, HUPCL) &&
       !ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR)) {
	/* drop DTR and RTS
	   (should we wait for output buffer to become empty first?) */
	cy_modem_control(cy, 0, DMSET);
    }
d493 5
a497 5
/*
 * XXX should we disable modem change and
 * receive interrupts here or somewhere ?
 */
    CLR(tp->t_state, TS_BUSY | TS_FLUSH);
d499 2
a500 2
    splx(s);
    ttyclose(tp);
d502 1
a502 1
    return 0;
d510 3
a512 3
     dev_t dev;
     struct uio *uio;
     int flag;
d514 5
a518 5
    int card = CY_CARD(dev);
    int port = CY_PORT(dev);
    struct cy_softc *sc = cy_cd.cd_devs[card];
    struct cy_port *cy = &sc->sc_ports[port];
    struct tty *tp = cy->cy_tty;
d521 2
a522 2
    printf("cy%d read port %d uio 0x%x flag 0x%x\n",
	   card, port, uio, flag);
d525 1
a525 1
    return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d533 3
a535 3
     dev_t dev;
     struct uio *uio;
     int flag;
d537 5
a541 5
    int card = CY_CARD(dev);
    int port = CY_PORT(dev);
    struct cy_softc *sc = cy_cd.cd_devs[card];
    struct cy_port *cy = &sc->sc_ports[port];
    struct tty *tp = cy->cy_tty;
d544 2
a545 2
    printf("cy%d write port %d uio 0x%x flag 0x%x\n",
	   card, port, uio, flag);
d548 1
a548 1
    return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d556 1
a556 1
     dev_t dev;
d558 5
a562 5
    int card = CY_CARD(dev);
    int port = CY_PORT(dev);
    struct cy_softc *sc = cy_cd.cd_devs[card];
    struct cy_port *cy = &sc->sc_ports[port];
    struct tty *tp = cy->cy_tty;
d565 2
a566 2
    printf("cy%d tty port %d tp 0x%x\n",
	   card, port, tp);
d569 1
a569 1
    return tp;
d577 5
a581 5
     dev_t dev;
     u_long cmd;
     caddr_t data;
     int flag;
     struct proc *p;
d583 71
a653 6
    int card = CY_CARD(dev);
    int port = CY_PORT(dev);
    struct cy_softc *sc = cy_cd.cd_devs[card];
    struct cy_port *cy = &sc->sc_ports[port];
    struct tty *tp = cy->cy_tty;
    int error;
d655 3
a657 12
#ifdef CY_DEBUG
    printf("cy%d port %d ioctl cmd 0x%x data 0x%x flag 0x%x\n",
	   card, port, cmd, data, flag);
#endif

    error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
    if(error >= 0)
      return error;

    error = ttioctl(tp, cmd, data, flag, p);
    if(error >= 0)
      return error;
d659 1
a659 57
/* XXX should not allow dropping DTR when dialin? */

    switch(cmd) {
      case TIOCSBRK: /* start break */
        SET(cy->cy_flags, CYF_START_BREAK);
	cy_enable_transmitter(cy);
        break;

      case TIOCCBRK: /* stop break */
	SET(cy->cy_flags, CYF_END_BREAK);
	cy_enable_transmitter(cy);
	break;

      case TIOCSDTR: /* DTR on */
	cy_modem_control(cy, TIOCM_DTR, DMBIS);
	break;

      case TIOCCDTR: /* DTR off */
	cy_modem_control(cy, TIOCM_DTR, DMBIC);
	break;

      case TIOCMSET: /* set new modem control line values */
	cy_modem_control(cy, *((int *)data), DMSET);
	break;

      case TIOCMBIS: /* turn modem control bits on */
	cy_modem_control(cy, *((int *)data), DMBIS);
	break;

      case TIOCMBIC: /* turn modem control bits off */
	cy_modem_control(cy, *((int *)data), DMBIC);
	break;

      case TIOCMGET: /* get modem control/status line state */
	*((int *)data) = cy_modem_control(cy, 0, DMGET);
	break;

      case TIOCGFLAGS:
	*((int *)data) = cy->cy_openflags |
	  (CY_DIALOUT(dev) ? TIOCFLAG_SOFTCAR : 0);
	break;

      case TIOCSFLAGS:
	error = suser(p->p_ucred, &p->p_acflag);
	if(error != 0)
	  return EPERM;

	cy->cy_openflags = *((int *)data) &
	  (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL |
	   TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF);
	break;

      default:
	return ENOTTY;
    }

    return 0;
d667 1
a667 1
     struct tty *tp;
d669 5
a673 5
    int card = CY_CARD(tp->t_dev);
    int port = CY_PORT(tp->t_dev);
    struct cy_softc *sc = cy_cd.cd_devs[card];
    struct cy_port *cy = &sc->sc_ports[port];
    int s;
d676 1
a676 1
    printf("cy%d port %d start, tty 0x%x\n", card, port, tp);
d679 1
a679 2

    s = spltty();
d682 1
a682 1
    cy->cy_start_count++;
d685 6
a690 6
  if(!ISSET(tp->t_state, TS_TTSTOP | TS_TIMEOUT | TS_BUSY)) {
      if(tp->t_outq.c_cc <= tp->t_lowat) {
	  if(ISSET(tp->t_state, TS_ASLEEP)) {
	      CLR(tp->t_state, TS_ASLEEP);
	      wakeup(&tp->t_outq);
	  }
d692 1
a692 1
	  selwakeup(&tp->t_wsel);
d694 3
a696 3
	  if(tp->t_outq.c_cc == 0)
	    goto out;
      }
d698 3
a700 3
      SET(tp->t_state, TS_BUSY);
      cy_enable_transmitter(cy);
  }
d703 1
a703 1
    splx(s);
d711 2
a712 2
     struct tty *tp;
     int flag;
d714 5
a718 5
    int card = CY_CARD(tp->t_dev);
    int port = CY_PORT(tp->t_dev);
    struct cy_softc *sc = cy_cd.cd_devs[card];
    struct cy_port *cy = &sc->sc_ports[port];
    int s;
d721 2
a722 2
    printf("cy%d port %d stop tty 0x%x flag 0x%x\n",
	   card, port, tp, flag);
d725 1
a725 1
    s = spltty();
d727 3
a729 3
    if(ISSET(tp->t_state, TS_BUSY)) {
	if(!ISSET(tp->t_state, TS_TTSTOP))
	  SET(tp->t_state, TS_FLUSH);
d731 8
a738 8
	/*
	 * the transmit interrupt routine will disable transmit when it
	 * notices that CYF_STOP has been set.
	 */
	SET(cy->cy_flags, CYF_STOP);
    }
    splx(s);
    return(0);
d747 2
a748 2
     struct tty *tp;
     struct termios *t;
d750 47
a796 64
    int card = CY_CARD(tp->t_dev);
    int port = CY_PORT(tp->t_dev);
    struct cy_softc *sc = cy_cd.cd_devs[card];
    struct cy_port *cy = &sc->sc_ports[port];
    int ibpr, obpr, i_clk_opt, o_clk_opt;
    int s, opt;

#ifdef CY_DEBUG
    printf("cy%d port %d param tty 0x%x termios 0x%x\n",
	   card, port, tp, t);
    printf("ispeed %d ospeed %d\n", t->c_ispeed, t->c_ospeed);
#endif

    if(t->c_ospeed != 0 && cy_speed(t->c_ospeed, &o_clk_opt, &obpr, cy->cy_clock) < 0)
      return EINVAL;

    if(t->c_ispeed != 0 && cy_speed(t->c_ispeed, &i_clk_opt, &ibpr, cy->cy_clock) < 0)
      return EINVAL;

    s = spltty();

    /* hang up the line is ospeed is zero, else turn DTR on */
    cy_modem_control(cy, TIOCM_DTR, (t->c_ospeed == 0 ? DMBIC : DMBIS));

    /* channel was selected by the above call to cy_modem_control() */
    /* cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN); */

    /* set transmit speed */
    if(t->c_ospeed != 0) {
	cd_write_reg(cy, CD1400_TCOR, o_clk_opt);
	cd_write_reg(cy, CD1400_TBPR, obpr);
    }
    /* set receive speed */
    if(t->c_ispeed != 0) {
	cd_write_reg(cy, CD1400_RCOR, i_clk_opt);
	cd_write_reg(cy, CD1400_RBPR, ibpr);
    }

    opt = CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN
      | (ISSET(t->c_cflag, CREAD) ? CD1400_CCR_RCVEN : CD1400_CCR_RCVDIS);

    if(opt != cy->cy_channel_control) {
	cy->cy_channel_control = opt;
	cd1400_channel_cmd(cy, opt);
    }

    /* compute COR1 contents */
    opt = 0;
    if(ISSET(t->c_cflag, PARENB)) {
	if(ISSET(t->c_cflag, PARODD))
	  opt |= CD1400_COR1_PARODD;
	opt |= CD1400_COR1_PARNORMAL;
    }

    if(!ISSET(t->c_iflag, INPCK))
      opt |= CD1400_COR1_NOINPCK; /* no parity checking */

    if(ISSET(t->c_cflag, CSTOPB))
      opt |= CD1400_COR1_STOP2;

    switch(t->c_cflag & CSIZE) {
      case CS5:
        opt |= CD1400_COR1_CS5;
        break;
d798 10
a807 3
      case CS6:
        opt |= CD1400_COR1_CS6;
	break;
d809 2
a810 3
      case CS7:
        opt |= CD1400_COR1_CS7;
	break;
d812 17
a828 4
      default:
        opt |= CD1400_COR1_CS8;
	break;
    }
d830 1
a830 1
    cd_write_reg(cy, CD1400_COR1, opt);
d833 1
a833 1
    printf("cor1 = 0x%x...", opt);
d836 26
a861 26
/*
 * use the CD1400 automatic CTS flow control if CRTSCTS is set
 *
 * CD1400_COR2_ETC is used because breaks are generated with
 * embedded transmit commands
 */
    cd_write_reg(cy, CD1400_COR2,
		 CD1400_COR2_ETC |
		 (ISSET(t->c_cflag, CRTSCTS) ? CD1400_COR2_CCTS_OFLOW : 0));

    cd_write_reg(cy, CD1400_COR3, RX_FIFO_THRESHOLD);

    cd1400_channel_cmd(cy,
		       CD1400_CCR_CMDCORCHG |
		       CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3);

    cd_write_reg(cy, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);
    cd_write_reg(cy, CD1400_COR5, 0);

  /*
   * set modem change option registers to generate interrupts
   * on carrier detect changes.
   *
   * if hardware RTS handshaking is used (CY_HW_RTS, DTR and RTS lines
   * exchanged), also set the handshaking threshold.
   */
d863 2
a864 2
    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd |
		 (ISSET(t->c_cflag, CRTSCTS) ? RX_DTR_THRESHOLD : 0));
d866 1
a866 1
    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd);
d869 1
a869 1
    cd_write_reg(cy, CD1400_MCOR2, CD1400_MCOR2_CDod);
d871 11
a881 11
    /*
     * set receive timeout to approx. 2ms
     * could use more complex logic here...
     * (but is it actually needed or even useful?)
     */
    cd_write_reg(cy, CD1400_RTPR, 2);

    /*
     * should do anything else here?
     * XXX check MDMBUF handshaking like in com.c?
     */
d883 2
a884 2
    splx(s);
    return 0;
d897 3
a899 3
     struct cy_port *cy;
     int bits;
     int howto;
d901 1
a901 1
    int s, msvr;
d903 1
a903 1
    s = spltty();
d905 2
a906 2
    /* select channel */
    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);
d909 6
a914 6
    switch(howto) {
      case DMGET:
	bits = 0;
	if(cy->cy_channel_control & CD1400_CCR_RCVEN)
	  bits |= TIOCM_LE;
	msvr = cd_read_reg(cy, CD1400_MSVR2);
d916 4
a919 4
	if(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)
	  bits |= TIOCM_DTR;
	if(msvr & CD1400_MSVR2_DTR)
	  bits |= TIOCM_RTS;
d921 4
a924 4
	if(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)
	  bits |= TIOCM_RTS;
	if(msvr & CD1400_MSVR2_DTR)
	  bits |= TIOCM_DTR;
d926 12
a937 10
	if(msvr & CD1400_MSVR2_CTS)
	  bits |= TIOCM_CTS;
	if(msvr & CD1400_MSVR2_CD)
	  bits |= TIOCM_CD;
	if(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */
	  bits |= TIOCM_DSR;
	if(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */
	  bits |= TIOCM_RI;
	splx(s);
	return bits;
d939 1
a939 1
      case DMSET: /* replace old values with new ones */
d941 5
a945 5
	if(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))
	  cd_write_reg(cy, CD1400_MSVR2,
		       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));
	cd_write_reg(cy, CD1400_MSVR1,
		     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));
d947 5
a951 5
	if(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))
	  cd_write_reg(cy, CD1400_MSVR1,
		  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));
	cd_write_reg(cy, CD1400_MSVR2,
		((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));
d953 1
a953 1
        break;
d955 1
a955 1
      case DMBIS: /* set bits */
d957 5
a961 5
	if(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
	   (bits & TIOCM_RTS) != 0)
	  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);
	if(bits & TIOCM_DTR)
	  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);
d963 5
a967 5
	if(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
	   (bits & TIOCM_RTS) != 0)
	  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);
	if(bits & TIOCM_DTR)
	  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);
d969 1
a969 1
	break;
d971 1
a971 1
      case DMBIC: /* clear bits */
d973 5
a977 5
	if(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
	   (bits & TIOCM_RTS))
	  cd_write_reg(cy, CD1400_MSVR2, 0);
	if(bits & TIOCM_DTR)
	  cd_write_reg(cy, CD1400_MSVR1, 0);
d979 5
a983 5
	if(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
	   (bits & TIOCM_RTS))
	  cd_write_reg(cy, CD1400_MSVR1, 0);
	if(bits & TIOCM_DTR)
	  cd_write_reg(cy, CD1400_MSVR2, 0);
d985 4
a988 4
	break;
    }
    splx(s);
    return 0;
d997 1
a997 1
     void *arg;
d999 5
a1003 5
    int card, port;
    struct cy_softc *sc;
    struct cy_port *cy;
    struct tty *tp;
    static int counter = 0;
d1005 1
a1005 1
    int did_something;
d1008 1
a1008 1
    int s;
d1010 1
a1010 1
    s = splhigh();
d1012 4
a1015 4
    if(cy_events == 0 && ++counter < 200) {
        splx(s);
	goto out;
    }
d1017 2
a1018 2
    cy_events = 0;
    splx(s);
d1020 4
a1023 4
    for(card = 0; card < cy_cd.cd_ndevs; card++) {
	sc = cy_cd.cd_devs[card];
	if(sc == NULL)
	  continue;
d1026 2
a1027 2
	sc->sc_poll_count1++;
	did_something = 0;
d1030 21
a1050 20
	for(port = 0; port < sc->sc_nports; port++) {
	    cy = &sc->sc_ports[port];
	    if((tp = cy->cy_tty) == NULL || cy->cy_ibuf == NULL ||
	       !ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN))
	    continue;

	    /*
	     * handle received data
	     */
	    while(cy->cy_ibuf_rd_ptr != cy->cy_ibuf_wr_ptr) {
	        u_char line_stat;
		int chr;

		line_stat = cy->cy_ibuf_rd_ptr[0];
		chr = cy->cy_ibuf_rd_ptr[1];

		if(line_stat & (CD1400_RDSR_BREAK|CD1400_RDSR_FE))
		  chr |= TTY_FE;
		if(line_stat & CD1400_RDSR_PE)
		  chr |= TTY_PE;
d1052 4
a1055 4
		/*
		 * on an overrun error the data is treated as good
		 * just as it should be.
		 */
d1058 2
a1059 2
		printf("cy%d port %d ttyinput 0x%x\n",
		       card, port, chr);
d1062 1
a1062 1
		(*linesw[tp->t_line].l_rint)(chr, tp);
d1064 5
a1068 4
                s = splhigh(); /* really necessary? */
		if((cy->cy_ibuf_rd_ptr += 2) == cy->cy_ibuf_end)
		  cy->cy_ibuf_rd_ptr = cy->cy_ibuf;
		splx(s);
d1071 1
a1071 1
		did_something = 1;
d1073 1
a1073 1
	    }
d1076 9
a1084 8
	    /* If we don't have any received data in ibuf and
	     * CRTSCTS is on and RTS is turned off, it is time
	     * to turn RTS back on
	     */
	    if(ISSET(tp->t_cflag, CRTSCTS)) {
	      /* we can't use cy_modem_control() here as it doesn't
		 change RTS if RTSCTS is on */
	      cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN);
d1086 4
a1089 2
	      if((cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS) == 0) {
		cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);
d1091 1
a1091 1
		did_something = 1;
d1093 2
a1094 2
	      }
	    }
d1097 21
a1117 20
	    /*
	     * handle carrier changes
	     */
	    s = splhigh();
	    if(ISSET(cy->cy_flags, CYF_CARRIER_CHANGED)) {
		int carrier;

		CLR(cy->cy_flags, CYF_CARRIER_CHANGED);
		splx(s);

		carrier = ((cy->cy_carrier_stat & CD1400_MSVR2_CD) != 0);

#ifdef CY_DEBUG
		printf("cy_poll: carrier change "
		       "(card %d, port %d, carrier %d)\n",
		       card, port, carrier);
#endif
		if(CY_DIALIN(tp->t_dev) &&
		   !(*linesw[tp->t_line].l_modem)(tp, carrier))
		  cy_modem_control(cy, TIOCM_DTR, DMBIC);
d1120 1
a1120 1
		did_something = 1;
d1122 3
a1124 3
	    } else {
		splx(s);
	    }
d1126 4
a1129 4
	    s = splhigh();
	    if(ISSET(cy->cy_flags, CYF_START)) {
		CLR(cy->cy_flags, CYF_START);
              splx(s);
d1131 1
a1131 1
		(*linesw[tp->t_line].l_start)(tp);
d1134 1
a1134 1
		did_something = 1;
d1136 18
a1153 18
	    } else {
                splx(s);
	    }

	    /* could move this to even upper level... */
	    if(cy->cy_fifo_overruns) {
		cy->cy_fifo_overruns = 0;
		/* doesn't report overrun count,
		   but shouldn't really matter */
		log(LOG_WARNING, "cy%d port %d fifo overrun\n",
		    card, port);
	    }
	    if(cy->cy_ibuf_overruns) {
		cy->cy_ibuf_overruns = 0;
		log(LOG_WARNING, "cy%d port %d ibuf overrun\n",
		    card, port);
	    }
	} /* for(port...) */
d1155 2
a1156 2
	if(did_something && counter >= 200)
	  sc->sc_poll_count2++;
d1158 1
a1158 1
    } /* for(card...) */
d1160 1
a1160 1
    counter = 0;
d1163 1
a1163 1
    timeout_add(&cy_poll_to, 1);
d1171 1
a1171 1
     void *arg;
d1173 5
a1177 5
    struct cy_softc *sc = arg;
    struct cy_port *cy;
    int card = sc->sc_dev.dv_unit;
    int cy_chip, stat;
    int int_serviced = 0;
d1179 5
a1183 5
/*
 * Check interrupt status of each CD1400 chip on this card
 * (multiple cards cannot share the same interrupt)
 */
    for(cy_chip = 0; cy_chip < cy_nr_cd1400s[card]; cy_chip++) {
d1185 13
a1197 13
	stat = cd_read_reg_sc(sc, cy_chip, CD1400_SVRR);
	if(stat == 0)
	  continue;

	if(ISSET(stat, CD1400_SVRR_RXRDY)) {
	    u_char save_car, save_rir, serv_type;
	    u_char line_stat, recv_data, n_chars;
	    u_char *buf_p;

	    save_rir = cd_read_reg_sc(sc, cy_chip, CD1400_RIR);
	    save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);
	    /* enter rx service */
	    cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_rir);
d1199 2
a1200 2
	    serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_RIVR);
	    cy = &sc->sc_ports[serv_type >> 3];
d1203 1
a1203 1
	    cy->cy_rx_int_count++;
d1206 52
a1257 3
	    if(cy->cy_tty == NULL ||
	       !ISSET(cy->cy_tty->t_state, TS_ISOPEN))
	      goto end_rx_serv;
d1259 1
a1259 1
	    buf_p = cy->cy_ibuf_wr_ptr;
d1261 8
a1268 3
	    if(ISSET(serv_type, CD1400_RIVR_EXCEPTION)) {
		line_stat = cd_read_reg(cy, CD1400_RDSR);
		recv_data = cd_read_reg(cy, CD1400_RDSR);
d1270 3
a1272 57
#ifdef CY_DEBUG
		printf("cy%d port %d recv exception, "
		       "line_stat 0x%x, char 0x%x\n",
		       card, cy->cy_port_num, line_stat, recv_data);
#endif
		if(ISSET(line_stat, CD1400_RDSR_OE))
		  cy->cy_fifo_overruns++;

		*buf_p++ = line_stat;
		*buf_p++ = recv_data;
		if(buf_p == cy->cy_ibuf_end)
		  buf_p = cy->cy_ibuf;

		if(buf_p == cy->cy_ibuf_rd_ptr) {
		    if(buf_p == cy->cy_ibuf)
		      buf_p = cy->cy_ibuf_end;
		    buf_p -= 2;
		    cy->cy_ibuf_overruns++;
		}
		cy_events = 1;
	    } else { /* no exception, received data OK */
		n_chars = cd_read_reg(cy, CD1400_RDCR);
#ifdef CY_DEBUG
		printf("cy%d port %d receive ok %d chars\n",
		       card, cy->cy_port_num, n_chars);
#endif
		while(n_chars--) {
		    *buf_p++ = 0; /* status: OK */
		    *buf_p++ =
		      cd_read_reg(cy, CD1400_RDSR); /* data byte */
		    if(buf_p == cy->cy_ibuf_end)
		      buf_p = cy->cy_ibuf;
		    if(buf_p == cy->cy_ibuf_rd_ptr) {
			if(buf_p == cy->cy_ibuf)
			  buf_p = cy->cy_ibuf_end;
			buf_p -= 2;
			cy->cy_ibuf_overruns++;
			break;
		    }
		}
		cy_events = 1;
	    }

	    cy->cy_ibuf_wr_ptr = buf_p;

#ifndef CY_HW_RTS
	    /* RTS handshaking for incoming data */
	    if(ISSET(cy->cy_tty->t_cflag, CRTSCTS)) {
		int bf;

		bf = buf_p - cy->cy_ibuf_rd_ptr;
		if(bf < 0)
		  bf += IBUF_SIZE;

		if(bf > (IBUF_SIZE/2))  /* turn RTS off */
		  cd_write_reg(cy, CD1400_MSVR1, 0);
	    }
d1275 14
a1288 14
end_rx_serv:
	    /* terminate service context */
	    cd_write_reg(cy, CD1400_RIR, save_rir & 0x3f);
	    cd_write_reg(cy, CD1400_CAR, save_car);
	    int_serviced = 1;
	} /* if(rx_service...) */

	if(ISSET(stat, CD1400_SVRR_MDMCH)) {
	    u_char save_car, save_mir, serv_type, modem_stat;

	    save_mir = cd_read_reg_sc(sc, cy_chip, CD1400_MIR);
	    save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);
	    /* enter modem service */
	    cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_mir);
d1290 2
a1291 2
	    serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_MIVR);
	    cy = &sc->sc_ports[serv_type >> 3];
d1294 1
a1294 1
	    cy->cy_modem_int_count++;
d1297 1
a1297 1
	    modem_stat = cd_read_reg(cy, CD1400_MSVR2);
d1300 2
a1301 2
	    printf("cy%d port %d modem line change, new stat 0x%x\n",
		   card, cy->cy_port_num, modem_stat);
d1303 5
a1307 6
	    if(ISSET((cy->cy_carrier_stat ^ modem_stat), CD1400_MSVR2_CD)) {
		SET(cy->cy_flags, CYF_CARRIER_CHANGED);
		cy_events = 1;
	    }

	    cy->cy_carrier_stat = modem_stat;
d1309 1
a1309 5
	  /* terminate service context */
	    cd_write_reg(cy, CD1400_MIR, save_mir & 0x3f);
	    cd_write_reg(cy, CD1400_CAR, save_car);
	    int_serviced = 1;
	} /* if(modem_service...) */
d1311 14
a1324 3
	if(ISSET(stat, CD1400_SVRR_TXRDY)) {
	    u_char save_car, save_tir, serv_type, count, ch;
	    struct tty *tp;
d1326 2
a1327 7
	    save_tir = cd_read_reg_sc(sc, cy_chip, CD1400_TIR);
	    save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);
	    /* enter tx service */
	    cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_tir);

	    serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_TIVR);
	    cy = &sc->sc_ports[serv_type >> 3];
d1330 1
a1330 1
	    cy->cy_tx_int_count++;
d1333 2
a1334 1
	    printf("cy%d port %d tx service\n", card, cy->cy_port_num);
d1337 4
a1340 4
	    /* stop transmitting if no tty or CYF_STOP set */
	    tp = cy->cy_tty;
	    if(tp == NULL || ISSET(cy->cy_flags, CYF_STOP))
	      goto txdone;
d1342 7
a1348 7
	    count = 0;
	    if(ISSET(cy->cy_flags, CYF_SEND_NUL)) {
		cd_write_reg(cy, CD1400_TDR, 0);
		cd_write_reg(cy, CD1400_TDR, 0);
		count += 2;
		CLR(cy->cy_flags, CYF_SEND_NUL);
	    }
d1350 38
a1387 10
	    if(tp->t_outq.c_cc > 0) {
		SET(tp->t_state, TS_BUSY);
		while(tp->t_outq.c_cc > 0 && count < CD1400_TX_FIFO_SIZE) {
		    ch = getc(&tp->t_outq);
		    /* remember to double NUL characters because
		       embedded transmit commands are enabled */
		    if(ch == 0) {
			if(count >= CD1400_TX_FIFO_SIZE-2) {
			    SET(cy->cy_flags, CYF_SEND_NUL);
			    break;
d1390 12
a1401 3
			cd_write_reg(cy, CD1400_TDR, ch);
			count++;
		    }
d1403 4
a1406 17
		    cd_write_reg(cy, CD1400_TDR, ch);
		    count++;
		}
	    } else {
		/* no data to send -- check if we should start/stop a break */
		/* XXX does this cause too much delay before breaks? */
		if(ISSET(cy->cy_flags, CYF_START_BREAK)) {
		    cd_write_reg(cy, CD1400_TDR, 0);
		    cd_write_reg(cy, CD1400_TDR, 0x81);
		    CLR(cy->cy_flags, CYF_START_BREAK);
		}
		if(ISSET(cy->cy_flags, CYF_END_BREAK)) {
		    cd_write_reg(cy, CD1400_TDR, 0);
		    cd_write_reg(cy, CD1400_TDR, 0x83);
		    CLR(cy->cy_flags, CYF_END_BREAK);
		}
	    }
d1408 11
a1418 29
	    if(tp->t_outq.c_cc == 0) {
txdone:
		/*
		 * No data to send or requested to stop.
		 * Disable transmit interrupt
		 */
		cd_write_reg(cy, CD1400_SRER,
			     cd_read_reg(cy, CD1400_SRER)
			     & ~CD1400_SRER_TXRDY);
		CLR(cy->cy_flags, CYF_STOP);
		CLR(tp->t_state, TS_BUSY);
	    }

	    if(tp->t_outq.c_cc <= tp->t_lowat) {
		SET(cy->cy_flags, CYF_START);
		cy_events = 1;
	    }

	    /* terminate service context */
	    cd_write_reg(cy, CD1400_TIR, save_tir & 0x3f);
	    cd_write_reg(cy, CD1400_CAR, save_car);
	    int_serviced = 1;
	} /* if(tx_service...) */
    } /* for(...all CD1400s on a card) */

    /* ensure an edge for next interrupt */
    bus_space_write_1(sc->sc_memt, sc->sc_memh,
		    CY_CLEAR_INTR<<sc->sc_bustype, 0);
    return int_serviced;
d1426 1
a1426 1
     struct cy_port *cy;
d1428 6
a1433 6
    int s;
    s = splhigh();
    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);
    cd_write_reg(cy, CD1400_SRER, cd_read_reg(cy, CD1400_SRER)
		 | CD1400_SRER_TXRDY);
    splx(s);
d1441 2
a1442 2
     struct cy_port *cy;
     int cmd;
d1444 1
a1444 1
    u_int waitcnt = 5 * 8 * 1024; /* approx 5 ms */
d1447 1
a1447 1
    printf("c1400_channel_cmd cy 0x%x command 0x%x\n", cy, cmd);
d1450 3
a1452 3
    /* wait until cd1400 is ready to process a new command */
    while(cd_read_reg(cy, CD1400_CCR) != 0 && waitcnt-- > 0)
      ;
d1454 2
a1455 2
    if(waitcnt == 0)
      log(LOG_ERR, "cy: channel command timeout\n");
d1457 1
a1457 1
    cd_write_reg(cy, CD1400_CCR, cmd);
d1471 1
a1471 1
    int c, co, br;
d1473 2
a1474 2
    if(speed < 50 || speed > 150000)
      return -1;
d1476 7
a1482 6
    for(c = 0, co = 8; co <= 2048; co <<= 2, c++) {
	br = (cy_clock + (co * speed) / 2) / (co * speed);
	if(br < 0x100) {
	    *bpr = br;
	    *cor = c;
	    return 0;
a1483 1
    }
d1485 1
a1485 1
    return -1;
@


1.12
log
@Repair timeouts. kern/1743, but with simpler fix
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.11 2001/02/03 06:33:37 mickey Exp $	*/
a910 1
        splx(s);
@


1.11
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.10 2000/12/10 11:12:00 deraadt Exp $	*/
d90 1
d228 2
a229 1
  timeout_set(&sc->sc_tmo, cy_poll, NULL);
d414 1
a414 1
	    timeout_add(&sc->sc_tmo, 1);
d1156 1
a1156 1
    timeout_add(&sc->sc_tmo, 1);
@


1.10
log
@support newer cy cards; elektrosatan@@voltagenoir.org, pr#1479
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.9 1999/11/30 23:54:07 aaron Exp $	*/
d227 1
d412 1
a412 1
	    timeout(cy_poll, NULL, 1);
d1154 1
a1154 1
    timeout(cy_poll, NULL, 1);
@


1.9
log
@Remove duplicate #include.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.8 1997/08/04 09:57:19 dgregor Exp $	*/
d78 1
a78 1
int	cy_speed __P((speed_t, int *, int *));
d205 1
a205 1
  int card, port, cy_chip, num_chips, cdu, chip_offs;
d246 6
d254 1
a254 1
		    (CY_CLOCK / CD1400_PPR_PRESCALER / 1000) + 1);
d262 1
d762 1
a762 1
    if(t->c_ospeed != 0 && cy_speed(t->c_ospeed, &o_clk_opt, &obpr) < 0)
d765 1
a765 1
    if(t->c_ispeed != 0 && cy_speed(t->c_ispeed, &i_clk_opt, &ibpr) < 0)
d1451 1
a1451 1
cy_speed(speed_t speed, int *cor, int *bpr)
d1459 1
a1459 1
	br = (CY_CLOCK + (co * speed) / 2) / (co * speed);
@


1.9.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.12 2001/03/25 11:54:00 art Exp $	*/
d78 1
a78 1
int	cy_speed __P((speed_t, int *, int *, int));
a89 1
struct timeout cy_poll_to;
d205 1
a205 1
  int card, port, cy_chip, num_chips, cdu, chip_offs, cy_clock;
a226 2
  if (!timeout_initialized(&cy_poll_to))
    timeout_set(&cy_poll_to, cy_poll, NULL);
a245 6
    /* Set cy_clock depending on firmware version */
    if (cd_read_reg_sc(sc, cy_chip, CD1400_GFRCR) <= 0x46)
        cy_clock = CY_CLOCK;
    else 
        cy_clock = CY_CLOCK_60;

d248 1
a248 1
		    (cy_clock / CD1400_PPR_PRESCALER / 1000) + 1);
a255 1
      sc->sc_ports[port].cy_clock = cy_clock;
d404 1
a404 1
	    timeout_add(&cy_poll_to, 1);
d755 1
a755 1
    if(t->c_ospeed != 0 && cy_speed(t->c_ospeed, &o_clk_opt, &obpr, cy->cy_clock) < 0)
d758 1
a758 1
    if(t->c_ispeed != 0 && cy_speed(t->c_ispeed, &i_clk_opt, &ibpr, cy->cy_clock) < 0)
d1146 1
a1146 1
    timeout_add(&cy_poll_to, 1);
d1444 1
a1444 1
cy_speed(speed_t speed, int *cor, int *bpr, int cy_clock)
d1452 1
a1452 1
	br = (cy_clock + (co * speed) / 2) / (co * speed);
@


1.9.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.9.2.1 2001/05/14 22:23:39 niklas Exp $	*/
d911 1
@


1.9.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.9.2.2 2001/07/04 10:40:47 niklas Exp $	*/
d25 3
d69 1
a69 1
void	cy_attach __P((struct device *, struct device *, void *));
d71 1
a71 1
int	cy_intr __P((void *));
d81 1
a81 1
	NULL, "cy", DV_TTY
d97 3
a99 3
	int card, bustype;
	bus_space_tag_t memt;
	bus_space_handle_t memh;
d101 2
a102 2
	int cy_chip, chip_offs;
	u_char firmware_ver;
d104 4
a107 4
	/* Cyclom card hardware reset */
	bus_space_write_1(memt, memh, CY16_RESET<<bustype, 0);
	DELAY(500); /* wait for reset to complete */
	bus_space_write_1(memt, memh, CY_CLEAR_INTR<<bustype, 0);
d110 1
a110 1
	printf("cy: card reset done\n");
d113 1
a113 1
	cy_nr_cd1400s[card] = 0;
d115 4
a118 4
	for (cy_chip = 0, chip_offs = 0;
	    cy_chip < CY_MAX_CD1400s;
	    cy_chip++, chip_offs += (CY_CD1400_MEMSPACING << bustype)) {
		int i;
d120 4
a123 4
		/* the last 4 cd1400s are 'interleaved'
		   with the first 4 on 32-port boards */
		if (cy_chip == 4)
			chip_offs -= (CY32_ADDR_FIX << bustype);
d126 2
a127 2
		printf("cy%d probe chip %d offset 0x%lx ... ",
		    card, cy_chip, chip_offs);
d130 4
a133 4
		/* wait until the chip is ready for command */
		DELAY(1000);
		if (bus_space_read_1(memt, memh, chip_offs +
		    ((CD1400_CCR << 1) << bustype)) != 0) {
d135 1
a135 1
			printf("not ready for command\n");
d137 2
a138 2
			break;
		}
d140 3
a142 3
		/* clear the firmware version reg. */
		bus_space_write_1(memt, memh, chip_offs +
		    ((CD1400_GFRCR << 1) << bustype), 0);
d144 10
a153 10
		/*
		 * On Cyclom-16 references to non-existent chip 4
		 * actually access chip 0 (address line 9 not decoded).
		 * Here we check if the clearing of chip 4 GFRCR actually
		 * cleared chip 0 GFRCR. In that case we have a 16 port card.
		 */
		if (cy_chip == 4 &&
		    bus_space_read_1(memt, memh, chip_offs +
			((CD1400_GFRCR << 1) << bustype)) == 0)
			break;
d155 3
a157 3
		/* reset the chip */
		bus_space_write_1(memt, memh, chip_offs +
		    ((CD1400_CCR << 1) << bustype),
d160 9
a168 8
		/* wait for the chip to initialize itself */
		for (i = 0; i < 200; i++) {
			DELAY(50);
			firmware_ver = bus_space_read_1(memt, memh, chip_offs +
			    ((CD1400_GFRCR << 1) << bustype));
			if ((firmware_ver & 0xf0) == 0x40) /* found a CD1400 */
				break;
		}
d170 1
a170 1
		printf("firmware version 0x%x\n", firmware_ver);
d173 2
a174 2
		if ((firmware_ver & 0xf0) != 0x40)
			break;
d176 3
a178 3
		/* firmware version OK, CD1400 found */
		cy_nr_cd1400s[card]++;
	}
d180 1
a180 1
	if (cy_nr_cd1400s[card] == 0) {
d182 1
a182 1
		printf("no CD1400s found\n");
d184 2
a185 2
		return (0);
	}
d188 1
a188 1
	printf("found %d CD1400s\n", cy_nr_cd1400s[card]);
d191 2
a192 2
	cy_card_memh[card] = memh;
	cy_bus_types[card] = bustype;
d194 1
a194 1
	return (1);
d197 3
d201 3
a203 3
cy_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d205 2
a206 2
	int card, port, cy_chip, num_chips, cdu, chip_offs, cy_clock;
	struct cy_softc *sc = (void *)self;
d208 8
a215 8
	card = sc->sc_dev.dv_unit;
	num_chips = cy_nr_cd1400s[card];
	if (num_chips == 0)
		return;

	sc->sc_bustype = cy_bus_types[card];
	sc->sc_memh = cy_card_memh[card];
	switch (sc->sc_bustype) {
d217 3
a219 3
	case CY_BUSTYPE_ISA:
		sc->sc_memt = ((struct isa_attach_args *)(aux))->ia_memt;
		break;
d222 3
a224 3
	case CY_BUSTYPE_PCI:
		sc->sc_memt = ((struct pci_attach_args *)aux)->pa_memt;
		break;
d226 1
a226 1
	}
d228 4
a231 26
	if (!timeout_initialized(&cy_poll_to))
		timeout_set(&cy_poll_to, cy_poll, NULL);
	bzero(sc->sc_ports, sizeof(sc->sc_ports));
	sc->sc_nports = num_chips * CD1400_NO_OF_CHANNELS;

	port = 0;
	for (cy_chip = 0, chip_offs = 0;
	    cy_chip < num_chips;
	    cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<sc->sc_bustype)) {
		if (cy_chip == 4)
			chip_offs -= (CY32_ADDR_FIX<<sc->sc_bustype);

#ifdef CY_DEBUG
		printf("attach CD1400 #%d offset 0x%x\n", cy_chip, chip_offs);
#endif
		sc->sc_cd1400_offs[cy_chip] = chip_offs;

		/* configure port 0 as serial port
		   (should already be after reset) */
		cd_write_reg_sc(sc, cy_chip, CD1400_GCR, 0);

		/* Set cy_clock depending on firmware version */
		if (cd_read_reg_sc(sc, cy_chip, CD1400_GFRCR) <= 0x46)
			cy_clock = CY_CLOCK;
		else 
			cy_clock = CY_CLOCK_60;
d233 4
a236 3
		/* set up a receive timeout period (1ms) */
		cd_write_reg_sc(sc, cy_chip, CD1400_PPR,
		    (cy_clock / CD1400_PPR_PRESCALER / 1000) + 1);
d238 2
a239 7
		for (cdu = 0; cdu < CD1400_NO_OF_CHANNELS; cdu++) {
			sc->sc_ports[port].cy_port_num = port;
			sc->sc_ports[port].cy_memt = sc->sc_memt;
			sc->sc_ports[port].cy_memh = sc->sc_memh;
			sc->sc_ports[port].cy_chip_offs = chip_offs;
			sc->sc_ports[port].cy_bustype = sc->sc_bustype;
			sc->sc_ports[port].cy_clock = cy_clock;
d241 4
a244 3
			/* should we initialize anything else here? */
			port++;
		} /* for(each port on one CD1400...) */
d246 2
a247 1
	} /* for(each CD1400 on a card... ) */
d249 9
a257 3
#if CY_DEBUG
	printf("cy: %d ports\n", port);
#endif
d259 19
a277 3
	/* ensure an edge for the next interrupt */
	bus_space_write_1(sc->sc_memt, sc->sc_memh,
	    CY_CLEAR_INTR<<sc->sc_bustype, 0);
d279 1
a279 1
	switch (sc->sc_bustype) {
d281 26
a306 3
	case CY_BUSTYPE_ISA:
	{
		struct isa_attach_args *ia = aux;
d308 3
a310 2
		sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq,
		    IST_EDGE, IPL_TTY, cy_intr, sc, sc->sc_dev.dv_xname);
d312 1
a312 9
		if (sc->sc_ih == NULL)
			panic("cy: couldn't establish interrupt");
	}
	break;
#endif /* NCY_ISA > 0 */
	case CY_BUSTYPE_PCI:
		break;
	}
}
d327 3
a329 3
	dev_t dev;
	int flag, mode;
	struct proc *p;
d331 27
a357 6
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc;
	struct cy_port *cy;
	struct tty *tp;
	int s, error;
d359 21
a379 4
#ifdef CY_DEBUG
	printf("cy%d open port %d flag 0x%x mode 0x%x\n",
	    card, port, flag, mode);
#endif
d381 1
a381 3
	if (card >= cy_cd.cd_ndevs ||
	    (sc = cy_cd.cd_devs[card]) == NULL)
		return (ENXIO);
d383 12
a394 10
	cy = &sc->sc_ports[port];

	s = spltty();
	if (cy->cy_tty == NULL) {
		if ((cy->cy_tty = ttymalloc()) == NULL) {
			splx(s);
			printf("cy%d port %d open: can't allocate tty\n",
			    card, port);
			return (ENOMEM);
		}
a395 1
	splx(s);
d397 2
a398 21
	tp = cy->cy_tty;
	tty_attach(tp);
	tp = cy->cy_tty;
	tp->t_oproc = cystart;
	tp->t_param = cyparam;
	tp->t_dev = dev;

	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_WOPEN);
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		if (ISSET(cy->cy_openflags, TIOCFLAG_CLOCAL))
			SET(tp->t_cflag, CLOCAL);
		if (ISSET(cy->cy_openflags, TIOCFLAG_CRTSCTS))
			SET(tp->t_cflag, CRTSCTS);
		if (ISSET(cy->cy_openflags, TIOCFLAG_MDMBUF))
			SET(tp->t_cflag, MDMBUF);
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
d400 43
a442 1
		s = spltty();
d444 11
a454 58
		/*
		 * Allocate input ring buffer if we don't already have one
		 */
		if (cy->cy_ibuf == NULL) {
			cy->cy_ibuf = malloc(IBUF_SIZE, M_DEVBUF, M_NOWAIT);
			if (cy->cy_ibuf == NULL) {
				printf("cy%d: (port %d) can't allocate input buffer\n",
				       card, port);
				splx(s);
				return (ENOMEM);
			}
			cy->cy_ibuf_end = cy->cy_ibuf + IBUF_SIZE;
		}

		/* mark the ring buffer as empty */
		cy->cy_ibuf_rd_ptr = cy->cy_ibuf_wr_ptr = cy->cy_ibuf;

		/* select CD1400 channel */
		cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN);
		/* reset the channel */
		cd1400_channel_cmd(cy, CD1400_CCR_CMDRESET);
		/* encode unit (port) number in LIVR */
		/* there is just enough space for 5 bits (32 ports) */
		cd_write_reg(cy, CD1400_LIVR, port << 3);

		cy->cy_channel_control = 0;

		/* hmm... need spltty() here? */
		if (cy_open == 0) {
			cy_open = 1;
			timeout_add(&cy_poll_to, 1);
		}

		/* this sets parameters and raises DTR */
		cyparam(tp, &tp->t_termios);

		ttsetwater(tp);

		/* raise RTS too */
		cy_modem_control(cy, TIOCM_RTS, DMBIS);

		cy->cy_carrier_stat = cd_read_reg(cy, CD1400_MSVR2);

		/* enable receiver and modem change interrupts */
		cd_write_reg(cy, CD1400_SRER,
		    CD1400_SRER_MDMCH | CD1400_SRER_RXDATA);

		if (CY_DIALOUT(dev) ||
		    ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR) ||
		    ISSET(tp->t_cflag, MDMBUF) ||
		    ISSET(cy->cy_carrier_stat, CD1400_MSVR2_CD))
			SET(tp->t_state, TS_CARR_ON);
		else
			CLR(tp->t_state, TS_CARR_ON);
	} else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {
		return (EBUSY);
	} else {
		s = spltty();
d456 1
d458 1
a458 14
	/* wait for carrier if necessary */
	if (!ISSET(flag, O_NONBLOCK)) {
		while (!ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON)) {
			SET(tp->t_state, TS_WOPEN);
			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
			    "cydcd", 0);
			if (error != 0) {
				splx(s);
				CLR(tp->t_state, TS_WOPEN);
				return (error);
			}
		}
	}
d460 1
a460 3
	splx(s);

	return (*linesw[tp->t_line].l_open)(dev, tp);
d468 3
a470 3
	dev_t dev;
	int flag, mode;
	struct proc *p;
d472 21
a492 6
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;
	int s;
d494 5
a498 4
#ifdef CY_DEBUG
	printf("cy%d close port %d, flag 0x%x, mode 0x%x\n",
	    card, port, flag, mode);
#endif
d500 2
a501 9
	(*linesw[tp->t_line].l_close)(tp, flag);
	s = spltty();

	if (ISSET(tp->t_cflag, HUPCL) &&
	    !ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR)) {
		/* drop DTR and RTS
		   (should we wait for output buffer to become empty first?) */
		cy_modem_control(cy, 0, DMSET);
	}
d503 1
a503 10
	/*
	 * XXX should we disable modem change and
	 * receive interrupts here or somewhere ?
	 */
	CLR(tp->t_state, TS_BUSY | TS_FLUSH);

	splx(s);
	ttyclose(tp);

	return (0);
d511 3
a513 3
	dev_t dev;
	struct uio *uio;
	int flag;
d515 5
a519 5
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;
d522 2
a523 2
	printf("cy%d read port %d uio 0x%x flag 0x%x\n",
	    card, port, uio, flag);
d526 1
a526 1
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d534 3
a536 3
	dev_t dev;
	struct uio *uio;
	int flag;
d538 5
a542 5
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;
d545 2
a546 2
	printf("cy%d write port %d uio 0x%x flag 0x%x\n",
	    card, port, uio, flag);
d549 1
a549 1
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d557 1
a557 1
	dev_t dev;
d559 5
a563 5
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;
d566 2
a567 2
	printf("cy%d tty port %d tp 0x%x\n",
	    card, port, tp);
d570 1
a570 1
	return (tp);
d578 5
a582 5
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d584 19
a602 71
	int card = CY_CARD(dev);
	int port = CY_PORT(dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	struct tty *tp = cy->cy_tty;
	int error;

#ifdef CY_DEBUG
	printf("cy%d port %d ioctl cmd 0x%x data 0x%x flag 0x%x\n",
	    card, port, cmd, data, flag);
#endif

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	/* XXX should not allow dropping DTR when dialin? */

	switch (cmd) {
	case TIOCSBRK:		/* start break */
		SET(cy->cy_flags, CYF_START_BREAK);
		cy_enable_transmitter(cy);
		break;

	case TIOCCBRK:		/* stop break */
		SET(cy->cy_flags, CYF_END_BREAK);
		cy_enable_transmitter(cy);
		break;

	case TIOCSDTR:		/* DTR on */
		cy_modem_control(cy, TIOCM_DTR, DMBIS);
		break;

	case TIOCCDTR:		/* DTR off */
		cy_modem_control(cy, TIOCM_DTR, DMBIC);
		break;

	case TIOCMSET:		/* set new modem control line values */
		cy_modem_control(cy, *((int *)data), DMSET);
		break;

	case TIOCMBIS:		/* turn modem control bits on */
		cy_modem_control(cy, *((int *)data), DMBIS);
		break;

	case TIOCMBIC:		/* turn modem control bits off */
		cy_modem_control(cy, *((int *)data), DMBIC);
		break;

	case TIOCMGET:		/* get modem control/status line state */
		*((int *)data) = cy_modem_control(cy, 0, DMGET);
		break;

	case TIOCGFLAGS:
		*((int *)data) = cy->cy_openflags |
		    (CY_DIALOUT(dev) ? TIOCFLAG_SOFTCAR : 0);
		break;

	case TIOCSFLAGS:
		error = suser(p->p_ucred, &p->p_acflag);
		if (error != 0)
			return (EPERM);

		cy->cy_openflags = *((int *)data) &
		    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL |
		     TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF);
		break;
d604 55
a658 3
	default:
		return (ENOTTY);
	}
d660 1
a660 1
	return (0);
d668 1
a668 1
	struct tty *tp;
d670 5
a674 5
	int card = CY_CARD(tp->t_dev);
	int port = CY_PORT(tp->t_dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	int s;
d677 1
a677 1
	printf("cy%d port %d start, tty 0x%x\n", card, port, tp);
d680 2
a681 1
	s = spltty();
d684 1
a684 1
	cy->cy_start_count++;
d687 6
a692 6
	if (!ISSET(tp->t_state, TS_TTSTOP | TS_TIMEOUT | TS_BUSY)) {
		if (tp->t_outq.c_cc <= tp->t_lowat) {
			if (ISSET(tp->t_state, TS_ASLEEP)) {
				CLR(tp->t_state, TS_ASLEEP);
				wakeup(&tp->t_outq);
			}
d694 1
a694 1
			selwakeup(&tp->t_wsel);
d696 3
a698 3
			if (tp->t_outq.c_cc == 0)
				goto out;
		}
d700 3
a702 3
		SET(tp->t_state, TS_BUSY);
		cy_enable_transmitter(cy);
	}
d705 1
a705 1
	splx(s);
d713 2
a714 2
	struct tty *tp;
	int flag;
d716 5
a720 5
	int card = CY_CARD(tp->t_dev);
	int port = CY_PORT(tp->t_dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	int s;
d723 2
a724 2
	printf("cy%d port %d stop tty 0x%x flag 0x%x\n",
	    card, port, tp, flag);
d727 1
a727 1
	s = spltty();
d729 3
a731 3
	if (ISSET(tp->t_state, TS_BUSY)) {
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);
d733 8
a740 8
		/*
		 * the transmit interrupt routine will disable transmit when it
		 * notices that CYF_STOP has been set.
		 */
		SET(cy->cy_flags, CYF_STOP);
	}
	splx(s);
	return (0);
d749 2
a750 2
	struct tty *tp;
	struct termios *t;
d752 64
a815 20
	int card = CY_CARD(tp->t_dev);
	int port = CY_PORT(tp->t_dev);
	struct cy_softc *sc = cy_cd.cd_devs[card];
	struct cy_port *cy = &sc->sc_ports[port];
	int ibpr, obpr, i_clk_opt, o_clk_opt;
	int s, opt;

#ifdef CY_DEBUG
	printf("cy%d port %d param tty 0x%x termios 0x%x\n",
	    card, port, tp, t);
	printf("ispeed %d ospeed %d\n", t->c_ispeed, t->c_ospeed);
#endif

	if (t->c_ospeed != 0 &&
	    cy_speed(t->c_ospeed, &o_clk_opt, &obpr, cy->cy_clock) < 0)
		return (EINVAL);

	if (t->c_ispeed != 0 &&
	    cy_speed(t->c_ispeed, &i_clk_opt, &ibpr, cy->cy_clock) < 0)
		return (EINVAL);
d817 3
a819 1
	s = spltty();
d821 3
a823 2
	/* hang up the line is ospeed is zero, else turn DTR on */
	cy_modem_control(cy, TIOCM_DTR, (t->c_ospeed == 0 ? DMBIC : DMBIS));
d825 4
a828 2
	/* channel was selected by the above call to cy_modem_control() */
	/* cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN); */
d830 1
a830 52
	/* set transmit speed */
	if (t->c_ospeed != 0) {
		cd_write_reg(cy, CD1400_TCOR, o_clk_opt);
		cd_write_reg(cy, CD1400_TBPR, obpr);
	}
	/* set receive speed */
	if (t->c_ispeed != 0) {
		cd_write_reg(cy, CD1400_RCOR, i_clk_opt);
		cd_write_reg(cy, CD1400_RBPR, ibpr);
	}

	opt = CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN
	    | (ISSET(t->c_cflag, CREAD) ? CD1400_CCR_RCVEN : CD1400_CCR_RCVDIS);

	if (opt != cy->cy_channel_control) {
		cy->cy_channel_control = opt;
		cd1400_channel_cmd(cy, opt);
	}

	/* compute COR1 contents */
	opt = 0;
	if (ISSET(t->c_cflag, PARENB)) {
		if (ISSET(t->c_cflag, PARODD))
			opt |= CD1400_COR1_PARODD;
		opt |= CD1400_COR1_PARNORMAL;
	}

	if (!ISSET(t->c_iflag, INPCK))
		opt |= CD1400_COR1_NOINPCK;	/* no parity checking */

	if (ISSET(t->c_cflag, CSTOPB))
		opt |= CD1400_COR1_STOP2;

	switch (t->c_cflag & CSIZE) {
	case CS5:
		opt |= CD1400_COR1_CS5;
		break;

	case CS6:
		opt |= CD1400_COR1_CS6;
		break;

	case CS7:
		opt |= CD1400_COR1_CS7;
		break;

	default:
		opt |= CD1400_COR1_CS8;
		break;
	}

	cd_write_reg(cy, CD1400_COR1, opt);
d833 1
a833 1
	printf("cor1 = 0x%x...", opt);
d836 26
a861 26
	/*
	 * use the CD1400 automatic CTS flow control if CRTSCTS is set
	 *
	 * CD1400_COR2_ETC is used because breaks are generated with
	 * embedded transmit commands
	 */
	cd_write_reg(cy, CD1400_COR2,
	    CD1400_COR2_ETC |
	    (ISSET(t->c_cflag, CRTSCTS) ? CD1400_COR2_CCTS_OFLOW : 0));

	cd_write_reg(cy, CD1400_COR3, RX_FIFO_THRESHOLD);

	cd1400_channel_cmd(cy,
	    CD1400_CCR_CMDCORCHG |
	    CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3);

	cd_write_reg(cy, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);
	cd_write_reg(cy, CD1400_COR5, 0);

	/*
	 * set modem change option registers to generate interrupts
	 * on carrier detect changes.
	 *
	 * if hardware RTS handshaking is used (CY_HW_RTS, DTR and RTS lines
	 * exchanged), also set the handshaking threshold.
	 */
d863 2
a864 2
	cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd |
	    (ISSET(t->c_cflag, CRTSCTS) ? RX_DTR_THRESHOLD : 0));
d866 1
a866 1
	cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd);
d869 1
a869 8
	cd_write_reg(cy, CD1400_MCOR2, CD1400_MCOR2_CDod);

	/*
	 * set receive timeout to approx. 2ms
	 * could use more complex logic here...
	 * (but is it actually needed or even useful?)
	 */
	cd_write_reg(cy, CD1400_RTPR, 2);
d871 11
a881 4
	/*
	 * should do anything else here?
	 * XXX check MDMBUF handshaking like in com.c?
	 */
d883 2
a884 2
	splx(s);
	return (0);
d897 3
a899 3
	struct cy_port *cy;
	int bits;
	int howto;
d901 1
a901 1
	int s, msvr;
d903 1
a903 1
	s = spltty();
d905 2
a906 2
	/* select channel */
	cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);
d909 6
a914 6
	switch (howto) {
	case DMGET:
		bits = 0;
		if (cy->cy_channel_control & CD1400_CCR_RCVEN)
			bits |= TIOCM_LE;
		msvr = cd_read_reg(cy, CD1400_MSVR2);
d916 4
a919 4
		if (cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)
			bits |= TIOCM_DTR;
		if (msvr & CD1400_MSVR2_DTR)
			bits |= TIOCM_RTS;
d921 4
a924 4
		if (cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)
			bits |= TIOCM_RTS;
		if (msvr & CD1400_MSVR2_DTR)
			bits |= TIOCM_DTR;
d926 10
a935 12
		if (msvr & CD1400_MSVR2_CTS)
			bits |= TIOCM_CTS;
		if (msvr & CD1400_MSVR2_CD)
			bits |= TIOCM_CD;
		if (msvr & CD1400_MSVR2_DSR)	/* not connected on some
						   Cyclom cards? */
			bits |= TIOCM_DSR;
		if (msvr & CD1400_MSVR2_RI)	/* not connected on
						   Cyclom-8Y cards? */
			bits |= TIOCM_RI;
		splx(s);
		return (bits);
d937 1
a937 1
	case DMSET: /* replace old values with new ones */
d939 5
a943 5
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS))
			cd_write_reg(cy, CD1400_MSVR2,
			    ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));
		cd_write_reg(cy, CD1400_MSVR1,
		    ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));
d945 5
a949 5
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS))
			cd_write_reg(cy, CD1400_MSVR1,
			    ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));
		cd_write_reg(cy, CD1400_MSVR2,
		    ((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));
d951 1
a951 1
		break;
d953 1
a953 1
	case DMBIS: /* set bits */
d955 5
a959 5
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
		    (bits & TIOCM_RTS) != 0)
			cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);
		if (bits & TIOCM_DTR)
			cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);
d961 5
a965 5
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
		    (bits & TIOCM_RTS) != 0)
			cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);
		if (bits & TIOCM_DTR)
			cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);
d967 1
a967 1
		break;
d969 1
a969 1
	case DMBIC: /* clear bits */
d971 5
a975 5
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
		    (bits & TIOCM_RTS))
			cd_write_reg(cy, CD1400_MSVR2, 0);
		if (bits & TIOCM_DTR)
			cd_write_reg(cy, CD1400_MSVR1, 0);
d977 5
a981 5
		if (!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&
		    (bits & TIOCM_RTS))
			cd_write_reg(cy, CD1400_MSVR1, 0);
		if (bits & TIOCM_DTR)
			cd_write_reg(cy, CD1400_MSVR2, 0);
d983 4
a986 4
		break;
	}
	splx(s);
	return (0);
d995 1
a995 1
	void *arg;
d997 5
a1001 5
	int card, port;
	struct cy_softc *sc;
	struct cy_port *cy;
	struct tty *tp;
	static int counter = 0;
d1003 1
a1003 1
	int did_something;
d1006 1
a1006 1
	int s;
d1008 1
a1008 1
	s = splhigh();
d1010 4
a1013 4
	if (cy_events == 0 && ++counter < 200) {
		splx(s);
		goto out;
	}
d1015 2
a1016 2
	cy_events = 0;
	splx(s);
d1018 4
a1021 4
	for (card = 0; card < cy_cd.cd_ndevs; card++) {
		sc = cy_cd.cd_devs[card];
		if (sc == NULL)
			continue;
d1024 2
a1025 2
		sc->sc_poll_count1++;
		did_something = 0;
d1028 20
a1047 5
		for (port = 0; port < sc->sc_nports; port++) {
			cy = &sc->sc_ports[port];
			if ((tp = cy->cy_tty) == NULL || cy->cy_ibuf == NULL ||
			    !ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN))
				continue;
d1049 4
a1052 20
			/*
			 * handle received data
			 */
			while (cy->cy_ibuf_rd_ptr != cy->cy_ibuf_wr_ptr) {
				u_char line_stat;
				int chr;

				line_stat = cy->cy_ibuf_rd_ptr[0];
				chr = cy->cy_ibuf_rd_ptr[1];

				if (line_stat &
				    (CD1400_RDSR_BREAK|CD1400_RDSR_FE))
					chr |= TTY_FE;
				if (line_stat & CD1400_RDSR_PE)
					chr |= TTY_PE;

				/*
				 * on an overrun error the data is treated as
				 * good just as it should be.
				 */
d1055 2
a1056 2
				printf("cy%d port %d ttyinput 0x%x\n",
				    card, port, chr);
d1059 1
a1059 1
				(*linesw[tp->t_line].l_rint)(chr, tp);
d1061 4
a1064 5
				s = splhigh(); /* really necessary? */
				if ((cy->cy_ibuf_rd_ptr += 2) ==
				    cy->cy_ibuf_end)
					cy->cy_ibuf_rd_ptr = cy->cy_ibuf;
				splx(s);
d1067 1
a1067 1
				did_something = 1;
d1069 1
a1069 1
			}
d1072 8
a1079 9
			/* If we don't have any received data in ibuf and
			 * CRTSCTS is on and RTS is turned off, it is time
			 * to turn RTS back on
			 */
			if (ISSET(tp->t_cflag, CRTSCTS)) {
				/* we can't use cy_modem_control() here as it
				    doesn't change RTS if RTSCTS is on */
				cd_write_reg(cy, CD1400_CAR,
				    port & CD1400_CAR_CHAN);
d1081 2
a1082 4
				if ((cd_read_reg(cy,
				    CD1400_MSVR1) & CD1400_MSVR1_RTS) == 0) {
					cd_write_reg(cy, CD1400_MSVR1,
					    CD1400_MSVR1_RTS);
d1084 1
a1084 1
					did_something = 1;
d1086 2
a1087 2
				}
			}
d1090 20
a1109 21
			/*
			 * handle carrier changes
			 */
			s = splhigh();
			if (ISSET(cy->cy_flags, CYF_CARRIER_CHANGED)) {
				int carrier;

				CLR(cy->cy_flags, CYF_CARRIER_CHANGED);
				splx(s);

				carrier = ((cy->cy_carrier_stat &
				    CD1400_MSVR2_CD) != 0);

#ifdef CY_DEBUG
				printf("cy_poll: carrier change "
				    "(card %d, port %d, carrier %d)\n",
				    card, port, carrier);
#endif
				if (CY_DIALIN(tp->t_dev) &&
				    !(*linesw[tp->t_line].l_modem)(tp, carrier))
					cy_modem_control(cy, TIOCM_DTR, DMBIC);
d1112 1
a1112 1
				did_something = 1;
d1114 3
a1116 3
			} else {
				splx(s);
			}
d1118 4
a1121 4
			s = splhigh();
			if (ISSET(cy->cy_flags, CYF_START)) {
				CLR(cy->cy_flags, CYF_START);
				splx(s);
d1123 1
a1123 1
				(*linesw[tp->t_line].l_start)(tp);
d1126 1
a1126 1
				did_something = 1;
d1128 18
a1145 18
			} else {
				splx(s);
			}

			/* could move this to even upper level... */
			if (cy->cy_fifo_overruns) {
				cy->cy_fifo_overruns = 0;
				/* doesn't report overrun count,
				   but shouldn't really matter */
				log(LOG_WARNING, "cy%d port %d fifo overrun\n",
				    card, port);
			}
			if (cy->cy_ibuf_overruns) {
				cy->cy_ibuf_overruns = 0;
				log(LOG_WARNING, "cy%d port %d ibuf overrun\n",
				    card, port);
			}
		} /* for(port...) */
d1147 2
a1148 2
		if (did_something && counter >= 200)
			sc->sc_poll_count2++;
d1150 1
a1150 1
	} /* for(card...) */
d1152 1
a1152 1
	counter = 0;
d1155 1
a1155 1
	timeout_add(&cy_poll_to, 1);
d1162 2
a1163 2
cy_intr(arg)
	void *arg;
d1165 5
a1169 5
	struct cy_softc *sc = arg;
	struct cy_port *cy;
	int card = sc->sc_dev.dv_unit;
	int cy_chip, stat;
	int int_serviced = 0;
d1171 5
a1175 5
	/*
	 * Check interrupt status of each CD1400 chip on this card
	 * (multiple cards cannot share the same interrupt)
	 */
	for (cy_chip = 0; cy_chip < cy_nr_cd1400s[card]; cy_chip++) {
d1177 13
a1189 13
		stat = cd_read_reg_sc(sc, cy_chip, CD1400_SVRR);
		if (stat == 0)
			continue;

		if (ISSET(stat, CD1400_SVRR_RXRDY)) {
			u_char save_car, save_rir, serv_type;
			u_char line_stat, recv_data, n_chars;
			u_char *buf_p;

			save_rir = cd_read_reg_sc(sc, cy_chip, CD1400_RIR);
			save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);
			/* enter rx service */
			cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_rir);
d1191 2
a1192 2
			serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_RIVR);
			cy = &sc->sc_ports[serv_type >> 3];
d1195 17
a1211 1
			cy->cy_rx_int_count++;
d1213 2
d1216 34
a1249 52
			if (cy->cy_tty == NULL ||
			    !ISSET(cy->cy_tty->t_state, TS_ISOPEN))
				goto end_rx_serv;

			buf_p = cy->cy_ibuf_wr_ptr;

			if (ISSET(serv_type, CD1400_RIVR_EXCEPTION)) {
				line_stat = cd_read_reg(cy, CD1400_RDSR);
				recv_data = cd_read_reg(cy, CD1400_RDSR);

#ifdef CY_DEBUG
				printf("cy%d port %d recv exception, "
				    "line_stat 0x%x, char 0x%x\n",
				    card, cy->cy_port_num, line_stat, recv_data);
#endif
				if (ISSET(line_stat, CD1400_RDSR_OE))
					cy->cy_fifo_overruns++;

				*buf_p++ = line_stat;
				*buf_p++ = recv_data;
				if (buf_p == cy->cy_ibuf_end)
					buf_p = cy->cy_ibuf;

				if (buf_p == cy->cy_ibuf_rd_ptr) {
					if (buf_p == cy->cy_ibuf)
						buf_p = cy->cy_ibuf_end;
					buf_p -= 2;
					cy->cy_ibuf_overruns++;
				}
				cy_events = 1;
			} else { /* no exception, received data OK */
				n_chars = cd_read_reg(cy, CD1400_RDCR);
#ifdef CY_DEBUG
				printf("cy%d port %d receive ok %d chars\n",
				    card, cy->cy_port_num, n_chars);
#endif
				while (n_chars--) {
					*buf_p++ = 0; /* status: OK */
					*buf_p++ = cd_read_reg(cy,
					    CD1400_RDSR); /* data byte */
					if (buf_p == cy->cy_ibuf_end)
						buf_p = cy->cy_ibuf;
					if (buf_p == cy->cy_ibuf_rd_ptr) {
						if (buf_p == cy->cy_ibuf)
							buf_p = cy->cy_ibuf_end;
						buf_p -= 2;
						cy->cy_ibuf_overruns++;
						break;
					}
				}
				cy_events = 1;
			}
d1251 1
a1251 1
			cy->cy_ibuf_wr_ptr = buf_p;
d1254 11
a1264 11
			/* RTS handshaking for incoming data */
			if (ISSET(cy->cy_tty->t_cflag, CRTSCTS)) {
				int bf;

				bf = buf_p - cy->cy_ibuf_rd_ptr;
				if (bf < 0)
					bf += IBUF_SIZE;

				if (bf > (IBUF_SIZE/2))	/* turn RTS off */
					cd_write_reg(cy, CD1400_MSVR1, 0);
			}
d1267 14
a1280 14
		end_rx_serv:
			/* terminate service context */
			cd_write_reg(cy, CD1400_RIR, save_rir & 0x3f);
			cd_write_reg(cy, CD1400_CAR, save_car);
			int_serviced = 1;
		} /* if(rx_service...) */

		if (ISSET(stat, CD1400_SVRR_MDMCH)) {
			u_char save_car, save_mir, serv_type, modem_stat;

			save_mir = cd_read_reg_sc(sc, cy_chip, CD1400_MIR);
			save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);
			/* enter modem service */
			cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_mir);
d1282 2
a1283 2
			serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_MIVR);
			cy = &sc->sc_ports[serv_type >> 3];
d1286 1
a1286 1
			cy->cy_modem_int_count++;
d1289 1
a1289 1
			modem_stat = cd_read_reg(cy, CD1400_MSVR2);
d1292 2
a1293 2
			printf("cy%d port %d modem line change, new stat 0x%x\n",
			    card, cy->cy_port_num, modem_stat);
d1295 12
a1306 5
			if (ISSET((cy->cy_carrier_stat ^ modem_stat),
			    CD1400_MSVR2_CD)) {
				SET(cy->cy_flags, CYF_CARRIER_CHANGED);
				cy_events = 1;
			}
d1308 3
a1310 1
			cy->cy_carrier_stat = modem_stat;
d1312 4
a1315 14
			/* terminate service context */
			cd_write_reg(cy, CD1400_MIR, save_mir & 0x3f);
			cd_write_reg(cy, CD1400_CAR, save_car);
			int_serviced = 1;
		} /* if(modem_service...) */

		if (ISSET(stat, CD1400_SVRR_TXRDY)) {
			u_char save_car, save_tir, serv_type, count, ch;
			struct tty *tp;

			save_tir = cd_read_reg_sc(sc, cy_chip, CD1400_TIR);
			save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);
			/* enter tx service */
			cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_tir);
d1317 2
a1318 2
			serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_TIVR);
			cy = &sc->sc_ports[serv_type >> 3];
d1321 1
a1321 1
			cy->cy_tx_int_count++;
d1324 1
a1324 2
			printf("cy%d port %d tx service\n",
			    card, cy->cy_port_num);
d1327 4
a1330 4
			/* stop transmitting if no tty or CYF_STOP set */
			tp = cy->cy_tty;
			if (tp == NULL || ISSET(cy->cy_flags, CYF_STOP))
				goto txdone;
d1332 7
a1338 7
			count = 0;
			if (ISSET(cy->cy_flags, CYF_SEND_NUL)) {
				cd_write_reg(cy, CD1400_TDR, 0);
				cd_write_reg(cy, CD1400_TDR, 0);
				count += 2;
				CLR(cy->cy_flags, CYF_SEND_NUL);
			}
d1340 10
a1349 38
			if (tp->t_outq.c_cc > 0) {
				SET(tp->t_state, TS_BUSY);
				while (tp->t_outq.c_cc > 0 &&
				    count < CD1400_TX_FIFO_SIZE) {
					ch = getc(&tp->t_outq);
					/* remember to double NUL characters
					   because embedded transmit commands
					   are enabled */
					if (ch == 0) {
						if (count >=
						    CD1400_TX_FIFO_SIZE-2) {
							SET(cy->cy_flags,
							    CYF_SEND_NUL);
							break;
						}

						cd_write_reg(cy, CD1400_TDR, ch);
						count++;
					}

					cd_write_reg(cy, CD1400_TDR, ch);
					count++;
				}
			} else {
				/* no data to send -- check if we should
				   start/stop a break */
				/* XXX does this cause too much delay before
				   breaks? */
				if (ISSET(cy->cy_flags, CYF_START_BREAK)) {
					cd_write_reg(cy, CD1400_TDR, 0);
					cd_write_reg(cy, CD1400_TDR, 0x81);
					CLR(cy->cy_flags, CYF_START_BREAK);
				}
				if (ISSET(cy->cy_flags, CYF_END_BREAK)) {
					cd_write_reg(cy, CD1400_TDR, 0);
					cd_write_reg(cy, CD1400_TDR, 0x83);
					CLR(cy->cy_flags, CYF_END_BREAK);
				}
d1352 3
a1354 12
			if (tp->t_outq.c_cc == 0) {
txdone:
				/*
				 * No data to send or requested to stop.
				 * Disable transmit interrupt
				 */
				cd_write_reg(cy, CD1400_SRER,
				    cd_read_reg(cy, CD1400_SRER)
				    & ~CD1400_SRER_TXRDY);
				CLR(cy->cy_flags, CYF_STOP);
				CLR(tp->t_state, TS_BUSY);
			}
d1356 17
a1372 4
			if (tp->t_outq.c_cc <= tp->t_lowat) {
				SET(cy->cy_flags, CYF_START);
				cy_events = 1;
			}
d1374 29
a1402 11
			/* terminate service context */
			cd_write_reg(cy, CD1400_TIR, save_tir & 0x3f);
			cd_write_reg(cy, CD1400_CAR, save_car);
			int_serviced = 1;
		} /* if(tx_service...) */
	} /* for(...all CD1400s on a card) */

	/* ensure an edge for next interrupt */
	bus_space_write_1(sc->sc_memt, sc->sc_memh,
	    CY_CLEAR_INTR<<sc->sc_bustype, 0);
	return (int_serviced);
d1410 1
a1410 1
	struct cy_port *cy;
d1412 6
a1417 6
	int s;
	s = splhigh();
	cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);
	cd_write_reg(cy, CD1400_SRER, cd_read_reg(cy, CD1400_SRER)
	    | CD1400_SRER_TXRDY);
	splx(s);
d1425 2
a1426 2
	struct cy_port *cy;
	int cmd;
d1428 1
a1428 1
	u_int waitcnt = 5 * 8 * 1024; /* approx 5 ms */
d1431 1
a1431 1
	printf("c1400_channel_cmd cy 0x%x command 0x%x\n", cy, cmd);
d1434 3
a1436 3
	/* wait until cd1400 is ready to process a new command */
	while (cd_read_reg(cy, CD1400_CCR) != 0 && waitcnt-- > 0)
		;
d1438 2
a1439 2
	if (waitcnt == 0)
		log(LOG_ERR, "cy: channel command timeout\n");
d1441 1
a1441 1
	cd_write_reg(cy, CD1400_CCR, cmd);
d1455 1
a1455 1
	int c, co, br;
d1457 2
a1458 2
	if (speed < 50 || speed > 150000)
		return (-1);
d1460 6
a1465 7
	for (c = 0, co = 8; co <= 2048; co <<= 2, c++) {
		br = (cy_clock + (co * speed) / 2) / (co * speed);
		if (br < 0x100) {
			*bpr = br;
			*cor = c;
			return (0);
		}
d1467 1
d1469 1
a1469 1
	return (-1);
@


1.9.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 6
@


1.9.2.5
log
@Merge in -current from about a week ago
@
text
@d60 10
a69 10
void	cy_attach(struct device *, struct device *, void *);
int	cy_probe_common(int, bus_space_tag_t, bus_space_handle_t, int);
int	cy_intr(void *);
int	cyparam(struct tty *, struct termios *);
void	cystart(struct tty *);
void	cy_poll(void *);
int	cy_modem_control(struct cy_port *, int, int);
void	cy_enable_transmitter(struct cy_port *);
void	cd1400_channel_cmd(struct cy_port *, int);
int	cy_speed(speed_t, int *, int *, int);
d290 7
a296 7
int cyopen(dev_t, int, int, struct proc *);
int cyclose(dev_t, int, int, struct proc *);
int cyread(dev_t, struct uio *, int);
int cywrite(dev_t, struct uio *, int);
struct tty *cytty(dev_t);
int cyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int cystop(struct tty *, int flag);
@


1.9.2.6
log
@Sync the SMP branch with 3.3
@
text
@a1 28
/*
 * Copyright (c) 1996 Timo Rossi.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
d60 2
d75 8
a84 2
 *
 * returns the number of chips found.
d87 4
a90 1
cy_probe_common(bus_space_tag_t memt, bus_space_handle_t memh, int bustype)
a93 1
	int nchips;
d104 1
a104 1
	nchips = 0;
d117 2
a118 2
		printf("cy: probe chip %d offset 0x%lx ... ",
		    cy_chip, chip_offs);
d167 1
a167 1
		nchips++;
d170 1
a170 1
	if (nchips == 0) {
d178 1
a178 1
	printf("found %d CD1400s\n", nchips);
d181 4
a184 1
	return (nchips);
d188 1
a188 1
cy_attach(parent, self)
d190 1
d196 1
a196 1
	num_chips = sc->sc_nr_cd1400s;
d200 17
a216 1
	timeout_set(&sc->sc_poll_to, cy_poll, sc);
d260 3
a262 1
	printf(": %d ports\n", port);
d267 18
d288 1
a288 1
 * open routine. returns zero if successful, else error code
d311 5
d317 1
a317 1
	    (sc = cy_cd.cd_devs[card]) == NULL) {
a318 6
	}

#ifdef CY_DEBUG
	printf("%s open port %d flag 0x%x mode 0x%x\n", sc->sc_dev.dv_xname,
	    port, flag, mode);
#endif
d326 2
a327 2
			printf("%s port %d open: can't allocate tty\n",
			    sc->sc_dev.dv_xname, port);
d363 2
a364 2
				printf("%s: (port %d) can't allocate input buffer\n",
				       sc->sc_dev.dv_xname, port);
d384 5
a388 2
		if (!timeout_pending(&sc->sc_poll_to))
			timeout_add(&sc->sc_poll_to, 1);
d438 1
a438 1
 * close routine. returns zero if successful, else error code
d454 2
a455 2
	printf("%s close port %d, flag 0x%x, mode 0x%x\n", sc->sc_dev.dv_xname,
	    port, flag, mode);
d496 2
a497 2
	printf("%s read port %d uio 0x%x flag 0x%x\n", sc->sc_dev.dv_xname,
	    port, uio, flag);
d519 2
a520 2
	printf("%s write port %d uio 0x%x flag 0x%x\n", sc->sc_dev.dv_xname,
	    port, uio, flag);
d539 5
d566 2
a567 2
	printf("%s port %d ioctl cmd 0x%x data 0x%x flag 0x%x\n",
	    sc->sc_dev.dv_xname, port, cmd, data, flag);
d651 1
a651 1
	printf("%s port %d start, tty 0x%x\n", sc->sc_dev.dv_xname, port, tp);
d696 2
a697 2
	printf("%s port %d stop tty 0x%x flag 0x%x\n", sc->sc_dev.dv_xname,
	    port, tp, flag);
d718 1
a718 1
 * returns 0 if successful, else returns error code
d733 2
a734 2
	printf("%s port %d param tty 0x%x termios 0x%x\n", sc->sc_dev.dv_xname,
	    port, tp, t);
d971 2
a972 1
cy_poll(void *arg)
d975 1
a975 1
	struct cy_softc *sc = arg;
d985 1
a985 1
	s = spltty();
d987 1
a987 1
	if (sc->sc_events == 0 && ++counter < 200) {
d992 1
a992 1
	sc->sc_events = 0;
d995 5
d1001 2
a1002 2
	sc->sc_poll_count1++;
	did_something = 0;
d1005 5
a1009 21
	for (port = 0; port < sc->sc_nports; port++) {
		cy = &sc->sc_ports[port];
		if ((tp = cy->cy_tty) == NULL || cy->cy_ibuf == NULL ||
		    !ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN))
			continue;

		/*
		 * handle received data
		 */
		while (cy->cy_ibuf_rd_ptr != cy->cy_ibuf_wr_ptr) {
			u_char line_stat;
			int chr;

			line_stat = cy->cy_ibuf_rd_ptr[0];
			chr = cy->cy_ibuf_rd_ptr[1];

			if (line_stat &
			    (CD1400_RDSR_BREAK|CD1400_RDSR_FE))
				chr |= TTY_FE;
			if (line_stat & CD1400_RDSR_PE)
				chr |= TTY_PE;
d1012 1
a1012 2
			 * on an overrun error the data is treated as
			 * good just as it should be.
d1014 17
d1033 2
a1034 2
			printf("%s port %d ttyinput 0x%x\n",
			    sc->sc_dev.dv_xname, port, chr);
d1037 1
a1037 1
			(*linesw[tp->t_line].l_rint)(chr, tp);
d1039 5
a1043 5
			s = spltty(); /* really necessary? */
			if ((cy->cy_ibuf_rd_ptr += 2) ==
			    cy->cy_ibuf_end)
				cy->cy_ibuf_rd_ptr = cy->cy_ibuf;
			splx(s);
d1046 1
a1046 1
			did_something = 1;
d1048 1
a1048 1
		}
d1051 9
a1059 10
		/*
		 * If we don't have any received data in ibuf and
		 * CRTSCTS is on and RTS is turned off, it is time
		 * to turn RTS back on
		 */
		if (ISSET(tp->t_cflag, CRTSCTS)) {
			/* we can't use cy_modem_control() here as it
			    doesn't change RTS if RTSCTS is on */
			cd_write_reg(cy, CD1400_CAR,
			    port & CD1400_CAR_CHAN);
d1061 4
a1064 4
			if ((cd_read_reg(cy,
			    CD1400_MSVR1) & CD1400_MSVR1_RTS) == 0) {
				cd_write_reg(cy, CD1400_MSVR1,
				    CD1400_MSVR1_RTS);
d1066 1
a1066 1
				did_something = 1;
d1068 1
a1069 1
		}
d1072 6
a1077 6
		/*
		 * handle carrier changes
		 */
		s = spltty();
		if (ISSET(cy->cy_flags, CYF_CARRIER_CHANGED)) {
			int carrier;
d1079 2
a1080 2
			CLR(cy->cy_flags, CYF_CARRIER_CHANGED);
			splx(s);
d1082 2
a1083 2
			carrier = ((cy->cy_carrier_stat &
			    CD1400_MSVR2_CD) != 0);
d1086 3
a1088 3
			printf("cy_poll: carrier change "
			    "(card %d, port %d, carrier %d)\n",
			    card, port, carrier);
d1090 3
a1092 3
			if (CY_DIALIN(tp->t_dev) &&
			    !(*linesw[tp->t_line].l_modem)(tp, carrier))
				cy_modem_control(cy, TIOCM_DTR, DMBIC);
d1095 1
a1095 1
			did_something = 1;
d1097 3
a1099 3
		} else {
			splx(s);
		}
d1101 4
a1104 4
		s = spltty();
		if (ISSET(cy->cy_flags, CYF_START)) {
			CLR(cy->cy_flags, CYF_START);
			splx(s);
d1106 1
a1106 1
			(*linesw[tp->t_line].l_start)(tp);
d1109 1
a1109 1
			did_something = 1;
d1111 3
a1113 3
		} else {
			splx(s);
		}
d1115 14
a1128 14
		/* could move this to even upper level... */
		if (cy->cy_fifo_overruns) {
			cy->cy_fifo_overruns = 0;
			/* doesn't report overrun count,
			   but shouldn't really matter */
			log(LOG_WARNING, "cy%d port %d fifo overrun\n",
			    card, port);
		}
		if (cy->cy_ibuf_overruns) {
			cy->cy_ibuf_overruns = 0;
			log(LOG_WARNING, "cy%d port %d ibuf overrun\n",
			    card, port);
		}
	} /* for(port...) */
d1130 2
a1131 2
	if (did_something && counter >= 200)
		sc->sc_poll_count2++;
d1133 1
d1138 1
a1138 1
	timeout_add(&sc->sc_poll_to, 1);
d1150 1
d1152 1
a1152 1
	int int_serviced = -1;
d1158 1
a1158 1
	for (cy_chip = 0; cy_chip < sc->sc_nr_cd1400s; cy_chip++) {
d1181 4
a1190 4
				if (cy->cy_tty == NULL ||
				    !ISSET(cy->cy_tty->t_state, TS_ISOPEN))
					goto end_rx_serv;

d1192 1
a1192 1
				printf("%s port %d recv exception, "
d1194 1
a1194 2
				    sc->sc_dev.dv_xname, cy->cy_port_num,
				    line_stat, recv_data);
d1210 1
a1210 1
				sc->sc_events = 1;
a1212 9

				/* If no tty or not open, discard data */
				if (cy->cy_tty == NULL ||
				    !ISSET(cy->cy_tty->t_state, TS_ISOPEN)) {
					while (n_chars--)
						cd_read_reg(cy, CD1400_RDSR);
					goto end_rx_serv;
				}

d1214 2
a1215 3
				printf("%s port %d receive ok %d chars\n",
				    sc->sc_dev.dv_xname, cy->cy_port_num,
				    n_chars);
d1231 1
a1231 1
				sc->sc_events = 1;
d1275 2
a1276 2
			printf("%s port %d modem line change, new stat 0x%x\n",
			    sc->sc_dev.dv_xname, cy->cy_port_num, modem_stat);
d1281 1
a1281 1
				sc->sc_events = 1;
d1308 2
a1309 2
			printf("%s port %d tx service\n", sc->sc_dev.dv_xname,
			    cy->cy_port_num);
d1380 1
a1380 1
				sc->sc_events = 1;
d1404 1
a1404 1
	s = spltty();
@


1.9.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d303 6
a308 1
		cy->cy_tty = ttymalloc();
d313 2
d592 1
a592 1
		error = suser(p, 0);
d944 1
a944 1
	int port;
d1052 3
a1054 3
			printf("%s: cy_poll: carrier change "
			    "(port %d, carrier %d)\n",
			    sc->sc_dev.dv_xname, port, carrier);
d1086 2
a1087 2
			log(LOG_WARNING, "%s: port %d fifo overrun\n",
			    sc->sc_dev.dv_xname, port);
d1091 2
a1092 2
			log(LOG_WARNING, "%s: port %d ibuf overrun\n",
			    sc->sc_dev.dv_xname, port);
@


1.8
log
@Change disable_intr()/enable_intr() to splhigh()/splx().
Fix bug of 'tp' not being initialized in cyopen - patch from Theo de Raadt.
Thanks to Niklas Hallqvist and Theo de Raadt for finding this bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.7 1996/12/03 11:08:28 deraadt Exp $	*/
a40 1
#include <sys/ioctl.h>
@


1.7
log
@clr TS_WOPEN if bailing on cua opens
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.6 1996/12/03 05:28:21 kstailey Exp $	*/
a22 2
 * NOT TESTED !!!
 *
d63 1
d69 1
d91 1
d350 1
d998 4
a1001 4
    /* XXX */
#ifdef i386
    disable_intr();
#endif
d1003 1
a1003 4
        /* XXX */
#ifdef i386
	enable_intr();
#endif
d1008 1
a1008 4
    /* XXX */
#ifdef i386
    enable_intr();
#endif
d1053 1
a1053 4
		/* XXX */
#ifdef i386
		disable_intr(); /* really necessary? */
#endif
d1056 1
a1056 4
		/* XXX */
#ifdef i386
		enable_intr();
#endif
d1085 1
a1085 1
	    disable_intr();
d1090 1
a1090 1
		enable_intr();
d1107 1
a1107 1
		enable_intr();
d1110 1
a1110 1
	    disable_intr();
d1113 1
a1113 1
	      enable_intr();
d1121 1
a1121 1
		enable_intr();
d1404 2
a1405 1
    disable_intr();
d1409 1
a1409 1
    enable_intr();
@


1.6
log
@void cystop() -> int cystop()
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.5 1996/11/28 23:27:48 niklas Exp $	*/
d441 1
@


1.5
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.4 1996/11/12 20:30:17 niklas Exp $	*/
d313 1
a313 1
void cystop __P((struct tty *, int flag));
d699 1
a699 1
void
d728 1
@


1.4
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.3 1996/10/16 12:38:16 deraadt Exp $	*/
d21 1
a21 1
 * This version uses the bus_mem/io_??() stuff
d49 1
a49 1
#include <machine/bus.old.h>
d71 1
a71 1
int	cy_probe_common __P((int, bus_chipset_tag_t, bus_mem_handle_t, int));
d87 1
a87 1
static bus_mem_handle_t cy_card_memh[NCY];
d95 1
a95 1
cy_probe_common(card, bc, memh, bustype)
d97 2
a98 2
     bus_chipset_tag_t bc;
     bus_mem_handle_t memh;
d104 1
a104 1
  bus_mem_write_1(bc, memh, CY16_RESET<<bustype, 0);
d106 1
a106 1
  bus_mem_write_1(bc, memh, CY_CLEAR_INTR<<bustype, 0);
d131 1
a131 1
    if(bus_mem_read_1(bc, memh, chip_offs +
d140 1
a140 1
    bus_mem_write_1(bc, memh, chip_offs +
d150 1
a150 1
       bus_mem_read_1(bc, memh, chip_offs +
d155 1
a155 1
    bus_mem_write_1(bc, memh, chip_offs +
d163 1
a163 1
	bus_mem_read_1(bc, memh, chip_offs +
d217 1
a217 1
      sc->sc_bc = ((struct isa_attach_args *)(aux))->ia_bc;
d222 1
a222 1
      sc->sc_bc = ((struct pci_attach_args *)aux)->pa_bc;
d252 1
a252 1
      sc->sc_ports[port].cy_bc = sc->sc_bc;
d266 1
a266 1
  bus_mem_write_1(sc->sc_bc, sc->sc_memh,
d1400 1
a1400 1
    bus_mem_write_1(sc->sc_bc, sc->sc_memh,
@


1.3
log
@Wall happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.2 1996/08/23 20:20:15 niklas Exp $	*/
d49 1
a49 1
#include <machine/bus.h>
@


1.2
log
@Make more MI, closer to compile on amiga, still some problems though.
Also removed unnecessary static specifiers that maess up DDB
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.1 1996/07/27 07:20:03 deraadt Exp $	*/
d307 8
@


1.1
log
@split cy driver up
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.4 1996/06/23 13:11:05 deraadt Exp $	*/
a33 3
#include "isa.h"
#include "pci.h"

d48 1
d50 3
a52 1
#if NISA > 0	
d55 2
a56 2
#endif /* NISA > 0 */
#if NPCI > 0
d60 1
a60 1
#endif /* NPCI > 0 */
d70 10
a79 10
void cyattach __P((struct device *, struct device *, void *));

static int cyintr __P((void *));
static int cyparam __P((struct tty *, struct termios *));
static void cystart __P((struct tty *));
static void cy_poll __P((void *));
static int cy_modem_control __P((struct cy_port *, int, int));
static void cy_enable_transmitter __P((struct cy_port *));
static void cd1400_channel_cmd __P((struct cy_port *, int));
static int cy_speed __P((speed_t, int *, int *));
d215 1
a215 1
#if NISA > 0
d220 1
a220 1
#if NPCI > 0
d270 1
a270 1
#if NISA > 0
d280 2
a281 2
#endif /* NISA > 0 */
#if NPCI > 0
d295 1
a296 1
#endif /* NPCI > 0 */
d726 1
a726 1
static int
d874 1
a874 1
static int
d973 1
a973 1
static void
d986 2
d989 1
d991 2
d994 1
d999 2
d1002 1
d1047 2
d1050 1
d1053 2
d1056 1
d1400 1
a1400 1
static void
d1414 1
a1414 1
static void
d1443 1
a1443 1
static int
@
