head	1.53;
access;
symbols
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.6
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.49.0.10
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.49.0.6
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.48.0.12
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.10
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.6
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.8
	OPENBSD_5_0:1.48.0.4
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.2
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.44.0.6
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.42.0.12
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.42.0.10
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.8
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.6
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.42.0.4
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.27
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	SMP:1.13.0.4
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.53
date	2015.11.25.03.56.32;	author dlg;	state Exp;
branches;
next	1.52;
commitid	H72K6lZKcQU6yHlz;

1.52
date	2015.09.12.09.56.36;	author miod;	state Exp;
branches;
next	1.51;
commitid	T0uA02ZBU2EazyUh;

1.51
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.50;
commitid	6vhYvh5CxZAHMnsN;

1.50
date	2015.08.30.02.12.23;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	8ejCDnVRQj6IRdEv;

1.49
date	2013.12.02.23.40.41;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.08.27.19.54.02;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.05.07.57.04;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2008.09.03.19.29.48;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.21.04.12.21;	author kevlo;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.22.03.47.16;	author martin;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.02.13.39.21;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.02.13.27.16;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.02.02.28.35;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.29.01.10.43;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.14.15.36.03;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.28.16.58.56;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.04.14.47.30;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.19.11.36.59;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.29.18.53.58;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.25.21.47.10;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.20.18.48.43;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.17.01.55.28;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.29.21.39.34;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.20.16.46.27;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.11.18.28.30;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.18.19.11.18;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.16.21.29.54;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.13.17.43.02;	author nate;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.12.06.21.22.07;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.06.20.12.00;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.06.17.32.59;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.06.16.51.30;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.06.06.25.17;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.06.05.42.12;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.23.22.03.07;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.13.15.55.16;	author aaron;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.04.06.17.14.14;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.09.03.45.54;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.09.02.23.35;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.26.20.50.43;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.13.00.29.35;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.02.19.01.06;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.21.15.52.10;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.12.16.46.53;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.12.15.17.13;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.13.58.28;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.26.03.28.56;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.18.19.35.30;	author jason;	state Exp;
branches;
next	;

1.13.4.1
date	2001.05.14.22.23.41;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2001.07.04.10.40.49;	author niklas;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.13.4.6;

1.13.4.6
date	2003.05.13.19.35.00;	author ho;	state Exp;
branches;
next	1.13.4.7;

1.13.4.7
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.13.4.8;

1.13.4.8
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	1.13.4.9;

1.13.4.9
date	2004.06.05.23.12.41;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.53
log
@trim unused variable
@
text
@/*	$OpenBSD: dcreg.h,v 1.52 2015/09/12 09:56:36 miod Exp $ */

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_dcreg.h,v 1.12 2000/10/05 17:36:14 wpaul Exp $
 */

/*
 * 21143 and clone common register definitions.
 */

#ifdef __alpha__
#define SRM_MEDIA
#endif

#define DC_BUSCTL		0x00	/* bus control */
#define DC_TXSTART		0x08	/* tx start demand */
#define DC_RXSTART		0x10	/* rx start demand */
#define DC_RXADDR		0x18	/* rx descriptor list start addr */
#define DC_TXADDR		0x20	/* tx descriptor list start addr */
#define DC_ISR			0x28	/* interrupt status register */
#define DC_NETCFG		0x30	/* network config register */
#define DC_IMR			0x38	/* interrupt mask */
#define DC_FRAMESDISCARDED	0x40	/* # of discarded frames */
#define DC_SIO			0x48	/* MII and ROM/EEPROM access */
#define DC_ROM			0x50	/* ROM programming address */
#define DC_TIMER		0x58	/* general timer */
#define DC_10BTSTAT		0x60	/* SIA status */
#define DC_SIARESET		0x68	/* SIA connectivity */
#define DC_10BTCTRL		0x70	/* SIA transmit and receive */
#define DC_WATCHDOG		0x78	/* SIA and general purpose port */
#define DC_SIAGP		0x78	/* SIA and general purpose port (X3201) */

/*
 * There are two general 'types' of MX chips that we need to be
 * concerned with. One is the original 98713, which has its internal
 * NWAY support controlled via the MDIO bits in the serial I/O
 * register. The other is everything else (from the 98713A on up),
 * which has its internal NWAY controlled via CSR13, CSR14 and CSR15,
 * just like the 21143. This type setting also governs which of the
 * 'magic' numbers we write to CSR16. The PNIC II falls into the
 * 98713A/98715/98715A/98725 category.
 */
#define DC_TYPE_98713		0x1
#define DC_TYPE_98713A		0x2
#define DC_TYPE_987x5		0x3

/* Other type of supported chips. */
#define DC_TYPE_21143		0x4	/* Intel 21143 */
#define DC_TYPE_ASIX		0x5	/* ASIX AX88140A/AX88141 */
#define DC_TYPE_AL981		0x6	/* ADMtek AL981 Comet */
#define DC_TYPE_AN983		0x7	/* ADMtek AN983 Centaur */
#define DC_TYPE_DM9102		0x8	/* Davicom DM9102 */
#define DC_TYPE_PNICII		0x9	/* 82c115 PNIC II */
#define DC_TYPE_PNIC		0xA	/* 82c168/82c169 PNIC I */
#define DC_TYPE_XIRCOM		0xB	/* Xircom X3201 */
#define DC_TYPE_CONEXANT	0xC	/* Conexant LANfinity RS7112 */
#define DC_TYPE_21145		0xD	/* Intel 21145 */

#define DC_IS_MACRONIX(x)			\
	(x->dc_type == DC_TYPE_98713 ||		\
	 x->dc_type == DC_TYPE_98713A ||	\
	 x->dc_type == DC_TYPE_987x5)

#define DC_IS_ADMTEK(x)				\
	(x->dc_type == DC_TYPE_AL981 ||		\
	 x->dc_type == DC_TYPE_AN983)

#define DC_IS_CENTAUR(x)			\
	(x->dc_type == DC_TYPE_AN983)

#define DC_IS_INTEL(x)				\
	(x->dc_type == DC_TYPE_21143 ||		\
	 x->dc_type == DC_TYPE_21145)

#define DC_IS_ASIX(x)		(x->dc_type == DC_TYPE_ASIX)
#define DC_IS_COMET(x)		(x->dc_type == DC_TYPE_AL981)
#define DC_IS_CENTAUR(x)	(x->dc_type == DC_TYPE_AN983)
#define DC_IS_DAVICOM(x)	(x->dc_type == DC_TYPE_DM9102)
#define DC_IS_PNICII(x)		(x->dc_type == DC_TYPE_PNICII)
#define DC_IS_PNIC(x)		(x->dc_type == DC_TYPE_PNIC)
#define DC_IS_XIRCOM(x)		(x->dc_type == DC_TYPE_XIRCOM)
#define DC_IS_CONEXANT(x)	(x->dc_type == DC_TYPE_CONEXANT)

/* MII/symbol mode port types */
#define DC_PMODE_MII		0x1
#define DC_PMODE_SYM		0x2
#define DC_PMODE_SIA		0x3

/*
 * Bus control bits.
 */
#define DC_BUSCTL_RESET		0x00000001
#define DC_BUSCTL_ARBITRATION	0x00000002
#define DC_BUSCTL_SKIPLEN	0x0000007C
#define DC_BUSCTL_BUF_BIGENDIAN	0x00000080
#define DC_BUSCTL_BURSTLEN	0x00003F00
#define DC_BUSCTL_CACHEALIGN	0x0000C000
#define DC_BUSCTL_TXPOLL	0x000E0000
#define DC_BUSCTL_DBO		0x00100000
#define DC_BUSCTL_MRME		0x00200000
#define DC_BUSCTL_MRLE		0x00800000
#define DC_BUSCTL_MWIE		0x01000000
#define DC_BUSCTL_ONNOW_ENB	0x04000000

#define DC_SKIPLEN_1LONG	0x00000004
#define DC_SKIPLEN_2LONG	0x00000008
#define DC_SKIPLEN_3LONG	0x00000010
#define DC_SKIPLEN_4LONG	0x00000020
#define DC_SKIPLEN_5LONG	0x00000040

#define DC_CACHEALIGN_NONE	0x00000000
#define DC_CACHEALIGN_8LONG	0x00004000
#define DC_CACHEALIGN_16LONG	0x00008000
#define DC_CACHEALIGN_32LONG	0x0000C000

#define DC_BURSTLEN_USECA	0x00000000
#define DC_BURSTLEN_1LONG	0x00000100
#define DC_BURSTLEN_2LONG	0x00000200
#define DC_BURSTLEN_4LONG	0x00000400
#define DC_BURSTLEN_8LONG	0x00000800
#define DC_BURSTLEN_16LONG	0x00001000
#define DC_BURSTLEN_32LONG	0x00002000

#define DC_TXPOLL_OFF		0x00000000
#define DC_TXPOLL_1		0x00020000
#define DC_TXPOLL_2		0x00040000
#define DC_TXPOLL_3		0x00060000
#define DC_TXPOLL_4		0x00080000
#define DC_TXPOLL_5		0x000A0000
#define DC_TXPOLL_6		0x000C0000
#define DC_TXPOLL_7		0x000E0000

/*
 * Interrupt status bits.
 */
#define DC_ISR_TX_OK		0x00000001
#define DC_ISR_TX_IDLE		0x00000002
#define DC_ISR_TX_NOBUF		0x00000004
#define DC_ISR_TX_JABBERTIMEO	0x00000008
#define DC_ISR_LINKGOOD		0x00000010
#define DC_ISR_TX_UNDERRUN	0x00000020
#define DC_ISR_RX_OK		0x00000040
#define DC_ISR_RX_NOBUF		0x00000080
#define DC_ISR_RX_READ		0x00000100
#define DC_ISR_RX_WATDOGTIMEO	0x00000200
#define DC_ISR_TX_EARLY		0x00000400
#define DC_ISR_TIMER_EXPIRED	0x00000800
#define DC_ISR_LINKFAIL		0x00001000
#define DC_ISR_BUS_ERR		0x00002000
#define DC_ISR_RX_EARLY		0x00004000
#define DC_ISR_ABNORMAL		0x00008000
#define DC_ISR_NORMAL		0x00010000
#define DC_ISR_RX_STATE		0x000E0000
#define DC_ISR_TX_STATE		0x00700000
#define DC_ISR_BUSERRTYPE	0x03800000
#define DC_ISR_100MBPSLINK	0x08000000
#define DC_ISR_MAGICKPACK	0x10000000

#define DC_RXSTATE_STOPPED	0x00000000	/* 000 - Stopped */
#define DC_RXSTATE_FETCH	0x00020000	/* 001 - Fetching descriptor */
#define DC_RXSTATE_ENDCHECK	0x00040000	/* 010 - check for rx end */
#define DC_RXSTATE_WAIT		0x00060000	/* 011 - waiting for packet */
#define DC_RXSTATE_SUSPEND	0x00080000	/* 100 - suspend rx */
#define DC_RXSTATE_CLOSE	0x000A0000	/* 101 - close tx desc */
#define DC_RXSTATE_FLUSH	0x000C0000	/* 110 - flush from FIFO */
#define DC_RXSTATE_DEQUEUE	0x000E0000	/* 111 - dequeue from FIFO */

#define DC_HAS_BROKEN_RXSTATE(x)					\
	(DC_IS_CENTAUR(x) || DC_IS_CONEXANT(x) || (DC_IS_DAVICOM(x) &&	\
	sc->dc_revision >= DC_REVISION_DM9102A))

#define DC_TXSTATE_RESET	0x00000000	/* 000 - reset */
#define DC_TXSTATE_FETCH	0x00100000	/* 001 - fetching descriptor */
#define DC_TXSTATE_WAITEND	0x00200000	/* 010 - wait for tx end */
#define DC_TXSTATE_READING	0x00300000	/* 011 - read and enqueue */
#define DC_TXSTATE_RSVD		0x00400000	/* 100 - reserved */
#define DC_TXSTATE_SETUP	0x00500000	/* 101 - setup packet */
#define DC_TXSTATE_SUSPEND	0x00600000	/* 110 - suspend tx */
#define DC_TXSTATE_CLOSE	0x00700000	/* 111 - close tx desc */

/*
 * Network config bits.
 */
#define DC_NETCFG_RX_HASHPERF	0x00000001
#define DC_NETCFG_RX_ON		0x00000002
#define DC_NETCFG_RX_HASHONLY	0x00000004
#define DC_NETCFG_RX_BADFRAMES	0x00000008
#define DC_NETCFG_RX_INVFILT	0x00000010
#define DC_NETCFG_BACKOFFCNT	0x00000020
#define DC_NETCFG_RX_PROMISC	0x00000040
#define DC_NETCFG_RX_ALLMULTI	0x00000080
#define DC_NETCFG_FULLDUPLEX	0x00000200
#define DC_NETCFG_LOOPBACK	0x00000C00
#define DC_NETCFG_FORCECOLL	0x00001000
#define DC_NETCFG_TX_ON		0x00002000
#define DC_NETCFG_TX_THRESH	0x0000C000
#define DC_NETCFG_TX_BACKOFF	0x00020000
#define DC_NETCFG_PORTSEL	0x00040000	/* 0 == 10, 1 == 100 */
#define DC_NETCFG_HEARTBEAT	0x00080000
#define DC_NETCFG_STORENFWD	0x00200000
#define DC_NETCFG_SPEEDSEL	0x00400000	/* 1 == 10, 0 == 100 */
#define DC_NETCFG_PCS		0x00800000
#define DC_NETCFG_SCRAMBLER	0x01000000
#define DC_NETCFG_NO_RXCRC	0x02000000
#define DC_NETCFG_RX_ALL	0x40000000
#define DC_NETCFG_CAPEFFECT	0x80000000

#define DC_OPMODE_NORM		0x00000000
#define DC_OPMODE_INTLOOP	0x00000400
#define DC_OPMODE_EXTLOOP	0x00000800

#if 0
#define DC_TXTHRESH_72BYTES	0x00000000
#define DC_TXTHRESH_96BYTES	0x00004000
#define DC_TXTHRESH_128BYTES	0x00008000
#define DC_TXTHRESH_160BYTES	0x0000C000
#endif

#define DC_TXTHRESH_MIN		0x00000000
#define DC_TXTHRESH_INC		0x00004000
#define DC_TXTHRESH_MAX		0x0000C000

/*
 * Interrupt mask bits.
 */
#define DC_IMR_TX_OK		0x00000001
#define DC_IMR_TX_IDLE		0x00000002
#define DC_IMR_TX_NOBUF		0x00000004
#define DC_IMR_TX_JABBERTIMEO	0x00000008
#define DC_IMR_LINKGOOD		0x00000010
#define DC_IMR_TX_UNDERRUN	0x00000020
#define DC_IMR_RX_OK		0x00000040
#define DC_IMR_RX_NOBUF		0x00000080
#define DC_IMR_RX_READ		0x00000100
#define DC_IMR_RX_WATDOGTIMEO	0x00000200
#define DC_IMR_TX_EARLY		0x00000400
#define DC_IMR_TIMER_EXPIRED	0x00000800
#define DC_IMR_LINKFAIL		0x00001000
#define DC_IMR_BUS_ERR		0x00002000
#define DC_IMR_RX_EARLY		0x00004000
#define DC_IMR_ABNORMAL		0x00008000
#define DC_IMR_NORMAL		0x00010000
#define DC_IMR_100MBPSLINK	0x08000000
#define DC_IMR_MAGICKPACK	0x10000000

#define DC_INTRS	\
	(DC_IMR_RX_OK|DC_IMR_TX_OK|DC_IMR_RX_NOBUF|DC_IMR_RX_WATDOGTIMEO|\
	DC_IMR_TX_IDLE|DC_IMR_TX_NOBUF|DC_IMR_TX_UNDERRUN|DC_IMR_BUS_ERR|\
	DC_IMR_ABNORMAL|DC_IMR_NORMAL/*|DC_IMR_TX_EARLY*/)
/*
 * Serial I/O (EEPROM/ROM) bits.
 */
#define DC_SIO_EE_CS		0x00000001	/* EEPROM chip select */
#define DC_SIO_EE_CLK		0x00000002	/* EEPROM clock */
#define DC_SIO_EE_DATAIN	0x00000004	/* EEPROM data output */
#define DC_SIO_EE_DATAOUT	0x00000008	/* EEPROM data input */
#define DC_SIO_ROMDATA4		0x00000010
#define DC_SIO_ROMDATA5		0x00000020
#define DC_SIO_ROMDATA6		0x00000040
#define DC_SIO_ROMDATA7		0x00000080
#define DC_SIO_EESEL		0x00000800
#define DC_SIO_ROMSEL		0x00001000
#define DC_SIO_ROMCTL_WRITE	0x00002000
#define DC_SIO_ROMCTL_READ	0x00004000
#define DC_SIO_MII_CLK		0x00010000	/* MDIO clock */
#define DC_SIO_MII_DATAOUT	0x00020000	/* MDIO data out */
#define DC_SIO_MII_DIR		0x00040000	/* MDIO dir */
#define DC_SIO_MII_DATAIN	0x00080000	/* MDIO data in */

#define DC_EECMD_WRITE		0x140
#define DC_EECMD_READ		0x180
#define DC_EECMD_ERASE		0x1c0

#define DC_EE_NODEADDR_OFFSET	0x70
#define DC_EE_NODEADDR		10

/*
 * General purpose timer register
 * (upper 15 bits exist on rev 0x41 chips only)
 */
#define DC_TIMER_CLKDIV		0x80000000	/* clock/16 */
#define DC_TIMER_TXTIMER	0x78000000	/* TX intr delay timer */
#define DC_TIMER_TXCOUNT	0x07000000	/* TX intr delay counter */
#define DC_TIMER_RXTIMER	0x00F00000	/* RX intr delay timer */
#define DC_TIMER_RXCOUNT	0x000E0000	/* RX intr delay counter */
#define DC_TIMER_CONTINUOUS	0x00010000
#define DC_TIMER_VALUE		0x0000FFFF	/* 81.92us */

/*
 * 10baseT status register
 */
#define DC_TSTAT_MIIACT		0x00000001 /* MII port activity */
#define DC_TSTAT_LS100		0x00000002 /* link status of 100baseTX */
#define DC_TSTAT_LS10		0x00000004 /* link status of 10baseT */
#define DC_TSTAT_AUTOPOLARITY	0x00000008
#define DC_TSTAT_AUIACT		0x00000100 /* AUI activity */
#define DC_TSTAT_10BTACT	0x00000200 /* 10baseT activity */
#define DC_TSTAT_NSN		0x00000400 /* non-stable FLPs detected */
#define DC_TSTAT_REMFAULT	0x00000800
#define DC_TSTAT_ANEGSTAT	0x00007000
#define DC_TSTAT_LP_CAN_NWAY	0x00008000 /* link partner supports NWAY */
#define DC_TSTAT_LPCODEWORD	0xFFFF0000 /* link partner's code word */

#define DC_ASTAT_DISABLE	0x00000000
#define DC_ASTAT_TXDISABLE	0x00001000
#define DC_ASTAT_ABDETECT	0x00002000
#define DC_ASTAT_ACKDETECT	0x00003000
#define DC_ASTAT_CMPACKDETECT	0x00004000
#define DC_ASTAT_AUTONEGCMP	0x00005000
#define DC_ASTAT_LINKCHECK	0x00006000

/*
 * PHY reset register
 */
#define DC_SIA_RESET		0x00000001
#define DC_SIA_AUI		0x00000008 /* AUI or 10baseT */

/*
 * 10baseT control register
 */
#define DC_TCTL_ENCODER_ENB	0x00000001
#define DC_TCTL_LOOPBACK	0x00000002
#define DC_TCTL_DRIVER_ENB	0x00000004
#define DC_TCTL_LNKPULSE_ENB	0x00000008
#define DC_TCTL_HALFDUPLEX	0x00000040
#define DC_TCTL_AUTONEGENBL	0x00000080
#define DC_TCTL_RX_SQUELCH	0x00000100
#define DC_TCTL_COLL_SQUELCH	0x00000200
#define DC_TCTL_COLL_DETECT	0x00000400
#define DC_TCTL_SQE_ENB		0x00000800
#define DC_TCTL_LINKTEST	0x00001000
#define DC_TCTL_AUTOPOLARITY	0x00002000
#define DC_TCTL_SET_POL_PLUS	0x00004000
#define DC_TCTL_AUTOSENSE	0x00008000	/* 10bt/AUI autosense */
#define DC_TCTL_100BTXHALF	0x00010000
#define DC_TCTL_100BTXFULL	0x00020000
#define DC_TCTL_100BT4		0x00040000

/*
 * Watchdog timer register
 */
#define DC_WDOG_JABBERDIS	0x00000001
#define DC_WDOG_HOSTUNJAB	0x00000002
#define DC_WDOG_JABBERCLK	0x00000004
#define DC_WDOG_RXWDOGDIS	0x00000010
#define DC_WDOG_RXWDOGCLK	0x00000020
#define DC_WDOG_MUSTBEZERO	0x00000100
#define DC_WDOG_AUIBNC		0x00100000
#define DC_WDOG_ACTIVITY	0x00200000
#define DC_WDOG_LINK		0x00800000
#define DC_WDOG_CTLWREN		0x08000000

/*
 * SIA and General Purpose Port register (X3201)
 */
#define DC_SIAGP_RXMATCH	0x40000000
#define DC_SIAGP_INT1		0x20000000
#define DC_SIAGP_INT0		0x10000000
#define DC_SIAGP_WRITE_EN	0x08000000
#define DC_SIAGP_RXMATCH_EN	0x04000000
#define DC_SIAGP_INT1_EN	0x02000000
#define DC_SIAGP_INT0_EN	0x01000000
#define DC_SIAGP_LED3		0x00800000
#define DC_SIAGP_LED2		0x00400000
#define DC_SIAGP_LED1		0x00200000
#define DC_SIAGP_LED0		0x00100000
#define DC_SIAGP_MD_GP3_OUTPUT	0x00080000
#define DC_SIAGP_MD_GP2_OUTPUT	0x00040000
#define DC_SIAGP_MD_GP1_OUTPUT	0x00020000
#define DC_SIAGP_MD_GP0_OUTPUT	0x00010000

/*
 * Size of a setup frame.
 */
#define DC_SFRAME_LEN		192

/*
 * 21x4x TX/RX list structure.
 */

struct dc_desc {
	u_int32_t		dc_status;
	u_int32_t		dc_ctl;
	u_int32_t		dc_ptr1;
	u_int32_t		dc_ptr2;
	u_int32_t		dc_pad[4];
};

#define dc_data		dc_ptr1
#define dc_next		dc_ptr2

#define DC_RXSTAT_FIFOOFLOW	0x00000001
#define DC_RXSTAT_CRCERR	0x00000002
#define DC_RXSTAT_DRIBBLE	0x00000004
#define DC_RXSTAT_MIIERE	0x00000008
#define DC_RXSTAT_WATCHDOG	0x00000010
#define DC_RXSTAT_FRAMETYPE	0x00000020	/* 0 == IEEE 802.3 */
#define DC_RXSTAT_COLLSEEN	0x00000040
#define DC_RXSTAT_GIANT		0x00000080
#define DC_RXSTAT_LASTFRAG	0x00000100
#define DC_RXSTAT_FIRSTFRAG	0x00000200
#define DC_RXSTAT_MULTICAST	0x00000400
#define DC_RXSTAT_RUNT		0x00000800
#define DC_RXSTAT_RXTYPE	0x00003000
#define DC_RXSTAT_DE		0x00004000
#define DC_RXSTAT_RXERR		0x00008000
#define DC_RXSTAT_RXLEN		0x3FFF0000
#define DC_RXSTAT_OWN		0x80000000

#define DC_RXBYTES(x)		((x & DC_RXSTAT_RXLEN) >> 16)
#define DC_RXSTAT (DC_RXSTAT_FIRSTFRAG|DC_RXSTAT_LASTFRAG|DC_RXSTAT_OWN)

#define DC_RXCTL_BUFLEN1	0x00000FFF
#define DC_RXCTL_BUFLEN2	0x00FFF000
#define DC_RXCTL_RLINK		0x01000000
#define DC_RXCTL_RLAST		0x02000000

#define DC_TXSTAT_DEFER		0x00000001
#define DC_TXSTAT_UNDERRUN	0x00000002
#define DC_TXSTAT_LINKFAIL	0x00000003
#define DC_TXSTAT_COLLCNT	0x00000078
#define DC_TXSTAT_SQE		0x00000080
#define DC_TXSTAT_EXCESSCOLL	0x00000100
#define DC_TXSTAT_LATECOLL	0x00000200
#define DC_TXSTAT_NOCARRIER	0x00000400
#define DC_TXSTAT_CARRLOST	0x00000800
#define DC_TXSTAT_JABTIMEO	0x00004000
#define DC_TXSTAT_ERRSUM	0x00008000
#define DC_TXSTAT_OWN		0x80000000

#define DC_TXCTL_BUFLEN1	0x000007FF
#define DC_TXCTL_BUFLEN2	0x003FF800
#define DC_TXCTL_FILTTYPE0	0x00400000
#define DC_TXCTL_PAD		0x00800000
#define DC_TXCTL_TLINK		0x01000000
#define DC_TXCTL_TLAST		0x02000000
#define DC_TXCTL_NOCRC		0x04000000
#define DC_TXCTL_SETUP		0x08000000
#define DC_TXCTL_FILTTYPE1	0x10000000
#define DC_TXCTL_FIRSTFRAG	0x20000000
#define DC_TXCTL_LASTFRAG	0x40000000
#define DC_TXCTL_FINT		0x80000000

#define DC_FILTER_PERFECT	0x00000000
#define DC_FILTER_HASHPERF	0x00400000
#define DC_FILTER_INVERSE	0x10000000
#define DC_FILTER_HASHONLY	0x10400000

#define DC_MAXFRAGS		16
#define DC_RX_LIST_CNT		64
#define DC_TX_LIST_CNT		256

#define DC_INC(x, y)	(x) = (x + 1) % y

struct dc_list_data {
	struct dc_desc		dc_rx_list[DC_RX_LIST_CNT];
	struct dc_desc		dc_tx_list[DC_TX_LIST_CNT];
	u_int32_t		dc_sbuf[DC_SFRAME_LEN/sizeof(u_int32_t)];
	u_int8_t		dc_pad[ETHER_MIN_LEN];
};

/* software descriptor */
struct dc_swdesc {
	bus_dmamap_t		sd_map;
	struct mbuf		*sd_mbuf;
};

struct dc_chain_data {
	struct dc_swdesc	dc_rx_chain[DC_RX_LIST_CNT];
	struct dc_swdesc	dc_tx_chain[DC_TX_LIST_CNT];
	int			dc_tx_prod;
	int			dc_tx_cons;
	int			dc_tx_cnt;
	int			dc_rx_prod;
};

struct dc_mediainfo {
	uint64_t		dc_media;
	u_int8_t		*dc_gp_ptr;
	u_int8_t		dc_gp_len;
	u_int8_t		*dc_reset_ptr;
	u_int8_t		dc_reset_len;
	struct dc_mediainfo	*dc_next;
};

struct dc_type {
	u_int16_t		dc_vid;
	u_int16_t		dc_did;
};

struct dc_mii_frame {
	u_int8_t		mii_stdelim;
	u_int8_t		mii_opcode;
	u_int8_t		mii_phyaddr;
	u_int8_t		mii_regaddr;
	u_int8_t		mii_turnaround;
	u_int16_t		mii_data;
};

/*
 * MII constants
 */
#define DC_MII_STARTDELIM	0x01
#define DC_MII_READOP		0x02
#define DC_MII_WRITEOP		0x01
#define DC_MII_TURNAROUND	0x02


/*
 * Registers specific to clone devices.
 * This mainly relates to RX filter programming: not all 21x4x clones
 * use the standard DEC filter programming mechanism.
 */

/*
 * ADMtek specific registers and constants for the AL981 and AN983.
 * The AN983 doesn't use the magic PHY registers.
 */
#define DC_AL_CR		0x88	/* Command register */
#define DC_AL_PAR0		0xA4	/* station address */
#define DC_AL_PAR1		0xA8	/* station address */
#define DC_AL_MAR0		0xAC	/* multicast hash filter */
#define DC_AL_MAR1		0xB0	/* multicast hash filter */
#define DC_AL_BMCR		0xB4	/* built in PHY control */
#define DC_AL_BMSR		0xB8	/* built in PHY status */
#define DC_AL_VENID		0xBC	/* built in PHY ID0 */
#define DC_AL_DEVID		0xC0	/* built in PHY ID1 */
#define DC_AL_ANAR		0xC4	/* built in PHY autoneg advert */
#define DC_AL_LPAR		0xC8	/* bnilt in PHY link part. ability */
#define DC_AL_ANER		0xCC	/* built in PHY autoneg expansion */

#define DC_ADMTEK_PHYADDR	0x1
#define DC_AL_EE_NODEADDR	8
#define DC_AL_CR_ATUR		0x00000001	/* Enable automatic TX underrun recovery */
/* End of ADMtek specific registers */

/*
 * ASIX specific registers.
 */
#define DC_AX_FILTIDX		0x68	/* RX filter index */
#define DC_AX_FILTDATA		0x70	/* RX filter data */

/*
 * Special ASIX-specific bits in the ASIX NETCFG register (CSR6).
 */
#define DC_AX_NETCFG_RX_BROAD	0x00000100 

/*
 * RX Filter Index Register values
 */
#define DC_AX_FILTIDX_PAR0	0x00000000
#define DC_AX_FILTIDX_PAR1	0x00000001
#define DC_AX_FILTIDX_MAR0	0x00000002
#define DC_AX_FILTIDX_MAR1	0x00000003
/* End of ASIX specific registers */

/*
 * Macronix specific registers. The Macronix chips have a special
 * register for reading the NWAY status, which we don't use, plus
 * a magic packet register, which we need to tweak a bit per the
 * Macronix application notes.
 */
#define DC_MX_MAGICPACKET	0x80
#define DC_MX_NWAYSTAT		0xA0

/*
 * Magic packet register
 */
#define DC_MX_MPACK_DISABLE	0x00400000

/*
 * NWAY status register.
 */
#define DC_MX_NWAY_10BTHALF	0x08000000
#define DC_MX_NWAY_10BTFULL	0x10000000
#define DC_MX_NWAY_100BTHALF	0x20000000
#define DC_MX_NWAY_100BTFULL	0x40000000
#define DC_MX_NWAY_100BT4	0x80000000

/*
 * These are magic values that must be written into CSR16
 * (DC_MX_MAGICPACKET) in order to put the chip into proper
 * operating mode. The magic numbers are documented in the
 * Macronix 98715 application notes.
 */
#define DC_MX_MAGIC_98713	0x0F370000
#define DC_MX_MAGIC_98713A	0x0B3C0000
#define DC_MX_MAGIC_98715	0x0B3C0000
#define DC_MX_MAGIC_98725	0x0B3C0000
/* End of Macronix specific registers */

/*
 * PNIC 82c168/82c169 specific registers.
 * The PNIC has its own special NWAY support, which doesn't work,
 * and shortcut ways of reading the EEPROM and MII bus.
 */
#define DC_PN_GPIO		0x60	/* general purpose pins control */
#define DC_PN_PWRUP_CFG		0x90	/* config register, set by EEPROM */
#define DC_PN_SIOCTL		0x98	/* serial EEPROM control register */
#define DC_PN_MII		0xA0	/* MII access register */
#define DC_PN_NWAY		0xB8	/* Internal NWAY register */

/* Serial I/O EEPROM register */
#define DC_PN_SIOCTL_DATA	0x0000003F
#define DC_PN_SIOCTL_OPCODE	0x00000300
#define DC_PN_SIOCTL_BUSY	0x80000000

#define DC_PN_EEOPCODE_ERASE	0x00000300
#define DC_PN_EEOPCODE_READ	0x00000600
#define DC_PN_EEOPCODE_WRITE	0x00000100

/*
 * The first two general purpose pins control speed selection and
 * 100Mbps loopback on the 82c168 chip. The control bits should always
 * be set (to make the data pins outputs) and the speed selction and
 * loopback bits set accordingly when changing media. Physically, this
 * will set the state of a relay mounted on the card.
 */
#define DC_PN_GPIO_DATA0	0x000000001
#define DC_PN_GPIO_DATA1	0x000000002
#define DC_PN_GPIO_DATA2	0x000000004
#define DC_PN_GPIO_DATA3	0x000000008
#define DC_PN_GPIO_CTL0		0x000000010
#define DC_PN_GPIO_CTL1		0x000000020
#define DC_PN_GPIO_CTL2		0x000000040
#define DC_PN_GPIO_CTL3		0x000000080
#define DC_PN_GPIO_SPEEDSEL	DC_PN_GPIO_DATA0/* 1 == 100Mbps, 0 == 10Mbps */
#define DC_PN_GPIO_100TX_LOOP	DC_PN_GPIO_DATA1/* 1 == normal, 0 == loop */
#define DC_PN_GPIO_BNC_ENB	DC_PN_GPIO_DATA2
#define DC_PN_GPIO_100TX_LNK	DC_PN_GPIO_DATA3
#define DC_PN_GPIO_SETBIT(sc, r)			\
	DC_SETBIT(sc, DC_PN_GPIO, ((r) | (r << 4)))
#define DC_PN_GPIO_CLRBIT(sc, r)			\
	{						\
		DC_SETBIT(sc, DC_PN_GPIO, ((r) << 4));	\
		DC_CLRBIT(sc, DC_PN_GPIO, (r));		\
	}
	
/* shortcut MII access register */
#define DC_PN_MII_DATA		0x0000FFFF
#define DC_PN_MII_RESERVER	0x00020000
#define DC_PN_MII_REGADDR	0x007C0000
#define DC_PN_MII_PHYADDR	0x0F800000
#define DC_PN_MII_OPCODE	0x30000000
#define DC_PN_MII_BUSY		0x80000000

#define DC_PN_MIIOPCODE_READ	0x60020000
#define DC_PN_MIIOPCODE_WRITE	0x50020000

/* Internal NWAY bits */
#define DC_PN_NWAY_RESET	0x00000001	/* reset */
#define DC_PN_NWAY_PDOWN	0x00000002	/* power down */
#define DC_PN_NWAY_BYPASS	0x00000004	/* bypass */
#define DC_PN_NWAY_AUILOWCUR	0x00000008	/* AUI low current */
#define DC_PN_NWAY_TPEXTEND	0x00000010	/* low squelch voltage */
#define DC_PN_NWAY_POLARITY	0x00000020	/* 0 == on, 1 == off */
#define DC_PN_NWAY_TP		0x00000040	/* 1 == tp, 0 == AUI */
#define DC_PN_NWAY_AUIVOLT	0x00000080	/* 1 == full, 0 == half */
#define DC_PN_NWAY_DUPLEX	0x00000100	/* LED, 1 == full, 0 == half */
#define DC_PN_NWAY_LINKTEST	0x00000200	/* 0 == on, 1 == off */
#define DC_PN_NWAY_AUTODETECT	0x00000400	/* 1 == off, 0 == on */
#define DC_PN_NWAY_SPEEDSEL	0x00000800	/* LED, 0 = 10, 1 == 100 */
#define DC_PN_NWAY_NWAY_ENB	0x00001000	/* 0 == off, 1 == on */
#define DC_PN_NWAY_CAP10HDX	0x00002000
#define DC_PN_NWAY_CAP10FDX	0x00004000
#define DC_PN_NWAY_CAP100FDX	0x00008000
#define DC_PN_NWAY_CAP100HDX	0x00010000
#define DC_PN_NWAY_CAP100T4	0x00020000
#define DC_PN_NWAY_ANEGRESTART	0x02000000	/* resets when aneg done */
#define DC_PN_NWAY_REMFAULT	0x04000000
#define DC_PN_NWAY_LPAR10HDX	0x08000000
#define DC_PN_NWAY_LPAR10FDX	0x10000000
#define DC_PN_NWAY_LPAR100FDX	0x20000000
#define DC_PN_NWAY_LPAR100HDX	0x40000000
#define DC_PN_NWAY_LPAR100T4	0x80000000

/* End of PNIC specific registers */

/*
 * CONEXANT specific registers.
 */

#define DC_CONEXANT_PHYADDR	0x1
#define DC_CONEXANT_EE_NODEADDR	0x19A

/* End of CONEXANT specific register */

struct dc_softc {
	struct device		sc_dev;
	void			*sc_ih;
	struct arpcom		sc_arpcom;	/* interface info */
	mii_data_t		sc_mii;
	bus_space_handle_t	dc_bhandle;	/* bus space handle */
	bus_space_tag_t		dc_btag;	/* bus space tag */
	u_int8_t		dc_type;
	u_int8_t		dc_pmode;
	u_int8_t		dc_link;
	u_int8_t		dc_cachesize;
	int			dc_romwidth;
	int			dc_pnic_rx_bug_save;
	unsigned char		*dc_pnic_rx_buf;
	uint64_t		dc_if_media;
	u_int32_t		dc_flags;
	u_int32_t		dc_txthresh;
	u_int8_t		*dc_srom;
	size_t			dc_sromsize;
	struct dc_mediainfo	*dc_mi;
	struct dc_list_data	*dc_ldata;
	struct dc_chain_data	dc_cdata;
	u_int32_t		dc_csid;
	u_int			dc_revision;
	struct timeout		dc_tick_tmo;
#ifdef SRM_MEDIA
	uint64_t		dc_srm_media;
#endif
	bus_dma_tag_t		sc_dmat;
	bus_dmamap_t		sc_listmap;
	bus_dma_segment_t	sc_listseg[1];
	int			sc_listnseg;
	caddr_t			sc_listkva;
	bus_dmamap_t		sc_rx_sparemap;
	bus_dmamap_t		sc_tx_sparemap;
	int			sc_hasmac;
};

#define DC_TX_POLL		0x00000001
#define DC_TX_COALESCE		0x00000002
#define DC_TX_ADMTEK_WAR	0x00000004
#define DC_TX_USE_TX_INTR	0x00000008
#define DC_RX_FILTER_TULIP	0x00000010
#define DC_TX_INTR_FIRSTFRAG	0x00000020
#define DC_PNIC_RX_BUG_WAR	0x00000040
#define DC_TX_FIXED_RING	0x00000080
#define DC_TX_STORENFWD		0x00000100
#define DC_REDUCED_MII_POLL	0x00000200
#define DC_TX_INTR_ALWAYS	0x00000400
#define DC_21143_NWAY		0x00000800
#define DC_128BIT_HASH		0x00001000
#define DC_64BIT_HASH		0x00002000
#define DC_TULIP_LEDS		0x00004000
#define DC_TX_ONE		0x00008000
#define DC_TX_ALIGN		0x00010000	/* align mbuf on tx */
#define DC_MOMENCO_BOTCH	0x00020000

/*
 * register space access macros
 */
#define CSR_WRITE_4(sc, reg, val)	\
	bus_space_write_4(sc->dc_btag, sc->dc_bhandle, reg, val)

#define CSR_READ_4(sc, reg)		\
	bus_space_read_4(sc->dc_btag, sc->dc_bhandle, reg)

#define DC_TIMEOUT		1000

/*
 * General constants that are fun to know.
 */

/* Macronix PCI revision codes. */
#define DC_REVISION_98713	0x00
#define DC_REVISION_98713A	0x10
#define DC_REVISION_98715	0x20
#define DC_REVISION_98715AEC_C	0x25
#define DC_REVISION_98725	0x30

/*
 * 82c168/82c169 PNIC device IDs. Both chips have the same device
 * ID but different revisions. Revision 0x10 is the 82c168, and
 * 0x20 is the 82c169.
 */
#define DC_REVISION_82C168	0x10
#define DC_REVISION_82C169	0x20

/*
 * The ASIX AX88140 and ASIX AX88141 have the same vendor and
 * device IDs but different revision values.
 */
#define DC_REVISION_88140	0x00
#define DC_REVISION_88141	0x10

/*
 * The DMA9102A has the same PCI device ID as the DM9102,
 * but a higher revision code.
 */
#define DC_REVISION_DM9102	0x10
#define DC_REVISION_DM9102A	0x30

/*
 * PCI low memory base and low I/O base register, and
 * other PCI registers.
 */

#define DC_PCI_CFID		0x00	/* Id */
#define DC_PCI_CFCS		0x04	/* Command and status */
#define DC_PCI_CFRV		0x08	/* Revision */
#define DC_PCI_CFLT		0x0C	/* Latency timer */
#define DC_PCI_CFBIO		0x10	/* Base I/O address */
#define DC_PCI_CFBMA		0x14	/* Base memory address */
#define DC_PCI_CCIS		0x28	/* Card info struct */
#define DC_PCI_CSID		0x2C	/* Subsystem ID */
#define DC_PCI_CBER		0x30	/* Expansion ROM base address */
#define DC_PCI_CCAP		0x34	/* Caps pointer - PD/TD chip only */
#define DC_PCI_CFIT		0x3C	/* Interrupt */
#define DC_PCI_CFDD		0x40	/* Device and driver area */
#define DC_PCI_CWUA0		0x44	/* Wake-Up LAN addr 0 */
#define DC_PCI_CWUA1		0x48	/* Wake-Up LAN addr 1 */
#define DC_PCI_SOP0		0x4C	/* SecureON passwd 0 */
#define DC_PCI_SOP1		0x50	/* SecureON passwd 1 */
#define DC_PCI_CWUC		0x54	/* Configuration Wake-Up cmd */
#define DC_PCI_CCID		0xDC	/* Capability ID - PD/TD only */
#define DC_PCI_CPMC		0xE0	/* Pwrmgmt ctl & sts - PD/TD only */

/* PCI ID register */
#define DC_CFID_VENDOR		0x0000FFFF
#define DC_CFID_DEVICE		0xFFFF0000

/* PCI command/status register */
#define DC_CFCS_IOSPACE		0x00000001 /* I/O space enable */
#define DC_CFCS_MEMSPACE	0x00000002 /* memory space enable */
#define DC_CFCS_BUSMASTER	0x00000004 /* bus master enable */
#define DC_CFCS_MWI_ENB		0x00000010 /* mem write and inval enable */
#define DC_CFCS_PARITYERR_ENB	0x00000040 /* parity error enable */
#define DC_CFCS_SYSERR_ENB	0x00000100 /* system error enable */
#define DC_CFCS_NEWCAPS		0x00100000 /* new capabilities */
#define DC_CFCS_FAST_B2B	0x00800000 /* fast back-to-back capable */
#define DC_CFCS_DATAPARITY	0x01000000 /* Parity error report */
#define DC_CFCS_DEVSELTIM	0x06000000 /* devsel timing */
#define DC_CFCS_TGTABRT		0x10000000 /* received target abort */
#define DC_CFCS_MASTERABRT	0x20000000 /* received master abort */
#define DC_CFCS_SYSERR		0x40000000 /* asserted system error */
#define DC_CFCS_PARITYERR	0x80000000 /* asserted parity error */

/* PCI revision register */
#define DC_CFRV_STEPPING	0x0000000F
#define DC_CFRV_REVISION	0x000000F0
#define DC_CFRV_SUBCLASS	0x00FF0000
#define DC_CFRV_BASECLASS	0xFF000000

#define DC_21143_PB_REV		0x00000030
#define DC_21143_TB_REV		0x00000030
#define DC_21143_PC_REV		0x00000030
#define DC_21143_TC_REV		0x00000030
#define DC_21143_PD_REV		0x00000041
#define DC_21143_TD_REV		0x00000041

/* PCI latency timer register */
#define DC_CFLT_CACHELINESIZE	0x000000FF
#define DC_CFLT_LATENCYTIMER	0x0000FF00

/* PCI subsystem ID register */
#define DC_CSID_VENDOR		0x0000FFFF
#define DC_CSID_DEVICE		0xFFFF0000

/* PCI capabilities pointer */
#define DC_CCAP_OFFSET		0x000000FF

/* PCI interrupt config register */
#define DC_CFIT_INTLINE		0x000000FF
#define DC_CFIT_INTPIN		0x0000FF00
#define DC_CFIT_MIN_GNT		0x00FF0000
#define DC_CFIT_MAX_LAT		0xFF000000

/* PCI capability register */
#define DC_CCID_CAPID		0x000000FF
#define DC_CCID_NEXTPTR		0x0000FF00
#define DC_CCID_PM_VERS		0x00070000
#define DC_CCID_PME_CLK		0x00080000
#define DC_CCID_DVSPEC_INT	0x00200000
#define DC_CCID_STATE_D1	0x02000000
#define DC_CCID_STATE_D2	0x04000000
#define DC_CCID_PME_D0		0x08000000
#define DC_CCID_PME_D1		0x10000000
#define DC_CCID_PME_D2		0x20000000
#define DC_CCID_PME_D3HOT	0x40000000
#define DC_CCID_PME_D3COLD	0x80000000

/* PCI power management control/status register */
#define DC_CPMC_STATE		0x00000003
#define DC_CPMC_PME_ENB		0x00000100
#define DC_CPMC_PME_STS		0x00008000

#define DC_PSTATE_D0		0x0
#define DC_PSTATE_D1		0x1
#define DC_PSTATE_D2		0x2
#define DC_PSTATE_D3		0x3

/* Device specific region */
/* Configuration and driver area */
#define DC_CFDD_DRVUSE		0x0000FFFF
#define DC_CFDD_SNOOZE_MODE	0x40000000
#define DC_CFDD_SLEEP_MODE	0x80000000

/* Configuration wake-up command register */
#define DC_CWUC_MUST_BE_ZERO	0x00000001
#define DC_CWUC_SECUREON_ENB	0x00000002
#define DC_CWUC_FORCE_WUL	0x00000004
#define DC_CWUC_BNC_ABILITY	0x00000008
#define DC_CWUC_AUI_ABILITY	0x00000010
#define DC_CWUC_TP10_ABILITY	0x00000020
#define DC_CWUC_MII_ABILITY	0x00000040
#define DC_CWUC_SYM_ABILITY	0x00000080
#define DC_CWUC_LOCK		0x00000100

/*
 * SROM nonsense.
 */

#define DC_IB_CTLRCNT		0x13
#define DC_IB_LEAF0_CNUM	0x1A
#define DC_IB_LEAF0_OFFSET	0x1B

struct dc_info_leaf {
	u_int16_t		dc_conntype;
	u_int8_t		dc_blkcnt;
	u_int8_t		dc_rsvd;
	u_int16_t		dc_infoblk;
};

#define DC_CTYPE_10BT			0x0000
#define DC_CTYPE_10BT_NWAY		0x0100
#define DC_CTYPE_10BT_FDX		0x0204
#define DC_CTYPE_10B2			0x0001
#define DC_CTYPE_10B5			0x0002
#define DC_CTYPE_100BT			0x0003
#define DC_CTYPE_100BT_FDX		0x0205
#define DC_CTYPE_100T4			0x0006
#define DC_CTYPE_100FX			0x0007
#define DC_CTYPE_100FX_FDX		0x0208
#define DC_CTYPE_MII_10BT		0x0009
#define DC_CTYPE_MII_10BT_FDX		0x020A
#define DC_CTYPE_MII_100BT		0x000D
#define DC_CTYPE_MII_100BT_FDX		0x020E
#define DC_CTYPE_MII_100T4		0x000F
#define DC_CTYPE_MII_100FX		0x0010
#define DC_CTYPE_MII_100FX_FDX		0x0211
#define DC_CTYPE_DYN_PUP_AUTOSENSE	0x0800
#define DC_CTYPE_PUP_AUTOSENSE		0x8800
#define DC_CTYPE_NOMEDIA		0xFFFF

#define DC_EBLOCK_SIA			0x0002
#define DC_EBLOCK_MII			0x0003
#define DC_EBLOCK_SYM			0x0004
#define DC_EBLOCK_RESET			0x0005
#define DC_EBLOCK_PHY_SHUTDOWN		0x0006

struct dc_leaf_hdr {
	u_int16_t		dc_mtype;
	u_int8_t		dc_mcnt;
	u_int8_t		dc_rsvd;
};

struct dc_eblock_hdr {
	u_int8_t		dc_len;
	u_int8_t		dc_type;
};

struct dc_eblock_sia {
	struct dc_eblock_hdr	dc_sia_hdr;
	u_int8_t		dc_sia_code;
	union {
		struct dc_sia_ext { /* if (dc_sia_code & DC_SIA_CODE_EXT) */
			u_int8_t dc_sia_mediaspec[6]; /* CSR13, CSR14, CSR15 */
			u_int8_t dc_sia_gpio_ctl[2];
			u_int8_t dc_sia_gpio_dat[2];
		} dc_sia_ext;
		struct dc_sia_noext {
			u_int8_t dc_sia_gpio_ctl[2];
			u_int8_t dc_sia_gpio_dat[2];
		} dc_sia_noext;
	} dc_un;
};

#define DC_SIA_CODE_10BT	0x00
#define DC_SIA_CODE_10B2	0x01
#define DC_SIA_CODE_10B5	0x02
#define DC_SIA_CODE_10BT_FDX	0x04
#define DC_SIA_CODE_EXT		0x40

/*
 * Note that the first word in the gpr and reset
 * sequences is always a control word.
 */
struct dc_eblock_mii {
	struct dc_eblock_hdr    dc_mii_hdr;
	u_int8_t		dc_mii_phynum;
	u_int8_t		dc_gpr_len;
/*	u_int16_t		dc_gpr_dat[n]; */
/*	u_int8_t		dc_reset_len; */
/*	u_int16_t		dc_reset_dat[n]; */
/* There are other fields after these, but we don't
 * care about them since they can be determined by looking
 * at the PHY.
 */
};

struct dc_eblock_sym {
	struct dc_eblock_hdr	dc_sym_hdr;
	u_int8_t		dc_sym_code;
	u_int8_t		dc_sym_gpio_ctl[2];
	u_int8_t		dc_sym_gpio_dat[2];
	u_int8_t		dc_sym_cmd[2];
};

#define DC_SYM_CODE_100BT	0x03
#define DC_SYM_CODE_100BT_FDX	0x05
#define DC_SYM_CODE_100T4	0x06
#define DC_SYM_CODE_100FX	0x07
#define DC_SYM_CODE_100FX_FDX	0x08

struct dc_eblock_reset {
	struct dc_eblock_hdr	dc_reset_hdr;
	u_int8_t		dc_reset_len;
/*	u_int16_t		dc_reset_dat[n]; */
};

extern void dc_attach(struct dc_softc *);
extern int dc_detach(struct dc_softc *);
extern int dc_activate(struct device *, int);
extern int dc_intr(void *);

void dc_init(void *);
void dc_stop(struct dc_softc *, int);

extern void dc_reset(struct dc_softc *);
extern void dc_eeprom_width(struct dc_softc *);
extern void dc_read_srom(struct dc_softc *, int);
extern void dc_parse_21143_srom(struct dc_softc *);

#if BYTE_ORDER == BIG_ENDIAN
#define	DC_SP_FIELD_C(x)	((x) << 16)
#else
#define	DC_SP_FIELD_C(x)	(x)
#endif
#define	DC_SP_FIELD(x,f)	DC_SP_FIELD_C(((u_int16_t *)(x))[(f)])
@


1.52
log
@ifmedia64 fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.51 2015/09/11 13:02:28 stsp Exp $ */
a724 1
	void			*dc_intrhand;
@


1.51
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.50 2015/08/30 02:12:23 deraadt Exp $ */
d733 1
a733 1
	int			dc_if_media;
@


1.50
log
@Track rom size, for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.49 2013/12/02 23:40:41 brad Exp $ */
d508 1
a508 1
	int			dc_media;
d745 1
a745 1
	int			dc_srm_media;
@


1.49
log
@Rewrite receive filter handling and ioctl bits. Fixes not being able to
bring the interface out of all multicast mode once a range of multicast
addresses has been found and missing multicast range checking for some
of the dc(4) variants.

Tested with 21143 (represents most of the dc(4) variants and boards) and
ADMtek based adapters. Untested with ASIX and Xircom based adapters.
Putting it in to move forward. I don't expect any issues with the
ASIX/Xircom adapters with the changes as is.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.48 2010/09/07 16:21:42 deraadt Exp $ */
d737 1
@


1.48
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.47 2010/08/27 19:54:02 deraadt Exp $ */
a732 1
	int			dc_if_flags;
@


1.47
log
@Move the dc_pci_activate function to dc.c, and mangle it up with some of
the gunk in dc_powerhook.  Then make dc_powerhook just call it
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.46 2010/08/05 07:57:04 deraadt Exp $ */
a725 1
	void			*sc_pwrhook;
@


1.46
log
@ca_activate function for suspend/resume; tested by mlarkin on a
Davicom DM9102.  (bit of noise on suspend or resume, but that can be
dealt with later)
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.45 2009/08/10 20:29:54 deraadt Exp $ */
d1051 1
@


1.45
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.44 2008/09/03 19:29:48 brad Exp $ */
d1052 4
@


1.44
log
@In dc_setcfg() suppress printing a warning when forcing the receiver
and transmitter to idle state times out for chips where the status
bits in question never change (observed in detail with DM9102A) and
therefore the warning would highly likely be a false positive.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.43 2008/07/21 04:12:21 kevlo Exp $ */
a725 1
	void			*sc_dhook;
@


1.43
log
@cleanup - we don't have resource structure
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.42 2005/05/22 03:47:16 martin Exp $ */
d197 4
@


1.42
log
@fix power hooks
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.41 2005/01/02 13:39:21 brad Exp $ */
a723 2
	struct resource		*dc_irq;
	struct resource		*dc_res;
@


1.41
log
@more constants
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.40 2005/01/02 13:27:16 brad Exp $ */
d723 1
@


1.40
log
@rev 1.21

Defs for three (unused so far) bits in PCI command/status register
were off by one bit.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.39 2004/12/02 02:28:35 brad Exp $ */
d421 1
d431 1
d772 2
a773 1
#define DC_MOMENCO_BOTCH	0x00010000
@


1.39
log
@rev 1.126

Ignore CSR13, CSR14, CSR15 'Media Specific Data' registers
for 21143 based cards which use SIA mode.

This fixes 10mbit mode for ZNYX ZX346Q cards and other
21143 based cards.

rev 1.108

Only use a SIA/SYM media info block if no MII block is detected.
The submitter of PR 32118 told me that this patch also fixes autoselecting
for znyx 4 port cards (10baseT, 100baseTX did work already).

From FreeBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.38 2004/10/29 01:10:43 brad Exp $ */
d849 3
a851 3
#define DC_CFCS_MWI_ENB		0x00000008 /* mem write and inval enable */
#define DC_CFCS_PARITYERR_ENB	0x00000020 /* parity error enable */
#define DC_CFCS_SYSERR_ENB	0x00000080 /* system error enable */
@


1.38
log
@rev 1.78

Enable the automatic TX underrun recovery for the ADMtek chips.
This solves cvsup update on my laptop which aborts after a while
without this patch.

rev 1.79

Fix the support for the AN985/983 chips, which do not set the
RXSTATE to STOPPED, but to WAIT. This should fix hangs which
could only be solved by replugging the cable.

From FreeBSD

Thanks to C. Bensend <benny at bennyvision dot com> for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.37 2004/10/14 15:36:03 brad Exp $ */
d988 11
a998 3
	u_int8_t		dc_sia_mediaspec[6]; /* CSR13, CSR14, CSR15 */
	u_int8_t		dc_sia_gpio_ctl[2];
	u_int8_t		dc_sia_gpio_dat[2];
@


1.37
log
@constants for TX underrun handling
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.36 2004/09/28 16:58:56 brad Exp $ */
d543 1
d558 1
@


1.36
log
@Use ETHER_MIN_LEN/ETHER_MAX_DIX_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.35 2004/08/04 14:47:30 mickey Exp $ */
d238 1
d243 1
d245 3
@


1.35
log
@interrupt mitigation bits
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.34 2004/05/19 11:36:59 brad Exp $ */
a470 2
#define DC_MIN_FRAMELEN		64
#define DC_RXLEN		1536
d478 1
a478 1
	u_int8_t		dc_pad[DC_MIN_FRAMELEN];
@


1.34
log
@remove duplication, use ETHER_ALIGN from if_ether.h
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.33 2003/10/21 18:58:49 jmc Exp $ */
d300 1
d302 5
a306 1
#define DC_TIMER_VALUE		0x0000FFFF
d308 1
@


1.33
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.32 2003/09/29 18:53:58 mickey Exp $ */
a770 1
#define ETHER_ALIGN		2
@


1.32
log
@better dmesg output including onboard memory size when present, free resources on failures; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.31 2003/09/25 21:47:10 mickey Exp $ */
d872 1
a872 1
/* PCI cababilities pointer */
@


1.31
log
@better structs alignment; jason@@ testing on sparc64 and ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.30 2003/05/20 18:48:43 henning Exp $ */
d269 1
a269 1
	DC_IMR_TX_NOBUF|DC_IMR_TX_UNDERRUN|DC_IMR_BUS_ERR|		\
@


1.30
log
@AN983 endian issue; from FreeBSD via PR 3263 with minor style fixes by me

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.29 2003/05/17 01:55:28 jason Exp $ */
d401 1
d465 1
a465 1
#define DC_MIN_FRAMELEN		60
@


1.29
log
@fix up the media handling for the intel based MACs.  Also hack around a
bug in the Momenco firmware on the Leopard-V, which now has one port
working.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.28 2003/04/29 21:39:34 jason Exp $ */
d97 3
@


1.28
log
@- remove last vestige of "old autoconf": dc_unit is dead, long live dv_xname
- remove a bunch of #if 0 stuff (most of which referred to dc_unit, grr)
- delay a bzero until necessary
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.27 2002/10/20 16:46:27 henning Exp $ */
d755 1
@


1.27
log
@add support for intel 21145
This chip is some strange abnormal 21143 variant. It really only works with
10 MBit/s halfduplex only and autonegotiation is totally broken in hardware.
Should also have a HomePNA phy, but we don't support that.
for now requires and explicit "media 10BaseT".
if anybody has such a chip please mail me.

nick@@ is the only one who has the hardware and did an incredible amount of
testing. Thanks for all the help, Nick!

some hints and ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.26 2002/06/11 18:28:30 aaron Exp $ */
a707 1
	u_int8_t		dc_unit;	/* interface number */
@


1.26
log
@Fix tab.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.25 2002/06/09 03:14:18 todd Exp $ */
d87 1
d98 4
a101 1
#define DC_IS_INTEL(x)		(x->dc_type == DC_TYPE_21143)
@


1.25
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.24 2002/04/18 19:11:18 jason Exp $ */
d472 1
a472 1
	struct mbuf *		sd_mbuf;
@


1.24
log
@add support for Conexant LANfinity RS7112; based on patch from Maurice Nonnekes <maurice@@amaze.nl> based on FreeBSD (only minor surgery necessary)
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.23 2002/04/16 21:29:54 jason Exp $ */
d696 1
a696 1
	struct arpcom		arpcom;		/* interface info */
@


1.23
log
@move prototypes of dc_eeprom_width, dc_read_srom, and dc_parse_21143_srom to dcreg.h and out of the bus specific drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.22 2002/03/14 01:26:54 millert Exp $ */
d86 1
d105 1
d683 9
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.21 2001/12/13 17:43:02 nate Exp $ */
d1011 3
@


1.21
log
@Fix old alpha bug recently triggered by conversion to busdma.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.20 2001/12/06 21:22:07 jason Exp $ */
d1007 4
a1010 4
extern void dc_attach	__P((struct dc_softc *));
extern int dc_detach	__P((struct dc_softc *));
extern int dc_intr	__P((void *));
extern void dc_reset	__P((struct dc_softc *));
@


1.21.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.21 2001/12/13 17:43:02 nate Exp $ */
a85 1
#define DC_TYPE_CONEXANT	0xC	/* Conexant LANfinity RS7112 */
a103 1
#define DC_IS_CONEXANT(x)	(x->dc_type == DC_TYPE_CONEXANT)
a681 9
/*
 * CONEXANT specific registers.
 */

#define DC_CONEXANT_PHYADDR	0x1
#define DC_CONEXANT_EE_NODEADDR	0x19A

/* End of CONEXANT specific register */

d685 1
a685 1
	struct arpcom		sc_arpcom;	/* interface info */
d1007 4
a1010 7
extern void dc_attach(struct dc_softc *);
extern int dc_detach(struct dc_softc *);
extern int dc_intr(void *);
extern void dc_reset(struct dc_softc *);
extern void dc_eeprom_width(struct dc_softc *);
extern void dc_read_srom(struct dc_softc *, int);
extern void dc_parse_21143_srom(struct dc_softc *);
@


1.21.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.21.2.1 2002/06/11 03:42:18 art Exp $ */
a86 1
#define DC_TYPE_21145		0xD	/* Intel 21145 */
d97 1
a97 4
#define DC_IS_INTEL(x)				\
	(x->dc_type == DC_TYPE_21143 ||		\
	 x->dc_type == DC_TYPE_21145)

d472 1
a472 1
	struct mbuf		*sd_mbuf;
@


1.21.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d708 1
a755 1
#define DC_MOMENCO_BOTCH	0x00010000
@


1.20
log
@a few more bus_dmamap_sync()'s and some borrowed setup frame macros from NetBSD, and RX works on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.19 2001/12/06 20:12:00 jason Exp $ */
d40 4
@


1.19
log
@enough bus_dmamap_sync() and htole()/letoh() to get TX working on sparc64.
ALso, get the MAC address from myetheraddr() instead of trying to use the eeprom on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.18 2001/12/06 17:32:59 jason Exp $ */
d1007 7
@


1.18
log
@vtophys, R.I.P. (tx now uses bus_dma)
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.17 2001/12/06 16:51:30 jason Exp $ */
d718 1
@


1.17
log
@move rx handling over to bus_dma... that just leaves one vtophys() in tx.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.16 2001/12/06 06:25:17 jason Exp $ */
d471 1
a471 1
	struct mbuf		*dc_tx_chain[DC_TX_LIST_CNT];
d717 1
a1000 5

#ifdef __alpha__
#undef vtophys
#define vtophys(va)		alpha_XXX_dmamap((vm_offset_t)va)
#endif
@


1.16
log
@move the setup buffer and pad into a bus_dma alloced area
(current score: 2 vtophys calls to go...)
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.15 2001/12/06 05:42:12 jason Exp $ */
d463 6
d470 1
a470 1
	struct mbuf		*dc_rx_chain[DC_RX_LIST_CNT];
a677 8
/* software descriptor */
struct dc_swdesc {
	bus_dmamap_t		sd_map;
	struct mbuf *		sd_mbuf;
	struct dc_swdesc *	sd_next;
};


d716 1
a716 2
	struct dc_swdesc	sc_txsd[DC_TX_LIST_CNT];
	struct dc_swdesc	sc_rxsd[DC_RX_LIST_CNT];
@


1.15
log
@Checkpoint bus_dma work in progress:
- descriptor lists are now bus_dma allocated and manipulated
(for those keeping score: 6 vtophys dead, 4 to go)
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.14 2001/06/23 22:03:07 fgsch Exp $ */
d459 2
a465 2
	u_int32_t		dc_sbuf[DC_SFRAME_LEN/sizeof(u_int32_t)];
	u_int8_t		dc_pad[DC_MIN_FRAMELEN];
@


1.14
log
@More constants cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.13 2001/04/13 15:55:16 aaron Exp $ */
d672 8
a705 1
	caddr_t			dc_ldata_ptr;
d713 7
@


1.13
log
@Disestablish the shutdownhook on detach.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.12 2001/04/06 17:14:14 aaron Exp $ */
a992 4
#endif

#ifndef ETHER_CRC_LEN
#define ETHER_CRC_LEN	4
@


1.13.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.13 2001/04/13 15:55:16 aaron Exp $ */
@


1.13.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.13.4.1 2001/05/14 22:23:41 niklas Exp $ */
d993 4
@


1.13.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a40 4
#ifdef __alpha__
#define SRM_MEDIA
#endif

a458 8
	u_int32_t		dc_sbuf[DC_SFRAME_LEN/sizeof(u_int32_t)];
	u_int8_t		dc_pad[DC_MIN_FRAMELEN];
};

/* software descriptor */
struct dc_swdesc {
	bus_dmamap_t		sd_map;
	struct mbuf *		sd_mbuf;
d462 4
a465 2
	struct dc_swdesc	dc_rx_chain[DC_RX_LIST_CNT];
	struct dc_swdesc	dc_tx_chain[DC_TX_LIST_CNT];
d698 1
a705 8
	bus_dma_tag_t		sc_dmat;
	bus_dmamap_t		sc_listmap;
	bus_dma_segment_t	sc_listseg[1];
	int			sc_listnseg;
	caddr_t			sc_listkva;
	bus_dmamap_t		sc_rx_sparemap;
	bus_dmamap_t		sc_tx_sparemap;
	int			sc_hasmac;
d990 5
a998 7

#if BYTE_ORDER == BIG_ENDIAN
#define	DC_SP_FIELD_C(x)	((x) << 16)
#else
#define	DC_SP_FIELD_C(x)	(x)
#endif
#define	DC_SP_FIELD(x,f)	DC_SP_FIELD_C(((u_int16_t *)(x))[(f)])
@


1.13.4.4
log
@Merge in -current from about a week ago
@
text
@d1007 4
a1010 4
extern void dc_attach(struct dc_softc *);
extern int dc_detach(struct dc_softc *);
extern int dc_intr(void *);
extern void dc_reset(struct dc_softc *);
@


1.13.4.5
log
@Sync the SMP branch with 3.3
@
text
@a85 2
#define DC_TYPE_CONEXANT	0xC	/* Conexant LANfinity RS7112 */
#define DC_TYPE_21145		0xD	/* Intel 21145 */
d96 1
a96 4
#define DC_IS_INTEL(x)				\
	(x->dc_type == DC_TYPE_21143 ||		\
	 x->dc_type == DC_TYPE_21145)

a103 1
#define DC_IS_CONEXANT(x)	(x->dc_type == DC_TYPE_CONEXANT)
d470 1
a470 1
	struct mbuf		*sd_mbuf;
a681 9
/*
 * CONEXANT specific registers.
 */

#define DC_CONEXANT_PHYADDR	0x1
#define DC_CONEXANT_EE_NODEADDR	0x19A

/* End of CONEXANT specific register */

d685 1
a685 1
	struct arpcom		sc_arpcom;	/* interface info */
a1010 3
extern void dc_eeprom_width(struct dc_softc *);
extern void dc_read_srom(struct dc_softc *, int);
extern void dc_parse_21143_srom(struct dc_softc *);
@


1.13.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.13.4.5 2003/03/28 00:38:12 niklas Exp $ */
d708 1
@


1.13.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.13.4.6 2003/05/13 19:35:00 ho Exp $ */
a97 3
#define DC_IS_CENTAUR(x)			\
	(x->dc_type == DC_TYPE_AN983)

a754 1
#define DC_MOMENCO_BOTCH	0x00010000
@


1.13.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d269 1
a269 1
	DC_IMR_TX_IDLE|DC_IMR_TX_NOBUF|DC_IMR_TX_UNDERRUN|DC_IMR_BUS_ERR|\
a400 1
	u_int32_t		dc_pad[4];
d464 1
a464 1
#define DC_MIN_FRAMELEN		64
d871 1
a871 1
/* PCI capabilities pointer */
@


1.13.4.9
log
@Merge with the trunk
@
text
@d771 1
@


1.12
log
@- For CardBus 21143 cards, parse the SROM. Makes my SMC EZ CardBus 10/100 work.
- General cleanup in the dc CardBus attachment.
- Split detach up into bus-dependent and bus-independent parts.
- Some function and variable renaming for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.11 2001/02/09 03:45:54 aaron Exp $ */
d680 1
@


1.11
log
@Sync with FreeBSD:
- Bugfix: 'reg' variable in dc_apply_fixup() needs to be u_int32_t.
- Bugfix: bzero() mediainfo structures after allocation.
- Call dc_apply_fixup() in dc_setcfg() for the MII case.
- Conditionalize some code in miibus_{read,write}reg to make non-mx98713
  cards happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.10 2001/02/09 02:23:35 aaron Exp $ */
d527 1
a527 1
#define DC_AL_EE_NODEADDR	4
d694 1
a694 1
	u_int8_t		dc_srom[1024];
d998 4
a1001 3
extern void dc_attach_common __P((struct dc_softc *));
extern int dc_intr __P((void *));
extern void dc_reset __P((struct dc_softc *));
@


1.10
log
@Add support for parsing the media blocks from the SROM on the 21143 adapters.
These changes should make the driver work with the built-in Ethernet on the
Alpha Miata machines. From FreeBSD.

To make sure I didn't break anything (and as a general test), I tested the
modified driver with the following dc(4) variants: Macronix PMAC 98715,
Lite-On PNIC, Lite-On PNIC-II, ADMtek AL981, and ADMtek AN983.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.9 2000/10/26 20:50:43 aaron Exp $ */
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_dcreg.h,v 1.11 2000/09/07 18:51:04 wpaul Exp $
@


1.9
log
@Add support for Xircom X3201-based CardBus Ethernet cards. Tested successfully
on four different models, including the CBEM56G-100, RBE-100 RealPort, and the
RBEM56G-100 RealPort. This commit adds support only for the LAN components; the
modem is not configured yet. Detach support to come. Based on work from
FreeBSD, mickey@@, nate@@, and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.8 2000/09/13 00:29:35 aaron Exp $ */
d104 1
d358 15
a372 15
#define DC_SIAGP_RXMATCH       0x40000000
#define DC_SIAGP_INT1          0x20000000
#define DC_SIAGP_INT0          0x10000000
#define DC_SIAGP_WRITE_EN      0x08000000
#define DC_SIAGP_RXMATCH_EN    0x04000000
#define DC_SIAGP_INT1_EN       0x02000000
#define DC_SIAGP_INT0_EN       0x01000000
#define DC_SIAGP_LED3          0x00800000
#define DC_SIAGP_LED2          0x00400000
#define DC_SIAGP_LED1          0x00200000
#define DC_SIAGP_LED0          0x00100000
#define DC_SIAGP_MD_GP3_OUTPUT 0x00080000
#define DC_SIAGP_MD_GP2_OUTPUT 0x00040000
#define DC_SIAGP_MD_GP1_OUTPUT 0x00020000
#define DC_SIAGP_MD_GP0_OUTPUT 0x00010000   
d472 9
d533 2
a534 2
#define DC_AX_FILTIDX		0x68    /* RX filter index */
#define DC_AX_FILTDATA		0x70    /* RX filter data */
d694 2
d702 3
d722 1
d884 104
@


1.8
log
@Sync with FreeBSD. Finally make the OpenBSD-specific changes necessary to make
non-MII 21143-based cards work. The sync just fixes the LED handling on these
kinds of adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.7 2000/08/02 19:01:06 aaron Exp $ */
d57 1
d81 1
d99 1
d353 19
@


1.7
log
@Sync with FreeBSD. Summary of changes:

- Add support for Accton EN1217 Ethernet adapters.
- Fix problems with LEDs on some cards when clearing the jabber disable bit.
- Handle new Macronix chips whose multicast hash tables are only 128 bits.
- Fix timing issues during autonegotiation with Macronix and PNIC II.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.6 2000/07/21 15:52:10 mickey Exp $ */
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_dcreg.h,v 1.9 2000/08/02 16:31:11 wpaul Exp $
d346 3
d684 1
@


1.6
log
@convert to new timeouts; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.5 2000/06/12 16:46:53 mickey Exp $ */
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_dcreg.h,v 1.3 2000/01/19 19:03:08 wpaul Exp $
d346 1
d678 3
d702 1
@


1.5
log
@eeprom width detection code.
idea from netbsd tulip driver.
there is problem w/ an983 card, but aaron@@ said he'll work it out.
aaron@@ & jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.4 2000/06/12 15:17:13 aaron Exp $ */
d663 1
@


1.4
log
@Fix ADMtek identity crisis.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.3 2000/04/26 13:58:28 mickey Exp $ */
d651 1
@


1.3
log
@we've done an oops
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.2 2000/04/26 03:28:56 mickey Exp $ */
d76 1
a76 1
#define DC_TYPE_AN985		0x7	/* ADMtek AN985 Centaur */
d88 1
a88 1
	 x->dc_type == DC_TYPE_AN985)
d93 1
a93 1
#define DC_IS_CENTAUR(x)	(x->dc_type == DC_TYPE_AN985)
d475 2
a476 2
 * ADMtek specific registers and constants for the AL981 and AN985.
 * The AN985 doesn't use the magic PHY registers.
@


1.2
log
@dc_csid ain't needed no more; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dcreg.h,v 1.1 2000/04/18 19:35:30 jason Exp $ */
d660 1
@


1.1
log
@split dc driver into bus dependent and bus independent (pci) parts
(cardbus to come later).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dcreg.h,v 1.5 2000/03/17 01:27:14 aaron Exp $ */
a659 1
	u_int32_t		dc_csid;
@

