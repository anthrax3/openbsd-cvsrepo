head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.6
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.10
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.8
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.22
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.26
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.24
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.20
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.18
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.14
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.16
	OPENBSD_5_0:1.13.0.12
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.11.0.12
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.10
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.8
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.04.05.23.25.57;	author miod;	state Exp;
branches;
next	1.13;
commitid	XOdAFq379z2QzTF2;

1.13
date	2009.01.28.17.37.40;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.01.17.30.56;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.29.11.54.07;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.24.19.20.04;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.23.16.53.21;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.19.02.52.38;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.19.02.25.11;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.19.24.22;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.31.17.00.19;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.11.21.30.30;	author mickey;	state Exp;
branches
	1.3.4.1
	1.3.8.1;
next	1.2;

1.2
date	2001.01.11.21.23.53;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.30.19.39.38;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.24.15;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.28.12.09.41;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2004.02.19.10.56.21;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2003.05.19.21.59.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Work-in-progress support for non-accelerated X11 on *some* sti(4) frame buffers;
based upon the old HP ngle X11 driver. Currently limited to CRX (720/735/750),
Timber (710, old 715), Artist (712, 715) and EG (B-series), however the
colormap isn't set up correctly on Timber and EG yet.

Joint work with Artem Falcon, now in good enough shape to be worked further
in the tree.
@
text
@/*	$OpenBSD: stireg.h,v 1.13 2009/01/28 17:37:40 miod Exp $	*/

/*
 * Copyright (c) 2000 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _IC_STIREG_H_
#define _IC_STIREG_H_

/* #define	STIDEBUG */

#define	STI_REGION_MAX	8
#define	STI_MONITOR_MAX	256
#define	STI_DEVNAME_LEN	32
#define	STI_NCMAP	256

/* code ROM definitions */
#define	STI_BEGIN	0
#define	STI_INIT_GRAPH	0
#define	STI_STATE_MGMT	1
#define	STI_FONT_UNPMV	2
#define	STI_BLOCK_MOVE	3
#define	STI_SELF_TEST	4
#define	STI_EXCEP_HDLR	5
#define	STI_INQ_CONF	6
#define	STI_SCM_ENT	7
#define	STI_DMA_CTRL	8
#define	STI_FLOW_CTRL	9
#define	STI_UTIMING	10
#define	STI_PROC_MGR	11
#define	STI_UTIL	12
#define	STI_END		13
#define	STI_CODECNT	16

#define	STI_CODEBASE_MAIN	0x40
#define	STI_CODEBASE_ALT	0x80

#define	STI_CODEBASE_PA		STI_CODEBASE_MAIN
#define	STI_CODEBASE_M68K	STI_CODEBASE_ALT
#define	STI_CODEBASE_PA64	STI_CODEBASE_ALT

/* sti returns */
#define	STI_OK		0
#define	STI_FAIL	-1
#define	STI_NRDY	1

/* sti errno */
#define	STI_NOERRNO		0	/* no error */
#define	STI_BADREENTLVL		1	/* bad reentry level */
#define	STI_NOREGIONSDEF	2	/* region table is not setup */
#define	STI_ILLNPLANES		3	/* invalid num of text planes */
#define	STI_ILLINDEX		4	/* invalid font index */
#define	STI_ILLLOC		5	/* invalid font location */
#define	STI_ILLCOLOUR		6	/* invalid colour */
#define	STI_ILLBLKMVFROM	7	/* invalid from in blkmv */
#define	STI_ILLBLKMVTO		8	/* invalid to in blkmv */
#define	STI_ILLBLKMVSIZE	9	/* invalid size in blkmv */
#define	STI_BEIUNSUPP		10	/* bus error ints unsupported */
#define	STI_UNXPBE		11	/* unexpected bus error */
#define	STI_UNXHWF		12	/* unexpected hardware failure */
#define	STI_NEGCFG		13	/* no ext global config struct */
#define	STI_NEIG		14	/* no ext init struct */
#define	STI_ILLSCME		15	/* invalid set cmap entry */
#define	STI_ILLCMVAL		16	/* invalid cmap value */
#define	STI_NORESMEM		17	/* no requested global memory */
#define	STI_RESMEMCORR		18	/* reserved memory corrupted */
#define	STI_ILLNTBLKMV		19	/* invalid non-text blkmv */
#define	STI_ILLMONITOR		20	/* monitor selection is out of range */
#define	STI_ILLEXCADDR		21	/* invalid excpt handler addr */
#define	STI_ILLEXCFLAGS		22	/* invalid excpt handler flags */
#define	STI_NOEHE		23	/* no ext exhdl struct */
#define	STI_NOINQCE		24	/* no ext inq cfg struct */
#define	STI_ILLRGNPTR		25	/* invalid region pointer */
#define	STI_ILLUTLOP		26	/* invalid util opcode */
#define	STI_UNKNOWN		250	/* unknown error */
#define	STI_NOCFGPTR		251	/* no config ptr defined */
#define	STI_NOFLPTR		252	/* no flag ptr defined */
#define	STI_NOINPTR		253	/* no in ptr defined */
#define	STI_NOOUTPTR		254	/* no way you can get it */
#define	STI_NOLOCK		255	/* kernel dishonour graphics lock */

/* colours */
#define	STI_COLOUR_BLACK	0
#define	STI_COLOUR_WHITE	1
#define	STI_COLOUR_RED		2
#define	STI_COLOUR_YELLOW	3
#define	STI_COLOUR_GREEN	4
#define	STI_COLOUR_CYAN		5
#define	STI_COLOUR_BLUE		6
#define	STI_COLOUR_MAGENTA	7

	/* LSB high */
struct	sti_dd {
	u_int32_t	dd_type;	/* 0x00 device type */
#define	STI_DEVTYPE1	1
#define	STI_DEVTYPE4	3
	u_int8_t	dd_unused;
	u_int8_t	dd_nmon;	/* 0x05 number monitor rates */
	u_int8_t	dd_grrev;	/* 0x06 global rom revision */
	u_int8_t	dd_lrrev;	/* 0x07 local rom revision */
	u_int32_t	dd_grid[2];	/* 0x08 graphics id */
#define	STI_DD_CRX		0x26D1482A	/* single-head CRX */
#define	STI_DD_GRX		0x26D1488C	/* gray-scale GRX */
#define	STI_DD_CRX24		0x26D148EE	/* CRX+ */
#define	STI_DD_EVRX		0x27134C9F	/* 425e on-board */
#define	STI_DD_3X2V		0x27134CB4	/* 382 on-board */
#define	STI_DD_TIMBER		0x27F12392	/* on-board 710, older 715 */
#define	STI_DD_DUAL_CRX		0x27FCCB6D	/* dual-head CRX */
#define	STI_DD_ARTIST		0x2B4DED6D	/* on-board 712/715, also GSC */
#define	STI_DD_HCRX		0x2BCB015A
#define	STI_DD_EG		0x2D08C0A7	/* Visualize EG */
#define	STI_DD_SUMMIT		0x2FC1066B	/* Visualize FX2, FX4, FX6 */
#define	STI_DD_PINNACLE		0x35ACDA16	/* Visualize FXe */
#define	STI_DD_LEGO		0x35ACDA30	/* Visualize FX5, FX10 */
	u_int32_t	dd_fntaddr;	/* 0x10 font start address */
	u_int32_t	dd_maxst;	/* 0x14 max state storage */
	u_int32_t	dd_romend;	/* 0x18 rom last address */
	u_int32_t	dd_reglst;	/* 0x1c device region list */
	u_int16_t	dd_maxreent;	/* 0x20 max reent storage */
	u_int16_t	dd_maxtimo;	/* 0x22 max execution timeout .1 sec */
	u_int32_t	dd_montbl;	/* 0x24 monitor table address */
	u_int32_t	dd_udaddr;	/* 0x28 user data address */
	u_int32_t	dd_stimemreq;	/* 0x2c sti memory request */
	u_int32_t	dd_udsize;	/* 0x30 user data size */
	u_int16_t	dd_pwruse;	/* 0x34 power usage */
	u_int8_t	dd_bussup;	/* 0x36 bus support */
#define	STI_BUSSUPPORT_GSCINTL	0x01	/*	supports pulling INTL for int */
#define	STI_BUSSUPPORT_GSC15X	0x02	/*	supports GSC 1.5X */
#define	STI_BUSSUPPORT_GSC2X	0x04	/*	supports GSC 2.X */
#define	STI_BUSSUPPORT_PCIIOEIM	0x08	/*	will use directed int */
#define	STI_BUSSUPPORT_PCISTD	0x10	/*	will use std PCI int */
#define	STI_BUSSUPPORT_ILOCK	0x20	/*	supports implicit locking */
#define	STI_BUSSUPPORT_ROMMAP	0x40	/*	rom is only in pci erom space */
#define	STI_BUSSUPPORT_2DECODE	0x80	/*	single address decoder */
	u_int8_t	dd_ebussup;	/* 0x37 extended bus support */
#define	STI_EBUSSUPPORT_DMA	0x01	/*	supports dma */
#define	STI_EBUSSUPPORT_PIOLOCK	0x02	/*	no implicit locking for dma */
	u_int8_t	dd_altcodet;	/* 0x38 alternate code type */
#define	STI_ALTCODE_UNKNOWN	0x00
#define	STI_ALTCODE_PA64	0x01	/*	alt code is in pa64 */
	u_int8_t	dd_eddst[3];	/* 0x39 extended DD struct */
	u_int32_t	dd_cfbaddr;	/* 0x3c CFB address, location of
						X11 driver to be used for
						servers w/o accel */
	u_int32_t	dd_pacode[16];	/* 0x40 routines for pa-risc */
	u_int32_t	dd_altcode[16];	/* 0x80 routines for m68k/i386 */
} __packed;

#define	STI_REVISION(maj, min)	(((maj) << 4) | ((min) & 0x0f))

/* after the last region there is one indirect list ptr */
struct sti_region {
	u_int	offset  :14;	/* page offset dev io space relative */
	u_int	sys_only: 1;	/* whether allow user access */
	u_int	cache   : 1;	/* map in cache */
	u_int	btlb    : 1;	/* should use BTLB if available */
	u_int	last    : 1;	/* last region in the list */
	u_int	length  :14;	/* size in pages */
}  __packed;

struct sti_font {
	u_int16_t	first;
	u_int16_t	last;
	u_int8_t	width;
	u_int8_t	height;
	u_int8_t	type;
#define	STI_FONT_HPROMAN8	1
#define	STI_FONT_KANA8		2
	u_int8_t	bpc;
	u_int32_t	next;
	u_int8_t	uheight;
	u_int8_t	uoffset;
	u_int8_t	unused[2];
}  __packed;

struct sti_fontcfg {
	u_int16_t	first;
	u_int16_t	last;
	u_int8_t	width;
	u_int8_t	height;
	u_int8_t	type;
	u_int8_t	bpc;
	u_int8_t	uheight;
	u_int8_t	uoffset;
}  __packed;

typedef struct sti_mon {
	u_int32_t	width: 12;
	u_int32_t	height: 12;
	u_int32_t	hz: 7;		/* low 7 bits of refresh rate */
	u_int32_t	flat: 1;	/* flatpanel */
	u_int32_t	vesa: 1;	/* vesa mode */
	u_int32_t	grey: 1;	/* greyscale */
	u_int32_t	dblbuf: 1;	/* double buffered */
	u_int32_t	user: 1;	/* user-defined mode */
	u_int32_t	stereo: 1;	/* stereo display */
	u_int32_t	sam: 1;		/* ? */
	u_int32_t	: 15;
	u_int32_t	hz_upper: 3;	/* upper 3 bits of refresh rate */
	u_int32_t	font: 8;	/* rom font index */
} __packed *sti_mon_t;

typedef struct sti_ecfg {
	u_int8_t	current_monitor;
	u_int8_t	uf_boot;
	u_int16_t	power;		/* power dissipation Watts */
	u_int32_t	freq_ref;
	u_int32_t	*addr;		/* memory block of size dd_stimemreq */
	void		*future;
} __packed *sti_ecfg_t;

typedef struct sti_cfg {
	u_int32_t	text_planes;
	u_int16_t	scr_width;
	u_int16_t	scr_height;
	u_int16_t	oscr_width;
	u_int16_t	oscr_height;
	u_int16_t	fb_width;
	u_int16_t	fb_height;
	u_int32_t	regions[STI_REGION_MAX];
	u_int32_t	reent_level;
	u_int32_t	*save_addr;
	sti_ecfg_t	ext_cfg;
}  __packed *sti_cfg_t;


/* routine types */
#define	STI_DEP(n) \
	typedef int (*sti_##n##_t)( \
	  sti_##n##flags_t, sti_##n##in_t, sti_##n##out_t, sti_cfg_t);

typedef struct sti_initflags {
	u_int32_t	flags;
#define	STI_INITF_WAIT	0x80000000
#define	STI_INITF_RESET	0x40000000
#define	STI_INITF_TEXT	0x20000000
#define	STI_INITF_NTEXT	0x10000000
#define	STI_INITF_CLEAR	0x08000000
#define	STI_INITF_CMB	0x04000000	/* non-text planes cmap black */
#define	STI_INITF_EBET	0x02000000	/* enable bus error timer */
#define	STI_INITF_EBETI	0x01000000	/* enable bus error timer interrupt */
#define	STI_INITF_PTS	0x00800000	/* preserve text settings */
#define	STI_INITF_PNTS	0x00400000	/* preserve non-text settings */
#define	STI_INITF_PBET	0x00200000	/* preserve BET settings */
#define	STI_INITF_PBETI	0x00100000	/* preserve BETI settings */
#define	STI_INITF_ICMT	0x00080000	/* init cmap for text planes */
#define	STI_INITF_SCMT	0x00040000	/* change current monitor type */
#define	STI_INITF_RIE	0x00020000	/* retain int enables */
	void *future;
} __packed *sti_initflags_t;

typedef struct sti_einitin {
	u_int8_t	mon_type;
	u_int8_t	pad;
	u_int16_t	inflight;	/* possible on pci */
	void		*future;
} __packed *sti_einitin_t;

typedef struct sti_initin {
	u_int32_t	text_planes;	/* number of planes for text */
	sti_einitin_t	ext_in;
} __packed *sti_initin_t;

typedef struct sti_initout {
	int32_t		errno;
	u_int32_t	text_planes;	/* number of planes used for text */
	void		*future;
} __packed *sti_initout_t;

STI_DEP(init);

typedef struct sti_mgmtflags {
	u_int32_t	flags;
#define	STI_MGMTF_WAIT	0x80000000
#define	STI_MGMTF_SAVE	0x40000000
#define	STI_MGMTF_RALL	0x20000000	/* restore all display planes */
	void *future;
} __packed *sti_mgmtflags_t;

typedef struct sti_mgmtin {
	void	*addr;
	void	*future;
} __packed *sti_mgmtin_t;

typedef struct sti_mgmtout {
	int32_t		errno;
	void		*future;
} __packed *sti_mgmtout_t;

STI_DEP(mgmt);

typedef struct sti_unpmvflags {
	u_int32_t	flags;
#define	STI_UNPMVF_WAIT	0x80000000
#define	STI_UNPMVF_NTXT	0x40000000	/* intp non-text planes */
	void		*future;
} __packed *sti_unpmvflags_t;

typedef struct sti_unpmvin {
	u_int32_t	*font_addr;	/* font */
	u_int16_t	index;		/* character index in the font */
	u_int8_t	fg_colour;
	u_int8_t	bg_colour;
	u_int16_t	x, y;
	void		*future;
} __packed *sti_unpmvin_t;

typedef struct sti_unpmvout {
	u_int32_t	errno;
	void		*future;
} __packed *sti_unpmvout_t;

STI_DEP(unpmv);

typedef struct sti_blkmvflags {
	u_int32_t	flags;
#define	STI_BLKMVF_WAIT	0x80000000
#define	STI_BLKMVF_COLR	0x40000000	/* change colour on move */
#define	STI_BLKMVF_CLR	0x20000000	/* clear on move */
#define	STI_BLKMVF_NTXT	0x10000000	/* move in non-text planes */
	void		*future;
} __packed *sti_blkmvflags_t;

typedef struct sti_blkmvin {
	u_int8_t	fg_colour;
	u_int8_t	bg_colour;
	u_int16_t	srcx, srcy, dstx, dsty;
	u_int16_t	width, height;
	u_int16_t	pad;
	void		*future;
} __packed *sti_blkmvin_t;

typedef struct sti_blkmvout {
	u_int32_t	errno;
	void		*future;
} __packed *sti_blkmvout_t;

STI_DEP(blkmv);

typedef struct sti_testflags {
	u_int32_t	flags;
#define	STI_TESTF_WAIT	0x80000000
#define	STI_TESTF_ETST	0x40000000
	void		*future;
} __packed *sti_testflags_t;

typedef struct sti_testin {
	void		*future;
} __packed *sti_testin_t;

typedef struct sti_testout {
	u_int32_t	errno;
	u_int32_t	result;
	void		*future;
} __packed *sti_testout_t;

STI_DEP(test);

typedef struct sti_exhdlflags {
	u_int32_t	flags;
#define	STI_EXHDLF_WAIT	0x80000000
#define	STI_EXHDLF_CINT	0x40000000	/* clear int */
#define	STI_EXHDLF_CBE	0x20000000	/* clear BE */
#define	STI_EXHDLF_PINT	0x10000000	/* preserve int */
#define	STI_EXHDLF_RINT	0x08000000	/* restore int */
#define	STI_EXHDLF_WEIM	0x04000000	/* write eim w/ sti_eexhdlin */
#define	STI_EXHDLF_REIM	0x02000000	/* read eim to sti_eexhdlout */
#define	STI_EXHDLF_GIE	0x01000000	/* global int enable */
#define	STI_EXHDLF_PGIE	0x00800000
#define	STI_EXHDLF_WIEM	0x00400000
#define	STI_EXHDLF_EIEM	0x00200000
#define	STI_EXHDLF_BIC	0x00100000	/* begin int cycle */
#define	STI_EXHDLF_EIC	0x00080000	/* end int cycle */
#define	STI_EXHDLF_RIE	0x00040000	/* reset do not clear int enables */
	void		*future;
} __packed *sti_exhdlflags_t;

typedef struct sti_eexhdlin {
	u_int32_t	eim_addr;
	u_int32_t	eim_data;
	u_int32_t	iem;		/* enable mask */
	u_int32_t	icm;		/* clear mask */
	void		*future;
} __packed *sti_eexhdlin_t;

typedef struct sti_exhdlint {
	u_int32_t	flags;
#define	STI_EXHDLINT_BET	0x80000000	/* bus error timer */
#define	STI_EXHDLINT_HW		0x40000000	/* high water */
#define	STI_EXHDLINT_LW		0x20000000	/* low water */
#define	STI_EXHDLINT_TM		0x10000000	/* texture map */
#define	STI_EXHDLINT_VB		0x08000000	/* vertical blank */
#define	STI_EXHDLINT_UDC	0x04000000	/* unbuffered dma complete */
#define	STI_EXHDLINT_BDC	0x02000000	/* buffered dma complete */
#define	STI_EXHDLINT_UDPC	0x01000000	/* unbuf priv dma complete */
#define	STI_EXHDLINT_BDPC	0x00800000	/* buffered priv dma complete */
} __packed *sti_exhdlint_t;

typedef struct sti_exhdlin {
	sti_exhdlint_t	addr;
	sti_eexhdlin_t	ext;
} __packed *sti_exhdlin_t;

typedef struct sti_eexhdlout {
	u_int32_t	eim_addr;
	u_int32_t	eim_data;
	u_int32_t	iem;		/* enable mask */
	u_int32_t	icm;		/* clear mask */
	void		*future;
} __packed *sti_eexhdlout_t;

typedef struct sti_exhdlout {
	u_int32_t	errno;
	u_int32_t	flags;
#define	STI_EXHDLO_BE	0x80000000	/* BE was intercepted */
#define	STI_EXHDLO_IP	0x40000000	/* there is int pending */
#define	STI_EXHDLO_IE	0x20000000	/* global enable set */
	sti_eexhdlout_t	ext;
} __packed *sti_exhdlout_t;

STI_DEP(exhdl);

typedef struct sti_inqconfflags {
	u_int32_t	flags;
#define	STI_INQCONFF_WAIT	0x80000000
	void		*future;
} __packed *sti_inqconfflags_t;

typedef struct sti_inqconfin {
	void	*future;
} __packed *sti_inqconfin_t;

typedef struct sti_einqconfout {
	u_int32_t	crt_config[3];
	u_int32_t	crt_hw[3];
	void		*future;
} __packed *sti_einqconfout_t;

typedef struct sti_inqconfout {
	u_int32_t	errno;
	u_int16_t	width, height, owidth, oheight, fbwidth, fbheight;
	u_int32_t	bpp;	/* bits per pixel */
	u_int32_t	bppu;	/* accessible bpp */
	u_int32_t	planes;
	u_int8_t	name[STI_DEVNAME_LEN];
	u_int32_t	attributes;
#define	STI_INQCONF_Y2X		0x0001	/* pixel is higher than wider */
#define	STI_INQCONF_HWBLKMV	0x0002	/* hw blkmv is present */
#define	STI_INQCONF_AHW		0x0004	/* adv hw accel */
#define	STI_INQCONF_INT		0x0008	/* can interrupt */
#define	STI_INQCONF_GONOFF	0x0010	/* supports on/off */
#define	STI_INQCONF_AONOFF	0x0020	/* supports alpha on/off */
#define	STI_INQCONF_VARY	0x0040	/* variable fb height */
#define	STI_INQCONF_ODDBYTES	0x0080	/* use only odd fb bytes */
#define	STI_INQCONF_FLUSH	0x0100	/* fb cache requires flushing */
#define	STI_INQCONF_DMA		0x0200	/* supports dma */
#define	STI_INQCONF_VDMA	0x0400	/* supports vdma */
#define	STI_INQCONF_YUV1	0x2000	/* supports YUV type 1 */
#define	STI_INQCONF_YUV2	0x4000	/* supports YUV type 2 */
#define	STI_INQCONF_BITS \
    "\020\001y2x\002hwblkmv\003ahw\004int\005gonoff\006aonoff\007vary"\
    "\010oddb\011flush\012dma\013vdma\016yuv1\017yuv2"
	sti_einqconfout_t ext;
} __packed *sti_inqconfout_t;

STI_DEP(inqconf);

typedef struct sti_scmentflags {
	u_int32_t	flags;
#define	STI_SCMENTF_WAIT	0x80000000
	void		*future;
} __packed *sti_scmentflags_t;

typedef struct sti_scmentin {
	u_int32_t	entry;
	u_int32_t	value;
	void		*future;
} __packed *sti_scmentin_t;

typedef struct sti_scmentout {
	u_int32_t	errno;
	void		*future;
} __packed *sti_scmentout_t;

STI_DEP(scment);

typedef struct sti_dmacflags {
	u_int32_t	flags;
#define	STI_DMACF_WAIT	0x80000000
#define	STI_DMACF_PRIV	0x40000000	/* priv dma */
#define	STI_DMACF_DIS	0x20000000	/* disable */
#define	STI_DMACF_BUF	0x10000000	/* buffered */
#define	STI_DMACF_MRK	0x08000000	/* write a marker */
#define	STI_DMACF_ABRT	0x04000000	/* abort dma xfer */
	void		*future;
} __packed *sti_dmacflags_t;

typedef struct sti_dmacin {
	u_int32_t	pa_upper;
	u_int32_t	pa_lower;
	u_int32_t	len;
	u_int32_t	mrk_data;
	u_int32_t	mrk_off;
	void		*future;
} __packed *sti_dmacin_t;

typedef struct sti_dmacout {
	u_int32_t	errno;
	void		*future;
} __packed *sti_dmacout_t;

STI_DEP(dmac);

typedef struct sti_flowcflags {
	u_int32_t	flags;
#define	STI_FLOWCF_WAIT	0x80000000
#define	STI_FLOWCF_CHW	0x40000000	/* check high water */
#define	STI_FLOWCF_WHW	0x20000000	/* write high water */
#define	STI_FLOWCF_WLW	0x10000000	/* write low water */
#define	STI_FLOWCF_PCSE	0x08000000	/* preserve cse */
#define	STI_FLOWCF_CSE	0x04000000
#define	STI_FLOWCF_CSWF	0x02000000	/* cs write fine */
#define	STI_FLOWCF_CSWC	0x01000000	/* cs write coarse */
#define	STI_FLOWCF_CSWQ	0x00800000	/* cs write fifo */
	void		*future;
} __packed *sti_flowcflags_t;

typedef struct sti_flowcin {
	u_int32_t	retry;
	u_int32_t	bufz;
	u_int32_t	hwcnt;
	u_int32_t	lwcnt;
	u_int32_t	csfv;	/* cs fine value */
	u_int32_t	cscv;	/* cs coarse value */
	u_int32_t	csqc;	/* cs fifo count */
	void		*future;
} __packed *sti_flowcin_t;

typedef struct sti_flowcout {
	u_int32_t	errno;
	u_int32_t	retry_result;
	u_int32_t	fifo_size;
	void		*future;
} __packed *sti_flowcout_t;

STI_DEP(flowc);

typedef struct sti_utimingflags {
	u_int32_t	flags;
#define	STI_UTIMF_WAIT	0x80000000
#define	STI_UTIMF_HKS	0x40000000	/* has kbuf_size */
	void		*future;
} __packed *sti_utimingflags_t;

typedef struct sti_utimingin {
	void		*data;
	void		*kbuf;
	void		*future;
} __packed *sti_utimingin_t;

typedef struct sti_utimingout {
	u_int32_t	errno;
	u_int32_t	kbuf_size;	/* buffer required size */
	void		*future;
} __packed *sti_utimingout_t;

STI_DEP(utiming);

typedef struct sti_pmgrflags {
	u_int32_t	flags;
#define	STI_UTIMF_WAIT	0x80000000
#define	STI_UTIMOP_CLEANUP	0x00000000
#define	STI_UTIMOP_BAC		0x10000000
#define	STI_UTIMF_CRIT	0x04000000
#define	STI_UTIMF_BUFF	0x02000000
#define	STI_UTIMF_IBUFF	0x01000000
	void		*future;
} __packed *sti_pmgrflags_t;

typedef struct sti_pmgrin {
	u_int32_t	reserved[4];
	void		*future;
} __packed *sti_pmgrin_t;

typedef struct sti_pmgrout {
	int32_t		errno;
	void		*future;
} __packed *sti_pmgrout_t;

STI_DEP(pmgr);

typedef struct sti_utilflags {
	u_int32_t	flags;
#define	STI_UTILF_ROOT	0x80000000	/* was called as root */
	void		*future;
} __packed *sti_utilflags_t;

typedef struct sti_utilin {
	u_int32_t	in_size;
	u_int32_t	out_size;
	u_int8_t	*buf;
} __packed *sti_utilin_t;

typedef struct sti_utilout {
	int32_t		errno;
	void		*future;
} __packed *sti_utilout_t;

STI_DEP(util);

/*
 * NGLE register layout.
 * Based upon xc/programs/Xserver/hw/hp/ngle/dregs.h
 */
#define	NGLE_REG_1		0x000118
#define	NGLE_REG_28		0x000420
#define	NGLE_REG_2		0x000480
#define	NGLE_REG_3		0x0004a0	/* palette index */
#define	NGLE_REG_22		0x0005a0
#define	NGLE_REG_23		0x0005c0
#define	NGLE_REG_4		0x000600	/* palette data */
#define	NGLE_REG_5		0x0006a0	/* cursor data */
#define	NGLE_REG_6		0x000800
#define	NGLE_REG_7		0x000804
#define	NGLE_REG_24		0x000808
#define	NGLE_REG_8		0x000820
#define	NGLE_REG_73		0x000944
#define	NGLE_REG_9		0x000a04
#define	NGLE_REG_25		0x000b00
#define	NGLE_REG_RAMDAC		0x001000
#define	NGLE_REG_10		0x018000
#define	NGLE_REG_11		0x018004	/* dest coords */
#define	NGLE_REG_12		0x01800c	/* control plane register */
#define	NGLE_REG_35		0x018010	/* fg color */
#define	NGLE_REG_36		0x018014
#define	NGLE_REG_13		0x018018	/* image planemask */
#define	NGLE_REG_14		0x01801c	/* raster op */
#define	NGLE_REG_15		0x200000
#define	NGLE_REG_15b0		0x200000	/* busy register */
#define	NGLE_REG_16		0x200004
#define	NGLE_REG_16b1		0x200005
#define	NGLE_REG_16b3		0x200007
#define	NGLE_REG_34		0x200008	/* # of fifo slots */
#define	NGLE_REG_17		0x200100	/* cursor coordinates */
#define	NGLE_REG_18		0x200104	/* cursor enable */
#define	NGLE_REG_26		0x200118
#define	NGLE_REG_19		0x200200
#define	NGLE_REG_20		0x200208	/* cursor geometry */
#define	NGLE_REG_21		0x200218	/* Artist misc video */
#define	NGLE_REG_27		0x200308	/* Artist misc ctrl */
#define	NGLE_REG_29		0x210000	/* HCRX cursor coord & enable */
#define	NGLE_REG_30		0x210004	/* HCRX cursor address */
#define	NGLE_REG_31		0x210008	/* HCRX cursor data */
#define	NGLE_REG_38		0x210020	/* colormap data */
#define	NGLE_REG_41		0x210024
#define	NGLE_REG_42		0x210028
#define	NGLE_REG_43		0x21002c
#define	NGLE_REG_44		0x210030
#define	NGLE_REG_45		0x210034
#define	NGLE_REG_32		0x21003c
#define	NGLE_REG_33		0x210040	/* HCRX misc video */
#define	NGLE_REG_39		0x210120
#define	NGLE_REG_40		0x210130

#define	NGLE_BUFF0_CMAP0	0x00001e02
#define	NGLE_BUFF1_CMAP0	0x02001e02
#define	NGLE_BUFF1_CMAP3	0x0c001e02
#define	NGLE_ARTIST_CMAP0	0x00000102

#endif /* _IC_STIREG_H_ */
@


1.13
log
@If the rom contains a monitor table, look for an entry matching our
display resolution, and if one is found, pick the built-in font it points
to, instead of the first font from the list. If the index is wrong and the
font list is shorter, revert to the previous behaviour of using the first
ROM font.

This fixes the font discrepency on my B132L (INTERNAL_EG_1280) where PDC
would use the 10x20 font, which is third in the list, and OpenBSD would
use the 8x16 font instead.

Tested on byte- and word- roms, gsc and pci cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.12 2008/09/01 17:30:56 deraadt Exp $	*/
d124 13
d632 59
@


1.12
log
@Avoid #pragma pack(1) and unify everything towards using __packed.
This requires that structures defined within __packed structures must
independently request that they themselves become __packed, too.
worked on with toby
 CVS: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.11 2005/10/29 11:54:07 miod Exp $	*/
d130 1
a130 2
	u_int32_t	dd_montbl;	/* 0x24 mon table address, array of
						names num of dd_nmon */
d195 16
@


1.11
log
@Correct type for dd_grid, so that we print the device id correctly for
byte-mode roms.
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.10 2005/01/24 19:20:04 miod Exp $	*/
a113 2
#pragma pack(1)

d157 1
a157 1
};
d169 1
a169 1
};
d184 1
a184 1
};
d195 1
a195 1
};
d204 1
a204 1
} *sti_ecfg_t;
d218 1
a218 1
} *sti_cfg_t;
d244 1
a244 1
} *sti_initflags_t;
d251 1
a251 1
} *sti_einitin_t;
d256 1
a256 1
} *sti_initin_t;
d262 1
a262 1
} *sti_initout_t;
d272 1
a272 1
} *sti_mgmtflags_t;
d277 1
a277 1
} *sti_mgmtin_t;
d282 1
a282 1
} *sti_mgmtout_t;
d291 1
a291 1
} *sti_unpmvflags_t;
d300 1
a300 1
} *sti_unpmvin_t;
d305 1
a305 1
} *sti_unpmvout_t;
d316 1
a316 1
} *sti_blkmvflags_t;
d325 1
a325 1
} *sti_blkmvin_t;
d330 1
a330 1
} *sti_blkmvout_t;
d339 1
a339 1
} *sti_testflags_t;
d343 1
a343 1
} *sti_testin_t;
d349 1
a349 1
} *sti_testout_t;
d370 1
a370 1
} *sti_exhdlflags_t;
d378 1
a378 1
} *sti_eexhdlin_t;
d391 1
a391 1
} *sti_exhdlint_t;
d396 1
a396 1
} *sti_exhdlin_t;
d404 1
a404 1
} *sti_eexhdlout_t;
d413 1
a413 1
} *sti_exhdlout_t;
d421 1
a421 1
} *sti_inqconfflags_t;
d425 1
a425 1
} *sti_inqconfin_t;
d431 1
a431 1
} *sti_einqconfout_t;
d458 1
a458 1
} *sti_inqconfout_t;
d466 1
a466 1
} *sti_scmentflags_t;
d472 1
a472 1
} *sti_scmentin_t;
d477 1
a477 1
} *sti_scmentout_t;
d490 1
a490 1
} *sti_dmacflags_t;
d499 1
a499 1
} *sti_dmacin_t;
d504 1
a504 1
} *sti_dmacout_t;
d520 1
a520 1
} *sti_flowcflags_t;
d531 1
a531 1
} *sti_flowcin_t;
d538 1
a538 1
} *sti_flowcout_t;
d547 1
a547 1
} *sti_utimingflags_t;
d553 1
a553 1
} *sti_utimingin_t;
d559 1
a559 1
} *sti_utimingout_t;
d572 1
a572 1
} *sti_pmgrflags_t;
d577 1
a577 1
} *sti_pmgrin_t;
d582 1
a582 1
} *sti_pmgrout_t;
d590 1
a590 1
} *sti_utilflags_t;
d596 1
a596 1
} *sti_utilin_t;
d601 1
a601 1
} *sti_utilout_t;
a603 2

#pragma pack()
@


1.10
log
@sti colormap fixes:
- correct bounds checking in colormap ioctls.
- force the scment() pointer to NULL on < 8.04 revisions; 8.02 provide a
  non-NULL pointer, but it does not point to any meaningful piece of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.9 2005/01/23 16:53:21 miod Exp $	*/
d74 1
a74 1
#define	STI_ILLINDEX		4	/* invalid fond index */
d79 1
a79 1
#define	STI_ILLBLKMVSIZE	9	/* invalid siz in blkmv */
d125 1
a125 1
	u_int8_t	dd_grid[8];	/* 0x08 graphics id */
d443 1
a443 1
#define	STI_INQCONF_Y2X		0x0001	/* pixel is higher tan wider */
@


1.9
log
@Two sti(4) changes necessary for hp300:
- specify which microcode bank (pa or m68k) to use at attachment time.
- compensate for broken 8.02 m68k code which reports wrong frame buffer
  offset.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.8 2003/08/19 02:52:38 mickey Exp $	*/
d160 2
@


1.8
log
@implement WSDISPLAYIO_{GET,PUT}CMAP; untested
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.7 2003/08/19 02:25:11 mickey Exp $	*/
d56 7
@


1.7
log
@inquire ext config and dump it in debugging and also fix other debugging prints
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.6 2003/06/02 19:24:22 mickey Exp $	*/
d37 1
@


1.6
log
@kill the caluses three and four on some of my code
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.5 2003/01/31 17:00:19 miod Exp $	*/
d433 16
@


1.5
log
@Working wscons attachment and block move operations; joint debug by mickey
and myself.
wsdisplay at sti will be enabled as soon as byte-size rom font loading is done.
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.4 2002/03/14 01:26:55 millert Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.3 2001/01/11 21:30:30 mickey Exp $	*/
d320 1
@


1.3
log
@no stidebug
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.2 2001/01/11 21:23:53 mickey Exp $	*/
d220 2
a221 2
	typedef int (*sti_##n##_t) __P(( \
	  sti_##n##flags_t, sti_##n##in_t, sti_##n##out_t, sti_cfg_t));
@


1.3.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.3 2001/01/11 21:30:30 mickey Exp $	*/
d220 2
a221 2
	typedef int (*sti_##n##_t)( \
	  sti_##n##flags_t, sti_##n##in_t, sti_##n##out_t, sti_cfg_t);
@


1.3.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a319 1
	u_int16_t	pad;
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.3 2001/01/11 21:30:30 mickey Exp $	*/
@


1.3.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d220 2
a221 2
	typedef int (*sti_##n##_t)( \
	  sti_##n##flags_t, sti_##n##in_t, sti_##n##out_t, sti_cfg_t);
@


1.3.4.3
log
@Sync the SMP branch with 3.3
@
text
@a319 1
	u_int16_t	pad;
@


1.3.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.3.4.3 2003/03/28 00:38:15 niklas Exp $	*/
d15 5
@


1.3.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 1
#define	STI_NCMAP	256
a432 16
#define	STI_INQCONF_Y2X		0x0001	/* pixel is higher tan wider */
#define	STI_INQCONF_HWBLKMV	0x0002	/* hw blkmv is present */
#define	STI_INQCONF_AHW		0x0004	/* adv hw accel */
#define	STI_INQCONF_INT		0x0008	/* can interrupt */
#define	STI_INQCONF_GONOFF	0x0010	/* supports on/off */
#define	STI_INQCONF_AONOFF	0x0020	/* supports alpha on/off */
#define	STI_INQCONF_VARY	0x0040	/* variable fb height */
#define	STI_INQCONF_ODDBYTES	0x0080	/* use only odd fb bytes */
#define	STI_INQCONF_FLUSH	0x0100	/* fb cache requires flushing */
#define	STI_INQCONF_DMA		0x0200	/* supports dma */
#define	STI_INQCONF_VDMA	0x0400	/* supports vdma */
#define	STI_INQCONF_YUV1	0x2000	/* supports YUV type 1 */
#define	STI_INQCONF_YUV2	0x4000	/* supports YUV type 2 */
#define	STI_INQCONF_BITS \
    "\020\001y2x\002hwblkmv\003ahw\004int\005gonoff\006aonoff\007vary"\
    "\010oddb\011flush\012dma\013vdma\016yuv1\017yuv2"
@


1.2
log
@fix a few types and alignment problems
@
text
@d1 1
a1 1
/*	$OpenBSD: stireg.h,v 1.1 2000/05/30 19:39:38 mickey Exp $	*/
d34 2
a35 2
#ifndef _STI_H_
#define _STI_H_
d37 1
a37 1
#define	STIDEBUG
d587 1
a587 1
#endif /* _STI_H_ */
@


1.1
log
@sti hp graphics, available in pci and hp-prop sgc bus form factors.
attach point for wsdisplay.
a few problems may exist w/ certain prom versions.
tested in byte- and word-wide modes.
no support yet for multiple resolutions and fonts.
pci not tested (obviously).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 2
d134 1
a134 1
	u_int32_t	dd_pwruse;	/* 0x34 power usage */
d211 1
a211 1
	u_int32_t	*regions[STI_REGION_MAX];
d584 2
@

