head	1.12;
access;
symbols
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.14
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.8
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.10
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.10.0.14
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.12
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.6
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.12
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.14
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9;
locks; strict;
comment	@ * @;


1.12
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.14.12.21.13;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.08.16.36.33;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.24.20.45.33;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.07.21.39.32;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.29.11.41.34;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.24.19.20.01;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.21.23.16.34;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.17.19.40.39;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.17.10.31.26;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.15.20.07.31;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.15.19.55.47;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@/*	$OpenBSD: malo.h,v 1.11 2013/11/14 12:21:13 dlg Exp $ */

/*
 * Copyright (c) 2006 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2006 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

struct malo_rx_desc;
struct malo_rx_data;

struct malo_rx_ring {
	bus_dmamap_t		map;
	bus_dma_segment_t	seg;
	bus_addr_t		physaddr;
	struct malo_rx_desc	*desc;
	struct malo_rx_data	*data;
	int			count;
	int			cur;
	int			next;
};

struct malo_tx_desc;
struct malo_tx_data;

struct malo_tx_ring {
	bus_dmamap_t		map;
	bus_dma_segment_t	seg;
	bus_addr_t		physaddr;
	struct malo_tx_desc	*desc;
	struct malo_tx_data	*data;
	int			count;
	int			queued;
	int			cur;
	int			next;
	int			stat;
};

#define MALO_RX_RADIOTAP_PRESENT					\
	((1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL) |				\
	 (1 << IEEE80211_RADIOTAP_RSSI))

struct malo_rx_radiotap_hdr {
	struct ieee80211_radiotap_header	wr_ihdr;
	uint8_t					wr_flags;
	uint16_t				wr_chan_freq;
	uint16_t				wr_chan_flags;
	uint8_t					wr_rssi;
	uint8_t					wr_max_rssi;
} __packed;

#define MALO_TX_RADIOTAP_PRESENT					\
	((1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_RATE) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL))

struct malo_tx_radiotap_hdr {
	struct ieee80211_radiotap_header	wt_ihdr;
	uint8_t					wt_flags;
	uint8_t					wt_rate;
	uint16_t				wt_chan_freq;
	uint16_t				wt_chan_flags;
} __packed;

struct malo_softc {
	struct device		sc_dev;
	struct ieee80211com	sc_ic;
	struct malo_rx_ring	sc_rxring;
	struct malo_tx_ring	sc_txring;

	bus_dma_tag_t		sc_dmat;
	bus_space_tag_t		sc_mem1_bt;
	bus_space_tag_t		sc_mem2_bt;
	bus_space_handle_t	sc_mem1_bh;
	bus_space_handle_t	sc_mem2_bh;

	bus_dmamap_t		sc_cmd_dmam;
	bus_dma_segment_t	sc_cmd_dmas;
	void			*sc_cmd_mem;
	bus_addr_t		sc_cmd_dmaaddr;
	uint32_t		*sc_cookie;
	bus_addr_t		sc_cookie_dmaaddr;

	uint32_t		sc_RxPdWrPtr;
	uint32_t		sc_RxPdRdPtr;

	int			(*sc_newstate)
				(struct ieee80211com *,
				 enum ieee80211_state, int);

	int			(*sc_enable)(struct malo_softc *);
	void			(*sc_disable)(struct malo_softc *);

	struct timeout		sc_scan_to;
	int			sc_tx_timer;
	int			sc_last_txrate;

#if NBPFILTER > 0
	caddr_t		sc_drvbpf;

	union {
		struct malo_rx_radiotap_hdr th;
		uint8_t pad[64];
	}		sc_rxtapu;
#define sc_rxtap	sc_rxtapu.th
	int		sc_rxtap_len;

	union {
		struct malo_tx_radiotap_hdr th;
		uint8_t pad[64];
	}		sc_txtapu;
#define sc_txtap	sc_txtapu.th
	int		sc_txtap_len;
#endif
};

int malo_intr(void *arg);
int malo_attach(struct malo_softc *sc);
int malo_detach(void *arg);
int malo_init(struct ifnet *);
void malo_stop(struct malo_softc *);
@


1.11
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.h,v 1.10 2010/08/08 16:36:33 deraadt Exp $ */
a126 1
	struct task	sc_resume_t;
@


1.10
log
@activate function for suspend/restore; from mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.h,v 1.9 2006/11/24 20:45:33 mglocker Exp $ */
d127 1
a127 1
	struct workq_task	sc_resume_wqt;
@


1.9
log
@Enable automatic rate adapation (done by firmware and hardware).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.h,v 1.8 2006/11/07 21:39:32 mglocker Exp $ */
d127 1
d133 2
@


1.8
log
@Add TX done cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.h,v 1.7 2006/10/29 11:41:34 mglocker Exp $ */
d108 1
@


1.7
log
@Add first TX path and active scan bits.  Don't expect to much yet.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.h,v 1.6 2006/10/24 19:20:01 mglocker Exp $ */
d107 1
@


1.6
log
@Fix RX DMA handling; until now the card stopped receiving interrupts
after it went one time through the RX ring (256 descriptors).  Also
reset RX rings correctly after ifconfig down / up.

"COMMIT IT!!!" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.h,v 1.5 2006/10/21 23:16:34 mglocker Exp $ */
d5 1
d105 2
@


1.5
log
@Fix RX handling; the chip injects control data in front and between
a 802.11 frame which needs to be cut off.  Looks like we receive
the first correct looking management frames now.

Add first radio bpf mtap bits but don't activate them in the RX handler
yet.  Need first to find out which radio data the card delivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.h,v 1.4 2006/10/17 19:40:39 claudio Exp $ */
d94 3
@


1.4
log
@Allocate and free TX DMA rings additionally change some of the structures to
match more the actual reality. Still unsure about it as we don't have any
documentation to verify against. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.h,v 1.3 2006/10/17 10:31:26 claudio Exp $ */
d49 27
d101 18
@


1.3
log
@Allocate and free RX DMA ring. Mostly form rt2661.c with adaption for malo.
Seems to fit pretty well. Does not do anything useful right now. The bits
in the interrupt handler and of course the TX ring are still missing.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.h,v 1.2 2006/10/15 20:07:31 claudio Exp $ */
d33 16
d52 2
a53 2
	struct malo_rx_ring	sc_rxring0;
	struct malo_rx_ring	sc_rxring1;
@


1.2
log
@Add $OpenBSD$ tag
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d19 14
d36 2
a57 4
};

struct malo_node {
	struct ieee80211_node	ni;
@


1.1
log
@First stubs for a new driver for the Marvell Libertas chips.
The card correctly loads the firmware and it is possible to send a few
simple commands to the card but that's it. No packet are sent or received.
Only the Netgear WG511v2 cardbus card is tested.
A cheese fondue and a bigger amount of white wine was needed to make the
interrupts work -- until last night the driver was uploading the firmware
to fast and the card garbled the image without moaning. It took us a full
day and hundreds of test kernels to figure that out.
Joint work with mglocker@@, fondue by mbalmer@@
OK mglocker@@, get it in deraadt@@
@
text
@d1 2
@

