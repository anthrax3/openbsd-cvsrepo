head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.8
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.6
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.32
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.34
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.30
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.28
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.26
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.24
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.22
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.20
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.18
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.6
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.05.11.02.01.01;	author guenther;	state Exp;
branches;
next	1.13;
commitid	erjAmqwRafm6pspM;

1.13
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.12;
commitid	C5iGb36LQxjM60Q3;

1.12
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.11;
commitid	uzzBR7hz9ncd4O6G;

1.11
date	2013.12.09.04.21.58;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.12.19.07.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2012.01.11.16.22.33;	author dhill;	state Exp;
branches;
next	1.8;

1.8
date	2011.09.17.08.36.06;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.08.06.00.00.41;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.21.17.41.02;	author mickey;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	99.01.07.15.55.54;	author niklas;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	97.09.02.01.16.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.11.30.00.53.35;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2001.05.14.22.23.58;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Convert from uiomovei() to uiomove() to prevent short tranfers

diff from natano@@bitrig
@
text
@/*	$OpenBSD: lpt.c,v 1.13 2015/02/10 21:56:09 miod Exp $ */
/*	$NetBSD: lpt.c,v 1.42 1996/10/21 22:41:14 thorpej Exp $	*/

/*
 * Copyright (c) 1993, 1994 Charles Hannum.
 * Copyright (c) 1990 William F. Jolitz, TeleMuse
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This software is a component of "386BSD" developed by 
 *	William F. Jolitz, TeleMuse.
 * 4. Neither the name of the developer nor the name "386BSD"
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS A COMPONENT OF 386BSD DEVELOPED BY WILLIAM F. JOLITZ 
 * AND IS INTENDED FOR RESEARCH AND EDUCATIONAL PURPOSES ONLY. THIS 
 * SOFTWARE SHOULD NOT BE CONSIDERED TO BE A COMMERCIAL PRODUCT. 
 * THE DEVELOPER URGES THAT USERS WHO REQUIRE A COMMERCIAL PRODUCT 
 * NOT MAKE USE OF THIS WORK.
 *
 * FOR USERS WHO WISH TO UNDERSTAND THE 386BSD SYSTEM DEVELOPED
 * BY WILLIAM F. JOLITZ, WE RECOMMEND THE USER STUDY WRITTEN 
 * REFERENCES SUCH AS THE  "PORTING UNIX TO THE 386" SERIES 
 * (BEGINNING JANUARY 1991 "DR. DOBBS JOURNAL", USA AND BEGINNING 
 * JUNE 1991 "UNIX MAGAZIN", GERMANY) BY WILLIAM F. JOLITZ AND 
 * LYNNE GREER JOLITZ, AS WELL AS OTHER BOOKS ON UNIX AND THE 
 * ON-LINE 386BSD USER MANUAL BEFORE USE. A BOOK DISCUSSING THE INTERNALS 
 * OF 386BSD ENTITLED "386BSD FROM THE INSIDE OUT" WILL BE AVAILABLE LATE 1992.
 *
 * THIS SOFTWARE IS PROVIDED BY THE DEVELOPER ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPER BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Device Driver for AT parallel printer port
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/uio.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/syslog.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/ic/lptreg.h>
#include <dev/ic/lptvar.h>

#include "lpt.h"

#define	TIMEOUT		hz*16	/* wait up to 16 seconds for a ready */
#define	STEP		hz/4

#define	LPTPRI		(PZERO+8)
#define	LPT_BSIZE	1024

#if !defined(DEBUG) || !defined(notdef)
#define LPRINTF(a)
#else
#define LPRINTF(a)	if (lptdebug) printf a
int lptdebug = 1;
#endif

/* XXX does not belong here */
cdev_decl(lpt);

struct cfdriver lpt_cd = {
	NULL, "lpt", DV_TTY
};

#define	LPTUNIT(s)	(minor(s) & 0x1f)
#define	LPTFLAGS(s)	(minor(s) & 0xe0)

#define	LPS_INVERT	(LPS_SELECT|LPS_NERR|LPS_NBSY|LPS_NACK)
#define	LPS_MASK	(LPS_SELECT|LPS_NERR|LPS_NBSY|LPS_NACK|LPS_NOPAPER)
#define	NOT_READY() \
    ((bus_space_read_1(sc->sc_iot, sc->sc_ioh, lpt_status) ^ LPS_INVERT) & LPS_MASK)
#define	NOT_READY_ERR() \
    lpt_not_ready(bus_space_read_1(sc->sc_iot, sc->sc_ioh, lpt_status), sc)

int	lpt_not_ready(u_int8_t, struct lpt_softc *);
void	lptwakeup(void *arg);
int	lptpushbytes(struct lpt_softc *);

/*
 * Internal routine to lptprobe to do port tests of one byte value.
 */
int
lpt_port_test(bus_space_tag_t iot, bus_space_handle_t ioh, bus_addr_t base,
    bus_size_t off, u_int8_t data, u_int8_t mask)
{
	int timeout;
	u_int8_t temp;

	data &= mask;
	bus_space_write_1(iot, ioh, off, data);
	timeout = 1000;
	do {
		delay(10);
		temp = bus_space_read_1(iot, ioh, off) & mask;
	} while (temp != data && --timeout);
	LPRINTF(("lpt: port=0x%x out=0x%x in=0x%x timeout=%d\n", base + off,
	    data, temp, timeout));
	return (temp == data);
}

void
lpt_attach_common(struct lpt_softc *sc)
{
	printf("\n");

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, lpt_control, LPC_NINIT);

	timeout_set(&sc->sc_wakeup_tmo, lptwakeup, sc);
}

void
lpt_detach_common(struct lpt_softc *sc)
{
	timeout_del(&sc->sc_wakeup_tmo);
	if (sc->sc_state != 0) {
		sc->sc_state = 0;
		wakeup(sc);
	}
}

/*
 * Reset the printer, then wait until it's selected and not busy.
 */
int
lptopen(dev_t dev, int flag, int mode, struct proc *p)
{
	int unit = LPTUNIT(dev);
	u_int8_t flags = LPTFLAGS(dev);
	struct lpt_softc *sc;
	u_int8_t control;
	int error;
	int spin;

	if (unit >= lpt_cd.cd_ndevs)
		return ENXIO;
	sc = lpt_cd.cd_devs[unit];
	if (!sc)
		return ENXIO;

	sc->sc_flags = (sc->sc_flags & LPT_POLLED) | flags;
	if ((sc->sc_flags & (LPT_POLLED|LPT_NOINTR)) == LPT_POLLED)
		return ENXIO;

#ifdef DIAGNOSTIC
	if (sc->sc_state)
		printf("%s: stat=0x%x not zero\n", sc->sc_dev.dv_xname,
		    sc->sc_state);
#endif

	if (sc->sc_state)
		return EBUSY;

	sc->sc_state = LPT_INIT;
	LPRINTF(("%s: open: flags=0x%x\n", sc->sc_dev.dv_xname, flags));

	if ((flags & LPT_NOPRIME) == 0) {
		/* assert INIT for 100 usec to start up printer */
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, lpt_control, LPC_SELECT);
		delay(100);
	}

	control = LPC_SELECT | LPC_NINIT;
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, lpt_control, control);

	/* wait till ready (printer running diagnostics) */
	for (spin = 0; NOT_READY_ERR(); spin += STEP) {
		if (spin >= TIMEOUT) {
			sc->sc_state = 0;
			return EBUSY;
		}

		/* wait 1/4 second, give up if we get a signal */
		error = tsleep((caddr_t)sc, LPTPRI | PCATCH, "lptopen", STEP);
		if (sc->sc_state == 0)
			return (EIO);
		if (error != EWOULDBLOCK) {
			sc->sc_state = 0;
			return error;
		}
	}

	if ((flags & LPT_NOINTR) == 0)
		control |= LPC_IENABLE;
	if (flags & LPT_AUTOLF)
		control |= LPC_AUTOLF;
	sc->sc_control = control;
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, lpt_control, control);

	sc->sc_inbuf = geteblk(LPT_BSIZE);
	sc->sc_count = 0;
	sc->sc_state = LPT_OPEN;

	if ((sc->sc_flags & LPT_NOINTR) == 0)
		lptwakeup(sc);

	LPRINTF(("%s: opened\n", sc->sc_dev.dv_xname));
	return 0;
}

int
lpt_not_ready(u_int8_t status, struct lpt_softc *sc)
{
	u_int8_t new;

	status = (status ^ LPS_INVERT) & LPS_MASK;
	new = status & ~sc->sc_laststatus;
	sc->sc_laststatus = status;

	if (new & LPS_SELECT)
		log(LOG_NOTICE, "%s: offline\n", sc->sc_dev.dv_xname);
	else if (new & LPS_NOPAPER)
		log(LOG_NOTICE, "%s: out of paper\n", sc->sc_dev.dv_xname);
	else if (new & LPS_NERR)
		log(LOG_NOTICE, "%s: output error\n", sc->sc_dev.dv_xname);

	return status;
}

void
lptwakeup(void *arg)
{
	struct lpt_softc *sc = arg;
	int s;

	s = spltty();
	lptintr(sc);
	splx(s);

	if (sc->sc_state != 0)
		timeout_add(&sc->sc_wakeup_tmo, STEP);
}

/*
 * Close the device, and free the local line buffer.
 */
int
lptclose(dev_t dev, int flag, int mode, struct proc *p)
{
	int unit = LPTUNIT(dev);
	struct lpt_softc *sc = lpt_cd.cd_devs[unit];
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	if (sc->sc_count)
		(void) lptpushbytes(sc);

	if ((sc->sc_flags & LPT_NOINTR) == 0)
		timeout_del(&sc->sc_wakeup_tmo);

	bus_space_write_1(iot, ioh, lpt_control, LPC_NINIT);
	sc->sc_state = 0;
	bus_space_write_1(iot, ioh, lpt_control, LPC_NINIT);
	brelse(sc->sc_inbuf);

	LPRINTF(("%s: closed\n", sc->sc_dev.dv_xname));
	return 0;
}

int
lptpushbytes(struct lpt_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int error;

	if (sc->sc_flags & LPT_NOINTR) {
		int spin, tic;
		u_int8_t control = sc->sc_control;

		while (sc->sc_count > 0) {
			spin = 0;
			if (sc->sc_state == 0)
				return (EIO);
			while (NOT_READY()) {
				if (++spin < sc->sc_spinmax)
					continue;
				tic = 0;
				/* adapt busy-wait algorithm */
				sc->sc_spinmax++;
				while (NOT_READY_ERR()) {
					/* exponential backoff */
					tic = tic + tic + 1;
					if (tic > TIMEOUT)
						tic = TIMEOUT;
					error = tsleep((caddr_t)sc,
					    LPTPRI | PCATCH, "lptpsh", tic);
					if (sc->sc_state == 0)
						error = EIO;
					if (error != EWOULDBLOCK)
						return error;
				}
				break;
			}

			bus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);
			bus_space_write_1(iot, ioh, lpt_control,
			    control | LPC_STROBE);
			sc->sc_count--;
			bus_space_write_1(iot, ioh, lpt_control, control);

			/* adapt busy-wait algorithm */
			if (spin*2 + 16 < sc->sc_spinmax)
				sc->sc_spinmax--;
		}
	} else {
		int s;

		while (sc->sc_count > 0) {
			/* if the printer is ready for a char, give it one */
			if ((sc->sc_state & LPT_OBUSY) == 0) {
				LPRINTF(("%s: write %d\n", sc->sc_dev.dv_xname,
				    sc->sc_count));
				s = spltty();
				(void) lptintr(sc);
				splx(s);
			}
			if (sc->sc_state == 0)
				return (EIO);
			error = tsleep((caddr_t)sc, LPTPRI | PCATCH,
			    "lptwrite2", 0);
			if (sc->sc_state == 0)
				error = EIO;
			if (error)
				return error;
		}
	}
	return 0;
}

/* 
 * Copy a line from user space to a local buffer, then call putc to get the
 * chars moved to the output queue.
 */
int
lptwrite(dev_t dev, struct uio *uio, int flags)
{
	struct lpt_softc *sc = lpt_cd.cd_devs[LPTUNIT(dev)];
	size_t n;
	int error = 0;

	while ((n = ulmin(LPT_BSIZE, uio->uio_resid)) != 0) {
		error = uiomove(sc->sc_cp = sc->sc_inbuf->b_data, n, uio);
		if (error != 0)
			return error;
		sc->sc_count = n;
		error = lptpushbytes(sc);
		if (error) {
			/*
			 * Return accurate residual if interrupted or timed
			 * out.
			 */
			uio->uio_resid += sc->sc_count;
			sc->sc_count = 0;
			return error;
		}
	}
	return 0;
}

/*
 * Handle printer interrupts which occur when the printer is ready to accept
 * another char.
 */
int
lptintr(void *arg)
{
	struct lpt_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	if (((sc->sc_state & LPT_OPEN) == 0 && sc->sc_count == 0) ||
	    (sc->sc_flags & LPT_NOINTR))
		return 0;

	/* is printer online and ready for output */
	if (NOT_READY() && NOT_READY_ERR())
		return -1;

	if (sc->sc_count) {
		u_int8_t control = sc->sc_control;
		/* send char */
		bus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);
		delay (50);
		bus_space_write_1(iot, ioh, lpt_control, control | LPC_STROBE);
		sc->sc_count--;
		bus_space_write_1(iot, ioh, lpt_control, control);
		sc->sc_state |= LPT_OBUSY;
	} else
		sc->sc_state &= ~LPT_OBUSY;

	if (sc->sc_count == 0) {
		/* none, wake up the top half to get more */
		wakeup((caddr_t)sc);
	}

	return 1;
}

int
lpt_activate(struct device *self, int act)
{
	struct lpt_softc *sc = (struct lpt_softc *)self;

	switch (act) {
	case DVACT_SUSPEND:
		timeout_del(&sc->sc_wakeup_tmo);
		break;
	case DVACT_RESUME:
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, lpt_control, LPC_NINIT);

		if (sc->sc_state) {
			int spin;

			if ((sc->sc_flags & LPT_NOPRIME) == 0) {
				/* assert INIT for 100 usec to start up printer */
				bus_space_write_1(sc->sc_iot, sc->sc_ioh,
				    lpt_control, LPC_SELECT);
				delay(100);
			}
			
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, lpt_control,
			    LPC_SELECT | LPC_NINIT);

			/* wait till ready (printer running diagnostics) */
			for (spin = 0; NOT_READY_ERR(); spin += STEP) {
				if (spin >= TIMEOUT) {
					sc->sc_state = 0;
					goto fail;
				}

				/* wait 1/4 second, give up if we get a signal */
				delay(STEP * 1000);
			}

			bus_space_write_1(sc->sc_iot, sc->sc_ioh,
			    lpt_control, sc->sc_control);
			wakeup(sc);
		}
fail:
		break;
	}
 
	return (0);
}
@


1.13
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.12 2014/09/14 14:17:24 jsg Exp $ */
d370 2
a371 2
	while ((n = min(LPT_BSIZE, uio->uio_resid)) != 0) {
		error = uiomovei(sc->sc_cp = sc->sc_inbuf->b_data, n, uio);
@


1.12
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.11 2013/12/09 04:21:58 deraadt Exp $ */
d371 1
a371 1
		error = uiomove(sc->sc_cp = sc->sc_inbuf->b_data, n, uio);
@


1.11
log
@timeout_del unconditionally
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.10 2013/06/12 19:07:40 deraadt Exp $ */
a58 1
#include <sys/proc.h>
@


1.10
log
@Add suspend/resume support to lpt.  Basically, ensure that DACT_SUSPEND
stops the timeouts, and that DVACT_RESUME unwedges the soft state and
bring the hardware state back to normal operation.
Tested by rpe, thanks a lot!
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.9 2012/01/11 16:22:33 dhill Exp $ */
d436 1
a436 2
		if (timeout_pending(&sc->sc_wakeup_tmo))
			timeout_del(&sc->sc_wakeup_tmo);
@


1.9
log
@ansify and de'register some prototypes

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.8 2011/09/17 08:36:06 miod Exp $ */
d101 1
a101 1
    ((bus_space_read_1(iot, ioh, lpt_status) ^ LPS_INVERT) & LPS_MASK)
d103 1
a103 1
    lpt_not_ready(bus_space_read_1(iot, ioh, lpt_status), sc)
d141 10
a159 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
a184 2
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
d188 1
a188 1
		bus_space_write_1(iot, ioh, lpt_control, LPC_SELECT);
d193 1
a193 1
	bus_space_write_1(iot, ioh, lpt_control, control);
d204 2
d217 1
a217 1
	bus_space_write_1(iot, ioh, lpt_control, control);
d259 2
a260 1
	timeout_add(&sc->sc_wakeup_tmo, STEP);
d302 2
d317 2
d347 2
d351 2
d427 48
@


1.8
log
@Don't bother keeping a {u,}lptioctl function which is a duplicate of
enodev().
ok jsing@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.7 2010/08/06 00:00:41 miod Exp $ */
d113 2
a114 6
lpt_port_test(iot, ioh, base, off, data, mask)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_addr_t base;
	bus_size_t off;
	u_int8_t data, mask;
d132 1
a132 2
lpt_attach_common(sc)
	struct lpt_softc *sc;
d145 1
a145 5
lptopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d223 1
a223 3
lpt_not_ready(status, sc)
	u_int8_t status;
	struct lpt_softc *sc;
d242 1
a242 2
lptwakeup(arg)
	void *arg;
d258 1
a258 5
lptclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d281 1
a281 2
lptpushbytes(sc)
	struct lpt_softc *sc;
d348 1
a348 4
lptwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d378 1
a378 2
lptintr(arg)
	void *arg;
@


1.7
log
@Every time you ignore uiomove() return value, $DEITY kills a little
$ADORABLE_FELINE.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.6 2010/06/26 23:24:44 guenther Exp $ */
a61 1
#include <sys/ioctl.h>
a430 18
}

int
lptioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error = 0;

	switch (cmd) {
	default:
		error = ENODEV;
	}

	return error;
@


1.6
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.5 2002/03/14 01:26:54 millert Exp $ */
d376 3
a378 1
		uiomove(sc->sc_cp = sc->sc_inbuf->b_data, n, uio);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.4 2000/07/21 17:41:02 mickey Exp $ */
a59 1
#include <sys/user.h>
@


1.4
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.3 1999/01/07 15:55:54 niklas Exp $ */
d107 3
a109 3
int	lpt_not_ready __P((u_int8_t, struct lpt_softc *));
void	lptwakeup __P((void *arg));
int	lptpushbytes __P((struct lpt_softc *));
@


1.4.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.4 2000/07/21 17:41:02 mickey Exp $ */
d107 3
a109 3
int	lpt_not_ready(u_int8_t, struct lpt_softc *);
void	lptwakeup(void *arg);
int	lptpushbytes(struct lpt_softc *);
@


1.3
log
@Polled mode when no irq was configured was broken
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.2 1997/09/02 01:16:50 deraadt Exp $ */
d137 11
d265 1
a265 1
	timeout(lptwakeup, sc, STEP);
d287 1
a287 1
		untimeout(lptwakeup, sc);
@


1.3.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.4 2000/07/21 17:41:02 mickey Exp $ */
a136 11
void
lpt_attach_common(sc)
	struct lpt_softc *sc;
{
	printf("\n");

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, lpt_control, LPC_NINIT);

	timeout_set(&sc->sc_wakeup_tmo, lptwakeup, sc);
}

d254 1
a254 1
	timeout_add(&sc->sc_wakeup_tmo, STEP);
d276 1
a276 1
		timeout_del(&sc->sc_wakeup_tmo);
@


1.3.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d107 3
a109 3
int	lpt_not_ready(u_int8_t, struct lpt_softc *);
void	lptwakeup(void *arg);
int	lptpushbytes(struct lpt_softc *);
@


1.2
log
@macro fix; mason@@primenet.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.1 1996/11/30 00:53:35 niklas Exp $ */
d162 1
a175 1
	sc->sc_flags = flags;
@


1.1
log
@Cleaned up.  lpt is MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpt.c,v 1.20 1996/11/29 22:55:04 niklas Exp $ */
d86 1
a86 1
#define LPRINTF		if (lptdebug) printf a
@
