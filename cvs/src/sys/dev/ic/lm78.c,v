head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.6
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.8
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.10
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.14
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.12
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.8
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.6
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.16
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.14
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.10
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.12
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.8
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.6
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7;
locks; strict;
comment	@ * @;


1.24
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.23;
commitid	p4LJxGKbi0BU2cG6;

1.23
date	2011.12.06.16.06.07;	author mpf;	state Exp;
branches;
next	1.22;

1.22
date	2011.10.05.15.05.47;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.26.18.43.35;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.25.22.50.18;	author cnst;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.26.22.47.39;	author cnst;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.25.02.26.43;	author cnst;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.25.02.20.25;	author cnst;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.19.12.23.24;	author robert;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.22.20.44.51;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.07.21.24.29;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.19.14.40.23;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.07.17.45.16;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.28.19.20.18;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.28.13.48.13;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.26.22.07.14;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.19.22.20.35;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.19.17.08.40;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.17.22.01.48;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.15.22.03.17;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.14.15.14.33;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: lm78.c,v 1.23 2011/12/06 16:06:07 mpf Exp $	*/

/*
 * Copyright (c) 2005, 2006 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/queue.h>
#include <sys/sensors.h>

#include <dev/ic/lm78var.h>
#include <dev/isa/wbsioreg.h>

#if defined(LMDEBUG)
#define DPRINTF(x)		do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

/*
 * LM78-compatible chips can typically measure voltages up to 4.096 V.
 * To measure higher voltages the input is attenuated with (external)
 * resistors.  Negative voltages are measured using inverting op amps
 * and resistors.  So we have to convert the sensor values back to
 * real voltages by applying the appropriate resistor factor.
 */
#define RFACT_NONE	10000
#define RFACT(x, y)	(RFACT_NONE * ((x) + (y)) / (y))
#define NRFACT(x, y)	(-RFACT_NONE * (x) / (y))

struct cfdriver lm_cd = {
	NULL, "lm", DV_DULL
};

int  lm_match(struct lm_softc *);
int  wb_match(struct lm_softc *);
int  def_match(struct lm_softc *);

void lm_setup_sensors(struct lm_softc *, struct lm_sensor *);
void lm_refresh(void *);

void lm_refresh_sensor_data(struct lm_softc *);
void lm_refresh_volt(struct lm_softc *, int);
void lm_refresh_temp(struct lm_softc *, int);
void lm_refresh_fanrpm(struct lm_softc *, int);

void wb_refresh_sensor_data(struct lm_softc *);
void wb_w83637hf_refresh_vcore(struct lm_softc *, int);
void wb_refresh_nvolt(struct lm_softc *, int);
void wb_w83627ehf_refresh_nvolt(struct lm_softc *, int);
void wb_refresh_temp(struct lm_softc *, int);
void wb_refresh_fanrpm(struct lm_softc *, int);
void wb_nct6776f_refresh_fanrpm(struct lm_softc *, int);
void wb_w83792d_refresh_fanrpm(struct lm_softc *, int);

void as_refresh_temp(struct lm_softc *, int);

struct lm_chip {
	int (*chip_match)(struct lm_softc *);
};

struct lm_chip lm_chips[] = {
	{ wb_match },
	{ lm_match },
	{ def_match } /* Must be last */
};

struct lm_sensor lm78_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT_NONE },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT_NONE },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(68, 100) },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volt, RFACT(30, 10) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, lm_refresh_volt, NRFACT(240, 60) },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_volt, NRFACT(100, 60) },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, lm_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, lm_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, lm_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83627hf_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT_NONE },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT_NONE },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 50) },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volt, RFACT(28, 10) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_nvolt, RFACT(232, 56) },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_nvolt, RFACT(120, 56) },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volt, RFACT(17, 33) },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volt, RFACT_NONE },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

/*
 * The W83627EHF can measure voltages up to 2.048 V instead of the
 * traditional 4.096 V.  For measuring positive voltages, this can be
 * accounted for by halving the resistor factor.  Negative voltages
 * need special treatment, also because the reference voltage is 2.048 V
 * instead of the traditional 3.6 V.
 */
struct lm_sensor w83627ehf_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE / 2},
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT(56, 10) / 2 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT(34, 34) / 2 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 34) / 2 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x24, wb_w83627ehf_refresh_nvolt },
	{ "", SENSOR_VOLTS_DC, 0, 0x25, lm_refresh_volt, RFACT_NONE / 2 },
	{ "", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_volt, RFACT_NONE / 2 },
	{ "3.3VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volt, RFACT(34, 34) / 2 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volt, RFACT_NONE / 2 },
	{ "", SENSOR_VOLTS_DC, 5, 0x52, lm_refresh_volt, RFACT_NONE / 2 },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

/* 
 * w83627dhg is almost identical to w83627ehf, except that 
 * it has 9 instead of 10 voltage sensors
 */
struct lm_sensor w83627dhg_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE / 2},
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT(56, 10) / 2 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT(34, 34) / 2 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 34) / 2 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x24, wb_w83627ehf_refresh_nvolt },
	{ "", SENSOR_VOLTS_DC, 0, 0x25, lm_refresh_volt, RFACT_NONE / 2 },
	{ "", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_volt, RFACT_NONE / 2 },
	{ "3.3VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volt, RFACT(34, 34) / 2 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volt, RFACT_NONE / 2 },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor nct6776f_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE / 2},
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT(56, 10) / 2 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT(34, 34) / 2 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 34) / 2 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x24, wb_w83627ehf_refresh_nvolt },
	{ "", SENSOR_VOLTS_DC, 0, 0x25, lm_refresh_volt, RFACT_NONE / 2 },
	{ "", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_volt, RFACT_NONE / 2 },
	{ "3.3VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volt, RFACT(34, 34) / 2 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volt, RFACT_NONE / 2 },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 6, 0x56, wb_nct6776f_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 6, 0x58, wb_nct6776f_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 6, 0x5a, wb_nct6776f_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 6, 0x5c, wb_nct6776f_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 6, 0x5e, wb_nct6776f_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83637hf_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, wb_w83637hf_refresh_vcore },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT(28, 10) },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT_NONE },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 51) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x24, wb_refresh_nvolt, RFACT(232, 56) },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volt, RFACT(34, 51) },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volt, RFACT_NONE },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83697hf_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT_NONE },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 50) },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volt, RFACT(28, 10) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_nvolt, RFACT(232, 56) },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_nvolt, RFACT(120, 56) },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volt, RFACT(17, 33) },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volt, RFACT_NONE },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },

	{ NULL }
};

/*
 * The datasheet doesn't mention the (internal) resistors used for the
 * +5V, but using the values from the W83782D datasheets seems to
 * provide sensible results.
 */
struct lm_sensor w83781d_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT_NONE },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT_NONE },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 50) },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volt, RFACT(28, 10) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, lm_refresh_volt, NRFACT(2100, 604) },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_volt, NRFACT(909, 604) },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, lm_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, lm_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, lm_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83782d_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE },
	{ "VINR0", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT_NONE },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT_NONE },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 50) },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volt, RFACT(28, 10) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_nvolt, RFACT(232, 56) },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_nvolt, RFACT(120, 56) },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volt, RFACT(17, 33) },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volt, RFACT_NONE },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83783s_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT_NONE },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 50) },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volt, RFACT(28, 10) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_nvolt, RFACT(232, 56) },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_nvolt, RFACT(120, 56) },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83791d_sensors[] = {
	/* Voltage */
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, 10000 },
	{ "VINR0", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 50) },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volt, RFACT(28, 10) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_nvolt, RFACT(232, 56) },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_nvolt, RFACT(120, 56) },
	{ "5VSB", SENSOR_VOLTS_DC, 0, 0xb0, lm_refresh_volt, RFACT(17, 33) },
	{ "VBAT", SENSOR_VOLTS_DC, 0, 0xb1, lm_refresh_volt, RFACT_NONE },
	{ "VINR1", SENSOR_VOLTS_DC, 0, 0xb2, lm_refresh_volt, RFACT_NONE },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 0, 0xc0, wb_refresh_temp },
	{ "", SENSOR_TEMP, 0, 0xc8, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0xba, wb_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0xbb, wb_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor w83792d_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT_NONE },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT_NONE },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x23, wb_refresh_nvolt, RFACT(120, 56) },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volt, RFACT(28, 10) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_nvolt, RFACT(232, 56) },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_volt, RFACT(34, 50) },
	{ "5VSB", SENSOR_VOLTS_DC, 0, 0xb0, lm_refresh_volt, RFACT(17, 33) },
	{ "VBAT", SENSOR_VOLTS_DC, 0, 0xb1, lm_refresh_volt, RFACT_NONE },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 0, 0xc0, wb_refresh_temp },
	{ "", SENSOR_TEMP, 0, 0xc8, wb_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, wb_w83792d_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, wb_w83792d_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, wb_w83792d_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0xb8, wb_w83792d_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0xb9, wb_w83792d_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0xba, wb_w83792d_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0xbe, wb_w83792d_refresh_fanrpm },

	{ NULL }
};

struct lm_sensor as99127f_sensors[] = {
	/* Voltage */
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volt, RFACT_NONE },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volt, RFACT_NONE },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 50) },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volt, RFACT(28, 10) },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_nvolt, RFACT(232, 56) },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_nvolt, RFACT(120, 56) },

	/* Temperature */
	{ "", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "", SENSOR_TEMP, 1, 0x50, as_refresh_temp },
	{ "", SENSOR_TEMP, 2, 0x50, as_refresh_temp },

	/* Fans */
	{ "", SENSOR_FANRPM, 0, 0x28, lm_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x29, lm_refresh_fanrpm },
	{ "", SENSOR_FANRPM, 0, 0x2a, lm_refresh_fanrpm },

	{ NULL }
};

void
lm_attach(struct lm_softc *sc)
{
	u_int i, config;

	for (i = 0; i < sizeof(lm_chips) / sizeof(lm_chips[0]); i++)
		if (lm_chips[i].chip_match(sc))
			break;

	/* No point in doing anything if we don't have any sensors. */
	if (sc->numsensors == 0)
		return;

	sc->sensortask = sensor_task_register(sc, lm_refresh, 5);
	if (sc->sensortask == NULL) {
		printf("%s: unable to register update task\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* Start the monitoring loop */
	config = sc->lm_readreg(sc, LM_CONFIG);
	sc->lm_writereg(sc, LM_CONFIG, config | 0x01);

	/* Add sensors */
	for (i = 0; i < sc->numsensors; ++i)
		sensor_attach(&sc->sensordev, &sc->sensors[i]);
	sensordev_install(&sc->sensordev);
}

int
lm_match(struct lm_softc *sc)
{
	int chipid;

	/* See if we have an LM78 or LM79. */
	chipid = sc->lm_readreg(sc, LM_CHIPID) & LM_CHIPID_MASK;
	switch(chipid) {
	case LM_CHIPID_LM78:
		printf(": LM78\n");
		break;
	case LM_CHIPID_LM78J:
		printf(": LM78J\n");
		break;
	case LM_CHIPID_LM79:
		printf(": LM79\n");
		break;
	case LM_CHIPID_LM81:
		printf(": LM81\n");
		break;
	default:
		return 0;
	}

	lm_setup_sensors(sc, lm78_sensors);
	sc->refresh_sensor_data = lm_refresh_sensor_data;
	return 1;
}

int
def_match(struct lm_softc *sc)
{
	int chipid;

	chipid = sc->lm_readreg(sc, LM_CHIPID) & LM_CHIPID_MASK;
	printf(": unknown chip (ID %d)\n", chipid);

	lm_setup_sensors(sc, lm78_sensors);
	sc->refresh_sensor_data = lm_refresh_sensor_data;
	return 1;
}

int
wb_match(struct lm_softc *sc)
{
	int banksel, vendid, devid;

	/* Read vendor ID */
	banksel = sc->lm_readreg(sc, WB_BANKSEL);
	sc->lm_writereg(sc, WB_BANKSEL, WB_BANKSEL_HBAC);
	vendid = sc->lm_readreg(sc, WB_VENDID) << 8;
	sc->lm_writereg(sc, WB_BANKSEL, 0);
	vendid |= sc->lm_readreg(sc, WB_VENDID);
	sc->lm_writereg(sc, WB_BANKSEL, banksel);
	DPRINTF((" winbond vend id 0x%x\n", vendid));
	if (vendid != WB_VENDID_WINBOND && vendid != WB_VENDID_ASUS)
		return 0;

	/* Read device/chip ID */
	sc->lm_writereg(sc, WB_BANKSEL, WB_BANKSEL_B0);
	devid = sc->lm_readreg(sc, LM_CHIPID);
	sc->chipid = sc->lm_readreg(sc, WB_BANK0_CHIPID);
	sc->lm_writereg(sc, WB_BANKSEL, banksel);
	DPRINTF((" winbond chip id 0x%x\n", sc->chipid));
	switch(sc->chipid) {
	case WB_CHIPID_W83627HF:
		printf(": W83627HF\n");
		lm_setup_sensors(sc, w83627hf_sensors);
		break;
	case WB_CHIPID_W83627THF:
		printf(": W83627THF\n");
		lm_setup_sensors(sc, w83637hf_sensors);
		break;
	case WB_CHIPID_W83627EHF_A:
		printf(": W83627EHF-A\n");
		lm_setup_sensors(sc, w83627ehf_sensors);
		break;
	case WB_CHIPID_W83627EHF:
		printf(": W83627EHF\n");
		lm_setup_sensors(sc, w83627ehf_sensors);
		break;
	case WB_CHIPID_W83627DHG:
		if (sc->sioid == WBSIO_ID_NCT6776F) {
			printf(": NCT6776F\n");
			lm_setup_sensors(sc, nct6776f_sensors);
		} else {
			printf(": W83627DHG\n");
			lm_setup_sensors(sc, w83627dhg_sensors);
		}
		break;
	case WB_CHIPID_W83637HF:
		printf(": W83637HF\n");
		sc->lm_writereg(sc, WB_BANKSEL, WB_BANKSEL_B0);
		if (sc->lm_readreg(sc, WB_BANK0_CONFIG) & WB_CONFIG_VMR9)
			sc->vrm9 = 1;
		sc->lm_writereg(sc, WB_BANKSEL, banksel);
		lm_setup_sensors(sc, w83637hf_sensors);
		break;
	case WB_CHIPID_W83697HF:
		printf(": W83697HF\n");
		lm_setup_sensors(sc, w83697hf_sensors);
		break;
	case WB_CHIPID_W83781D:
	case WB_CHIPID_W83781D_2:
		printf(": W83781D\n");
		lm_setup_sensors(sc, w83781d_sensors);
		break;
	case WB_CHIPID_W83782D:
		printf(": W83782D\n");
		lm_setup_sensors(sc, w83782d_sensors);
		break;
	case WB_CHIPID_W83783S:
		printf(": W83783S\n");
		lm_setup_sensors(sc, w83783s_sensors);
		break;
	case WB_CHIPID_W83791D:
		printf(": W83791D\n");
		lm_setup_sensors(sc, w83791d_sensors);
		break;
	case WB_CHIPID_W83791SD:
		printf(": W83791SD\n");
		break;
	case WB_CHIPID_W83792D:
		if (devid >= 0x10 && devid <= 0x29)
			printf(": W83792D rev %c\n", 'A' + devid - 0x10);
		else
			printf(": W83792D rev 0x%x\n", devid);
		lm_setup_sensors(sc, w83792d_sensors);
		break;
	case WB_CHIPID_AS99127F:
		if (vendid == WB_VENDID_ASUS) {
			printf(": AS99127F\n");
			lm_setup_sensors(sc, w83781d_sensors);
		} else {
			printf(": AS99127F rev 2\n");
			lm_setup_sensors(sc, as99127f_sensors);
		}
		break;
	default:
		printf(": unknown Winbond chip (ID 0x%x)\n", sc->chipid);
		/* Handle as a standard LM78. */
		lm_setup_sensors(sc, lm78_sensors);
		sc->refresh_sensor_data = lm_refresh_sensor_data;
		return 1;
	}

	sc->refresh_sensor_data = wb_refresh_sensor_data;
	return 1;
}

void
lm_setup_sensors(struct lm_softc *sc, struct lm_sensor *sensors)
{
	int i;

	strlcpy(sc->sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sensordev.xname));

	for (i = 0; sensors[i].desc; i++) {
		sc->sensors[i].type = sensors[i].type;
		strlcpy(sc->sensors[i].desc, sensors[i].desc,
		    sizeof(sc->sensors[i].desc));
		sc->numsensors++;
	}
	sc->lm_sensors = sensors;
}

void
lm_refresh(void *arg)
{
	struct lm_softc *sc = arg;

	sc->refresh_sensor_data(sc);
}

void
lm_refresh_sensor_data(struct lm_softc *sc)
{
	int i;

	for (i = 0; i < sc->numsensors; i++)
		sc->lm_sensors[i].refresh(sc, i);
}

void
lm_refresh_volt(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	sensor->value = (data << 4);
	sensor->value *= sc->lm_sensors[n].rfact;
	sensor->value /= 10;
}

void
lm_refresh_temp(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int sdata;

	/*
	 * The data sheet suggests that the range of the temperature
	 * sensor is between -55 degC and +125 degC.
	 */
	sdata = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	if (sdata > 0x7d && sdata < 0xc9) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		if (sdata & 0x80)
			sdata -= 0x100;
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = sdata * 1000000 + 273150000;
	}
}

void
lm_refresh_fanrpm(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int data, divisor = 1;

	/*
	 * We might get more accurate fan readings by adjusting the
	 * divisor, but that might interfere with APM or other SMM
	 * BIOS code reading the fan speeds.
	 */

	/* FAN3 has a fixed fan divisor. */
	if (sc->lm_sensors[n].reg == LM_FAN1 ||
	    sc->lm_sensors[n].reg == LM_FAN2) {
		data = sc->lm_readreg(sc, LM_VIDFAN);
		if (sc->lm_sensors[n].reg == LM_FAN1)
			divisor = (data >> 4) & 0x03;
		else
			divisor = (data >> 6) & 0x03;
	}

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	if (data == 0xff || data == 0x00) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = 1350000 / (data << divisor);
	}
}

void
wb_refresh_sensor_data(struct lm_softc *sc)
{
	int banksel, bank, i;

	/*
	 * Properly save and restore bank selection register.
	 */

	banksel = bank = sc->lm_readreg(sc, WB_BANKSEL);
	for (i = 0; i < sc->numsensors; i++) {
		if (bank != sc->lm_sensors[i].bank) {
			bank = sc->lm_sensors[i].bank;
			sc->lm_writereg(sc, WB_BANKSEL, bank);
		}
		sc->lm_sensors[i].refresh(sc, i);
	}
	sc->lm_writereg(sc, WB_BANKSEL, banksel);
}

void
wb_w83637hf_refresh_vcore(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);

	/*
	 * Depending on the voltage detection method,
	 * one of the following formulas is used:
	 *	VRM8 method: value = raw * 0.016V
	 *	VRM9 method: value = raw * 0.00488V + 0.70V
	 */
	if (sc->vrm9)
		sensor->value = (data * 4880) + 700000;
	else
		sensor->value = (data * 16000);
}

void
wb_refresh_nvolt(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	sensor->value = ((data << 4) - WB_VREF);
	sensor->value *= sc->lm_sensors[n].rfact;
	sensor->value /= 10;
	sensor->value += WB_VREF * 1000;
}

void
wb_w83627ehf_refresh_nvolt(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	sensor->value = ((data << 3) - WB_W83627EHF_VREF);
	sensor->value *= RFACT(232, 10);
	sensor->value /= 10;
	sensor->value += WB_W83627EHF_VREF * 1000;
}

void
wb_refresh_temp(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int sdata;

	/*
	 * The data sheet suggests that the range of the temperature
	 * sensor is between -55 degC and +125 degC.  However, values
	 * around -48 degC seem to be a very common bogus values.
	 * Since such values are unreasonably low, we use -45 degC for
	 * the lower limit instead.
	 */
	sdata = sc->lm_readreg(sc, sc->lm_sensors[n].reg) << 1;
	sdata += sc->lm_readreg(sc, sc->lm_sensors[n].reg + 1) >> 7;
	if (sdata > 0x0fa && sdata < 0x1a6) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		if (sdata & 0x100)
			sdata -= 0x200;
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = sdata * 500000 + 273150000;
	}
}

void
wb_refresh_fanrpm(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int fan, data, divisor = 0;

	/* 
	 * This is madness; the fan divisor bits are scattered all
	 * over the place.
	 */

	if (sc->lm_sensors[n].reg == LM_FAN1 ||
	    sc->lm_sensors[n].reg == LM_FAN2 ||
	    sc->lm_sensors[n].reg == LM_FAN3) {
		data = sc->lm_readreg(sc, WB_BANK0_VBAT);
		fan = (sc->lm_sensors[n].reg - LM_FAN1);
		if ((data >> 5) & (1 << fan))
			divisor |= 0x04;
	}

	if (sc->lm_sensors[n].reg == LM_FAN1 ||
	    sc->lm_sensors[n].reg == LM_FAN2) {
		data = sc->lm_readreg(sc, LM_VIDFAN);
		if (sc->lm_sensors[n].reg == LM_FAN1)
			divisor |= (data >> 4) & 0x03;
		else
			divisor |= (data >> 6) & 0x03;
	} else if (sc->lm_sensors[n].reg == LM_FAN3) {
		data = sc->lm_readreg(sc, WB_PIN);
		divisor |= (data >> 6) & 0x03;
	} else if (sc->lm_sensors[n].reg == WB_BANK0_FAN4 ||
		   sc->lm_sensors[n].reg == WB_BANK0_FAN5) {
		data = sc->lm_readreg(sc, WB_BANK0_FAN45);
		if (sc->lm_sensors[n].reg == WB_BANK0_FAN4)
			divisor |= (data >> 0) & 0x07;
		else
			divisor |= (data >> 4) & 0x07;
	}

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	if (data == 0xff || data == 0x00) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = 1350000 / (data << divisor);
	}
}

void
wb_nct6776f_refresh_fanrpm(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int datah, datal;

	datah = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	datal = sc->lm_readreg(sc, sc->lm_sensors[n].reg + 1);

	if (datah == 0xff) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = (datah << 8) | datal;
	}
}

void
wb_w83792d_refresh_fanrpm(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int reg, shift, data, divisor = 1;

	switch (sc->lm_sensors[n].reg) {
	case 0x28:
		reg = 0x47; shift = 0;
		break;
	case 0x29:
		reg = 0x47; shift = 4;
		break;
	case 0x2a:
		reg = 0x5b; shift = 0;
		break;
	case 0xb8:
		reg = 0x5b; shift = 4;
		break;
	case 0xb9:
		reg = 0x5c; shift = 0;
		break;
	case 0xba:
		reg = 0x5c; shift = 4;
		break;
	case 0xbe:
		reg = 0x9e; shift = 0;
		break;
	default:
		reg = 0;
		break;
	}

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	if (data == 0xff || data == 0x00) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		if (reg != 0)
			divisor = (sc->lm_readreg(sc, reg) >> shift) & 0x7;
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = 1350000 / (data << divisor);
	}
}

void
as_refresh_temp(struct lm_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sensors[n];
	int sdata;

	/*
	 * It seems a shorted temperature diode produces an all-ones
	 * bit pattern.
	 */
	sdata = sc->lm_readreg(sc, sc->lm_sensors[n].reg) << 1;
	sdata += sc->lm_readreg(sc, sc->lm_sensors[n].reg + 1) >> 7;
	if (sdata == 0x1ff) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		if (sdata & 0x100)
			sdata -= 0x200;
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = sdata * 500000 + 273150000;
	}
}
@


1.23
log
@Add support for Nuvoton NCT6776F fan, voltage and temperature sensors.
Tested on a Supermicro X9SCL/X9SCM board.
With help from kettenis to make the part that works around a
chip ID collision less ugly.
OK kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.22 2011/10/05 15:05:47 deraadt Exp $	*/
a24 1
#include <machine/bus.h>
@


1.22
log
@It is not safe to call sensor_task_unregister() from inside the
refresh function.  sensor_task_work() is incomprehensively complex.
Work around this by using a workq to deactive the i2c alias when the
isa interface is preffered.
Problem of dead sensors reported by henning, fix tested by Nigel Taylor
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.21 2011/07/26 18:43:35 deraadt Exp $	*/
d28 1
d69 1
d192 27
d530 7
a536 2
		printf(": W83627DHG\n");
		lm_setup_sensors(sc, w83627dhg_sensors);
d836 18
@


1.21
log
@Calling a detach function from an attach function is no longer legal (
see a recent subr_autoconf.c commit).  To resolve this problem, mark the
other attachment dead, and clean it up when the first servicing timeout
gets run.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.20 2007/06/25 22:50:18 cnst Exp $	*/
a584 14

	if (sc->flags & LM78_DEAD) {
		/* Remove sensors */
		int i;

		printf("%s: disabling sensors\n", sc->sc_dev.dv_xname);
		sensordev_deinstall(&sc->sensordev);
		for (i = 0; i < sc->numsensors; i++)
			sensor_detach(&sc->sensordev, &sc->sensors[i]);
		if (sc->sensortask != NULL)
			sensor_task_unregister(sc->sensortask);
		sc->sensortask = NULL;
		return;
	}
@


1.20
log
@support early W83627EHF-A; tested by Sam Fourman Jr; discussed with Gong Jun; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.19 2007/06/24 05:34:35 dlg Exp $	*/
a419 16
lm_detach(struct lm_softc *sc)
{
	int i;

	/* Remove sensors */
	sensordev_deinstall(&sc->sensordev);
	for (i = 0; i < sc->numsensors; i++)
		sensor_detach(&sc->sensordev, &sc->sensors[i]);

	if (sc->sensortask != NULL)
		sensor_task_unregister(sc->sensortask);

	return 0;
}

int
d585 14
@


1.19
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.18 2007/05/26 22:47:39 cnst Exp $	*/
d507 4
@


1.18
log
@fix a copy/paste typo from my previous commit: s/dhf/dhg/g
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.17 2007/05/25 02:26:43 cnst Exp $	*/
d402 2
a403 1
	if (sensor_task_register(sc, lm_refresh, 5)) {
d429 2
a430 1
	sensor_task_unregister(sc);
@


1.17
log
@add support for W83627DHG; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.16 2007/05/25 02:20:25 cnst Exp $	*/
d162 1
a162 1
 * w83627dhf is almost identical to w83627ehf, except that 
d165 1
a165 1
struct lm_sensor w83627dhf_sensors[] = {
d511 2
a512 2
		printf(": W83627DHF\n");
		lm_setup_sensors(sc, w83627dhf_sensors);
@


1.16
log
@fix a typo in RFACT of 3.3Vcc of w83627ehf; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.15 2007/04/19 12:23:24 robert Exp $	*/
d161 29
d509 4
@


1.15
log
@make it compile again if LMDEBUG is defined;
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.14 2007/03/22 16:55:31 deraadt Exp $	*/
d140 1
a140 1
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volt, RFACT(34, 24) / 2 },
@


1.14
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.13 2007/02/22 20:44:51 kettenis Exp $	*/
d458 1
a458 1
	DPRINTF((" winbond vend id 0x%x\n", j));
@


1.13
log
@Add support for Winbond W83627EHF chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.12 2007/01/07 21:24:29 kettenis Exp $	*/
d578 1
a578 1
	struct sensor *sensor = &sc->sensors[n];
d590 1
a590 1
	struct sensor *sensor = &sc->sensors[n];
d612 1
a612 1
	struct sensor *sensor = &sc->sensors[n];
d664 1
a664 1
	struct sensor *sensor = &sc->sensors[n];
d684 1
a684 1
	struct sensor *sensor = &sc->sensors[n];
d697 1
a697 1
	struct sensor *sensor = &sc->sensors[n];
d710 1
a710 1
	struct sensor *sensor = &sc->sensors[n];
d736 1
a736 1
	struct sensor *sensor = &sc->sensors[n];
d785 1
a785 1
	struct sensor *sensor = &sc->sensors[n];
d830 1
a830 1
	struct sensor *sensor = &sc->sensors[n];
@


1.12
log
@Fix VCore voltage detection on w83637hf.

Based on a diff from Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.11 2006/12/23 17:46:39 deraadt Exp $	*/
d65 1
d128 33
d477 4
d692 13
@


1.11
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.10 2006/06/19 14:40:23 kettenis Exp $	*/
d63 1
d129 1
a129 1
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volt, RFACT_NONE },
d445 4
d621 20
@


1.10
log
@Avoid using the rfact member of 'struct sensor' which is on its way out.
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.9 2006/05/07 17:45:16 kettenis Exp $	*/
d91 1
a91 1
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
d94 3
a96 3
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, lm_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, lm_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, lm_refresh_fanrpm },
d114 3
a116 3
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },
d119 3
a121 3
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },
d137 3
a139 3
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },
d142 3
a144 3
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },
d161 2
a162 2
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
d165 2
a166 2
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
d187 3
a189 3
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },
d192 3
a194 3
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, lm_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, lm_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, lm_refresh_fanrpm },
d212 3
a214 3
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },
d217 3
a219 3
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },
d234 2
a235 2
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
d238 3
a240 3
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },
d259 3
a261 3
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 0, 0xc0, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 0, 0xc8, wb_refresh_temp },
d264 5
a268 5
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_refresh_fanrpm },
	{ "Fan4", SENSOR_FANRPM, 0, 0xba, wb_refresh_fanrpm },
	{ "Fan5", SENSOR_FANRPM, 0, 0xbb, wb_refresh_fanrpm },
d286 3
a288 3
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 0, 0xc0, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 0, 0xc8, wb_refresh_temp },
d291 7
a297 7
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, wb_w83792d_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, wb_w83792d_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, wb_w83792d_refresh_fanrpm },
	{ "Fan4", SENSOR_FANRPM, 0, 0xb8, wb_w83792d_refresh_fanrpm },
	{ "Fan5", SENSOR_FANRPM, 0, 0xb9, wb_w83792d_refresh_fanrpm },
	{ "Fan6", SENSOR_FANRPM, 0, 0xba, wb_w83792d_refresh_fanrpm },
	{ "Fan7", SENSOR_FANRPM, 0, 0xbe, wb_w83792d_refresh_fanrpm },
d313 3
a315 3
	{ "Temp1", SENSOR_TEMP, 0, 0x27, lm_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, 0x50, as_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, as_refresh_temp },
d318 3
a320 3
	{ "Fan1", SENSOR_FANRPM, 0, 0x28, lm_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, 0, 0x29, lm_refresh_fanrpm },
	{ "Fan3", SENSOR_FANRPM, 0, 0x2a, lm_refresh_fanrpm },
d350 2
a351 1
		sensor_add(&sc->sensors[i]);
d360 1
d362 1
a362 1
		sensor_del(&sc->sensors[i]);
d503 3
a506 2
		strlcpy(sc->sensors[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sensors[i].device));
@


1.9
log
@Add abstraction for resistor factor; makes it easier to compare them to
the datasheets.  Fix a few typos too.
From Constantine Murenin <mureninc@@gmail.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.8 2006/04/28 19:20:18 kettenis Exp $	*/
a506 1
		sc->sensors[i].rfact = sensors[i].rfact;
d537 1
a537 1
	sensor->value *= sensor->rfact;
d623 1
a623 1
	sensor->value *= sensor->rfact;
@


1.8
log
@The W83627THF is pretty much identical to the W83637HF, not the W83627HF.
stolen from wilfried@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.7 2006/01/28 13:48:13 kettenis Exp $	*/
d35 11
d58 1
a58 2
void lm_refresh_volts(struct lm_softc *, int);
void lm_refresh_nvolts(struct lm_softc *, int);
d63 1
a63 2
void wb_refresh_n12volts(struct lm_softc *, int);
void wb_refresh_n5volts(struct lm_softc *, int);
d82 7
a88 7
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 40000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, lm_refresh_nvolts, 40000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_nvolts, 16667 },
d103 9
a111 9
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volts, 10000 },
d128 7
a134 7
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 38000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16667 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x24, wb_refresh_n12volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volts, 16667 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volts, 10000 },
d151 8
a158 8
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V",SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volts, 10000 },
d171 5
d178 7
a184 7
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 15050 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000},
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, lm_refresh_nvolts, 34768 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_nvolts, 15050 },
d201 9
a209 9
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VINR0", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000},
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 5, 0x50, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 5, 0x51, lm_refresh_volts, 10000 },
d226 6
a231 6
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
d247 10
a256 10
	{ "VCore", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VINR0", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000},
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
	{ "5VSB", SENSOR_VOLTS_DC, 0, 0xb0, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 0, 0xb1, lm_refresh_volts, 10000 },
	{ "VINR1", SENSOR_VOLTS_DC, 0, 0xb2, lm_refresh_volts, 10000 },
d275 9
a283 9
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x23, wb_refresh_n5volts, 10000 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000},
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x26, lm_refresh_volts, 16800 },
	{ "5VSB", SENSOR_VOLTS_DC, 0, 0xb0, lm_refresh_volts, 15151 },
	{ "VBAT", SENSOR_VOLTS_DC, 0, 0xb1, lm_refresh_volts, 10000 },
d304 7
a310 7
	{ "VCore A", SENSOR_VOLTS_DC, 0, 0x20, lm_refresh_volts, 10000 },
	{ "VCore B", SENSOR_VOLTS_DC, 0, 0x21, lm_refresh_volts, 10000 },
	{ "+3.3V", SENSOR_VOLTS_DC, 0, 0x22, lm_refresh_volts, 10000  },
	{ "+5V", SENSOR_VOLTS_DC, 0, 0x23, lm_refresh_volts, 16800 },
	{ "+12V", SENSOR_VOLTS_DC, 0, 0x24, lm_refresh_volts, 38000 },
	{ "-12V", SENSOR_VOLTS_DC, 0, 0x25, wb_refresh_n12volts, 10000 },
	{ "-5V", SENSOR_VOLTS_DC, 0, 0x26, wb_refresh_n5volts, 10000 },
d421 1
a421 1
	DPRINTF(("winbond vend id 0x%x\n", j));
d430 1
a430 1
	DPRINTF(("winbond chip id 0x%x\n", sc->chipid));
d470 1
a470 1
			printf(": W83782D rev %c\n", 'A' + devid - 0x10);
d472 1
a472 1
			printf(": W83782D rev 0x%x\n", devid);
d506 1
a506 1
		     sizeof(sc->sensors[i].desc));
d531 1
a531 13
lm_refresh_volts(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	sensor->value = (data << 4);
	sensor->value *= sensor->rfact;
	sensor->value /= 10;
}

void
lm_refresh_nvolts(struct lm_softc *sc, int n)
a539 1
	sensor->value *= -1;
d617 1
a617 13
wb_refresh_n12volts(struct lm_softc *sc, int n)
{
	struct sensor *sensor = &sc->sensors[n];
	int data;

	data = sc->lm_readreg(sc, sc->lm_sensors[n].reg);
	sensor->value = (((data << 4) * 1000) - (WB_VREF * 806)) / 194;
	sensor->value *= sensor->rfact;
	sensor->value /= 10;
}

void
wb_refresh_n5volts(struct lm_softc *sc, int n)
d623 1
a623 1
	sensor->value = (((data << 4) * 1000) - (WB_VREF * 682)) / 318;
d626 1
@


1.7
log
@Consider temperatures below -45 degC to be invalid for Winbond chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.6 2006/01/26 22:07:14 kettenis Exp $	*/
d424 1
a424 1
		lm_setup_sensors(sc, w83627hf_sensors);
@


1.6
log
@Make lm at iic detach properly, and use config_detach(9) to fully detach
lm at iic if we attach lm at isa for the same chip.
tested by robert@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.5 2006/01/19 22:20:35 kettenis Exp $	*/
d647 4
a650 3
	 * sensor is between -55 degC and +125 degC.  However, -48
	 * degC seems to be a very common bogus value, and is already
	 * unreasonably low.
d654 1
a654 1
	if ((sdata > 0x0fa && sdata < 0x192) || sdata == 0x1a0) {
@


1.5
log
@Try to disable unconnected temperature sensors.
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.4 2006/01/19 17:08:40 grange Exp $	*/
d337 14
@


1.4
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.3 2006/01/17 22:01:48 kettenis Exp $	*/
d59 2
d300 2
a301 2
	{ "Temp2", SENSOR_TEMP, 1, 0x50, wb_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, 0x50, wb_refresh_temp },
d533 4
d538 9
a546 3
	if (sdata & 0x80)
		sdata -= 0x100;
	sensor->value = sdata * 1000000 + 273150000;
d631 6
d639 9
a647 3
	if (sdata & 0x100)
		sdata -= 0x200;
	sensor->value = sdata * 500000 + 273150000;
d741 23
@


1.3
log
@Support W83791SD as an lm(4) without sensors.
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.2 2006/01/15 22:03:17 kettenis Exp $	*/
d334 1
a334 1
		SENSOR_ADD(&sc->sensors[i]);
@


1.2
log
@Commit missing bits too:

If we attach an lm(4) to isa(4) that is already attached to iic(4), disable
the one attached to iic(4).
idea from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm78.c,v 1.1 2006/01/14 15:14:33 kettenis Exp $	*/
d318 4
a431 1
	case WB_CHIPID_W83791D_2:
d434 3
@


1.1
log
@Rename nslm7x.c into lm78.c and nslm7xvar.h into lm78var.h, and clean up
lm78var.h.
Now that I've completely rewritten the driver, replace copyright with my own.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nslm7x.c,v 1.18 2006/01/12 22:45:46 kettenis Exp $	*/
d378 1
a378 1
	int banksel, vendid, chipid, devid;
d394 1
a394 1
	chipid = sc->lm_readreg(sc, WB_BANK0_CHIPID);
d396 2
a397 2
	DPRINTF(("winbond chip id 0x%x\n", chipid));
	switch(chipid) {
d449 1
a449 1
		printf(": unknown Winbond chip (ID 0x%x)\n", chipid);
@

