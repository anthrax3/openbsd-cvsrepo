head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.24
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.18
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.20
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.12
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.16
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.14
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.10
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.8
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.14
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.10
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.8
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.6
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.16
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.14
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2;
locks; strict;
comment	@ * @;


1.11
date	2011.04.11.19.11.01;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.03.15.46.30;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.28.12.48.14;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.29.19.11.15;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.29.19.46.02;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.20.17.47.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.14.04.44.01;	author aaron;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.03.14.02.49.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.02.20.25.39;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.15.20.42.40;	author aaron;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.24.05;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Fix SPL handling when PCDISPLAY_SOFTCURSOR is enabled.

Discovered, narrowed down, and tested by jmc@@.
"definitely commit that" deraadt@@, ok miod@@
@
text
@/* $OpenBSD: pcdisplay_subr.c,v 1.10 2011/04/03 15:46:30 miod Exp $ */
/* $NetBSD: pcdisplay_subr.c,v 1.16 2000/06/08 07:01:19 cgd Exp $ */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <machine/bus.h>

#include <dev/ic/mc6845reg.h>
#include <dev/ic/pcdisplayvar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>

void
pcdisplay_cursor_reset(struct pcdisplayscreen *scr)
{
#ifdef PCDISPLAY_SOFTCURSOR
	pcdisplay_6845_write(scr->hdl, curstart, 0x10);
	pcdisplay_6845_write(scr->hdl, curend, 0x10);
#endif
}

void
pcdisplay_cursor_init(struct pcdisplayscreen *scr, int existing)
{
#ifdef PCDISPLAY_SOFTCURSOR
	bus_space_tag_t memt;
	bus_space_handle_t memh;
	int off;
#endif

	pcdisplay_cursor_reset(scr);

#ifdef PCDISPLAY_SOFTCURSOR
	if (existing) {
		/*
		 * This is the first screen. At this point, scr->active is
		 * false and scr->mem is NULL (no backing store), so we
		 * can't use pcdisplay_cursor() to do this.
		 */
		memt = scr->hdl->ph_memt;
		memh = scr->hdl->ph_memh;
		off = (scr->vc_crow * scr->type->ncols + scr->vc_ccol) * 2 +
		    scr->dispoffset;

		scr->cursortmp = bus_space_read_2(memt, memh, off);
		bus_space_write_2(memt, memh, off, scr->cursortmp ^ 0x7700);
	} else
		scr->cursortmp = 0;
#endif
	scr->cursoron = 1;
}

int
pcdisplay_cursor(void *id, int on, int row, int col)
{
#ifdef PCDISPLAY_SOFTCURSOR
	struct pcdisplayscreen *scr = id;
	bus_space_tag_t memt = scr->hdl->ph_memt;
	bus_space_handle_t memh = scr->hdl->ph_memh;
	int off;
	int s = spltty();

	/* Remove old cursor image */
	if (scr->cursoron) {
		off = scr->vc_crow * scr->type->ncols + scr->vc_ccol;
		if (scr->active)
			bus_space_write_2(memt, memh, scr->dispoffset + off * 2,
			    scr->cursortmp);
		else
			scr->mem[off] = scr->cursortmp;
	}
		
	scr->vc_crow = row;
	scr->vc_ccol = col;

	if ((scr->cursoron = on) == 0)
		goto done;

	off = (scr->vc_crow * scr->type->ncols + scr->vc_ccol);
	if (scr->active) {
		off = off * 2 + scr->dispoffset;
		scr->cursortmp = bus_space_read_2(memt, memh, off);
		bus_space_write_2(memt, memh, off, scr->cursortmp ^ 0x7700);
	} else {
		scr->cursortmp = scr->mem[off];
		scr->mem[off] = scr->cursortmp ^ 0x7700;
	}

done:
	splx(s);
	return 0;
#else 	/* PCDISPLAY_SOFTCURSOR */
	struct pcdisplayscreen *scr = id;
	int pos;
	int s = spltty();

	scr->vc_crow = row;
	scr->vc_ccol = col;
	scr->cursoron = on;

	if (scr->active) {
		if (!on)
			pos = 0x1010;
		else
			pos = scr->dispoffset / 2
				+ row * scr->type->ncols + col;

		pcdisplay_6845_write(scr->hdl, cursorh, pos >> 8);
		pcdisplay_6845_write(scr->hdl, cursorl, pos);
	}

	splx(s);
	return 0;
#endif	/* PCDISPLAY_SOFTCURSOR */
}

#if 0
unsigned int
pcdisplay_mapchar_simple(void *id, int uni)
{
	if (uni < 128)
		return (uni);

	return (1); /* XXX ??? smiley */
}
#endif

int
pcdisplay_putchar(void *id, int row, int col, u_int c, long attr)
{
	struct pcdisplayscreen *scr = id;
	bus_space_tag_t memt = scr->hdl->ph_memt;
	bus_space_handle_t memh = scr->hdl->ph_memh;
	int off;
	int s;

	off = row * scr->type->ncols + col;

	s = spltty();
	if (scr->active)
		bus_space_write_2(memt, memh, scr->dispoffset + off * 2,
				  c | (attr << 8));
	else
		scr->mem[off] = c | (attr << 8);
	splx(s);

	return 0;
}

int
pcdisplay_getchar(void *id, int row, int col, struct wsdisplay_charcell *cell)
{
	struct pcdisplayscreen *scr = id;
	bus_space_tag_t memt = scr->hdl->ph_memt;
	bus_space_handle_t memh = scr->hdl->ph_memh;
	int off;
	int s;
	u_int16_t data;
	
	off = row * scr->type->ncols + col;
	/* XXX bounds check? */
	
	s = spltty();
	if (scr->active)
		data = (bus_space_read_2(memt, memh, 
					scr->dispoffset + off * 2));
	else
		data = (scr->mem[off]);
	splx(s);

	cell->uc = data & 0xff;
	cell->attr = data >> 8;

	return (0);
}

int
pcdisplay_copycols(void *id, int row, int srccol, int dstcol, int ncols)
{
	struct pcdisplayscreen *scr = id;
	bus_space_tag_t memt = scr->hdl->ph_memt;
	bus_space_handle_t memh = scr->hdl->ph_memh;
	bus_size_t srcoff, dstoff;
	int s;

	srcoff = dstoff = row * scr->type->ncols;
	srcoff += srccol;
	dstoff += dstcol;

	s = spltty();
	if (scr->active)
		bus_space_copy_2(memt, memh,
					scr->dispoffset + srcoff * 2,
					memh, scr->dispoffset + dstoff * 2,
					ncols);
	else
		bcopy(&scr->mem[srcoff], &scr->mem[dstoff], ncols * 2);
	splx(s);

	return 0;
}

int
pcdisplay_erasecols(void *id, int row, int startcol, int ncols, long fillattr)
{
	struct pcdisplayscreen *scr = id;
	bus_space_tag_t memt = scr->hdl->ph_memt;
	bus_space_handle_t memh = scr->hdl->ph_memh;
	bus_size_t off;
	u_int16_t val;
	int i;
	int s;

	off = row * scr->type->ncols + startcol;
	val = (fillattr << 8) | ' ';

	s = spltty();
	if (scr->active)
		bus_space_set_region_2(memt, memh, scr->dispoffset + off * 2,
				       val, ncols);
	else
		for (i = 0; i < ncols; i++)
			scr->mem[off + i] = val;
	splx(s);

	return 0;
}

int
pcdisplay_copyrows(void *id, int srcrow, int dstrow, int nrows)
{
	struct pcdisplayscreen *scr = id;
	bus_space_tag_t memt = scr->hdl->ph_memt;
	bus_space_handle_t memh = scr->hdl->ph_memh;
	int ncols = scr->type->ncols;
	bus_size_t srcoff, dstoff;
	int s;

	srcoff = srcrow * ncols + 0;
	dstoff = dstrow * ncols + 0;

	s = spltty();
	if (scr->active)
		bus_space_copy_2(memt, memh,
					scr->dispoffset + srcoff * 2,
					memh, scr->dispoffset + dstoff * 2,
					nrows * ncols);
	else
		bcopy(&scr->mem[srcoff], &scr->mem[dstoff],
		      nrows * ncols * 2);
	splx(s);

	return 0;
}

int
pcdisplay_eraserows(void *id, int startrow, int nrows, long fillattr)
{
	struct pcdisplayscreen *scr = id;
	bus_space_tag_t memt = scr->hdl->ph_memt;
	bus_space_handle_t memh = scr->hdl->ph_memh;
	bus_size_t off, count, n;
	u_int16_t val;
	int s;

	off = startrow * scr->type->ncols;
	count = nrows * scr->type->ncols;
	val = (fillattr << 8) | ' ';

	s = spltty();
	if (scr->active)
		bus_space_set_region_2(memt, memh, scr->dispoffset + off * 2,
				       val, count);
	else
		for (n = 0; n < count; n++)
			scr->mem[off + n] = val;
	splx(s);

	return 0;
}
@


1.10
log
@Sprinkle spltty around code which plays with either the video memory or
the backing store. The state of a VT is only coherent if both the active
flag and the backing store are in order, which is not the case during VT
switches.
This fixes display glitches occuring during VT switches if one of the
VT involved is doing a lot of tty updates.
Noticed by deraadt@@ on a machine too fast for mere mortals.
@
text
@d1 1
a1 1
/* $OpenBSD: pcdisplay_subr.c,v 1.9 2010/08/28 12:48:14 miod Exp $ */
d119 1
a120 1
done:
@


1.9
log
@ansify function definitions, and constify a few arrays while there.
no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: pcdisplay_subr.c,v 1.8 2009/09/05 14:09:35 miod Exp $ */
d91 1
d107 1
a107 1
		return 0;
d119 2
d125 1
d142 1
d165 1
d169 1
d175 1
d187 1
d193 1
d199 1
d214 1
d220 1
d228 1
d242 1
a244 1

d247 1
d254 1
d267 1
d272 1
d281 1
d294 1
a297 1

d300 1
d307 1
@


1.8
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/* $OpenBSD: pcdisplay_subr.c,v 1.7 2006/11/29 19:11:15 miod Exp $ */
d44 1
a44 2
pcdisplay_cursor_reset(scr)
	struct pcdisplayscreen *scr;
d53 1
a53 3
pcdisplay_cursor_init(scr, existing)
	struct pcdisplayscreen *scr;
	int existing;
d84 1
a84 3
pcdisplay_cursor(id, on, row, col)
	void *id;
	int on, row, col;
d144 1
a144 3
pcdisplay_mapchar_simple(id, uni)
	void *id;
	int uni;
d154 1
a154 5
pcdisplay_putchar(id, row, col, c, attr)
	void *id;
	int row, col;
	u_int c;
	long attr;
d173 1
a173 4
pcdisplay_getchar(id, row, col, cell)
	void *id;
	int row, col;
	struct wsdisplay_charcell *cell;
d197 1
a197 3
pcdisplay_copycols(id, row, srccol, dstcol, ncols)
	void *id;
	int row, srccol, dstcol, ncols;
d220 1
a220 4
pcdisplay_erasecols(id, row, startcol, ncols, fillattr)
	void *id;
	int row, startcol, ncols;
	long fillattr;
d244 1
a244 3
pcdisplay_copyrows(id, srcrow, dstrow, nrows)
	void *id;
	int srcrow, dstrow, nrows;
d268 1
a268 4
pcdisplay_eraserows(id, startrow, nrows, fillattr)
	void *id;
	int startrow, nrows;
	long fillattr;
@


1.7
log
@Change the getchar wsdisplay_accessops function to not return a
display-dependent value, but instead fill a structure with the chaarcter
and a valid attribute, suitable for use with unpack_attr.

Adapt the wsmoused code to these changes, and remove all knowledge of
the text-mode style pc video attributes in it.

This will eventually allow wsmoused to be used on non-pcdisplay devices.
@
text
@d1 1
a1 1
/* $OpenBSD: pcdisplay_subr.c,v 1.6 2006/09/29 19:46:02 miod Exp $ */
d86 1
a86 1
void
d111 1
a111 1
		return;
d122 2
d142 2
d160 1
a160 1
void
d179 2
d210 1
a210 1
void
d231 2
d235 1
a235 1
void
d258 2
d262 1
a262 1
void
d284 2
d288 1
a288 1
void
d311 2
@


1.6
log
@If option PCDISPLAY_SOFTCURSOR, force the hardware cursor off every time
we switch vt, so that the hardware cursor does not reappear after starting
X11, and switching to a text vt.

Spotted by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: pcdisplay_subr.c,v 1.5 2003/11/20 17:47:02 millert Exp $ */
d177 2
a178 2
u_int16_t
pcdisplay_getchar(id, row, col)
d181 1
d187 1
d190 1
d193 1
a193 1
		return (bus_space_read_2(memt, memh, 
d196 6
a201 1
		return (scr->mem[off]);
@


1.5
log
@Make these pass -Wsign-compare
@
text
@d1 1
a1 1
/* $OpenBSD: pcdisplay_subr.c,v 1.4 2001/04/14 04:44:01 aaron Exp $ */
d44 10
d62 3
d66 1
a66 3
	pcdisplay_6845_write(scr->hdl, curstart, 0x10);
	pcdisplay_6845_write(scr->hdl, curend, 0x10);
	
@


1.4
log
@Kernel support for console mouse functionality which will be controlled by
the wsmoused daemon (replacement for moused which was used with PCVT). Adds
a "getchar" method to the display drivers which returns the value of the
character currently under the cursor (e.g., so it may be inversed). From jbm@@.

Still needs a bit of cleanup and improvement, especially X cohabitation
features. The pointer moves to fast as well. These sorts of issues will be
corrected in-tree.
@
text
@d1 1
a1 1
/* $OpenBSD: pcdisplay_subr.c,v 1.3 2001/03/14 02:49:22 mickey Exp $ */
d266 1
a266 1
	bus_size_t off, count;
a267 1
	int i;
d278 2
a279 2
		for (i = 0; i < count; i++)
			scr->mem[off + i] = val;
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: pcdisplay_subr.c,v 1.4 2001/04/14 04:44:01 aaron Exp $ */
@


1.4.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d266 1
a266 1
	bus_size_t off, count, n;
d268 1
d279 2
a280 2
		for (n = 0; n < count; n++)
			scr->mem[off + n] = val;
@


1.3
log
@allow listing and soon deleting fonts; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pcdisplay_subr.c,v 1.2 2001/02/02 20:25:39 aaron Exp $ */
d164 19
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d40 1
@


1.1
log
@This driver supports PC display adapter hardware within the wscons(4)
console framework. It doesn't provide direct device driver entry points
but makes its functions available via the internal wsdisplay(4) interface.

The pcdisplay driver is indended as a minimal ``catch-all'' driver for
the different kinds of MDA or CGA compatible adapters. It doesn't support
multiple screens, nor colors or font loading.

From NetBSD. Contains routines used by the vga(4) and ega(4) drivers, etc.
This is more MI stuff in prepartion for wscons on i386 and alpha.
@
text
@d1 1
@

