head	1.95;
access;
symbols
	OPENBSD_6_2:1.95.0.2
	OPENBSD_6_2_BASE:1.95
	OPENBSD_6_1:1.95.0.4
	OPENBSD_6_1_BASE:1.95
	OPENBSD_6_0:1.94.0.4
	OPENBSD_6_0_BASE:1.94
	OPENBSD_5_9:1.93.0.2
	OPENBSD_5_9_BASE:1.93
	OPENBSD_5_8:1.86.0.4
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.82.0.2
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.80.0.4
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.79.0.4
	OPENBSD_5_5_BASE:1.79
	OPENBSD_5_4:1.78.0.6
	OPENBSD_5_4_BASE:1.78
	OPENBSD_5_3:1.78.0.4
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.78.0.2
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.77
	OPENBSD_5_1:1.77.0.4
	OPENBSD_5_0:1.76.0.8
	OPENBSD_5_0_BASE:1.76
	OPENBSD_4_9:1.76.0.6
	OPENBSD_4_9_BASE:1.76
	OPENBSD_4_8:1.76.0.4
	OPENBSD_4_8_BASE:1.76
	OPENBSD_4_7:1.76.0.2
	OPENBSD_4_7_BASE:1.76
	OPENBSD_4_6:1.73.0.6
	OPENBSD_4_6_BASE:1.73
	OPENBSD_4_5:1.73.0.2
	OPENBSD_4_5_BASE:1.73
	OPENBSD_4_4:1.71.0.4
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.71.0.2
	OPENBSD_4_3_BASE:1.71
	OPENBSD_4_2:1.69.0.4
	OPENBSD_4_2_BASE:1.69
	OPENBSD_4_1:1.69.0.2
	OPENBSD_4_1_BASE:1.69
	OPENBSD_4_0:1.68.0.2
	OPENBSD_4_0_BASE:1.68
	OPENBSD_3_9:1.66.0.2
	OPENBSD_3_9_BASE:1.66
	OPENBSD_3_8:1.64.0.2
	OPENBSD_3_8_BASE:1.64
	OPENBSD_3_7:1.63.0.2
	OPENBSD_3_7_BASE:1.63
	OPENBSD_3_6:1.62.0.2
	OPENBSD_3_6_BASE:1.62
	SMP_SYNC_A:1.62
	SMP_SYNC_B:1.62
	OPENBSD_3_5:1.61.0.2
	OPENBSD_3_5_BASE:1.61
	OPENBSD_3_4:1.60.0.2
	OPENBSD_3_4_BASE:1.60
	UBC_SYNC_A:1.59
	OPENBSD_3_3:1.59.0.4
	OPENBSD_3_3_BASE:1.59
	OPENBSD_3_2:1.59.0.2
	OPENBSD_3_2_BASE:1.59
	OPENBSD_3_1:1.57.0.2
	OPENBSD_3_1_BASE:1.57
	UBC_SYNC_B:1.59
	UBC:1.54.0.4
	UBC_BASE:1.54
	OPENBSD_3_0:1.54.0.2
	OPENBSD_3_0_BASE:1.54
	OPENBSD_2_9_BASE:1.47
	OPENBSD_2_9:1.47.0.2
	OPENBSD_2_8:1.45.0.2
	OPENBSD_2_8_BASE:1.45
	OPENBSD_2_7:1.38.0.2
	OPENBSD_2_7_BASE:1.38
	SMP:1.37.0.2
	SMP_BASE:1.37
	kame_19991208:1.36
	OPENBSD_2_6:1.35.0.2
	OPENBSD_2_6_BASE:1.35
	OPENBSD_2_5:1.31.0.2
	OPENBSD_2_5_BASE:1.31
	OPENBSD_2_4:1.29.0.2
	OPENBSD_2_4_BASE:1.29
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.17.0.2
	OPENBSD_2_1_BASE:1.17
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12;
locks; strict;
comment	@ * @;


1.95
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.94;
commitid	VyLWTsbepAOk7VQM;

1.94
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.93;
commitid	QHiEhS9DHyE6oiIr;

1.93
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.92;
commitid	J9apD0jq2AjFmqZc;

1.92
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.91;
commitid	f4dx5ry1aOiKJw33;

1.91
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.90;
commitid	B0kwmVGiD5DVx4kv;

1.90
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.89;
commitid	5DvsamK0GblTp8ww;

1.89
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.88;
commitid	eYnPulzvLjDImPCa;

1.88
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.87;
commitid	p0v5tuE1Ch6fY0Nj;

1.87
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.86;
commitid	6vhYvh5CxZAHMnsN;

1.86
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.85;
commitid	9ERVupAoYqW4Iok9;

1.85
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.84;
commitid	MVWrtktB46JRxFWT;

1.84
date	2015.03.30.10.04.11;	author mpi;	state Exp;
branches;
next	1.83;
commitid	vuysUy6vx4zNlffv;

1.83
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.82;
commitid	p4LJxGKbi0BU2cG6;

1.82
date	2014.12.29.02.33.13;	author brad;	state Exp;
branches;
next	1.81;
commitid	FC9SdQLMwVLtzObM;

1.81
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.80;
commitid	yM2VFFhpDTeFQlve;

1.80
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.79;
commitid	TGHgrLxu6sxZoiFt;

1.79
date	2013.08.07.01.06.29;	author bluhm;	state Exp;
branches;
next	1.78;

1.78
date	2012.04.09.16.41.33;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2012.01.11.16.22.33;	author dhill;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.24.18.12.39;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2009.11.23.16.36.22;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.16.13.41.49;	author jsg;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.13.16.12.29;	author fgsch;	state Exp;
branches;
next	1.70;

1.70
date	2007.09.26.13.09.59;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.19.01.33.44;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2006.06.17.17.56.10;	author brad;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.25.22.41.42;	author djm;	state Exp;
branches;
next	1.66;

1.66
date	2005.11.21.18.16.39;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2005.11.14.12.24.34;	author mickey;	state Exp;
branches;
next	1.64;

1.64
date	2005.04.25.17.55.50;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.08.20.17.05;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.09.02.52.44;	author fgsch;	state Exp;
branches;
next	1.58;

1.58
date	2002.04.30.22.08.43;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.14.03.16.04;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.31.04.07.38;	author rees;	state Exp;
branches;
next	1.54;

1.54
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches
	1.54.4.1;
next	1.53;

1.53
date	2001.07.08.23.38.05;	author fgsch;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.27.06.34.41;	author kjc;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.24.20.30.24;	author fgsch;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.23.21.54.44;	author fgsch;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.26.06.57.19;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.22.18.59.54;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2001.02.20.19.39.36;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2000.11.09.18.06.38;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2000.10.16.17.08.07;	author aaron;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.17.19.10.56;	author provos;	state Exp;
branches;
next	1.43;

1.43
date	2000.09.17.00.06.01;	author aaron;	state Exp;
branches;
next	1.42;

1.42
date	2000.09.15.22.28.50;	author aaron;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.06.00.59.01;	author todd;	state Exp;
branches;
next	1.40;

1.40
date	2000.06.29.03.22.31;	author aaron;	state Exp;
branches;
next	1.39;

1.39
date	2000.05.29.18.04.07;	author aaron;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.25.04.26.11;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2000.02.02.18.47.01;	author deraadt;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	99.12.08.06.08.04;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	99.08.13.19.00.37;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	99.08.08.21.46.15;	author niklas;	state Exp;
branches;
next	1.33;

1.33
date	99.08.05.18.08.55;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	99.07.26.12.31.43;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	99.02.28.03.23.36;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	98.12.26.23.58.33;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	98.09.27.21.22.15;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.09.19.10.08.05;	author maja;	state Exp;
branches;
next	1.27;

1.27
date	98.09.16.21.16.19;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.09.11.12.06.54;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	98.04.28.07.39.53;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.04.04.08.09.23;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.02.25.23.56.51;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.02.23.17.36.52;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	98.01.17.16.40.38;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.10.30.23.49.28;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	97.09.16.17.47.03;	author flipk;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	97.07.30.11.12.22;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	97.01.05.04.03.26;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.11.28.23.27.49;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	96.11.12.20.30.18;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	96.10.31.01.01.28;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	96.10.12.23.38.54;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.09.29.20.59.39;	author deraadt;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	96.09.28.10.16.20;	author pefo;	state Exp;
branches;
next	1.10;

1.10
date	96.09.25.22.07.59;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	96.09.25.21.46.00;	author pefo;	state Exp;
branches;
next	1.8;

1.8
date	96.09.24.09.29.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.17.18.47.31;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	96.05.26.00.26.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.10.12.41.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.07.35.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.05.13.39.38;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.03.07.59.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.02.13.38.06;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	96.10.13.06.52.58;	author deraadt;	state Exp;
branches;
next	;

1.19.2.1
date	97.10.30.23.55.03;	author niklas;	state Exp;
branches;
next	;

1.37.2.1
date	2000.03.02.07.04.38;	author niklas;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2001.05.14.22.23.45;	author niklas;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2001.07.04.10.40.51;	author niklas;	state Exp;
branches;
next	1.37.2.4;

1.37.2.4
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.37.2.5;

1.37.2.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.37.2.6;

1.37.2.6
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.37.2.7;

1.37.2.7
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.37.2.8;

1.37.2.8
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	1.37.2.9;

1.37.2.9
date	2004.06.05.23.12.41;	author niklas;	state Exp;
branches;
next	;

1.54.4.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.54.4.2;

1.54.4.2
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.95
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: elink3.c,v 1.94 2016/04/13 10:49:26 mpi Exp $	*/
/*	$NetBSD: elink3.c,v 1.32 1997/05/14 00:22:00 thorpej Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jonathan Stone <jonathan@@NetBSD.org>
 * Copyright (c) 1994 Herb Peyerl <hpeyerl@@beer.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Herb Peyerl.
 * 4. The name of Herb Peyerl may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/selinfo.h>
#include <sys/timeout.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/cpu.h>
#include <machine/bus.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/ic/elink3var.h>
#include <dev/ic/elink3reg.h>

/*
 * Structure to map media-present bits in boards to 
 * ifmedia codes and printable media names. Used for table-driven
 * ifmedia initialization.
 */
struct ep_media {
	int	epm_eeprom_data;	/* bitmask for eeprom config */
	int	epm_conn;		/* sc->ep_connectors code for medium */
	char   *epm_name;		/* name of medium */
	uint64_t	epm_ifmedia;		/* ifmedia word for medium */
	int	epm_ifdata;
};

/*
 * ep_media table for Vortex/Demon/Boomerang:
 * map from media-present bits in register RESET_OPTIONS+2 
 * to  ifmedia "media words" and printable names.
 *
 * XXX indexed directly by INTERNAL_CONFIG default_media field,
 * (i.e., EPMEDIA_ constants)  forcing order of entries. 
 *  Note that 3 is reserved.
 */
const struct ep_media ep_vortex_media[] = {
  { EP_PCI_UTP,        EPC_UTP, "utp",	    IFM_ETHER|IFM_10_T,
       EPMEDIA_10BASE_T },
  { EP_PCI_AUI,        EPC_AUI, "aui",	    IFM_ETHER|IFM_10_5,
       EPMEDIA_AUI },
  { 0,                 0,  	"reserved", IFM_NONE,  EPMEDIA_RESV1 },
  { EP_PCI_BNC,        EPC_BNC, "bnc",	    IFM_ETHER|IFM_10_2,
       EPMEDIA_10BASE_2 },
  { EP_PCI_100BASE_TX, EPC_100TX, "100-TX", IFM_ETHER|IFM_100_TX,
       EPMEDIA_100BASE_TX },
  { EP_PCI_100BASE_FX, EPC_100FX, "100-FX", IFM_ETHER|IFM_100_FX,
       EPMEDIA_100BASE_FX },
  { EP_PCI_100BASE_MII,EPC_MII,   "mii",    IFM_ETHER|IFM_100_TX,
       EPMEDIA_MII },
  { EP_PCI_100BASE_T4, EPC_100T4, "100-T4", IFM_ETHER|IFM_100_T4,
       EPMEDIA_100BASE_T4 }
};

/*
 * ep_media table for 3c509/3c509b/3c579/3c589:
 * map from media-present bits in register CNFG_CNTRL
 * (window 0, offset ?) to  ifmedia "media words" and printable names.
 */
struct ep_media ep_isa_media[] = {
  { EP_W0_CC_UTP,  EPC_UTP, "utp",   IFM_ETHER|IFM_10_T, EPMEDIA_10BASE_T },
  { EP_W0_CC_AUI,  EPC_AUI, "aui",   IFM_ETHER|IFM_10_5, EPMEDIA_AUI },
  { EP_W0_CC_BNC,  EPC_BNC, "bnc",   IFM_ETHER|IFM_10_2, EPMEDIA_10BASE_2 },
};

/* Map vortex reset_options bits to if_media codes. */
const uint64_t ep_default_to_media[] = {
	IFM_ETHER | IFM_10_T,
	IFM_ETHER | IFM_10_5,
	0, 			/* reserved by 3Com */
	IFM_ETHER | IFM_10_2,
	IFM_ETHER | IFM_100_TX,
	IFM_ETHER | IFM_100_FX,
	IFM_ETHER | IFM_100_TX,	/* XXX really MII: need to talk to PHY */
	IFM_ETHER | IFM_100_T4,
};

struct cfdriver ep_cd = {
	NULL, "ep", DV_IFNET
};

void ep_vortex_probemedia(struct ep_softc *sc);
void ep_isa_probemedia(struct ep_softc *sc);

void eptxstat(struct ep_softc *);
int epstatus(struct ep_softc *);
int epioctl(struct ifnet *, u_long, caddr_t);
void epstart(struct ifnet *);
void epwatchdog(struct ifnet *);
void epreset(struct ep_softc *);
void epread(struct ep_softc *);
struct mbuf *epget(struct ep_softc *, int);
void epmbuffill(void *);
void epmbufempty(struct ep_softc *);
void epsetfilter(struct ep_softc *);
void ep_roadrunner_mii_enable(struct ep_softc *);
int epsetmedia(struct ep_softc *, int);

/* ifmedia callbacks */
int ep_media_change(struct ifnet *);
void ep_media_status(struct ifnet *, struct ifmediareq *);

/* MII callbacks */
int ep_mii_readreg(struct device *, int, int);
void ep_mii_writereg(struct device *, int, int, int);
void ep_statchg(struct device *);

void    ep_mii_setbit(struct ep_softc *, u_int16_t);
void    ep_mii_clrbit(struct ep_softc *, u_int16_t);
u_int16_t ep_mii_readbit(struct ep_softc *, u_int16_t);
void    ep_mii_sync(struct ep_softc *);
void    ep_mii_sendbits(struct ep_softc *, u_int32_t, int);

int epbusyeeprom(struct ep_softc *);
u_int16_t ep_read_eeprom(struct ep_softc *, u_int16_t);

static inline void ep_reset_cmd(struct ep_softc *sc, u_int cmd,u_int arg);
static inline void ep_finish_reset(bus_space_tag_t, bus_space_handle_t);
static inline void ep_discard_rxtop(bus_space_tag_t, bus_space_handle_t);
static __inline int ep_w1_reg(struct ep_softc *, int);

/*
 * Issue a (reset) command, and be sure it has completed.
 * Used for global reset, TX_RESET, RX_RESET.
 */
static inline void
ep_reset_cmd(struct ep_softc *sc, u_int cmd, u_int arg)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	bus_space_write_2(iot, ioh, cmd, arg);
	ep_finish_reset(iot, ioh);
}

/*
 * Wait for any pending reset to complete.
 */
static inline void
ep_finish_reset(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	int i;

	for (i = 0; i < 10000; i++) {
		if ((bus_space_read_2(iot, ioh, EP_STATUS) &
		    S_COMMAND_IN_PROGRESS) == 0)
			break;
		DELAY(10);
	}
}

static inline void
ep_discard_rxtop(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	int i;

	bus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);

	/*
	 * Spin for about 1 msec, to avoid forcing a DELAY() between
	 * every received packet (adding latency and limiting pkt-recv rate).
	 * On PCI, at 4 30-nsec PCI bus cycles for a read, 8000 iterations
	 * is about right.
	 */
	for (i = 0; i < 8000; i++) {
		if ((bus_space_read_2(iot, ioh, EP_STATUS) &
		    S_COMMAND_IN_PROGRESS) == 0)
			return;
	}

	/* not fast enough, do DELAY()s */
	ep_finish_reset(iot, ioh);
}

/*
 * Some chips (i.e., 3c574 RoadRunner) have Window 1 registers offset.
 */
static __inline int
ep_w1_reg(struct ep_softc *sc, int reg)
{
	switch (sc->ep_chipset) {
	case EP_CHIPSET_ROADRUNNER:
		switch (reg) {
		case EP_W1_FREE_TX:
		case EP_W1_RUNNER_RDCTL:
		case EP_W1_RUNNER_WRCTL:
			return (reg);
		}
		return (reg + 0x10);
	}
	return (reg);
}

/*
 * Back-end attach and configure.
 */
void
epconfig(struct ep_softc *sc, u_short chipset, u_int8_t *enaddr)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t i;

	sc->ep_chipset = chipset;

	/*
	 * We could have been groveling around in other register
	 * windows in the front-end; make sure we're in window 0
	 * to read the EEPROM.
	 */
	GO_WINDOW(0);

	if (enaddr == NULL) {
		/*
		 * Read the station address from the eeprom.
		 */
		for (i = 0; i < 3; i++) {
			u_int16_t x = ep_read_eeprom(sc, i);

			sc->sc_arpcom.ac_enaddr[(i << 1)] = x >> 8;
			sc->sc_arpcom.ac_enaddr[(i << 1) + 1] = x;
		}
	} else {
		bcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
	}

	printf(" address %s", ether_sprintf(sc->sc_arpcom.ac_enaddr));
	if (sc->ep_flags & EP_FLAGS_MII)
		printf("\n");
	else
		printf(", ");

	/*
	 * Vortex-based (3c59x pci,eisa) cards allow FDDI-sized (4500) byte
	 * packets.  Commands only take an 11-bit parameter, and  11 bits
	 * isn't enough to hold a full-size packet length.
	 * Commands to these cards implicitly upshift a packet size
	 * or threshold by 2 bits. 
	 * To detect  cards with large-packet support, we probe by setting
	 * the transmit threshold register, then change windows and
	 * read back the threshold register directly, and see if the
	 * threshold value was shifted or not.
	 */
	bus_space_write_2(iot, ioh, EP_COMMAND,
			  SET_TX_AVAIL_THRESH | EP_LARGEWIN_PROBE ); 
	GO_WINDOW(5);
	i = bus_space_read_2(iot, ioh, EP_W5_TX_AVAIL_THRESH);
	GO_WINDOW(1);
	switch (i)  {
	case EP_LARGEWIN_PROBE:
	case (EP_LARGEWIN_PROBE & EP_LARGEWIN_MASK):
		sc->txashift = 0;
		break;

	case (EP_LARGEWIN_PROBE << 2):
		sc->txashift = 2;
		/* XXX does the 3c515 support Vortex-style RESET_OPTIONS? */
		break;

	default:
		printf("wrote %x to TX_AVAIL_THRESH, read back %x. "
		    "Interface disabled\n", EP_THRESH_DISABLE, (int) i);
		return;
	}

	timeout_set(&sc->sc_epmbuffill_tmo, epmbuffill, sc);

	/*
	 * Ensure Tx-available interrupts are enabled for 
	 * start the interface.
	 * XXX should be in epinit()?
	 */
	bus_space_write_2(iot, ioh, EP_COMMAND,
	    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = epstart;
	ifp->if_ioctl = epioctl;
	ifp->if_watchdog = epwatchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	/* 64 packets are around 100ms on 10Mbps */
	IFQ_SET_MAXLEN(&ifp->if_snd, 64);

	if_attach(ifp);
	ether_ifattach(ifp);

	/*
	 * Finish configuration: 
	 * determine chipset if the front-end couldn't do so,
	 * show board details, set media.
	 */

	GO_WINDOW(0);

	ifmedia_init(&sc->sc_mii.mii_media, 0, ep_media_change,
	    ep_media_status);
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = ep_mii_readreg;
	sc->sc_mii.mii_writereg = ep_mii_writereg;
	sc->sc_mii.mii_statchg = ep_statchg;

	/*
	 * If we've got an indirect (ISA, PCMCIA?) board, the chipset
	 * is unknown.  If the board has large-packet support, it's a
	 * Vortex/Boomerang, otherwise it's a 3c509.
	 * XXX use eeprom capability word instead?
	 */
	if (sc->ep_chipset == EP_CHIPSET_UNKNOWN && sc->txashift)  {
		printf("warning: unknown chipset, possibly 3c515?\n");
#ifdef notyet
		sc->sc_chipset = EP_CHIPSET_VORTEX;
#endif	/* notyet */
	}

	/*
	 * Ascertain which media types are present and inform ifmedia.
	 */
	switch (sc->ep_chipset) {
	case EP_CHIPSET_ROADRUNNER:
		if (sc->ep_flags & EP_FLAGS_MII) {
			ep_roadrunner_mii_enable(sc);
			GO_WINDOW(0);
		}
		/* FALLTHROUGH */

	case EP_CHIPSET_BOOMERANG:
		/*
		 * If the device has MII, probe it.  We won't be using
		 * any `native' media in this case, only PHYs.  If
		 * we don't, just treat the Boomerang like the Vortex.
		 */
		if (sc->ep_flags & EP_FLAGS_MII) {
			mii_attach(&sc->sc_dev, &sc->sc_mii, 0xffffffff,
			    MII_PHY_ANY, MII_OFFSET_ANY, 0);
			if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
				ifmedia_add(&sc->sc_mii.mii_media,
				    IFM_ETHER|IFM_NONE, 0, NULL);
				ifmedia_set(&sc->sc_mii.mii_media,
				    IFM_ETHER|IFM_NONE);
			} else {
				ifmedia_set(&sc->sc_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
			}
			break;
		}
		/* FALLTHROUGH */

	/* on a direct bus, the attach routine can tell, but check anyway. */
	case EP_CHIPSET_VORTEX:
	case EP_CHIPSET_BOOMERANG2:
		ep_vortex_probemedia(sc);
		break;

	/* on ISA we can't yet tell 3c509 from 3c515. Assume the former. */
	case EP_CHIPSET_3C509:
	default:
		ep_isa_probemedia(sc);
		break;
	}

	GO_WINDOW(1);		/* Window 1 is operating window */

	sc->tx_start_thresh = 20;	/* probably a good starting point. */

	ep_reset_cmd(sc, EP_COMMAND, RX_RESET);
	ep_reset_cmd(sc, EP_COMMAND, TX_RESET);
}

int
ep_detach(struct device *self)
{
	struct ep_softc *sc = (struct ep_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	if (sc->ep_flags & EP_FLAGS_MII)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (0);
}

/*
 * Find supported media on 3c509-generation hardware that doesn't have
 * a "reset_options" register in window 3.
 * Use the config_cntrl register  in window 0 instead.
 * Used on original, 10Mbit ISA (3c509), 3c509B, and pre-Demon EISA cards
 * that implement  CONFIG_CTRL.  We don't have a good way to set the
 * default active medium; punt to ifconfig instead.
 *
 * XXX what about 3c515, pcmcia 10/100?
 */
void
ep_isa_probemedia(struct ep_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ifmedia *ifm = &sc->sc_mii.mii_media;
	int	conn, i;
	u_int16_t ep_w0_config, port;

	conn = 0;
	GO_WINDOW(0);
	ep_w0_config = bus_space_read_2(iot, ioh, EP_W0_CONFIG_CTRL);
	for (i = 0; i < nitems(ep_isa_media); i++) {
		struct ep_media * epm = ep_isa_media + i;

		if ((ep_w0_config & epm->epm_eeprom_data) != 0) {
			ifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);
			if (conn)
				printf("/");
			printf("%s", epm->epm_name);
			conn |= epm->epm_conn;
		}
	}
	sc->ep_connectors = conn;

	/* get default medium from EEPROM */
	if (epbusyeeprom(sc))
		return;		/* XXX why is eeprom busy? */
	bus_space_write_2(iot, ioh, EP_W0_EEPROM_COMMAND,
	    READ_EEPROM | EEPROM_ADDR_CFG);
	if (epbusyeeprom(sc))
		return;		/* XXX why is  eeprom busy? */
	port = bus_space_read_2(iot, ioh, EP_W0_EEPROM_DATA);
	port = port >> 14;

	printf(" (default %s)\n", ep_vortex_media[port].epm_name);

	/* tell ifconfig what currently-active media is. */
	ifmedia_set(ifm, ep_default_to_media[port]);

	/* XXX autoselect not yet implemented */
}


/*
 * Find media present on large-packet-capable elink3 devices.
 * Show onboard configuration of large-packet-capable elink3 devices
 * (Demon, Vortex, Boomerang), which do not implement CONFIG_CTRL in window 0.
 * Use media and card-version info in window 3 instead.
 *
 * XXX how much of this works with 3c515, pcmcia 10/100?
 */
void
ep_vortex_probemedia(struct ep_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ifmedia *ifm = &sc->sc_mii.mii_media;
	u_int config1, conn;
	int reset_options;
	int default_media;	/* 3-bit encoding of default (EEPROM) media */
	int autoselect;		/* boolean: should default to autoselect */
	const char *medium_name;
	register int i;

	GO_WINDOW(3);
	config1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);
	reset_options  = (int)bus_space_read_1(iot, ioh, EP_W3_RESET_OPTIONS);
	GO_WINDOW(0);

	default_media = (config1 & CONFIG_MEDIAMASK) >> CONFIG_MEDIAMASK_SHIFT;
        autoselect = (config1 & CONFIG_AUTOSELECT) >> CONFIG_AUTOSELECT_SHIFT;

	/* set available media options */
	conn = 0;
	for (i = 0; i < nitems(ep_vortex_media); i++) {
		const struct ep_media *epm = ep_vortex_media + i;

		if ((reset_options & epm->epm_eeprom_data) != 0) {
			if (conn)
				printf("/");
			printf("%s", epm->epm_name);
			conn |= epm->epm_conn;
			ifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);
		}
	}

	sc->ep_connectors = conn;

	/* Show  eeprom's idea of default media.  */
	medium_name = (default_media > nitems(ep_vortex_media) - 1)
		? "(unknown/impossible media)"
		: ep_vortex_media[default_media].epm_name;
	printf(" default %s%s",
	       medium_name, (autoselect) ? "/autoselect" : "");
/*	sc->sc_media = ep_vortex_media[default_media].epm_ifdata;*/

#ifdef notyet	
	/*
	 * Set default: either the active interface the card
	 * reads  from the EEPROM, or if autoselect is true,
	 * whatever we find is actually connected. 
	 *
	 * XXX autoselect not yet implemented.
	 */
#endif	/* notyet */

	/* tell ifconfig what currently-active media is. */
	ifmedia_set(ifm, ep_default_to_media[default_media]);
}

/*
 * Bring device up.
 *
 * The order in here seems important. Otherwise we may not receive
 * interrupts. ?!
 */
void
epinit(struct ep_softc *sc)
{
	register struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i;

	/* make sure any pending reset has completed before touching board */
	ep_finish_reset(iot, ioh);

	/* cancel any pending I/O */
	epstop(sc);

	if (sc->bustype != EP_BUS_PCI) {
		GO_WINDOW(0);
		bus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, 0);
		bus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);
	}

	if (sc->bustype == EP_BUS_PCMCIA) {
		bus_space_write_2(iot, ioh, EP_W0_RESOURCE_CFG, 0x3f00);
	}

	GO_WINDOW(2);
	for (i = 0; i < 6; i++)	/* Reload the ether_addr. */
		bus_space_write_1(iot, ioh, EP_W2_ADDR_0 + i,
		    sc->sc_arpcom.ac_enaddr[i]);

	if (sc->bustype == EP_BUS_PCI || sc->bustype == EP_BUS_EISA)
		/*
		 * Reset the station-address receive filter.
		 * A bug workaround for busmastering  (Vortex, Demon) cards.
		 */
		for (i = 0; i < 6; i++)
			bus_space_write_1(iot, ioh, EP_W2_RECVMASK_0 + i, 0);

	ep_reset_cmd(sc, EP_COMMAND, RX_RESET);
	ep_reset_cmd(sc, EP_COMMAND, TX_RESET);

	GO_WINDOW(1);		/* Window 1 is operating window */
	for (i = 0; i < 31; i++)
		bus_space_read_1(iot, ioh, ep_w1_reg(sc, EP_W1_TX_STATUS));

	/* Set threshold for for Tx-space available interrupt. */
	bus_space_write_2(iot, ioh, EP_COMMAND,
	    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));

	if (sc->ep_chipset == EP_CHIPSET_ROADRUNNER) {
		/* Enable options in the PCMCIA LAN COR register, via
		 * RoadRunner Window 1.
		 *
		 * XXX MAGIC CONSTANTS!
		 */
		u_int16_t cor;

		bus_space_write_2(iot, ioh, EP_W1_RUNNER_RDCTL, (1 << 11));

		cor = bus_space_read_2(iot, ioh, 0) & ~0x30;
		bus_space_write_2(iot, ioh, 0, cor);

		bus_space_write_2(iot, ioh, EP_W1_RUNNER_WRCTL, 0);
		bus_space_write_2(iot, ioh, EP_W1_RUNNER_RDCTL, 0);

		if (sc->ep_flags & EP_FLAGS_MII) {
			ep_roadrunner_mii_enable(sc);
			GO_WINDOW(1);
		}
	}

	/* Enable interrupts. */
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK |
	    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK |
	    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);

	/*
	 * Attempt to get rid of any stray interrupts that occurred during
	 * configuration.  On the i386 this isn't possible because one may
	 * already be queued.  However, a single stray interrupt is
	 * unimportant.
	 */
	bus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | 0xff);

	epsetfilter(sc);
	epsetmedia(sc, sc->sc_mii.mii_media.ifm_cur->ifm_data);

	bus_space_write_2(iot, ioh, EP_COMMAND, RX_ENABLE);
	bus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);

	epmbuffill(sc);

	/* Interface is now `running', with no output active. */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* Attempt to start output, if any. */
	epstart(ifp);
}

/*
 * Set multicast receive filter. 
 * elink3 hardware has no selective multicast filter in hardware.
 * Enable reception of all multicasts and filter in software.
 */
void
epsetfilter(struct ep_softc *sc)
{
	register struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	GO_WINDOW(1);		/* Window 1 is operating window */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_COMMAND, SET_RX_FILTER |
	    FIL_INDIVIDUAL | FIL_BRDCST |
	    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |
	    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));
}


int
ep_media_change(struct ifnet *ifp)
{
	register struct ep_softc *sc = ifp->if_softc;

	return	epsetmedia(sc, sc->sc_mii.mii_media.ifm_cur->ifm_data);
}

/*
 * Reset and enable the MII on the RoadRunner.
 */
void
ep_roadrunner_mii_enable(struct ep_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	GO_WINDOW(3);
	bus_space_write_2(iot, ioh, EP_W3_RESET_OPTIONS,
	    EP_PCI_100BASE_MII|EP_RUNNER_ENABLE_MII);
	delay(1000);
	bus_space_write_2(iot, ioh, EP_W3_RESET_OPTIONS,
	    EP_PCI_100BASE_MII|EP_RUNNER_MII_RESET|EP_RUNNER_ENABLE_MII);
	ep_reset_cmd(sc, EP_COMMAND, TX_RESET);
	ep_reset_cmd(sc, EP_COMMAND, RX_RESET);
	delay(1000);
	bus_space_write_2(iot, ioh, EP_W3_RESET_OPTIONS,
	    EP_PCI_100BASE_MII|EP_RUNNER_ENABLE_MII);
}

/*
 * Set active media to a specific given EPMEDIA_<> value.
 * For vortex/demon/boomerang cards, update media field in w3_internal_config,
 *       and power on selected transceiver.
 * For 3c509-generation cards (3c509/3c579/3c589/3c509B),
 *	update media field in w0_address_config, and power on selected xcvr.
 */
int
epsetmedia(struct ep_softc *sc, int medium)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int w4_media;
	int config0, config1;

	/*
	 * you can `ifconfig (link0|-link0) ep0' to get the following
	 * behaviour:
	 *	-link0	disable AUI/UTP. enable BNC.
	 *	link0	disable BNC. enable AUI.
	 *	link1	if the card has a UTP connector, and link0 is
	 *		set too, then you get the UTP port.
	 */

	/*
	 * First, change the media-control bits in EP_W4_MEDIA_TYPE.
	 */

	 /* Turn everything off.  First turn off linkbeat and UTP. */
	GO_WINDOW(4);
	w4_media = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);
	w4_media =  w4_media & ~(ENABLE_UTP|SQE_ENABLE);
	bus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, w4_media);

	/* Turn off coax */
	bus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);
	delay(1000);

	/* If the device has MII, select it, and then tell the
	 * PHY which media to use.
	 */
	if (sc->ep_flags & EP_FLAGS_MII) {
		GO_WINDOW(3);

		if (sc->ep_chipset == EP_CHIPSET_ROADRUNNER) {
			int resopt;

			resopt = bus_space_read_2(iot, ioh,
			    EP_W3_RESET_OPTIONS);
			bus_space_write_2(iot, ioh, EP_W3_RESET_OPTIONS,
			    resopt | EP_RUNNER_ENABLE_MII);
		}

		config0 = (u_int)bus_space_read_2(iot, ioh,
		    EP_W3_INTERNAL_CONFIG);
		config1 = (u_int)bus_space_read_2(iot, ioh,
		    EP_W3_INTERNAL_CONFIG + 2);

		config1 = config1 & ~CONFIG_MEDIAMASK;
		config1 |= (EPMEDIA_MII << CONFIG_MEDIAMASK_SHIFT);

		bus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);
		bus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);
		GO_WINDOW(1);	/* back to operating window */

		mii_mediachg(&sc->sc_mii);
		return (0);
	}

	/*
	 * Now turn on the selected media/transceiver.
	 */
	GO_WINDOW(4);
	switch (medium) {
	case EPMEDIA_10BASE_T:
		bus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, (ENABLE_UTP |
		    (sc->bustype == EP_BUS_PCMCIA ? MEDIA_LED : 0)));
		break;

	case EPMEDIA_10BASE_2:
		bus_space_write_2(iot, ioh, EP_COMMAND, START_TRANSCEIVER);
		DELAY(1000);	/* 50ms not enough? */
		break;

	/* XXX following only for new-generation cards */
	case EPMEDIA_100BASE_TX:
	case EPMEDIA_100BASE_FX:
	case EPMEDIA_100BASE_T4:	/* XXX check documentation */
		bus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,
		    w4_media | LINKBEAT_ENABLE);
		DELAY(1000);	/* not strictly necessary? */
		break;

	case EPMEDIA_AUI:
		bus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,
		    w4_media | SQE_ENABLE);
		DELAY(1000);	/*  not strictly necessary? */
		break;
	case EPMEDIA_MII:
		break;
	default:
#if defined(EP_DEBUG)
		printf("%s unknown media 0x%x\n", sc->sc_dev.dv_xname, medium);
#endif
		break;
		
	}

	/*
	 * Tell the chip which PHY [sic] to use.
	 */
	switch (sc->ep_chipset) {
	case EP_CHIPSET_VORTEX:
	case EP_CHIPSET_BOOMERANG2:
		GO_WINDOW(3);
		config0 = (u_int)bus_space_read_2(iot, ioh,
		    EP_W3_INTERNAL_CONFIG);
		config1 = (u_int)bus_space_read_2(iot, ioh,
		    EP_W3_INTERNAL_CONFIG + 2);

#if defined(EP_DEBUG)
		printf("%s:  read 0x%x, 0x%x from EP_W3_CONFIG register\n",
		       sc->sc_dev.dv_xname, config0, config1);
#endif
		config1 = config1 & ~CONFIG_MEDIAMASK;
		config1 |= (medium << CONFIG_MEDIAMASK_SHIFT);
		
#if defined(EP_DEBUG)
		printf("epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\n",
		    sc->sc_dev.dv_xname, medium, config1);
#endif
		bus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);
		bus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);
		break;

	default:
		GO_WINDOW(0);
		config0 = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);
		config0 &= 0x3fff;
		bus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,
		    config0 | (medium << 14));
		DELAY(1000);
		break;
	}

	GO_WINDOW(1);		/* Window 1 is operating window */
	return (0);
}


/*
 * Get currently-selected media from card.
 * (if_media callback, may be called before interface is brought up).
 */
void
ep_media_status(struct ifnet *ifp, struct ifmediareq *req)
{
	register struct ep_softc *sc = ifp->if_softc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int config1;
	u_int ep_mediastatus;

	/*
	 * If we have MII, go ask the PHY what's going on.
	 */
	if (sc->ep_flags & EP_FLAGS_MII) {
		mii_pollstat(&sc->sc_mii);
		req->ifm_active = sc->sc_mii.mii_media_active;
		req->ifm_status = sc->sc_mii.mii_media_status;
		return;
	}

	/* XXX read from softc when we start autosensing media */
	req->ifm_active = sc->sc_mii.mii_media.ifm_cur->ifm_media;
	
	switch (sc->ep_chipset) {
	case EP_CHIPSET_VORTEX:
	case EP_CHIPSET_BOOMERANG:
		GO_WINDOW(3);
		delay(5000);

		config1 = bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);
		GO_WINDOW(1);

		config1 = 
		    (config1 & CONFIG_MEDIAMASK) >> CONFIG_MEDIAMASK_SHIFT;
		req->ifm_active = ep_default_to_media[config1];

		/* XXX check full-duplex bits? */

		GO_WINDOW(4);
		req->ifm_status = IFM_AVALID;	/* XXX */
		ep_mediastatus = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);
		if (ep_mediastatus & LINKBEAT_DETECT)
			req->ifm_status |= IFM_ACTIVE; 	/* XXX  automedia */

		break;

	case EP_CHIPSET_UNKNOWN:
	case EP_CHIPSET_3C509:
		req->ifm_status = 0;	/* XXX */
		break;

	default:
		printf("%s: media_status on unknown chipset 0x%x\n",
		       ifp->if_xname, sc->ep_chipset);
		break;
	}

	/* XXX look for softc heartbeat for other chips or media */

	GO_WINDOW(1);
	return;
}



/*
 * Start outputting on the interface.
 * Always called as splnet().
 */
void
epstart(struct ifnet *ifp)
{
	register struct ep_softc *sc = ifp->if_softc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct mbuf *m, *m0;
	caddr_t data;
	int sh, len, pad, txreg;

	/* Don't transmit if interface is busy or not running */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

startagain:
	/* Sneak a peek at the next packet */
	m0 = ifq_deq_begin(&ifp->if_snd);
	if (m0 == NULL)
		return;

	/* We need to use m->m_pkthdr.len, so require the header */
	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("epstart: no header mbuf");
	len = m0->m_pkthdr.len;

	pad = (4 - len) & 3;

	/*
	 * The 3c509 automatically pads short packets to minimum ethernet
	 * length, but we drop packets that are too large. Perhaps we should
	 * truncate them instead?
	 */
	if (len + pad > ETHER_MAX_LEN) {
		/* packet is obviously too large: toss it */
		++ifp->if_oerrors;
		ifq_deq_commit(&ifp->if_snd, m0);
		m_freem(m0);
		goto readcheck;
	}

	if (bus_space_read_2(iot, ioh, ep_w1_reg(sc, EP_W1_FREE_TX)) <
	    len + pad + 4) {
		bus_space_write_2(iot, ioh, EP_COMMAND,
		    SET_TX_AVAIL_THRESH | ((len + pad + 4) >> sc->txashift));
		/* not enough room in FIFO */
		ifq_deq_rollback(&ifp->if_snd, m0);
		ifq_set_oactive(&ifp->if_snd);
		return;
	} else {
		bus_space_write_2(iot, ioh, EP_COMMAND,
		    SET_TX_AVAIL_THRESH | EP_THRESH_DISABLE);
	}

	ifq_deq_commit(&ifp->if_snd, m0);
	if (m0 == NULL)
		return;

	bus_space_write_2(iot, ioh, EP_COMMAND, SET_TX_START_THRESH |
	    ((len / 4 + sc->tx_start_thresh) /*>> sc->txashift*/));

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

	/*
	 * Do the output at splhigh() so that an interrupt from another device
	 * won't cause a FIFO underrun.
	 */
	sh = splhigh();

	txreg = ep_w1_reg(sc, EP_W1_TX_PIO_WR_1);

	bus_space_write_2(iot, ioh, txreg, len);
	bus_space_write_2(iot, ioh, txreg, 0xffff); /* Second is meaningless */
	if (EP_IS_BUS_32(sc->bustype)) {
		for (m = m0; m; ) {
			data = mtod(m, u_int8_t *);
			if (m->m_len > 3 && ALIGNED_POINTER(data, uint32_t)) {
				bus_space_write_raw_multi_4(iot, ioh, txreg,
				    data, m->m_len & ~3);
				if (m->m_len & 3)
					bus_space_write_multi_1(iot, ioh, txreg,
					    data + (m->m_len & ~3),
					    m->m_len & 3);
			} else
				bus_space_write_multi_1(iot, ioh, txreg,
				    data, m->m_len);
			m0 = m_free(m);
			m = m0;
		}
	} else {
		for (m = m0; m; ) {
			data = mtod(m, u_int8_t *);
			if (m->m_len > 1 && ALIGNED_POINTER(data, uint16_t)) {
				bus_space_write_raw_multi_2(iot, ioh, txreg,
				    data, m->m_len & ~1);
				if (m->m_len & 1)
					bus_space_write_1(iot, ioh, txreg,
					     *(data + m->m_len - 1));
			} else
				bus_space_write_multi_1(iot, ioh, txreg,
				    data, m->m_len);
			m0 = m_free(m);
			m = m0;
		}
	}
	while (pad--)
		bus_space_write_1(iot, ioh, txreg, 0);

	splx(sh);

readcheck:
	if ((bus_space_read_2(iot, ioh, ep_w1_reg(sc, EP_W1_RX_STATUS)) &
	    ERR_INCOMPLETE) == 0) {
		/* We received a complete packet. */
		u_int16_t status = bus_space_read_2(iot, ioh, EP_STATUS);

		if ((status & S_INTR_LATCH) == 0) {
			/*
			 * No interrupt, read the packet and continue
			 * Is  this supposed to happen? Is my motherboard 
			 * completely busted?
			 */
			epread(sc);
		} else
			/* Got an interrupt, return to get it serviced. */
			return;
	} else {
		/* Check if we are stuck and reset [see XXX comment] */
		if (epstatus(sc)) {
#ifdef EP_DEBUG
			if (ifp->if_flags & IFF_DEBUG)
				printf("%s: adapter reset\n",
				    sc->sc_dev.dv_xname);
#endif
			epreset(sc);
		}
	}

	goto startagain;
}


/*
 * XXX: The 3c509 card can get in a mode where both the fifo status bit
 *	FIFOS_RX_OVERRUN and the status bit ERR_INCOMPLETE are set
 *	We detect this situation and we reset the adapter.
 *	It happens at times when there is a lot of broadcast traffic
 *	on the cable (once in a blue moon).
 */
int
epstatus(struct ep_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t fifost;

	/*
	 * Check the FIFO status and act accordingly
	 */
	GO_WINDOW(4);
	fifost = bus_space_read_2(iot, ioh, EP_W4_FIFO_DIAG);
	GO_WINDOW(1);

	if (fifost & FIFOS_RX_UNDERRUN) {
#ifdef EP_DEBUG
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf("%s: RX underrun\n", sc->sc_dev.dv_xname);
#endif
		epreset(sc);
		return 0;
	}

	if (fifost & FIFOS_RX_STATUS_OVERRUN) {
#ifdef EP_DEBUG
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf("%s: RX Status overrun\n", sc->sc_dev.dv_xname);
#endif
		return 1;
	}

	if (fifost & FIFOS_RX_OVERRUN) {
#ifdef EP_DEBUG
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf("%s: RX overrun\n", sc->sc_dev.dv_xname);
#endif
		return 1;
	}

	if (fifost & FIFOS_TX_OVERRUN) {
#ifdef EP_DEBUG
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf("%s: TX overrun\n", sc->sc_dev.dv_xname);
#endif
		epreset(sc);
		return 0;
	}

	return 0;
}


void
eptxstat(struct ep_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i;

	/*
	 * We need to read+write TX_STATUS until we get a 0 status
	 * in order to turn off the interrupt flag.
	 */
	while ((i = bus_space_read_1(iot, ioh,
	    ep_w1_reg(sc, EP_W1_TX_STATUS))) & TXS_COMPLETE) {
		bus_space_write_1(iot, ioh, ep_w1_reg(sc, EP_W1_TX_STATUS),
		    0x0);

		if (i & TXS_JABBER) {
			++sc->sc_arpcom.ac_if.if_oerrors;
#ifdef EP_DEBUG
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
				printf("%s: jabber (%x)\n",
				       sc->sc_dev.dv_xname, i);
#endif
			epreset(sc);
		} else if (i & TXS_UNDERRUN) {
			++sc->sc_arpcom.ac_if.if_oerrors;
#ifdef EP_DEBUG
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
				printf("%s: fifo underrun (%x) @@%d\n",
				       sc->sc_dev.dv_xname, i,
				       sc->tx_start_thresh);
#endif
			if (sc->tx_succ_ok < 100)
				    sc->tx_start_thresh = min(ETHER_MAX_LEN,
					    sc->tx_start_thresh + 20);
			sc->tx_succ_ok = 0;
			epreset(sc);
		} else if (i & TXS_MAX_COLLISION) {
			++sc->sc_arpcom.ac_if.if_collisions;
			bus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);
			ifq_clr_oactive(&sc->sc_arpcom.ac_if.if_snd);
		} else
			sc->tx_succ_ok = (sc->tx_succ_ok+1) & 127;
	}
}

int
epintr(void *arg)
{
	register struct ep_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int16_t status;
	int ret = 0;

	for (;;) {
		bus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);

		status = bus_space_read_2(iot, ioh, EP_STATUS);

		if ((status & (S_TX_COMPLETE | S_TX_AVAIL |
			       S_RX_COMPLETE | S_CARD_FAILURE)) == 0)
			break;

		ret = 1;

		/*
		 * Acknowledge any interrupts.  It's important that we do this
		 * first, since there would otherwise be a race condition.
		 * Due to the i386 interrupt queueing, we may get spurious
		 * interrupts occasionally.
		 */
		bus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | status);

		if (status & S_RX_COMPLETE)
			epread(sc);
		if (status & S_TX_AVAIL) {
			ifq_clr_oactive(&ifp->if_snd);
			epstart(ifp);
		}
		if (status & S_CARD_FAILURE) {
			epreset(sc);
			return (1);
		}
		if (status & S_TX_COMPLETE) {
			eptxstat(sc);
			epstart(ifp);
		}
	}	

	/* no more interrupts */
	return (ret);
}

void
epread(struct ep_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	int len, error = 0;

	len = bus_space_read_2(iot, ioh, ep_w1_reg(sc, EP_W1_RX_STATUS));

again:
#ifdef EP_DEBUG
	if (ifp->if_flags & IFF_DEBUG) {
		int err = len & ERR_MASK;
		char *s = NULL;

		if (len & ERR_INCOMPLETE)
			s = "incomplete packet";
		else if (err == ERR_OVERRUN)
			s = "packet overrun";
		else if (err == ERR_RUNT)
			s = "runt packet";
		else if (err == ERR_ALIGNMENT)
			s = "bad alignment";
		else if (err == ERR_CRC)
			s = "bad crc";
		else if (err == ERR_OVERSIZE)
			s = "oversized packet";
		else if (err == ERR_DRIBBLE)
			s = "dribble bits";

		if (s)
			printf("%s: %s\n", sc->sc_dev.dv_xname, s);
	}
#endif

	if (len & ERR_INCOMPLETE)
		goto done;

	if (len & ERR_RX) {
		++ifp->if_ierrors;
		error = 1;
		goto done;
	}

	len &= RX_BYTES_MASK;	/* Lower 11 bits = RX bytes. */

	/* Pull packet off interface. */
	m = epget(sc, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		error = 1;
		goto done;
	}

	ml_enqueue(&ml, m);

	/*
	 * In periods of high traffic we can actually receive enough
	 * packets so that the fifo overrun bit will be set at this point,
	 * even though we just read a packet. In this case we
	 * are not going to receive any more interrupts. We check for
	 * this condition and read again until the fifo is not full.
	 * We could simplify this test by not using epstatus(), but
	 * rechecking the RX_STATUS register directly. This test could
	 * result in unnecessary looping in cases where there is a new
	 * packet but the fifo is not full, but it will not fix the
	 * stuck behavior.
	 *
	 * Even with this improvement, we still get packet overrun errors
	 * which are hurting performance. Maybe when I get some more time
	 * I'll modify epread() so that it can handle RX_EARLY interrupts.
	 */
	if (epstatus(sc)) {
		len = bus_space_read_2(iot, ioh,
		    ep_w1_reg(sc, EP_W1_RX_STATUS));
		/* Check if we are stuck and reset [see XXX comment] */
		if (len & ERR_INCOMPLETE) {
#ifdef EP_DEBUG
			if (ifp->if_flags & IFF_DEBUG)
				printf("%s: adapter reset\n",
				    sc->sc_dev.dv_xname);
#endif
			epreset(sc);
			goto done;
		}
		goto again;
	}
done:
	if (error)
		ep_discard_rxtop(iot, ioh);
	if_input(ifp, &ml);
}

struct mbuf *
epget(struct ep_softc *sc, int totlen)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct mbuf *m;
	caddr_t data;
	int len, pad, off, sh, rxreg;

	splassert(IPL_NET);

	m = sc->mb[sc->next_mb];
	sc->mb[sc->next_mb] = NULL;
	if (m == NULL) {
		m = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
		/* If the queue is no longer full, refill. */
		if (!timeout_pending(&sc->sc_epmbuffill_tmo))
			timeout_add(&sc->sc_epmbuffill_tmo, 1);
	}
	if (!m)
		return (NULL);

	sc->next_mb = (sc->next_mb + 1) % MAX_MBS;

	len = MCLBYTES;
	m->m_pkthdr.len = totlen;
	m->m_len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m->m_data += pad;
	len -= pad;

	/*
	 * We read the packet at splhigh() so that an interrupt from another
	 * device doesn't cause the card's buffer to overflow while we're
	 * reading it.  We may still lose packets at other times.
	 */
	sh = splhigh();

	rxreg = ep_w1_reg(sc, EP_W1_RX_PIO_RD_1);

	off = 0;
	while (totlen) {
		len = min(totlen, M_TRAILINGSPACE(m));
		if (len == 0)
			panic("ep_get: packet does not fit in MCLBYTES");

		data = mtod(m, u_int8_t *);
		if (EP_IS_BUS_32(sc->bustype))
			pad = 4 - ((u_long)(data + off) & 0x3);
		else
			pad = (u_long)(data + off) & 0x1;

		if (pad) {
			if (pad < len)
				pad = len;
			bus_space_read_multi_1(iot, ioh, rxreg,
			    data + off, pad);
			len = pad;
		} else if (EP_IS_BUS_32(sc->bustype) && len > 3 &&
		    ALIGNED_POINTER(data, uint32_t)) {
			len &= ~3;
			bus_space_read_raw_multi_4(iot, ioh, rxreg,
			    data + off, len);
		} else if (len > 1 && ALIGNED_POINTER(data, uint16_t)) {
			len &= ~1;
			bus_space_read_raw_multi_2(iot, ioh, rxreg,
			    data + off, len);
		} else
			bus_space_read_multi_1(iot, ioh, rxreg,
			    data + off, len);

		off += len;
		totlen -= len;
	}

	ep_discard_rxtop(iot, ioh);

	splx(sh);

	return m;
}

int
epioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ep_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			epinit(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				epinit(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				epstop(sc);
 		}
 		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			epreset(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
epreset(struct ep_softc *sc)
{
	int s;

	s = splnet();
	epinit(sc);
	splx(s);
}

void
epwatchdog(struct ifnet *ifp)
{
	struct ep_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	epreset(sc);
}

void
epstop(struct ep_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (sc->ep_flags & EP_FLAGS_MII) {
		mii_down(&sc->sc_mii);
	}

	if (sc->ep_chipset == EP_CHIPSET_ROADRUNNER) {
		/* Clear the FIFO buffer count, thus halting
		 * any currently-running transactions.
		 */
		GO_WINDOW(1);		/* sanity */
		bus_space_write_2(iot, ioh, EP_W1_RUNNER_WRCTL, 0);
		bus_space_write_2(iot, ioh, EP_W1_RUNNER_RDCTL, 0);
	}

	bus_space_write_2(iot, ioh, EP_COMMAND, RX_DISABLE);
	ep_discard_rxtop(iot, ioh);

	bus_space_write_2(iot, ioh, EP_COMMAND, TX_DISABLE);
	bus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);

	ep_reset_cmd(sc, EP_COMMAND, RX_RESET);
	ep_reset_cmd(sc, EP_COMMAND, TX_RESET);

	bus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK);
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK);
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_RX_FILTER);

	epmbufempty(sc);
}

/*
 * We get eeprom data from the id_port given an offset into the
 * eeprom.  Basically; after the ID_sequence is sent to all of
 * the cards; they enter the ID_CMD state where they will accept
 * command requests. 0x80-0xbf loads the eeprom data.  We then
 * read the port 16 times and with every read; the cards check
 * for contention (ie: if one card writes a 0 bit and another
 * writes a 1 bit then the host sees a 0. At the end of the cycle;
 * each card compares the data on the bus; if there is a difference
 * then that card goes into ID_WAIT state again). In the meantime;
 * one bit of data is returned in the AX register which is conveniently
 * returned to us by bus_space_read_1().  Hence; we read 16 times getting one
 * bit of data with each read.
 *
 * NOTE: the caller must provide an i/o handle for ELINK_ID_PORT!
 */
u_int16_t
epreadeeprom(bus_space_tag_t iot, bus_space_handle_t ioh, int offset)
{
	u_int16_t data = 0;
	int i;

	bus_space_write_1(iot, ioh, 0, 0x80 + offset);
	delay(1000);
	for (i = 0; i < 16; i++)
		data = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);
	return (data);
}

int
epbusyeeprom(struct ep_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i = 100, j;

	while (i--) {
		j = bus_space_read_2(iot, ioh, EP_W0_EEPROM_COMMAND);
		if (j & EEPROM_BUSY)
			delay(100);
		else
			break;
	}
	if (!i) {
		printf("\n%s: eeprom failed to come ready\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}
	if (sc->bustype != EP_BUS_PCMCIA && sc->bustype != EP_BUS_PCI &&
	    (j & EEPROM_TST_MODE)) {
		printf("\n%s: erase pencil mark, or disable PnP mode!\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}
	return (0);
}

u_int16_t
ep_read_eeprom(struct ep_softc *sc, u_int16_t offset)
{
	u_int16_t readcmd;

	/*
	 * RoadRunner has a larger EEPROM, so a different read command
	 * is required.
	 */
	if (sc->ep_chipset == EP_CHIPSET_ROADRUNNER)
		readcmd = READ_EEPROM_RR;
	else
		readcmd = READ_EEPROM;

	if (epbusyeeprom(sc))
		return (0);			/* XXX why is eeprom busy? */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W0_EEPROM_COMMAND,
	    readcmd | offset);
	if (epbusyeeprom(sc))
		return (0);			/* XXX why is eeprom busy? */

	return (bus_space_read_2(sc->sc_iot, sc->sc_ioh, EP_W0_EEPROM_DATA));
}

void
epmbuffill(void *v)
{
	struct ep_softc *sc = v;
	int s, i;

	s = splnet();
	for (i = 0; i < MAX_MBS; i++) {
		if (sc->mb[i] == NULL) {
			sc->mb[i] = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
			if (sc->mb[i] == NULL)
				break;
		}
	}
	/* If the queue was not filled, try again. */
	if (i < MAX_MBS)
		timeout_add(&sc->sc_epmbuffill_tmo, 1);
	splx(s);
}

void
epmbufempty(struct ep_softc *sc)
{
	int s, i;

	s = splnet();
	for (i = 0; i<MAX_MBS; i++) {
		if (sc->mb[i]) {
			m_freem(sc->mb[i]);
			sc->mb[i] = NULL;
		}
	}
	sc->next_mb = 0;
	timeout_del(&sc->sc_epmbuffill_tmo);
	splx(s);
}

void
ep_mii_setbit(struct ep_softc *sc, u_int16_t bit)
{
        u_int16_t val;

        /* We assume we're already in Window 4 */
        val = bus_space_read_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT);
        bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT,
            val | bit);
}

void
ep_mii_clrbit(struct ep_softc *sc, u_int16_t bit)
{
        u_int16_t val;

        /* We assume we're already in Window 4 */
        val = bus_space_read_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT);
        bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT,
            val & ~bit);
}

u_int16_t
ep_mii_readbit(struct ep_softc *sc, u_int16_t bit)
{

        /* We assume we're already in Window 4 */
        return (bus_space_read_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT) &
            bit);
}

void
ep_mii_sync(struct ep_softc *sc)
{
        int i;

        /* We assume we're already in Window 4 */
        ep_mii_clrbit(sc, PHYSMGMT_DIR);
        for (i = 0; i < 32; i++) {
                ep_mii_clrbit(sc, PHYSMGMT_CLK);
                ep_mii_setbit(sc, PHYSMGMT_CLK);
        }
}

void
ep_mii_sendbits(struct ep_softc *sc, u_int32_t data, int nbits)
{
        int i;

        /* We assume we're already in Window 4 */
        ep_mii_setbit(sc, PHYSMGMT_DIR);
        for (i = 1 << (nbits - 1); i; i = i >> 1) {
                ep_mii_clrbit(sc, PHYSMGMT_CLK);
                ep_mii_readbit(sc, PHYSMGMT_CLK);
                if (data & i)
                        ep_mii_setbit(sc, PHYSMGMT_DATA);
                else
                        ep_mii_clrbit(sc, PHYSMGMT_DATA);
                ep_mii_setbit(sc, PHYSMGMT_CLK);
                ep_mii_readbit(sc, PHYSMGMT_CLK);
        }
}

int
ep_mii_readreg(struct device *self, int phy, int reg)
{
        struct ep_softc *sc = (struct ep_softc *)self;
        int val = 0, i, err;

        /*
         * Read the PHY register by manually driving the MII control lines.
         */

        GO_WINDOW(4);

        bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT, 0);

        ep_mii_sync(sc);
        ep_mii_sendbits(sc, MII_COMMAND_START, 2);
        ep_mii_sendbits(sc, MII_COMMAND_READ, 2);
        ep_mii_sendbits(sc, phy, 5);
        ep_mii_sendbits(sc, reg, 5);

        ep_mii_clrbit(sc, PHYSMGMT_DIR);
        ep_mii_clrbit(sc, PHYSMGMT_CLK);
        ep_mii_setbit(sc, PHYSMGMT_CLK);
        ep_mii_clrbit(sc, PHYSMGMT_CLK);

        err = ep_mii_readbit(sc, PHYSMGMT_DATA);
        ep_mii_setbit(sc, PHYSMGMT_CLK);

        /* Even if an error occurs, must still clock out the cycle. */
        for (i = 0; i < 16; i++) {
                val <<= 1;
                ep_mii_clrbit(sc, PHYSMGMT_CLK);
                if (err == 0 && ep_mii_readbit(sc, PHYSMGMT_DATA))
                        val |= 1;
                ep_mii_setbit(sc, PHYSMGMT_CLK);
        }
        ep_mii_clrbit(sc, PHYSMGMT_CLK);
        ep_mii_setbit(sc, PHYSMGMT_CLK);

        GO_WINDOW(1);   /* back to operating window */

        return (err ? 0 : val);
}

void
ep_mii_writereg(struct device *self, int phy, int reg, int val)
{
        struct ep_softc *sc = (struct ep_softc *)self;

        /*
         * Write the PHY register by manually driving the MII control lines.
         */

        GO_WINDOW(4);

        ep_mii_sync(sc);
        ep_mii_sendbits(sc, MII_COMMAND_START, 2);
        ep_mii_sendbits(sc, MII_COMMAND_WRITE, 2);
        ep_mii_sendbits(sc, phy, 5);
        ep_mii_sendbits(sc, reg, 5);
        ep_mii_sendbits(sc, MII_COMMAND_ACK, 2);
        ep_mii_sendbits(sc, val, 16);

        ep_mii_clrbit(sc, PHYSMGMT_CLK);
        ep_mii_setbit(sc, PHYSMGMT_CLK);

        GO_WINDOW(1);   /* back to operating window */
}

void
ep_statchg(struct device *self)
{
        struct ep_softc *sc = (struct ep_softc *)self;
        bus_space_tag_t iot = sc->sc_iot;
        bus_space_handle_t ioh = sc->sc_ioh;
        int mctl;

        /* XXX Update ifp->if_baudrate */

        GO_WINDOW(3);
        mctl = bus_space_read_2(iot, ioh, EP_W3_MAC_CONTROL);
        if (sc->sc_mii.mii_media_active & IFM_FDX)
                mctl |= MAC_CONTROL_FDX;
        else
                mctl &= ~MAC_CONTROL_FDX;
        bus_space_write_2(iot, ioh, EP_W3_MAC_CONTROL, mctl);
        GO_WINDOW(1);   /* back to operating window */
}
@


1.94
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.93 2015/12/08 13:34:22 tedu Exp $	*/
a1048 2

	++ifp->if_opackets;
@


1.93
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.92 2015/11/25 11:20:38 mpi Exp $	*/
a337 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.92
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.91 2015/11/25 03:09:58 dlg Exp $	*/
d335 1
a335 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.91
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.90 2015/11/24 13:33:17 mpi Exp $	*/
a48 1
#include <net/netisr.h>
@


1.90
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.89 2015/11/20 03:35:22 dlg Exp $	*/
d664 1
a664 1
	ifp->if_flags &= ~IFF_OACTIVE;
d951 1
a951 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d986 1
a986 1
		ifp->if_flags |= IFF_OACTIVE;
d1185 1
a1185 1
			sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;
d1223 1
a1223 1
			ifp->if_flags &= ~IFF_OACTIVE;
d1493 2
a1494 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.89
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.88 2015/10/25 12:48:46 mpi Exp $	*/
a48 1
#include <net/if_types.h>
@


1.88
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.87 2015/09/11 13:02:28 stsp Exp $	*/
d957 1
a957 1
	IFQ_POLL(&ifp->if_snd, m0);
d976 1
a976 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
d986 1
d994 1
a994 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.87
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.86 2015/07/08 07:21:50 mpi Exp $	*/
a1421 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1431 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.86
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.85 2015/06/24 09:40:54 mpi Exp $	*/
d78 1
a78 1
	int	epm_ifmedia;		/* ifmedia word for medium */
d121 1
a121 1
const u_int ep_default_to_media[] = {
@


1.85
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.84 2015/03/30 10:04:11 mpi Exp $	*/
d1028 1
a1028 1
			MFREE(m, m0);
d1043 1
a1043 1
			MFREE(m, m0);
@


1.84
log
@Convert, convert, convert 'em all to if_input(), tralalalala...

Tested by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.83 2015/03/14 03:38:47 jsg Exp $	*/
a1295 2

	++ifp->if_ipackets;
@


1.83
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.82 2014/12/29 02:33:13 brad Exp $	*/
d1246 1
d1248 1
a1248 1
	int len;
d1279 1
a1279 1
		return;
d1283 2
a1284 1
		goto abort;
d1293 2
a1294 1
		goto abort;
d1299 1
a1299 10
#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m);
d1328 1
a1328 1
			return;
d1332 4
a1335 5

	return;

abort:
	ep_discard_rxtop(iot, ioh);
a1342 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a1362 1
	m->m_pkthdr.rcvif = ifp;
@


1.82
log
@Some cleaning up of the ioctl handling bits to bring things in line
with the other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.81 2014/12/22 02:28:51 tedu Exp $	*/
a48 1
#include <net/if_dl.h>
@


1.81
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.80 2014/07/22 13:12:11 mpi Exp $	*/
d1443 1
a1443 3

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
d1445 1
a1446 5
			break;
		default:
			epinit(sc);
			break;
		}
d1449 12
a1465 25
	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			epstop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			epinit(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0) {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			epinit(sc);
		}
		break;

d1504 1
d1507 2
@


1.80
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.79 2013/08/07 01:06:29 bluhm Exp $	*/
a1444 1
#ifdef INET
a1448 1
#endif
@


1.79
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.78 2012/04/09 16:41:33 miod Exp $	*/
a53 1
#ifdef INET
a54 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a55 1
#endif
@


1.78
log
@Cope with strict alignment platforms, and unbreak the RX logic. Tested with
ep@@eisa on sgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.77 2012/01/11 16:22:33 dhill Exp $	*/
a56 1
#include <netinet/in_var.h>
@


1.77
log
@ansify and de'register some prototypes

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.76 2009/11/24 18:12:39 claudio Exp $	*/
d954 1
d1023 2
a1024 1
			if (m->m_len > 3)
d1026 6
a1031 2
				    mtod(m, u_int8_t *), m->m_len & ~3);
			if (m->m_len & 3)
d1033 1
a1033 2
				    mtod(m, u_int8_t *) + (m->m_len & ~3),
				    m->m_len & 3);
d1039 2
a1040 1
			if (m->m_len > 1)
d1042 7
a1048 4
				    mtod(m, u_int8_t *), m->m_len & ~1);
			if (m->m_len & 1)
				bus_space_write_1(iot, ioh, txreg,
				     *(mtod(m, u_int8_t *) + m->m_len - 1));
d1358 1
d1399 1
d1401 1
a1401 1
			pad = (u_long)(mtod(m, u_int8_t *) + off) & 0x3;
d1403 1
a1403 1
			pad = (u_long)(mtod(m, u_int8_t *) + off) & 0x1;
d1406 2
d1409 4
a1412 2
			    mtod(m, u_int8_t *) + off, pad);
		} else if (EP_IS_BUS_32(sc->bustype) && len > 3) {
d1415 2
a1416 2
			    mtod(m, u_int8_t *) + off, len);
		} else if (len > 1) {
d1419 2
a1420 2
			    mtod(m, u_int8_t *) + off, len);
		} else {
d1422 2
a1423 2
			    mtod(m, u_int8_t *) + off, len);
		}
@


1.76
log
@Correct the copy out of the packet into the mbuf. We need to loop or
non-even packets will end up being a bit trunkated.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.75 2009/11/23 16:36:22 claudio Exp $	*/
d187 1
a187 3
ep_reset_cmd(sc, cmd, arg)
	struct ep_softc *sc;
	u_int cmd, arg;
d200 1
a200 3
ep_finish_reset(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d213 1
a213 3
ep_discard_rxtop(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d239 1
a239 3
ep_w1_reg(sc, reg)
	struct ep_softc *sc;
	int reg;
d258 1
a258 4
epconfig(sc, chipset, enaddr)
	struct ep_softc *sc;
	u_short chipset;
	u_int8_t *enaddr;
d434 1
a434 2
ep_detach(self)
	struct device *self;
d461 1
a461 2
ep_isa_probemedia(sc)
	struct ep_softc *sc;
d513 1
a513 2
ep_vortex_probemedia(sc)
	struct ep_softc *sc;
d578 1
a578 2
epinit(sc)
	register struct ep_softc *sc;
d683 1
a683 2
epsetfilter(sc)
	register struct ep_softc *sc;
d696 1
a696 2
ep_media_change(ifp)
	struct ifnet *ifp;
d707 1
a707 2
ep_roadrunner_mii_enable(sc)
	struct ep_softc *sc;
d733 1
a733 3
epsetmedia(sc, medium)
	struct ep_softc *sc;
	int medium;
d880 1
a880 3
ep_media_status(ifp, req)
	struct ifnet *ifp;
	struct ifmediareq *req;
d948 1
a948 2
epstart(ifp)
	struct ifnet *ifp;
d1091 1
a1091 2
epstatus(sc)
	register struct ep_softc *sc;
d1143 1
a1143 2
eptxstat(sc)
	register struct ep_softc *sc;
d1189 1
a1189 2
epintr(arg)
	void *arg;
d1238 1
a1238 2
epread(sc)
	register struct ep_softc *sc;
d1343 1
a1343 3
epget(sc, totlen)
	struct ep_softc *sc;
	int totlen;
d1421 1
a1421 4
epioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d1492 1
a1492 2
epreset(sc)
	struct ep_softc *sc;
d1502 1
a1502 2
epwatchdog(ifp)
	struct ifnet *ifp;
d1513 1
a1513 2
epstop(sc)
	register struct ep_softc *sc;
d1565 1
a1565 4
epreadeeprom(iot, ioh, offset)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int offset;
d1578 1
a1578 2
epbusyeeprom(sc)
	struct ep_softc *sc;
d1606 1
a1606 3
ep_read_eeprom(sc, offset)
	struct ep_softc *sc;
	u_int16_t offset;
d1630 1
a1630 2
epmbuffill(v)
	void *v;
d1650 1
a1650 2
epmbufempty(sc)
	struct ep_softc *sc;
d1667 1
a1667 3
ep_mii_setbit(sc, bit)
        struct ep_softc *sc;
        u_int16_t bit;
d1678 1
a1678 3
ep_mii_clrbit(sc, bit)
        struct ep_softc *sc;
        u_int16_t bit;
d1689 1
a1689 3
ep_mii_readbit(sc, bit)
        struct ep_softc *sc;
        u_int16_t bit;
d1698 1
a1698 2
ep_mii_sync(sc)
        struct ep_softc *sc;
d1711 1
a1711 4
ep_mii_sendbits(sc, data, nbits)
        struct ep_softc *sc;
        u_int32_t data;
        int nbits;
d1730 1
a1730 3
ep_mii_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
d1774 1
a1774 3
ep_mii_writereg(self, phy, reg, val)
        struct device *self;
        int phy, reg, val;
d1799 1
a1799 2
ep_statchg(self)
        struct device *self;
@


1.75
log
@Bring elink3 at least a bit into the new world. It used to have some super
scary mbuf chache that caused massive problems. Now we just pre-allocate
empty mbuf cluster for later use. Diff mostly from deraadt@@ with some
minor changes by myself. Tested with pcmcia ep(4) by myself. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.74 2009/11/16 13:41:49 jsg Exp $	*/
d355 2
d1378 1
a1378 1
	int len, pad, sh, rxreg;
d1398 1
d1412 15
a1426 3
	len = min(totlen, len);
	if (EP_IS_BUS_32(sc->bustype)) {
		if (len > 3) {
d1429 2
a1430 6
			    mtod(m, u_int8_t *), len);
		} else
			bus_space_read_multi_1(iot, ioh, rxreg,
			    mtod(m, u_int8_t *), len);
	} else {
		if (len > 1) {
d1433 7
a1439 4
			    mtod(m, u_int8_t *), len);
		} else
			*(mtod(m, u_int8_t *)) =
			    bus_space_read_1(iot, ioh, rxreg);
a1440 1
	m->m_len = len;
@


1.74
log
@Fix array access found by parfait and switch to nitems while here.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.73 2008/11/28 02:44:17 brad Exp $	*/
d1375 1
a1375 1
	struct mbuf *top, **mp, *m;
d1378 2
d1383 1
a1383 4
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			return (NULL);
	} else {
d1385 1
a1385 1
		if (sc->last_mb == sc->next_mb)
a1386 3
		/* Convert one of our saved mbuf's. */
		sc->next_mb = (sc->next_mb + 1) % MAX_MBS;
		m = m_inithdr(m);
d1388 6
a1396 6
	len = MHLEN;
	if (totlen >= MINCLSIZE) {
		MCLGET(m, M_DONTWAIT);
		if (m->m_flags & M_EXT)
			len = MCLBYTES;
	}
a1398 2
	top = 0;
	mp = &top;
d1409 17
a1425 43
	while (totlen > 0) {
		if (top) {
			m = sc->mb[sc->next_mb];
			sc->mb[sc->next_mb] = NULL;
			if (m == NULL) {
				MGET(m, M_DONTWAIT, MT_DATA);
				if (m == NULL) {
					splx(sh);
					m_freem(top);
					return (NULL);
				}
			} else
				sc->next_mb = (sc->next_mb + 1) % MAX_MBS;

			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		len = min(totlen, len);
		if (EP_IS_BUS_32(sc->bustype)) {
			if (len > 3) {
				len &= ~3;
				bus_space_read_raw_multi_4(iot, ioh, rxreg,
				    mtod(m, u_int8_t *), len);
			} else
				bus_space_read_multi_1(iot, ioh, rxreg,
				    mtod(m, u_int8_t *), len);
		} else {
			if (len > 1) {
				len &= ~1;
				bus_space_read_raw_multi_2(iot, ioh, rxreg,
				    mtod(m, u_int8_t *), len);
			} else
				*(mtod(m, u_int8_t *)) =
				    bus_space_read_1(iot, ioh, rxreg);
		}
		m->m_len = len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
d1427 1
d1433 1
a1433 1
	return top;
d1665 7
a1671 9
	i = sc->last_mb;
	do {
		if (sc->mb[i] == NULL)
			MGET(sc->mb[i], M_DONTWAIT, MT_DATA);
		if (sc->mb[i] == NULL)
			break;
		i = (i + 1) % MAX_MBS;
	} while (i != sc->next_mb);
	sc->last_mb = i;
d1673 1
a1673 1
	if (sc->last_mb != sc->next_mb)
d1691 1
a1691 1
	sc->last_mb = sc->next_mb = 0;
@


1.73
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.72 2008/10/02 20:21:13 brad Exp $	*/
d97 1
a97 1
const struct ep_media ep_vortex_media[8] = {
d120 1
a120 1
struct ep_media ep_isa_media[3] = {
d127 1
a127 1
const u_int ep_default_to_media[8] = {
d483 1
a483 1
	for (i = 0; i < 3; i++) {
d547 1
a547 1
	for (i = 0; i < 8; i++) {
d562 1
a562 1
	medium_name = (default_media > 8)
@


1.72
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.71 2007/10/13 16:12:29 fgsch Exp $	*/
a1501 8
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;

a1526 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				epreset(sc);
			error = 0;
		}
		break;

d1529 6
@


1.71
log
@remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.70 2007/09/26 13:09:59 henning Exp $	*/
a1479 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}

a1480 1

d1553 1
a1553 2
		error = EINVAL;
		break;
@


1.70
log
@ep(4) is totally weird. due to hardware design limitations it plays
wierd games with caching mbufs. as part of that it used regular mbufs
and makes them M_PKTHDR mbufs on the fly, instead of calling m_gethdr.
of course it did it hackish and wrong and did not properly initialize
the pkthdr fields, which stated to cause problems as soon as we started
to stuff more into the packet header.
so use the freshly introduced m_inithdr() to make the mbuf a pktdr mbuf.
problem found + analyzed by janjaap@@stack.nl PR5563, input theo, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.69 2007/01/19 01:33:44 krw Exp $	*/
a784 2
		int config0, config1;

@


1.69
log
@Some '= 0' -> '= NULL' cleanup for pointer fields and return values.

From Brad.

Tested by nick@@ just to be sure.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.68 2006/06/17 17:56:10 brad Exp $	*/
d1392 1
a1392 4
		m->m_data = m->m_pktdat;
		m->m_flags = M_PKTHDR;
		m_tag_init(m);
		m->m_pkthdr.csum_flags = 0;
@


1.68
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.67 2006/03/25 22:41:42 djm Exp $	*/
d986 1
a986 1
	if (m0 == 0)
d1020 1
d1022 1
a1022 1
	if (m0 == 0)		/* not really needed */
d1313 1
a1313 1
	if (m == 0) {
d1381 2
a1382 2
	sc->mb[sc->next_mb] = 0;
	if (m == 0) {
d1384 2
a1385 2
		if (m == 0)
			return 0;
d1423 2
a1424 2
			sc->mb[sc->next_mb] = 0;
			if (m == 0) {
d1426 1
a1426 1
				if (m == 0) {
d1429 1
a1429 1
					return 0;
d1431 1
a1431 1
			} else {
d1433 1
a1433 1
			}
@


1.67
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.66 2005/11/21 18:16:39 millert Exp $	*/
d45 1
@


1.66
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.65 2005/11/14 12:24:34 mickey Exp $	*/
d1028 1
a1028 1
		bpf_mtap(ifp->if_bpf, m0);
d1324 1
a1324 1
		bpf_mtap(ifp->if_bpf, m);
@


1.65
log
@ep_w1_reg() returns int thus no need to stuff it into bus_addr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.64 2005/04/25 17:55:50 brad Exp $	*/
d44 1
a44 1
#include <sys/select.h>
@


1.64
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.63 2005/01/15 05:24:11 brad Exp $	*/
d976 1
a976 2
	int sh, len, pad;
	bus_addr_t txreg;
d1376 1
a1376 3
	int len, pad;
	int sh;
	bus_addr_t rxreg;
@


1.63
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.62 2004/05/12 06:35:10 tedu Exp $	*/
d1396 1
a1396 1
		m->m_pkthdr.csum = 0;
@


1.62
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.61 2003/10/21 18:58:49 jmc Exp $	*/
d1558 2
a1559 1
			epreset(sc);
@


1.61
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.60 2003/07/08 20:17:05 mickey Exp $	*/
a62 1
#include <net/bpfdesc.h>
@


1.60
log
@no need for an explicit machine/intr.h; tested on alpha, i386, sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.59 2002/06/09 02:52:44 fgsch Exp $	*/
d466 1
a466 1
 * default active mediuim; punt to ifconfig  instead.
@


1.59
log
@replace epsetfilter() / epsetmedia() with epinit() and only if the
interface is up. same behavior, plus will reload the mac address.
tested by aaron@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.58 2002/04/30 22:08:43 mickey Exp $	*/
a67 1
#include <machine/intr.h>
@


1.58
log
@media table could be const
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.57 2002/03/14 03:16:04 millert Exp $	*/
a1522 1
	
d1540 1
a1540 1
		} else {
d1542 2
a1543 3
			 * deal with flags changes:
			 * IFF_MULTICAST, IFF_PROMISC,
			 * IFF_LINK0, IFF_LINK1.
d1545 1
a1545 2
			epsetfilter(sc);
			epsetmedia(sc, sc->sc_mii.mii_media.ifm_cur->ifm_data);
@


1.57
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.56 2002/03/14 01:26:54 millert Exp $	*/
d98 1
a98 1
struct ep_media ep_vortex_media[8] = {
d549 1
a549 1
		struct ep_media * epm = ep_vortex_media + i;
@


1.56
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.55 2002/01/31 04:07:38 rees Exp $	*/
d84 1
a84 1
	char*	epm_name;		/* name of medium */
@


1.55
log
@zero out csum when re-using mbuf (cures 50% packet loss under load)
angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.54 2001/09/20 17:02:31 mpech Exp $	*/
d143 2
a144 2
void ep_vortex_probemedia	__P((struct ep_softc *sc));
void ep_isa_probemedia		__P((struct ep_softc *sc));
d146 13
a158 13
void eptxstat			__P((struct ep_softc *));
int epstatus			__P((struct ep_softc *));
int epioctl			__P((struct ifnet *, u_long, caddr_t));
void epstart			__P((struct ifnet *));
void epwatchdog			__P((struct ifnet *));
void epreset			__P((struct ep_softc *));
void epread			__P((struct ep_softc *));
struct mbuf *epget		__P((struct ep_softc *, int));
void epmbuffill			__P((void *));
void epmbufempty		__P((struct ep_softc *));
void epsetfilter		__P((struct ep_softc *));
void ep_roadrunner_mii_enable	__P((struct ep_softc *));
int epsetmedia			__P((struct ep_softc *, int));
d161 2
a162 2
int ep_media_change		__P((struct ifnet *));
void ep_media_status		__P((struct ifnet *, struct ifmediareq *));
d165 17
a181 17
int ep_mii_readreg		__P((struct device *, int, int));
void ep_mii_writereg		__P((struct device *, int, int, int));
void ep_statchg			__P((struct device *));

void    ep_mii_setbit		__P((struct ep_softc *, u_int16_t));
void    ep_mii_clrbit		__P((struct ep_softc *, u_int16_t));
u_int16_t ep_mii_readbit	__P((struct ep_softc *, u_int16_t));
void    ep_mii_sync		__P((struct ep_softc *));
void    ep_mii_sendbits		__P((struct ep_softc *, u_int32_t, int));

int epbusyeeprom		__P((struct ep_softc *));
u_int16_t ep_read_eeprom	__P((struct ep_softc *, u_int16_t));

static inline void ep_reset_cmd __P((struct ep_softc *sc, u_int cmd,u_int arg));
static inline void ep_finish_reset __P((bus_space_tag_t, bus_space_handle_t));
static inline void ep_discard_rxtop __P((bus_space_tag_t, bus_space_handle_t));
static __inline int ep_w1_reg	__P((struct ep_softc *, int));
@


1.54
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.53 2001/07/08 23:38:05 fgsch Exp $	*/
d1247 2
a1248 2
			sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;
			epstart(&sc->sc_arpcom.ac_if);
d1398 1
@


1.54.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.55 2002/01/31 04:07:38 rees Exp $	*/
d1247 2
a1248 2
			ifp->if_flags &= ~IFF_OACTIVE;
			epstart(ifp);
a1397 1
		m->m_pkthdr.csum = 0;
@


1.54.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.54.4.1 2002/01/31 22:55:31 niklas Exp $	*/
d84 1
a84 1
	char   *epm_name;		/* name of medium */
d98 1
a98 1
const struct ep_media ep_vortex_media[8] = {
d143 2
a144 2
void ep_vortex_probemedia(struct ep_softc *sc);
void ep_isa_probemedia(struct ep_softc *sc);
d146 13
a158 13
void eptxstat(struct ep_softc *);
int epstatus(struct ep_softc *);
int epioctl(struct ifnet *, u_long, caddr_t);
void epstart(struct ifnet *);
void epwatchdog(struct ifnet *);
void epreset(struct ep_softc *);
void epread(struct ep_softc *);
struct mbuf *epget(struct ep_softc *, int);
void epmbuffill(void *);
void epmbufempty(struct ep_softc *);
void epsetfilter(struct ep_softc *);
void ep_roadrunner_mii_enable(struct ep_softc *);
int epsetmedia(struct ep_softc *, int);
d161 2
a162 2
int ep_media_change(struct ifnet *);
void ep_media_status(struct ifnet *, struct ifmediareq *);
d165 17
a181 17
int ep_mii_readreg(struct device *, int, int);
void ep_mii_writereg(struct device *, int, int, int);
void ep_statchg(struct device *);

void    ep_mii_setbit(struct ep_softc *, u_int16_t);
void    ep_mii_clrbit(struct ep_softc *, u_int16_t);
u_int16_t ep_mii_readbit(struct ep_softc *, u_int16_t);
void    ep_mii_sync(struct ep_softc *);
void    ep_mii_sendbits(struct ep_softc *, u_int32_t, int);

int epbusyeeprom(struct ep_softc *);
u_int16_t ep_read_eeprom(struct ep_softc *, u_int16_t);

static inline void ep_reset_cmd(struct ep_softc *sc, u_int cmd,u_int arg);
static inline void ep_finish_reset(bus_space_tag_t, bus_space_handle_t);
static inline void ep_discard_rxtop(bus_space_tag_t, bus_space_handle_t);
static __inline int ep_w1_reg(struct ep_softc *, int);
d549 1
a549 1
		const struct ep_media *epm = ep_vortex_media + i;
d1523 1
d1541 1
a1541 1
		} else if ((ifp->if_flags & IFF_UP) != 0) {
d1543 3
a1545 2
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
d1547 2
a1548 1
			epinit(sc);
@


1.53
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.52 2001/06/27 06:34:41 kjc Exp $	*/
d668 1
a668 1
	 * Attempt to get rid of any stray interrupts that occured during
@


1.52
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.51 2001/06/24 20:30:24 fgsch Exp $	*/
a355 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
@


1.51
log
@ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.50 2001/06/23 21:54:44 fgsch Exp $	*/
d356 2
a357 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d988 1
a988 1
	m0 = ifp->if_snd.ifq_head;
d1007 1
a1007 1
		IF_DEQUEUE(&ifp->if_snd, m0);
d1023 1
a1023 2

	IF_DEQUEUE(&ifp->if_snd, m0);
@


1.50
log
@Remove repeated ethernet constants; use if_ether.h for it instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.49 2001/05/26 06:57:19 angelos Exp $	*/
a1272 1
	struct ether_header *eh;
a1321 3
	/* We assume the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d1331 1
a1331 3
	/* We assume the header fit entirely in one mbuf. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.49
log
@Use m_tag_init() to initialize new mbuf m_pkthdr fields, rather than
having to change it every time.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.48 2001/05/22 18:59:54 angelos Exp $	*/
a74 4

#define ETHER_MIN_LEN	64
#define ETHER_MAX_LEN   1518
#define ETHER_ADDR_LEN  6
@


1.48
log
@Initialize packet tag -- this has probably been causing panics for
people with ep cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.47 2001/02/20 19:39:36 mickey Exp $	*/
d1408 1
a1408 1
		TAILQ_INIT(&m->m_pkthdr.tags);
@


1.47
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.46 2000/11/09 18:06:38 mickey Exp $	*/
d1408 1
a1408 1
		bzero(&m->m_pkthdr, sizeof(m->m_pkthdr));
@


1.46
log
@new timeouts; aaron@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.45 2000/10/16 17:08:07 aaron Exp $	*/
a439 5

#if NBPFILTER > 0
	bpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif
@


1.45
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.44 2000/09/17 19:10:56 provos Exp $	*/
d338 1
a338 1
		printf("wrote %d to TX_AVAIL_THRESH, read back %d. "
d343 2
d1408 1
a1408 1
			timeout(epmbuffill, sc, 1);
d1758 1
a1758 1
		timeout(epmbuffill, sc, 1);
d1776 1
a1776 1
	untimeout(epmbuffill, sc);
@


1.44
log
@implement SIOCSIFMTU, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.43 2000/09/17 00:06:01 aaron Exp $	*/
d409 2
a410 1
			mii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);
@


1.43
log
@Twiddle another bit to illuminate the link LED on the 3C589E 10BaseT connector.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.42 2000/09/15 22:28:50 aaron Exp $	*/
d1527 9
@


1.42
log
@Support the ejection of mii ep(4) devices, i.e., the 3c574.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.41 2000/07/06 00:59:01 todd Exp $	*/
d827 2
a828 2
		bus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,
		    w4_media | ENABLE_UTP);
@


1.41
log
@printf %s
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.40 2000/06/29 03:22:31 aaron Exp $	*/
d447 18
@


1.40
log
@Be more detach friendly. In particular, remove the infinite while() loops
waiting on S_COMMAND_IN_PROGRESS and replace them with a bounded loop count
plus a small delay; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.39 2000/05/29 18:04:07 aaron Exp $	*/
d479 1
a479 1
			printf(epm->epm_name);
d542 1
a542 1
			printf(epm->epm_name);
@


1.39
log
@Support for 3c574 and 3CCFEM556BI PCMCIA Ethernet; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.38 2000/02/25 04:26:11 itojun Exp $	*/
d173 5
a177 5
void    ep_mii_setbit __P((struct ep_softc *, u_int16_t));
void    ep_mii_clrbit __P((struct ep_softc *, u_int16_t));
u_int16_t ep_mii_readbit __P((struct ep_softc *, u_int16_t));
void    ep_mii_sync __P((struct ep_softc *));
void    ep_mii_sendbits __P((struct ep_softc *, u_int32_t, int));
d181 4
a184 2
static inline void ep_complete_cmd __P((struct ep_softc *sc, u_int cmd,
    u_int arg));
d189 1
a189 4
 * Used for commands that reset part or all of the  board.
 * On newer hardware we could poll SC_COMMAND_IN_PROGRESS,
 * but older hardware doesn't implement it and we must delay.
 * It's easiest to just delay always.
d192 1
a192 1
ep_complete_cmd(sc, cmd, arg)
d200 27
d228 16
a243 8
#ifdef notyet
	/* if this adapter family has S_COMMAND_IN_PROGRESS, use it */
	while (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
		;
	else
#else
	DELAY(100000);	/* need at least 1 ms, but be generous. */
#endif
d445 2
a446 2
	ep_complete_cmd(sc, EP_COMMAND, RX_RESET);
	ep_complete_cmd(sc, EP_COMMAND, TX_RESET);
d587 5
a591 2
	while (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
		;
d616 2
a617 2
	ep_complete_cmd(sc, EP_COMMAND, RX_RESET);
	ep_complete_cmd(sc, EP_COMMAND, TX_RESET);
d723 2
a724 2
	ep_complete_cmd(sc, EP_COMMAND, TX_RESET);
	ep_complete_cmd(sc, EP_COMMAND, RX_RESET);
a1239 2
			printf("%s: adapter failure (%x)\n",
			    sc->sc_dev.dv_xname, status);
d1362 1
a1362 3
	bus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
		;
d1462 1
a1462 3
	bus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
		;
a1568 1
	epstop(sc);
d1606 2
a1607 3
	bus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
		;
d1611 2
a1612 2
	ep_complete_cmd(sc, EP_COMMAND, RX_RESET);
	ep_complete_cmd(sc, EP_COMMAND, TX_RESET);
@


1.38
log
@clear m->m_pkthdr when changing mbuf type to M_PKTHDR.
without it, junk pointer in m->m_pkthdr.tdbi may bite us.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.37 2000/02/02 18:47:01 deraadt Exp $	*/
d70 3
d81 1
a81 1
 * Structure to map  media-present bits in boards to 
a142 1
/* Autoconfig definition of driver back-end */
d147 16
a162 17
#ifdef __NetBSD__
void	ep_internalconfig __P((struct ep_softc *sc));
#endif
void	ep_vortex_probemedia __P((struct ep_softc *sc));
void	ep_isa_probemedia __P((struct ep_softc *sc));
void	eptxstat __P((struct ep_softc *));
int	epstatus __P((struct ep_softc *));
int	epioctl __P((struct ifnet *, u_long, caddr_t));
void	epstart __P((struct ifnet *));
void	epwatchdog __P((struct ifnet *));
void	epreset __P((struct ep_softc *));
void	epread __P((struct ep_softc *));
struct mbuf *epget __P((struct ep_softc *, int));
void	epmbuffill __P((void *));
void	epmbufempty __P((struct ep_softc *));
void	epsetfilter __P((struct ep_softc *));
int	epsetmedia __P((struct ep_softc *, int));
d165 2
a166 2
int	ep_media_change __P((struct ifnet *));
void	ep_media_status __P((struct ifnet *, struct ifmediareq *));
d168 13
a180 1
int	epbusyeeprom __P((struct ep_softc *));
d183 1
d213 21
d258 1
a258 1
		 * Read the station address from the eeprom
d261 2
a262 8
			u_int16_t x;
			if (epbusyeeprom(sc))
				return;		/* XXX why is eeprom busy? */
			bus_space_write_2(iot, ioh, EP_W0_EEPROM_COMMAND,
			    READ_EEPROM | i);
			if (epbusyeeprom(sc))
				return;		/* XXX why is eeprom busy? */
			x = bus_space_read_2(iot, ioh, EP_W0_EEPROM_DATA);
d270 5
a274 1
	printf(" address %s, ", ether_sprintf(sc->sc_arpcom.ac_enaddr));
a334 4
#ifdef __NetBSD__
	/* print RAM size */
	ep_internalconfig(sc);
#endif
d337 6
a342 1
	ifmedia_init(&sc->sc_media, 0, ep_media_change, ep_media_status);
d361 28
d406 1
a406 1
	    sizeof (struct ether_header));
a414 43
#ifdef __NetBSD__
/* Is this info worth an extra line of dmesg output? */

/*
 * Show interface-model-independent info from window 3
 * internal-configuration register.
 */
void
ep_internalconfig(sc)
	struct ep_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	u_int config0;
	u_int config1;

	int  ram_size, ram_width, ram_speed, rom_size, ram_split;
	/*
	 * NVRAM buffer Rx:Tx config names for busmastering cards
	 * (Demon, Vortex, and later).
	 */
	const char *onboard_ram_config[] = {
		"5:3", "3:1", "1:1", "(undefined)" };

	GO_WINDOW(3);
	config0 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG);
	config1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);
	GO_WINDOW(0);

	ram_size  = (config0 & CONFIG_RAMSIZE) >> CONFIG_RAMSIZE_SHIFT;
	ram_width = (config0 & CONFIG_RAMWIDTH) >> CONFIG_RAMWIDTH_SHIFT;
	ram_speed = (config0 & CONFIG_RAMSPEED) >> CONFIG_RAMSPEED_SHIFT;
	rom_size  = (config0 & CONFIG_ROMSIZE) >> CONFIG_ROMSIZE_SHIFT;

	ram_split  = (config1 & CONFIG_RAMSPLIT) >> CONFIG_RAMSPLIT_SHIFT;

	printf("%s: %dKB %s-wide FIFO, %s Rx:Tx split, ",
	    sc->sc_dev.dv_xname, 8 << ram_size, (ram_width) ? "word" : "byte",
	    onboard_ram_config[ram_split]);
}
#endif

d431 1
a431 1
	struct ifmedia *ifm = &sc->sc_media;
d462 1
d484 1
a484 1
	struct ifmedia *ifm = &sc->sc_media;
d506 2
a507 1
			if (conn) printf("/");
d521 1
a521 1
	       medium_name,  (autoselect)? "/autoselect" : "" );
d584 1
a584 1
		bus_space_read_1(iot, ioh, EP_W1_TX_STATUS);
d590 22
d627 1
a627 1
	epsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);
d667 24
a690 1
	return	epsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);
a704 1
/*	struct ifnet *ifp = &sc->sc_arpcom.ac_if;*/
d733 33
d770 1
a770 1
	switch  (medium) {
d832 1
a832 1
	case EP_CHIPSET_3C509:
d862 10
d873 1
a873 1
	req->ifm_active = sc->sc_media.ifm_cur->ifm_media;
d930 1
d962 2
a963 1
	if (bus_space_read_2(iot, ioh, EP_W1_FREE_TX) < len + pad + 4) {
d992 4
a995 3
	bus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1, len);
	bus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1,
	    0xffff);	/* Second dword meaningless */
d999 2
a1000 3
				bus_space_write_raw_multi_4(iot, ioh,
				    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),
				    m->m_len & ~3);
d1002 1
a1002 2
				bus_space_write_multi_1(iot, ioh,
				    EP_W1_TX_PIO_WR_1,
d1011 2
a1012 3
				bus_space_write_raw_multi_2(iot, ioh,
				    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),
				    m->m_len & ~1);
d1014 1
a1014 1
				bus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1,
d1021 1
a1021 1
		bus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1, 0);
d1028 2
a1029 2
	if ((bus_space_read_2(iot, ioh, EP_W1_RX_STATUS) & ERR_INCOMPLETE) ==
	    0) {
d1131 4
a1134 3
	while ((i = bus_space_read_1(iot, ioh, EP_W1_TX_STATUS)) &
	    TXS_COMPLETE) {
		bus_space_write_1(iot, ioh, EP_W1_TX_STATUS, 0x0);
d1229 1
a1229 1
	len = bus_space_read_2(iot, ioh, EP_W1_RX_STATUS);
d1309 2
a1310 1
		len = bus_space_read_2(iot, ioh, EP_W1_RX_STATUS);
d1343 1
d1382 2
d1409 2
a1410 3
				bus_space_read_raw_multi_4(iot, ioh,
				    EP_W1_RX_PIO_RD_1, mtod(m, u_int8_t *),
				    len);
d1412 2
a1413 3
				bus_space_read_multi_1(iot, ioh,
				    EP_W1_RX_PIO_RD_1, mtod(m, u_int8_t *),
				    len);
d1417 2
a1418 3
				bus_space_read_raw_multi_2(iot, ioh,
				    EP_W1_RX_PIO_RD_1, mtod(m, u_int8_t *),
				    len);
d1421 1
a1421 2
				    bus_space_read_1(iot, ioh,
					EP_W1_RX_PIO_RD_1);
d1476 1
a1476 1
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
d1502 1
a1502 2
/*			epsetmedia(sc, sc->sc_media);*/	/* XXX */
			epsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);
d1562 13
d1654 26
d1719 167
@


1.37
log
@make the activate routines do xxstop() and xxinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.36 1999/12/08 06:08:04 itojun Exp $	*/
d1248 1
@


1.37.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1247 1
		bzero(&m->m_pkthdr, sizeof(m->m_pkthdr));
@


1.37.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.47 2001/02/20 19:39:36 mickey Exp $	*/
a69 3
#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

d78 1
a78 1
 * Structure to map media-present bits in boards to 
d140 1
d145 17
a161 16
void ep_vortex_probemedia	__P((struct ep_softc *sc));
void ep_isa_probemedia		__P((struct ep_softc *sc));

void eptxstat			__P((struct ep_softc *));
int epstatus			__P((struct ep_softc *));
int epioctl			__P((struct ifnet *, u_long, caddr_t));
void epstart			__P((struct ifnet *));
void epwatchdog			__P((struct ifnet *));
void epreset			__P((struct ep_softc *));
void epread			__P((struct ep_softc *));
struct mbuf *epget		__P((struct ep_softc *, int));
void epmbuffill			__P((void *));
void epmbufempty		__P((struct ep_softc *));
void epsetfilter		__P((struct ep_softc *));
void ep_roadrunner_mii_enable	__P((struct ep_softc *));
int epsetmedia			__P((struct ep_softc *, int));
d164 2
a165 2
int ep_media_change		__P((struct ifnet *));
void ep_media_status		__P((struct ifnet *, struct ifmediareq *));
d167 3
a169 18
/* MII callbacks */
int ep_mii_readreg		__P((struct device *, int, int));
void ep_mii_writereg		__P((struct device *, int, int, int));
void ep_statchg			__P((struct device *));

void    ep_mii_setbit		__P((struct ep_softc *, u_int16_t));
void    ep_mii_clrbit		__P((struct ep_softc *, u_int16_t));
u_int16_t ep_mii_readbit	__P((struct ep_softc *, u_int16_t));
void    ep_mii_sync		__P((struct ep_softc *));
void    ep_mii_sendbits		__P((struct ep_softc *, u_int32_t, int));

int epbusyeeprom		__P((struct ep_softc *));
u_int16_t ep_read_eeprom	__P((struct ep_softc *, u_int16_t));

static inline void ep_reset_cmd __P((struct ep_softc *sc, u_int cmd,u_int arg));
static inline void ep_finish_reset __P((bus_space_tag_t, bus_space_handle_t));
static inline void ep_discard_rxtop __P((bus_space_tag_t, bus_space_handle_t));
static __inline int ep_w1_reg	__P((struct ep_softc *, int));
d173 4
a176 1
 * Used for global reset, TX_RESET, RX_RESET.
d179 1
a179 1
ep_reset_cmd(sc, cmd, arg)
a186 2
	ep_finish_reset(iot, ioh);
}
d188 8
a195 62
/*
 * Wait for any pending reset to complete.
 */
static inline void
ep_finish_reset(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
{
	int i;

	for (i = 0; i < 10000; i++) {
		if ((bus_space_read_2(iot, ioh, EP_STATUS) &
		    S_COMMAND_IN_PROGRESS) == 0)
			break;
		DELAY(10);
	}
}

static inline void
ep_discard_rxtop(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
{
	int i;

	bus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);

	/*
	 * Spin for about 1 msec, to avoid forcing a DELAY() between
	 * every received packet (adding latency and limiting pkt-recv rate).
	 * On PCI, at 4 30-nsec PCI bus cycles for a read, 8000 iterations
	 * is about right.
	 */
	for (i = 0; i < 8000; i++) {
		if ((bus_space_read_2(iot, ioh, EP_STATUS) &
		    S_COMMAND_IN_PROGRESS) == 0)
			return;
	}

	/* not fast enough, do DELAY()s */
	ep_finish_reset(iot, ioh);
}

/*
 * Some chips (i.e., 3c574 RoadRunner) have Window 1 registers offset.
 */
static __inline int
ep_w1_reg(sc, reg)
	struct ep_softc *sc;
	int reg;
{
	switch (sc->ep_chipset) {
	case EP_CHIPSET_ROADRUNNER:
		switch (reg) {
		case EP_W1_FREE_TX:
		case EP_W1_RUNNER_RDCTL:
		case EP_W1_RUNNER_WRCTL:
			return (reg);
		}
		return (reg + 0x10);
	}
	return (reg);
d223 1
a223 1
		 * Read the station address from the eeprom.
d226 8
a233 2
			u_int16_t x = ep_read_eeprom(sc, i);

d241 1
a241 5
	printf(" address %s", ether_sprintf(sc->sc_arpcom.ac_enaddr));
	if (sc->ep_flags & EP_FLAGS_MII)
		printf("\n");
	else
		printf(", ");
d271 1
a271 1
		printf("wrote %x to TX_AVAIL_THRESH, read back %x. "
a275 2
	timeout_set(&sc->sc_epmbuffill_tmo, epmbuffill, sc);

d302 4
d308 1
a308 6
	ifmedia_init(&sc->sc_mii.mii_media, 0, ep_media_change,
	    ep_media_status);
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = ep_mii_readreg;
	sc->sc_mii.mii_writereg = ep_mii_writereg;
	sc->sc_mii.mii_statchg = ep_statchg;
a326 29
	case EP_CHIPSET_ROADRUNNER:
		if (sc->ep_flags & EP_FLAGS_MII) {
			ep_roadrunner_mii_enable(sc);
			GO_WINDOW(0);
		}
		/* FALLTHROUGH */

	case EP_CHIPSET_BOOMERANG:
		/*
		 * If the device has MII, probe it.  We won't be using
		 * any `native' media in this case, only PHYs.  If
		 * we don't, just treat the Boomerang like the Vortex.
		 */
		if (sc->ep_flags & EP_FLAGS_MII) {
			mii_attach(&sc->sc_dev, &sc->sc_mii, 0xffffffff,
			    MII_PHY_ANY, MII_OFFSET_ANY, 0);
			if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
				ifmedia_add(&sc->sc_mii.mii_media,
				    IFM_ETHER|IFM_NONE, 0, NULL);
				ifmedia_set(&sc->sc_mii.mii_media,
				    IFM_ETHER|IFM_NONE);
			} else {
				ifmedia_set(&sc->sc_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
			}
			break;
		}
		/* FALLTHROUGH */

d342 5
d349 2
a350 2
	ep_reset_cmd(sc, EP_COMMAND, RX_RESET);
	ep_reset_cmd(sc, EP_COMMAND, TX_RESET);
d353 10
a362 3
int
ep_detach(self)
	struct device *self;
d364 2
a365 2
	struct ep_softc *sc = (struct ep_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d367 2
a368 2
	if (sc->ep_flags & EP_FLAGS_MII)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);
d370 7
a376 1
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);
d378 4
a381 2
	ether_ifdetach(ifp);
	if_detach(ifp);
d383 10
a392 1
	return (0);
d394 1
d412 1
a412 1
	struct ifmedia *ifm = &sc->sc_mii.mii_media;
d426 1
a426 1
			printf("%s", epm->epm_name);
a442 1

d464 1
a464 1
	struct ifmedia *ifm = &sc->sc_mii.mii_media;
d486 2
a487 3
			if (conn)
				printf("/");
			printf("%s", epm->epm_name);
d500 1
a500 1
	       medium_name, (autoselect) ? "/autoselect" : "");
d532 2
a533 5
	/* make sure any pending reset has completed before touching board */
	ep_finish_reset(iot, ioh);

	/* cancel any pending I/O */
	epstop(sc);
d558 2
a559 2
	ep_reset_cmd(sc, EP_COMMAND, RX_RESET);
	ep_reset_cmd(sc, EP_COMMAND, TX_RESET);
d563 1
a563 1
		bus_space_read_1(iot, ioh, ep_w1_reg(sc, EP_W1_TX_STATUS));
a568 22
	if (sc->ep_chipset == EP_CHIPSET_ROADRUNNER) {
		/* Enable options in the PCMCIA LAN COR register, via
		 * RoadRunner Window 1.
		 *
		 * XXX MAGIC CONSTANTS!
		 */
		u_int16_t cor;

		bus_space_write_2(iot, ioh, EP_W1_RUNNER_RDCTL, (1 << 11));

		cor = bus_space_read_2(iot, ioh, 0) & ~0x30;
		bus_space_write_2(iot, ioh, 0, cor);

		bus_space_write_2(iot, ioh, EP_W1_RUNNER_WRCTL, 0);
		bus_space_write_2(iot, ioh, EP_W1_RUNNER_RDCTL, 0);

		if (sc->ep_flags & EP_FLAGS_MII) {
			ep_roadrunner_mii_enable(sc);
			GO_WINDOW(1);
		}
	}

d584 1
a584 1
	epsetmedia(sc, sc->sc_mii.mii_media.ifm_cur->ifm_data);
d624 1
a624 24
	return	epsetmedia(sc, sc->sc_mii.mii_media.ifm_cur->ifm_data);
}

/*
 * Reset and enable the MII on the RoadRunner.
 */
void
ep_roadrunner_mii_enable(sc)
	struct ep_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	GO_WINDOW(3);
	bus_space_write_2(iot, ioh, EP_W3_RESET_OPTIONS,
	    EP_PCI_100BASE_MII|EP_RUNNER_ENABLE_MII);
	delay(1000);
	bus_space_write_2(iot, ioh, EP_W3_RESET_OPTIONS,
	    EP_PCI_100BASE_MII|EP_RUNNER_MII_RESET|EP_RUNNER_ENABLE_MII);
	ep_reset_cmd(sc, EP_COMMAND, TX_RESET);
	ep_reset_cmd(sc, EP_COMMAND, RX_RESET);
	delay(1000);
	bus_space_write_2(iot, ioh, EP_W3_RESET_OPTIONS,
	    EP_PCI_100BASE_MII|EP_RUNNER_ENABLE_MII);
d639 1
a667 33
	/* If the device has MII, select it, and then tell the
	 * PHY which media to use.
	 */
	if (sc->ep_flags & EP_FLAGS_MII) {
		int config0, config1;

		GO_WINDOW(3);

		if (sc->ep_chipset == EP_CHIPSET_ROADRUNNER) {
			int resopt;

			resopt = bus_space_read_2(iot, ioh,
			    EP_W3_RESET_OPTIONS);
			bus_space_write_2(iot, ioh, EP_W3_RESET_OPTIONS,
			    resopt | EP_RUNNER_ENABLE_MII);
		}

		config0 = (u_int)bus_space_read_2(iot, ioh,
		    EP_W3_INTERNAL_CONFIG);
		config1 = (u_int)bus_space_read_2(iot, ioh,
		    EP_W3_INTERNAL_CONFIG + 2);

		config1 = config1 & ~CONFIG_MEDIAMASK;
		config1 |= (EPMEDIA_MII << CONFIG_MEDIAMASK_SHIFT);

		bus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);
		bus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);
		GO_WINDOW(1);	/* back to operating window */

		mii_mediachg(&sc->sc_mii);
		return (0);
	}

d672 1
a672 1
	switch (medium) {
d674 2
a675 2
		bus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, (ENABLE_UTP |
		    (sc->bustype == EP_BUS_PCMCIA ? MEDIA_LED : 0)));
d734 1
a734 1
	default:
a763 10
	/*
	 * If we have MII, go ask the PHY what's going on.
	 */
	if (sc->ep_flags & EP_FLAGS_MII) {
		mii_pollstat(&sc->sc_mii);
		req->ifm_active = sc->sc_mii.mii_media_active;
		req->ifm_status = sc->sc_mii.mii_media_status;
		return;
	}

d765 1
a765 1
	req->ifm_active = sc->sc_mii.mii_media.ifm_cur->ifm_media;
a821 1
	bus_addr_t txreg;
d853 1
a853 2
	if (bus_space_read_2(iot, ioh, ep_w1_reg(sc, EP_W1_FREE_TX)) <
	    len + pad + 4) {
d882 3
a884 4
	txreg = ep_w1_reg(sc, EP_W1_TX_PIO_WR_1);

	bus_space_write_2(iot, ioh, txreg, len);
	bus_space_write_2(iot, ioh, txreg, 0xffff); /* Second is meaningless */
d888 3
a890 2
				bus_space_write_raw_multi_4(iot, ioh, txreg,
				    mtod(m, u_int8_t *), m->m_len & ~3);
d892 2
a893 1
				bus_space_write_multi_1(iot, ioh, txreg,
d902 3
a904 2
				bus_space_write_raw_multi_2(iot, ioh, txreg,
				    mtod(m, u_int8_t *), m->m_len & ~1);
d906 1
a906 1
				bus_space_write_1(iot, ioh, txreg,
d913 1
a913 1
		bus_space_write_1(iot, ioh, txreg, 0);
d920 2
a921 2
	if ((bus_space_read_2(iot, ioh, ep_w1_reg(sc, EP_W1_RX_STATUS)) &
	    ERR_INCOMPLETE) == 0) {
d1023 3
a1025 4
	while ((i = bus_space_read_1(iot, ioh,
	    ep_w1_reg(sc, EP_W1_TX_STATUS))) & TXS_COMPLETE) {
		bus_space_write_1(iot, ioh, ep_w1_reg(sc, EP_W1_TX_STATUS),
		    0x0);
d1094 2
d1120 1
a1120 1
	len = bus_space_read_2(iot, ioh, ep_w1_reg(sc, EP_W1_RX_STATUS));
d1200 1
a1200 2
		len = bus_space_read_2(iot, ioh,
		    ep_w1_reg(sc, EP_W1_RX_STATUS));
d1217 3
a1219 1
	ep_discard_rxtop(iot, ioh);
a1232 1
	bus_addr_t rxreg;
d1243 1
a1243 1
			timeout_add(&sc->sc_epmbuffill_tmo, 1);
a1270 2
	rxreg = ep_w1_reg(sc, EP_W1_RX_PIO_RD_1);

d1296 3
a1298 2
				bus_space_read_raw_multi_4(iot, ioh, rxreg,
				    mtod(m, u_int8_t *), len);
d1300 3
a1302 2
				bus_space_read_multi_1(iot, ioh, rxreg,
				    mtod(m, u_int8_t *), len);
d1306 3
a1308 2
				bus_space_read_raw_multi_2(iot, ioh, rxreg,
				    mtod(m, u_int8_t *), len);
d1311 2
a1312 1
				    bus_space_read_1(iot, ioh, rxreg);
d1320 3
a1322 1
	ep_discard_rxtop(iot, ioh);
d1367 1
a1367 9
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
a1368 1
	
d1393 2
a1394 1
			epsetmedia(sc, sc->sc_mii.mii_media.ifm_cur->ifm_data);
d1430 1
a1453 13
	if (sc->ep_flags & EP_FLAGS_MII) {
		mii_down(&sc->sc_mii);
	}

	if (sc->ep_chipset == EP_CHIPSET_ROADRUNNER) {
		/* Clear the FIFO buffer count, thus halting
		 * any currently-running transactions.
		 */
		GO_WINDOW(1);		/* sanity */
		bus_space_write_2(iot, ioh, EP_W1_RUNNER_WRCTL, 0);
		bus_space_write_2(iot, ioh, EP_W1_RUNNER_RDCTL, 0);
	}

d1455 3
a1457 2
	ep_discard_rxtop(iot, ioh);

d1461 2
a1462 2
	ep_reset_cmd(sc, EP_COMMAND, RX_RESET);
	ep_reset_cmd(sc, EP_COMMAND, TX_RESET);
a1532 26
u_int16_t
ep_read_eeprom(sc, offset)
	struct ep_softc *sc;
	u_int16_t offset;
{
	u_int16_t readcmd;

	/*
	 * RoadRunner has a larger EEPROM, so a different read command
	 * is required.
	 */
	if (sc->ep_chipset == EP_CHIPSET_ROADRUNNER)
		readcmd = READ_EEPROM_RR;
	else
		readcmd = READ_EEPROM;

	if (epbusyeeprom(sc))
		return (0);			/* XXX why is eeprom busy? */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W0_EEPROM_COMMAND,
	    readcmd | offset);
	if (epbusyeeprom(sc))
		return (0);			/* XXX why is eeprom busy? */

	return (bus_space_read_2(sc->sc_iot, sc->sc_ioh, EP_W0_EEPROM_DATA));
}

d1552 1
a1552 1
		timeout_add(&sc->sc_epmbuffill_tmo, 1);
d1570 1
a1570 1
	timeout_del(&sc->sc_epmbuffill_tmo);
a1571 167
}

void
ep_mii_setbit(sc, bit)
        struct ep_softc *sc;
        u_int16_t bit;
{
        u_int16_t val;

        /* We assume we're already in Window 4 */
        val = bus_space_read_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT);
        bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT,
            val | bit);
}

void
ep_mii_clrbit(sc, bit)
        struct ep_softc *sc;
        u_int16_t bit;
{
        u_int16_t val;

        /* We assume we're already in Window 4 */
        val = bus_space_read_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT);
        bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT,
            val & ~bit);
}

u_int16_t
ep_mii_readbit(sc, bit)
        struct ep_softc *sc;
        u_int16_t bit;
{

        /* We assume we're already in Window 4 */
        return (bus_space_read_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT) &
            bit);
}

void
ep_mii_sync(sc)
        struct ep_softc *sc;
{
        int i;

        /* We assume we're already in Window 4 */
        ep_mii_clrbit(sc, PHYSMGMT_DIR);
        for (i = 0; i < 32; i++) {
                ep_mii_clrbit(sc, PHYSMGMT_CLK);
                ep_mii_setbit(sc, PHYSMGMT_CLK);
        }
}

void
ep_mii_sendbits(sc, data, nbits)
        struct ep_softc *sc;
        u_int32_t data;
        int nbits;
{
        int i;

        /* We assume we're already in Window 4 */
        ep_mii_setbit(sc, PHYSMGMT_DIR);
        for (i = 1 << (nbits - 1); i; i = i >> 1) {
                ep_mii_clrbit(sc, PHYSMGMT_CLK);
                ep_mii_readbit(sc, PHYSMGMT_CLK);
                if (data & i)
                        ep_mii_setbit(sc, PHYSMGMT_DATA);
                else
                        ep_mii_clrbit(sc, PHYSMGMT_DATA);
                ep_mii_setbit(sc, PHYSMGMT_CLK);
                ep_mii_readbit(sc, PHYSMGMT_CLK);
        }
}

int
ep_mii_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
{
        struct ep_softc *sc = (struct ep_softc *)self;
        int val = 0, i, err;

        /*
         * Read the PHY register by manually driving the MII control lines.
         */

        GO_WINDOW(4);

        bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W4_BOOM_PHYSMGMT, 0);

        ep_mii_sync(sc);
        ep_mii_sendbits(sc, MII_COMMAND_START, 2);
        ep_mii_sendbits(sc, MII_COMMAND_READ, 2);
        ep_mii_sendbits(sc, phy, 5);
        ep_mii_sendbits(sc, reg, 5);

        ep_mii_clrbit(sc, PHYSMGMT_DIR);
        ep_mii_clrbit(sc, PHYSMGMT_CLK);
        ep_mii_setbit(sc, PHYSMGMT_CLK);
        ep_mii_clrbit(sc, PHYSMGMT_CLK);

        err = ep_mii_readbit(sc, PHYSMGMT_DATA);
        ep_mii_setbit(sc, PHYSMGMT_CLK);

        /* Even if an error occurs, must still clock out the cycle. */
        for (i = 0; i < 16; i++) {
                val <<= 1;
                ep_mii_clrbit(sc, PHYSMGMT_CLK);
                if (err == 0 && ep_mii_readbit(sc, PHYSMGMT_DATA))
                        val |= 1;
                ep_mii_setbit(sc, PHYSMGMT_CLK);
        }
        ep_mii_clrbit(sc, PHYSMGMT_CLK);
        ep_mii_setbit(sc, PHYSMGMT_CLK);

        GO_WINDOW(1);   /* back to operating window */

        return (err ? 0 : val);
}

void
ep_mii_writereg(self, phy, reg, val)
        struct device *self;
        int phy, reg, val;
{
        struct ep_softc *sc = (struct ep_softc *)self;

        /*
         * Write the PHY register by manually driving the MII control lines.
         */

        GO_WINDOW(4);

        ep_mii_sync(sc);
        ep_mii_sendbits(sc, MII_COMMAND_START, 2);
        ep_mii_sendbits(sc, MII_COMMAND_WRITE, 2);
        ep_mii_sendbits(sc, phy, 5);
        ep_mii_sendbits(sc, reg, 5);
        ep_mii_sendbits(sc, MII_COMMAND_ACK, 2);
        ep_mii_sendbits(sc, val, 16);

        ep_mii_clrbit(sc, PHYSMGMT_CLK);
        ep_mii_setbit(sc, PHYSMGMT_CLK);

        GO_WINDOW(1);   /* back to operating window */
}

void
ep_statchg(self)
        struct device *self;
{
        struct ep_softc *sc = (struct ep_softc *)self;
        bus_space_tag_t iot = sc->sc_iot;
        bus_space_handle_t ioh = sc->sc_ioh;
        int mctl;

        /* XXX Update ifp->if_baudrate */

        GO_WINDOW(3);
        mctl = bus_space_read_2(iot, ioh, EP_W3_MAC_CONTROL);
        if (sc->sc_mii.mii_media_active & IFM_FDX)
                mctl |= MAC_CONTROL_FDX;
        else
                mctl &= ~MAC_CONTROL_FDX;
        bus_space_write_2(iot, ioh, EP_W3_MAC_CONTROL, mctl);
        GO_WINDOW(1);   /* back to operating window */
@


1.37.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.37.2.2 2001/05/14 22:23:45 niklas Exp $	*/
d76 4
d360 1
a360 2
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
	IFQ_SET_READY(&ifp->if_snd);
d991 1
a991 1
	IFQ_POLL(&ifp->if_snd, m0);
d1010 1
a1010 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
d1026 2
a1027 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
d1277 1
d1327 3
d1339 3
a1341 1
	ether_input_mbuf(ifp, m);
d1408 1
a1408 1
		m_tag_init(m);
@


1.37.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.37.2.3 2001/07/04 10:40:51 niklas Exp $	*/
d356 1
d669 1
a669 1
	 * Attempt to get rid of any stray interrupts that occurred during
@


1.37.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1247 2
a1248 2
			ifp->if_flags &= ~IFF_OACTIVE;
			epstart(ifp);
a1397 1
		m->m_pkthdr.csum = 0;
@


1.37.2.6
log
@Merge in -current from about a week ago
@
text
@d84 1
a84 1
	char   *epm_name;		/* name of medium */
d143 2
a144 2
void ep_vortex_probemedia(struct ep_softc *sc);
void ep_isa_probemedia(struct ep_softc *sc);
d146 13
a158 13
void eptxstat(struct ep_softc *);
int epstatus(struct ep_softc *);
int epioctl(struct ifnet *, u_long, caddr_t);
void epstart(struct ifnet *);
void epwatchdog(struct ifnet *);
void epreset(struct ep_softc *);
void epread(struct ep_softc *);
struct mbuf *epget(struct ep_softc *, int);
void epmbuffill(void *);
void epmbufempty(struct ep_softc *);
void epsetfilter(struct ep_softc *);
void ep_roadrunner_mii_enable(struct ep_softc *);
int epsetmedia(struct ep_softc *, int);
d161 2
a162 2
int ep_media_change(struct ifnet *);
void ep_media_status(struct ifnet *, struct ifmediareq *);
d165 17
a181 17
int ep_mii_readreg(struct device *, int, int);
void ep_mii_writereg(struct device *, int, int, int);
void ep_statchg(struct device *);

void    ep_mii_setbit(struct ep_softc *, u_int16_t);
void    ep_mii_clrbit(struct ep_softc *, u_int16_t);
u_int16_t ep_mii_readbit(struct ep_softc *, u_int16_t);
void    ep_mii_sync(struct ep_softc *);
void    ep_mii_sendbits(struct ep_softc *, u_int32_t, int);

int epbusyeeprom(struct ep_softc *);
u_int16_t ep_read_eeprom(struct ep_softc *, u_int16_t);

static inline void ep_reset_cmd(struct ep_softc *sc, u_int cmd,u_int arg);
static inline void ep_finish_reset(bus_space_tag_t, bus_space_handle_t);
static inline void ep_discard_rxtop(bus_space_tag_t, bus_space_handle_t);
static __inline int ep_w1_reg(struct ep_softc *, int);
@


1.37.2.7
log
@Sync the SMP branch with 3.3
@
text
@d98 1
a98 1
const struct ep_media ep_vortex_media[8] = {
d549 1
a549 1
		const struct ep_media *epm = ep_vortex_media + i;
d1523 1
d1541 1
a1541 1
		} else if ((ifp->if_flags & IFF_UP) != 0) {
d1543 3
a1545 2
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
d1547 2
a1548 1
			epinit(sc);
@


1.37.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d68 1
d467 1
a467 1
 * default active medium; punt to ifconfig instead.
@


1.37.2.9
log
@Merge with the trunk
@
text
@d63 1
@


1.36
log
@fix mbuf chain allocation to comply with m_devget() way.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.35 1999/08/13 19:00:37 deraadt Exp $	*/
a151 1
void	epinit __P((struct ep_softc *));
@


1.35
log
@shutdown hook exists for the wrong reasons
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.34 1999/08/08 21:46:15 niklas Exp $	*/
d1253 6
d1260 1
a1260 1
	len = MHLEN - pad;
@


1.34
log
@These all are backends for interfaces that can be attached late, whence
ifinit can not set their ifq_maxlen, so do it ourselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.33 1999/08/05 18:08:55 jason Exp $	*/
a156 1
void	epshutdown __P((void *));
a349 3
	/*  Establish callback to reset card when we reboot. */
	shutdownhook_establish(epshutdown, sc);

a1463 13
}

/*
 * Before reboots, reset card completely.
 */
void
epshutdown(arg)
	void *arg;
{
	register struct ep_softc *sc = arg;

	epstop(sc);
	ep_complete_cmd(sc, EP_COMMAND, GLOBAL_RESET);
@


1.33
log
@ifdef/endif enclose debugging code
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.32 1999/07/26 12:31:43 niklas Exp $	*/
d293 1
@


1.32
log
@Remove obsolete detach code that has been dead for very long
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.31 1999/02/28 03:23:36 jason Exp $	*/
d942 1
d946 1
d978 1
d981 1
d987 1
d990 1
d995 1
d998 1
d1003 1
d1006 1
d1033 1
d1037 1
d1041 1
d1046 1
d1127 1
d1150 1
d1207 1
d1211 1
@


1.31
log
@compensate for the test of packet ownership being moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.30 1998/12/26 23:58:33 niklas Exp $	*/
a1056 3

	if (sc->bustype == EP_BUS_PCMCIA && (sc->pcmcia_flags & EP_ABSENT))
		return (ret);
@


1.30
log
@Kill pcmcia media setting that is always overridden these days.  Fix typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.29 1998/09/27 21:22:15 deraadt Exp $	*/
d1166 1
a1166 1
	if (ifp->if_bpf) {
a1167 14

		/*
		 * Note that the interface cannot be in promiscuous mode if
		 * there are no BPF listeners.  And if we are in promiscuous
		 * mode, we have to check if this packet is really ours.
		 */
		if ((ifp->if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
			    sizeof(eh->ether_dhost)) != 0) {
			m_freem(m);
			return;
		}
	}
@


1.29
log
@this driver does not handle 3c9xx
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.28 1998/09/19 10:08:05 maja Exp $	*/
d140 1
a140 1
/* Autoconfig defintion of driver back-end */
a545 5
#ifdef EP_COAX_DEFAULT
		bus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,3<<14);
#else
		bus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,0<<14);
#endif
@


1.28
log
@Added if_media support from NetBSD. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.27 1998/09/16 21:16:19 deraadt Exp $	*/
d246 3
a248 4
	 * Vortex-based (3c59x pci,eisa) and Boomerang (3c900,3c515?) cards
	 * allow FDDI-sized (4500) byte packets.  Commands only take an
	 * 11-bit parameter, and  11 bits isn't enough to hold a full-size
	 * packet length.
@


1.27
log
@fix ep probe message printouts
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.26 1998/09/11 12:06:54 fgsch Exp $	*/
d51 1
d100 1
a100 1
  { EP_PCI_UTP,        EPC_UTP, "utp",	    /*IFM_ETHER|IFM_10_T*/0,
d102 1
a102 1
  { EP_PCI_AUI,        EPC_AUI, "aui",	    /*IFM_ETHER|IFM_10_5*/0,
d104 2
a105 2
  { 0,                 0,  	"reserved", /*IFM_NONE*/0,  EPMEDIA_RESV1 },
  { EP_PCI_BNC,        EPC_BNC, "bnc",	    /*IFM_ETHER|IFM_10_2*/0,
d107 1
a107 1
  { EP_PCI_100BASE_TX, EPC_100TX, "100-TX", /*IFM_ETHER|IFM_100_TX*/0,
d109 1
a109 1
  { EP_PCI_100BASE_FX, EPC_100FX, "100-FX", /*IFM_ETHER|IFM_100_FX*/0,
d111 1
a111 1
  { EP_PCI_100BASE_MII,EPC_MII,   "mii",    /*IFM_ETHER|IFM_100_TX*/0,
d113 1
a113 1
  { EP_PCI_100BASE_T4, EPC_100T4, "100-T4", /*IFM_ETHER|IFM_100_T4*/0,
d123 3
a125 3
  { EP_W0_CC_UTP,  EPC_UTP, "utp",   /*IFM_ETHER|IFM_10_T*/0, EPMEDIA_10BASE_T },
  { EP_W0_CC_AUI,  EPC_AUI, "aui",   /*IFM_ETHER|IFM_10_5*/0, EPMEDIA_AUI },
  { EP_W0_CC_BNC,  EPC_BNC, "bnc",   /*IFM_ETHER|IFM_10_2*/0, EPMEDIA_10BASE_2 },
a127 1
#ifdef __NetBSD__
a138 1
#endif
d164 5
a309 1
#ifdef __NetBSD__
a310 1
#endif
a416 1
#ifdef __NetBSD__
a417 1
#endif
a427 1
#ifdef __NetBSD__
a428 1
#endif
a447 1
#ifdef __NetBSD__
a449 1
#endif
a468 1
#ifdef __NetBSD__
a469 1
#endif
a493 1
#ifdef __NetBSD__
a494 1
#endif	/* __NetBSD__ */
d506 1
a506 1
	sc->sc_media = ep_vortex_media[default_media].epm_ifdata;
a517 1
#ifdef __NetBSD__
a519 1
#endif	/* __NetBSD__ */
a593 1
#ifdef __NetBSD__
a594 3
#else
	epsetmedia(sc, sc->sc_media);
#endif
d627 10
d649 1
a649 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a677 10
#ifndef __NetBSD__
	/* XXX what media?  */
	if (!(ifp->if_flags & IFF_LINK0) && (sc->ep_connectors & EPC_BNC))
		medium = EPMEDIA_10BASE_2;
	else if (ifp->if_flags & IFF_LINK0)
		medium = ((ifp->if_flags & IFF_LINK1) &&
		    (sc->ep_connectors & EPC_UTP)) ?
		    EPMEDIA_10BASE_T :  EPMEDIA_AUI;
#endif

d758 61
d1367 5
d1395 2
a1396 1
			epsetmedia(sc, sc->sc_media);	/* XXX */
@


1.26
log
@Add a third parameter to epconfig to get the MAC address if it's a pcmcia
card and support it. Use NULL otherwise.
Update the ep based drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.25 1998/04/28 07:39:53 deraadt Exp $	*/
d239 1
a239 1
	printf(": address %s, ", ether_sprintf(sc->sc_arpcom.ac_enaddr));
@


1.25
log
@do not zap media flag on SIOCSIFFLAGS; ibo@@ragnarok.val-axs.net & ms@@xy.org
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.24 1998/04/04 08:09:23 deraadt Exp $	*/
d200 1
a200 1
epconfig(sc, chipset)
d203 1
d219 18
a236 14
	/*
	 * Read the station address from the eeprom
	 */
	for (i = 0; i < 3; i++) {
		u_int16_t x;
		if (epbusyeeprom(sc))
			return;		/* XXX why is eeprom busy? */
		bus_space_write_2(iot, ioh, EP_W0_EEPROM_COMMAND,
		    READ_EEPROM | i);
		if (epbusyeeprom(sc))
			return;		/* XXX why is eeprom busy? */
		x = bus_space_read_2(iot, ioh, EP_W0_EEPROM_DATA);
		sc->sc_arpcom.ac_enaddr[(i << 1)] = x >> 8;
		sc->sc_arpcom.ac_enaddr[(i << 1) + 1] = x;
@


1.24
log
@ignore EEPROM_TST_MODE mode on pci cards too
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.23 1998/02/25 23:56:51 deraadt Exp $	*/
d1338 1
a1338 1
			epsetmedia(sc, 0);	/* XXX */
@


1.23
log
@pretty print for pci cards too
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.22 1998/02/23 17:36:52 niklas Exp $	*/
d1481 2
a1482 1
	if (sc->bustype != EP_BUS_PCMCIA && (j & EEPROM_TST_MODE)) {
@


1.22
log
@Please GCC2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.21 1998/01/17 16:40:38 mickey Exp $	*/
d234 1
a234 2
	printf("%s: address %s, ", sc->sc_dev.dv_xname,
		ether_sprintf(sc->sc_arpcom.ac_enaddr));
d507 2
a508 2
	printf(" default %s%s\n",
	       medium_name,  (autoselect)? ", autoselect" : "" );
@


1.21
log
@s/defined(DEBUG)/defined(EP_DEBUG)/g
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.20 1997/10/30 23:49:28 niklas Exp $	*/
d683 3
a685 5
		if ((ifp->if_flags & IFF_LINK1) &&
		    (sc->ep_connectors & EPC_UTP))
			medium = EPMEDIA_10BASE_T;
		else
			medium = EPMEDIA_AUI;
@


1.20
log
@From Jim Rees <rees@@umich.edu>: remember media type
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.19 1997/09/16 17:47:03 flipk Exp $	*/
d722 1
a722 1
#if defined(DEBUG)
d741 1
a741 1
#if defined(DEBUG)
d748 1
a748 1
#if defined(DEBUG)
@


1.19
log
@tighten up probe printfs a bit and prepend with device name
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.18 1997/07/30 11:12:22 niklas Exp $	*/
d510 1
d581 1
a581 1
	/* Set threshhold for for Tx-space avaiable interrupt. */
d603 1
a603 1
	epsetmedia(sc, 0);	/* XXX */
a679 1
	medium = 0;
d702 1
a702 1
		DELAY(1000);	/* 50ms not enmough? */
@


1.19.2.1
log
@Merge in 1.19 to 1.20 from the trunk;
From Jim Rees <rees@@umich.edu>: remember media type
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.20 1997/10/30 23:49:28 niklas Exp $	*/
a509 1
	sc->sc_media = ep_vortex_media[default_media].epm_ifdata;
d580 1
a580 1
	/* Set threshold for for Tx-space available interrupt. */
d602 1
a602 1
	epsetmedia(sc, sc->sc_media);
d679 1
d702 1
a702 1
		DELAY(1000);	/* 50ms not enough? */
@


1.18
log
@Sync to NetBSD.  Adapt to use bus_space_multi_raw* interface of OpenBSD.
Some KNF too.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.17 1997/01/05 04:03:26 deraadt Exp $	*/
d234 2
a235 1
	printf("address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d266 2
a267 3
		printf("%s: wrote %d to TX_AVAIL_THRESH, read back %d. "
		    "Interface disabled\n",
		    sc->sc_dev.dv_xname, EP_THRESH_DISABLE, (int) i);
@


1.17
log
@absent pcmcia cards do not interrupt
@
text
@d1 2
a2 2
/*	$OpenBSD: elink3.c,v 1.16 1996/11/28 23:27:49 niklas Exp $	*/
/*	$NetBSD: elink3.c,v 1.11 1996/10/21 22:34:21 thorpej Exp $	*/
d5 1
a47 1
#include <net/netisr.h>
d76 66
d146 14
a159 8
static void eptxstat __P((struct ep_softc *));
static int epstatus __P((struct ep_softc *));
void epinit __P((struct ep_softc *));
int epioctl __P((struct ifnet *, u_long, caddr_t));
void epstart __P((struct ifnet *));
void epwatchdog __P((struct ifnet *));
void epreset __P((struct ep_softc *));
void epread __P((struct ep_softc *));
d161 7
a167 4
void epmbuffill __P((void *));
void epmbufempty __P((struct ep_softc *));
void epsetfilter __P((struct ep_softc *));
void epsetlink __P((struct ep_softc *));
d169 14
a182 1
static int epbusyeeprom __P((struct ep_softc *));
d184 15
d200 1
a200 1
epconfig(sc, conn)
d202 1
a202 1
	u_int16_t conn;
d209 8
a216 19
	sc->ep_connectors = 0;
	if (conn & IS_AUI) {
		printf("aui");
		sc->ep_connectors |= AUI;
	}
	if (conn & IS_BNC) {
		if (sc->ep_connectors)
			printf("/");
		printf("bnc");
		sc->ep_connectors |= BNC;
	}
	if (conn & IS_UTP) {
		if (sc->ep_connectors)
			printf("/");
		printf("utp");
		sc->ep_connectors |= UTP;
	}
	if (!sc->ep_connectors)
		printf("no connectors!");
d224 1
a224 1
			return;
d228 1
a228 1
			return;
d234 1
a234 1
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d236 14
a249 1
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_TX_AVAIL_THRESH | 1800 );
d253 7
a259 1
	if (i == 1800*4)
d261 17
d290 48
d340 1
a340 1
		  sizeof(struct ether_header));
d344 108
d454 1
d456 74
d566 4
a569 1
		/* Reset the station-address receive filter */
d571 1
a571 1
			bus_space_write_1(iot, ioh,EP_W2_RECVMASK_0 + i, 0);
d573 2
a574 2
	bus_space_write_2(iot, ioh, EP_COMMAND, RX_RESET);
	bus_space_write_2(iot, ioh, EP_COMMAND, TX_RESET);
d580 5
d599 5
a603 1
	epsetlink(sc);
d618 5
d636 11
a646 3
void
epsetlink(sc)
	register struct ep_softc *sc;
d648 1
a648 1
	register struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d651 2
d662 31
d694 7
a700 7
	bus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, DISABLE_UTP);
	if (!(ifp->if_flags & IFF_LINK0) && (sc->ep_connectors & BNC)) {
		if (sc->bustype == EP_BUS_PCMCIA) {
			GO_WINDOW(0);
			bus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,3<<14);
			GO_WINDOW(1);
		}
d702 25
a726 1
		delay(1000);
d728 36
a763 13
	if (ifp->if_flags & IFF_LINK0) {
		bus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);
		delay(1000);
		if ((ifp->if_flags & IFF_LINK1) && (sc->ep_connectors & UTP)) {
			if (sc->bustype == EP_BUS_PCMCIA) {
				GO_WINDOW(0);
				bus_space_write_2(iot, ioh,
				    EP_W0_ADDRESS_CFG,0<<14);
				GO_WINDOW(4);
			}
			bus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,
			    ENABLE_UTP);
		}
d765 3
a767 1
	GO_WINDOW(1);
d785 1
a785 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)
d822 1
a822 1
		    SET_TX_AVAIL_THRESH | (2044 >> sc->txashift));
d830 1
a830 1
	    (len / 4 + sc->tx_start_thresh));
d849 3
a851 3
				bus_space_write_multi_4(iot, ioh,
				    EP_W1_TX_PIO_WR_1, mtod(m, u_int32_t *),
				    m->m_len / 4);
d863 3
a865 3
				bus_space_write_multi_2(iot, ioh,
				    EP_W1_TX_PIO_WR_1, mtod(m, u_int16_t *),
				    m->m_len / 2);
d893 1
a893 2
		}
		else
d896 1
a896 2
	}
	else {
d917 1
a917 1
static int
d962 1
a962 1
static void
d1115 1
d1141 1
d1167 1
a1167 1
				       sc->sc_dev.dv_xname);
d1249 3
a1251 3
				bus_space_read_multi_4(iot, ioh,
				    EP_W1_RX_PIO_RD_1, mtod(m, u_int32_t *),
				    len / 4);
d1259 3
a1261 3
				bus_space_read_multi_2(iot, ioh,
				    EP_W1_RX_PIO_RD_1, mtod(m, u_int16_t *),
				    len / 2);
d1338 1
a1338 1
			 * IFF_LINK0, IFF_LINK1,
d1341 1
a1341 1
			epsetlink(sc);
d1407 4
a1410 2
	bus_space_write_2(iot, ioh, EP_COMMAND, RX_RESET);
	bus_space_write_2(iot, ioh, EP_COMMAND, TX_RESET);
d1420 13
d1464 1
a1464 1
static int
d1484 2
a1485 2
	if (sc->bustype != EP_BUS_PCMCIA && j & EEPROM_TST_MODE) {
		printf("\n%s: erase pencil mark, or disable plug-n-play mode!\n",
@


1.16
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.15 1996/11/12 20:30:18 niklas Exp $	*/
d550 3
@


1.15
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*	$OpenBSD: elink3.c,v 1.14 1996/10/31 01:01:28 niklas Exp $	*/
/*	$NetBSD: elink3.c,v 1.7 1996/05/14 22:22:05 thorpej Exp $	*/
d66 1
a66 1
#include <machine/bus.old.h>
d102 2
a103 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d133 2
a134 1
		bus_io_write_2(bc, ioh, EP_W0_EEPROM_COMMAND, READ_EEPROM | i);
d137 1
a137 1
		x = bus_io_read_2(bc, ioh, EP_W0_EEPROM_DATA);
d144 1
a144 1
	bus_io_write_2(bc, ioh, EP_COMMAND, SET_TX_AVAIL_THRESH | 1800 );
d146 1
a146 1
	i = bus_io_read_2(bc, ioh, EP_W5_TX_AVAIL_THRESH);
d179 2
a180 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d183 1
a183 1
	while (bus_io_read_2(bc, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
d188 2
a189 2
		bus_io_write_2(bc, ioh, EP_W0_CONFIG_CTRL, 0);
		bus_io_write_2(bc, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);
d194 1
a194 1
		bus_io_write_2(bc, ioh, EP_W0_ADDRESS_CFG,3<<14);
d196 1
a196 1
		bus_io_write_2(bc, ioh, EP_W0_ADDRESS_CFG,0<<14);
d198 1
a198 1
		bus_io_write_2(bc, ioh, EP_W0_RESOURCE_CFG, 0x3f00);
d203 1
a203 1
		bus_io_write_1(bc, ioh, EP_W2_ADDR_0 + i,
d209 1
a209 1
			bus_io_write_1(bc, ioh,EP_W2_RECVMASK_0 + i, 0);
d211 2
a212 2
	bus_io_write_2(bc, ioh, EP_COMMAND, RX_RESET);
	bus_io_write_2(bc, ioh, EP_COMMAND, TX_RESET);
d216 1
a216 1
		bus_io_read_1(bc, ioh, EP_W1_TX_STATUS);
d218 4
a221 4
	bus_io_write_2(bc, ioh, EP_COMMAND, SET_RD_0_MASK | S_CARD_FAILURE | 
				S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);
	bus_io_write_2(bc, ioh, EP_COMMAND, SET_INTR_MASK | S_CARD_FAILURE |
				S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);
d229 1
a229 1
	bus_io_write_2(bc, ioh, EP_COMMAND, ACK_INTR | 0xff);
d234 2
a235 2
	bus_io_write_2(bc, ioh, EP_COMMAND, RX_ENABLE);
	bus_io_write_2(bc, ioh, EP_COMMAND, TX_ENABLE);
d254 1
a254 1
	bus_io_write_2(sc->sc_bc, sc->sc_ioh, EP_COMMAND, SET_RX_FILTER |
d265 2
a266 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d277 1
a277 1
	bus_io_write_2(bc, ioh, EP_W4_MEDIA_TYPE, DISABLE_UTP);
d281 1
a281 1
			bus_io_write_2(bc, ioh, EP_W0_ADDRESS_CFG,3<<14);
d284 1
a284 1
		bus_io_write_2(bc, ioh, EP_COMMAND, START_TRANSCEIVER);
d288 1
a288 1
		bus_io_write_2(bc, ioh, EP_COMMAND, STOP_TRANSCEIVER);
d293 1
a293 1
				bus_io_write_2(bc, ioh,
d297 2
a298 1
			bus_io_write_2(bc, ioh, EP_W4_MEDIA_TYPE, ENABLE_UTP);
d313 2
a314 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d348 2
a349 2
	if (bus_io_read_2(bc, ioh, EP_W1_FREE_TX) < len + pad + 4) {
		bus_io_write_2(bc, ioh, EP_COMMAND,
d355 1
a355 1
		bus_io_write_2(bc, ioh, EP_COMMAND,
d363 1
a363 1
	bus_io_write_2(bc, ioh, EP_COMMAND, SET_TX_START_THRESH |
d377 2
a378 2
	bus_io_write_2(bc, ioh, EP_W1_TX_PIO_WR_1, len);
	bus_io_write_2(bc, ioh, EP_W1_TX_PIO_WR_1,
d383 1
a383 1
				bus_io_write_multi_4(bc, ioh,
d387 1
a387 1
				bus_io_write_multi_1(bc, ioh,
d397 1
a397 1
				bus_io_write_multi_2(bc, ioh,
d401 1
a401 1
				bus_io_write_1(bc, ioh, EP_W1_TX_PIO_WR_1,
d408 1
a408 1
		bus_io_write_1(bc, ioh, EP_W1_TX_PIO_WR_1, 0);
d415 2
a416 1
	if ((bus_io_read_2(bc, ioh, EP_W1_RX_STATUS) & ERR_INCOMPLETE) == 0) {
d418 1
a418 1
		u_int16_t status = bus_io_read_2(bc, ioh, EP_STATUS);
d429 1
a429 1
			/* Got an interrupt, return so that it gets serviced. */
d437 1
a437 1
				       sc->sc_dev.dv_xname);
d457 2
a458 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d465 1
a465 1
	fifost = bus_io_read_2(bc, ioh, EP_W4_FIFO_DIAG);
d502 2
a503 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d510 3
a512 2
	while ((i = bus_io_read_1(bc, ioh, EP_W1_TX_STATUS)) & TXS_COMPLETE) {
		bus_io_write_1(bc, ioh, EP_W1_TX_STATUS, 0x0);
d533 1
a533 1
			bus_io_write_2(bc, ioh, EP_COMMAND, TX_ENABLE);
d545 2
a546 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d552 1
a552 1
		bus_io_write_2(bc, ioh, EP_COMMAND, C_INTR_LATCH);
d554 1
a554 1
		status = bus_io_read_2(bc, ioh, EP_STATUS);
d568 1
a568 1
		bus_io_write_2(bc, ioh, EP_COMMAND, ACK_INTR | status);
d578 1
a578 1
			       sc->sc_dev.dv_xname, status);
d596 2
a597 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d603 1
a603 1
	len = bus_io_read_2(bc, ioh, EP_W1_RX_STATUS);
d693 1
a693 1
		len = bus_io_read_2(bc, ioh, EP_W1_RX_STATUS);
d708 2
a709 2
	bus_io_write_2(bc, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (bus_io_read_2(bc, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
d718 2
a719 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d780 1
a780 1
				bus_io_read_multi_4(bc, ioh,
d784 1
a784 1
				bus_io_read_multi_1(bc, ioh,
d790 1
a790 1
				bus_io_read_multi_2(bc, ioh,
d795 2
a796 1
				    bus_io_read_1(bc, ioh, EP_W1_RX_PIO_RD_1);
d804 2
a805 2
	bus_io_write_2(bc, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (bus_io_read_2(bc, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
d929 2
a930 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d932 3
a934 3
	bus_io_write_2(bc, ioh, EP_COMMAND, RX_DISABLE);
	bus_io_write_2(bc, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (bus_io_read_2(bc, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
d936 8
a943 8
	bus_io_write_2(bc, ioh, EP_COMMAND, TX_DISABLE);
	bus_io_write_2(bc, ioh, EP_COMMAND, STOP_TRANSCEIVER);
	bus_io_write_2(bc, ioh, EP_COMMAND, RX_RESET);
	bus_io_write_2(bc, ioh, EP_COMMAND, TX_RESET);
	bus_io_write_2(bc, ioh, EP_COMMAND, C_INTR_LATCH);
	bus_io_write_2(bc, ioh, EP_COMMAND, SET_RD_0_MASK);
	bus_io_write_2(bc, ioh, EP_COMMAND, SET_INTR_MASK);
	bus_io_write_2(bc, ioh, EP_COMMAND, SET_RX_FILTER);
d959 1
a959 1
 * returned to us by bus_io_read_1().  Hence; we read 16 times getting one
d965 3
a967 3
epreadeeprom(bc, ioh, offset)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d973 1
a973 1
	bus_io_write_1(bc, ioh, 0, 0x80 + offset);
d976 1
a976 1
		data = (data << 1) | (bus_io_read_2(bc, ioh, 0) & 1);
d984 2
a985 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d989 1
a989 1
		j = bus_io_read_2(bc, ioh, EP_W0_EEPROM_COMMAND);
@


1.14
log
@$OpenBSD RCSIDs
@
text
@d1 1
a1 1
/*	$OpenBSD: elink3.c,v 1.7 1996/05/14 22:22:05 thorpej Exp $	*/
d66 1
a66 1
#include <machine/bus.h>
@


1.13
log
@on newer cards, use word count for SET_TX_AVAIL_THRESH; from numerous people, gleamed from plan9/bsdi drivers, and confirmed in last two sentences in 3c590 manual
@
text
@d1 1
@


1.12
log
@Fix for PCI etherlink3  packet-receive bug; netbsd pr#2661, jonathan@@DSG.Stanford.EDU
@
text
@d142 7
d347 1
a347 1
		    SET_TX_AVAIL_THRESH | (len + pad + 4));
d353 1
a353 1
		    SET_TX_AVAIL_THRESH | 2044);
@


1.12.2.1
log
@merge in fixes
@
text
@a141 7
	bus_io_write_2(bc, ioh, EP_COMMAND, SET_TX_AVAIL_THRESH | 1800 );
	GO_WINDOW(5);
	i = bus_io_read_2(bc, ioh, EP_W5_TX_AVAIL_THRESH);
	GO_WINDOW(1);
	if (i == 1800*4)
		sc->txashift = 2;

d340 1
a340 1
		    SET_TX_AVAIL_THRESH | ((len + pad + 4) >> sc->txashift));
d346 1
a346 1
		    SET_TX_AVAIL_THRESH | (2044 >> sc->txashift));
@


1.11
log
@Apply Niklas align fix. (better than my try)
@
text
@d197 5
@


1.10
log
@Not a good idea. Revert to r1.5 + changes
@
text
@d705 1
a705 1
	int len;
d725 3
a727 1
	len = MHLEN;
d754 1
a754 1
		if (totlen >= MINCLSIZE) {
@


1.9
log
@Alignment fix, another aproach as the previous broke bpf..
@
text
@d583 1
a583 1
	struct ether_header eh;
d631 2
d647 3
a649 3
		    (eh.ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(eh.ether_dhost, sc->sc_arpcom.ac_enaddr,
			    sizeof(eh.ether_dhost)) != 0) {
a655 1
	bcopy(m->m_data, &eh, sizeof(struct ether_header));
d657 1
a657 1
	ether_input(ifp, &eh, m);
@


1.8
log
@do not delay excessively on pcmcia; from peter
@
text
@d87 1
a87 1
struct mbuf *epget __P((struct ep_softc *, struct ether_header *, int));
d623 1
a623 1
	m = epget(sc, &eh, len);
d654 2
d696 1
a696 1
epget(sc, eh, totlen)
a697 1
	struct ether_header *eh;
d723 1
a733 7

	if(totlen > sizeof(struct ether_header)) {
		bus_io_read_multi_2(bc, ioh,
		    EP_W1_RX_PIO_RD_1, eh, sizeof(struct ether_header) / 2);
		totlen -= sizeof(struct ether_header);
	}
	m->m_pkthdr.len = totlen;
@


1.7
log
@This driver and some other ether drivers violates the alignment of
struct ether_header by placing it's start on a non 32bit int boundary.
On processor with alignment restrictions (like MIPS) this will fail badly.
This is the first driver to have been fixed. The fix is to copy the
ether header to a separate buffer instead of into the mbuf.
@
text
@a971 5
	if (sc->bustype == EP_BUS_PCMCIA) {
		delay(1000);
		return 0;
	}

d984 1
a984 1
	if (j & EEPROM_TST_MODE) {
@


1.6
log
@sync 0521
@
text
@d87 1
a87 1
struct mbuf *epget __P((struct ep_softc *, int));
d583 1
a583 1
	struct ether_header *eh;
d623 1
a623 1
	m = epget(sc, len);
a630 3
	/* We assume the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d645 3
a647 3
		    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
			    sizeof(eh->ether_dhost)) != 0) {
d654 1
a654 3
	/* We assume the header fit entirely in one mbuf. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
d694 1
a694 1
epget(sc, totlen)
d696 1
a721 1
	m->m_pkthdr.len = totlen;
d732 7
@


1.5
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$NetBSD: elink3.c,v 1.5 1996/05/07 01:43:13 thorpej Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994 Herb Peyerl <hpeyerl@@novatel.ca>
d66 1
d98 1
a98 1
	u_int conn;
d103 1
a103 1
	u_short i;
d129 1
a129 1
		u_short x;
d402 1
a402 1
		u_short status = bus_io_read_2(bc, ioh, EP_STATUS);
d443 1
a443 1
	u_short fifost;
d531 1
a531 1
	u_short status;
@


1.4
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 1
a1 1
/*	$NetBSD: elink3.c,v 1.4 1996/05/03 19:08:47 christos Exp $	*/
d83 1
a83 1
void epwatchdog __P((int));
d99 1
a103 2
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

d141 2
a142 2
	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_name = ep_cd.cd_name;
d296 1
a296 1
	register struct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];
d800 1
a800 1
	struct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];
d895 2
a896 2
epwatchdog(unit)
	int unit;
d898 1
a898 1
	struct ep_softc *sc = ep_cd.cd_devs[unit];
@


1.3
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d1 1
a1 1
/*	$NetBSD: elink3.c,v 1.1 1996/04/25 02:17:34 thorpej Exp $	*/
d36 1
d65 1
a65 1
#include <machine/pio.h>
d78 1
a78 1
static void epxstat __P((struct ep_softc *));
d87 1
a87 1
void epmbuffill __P((struct ep_softc *));
a88 1
void epstop __P((struct ep_softc *));
a90 1
u_short epreadeeprom __P((int id_port, int offset));
d99 2
d132 1
a132 1
		outw(BASE + EP_W0_EEPROM_COMMAND, READ_EEPROM | i);
d135 1
a135 1
		x = inw(BASE + EP_W0_EEPROM_DATA);
d170 2
d174 1
a174 1
	while (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)
d179 2
a180 2
		outw(BASE + EP_W0_CONFIG_CTRL, 0);
		outw(BASE + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);
d185 1
a185 1
		outw(BASE + EP_W0_ADDRESS_CFG,3<<14);
d187 1
a187 1
		outw(BASE + EP_W0_ADDRESS_CFG,0<<14);
d189 1
a189 1
		outw(BASE + EP_W0_RESOURCE_CFG, 0x3f00);
d194 2
a195 1
		outb(BASE + EP_W2_ADDR_0 + i, sc->sc_arpcom.ac_enaddr[i]);
d197 2
a198 2
	outw(BASE + EP_COMMAND, RX_RESET);
	outw(BASE + EP_COMMAND, TX_RESET);
d202 1
a202 1
		inb(BASE + EP_W1_TX_STATUS);
d204 1
a204 1
	outw(BASE + EP_COMMAND, SET_RD_0_MASK | S_CARD_FAILURE | 
d206 1
a206 1
	outw(BASE + EP_COMMAND, SET_INTR_MASK | S_CARD_FAILURE |
d215 1
a215 1
	outw(BASE + EP_COMMAND, ACK_INTR | 0xff);
d220 2
a221 2
	outw(BASE + EP_COMMAND, RX_ENABLE);
	outw(BASE + EP_COMMAND, TX_ENABLE);
d240 1
a240 1
	outw(BASE + EP_COMMAND, SET_RX_FILTER |
d251 2
d263 1
a263 1
	outw(BASE + EP_W4_MEDIA_TYPE, DISABLE_UTP);
d267 1
a267 1
			outw(BASE + EP_W0_ADDRESS_CFG,3<<14);
d270 1
a270 1
		outw(BASE + EP_COMMAND, START_TRANSCEIVER);
d274 1
a274 1
		outw(BASE + EP_COMMAND, STOP_TRANSCEIVER);
d279 2
a280 1
				outw(BASE + EP_W0_ADDRESS_CFG,0<<14);
d283 1
a283 1
			outw(BASE + EP_W4_MEDIA_TYPE, ENABLE_UTP);
d298 2
d333 3
a335 2
	if (inw(BASE + EP_W1_FREE_TX) < len + pad + 4) {
		outw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | (len + pad + 4));
d340 2
a341 1
		outw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | 2044);
d348 1
a348 1
	outw(BASE + EP_COMMAND, SET_TX_START_THRESH |
d362 3
a364 2
	outw(BASE + EP_W1_TX_PIO_WR_1, len);
	outw(BASE + EP_W1_TX_PIO_WR_1, 0xffff);	/* Second dword meaningless */
d368 3
a370 2
				outsl(BASE + EP_W1_TX_PIO_WR_1,
				      mtod(m, caddr_t), m->m_len / 4);
d372 4
a375 3
				outsb(BASE + EP_W1_TX_PIO_WR_1,
				      mtod(m, caddr_t) + (m->m_len & ~3),
				      m->m_len & 3);
d382 3
a384 2
				outsw(BASE + EP_W1_TX_PIO_WR_1,
				      mtod(m, caddr_t), m->m_len / 2);
d386 2
a387 2
				outb(BASE + EP_W1_TX_PIO_WR_1,
				     *(mtod(m, caddr_t) + m->m_len - 1));
d393 1
a393 1
		outb(BASE + EP_W1_TX_PIO_WR_1, 0);
d400 1
a400 1
	if ((inw(BASE + EP_W1_RX_STATUS) & ERR_INCOMPLETE) == 0) {
d402 1
a402 1
		u_short status = inw(BASE + EP_STATUS);
d441 2
d449 1
a449 1
	fifost = inw(BASE + EP_W4_FIFO_DIAG);
d486 2
d494 2
a495 2
	while ((i = inb(BASE + EP_W1_TX_STATUS)) & TXS_COMPLETE) {
		outb(BASE + EP_W1_TX_STATUS, 0x0);
d516 1
a516 1
			outw(BASE + EP_COMMAND, TX_ENABLE);
a519 1
			
d528 2
d535 1
a535 1
		outw(BASE + EP_COMMAND, C_INTR_LATCH);
d537 1
a537 1
		status = inw(BASE + EP_STATUS);
d551 1
a551 1
		outw(BASE + EP_COMMAND, ACK_INTR | status);
d579 2
d586 1
a586 1
	len = inw(BASE + EP_W1_RX_STATUS);
d678 1
a678 1
		len = inw(BASE + EP_W1_RX_STATUS);
d693 2
a694 2
	outw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)
d703 2
d763 3
a765 2
				insl(BASE + EP_W1_RX_PIO_RD_1,
				     mtod(m, caddr_t), len / 4);
d767 3
a769 2
				insb(BASE + EP_W1_RX_PIO_RD_1,
				     mtod(m, caddr_t), len);
d773 3
a775 2
				insw(BASE + EP_W1_RX_PIO_RD_1,
				     mtod(m, caddr_t), len / 2);
d777 2
a778 2
				*(mtod(m, caddr_t)) =
				    inb(BASE + EP_W1_RX_PIO_RD_1);
d786 2
a787 2
	outw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)
d808 1
a808 1
	if ((error = ether_ioctl(ifp, sc->sc_arpcom, cmd, data)) > 0) {
d911 2
d914 3
a916 3
	outw(BASE + EP_COMMAND, RX_DISABLE);
	outw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)
d918 8
a925 8
	outw(BASE + EP_COMMAND, TX_DISABLE);
	outw(BASE + EP_COMMAND, STOP_TRANSCEIVER);
	outw(BASE + EP_COMMAND, RX_RESET);
	outw(BASE + EP_COMMAND, TX_RESET);
	outw(BASE + EP_COMMAND, C_INTR_LATCH);
	outw(BASE + EP_COMMAND, SET_RD_0_MASK);
	outw(BASE + EP_COMMAND, SET_INTR_MASK);
	outw(BASE + EP_COMMAND, SET_RX_FILTER);
d941 1
a941 1
 * returned to us by inb().  Hence; we read 16 times getting one
d943 2
d946 5
a950 4
u_short
epreadeeprom(id_port, offset)
	int     id_port;
	int     offset;
d952 2
a953 1
	int i, data = 0;
d955 1
a955 1
	outb(id_port, 0x80 + offset);
d958 1
a958 1
		data = (data << 1) | (inw(id_port) & 1);
d966 2
d976 1
a976 1
		j = inw(BASE + EP_W0_EEPROM_COMMAND);
d996 2
a997 2
epmbuffill(sc)
	struct ep_softc *sc;
d999 1
@


1.2
log
@prettier printf messages
@
text
@a57 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d781 5
a796 17
#endif
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			epinit(sc);
			break;
		    }
@


1.1
log
@if_ep splitup
@
text
@a109 1
	printf("%s: ", sc->sc_dev.dv_xname);
@

