head	1.49;
access;
symbols
	OPENBSD_6_2_BASE:1.49
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.10
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.8
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.4
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.6
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.8
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.6
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.49
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.48;
commitid	VyLWTsbepAOk7VQM;

1.48
date	2016.07.13.15.40.26;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	5MkUhHev3oDNkNaB;

1.47
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.46;
commitid	QHiEhS9DHyE6oiIr;

1.46
date	2016.02.12.20.02.04;	author mmcc;	state Exp;
branches;
next	1.45;
commitid	jrLk1qQflL5w44ka;

1.45
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.44;
commitid	J9apD0jq2AjFmqZc;

1.44
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.43;
commitid	B0kwmVGiD5DVx4kv;

1.43
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.42;
commitid	eYnPulzvLjDImPCa;

1.42
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.41;
commitid	p0v5tuE1Ch6fY0Nj;

1.41
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.40;
commitid	6vhYvh5CxZAHMnsN;

1.40
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.39;
commitid	MVWrtktB46JRxFWT;

1.39
date	2015.05.19.11.24.01;	author mpi;	state Exp;
branches;
next	1.38;
commitid	0fL6zHGm3fqppVdw;

1.38
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.37;
commitid	p4LJxGKbi0BU2cG6;

1.37
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.36;
commitid	yM2VFFhpDTeFQlve;

1.36
date	2014.09.23.02.53.59;	author dlg;	state Exp;
branches;
next	1.35;
commitid	hLkaixptKEhr2g73;

1.35
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.34;
commitid	TGHgrLxu6sxZoiFt;

1.34
date	2013.08.07.01.06.31;	author bluhm;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.23.09.45.58;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.03.20.25.29;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.17.17.56.10;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2006.02.24.01.48.27;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.23.14.42.55;	author martin;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.08.17.03.00;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.07.02.29.30;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.07.01.07.22;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.22.00.04.29;	author vincent;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.08.23.38.06;	author fgsch;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.06.27.06.34.43;	author kjc;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.24.04.57.07;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.23.23.17.35;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.23.21.54.46;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.20.19.39.36;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.02.19.09.58;	author fgsch;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.08.16.08.27.15;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	99.08.16.02.23.55;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.08.21.46.15;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.02.28.03.23.37;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	98.09.12.07.48.07;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	98.09.11.06.55.27;	author fgsch;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.24.14;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.41.10;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.49
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: smc91cxx.c,v 1.48 2016/07/13 15:40:26 deraadt Exp $	*/
/*	$NetBSD: smc91cxx.c,v 1.11 1998/08/08 23:51:41 mycroft Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*      
 * Copyright (c) 1996 Gardner Buchanan <gbuchanan@@shl.com>
 * All rights reserved.
 *      
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Gardner Buchanan.
 * 4. The name of Gardner Buchanan may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *       
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *      
 *   from FreeBSD Id: if_sn.c,v 1.4 1996/03/18 15:47:16 gardner Exp
 */      

/*
 * Core driver for the SMC 91Cxx family of Ethernet chips.
 *
 * Memory allocation interrupt logic is drived from an SMC 91C90 driver
 * written for NetBSD/amiga by Michael Hitch.
 */

#include "bpfilter.h"

#include <sys/param.h> 
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/ioctl.h> 
#include <sys/errno.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <net/if.h>
#include <net/if_media.h> 

#include <netinet/in.h> 
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/mii_bitbang.h>

#include <dev/ic/smc91cxxreg.h>
#include <dev/ic/smc91cxxvar.h>

#ifndef __BUS_SPACE_HAS_STREAM_METHODS
#define bus_space_write_multi_stream_2 bus_space_write_multi_2
#define bus_space_write_multi_stream_4 bus_space_write_multi_4
#define bus_space_read_multi_stream_2  bus_space_read_multi_2
#define bus_space_read_multi_stream_4  bus_space_read_multi_4
#endif /* __BUS_SPACE_HAS_STREAM_METHODS */

/* XXX Hardware padding doesn't work yet(?) */
#define	SMC91CXX_SW_PAD

const char *smc91cxx_idstrs[] = {
	NULL,				/* 0 */
	NULL,				/* 1 */
	NULL,				/* 2 */
	"SMC91C90/91C92",		/* 3 */
	"SMC91C94/91C96",		/* 4 */
	"SMC91C95",			/* 5 */
	NULL,				/* 6 */
	"SMC91C100",			/* 7 */
	"SMC91C100FD",			/* 8 */
	NULL,				/* 9 */
	NULL,				/* 10 */
	NULL,				/* 11 */
	NULL,				/* 12 */
	NULL,				/* 13 */
	NULL,				/* 14 */
	NULL,				/* 15 */
};

/* Supported media types. */
const uint64_t smc91cxx_media[] = {
	IFM_ETHER|IFM_10_T,
	IFM_ETHER|IFM_10_5,
};
#define	NSMC91CxxMEDIA	(sizeof(smc91cxx_media) / sizeof(smc91cxx_media[0]))

/*
 * MII bit-bang glue.
 */
u_int32_t smc91cxx_mii_bitbang_read(struct device *);
void smc91cxx_mii_bitbang_write(struct device *, u_int32_t);

const struct mii_bitbang_ops smc91cxx_mii_bitbang_ops = {
	smc91cxx_mii_bitbang_read,
	smc91cxx_mii_bitbang_write,
	{
		MR_MDO,		/* MII_BIT_MDO */
		MR_MDI,		/* MII_BIT_MDI */
		MR_MCLK,	/* MII_BIT_MDC */
		MR_MDOE,	/* MII_BIT_DIR_HOST_PHY */
		0,		/* MII_BIT_DIR_PHY_HOST */
	}
};

struct cfdriver sm_cd = {
	NULL, "sm", DV_IFNET
};

/* MII callbacks */
int	smc91cxx_mii_readreg(struct device *, int, int);
void	smc91cxx_mii_writereg(struct device *, int, int, int);
void	smc91cxx_statchg(struct device *);
void	smc91cxx_tick(void *);

int	smc91cxx_mediachange(struct ifnet *);
void	smc91cxx_mediastatus(struct ifnet *, struct ifmediareq *);

int	smc91cxx_set_media(struct smc91cxx_softc *, uint64_t);

void	smc91cxx_read(struct smc91cxx_softc *);
void	smc91cxx_reset(struct smc91cxx_softc *);
void	smc91cxx_start(struct ifnet *);
void	smc91cxx_resume(struct smc91cxx_softc *);
void	smc91cxx_watchdog(struct ifnet *);
int	smc91cxx_ioctl(struct ifnet *, u_long, caddr_t);

void
smc91cxx_attach(sc, myea)
	struct smc91cxx_softc *sc;
	u_int8_t *myea;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	struct ifmedia *ifm = &sc->sc_mii.mii_media;
	u_int32_t miicapabilities;
	u_int16_t tmp;
	int i, aui;
	const char *idstr;

	/* Make sure the chip is stopped. */
	smc91cxx_stop(sc);

	SMC_SELECT_BANK(sc, 3);
	tmp = bus_space_read_2(bst, bsh, REVISION_REG_W);
	sc->sc_chipid = RR_ID(tmp);
	/* check magic number */
	if ((tmp & BSR_DETECT_MASK) != BSR_DETECT_VALUE) {
		idstr = NULL;
		printf("%s: invalid BSR 0x%04x\n", sc->sc_dev.dv_xname, tmp);
	} else
		idstr = smc91cxx_idstrs[RR_ID(tmp)];
#ifdef SMC_DEBUG
	printf("\n%s: ", sc->sc_dev.dv_xname);
	if (idstr != NULL)
		printf("%s, ", idstr);
	else
		printf("unknown chip id %d, ", sc->sc_chipid);
	printf("revision %d", RR_REV(tmp));
#endif

	/* Read the station address from the chip. */
	SMC_SELECT_BANK(sc, 1);
	if (myea == NULL) {
		for (i = 0; i < ETHER_ADDR_LEN; i += 2) {
			tmp = bus_space_read_2(bst, bsh, IAR_ADDR0_REG_W + i);
			sc->sc_arpcom.ac_enaddr[i + 1] = (tmp >>8) & 0xff;
			sc->sc_arpcom.ac_enaddr[i] = tmp & 0xff;
		}
	} else {
		bcopy(myea, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
	}

	printf(": address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/* Initialize the ifnet structure. */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = smc91cxx_start;
	ifp->if_ioctl = smc91cxx_ioctl;
	ifp->if_watchdog = smc91cxx_watchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	/*
	 * Initialize our media structures and MII info.  We will
	 * probe the MII if we are on the SMC91Cxx
	 */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = smc91cxx_mii_readreg;
	sc->sc_mii.mii_writereg = smc91cxx_mii_writereg;
	sc->sc_mii.mii_statchg = smc91cxx_statchg;
	ifmedia_init(ifm, 0, smc91cxx_mediachange, smc91cxx_mediastatus);

	SMC_SELECT_BANK(sc, 1);
	tmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);

	miicapabilities = BMSR_MEDIAMASK|BMSR_ANEG;
	switch (sc->sc_chipid) {
	case CHIP_91100:
		/*
		 * The 91100 does not have full-duplex capabilities,
		 * even if the PHY does.
		 */
		miicapabilities &= ~(BMSR_100TXFDX | BMSR_10TFDX);
		/* FALLTHROUGH */
	case CHIP_91100FD:
		if (tmp & CR_MII_SELECT) {
#ifdef SMC_DEBUG
			printf("%s: default media MII\n",
			    sc->sc_dev.dv_xname);
#endif
			mii_attach(&sc->sc_dev, &sc->sc_mii, miicapabilities,
			    MII_PHY_ANY, MII_OFFSET_ANY, 0);
			if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
				ifmedia_add(&sc->sc_mii.mii_media,
				    IFM_ETHER|IFM_NONE, 0, NULL);
				ifmedia_set(&sc->sc_mii.mii_media,
				    IFM_ETHER|IFM_NONE);
			} else {
				ifmedia_set(&sc->sc_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
			}
			sc->sc_flags |= SMC_FLAGS_HAS_MII;
			break;
		}
		/* FALLTHROUGH */
	default:
		aui = tmp & CR_AUI_SELECT;
#ifdef SMC_DEBUG
		printf("%s: default media %s\n", sc->sc_dev.dv_xname,
			aui ? "AUI" : "UTP");
#endif
		for (i = 0; i < NSMC91CxxMEDIA; i++)
			ifmedia_add(ifm, smc91cxx_media[i], 0, NULL);
		ifmedia_set(ifm, IFM_ETHER | (aui ? IFM_10_5 : IFM_10_T));
		break;
	}

	/* The attach is successful. */
	sc->sc_flags |= SMC_FLAGS_ATTACHED;
}

/*
 * Change media according to request.
 */
int
smc91cxx_mediachange(ifp)
	struct ifnet *ifp;
{
	struct smc91cxx_softc *sc = ifp->if_softc;

	return (smc91cxx_set_media(sc, sc->sc_mii.mii_media.ifm_media));
}

int
smc91cxx_set_media(sc, media)
	struct smc91cxx_softc *sc;
	uint64_t media;
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	u_int16_t tmp;

	/*
	 * If the interface is not currently powered on, just return.
	 * When it is enabled later, smc91cxx_init() will properly set
	 * up the media for us.
	 */
	if ((sc->sc_flags & SMC_FLAGS_ENABLED) == 0)
		return (0);

	if (IFM_TYPE(media) != IFM_ETHER)
		return (EINVAL);

	if (sc->sc_flags & SMC_FLAGS_HAS_MII)
		return (mii_mediachg(&sc->sc_mii));

	switch (IFM_SUBTYPE(media)) {
	case IFM_10_T:
	case IFM_10_5:
		SMC_SELECT_BANK(sc, 1);
		tmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);
		if (IFM_SUBTYPE(media) == IFM_10_5)
			tmp |= CR_AUI_SELECT;
		else
			tmp &= ~CR_AUI_SELECT;
		bus_space_write_2(bst, bsh, CONFIG_REG_W, tmp);
		delay(20000);	/* XXX is this needed? */
		break;

	default:
		return (EINVAL);
	}

	return (0);
}

/*
 * Notify the world which media we're using.
 */
void
smc91cxx_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct smc91cxx_softc *sc = ifp->if_softc;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	u_int16_t tmp;

	if ((sc->sc_flags & SMC_FLAGS_ENABLED) == 0) {
		ifmr->ifm_active = IFM_ETHER | IFM_NONE;
		ifmr->ifm_status = 0;
		return;
	}

	/*
	 * If we have MII, go ask the PHY what's going on.
	 */
	if (sc->sc_flags & SMC_FLAGS_HAS_MII) {
		mii_pollstat(&sc->sc_mii);
		ifmr->ifm_active = sc->sc_mii.mii_media_active;
		ifmr->ifm_status = sc->sc_mii.mii_media_status;
		return;
	}

	SMC_SELECT_BANK(sc, 1);
	tmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);
	ifmr->ifm_active =
	    IFM_ETHER | ((tmp & CR_AUI_SELECT) ? IFM_10_5 : IFM_10_T);
}

/*
 * Reset and initialize the chip.
 */
void
smc91cxx_init(sc)
	struct smc91cxx_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	u_int16_t tmp;
	int s, i;

	s = splnet();

	/*
	 * This resets the registers mostly to defaults, but doesn't
	 * affect the EEPROM.  After the reset cycle, we pause briefly
	 * for the chip to recover.
	 *
	 * XXX how long are we really supposed to delay?  --thorpej
	 */
	SMC_SELECT_BANK(sc, 0);
	bus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, RCR_SOFTRESET);
	delay(100);
	bus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);
	delay(200);

	bus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);

	/* Set the Ethernet address. */
	SMC_SELECT_BANK(sc, 1);
	for (i = 0; i < ETHER_ADDR_LEN; i++ )
		bus_space_write_1(bst, bsh, IAR_ADDR0_REG_W + i,
		    sc->sc_arpcom.ac_enaddr[i]);

	/*
	 * Set the control register to automatically release successfully
	 * transmitted packets (making the best use of our limited memory)
	 * and enable the EPH interrupt on certain TX errors.
	 */
	bus_space_write_2(bst, bsh, CONTROL_REG_W, (CTR_AUTO_RELEASE |
	    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE));

	/*
	 * Reset the MMU and wait for it to be un-busy.
	 */
	SMC_SELECT_BANK(sc, 2);
	bus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RESET);
	while (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)
		/* XXX bound this loop! */ ;

	/*
	 * Disable all interrupts.
	 */
	bus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);

	/*
	 * Set current media.
	 */
	smc91cxx_set_media(sc, sc->sc_mii.mii_media.ifm_cur->ifm_media);

	/*
	 * Set the receive filter.  We want receive enable and auto
	 * strip of CRC from received packet.  If we are in promisc. mode,
	 * then set that bit as well.
	 *
	 * XXX Initialize multicast filter.  For now, we just accept
	 * XXX all multicast.
	 */
	SMC_SELECT_BANK(sc, 0);

	tmp = RCR_ENABLE | RCR_STRIP_CRC | RCR_ALMUL;
	if (ifp->if_flags & IFF_PROMISC)
		tmp |= RCR_PROMISC;

	bus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, tmp);

	/*
	 * Set transmitter control to "enabled".
	 */
	tmp = TCR_ENABLE;

#ifndef SMC91CXX_SW_PAD
	/*
	 * Enable hardware padding of transmitted packets.
	 * XXX doesn't work?
	 */
	tmp |= TCR_PAD_ENABLE;
#endif

	bus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, tmp);

	/*
	 * Now, enable interrupts.
	 */
	SMC_SELECT_BANK(sc, 2);

	bus_space_write_1(bst, bsh, INTR_MASK_REG_B,
	    IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT);

	/* Interface is now running, with no output active. */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (sc->sc_flags & SMC_FLAGS_HAS_MII) {
		/* Start the one second clock. */
		timeout_set(&sc->sc_mii_timeout, smc91cxx_tick, sc);
		timeout_add_sec(&sc->sc_mii_timeout, 1);
	}

	/*
	 * Attempt to start any pending transmission.
	 */
	smc91cxx_start(ifp);

	splx(s);
}

/*
 * Start output on an interface.
 * Must be called at splnet or interrupt level.
 */
void
smc91cxx_start(ifp)
	struct ifnet *ifp;
{
	struct smc91cxx_softc *sc = ifp->if_softc;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	u_int len;
	struct mbuf *m, *top;
	u_int16_t length, npages;
	u_int8_t packetno;
	int timo, pad;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

 again:
	/*
	 * Peek at the next packet.
	 */
	m = ifq_deq_begin(&ifp->if_snd);
	if (m == NULL)
		return;

	/*
	 * Compute the frame length and set pad to give an overall even
	 * number of bytes.  Below, we assume that the packet length
	 * is even.
	 */
	for (len = 0, top = m; m != NULL; m = m->m_next)
		len += m->m_len;
	pad = (len & 1);

	/*
	 * We drop packets that are too large.  Perhaps we should
	 * truncate them instead?
	 */
	if ((len + pad) > (ETHER_MAX_LEN - ETHER_CRC_LEN)) {
		printf("%s: large packet discarded\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		ifq_deq_commit(&ifp->if_snd, m);
		m_freem(m);
		goto readcheck;
	}

#ifdef SMC91CXX_SW_PAD
	/*
	 * Not using hardware padding; pad to ETHER_MIN_LEN.
	 */
	if (len < (ETHER_MIN_LEN - ETHER_CRC_LEN))
		pad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;
#endif

	length = pad + len;

	/*
	 * The MMU has a 256 byte page size.  The MMU expects us to
	 * ask for "npages - 1".  We include space for the status word,
	 * byte count, and control bytes in the allocation request.
	 */
	npages = (length + 6) >> 8;

	/*
	 * Now allocate the memory.
	 */
	SMC_SELECT_BANK(sc, 2);
	bus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ALLOC | npages);

	timo = MEMORY_WAIT_TIME;
	do {
		if (bus_space_read_1(bst, bsh, INTR_STAT_REG_B) & IM_ALLOC_INT)
			break;
		delay(1);
	} while (--timo);

	packetno = bus_space_read_1(bst, bsh, ALLOC_RESULT_REG_B);

	if (packetno & ARR_FAILED || timo == 0) {
		/*
		 * No transmit memory is available.  Record the number
		 * of requestd pages and enable the allocation completion
		 * interrupt.  Set up the watchdog timer in case we miss
		 * the interrupt.  Mark the interface as active so that
		 * no one else attempts to transmit while we're allocating
		 * memory.
		 */
		bus_space_write_1(bst, bsh, INTR_MASK_REG_B,
		    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) | IM_ALLOC_INT);

		ifp->if_timer = 5;
		ifq_deq_rollback(&ifp->if_snd, m);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	/*
	 * We have a packet number - set the data window.
	 */
	bus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);

	/*
	 * Point to the beginning of the packet.
	 */
	bus_space_write_2(bst, bsh, POINTER_REG_W, PTR_AUTOINC /* | 0x0000 */);

	/*
	 * Send the packet length (+6 for stats, length, and control bytes)
	 * and the status word (set to zeros).
	 */
	bus_space_write_2(bst, bsh, DATA_REG_W, 0);
	bus_space_write_1(bst, bsh, DATA_REG_B, (length + 6) & 0xff);
	bus_space_write_1(bst, bsh, DATA_REG_B, ((length + 6) >> 8) & 0xff);

	/*
	 * Get the packet from the kernel.  This will include the Ethernet
	 * frame header, MAC address, etc.
	 */
	ifq_deq_commit(&ifp->if_snd, m);

	/*
	 * Push the packet out to the card.
	 */
	for (top = m; m != NULL; m = m->m_next) {
		/* Words... */
		if (m->m_len > 1)
			bus_space_write_multi_stream_2(bst, bsh, DATA_REG_W,
			    mtod(m, u_int16_t *), m->m_len >> 1);

		/* ...and the remaining byte, if any. */
		if (m->m_len & 1)
			bus_space_write_1(bst, bsh, DATA_REG_B,
			  *(u_int8_t *)(mtod(m, u_int8_t *) + (m->m_len - 1)));
	}

#ifdef SMC91CXX_SW_PAD
	/*
	 * Push out padding.
	 */
	while (pad > 1) {
		bus_space_write_2(bst, bsh, DATA_REG_W, 0);
		pad -= 2;
	}
	if (pad)
		bus_space_write_1(bst, bsh, DATA_REG_B, 0);
#endif

	/*
	 * Push out control byte and unused packet byte.  The control byte
	 * is 0, meaning the packet is even lengthed and no special
	 * CRC handling is necessary.
	 */
	bus_space_write_2(bst, bsh, DATA_REG_W, 0);

	/*
	 * Enable transmit interrupts and let the chip go.  Set a watchdog
	 * in case we miss the interrupt.
	 */
	bus_space_write_1(bst, bsh, INTR_MASK_REG_B,
	    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) |
	    IM_TX_INT | IM_TX_EMPTY_INT);

	bus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ENQUEUE);

	ifp->if_timer = 5;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, top, BPF_DIRECTION_OUT);
#endif

	m_freem(top);

 readcheck:
	/*
	 * Check for incoming packets.  We don't want to overflow the small
	 * RX FIFO.  If nothing has arrived, attempt to queue another
	 * transmit packet.
	 */
	if (bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) & FIFO_REMPTY)
		goto again;
}

/*
 * Interrupt service routine.
 */
int
smc91cxx_intr(arg)
	void *arg;
{
	struct smc91cxx_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	u_int8_t mask, interrupts, status;
	u_int16_t packetno, tx_status, card_stats;

	if ((sc->sc_flags & SMC_FLAGS_ENABLED) == 0 ||
	    (sc->sc_dev.dv_flags & DVF_ACTIVE) == 0)
		return (0);

	SMC_SELECT_BANK(sc, 2);

	/*
	 * Obtain the current interrupt mask.
	 */
	mask = bus_space_read_1(bst, bsh, INTR_MASK_REG_B);

	/*
	 * Get the set of interrupt which occurred and eliminate any
	 * which are not enabled.
	 */
	interrupts = bus_space_read_1(bst, bsh, INTR_STAT_REG_B);
	status = interrupts & mask;

	/* Ours? */
	if (status == 0)
		return (0);

	/*
	 * It's ours; disable all interrupts while we process them.
	 */
	bus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);

	/*
	 * Receive overrun interrupts.
	 */
	if (status & IM_RX_OVRN_INT) {
		bus_space_write_1(bst, bsh, INTR_ACK_REG_B, IM_RX_OVRN_INT);
		ifp->if_ierrors++;
	}

	/*
	 * Receive interrupts.
	 */
	if (status & IM_RCV_INT) {
#if 1 /* DIAGNOSTIC */
		packetno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W);
		if (packetno & FIFO_REMPTY) {
			printf("%s: receive interrupt on empty fifo\n",
			    sc->sc_dev.dv_xname);
			goto out;
		} else
#endif
		smc91cxx_read(sc);
	}

	/*
	 * Memory allocation interrupts.
	 */
	if (status & IM_ALLOC_INT) {
		/* Disable this interrupt. */
		mask &= ~IM_ALLOC_INT;

		/*
		 * Release the just-allocated memory.  We will reallocate
		 * it through the normal start logic.
		 */
		while (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)
			/* XXX bound this loop! */ ;
		bus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_FREEPKT);

		ifq_clr_oactive(&ifp->if_snd);
		ifp->if_timer = 0;
	}

	/*
	 * Transmit complete interrupt.  Handle transmission error messages.
	 * This will only be called on error condition because of AUTO RELEASE
	 * mode.
	 */
	if (status & IM_TX_INT) {
		bus_space_write_1(bst, bsh, INTR_ACK_REG_B, IM_TX_INT);

		packetno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) &
		    FIFO_TX_MASK;

		/*
		 * Select this as the packet to read from.
		 */
		bus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);

		/*
		 * Position the pointer to the beginning of the packet.
		 */
		bus_space_write_2(bst, bsh, POINTER_REG_W,
		    PTR_AUTOINC | PTR_READ /* | 0x0000 */);

		/*
		 * Fetch the TX status word.  This will be a copy of
		 * the EPH_STATUS_REG_W at the time of the transmission
		 * failure.
		 */
		tx_status = bus_space_read_2(bst, bsh, DATA_REG_W);

		if (tx_status & EPHSR_TX_SUC)
			printf("%s: successful packet caused TX interrupt?!\n",
			    sc->sc_dev.dv_xname);
		else
			ifp->if_oerrors++;

		if (tx_status & EPHSR_LATCOL)
			ifp->if_collisions++;

		/*
		 * Some of these errors disable the transmitter; reenable it.
		 */
		SMC_SELECT_BANK(sc, 0);
#ifdef SMC91CXX_SW_PAD
		bus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, TCR_ENABLE);
#else
		bus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W,
		    TCR_ENABLE | TCR_PAD_ENABLE);
#endif

		/*
		 * Kill the failed packet and wait for the MMU to unbusy.
		 */
		SMC_SELECT_BANK(sc, 2);
		while (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)
			/* XXX bound this loop! */ ;
		bus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_FREEPKT);

		ifp->if_timer = 0;
	}

	/*
	 * Transmit underrun interrupts.  We use this opportunity to
	 * update transmit statistics from the card.
	 */
	if (status & IM_TX_EMPTY_INT) {
		bus_space_write_1(bst, bsh, INTR_ACK_REG_B, IM_TX_EMPTY_INT);

		/* Disable this interrupt. */
		mask &= ~IM_TX_EMPTY_INT;

		SMC_SELECT_BANK(sc, 0);
		card_stats = bus_space_read_2(bst, bsh, COUNTER_REG_W);

		/* Single collisions. */
		ifp->if_collisions += card_stats & ECR_COLN_MASK;

		/* Multiple collisions. */
		ifp->if_collisions += (card_stats & ECR_MCOLN_MASK) >> 4;

		SMC_SELECT_BANK(sc, 2);

		ifp->if_timer = 0;
	}

	/*
	 * Other errors.  Reset the interface.
	 */
	if (status & IM_EPH_INT) {
		smc91cxx_stop(sc);
		smc91cxx_init(sc);
	}

	/*
	 * Attempt to queue more packets for transmission.
	 */
	smc91cxx_start(ifp);

out:
	/*
	 * Reenable the interrupts we wish to receive now that processing
	 * is complete.
	 */
	mask |= bus_space_read_1(bst, bsh, INTR_MASK_REG_B);
	bus_space_write_1(bst, bsh, INTR_MASK_REG_B, mask);

	return (1);
}

/*
 * Read a packet from the card and pass it up to the kernel.
 * NOTE!  WE EXPECT TO BE IN REGISTER WINDOW 2!
 */
void
smc91cxx_read(sc)
	struct smc91cxx_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	u_int16_t status, packetno, packetlen;
	u_int8_t *data;

 again:
	/*
	 * Set data pointer to the beginning of the packet.  Since
	 * PTR_RCV is set, the packet number will be found automatically
	 * in FIFO_PORTS_REG_W, FIFO_RX_MASK.
	 */
	bus_space_write_2(bst, bsh, POINTER_REG_W,
	    PTR_READ | PTR_RCV | PTR_AUTOINC /* | 0x0000 */);

	/*
	 * First two words are status and packet length.
	 */
	status = bus_space_read_2(bst, bsh, DATA_REG_W);
	packetlen = bus_space_read_2(bst, bsh, DATA_REG_W);

	/*
	 * The packet length includes 3 extra words: status, length,
	 * and an extra word that includes the control byte.
	 */
	packetlen -= 6;

	/*
	 * Account for receive errors and discard.
	 */
	if (status & RS_ERRORS) {
		ifp->if_ierrors++;
		goto out;
	}

	/*
	 * Adjust for odd-length packet.
	 */
	if (status & RS_ODDFRAME)
		packetlen++;

	/*
	 * Allocate a header mbuf.
	 */
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		goto out;
	m->m_pkthdr.len = packetlen;

	/*
	 * Always put the packet in a cluster.
	 * XXX should chain small mbufs if less than threshold.
	 */
	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		ifp->if_ierrors++;
		printf("%s: can't allocate cluster for incoming packet\n",
		    sc->sc_dev.dv_xname);
		goto out;
	}

	/*
	 * Pull the packet off the interface.  Make sure the payload
	 * is aligned.
	 */
	m->m_data = (caddr_t) ALIGN(mtod(m, caddr_t) +
	    sizeof(struct ether_header)) - sizeof(struct ether_header);

	data = mtod(m, u_int8_t *);
	if (packetlen > 1)
		bus_space_read_multi_stream_2(bst, bsh, DATA_REG_W,
		    (u_int16_t *)data, packetlen >> 1);
	if (packetlen & 1) {
		data += packetlen & ~1;
		*data = bus_space_read_1(bst, bsh, DATA_REG_B);
	}

	m->m_pkthdr.len = m->m_len = packetlen;
	ml_enqueue(&ml, m);

 out:
	/*
	 * Tell the card to free the memory occupied by this packet.
	 */
	while (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)
		/* XXX bound this loop! */ ;
	bus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RELEASE);

	/*
	 * Check for another packet.
	 */
	packetno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W);
	if (packetno & FIFO_REMPTY) {
		if_input(ifp, &ml);
		return;
	}
	goto again;
}

/*
 * Process an ioctl request.
 */
int
smc91cxx_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct smc91cxx_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		if ((error = smc91cxx_enable(sc)) != 0)
			break;
		ifp->if_flags |= IFF_UP;
		smc91cxx_init(sc);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running,
			 * stop it.
			 */
			smc91cxx_stop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
			smc91cxx_disable(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped,
			 * start it.
			 */
			if ((error = smc91cxx_enable(sc)) != 0)
				break;
			smc91cxx_init(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0) {
			/*
			 * Reset the interface to pick up changes in any
			 * other flags that affect hardware registers.
			 */
			smc91cxx_reset(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			smc91cxx_reset(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

/*
 * Reset the interface.
 */
void
smc91cxx_reset(sc)
	struct smc91cxx_softc *sc;
{
	int s;

	s = splnet();
	smc91cxx_stop(sc);
	smc91cxx_init(sc);
	splx(s);
}

/*
 * Watchdog timer.
 */
void
smc91cxx_watchdog(ifp)
	struct ifnet *ifp;
{
	struct smc91cxx_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	smc91cxx_reset(sc);
}

/*
 * Stop output on the interface.
 */
void
smc91cxx_stop(sc)
	struct smc91cxx_softc *sc;
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;

	/*
	 * Clear interrupt mask; disable all interrupts.
	 */
	SMC_SELECT_BANK(sc, 2);
	bus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);

	/*
	 * Disable transmitter and receiver.
	 */
	SMC_SELECT_BANK(sc, 0);
	bus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);
	bus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);

	/*
	 * Cancel watchdog timer.
	 */
	sc->sc_arpcom.ac_if.if_timer = 0;
}

/*
 * Enable power on the interface.
 */
int
smc91cxx_enable(sc)
	struct smc91cxx_softc *sc;
{
	if ((sc->sc_flags & SMC_FLAGS_ENABLED) == 0 && sc->sc_enable != NULL) {
		if ((*sc->sc_enable)(sc) != 0) {
			printf("%s: device enable failed\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}
	}

	sc->sc_flags |= SMC_FLAGS_ENABLED;
	return (0);
}

/*
 * Disable power on the interface.
 */
void
smc91cxx_disable(sc)
	struct smc91cxx_softc *sc;
{
	if ((sc->sc_flags & SMC_FLAGS_ENABLED) != 0 && sc->sc_disable != NULL) {
		(*sc->sc_disable)(sc);
		sc->sc_flags &= ~SMC_FLAGS_ENABLED;
	}
}

int
smc91cxx_activate(self, act)
	struct device *self;
	int act;
{
#if 0
	struct smc91cxx_softc *sc = (struct smc91cxx_softc *)self;
#endif
	int rv = 0, s;

	s = splnet();
	switch (act) {
	case DVACT_DEACTIVATE:
#if 0
		if_deactivate(&sc->sc_ic.ic_if);
#endif
		break;
	}
	splx(s);
	return(rv);
}

int
smc91cxx_detach(self, flags)
	struct device *self;
	int flags;
{
	struct smc91cxx_softc *sc = (struct smc91cxx_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Succeed now if there's no work to do. */
	if ((sc->sc_flags & SMC_FLAGS_ATTACHED) == 0)
		return(0);

	/* smc91cxx_disable() checks SMC_FLAGS_ENABLED */
	smc91cxx_disable(sc);

	/* smc91cxx_attach() never fails */

	/* Delete all media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (0);
}

u_int32_t
smc91cxx_mii_bitbang_read(self)
	struct device *self;
{
	struct smc91cxx_softc *sc = (void *) self;

	/* We're already in bank 3. */
	return (bus_space_read_2(sc->sc_bst, sc->sc_bsh, MGMT_REG_W));
}

void
smc91cxx_mii_bitbang_write(self, val)
	struct device *self;
	u_int32_t val;
{
	struct smc91cxx_softc *sc = (void *) self;

	/* We're already in bank 3. */
	bus_space_write_2(sc->sc_bst, sc->sc_bsh, MGMT_REG_W, val);
}

int
smc91cxx_mii_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
{
	struct smc91cxx_softc *sc = (void *) self;
	int val;

	SMC_SELECT_BANK(sc, 3);

	val = mii_bitbang_readreg(self, &smc91cxx_mii_bitbang_ops, phy, reg);

	SMC_SELECT_BANK(sc, 2);

	return (val);
}

void
smc91cxx_mii_writereg(self, phy, reg, val)
	struct device *self;
	int phy, reg, val;
{
	struct smc91cxx_softc *sc = (void *) self;

	SMC_SELECT_BANK(sc, 3);

	mii_bitbang_writereg(self, &smc91cxx_mii_bitbang_ops, phy, reg, val);

	SMC_SELECT_BANK(sc, 2);
}

void
smc91cxx_statchg(self)
	struct device *self;
{
	struct smc91cxx_softc *sc = (struct smc91cxx_softc *)self;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	int mctl;

	SMC_SELECT_BANK(sc, 0);
	mctl = bus_space_read_2(bst, bsh, TXMIT_CONTROL_REG_W);
	if (sc->sc_mii.mii_media_active & IFM_FDX)
		mctl |= TCR_SWFDUP;
	else
		mctl &= ~TCR_SWFDUP;
	bus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, mctl);
	SMC_SELECT_BANK(sc, 2); /* back to operating window */
}

/*
 * One second timer, used to tick the MII.
 */
void
smc91cxx_tick(arg)
	void *arg;
{
	struct smc91cxx_softc *sc = arg;
	int s;

#ifdef DIAGNOSTIC
	if ((sc->sc_flags & SMC_FLAGS_HAS_MII) == 0)
		panic("smc91cxx_tick");
#endif

	if ((sc->sc_dev.dv_flags & DVF_ACTIVE) == 0)
		return;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_mii_timeout, 1);
}
@


1.48
log
@remove unused function ether_cmp()
from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.47 2016/04/13 10:49:26 mpi Exp $	*/
a687 1
	ifp->if_opackets++;
@


1.47
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.46 2016/02/12 20:02:04 mmcc Exp $	*/
a182 12

static __inline int ether_cmp(void *, void *);
static __inline int
ether_cmp(va, vb)
	void *va, *vb;
{
	u_int8_t *a = va;
	u_int8_t *b = vb;

	return ((a[5] != b[5]) || (a[4] != b[4]) || (a[3] != b[3]) ||
		(a[2] != b[2]) || (a[1] != b[1]) || (a[0] != b[0]));
}
@


1.46
log
@pcakets -> packets
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.45 2015/12/08 13:34:22 tedu Exp $	*/
a252 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.45
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.44 2015/11/25 03:09:58 dlg Exp $	*/
d706 1
a706 1
	 * Check for incoming pcakets.  We don't want to overflow the small
@


1.44
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.43 2015/11/20 03:35:22 dlg Exp $	*/
d252 1
a252 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.43
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.42 2015/10/25 12:48:46 mpi Exp $	*/
d511 1
a511 1
	ifp->if_flags &= ~IFF_OACTIVE;
d544 1
a544 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)
a620 2
		ifp->if_flags |= IFF_OACTIVE;

d622 1
d793 1
a793 1
		ifp->if_flags &= ~IFF_OACTIVE;
@


1.42
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.41 2015/09/11 13:02:28 stsp Exp $	*/
d551 1
a551 1
	IFQ_POLL(&ifp->if_snd, m);
d571 1
a571 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d623 1
d649 1
a649 1
	IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.41
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.40 2015/06/24 09:40:54 mpi Exp $	*/
a1024 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d1035 1
a1035 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			smc91cxx_init(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			smc91cxx_init(sc);
			break;
		}
@


1.40
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.39 2015/05/19 11:24:01 mpi Exp $	*/
d138 1
a138 1
const int smc91cxx_media[] = {
d175 1
a175 1
int	smc91cxx_set_media(struct smc91cxx_softc *, int);
d333 1
a333 1
	int media;
@


1.39
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.38 2015/03/14 03:38:47 jsg Exp $	*/
a992 1
	ifp->if_ipackets++;
@


1.38
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.37 2014/12/22 02:28:51 tedu Exp $	*/
d916 1
a961 1
	m->m_pkthdr.rcvif = ifp;
a993 6

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

d995 1
a995 1
	ether_input_mbuf(ifp, m);
d1009 2
a1010 1
	if (packetno & FIFO_REMPTY)
d1012 1
@


1.37
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.36 2014/09/23 02:53:59 dlg Exp $	*/
a91 1
#include <net/if_dl.h>
@


1.36
log
@dont need to call bpfdetach cos if_detach does it for you.

delete some stupid comments while there.

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.35 2014/07/22 13:12:12 mpi Exp $	*/
a94 1
#ifdef INET
a96 1
#endif
a1042 1
#ifdef INET
a1046 1
#endif
@


1.35
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.34 2013/08/07 01:06:31 bluhm Exp $	*/
a699 1
	/* Hand off a copy to the bpf. */
a998 4
	/*
	 * Hand the packet off to bpf listeners.  If there's a bpf listener,
	 * we need to check if the packet is ours.
	 */
a1236 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.34
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.33 2011/07/03 15:47:16 matthew Exp $	*/
a97 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.33
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.32 2009/10/13 19:33:16 pirofti Exp $	*/
a98 1
#include <netinet/in_var.h>
@


1.32
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.31 2009/07/23 09:45:58 kettenis Exp $	*/
a1214 3
	case DVACT_ACTIVATE:
		break;

@


1.31
log
@If we initialize miicapabilities, we might as well pass it on when calling
mii_attach.  Spotted by chl@@.  Fix inspired by looking at the current
NetBSD code.  Repeated calls for testing went unanswered.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.30 2008/11/28 02:44:17 brad Exp $	*/
d1206 1
a1206 1
	enum devact act;
@


1.30
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.29 2008/10/03 20:25:29 brad Exp $	*/
d286 1
d293 1
a293 1
			mii_attach(&sc->sc_dev, &sc->sc_mii, 0xffffffff,
d307 1
a307 1
		/*FALLTHROUGH*/
@


1.29
log
@Use ether_ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.28 2008/09/10 14:01:22 blambert Exp $	*/
a1091 21
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		if ((sc->sc_flags & SMC_FLAGS_ENABLED) == 0) {
			error = EIO;
			break;
		}

		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				smc91cxx_reset(sc);
			error = 0;
		}
		break;

d1099 6
@


1.28
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.27 2008/06/26 05:42:16 ray Exp $	*/
d1119 1
a1119 2
		error = EINVAL;
		break;
@


1.27
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.26 2006/06/23 06:27:11 miod Exp $	*/
d521 1
a521 1
		timeout_add(&sc->sc_mii_timeout, hz);
d1365 1
a1365 1
	timeout_add(&sc->sc_mii_timeout, hz);
@


1.26
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.25 2006/06/17 17:56:10 brad Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.25
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.24 2006/03/25 22:41:43 djm Exp $	*/
a1237 1
		rv = EOPNOTSUPP;
@


1.24
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.23 2006/02/24 01:48:27 brad Exp $	*/
d89 1
@


1.23
log
@remove NetBSD rnd(4) code.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.22 2006/01/23 14:42:55 martin Exp $	*/
d710 1
a710 1
		bpf_mtap(ifp->if_bpf, top);
d1013 1
a1013 1
		bpf_mtap(ifp->if_bpf, m);
@


1.22
log
@update sm(4) from NetBSD, including support for more models and MII;
also activate ISA attachment;

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.21 2005/06/08 17:03:00 henning Exp $	*/
a92 3
#if NRND > 0
#include <sys/rnd.h>
#endif
a324 5
#if NRND > 0
	rnd_attach_source(&sc->rnd_source, sc->sc_dev.dv_xname,
			  RND_TYPE_NET, 0);
#endif

a913 5
#if NRND > 0
	if (status)
		rnd_add_uint32(&sc->rnd_source, status);
#endif

a1269 3
#if NRND > 0
	rnd_detach_source(&sc->rnd_source);
#endif
@


1.21
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.20 2005/06/07 02:29:30 henning Exp $	*/
d89 1
d116 4
d123 7
d138 1
a138 1
	"SMC91C94",			/* 4 */
d142 1
a142 1
	NULL,				/* 8 */
d159 18
d181 6
a198 3
int	smc91cxx_enable(struct smc91cxx_softc *);
void	smc91cxx_disable(struct smc91cxx_softc *);

d219 2
a222 1
#ifdef SMC_DEBUG
a223 1
#endif
a227 1
#ifdef SMC_DEBUG
d230 9
a238 2
	idstr = smc91cxx_idstrs[RR_ID(tmp)];
	printf("%s: ", sc->sc_dev.dv_xname);
d242 2
a243 2
		printf("unknown chip id %d, ", RR_ID(tmp));
	printf("revision %d\n", RR_REV(tmp));
d258 1
a258 7
	printf(": address %s, ",
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/* ..and default media. */
	tmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);
	printf("utp/aui (default %s)\n", (aui = (tmp & CR_AUI_SELECT)) ?
	    "aui" : "utp");
d274 53
a326 6
	/* Initialize the media structures. */
	ifmedia_init(&sc->sc_media, 0, smc91cxx_mediachange,
	    smc91cxx_mediastatus);
	for (i = 0; i < NSMC91CxxMEDIA; i++)
		ifmedia_add(&sc->sc_media, smc91cxx_media[i], 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER | (aui ? IFM_10_5 : IFM_10_T));
d329 2
a330 1
	rnd_attach_source(&sc->rnd_source, sc->sc_dev.dv_xname, RND_TYPE_NET);
d332 3
d346 1
a346 1
	return (smc91cxx_set_media(sc, sc->sc_media.ifm_media));
d363 1
a363 1
	if (sc->sc_enabled == 0)
d369 3
d405 1
a405 1
	if (sc->sc_enabled == 0) {
d411 10
d487 1
a487 1
	smc91cxx_set_media(sc, sc->sc_media.ifm_cur->ifm_media);
d532 6
d674 3
a676 2
		bus_space_write_multi_2(bst, bsh, DATA_REG_W,
		    mtod(m, u_int16_t *), m->m_len >> 1);
d748 2
a749 1
	if (sc->sc_enabled == 0)
d789 1
a789 1
		if (packetno & FIFO_REMPTY)
d792 2
a793 1
		else
d914 1
a985 1

d987 1
a987 1
	m->m_pkthdr.len = m->m_len = packetlen;
d1003 2
a1004 1
	 * Pull the packet off the interface.
d1006 3
d1010 3
a1012 2
	bus_space_read_multi_2(bst, bsh, DATA_REG_W, (u_int16_t *)data,
	    packetlen >> 1);
d1102 1
a1102 1
		} else if (sc->sc_enabled) {
d1113 1
a1113 1
		if (sc->sc_enabled == 0) {
d1134 1
a1134 1
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
d1212 1
a1212 2

	if (sc->sc_enabled == 0 && sc->sc_enable != NULL) {
d1220 1
a1220 1
	sc->sc_enabled = 1;
d1231 21
d1253 5
a1257 3
	if (sc->sc_enabled != 0 && sc->sc_disable != NULL) {
		(*sc->sc_disable)(sc);
		sc->sc_enabled = 0;
d1259 130
@


1.20
log
@CCITT about to bite the dust, remove special casing in archs and drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.19 2005/01/15 05:24:11 brad Exp $	*/
a110 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a964 22
#endif
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else {
				bcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl), 
				    ETHER_ADDR_LEN);
			}

			/*
			 * Set new address.  Reset, because the receiver
			 * has to be stopped before we can set the new
			 * MAC address.
			 */
			smc91cxx_reset(sc);
			break;
		    }
@


1.19
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.18 2004/05/12 06:35:10 tedu Exp $	*/
a115 8
#if defined(CCITT) && defined(LLC)
#include <sys/socketvar.h>
#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>
#endif

a997 12

#if defined(CCITT) && defined(LLC)
	case SIOCSIFCONF_X25:
		if ((error = smc91cxx_enable(sc)) != 0)
			break;
		ifp->if_flags |= IFF_UP;
		ifa->ifa_rtrequest = cons_rtrequest;	/* XXX */
		error = x25_llcglue(PRC_IFUP, ifa->ifa_addr);
		if (error == 0)
			smc91cxx_init(sc);
		break;
#endif
@


1.18
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.17 2003/10/21 18:58:49 jmc Exp $	*/
d1062 2
a1063 1
			smc91cxx_reset(sc);
@


1.17
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.16 2002/06/07 01:07:22 itojun Exp $	*/
a125 1
#include <net/bpfdesc.h>
@


1.16
log
@fix indent
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.15 2002/03/22 00:04:29 vincent Exp $	*/
d360 1
a360 1
	 * This resets the registersmostly to defaults, but doesn't
@


1.15
log
@  make idstrs[] even if SMC_DEBUG is not defined, so the sm(4) drivers
compile.

 ok fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.14 2002/03/14 01:26:55 millert Exp $	*/
d976 3
a978 3
		smc91cxx_init(sc);
		arp_ifinit(&sc->sc_arpcom, ifa);
		break;
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.13 2001/07/08 23:38:06 fgsch Exp $	*/
a134 1
#ifdef SMC_DEBUG
a152 1
#endif
@


1.13
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.12 2001/06/27 06:34:43 kjc Exp $	*/
d167 2
a168 2
int	smc91cxx_mediachange __P((struct ifnet *));
void	smc91cxx_mediastatus __P((struct ifnet *, struct ifmediareq *));
d170 1
a170 1
int	smc91cxx_set_media __P((struct smc91cxx_softc *, int));
d172 6
a177 6
void	smc91cxx_read __P((struct smc91cxx_softc *));
void	smc91cxx_reset __P((struct smc91cxx_softc *));
void	smc91cxx_start __P((struct ifnet *));
void	smc91cxx_resume __P((struct smc91cxx_softc *));
void	smc91cxx_watchdog __P((struct ifnet *));
int	smc91cxx_ioctl __P((struct ifnet *, u_long, caddr_t));
d179 2
a180 2
int	smc91cxx_enable __P((struct smc91cxx_softc *));
void	smc91cxx_disable __P((struct smc91cxx_softc *));
d182 1
a182 1
static __inline int ether_cmp __P((void *, void *));
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.13 2001/07/08 23:38:06 fgsch Exp $	*/
d135 1
d154 1
d167 2
a168 2
int	smc91cxx_mediachange(struct ifnet *);
void	smc91cxx_mediastatus(struct ifnet *, struct ifmediareq *);
d170 1
a170 1
int	smc91cxx_set_media(struct smc91cxx_softc *, int);
d172 6
a177 6
void	smc91cxx_read(struct smc91cxx_softc *);
void	smc91cxx_reset(struct smc91cxx_softc *);
void	smc91cxx_start(struct ifnet *);
void	smc91cxx_resume(struct smc91cxx_softc *);
void	smc91cxx_watchdog(struct ifnet *);
int	smc91cxx_ioctl(struct ifnet *, u_long, caddr_t);
d179 2
a180 2
int	smc91cxx_enable(struct smc91cxx_softc *);
void	smc91cxx_disable(struct smc91cxx_softc *);
d182 1
a182 1
static __inline int ether_cmp(void *, void *);
d978 3
a980 3
			smc91cxx_init(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
@


1.12
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.11 2001/06/24 04:57:07 fgsch Exp $	*/
a250 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
@


1.11
log
@Add back stuff I removed in previous commit with a minor change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.10 2001/06/23 23:17:35 fgsch Exp $	*/
d251 2
a252 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d484 2
a485 1
	if ((m = ifp->if_snd.ifq_head) == NULL)
d504 1
a504 1
		IF_DEQUEUE(&ifp->if_snd, m);
d581 1
a581 1
	IF_DEQUEUE(&ifp->if_snd, m);
@


1.10
log
@ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.9 2001/06/23 21:54:46 fgsch Exp $	*/
d933 1
@


1.9
log
@Remove repeated ethernet constants; use if_ether.h for it instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.8 2001/02/20 19:39:36 mickey Exp $	*/
a848 1
	struct ether_header *eh;
a913 1
	eh = mtod(m, struct ether_header *);
d933 1
a933 7
	/*
	 * Strip the ethernet header.
	 */
	m->m_pkthdr.len = m->m_len = packetlen - sizeof(struct ether_header);
	m->m_data += sizeof(struct ether_header);

	ether_input(ifp, eh, m);
@


1.8
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.7 2000/02/02 19:09:58 fgsch Exp $	*/
a134 2
#define ETHER_ADDR_LEN		6

a180 5

/* XXX Should be in a common header file. */
#define	ETHER_MAX_LEN	1518
#define	ETHER_MIN_LEN	64
#define	ETHER_CRC_LEN	4
@


1.7
log
@Call xxx_init and xxx_stop on activate.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.6 1999/08/16 08:27:15 fgsch Exp $	*/
a269 5

#if NBPFILTER > 0
	bpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
		sizeof(struct ether_header));
#endif
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.8 2001/02/20 19:39:36 mickey Exp $	*/
d270 5
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.7.2.1 2001/05/14 22:24:14 niklas Exp $	*/
d135 2
d184 5
d258 1
a258 2
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
	IFQ_SET_READY(&ifp->if_snd);
d490 1
a490 2
	IFQ_POLL(&ifp->if_snd, m);
	if (m == NULL)
d509 1
a509 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d586 1
a586 1
	IFQ_DEQUEUE(&ifp->if_snd, m);
d856 1
d922 1
d942 7
a948 2
	m->m_pkthdr.len = m->m_len = packetlen;
	ether_input_mbuf(ifp, m);
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.7.2.2 2001/07/04 10:41:10 niklas Exp $	*/
d251 1
@


1.7.2.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d167 2
a168 2
int	smc91cxx_mediachange(struct ifnet *);
void	smc91cxx_mediastatus(struct ifnet *, struct ifmediareq *);
d170 1
a170 1
int	smc91cxx_set_media(struct smc91cxx_softc *, int);
d172 6
a177 6
void	smc91cxx_read(struct smc91cxx_softc *);
void	smc91cxx_reset(struct smc91cxx_softc *);
void	smc91cxx_start(struct ifnet *);
void	smc91cxx_resume(struct smc91cxx_softc *);
void	smc91cxx_watchdog(struct ifnet *);
int	smc91cxx_ioctl(struct ifnet *, u_long, caddr_t);
d179 2
a180 2
int	smc91cxx_enable(struct smc91cxx_softc *);
void	smc91cxx_disable(struct smc91cxx_softc *);
d182 1
a182 1
static __inline int ether_cmp(void *, void *);
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d135 1
d154 1
d978 3
a980 3
			smc91cxx_init(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
@


1.7.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d360 1
a360 1
	 * This resets the registers mostly to defaults, but doesn't
@


1.7.2.7
log
@Merge with the trunk
@
text
@d126 1
@


1.6
log
@Remove netbsd ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.5 1999/08/16 02:23:55 fgsch Exp $	*/
a173 1
void	smc91cxx_init __P((struct smc91cxx_softc *));
a177 1
void	smc91cxx_stop __P((struct smc91cxx_softc *));
@


1.5
log
@Only print revision if SMC_DEBUG is defined. Shorten dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.4 1999/08/08 21:46:15 niklas Exp $	*/
a100 3
#ifdef __NetBSD__
#include <net/if_ether.h>
#endif
a104 3
#ifdef __NetBSD__
#include <netinet/if_inarp.h>
#else
a105 1
#endif
a207 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a208 1
#endif
d212 1
a215 4
#ifdef __NetBSD__
	u_int8_t enaddr[ETHER_ADDR_LEN];
#endif
	int i, aui;
a234 3
#ifdef __NetBSD__
		myea = enaddr;
#endif
a236 4
#ifdef __NetBSD__
			myea[i + 1] = (tmp >> 8) & 0xff;
			myea[i] = tmp & 0xff;
#else
a238 1
#endif
a239 3
#ifdef __NetBSD__
	}
#else
d243 1
a243 1
#endif
a244 3
#ifdef __NetBSD__
	    ether_sprintf(myea));
#else
a245 1
#endif
a263 3
#ifdef __NetBSD__
	ether_ifattach(ifp, myea);
#else
a264 1
#endif
a366 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a367 1
#endif
a370 3
#ifdef __NetBSD__
	u_int8_t *enaddr;
#endif
a391 7
#ifdef __NetBSD__
	enaddr = (u_int8_t *)LLADDR(ifp->if_sadl);
	for (i = 0; i < ETHER_ADDR_LEN; i += 2) {
		tmp = enaddr[i + 1] << 8 | enaddr[i];
		bus_space_write_2(bst, bsh, IAR_ADDR0_REG_W + i, tmp);
	}
#else
a394 1
#endif
a666 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a667 1
#endif
a859 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a860 1
#endif
a998 3
#ifdef __NetBSD__
		arp_ifinit(ifp, ifa);
#else
a999 1
#endif
a1077 4
#ifdef __NetBSD__
		    ether_addmulti(ifr, &sc->sc_ec) :
		    ether_delmulti(ifr, &sc->sc_ec);
#else
a1079 1
#endif
a1128 3
#ifdef __NetBSD__
	ifp->if_oerrors++;
#else
a1129 1
#endif
a1159 3
#ifdef __NetBSD__
	sc->sc_ec.ec_if.if_timer = 0;
#else
a1160 1
#endif
@


1.4
log
@These all are backends for interfaces that can be attached late, whence
ifinit can not set their ifq_maxlen, so do it ourselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.3 1999/02/28 03:23:37 jason Exp $	*/
d144 1
d163 1
d222 2
d225 1
a225 1
	u_int16_t tmp;
d234 1
d244 1
d269 1
a269 1
	printf("%s: MAC address %s, ", sc->sc_dev.dv_xname,
d278 2
a279 2
	printf("default media %s\n", (aui = (tmp & CR_AUI_SELECT)) ?
	    "AUI" : "UTP");
@


1.3
log
@compensate for the test of packet ownership being moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.2 1998/09/12 07:48:07 fgsch Exp $	*/
d283 1
@


1.2
log
@if_media support.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc91cxx.c,v 1.1 1998/09/11 06:55:27 fgsch Exp $	*/
d994 1
a994 1
	if (ifp->if_bpf) {
a995 12

		if ((ifp->if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 &&	/* !mcast and !bcast */
#ifdef __NetBSD__
		    ether_cmp(eh->ether_dhost, LLADDR(ifp->if_sadl))) {
#else
		    ether_cmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr)) {
#endif
			m_freem(m);
			goto out;
		}
	}
@


1.1
log
@Support for the SMC 91Cxx family of ethernet chips from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
a104 1
#endif
a162 1
#ifdef __NetBSD__
a168 1
#endif
a173 1
#ifdef __NetBSD__
a177 1
#endif
a291 1
#ifdef __NetBSD__
a297 1
#endif
a308 1
#ifdef __NetBSD__
a384 1
#endif
d395 2
a397 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a460 1
#ifdef __NetBSD__
a461 1
#endif
a1159 1
#ifdef __NetBSD__
a1163 1
#endif
@

