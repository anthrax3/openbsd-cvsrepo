head	1.167;
access;
symbols
	OPENBSD_6_1:1.167.0.2
	OPENBSD_6_1_BASE:1.167
	OPENBSD_6_0:1.166.0.4
	OPENBSD_6_0_BASE:1.166
	OPENBSD_5_9:1.165.0.2
	OPENBSD_5_9_BASE:1.165
	OPENBSD_5_8:1.162.0.4
	OPENBSD_5_8_BASE:1.162
	OPENBSD_5_7:1.159.0.2
	OPENBSD_5_7_BASE:1.159
	OPENBSD_5_6:1.156.0.4
	OPENBSD_5_6_BASE:1.156
	OPENBSD_5_5:1.154.0.4
	OPENBSD_5_5_BASE:1.154
	OPENBSD_5_4:1.151.0.4
	OPENBSD_5_4_BASE:1.151
	OPENBSD_5_3:1.151.0.2
	OPENBSD_5_3_BASE:1.151
	OPENBSD_5_2:1.150.0.4
	OPENBSD_5_2_BASE:1.150
	OPENBSD_5_1_BASE:1.150
	OPENBSD_5_1:1.150.0.6
	OPENBSD_5_0:1.150.0.2
	OPENBSD_5_0_BASE:1.150
	OPENBSD_4_9:1.149.0.2
	OPENBSD_4_9_BASE:1.149
	OPENBSD_4_8:1.148.0.2
	OPENBSD_4_8_BASE:1.148
	OPENBSD_4_7:1.146.0.2
	OPENBSD_4_7_BASE:1.146
	OPENBSD_4_6:1.144.0.4
	OPENBSD_4_6_BASE:1.144
	OPENBSD_4_5:1.143.0.2
	OPENBSD_4_5_BASE:1.143
	OPENBSD_4_4:1.140.0.2
	OPENBSD_4_4_BASE:1.140
	OPENBSD_4_3:1.138.0.2
	OPENBSD_4_3_BASE:1.138
	OPENBSD_4_2:1.137.0.4
	OPENBSD_4_2_BASE:1.137
	OPENBSD_4_1:1.137.0.2
	OPENBSD_4_1_BASE:1.137
	OPENBSD_4_0:1.134.0.2
	OPENBSD_4_0_BASE:1.134
	OPENBSD_3_9:1.126.0.2
	OPENBSD_3_9_BASE:1.126
	OPENBSD_3_8:1.119.0.2
	OPENBSD_3_8_BASE:1.119
	OPENBSD_3_7:1.116.0.2
	OPENBSD_3_7_BASE:1.116
	OPENBSD_3_6:1.111.0.2
	OPENBSD_3_6_BASE:1.111
	SMP_SYNC_A:1.109
	SMP_SYNC_B:1.109
	OPENBSD_3_5:1.108.0.2
	OPENBSD_3_5_BASE:1.108
	OPENBSD_3_4:1.98.0.2
	OPENBSD_3_4_BASE:1.98
	UBC_SYNC_A:1.95
	OPENBSD_3_3:1.94.0.2
	OPENBSD_3_3_BASE:1.94
	OPENBSD_3_2:1.79.0.2
	OPENBSD_3_2_BASE:1.79
	OPENBSD_3_1:1.53.0.2
	OPENBSD_3_1_BASE:1.53
	UBC_SYNC_B:1.88
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	SMP:1.15.0.2;
locks; strict;
comment	@ * @;


1.167
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.166;
commitid	VyLWTsbepAOk7VQM;

1.166
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.165;
commitid	QHiEhS9DHyE6oiIr;

1.165
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.164;
commitid	B0kwmVGiD5DVx4kv;

1.164
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.163;
commitid	p0v5tuE1Ch6fY0Nj;

1.163
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.162;
commitid	6vhYvh5CxZAHMnsN;

1.162
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.161;
commitid	MVWrtktB46JRxFWT;

1.161
date	2015.05.19.11.34.30;	author mpi;	state Exp;
branches;
next	1.160;
commitid	mPf9He2UCnJ9Pi86;

1.160
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.159;
commitid	p4LJxGKbi0BU2cG6;

1.159
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.158;
commitid	yM2VFFhpDTeFQlve;

1.158
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.157;
commitid	Z1vcFtHO8wRH0yRt;

1.157
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.156;
commitid	uzzBR7hz9ncd4O6G;

1.156
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.155;
commitid	TGHgrLxu6sxZoiFt;

1.155
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.154;
commitid	I19imNlAX05zJOED;

1.154
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.153;

1.153
date	2013.10.01.19.33.49;	author kettenis;	state Exp;
branches;
next	1.152;

1.152
date	2013.08.07.01.06.29;	author bluhm;	state Exp;
branches;
next	1.151;

1.151
date	2012.11.29.21.10.31;	author brad;	state Exp;
branches;
next	1.150;

1.150
date	2011.06.21.16.52.45;	author tedu;	state Exp;
branches;
next	1.149;

1.149
date	2010.08.30.20.42.27;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2010.07.02.02.40.15;	author blambert;	state Exp;
branches;
next	1.147;

1.147
date	2010.05.20.14.03.05;	author nicm;	state Exp;
branches;
next	1.146;

1.146
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.144;

1.144
date	2009.06.03.20.35.37;	author beck;	state Exp;
branches;
next	1.143;

1.143
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.142;

1.142
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.141;

1.141
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.140;

1.140
date	2008.04.18.09.16.14;	author djm;	state Exp;
branches;
next	1.139;

1.139
date	2008.04.17.19.26.51;	author damien;	state Exp;
branches;
next	1.138;

1.138
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.137;

1.137
date	2006.11.26.19.46.28;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2006.11.21.23.00.16;	author miod;	state Exp;
branches;
next	1.135;

1.135
date	2006.11.06.10.49.01;	author jsg;	state Exp;
branches;
next	1.134;

1.134
date	2006.08.17.20.36.35;	author deraadt;	state Exp;
branches;
next	1.133;

1.133
date	2006.07.01.20.22.22;	author reyk;	state Exp;
branches;
next	1.132;

1.132
date	2006.07.01.19.30.51;	author reyk;	state Exp;
branches;
next	1.131;

1.131
date	2006.06.27.20.55.51;	author reyk;	state Exp;
branches;
next	1.130;

1.130
date	2006.06.27.09.48.02;	author reyk;	state Exp;
branches;
next	1.129;

1.129
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.128;

1.128
date	2006.04.10.00.58.52;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.126;

1.126
date	2005.12.03.21.11.47;	author brad;	state Exp;
branches;
next	1.125;

1.125
date	2005.11.28.00.17.14;	author jsg;	state Exp;
branches;
next	1.124;

1.124
date	2005.11.01.03.10.21;	author jsg;	state Exp;
branches;
next	1.123;

1.123
date	2005.10.31.05.37.12;	author jsg;	state Exp;
branches;
next	1.122;

1.122
date	2005.10.19.20.04.43;	author fgsch;	state Exp;
branches;
next	1.121;

1.121
date	2005.10.15.00.20.49;	author fgsch;	state Exp;
branches;
next	1.120;

1.120
date	2005.09.18.09.24.03;	author jsg;	state Exp;
branches;
next	1.119;

1.119
date	2005.07.31.23.08.58;	author pascoe;	state Exp;
branches;
next	1.118;

1.118
date	2005.07.12.17.23.19;	author jsg;	state Exp;
branches;
next	1.117;

1.117
date	2005.04.03.08.07.00;	author uwe;	state Exp;
branches;
next	1.116;

1.116
date	2005.02.15.19.44.15;	author reyk;	state Exp;
branches;
next	1.115;

1.115
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.114;

1.114
date	2004.12.22.02.19.11;	author millert;	state Exp;
branches;
next	1.113;

1.113
date	2004.11.23.21.12.23;	author fgsch;	state Exp;
branches;
next	1.112;

1.112
date	2004.10.20.12.53.28;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2004.08.16.03.42.22;	author millert;	state Exp;
branches;
next	1.110;

1.110
date	2004.06.22.20.48.00;	author millert;	state Exp;
branches;
next	1.109;

1.109
date	2004.05.31.19.32.30;	author mcbride;	state Exp;
branches;
next	1.108;

1.108
date	2004.03.18.16.16.10;	author millert;	state Exp;
branches;
next	1.107;

1.107
date	2004.03.15.21.50.26;	author millert;	state Exp;
branches;
next	1.106;

1.106
date	2004.03.12.20.50.45;	author millert;	state Exp;
branches;
next	1.105;

1.105
date	2004.03.02.21.59.29;	author millert;	state Exp;
branches;
next	1.104;

1.104
date	2004.03.02.21.55.07;	author millert;	state Exp;
branches;
next	1.103;

1.103
date	2004.02.27.21.34.58;	author millert;	state Exp;
branches;
next	1.102;

1.102
date	2003.12.05.02.23.42;	author drahn;	state Exp;
branches;
next	1.101;

1.101
date	2003.10.26.15.34.15;	author drahn;	state Exp;
branches;
next	1.100;

1.100
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.99;

1.99
date	2003.10.07.07.08.45;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2003.09.06.20.53.57;	author drahn;	state Exp;
branches;
next	1.97;

1.97
date	2003.08.15.20.32.17;	author tedu;	state Exp;
branches;
next	1.96;

1.96
date	2003.06.07.21.14.42;	author mickey;	state Exp;
branches;
next	1.95;

1.95
date	2003.04.26.08.01.42;	author jmc;	state Exp;
branches;
next	1.94;

1.94
date	2003.03.10.00.59.54;	author millert;	state Exp;
branches;
next	1.93;

1.93
date	2003.02.13.20.45.09;	author millert;	state Exp;
branches;
next	1.92;

1.92
date	2003.02.12.21.49.05;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2003.01.23.19.27.19;	author mickey;	state Exp;
branches;
next	1.90;

1.90
date	2003.01.21.16.26.40;	author millert;	state Exp;
branches;
next	1.89;

1.89
date	2003.01.10.21.38.02;	author millert;	state Exp;
branches;
next	1.88;

1.88
date	2002.10.27.16.20.48;	author millert;	state Exp;
branches;
next	1.87;

1.87
date	2002.10.27.14.46.30;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2002.10.18.03.46.35;	author fgsch;	state Exp;
branches;
next	1.85;

1.85
date	2002.10.18.03.35.56;	author fgsch;	state Exp;
branches;
next	1.84;

1.84
date	2002.10.11.15.31.25;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2002.10.11.15.04.44;	author millert;	state Exp;
branches;
next	1.82;

1.82
date	2002.10.11.13.31.49;	author millert;	state Exp;
branches;
next	1.81;

1.81
date	2002.10.10.20.27.46;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2002.10.04.02.29.36;	author millert;	state Exp;
branches;
next	1.79;

1.79
date	2002.08.30.08.19.49;	author fgsch;	state Exp;
branches;
next	1.78;

1.78
date	2002.08.30.08.08.22;	author fgsch;	state Exp;
branches;
next	1.77;

1.77
date	2002.08.13.03.49.51;	author millert;	state Exp;
branches;
next	1.76;

1.76
date	2002.08.08.18.53.10;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2002.07.16.13.46.43;	author fgsch;	state Exp;
branches;
next	1.74;

1.74
date	2002.07.10.20.21.16;	author fgsch;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.24.17.59.09;	author fgsch;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.22.16.14.14;	author fgsch;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.21.20.15.37;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.21.06.56.24;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.21.06.50.37;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.21.06.46.26;	author fgsch;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.15.18.49.04;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.14.03.58.45;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.12.04.43.41;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.03.21.53.58;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.02.16.11.41;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.31.19.27.40;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2002.04.30.22.56.33;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2002.04.26.21.27.27;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2002.04.26.21.19.18;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2002.04.26.19.20.27;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2002.04.23.22.25.29;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2002.04.21.02.16.52;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2002.04.16.00.18.21;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.11.02.11.19;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2002.04.11.00.08.25;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.04.10.19.25.07;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2002.04.08.18.31.27;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2002.04.07.23.23.49;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.04.06.23.48.38;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2002.04.06.21.58.12;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.04.06.20.31.56;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2002.04.05.15.35.34;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.04.18.44.35;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.04.03.21.52.08;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.04.02.21.47.26;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2002.04.02.08.44.57;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2002.04.02.06.01.44;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2002.04.02.00.31.59;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2002.04.01.20.42.18;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2002.04.01.20.38.36;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.04.01.18.55.05;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.01.07.12.05;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.31.01.01.44;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.31.00.33.42;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.30.22.43.58;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.30.20.23.28;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.30.20.18.45;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.30.18.52.08;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.30.18.49.28;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.30.00.15.24;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.29.02.43.34;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.28.18.21.06;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.28.17.41.02;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.26.18.59.11;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.20.21.51.07;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.20.20.52.42;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.19.01.24.58;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.21.15.48.19;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.25.16.39.25;	author mickey;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.07.08.23.38.05;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.27.06.34.42;	author kjc;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.06.25.19.36.13;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.25.19.33.09;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.25.18.04.22;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.23.22.54.17;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.11.01.10.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.11.00.50.38;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.10.05.35.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.09.20.17.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.09.03.45.15;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.07.18.51.59;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.07.06.04.45;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.07.04.49.07;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.06.18.56.24;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.15.02.40.35;	author millert;	state Exp;
branches;
next	;

1.15.2.1
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2003.05.13.19.35.00;	author ho;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	1.15.2.7;

1.15.2.7
date	2004.06.05.23.12.42;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.167
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_wi.c,v 1.166 2016/04/13 10:49:26 mpi Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	From: if_wi.c,v 1.7 1999/07/04 14:40:22 wpaul Exp $
 */

/*
 * Lucent WaveLAN/IEEE 802.11 driver for OpenBSD.
 *
 * Originally written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The WaveLAN/IEEE adapter is the second generation of the WaveLAN
 * from Lucent. Unlike the older cards, the new ones are programmed
 * entirely via a firmware-driven controller called the Hermes.
 * Unfortunately, Lucent will not release the Hermes programming manual
 * without an NDA (if at all). What they do release is an API library
 * called the HCF (Hardware Control Functions) which is supposed to
 * do the device-specific operations of a device driver for you. The
 * publicly available version of the HCF library (the 'HCF Light') is
 * a) extremely gross, b) lacks certain features, particularly support
 * for 802.11 frames, and c) is contaminated by the GNU Public License.
 *
 * This driver does not use the HCF or HCF Light at all. Instead, it
 * programs the Hermes controller directly, using information gleaned
 * from the HCF Light code and corresponding documentation.
 */

#define WI_HERMES_AUTOINC_WAR	/* Work around data write autoinc bug. */
#define WI_HERMES_STATS_WAR	/* Work around stats counter bug. */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_ioctl.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <dev/ic/if_wireg.h>
#include <dev/ic/if_wi_ieee.h>
#include <dev/ic/if_wivar.h>

#include <crypto/arc4.h>

#define BPFATTACH(if_bpf,if,dlt,sz)
#define STATIC

#ifdef WIDEBUG

u_int32_t	widebug = WIDEBUG;

#define WID_INTR	0x01
#define WID_START	0x02
#define WID_IOCTL	0x04
#define WID_INIT	0x08
#define WID_STOP	0x10
#define WID_RESET	0x20

#define DPRINTF(mask,args) if (widebug & (mask)) printf args;

#else	/* !WIDEBUG */
#define DPRINTF(mask,args)
#endif	/* WIDEBUG */

#ifdef foo
static u_int8_t	wi_mcast_addr[6] = { 0x01, 0x60, 0x1D, 0x00, 0x01, 0x00 };
#endif

STATIC void wi_reset(struct wi_softc *);
STATIC int wi_ioctl(struct ifnet *, u_long, caddr_t);
STATIC void wi_init_io(struct wi_softc *);
STATIC void wi_start(struct ifnet *);
STATIC void wi_watchdog(struct ifnet *);
STATIC void wi_rxeof(struct wi_softc *);
STATIC void wi_txeof(struct wi_softc *, int);
STATIC void wi_update_stats(struct wi_softc *);
STATIC void wi_setmulti(struct wi_softc *);

STATIC int wi_cmd_io(struct wi_softc *, int, int, int, int);
STATIC int wi_read_record_io(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_write_record_io(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_read_data_io(struct wi_softc *, int,
					int, caddr_t, int);
STATIC int wi_write_data_io(struct wi_softc *, int,
					int, caddr_t, int);
STATIC int wi_seek(struct wi_softc *, int, int, int);

STATIC void wi_inquire(void *);
STATIC int wi_setdef(struct wi_softc *, struct wi_req *);
STATIC void wi_get_id(struct wi_softc *);

STATIC int wi_media_change(struct ifnet *);
STATIC void wi_media_status(struct ifnet *, struct ifmediareq *);

STATIC int wi_set_ssid(struct ieee80211_nwid *, u_int8_t *, int);
STATIC int wi_set_nwkey(struct wi_softc *, struct ieee80211_nwkey *);
STATIC int wi_get_nwkey(struct wi_softc *, struct ieee80211_nwkey *);
STATIC int wi_sync_media(struct wi_softc *, int, int);
STATIC int wi_set_pm(struct wi_softc *, struct ieee80211_power *);
STATIC int wi_get_pm(struct wi_softc *, struct ieee80211_power *);
STATIC int wi_set_txpower(struct wi_softc *, struct ieee80211_txpower *);
STATIC int wi_get_txpower(struct wi_softc *, struct ieee80211_txpower *);

STATIC int wi_get_debug(struct wi_softc *, struct wi_req *);
STATIC int wi_set_debug(struct wi_softc *, struct wi_req *);

STATIC void wi_do_hostencrypt(struct wi_softc *, caddr_t, int);                
STATIC int wi_do_hostdecrypt(struct wi_softc *, caddr_t, int);

STATIC int wi_alloc_nicmem_io(struct wi_softc *, int, int *);
STATIC int wi_get_fid_io(struct wi_softc *sc, int fid);
STATIC void wi_intr_enable(struct wi_softc *sc, int mode);
STATIC void wi_intr_ack(struct wi_softc *sc, int mode);
void	 wi_scan_timeout(void *);

/* Autoconfig definition of driver back-end */
struct cfdriver wi_cd = {
	NULL, "wi", DV_IFNET
};

const struct wi_card_ident wi_card_ident[] = {
	WI_CARD_IDS
};

struct wi_funcs wi_func_io = {
        wi_cmd_io,
        wi_read_record_io,
        wi_write_record_io,
        wi_alloc_nicmem_io,
        wi_read_data_io,
        wi_write_data_io,
        wi_get_fid_io,
        wi_init_io,

        wi_start,
        wi_ioctl,
        wi_watchdog,
        wi_inquire,
};

int
wi_attach(struct wi_softc *sc, struct wi_funcs *funcs)
{
	struct ieee80211com	*ic;
	struct ifnet		*ifp;
	struct wi_ltv_macaddr	mac;
	struct wi_ltv_rates	rates;
	struct wi_ltv_gen	gen;
	int			error;

	ic = &sc->sc_ic;
	ifp = &ic->ic_if;

	sc->sc_funcs = funcs;
	sc->wi_cmd_count = 500;

	wi_reset(sc);

	/* Read the station address. */
	mac.wi_type = WI_RID_MAC_NODE;
	mac.wi_len = 4;
	error = wi_read_record(sc, (struct wi_ltv_gen *)&mac);
	if (error) {
		printf(": unable to read station address\n");
		return (error);
	}
	bcopy(&mac.wi_mac_addr, &ic->ic_myaddr, IEEE80211_ADDR_LEN);

	wi_get_id(sc);
	printf("address %s", ether_sprintf(ic->ic_myaddr));

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = funcs->f_ioctl;
	ifp->if_start = funcs->f_start;
	ifp->if_watchdog = funcs->f_watchdog;

	(void)wi_set_ssid(&sc->wi_node_name, WI_DEFAULT_NODENAME,
	    sizeof(WI_DEFAULT_NODENAME) - 1);
	(void)wi_set_ssid(&sc->wi_net_name, WI_DEFAULT_NETNAME,
	    sizeof(WI_DEFAULT_NETNAME) - 1);
	(void)wi_set_ssid(&sc->wi_ibss_name, WI_DEFAULT_IBSS,
	    sizeof(WI_DEFAULT_IBSS) - 1);

	sc->wi_portnum = WI_DEFAULT_PORT;
	sc->wi_ptype = WI_PORTTYPE_BSS;
	sc->wi_ap_density = WI_DEFAULT_AP_DENSITY;
	sc->wi_rts_thresh = WI_DEFAULT_RTS_THRESH;
	sc->wi_tx_rate = WI_DEFAULT_TX_RATE;
	sc->wi_max_data_len = WI_DEFAULT_DATALEN;
	sc->wi_create_ibss = WI_DEFAULT_CREATE_IBSS;
	sc->wi_pm_enabled = WI_DEFAULT_PM_ENABLED;
	sc->wi_max_sleep = WI_DEFAULT_MAX_SLEEP;
	sc->wi_roaming = WI_DEFAULT_ROAMING;
	sc->wi_authtype = WI_DEFAULT_AUTHTYPE;
	sc->wi_diversity = WI_DEFAULT_DIVERSITY;
	sc->wi_crypto_algorithm = WI_CRYPTO_FIRMWARE_WEP;

	/*
	 * Read the default channel from the NIC. This may vary
	 * depending on the country where the NIC was purchased, so
	 * we can't hard-code a default and expect it to work for
	 * everyone.
	 */
	gen.wi_type = WI_RID_OWN_CHNL;
	gen.wi_len = 2;
	if (wi_read_record(sc, &gen) == 0)
		sc->wi_channel = letoh16(gen.wi_val);
	else
		sc->wi_channel = 3;

	/*
	 * Set flags based on firmware version.
	 */
	switch (sc->sc_firmware_type) {
	case WI_LUCENT:
		sc->wi_flags |= WI_FLAGS_HAS_ROAMING;
		if (sc->sc_sta_firmware_ver >= 60000)
			sc->wi_flags |= WI_FLAGS_HAS_MOR;
		if (sc->sc_sta_firmware_ver >= 60006) {
			sc->wi_flags |= WI_FLAGS_HAS_IBSS;
			sc->wi_flags |= WI_FLAGS_HAS_CREATE_IBSS;
		}
		sc->wi_ibss_port = htole16(1);
		break;
	case WI_INTERSIL:
		sc->wi_flags |= WI_FLAGS_HAS_ROAMING;
		/* older prism firmware is slow so crank the count */
		if (sc->sc_sta_firmware_ver < 10000)
			sc->wi_cmd_count = 5000;
		else
			sc->wi_cmd_count = 2000;
		if (sc->sc_sta_firmware_ver >= 800) {
#ifndef SMALL_KERNEL
			/*
			 * USB hostap is more pain than it is worth
			 * for now, things would have to be overhauled
			 */
			if ((sc->sc_sta_firmware_ver != 10402) &&
			    (!(sc->wi_flags & WI_FLAGS_BUS_USB)))
				sc->wi_flags |= WI_FLAGS_HAS_HOSTAP;
#endif
			sc->wi_flags |= WI_FLAGS_HAS_IBSS;
			sc->wi_flags |= WI_FLAGS_HAS_CREATE_IBSS;
		}
		if (sc->sc_sta_firmware_ver >= 10603)
			sc->wi_flags |= WI_FLAGS_HAS_ENH_SECURITY;
		sc->wi_ibss_port = htole16(0);
		break;
	case WI_SYMBOL:
		sc->wi_flags |= WI_FLAGS_HAS_DIVERSITY;
		if (sc->sc_sta_firmware_ver >= 20000)
			sc->wi_flags |= WI_FLAGS_HAS_IBSS;
		if (sc->sc_sta_firmware_ver >= 25000)
			sc->wi_flags |= WI_FLAGS_HAS_CREATE_IBSS;
		sc->wi_ibss_port = htole16(4);
		break;
	}

	/*
	 * Find out if we support WEP on this card.
	 */
	gen.wi_type = WI_RID_WEP_AVAIL;
	gen.wi_len = 2;
	if (wi_read_record(sc, &gen) == 0 && gen.wi_val != htole16(0))
		sc->wi_flags |= WI_FLAGS_HAS_WEP;
	timeout_set(&sc->sc_timo, funcs->f_inquire, sc);

	bzero(&sc->wi_stats, sizeof(sc->wi_stats));

	/* Find supported rates. */
	rates.wi_type = WI_RID_DATA_RATES;
	rates.wi_len = sizeof(rates.wi_rates);
	if (wi_read_record(sc, (struct wi_ltv_gen *)&rates) == 0) {
		int i, nrates;

		nrates = letoh16(*(u_int16_t *)rates.wi_rates);
		if (nrates > sizeof(rates.wi_rates) - 2)
			nrates = sizeof(rates.wi_rates) - 2;

		sc->wi_supprates = 0;
		for (i = 0; i < nrates; i++)
			sc->wi_supprates |= rates.wi_rates[2 + i];
	} else
		sc->wi_supprates = WI_SUPPRATES_1M | WI_SUPPRATES_2M |
		    WI_SUPPRATES_5M | WI_SUPPRATES_11M;

	ifmedia_init(&sc->sc_media, 0, wi_media_change, wi_media_status);
#define	ADD(m, c)	ifmedia_add(&sc->sc_media, (m), (c), NULL)
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, IFM_IEEE80211_ADHOC, 0), 0);
	if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, IFM_IEEE80211_IBSS,
		    0), 0);
	if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
		    IFM_IEEE80211_IBSSMASTER, 0), 0);
	if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
		    IFM_IEEE80211_HOSTAP, 0), 0);
	if (sc->wi_supprates & WI_SUPPRATES_1M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
			    IFM_IEEE80211_HOSTAP, 0), 0);
	}
	if (sc->wi_supprates & WI_SUPPRATES_2M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
			    IFM_IEEE80211_HOSTAP, 0), 0);
	}
	if (sc->wi_supprates & WI_SUPPRATES_5M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
			    IFM_IEEE80211_HOSTAP, 0), 0);
	}
	if (sc->wi_supprates & WI_SUPPRATES_11M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
			    IFM_IEEE80211_HOSTAP, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_MANUAL, 0, 0), 0);
	}
#undef ADD
	ifmedia_set(&sc->sc_media,
	    IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, 0, 0));

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	memcpy(((struct arpcom *)ifp)->ac_enaddr, ic->ic_myaddr,
	    ETHER_ADDR_LEN);
	ether_ifattach(ifp);
	printf("\n");

	sc->wi_flags |= WI_FLAGS_ATTACHED;

#if NBPFILTER > 0
	BPFATTACH(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif

	if_addgroup(ifp, "wlan");
	ifp->if_priority = IF_WIRELESS_DEFAULT_PRIORITY;

	wi_init(sc);
	wi_stop(sc);

	return (0);
}

STATIC void
wi_intr_enable(struct wi_softc *sc, int mode)
{
	if (!(sc->wi_flags & WI_FLAGS_BUS_USB))
		CSR_WRITE_2(sc, WI_INT_EN, mode);
}

STATIC void
wi_intr_ack(struct wi_softc *sc, int mode)
{
	if (!(sc->wi_flags & WI_FLAGS_BUS_USB))
		CSR_WRITE_2(sc, WI_EVENT_ACK, mode);
}

int
wi_intr(void *vsc)
{
	struct wi_softc		*sc = vsc;
	struct ifnet		*ifp;
	u_int16_t		status;

	DPRINTF(WID_INTR, ("wi_intr: sc %p\n", sc));

	ifp = &sc->sc_ic.ic_if;

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED) || !(ifp->if_flags & IFF_UP)) {
		CSR_WRITE_2(sc, WI_INT_EN, 0);
		CSR_WRITE_2(sc, WI_EVENT_ACK, 0xffff);
		return (0);
	}

	/* Disable interrupts. */
	CSR_WRITE_2(sc, WI_INT_EN, 0);

	status = CSR_READ_2(sc, WI_EVENT_STAT);
	CSR_WRITE_2(sc, WI_EVENT_ACK, ~WI_INTRS);

	if (status & WI_EV_RX) {
		wi_rxeof(sc);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_RX);
	}

	if (status & WI_EV_TX) {
		wi_txeof(sc, status);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_TX);
	}

	if (status & WI_EV_ALLOC) {
		int			id;
		id = CSR_READ_2(sc, WI_ALLOC_FID);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);
		if (id == sc->wi_tx_data_id)
			wi_txeof(sc, status);
	}

	if (status & WI_EV_INFO) {
		wi_update_stats(sc);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_INFO);
	}

	if (status & WI_EV_TX_EXC) {
		wi_txeof(sc, status);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_TX_EXC);
	}

	if (status & WI_EV_INFO_DROP) {
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_INFO_DROP);
	}

	/* Re-enable interrupts. */
	CSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);

	if (status == 0)
		return (0);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		wi_start(ifp);

	return (1);
}

STATIC int
wi_get_fid_io(struct wi_softc *sc, int fid)
{
	return CSR_READ_2(sc, fid);
}


void
wi_rxeof(struct wi_softc *sc)
{
	struct ifnet		*ifp;
	struct ether_header	*eh;
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct mbuf		*m;
	caddr_t			olddata;
	u_int16_t		ftype;
	int			maxlen;
	int			id;

	ifp = &sc->sc_ic.ic_if;

	id = wi_get_fid(sc, WI_RX_FID);

	if (sc->wi_procframe || sc->wi_debug.wi_monitor) {
		struct wi_frame	*rx_frame;
		int		datlen, hdrlen;

		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			ifp->if_ierrors++;
			return;
		}
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		if (wi_read_data(sc, id, 0, mtod(m, caddr_t),
		    sizeof(struct wi_frame))) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		rx_frame = mtod(m, struct wi_frame *);

		if (rx_frame->wi_status & htole16(WI_STAT_BADCRC)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		switch ((letoh16(rx_frame->wi_status) & WI_STAT_MAC_PORT)
		    >> 8) {
		case 7:
			switch (letoh16(rx_frame->wi_frame_ctl) &
			    WI_FCTL_FTYPE) {
			case WI_FTYPE_DATA:
				hdrlen = WI_DATA_HDRLEN;
				datlen = letoh16(rx_frame->wi_dat_len);
				break;
			case WI_FTYPE_MGMT:
				hdrlen = WI_MGMT_HDRLEN;
				datlen = letoh16(rx_frame->wi_dat_len);
				break;
			case WI_FTYPE_CTL:
				hdrlen = WI_CTL_HDRLEN;
				datlen = 0;
				break;
			default:
				printf(WI_PRT_FMT ": received packet of "
				    "unknown type on port 7\n", WI_PRT_ARG(sc));
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			break;
		case 0:
			hdrlen = WI_DATA_HDRLEN;
			datlen = letoh16(rx_frame->wi_dat_len);
			break;
		default:
			printf(WI_PRT_FMT ": received packet on invalid port "
			    "(wi_status=0x%x)\n", WI_PRT_ARG(sc),
			    letoh16(rx_frame->wi_status));
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		if ((hdrlen + datlen + 2) > MCLBYTES) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		if (wi_read_data(sc, id, hdrlen, mtod(m, caddr_t) + hdrlen,
		    datlen + 2)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		m->m_pkthdr.len = m->m_len = hdrlen + datlen;
	} else {
		struct wi_frame rx_frame;

		/* First read in the frame header */
		if (wi_read_data(sc, id, 0, (caddr_t)&rx_frame,
		    sizeof(rx_frame))) {
			ifp->if_ierrors++;
			return;
		}

		/* Drop undecryptable or packets with receive errors here */
		if (rx_frame.wi_status & htole16(WI_STAT_ERRSTAT)) {
			ifp->if_ierrors++;
			return;
		}

		/* Stash frame type in host byte order for later use */
		ftype = letoh16(rx_frame.wi_frame_ctl) & WI_FCTL_FTYPE;

		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			ifp->if_ierrors++;
			return;
		}
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		olddata = m->m_data;
		/* Align the data after the ethernet header */
		m->m_data = (caddr_t)ALIGN(m->m_data +
		    sizeof(struct ether_header)) - sizeof(struct ether_header);

		eh = mtod(m, struct ether_header *);
		maxlen = MCLBYTES - (m->m_data - olddata);

		if (ftype == WI_FTYPE_MGMT &&
		    sc->wi_ptype == WI_PORTTYPE_HOSTAP) {

			u_int16_t rxlen = letoh16(rx_frame.wi_dat_len);

			if ((WI_802_11_OFFSET_RAW + rxlen + 2) > maxlen) {
				printf("%s: oversized mgmt packet received in "
				    "hostap mode (wi_dat_len=%d, "
				    "wi_status=0x%x)\n", sc->sc_dev.dv_xname,
				    rxlen, letoh16(rx_frame.wi_status));
				m_freem(m);
				ifp->if_ierrors++;  
				return;
			}

			/* Put the whole header in there. */
			bcopy(&rx_frame, mtod(m, void *),
			    sizeof(struct wi_frame));
			if (wi_read_data(sc, id, WI_802_11_OFFSET_RAW,
			    mtod(m, caddr_t) + WI_802_11_OFFSET_RAW,
			    rxlen + 2)) {
				m_freem(m);
				if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
					printf("wihap: failed to copy header\n");
				ifp->if_ierrors++;
				return;
			}

			m->m_pkthdr.len = m->m_len =
			    WI_802_11_OFFSET_RAW + rxlen;

			/* XXX: consider giving packet to bhp? */

			wihap_mgmt_input(sc, &rx_frame, m);

			return;
		}

		switch (letoh16(rx_frame.wi_status) & WI_RXSTAT_MSG_TYPE) {
		case WI_STAT_1042:
		case WI_STAT_TUNNEL:
		case WI_STAT_WMP_MSG:
			if ((letoh16(rx_frame.wi_dat_len) + WI_SNAPHDR_LEN) >
			    maxlen) {
				printf(WI_PRT_FMT ": oversized packet received "
				    "(wi_dat_len=%d, wi_status=0x%x)\n",
				    WI_PRT_ARG(sc),
				    letoh16(rx_frame.wi_dat_len),
				    letoh16(rx_frame.wi_status));
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			m->m_pkthdr.len = m->m_len =
			    letoh16(rx_frame.wi_dat_len) + WI_SNAPHDR_LEN;

			bcopy(&rx_frame.wi_dst_addr,
			    &eh->ether_dhost, ETHER_ADDR_LEN);
			bcopy(&rx_frame.wi_src_addr,
			    &eh->ether_shost, ETHER_ADDR_LEN);
			bcopy(&rx_frame.wi_type,
			    &eh->ether_type, ETHER_TYPE_LEN);

			if (wi_read_data(sc, id, WI_802_11_OFFSET,
			    mtod(m, caddr_t) + sizeof(struct ether_header),
			    m->m_len + 2)) {
				ifp->if_ierrors++;
				m_freem(m);
				return;
			}
			break;
		default:
			if ((letoh16(rx_frame.wi_dat_len) +
			    sizeof(struct ether_header)) > maxlen) {
				printf(WI_PRT_FMT ": oversized packet received "
				    "(wi_dat_len=%d, wi_status=0x%x)\n",
				    WI_PRT_ARG(sc),
				    letoh16(rx_frame.wi_dat_len),
				    letoh16(rx_frame.wi_status));
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			m->m_pkthdr.len = m->m_len =
			    letoh16(rx_frame.wi_dat_len) +
			    sizeof(struct ether_header);

			if (wi_read_data(sc, id, WI_802_3_OFFSET,
			    mtod(m, caddr_t), m->m_len + 2)) {
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			break;
		}

		if (sc->wi_use_wep &&
		    rx_frame.wi_frame_ctl & htole16(WI_FCTL_WEP)) {
			int len;

			switch (sc->wi_crypto_algorithm) {
			case WI_CRYPTO_FIRMWARE_WEP:
				break;
			case WI_CRYPTO_SOFTWARE_WEP:
				m_copydata(m, 0, m->m_pkthdr.len,
				    (caddr_t)sc->wi_rxbuf);
				len = m->m_pkthdr.len -
				    sizeof(struct ether_header);
				if (wi_do_hostdecrypt(sc, sc->wi_rxbuf +
				    sizeof(struct ether_header), len)) {
					if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
						printf(WI_PRT_FMT ": Error decrypting incoming packet.\n", WI_PRT_ARG(sc));
					m_freem(m);
					ifp->if_ierrors++;  
					return;
				}
				len -= IEEE80211_WEP_IVLEN +
				    IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN;
				/*
				 * copy data back to mbufs:
				 * we need to ditch the IV & most LLC/SNAP stuff
				 * (except SNAP type, we're going use that to
				 * overwrite the ethertype in the ether_header)
				 */
				m_copyback(m, sizeof(struct ether_header) -
				    WI_ETHERTYPE_LEN, WI_ETHERTYPE_LEN +
				    (len - WI_SNAPHDR_LEN),
				    sc->wi_rxbuf + sizeof(struct ether_header) +
				    IEEE80211_WEP_IVLEN +
				    IEEE80211_WEP_KIDLEN + WI_SNAPHDR_LEN,
				    M_NOWAIT);
				m_adj(m, -(WI_ETHERTYPE_LEN +
				    IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
				    WI_SNAPHDR_LEN));
				break;
			}
		}

		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
			/*
			 * Give host AP code first crack at data packets.
			 * If it decides to handle it (or drop it), it will
			 * return a non-zero.  Otherwise, it is destined for
			 * this host.
			 */
			if (wihap_data_input(sc, &rx_frame, m))
				return;
		}
	}

	/* Receive packet unless in procframe or monitor mode. */
	if (sc->wi_procframe || sc->wi_debug.wi_monitor)
		m_freem(m);
	else {
		ml_enqueue(&ml, m);
		if_input(ifp, &ml);
	}

	return;
}

void
wi_txeof(struct wi_softc *sc, int status)
{
	struct ifnet		*ifp;

	ifp = &sc->sc_ic.ic_if;

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (status & WI_EV_TX_EXC)
		ifp->if_oerrors++;

	return;
}

void
wi_inquire(void *xsc)
{
	struct wi_softc		*sc;
	struct ifnet		*ifp;
	int s, rv;

	sc = xsc;
	ifp = &sc->sc_ic.ic_if;

	timeout_add_sec(&sc->sc_timo, 60);

	/* Don't do this while we're transmitting */
	if (ifq_is_oactive(&ifp->if_snd))
		return;

	s = splnet();
	rv = wi_cmd(sc, WI_CMD_INQUIRE, WI_INFO_COUNTERS, 0, 0);
	splx(s);
	if (rv)
		printf(WI_PRT_FMT ": wi_cmd failed with %d\n", WI_PRT_ARG(sc),
		    rv);

	return;
}

void
wi_update_stats(struct wi_softc *sc)
{
	struct wi_ltv_gen	gen;
	u_int16_t		id;
	struct ifnet		*ifp;
	u_int32_t		*ptr;
	int			len, i;
	u_int16_t		t;

	ifp = &sc->sc_ic.ic_if;

	id = wi_get_fid(sc, WI_INFO_FID);

	wi_read_data(sc, id, 0, (char *)&gen, 4);

	if (gen.wi_type == htole16(WI_INFO_SCAN_RESULTS)) {
		sc->wi_scanbuf_len = letoh16(gen.wi_len);
		wi_read_data(sc, id, 4, (caddr_t)sc->wi_scanbuf,
		    sc->wi_scanbuf_len * 2);
		return;
	} else if (gen.wi_type != htole16(WI_INFO_COUNTERS))
		return;

	/* Some card versions have a larger stats structure */
	len = (letoh16(gen.wi_len) - 1 < sizeof(sc->wi_stats) / 4) ?
	    letoh16(gen.wi_len) - 1 : sizeof(sc->wi_stats) / 4;

	ptr = (u_int32_t *)&sc->wi_stats;

	for (i = 0; i < len; i++) {
		if (sc->wi_flags & WI_FLAGS_BUS_USB) {
			wi_read_data(sc, id, 4 + i*2, (char *)&t, 2);
			t = letoh16(t);
		} else 
			t = CSR_READ_2(sc, WI_DATA1);
#ifdef WI_HERMES_STATS_WAR
		if (t > 0xF000)
			t = ~t & 0xFFFF;
#endif
		ptr[i] += t;
	}

	ifp->if_collisions = sc->wi_stats.wi_tx_single_retries +
	    sc->wi_stats.wi_tx_multi_retries +
	    sc->wi_stats.wi_tx_retry_limit;

	return;
}

STATIC int
wi_cmd_io(struct wi_softc *sc, int cmd, int val0, int val1, int val2)
{
	int			i, s = 0;

	/* Wait for the busy bit to clear. */
	for (i = sc->wi_cmd_count; i--; DELAY(1000)) {
		if (!(CSR_READ_2(sc, WI_COMMAND) & WI_CMD_BUSY))
			break;
	}
	if (i < 0) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf(WI_PRT_FMT ": wi_cmd_io: busy bit won't clear\n",
			    WI_PRT_ARG(sc));
		return(ETIMEDOUT);
	}

	CSR_WRITE_2(sc, WI_PARAM0, val0);
	CSR_WRITE_2(sc, WI_PARAM1, val1);
	CSR_WRITE_2(sc, WI_PARAM2, val2);
	CSR_WRITE_2(sc, WI_COMMAND, cmd);

	for (i = WI_TIMEOUT; i--; DELAY(WI_DELAY)) {
		/*
		 * Wait for 'command complete' bit to be
		 * set in the event status register.
		 */
		s = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;
		if (s) {
			/* Ack the event and read result code. */
			s = CSR_READ_2(sc, WI_STATUS);
			CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);
			if (s & WI_STAT_CMD_RESULT)
				return(EIO);
			break;
		}
	}

	if (i < 0) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf(WI_PRT_FMT
			    ": timeout in wi_cmd 0x%04x; event status 0x%04x\n",
			    WI_PRT_ARG(sc), cmd, s);
		return(ETIMEDOUT);
	}

	return(0);
}

STATIC void
wi_reset(struct wi_softc *sc)
{
	int error, tries = 3;

	DPRINTF(WID_RESET, ("wi_reset: sc %p\n", sc));

	/* Symbol firmware cannot be initialized more than once. */
	if (sc->sc_firmware_type == WI_SYMBOL) {
		if (sc->wi_flags & WI_FLAGS_INITIALIZED)
			return;
		tries = 1;
	}

	for (; tries--; DELAY(WI_DELAY * 1000)) {
		if ((error = wi_cmd(sc, WI_CMD_INI, 0, 0, 0)) == 0)
			break;
	}
	if (tries < 0) {
		printf(WI_PRT_FMT ": init failed\n", WI_PRT_ARG(sc));
		return;
	}
	sc->wi_flags |= WI_FLAGS_INITIALIZED;

	wi_intr_enable(sc, 0);
	wi_intr_ack(sc, 0xffff);

	/* Calibrate timer. */
	WI_SETVAL(WI_RID_TICK_TIME, 8);

	return;
}

STATIC void
wi_cor_reset(struct wi_softc *sc)
{
	u_int8_t cor_value;

	DPRINTF(WID_RESET, ("wi_cor_reset: sc %p\n", sc));

	/*
	 * Do a soft reset of the card; this is required for Symbol cards.
	 * This shouldn't hurt other cards but there have been reports
	 * of the COR reset messing up old Lucent firmware revisions so
	 * we avoid soft reset on Lucent cards for now.
	 */
	if (sc->sc_firmware_type != WI_LUCENT) {
		cor_value = bus_space_read_1(sc->wi_ltag, sc->wi_lhandle,
		    sc->wi_cor_offset);
		bus_space_write_1(sc->wi_ltag, sc->wi_lhandle,
		    sc->wi_cor_offset, (cor_value | WI_COR_SOFT_RESET));
		DELAY(1000);
		bus_space_write_1(sc->wi_ltag, sc->wi_lhandle,
		    sc->wi_cor_offset, (cor_value & ~WI_COR_SOFT_RESET));
		DELAY(1000);
	}

	return;
}

/*
 * Read an LTV record from the NIC.
 */
STATIC int
wi_read_record_io(struct wi_softc *sc, struct wi_ltv_gen *ltv)
{
	u_int8_t		*ptr;
	int			len, code;
	struct wi_ltv_gen	*oltv, p2ltv;

	if (sc->sc_firmware_type != WI_LUCENT) {
		oltv = ltv;
		switch (ltv->wi_type) {
		case WI_RID_ENCRYPTION:
			p2ltv.wi_type = WI_RID_P2_ENCRYPTION;
			p2ltv.wi_len = 2;
			ltv = &p2ltv;
			break;
		case WI_RID_TX_CRYPT_KEY:
			if (ltv->wi_val > WI_NLTV_KEYS)
				return (EINVAL);
			p2ltv.wi_type = WI_RID_P2_TX_CRYPT_KEY;
			p2ltv.wi_len = 2;
			ltv = &p2ltv;
			break;
		}
	}

	/* Tell the NIC to enter record read mode. */
	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type, 0, 0))
		return(EIO);

	/* Seek to the record. */
	if (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))
		return(EIO);

	/*
	 * Read the length and record type and make sure they
	 * match what we expect (this verifies that we have enough
	 * room to hold all of the returned data).
	 */
	len = CSR_READ_2(sc, WI_DATA1);
	if (len > ltv->wi_len)
		return(ENOSPC);
	code = CSR_READ_2(sc, WI_DATA1);
	if (code != ltv->wi_type)
		return(EIO);

	ltv->wi_len = len;
	ltv->wi_type = code;

	/* Now read the data. */
	ptr = (u_int8_t *)&ltv->wi_val;
	if (ltv->wi_len > 1)
		CSR_READ_RAW_2(sc, WI_DATA1, ptr, (ltv->wi_len-1)*2);

	if (ltv->wi_type == WI_RID_PORTTYPE && sc->wi_ptype == WI_PORTTYPE_IBSS
	    && ltv->wi_val == sc->wi_ibss_port) {
		/*
		 * Convert vendor IBSS port type to WI_PORTTYPE_IBSS.
		 * Since Lucent uses port type 1 for BSS *and* IBSS we
		 * have to rely on wi_ptype to distinguish this for us.
		 */
		ltv->wi_val = htole16(WI_PORTTYPE_IBSS);
	} else if (sc->sc_firmware_type != WI_LUCENT) {
		int v;

		switch (oltv->wi_type) {
		case WI_RID_TX_RATE:
		case WI_RID_CUR_TX_RATE:
			switch (letoh16(ltv->wi_val)) {
			case 1: v = 1; break;
			case 2: v = 2; break;
			case 3:	v = 6; break;
			case 4: v = 5; break;
			case 7: v = 7; break;
			case 8: v = 11; break;
			case 15: v = 3; break;
			default: v = 0x100 + letoh16(ltv->wi_val); break;
			}
			oltv->wi_val = htole16(v);
			break;
		case WI_RID_ENCRYPTION:
			oltv->wi_len = 2;
			if (ltv->wi_val & htole16(0x01))
				oltv->wi_val = htole16(1);
			else
				oltv->wi_val = htole16(0);
			break;
		case WI_RID_TX_CRYPT_KEY:
		case WI_RID_CNFAUTHMODE:
			oltv->wi_len = 2;
			oltv->wi_val = ltv->wi_val;
			break;
		}
	}

	return(0);
}

/*
 * Same as read, except we inject data instead of reading it.
 */
STATIC int
wi_write_record_io(struct wi_softc *sc, struct wi_ltv_gen *ltv)
{
	u_int8_t		*ptr;
	u_int16_t		val = 0;
	int			i;
	struct wi_ltv_gen	p2ltv;

	if (ltv->wi_type == WI_RID_PORTTYPE &&
	    letoh16(ltv->wi_val) == WI_PORTTYPE_IBSS) {
		/* Convert WI_PORTTYPE_IBSS to vendor IBSS port type. */
		p2ltv.wi_type = WI_RID_PORTTYPE;
		p2ltv.wi_len = 2;
		p2ltv.wi_val = sc->wi_ibss_port;
		ltv = &p2ltv;
	} else if (sc->sc_firmware_type != WI_LUCENT) {
		int v;

		switch (ltv->wi_type) {
		case WI_RID_TX_RATE:
			p2ltv.wi_type = WI_RID_TX_RATE;
			p2ltv.wi_len = 2;
			switch (letoh16(ltv->wi_val)) {
			case 1: v = 1; break;
			case 2: v = 2; break;
			case 3:	v = 15; break;
			case 5: v = 4; break;
			case 6: v = 3; break;
			case 7: v = 7; break;
			case 11: v = 8; break;
			default: return EINVAL;
			}
			p2ltv.wi_val = htole16(v);
			ltv = &p2ltv;
			break;
		case WI_RID_ENCRYPTION:
			p2ltv.wi_type = WI_RID_P2_ENCRYPTION;
			p2ltv.wi_len = 2;
			if (ltv->wi_val & htole16(0x01)) {
				val = PRIVACY_INVOKED;
				/*
				 * If using shared key WEP we must set the
				 * EXCLUDE_UNENCRYPTED bit.  Symbol cards
				 * need this bit set even when not using
				 * shared key. We can't just test for
				 * IEEE80211_AUTH_SHARED since Symbol cards
				 * have 2 shared key modes.
				 */
				if (sc->wi_authtype != IEEE80211_AUTH_OPEN ||
				    sc->sc_firmware_type == WI_SYMBOL)
					val |= EXCLUDE_UNENCRYPTED;

				switch (sc->wi_crypto_algorithm) {
				case WI_CRYPTO_FIRMWARE_WEP:
					/*
					 * TX encryption is broken in
					 * Host AP mode.
					 */
					if (sc->wi_ptype == WI_PORTTYPE_HOSTAP)
						val |= HOST_ENCRYPT;
					break;
				case WI_CRYPTO_SOFTWARE_WEP:
					val |= HOST_ENCRYPT|HOST_DECRYPT;
					break;
				}
				p2ltv.wi_val = htole16(val);
			} else
				p2ltv.wi_val = htole16(HOST_ENCRYPT | HOST_DECRYPT);
			ltv = &p2ltv;
			break;
		case WI_RID_TX_CRYPT_KEY:
			if (ltv->wi_val > WI_NLTV_KEYS)
				return (EINVAL);
			p2ltv.wi_type = WI_RID_P2_TX_CRYPT_KEY;
			p2ltv.wi_len = 2;
			p2ltv.wi_val = ltv->wi_val;
			ltv = &p2ltv;
			break;
		case WI_RID_DEFLT_CRYPT_KEYS: {
				int error;
				int keylen;
				struct wi_ltv_str ws;
				struct wi_ltv_keys *wk = (struct wi_ltv_keys *)ltv;

				keylen = wk->wi_keys[sc->wi_tx_key].wi_keylen;
				keylen = letoh16(keylen);

				for (i = 0; i < 4; i++) {
					bzero(&ws, sizeof(ws));
					ws.wi_len = (keylen > 5) ? 8 : 4;
					ws.wi_type = WI_RID_P2_CRYPT_KEY0 + i;
					bcopy(&wk->wi_keys[i].wi_keydat,
					    ws.wi_str, keylen);
					error = wi_write_record(sc,
					    (struct wi_ltv_gen *)&ws);
					if (error)
						return (error);
				}
			}
			return (0);
		}
	}

	if (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))
		return(EIO);

	CSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);
	CSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);

	ptr = (u_int8_t *)&ltv->wi_val;
	if (ltv->wi_len > 1)
		CSR_WRITE_RAW_2(sc, WI_DATA1, ptr, (ltv->wi_len-1) *2);

	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type, 0, 0))
		return(EIO);

	return(0);
}

STATIC int
wi_seek(struct wi_softc *sc, int id, int off, int chan)
{
	int			i;
	int			selreg, offreg;

	switch (chan) {
	case WI_BAP0:
		selreg = WI_SEL0;
		offreg = WI_OFF0;
		break;
	case WI_BAP1:
		selreg = WI_SEL1;
		offreg = WI_OFF1;
		break;
	default:
		printf(WI_PRT_FMT ": invalid data path: %x\n", WI_PRT_ARG(sc),
		    chan);
		return(EIO);
	}

	CSR_WRITE_2(sc, selreg, id);
	CSR_WRITE_2(sc, offreg, off);

	for (i = WI_TIMEOUT; i--; DELAY(1))
		if (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))
			break;

	if (i < 0)
		return(ETIMEDOUT);

	return(0);
}

STATIC int
wi_read_data_io(struct wi_softc *sc, int id, int off, caddr_t buf, int len)
{
	u_int8_t		*ptr;

	if (wi_seek(sc, id, off, WI_BAP1))
		return(EIO);

	ptr = (u_int8_t *)buf;
	CSR_READ_RAW_2(sc, WI_DATA1, ptr, len);

	return(0);
}

/*
 * According to the comments in the HCF Light code, there is a bug in
 * the Hermes (or possibly in certain Hermes firmware revisions) where
 * the chip's internal autoincrement counter gets thrown off during
 * data writes: the autoincrement is missed, causing one data word to
 * be overwritten and subsequent words to be written to the wrong memory
 * locations. The end result is that we could end up transmitting bogus
 * frames without realizing it. The workaround for this is to write a
 * couple of extra guard words after the end of the transfer, then
 * attempt to read then back. If we fail to locate the guard words where
 * we expect them, we preform the transfer over again.
 */
STATIC int
wi_write_data_io(struct wi_softc *sc, int id, int off, caddr_t buf, int len)
{
	u_int8_t		*ptr;

#ifdef WI_HERMES_AUTOINC_WAR
again:
#endif

	if (wi_seek(sc, id, off, WI_BAP0))
		return(EIO);

	ptr = (u_int8_t *)buf;
	CSR_WRITE_RAW_2(sc, WI_DATA0, ptr, len);

#ifdef WI_HERMES_AUTOINC_WAR
	CSR_WRITE_2(sc, WI_DATA0, 0x1234);
	CSR_WRITE_2(sc, WI_DATA0, 0x5678);

	if (wi_seek(sc, id, off + len, WI_BAP0))
		return(EIO);

	if (CSR_READ_2(sc, WI_DATA0) != 0x1234 ||
	    CSR_READ_2(sc, WI_DATA0) != 0x5678)
		goto again;
#endif

	return(0);
}

/*
 * Allocate a region of memory inside the NIC and zero
 * it out.
 */
STATIC int
wi_alloc_nicmem_io(struct wi_softc *sc, int len, int *id)
{
	int			i;

	if (wi_cmd(sc, WI_CMD_ALLOC_MEM, len, 0, 0)) {
		printf(WI_PRT_FMT ": failed to allocate %d bytes on NIC\n",
		    WI_PRT_ARG(sc), len);
		return(ENOMEM);
	}

	for (i = WI_TIMEOUT; i--; DELAY(1)) {
		if (CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_ALLOC)
			break;
	}

	if (i < 0)
		return(ETIMEDOUT);

	*id = CSR_READ_2(sc, WI_ALLOC_FID);
	CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);

	if (wi_seek(sc, *id, 0, WI_BAP0))
		return(EIO);

	for (i = 0; i < len / 2; i++)
		CSR_WRITE_2(sc, WI_DATA0, 0);

	return(0);
}

STATIC void
wi_setmulti(struct wi_softc *sc)
{
	struct arpcom		*ac = &sc->sc_ic.ic_ac;
	struct ifnet		*ifp;
	int			i = 0;
	struct wi_ltv_mcast	mcast;
	struct ether_multistep	step;
	struct ether_multi	*enm;

	ifp = &sc->sc_ic.ic_if;

	bzero(&mcast, sizeof(mcast));

	mcast.wi_type = WI_RID_MCAST_LIST;
	mcast.wi_len = ((ETHER_ADDR_LEN / 2) * 16) + 1;

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		wi_write_record(sc, (struct wi_ltv_gen *)&mcast);
		return;
	}

	ETHER_FIRST_MULTI(step, &sc->sc_ic.ic_ac, enm);
	while (enm != NULL) {
		if (i >= 16) {
			bzero(&mcast, sizeof(mcast));
			break;
		}

		bcopy(enm->enm_addrlo, &mcast.wi_mcast[i], ETHER_ADDR_LEN);
		i++;
		ETHER_NEXT_MULTI(step, enm);
	}

	mcast.wi_len = (i * 3) + 1;
	wi_write_record(sc, (struct wi_ltv_gen *)&mcast);

	return;
}

STATIC int
wi_setdef(struct wi_softc *sc, struct wi_req *wreq)
{
	struct ifnet		*ifp;
	int error = 0;

	ifp = &sc->sc_ic.ic_if;

	switch(wreq->wi_type) {
	case WI_RID_MAC_NODE:
		bcopy(&wreq->wi_val, LLADDR(ifp->if_sadl), ETHER_ADDR_LEN);
		bcopy(&wreq->wi_val, &sc->sc_ic.ic_myaddr, ETHER_ADDR_LEN);
		break;
	case WI_RID_PORTTYPE:
		error = wi_sync_media(sc, letoh16(wreq->wi_val[0]),
		    sc->wi_tx_rate);
		break;
	case WI_RID_TX_RATE:
		error = wi_sync_media(sc, sc->wi_ptype,
		    letoh16(wreq->wi_val[0]));
		break;
	case WI_RID_MAX_DATALEN:
		sc->wi_max_data_len = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_RTS_THRESH:
		sc->wi_rts_thresh = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_SYSTEM_SCALE:
		sc->wi_ap_density = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_CREATE_IBSS:
		sc->wi_create_ibss = letoh16(wreq->wi_val[0]);
		error = wi_sync_media(sc, sc->wi_ptype, sc->wi_tx_rate);
		break;
	case WI_RID_OWN_CHNL:
		sc->wi_channel = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_NODENAME:
		error = wi_set_ssid(&sc->wi_node_name,
		    (u_int8_t *)&wreq->wi_val[1], letoh16(wreq->wi_val[0]));
		break;
	case WI_RID_DESIRED_SSID:
		error = wi_set_ssid(&sc->wi_net_name,
		    (u_int8_t *)&wreq->wi_val[1], letoh16(wreq->wi_val[0]));
		break;
	case WI_RID_OWN_SSID:
		error = wi_set_ssid(&sc->wi_ibss_name,
		    (u_int8_t *)&wreq->wi_val[1], letoh16(wreq->wi_val[0]));
		break;
	case WI_RID_PM_ENABLED:
		sc->wi_pm_enabled = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_MICROWAVE_OVEN:
		sc->wi_mor_enabled = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_MAX_SLEEP:
		sc->wi_max_sleep = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_CNFAUTHMODE:
		sc->wi_authtype = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_ROAMING_MODE:
		sc->wi_roaming = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_SYMBOL_DIVERSITY:
		sc->wi_diversity = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_ENH_SECURITY:
		sc->wi_enh_security = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_ENCRYPTION:
		sc->wi_use_wep = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_TX_CRYPT_KEY:
		sc->wi_tx_key = letoh16(wreq->wi_val[0]);
		break;
	case WI_RID_DEFLT_CRYPT_KEYS:
		bcopy(wreq, &sc->wi_keys, sizeof(struct wi_ltv_keys));
		break;
	case WI_FRID_CRYPTO_ALG:
		switch (letoh16(wreq->wi_val[0])) {
		case WI_CRYPTO_FIRMWARE_WEP:
			sc->wi_crypto_algorithm = WI_CRYPTO_FIRMWARE_WEP;
			break;
		case WI_CRYPTO_SOFTWARE_WEP:
			sc->wi_crypto_algorithm = WI_CRYPTO_SOFTWARE_WEP;
			break;
		default:
			printf(WI_PRT_FMT ": unsupported crypto algorithm %d\n",
			    WI_PRT_ARG(sc), letoh16(wreq->wi_val[0]));
			error = EINVAL;
		}
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

STATIC int
wi_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	int			s, error = 0, i, j, len;
	struct wi_softc		*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *)data;
	struct proc		*p = curproc;
	struct wi_scan_res	*res;
	struct wi_scan_p2_hdr	*p2;
	struct wi_req		*wreq = NULL;
	u_int32_t		flags;
	struct ieee80211_nwid		*nwidp = NULL;
	struct ieee80211_nodereq_all	*na;
	struct ieee80211_bssid		*bssid;

	s = splnet();
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED)) {
		error = ENODEV;
		goto fail;
	}

	/*
	 * Prevent processes from entering this function while another
	 * process is tsleep'ing in it.
	 */
	while ((sc->wi_flags & WI_FLAGS_BUSY) && error == 0)
		error = tsleep(&sc->wi_flags, PCATCH, "wiioc", 0);
	if (error != 0) {
		splx(s);
		return error;
	}
	sc->wi_flags |= WI_FLAGS_BUSY;


	DPRINTF (WID_IOCTL, ("wi_ioctl: command %lu data %p\n",
	    command, data));

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		wi_init(sc);
		break;
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->wi_if_flags & IFF_PROMISC)) {
				if (sc->wi_ptype != WI_PORTTYPE_HOSTAP)
					WI_SETVAL(WI_RID_PROMISC, 1);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->wi_if_flags & IFF_PROMISC) {
				if (sc->wi_ptype != WI_PORTTYPE_HOSTAP)
					WI_SETVAL(WI_RID_PROMISC, 0);
			} else
				wi_init(sc);
		} else if (ifp->if_flags & IFF_RUNNING)
			wi_stop(sc);
		sc->wi_if_flags = ifp->if_flags;
		error = 0;
		break;
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, command);
		break;
	case SIOCGWAVELAN:
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK | M_ZERO);
		error = copyin(ifr->ifr_data, wreq, sizeof(*wreq));
		if (error)
			break;
		if (wreq->wi_len > WI_MAX_DATALEN) {
			error = EINVAL;
			break;
		}
		switch (wreq->wi_type) {
		case WI_RID_IFACE_STATS:
			/* XXX native byte order */
			bcopy(&sc->wi_stats, &wreq->wi_val,
			    sizeof(sc->wi_stats));
			wreq->wi_len = (sizeof(sc->wi_stats) / 2) + 1;
			break;
		case WI_RID_DEFLT_CRYPT_KEYS:
			/* For non-root user, return all-zeroes keys */
			if (suser(p, 0))
				bzero(wreq, sizeof(struct wi_ltv_keys));
			else
				bcopy(&sc->wi_keys, wreq,
					sizeof(struct wi_ltv_keys));
			break;
		case WI_RID_PROCFRAME:
			wreq->wi_len = 2;
			wreq->wi_val[0] = htole16(sc->wi_procframe);
			break;
		case WI_RID_PRISM2:
			wreq->wi_len = 2;
			wreq->wi_val[0] = htole16(sc->sc_firmware_type ==
			    WI_LUCENT ? 0 : 1);
			break;
		case WI_FRID_CRYPTO_ALG:
			wreq->wi_val[0] =
			    htole16((u_int16_t)sc->wi_crypto_algorithm);
			wreq->wi_len = 1;
			break;
		case WI_RID_SCAN_RES:
			if (sc->sc_firmware_type == WI_LUCENT) {
				memcpy((char *)wreq->wi_val,
				    (char *)sc->wi_scanbuf,
				    sc->wi_scanbuf_len * 2);
				wreq->wi_len = sc->wi_scanbuf_len;
				break;
			}
			/* FALLTHROUGH */
		default:
			if (wi_read_record(sc, (struct wi_ltv_gen *)wreq)) {
				error = EINVAL;
			}
			break;
		}
		error = copyout(wreq, ifr->ifr_data, sizeof(*wreq));
		break;
	case SIOCSWAVELAN:
		if ((error = suser(curproc, 0)) != 0)
			break;
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK | M_ZERO);
		error = copyin(ifr->ifr_data, wreq, sizeof(*wreq));
		if (error)
			break;
		error = EINVAL;
		if (wreq->wi_len > WI_MAX_DATALEN)
			break;
		switch (wreq->wi_type) {
		case WI_RID_IFACE_STATS:
			break;
		case WI_RID_MGMT_XMIT:
			error = wi_mgmt_xmit(sc, (caddr_t)&wreq->wi_val,
			    wreq->wi_len);
			break;
		case WI_RID_PROCFRAME:
			sc->wi_procframe = letoh16(wreq->wi_val[0]);
			error = 0;
			break;
		case WI_RID_SCAN_REQ:
			error = 0;
			if (sc->sc_firmware_type == WI_LUCENT)
				wi_cmd(sc, WI_CMD_INQUIRE,
				    WI_INFO_SCAN_RESULTS, 0, 0);
			else
				error = wi_write_record(sc,
				    (struct wi_ltv_gen *)wreq);
			break;
		case WI_FRID_CRYPTO_ALG:
			if (sc->sc_firmware_type != WI_LUCENT) {
				error = wi_setdef(sc, wreq);
				if (!error && (ifp->if_flags & IFF_UP))
					wi_init(sc);
			}
			break;
		case WI_RID_SYMBOL_DIVERSITY:
		case WI_RID_ROAMING_MODE:
		case WI_RID_CREATE_IBSS:
		case WI_RID_MICROWAVE_OVEN:
		case WI_RID_OWN_SSID:
		case WI_RID_ENH_SECURITY:
			/*
			 * Check for features that may not be supported
			 * (must be just before default case).
			 */
			if ((wreq->wi_type == WI_RID_SYMBOL_DIVERSITY &&
			    !(sc->wi_flags & WI_FLAGS_HAS_DIVERSITY)) ||
			    (wreq->wi_type == WI_RID_ROAMING_MODE &&
			    !(sc->wi_flags & WI_FLAGS_HAS_ROAMING)) ||
			    (wreq->wi_type == WI_RID_CREATE_IBSS &&
			    !(sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)) ||
			    (wreq->wi_type == WI_RID_MICROWAVE_OVEN &&
			    !(sc->wi_flags & WI_FLAGS_HAS_MOR)) ||
			    (wreq->wi_type == WI_RID_ENH_SECURITY &&
			    !(sc->wi_flags & WI_FLAGS_HAS_ENH_SECURITY)) ||
			    (wreq->wi_type == WI_RID_OWN_SSID &&
			    wreq->wi_len != 0))
				break;
			/* FALLTHROUGH */
		default:
			error = wi_write_record(sc, (struct wi_ltv_gen *)wreq);
			if (!error)
				error = wi_setdef(sc, wreq);
			if (!error && (ifp->if_flags & IFF_UP))
				wi_init(sc);
		}
		break;
	case SIOCGPRISM2DEBUG:
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK | M_ZERO);
		error = copyin(ifr->ifr_data, wreq, sizeof(*wreq));
		if (error)
			break;
		if (!(ifp->if_flags & IFF_RUNNING) ||
		    sc->sc_firmware_type == WI_LUCENT) {
			error = EIO;
			break;
		}
		error = wi_get_debug(sc, wreq);
		if (error == 0)
			error = copyout(wreq, ifr->ifr_data, sizeof(*wreq));
		break;
	case SIOCSPRISM2DEBUG:
		if ((error = suser(curproc, 0)) != 0)
			break;
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK | M_ZERO);
		error = copyin(ifr->ifr_data, wreq, sizeof(*wreq));
		if (error)
			break;
		error = wi_set_debug(sc, wreq);
		break;
	case SIOCG80211NWID:
		if ((ifp->if_flags & IFF_UP) && sc->wi_net_name.i_len > 0) {
			/* Return the desired ID */
			error = copyout(&sc->wi_net_name, ifr->ifr_data,
			    sizeof(sc->wi_net_name));
		} else {
			wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK|M_ZERO);
			wreq->wi_type = WI_RID_CURRENT_SSID;
			wreq->wi_len = WI_MAX_DATALEN;
			if (wi_read_record(sc, (struct wi_ltv_gen *)wreq) ||
			    letoh16(wreq->wi_val[0]) > IEEE80211_NWID_LEN)
				error = EINVAL;
			else {
				nwidp = malloc(sizeof *nwidp, M_DEVBUF,
				    M_WAITOK | M_ZERO);
				wi_set_ssid(nwidp, (u_int8_t *)&wreq->wi_val[1],
				    letoh16(wreq->wi_val[0]));
				error = copyout(nwidp, ifr->ifr_data,
				    sizeof(*nwidp));
			}
		}
		break;
	case SIOCS80211NWID:
		if ((error = suser(curproc, 0)) != 0)
			break;
		nwidp = malloc(sizeof *nwidp, M_DEVBUF, M_WAITOK);
		error = copyin(ifr->ifr_data, nwidp, sizeof(*nwidp));
		if (error)
			break;
		if (nwidp->i_len > IEEE80211_NWID_LEN) {
			error = EINVAL;
			break;
		}
		if (sc->wi_net_name.i_len == nwidp->i_len &&
		    memcmp(sc->wi_net_name.i_nwid, nwidp->i_nwid, nwidp->i_len) == 0)
			break;
		wi_set_ssid(&sc->wi_net_name, nwidp->i_nwid, nwidp->i_len);
		WI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);
		if (ifp->if_flags & IFF_UP)
			/* Reinitialize WaveLAN. */
			wi_init(sc);
		break;
	case SIOCS80211NWKEY:
		if ((error = suser(curproc, 0)) != 0)
			break;
		error = wi_set_nwkey(sc, (struct ieee80211_nwkey *)data);
		break;
	case SIOCG80211NWKEY:
		error = wi_get_nwkey(sc, (struct ieee80211_nwkey *)data);
		break;
	case SIOCS80211POWER:
		if ((error = suser(curproc, 0)) != 0)
			break;
		error = wi_set_pm(sc, (struct ieee80211_power *)data);
		break;
	case SIOCG80211POWER:
		error = wi_get_pm(sc, (struct ieee80211_power *)data);
		break;
	case SIOCS80211TXPOWER:
		if ((error = suser(curproc, 0)) != 0)
			break;
		error = wi_set_txpower(sc, (struct ieee80211_txpower *)data);
		break;
	case SIOCG80211TXPOWER:
		error = wi_get_txpower(sc, (struct ieee80211_txpower *)data);
		break;
	case SIOCS80211CHANNEL:
		if ((error = suser(curproc, 0)) != 0)
			break;
		if (((struct ieee80211chanreq *)data)->i_channel > 14) {
			error = EINVAL;
			break;
		}
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK | M_ZERO);
		wreq->wi_type = WI_RID_OWN_CHNL;
		wreq->wi_val[0] =
		    htole16(((struct ieee80211chanreq *)data)->i_channel);
		error = wi_setdef(sc, wreq);
		if (!error && (ifp->if_flags & IFF_UP))
			wi_init(sc);
		break;
	case SIOCG80211CHANNEL:
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK | M_ZERO);
		wreq->wi_type = WI_RID_CURRENT_CHAN;
		wreq->wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)wreq)) {
			error = EINVAL;
			break;
		}
		((struct ieee80211chanreq *)data)->i_channel =
		    letoh16(wreq->wi_val[0]);
		break;
	case SIOCG80211BSSID:
		bssid = (struct ieee80211_bssid *)data;
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK | M_ZERO);
		wreq->wi_type = WI_RID_CURRENT_BSSID;
		wreq->wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)wreq)) {
			error = EINVAL;
			break;
		}
		IEEE80211_ADDR_COPY(bssid->i_bssid, wreq->wi_val);
		break;
	case SIOCS80211SCAN:
		if ((error = suser(curproc, 0)) != 0)
			break;
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP)
			break;
		if ((ifp->if_flags & IFF_UP) == 0) {
			error = ENETDOWN;
			break;
		}
		if (sc->sc_firmware_type == WI_LUCENT) {
			wi_cmd(sc, WI_CMD_INQUIRE,
			    WI_INFO_SCAN_RESULTS, 0, 0);
		} else {
			wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK|M_ZERO);
			wreq->wi_len = 3;
			wreq->wi_type = WI_RID_SCAN_REQ;
			wreq->wi_val[0] = 0x3FFF;
			wreq->wi_val[1] = 0x000F;

			error = wi_write_record(sc,
			    (struct wi_ltv_gen *)wreq);
			if (error)
				break;
		}
		sc->wi_scan_lock = 0;
		timeout_set(&sc->wi_scan_timeout, wi_scan_timeout, sc);
		len = WI_WAVELAN_RES_TIMEOUT;
		if (sc->wi_flags & WI_FLAGS_BUS_USB) {
			/* Use a longer timeout for wi@@usb */
			len = WI_WAVELAN_RES_TIMEOUT * 4;
		}
		timeout_add(&sc->wi_scan_timeout, len);

		/* Let the userspace process wait for completion */
		error = tsleep(&sc->wi_scan_lock, PCATCH, "wiscan",
		    hz * IEEE80211_SCAN_TIMEOUT);
		break;
	case SIOCG80211ALLNODES:
	    {
		struct ieee80211_nodereq	*nr = NULL;

		if ((error = suser(curproc, 0)) != 0)
			break;
		na = (struct ieee80211_nodereq_all *)data;
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
			/* List all associated stations */
			error = wihap_ioctl(sc, command, data);
			break;
		}
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK | M_ZERO);
		wreq->wi_len = WI_MAX_DATALEN;
		wreq->wi_type = WI_RID_SCAN_RES;
		if (sc->sc_firmware_type == WI_LUCENT) {
			bcopy(sc->wi_scanbuf, wreq->wi_val,
			    sc->wi_scanbuf_len * 2);
			wreq->wi_len = sc->wi_scanbuf_len;
			i = 0;
			len = WI_WAVELAN_RES_SIZE;
		} else {
			if (wi_read_record(sc, (struct wi_ltv_gen *)wreq)) {
				error = EINVAL;
				break;
			}
			p2 = (struct wi_scan_p2_hdr *)wreq->wi_val;
			if (p2->wi_reason == 0)
				break;
			i = sizeof(*p2);
			len = WI_PRISM2_RES_SIZE;
		}

		for (na->na_nodes = j = 0; (i < (wreq->wi_len * 2) - len) &&
		    (na->na_size >= j + sizeof(struct ieee80211_nodereq));
		    i += len) {

			if (nr == NULL)
				nr = malloc(sizeof *nr, M_DEVBUF, M_WAITOK);
			res = (struct wi_scan_res *)((char *)wreq->wi_val + i);
			if (res == NULL)
				break;

			bzero(nr, sizeof(*nr));
			IEEE80211_ADDR_COPY(nr->nr_macaddr, res->wi_bssid);
			IEEE80211_ADDR_COPY(nr->nr_bssid, res->wi_bssid);
			nr->nr_channel = letoh16(res->wi_chan);
			nr->nr_chan_flags = IEEE80211_CHAN_B;
			nr->nr_rssi = letoh16(res->wi_signal);
			nr->nr_max_rssi = 0; /* XXX */
			nr->nr_nwid_len = letoh16(res->wi_ssid_len);
			bcopy(res->wi_ssid, nr->nr_nwid, nr->nr_nwid_len);
			nr->nr_intval = letoh16(res->wi_interval);
			nr->nr_capinfo = letoh16(res->wi_capinfo);
			nr->nr_txrate = res->wi_rate == WI_WAVELAN_RES_1M ? 2 :
			    (res->wi_rate == WI_WAVELAN_RES_2M ? 4 :
			    (res->wi_rate == WI_WAVELAN_RES_5M ? 11 :
			    (res->wi_rate == WI_WAVELAN_RES_11M ? 22 : 0)));
			nr->nr_nrates = 0;
			while (res->wi_srates[nr->nr_nrates] != 0) {
				nr->nr_rates[nr->nr_nrates] =
				    res->wi_srates[nr->nr_nrates] &
				    WI_VAR_SRATES_MASK;
				nr->nr_nrates++;
			}
			nr->nr_flags = 0;
			if (bcmp(nr->nr_macaddr, nr->nr_bssid,
			    IEEE80211_ADDR_LEN) == 0)
				nr->nr_flags |= IEEE80211_NODEREQ_AP;

			error = copyout(nr, (caddr_t)na->na_node + j,
			    sizeof(struct ieee80211_nodereq));
			if (error)
				break;
			j += sizeof(struct ieee80211_nodereq);
			na->na_nodes++;
		}
		if (nr)
			free(nr, M_DEVBUF, 0);
		break;
	    }
	case SIOCG80211FLAGS:
		if (sc->wi_ptype != WI_PORTTYPE_HOSTAP)
			break;
		ifr->ifr_flags = 0;
		if (sc->wi_flags & WI_FLAGS_HAS_ENH_SECURITY) {
			wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK|M_ZERO);
			wreq->wi_len = WI_MAX_DATALEN;
			wreq->wi_type = WI_RID_ENH_SECURITY;
			if (wi_read_record(sc, (struct wi_ltv_gen *)wreq)) {
				error = EINVAL;
				break;
			}
			sc->wi_enh_security = letoh16(wreq->wi_val[0]);
			if (sc->wi_enh_security == WI_HIDESSID_IGNPROBES)
				ifr->ifr_flags |= IEEE80211_F_HIDENWID >>
				    IEEE80211_F_USERSHIFT;
		}
		break;
	case SIOCS80211FLAGS:
		if ((error = suser(curproc, 0)) != 0)
			break;
		if (sc->wi_ptype != WI_PORTTYPE_HOSTAP) {
			error = EINVAL;
			break;
		}
		flags = (u_int32_t)ifr->ifr_flags << IEEE80211_F_USERSHIFT;
		if (sc->wi_flags & WI_FLAGS_HAS_ENH_SECURITY) {
			sc->wi_enh_security = (flags & IEEE80211_F_HIDENWID) ?
			    WI_HIDESSID_IGNPROBES : 0;
			WI_SETVAL(WI_RID_ENH_SECURITY, sc->wi_enh_security);
		}
		break;
	case SIOCHOSTAP_ADD:
	case SIOCHOSTAP_DEL:
	case SIOCHOSTAP_GET:
	case SIOCHOSTAP_GETALL:
	case SIOCHOSTAP_GFLAGS:
	case SIOCHOSTAP_SFLAGS:
		/* Send all Host AP specific ioctl's to Host AP code. */
		error = wihap_ioctl(sc, command, data);
		break;
	default:
		error = ether_ioctl(ifp, &sc->sc_ic.ic_ac, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			wi_setmulti(sc);
		error = 0;
	}

	if (wreq)
		free(wreq, M_DEVBUF, 0);
	if (nwidp)
		free(nwidp, M_DEVBUF, 0);

fail:
	sc->wi_flags &= ~WI_FLAGS_BUSY;
	wakeup(&sc->wi_flags);
	splx(s);
	return(error);
}

void
wi_scan_timeout(void *arg)
{
	struct wi_softc		*sc = (struct wi_softc *)arg;
	struct wi_req		wreq;

	if (sc->wi_scan_lock++ < WI_WAVELAN_RES_TRIES &&
	    sc->sc_firmware_type != WI_LUCENT &&
	    (sc->wi_flags & WI_FLAGS_BUS_USB) == 0) {
		/*
		 * The Prism2/2.5/3 chipsets will set an extra field in the
		 * scan result if the scan request has been completed by the
		 * firmware. This allows to poll for completion and to
		 * wait for some more time if the scan is still in progress.
		 *
		 * XXX This doesn't work with wi@@usb because it isn't safe
		 * to call wi_read_record_usb() while beeing in the timeout
		 * handler.
		 */
		wreq.wi_len = WI_MAX_DATALEN;
		wreq.wi_type = WI_RID_SCAN_RES;

		if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) == 0 &&
		    ((struct wi_scan_p2_hdr *)wreq.wi_val)->wi_reason == 0) {
			/* Wait some more time for scan completion */
			timeout_add(&sc->wi_scan_timeout, WI_WAVELAN_RES_TIMEOUT);
			return;
		}
	}

	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf(WI_PRT_FMT ": wi_scan_timeout: %d tries\n",
		    WI_PRT_ARG(sc), sc->wi_scan_lock);

	/* Wakeup the userland */
	wakeup(&sc->wi_scan_lock);	
	sc->wi_scan_lock = 0;
}

STATIC void
wi_init_io(struct wi_softc *sc)
{
	struct ifnet		*ifp = &sc->sc_ic.ic_ac.ac_if;
	int			s;
	struct wi_ltv_macaddr	mac;
	int			id = 0;

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
		return;

	DPRINTF(WID_INIT, ("wi_init: sc %p\n", sc));

	s = splnet();

	if (ifp->if_flags & IFF_RUNNING)
		wi_stop(sc);

	wi_reset(sc);

	/* Program max data length. */
	WI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);

	/* Set the port type. */
	WI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);

	/* Enable/disable IBSS creation. */
	WI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);

	/* Program the RTS/CTS threshold. */
	WI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);

	/* Program the TX rate */
	WI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);

	/* Access point density */
	WI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);

	/* Power Management Enabled */
	WI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);

	/* Power Management Max Sleep */
	WI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);

	/* Set Enhanced Security if supported. */
	if (sc->wi_flags & WI_FLAGS_HAS_ENH_SECURITY)
		WI_SETVAL(WI_RID_ENH_SECURITY, sc->wi_enh_security);

	/* Set Roaming Mode unless this is a Symbol card. */
	if (sc->wi_flags & WI_FLAGS_HAS_ROAMING)
		WI_SETVAL(WI_RID_ROAMING_MODE, sc->wi_roaming);

	/* Set Antenna Diversity if this is a Symbol card. */
	if (sc->wi_flags & WI_FLAGS_HAS_DIVERSITY)
		WI_SETVAL(WI_RID_SYMBOL_DIVERSITY, sc->wi_diversity);

	/* Specify the network name */
	WI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);

	/* Specify the IBSS name */
	if (sc->wi_net_name.i_len != 0 && (sc->wi_ptype == WI_PORTTYPE_HOSTAP ||
	    (sc->wi_create_ibss && sc->wi_ptype == WI_PORTTYPE_IBSS)))
		WI_SETSTR(WI_RID_OWN_SSID, sc->wi_net_name);
	else
		WI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);

	/* Specify the frequency to use */
	WI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);

	/* Program the nodename. */
	WI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);

	/* Set our MAC address. */
	mac.wi_len = 4;
	mac.wi_type = WI_RID_MAC_NODE;
	bcopy(LLADDR(ifp->if_sadl), &sc->sc_ic.ic_myaddr, ETHER_ADDR_LEN);
	bcopy(&sc->sc_ic.ic_myaddr, &mac.wi_mac_addr, ETHER_ADDR_LEN);
	wi_write_record(sc, (struct wi_ltv_gen *)&mac);

	/*
	 * Initialize promisc mode.
	 *	Being in the Host-AP mode causes
	 *	great deal of pain if promisc mode is set.
	 *	Therefore we avoid confusing the firmware
	 *	and always reset promisc mode in Host-AP regime,
	 *	it shows us all the packets anyway.
	 */
	if (sc->wi_ptype != WI_PORTTYPE_HOSTAP && ifp->if_flags & IFF_PROMISC)
		WI_SETVAL(WI_RID_PROMISC, 1);
	else
		WI_SETVAL(WI_RID_PROMISC, 0);

	/* Configure WEP. */
	if (sc->wi_flags & WI_FLAGS_HAS_WEP) {
		WI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);
		WI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);
		sc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;
		sc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;
		wi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);
		if (sc->sc_firmware_type != WI_LUCENT && sc->wi_use_wep) {
			/*
			 * HWB3163 EVAL-CARD Firmware version less than 0.8.2.
			 *
			 * If promiscuous mode is disabled, the Prism2 chip
			 * does not work with WEP .
			 * I'm currently investigating the details of this.
			 * (ichiro@@netbsd.org)
			 */
			 if (sc->sc_firmware_type == WI_INTERSIL &&
			    sc->sc_sta_firmware_ver < 802 ) {
				/* firm ver < 0.8.2 */
				WI_SETVAL(WI_RID_PROMISC, 1);
			 }
			 WI_SETVAL(WI_RID_CNFAUTHMODE, sc->wi_authtype);
		}
	}

	/* Set multicast filter. */
	wi_setmulti(sc);

	/* Enable desired port */
	wi_cmd(sc, WI_CMD_ENABLE | sc->wi_portnum, 0, 0, 0);

	if (wi_alloc_nicmem(sc, ETHER_MAX_LEN + sizeof(struct wi_frame) + 8, &id))
		printf(WI_PRT_FMT ": tx buffer allocation failed\n",
		    WI_PRT_ARG(sc));
	sc->wi_tx_data_id = id;

	if (wi_alloc_nicmem(sc, ETHER_MAX_LEN + sizeof(struct wi_frame) + 8, &id))
		printf(WI_PRT_FMT ": mgmt. buffer allocation failed\n",
		    WI_PRT_ARG(sc));
	sc->wi_tx_mgmt_id = id;

	/* Set txpower */
	if (sc->wi_flags & WI_FLAGS_TXPOWER)
		wi_set_txpower(sc, NULL);

	/* enable interrupts */
	wi_intr_enable(sc, WI_INTRS);

        wihap_init(sc);

	splx(s);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_add_sec(&sc->sc_timo, 60);

	return;
}

STATIC void
wi_do_hostencrypt(struct wi_softc *sc, caddr_t buf, int len)
{
	u_int32_t crc, klen;
	u_int8_t key[RC4KEYLEN];
	u_int8_t *dat;
	struct rc4_ctx ctx;

	if (!sc->wi_icv_flag) {
		sc->wi_icv = arc4random();
		sc->wi_icv_flag++;
        } else
		sc->wi_icv++;
	/*
	 * Skip 'bad' IVs from Fluhrer/Mantin/Shamir:
	 * (B, 255, N) with 3 <= B < 8
	 */
	if (sc->wi_icv >= 0x03ff00 &&
            (sc->wi_icv & 0xf8ff00) == 0x00ff00)
                sc->wi_icv += 0x000100;

	/* prepend 24bit IV to tx key, byte order does not matter */
	bzero(key, sizeof(key));
	key[0] = sc->wi_icv >> 16;
	key[1] = sc->wi_icv >> 8;
	key[2] = sc->wi_icv;

	klen = letoh16(sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keylen);
	bcopy(&sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keydat,
	    key + IEEE80211_WEP_IVLEN, klen);
	klen = (klen > IEEE80211_WEP_KEYLEN) ? RC4KEYLEN : RC4KEYLEN / 2;

	/* rc4 keysetup */
	rc4_keysetup(&ctx, key, klen);

	/* output: IV, tx keyid, rc4(data), rc4(crc32(data)) */
	dat = buf;
	dat[0] = key[0];
	dat[1] = key[1];
	dat[2] = key[2];
	dat[3] = sc->wi_tx_key << 6;		/* pad and keyid */
	dat += 4;

	/* compute crc32 over data and encrypt */
	crc = ~ether_crc32_le(dat, len);
	rc4_crypt(&ctx, dat, dat, len);
	dat += len;

	/* append little-endian crc32 and encrypt */
	dat[0] = crc;
	dat[1] = crc >> 8;
	dat[2] = crc >> 16;
	dat[3] = crc >> 24;
	rc4_crypt(&ctx, dat, dat, IEEE80211_WEP_CRCLEN);
}

STATIC int
wi_do_hostdecrypt(struct wi_softc *sc, caddr_t buf, int len)
{
	u_int32_t crc, klen, kid;
	u_int8_t key[RC4KEYLEN];
	u_int8_t *dat;
	struct rc4_ctx ctx;

	if (len < IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
	    IEEE80211_WEP_CRCLEN)
		return -1;
	len -= (IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
	    IEEE80211_WEP_CRCLEN);

	dat = buf;

	bzero(key, sizeof(key));
	key[0] = dat[0];
	key[1] = dat[1];
	key[2] = dat[2];
	kid = (dat[3] >> 6) % 4;
	dat += 4;

	klen = letoh16(sc->wi_keys.wi_keys[kid].wi_keylen);
	bcopy(&sc->wi_keys.wi_keys[kid].wi_keydat,
	    key + IEEE80211_WEP_IVLEN, klen);
	klen = (klen > IEEE80211_WEP_KEYLEN) ? RC4KEYLEN : RC4KEYLEN / 2;

	/* rc4 keysetup */
	rc4_keysetup(&ctx, key, klen);

	/* decrypt and compute crc32 over data */
	rc4_crypt(&ctx, dat, dat, len);
	crc = ~ether_crc32_le(dat, len);
	dat += len;

	/* decrypt little-endian crc32 and verify */
	rc4_crypt(&ctx, dat, dat, IEEE80211_WEP_CRCLEN);

	if ((dat[0] != crc) && (dat[1] != crc >> 8) &&
	    (dat[2] != crc >> 16) && (dat[3] != crc >> 24)) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf(WI_PRT_FMT ": wi_do_hostdecrypt: iv mismatch: "
			    "0x%02x%02x%02x%02x vs. 0x%x\n", WI_PRT_ARG(sc),
			    dat[3], dat[2], dat[1], dat[0], crc);
		return -1;
	}

	return 0;
}

void
wi_start(struct ifnet *ifp)
{
	struct wi_softc		*sc;
	struct mbuf		*m0;
	struct wi_frame		tx_frame;
	struct ether_header	*eh;
	int			id, hostencrypt = 0;

	sc = ifp->if_softc;

	DPRINTF(WID_START, ("wi_start: ifp %p sc %p\n", ifp, sc));

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

nextpkt:
	IFQ_DEQUEUE(&ifp->if_snd, m0);
	if (m0 == NULL)
		return;

	bzero(&tx_frame, sizeof(tx_frame));
	tx_frame.wi_frame_ctl = htole16(WI_FTYPE_DATA | WI_STYPE_DATA);
	id = sc->wi_tx_data_id;
	eh = mtod(m0, struct ether_header *);

	if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
		if (!wihap_check_tx(&sc->wi_hostap_info, eh->ether_dhost,
		    &tx_frame.wi_tx_rate) && !(ifp->if_flags & IFF_PROMISC)) {
			if (ifp->if_flags & IFF_DEBUG)
				printf(WI_PRT_FMT
				    ": wi_start: dropping unassoc dst %s\n",
				    WI_PRT_ARG(sc),
				    ether_sprintf(eh->ether_dhost));
			m_freem(m0);
			goto nextpkt;
		}
	}

	/*
	 * Use RFC1042 encoding for IP and ARP datagrams,
	 * 802.3 for anything else.
	 */
	if (eh->ether_type == htons(ETHERTYPE_IP) ||
	    eh->ether_type == htons(ETHERTYPE_ARP) ||
	    eh->ether_type == htons(ETHERTYPE_REVARP) ||
	    eh->ether_type == htons(ETHERTYPE_IPV6)) {
		bcopy(&eh->ether_dhost,
		    &tx_frame.wi_addr1, ETHER_ADDR_LEN);
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
			tx_frame.wi_tx_ctl = htole16(WI_ENC_TX_MGMT); /* XXX */
			tx_frame.wi_frame_ctl |= htole16(WI_FCTL_FROMDS);
			bcopy(&sc->sc_ic.ic_myaddr,
			    &tx_frame.wi_addr2, ETHER_ADDR_LEN);
			bcopy(&eh->ether_shost,
			    &tx_frame.wi_addr3, ETHER_ADDR_LEN);
			if (sc->wi_use_wep)
				hostencrypt = 1;
		} else if (sc->wi_ptype == WI_PORTTYPE_BSS && sc->wi_use_wep &&
		    sc->wi_crypto_algorithm != WI_CRYPTO_FIRMWARE_WEP) {
			tx_frame.wi_tx_ctl = htole16(WI_ENC_TX_MGMT); /* XXX */
			tx_frame.wi_frame_ctl |= htole16(WI_FCTL_TODS);
			bcopy(&sc->sc_ic.ic_myaddr,
			    &tx_frame.wi_addr2, ETHER_ADDR_LEN);
			bcopy(&eh->ether_dhost,
			    &tx_frame.wi_addr3, ETHER_ADDR_LEN);
			hostencrypt = 1;
		} else
			bcopy(&eh->ether_shost,
			    &tx_frame.wi_addr2, ETHER_ADDR_LEN);
		bcopy(&eh->ether_dhost, &tx_frame.wi_dst_addr, ETHER_ADDR_LEN);
		bcopy(&eh->ether_shost, &tx_frame.wi_src_addr, ETHER_ADDR_LEN);

		tx_frame.wi_dat_len = m0->m_pkthdr.len - WI_SNAPHDR_LEN;
		tx_frame.wi_dat[0] = htons(WI_SNAP_WORD0);
		tx_frame.wi_dat[1] = htons(WI_SNAP_WORD1);
		tx_frame.wi_len = htons(m0->m_pkthdr.len - WI_SNAPHDR_LEN);
		tx_frame.wi_type = eh->ether_type;

		if (hostencrypt) {

			/* Do host encryption. */
			tx_frame.wi_frame_ctl |= htole16(WI_FCTL_WEP);
			bcopy(&tx_frame.wi_dat[0], &sc->wi_txbuf[4], 6);
			bcopy(&tx_frame.wi_type, &sc->wi_txbuf[10], 2);

			m_copydata(m0, sizeof(struct ether_header),
			    m0->m_pkthdr.len - sizeof(struct ether_header),
			    (caddr_t)&sc->wi_txbuf[12]);

			wi_do_hostencrypt(sc, (caddr_t)&sc->wi_txbuf,
			    tx_frame.wi_dat_len);

			tx_frame.wi_dat_len += IEEE80211_WEP_IVLEN +
			    IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN;

			tx_frame.wi_dat_len = htole16(tx_frame.wi_dat_len);
			wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
			    sizeof(struct wi_frame));
			wi_write_data(sc, id, WI_802_11_OFFSET_RAW,
			    (caddr_t)&sc->wi_txbuf,
			    (m0->m_pkthdr.len -
			     sizeof(struct ether_header)) + 18);
		} else {
			m_copydata(m0, sizeof(struct ether_header),
			    m0->m_pkthdr.len - sizeof(struct ether_header),
			    (caddr_t)&sc->wi_txbuf);

			tx_frame.wi_dat_len = htole16(tx_frame.wi_dat_len);
			wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
			    sizeof(struct wi_frame));
			wi_write_data(sc, id, WI_802_11_OFFSET,
			    (caddr_t)&sc->wi_txbuf,
			    (m0->m_pkthdr.len -
			     sizeof(struct ether_header)) + 2);
		}
	} else {
		tx_frame.wi_dat_len = htole16(m0->m_pkthdr.len);

		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP && sc->wi_use_wep) {

			/* Do host encryption. (XXX - not implemented) */
			printf(WI_PRT_FMT
			    ": host encrypt not implemented for 802.3\n",
			    WI_PRT_ARG(sc));
		} else {
			m_copydata(m0, 0, m0->m_pkthdr.len,
			    (caddr_t)&sc->wi_txbuf);

			wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
			    sizeof(struct wi_frame));
			wi_write_data(sc, id, WI_802_3_OFFSET,
			    (caddr_t)&sc->wi_txbuf, m0->m_pkthdr.len + 2);
		}
	}

#if NBPFILTER > 0
	/*
	 * If there's a BPF listener, bounce a copy of
	 * this frame to him.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

	m_freem(m0);

	ifq_set_oactive(&ifp->if_snd);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;

	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id, 0, 0))
		printf(WI_PRT_FMT ": wi_start: xmit failed\n", WI_PRT_ARG(sc));

	return;
}

STATIC int
wi_mgmt_xmit(struct wi_softc *sc, caddr_t data, int len)
{
	struct wi_frame		tx_frame;
	int			id;
	struct wi_80211_hdr	*hdr;
	caddr_t			dptr;

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
		return(ENODEV);

	hdr = (struct wi_80211_hdr *)data;
	dptr = data + sizeof(struct wi_80211_hdr);

	bzero(&tx_frame, sizeof(tx_frame));
	id = sc->wi_tx_mgmt_id;

	bcopy(hdr, &tx_frame.wi_frame_ctl, sizeof(struct wi_80211_hdr));

	tx_frame.wi_tx_ctl = htole16(WI_ENC_TX_MGMT);
	tx_frame.wi_dat_len = len - sizeof(struct wi_80211_hdr);
	tx_frame.wi_len = htole16(tx_frame.wi_dat_len);

	tx_frame.wi_dat_len = htole16(tx_frame.wi_dat_len);
	wi_write_data(sc, id, 0, (caddr_t)&tx_frame, sizeof(struct wi_frame));
	wi_write_data(sc, id, WI_802_11_OFFSET_RAW, dptr,
	    (len - sizeof(struct wi_80211_hdr)) + 2);

	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id, 0, 0)) {
		printf(WI_PRT_FMT ": wi_mgmt_xmit: xmit failed\n",
		    WI_PRT_ARG(sc));
		/*
		 * Hostile stations or corrupt frames may crash the card
		 * and cause the kernel to get stuck printing complaints.
		 * Reset the card and hope the problem goes away.
		 */
		wi_reset(sc);
		return(EIO);
	}

	return(0);
}

void
wi_stop(struct wi_softc *sc)
{
	struct ifnet		*ifp;

	wihap_shutdown(sc);

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
		return;

	DPRINTF(WID_STOP, ("wi_stop: sc %p\n", sc));

	timeout_del(&sc->sc_timo);

	ifp = &sc->sc_ic.ic_if;

	wi_intr_enable(sc, 0);
	wi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0, 0, 0);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	return;
}


void
wi_watchdog(struct ifnet *ifp)
{
	struct wi_softc		*sc;

	sc = ifp->if_softc;

	printf(WI_PRT_FMT ": device timeout\n", WI_PRT_ARG(sc));

	wi_cor_reset(sc);
	wi_init(sc);

	ifp->if_oerrors++;

	return;
}

void
wi_detach(struct wi_softc *sc)
{
	struct ifnet *ifp;
	ifp = &sc->sc_ic.ic_if;

	if (ifp->if_flags & IFF_RUNNING)
		wi_stop(sc);
	
	if (sc->wi_flags & WI_FLAGS_ATTACHED) {
		sc->wi_flags &= ~WI_FLAGS_ATTACHED;
	}
}

STATIC void
wi_get_id(struct wi_softc *sc)
{
	struct wi_ltv_ver		ver;
	const struct wi_card_ident	*id;
	u_int16_t			pri_fw_ver[3];
	const char			*card_name;
	u_int16_t			card_id;

	/* get chip identity */
	bzero(&ver, sizeof(ver));
	ver.wi_type = WI_RID_CARD_ID;
	ver.wi_len = 5;
	wi_read_record(sc, (struct wi_ltv_gen *)&ver);
	card_id = letoh16(ver.wi_ver[0]);
	for (id = wi_card_ident; id->firm_type != WI_NOTYPE; id++) {
		if (card_id == id->card_id)
			break;
	}
	if (id->firm_type != WI_NOTYPE) {
		sc->sc_firmware_type = id->firm_type;
		card_name = id->card_name;
	} else if (ver.wi_ver[0] & htole16(0x8000)) {
		sc->sc_firmware_type = WI_INTERSIL;
		card_name = "Unknown PRISM2 chip";
	} else {
		sc->sc_firmware_type = WI_LUCENT;
	}

	/* get primary firmware version (XXX - how to do Lucent?) */
	if (sc->sc_firmware_type != WI_LUCENT) {
		bzero(&ver, sizeof(ver));
		ver.wi_type = WI_RID_PRI_IDENTITY;
		ver.wi_len = 5;
		wi_read_record(sc, (struct wi_ltv_gen *)&ver);
		pri_fw_ver[0] = letoh16(ver.wi_ver[2]);
		pri_fw_ver[1] = letoh16(ver.wi_ver[3]);
		pri_fw_ver[2] = letoh16(ver.wi_ver[1]);
	}

	/* get station firmware version */
	bzero(&ver, sizeof(ver));
	ver.wi_type = WI_RID_STA_IDENTITY;
	ver.wi_len = 5;
	wi_read_record(sc, (struct wi_ltv_gen *)&ver);
	ver.wi_ver[1] = letoh16(ver.wi_ver[1]);
	ver.wi_ver[2] = letoh16(ver.wi_ver[2]);
	ver.wi_ver[3] = letoh16(ver.wi_ver[3]);
	sc->sc_sta_firmware_ver = ver.wi_ver[2] * 10000 +
	    ver.wi_ver[3] * 100 + ver.wi_ver[1];

	if (sc->sc_firmware_type == WI_INTERSIL &&
	    (sc->sc_sta_firmware_ver == 10102 || sc->sc_sta_firmware_ver == 20102)) {
		struct wi_ltv_str sver;
		char *p;

		bzero(&sver, sizeof(sver));
		sver.wi_type = WI_RID_SYMBOL_IDENTITY;
		sver.wi_len = 7;
		/* value should be something like "V2.00-11" */
		if (wi_read_record(sc, (struct wi_ltv_gen *)&sver) == 0 &&
		    *(p = (char *)sver.wi_str) >= 'A' &&
		    p[2] == '.' && p[5] == '-' && p[8] == '\0') {
			sc->sc_firmware_type = WI_SYMBOL;
			sc->sc_sta_firmware_ver = (p[1] - '0') * 10000 +
			    (p[3] - '0') * 1000 + (p[4] - '0') * 100 +
			    (p[6] - '0') * 10 + (p[7] - '0');
		}
	}

	if (sc->sc_firmware_type == WI_LUCENT) {
		printf("%s: Firmware %d.%02d variant %d, ", WI_PRT_ARG(sc),
		    ver.wi_ver[2], ver.wi_ver[3], ver.wi_ver[1]);
	} else {
		printf("%s: %s%s (0x%04x), Firmware %d.%d.%d (primary), %d.%d.%d (station), ",
		    WI_PRT_ARG(sc),
		    sc->sc_firmware_type == WI_SYMBOL ? "Symbol " : "",
		    card_name, card_id, pri_fw_ver[0], pri_fw_ver[1],
		    pri_fw_ver[2], sc->sc_sta_firmware_ver / 10000,
		    (sc->sc_sta_firmware_ver % 10000) / 100,
		    sc->sc_sta_firmware_ver % 100);
	}
}

STATIC int
wi_sync_media(struct wi_softc *sc, int ptype, int txrate)
{
	uint64_t media = sc->sc_media.ifm_cur->ifm_media;
	uint64_t options = IFM_OPTIONS(media);
	uint64_t subtype;

	switch (txrate) {
	case 1:
		subtype = IFM_IEEE80211_DS1;
		break;
	case 2:
		subtype = IFM_IEEE80211_DS2;
		break;
	case 3:
		subtype = IFM_AUTO;
		break;
	case 5:
		subtype = IFM_IEEE80211_DS5;
		break;
	case 11:
		subtype = IFM_IEEE80211_DS11;
		break;
	default:
		subtype = IFM_MANUAL;		/* Unable to represent */
		break;
	}

	options &= ~IFM_OMASK;
	switch (ptype) {
	case WI_PORTTYPE_BSS:
		/* default port type */
		break;
	case WI_PORTTYPE_ADHOC:
		options |= IFM_IEEE80211_ADHOC;
		break;
	case WI_PORTTYPE_HOSTAP:
		options |= IFM_IEEE80211_HOSTAP;
		break;
	case WI_PORTTYPE_IBSS:
		if (sc->wi_create_ibss)
			options |= IFM_IEEE80211_IBSSMASTER;
		else
			options |= IFM_IEEE80211_IBSS;
		break;
	default:
		subtype = IFM_MANUAL;		/* Unable to represent */
		break;
	}
	media = IFM_MAKEWORD(IFM_TYPE(media), subtype, options,
	IFM_INST(media));
	if (ifmedia_match(&sc->sc_media, media, sc->sc_media.ifm_mask) == NULL)
		return (EINVAL);
	ifmedia_set(&sc->sc_media, media);
	sc->wi_ptype = ptype;
	sc->wi_tx_rate = txrate;
	return (0);
}

STATIC int
wi_media_change(struct ifnet *ifp)
{
	struct wi_softc *sc = ifp->if_softc;
	int otype = sc->wi_ptype;
	int orate = sc->wi_tx_rate;
	int ocreate_ibss = sc->wi_create_ibss;

	if ((sc->sc_media.ifm_cur->ifm_media & IFM_IEEE80211_HOSTAP) &&
	    sc->sc_firmware_type != WI_INTERSIL)
		return (EINVAL);

	sc->wi_create_ibss = 0;

	switch (sc->sc_media.ifm_cur->ifm_media & IFM_OMASK) {
	case 0:
		sc->wi_ptype = WI_PORTTYPE_BSS;
		break;
	case IFM_IEEE80211_ADHOC:
		sc->wi_ptype = WI_PORTTYPE_ADHOC;
		break;
	case IFM_IEEE80211_HOSTAP:
		sc->wi_ptype = WI_PORTTYPE_HOSTAP;
		break;
	case IFM_IEEE80211_IBSSMASTER:
	case IFM_IEEE80211_IBSSMASTER|IFM_IEEE80211_IBSS:
		if (!(sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS))
			return (EINVAL);
		sc->wi_create_ibss = 1;
		/* FALLTHROUGH */
	case IFM_IEEE80211_IBSS:
		sc->wi_ptype = WI_PORTTYPE_IBSS;
		break;
	default:
		/* Invalid combination. */
		return (EINVAL);
	}

	switch (IFM_SUBTYPE(sc->sc_media.ifm_cur->ifm_media)) {
	case IFM_IEEE80211_DS1:
		sc->wi_tx_rate = 1;
		break;
	case IFM_IEEE80211_DS2:
		sc->wi_tx_rate = 2;
		break;
	case IFM_AUTO:
		sc->wi_tx_rate = 3;
		break;
	case IFM_IEEE80211_DS5:
		sc->wi_tx_rate = 5;
		break;
	case IFM_IEEE80211_DS11:
		sc->wi_tx_rate = 11;
		break;
	}

	if (sc->sc_ic.ic_if.if_flags & IFF_UP) {
		if (otype != sc->wi_ptype || orate != sc->wi_tx_rate ||
		    ocreate_ibss != sc->wi_create_ibss)
			wi_init(sc);
	}

	ifp->if_baudrate = ifmedia_baudrate(sc->sc_media.ifm_cur->ifm_media);

	return (0);
}

STATIC void
wi_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct wi_softc *sc = ifp->if_softc;
	struct wi_req wreq;

	if (!(sc->sc_ic.ic_if.if_flags & IFF_UP)) {
		imr->ifm_active = IFM_IEEE80211|IFM_NONE;
		imr->ifm_status = 0;
		return;
	}

	if (sc->wi_tx_rate == 3) {
		imr->ifm_active = IFM_IEEE80211|IFM_AUTO;

		wreq.wi_type = WI_RID_CUR_TX_RATE;
		wreq.wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) == 0) {
			switch (letoh16(wreq.wi_val[0])) {
			case 1:
				imr->ifm_active |= IFM_IEEE80211_DS1;
				break;
			case 2:
				imr->ifm_active |= IFM_IEEE80211_DS2;
				break;
			case 6:
				imr->ifm_active |= IFM_IEEE80211_DS5;
				break;
			case 11:
				imr->ifm_active |= IFM_IEEE80211_DS11;
				break;
			}
		}
	} else {
		imr->ifm_active = sc->sc_media.ifm_cur->ifm_media;
	}

	imr->ifm_status = IFM_AVALID;
	switch (sc->wi_ptype) {
	case WI_PORTTYPE_ADHOC:
	case WI_PORTTYPE_IBSS:
		/*
		 * XXX: It would be nice if we could give some actually
		 * useful status like whether we joined another IBSS or
		 * created one ourselves.
		 */
		/* FALLTHROUGH */
	case WI_PORTTYPE_HOSTAP:
		imr->ifm_status |= IFM_ACTIVE;
		break;
	default:
		wreq.wi_type = WI_RID_COMMQUAL;
		wreq.wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) == 0 &&
		    letoh16(wreq.wi_val[0]) != 0)
			imr->ifm_status |= IFM_ACTIVE;
	}
}

STATIC int
wi_set_nwkey(struct wi_softc *sc, struct ieee80211_nwkey *nwkey)
{
	int i, len, error;
	struct wi_req wreq;
	struct wi_ltv_keys *wk = (struct wi_ltv_keys *)&wreq;

	if (!(sc->wi_flags & WI_FLAGS_HAS_WEP))
		return ENODEV;
	if (nwkey->i_defkid <= 0 || nwkey->i_defkid > IEEE80211_WEP_NKID)
		return EINVAL;
	memcpy(wk, &sc->wi_keys, sizeof(*wk));
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (nwkey->i_key[i].i_keydat == NULL)
			continue;
		len = nwkey->i_key[i].i_keylen;
		if (len > sizeof(wk->wi_keys[i].wi_keydat))
			return EINVAL;
		error = copyin(nwkey->i_key[i].i_keydat,
		    wk->wi_keys[i].wi_keydat, len);
		if (error)
			return error;
		wk->wi_keys[i].wi_keylen = htole16(len);
	}

	wk->wi_len = (sizeof(*wk) / 2) + 1;
	wk->wi_type = WI_RID_DEFLT_CRYPT_KEYS;
	if (sc->sc_ic.ic_if.if_flags & IFF_UP) {
		error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
		if (error)
			return error;
	}
	if ((error = wi_setdef(sc, &wreq)))
		return (error);

	wreq.wi_len = 2;
	wreq.wi_type = WI_RID_TX_CRYPT_KEY;
	wreq.wi_val[0] = htole16(nwkey->i_defkid - 1);
	if (sc->sc_ic.ic_if.if_flags & IFF_UP) {
		error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
		if (error)
			return error;
	}
	if ((error = wi_setdef(sc, &wreq)))
		return (error);

	wreq.wi_type = WI_RID_ENCRYPTION;
	wreq.wi_val[0] = htole16(nwkey->i_wepon);
	if (sc->sc_ic.ic_if.if_flags & IFF_UP) {
		error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
		if (error)
			return error;
	}
	if ((error = wi_setdef(sc, &wreq)))
		return (error);

	if (sc->sc_ic.ic_if.if_flags & IFF_UP)
		wi_init(sc);
	return 0;
}

STATIC int
wi_get_nwkey(struct wi_softc *sc, struct ieee80211_nwkey *nwkey)
{
	int i, len, error;
	struct wi_ltv_keys *wk = &sc->wi_keys;

	if (!(sc->wi_flags & WI_FLAGS_HAS_WEP))
		return ENODEV;
	nwkey->i_wepon = sc->wi_use_wep;
	nwkey->i_defkid = sc->wi_tx_key + 1;

	/* do not show any keys to non-root user */
	error = suser(curproc, 0);
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (nwkey->i_key[i].i_keydat == NULL)
			continue;
		/* error holds results of suser() for the first time */
		if (error)
			return error;
		len = letoh16(wk->wi_keys[i].wi_keylen);
		if (nwkey->i_key[i].i_keylen < len)
			return ENOSPC;
		nwkey->i_key[i].i_keylen = len;
		error = copyout(wk->wi_keys[i].wi_keydat,
		    nwkey->i_key[i].i_keydat, len);
		if (error)
			return error;
	}
	return 0;
}

STATIC int
wi_set_pm(struct wi_softc *sc, struct ieee80211_power *power)
{

	sc->wi_pm_enabled = power->i_enabled;
	sc->wi_max_sleep = power->i_maxsleep;

	if (sc->sc_ic.ic_if.if_flags & IFF_UP)
		wi_init(sc);

	return (0);
}

STATIC int
wi_get_pm(struct wi_softc *sc, struct ieee80211_power *power)
{

	power->i_enabled = sc->wi_pm_enabled;
	power->i_maxsleep = sc->wi_max_sleep;

	return (0);
}

STATIC int
wi_set_txpower(struct wi_softc *sc, struct ieee80211_txpower *txpower)
{
	u_int16_t	cmd;
	u_int16_t	power;
	int8_t		tmp;
	int		error;
	int		alc;

	if (txpower == NULL) {
		if (!(sc->wi_flags & WI_FLAGS_TXPOWER))
			return (EINVAL);
		alc = 0;		/* disable ALC */
	} else {
		if (txpower->i_mode == IEEE80211_TXPOWER_MODE_AUTO) {
			alc = 1;	/* enable ALC */
			sc->wi_flags &= ~WI_FLAGS_TXPOWER;
		} else {
			alc = 0;	/* disable ALC */
			sc->wi_flags |= WI_FLAGS_TXPOWER;
			sc->wi_txpower = txpower->i_val;
		}
	}	

	/* Set ALC */
	cmd = WI_CMD_DEBUG | (WI_DEBUG_CONFBITS << 8);
	if ((error = wi_cmd(sc, cmd, alc, 0x8, 0)) != 0)
		return (error);

	/* No need to set the TX power value if ALC is enabled */
	if (alc)
		return (0);

	/* Convert dBM to internal TX power value */
	if (sc->wi_txpower > 20)
		power = 128;
	else if (sc->wi_txpower < -43)
		power = 127;
	else {
		tmp = sc->wi_txpower;
		tmp = -12 - tmp;
		tmp <<= 2;

		power = (u_int16_t)tmp;
	}

	/* Set manual TX power */
	cmd = WI_CMD_WRITE_MIF;
	if ((error = wi_cmd(sc, cmd,
		 WI_HFA384X_CR_MANUAL_TX_POWER, power, 0)) != 0)
		return (error);

	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf("%s: %u (%d dBm)\n", sc->sc_dev.dv_xname, power,
		    sc->wi_txpower);

	return (0);
}

STATIC int
wi_get_txpower(struct wi_softc *sc, struct ieee80211_txpower *txpower)
{
	u_int16_t	cmd;
	u_int16_t	power;
	int8_t		tmp;
	int		error;

	if (sc->wi_flags & WI_FLAGS_BUS_USB)
		return (EOPNOTSUPP);

	/* Get manual TX power */
	cmd = WI_CMD_READ_MIF;
	if ((error = wi_cmd(sc, cmd,
		 WI_HFA384X_CR_MANUAL_TX_POWER, 0, 0)) != 0)
		return (error);

	power = CSR_READ_2(sc, WI_RESP0);

	/* Convert internal TX power value to dBM */
	if (power > 255)
		txpower->i_val = 255;
	else {
		tmp = power;
		tmp >>= 2;
		txpower->i_val = (u_int16_t)(-12 - tmp);
	}

	if (sc->wi_flags & WI_FLAGS_TXPOWER)
		txpower->i_mode = IEEE80211_TXPOWER_MODE_FIXED;
	else
		txpower->i_mode = IEEE80211_TXPOWER_MODE_AUTO;
	
	return (0);
}

STATIC int
wi_set_ssid(struct ieee80211_nwid *ws, u_int8_t *id, int len)
{

	if (len > IEEE80211_NWID_LEN)
		return (EINVAL);
	ws->i_len = len;
	memcpy(ws->i_nwid, id, len);
	return (0);
}

STATIC int
wi_get_debug(struct wi_softc *sc, struct wi_req *wreq)
{
	int			error = 0;

	wreq->wi_len = 1;

	switch (wreq->wi_type) {
	case WI_DEBUG_SLEEP:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_sleep);
		break;
	case WI_DEBUG_DELAYSUPP:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_delaysupp);
		break;
	case WI_DEBUG_TXSUPP:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_txsupp);
		break;
	case WI_DEBUG_MONITOR:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_monitor);
		break;
	case WI_DEBUG_LEDTEST:
		wreq->wi_len += 3;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_ledtest);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_ledtest_param0);
		wreq->wi_val[2] = htole16(sc->wi_debug.wi_ledtest_param1);
		break;
	case WI_DEBUG_CONTTX:
		wreq->wi_len += 2;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_conttx);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_conttx_param0);
		break;
	case WI_DEBUG_CONTRX:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_contrx);
		break;
	case WI_DEBUG_SIGSTATE:
		wreq->wi_len += 2;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_sigstate);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_sigstate_param0);
		break;
	case WI_DEBUG_CONFBITS:
		wreq->wi_len += 2;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_confbits);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_confbits_param0);
		break;
	default:
		error = EIO;
		break;
	}

	return (error);
}

STATIC int
wi_set_debug(struct wi_softc *sc, struct wi_req *wreq)
{
	int				error = 0;
	u_int16_t			cmd, param0 = 0, param1 = 0;

	switch (wreq->wi_type) {
	case WI_DEBUG_RESET:
	case WI_DEBUG_INIT:
	case WI_DEBUG_CALENABLE:
		break;
	case WI_DEBUG_SLEEP:
		sc->wi_debug.wi_sleep = 1;
		break;
	case WI_DEBUG_WAKE:
		sc->wi_debug.wi_sleep = 0;
		break;
	case WI_DEBUG_CHAN:
		param0 = letoh16(wreq->wi_val[0]);
		break;
	case WI_DEBUG_DELAYSUPP:
		sc->wi_debug.wi_delaysupp = 1;
		break;
	case WI_DEBUG_TXSUPP:
		sc->wi_debug.wi_txsupp = 1;
		break;
	case WI_DEBUG_MONITOR:
		sc->wi_debug.wi_monitor = 1;
		break;
	case WI_DEBUG_LEDTEST:
		param0 = letoh16(wreq->wi_val[0]);
		param1 = letoh16(wreq->wi_val[1]);
		sc->wi_debug.wi_ledtest = 1;
		sc->wi_debug.wi_ledtest_param0 = param0;
		sc->wi_debug.wi_ledtest_param1 = param1;
		break;
	case WI_DEBUG_CONTTX:
		param0 = letoh16(wreq->wi_val[0]);
		sc->wi_debug.wi_conttx = 1;
		sc->wi_debug.wi_conttx_param0 = param0;
		break;
	case WI_DEBUG_STOPTEST:
		sc->wi_debug.wi_delaysupp = 0;
		sc->wi_debug.wi_txsupp = 0;
		sc->wi_debug.wi_monitor = 0;
		sc->wi_debug.wi_ledtest = 0;
		sc->wi_debug.wi_ledtest_param0 = 0;
		sc->wi_debug.wi_ledtest_param1 = 0;
		sc->wi_debug.wi_conttx = 0;
		sc->wi_debug.wi_conttx_param0 = 0;
		sc->wi_debug.wi_contrx = 0;
		sc->wi_debug.wi_sigstate = 0;
		sc->wi_debug.wi_sigstate_param0 = 0;
		break;
	case WI_DEBUG_CONTRX:
		sc->wi_debug.wi_contrx = 1;
		break;
	case WI_DEBUG_SIGSTATE:
		param0 = letoh16(wreq->wi_val[0]);
		sc->wi_debug.wi_sigstate = 1;
		sc->wi_debug.wi_sigstate_param0 = param0;
		break;
	case WI_DEBUG_CONFBITS:
		param0 = letoh16(wreq->wi_val[0]);
		param1 = letoh16(wreq->wi_val[1]);
		sc->wi_debug.wi_confbits = param0;
		sc->wi_debug.wi_confbits_param0 = param1;
		break;
	default:
		error = EIO;
		break;
	}

	if (error)
		return (error);

	cmd = WI_CMD_DEBUG | (wreq->wi_type << 8);
	error = wi_cmd(sc, cmd, param0, param1, 0);

	return (error);
}
@


1.166
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.165 2015/11/25 03:09:58 dlg Exp $	*/
a838 2
	else
		ifp->if_opackets++;
@


1.165
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.164 2015/10/25 12:48:46 mpi Exp $	*/
a230 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.164
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.163 2015/09/11 13:02:28 stsp Exp $	*/
d836 1
a836 1
	ifp->if_flags &= ~IFF_OACTIVE;
d859 1
a859 1
	if (ifp->if_flags & IFF_OACTIVE)
d2202 1
a2202 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2332 1
a2332 1
	if (ifp->if_flags & IFF_OACTIVE)
d2466 1
a2466 1
	ifp->if_flags |= IFF_OACTIVE;
d2541 2
a2542 1
	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);
@


1.163
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.162 2015/06/24 09:40:54 mpi Exp $	*/
a1528 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
d1562 1
a1562 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			wi_init(sc);
			arp_ifinit(&sc->sc_ic.ic_ac, ifa);
			break;
		default:
			wi_init(sc);
			break;
		}
@


1.162
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.161 2015/05/19 11:34:30 mpi Exp $	*/
d2675 3
a2677 3
	int media = sc->sc_media.ifm_cur->ifm_media;
	int options = IFM_OPTIONS(media);
	int subtype;
@


1.161
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.160 2015/03/14 03:38:47 jsg Exp $	*/
a761 2

		ifp->if_ipackets++;
@


1.160
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.159 2014/12/22 02:28:51 tedu Exp $	*/
d534 1
a560 2
		m->m_pkthdr.rcvif = ifp;

a665 1
		m->m_pkthdr.rcvif = ifp;
a818 6
#if NBPFILTER > 0
	/* Handle BPF listeners. */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

d822 4
a825 2
	else
		ether_input_mbuf(ifp, m);
@


1.159
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.158 2014/11/18 02:37:30 tedu Exp $	*/
a78 1
#include <net/if_types.h>
@


1.158
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.157 2014/09/14 14:17:24 jsg Exp $	*/
a80 1
#ifdef INET
a82 1
#endif
a1572 1
#ifdef INET
a1576 1
#endif	/* INET */
@


1.157
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.156 2014/07/22 13:12:12 mpi Exp $	*/
a93 2

#include <dev/rndvar.h>
@


1.156
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.155 2014/07/12 18:48:17 tedu Exp $	*/
a72 1
#include <sys/proc.h>
@


1.155
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.154 2013/11/26 09:50:33 mpi Exp $	*/
a83 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.154
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.153 2013/10/01 19:33:49 kettenis Exp $	*/
d1979 1
a1979 1
			free(nr, M_DEVBUF);
d2034 1
a2034 1
		free(wreq, M_DEVBUF);
d2036 1
a2036 1
		free(nwidp, M_DEVBUF);
@


1.153
log
@Don't claim the interrupt if none of the interrupt status bits were set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.152 2013/08/07 01:06:29 bluhm Exp $	*/
d1397 1
d1411 3
a1413 1
allmulti:
a1425 4
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
@


1.152
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.151 2012/11/29 21:10:31 brad Exp $	*/
d520 3
@


1.151
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.150 2011/06/21 16:52:45 tedu Exp $	*/
a84 1
#include <netinet/in_var.h>
@


1.150
log
@remove some unnecessary casts.  ok blambert deraadt kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.149 2010/08/30 20:42:27 deraadt Exp $	*/
a239 1
	ifp->if_baudrate = 10000000;
@


1.149
log
@ioctl versus resume-workq exclusion; cloned from iwn
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.148 2010/07/02 02:40:15 blambert Exp $	*/
d229 1
a229 2
	bcopy((char *)&mac.wi_mac_addr, (char *)&ic->ic_myaddr,
	    IEEE80211_ADDR_LEN);
d334 1
a334 1
	bzero((char *)&sc->wi_stats, sizeof(sc->wi_stats));
d732 6
a737 6
			bcopy((char *)&rx_frame.wi_dst_addr,
			    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);
			bcopy((char *)&rx_frame.wi_src_addr,
			    (char *)&eh->ether_shost, ETHER_ADDR_LEN);
			bcopy((char *)&rx_frame.wi_type,
			    (char *)&eh->ether_type, ETHER_TYPE_LEN);
d1404 1
a1404 1
	bzero((char *)&mcast, sizeof(mcast));
d1418 1
a1418 1
			bzero((char *)&mcast, sizeof(mcast));
d1426 1
a1426 2
		bcopy(enm->enm_addrlo, (char *)&mcast.wi_mcast[i],
		    ETHER_ADDR_LEN);
d1447 2
a1448 4
		bcopy((char *)&wreq->wi_val, LLADDR(ifp->if_sadl),
		    ETHER_ADDR_LEN);
		bcopy((char *)&wreq->wi_val, (char *)&sc->sc_ic.ic_myaddr,
		    ETHER_ADDR_LEN);
d1514 1
a1514 2
		bcopy((char *)wreq, (char *)&sc->wi_keys,
		    sizeof(struct wi_ltv_keys));
d1626 1
a1626 1
			bcopy((char *)&sc->wi_stats, (char *)&wreq->wi_val,
d1635 1
a1635 1
				bcopy((char *)&sc->wi_keys, wreq,
d2159 2
a2160 4
	bcopy(LLADDR(ifp->if_sadl),
	    (char *)&sc->sc_ic.ic_myaddr, ETHER_ADDR_LEN);
	bcopy((char *)&sc->sc_ic.ic_myaddr,
	    (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);
d2264 2
a2265 2
	bcopy((char *)&sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keydat,
	    (char *)key + IEEE80211_WEP_IVLEN, klen);
d2316 2
a2317 2
	bcopy((char *)&sc->wi_keys.wi_keys[kid].wi_keydat,
	    (char *)key + IEEE80211_WEP_IVLEN, klen);
d2367 1
a2367 1
	bzero((char *)&tx_frame, sizeof(tx_frame));
d2393 2
a2394 2
		bcopy((char *)&eh->ether_dhost,
		    (char *)&tx_frame.wi_addr1, ETHER_ADDR_LEN);
d2398 4
a2401 4
			bcopy((char *)&sc->sc_ic.ic_myaddr,
			    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
			bcopy((char *)&eh->ether_shost,
			    (char *)&tx_frame.wi_addr3, ETHER_ADDR_LEN);
d2408 4
a2411 4
			bcopy((char *)&sc->sc_ic.ic_myaddr,
			    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
			bcopy((char *)&eh->ether_dhost,
			    (char *)&tx_frame.wi_addr3, ETHER_ADDR_LEN);
d2414 4
a2417 6
			bcopy((char *)&eh->ether_shost,
			    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
		bcopy((char *)&eh->ether_dhost,
		    (char *)&tx_frame.wi_dst_addr, ETHER_ADDR_LEN);
		bcopy((char *)&eh->ether_shost,
		    (char *)&tx_frame.wi_src_addr, ETHER_ADDR_LEN);
d2520 1
a2520 1
	bzero((char *)&tx_frame, sizeof(tx_frame));
d2523 1
a2523 2
	bcopy((char *)hdr, (char *)&tx_frame.wi_frame_ctl,
	   sizeof(struct wi_80211_hdr));
@


1.148
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.147 2010/05/20 14:03:05 nicm Exp $	*/
d1547 2
a1548 2
	struct wi_softc		*sc;
	struct ifreq		*ifr;
a1554 1

d1560 4
d1565 7
a1571 4
	sc = ifp->if_softc;
	ifr = (struct ifreq *)data;

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED)) {
d1573 1
a1573 1
		return(ENODEV);
d1575 2
d2043 3
@


1.147
log
@Split some copies of two struct members together into two bcopy rather
than one to make gcc4 -Wbounded happy.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.146 2009/10/27 23:59:34 deraadt Exp $	*/
d808 2
a809 1
				    IEEE80211_WEP_KIDLEN + WI_SNAPHDR_LEN);
@


1.146
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.145 2009/08/10 20:29:54 deraadt Exp $	*/
d2426 2
a2427 1
			bcopy(&tx_frame.wi_dat[0], &sc->wi_txbuf[4], 8);
@


1.145
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.144 2009/06/03 20:35:37 beck Exp $	*/
a125 5

#if !defined(lint) && !defined(__OpenBSD__)
static const char rcsid[] =
	"$OpenBSD: if_wi.c,v 1.144 2009/06/03 20:35:37 beck Exp $";
#endif	/* lint */
@


1.144
log
@make wireless interfaces priority 4 by default. other interfaces remain
priority 0.  while we are in here make sure we add wi interfaces to group "wlan"
in the same way the net80211 stuff already is.

this makes dhcp multiple default routes useful on laptops.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.143 2008/11/28 02:44:17 brad Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.143 2008/11/28 02:44:17 brad Exp $";
a140 1
STATIC void wi_shutdown(void *);
a447 2
	sc->sc_sdhook = shutdownhook_establish(wi_shutdown, sc);

a2604 2
		if (sc->sc_sdhook != NULL)
			shutdownhook_disestablish(sc->sc_sdhook);
a2605 11
}

STATIC void
wi_shutdown(void *arg)
{
	struct wi_softc		*sc;

	sc = arg;
	wi_stop(sc);

	return;
@


1.143
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.142 2008/10/15 19:12:19 blambert Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.142 2008/10/15 19:12:19 blambert Exp $";
d450 3
@


1.142
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.141 2008/10/02 20:21:13 brad Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.141 2008/10/02 20:21:13 brad Exp $";
a1591 9

	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;

a1610 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		/* Update our multicast list. */
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ic.ic_ac) :
		    ether_delmulti(ifr, &sc->sc_ic.ic_ac);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				wi_setmulti(sc);
			error = 0;
		}
		break;
d2026 6
@


1.141
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.140 2008/04/18 09:16:14 djm Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.140 2008/04/18 09:16:14 djm Exp $";
d876 1
a876 1
	timeout_add(&sc->sc_timo, hz * 60);
d2251 1
a2251 1
	timeout_add(&sc->sc_timo, hz * 60);
@


1.140
log
@extend the if_ethersubr.c crc functions to support updating a running
crc in addition to the existing "oneshot" mode and use them to replace
ieee80211_crc_update() with the new ether_crc32_le_update(). Saves 1k
kernel bss + some code.

Mark the new ether_crc32_[lb]e_update functions as __pure for a
~25x speedup (on my i386 at least).

feedback and ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.139 2008/04/17 19:26:51 damien Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.139 2008/04/17 19:26:51 damien Exp $";
a1576 5
	if ((error = ether_ioctl(ifp, &sc->sc_ic.ic_ac, command, data)) > 0) {
		splx(s);
		return error;
	}

d2051 1
a2051 2
		error = EINVAL;
		break;
d2058 1
@


1.139
log
@save some space by making use of the WEP CRC table from net80211
and use the ieee80211_crc_update() function too.

not tested as I do not have a wi(4) but I see no reason why it
would not work.

"Just be brave" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.138 2007/09/17 01:33:33 krw Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.138 2007/09/17 01:33:33 krw Exp $";
a211 1
	extern void ieee80211_crc_init(void);
a224 3
	/* make use of the WEP CRC table from net80211 */
	ieee80211_crc_init();

d2305 1
a2305 3
	crc = ~0;
	crc = ieee80211_crc_update(crc, dat, len);
	crc = ~crc;
d2350 1
a2350 3
	crc = ~0;
	crc = ieee80211_crc_update(crc, dat, len);
	crc = ~crc;
@


1.138
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.137 2006/11/26 19:46:28 deraadt Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.137 2006/11/26 19:46:28 deraadt Exp $";
d212 1
d226 3
a2264 67
static const u_int32_t crc32tab[] = {
	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL,
	0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L,
	0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L,
	0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L,
	0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
	0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L,
	0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL,
	0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L,
	0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L,
	0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
	0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L,
	0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L,
	0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L,
	0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL,
	0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
	0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL,
	0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL,
	0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L,
	0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L,
	0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
	0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL,
	0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L,
	0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL,
	0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L,
	0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
	0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL,
	0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L,
	0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L,
	0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L,
	0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
	0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L,
	0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL,
	0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL,
	0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L,
	0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
	0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L,
	0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL,
	0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L,
	0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL,
	0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
	0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L,
	0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL,
	0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L,
	0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L,
	0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
	0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL,
	0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L,
	0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL,
	0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL,
	0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
	0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L,
	0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L,
	0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL,
	0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L,
	0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
	0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L,
	0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L,
	0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL,
	0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L,
	0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
	0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L,
	0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL,
	0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L,
	0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL
};

d2268 1
a2268 1
	u_int32_t i, crc, klen;
d2310 1
a2310 2
	for (i = 0; i < len; i++)
		crc = crc32tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
d2326 1
a2326 1
	u_int32_t i, crc, klen, kid;
d2357 1
a2357 2
	for (i = 0; i < len; i++)
		crc = crc32tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
@


1.137
log
@avoid extra inclusions; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.136 2006/11/21 23:00:16 miod Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.136 2006/11/21 23:00:16 miod Exp $";
d1647 1
a1647 2
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
		bzero(wreq, sizeof(*wreq));
d1704 1
a1704 2
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
		bzero(wreq, sizeof(*wreq));
d1771 1
a1771 2
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
		bzero(wreq, sizeof(*wreq));
d1787 1
a1787 2
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
		bzero(wreq, sizeof(*wreq));
d1799 1
a1799 2
			wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
			bzero(wreq, sizeof(*wreq));
d1806 2
a1807 2
				nwidp = malloc(sizeof *nwidp, M_DEVBUF, M_WAITOK);
				bzero(nwidp, sizeof(*nwidp));
d1866 1
a1866 2
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
		bzero(wreq, sizeof(*wreq));
d1875 1
a1875 2
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
		bzero(wreq, sizeof(*wreq));
d1887 1
a1887 2
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
		bzero(wreq, sizeof(*wreq));
d1909 1
a1909 2
			wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
			bzero(wreq, sizeof(*wreq));
d1945 1
a1945 2
		wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
		bzero(wreq, sizeof(*wreq));
d2019 1
a2019 2
			wreq = malloc(sizeof *wreq, M_DEVBUF, M_WAITOK);
			bzero(wreq, sizeof(*wreq));
@


1.136
log
@Fail wi_get_txpower() on USB wi(4), so that we don't CSR_READ on them.
ok mickey@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.135 2006/11/06 10:49:01 jsg Exp $	*/
d90 1
a90 1
#include <net80211/ieee80211.h>
a91 1
#include <net80211/ieee80211_var.h>
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.135 2006/11/06 10:49:01 jsg Exp $";
@


1.135
log
@Don't advertise USB wi adapters as supported hostap devices,
the code would need to be largely overhauled if the hardware
actually supports it.

Fixes a panic when trying to set hostap on a usb wi, PR 5154.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.134 2006/08/17 20:36:35 deraadt Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.134 2006/08/17 20:36:35 deraadt Exp $";
d3181 3
@


1.134
log
@reduce the stack usage of the ioctl function by malloc/free'ing a number
of larger structures as need be.  This was one of the worst offenders
in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.133 2006/07/01 20:22:22 reyk Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.133 2006/07/01 20:22:22 reyk Exp $";
d308 6
a313 1
			if (sc->sc_sta_firmware_ver != 10402)
@


1.133
log
@always report the channel as type 802.11b (IEEE802_CHAN_B) in the
net80211 node wrappers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.132 2006/07/01 19:30:51 reyk Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.132 2006/07/01 19:30:51 reyk Exp $";
d1233 1
d1553 1
a1553 1
	struct wi_req		wreq;
d1556 1
a1556 2
	struct ieee80211_nwid		nwid;
	struct ieee80211_nodereq	nr;
d1643 3
a1645 1
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
d1648 1
a1648 1
		if (wreq.wi_len > WI_MAX_DATALEN) {
d1652 1
a1652 1
		switch (wreq.wi_type) {
d1655 1
a1655 1
			bcopy((char *)&sc->wi_stats, (char *)&wreq.wi_val,
d1657 1
a1657 1
			wreq.wi_len = (sizeof(sc->wi_stats) / 2) + 1;
d1662 1
a1662 2
				bzero((char *)&wreq,
					sizeof(struct wi_ltv_keys));
d1664 1
a1664 1
				bcopy((char *)&sc->wi_keys, (char *)&wreq,
d1668 2
a1669 2
			wreq.wi_len = 2;
			wreq.wi_val[0] = htole16(sc->wi_procframe);
d1672 2
a1673 2
			wreq.wi_len = 2;
			wreq.wi_val[0] = htole16(sc->sc_firmware_type ==
d1677 1
a1677 1
			wreq.wi_val[0] =
d1679 1
a1679 1
			wreq.wi_len = 1;
d1683 1
a1683 1
				memcpy((char *)wreq.wi_val,
d1686 1
a1686 1
				wreq.wi_len = sc->wi_scanbuf_len;
d1691 1
a1691 1
			if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq)) {
d1696 1
a1696 1
		error = copyout(&wreq, ifr->ifr_data, sizeof(wreq));
d1701 3
a1703 1
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
d1707 1
a1707 1
		if (wreq.wi_len > WI_MAX_DATALEN)
d1709 1
a1709 1
		switch (wreq.wi_type) {
d1713 2
a1714 2
			error = wi_mgmt_xmit(sc, (caddr_t)&wreq.wi_val,
			    wreq.wi_len);
d1717 1
a1717 1
			sc->wi_procframe = letoh16(wreq.wi_val[0]);
d1727 1
a1727 1
				    (struct wi_ltv_gen *)&wreq);
d1731 1
a1731 1
				error = wi_setdef(sc, &wreq);
d1746 1
a1746 1
			if ((wreq.wi_type == WI_RID_SYMBOL_DIVERSITY &&
d1748 1
a1748 1
			    (wreq.wi_type == WI_RID_ROAMING_MODE &&
d1750 1
a1750 1
			    (wreq.wi_type == WI_RID_CREATE_IBSS &&
d1752 1
a1752 1
			    (wreq.wi_type == WI_RID_MICROWAVE_OVEN &&
d1754 1
a1754 1
			    (wreq.wi_type == WI_RID_ENH_SECURITY &&
d1756 2
a1757 2
			    (wreq.wi_type == WI_RID_OWN_SSID &&
			    wreq.wi_len != 0))
d1761 1
a1761 1
			error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
d1763 1
a1763 1
				error = wi_setdef(sc, &wreq);
d1769 3
a1771 1
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
d1779 1
a1779 1
		error = wi_get_debug(sc, &wreq);
d1781 1
a1781 1
			error = copyout(&wreq, ifr->ifr_data, sizeof(wreq));
d1786 3
a1788 1
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
d1791 1
a1791 1
		error = wi_set_debug(sc, &wreq);
d1799 6
a1804 4
			wreq.wi_type = WI_RID_CURRENT_SSID;
			wreq.wi_len = WI_MAX_DATALEN;
			if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) ||
			    letoh16(wreq.wi_val[0]) > IEEE80211_NWID_LEN)
d1807 6
a1812 4
				wi_set_ssid(&nwid, (u_int8_t *)&wreq.wi_val[1],
				    letoh16(wreq.wi_val[0]));
				error = copyout(&nwid, ifr->ifr_data,
				    sizeof(nwid));
d1819 2
a1820 1
		error = copyin(ifr->ifr_data, &nwid, sizeof(nwid));
d1823 1
a1823 1
		if (nwid.i_len > IEEE80211_NWID_LEN) {
d1827 2
a1828 2
		if (sc->wi_net_name.i_len == nwid.i_len &&
		    memcmp(sc->wi_net_name.i_nwid, nwid.i_nwid, nwid.i_len) == 0)
d1830 1
a1830 1
		wi_set_ssid(&sc->wi_net_name, nwid.i_nwid, nwid.i_len);
d1867 4
a1870 2
		wreq.wi_type = WI_RID_OWN_CHNL;
		wreq.wi_val[0] =
d1872 1
a1872 1
		error = wi_setdef(sc, &wreq);
d1877 5
a1881 3
		wreq.wi_type = WI_RID_CURRENT_CHAN;
		wreq.wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq)) {
d1886 1
a1886 1
		    letoh16(wreq.wi_val[0]);
d1890 5
a1894 3
		wreq.wi_type = WI_RID_CURRENT_BSSID;
		wreq.wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq)) {
d1898 1
a1898 1
		IEEE80211_ADDR_COPY(bssid->i_bssid, wreq.wi_val);
d1913 6
a1918 4
			wreq.wi_len = 3;
			wreq.wi_type = WI_RID_SCAN_REQ;
			wreq.wi_val[0] = 0x3FFF;
			wreq.wi_val[1] = 0x000F;
d1921 1
a1921 1
			    (struct wi_ltv_gen *)&wreq);
d1939 3
d1950 4
a1953 2
		wreq.wi_len = WI_MAX_DATALEN;
		wreq.wi_type = WI_RID_SCAN_RES;
d1955 1
a1955 1
			bcopy(sc->wi_scanbuf, wreq.wi_val,
d1957 1
a1957 1
			wreq.wi_len = sc->wi_scanbuf_len;
d1961 1
a1961 1
			if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq)) {
d1965 1
a1965 1
			p2 = (struct wi_scan_p2_hdr *)wreq.wi_val;
d1972 1
a1972 1
		for (na->na_nodes = j = 0; (i < (wreq.wi_len * 2) - len) &&
d1975 4
a1978 1
			res = (struct wi_scan_res *)((char *)wreq.wi_val + i);
d1982 12
a1993 12
			bzero(&nr, sizeof(nr));
			IEEE80211_ADDR_COPY(nr.nr_macaddr, res->wi_bssid);
			IEEE80211_ADDR_COPY(nr.nr_bssid, res->wi_bssid);
			nr.nr_channel = letoh16(res->wi_chan);
			nr.nr_chan_flags = IEEE80211_CHAN_B;
			nr.nr_rssi = letoh16(res->wi_signal);
			nr.nr_max_rssi = 0; /* XXX */
			nr.nr_nwid_len = letoh16(res->wi_ssid_len);
			bcopy(res->wi_ssid, nr.nr_nwid, nr.nr_nwid_len);
			nr.nr_intval = letoh16(res->wi_interval);
			nr.nr_capinfo = letoh16(res->wi_capinfo);
			nr.nr_txrate = res->wi_rate == WI_WAVELAN_RES_1M ? 2 :
d1997 4
a2000 4
			nr.nr_nrates = 0;
			while (res->wi_srates[nr.nr_nrates] != 0) {
				nr.nr_rates[nr.nr_nrates] =
				    res->wi_srates[nr.nr_nrates] &
d2002 1
a2002 1
				nr.nr_nrates++;
d2004 2
a2005 2
			nr.nr_flags = 0;
			if (bcmp(nr.nr_macaddr, nr.nr_bssid,
d2007 1
a2007 1
				nr.nr_flags |= IEEE80211_NODEREQ_AP;
d2009 1
a2009 1
			error = copyout(&nr, (caddr_t)na->na_node + j,
d2016 2
d2019 1
d2025 5
a2029 3
			wreq.wi_len = WI_MAX_DATALEN;
			wreq.wi_type = WI_RID_ENH_SECURITY;
			if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq)) {
d2033 1
a2033 1
			sc->wi_enh_security = letoh16(wreq.wi_val[0]);
d2067 4
@


1.132
log
@update the 802.11 address as well if the interface mac address has
been changed by the user, ie. with the ifconfig lladdr command. this
also replaces the old wicontrol -m option.

this closes pr 5159 from peter philipp at freenet dot de.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.131 2006/06/27 20:55:51 reyk Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.131 2006/06/27 20:55:51 reyk Exp $";
d1958 1
@


1.131
log
@add the net80211 hostap options "nwflag hidenwid" for hidden SSID mode
and "nwflag nobridge" to prevent inter-station communications.
"hidenwid" will also work with wi(4) to replace the old -E 3 option of
wicontrol.

ok damien@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.130 2006/06/27 09:48:02 reyk Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.130 2006/06/27 09:48:02 reyk Exp $";
d2151 2
d2154 1
a2154 1
	   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);
@


1.130
log
@add some more net80211 compatibility glue:
- support scanning and node listing ("ifconfig -M"). this will replace
wicontrol -L in station mode and wicontrol -l in hostap mode.
- allow to print the BSSID

tested by quite a few people
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.129 2006/05/22 20:35:12 krw Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.129 2006/05/22 20:35:12 krw Exp $";
d1553 1
d1986 31
@


1.129
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.128 2006/04/10 00:58:52 deraadt Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.128 2006/04/10 00:58:52 deraadt Exp $";
d183 1
d1545 1
a1545 1
	int			s, error = 0;
a1546 1
	struct wi_req		wreq;
d1550 8
a1557 1
	struct ieee80211_nwid	nwid;
d1871 116
d2003 39
@


1.128
log
@under some cases some wi(4) cards freak out and then do not recover.
make the driver reset in those cases.  this needs testing, which is
why it is being commited; from kuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.127 2006/03/25 22:41:43 djm Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.127 2006/03/25 22:41:43 djm Exp $";
d2476 2
a2477 1
		shutdownhook_disestablish(sc->sc_sdhook);
@


1.127
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.126 2005/12/03 21:11:47 brad Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.126 2005/12/03 21:11:47 brad Exp $";
d2410 6
@


1.126
log
@splimp -> splnet

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.125 2005/11/28 00:17:14 jsg Exp $	*/
a107 1
#define BPF_MTAP(if,mbuf) bpf_mtap((if)->if_bpf, (mbuf))
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.125 2005/11/28 00:17:14 jsg Exp $";
d831 1
a831 1
		BPF_MTAP(ifp, m);
d2360 1
a2360 1
		BPF_MTAP(ifp, m0);
@


1.125
log
@Correctly report channel. PR 4728.
ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.124 2005/11/01 03:10:21 jsg Exp $	*/
d131 1
a131 1
	"$OpenBSD: if_wi.c,v 1.124 2005/11/01 03:10:21 jsg Exp $";
d878 1
a878 1
	s = splimp();
d1553 1
a1553 1
	s = splimp();
d1896 1
a1896 1
	s = splimp();
@


1.124
log
@Remove the call to ieee80211_ifattach() for the moment as it
makes wi prematurely depend on net80211 code which bloats the
ramdisks.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.123 2005/10/31 05:37:12 jsg Exp $	*/
d131 1
a131 1
	"$OpenBSD: if_wi.c,v 1.123 2005/10/31 05:37:12 jsg Exp $";
d1856 6
d1863 1
a1863 1
		    sc->wi_channel;
@


1.123
log
@Move from arpcom to ieee80211com in wi softc.  This will be
required for net80211 support.
Updated version of a diff from dlg@@
similiar diff ok fgsch@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.122 2005/10/19 20:04:43 fgsch Exp $	*/
d131 1
a131 1
	"$OpenBSD: if_wi.c,v 1.122 2005/10/19 20:04:43 fgsch Exp $";
d434 3
a436 1
	ieee80211_ifattach(ifp);
@


1.122
log
@add support to change the channel from ifconfig; tested by some,
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.121 2005/10/15 00:20:49 fgsch Exp $	*/
d92 1
d131 1
a131 1
	"$OpenBSD: if_wi.c,v 1.121 2005/10/15 00:20:49 fgsch Exp $";
d213 2
a217 1
	struct ifnet		*ifp;
d220 3
d236 2
a237 2
	bcopy((char *)&mac.wi_mac_addr, (char *)&sc->sc_arpcom.ac_enaddr,
	    ETHER_ADDR_LEN);
d240 1
a240 1
	printf("address %s", ether_sprintf(sc->sc_arpcom.ac_enaddr));
a241 1
	ifp = &sc->sc_arpcom.ac_if;
d434 1
a434 1
	ether_ifattach(ifp);
d440 1
a440 2
	BPFATTACH(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
d474 1
a474 1
	ifp = &sc->sc_arpcom.ac_if;
d547 1
a547 1
	ifp = &sc->sc_arpcom.ac_if;
d698 1
a698 1
				if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d788 1
a788 1
					if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d847 1
a847 1
	ifp = &sc->sc_arpcom.ac_if;
d868 1
a868 1
	ifp = &sc->sc_arpcom.ac_if;
d896 1
a896 1
	ifp = &sc->sc_arpcom.ac_if;
d947 1
a947 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d975 1
a975 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d1400 1
a1400 1
	ifp = &sc->sc_arpcom.ac_if;
d1413 1
a1413 1
	ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
d1442 1
a1442 1
	ifp = &sc->sc_arpcom.ac_if;
d1448 1
a1448 1
		bcopy((char *)&wreq->wi_val, (char *)&sc->sc_arpcom.ac_enaddr,
d1564 1
a1564 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d1576 1
a1576 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1616 2
a1617 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
d1878 1
a1878 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d1950 1
a1950 1
	bcopy((char *)&sc->sc_arpcom.ac_enaddr,
d2197 1
a2197 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d2262 1
a2262 1
			bcopy((char *)&sc->sc_arpcom.ac_enaddr,
d2272 1
a2272 1
			bcopy((char *)&sc->sc_arpcom.ac_enaddr,
d2423 1
a2423 1
	ifp = &sc->sc_arpcom.ac_if;
d2456 1
a2456 1
	ifp = &sc->sc_arpcom.ac_if;
d2677 1
a2677 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
d2694 1
a2694 1
	if (!(sc->sc_arpcom.ac_if.if_flags & IFF_UP)) {
d2774 1
a2774 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
d2785 1
a2785 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
d2795 1
a2795 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
d2803 1
a2803 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP)
d2846 1
a2846 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP)
d2914 1
a2914 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
@


1.121
log
@correctly parse the supported data rates. needed by wi@@usb.
tested by jsg@@ and joris@@, deraadt@@ go ahead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.120 2005/09/18 09:24:03 jsg Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.120 2005/09/18 09:24:03 jsg Exp $";
d1835 18
@


1.120
log
@ansi. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.119 2005/07/31 23:08:58 pascoe Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.119 2005/07/31 23:08:58 pascoe Exp $";
d213 1
d336 13
a348 3
	gen.wi_type = WI_RID_DATA_RATES;
	gen.wi_len = 2;
	if (wi_read_record(sc, &gen))
a350 2
	else
		sc->wi_supprates = gen.wi_val;
@


1.119
log
@Move large receive/decryption buffer allocation from the stack into
wi_softc.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.118 2005/07/12 17:23:19 jsg Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.118 2005/07/12 17:23:19 jsg Exp $";
d454 1
a454 2
wi_intr(vsc)
	void			*vsc;
d525 1
a525 2
wi_rxeof(sc)
	struct wi_softc		*sc;
d831 1
a831 3
wi_txeof(sc, status)
	struct wi_softc		*sc;
	int			status;
d849 1
a849 2
wi_inquire(xsc)
	void			*xsc;
d875 1
a875 2
wi_update_stats(sc)
	struct wi_softc		*sc;
d925 1
a925 6
wi_cmd_io(sc, cmd, val0, val1, val2)
	struct wi_softc		*sc;
	int			cmd;
	int			val0;
	int			val1;
	int			val2;
d974 1
a974 2
wi_reset(sc)
	struct wi_softc		*sc;
d1007 1
a1007 2
wi_cor_reset(sc)
	struct wi_softc		*sc;
d1037 1
a1037 3
wi_read_record_io(sc, ltv)
	struct wi_softc		*sc;
	struct wi_ltv_gen	*ltv;
d1137 1
a1137 3
wi_write_record_io(sc, ltv)
	struct wi_softc		*sc;
	struct wi_ltv_gen	*ltv;
d1255 1
a1255 3
wi_seek(sc, id, off, chan)
	struct wi_softc		*sc;
	int			id, off, chan;
d1289 1
a1289 5
wi_read_data_io(sc, id, off, buf, len)
	struct wi_softc		*sc;
	int			id, off;
	caddr_t			buf;
	int			len;
d1315 1
a1315 5
wi_write_data_io(sc, id, off, buf, len)
	struct wi_softc		*sc;
	int			id, off;
	caddr_t			buf;
	int			len;
d1349 1
a1349 4
wi_alloc_nicmem_io(sc, len, id)
	struct wi_softc		*sc;
	int			len;
	int			*id;
d1380 1
a1380 2
wi_setmulti(sc)
	struct wi_softc		*sc;
d1425 1
a1425 3
wi_setdef(sc, wreq)
	struct wi_softc		*sc;
	struct wi_req		*wreq;
d1529 1
a1529 4
wi_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d1846 1
a1846 2
wi_init_io(sc)
	struct wi_softc		*sc;
d2178 1
a2178 2
wi_start(ifp)
	struct ifnet		*ifp;
d2342 1
a2342 4
wi_mgmt_xmit(sc, data, len)
	struct wi_softc		*sc;
	caddr_t			data;
	int			len;
d2380 1
a2380 2
wi_stop(sc)
	struct wi_softc		*sc;
d2406 1
a2406 2
wi_watchdog(ifp)
	struct ifnet		*ifp;
d2423 1
a2423 2
wi_detach(sc)
	struct wi_softc *sc;
d2438 1
a2438 2
wi_shutdown(arg)
	void			*arg;
d2449 1
a2449 2
wi_get_id(sc)
	struct wi_softc *sc;
d2533 1
a2533 4
wi_sync_media(sc, ptype, txrate)
	struct wi_softc *sc;
	int ptype;
	int txrate;
d2592 1
a2592 2
wi_media_change(ifp)
	struct ifnet *ifp;
d2659 1
a2659 3
wi_media_status(ifp, imr)
	struct ifnet *ifp;
	struct ifmediareq *imr;
d2718 1
a2718 3
wi_set_nwkey(sc, nwkey)
	struct wi_softc *sc;
	struct ieee80211_nwkey *nwkey;
d2779 1
a2779 3
wi_get_nwkey(sc, nwkey)
	struct wi_softc *sc;
	struct ieee80211_nwkey *nwkey;
d2925 1
a2925 4
wi_set_ssid(ws, id, len)
	struct ieee80211_nwid *ws;
	u_int8_t *id;
	int len;
d2936 1
a2936 3
wi_get_debug(sc, wreq)
	struct wi_softc		*sc;
	struct wi_req		*wreq;
d2993 1
a2993 3
wi_set_debug(sc, wreq)
	struct wi_softc		*sc;
	struct wi_req		*wreq;
@


1.118
log
@Print the card number the chipset string is obtained from.
As this is not a 1 to 1 mapping it can be useful to know
this number, in particular if you have a broken device and
want to upgrade the firmware.
Prodded by jolan@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.117 2005/04/03 08:07:00 uwe Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.117 2005/04/03 08:07:00 uwe Exp $";
a766 1
			u_int8_t rx_buf[1596];
d773 1
a773 1
				    (caddr_t)rx_buf);
d776 1
a776 1
				if (wi_do_hostdecrypt(sc, rx_buf +
d795 1
a795 1
				    rx_buf + sizeof(struct ether_header) +
@


1.117
log
@make wi_ioctl() easier to audit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.116 2005/02/15 19:44:15 reyk Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.116 2005/02/15 19:44:15 reyk Exp $";
d2569 1
a2569 1
		printf("%s: %s%s, Firmware %d.%d.%d (primary), %d.%d.%d (station), ",
d2572 2
a2573 2
		    card_name, pri_fw_ver[0], pri_fw_ver[1], pri_fw_ver[2],
		    sc->sc_sta_firmware_ver / 10000,
@


1.116
log
@add the manual tx power option. this is supported by some prism2/2.5/3
cards in hostap mode but it depends on the firmware version. support
for other wireless chipsets will be added in the future using the
net80211-framework.

ok robert@@ bob@@ danh@@, tested by some others
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.115 2005/01/15 05:24:11 brad Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.115 2005/01/15 05:24:11 brad Exp $";
a1594 16
	case SIOCSWAVELAN:
	case SIOCSPRISM2DEBUG:
	case SIOCS80211NWID:
	case SIOCS80211NWKEY:
	case SIOCS80211POWER:
	case SIOCS80211TXPOWER:
		error = suser(p, 0);
		if (error) {
			splx(s);
			return (error);
		}
	default:
		break;
	}

	switch(command) {
d1714 2
d1795 2
d1822 2
d1841 2
d1849 2
d1857 2
@


1.115
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.114 2004/12/22 02:19:11 millert Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.114 2004/12/22 02:19:11 millert Exp $";
d170 2
d1600 1
d1862 6
d2020 4
d2890 92
@


1.114
log
@Do a COR reset on prism cards too in the watchdog reset.  Helps recover
things when older prism firmware gets wedged.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.113 2004/11/23 21:12:23 fgsch Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.113 2004/11/23 21:12:23 fgsch Exp $";
d1656 1
d1662 2
a1663 1
			wi_setmulti(sc);
@


1.113
log
@replace old net/if_ieee80211.h header with the net80211 ones, kernel part.
millert@@ mcbride@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.112 2004/10/20 12:53:28 deraadt Exp $	*/
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.112 2004/10/20 12:53:28 deraadt Exp $";
d1029 1
a1029 1
	 * we only soft reset Symbol cards for now.
d1031 1
a1031 1
	if (sc->sc_firmware_type == WI_SYMBOL) {
@


1.112
log
@put newlines at slightly different places during attach, leading to clean
USB attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.111 2004/08/16 03:42:22 millert Exp $	*/
d90 2
a91 1
#include <net/if_ieee80211.h>
d130 1
a130 1
	"$OpenBSD: if_wi.c,v 1.111 2004/08/16 03:42:22 millert Exp $";
@


1.111
log
@crank wi_cmd_count to 2000 for the time being; should help avoid
timeouts on cards with station firmware < 1.8.  Better fix coming
post-3.6...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.110 2004/06/22 20:48:00 millert Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.110 2004/06/22 20:48:00 millert Exp $";
d2554 1
a2554 1
		printf("\n%s: Firmware %d.%02d variant %d, ", WI_PRT_ARG(sc),
d2557 1
a2557 1
		printf("\n%s: %s%s, Firmware %d.%d.%d (primary), %d.%d.%d (station), ",
@


1.110
log
@The Prism device driver's manual makes a distinction in naming of
config comands and other types but we don't so remove the CNF_ from
WI_RID_CNF_ENH_SECURITY and WI_RID_CNF_DBM_ADJUST for consistency
and compat with Net and Free.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.109 2004/05/31 19:32:30 mcbride Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.109 2004/05/31 19:32:30 mcbride Exp $";
d296 2
@


1.109
log
@When loading multicast filters, accept all multicast when we encounter
a range instead of ignoring it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.108 2004/03/18 16:16:10 millert Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.108 2004/03/18 16:16:10 millert Exp $";
d1522 1
a1522 1
	case WI_RID_CNF_ENH_SECURITY:
d1760 1
a1760 1
		case WI_RID_CNF_ENH_SECURITY:
d1773 1
a1773 1
			    (wreq.wi_type == WI_RID_CNF_ENH_SECURITY &&
d1919 1
a1919 1
		WI_SETVAL(WI_RID_CNF_ENH_SECURITY, sc->wi_enh_security);
@


1.108
log
@Starting with Prism firmware version 1.6.3, HostAP supports an
enhanced security mode whereby the SSID can be hidden from snoopers.
Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.107 2004/03/15 21:50:26 millert Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.107 2004/03/15 21:50:26 millert Exp $";
d1422 1
d1435 4
a1438 4
		/* Punt on ranges. */
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    sizeof(enm->enm_addrlo)) != 0)
			break;
@


1.107
log
@Make software WEP work in BSS (station) mode.  Based on patches from
Jamison M. Adcock.  Software WEP is still unsupported in ad-hoc or
IBSS mode at the present time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.106 2004/03/12 20:50:45 millert Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.106 2004/03/12 20:50:45 millert Exp $";
d304 2
d1521 3
d1759 1
d1772 2
d1915 4
@


1.106
log
@Add a missing htole16() that broke software WEP on big endian machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.105 2004/03/02 21:59:29 millert Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.105 2004/03/02 21:59:29 millert Exp $";
d2196 1
a2196 1
	int			id;
d2214 1
a2214 1
	tx_frame.wi_frame_ctl = htole16(WI_FTYPE_DATA);
d2244 4
d2249 5
a2253 1
				tx_frame.wi_frame_ctl |= htole16(WI_FCTL_WEP);
d2256 1
a2256 1
			bcopy((char *)&eh->ether_shost,
d2258 1
d2273 1
a2273 1
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP && sc->wi_use_wep) {
d2276 1
@


1.105
log
@Fix timing issues with newer Prism firmware and retry card reset up
to three times (only once for Symbol though).  This fixes intermittent
problems on Prism-based cards with newer firmware.  Tested with a
wide variety of cards and firmware revisions.  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.104 2004/03/02 21:55:07 millert Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.104 2004/03/02 21:55:07 millert Exp $";
d758 1
a758 1
		    rx_frame.wi_frame_ctl & WI_FCTL_WEP) {
@


1.104
log
@Make HostAP work Prism cards with newer firmware (1.7.0 and higher).
Accept probe packets that Lucent cards send when the associated AP
disapears; this speeds up reassocication with those cards.  Don't
advertise HostAP as being available for firmware 1.4.2.  I added a
note about this in the man pages a while ago but forgot to update
the driver itself.  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.103 2004/02/27 21:34:58 millert Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.103 2004/02/27 21:34:58 millert Exp $";
d215 1
d293 3
d935 1
a935 1
	for (i = 0; i < WI_TIMEOUT; i++) {
d938 6
a943 1
		DELAY(10);
d951 1
a951 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
a960 4
#ifdef foo
			if ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))
				return(EIO);
#endif
d967 5
a971 1
	if (i < 0)
d973 1
d982 2
d987 5
a991 3
	if (sc->sc_firmware_type == WI_SYMBOL &&
	    (sc->wi_flags & WI_FLAGS_INITIALIZED))
		return;
d993 5
a997 1
	if (wi_cmd(sc, WI_CMD_INI, 0, 0, 0))
d999 3
a1001 2
	else
		sc->wi_flags |= WI_FLAGS_INITIALIZED;
d1291 1
a1291 1
	for (i = WI_TIMEOUT; i--; DELAY(10))
d1383 1
a1383 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
@


1.103
log
@Disable interrupts in wi_intr() before sending an ACK.  Fixes a
race condition and makes things consistent with the rest of the
code.  From NetBSD.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.102 2003/12/05 02:23:42 drahn Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.102 2003/12/05 02:23:42 drahn Exp $";
d294 2
a295 1
			sc->wi_flags |= WI_FLAGS_HAS_HOSTAP;
d522 1
a522 1
	u_int16_t		msg_type;
d631 2
a632 2
		/* Stash message type in host byte order for later use */
		msg_type = letoh16(rx_frame.wi_status) & WI_RXSTAT_MSG_TYPE;
d655 1
a655 1
		if (msg_type == WI_STAT_MGMT &&
d693 1
a693 1
		switch (msg_type) {
@


1.102
log
@consistently treat wi_keylen as le16, fixes wicontrol crash for if_wi
and if_wi_usb ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.101 2003/10/26 15:34:15 drahn Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.101 2003/10/26 15:34:15 drahn Exp $";
a453 1
		CSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);
d455 1
@


1.101
log
@Driver for PRISM 2.5/3 based (wifi) USB adapters. This is a work in progress,
it does not yet handle bulk data copies or hostap mode. Only one model
currently supported, however driver may support other PRISM based adapters.
ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.100 2003/10/21 18:58:49 jmc Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.100 2003/10/21 18:58:49 jmc Exp $";
d1211 1
d2082 1
a2082 1
	klen = sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keylen;
d2137 1
a2137 1
	klen = sc->wi_keys.wi_keys[kid].wi_keylen;
@


1.100
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.99 2003/10/07 07:08:45 markus Exp $	*/
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.99 2003/10/07 07:08:45 markus Exp $";
d138 1
d147 4
a150 4
STATIC int wi_cmd(struct wi_softc *, int, int, int, int);
STATIC int wi_read_record(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_write_record(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_read_data(struct wi_softc *, int,
d152 1
a152 1
STATIC int wi_write_data(struct wi_softc *, int,
d155 1
a155 1
STATIC int wi_alloc_nicmem(struct wi_softc *, int, int *);
d176 5
d190 16
d207 1
a207 2
wi_attach(sc)
	struct wi_softc *sc;
d214 2
d236 3
a238 3
	ifp->if_ioctl = wi_ioctl;
	ifp->if_start = wi_start;
	ifp->if_watchdog = wi_watchdog;
d318 1
a318 1
	timeout_set(&sc->sc_timo, wi_inquire, sc);
d427 14
d506 8
a513 1
STATIC void
d527 1
a527 1
	id = CSR_READ_2(sc, WI_RX_FID);
d821 1
a821 1
STATIC void
d881 1
a881 1
	id = CSR_READ_2(sc, WI_INFO_FID);
d900 5
a904 1
		t = CSR_READ_2(sc, WI_DATA1);
d920 1
a920 1
wi_cmd(sc, cmd, val0, val1, val2)
d983 2
a984 2
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);
d1024 1
a1024 1
wi_read_record(sc, ltv)
d1126 1
a1126 1
wi_write_record(sc, ltv)
d1281 1
a1281 1
wi_read_data(sc, id, off, buf, len)
d1311 1
a1311 1
wi_write_data(sc, id, off, buf, len)
d1349 1
a1349 1
wi_alloc_nicmem(sc, len, id)
d1843 1
a1843 1
wi_init(sc)
d1973 1
a1973 1
	CSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);
d2167 1
a2167 1
STATIC void
a2308 3
	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id, 0, 0))
		printf(WI_PRT_FMT ": wi_start: xmit failed\n", WI_PRT_ARG(sc));

d2316 3
d2363 1
a2363 1
STATIC void
d2380 1
a2380 1
	CSR_WRITE_2(sc, WI_INT_EN, 0);
d2389 2
a2390 1
STATIC void
d2418 4
a2421 3
	sc->wi_flags &= ~WI_FLAGS_ATTACHED;
	shutdownhook_disestablish(sc->sc_sdhook);

@


1.99
log
@use crypto/arc4; test, debug, ok millert@@; ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.98 2003/09/06 20:53:57 drahn Exp $	*/
d53 1
a53 1
 * publically available version of the HCF library (the 'HCF Light') is
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.98 2003/09/06 20:53:57 drahn Exp $";
d2252 1
a2252 1
	 * If there's a BPF listner, bounce a copy of
@


1.98
log
@Add wi_detach, use it in pcmcia so that the shutdownhook is properly removed.
ok miod@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.97 2003/08/15 20:32:17 tedu Exp $	*/
d104 2
d129 1
a129 1
	"$OpenBSD: if_wi.c,v 1.97 2003/08/15 20:32:17 tedu Exp $";
a2005 5
#define RC4STATE 256
#define RC4KEYLEN 16
#define RC4SWAP(x,y) \
    do { u_int8_t t = state[x]; state[x] = state[y]; state[y] = t; } while(0)

d2010 3
a2012 2
	u_int8_t state[RC4STATE], key[RC4KEYLEN];
	u_int8_t x, y, *dat;
d2039 1
a2039 8
	x = y = 0;
	for (i = 0; i < RC4STATE; i++)
		state[i] = i;
	for (i = 0; i < RC4STATE; i++) {
		y = (key[x] + state[i] + y) % RC4STATE;
		RC4SWAP(i, y);
		x = (x + 1) % klen;
	}
d2049 1
a2049 1
	/* compute rc4 over data, crc32 over data */
d2051 1
a2051 5
	x = y = 0;
	for (i = 0; i < len; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
a2052 2
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
	}
d2054 1
d2062 1
a2062 6
	for (i = 0; i < IEEE80211_WEP_CRCLEN; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
	}
d2069 3
a2071 2
	u_int8_t state[RC4STATE], key[RC4KEYLEN];
	u_int8_t x, y, *dat;
d2094 1
a2094 8
	x = y = 0;
	for (i = 0; i < RC4STATE; i++)
		state[i] = i;
	for (i = 0; i < RC4STATE; i++) {
		y = (key[x] + state[i] + y) % RC4STATE;
		RC4SWAP(i, y);
		x = (x + 1) % klen;
	}
d2096 2
a2097 1
	/* compute rc4 over data, crc32 over data */
d2099 1
a2099 6
	x = y = 0;
	for (i = 0; i < len; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
a2100 1
	}
d2104 3
a2106 7
	/* append little-endian crc32 and encrypt */
	for (i = 0; i < IEEE80211_WEP_CRCLEN; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
	}
@


1.97
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.96 2003/06/07 21:14:42 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.96 2003/06/07 21:14:42 mickey Exp $";
d394 1
a394 1
	shutdownhook_establish(wi_shutdown, sc);
d2391 15
@


1.96
log
@print minor version as 02d; from Adam Montague via pr 3284; matches what freebsd does as well
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.95 2003/04/26 08:01:42 jmc Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.95 2003/04/26 08:01:42 jmc Exp $";
d1518 1
a1518 1
		error = suser(p->p_ucred, &p->p_acflag);
d1606 1
a1606 1
			if (suser(p->p_ucred, &p->p_acflag))
d2758 1
a2758 1
	error = suser(curproc->p_ucred, &curproc->p_acflag);
@


1.95
log
@managment -> management;

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.94 2003/03/10 00:59:54 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.94 2003/03/10 00:59:54 millert Exp $";
d2477 1
a2477 1
		printf("\n%s: Firmware %d.%d variant %d, ", WI_PRT_ARG(sc),
@


1.94
log
@Fix AP scan on prism and add a /* FALLTHROUGH */ comment to make
things obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.93 2003/02/13 20:45:09 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.93 2003/02/13 20:45:09 millert Exp $";
d1834 1
a1834 1
	/* Power Managment Max Sleep */
@


1.93
log
@Plug mbuf leak when there is an IV mismatch during software decrypt.
Found by dhartmei@@;  I thought he committed the fix but appearently not.
Also make the debugging printf for IV mismatch more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.92 2003/02/12 21:49:05 markus Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.92 2003/02/12 21:49:05 markus Exp $";
d1622 5
d1635 1
a1635 5
		case WI_FRID_CRYPTO_ALG:
			wreq.wi_val[0] =
			    htole16((u_int16_t)sc->wi_crypto_algorithm);
			wreq.wi_len = 1;
			break;
@


1.92
log
@replace crc32 code with BSD licensed code from openssh
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.91 2003/01/23 19:27:19 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.91 2003/01/23 19:27:19 mickey Exp $";
d723 2
d2143 3
a2145 2
			printf(WI_PRT_FMT ": wi_do_hostdecrypt: iv mismatch\n",
			    WI_PRT_ARG(sc));
@


1.91
log
@be consistant on the spl everywhere and use splimp(), this seems to prevent wi_mgmt_xmit: xmit failed messages; millert@@ testing and ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.90 2003/01/21 16:26:40 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.90 2003/01/21 16:26:40 millert Exp $";
d1934 65
a1998 53
static const u_int32_t crc32_tab[] = {
	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
	0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
	0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
	0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
	0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
	0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
	0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
	0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
	0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
	0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
	0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
	0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
	0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
	0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
	0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
	0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
	0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
	0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
	0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
	0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
	0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
	0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
	0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
	0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
	0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
	0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
	0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
	0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
	0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
	0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
	0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
	0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
	0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
	0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
	0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
	0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
	0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
	0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
	0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
	0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
	0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
	0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
	0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
	0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
	0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
	0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
	0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
	0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
	0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
	0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
	0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
	0x2d02ef8dL
d2062 1
a2062 1
		crc = crc32_tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
d2126 1
a2126 1
		crc = crc32_tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
@


1.90
log
@Stub out hostap bits #ifdef SMALL_KERNEL to free up space on the
floppies; OK mickey@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.89 2003/01/10 21:38:02 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.89 2003/01/10 21:38:02 millert Exp $";
d810 1
a810 1
	s = splnet();
@


1.89
log
@Don't call wi_cor_reset() in wi_attach(); since sc_firmware_type is
not set yet this is a NOOP (noticed some time ago by fgs@@).

Call wi_cor_reset() from wi_watchdog() so we do a soft reset of the
card.  Currently, we only reset Symbol cards but should probably
reset all but Lucent cards with very old firmware revisions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.88 2002/10/27 16:20:48 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.88 2002/10/27 16:20:48 millert Exp $";
d268 1
d270 1
@


1.88
log
@Add an option to use software WEP now that we have a software decrypt
function.  Can be useful for cards that only support 40-bit WEP or
where the card firmware lacks weak IVs avoidance.  Prism/Symbol only.
In the future this will be expanded to support proposed WEP replacements.
Based on code from Jamison Adcock.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.87 2002/10/27 14:46:30 markus Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.87 2002/10/27 14:46:30 markus Exp $";
a190 1
	wi_cor_reset(sc);
d2367 1
@


1.87
log
@add a matching wi_do_hostdecrypt()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.86 2002/10/18 03:46:35 fgsch Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.86 2002/10/18 03:46:35 fgsch Exp $";
d237 1
d705 40
d1078 1
a1078 1
	u_int16_t		val;
d1125 14
a1138 3
				/* TX encryption is broken in Host AP mode. */
				if (sc->wi_ptype == WI_PORTTYPE_HOSTAP)
					val |= HOST_ENCRYPT;
d1455 14
d1627 5
d1666 7
@


1.86
log
@Account for the aligned m_data when checking boundaries; from NetBSD.
mickey and millert ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.83 2002/10/11 14:47:50 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.83 2002/10/11 14:47:50 millert Exp $";
d170 3
d1915 1
a1915 1
static void
d1988 68
@


1.85
log
@media support; slightly modified from FreeBSD.
mickey and millert ok.
@
text
@d469 1
d471 1
d594 1
d600 1
d608 1
a608 1
			if ((WI_802_11_OFFSET_RAW + rxlen + 2) > MCLBYTES) {
d646 1
a646 1
			    MCLBYTES) {
d676 1
a676 1
			    sizeof(struct ether_header)) > MCLBYTES) {
@


1.84
log
@pad keys of size != RC4KEYLEN or RC4KEYLEN/2 with zero; noticed and tested by millert@@
@
text
@d2455 1
d2463 45
a2507 2
	imr->ifm_active = sc->sc_media.ifm_cur->ifm_media;
	imr->ifm_status = IFM_AVALID|IFM_ACTIVE;
@


1.83
log
@Stash the value of letoh16(ver.wi_ver[0]) in a variable so we don't
evaluate the same thing for each loop iteration in wi_get_id().
[ previous commit contained unrelated changes and has been removed ]
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.82 2002/10/11 13:31:49 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.82 2002/10/11 13:31:49 millert Exp $";
d1929 1
d1934 1
a1934 3
	klen = sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keylen +
	    IEEE80211_WEP_IVLEN;
	klen = (klen >= RC4KEYLEN) ? RC4KEYLEN : RC4KEYLEN/2;
d1936 2
a1937 1
	    (char *)key + IEEE80211_WEP_IVLEN, klen - IEEE80211_WEP_IVLEN);
@


1.82
log
@Sigh, we can't just put the htole16() in the WI_CARD_IDS macro
since gcc doesn't seem to evaluate htole16() of a constant at
compile time after all.  Noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.81 2002/10/10 20:27:46 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.81 2002/10/10 20:27:46 millert Exp $";
d2241 2
a2242 1
	const char			*chip_id;
d2249 1
d2251 1
a2251 1
		if (letoh16(ver.wi_ver[0]) == id->card_id)
d2256 1
a2256 1
		chip_id = id->card_name;
d2259 1
a2259 1
		chip_id = "Unknown PRISM2 chip";
d2312 1
a2312 1
		    chip_id, pri_fw_ver[0], pri_fw_ver[1], pri_fw_ver[2],
@


1.81
log
@Make wi_get_id() table driven, similar to NetBSD and FreeBSD but
make the table itself a #define so we can reuse it in wicontrol.
Also add a bunch of chip IDs from NetBSD/FreeBSD.
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.80 2002/10/04 02:29:36 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.80 2002/10/04 02:29:36 millert Exp $";
d2249 1
a2249 1
		if (ver.wi_ver[0] == id->card_id)
@


1.80
log
@Limit the TX key to a valid range; imp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.79 2002/08/30 08:19:49 fgsch Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.79 2002/08/30 08:19:49 fgsch Exp $";
d175 4
d2238 4
a2241 3
	struct wi_ltv_ver	ver;
	u_int16_t		pri_fw_ver[3];
	const char		*p;
d2248 2
a2249 48
	switch (letoh16(ver.wi_ver[0])) {
		case WI_NIC_EVB2:
			p = "PRISM I HFA3841(EVB2)";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_HWB3763:
			p = "PRISM II HWB3763 rev.B";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_HWB3163:
			p = "PRISM II HWB3163 rev.A";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_HWB3163B:
			p = "PRISM II HWB3163 rev.B";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_EVB3:
			p = "PRISM II  HFA3842(EVB3)";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_HWB1153:
			p = "PRISM I HFA1153";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_P2_SST:
			p = "PRISM II HWB3163 SST-flash";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_PRISM2_5:
			p = "PRISM 2.5 ISL3873";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_3874A:
			p = "PRISM 2.5 ISL3874A(PCI)";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_37300P:
			p = "PRISM 2.5 ISL37300P";
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		default:
			if (ver.wi_ver[0] & htole16(0x8000)) {
				p = "Unknown PRISM2 chip";
				sc->sc_firmware_type = WI_INTERSIL;
			} else {
				sc->sc_firmware_type = WI_LUCENT;
			}
d2251 9
d2309 2
a2310 2
		    sc->sc_firmware_type == WI_SYMBOL ? "Symbol " : "", p,
		    pri_fw_ver[0], pri_fw_ver[1], pri_fw_ver[2],
a2314 2

	return;
@


1.79
log
@plug mbuf leak.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.78 2002/08/30 08:08:22 fgsch Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.78 2002/08/30 08:08:22 fgsch Exp $";
d936 2
d1082 2
@


1.78
log
@only do copyout() if wi_get_debug() returned 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.77 2002/08/13 03:49:51 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.77 2002/08/13 03:49:51 millert Exp $";
d2013 1
@


1.77
log
@change WI_PORTTYPE_AP -> WI_PORTTYPE_HOSTAP to match FreeBSD and NetBSD.
The reason for this is that it is possible in the future to have
wi(4) be a real AP using the AP tertiary firmware.
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.76 2002/08/08 18:53:10 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.76 2002/08/08 18:53:10 millert Exp $";
d1620 2
a1621 1
		error = copyout(&wreq, ifr->ifr_data, sizeof(wreq));
@


1.76
log
@Fix IFF_PROMISC setting optimization.  The point is to avoid the
wi_init() if only IFF_PROMISC status has changed.  There is no need
to change anything if we are in HostAP mode since wi_init() has
already turned off the hardware promisc bit when we entered HostAP
(HostAP already implies promisc behavior).
Noticed by imp@@, OK by mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.75 2002/07/16 13:46:43 fgsch Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.75 2002/07/16 13:46:43 fgsch Exp $";
d596 1
a596 1
		    sc->wi_ptype == WI_PORTTYPE_AP) {
d693 1
a693 1
		if (sc->wi_ptype == WI_PORTTYPE_AP) {
d1072 1
a1072 1
				if (sc->wi_ptype == WI_PORTTYPE_AP)
d1472 1
a1472 1
				if (sc->wi_ptype != WI_PORTTYPE_AP)
d1477 1
a1477 1
				if (sc->wi_ptype != WI_PORTTYPE_AP)
d1751 1
a1751 1
	if (sc->wi_net_name.i_len != 0 && (sc->wi_ptype == WI_PORTTYPE_AP ||
d1778 1
a1778 1
	if (sc->wi_ptype != WI_PORTTYPE_AP && ifp->if_flags & IFF_PROMISC)
d2004 1
a2004 1
	if (sc->wi_ptype == WI_PORTTYPE_AP) {
d2026 1
a2026 1
		if (sc->wi_ptype == WI_PORTTYPE_AP) {
d2049 1
a2049 1
		if (sc->wi_ptype == WI_PORTTYPE_AP && sc->wi_use_wep) {
d2087 1
a2087 1
		if (sc->wi_ptype == WI_PORTTYPE_AP && sc->wi_use_wep) {
d2384 1
a2384 1
	case WI_PORTTYPE_AP:
d2430 1
a2430 1
		sc->wi_ptype = WI_PORTTYPE_AP;
@


1.75
log
@remove prototypes that now live in if_wivar.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.74 2002/07/10 20:21:16 fgsch Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.74 2002/07/10 20:21:16 fgsch Exp $";
d1469 4
a1472 6
			if (sc->wi_ptype == WI_PORTTYPE_AP) {
				WI_SETVAL(WI_RID_PROMISC, 0);
			} else {
				if (ifp->if_flags & IFF_RUNNING &&
				    ifp->if_flags & IFF_PROMISC &&
				    !(sc->wi_if_flags & IFF_PROMISC)) {
d1474 4
a1477 3
				} else if (ifp->if_flags & IFF_RUNNING &&
				    !(ifp->if_flags & IFF_PROMISC) &&
				    sc->wi_if_flags & IFF_PROMISC) {
d1479 2
a1480 3
				}
			}
			wi_init(sc);
@


1.74
log
@use ifp->if_sadl whether possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.73 2002/06/24 17:59:09 fgsch Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.73 2002/06/24 17:59:09 fgsch Exp $";
a134 1
STATIC void wi_cor_reset(struct wi_softc *);
a168 5

int	wi_intr(void *);
int	wi_attach(struct wi_softc *);
void	wi_init(struct wi_softc *);
void	wi_stop(struct wi_softc *);
@


1.73
log
@oops. don't initialize wi_flags and wi_hostap_info here; fixes sparc.
somehow i didn't commit this. from denver airport.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.72 2002/06/22 16:14:14 fgsch Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.72 2002/06/22 16:14:14 fgsch Exp $";
a1317 2
	struct sockaddr_dl	*sdl;
	struct ifaddr		*ifa;
a1318 1
	extern struct ifaddr	**ifnet_addrs;
d1325 2
a1326 3
		ifa = ifnet_addrs[ifp->if_index];
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		bcopy((char *)&wreq->wi_val, LLADDR(sdl), ETHER_ADDR_LEN);
@


1.72
log
@use 8-bits when accessing the wi_cor_offset; millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.71 2002/06/21 20:15:37 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.71 2002/06/21 20:15:37 millert Exp $";
a188 3

	sc->wi_flags = 0;
	sc->wi_hostap_info.apflags = 0;
@


1.71
log
@Clear wi_hostap_info.apflags in wi_attach() to guarantee wihap_shutdown()
doesn't do the wrong thing with quick card insert/ejects.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.70 2002/06/21 06:56:24 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.70 2002/06/21 06:56:24 millert Exp $";
d911 1
a911 1
		cor_value = bus_space_read_2(sc->wi_ltag, sc->wi_lhandle,
@


1.70
log
@Add some missing casts of sc->wi_txbuf -> caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.69 2002/06/21 06:50:37 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.69 2002/06/21 06:50:37 millert Exp $";
d191 1
@


1.69
log
@Don't set WI_FLAGS_ATTACHED in sc->wi_flags until after mi attach
routines have been called.  Avoids a panic when you insert & eject
a card very quickly on a slow machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.68 2002/06/21 06:46:26 fgsch Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.68 2002/06/21 06:46:26 fgsch Exp $";
d794 1
a794 1
		wi_read_data(sc, id, 4, (char *)sc->wi_scanbuf,
d2072 1
a2072 1
			wi_do_hostencrypt(sc, &sc->wi_txbuf[0],
@


1.68
log
@don't convert these to little-endian. now ifconfig shows the nwid on
sparc64 and macppc; tested by me and drahn@@ on i386, macppc and sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.67 2002/06/15 18:49:04 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.67 2002/06/15 18:49:04 millert Exp $";
d190 1
a190 1
	sc->wi_flags = WI_FLAGS_ATTACHED;
d385 2
@


1.67
log
@Don't advertise hostap as an allowed media type for firmware < 0.80
Hopefully this will confuse people with crufty firmware a little less
than the old behavior.  Supposedly it is possible to get hostap working
on prism firmware 0.7.6 but I'm not going to attempt that at this time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.66 2002/06/14 03:58:45 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.66 2002/06/14 03:58:45 millert Exp $";
d1646 2
a1647 2
			wreq.wi_type = htole16(WI_RID_CURRENT_SSID);
			wreq.wi_len = htole16(WI_MAX_DATALEN);
@


1.66
log
@don't allow users to set the IBSS/HostAP SSID to the empty string
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.65 2002/06/12 04:43:41 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.65 2002/06/12 04:43:41 millert Exp $";
d269 1
d315 1
a315 1
	if (sc->sc_firmware_type == WI_INTERSIL)
d328 1
a328 1
		if (sc->sc_firmware_type == WI_INTERSIL)
d342 1
a342 1
		if (sc->sc_firmware_type == WI_INTERSIL)
d356 1
a356 1
		if (sc->sc_firmware_type == WI_INTERSIL)
d370 1
a370 1
		if (sc->sc_firmware_type == WI_INTERSIL)
@


1.65
log
@Previously, SIOCG80211NWID would return the "desired" netname if
the interface was up, even if it was the empty string.  This tends
to confuse users who have not set the desired net name (ie: associate
with any AP).  Now we only return the desired net name if it is not
empty and the interface is up.  Otherwise we return the current
net name (ie: what we are associated with).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.64 2002/06/09 03:14:18 todd Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.64 2002/06/09 03:14:18 todd Exp $";
d1596 1
d1608 3
a1610 1
			    !(sc->wi_flags & WI_FLAGS_HAS_MOR)))
@


1.64
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.63 2002/06/03 21:53:58 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.63 2002/06/03 21:53:58 millert Exp $";
d1637 1
a1637 1
		if (ifp->if_flags & IFF_UP) {
@


1.63
log
@o when checking the message type, mask with WI_RXSTAT_MSG_TYPE instead
  of comparing directly against WI_STAT_1042, WI_STAT_TUNNEL, etc.
  This is needed by some Symbol cards in ad-hoc mode.

o change some ntohs(var) to htons(constant).

Adapted from NetBSD (mycroft).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.62 2002/06/02 16:11:41 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.62 2002/06/02 16:11:41 millert Exp $";
d203 1
a203 1
	bcopy((char *)&mac.wi_mac_addr, (char *)&sc->arpcom.ac_enaddr,
d207 1
a207 1
	printf("address %s", ether_sprintf(sc->arpcom.ac_enaddr));
d209 1
a209 1
	ifp = &sc->arpcom.ac_if;
d386 1
a386 1
	BPFATTACH(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
d408 1
a408 1
	ifp = &sc->arpcom.ac_if;
d473 1
a473 1
	ifp = &sc->arpcom.ac_if;
d622 1
a622 1
				if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d732 1
a732 1
	ifp = &sc->arpcom.ac_if;
d754 1
a754 1
	ifp = &sc->arpcom.ac_if;
d783 1
a783 1
	ifp = &sc->arpcom.ac_if;
d1277 1
a1277 1
	ifp = &sc->arpcom.ac_if;
d1289 1
a1289 1
	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
d1323 1
a1323 1
	ifp = &sc->arpcom.ac_if;
d1330 1
a1330 1
		bcopy((char *)&wreq->wi_val, (char *)&sc->arpcom.ac_enaddr,
d1432 1
a1432 1
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
d1459 1
a1459 1
			arp_ifinit(&sc->arpcom, ifa);
d1501 2
a1502 2
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
d1706 1
a1706 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d1774 1
a1774 1
	bcopy((char *)&sc->arpcom.ac_enaddr,
d2039 1
a2039 1
			bcopy((char *)&sc->arpcom.ac_enaddr,
d2192 1
a2192 1
	ifp = &sc->arpcom.ac_if;
d2472 1
a2472 1
	if (sc->arpcom.ac_if.if_flags & IFF_UP) {
d2490 1
a2490 1
	if (!(sc->arpcom.ac_if.if_flags & IFF_UP)) {
d2529 1
a2529 1
	if (sc->arpcom.ac_if.if_flags & IFF_UP) {
d2540 1
a2540 1
	if (sc->arpcom.ac_if.if_flags & IFF_UP) {
d2550 1
a2550 1
	if (sc->arpcom.ac_if.if_flags & IFF_UP) {
d2558 1
a2558 1
	if (sc->arpcom.ac_if.if_flags & IFF_UP)
d2603 1
a2603 1
	if (sc->arpcom.ac_if.if_flags & IFF_UP)
@


1.62
log
@BSD air-tools 0.2 patches from dachb0den labs; h1kari@@dachb0den.com
The common.h include file has been incorporated into if_wi_ieee.h
similar to what is in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.61 2002/05/31 19:27:40 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.61 2002/05/31 19:27:40 millert Exp $";
d470 1
d572 1
a572 3
		/*
		 * Drop undecryptable or packets with receive errors here
		 */
d578 3
d600 1
a600 1
		if (rx_frame.wi_status == htole16(WI_STAT_MGMT) &&  
d638 4
a641 3
		if (rx_frame.wi_status == htole16(WI_STAT_1042) ||
		    rx_frame.wi_status == htole16(WI_STAT_TUNNEL) ||
		    rx_frame.wi_status == htole16(WI_STAT_WMP_MSG)) {
d670 2
a671 1
		} else {
d693 1
d2028 4
a2031 4
	if (ntohs(eh->ether_type) == ETHERTYPE_IP ||
	    ntohs(eh->ether_type) == ETHERTYPE_ARP ||
	    ntohs(eh->ether_type) == ETHERTYPE_REVARP ||
	    ntohs(eh->ether_type) == ETHERTYPE_IPV6) {
@


1.61
log
@Allow IBSS creation on Symbol cards with station firmware >= 2.5
From John Hay via Warner Losh
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.60 2002/04/30 22:56:33 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.60 2002/04/30 22:56:33 mickey Exp $";
d145 1
a145 1
STATIC int wi_cmd(struct wi_softc *, int, int);
d168 3
a468 1
	struct wi_frame		rx_frame;
d476 3
a478 5
	/* First read in the frame header */
	if (wi_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {
		ifp->if_ierrors++;
		return;
	}
d480 11
a490 7
	/*
	 * Drop undecryptable or packets with receive errors here
	 */
	if (rx_frame.wi_status & htole16(WI_STAT_ERRSTAT)) {
		ifp->if_ierrors++;
		return;
	}
d492 1
a492 11
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}
	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		ifp->if_ierrors++;
		return;
	}
d494 2
a495 17
	/* Align the data after the ethernet header */
	m->m_data = (caddr_t) ALIGN(m->m_data + sizeof(struct ether_header))
	    - sizeof(struct ether_header);

	eh = mtod(m, struct ether_header *);
	m->m_pkthdr.rcvif = ifp;

	if (rx_frame.wi_status == htole16(WI_STAT_MGMT) &&  
	    sc->wi_ptype == WI_PORTTYPE_AP) {

		u_int16_t rxlen = letoh16(rx_frame.wi_dat_len);

		if ((WI_802_11_OFFSET_RAW + rxlen + 2) > MCLBYTES) {
			printf("%s: oversized mgmt packet received in "
			    "hostap mode (wi_dat_len=%d, wi_status=0x%x)\n",
			    sc->sc_dev.dv_xname,
			    rxlen, letoh16(rx_frame.wi_status));
d497 1
a497 1
			ifp->if_ierrors++;  
d501 3
a503 4
		/* Put the whole header in there. */
		bcopy(&rx_frame, mtod(m, void *), sizeof(struct wi_frame));
		if (wi_read_data(sc, id, WI_802_11_OFFSET_RAW,
		    mtod(m, caddr_t) + WI_802_11_OFFSET_RAW, rxlen + 2)) {
a504 2
			if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
				printf("wihap: failed to copy header\n");
d509 37
a545 1
		m->m_pkthdr.len = m->m_len = WI_802_11_OFFSET_RAW + rxlen;
d547 5
a551 6
		/* XXX: consider giving packet to bhp? */

		wihap_mgmt_input(sc, &rx_frame, m);

		return;
	}
d553 2
a554 8
	if (rx_frame.wi_status == htole16(WI_STAT_1042) ||
	    rx_frame.wi_status == htole16(WI_STAT_TUNNEL) ||
	    rx_frame.wi_status == htole16(WI_STAT_WMP_MSG)) {
		if ((letoh16(rx_frame.wi_dat_len) + WI_SNAPHDR_LEN) > MCLBYTES) {
			printf(WI_PRT_FMT ": oversized packet received "
			    "(wi_dat_len=%d, wi_status=0x%x)\n",
			    WI_PRT_ARG(sc), letoh16(rx_frame.wi_dat_len),
			    letoh16(rx_frame.wi_status));
a558 2
		m->m_pkthdr.len = m->m_len =
		    letoh16(rx_frame.wi_dat_len) + WI_SNAPHDR_LEN;
d560 3
a562 6
		bcopy((char *)&rx_frame.wi_dst_addr,
		    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);
		bcopy((char *)&rx_frame.wi_src_addr,
		    (char *)&eh->ether_shost, ETHER_ADDR_LEN);
		bcopy((char *)&rx_frame.wi_type,
		    (char *)&eh->ether_type, ETHER_TYPE_LEN);
d564 3
a566 2
		if (wi_read_data(sc, id, WI_802_11_OFFSET, mtod(m, caddr_t) +
		    sizeof(struct ether_header), m->m_len + 2)) {
a567 1
			m_freem(m);
d570 5
a574 8
	} else {
		if ((letoh16(rx_frame.wi_dat_len) +
		    sizeof(struct ether_header)) > MCLBYTES) {
			printf(WI_PRT_FMT ": oversized packet received "
			    "(wi_dat_len=%d, wi_status=0x%x)\n",
			    WI_PRT_ARG(sc), letoh16(rx_frame.wi_dat_len),
			    letoh16(rx_frame.wi_status));
			m_freem(m);
a577 2
		m->m_pkthdr.len = m->m_len =
		    letoh16(rx_frame.wi_dat_len) + sizeof(struct ether_header);
d579 7
a585 2
		if (wi_read_data(sc, id, WI_802_3_OFFSET,
		    mtod(m, caddr_t), m->m_len + 2)) {
a589 1
	}
d591 41
a631 1
	ifp->if_ipackets++;
a632 7
	if (sc->wi_ptype == WI_PORTTYPE_AP) {
		/*
		 * Give host AP code first crack at data packets.
		 * If it decides to handle it (or drop it), it will return
		 * a non-zero.  Otherwise, it is destined for this host.
		 */
		if (wihap_data_input(sc, &rx_frame, m))
d634 69
d711 5
a715 2
	/* Receive packet. */
	ether_input_mbuf(ifp, m);
d758 1
a758 1
	rv = wi_cmd(sc, WI_CMD_INQUIRE, WI_INFO_COUNTERS);
d784 6
a789 1
	if (gen.wi_type != WI_INFO_COUNTERS)
d793 2
a794 2
	len = (gen.wi_len - 1 < sizeof(sc->wi_stats) / 4) ?
	    gen.wi_len - 1 : sizeof(sc->wi_stats) / 4;
d815 1
a815 1
wi_cmd(sc, cmd, val)
d818 3
a820 1
	int			val;
d831 3
a833 3
	CSR_WRITE_2(sc, WI_PARAM0, val);
	CSR_WRITE_2(sc, WI_PARAM1, 0);
	CSR_WRITE_2(sc, WI_PARAM2, 0);
d873 1
a873 1
	if (wi_cmd(sc, WI_CMD_INI, 0))
d944 1
a944 1
	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type))
d1118 1
a1118 1
	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))
d1236 1
a1236 1
	if (wi_cmd(sc, WI_CMD_ALLOC_MEM, len)) {
d1434 1
d1519 2
a1520 1
		if (wreq.wi_type == WI_RID_IFACE_STATS) {
d1525 2
a1526 1
		} else if (wreq.wi_type == WI_RID_DEFLT_CRYPT_KEYS) {
d1534 19
a1552 1
		} else {
a1554 1
				break;
d1556 1
d1574 13
d1592 2
a1593 1
			 * Check for features that may not be supported.
d1613 18
d1815 1
a1815 1
	wi_cmd(sc, WI_CMD_ENABLE | sc->wi_portnum, 0);
d2118 1
a2118 1
	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id))
d2163 1
a2163 1
	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id)) {
d2190 1
a2190 1
	wi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);
d2626 143
@


1.60
log
@crc32_tab can be const
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.59 2002/04/26 21:27:27 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.59 2002/04/26 21:27:27 millert Exp $";
a272 1
		/* XXX - Symbol does not seem to support IBSS creation. */
d275 2
@


1.59
log
@Add some bounds checking of wi_len on copyin().  From NetBSD via FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.58 2002/04/26 21:19:18 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.58 2002/04/26 21:19:18 millert Exp $";
d1677 1
a1677 1
static u_int32_t crc32_tab[] = {
@


1.58
log
@Don't set WI_RID_OWN_SSID based on wi_net_name if wi_net_name is
not actually set.  Closed PR #2569.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.57 2002/04/26 19:20:27 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.57 2002/04/26 19:20:27 millert Exp $";
d1402 4
d1432 2
d1487 1
a1487 1
		if (error != 0)
@


1.57
log
@We use wi_authtype, not wi_authmode to store the auth type (open system
or shared key).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.56 2002/04/23 22:25:29 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.56 2002/04/23 22:25:29 millert Exp $";
d1583 2
a1584 2
	if ((sc->wi_create_ibss && sc->wi_ptype == WI_PORTTYPE_IBSS) ||
	    sc->wi_ptype == WI_PORTTYPE_AP)
@


1.56
log
@Clear flags indicating whether or not wi or hostap is active as
early as possible.  Also move the timeout_del() in wi_stop() to
before we disable wi(4) so it doesn't fire at the wrong time.
Joint effort between mickey@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.55 2002/04/21 02:16:52 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.55 2002/04/21 02:16:52 millert Exp $";
d956 1
a956 1
				if (sc->wi_authmode != IEEE80211_AUTH_OPEN ||
@


1.55
log
@Symbol version string need not start with 'V'; from NetBSD (onoe)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.54 2002/04/16 00:18:21 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.54 2002/04/16 00:18:21 millert Exp $";
d2014 2
a2019 2

	timeout_del(&sc->sc_timo);
@


1.54
log
@From NetBSD:
o Fix m->m_data alignment in wi_rxeof()
o Add a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.53 2002/04/11 02:11:19 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.53 2002/04/11 02:11:19 millert Exp $";
d2150 1
a2150 1
		/* value should be "V2.00-11" */
d2152 1
a2152 1
		    *(p = (char *)sver.wi_str) == 'V' &&
@


1.53
log
@Fix Lucent <-> Prism2 WEP interop bug.  We only want to set the
EXCLUDE_UNENCRYPTED bit in the WI_RID_P2_ENCRYPTION value if we are
in shared key mode.  Symbol cards, just to be different, supposedly
always want the EXCLUDE_UNENCRYPTED bit set (confirmed with the
Linux orinoco and spectrum24 drivers).

I have so far been unable to get my Symbol card to interop with
Lucent or Prism2 WEP.  In BSS mode at least, this Symbol card does
not list WEP as a capability it supports.  This is, to put it mildly,
rather annoying.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.52 2002/04/11 00:08:25 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.52 2002/04/11 00:08:25 millert Exp $";
d479 3
d499 4
d594 2
a595 2

		/* Give host AP code first crack at data packets.
@


1.52
log
@o Set feature flags based on firmware type and version.
o Move the sc->has_wep flag into sc->wi_flags
o Only do the COR reset on Symbol cards just to play it safe.
o Remove unused sc->sc_enabled variable.
o Kill ibss_portmap array in favor of sc->wi_ibss_port, which is
stored in little endian.

mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.51 2002/04/10 19:25:07 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.51 2002/04/10 19:25:07 millert Exp $";
d905 1
d939 14
a952 1
			if (ltv->wi_val & htole16(0x01))
d954 3
a956 10
					/* Disable tx encryption...
					 * it's broken.
					 */
					p2ltv.wi_val = htole16(HOST_ENCRYPT |
					    PRIVACY_INVOKED |
					    EXCLUDE_UNENCRYPTED);
				else
					p2ltv.wi_val = htole16(PRIVACY_INVOKED |
					    EXCLUDE_UNENCRYPTED);
			else
@


1.51
log
@o Add ibss and ibss-master mediaopt for ifconfig
o Map port type 4 to ibss regardless of firmware type.  This gives
us a consistent way to set ibss mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.50 2002/04/08 18:31:27 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.50 2002/04/08 18:31:27 mickey Exp $";
a177 7
/* Map of firmware type to IBBS port type */
int ibss_portmap[] = {
	1,		/* WI_LUCENT */
	0,		/* WI_INTERSIL */
	4,		/* WI_SYMBOL */
};

d250 31
d285 2
a286 2
	if (wi_read_record(sc, &gen) == 0)
		sc->wi_has_wep = letoh16(gen.wi_val);
d304 4
a307 2
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, IFM_IEEE80211_IBSS, 0), 0);
	if (sc->sc_firmware_type != WI_SYMBOL)
d317 4
a320 3
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
		    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->sc_firmware_type != WI_SYMBOL)
d331 4
a334 3
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
		    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->sc_firmware_type != WI_SYMBOL)
d345 4
a348 3
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
		    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->sc_firmware_type != WI_SYMBOL)
d359 4
a362 3
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
		    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->sc_firmware_type != WI_SYMBOL)
d777 4
a780 3
	 * Do a soft reset of the card.  This is required by Symbol cards
	 * and shouldn't hurt others.  We don't do this on Lucent cards
	 * because it messes up some old Lucent firmware revisions.
d782 1
a782 1
	if (sc->sc_firmware_type != WI_LUCENT) {
d853 1
a853 1
	    && letoh16(ltv->wi_val) == ibss_portmap[sc->sc_firmware_type]) {
d913 1
a913 1
		p2ltv.wi_val = htole16(ibss_portmap[sc->sc_firmware_type]);
d1423 13
a1435 7
			/* Only Symbol cards support antenna diversity */
			if (wreq.wi_type == WI_RID_SYMBOL_DIVERSITY &&
			    sc->sc_firmware_type != WI_SYMBOL)
				break;
			/* Symbol cards use 0xFC2D for something else. */
			if (wreq.wi_type == WI_RID_ROAMING_MODE &&
			    sc->sc_firmware_type == WI_SYMBOL)
d1558 1
a1558 1
	if (sc->sc_firmware_type != WI_SYMBOL)
d1562 1
a1562 1
	if (sc->sc_firmware_type == WI_SYMBOL)
d1602 1
a1602 1
	if (sc->wi_has_wep) {
d2252 2
a2253 2
		if (sc->sc_firmware_type == WI_SYMBOL)
			return (EINVAL);	/* not working on Symbol */
d2319 1
a2319 1
	if (!sc->wi_has_wep)
d2381 1
a2381 1
	if (!sc->wi_has_wep)
@


1.50
log
@make hostap work on other-endian machines; tested by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.49 2002/04/07 23:23:49 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.49 2002/04/07 23:23:49 millert Exp $";
d178 7
d279 5
a283 2
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
	    IFM_IEEE80211_ADHOC, 0), 0);
d291 5
d304 5
d317 5
d330 5
d821 9
a829 1
	if (sc->sc_firmware_type != WI_LUCENT) {
d877 8
a884 1
	if (sc->sc_firmware_type != WI_LUCENT) {
d1190 1
d1499 3
a1504 3
	/* Set the port type. */
	WI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);

d1532 2
a1533 1
	if (sc->wi_ptype == WI_PORTTYPE_AP)
d2157 1
d2159 3
d2165 8
a2172 2
	case WI_PORTTYPE_BSS:
		options &= ~IFM_IEEE80211_ADHOC;
d2195 1
a2196 4
	if ((sc->sc_media.ifm_cur->ifm_media &
	    (IFM_IEEE80211_ADHOC|IFM_IEEE80211_HOSTAP)) ==
	    (IFM_IEEE80211_ADHOC|IFM_IEEE80211_HOSTAP))
		return (EINVAL);
d2198 1
a2198 1
	    sc->sc_firmware_type == WI_LUCENT)
d2201 7
a2207 1
	if ((sc->sc_media.ifm_cur->ifm_media & IFM_IEEE80211_ADHOC))
d2209 2
a2210 1
	else if ((sc->sc_media.ifm_cur->ifm_media & IFM_IEEE80211_HOSTAP))
d2212 14
a2225 2
	else
		sc->wi_ptype = WI_PORTTYPE_BSS;
d2246 2
a2247 2
		if (otype != sc->wi_ptype ||
		    orate != sc->wi_tx_rate)
@


1.49
log
@Don't reset COR in wi_reset(), break it out into its own function and
only call it from wi_attach() and wi_pcmcia_activate() (ie: just once).
It would be nicer to have the COR reset be part of the bus-specific
code but we need to know whether or not we have a Lucent card since
old Lucent firmware revs get messed up on a COR soft reset.

Even with the COR reset we still need to avoid initializing Symbol
cards more than once.  However, we *do* want to do a reset after
returning from suspend.  Therefore, rename wi_gone to wi_flags and
store both the attach and init status in it.  wi_reset() now checks
wi_flags to see if the card should be initialized in the Symbol case.

Info on initializing Symbol cards once from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.48 2002/04/06 23:48:38 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.48 2002/04/06 23:48:38 millert Exp $";
d439 1
a439 1
	if (rx_frame.wi_status == WI_STAT_MGMT &&  
d442 3
a444 2
		if ((WI_802_11_OFFSET_RAW + rx_frame.wi_dat_len + 2) >
		    MCLBYTES) {
d448 1
a448 1
			    rx_frame.wi_dat_len, rx_frame.wi_status);
d457 1
a457 2
		    mtod(m, caddr_t) + WI_802_11_OFFSET_RAW,
		    rx_frame.wi_dat_len + 2)) {
d465 1
a465 2
		m->m_pkthdr.len = m->m_len =
		    WI_802_11_OFFSET_RAW + rx_frame.wi_dat_len;
d1777 1
a1777 1
		tx_frame.wi_dat_len = htole16(m0->m_pkthdr.len - WI_SNAPHDR_LEN);
d1798 1
d1810 1
d1889 1
d2013 1
a2013 1
			if (letoh16(ver.wi_ver[0]) & 0x8000) {
@


1.48
log
@Add support for setting antenna diversity on Symbol cards.
Also add some more Symbol-specific RID values I noticed in the
Linux orinoco driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.47 2002/04/06 21:58:12 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.47 2002/04/06 21:58:12 millert Exp $";
d135 1
d187 1
a187 1
	sc->wi_gone = 0;
d189 1
d346 1
a346 1
	if (sc->wi_gone || !(ifp->if_flags & IFF_UP)) {
d688 25
d715 1
a715 1
	DPRINTF(WID_RESET, ("wi_reset: sc %p\n", sc));
a732 9
	if (wi_cmd(sc, WI_CMD_INI, 0))
		printf(WI_PRT_FMT ": init failed\n", WI_PRT_ARG(sc));

	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);

	/* Calibrate timer. */
	WI_SETVAL(WI_RID_TICK_TIME, 8);

d1217 1
a1217 1
	if (sc->wi_gone) {
d1439 1
a1439 1
	if (sc->wi_gone)
d1723 1
a1723 1
	if (sc->wi_gone)
d1872 1
a1872 1
	if (sc->wi_gone)
d1909 1
a1909 1
	if (sc->wi_gone)
@


1.47
log
@For PLX-based bridge cards, move printing of pcmcia card CIS strings
out of generic wi_attach() and into wi_pci_attach().  This means
we can't print the CIS info for embedded cards like the NCP130 but
since those don't have a "real" pcmcia card in them this is really
not a problem.  Also check to see that there is actually a pcmcia
present and give and error if not.  CIS magic number taken from the
Linux orinoco driver; there may be a better way to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.46 2002/04/06 20:31:56 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.46 2002/04/06 20:31:56 millert Exp $";
d232 1
d1159 3
d1327 1
d1329 4
d1334 2
a1335 1
			if (sc->sc_firmware_type == WI_SYMBOL)
d1460 4
@


1.46
log
@Add support for Symbol cards and printing of the primary station
firmware version.  Adapted from NetBSD and the Linux orinoco driver.
The Symbol firmware requires that we do a COR soft reset before
initializing the card in wi_reset().  Also, setting WI_RID_ROAMING_MODE
caused the Symbol card to go into a strange (non-working) mode with
firmware 2.x.x.

There are some other Symbol additions/oddities that will need to be
addressed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.45 2002/04/05 15:35:34 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.45 2002/04/05 15:35:34 millert Exp $";
d155 1
a155 1
STATIC void wi_get_id(struct wi_softc *, int);
d168 1
a168 1
int	wi_attach(struct wi_softc *, int);
d178 1
a178 1
wi_attach(sc, print_cis)
a179 1
	int print_cis;
d201 1
a201 1
	wi_get_id(sc, print_cis);
d1925 1
a1925 1
wi_get_id(sc, print_cis)
a1926 1
	int print_cis;
a1928 1
	struct wi_ltv_cis	cis;
a1930 21

	if (print_cis) {
		/*
		 * For PCI attachments the CIS strings won't have been printed
		 * so print them here.
		 * XXX - messes up each odd character on Symbol cards
		 */
		cis.wi_type = WI_RID_CIS;
		cis.wi_len = sizeof(cis.wi_cis);
		if (wi_read_record(sc, (struct wi_ltv_gen *)&cis) == 0) {
			char *cis_strings[3];

			cis_strings[0] = (char *)&cis.wi_cis[11];
			cis_strings[1] = cis_strings[0] +
			    strlen(cis_strings[0]) + 1;
			cis_strings[2] = cis_strings[1] +
			    strlen(cis_strings[1]) + 1;
			printf("\n%s: \"%s, %s, %s\"", WI_PRT_ARG(sc),
			    cis_strings[0], cis_strings[1], cis_strings[2]);
		}
	}
@


1.45
log
@Add another check for sc->wi_gone; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.44 2002/04/04 18:44:35 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.44 2002/04/04 18:44:35 millert Exp $";
d272 1
a272 1
	if (sc->sc_prism2)
d279 1
a279 1
		if (sc->sc_prism2)
d287 1
a287 1
		if (sc->sc_prism2)
d295 1
a295 1
		if (sc->sc_prism2)
d303 1
a303 1
		if (sc->sc_prism2)
d686 2
d690 16
d708 1
d730 1
a730 1
	if (sc->sc_prism2) {
d774 1
a774 1
	if (sc->sc_prism2) {
d800 1
a803 7
		case WI_RID_CNFAUTHMODE:
			oltv->wi_len = 2;
			if (ltv->wi_val & htole16(0x01))
				oltv->wi_val = htole16(1);
			else if (ltv->wi_val & htole16(0x02))
				oltv->wi_val = htole16(2);
			break;
d822 1
a822 1
	if (sc->sc_prism2) {
d850 3
a852 1
					p2ltv.wi_val = htole16(0x13);
d854 2
a855 1
					p2ltv.wi_val = htole16(0x03);
d857 1
a857 1
				p2ltv.wi_val = htole16(0x90);
a885 9
		case WI_RID_CNFAUTHMODE:
			p2ltv.wi_type = WI_RID_CNFAUTHMODE;
			p2ltv.wi_len = 2;
			if (ltv->wi_val == htole16(1))
				p2ltv.wi_val = htole16(0x01);
			else if (ltv->wi_val == htole16(2))
				p2ltv.wi_val = htole16(0x02);
			ltv = &p2ltv;
			break;
d1031 1
a1032 1
	*id = CSR_READ_2(sc, WI_ALLOC_FID);
d1316 3
a1318 2
		if (wreq.wi_type == WI_RID_IFACE_STATS) {
			error = EINVAL;
d1320 1
a1320 1
		} else if (wreq.wi_type == WI_RID_MGMT_XMIT) {
d1323 7
a1329 1
		} else {
d1448 3
a1450 2
	/* Roaming type */
	WI_SETVAL(WI_RID_ROAMING_MODE, sc->wi_roaming);
d1494 1
a1494 1
		if (sc->sc_prism2 && sc->wi_use_wep) {
d1496 2
a1497 1
			 * For Prism2 Firmware version less than 0.8.2.
d1503 2
a1504 1
			 if (sc->sc_prism2_ver < 82 ) {
d1712 3
a1714 1
				printf("wi_start: dropping unassoc dst %s\n",
a1715 1
			m_freem(m0);
d1791 4
a1794 2
			/* Do host encryption. */
			printf("XXX: host encrypt not implemented for 802.3\n");
d1818 1
a1818 1
		printf(WI_PRT_FMT ": xmit failed\n", WI_PRT_ARG(sc));
d1862 2
a1863 1
		printf(WI_PRT_FMT ": xmit failed\n", WI_PRT_ARG(sc));
d1932 1
d1939 1
d1964 1
a1964 1
			sc->sc_prism2 = 1;
d1968 1
a1968 1
			sc->sc_prism2 = 1;
d1972 1
a1972 1
			sc->sc_prism2 = 1;
d1976 1
a1976 1
			sc->sc_prism2 = 1;
d1980 1
a1980 1
			sc->sc_prism2 = 1;
d1984 1
a1984 1
			sc->sc_prism2 = 1;
d1988 1
a1988 1
			sc->sc_prism2 = 1;
d1992 1
a1992 1
			sc->sc_prism2 = 1;
d1996 1
a1996 1
			sc->sc_prism2 = 1;
d2000 1
a2000 1
			sc->sc_prism2 = 1;
d2003 6
a2008 2
			p = "Lucent chip or unknown chip";
			sc->sc_prism2 = 0;
d2012 12
a2023 1
	/* get firmware version */
d2031 23
a2053 7
	if (sc->sc_prism2) {
		printf("\n%s: %s, Firmware %d.%d.%d, ",
		    WI_PRT_ARG(sc), p, ver.wi_ver[2],
		    ver.wi_ver[3], ver.wi_ver[1]);
		sc->sc_prism2_ver = ver.wi_ver[2] * 100 +
				    ver.wi_ver[3] *  10 + ver.wi_ver[1];
	} else {
d2056 8
d2134 1
a2134 1
	    !sc->sc_prism2)
@


1.44
log
@wi_init() now takes a struct wi_softc * not a void * since an sc pointer
is available everywhere wi_init() is called.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.43 2002/04/03 21:52:08 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.43 2002/04/03 21:52:08 millert Exp $";
d344 1
a344 1
	if (!(ifp->if_flags & IFF_UP)) {
@


1.43
log
@In Host-AP mode, set IBSS SSID to the normal network id.  This makes
"ifconfig nwid FOO" work correctly in Host-AP mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.42 2002/04/02 21:47:26 markus Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.42 2002/04/02 21:47:26 markus Exp $";
d169 1
a169 1
void	wi_init(void *);
d1319 2
a1320 2
			if (!error && ifp->if_flags & IFF_UP)
				wi_init(ifp);
d1357 1
a1357 1
			wi_init(ifp);
d1390 2
a1391 2
wi_init(xsc)
	void			*xsc;
a1392 1
	struct wi_softc		*sc = xsc;
d2103 1
a2103 1
			wi_init(ifp);
d2187 1
a2187 1
		wi_init(&sc->arpcom.ac_if);
d2232 1
a2232 1
		wi_init(&sc->arpcom.ac_if);
@


1.42
log
@keylen is either 8 (40 bit secret ) or 16 (104 bit)
wrong index used for RC4SWAP during key setup
IV is stored in little endian format; works for millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.41 2002/04/02 08:44:57 markus Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.41 2002/04/02 08:44:57 markus Exp $";
a1437 3
	/* Specify the IBSS name */
	WI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);

d1440 6
@


1.41
log
@fix keyid encoding wi_tx_key
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.40 2002/04/02 06:01:44 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.40 2002/04/02 06:01:44 millert Exp $";
d1611 1
a1611 2
	if (klen > RC4KEYLEN)
		klen = RC4KEYLEN;
d1621 1
a1621 1
		RC4SWAP(x, y);
d1646 5
a1650 5
	/* append crc32 and encrypt */
	dat[0] = crc >> 24;
	dat[1] = crc >> 16;
	dat[2] = crc >> 8;
	dat[3] = crc;
@


1.40
log
@Prism2 firmware should be reported as version a.b.c not a.b variant c.
Only Lucent uses the 'variant' form.  Also, prism2 firmware 0.8.2 does
WEP w/o requiring promisc mode (from NetBSD).  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.39 2002/04/02 00:31:59 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.39 2002/04/02 00:31:59 mickey Exp $";
d1631 1
a1631 1
	dat[3] = sc->wi_tx_key % 4;
@


1.39
log
@always reset promisc in hostap mode (a comment added), a couple of formatiing and byte-swapping fixens as well
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.38 2002/04/01 20:42:18 markus Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.38 2002/04/01 20:42:18 markus Exp $";
d1465 1
a1465 1
	if (sc->wi_ptype != WI_PORTTYPE_AP && ifp->if_flags & IFF_PROMISC) {
d1467 1
a1467 1
	} else {
a1468 1
	}
d1479 1
a1479 1
			 * For Prism2 Firmware version less than 0.8 variant3.
d1485 2
a1486 2
			 if (sc->sc_prism2_ver < 83 ) {
				/* firm ver < 0.8 variant 3 */
d1993 1
a1993 1
		printf("\n%s: %s, Firmware %i.%i variant %i, ",
d1999 1
a1999 1
		printf("\n%s: Firmware %i.%i variant %i, ", WI_PRT_ARG(sc),
@


1.38
log
@always check for bad IVs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.37 2002/04/01 20:38:36 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.37 2002/04/01 20:38:36 millert Exp $";
d495 3
a497 3
		if (wi_read_data(sc, id, WI_802_11_OFFSET,
		    mtod(m, caddr_t) + sizeof(struct ether_header),
		    m->m_len + 2)) {
a498 1
			ifp->if_ierrors++;
d1242 1
a1242 7
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->wi_if_flags & IFF_PROMISC)) {
				WI_SETVAL(WI_RID_PROMISC, 1);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->wi_if_flags & IFF_PROMISC) {
d1244 10
d1256 2
a1257 5
		} else {
			if (ifp->if_flags & IFF_RUNNING) {
				wi_stop(sc);
			}
		}
d1457 9
a1465 2
	/* Initialize promisc mode. */
	if (ifp->if_flags & IFF_PROMISC) {
d1713 2
a1714 2
			tx_frame.wi_tx_ctl = WI_ENC_TX_MGMT; /* XXX */
			tx_frame.wi_frame_ctl |= WI_FCTL_FROMDS;
d1716 1
a1716 1
				tx_frame.wi_frame_ctl |= WI_FCTL_WEP;
@


1.37
log
@Missing splx in suser() check.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.36 2002/04/01 18:55:05 markus Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.36 2002/04/01 18:55:05 markus Exp $";
a1587 7
	} else if (sc->wi_icv >= 0x03ff00 &&
            (sc->wi_icv & 0xf8ff00) == 0x00ff00) {
		/*
		 * Skip 'bad' IVs from Fluhrer/Mantin/Shamir:
		 * (B, 255, N) with 3 <= B < 8
		 */
                sc->wi_icv += 0x000100;
d1590 7
@


1.36
log
@skip bad IVs; ok provos@@/deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.35 2002/04/01 07:12:05 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.35 2002/04/01 07:12:05 millert Exp $";
d1209 2
a1210 1
		if (error)
d1212 1
@


1.35
log
@Use WI_RID_DATA_RATES not WI_RID_SUPPORT_RATE to get the list of
supported data rates.  Fixes rate probing on Lucent cards.
Figured out from reading the Linux orinoco driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.34 2002/03/31 01:01:44 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.34 2002/03/31 01:01:44 millert Exp $";
d1586 9
a1594 2
	} else
		sc->wi_icv++;	/* XXX better IV needed */
@


1.34
log
@Fix logic thinko.  In AP mode we were never calling wihap_check_tx() if
the IFF_PROMISC flag was set (e.g. in bridge mode).  Found by mickey@@
There still seems to be an issue with Lucent stations reporting
1Mbs when the AP is in bridge mode though.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.33 2002/03/31 00:33:42 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.33 2002/03/31 00:33:42 mickey Exp $";
d258 2
a259 2
	/* Find supported rates (appears to be prism2 only) */
	gen.wi_type = WI_RID_SUPPORT_RATE;
d261 1
a261 1
	if (!sc->sc_prism2 || wi_read_record(sc, &gen))
@


1.33
log
@check for super user more; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.32 2002/03/30 22:43:58 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.32 2002/03/30 22:43:58 mickey Exp $";
d1676 2
a1677 3
		if (!(ifp->if_flags & IFF_PROMISC) &&
		    !wihap_check_tx(&sc->wi_hostap_info,
		        eh->ether_dhost, &tx_frame.wi_tx_rate)) {
@


1.32
log
@make sure that hostap never happens on non-prism2 cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.31 2002/03/30 20:23:28 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.31 2002/03/30 20:23:28 millert Exp $";
d1204 12
a1303 3
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			break;
a1340 3
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			break;
@


1.31
log
@WI_RID_SUPPORT_RATE only seems to work for prism2.  On lucent boards
it only indicates support for the lowest speed which is not what we want.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.30 2002/03/30 20:18:45 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.30 2002/03/30 20:18:45 mickey Exp $";
d2050 4
@


1.30
log
@only trust supported rates report on prism2 cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.29 2002/03/30 18:52:08 markus Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.29 2002/03/30 18:52:08 markus Exp $";
d258 1
a258 2
	 /* Find supported rates.
	  */
@


1.29
log
@missing suser on SIOCS80211NWID
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.28 2002/03/30 18:49:28 markus Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.28 2002/03/30 18:49:28 markus Exp $";
d262 1
a262 1
	if (wi_read_record(sc, &gen))
@


1.28
log
@implement WEP in wi_do_hostencrypt()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.27 2002/03/30 00:15:24 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.27 2002/03/30 00:15:24 millert Exp $";
d1333 3
@


1.27
log
@Actually write new value to the card for SIOCS80211NWID ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.26 2002/03/29 02:43:34 millert Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.26 2002/03/29 02:43:34 millert Exp $";
d1508 60
d1571 4
d1578 56
a1634 1

d1724 2
a1725 1
			tx_frame.wi_dat_len += 8;
@


1.26
log
@1) restrict 'hostap' mediaopt to prism2 chips
2) set ether_dhost and ether_shost based on wi_dst_addr and wi_src_addr
   respectively.  This allows packets to traverse the hostap and is also
   what FreeBSD and NetBSD both do.
3) Move the setting of tx_frame.wi_frame_ctl to be right after we zero
   tx_frame.  Otherwise we end up clearing the WI_FCTL_FROMDS flag.
4) Use some ETHER_* constants instead of hard-coding things (cosmetic only)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.25 2002/03/28 18:21:06 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.25 2002/03/28 18:21:06 mickey Exp $";
d1344 1
@


1.25
log
@basic host-ap implementation, more work is needed; from Thomas Skibo <skibo@@pacbell.net>; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.24 2002/03/28 17:41:02 mickey Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.24 2002/03/28 17:41:02 mickey Exp $";
d273 3
a275 2
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
	    IFM_IEEE80211_HOSTAP, 0), 0);
d280 3
a282 2
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
		    IFM_IEEE80211_HOSTAP, 0), 0);
d288 3
a290 2
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
		    IFM_IEEE80211_HOSTAP, 0), 0);
d296 3
a298 2
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
		    IFM_IEEE80211_HOSTAP, 0), 0);
d304 3
a306 2
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
		    IFM_IEEE80211_HOSTAP, 0), 0);
d489 1
a489 1
		bcopy((char *)&rx_frame.wi_addr1,
d491 1
a491 1
		bcopy((char *)&rx_frame.wi_addr2,
d494 1
a494 1
		    (char *)&eh->ether_type, sizeof(u_int16_t));
d1482 1
a1482 1
	if (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))
d1487 1
a1487 1
	if (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))
d1543 1
a1586 1
		tx_frame.wi_frame_ctl = htole16(WI_FTYPE_DATA);
@


1.24
log
@recognize isl37300p as a prism2.5, for niels baby
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.23 2002/03/26 18:59:11 millert Exp $	*/
d98 2
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.23 2002/03/26 18:59:11 millert Exp $";
a154 1
STATIC int wi_mgmt_xmit(struct wi_softc *, caddr_t, int);
d258 10
d273 31
a303 13
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_MANUAL, 0, 0), 0);
d433 36
d522 10
d781 1
a781 1
		case WI_RID_AUTH_CNTL:
d830 7
a836 1
				p2ltv.wi_val = htole16(0x03);
d867 2
a868 2
		case WI_RID_AUTH_CNTL:
			p2ltv.wi_type = WI_RID_AUTH_CNTL;
d1143 1
a1143 1
	case WI_RID_AUTH_CNTL:
d1355 9
d1467 1
a1467 1
			 WI_SETVAL(WI_RID_AUTH_CNTL, sc->wi_authtype);
d1490 2
d1502 10
d1532 1
d1541 12
d1563 12
a1574 2
		bcopy((char *)&eh->ether_shost,
		    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
d1587 32
a1618 8
		m_copydata(m0, sizeof(struct ether_header),
		    m0->m_pkthdr.len - sizeof(struct ether_header),
		    (caddr_t)&sc->wi_txbuf);

		wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
		    sizeof(struct wi_frame));
		wi_write_data(sc, id, WI_802_11_OFFSET, (caddr_t)&sc->wi_txbuf,
		    (m0->m_pkthdr.len - sizeof(struct ether_header)) + 2);
d1622 7
a1628 1
		m_copydata(m0, 0, m0->m_pkthdr.len, (caddr_t)&sc->wi_txbuf);
d1630 5
a1634 4
		wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
		    sizeof(struct wi_frame));
		wi_write_data(sc, id, WI_802_3_OFFSET, (caddr_t)&sc->wi_txbuf,
		    m0->m_pkthdr.len + 2);
d1684 3
a1686 2
	tx_frame.wi_dat_len = htole16(len - WI_SNAPHDR_LEN);
	tx_frame.wi_len = htons(len - WI_SNAPHDR_LEN);
d1706 2
d1760 1
a1760 1
	struct wi_ltv_ver       ver;
d1885 1
a1885 1
		subtype = IFM_MANUAL;           /* Unable to represent */
d1897 1
a1897 1
		subtype = IFM_MANUAL;           /* Unable to represent */
d1918 5
a1922 1
	if ((sc->sc_media.ifm_cur->ifm_media & IFM_IEEE80211_ADHOC) != 0)
d1924 2
d1986 1
a1986 2
	if (nwkey->i_defkid <= 0 ||
	    nwkey->i_defkid > IEEE80211_WEP_NKID)
@


1.23
log
@Fix 128bit WEP on prism2; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.22 2002/03/14 01:26:54 millert Exp $	*/
d125 1
a125 1
	"$OpenBSD: if_wi.c,v 1.22 2002/03/14 01:26:54 millert Exp $";
d1665 4
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.21 2002/02/20 21:51:07 millert Exp $	*/
d125 1
a125 1
	"$OpenBSD: if_wi.c,v 1.21 2002/02/20 21:51:07 millert Exp $";
d768 1
d771 2
d775 1
a775 13
					if (wk->wi_keys[i].wi_keylen <= 5) {
						/* 5 Octet WEP Keys */
						ws.wi_len = 4;
						bcopy(&wk->wi_keys[i].wi_keydat,
						    ws.wi_str, 5);
						ws.wi_str[5] = '\0';
					} else {
						/* 13 Octet WEP Keys */
						ws.wi_len = 8;
						bcopy(&wk->wi_keys[i].wi_keydat,
						    ws.wi_str, 13);
						ws.wi_str[13] = '\0';
					}
d777 2
@


1.21
log
@104 byte WEP key support for Prism2 cards; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.20 2002/02/20 20:52:42 millert Exp $	*/
d125 1
a125 1
	"$OpenBSD: if_wi.c,v 1.20 2002/02/20 20:52:42 millert Exp $";
d132 38
a169 38
STATIC void wi_reset		__P((struct wi_softc *));
STATIC int wi_ioctl		__P((struct ifnet *, u_long, caddr_t));
STATIC void wi_start		__P((struct ifnet *));
STATIC void wi_watchdog		__P((struct ifnet *));
STATIC void wi_shutdown		__P((void *));
STATIC void wi_rxeof		__P((struct wi_softc *));
STATIC void wi_txeof		__P((struct wi_softc *, int));
STATIC void wi_update_stats	__P((struct wi_softc *));
STATIC void wi_setmulti		__P((struct wi_softc *));

STATIC int wi_cmd		__P((struct wi_softc *, int, int));
STATIC int wi_read_record	__P((struct wi_softc *, struct wi_ltv_gen *));
STATIC int wi_write_record	__P((struct wi_softc *, struct wi_ltv_gen *));
STATIC int wi_read_data		__P((struct wi_softc *, int,
					int, caddr_t, int));
STATIC int wi_write_data	__P((struct wi_softc *, int,
					int, caddr_t, int));
STATIC int wi_seek		__P((struct wi_softc *, int, int, int));
STATIC int wi_alloc_nicmem	__P((struct wi_softc *, int, int *));
STATIC void wi_inquire		__P((void *));
STATIC int wi_setdef		__P((struct wi_softc *, struct wi_req *));
STATIC int wi_mgmt_xmit		__P((struct wi_softc *, caddr_t, int));
STATIC void wi_get_id		__P((struct wi_softc *, int));

STATIC int wi_media_change __P((struct ifnet *));
STATIC void wi_media_status __P((struct ifnet *, struct ifmediareq *));

STATIC int wi_set_ssid __P((struct ieee80211_nwid *, u_int8_t *, int));
STATIC int wi_set_nwkey __P((struct wi_softc *, struct ieee80211_nwkey *));
STATIC int wi_get_nwkey __P((struct wi_softc *, struct ieee80211_nwkey *));
STATIC int wi_sync_media __P((struct wi_softc *, int, int));
STATIC int wi_set_pm __P((struct wi_softc *, struct ieee80211_power *));
STATIC int wi_get_pm __P((struct wi_softc *, struct ieee80211_power *));

int	wi_intr			__P((void *));
int	wi_attach		__P((struct wi_softc *, int));
void	wi_init			__P((void *));
void	wi_stop			__P((struct wi_softc *));
@


1.20
log
@Remove useless prototypes for wi_request_fill_ssid() and wi_write_ssid().
Unike NetBSD we use a macro instead of those functions.  mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.19 2002/02/19 01:24:58 mickey Exp $	*/
d125 1
a125 1
	"$OpenBSD: if_wi.c,v 1.19 2002/02/19 01:24:58 mickey Exp $";
d771 14
a784 1
					ws.wi_len = 4;
a785 3
					bcopy(&wk->wi_keys[i].wi_keydat,
					    ws.wi_str, 5);
					ws.wi_str[5] = '\0';
@


1.19
log
@add support for media and other generic 802.11 ioctls, elliminates need for wicontrol on the ramdisk floppy, pretty much; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.18 2001/12/21 15:48:19 mickey Exp $	*/
d125 1
a125 1
	"$OpenBSD: if_wi.c,v 1.18 2001/12/21 15:48:19 mickey Exp $";
a159 4
STATIC void wi_request_fill_ssid __P((struct wi_req *,
    struct ieee80211_nwid *));
STATIC int wi_write_ssid __P((struct wi_softc *, int, struct wi_req *,
    struct ieee80211_nwid *));
@


1.18
log
@increase the timeout 10x, it seems some cards cannot keep up w/ our pace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.17 2001/10/25 16:39:25 mickey Exp $	*/
d90 2
d125 1
a125 1
	"$OpenBSD: if_wi.c,v 1.17 2001/10/25 16:39:25 mickey Exp $";
d152 1
a152 1
STATIC void wi_setdef		__P((struct wi_softc *, struct wi_req *));
d156 14
d218 1
a218 2
	bzero(sc->wi_node_name, sizeof(sc->wi_node_name));
	bcopy(WI_DEFAULT_NODENAME, sc->wi_node_name,
d220 1
a220 3

	bzero(sc->wi_net_name, sizeof(sc->wi_net_name));
	bcopy(WI_DEFAULT_NETNAME, sc->wi_net_name,
d222 1
a222 3

	bzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));
	bcopy(WI_DEFAULT_IBSS, sc->wi_ibss_name,
d261 22
d998 1
a998 1
STATIC void
d1007 1
d1020 2
a1021 1
		sc->wi_ptype = letoh16(wreq->wi_val[0]);
d1024 2
a1025 1
		sc->wi_tx_rate = letoh16(wreq->wi_val[0]);
d1043 2
a1044 2
		bzero(sc->wi_node_name, sizeof(sc->wi_node_name));
		bcopy((char *)&wreq->wi_val[1], sc->wi_node_name, 30);
d1047 2
a1048 2
		bzero(sc->wi_net_name, sizeof(sc->wi_net_name));
		bcopy((char *)&wreq->wi_val[1], sc->wi_net_name, 30);
d1051 2
a1052 2
		bzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));
		bcopy((char *)&wreq->wi_val[1], sc->wi_ibss_name, 30);
d1080 1
d1084 1
a1084 4
	/* Reinitialize WaveLAN. */
	wi_init(sc);

	return;
d1099 1
d1178 4
d1223 3
a1225 1
				wi_setdef(sc, &wreq);
d1228 47
d1694 245
@


1.17
log
@add prism2.5 mini-pci nic id
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.16 2001/07/08 23:38:05 fgsch Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.16 2001/07/08 23:38:05 fgsch Exp $";
d541 1
a541 1
		DELAY(1);
d549 1
a549 1
	for (i = WI_TIMEOUT; i--; DELAY(1)) {
d808 1
a808 1
	for (i = WI_TIMEOUT; i--; DELAY(1))
d900 1
a900 1
	for (i = WI_TIMEOUT; i--; DELAY(1)) {
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.18 2001/12/21 15:48:19 mickey Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.18 2001/12/21 15:48:19 mickey Exp $";
d541 1
a541 1
		DELAY(10);
d549 1
a549 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
d808 1
a808 1
	for (i = WI_TIMEOUT; i--; DELAY(10))
d900 1
a900 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.17.2.1 2002/01/31 22:55:31 niklas Exp $	*/
a89 2
#include <net/if_ieee80211.h>

a95 2
#include <dev/rndvar.h>

d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.17.2.1 2002/01/31 22:55:31 niklas Exp $";
d130 28
a157 41
STATIC void wi_reset(struct wi_softc *);
STATIC void wi_cor_reset(struct wi_softc *);
STATIC int wi_ioctl(struct ifnet *, u_long, caddr_t);
STATIC void wi_start(struct ifnet *);
STATIC void wi_watchdog(struct ifnet *);
STATIC void wi_shutdown(void *);
STATIC void wi_rxeof(struct wi_softc *);
STATIC void wi_txeof(struct wi_softc *, int);
STATIC void wi_update_stats(struct wi_softc *);
STATIC void wi_setmulti(struct wi_softc *);

STATIC int wi_cmd(struct wi_softc *, int, int, int, int);
STATIC int wi_read_record(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_write_record(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_read_data(struct wi_softc *, int,
					int, caddr_t, int);
STATIC int wi_write_data(struct wi_softc *, int,
					int, caddr_t, int);
STATIC int wi_seek(struct wi_softc *, int, int, int);
STATIC int wi_alloc_nicmem(struct wi_softc *, int, int *);
STATIC void wi_inquire(void *);
STATIC int wi_setdef(struct wi_softc *, struct wi_req *);
STATIC void wi_get_id(struct wi_softc *);

STATIC int wi_media_change(struct ifnet *);
STATIC void wi_media_status(struct ifnet *, struct ifmediareq *);

STATIC int wi_set_ssid(struct ieee80211_nwid *, u_int8_t *, int);
STATIC int wi_set_nwkey(struct wi_softc *, struct ieee80211_nwkey *);
STATIC int wi_get_nwkey(struct wi_softc *, struct ieee80211_nwkey *);
STATIC int wi_sync_media(struct wi_softc *, int, int);
STATIC int wi_set_pm(struct wi_softc *, struct ieee80211_power *);
STATIC int wi_get_pm(struct wi_softc *, struct ieee80211_power *);

STATIC int wi_get_debug(struct wi_softc *, struct wi_req *);
STATIC int wi_set_debug(struct wi_softc *, struct wi_req *);

int	wi_intr(void *);
int	wi_attach(struct wi_softc *);
void	wi_init(struct wi_softc *);
void	wi_stop(struct wi_softc *);
d165 1
a165 1
wi_attach(sc)
d167 1
d174 1
a174 1
	sc->wi_flags = WI_FLAGS_ATTACHED;
a175 1
	wi_cor_reset(sc);
d186 1
a186 1
	bcopy((char *)&mac.wi_mac_addr, (char *)&sc->sc_arpcom.ac_enaddr,
d189 2
a190 2
	wi_get_id(sc);
	printf("address %s", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d192 1
a192 1
	ifp = &sc->sc_arpcom.ac_if;
d202 2
a203 1
	(void)wi_set_ssid(&sc->wi_node_name, WI_DEFAULT_NODENAME,
d205 3
a207 1
	(void)wi_set_ssid(&sc->wi_net_name, WI_DEFAULT_NETNAME,
d209 3
a211 1
	(void)wi_set_ssid(&sc->wi_ibss_name, WI_DEFAULT_IBSS,
a224 1
	sc->wi_diversity = WI_DEFAULT_DIVERSITY;
a239 32
	 * Set flags based on firmware version.
	 */
	switch (sc->sc_firmware_type) {
	case WI_LUCENT:
		sc->wi_flags |= WI_FLAGS_HAS_ROAMING;
		if (sc->sc_sta_firmware_ver >= 60000)
			sc->wi_flags |= WI_FLAGS_HAS_MOR;
		if (sc->sc_sta_firmware_ver >= 60006) {
			sc->wi_flags |= WI_FLAGS_HAS_IBSS;
			sc->wi_flags |= WI_FLAGS_HAS_CREATE_IBSS;
		}
		sc->wi_ibss_port = htole16(1);
		break;
	case WI_INTERSIL:
		sc->wi_flags |= WI_FLAGS_HAS_ROAMING;
		if (sc->sc_sta_firmware_ver >= 800) {
			sc->wi_flags |= WI_FLAGS_HAS_IBSS;
			sc->wi_flags |= WI_FLAGS_HAS_CREATE_IBSS;
		}
		sc->wi_ibss_port = htole16(0);
		break;
	case WI_SYMBOL:
		sc->wi_flags |= WI_FLAGS_HAS_DIVERSITY;
		if (sc->sc_sta_firmware_ver >= 20000)
			sc->wi_flags |= WI_FLAGS_HAS_IBSS;
		if (sc->sc_sta_firmware_ver >= 25000)
			sc->wi_flags |= WI_FLAGS_HAS_CREATE_IBSS;
		sc->wi_ibss_port = htole16(4);
		break;
	}

	/*
d244 2
a245 2
	if (wi_read_record(sc, &gen) == 0 && gen.wi_val != htole16(0))
		sc->wi_flags |= WI_FLAGS_HAS_WEP;
a249 83
	/* Find supported rates. */
	gen.wi_type = WI_RID_DATA_RATES;
	gen.wi_len = 2;
	if (wi_read_record(sc, &gen))
		sc->wi_supprates = WI_SUPPRATES_1M | WI_SUPPRATES_2M |
		    WI_SUPPRATES_5M | WI_SUPPRATES_11M;
	else
		sc->wi_supprates = gen.wi_val;

	ifmedia_init(&sc->sc_media, 0, wi_media_change, wi_media_status);
#define	ADD(m, c)	ifmedia_add(&sc->sc_media, (m), (c), NULL)
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, IFM_IEEE80211_ADHOC, 0), 0);
	if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, IFM_IEEE80211_IBSS,
		    0), 0);
	if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
		    IFM_IEEE80211_IBSSMASTER, 0), 0);
	if (sc->sc_firmware_type == WI_INTERSIL)
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
		    IFM_IEEE80211_HOSTAP, 0), 0);
	if (sc->wi_supprates & WI_SUPPRATES_1M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->sc_firmware_type == WI_INTERSIL)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
			    IFM_IEEE80211_HOSTAP, 0), 0);
	}
	if (sc->wi_supprates & WI_SUPPRATES_2M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->sc_firmware_type == WI_INTERSIL)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
			    IFM_IEEE80211_HOSTAP, 0), 0);
	}
	if (sc->wi_supprates & WI_SUPPRATES_5M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->sc_firmware_type == WI_INTERSIL)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
			    IFM_IEEE80211_HOSTAP, 0), 0);
	}
	if (sc->wi_supprates & WI_SUPPRATES_11M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->sc_firmware_type == WI_INTERSIL)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
			    IFM_IEEE80211_HOSTAP, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_MANUAL, 0, 0), 0);
	}
#undef ADD
	ifmedia_set(&sc->sc_media,
	    IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, 0, 0));

d258 1
a258 1
	BPFATTACH(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
d280 1
a280 1
	ifp = &sc->sc_arpcom.ac_if;
d282 1
a282 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED) || !(ifp->if_flags & IFF_UP)) {
d341 1
a342 1
	u_int16_t		msg_type;
d345 1
a345 1
	ifp = &sc->sc_arpcom.ac_if;
d349 5
a353 3
	if (sc->wi_procframe || sc->wi_debug.wi_monitor) {
		struct wi_frame	*rx_frame;
		int		datlen, hdrlen;
d355 4
a358 11
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			ifp->if_ierrors++;
			return;
		}
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}
d360 11
a370 8
		m->m_pkthdr.rcvif = ifp;

		if (wi_read_data(sc, id, 0, mtod(m, caddr_t),
		    sizeof(struct wi_frame))) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}
d372 2
a373 1
		rx_frame = mtod(m, struct wi_frame *);
d375 8
a382 1
		if (rx_frame->wi_status & htole16(WI_STAT_BADCRC)) {
d387 2
d390 10
a399 33
		switch ((letoh16(rx_frame->wi_status) & WI_STAT_MAC_PORT)
		    >> 8) {
		case 7:
			switch (letoh16(rx_frame->wi_frame_ctl) &
			    WI_FCTL_FTYPE) {
			case WI_FTYPE_DATA:
				hdrlen = WI_DATA_HDRLEN;
				datlen = letoh16(rx_frame->wi_dat_len);
				break;
			case WI_FTYPE_MGMT:
				hdrlen = WI_MGMT_HDRLEN;
				datlen = letoh16(rx_frame->wi_dat_len);
				break;
			case WI_FTYPE_CTL:
				hdrlen = WI_CTL_HDRLEN;
				datlen = 0;
				break;
			default:
				printf(WI_PRT_FMT ": received packet of "
				    "unknown type on port 7\n", WI_PRT_ARG(sc));
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			break;
		case 0:
			hdrlen = WI_DATA_HDRLEN;
			datlen = letoh16(rx_frame->wi_dat_len);
			break;
		default:
			printf(WI_PRT_FMT ": received packet on invalid port "
			    "(wi_status=0x%x)\n", WI_PRT_ARG(sc),
			    letoh16(rx_frame->wi_status));
d404 7
a410 2

		if ((hdrlen + datlen + 2) > MCLBYTES) {
d415 2
d418 2
a419 2
		if (wi_read_data(sc, id, hdrlen, mtod(m, caddr_t) + hdrlen,
		    datlen + 2)) {
d424 1
d426 1
a426 148
		m->m_pkthdr.len = m->m_len = hdrlen + datlen;
	} else {
		struct wi_frame rx_frame;

		/* First read in the frame header */
		if (wi_read_data(sc, id, 0, (caddr_t)&rx_frame,
		    sizeof(rx_frame))) {
			ifp->if_ierrors++;
			return;
		}

		/* Drop undecryptable or packets with receive errors here */
		if (rx_frame.wi_status & htole16(WI_STAT_ERRSTAT)) {
			ifp->if_ierrors++;
			return;
		}

		/* Stash message type in host byte order for later use */
		msg_type = letoh16(rx_frame.wi_status) & WI_RXSTAT_MSG_TYPE;

		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			ifp->if_ierrors++;
			return;
		}
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		/* Align the data after the ethernet header */
		m->m_data = (caddr_t)ALIGN(m->m_data +
		    sizeof(struct ether_header)) - sizeof(struct ether_header);

		eh = mtod(m, struct ether_header *);
		m->m_pkthdr.rcvif = ifp;

		if (msg_type == WI_STAT_MGMT &&
		    sc->wi_ptype == WI_PORTTYPE_AP) {

			u_int16_t rxlen = letoh16(rx_frame.wi_dat_len);

			if ((WI_802_11_OFFSET_RAW + rxlen + 2) > MCLBYTES) {
				printf("%s: oversized mgmt packet received in "
				    "hostap mode (wi_dat_len=%d, "
				    "wi_status=0x%x)\n", sc->sc_dev.dv_xname,
				    rxlen, letoh16(rx_frame.wi_status));
				m_freem(m);
				ifp->if_ierrors++;  
				return;
			}

			/* Put the whole header in there. */
			bcopy(&rx_frame, mtod(m, void *),
			    sizeof(struct wi_frame));
			if (wi_read_data(sc, id, WI_802_11_OFFSET_RAW,
			    mtod(m, caddr_t) + WI_802_11_OFFSET_RAW,
			    rxlen + 2)) {
				m_freem(m);
				if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
					printf("wihap: failed to copy header\n");
				ifp->if_ierrors++;
				return;
			}

			m->m_pkthdr.len = m->m_len =
			    WI_802_11_OFFSET_RAW + rxlen;

			/* XXX: consider giving packet to bhp? */

			wihap_mgmt_input(sc, &rx_frame, m);

			return;
		}

		switch (msg_type) {
		case WI_STAT_1042:
		case WI_STAT_TUNNEL:
		case WI_STAT_WMP_MSG:
			if ((letoh16(rx_frame.wi_dat_len) + WI_SNAPHDR_LEN) >
			    MCLBYTES) {
				printf(WI_PRT_FMT ": oversized packet received "
				    "(wi_dat_len=%d, wi_status=0x%x)\n",
				    WI_PRT_ARG(sc),
				    letoh16(rx_frame.wi_dat_len),
				    letoh16(rx_frame.wi_status));
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			m->m_pkthdr.len = m->m_len =
			    letoh16(rx_frame.wi_dat_len) + WI_SNAPHDR_LEN;

			bcopy((char *)&rx_frame.wi_dst_addr,
			    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);
			bcopy((char *)&rx_frame.wi_src_addr,
			    (char *)&eh->ether_shost, ETHER_ADDR_LEN);
			bcopy((char *)&rx_frame.wi_type,
			    (char *)&eh->ether_type, ETHER_TYPE_LEN);

			if (wi_read_data(sc, id, WI_802_11_OFFSET,
			    mtod(m, caddr_t) + sizeof(struct ether_header),
			    m->m_len + 2)) {
				ifp->if_ierrors++;
				m_freem(m);
				return;
			}
			break;
		default:
			if ((letoh16(rx_frame.wi_dat_len) +
			    sizeof(struct ether_header)) > MCLBYTES) {
				printf(WI_PRT_FMT ": oversized packet received "
				    "(wi_dat_len=%d, wi_status=0x%x)\n",
				    WI_PRT_ARG(sc),
				    letoh16(rx_frame.wi_dat_len),
				    letoh16(rx_frame.wi_status));
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			m->m_pkthdr.len = m->m_len =
			    letoh16(rx_frame.wi_dat_len) +
			    sizeof(struct ether_header);

			if (wi_read_data(sc, id, WI_802_3_OFFSET,
			    mtod(m, caddr_t), m->m_len + 2)) {
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			break;
		}

		ifp->if_ipackets++;

		if (sc->wi_ptype == WI_PORTTYPE_AP) {
			/*
			 * Give host AP code first crack at data packets.
			 * If it decides to handle it (or drop it), it will
			 * return a non-zero.  Otherwise, it is destined for
			 * this host.
			 */
			if (wihap_data_input(sc, &rx_frame, m))
				return;
		}
	}
d434 2
a435 5
	/* Receive packet unless in procframe or monitor mode. */
	if (sc->wi_procframe || sc->wi_debug.wi_monitor)
		m_freem(m);
	else
		ether_input_mbuf(ifp, m);
d447 1
a447 1
	ifp = &sc->sc_arpcom.ac_if;
d469 1
a469 1
	ifp = &sc->sc_arpcom.ac_if;
d478 1
a478 1
	rv = wi_cmd(sc, WI_CMD_INQUIRE, WI_INFO_COUNTERS, 0, 0);
d498 1
a498 1
	ifp = &sc->sc_arpcom.ac_if;
d504 1
a504 6
	if (gen.wi_type == htole16(WI_INFO_SCAN_RESULTS)) {
		sc->wi_scanbuf_len = letoh16(gen.wi_len);
		wi_read_data(sc, id, 4, (char *)sc->wi_scanbuf,
		    sc->wi_scanbuf_len * 2);
		return;
	} else if (gen.wi_type != htole16(WI_INFO_COUNTERS))
d508 2
a509 2
	len = (letoh16(gen.wi_len) - 1 < sizeof(sc->wi_stats) / 4) ?
	    letoh16(gen.wi_len) - 1 : sizeof(sc->wi_stats) / 4;
d530 1
a530 1
wi_cmd(sc, cmd, val0, val1, val2)
d533 1
a533 3
	int			val0;
	int			val1;
	int			val2;
d544 3
a546 3
	CSR_WRITE_2(sc, WI_PARAM0, val0);
	CSR_WRITE_2(sc, WI_PARAM1, val1);
	CSR_WRITE_2(sc, WI_PARAM2, val2);
d581 1
a581 6
	/* Symbol firmware cannot be initialized more than once. */
	if (sc->sc_firmware_type == WI_SYMBOL &&
	    (sc->wi_flags & WI_FLAGS_INITIALIZED))
		return;

	if (wi_cmd(sc, WI_CMD_INI, 0, 0, 0))
a582 3
	else
		sc->wi_flags |= WI_FLAGS_INITIALIZED;

a591 28
STATIC void
wi_cor_reset(sc)
	struct wi_softc		*sc;
{
	u_int8_t cor_value;

	DPRINTF(WID_RESET, ("wi_cor_reset: sc %p\n", sc));

	/*
	 * Do a soft reset of the card; this is required for Symbol cards.
	 * This shouldn't hurt other cards but there have been reports
	 * of the COR reset messing up old Lucent firmware revisions so
	 * we only soft reset Symbol cards for now.
	 */
	if (sc->sc_firmware_type == WI_SYMBOL) {
		cor_value = bus_space_read_2(sc->wi_ltag, sc->wi_lhandle,
		    sc->wi_cor_offset);
		bus_space_write_1(sc->wi_ltag, sc->wi_lhandle,
		    sc->wi_cor_offset, (cor_value | WI_COR_SOFT_RESET));
		DELAY(1000);
		bus_space_write_1(sc->wi_ltag, sc->wi_lhandle,
		    sc->wi_cor_offset, (cor_value & ~WI_COR_SOFT_RESET));
		DELAY(1000);
	}

	return;
}

d604 1
a604 1
	if (sc->sc_firmware_type != WI_LUCENT) {
d621 1
a621 1
	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type, 0, 0))
d648 1
a648 9
	if (ltv->wi_type == WI_RID_PORTTYPE && sc->wi_ptype == WI_PORTTYPE_IBSS
	    && ltv->wi_val == sc->wi_ibss_port) {
		/*
		 * Convert vendor IBSS port type to WI_PORTTYPE_IBSS.
		 * Since Lucent uses port type 1 for BSS *and* IBSS we
		 * have to rely on wi_ptype to distinguish this for us.
		 */
		ltv->wi_val = htole16(WI_PORTTYPE_IBSS);
	} else if (sc->sc_firmware_type != WI_LUCENT) {
a673 1
		case WI_RID_CNFAUTHMODE:
d677 7
a698 1
	u_int16_t		val;
d702 1
a702 8
	if (ltv->wi_type == WI_RID_PORTTYPE &&
	    letoh16(ltv->wi_val) == WI_PORTTYPE_IBSS) {
		/* Convert WI_PORTTYPE_IBSS to vendor IBSS port type. */
		p2ltv.wi_type = WI_RID_PORTTYPE;
		p2ltv.wi_len = 2;
		p2ltv.wi_val = sc->wi_ibss_port;
		ltv = &p2ltv;
	} else if (sc->sc_firmware_type != WI_LUCENT) {
d725 4
a728 19
			if (ltv->wi_val & htole16(0x01)) {
				val = PRIVACY_INVOKED;
				/*
				 * If using shared key WEP we must set the
				 * EXCLUDE_UNENCRYPTED bit.  Symbol cards
				 * need this bit set even when not using
				 * shared key. We can't just test for
				 * IEEE80211_AUTH_SHARED since Symbol cards
				 * have 2 shared key modes.
				 */
				if (sc->wi_authtype != IEEE80211_AUTH_OPEN ||
				    sc->sc_firmware_type == WI_SYMBOL)
					val |= EXCLUDE_UNENCRYPTED;
				/* TX encryption is broken in Host AP mode. */
				if (sc->wi_ptype == WI_PORTTYPE_AP)
					val |= HOST_ENCRYPT;
				p2ltv.wi_val = htole16(val);
			} else
				p2ltv.wi_val = htole16(HOST_ENCRYPT | HOST_DECRYPT);
a738 1
				int keylen;
a740 2
				keylen = wk->wi_keys[sc->wi_tx_key].wi_keylen;

d742 1
a742 2
					bzero(&ws, sizeof(ws));
					ws.wi_len = (keylen > 5) ? 8 : 4;
d745 2
a746 1
					    ws.wi_str, keylen);
d754 9
d776 1
a776 1
	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type, 0, 0))
d894 1
a894 1
	if (wi_cmd(sc, WI_CMD_ALLOC_MEM, len, 0, 0)) {
d908 1
a909 1
	CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);
d930 1
a930 1
	ifp = &sc->sc_arpcom.ac_if;
d942 1
a942 1
	ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
d965 1
a965 1
STATIC int
a973 1
	int error = 0;
d975 1
a975 1
	ifp = &sc->sc_arpcom.ac_if;
d982 1
a982 1
		bcopy((char *)&wreq->wi_val, (char *)&sc->sc_arpcom.ac_enaddr,
d986 1
a986 2
		error = wi_sync_media(sc, letoh16(wreq->wi_val[0]),
		    sc->wi_tx_rate);
d989 1
a989 2
		error = wi_sync_media(sc, sc->wi_ptype,
		    letoh16(wreq->wi_val[0]));
a1001 1
		error = wi_sync_media(sc, sc->wi_ptype, sc->wi_tx_rate);
d1007 2
a1008 2
		error = wi_set_ssid(&sc->wi_node_name,
		    (u_int8_t *)&wreq->wi_val[1], letoh16(wreq->wi_val[0]));
d1011 2
a1012 2
		error = wi_set_ssid(&sc->wi_net_name,
		    (u_int8_t *)&wreq->wi_val[1], letoh16(wreq->wi_val[0]));
d1015 2
a1016 2
		error = wi_set_ssid(&sc->wi_ibss_name,
		    (u_int8_t *)&wreq->wi_val[1], letoh16(wreq->wi_val[0]));
d1027 1
a1027 1
	case WI_RID_CNFAUTHMODE:
a1032 3
	case WI_RID_SYMBOL_DIVERSITY:
		sc->wi_diversity = letoh16(wreq->wi_val[0]);
		break;
a1043 1
		error = EINVAL;
d1047 4
a1050 1
	return (error);
a1064 1
	struct ieee80211_nwid	nwid;
d1071 1
a1071 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED)) {
d1079 1
a1079 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
a1084 15
	case SIOCSWAVELAN:
	case SIOCSPRISM2DEBUG:
	case SIOCS80211NWID:
	case SIOCS80211NWKEY:
	case SIOCS80211POWER:
		error = suser(p->p_ucred, &p->p_acflag);
		if (error) {
			splx(s);
			return (error);
		}
	default:
		break;
	}

	switch(command) {
d1091 1
a1091 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1110 7
a1116 1
			if (sc->wi_ptype == WI_PORTTYPE_AP) {
a1117 10
			} else {
				if (ifp->if_flags & IFF_RUNNING &&
				    ifp->if_flags & IFF_PROMISC &&
				    !(sc->wi_if_flags & IFF_PROMISC)) {
					WI_SETVAL(WI_RID_PROMISC, 1);
				} else if (ifp->if_flags & IFF_RUNNING &&
				    !(ifp->if_flags & IFF_PROMISC) &&
				    sc->wi_if_flags & IFF_PROMISC) {
					WI_SETVAL(WI_RID_PROMISC, 0);
				}
d1120 5
a1124 2
		} else if (ifp->if_flags & IFF_RUNNING)
			wi_stop(sc);
d1132 2
a1133 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
a1142 4
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, command);
		break;
d1147 1
a1147 6
		if (wreq.wi_len > WI_MAX_DATALEN) {
			error = EINVAL;
			break;
		}
		switch (wreq.wi_type) {
		case WI_RID_IFACE_STATS:
d1152 1
a1152 2
			break;
		case WI_RID_DEFLT_CRYPT_KEYS:
d1160 1
a1160 19
			break;
		case WI_RID_PROCFRAME:
			wreq.wi_len = 2;
			wreq.wi_val[0] = htole16(sc->wi_procframe);
			break;
		case WI_RID_PRISM2:
			wreq.wi_len = 2;
			wreq.wi_val[0] = htole16(sc->sc_firmware_type ==
			    WI_LUCENT ? 0 : 1);
			break;
		case WI_RID_SCAN_RES:
			if (sc->sc_firmware_type == WI_LUCENT) {
				memcpy((char *)wreq.wi_val,
				    (char *)sc->wi_scanbuf,
				    sc->wi_scanbuf_len * 2);
				wreq.wi_len = sc->wi_scanbuf_len;
				break;
			}
		default:
d1163 1
a1164 1
			break;
d1169 3
d1175 2
a1176 5
		error = EINVAL;
		if (wreq.wi_len > WI_MAX_DATALEN)
			break;
		switch (wreq.wi_type) {
		case WI_RID_IFACE_STATS:
d1178 1
a1178 1
		case WI_RID_MGMT_XMIT:
d1181 1
a1181 33
			break;
		case WI_RID_PROCFRAME:
			sc->wi_procframe = letoh16(wreq.wi_val[0]);
			error = 0;
			break;
		case WI_RID_SCAN_REQ:
			error = 0;
			if (sc->sc_firmware_type == WI_LUCENT)
				wi_cmd(sc, WI_CMD_INQUIRE,
				    WI_INFO_SCAN_RESULTS, 0, 0);
			else
				error = wi_write_record(sc,
				    (struct wi_ltv_gen *)&wreq);
			break;
		case WI_RID_SYMBOL_DIVERSITY:
		case WI_RID_ROAMING_MODE:
		case WI_RID_CREATE_IBSS:
		case WI_RID_MICROWAVE_OVEN:
			/*
			 * Check for features that may not be supported
			 * (must be just before default case).
			 */
			if ((wreq.wi_type == WI_RID_SYMBOL_DIVERSITY &&
			    !(sc->wi_flags & WI_FLAGS_HAS_DIVERSITY)) ||
			    (wreq.wi_type == WI_RID_ROAMING_MODE &&
			    !(sc->wi_flags & WI_FLAGS_HAS_ROAMING)) ||
			    (wreq.wi_type == WI_RID_CREATE_IBSS &&
			    !(sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)) ||
			    (wreq.wi_type == WI_RID_MICROWAVE_OVEN &&
			    !(sc->wi_flags & WI_FLAGS_HAS_MOR)))
				break;
			/* FALLTHROUGH */
		default:
d1184 1
a1184 49
				error = wi_setdef(sc, &wreq);
			if (!error && (ifp->if_flags & IFF_UP))
				wi_init(sc);
		}
		break;
	case SIOCGPRISM2DEBUG:
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
		if (error)
			break;
		if (!(ifp->if_flags & IFF_RUNNING) ||
		    sc->sc_firmware_type == WI_LUCENT) {
			error = EIO;
			break;
		}
		error = wi_get_debug(sc, &wreq);
		error = copyout(&wreq, ifr->ifr_data, sizeof(wreq));
		break;
	case SIOCSPRISM2DEBUG:
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
		if (error)
			break;
		error = wi_set_debug(sc, &wreq);
		break;
	case SIOCG80211NWID:
		if (ifp->if_flags & IFF_UP) {
			/* Return the desired ID */
			error = copyout(&sc->wi_net_name, ifr->ifr_data,
			    sizeof(sc->wi_net_name));
		} else {
			wreq.wi_type = htole16(WI_RID_CURRENT_SSID);
			wreq.wi_len = htole16(WI_MAX_DATALEN);
			if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) ||
			    letoh16(wreq.wi_val[0]) > IEEE80211_NWID_LEN)
				error = EINVAL;
			else {
				wi_set_ssid(&nwid, (u_int8_t *)&wreq.wi_val[1],
				    letoh16(wreq.wi_val[0]));
				error = copyout(&nwid, ifr->ifr_data,
				    sizeof(nwid));
			}
		}
		break;
	case SIOCS80211NWID:
		error = copyin(ifr->ifr_data, &nwid, sizeof(nwid));
		if (error)
			break;
		if (nwid.i_len > IEEE80211_NWID_LEN) {
			error = EINVAL;
			break;
a1185 29
		if (sc->wi_net_name.i_len == nwid.i_len &&
		    memcmp(sc->wi_net_name.i_nwid, nwid.i_nwid, nwid.i_len) == 0)
			break;
		wi_set_ssid(&sc->wi_net_name, nwid.i_nwid, nwid.i_len);
		WI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);
		if (ifp->if_flags & IFF_UP)
			/* Reinitialize WaveLAN. */
			wi_init(sc);
		break;
	case SIOCS80211NWKEY:
		error = wi_set_nwkey(sc, (struct ieee80211_nwkey *)data);
		break;
	case SIOCG80211NWKEY:
		error = wi_get_nwkey(sc, (struct ieee80211_nwkey *)data);
		break;
	case SIOCS80211POWER:
		error = wi_set_pm(sc, (struct ieee80211_power *)data);
		break;
	case SIOCG80211POWER:
		error = wi_get_pm(sc, (struct ieee80211_power *)data);
		break;
	case SIOCHOSTAP_ADD:
	case SIOCHOSTAP_DEL:
	case SIOCHOSTAP_GET:
	case SIOCHOSTAP_GETALL:
	case SIOCHOSTAP_GFLAGS:
	case SIOCHOSTAP_SFLAGS:
		/* Send all Host AP specific ioctl's to Host AP code. */
		error = wihap_ioctl(sc, command, data);
d1197 2
a1198 2
wi_init(sc)
	struct wi_softc		*sc;
d1200 2
a1201 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d1206 1
a1206 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
d1221 3
a1226 3
	/* Enable/disable IBSS creation. */
	WI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);

d1242 5
a1246 7
	/* Set Roaming Mode unless this is a Symbol card. */
	if (sc->wi_flags & WI_FLAGS_HAS_ROAMING)
		WI_SETVAL(WI_RID_ROAMING_MODE, sc->wi_roaming);

	/* Set Antenna Diversity if this is a Symbol card. */
	if (sc->wi_flags & WI_FLAGS_HAS_DIVERSITY)
		WI_SETVAL(WI_RID_SYMBOL_DIVERSITY, sc->wi_diversity);
a1250 7
	/* Specify the IBSS name */
	if (sc->wi_net_name.i_len != 0 && (sc->wi_ptype == WI_PORTTYPE_AP ||
	    (sc->wi_create_ibss && sc->wi_ptype == WI_PORTTYPE_IBSS)))
		WI_SETSTR(WI_RID_OWN_SSID, sc->wi_net_name);
	else
		WI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);

d1260 1
a1260 1
	bcopy((char *)&sc->sc_arpcom.ac_enaddr,
d1264 2
a1265 9
	/*
	 * Initialize promisc mode.
	 *	Being in the Host-AP mode causes
	 *	great deal of pain if promisc mode is set.
	 *	Therefore we avoid confusing the firmware
	 *	and always reset promisc mode in Host-AP regime,
	 *	it shows us all the packets anyway.
	 */
	if (sc->wi_ptype != WI_PORTTYPE_AP && ifp->if_flags & IFF_PROMISC)
d1267 1
a1267 1
	else
d1269 1
d1272 1
a1272 1
	if (sc->wi_flags & WI_FLAGS_HAS_WEP) {
d1278 1
a1278 1
		if (sc->sc_firmware_type != WI_LUCENT && sc->wi_use_wep) {
d1280 1
a1280 2
			 * HWB3163 EVAL-CARD Firmware version less than 0.8.2.
			 *
d1286 2
a1287 3
			 if (sc->sc_firmware_type == WI_INTERSIL &&
			    sc->sc_sta_firmware_ver < 802 ) {
				/* firm ver < 0.8.2 */
d1290 1
a1290 1
			 WI_SETVAL(WI_RID_CNFAUTHMODE, sc->wi_authtype);
d1298 1
a1298 1
	wi_cmd(sc, WI_CMD_ENABLE | sc->wi_portnum, 0, 0, 0);
d1300 1
a1300 1
	if (wi_alloc_nicmem(sc, ETHER_MAX_LEN + sizeof(struct wi_frame) + 8, &id))
d1305 1
a1305 1
	if (wi_alloc_nicmem(sc, ETHER_MAX_LEN + sizeof(struct wi_frame) + 8, &id))
a1312 2
        wihap_init(sc);

a1322 135
static const u_int32_t crc32_tab[] = {
	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
	0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
	0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
	0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
	0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
	0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
	0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
	0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
	0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
	0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
	0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
	0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
	0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
	0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
	0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
	0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
	0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
	0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
	0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
	0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
	0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
	0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
	0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
	0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
	0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
	0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
	0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
	0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
	0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
	0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
	0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
	0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
	0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
	0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
	0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
	0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
	0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
	0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
	0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
	0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
	0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
	0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
	0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
	0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
	0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
	0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
	0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
	0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
	0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
	0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
	0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
	0x2d02ef8dL
};

#define RC4STATE 256
#define RC4KEYLEN 16
#define RC4SWAP(x,y) \
    do { u_int8_t t = state[x]; state[x] = state[y]; state[y] = t; } while(0)

static void
wi_do_hostencrypt(struct wi_softc *sc, caddr_t buf, int len)
{
	u_int32_t i, crc, klen;
	u_int8_t state[RC4STATE], key[RC4KEYLEN];
	u_int8_t x, y, *dat;

	if (!sc->wi_icv_flag) {
		sc->wi_icv = arc4random();
		sc->wi_icv_flag++;
        } else
		sc->wi_icv++;
	/*
	 * Skip 'bad' IVs from Fluhrer/Mantin/Shamir:
	 * (B, 255, N) with 3 <= B < 8
	 */
	if (sc->wi_icv >= 0x03ff00 &&
            (sc->wi_icv & 0xf8ff00) == 0x00ff00)
                sc->wi_icv += 0x000100;

	/* prepend 24bit IV to tx key, byte order does not matter */
	key[0] = sc->wi_icv >> 16;
	key[1] = sc->wi_icv >> 8;
	key[2] = sc->wi_icv;

	klen = sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keylen +
	    IEEE80211_WEP_IVLEN;
	klen = (klen >= RC4KEYLEN) ? RC4KEYLEN : RC4KEYLEN/2;
	bcopy((char *)&sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keydat,
	    (char *)key + IEEE80211_WEP_IVLEN, klen - IEEE80211_WEP_IVLEN);

	/* rc4 keysetup */
	x = y = 0;
	for (i = 0; i < RC4STATE; i++)
		state[i] = i;
	for (i = 0; i < RC4STATE; i++) {
		y = (key[x] + state[i] + y) % RC4STATE;
		RC4SWAP(i, y);
		x = (x + 1) % klen;
	}

	/* output: IV, tx keyid, rc4(data), rc4(crc32(data)) */
	dat = buf;
	dat[0] = key[0];
	dat[1] = key[1];
	dat[2] = key[2];
	dat[3] = sc->wi_tx_key << 6;		/* pad and keyid */
	dat += 4;

	/* compute rc4 over data, crc32 over data */
	crc = ~0;
	x = y = 0;
	for (i = 0; i < len; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		crc = crc32_tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
	}
	crc = ~crc;
	dat += len;

	/* append little-endian crc32 and encrypt */
	dat[0] = crc;
	dat[1] = crc >> 8;
	dat[2] = crc >> 16;
	dat[3] = crc >> 24;
	for (i = 0; i < IEEE80211_WEP_CRCLEN; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
	}
}

d1337 1
a1337 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
a1342 1
nextpkt:
a1347 1
	tx_frame.wi_frame_ctl = htole16(WI_FTYPE_DATA);
a1350 12
	if (sc->wi_ptype == WI_PORTTYPE_AP) {
		if (!wihap_check_tx(&sc->wi_hostap_info, eh->ether_dhost,
		    &tx_frame.wi_tx_rate) && !(ifp->if_flags & IFF_PROMISC)) {
			if (ifp->if_flags & IFF_DEBUG)
				printf(WI_PRT_FMT
				    ": wi_start: dropping unassoc dst %s\n",
				    WI_PRT_ARG(sc),
				    ether_sprintf(eh->ether_dhost));
			goto nextpkt;
		}
	}

d1355 4
a1358 4
	if (eh->ether_type == htons(ETHERTYPE_IP) ||
	    eh->ether_type == htons(ETHERTYPE_ARP) ||
	    eh->ether_type == htons(ETHERTYPE_REVARP) ||
	    eh->ether_type == htons(ETHERTYPE_IPV6)) {
d1361 2
a1362 12
		if (sc->wi_ptype == WI_PORTTYPE_AP) {
			tx_frame.wi_tx_ctl = htole16(WI_ENC_TX_MGMT); /* XXX */
			tx_frame.wi_frame_ctl |= htole16(WI_FCTL_FROMDS);
			if (sc->wi_use_wep)
				tx_frame.wi_frame_ctl |= htole16(WI_FCTL_WEP);
			bcopy((char *)&sc->sc_arpcom.ac_enaddr,
			    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
			bcopy((char *)&eh->ether_shost,
			    (char *)&tx_frame.wi_addr3, ETHER_ADDR_LEN);
		} else
			bcopy((char *)&eh->ether_shost,
			    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
d1368 2
a1369 1
		tx_frame.wi_dat_len = m0->m_pkthdr.len - WI_SNAPHDR_LEN;
d1375 8
a1382 35
		if (sc->wi_ptype == WI_PORTTYPE_AP && sc->wi_use_wep) {

			/* Do host encryption. */
			bcopy(&tx_frame.wi_dat[0], &sc->wi_txbuf[4], 8);

			m_copydata(m0, sizeof(struct ether_header),
			    m0->m_pkthdr.len - sizeof(struct ether_header),
			    (caddr_t)&sc->wi_txbuf[12]);

			wi_do_hostencrypt(sc, &sc->wi_txbuf[0],
			    tx_frame.wi_dat_len);

			tx_frame.wi_dat_len += IEEE80211_WEP_IVLEN +
			    IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN;

			tx_frame.wi_dat_len = htole16(tx_frame.wi_dat_len);
			wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
			    sizeof(struct wi_frame));
			wi_write_data(sc, id, WI_802_11_OFFSET_RAW,
			    (caddr_t)&sc->wi_txbuf,
			    (m0->m_pkthdr.len -
			     sizeof(struct ether_header)) + 18);
		} else {
			m_copydata(m0, sizeof(struct ether_header),
			    m0->m_pkthdr.len - sizeof(struct ether_header),
			    (caddr_t)&sc->wi_txbuf);

			tx_frame.wi_dat_len = htole16(tx_frame.wi_dat_len);
			wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
			    sizeof(struct wi_frame));
			wi_write_data(sc, id, WI_802_11_OFFSET,
			    (caddr_t)&sc->wi_txbuf,
			    (m0->m_pkthdr.len -
			     sizeof(struct ether_header)) + 2);
		}
d1386 1
a1386 9
		if (sc->wi_ptype == WI_PORTTYPE_AP && sc->wi_use_wep) {

			/* Do host encryption. (XXX - not implemented) */
			printf(WI_PRT_FMT
			    ": host encrypt not implemented for 802.3\n",
			    WI_PRT_ARG(sc));
		} else {
			m_copydata(m0, 0, m0->m_pkthdr.len,
			    (caddr_t)&sc->wi_txbuf);
d1388 4
a1391 5
			wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
			    sizeof(struct wi_frame));
			wi_write_data(sc, id, WI_802_3_OFFSET,
			    (caddr_t)&sc->wi_txbuf, m0->m_pkthdr.len + 2);
		}
d1405 2
a1406 2
	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id, 0, 0))
		printf(WI_PRT_FMT ": wi_start: xmit failed\n", WI_PRT_ARG(sc));
d1429 1
a1429 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
d1441 2
a1442 3
	tx_frame.wi_tx_ctl = htole16(WI_ENC_TX_MGMT);
	tx_frame.wi_dat_len = len - sizeof(struct wi_80211_hdr);
	tx_frame.wi_len = htole16(tx_frame.wi_dat_len);
a1443 1
	tx_frame.wi_dat_len = htole16(tx_frame.wi_dat_len);
d1448 2
a1449 3
	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id, 0, 0)) {
		printf(WI_PRT_FMT ": wi_mgmt_xmit: xmit failed\n",
		    WI_PRT_ARG(sc));
d1462 1
a1462 3
	wihap_shutdown(sc);

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
d1467 1
a1467 1
	timeout_del(&sc->sc_timo);
d1469 2
a1470 1
	ifp = &sc->sc_arpcom.ac_if;
d1472 1
a1472 2
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	wi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0, 0, 0);
d1510 1
a1510 1
wi_get_id(sc)
d1512 1
d1514 2
a1515 2
	struct wi_ltv_ver	ver;
	u_int16_t		pri_fw_ver[3];
d1518 20
d1546 1
a1546 1
			sc->sc_firmware_type = WI_INTERSIL;
d1550 1
a1550 1
			sc->sc_firmware_type = WI_INTERSIL;
d1554 1
a1554 1
			sc->sc_firmware_type = WI_INTERSIL;
d1558 1
a1558 1
			sc->sc_firmware_type = WI_INTERSIL;
d1562 1
a1562 1
			sc->sc_firmware_type = WI_INTERSIL;
d1566 1
a1566 1
			sc->sc_firmware_type = WI_INTERSIL;
d1570 1
a1570 1
			sc->sc_firmware_type = WI_INTERSIL;
d1574 1
a1574 1
			sc->sc_firmware_type = WI_INTERSIL;
d1578 1
a1578 5
			sc->sc_firmware_type = WI_INTERSIL;
			break;
		case WI_NIC_37300P:
			p = "PRISM 2.5 ISL37300P";
			sc->sc_firmware_type = WI_INTERSIL;
d1581 2
a1582 6
			if (ver.wi_ver[0] & htole16(0x8000)) {
				p = "Unknown PRISM2 chip";
				sc->sc_firmware_type = WI_INTERSIL;
			} else {
				sc->sc_firmware_type = WI_LUCENT;
			}
d1586 1
a1586 12
	/* get primary firmware version (XXX - how to do Lucent?) */
	if (sc->sc_firmware_type != WI_LUCENT) {
		bzero(&ver, sizeof(ver));
		ver.wi_type = WI_RID_PRI_IDENTITY;
		ver.wi_len = 5;
		wi_read_record(sc, (struct wi_ltv_gen *)&ver);
		pri_fw_ver[0] = letoh16(ver.wi_ver[2]);
		pri_fw_ver[1] = letoh16(ver.wi_ver[3]);
		pri_fw_ver[2] = letoh16(ver.wi_ver[1]);
	}

	/* get station firmware version */
d1594 8
a1601 24
	sc->sc_sta_firmware_ver = ver.wi_ver[2] * 10000 +
	    ver.wi_ver[3] * 100 + ver.wi_ver[1];

	if (sc->sc_firmware_type == WI_INTERSIL &&
	    (sc->sc_sta_firmware_ver == 10102 || sc->sc_sta_firmware_ver == 20102)) {
		struct wi_ltv_str sver;
		char *p;

		bzero(&sver, sizeof(sver));
		sver.wi_type = WI_RID_SYMBOL_IDENTITY;
		sver.wi_len = 7;
		/* value should be something like "V2.00-11" */
		if (wi_read_record(sc, (struct wi_ltv_gen *)&sver) == 0 &&
		    *(p = (char *)sver.wi_str) >= 'A' &&
		    p[2] == '.' && p[5] == '-' && p[8] == '\0') {
			sc->sc_firmware_type = WI_SYMBOL;
			sc->sc_sta_firmware_ver = (p[1] - '0') * 10000 +
			    (p[3] - '0') * 1000 + (p[4] - '0') * 100 +
			    (p[6] - '0') * 10 + (p[7] - '0');
		}
	}

	if (sc->sc_firmware_type == WI_LUCENT) {
		printf("\n%s: Firmware %d.%d variant %d, ", WI_PRT_ARG(sc),
a1602 8
	} else {
		printf("\n%s: %s%s, Firmware %d.%d.%d (primary), %d.%d.%d (station), ",
		    WI_PRT_ARG(sc),
		    sc->sc_firmware_type == WI_SYMBOL ? "Symbol " : "", p,
		    pri_fw_ver[0], pri_fw_ver[1], pri_fw_ver[2],
		    sc->sc_sta_firmware_ver / 10000,
		    (sc->sc_sta_firmware_ver % 10000) / 100,
		    sc->sc_sta_firmware_ver % 100);
a1605 423
}

STATIC int
wi_sync_media(sc, ptype, txrate)
	struct wi_softc *sc;
	int ptype;
	int txrate;
{
	int media = sc->sc_media.ifm_cur->ifm_media;
	int options = IFM_OPTIONS(media);
	int subtype;

	switch (txrate) {
	case 1:
		subtype = IFM_IEEE80211_DS1;
		break;
	case 2:
		subtype = IFM_IEEE80211_DS2;
		break;
	case 3:
		subtype = IFM_AUTO;
		break;
	case 5:
		subtype = IFM_IEEE80211_DS5;
		break;
	case 11:
		subtype = IFM_IEEE80211_DS11;
		break;
	default:
		subtype = IFM_MANUAL;		/* Unable to represent */
		break;
	}

	options &= ~IFM_OMASK;
	switch (ptype) {
	case WI_PORTTYPE_BSS:
		/* default port type */
		break;
	case WI_PORTTYPE_ADHOC:
		options |= IFM_IEEE80211_ADHOC;
		break;
	case WI_PORTTYPE_AP:
		options |= IFM_IEEE80211_HOSTAP;
		break;
	case WI_PORTTYPE_IBSS:
		if (sc->wi_create_ibss)
			options |= IFM_IEEE80211_IBSSMASTER;
		else
			options |= IFM_IEEE80211_IBSS;
		break;
	default:
		subtype = IFM_MANUAL;		/* Unable to represent */
		break;
	}
	media = IFM_MAKEWORD(IFM_TYPE(media), subtype, options,
	IFM_INST(media));
	if (ifmedia_match(&sc->sc_media, media, sc->sc_media.ifm_mask) == NULL)
		return (EINVAL);
	ifmedia_set(&sc->sc_media, media);
	sc->wi_ptype = ptype;
	sc->wi_tx_rate = txrate;
	return (0);
}

STATIC int
wi_media_change(ifp)
	struct ifnet *ifp;
{
	struct wi_softc *sc = ifp->if_softc;
	int otype = sc->wi_ptype;
	int orate = sc->wi_tx_rate;
	int ocreate_ibss = sc->wi_create_ibss;

	if ((sc->sc_media.ifm_cur->ifm_media & IFM_IEEE80211_HOSTAP) &&
	    sc->sc_firmware_type != WI_INTERSIL)
		return (EINVAL);

	sc->wi_create_ibss = 0;

	switch (sc->sc_media.ifm_cur->ifm_media & IFM_OMASK) {
	case 0:
		sc->wi_ptype = WI_PORTTYPE_BSS;
		break;
	case IFM_IEEE80211_ADHOC:
		sc->wi_ptype = WI_PORTTYPE_ADHOC;
		break;
	case IFM_IEEE80211_HOSTAP:
		sc->wi_ptype = WI_PORTTYPE_AP;
		break;
	case IFM_IEEE80211_IBSSMASTER:
	case IFM_IEEE80211_IBSSMASTER|IFM_IEEE80211_IBSS:
		if (!(sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS))
			return (EINVAL);
		sc->wi_create_ibss = 1;
		/* FALLTHROUGH */
	case IFM_IEEE80211_IBSS:
		sc->wi_ptype = WI_PORTTYPE_IBSS;
		break;
	default:
		/* Invalid combination. */
		return (EINVAL);
	}

	switch (IFM_SUBTYPE(sc->sc_media.ifm_cur->ifm_media)) {
	case IFM_IEEE80211_DS1:
		sc->wi_tx_rate = 1;
		break;
	case IFM_IEEE80211_DS2:
		sc->wi_tx_rate = 2;
		break;
	case IFM_AUTO:
		sc->wi_tx_rate = 3;
		break;
	case IFM_IEEE80211_DS5:
		sc->wi_tx_rate = 5;
		break;
	case IFM_IEEE80211_DS11:
		sc->wi_tx_rate = 11;
		break;
	}

	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
		if (otype != sc->wi_ptype || orate != sc->wi_tx_rate ||
		    ocreate_ibss != sc->wi_create_ibss)
			wi_init(sc);
	}

	ifp->if_baudrate = ifmedia_baudrate(sc->sc_media.ifm_cur->ifm_media);

	return (0);
}

STATIC void
wi_media_status(ifp, imr)
	struct ifnet *ifp;
	struct ifmediareq *imr;
{
	struct wi_softc *sc = ifp->if_softc;

	if (!(sc->sc_arpcom.ac_if.if_flags & IFF_UP)) {
		imr->ifm_active = IFM_IEEE80211|IFM_NONE;
		imr->ifm_status = 0;
		return;
	}

	imr->ifm_active = sc->sc_media.ifm_cur->ifm_media;
	imr->ifm_status = IFM_AVALID|IFM_ACTIVE;
}

STATIC int
wi_set_nwkey(sc, nwkey)
	struct wi_softc *sc;
	struct ieee80211_nwkey *nwkey;
{
	int i, len, error;
	struct wi_req wreq;
	struct wi_ltv_keys *wk = (struct wi_ltv_keys *)&wreq;

	if (!(sc->wi_flags & WI_FLAGS_HAS_WEP))
		return ENODEV;
	if (nwkey->i_defkid <= 0 || nwkey->i_defkid > IEEE80211_WEP_NKID)
		return EINVAL;
	memcpy(wk, &sc->wi_keys, sizeof(*wk));
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (nwkey->i_key[i].i_keydat == NULL)
			continue;
		len = nwkey->i_key[i].i_keylen;
		if (len > sizeof(wk->wi_keys[i].wi_keydat))
			return EINVAL;
		error = copyin(nwkey->i_key[i].i_keydat,
		    wk->wi_keys[i].wi_keydat, len);
		if (error)
			return error;
		wk->wi_keys[i].wi_keylen = htole16(len);
	}

	wk->wi_len = (sizeof(*wk) / 2) + 1;
	wk->wi_type = WI_RID_DEFLT_CRYPT_KEYS;
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
		error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
		if (error)
			return error;
	}
	if ((error = wi_setdef(sc, &wreq)))
		return (error);

	wreq.wi_len = 2;
	wreq.wi_type = WI_RID_TX_CRYPT_KEY;
	wreq.wi_val[0] = htole16(nwkey->i_defkid - 1);
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
		error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
		if (error)
			return error;
	}
	if ((error = wi_setdef(sc, &wreq)))
		return (error);

	wreq.wi_type = WI_RID_ENCRYPTION;
	wreq.wi_val[0] = htole16(nwkey->i_wepon);
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
		error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
		if (error)
			return error;
	}
	if ((error = wi_setdef(sc, &wreq)))
		return (error);

	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP)
		wi_init(sc);
	return 0;
}

STATIC int
wi_get_nwkey(sc, nwkey)
	struct wi_softc *sc;
	struct ieee80211_nwkey *nwkey;
{
	int i, len, error;
	struct wi_ltv_keys *wk = &sc->wi_keys;

	if (!(sc->wi_flags & WI_FLAGS_HAS_WEP))
		return ENODEV;
	nwkey->i_wepon = sc->wi_use_wep;
	nwkey->i_defkid = sc->wi_tx_key + 1;

	/* do not show any keys to non-root user */
	error = suser(curproc->p_ucred, &curproc->p_acflag);
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (nwkey->i_key[i].i_keydat == NULL)
			continue;
		/* error holds results of suser() for the first time */
		if (error)
			return error;
		len = letoh16(wk->wi_keys[i].wi_keylen);
		if (nwkey->i_key[i].i_keylen < len)
			return ENOSPC;
		nwkey->i_key[i].i_keylen = len;
		error = copyout(wk->wi_keys[i].wi_keydat,
		    nwkey->i_key[i].i_keydat, len);
		if (error)
			return error;
	}
	return 0;
}

STATIC int
wi_set_pm(struct wi_softc *sc, struct ieee80211_power *power)
{

	sc->wi_pm_enabled = power->i_enabled;
	sc->wi_max_sleep = power->i_maxsleep;

	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP)
		wi_init(sc);

	return (0);
}

STATIC int
wi_get_pm(struct wi_softc *sc, struct ieee80211_power *power)
{

	power->i_enabled = sc->wi_pm_enabled;
	power->i_maxsleep = sc->wi_max_sleep;

	return (0);
}

STATIC int
wi_set_ssid(ws, id, len)
	struct ieee80211_nwid *ws;
	u_int8_t *id;
	int len;
{

	if (len > IEEE80211_NWID_LEN)
		return (EINVAL);
	ws->i_len = len;
	memcpy(ws->i_nwid, id, len);
	return (0);
}

STATIC int
wi_get_debug(sc, wreq)
	struct wi_softc		*sc;
	struct wi_req		*wreq;
{
	int			error = 0;

	wreq->wi_len = 1;

	switch (wreq->wi_type) {
	case WI_DEBUG_SLEEP:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_sleep);
		break;
	case WI_DEBUG_DELAYSUPP:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_delaysupp);
		break;
	case WI_DEBUG_TXSUPP:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_txsupp);
		break;
	case WI_DEBUG_MONITOR:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_monitor);
		break;
	case WI_DEBUG_LEDTEST:
		wreq->wi_len += 3;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_ledtest);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_ledtest_param0);
		wreq->wi_val[2] = htole16(sc->wi_debug.wi_ledtest_param1);
		break;
	case WI_DEBUG_CONTTX:
		wreq->wi_len += 2;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_conttx);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_conttx_param0);
		break;
	case WI_DEBUG_CONTRX:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_contrx);
		break;
	case WI_DEBUG_SIGSTATE:
		wreq->wi_len += 2;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_sigstate);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_sigstate_param0);
		break;
	case WI_DEBUG_CONFBITS:
		wreq->wi_len += 2;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_confbits);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_confbits_param0);
		break;
	default:
		error = EIO;
		break;
	}

	return (error);
}

STATIC int
wi_set_debug(sc, wreq)
	struct wi_softc		*sc;
	struct wi_req		*wreq;
{
	int				error = 0;
	u_int16_t			cmd, param0 = 0, param1 = 0;

	switch (wreq->wi_type) {
	case WI_DEBUG_RESET:
	case WI_DEBUG_INIT:
	case WI_DEBUG_CALENABLE:
		break;
	case WI_DEBUG_SLEEP:
		sc->wi_debug.wi_sleep = 1;
		break;
	case WI_DEBUG_WAKE:
		sc->wi_debug.wi_sleep = 0;
		break;
	case WI_DEBUG_CHAN:
		param0 = letoh16(wreq->wi_val[0]);
		break;
	case WI_DEBUG_DELAYSUPP:
		sc->wi_debug.wi_delaysupp = 1;
		break;
	case WI_DEBUG_TXSUPP:
		sc->wi_debug.wi_txsupp = 1;
		break;
	case WI_DEBUG_MONITOR:
		sc->wi_debug.wi_monitor = 1;
		break;
	case WI_DEBUG_LEDTEST:
		param0 = letoh16(wreq->wi_val[0]);
		param1 = letoh16(wreq->wi_val[1]);
		sc->wi_debug.wi_ledtest = 1;
		sc->wi_debug.wi_ledtest_param0 = param0;
		sc->wi_debug.wi_ledtest_param1 = param1;
		break;
	case WI_DEBUG_CONTTX:
		param0 = letoh16(wreq->wi_val[0]);
		sc->wi_debug.wi_conttx = 1;
		sc->wi_debug.wi_conttx_param0 = param0;
		break;
	case WI_DEBUG_STOPTEST:
		sc->wi_debug.wi_delaysupp = 0;
		sc->wi_debug.wi_txsupp = 0;
		sc->wi_debug.wi_monitor = 0;
		sc->wi_debug.wi_ledtest = 0;
		sc->wi_debug.wi_ledtest_param0 = 0;
		sc->wi_debug.wi_ledtest_param1 = 0;
		sc->wi_debug.wi_conttx = 0;
		sc->wi_debug.wi_conttx_param0 = 0;
		sc->wi_debug.wi_contrx = 0;
		sc->wi_debug.wi_sigstate = 0;
		sc->wi_debug.wi_sigstate_param0 = 0;
		break;
	case WI_DEBUG_CONTRX:
		sc->wi_debug.wi_contrx = 1;
		break;
	case WI_DEBUG_SIGSTATE:
		param0 = letoh16(wreq->wi_val[0]);
		sc->wi_debug.wi_sigstate = 1;
		sc->wi_debug.wi_sigstate_param0 = param0;
		break;
	case WI_DEBUG_CONFBITS:
		param0 = letoh16(wreq->wi_val[0]);
		param1 = letoh16(wreq->wi_val[1]);
		sc->wi_debug.wi_confbits = param0;
		sc->wi_debug.wi_confbits_param0 = param1;
		break;
	default:
		error = EIO;
		break;
	}

	if (error)
		return (error);

	cmd = WI_CMD_DEBUG | (wreq->wi_type << 8);
	error = wi_cmd(sc, cmd, param0, param1, 0);

	return (error);
@


1.17.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.17.2.2 2002/06/11 03:42:18 art Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.17.2.2 2002/06/11 03:42:18 art Exp $";
d135 1
d171 4
a174 2
STATIC void wi_do_hostencrypt(struct wi_softc *, caddr_t, int);                
STATIC int wi_do_hostdecrypt(struct wi_softc *, caddr_t, int);
a180 4
const struct wi_card_ident wi_card_ident[] = {
	WI_CARD_IDS
};

d190 2
a237 1
	sc->wi_crypto_algorithm = WI_CRYPTO_FIRMWARE_WEP;
a268 1
			sc->wi_flags |= WI_FLAGS_HAS_HOSTAP;
d314 1
a314 1
	if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
d327 1
a327 1
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
d341 1
a341 1
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
d355 1
a355 1
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
d369 1
a369 1
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
a384 2
	sc->wi_flags |= WI_FLAGS_ATTACHED;

a469 1
	caddr_t			olddata;
a470 1
	int			maxlen;
a592 1
		olddata = m->m_data;
a597 1
		maxlen = MCLBYTES - (m->m_data - olddata);
d601 1
a601 1
		    sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
d605 1
a605 1
			if ((WI_802_11_OFFSET_RAW + rxlen + 2) > maxlen) {
d643 1
a643 1
			    maxlen) {
d673 1
a673 1
			    sizeof(struct ether_header)) > maxlen) {
d698 1
a698 41
		if (sc->wi_use_wep &&
		    rx_frame.wi_frame_ctl & WI_FCTL_WEP) {
			int len;
			u_int8_t rx_buf[1596];

			switch (sc->wi_crypto_algorithm) {
			case WI_CRYPTO_FIRMWARE_WEP:
				break;
			case WI_CRYPTO_SOFTWARE_WEP:
				m_copydata(m, 0, m->m_pkthdr.len,
				    (caddr_t)rx_buf);
				len = m->m_pkthdr.len -
				    sizeof(struct ether_header);
				if (wi_do_hostdecrypt(sc, rx_buf +
				    sizeof(struct ether_header), len)) {
					if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
						printf(WI_PRT_FMT ": Error decrypting incoming packet.\n", WI_PRT_ARG(sc));
					return;
				}
				len -= IEEE80211_WEP_IVLEN +
				    IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN;
				/*
				 * copy data back to mbufs:
				 * we need to ditch the IV & most LLC/SNAP stuff
				 * (except SNAP type, we're going use that to
				 * overwrite the ethertype in the ether_header)
				 */
				m_copyback(m, sizeof(struct ether_header) -
				    WI_ETHERTYPE_LEN, WI_ETHERTYPE_LEN +
				    (len - WI_SNAPHDR_LEN),
				    rx_buf + sizeof(struct ether_header) +
				    IEEE80211_WEP_IVLEN +
				    IEEE80211_WEP_KIDLEN + WI_SNAPHDR_LEN);
				m_adj(m, -(WI_ETHERTYPE_LEN +
				    IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
				    WI_SNAPHDR_LEN));
				break;
			}
		}

		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
d791 1
a791 1
		wi_read_data(sc, id, 4, (caddr_t)sc->wi_scanbuf,
d907 1
a907 1
		cor_value = bus_space_read_1(sc->wi_ltag, sc->wi_lhandle,
a940 2
			if (ltv->wi_val > WI_NLTV_KEYS)
				return (EINVAL);
d1029 1
a1029 1
	u_int16_t		val = 0;
d1076 3
a1078 14

				switch (sc->wi_crypto_algorithm) {
				case WI_CRYPTO_FIRMWARE_WEP:
					/*
					 * TX encryption is broken in
					 * Host AP mode.
					 */
					if (sc->wi_ptype == WI_PORTTYPE_HOSTAP)
						val |= HOST_ENCRYPT;
					break;
				case WI_CRYPTO_SOFTWARE_WEP:
					val |= HOST_ENCRYPT|HOST_DECRYPT;
					break;
				}
a1084 2
			if (ltv->wi_val > WI_NLTV_KEYS)
				return (EINVAL);
d1317 2
d1320 1
d1327 3
a1329 2
		bcopy((char *)&wreq->wi_val, LLADDR(ifp->if_sadl),
		    ETHER_ADDR_LEN);
a1396 14
	case WI_FRID_CRYPTO_ALG:
		switch (letoh16(wreq->wi_val[0])) {
		case WI_CRYPTO_FIRMWARE_WEP:
			sc->wi_crypto_algorithm = WI_CRYPTO_FIRMWARE_WEP;
			break;
		case WI_CRYPTO_SOFTWARE_WEP:
			sc->wi_crypto_algorithm = WI_CRYPTO_SOFTWARE_WEP;
			break;
		default:
			printf(WI_PRT_FMT ": unsupported crypto algorithm %d\n",
			    WI_PRT_ARG(sc), letoh16(wreq->wi_val[0]));
			error = EINVAL;
		}
		break;
d1478 6
a1483 4
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->wi_if_flags & IFF_PROMISC)) {
				if (sc->wi_ptype != WI_PORTTYPE_HOSTAP)
d1485 3
a1487 4
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->wi_if_flags & IFF_PROMISC) {
				if (sc->wi_ptype != WI_PORTTYPE_HOSTAP)
d1489 3
a1491 2
			} else
				wi_init(sc);
a1556 5
		case WI_FRID_CRYPTO_ALG:
			wreq.wi_val[0] =
			    htole16((u_int16_t)sc->wi_crypto_algorithm);
			wreq.wi_len = 1;
			break;
a1591 7
		case WI_FRID_CRYPTO_ALG:
			if (sc->sc_firmware_type != WI_LUCENT) {
				error = wi_setdef(sc, &wreq);
				if (!error && (ifp->if_flags & IFF_UP))
					wi_init(sc);
			}
			break;
a1595 1
		case WI_RID_OWN_SSID:
d1607 1
a1607 3
			    !(sc->wi_flags & WI_FLAGS_HAS_MOR)) ||
			    (wreq.wi_type == WI_RID_OWN_SSID &&
			    wreq.wi_len != 0))
d1628 1
a1628 2
		if (error == 0)
			error = copyout(&wreq, ifr->ifr_data, sizeof(wreq));
d1637 1
a1637 1
		if ((ifp->if_flags & IFF_UP) && sc->wi_net_name.i_len > 0) {
d1642 2
a1643 2
			wreq.wi_type = WI_RID_CURRENT_SSID;
			wreq.wi_len = WI_MAX_DATALEN;
d1759 1
a1759 1
	if (sc->wi_net_name.i_len != 0 && (sc->wi_ptype == WI_PORTTYPE_HOSTAP ||
d1786 1
a1786 1
	if (sc->wi_ptype != WI_PORTTYPE_HOSTAP && ifp->if_flags & IFF_PROMISC)
d1907 1
a1907 1
STATIC void
a1927 1
	bzero(key, sizeof(key));
d1932 3
a1934 1
	klen = sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keylen;
d1936 1
a1936 2
	    (char *)key + IEEE80211_WEP_IVLEN, klen);
	klen = (klen > IEEE80211_WEP_KEYLEN) ? RC4KEYLEN : RC4KEYLEN / 2;
a1981 68
STATIC int
wi_do_hostdecrypt(struct wi_softc *sc, caddr_t buf, int len)
{
	u_int32_t i, crc, klen, kid;
	u_int8_t state[RC4STATE], key[RC4KEYLEN];
	u_int8_t x, y, *dat;

	if (len < IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
	    IEEE80211_WEP_CRCLEN)
		return -1;
	len -= (IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
	    IEEE80211_WEP_CRCLEN);

	dat = buf;

	bzero(key, sizeof(key));
	key[0] = dat[0];
	key[1] = dat[1];
	key[2] = dat[2];
	kid = (dat[3] >> 6) % 4;
	dat += 4;

	klen = sc->wi_keys.wi_keys[kid].wi_keylen;
	bcopy((char *)&sc->wi_keys.wi_keys[kid].wi_keydat,
	    (char *)key + IEEE80211_WEP_IVLEN, klen);
	klen = (klen > IEEE80211_WEP_KEYLEN) ? RC4KEYLEN : RC4KEYLEN / 2;

	/* rc4 keysetup */
	x = y = 0;
	for (i = 0; i < RC4STATE; i++)
		state[i] = i;
	for (i = 0; i < RC4STATE; i++) {
		y = (key[x] + state[i] + y) % RC4STATE;
		RC4SWAP(i, y);
		x = (x + 1) % klen;
	}

	/* compute rc4 over data, crc32 over data */
	crc = ~0;
	x = y = 0;
	for (i = 0; i < len; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
		crc = crc32_tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
	}
	crc = ~crc;
	dat += len;

	/* append little-endian crc32 and encrypt */
	for (i = 0; i < IEEE80211_WEP_CRCLEN; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
	}
	if ((dat[0] != crc) && (dat[1] != crc >> 8) &&
	    (dat[2] != crc >> 16) && (dat[3] != crc >> 24)) {
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf(WI_PRT_FMT ": wi_do_hostdecrypt: iv mismatch\n",
			    WI_PRT_ARG(sc));
		return -1;
	}

	return 0;
}

d2012 1
a2012 1
	if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
a2019 1
			m_freem(m0);
d2034 1
a2034 1
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
d2057 1
a2057 1
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP && sc->wi_use_wep) {
d2066 1
a2066 1
			wi_do_hostencrypt(sc, (caddr_t)&sc->wi_txbuf,
d2095 1
a2095 1
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP && sc->wi_use_wep) {
d2236 3
a2238 5
	struct wi_ltv_ver		ver;
	const struct wi_card_ident	*id;
	u_int16_t			pri_fw_ver[3];
	const char			*card_name;
	u_int16_t			card_id;
d2245 48
a2292 3
	card_id = letoh16(ver.wi_ver[0]);
	for (id = wi_card_ident; id->firm_type != WI_NOTYPE; id++) {
		if (card_id == id->card_id)
a2294 9
	if (id->firm_type != WI_NOTYPE) {
		sc->sc_firmware_type = id->firm_type;
		card_name = id->card_name;
	} else if (ver.wi_ver[0] & htole16(0x8000)) {
		sc->sc_firmware_type = WI_INTERSIL;
		card_name = "Unknown PRISM2 chip";
	} else {
		sc->sc_firmware_type = WI_LUCENT;
	}
d2343 2
a2344 2
		    sc->sc_firmware_type == WI_SYMBOL ? "Symbol " : "",
		    card_name, pri_fw_ver[0], pri_fw_ver[1], pri_fw_ver[2],
d2349 2
d2392 1
a2392 1
	case WI_PORTTYPE_HOSTAP:
d2438 1
a2438 1
		sc->wi_ptype = WI_PORTTYPE_HOSTAP;
a2488 1
	struct wi_req wreq;
d2496 2
a2497 45
	if (sc->wi_tx_rate == 3) {
		imr->ifm_active = IFM_IEEE80211|IFM_AUTO;

		wreq.wi_type = WI_RID_CUR_TX_RATE;
		wreq.wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) == 0) {
			switch (letoh16(wreq.wi_val[0])) {
			case 1:
				imr->ifm_active |= IFM_IEEE80211_DS1;
				break;
			case 2:
				imr->ifm_active |= IFM_IEEE80211_DS2;
				break;
			case 6:
				imr->ifm_active |= IFM_IEEE80211_DS5;
				break;
			case 11:
				imr->ifm_active |= IFM_IEEE80211_DS11;
				break;
			}
		}
	} else {
		imr->ifm_active = sc->sc_media.ifm_cur->ifm_media;
	}

	imr->ifm_status = IFM_AVALID;
	switch (sc->wi_ptype) {
	case WI_PORTTYPE_ADHOC:
	case WI_PORTTYPE_IBSS:
		/*
		 * XXX: It would be nice if we could give some actually
		 * useful status like whether we joined another IBSS or
		 * created one ourselves.
		 */
		/* FALLTHROUGH */
	case WI_PORTTYPE_HOSTAP:
		imr->ifm_status |= IFM_ACTIVE;
		break;
	default:
		wreq.wi_type = WI_RID_COMMQUAL;
		wreq.wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) == 0 &&
		    letoh16(wreq.wi_val[0]) != 0)
			imr->ifm_status |= IFM_ACTIVE;
	}
@


1.17.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d127 1
a127 1
	"$OpenBSD$";
d191 1
a268 1
#ifndef SMALL_KERNEL
a269 1
#endif
a721 2
					m_freem(m);
					ifp->if_ierrors++;  
d809 1
a809 1
	s = splimp();
a1618 5
		case WI_FRID_CRYPTO_ALG:
			wreq.wi_val[0] =
			    htole16((u_int16_t)sc->wi_crypto_algorithm);
			wreq.wi_len = 1;
			break;
d1627 5
a1631 1
			/* FALLTHROUGH */
d1830 1
a1830 1
	/* Power Management Max Sleep */
d1933 53
a1985 65
static const u_int32_t crc32tab[] = {
	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL,
	0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L,
	0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L,
	0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L,
	0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
	0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L,
	0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL,
	0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L,
	0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L,
	0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
	0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L,
	0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L,
	0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L,
	0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL,
	0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
	0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL,
	0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL,
	0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L,
	0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L,
	0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
	0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL,
	0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L,
	0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL,
	0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L,
	0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
	0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL,
	0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L,
	0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L,
	0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L,
	0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
	0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L,
	0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL,
	0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL,
	0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L,
	0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
	0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L,
	0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL,
	0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L,
	0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL,
	0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
	0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L,
	0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL,
	0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L,
	0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L,
	0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
	0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL,
	0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L,
	0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL,
	0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL,
	0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
	0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L,
	0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L,
	0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL,
	0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L,
	0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
	0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L,
	0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L,
	0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL,
	0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L,
	0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
	0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L,
	0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL,
	0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L,
	0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL
d2049 1
a2049 1
		crc = crc32tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
d2113 1
a2113 1
		crc = crc32tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
d2128 2
a2129 3
			printf(WI_PRT_FMT ": wi_do_hostdecrypt: iv mismatch: "
			    "0x%02x%02x%02x%02x vs. 0x%x\n", WI_PRT_ARG(sc),
			    dat[3], dat[2], dat[1], dat[0], crc);
a2367 1
	wi_cor_reset(sc);
@


1.16
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.15 2001/06/27 06:34:42 kjc Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.15 2001/06/27 06:34:42 kjc Exp $";
d1574 4
@


1.15
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.14 2001/06/25 19:36:13 drahn Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.14 2001/06/25 19:36:13 drahn Exp $";
a199 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
@


1.15.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.15 2001/06/27 06:34:42 kjc Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.15 2001/06/27 06:34:42 kjc Exp $";
d200 1
a1574 4
			sc->sc_prism2 = 1;
			break;
		case WI_NIC_3874A:
			p = "PRISM 2.5 ISL3874A(PCI)";
@


1.15.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a89 2
#include <net/if_ieee80211.h>

d123 1
a123 1
	"$OpenBSD$";
d150 1
a150 1
STATIC int wi_setdef		__P((struct wi_softc *, struct wi_req *));
a153 10
STATIC int wi_media_change __P((struct ifnet *));
STATIC void wi_media_status __P((struct ifnet *, struct ifmediareq *));

STATIC int wi_set_ssid __P((struct ieee80211_nwid *, u_int8_t *, int));
STATIC int wi_set_nwkey __P((struct wi_softc *, struct ieee80211_nwkey *));
STATIC int wi_get_nwkey __P((struct wi_softc *, struct ieee80211_nwkey *));
STATIC int wi_sync_media __P((struct wi_softc *, int, int));
STATIC int wi_set_pm __P((struct wi_softc *, struct ieee80211_power *));
STATIC int wi_get_pm __P((struct wi_softc *, struct ieee80211_power *));

d202 2
a203 1
	(void)wi_set_ssid(&sc->wi_node_name, WI_DEFAULT_NODENAME,
d205 3
a207 1
	(void)wi_set_ssid(&sc->wi_net_name, WI_DEFAULT_NETNAME,
d209 3
a211 1
	(void)wi_set_ssid(&sc->wi_ibss_name, WI_DEFAULT_IBSS,
a249 22
	ifmedia_init(&sc->sc_media, 0, wi_media_change, wi_media_status);
#define	ADD(m, c)	ifmedia_add(&sc->sc_media, (m), (c), NULL)
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_MANUAL, 0, 0), 0);
#undef ADD
	ifmedia_set(&sc->sc_media,
	    IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, 0, 0));

d541 1
a541 1
		DELAY(10);
d549 1
a549 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
d742 1
a742 14
					bzero(&ws, sizeof(ws));
					if (wk->wi_keys[i].wi_keylen <= 5) {
						/* 5 Octet WEP Keys */
						ws.wi_len = 4;
						bcopy(&wk->wi_keys[i].wi_keydat,
						    ws.wi_str, 5);
						ws.wi_str[5] = '\0';
					} else {
						/* 13 Octet WEP Keys */
						ws.wi_len = 8;
						bcopy(&wk->wi_keys[i].wi_keydat,
						    ws.wi_str, 13);
						ws.wi_str[13] = '\0';
					}
d744 3
d808 1
a808 1
	for (i = WI_TIMEOUT; i--; DELAY(10))
d900 1
a900 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
d965 1
a965 1
STATIC int
a973 1
	int error = 0;
d986 1
a986 2
		error = wi_sync_media(sc, letoh16(wreq->wi_val[0]),
		    sc->wi_tx_rate);
d989 1
a989 2
		error = wi_sync_media(sc, sc->wi_ptype,
		    letoh16(wreq->wi_val[0]));
d1007 2
a1008 2
		error = wi_set_ssid(&sc->wi_node_name,
		    (u_int8_t *)&wreq->wi_val[1], letoh16(wreq->wi_val[0]));
d1011 2
a1012 2
		error = wi_set_ssid(&sc->wi_net_name,
		    (u_int8_t *)&wreq->wi_val[1], letoh16(wreq->wi_val[0]));
d1015 2
a1016 2
		error = wi_set_ssid(&sc->wi_ibss_name,
		    (u_int8_t *)&wreq->wi_val[1], letoh16(wreq->wi_val[0]));
a1043 1
		error = EINVAL;
d1047 4
a1050 1
	return (error);
a1064 1
	struct ieee80211_nwid	nwid;
a1142 4
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, command);
		break;
d1184 1
a1184 3
				error = wi_setdef(sc, &wreq);
			if (!error && ifp->if_flags & IFF_UP)
				wi_init(ifp);
a1186 47
	case SIOCG80211NWID:
		if (ifp->if_flags & IFF_UP) {
			/* Return the desired ID */
			error = copyout(&sc->wi_net_name, ifr->ifr_data,
			    sizeof(sc->wi_net_name));
		} else {
			wreq.wi_type = htole16(WI_RID_CURRENT_SSID);
			wreq.wi_len = htole16(WI_MAX_DATALEN);
			if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) ||
			    letoh16(wreq.wi_val[0]) > IEEE80211_NWID_LEN)
				error = EINVAL;
			else {
				wi_set_ssid(&nwid, (u_int8_t *)&wreq.wi_val[1],
				    letoh16(wreq.wi_val[0]));
				error = copyout(&nwid, ifr->ifr_data,
				    sizeof(nwid));
			}
		}
		break;
	case SIOCS80211NWID:
		error = copyin(ifr->ifr_data, &nwid, sizeof(nwid));
		if (error != 0)
			break;
		if (nwid.i_len > IEEE80211_NWID_LEN) {
			error = EINVAL;
			break;
		}
		if (sc->wi_net_name.i_len == nwid.i_len &&
		    memcmp(sc->wi_net_name.i_nwid, nwid.i_nwid, nwid.i_len) == 0)
			break;
		wi_set_ssid(&sc->wi_net_name, nwid.i_nwid, nwid.i_len);
		if (ifp->if_flags & IFF_UP)
			/* Reinitialize WaveLAN. */
			wi_init(ifp);
		break;
	case SIOCS80211NWKEY:
		error = wi_set_nwkey(sc, (struct ieee80211_nwkey *)data);
		break;
	case SIOCG80211NWKEY:
		error = wi_get_nwkey(sc, (struct ieee80211_nwkey *)data);
		break;
	case SIOCS80211POWER:
		error = wi_set_pm(sc, (struct ieee80211_power *)data);
		break;
	case SIOCG80211POWER:
		error = wi_get_pm(sc, (struct ieee80211_power *)data);
		break;
a1605 245
}

STATIC int
wi_sync_media(sc, ptype, txrate)
	struct wi_softc *sc;
	int ptype;
	int txrate;
{
	int media = sc->sc_media.ifm_cur->ifm_media;
	int options = IFM_OPTIONS(media);
	int subtype;

	switch (txrate) {
	case 1:
		subtype = IFM_IEEE80211_DS1;
		break;
	case 2:
		subtype = IFM_IEEE80211_DS2;
		break;
	case 3:
		subtype = IFM_AUTO;
		break;
	case 5:
		subtype = IFM_IEEE80211_DS5;
		break;
	case 11:
		subtype = IFM_IEEE80211_DS11;
		break;
	default:
		subtype = IFM_MANUAL;           /* Unable to represent */
		break;
	}

	switch (ptype) {
	case WI_PORTTYPE_ADHOC:
		options |= IFM_IEEE80211_ADHOC;
		break;
	case WI_PORTTYPE_BSS:
		options &= ~IFM_IEEE80211_ADHOC;
		break;
	default:
		subtype = IFM_MANUAL;           /* Unable to represent */
		break;
	}
	media = IFM_MAKEWORD(IFM_TYPE(media), subtype, options,
	IFM_INST(media));
	if (ifmedia_match(&sc->sc_media, media, sc->sc_media.ifm_mask) == NULL)
		return (EINVAL);
	ifmedia_set(&sc->sc_media, media);
	sc->wi_ptype = ptype;
	sc->wi_tx_rate = txrate;
	return (0);
}

STATIC int
wi_media_change(ifp)
	struct ifnet *ifp;
{
	struct wi_softc *sc = ifp->if_softc;
	int otype = sc->wi_ptype;
	int orate = sc->wi_tx_rate;

	if ((sc->sc_media.ifm_cur->ifm_media & IFM_IEEE80211_ADHOC) != 0)
		sc->wi_ptype = WI_PORTTYPE_ADHOC;
	else
		sc->wi_ptype = WI_PORTTYPE_BSS;

	switch (IFM_SUBTYPE(sc->sc_media.ifm_cur->ifm_media)) {
	case IFM_IEEE80211_DS1:
		sc->wi_tx_rate = 1;
		break;
	case IFM_IEEE80211_DS2:
		sc->wi_tx_rate = 2;
		break;
	case IFM_AUTO:
		sc->wi_tx_rate = 3;
		break;
	case IFM_IEEE80211_DS5:
		sc->wi_tx_rate = 5;
		break;
	case IFM_IEEE80211_DS11:
		sc->wi_tx_rate = 11;
		break;
	}

	if (sc->arpcom.ac_if.if_flags & IFF_UP) {
		if (otype != sc->wi_ptype ||
		    orate != sc->wi_tx_rate)
			wi_init(ifp);
	}

	ifp->if_baudrate = ifmedia_baudrate(sc->sc_media.ifm_cur->ifm_media);

	return (0);
}

STATIC void
wi_media_status(ifp, imr)
	struct ifnet *ifp;
	struct ifmediareq *imr;
{
	struct wi_softc *sc = ifp->if_softc;

	if (!(sc->arpcom.ac_if.if_flags & IFF_UP)) {
		imr->ifm_active = IFM_IEEE80211|IFM_NONE;
		imr->ifm_status = 0;
		return;
	}

	imr->ifm_active = sc->sc_media.ifm_cur->ifm_media;
	imr->ifm_status = IFM_AVALID|IFM_ACTIVE;
}

STATIC int
wi_set_nwkey(sc, nwkey)
	struct wi_softc *sc;
	struct ieee80211_nwkey *nwkey;
{
	int i, len, error;
	struct wi_req wreq;
	struct wi_ltv_keys *wk = (struct wi_ltv_keys *)&wreq;

	if (!sc->wi_has_wep)
		return ENODEV;
	if (nwkey->i_defkid <= 0 ||
	    nwkey->i_defkid > IEEE80211_WEP_NKID)
		return EINVAL;
	memcpy(wk, &sc->wi_keys, sizeof(*wk));
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (nwkey->i_key[i].i_keydat == NULL)
			continue;
		len = nwkey->i_key[i].i_keylen;
		if (len > sizeof(wk->wi_keys[i].wi_keydat))
			return EINVAL;
		error = copyin(nwkey->i_key[i].i_keydat,
		    wk->wi_keys[i].wi_keydat, len);
		if (error)
			return error;
		wk->wi_keys[i].wi_keylen = htole16(len);
	}

	wk->wi_len = (sizeof(*wk) / 2) + 1;
	wk->wi_type = WI_RID_DEFLT_CRYPT_KEYS;
	if (sc->arpcom.ac_if.if_flags & IFF_UP) {
		error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
		if (error)
			return error;
	}
	if ((error = wi_setdef(sc, &wreq)))
		return (error);

	wreq.wi_len = 2;
	wreq.wi_type = WI_RID_TX_CRYPT_KEY;
	wreq.wi_val[0] = htole16(nwkey->i_defkid - 1);
	if (sc->arpcom.ac_if.if_flags & IFF_UP) {
		error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
		if (error)
			return error;
	}
	if ((error = wi_setdef(sc, &wreq)))
		return (error);

	wreq.wi_type = WI_RID_ENCRYPTION;
	wreq.wi_val[0] = htole16(nwkey->i_wepon);
	if (sc->arpcom.ac_if.if_flags & IFF_UP) {
		error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
		if (error)
			return error;
	}
	if ((error = wi_setdef(sc, &wreq)))
		return (error);

	if (sc->arpcom.ac_if.if_flags & IFF_UP)
		wi_init(&sc->arpcom.ac_if);
	return 0;
}

STATIC int
wi_get_nwkey(sc, nwkey)
	struct wi_softc *sc;
	struct ieee80211_nwkey *nwkey;
{
	int i, len, error;
	struct wi_ltv_keys *wk = &sc->wi_keys;

	if (!sc->wi_has_wep)
		return ENODEV;
	nwkey->i_wepon = sc->wi_use_wep;
	nwkey->i_defkid = sc->wi_tx_key + 1;

	/* do not show any keys to non-root user */
	error = suser(curproc->p_ucred, &curproc->p_acflag);
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (nwkey->i_key[i].i_keydat == NULL)
			continue;
		/* error holds results of suser() for the first time */
		if (error)
			return error;
		len = letoh16(wk->wi_keys[i].wi_keylen);
		if (nwkey->i_key[i].i_keylen < len)
			return ENOSPC;
		nwkey->i_key[i].i_keylen = len;
		error = copyout(wk->wi_keys[i].wi_keydat,
		    nwkey->i_key[i].i_keydat, len);
		if (error)
			return error;
	}
	return 0;
}

STATIC int
wi_set_pm(struct wi_softc *sc, struct ieee80211_power *power)
{

	sc->wi_pm_enabled = power->i_enabled;
	sc->wi_max_sleep = power->i_maxsleep;

	if (sc->arpcom.ac_if.if_flags & IFF_UP)
		wi_init(&sc->arpcom.ac_if);

	return (0);
}

STATIC int
wi_get_pm(struct wi_softc *sc, struct ieee80211_power *power)
{

	power->i_enabled = sc->wi_pm_enabled;
	power->i_maxsleep = sc->wi_max_sleep;

	return (0);
}

STATIC int
wi_set_ssid(ws, id, len)
	struct ieee80211_nwid *ws;
	u_int8_t *id;
	int len;
{

	if (len > IEEE80211_NWID_LEN)
		return (EINVAL);
	ws->i_len = len;
	memcpy(ws->i_nwid, id, len);
	return (0);
@


1.15.2.3
log
@Merge in -current from about a week ago
@
text
@d132 9
a140 9
STATIC void wi_reset(struct wi_softc *);
STATIC int wi_ioctl(struct ifnet *, u_long, caddr_t);
STATIC void wi_start(struct ifnet *);
STATIC void wi_watchdog(struct ifnet *);
STATIC void wi_shutdown(void *);
STATIC void wi_rxeof(struct wi_softc *);
STATIC void wi_txeof(struct wi_softc *, int);
STATIC void wi_update_stats(struct wi_softc *);
STATIC void wi_setmulti(struct wi_softc *);
d142 13
a154 13
STATIC int wi_cmd(struct wi_softc *, int, int);
STATIC int wi_read_record(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_write_record(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_read_data(struct wi_softc *, int,
					int, caddr_t, int);
STATIC int wi_write_data(struct wi_softc *, int,
					int, caddr_t, int);
STATIC int wi_seek(struct wi_softc *, int, int, int);
STATIC int wi_alloc_nicmem(struct wi_softc *, int, int *);
STATIC void wi_inquire(void *);
STATIC int wi_setdef(struct wi_softc *, struct wi_req *);
STATIC int wi_mgmt_xmit(struct wi_softc *, caddr_t, int);
STATIC void wi_get_id(struct wi_softc *, int);
d156 2
a157 2
STATIC int wi_media_change(struct ifnet *);
STATIC void wi_media_status(struct ifnet *, struct ifmediareq *);
d159 6
a164 6
STATIC int wi_set_ssid(struct ieee80211_nwid *, u_int8_t *, int);
STATIC int wi_set_nwkey(struct wi_softc *, struct ieee80211_nwkey *);
STATIC int wi_get_nwkey(struct wi_softc *, struct ieee80211_nwkey *);
STATIC int wi_sync_media(struct wi_softc *, int, int);
STATIC int wi_set_pm(struct wi_softc *, struct ieee80211_power *);
STATIC int wi_get_pm(struct wi_softc *, struct ieee80211_power *);
d166 4
a169 4
int	wi_intr(void *);
int	wi_attach(struct wi_softc *, int);
void	wi_init(void *);
void	wi_stop(struct wi_softc *);
@


1.15.2.4
log
@Sync the SMP branch with 3.3
@
text
@a97 2
#include <dev/rndvar.h>

d142 1
a142 1
STATIC int wi_cmd(struct wi_softc *, int, int, int, int);
d153 2
a154 1
STATIC void wi_get_id(struct wi_softc *);
d166 4
a169 5
STATIC int wi_get_debug(struct wi_softc *, struct wi_req *);
STATIC int wi_set_debug(struct wi_softc *, struct wi_req *);

STATIC void wi_do_hostencrypt(struct wi_softc *, caddr_t, int);                
STATIC int wi_do_hostdecrypt(struct wi_softc *, caddr_t, int);
a175 4
const struct wi_card_ident wi_card_ident[] = {
	WI_CARD_IDS
};

d177 1
a177 1
wi_attach(sc)
d179 1
d186 2
d198 1
a198 1
	bcopy((char *)&mac.wi_mac_addr, (char *)&sc->sc_arpcom.ac_enaddr,
d201 2
a202 2
	wi_get_id(sc);
	printf("address %s", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d204 1
a204 1
	ifp = &sc->sc_arpcom.ac_if;
a231 2
	sc->wi_diversity = WI_DEFAULT_DIVERSITY;
	sc->wi_crypto_algorithm = WI_CRYPTO_FIRMWARE_WEP;
a246 35
	 * Set flags based on firmware version.
	 */
	switch (sc->sc_firmware_type) {
	case WI_LUCENT:
		sc->wi_flags |= WI_FLAGS_HAS_ROAMING;
		if (sc->sc_sta_firmware_ver >= 60000)
			sc->wi_flags |= WI_FLAGS_HAS_MOR;
		if (sc->sc_sta_firmware_ver >= 60006) {
			sc->wi_flags |= WI_FLAGS_HAS_IBSS;
			sc->wi_flags |= WI_FLAGS_HAS_CREATE_IBSS;
		}
		sc->wi_ibss_port = htole16(1);
		break;
	case WI_INTERSIL:
		sc->wi_flags |= WI_FLAGS_HAS_ROAMING;
		if (sc->sc_sta_firmware_ver >= 800) {
#ifndef SMALL_KERNEL
			sc->wi_flags |= WI_FLAGS_HAS_HOSTAP;
#endif
			sc->wi_flags |= WI_FLAGS_HAS_IBSS;
			sc->wi_flags |= WI_FLAGS_HAS_CREATE_IBSS;
		}
		sc->wi_ibss_port = htole16(0);
		break;
	case WI_SYMBOL:
		sc->wi_flags |= WI_FLAGS_HAS_DIVERSITY;
		if (sc->sc_sta_firmware_ver >= 20000)
			sc->wi_flags |= WI_FLAGS_HAS_IBSS;
		if (sc->sc_sta_firmware_ver >= 25000)
			sc->wi_flags |= WI_FLAGS_HAS_CREATE_IBSS;
		sc->wi_ibss_port = htole16(4);
		break;
	}

	/*
d251 2
a252 2
	if (wi_read_record(sc, &gen) == 0 && gen.wi_val != htole16(0))
		sc->wi_flags |= WI_FLAGS_HAS_WEP;
a256 9
	/* Find supported rates. */
	gen.wi_type = WI_RID_DATA_RATES;
	gen.wi_len = 2;
	if (wi_read_record(sc, &gen))
		sc->wi_supprates = WI_SUPPRATES_1M | WI_SUPPRATES_2M |
		    WI_SUPPRATES_5M | WI_SUPPRATES_11M;
	else
		sc->wi_supprates = gen.wi_val;

d260 15
a274 67
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, IFM_IEEE80211_ADHOC, 0), 0);
	if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, IFM_IEEE80211_IBSS,
		    0), 0);
	if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
		    IFM_IEEE80211_IBSSMASTER, 0), 0);
	if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
		    IFM_IEEE80211_HOSTAP, 0), 0);
	if (sc->wi_supprates & WI_SUPPRATES_1M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
			    IFM_IEEE80211_HOSTAP, 0), 0);
	}
	if (sc->wi_supprates & WI_SUPPRATES_2M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
			    IFM_IEEE80211_HOSTAP, 0), 0);
	}
	if (sc->wi_supprates & WI_SUPPRATES_5M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
			    IFM_IEEE80211_HOSTAP, 0), 0);
	}
	if (sc->wi_supprates & WI_SUPPRATES_11M) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11, 0, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
		    IFM_IEEE80211_ADHOC, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
			    IFM_IEEE80211_IBSS, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
			    IFM_IEEE80211_IBSSMASTER, 0), 0);
		if (sc->wi_flags & WI_FLAGS_HAS_HOSTAP)
			ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
			    IFM_IEEE80211_HOSTAP, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_MANUAL, 0, 0), 0);
	}
a285 2
	sc->wi_flags |= WI_FLAGS_ATTACHED;

d287 1
a287 1
	BPFATTACH(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
d309 1
a309 1
	ifp = &sc->sc_arpcom.ac_if;
d311 1
a311 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED) || !(ifp->if_flags & IFF_UP)) {
d370 1
a371 3
	caddr_t			olddata;
	u_int16_t		msg_type;
	int			maxlen;
d374 1
a374 1
	ifp = &sc->sc_arpcom.ac_if;
d378 5
a382 3
	if (sc->wi_procframe || sc->wi_debug.wi_monitor) {
		struct wi_frame	*rx_frame;
		int		datlen, hdrlen;
d384 4
a387 11
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			ifp->if_ierrors++;
			return;
		}
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}
d389 11
a399 1
		m->m_pkthdr.rcvif = ifp;
d401 2
a402 8
		if (wi_read_data(sc, id, 0, mtod(m, caddr_t),
		    sizeof(struct wi_frame))) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		rx_frame = mtod(m, struct wi_frame *);
d404 8
a411 1
		if (rx_frame->wi_status & htole16(WI_STAT_BADCRC)) {
d416 2
d419 10
a428 33
		switch ((letoh16(rx_frame->wi_status) & WI_STAT_MAC_PORT)
		    >> 8) {
		case 7:
			switch (letoh16(rx_frame->wi_frame_ctl) &
			    WI_FCTL_FTYPE) {
			case WI_FTYPE_DATA:
				hdrlen = WI_DATA_HDRLEN;
				datlen = letoh16(rx_frame->wi_dat_len);
				break;
			case WI_FTYPE_MGMT:
				hdrlen = WI_MGMT_HDRLEN;
				datlen = letoh16(rx_frame->wi_dat_len);
				break;
			case WI_FTYPE_CTL:
				hdrlen = WI_CTL_HDRLEN;
				datlen = 0;
				break;
			default:
				printf(WI_PRT_FMT ": received packet of "
				    "unknown type on port 7\n", WI_PRT_ARG(sc));
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			break;
		case 0:
			hdrlen = WI_DATA_HDRLEN;
			datlen = letoh16(rx_frame->wi_dat_len);
			break;
		default:
			printf(WI_PRT_FMT ": received packet on invalid port "
			    "(wi_status=0x%x)\n", WI_PRT_ARG(sc),
			    letoh16(rx_frame->wi_status));
d433 7
a439 2

		if ((hdrlen + datlen + 2) > MCLBYTES) {
d444 2
d447 2
a448 2
		if (wi_read_data(sc, id, hdrlen, mtod(m, caddr_t) + hdrlen,
		    datlen + 2)) {
d453 1
d455 1
a455 192
		m->m_pkthdr.len = m->m_len = hdrlen + datlen;
	} else {
		struct wi_frame rx_frame;

		/* First read in the frame header */
		if (wi_read_data(sc, id, 0, (caddr_t)&rx_frame,
		    sizeof(rx_frame))) {
			ifp->if_ierrors++;
			return;
		}

		/* Drop undecryptable or packets with receive errors here */
		if (rx_frame.wi_status & htole16(WI_STAT_ERRSTAT)) {
			ifp->if_ierrors++;
			return;
		}

		/* Stash message type in host byte order for later use */
		msg_type = letoh16(rx_frame.wi_status) & WI_RXSTAT_MSG_TYPE;

		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			ifp->if_ierrors++;
			return;
		}
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}

		olddata = m->m_data;
		/* Align the data after the ethernet header */
		m->m_data = (caddr_t)ALIGN(m->m_data +
		    sizeof(struct ether_header)) - sizeof(struct ether_header);

		eh = mtod(m, struct ether_header *);
		maxlen = MCLBYTES - (m->m_data - olddata);
		m->m_pkthdr.rcvif = ifp;

		if (msg_type == WI_STAT_MGMT &&
		    sc->wi_ptype == WI_PORTTYPE_HOSTAP) {

			u_int16_t rxlen = letoh16(rx_frame.wi_dat_len);

			if ((WI_802_11_OFFSET_RAW + rxlen + 2) > maxlen) {
				printf("%s: oversized mgmt packet received in "
				    "hostap mode (wi_dat_len=%d, "
				    "wi_status=0x%x)\n", sc->sc_dev.dv_xname,
				    rxlen, letoh16(rx_frame.wi_status));
				m_freem(m);
				ifp->if_ierrors++;  
				return;
			}

			/* Put the whole header in there. */
			bcopy(&rx_frame, mtod(m, void *),
			    sizeof(struct wi_frame));
			if (wi_read_data(sc, id, WI_802_11_OFFSET_RAW,
			    mtod(m, caddr_t) + WI_802_11_OFFSET_RAW,
			    rxlen + 2)) {
				m_freem(m);
				if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
					printf("wihap: failed to copy header\n");
				ifp->if_ierrors++;
				return;
			}

			m->m_pkthdr.len = m->m_len =
			    WI_802_11_OFFSET_RAW + rxlen;

			/* XXX: consider giving packet to bhp? */

			wihap_mgmt_input(sc, &rx_frame, m);

			return;
		}

		switch (msg_type) {
		case WI_STAT_1042:
		case WI_STAT_TUNNEL:
		case WI_STAT_WMP_MSG:
			if ((letoh16(rx_frame.wi_dat_len) + WI_SNAPHDR_LEN) >
			    maxlen) {
				printf(WI_PRT_FMT ": oversized packet received "
				    "(wi_dat_len=%d, wi_status=0x%x)\n",
				    WI_PRT_ARG(sc),
				    letoh16(rx_frame.wi_dat_len),
				    letoh16(rx_frame.wi_status));
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			m->m_pkthdr.len = m->m_len =
			    letoh16(rx_frame.wi_dat_len) + WI_SNAPHDR_LEN;

			bcopy((char *)&rx_frame.wi_dst_addr,
			    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);
			bcopy((char *)&rx_frame.wi_src_addr,
			    (char *)&eh->ether_shost, ETHER_ADDR_LEN);
			bcopy((char *)&rx_frame.wi_type,
			    (char *)&eh->ether_type, ETHER_TYPE_LEN);

			if (wi_read_data(sc, id, WI_802_11_OFFSET,
			    mtod(m, caddr_t) + sizeof(struct ether_header),
			    m->m_len + 2)) {
				ifp->if_ierrors++;
				m_freem(m);
				return;
			}
			break;
		default:
			if ((letoh16(rx_frame.wi_dat_len) +
			    sizeof(struct ether_header)) > maxlen) {
				printf(WI_PRT_FMT ": oversized packet received "
				    "(wi_dat_len=%d, wi_status=0x%x)\n",
				    WI_PRT_ARG(sc),
				    letoh16(rx_frame.wi_dat_len),
				    letoh16(rx_frame.wi_status));
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			m->m_pkthdr.len = m->m_len =
			    letoh16(rx_frame.wi_dat_len) +
			    sizeof(struct ether_header);

			if (wi_read_data(sc, id, WI_802_3_OFFSET,
			    mtod(m, caddr_t), m->m_len + 2)) {
				m_freem(m);
				ifp->if_ierrors++;
				return;
			}
			break;
		}

		ifp->if_ipackets++;

		if (sc->wi_use_wep &&
		    rx_frame.wi_frame_ctl & WI_FCTL_WEP) {
			int len;
			u_int8_t rx_buf[1596];

			switch (sc->wi_crypto_algorithm) {
			case WI_CRYPTO_FIRMWARE_WEP:
				break;
			case WI_CRYPTO_SOFTWARE_WEP:
				m_copydata(m, 0, m->m_pkthdr.len,
				    (caddr_t)rx_buf);
				len = m->m_pkthdr.len -
				    sizeof(struct ether_header);
				if (wi_do_hostdecrypt(sc, rx_buf +
				    sizeof(struct ether_header), len)) {
					if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
						printf(WI_PRT_FMT ": Error decrypting incoming packet.\n", WI_PRT_ARG(sc));
					m_freem(m);
					ifp->if_ierrors++;  
					return;
				}
				len -= IEEE80211_WEP_IVLEN +
				    IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN;
				/*
				 * copy data back to mbufs:
				 * we need to ditch the IV & most LLC/SNAP stuff
				 * (except SNAP type, we're going use that to
				 * overwrite the ethertype in the ether_header)
				 */
				m_copyback(m, sizeof(struct ether_header) -
				    WI_ETHERTYPE_LEN, WI_ETHERTYPE_LEN +
				    (len - WI_SNAPHDR_LEN),
				    rx_buf + sizeof(struct ether_header) +
				    IEEE80211_WEP_IVLEN +
				    IEEE80211_WEP_KIDLEN + WI_SNAPHDR_LEN);
				m_adj(m, -(WI_ETHERTYPE_LEN +
				    IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
				    WI_SNAPHDR_LEN));
				break;
			}
		}

		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
			/*
			 * Give host AP code first crack at data packets.
			 * If it decides to handle it (or drop it), it will
			 * return a non-zero.  Otherwise, it is destined for
			 * this host.
			 */
			if (wihap_data_input(sc, &rx_frame, m))
				return;
		}
	}
d463 2
a464 5
	/* Receive packet unless in procframe or monitor mode. */
	if (sc->wi_procframe || sc->wi_debug.wi_monitor)
		m_freem(m);
	else
		ether_input_mbuf(ifp, m);
d476 1
a476 1
	ifp = &sc->sc_arpcom.ac_if;
d498 1
a498 1
	ifp = &sc->sc_arpcom.ac_if;
d506 2
a507 2
	s = splimp();
	rv = wi_cmd(sc, WI_CMD_INQUIRE, WI_INFO_COUNTERS, 0, 0);
d527 1
a527 1
	ifp = &sc->sc_arpcom.ac_if;
d533 1
a533 6
	if (gen.wi_type == htole16(WI_INFO_SCAN_RESULTS)) {
		sc->wi_scanbuf_len = letoh16(gen.wi_len);
		wi_read_data(sc, id, 4, (caddr_t)sc->wi_scanbuf,
		    sc->wi_scanbuf_len * 2);
		return;
	} else if (gen.wi_type != htole16(WI_INFO_COUNTERS))
d537 2
a538 2
	len = (letoh16(gen.wi_len) - 1 < sizeof(sc->wi_stats) / 4) ?
	    letoh16(gen.wi_len) - 1 : sizeof(sc->wi_stats) / 4;
d559 1
a559 1
wi_cmd(sc, cmd, val0, val1, val2)
d562 1
a562 3
	int			val0;
	int			val1;
	int			val2;
d573 3
a575 3
	CSR_WRITE_2(sc, WI_PARAM0, val0);
	CSR_WRITE_2(sc, WI_PARAM1, val1);
	CSR_WRITE_2(sc, WI_PARAM2, val2);
d610 1
a610 6
	/* Symbol firmware cannot be initialized more than once. */
	if (sc->sc_firmware_type == WI_SYMBOL &&
	    (sc->wi_flags & WI_FLAGS_INITIALIZED))
		return;

	if (wi_cmd(sc, WI_CMD_INI, 0, 0, 0))
a611 3
	else
		sc->wi_flags |= WI_FLAGS_INITIALIZED;

a620 28
STATIC void
wi_cor_reset(sc)
	struct wi_softc		*sc;
{
	u_int8_t cor_value;

	DPRINTF(WID_RESET, ("wi_cor_reset: sc %p\n", sc));

	/*
	 * Do a soft reset of the card; this is required for Symbol cards.
	 * This shouldn't hurt other cards but there have been reports
	 * of the COR reset messing up old Lucent firmware revisions so
	 * we only soft reset Symbol cards for now.
	 */
	if (sc->sc_firmware_type == WI_SYMBOL) {
		cor_value = bus_space_read_1(sc->wi_ltag, sc->wi_lhandle,
		    sc->wi_cor_offset);
		bus_space_write_1(sc->wi_ltag, sc->wi_lhandle,
		    sc->wi_cor_offset, (cor_value | WI_COR_SOFT_RESET));
		DELAY(1000);
		bus_space_write_1(sc->wi_ltag, sc->wi_lhandle,
		    sc->wi_cor_offset, (cor_value & ~WI_COR_SOFT_RESET));
		DELAY(1000);
	}

	return;
}

d633 1
a633 1
	if (sc->sc_firmware_type != WI_LUCENT) {
a641 2
			if (ltv->wi_val > WI_NLTV_KEYS)
				return (EINVAL);
d650 1
a650 1
	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type, 0, 0))
d677 1
a677 9
	if (ltv->wi_type == WI_RID_PORTTYPE && sc->wi_ptype == WI_PORTTYPE_IBSS
	    && ltv->wi_val == sc->wi_ibss_port) {
		/*
		 * Convert vendor IBSS port type to WI_PORTTYPE_IBSS.
		 * Since Lucent uses port type 1 for BSS *and* IBSS we
		 * have to rely on wi_ptype to distinguish this for us.
		 */
		ltv->wi_val = htole16(WI_PORTTYPE_IBSS);
	} else if (sc->sc_firmware_type != WI_LUCENT) {
a702 1
		case WI_RID_CNFAUTHMODE:
d706 7
a727 1
	u_int16_t		val = 0;
d731 1
a731 8
	if (ltv->wi_type == WI_RID_PORTTYPE &&
	    letoh16(ltv->wi_val) == WI_PORTTYPE_IBSS) {
		/* Convert WI_PORTTYPE_IBSS to vendor IBSS port type. */
		p2ltv.wi_type = WI_RID_PORTTYPE;
		p2ltv.wi_len = 2;
		p2ltv.wi_val = sc->wi_ibss_port;
		ltv = &p2ltv;
	} else if (sc->sc_firmware_type != WI_LUCENT) {
d754 4
a757 30
			if (ltv->wi_val & htole16(0x01)) {
				val = PRIVACY_INVOKED;
				/*
				 * If using shared key WEP we must set the
				 * EXCLUDE_UNENCRYPTED bit.  Symbol cards
				 * need this bit set even when not using
				 * shared key. We can't just test for
				 * IEEE80211_AUTH_SHARED since Symbol cards
				 * have 2 shared key modes.
				 */
				if (sc->wi_authtype != IEEE80211_AUTH_OPEN ||
				    sc->sc_firmware_type == WI_SYMBOL)
					val |= EXCLUDE_UNENCRYPTED;

				switch (sc->wi_crypto_algorithm) {
				case WI_CRYPTO_FIRMWARE_WEP:
					/*
					 * TX encryption is broken in
					 * Host AP mode.
					 */
					if (sc->wi_ptype == WI_PORTTYPE_HOSTAP)
						val |= HOST_ENCRYPT;
					break;
				case WI_CRYPTO_SOFTWARE_WEP:
					val |= HOST_ENCRYPT|HOST_DECRYPT;
					break;
				}
				p2ltv.wi_val = htole16(val);
			} else
				p2ltv.wi_val = htole16(HOST_ENCRYPT | HOST_DECRYPT);
a760 2
			if (ltv->wi_val > WI_NLTV_KEYS)
				return (EINVAL);
a767 1
				int keylen;
a769 2
				keylen = wk->wi_keys[sc->wi_tx_key].wi_keylen;

d772 13
a784 1
					ws.wi_len = (keylen > 5) ? 8 : 4;
a785 2
					bcopy(&wk->wi_keys[i].wi_keydat,
					    ws.wi_str, keylen);
d793 9
d815 1
a815 1
	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type, 0, 0))
d933 1
a933 1
	if (wi_cmd(sc, WI_CMD_ALLOC_MEM, len, 0, 0)) {
d947 1
a948 1
	CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);
d969 1
a969 1
	ifp = &sc->sc_arpcom.ac_if;
d981 1
a981 1
	ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
d1009 2
d1012 1
d1015 1
a1015 1
	ifp = &sc->sc_arpcom.ac_if;
d1019 4
a1022 3
		bcopy((char *)&wreq->wi_val, LLADDR(ifp->if_sadl),
		    ETHER_ADDR_LEN);
		bcopy((char *)&wreq->wi_val, (char *)&sc->sc_arpcom.ac_enaddr,
a1043 1
		error = wi_sync_media(sc, sc->wi_ptype, sc->wi_tx_rate);
d1069 1
a1069 1
	case WI_RID_CNFAUTHMODE:
a1074 3
	case WI_RID_SYMBOL_DIVERSITY:
		sc->wi_diversity = letoh16(wreq->wi_val[0]);
		break;
a1084 14
	case WI_FRID_CRYPTO_ALG:
		switch (letoh16(wreq->wi_val[0])) {
		case WI_CRYPTO_FIRMWARE_WEP:
			sc->wi_crypto_algorithm = WI_CRYPTO_FIRMWARE_WEP;
			break;
		case WI_CRYPTO_SOFTWARE_WEP:
			sc->wi_crypto_algorithm = WI_CRYPTO_SOFTWARE_WEP;
			break;
		default:
			printf(WI_PRT_FMT ": unsupported crypto algorithm %d\n",
			    WI_PRT_ARG(sc), letoh16(wreq->wi_val[0]));
			error = EINVAL;
		}
		break;
d1112 1
a1112 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED)) {
d1120 1
a1120 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
a1125 15
	case SIOCSWAVELAN:
	case SIOCSPRISM2DEBUG:
	case SIOCS80211NWID:
	case SIOCS80211NWKEY:
	case SIOCS80211POWER:
		error = suser(p->p_ucred, &p->p_acflag);
		if (error) {
			splx(s);
			return (error);
		}
	default:
		break;
	}

	switch(command) {
d1132 1
a1132 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1154 1
a1154 2
				if (sc->wi_ptype != WI_PORTTYPE_HOSTAP)
					WI_SETVAL(WI_RID_PROMISC, 1);
d1158 8
a1165 6
				if (sc->wi_ptype != WI_PORTTYPE_HOSTAP)
					WI_SETVAL(WI_RID_PROMISC, 0);
			} else
				wi_init(sc);
		} else if (ifp->if_flags & IFF_RUNNING)
			wi_stop(sc);
d1173 2
a1174 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
d1192 1
a1192 6
		if (wreq.wi_len > WI_MAX_DATALEN) {
			error = EINVAL;
			break;
		}
		switch (wreq.wi_type) {
		case WI_RID_IFACE_STATS:
d1197 1
a1197 2
			break;
		case WI_RID_DEFLT_CRYPT_KEYS:
d1205 1
a1205 25
			break;
		case WI_RID_PROCFRAME:
			wreq.wi_len = 2;
			wreq.wi_val[0] = htole16(sc->wi_procframe);
			break;
		case WI_RID_PRISM2:
			wreq.wi_len = 2;
			wreq.wi_val[0] = htole16(sc->sc_firmware_type ==
			    WI_LUCENT ? 0 : 1);
			break;
		case WI_FRID_CRYPTO_ALG:
			wreq.wi_val[0] =
			    htole16((u_int16_t)sc->wi_crypto_algorithm);
			wreq.wi_len = 1;
			break;
		case WI_RID_SCAN_RES:
			if (sc->sc_firmware_type == WI_LUCENT) {
				memcpy((char *)wreq.wi_val,
				    (char *)sc->wi_scanbuf,
				    sc->wi_scanbuf_len * 2);
				wreq.wi_len = sc->wi_scanbuf_len;
				break;
			}
			/* FALLTHROUGH */
		default:
d1208 1
a1209 1
			break;
d1214 3
d1220 2
a1221 5
		error = EINVAL;
		if (wreq.wi_len > WI_MAX_DATALEN)
			break;
		switch (wreq.wi_type) {
		case WI_RID_IFACE_STATS:
d1223 1
a1223 1
		case WI_RID_MGMT_XMIT:
d1226 1
a1226 43
			break;
		case WI_RID_PROCFRAME:
			sc->wi_procframe = letoh16(wreq.wi_val[0]);
			error = 0;
			break;
		case WI_RID_SCAN_REQ:
			error = 0;
			if (sc->sc_firmware_type == WI_LUCENT)
				wi_cmd(sc, WI_CMD_INQUIRE,
				    WI_INFO_SCAN_RESULTS, 0, 0);
			else
				error = wi_write_record(sc,
				    (struct wi_ltv_gen *)&wreq);
			break;
		case WI_FRID_CRYPTO_ALG:
			if (sc->sc_firmware_type != WI_LUCENT) {
				error = wi_setdef(sc, &wreq);
				if (!error && (ifp->if_flags & IFF_UP))
					wi_init(sc);
			}
			break;
		case WI_RID_SYMBOL_DIVERSITY:
		case WI_RID_ROAMING_MODE:
		case WI_RID_CREATE_IBSS:
		case WI_RID_MICROWAVE_OVEN:
		case WI_RID_OWN_SSID:
			/*
			 * Check for features that may not be supported
			 * (must be just before default case).
			 */
			if ((wreq.wi_type == WI_RID_SYMBOL_DIVERSITY &&
			    !(sc->wi_flags & WI_FLAGS_HAS_DIVERSITY)) ||
			    (wreq.wi_type == WI_RID_ROAMING_MODE &&
			    !(sc->wi_flags & WI_FLAGS_HAS_ROAMING)) ||
			    (wreq.wi_type == WI_RID_CREATE_IBSS &&
			    !(sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS)) ||
			    (wreq.wi_type == WI_RID_MICROWAVE_OVEN &&
			    !(sc->wi_flags & WI_FLAGS_HAS_MOR)) ||
			    (wreq.wi_type == WI_RID_OWN_SSID &&
			    wreq.wi_len != 0))
				break;
			/* FALLTHROUGH */
		default:
d1230 2
a1231 12
			if (!error && (ifp->if_flags & IFF_UP))
				wi_init(sc);
		}
		break;
	case SIOCGPRISM2DEBUG:
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
		if (error)
			break;
		if (!(ifp->if_flags & IFF_RUNNING) ||
		    sc->sc_firmware_type == WI_LUCENT) {
			error = EIO;
			break;
a1232 9
		error = wi_get_debug(sc, &wreq);
		if (error == 0)
			error = copyout(&wreq, ifr->ifr_data, sizeof(wreq));
		break;
	case SIOCSPRISM2DEBUG:
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
		if (error)
			break;
		error = wi_set_debug(sc, &wreq);
d1235 1
a1235 1
		if ((ifp->if_flags & IFF_UP) && sc->wi_net_name.i_len > 0) {
d1240 2
a1241 2
			wreq.wi_type = WI_RID_CURRENT_SSID;
			wreq.wi_len = WI_MAX_DATALEN;
d1255 1
a1255 1
		if (error)
a1264 1
		WI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);
d1267 1
a1267 1
			wi_init(sc);
a1280 9
	case SIOCHOSTAP_ADD:
	case SIOCHOSTAP_DEL:
	case SIOCHOSTAP_GET:
	case SIOCHOSTAP_GETALL:
	case SIOCHOSTAP_GFLAGS:
	case SIOCHOSTAP_SFLAGS:
		/* Send all Host AP specific ioctl's to Host AP code. */
		error = wihap_ioctl(sc, command, data);
		break;
d1291 2
a1292 2
wi_init(sc)
	struct wi_softc		*sc;
d1294 2
a1295 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d1300 1
a1300 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
d1315 3
a1320 3
	/* Enable/disable IBSS creation. */
	WI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);

d1336 5
a1340 7
	/* Set Roaming Mode unless this is a Symbol card. */
	if (sc->wi_flags & WI_FLAGS_HAS_ROAMING)
		WI_SETVAL(WI_RID_ROAMING_MODE, sc->wi_roaming);

	/* Set Antenna Diversity if this is a Symbol card. */
	if (sc->wi_flags & WI_FLAGS_HAS_DIVERSITY)
		WI_SETVAL(WI_RID_SYMBOL_DIVERSITY, sc->wi_diversity);
a1344 7
	/* Specify the IBSS name */
	if (sc->wi_net_name.i_len != 0 && (sc->wi_ptype == WI_PORTTYPE_HOSTAP ||
	    (sc->wi_create_ibss && sc->wi_ptype == WI_PORTTYPE_IBSS)))
		WI_SETSTR(WI_RID_OWN_SSID, sc->wi_net_name);
	else
		WI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);

d1354 1
a1354 1
	bcopy((char *)&sc->sc_arpcom.ac_enaddr,
d1358 2
a1359 9
	/*
	 * Initialize promisc mode.
	 *	Being in the Host-AP mode causes
	 *	great deal of pain if promisc mode is set.
	 *	Therefore we avoid confusing the firmware
	 *	and always reset promisc mode in Host-AP regime,
	 *	it shows us all the packets anyway.
	 */
	if (sc->wi_ptype != WI_PORTTYPE_HOSTAP && ifp->if_flags & IFF_PROMISC)
d1361 1
a1361 1
	else
d1363 1
d1366 1
a1366 1
	if (sc->wi_flags & WI_FLAGS_HAS_WEP) {
d1372 1
a1372 1
		if (sc->sc_firmware_type != WI_LUCENT && sc->wi_use_wep) {
d1374 1
a1374 2
			 * HWB3163 EVAL-CARD Firmware version less than 0.8.2.
			 *
d1380 2
a1381 3
			 if (sc->sc_firmware_type == WI_INTERSIL &&
			    sc->sc_sta_firmware_ver < 802 ) {
				/* firm ver < 0.8.2 */
d1384 1
a1384 1
			 WI_SETVAL(WI_RID_CNFAUTHMODE, sc->wi_authtype);
d1392 1
a1392 1
	wi_cmd(sc, WI_CMD_ENABLE | sc->wi_portnum, 0, 0, 0);
d1394 1
a1394 1
	if (wi_alloc_nicmem(sc, ETHER_MAX_LEN + sizeof(struct wi_frame) + 8, &id))
d1399 1
a1399 1
	if (wi_alloc_nicmem(sc, ETHER_MAX_LEN + sizeof(struct wi_frame) + 8, &id))
a1406 2
        wihap_init(sc);

a1416 216
static const u_int32_t crc32tab[] = {
	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL,
	0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L,
	0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L,
	0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L,
	0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
	0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L,
	0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL,
	0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L,
	0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L,
	0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
	0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L,
	0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L,
	0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L,
	0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL,
	0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
	0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL,
	0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL,
	0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L,
	0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L,
	0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
	0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL,
	0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L,
	0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL,
	0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L,
	0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
	0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL,
	0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L,
	0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L,
	0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L,
	0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
	0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L,
	0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL,
	0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL,
	0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L,
	0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
	0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L,
	0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL,
	0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L,
	0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL,
	0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
	0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L,
	0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL,
	0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L,
	0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L,
	0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
	0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL,
	0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L,
	0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL,
	0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL,
	0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
	0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L,
	0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L,
	0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL,
	0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L,
	0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
	0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L,
	0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L,
	0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL,
	0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L,
	0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
	0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L,
	0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL,
	0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L,
	0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL
};

#define RC4STATE 256
#define RC4KEYLEN 16
#define RC4SWAP(x,y) \
    do { u_int8_t t = state[x]; state[x] = state[y]; state[y] = t; } while(0)

STATIC void
wi_do_hostencrypt(struct wi_softc *sc, caddr_t buf, int len)
{
	u_int32_t i, crc, klen;
	u_int8_t state[RC4STATE], key[RC4KEYLEN];
	u_int8_t x, y, *dat;

	if (!sc->wi_icv_flag) {
		sc->wi_icv = arc4random();
		sc->wi_icv_flag++;
        } else
		sc->wi_icv++;
	/*
	 * Skip 'bad' IVs from Fluhrer/Mantin/Shamir:
	 * (B, 255, N) with 3 <= B < 8
	 */
	if (sc->wi_icv >= 0x03ff00 &&
            (sc->wi_icv & 0xf8ff00) == 0x00ff00)
                sc->wi_icv += 0x000100;

	/* prepend 24bit IV to tx key, byte order does not matter */
	bzero(key, sizeof(key));
	key[0] = sc->wi_icv >> 16;
	key[1] = sc->wi_icv >> 8;
	key[2] = sc->wi_icv;

	klen = sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keylen;
	bcopy((char *)&sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keydat,
	    (char *)key + IEEE80211_WEP_IVLEN, klen);
	klen = (klen > IEEE80211_WEP_KEYLEN) ? RC4KEYLEN : RC4KEYLEN / 2;

	/* rc4 keysetup */
	x = y = 0;
	for (i = 0; i < RC4STATE; i++)
		state[i] = i;
	for (i = 0; i < RC4STATE; i++) {
		y = (key[x] + state[i] + y) % RC4STATE;
		RC4SWAP(i, y);
		x = (x + 1) % klen;
	}

	/* output: IV, tx keyid, rc4(data), rc4(crc32(data)) */
	dat = buf;
	dat[0] = key[0];
	dat[1] = key[1];
	dat[2] = key[2];
	dat[3] = sc->wi_tx_key << 6;		/* pad and keyid */
	dat += 4;

	/* compute rc4 over data, crc32 over data */
	crc = ~0;
	x = y = 0;
	for (i = 0; i < len; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		crc = crc32tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
	}
	crc = ~crc;
	dat += len;

	/* append little-endian crc32 and encrypt */
	dat[0] = crc;
	dat[1] = crc >> 8;
	dat[2] = crc >> 16;
	dat[3] = crc >> 24;
	for (i = 0; i < IEEE80211_WEP_CRCLEN; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
	}
}

STATIC int
wi_do_hostdecrypt(struct wi_softc *sc, caddr_t buf, int len)
{
	u_int32_t i, crc, klen, kid;
	u_int8_t state[RC4STATE], key[RC4KEYLEN];
	u_int8_t x, y, *dat;

	if (len < IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
	    IEEE80211_WEP_CRCLEN)
		return -1;
	len -= (IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
	    IEEE80211_WEP_CRCLEN);

	dat = buf;

	bzero(key, sizeof(key));
	key[0] = dat[0];
	key[1] = dat[1];
	key[2] = dat[2];
	kid = (dat[3] >> 6) % 4;
	dat += 4;

	klen = sc->wi_keys.wi_keys[kid].wi_keylen;
	bcopy((char *)&sc->wi_keys.wi_keys[kid].wi_keydat,
	    (char *)key + IEEE80211_WEP_IVLEN, klen);
	klen = (klen > IEEE80211_WEP_KEYLEN) ? RC4KEYLEN : RC4KEYLEN / 2;

	/* rc4 keysetup */
	x = y = 0;
	for (i = 0; i < RC4STATE; i++)
		state[i] = i;
	for (i = 0; i < RC4STATE; i++) {
		y = (key[x] + state[i] + y) % RC4STATE;
		RC4SWAP(i, y);
		x = (x + 1) % klen;
	}

	/* compute rc4 over data, crc32 over data */
	crc = ~0;
	x = y = 0;
	for (i = 0; i < len; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
		crc = crc32tab[(crc ^ dat[i]) & 0xff] ^ (crc >> 8);
	}
	crc = ~crc;
	dat += len;

	/* append little-endian crc32 and encrypt */
	for (i = 0; i < IEEE80211_WEP_CRCLEN; i++) {
		x = (x + 1) % RC4STATE;
		y = (state[x] + y) % RC4STATE;
		RC4SWAP(x, y);
		dat[i] ^= state[(state[x] + state[y]) % RC4STATE];
	}
	if ((dat[0] != crc) && (dat[1] != crc >> 8) &&
	    (dat[2] != crc >> 16) && (dat[3] != crc >> 24)) {
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf(WI_PRT_FMT ": wi_do_hostdecrypt: iv mismatch: "
			    "0x%02x%02x%02x%02x vs. 0x%x\n", WI_PRT_ARG(sc),
			    dat[3], dat[2], dat[1], dat[0], crc);
		return -1;
	}

	return 0;
}

d1431 1
a1431 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
a1436 1
nextpkt:
a1441 1
	tx_frame.wi_frame_ctl = htole16(WI_FTYPE_DATA);
a1444 13
	if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
		if (!wihap_check_tx(&sc->wi_hostap_info, eh->ether_dhost,
		    &tx_frame.wi_tx_rate) && !(ifp->if_flags & IFF_PROMISC)) {
			if (ifp->if_flags & IFF_DEBUG)
				printf(WI_PRT_FMT
				    ": wi_start: dropping unassoc dst %s\n",
				    WI_PRT_ARG(sc),
				    ether_sprintf(eh->ether_dhost));
			m_freem(m0);
			goto nextpkt;
		}
	}

d1449 4
a1452 4
	if (eh->ether_type == htons(ETHERTYPE_IP) ||
	    eh->ether_type == htons(ETHERTYPE_ARP) ||
	    eh->ether_type == htons(ETHERTYPE_REVARP) ||
	    eh->ether_type == htons(ETHERTYPE_IPV6)) {
d1455 2
a1456 12
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP) {
			tx_frame.wi_tx_ctl = htole16(WI_ENC_TX_MGMT); /* XXX */
			tx_frame.wi_frame_ctl |= htole16(WI_FCTL_FROMDS);
			if (sc->wi_use_wep)
				tx_frame.wi_frame_ctl |= htole16(WI_FCTL_WEP);
			bcopy((char *)&sc->sc_arpcom.ac_enaddr,
			    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
			bcopy((char *)&eh->ether_shost,
			    (char *)&tx_frame.wi_addr3, ETHER_ADDR_LEN);
		} else
			bcopy((char *)&eh->ether_shost,
			    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
d1462 2
a1463 1
		tx_frame.wi_dat_len = m0->m_pkthdr.len - WI_SNAPHDR_LEN;
d1469 8
a1476 35
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP && sc->wi_use_wep) {

			/* Do host encryption. */
			bcopy(&tx_frame.wi_dat[0], &sc->wi_txbuf[4], 8);

			m_copydata(m0, sizeof(struct ether_header),
			    m0->m_pkthdr.len - sizeof(struct ether_header),
			    (caddr_t)&sc->wi_txbuf[12]);

			wi_do_hostencrypt(sc, (caddr_t)&sc->wi_txbuf,
			    tx_frame.wi_dat_len);

			tx_frame.wi_dat_len += IEEE80211_WEP_IVLEN +
			    IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN;

			tx_frame.wi_dat_len = htole16(tx_frame.wi_dat_len);
			wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
			    sizeof(struct wi_frame));
			wi_write_data(sc, id, WI_802_11_OFFSET_RAW,
			    (caddr_t)&sc->wi_txbuf,
			    (m0->m_pkthdr.len -
			     sizeof(struct ether_header)) + 18);
		} else {
			m_copydata(m0, sizeof(struct ether_header),
			    m0->m_pkthdr.len - sizeof(struct ether_header),
			    (caddr_t)&sc->wi_txbuf);

			tx_frame.wi_dat_len = htole16(tx_frame.wi_dat_len);
			wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
			    sizeof(struct wi_frame));
			wi_write_data(sc, id, WI_802_11_OFFSET,
			    (caddr_t)&sc->wi_txbuf,
			    (m0->m_pkthdr.len -
			     sizeof(struct ether_header)) + 2);
		}
d1480 1
a1480 9
		if (sc->wi_ptype == WI_PORTTYPE_HOSTAP && sc->wi_use_wep) {

			/* Do host encryption. (XXX - not implemented) */
			printf(WI_PRT_FMT
			    ": host encrypt not implemented for 802.3\n",
			    WI_PRT_ARG(sc));
		} else {
			m_copydata(m0, 0, m0->m_pkthdr.len,
			    (caddr_t)&sc->wi_txbuf);
d1482 4
a1485 5
			wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
			    sizeof(struct wi_frame));
			wi_write_data(sc, id, WI_802_3_OFFSET,
			    (caddr_t)&sc->wi_txbuf, m0->m_pkthdr.len + 2);
		}
d1499 2
a1500 2
	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id, 0, 0))
		printf(WI_PRT_FMT ": wi_start: xmit failed\n", WI_PRT_ARG(sc));
d1523 1
a1523 1
	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
d1535 2
a1536 3
	tx_frame.wi_tx_ctl = htole16(WI_ENC_TX_MGMT);
	tx_frame.wi_dat_len = len - sizeof(struct wi_80211_hdr);
	tx_frame.wi_len = htole16(tx_frame.wi_dat_len);
a1537 1
	tx_frame.wi_dat_len = htole16(tx_frame.wi_dat_len);
d1542 2
a1543 3
	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id, 0, 0)) {
		printf(WI_PRT_FMT ": wi_mgmt_xmit: xmit failed\n",
		    WI_PRT_ARG(sc));
d1556 1
a1556 3
	wihap_shutdown(sc);

	if (!(sc->wi_flags & WI_FLAGS_ATTACHED))
d1561 1
a1561 1
	timeout_del(&sc->sc_timo);
d1563 2
a1564 1
	ifp = &sc->sc_arpcom.ac_if;
d1566 1
a1566 2
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	wi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0, 0, 0);
a1583 1
	wi_cor_reset(sc);
d1604 1
a1604 1
wi_get_id(sc)
d1606 1
d1608 23
a1630 5
	struct wi_ltv_ver		ver;
	const struct wi_card_ident	*id;
	u_int16_t			pri_fw_ver[3];
	const char			*card_name;
	u_int16_t			card_id;
d1637 40
a1676 3
	card_id = letoh16(ver.wi_ver[0]);
	for (id = wi_card_ident; id->firm_type != WI_NOTYPE; id++) {
		if (card_id == id->card_id)
a1678 9
	if (id->firm_type != WI_NOTYPE) {
		sc->sc_firmware_type = id->firm_type;
		card_name = id->card_name;
	} else if (ver.wi_ver[0] & htole16(0x8000)) {
		sc->sc_firmware_type = WI_INTERSIL;
		card_name = "Unknown PRISM2 chip";
	} else {
		sc->sc_firmware_type = WI_LUCENT;
	}
d1680 1
a1680 12
	/* get primary firmware version (XXX - how to do Lucent?) */
	if (sc->sc_firmware_type != WI_LUCENT) {
		bzero(&ver, sizeof(ver));
		ver.wi_type = WI_RID_PRI_IDENTITY;
		ver.wi_len = 5;
		wi_read_record(sc, (struct wi_ltv_gen *)&ver);
		pri_fw_ver[0] = letoh16(ver.wi_ver[2]);
		pri_fw_ver[1] = letoh16(ver.wi_ver[3]);
		pri_fw_ver[2] = letoh16(ver.wi_ver[1]);
	}

	/* get station firmware version */
d1688 9
a1696 20
	sc->sc_sta_firmware_ver = ver.wi_ver[2] * 10000 +
	    ver.wi_ver[3] * 100 + ver.wi_ver[1];

	if (sc->sc_firmware_type == WI_INTERSIL &&
	    (sc->sc_sta_firmware_ver == 10102 || sc->sc_sta_firmware_ver == 20102)) {
		struct wi_ltv_str sver;
		char *p;

		bzero(&sver, sizeof(sver));
		sver.wi_type = WI_RID_SYMBOL_IDENTITY;
		sver.wi_len = 7;
		/* value should be something like "V2.00-11" */
		if (wi_read_record(sc, (struct wi_ltv_gen *)&sver) == 0 &&
		    *(p = (char *)sver.wi_str) >= 'A' &&
		    p[2] == '.' && p[5] == '-' && p[8] == '\0') {
			sc->sc_firmware_type = WI_SYMBOL;
			sc->sc_sta_firmware_ver = (p[1] - '0') * 10000 +
			    (p[3] - '0') * 1000 + (p[4] - '0') * 100 +
			    (p[6] - '0') * 10 + (p[7] - '0');
		}
d1699 1
a1699 12
	if (sc->sc_firmware_type == WI_LUCENT) {
		printf("\n%s: Firmware %d.%d variant %d, ", WI_PRT_ARG(sc),
		    ver.wi_ver[2], ver.wi_ver[3], ver.wi_ver[1]);
	} else {
		printf("\n%s: %s%s, Firmware %d.%d.%d (primary), %d.%d.%d (station), ",
		    WI_PRT_ARG(sc),
		    sc->sc_firmware_type == WI_SYMBOL ? "Symbol " : "",
		    card_name, pri_fw_ver[0], pri_fw_ver[1], pri_fw_ver[2],
		    sc->sc_sta_firmware_ver / 10000,
		    (sc->sc_sta_firmware_ver % 10000) / 100,
		    sc->sc_sta_firmware_ver % 100);
	}
d1729 1
a1729 1
		subtype = IFM_MANUAL;		/* Unable to represent */
a1732 1
	options &= ~IFM_OMASK;
a1733 3
	case WI_PORTTYPE_BSS:
		/* default port type */
		break;
d1737 2
a1738 8
	case WI_PORTTYPE_HOSTAP:
		options |= IFM_IEEE80211_HOSTAP;
		break;
	case WI_PORTTYPE_IBSS:
		if (sc->wi_create_ibss)
			options |= IFM_IEEE80211_IBSSMASTER;
		else
			options |= IFM_IEEE80211_IBSS;
d1741 1
a1741 1
		subtype = IFM_MANUAL;		/* Unable to represent */
a1760 1
	int ocreate_ibss = sc->wi_create_ibss;
d1762 3
a1764 8
	if ((sc->sc_media.ifm_cur->ifm_media & IFM_IEEE80211_HOSTAP) &&
	    sc->sc_firmware_type != WI_INTERSIL)
		return (EINVAL);

	sc->wi_create_ibss = 0;

	switch (sc->sc_media.ifm_cur->ifm_media & IFM_OMASK) {
	case 0:
a1765 20
		break;
	case IFM_IEEE80211_ADHOC:
		sc->wi_ptype = WI_PORTTYPE_ADHOC;
		break;
	case IFM_IEEE80211_HOSTAP:
		sc->wi_ptype = WI_PORTTYPE_HOSTAP;
		break;
	case IFM_IEEE80211_IBSSMASTER:
	case IFM_IEEE80211_IBSSMASTER|IFM_IEEE80211_IBSS:
		if (!(sc->wi_flags & WI_FLAGS_HAS_CREATE_IBSS))
			return (EINVAL);
		sc->wi_create_ibss = 1;
		/* FALLTHROUGH */
	case IFM_IEEE80211_IBSS:
		sc->wi_ptype = WI_PORTTYPE_IBSS;
		break;
	default:
		/* Invalid combination. */
		return (EINVAL);
	}
d1785 4
a1788 4
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
		if (otype != sc->wi_ptype || orate != sc->wi_tx_rate ||
		    ocreate_ibss != sc->wi_create_ibss)
			wi_init(sc);
a1801 1
	struct wi_req wreq;
d1803 1
a1803 1
	if (!(sc->sc_arpcom.ac_if.if_flags & IFF_UP)) {
d1809 2
a1810 45
	if (sc->wi_tx_rate == 3) {
		imr->ifm_active = IFM_IEEE80211|IFM_AUTO;

		wreq.wi_type = WI_RID_CUR_TX_RATE;
		wreq.wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) == 0) {
			switch (letoh16(wreq.wi_val[0])) {
			case 1:
				imr->ifm_active |= IFM_IEEE80211_DS1;
				break;
			case 2:
				imr->ifm_active |= IFM_IEEE80211_DS2;
				break;
			case 6:
				imr->ifm_active |= IFM_IEEE80211_DS5;
				break;
			case 11:
				imr->ifm_active |= IFM_IEEE80211_DS11;
				break;
			}
		}
	} else {
		imr->ifm_active = sc->sc_media.ifm_cur->ifm_media;
	}

	imr->ifm_status = IFM_AVALID;
	switch (sc->wi_ptype) {
	case WI_PORTTYPE_ADHOC:
	case WI_PORTTYPE_IBSS:
		/*
		 * XXX: It would be nice if we could give some actually
		 * useful status like whether we joined another IBSS or
		 * created one ourselves.
		 */
		/* FALLTHROUGH */
	case WI_PORTTYPE_HOSTAP:
		imr->ifm_status |= IFM_ACTIVE;
		break;
	default:
		wreq.wi_type = WI_RID_COMMQUAL;
		wreq.wi_len = WI_MAX_DATALEN;
		if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq) == 0 &&
		    letoh16(wreq.wi_val[0]) != 0)
			imr->ifm_status |= IFM_ACTIVE;
	}
d1822 1
a1822 1
	if (!(sc->wi_flags & WI_FLAGS_HAS_WEP))
d1824 2
a1825 1
	if (nwkey->i_defkid <= 0 || nwkey->i_defkid > IEEE80211_WEP_NKID)
d1843 1
a1843 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
d1854 1
a1854 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
d1864 1
a1864 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP) {
d1872 2
a1873 2
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP)
		wi_init(sc);
d1885 1
a1885 1
	if (!(sc->wi_flags & WI_FLAGS_HAS_WEP))
d1917 2
a1918 2
	if (sc->sc_arpcom.ac_if.if_flags & IFF_UP)
		wi_init(sc);
a1944 143
}

STATIC int
wi_get_debug(sc, wreq)
	struct wi_softc		*sc;
	struct wi_req		*wreq;
{
	int			error = 0;

	wreq->wi_len = 1;

	switch (wreq->wi_type) {
	case WI_DEBUG_SLEEP:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_sleep);
		break;
	case WI_DEBUG_DELAYSUPP:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_delaysupp);
		break;
	case WI_DEBUG_TXSUPP:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_txsupp);
		break;
	case WI_DEBUG_MONITOR:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_monitor);
		break;
	case WI_DEBUG_LEDTEST:
		wreq->wi_len += 3;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_ledtest);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_ledtest_param0);
		wreq->wi_val[2] = htole16(sc->wi_debug.wi_ledtest_param1);
		break;
	case WI_DEBUG_CONTTX:
		wreq->wi_len += 2;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_conttx);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_conttx_param0);
		break;
	case WI_DEBUG_CONTRX:
		wreq->wi_len++;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_contrx);
		break;
	case WI_DEBUG_SIGSTATE:
		wreq->wi_len += 2;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_sigstate);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_sigstate_param0);
		break;
	case WI_DEBUG_CONFBITS:
		wreq->wi_len += 2;
		wreq->wi_val[0] = htole16(sc->wi_debug.wi_confbits);
		wreq->wi_val[1] = htole16(sc->wi_debug.wi_confbits_param0);
		break;
	default:
		error = EIO;
		break;
	}

	return (error);
}

STATIC int
wi_set_debug(sc, wreq)
	struct wi_softc		*sc;
	struct wi_req		*wreq;
{
	int				error = 0;
	u_int16_t			cmd, param0 = 0, param1 = 0;

	switch (wreq->wi_type) {
	case WI_DEBUG_RESET:
	case WI_DEBUG_INIT:
	case WI_DEBUG_CALENABLE:
		break;
	case WI_DEBUG_SLEEP:
		sc->wi_debug.wi_sleep = 1;
		break;
	case WI_DEBUG_WAKE:
		sc->wi_debug.wi_sleep = 0;
		break;
	case WI_DEBUG_CHAN:
		param0 = letoh16(wreq->wi_val[0]);
		break;
	case WI_DEBUG_DELAYSUPP:
		sc->wi_debug.wi_delaysupp = 1;
		break;
	case WI_DEBUG_TXSUPP:
		sc->wi_debug.wi_txsupp = 1;
		break;
	case WI_DEBUG_MONITOR:
		sc->wi_debug.wi_monitor = 1;
		break;
	case WI_DEBUG_LEDTEST:
		param0 = letoh16(wreq->wi_val[0]);
		param1 = letoh16(wreq->wi_val[1]);
		sc->wi_debug.wi_ledtest = 1;
		sc->wi_debug.wi_ledtest_param0 = param0;
		sc->wi_debug.wi_ledtest_param1 = param1;
		break;
	case WI_DEBUG_CONTTX:
		param0 = letoh16(wreq->wi_val[0]);
		sc->wi_debug.wi_conttx = 1;
		sc->wi_debug.wi_conttx_param0 = param0;
		break;
	case WI_DEBUG_STOPTEST:
		sc->wi_debug.wi_delaysupp = 0;
		sc->wi_debug.wi_txsupp = 0;
		sc->wi_debug.wi_monitor = 0;
		sc->wi_debug.wi_ledtest = 0;
		sc->wi_debug.wi_ledtest_param0 = 0;
		sc->wi_debug.wi_ledtest_param1 = 0;
		sc->wi_debug.wi_conttx = 0;
		sc->wi_debug.wi_conttx_param0 = 0;
		sc->wi_debug.wi_contrx = 0;
		sc->wi_debug.wi_sigstate = 0;
		sc->wi_debug.wi_sigstate_param0 = 0;
		break;
	case WI_DEBUG_CONTRX:
		sc->wi_debug.wi_contrx = 1;
		break;
	case WI_DEBUG_SIGSTATE:
		param0 = letoh16(wreq->wi_val[0]);
		sc->wi_debug.wi_sigstate = 1;
		sc->wi_debug.wi_sigstate_param0 = param0;
		break;
	case WI_DEBUG_CONFBITS:
		param0 = letoh16(wreq->wi_val[0]);
		param1 = letoh16(wreq->wi_val[1]);
		sc->wi_debug.wi_confbits = param0;
		sc->wi_debug.wi_confbits_param0 = param1;
		break;
	default:
		error = EIO;
		break;
	}

	if (error)
		return (error);

	cmd = WI_CMD_DEBUG | (wreq->wi_type << 8);
	error = wi_cmd(sc, cmd, param0, param1, 0);

	return (error);
@


1.15.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.15.2.4 2003/03/28 00:38:13 niklas Exp $	*/
d127 1
a127 1
	"$OpenBSD: if_wi.c,v 1.15.2.4 2003/03/28 00:38:13 niklas Exp $";
d1834 1
a1834 1
	/* Power Management Max Sleep */
@


1.15.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
a53 1
 * publicly available version of the HCF library (the 'HCF Light') is
a103 2
#include <crypto/arc4.h>

d127 1
a127 1
	"$OpenBSD$";
a135 1
STATIC void wi_init_io(struct wi_softc *);
d144 4
a147 4
STATIC int wi_cmd_io(struct wi_softc *, int, int, int, int);
STATIC int wi_read_record_io(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_write_record_io(struct wi_softc *, struct wi_ltv_gen *);
STATIC int wi_read_data_io(struct wi_softc *, int,
d149 1
a149 1
STATIC int wi_write_data_io(struct wi_softc *, int,
d152 1
a152 1

a172 5
STATIC int wi_alloc_nicmem_io(struct wi_softc *, int, int *);
STATIC int wi_get_fid_io(struct wi_softc *sc, int fid);
STATIC void wi_intr_enable(struct wi_softc *sc, int mode);
STATIC void wi_intr_ack(struct wi_softc *sc, int mode);

a181 16
struct wi_funcs wi_func_io = {
        wi_cmd_io,
        wi_read_record_io,
        wi_write_record_io,
        wi_alloc_nicmem_io,
        wi_read_data_io,
        wi_write_data_io,
        wi_get_fid_io,
        wi_init_io,

        wi_start,
        wi_ioctl,
        wi_watchdog,
        wi_inquire,
};

d183 2
a184 1
wi_attach(struct wi_softc *sc, struct wi_funcs *funcs)
a190 2
	sc->sc_funcs = funcs;

d211 3
a213 3
	ifp->if_ioctl = funcs->f_ioctl;
	ifp->if_start = funcs->f_start;
	ifp->if_watchdog = funcs->f_watchdog;
d293 1
a293 1
	timeout_set(&sc->sc_timo, funcs->f_inquire, sc);
d394 1
a394 1
	sc->sc_sdhook = shutdownhook_establish(wi_shutdown, sc);
a401 14
STATIC void
wi_intr_enable(struct wi_softc *sc, int mode)
{
	if (!(sc->wi_flags & WI_FLAGS_BUS_USB))
		CSR_WRITE_2(sc, WI_INT_EN, mode);
}

STATIC void
wi_intr_ack(struct wi_softc *sc, int mode)
{
	if (!(sc->wi_flags & WI_FLAGS_BUS_USB))
		CSR_WRITE_2(sc, WI_EVENT_ACK, mode);
}

d467 1
a467 8
STATIC int
wi_get_fid_io(struct wi_softc *sc, int fid)
{
	return CSR_READ_2(sc, fid);
}


void
d481 1
a481 1
	id = wi_get_fid(sc, WI_RX_FID);
d775 1
a775 1
void
d835 1
a835 1
	id = wi_get_fid(sc, WI_INFO_FID);
d854 1
a854 5
		if (sc->wi_flags & WI_FLAGS_BUS_USB) {
			wi_read_data(sc, id, 4 + i*2, (char *)&t, 2);
			t = letoh16(t);
		} else 
			t = CSR_READ_2(sc, WI_DATA1);
d870 1
a870 1
wi_cmd_io(sc, cmd, val0, val1, val2)
d933 2
a934 2
	wi_intr_enable(sc, 0);
	wi_intr_ack(sc, 0xffff);
d974 1
a974 1
wi_read_record_io(sc, ltv)
d1076 1
a1076 1
wi_write_record_io(sc, ltv)
a1160 1
				keylen = letoh16(keylen);
d1231 1
a1231 1
wi_read_data_io(sc, id, off, buf, len)
d1261 1
a1261 1
wi_write_data_io(sc, id, off, buf, len)
d1299 1
a1299 1
wi_alloc_nicmem_io(sc, len, id)
d1518 1
a1518 1
		error = suser(p, 0);
d1606 1
a1606 1
			if (suser(p, 0))
d1793 1
a1793 1
wi_init_io(sc)
d1923 1
a1923 1
	wi_intr_enable(sc, WI_INTRS);
d2004 5
d2013 2
a2014 3
	u_int8_t key[RC4KEYLEN];
	u_int8_t *dat;
	struct rc4_ctx ctx;
d2035 1
a2035 1
	klen = letoh16(sc->wi_keys.wi_keys[sc->wi_tx_key].wi_keylen);
d2041 8
a2048 1
	rc4_keysetup(&ctx, key, klen);
d2058 1
a2058 1
	/* compute crc32 over data and encrypt */
d2060 5
a2064 1
	for (i = 0; i < len; i++)
d2066 2
a2068 1
	rc4_crypt(&ctx, dat, dat, len);
d2076 6
a2081 1
	rc4_crypt(&ctx, dat, dat, IEEE80211_WEP_CRCLEN);
d2088 2
a2089 3
	u_int8_t key[RC4KEYLEN];
	u_int8_t *dat;
	struct rc4_ctx ctx;
d2106 1
a2106 1
	klen = letoh16(sc->wi_keys.wi_keys[kid].wi_keylen);
d2112 8
a2119 1
	rc4_keysetup(&ctx, key, klen);
d2121 1
a2121 2
	/* decrypt and compute crc32 over data */
	rc4_crypt(&ctx, dat, dat, len);
d2123 6
a2128 1
	for (i = 0; i < len; i++)
d2130 1
d2134 7
a2140 3
	/* decrypt little-endian crc32 and verify */
	rc4_crypt(&ctx, dat, dat, IEEE80211_WEP_CRCLEN);

d2153 1
a2153 1
void
d2286 1
a2286 1
	 * If there's a BPF listener, bounce a copy of
d2295 3
a2304 3
	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id, 0, 0))
		printf(WI_PRT_FMT ": wi_start: xmit failed\n", WI_PRT_ARG(sc));

d2349 1
a2349 1
void
d2366 1
a2366 1
	wi_intr_enable(sc, 0);
d2375 1
a2375 2

void
a2392 16
void
wi_detach(sc)
	struct wi_softc *sc;
{
	struct ifnet *ifp;
	ifp = &sc->sc_arpcom.ac_if;

	if (ifp->if_flags & IFF_RUNNING)
		wi_stop(sc);
	
	if (sc->wi_flags & WI_FLAGS_ATTACHED) {
		sc->wi_flags &= ~WI_FLAGS_ATTACHED;
		shutdownhook_disestablish(sc->sc_sdhook);
	}
}

d2477 1
a2477 1
		printf("\n%s: Firmware %d.%02d variant %d, ", WI_PRT_ARG(sc),
d2758 1
a2758 1
	error = suser(curproc, 0);
@


1.15.2.7
log
@Merge with the trunk
@
text
@a214 1
	sc->wi_cmd_count = 500;
a291 3
		/* older prism firmware is slow so crank the count */
		if (sc->sc_sta_firmware_ver < 10000)
			sc->wi_cmd_count = 5000;
d294 1
a294 2
			if (sc->sc_sta_firmware_ver != 10402)
				sc->wi_flags |= WI_FLAGS_HAS_HOSTAP;
a298 2
		if (sc->sc_sta_firmware_ver >= 10603)
			sc->wi_flags |= WI_FLAGS_HAS_ENH_SECURITY;
d454 1
a455 1
		CSR_WRITE_2(sc, WI_EVENT_ACK, 0xffff);
d521 1
a521 1
	u_int16_t		ftype;
d630 2
a631 2
		/* Stash frame type in host byte order for later use */
		ftype = letoh16(rx_frame.wi_frame_ctl) & WI_FCTL_FTYPE;
d654 1
a654 1
		if (ftype == WI_FTYPE_MGMT &&
d692 1
a692 1
		switch (letoh16(rx_frame.wi_status) & WI_RXSTAT_MSG_TYPE) {
d753 1
a753 1
		    rx_frame.wi_frame_ctl & htole16(WI_FCTL_WEP)) {
d930 1
a930 1
	for (i = sc->wi_cmd_count; i--; DELAY(1000)) {
d933 1
a933 6
	}
	if (i < 0) {
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf(WI_PRT_FMT ": wi_cmd_io: busy bit won't clear\n",
			    WI_PRT_ARG(sc));
		return(ETIMEDOUT);
d941 1
a941 1
	for (i = WI_TIMEOUT; i--; DELAY(WI_DELAY)) {
d951 4
d961 1
a961 5
	if (i < 0) {
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf(WI_PRT_FMT
			    ": timeout in wi_cmd 0x%04x; event status 0x%04x\n",
			    WI_PRT_ARG(sc), cmd, s);
a962 1
	}
a970 2
	int error, tries = 3;

d974 3
a976 5
	if (sc->sc_firmware_type == WI_SYMBOL) {
		if (sc->wi_flags & WI_FLAGS_INITIALIZED)
			return;
		tries = 1;
	}
d978 1
a978 5
	for (; tries--; DELAY(WI_DELAY * 1000)) {
		if ((error = wi_cmd(sc, WI_CMD_INI, 0, 0, 0)) == 0)
			break;
	}
	if (tries < 0) {
d980 2
a981 3
		return;
	}
	sc->wi_flags |= WI_FLAGS_INITIALIZED;
d1271 1
a1271 1
	for (i = WI_TIMEOUT; i--; DELAY(1))
d1363 1
a1363 1
	for (i = WI_TIMEOUT; i--; DELAY(1)) {
a1399 1
allmulti:
d1412 4
a1415 4
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
a1498 3
	case WI_RID_CNF_ENH_SECURITY:
		sc->wi_enh_security = letoh16(wreq->wi_val[0]);
		break;
a1733 1
		case WI_RID_CNF_ENH_SECURITY:
a1745 2
			    (wreq.wi_type == WI_RID_CNF_ENH_SECURITY &&
			    !(sc->wi_flags & WI_FLAGS_HAS_ENH_SECURITY)) ||
a1887 4
	/* Set Enhanced Security if supported. */
	if (sc->wi_flags & WI_FLAGS_HAS_ENH_SECURITY)
		WI_SETVAL(WI_RID_CNF_ENH_SECURITY, sc->wi_enh_security);

d2176 1
a2176 1
	int			id, hostencrypt = 0;
d2194 1
a2194 1
	tx_frame.wi_frame_ctl = htole16(WI_FTYPE_DATA | WI_STYPE_DATA);
d2224 2
a2229 11
			if (sc->wi_use_wep)
				hostencrypt = 1;
		} else if (sc->wi_ptype == WI_PORTTYPE_BSS && sc->wi_use_wep &&
		    sc->wi_crypto_algorithm != WI_CRYPTO_FIRMWARE_WEP) {
			tx_frame.wi_tx_ctl = htole16(WI_ENC_TX_MGMT); /* XXX */
			tx_frame.wi_frame_ctl |= htole16(WI_FCTL_TODS);
			bcopy((char *)&sc->sc_arpcom.ac_enaddr,
			    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
			bcopy((char *)&eh->ether_dhost,
			    (char *)&tx_frame.wi_addr3, ETHER_ADDR_LEN);
			hostencrypt = 1;
d2244 1
a2244 1
		if (hostencrypt) {
a2246 1
			tx_frame.wi_frame_ctl |= htole16(WI_FCTL_WEP);
@


1.14
log
@Fix this right this time. ugh.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.13 2001/06/25 19:33:09 drahn Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.13 2001/06/25 19:33:09 drahn Exp $";
d200 2
a201 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d330 1
a330 1
	if (ifp->if_snd.ifq_head != NULL)
d1344 1
a1344 1
	IF_DEQUEUE(&ifp->if_snd, m0);
@


1.13
log
@remove unused variable.
Cleanup as suggested by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.12 2001/06/25 18:04:22 drahn Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.12 2001/06/25 18:04:22 drahn Exp $";
d601 1
a601 1
	int			i, len, code;
d699 1
@


1.12
log
@Add the missing endian pieces to wavelan driver.
ok, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.11 2001/06/23 22:54:17 fgsch Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.11 2001/06/23 22:54:17 fgsch Exp $";
d645 1
a645 1
	if (ltv->wi_len > 1) {
a646 1
	}
a698 1
	int			i;
d772 1
a772 1
	if (ltv->wi_len > 1)  {
a773 1
	}
@


1.11
log
@Use ether_input_mbuf instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.10 2001/06/11 01:10:20 millert Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.10 2001/06/11 01:10:20 millert Exp $";
d600 1
a600 1
	u_int16_t		*ptr;
d644 4
a647 3
	ptr = &ltv->wi_val;
	for (i = 0; i < ltv->wi_len - 1; i++)
		ptr[i] = CSR_READ_2(sc, WI_DATA1);
d699 1
a699 1
	u_int16_t		*ptr;
d773 4
a776 3
	ptr = &ltv->wi_val;
	for (i = 0; i < ltv->wi_len - 1; i++)
		CSR_WRITE_2(sc, WI_DATA1, ptr[i]);
d827 1
a827 2
	int			i;
	u_int16_t		*ptr;
d832 2
a833 3
	ptr = (u_int16_t *)buf;
	for (i = 0; i < len / 2; i++)
		ptr[i] = CSR_READ_2(sc, WI_DATA1);
d857 1
a857 2
	int			i;
	u_int16_t		*ptr;
d866 2
a867 3
	ptr = (u_int16_t *)buf;
	for (i = 0; i < (len / 2); i++)
		CSR_WRITE_2(sc, WI_DATA0, ptr[i]);
@


1.10
log
@Bail out of wi_attach() if the ether addr cannot be read from the
card.  This is useful for PCI adapters where the card is not actually
present.  Also check some more wi_read_record() calls and try to
deal sanely (avoid using uninitialized data).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.9 2001/06/11 00:50:38 millert Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.9 2001/06/11 00:50:38 millert Exp $";
d435 1
a435 2
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.9
log
@For PCI attachments print the CIS strings since otherwise all we have
is info on the PCI -> PCMCIA dumb bridge and not the card itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.8 2001/06/10 05:35:59 millert Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.8 2001/06/10 05:35:59 millert Exp $";
d172 1
d181 5
a185 1
	wi_read_record(sc, (struct wi_ltv_gen *)&mac);
d234 4
a237 2
	wi_read_record(sc, &gen);
	sc->wi_channel = letoh16(gen.wi_val);
d244 2
a245 2
	wi_read_record(sc, &gen);
	sc->wi_has_wep = letoh16(gen.wi_val);
@


1.8
log
@In wi_cmd() wait for the busy bit to clear; from NetBSD (ichiro)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.7 2001/06/09 20:17:22 millert Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.7 2001/06/09 20:17:22 millert Exp $";
d152 1
a152 1
STATIC void wi_get_id		__P((struct wi_softc *));
d155 1
a155 1
int	wi_attach		__P((struct wi_softc *));
d165 1
a165 1
wi_attach(sc)
d167 1
d184 1
a184 2
	wi_get_id(sc);

d1508 1
a1508 1
wi_get_id(sc)
d1510 1
d1513 1
d1516 20
d1590 1
a1590 1
		    sc->sc_dev.dv_xname, p, ver.wi_ver[2],
d1595 2
a1596 2
		printf("\n%s: Firmware %i.%i, ", sc->sc_dev.dv_xname,
		    ver.wi_ver[2], ver.wi_ver[3]);
@


1.7
log
@Updates from NetBSD:
o Endian fixes
o Missing WI_RID_AUTH_CNTL and WI_RID_MICROWAVE_OVEN bits
o Move promisc mode setting to be before prism2 detect since
  some prism2 firmware revs need to have promisc to support WEP
  and it is useless to set promisc and then clear it again.
o Add missing clear of ifp->if_timer when IFF_OACTIVE is cleared
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.6 2001/06/09 03:45:15 millert Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.6 2001/06/09 03:45:15 millert Exp $";
d531 7
d539 2
@


1.6
log
@Print firmware version for Lucent as well as Prism2 and break into
two lines for readability.  In practice this doesn't take an extra
line on the screen.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.5 2001/06/07 18:51:59 millert Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.5 2001/06/07 18:51:59 millert Exp $";
d230 1
a230 1
	sc->wi_channel = gen.wi_val;
d238 1
a238 1
	sc->wi_has_wep = gen.wi_val;
d348 1
a348 1
	if (rx_frame.wi_status & WI_STAT_ERRSTAT) {
d368 4
a371 4
	if (rx_frame.wi_status == WI_STAT_1042 ||
	    rx_frame.wi_status == WI_STAT_TUNNEL ||
	    rx_frame.wi_status == WI_STAT_WMP_MSG) {
		if((rx_frame.wi_dat_len + WI_SNAPHDR_LEN) > MCLBYTES) {
d374 2
a375 2
			    WI_PRT_ARG(sc), rx_frame.wi_dat_len,
			    rx_frame.wi_status);
d381 1
a381 1
		    rx_frame.wi_dat_len + WI_SNAPHDR_LEN;
d398 1
a398 1
		if((rx_frame.wi_dat_len +
d402 2
a403 2
			    WI_PRT_ARG(sc), rx_frame.wi_dat_len,
			    rx_frame.wi_status);
d409 1
a409 1
		    rx_frame.wi_dat_len + sizeof(struct ether_header);
d489 1
a489 1
	int			i;
d498 1
a498 2
	if (gen.wi_type != WI_INFO_COUNTERS ||
	    gen.wi_len > (sizeof(sc->wi_stats) / 4) + 1)
d501 4
d507 1
a507 1
	for (i = 0; i < gen.wi_len - 1; i++) {
d634 2
d639 9
a647 9
			switch (ltv->wi_val) {
			case 1: oltv->wi_val = 1; break;
			case 2: oltv->wi_val = 2; break;
			case 3:	oltv->wi_val = 6; break;
			case 4: oltv->wi_val = 5; break;
			case 7: oltv->wi_val = 7; break;
			case 8: oltv->wi_val = 11; break;
			case 15: oltv->wi_val = 3; break;
			default: oltv->wi_val = 0x100 + ltv->wi_val; break;
d649 1
d653 2
a654 2
			if (ltv->wi_val & 0x01)
				oltv->wi_val = 1;
d656 1
a656 1
				oltv->wi_val = 0;
d662 7
d688 2
d692 10
a701 8
			switch (ltv->wi_val) {
			case 1: p2ltv.wi_val = 1; break;
			case 2: p2ltv.wi_val = 2; break;
			case 3:	p2ltv.wi_val = 15; break;
			case 5: p2ltv.wi_val = 4; break;
			case 6: p2ltv.wi_val = 3; break;
			case 7: p2ltv.wi_val = 7; break;
			case 11: p2ltv.wi_val = 8; break;
d704 1
d710 2
a711 2
			if (ltv->wi_val & 0x01)
				p2ltv.wi_val = 0x03;
d713 1
a713 1
				p2ltv.wi_val = 0x90;
d739 9
d975 1
a975 1
		sc->wi_ptype = wreq->wi_val[0];
d978 1
a978 1
		sc->wi_tx_rate = wreq->wi_val[0];
d981 1
a981 1
		sc->wi_max_data_len = wreq->wi_val[0];
d984 1
a984 1
		sc->wi_rts_thresh = wreq->wi_val[0];
d987 1
a987 1
		sc->wi_ap_density = wreq->wi_val[0];
d990 1
a990 1
		sc->wi_create_ibss = wreq->wi_val[0];
d993 1
a993 1
		sc->wi_channel = wreq->wi_val[0];
d1008 4
a1011 1
		sc->wi_pm_enabled = wreq->wi_val[0];
d1014 1
a1014 1
		sc->wi_max_sleep = wreq->wi_val[0];
d1026 1
a1026 1
		sc->wi_tx_key = wreq->wi_val[0];
d1137 1
a1181 1

d1253 7
d1269 4
a1272 4
			 * Prism2 Firmware version less than 0.8 variant3
			 *   If promiscuous mode disable, Prism2 chip
			 *  does not work with WEP .
			 * It is under investigation for details.
a1282 7
	/* Initialize promisc mode. */
	if (ifp->if_flags & IFF_PROMISC) {
		WI_SETVAL(WI_RID_PROMISC, 1);
	} else {
		WI_SETVAL(WI_RID_PROMISC, 0);
	}

d1287 1
a1287 1
	wi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);
d1357 2
a1358 2
		tx_frame.wi_dat_len = m0->m_pkthdr.len - WI_SNAPHDR_LEN;
		tx_frame.wi_frame_ctl = WI_FTYPE_DATA;
d1373 1
a1373 1
		tx_frame.wi_dat_len = m0->m_pkthdr.len;
d1430 1
a1430 1
	tx_frame.wi_dat_len = len - WI_SNAPHDR_LEN;
d1464 1
@


1.5
log
@Kill #define duplicates between if_wireg.h and if_wi_ieee.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.4 2001/06/07 06:04:45 millert Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.4 2001/06/07 06:04:45 millert Exp $";
a182 1
	printf(": ");
d1474 2
a1475 2
	/* getting chip identity */
	memset(&ver, 0, sizeof(ver));
d1518 8
d1527 3
a1529 10
		/* try to get prism2 firmware version */
		memset(&ver, 0, sizeof(ver));
		ver.wi_type = WI_RID_STA_IDENTITY;
		ver.wi_len = 5;
		wi_read_record(sc, (struct wi_ltv_gen *)&ver);
		ver.wi_ver[1] = letoh16(ver.wi_ver[1]);
		ver.wi_ver[2] = letoh16(ver.wi_ver[2]);
		ver.wi_ver[3] = letoh16(ver.wi_ver[3]);
		printf("%s, Firmware %i.%i variant %i, ", p, ver.wi_ver[2],
		       ver.wi_ver[3], ver.wi_ver[1]);
d1532 3
@


1.4
log
@remove extra space before ether address for Lucent wi boards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.3 2001/06/07 04:49:07 mickey Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.3 2001/06/07 04:49:07 mickey Exp $";
d897 1
a897 1
	mcast.wi_type = WI_RID_MCAST;
d1477 1
a1477 1
	ver.wi_type = WI_RID_CARDID;
d1522 1
a1522 1
		ver.wi_type = WI_RID_IDENT;
@


1.3
log
@probe prism2 chips based on the probed card id, not cis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.2 2001/06/06 18:56:24 millert Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.2 2001/06/06 18:56:24 millert Exp $";
d186 1
a186 1
	printf(" address %s", ether_sprintf(sc->arpcom.ac_enaddr));
d1528 1
a1528 1
		printf("%s, Firmware %i.%i variant %i,", p, ver.wi_ver[2],
@


1.2
log
@We now disable interrupts in the bus-specific attach routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.1 2001/05/15 02:40:35 millert Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.1 2001/05/15 02:40:35 millert Exp $";
d152 1
d183 4
a186 2
	printf(": %saddress %s", sc->sc_prism2? "Prism II, " : "",
	    ether_sprintf(sc->arpcom.ac_enaddr));
d219 2
d987 6
d994 1
a994 1
		sc->wi_use_wep = wreq->wi_val[0];
d1202 3
d1231 14
d1464 69
@


1.1
log
@Split wi(4) into bus-dependent and bus-independent bits similar to
an(4) -- no real code changes at this point.
Rename if_wavelan_ieee.h to if_wi_ieee.h while I'm at it and
create an if_wivar.h similar to NetBSD.
PCI adaptors exist that are not true PCMCIA controllers so
wi(4) @@ PCI is possible (though the code is not working yet ;-).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.30 2001/04/08 21:44:36 mickey Exp $	*/
d123 1
a123 1
	"$OpenBSD: if_wi.c,v 1.30 2001/04/08 21:44:36 mickey Exp $";
a171 4

	/* Make sure interrupts are disabled. */
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xffff);
@

