head	1.131;
access;
symbols
	OPENBSD_6_2_BASE:1.131
	OPENBSD_6_1:1.131.0.4
	OPENBSD_6_1_BASE:1.131
	OPENBSD_6_0:1.130.0.4
	OPENBSD_6_0_BASE:1.130
	OPENBSD_5_9:1.129.0.2
	OPENBSD_5_9_BASE:1.129
	OPENBSD_5_8:1.121.0.4
	OPENBSD_5_8_BASE:1.121
	OPENBSD_5_7:1.119.0.2
	OPENBSD_5_7_BASE:1.119
	OPENBSD_5_6:1.117.0.4
	OPENBSD_5_6_BASE:1.117
	OPENBSD_5_5:1.115.0.4
	OPENBSD_5_5_BASE:1.115
	OPENBSD_5_4:1.111.0.4
	OPENBSD_5_4_BASE:1.111
	OPENBSD_5_3:1.111.0.2
	OPENBSD_5_3_BASE:1.111
	OPENBSD_5_2:1.110.0.2
	OPENBSD_5_2_BASE:1.110
	OPENBSD_5_1_BASE:1.109
	OPENBSD_5_1:1.109.0.4
	OPENBSD_5_0:1.108.0.2
	OPENBSD_5_0_BASE:1.108
	OPENBSD_4_9:1.107.0.2
	OPENBSD_4_9_BASE:1.107
	OPENBSD_4_8:1.102.0.2
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.100.0.2
	OPENBSD_4_7_BASE:1.100
	OPENBSD_4_6:1.96.0.4
	OPENBSD_4_6_BASE:1.96
	OPENBSD_4_5:1.94.0.2
	OPENBSD_4_5_BASE:1.94
	OPENBSD_4_4:1.91.0.4
	OPENBSD_4_4_BASE:1.91
	OPENBSD_4_3:1.91.0.2
	OPENBSD_4_3_BASE:1.91
	OPENBSD_4_2:1.87.0.2
	OPENBSD_4_2_BASE:1.87
	OPENBSD_4_1:1.84.0.2
	OPENBSD_4_1_BASE:1.84
	OPENBSD_4_0:1.79.0.2
	OPENBSD_4_0_BASE:1.79
	OPENBSD_3_9:1.75.0.2
	OPENBSD_3_9_BASE:1.75
	OPENBSD_3_8:1.72.0.2
	OPENBSD_3_8_BASE:1.72
	OPENBSD_3_7:1.68.0.2
	OPENBSD_3_7_BASE:1.68
	OPENBSD_3_6:1.56.0.2
	OPENBSD_3_6_BASE:1.56
	SMP_SYNC_A:1.53
	SMP_SYNC_B:1.53
	OPENBSD_3_5:1.47.0.2
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	UBC_SYNC_A:1.41
	OPENBSD_3_3:1.41.0.2
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.39.0.2
	OPENBSD_3_2_BASE:1.39
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.40
	UBC:1.30.0.2
	UBC_BASE:1.30
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	SMP:1.13.0.4
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.131
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.130;
commitid	VyLWTsbepAOk7VQM;

1.130
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.129;
commitid	QHiEhS9DHyE6oiIr;

1.129
date	2015.12.03.08.29.35;	author claudio;	state Exp;
branches;
next	1.128;
commitid	gP2VIL9L72svyLHF;

1.128
date	2015.12.02.08.28.02;	author claudio;	state Exp;
branches;
next	1.127;
commitid	72n6WESl1rteYJQz;

1.127
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.126;
commitid	B0kwmVGiD5DVx4kv;

1.126
date	2015.11.24.15.43.15;	author mpi;	state Exp;
branches;
next	1.125;
commitid	4NlO6WfWlwA8ekGS;

1.125
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.124;
commitid	5DvsamK0GblTp8ww;

1.124
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.123;
commitid	eYnPulzvLjDImPCa;

1.123
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.122;
commitid	p0v5tuE1Ch6fY0Nj;

1.122
date	2015.08.29.20.55.34;	author deraadt;	state Exp;
branches;
next	1.121;
commitid	pUbB7iMiclIsR7nA;

1.121
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.120;
commitid	MVWrtktB46JRxFWT;

1.120
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.119;
commitid	p4LJxGKbi0BU2cG6;

1.119
date	2015.02.12.09.08.00;	author mpi;	state Exp;
branches;
next	1.118;
commitid	IrfXfzntAazmEJMs;

1.118
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.117;
commitid	yM2VFFhpDTeFQlve;

1.117
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.116;
commitid	TGHgrLxu6sxZoiFt;

1.116
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.115;
commitid	I19imNlAX05zJOED;

1.115
date	2013.12.28.03.34.59;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2013.11.14.12.16.01;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2013.08.07.01.06.29;	author bluhm;	state Exp;
branches;
next	1.111;

1.111
date	2012.10.10.08.22.38;	author blambert;	state Exp;
branches;
next	1.110;

1.110
date	2012.04.03.23.39.09;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2011.12.19.22.01.23;	author mpf;	state Exp;
branches;
next	1.108;

1.108
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.107;

1.107
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2010.09.06.16.01.52;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2010.08.31.17.13.46;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2010.08.31.16.29.10;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2010.08.27.18.25.47;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2010.08.06.14.11.42;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.100;

1.100
date	2009.10.15.17.54.54;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2009.08.25.11.04.23;	author sthen;	state Exp;
branches;
next	1.98;

1.98
date	2009.08.13.21.14.40;	author sthen;	state Exp;
branches;
next	1.97;

1.97
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2009.06.06.02.49.39;	author naddy;	state Exp;
branches;
next	1.95;

1.95
date	2009.06.02.16.50.20;	author jsg;	state Exp;
branches;
next	1.94;

1.94
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.93;

1.93
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.91;

1.91
date	2008.02.21.03.58.07;	author brad;	state Exp;
branches;
next	1.90;

1.90
date	2008.02.20.12.31.48;	author brad;	state Exp;
branches;
next	1.89;

1.89
date	2007.10.13.16.12.29;	author fgsch;	state Exp;
branches;
next	1.88;

1.88
date	2007.08.31.22.06.02;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2007.06.06.09.43.44;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.08.20.33.07;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2007.03.16.15.36.45;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2006.12.26.17.02.09;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2006.12.13.17.13.01;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2006.12.13.09.49.59;	author martin;	state Exp;
branches;
next	1.81;

1.81
date	2006.11.05.02.47.01;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2006.10.26.19.25.34;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2006.07.01.21.48.08;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.25.22.41.42;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2006.03.04.03.34.38;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2006.01.05.21.22.24;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2006.01.05.20.42.15;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.07.03.20.00;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2005.06.08.17.02.59;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2005.05.27.06.37.21;	author brad;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.13.00.09.59;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2005.04.24.20.41.34;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2005.02.03.14.46.42;	author hshoexer;	state Exp;
branches;
next	1.67;

1.67
date	2005.02.03.00.37.48;	author kevlo;	state Exp;
branches;
next	1.66;

1.66
date	2005.01.15.18.48.12;	author brad;	state Exp;
branches;
next	1.65;

1.65
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2005.01.14.18.14.12;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2004.12.23.19.40.21;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2004.12.22.12.02.47;	author grange;	state Exp;
branches;
next	1.61;

1.61
date	2004.12.08.22.35.13;	author pascoe;	state Exp;
branches;
next	1.60;

1.60
date	2004.11.07.01.13.48;	author dhartmei;	state Exp;
branches;
next	1.59;

1.59
date	2004.09.28.05.14.44;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2004.09.20.04.25.27;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2004.09.16.13.57.49;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2004.08.04.19.42.30;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2004.07.12.20.57.32;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.27.02.38.37;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.18.22.37.25;	author beck;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.18.21.19.35;	author beck;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2004.05.01.00.03.59;	author beck;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.26.03.00.44;	author mcbride;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.15.21.16.34;	author mcbride;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.20.14.50.22;	author deraadt;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2004.01.08.17.40.33;	author jmc;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.29.23.06.55;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.23.15.16.44;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.28.11.23.19;	author henric;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2003.02.19.04.24.39;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2002.10.17.15.12.12;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.13.15.36.22;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.13.14.19.53;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.10.15.54.03;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.10.15.50.55;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.15.22.15.09;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.17.16.24.49;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.27.22.06.52;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.25.14.55.14;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.10.15.02.05;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.09.21.12.51;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.03.23.28.49;	author chris;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.18.19.32.01;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.27.06.34.41;	author kjc;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.23.23.17.35;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.13.23.19.17;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.27.01.32.21;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.26.19.40.37;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.24.04.24.36;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.24.03.32.51;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.06.04.42.05;	author csapuntz;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.03.22.01.38.05;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.20.19.39.38;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.16.17.08.07;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.17.17.08.16;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.02.18.50.17;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.20.16.22.26;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.03.02.55.04;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.27.00.29.51;	author chris;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.27.00.00.25;	author chris;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.19.12.08;	author chris;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.26.12.48.53;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.18.18.44.26;	author jason;	state Exp;
branches;
next	;

1.13.4.1
date	2001.05.14.22.23.47;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2001.07.04.10.40.52;	author niklas;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.13.4.6;

1.13.4.6
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.13.4.7;

1.13.4.7
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.13.4.8;

1.13.4.8
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.13.4.9;

1.13.4.9
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	1.13.4.10;

1.13.4.10
date	2004.06.05.23.12.41;	author niklas;	state Exp;
branches;
next	;

1.30.2.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;

1.42.2.1
date	2004.05.14.21.29.59;	author brad;	state Exp;
branches;
next	;

1.47.2.1
date	2004.05.14.21.28.43;	author brad;	state Exp;
branches;
next	;


desc
@@


1.131
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: fxp.c,v 1.130 2016/04/13 10:49:26 mpi Exp $	*/
/*	$NetBSD: if_fxp.c,v 1.2 1997/06/05 02:01:55 thorpej Exp $	*/

/*
 * Copyright (c) 1995, David Greenman
 * All rights reserved.
 *
 * Modifications to support NetBSD:
 * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	Id: if_fxp.c,v 1.55 1998/08/04 08:53:12 dg Exp
 */

/*
 * Intel EtherExpress Pro/100B PCI Fast Ethernet driver
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>

#include <netinet/if_ether.h>

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/miivar.h>

#include <dev/ic/fxpreg.h>
#include <dev/ic/fxpvar.h>

/*
 * NOTE!  On the Alpha, we have an alignment constraint.  The
 * card DMAs the packet immediately following the RFA.  However,
 * the first thing in the packet is a 14-byte Ethernet header.
 * This means that the packet is misaligned.  To compensate,
 * we actually offset the RFA 2 bytes into the cluster.  This
 * aligns the packet after the Ethernet header at a 32-bit
 * boundary.  HOWEVER!  This means that the RFA is misaligned!
 */
#define	RFA_ALIGNMENT_FUDGE	(2 + sizeof(bus_dmamap_t *))

/*
 * Inline function to copy a 16-bit aligned 32-bit quantity.
 */
static __inline void fxp_lwcopy(volatile u_int32_t *,
	volatile u_int32_t *);

static __inline void
fxp_lwcopy(volatile u_int32_t *src, volatile u_int32_t *dst)
{
	volatile u_int16_t *a = (u_int16_t *)src;
	volatile u_int16_t *b = (u_int16_t *)dst;

	b[0] = a[0];
	b[1] = a[1];
}

/*
 * Template for default configuration parameters.
 * See struct fxp_cb_config for the bit definitions.
 * Note, cb_command is filled in later.
 */
static u_char fxp_cb_config_template[] = {
	0x0, 0x0,		/* cb_status */
	0x0, 0x0,		/* cb_command */
	0xff, 0xff, 0xff, 0xff,	/* link_addr */
	0x16,	/*  0 Byte count. */
	0x08,	/*  1 Fifo limit */
	0x00,	/*  2 Adaptive ifs */
	0x00,	/*  3 ctrl0 */
	0x00,	/*  4 rx_dma_bytecount */
	0x80,	/*  5 tx_dma_bytecount */
	0xb2,	/*  6 ctrl 1*/
	0x03,	/*  7 ctrl 2*/
	0x01,	/*  8 mediatype */
	0x00,	/*  9 void2 */
	0x26,	/* 10 ctrl3 */
	0x00,	/* 11 linear priority */
	0x60,	/* 12 interfrm_spacing */
	0x00,	/* 13 void31 */
	0xf2,	/* 14 void32 */
	0x48,	/* 15 promiscuous */
	0x00,	/* 16 void41 */
	0x40,	/* 17 void42 */
	0xf3,	/* 18 stripping */
	0x00,	/* 19 fdx_pin */
	0x3f,	/* 20 multi_ia */
	0x05	/* 21 mc_all */
};

void fxp_eeprom_shiftin(struct fxp_softc *, int, int);
void fxp_eeprom_putword(struct fxp_softc *, int, u_int16_t);
void fxp_write_eeprom(struct fxp_softc *, u_short *, int, int);
int fxp_mediachange(struct ifnet *);
void fxp_mediastatus(struct ifnet *, struct ifmediareq *);
void fxp_scb_wait(struct fxp_softc *);
void fxp_start(struct ifnet *);
int fxp_ioctl(struct ifnet *, u_long, caddr_t);
void fxp_load_ucode(struct fxp_softc *);
void fxp_watchdog(struct ifnet *);
int fxp_add_rfabuf(struct fxp_softc *, struct mbuf *);
int fxp_mdi_read(struct device *, int, int);
void fxp_mdi_write(struct device *, int, int, int);
void fxp_autosize_eeprom(struct fxp_softc *);
void fxp_statchg(struct device *);
void fxp_read_eeprom(struct fxp_softc *, u_int16_t *,
				    int, int);
void fxp_stats_update(void *);
void fxp_mc_setup(struct fxp_softc *, int);
void fxp_scb_cmd(struct fxp_softc *, u_int16_t);

/*
 * Set initial transmit threshold at 64 (512 bytes). This is
 * increased by 64 (512 bytes) at a time, to maximum of 192
 * (1536 bytes), if an underrun occurs.
 */
static int tx_threshold = 64;

/*
 * Interrupts coalescing code params
 */
int fxp_int_delay = FXP_INT_DELAY;
int fxp_bundle_max = FXP_BUNDLE_MAX;
int fxp_min_size_mask = FXP_MIN_SIZE_MASK;

/*
 * TxCB list index mask. This is used to do list wrap-around.
 */
#define FXP_TXCB_MASK	(FXP_NTXCB - 1)

/*
 * Maximum number of seconds that the receiver can be idle before we
 * assume it's dead and attempt to reset it by reprogramming the
 * multicast filter. This is part of a work-around for a bug in the
 * NIC. See fxp_stats_update().
 */
#define FXP_MAX_RX_IDLE	15

/*
 * Wait for the previous command to be accepted (but not necessarily
 * completed).
 */
void
fxp_scb_wait(struct fxp_softc *sc)
{
	int i = FXP_CMD_TMO;

	while ((CSR_READ_2(sc, FXP_CSR_SCB_COMMAND) & 0xff) && --i)
		DELAY(2);
	if (i == 0)
		printf("%s: warning: SCB timed out\n", sc->sc_dev.dv_xname);
}

void
fxp_eeprom_shiftin(struct fxp_softc *sc, int data, int length)
{
	u_int16_t reg;
	int x;

	/*
	 * Shift in data.
	 */
	for (x = 1 << (length - 1); x; x >>= 1) {
		if (data & x)
			reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;
		else
			reg = FXP_EEPROM_EECS;
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
		DELAY(1);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg | FXP_EEPROM_EESK);
		DELAY(1);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
		DELAY(1);
	}
}

void
fxp_eeprom_putword(struct fxp_softc *sc, int offset, u_int16_t data)
{
	int i;

	/*
	 * Erase/write enable.
	 */
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	fxp_eeprom_shiftin(sc, 0x4, 3);
	fxp_eeprom_shiftin(sc, 0x03 << (sc->eeprom_size - 2), sc->eeprom_size);
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(1);
	/*
	 * Shift in write opcode, address, data.
	 */
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	fxp_eeprom_shiftin(sc, FXP_EEPROM_OPC_WRITE, 3);
	fxp_eeprom_shiftin(sc, offset, sc->eeprom_size);
	fxp_eeprom_shiftin(sc, data, 16);
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(1);
	/*
	 * Wait for EEPROM to finish up.
	 */
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	DELAY(1);
	for (i = 0; i < 1000; i++) {
		if (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) & FXP_EEPROM_EEDO)
			break;
		DELAY(50);
	}
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(1);
	/*
	 * Erase/write disable.
	 */
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	fxp_eeprom_shiftin(sc, 0x4, 3);
	fxp_eeprom_shiftin(sc, 0, sc->eeprom_size);
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(1);
}

void
fxp_write_eeprom(struct fxp_softc *sc, u_short *data, int offset, int words)
{
	int i;

	for (i = 0; i < words; i++)
		fxp_eeprom_putword(sc, offset + i, data[i]);
}

/*************************************************************
 * Operating system-specific autoconfiguration glue
 *************************************************************/

struct cfdriver fxp_cd = {
	NULL, "fxp", DV_IFNET
};

int
fxp_activate(struct device *self, int act)
{
	struct fxp_softc *sc = (struct fxp_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;	
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			fxp_stop(sc, 1, 0);
		rv = config_activate_children(self, act);
		break;
	case DVACT_WAKEUP:
		if (ifp->if_flags & IFF_UP)
			fxp_wakeup(sc);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
fxp_wakeup(struct fxp_softc *sc)
{
	int s = splnet();

	/* force reload of the microcode */
	sc->sc_flags &= ~FXPF_UCODELOADED;

	fxp_init(sc);
	splx(s);
}

/*************************************************************
 * End of operating system-specific autoconfiguration glue
 *************************************************************/

/*
 * Do generic parts of attach.
 */
int
fxp_attach(struct fxp_softc *sc, const char *intrstr)
{
	struct ifnet *ifp;
	struct mbuf *m;
	bus_dmamap_t rxmap;
	u_int16_t data;
	u_int8_t enaddr[6];
	int i, err;

	/*
	 * Reset to a stable state.
	 */
	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SOFTWARE_RESET);
	DELAY(10);

	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct fxp_ctrl),
	    PAGE_SIZE, 0, &sc->sc_cb_seg, 1, &sc->sc_cb_nseg,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO))
		goto fail;
	if (bus_dmamem_map(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg,
	    sizeof(struct fxp_ctrl), (caddr_t *)&sc->sc_ctrl,
	    BUS_DMA_NOWAIT)) {
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg);
		goto fail;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct fxp_ctrl),
	    1, sizeof(struct fxp_ctrl), 0, BUS_DMA_NOWAIT,
	    &sc->tx_cb_map)) {
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_ctrl,
		    sizeof(struct fxp_ctrl));
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg);
		goto fail;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->tx_cb_map, (caddr_t)sc->sc_ctrl,
	    sizeof(struct fxp_ctrl), NULL, BUS_DMA_NOWAIT)) {
		bus_dmamap_destroy(sc->sc_dmat, sc->tx_cb_map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_ctrl,
		    sizeof(struct fxp_ctrl));
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg);
		goto fail;
	}

	for (i = 0; i < FXP_NTXCB; i++) {
		if ((err = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    FXP_NTXSEG, MCLBYTES, 0, 0, &sc->txs[i].tx_map)) != 0) {
			printf("%s: unable to create tx dma map %d, error %d\n",
			    sc->sc_dev.dv_xname, i, err);
			goto fail;
		}
		sc->txs[i].tx_mbuf = NULL;
		sc->txs[i].tx_cb = sc->sc_ctrl->tx_cb + i;
		sc->txs[i].tx_off = offsetof(struct fxp_ctrl, tx_cb[i]);
		sc->txs[i].tx_next = &sc->txs[(i + 1) & FXP_TXCB_MASK];
	}

	/*
	 * Pre-allocate some receive buffers.
	 */
	sc->sc_rxfree = 0;
	for (i = 0; i < FXP_NRFABUFS_MIN; i++) {
		if ((err = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &sc->sc_rxmaps[i])) != 0) {
			printf("%s: unable to create rx dma map %d, error %d\n",
			    sc->sc_dev.dv_xname, i, err);
			goto fail;
		}
		sc->rx_bufs++;
	}
	for (i = 0; i < FXP_NRFABUFS_MIN; i++)
		if (fxp_add_rfabuf(sc, NULL) != 0)
			goto fail;

	/*
	 * Find out how large of an SEEPROM we have.
	 */
	fxp_autosize_eeprom(sc);

	/*
	 * Get info about the primary PHY
	 */
	fxp_read_eeprom(sc, (u_int16_t *)&data, FXP_EEPROM_REG_PHY, 1);
	sc->phy_primary_addr = data & 0xff;
	sc->phy_primary_device = (data >> 8) & 0x3f;
	sc->phy_10Mbps_only = data >> 15;

	/*
	 * Only 82558 and newer cards can do this.
	 */
	if (sc->sc_revision >= FXP_REV_82558_A4) {
		sc->sc_int_delay = fxp_int_delay;
		sc->sc_bundle_max = fxp_bundle_max;
		sc->sc_min_size_mask = fxp_min_size_mask;
	}
	/*
	 * Read MAC address.
	 */
	fxp_read_eeprom(sc, (u_int16_t *)enaddr, FXP_EEPROM_REG_MAC, 3);

	ifp = &sc->sc_arpcom.ac_if;
	bcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = fxp_ioctl;
	ifp->if_start = fxp_start;
	ifp->if_watchdog = fxp_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, FXP_NTXCB - 1);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	printf(": %s, address %s\n", intrstr,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));

	if (sc->sc_flags & FXPF_DISABLE_STANDBY) {
		fxp_read_eeprom(sc, &data, FXP_EEPROM_REG_ID, 1);
		if (data & FXP_EEPROM_REG_ID_STB) {
			u_int16_t cksum;

			printf("%s: Disabling dynamic standby mode in EEPROM",
			    sc->sc_dev.dv_xname);
			data &= ~FXP_EEPROM_REG_ID_STB;
			fxp_write_eeprom(sc, &data, FXP_EEPROM_REG_ID, 1);
			printf(", New ID 0x%x", data);
			cksum = 0;
			for (i = 0; i < (1 << sc->eeprom_size) - 1; i++) {
				fxp_read_eeprom(sc, &data, i, 1);
				cksum += data;
			}
			i = (1 << sc->eeprom_size) - 1;
			cksum = 0xBABA - cksum;
			fxp_read_eeprom(sc, &data, i, 1);
			fxp_write_eeprom(sc, &cksum, i, 1);
			printf(", cksum @@ 0x%x: 0x%x -> 0x%x\n",
			    i, data, cksum);
		}
	}

	/* Receiver lock-up workaround detection. */
	fxp_read_eeprom(sc, &data, FXP_EEPROM_REG_COMPAT, 1);
	if ((data & (FXP_EEPROM_REG_COMPAT_MC10|FXP_EEPROM_REG_COMPAT_MC100))
	    != (FXP_EEPROM_REG_COMPAT_MC10|FXP_EEPROM_REG_COMPAT_MC100))
		sc->sc_flags |= FXPF_RECV_WORKAROUND;

	/*
	 * Initialize our media structures and probe the MII.
	 */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = fxp_mdi_read;
	sc->sc_mii.mii_writereg = fxp_mdi_write;
	sc->sc_mii.mii_statchg = fxp_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, fxp_mediachange,
	    fxp_mediastatus);
	mii_attach(&sc->sc_dev, &sc->sc_mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, MIIF_NOISOLATE);
	/* If no phy found, just use auto mode */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL,
		    0, NULL);
		printf("%s: no phy found, using manual mode\n",
		    sc->sc_dev.dv_xname);
	}

	if (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL, 0))
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL);
	else if (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO, 0))
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);
	else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);

	/*
	 * Attach the interface.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	/*
	 * Initialize timeout for statistics update.
	 */
	timeout_set(&sc->stats_update_to, fxp_stats_update, sc);

	return (0);

 fail:
	printf("%s: Failed to malloc memory\n", sc->sc_dev.dv_xname);
	if (sc->tx_cb_map != NULL) {
		bus_dmamap_unload(sc->sc_dmat, sc->tx_cb_map);
		bus_dmamap_destroy(sc->sc_dmat, sc->tx_cb_map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_ctrl,
		    sizeof(struct fxp_cb_tx) * FXP_NTXCB);
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg);
	}
	m = sc->rfa_headm;
	while (m != NULL) {
		rxmap = *((bus_dmamap_t *)m->m_ext.ext_buf);
		bus_dmamap_unload(sc->sc_dmat, rxmap);
		FXP_RXMAP_PUT(sc, rxmap);
		m = m_free(m);
	}
	return (ENOMEM);
}

/*
 * From NetBSD:
 *
 * Figure out EEPROM size.
 *
 * 559's can have either 64-word or 256-word EEPROMs, the 558
 * datasheet only talks about 64-word EEPROMs, and the 557 datasheet
 * talks about the existence of 16 to 256 word EEPROMs.
 *
 * The only known sizes are 64 and 256, where the 256 version is used
 * by CardBus cards to store CIS information.
 *
 * The address is shifted in msb-to-lsb, and after the last
 * address-bit the EEPROM is supposed to output a `dummy zero' bit,
 * after which follows the actual data. We try to detect this zero, by
 * probing the data-out bit in the EEPROM control register just after
 * having shifted in a bit. If the bit is zero, we assume we've
 * shifted enough address bits. The data-out should be tri-state,
 * before this, which should translate to a logical one.
 *
 * Other ways to do this would be to try to read a register with known
 * contents with a varying number of address bits, but no such
 * register seem to be available. The high bits of register 10 are 01
 * on the 558 and 559, but apparently not on the 557.
 *
 * The Linux driver computes a checksum on the EEPROM data, but the
 * value of this checksum is not very well documented.
 */
void
fxp_autosize_eeprom(struct fxp_softc *sc)
{
	u_int16_t reg;
	int x;

	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	/*
	 * Shift in read opcode.
	 */
	for (x = 3; x > 0; x--) {
		if (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {
			reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;
		} else {
			reg = FXP_EEPROM_EECS;
		}
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
		    reg | FXP_EEPROM_EESK);
		DELAY(4);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
		DELAY(4);
	}
	/*
	 * Shift in address.
	 * Wait for the dummy zero following a correct address shift.
	 */
	for (x = 1; x <= 8; x++) {
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
			FXP_EEPROM_EECS | FXP_EEPROM_EESK);
		DELAY(4);
		if ((CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) & FXP_EEPROM_EEDO) == 0)
			break;
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
		DELAY(4);
	}
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(4);
	sc->eeprom_size = x;
}

/*
 * Read from the serial EEPROM. Basically, you manually shift in
 * the read opcode (one bit at a time) and then shift in the address,
 * and then you shift out the data (all of this one bit at a time).
 * The word size is 16 bits, so you have to provide the address for
 * every 16 bits of data.
 */
void
fxp_read_eeprom(struct fxp_softc *sc, u_short *data, int offset,
    int words)
{
	u_int16_t reg;
	int i, x;

	for (i = 0; i < words; i++) {
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
		/*
		 * Shift in read opcode.
		 */
		for (x = 3; x > 0; x--) {
			if (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {
				reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;
			} else {
				reg = FXP_EEPROM_EECS;
			}
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
			    reg | FXP_EEPROM_EESK);
			DELAY(4);
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			DELAY(4);
		}
		/*
		 * Shift in address.
		 */
		for (x = sc->eeprom_size; x > 0; x--) {
			if ((i + offset) & (1 << (x - 1))) {
				reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;
			} else {
				reg = FXP_EEPROM_EECS;
			}
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
			    reg | FXP_EEPROM_EESK);
			DELAY(4);
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			DELAY(4);
		}
		reg = FXP_EEPROM_EECS;
		data[i] = 0;
		/*
		 * Shift out data.
		 */
		for (x = 16; x > 0; x--) {
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
			    reg | FXP_EEPROM_EESK);
			DELAY(4);
			if (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) &
			    FXP_EEPROM_EEDO)
				data[i] |= (1 << (x - 1));
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			DELAY(4);
		}
		data[i] = letoh16(data[i]);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
		DELAY(4);
	}
}

/*
 * Start packet transmission on the interface.
 */
void
fxp_start(struct ifnet *ifp)
{
	struct fxp_softc *sc = ifp->if_softc;
	struct fxp_txsw *txs = sc->sc_cbt_prod;
	struct fxp_cb_tx *txc;
	struct mbuf *m0;
	int cnt = sc->sc_cbt_cnt, seg, error;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	while (1) {
		if (cnt >= (FXP_NTXCB - 2)) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		txs = txs->tx_next;

		m0 = ifq_dequeue(&ifp->if_snd);
		if (m0 == NULL)
			break;

		error = bus_dmamap_load_mbuf(sc->sc_dmat, txs->tx_map,
		    m0, BUS_DMA_NOWAIT);
		switch (error) {
		case 0:
			break;
		case EFBIG:
			if (m_defrag(m0, M_DONTWAIT) == 0 &&
			    bus_dmamap_load_mbuf(sc->sc_dmat, txs->tx_map,
			    m0, BUS_DMA_NOWAIT) == 0)
				break;
			/* FALLTHROUGH */
		default:
			ifp->if_oerrors++;
			m_freem(m0);
			/* try next packet */
			continue;
		}

		txs->tx_mbuf = m0;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

		FXP_MBUF_SYNC(sc, txs->tx_map, BUS_DMASYNC_PREWRITE);

		txc = txs->tx_cb;
		txc->tbd_number = txs->tx_map->dm_nsegs;
		txc->cb_status = 0;
		txc->cb_command = htole16(FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF);
		txc->tx_threshold = tx_threshold;
		for (seg = 0; seg < txs->tx_map->dm_nsegs; seg++) {
			txc->tbd[seg].tb_addr =
			    htole32(txs->tx_map->dm_segs[seg].ds_addr);
			txc->tbd[seg].tb_size =
			    htole32(txs->tx_map->dm_segs[seg].ds_len);
		}
		FXP_TXCB_SYNC(sc, txs,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		++cnt;
		sc->sc_cbt_prod = txs;
	}

	if (cnt != sc->sc_cbt_cnt) {
		/* We enqueued at least one. */
		ifp->if_timer = 5;

		txs = sc->sc_cbt_prod;
		txs = txs->tx_next;
		sc->sc_cbt_prod = txs;
		txs->tx_cb->cb_command =
		    htole16(FXP_CB_COMMAND_I | FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S);
		FXP_TXCB_SYNC(sc, txs,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		FXP_TXCB_SYNC(sc, sc->sc_cbt_prev,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		sc->sc_cbt_prev->tx_cb->cb_command &=
		    htole16(~(FXP_CB_COMMAND_S | FXP_CB_COMMAND_I));
		FXP_TXCB_SYNC(sc, sc->sc_cbt_prev,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		sc->sc_cbt_prev = txs;

		fxp_scb_wait(sc);
		fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_RESUME);

		sc->sc_cbt_cnt = cnt + 1;
	}
}

/*
 * Process interface interrupts.
 */
int
fxp_intr(void *arg)
{
	struct fxp_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	u_int16_t statack;
	bus_dmamap_t rxmap;
	int claimed = 0;
	int rnr = 0;

	/*
	 * If the interface isn't running, don't try to
	 * service the interrupt.. just ack it and bail.
	 */
	if ((ifp->if_flags & IFF_RUNNING) == 0) {
		statack = CSR_READ_2(sc, FXP_CSR_SCB_STATUS);
		if (statack) {
			claimed = 1;
			CSR_WRITE_2(sc, FXP_CSR_SCB_STATUS,
			    statack & FXP_SCB_STATACK_MASK);
		}
		return claimed;
	}

	while ((statack = CSR_READ_2(sc, FXP_CSR_SCB_STATUS)) &
	    FXP_SCB_STATACK_MASK) {
		claimed = 1;
		rnr = (statack & (FXP_SCB_STATACK_RNR | 
		                  FXP_SCB_STATACK_SWI)) ? 1 : 0;
		/*
		 * First ACK all the interrupts in this pass.
		 */
		CSR_WRITE_2(sc, FXP_CSR_SCB_STATUS,
		    statack & FXP_SCB_STATACK_MASK);

		/*
		 * Free any finished transmit mbuf chains.
		 */
		if (statack & (FXP_SCB_STATACK_CXTNO|FXP_SCB_STATACK_CNA)) {
			int txcnt = sc->sc_cbt_cnt;
			struct fxp_txsw *txs = sc->sc_cbt_cons;

			FXP_TXCB_SYNC(sc, txs,
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

			while ((txcnt > 0) &&
			   ((txs->tx_cb->cb_status & htole16(FXP_CB_STATUS_C)) ||
			   (txs->tx_cb->cb_command & htole16(FXP_CB_COMMAND_NOP)))) {
				if (txs->tx_mbuf != NULL) {
					FXP_MBUF_SYNC(sc, txs->tx_map,
					    BUS_DMASYNC_POSTWRITE);
					bus_dmamap_unload(sc->sc_dmat,
					    txs->tx_map);
					m_freem(txs->tx_mbuf);
					txs->tx_mbuf = NULL;
				}
				--txcnt;
				txs = txs->tx_next;
				FXP_TXCB_SYNC(sc, txs,
				    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
			}
			sc->sc_cbt_cnt = txcnt;
			/* Did we transmit any packets? */
			if (sc->sc_cbt_cons != txs)
				ifq_clr_oactive(&ifp->if_snd);
			ifp->if_timer = sc->sc_cbt_cnt ? 5 : 0;
			sc->sc_cbt_cons = txs;

			if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
				/*
				 * Try to start more packets transmitting.
				 */
				fxp_start(ifp);
			}
		}
		/*
		 * Process receiver interrupts. If a Receive Unit
		 * not ready (RNR) condition exists, get whatever
		 * packets we can and re-start the receiver.
		 */
		if (statack & (FXP_SCB_STATACK_FR | FXP_SCB_STATACK_RNR |
			       FXP_SCB_STATACK_SWI)) {
			struct mbuf *m;
			u_int8_t *rfap;
rcvloop:
			m = sc->rfa_headm;
			rfap = m->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;
			rxmap = *((bus_dmamap_t *)m->m_ext.ext_buf);
			bus_dmamap_sync(sc->sc_dmat, rxmap,
			    0, MCLBYTES, BUS_DMASYNC_POSTREAD |
			    BUS_DMASYNC_POSTWRITE);

			if (*(u_int16_t *)(rfap +
			    offsetof(struct fxp_rfa, rfa_status)) &
			    htole16(FXP_RFA_STATUS_C)) {
				if (*(u_int16_t *)(rfap +
				    offsetof(struct fxp_rfa, rfa_status)) &
				    htole16(FXP_RFA_STATUS_RNR))
					rnr = 1;

				/*
				 * Remove first packet from the chain.
				 */
				sc->rfa_headm = m->m_next;
				m->m_next = NULL;

				/*
				 * Add a new buffer to the receive chain.
				 * If this fails, the old buffer is recycled
				 * instead.
				 */
				if (fxp_add_rfabuf(sc, m) == 0) {
					u_int16_t total_len;

					total_len = htole16(*(u_int16_t *)(rfap +
					    offsetof(struct fxp_rfa,
					    actual_size))) &
					    (MCLBYTES - 1);
					if (total_len <
					    sizeof(struct ether_header)) {
						m_freem(m);
						goto rcvloop;
					}
					if (*(u_int16_t *)(rfap +
					    offsetof(struct fxp_rfa,
					    rfa_status)) &
					    htole16(FXP_RFA_STATUS_CRC)) {
						m_freem(m);
						goto rcvloop;
					}

					m->m_pkthdr.len = m->m_len = total_len;
					ml_enqueue(&ml, m);
				}
				goto rcvloop;
			}
		}
		if (rnr) {
			rxmap = *((bus_dmamap_t *)
			    sc->rfa_headm->m_ext.ext_buf);
			fxp_scb_wait(sc);
			CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
				    rxmap->dm_segs[0].ds_addr +
				    RFA_ALIGNMENT_FUDGE);
			fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);

		}
	}

	if_input(ifp, &ml);

	return (claimed);
}

/*
 * Update packet in/out/collision statistics. The i82557 doesn't
 * allow you to access these counters without doing a fairly
 * expensive DMA to get _all_ of the statistics it maintains, so
 * we do this operation here only once per second. The statistics
 * counters in the kernel are updated from the previous dump-stats
 * DMA and then a new dump-stats DMA is started. The on-chip
 * counters are zeroed when the DMA completes. If we can't start
 * the DMA immediately, we don't wait - we just prepare to read
 * them again next time.
 */
void
fxp_stats_update(void *arg)
{
	struct fxp_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct fxp_stats *sp = &sc->sc_ctrl->stats;
	int s;

	FXP_STATS_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	ifp->if_collisions += letoh32(sp->tx_total_collisions);
	if (sp->rx_good) {
		sc->rx_idle_secs = 0;
	} else if (sc->sc_flags & FXPF_RECV_WORKAROUND)
		sc->rx_idle_secs++;
	ifp->if_ierrors +=
	    letoh32(sp->rx_crc_errors) +
	    letoh32(sp->rx_alignment_errors) +
	    letoh32(sp->rx_rnr_errors) +
	    letoh32(sp->rx_overrun_errors);
	/*
	 * If any transmit underruns occurred, bump up the transmit
	 * threshold by another 512 bytes (64 * 8).
	 */
	if (sp->tx_underruns) {
		ifp->if_oerrors += letoh32(sp->tx_underruns);
		if (tx_threshold < 192)
			tx_threshold += 64;
	}
	s = splnet();
	/*
	 * If we haven't received any packets in FXP_MAX_RX_IDLE seconds,
	 * then assume the receiver has locked up and attempt to clear
	 * the condition by reprogramming the multicast filter. This is
	 * a work-around for a bug in the 82557 where the receiver locks
	 * up if it gets certain types of garbage in the synchronization
	 * bits prior to the packet header. This bug is supposed to only
	 * occur in 10Mbps mode, but has been seen to occur in 100Mbps
	 * mode as well (perhaps due to a 10/100 speed transition).
	 */
	if (sc->rx_idle_secs > FXP_MAX_RX_IDLE) {
		sc->rx_idle_secs = 0;
		fxp_init(sc);
		splx(s);
		return;
	}
	/*
	 * If there is no pending command, start another stats
	 * dump. Otherwise punt for now.
	 */
	FXP_STATS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	if (!(CSR_READ_2(sc, FXP_CSR_SCB_COMMAND) & 0xff)) {
		/*
		 * Start another stats dump.
		 */
		fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_DUMPRESET);
	} else {
		/*
		 * A previous command is still waiting to be accepted.
		 * Just zero our copy of the stats and wait for the
		 * next timer event to update them.
		 */
		sp->tx_good = 0;
		sp->tx_underruns = 0;
		sp->tx_total_collisions = 0;

		sp->rx_good = 0;
		sp->rx_crc_errors = 0;
		sp->rx_alignment_errors = 0;
		sp->rx_rnr_errors = 0;
		sp->rx_overrun_errors = 0;
	}

	/* Tick the MII clock. */
	mii_tick(&sc->sc_mii);

	splx(s);
	/*
	 * Schedule another timeout one second from now.
	 */
	timeout_add_sec(&sc->stats_update_to, 1);
}

void
fxp_detach(struct fxp_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Get rid of our timeouts and mbufs */
	fxp_stop(sc, 1, 1);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

#ifndef SMALL_KERNEL
	if (sc->sc_ucodebuf)
		free(sc->sc_ucodebuf, M_DEVBUF, sc->sc_ucodelen);
#endif
}

/*
 * Stop the interface. Cancels the statistics updater and resets
 * the interface.
 */
void
fxp_stop(struct fxp_softc *sc, int drain, int softonly)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int i;

	/*
	 * Cancel stats updater.
	 */
	timeout_del(&sc->stats_update_to);

	/*
	 * Turn down interface (done early to avoid bad interactions
	 * between panics, and the watchdog timer)
	 */
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (!softonly)
		mii_down(&sc->sc_mii);

	/*
	 * Issue software reset.
	 */
	if (!softonly) {
		CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);
		DELAY(10);
	}

	/*
	 * Release any xmit buffers.
	 */
	for (i = 0; i < FXP_NTXCB; i++) {
		if (sc->txs[i].tx_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->txs[i].tx_map);
			m_freem(sc->txs[i].tx_mbuf);
			sc->txs[i].tx_mbuf = NULL;
		}
	}
	sc->sc_cbt_cnt = 0;

	if (drain) {
		bus_dmamap_t rxmap;
		struct mbuf *m;

		/*
		 * Free all the receive buffers then reallocate/reinitialize
		 */
		m = sc->rfa_headm;
		while (m != NULL) {
			rxmap = *((bus_dmamap_t *)m->m_ext.ext_buf);
			bus_dmamap_unload(sc->sc_dmat, rxmap);
			FXP_RXMAP_PUT(sc, rxmap);
			m = m_free(m);
			sc->rx_bufs--;
		}
		sc->rfa_headm = NULL;
		sc->rfa_tailm = NULL;
		for (i = 0; i < FXP_NRFABUFS_MIN; i++) {
			if (fxp_add_rfabuf(sc, NULL) != 0) {
				/*
				 * This "can't happen" - we're at splnet()
				 * and we just freed all the buffers we need
				 * above.
				 */
				panic("fxp_stop: no buffers!");
			}
			sc->rx_bufs++;
		}
	}
}

/*
 * Watchdog/transmission transmit timeout handler. Called when a
 * transmission is started on the interface, but no interrupt is
 * received before the timeout. This usually indicates that the
 * card has wedged for some reason.
 */
void
fxp_watchdog(struct ifnet *ifp)
{
	struct fxp_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	ifp->if_oerrors++;

	fxp_init(sc);
}

/*
 * Submit a command to the i82557.
 */
void
fxp_scb_cmd(struct fxp_softc *sc, u_int16_t cmd)
{
	CSR_WRITE_2(sc, FXP_CSR_SCB_COMMAND, cmd);
}

void
fxp_init(void *xsc)
{
	struct fxp_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct fxp_cb_config *cbp;
	struct fxp_cb_ias *cb_ias;
	struct fxp_cb_tx *txp;
	bus_dmamap_t rxmap;
	int i, prm, save_bf, lrxen, allm, bufs;

	splassert(IPL_NET);

	/*
	 * Cancel any pending I/O
	 */
	fxp_stop(sc, 0, 0);

	/*
	 * Initialize base of CBL and RFA memory. Loading with zero
	 * sets it up for regular linear addressing.
	 */
	fxp_scb_wait(sc);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_BASE);

	fxp_scb_wait(sc);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_BASE);

#ifndef SMALL_KERNEL
	fxp_load_ucode(sc);
#endif
	/* Once through to set flags */
	fxp_mc_setup(sc, 0);

        /*
	 * In order to support receiving 802.1Q VLAN frames, we have to
	 * enable "save bad frames", since they are 4 bytes larger than
	 * the normal Ethernet maximum frame length. On i82558 and later,
	 * we have a better mechanism for this.
	 */
	save_bf = 0;
	lrxen = 0;

	if (sc->sc_revision >= FXP_REV_82558_A4)
		lrxen = 1;
	else
		save_bf = 1;

	/*
	 * Initialize base of dump-stats buffer.
	 */
	fxp_scb_wait(sc);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
	    sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, stats));
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_DUMP_ADR);

	cbp = &sc->sc_ctrl->u.cfg;
	/*
	 * This bcopy is kind of disgusting, but there are a bunch of must be
	 * zero and must be one bits in this structure and this is the easiest
	 * way to initialize them all to proper values.
	 */
	bcopy(fxp_cb_config_template, (void *)&cbp->cb_status,
		sizeof(fxp_cb_config_template));

	prm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;
	allm = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;

#if 0
	cbp->cb_status =	0;
	cbp->cb_command =	FXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;
	cbp->link_addr =	0xffffffff;	/* (no) next command */
	cbp->byte_count =	22;		/* (22) bytes to config */
	cbp->rx_fifo_limit =	8;	/* rx fifo threshold (32 bytes) */
	cbp->tx_fifo_limit =	0;	/* tx fifo threshold (0 bytes) */
	cbp->adaptive_ifs =	0;	/* (no) adaptive interframe spacing */
	cbp->rx_dma_bytecount =	0;	/* (no) rx DMA max */
	cbp->tx_dma_bytecount =	0;	/* (no) tx DMA max */
	cbp->dma_bce =		0;	/* (disable) dma max counters */
	cbp->late_scb =		0;	/* (don't) defer SCB update */
	cbp->tno_int =		0;	/* (disable) tx not okay interrupt */
	cbp->ci_int =		1;	/* interrupt on CU idle */
	cbp->save_bf =		save_bf ? 1 : prm; /* save bad frames */
	cbp->disc_short_rx =	!prm;	/* discard short packets */
	cbp->underrun_retry =	1;	/* retry mode (1) on DMA underrun */
	cbp->mediatype =	!sc->phy_10Mbps_only; /* interface mode */
	cbp->nsai =		1;	/* (don't) disable source addr insert */
	cbp->preamble_length =	2;	/* (7 byte) preamble */
	cbp->loopback =		0;	/* (don't) loopback */
	cbp->linear_priority =	0;	/* (normal CSMA/CD operation) */
	cbp->linear_pri_mode =	0;	/* (wait after xmit only) */
	cbp->interfrm_spacing =	6;	/* (96 bits of) interframe spacing */
	cbp->promiscuous =	prm;	/* promiscuous mode */
	cbp->bcast_disable =	0;	/* (don't) disable broadcasts */
	cbp->crscdt =		0;	/* (CRS only) */
	cbp->stripping =	!prm;	/* truncate rx packet to byte count */
	cbp->padding =		1;	/* (do) pad short tx packets */
	cbp->rcv_crc_xfer =	0;	/* (don't) xfer CRC to host */
	cbp->long_rx =		lrxen;	/* (enable) long packets */
	cbp->force_fdx =	0;	/* (don't) force full duplex */
	cbp->fdx_pin_en =	1;	/* (enable) FDX# pin */
	cbp->multi_ia =		0;	/* (don't) accept multiple IAs */
	cbp->mc_all =		allm;
#else
	cbp->cb_command = htole16(FXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL);

	if (allm && !prm)
		cbp->mc_all |= 0x08;		/* accept all multicasts */
	else
		cbp->mc_all &= ~0x08;		/* reject all multicasts */

	if (prm) {
		cbp->promiscuous |= 1;		/* promiscuous mode */
		cbp->ctrl2 &= ~0x01;		/* save short packets */
		cbp->stripping &= ~0x01;	/* don't truncate rx packets */
	} else {
		cbp->promiscuous &= ~1;		/* no promiscuous mode */
		cbp->ctrl2 |= 0x01;		/* discard short packets */
		cbp->stripping |= 0x01;		/* truncate rx packets */
	}

	if (prm || save_bf)
		cbp->ctrl1 |= 0x80;		/* save bad frames */
	else
		cbp->ctrl1 &= ~0x80;		/* discard bad frames */

	if (sc->sc_flags & FXPF_MWI_ENABLE)
		cbp->ctrl0 |= 0x01;		/* enable PCI MWI command */

	if(!sc->phy_10Mbps_only)			/* interface mode */
		cbp->mediatype |= 0x01;
	else
		cbp->mediatype &= ~0x01;

	if(lrxen)			/* long packets */
		cbp->stripping |= 0x08;
	else
		cbp->stripping &= ~0x08;

	cbp->tx_dma_bytecount = 0; /* (no) tx DMA max, dma_dce = 0 ??? */
	cbp->ctrl1 |= 0x08;	/* ci_int = 1 */
	cbp->ctrl3 |= 0x08;	/* nsai */
	cbp->fifo_limit = 0x08; /* tx and rx fifo limit */
	cbp->fdx_pin |= 0x80;	/* Enable full duplex setting by pin */
#endif

	/*
	 * Start the config command/DMA.
	 */
	fxp_scb_wait(sc);
	FXP_CFG_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, u.cfg));
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);
	/* ...and wait for it to complete. */
	i = FXP_CMD_TMO;
	do {
		DELAY(1);
		FXP_CFG_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	} while ((cbp->cb_status & htole16(FXP_CB_STATUS_C)) == 0 && i--);

	FXP_CFG_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	if (!(cbp->cb_status & htole16(FXP_CB_STATUS_C))) {
		printf("%s: config command timeout\n", sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Now initialize the station address.
	 */
	cb_ias = &sc->sc_ctrl->u.ias;
	cb_ias->cb_status = htole16(0);
	cb_ias->cb_command = htole16(FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL);
	cb_ias->link_addr = htole32(0xffffffff);
	bcopy(sc->sc_arpcom.ac_enaddr, (void *)cb_ias->macaddr,
	    sizeof(sc->sc_arpcom.ac_enaddr));

	/*
	 * Start the IAS (Individual Address Setup) command/DMA.
	 */
	fxp_scb_wait(sc);
	FXP_IAS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, u.ias));
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);
	/* ...and wait for it to complete. */
	i = FXP_CMD_TMO;
	do {
		DELAY(1);
		FXP_IAS_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	} while (!(cb_ias->cb_status & htole16(FXP_CB_STATUS_C)) && i--);

	FXP_IAS_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	if (!(cb_ias->cb_status & htole16(FXP_CB_STATUS_C))) {
		printf("%s: IAS command timeout\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Again, this time really upload the multicast addresses */
	fxp_mc_setup(sc, 1);

	/*
	 * Initialize transmit control block (TxCB) list.
	 */
	bzero(sc->sc_ctrl->tx_cb, sizeof(struct fxp_cb_tx) * FXP_NTXCB);
	txp = sc->sc_ctrl->tx_cb;
	for (i = 0; i < FXP_NTXCB; i++) {
		txp[i].cb_command = htole16(FXP_CB_COMMAND_NOP);
		txp[i].link_addr = htole32(sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[(i + 1) & FXP_TXCB_MASK]));
		txp[i].tbd_array_addr =htole32(sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[i].tbd[0]));
	}
	/*
	 * Set the suspend flag on the first TxCB and start the control
	 * unit. It will execute the NOP and then suspend.
	 */
	sc->sc_cbt_prev = sc->sc_cbt_prod = sc->sc_cbt_cons = sc->txs;
	sc->sc_cbt_cnt = 1;
	sc->sc_ctrl->tx_cb[0].cb_command = htole16(FXP_CB_COMMAND_NOP |
	    FXP_CB_COMMAND_S | FXP_CB_COMMAND_I);
	bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map, 0,
	    sc->tx_cb_map->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	fxp_scb_wait(sc);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, tx_cb[0]));
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);

	/*
	 * Initialize receiver buffer area - RFA.
	 */
	if (ifp->if_flags & IFF_UP)
		bufs = FXP_NRFABUFS_MAX;
	else
		bufs = FXP_NRFABUFS_MIN;
	if (sc->rx_bufs > bufs) {
		while (sc->rfa_headm != NULL && sc->rx_bufs-- > bufs) {
			rxmap = *((bus_dmamap_t *)sc->rfa_headm->m_ext.ext_buf);
			bus_dmamap_unload(sc->sc_dmat, rxmap);
			FXP_RXMAP_PUT(sc, rxmap);
			sc->rfa_headm = m_free(sc->rfa_headm);
		}
	} else if (sc->rx_bufs < bufs) {
		int err, tmp_rx_bufs = sc->rx_bufs;
		for (i = sc->rx_bufs; i < bufs; i++) {
			if ((err = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
			    MCLBYTES, 0, 0, &sc->sc_rxmaps[i])) != 0) {
				printf("%s: unable to create rx dma map %d, "
				  "error %d\n", sc->sc_dev.dv_xname, i, err);
				break;
			}
			sc->rx_bufs++;
		}
		for (i = tmp_rx_bufs; i < sc->rx_bufs; i++)
			if (fxp_add_rfabuf(sc, NULL) != 0)
				break;
	}
	fxp_scb_wait(sc);

	/*
	 * Set current media.
	 */
	mii_mediachg(&sc->sc_mii);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/*
	 * Request a software generated interrupt that will be used to 
	 * (re)start the RU processing.  If we direct the chip to start
	 * receiving from the start of queue now, instead of letting the
	 * interrupt handler first process all received packets, we run
	 * the risk of having it overwrite mbuf clusters while they are
	 * being processed or after they have been returned to the pool.
	 */
	CSR_WRITE_2(sc, FXP_CSR_SCB_COMMAND,
	    CSR_READ_2(sc, FXP_CSR_SCB_COMMAND) |
	    FXP_SCB_INTRCNTL_REQUEST_SWI);

	/*
	 * Start stats updater.
	 */
	timeout_add_sec(&sc->stats_update_to, 1);
}

/*
 * Change media according to request.
 */
int
fxp_mediachange(struct ifnet *ifp)
{
	struct fxp_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->sc_mii;

	if (mii->mii_instance) {
		struct mii_softc *miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(&sc->sc_mii);
	return (0);
}

/*
 * Notify the world which media we're using.
 */
void
fxp_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct fxp_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
}

/*
 * Add a buffer to the end of the RFA buffer list.
 * Return 0 if successful, 1 for failure. A failure results in
 * adding the 'oldm' (if non-NULL) on to the end of the list -
 * tossing out its old contents and recycling it.
 * The RFA struct is stuck at the beginning of mbuf cluster and the
 * data pointer is fixed up to point just past it.
 */
int
fxp_add_rfabuf(struct fxp_softc *sc, struct mbuf *oldm)
{
	u_int32_t v;
	struct mbuf *m;
	u_int8_t *rfap;
	bus_dmamap_t rxmap = NULL;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m != NULL) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
			if (oldm == NULL)
				return 1;
			m = oldm;
			m->m_data = m->m_ext.ext_buf;
		}
		if (oldm == NULL) {
			rxmap = FXP_RXMAP_GET(sc);
			*((bus_dmamap_t *)m->m_ext.ext_buf) = rxmap;
			bus_dmamap_load(sc->sc_dmat, rxmap,
			    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
			    BUS_DMA_NOWAIT);
		} else if (oldm == m)
			rxmap = *((bus_dmamap_t *)oldm->m_ext.ext_buf);
		else {
			rxmap = *((bus_dmamap_t *)oldm->m_ext.ext_buf);
			bus_dmamap_unload(sc->sc_dmat, rxmap);
			bus_dmamap_load(sc->sc_dmat, rxmap,
			    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
			    BUS_DMA_NOWAIT);
			*mtod(m, bus_dmamap_t *) = rxmap;
		}
	} else {
		if (oldm == NULL)
			return 1;
		m = oldm;
		m->m_data = m->m_ext.ext_buf;
		rxmap = *mtod(m, bus_dmamap_t *);
	}

	/*
	 * Move the data pointer up so that the incoming data packet
	 * will be 32-bit aligned.
	 */
	m->m_data += RFA_ALIGNMENT_FUDGE;

	/*
	 * Get a pointer to the base of the mbuf cluster and move
	 * data start past it.
	 */
	rfap = m->m_data;
	m->m_data += sizeof(struct fxp_rfa);
	*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =
	    htole16(MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE);

	/*
	 * Initialize the rest of the RFA.  Note that since the RFA
	 * is misaligned, we cannot store values directly.  Instead,
	 * we use an optimized, inline copy.
	 */
	*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;
	*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =
	    htole16(FXP_RFA_CONTROL_EL);
	*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;

	v = -1;
	fxp_lwcopy(&v,
	    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));
	fxp_lwcopy(&v,
	    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));

	bus_dmamap_sync(sc->sc_dmat, rxmap, 0, MCLBYTES,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	/*
	 * If there are other buffers already on the list, attach this
	 * one to the end by fixing up the tail to point to this one.
	 */
	if (sc->rfa_headm != NULL) {
		sc->rfa_tailm->m_next = m;
		v = htole32(rxmap->dm_segs[0].ds_addr + RFA_ALIGNMENT_FUDGE);
		rfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;
		fxp_lwcopy(&v,
		    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));
		*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=
		    htole16((u_int16_t)~FXP_RFA_CONTROL_EL);
		/* XXX we only need to sync the control struct */
		bus_dmamap_sync(sc->sc_dmat,
		    *((bus_dmamap_t *)sc->rfa_tailm->m_ext.ext_buf), 0,
			MCLBYTES, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	} else
		sc->rfa_headm = m;

	sc->rfa_tailm = m;

	return (m == oldm);
}

int
fxp_mdi_read(struct device *self, int phy, int reg)
{
	struct fxp_softc *sc = (struct fxp_softc *)self;
	int count = FXP_CMD_TMO;
	int value;

	CSR_WRITE_4(sc, FXP_CSR_MDICONTROL,
	    (FXP_MDI_READ << 26) | (reg << 16) | (phy << 21));

	while (((value = CSR_READ_4(sc, FXP_CSR_MDICONTROL)) & 0x10000000) == 0
	    && count--)
		DELAY(10);

	if (count <= 0)
		printf("%s: fxp_mdi_read: timed out\n", sc->sc_dev.dv_xname);

	return (value & 0xffff);
}

void
fxp_statchg(struct device *self)
{
	/* Nothing to do. */
}

void
fxp_mdi_write(struct device *self, int phy, int reg, int value)
{
	struct fxp_softc *sc = (struct fxp_softc *)self;
	int count = FXP_CMD_TMO;

	CSR_WRITE_4(sc, FXP_CSR_MDICONTROL,
	    (FXP_MDI_WRITE << 26) | (reg << 16) | (phy << 21) |
	    (value & 0xffff));

	while((CSR_READ_4(sc, FXP_CSR_MDICONTROL) & 0x10000000) == 0 &&
	    count--)
		DELAY(10);

	if (count <= 0)
		printf("%s: fxp_mdi_write: timed out\n", sc->sc_dev.dv_xname);
}

int
fxp_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct fxp_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			fxp_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				fxp_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				fxp_stop(sc, 1, 0);
		}
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			fxp_init(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

/*
 * Program the multicast filter.
 *
 * We have an artificial restriction that the multicast setup command
 * must be the first command in the chain, so we take steps to ensure
 * this. By requiring this, it allows us to keep up the performance of
 * the pre-initialized command ring (esp. link pointers) by not actually
 * inserting the mcsetup command in the ring - i.e. its link pointer
 * points to the TxCB ring, but the mcsetup descriptor itself is not part
 * of it. We then can do 'CU_START' on the mcsetup descriptor and have it
 * lead into the regular TxCB ring when it completes.
 *
 * This function must be called at splnet.
 */
void
fxp_mc_setup(struct fxp_softc *sc, int doit)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct arpcom *ac = &sc->sc_arpcom;
	struct fxp_cb_mcs *mcsp = &sc->sc_ctrl->u.mcs;
	struct ether_multistep step;
	struct ether_multi *enm;
	int i, nmcasts = 0;

	splassert(IPL_NET);

	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0 ||
	    ac->ac_multicnt >= MAXMCADDR) {
		ifp->if_flags |= IFF_ALLMULTI;
	} else {
		ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
		while (enm != NULL) {
			bcopy(enm->enm_addrlo,
			    (void *)&mcsp->mc_addr[nmcasts][0], ETHER_ADDR_LEN);

			nmcasts++;

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	if (doit == 0)
		return;

	/* 
	 * Initialize multicast setup descriptor.
	 */
	mcsp->cb_status = htole16(0);
	mcsp->cb_command = htole16(FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_EL);
	mcsp->link_addr = htole32(-1);
	mcsp->mc_cnt = htole16(nmcasts * ETHER_ADDR_LEN);

	/*
	 * Wait until command unit is not active. This should never
	 * be the case when nothing is queued, but make sure anyway.
	 */
	for (i = FXP_CMD_TMO; (CSR_READ_2(sc, FXP_CSR_SCB_STATUS) &
	    FXP_SCB_CUS_MASK) != FXP_SCB_CUS_IDLE && i--; DELAY(1));

	if ((CSR_READ_2(sc, FXP_CSR_SCB_STATUS) &
	    FXP_SCB_CUS_MASK) != FXP_SCB_CUS_IDLE) {
		printf("%s: timeout waiting for CU ready\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Start the multicast setup command.
	 */
	fxp_scb_wait(sc);
	FXP_MCS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, u.mcs));
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);

	i = FXP_CMD_TMO;
	do {
		DELAY(1);
		FXP_MCS_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	} while (!(mcsp->cb_status & htole16(FXP_CB_STATUS_C)) && i--);

	FXP_MCS_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	if (!(mcsp->cb_status & htole16(FXP_CB_STATUS_C))) {
		printf("%s: multicast command timeout\n", sc->sc_dev.dv_xname);
		return;
	}

}

#ifndef SMALL_KERNEL
#include <dev/microcode/fxp/rcvbundl.h>
struct ucode {
	u_int16_t	revision;
	u_int16_t	int_delay_offset;
	u_int16_t	bundle_max_offset;
	u_int16_t	min_size_mask_offset;
	const char	*uname;
} const ucode_table[] = {
	{ FXP_REV_82558_A4, D101_CPUSAVER_DWORD,
	  0, 0,
	  "fxp-d101a" }, 

	{ FXP_REV_82558_B0, D101_CPUSAVER_DWORD,
	  0, 0,
	  "fxp-d101b0" },

	{ FXP_REV_82559_A0, D101M_CPUSAVER_DWORD, 
	  D101M_CPUSAVER_BUNDLE_MAX_DWORD, D101M_CPUSAVER_MIN_SIZE_DWORD,
	  "fxp-d101ma" },

	{ FXP_REV_82559S_A, D101S_CPUSAVER_DWORD,
	  D101S_CPUSAVER_BUNDLE_MAX_DWORD, D101S_CPUSAVER_MIN_SIZE_DWORD,
	  "fxp-d101s" },

	{ FXP_REV_82550, D102_B_CPUSAVER_DWORD,
	  D102_B_CPUSAVER_BUNDLE_MAX_DWORD, D102_B_CPUSAVER_MIN_SIZE_DWORD,
	  "fxp-d102" },

	{ FXP_REV_82550_C, D102_C_CPUSAVER_DWORD,
	  D102_C_CPUSAVER_BUNDLE_MAX_DWORD, D102_C_CPUSAVER_MIN_SIZE_DWORD,
	  "fxp-d102c" },

	{ FXP_REV_82551_F, D102_E_CPUSAVER_DWORD,
	  D102_E_CPUSAVER_BUNDLE_MAX_DWORD, D102_E_CPUSAVER_MIN_SIZE_DWORD,
	  "fxp-d102e" },

	{ FXP_REV_82551_10, D102_E_CPUSAVER_DWORD,
	  D102_E_CPUSAVER_BUNDLE_MAX_DWORD, D102_E_CPUSAVER_MIN_SIZE_DWORD,
	  "fxp-d102e" },
	
	{ 0, 0,
	  0, 0,
	  NULL }
};

void
fxp_load_ucode(struct fxp_softc *sc)
{
	const struct ucode *uc;
	struct fxp_cb_ucode *cbp = &sc->sc_ctrl->u.code;
	int i, error;

	if (sc->sc_flags & FXPF_NOUCODE)
		return;

	for (uc = ucode_table; uc->revision != 0; uc++)
		if (sc->sc_revision == uc->revision)
			break;
	if (uc->revision == 0) {
		sc->sc_flags |= FXPF_NOUCODE;
		return;	/* no ucode for this chip is found */
	}

	if (sc->sc_ucodebuf)
		goto reloadit;

	if (sc->sc_revision == FXP_REV_82550_C) {
		u_int16_t data;

		/*
		 * 82550C without the server extensions
		 * locks up with the microcode patch.
		 */
		fxp_read_eeprom(sc, &data, FXP_EEPROM_REG_COMPAT, 1);
		if ((data & FXP_EEPROM_REG_COMPAT_SRV) == 0) {
			sc->sc_flags |= FXPF_NOUCODE;
			return;
		}
	}

	error = loadfirmware(uc->uname, (u_char **)&sc->sc_ucodebuf,
	    &sc->sc_ucodelen);
	if (error) {
		printf("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, uc->uname);
		return;
	}

reloadit:
	if (sc->sc_flags & FXPF_UCODELOADED)
		return;

	cbp->cb_status = 0;
	cbp->cb_command = htole16(FXP_CB_COMMAND_UCODE|FXP_CB_COMMAND_EL);
	cbp->link_addr = 0xffffffff;	/* (no) next command */
	for (i = 0; i < (sc->sc_ucodelen / sizeof(u_int32_t)); i++)
		cbp->ucode[i] = sc->sc_ucodebuf[i];

	if (uc->int_delay_offset)
		*((u_int16_t *)&cbp->ucode[uc->int_delay_offset]) =
			htole16(sc->sc_int_delay + sc->sc_int_delay / 2);

	if (uc->bundle_max_offset)
		*((u_int16_t *)&cbp->ucode[uc->bundle_max_offset]) =
			htole16(sc->sc_bundle_max);

	if (uc->min_size_mask_offset)
		*((u_int16_t *)&cbp->ucode[uc->min_size_mask_offset]) =
			htole16(sc->sc_min_size_mask);
	
	FXP_UCODE_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	/*
	 * Download the ucode to the chip.
	 */
	fxp_scb_wait(sc);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc->tx_cb_map->dm_segs->ds_addr
	      + offsetof(struct fxp_ctrl, u.code));
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);

	/* ...and wait for it to complete. */
	i = FXP_CMD_TMO;
	do {
		DELAY(2);
		FXP_UCODE_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	} while (((cbp->cb_status & htole16(FXP_CB_STATUS_C)) == 0) && --i);
	if (i == 0) {
		printf("%s: timeout loading microcode\n", sc->sc_dev.dv_xname);
		return;
	}
	sc->sc_flags |= FXPF_UCODELOADED;

#ifdef DEBUG
	printf("%s: microcode loaded, int_delay: %d usec",
	    sc->sc_dev.dv_xname, sc->sc_int_delay);

	if (uc->bundle_max_offset)
		printf(", bundle_max %d\n", sc->sc_bundle_max);
	else
		printf("\n");
#endif
}
#endif /* SMALL_KERNEL */
@


1.130
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.129 2015/12/03 08:29:35 claudio Exp $	*/
a943 1
	ifp->if_opackets += letoh32(sp->tx_good);
@


1.129
log
@Rewrite the tx handler to just use ifq_dequeue and drop packets that
could not be sent either because the dma mapping failed or because
m_defrag failed. Those errors are accounted as oerrors. dlg@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.128 2015/12/02 08:28:02 claudio Exp $	*/
a432 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.128
log
@Simplify fxp tx dma handling by using m_defrag instead of rolling our own
version. Based on a very old diff from brad@@, tested by me and David Hill
OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.127 2015/11/25 03:09:58 dlg Exp $	*/
d690 1
a690 1
		m0 = ifq_deq_begin(&ifp->if_snd);
d696 7
a702 3
		if (error == EFBIG) {
			if (m_defrag(m0, M_DONTWAIT)) {
				ifq_deq_rollback(&ifp->if_snd, m0);
d704 6
a709 7
			}
			error = bus_dmamap_load_mbuf(sc->sc_dmat, txs->tx_map,
			    m0, BUS_DMA_NOWAIT);
		}
		if (error != 0) {
			ifq_deq_rollback(&ifp->if_snd, m0);
			break;
a711 1
		ifq_deq_commit(&ifp->if_snd, m0);
@


1.127
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.126 2015/11/24 15:43:15 mpi Exp $	*/
d676 2
a677 2
	struct mbuf *m0, *m = NULL;
	int cnt = sc->sc_cbt_cnt, seg;
d694 4
a697 20
		if (bus_dmamap_load_mbuf(sc->sc_dmat, txs->tx_map,
		    m0, BUS_DMA_NOWAIT) != 0) {
			MGETHDR(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				ifq_deq_rollback(&ifp->if_snd, m0);
				break;
			}
			if (m0->m_pkthdr.len > MHLEN) {
				MCLGET(m, M_DONTWAIT);
				if (!(m->m_flags & M_EXT)) {
					m_freem(m);
					ifq_deq_rollback(&ifp->if_snd, m0);
					break;
				}
			}
			m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m, caddr_t));
			m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;
			if (bus_dmamap_load_mbuf(sc->sc_dmat, txs->tx_map,
			    m, BUS_DMA_NOWAIT) != 0) {
				m_freem(m);
d701 6
a709 6
		if (m != NULL) {
			m_freem(m0);
			m0 = m;
			m = NULL;
		}

@


1.126
log
@You need <netinet/ip.h> if you use "struct ip" for hw checksum.

You never need <netinet/ip_var.h> nor <netinet/in_systm.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.125 2015/11/24 13:33:17 mpi Exp $	*/
d679 1
a679 1
	if ((ifp->if_flags & (IFF_OACTIVE | IFF_RUNNING)) != IFF_RUNNING)
d684 1
a684 1
			ifp->if_flags |= IFF_OACTIVE;
d849 1
a849 1
				ifp->if_flags &= ~IFF_OACTIVE;
d1077 2
a1078 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d1430 1
a1430 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.125
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.124 2015/11/20 03:35:22 dlg Exp $	*/
a54 1
#include <netinet/ip.h>
@


1.124
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.123 2015/10/25 12:48:46 mpi Exp $	*/
a52 1
#include <net/if_types.h>
@


1.123
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.122 2015/08/29 20:55:34 deraadt Exp $	*/
d692 1
a692 1
		IFQ_POLL(&ifp->if_snd, m0);
d699 2
a700 1
			if (m == NULL)
d702 1
d707 1
d716 1
d721 1
a721 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.122
log
@firmware sizes are known; use them for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.121 2015/06/24 09:40:54 mpi Exp $	*/
a1634 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1643 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.121
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.120 2015/03/14 03:38:47 jsg Exp $	*/
d1051 1
a1051 1
		free(sc->sc_ucodebuf, M_DEVBUF, 0);
@


1.120
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.119 2015/02/12 09:08:00 mpi Exp $	*/
a959 1
		ifp->if_ipackets += letoh32(sp->rx_good);
@


1.119
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.118 2014/12/22 02:28:51 tedu Exp $	*/
a51 1
#include <net/if_dl.h>
@


1.118
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.117 2014/07/22 13:12:11 mpi Exp $	*/
d788 1
d915 2
a916 9
					m->m_pkthdr.rcvif = ifp;
					m->m_pkthdr.len = m->m_len =
					    total_len;
#if NBPFILTER > 0
					if (ifp->if_bpf)
						bpf_mtap(ifp->if_bpf, m,
						    BPF_DIRECTION_IN);
#endif /* NBPFILTER > 0 */
					ether_input_mbuf(ifp, m);
d932 3
@


1.117
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.116 2014/07/12 18:48:17 tedu Exp $	*/
a55 1
#ifdef INET
a57 1
#endif
a1649 1
#ifdef INET
a1651 1
#endif
@


1.116
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.115 2013/12/28 03:34:59 deraadt Exp $	*/
a57 1
#include <netinet/in_systm.h>
@


1.115
log
@The few network drivers that called their children's (ie. mii PHY
drivers) activate functions at DVACT_RESUME time do not need to do
so, since their PHYs are repaired by IFF_UP.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.114 2013/12/06 21:03:03 deraadt Exp $	*/
d1059 1
a1059 1
		free(sc->sc_ucodebuf, M_DEVBUF);
@


1.114
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.113 2013/11/14 12:16:01 dlg Exp $	*/
a301 1
		rv = config_activate_children(self, act);
@


1.113
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.112 2013/08/07 01:06:29 bluhm Exp $	*/
a49 1
#include <sys/task.h>
a295 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d301 1
a301 1
	case DVACT_RESUME:
d304 4
a307 1
			task_add(systq, &sc->sc_resume_t);
d314 1
a314 1
fxp_resume(void *arg1, void *arg2)
a315 2
	struct fxp_softc *sc = arg1;

a340 2

	task_set(&sc->sc_resume_t, fxp_resume, sc, NULL);
@


1.112
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.111 2012/10/10 08:22:38 blambert Exp $	*/
d50 1
a50 1
#include <sys/workq.h>
d308 1
a308 2
			workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
			    fxp_resume, sc, NULL);
d344 2
@


1.111
log
@Avoid potential uninitialized variable access in fxp driver.

Found by haesbaert@@.

ok haesbaert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.110 2012/04/03 23:39:09 deraadt Exp $	*/
a59 1
#include <netinet/in_var.h>
@


1.110
log
@After suspend/resume, reload the firmware.  Skip firmware on
FXP_REV_82550_C with server extensions.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.109 2011/12/19 22:01:23 mpf Exp $	*/
a1839 3
	if (sc->sc_ucodebuf)
		goto reloadit;

d1850 3
@


1.109
log
@fxp_init could bail out on errors without calling slpx.
Change fxp_resume to avoid the nested splnet call inside fxp_init
altogether. Initial diff by Jan Klemkow; Tested and OK bluhm.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.108 2011/04/07 15:30:16 miod Exp $	*/
d322 4
d418 1
a418 1
	fxp_read_eeprom(sc, (u_int16_t *)&data, 6, 1);
d434 1
a434 1
	fxp_read_eeprom(sc, (u_int16_t *)enaddr, 0, 3);
d453 2
a454 2
		fxp_read_eeprom(sc, &data, 10, 1);
		if (data & 0x02) {			/* STB enable */
d459 2
a460 2
			data &= ~0x02;
			fxp_write_eeprom(sc, &data, 10, 1);
d477 3
a479 2
	fxp_read_eeprom(sc, &data, 3, 1);
	if ((data & 0x03) != 0x03)
d1062 5
a1838 2
	u_int32_t *ucode_buf;
	size_t ucode_len;
d1840 4
a1843 1
	if (sc->sc_flags & FXPF_UCODE)
d1849 2
a1850 1
	if (uc->revision == 0)
d1852 4
d1857 13
a1869 1
	error = loadfirmware(uc->uname, (u_char **)&ucode_buf, &ucode_len);
a1872 1
		sc->sc_flags |= FXPF_UCODE;
d1876 4
d1883 2
a1884 2
	for (i = 0; i < (ucode_len / sizeof(u_int32_t)); i++)
		cbp->ucode[i] = ucode_buf[i];
a1915 1
		free(ucode_buf, M_DEVBUF);
d1918 1
a1928 3

	free(ucode_buf, M_DEVBUF);
	sc->sc_flags |= FXPF_UCODE;
@


1.108
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.107 2010/09/07 16:21:42 deraadt Exp $	*/
d321 1
d323 1
d1170 1
a1170 1
	int i, prm, save_bf, lrxen, allm, s, bufs;
d1172 1
a1172 1
	s = splnet();
a1443 1
	splx(s);
d1709 2
@


1.107
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.106 2010/09/06 16:01:52 deraadt Exp $	*/
d1835 1
a1835 1
	if (uc->revision == NULL)
@


1.106
log
@initialize rv to 0 in the activate function
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.105 2010/08/31 17:13:46 deraadt Exp $	*/
a289 2
void	fxp_powerhook(int, void *);

a323 6
void
fxp_powerhook(int why, void *arg)
{
	fxp_activate(arg, why);
}

a507 7
	 * Add power hook, so that DMA is disabled prior to reboot. Not
	 * doing so could allow DMA to corrupt kernel memory during the
	 * reboot before the driver initializes.
	 */
	sc->sc_powerhook = powerhook_establish(fxp_powerhook, sc);

	/*
a1054 3

	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);
@


1.105
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.104 2010/08/31 16:29:10 deraadt Exp $	*/
d297 1
a297 1
	int rv;
@


1.104
log
@activate function should return result of config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.103 2010/08/27 18:25:47 deraadt Exp $	*/
d300 3
@


1.103
log
@Since the pci-specific activate function does nothing, move it to fxp.c.
Then it is possible for fxp_powerhook to use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.102 2010/08/06 14:11:42 deraadt Exp $	*/
d297 1
d303 1
a303 1
		config_activate_children(self, act);
d306 1
a306 1
		config_activate_children(self, act);
d312 1
a312 1
	return 0;
@


1.102
log
@ca_activate for suspend/resume; tested by andrew@@afresh1.com
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.101 2010/05/19 15:27:35 oga Exp $	*/
d50 1
a285 2
void	fxp_power(int, void *);

d290 4
a293 8
/*
 * Power handler routine. Called when the system is transitioning
 * into/out of power save modes.  The main purpose of this routine
 * is to shut off receiver DMA so it doesn't clobber kernel memory
 * at the wrong time.
 */
void
fxp_power(int why, void *arg)
d295 2
a296 3
	struct fxp_softc *sc = arg;
	struct ifnet *ifp;
	int s;
d298 8
a305 5
	s = splnet();
	if (why != PWR_RESUME)
		fxp_stop(sc, 0, 0);
	else {
		ifp = &sc->sc_arpcom.ac_if;
d307 3
a309 1
			fxp_init(sc);
d311 15
a325 1
	splx(s);
d516 1
a516 1
	sc->sc_powerhook = powerhook_establish(fxp_power, sc);
@


1.101
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.100 2009/10/15 17:54:54 deraadt Exp $	*/
a149 1
void fxp_init(void *);
a150 1
void fxp_stop(struct fxp_softc *, int, int);
@


1.100
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.99 2009/08/25 11:04:23 sthen Exp $	*/
d341 2
a342 1
	    PAGE_SIZE, 0, &sc->sc_cb_seg, 1, &sc->sc_cb_nseg, BUS_DMA_NOWAIT))
a378 1
	bzero(sc->sc_ctrl, sizeof(struct fxp_ctrl));
@


1.99
log
@Don't setup multicast when in promiscuous mode. From Brad.

This was in the diff Brad sent to tech@@ and had tested
by others and should have been in my previous commit, but I was
working from and testing an earlier version of the diff. I've
retested with multicast/promisc on my dual 82550.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.98 2009/08/13 21:14:40 sthen Exp $	*/
d152 1
a152 1
void fxp_stop(struct fxp_softc *, int);
d308 1
a308 1
		fxp_stop(sc, 0);
d1038 1
a1038 1
int
d1043 2
a1044 2
	/* Unhook our tick handler. */
	timeout_del(&sc->stats_update_to);
a1057 2

	return (0);
d1065 1
a1065 1
fxp_stop(struct fxp_softc *sc, int drain)
d1071 5
d1082 2
a1083 5
	/*
	 * Cancel stats updater.
	 */
	timeout_del(&sc->stats_update_to);
	mii_down(&sc->sc_mii);
d1088 4
a1091 2
	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);
	DELAY(10);
d1178 1
a1178 1
	fxp_stop(sc, 0);
d1665 1
a1665 1
				fxp_stop(sc, 1);
@


1.98
log
@Rewrite part of the promiscuous/multicast handling; tested by myself,
naddy@@ and several tech@@ readers. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.97 2009/08/10 20:29:54 deraadt Exp $	*/
d1268 2
a1269 1
	if (allm)
d1710 1
a1710 6
	/*
	 * Initialize multicast setup descriptor.
	 */
	mcsp->cb_status = htole16(0);
	mcsp->cb_command = htole16(FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_EL);
	mcsp->link_addr = htole32(-1);
d1712 2
a1713 1
	if (ac->ac_multirangecnt > 0 || ac->ac_multicnt >= MAXMCADDR)
d1715 1
a1715 1
	else {
d1720 1
d1730 6
@


1.97
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.96 2009/06/06 02:49:39 naddy Exp $	*/
d1702 2
a1704 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d1707 1
a1707 1
	int i, nmcasts;
d1716 3
a1718 2
	nmcasts = 0;
	if (!(ifp->if_flags & IFF_ALLMULTI)) {
a1720 13
			if (nmcasts >= MAXMCADDR) {
				ifp->if_flags |= IFF_ALLMULTI;
				nmcasts = 0;
				break;
			}

			/* Punt on ranges. */
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
			    sizeof(enm->enm_addrlo)) != 0) {
				ifp->if_flags |= IFF_ALLMULTI;
				nmcasts = 0;
				break;
			}
d1724 1
d1728 1
d1731 1
@


1.96
log
@Rewrite the SIOCSIFFLAGS ioctl handling code to clean it up a bit and
make it consistent with other drivers.  No functional change.  From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.95 2009/06/02 16:50:20 jsg Exp $	*/
a286 1
void	fxp_shutdown(void *);
a293 11
 * Device shutdown routine. Called at system shutdown after sync. The
 * main purpose of this routine is to shut off receiver DMA so that
 * kernel memory doesn't get clobbered during warmboot.
 */
void
fxp_shutdown(void *sc)
{
	fxp_stop((struct fxp_softc *) sc, 0);
}

/*
d295 3
a297 3
 * into/out of power save modes.  As with fxp_shutdown, the main
 * purpose of this routine is to shut off receiver DMA so it doesn't
 * clobber kernel memory at the wrong time.
d501 1
a501 1
	 * Add shutdown hook so that DMA is disabled prior to reboot. Not
a504 5
	sc->sc_sdhook = shutdownhook_establish(fxp_shutdown, sc);

	/*
	 * Add suspend hook, for similiar reasons..
	 */
a1055 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
d1074 1
a1074 1
	 * between panics, shutdown hooks, and the watchdog timer)
@


1.95
log
@Make fxp at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.94 2008/11/28 02:44:17 brad Exp $	*/
d1674 9
a1682 10
		/*
		 * If interface is marked up and not running, then start it.
		 * If it is marked down and running, stop it.
		 * XXX If it's up then re-initialize it. This is so flags
		 * such as IFF_PROMISC are handled.
		 */
		if (ifp->if_flags & IFF_UP)
			fxp_init(sc);
		else if (ifp->if_flags & IFF_RUNNING)
			fxp_stop(sc, 1);
@


1.94
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.93 2008/10/02 20:21:13 brad Exp $	*/
d1053 26
@


1.93
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.92 2008/09/10 14:01:22 blambert Exp $	*/
a1646 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;

a1659 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				fxp_init(sc);
			error = 0;
		}
		break;

d1667 6
@


1.92
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.91 2008/02/21 03:58:07 brad Exp $	*/
a1635 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}

d1689 1
a1689 1
		error = EINVAL;
d1691 1
@


1.91
log
@Some fxp(4) chips do not like having their status/command registers accessed
as 8-bit reads/writes even though they are 16-bit. This can cause the
respective interfaces to lock up until the system is hard rebooted. Having
the driver read/write to these registers as 16-bit entities resolves the
instability.

From mickey@@

ok krw@@ sthen@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.90 2008/02/20 12:31:48 brad Exp $	*/
d1052 1
a1052 1
	timeout_add(&sc->stats_update_to, hz);
d1440 1
a1440 1
	timeout_add(&sc->stats_update_to, hz);
@


1.90
log
@- Only clear the IFF_OACTIVE flag if packets were processed.
- Only clear the watchdog timer if there are no more packets to
process otherwise rearm the timer.

From mickey@@

Tested by krw@@, mikeb@@ and brad@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.89 2007/10/13 16:12:29 fgsch Exp $	*/
d163 1
a163 1
void fxp_scb_cmd(struct fxp_softc *, u_int8_t);
d199 1
a199 1
	int i = 10000;
d201 1
a201 1
	while (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i)
d807 1
a807 1
	u_int8_t statack;
d817 1
a817 1
		statack = CSR_READ_1(sc, FXP_CSR_SCB_STATACK);
d820 2
a821 1
			CSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, statack);
d826 2
a827 1
	while ((statack = CSR_READ_1(sc, FXP_CSR_SCB_STATACK)) != 0) {
d834 2
a835 1
		CSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, statack);
d1023 1
a1023 1
	if (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) == 0) {
d1148 1
a1148 1
fxp_scb_cmd(struct fxp_softc *sc, u_int8_t cmd)
d1150 1
a1150 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, cmd);
d1310 1
d1314 7
a1320 1
	} while ((cbp->cb_status & htole16(FXP_CB_STATUS_C)) == 0);
d1341 1
d1345 7
a1351 1
	} while (!(cb_ias->cb_status & htole16(FXP_CB_STATUS_C)));
d1432 3
a1434 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_INTRCNTL, FXP_SCB_INTRCNTL_REQUEST_SWI);
d1586 1
a1586 1
	int count = 10000;
d1612 1
a1612 1
	int count = 10000;
d1721 1
a1721 1
	int nmcasts;
d1761 9
a1769 1
	while ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) != FXP_SCB_CUS_IDLE);
d1780 1
d1784 8
a1791 1
	} while (!(mcsp->cb_status & htole16(FXP_CB_STATUS_C)));
d1895 1
a1895 1
	i = 10000;
@


1.89
log
@remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.88 2007/08/31 22:06:02 deraadt Exp $	*/
d860 5
a865 3
			sc->sc_cbt_cnt = txcnt;
			ifp->if_timer = 0;
			ifp->if_flags &= ~IFF_OACTIVE;
@


1.88
log
@new format firmware load message
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.87 2007/06/06 09:43:44 henning Exp $	*/
a454 1
			int i;
@


1.87
log
@do not include ipx headers (were not needed in the first place)
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.86 2007/05/08 20:33:07 deraadt Exp $	*/
d1824 2
a1825 2
		printf("%s: failed loadfirmware of file %s: errno %d\n",
		    sc->sc_dev.dv_xname, uc->uname, error);
@


1.86
log
@put more foo_detach() routines where they are used
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.85 2007/03/16 15:36:45 claudio Exp $	*/
a60 5
#endif

#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
@


1.85
log
@Add missing "goto fail;" in an error path of fxp_attach().
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.84 2006/12/26 17:02:09 krw Exp $	*/
a553 26
}

int
fxp_detach(struct fxp_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Unhook our tick handler. */
	timeout_del(&sc->stats_update_to);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);

	return (0);
@


1.84
log
@Don't re-initialize the card every time the IP address is changed.
Brings fxp into line with many other drivers.

From brad@@, tested by martin@@, thib@@, pyr@@, mk@@ and Johan M:son
Lindman.

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.83 2006/12/13 17:13:01 deraadt Exp $	*/
d380 1
@


1.83
log
@insufficient testing, martin, please do not be a moron
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.81 2006/11/05 02:47:01 brad Exp $	*/
d1654 2
a1655 2

		switch (ifa->ifa_addr->sa_family) {
d1657 1
a1657 2
		case AF_INET:
			fxp_init(sc);
a1658 1
			break;
a1659 4
		default:
			fxp_init(sc);
			break;
		}
@


1.82
log
@eliminate unnecessary interface resets in fxp_ioctl()
@
text
@d1654 4
a1657 1
		if (!(ifp->if_flags & IFF_RUNNING))
a1658 2
#ifdef INET
		if (ifa->ifa_addr->sa_family == AF_INET)
d1660 1
d1662 4
@


1.81
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.80 2006/10/26 19:25:34 brad Exp $	*/
d1654 2
a1655 2

		switch (ifa->ifa_addr->sa_family) {
d1657 1
a1657 2
		case AF_INET:
			fxp_init(sc);
a1658 1
			break;
a1659 4
		default:
			fxp_init(sc);
			break;
		}
@


1.80
log
@fix fxp(4) so that it will reset the link when you change the speed...  This
will fix a problem where you boot w/ the default of autoselect, but then
set the speed to 100/full, the switch will keep the autoselect/100/full
negotiation...  This will continue to work till someone resets the switch
or unplugs the cable resulting in the switch failing to autoneg and falling
back to 100/half, causing a hard to track down duplex mismatch..

From nCircle Network Security, Inc. via FreeBSD

Tested by ckuethe@@, pedro@@, brad@@, craig at creative dot com dot au
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.79 2006/07/01 21:48:08 brad Exp $	*/
d103 1
d105 1
a105 2
fxp_lwcopy(src, dst)
	volatile u_int32_t *src, *dst;
d202 1
a202 2
fxp_scb_wait(sc)
	struct fxp_softc *sc;
d305 1
a305 2
fxp_shutdown(sc)
	void *sc;
d317 1
a317 3
fxp_power(why, arg)
	int why;
	void *arg;
d342 1
a342 3
fxp_attach(sc, intrstr)
	struct fxp_softc *sc;
	const char *intrstr;
d482 1
a482 1
	if ((data & 0x03) != 0x03) {
a483 1
	}
d556 1
a556 2
fxp_detach(sc)
	struct fxp_softc *sc;
d610 1
a610 2
fxp_autosize_eeprom(sc)
	struct fxp_softc *sc;
d659 2
a660 5
fxp_read_eeprom(sc, data, offset, words)
	struct fxp_softc *sc;
	u_short *data;
	int offset;
	int words;
d724 1
a724 2
fxp_start(ifp)
	struct ifnet *ifp;
d834 1
a834 2
fxp_intr(arg)
	void *arg;
d998 1
a998 2
fxp_stats_update(arg)
	void *arg;
d1011 1
a1011 1
	} else if (sc->sc_flags & FXPF_RECV_WORKAROUND) {
a1012 1
	}
d1086 1
a1086 3
fxp_stop(sc, drain)
	struct fxp_softc *sc;
	int drain;
d1160 1
a1160 2
fxp_watchdog(ifp)
	struct ifnet *ifp;
d1174 1
a1174 3
fxp_scb_cmd(sc, cmd)
	struct fxp_softc *sc;
	u_int8_t cmd;
d1180 1
a1180 2
fxp_init(xsc)
	void *xsc;
d1457 1
a1457 2
fxp_mediachange(ifp)
	struct ifnet *ifp;
d1475 1
a1475 3
fxp_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d1493 1
a1493 3
fxp_add_rfabuf(sc, oldm)
	struct fxp_softc *sc;
	struct mbuf *oldm;
d1593 1
a1593 4
fxp_mdi_read(self, phy, reg)
	struct device *self;
	int phy;
	int reg;
d1613 1
a1613 2
fxp_statchg(self)
	struct device *self;
d1619 1
a1619 5
fxp_mdi_write(self, phy, reg, value)
	struct device *self;
	int phy;
	int reg;
	int value;
d1637 1
a1637 4
fxp_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
d1669 1
a1669 1
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
d1671 1
a1671 1
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
a1672 1
		}
d1731 1
a1731 3
fxp_mc_setup(sc, doit)
	struct fxp_softc *sc;
	int doit;
@


1.79
log
@(fxp/re)_attach_common -> (fxp/re)_attach
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.78 2006/05/22 20:35:12 krw Exp $	*/
d1483 1
d1485 5
@


1.78
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.77 2006/03/25 22:41:42 djm Exp $	*/
d346 1
a346 1
fxp_attach_common(sc, intrstr)
@


1.77
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.76 2006/03/04 03:34:38 brad Exp $	*/
d581 4
a584 2
	shutdownhook_disestablish(sc->sc_sdhook);
	powerhook_disestablish(sc->sc_powerhook);
@


1.76
log
@remove vlan header.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.75 2006/01/05 21:22:24 brad Exp $	*/
d790 1
a790 1
			bpf_mtap(ifp->if_bpf, m0);
d976 2
a977 1
						bpf_mtap(ifp->if_bpf, m);
@


1.75
log
@Disable the minimum size frame bundling when using the CPUSaver microcode.
This could cause 2 interrupts per frame if the frame size is below 128 bytes.

From Dmitry Bogdan <dsb at imcs dot dvgu dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.74 2006/01/05 20:42:15 brad Exp $	*/
a40 1
#include "vlan.h"
@


1.74
log
@load the CPUSaver 102E microcode for the 82551 Rev 10 chip.

From the Intel e100 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.73 2005/11/07 03:20:00 brad Exp $	*/
d183 1
d439 1
d1833 1
d1836 7
a1842 3
	{ FXP_REV_82558_A4, D101_CPUSAVER_DWORD, 0, "fxp-d101a" }, 

	{ FXP_REV_82558_B0, D101_CPUSAVER_DWORD, 0, "fxp-d101b0" },
d1845 2
a1846 1
	    D101M_CPUSAVER_BUNDLE_MAX_DWORD, "fxp-d101ma" },
d1849 2
a1850 1
	    D101S_CPUSAVER_BUNDLE_MAX_DWORD, "fxp-d101s" },
d1853 2
a1854 1
	    D102_B_CPUSAVER_BUNDLE_MAX_DWORD, "fxp-d102" },
d1857 2
a1858 1
	    D102_C_CPUSAVER_BUNDLE_MAX_DWORD, "fxp-d102c" },
d1861 2
a1862 1
	    D102_E_CPUSAVER_BUNDLE_MAX_DWORD, "fxp-d102e" },
d1865 2
a1866 1
	    D102_E_CPUSAVER_BUNDLE_MAX_DWORD, "fxp-d102e" },
d1868 3
a1870 1
	{ 0, 0, 0, NULL }
d1913 4
@


1.73
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.72 2005/06/08 17:02:59 henning Exp $	*/
d1850 3
@


1.72
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.71 2005/05/27 06:37:21 brad Exp $	*/
d327 1
a327 1
	s = splimp();
d1039 1
a1039 1
	s = splimp();
d1156 1
a1156 1
				 * This "can't happen" - we're at splimp()
d1208 1
a1208 1
	s = splimp();
d1672 1
a1672 1
	s = splimp();
d1757 1
a1757 1
 * This function must be called at splimp.
@


1.71
log
@- fix reception of VLAN sized frames on 82558 and up
- add support for reception of VLAN sized frames on 82557
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.70 2005/05/13 00:09:59 brad Exp $	*/
a68 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a1688 16
#endif
#ifdef NS
		case AF_NS:
		    {
			 register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			 if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
				    LLADDR(ifp->if_sadl);
			 else
				bcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),
				    ifp->if_addrlen);
			 /* Set new address. */
			 fxp_init(sc);
			 break;
		    }
@


1.70
log
@move IFQ_SET_MAXLEN to just above IFQ_SET_READY
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.69 2005/04/24 20:41:34 brad Exp $	*/
d460 1
a460 5
	/*
	 * Only 82558 and newer cards have a bit to ignore oversized frames.
	 */
	if (sc->not_82557)
		ifp->if_capabilities = IFCAP_VLAN_MTU;
d1211 1
a1211 1
	int i, prm, allm, s, bufs;
d1238 14
d1287 1
a1287 1
	cbp->save_bf =		prm;	/* save bad frames */
d1303 1
a1303 1
	cbp->long_rx =		sc->not_82557; /* (enable) long packets */
a1316 1
		cbp->ctrl1 |= 0x80;		/* save bad frames */
d1319 1
a1319 2
	}
	else {
a1320 1
		cbp->ctrl1 &= ~0x80;		/* discard bad frames */
d1325 5
d1338 1
a1338 1
	if(sc->not_82557)			/* long packets */
@


1.69
log
@add microcode to support interrupt mitigation on the
82551 F stepping chipset.

From FreeBSD via Dmitry Bogdan <dsb at imcs dot dvgu dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.68 2005/02/03 14:46:42 hshoexer Exp $	*/
d457 1
a529 5
	/*
	 * Let the system queue as many packets as we have available
	 * TX descriptors.
	 */
	IFQ_SET_MAXLEN(&ifp->if_snd, FXP_NTXCB - 1);
@


1.68
log
@unbreak by killing volatile from fxp_mdi_read().  No binary change.

ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.67 2005/02/03 00:37:48 kevlo Exp $	*/
d1862 3
@


1.67
log
@make prototype match function for fxp_mdi_read.
ok millert@@
CVS ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.66 2005/01/15 18:48:12 brad Exp $	*/
d166 1
a166 1
volatile int fxp_mdi_read(struct device *, int, int);
d1606 1
a1606 1
volatile int
@


1.66
log
@rev 1.85

Newer chips do not need the receiver lock-up workaround; detect when it
is required.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.65 2005/01/15 05:24:11 brad Exp $	*/
d166 1
a166 1
int fxp_mdi_read(struct device *, int, int);
@


1.65
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.64 2005/01/14 18:14:12 deraadt Exp $	*/
d493 6
d1035 1
a1035 1
	} else
d1037 1
@


1.64
log
@use PCI Memory Write and Invalidate; from bogdan@@eastonline.ru, ok pascoe
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.63 2004/12/23 19:40:21 deraadt Exp $	*/
d1733 2
a1734 1
			fxp_init(sc);
@


1.63
log
@change FXPF_UCODE to mean "firmware load attempted".  if the first
loadfirmware() fails because the file is missing, we do not want to
try again when the first softclock -> fxp_stats_update -> fxp_init
happens later. calling namei in that context is really bad; tested by mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.62 2004/12/22 12:02:47 grange Exp $	*/
d132 1
a132 1
	0x00,	/*  3 void1 */
d1314 3
@


1.62
log
@Use vfs firmware loader for fxp(4) interrupt coalescing microcode.
Initial work by Dmitry Bogdan <bogdan@@eastonline.ru> with a help
from me and Theo.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.61 2004/12/08 22:35:13 pascoe Exp $	*/
d1876 1
@


1.61
log
@Defer reinitialisation of the RU until after the interrupt handler has had
a chance to process all pending packets, otherwise the chip may overwrite
their mbuf clusters after we have freed them.

Eliminates a race that can cause random pool corruption when reconfiguring
an interface under heavy network load.

ok brad@@ mcbride@@ beck@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.60 2004/11/07 01:13:48 dhartmei Exp $	*/
a1828 10

const u_int32_t fxp_ucode_d101a[] = D101_A_RCVBUNDLE_UCODE;
const u_int32_t fxp_ucode_d101b0[] = D101_B0_RCVBUNDLE_UCODE;
const u_int32_t fxp_ucode_d101ma[] = D101M_B_RCVBUNDLE_UCODE;
const u_int32_t fxp_ucode_d101s[] = D101S_RCVBUNDLE_UCODE;
const u_int32_t fxp_ucode_d102[] = D102_B_RCVBUNDLE_UCODE;
const u_int32_t fxp_ucode_d102c[] = D102_C_RCVBUNDLE_UCODE;

#define UCODE(x)	sizeof(x) / sizeof(u_int32_t), x

d1833 1
a1833 2
	u_int16_t	length;
	const u_int32_t	*ucode;
d1835 9
a1843 23
	{ FXP_REV_82558_A4,
	  D101_CPUSAVER_DWORD, 0,
	  UCODE(fxp_ucode_d101a) },

	{ FXP_REV_82558_B0,
	  D101_CPUSAVER_DWORD, 0,
	  UCODE(fxp_ucode_d101b0), },

	{ FXP_REV_82559_A0,
	  D101M_CPUSAVER_DWORD, D101M_CPUSAVER_BUNDLE_MAX_DWORD,
	  UCODE(fxp_ucode_d101ma) },

	{ FXP_REV_82559S_A,
	  D101S_CPUSAVER_DWORD, D101S_CPUSAVER_BUNDLE_MAX_DWORD,
	  UCODE(fxp_ucode_d101s) },

	{ FXP_REV_82550,
	  D102_B_CPUSAVER_DWORD, D102_B_CPUSAVER_BUNDLE_MAX_DWORD,
	  UCODE(fxp_ucode_d102) },

	{ FXP_REV_82550_C,
	  D102_C_CPUSAVER_DWORD, D102_C_CPUSAVER_BUNDLE_MAX_DWORD,
	  UCODE(fxp_ucode_d102c) },
d1845 7
a1851 1
	{ 0, 0, 0, 0, NULL }
d1859 3
a1861 1
	int i;
d1866 1
a1866 1
	for (uc = ucode_table; uc->ucode != NULL; uc++)
d1869 1
a1869 1
	if (uc->ucode == NULL)
d1872 7
d1882 2
a1883 2
	for (i = 0; i < uc->length; i++)
		cbp->ucode[i] = htole32(uc->ucode[i]);
d1911 1
d1925 1
@


1.60
log
@struct ucode.length should be in number of elements (u_int32_t), not
number of bytes. reported by Pyun YongHyeon, patch from mickey@@,
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.59 2004/09/28 05:14:44 brad Exp $	*/
d876 2
a877 1
		rnr = (statack & FXP_SCB_STATACK_RNR) ? 1 : 0;
d926 2
a927 1
		if (statack & (FXP_SCB_STATACK_FR | FXP_SCB_STATACK_RNR)) {
a1210 1
	struct mbuf *m;
d1411 1
a1411 1
			rxmap = *((bus_dmamap_t *)m->m_ext.ext_buf);
d1414 1
a1414 1
			sc->rfa_headm = m_free(m);
a1431 4
	rxmap = *((bus_dmamap_t *)sc->rfa_headm->m_ext.ext_buf);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
	    rxmap->dm_segs[0].ds_addr + RFA_ALIGNMENT_FUDGE);
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);
d1440 10
@


1.59
log
@remove if NVLAN around IFCAP_VLAN_MTU
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.58 2004/09/20 04:25:27 brad Exp $	*/
d1830 1
a1830 1
#define UCODE(x)	sizeof(x), x
@


1.58
log
@remove software-based workaround for the resume issue.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.57 2004/09/16 13:57:49 markus Exp $	*/
a458 1
#if NVLAN > 0
d463 1
a463 2
		ifp->if_capabilities |= IFCAP_VLAN_MTU;
#endif
@


1.57
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.56 2004/08/04 19:42:30 mickey Exp $	*/
a1198 5
	if (cmd == FXP_SCB_COMMAND_CU_RESUME &&
	    (sc->sc_flags & FXPF_FIX_RESUME_BUG) != 0) {
		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_CB_COMMAND_NOP);
		fxp_scb_wait(sc);
	}
d1618 1
a1618 12
	struct fxp_softc *sc = (struct fxp_softc *)self;

	/*
	 * Determine whether or not we have to work-around the
	 * Resume Bug.
	 */
	if (sc->sc_flags & FXPF_HAS_RESUME_BUG) {
		if (IFM_TYPE(sc->sc_mii.mii_media_active) == IFM_10_T)
			sc->sc_flags |= FXPF_FIX_RESUME_BUG;
		else
			sc->sc_flags &= ~FXPF_FIX_RESUME_BUG;
	}
@


1.56
log
@interrupt coalescing on post 82557 chips; from freebsd via Dmitry Bogdan <dsb@@poi.dvo.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.55 2004/07/12 20:57:32 deraadt Exp $	*/
a217 1

a240 1

a293 2


a664 4




@


1.55
log
@rearrange config-time printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.54 2004/06/27 02:38:37 brad Exp $	*/
d162 1
d184 6
d219 1
a219 1
void 
d442 7
d623 1
a623 1
 * 
d870 1
a870 1
	
d931 3
a933 3
		 * Process receiver interrupts. If a no-resource (RNR)
		 * condition exists, get whatever packets we can and
		 * re-start the receiver.
d1005 1
a1005 1
			
d1133 1
a1133 1
	 * Issue software reset
d1247 3
d1311 1
a1311 1
	if (allm) 
d1340 1
a1340 1
 	cbp->ctrl1 |= 0x08;	/* ci_int = 1 */
d1845 111
@


1.54
log
@stop passing an empty enaddr around since we figure out the
MAC address in the common attach code and not the PCI/CardBus
specific portions, this was a side effect of the code being
split to support CardBus.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.53 2004/05/18 22:37:25 beck Exp $	*/
d449 11
a459 1
	
d465 3
a467 1
			printf("Disabling dynamic standby mode in EEPROM\n");
d470 1
a470 1
			printf("New EEPROM ID: 0x%x\n", data);
d480 1
a480 1
			printf("EEPROM checksum @@ 0x%x: 0x%x -> 0x%x\n",
a483 11

#if NVLAN > 0
	/*
	 * Only 82558 and newer cards have a bit to ignore oversized frames.
	 */
	if (sc->not_82557)
		ifp->if_capabilities |= IFCAP_VLAN_MTU;
#endif

	printf(": %s, address %s\n", intrstr,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));
@


1.53
log
@fix from netbsd to twiddle the fxp eeprom to disable dynamic standby mode
on cards that have issues with this creating pci errors in 10 mbps mode
tested by many, including me, nick, and pval.
ok jason@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.52 2004/05/18 21:19:35 beck Exp $	*/
d348 1
a348 1
fxp_attach_common(sc, enaddr, intrstr)
a349 1
	u_int8_t *enaddr;
d356 1
@


1.52
log
@Check for and handle interface CRC errors.
testing by me, pval, nick, others...
ok jason@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.51 2004/05/12 06:35:10 tedu Exp $	*/
d153 3
d211 80
d449 24
d654 5
d1022 1
a1022 1
	} else {
a1023 1
	}
@


1.51
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.50 2004/05/01 00:03:59 beck Exp $	*/
d850 8
@


1.50
log
@Fix nasty bug where driver would not correctly catch and handle an rnr
condition when it was due to the the recieve buffers being exhausted with
no packet transmits during that time. Symptom was that the fxp would
simply stop interrupting for the next 15 seconds until the watchdog kicked
in and reset the chip due to 15 seconds of inactivity, making the fxp very
poorly behaved when hammered on hard.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.49 2004/04/26 03:00:44 mcbride Exp $	*/
a75 1
#include <net/bpfdesc.h>
@


1.49
log
@Allocate rx buffer mbuf clusters at ifconfig time, release them when the
interface is configured down.  FXP_NRFABUFS_MIN clusters are allocated at all
times as they are used by the driver to send commands to the card.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.48 2004/04/15 21:16:34 mcbride Exp $	*/
d741 4
a744 2
	int claimed = 0, rnr;

d760 1
a760 2
		rnr = 0;

a810 1
			bus_dmamap_t rxmap;
d862 6
a867 5
			if (rnr) {
				rxmap = *((bus_dmamap_t *)
				    sc->rfa_headm->m_ext.ext_buf);
				fxp_scb_wait(sc);
				CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
d870 2
a871 2
				fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);
			}
@


1.48
log
@Fix incorrect error message (rx dma map, not tx).
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.47 2004/01/20 14:50:22 deraadt Exp $	*/
d323 1
a323 1
	 * Pre-allocate our receive buffers.
d326 1
a326 1
	for (i = 0; i < FXP_NRFABUFS; i++) {
d333 1
d335 1
a335 1
	for (i = 0; i < FXP_NRFABUFS; i++)
d1029 1
d1033 1
a1033 1
		for (i = 0; i < FXP_NRFABUFS; i++) {
d1042 1
d1090 1
d1092 1
a1092 1
	int i, prm, allm, s;
d1282 26
@


1.47
log
@when reading eeprom for the address, DELAY(4) during the operations.
added by netbsd to support cats machines, but i ran into it on the
alpha cs20's fxp0 when additional bits got set or reset randomly
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.46 2004/01/08 17:40:33 jmc Exp $	*/
d329 1
a329 1
			printf("%s: unable to create tx dma map %d, error %d\n",
@


1.47.2.1
log
@MFC:
Fix by beck@@

Fix nasty bug where driver would not correctly catch and handle an rnr
condition when it was due to the the recieve buffers being exhausted with
no packet transmits during that time. Symptom was that the fxp would
simply stop interrupting for the next 15 seconds until the watchdog kicked
in and reset the chip due to 15 seconds of inactivity, making the fxp very
poorly behaved when hammered on hard.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.47 2004/01/20 14:50:22 deraadt Exp $	*/
d740 2
a741 4
	bus_dmamap_t rxmap;
	int claimed = 0;
	int rnr = 0;
	
d757 2
a758 1
		rnr = (statack & FXP_SCB_STATACK_RNR) ? 1 : 0;
d809 1
d861 5
a865 6
		}
		if (rnr) {
			rxmap = *((bus_dmamap_t *)
				  sc->rfa_headm->m_ext.ext_buf);
			fxp_scb_wait(sc);
			CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
d868 2
a869 2
			fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);
			
@


1.46
log
@typo from Pedro Martelletto;
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.45 2003/12/29 23:06:55 brad Exp $	*/
d525 1
a525 1
		DELAY(1);
d527 1
a527 1
		DELAY(1);
d537 1
a537 1
		DELAY(1);
d541 1
a541 1
		DELAY(1);
d544 1
a544 1
	DELAY(1);
d578 1
a578 1
			DELAY(1);
d580 1
a580 1
			DELAY(1);
d594 1
a594 1
			DELAY(1);
d596 1
a596 1
			DELAY(1);
d606 1
a606 1
			DELAY(1);
d611 1
a611 1
			DELAY(1);
d615 1
a615 1
		DELAY(1);
@


1.45
log
@no vtophys(), don't need uvm_extern.h anymore.

tested on alpha, i386, macppc and sparc64.

ok millert@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.44 2003/12/23 15:16:44 mickey Exp $	*/
d416 1
a416 1
	 * doing do could allow DMA to corrupt kernel memory during the
@


1.44
log
@htole vs letoh (no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.43 2003/10/21 18:58:49 jmc Exp $	*/
a83 2

#include <uvm/uvm_extern.h>
@


1.43
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.42 2003/05/28 11:23:19 henric Exp $	*/
d615 1
a615 1
		data[i] = htole16(data[i]);
@


1.42
log
@The statistics are wrong endian.  "netstat -i" now gives sane results.

ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.41 2003/02/19 04:24:39 jason Exp $	*/
d147 1
a147 1
	0x48,	/* 15 promiscous */
d486 1
a486 1
 * talks about the existance of 16 to 256 word EEPROMs.
@


1.42.2.1
log
@MFC:
Fix by beck@@

Fix nasty bug where driver would not correctly catch and handle an rnr
condition when it was due to the the recieve buffers being exhausted with
no packet transmits during that time. Symptom was that the fxp would
simply stop interrupting for the next 15 seconds until the watchdog kicked
in and reset the chip due to 15 seconds of inactivity, making the fxp very
poorly behaved when hammered on hard.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.42 2003/05/28 11:23:19 henric Exp $	*/
d742 2
a743 4
	bus_dmamap_t rxmap;
	int claimed = 0;
	int rnr = 0;
	
d759 2
a760 1
		rnr = (statack & FXP_SCB_STATACK_RNR) ? 1 : 0;
d811 1
d863 5
a867 6
		}
		if (rnr) {
			rxmap = *((bus_dmamap_t *)
				  sc->rfa_headm->m_ext.ext_buf);
			fxp_scb_wait(sc);
			CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
d870 2
a871 2
			fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);
			
@


1.41
log
@use a nop with I bit set at the end of the tx chain.  This avoids a race
between status update and clearing the suspend bit on machines which can't
write data smaller than 32bits at a time.  Diff is the work of pefo, he
just has been slacking too much to commit =)
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.40 2002/10/17 15:12:12 drahn Exp $	*/
d898 2
a899 2
	ifp->if_opackets += sp->tx_good;
	ifp->if_collisions += sp->tx_total_collisions;
d901 1
a901 1
		ifp->if_ipackets += sp->rx_good;
d907 4
a910 4
	    sp->rx_crc_errors +
	    sp->rx_alignment_errors +
	    sp->rx_rnr_errors +
	    sp->rx_overrun_errors;
d916 1
a916 1
		ifp->if_oerrors += sp->tx_underruns;
@


1.40
log
@Bigendian support for fxp, work from pefo with cleanups, ok art@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.39 2002/06/14 21:34:59 todd Exp $	*/
d638 1
a638 1
		if (cnt >= (FXP_NTXCB - 1)) {
d709 4
a712 2
		txs->tx_cb->cb_command |=
		    htole16(FXP_CB_COMMAND_I | FXP_CB_COMMAND_S);
d718 2
a719 1
		sc->sc_cbt_prev->tx_cb->cb_command &= htole16(~FXP_CB_COMMAND_S);
d728 1
a728 1
		sc->sc_cbt_cnt = cnt;
d777 2
a778 1
			   (txs->tx_cb->cb_status & htole16(FXP_CB_STATUS_C))) {
@


1.39
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.38 2002/06/09 03:14:18 todd Exp $	*/
d126 1
d130 1
a130 1
	0x80, 0x2,		/* cb_command */
d132 22
a153 22
	0x16,	/*  0 */
	0x8,	/*  1 */
	0x0,	/*  2 */
	0x0,	/*  3 */
	0x0,	/*  4 */
	0x80,	/*  5 */
	0xb2,	/*  6 */
	0x3,	/*  7 */
	0x1,	/*  8 */
	0x0,	/*  9 */
	0x26,	/* 10 */
	0x0,	/* 11 */
	0x60,	/* 12 */
	0x0,	/* 13 */
	0xf2,	/* 14 */
	0x48,	/* 15 */
	0x0,	/* 16 */
	0x40,	/* 17 */
	0xf3,	/* 18 */
	0x0,	/* 19 */
	0x3f,	/* 20 */
	0x5	/* 21 */
d615 1
d689 1
a689 1
		txc->cb_command = FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF;
d693 1
a693 1
			    txs->tx_map->dm_segs[seg].ds_addr;
d695 1
a695 1
			    txs->tx_map->dm_segs[seg].ds_len;
d709 2
a710 1
		txs->tx_cb->cb_command |= FXP_CB_COMMAND_I | FXP_CB_COMMAND_S;
d716 1
a716 1
		sc->sc_cbt_prev->tx_cb->cb_command &= ~FXP_CB_COMMAND_S;
d774 1
a774 1
			    (txs->tx_cb->cb_status & FXP_CB_STATUS_C)) {
d819 1
a819 1
			    FXP_RFA_STATUS_C) {
d822 1
a822 1
				    FXP_RFA_STATUS_RNR)
d839 1
a839 1
					total_len = *(u_int16_t *)(rfap +
d841 1
a841 1
					    actual_size)) &
d893 1
d937 1
d1131 1
d1166 36
d1207 1
a1211 1
	FXP_CFG_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1215 1
a1215 1
	} while ((cbp->cb_status & FXP_CB_STATUS_C) == 0);
d1221 3
a1223 3
	cb_ias->cb_status = 0;
	cb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;
	cb_ias->link_addr = 0xffffffff;
d1231 1
a1235 1
	FXP_IAS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1239 1
a1239 1
	} while (!(cb_ias->cb_status & FXP_CB_STATUS_C));
d1250 5
a1254 5
		txp[i].cb_command = FXP_CB_COMMAND_NOP;
		txp[i].link_addr = sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[(i + 1) & FXP_TXCB_MASK]);
		txp[i].tbd_array_addr = sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[i].tbd[0]);
d1262 2
a1263 2
	sc->sc_ctrl->tx_cb[0].cb_command = FXP_CB_COMMAND_NOP |
	    FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;
d1390 1
a1390 1
	    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;
d1399 1
a1399 1
	    FXP_RFA_CONTROL_EL;
d1408 3
d1417 1
a1417 1
		v = rxmap->dm_segs[0].ds_addr + RFA_ALIGNMENT_FUDGE;
d1422 5
a1426 1
		    ~FXP_RFA_CONTROL_EL;
a1431 3
	bus_dmamap_sync(sc->sc_dmat, rxmap, 0, MCLBYTES,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d1625 3
a1627 3
	mcsp->cb_status = 0;
	mcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_EL;
	mcsp->link_addr = -1;
d1654 1
a1654 1
	mcsp->mc_cnt = nmcasts * ETHER_ADDR_LEN;
d1666 1
a1670 1
	FXP_MCS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1674 1
a1674 1
	} while (!(mcsp->cb_status & FXP_CB_STATUS_C));
@


1.38
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.37 2002/05/13 15:36:22 art Exp $	*/
d918 1
a918 1
	 * up if it gets certain types of garbage in the syncronization
@


1.37
log
@When collecting the completed tx descriptors, dmasync all of them
before reading, not just the first one.
jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.36 2002/05/13 14:19:53 art Exp $	*/
d252 1
a252 1
		ifp = &sc->arpcom.ac_if;
d357 2
a358 2
	ifp = &sc->arpcom.ac_if;
	bcopy(enaddr, sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);
d376 1
a376 1
	    ether_sprintf(sc->arpcom.ac_enaddr));
d457 1
a457 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d734 1
a734 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d886 1
a886 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d974 1
a974 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d1076 1
a1076 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d1182 2
a1183 2
	bcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,
	    sizeof(sc->arpcom.ac_enaddr));
d1465 1
a1465 1
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
d1478 1
a1478 1
			arp_ifinit(&sc->arpcom, ifa);
d1527 2
a1528 2
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
d1571 1
a1571 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d1585 1
a1585 1
		ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
@


1.36
log
@Don't leak memory when bus_dmamap_load_mbuf fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.35 2002/05/10 15:54:03 art Exp $	*/
d782 2
@


1.35
log
@Zap an unsued define.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.34 2002/05/10 15:50:55 art Exp $	*/
d662 2
a663 1
			    m, BUS_DMA_NOWAIT) != 0)
d665 1
@


1.34
log
@What we store on all archs just before the rfa is a pointer
to a bus_dmamap_t, not a bus_dmamap_t (just a cosmetic change, bus_dmamap_t
is a pointer on all archs, but this was confusing)
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.33 2002/03/15 22:15:09 art Exp $	*/
a179 9

/*
 * Number of completed TX commands at which point an interrupt
 * will be generated to garbage collect the attached buffers.
 * Must be at least one less than FXP_NTXCB, and should be
 * enough less so that the transmitter doesn't becomes idle
 * during the buffer rundown (which would reduce performance).
 */
#define FXP_CXINT_THRESH 120
@


1.33
log
@Missing splx
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.32 2002/03/14 01:26:54 millert Exp $	*/
d105 1
a105 1
#define	RFA_ALIGNMENT_FUDGE	(2 + sizeof(bus_dmamap_t))
@


1.32
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.31 2002/02/15 20:45:31 nordin Exp $	*/
d931 1
@


1.31
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.30 2001/11/06 19:53:18 miod Exp $	*/
d110 2
a111 2
static __inline void fxp_lwcopy __P((volatile u_int32_t *,
	volatile u_int32_t *));
d155 18
a172 18
int fxp_mediachange		__P((struct ifnet *));
void fxp_mediastatus		__P((struct ifnet *, struct ifmediareq *));
void fxp_scb_wait	__P((struct fxp_softc *));
void fxp_start			__P((struct ifnet *));
int fxp_ioctl			__P((struct ifnet *, u_long, caddr_t));
void fxp_init			__P((void *));
void fxp_stop			__P((struct fxp_softc *, int));
void fxp_watchdog		__P((struct ifnet *));
int fxp_add_rfabuf		__P((struct fxp_softc *, struct mbuf *));
int fxp_mdi_read		__P((struct device *, int, int));
void fxp_mdi_write		__P((struct device *, int, int, int));
void fxp_autosize_eeprom	__P((struct fxp_softc *));
void fxp_statchg		__P((struct device *));
void fxp_read_eeprom		__P((struct fxp_softc *, u_int16_t *,
				    int, int));
void fxp_stats_update		__P((void *));
void fxp_mc_setup		__P((struct fxp_softc *, int));
void fxp_scb_cmd		__P((struct fxp_softc *, u_int8_t));
d223 2
a224 2
void	fxp_shutdown __P((void *));
void	fxp_power __P((int, void *));
@


1.30
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.29 2001/11/05 17:25:58 art Exp $	*/
d1551 1
a1551 1
	(void) splx(s);
@


1.30.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.30 2001/11/06 19:53:18 miod Exp $	*/
d105 1
a105 1
#define	RFA_ALIGNMENT_FUDGE	(2 + sizeof(bus_dmamap_t *))
d110 2
a111 2
static __inline void fxp_lwcopy(volatile u_int32_t *,
	volatile u_int32_t *);
d155 18
a172 18
int fxp_mediachange(struct ifnet *);
void fxp_mediastatus(struct ifnet *, struct ifmediareq *);
void fxp_scb_wait(struct fxp_softc *);
void fxp_start(struct ifnet *);
int fxp_ioctl(struct ifnet *, u_long, caddr_t);
void fxp_init(void *);
void fxp_stop(struct fxp_softc *, int);
void fxp_watchdog(struct ifnet *);
int fxp_add_rfabuf(struct fxp_softc *, struct mbuf *);
int fxp_mdi_read(struct device *, int, int);
void fxp_mdi_write(struct device *, int, int, int);
void fxp_autosize_eeprom(struct fxp_softc *);
void fxp_statchg(struct device *);
void fxp_read_eeprom(struct fxp_softc *, u_int16_t *,
				    int, int);
void fxp_stats_update(void *);
void fxp_mc_setup(struct fxp_softc *, int);
void fxp_scb_cmd(struct fxp_softc *, u_int8_t);
d182 9
d223 2
a224 2
void	fxp_shutdown(void *);
void	fxp_power(int, void *);
d261 1
a261 1
		ifp = &sc->sc_arpcom.ac_if;
d366 2
a367 2
	ifp = &sc->sc_arpcom.ac_if;
	bcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
d385 1
a385 1
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));
d466 1
a466 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d671 1
a671 2
			    m, BUS_DMA_NOWAIT) != 0) {
				m_freem(m);
a672 1
			}
d741 1
a741 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a788 2
				FXP_TXCB_SYNC(sc, txs,
				    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
d891 1
a891 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a930 1
		splx(s);
d978 1
a978 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d1080 1
a1080 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d1186 2
a1187 2
	bcopy(sc->sc_arpcom.ac_enaddr, (void *)cb_ias->macaddr,
	    sizeof(sc->sc_arpcom.ac_enaddr));
d1469 1
a1469 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d1482 1
a1482 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1531 2
a1532 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
d1551 1
a1551 1
	splx(s);
d1575 1
a1575 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d1589 1
a1589 1
		ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
@


1.30.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.30.2.1 2002/06/11 03:42:18 art Exp $	*/
a125 1
 * Note, cb_command is filled in later.
d129 1
a129 1
	0x0, 0x0,		/* cb_command */
d131 22
a152 22
	0x16,	/*  0 Byte count. */
	0x08,	/*  1 Fifo limit */
	0x00,	/*  2 Adaptive ifs */
	0x00,	/*  3 void1 */
	0x00,	/*  4 rx_dma_bytecount */
	0x80,	/*  5 tx_dma_bytecount */
	0xb2,	/*  6 ctrl 1*/
	0x03,	/*  7 ctrl 2*/
	0x01,	/*  8 mediatype */
	0x00,	/*  9 void2 */
	0x26,	/* 10 ctrl3 */
	0x00,	/* 11 linear priority */
	0x60,	/* 12 interfrm_spacing */
	0x00,	/* 13 void31 */
	0xf2,	/* 14 void32 */
	0x48,	/* 15 promiscous */
	0x00,	/* 16 void41 */
	0x40,	/* 17 void42 */
	0xf3,	/* 18 stripping */
	0x00,	/* 19 fdx_pin */
	0x3f,	/* 20 multi_ia */
	0x05	/* 21 mc_all */
a613 1
		data[i] = htole16(data[i]);
d687 1
a687 1
		txc->cb_command = htole16(FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF);
d691 1
a691 1
			    htole32(txs->tx_map->dm_segs[seg].ds_addr);
d693 1
a693 1
			    htole32(txs->tx_map->dm_segs[seg].ds_len);
d707 1
a707 2
		txs->tx_cb->cb_command |=
		    htole16(FXP_CB_COMMAND_I | FXP_CB_COMMAND_S);
d713 1
a713 1
		sc->sc_cbt_prev->tx_cb->cb_command &= htole16(~FXP_CB_COMMAND_S);
d771 1
a771 1
			   (txs->tx_cb->cb_status & htole16(FXP_CB_STATUS_C))) {
d816 1
a816 1
			    htole16(FXP_RFA_STATUS_C)) {
d819 1
a819 1
				    htole16(FXP_RFA_STATUS_RNR))
d836 1
a836 1
					total_len = htole16(*(u_int16_t *)(rfap +
d838 1
a838 1
					    actual_size))) &
a889 1
	FXP_STATS_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
d918 1
a918 1
	 * up if it gets certain types of garbage in the synchronization
a932 1
	FXP_STATS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
a1125 1
#if 0
a1159 36
#else
	cbp->cb_command = htole16(FXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL);
	if (allm) 
		cbp->mc_all |= 0x08;		/* accept all multicasts */
	else
		cbp->mc_all &= ~0x08;		/* reject all multicasts */

	if (prm) {
		cbp->promiscuous |= 1;		/* promiscuous mode */
		cbp->ctrl1 |= 0x80;		/* save bad frames */
		cbp->ctrl2 &= ~0x01;		/* save short packets */
		cbp->stripping &= ~0x01;	/* don't truncate rx packets */
	}
	else {
		cbp->promiscuous &= ~1;		/* no promiscuous mode */
		cbp->ctrl1 &= ~0x80;		/* discard bad frames */
		cbp->ctrl2 |= 0x01;		/* discard short packets */
		cbp->stripping |= 0x01;		/* truncate rx packets */
	}

	if(!sc->phy_10Mbps_only)			/* interface mode */
		cbp->mediatype |= 0x01;
	else
		cbp->mediatype &= ~0x01;

	if(sc->not_82557)			/* long packets */
		cbp->stripping |= 0x08;
	else
		cbp->stripping &= ~0x08;

	cbp->tx_dma_bytecount = 0; /* (no) tx DMA max, dma_dce = 0 ??? */
 	cbp->ctrl1 |= 0x08;	/* ci_int = 1 */
	cbp->ctrl3 |= 0x08;	/* nsai */
	cbp->fifo_limit = 0x08; /* tx and rx fifo limit */
	cbp->fdx_pin |= 0x80;	/* Enable full duplex setting by pin */
#endif
a1164 1
	FXP_CFG_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1169 1
d1173 1
a1173 1
	} while ((cbp->cb_status & htole16(FXP_CB_STATUS_C)) == 0);
d1179 3
a1181 3
	cb_ias->cb_status = htole16(0);
	cb_ias->cb_command = htole16(FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL);
	cb_ias->link_addr = htole32(0xffffffff);
a1188 1
	FXP_IAS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1193 1
d1197 1
a1197 1
	} while (!(cb_ias->cb_status & htole16(FXP_CB_STATUS_C)));
d1208 5
a1212 5
		txp[i].cb_command = htole16(FXP_CB_COMMAND_NOP);
		txp[i].link_addr = htole32(sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[(i + 1) & FXP_TXCB_MASK]));
		txp[i].tbd_array_addr =htole32(sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[i].tbd[0]));
d1220 2
a1221 2
	sc->sc_ctrl->tx_cb[0].cb_command = htole16(FXP_CB_COMMAND_NOP |
	    FXP_CB_COMMAND_S | FXP_CB_COMMAND_I);
d1348 1
a1348 1
	    htole16(MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE);
d1357 1
a1357 1
	    htole16(FXP_RFA_CONTROL_EL);
a1365 3
	bus_dmamap_sync(sc->sc_dmat, rxmap, 0, MCLBYTES,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d1372 1
a1372 1
		v = htole32(rxmap->dm_segs[0].ds_addr + RFA_ALIGNMENT_FUDGE);
d1377 1
a1377 5
		    htole16((u_int16_t)~FXP_RFA_CONTROL_EL);
		/* XXX we only need to sync the control struct */
		bus_dmamap_sync(sc->sc_dmat,
		    *((bus_dmamap_t *)sc->rfa_tailm->m_ext.ext_buf), 0,
			MCLBYTES, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1383 3
d1579 3
a1581 3
	mcsp->cb_status = htole16(0);
	mcsp->cb_command = htole16(FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_EL);
	mcsp->link_addr = htole32(-1);
d1608 1
a1608 1
	mcsp->mc_cnt = htole16(nmcasts * ETHER_ADDR_LEN);
a1619 1
	FXP_MCS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1624 1
d1628 1
a1628 1
	} while (!(mcsp->cb_status & htole16(FXP_CB_STATUS_C)));
@


1.30.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d638 1
a638 1
		if (cnt >= (FXP_NTXCB - 2)) {
d709 2
a710 4
		txs = txs->tx_next;
		sc->sc_cbt_prod = txs;
		txs->tx_cb->cb_command =
		    htole16(FXP_CB_COMMAND_I | FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S);
d716 1
a716 2
		sc->sc_cbt_prev->tx_cb->cb_command &=
		    htole16(~(FXP_CB_COMMAND_S | FXP_CB_COMMAND_I));
d725 1
a725 1
		sc->sc_cbt_cnt = cnt + 1;
d774 1
a774 2
			   ((txs->tx_cb->cb_status & htole16(FXP_CB_STATUS_C)) ||
			   (txs->tx_cb->cb_command & htole16(FXP_CB_COMMAND_NOP)))) {
@


1.29
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.28 2001/09/20 17:02:31 mpech Exp $	*/
d85 1
a85 1
#include <vm/vm.h>
@


1.28
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.27 2001/09/17 16:24:49 jason Exp $	*/
d815 1
a815 1
			fxp_bus_dmamap_sync(sc->sc_dmat, rxmap,
d1226 3
a1228 2
	fxp_bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map, 0,
	    sc->tx_cb_map->dm_mapsize, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1387 1
a1387 1
	fxp_bus_dmamap_sync(sc->sc_dmat, rxmap, 0, MCLBYTES,
@


1.27
log
@Remove all of the last vestiges of vtophys (namely RFA's):
o stash bus_dmamap_t in the mbuf cluster (alignment fudge is now
  2+sizeof(bus_dmamap_t)
o borrow FXP_RXMAP_{GET|PUT} macros from NetBSD
o move a few definitions around to make it all work
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.26 2001/08/27 22:06:52 jason Exp $	*/
d909 1
a909 1
	 * If any transmit underruns occured, bump up the transmit
@


1.26
log
@get direction of read/write correct in calls to bus_dmamap_sync()
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.25 2001/08/25 14:55:14 jason Exp $	*/
a95 6
#ifdef __alpha__		/* XXX */
/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
#undef vtophys
#define	vtophys(va)	alpha_XXX_dmamap((vm_offset_t)(va))
#endif /* __alpha__ */

d105 1
a105 1
#define	RFA_ALIGNMENT_FUDGE	2
a195 6
 * Number of receive frame area buffers. These are large so chose
 * wisely.
 */
#define FXP_NRFABUFS	64

/*
d282 2
d335 1
d337 4
a340 1
		if (fxp_add_rfabuf(sc, NULL) != 0) {
d344 3
d452 7
a458 4
	/* frees entire chain */
	if (sc->rfa_headm)
		m_freem(sc->rfa_headm);

d809 1
d814 4
d862 2
d866 2
a867 1
				    vtophys((vaddr_t)sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);
d1013 3
d1019 7
a1025 2
		if (sc->rfa_headm != NULL)
			m_freem(sc->rfa_headm);
d1084 1
d1238 1
d1240 1
a1240 1
	    vtophys((vaddr_t)sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);
d1302 1
d1314 16
d1335 1
d1375 1
a1375 1
		v = vtophys((vaddr_t)rfap);
d1381 1
a1381 1
	} else {
d1383 1
a1383 1
	}
d1385 3
@


1.25
log
@deal with 5 arg form of bus_dmamap_sync() if available.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.24 2001/08/10 15:02:05 jason Exp $	*/
d689 1
a689 1
		FXP_MBUF_SYNC(sc, txs->tx_map, BUS_DMASYNC_PREREAD);
d781 1
a781 1
					    BUS_DMASYNC_POSTREAD);
@


1.24
log
@- make transmit use linked lists not indexed arrays (more like it was when I started)
- also, only bus_dmamap_unload() loaded maps in fxp_stop()
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.23 2001/08/09 21:12:51 jason Exp $	*/
d337 1
d689 1
a689 1
		bus_dmamap_sync(sc->sc_dmat, txs->tx_map, BUS_DMASYNC_PREREAD);
d702 2
d715 5
d721 3
a725 3
		bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d774 1
a774 1
			bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map,
d780 2
a781 2
					bus_dmamap_sync(sc->sc_dmat,
					    txs->tx_map, BUS_DMASYNC_POSTREAD);
d1156 1
a1156 2
	bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1159 1
a1159 2
		bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
d1180 1
a1180 2
	bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1183 1
a1183 2
		bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
d1209 2
a1210 2
	bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1588 1
a1588 3
	bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d1591 1
a1591 2
		bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
@


1.23
log
@- scb_wait() is now time based (not cpu speed based)
- rearrange multicast setup to be part of init
- convert cu operations to bus_dma(9) (still have to do RFA ops).
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.22 2001/08/03 23:28:49 chris Exp $	*/
d337 1
d635 1
a635 1
	struct fxp_txsw *txs;
d638 1
a638 1
	int prod, oprod, cnt, seg;
a642 5
	prod = sc->tx_prod;
	oprod = (prod == 0) ? oprod = FXP_NTXCB - 1 : prod - 1;
	cnt = sc->tx_cnt;
	txs = &sc->txs[prod];

d649 2
d703 1
a703 5
		if (++prod == FXP_NTXCB) {
			prod = 0;
			txs = sc->txs;
		} else
			txs++;
d706 1
a706 1
	if (cnt != sc->tx_cnt) {
d710 4
a713 3
		txc->cb_command |= FXP_CB_COMMAND_I | FXP_CB_COMMAND_S;
		sc->txs[oprod].tx_cb->cb_command &=
		    ~(FXP_CB_COMMAND_S);
d721 1
a721 2
		sc->tx_prod = prod;
		sc->tx_cnt = cnt;
d763 2
a764 3
			int txcnt = sc->tx_cnt, txcons = sc->tx_cons;
			struct fxp_txsw *txs = &sc->txs[txcons];
			struct fxp_cb_tx *txc = txs->tx_cb;
d770 1
a770 1
			    (txc->cb_status & FXP_CB_STATUS_C)) {
d780 1
a780 6
				if (++txcons == FXP_NTXCB) {
					txs = sc->txs;
					txcons = 0;
				} else
					txs++;
				txc = txs->tx_cb;
d782 2
a783 2
			sc->tx_cons = txcons;
			sc->tx_cnt = txcnt;
d988 5
a992 3
		bus_dmamap_unload(sc->sc_dmat, sc->txs[i].tx_map);
		m_freem(sc->txs[i].tx_mbuf);
		sc->txs[i].tx_mbuf = NULL;
d994 1
a994 1
	sc->tx_prod = sc->tx_cons = sc->tx_cnt = 0;
d1201 2
a1202 3
	sc->tx_cons = 0;
	sc->tx_prod = 1;
	sc->tx_cnt = 1;
@


1.22
log
@Fix logic for detecting 82558 and newer chips in pci;
This driver allows large frames for those chips so set IFCAP_VLAN_MTU
for 82558+
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.21 2001/07/18 19:32:01 mickey Exp $	*/
a160 8
/* Supported media types. */
struct fxp_supported_media {
	const int	fsm_phy;	/* PHY type */
	const int	*fsm_media;	/* the media array */
	const int	fsm_nmedia;	/* the number of supported media */
	const int	fsm_defmedia;	/* default media for this PHY */
};

d163 1
a163 1
static inline void fxp_scb_wait	__P((struct fxp_softc *));
d177 2
a178 2
void fxp_mc_setup		__P((struct fxp_softc *));
static __inline void fxp_scb_cmd __P((struct fxp_softc *, u_int8_t));
a187 7
 * Number of transmit control blocks. This determines the number
 * of transmit buffers that can be chained in the CB list.
 * This must be a power of two.
 */
#define FXP_NTXCB	128

/*
d219 1
a219 1
static inline void
d225 4
a228 1
	while (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);
a234 2
void fxp_attach __P((struct device *, struct device *, void *));

d269 1
a269 1
	s = splnet();
d295 1
a295 1
	int i;
d300 1
a300 1
	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);
d303 7
a309 3
	sc->cbl_base = malloc(sizeof(struct fxp_cb_tx) * FXP_NTXCB,
	    M_DEVBUF, M_NOWAIT);
	if (sc->cbl_base == NULL)
d311 7
a317 4
	memset(sc->cbl_base, 0, sizeof(struct fxp_cb_tx) * FXP_NTXCB);

	sc->fxp_stats = malloc(sizeof(struct fxp_stats), M_DEVBUF, M_NOWAIT);
	if (sc->fxp_stats == NULL)
d319 8
a326 1
	bzero(sc->fxp_stats, sizeof(struct fxp_stats));
d328 11
a338 3
	sc->mcsp = malloc(sizeof(struct fxp_cb_mcs), M_DEVBUF, M_NOWAIT);
	if (sc->mcsp == NULL)
		goto fail;
a377 2
	if (sc->not_82557)
		ifp->if_capabilities |= IFCAP_VLAN_MTU;
d381 2
d446 7
a452 6
	if (sc->cbl_base)
		free(sc->cbl_base, M_DEVBUF);
	if (sc->fxp_stats)
		free(sc->fxp_stats, M_DEVBUF);
	if (sc->mcsp)
		free(sc->mcsp, M_DEVBUF);
d634 4
a637 1
	struct fxp_cb_tx *txp;
d639 1
a639 6
	/*
	 * See if we need to suspend xmit until the multicast filter
	 * has been reprogrammed (which can only be done at the head
	 * of the command chain).
	 */
	if (sc->need_mcsetup)
d642 10
a651 1
	txp = NULL;
d653 2
a654 15
	/*
	 * We're finished if there is nothing more to add to the list or if
	 * we're all filled up with buffers to transmit.
	 * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add
	 *       a NOP command when needed.
	 */
	while (IFQ_IS_EMPTY(&ifp->if_snd) == 0 && sc->tx_queued < FXP_NTXCB - 1) {
		struct mbuf *m, *mb_head;
		int segment;

		/*
		 * Grab a packet to transmit.
		 */
		IFQ_DEQUEUE(&ifp->if_snd, mb_head);
		if (mb_head == NULL)
d657 4
a660 32
		/*
		 * Get pointer to next available tx desc.
		 */
		txp = sc->cbl_last->next;

		/*
		 * Go through each of the mbufs in the chain and initialize
		 * the transmit buffer descriptors with the physical address
		 * and size of the mbuf.
		 */
tbdinit:
		for (m = mb_head, segment = 0; m != NULL; m = m->m_next) {
			if (m->m_len != 0) {
				if (segment == FXP_NTXSEG)
					break;
				txp->tbd[segment].tb_addr =
				    vtophys(mtod(m, vaddr_t));
				txp->tbd[segment].tb_size = m->m_len;
				segment++;
			}
		}
		if (m != NULL) {
			struct mbuf *mn;

			/*
			 * We ran out of segments. We have to recopy this mbuf
			 * chain first. Bail out if we can't get the new
			 * buffers.
			 */
			MGETHDR(mn, M_DONTWAIT, MT_DATA);
			if (mn == NULL) {
				m_freem(mb_head);
d662 4
a665 6
			}
			if (mb_head->m_pkthdr.len > MHLEN) {
				MCLGET(mn, M_DONTWAIT);
				if ((mn->m_flags & M_EXT) == 0) {
					m_freem(mn);
					m_freem(mb_head);
d669 5
a673 6
			m_copydata(mb_head, 0, mb_head->m_pkthdr.len,
			    mtod(mn, caddr_t));
			mn->m_pkthdr.len = mn->m_len = mb_head->m_pkthdr.len;
			m_freem(mb_head);
			mb_head = mn;
			goto tbdinit;
d676 5
a680 14
		txp->tbd_number = segment;
		txp->mb_head = mb_head;
		txp->cb_status = 0;
		if (sc->tx_queued != FXP_CXINT_THRESH - 1) {
			txp->cb_command =
			    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S;
		} else {
			txp->cb_command =
			    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;
			/*
			 * Set a 5 second timer just in case we don't hear from the
			 * card again.
			 */
			ifp->if_timer = 5;
a681 7
		txp->tx_threshold = tx_threshold;
	
		/*
		 * Advance the end of list forward.
		 */
		sc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;
		sc->cbl_last = txp;
d683 1
a683 9
		/*
		 * Advance the beginning of the list forward if there are
		 * no other packets queued (when nothing is queued, cbl_first
		 * sits on the last TxCB that was sent out).
		 */
		if (sc->tx_queued == 0)
			sc->cbl_first = txp;

		sc->tx_queued++;
a685 3
		/*
		 * Pass packet to bpf if there is a listener.
		 */
d687 1
a687 1
			bpf_mtap(ifp->if_bpf, mb_head);
d689 21
d712 11
a722 10
	/*
	 * We're finished. If we added to the list, issue a RESUME to get DMA
	 * going again if suspended.
	 */
	if (txp != NULL) {
#ifdef ALTQ
		/* if tb regulator is used, we need tx complete interrupt */
		if (TBR_IS_ENABLED(&ifp->if_snd))
			txp->cb_command |= FXP_CB_COMMAND_I;
#endif
d724 4
a727 1
		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);
a730 2
volatile int _fxp_debugit;

d768 17
a784 11
		if (statack & FXP_SCB_STATACK_CXTNO) {
			struct fxp_cb_tx *txp;

			for (txp = sc->cbl_first; sc->tx_queued &&
			    (txp->cb_status & FXP_CB_STATUS_C) != 0;
			    txp = txp->next) {
				if (txp->mb_head != NULL) {
					_fxp_debugit = 1;
					m_freem(txp->mb_head);
					_fxp_debugit = 0;
					txp->mb_head = NULL;
d786 7
a792 1
				sc->tx_queued--;
d794 2
a795 1
			sc->cbl_first = txp;
d797 7
a803 3
			if (sc->tx_queued == 0) {
				if (sc->need_mcsetup)
					fxp_mc_setup(sc);
a804 5
			/*
			 * Try to start more packets transmitting.
			 */
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
				fxp_start(ifp);
a845 1
						_fxp_debugit = 2;
a846 1
						_fxp_debugit = 0;
d888 1
a888 1
	struct fxp_stats *sp = sc->fxp_stats;
d926 2
a927 1
		fxp_mc_setup(sc);
a974 1
	struct fxp_cb_tx *txp;
d988 1
a998 1
	txp = sc->cbl_base;
d1000 3
a1002 3
		if (txp[i].mb_head != NULL)
			m_freem(txp[i].mb_head);
		txp[i].mb_head = NULL;
d1004 1
a1004 1
	sc->tx_queued = 0;
a1024 1

d1048 1
a1048 1
static __inline void
d1070 1
a1070 1
	int i, s, prm;
d1073 1
a1078 2
	prm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;

d1083 1
d1088 1
d1091 3
d1098 3
a1100 1
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys((vaddr_t)sc->fxp_stats));
d1103 1
a1103 7
	/*
	 * We temporarily use memory that contains the TxCB list to
	 * construct the config CB. The TxCB list memory is rebuilt
	 * later.
	 */
	cbp = (struct fxp_cb_config *) sc->cbl_base;

d1112 3
d1117 2
a1118 2
	cbp->link_addr =	-1;	/* (no) next command */
	cbp->byte_count =	22;	/* (22) bytes to config */
d1148 1
a1148 1
	cbp->mc_all =		sc->all_mcasts;/* accept all multicasts */
d1154 2
a1155 1
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys((vaddr_t)&cbp->cb_status));
d1158 7
a1164 1
	while (!(cbp->cb_status & FXP_CB_STATUS_C));
d1167 1
a1167 2
	 * Now initialize the station address. Temporarily use the TxCB
	 * memory area like we did above for the config CB.
d1169 1
a1169 1
	cb_ias = (struct fxp_cb_ias *) sc->cbl_base;
d1172 1
a1172 1
	cb_ias->link_addr = -1;
d1180 2
d1184 10
a1193 1
	while (!(cb_ias->cb_status & FXP_CB_STATUS_C));
d1198 2
a1199 3

	txp = sc->cbl_base;
	bzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);
a1200 1
		txp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;
d1202 4
a1205 3
		txp[i].link_addr = vtophys((vaddr_t)&txp[(i + 1) & FXP_TXCB_MASK].cb_status);
		txp[i].tbd_array_addr = vtophys((vaddr_t)&txp[i].tbd[0]);
		txp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];
d1211 7
a1217 3
	txp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;
	sc->cbl_first = sc->cbl_last = txp;
	sc->tx_queued = 1;
d1220 2
d1254 1
d1256 1
a1256 2
	if (ifp->if_flags & IFF_UP)
		fxp_init(ifp->if_softc);
a1482 2
		sc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;

d1489 1
a1489 1
		if (ifp->if_flags & IFF_UP) {
d1491 2
a1492 4
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				fxp_stop(sc, 1);
		}
a1496 1
		sc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;
d1505 1
a1505 8
			if (!sc->all_mcasts)
				fxp_mc_setup(sc);
			/*
			 * fxp_mc_setup() can turn on all_mcasts if we run
			 * out of space, so check it again rather than else {}.
			 */
			if (sc->all_mcasts)
				fxp_init(sc);
d1537 1
a1537 1
fxp_mc_setup(sc)
d1539 1
d1541 1
a1541 1
	struct fxp_cb_mcs *mcsp = sc->mcsp;
a1547 45
	 * If there are queued commands, we must wait until they are all
	 * completed. If we are already waiting, then add a NOP command
	 * with interrupt option so that we're notified when all commands
	 * have been completed - fxp_start() ensures that no additional
	 * TX commands will be added when need_mcsetup is true.
	 */
	if (sc->tx_queued) {
		struct fxp_cb_tx *txp;

		/*
		 * need_mcsetup will be true if we are already waiting for the
		 * NOP command to be completed (see below). In this case, bail.
		 */
		if (sc->need_mcsetup)
			return;
		sc->need_mcsetup = 1;

		/*
		 * Add a NOP command with interrupt so that we are notified when all
		 * TX commands have been processed.
		 */
		txp = sc->cbl_last->next;
		txp->mb_head = NULL;
		txp->cb_status = 0;
		txp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;
		/*
		 * Advance the end of list forward.
		 */
		sc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;
		sc->cbl_last = txp;
		sc->tx_queued++;
		/*
		 * Issue a resume in case the CU has just suspended.
		 */
		fxp_scb_wait(sc);
		fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_RESUME);

		/* Set a 5 watchdog timer in case the chip flakes out. */
		ifp->if_timer = 5;

		return;
	}
	sc->need_mcsetup = 0;

	/*
a1549 2
	mcsp->next = sc->cbl_base;
	mcsp->mb_head = NULL;
d1551 2
a1552 2
	mcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;
	mcsp->link_addr = vtophys((vaddr_t)&sc->cbl_base->cb_status);
d1555 1
a1555 1
	if (!sc->all_mcasts) {
d1559 1
a1559 1
				sc->all_mcasts = 1;
d1567 1
a1567 1
				sc->all_mcasts = 1;
d1572 1
a1572 1
			    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);
d1577 3
a1579 3
	mcsp->mc_cnt = nmcasts * 6;
	sc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;
	sc->tx_queued = 1;
d1585 1
a1585 2
	while ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==
	    FXP_SCB_CUS_ACTIVE) ;
d1591 2
a1592 1
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys((vaddr_t)&mcsp->cb_status));
d1595 8
a1602 2
	ifp->if_timer = 2;
	return;
@


1.21
log
@fix vtophys usage, mainly ppc-required; art@@ ok and tried to bribe^H^H^H^H^Hmotivate me to bussydma 'em too (;
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.20 2001/06/27 06:34:41 kjc Exp $	*/
d41 1
d368 8
@


1.20
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.19 2001/06/23 23:17:35 fgsch Exp $	*/
d661 1
a661 1
				    vtophys(mtod(m, vm_offset_t));
d876 1
a876 2
				    vtophys(sc->rfa_headm->m_ext.ext_buf) +
					RFA_ALIGNMENT_FUDGE);
d1108 1
a1108 1
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));
d1165 1
a1165 1
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));
d1198 2
a1199 2
		txp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);
		txp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);
d1218 1
a1218 1
	    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);
d1335 1
a1335 1
		v = vtophys(rfap);
d1599 1
a1599 1
	mcsp->link_addr = vtophys(&sc->cbl_base->cb_status);
d1639 1
a1639 1
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));
@


1.19
log
@ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.18 2001/06/13 23:19:17 jason Exp $	*/
d366 1
d405 1
a405 1
	ifp->if_snd.ifq_maxlen = FXP_NTXCB - 1;
d634 1
a634 1
	while (ifp->if_snd.ifq_head != NULL && sc->tx_queued < FXP_NTXCB - 1) {
d641 3
a643 1
		IF_DEQUEUE(&ifp->if_snd, mb_head);
d742 5
d814 1
a814 1
			if (ifp->if_snd.ifq_head != NULL)
@


1.18
log
@From NetBSD, 82562 requires a nop before a resume (tested by mickey)
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.17 2001/05/27 01:32:21 art Exp $	*/
a840 1
					struct ether_header *eh;
d856 1
a856 3
					    total_len -
					    sizeof(struct ether_header);
					eh = mtod(m, struct ether_header *);
d859 1
a859 3
						bpf_tap(ifp->if_bpf,
						    mtod(m, caddr_t),
						    total_len); 
d861 1
a861 3
					m->m_data +=
					    sizeof(struct ether_header);
					ether_input(ifp, eh, m);
@


1.17
log
@Put back the fix for the possible leak and fix another bug
that the fix uncovered.

The tx descriptors were not initialized when allocated. The initialization
was done in fxp_init, but the first thing fxp_init does is to call fxp_stop
and fxp_stop expects the tx descriptors to be already initialized.
How did this ever work?
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.16 2001/05/26 19:40:37 deraadt Exp $	*/
d185 1
d744 2
d756 1
a756 1
	int claimed = 0;
d773 2
d790 1
d792 1
d824 5
d850 1
d852 1
d872 1
a872 1
			if (statack & FXP_SCB_STATACK_RNR) {
d877 1
a877 2
				CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND,
				    FXP_SCB_COMMAND_RU_START);
d949 1
a949 2
		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND,
		    FXP_SCB_COMMAND_CU_DUMPRESET);
d1059 16
d1099 1
a1099 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);
d1102 1
a1102 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);
d1109 1
a1109 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);
d1166 1
a1166 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);
d1185 1
a1185 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);
d1211 1
a1211 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);
d1219 1
a1219 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);
d1376 1
d1378 10
a1387 1
	/* XXX Update ifp->if_baudrate */
d1583 3
a1585 5
		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);
		/*
		 * Set a 5 second timer just in case we don't hear from the
		 * card again.
		 */
d1640 1
a1640 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);
@


1.16
log
@remove code which was obviously not tested.  begone, sloppy code monkeys
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.14 2001/05/24 03:32:51 art Exp $	*/
d319 1
d999 5
a1003 4
	for (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;
	    txp = txp->next) {
		m_freem(txp->mb_head);
		txp->mb_head = NULL;
@


1.15
log
@When releasing the tx buffers, walk through all of them, don't abort when
we find a descriptor with mb_head == NULL. It happens sometimes that we have
NOPs in the tx chains and normal buffers after the NOP.
@
text
@d998 4
a1001 5
	txp = sc->cbl_base;
	for (i = 0; i < FXP_NTXCB; i++) {
		if (txp[i].mb_head != NULL)
			m_freem(txp[i].mb_head);
		txp[i].mb_head = NULL;
@


1.14
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.13 2001/04/06 04:42:05 csapuntz Exp $	*/
d998 5
a1002 4
	for (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;
	    txp = txp->next) {
		m_freem(txp->mb_head);
		txp->mb_head = NULL;
@


1.13
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.12 2001/03/22 01:38:05 angelos Exp $	*/
d914 1
a914 1
	 * If we haven't received any packets in FXP_MAC_RX_IDLE seconds,
@


1.13.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.13 2001/04/06 04:42:05 csapuntz Exp $	*/
@


1.13.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.13.4.1 2001/05/14 22:23:47 niklas Exp $	*/
a184 1
static __inline void fxp_scb_cmd __P((struct fxp_softc *, u_int8_t));
a318 1
	memset(sc->cbl_base, 0, sizeof(struct fxp_cb_tx) * FXP_NTXCB);
a363 1
	IFQ_SET_READY(&ifp->if_snd);
d402 1
a402 1
	IFQ_SET_MAXLEN(&ifp->if_snd, FXP_NTXCB - 1);
d631 1
a631 1
	while (IFQ_IS_EMPTY(&ifp->if_snd) == 0 && sc->tx_queued < FXP_NTXCB - 1) {
d638 1
a638 3
		IFQ_DEQUEUE(&ifp->if_snd, mb_head);
		if (mb_head == NULL)
			break;
a736 5
#ifdef ALTQ
		/* if tb regulator is used, we need tx complete interrupt */
		if (TBR_IS_ENABLED(&ifp->if_snd))
			txp->cb_command |= FXP_CB_COMMAND_I;
#endif
a741 2
volatile int _fxp_debugit;

d752 1
a752 1
	int claimed = 0, rnr;
a768 2
		rnr = 0;

a783 1
					_fxp_debugit = 1;
a784 1
					_fxp_debugit = 0;
d798 1
a798 1
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
a815 5
				if (*(u_int16_t *)(rfap +
				    offsetof(struct fxp_rfa, rfa_status)) &
				    FXP_RFA_STATUS_RNR)
					rnr = 1;

d828 1
a836 1
						_fxp_debugit = 2;
a837 1
						_fxp_debugit = 0;
d842 3
a844 1
					    total_len;
d847 3
a849 1
						bpf_mtap(ifp->if_bpf, m);
d851 3
a853 1
					ether_input_mbuf(ifp, m);
d857 1
a857 1
			if (rnr) {
d862 2
a863 1
				fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);
d914 1
a914 1
	 * If we haven't received any packets in FXP_MAX_RX_IDLE seconds,
d935 2
a936 1
		fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_DUMPRESET);
d998 4
a1001 5
	txp = sc->cbl_base;
	for (i = 0; i < FXP_NTXCB; i++) {
		if (txp[i].mb_head != NULL)
			m_freem(txp[i].mb_head);
		txp[i].mb_head = NULL;
a1044 16
/*
 * Submit a command to the i82557.
 */
static __inline void
fxp_scb_cmd(sc, cmd)
	struct fxp_softc *sc;
	u_int8_t cmd;
{
	if (cmd == FXP_SCB_COMMAND_CU_RESUME &&
	    (sc->sc_flags & FXPF_FIX_RESUME_BUG) != 0) {
		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_CB_COMMAND_NOP);
		fxp_scb_wait(sc);
	}
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, cmd);
}

d1069 1
a1069 1
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_BASE);
d1072 1
a1072 1
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_BASE);
d1079 1
a1079 1
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_DUMP_ADR);
d1136 1
a1136 1
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);
d1155 1
a1155 1
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);
d1181 1
a1181 1
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);
d1189 1
a1189 1
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);
a1345 1
	struct fxp_softc *sc = (struct fxp_softc *)self;
d1347 1
a1347 10
	/*
	 * Determine whether or not we have to work-around the
	 * Resume Bug.
	 */
	if (sc->sc_flags & FXPF_HAS_RESUME_BUG) {
		if (IFM_TYPE(sc->sc_mii.mii_media_active) == IFM_10_T)
			sc->sc_flags |= FXPF_FIX_RESUME_BUG;
		else
			sc->sc_flags &= ~FXPF_FIX_RESUME_BUG;
	}
d1543 5
a1547 3
		fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_RESUME);

		/* Set a 5 watchdog timer in case the chip flakes out. */
d1602 1
a1602 1
	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);
@


1.13.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.13.4.2 2001/07/04 10:40:52 niklas Exp $	*/
a40 1
#include "vlan.h"
d95 6
d110 1
a110 1
#define	RFA_ALIGNMENT_FUDGE	(2 + sizeof(bus_dmamap_t))
d160 8
d170 1
a170 1
void fxp_scb_wait	__P((struct fxp_softc *));
d184 2
a185 2
void fxp_mc_setup		__P((struct fxp_softc *, int));
void fxp_scb_cmd		__P((struct fxp_softc *, u_int8_t));
d195 7
d216 6
d233 1
a233 1
void
d239 1
a239 4
	while (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i)
		DELAY(2);
	if (i == 0)
		printf("%s: warning: SCB timed out\n", sc->sc_dev.dv_xname);
d246 2
d282 1
a282 1
	s = splimp();
a306 2
	struct mbuf *m;
	bus_dmamap_t rxmap;
d308 1
a308 1
	int i, err;
d313 1
a313 1
	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SOFTWARE_RESET);
d316 3
a318 2
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct fxp_ctrl),
	    PAGE_SIZE, 0, &sc->sc_cb_seg, 1, &sc->sc_cb_nseg, BUS_DMA_NOWAIT))
d320 4
a323 4
	if (bus_dmamem_map(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg,
	    sizeof(struct fxp_ctrl), (caddr_t *)&sc->sc_ctrl,
	    BUS_DMA_NOWAIT)) {
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg);
d325 4
a328 7
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct fxp_ctrl),
	    1, sizeof(struct fxp_ctrl), 0, BUS_DMA_NOWAIT,
	    &sc->tx_cb_map)) {
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_ctrl,
		    sizeof(struct fxp_ctrl));
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg);
a329 22
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->tx_cb_map, (caddr_t)sc->sc_ctrl,
	    sizeof(struct fxp_ctrl), NULL, BUS_DMA_NOWAIT)) {
		bus_dmamap_destroy(sc->sc_dmat, sc->tx_cb_map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_ctrl,
		    sizeof(struct fxp_ctrl));
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg);
	}

	for (i = 0; i < FXP_NTXCB; i++) {
		if ((err = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    FXP_NTXSEG, MCLBYTES, 0, 0, &sc->txs[i].tx_map)) != 0) {
			printf("%s: unable to create tx dma map %d, error %d\n",
			    sc->sc_dev.dv_xname, i, err);
			goto fail;
		}
		sc->txs[i].tx_mbuf = NULL;
		sc->txs[i].tx_cb = sc->sc_ctrl->tx_cb + i;
		sc->txs[i].tx_off = offsetof(struct fxp_ctrl, tx_cb[i]);
		sc->txs[i].tx_next = &sc->txs[(i + 1) & FXP_TXCB_MASK];
	}
	bzero(sc->sc_ctrl, sizeof(struct fxp_ctrl));
a333 1
	sc->sc_rxfree = 0;
d335 1
a335 4
		if ((err = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &sc->sc_rxmaps[i])) != 0) {
			printf("%s: unable to create tx dma map %d, error %d\n",
			    sc->sc_dev.dv_xname, i, err);
a338 3
	for (i = 0; i < FXP_NRFABUFS; i++)
		if (fxp_add_rfabuf(sc, NULL) != 0)
			goto fail;
a367 8
#if NVLAN > 0
	/*
	 * Only 82558 and newer cards have a bit to ignore oversized frames.
	 */
	if (sc->not_82557)
		ifp->if_capabilities |= IFCAP_VLAN_MTU;
#endif

d429 10
a438 14
	if (sc->tx_cb_map != NULL) {
		bus_dmamap_unload(sc->sc_dmat, sc->tx_cb_map);
		bus_dmamap_destroy(sc->sc_dmat, sc->tx_cb_map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_ctrl,
		    sizeof(struct fxp_cb_tx) * FXP_NTXCB);
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cb_seg, sc->sc_cb_nseg);
	}
	m = sc->rfa_headm;
	while (m != NULL) {
		rxmap = *((bus_dmamap_t *)m->m_ext.ext_buf);
		bus_dmamap_unload(sc->sc_dmat, rxmap);
		FXP_RXMAP_PUT(sc, rxmap);
		m = m_free(m);
	}
d616 1
a616 4
	struct fxp_txsw *txs = sc->sc_cbt_prod;
	struct fxp_cb_tx *txc;
	struct mbuf *m0, *m = NULL;
	int cnt = sc->sc_cbt_cnt, seg;
d618 6
a623 1
	if ((ifp->if_flags & (IFF_OACTIVE | IFF_RUNNING)) != IFF_RUNNING)
d626 17
a642 3
	while (1) {
		if (cnt >= (FXP_NTXCB - 1)) {
			ifp->if_flags |= IFF_OACTIVE;
a643 1
		}
d645 4
a648 1
		txs = txs->tx_next;
d650 18
a667 3
		IFQ_POLL(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;
d669 8
a676 4
		if (bus_dmamap_load_mbuf(sc->sc_dmat, txs->tx_map,
		    m0, BUS_DMA_NOWAIT) != 0) {
			MGETHDR(m, M_DONTWAIT, MT_DATA);
			if (m == NULL)
d678 6
a683 4
			if (m0->m_pkthdr.len > MHLEN) {
				MCLGET(m, M_DONTWAIT);
				if (!(m->m_flags & M_EXT)) {
					m_freem(m);
d687 6
a692 5
			m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m, caddr_t));
			m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;
			if (bus_dmamap_load_mbuf(sc->sc_dmat, txs->tx_map,
			    m, BUS_DMA_NOWAIT) != 0)
				break;
d695 14
a708 5
		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m != NULL) {
			m_freem(m0);
			m0 = m;
			m = NULL;
d710 7
d718 9
a726 1
		txs->tx_mbuf = m0;
d729 3
d733 1
a733 1
			bpf_mtap(ifp->if_bpf, m0);
a734 19

		FXP_MBUF_SYNC(sc, txs->tx_map, BUS_DMASYNC_PREWRITE);

		txc = txs->tx_cb;
		txc->tbd_number = txs->tx_map->dm_nsegs;
		txc->cb_status = 0;
		txc->cb_command = FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF;
		txc->tx_threshold = tx_threshold;
		for (seg = 0; seg < txs->tx_map->dm_nsegs; seg++) {
			txc->tbd[seg].tb_addr =
			    txs->tx_map->dm_segs[seg].ds_addr;
			txc->tbd[seg].tb_size =
			    txs->tx_map->dm_segs[seg].ds_len;
		}
		FXP_TXCB_SYNC(sc, txs,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		++cnt;
		sc->sc_cbt_prod = txs;
d737 10
a746 17
	if (cnt != sc->sc_cbt_cnt) {
		/* We enqueued at least one. */
		ifp->if_timer = 5;

		txs = sc->sc_cbt_prod;
		txs->tx_cb->cb_command |= FXP_CB_COMMAND_I | FXP_CB_COMMAND_S;
		FXP_TXCB_SYNC(sc, txs,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		FXP_TXCB_SYNC(sc, sc->sc_cbt_prev,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		sc->sc_cbt_prev->tx_cb->cb_command &= ~FXP_CB_COMMAND_S;
		FXP_TXCB_SYNC(sc, sc->sc_cbt_prev,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		sc->sc_cbt_prev = txs;

d748 1
a748 3
		fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_RESUME);

		sc->sc_cbt_cnt = cnt;
d752 2
d791 11
a801 16
		if (statack & (FXP_SCB_STATACK_CXTNO|FXP_SCB_STATACK_CNA)) {
			int txcnt = sc->sc_cbt_cnt;
			struct fxp_txsw *txs = sc->sc_cbt_cons;

			FXP_TXCB_SYNC(sc, txs,
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

			while ((txcnt > 0) &&
			    (txs->tx_cb->cb_status & FXP_CB_STATUS_C)) {
				if (txs->tx_mbuf != NULL) {
					FXP_MBUF_SYNC(sc, txs->tx_map,
					    BUS_DMASYNC_POSTWRITE);
					bus_dmamap_unload(sc->sc_dmat,
					    txs->tx_map);
					m_freem(txs->tx_mbuf);
					txs->tx_mbuf = NULL;
d803 1
a803 2
				--txcnt;
				txs = txs->tx_next;
d805 1
a805 2
			sc->sc_cbt_cons = txs;
			sc->sc_cbt_cnt = txcnt;
d807 8
a814 6
			ifp->if_flags &= ~IFF_OACTIVE;

			if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
				/*
				 * Try to start more packets transmitting.
				 */
a815 1
			}
a823 1
			bus_dmamap_t rxmap;
a827 4
			rxmap = *((bus_dmamap_t *)m->m_ext.ext_buf);
			fxp_bus_dmamap_sync(sc->sc_dmat, rxmap,
			    0, MCLBYTES, BUS_DMASYNC_POSTREAD |
			    BUS_DMASYNC_POSTWRITE);
d857 1
d859 1
a873 2
				rxmap = *((bus_dmamap_t *)
				    sc->rfa_headm->m_ext.ext_buf);
d876 2
a877 2
				    rxmap->dm_segs[0].ds_addr +
				    RFA_ALIGNMENT_FUDGE);
d902 1
a902 1
	struct fxp_stats *sp = &sc->sc_ctrl->stats;
d919 1
a919 1
	 * If any transmit underruns occurred, bump up the transmit
d940 1
a940 2
		fxp_init(sc);
		return;
d988 1
a1001 1
	mii_down(&sc->sc_mii);
d1012 1
d1014 3
a1016 5
		if (sc->txs[i].tx_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->txs[i].tx_map);
			m_freem(sc->txs[i].tx_mbuf);
			sc->txs[i].tx_mbuf = NULL;
		}
d1018 1
a1018 1
	sc->sc_cbt_cnt = 0;
a1020 3
		bus_dmamap_t rxmap;
		struct mbuf *m;

d1024 2
a1025 7
		m = sc->rfa_headm;
		while (m != NULL) {
			rxmap = *((bus_dmamap_t *)m->m_ext.ext_buf);
			bus_dmamap_unload(sc->sc_dmat, rxmap);
			FXP_RXMAP_PUT(sc, rxmap);
			m = m_free(m);
		}
d1039 1
d1063 1
a1063 1
void
d1085 1
a1085 2
	bus_dmamap_t rxmap;
	int i, prm, allm, s;
a1087 1

d1093 2
a1098 1
	fxp_scb_wait(sc);
a1102 1
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);
a1104 3
	/* Once through to set flags */
	fxp_mc_setup(sc, 0);

d1109 1
a1109 3
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
	    sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, stats));
d1112 7
a1118 1
	cbp = &sc->sc_ctrl->u.cfg;
a1126 3
	prm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;
	allm = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;

d1129 2
a1130 2
	cbp->link_addr =	0xffffffff;	/* (no) next command */
	cbp->byte_count =	22;		/* (22) bytes to config */
d1160 1
a1160 1
	cbp->mc_all =		allm;
d1166 1
a1166 2
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, u.cfg));
d1169 1
a1169 5
	FXP_CFG_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	do {
		DELAY(1);
		FXP_CFG_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	} while ((cbp->cb_status & FXP_CB_STATUS_C) == 0);
d1172 2
a1173 1
	 * Now initialize the station address.
d1175 1
a1175 1
	cb_ias = &sc->sc_ctrl->u.ias;
d1178 1
a1178 1
	cb_ias->link_addr = 0xffffffff;
a1185 2
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, u.ias));
d1188 1
a1188 8
	FXP_IAS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	do {
		DELAY(1);
		FXP_IAS_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	} while (!(cb_ias->cb_status & FXP_CB_STATUS_C));

	/* Again, this time really upload the multicast addresses */
	fxp_mc_setup(sc, 1);
d1193 3
a1195 2
	bzero(sc->sc_ctrl->tx_cb, sizeof(struct fxp_cb_tx) * FXP_NTXCB);
	txp = sc->sc_ctrl->tx_cb;
d1197 1
d1199 3
a1201 4
		txp[i].link_addr = sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[(i + 1) & FXP_TXCB_MASK]);
		txp[i].tbd_array_addr = sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[i].tbd[0]);
d1207 3
a1209 6
	sc->sc_cbt_prev = sc->sc_cbt_prod = sc->sc_cbt_cons = sc->txs;
	sc->sc_cbt_cnt = 1;
	sc->sc_ctrl->tx_cb[0].cb_command = FXP_CB_COMMAND_NOP |
	    FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;
	fxp_bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map, 0,
	    sc->tx_cb_map->dm_mapsize, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
a1211 2
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, tx_cb[0]));
a1217 1
	rxmap = *((bus_dmamap_t *)sc->rfa_headm->m_ext.ext_buf);
d1219 1
a1219 1
	    rxmap->dm_segs[0].ds_addr + RFA_ALIGNMENT_FUDGE);
a1243 1
	struct fxp_softc *sc = ifp->if_softc;
d1245 2
a1246 1
	mii_mediachg(&sc->sc_mii);
a1280 1
	bus_dmamap_t rxmap = NULL;
a1291 16
		if (oldm == NULL) {
			rxmap = FXP_RXMAP_GET(sc);
			*((bus_dmamap_t *)m->m_ext.ext_buf) = rxmap;
			bus_dmamap_load(sc->sc_dmat, rxmap,
			    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
			    BUS_DMA_NOWAIT);
		} else if (oldm == m)
			rxmap = *((bus_dmamap_t *)oldm->m_ext.ext_buf);
		else {
			rxmap = *((bus_dmamap_t *)oldm->m_ext.ext_buf);
			bus_dmamap_unload(sc->sc_dmat, rxmap);
			bus_dmamap_load(sc->sc_dmat, rxmap,
			    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
			    BUS_DMA_NOWAIT);
			*mtod(m, bus_dmamap_t *) = rxmap;
		}
a1296 1
		rxmap = *mtod(m, bus_dmamap_t *);
d1336 1
a1336 1
		v = rxmap->dm_segs[0].ds_addr + RFA_ALIGNMENT_FUDGE;
d1342 1
a1342 1
	} else
d1344 1
a1344 1

a1346 3
	fxp_bus_dmamap_sync(sc->sc_dmat, rxmap, 0, MCLBYTES,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d1473 2
d1481 1
a1481 1
		if (ifp->if_flags & IFF_UP)
d1483 4
a1486 2
		else if (ifp->if_flags & IFF_RUNNING)
			fxp_stop(sc, 1);
d1491 1
d1500 8
a1507 1
			fxp_init(sc);
d1539 1
a1539 1
fxp_mc_setup(sc, doit)
a1540 1
	int doit;
d1542 1
a1542 1
	struct fxp_cb_mcs *mcsp = &sc->sc_ctrl->u.mcs;
d1549 45
d1596 2
d1599 2
a1600 2
	mcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_EL;
	mcsp->link_addr = -1;
d1603 1
a1603 1
	if (!(ifp->if_flags & IFF_ALLMULTI)) {
d1607 1
a1607 1
				ifp->if_flags |= IFF_ALLMULTI;
d1615 1
a1615 1
				ifp->if_flags |= IFF_ALLMULTI;
d1620 1
a1620 1
			    (void *)&mcsp->mc_addr[nmcasts][0], ETHER_ADDR_LEN);
d1625 3
a1627 3
	if (doit == 0)
		return;
	mcsp->mc_cnt = nmcasts * ETHER_ADDR_LEN;
d1633 2
a1634 1
	while ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) != FXP_SCB_CUS_IDLE);
d1640 1
a1640 2
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc->tx_cb_map->dm_segs->ds_addr +
	    offsetof(struct fxp_ctrl, u.mcs));
d1643 2
a1644 5
	FXP_MCS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	do {
		DELAY(1);
		FXP_MCS_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	} while (!(mcsp->cb_status & FXP_CB_STATUS_C));
@


1.13.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
a85 1
#include <uvm/uvm_extern.h>
d815 1
a815 1
			bus_dmamap_sync(sc->sc_dmat, rxmap,
d1226 2
a1227 3
	bus_dmamap_sync(sc->sc_dmat, sc->tx_cb_map, 0,
	    sc->tx_cb_map->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1386 1
a1386 1
	bus_dmamap_sync(sc->sc_dmat, rxmap, 0, MCLBYTES,
@


1.13.4.5
log
@Merge in trunk
@
text
@d1551 1
a1551 1
	splx(s);
@


1.13.4.6
log
@Merge in -current from about a week ago
@
text
@d110 2
a111 2
static __inline void fxp_lwcopy(volatile u_int32_t *,
	volatile u_int32_t *);
d155 18
a172 18
int fxp_mediachange(struct ifnet *);
void fxp_mediastatus(struct ifnet *, struct ifmediareq *);
void fxp_scb_wait(struct fxp_softc *);
void fxp_start(struct ifnet *);
int fxp_ioctl(struct ifnet *, u_long, caddr_t);
void fxp_init(void *);
void fxp_stop(struct fxp_softc *, int);
void fxp_watchdog(struct ifnet *);
int fxp_add_rfabuf(struct fxp_softc *, struct mbuf *);
int fxp_mdi_read(struct device *, int, int);
void fxp_mdi_write(struct device *, int, int, int);
void fxp_autosize_eeprom(struct fxp_softc *);
void fxp_statchg(struct device *);
void fxp_read_eeprom(struct fxp_softc *, u_int16_t *,
				    int, int);
void fxp_stats_update(void *);
void fxp_mc_setup(struct fxp_softc *, int);
void fxp_scb_cmd(struct fxp_softc *, u_int8_t);
d223 2
a224 2
void	fxp_shutdown(void *);
void	fxp_power(int, void *);
a930 1
		splx(s);
@


1.13.4.7
log
@Sync the SMP branch with 3.3
@
text
@d105 1
a105 1
#define	RFA_ALIGNMENT_FUDGE	(2 + sizeof(bus_dmamap_t *))
a125 1
 * Note, cb_command is filled in later.
d129 1
a129 1
	0x0, 0x0,		/* cb_command */
d131 22
a152 22
	0x16,	/*  0 Byte count. */
	0x08,	/*  1 Fifo limit */
	0x00,	/*  2 Adaptive ifs */
	0x00,	/*  3 void1 */
	0x00,	/*  4 rx_dma_bytecount */
	0x80,	/*  5 tx_dma_bytecount */
	0xb2,	/*  6 ctrl 1*/
	0x03,	/*  7 ctrl 2*/
	0x01,	/*  8 mediatype */
	0x00,	/*  9 void2 */
	0x26,	/* 10 ctrl3 */
	0x00,	/* 11 linear priority */
	0x60,	/* 12 interfrm_spacing */
	0x00,	/* 13 void31 */
	0xf2,	/* 14 void32 */
	0x48,	/* 15 promiscous */
	0x00,	/* 16 void41 */
	0x40,	/* 17 void42 */
	0xf3,	/* 18 stripping */
	0x00,	/* 19 fdx_pin */
	0x3f,	/* 20 multi_ia */
	0x05	/* 21 mc_all */
d182 9
d261 1
a261 1
		ifp = &sc->sc_arpcom.ac_if;
d366 2
a367 2
	ifp = &sc->sc_arpcom.ac_if;
	bcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
d385 1
a385 1
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));
d466 1
a466 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a622 1
		data[i] = htole16(data[i]);
d645 1
a645 1
		if (cnt >= (FXP_NTXCB - 2)) {
d671 1
a671 2
			    m, BUS_DMA_NOWAIT) != 0) {
				m_freem(m);
a672 1
			}
d694 1
a694 1
		txc->cb_command = htole16(FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF);
d698 1
a698 1
			    htole32(txs->tx_map->dm_segs[seg].ds_addr);
d700 1
a700 1
			    htole32(txs->tx_map->dm_segs[seg].ds_len);
d714 1
a714 4
		txs = txs->tx_next;
		sc->sc_cbt_prod = txs;
		txs->tx_cb->cb_command =
		    htole16(FXP_CB_COMMAND_I | FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S);
d720 1
a720 2
		sc->sc_cbt_prev->tx_cb->cb_command &=
		    htole16(~(FXP_CB_COMMAND_S | FXP_CB_COMMAND_I));
d729 1
a729 1
		sc->sc_cbt_cnt = cnt + 1;
d741 1
a741 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d778 1
a778 2
			   ((txs->tx_cb->cb_status & htole16(FXP_CB_STATUS_C)) ||
			   (txs->tx_cb->cb_command & htole16(FXP_CB_COMMAND_NOP)))) {
a788 2
				FXP_TXCB_SYNC(sc, txs,
				    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
d821 1
a821 1
			    htole16(FXP_RFA_STATUS_C)) {
d824 1
a824 1
				    htole16(FXP_RFA_STATUS_RNR))
d841 1
a841 1
					total_len = htole16(*(u_int16_t *)(rfap +
d843 1
a843 1
					    actual_size))) &
d891 1
a891 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a894 1
	FXP_STATS_SYNC(sc, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
d923 1
a923 1
	 * up if it gets certain types of garbage in the synchronization
a937 1
	FXP_STATS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d979 1
a979 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d1081 1
a1081 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a1130 1
#if 0
a1164 36
#else
	cbp->cb_command = htole16(FXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL);
	if (allm) 
		cbp->mc_all |= 0x08;		/* accept all multicasts */
	else
		cbp->mc_all &= ~0x08;		/* reject all multicasts */

	if (prm) {
		cbp->promiscuous |= 1;		/* promiscuous mode */
		cbp->ctrl1 |= 0x80;		/* save bad frames */
		cbp->ctrl2 &= ~0x01;		/* save short packets */
		cbp->stripping &= ~0x01;	/* don't truncate rx packets */
	}
	else {
		cbp->promiscuous &= ~1;		/* no promiscuous mode */
		cbp->ctrl1 &= ~0x80;		/* discard bad frames */
		cbp->ctrl2 |= 0x01;		/* discard short packets */
		cbp->stripping |= 0x01;		/* truncate rx packets */
	}

	if(!sc->phy_10Mbps_only)			/* interface mode */
		cbp->mediatype |= 0x01;
	else
		cbp->mediatype &= ~0x01;

	if(sc->not_82557)			/* long packets */
		cbp->stripping |= 0x08;
	else
		cbp->stripping &= ~0x08;

	cbp->tx_dma_bytecount = 0; /* (no) tx DMA max, dma_dce = 0 ??? */
 	cbp->ctrl1 |= 0x08;	/* ci_int = 1 */
	cbp->ctrl3 |= 0x08;	/* nsai */
	cbp->fifo_limit = 0x08; /* tx and rx fifo limit */
	cbp->fdx_pin |= 0x80;	/* Enable full duplex setting by pin */
#endif
a1169 1
	FXP_CFG_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1174 1
d1178 1
a1178 1
	} while ((cbp->cb_status & htole16(FXP_CB_STATUS_C)) == 0);
d1184 5
a1188 5
	cb_ias->cb_status = htole16(0);
	cb_ias->cb_command = htole16(FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL);
	cb_ias->link_addr = htole32(0xffffffff);
	bcopy(sc->sc_arpcom.ac_enaddr, (void *)cb_ias->macaddr,
	    sizeof(sc->sc_arpcom.ac_enaddr));
a1193 1
	FXP_IAS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1198 1
d1202 1
a1202 1
	} while (!(cb_ias->cb_status & htole16(FXP_CB_STATUS_C)));
d1213 5
a1217 5
		txp[i].cb_command = htole16(FXP_CB_COMMAND_NOP);
		txp[i].link_addr = htole32(sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[(i + 1) & FXP_TXCB_MASK]));
		txp[i].tbd_array_addr =htole32(sc->tx_cb_map->dm_segs->ds_addr +
		    offsetof(struct fxp_ctrl, tx_cb[i].tbd[0]));
d1225 2
a1226 2
	sc->sc_ctrl->tx_cb[0].cb_command = htole16(FXP_CB_COMMAND_NOP |
	    FXP_CB_COMMAND_S | FXP_CB_COMMAND_I);
d1353 1
a1353 1
	    htole16(MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE);
d1362 1
a1362 1
	    htole16(FXP_RFA_CONTROL_EL);
a1370 3
	bus_dmamap_sync(sc->sc_dmat, rxmap, 0, MCLBYTES,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d1377 1
a1377 1
		v = htole32(rxmap->dm_segs[0].ds_addr + RFA_ALIGNMENT_FUDGE);
d1382 1
a1382 5
		    htole16((u_int16_t)~FXP_RFA_CONTROL_EL);
		/* XXX we only need to sync the control struct */
		bus_dmamap_sync(sc->sc_dmat,
		    *((bus_dmamap_t *)sc->rfa_tailm->m_ext.ext_buf), 0,
			MCLBYTES, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1388 3
d1470 1
a1470 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d1483 1
a1483 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1532 2
a1533 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
d1576 1
a1576 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d1584 3
a1586 3
	mcsp->cb_status = htole16(0);
	mcsp->cb_command = htole16(FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_EL);
	mcsp->link_addr = htole32(-1);
d1590 1
a1590 1
		ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
d1613 1
a1613 1
	mcsp->mc_cnt = htole16(nmcasts * ETHER_ADDR_LEN);
a1624 1
	FXP_MCS_SYNC(sc, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d1629 1
d1633 1
a1633 1
	} while (!(mcsp->cb_status & htole16(FXP_CB_STATUS_C)));
@


1.13.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.13.4.7 2003/03/28 00:38:13 niklas Exp $	*/
d898 2
a899 2
	ifp->if_opackets += letoh32(sp->tx_good);
	ifp->if_collisions += letoh32(sp->tx_total_collisions);
d901 1
a901 1
		ifp->if_ipackets += letoh32(sp->rx_good);
d907 4
a910 4
	    letoh32(sp->rx_crc_errors) +
	    letoh32(sp->rx_alignment_errors) +
	    letoh32(sp->rx_rnr_errors) +
	    letoh32(sp->rx_overrun_errors);
d916 1
a916 1
		ifp->if_oerrors += letoh32(sp->tx_underruns);
@


1.13.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 2
d147 1
a147 1
	0x48,	/* 15 promiscuous */
d418 1
a418 1
	 * doing so could allow DMA to corrupt kernel memory during the
d486 1
a486 1
 * talks about the existence of 16 to 256 word EEPROMs.
d527 1
a527 1
		DELAY(4);
d529 1
a529 1
		DELAY(4);
d539 1
a539 1
		DELAY(4);
d543 1
a543 1
		DELAY(4);
d546 1
a546 1
	DELAY(4);
d580 1
a580 1
			DELAY(4);
d582 1
a582 1
			DELAY(4);
d596 1
a596 1
			DELAY(4);
d598 1
a598 1
			DELAY(4);
d608 1
a608 1
			DELAY(4);
d613 1
a613 1
			DELAY(4);
d615 1
a615 1
		data[i] = letoh16(data[i]);
d617 1
a617 1
		DELAY(4);
@


1.13.4.10
log
@Merge with the trunk
@
text
@d76 1
a153 3
void fxp_eeprom_shiftin(struct fxp_softc *, int, int);
void fxp_eeprom_putword(struct fxp_softc *, int, u_int16_t);
void fxp_write_eeprom(struct fxp_softc *, u_short *, int, int);
a208 80

void 
fxp_eeprom_shiftin(struct fxp_softc *sc, int data, int length)
{
	u_int16_t reg;
	int x;

	/*
	 * Shift in data.
	 */
	for (x = 1 << (length - 1); x; x >>= 1) {
		if (data & x)
			reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;
		else
			reg = FXP_EEPROM_EECS;
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
		DELAY(1);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg | FXP_EEPROM_EESK);
		DELAY(1);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
		DELAY(1);
	}
}


void
fxp_eeprom_putword(struct fxp_softc *sc, int offset, u_int16_t data)
{
	int i;

	/*
	 * Erase/write enable.
	 */
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	fxp_eeprom_shiftin(sc, 0x4, 3);
	fxp_eeprom_shiftin(sc, 0x03 << (sc->eeprom_size - 2), sc->eeprom_size);
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(1);
	/*
	 * Shift in write opcode, address, data.
	 */
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	fxp_eeprom_shiftin(sc, FXP_EEPROM_OPC_WRITE, 3);
	fxp_eeprom_shiftin(sc, offset, sc->eeprom_size);
	fxp_eeprom_shiftin(sc, data, 16);
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(1);
	/*
	 * Wait for EEPROM to finish up.
	 */
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	DELAY(1);
	for (i = 0; i < 1000; i++) {
		if (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) & FXP_EEPROM_EEDO)
			break;
		DELAY(50);
	}
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(1);
	/*
	 * Erase/write disable.
	 */
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	fxp_eeprom_shiftin(sc, 0x4, 3);
	fxp_eeprom_shiftin(sc, 0, sc->eeprom_size);
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(1);
}

void
fxp_write_eeprom(struct fxp_softc *sc, u_short *data, int offset, int words)
{
	int i;

	for (i = 0; i < words; i++)
		fxp_eeprom_putword(sc, offset + i, data[i]);
}



d323 1
a323 1
	 * Pre-allocate some receive buffers.
d326 1
a326 1
	for (i = 0; i < FXP_NRFABUFS_MIN; i++) {
d329 1
a329 1
			printf("%s: unable to create rx dma map %d, error %d\n",
a332 1
		sc->rx_bufs++;
d334 1
a334 1
	for (i = 0; i < FXP_NRFABUFS_MIN; i++)
a365 24
	
	if (sc->sc_flags & FXPF_DISABLE_STANDBY) {
		fxp_read_eeprom(sc, &data, 10, 1);
		if (data & 0x02) {			/* STB enable */
			u_int16_t cksum;
			int i;
			printf("Disabling dynamic standby mode in EEPROM\n");
			data &= ~0x02;
			fxp_write_eeprom(sc, &data, 10, 1);
			printf("New EEPROM ID: 0x%x\n", data);
			cksum = 0;
			for (i = 0; i < (1 << sc->eeprom_size) - 1; i++) {
				fxp_read_eeprom(sc, &data, i, 1);
				cksum += data;
			}
			i = (1 << sc->eeprom_size) - 1;
			cksum = 0xBABA - cksum;
			fxp_read_eeprom(sc, &data, i, 1);
			fxp_write_eeprom(sc, &cksum, i, 1);
			printf("EEPROM checksum @@ 0x%x: 0x%x -> 0x%x\n",
			    i, data, cksum);
		}
	}

a546 5





d740 2
a741 4
	bus_dmamap_t rxmap;
	int claimed = 0;
	int rnr = 0;
	
d757 2
a758 1
		rnr = (statack & FXP_SCB_STATACK_RNR) ? 1 : 0;
d809 1
a849 8
					if (*(u_int16_t *)(rfap +
					    offsetof(struct fxp_rfa,
					    rfa_status)) &
					    htole16(FXP_RFA_STATUS_CRC)) {
						m_freem(m);
						goto rcvloop;
					}

d861 5
a865 6
		}
		if (rnr) {
			rxmap = *((bus_dmamap_t *)
			    sc->rfa_headm->m_ext.ext_buf);
			fxp_scb_wait(sc);
			CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
d868 2
a869 2
			fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);
			
d901 1
a901 1
	} else
d903 1
a1027 1
			sc->rx_bufs--;
d1031 1
a1031 1
		for (i = 0; i < FXP_NRFABUFS_MIN; i++) {
a1039 1
			sc->rx_bufs++;
a1086 1
	struct mbuf *m;
d1088 1
a1088 1
	int i, prm, allm, s, bufs;
a1277 26
	if (ifp->if_flags & IFF_UP)
		bufs = FXP_NRFABUFS_MAX;
	else
		bufs = FXP_NRFABUFS_MIN;
	if (sc->rx_bufs > bufs) {
		while (sc->rfa_headm != NULL && sc->rx_bufs-- > bufs) {
			rxmap = *((bus_dmamap_t *)m->m_ext.ext_buf);
			bus_dmamap_unload(sc->sc_dmat, rxmap);
			FXP_RXMAP_PUT(sc, rxmap);
			sc->rfa_headm = m_free(m);
		}
	} else if (sc->rx_bufs < bufs) {
		int err, tmp_rx_bufs = sc->rx_bufs;
		for (i = sc->rx_bufs; i < bufs; i++) {
			if ((err = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
			    MCLBYTES, 0, 0, &sc->sc_rxmaps[i])) != 0) {
				printf("%s: unable to create rx dma map %d, "
				  "error %d\n", sc->sc_dev.dv_xname, i, err);
				break;
			}
			sc->rx_bufs++;
		}
		for (i = tmp_rx_bufs; i < sc->rx_bufs; i++)
			if (fxp_add_rfabuf(sc, NULL) != 0)
				break;
	}
@


1.12
log
@Reformat comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.11 2001/02/20 19:39:38 mickey Exp $	*/
a99 2

#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
@


1.11
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.10 2000/10/16 17:08:07 aaron Exp $	*/
d668 2
a669 1
			 * chain first. Bail out if we can't get the new buffers.
@


1.10
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.9 2000/09/17 17:08:16 aaron Exp $	*/
a405 4
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif
@


1.9
log
@Support detach of fxp devices to allow ejection of Intel CardBus adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.8 2000/08/02 18:50:17 aaron Exp $	*/
d379 2
a380 1
	mii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);
@


1.8
log
@No need to include pci header files here.
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.7 2000/07/20 16:22:26 ho Exp $	*/
d415 1
a415 1
	shutdownhook_establish(fxp_shutdown, sc);
d420 1
a420 1
	powerhook_establish(fxp_power, sc);
d442 25
@


1.7
log
@Convert to new timeouts. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.6 2000/06/03 02:55:04 jason Exp $	*/
a93 4

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
@


1.6
log
@remove fxp_ether_ioctl(), and move it's processing to fxp_ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.5 2000/04/27 00:29:51 chris Exp $	*/
d49 1
d426 5
d944 1
a944 1
	timeout(fxp_stats_update, sc, hz);
d970 1
a970 1
	untimeout(fxp_stats_update, sc);
d1186 1
a1186 1
	timeout(fxp_stats_update, sc, hz);
@


1.5
log
@Whoops
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.4 2000/04/27 00:00:25 chris Exp $	*/
a254 4
/* Compensate for lack of a generic ether_ioctl() */
int	fxp_ether_ioctl __P((struct ifnet *, u_long, caddr_t));
#define	ether_ioctl	fxp_ether_ioctl

a296 49
int
fxp_ether_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ifaddr *ifa = (struct ifaddr *) data;
	struct fxp_softc *sc = ifp->if_softc;

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			fxp_init(sc);
			arp_ifinit(&sc->arpcom, ifa);
			break;
#endif
#ifdef NS
		case AF_NS:
		    {
			 register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			 if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
				    LLADDR(ifp->if_sadl);
			 else
				bcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),
				    ifp->if_addrlen);
			 /* Set new address. */
			 fxp_init(sc);
			 break;
		    }
#endif
		default:
			fxp_init(sc);
			break;
		}
		break;

	default:
		return (EINVAL);
	}

	return (0);
}

d1357 1
d1362 5
d1368 2
d1371 27
a1397 3
	case SIOCSIFADDR:
	case SIOCGIFADDR:
		error = ether_ioctl(ifp, command, data);
@


1.4
log
@Fix SIOCSIFMTU
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.3 2000/04/26 19:12:08 chris Exp $	*/
a1425 1
			error = fxp_init(sc);
@


1.3
log
@Turn on a bit (for 82558/82559 only) which disables the chip's
builin feature to discard frames >1500 bytes (useful for jumbo frames,
also 802.1Q VLANs)

ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.2 2000/04/26 12:48:53 aaron Exp $	*/
d1418 3
d1422 6
a1427 1
		error = ether_ioctl(ifp, command, data);
@


1.2
log
@After the fxp split, sizeof(enaddr) is now 4, not 6, since enaddr is a pointer
that's passed in from the bus-dependent parts. Use ETHER_ADDR_LEN so we get the
whole thing; sigh@@kuzirabekon.econ.nagasaki-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: fxp.c,v 1.1 2000/04/18 18:44:26 jason Exp $	*/
d1155 1
@


1.1
log
@split fxp into bus independent and dependent (pci) parts (cardbus to come)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.26 2000/04/18 03:40:55 jason Exp $	*/
d415 1
a415 1
	bcopy(enaddr, sc->arpcom.ac_enaddr, sizeof(enaddr));
@

