head	1.114;
access;
symbols
	OPENBSD_6_1:1.112.0.4
	OPENBSD_6_1_BASE:1.112
	OPENBSD_6_0:1.111.0.4
	OPENBSD_6_0_BASE:1.111
	OPENBSD_5_9:1.110.0.2
	OPENBSD_5_9_BASE:1.110
	OPENBSD_5_8:1.105.0.4
	OPENBSD_5_8_BASE:1.105
	OPENBSD_5_7:1.104.0.2
	OPENBSD_5_7_BASE:1.104
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.98.0.4
	OPENBSD_5_5_BASE:1.98
	OPENBSD_5_4:1.96.0.4
	OPENBSD_5_4_BASE:1.96
	OPENBSD_5_3:1.96.0.2
	OPENBSD_5_3_BASE:1.96
	OPENBSD_5_2:1.95.0.2
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.95
	OPENBSD_5_1:1.95.0.4
	OPENBSD_5_0:1.92.0.2
	OPENBSD_5_0_BASE:1.92
	OPENBSD_4_9:1.91.0.2
	OPENBSD_4_9_BASE:1.91
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.84.0.2
	OPENBSD_4_7_BASE:1.84
	OPENBSD_4_6:1.80.0.6
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.80.0.2
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.72.0.2
	OPENBSD_4_4_BASE:1.72
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.66.0.2
	OPENBSD_4_2_BASE:1.66
	OPENBSD_4_1:1.61.0.2
	OPENBSD_4_1_BASE:1.61
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16;
locks; strict;
comment	@ * @;


1.114
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.113;
commitid	zztPc3QpQPdWwQ6h;

1.113
date	2017.04.09.18.07.19;	author dhill;	state Exp;
branches;
next	1.112;
commitid	O6yENjmyJQKVKwHV;

1.112
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.111;
commitid	VyLWTsbepAOk7VQM;

1.111
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.110;
commitid	QHiEhS9DHyE6oiIr;

1.110
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.109;
commitid	1npmDuWgN1zBR6BQ;

1.109
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.108;
commitid	J9apD0jq2AjFmqZc;

1.108
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.107;
commitid	B0kwmVGiD5DVx4kv;

1.107
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.106;
commitid	YT6fyIEviv9qwbl6;

1.106
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.105;
commitid	p0v5tuE1Ch6fY0Nj;

1.105
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.104;
commitid	p4LJxGKbi0BU2cG6;

1.104
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.103;
commitid	Hly9lJn6CNMylcFu;

1.103
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.102;
commitid	yM2VFFhpDTeFQlve;

1.102
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.101;
commitid	LS2TNeCue5R9L67C;

1.101
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.100;
commitid	I19imNlAX05zJOED;

1.100
date	2014.07.10.11.34.48;	author stsp;	state Exp;
branches;
next	1.99;
commitid	tJr0LqV48q3NliAT;

1.99
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.98;

1.98
date	2013.11.26.09.50.32;	author mpi;	state Exp;
branches;
next	1.97;

1.97
date	2013.11.21.16.16.08;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2012.10.17.00.59.57;	author jsg;	state Exp;
branches;
next	1.95;

1.95
date	2012.01.29.12.33.36;	author stsp;	state Exp;
branches;
next	1.94;

1.94
date	2012.01.28.12.46.32;	author stsp;	state Exp;
branches;
next	1.93;

1.93
date	2011.10.14.17.08.10;	author stsp;	state Exp;
branches;
next	1.92;

1.92
date	2011.04.17.20.38.10;	author stsp;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2010.08.27.19.44.43;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.88;

1.88
date	2010.08.27.04.09.18;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2010.08.04.21.02.24;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2010.07.02.06.06.30;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.84;

1.84
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.83;

1.83
date	2009.09.13.14.42.52;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2009.07.31.11.18.09;	author blambert;	state Exp;
branches;
next	1.80;

1.80
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.79;

1.79
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.78;

1.78
date	2008.09.01.09.02.59;	author reyk;	state Exp;
branches;
next	1.77;

1.77
date	2008.08.29.11.15.32;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2008.08.27.10.01.18;	author damien;	state Exp;
branches;
next	1.75;

1.75
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2008.08.25.20.43.49;	author jmc;	state Exp;
branches;
next	1.73;

1.73
date	2008.08.14.16.02.24;	author damien;	state Exp;
branches;
next	1.72;

1.72
date	2008.07.30.07.43.01;	author reyk;	state Exp;
branches;
next	1.71;

1.71
date	2008.07.29.00.18.25;	author reyk;	state Exp;
branches;
next	1.70;

1.70
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.13.16.12.29;	author fgsch;	state Exp;
branches;
next	1.68;

1.68
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.18.00.46.41;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.06.21.41.32;	author reyk;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.09.16.41.14;	author reyk;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.13.14.44.41;	author reyk;	state Exp;
branches;
next	1.61;

1.61
date	2007.01.03.18.16.43;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2006.12.14.09.23.24;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2006.11.06.08.48.49;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.19.10.55.56;	author tom;	state Exp;
branches;
next	1.57;

1.57
date	2006.10.14.16.16.18;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2006.09.19.17.49.13;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2006.09.19.17.08.01;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2006.09.19.16.46.39;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2006.09.19.13.25.54;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.23.21.53.01;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.08.18.32.11;	author pedro;	state Exp;
branches;
next	1.48;

1.48
date	2006.04.20.20.29.56;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.25.22.41.42;	author djm;	state Exp;
branches;
next	1.46;

1.46
date	2006.02.20.20.12.13;	author damien;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2006.01.04.06.04.41;	author canacar;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.10.15.43.11;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.11.14.11.40;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.23.20.06.50;	author reyk;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.22.10.17.04;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.19.10.27.08;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.08.17.38.11;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.08.17.34.30;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.08.09.11.07;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.21.18.40.17;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.21.11.17.51;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.17.13.14.17;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.30.17.13.17;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.19.23.04.37;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.18.02.43.26;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.28.23.45.10;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.27.09.53.55;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.27.04.10.06;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.24.21.46.18;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.11.05.15.01;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.08.18.13.17;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.18.18.42.55;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.08.22.12.21;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.06.09.14.53;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.06.00.42.59;	author kevlo;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.05.17.10.43;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.03.08.06.14;	author uwe;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.02.22.09.31;	author uwe;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.19.17.27.46;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.18.21.37.56;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.11.17.45.28;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.10.08.30.56;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.10.03.12.30;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.03.16.39.54;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.03.14.36.38;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.01.02.19.30;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.17.21.02.24;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.03.19.59.18;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.31.01.00.23;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.23.09.39.28;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.11.20.11.28;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.14.05.49;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.02.02.45.37;	author reyk;	state Exp;
branches;
next	;

1.46.2.1
date	2006.05.09.18.41.17;	author brad;	state Exp;
branches;
next	;


desc
@@


1.114
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@/*      $OpenBSD: ath.c,v 1.113 2017/04/09 18:07:19 dhill Exp $  */
/*	$NetBSD: ath.c,v 1.37 2004/08/18 21:59:39 dyoung Exp $	*/

/*-
 * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
 *    redistribution must be conditioned upon including a substantially
 *    similar Disclaimer requirement for further binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGES.
 */

/*
 * Driver for the Atheros Wireless LAN controller.
 *
 * This software is derived from work of Atsushi Onoe; his contribution
 * is greatly appreciated. It has been modified for OpenBSD to use an
 * open source HAL instead of the original binary-only HAL. 
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/lock.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/timeout.h>
#include <sys/gpio.h>
#include <sys/endian.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_rssadapt.h>

#include <dev/pci/pcidevs.h>
#include <dev/gpio/gpiovar.h>

#include <dev/ic/athvar.h>

int	ath_init(struct ifnet *);
int	ath_init1(struct ath_softc *);
int	ath_intr1(struct ath_softc *);
void	ath_stop(struct ifnet *);
void	ath_start(struct ifnet *);
void	ath_reset(struct ath_softc *, int);
int	ath_media_change(struct ifnet *);
void	ath_watchdog(struct ifnet *);
int	ath_ioctl(struct ifnet *, u_long, caddr_t);
void	ath_fatal_proc(void *, int);
void	ath_rxorn_proc(void *, int);
void	ath_bmiss_proc(void *, int);
u_int   ath_chan2flags(struct ieee80211com *, struct ieee80211_channel *);
int	ath_initkeytable(struct ath_softc *);
void    ath_mcastfilter_accum(caddr_t, u_int32_t (*)[2]);
void    ath_mcastfilter_compute(struct ath_softc *, u_int32_t (*)[2]);
u_int32_t ath_calcrxfilter(struct ath_softc *);
void	ath_mode_init(struct ath_softc *);
#ifndef IEEE80211_STA_ONLY
int	ath_beacon_alloc(struct ath_softc *, struct ieee80211_node *);
void	ath_beacon_proc(void *, int);
void	ath_beacon_free(struct ath_softc *);
#endif
void	ath_beacon_config(struct ath_softc *);
int	ath_desc_alloc(struct ath_softc *);
void	ath_desc_free(struct ath_softc *);
struct ieee80211_node *ath_node_alloc(struct ieee80211com *);
struct mbuf *ath_getmbuf(int, int, u_int);
void	ath_node_free(struct ieee80211com *, struct ieee80211_node *);
void	ath_node_copy(struct ieee80211com *,
	    struct ieee80211_node *, const struct ieee80211_node *);
u_int8_t ath_node_getrssi(struct ieee80211com *,
	    const struct ieee80211_node *);
int	ath_rxbuf_init(struct ath_softc *, struct ath_buf *);
void	ath_rx_proc(void *, int);
int	ath_tx_start(struct ath_softc *, struct ieee80211_node *,
	    struct ath_buf *, struct mbuf *);
void	ath_tx_proc(void *, int);
int	ath_chan_set(struct ath_softc *, struct ieee80211_channel *);
void	ath_draintxq(struct ath_softc *);
void	ath_stoprecv(struct ath_softc *);
int	ath_startrecv(struct ath_softc *);
void	ath_next_scan(void *);
int	ath_set_slot_time(struct ath_softc *);
void	ath_calibrate(void *);
void	ath_ledstate(struct ath_softc *, enum ieee80211_state);
int	ath_newstate(struct ieee80211com *, enum ieee80211_state, int);
void	ath_newassoc(struct ieee80211com *,
	    struct ieee80211_node *, int);
int	ath_getchannels(struct ath_softc *, HAL_BOOL outdoor,
	    HAL_BOOL xchanmode);
int	ath_rate_setup(struct ath_softc *sc, u_int mode);
void	ath_setcurmode(struct ath_softc *, enum ieee80211_phymode);
void	ath_rssadapt_updatenode(void *, struct ieee80211_node *);
void	ath_rssadapt_updatestats(void *);
#ifndef IEEE80211_STA_ONLY
void	ath_recv_mgmt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, struct ieee80211_rxinfo *, int);
#endif
void	ath_disable(struct ath_softc *);

int	ath_gpio_attach(struct ath_softc *, u_int16_t);
int	ath_gpio_pin_read(void *, int);
void	ath_gpio_pin_write(void *, int, int);
void	ath_gpio_pin_ctl(void *, int, int);

#ifdef AR_DEBUG
void	ath_printrxbuf(struct ath_buf *, int);
void	ath_printtxbuf(struct ath_buf *, int);
int ath_debug = 0;
#endif

int ath_dwelltime = 200;		/* 5 channels/second */
int ath_calinterval = 30;		/* calibrate every 30 secs */
int ath_outdoor = AH_TRUE;		/* outdoor operation */
int ath_xchanmode = AH_TRUE;		/* enable extended channels */
int ath_softcrypto = 1;			/* 1=enable software crypto */

struct cfdriver ath_cd = {
	NULL, "ath", DV_IFNET
};

int
ath_activate(struct device *self, int act)
{
	struct ath_softc *sc = (struct ath_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING) {
			ath_stop(ifp);
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, act);
		}
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP) {
			ath_init(ifp);
			if (ifp->if_flags & IFF_RUNNING)
				ath_start(ifp);
		}
		break;
	}
	return 0;
}

int
ath_enable(struct ath_softc *sc)
{
	if (ATH_IS_ENABLED(sc) == 0) {
		if (sc->sc_enable != NULL && (*sc->sc_enable)(sc) != 0) {
			printf("%s: device enable failed\n",
				sc->sc_dev.dv_xname);
			return (EIO);
		}
		sc->sc_flags |= ATH_ENABLED;
	}
	return (0);
}

void
ath_disable(struct ath_softc *sc)
{
	if (!ATH_IS_ENABLED(sc))
		return;
	if (sc->sc_disable != NULL)
		(*sc->sc_disable)(sc);
	sc->sc_flags &= ~ATH_ENABLED;
}

int
ath_attach(u_int16_t devid, struct ath_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ath_hal *ah;
	HAL_STATUS status;
	HAL_TXQ_INFO qinfo;
	int error = 0, i;

	DPRINTF(ATH_DEBUG_ANY, ("%s: devid 0x%x\n", __func__, devid));

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	sc->sc_flags &= ~ATH_ATTACHED;	/* make sure that it's not attached */

	ah = ath_hal_attach(devid, sc, sc->sc_st, sc->sc_sh,
	    sc->sc_pcie, &status);
	if (ah == NULL) {
		printf("%s: unable to attach hardware; HAL status %d\n",
			ifp->if_xname, status);
		error = ENXIO;
		goto bad;
	}
	if (ah->ah_abi != HAL_ABI_VERSION) {
		printf("%s: HAL ABI mismatch detected (0x%x != 0x%x)\n",
			ifp->if_xname, ah->ah_abi, HAL_ABI_VERSION);
		error = ENXIO;
		goto bad;
	}

	if (ah->ah_single_chip == AH_TRUE) {
		printf("%s: AR%s %u.%u phy %u.%u rf %u.%u", ifp->if_xname,
		    ar5k_printver(AR5K_VERSION_DEV, devid),
		    ah->ah_mac_version, ah->ah_mac_revision,
		    ah->ah_phy_revision >> 4, ah->ah_phy_revision & 0xf,
		    ah->ah_radio_5ghz_revision >> 4,
		    ah->ah_radio_5ghz_revision & 0xf);
	} else {
		printf("%s: AR%s %u.%u phy %u.%u", ifp->if_xname,
		    ar5k_printver(AR5K_VERSION_VER, ah->ah_mac_srev),
		    ah->ah_mac_version, ah->ah_mac_revision,
		    ah->ah_phy_revision >> 4, ah->ah_phy_revision & 0xf);
		printf(" rf%s %u.%u",
		    ar5k_printver(AR5K_VERSION_RAD, ah->ah_radio_5ghz_revision),
		    ah->ah_radio_5ghz_revision >> 4,
		    ah->ah_radio_5ghz_revision & 0xf);
		if (ah->ah_radio_2ghz_revision != 0) {
			printf(" rf%s %u.%u",
			    ar5k_printver(AR5K_VERSION_RAD,
			    ah->ah_radio_2ghz_revision),
			    ah->ah_radio_2ghz_revision >> 4,
			    ah->ah_radio_2ghz_revision & 0xf);
		}
	}
	if (ah->ah_ee_version == AR5K_EEPROM_VERSION_4_7)
		printf(" eeprom 4.7");
	else
		printf(" eeprom %1x.%1x", ah->ah_ee_version >> 12,
		    ah->ah_ee_version & 0xff);

#if 0
	if (ah->ah_radio_5ghz_revision >= AR5K_SREV_RAD_UNSUPP ||
	    ah->ah_radio_2ghz_revision >= AR5K_SREV_RAD_UNSUPP) {
		printf(": RF radio not supported\n");
		error = EOPNOTSUPP;
		goto bad;
	}
#endif

	sc->sc_ah = ah;
	sc->sc_invalid = 0;	/* ready to go, enable interrupt handling */

	/*
	 * Get regulation domain either stored in the EEPROM or defined
	 * as the default value. Some devices are known to have broken
	 * regulation domain values in their EEPROM.
	 */
	ath_hal_get_regdomain(ah, &ah->ah_regdomain);

	/*
	 * Construct channel list based on the current regulation domain.
	 */
	error = ath_getchannels(sc, ath_outdoor, ath_xchanmode);
	if (error != 0)
		goto bad;

	/*
	 * Setup rate tables for all potential media types.
	 */
	ath_rate_setup(sc, IEEE80211_MODE_11A);
	ath_rate_setup(sc, IEEE80211_MODE_11B);
	ath_rate_setup(sc, IEEE80211_MODE_11G);

	error = ath_desc_alloc(sc);
	if (error != 0) {
		printf(": failed to allocate descriptors: %d\n", error);
		goto bad;
	}
	timeout_set(&sc->sc_scan_to, ath_next_scan, sc);
	timeout_set(&sc->sc_cal_to, ath_calibrate, sc);
	timeout_set(&sc->sc_rssadapt_to, ath_rssadapt_updatestats, sc);

#ifdef __FreeBSD__
	ATH_TXBUF_LOCK_INIT(sc);
	ATH_TXQ_LOCK_INIT(sc);
#endif

	ATH_TASK_INIT(&sc->sc_txtask, ath_tx_proc, sc);
	ATH_TASK_INIT(&sc->sc_rxtask, ath_rx_proc, sc);
	ATH_TASK_INIT(&sc->sc_rxorntask, ath_rxorn_proc, sc);
	ATH_TASK_INIT(&sc->sc_fataltask, ath_fatal_proc, sc);
	ATH_TASK_INIT(&sc->sc_bmisstask, ath_bmiss_proc, sc);
#ifndef IEEE80211_STA_ONLY
	ATH_TASK_INIT(&sc->sc_swbatask, ath_beacon_proc, sc);
#endif

	/*
	 * For now just pre-allocate one data queue and one
	 * beacon queue.  Note that the HAL handles resetting
	 * them at the needed time.  Eventually we'll want to
	 * allocate more tx queues for splitting management
	 * frames and for QOS support.
	 */
	sc->sc_bhalq = ath_hal_setup_tx_queue(ah, HAL_TX_QUEUE_BEACON, NULL);
	if (sc->sc_bhalq == (u_int) -1) {
		printf(": unable to setup a beacon xmit queue!\n");
		goto bad2;
	}

	for (i = 0; i <= HAL_TX_QUEUE_ID_DATA_MAX; i++) {
		bzero(&qinfo, sizeof(qinfo));
		qinfo.tqi_type = HAL_TX_QUEUE_DATA;
		qinfo.tqi_subtype = i; /* should be mapped to WME types */
		sc->sc_txhalq[i] = ath_hal_setup_tx_queue(ah,
		    HAL_TX_QUEUE_DATA, &qinfo);
		if (sc->sc_txhalq[i] == (u_int) -1) {
			printf(": unable to setup a data xmit queue %u!\n", i);
			goto bad2;
		}
	}

	ifp->if_softc = sc;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	ifp->if_start = ath_start;
	ifp->if_watchdog = ath_watchdog;
	ifp->if_ioctl = ath_ioctl;
#ifndef __OpenBSD__
	ifp->if_stop = ath_stop;		/* XXX */
#endif
	IFQ_SET_MAXLEN(&ifp->if_snd, ATH_TXBUF * ATH_TXDESC);

	ic->ic_softc = sc;
	ic->ic_newassoc = ath_newassoc;
	/* XXX not right but it's not used anywhere important */
	ic->ic_phytype = IEEE80211_T_OFDM;
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_caps = IEEE80211_C_WEP	/* wep supported */
	    | IEEE80211_C_PMGT		/* power management */
#ifndef IEEE80211_STA_ONLY
	    | IEEE80211_C_IBSS		/* ibss, nee adhoc, mode */
	    | IEEE80211_C_HOSTAP	/* hostap mode */
#endif
	    | IEEE80211_C_MONITOR	/* monitor mode */
	    | IEEE80211_C_SHSLOT	/* short slot time supported */
	    | IEEE80211_C_SHPREAMBLE;	/* short preamble supported */
	if (ath_softcrypto)
		ic->ic_caps |= IEEE80211_C_RSN;	/* wpa/rsn supported */

	/*
	 * Not all chips have the VEOL support we want to use with
	 * IBSS beacon; check here for it.
	 */
	sc->sc_veol = ath_hal_has_veol(ah);

	/* get mac address from hardware */
	ath_hal_get_lladdr(ah, ic->ic_myaddr);

	if_attach(ifp);

	/* call MI attach routine. */
	ieee80211_ifattach(ifp);

	/* override default methods */
	ic->ic_node_alloc = ath_node_alloc;
	sc->sc_node_free = ic->ic_node_free;
	ic->ic_node_free = ath_node_free;
	sc->sc_node_copy = ic->ic_node_copy;
	ic->ic_node_copy = ath_node_copy;
	ic->ic_node_getrssi = ath_node_getrssi;
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = ath_newstate;
#ifndef IEEE80211_STA_ONLY
	sc->sc_recv_mgmt = ic->ic_recv_mgmt;
	ic->ic_recv_mgmt = ath_recv_mgmt;
#endif
	ic->ic_max_rssi = AR5K_MAX_RSSI;
	bcopy(etherbroadcastaddr, sc->sc_broadcast_addr, IEEE80211_ADDR_LEN);

	/* complete initialization */
	ieee80211_media_init(ifp, ath_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof(sc->sc_rxtapu);
	bzero(&sc->sc_rxtapu, sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(ATH_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof(sc->sc_txtapu);
	bzero(&sc->sc_txtapu, sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(ATH_TX_RADIOTAP_PRESENT);
#endif

	sc->sc_flags |= ATH_ATTACHED;

	/*
	 * Print regulation domain and the mac address. The regulation domain
	 * will be marked with a * if the EEPROM value has been overwritten.
	 */
	printf(", %s%s, address %s\n",
	    ieee80211_regdomain2name(ah->ah_regdomain),
	    ah->ah_regdomain != ah->ah_regdomain_hw ? "*" : "",
	    ether_sprintf(ic->ic_myaddr));

	if (ath_gpio_attach(sc, devid) == 0)
		sc->sc_flags |= ATH_GPIO;

	return 0;
bad2:
	ath_desc_free(sc);
bad:
	if (ah)
		ath_hal_detach(ah);
	sc->sc_invalid = 1;
	return error;
}

int
ath_detach(struct ath_softc *sc, int flags)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	if ((sc->sc_flags & ATH_ATTACHED) == 0)
		return (0);

	config_detach_children(&sc->sc_dev, flags);

	DPRINTF(ATH_DEBUG_ANY, ("%s: if_flags %x\n", __func__, ifp->if_flags));

	timeout_del(&sc->sc_scan_to);
	timeout_del(&sc->sc_cal_to);
	timeout_del(&sc->sc_rssadapt_to);

	s = splnet();
	ath_stop(ifp);
	ath_desc_free(sc);
	ath_hal_detach(sc->sc_ah);

	ieee80211_ifdetach(ifp);
	if_detach(ifp);

	splx(s);
#ifdef __FreeBSD__
	ATH_TXBUF_LOCK_DESTROY(sc);
	ATH_TXQ_LOCK_DESTROY(sc);
#endif

	return 0;
}

int
ath_intr(void *arg)
{
	return ath_intr1((struct ath_softc *)arg);
}

int
ath_intr1(struct ath_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ath_hal *ah = sc->sc_ah;
	HAL_INT status;

	if (sc->sc_invalid) {
		/*
		 * The hardware is not ready/present, don't touch anything.
		 * Note this can happen early on if the IRQ is shared.
		 */
		DPRINTF(ATH_DEBUG_ANY, ("%s: invalid; ignored\n", __func__));
		return 0;
	}
	if (!ath_hal_is_intr_pending(ah))		/* shared irq, not for us */
		return 0;
	if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) != (IFF_RUNNING|IFF_UP)) {
		DPRINTF(ATH_DEBUG_ANY, ("%s: if_flags 0x%x\n",
		    __func__, ifp->if_flags));
		ath_hal_get_isr(ah, &status);	/* clear ISR */
		ath_hal_set_intr(ah, 0);		/* disable further intr's */
		return 1; /* XXX */
	}
	ath_hal_get_isr(ah, &status);		/* NB: clears ISR too */
	DPRINTF(ATH_DEBUG_INTR, ("%s: status 0x%x\n", __func__, status));
	status &= sc->sc_imask;			/* discard unasked for bits */
	if (status & HAL_INT_FATAL) {
		sc->sc_stats.ast_hardware++;
		ath_hal_set_intr(ah, 0);		/* disable intr's until reset */
		ATH_TASK_RUN_OR_ENQUEUE(&sc->sc_fataltask);
	} else if (status & HAL_INT_RXORN) {
		sc->sc_stats.ast_rxorn++;
		ath_hal_set_intr(ah, 0);		/* disable intr's until reset */
		ATH_TASK_RUN_OR_ENQUEUE(&sc->sc_rxorntask);
	} else if (status & HAL_INT_MIB) {
		DPRINTF(ATH_DEBUG_INTR,
		    ("%s: resetting MIB counters\n", __func__));
		sc->sc_stats.ast_mib++;
		ath_hal_update_mib_counters(ah, &sc->sc_mib_stats);
	} else {
		if (status & HAL_INT_RXEOL) {
			/*
			 * NB: the hardware should re-read the link when
			 *     RXE bit is written, but it doesn't work at
			 *     least on older hardware revs.
			 */
			sc->sc_stats.ast_rxeol++;
			sc->sc_rxlink = NULL;
		}
		if (status & HAL_INT_TXURN) {
			sc->sc_stats.ast_txurn++;
			/* bump tx trigger level */
			ath_hal_update_tx_triglevel(ah, AH_TRUE);
		}
		if (status & HAL_INT_RX)
			ATH_TASK_RUN_OR_ENQUEUE(&sc->sc_rxtask);
		if (status & HAL_INT_TX)
			ATH_TASK_RUN_OR_ENQUEUE(&sc->sc_txtask);
		if (status & HAL_INT_SWBA)
			ATH_TASK_RUN_OR_ENQUEUE(&sc->sc_swbatask);
		if (status & HAL_INT_BMISS) {
			sc->sc_stats.ast_bmiss++;
			ATH_TASK_RUN_OR_ENQUEUE(&sc->sc_bmisstask);
		}
	}
	return 1;
}

void
ath_fatal_proc(void *arg, int pending)
{
	struct ath_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	if (ifp->if_flags & IFF_DEBUG)
		printf("%s: hardware error; resetting\n", ifp->if_xname);
	ath_reset(sc, 1);
}

void
ath_rxorn_proc(void *arg, int pending)
{
	struct ath_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	if (ifp->if_flags & IFF_DEBUG)
		printf("%s: rx FIFO overrun; resetting\n", ifp->if_xname);
	ath_reset(sc, 1);
}

void
ath_bmiss_proc(void *arg, int pending)
{
	struct ath_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;

	DPRINTF(ATH_DEBUG_ANY, ("%s: pending %u\n", __func__, pending));
	if (ic->ic_opmode != IEEE80211_M_STA)
		return;
	if (ic->ic_state == IEEE80211_S_RUN) {
		/*
		 * Rather than go directly to scan state, try to
		 * reassociate first.  If that fails then the state
		 * machine will drop us into scanning after timing
		 * out waiting for a probe response.
		 */
		ieee80211_new_state(ic, IEEE80211_S_ASSOC, -1);
	}
}

u_int
ath_chan2flags(struct ieee80211com *ic, struct ieee80211_channel *chan)
{
	enum ieee80211_phymode mode = ieee80211_chan2mode(ic, chan);

	switch (mode) {
	case IEEE80211_MODE_AUTO:
		return 0;
	case IEEE80211_MODE_11A:
		return CHANNEL_A;
	case IEEE80211_MODE_11B:
		return CHANNEL_B;
	case IEEE80211_MODE_11G:
		return CHANNEL_G;
	default:
		panic("%s: unsupported mode %d", __func__, mode);
		return 0;
	}
}

int
ath_init(struct ifnet *ifp)
{
	return ath_init1((struct ath_softc *)ifp->if_softc);
}

int
ath_init1(struct ath_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_node *ni;
	enum ieee80211_phymode mode;
	struct ath_hal *ah = sc->sc_ah;
	HAL_STATUS status;
	HAL_CHANNEL hchan;
	int error = 0, s;

	DPRINTF(ATH_DEBUG_ANY, ("%s: if_flags 0x%x\n",
	    __func__, ifp->if_flags));

	if ((error = ath_enable(sc)) != 0)
		return error;

	s = splnet();
	/*
	 * Stop anything previously setup.  This is safe
	 * whether this is the first time through or not.
	 */
	ath_stop(ifp);

	/*
	 * Reset the link layer address to the latest value.
	 */
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	ath_hal_set_lladdr(ah, ic->ic_myaddr);

	/*
	 * The basic interface to setting the hardware in a good
	 * state is ``reset''.  On return the hardware is known to
	 * be powered up and with interrupts disabled.  This must
	 * be followed by initialization of the appropriate bits
	 * and then setup of the interrupt mask.
	 */
	hchan.channel = ic->ic_ibss_chan->ic_freq;
	hchan.channelFlags = ath_chan2flags(ic, ic->ic_ibss_chan);
	if (!ath_hal_reset(ah, ic->ic_opmode, &hchan, AH_TRUE, &status)) {
		printf("%s: unable to reset hardware; hal status %u\n",
			ifp->if_xname, status);
		error = EIO;
		goto done;
	}
	ath_set_slot_time(sc);

	if ((error = ath_initkeytable(sc)) != 0) {
		printf("%s: unable to reset the key cache\n",
		    ifp->if_xname);
		goto done;
	}

	if ((error = ath_startrecv(sc)) != 0) {
		printf("%s: unable to start recv logic\n", ifp->if_xname);
		goto done;
	}

	/*
	 * Enable interrupts.
	 */
	sc->sc_imask = HAL_INT_RX | HAL_INT_TX
	    | HAL_INT_RXEOL | HAL_INT_RXORN
	    | HAL_INT_FATAL | HAL_INT_GLOBAL;
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP)
		sc->sc_imask |= HAL_INT_MIB;
#endif
	ath_hal_set_intr(ah, sc->sc_imask);

	ifp->if_flags |= IFF_RUNNING;
	ic->ic_state = IEEE80211_S_INIT;

	/*
	 * The hardware should be ready to go now so it's safe
	 * to kick the 802.11 state machine as it's likely to
	 * immediately call back to us to send mgmt frames.
	 */
	ni = ic->ic_bss;
	ni->ni_chan = ic->ic_ibss_chan;
	mode = ieee80211_chan2mode(ic, ni->ni_chan);
	if (mode != sc->sc_curmode)
		ath_setcurmode(sc, mode);
	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	} else {
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	}
done:
	splx(s);
	return error;
}

void
ath_stop(struct ifnet *ifp)
{
	struct ieee80211com *ic = (struct ieee80211com *) ifp;
	struct ath_softc *sc = ifp->if_softc;
	struct ath_hal *ah = sc->sc_ah;
	int s;

	DPRINTF(ATH_DEBUG_ANY, ("%s: invalid %u if_flags 0x%x\n",
	    __func__, sc->sc_invalid, ifp->if_flags));

	s = splnet();
	if (ifp->if_flags & IFF_RUNNING) {
		/*
		 * Shutdown the hardware and driver:
		 *    disable interrupts
		 *    turn off timers
		 *    clear transmit machinery
		 *    clear receive machinery
		 *    drain and release tx queues
		 *    reclaim beacon resources
		 *    reset 802.11 state machine
		 *    power down hardware
		 *
		 * Note that some of this work is not possible if the
		 * hardware is gone (invalid).
		 */
		ifp->if_flags &= ~IFF_RUNNING;
		ifp->if_timer = 0;
		if (!sc->sc_invalid)
			ath_hal_set_intr(ah, 0);
		ath_draintxq(sc);
		if (!sc->sc_invalid) {
			ath_stoprecv(sc);
		} else {
			sc->sc_rxlink = NULL;
		}
		IFQ_PURGE(&ifp->if_snd);
#ifndef IEEE80211_STA_ONLY
		ath_beacon_free(sc);
#endif
		ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
		if (!sc->sc_invalid) {
			ath_hal_set_power(ah, HAL_PM_FULL_SLEEP, 0);
		}
		ath_disable(sc);
	}
	splx(s);
}

/*
 * Reset the hardware w/o losing operational state.  This is
 * basically a more efficient way of doing ath_stop, ath_init,
 * followed by state transitions to the current 802.11
 * operational state.  Used to recover from errors rx overrun
 * and to reset the hardware when rf gain settings must be reset.
 */
void
ath_reset(struct ath_softc *sc, int full)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ath_hal *ah = sc->sc_ah;
	struct ieee80211_channel *c;
	HAL_STATUS status;
	HAL_CHANNEL hchan;

	/*
	 * Convert to a HAL channel description with the flags
	 * constrained to reflect the current operating mode.
	 */
	c = ic->ic_ibss_chan;
	hchan.channel = c->ic_freq;
	hchan.channelFlags = ath_chan2flags(ic, c);

	ath_hal_set_intr(ah, 0);		/* disable interrupts */
	ath_draintxq(sc);		/* stop xmit side */
	ath_stoprecv(sc);		/* stop recv side */
	/* NB: indicate channel change so we do a full reset */
	if (!ath_hal_reset(ah, ic->ic_opmode, &hchan,
	    full ? AH_TRUE : AH_FALSE, &status)) {
		printf("%s: %s: unable to reset hardware; hal status %u\n",
			ifp->if_xname, __func__, status);
	}
	ath_set_slot_time(sc);
	/* In case channel changed, save as a node channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	ath_hal_set_intr(ah, sc->sc_imask);
	if (ath_startrecv(sc) != 0)	/* restart recv */
		printf("%s: %s: unable to start recv logic\n", ifp->if_xname,
		    __func__);
	ath_start(ifp);			/* restart xmit */
	if (ic->ic_state == IEEE80211_S_RUN)
		ath_beacon_config(sc);	/* restart beacons */
}

void
ath_start(struct ifnet *ifp)
{
	struct ath_softc *sc = ifp->if_softc;
	struct ath_hal *ah = sc->sc_ah;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct ath_buf *bf;
	struct mbuf *m;
	struct ieee80211_frame *wh;
	int s;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd) ||
	    sc->sc_invalid)
		return;
	for (;;) {
		/*
		 * Grab a TX buffer and associated resources.
		 */
		s = splnet();
		bf = TAILQ_FIRST(&sc->sc_txbuf);
		if (bf != NULL)
			TAILQ_REMOVE(&sc->sc_txbuf, bf, bf_list);
		splx(s);
		if (bf == NULL) {
			DPRINTF(ATH_DEBUG_ANY, ("%s: out of xmit buffers\n",
			    __func__));
			sc->sc_stats.ast_tx_qstop++;
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		/*
		 * Poll the management queue for frames; they
		 * have priority over normal data frames.
		 */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m == NULL) {
			/*
			 * No data frames go out unless we're associated.
			 */
			if (ic->ic_state != IEEE80211_S_RUN) {
				DPRINTF(ATH_DEBUG_ANY,
				    ("%s: ignore data packet, state %u\n",
				    __func__, ic->ic_state));
				sc->sc_stats.ast_tx_discard++;
				s = splnet();
				TAILQ_INSERT_TAIL(&sc->sc_txbuf, bf, bf_list);
				splx(s);
				break;
			}
			IFQ_DEQUEUE(&ifp->if_snd, m);
			if (m == NULL) {
				s = splnet();
				TAILQ_INSERT_TAIL(&sc->sc_txbuf, bf, bf_list);
				splx(s);
				break;
			}

#if NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

			/*
			 * Encapsulate the packet in prep for transmission.
			 */
			m = ieee80211_encap(ifp, m, &ni);
			if (m == NULL) {
				DPRINTF(ATH_DEBUG_ANY,
				    ("%s: encapsulation failure\n",
				    __func__));
				sc->sc_stats.ast_tx_encap++;
				goto bad;
			}
			wh = mtod(m, struct ieee80211_frame *);
		} else {
			ni = m->m_pkthdr.ph_cookie;

			wh = mtod(m, struct ieee80211_frame *);
			if ((wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
			    IEEE80211_FC0_SUBTYPE_PROBE_RESP) {
				/* fill time stamp */
				u_int64_t tsf;
				u_int32_t *tstamp;

				tsf = ath_hal_get_tsf64(ah);
				/* XXX: adjust 100us delay to xmit */
				tsf += 100;
				tstamp = (u_int32_t *)&wh[1];
				tstamp[0] = htole32(tsf & 0xffffffff);
				tstamp[1] = htole32(tsf >> 32);
			}
			sc->sc_stats.ast_tx_mgmt++;
		}

		if (ath_tx_start(sc, ni, bf, m)) {
	bad:
			s = splnet();
			TAILQ_INSERT_TAIL(&sc->sc_txbuf, bf, bf_list);
			splx(s);
			ifp->if_oerrors++;
			if (ni != NULL)
				ieee80211_release_node(ic, ni);
			continue;
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

int
ath_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) ==
		    (IFF_RUNNING|IFF_UP))
			ath_init(ifp);		/* XXX lose error */
		error = 0;
	}
	return error;
}

void
ath_watchdog(struct ifnet *ifp)
{
	struct ath_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;
	if ((ifp->if_flags & IFF_RUNNING) == 0 || sc->sc_invalid)
		return;
	if (sc->sc_tx_timer) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", ifp->if_xname);
			ath_reset(sc, 1);
			ifp->if_oerrors++;
			sc->sc_stats.ast_watchdog++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
ath_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ath_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr = (struct ifreq *)data;
	int error = 0, s;

	s = splnet();
	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING) {
				/*
				 * To avoid rescanning another access point,
				 * do not call ath_init() here.  Instead,
				 * only reflect promisc mode settings.
				 */
				ath_mode_init(sc);
			} else {
				/*
				 * Beware of being called during detach to
				 * reset promiscuous mode.  In that case we
				 * will still be marked UP but not RUNNING.
				 * However trying to re-init the interface
				 * is the wrong thing to do as we've already
				 * torn down much of our state.  There's
				 * probably a better way to deal with this.
				 */
				if (!sc->sc_invalid)
					ath_init(ifp);	/* XXX lose error */
			}
		} else
			ath_stop(ifp);
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
#ifdef __FreeBSD__
		/*
		 * The upper layer has already installed/removed
		 * the multicast address(es), just recalculate the
		 * multicast filter for the card.
		 */
		if (ifp->if_flags & IFF_RUNNING)
			ath_mode_init(sc);
#endif
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ic.ic_ac) :
		    ether_delmulti(ifr, &sc->sc_ic.ic_ac);
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				ath_mode_init(sc);
			error = 0;
		}
		break;
	case SIOCGATHSTATS:
		error = copyout(&sc->sc_stats,
		    ifr->ifr_data, sizeof (sc->sc_stats));
		break;
	default:
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET) {
			if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) ==
			    (IFF_RUNNING|IFF_UP)) {
				if (ic->ic_opmode != IEEE80211_M_MONITOR)
					ath_init(ifp);	/* XXX lose error */
				else
					ath_reset(sc, 1);
			}
			error = 0;
		}
		break;
	}
	splx(s);
	return error;
}

/*
 * Fill the hardware key cache with key entries.
 */
int
ath_initkeytable(struct ath_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ath_hal *ah = sc->sc_ah;
	int i;

	if (ath_softcrypto) {
		/*
		 * Disable the hardware crypto engine and reset the key cache
		 * to allow software crypto operation for WEP/RSN/WPA2
		 */
		if (ic->ic_flags & (IEEE80211_F_WEPON|IEEE80211_F_RSNON))
			(void)ath_hal_softcrypto(ah, AH_TRUE);
		else
			(void)ath_hal_softcrypto(ah, AH_FALSE);
		return (0);
	}

	/* WEP is disabled, we only support WEP in hardware yet */
	if ((ic->ic_flags & IEEE80211_F_WEPON) == 0)
		return (0);

	/*
	 * Setup the hardware after reset: the key cache is filled as
	 * needed and the receive engine is set going.  Frame transmit
	 * is handled entirely in the frame output path; there's nothing
	 * to do here except setup the interrupt mask.
	 */

	/* XXX maybe should reset all keys when !WEPON */
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		struct ieee80211_key *k = &ic->ic_nw_keys[i];
		if (k->k_len == 0)
			ath_hal_reset_key(ah, i);
		else {
			HAL_KEYVAL hk;

			bzero(&hk, sizeof(hk));
			/*
			 * Pad the key to a supported key length. It
			 * is always a good idea to use full-length
			 * keys without padded zeros but this seems
			 * to be the default behaviour used by many
			 * implementations.
			 */
			if (k->k_cipher == IEEE80211_CIPHER_WEP40)
				hk.wk_len = AR5K_KEYVAL_LENGTH_40;
			else if (k->k_cipher == IEEE80211_CIPHER_WEP104)
				hk.wk_len = AR5K_KEYVAL_LENGTH_104;
			else
				return (EINVAL);
			bcopy(k->k_key, hk.wk_key, hk.wk_len);

			if (ath_hal_set_key(ah, i, &hk) != AH_TRUE)
				return (EINVAL);
		}
	}

	return (0);
}

void
ath_mcastfilter_accum(caddr_t dl, u_int32_t (*mfilt)[2])
{
	u_int32_t val;
	u_int8_t pos;

	val = LE_READ_4(dl + 0);
	pos = (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ val;
	val = LE_READ_4(dl + 3);
	pos ^= (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ val;
	pos &= 0x3f;
	(*mfilt)[pos / 32] |= (1 << (pos % 32));
}

void
ath_mcastfilter_compute(struct ath_softc *sc, u_int32_t (*mfilt)[2])
{
	struct arpcom *ac = &sc->sc_ic.ic_ac;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct ether_multi *enm;
	struct ether_multistep estep;

	if (ac->ac_multirangecnt > 0) {
		/* XXX Punt on ranges. */
		(*mfilt)[0] = (*mfilt)[1] = ~((u_int32_t)0);
		ifp->if_flags |= IFF_ALLMULTI;
		return;
	}

	ETHER_FIRST_MULTI(estep, ac, enm);
	while (enm != NULL) {
		ath_mcastfilter_accum(enm->enm_addrlo, mfilt);
		ETHER_NEXT_MULTI(estep, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
}

/*
 * Calculate the receive filter according to the
 * operating mode and state:
 *
 * o always accept unicast, broadcast, and multicast traffic
 * o maintain current state of phy error reception
 * o probe request frames are accepted only when operating in
 *   hostap, adhoc, or monitor modes
 * o enable promiscuous mode according to the interface state
 * o accept beacons:
 *   - when operating in adhoc mode so the 802.11 layer creates
 *     node table entries for peers,
 *   - when operating in station mode for collecting rssi data when
 *     the station is otherwise quiet, or
 *   - when scanning
 */
u_int32_t
ath_calcrxfilter(struct ath_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ath_hal *ah = sc->sc_ah;
	struct ifnet *ifp = &ic->ic_if;
	u_int32_t rfilt;

	rfilt = (ath_hal_get_rx_filter(ah) & HAL_RX_FILTER_PHYERR)
	    | HAL_RX_FILTER_UCAST | HAL_RX_FILTER_BCAST | HAL_RX_FILTER_MCAST;
	if (ic->ic_opmode != IEEE80211_M_STA)
		rfilt |= HAL_RX_FILTER_PROBEREQ;
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode != IEEE80211_M_AHDEMO)
#endif
		rfilt |= HAL_RX_FILTER_BEACON;
	if (ifp->if_flags & IFF_PROMISC)
		rfilt |= HAL_RX_FILTER_PROM;
	return rfilt;
}

void
ath_mode_init(struct ath_softc *sc)
{
	struct ath_hal *ah = sc->sc_ah;
	u_int32_t rfilt, mfilt[2];

	/* configure rx filter */
	rfilt = ath_calcrxfilter(sc);
	ath_hal_set_rx_filter(ah, rfilt);

	/* configure operational mode */
	ath_hal_set_opmode(ah);

	/* calculate and install multicast filter */
	mfilt[0] = mfilt[1] = 0;
	ath_mcastfilter_compute(sc, &mfilt);
	ath_hal_set_mcast_filter(ah, mfilt[0], mfilt[1]);
	DPRINTF(ATH_DEBUG_MODE, ("%s: RX filter 0x%x, MC filter %08x:%08x\n",
	    __func__, rfilt, mfilt[0], mfilt[1]));
}

struct mbuf *
ath_getmbuf(int flags, int type, u_int pktlen)
{
	struct mbuf *m;

	KASSERT(pktlen <= MCLBYTES, ("802.11 packet too large: %u", pktlen));
#ifdef __FreeBSD__
	if (pktlen <= MHLEN) {
		MGETHDR(m, flags, type);
	} else {
		m = m_getcl(flags, type, M_PKTHDR);
	}
#else
	MGETHDR(m, flags, type);
	if (m != NULL && pktlen > MHLEN) {
		MCLGET(m, flags);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			m = NULL;
		}
	}
#endif
	return m;
}

#ifndef IEEE80211_STA_ONLY
int
ath_beacon_alloc(struct ath_softc *sc, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ath_hal *ah = sc->sc_ah;
	struct ath_buf *bf;
	struct ath_desc *ds;
	struct mbuf *m;
	int error;
	u_int8_t rate;
	const HAL_RATE_TABLE *rt;
	u_int flags = 0;

	bf = sc->sc_bcbuf;
	if (bf->bf_m != NULL) {
		bus_dmamap_unload(sc->sc_dmat, bf->bf_dmamap);
		m_freem(bf->bf_m);
		bf->bf_m = NULL;
		bf->bf_node = NULL;
	}
	/*
	 * NB: the beacon data buffer must be 32-bit aligned;
	 * we assume the mbuf routines will return us something
	 * with this alignment (perhaps should assert).
	 */
	m = ieee80211_beacon_alloc(ic, ni);
	if (m == NULL) {
		DPRINTF(ATH_DEBUG_BEACON, ("%s: cannot get mbuf/cluster\n",
		    __func__));
		sc->sc_stats.ast_be_nombuf++;
		return ENOMEM;
	}

	DPRINTF(ATH_DEBUG_BEACON, ("%s: m %p len %u\n", __func__, m, m->m_len));
	error = bus_dmamap_load_mbuf(sc->sc_dmat, bf->bf_dmamap, m,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		m_freem(m);
		return error;
	}
	KASSERT(bf->bf_nseg == 1,
		("%s: multi-segment packet; nseg %u", __func__, bf->bf_nseg));
	bf->bf_m = m;

	/* setup descriptors */
	ds = bf->bf_desc;
	bzero(ds, sizeof(struct ath_desc));

	if (ic->ic_opmode == IEEE80211_M_IBSS && sc->sc_veol) {
		ds->ds_link = bf->bf_daddr;	/* link to self */
		flags |= HAL_TXDESC_VEOL;
	} else {
		ds->ds_link = 0;
	}
	ds->ds_data = bf->bf_segs[0].ds_addr;

	DPRINTF(ATH_DEBUG_ANY, ("%s: segaddr %p seglen %u\n", __func__,
	    (caddr_t)bf->bf_segs[0].ds_addr, (u_int)bf->bf_segs[0].ds_len));

	/*
	 * Calculate rate code.
	 * XXX everything at min xmit rate
	 */
	rt = sc->sc_currates;
	KASSERT(rt != NULL, ("no rate table, mode %u", sc->sc_curmode));
	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE) {
		rate = rt->info[0].rateCode | rt->info[0].shortPreamble;
	} else {
		rate = rt->info[0].rateCode;
	}

	flags = HAL_TXDESC_NOACK;
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		flags |= HAL_TXDESC_VEOL;

	if (!ath_hal_setup_tx_desc(ah, ds
		, m->m_pkthdr.len + IEEE80211_CRC_LEN	/* packet length */
		, sizeof(struct ieee80211_frame)	/* header length */
		, HAL_PKT_TYPE_BEACON		/* Atheros packet type */
		, 60				/* txpower XXX */
		, rate, 1			/* series 0 rate/tries */
		, HAL_TXKEYIX_INVALID		/* no encryption */
		, 0				/* antenna mode */
		, flags				/* no ack for beacons */
		, 0				/* rts/cts rate */
		, 0				/* rts/cts duration */
	)) {
		printf("%s: ath_hal_setup_tx_desc failed\n", __func__);
		return -1;
	}
	/* NB: beacon's BufLen must be a multiple of 4 bytes */
	/* XXX verify mbuf data area covers this roundup */
	if (!ath_hal_fill_tx_desc(ah, ds
		, roundup(bf->bf_segs[0].ds_len, 4)	/* buffer length */
		, AH_TRUE				/* first segment */
		, AH_TRUE				/* last segment */
	)) {
		printf("%s: ath_hal_fill_tx_desc failed\n", __func__);
		return -1;
	}

	/* XXX it is not appropriate to bus_dmamap_sync? -dcy */

	return 0;
}

void
ath_beacon_proc(void *arg, int pending)
{
	struct ath_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ath_buf *bf = sc->sc_bcbuf;
	struct ath_hal *ah = sc->sc_ah;

	DPRINTF(ATH_DEBUG_BEACON_PROC, ("%s: pending %u\n", __func__, pending));
	if (ic->ic_opmode == IEEE80211_M_STA ||
	    bf == NULL || bf->bf_m == NULL) {
		DPRINTF(ATH_DEBUG_ANY, ("%s: ic_flags=%x bf=%p bf_m=%p\n",
		    __func__, ic->ic_flags, bf, bf ? bf->bf_m : NULL));
		return;
	}
	/* TODO: update beacon to reflect PS poll state */
	if (!ath_hal_stop_tx_dma(ah, sc->sc_bhalq)) {
		DPRINTF(ATH_DEBUG_ANY, ("%s: beacon queue %u did not stop?\n",
		    __func__, sc->sc_bhalq));
	}
	bus_dmamap_sync(sc->sc_dmat, bf->bf_dmamap, 0,
	    bf->bf_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	ath_hal_put_tx_buf(ah, sc->sc_bhalq, bf->bf_daddr);
	ath_hal_tx_start(ah, sc->sc_bhalq);
	DPRINTF(ATH_DEBUG_BEACON_PROC,
	    ("%s: TXDP%u = %p (%p)\n", __func__,
	    sc->sc_bhalq, (caddr_t)bf->bf_daddr, bf->bf_desc));
}

void
ath_beacon_free(struct ath_softc *sc)
{
	struct ath_buf *bf = sc->sc_bcbuf;

	if (bf->bf_m != NULL) {
		bus_dmamap_unload(sc->sc_dmat, bf->bf_dmamap);
		m_freem(bf->bf_m);
		bf->bf_m = NULL;
		bf->bf_node = NULL;
	}
}
#endif	/* IEEE80211_STA_ONLY */

/*
 * Configure the beacon and sleep timers.
 *
 * When operating as an AP this resets the TSF and sets
 * up the hardware to notify us when we need to issue beacons.
 *
 * When operating in station mode this sets up the beacon
 * timers according to the timestamp of the last received
 * beacon and the current TSF, configures PCF and DTIM
 * handling, programs the sleep registers so the hardware
 * will wakeup in time to receive beacons, and configures
 * the beacon miss handling so we'll receive a BMISS
 * interrupt when we stop seeing beacons from the AP
 * we've associated with.
 */
void
ath_beacon_config(struct ath_softc *sc)
{
#define MS_TO_TU(x)	(((x) * 1000) / 1024)
	struct ath_hal *ah = sc->sc_ah;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	u_int32_t nexttbtt, intval;

	nexttbtt = (LE_READ_4(ni->ni_tstamp + 4) << 22) |
	    (LE_READ_4(ni->ni_tstamp) >> 10);
	intval = MAX(1, ni->ni_intval) & HAL_BEACON_PERIOD;
	if (nexttbtt == 0) {	/* e.g. for ap mode */
		nexttbtt = intval;
	} else if (intval) {
		nexttbtt = roundup(nexttbtt, intval);
	}
	DPRINTF(ATH_DEBUG_BEACON, ("%s: intval %u nexttbtt %u\n",
	    __func__, ni->ni_intval, nexttbtt));
	if (ic->ic_opmode == IEEE80211_M_STA) {
		HAL_BEACON_STATE bs;
		u_int32_t bmisstime;

		/* NB: no PCF support right now */
		bzero(&bs, sizeof(bs));
		bs.bs_intval = intval;
		bs.bs_nexttbtt = nexttbtt;
		bs.bs_dtimperiod = bs.bs_intval;
		bs.bs_nextdtim = nexttbtt;
		/*
		 * Calculate the number of consecutive beacons to miss
		 * before taking a BMISS interrupt.  The configuration
		 * is specified in ms, so we need to convert that to
		 * TU's and then calculate based on the beacon interval.
		 * Note that we clamp the result to at most 10 beacons.
		 */
		bmisstime = MAX(7, ic->ic_bmisstimeout);
		bs.bs_bmissthreshold = howmany(bmisstime, intval);
		if (bs.bs_bmissthreshold > 7) {
			bs.bs_bmissthreshold = 7;
		} else if (bs.bs_bmissthreshold <= 0) {
			bs.bs_bmissthreshold = 1;
		}

		/*
		 * Calculate sleep duration.  The configuration is
		 * given in ms.  We insure a multiple of the beacon
		 * period is used.  Also, if the sleep duration is
		 * greater than the DTIM period then it makes senses
		 * to make it a multiple of that.
		 *
		 * XXX fixed at 100ms
		 */
		bs.bs_sleepduration =
			roundup(MS_TO_TU(100), bs.bs_intval);
		if (bs.bs_sleepduration > bs.bs_dtimperiod) {
			bs.bs_sleepduration =
			    roundup(bs.bs_sleepduration, bs.bs_dtimperiod);
		}

		DPRINTF(ATH_DEBUG_BEACON,
		    ("%s: intval %u nexttbtt %u dtim %u nextdtim %u bmiss %u"
		    " sleep %u\n"
		    , __func__
		    , bs.bs_intval
		    , bs.bs_nexttbtt
		    , bs.bs_dtimperiod
		    , bs.bs_nextdtim
		    , bs.bs_bmissthreshold
		    , bs.bs_sleepduration
		));
		ath_hal_set_intr(ah, 0);
		ath_hal_set_beacon_timers(ah, &bs, 0/*XXX*/, 0, 0);
		sc->sc_imask |= HAL_INT_BMISS;
		ath_hal_set_intr(ah, sc->sc_imask);
	}
#ifndef IEEE80211_STA_ONLY
	else {
		ath_hal_set_intr(ah, 0);
		if (nexttbtt == intval)
			intval |= HAL_BEACON_RESET_TSF;
		if (ic->ic_opmode == IEEE80211_M_IBSS) {
			/*
			 * In IBSS mode enable the beacon timers but only
			 * enable SWBA interrupts if we need to manually
			 * prepare beacon frames. Otherwise we use a
			 * self-linked tx descriptor and let the hardware
			 * deal with things.
			 */
			intval |= HAL_BEACON_ENA;
			if (!sc->sc_veol)
				sc->sc_imask |= HAL_INT_SWBA;
		} else if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
			/*
			 * In AP mode we enable the beacon timers and
			 * SWBA interrupts to prepare beacon frames.
			 */
			intval |= HAL_BEACON_ENA;
			sc->sc_imask |= HAL_INT_SWBA;	/* beacon prepare */
		}
		ath_hal_init_beacon(ah, nexttbtt, intval);
		ath_hal_set_intr(ah, sc->sc_imask);
		/*
		 * When using a self-linked beacon descriptor in IBBS
		 * mode load it once here.
		 */
		if (ic->ic_opmode == IEEE80211_M_IBSS && sc->sc_veol)
			ath_beacon_proc(sc, 0);
	}
#endif
}

int
ath_desc_alloc(struct ath_softc *sc)
{
	int i, bsize, error = -1;
	struct ath_desc *ds;
	struct ath_buf *bf;

	/* allocate descriptors */
	sc->sc_desc_len = sizeof(struct ath_desc) *
				(ATH_TXBUF * ATH_TXDESC + ATH_RXBUF + 1);
	if ((error = bus_dmamem_alloc(sc->sc_dmat, sc->sc_desc_len, PAGE_SIZE,
	    0, &sc->sc_dseg, 1, &sc->sc_dnseg, 0)) != 0) {
		printf("%s: unable to allocate control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail0;
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, &sc->sc_dseg, sc->sc_dnseg,
	    sc->sc_desc_len, (caddr_t *)&sc->sc_desc, BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail1;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, sc->sc_desc_len, 1,
	    sc->sc_desc_len, 0, 0, &sc->sc_ddmamap)) != 0) {
		printf("%s: unable to create control data DMA map, "
		    "error = %d\n", sc->sc_dev.dv_xname, error);
		goto fail2;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_ddmamap, sc->sc_desc,
	    sc->sc_desc_len, NULL, 0)) != 0) {
		printf("%s: unable to load control data DMA map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail3;
	}

	ds = sc->sc_desc;
	sc->sc_desc_paddr = sc->sc_ddmamap->dm_segs[0].ds_addr;

	DPRINTF(ATH_DEBUG_XMIT_DESC|ATH_DEBUG_RECV_DESC,
	    ("ath_desc_alloc: DMA map: %p (%lu) -> %p (%lu)\n",
	    ds, (u_long)sc->sc_desc_len,
	    (caddr_t) sc->sc_desc_paddr, /*XXX*/ (u_long) sc->sc_desc_len));

	/* allocate buffers */
	bsize = sizeof(struct ath_buf) * (ATH_TXBUF + ATH_RXBUF + 1);
	bf = malloc(bsize, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (bf == NULL) {
		printf("%s: unable to allocate Tx/Rx buffers\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail3;
	}
	sc->sc_bufptr = bf;

	TAILQ_INIT(&sc->sc_rxbuf);
	for (i = 0; i < ATH_RXBUF; i++, bf++, ds++) {
		bf->bf_desc = ds;
		bf->bf_daddr = sc->sc_desc_paddr +
		    ((caddr_t)ds - (caddr_t)sc->sc_desc);
		if ((error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &bf->bf_dmamap)) != 0) {
			printf("%s: unable to create Rx dmamap, error = %d\n",
			    sc->sc_dev.dv_xname, error);
			goto fail4;
		}
		TAILQ_INSERT_TAIL(&sc->sc_rxbuf, bf, bf_list);
	}

	TAILQ_INIT(&sc->sc_txbuf);
	for (i = 0; i < ATH_TXBUF; i++, bf++, ds += ATH_TXDESC) {
		bf->bf_desc = ds;
		bf->bf_daddr = sc->sc_desc_paddr +
		    ((caddr_t)ds - (caddr_t)sc->sc_desc);
		if ((error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    ATH_TXDESC, MCLBYTES, 0, 0, &bf->bf_dmamap)) != 0) {
			printf("%s: unable to create Tx dmamap, error = %d\n",
			    sc->sc_dev.dv_xname, error);
			goto fail5;
		}
		TAILQ_INSERT_TAIL(&sc->sc_txbuf, bf, bf_list);
	}
	TAILQ_INIT(&sc->sc_txq);

	/* beacon buffer */
	bf->bf_desc = ds;
	bf->bf_daddr = sc->sc_desc_paddr + ((caddr_t)ds - (caddr_t)sc->sc_desc);
	if ((error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0, 0,
	    &bf->bf_dmamap)) != 0) {
		printf("%s: unable to create beacon dmamap, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail5;
	}
	sc->sc_bcbuf = bf;
	return 0;

fail5:
	for (i = ATH_RXBUF; i < ATH_RXBUF + ATH_TXBUF; i++) {
		if (sc->sc_bufptr[i].bf_dmamap == NULL)
			continue;
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_bufptr[i].bf_dmamap);
	}
fail4:
	for (i = 0; i < ATH_RXBUF; i++) {
		if (sc->sc_bufptr[i].bf_dmamap == NULL)
			continue;
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_bufptr[i].bf_dmamap);
	}
fail3:
	bus_dmamap_unload(sc->sc_dmat, sc->sc_ddmamap);
fail2:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ddmamap);
	sc->sc_ddmamap = NULL;
fail1:
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_desc, sc->sc_desc_len);
fail0:
	bus_dmamem_free(sc->sc_dmat, &sc->sc_dseg, sc->sc_dnseg);
	return error;
}

void
ath_desc_free(struct ath_softc *sc)
{
	struct ath_buf *bf;

	bus_dmamap_unload(sc->sc_dmat, sc->sc_ddmamap);
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ddmamap);
	bus_dmamem_free(sc->sc_dmat, &sc->sc_dseg, sc->sc_dnseg);

	TAILQ_FOREACH(bf, &sc->sc_txq, bf_list) {
		bus_dmamap_unload(sc->sc_dmat, bf->bf_dmamap);
		bus_dmamap_destroy(sc->sc_dmat, bf->bf_dmamap);
		m_freem(bf->bf_m);
	}
	TAILQ_FOREACH(bf, &sc->sc_txbuf, bf_list)
		bus_dmamap_destroy(sc->sc_dmat, bf->bf_dmamap);
	TAILQ_FOREACH(bf, &sc->sc_rxbuf, bf_list) {
		if (bf->bf_m) {
			bus_dmamap_unload(sc->sc_dmat, bf->bf_dmamap);
			bus_dmamap_destroy(sc->sc_dmat, bf->bf_dmamap);
			m_freem(bf->bf_m);
			bf->bf_m = NULL;
		}
	}
	if (sc->sc_bcbuf != NULL) {
		bus_dmamap_unload(sc->sc_dmat, sc->sc_bcbuf->bf_dmamap);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_bcbuf->bf_dmamap);
		sc->sc_bcbuf = NULL;
	}

	TAILQ_INIT(&sc->sc_rxbuf);
	TAILQ_INIT(&sc->sc_txbuf);
	TAILQ_INIT(&sc->sc_txq);
	free(sc->sc_bufptr, M_DEVBUF, 0);
	sc->sc_bufptr = NULL;
}

struct ieee80211_node *
ath_node_alloc(struct ieee80211com *ic)
{
	struct ath_node *an;

	an = malloc(sizeof(*an), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (an) {
		int i;
		for (i = 0; i < ATH_RHIST_SIZE; i++)
			an->an_rx_hist[i].arh_ticks = ATH_RHIST_NOTIME;
		an->an_rx_hist_next = ATH_RHIST_SIZE-1;
		return &an->an_node;
	} else
		return NULL;
}

void
ath_node_free(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct ath_softc *sc = ic->ic_if.if_softc;
	struct ath_buf *bf;

	TAILQ_FOREACH(bf, &sc->sc_txq, bf_list) {
		if (bf->bf_node == ni)
			bf->bf_node = NULL;
	}
	(*sc->sc_node_free)(ic, ni);
}

void
ath_node_copy(struct ieee80211com *ic,
	struct ieee80211_node *dst, const struct ieee80211_node *src)
{
	struct ath_softc *sc = ic->ic_if.if_softc;

	bcopy(&src[1], &dst[1],
		sizeof(struct ath_node) - sizeof(struct ieee80211_node));
	(*sc->sc_node_copy)(ic, dst, src);
}

u_int8_t
ath_node_getrssi(struct ieee80211com *ic, const struct ieee80211_node *ni)
{
	const struct ath_node *an = ATH_NODE(ni);
	int i, now, nsamples, rssi;

	/*
	 * Calculate the average over the last second of sampled data.
	 */
	now = ATH_TICKS();
	nsamples = 0;
	rssi = 0;
	i = an->an_rx_hist_next;
	do {
		const struct ath_recv_hist *rh = &an->an_rx_hist[i];
		if (rh->arh_ticks == ATH_RHIST_NOTIME)
			goto done;
		if (now - rh->arh_ticks > hz)
			goto done;
		rssi += rh->arh_rssi;
		nsamples++;
		if (i == 0) {
			i = ATH_RHIST_SIZE-1;
		} else {
			i--;
		}
	} while (i != an->an_rx_hist_next);
done:
	/*
	 * Return either the average or the last known
	 * value if there is no recent data.
	 */
	return (nsamples ? rssi / nsamples : an->an_rx_hist[i].arh_rssi);
}

int
ath_rxbuf_init(struct ath_softc *sc, struct ath_buf *bf)
{
	struct ath_hal *ah = sc->sc_ah;
	int error;
	struct mbuf *m;
	struct ath_desc *ds;

	m = bf->bf_m;
	if (m == NULL) {
		/*
		 * NB: by assigning a page to the rx dma buffer we
		 * implicitly satisfy the Atheros requirement that
		 * this buffer be cache-line-aligned and sized to be
		 * multiple of the cache line size.  Not doing this
		 * causes weird stuff to happen (for the 5210 at least).
		 */
		m = ath_getmbuf(M_DONTWAIT, MT_DATA, MCLBYTES);
		if (m == NULL) {
			DPRINTF(ATH_DEBUG_ANY,
			    ("%s: no mbuf/cluster\n", __func__));
			sc->sc_stats.ast_rx_nombuf++;
			return ENOMEM;
		}
		bf->bf_m = m;
		m->m_pkthdr.len = m->m_len = m->m_ext.ext_size;

		error = bus_dmamap_load_mbuf(sc->sc_dmat, bf->bf_dmamap, m,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			DPRINTF(ATH_DEBUG_ANY,
			    ("%s: ath_bus_dmamap_load_mbuf failed;"
			    " error %d\n", __func__, error));
			sc->sc_stats.ast_rx_busdma++;
			return error;
		}
		KASSERT(bf->bf_nseg == 1,
			("ath_rxbuf_init: multi-segment packet; nseg %u",
			bf->bf_nseg));
	}
	bus_dmamap_sync(sc->sc_dmat, bf->bf_dmamap, 0,
	    bf->bf_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	/*
	 * Setup descriptors.  For receive we always terminate
	 * the descriptor list with a self-linked entry so we'll
	 * not get overrun under high load (as can happen with a
	 * 5212 when ANI processing enables PHY errors).
	 *
	 * To insure the last descriptor is self-linked we create
	 * each descriptor as self-linked and add it to the end.  As
	 * each additional descriptor is added the previous self-linked
	 * entry is ``fixed'' naturally.  This should be safe even
	 * if DMA is happening.  When processing RX interrupts we
	 * never remove/process the last, self-linked, entry on the
	 * descriptor list.  This insures the hardware always has
	 * someplace to write a new frame.
	 */
	ds = bf->bf_desc;
	bzero(ds, sizeof(struct ath_desc));
#ifndef IEEE80211_STA_ONLY
	if (sc->sc_ic.ic_opmode != IEEE80211_M_HOSTAP)
		ds->ds_link = bf->bf_daddr;	/* link to self */
#endif
	ds->ds_data = bf->bf_segs[0].ds_addr;
	ath_hal_setup_rx_desc(ah, ds
		, m->m_len		/* buffer size */
		, 0
	);

	if (sc->sc_rxlink != NULL)
		*sc->sc_rxlink = bf->bf_daddr;
	sc->sc_rxlink = &ds->ds_link;
	return 0;
}

void
ath_rx_proc(void *arg, int npending)
{
#define	PA2DESC(_sc, _pa) \
	((struct ath_desc *)((caddr_t)(_sc)->sc_desc + \
		((_pa) - (_sc)->sc_desc_paddr)))
	struct ath_softc *sc = arg;
	struct ath_buf *bf;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ath_hal *ah = sc->sc_ah;
	struct ath_desc *ds;
	struct mbuf *m;
	struct ieee80211_frame *wh;
	struct ieee80211_frame whbuf;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct ath_node *an;
	struct ath_recv_hist *rh;
	int len;
	u_int phyerr;
	HAL_STATUS status;

	DPRINTF(ATH_DEBUG_RX_PROC, ("%s: pending %u\n", __func__, npending));
	do {
		bf = TAILQ_FIRST(&sc->sc_rxbuf);
		if (bf == NULL) {		/* NB: shouldn't happen */
			printf("%s: ath_rx_proc: no buffer!\n", ifp->if_xname);
			break;
		}
		ds = bf->bf_desc;
		if (ds->ds_link == bf->bf_daddr) {
			/* NB: never process the self-linked entry at the end */
			break;
		}
		m = bf->bf_m;
		if (m == NULL) {		/* NB: shouldn't happen */
			printf("%s: ath_rx_proc: no mbuf!\n", ifp->if_xname);
			continue;
		}
		/* XXX sync descriptor memory */
		/*
		 * Must provide the virtual address of the current
		 * descriptor, the physical address, and the virtual
		 * address of the next descriptor in the h/w chain.
		 * This allows the HAL to look ahead to see if the
		 * hardware is done with a descriptor by checking the
		 * done bit in the following descriptor and the address
		 * of the current descriptor the DMA engine is working
		 * on.  All this is necessary because of our use of
		 * a self-linked list to avoid rx overruns.
		 */
		status = ath_hal_proc_rx_desc(ah, ds,
		    bf->bf_daddr, PA2DESC(sc, ds->ds_link));
#ifdef AR_DEBUG
		if (ath_debug & ATH_DEBUG_RECV_DESC)
		    ath_printrxbuf(bf, status == HAL_OK);
#endif
		if (status == HAL_EINPROGRESS)
			break;
		TAILQ_REMOVE(&sc->sc_rxbuf, bf, bf_list);

		if (ds->ds_rxstat.rs_more) {
			/*
			 * Frame spans multiple descriptors; this
			 * cannot happen yet as we don't support
			 * jumbograms.  If not in monitor mode,
			 * discard the frame.
			 */

			/* 
			 * Enable this if you want to see error
			 * frames in Monitor mode.
			 */
#ifdef ERROR_FRAMES
			if (ic->ic_opmode != IEEE80211_M_MONITOR) {
				/* XXX statistic */
				goto rx_next;
			}
#endif
			/* fall thru for monitor mode handling... */

		} else if (ds->ds_rxstat.rs_status != 0) {
			if (ds->ds_rxstat.rs_status & HAL_RXERR_CRC)
				sc->sc_stats.ast_rx_crcerr++;
			if (ds->ds_rxstat.rs_status & HAL_RXERR_FIFO)
				sc->sc_stats.ast_rx_fifoerr++;
			if (ds->ds_rxstat.rs_status & HAL_RXERR_DECRYPT)
				sc->sc_stats.ast_rx_badcrypt++;
			if (ds->ds_rxstat.rs_status & HAL_RXERR_PHY) {
				sc->sc_stats.ast_rx_phyerr++;
				phyerr = ds->ds_rxstat.rs_phyerr & 0x1f;
				sc->sc_stats.ast_rx_phy[phyerr]++;
			}

			/*
			 * reject error frames, we normally don't want
			 * to see them in monitor mode.
			 */
			if ((ds->ds_rxstat.rs_status & HAL_RXERR_DECRYPT ) ||
			    (ds->ds_rxstat.rs_status & HAL_RXERR_PHY))
			    goto rx_next;

			/*
			 * In monitor mode, allow through packets that
			 * cannot be decrypted
			 */
			if ((ds->ds_rxstat.rs_status & ~HAL_RXERR_DECRYPT) ||
			    sc->sc_ic.ic_opmode != IEEE80211_M_MONITOR)
				goto rx_next;
		}

		len = ds->ds_rxstat.rs_datalen;
		if (len < IEEE80211_MIN_LEN) {
			DPRINTF(ATH_DEBUG_RECV, ("%s: short packet %d\n",
			    __func__, len));
			sc->sc_stats.ast_rx_tooshort++;
			goto rx_next;
		}

		bus_dmamap_sync(sc->sc_dmat, bf->bf_dmamap, 0,
		    bf->bf_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);

		bus_dmamap_unload(sc->sc_dmat, bf->bf_dmamap);
		bf->bf_m = NULL;
		m->m_pkthdr.len = m->m_len = len;

#if NBPFILTER > 0
		if (sc->sc_drvbpf) {
			struct mbuf mb;

			sc->sc_rxtap.wr_flags = IEEE80211_RADIOTAP_F_FCS;
			sc->sc_rxtap.wr_rate =
			    sc->sc_hwmap[ds->ds_rxstat.rs_rate] &
			    IEEE80211_RATE_VAL;
			sc->sc_rxtap.wr_antenna = ds->ds_rxstat.rs_antenna;
			sc->sc_rxtap.wr_rssi = ds->ds_rxstat.rs_rssi;
			sc->sc_rxtap.wr_max_rssi = ic->ic_max_rssi;

			mb.m_data = (caddr_t)&sc->sc_rxtap;
			mb.m_len = sc->sc_rxtap_len;
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
		}
#endif
		m_adj(m, -IEEE80211_CRC_LEN);
		wh = mtod(m, struct ieee80211_frame *);
		rxi.rxi_flags = 0;
		if (!ath_softcrypto && (wh->i_fc[1] & IEEE80211_FC1_WEP)) {
			/*
			 * WEP is decrypted by hardware. Clear WEP bit
			 * and trim WEP header for ieee80211_input().
			 */
			wh->i_fc[1] &= ~IEEE80211_FC1_WEP;
			bcopy(wh, &whbuf, sizeof(whbuf));
			m_adj(m, IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN);
			wh = mtod(m, struct ieee80211_frame *);
			bcopy(&whbuf, wh, sizeof(whbuf));
			/*
			 * Also trim WEP ICV from the tail.
			 */
			m_adj(m, -IEEE80211_WEP_CRCLEN);
			/*
			 * The header has probably moved.
			 */
			wh = mtod(m, struct ieee80211_frame *);

			rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
		}

		/*
		 * Locate the node for sender, track state, and
		 * then pass this node (referenced) up to the 802.11
		 * layer for its use.
		 */
		ni = ieee80211_find_rxnode(ic, wh);

		/*
		 * Record driver-specific state.
		 */
		an = ATH_NODE(ni);
		if (++(an->an_rx_hist_next) == ATH_RHIST_SIZE)
			an->an_rx_hist_next = 0;
		rh = &an->an_rx_hist[an->an_rx_hist_next];
		rh->arh_ticks = ATH_TICKS();
		rh->arh_rssi = ds->ds_rxstat.rs_rssi;
		rh->arh_antenna = ds->ds_rxstat.rs_antenna;

		/*
		 * Send frame up for processing.
		 */
		rxi.rxi_rssi = ds->ds_rxstat.rs_rssi;
		rxi.rxi_tstamp = ds->ds_rxstat.rs_tstamp;
		ieee80211_input(ifp, m, ni, &rxi);

		/* Handle the rate adaption */
		ieee80211_rssadapt_input(ic, ni, &an->an_rssadapt,
		    ds->ds_rxstat.rs_rssi);

		/*
		 * The frame may have caused the node to be marked for
		 * reclamation (e.g. in response to a DEAUTH message)
		 * so use release_node here instead of unref_node.
		 */
		ieee80211_release_node(ic, ni);

	rx_next:
		TAILQ_INSERT_TAIL(&sc->sc_rxbuf, bf, bf_list);
	} while (ath_rxbuf_init(sc, bf) == 0);

	ath_hal_set_rx_signal(ah);		/* rx signal state monitoring */
	ath_hal_start_rx(ah);			/* in case of RXEOL */
#undef PA2DESC
}

/*
 * XXX Size of an ACK control frame in bytes.
 */
#define	IEEE80211_ACK_SIZE	(2+2+IEEE80211_ADDR_LEN+4)

int
ath_tx_start(struct ath_softc *sc, struct ieee80211_node *ni,
    struct ath_buf *bf, struct mbuf *m0)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ath_hal *ah = sc->sc_ah;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int i, error, iswep, hdrlen, pktlen, len, s, tries;
	u_int8_t rix, cix, txrate, ctsrate;
	struct ath_desc *ds;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	u_int32_t iv;
	u_int8_t *ivp;
	u_int8_t hdrbuf[sizeof(struct ieee80211_frame) +
	    IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN];
	u_int subtype, flags, ctsduration, antenna;
	HAL_PKT_TYPE atype;
	const HAL_RATE_TABLE *rt;
	HAL_BOOL shortPreamble;
	struct ath_node *an;
	u_int8_t hwqueue = HAL_TX_QUEUE_ID_DATA_MIN;

	wh = mtod(m0, struct ieee80211_frame *);
	iswep = wh->i_fc[1] & IEEE80211_FC1_PROTECTED;
	hdrlen = sizeof(struct ieee80211_frame);
	pktlen = m0->m_pkthdr.len;

	if (ath_softcrypto && iswep) {
		k = ieee80211_get_txkey(ic, wh, ni);	
		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOMEM;
		wh = mtod(m0, struct ieee80211_frame *);

		/* reset len in case we got a new mbuf */
		pktlen = m0->m_pkthdr.len;
	} else if (!ath_softcrypto && iswep) {
		bcopy(mtod(m0, caddr_t), hdrbuf, hdrlen);
		m_adj(m0, hdrlen);
		M_PREPEND(m0, sizeof(hdrbuf), M_DONTWAIT);
		if (m0 == NULL) {
			sc->sc_stats.ast_tx_nombuf++;
			return ENOMEM;
		}
		ivp = hdrbuf + hdrlen;
		wh = mtod(m0, struct ieee80211_frame *);
		/*
		 * XXX
		 * IV must not duplicate during the lifetime of the key.
		 * But no mechanism to renew keys is defined in IEEE 802.11
		 * for WEP.  And the IV may be duplicated at other stations
		 * because the session key itself is shared.  So we use a
		 * pseudo random IV for now, though it is not the right way.
		 *
		 * NB: Rather than use a strictly random IV we select a
		 * random one to start and then increment the value for
		 * each frame.  This is an explicit tradeoff between
		 * overhead and security.  Given the basic insecurity of
		 * WEP this seems worthwhile.
		 */

		/*
		 * Skip 'bad' IVs from Fluhrer/Mantin/Shamir:
		 * (B, 255, N) with 3 <= B < 16 and 0 <= N <= 255
		 */
		iv = ic->ic_iv;
		if ((iv & 0xff00) == 0xff00) {
			int B = (iv & 0xff0000) >> 16;
			if (3 <= B && B < 16)
				iv = (B+1) << 16;
		}
		ic->ic_iv = iv + 1;

		/*
		 * NB: Preserve byte order of IV for packet
		 *     sniffers; it doesn't matter otherwise.
		 */
#if BYTE_ORDER == BIG_ENDIAN
		ivp[0] = iv >> 0;
		ivp[1] = iv >> 8;
		ivp[2] = iv >> 16;
#else
		ivp[2] = iv >> 0;
		ivp[1] = iv >> 8;
		ivp[0] = iv >> 16;
#endif
		ivp[3] = ic->ic_wep_txkey << 6; /* Key ID and pad */
		bcopy(hdrbuf, mtod(m0, caddr_t), sizeof(hdrbuf));
		/*
		 * The length of hdrlen and pktlen must be increased for WEP
		 */
		len = IEEE80211_WEP_IVLEN +
		    IEEE80211_WEP_KIDLEN +
		    IEEE80211_WEP_CRCLEN;
		hdrlen += len;
		pktlen += len;
	}
	pktlen += IEEE80211_CRC_LEN;

	/*
	 * Load the DMA map so any coalescing is done.  This
	 * also calculates the number of descriptors we need.
	 */
	error = bus_dmamap_load_mbuf(sc->sc_dmat, bf->bf_dmamap, m0,
	    BUS_DMA_NOWAIT);
	/*
	 * Discard null packets and check for packets that
	 * require too many TX descriptors.  We try to convert
	 * the latter to a cluster.
	 */
	if (error == EFBIG) {		/* too many desc's, linearize */
		sc->sc_stats.ast_tx_linear++;
		if (m_defrag(m0, M_DONTWAIT)) {
			sc->sc_stats.ast_tx_nomcl++;
			m_freem(m0);
			return ENOMEM;
		}
		error = bus_dmamap_load_mbuf(sc->sc_dmat, bf->bf_dmamap, m0,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			sc->sc_stats.ast_tx_busdma++;
			m_freem(m0);
			return error;
		}
		KASSERT(bf->bf_nseg == 1,
			("ath_tx_start: packet not one segment; nseg %u",
			bf->bf_nseg));
	} else if (error != 0) {
		sc->sc_stats.ast_tx_busdma++;
		m_freem(m0);
		return error;
	} else if (bf->bf_nseg == 0) {		/* null packet, discard */
		sc->sc_stats.ast_tx_nodata++;
		m_freem(m0);
		return EIO;
	}
	DPRINTF(ATH_DEBUG_XMIT, ("%s: m %p len %u\n", __func__, m0, pktlen));
	bus_dmamap_sync(sc->sc_dmat, bf->bf_dmamap, 0,
	    bf->bf_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);
	bf->bf_m = m0;
	bf->bf_node = ni;			/* NB: held reference */
	an = ATH_NODE(ni);

	/* setup descriptors */
	ds = bf->bf_desc;
	rt = sc->sc_currates;
	KASSERT(rt != NULL, ("no rate table, mode %u", sc->sc_curmode));

	/*
	 * Calculate Atheros packet type from IEEE80211 packet header
	 * and setup for rate calculations.
	 */
	bf->bf_id.id_node = NULL;
	atype = HAL_PKT_TYPE_NORMAL;			/* default */
	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
	case IEEE80211_FC0_TYPE_MGT:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;
		if (subtype == IEEE80211_FC0_SUBTYPE_BEACON) {
			atype = HAL_PKT_TYPE_BEACON;
		} else if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP) {
			atype = HAL_PKT_TYPE_PROBE_RESP;
		} else if (subtype == IEEE80211_FC0_SUBTYPE_ATIM) {
			atype = HAL_PKT_TYPE_ATIM;
		}
		rix = 0;			/* XXX lowest rate */
		break;
	case IEEE80211_FC0_TYPE_CTL:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;
		if (subtype == IEEE80211_FC0_SUBTYPE_PS_POLL)
			atype = HAL_PKT_TYPE_PSPOLL;
		rix = 0;			/* XXX lowest rate */
		break;
	default:
		/* remember link conditions for rate adaptation algorithm */
		if (ic->ic_fixed_rate == -1) {
			bf->bf_id.id_len = m0->m_pkthdr.len;
			bf->bf_id.id_rateidx = ni->ni_txrate;
			bf->bf_id.id_node = ni;
			bf->bf_id.id_rssi = ath_node_getrssi(ic, ni);
		}
		ni->ni_txrate = ieee80211_rssadapt_choose(&an->an_rssadapt,
		    &ni->ni_rates, wh, m0->m_pkthdr.len, ic->ic_fixed_rate,
		    ifp->if_xname, 0);
		rix = sc->sc_rixmap[ni->ni_rates.rs_rates[ni->ni_txrate] &
		    IEEE80211_RATE_VAL];
		if (rix == 0xff) {
			printf("%s: bogus xmit rate 0x%x (idx 0x%x)\n",
			    ifp->if_xname, ni->ni_rates.rs_rates[ni->ni_txrate],
			    ni->ni_txrate);
			sc->sc_stats.ast_tx_badrate++;
			m_freem(m0);
			return EIO;
		}
		break;
	}

	/*
	 * NB: the 802.11 layer marks whether or not we should
	 * use short preamble based on the current mode and
	 * negotiated parameters.
	 */
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    (ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_PREAMBLE)) {
		txrate = rt->info[rix].rateCode | rt->info[rix].shortPreamble;
		shortPreamble = AH_TRUE;
		sc->sc_stats.ast_tx_shortpre++;
	} else {
		txrate = rt->info[rix].rateCode;
		shortPreamble = AH_FALSE;
	}

	/*
	 * Calculate miscellaneous flags.
	 */
	flags = HAL_TXDESC_CLRDMASK;		/* XXX needed for wep errors */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= HAL_TXDESC_NOACK;	/* no ack on broad/multicast */
		sc->sc_stats.ast_tx_noack++;
	} else if (pktlen > ic->ic_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;	/* RTS based on frame length */
		sc->sc_stats.ast_tx_rts++;
	}

	/*
	 * Calculate duration.  This logically belongs in the 802.11
	 * layer but it lacks sufficient information to calculate it.
	 */
	if ((flags & HAL_TXDESC_NOACK) == 0 &&
	    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL) {
		u_int16_t dur;
		/*
		 * XXX not right with fragmentation.
		 */
		dur = ath_hal_computetxtime(ah, rt, IEEE80211_ACK_SIZE,
				rix, shortPreamble);
		*((u_int16_t*) wh->i_dur) = htole16(dur);
	}

	/*
	 * Calculate RTS/CTS rate and duration if needed.
	 */
	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
		/*
		 * CTS transmit rate is derived from the transmit rate
		 * by looking in the h/w rate table.  We must also factor
		 * in whether or not a short preamble is to be used.
		 */
		cix = rt->info[rix].controlRate;
		ctsrate = rt->info[cix].rateCode;
		if (shortPreamble)
			ctsrate |= rt->info[cix].shortPreamble;
		/*
		 * Compute the transmit duration based on the size
		 * of an ACK frame.  We call into the HAL to do the
		 * computation since it depends on the characteristics
		 * of the actual PHY being used.
		 */
		if (flags & HAL_TXDESC_RTSENA) {	/* SIFS + CTS */
			ctsduration += ath_hal_computetxtime(ah,
				rt, IEEE80211_ACK_SIZE, cix, shortPreamble);
		}
		/* SIFS + data */
		ctsduration += ath_hal_computetxtime(ah,
			rt, pktlen, rix, shortPreamble);
		if ((flags & HAL_TXDESC_NOACK) == 0) {	/* SIFS + ACK */
			ctsduration += ath_hal_computetxtime(ah,
				rt, IEEE80211_ACK_SIZE, cix, shortPreamble);
		}
	} else
		ctsrate = 0;

	/*
	 * For now use the antenna on which the last good
	 * frame was received on.  We assume this field is
	 * initialized to 0 which gives us ``auto'' or the
	 * ``default'' antenna.
	 */
	if (an->an_tx_antenna) {
		antenna = an->an_tx_antenna;
	} else {
		antenna = an->an_rx_hist[an->an_rx_hist_next].arh_antenna;
	}

#if NBPFILTER > 0
	if (ic->ic_rawbpf)
		bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);

	if (sc->sc_drvbpf) {
		struct mbuf mb;

		sc->sc_txtap.wt_flags = 0;
		if (shortPreamble)
			sc->sc_txtap.wt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
		if (!ath_softcrypto && iswep)
			sc->sc_txtap.wt_flags |= IEEE80211_RADIOTAP_F_WEP;
		sc->sc_txtap.wt_rate = ni->ni_rates.rs_rates[ni->ni_txrate] &
		    IEEE80211_RATE_VAL;
		sc->sc_txtap.wt_txpower = 30;
		sc->sc_txtap.wt_antenna = antenna;
		sc->sc_txtap.wt_hwqueue = hwqueue;

		mb.m_data = (caddr_t)&sc->sc_txtap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	/*
	 * Formulate first tx descriptor with tx controls.
	 */
	tries = IEEE80211_IS_MULTICAST(wh->i_addr1) ? 1 : 15;
	/* XXX check return value? */
	ath_hal_setup_tx_desc(ah, ds
		, pktlen		/* packet length */
		, hdrlen		/* header length */
		, atype			/* Atheros packet type */
		, 60			/* txpower XXX */
		, txrate, tries		/* series 0 rate/tries */
		, iswep ? sc->sc_ic.ic_wep_txkey : HAL_TXKEYIX_INVALID
		, antenna		/* antenna mode */
		, flags			/* flags */
		, ctsrate		/* rts/cts rate */
		, ctsduration		/* rts/cts duration */
	);
#ifdef notyet
	ath_hal_setup_xtx_desc(ah, ds
		, AH_FALSE		/* short preamble */
		, 0, 0			/* series 1 rate/tries */
		, 0, 0			/* series 2 rate/tries */
		, 0, 0			/* series 3 rate/tries */
	);
#endif
	/*
	 * Fillin the remainder of the descriptor info.
	 */
	for (i = 0; i < bf->bf_nseg; i++, ds++) {
		ds->ds_data = bf->bf_segs[i].ds_addr;
		if (i == bf->bf_nseg - 1) {
			ds->ds_link = 0;
		} else {
			ds->ds_link = bf->bf_daddr + sizeof(*ds) * (i + 1);
		}
		ath_hal_fill_tx_desc(ah, ds
			, bf->bf_segs[i].ds_len	/* segment length */
			, i == 0		/* first segment */
			, i == bf->bf_nseg - 1	/* last segment */
		);
		DPRINTF(ATH_DEBUG_XMIT,
		    ("%s: %d: %08x %08x %08x %08x %08x %08x\n",
		    __func__, i, ds->ds_link, ds->ds_data,
		    ds->ds_ctl0, ds->ds_ctl1, ds->ds_hw[0], ds->ds_hw[1]));
	}

	/*
	 * Insert the frame on the outbound list and
	 * pass it on to the hardware.
	 */
	s = splnet();
	TAILQ_INSERT_TAIL(&sc->sc_txq, bf, bf_list);
	if (sc->sc_txlink == NULL) {
		ath_hal_put_tx_buf(ah, sc->sc_txhalq[hwqueue], bf->bf_daddr);
		DPRINTF(ATH_DEBUG_XMIT, ("%s: TXDP0 = %p (%p)\n", __func__,
		    (caddr_t)bf->bf_daddr, bf->bf_desc));
	} else {
		*sc->sc_txlink = bf->bf_daddr;
		DPRINTF(ATH_DEBUG_XMIT, ("%s: link(%p)=%p (%p)\n", __func__,
		    sc->sc_txlink, (caddr_t)bf->bf_daddr, bf->bf_desc));
	}
	sc->sc_txlink = &bf->bf_desc[bf->bf_nseg - 1].ds_link;
	splx(s);

	ath_hal_tx_start(ah, sc->sc_txhalq[hwqueue]);
	return 0;
}

void
ath_tx_proc(void *arg, int npending)
{
	struct ath_softc *sc = arg;
	struct ath_hal *ah = sc->sc_ah;
	struct ath_buf *bf;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ath_desc *ds;
	struct ieee80211_node *ni;
	struct ath_node *an;
	int sr, lr, s;
	HAL_STATUS status;

	for (;;) {
		s = splnet();
		bf = TAILQ_FIRST(&sc->sc_txq);
		if (bf == NULL) {
			sc->sc_txlink = NULL;
			splx(s);
			break;
		}
		/* only the last descriptor is needed */
		ds = &bf->bf_desc[bf->bf_nseg - 1];
		status = ath_hal_proc_tx_desc(ah, ds);
#ifdef AR_DEBUG
		if (ath_debug & ATH_DEBUG_XMIT_DESC)
			ath_printtxbuf(bf, status == HAL_OK);
#endif
		if (status == HAL_EINPROGRESS) {
			splx(s);
			break;
		}
		TAILQ_REMOVE(&sc->sc_txq, bf, bf_list);
		splx(s);

		ni = bf->bf_node;
		if (ni != NULL) {
			an = (struct ath_node *) ni;
			if (ds->ds_txstat.ts_status == 0) {
				if (bf->bf_id.id_node != NULL)
					ieee80211_rssadapt_raise_rate(ic,
					    &an->an_rssadapt, &bf->bf_id);
				an->an_tx_antenna = ds->ds_txstat.ts_antenna;
			} else {
				if (bf->bf_id.id_node != NULL)
					ieee80211_rssadapt_lower_rate(ic, ni,
					    &an->an_rssadapt, &bf->bf_id);
				if (ds->ds_txstat.ts_status & HAL_TXERR_XRETRY)
					sc->sc_stats.ast_tx_xretries++;
				if (ds->ds_txstat.ts_status & HAL_TXERR_FIFO)
					sc->sc_stats.ast_tx_fifoerr++;
				if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
					sc->sc_stats.ast_tx_filtered++;
				an->an_tx_antenna = 0;	/* invalidate */
			}
			sr = ds->ds_txstat.ts_shortretry;
			lr = ds->ds_txstat.ts_longretry;
			sc->sc_stats.ast_tx_shortretry += sr;
			sc->sc_stats.ast_tx_longretry += lr;
			/*
			 * Reclaim reference to node.
			 *
			 * NB: the node may be reclaimed here if, for example
			 *     this is a DEAUTH message that was sent and the
			 *     node was timed out due to inactivity.
			 */
			ieee80211_release_node(ic, ni);
		}
		bus_dmamap_sync(sc->sc_dmat, bf->bf_dmamap, 0,
		    bf->bf_dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, bf->bf_dmamap);
		m_freem(bf->bf_m);
		bf->bf_m = NULL;
		bf->bf_node = NULL;

		s = splnet();
		TAILQ_INSERT_TAIL(&sc->sc_txbuf, bf, bf_list);
		splx(s);
	}
	ifq_clr_oactive(&ifp->if_snd);
	sc->sc_tx_timer = 0;

	ath_start(ifp);
}

/*
 * Drain the transmit queue and reclaim resources.
 */
void
ath_draintxq(struct ath_softc *sc)
{
	struct ath_hal *ah = sc->sc_ah;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_node *ni;
	struct ath_buf *bf;
	int s, i;

	/* XXX return value */
	if (!sc->sc_invalid) {
		for (i = 0; i <= HAL_TX_QUEUE_ID_DATA_MAX; i++) {
			/* don't touch the hardware if marked invalid */
			(void) ath_hal_stop_tx_dma(ah, sc->sc_txhalq[i]);
			DPRINTF(ATH_DEBUG_RESET,
			    ("%s: tx queue %d (%p), link %p\n", __func__, i,
			    (caddr_t)(u_intptr_t)ath_hal_get_tx_buf(ah,
			    sc->sc_txhalq[i]), sc->sc_txlink));
		}
		(void) ath_hal_stop_tx_dma(ah, sc->sc_bhalq);
		DPRINTF(ATH_DEBUG_RESET,
		    ("%s: beacon queue (%p)\n", __func__,
		    (caddr_t)(u_intptr_t)ath_hal_get_tx_buf(ah, sc->sc_bhalq)));
	}
	for (;;) {
		s = splnet();
		bf = TAILQ_FIRST(&sc->sc_txq);
		if (bf == NULL) {
			sc->sc_txlink = NULL;
			splx(s);
			break;
		}
		TAILQ_REMOVE(&sc->sc_txq, bf, bf_list);
		splx(s);
#ifdef AR_DEBUG
		if (ath_debug & ATH_DEBUG_RESET) {
			ath_printtxbuf(bf,
			    ath_hal_proc_tx_desc(ah, bf->bf_desc) == HAL_OK);
		}
#endif /* AR_DEBUG */
		bus_dmamap_unload(sc->sc_dmat, bf->bf_dmamap);
		m_freem(bf->bf_m);
		bf->bf_m = NULL;
		ni = bf->bf_node;
		bf->bf_node = NULL;
		s = splnet();
		if (ni != NULL) {
			/*
			 * Reclaim node reference.
			 */
			ieee80211_release_node(ic, ni);
		}
		TAILQ_INSERT_TAIL(&sc->sc_txbuf, bf, bf_list);
		splx(s);
	}
	ifq_clr_oactive(&ifp->if_snd);
	sc->sc_tx_timer = 0;
}

/*
 * Disable the receive h/w in preparation for a reset.
 */
void
ath_stoprecv(struct ath_softc *sc)
{
#define	PA2DESC(_sc, _pa) \
	((struct ath_desc *)((caddr_t)(_sc)->sc_desc + \
		((_pa) - (_sc)->sc_desc_paddr)))
	struct ath_hal *ah = sc->sc_ah;

	ath_hal_stop_pcu_recv(ah);	/* disable PCU */
	ath_hal_set_rx_filter(ah, 0);	/* clear recv filter */
	ath_hal_stop_rx_dma(ah);	/* disable DMA engine */
#ifdef AR_DEBUG
	if (ath_debug & ATH_DEBUG_RESET) {
		struct ath_buf *bf;

		printf("%s: rx queue %p, link %p\n", __func__,
		    (caddr_t)(u_intptr_t)ath_hal_get_rx_buf(ah), sc->sc_rxlink);
		TAILQ_FOREACH(bf, &sc->sc_rxbuf, bf_list) {
			struct ath_desc *ds = bf->bf_desc;
			if (ath_hal_proc_rx_desc(ah, ds, bf->bf_daddr,
			    PA2DESC(sc, ds->ds_link)) == HAL_OK)
				ath_printrxbuf(bf, 1);
		}
	}
#endif
	sc->sc_rxlink = NULL;		/* just in case */
#undef PA2DESC
}

/*
 * Enable the receive h/w following a reset.
 */
int
ath_startrecv(struct ath_softc *sc)
{
	struct ath_hal *ah = sc->sc_ah;
	struct ath_buf *bf;

	sc->sc_rxlink = NULL;
	TAILQ_FOREACH(bf, &sc->sc_rxbuf, bf_list) {
		int error = ath_rxbuf_init(sc, bf);
		if (error != 0) {
			DPRINTF(ATH_DEBUG_RECV,
			    ("%s: ath_rxbuf_init failed %d\n",
			    __func__, error));
			return error;
		}
	}

	bf = TAILQ_FIRST(&sc->sc_rxbuf);
	ath_hal_put_rx_buf(ah, bf->bf_daddr);
	ath_hal_start_rx(ah);		/* enable recv descriptors */
	ath_mode_init(sc);		/* set filters, etc. */
	ath_hal_start_rx_pcu(ah);	/* re-enable PCU/DMA engine */
	return 0;
}

/*
 * Set/change channels.  If the channel is really being changed,
 * it's done by resetting the chip.  To accomplish this we must
 * first cleanup any pending DMA, then restart stuff after a la
 * ath_init.
 */
int
ath_chan_set(struct ath_softc *sc, struct ieee80211_channel *chan)
{
	struct ath_hal *ah = sc->sc_ah;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	DPRINTF(ATH_DEBUG_ANY, ("%s: %u (%u MHz) -> %u (%u MHz)\n", __func__,
	    ieee80211_chan2ieee(ic, ic->ic_ibss_chan),
	    ic->ic_ibss_chan->ic_freq,
	    ieee80211_chan2ieee(ic, chan), chan->ic_freq));
	if (chan != ic->ic_ibss_chan) {
		HAL_STATUS status;
		HAL_CHANNEL hchan;
		enum ieee80211_phymode mode;

		/*
		 * To switch channels clear any pending DMA operations;
		 * wait long enough for the RX fifo to drain, reset the
		 * hardware at the new frequency, and then re-enable
		 * the relevant bits of the h/w.
		 */
		ath_hal_set_intr(ah, 0);		/* disable interrupts */
		ath_draintxq(sc);		/* clear pending tx frames */
		ath_stoprecv(sc);		/* turn off frame recv */
		/*
		 * Convert to a HAL channel description with
		 * the flags constrained to reflect the current
		 * operating mode.
		 */
		hchan.channel = chan->ic_freq;
		hchan.channelFlags = ath_chan2flags(ic, chan);
		if (!ath_hal_reset(ah, ic->ic_opmode, &hchan, AH_TRUE,
		    &status)) {
			printf("%s: ath_chan_set: unable to reset "
				"channel %u (%u MHz)\n", ifp->if_xname,
				ieee80211_chan2ieee(ic, chan), chan->ic_freq);
			return EIO;
		}
		ath_set_slot_time(sc);
		/*
		 * Re-enable rx framework.
		 */
		if (ath_startrecv(sc) != 0) {
			printf("%s: ath_chan_set: unable to restart recv "
			    "logic\n", ifp->if_xname);
			return EIO;
		}

#if NBPFILTER > 0
		/*
		 * Update BPF state.
		 */
		sc->sc_txtap.wt_chan_freq = sc->sc_rxtap.wr_chan_freq =
		    htole16(chan->ic_freq);
		sc->sc_txtap.wt_chan_flags = sc->sc_rxtap.wr_chan_flags =
		    htole16(chan->ic_flags);
#endif

		/*
		 * Change channels and update the h/w rate map
		 * if we're switching; e.g. 11a to 11b/g.
		 */
		ic->ic_ibss_chan = chan;
		mode = ieee80211_chan2mode(ic, chan);
		if (mode != sc->sc_curmode)
			ath_setcurmode(sc, mode);

		/*
		 * Re-enable interrupts.
		 */
		ath_hal_set_intr(ah, sc->sc_imask);
	}
	return 0;
}

void
ath_next_scan(void *arg)
{
	struct ath_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	/* don't call ath_start w/o network interrupts blocked */
	s = splnet();

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
	splx(s);
}

int
ath_set_slot_time(struct ath_softc *sc)
{
	struct ath_hal *ah = sc->sc_ah;
	struct ieee80211com *ic = &sc->sc_ic;

	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		return (ath_hal_set_slot_time(ah, HAL_SLOT_TIME_9));

	return (0);
}

/*
 * Periodically recalibrate the PHY to account
 * for temperature/environment changes.
 */
void
ath_calibrate(void *arg)
{
	struct ath_softc *sc = arg;
	struct ath_hal *ah = sc->sc_ah;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *c;
	HAL_CHANNEL hchan;
	int s;

	sc->sc_stats.ast_per_cal++;

	/*
	 * Convert to a HAL channel description with the flags
	 * constrained to reflect the current operating mode.
	 */
	c = ic->ic_ibss_chan;
	hchan.channel = c->ic_freq;
	hchan.channelFlags = ath_chan2flags(ic, c);

	s = splnet();
	DPRINTF(ATH_DEBUG_CALIBRATE,
	    ("%s: channel %u/%x\n", __func__, c->ic_freq, c->ic_flags));

	if (ath_hal_get_rf_gain(ah) == HAL_RFGAIN_NEED_CHANGE) {
		/*
		 * Rfgain is out of bounds, reset the chip
		 * to load new gain values.
		 */
		sc->sc_stats.ast_per_rfgain++;
		ath_reset(sc, 1);
	}
	if (!ath_hal_calibrate(ah, &hchan)) {
		DPRINTF(ATH_DEBUG_ANY,
		    ("%s: calibration of channel %u failed\n",
		    __func__, c->ic_freq));
		sc->sc_stats.ast_per_calfail++;
	}
	timeout_add_sec(&sc->sc_cal_to, ath_calinterval);
	splx(s);
}

void
ath_ledstate(struct ath_softc *sc, enum ieee80211_state state)
{
	HAL_LED_STATE led = HAL_LED_INIT;
	u_int32_t softled = AR5K_SOFTLED_OFF;

	switch (state) {
	case IEEE80211_S_INIT:
		break;
	case IEEE80211_S_SCAN:
		led = HAL_LED_SCAN;
		break;
	case IEEE80211_S_AUTH:
		led = HAL_LED_AUTH;
		break;
	case IEEE80211_S_ASSOC:
		led = HAL_LED_ASSOC;
		softled = AR5K_SOFTLED_ON;
		break;
	case IEEE80211_S_RUN:
		led = HAL_LED_RUN;
		softled = AR5K_SOFTLED_ON;
		break;
	}

	ath_hal_set_ledstate(sc->sc_ah, led);
	if (sc->sc_softled) {
		ath_hal_set_gpio_output(sc->sc_ah, AR5K_SOFTLED_PIN);
		ath_hal_set_gpio(sc->sc_ah, AR5K_SOFTLED_PIN, softled);
	}
}

int
ath_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ath_softc *sc = ifp->if_softc;
	struct ath_hal *ah = sc->sc_ah;
	struct ieee80211_node *ni;
	const u_int8_t *bssid;
	int error, i;

	u_int32_t rfilt;

	DPRINTF(ATH_DEBUG_ANY, ("%s: %s -> %s\n", __func__,
	    ieee80211_state_name[ic->ic_state],
	    ieee80211_state_name[nstate]));

	timeout_del(&sc->sc_scan_to);
	timeout_del(&sc->sc_cal_to);
	ath_ledstate(sc, nstate);

	if (nstate == IEEE80211_S_INIT) {
		timeout_del(&sc->sc_rssadapt_to);
		sc->sc_imask &= ~(HAL_INT_SWBA | HAL_INT_BMISS);
		ath_hal_set_intr(ah, sc->sc_imask);
		return (*sc->sc_newstate)(ic, nstate, arg);
	}
	ni = ic->ic_bss;
	error = ath_chan_set(sc, ni->ni_chan);
	if (error != 0)
		goto bad;
	rfilt = ath_calcrxfilter(sc);
	if (nstate == IEEE80211_S_SCAN ||
	    ic->ic_opmode == IEEE80211_M_MONITOR) {
		bssid = sc->sc_broadcast_addr;
	} else {
		bssid = ni->ni_bssid;
	}
	ath_hal_set_rx_filter(ah, rfilt);
	DPRINTF(ATH_DEBUG_ANY, ("%s: RX filter 0x%x bssid %s\n",
	    __func__, rfilt, ether_sprintf((u_char*)bssid)));

	if (nstate == IEEE80211_S_RUN && ic->ic_opmode == IEEE80211_M_STA) {
		ath_hal_set_associd(ah, bssid, ni->ni_associd);
	} else {
		ath_hal_set_associd(ah, bssid, 0);
	}

	if (!ath_softcrypto && (ic->ic_flags & IEEE80211_F_WEPON)) {
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			if (ath_hal_is_key_valid(ah, i))
				ath_hal_set_key_lladdr(ah, i, bssid);
		}
	}

	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		/* nothing to do */
	} else if (nstate == IEEE80211_S_RUN) {
		DPRINTF(ATH_DEBUG_ANY, ("%s(RUN): "
		    "ic_flags=0x%08x iv=%d bssid=%s "
		    "capinfo=0x%04x chan=%d\n",
		    __func__,
		    ic->ic_flags,
		    ni->ni_intval,
		    ether_sprintf(ni->ni_bssid),
		    ni->ni_capinfo,
		    ieee80211_chan2ieee(ic, ni->ni_chan)));

		/*
		 * Allocate and setup the beacon frame for AP or adhoc mode.
		 */
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
		    ic->ic_opmode == IEEE80211_M_IBSS) {
			error = ath_beacon_alloc(sc, ni);
			if (error != 0)
				goto bad;
		}
#endif
		/*
		 * Configure the beacon and sleep timers.
		 */
		ath_beacon_config(sc);
	} else {
		sc->sc_imask &= ~(HAL_INT_SWBA | HAL_INT_BMISS);
		ath_hal_set_intr(ah, sc->sc_imask);
	}

	/*
	 * Invoke the parent method to complete the work.
	 */
	error = (*sc->sc_newstate)(ic, nstate, arg);

	if (nstate == IEEE80211_S_RUN) {
		/* start periodic recalibration timer */
		timeout_add_sec(&sc->sc_cal_to, ath_calinterval);

		if (ic->ic_opmode != IEEE80211_M_MONITOR)
			timeout_add_msec(&sc->sc_rssadapt_to, 100);
	} else if (nstate == IEEE80211_S_SCAN) {
		/* start ap/neighbor scan timer */
		timeout_add_msec(&sc->sc_scan_to, ath_dwelltime);
	}
bad:
	return error;
}

#ifndef IEEE80211_STA_ONLY
void
ath_recv_mgmt(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, struct ieee80211_rxinfo *rxi, int subtype)
{
	struct ath_softc *sc = (struct ath_softc*)ic->ic_softc;
	struct ath_hal *ah = sc->sc_ah;

	(*sc->sc_recv_mgmt)(ic, m, ni, rxi, subtype);

	switch (subtype) {
	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
	case IEEE80211_FC0_SUBTYPE_BEACON:
		if (ic->ic_opmode != IEEE80211_M_IBSS ||
		    ic->ic_state != IEEE80211_S_RUN)
			break;
		if (ieee80211_ibss_merge(ic, ni, ath_hal_get_tsf64(ah)) ==
		    ENETRESET)
			ath_hal_set_associd(ah, ic->ic_bss->ni_bssid, 0);
		break;
	default:
		break;
	}
	return;
}
#endif

/*
 * Setup driver-specific state for a newly associated node.
 * Note that we're called also on a re-associate, the isnew
 * param tells us if this is the first time or not.
 */
void
ath_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		return;
}

int
ath_getchannels(struct ath_softc *sc, HAL_BOOL outdoor, HAL_BOOL xchanmode)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ath_hal *ah = sc->sc_ah;
	HAL_CHANNEL *chans;
	int i, ix, nchan;

	sc->sc_nchan = 0;
	chans = malloc(IEEE80211_CHAN_MAX * sizeof(HAL_CHANNEL),
			M_TEMP, M_NOWAIT);
	if (chans == NULL) {
		printf("%s: unable to allocate channel table\n", ifp->if_xname);
		return ENOMEM;
	}
	if (!ath_hal_init_channels(ah, chans, IEEE80211_CHAN_MAX, &nchan,
	    HAL_MODE_ALL, outdoor, xchanmode)) {
		printf("%s: unable to collect channel list from hal\n",
		    ifp->if_xname);
		free(chans, M_TEMP, 0);
		return EINVAL;
	}

	/*
	 * Convert HAL channels to ieee80211 ones and insert
	 * them in the table according to their channel number.
	 */
	for (i = 0; i < nchan; i++) {
		HAL_CHANNEL *c = &chans[i];
		ix = ieee80211_mhz2ieee(c->channel, c->channelFlags);
		if (ix > IEEE80211_CHAN_MAX) {
			printf("%s: bad hal channel %u (%u/%x) ignored\n",
				ifp->if_xname, ix, c->channel, c->channelFlags);
			continue;
		}
		DPRINTF(ATH_DEBUG_ANY,
		    ("%s: HAL channel %d/%d freq %d flags %#04x idx %d\n",
		    sc->sc_dev.dv_xname, i, nchan, c->channel, c->channelFlags,
		    ix));
		/* NB: flags are known to be compatible */
		if (ic->ic_channels[ix].ic_freq == 0) {
			ic->ic_channels[ix].ic_freq = c->channel;
			ic->ic_channels[ix].ic_flags = c->channelFlags;
		} else {
			/* channels overlap; e.g. 11g and 11b */
			ic->ic_channels[ix].ic_flags |= c->channelFlags;
		}
		/* count valid channels */
		sc->sc_nchan++;
	}
	free(chans, M_TEMP, 0);

	if (sc->sc_nchan < 1) {
		printf("%s: no valid channels for regdomain %s(%u)\n",
		    ifp->if_xname, ieee80211_regdomain2name(ah->ah_regdomain),
		    ah->ah_regdomain);
		return ENOENT;
	}

	/* set an initial channel */
	ic->ic_ibss_chan = &ic->ic_channels[0];

	return 0;
}

int
ath_rate_setup(struct ath_softc *sc, u_int mode)
{
	struct ath_hal *ah = sc->sc_ah;
	struct ieee80211com *ic = &sc->sc_ic;
	const HAL_RATE_TABLE *rt;
	struct ieee80211_rateset *rs;
	int i, maxrates;

	switch (mode) {
	case IEEE80211_MODE_11A:
		sc->sc_rates[mode] = ath_hal_get_rate_table(ah, HAL_MODE_11A);
		break;
	case IEEE80211_MODE_11B:
		sc->sc_rates[mode] = ath_hal_get_rate_table(ah, HAL_MODE_11B);
		break;
	case IEEE80211_MODE_11G:
		sc->sc_rates[mode] = ath_hal_get_rate_table(ah, HAL_MODE_11G);
		break;
	default:
		DPRINTF(ATH_DEBUG_ANY,
		    ("%s: invalid mode %u\n", __func__, mode));
		return 0;
	}
	rt = sc->sc_rates[mode];
	if (rt == NULL)
		return 0;
	if (rt->rateCount > IEEE80211_RATE_MAXSIZE) {
		DPRINTF(ATH_DEBUG_ANY,
		    ("%s: rate table too small (%u > %u)\n",
		    __func__, rt->rateCount, IEEE80211_RATE_MAXSIZE));
		maxrates = IEEE80211_RATE_MAXSIZE;
	} else {
		maxrates = rt->rateCount;
	}
	rs = &ic->ic_sup_rates[mode];
	for (i = 0; i < maxrates; i++)
		rs->rs_rates[i] = rt->info[i].dot11Rate;
	rs->rs_nrates = maxrates;
	return 1;
}

void
ath_setcurmode(struct ath_softc *sc, enum ieee80211_phymode mode)
{
	const HAL_RATE_TABLE *rt;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	int i;

	memset(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));
	rt = sc->sc_rates[mode];
	KASSERT(rt != NULL, ("no h/w rate set for phy mode %u", mode));
	for (i = 0; i < rt->rateCount; i++)
		sc->sc_rixmap[rt->info[i].dot11Rate & IEEE80211_RATE_VAL] = i;
	bzero(sc->sc_hwmap, sizeof(sc->sc_hwmap));
	for (i = 0; i < 32; i++)
		sc->sc_hwmap[i] = rt->info[rt->rateCodeToIndex[i]].dot11Rate;
	sc->sc_currates = rt;
	sc->sc_curmode = mode;
	ni = ic->ic_bss;
	ni->ni_rates.rs_nrates = sc->sc_currates->rateCount;
	if (ni->ni_txrate >= ni->ni_rates.rs_nrates)
		ni->ni_txrate = 0;
}

void
ath_rssadapt_updatenode(void *arg, struct ieee80211_node *ni)
{
	struct ath_node *an = ATH_NODE(ni);

	ieee80211_rssadapt_updatestats(&an->an_rssadapt);
}

void
ath_rssadapt_updatestats(void *arg)
{
	struct ath_softc *sc = (struct ath_softc *)arg;
	struct ieee80211com *ic = &sc->sc_ic;

	if (ic->ic_opmode == IEEE80211_M_STA) {
		ath_rssadapt_updatenode(arg, ic->ic_bss);
	} else {
		ieee80211_iterate_nodes(ic, ath_rssadapt_updatenode, arg);
	}

	timeout_add_msec(&sc->sc_rssadapt_to, 100);
}

#ifdef AR_DEBUG
void
ath_printrxbuf(struct ath_buf *bf, int done)
{
	struct ath_desc *ds;
	int i;

	for (i = 0, ds = bf->bf_desc; i < bf->bf_nseg; i++, ds++) {
		printf("R%d (%p %p) %08x %08x %08x %08x %08x %08x %c\n",
		    i, ds, (struct ath_desc *)bf->bf_daddr + i,
		    ds->ds_link, ds->ds_data,
		    ds->ds_ctl0, ds->ds_ctl1,
		    ds->ds_hw[0], ds->ds_hw[1],
		    !done ? ' ' : (ds->ds_rxstat.rs_status == 0) ? '*' : '!');
	}
}

void
ath_printtxbuf(struct ath_buf *bf, int done)
{
	struct ath_desc *ds;
	int i;

	for (i = 0, ds = bf->bf_desc; i < bf->bf_nseg; i++, ds++) {
		printf("T%d (%p %p) "
		    "%08x %08x %08x %08x %08x %08x %08x %08x %c\n",
		    i, ds, (struct ath_desc *)bf->bf_daddr + i,
		    ds->ds_link, ds->ds_data,
		    ds->ds_ctl0, ds->ds_ctl1,
		    ds->ds_hw[0], ds->ds_hw[1], ds->ds_hw[2], ds->ds_hw[3],
		    !done ? ' ' : (ds->ds_txstat.ts_status == 0) ? '*' : '!');
	}
}
#endif /* AR_DEBUG */

int
ath_gpio_attach(struct ath_softc *sc, u_int16_t devid)
{
	struct ath_hal *ah = sc->sc_ah;
	struct gpiobus_attach_args gba;
	int i;

	if (ah->ah_gpio_npins < 1)
		return 0;

	/* Initialize gpio pins array */
	for (i = 0; i < ah->ah_gpio_npins && i < AR5K_MAX_GPIO; i++) {
		sc->sc_gpio_pins[i].pin_num = i;
		sc->sc_gpio_pins[i].pin_caps = GPIO_PIN_INPUT |
		    GPIO_PIN_OUTPUT;

		/* Set pin mode to input */
		ath_hal_set_gpio_input(ah, i);
		sc->sc_gpio_pins[i].pin_flags = GPIO_PIN_INPUT;

		/* Get pin input */
		sc->sc_gpio_pins[i].pin_state = ath_hal_get_gpio(ah, i) ?
		    GPIO_PIN_HIGH : GPIO_PIN_LOW;
	}

	/* Enable GPIO-controlled software LED if available */
	if ((ah->ah_version == AR5K_AR5211) ||
	    (devid == PCI_PRODUCT_ATHEROS_AR5212_IBM)) {
		sc->sc_softled = 1;
		ath_hal_set_gpio_output(ah, AR5K_SOFTLED_PIN);
		ath_hal_set_gpio(ah, AR5K_SOFTLED_PIN, AR5K_SOFTLED_OFF);
	}

	/* Create gpio controller tag */
	sc->sc_gpio_gc.gp_cookie = sc;
	sc->sc_gpio_gc.gp_pin_read = ath_gpio_pin_read;
	sc->sc_gpio_gc.gp_pin_write = ath_gpio_pin_write;
	sc->sc_gpio_gc.gp_pin_ctl = ath_gpio_pin_ctl;

	gba.gba_name = "gpio";
	gba.gba_gc = &sc->sc_gpio_gc;
	gba.gba_pins = sc->sc_gpio_pins;
	gba.gba_npins = ah->ah_gpio_npins;

#ifdef notyet
#if NGPIO > 0
	if (config_found(&sc->sc_dev, &gba, gpiobus_print) == NULL)
		return (ENODEV);
#endif
#endif

	return (0);
}

int
ath_gpio_pin_read(void *arg, int pin)
{
	struct ath_softc *sc = arg;
	struct ath_hal *ah = sc->sc_ah;
	return (ath_hal_get_gpio(ah, pin) ? GPIO_PIN_HIGH : GPIO_PIN_LOW);
}

void
ath_gpio_pin_write(void *arg, int pin, int value)
{
	struct ath_softc *sc = arg;
	struct ath_hal *ah = sc->sc_ah;
	ath_hal_set_gpio(ah, pin, value ? GPIO_PIN_HIGH : GPIO_PIN_LOW);
}

void
ath_gpio_pin_ctl(void *arg, int pin, int flags)
{
	struct ath_softc *sc = arg;
	struct ath_hal *ah = sc->sc_ah;

	if (flags & GPIO_PIN_INPUT) {
		ath_hal_set_gpio_input(ah, pin);
	} else if (flags & GPIO_PIN_OUTPUT) {
		ath_hal_set_gpio_output(ah, pin);
	}
}
@


1.113
log
@Convert some malloc(9) to mallocarray(9)

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.112 2017/01/22 10:17:37 dlg Exp $  */
d2976 1
a2976 1
	chans = mallocarray(IEEE80211_CHAN_MAX, sizeof(HAL_CHANNEL),
@


1.112
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.111 2016/04/13 10:49:26 mpi Exp $  */
d2976 1
a2976 1
	chans = malloc(IEEE80211_CHAN_MAX * sizeof(HAL_CHANNEL),
@


1.111
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.110 2016/01/12 09:28:09 stsp Exp $  */
a876 1
			ifp->if_opackets++;
@


1.110
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.109 2015/12/08 13:34:22 tedu Exp $  */
a359 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.109
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.108 2015/11/25 03:09:58 dlg Exp $  */
a301 1
	ath_rate_setup(sc, IEEE80211_MODE_TURBO);
a618 2
	case IEEE80211_MODE_TURBO:
		return CHANNEL_T;
a3051 3
		break;
	case IEEE80211_MODE_TURBO:
		sc->sc_rates[mode] = ath_hal_get_rate_table(ah, HAL_MODE_TURBO);
@


1.108
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.107 2015/11/04 12:11:59 dlg Exp $  */
d353 1
a353 2
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST
	    | IFF_NOTRAILERS;
@


1.107
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.106 2015/10/25 12:48:46 mpi Exp $  */
d837 1
a837 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING ||
d853 1
a853 1
			ifp->if_flags |= IFF_OACTIVE;
d2510 1
a2510 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2575 1
a2575 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.106
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.105 2015/03/14 03:38:47 jsg Exp $  */
d860 1
a860 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
@


1.105
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.104 2015/02/10 23:25:46 mpi Exp $  */
a979 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a985 3
		if (ifa->ifa_addr->sa_family == AF_INET) {
			arp_ifinit(&ic->ic_ac, ifa);
		}
@


1.104
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.103 2014/12/22 02:28:51 tedu Exp $  */
a64 1
#include <net/if_arp.h>
@


1.103
log
@unifdef INET
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.102 2014/12/19 22:44:58 guenther Exp $  */
a1956 1
		m->m_pkthdr.rcvif = ifp;
@


1.102
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.101 2014/07/12 18:48:17 tedu Exp $  */
a68 1
#ifdef INET
a70 1
#endif
a987 1
#ifdef INET
a990 1
#endif  /* INET */
@


1.101
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.100 2014/07/10 11:34:48 stsp Exp $  */
d58 1
a59 1
#include <machine/endian.h>
d2137 1
a2137 1
#if _BYTE_ORDER == _BIG_ENDIAN
@


1.100
log
@Show eeprom version of ath devices in dmesg; ok reyk
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.99 2014/03/19 10:09:19 mpi Exp $  */
d1681 1
a1681 1
	free(sc->sc_bufptr, M_DEVBUF);
d3002 1
a3002 1
		free(chans, M_TEMP);
d3033 1
a3033 1
	free(chans, M_TEMP);
@


1.99
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.98 2013/11/26 09:50:32 mpi Exp $  */
d267 5
@


1.98
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.97 2013/11/21 16:16:08 mpi Exp $  */
d900 1
a900 11
			/*
			 * Hack!  The referenced node pointer is in the
			 * rcvif field of the packet header.  This is
			 * placed there by ieee80211_mgmt_output because
			 * we need to hold the reference with the frame
			 * and there's no other way (other than packet
			 * tags which we consider too expensive to use)
			 * to pass it along.
			 */
			ni = (struct ieee80211_node *) m->m_pkthdr.rcvif;
			m->m_pkthdr.rcvif = NULL;
@


1.97
log
@Remove unneeded include.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.96 2012/10/17 00:59:57 jsg Exp $  */
d1150 1
d1155 8
a1162 1
	ETHER_FIRST_MULTI(estep, &sc->sc_ic.ic_ac, enm);
a1163 6
		/* XXX Punt on ranges. */
		if (!IEEE80211_ADDR_EQ(enm->enm_addrlo, enm->enm_addrhi)) {
			(*mfilt)[0] = (*mfilt)[1] = ~((u_int32_t)0);
			ifp->if_flags |= IFF_ALLMULTI;
			return;
		}
@


1.96
log
@AH_BYTE_ORDER and AH_BIG_ENDIAN are holdovers from the old FreeBSD
code, we test but don't define them.  Replace with _BYTE_ORDER
and _BIG_ENDIAN to make the iv show up properly for big endian
bpf consumers.

ok stsp@@ reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.95 2012/01/29 12:33:36 stsp Exp $  */
a65 1
#include <net/if_llc.h>
@


1.95
log
@Fix another instance of the 11a->11b switch panic (see previous commit).
It could also trigger during a scan. Moving the fix into ath_setcurmode()
should fix the problem for good. Pointed out by ml@@extensibl.com; ok mikeb
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.94 2012/01/28 12:46:32 stsp Exp $  */
d2141 1
a2141 1
#if AH_BYTE_ORDER == AH_BIG_ENDIAN
@


1.94
log
@Don't panic when switching an ath interface in hostap mode from 11a to 11b.
The driver forgot to reconfigure the ic_bss' rate table during the switch.
This triggered an assertion in ieee80211_newstate() which is present to
prevent an out-of-bounds array access (11a has more rates than 11b).
Problem reported by ml@@extensibl.com; ok mikeb deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.93 2011/10/14 17:08:10 stsp Exp $  */
d716 1
a716 1
	if (mode != sc->sc_curmode) {
a717 4
		ni->ni_rates.rs_nrates = sc->sc_currates->rateCount;
		if (ni->ni_txrate >= ni->ni_rates.rs_nrates)
			ni->ni_txrate = 0;
	}
d3101 2
d3115 4
@


1.93
log
@Make ath(4) send multicast frames once, not multiple times.
Fixes TKIP replays seen by STAs connecting to an ath(4) hostap and matches
the FreeBSD driver. Tested with several cards by Theo and myself.
Thanks mikeb for providing some cards, your next beer in Berlin is on me.
ok deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.92 2011/04/17 20:38:10 stsp Exp $  */
d716 1
a716 1
	if (mode != sc->sc_curmode)
d718 4
@


1.92
log
@Don't increase if_oerrors for every multicast frame leaving the interface.
ok deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.91 2010/09/07 16:21:42 deraadt Exp $  */
d2071 1
a2071 1
	int i, error, iswep, hdrlen, pktlen, len, s;
d2379 1
d2386 1
a2386 1
		, txrate, 1+10		/* series 0 rate/tries */
@


1.91
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.90 2010/08/27 19:44:43 deraadt Exp $  */
a2490 1
				ifp->if_oerrors++;
@


1.90
log
@Get rid of the clumsy pci_activate function and do this job inside ath.c
so that the powerhook wrapper can get at it
ok kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.89 2010/08/27 17:08:00 jsg Exp $  */
a428 6
	/*
	 * Make sure the interface is shutdown during reboot.
	 */
	sc->sc_powerhook = powerhook_establish(ath_powerhook, sc);
	if (sc->sc_powerhook == NULL)
		printf(": WARNING: unable to establish power hook\n");
a477 2
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);
a483 6
}

void
ath_powerhook(int why, void *arg)
{
	ath_activate(arg, why);
@


1.89
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.88 2010/08/27 04:09:18 deraadt Exp $  */
a164 1
#if 0
d169 1
a169 1
	int rv = 0, s;
a170 1
	s = splnet();
d172 6
a177 1
	case DVACT_ACTIVATE:
d179 6
a184 2
	case DVACT_DEACTIVATE:
		if_deactivate(&sc->sc_ic.ic_if);
d187 1
a187 2
	splx(s);
	return rv;
a188 1
#endif
d432 1
a432 1
	sc->sc_powerhook = powerhook_establish(ath_power, sc);
d495 1
a495 21
ath_power(int why, void *arg)
{
	struct ath_softc *sc = arg;
	int s;

	DPRINTF(ATH_DEBUG_ANY, ("ath_power(%d)\n", why));

	s = splnet();
	switch (why) {
	case PWR_SUSPEND:
		ath_suspend(sc, why);
		break;
	case PWR_RESUME:
		ath_resume(sc, why);
		break;
	}
	splx(s);
}

void
ath_suspend(struct ath_softc *sc, int why)
d497 1
a497 21
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	DPRINTF(ATH_DEBUG_ANY, ("%s: if_flags %x\n", __func__, ifp->if_flags));

	ath_stop(ifp);
	if (sc->sc_power != NULL)
		(*sc->sc_power)(sc, why);
}

void
ath_resume(struct ath_softc *sc, int why)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	DPRINTF(ATH_DEBUG_ANY, ("%s: if_flags %x\n", __func__, ifp->if_flags));

	if (ifp->if_flags & IFF_UP) {
		ath_init(ifp);
		if (ifp->if_flags & IFF_RUNNING)
			ath_start(ifp);
	}
@


1.88
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.87 2010/08/04 21:02:24 deraadt Exp $  */
a352 1
	ifp->if_init = ath_init;
@


1.87
log
@on resume:  calling sc_power after ath_init() is silly.  ath_init()
gets down to there through ath_init() -> ath_enable() -> ...
from a discussion with damien
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.86 2010/07/02 06:06:30 reyk Exp $  */
a500 1
	case PWR_STANDBY:
@


1.86
log
@cleanup and remove some #ifdef junk in the power hooks.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.85 2010/04/20 22:05:43 tedu Exp $  */
a531 2
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
@


1.85
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.84 2009/10/13 19:33:16 pirofti Exp $  */
a142 1
void	ath_power(int, void *);
a506 6
#if !defined(__OpenBSD__)
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
#endif
a531 3
#if 0
		(void)ath_intr(sc);
#endif
@


1.84
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.83 2009/09/13 14:42:52 krw Exp $  */
a47 1
#include <sys/sysctl.h>
@


1.83
log
@M_DUP_PKTHDR() define -> m_dup_pkthdr() function to properly deal
with m_tag_copy_chain() failures.

Use m_defrag() to eliminate hand rolled defragging of mbufs and
some uses of M_DUP_PKTHDR().

Original diff from thib@@, claudio@@'s feedback integrated by me.

Tests kevlo@@ claudio@@, "reads ok" blambert@@

ok thib@@ claudio@@, "m_defrag() bits ok" kettenis@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.82 2009/08/10 20:29:54 deraadt Exp $  */
d169 1
a169 1
ath_activate(struct device *self, enum devact act)
@


1.82
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.81 2009/07/31 11:18:09 blambert Exp $  */
a2137 1
	struct mbuf *m;
d2240 1
a2240 10
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			sc->sc_stats.ast_tx_nombuf++;
			m_freem(m0);
			return ENOMEM;
		}

		M_DUP_PKTHDR(m, m0);
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
a2242 1
			m_free(m);
a2244 4
		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m, caddr_t));
		m_freem(m0);
		m->m_len = m->m_pkthdr.len;
		m0 = m;
@


1.81
log
@timeout_add -> timeout_add_msec

ok jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.80 2009/01/21 21:53:59 grange Exp $  */
a429 3
	sc->sc_sdhook = shutdownhook_establish(ath_shutdown, sc);
	if (sc->sc_sdhook == NULL)
		printf(": WARNING: unable to establish shutdown hook\n");
a483 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
a547 8
}

void
ath_shutdown(void *arg)
{
	struct ath_softc *sc = arg;

	ath_stop(&sc->sc_ic.ic_if);
@


1.80
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.79 2008/10/15 19:12:19 blambert Exp $  */
d3030 1
a3030 1
			timeout_add(&sc->sc_rssadapt_to, hz / 10);
d3227 1
a3227 1
	timeout_add(&sc->sc_rssadapt_to, hz / 10);
@


1.79
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.78 2008/09/01 09:02:59 reyk Exp $  */
d3033 1
a3033 1
		timeout_add(&sc->sc_scan_to, (hz * ath_dwelltime) / 1000);
@


1.78
log
@Switch ath(4) to softcrypto to enable support for WPA/WPA2.

Tested by ckuethe@@ and many users, thanks!
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.77 2008/08/29 11:15:32 reyk Exp $  */
d2897 1
a2897 1
	timeout_add(&sc->sc_cal_to, hz * ath_calinterval);
d3027 1
a3027 1
		timeout_add(&sc->sc_cal_to, hz * ath_calinterval);
@


1.77
log
@add support for software crypto to allow WPA/WPA2/RSN.  it is disabled
for now because it needs more testing, but basic WPA/WPA2 and WEP
seems to work.  to enable it, set the compiled-in ath_softcrypto
variable to 1.

this is based on a previous diff from damien@@ with some changes to
disable the hardware crypto engine if softcrypto is enabled and to
keeps the hardware crypto code in place to allow later work on
hardware WPA/WPA2.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.76 2008/08/27 10:01:18 damien Exp $  */
d161 1
a161 1
int ath_softcrypto = 0;			/* 1=enable software crypto */
@


1.76
log
@add IEEE80211_RADIOTAP_F_FCS radiotap flag from NetBSD.

use it in drivers that leave the 802.11 FCS in frames
passed to radiotap BPF.  otherwise, userland has no way
to know if FCS is included or not as it depends on drivers.
this is required by some ports (aircrack).

requested by dhill@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.75 2008/08/27 09:05:03 damien Exp $  */
d81 1
d161 1
d375 2
d758 5
a762 13
	/*
	 * Setup the hardware after reset: the key cache
	 * is filled as needed and the receive engine is
	 * set going.  Frame transmit is handled entirely
	 * in the frame output path; there's nothing to do
	 * here except setup the interrupt mask.
	 */
	if (ic->ic_flags & IEEE80211_F_WEPON) {
		if ((error = ath_initkeytable(sc)) != 0) {
			printf("%s: unable to initialize the key cache\n",
			    ifp->if_xname);
			goto done;
		}
d764 1
d1156 23
d1930 2
a1931 1
	struct ieee80211_frame *wh, whbuf;
d2069 1
a2069 1
		if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
d2153 1
d2166 1
a2166 1
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
d2170 9
a2178 1
	if (iswep) {
d2450 1
a2450 1
		if (iswep)
d2941 2
a2942 1
	int i, error;
d2980 1
a2980 1
	if (ic->ic_flags & IEEE80211_F_WEPON) {
@


1.75
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.74 2008/08/25 20:43:49 jmc Exp $  */
d2028 1
@


1.74
log
@two spelling fixes from Anathae Townsend;
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.73 2008/08/14 16:02:24 damien Exp $  */
d101 1
d105 1
d138 1
d141 1
d317 1
d319 1
d366 1
d369 1
d397 1
d400 1
d779 1
d782 1
d846 1
d848 1
d1254 1
d1256 1
d1309 1
d1458 1
d1550 3
a1552 1
	} else {
d1584 1
a1824 1
	struct ieee80211com *ic = &sc->sc_ic;
d1881 2
a1882 1
	if (ic->ic_opmode != IEEE80211_M_HOSTAP)
d1884 1
d2971 1
d2978 1
a2978 1

d3007 1
d3032 1
@


1.73
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.72 2008/07/30 07:43:01 reyk Exp $  */
d1538 2
a1539 2
			 * In IBSS mode enable the beacon timers but ony
			 * enable SWBA interrupts if we need to moanually
@


1.72
log
@spacing
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.71 2008/07/29 00:18:25 reyk Exp $  */
a2088 3

	if ((ifp->if_flags & IFF_OACTIVE) == 0 && !IFQ_IS_EMPTY(&ifp->if_snd))
		ath_start(ifp);
@


1.71
log
@- fix FIFO overruns on PCI-E chipsets by setting the DMA size
RX/TX configuration registers to 128 instead of 512 bytes.
- add a few more MAC/RF id strings for the dmesg.
- check for PCI-E instead of single chip variants in a few places.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.70 2008/07/21 18:43:19 damien Exp $  */
d1729 1
a1729 1
	
@


1.70
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.69 2007/10/13 16:12:29 fgsch Exp $  */
d220 2
a221 2
	ah = ath_hal_attach(devid, sc, sc->sc_st, sc->sc_sh, sc->sc_64bit,
	    &status);
@


1.69
log
@remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.68 2007/10/01 04:03:51 krw Exp $  */
d137 1
a137 1
	    struct ieee80211_node *, int, int, u_int32_t);
d1889 1
a2021 1

d2024 1
d2043 2
d2068 3
a2070 2
		ieee80211_input(ifp, m, ni,
		    ds->ds_rxstat.rs_rssi, ds->ds_rxstat.rs_tstamp);
d2989 1
a2989 1
    struct ieee80211_node *ni, int subtype, int rssi, u_int32_t rstamp)
d2994 1
a2994 1
	(*sc->sc_recv_mgmt)(ic, m, ni, subtype, rssi, rstamp);
@


1.68
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.67 2007/09/18 00:46:41 krw Exp $  */
a1121 2
				struct ieee80211com *ic = &sc->sc_ic;

@


1.67
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.66 2007/07/18 18:10:31 damien Exp $  */
d1730 3
a1732 2
	struct ath_node *an =
		malloc(sizeof(struct ath_node), M_DEVBUF, M_NOWAIT);
a1734 1
		bzero(an, sizeof(struct ath_node));
@


1.66
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.65 2007/06/16 13:17:05 damien Exp $  */
d1616 1
a1616 1
	bf = malloc(bsize, M_DEVBUF, M_NOWAIT);
a1622 1
	bzero(bf, bsize);
@


1.65
log
@constify
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.64 2007/06/06 21:41:32 reyk Exp $  */
d1149 2
a1150 2
		struct ieee80211_wepkey *k = &ic->ic_nw_keys[i];
		if (k->wk_len == 0)
a1155 2
			bcopy(k->wk_key, hk.wk_key, k->wk_len);

d1163 1
a1163 1
			if (k->wk_len <= AR5K_KEYVAL_LENGTH_40)
d1165 1
a1165 1
			else if (k->wk_len <= AR5K_KEYVAL_LENGTH_104)
a1166 2
			else if (k->wk_len <= AR5K_KEYVAL_LENGTH_128)
				hk.wk_len = AR5K_KEYVAL_LENGTH_128;
d1169 1
@


1.64
log
@the copyright holder changed the license from "dual bsd/gpl" to be
2-clause bsd-only. good.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.63 2007/05/09 16:41:14 reyk Exp $  */
d113 1
a113 1
	    struct ieee80211_node *);
d1772 1
a1772 1
ath_node_getrssi(struct ieee80211com *ic, struct ieee80211_node *ni)
d1774 1
a1774 1
	struct ath_node *an = ATH_NODE(ni);
d1785 1
a1785 1
		struct ath_recv_hist *rh = &an->an_rx_hist[i];
@


1.63
log
@remove the internal wrapper functions for ieee80211_mhz2ieee and
ieee80211_ieee2mhz which also removes some dead code.

figured out by deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.62 2007/04/13 14:44:41 reyk Exp $  */
a20 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.62
log
@The integrated Atheros NICs found in IBM/Lenovo ThinkPads use the same
device ID for old AR5212-based 32bit and new AR5424-based 64bit (PCI
Express Mini Card) interfaces.  Use an extra check to look if the card
is 64bit and attach it as a single chip device.  This prevents a panic
when attaching the device on some laptops like the T60.

Tested on a T42 (old AR5212 Mini PCI interface),
Tested on a T60 (new AR5424 Mini Card interface)

Nevertheless, the AR5424 does not work yet.

Thanks to Stefan Konrath
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.61 2007/01/03 18:16:43 claudio Exp $  */
d3060 1
a3060 1
		ix = ath_hal_mhz2ieee(c->channel, c->channelFlags);
@


1.61
log
@M_DUP_PKTHDR() cleanup. On static buffers M_DUP_PKTHDR() will leak mbuf tags.
See similar rum(4) commit for more info. OK mglocker@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.60 2006/12/14 09:23:24 reyk Exp $  */
d224 2
a225 1
	ah = ath_hal_attach(devid, sc, sc->sc_st, sc->sc_sh, &status);
@


1.60
log
@fix a minor bug in the tx data queue setup by using the right queue
type. this would cause us some more trouble with WME which isn't
supported yet...

thanks to Nick Kossifidis
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.59 2006/11/06 08:48:49 reyk Exp $  */
a2020 1
			M_DUP_PKTHDR(&mb, m);
d2024 3
a2026 2
			mb.m_pkthdr.len += mb.m_len;

a2412 1
		M_DUP_PKTHDR(&mb, m0);
d2416 3
a2418 1
		mb.m_pkthdr.len += mb.m_len;
@


1.59
log
@figured out by tdeval@@:
>During factorization in 1.57, the switch block was moved too early.
>Hence it's updating an uninitialized ah structure.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.58 2006/10/19 10:55:56 tom Exp $  */
d325 1
a325 1
	sc->sc_bhalq = ath_hal_setup_tx_queue(ah,HAL_TX_QUEUE_BEACON,NULL);
d333 1
@


1.58
log
@s/Mhz/MHz/ in comments and printf() strings

ok jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.57 2006/10/14 16:16:18 reyk Exp $  */
a222 17

	switch (devid) {
	case PCI_PRODUCT_ATHEROS_AR2413:
	case PCI_PRODUCT_ATHEROS_AR5413:
	case PCI_PRODUCT_ATHEROS_AR5424:
		/*
		 * Known single chip solutions
		 */
		ah->ah_single_chip = AH_TRUE;
		break;
	default:
		/*
		 * Multi chip solutions
		 */
		ah->ah_single_chip = AH_FALSE;
		break;
	}
@


1.57
log
@fix the slightly different reset procedure of single chip variants.
this should successfully initialize the ar5424 PCI-E chipset.

figured out by kettenis@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.56 2006/09/19 17:49:13 reyk Exp $  */
d2756 1
a2756 1
				"channel %u (%u Mhz)\n", ifp->if_xname,
@


1.56
log
@attach and enable the newer chipset generations AR2413, AR5413, and
AR5424. unlike the previous chipset generations, these chipsets are
single chip solutions. the AR5424 is a PCI Express chipset as found in
various intel Macs.

support is still incomplete- 11a mode works and 11b mode is rx-only. i
need some more test reports, hardware donations (there are several
different subrevisions) and time to finish it.

thanks for help from kettenis@@
"of course!" deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.55 2006/09/19 17:08:01 reyk Exp $  */
d224 17
d255 1
a255 8
	switch (devid) {
	case PCI_PRODUCT_ATHEROS_AR2413:
	case PCI_PRODUCT_ATHEROS_AR5413:
	case PCI_PRODUCT_ATHEROS_AR5424:
		/*
		 * Known single chip solutions
		 */
		ah->ah_single_chip = AH_TRUE;
d262 1
a262 6
		break;
	default:
		/*
		 * Multi chip solutions
		 */
		ah->ah_single_chip = AH_FALSE;
a277 1
		break;
@


1.55
log
@detect the newer single chip generations AR2413, AR5413 and AR5224 but
don't attach them, yet.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.54 2006/09/19 16:46:39 reyk Exp $  */
d245 1
d257 1
d276 1
d283 1
@


1.54
log
@"pure g" is a special, non-standard ofdm-only mode. use the standard
dynamic cck/ofdm "11g" mode instead.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.53 2006/09/19 13:25:54 reyk Exp $  */
d238 22
a259 9
	printf("%s: AR%s %u.%u phy %u.%u", ifp->if_xname,
	    ar5k_printver(AR5K_VERSION_VER, ah->ah_mac_srev),
	    ah->ah_mac_version, ah->ah_mac_revision,
	    ah->ah_phy_revision >> 4, ah->ah_phy_revision & 0xf);
	printf(" rf%s %u.%u",
	    ar5k_printver(AR5K_VERSION_RAD, ah->ah_radio_5ghz_revision),
	    ah->ah_radio_5ghz_revision >> 4,
	    ah->ah_radio_5ghz_revision & 0xf);
	if (ah->ah_radio_2ghz_revision != 0) {
d261 11
a271 4
		    ar5k_printver(AR5K_VERSION_RAD,
		    ah->ah_radio_2ghz_revision),
		    ah->ah_radio_2ghz_revision >> 4,
		    ah->ah_radio_2ghz_revision & 0xf);
@


1.53
log
@use the correct antenna mode settings and fix a bug in the tx
descriptor setup. this will fix various issues including 11a mode with
ar5212.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.52 2006/06/23 21:53:01 reyk Exp $  */
d673 1
a673 1
		return CHANNEL_PUREG;
@


1.52
log
@set the RSSI Max value in ath(4) and use the new RSSI radiotap header
instead of the old db signal header. also allow tcpdump and hostapd to
print the new RSSI radiotap header values current/max rssi.

ok damien@@ jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.51 2006/06/23 06:27:11 miod Exp $  */
d728 1
a728 1
	if (!ath_hal_reset(ah, ic->ic_opmode, &hchan, AH_FALSE, &status)) {
@


1.51
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.50 2006/05/22 20:35:12 krw Exp $  */
d382 1
a2004 1
			sc->sc_rxtap.wr_antsignal = ds->ds_rxstat.rs_rssi;
d2006 2
@


1.50
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.49 2006/05/08 18:32:11 pedro Exp $  */
a174 1
		rv = EOPNOTSUPP;
@


1.49
log
@Make ath_attach() return error if the RF is unsupported so the PCI code
can disable its shutdown hooks, otherwise we will panic upon halt.
Okay jsg@@ and brad@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.48 2006/04/20 20:29:56 miod Exp $  */
d462 4
a465 2
	powerhook_disestablish(sc->sc_powerhook);
	shutdownhook_disestablish(sc->sc_sdhook);
@


1.48
log
@printf() calls with the format string spanning several lines should not have
trailing commas between string chunks, for this has unexpected effects.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.47 2006/03/25 22:41:42 djm Exp $  */
d258 1
@


1.47
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.46 2006/02/20 20:12:13 damien Exp $  */
d2733 1
a2733 1
			printf("%s: ath_chan_set: unable to restart recv ",
@


1.46
log
@Fix kernel builds without bpfilter. Linking is still broken.

"Please commit this diff ASAP" brad@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.45 2006/01/04 06:04:41 canacar Exp $  */
d939 1
a939 1
				bpf_mtap(ifp->if_bpf, m);
d2011 1
a2011 1
			bpf_mtap(sc->sc_drvbpf, &mb);
d2381 1
a2381 1
		bpf_mtap(ic->ic_rawbpf, m0);
d2402 1
a2402 1
		bpf_mtap(sc->sc_drvbpf, &mb);
@


1.46.2.1
log
@MFC:
Fix by pedro@@

Make ath_attach() return error if the RF is unsupported so the PCI code
can disable its shutdown hooks, otherwise we will panic upon halt.

ok deraadt@@ pedro@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.46 2006/02/20 20:12:13 damien Exp $  */
a257 1
		error = EOPNOTSUPP;
@


1.45
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.44 2005/12/10 15:43:11 krw Exp $  */
d2738 1
d2746 1
@


1.44
log
@Initialize flags before using it. Spotted by lint.

ok reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.43 2005/11/11 14:11:40 reyk Exp $  */
a453 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.43
log
@more verbose error message for the "bogus xmit rate" problem
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.42 2005/09/23 20:06:50 reyk Exp $  */
d1300 1
a1300 1
	u_int flags;
@


1.42
log
@cleanup and simplify the regulation domain handling. some devices are
known to have a broken/unsupported regulation domain stored in their
EEPROM, we use the default instead (Canada). there's no need to
manually define COUNTRYCODE in ar5xxx.c anymore for invalid EEPROMs
but it's still possible to force a specific country - your choice.

ok aanriot@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.41 2005/09/22 10:17:04 reyk Exp $  */
d2284 3
a2286 2
			printf("%s: bogus xmit rate 0x%x\n", ifp->if_xname,
				ni->ni_rates.rs_rates[ni->ni_txrate]);
@


1.41
log
@remove the very basic ath(4) rate control implementation and use
rssadapt(9) instead. this may need some further work but now it's in
the right place and shared with other drivers (like ral(4)).

yes jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.40 2005/09/19 10:27:08 reyk Exp $  */
d134 1
a134 1
int	ath_getchannels(struct ath_softc *, u_int cc, HAL_BOOL outdoor,
a159 2
int ath_countrycode = CTRY_DEFAULT;	/* country code */
int ath_regdomain = DMN_DEFAULT;	/* regulatory domain */
d223 1
d265 3
a267 4
	 * Collect the channel list using the default country
	 * code and including outdoor channels.  The 802.11 layer
	 * is resposible for filtering this list based on settings
	 * like the phy mode.
d269 6
a274 2
	error = ath_getchannels(sc, ath_countrycode, ath_outdoor,
	    ath_xchanmode);
a276 6
	/*
	 * Copy these back; they are set as a side effect
	 * of constructing the channel list.
	 */
	ath_hal_get_regdomain(ah, &ath_regdomain);
	ath_hal_getcountrycode(ah, &ath_countrycode);
d413 7
a419 1
	printf(", %s, address %s\n", ieee80211_regdomain2name(ath_regdomain),
d3013 1
a3013 2
ath_getchannels(struct ath_softc *sc, u_int cc, HAL_BOOL outdoor,
    HAL_BOOL xchanmode)
d3029 1
a3029 1
	    cc, HAL_MODE_ALL, outdoor, xchanmode)) {
d3067 2
a3068 2
		    ifp->if_xname, ieee80211_regdomain2name(ath_regdomain),
		    sc->sc_ah->ah_capabilities.cap_eeprom.ee_regdomain);
@


1.40
log
@don't attach unsupported radio chipsets

based on a diff by jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.39 2005/09/08 17:38:11 reyk Exp $  */
d81 1
d138 2
a139 3
void	ath_rate_ctl_reset(struct ath_softc *, enum ieee80211_state);
void	ath_rate_ctl_tx_reset(void *, struct ieee80211_node *);
void	ath_rate_ctl(void *, struct ieee80211_node *);
d297 1
d446 4
a1019 1
	struct ieee80211com *ic = &sc->sc_ic;
d1034 1
a1034 11
	if (ic->ic_fixed_rate == -1) {
		/*
		 * Run the rate control algorithm if we're not
		 * locked at a fixed rate.
		 */
		if (ic->ic_opmode == IEEE80211_M_STA) {
			ath_rate_ctl(sc, ic->ic_bss);
		} else {
			ieee80211_iterate_nodes(ic, ath_rate_ctl, sc);
		}
	}
d2060 5
a2064 1
			ds->ds_rxstat.rs_rssi, ds->ds_rxstat.rs_tstamp);
d2237 1
d2248 1
d2269 10
d2280 1
a2280 1
				IEEE80211_RATE_VAL];
d2290 1
a2372 1
	an = (struct ath_node *) ni;
d2513 3
a2515 1
				an->an_tx_ok++;
d2518 3
a2520 1
				an->an_tx_err++;
a2533 2
			if (sr + lr)
				an->an_tx_retr++;
d2889 1
a2954 4
	 * Reset the rate control state.
	 */
	ath_rate_ctl_reset(sc, nstate);
	/*
d2962 3
a3007 15

	if (isnew) {
		struct ath_node *an = (struct ath_node *) ni;

		an->an_tx_ok = an->an_tx_err =
			an->an_tx_retr = an->an_tx_upper = 0;
		/* start with highest negotiated rate */
		/*
		 * XXX should do otherwise but only when
		 * the rate control algorithm is better.
		 */
		KASSERT(ni->ni_rates.rs_nrates > 0,
			("new association w/ no rates!"));
		ni->ni_txrate = ni->ni_rates.rs_nrates - 1;
	}
a3139 3
/*
 * Reset the rate control state for each 802.11 state transition.
 */
d3141 1
a3141 1
ath_rate_ctl_reset(struct ath_softc *sc, enum ieee80211_state state)
d3143 1
a3143 3
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct ath_node *an;
d3145 1
a3145 26
	/*
	 * When operating as a station the node table holds
	 * the AP's that were discovered during scanning.
	 * For any other operating mode we want to reset the
	 * tx rate state of each node.
	 */
	if (ic->ic_opmode != IEEE80211_M_STA)
		ieee80211_iterate_nodes(ic, ath_rate_ctl_tx_reset, NULL);

	/*
	 * Reset local xmit state; this is really only meaningful
	 * when operating in station or adhoc mode.
	 */
	ni = ic->ic_bss;
	an = (struct ath_node *) ni;
	an->an_tx_ok = an->an_tx_err = an->an_tx_retr = an->an_tx_upper = 0;
	if (state == IEEE80211_S_RUN &&
	    ic->ic_opmode != IEEE80211_M_MONITOR) {
		/* start with highest negotiated rate */
		KASSERT(ni->ni_rates.rs_nrates > 0,
			("transition to RUN state w/ no rates!"));
		ni->ni_txrate = ni->ni_rates.rs_nrates - 1;
	} else {
		/* use lowest rate */
		ni->ni_txrate = 0;
	}
d3149 1
a3149 1
ath_rate_ctl_tx_reset(void *arg, struct ieee80211_node *ni)
d3151 2
a3152 5
	struct ath_node *an = (struct ath_node *) ni;
	ni->ni_txrate = 0;		/* use lowest rate */
	an->an_tx_ok = an->an_tx_err = an->an_tx_retr =
	    an->an_tx_upper = 0;
}
d3154 4
a3157 53
/* 
 * Examine and potentially adjust the transmit rate.
 */
void
ath_rate_ctl(void *arg, struct ieee80211_node *ni)
{
	struct ath_softc *sc = arg;
	struct ath_node *an = (struct ath_node *) ni;
	struct ieee80211_rateset *rs = &ni->ni_rates;
	int mod = 0, orate, enough;

	/*
	 * Rate control
	 * XXX: very primitive version.
	 */
	sc->sc_stats.ast_rate_calls++;

	enough = (an->an_tx_ok + an->an_tx_err >= 10);

	/* no packet reached -> down */
	if (an->an_tx_err > 0 && an->an_tx_ok == 0)
		mod = -1;

	/* all packets needs retry in average -> down */
	if (enough && an->an_tx_ok < an->an_tx_retr)
		mod = -1;

	/* no error and less than 10% of packets needs retry -> up */
	if (enough && an->an_tx_err == 0 && an->an_tx_ok > an->an_tx_retr * 10)
		mod = 1;

	orate = ni->ni_txrate;
	switch (mod) {
	case 0:
		if (enough && an->an_tx_upper > 0)
			an->an_tx_upper--;
		break;
	case -1:
		if (ni->ni_txrate > 0) {
			ni->ni_txrate--;
			sc->sc_stats.ast_rate_drop++;
		}
		an->an_tx_upper = 0;
		break;
	case 1:
		if (++an->an_tx_upper < 2)
			break;
		an->an_tx_upper = 0;
		if (ni->ni_txrate + 1 < rs->rs_nrates) {
			ni->ni_txrate++;
			sc->sc_stats.ast_rate_raise++;
		}
		break;
d3160 1
a3160 10
	if (ni->ni_txrate != orate) {
		DPRINTF(ATH_DEBUG_RATE,
		    ("%s: %dM -> %dM (%d ok, %d err, %d retr)\n",
		    __func__,
		    (rs->rs_rates[orate] & IEEE80211_RATE_VAL) / 2,
		    (rs->rs_rates[ni->ni_txrate] & IEEE80211_RATE_VAL) / 2,
		    an->an_tx_ok, an->an_tx_err, an->an_tx_retr));
	}
	if (ni->ni_txrate != orate || enough)
		an->an_tx_ok = an->an_tx_err = an->an_tx_retr = 0;
@


1.39
log
@use ieee80211_iterate_nodes to iterate the nodes and add a extra check
for the maximal number of gpio pins.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.38 2005/09/08 17:34:30 reyk Exp $  */
d241 3
a243 3
	    ar5k_printver(AR5K_VERSION_VER, ah->ah_macVersion),
	    ah->ah_macVersion, ah->ah_macRev,
	    ah->ah_phyRev >> 4, ah->ah_phyRev & 0xf);
d245 4
a248 4
	    ar5k_printver(AR5K_VERSION_RAD, ah->ah_analog5GhzRev),
	    ah->ah_analog5GhzRev >> 4,
	    ah->ah_analog5GhzRev & 0xf);
	if (ah->ah_analog2GhzRev != 0) {
d250 10
a259 3
		    ar5k_printver(AR5K_VERSION_RAD, ah->ah_analog2GhzRev),
		    ah->ah_analog2GhzRev >> 4,
		    ah->ah_analog2GhzRev & 0xf);
d292 1
a292 2
		printf("%s: failed to allocate descriptors: %d\n",
		    ifp->if_xname, error);
d319 1
a319 2
		printf("%s: unable to setup a beacon xmit queue!\n",
		    ifp->if_xname);
d329 1
a329 2
			printf("%s: unable to setup a data xmit queue %u!\n",
			    ifp->if_xname, i);
d410 2
a411 4
	if (sc->sc_sdhook == NULL) {
		printf("%s: WARNING: unable to establish shutdown hook\n",
			sc->sc_dev.dv_xname);
	}
d413 3
a415 4
	if (sc->sc_powerhook == NULL) {
		printf("%s: WARNING: unable to establish power hook\n",
			sc->sc_dev.dv_xname);
	}
a437 2
	config_detach_children(&sc->sc_dev, flags);

d440 2
@


1.38
log
@fix a possible division by zero by using minimal default values for the
beacon interval and the beacon miss timeout (beacon interval * 7).
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.37 2005/09/08 12:44:55 jsg Exp $  */
d138 1
d3152 9
a3160 14
	if (ic->ic_opmode != IEEE80211_M_STA) {
		/*
		 * When operating as a station the node table holds
		 * the AP's that were discovered during scanning.
		 * For any other operating mode we want to reset the
		 * tx rate state of each node.
		 */
		TAILQ_FOREACH(ni, &ic->ic_node, ni_list) {
			ni->ni_txrate = 0;		/* use lowest rate */
			an = (struct ath_node *) ni;
			an->an_tx_ok = an->an_tx_err = an->an_tx_retr =
			    an->an_tx_upper = 0;
		}
	}
d3180 9
d3302 1
a3302 1
	for (i = 0; i < ah->ah_gpio_npins; i++) {
@


1.37
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.36 2005/09/08 09:11:07 jsg Exp $  */
d1466 1
a1466 1
	intval = MS_TO_TU(ni->ni_intval) & HAL_BEACON_PERIOD;
d1491 1
a1491 1
		bmisstime = MS_TO_TU(ic->ic_bmisstimeout);
@


1.36
log
@Remove FreeBSD if_printf compat function from net80211.
ok reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.35 2005/08/21 18:40:17 reyk Exp $  */
a80 1
#include <net80211/ieee80211_compat.h>
@


1.35
log
@update the 802.11 station address if the ethernet lladdr has been changed.
pointed out by Nick Holmes and Justin Reigle.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.34 2005/08/21 11:17:51 reyk Exp $  */
d228 2
a229 2
		if_printf(ifp, "unable to attach hardware; HAL status %d\n",
			status);
d234 2
a235 2
		if_printf(ifp, "HAL ABI mismatch detected (0x%x != 0x%x)\n",
			ah->ah_abi, HAL_ABI_VERSION);
d240 1
a240 1
	if_printf(ifp, "AR%s %u.%u phy %u.%u",
d285 2
a286 1
		if_printf(ifp, "failed to allocate descriptors: %d\n", error);
d313 2
a314 1
		if_printf(ifp, "unable to setup a beacon xmit queue!\n");
d324 2
a325 2
			if_printf(ifp,
			    "unable to setup a data xmit queue %u!\n", i);
d616 1
a616 1
		if_printf(ifp, "hardware error; resetting\n");
d628 1
a628 1
		if_printf(ifp, "rx FIFO overrun; resetting\n");
d721 2
a722 2
		if_printf(ifp, "unable to reset hardware; hal status %u\n",
			status);
d736 2
a737 1
			if_printf(ifp, "unable to initialize the key cache\n");
d742 1
a742 1
		if_printf(ifp, "unable to start recv logic\n");
d858 2
a859 2
		if_printf(ifp, "%s: unable to reset hardware; hal status %u\n",
			__func__, status);
d866 2
a867 1
		if_printf(ifp, "%s: unable to start recv logic\n", __func__);
d1021 1
a1021 1
			if_printf(ifp, "device timeout\n");
d1900 1
a1900 1
			if_printf(ifp, "ath_rx_proc: no buffer!\n");
d1910 1
a1910 1
			if_printf(ifp, "ath_rx_proc: no mbuf!\n");
d2271 1
a2271 1
			if_printf(ifp, "bogus xmit rate 0x%x\n",
d2681 1
d2710 2
a2711 2
			if_printf(&ic->ic_if, "ath_chan_set: unable to reset "
				"channel %u (%u Mhz)\n",
d2720 2
a2721 2
			if_printf(&ic->ic_if,
				"ath_chan_set: unable to restart recv logic\n");
d3026 1
a3026 1
		if_printf(ifp, "unable to allocate channel table\n");
d3031 2
a3032 1
		if_printf(ifp, "unable to collect channel list from hal\n");
d3045 2
a3046 2
			if_printf(ifp, "bad hal channel %u (%u/%x) ignored\n",
				ix, c->channel, c->channelFlags);
d3067 2
a3068 2
		if_printf(ifp, "no valid channels for regdomain %s(%u)\n",
		    ieee80211_regdomain2name(ath_regdomain),
@


1.34
log
@remove the IEEE80211_C_SCANALL capability, it should be used on
devices with firmware-based scanning only.

pointed out in a discussion about iwi(4) and ipw(4).
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.33 2005/08/17 13:14:17 reyk Exp $  */
d702 6
@


1.33
log
@fix led states and knf. this also enables support for the software led
in some thinkpads - turn it on in the ASSOC and RUN states.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.32 2005/07/30 17:13:17 reyk Exp $  */
a351 1
	    | IEEE80211_C_SCANALL	/* scan all channels */
@


1.32
log
@remove a useless timeout after tx (decrease nasty delays while
scanning) and fix various other minor things in the ath(4) driver.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.31 2005/07/19 23:04:37 reyk Exp $  */
d83 1
d130 1
a130 1
HAL_LED_STATE ath_state_to_led(enum ieee80211_state);
d145 1
a145 1
int	ath_gpio_attach(struct ath_softc *);
d319 2
a320 1
		sc->sc_txhalq[i] = ath_hal_setup_tx_queue(ah, HAL_TX_QUEUE_DATA, &qinfo);
d322 2
a323 1
			if_printf(ifp, "unable to setup a data xmit queue %u!\n", i);
d359 1
a359 1
	sc->sc_has_veol = ath_hal_has_veol(ah);
d417 1
a417 1
	if (ath_gpio_attach(sc) == 0)
d848 2
a849 1
	if (!ath_hal_reset(ah, ic->ic_opmode, &hchan, full ? AH_TRUE : AH_FALSE, &status)) {
d1331 1
a1331 1
	if (ic->ic_opmode == IEEE80211_M_IBSS && sc->sc_has_veol) {
d1535 1
a1535 1
			if (!sc->sc_has_veol)
d1551 1
a1551 1
		if (ic->ic_opmode == IEEE80211_M_IBSS && sc->sc_has_veol)
d2558 2
a2559 2
			    (caddr_t)(u_intptr_t) ath_hal_get_tx_buf(ah, sc->sc_txhalq[i]),
			    sc->sc_txlink));
d2814 2
a2815 2
HAL_LED_STATE
ath_state_to_led(enum ieee80211_state state)
d2817 3
d2822 1
a2822 1
		return HAL_LED_INIT;
d2824 2
a2825 1
		return HAL_LED_SCAN;
d2827 2
a2828 1
		return HAL_LED_AUTH;
d2830 3
a2832 1
		return HAL_LED_ASSOC;
d2834 9
a2842 4
		return HAL_LED_RUN;
	default:
		panic("%s: unknown 802.11 state %d", __func__, state);
		return HAL_LED_INIT;
d2863 1
a2863 1
	ath_hal_set_ledstate(ah, ath_state_to_led(nstate));	/* set LED */
d3277 1
a3277 1
ath_gpio_attach(struct ath_softc *sc)
d3299 8
@


1.31
log
@- the self linked hardware rx descriptor list does not work in hostap
mode, use the normal behaviour with rx overrun interrupts for now.
this prevents the hostap from locking under heavy load (like ping -f)
and it works more reliable.
- run ath_calibrate in splnet() context (from netbsd)
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.30 2005/07/18 02:43:26 fgsch Exp $  */
d91 1
a91 1
void	ath_reset(struct ath_softc *);
d127 1
d219 1
a219 1
	int error = 0;
d315 8
a322 6
	bzero(&qinfo, sizeof(qinfo));
	qinfo.tqi_subtype = HAL_WME_AC_BE;
	sc->sc_txhalq = ath_hal_setup_tx_queue(ah, HAL_TX_QUEUE_DATA, &qinfo);
	if (sc->sc_txhalq == (u_int) -1) {
		if_printf(ifp, "unable to setup a data xmit queue!\n");
		goto bad2;
d348 2
d611 3
a613 2
	if_printf(ifp, "hardware error; resetting\n");
	ath_reset(sc);
d623 3
a625 2
	if_printf(ifp, "rx FIFO overrun; resetting\n");
	ath_reset(sc);
d716 1
a716 1

d824 1
a824 1
ath_reset(struct ath_softc *sc)
d845 1
a845 1
	if (!ath_hal_reset(ah, ic->ic_opmode, &hchan, AH_TRUE, &status)) {
d849 1
d1009 1
a1009 1
			ath_reset(sc);
d1108 1
a1108 1
					ath_reset(sc);
d2099 1
d2371 1
d2434 1
a2434 1
		ath_hal_put_tx_buf(ah, sc->sc_txhalq, bf->bf_daddr);
d2445 1
a2445 1
	ath_hal_tx_start(ah, sc->sc_txhalq);
a2462 4
	DPRINTF(ATH_DEBUG_TX_PROC, ("%s: pending %u tx queue %p, "
	    "link %p\n", __func__, npending,
	    (caddr_t)(u_intptr_t) ath_hal_get_tx_buf(sc->sc_ah,
	    sc->sc_txhalq), sc->sc_txlink));
d2545 1
a2545 1
	int s;
d2549 8
a2556 6
		/* don't touch the hardware if marked invalid */
		(void) ath_hal_stop_tx_dma(ah, sc->sc_txhalq);
		DPRINTF(ATH_DEBUG_RESET,
		    ("%s: tx queue %p, link %p\n", __func__,
		    (caddr_t)(u_intptr_t) ath_hal_get_tx_buf(ah, sc->sc_txhalq),
		    sc->sc_txlink));
d2559 1
a2559 1
		    ("%s: beacon queue %p\n", __func__,
d2701 1
d2752 12
d2798 1
a2798 1
		ath_reset(sc);
@


1.30
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.29 2005/05/28 23:45:10 reyk Exp $  */
d1783 1
d1840 2
a1841 2

	ds->ds_link = bf->bf_daddr;	/* link to self */
d1905 1
a1905 1
				bf->bf_daddr, PA2DESC(sc, ds->ds_link));
d2755 1
d2767 1
d2786 1
@


1.29
log
@fix hostap mode
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.28 2005/05/27 09:53:55 reyk Exp $  */
d658 1
a658 1
		panic("%s: unsupported mode %d\n", __func__, mode);
d2800 1
a2800 1
		panic("%s: unknown 802.11 state %d\n", __func__, state);
@


1.28
log
@re-enable gpio init even without using the gpio(4) framework
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.27 2005/05/27 04:10:06 reyk Exp $  */
a139 1
int	ath_enable(struct ath_softc *);
d151 1
a151 1
int ath_debug = ATH_DEBUG_ANY;
d565 5
d734 2
@


1.27
log
@- disable the gpio user interface for now, it's just an unimportant
button which is not yet available on non-i386 platforms
- fix endianess and attachement on big endian platforms (tested on
macppc - ath attaches correctly, receives frames but assoc still
fails)
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.26 2005/05/24 21:46:18 reyk Exp $  */
a82 1
#ifdef notyet
a83 1
#endif
a143 2
#ifdef notyet
#if NGPIO > 0
a147 2
#endif
#endif
a409 2
#ifdef notyet
#if NGPIO > 0
a411 2
#endif
#endif
a3228 2
#ifdef notyet
#if NGPIO > 0
d3265 2
d3269 2
a3302 2
#endif /* NGPIO */
#endif
@


1.26
log
@ath_hal_rx_monitor should be used for link state monitoring instead of
setting the promisc mode. rename it to ath_hal_rx_signal and remove
the incorrect promisc flag. this should fix some problems with ath
running in forwarding mode.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.25 2005/05/11 05:15:01 reyk Exp $  */
d83 1
d85 1
d146 1
d153 1
d416 1
d421 1
d3239 1
d3312 1
@


1.25
log
@extra checks for monitor mode
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.24 2005/05/08 18:13:17 reyk Exp $  */
d2054 1
a2054 1
	ath_hal_set_rx_monitor(ah);			/* rx signal state monitoring */
a2599 1
	DELAY(3000);			/* long enough for 1 frame */
@


1.24
log
@change the dmesg output: print known chipset names, don't print the
supported 802.11a/b/g modes (this could be discovered with ifconfig -m
athX). inspired by Johan M:son Lindman and others asking about the
several different ARxxxx chipset combos.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.23 2005/04/18 18:42:55 reyk Exp $  */
d2833 2
a2834 1
	if (nstate == IEEE80211_S_SCAN) {
d2941 3
d3120 2
a3121 1
	if (state == IEEE80211_S_RUN) {
@


1.23
log
@beautify the code by renaming HAL functions with capitalized words (i
always wanted to do that). this breaks HAL compatibility but porting
should be easy, have a look at athvar.h. no functional changes.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.22 2005/04/08 22:12:21 reyk Exp $  */
d221 1
a221 1
	int error = 0, i = 0;
d240 8
a247 4
	if_printf(ifp, "mac %d.%d phy %d.%d",
		ah->ah_macVersion, ah->ah_macRev,
		ah->ah_phyRev >> 4, ah->ah_phyRev & 0xf);
	printf(" radio %d.%d", ah->ah_analog5GhzRev >> 4,
d250 3
a252 1
		printf(" %d.%d", ah->ah_analog2GhzRev >> 4,
a254 14
#define ah_mode(_m)	{						\
	if (i++) {							\
		printf("/%s", #_m);					\
	} else {							\
		printf(", 802.11%s", #_m);				\
	}								\
}									\
	if (ah->ah_modes & HAL_MODE_11A)
		ah_mode(a);
	if (ah->ah_modes & HAL_MODE_11B)
		ah_mode(b);
	if (ah->ah_modes & HAL_MODE_11G)
		ah_mode(g);
#undef ah_mode
@


1.22
log
@move reset of HAL descriptors to ath.c
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.21 2005/04/06 09:14:53 reyk Exp $  */
d281 1
a281 1
	ath_hal_getregdomain(ah, &ath_regdomain);
d319 1
a319 1
	sc->sc_bhalq = ath_hal_setuptxqueue(ah,HAL_TX_QUEUE_BEACON,NULL);
d327 1
a327 1
	sc->sc_txhalq = ath_hal_setuptxqueue(ah, HAL_TX_QUEUE_DATA, &qinfo);
d362 1
a362 1
	sc->sc_hasveol = ath_hal_hasveol(ah);
d365 1
a365 1
	ath_hal_getmac(ah, ic->ic_myaddr);
d558 1
a558 1
	if (!ath_hal_intrpend(ah))		/* shared irq, not for us */
d563 2
a564 2
		ath_hal_getisr(ah, &status);	/* clear ISR */
		ath_hal_intrset(ah, 0);		/* disable further intr's */
d567 1
a567 1
	ath_hal_getisr(ah, &status);		/* NB: clears ISR too */
d572 1
a572 1
		ath_hal_intrset(ah, 0);		/* disable intr's until reset */
d576 1
a576 1
		ath_hal_intrset(ah, 0);		/* disable intr's until reset */
d591 1
a591 1
			ath_hal_updatetxtriglevel(ah, AH_TRUE);
d742 1
a742 1
	ath_hal_intrset(ah, sc->sc_imask);
d797 1
a797 1
			ath_hal_intrset(ah, 0);
d808 1
a808 1
			ath_hal_setpower(ah, HAL_PM_FULL_SLEEP, 0);
d840 1
a840 1
	ath_hal_intrset(ah, 0);		/* disable interrupts */
d850 1
a850 1
	ath_hal_intrset(ah, sc->sc_imask);
d954 1
a954 1
				tsf = ath_hal_gettsf64(ah);
d1130 1
a1130 1
			ath_hal_keyreset(ah, i);
d1152 2
a1153 2
			
			if (ath_hal_keyset(ah, i, &hk) != AH_TRUE)
d1220 1
a1220 1
	rfilt = (ath_hal_getrxfilter(ah) & HAL_RX_FILTER_PHYERR)
d1239 1
a1239 1
	ath_hal_setrxfilter(ah, rfilt);
d1242 1
a1242 1
	ath_hal_setopmode(ah);
d1247 1
a1247 1
	ath_hal_setmcastfilter(ah, mfilt[0], mfilt[1]);
d1325 1
a1325 1
	if (ic->ic_opmode == IEEE80211_M_IBSS && sc->sc_hasveol) {
d1352 1
a1352 1
	if (!ath_hal_setuptxdesc(ah, ds
d1364 1
a1364 1
		printf("%s: ath_hal_setuptxdesc failed\n", __func__);
d1369 1
a1369 1
	if (!ath_hal_filltxdesc(ah, ds
d1374 1
a1374 1
		printf("%s: ath_hal_filltxdesc failed\n", __func__);
d1399 1
a1399 1
	if (!ath_hal_stoptxdma(ah, sc->sc_bhalq)) {
d1406 2
a1407 2
	ath_hal_puttxbuf(ah, sc->sc_bhalq, bf->bf_daddr);
	ath_hal_txstart(ah, sc->sc_bhalq);
d1512 2
a1513 2
		ath_hal_intrset(ah, 0);
		ath_hal_beacontimers(ah, &bs, 0/*XXX*/, 0, 0);
d1515 1
a1515 1
		ath_hal_intrset(ah, sc->sc_imask);
d1517 1
a1517 1
		ath_hal_intrset(ah, 0);
d1529 1
a1529 1
			if (!sc->sc_hasveol)
d1539 2
a1540 2
		ath_hal_beaconinit(ah, nexttbtt, intval);
		ath_hal_intrset(ah, sc->sc_imask);
d1545 1
a1545 1
		if (ic->ic_opmode == IEEE80211_M_IBSS && sc->sc_hasveol)
d1848 1
a1848 1
	ath_hal_setuprxdesc(ah, ds
d1909 1
a1909 1
		status = ath_hal_rxprocdesc(ah, ds,
d2062 2
a2063 2
	ath_hal_rxmonitor(ah);			/* rx signal state monitoring */
	ath_hal_rxena(ah);			/* in case of RXEOL */
d2381 1
a2381 1
	ath_hal_setuptxdesc(ah, ds
d2394 1
a2394 1
	ath_hal_setupxtxdesc(ah, ds
d2411 1
a2411 1
		ath_hal_filltxdesc(ah, ds
d2429 1
a2429 1
		ath_hal_puttxbuf(ah, sc->sc_txhalq, bf->bf_daddr);
d2440 1
a2440 1
	ath_hal_txstart(ah, sc->sc_txhalq);
d2460 1
a2460 1
	    (caddr_t)(u_intptr_t) ath_hal_gettxbuf(sc->sc_ah,
d2472 1
a2472 1
		status = ath_hal_txprocdesc(ah, ds);
d2549 1
a2549 1
		(void) ath_hal_stoptxdma(ah, sc->sc_txhalq);
d2552 1
a2552 1
		    (caddr_t)(u_intptr_t) ath_hal_gettxbuf(ah, sc->sc_txhalq),
d2554 1
a2554 1
		(void) ath_hal_stoptxdma(ah, sc->sc_bhalq);
d2557 1
a2557 1
		    (caddr_t)(u_intptr_t) ath_hal_gettxbuf(ah, sc->sc_bhalq)));
d2572 1
a2572 1
				ath_hal_txprocdesc(ah, bf->bf_desc) == HAL_OK);
d2605 3
a2607 3
	ath_hal_stoppcurecv(ah);	/* disable PCU */
	ath_hal_setrxfilter(ah, 0);	/* clear recv filter */
	ath_hal_stopdmarecv(ah);	/* disable DMA engine */
d2614 1
a2614 1
		    (caddr_t)(u_intptr_t) ath_hal_getrxbuf(ah), sc->sc_rxlink);
d2617 1
a2617 1
			if (ath_hal_rxprocdesc(ah, ds, bf->bf_daddr,
d2648 2
a2649 2
	ath_hal_putrxbuf(ah, bf->bf_daddr);
	ath_hal_rxena(ah);		/* enable recv descriptors */
d2651 1
a2651 1
	ath_hal_startpcurecv(ah);	/* re-enable PCU/DMA engine */
d2682 1
a2682 1
		ath_hal_intrset(ah, 0);		/* disable interrupts */
d2728 1
a2728 1
		ath_hal_intrset(ah, sc->sc_imask);
d2775 1
a2775 1
	if (ath_hal_getrfgain(ah) == HAL_RFGAIN_NEED_CHANGE) {
d2829 1
a2829 1
	ath_hal_setledstate(ah, ath_state_to_led(nstate));	/* set LED */
d2833 1
a2833 1
		ath_hal_intrset(ah, sc->sc_imask);
d2846 1
a2846 1
	ath_hal_setrxfilter(ah, rfilt);
d2851 1
a2851 1
		ath_hal_setassocid(ah, bssid, ni->ni_associd);
d2853 1
a2853 1
		ath_hal_setassocid(ah, bssid, 0);
d2858 2
a2859 2
			if (ath_hal_keyisvalid(ah, i))
				ath_hal_keysetmac(ah, i, bssid);
d2892 1
a2892 1
		ath_hal_intrset(ah, sc->sc_imask);
d2930 1
a2930 1
		if (ieee80211_ibss_merge(ic, ni, ath_hal_gettsf64(ah)) ==
d2932 1
a2932 1
			ath_hal_setassocid(ah, ic->ic_bss->ni_bssid, 0);
d2973 1
a2973 1
	
d3016 1
a3016 1
	
d3041 1
a3041 1
		sc->sc_rates[mode] = ath_hal_getratetable(ah, HAL_MODE_11A);
d3044 1
a3044 1
		sc->sc_rates[mode] = ath_hal_getratetable(ah, HAL_MODE_11B);
d3047 1
a3047 1
		sc->sc_rates[mode] = ath_hal_getratetable(ah, HAL_MODE_11G);
d3050 1
a3050 1
		sc->sc_rates[mode] = ath_hal_getratetable(ah, HAL_MODE_TURBO);
d3255 1
a3255 1
		ath_hal_gpiocfginput(ah, i);
d3259 1
a3259 1
		sc->sc_gpio_pins[i].pin_state = ath_hal_gpioget(ah, i) ?
d3285 1
a3285 1
	return (ath_hal_gpioget(ah, pin) ? GPIO_PIN_HIGH : GPIO_PIN_LOW);
d3293 1
a3293 1
	ath_hal_gpioset(ah, pin, value ? GPIO_PIN_HIGH : GPIO_PIN_LOW);
d3303 1
a3303 1
		ath_hal_gpiocfginput(ah, pin);
d3305 1
a3305 1
		ath_hal_gpiocfgoutput(ah, pin);
@


1.21
log
@pad keys with zeros to a supported key length. this is bad but seems
to be the default WEP behaviour for string-based keys and allows
commands like "ifconfig ath0 nwkey yuck" to work...
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.20 2005/04/06 00:42:59 kevlo Exp $  */
d1323 1
d1844 2
@


1.20
log
@<sys/types.h> is not needed with <sys/param.h>
ok reyk and damien
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.19 2005/04/05 17:10:43 reyk Exp $  */
d99 1
a99 1
void	ath_initkeytable(struct ath_softc *);
d725 6
a730 2
	if (ic->ic_flags & IEEE80211_F_WEPON)
		ath_initkeytable(sc);
d1119 1
a1119 1
void
a1134 1
			hk.wk_len = k->wk_len;
d1136 19
a1154 2
			/* XXX return value */
			ath_hal_keyset(ah, i, &hk);
d1157 2
@


1.19
log
@fix wep by adjusting the total packet length
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.18 2005/04/03 08:06:14 uwe Exp $  */
a51 1
#include <sys/types.h>
@


1.18
log
@remove redundant suser() checks
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.17 2005/04/02 22:09:31 uwe Exp $  */
d2058 1
a2058 1
	int i, error, iswep, hdrlen, pktlen, s;
d2131 1
a2131 1
		 * The ICV length must be included into hdrlen and pktlen.
d2133 5
a2137 2
		hdrlen = sizeof(hdrbuf) + IEEE80211_WEP_CRCLEN;
		pktlen = m0->m_pkthdr.len + IEEE80211_WEP_CRCLEN;
@


1.17
log
@More ioctl permission checks.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.16 2005/03/19 17:27:46 reyk Exp $  */
a1036 2
		if ((error = suser(curproc, 0)) != 0)
			break;
a1044 2
		if ((error = suser(curproc, 0)) != 0)
			break;
a1070 2
		if ((error = suser(curproc, 0)) != 0)
			break;
@


1.16
log
@further fixes for ar5212.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.15 2005/03/18 21:37:56 reyk Exp $  */
d1037 2
d1047 2
d1075 2
@


1.15
log
@use IFQ_* instead of IF_* for the data queue
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.14 2005/03/11 17:45:28 reyk Exp $  */
d2991 3
a2993 2
		if_printf(ifp, "no valid channels for regdomain %s\n",
		    ieee80211_regdomain2name(ath_regdomain));
@


1.14
log
@fix channel initialisation. thanks to simon slater.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.13 2005/03/10 08:30:56 reyk Exp $  */
d344 1
d801 1
a801 1
		IF_PURGE(&ifp->if_snd);
d905 1
a905 1
			IF_DEQUEUE(&ifp->if_snd, m);
@


1.13
log
@fix beacon handling
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.12 2005/03/10 03:12:30 reyk Exp $  */
d844 2
d1096 8
a1103 2
			    (IFF_RUNNING|IFF_UP))
				ath_init(ifp);		/* XXX lose error */
d2945 2
a2946 1

d2984 2
d2988 10
@


1.12
log
@use bcopy and bzero
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.11 2005/03/03 16:39:54 reyk Exp $  */
d106 1
a106 1
void	ath_beacon_proc(struct ath_softc *, int);
d311 1
d597 2
a598 8
		if (status & HAL_INT_SWBA) {
			/*
			 * Handle beacon transmission directly; deferring
			 * this is too slow to meet timing constraints
			 * under load.
			 */
			ath_beacon_proc(sc, 0);
		}
d1353 1
a1353 1
ath_beacon_proc(struct ath_softc *sc, int pending)
d1355 1
a1370 1
		/* NB: the HAL still stops DMA, so proceed */
@


1.11
log
@improve radiotap support, fix some minor bugs.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.10 2005/03/03 14:36:38 damien Exp $  */
d226 1
a226 1
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
d325 1
a325 1
	memset(&qinfo, 0, sizeof(qinfo));
d382 1
a382 1
	memset(&sc->sc_broadcast_addr, 0xFF, IEEE80211_ADDR_LEN);
a1037 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;
d1127 1
a1127 1
			memset(&hk, 0, sizeof(hk));
d1129 1
a1129 1
			memcpy(hk.wk_key, k->wk_key, k->wk_len);
d1439 1
a1439 1
		memset(&bs, 0, sizeof(bs));
d1719 1
a1719 1
	memcpy(&dst[1], &src[1],
d1985 1
a1985 1
			memcpy(&whbuf, wh, sizeof(whbuf));
d1988 1
a1988 1
			memcpy(wh, &whbuf, sizeof(whbuf));
d2075 1
a2075 1
		memcpy(hdrbuf, mtod(m0, caddr_t), hdrlen);
d2125 1
a2125 1
		memcpy(mtod(m0, caddr_t), hdrbuf, sizeof(hdrbuf));
d3041 1
a3041 1
	memset(sc->sc_hwmap, 0, sizeof(sc->sc_hwmap));
@


1.10
log
@addtion of a generic function for allocating beacons: ieee80211_beacon_alloc().
ok jsg@@, reyk@@, dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.9 2005/03/01 02:19:30 reyk Exp $  */
d389 1
a389 1
	    sizeof(struct ieee80211_frame) + 64);
d391 9
a399 16
	/*
	 * Initialize constant fields.
	 * XXX make header lengths a multiple of 32-bits so subsequent
	 *     headers are properly aligned; this is a kludge to keep
	 *     certain applications happy.
	 *
	 * NB: the channel is setup each time we transition to the
	 *     RUN state to avoid filling it in for each frame.
	 */
	sc->sc_tx_th_len = roundup(sizeof(sc->sc_tx_th), sizeof(u_int32_t));
	sc->sc_tx_th.wt_ihdr.it_len = htole16(sc->sc_tx_th_len);
	sc->sc_tx_th.wt_ihdr.it_present = htole32(ATH_TX_RADIOTAP_PRESENT);

	sc->sc_rx_th_len = roundup(sizeof(sc->sc_rx_th), sizeof(u_int32_t));
	sc->sc_rx_th.wr_ihdr.it_len = htole16(sc->sc_rx_th_len);
	sc->sc_rx_th.wr_ihdr.it_present = htole32(ATH_RX_RADIOTAP_PRESENT);
a649 1
		/* XXX sometimes after association */
d1337 1
a1337 1
		, 0x20				/* txpower XXX */
d1968 6
a1973 5
			sc->sc_rx_th.wr_rate =
				sc->sc_hwmap[ds->ds_rxstat.rs_rate];
			sc->sc_rx_th.wr_antsignal = ds->ds_rxstat.rs_rssi;
			sc->sc_rx_th.wr_antenna = ds->ds_rxstat.rs_antenna;
			/* XXX TSF */
d1975 2
a1976 2
			mb.m_data = (caddr_t)&sc->sc_rx_th;
			mb.m_len = sc->sc_rx_th_len;
d1979 1
d2334 1
a2334 1
		sc->sc_tx_th.wt_flags = 0;
d2336 1
a2336 1
			sc->sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
d2338 5
a2342 4
			sc->sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_WEP;
		sc->sc_tx_th.wt_rate = ni->ni_rates.rs_rates[ni->ni_txrate];
		sc->sc_tx_th.wt_txpower = 60/2;		/* XXX */
		sc->sc_tx_th.wt_antenna = antenna;
d2345 2
a2346 2
		mb.m_data = (caddr_t)&sc->sc_tx_th;
		mb.m_len = sc->sc_tx_th_len;
d2687 4
a2690 4
		sc->sc_tx_th.wt_chan_freq = sc->sc_rx_th.wr_chan_freq =
			htole16(chan->ic_freq);
		sc->sc_tx_th.wt_chan_flags = sc->sc_rx_th.wr_chan_flags =
			htole16(chan->ic_flags);
@


1.9
log
@fix the radiotap bpf listener
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.8 2005/02/17 21:02:24 reyk Exp $  */
a1271 1
	struct ieee80211_frame *wh;
d1275 2
a1276 4
	int error, pktlen;
	u_int8_t *frm, rate;
	u_int16_t capinfo;
	struct ieee80211_rateset *rs;
d1292 1
a1292 6
	rs = &ni->ni_rates;
	pktlen = sizeof (struct ieee80211_frame)
	    + 8 + 2 + 2 + 2+ni->ni_esslen + 2+rs->rs_nrates + 3 + 6;
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		pktlen += 2;
	m = ath_getmbuf(M_DONTWAIT, MT_DATA, pktlen);
d1294 2
a1295 3
		DPRINTF(ATH_DEBUG_BEACON,
		    ("%s: cannot get mbuf/cluster; size %u\n",
		    __func__, pktlen));
a1298 66

	wh = mtod(m, struct ieee80211_frame *);
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_BEACON;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	*(u_int16_t *)wh->i_dur = 0;
	memcpy(wh->i_addr1, sc->sc_broadcast_addr, IEEE80211_ADDR_LEN);
	memcpy(wh->i_addr2, ic->ic_myaddr, IEEE80211_ADDR_LEN);
	memcpy(wh->i_addr3, ni->ni_bssid, IEEE80211_ADDR_LEN);
	*(u_int16_t *)wh->i_seq = 0;

	/*
	 * beacon frame format
	 *	[8] time stamp
	 *	[2] beacon interval
	 *	[2] cabability information
	 *	[tlv] ssid
	 *	[tlv] supported rates
	 *	[tlv] parameter set (IBSS)
	 *	[tlv] extended supported rates
	 */
	frm = (u_int8_t *)&wh[1];
	memset(frm, 0, 8);	/* timestamp is set by hardware */
	frm += 8;
	*(u_int16_t *)frm = htole16(ni->ni_intval);
	frm += 2;
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		capinfo = IEEE80211_CAPINFO_IBSS;
	} else {
		capinfo = IEEE80211_CAPINFO_ESS;
	}
	if (ic->ic_flags & IEEE80211_F_WEPON)
		capinfo |= IEEE80211_CAPINFO_PRIVACY;
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
	*(u_int16_t *)frm = htole16(capinfo);
	frm += 2;
	*frm++ = IEEE80211_ELEMID_SSID;
	*frm++ = ni->ni_esslen;
	memcpy(frm, ni->ni_essid, ni->ni_esslen);
	frm += ni->ni_esslen;
	frm = ieee80211_add_rates(frm, rs);
	*frm++ = IEEE80211_ELEMID_DSPARMS;
	*frm++ = 1;
	*frm++ = ieee80211_chan2ieee(ic, ni->ni_chan);
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		*frm++ = IEEE80211_ELEMID_IBSSPARMS;
		*frm++ = 2;
		*frm++ = 0; *frm++ = 0;		/* TODO: ATIM window */
	} else {
		/* TODO: TIM */
		*frm++ = IEEE80211_ELEMID_TIM;
		*frm++ = 4;	/* length */
		*frm++ = 0;	/* DTIM count */ 
		*frm++ = 1;	/* DTIM period */
		*frm++ = 0;	/* bitmap control */
		*frm++ = 0;	/* Partial Virtual Bitmap (variable length) */
	}
	frm = ieee80211_add_xrates(frm, rs);
	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);
	KASSERT(m->m_pkthdr.len <= pktlen,
		("beacon bigger than expected, len %u calculated %u",
		m->m_pkthdr.len, pktlen));
@


1.8
log
@mostly cosmetic changes: knf, get rid of unneeded sysctls, cleanup the
code.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.7 2005/02/17 18:28:05 reyk Exp $  */
d390 1
a390 1
#endif
d407 1
d2408 1
d2411 1
d2424 1
a2424 1
		M_DUP_PKTHDR(&mb, m);
d2427 1
a2427 1
		mb.m_next = m;
d2431 1
@


1.7
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.6 2005/01/03 19:59:18 jsg Exp $  */
d44 2
a45 1
 * is greatly appreciated.
d51 1
a51 1
#include <sys/systm.h> 
d54 1
a54 1
#include <sys/mbuf.h>   
d60 1
d67 1
a67 1
 
d73 3
a80 4
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

a84 1

a86 12
/* unaligned little endian access */     
#define LE_READ_2(p)							\
	((u_int16_t)							\
	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1] <<  8)))
#define LE_READ_4(p)							\
	((u_int32_t)							\
	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1] <<  8) |	\
	  (((u_int8_t *)(p))[2] << 16) | (((u_int8_t *)(p))[3] << 24)))

#ifdef __FreeBSD__
void	ath_init(void *);
#else
a87 1
#endif
d115 3
a117 3
			struct ieee80211_node *, const struct ieee80211_node *);
u_int8_t	ath_node_getrssi(struct ieee80211com *,
			struct ieee80211_node *);
d121 1
a121 1
			     struct ath_buf *, struct mbuf *);
d132 1
a132 1
			struct ieee80211_node *, int);
d134 1
a134 2
			HAL_BOOL xchanmode);

d140 1
a140 2
			struct ieee80211_node *, int, int, u_int32_t);

d152 12
a163 26
#ifdef __FreeBSD__
SYSCTL_DECL(_hw_ath);
/* XXX validate sysctl values */
SYSCTL_INT(_hw_ath, OID_AUTO, dwell, CTLFLAG_RW, &ath_dwelltime,
	    0, "channel dwell time (ms) for AP/station scanning");
SYSCTL_INT(_hw_ath, OID_AUTO, calibrate, CTLFLAG_RW, &ath_calinterval,
	    0, "chip calibration interval (secs)");
SYSCTL_INT(_hw_ath, OID_AUTO, outdoor, CTLFLAG_RD, &ath_outdoor,
	    0, "enable/disable outdoor operation");
TUNABLE_INT("hw.ath.outdoor", &ath_outdoor);
SYSCTL_INT(_hw_ath, OID_AUTO, countrycode, CTLFLAG_RD, &ath_countrycode,
	    0, "country code");
TUNABLE_INT("hw.ath.countrycode", &ath_countrycode);
SYSCTL_INT(_hw_ath, OID_AUTO, regdomain, CTLFLAG_RD, &ath_regdomain,
	    0, "regulatory domain");
#endif /* __FreeBSD__ */

int ath_dwelltime_nodenum, ath_calibrate_nodenum, ath_outdoor_nodenum,
           ath_countrycode_nodenum, ath_regdomain_nodenum, ath_debug_nodenum;

static	int ath_dwelltime = 200;		/* 5 channels/second */
static	int ath_calinterval = 30;		/* calibrate every 30 secs */
static	int ath_outdoor = AH_TRUE;		/* outdoor operation */
static	int ath_xchanmode = AH_TRUE;		/* enable extended channels */
static	int ath_countrycode = CTRY_DEFAULT;	/* country code */
static	int ath_regdomain = DMN_DEFAULT;	/* regulatory domain */
a168 36
#ifdef AR_DEBUG
enum {
	ATH_DEBUG_XMIT		= 0x00000001,	/* basic xmit operation */
	ATH_DEBUG_XMIT_DESC	= 0x00000002,	/* xmit descriptors */
	ATH_DEBUG_RECV		= 0x00000004,	/* basic recv operation */
	ATH_DEBUG_RECV_DESC	= 0x00000008,	/* recv descriptors */
	ATH_DEBUG_RATE		= 0x00000010,	/* rate control */
	ATH_DEBUG_RESET		= 0x00000020,	/* reset processing */
	ATH_DEBUG_MODE		= 0x00000040,	/* mode init/setup */
	ATH_DEBUG_BEACON 	= 0x00000080,	/* beacon handling */
	ATH_DEBUG_WATCHDOG 	= 0x00000100,	/* watchdog timeout */
	ATH_DEBUG_INTR		= 0x00001000,	/* ISR */
	ATH_DEBUG_TX_PROC	= 0x00002000,	/* tx ISR proc */
	ATH_DEBUG_RX_PROC	= 0x00004000,	/* rx ISR proc */
	ATH_DEBUG_BEACON_PROC	= 0x00008000,	/* beacon ISR proc */
	ATH_DEBUG_CALIBRATE	= 0x00010000,	/* periodic calibration */
	ATH_DEBUG_ANY		= 0xffffffff
};
int	ath_debug = ATH_DEBUG_ANY;
#ifdef __FreeBSD__
SYSCTL_INT(_hw_ath, OID_AUTO, debug, CTLFLAG_RW, &ath_debug,
	    0, "control debugging printfs");
TUNABLE_INT("hw.ath.debug", &ath_debug);
#endif /* __FreeBSD__ */
#define	IFF_DUMPPKTS(_ifp, _m) \
	((ath_debug & _m) || \
	    ((_ifp)->if_flags & (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
static	void ath_printrxbuf(struct ath_buf *bf, int);
static	void ath_printtxbuf(struct ath_buf *bf, int);
#define	DPRINTF(_m,X)	if (ath_debug & (_m)) printf X
#else
#define	IFF_DUMPPKTS(_ifp, _m) \
	(((_ifp)->if_flags & (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
#define	DPRINTF(_m, X)
#endif

a213 135
#if 0
int
sysctl_ath_verify(SYSCTLFN_ARGS)
{
	int error, t;
	struct sysctlnode node;

	node = *rnode;
	t = *(int*)rnode->sysctl_data;
	node.sysctl_data = &t;
	error = sysctl_lookup(SYSCTLFN_CALL(&node));
	if (error || newp == NULL)
		return (error);

	DPRINTF(ATH_DEBUG_ANY, ("%s: t = %d, nodenum = %d, rnodenum = %d\n",
	    __func__, t, node.sysctl_num, rnode->sysctl_num));

	if (node.sysctl_num == ath_dwelltime_nodenum) {
		if (t <= 0)
			return (EINVAL);
	} else if (node.sysctl_num == ath_calibrate_nodenum) {
		if (t <= 0)
			return (EINVAL);
#ifdef AR_DEBUG
	} else if (node.sysctl_num == ath_debug_nodenum) {
		if (t < 0 || t > 2)
			return (EINVAL);
#endif /* AR_DEBUG */
	} else
		return (EINVAL);

	*(int*)rnode->sysctl_data = t;

	return (0);
}

/*
 * Setup sysctl(3) MIB, ath.*.
 *
 * TBD condition CTLFLAG_PERMANENT on being an LKM or not
 */
SYSCTL_SETUP(sysctl_ath, "sysctl ath subtree setup")
{
	int rc, ath_node_num;
	struct sysctlnode *node;

	if ((rc = sysctl_createv(clog, 0, NULL, NULL,
	    CTLFLAG_PERMANENT, CTLTYPE_NODE, "hw", NULL,
	    NULL, 0, NULL, 0, CTL_HW, CTL_EOL)) != 0)
		goto err;

	if ((rc = sysctl_createv(clog, 0, NULL, &node,
	    CTLFLAG_PERMANENT, CTLTYPE_NODE, "ath",
	    SYSCTL_DESCR("ath information and options"),
	    NULL, 0, NULL, 0, CTL_HW, CTL_CREATE, CTL_EOL)) != 0)
		goto err;

	ath_node_num = node->sysctl_num;

	/* channel dwell time (ms) for AP/station scanning */
	if ((rc = sysctl_createv(clog, 0, NULL, &node,
	    CTLFLAG_PERMANENT|CTLFLAG_READWRITE,
	    CTLTYPE_INT, "dwell",
	    SYSCTL_DESCR("Channel dwell time (ms) for AP/station scanning"),
	    sysctl_ath_verify, 0, &ath_dwelltime,
	    0, CTL_HW, ath_node_num, CTL_CREATE,
	    CTL_EOL)) != 0)
		goto err;

	ath_dwelltime_nodenum = node->sysctl_num;

	/* chip calibration interval (secs) */
	if ((rc = sysctl_createv(clog, 0, NULL, &node,
	    CTLFLAG_PERMANENT|CTLFLAG_READWRITE,
	    CTLTYPE_INT, "calibrate",
	    SYSCTL_DESCR("Chip calibration interval (secs)"), sysctl_ath_verify,
	    0, &ath_calinterval, 0, CTL_HW,
	    ath_node_num, CTL_CREATE, CTL_EOL)) != 0)
		goto err;

	ath_calibrate_nodenum = node->sysctl_num;

	/* enable/disable outdoor operation */
	if ((rc = sysctl_createv(clog, 0, NULL, &node,
	    CTLFLAG_PERMANENT|CTLFLAG_READWRITE, CTLTYPE_INT,
	    "outdoor", SYSCTL_DESCR("Enable/disable outdoor operation"),
	    NULL, 0, &ath_outdoor, 0,
	    CTL_HW, ath_node_num, CTL_CREATE,
	    CTL_EOL)) != 0)
		goto err;

	ath_outdoor_nodenum = node->sysctl_num;

	/* country code */
	if ((rc = sysctl_createv(clog, 0, NULL, &node,
	    CTLFLAG_PERMANENT|CTLFLAG_READWRITE, CTLTYPE_INT,
	    "countrycode", SYSCTL_DESCR("Country code"),
	    NULL, 0, &ath_countrycode, 0,
	    CTL_HW, ath_node_num, CTL_CREATE,
	    CTL_EOL)) != 0)
		goto err;

	ath_countrycode_nodenum = node->sysctl_num;

	/* regulatory domain */
	if ((rc = sysctl_createv(clog, 0, NULL, &node,
	    CTLFLAG_PERMANENT|CTLFLAG_READONLY, CTLTYPE_INT,
	    "regdomain", SYSCTL_DESCR("Regulatory domain"),
	    NULL, 0, &ath_regdomain, 0,
	    CTL_HW, ath_node_num, CTL_CREATE,
	    CTL_EOL)) != 0)
		goto err;

	ath_regdomain_nodenum = node->sysctl_num;

#ifdef AR_DEBUG

	/* control debugging printfs */
	if ((rc = sysctl_createv(clog, 0, NULL, &node,
	    CTLFLAG_PERMANENT|CTLFLAG_READWRITE, CTLTYPE_INT,
	    "debug", SYSCTL_DESCR("Enable/disable ath debugging output"),
	    sysctl_ath_verify, 0, &ath_debug, 0,
	    CTL_HW, ath_node_num, CTL_CREATE,
	    CTL_EOL)) != 0)
		goto err;

	ath_debug_nodenum = node->sysctl_num;

#endif /* AR_DEBUG */
	return;
err:
	printf("%s: sysctl_createv failed (rc = %d)\n", __func__, rc);
}
#endif /* 0 */

a225 5
#ifdef __FreeBSD__
	/* set these up early for if_printf use */
	if_initname(ifp, device_get_name(sc->sc_dev),
	    device_get_unit(sc->sc_dev));
#else
a226 1
#endif
d246 1
a246 1
	if (ah->ah_analog2GhzRev != 0)
d249 1
d251 5
a255 4
		if (i++)						\
                        printf("/%s", #_m);				\
                else							\
                        printf(", 802.11%s", #_m);			\
d263 1
a263 1
#undef ah_mode	
d334 2
a335 1
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST | IFF_NOTRAILERS;
a340 5
#endif
#ifdef __FreeBSD__
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
#else
#if 0
a343 1
#endif
d350 12
a361 7
	ic->ic_caps = IEEE80211_C_WEP		/* wep supported */
	        | IEEE80211_C_PMGT
		| IEEE80211_C_IBSS		/* ibss, nee adhoc, mode */
		| IEEE80211_C_HOSTAP		/* hostap mode */
		| IEEE80211_C_MONITOR		/* monitor mode */
		| IEEE80211_C_SHPREAMBLE	/* short preamble supported */
		;
d413 1
a413 1
	if (sc->sc_sdhook == NULL)
d416 1
d418 1
a418 1
	if (sc->sc_powerhook == NULL)
d421 1
a421 1

d423 1
a423 1
	       ether_sprintf(ic->ic_myaddr));
d452 1
a452 1
	
a467 1

d470 1
a470 2

#endif /* __FreeBSD__ */
d567 1
a567 1
			__func__, ifp->if_flags));
d656 1
d702 1
a702 1
		__func__, ifp->if_flags));
d748 2
a749 2
		  | HAL_INT_RXEOL | HAL_INT_RXORN
		  | HAL_INT_FATAL | HAL_INT_GLOBAL;
d765 1
a765 1
	if (ic->ic_opmode != IEEE80211_M_MONITOR)
d767 1
a767 1
	else
d769 1
d784 1
a784 1
		__func__, sc->sc_invalid, ifp->if_flags));
d807 1
a807 1
		if (!sc->sc_invalid)
d809 1
a809 1
		else
d811 1
a811 3
#ifdef __FreeBSD__
		IF_DRAIN(&ifp->if_snd);
#else
a812 1
#endif
d852 1
a852 1
	if (!ath_hal_reset(ah, ic->ic_opmode, &hchan, AH_TRUE, &status))
d855 1
d876 2
a877 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING || sc->sc_invalid)
d890 1
a890 1
				__func__));
d906 2
a907 2
					("%s: ignore data packet, state %u\n",
					__func__, ic->ic_state));
d934 2
a935 2
					("%s: encapsulation failure\n",
					__func__));
d1025 1
a1025 1
		if (ic->ic_opmode == IEEE80211_M_STA)
d1027 1
a1027 1
		else
d1029 1
d1040 1
a1040 1
   	struct ifaddr *ifa = (struct ifaddr *)data;
d1045 9
a1053 9
        case SIOCSIFMTU:
                if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
                        error = EINVAL;
                } else if (ifp->if_mtu != ifr->ifr_mtu) {
                        ifp->if_mtu = ifr->ifr_mtu;
                }
                break;
        case SIOCSIFADDR:
                ifp->if_flags |= IFF_UP;
d1055 3
a1057 3
                if (ifa->ifa_addr->sa_family == AF_INET) {
                        arp_ifinit(&ic->ic_ac, ifa);
                }
d1107 1
a1107 1
				ifr->ifr_data, sizeof (sc->sc_stats));
a1108 19
	case SIOCGATHDIAG: {
#if 0	/* XXX punt */
		struct ath_diag *ad = (struct ath_diag *)data;
		struct ath_hal *ah = sc->sc_ah;
		void *data;
		u_int size;

		if (ath_hal_getdiagstate(ah, ad->ad_id, &data, &size)) {
			if (size < ad->ad_size)
				ad->ad_size = size;
			if (data)
				error = copyout(data, ad->ad_data, ad->ad_size);
		} else
			error = EINVAL;
#else
		error = EINVAL;
#endif
		break;
	}
d1172 1
a1172 1
	while (enm != NULL) {   
d1210 1
a1210 1
	      | HAL_RX_FILTER_UCAST | HAL_RX_FILTER_BCAST | HAL_RX_FILTER_MCAST;
a1222 3
#ifdef __FreeBSD__
	struct ieee80211com *ic = &sc->sc_ic;
#endif
a1233 8
#ifdef __FreeBSD__
	if ((ic->ic_if.if_flags & IFF_ALLMULTI) == 0) {
		mfilt[0] = mfilt[1] = 0;
		ath_mcastfilter_compute(sc, &mfilt);
	} else {
		mfilt[0] = mfilt[1] = ~0;
	}
#endif
d1238 1
a1238 1
		__func__, rfilt, mfilt[0], mfilt[1]));
a1240 14
#ifdef __FreeBSD__
void
ath_mbuf_load_cb(void *arg, bus_dma_segment_t *seg, int nseg, bus_size_t mapsize, int error)
{
	struct ath_buf *bf = arg;

	KASSERT(nseg <= ATH_MAX_SCATTER,
		("ath_mbuf_load_cb: too many DMA segments %u", nseg));
	bf->bf_mapsize = mapsize;
	bf->bf_nseg = nseg;
	bcopy(seg, bf->bf_segs, nseg * sizeof (seg[0]));
}
#endif /* __FreeBSD__ */

d1248 1
a1248 1
	if (pktlen <= MHLEN)
d1250 1
a1250 1
	else
d1252 1
d1255 1
a1255 1
	if (m != NULL && pktlen > MHLEN)
d1257 5
d1296 1
a1296 1
	       + 8 + 2 + 2 + 2+ni->ni_esslen + 2+rs->rs_nrates + 3 + 6;
d1302 2
a1303 2
			("%s: cannot get mbuf/cluster; size %u\n",
			__func__, pktlen));
d1333 1
a1333 1
	if (ic->ic_opmode == IEEE80211_M_IBSS)
d1335 1
a1335 1
	else
d1337 1
d1388 1
a1388 1
	if (ic->ic_opmode == IEEE80211_M_IBSS)
d1390 2
a1391 1
	else
d1393 1
d1405 1
a1405 1
	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
d1407 1
a1407 1
	else
d1409 1
d1457 1
a1457 1
			__func__, ic->ic_flags, bf, bf ? bf->bf_m : NULL));
d1463 1
a1463 1
			__func__, sc->sc_bhalq));
d1472 2
a1473 2
		("%s: TXDP%u = %p (%p)\n", __func__,
		sc->sc_bhalq, (caddr_t)bf->bf_daddr, bf->bf_desc));
d1507 1
d1515 8
a1522 3
	DPRINTF(ATH_DEBUG_BEACON, ("%s: nexttbtt=%u\n", __func__, nexttbtt));
	nexttbtt += ni->ni_intval;
	intval = ni->ni_intval & HAL_BEACON_PERIOD;
d1529 1
a1529 6
		/*
		 * Reset our tsf so the hardware will update the
		 * tsf register to reflect timestamps found in
		 * received beacons.
		 */
		bs.bs_intval = intval | HAL_BEACON_RESET_TSF;
d1540 5
a1544 5
		bmisstime = (ic->ic_bmisstimeout * 1000) / 1024;
		bs.bs_bmissthreshold = howmany(bmisstime,ni->ni_intval);
		if (bs.bs_bmissthreshold > 10)
			bs.bs_bmissthreshold = 10;
		else if (bs.bs_bmissthreshold <= 0)
d1546 1
d1558 16
a1573 13
			roundup((100 * 1000) / 1024, bs.bs_intval);
		if (bs.bs_sleepduration > bs.bs_dtimperiod)
			bs.bs_sleepduration = roundup(bs.bs_sleepduration, bs.bs_dtimperiod);

		DPRINTF(ATH_DEBUG_BEACON, 
			("%s: intval %u nexttbtt %u dtim %u nextdtim %u bmiss %u sleep %u\n"
			, __func__
			, bs.bs_intval
			, bs.bs_nexttbtt
			, bs.bs_dtimperiod
			, bs.bs_nextdtim
			, bs.bs_bmissthreshold
			, bs.bs_sleepduration
d1581 20
a1600 21
		sc->sc_imask |= HAL_INT_SWBA;	/* beacon prepare */
		intval |= HAL_BEACON_ENA;
		switch (ic->ic_opmode) {
		/* No beacons in monitor, ad hoc-demo modes. */
		case IEEE80211_M_MONITOR:
		case IEEE80211_M_AHDEMO:
			intval &= ~HAL_BEACON_ENA;
			/*FALLTHROUGH*/
		/* In IBSS mode, I am uncertain how SWBA interrupts
		 * work, so I just turn them off and use a self-linked
		 * descriptor.
		 */
		case IEEE80211_M_IBSS:
			sc->sc_imask &= ~HAL_INT_SWBA;
			nexttbtt = ni->ni_intval;
			/*FALLTHROUGH*/
		case IEEE80211_M_HOSTAP:
		default:
			if (nexttbtt == ni->ni_intval)
				intval |= HAL_BEACON_RESET_TSF;
			break;
a1601 2
		DPRINTF(ATH_DEBUG_BEACON, ("%s: intval %u nexttbtt %u\n",
			__func__, ni->ni_intval, nexttbtt));
d1604 5
a1608 1
		if (ic->ic_opmode == IEEE80211_M_IBSS)
a1612 98
#ifdef __FreeBSD__
void
ath_load_cb(void *arg, bus_dma_segment_t *segs, int nsegs, int error)
{
	bus_addr_t *paddr = (bus_addr_t*) arg;
	*paddr = segs->ds_addr;
}
#endif

#ifdef __FreeBSD__
int
ath_desc_alloc(struct ath_softc *sc)
{
	int i, bsize, error;
	struct ath_desc *ds;
	struct ath_buf *bf;

	/* allocate descriptors */
	sc->sc_desc_len = sizeof(struct ath_desc) *
				(ATH_TXBUF * ATH_TXDESC + ATH_RXBUF + 1);
	error = bus_dmamap_create(sc->sc_dmat, BUS_DMA_NOWAIT, &sc->sc_ddmamap);
	if (error != 0)
		return error;

	error = bus_dmamem_alloc(sc->sc_dmat, (void**) &sc->sc_desc,
				 BUS_DMA_NOWAIT, &sc->sc_ddmamap);

	if (error != 0)
		goto fail0;

	error = bus_dmamap_load(sc->sc_dmat, sc->sc_ddmamap,
				sc->sc_desc, sc->sc_desc_len,
				ath_load_cb, &sc->sc_desc_paddr,
				BUS_DMA_NOWAIT);
	if (error != 0)
		goto fail1;

	ds = sc->sc_desc;
	DPRINTF(ATH_DEBUG_ANY, ("%s: DMA map: %p (%lu) -> %p (%lu)\n",
	    __func__, ds, (u_long) sc->sc_desc_len, (caddr_t) sc->sc_desc_paddr,
	    /*XXX*/ (u_long) sc->sc_desc_len));

	/* allocate buffers */
	bsize = sizeof(struct ath_buf) * (ATH_TXBUF + ATH_RXBUF + 1);
	bf = malloc(bsize, M_DEVBUF, M_NOWAIT);
	if (bf == NULL) {
		printf("%s: unable to allocate Tx/Rx buffers\n",
		    sc->sc_dev.dv_xname);
		error = -1;
		goto fail2;
	}
	bzero(bf, bsize);
	sc->sc_bufptr = bf;

	TAILQ_INIT(&sc->sc_rxbuf);
	for (i = 0; i < ATH_RXBUF; i++, bf++, ds++) {
		bf->bf_desc = ds;
		bf->bf_daddr = sc->sc_desc_paddr +
		    ((caddr_t)ds - (caddr_t)sc->sc_desc);
		error = bus_dmamap_create(sc->sc_dmat, BUS_DMA_NOWAIT,
					  &bf->bf_dmamap);
		if (error != 0)
			break;
		TAILQ_INSERT_TAIL(&sc->sc_rxbuf, bf, bf_list);
	}

	TAILQ_INIT(&sc->sc_txbuf);
	for (i = 0; i < ATH_TXBUF; i++, bf++, ds += ATH_TXDESC) {
		bf->bf_desc = ds;
		bf->bf_daddr = sc->sc_desc_paddr +
		    ((caddr_t)ds - (caddr_t)sc->sc_desc);
		error = bus_dmamap_create(sc->sc_dmat, BUS_DMA_NOWAIT,
					  &bf->bf_dmamap);
		if (error != 0)
			break;
		TAILQ_INSERT_TAIL(&sc->sc_txbuf, bf, bf_list);
	}
	TAILQ_INIT(&sc->sc_txq);

	/* beacon buffer */
	bf->bf_desc = ds;
	bf->bf_daddr = sc->sc_desc_paddr + ((caddr_t)ds - (caddr_t)sc->sc_desc);
	error = bus_dmamap_create(sc->sc_dmat, BUS_DMA_NOWAIT, &bf->bf_dmamap);
	if (error != 0)
		return error;
	sc->sc_bcbuf = bf;
	return 0;

fail2:
	bus_dmamap_unload(sc->sc_dmat, sc->sc_ddmamap);
fail1:
	bus_dmamem_free(sc->sc_dmat, sc->sc_desc, sc->sc_ddmamap);
fail0:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ddmamap);
	sc->sc_ddmamap = NULL;
	return error;
}
#else
a1734 1
#endif
a1740 5
#ifdef __FreeBSD__
	bus_dmamap_unload(sc->sc_dmat, sc->sc_ddmamap);
	bus_dmamem_free(sc->sc_dmat, sc->sc_desc, sc->sc_ddmamap);
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ddmamap);
#else
a1743 1
#endif
d1806 1
a1806 1
        struct ath_softc *sc = ic->ic_if.if_softc;
d1834 1
a1834 1
		if (i == 0)
d1836 1
a1836 1
		else
d1838 1
d1868 1
a1868 1
				("%s: no mbuf/cluster\n", __func__));
d1876 1
a1876 1
		    BUS_DMA_NOWAIT);	
d1879 2
a1880 2
				("%s: ath_bus_dmamap_load_mbuf failed;"
				" error %d\n", __func__, error));
d1974 1
a1974 1
			ath_printrxbuf(bf, status == HAL_OK); 
d1988 4
a1991 1
			/* enable this if you want to see error frames in Monitor mode */
d2033 1
a2033 1
				__func__, len));
d2038 1
a2038 1
		bus_dmamap_sync(sc->sc_dmat, bf->bf_dmamap, 0, 
d2117 1
a2117 1
  rx_next:
d2135 2
a2136 2
ath_tx_start(struct ath_softc *sc, struct ieee80211_node *ni, struct ath_buf *bf,
    struct mbuf *m0)
d2291 1
a2291 1
		if (subtype == IEEE80211_FC0_SUBTYPE_BEACON)
d2293 1
a2293 1
		else if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
d2295 1
a2295 1
		else if (subtype == IEEE80211_FC0_SUBTYPE_ATIM)
d2297 1
d2401 1
a2401 1
	if (an->an_tx_antenna)
d2403 1
a2403 1
	else
d2405 1
d2410 1
a2410 1
	        struct mbuf mb;
d2458 1
a2458 1
		if (i == bf->bf_nseg - 1)
d2460 1
a2460 1
		else
d2462 1
d2469 3
a2471 3
			("%s: %d: %08x %08x %08x %08x %08x %08x\n",
			__func__, i, ds->ds_link, ds->ds_data,
			ds->ds_ctl0, ds->ds_ctl1, ds->ds_hw[0], ds->ds_hw[1]));
d2510 4
a2513 4
	DPRINTF(ATH_DEBUG_TX_PROC, ("%s: pending %u tx queue %p, link %p\n",
		__func__, npending,
		(caddr_t)(u_intptr_t) ath_hal_gettxbuf(sc->sc_ah, sc->sc_txhalq),
		sc->sc_txlink));
d2622 1
a2622 1
		if (ath_debug & ATH_DEBUG_RESET)
d2625 1
d2666 1
a2666 1
			(caddr_t)(u_intptr_t) ath_hal_getrxbuf(ah), sc->sc_rxlink);
d2693 2
a2694 2
				("%s: ath_rxbuf_init failed %d\n",
				__func__, error));
d2721 1
a2721 1
		ic->ic_ibss_chan->ic_freq,
d2744 2
a2745 1
		if (!ath_hal_reset(ah, ic->ic_opmode, &hchan, AH_TRUE, &status)) {
d2825 1
a2825 1
		("%s: channel %u/%x\n", __func__, c->ic_freq, c->ic_flags));
d2837 2
a2838 2
			("%s: calibration of channel %u failed\n",
			__func__, c->ic_freq));
d2876 2
a2877 2
		ieee80211_state_name[ic->ic_state],
		ieee80211_state_name[nstate]));
d2879 2
a2885 2
		timeout_del(&sc->sc_scan_to);
		timeout_del(&sc->sc_cal_to);
a2893 1
	        timeout_add(&sc->sc_scan_to, (hz * ath_dwelltime) / 1000);
a2895 1
		timeout_del(&sc->sc_scan_to);
d2900 1
a2900 1
		 __func__, rfilt, ether_sprintf((u_char*)bssid)));
d2902 1
a2902 1
	if (nstate == IEEE80211_S_RUN && ic->ic_opmode == IEEE80211_M_STA)
d2904 1
a2904 1
	else
d2906 2
d2909 1
a2909 1
		for (i = 0; i < IEEE80211_WEP_NKID; i++)
d2912 1
d2915 12
a2926 9
	if (nstate == IEEE80211_S_RUN) {
		DPRINTF(ATH_DEBUG_ANY, ("%s(RUN): ic_flags=0x%08x iv=%d bssid=%s "
			"capinfo=0x%04x chan=%d\n"
			 , __func__
			 , ic->ic_flags
			 , ni->ni_intval
			 , ether_sprintf(ni->ni_bssid)
			 , ni->ni_capinfo
			 , ieee80211_chan2ieee(ic, ni->ni_chan)));
a2941 3

		/* start periodic recalibration timer */
	        timeout_add(&sc->sc_cal_to, hz * ath_calinterval);
a2944 1
		timeout_del(&sc->sc_cal_to); /* no calibration */
d2946 1
d2954 9
a2962 1
	return (*sc->sc_newstate)(ic, nstate, arg);
a2963 3
	timeout_del(&sc->sc_scan_to);
	timeout_del(&sc->sc_cal_to);
	/* NB: do not invoke the parent */
d3092 1
a3092 1
			("%s: invalid mode %u\n", __func__, mode));
d3100 2
a3101 2
			("%s: rate table too small (%u > %u)\n",
			__func__, rt->rateCount, IEEE80211_RATE_MAXSIZE));
d3103 1
a3103 1
	} else
d3105 1
a3240 60
#ifdef __FreeBSD__
int
sysctl_hw_ath_dump(SYSCTL_HANDLER_ARGS)
{
	char dmode[64];
	int error;

	strlcpy(dmode, "", sizeof(dmode) - 1);
	dmode[sizeof(dmode) - 1] = '\0';
	error = sysctl_handle_string(oidp, &dmode[0], sizeof(dmode), req);

	if (error == 0 && req->newptr != NULL) {
		struct ifnet *ifp;
		struct ath_softc *sc;

		ifp = ifunit("ath0");		/* XXX */
		if (!ifp)
			return EINVAL;
		sc = ifp->if_softc;
		if (strcmp(dmode, "hal") == 0)
			ath_hal_dumpstate(sc->sc_ah);
		else
			return EINVAL;
	}
	return error;
}
SYSCTL_PROC(_hw_ath, OID_AUTO, dump, CTLTYPE_STRING | CTLFLAG_RW,
	0, 0, sysctl_hw_ath_dump, "A", "Dump driver state");
#endif /* __FreeBSD__ */

#if 0 /* #ifdef __NetBSD__ */
int
sysctl_hw_ath_dump(SYSCTL_HANDLER_ARGS)
{
	char dmode[64];
	int error;

	strlcpy(dmode, "", sizeof(dmode) - 1);
	dmode[sizeof(dmode) - 1] = '\0';
	error = sysctl_handle_string(oidp, &dmode[0], sizeof(dmode), req);

	if (error == 0 && req->newptr != NULL) {
		struct ifnet *ifp;
		struct ath_softc *sc;

		ifp = ifunit("ath0");		/* XXX */
		if (!ifp)
			return EINVAL;
		sc = ifp->if_softc;
		if (strcmp(dmode, "hal") == 0)
			ath_hal_dumpstate(sc->sc_ah);
		else
			return EINVAL;
	}
	return error;
}
SYSCTL_PROC(_hw_ath, OID_AUTO, dump, CTLTYPE_STRING | CTLFLAG_RW,
	0, 0, sysctl_hw_ath_dump, "A", "Dump driver state");
#endif /* __NetBSD__ */

d3264 2
a3265 1
		printf("T%d (%p %p) %08x %08x %08x %08x %08x %08x %08x %08x %c\n",
d3285 1
a3285 1
	
d3340 1
a3340 1
	if (flags & GPIO_PIN_INPUT)
d3342 1
a3342 1
	else if (flags & GPIO_PIN_OUTPUT)
d3344 1
@


1.6
log
@Make ath at cardbus not depend on ath at pci. ok reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.5 2004/12/31 01:00:23 reyk Exp $  */
d1180 2
a1181 2
			if (ni != NULL && ni != ic->ic_bss)
			          ieee80211_free_node(ic, ni);
d2447 1
a2447 4
		if (ni == ic->ic_bss)
			ieee80211_unref_node(&ni);
		else
			ieee80211_free_node(ic, ni);
d2895 1
a2895 2
			if(ni != NULL && ni != ic->ic_bss)
  			        ieee80211_free_node(ic, ni);
d2961 1
a2961 1
		if (ni != NULL && ni != ic->ic_bss) {
d2965 1
a2965 1
			ieee80211_free_node(ic, ni);
@


1.5
log
@sync with the latest work and add some stuff needed by the upcoming ar5211/ar5212
support. some further cleanups and changes will follow.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.4 2004/11/23 09:39:28 reyk Exp $  */
d193 4
@


1.4
log
@support the gpio found on ath(4) devices.
ok grange@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.3 2004/11/11 20:11:28 reyk Exp $  */
d418 1
a418 1
	int error = 0;
d446 2
a447 3
	if (ah->ah_analog5GhzRev != 0)
		printf(" 5GHz radio %d.%d",
			ah->ah_analog5GhzRev >> 4, ah->ah_analog5GhzRev & 0xf);
d449 16
a464 2
		printf(" 2GHz radio %d.%d",
			ah->ah_analog2GhzRev >> 4, ah->ah_analog2GhzRev & 0xf);
a1243 1
#if 0
a1250 1
#endif
d2835 1
a2835 1
	int sr, lr, s, s2;
d2904 1
a2904 1
		s2 = splnet();
d2906 1
a2906 1
		splx(s2);
d2925 1
a2925 1
	int s, s2;
d2960 1
a2960 1
		s2 = splnet();
d2968 1
a2968 1
		splx(s2);
@


1.3
log
@some fixes for beeing compatible with gcc3 as noticed by some people.
thanks to Joerg Sonnenberger and Nathan Binkert.
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.2 2004/11/02 14:05:49 reyk Exp $  */
d61 1
d83 2
d160 7
d611 5
d627 1
a627 1
ath_detach(struct ath_softc *sc)
d632 2
d636 1
d659 1
d3642 72
@


1.2
log
@spacing, beautify dmesg output
@
text
@d1 1
a1 1
/*      $OpenBSD: ath.c,v 1.1 2004/11/02 02:45:37 reyk Exp $  */
d182 1
a182 1
static	int ath_regdomain = 0;			/* regulatory domain */
@


1.1
log
@imported Sam Leffler's ath driver for atheros multimode wireless nics
from NetBSD and FreeBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD$  */
d437 1
a437 1
		printf(" 5ghz radio %d.%d",
d440 1
a440 1
		printf(" 2ghz radio %d.%d",
@

