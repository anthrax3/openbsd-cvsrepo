head	1.43;
access;
symbols
	OPENBSD_6_1:1.43.0.10
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.8
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.42.0.10
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.14
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.12
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.8
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.6
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.40.0.4
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.25.0.6
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.23.0.8
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.15
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2;
locks; strict;
comment	@ * @;


1.43
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.42;
commitid	p4LJxGKbi0BU2cG6;

1.42
date	2012.02.04.21.44.54;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.11.16.22.33;	author dhill;	state Exp;
branches;
next	1.40;

1.40
date	2010.10.03.21.14.40;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.04.04.57.14;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.12.29.03.04.19;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.05.00.21.36;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.18.20.28.26;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.03.16.53.16;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.05.03.13.29;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.19.00.44.32;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.30.00.32.48;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.29.23.28.49;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.29.17.52.01;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.29.02.34.17;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.28.00.16.12;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.14.02.31.46;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.09.23.43.11;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.09.02.11.47;	author jsyn;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.11.21.59.19;	author krw;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.14.02.56.34;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.26.02.39.05;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.13.04.27.09;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.13.03.24.20;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.10.23.30.39;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.09.18.01.38;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.09.15.20.28;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.20.00.47.33;	author krw;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.02.08.17.35.05;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.23.04.19.41;	author krw;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.23.52;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2003.05.13.19.35.01;	author ho;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: iha.c,v 1.42 2012/02/04 21:44:54 krw Exp $ */
/*-------------------------------------------------------------------------
 *
 * Device driver for the INI-9XXXU/UW or INIC-940/950  PCI SCSI Controller.
 *
 * Written for 386bsd and FreeBSD by
 *	Winston Hung		<winstonh@@initio.com>
 *
 * Copyright (c) 1997-1999 Initio Corp
 * Copyright (c) 2000-2002 Ken Westerback
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer,
 *    without modification, immediately at the beginning of the file.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 *-------------------------------------------------------------------------
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <dev/ic/iha.h>

/* #define IHA_DEBUG_STATE */

struct cfdriver iha_cd = {
	NULL, "iha", DV_DULL
};

struct scsi_adapter iha_switch = {
	iha_scsi_cmd,	/* scsi_cmd() */
	iha_minphys,	/* scsi_minphys() */
	NULL,		/* probe_dev(void) */
	NULL		/* free_dev() */
};

/*
 * SCSI Rate Table, indexed by FLAG_SCSI_RATE field of
 * TCS_Flags.
 */
static const u_int8_t iha_rate_tbl[] = {
	/* fast 20		  */
	/* nanosecond divide by 4 */
	12,	/* 50ns,  20M	  */
	18,	/* 75ns,  13.3M	  */
	25,	/* 100ns, 10M	  */
	31,	/* 125ns, 8M	  */
	37,	/* 150ns, 6.6M	  */
	43,	/* 175ns, 5.7M	  */
	50,	/* 200ns, 5M	  */
	62	/* 250ns, 4M	  */
};

int iha_setup_sg_list(struct iha_softc *, struct iha_scb *);
u_int8_t iha_data_over_run(struct iha_scb *);
int iha_push_sense_request(struct iha_softc *, struct iha_scb *);
void iha_timeout(void *);
int  iha_alloc_scbs(struct iha_softc *);
void iha_read_eeprom(bus_space_tag_t, bus_space_handle_t,
			     struct iha_nvram *);
void iha_se2_instr(bus_space_tag_t, bus_space_handle_t, u_int8_t);
u_int16_t iha_se2_rd(bus_space_tag_t, bus_space_handle_t, u_int8_t);
void iha_reset_scsi_bus(struct iha_softc *);
void iha_reset_chip(struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t);
void iha_reset_dma(bus_space_tag_t, bus_space_handle_t);
void iha_reset_tcs(struct tcs *, u_int8_t);
void iha_print_info(struct iha_softc *, int);
void iha_done_scb(struct iha_softc *, struct iha_scb *);
void iha_exec_scb(struct iha_softc *, struct iha_scb *);
void iha_main(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
void iha_scsi(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
int  iha_wait(struct iha_softc *, bus_space_tag_t, bus_space_handle_t,
		      u_int8_t);
void iha_mark_busy_scb(struct iha_scb *);
void *iha_scb_alloc(void *);
void iha_scb_free(void *, void *);
void iha_append_done_scb(struct iha_softc *, struct iha_scb *,
				 u_int8_t);
struct iha_scb *iha_pop_done_scb(struct iha_softc *);
void iha_append_pend_scb(struct iha_softc *, struct iha_scb *);
void iha_push_pend_scb(struct iha_softc *, struct iha_scb *);
struct iha_scb *iha_find_pend_scb(struct iha_softc *);
void iha_sync_done(struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t);
void iha_wide_done(struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t);
void iha_bad_seq(struct iha_softc *);
int  iha_next_state(struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t);
int  iha_state_1(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_2(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_3(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_4(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_5(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_6(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_8(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
void iha_set_ssig(bus_space_tag_t,
			  bus_space_handle_t, u_int8_t, u_int8_t);
int  iha_xpad_in(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_xpad_out(struct iha_softc *,
			  bus_space_tag_t, bus_space_handle_t);
int  iha_xfer_data(struct iha_scb *,
			   bus_space_tag_t, bus_space_handle_t,
			   int direction);
int  iha_status_msg(struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t);
int  iha_msgin(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
int  iha_msgin_sdtr(struct iha_softc *);
int  iha_msgin_extended(struct iha_softc *,
				bus_space_tag_t, bus_space_handle_t);
int  iha_msgin_ignore_wid_resid(struct iha_softc *,
					bus_space_tag_t, bus_space_handle_t);
int  iha_msgout(struct iha_softc *,
			bus_space_tag_t, bus_space_handle_t, u_int8_t);
int  iha_msgout_extended(struct iha_softc *,
				 bus_space_tag_t, bus_space_handle_t);
void iha_msgout_abort(struct iha_softc *,
			      bus_space_tag_t, bus_space_handle_t,  u_int8_t);
int  iha_msgout_reject(struct iha_softc *,
			       bus_space_tag_t, bus_space_handle_t);
int  iha_msgout_sdtr(struct iha_softc *,
			     bus_space_tag_t, bus_space_handle_t);
int  iha_msgout_wdtr(struct iha_softc *,
			     bus_space_tag_t, bus_space_handle_t);
void iha_select(struct iha_softc *,
			bus_space_tag_t, bus_space_handle_t,
			struct iha_scb *, u_int8_t);
void iha_busfree(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_resel(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
void iha_abort_xs(struct iha_softc *, struct scsi_xfer *, u_int8_t);

/*
 * iha_intr - the interrupt service routine for the iha driver
 */
int
iha_intr(void *arg)
{
	bus_space_handle_t ioh;
	struct iha_softc *sc;
	bus_space_tag_t iot;
	int s;

	sc  = (struct iha_softc *)arg;
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	if ((bus_space_read_1(iot, ioh, TUL_STAT0) & INTPD) == 0)
		return (0);

	s = splbio(); /* XXX - Or are interrupts off when ISR's are called? */

	if (sc->HCS_Semaph != SEMAPH_IN_MAIN) {
		/* XXX - need these inside a splbio()/splx()? */
		bus_space_write_1(iot, ioh, TUL_IMSK, MASK_ALL);
		sc->HCS_Semaph = SEMAPH_IN_MAIN;

		iha_main(sc, iot, ioh);

		sc->HCS_Semaph = ~SEMAPH_IN_MAIN;
		bus_space_write_1(iot, ioh, TUL_IMSK, (MASK_ALL & ~MSCMP));
	}

	splx(s);

	return (1);
}

/*
 * iha_setup_sg_list -	initialize scatter gather list of pScb from
 *			pScb->SCB_DataDma.
 */
int
iha_setup_sg_list(struct iha_softc *sc, struct iha_scb *pScb)
{
	bus_dma_segment_t *segs = pScb->SCB_DataDma->dm_segs;
	int i, error, nseg = pScb->SCB_DataDma->dm_nsegs;

	if (nseg > 1) {
		error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_SGDma,
				pScb->SCB_SGList, sizeof(pScb->SCB_SGList), NULL,
				(pScb->SCB_Flags & SCSI_NOSLEEP) ?
					BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			sc_print_addr(pScb->SCB_Xs->sc_link);
			printf("error %d loading SG list dma map\n", error);
			return (error);
		}

		/*
		 * Only set FLAG_SG when SCB_SGDma is loaded so iha_scsi_done
		 * will not unload an unloaded map.
		 */
		pScb->SCB_Flags	|= FLAG_SG;
		bzero(pScb->SCB_SGList, sizeof(pScb->SCB_SGList));

		pScb->SCB_SGIdx	  = 0;
		pScb->SCB_SGCount = nseg;

		for (i=0; i < nseg; i++) {
			pScb->SCB_SGList[i].SG_Len  = segs[i].ds_len;
			pScb->SCB_SGList[i].SG_Addr = segs[i].ds_addr;
		}

		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma, 
			0, sizeof(pScb->SCB_SGList), BUS_DMASYNC_PREWRITE);
	}

	return (0);
}

/*
 * iha_scsi_cmd - start execution of a SCSI command. This is called
 *		  from the generic SCSI driver via the field
 *		  sc_adapter.scsi_cmd of iha_softc.
 */
void
iha_scsi_cmd(struct scsi_xfer *xs)
{
	struct iha_scb *pScb;
	struct scsi_link *sc_link = xs->sc_link;
	struct iha_softc *sc = sc_link->adapter_softc;
	int error;

	if ((xs->cmdlen > 12) || (sc_link->target >= IHA_MAX_TARGETS)) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	pScb = xs->io;

	pScb->SCB_Target = sc_link->target;
	pScb->SCB_Lun	 = sc_link->lun;
	pScb->SCB_Tcs	 = &sc->HCS_Tcs[pScb->SCB_Target];
	pScb->SCB_Flags	 = xs->flags;
	pScb->SCB_Ident  = MSG_IDENTIFYFLAG |
		(pScb->SCB_Lun & MSG_IDENTIFY_LUNMASK);

	if ((xs->cmd->opcode != REQUEST_SENSE)
	    && ((pScb->SCB_Flags & SCSI_POLL) == 0))
		pScb->SCB_Ident |= MSG_IDENTIFY_DISCFLAG;

	pScb->SCB_Xs	 = xs;
	pScb->SCB_CDBLen = xs->cmdlen;
	bcopy(xs->cmd, &pScb->SCB_CDB, xs->cmdlen);

	pScb->SCB_BufCharsLeft = pScb->SCB_BufChars = xs->datalen;

	if ((pScb->SCB_Flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) != 0) {
		error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_DataDma,
		    xs->data, pScb->SCB_BufChars, NULL,
		    (pScb->SCB_Flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);

		if (error) {
			sc_print_addr(xs->sc_link);
			if (error == EFBIG)
				printf("buffer needs >%d dma segments\n",
				    IHA_MAX_SG_ENTRIES);
			else
				printf("error %d loading buffer dma map\n",
				    error);

			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma, 
			0, pScb->SCB_BufChars,
			(pScb->SCB_Flags & SCSI_DATA_IN) ?
				BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);

		error = iha_setup_sg_list(sc, pScb);
		if (error) {
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}

	}

	/*
	 * Always initialize the stimeout structure as it may 
	 * contain garbage that confuses timeout_del() later on.
	 * But, timeout_add() ONLY if we are not polling.
	 */
	timeout_set(&xs->stimeout, iha_timeout, pScb);

	iha_exec_scb(sc, pScb);
}

/*
 * iha_init_tulip - initialize the inic-940/950 card and the rest of the
 *		    iha_softc structure supplied
 */
int
iha_init_tulip(struct iha_softc *sc)
{
	struct iha_scb *pScb;
	struct iha_nvram_scsi *pScsi;
	bus_space_handle_t ioh;
	struct iha_nvram iha_nvram;
	bus_space_tag_t iot;
	int i, error;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	iha_read_eeprom(iot, ioh, &iha_nvram);

	pScsi = &iha_nvram.NVM_Scsi[0];

	TAILQ_INIT(&sc->HCS_FreeScb);
	TAILQ_INIT(&sc->HCS_PendScb);
	TAILQ_INIT(&sc->HCS_DoneScb);

	mtx_init(&sc->sc_scb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, iha_scb_alloc, iha_scb_free);

	/*
	 * fill in the prototype scsi_link.
	 */
	sc->sc_link.adapter_softc    = sc;
	sc->sc_link.adapter	     = &iha_switch;
	sc->sc_link.openings	     = 4; /* # xs's allowed per device */
	sc->sc_link.adapter_target   = pScsi->NVM_SCSI_Id;
	sc->sc_link.adapter_buswidth = pScsi->NVM_SCSI_Targets;
	sc->sc_link.pool             = &sc->sc_iopool;

	/*
	 * fill in the rest of the iha_softc fields
	 */
	sc->HCS_Semaph	  = ~SEMAPH_IN_MAIN;
	sc->HCS_JSStatus0 = 0;
	sc->HCS_ActScb	  = NULL;

	error = iha_alloc_scbs(sc);
	if (error != 0)
		return (error);

	for (i = 0, pScb = sc->HCS_Scb; i < IHA_MAX_SCB; i++, pScb++) {
		pScb->SCB_TagId = i;

		error = bus_dmamap_create(sc->sc_dmat,
		    (IHA_MAX_SG_ENTRIES-1) * PAGE_SIZE, IHA_MAX_SG_ENTRIES,
		    (IHA_MAX_SG_ENTRIES-1) * PAGE_SIZE, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &pScb->SCB_DataDma);

		if (error != 0) {
			printf("%s: couldn't create SCB data DMA map, error = %d\n",
			    sc->sc_dev.dv_xname, error);
			return (error);
		}

		error = bus_dmamap_create(sc->sc_dmat,
				sizeof(pScb->SCB_SGList), 1,
				sizeof(pScb->SCB_SGList), 0,
				BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
				&pScb->SCB_SGDma);
		if (error != 0) {
			printf("%s: couldn't create SCB SG DMA map, error = %d\n",
			    sc->sc_dev.dv_xname, error);
			return (error);
		}

		TAILQ_INSERT_TAIL(&sc->HCS_FreeScb, pScb, SCB_ScbList);
	}

	/* Mask all the interrupts */
	bus_space_write_1(iot, ioh, TUL_IMSK, MASK_ALL);

	/* Stop any I/O and reset the scsi module */
	iha_reset_dma(iot, ioh);
	bus_space_write_1(iot, ioh, TUL_SCTRL0, RSMOD);

	/* Program HBA's SCSI ID */
	bus_space_write_1(iot, ioh, TUL_SID, sc->sc_link.adapter_target << 4);

	/*
	 * Configure the channel as requested by the NVRAM settings read 
	 * into iha_nvram by iha_read_eeprom() above.
	 */

	if ((pScsi->NVM_SCSI_Cfg & CFG_EN_PAR) != 0)
		sc->HCS_SConf1 = (SCONFIG0DEFAULT | SPCHK);
	else
		sc->HCS_SConf1 = (SCONFIG0DEFAULT);
	bus_space_write_1(iot, ioh, TUL_SCONFIG0, sc->HCS_SConf1);

	/* selection time out in units of 1.6385 millisecond = 250 ms */
	bus_space_write_1(iot, ioh, TUL_STIMO, 153);

	/* Enable desired SCSI termination configuration read from eeprom */
	bus_space_write_1(iot, ioh, TUL_DCTRL0,
	    (pScsi->NVM_SCSI_Cfg & (CFG_ACT_TERM1 | CFG_ACT_TERM2)));

	bus_space_write_1(iot, ioh, TUL_GCTRL1,
	    ((pScsi->NVM_SCSI_Cfg & CFG_AUTO_TERM) >> 4) 
	        | (bus_space_read_1(iot, ioh, TUL_GCTRL1) & (~ATDEN)));

	for (i = 0; i < IHA_MAX_TARGETS; i++) {
		sc->HCS_Tcs[i].TCS_Flags = pScsi->NVM_SCSI_TargetFlags[i];
		iha_reset_tcs(&sc->HCS_Tcs[i], sc->HCS_SConf1);
	}

	iha_reset_chip(sc, iot, ioh);
	bus_space_write_1(iot, ioh, TUL_SIEN, ALL_INTERRUPTS);

	return (0);
}

/*
 * iha_minphys - reduce bp->b_bcount to something less than
 *		 or equal to the largest I/O possible through
 *		 the adapter. Called from higher layers
 *		 via sc->sc_adapter.scsi_minphys.
 */
void
iha_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > ((IHA_MAX_SG_ENTRIES - 1) * PAGE_SIZE))
		bp->b_bcount = ((IHA_MAX_SG_ENTRIES - 1) * PAGE_SIZE);

	minphys(bp);
}

/*
 * iha_reset_dma - abort any active DMA xfer, reset tulip FIFO.
 */
void
iha_reset_dma(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	if ((bus_space_read_1(iot, ioh, TUL_ISTUS1) & XPEND) != 0) {
		/* if DMA xfer is pending, abort DMA xfer */
		bus_space_write_1(iot, ioh, TUL_DCMD, ABTXFR);
		/* wait Abort DMA xfer done */
		while ((bus_space_read_1(iot, ioh, TUL_ISTUS0) & DABT) == 0)
			;
	}

	bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);
}

/*
 * iha_scb_alloc - return the first free SCB, or NULL if there are none.
 */
void *
iha_scb_alloc(void *xsc)
{
	struct iha_softc *sc = xsc;
	struct iha_scb *pScb;

	mtx_enter(&sc->sc_scb_mtx);
	pScb = TAILQ_FIRST(&sc->HCS_FreeScb);
	if (pScb != NULL) {
		pScb->SCB_Status = STATUS_RENT;
		TAILQ_REMOVE(&sc->HCS_FreeScb, pScb, SCB_ScbList);
	}
	mtx_leave(&sc->sc_scb_mtx);

	return (pScb);
}

/*
 * iha_scb_free - append the supplied SCB to the tail of the
 *                HCS_FreeScb queue after clearing and resetting
 *		  everything possible.
 */
void
iha_scb_free(void *xsc, void *xscb)
{
	struct iha_softc *sc = xsc;
	struct iha_scb *pScb = xscb;
	int s;

	s = splbio();
	if (pScb == sc->HCS_ActScb)
		sc->HCS_ActScb = NULL;
	splx(s);

	pScb->SCB_Status = STATUS_QUEUED;
	pScb->SCB_HaStat = HOST_OK;
	pScb->SCB_TaStat = SCSI_OK;

	pScb->SCB_NxtStat  = 0;
	pScb->SCB_Flags	   = 0;
	pScb->SCB_Target   = 0;
	pScb->SCB_Lun	   = 0;
	pScb->SCB_CDBLen   = 0;
	pScb->SCB_Ident	   = 0;
	pScb->SCB_TagMsg   = 0;

	pScb->SCB_BufChars     = 0;
	pScb->SCB_BufCharsLeft = 0;

	pScb->SCB_Xs  = NULL;
	pScb->SCB_Tcs = NULL;

	bzero(pScb->SCB_CDB, sizeof(pScb->SCB_CDB));

	/*
	 * SCB_TagId is set at initialization and never changes
	 */

	mtx_enter(&sc->sc_scb_mtx);
	TAILQ_INSERT_TAIL(&sc->HCS_FreeScb, pScb, SCB_ScbList);
	mtx_leave(&sc->sc_scb_mtx);
}

void
iha_append_pend_scb(struct iha_softc *sc, struct iha_scb *pScb)
{
	/* ASSUMPTION: only called within a splbio()/splx() pair */

	if (pScb == sc->HCS_ActScb)
		sc->HCS_ActScb = NULL;

	pScb->SCB_Status = STATUS_QUEUED;

	TAILQ_INSERT_TAIL(&sc->HCS_PendScb, pScb, SCB_ScbList);
}

void
iha_push_pend_scb(struct iha_softc *sc, struct iha_scb *pScb)
{
	int s;

	s = splbio();

	if (pScb == sc->HCS_ActScb)
		sc->HCS_ActScb = NULL;

	pScb->SCB_Status = STATUS_QUEUED;

	TAILQ_INSERT_HEAD(&sc->HCS_PendScb, pScb, SCB_ScbList);

	splx(s);
}

/*
 * iha_find_pend_scb - scan the pending queue for a SCB that can be
 *		       processed immediately. Return NULL if none found
 *		       and a pointer to the SCB if one is found. If there
 *		       is an active SCB, return NULL!
 */
struct iha_scb *
iha_find_pend_scb(struct iha_softc *sc)
{
	struct iha_scb *pScb;
	struct tcs *pTcs;
	int s;

	s = splbio();

	if (sc->HCS_ActScb != NULL)
		pScb = NULL;

	else
		TAILQ_FOREACH(pScb, &sc->HCS_PendScb, SCB_ScbList) {
			if ((pScb->SCB_Flags & SCSI_RESET) != 0)
				/* ALWAYS willing to reset a device */
				break;

			pTcs = pScb->SCB_Tcs;

			if ((pScb->SCB_TagMsg) != 0) {
				/*
				 * A Tagged I/O. OK to start If no
				 * non-tagged I/O is active on the same
				 * target
				 */
				if (pTcs->TCS_NonTagScb == NULL)
					break;

			} else	if (pScb->SCB_CDB[0] == REQUEST_SENSE) {
				/*
				 * OK to do a non-tagged request sense
				 * even if a non-tagged I/O has been
				 * started, because we don't allow any
				 * disconnect during a request sense op
				 */
				break;

			} else	if (pTcs->TCS_TagCnt == 0) {
				/*
				 * No tagged I/O active on this target,
				 * ok to start a non-tagged one if one
				 * is not already active
				 */
				if (pTcs->TCS_NonTagScb == NULL)
					break;
			}
		}

	splx(s);

	return (pScb);
}

void
iha_mark_busy_scb(struct iha_scb *pScb)
{
	int  s;

	s = splbio();

	pScb->SCB_Status = STATUS_BUSY;

	if (pScb->SCB_TagMsg == 0)
		pScb->SCB_Tcs->TCS_NonTagScb = pScb;
	else
		pScb->SCB_Tcs->TCS_TagCnt++;

	splx(s);
}

void
iha_append_done_scb(struct iha_softc *sc, struct iha_scb *pScb, u_int8_t hastat)
{
	struct tcs *pTcs;
	int s;

	s = splbio();

	if (pScb->SCB_Xs != NULL)
		timeout_del(&pScb->SCB_Xs->stimeout);

	if (pScb == sc->HCS_ActScb)
		sc->HCS_ActScb = NULL;

	pTcs = pScb->SCB_Tcs;

	if (pScb->SCB_TagMsg != 0) {
		if (pTcs->TCS_TagCnt)
			pTcs->TCS_TagCnt--;
	} else if (pTcs->TCS_NonTagScb == pScb)
		pTcs->TCS_NonTagScb = NULL;

	pScb->SCB_Status = STATUS_QUEUED;
	pScb->SCB_HaStat = hastat;

	TAILQ_INSERT_TAIL(&sc->HCS_DoneScb, pScb, SCB_ScbList);

	splx(s);
}

struct iha_scb *
iha_pop_done_scb(struct iha_softc *sc)
{
	struct iha_scb *pScb;
	int s;

	s = splbio();

	pScb = TAILQ_FIRST(&sc->HCS_DoneScb);

	if (pScb != NULL) {
		pScb->SCB_Status = STATUS_RENT;
		TAILQ_REMOVE(&sc->HCS_DoneScb, pScb, SCB_ScbList);
	}

	splx(s);

	return (pScb);
}

/*
 * iha_abort_xs - find the SCB associated with the supplied xs and
 *                stop all processing on it, moving it to the done
 *                queue with the supplied host status value.
 */
void
iha_abort_xs(struct iha_softc *sc, struct scsi_xfer *xs, u_int8_t hastat)
{
	struct iha_scb *pScb, *next;
	int i, s;

	s = splbio();

	/* Check the pending queue for the SCB pointing to xs */

	for (pScb = TAILQ_FIRST(&sc->HCS_PendScb); pScb != NULL; pScb = next) {
		next = TAILQ_NEXT(pScb, SCB_ScbList);
		if (pScb->SCB_Xs == xs) {
			TAILQ_REMOVE(&sc->HCS_PendScb, pScb, SCB_ScbList);
			iha_append_done_scb(sc, pScb, hastat);
			splx(s);
			return;
		}
	}

	/*
	 * If that didn't work, check all BUSY/SELECTING SCB's for one
	 * pointing to xs
	 */

	for (i = 0, pScb = sc->HCS_Scb; i < IHA_MAX_SCB; i++, pScb++)
		switch (pScb->SCB_Status) {
		case STATUS_BUSY:
		case STATUS_SELECT:
			if (pScb->SCB_Xs == xs) {
				iha_append_done_scb(sc, pScb, hastat);
				splx(s);
				return;
			}
			break;
		default:
			break;
		}
	
	splx(s);
}

/*
 * iha_bad_seq - a SCSI bus phase was encountered out of the
 *               correct/expected sequence. Reset the SCSI bus.
 */
void
iha_bad_seq(struct iha_softc *sc)
{
	struct iha_scb *pScb = sc->HCS_ActScb;

	if (pScb != NULL)
		iha_append_done_scb(sc, pScb, HOST_BAD_PHAS);

	iha_reset_scsi_bus(sc);
	iha_reset_chip(sc, sc->sc_iot, sc->sc_ioh);
}

/*
 * iha_push_sense_request - obtain auto sense data by pushing the
 *                          SCB needing it back onto the pending
 *			    queue with a REQUEST_SENSE CDB.
 */
int
iha_push_sense_request(struct iha_softc *sc, struct iha_scb *pScb)
{
	struct scsi_sense *sensecmd;
	int error;

	/* First sync & unload any existing DataDma and SGDma maps */
	if ((pScb->SCB_Flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) != 0) {
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma,
			0, pScb->SCB_BufChars,
			((pScb->SCB_Flags & SCSI_DATA_IN) ? 
				BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
		bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
		/* Don't unload this map again until it is reloaded */
		pScb->SCB_Flags &= ~(SCSI_DATA_IN | SCSI_DATA_OUT);
	}
	if ((pScb->SCB_Flags & FLAG_SG) != 0) {
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma,
			0, sizeof(pScb->SCB_SGList),
			BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, pScb->SCB_SGDma);
		/* Don't unload this map again until it is reloaded */
		pScb->SCB_Flags &= ~FLAG_SG;
	}

	pScb->SCB_BufChars     = sizeof(pScb->SCB_ScsiSenseData);
	pScb->SCB_BufCharsLeft = sizeof(pScb->SCB_ScsiSenseData);
	bzero(&pScb->SCB_ScsiSenseData, sizeof(pScb->SCB_ScsiSenseData)); 

	error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_DataDma,
			&pScb->SCB_ScsiSenseData,
			sizeof(pScb->SCB_ScsiSenseData), NULL,
			(pScb->SCB_Flags & SCSI_NOSLEEP) ?
				BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error) {
		sc_print_addr(pScb->SCB_Xs->sc_link);
		printf("error %d loading request sense buffer dma map\n",
			error);
		return (error);
	}
	bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma, 
		0, pScb->SCB_BufChars, BUS_DMASYNC_PREREAD);

	/* Save _POLL and _NOSLEEP flags. */ 
	pScb->SCB_Flags &= SCSI_POLL | SCSI_NOSLEEP;
	pScb->SCB_Flags |= FLAG_RSENS | SCSI_DATA_IN;

	error = iha_setup_sg_list(sc, pScb);
	if (error)
		return (error);

	pScb->SCB_Ident &= ~MSG_IDENTIFY_DISCFLAG;

	pScb->SCB_TagMsg = 0;
	pScb->SCB_TaStat = SCSI_OK;

	bzero(pScb->SCB_CDB, sizeof(pScb->SCB_CDB));

	sensecmd = (struct scsi_sense *)pScb->SCB_CDB;
	pScb->SCB_CDBLen = sizeof(*sensecmd);
	sensecmd->opcode = REQUEST_SENSE;
	sensecmd->byte2  = pScb->SCB_Xs->sc_link->lun << 5;
	sensecmd->length = sizeof(pScb->SCB_ScsiSenseData);

	if ((pScb->SCB_Flags & SCSI_POLL) == 0)
		timeout_add_msec(&pScb->SCB_Xs->stimeout,
		    pScb->SCB_Xs->timeout);

	iha_push_pend_scb(sc, pScb);

	return (0);
}

/*
 * iha_main - process the active SCB, taking one off pending and making it
 *            active if necessary, and any done SCB's created as
 *            a result until there are no interrupts pending and no pending
 *            SCB's that can be started.
 */
void
iha_main(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb;

	for (;;) {
iha_scsi_label:
		iha_scsi(sc, iot, ioh);

		while ((pScb = iha_pop_done_scb(sc)) != NULL) {

			switch (pScb->SCB_TaStat) {
			case SCSI_TERMINATED:
			case SCSI_ACA_ACTIVE:
			case SCSI_CHECK:
				pScb->SCB_Tcs->TCS_Flags &= 
				    ~(FLAG_SYNC_DONE | FLAG_WIDE_DONE);

				if ((pScb->SCB_Flags & FLAG_RSENS) != 0)
					/* Check condition on check condition*/
					pScb->SCB_HaStat = HOST_BAD_PHAS;
				else if (iha_push_sense_request(sc, pScb) != 0)
					/* Could not push sense request */
					pScb->SCB_HaStat = HOST_BAD_PHAS;
				else
					/* REQUEST SENSE ready to process */
					goto iha_scsi_label;
				break;

			default:
				if ((pScb->SCB_Flags & FLAG_RSENS) != 0)
					/*
					 * Return the original SCSI_CHECK, not
					 * the status of the request sense
					 * command!		
					 */
					pScb->SCB_TaStat = SCSI_CHECK;
				break;
			}

			iha_done_scb(sc, pScb);
		}

		/*
		 * If there are no interrupts pending, or we can't start
		 * a pending sc, break out of the for(;;). Otherwise
		 * continue the good work with another call to
		 * iha_scsi().
		 */
		if (((bus_space_read_1(iot, ioh, TUL_STAT0) & INTPD) == 0) 
		    && (iha_find_pend_scb(sc) == NULL))
			break;
	}
}

/*
 * iha_scsi - service any outstanding interrupts. If there are none, try to
 *            start another SCB currently in the pending queue.
 */
void
iha_scsi(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb;
	struct tcs *pTcs;
	u_int8_t stat;
	int i;

	/* service pending interrupts asap */

	stat = bus_space_read_1(iot, ioh, TUL_STAT0);
	if ((stat & INTPD) != 0) {
		sc->HCS_JSStatus0 = stat;
		sc->HCS_JSStatus1 = bus_space_read_1(iot, ioh, TUL_STAT1);
		sc->HCS_JSInt     = bus_space_read_1(iot, ioh, TUL_SISTAT);

		sc->HCS_Phase = sc->HCS_JSStatus0 & PH_MASK;
		
		if ((sc->HCS_JSInt & SRSTD) != 0) {
			iha_reset_scsi_bus(sc);
			return;
		}
		
		if ((sc->HCS_JSInt & RSELED) != 0) {
			iha_resel(sc, iot, ioh);
			return;
		}

		if ((sc->HCS_JSInt & (STIMEO | DISCD)) != 0) {
			iha_busfree(sc, iot, ioh);
			return;
		}

		if ((sc->HCS_JSInt & (SCMDN | SBSRV)) != 0) {
			iha_next_state(sc, iot, ioh);
			return;
		}

		if ((sc->HCS_JSInt & SELED) != 0)
			iha_set_ssig(iot, ioh, 0, 0);
	}

	/*
	 * There were no interrupts pending which required action elsewhere, so
	 * see if it is possible to start the selection phase on a pending SCB
	 */
	if ((pScb = iha_find_pend_scb(sc)) == NULL)
		return;

	pTcs = pScb->SCB_Tcs;

	/* program HBA's SCSI ID & target SCSI ID */
	bus_space_write_1(iot, ioh, TUL_SID,
	    (sc->sc_link.adapter_target << 4) | pScb->SCB_Target);

	if ((pScb->SCB_Flags & SCSI_RESET) == 0) {
		bus_space_write_1(iot, ioh, TUL_SYNCM, pTcs->TCS_JS_Period);

		if (((pTcs->TCS_Flags & FLAG_NO_NEG_WIDE) == 0)
		    ||
		    ((pTcs->TCS_Flags & FLAG_NO_NEG_SYNC) == 0))
			iha_select(sc, iot, ioh, pScb, SELATNSTOP);

		else if (pScb->SCB_TagMsg != 0)
			iha_select(sc, iot, ioh, pScb, SEL_ATN3);

		else
			iha_select(sc, iot, ioh, pScb, SEL_ATN);

	} else {
		iha_select(sc, iot, ioh, pScb, SELATNSTOP);
		pScb->SCB_NxtStat = 8;
	}

	if ((pScb->SCB_Flags & SCSI_POLL) != 0) {
		for (i = pScb->SCB_Xs->timeout; i > 0; i--) {
			if (iha_wait(sc, iot, ioh, NO_OP) == -1)
				break;
			if (iha_next_state(sc, iot, ioh) == -1)
				break;
			delay(1000); /* Only happens in boot, so it's ok */
		}

		/*
		 * Since done queue processing not done until AFTER this
		 * function returns, pScb is on the done queue, not
		 * the free queue at this point and still has valid data
		 *
		 * Conversely, xs->error has not been set yet
		 */
		if (i == 0)
			iha_timeout(pScb);

		else if ((pScb->SCB_CDB[0] == INQUIRY)
		    && (pScb->SCB_Lun == 0)
		    && (pScb->SCB_HaStat == HOST_OK)
		    && (pScb->SCB_TaStat == SCSI_OK))
			iha_print_info(sc, pScb->SCB_Target);
	}
}

/*
 * iha_data_over_run - return HOST_OK for all SCSI opcodes where BufCharsLeft
 *                     is an 'Allocation Length'. All other SCSI opcodes
 *		       get HOST_DO_DU as they SHOULD have xferred all the
 *		       data requested.
 * 
 *		       The list of opcodes using 'Allocation Length' was
 * 		       found by scanning all the SCSI-3 T10 drafts. See
 *		       www.t10.org for the curious with a .pdf reader.
 */
u_int8_t
iha_data_over_run(struct iha_scb *pScb)
{
	switch (pScb->SCB_CDB[0]) {
	case 0x03: /* Request Sense                   SPC-2 */
	case 0x12: /* Inquiry                         SPC-2 */
	case 0x1a: /* Mode Sense (6 byte version)     SPC-2 */
	case 0x1c: /* Receive Diagnostic Results      SPC-2 */
	case 0x23: /* Read Format Capacities          MMC-2 */
	case 0x29: /* Read Generation                 SBC   */
	case 0x34: /* Read Position                   SSC-2 */
	case 0x37: /* Read Defect Data                SBC   */
	case 0x3c: /* Read Buffer                     SPC-2 */
	case 0x42: /* Read Sub Channel                MMC-2 */
	case 0x43: /* Read TOC/PMA/ATIP               MMC   */

	/* XXX - 2 with same opcode of 0x44? */
	case 0x44: /* Read Header/Read Density Suprt  MMC/SSC*/

	case 0x46: /* Get Configuration               MMC-2 */
	case 0x4a: /* Get Event/Status Notification   MMC-2 */
	case 0x4d: /* Log Sense                       SPC-2 */
	case 0x51: /* Read Disc Information           MMC   */
	case 0x52: /* Read Track Information          MMC   */
	case 0x59: /* Read Master CUE                 MMC   */
	case 0x5a: /* Mode Sense (10 byte version)    SPC-2 */
	case 0x5c: /* Read Buffer Capacity            MMC   */
	case 0x5e: /* Persistent Reserve In           SPC-2 */
	case 0x84: /* Receive Copy Results            SPC-2 */
	case 0xa0: /* Report LUNs                     SPC-2 */
	case 0xa3: /* Various Report requests         SBC-2/SCC-2*/
	case 0xa4: /* Report Key                      MMC-2 */
	case 0xad: /* Read DVD Structure              MMC-2 */
	case 0xb4: /* Read Element Status (Attached)  SMC   */
	case 0xb5: /* Request Volume Element Address  SMC   */
	case 0xb7: /* Read Defect Data (12 byte ver.) SBC   */
	case 0xb8: /* Read Element Status (Independ.) SMC   */
	case 0xba: /* Report Redundancy               SCC-2 */
	case 0xbd: /* Mechanism Status                MMC   */
	case 0xbe: /* Report Basic Redundancy         SCC-2 */

		return (HOST_OK);
		break;
		
	default:
		return (HOST_DO_DU);
		break;
	}
}

/*
 * iha_next_state - process the current SCB as requested in its 
 *                  SCB_NxtStat member.
 */
int
iha_next_state(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh)
{
	if (sc->HCS_ActScb == NULL)
		return (-1);

	switch (sc->HCS_ActScb->SCB_NxtStat) {
	case 1:
		if (iha_state_1(sc, iot, ioh) == 3)
			goto state_3;
		break;

	case 2:
		switch (iha_state_2(sc, iot, ioh)) {
		case 3:	 goto state_3;
		case 4:	 goto state_4;
		default: break;
		}
		break;

	case 3:
	state_3:
		if (iha_state_3(sc, iot, ioh) == 4)
			goto state_4;
		break;

	case 4:
	state_4:
		switch (iha_state_4(sc, iot, ioh)) {
		case 0:	 return (0);
		case 6:	 goto state_6;
		default: break;
		}
		break;

	case 5:
		switch (iha_state_5(sc, iot, ioh)) {
		case 4:	 goto state_4;
		case 6:	 goto state_6;
		default: break;
		}
		break;

	case 6:
	state_6:
		iha_state_6(sc, iot, ioh);
		break;

	case 8:
		iha_state_8(sc, iot, ioh);
		break;

	default:
#ifdef IHA_DEBUG_STATE
		sc_print_addr(sc->HCS_ActScb->SCB_Xs->sc_link);
		printf("[debug] -unknown state: %i-\n",
		    sc->HCS_ActScb->SCB_NxtStat);
#endif
		iha_bad_seq(sc);
		break;
	}

	return (-1);
}

/*
 * iha_state_1 - selection is complete after a SELATNSTOP. If the target
 *               has put the bus into MSG_OUT phase start wide/sync
 *               negotiation. Otherwise clear the FIFO and go to state 3,
 *	    	 which will send the SCSI CDB to the target.
 */
int
iha_state_1(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb = sc->HCS_ActScb;
	struct tcs *pTcs;
	u_int16_t flags;

	iha_mark_busy_scb(pScb);

	pTcs = pScb->SCB_Tcs;

	bus_space_write_1(iot, ioh, TUL_SCONFIG0, pTcs->TCS_SConfig0);

	/*
	 * If we are in PHASE_MSG_OUT, send
	 *     a) IDENT message (with tags if appropriate)
	 *     b) WDTR if the target is configured to negotiate wide xfers
	 *     ** OR **
	 *     c) SDTR if the target is configured to negotiate sync xfers
	 *	  but not wide ones
	 *
	 * If we are NOT, then the target is not asking for anything but
	 * the data/command, so go straight to state 3.
	 */
	if (sc->HCS_Phase == PHASE_MSG_OUT) {
		bus_space_write_1(iot, ioh, TUL_SCTRL1, (ESBUSIN | EHRSL));
		bus_space_write_1(iot, ioh, TUL_SFIFO,	pScb->SCB_Ident);

		if (pScb->SCB_TagMsg != 0) {
			bus_space_write_1(iot, ioh, TUL_SFIFO,
			    pScb->SCB_TagMsg);
			bus_space_write_1(iot, ioh, TUL_SFIFO,
			    pScb->SCB_TagId);
		}

		flags = pTcs->TCS_Flags;
		if ((flags & FLAG_NO_NEG_WIDE) == 0) {
			if (iha_msgout_wdtr(sc, iot, ioh) == -1)
				return (-1);
		} else if ((flags & FLAG_NO_NEG_SYNC) == 0) {
			if (iha_msgout_sdtr(sc, iot, ioh) == -1)
				return (-1);
		}

	} else {
		bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);
		iha_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
	}

	return (3);
}

/*
 * iha_state_2 - selection is complete after a SEL_ATN or SEL_ATN3. If the SCSI
 *		 CDB has already been send, go to state 4 to start the data
 *               xfer. Otherwise reset the FIFO and go to state 3, sending 
 *		 the SCSI CDB.
 */
int
iha_state_2(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb = sc->HCS_ActScb;

	iha_mark_busy_scb(pScb);

	bus_space_write_1(iot, ioh, TUL_SCONFIG0, pScb->SCB_Tcs->TCS_SConfig0);

	if ((sc->HCS_JSStatus1 & CPDNE) != 0)
		return (4);

	bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);

	iha_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);

	return (3);
}

/*
 * iha_state_3 - send the SCSI CDB to the target, processing any status
 *		 or other messages received until that is done or
 *               abandoned.
 */
int
iha_state_3(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb = sc->HCS_ActScb;
	u_int16_t flags;

	for (;;)
		switch (sc->HCS_Phase) {
		case PHASE_CMD_OUT:
			bus_space_write_multi_1(iot, ioh, TUL_SFIFO,
			    pScb->SCB_CDB, pScb->SCB_CDBLen);
			if (iha_wait(sc, iot, ioh, XF_FIFO_OUT) == -1)
				return (-1);
			else if (sc->HCS_Phase == PHASE_CMD_OUT) {
				iha_bad_seq(sc);
				return (-1);
			} else
				return (4);

		case PHASE_MSG_IN:
			pScb->SCB_NxtStat = 3;
			if (iha_msgin(sc, iot, ioh) == -1)
				return (-1);
			break;

		case PHASE_STATUS_IN:
			if (iha_status_msg(sc, iot, ioh) == -1)
				return (-1);
			break;

		case PHASE_MSG_OUT:
			flags = pScb->SCB_Tcs->TCS_Flags;
			if ((flags & FLAG_NO_NEG_SYNC) != 0) {
				if (iha_msgout(sc, iot, ioh, MSG_NOOP) == -1)
					return (-1);
			} else if (iha_msgout_sdtr(sc, iot, ioh) == -1)
				return (-1);
			break;

		default:
#ifdef IHA_DEBUG_STATE
			sc_print_addr(pScb->SCB_Xs->sc_link);
			printf("[debug] -s3- bad phase = %d\n", sc->HCS_Phase);
#endif
			iha_bad_seq(sc);
			return (-1);
		}
}

/* 
 * iha_state_4 - start a data xfer. Handle any bus state
 *               transitions until PHASE_DATA_IN/_OUT
 *               or the attempt is abandoned. If there is 
 *               no data to xfer, go to state 6 and finish
 *               processing the current SCB.
 */
int
iha_state_4(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb = sc->HCS_ActScb;

	if ((pScb->SCB_Flags & FLAG_DIR) == FLAG_DIR)
		return (6); /* Both dir flags set => NO xfer was requested */

	for (;;) {
		if (pScb->SCB_BufCharsLeft == 0)
			return (6);

		switch (sc->HCS_Phase) {
		case PHASE_STATUS_IN:
			if ((pScb->SCB_Flags & FLAG_DIR) != 0)
				pScb->SCB_HaStat = iha_data_over_run(pScb);
			if ((iha_status_msg(sc, iot, ioh)) == -1)
				return (-1);
			break;

		case PHASE_MSG_IN:
			pScb->SCB_NxtStat = 4;
			if (iha_msgin(sc, iot, ioh) == -1)
				return (-1);
			break;

		case PHASE_MSG_OUT:
			if ((sc->HCS_JSStatus0 & SPERR) != 0) {
				pScb->SCB_BufCharsLeft = 0;
				pScb->SCB_HaStat = HOST_SPERR;
				if (iha_msgout(sc, iot, ioh,
					MSG_INITIATOR_DET_ERR) == -1)
					return (-1);
				else
					return (6);
			} else {
				if (iha_msgout(sc, iot, ioh, MSG_NOOP) == -1)
					return (-1);
			}
			break;

		case PHASE_DATA_IN:
			return (iha_xfer_data(pScb, iot, ioh, SCSI_DATA_IN));

		case PHASE_DATA_OUT:
			return (iha_xfer_data(pScb, iot, ioh, SCSI_DATA_OUT));

		default:
			iha_bad_seq(sc);
			return (-1);
		}
	}
}

/*
 * iha_state_5 - handle the partial or final completion of the current
 *               data xfer. If DMA is still active stop it. If there is 
 *		 more data to xfer, go to state 4 and start the xfer.
 *               If not go to state 6 and finish the SCB.
 */
int
iha_state_5(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb = sc->HCS_ActScb;
	struct iha_sg_element *pSg;
	u_int32_t cnt;
	u_int16_t period;
	u_int8_t stat;
	long xcnt;  /* cannot use unsigned!! see code: if (xcnt < 0) */

	cnt = bus_space_read_4(iot, ioh, TUL_STCNT0) & TCNT;
	
	/*
	 * Stop any pending DMA activity and check for parity error.
	 */

	if ((bus_space_read_1(iot, ioh, TUL_DCMD) & XDIR) != 0) {
		/* Input Operation */
		if ((sc->HCS_JSStatus0 & SPERR) != 0)
			pScb->SCB_HaStat = HOST_SPERR;

		if ((bus_space_read_1(iot, ioh, TUL_ISTUS1) & XPEND) != 0) {
			bus_space_write_1(iot, ioh, TUL_DCTRL0,
			    bus_space_read_1(iot, ioh, TUL_DCTRL0) | SXSTP);
			while (bus_space_read_1(iot, ioh, TUL_ISTUS1) & XPEND)
				;
		}

	} else {
		/* Output Operation */
		if ((sc->HCS_JSStatus1 & SXCMP) == 0) {
			period = pScb->SCB_Tcs->TCS_JS_Period; 
			if ((period & PERIOD_WIDE_SCSI) != 0)
				cnt += (bus_space_read_1(iot, ioh,
					    TUL_SFIFOCNT) & FIFOC) << 1;
			else
				cnt += (bus_space_read_1(iot, ioh,
					    TUL_SFIFOCNT) & FIFOC);
		}

		if ((bus_space_read_1(iot, ioh, TUL_ISTUS1) & XPEND) != 0) {
			bus_space_write_1(iot, ioh, TUL_DCMD, ABTXFR);
			do
				stat = bus_space_read_1(iot, ioh, TUL_ISTUS0);
			while ((stat & DABT) == 0);
		}

		if ((cnt == 1) && (sc->HCS_Phase == PHASE_DATA_OUT)) {
			if (iha_wait(sc, iot, ioh, XF_FIFO_OUT) == -1)
				return (-1);
			cnt = 0;

		} else if ((sc->HCS_JSStatus1 & SXCMP) == 0)
			bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);
	}

	if (cnt == 0) {
		pScb->SCB_BufCharsLeft = 0;
		return (6);
	}

	/* Update active data pointer and restart the I/O at the new point */

	xcnt = pScb->SCB_BufCharsLeft - cnt;	/* xcnt == bytes xferred */
	pScb->SCB_BufCharsLeft = cnt;		/* cnt  == bytes left    */

	bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma, 
		0, sizeof(pScb->SCB_SGList), BUS_DMASYNC_POSTWRITE);

	if ((pScb->SCB_Flags & FLAG_SG) != 0) {
		pSg = &pScb->SCB_SGList[pScb->SCB_SGIdx];
		for (; pScb->SCB_SGIdx < pScb->SCB_SGCount; pSg++, pScb->SCB_SGIdx++) {
			xcnt -= pSg->SG_Len;
			if (xcnt < 0) {
				xcnt += pSg->SG_Len;

				pSg->SG_Addr += xcnt;
				pSg->SG_Len -= xcnt;

				bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma, 
					0, sizeof(pScb->SCB_SGList),
					BUS_DMASYNC_PREWRITE);

				return (4);
			}
		}
		return (6);

	}

	return (4);
}

/*
 * iha_state_6 - finish off the active scb (may require several
 *               iterations if PHASE_MSG_IN) and return -1 to indicate 
 *		 the bus is free.
 */
int
iha_state_6(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	for (;;)
		switch (sc->HCS_Phase) {
		case PHASE_STATUS_IN:
			if (iha_status_msg(sc, iot, ioh) == -1)
				return (-1);
			break;

		case PHASE_MSG_IN:
			sc->HCS_ActScb->SCB_NxtStat = 6;
			if ((iha_msgin(sc, iot, ioh)) == -1)
				return (-1);
			break;

		case PHASE_MSG_OUT:
			if ((iha_msgout(sc, iot, ioh, MSG_NOOP)) == -1)
				return (-1);
			break;

		case PHASE_DATA_IN:
			if (iha_xpad_in(sc, iot, ioh) == -1)
				return (-1);
			break;

		case PHASE_DATA_OUT:
			if (iha_xpad_out(sc, iot, ioh) == -1)
				return (-1);
			break;

		default:
			iha_bad_seq(sc);
			return (-1);
		}
}

/*
 * iha_state_8 - reset the active device and all busy SCBs using it
 */
int
iha_state_8(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb;
	u_int32_t i;
	u_int8_t tar;

	if (sc->HCS_Phase == PHASE_MSG_OUT) {
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_BUS_DEV_RESET);

		pScb = sc->HCS_ActScb;
		
		/* This SCB finished correctly -- resetting the device */
		iha_append_done_scb(sc, pScb, HOST_OK);

		iha_reset_tcs(pScb->SCB_Tcs, sc->HCS_SConf1);

		tar = pScb->SCB_Target;
		for (i = 0, pScb = sc->HCS_Scb; i < IHA_MAX_SCB; i++, pScb++)
			if (pScb->SCB_Target == tar)
				switch (pScb->SCB_Status) {
				case STATUS_BUSY:
					iha_append_done_scb(sc,
					    pScb, HOST_DEV_RST);
					break;

				case STATUS_SELECT:
					iha_push_pend_scb(sc, pScb);
					break;
					
				default:
					break;
				}

		sc->HCS_Flags |= FLAG_EXPECT_DISC;

		if (iha_wait(sc, iot, ioh, XF_FIFO_OUT) == -1)
			return (-1);
	}

	iha_bad_seq(sc);
	return (-1);
}

/*
 * iha_xfer_data - initiate the DMA xfer of the data
 */
int
iha_xfer_data(struct iha_scb *pScb, bus_space_tag_t iot, bus_space_handle_t ioh,
    int direction)
{
	u_int32_t xferaddr, xferlen;
	u_int8_t xfertype;

	if ((pScb->SCB_Flags & FLAG_DIR) != direction)
		return (6); /* wrong direction, abandon I/O */

	bus_space_write_4(iot, ioh, TUL_STCNT0, pScb->SCB_BufCharsLeft);

	if ((pScb->SCB_Flags & FLAG_SG) == 0) {
		xferaddr = pScb->SCB_DataDma->dm_segs[0].ds_addr
				+ (pScb->SCB_BufChars - pScb->SCB_BufCharsLeft);
		xferlen  = pScb->SCB_BufCharsLeft;
		xfertype = (direction == SCSI_DATA_IN) ? ST_X_IN : ST_X_OUT;

	} else {
		xferaddr = pScb->SCB_SGDma->dm_segs[0].ds_addr
				+ (pScb->SCB_SGIdx * sizeof(struct iha_sg_element));
		xferlen  = (pScb->SCB_SGCount - pScb->SCB_SGIdx)
				* sizeof(struct iha_sg_element);
		xfertype = (direction == SCSI_DATA_IN) ? ST_SG_IN : ST_SG_OUT;
	}

	bus_space_write_4(iot, ioh, TUL_DXC,  xferlen);
	bus_space_write_4(iot, ioh, TUL_DXPA, xferaddr);
	bus_space_write_1(iot, ioh, TUL_DCMD, xfertype);

	bus_space_write_1(iot, ioh, TUL_SCMD,
	    (direction == SCSI_DATA_IN) ? XF_DMA_IN : XF_DMA_OUT);

	pScb->SCB_NxtStat = 5;

	return (0);
}

int
iha_xpad_in(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb = sc->HCS_ActScb;

	if ((pScb->SCB_Flags & FLAG_DIR) != 0)
		pScb->SCB_HaStat = HOST_DO_DU;

	for (;;) {
		if ((pScb->SCB_Tcs->TCS_JS_Period & PERIOD_WIDE_SCSI) != 0)
			bus_space_write_4(iot, ioh, TUL_STCNT0, 2);
		else
			bus_space_write_4(iot, ioh, TUL_STCNT0, 1);

		switch (iha_wait(sc, iot, ioh, XF_FIFO_IN)) {
		case -1:
			return (-1);

		case PHASE_DATA_IN:
			bus_space_read_1(iot, ioh, TUL_SFIFO);
			break;

		default:
			bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);
			return (6);
		}
	}
}

int
iha_xpad_out(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb = sc->HCS_ActScb;

	if ((pScb->SCB_Flags & FLAG_DIR) != 0)
		pScb->SCB_HaStat = HOST_DO_DU;

	for (;;) {
		if ((pScb->SCB_Tcs->TCS_JS_Period & PERIOD_WIDE_SCSI) != 0)
			bus_space_write_4(iot, ioh, TUL_STCNT0, 2);
		else
			bus_space_write_4(iot, ioh, TUL_STCNT0, 1);

		bus_space_write_1(iot, ioh, TUL_SFIFO, 0);

		switch (iha_wait(sc, iot, ioh, XF_FIFO_OUT)) {
		case -1:
			return (-1);

		case PHASE_DATA_OUT:
			break;

		default:
			/* Disable wide CPU to allow read 16 bits */
			bus_space_write_1(iot, ioh, TUL_SCTRL1, EHRSL);
			bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);
			return (6);
		}
	}
}

int
iha_status_msg(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh)
{
	struct iha_scb *pScb;
	u_int8_t msg;
	int phase;

	if ((phase = iha_wait(sc, iot, ioh, CMD_COMP)) == -1)
		return (-1);

	pScb = sc->HCS_ActScb;
	
	pScb->SCB_TaStat = bus_space_read_1(iot, ioh, TUL_SFIFO);

	if (phase == PHASE_MSG_OUT) {
		if ((sc->HCS_JSStatus0 & SPERR) == 0)
			bus_space_write_1(iot, ioh, TUL_SFIFO,
			    MSG_NOOP);
		else
			bus_space_write_1(iot, ioh, TUL_SFIFO,
			    MSG_PARITY_ERROR);

		return (iha_wait(sc, iot, ioh, XF_FIFO_OUT));

	} else if (phase == PHASE_MSG_IN) {
		msg = bus_space_read_1(iot, ioh, TUL_SFIFO);

		if ((sc->HCS_JSStatus0 & SPERR) != 0)
			switch (iha_wait(sc, iot, ioh, MSG_ACCEPT)) {
			case -1:
				return (-1);
			case PHASE_MSG_OUT:
				bus_space_write_1(iot, ioh, TUL_SFIFO,
				    MSG_PARITY_ERROR);
				return (iha_wait(sc, iot, ioh, XF_FIFO_OUT));
			default:
				iha_bad_seq(sc);
				return (-1);
			}

		if (msg == MSG_CMDCOMPLETE) {
			if ((pScb->SCB_TaStat 
				& (SCSI_INTERM | SCSI_BUSY)) == SCSI_INTERM) {
				iha_bad_seq(sc);
				return (-1);
			}
			sc->HCS_Flags |= FLAG_EXPECT_DONE_DISC;
			bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);
			return (iha_wait(sc, iot, ioh, MSG_ACCEPT));
		}

		if ((msg == MSG_LINK_CMD_COMPLETE)
		    || (msg == MSG_LINK_CMD_COMPLETEF)) {
			if ((pScb->SCB_TaStat 
				 & (SCSI_INTERM | SCSI_BUSY)) == SCSI_INTERM)
				return (iha_wait(sc, iot, ioh, MSG_ACCEPT));
		}
	}

	iha_bad_seq(sc);
	return (-1);
}

/*
 * iha_busfree - SCSI bus free detected as a result of a TIMEOUT or
 *		 DISCONNECT interrupt. Reset the tulip FIFO and
 *		 SCONFIG0 and enable hardware reselect. Move any active
 *		 SCB to HCS_DoneScb list. Return an appropriate host status
 *		 if an I/O was active.
 */
void
iha_busfree(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb;

	bus_space_write_1(iot, ioh, TUL_SCTRL0,	  RSFIFO);
	bus_space_write_1(iot, ioh, TUL_SCONFIG0, SCONFIG0DEFAULT);
	bus_space_write_1(iot, ioh, TUL_SCTRL1,	  EHRSL);

	pScb = sc->HCS_ActScb;

	if (pScb != NULL) {
		if (pScb->SCB_Status == STATUS_SELECT)
			/* selection timeout   */
			iha_append_done_scb(sc, pScb, HOST_SEL_TOUT);
		else
			/* Unexpected bus free */
			iha_append_done_scb(sc, pScb, HOST_BAD_PHAS);

	}
}

void
iha_reset_scsi_bus(struct iha_softc *sc)
{
	struct iha_scb *pScb;
	struct tcs *pTcs;
	int i, s;

	s = splbio();

	iha_reset_dma(sc->sc_iot, sc->sc_ioh);

	for (i = 0, pScb = sc->HCS_Scb; i < IHA_MAX_SCB; i++, pScb++)
		switch (pScb->SCB_Status) {
		case STATUS_BUSY:
			iha_append_done_scb(sc, pScb, HOST_SCSI_RST);
			break;

		case STATUS_SELECT:
			iha_push_pend_scb(sc, pScb);
			break;

		default:
			break;
		}

	for (i = 0, pTcs = sc->HCS_Tcs; i < IHA_MAX_TARGETS; i++, pTcs++)
		iha_reset_tcs(pTcs, sc->HCS_SConf1);

	splx(s);
}

/*
 * iha_resel - handle a detected SCSI bus reselection request.
 */
int
iha_resel(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct iha_scb *pScb;
	struct tcs *pTcs;
	u_int8_t tag, target, lun, msg, abortmsg;

	if (sc->HCS_ActScb != NULL) {
		if (sc->HCS_ActScb->SCB_Status == STATUS_SELECT)
			iha_push_pend_scb(sc, sc->HCS_ActScb);
		sc->HCS_ActScb = NULL;
	}

	target = bus_space_read_1(iot, ioh, TUL_SBID);
	lun    = bus_space_read_1(iot, ioh, TUL_SALVC) & MSG_IDENTIFY_LUNMASK;

	pTcs = &sc->HCS_Tcs[target];

	bus_space_write_1(iot, ioh, TUL_SCONFIG0, pTcs->TCS_SConfig0);
	bus_space_write_1(iot, ioh, TUL_SYNCM,	  pTcs->TCS_JS_Period);

	abortmsg = MSG_ABORT; /* until a valid tag has been obtained */

	if (pTcs->TCS_NonTagScb != NULL)
		/* There is a non-tagged I/O active on the target */
		pScb = pTcs->TCS_NonTagScb;

	else {
		/* 
		 * Since there is no active non-tagged operation
		 * read the tag type, the tag itself, and find
		 * the appropriate pScb by indexing HCS_Scb with
		 * the tag.
		 */

		switch (iha_wait(sc, iot, ioh, MSG_ACCEPT)) {
		case -1:
			return (-1);
		case PHASE_MSG_IN:
			bus_space_write_4(iot, ioh, TUL_STCNT0, 1);
			if ((iha_wait(sc, iot, ioh, XF_FIFO_IN)) == -1)
				return (-1);
			break;
		default:
			goto abort;
		}

		msg = bus_space_read_1(iot, ioh, TUL_SFIFO); /* Read Tag Msg */

		if ((msg < MSG_SIMPLE_Q_TAG) || (msg > MSG_ORDERED_Q_TAG))
			goto abort;

		switch (iha_wait(sc, iot, ioh, MSG_ACCEPT)) {
		case -1:
			return (-1);
		case PHASE_MSG_IN:
			bus_space_write_4(iot, ioh, TUL_STCNT0, 1);
			if ((iha_wait(sc, iot, ioh, XF_FIFO_IN)) == -1)
				return (-1);
			break;
		default:
			goto abort;
		}

		tag  = bus_space_read_1(iot, ioh, TUL_SFIFO); /* Read Tag ID */
		pScb = &sc->HCS_Scb[tag];

		abortmsg = MSG_ABORT_TAG; /* Now that we have valdid tag! */
	}

	if ((pScb->SCB_Target != target)  
	    || (pScb->SCB_Lun != lun)
	    || (pScb->SCB_Status != STATUS_BUSY)) {
abort:
		iha_msgout_abort(sc, iot, ioh, abortmsg);
		return (-1);
	}

	sc->HCS_ActScb = pScb;

	if (iha_wait(sc, iot, ioh, MSG_ACCEPT) == -1)
		return (-1);

	return(iha_next_state(sc, iot, ioh));
}

int
iha_msgin(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	u_int16_t flags;
	u_int8_t msg;
	int phase;

	for (;;) {
		if ((bus_space_read_1(iot, ioh, TUL_SFIFOCNT) & FIFOC) > 0)
			bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);

		bus_space_write_4(iot, ioh, TUL_STCNT0, 1);

		phase = iha_wait(sc, iot, ioh, XF_FIFO_IN);
		msg   = bus_space_read_1(iot, ioh, TUL_SFIFO);

		switch (msg) {
		case MSG_DISCONNECT:
			sc->HCS_Flags |= FLAG_EXPECT_DISC;
			if (iha_wait(sc, iot, ioh, MSG_ACCEPT) != -1)
				iha_bad_seq(sc);
			phase = -1;
			break;
		case MSG_SAVEDATAPOINTER:
		case MSG_RESTOREPOINTERS:
		case MSG_NOOP:
			phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
			break;
		case MSG_MESSAGE_REJECT:
			/* XXX - need to clear FIFO like other 'Clear ATN'?*/
			iha_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
			flags = sc->HCS_ActScb->SCB_Tcs->TCS_Flags;
			if ((flags & FLAG_NO_NEG_SYNC) == 0)
				iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
			phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
			break;
		case MSG_EXTENDED:
			phase = iha_msgin_extended(sc, iot, ioh);
			break;
		case MSG_IGN_WIDE_RESIDUE:
			phase = iha_msgin_ignore_wid_resid(sc, iot, ioh);
			break;
		case MSG_CMDCOMPLETE:
			sc->HCS_Flags |= FLAG_EXPECT_DONE_DISC;
			bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);
			phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
			if (phase != -1) {
				iha_bad_seq(sc);
				return (-1);
			}
			break;
		default:
#ifdef IHA_DEBUG_STATE
			printf("[debug] iha_msgin: bad msg type: %d\n", msg);
#endif
			phase = iha_msgout_reject(sc, iot, ioh);
			break;
		}

		if (phase != PHASE_MSG_IN)
			return (phase);
	}
	/* NOTREACHED */
}

int
iha_msgin_ignore_wid_resid(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh)
{
	int phase;

	phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);

	if (phase == PHASE_MSG_IN) {
		phase = iha_wait(sc, iot, ioh, XF_FIFO_IN);

		if (phase != -1) {
			bus_space_write_1(iot, ioh, TUL_SFIFO, 0);
			bus_space_read_1 (iot, ioh, TUL_SFIFO);
			bus_space_read_1 (iot, ioh, TUL_SFIFO);

			phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
		}
	}

	return (phase);
}

int
iha_msgin_extended(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh)
{
	u_int16_t flags;
	int i, phase, msglen, msgcode;

	/* XXX - can we just stop reading and reject, or do we have to
	 *	 read all input, discarding the excess, and then reject
	 */
	for (i = 0; i < IHA_MAX_EXTENDED_MSG; i++) {
		phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);

		if (phase != PHASE_MSG_IN)
			return (phase);

		bus_space_write_4(iot, ioh, TUL_STCNT0, 1);

		if (iha_wait(sc, iot, ioh, XF_FIFO_IN) == -1)
			return (-1);

		sc->HCS_Msg[i] = bus_space_read_1(iot, ioh, TUL_SFIFO);

		if (sc->HCS_Msg[0] == i)
			break;
	}

	msglen	= sc->HCS_Msg[0];
	msgcode = sc->HCS_Msg[1];

	if ((msglen == MSG_EXT_SDTR_LEN) && (msgcode == MSG_EXT_SDTR)) {
		if (iha_msgin_sdtr(sc) == 0) {
			iha_sync_done(sc, iot, ioh);
			return (iha_wait(sc, iot, ioh, MSG_ACCEPT));
		}

		iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);

		phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
		if (phase != PHASE_MSG_OUT)
			return (phase);

		/* Clear FIFO for important message - final SYNC offer */
		bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);

		iha_sync_done(sc, iot, ioh); /* This is our final offer */

	} else if ((msglen == MSG_EXT_WDTR_LEN) && (msgcode == MSG_EXT_WDTR)) {

		flags = sc->HCS_ActScb->SCB_Tcs->TCS_Flags;

		if ((flags & FLAG_NO_WIDE) != 0)
			/* Offer 8 bit xfers only */
			sc->HCS_Msg[2] = MSG_EXT_WDTR_BUS_8_BIT;

		else if (sc->HCS_Msg[2] > MSG_EXT_WDTR_BUS_32_BIT)
			return (iha_msgout_reject(sc, iot, ioh));

		else if (sc->HCS_Msg[2] == MSG_EXT_WDTR_BUS_32_BIT)
			/* Offer 16 instead */
			sc->HCS_Msg[2] = MSG_EXT_WDTR_BUS_32_BIT;

		else {
			iha_wide_done(sc, iot, ioh);
			if ((flags & FLAG_NO_NEG_SYNC) == 0)
				iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
			return (iha_wait(sc, iot, ioh, MSG_ACCEPT));
		}

		iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);

		phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
		if (phase != PHASE_MSG_OUT)
			return (phase);

	} else
		return (iha_msgout_reject(sc, iot, ioh));

	/* Send message built in sc->HCS_Msg[] */
	return (iha_msgout_extended(sc, iot, ioh));
}

/*
 * iha_msgin_sdtr - check SDTR msg in HCS_Msg. If the offer is
 *                  acceptable leave HCS_Msg as is and return 0.
 *                  If the negotiation must continue, modify HCS_Msg
 *                  as needed and return 1. Else return 0.
 */
int
iha_msgin_sdtr(struct iha_softc *sc)
{
	u_int16_t flags;
	u_int8_t default_period;
	int newoffer;

	flags = sc->HCS_ActScb->SCB_Tcs->TCS_Flags;

	default_period = iha_rate_tbl[flags & FLAG_SCSI_RATE];

	if (sc->HCS_Msg[3] == 0) /* target offered async only. Accept it. */
		return (0);

	newoffer = 0;

	if ((flags & FLAG_NO_SYNC) != 0) {
		sc->HCS_Msg[3] = 0;
		newoffer   = 1;
	}

	if (sc->HCS_Msg[3] > IHA_MAX_TARGETS-1) {
		sc->HCS_Msg[3] = IHA_MAX_TARGETS-1;
		newoffer   = 1;
	}

	if (sc->HCS_Msg[2] < default_period) {
		sc->HCS_Msg[2] = default_period;
		newoffer   = 1;
	}

	if (sc->HCS_Msg[2] >= 59) {
		sc->HCS_Msg[3] = 0;
		newoffer   = 1;
	}

	return (newoffer);
}

int
iha_msgout(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh, u_int8_t msg)
{
	bus_space_write_1(iot, ioh, TUL_SFIFO, msg);

	return (iha_wait(sc, iot, ioh, XF_FIFO_OUT));
}

void
iha_msgout_abort(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh, u_int8_t aborttype)
{
	iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);

	switch (iha_wait(sc, iot, ioh, MSG_ACCEPT)) {
	case -1:
		break;

	case PHASE_MSG_OUT:
		sc->HCS_Flags |= FLAG_EXPECT_DISC;
		if (iha_msgout(sc, iot, ioh, aborttype) != -1)
			iha_bad_seq(sc);
		break;

	default:
		iha_bad_seq(sc);
		break;
	}
}

int
iha_msgout_reject(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh)
{
	iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);

	if (iha_wait(sc, iot, ioh, MSG_ACCEPT) == PHASE_MSG_OUT)
		return (iha_msgout(sc, iot, ioh, MSG_MESSAGE_REJECT));

	return (-1);
}

int
iha_msgout_extended(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh)
{
	int phase;

	bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXTENDED);

	bus_space_write_multi_1(iot, ioh, TUL_SFIFO, 
	    sc->HCS_Msg, sc->HCS_Msg[0]+1);

	phase = iha_wait(sc, iot, ioh, XF_FIFO_OUT);

	bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);
	iha_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);

	return (phase);
}

int
iha_msgout_wdtr(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh)
{
	sc->HCS_ActScb->SCB_Tcs->TCS_Flags |= FLAG_WIDE_DONE;

	sc->HCS_Msg[0] = MSG_EXT_WDTR_LEN;
	sc->HCS_Msg[1] = MSG_EXT_WDTR;
	sc->HCS_Msg[2] = MSG_EXT_WDTR_BUS_16_BIT;

	return (iha_msgout_extended(sc, iot, ioh));
}

int
iha_msgout_sdtr(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh)
{
	u_int16_t rateindex;
	u_int8_t sync_rate;

	rateindex = sc->HCS_ActScb->SCB_Tcs->TCS_Flags & FLAG_SCSI_RATE;

	sync_rate = iha_rate_tbl[rateindex];

	sc->HCS_Msg[0] = MSG_EXT_SDTR_LEN;
	sc->HCS_Msg[1] = MSG_EXT_SDTR;
	sc->HCS_Msg[2] = sync_rate;
	sc->HCS_Msg[3] = IHA_MAX_TARGETS-1; /* REQ/ACK */

	return (iha_msgout_extended(sc, iot, ioh));
}

void
iha_wide_done(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct tcs *pTcs = sc->HCS_ActScb->SCB_Tcs;

	pTcs->TCS_JS_Period = 0;

	if (sc->HCS_Msg[2] != 0)
		pTcs->TCS_JS_Period |= PERIOD_WIDE_SCSI;

	pTcs->TCS_SConfig0 &= ~ALTPD;
	pTcs->TCS_Flags	   &= ~FLAG_SYNC_DONE;
	pTcs->TCS_Flags	   |=  FLAG_WIDE_DONE;

	bus_space_write_1(iot, ioh, TUL_SCONFIG0, pTcs->TCS_SConfig0);
	bus_space_write_1(iot, ioh, TUL_SYNCM,	  pTcs->TCS_JS_Period);
}

void
iha_sync_done(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh)
{
	struct tcs *pTcs = sc->HCS_ActScb->SCB_Tcs;
	int i;

	if ((pTcs->TCS_Flags & FLAG_SYNC_DONE) == 0) {
		if (sc->HCS_Msg[3] != 0) {
			pTcs->TCS_JS_Period |= sc->HCS_Msg[3];

			/* pick the highest possible rate */
			for (i = 0; i < sizeof(iha_rate_tbl); i++)
				if (iha_rate_tbl[i] >= sc->HCS_Msg[2])
					break;

			pTcs->TCS_JS_Period |= (i << 4);
			pTcs->TCS_SConfig0  |= ALTPD;
		}

		pTcs->TCS_Flags |= FLAG_SYNC_DONE;

		bus_space_write_1(iot, ioh, TUL_SCONFIG0, pTcs->TCS_SConfig0);
		bus_space_write_1(iot, ioh, TUL_SYNCM,	  pTcs->TCS_JS_Period);
	}
}

void
iha_reset_chip(struct iha_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh)
{
	int i;

	/* reset tulip chip */

	bus_space_write_1(iot, ioh, TUL_SCTRL0, RSCSI);

	do
		sc->HCS_JSInt = bus_space_read_1(iot, ioh, TUL_SISTAT);
	while((sc->HCS_JSInt & SRSTD) == 0);

	iha_set_ssig(iot, ioh, 0, 0);

	/*
	 * Stall for 2 seconds, wait for target's firmware ready.
	 */
	for (i = 0; i < 2000; i++)
		DELAY (1000);

	bus_space_read_1(iot, ioh, TUL_SISTAT); /* Clear any active interrupt*/
}

void
iha_select(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh,
    struct iha_scb *pScb, u_int8_t select_type)
{
	int s;

	switch (select_type) {
	case SEL_ATN:
		bus_space_write_1(iot, ioh, TUL_SFIFO, pScb->SCB_Ident);
		bus_space_write_multi_1(iot, ioh, TUL_SFIFO,
		    pScb->SCB_CDB, pScb->SCB_CDBLen);

		pScb->SCB_NxtStat = 2;
		break;

	case SELATNSTOP:
		pScb->SCB_NxtStat = 1;
		break;

	case SEL_ATN3:
		bus_space_write_1(iot, ioh, TUL_SFIFO, pScb->SCB_Ident);
		bus_space_write_1(iot, ioh, TUL_SFIFO, pScb->SCB_TagMsg);
		bus_space_write_1(iot, ioh, TUL_SFIFO, pScb->SCB_TagId);

		bus_space_write_multi_1(iot, ioh, TUL_SFIFO, pScb->SCB_CDB,
		    pScb->SCB_CDBLen);

		pScb->SCB_NxtStat = 2;
		break;

	default:
#ifdef IHA_DEBUG_STATE
		sc_print_addr(pScb->SCB_Xs->sc_link);
		printf("[debug] iha_select() - unknown select type = 0x%02x\n",
		    select_type);
#endif
		return;
	}

	s = splbio();
	TAILQ_REMOVE(&sc->HCS_PendScb, pScb, SCB_ScbList);
	splx(s);

	pScb->SCB_Status = STATUS_SELECT;

	sc->HCS_ActScb = pScb;

	bus_space_write_1(iot, ioh, TUL_SCMD, select_type);
}

/*
 * iha_wait - wait for an interrupt to service or a SCSI bus phase change
 *            after writing the supplied command to the tulip chip. If 
 *            the command is NO_OP, skip the command writing.
 */
int
iha_wait(struct iha_softc *sc, bus_space_tag_t iot, bus_space_handle_t ioh,
    u_int8_t cmd)
{
	if (cmd != NO_OP)
		bus_space_write_1(iot, ioh, TUL_SCMD, cmd);

	/* 
	 * Have to do this here, in addition to in iha_isr, because
	 * interrupts might be turned off when we get here.
	 */
	do
		sc->HCS_JSStatus0 = bus_space_read_1(iot, ioh, TUL_STAT0);
	while ((sc->HCS_JSStatus0 & INTPD) == 0);

	sc->HCS_JSStatus1 = bus_space_read_1(iot, ioh, TUL_STAT1);
	sc->HCS_JSInt     = bus_space_read_1(iot, ioh, TUL_SISTAT);

	sc->HCS_Phase = sc->HCS_JSStatus0 & PH_MASK;

	if ((sc->HCS_JSInt & SRSTD) != 0) {
		/* SCSI bus reset interrupt */
		iha_reset_scsi_bus(sc);
		return (-1);
	}

	if ((sc->HCS_JSInt & RSELED) != 0)
		/* Reselection interrupt */
		return (iha_resel(sc, iot, ioh));

	if ((sc->HCS_JSInt & STIMEO) != 0) {
		/* selected/reselected timeout interrupt */
		iha_busfree(sc, iot, ioh);
		return (-1);
	}

	if ((sc->HCS_JSInt & DISCD) != 0) {
		/* BUS disconnection interrupt */
		if ((sc->HCS_Flags & FLAG_EXPECT_DONE_DISC) != 0) {
			bus_space_write_1(iot, ioh, TUL_SCTRL0,	  RSFIFO);
			bus_space_write_1(iot, ioh, TUL_SCONFIG0,
			    SCONFIG0DEFAULT);
			bus_space_write_1(iot, ioh, TUL_SCTRL1,	  EHRSL);
			iha_append_done_scb(sc, sc->HCS_ActScb, HOST_OK);
			sc->HCS_Flags &= ~FLAG_EXPECT_DONE_DISC;

		} else if ((sc->HCS_Flags & FLAG_EXPECT_DISC) != 0) {
			bus_space_write_1(iot, ioh, TUL_SCTRL0,	  RSFIFO);
			bus_space_write_1(iot, ioh, TUL_SCONFIG0,
			    SCONFIG0DEFAULT);
			bus_space_write_1(iot, ioh, TUL_SCTRL1,	  EHRSL);
			sc->HCS_ActScb = NULL;
			sc->HCS_Flags &= ~FLAG_EXPECT_DISC;

		} else
			iha_busfree(sc, iot, ioh);

		return (-1);
	}

	return (sc->HCS_Phase);
}

/*
 * iha_done_scb - We have a scb which has been processed by the
 *                adaptor, now we look to see how the operation went.
 */
void
iha_done_scb(struct iha_softc *sc, struct iha_scb *pScb)
{
	struct scsi_sense_data *s1, *s2;
	struct scsi_xfer *xs = pScb->SCB_Xs;

	if (xs != NULL) {
		timeout_del(&xs->stimeout);

		xs->status = pScb->SCB_TaStat;

		if ((pScb->SCB_Flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) != 0) {
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma,
				0, pScb->SCB_BufChars,
				((pScb->SCB_Flags & SCSI_DATA_IN) ? 
					BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
		}
		if ((pScb->SCB_Flags & FLAG_SG) != 0) {
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma,
				0, sizeof(pScb->SCB_SGList),
				BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_SGDma);
		}

		switch (pScb->SCB_HaStat) {
		case HOST_OK:
			switch (pScb->SCB_TaStat) {
			case SCSI_OK:
			case SCSI_COND_MET:
			case SCSI_INTERM:
			case SCSI_INTERM_COND_MET:
				xs->resid = pScb->SCB_BufCharsLeft;
				xs->error = XS_NOERROR;
				break;

			case SCSI_RESV_CONFLICT:
			case SCSI_BUSY:
			case SCSI_QUEUE_FULL:
				xs->error = XS_BUSY;
				break;

			case SCSI_TERMINATED:
			case SCSI_ACA_ACTIVE:
			case SCSI_CHECK:
				s1 = &pScb->SCB_ScsiSenseData;
				s2 = &xs->sense;
				*s2 = *s1;

				xs->error = XS_SENSE;
				break;

			default:
				xs->error = XS_DRIVER_STUFFUP;
				break;
			}
			break;

		case HOST_SEL_TOUT:
			xs->error = XS_SELTIMEOUT;
			break;

		case HOST_SCSI_RST:
		case HOST_DEV_RST:
			xs->error = XS_RESET;
			break;

		case HOST_SPERR:
			sc_print_addr(xs->sc_link);
			printf("SCSI Parity error detected\n");
			xs->error = XS_DRIVER_STUFFUP;
			break;

		case HOST_TIMED_OUT:
			xs->error = XS_TIMEOUT;
			break;

		case HOST_DO_DU:
		case HOST_BAD_PHAS:
		default:
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		scsi_done(xs);
	}
}

void
iha_timeout(void *arg)
{
	struct iha_scb *pScb = (struct iha_scb *)arg;
	struct scsi_xfer *xs = pScb->SCB_Xs;

	if (xs != NULL) {
		sc_print_addr(xs->sc_link);
		printf("SCSI OpCode 0x%02x timed out\n", xs->cmd->opcode);
		iha_abort_xs(xs->sc_link->adapter_softc, xs, HOST_TIMED_OUT);
	}
}

void
iha_exec_scb(struct iha_softc *sc, struct iha_scb *pScb)
{
	struct scsi_xfer *xs = pScb->SCB_Xs;
	bus_space_handle_t ioh;
	bus_space_tag_t iot;
	int s;

	s = splbio();

	if ((pScb->SCB_Flags & SCSI_POLL) == 0)
		timeout_add_msec(&xs->stimeout, xs->timeout);

	if (((pScb->SCB_Flags & SCSI_RESET) != 0)
	    || (pScb->SCB_CDB[0] == REQUEST_SENSE))
		iha_push_pend_scb(sc, pScb);   /* Insert SCB at head of Pend */
	else
		iha_append_pend_scb(sc, pScb); /* Append SCB to tail of Pend */

	/*
	 * Run through iha_main() to ensure something is active, if
	 * only this new SCB.
	 */
	if (sc->HCS_Semaph != SEMAPH_IN_MAIN) {
		iot = sc->sc_iot;
		ioh = sc->sc_ioh;

		bus_space_write_1(iot, ioh, TUL_IMSK, MASK_ALL);
		sc->HCS_Semaph = SEMAPH_IN_MAIN;

		splx(s);
		iha_main(sc, iot, ioh);
		s = splbio();

		sc->HCS_Semaph = ~SEMAPH_IN_MAIN;
		bus_space_write_1(iot, ioh, TUL_IMSK, (MASK_ALL & ~MSCMP));
	}

	splx(s);
}


/*
 * iha_set_ssig - read the current scsi signal mask, then write a new
 *		  one which turns off/on the specified signals.
 */
void
iha_set_ssig(bus_space_tag_t iot, bus_space_handle_t ioh, u_int8_t offsigs,
    u_int8_t onsigs)
{
	u_int8_t currsigs;

	currsigs = bus_space_read_1(iot, ioh, TUL_SSIGI);
	bus_space_write_1(iot, ioh, TUL_SSIGO, (currsigs & ~offsigs) | onsigs);
}

void
iha_print_info(struct iha_softc *sc, int target)
{
	u_int8_t period = sc->HCS_Tcs[target].TCS_JS_Period;
	u_int8_t config = sc->HCS_Tcs[target].TCS_SConfig0;
	int rate;

	printf("%s: target %d using %d bit ", sc->sc_dev.dv_xname, target,
		(period & PERIOD_WIDE_SCSI) ? 16 : 8);
 
	if ((period & PERIOD_SYOFS) == 0)
		printf("async ");
	else {
		rate = (period & PERIOD_SYXPD) >> 4;
		if ((config & ALTPD) == 0)
			rate = 100 + rate * 50;
		else
			rate =	50 + rate * 25;
		rate = 1000000000 / rate;
		printf("%d.%d MHz %d REQ/ACK offset ", rate / 1000000,
		    (rate % 1000000 + 99999) / 100000, period & PERIOD_SYOFS);
	}

	printf("xfers\n");
}


/*
 * iha_alloc_scbs - allocate and map the SCB's for the supplied iha_softc
 */
int
iha_alloc_scbs(struct iha_softc *sc)
{
	bus_dma_segment_t seg;
	int error, rseg;

	/*
	 * Allocate dma-safe memory for the SCB's
	 */
	if ((error = bus_dmamem_alloc(sc->sc_dmat,
		 sizeof(struct iha_scb)*IHA_MAX_SCB,
		 NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO))
	    != 0) {
		printf("%s: unable to allocate SCBs,"
		       " error = %d\n", sc->sc_dev.dv_xname, error);
		return (error);
	}
	if ((error = bus_dmamem_map(sc->sc_dmat,
		 &seg, rseg, sizeof(struct iha_scb)*IHA_MAX_SCB,
		 (caddr_t *)&sc->HCS_Scb, BUS_DMA_NOWAIT | BUS_DMA_COHERENT))
	    != 0) {
		printf("%s: unable to map SCBs, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}

	return (0);
}

/*
 * iha_read_eeprom - read contents of serial EEPROM into iha_nvram pointed at
 *                                        by parameter nvram.
 */
void
iha_read_eeprom(bus_space_tag_t iot, bus_space_handle_t ioh,
    struct iha_nvram *nvram)
{
	u_int32_t chksum;
	u_int16_t *np;
	u_int8_t gctrl, addr;

	const int chksum_addr = offsetof(struct iha_nvram, NVM_CheckSum) / 2;

	/* Enable EEProm programming */
	gctrl = bus_space_read_1(iot, ioh, TUL_GCTRL0) | EEPRG;
	bus_space_write_1(iot, ioh, TUL_GCTRL0, gctrl);

	/* Read EEProm */
	np = (u_int16_t *)nvram;
	for (addr=0, chksum=0; addr < chksum_addr; addr++, np++) {
		*np = iha_se2_rd(iot, ioh, addr);
		chksum += *np;
	}

	chksum &= 0x0000ffff;
	nvram->NVM_CheckSum = iha_se2_rd(iot, ioh, chksum_addr);

	/* Disable EEProm programming */
	gctrl = bus_space_read_1(iot, ioh, TUL_GCTRL0) & ~EEPRG;
	bus_space_write_1(iot, ioh, TUL_GCTRL0, gctrl);

	if ((nvram->NVM_Signature != SIGNATURE)
	    ||
	    (nvram->NVM_CheckSum  != chksum))
		panic("iha: invalid EEPROM,  bad signature or checksum");
}

/*
 * iha_se2_rd - read & return the 16 bit value at the specified
 *		offset in the Serial E2PROM
 *
 */
u_int16_t
iha_se2_rd(bus_space_tag_t iot, bus_space_handle_t ioh, u_int8_t addr)
{
	u_int16_t readWord;
	u_int8_t bit;
	int i;

	/* Send 'READ' instruction == address | READ bit */
	iha_se2_instr(iot, ioh, (addr | NVREAD));

	readWord = 0;
	for (i = 15; i >= 0; i--) {
		bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS | NVRCK);
		DELAY(5);

		bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS);
		DELAY(5);

		/* sample data after the following edge of clock     */
		bit = bus_space_read_1(iot, ioh, TUL_NVRAM) & NVRDI;
		DELAY(5);

		readWord += bit << i;
	}

	bus_space_write_1(iot, ioh, TUL_NVRAM, 0);
	DELAY(5);

	return (readWord);
}

/*
 * iha_se2_instr - write an octet to serial E2PROM one bit at a time
 */
void
iha_se2_instr(bus_space_tag_t iot, bus_space_handle_t ioh, u_int8_t instr)
{
	u_int8_t b;
	int i;

	b = NVRCS | NVRDO; /* Write the start bit (== 1) */

	bus_space_write_1(iot, ioh, TUL_NVRAM, b);
	DELAY(5);
	bus_space_write_1(iot, ioh, TUL_NVRAM, b | NVRCK);
	DELAY(5);

	for (i = 0; i < 8; i++, instr <<= 1) {
		if (instr & 0x80)
			b = NVRCS | NVRDO; /* Write a 1 bit */
		else
			b = NVRCS;	   /* Write a 0 bit */

		bus_space_write_1(iot, ioh, TUL_NVRAM, b);
		DELAY(5);
		bus_space_write_1(iot, ioh, TUL_NVRAM, b | NVRCK);
		DELAY(5);
	}

	bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS);
	DELAY(5);

	return;
}

/*
 * iha_reset_tcs - reset the target control structure pointed
 *		   to by pTcs to default values. TCS_Flags
 *		   only has the negotiation done bits reset as
 *		   the other bits are fixed at initialization.
 */
void
iha_reset_tcs(struct tcs *pTcs, u_int8_t config0)
{
	pTcs->TCS_Flags	    &= ~(FLAG_SYNC_DONE | FLAG_WIDE_DONE);
	pTcs->TCS_JS_Period  = 0;
	pTcs->TCS_SConfig0   = config0;
	pTcs->TCS_TagCnt     = 0;
	pTcs->TCS_NonTagScb  = NULL;
}
@


1.42
log
@Close races where timer is started on a command and then an splbio()
is called before the command is started. This might have resulted
in the timeout firing and invalidating the command before it is
started. Move the timeout_add_* inside the relevant splbio()/splx().

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.41 2012/01/11 16:22:33 dhill Exp $ */
a36 1
#include <sys/kernel.h>
@


1.41
log
@ansify and de'register some prototypes

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.40 2010/10/03 21:14:40 krw Exp $ */
a324 2
	if ((pScb->SCB_Flags & SCSI_POLL) == 0)
		timeout_add_msec(&xs->stimeout, xs->timeout);
d2445 1
d2451 3
@


1.40
log
@iopoolification. Tested on my Initio INIC-950. Various eyes including
miod@@, oga@@, dlg@@, matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.39 2010/06/28 18:31:02 krw Exp $ */
d172 1
a172 2
iha_intr(arg)
	void *arg;
d209 1
a209 3
iha_setup_sg_list(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
d253 1
a253 2
iha_scsi_cmd(xs)
	struct scsi_xfer *xs;
d336 1
a336 2
iha_init_tulip(sc)
	struct iha_softc *sc;
d470 1
a470 3
iha_reset_dma(iot, ioh)
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d487 1
a487 2
iha_scb_alloc(xsc)
	void *xsc;
d550 1
a550 3
iha_append_pend_scb(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
d563 1
a563 3
iha_push_pend_scb(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
d586 1
a586 2
iha_find_pend_scb(sc)
	struct iha_softc *sc;
d640 1
a640 2
iha_mark_busy_scb(pScb)
	struct iha_scb *pScb;
d657 1
a657 4
iha_append_done_scb(sc, pScb, hastat)
	struct iha_softc *sc;
	struct iha_scb *pScb;
	u_int8_t hastat;
d687 1
a687 2
iha_pop_done_scb(sc)
	struct iha_softc *sc;
d712 1
a712 4
iha_abort_xs(sc, xs, hastat)
	struct iha_softc *sc;
	struct scsi_xfer *xs;
	u_int8_t hastat;
d758 1
a758 2
iha_bad_seq(sc)
	struct iha_softc *sc;
d775 1
a775 3
iha_push_sense_request(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
d854 1
a854 4
iha_main(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d913 1
a913 4
iha_scsi(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1024 1
a1024 2
iha_data_over_run(pScb)
	struct iha_scb *pScb;
d1078 2
a1079 4
iha_next_state(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1150 1
a1150 4
iha_state_1(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1208 1
a1208 4
iha_state_2(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1232 1
a1232 4
iha_state_3(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1288 1
a1288 4
iha_state_4(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1348 1
a1348 4
iha_state_5(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1446 1
a1446 4
iha_state_6(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1486 1
a1486 4
iha_state_8(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1533 2
a1534 5
iha_xfer_data(pScb, iot, ioh, direction)
	struct iha_scb *pScb;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
	int direction;
d1571 1
a1571 4
iha_xpad_in(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1600 1
a1600 4
iha_xpad_out(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1632 2
a1633 4
iha_status_msg(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1703 1
a1703 4
iha_busfree(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1725 1
a1725 2
iha_reset_scsi_bus(sc)
	struct iha_softc *sc;
d1759 1
a1759 4
iha_resel(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1766 1
a1766 1
		if ((sc->HCS_ActScb->SCB_Status == STATUS_SELECT))
d1845 1
a1845 4
iha_msgin(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1910 2
a1911 4
iha_msgin_ignore_wid_resid(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d1933 2
a1934 4
iha_msgin_extended(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d2021 1
a2021 2
iha_msgin_sdtr(sc)
	struct iha_softc *sc;
d2060 2
a2061 5
iha_msgout(sc, iot, ioh, msg)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
	u_int8_t   msg;
d2069 2
a2070 5
iha_msgout_abort(sc, iot, ioh,	aborttype)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
	u_int8_t	   aborttype;
d2091 2
a2092 4
iha_msgout_reject(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d2103 2
a2104 4
iha_msgout_extended(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d2122 2
a2123 4
iha_msgout_wdtr(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d2135 2
a2136 4
iha_msgout_sdtr(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d2154 1
a2154 4
iha_wide_done(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d2172 1
a2172 4
iha_sync_done(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d2198 2
a2199 4
iha_reset_chip(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
d2223 2
a2224 6
iha_select(sc, iot, ioh, pScb, select_type)
	struct iha_softc   *sc;
	bus_space_tag_t	    iot;
	bus_space_handle_t  ioh;
	struct iha_scb *pScb;
	u_int8_t	select_type;
d2278 2
a2279 5
iha_wait(sc, iot, ioh, cmd)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
	u_int8_t	   cmd;
d2345 1
a2345 3
iha_done_scb(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
d2432 1
a2432 2
iha_timeout(arg)
	void *arg;
d2445 1
a2445 3
iha_exec_scb(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
d2487 2
a2488 4
iha_set_ssig( iot, ioh, offsigs, onsigs)
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
	u_int8_t	   offsigs, onsigs;
d2497 1
a2497 3
iha_print_info(sc, target)
	struct iha_softc *sc;
	int target;
d2527 1
a2527 2
iha_alloc_scbs(sc)
	struct iha_softc *sc;
d2560 2
a2561 4
iha_read_eeprom(iot, ioh, nvram)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct iha_nvram *nvram;
d2599 1
a2599 4
iha_se2_rd(iot, ioh, addr)
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
	u_int8_t	   addr;
d2633 1
a2633 4
iha_se2_instr(iot, ioh, instr)
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
	u_int8_t	   instr;
d2670 1
a2670 3
iha_reset_tcs(pTcs, config0)
	struct tcs *pTcs;
	u_int8_t config0;
@


1.39
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.38 2010/05/20 00:55:17 krw Exp $ */
d102 2
a103 2
void iha_append_free_scb(struct iha_softc *, struct iha_scb *);
struct iha_scb *iha_pop_free_scb(struct iha_softc *);
d270 1
a270 6
	pScb = iha_pop_free_scb(sc);
	if (pScb == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
a303 2
			iha_append_free_scb(sc, pScb); 

d357 7
d372 1
a380 4
	TAILQ_INIT(&sc->HCS_FreeScb);
	TAILQ_INIT(&sc->HCS_PendScb);
	TAILQ_INIT(&sc->HCS_DoneScb);

d491 1
a491 1
 * iha_pop_free_scb - return the first free SCB, or NULL if there are none.
d493 3
a495 3
struct iha_scb *
iha_pop_free_scb(sc)
	struct iha_softc *sc;
d497 1
a498 3
	int s;

	s = splbio();
d500 1
a501 1

d506 1
a506 2

	splx(s);
d512 3
a514 3
 * iha_append_free_scb - append the supplied SCB to the tail of the
 *                       HCS_FreeScb queue after clearing and resetting
 *			 everything possible.
d517 1
a517 3
iha_append_free_scb(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
d519 2
a523 1

d526 1
d552 1
d554 1
a554 2

	splx(s);
a2537 1

a2539 2
	
	iha_append_free_scb(sc, pScb);
@


1.38
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.37 2010/05/19 15:27:35 oga Exp $ */
a62 7
struct scsi_device iha_dev = {
	NULL,		/* Use default error handler    */
	NULL,		/* have a queue, served by this */
	NULL,		/* have no async handler	*/
	NULL,		/* Use default 'done' routine   */
};

a368 1
	sc->sc_link.device	     = &iha_dev;
@


1.37
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.36 2010/03/23 01:57:19 krw Exp $ */
d269 1
a269 1
	int s, error;
a272 1
		s = splbio();
a273 1
		splx(s);
a279 1
		s = splbio();
a280 1
		splx(s);
a318 1
			s = splbio();
a319 1
			splx(s);
a330 1
			s = splbio();
a331 1
			splx(s);
a2473 1
	int s;
a2552 1
		s = splbio();
a2553 1
		splx(s);
@


1.36
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.35 2010/01/10 00:10:23 krw Exp $ */
d2684 1
a2684 1
		 NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT))
a2697 1
	bzero(sc->HCS_Scb, sizeof(struct iha_scb)*IHA_MAX_SCB);
@


1.35
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.34 2009/09/04 04:57:14 miod Exp $ */
d262 1
a262 1
int
d276 1
a276 1
		return (COMPLETE);
d281 5
a285 3
		/* XXX - different xs->error/return if
		 * SCSI_POLL/_NOSLEEP? */
		return (NO_CCB);
d326 1
a326 1
			return (COMPLETE);
d340 1
a340 1
			return (COMPLETE);
a354 5

	if (xs->flags & (SCSI_POLL | ITSDONE))
		return (COMPLETE);
	else
		return (SUCCESSFULLY_QUEUED);
@


1.34
log
@Missing scsi_done() in some error path returning COMPLETE; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.33 2009/02/16 21:19:06 miod Exp $ */
a272 1
		xs->flags |= ITSDONE;
a320 1
			xs->flags |= ITSDONE;
a334 1
			xs->flags |= ITSDONE;
a2564 1
		xs->flags |= ITSDONE;
@


1.33
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.32 2009/01/21 21:54:00 grange Exp $ */
d269 1
a269 1
	int error;
d273 4
d322 4
d337 4
@


1.32
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.31 2008/11/24 00:31:35 krw Exp $ */
d476 1
a476 2
iha_minphys(bp)
	struct buf *bp;
@


1.31
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.30 2008/09/12 11:14:04 miod Exp $ */
d341 1
a341 1
		timeout_add(&xs->stimeout, (xs->timeout/1000) * hz);
d880 2
a881 2
		timeout_add(&pScb->SCB_Xs->stimeout,
		    (pScb->SCB_Xs->timeout/1000) * hz);
@


1.30
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.29 2007/12/29 03:04:19 dlg Exp $ */
d280 1
a280 1
		return (TRY_AGAIN_LATER);
@


1.29
log
@fix comments after the members of scsi_adapter were changed.

prompted by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.28 2007/11/05 00:21:36 krw Exp $ */
d301 4
a304 12
#ifdef TFS
		if (pScb->SCB_Flags & SCSI_DATA_UIO)
			error = bus_dmamap_load_uio(sc->sc_dmat,
			    pScb->SCB_DataDma, (struct uio *)xs->data,
			    (pScb->SCB_Flags & SCSI_NOSLEEP) ?
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		else
#endif /* TFS */
			error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_DataDma,
			    xs->data, pScb->SCB_BufChars, NULL,
			    (pScb->SCB_Flags & SCSI_NOSLEEP) ?
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
@


1.28
log
@Take a bit more care to ensure that SCSI_POLL commands always return
COMPLETE and never SUCCESSFULLY_QUEUED.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.27 2007/10/18 20:28:26 otto Exp $ */
d57 4
a60 4
	iha_scsi_cmd,	/*  int (*scsi_cmd)(struct scsi_xfer *); */
	iha_minphys,	/* void (*scsi_minphys)(struct buf *);   */
	NULL,		/*  int (*open_target_lu)(void);         */
	NULL		/*  int (*close_target_lu)(void);        */
@


1.27
log
@avoid splassert, caused by the fact that iha_main() is called
unprotected by iha_exec_scb(). With help and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.26 2007/04/10 17:47:55 miod Exp $ */
d353 3
a355 1
	if ((xs->flags & ITSDONE) == 0)
a356 2
	else
		return (COMPLETE);
@


1.26
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.25 2005/12/03 16:53:16 krw Exp $ */
d2485 1
d2566 1
d2568 1
@


1.25
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.24 2005/11/05 03:13:29 krw Exp $ */
d1130 1
a1130 1
 * iha_next_state - process the current SCB as requested in it's 
@


1.24
log
@Don't tempt fate by TAILQ_REMOVE()'ing inside TAILQ_FOREACH(), even if
we currently return immediately after the remove. Use for() idiom
instead of TAILQ_FOREACH. Make clear we are doing a TAILQ_REMOVE() by
eliminating wrapper function.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.23 2004/01/19 00:44:32 krw Exp $ */
a279 1
		xs->error = XS_BUSY;
@


1.23
log
@Rename a few defines to avoid namespace pollution. The only one used was 'READ' which is now 'NVREAD'.

Potential conflict with SCSI 'READ' spotted by tdeval@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.22 2003/10/21 18:58:49 jmc Exp $ */
a115 1
void iha_del_pend_scb(struct iha_softc *, struct iha_scb *);
a677 17
/*
 * iha_del_pend_scb - remove pScb from HCS_PendScb
 */
void
iha_del_pend_scb(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
{
	int s;

	s = splbio();

	TAILQ_REMOVE(&sc->HCS_PendScb, pScb, SCB_ScbList);

	splx(s);
}

d761 1
a761 1
	struct iha_scb *pScb;
d768 2
a769 1
	TAILQ_FOREACH(pScb, &sc->HCS_PendScb, SCB_ScbList)
d771 1
a771 1
			iha_del_pend_scb(sc, pScb);
d776 1
d2358 2
d2393 4
a2396 1
	iha_del_pend_scb(sc, pScb);
@


1.22
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.21 2003/03/30 00:32:48 krw Exp $ */
d2772 1
a2772 1
	iha_se2_instr(iot, ioh, (addr | READ));
@


1.21
log
@As long as I am here pull in some useful changes from NetBSD.

1) Eliminate some magic numbers.
2) Eliminate some double semi-colons.
3) Rename iha_scsi_req_q to iha_scb.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.20 2003/03/29 23:28:49 krw Exp $ */
d1123 1
a1123 1
	case 0x5e: /* Persistant Reserve In           SPC-2 */
d1147 1
a1147 1
 * iha_next_state - prcess the current SCB as requested in it's 
@


1.20
log
@A few final (I hope) tweaks to the dma fixes.

1) Return XS_DRIVER_STUFFUP if request sense cannot be loaded.

2) Try to avoid bus_dmamap_unload()'ing maps that have already been
unloaded.

3) Try to avoid bus_dmamap_load()'ing maps that are loaded.

4) Be extra paranoid and ensure bus_dmamap_sync()'s are done before
a bus_dmamap_unload().
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.19 2003/03/29 17:52:01 krw Exp $ */
d74 1
a74 1
static const u_int8_t iha_rate_tbl[8] = {
d87 3
a89 3
int iha_setup_sg_list(struct iha_softc *, struct iha_scsi_req_q *);
u_int8_t iha_data_over_run(struct iha_scsi_req_q *);
int iha_push_sense_request(struct iha_softc *, struct iha_scsi_req_q *);
d102 2
a103 2
void iha_done_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_exec_scb(struct iha_softc *, struct iha_scsi_req_q *);
d108 4
a111 4
void iha_mark_busy_scb(struct iha_scsi_req_q *);
void iha_append_free_scb(struct iha_softc *, struct iha_scsi_req_q *);
struct iha_scsi_req_q *iha_pop_free_scb(struct iha_softc *);
void iha_append_done_scb(struct iha_softc *, struct iha_scsi_req_q *,
d113 5
a117 5
struct iha_scsi_req_q *iha_pop_done_scb(struct iha_softc *);
void iha_append_pend_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_push_pend_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_del_pend_scb(struct iha_softc *, struct iha_scsi_req_q *);
struct iha_scsi_req_q *iha_find_pend_scb(struct iha_softc *);
d145 1
a145 1
int  iha_xfer_data(struct iha_scsi_req_q *,
d170 1
a170 1
			struct iha_scsi_req_q *, u_int8_t);
d220 1
a220 1
	struct iha_scsi_req_q *pScb;
d267 1
a267 1
	struct iha_scsi_req_q *pScb;
d369 1
a369 1
	struct iha_scsi_req_q *pScb;
d517 1
a517 1
struct iha_scsi_req_q *
d521 1
a521 1
	struct iha_scsi_req_q *pScb;
d546 1
a546 1
	struct iha_scsi_req_q *pScb;
d587 1
a587 1
	struct iha_scsi_req_q *pScb;
d602 1
a602 1
	struct iha_scsi_req_q *pScb;
d624 1
a624 1
struct iha_scsi_req_q *
d628 1
a628 1
	struct iha_scsi_req_q *pScb;
d685 1
a685 1
	struct iha_scsi_req_q *pScb;
d698 1
a698 1
	struct iha_scsi_req_q *pScb;
d717 1
a717 1
	struct iha_scsi_req_q *pScb;
d747 1
a747 1
struct iha_scsi_req_q *
d751 1
a751 1
	struct iha_scsi_req_q *pScb;
d779 1
a779 1
	struct iha_scsi_req_q *pScb;
d824 1
a824 1
	struct iha_scsi_req_q *pScb = sc->HCS_ActScb;
d841 1
a841 1
	struct iha_scsi_req_q *pScb;
d925 1
a925 1
	struct iha_scsi_req_q *pScb;
d987 1
a987 1
	struct iha_scsi_req_q *pScb;
d1097 1
a1097 1
	struct iha_scsi_req_q *pScb;
d1230 1
a1230 1
	struct iha_scsi_req_q *pScb = sc->HCS_ActScb;
d1291 1
a1291 1
	struct iha_scsi_req_q *pScb = sc->HCS_ActScb;
d1318 1
a1318 1
	struct iha_scsi_req_q *pScb = sc->HCS_ActScb;
d1377 1
a1377 1
	struct iha_scsi_req_q *pScb = sc->HCS_ActScb;
d1440 1
a1440 1
	struct iha_scsi_req_q *pScb = sc->HCS_ActScb;
d1584 1
a1584 1
	struct iha_scsi_req_q *pScb;
d1630 1
a1630 1
	struct iha_scsi_req_q *pScb;
d1675 1
a1675 1
	struct iha_scsi_req_q *pScb = sc->HCS_ActScb;
d1707 1
a1707 1
	struct iha_scsi_req_q *pScb = sc->HCS_ActScb;
d1742 1
a1742 1
	struct iha_scsi_req_q *pScb;
d1815 1
a1815 1
	struct iha_scsi_req_q *pScb;
d1838 1
a1838 1
	struct iha_scsi_req_q *pScb;
d1875 1
a1875 1
	struct iha_scsi_req_q *pScb;
d2105 2
a2106 1
			sc->HCS_Msg[2] = 0;	/* Offer async xfers only    */
d2108 1
a2108 1
		else if (sc->HCS_Msg[2] > 2)	/* BAD MSG: 2 is max  value  */
d2111 3
a2113 2
		else if (sc->HCS_Msg[2] == 2)	/* a request for 32 bit xfers*/
			sc->HCS_Msg[2] = 1;	/* Offer 16 instead	     */
d2324 1
a2324 1
			for (i = 0; i < 8; i++)
d2371 1
a2371 1
	struct iha_scsi_req_q *pScb;
d2493 1
a2493 1
	struct iha_scsi_req_q *pScb;
d2587 1
a2587 1
	struct iha_scsi_req_q *pScb = (struct iha_scsi_req_q *)arg;
d2600 1
a2600 1
	struct iha_scsi_req_q *pScb;
d2623 1
a2623 1
		sc->HCS_Semaph = SEMAPH_IN_MAIN;;
d2629 1
a2629 1
		sc->HCS_Semaph = ~SEMAPH_IN_MAIN;;
d2696 1
a2696 1
		 sizeof(struct iha_scsi_req_q)*IHA_MAX_SCB,
d2704 1
a2704 1
		 &seg, rseg, sizeof(struct iha_scsi_req_q)*IHA_MAX_SCB,
d2711 1
a2711 1
	bzero(sc->HCS_Scb, sizeof(struct iha_scsi_req_q)*IHA_MAX_SCB);
@


1.19
log
@Another chunk of bus_dma fixes. May actually approach correctness now.

1) Actually map and sync scatter gather list that is also DMA'd.

2) Actually map and sync request sense buffer.

3) Actually POSTREAD/WRITE sync data buffer after I/O, rather than
skipping it because the I/O was successful and no chars were left to
xfer.

4) Eliminate extra fields, clarify some names, reorder fields to
clarify their use.

5) Put common scatter gather preparation logic into separate function.

6) If insertion of request sense command fails, complete active
command with XS_SENSE, but zero'd sense data.

7) Eliminate physical address arithmetic as much as possible,
centralizing remaining manipulations in code actually sending
addresses to adapter.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.18 2003/03/29 02:34:17 krw Exp $ */
a225 3
		pScb->SCB_Flags	|= FLAG_SG;
		bzero(pScb->SCB_SGList, sizeof(pScb->SCB_SGList));

d236 7
d330 4
a341 4
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma, 
			0, pScb->SCB_BufChars,
			(pScb->SCB_Flags & SCSI_DATA_IN) ?
				BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
d846 18
a863 2
	pScb->SCB_Flags &= SCSI_POLL | SCSI_NOSLEEP;
	pScb->SCB_Flags |= FLAG_RSENS | SCSI_DATA_IN;
d878 1
a878 1
		return (1);
d880 6
d888 1
a888 2
	if (error) {
		bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
a889 6
	}

	bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma, 
		0, pScb->SCB_BufChars,
		(pScb->SCB_Flags & SCSI_DATA_IN) ?
			BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
d943 4
a946 1
				else if (iha_push_sense_request(sc, pScb) == 0)
@


1.18
log
@Use sc_print_addr() where possible to improve messages.

Put debug messages in #ifdef sections.

Eliminate a less than useful error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.17 2003/03/28 00:16:12 krw Exp $ */
d87 1
d89 1
a89 1
void iha_push_sense_request(struct iha_softc *, struct iha_scsi_req_q *);
d214 41
a263 1
	struct iha_sg_element *sg;
d266 1
a266 2
	bus_dmamap_t dm;
	int error, nseg, i;
d296 1
a296 1
	pScb->SCB_BufLen = xs->datalen;
d298 1
a298 1
	if (pScb->SCB_BufLen > 0) {
d302 1
a302 1
			    pScb->SCB_Dmamap, (struct uio *)xs->data,
d307 2
a308 2
			error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_Dmamap,
			    xs->data, pScb->SCB_BufLen, NULL,
d327 6
a332 17
		dm   = pScb->SCB_Dmamap;
		nseg = dm->dm_nsegs;

		if (nseg > 1) {
			sg = pScb->SCB_SGList;

			for (i=0; i < nseg; i++) {
				sg[i].SG_Len = dm->dm_segs[i].ds_len;
				sg[i].SG_Ptr = dm->dm_segs[i].ds_addr;
			}

			pScb->SCB_Flags	  |= FLAG_SG;
			pScb->SCB_SGLen	   = nseg;

			pScb->SCB_BufPAddr = pScb->SCB_SGPAddr;
		} else
			pScb->SCB_BufPAddr = dm->dm_segs[0].ds_addr;
d334 4
a337 4
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap, 
		    0, pScb->SCB_Dmamap->dm_mapsize,
		    (pScb->SCB_Flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
a339 3
	pScb->SCB_SGMax	  = pScb->SCB_SGLen;
	pScb->SCB_Timeout = xs->timeout;

a405 8
		pScb->SCB_SGPAddr = sc->sc_dmamap->dm_segs[0].ds_addr
		    + i*sizeof(struct iha_scsi_req_q)
		    + offsetof(struct iha_scsi_req_q, SCB_SGList);

		pScb->SCB_SenseLen   = sizeof(struct scsi_sense_data);
		pScb->SCB_SensePAddr = sc->sc_dmamap->dm_segs[0].ds_addr
		    + i*sizeof(struct iha_scsi_req_q)
		    + offsetof(struct iha_scsi_req_q, SCB_ScsiSenseData);
d410 1
a410 1
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &pScb->SCB_Dmamap);
d413 1
a413 1
			printf("%s: couldn't create SCB DMA map, error = %d\n",
d417 12
d551 3
a553 3
	pScb->SCB_Status  = STATUS_QUEUED;
	pScb->SCB_HaStat  = HOST_OK;
	pScb->SCB_TaStat  = SCSI_OK;
a555 2
	pScb->SCB_SGIdx	   = 0;
	pScb->SCB_SGMax	   = 0;
a558 2
	pScb->SCB_BufLen   = 0;
	pScb->SCB_SGLen	   = 0;
d562 3
a564 2
	pScb->SCB_Timeout  = 0;
	pScb->SCB_BufPAddr = 0;
d569 1
a569 3
	bzero( pScb->SCB_CDB,		sizeof(pScb->SCB_CDB));
	bzero(&pScb->SCB_ScsiSenseData, sizeof(pScb->SCB_ScsiSenseData));
	bzero( pScb->SCB_SGList,	sizeof(pScb->SCB_SGList));
d572 1
a572 3
	 * SCB_TagId, SCB_SGPAddr, SCB_SenseLen, SCB_SGList
	 * SCB_SensePtr are set at initialization
	 * and never change
d834 1
a834 1
void
d840 1
d842 6
a847 2
	pScb->SCB_BufLen   = pScb->SCB_SenseLen;
	pScb->SCB_BufPAddr = pScb->SCB_SensePAddr;
d849 22
a870 2
	pScb->SCB_Flags &= SCSI_POLL;
	pScb->SCB_Flags |= FLAG_RSENS | SCSI_DATA_IN;
a877 1
	bzero(&pScb->SCB_ScsiSenseData, sizeof(pScb->SCB_ScsiSenseData)); 
d887 1
a887 1
		    (pScb->SCB_Timeout/1000) * hz);
d890 2
d924 2
a925 3

				else {
					iha_push_sense_request(sc, pScb);
a926 1
				}
d968 1
d1037 1
a1037 1
		for (; pScb->SCB_Timeout > 0; pScb->SCB_Timeout--) {
d1052 1
a1052 1
		if (pScb->SCB_Timeout == 0)
d1064 1
a1064 1
 * iha_data_over_run - return HOST_OK for all SCSI opcodes where BufLen
d1361 1
a1361 1
		if (pScb->SCB_BufLen == 0)
d1380 1
a1380 1
				pScb->SCB_BufLen = 0;
a1423 1
	int i;
d1472 1
a1472 1
		pScb->SCB_BufLen = 0;
d1478 5
a1482 2
	xcnt		 = pScb->SCB_BufLen - cnt; /* xcnt == bytes xferred */
	pScb->SCB_BufLen = cnt;			   /* cnt  == bytes left    */
d1486 1
a1486 1
		for (i = pScb->SCB_SGIdx; i < pScb->SCB_SGMax; pSg++, i++) {
d1491 1
a1491 1
				pSg->SG_Ptr += xcnt;
d1494 3
a1496 4
				pScb->SCB_BufPAddr += (i - pScb->SCB_SGIdx)
					* sizeof(struct iha_sg_element);
				pScb->SCB_SGLen	  = pScb->SCB_SGMax - i;
				pScb->SCB_SGIdx	  = i;
d1503 1
a1503 2
	} else
		pScb->SCB_BufPAddr += xcnt;
d1613 1
a1613 1
	u_int32_t xferlen;
d1619 1
a1619 1
	bus_space_write_4(iot, ioh, TUL_STCNT0, pScb->SCB_BufLen);
d1622 3
a1624 1
		xferlen  = pScb->SCB_BufLen;
d1628 4
a1631 1
		xferlen  = pScb->SCB_SGLen * sizeof(struct iha_sg_element);
d1636 1
a1636 1
	bus_space_write_4(iot, ioh, TUL_DXPA, pScb->SCB_BufPAddr);
d2479 12
a2490 6
		if (pScb->SCB_BufLen > 0) {
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap,
			    0, pScb->SCB_Dmamap->dm_mapsize,
			    ((pScb->SCB_Flags & SCSI_DATA_IN) ? 
				BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_Dmamap);
d2500 1
a2500 1
				xs->resid = pScb->SCB_BufLen;
a2686 22

	/*
	 * Create and load the DMA map used for the SCBs
	 */
	if ((error = bus_dmamap_create(sc->sc_dmat,
		 sizeof(struct iha_scsi_req_q)*IHA_MAX_SCB,
		 1, sizeof(struct iha_scsi_req_q)*IHA_MAX_SCB,
		 0, BUS_DMA_NOWAIT, &sc->sc_dmamap))
	    != 0) {
		printf("%s: unable to create control DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap,
		 sc->HCS_Scb, sizeof(struct iha_scsi_req_q)*IHA_MAX_SCB,
		 NULL, BUS_DMA_NOWAIT))
	    != 0) {
		printf("%s: unable to load control DMA map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}

@


1.17
log
@Fix REQUEST SENSE handling based on lessons learned struggling with
osiop.

1) bus_dmamap_sync(POSTREAD) the request sense buffer *before* copying
it to xs->sense.

2) Always terminate timeout on completion of command, starting new one
for any REQUEST SENSE that is issued for non-polling commands.

3) Use pScb->SCB_Flags rather than xs->flags to ensure correct flags
are used during REQUEST_SENSE processing.

4) bzero() sense buffer before reading data into it.

This fixes a long standing problem where my Yamaha SCSI CD reported
bogus errors during probe.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.16 2002/11/14 02:31:46 krw Exp $ */
d50 2
d273 1
d275 2
a276 2
				printf("%s: buffer needs >%d dma segments\n",
				    sc->sc_dev.dv_xname, IHA_MAX_SG_ENTRIES);
d278 2
a279 2
				printf("%s: error %d loading dma map\n",
				    sc->sc_dev.dv_xname, error);
d1137 1
d1285 2
d1288 1
d1938 1
d1940 1
d2322 2
d2326 1
d2477 2
a2478 2
			printf("%s: SCSI Parity error detected\n",
			    sc->sc_dev.dv_xname);
a2505 1
	struct iha_softc *sc;
d2507 1
a2507 5
	if (xs == NULL)
		printf("[debug] iha_timeout called with xs == NULL\n");

	else {
		sc = xs->sc_link->adapter_softc;
a2509 1

d2580 2
a2581 2
	    (period & PERIOD_WIDE_SCSI) ? 16 : 8);

d2594 1
a2594 1
	
@


1.16
log
@Rework iha copyight verbiage to make clear what needs to be clear for
it to remain in the tree. With agreement of Initio.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.15 2002/10/09 23:43:11 krw Exp $ */
d258 1
a258 1
		if (xs->flags & SCSI_DATA_UIO)
d261 1
a261 1
			    (xs->flags & SCSI_NOSLEEP) ?
d267 1
a267 1
			    (xs->flags & SCSI_NOSLEEP) ?
d317 1
a317 1
	if ((xs->flags & SCSI_POLL) == 0)
d813 2
d818 1
a818 1
	pScb->SCB_Flags &= ~(FLAG_SG | FLAG_DIR);
d827 1
d829 5
a833 3
	pScb->SCB_CDBLen = 6;
	pScb->SCB_CDB[0] = REQUEST_SENSE;
	pScb->SCB_CDB[4] = pScb->SCB_SenseLen;
d2410 2
d2414 8
a2480 9
		if (xs->datalen > 0) {
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap,
			    0, pScb->SCB_Dmamap->dm_mapsize,
			    ((xs->flags & SCSI_DATA_IN) ? 
				BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_Dmamap);
		}

		timeout_del(&xs->stimeout);
@


1.15
log
@Remove trailing '\n's from panic messages.

Started by a commit to siop from provos@@netbsd.org.

ok miod@@ millert@@
@
text
@d1 2
a2 3
/*	$OpenBSD: iha.c,v 1.14 2002/06/09 02:11:47 jsyn Exp $ */
/*
 * Initio INI-9xxxU/UW SCSI Device Driver
d4 7
a10 2
 * Copyright (c) 2000-2001 Ken Westerback
 * All rights reserved.
a31 13
 *
 *-------------------------------------------------------------------------
 *
 * Ported from i91u.c, provided by Initio Corporation, which credits:
 *
 * Device driver for the INI-9XXXU/UW or INIC-940/950  PCI SCSI Controller.
 *
 * FreeBSD
 *
 *  Written for 386bsd and FreeBSD by
 *	Winston Hung		<winstonh@@initio.com>
 *
 * Copyright (c) 1997-99 Initio Corp.  All rights reserved.
@


1.14
log
@fix the use of "cuz" in the tree; these are all in comments

noticed by aaron@@, recommended by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.13 2002/03/14 01:26:54 millert Exp $ */
d2689 1
a2689 1
		panic("iha: invalid EEPROM,  bad signature or checksum\n");
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.12 2001/11/11 21:59:19 krw Exp $ */
d637 1
a637 1
				 * started, 'cuz we don't allow any
@


1.12
log
@Remove local defines for SCSI status codes and use those now
defined in scsi_all.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.11 2001/11/05 17:25:58 art Exp $ */
d64 4
a67 4
	iha_scsi_cmd,	/*  int (*scsi_cmd) __P((struct scsi_xfer *)); */
	iha_minphys,	/* void (*scsi_minphys) __P((struct buf *));   */
	NULL,		/*  int (*open_target_lu) __P((void));         */
	NULL		/*  int (*close_target_lu) __P((void));        */
d94 58
a151 58
u_int8_t iha_data_over_run __P((struct iha_scsi_req_q *));
void iha_push_sense_request __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_timeout __P((void *));
int  iha_alloc_scbs __P((struct iha_softc *));
void iha_read_eeprom __P((bus_space_tag_t, bus_space_handle_t,
			     struct iha_nvram *));
void iha_se2_instr __P((bus_space_tag_t, bus_space_handle_t, u_int8_t));
u_int16_t iha_se2_rd __P((bus_space_tag_t, bus_space_handle_t, u_int8_t));
void iha_reset_scsi_bus __P((struct iha_softc *));
void iha_reset_chip __P((struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t));
void iha_reset_dma __P((bus_space_tag_t, bus_space_handle_t));
void iha_reset_tcs __P((struct tcs *, u_int8_t));
void iha_print_info __P((struct iha_softc *, int));
void iha_done_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_exec_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_main __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t));
void iha_scsi __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t));
int  iha_wait __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t,
		      u_int8_t));
void iha_mark_busy_scb __P((struct iha_scsi_req_q *));
void iha_append_free_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
struct iha_scsi_req_q *iha_pop_free_scb __P((struct iha_softc *));
void iha_append_done_scb __P((struct iha_softc *, struct iha_scsi_req_q *,
				 u_int8_t));
struct iha_scsi_req_q *iha_pop_done_scb __P((struct iha_softc *));
void iha_append_pend_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_push_pend_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_del_pend_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
struct iha_scsi_req_q *iha_find_pend_scb __P((struct iha_softc *));
void iha_sync_done __P((struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t));
void iha_wide_done __P((struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t));
void iha_bad_seq __P((struct iha_softc *));
int  iha_next_state __P((struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t));
int  iha_state_1 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_2 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_3 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_4 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_5 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_6 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_8 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
void iha_set_ssig __P((bus_space_tag_t,
			  bus_space_handle_t, u_int8_t, u_int8_t));
int  iha_xpad_in __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_xpad_out __P((struct iha_softc *,
			  bus_space_tag_t, bus_space_handle_t));
int  iha_xfer_data __P((struct iha_scsi_req_q *,
d153 22
a174 22
			   int direction));
int  iha_status_msg __P((struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t));
int  iha_msgin __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t));
int  iha_msgin_sdtr __P((struct iha_softc *));
int  iha_msgin_extended __P((struct iha_softc *,
				bus_space_tag_t, bus_space_handle_t));
int  iha_msgin_ignore_wid_resid __P((struct iha_softc *,
					bus_space_tag_t, bus_space_handle_t));
int  iha_msgout __P((struct iha_softc *,
			bus_space_tag_t, bus_space_handle_t, u_int8_t));
int  iha_msgout_extended __P((struct iha_softc *,
				 bus_space_tag_t, bus_space_handle_t));
void iha_msgout_abort __P((struct iha_softc *,
			      bus_space_tag_t, bus_space_handle_t,  u_int8_t));
int  iha_msgout_reject __P((struct iha_softc *,
			       bus_space_tag_t, bus_space_handle_t));
int  iha_msgout_sdtr __P((struct iha_softc *,
			     bus_space_tag_t, bus_space_handle_t));
int  iha_msgout_wdtr __P((struct iha_softc *,
			     bus_space_tag_t, bus_space_handle_t));
void iha_select __P((struct iha_softc *,
d176 5
a180 5
			struct iha_scsi_req_q *, u_int8_t));
void iha_busfree __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_resel __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t));
void iha_abort_xs __P((struct iha_softc *, struct scsi_xfer *, u_int8_t));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.12 2001/11/11 21:59:19 krw Exp $ */
d64 4
a67 4
	iha_scsi_cmd,	/*  int (*scsi_cmd)(struct scsi_xfer *); */
	iha_minphys,	/* void (*scsi_minphys)(struct buf *);   */
	NULL,		/*  int (*open_target_lu)(void);         */
	NULL		/*  int (*close_target_lu)(void);        */
d94 58
a151 58
u_int8_t iha_data_over_run(struct iha_scsi_req_q *);
void iha_push_sense_request(struct iha_softc *, struct iha_scsi_req_q *);
void iha_timeout(void *);
int  iha_alloc_scbs(struct iha_softc *);
void iha_read_eeprom(bus_space_tag_t, bus_space_handle_t,
			     struct iha_nvram *);
void iha_se2_instr(bus_space_tag_t, bus_space_handle_t, u_int8_t);
u_int16_t iha_se2_rd(bus_space_tag_t, bus_space_handle_t, u_int8_t);
void iha_reset_scsi_bus(struct iha_softc *);
void iha_reset_chip(struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t);
void iha_reset_dma(bus_space_tag_t, bus_space_handle_t);
void iha_reset_tcs(struct tcs *, u_int8_t);
void iha_print_info(struct iha_softc *, int);
void iha_done_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_exec_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_main(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
void iha_scsi(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
int  iha_wait(struct iha_softc *, bus_space_tag_t, bus_space_handle_t,
		      u_int8_t);
void iha_mark_busy_scb(struct iha_scsi_req_q *);
void iha_append_free_scb(struct iha_softc *, struct iha_scsi_req_q *);
struct iha_scsi_req_q *iha_pop_free_scb(struct iha_softc *);
void iha_append_done_scb(struct iha_softc *, struct iha_scsi_req_q *,
				 u_int8_t);
struct iha_scsi_req_q *iha_pop_done_scb(struct iha_softc *);
void iha_append_pend_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_push_pend_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_del_pend_scb(struct iha_softc *, struct iha_scsi_req_q *);
struct iha_scsi_req_q *iha_find_pend_scb(struct iha_softc *);
void iha_sync_done(struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t);
void iha_wide_done(struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t);
void iha_bad_seq(struct iha_softc *);
int  iha_next_state(struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t);
int  iha_state_1(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_2(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_3(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_4(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_5(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_6(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_8(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
void iha_set_ssig(bus_space_tag_t,
			  bus_space_handle_t, u_int8_t, u_int8_t);
int  iha_xpad_in(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_xpad_out(struct iha_softc *,
			  bus_space_tag_t, bus_space_handle_t);
int  iha_xfer_data(struct iha_scsi_req_q *,
d153 22
a174 22
			   int direction);
int  iha_status_msg(struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t);
int  iha_msgin(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
int  iha_msgin_sdtr(struct iha_softc *);
int  iha_msgin_extended(struct iha_softc *,
				bus_space_tag_t, bus_space_handle_t);
int  iha_msgin_ignore_wid_resid(struct iha_softc *,
					bus_space_tag_t, bus_space_handle_t);
int  iha_msgout(struct iha_softc *,
			bus_space_tag_t, bus_space_handle_t, u_int8_t);
int  iha_msgout_extended(struct iha_softc *,
				 bus_space_tag_t, bus_space_handle_t);
void iha_msgout_abort(struct iha_softc *,
			      bus_space_tag_t, bus_space_handle_t,  u_int8_t);
int  iha_msgout_reject(struct iha_softc *,
			       bus_space_tag_t, bus_space_handle_t);
int  iha_msgout_sdtr(struct iha_softc *,
			     bus_space_tag_t, bus_space_handle_t);
int  iha_msgout_wdtr(struct iha_softc *,
			     bus_space_tag_t, bus_space_handle_t);
void iha_select(struct iha_softc *,
d176 5
a180 5
			struct iha_scsi_req_q *, u_int8_t);
void iha_busfree(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_resel(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
void iha_abort_xs(struct iha_softc *, struct scsi_xfer *, u_int8_t);
d637 1
a637 1
				 * started, because we don't allow any
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.12.2.1 2002/06/11 03:42:18 art Exp $ */
d2689 1
a2689 1
		panic("iha: invalid EEPROM,  bad signature or checksum");
@


1.12.2.3
log
@sync
@
text
@d1 3
a3 7
/*	$OpenBSD$ */
/*-------------------------------------------------------------------------
 *
 * Device driver for the INI-9XXXU/UW or INIC-940/950  PCI SCSI Controller.
 *
 * Written for 386bsd and FreeBSD by
 *	Winston Hung		<winstonh@@initio.com>
d5 2
a6 2
 * Copyright (c) 1997-1999 Initio Corp
 * Copyright (c) 2000-2002 Ken Westerback
d30 13
a58 2
/* #define IHA_DEBUG_STATE */

d81 1
a81 1
static const u_int8_t iha_rate_tbl[] = {
d94 2
a95 3
int iha_setup_sg_list(struct iha_softc *, struct iha_scb *);
u_int8_t iha_data_over_run(struct iha_scb *);
int iha_push_sense_request(struct iha_softc *, struct iha_scb *);
d108 2
a109 2
void iha_done_scb(struct iha_softc *, struct iha_scb *);
void iha_exec_scb(struct iha_softc *, struct iha_scb *);
d114 4
a117 4
void iha_mark_busy_scb(struct iha_scb *);
void iha_append_free_scb(struct iha_softc *, struct iha_scb *);
struct iha_scb *iha_pop_free_scb(struct iha_softc *);
void iha_append_done_scb(struct iha_softc *, struct iha_scb *,
d119 5
a123 5
struct iha_scb *iha_pop_done_scb(struct iha_softc *);
void iha_append_pend_scb(struct iha_softc *, struct iha_scb *);
void iha_push_pend_scb(struct iha_softc *, struct iha_scb *);
void iha_del_pend_scb(struct iha_softc *, struct iha_scb *);
struct iha_scb *iha_find_pend_scb(struct iha_softc *);
d151 1
a151 1
int  iha_xfer_data(struct iha_scb *,
d176 1
a176 1
			struct iha_scb *, u_int8_t);
a219 45
 * iha_setup_sg_list -	initialize scatter gather list of pScb from
 *			pScb->SCB_DataDma.
 */
int
iha_setup_sg_list(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
{
	bus_dma_segment_t *segs = pScb->SCB_DataDma->dm_segs;
	int i, error, nseg = pScb->SCB_DataDma->dm_nsegs;

	if (nseg > 1) {
		error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_SGDma,
				pScb->SCB_SGList, sizeof(pScb->SCB_SGList), NULL,
				(pScb->SCB_Flags & SCSI_NOSLEEP) ?
					BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			sc_print_addr(pScb->SCB_Xs->sc_link);
			printf("error %d loading SG list dma map\n", error);
			return (error);
		}

		/*
		 * Only set FLAG_SG when SCB_SGDma is loaded so iha_scsi_done
		 * will not unload an unloaded map.
		 */
		pScb->SCB_Flags	|= FLAG_SG;
		bzero(pScb->SCB_SGList, sizeof(pScb->SCB_SGList));

		pScb->SCB_SGIdx	  = 0;
		pScb->SCB_SGCount = nseg;

		for (i=0; i < nseg; i++) {
			pScb->SCB_SGList[i].SG_Len  = segs[i].ds_len;
			pScb->SCB_SGList[i].SG_Addr = segs[i].ds_addr;
		}

		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma, 
			0, sizeof(pScb->SCB_SGList), BUS_DMASYNC_PREWRITE);
	}

	return (0);
}

/*
d228 2
a229 1
	struct iha_scb *pScb;
d232 2
a233 1
	int error;
d263 1
a263 1
	pScb->SCB_BufCharsLeft = pScb->SCB_BufChars = xs->datalen;
d265 1
a265 1
	if ((pScb->SCB_Flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) != 0) {
d267 1
a267 1
		if (pScb->SCB_Flags & SCSI_DATA_UIO)
d269 2
a270 2
			    pScb->SCB_DataDma, (struct uio *)xs->data,
			    (pScb->SCB_Flags & SCSI_NOSLEEP) ?
d274 3
a276 3
			error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_DataDma,
			    xs->data, pScb->SCB_BufChars, NULL,
			    (pScb->SCB_Flags & SCSI_NOSLEEP) ?
a279 1
			sc_print_addr(xs->sc_link);
d281 2
a282 2
				printf("buffer needs >%d dma segments\n",
				    IHA_MAX_SG_ENTRIES);
d284 2
a285 2
				printf("error %d loading buffer dma map\n",
				    error);
a291 4
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma, 
			0, pScb->SCB_BufChars,
			(pScb->SCB_Flags & SCSI_DATA_IN) ?
				BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
d293 17
a309 6
		error = iha_setup_sg_list(sc, pScb);
		if (error) {
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
			xs->error = XS_DRIVER_STUFFUP;
			return (COMPLETE);
		}
d311 4
d317 3
d326 1
a326 1
	if ((pScb->SCB_Flags & SCSI_POLL) == 0)
d345 1
a345 1
	struct iha_scb *pScb;
d386 8
d398 1
a398 7
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &pScb->SCB_DataDma);

		if (error != 0) {
			printf("%s: couldn't create SCB data DMA map, error = %d\n",
			    sc->sc_dev.dv_xname, error);
			return (error);
		}
a399 5
		error = bus_dmamap_create(sc->sc_dmat,
				sizeof(pScb->SCB_SGList), 1,
				sizeof(pScb->SCB_SGList), 0,
				BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
				&pScb->SCB_SGDma);
d401 1
a401 1
			printf("%s: couldn't create SCB SG DMA map, error = %d\n",
a404 1

d489 1
a489 1
struct iha_scb *
d493 1
a493 1
	struct iha_scb *pScb;
d518 1
a518 1
	struct iha_scb *pScb;
d527 3
a529 3
	pScb->SCB_Status = STATUS_QUEUED;
	pScb->SCB_HaStat = HOST_OK;
	pScb->SCB_TaStat = SCSI_OK;
d532 2
d537 2
d542 2
a543 3

	pScb->SCB_BufChars     = 0;
	pScb->SCB_BufCharsLeft = 0;
d548 3
a550 1
	bzero(pScb->SCB_CDB, sizeof(pScb->SCB_CDB));
d553 3
a555 1
	 * SCB_TagId is set at initialization and never changes
d566 1
a566 1
	struct iha_scb *pScb;
d581 1
a581 1
	struct iha_scb *pScb;
d603 1
a603 1
struct iha_scb *
d607 1
a607 1
	struct iha_scb *pScb;
d664 1
a664 1
	struct iha_scb *pScb;
d677 1
a677 1
	struct iha_scb *pScb;
d696 1
a696 1
	struct iha_scb *pScb;
d726 1
a726 1
struct iha_scb *
d730 1
a730 1
	struct iha_scb *pScb;
d758 1
a758 1
	struct iha_scb *pScb;
d803 1
a803 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d817 1
a817 1
int
d820 1
a820 1
	struct iha_scb *pScb;
d822 2
a823 2
	struct scsi_sense *sensecmd;
	int error;
d825 1
a825 39
	/* First sync & unload any existing DataDma and SGDma maps */
	if ((pScb->SCB_Flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) != 0) {
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma,
			0, pScb->SCB_BufChars,
			((pScb->SCB_Flags & SCSI_DATA_IN) ? 
				BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
		bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
		/* Don't unload this map again until it is reloaded */
		pScb->SCB_Flags &= ~(SCSI_DATA_IN | SCSI_DATA_OUT);
	}
	if ((pScb->SCB_Flags & FLAG_SG) != 0) {
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma,
			0, sizeof(pScb->SCB_SGList),
			BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, pScb->SCB_SGDma);
		/* Don't unload this map again until it is reloaded */
		pScb->SCB_Flags &= ~FLAG_SG;
	}

	pScb->SCB_BufChars     = sizeof(pScb->SCB_ScsiSenseData);
	pScb->SCB_BufCharsLeft = sizeof(pScb->SCB_ScsiSenseData);
	bzero(&pScb->SCB_ScsiSenseData, sizeof(pScb->SCB_ScsiSenseData)); 

	error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_DataDma,
			&pScb->SCB_ScsiSenseData,
			sizeof(pScb->SCB_ScsiSenseData), NULL,
			(pScb->SCB_Flags & SCSI_NOSLEEP) ?
				BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error) {
		sc_print_addr(pScb->SCB_Xs->sc_link);
		printf("error %d loading request sense buffer dma map\n",
			error);
		return (error);
	}
	bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma, 
		0, pScb->SCB_BufChars, BUS_DMASYNC_PREREAD);

	/* Save _POLL and _NOSLEEP flags. */ 
	pScb->SCB_Flags &= SCSI_POLL | SCSI_NOSLEEP;
a827 4
	error = iha_setup_sg_list(sc, pScb);
	if (error)
		return (error);

d835 3
a837 5
	sensecmd = (struct scsi_sense *)pScb->SCB_CDB;
	pScb->SCB_CDBLen = sizeof(*sensecmd);
	sensecmd->opcode = REQUEST_SENSE;
	sensecmd->byte2  = pScb->SCB_Xs->sc_link->lun << 5;
	sensecmd->length = sizeof(pScb->SCB_ScsiSenseData);
d841 1
a841 1
		    (pScb->SCB_Xs->timeout/1000) * hz);
a843 2

	return (0);
d858 1
a858 1
	struct iha_scb *pScb;
d876 3
a878 5
				else if (iha_push_sense_request(sc, pScb) != 0)
					/* Could not push sense request */
					pScb->SCB_HaStat = HOST_BAD_PHAS;
				else
					/* REQUEST SENSE ready to process */
d880 1
d919 1
a919 1
	struct iha_scb *pScb;
a921 1
	int i;
d990 1
a990 1
		for (i = pScb->SCB_Xs->timeout; i > 0; i--) {
d1005 1
a1005 1
		if (i == 0)
d1017 1
a1017 1
 * iha_data_over_run - return HOST_OK for all SCSI opcodes where BufCharsLeft
d1028 1
a1028 1
	struct iha_scb *pScb;
a1137 1
		sc_print_addr(sc->HCS_ActScb->SCB_Xs->sc_link);
d1160 1
a1160 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1221 1
a1221 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1248 1
a1248 1
	struct iha_scb *pScb = sc->HCS_ActScb;
a1284 2
#ifdef IHA_DEBUG_STATE
			sc_print_addr(pScb->SCB_Xs->sc_link);
a1285 1
#endif
d1304 1
a1304 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1310 1
a1310 1
		if (pScb->SCB_BufCharsLeft == 0)
d1329 1
a1329 1
				pScb->SCB_BufCharsLeft = 0;
d1367 1
a1367 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1373 1
d1422 1
a1422 1
		pScb->SCB_BufCharsLeft = 0;
d1428 2
a1429 5
	xcnt = pScb->SCB_BufCharsLeft - cnt;	/* xcnt == bytes xferred */
	pScb->SCB_BufCharsLeft = cnt;		/* cnt  == bytes left    */

	bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma, 
		0, sizeof(pScb->SCB_SGList), BUS_DMASYNC_POSTWRITE);
d1433 1
a1433 1
		for (; pScb->SCB_SGIdx < pScb->SCB_SGCount; pSg++, pScb->SCB_SGIdx++) {
d1438 1
a1438 1
				pSg->SG_Addr += xcnt;
d1441 4
a1444 3
				bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma, 
					0, sizeof(pScb->SCB_SGList),
					BUS_DMASYNC_PREWRITE);
d1451 2
a1452 1
	}
d1511 1
a1511 1
	struct iha_scb *pScb;
d1557 1
a1557 1
	struct iha_scb *pScb;
d1562 1
a1562 1
	u_int32_t xferaddr, xferlen;
d1568 1
a1568 1
	bus_space_write_4(iot, ioh, TUL_STCNT0, pScb->SCB_BufCharsLeft);
d1571 1
a1571 3
		xferaddr = pScb->SCB_DataDma->dm_segs[0].ds_addr
				+ (pScb->SCB_BufChars - pScb->SCB_BufCharsLeft);
		xferlen  = pScb->SCB_BufCharsLeft;
d1575 1
a1575 4
		xferaddr = pScb->SCB_SGDma->dm_segs[0].ds_addr
				+ (pScb->SCB_SGIdx * sizeof(struct iha_sg_element));
		xferlen  = (pScb->SCB_SGCount - pScb->SCB_SGIdx)
				* sizeof(struct iha_sg_element);
d1580 1
a1580 1
	bus_space_write_4(iot, ioh, TUL_DXPA, xferaddr);
d1597 1
a1597 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1629 1
a1629 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1664 1
a1664 1
	struct iha_scb *pScb;
d1737 1
a1737 1
	struct iha_scb *pScb;
d1760 1
a1760 1
	struct iha_scb *pScb;
d1797 1
a1797 1
	struct iha_scb *pScb;
a1934 1
#ifdef IHA_DEBUG_STATE
a1935 1
#endif
d2025 1
a2025 2
			/* Offer 8 bit xfers only */
			sc->HCS_Msg[2] = MSG_EXT_WDTR_BUS_8_BIT;
d2027 1
a2027 1
		else if (sc->HCS_Msg[2] > MSG_EXT_WDTR_BUS_32_BIT)
d2030 2
a2031 3
		else if (sc->HCS_Msg[2] == MSG_EXT_WDTR_BUS_32_BIT)
			/* Offer 16 instead */
			sc->HCS_Msg[2] = MSG_EXT_WDTR_BUS_32_BIT;
d2242 1
a2242 1
			for (i = 0; i < sizeof(iha_rate_tbl); i++)
d2289 1
a2289 1
	struct iha_scb *pScb;
a2316 2
#ifdef IHA_DEBUG_STATE
		sc_print_addr(pScb->SCB_Xs->sc_link);
a2318 1
#endif
d2408 1
a2408 1
	struct iha_scb *pScb;
a2413 2
		timeout_del(&xs->stimeout);

a2415 14
		if ((pScb->SCB_Flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) != 0) {
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma,
				0, pScb->SCB_BufChars,
				((pScb->SCB_Flags & SCSI_DATA_IN) ? 
					BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
		}
		if ((pScb->SCB_Flags & FLAG_SG) != 0) {
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma,
				0, sizeof(pScb->SCB_SGList),
				BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_SGDma);
		}

d2423 1
a2423 1
				xs->resid = pScb->SCB_BufCharsLeft;
d2459 2
a2460 2
			sc_print_addr(xs->sc_link);
			printf("SCSI Parity error detected\n");
d2475 9
d2495 1
a2495 1
	struct iha_scb *pScb = (struct iha_scb *)arg;
d2497 1
d2499 5
a2503 1
	if (xs != NULL) {
d2506 1
d2514 1
a2514 1
	struct iha_scb *pScb;
d2537 1
a2537 1
		sc->HCS_Semaph = SEMAPH_IN_MAIN;
d2543 1
a2543 1
		sc->HCS_Semaph = ~SEMAPH_IN_MAIN;
d2577 2
a2578 2
		(period & PERIOD_WIDE_SCSI) ? 16 : 8);
 
d2591 1
a2591 1

d2610 1
a2610 1
		 sizeof(struct iha_scb)*IHA_MAX_SCB,
d2618 1
a2618 1
		 &seg, rseg, sizeof(struct iha_scb)*IHA_MAX_SCB,
d2625 23
a2647 1
	bzero(sc->HCS_Scb, sizeof(struct iha_scb)*IHA_MAX_SCB);
@


1.11
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.10 2001/10/14 02:56:34 krw Exp $ */
d867 1
a867 1
			case SCSI_CMD_TERMINATED:
d2420 1
a2420 1
			case SCSI_CONDITION_MET:
d2427 1
a2427 1
			case SCSI_RSERV_CONFLICT:
d2433 1
a2433 1
			case SCSI_CMD_TERMINATED:
@


1.10
log
@Andreas Gunnarsson found a bug in iha that causes system crashes
when running a DIAGNOSTIC kernel. This was exposed by the recent
migration of the SCSI layer to use pools.

timeout_del() was being called on de-allocated memory after every
completed SCSI command. Which worked as long as the memory was not
reused or zapped ...

This patch, slightly modified from Andreas's original diff, moves
the timeout_del() to before the call to scsi_done() which
de-allocates the memory holding the timeout. All scb's that start
a timeout go through this logic and have the timeout_del() called.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.9 2001/08/26 02:39:05 krw Exp $ */
d311 1
a311 1
		iha_bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap, 
d2476 1
a2476 1
			iha_bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap,
@


1.9
log
@Prepare for transition to 5-parameter bus_dmamap_sync() by creating and
using *_bus_dmamap_sync() defines that are defined appropriately
depending on __HAS_NEW_BUS_DMAMAP_SYNC.

Most of the code changes are simple reversions to the original NetBSD
code.

Slip in a siop_script_sync() instead of a manually done code section.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.8 2001/07/13 04:27:09 krw Exp $ */
a523 3
	if (pScb->SCB_Xs != NULL)
		timeout_del(&pScb->SCB_Xs->stimeout);

d2483 1
d2487 1
a2487 1

@


1.8
log
@Change references to inic-950 to inic-940/950 to reflect chips
actually supported.

Update copyright to include 2001.

Fold iha_se2_rd_all() into iha_read_eeprom(), eliminating magic number
31 at the same time, calculating correct offset of checksum at run
time instead.

Eliminate static global variable iha_nvram in favour of dynamic
variable in iha_init_tulip(), which is only place it is used.

Rectify a few typos in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.7 2001/07/13 03:24:20 krw Exp $ */
d311 2
a312 1
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap,
d2479 4
a2482 3
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap
			    ,(xs->flags & SCSI_DATA_IN) ? 
			    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
@


1.7
log
@Remove static'ness of functions in line with normal OpenBSD
preferences.

Rename tul_* functions/variables iha_* for consistancy, since all are
now visible.

As updating the EEPROM did not work, don't try. Remove now unused
static dftNvram variable, and functions used only in trying to write
it to EEPROM.

Make iha_rate_tbl a const.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.6 2001/07/10 23:30:39 krw Exp $ */
d5 1
a5 1
 * Copyright (c) 2000 Ken Westerback
a93 2
static struct iha_nvram iha_nvram;

d98 2
a99 2
void iha_read_eeprom __P((bus_space_tag_t, bus_space_handle_t));
int  iha_se2_rd_all __P((bus_space_tag_t, bus_space_handle_t));
d337 2
a338 2
 * iha_init_tulip - initialize the inic-950 card and the rest of the
 *		    IHA_SOFTC structure supplied
d345 1
d347 1
a347 1
	struct iha_nvram_scsi *pScsi;
d354 1
a354 1
	iha_read_eeprom(iot, ioh);
d369 1
a369 1
	 * fill in the rest of the IHA_SOFTC fields
d2597 1
a2597 1
 * iha_alloc_scbs - allocate and map the SCB's for the supplied IHA_SOFTC
d2653 2
a2654 2
 * iha_read_eeprom - read Serial EEPROM value & set to defaults
 *		     if required. XXX - Writing does NOT work!
d2657 1
a2657 1
iha_read_eeprom(iot, ioh)
d2660 1
d2662 5
a2666 1
	u_int8_t gctrl;
d2673 8
a2680 2
	if (iha_se2_rd_all(iot, ioh) == 0)
		panic("iha: could not read EEPROM\n");
d2685 5
a2728 28
}

/*
 * iha_se2_rd_all - Read SCSI H/A config parameters from serial EEPROM
 *		    into iha_nvram variable.
 */
int
iha_se2_rd_all(iot, ioh)
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
{
	u_int16_t *np;
	u_int32_t chksum;
	u_int8_t i;

	np = (u_int16_t *)&iha_nvram;

	for (i = 0, chksum = 0; i < 31; i++, np++) {
		*np = iha_se2_rd(iot, ioh, i);
		chksum += *np;
	}
	*np = iha_se2_rd(iot, ioh, 31); /* read checksum from eeprom */

	chksum &= 0x0000ffff; /* calculated checksum is lower 16 bits of sum */

	return (iha_nvram.NVM_Signature == SIGNATURE)
	       &&
	       (iha_nvram.NVM_CheckSum	== chksum);
@


1.6
log
@Use offsetof() from sys/param.h, not a local define.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.5 2001/07/09 18:01:38 krw Exp $ */
d81 1
a81 1
static u_int8_t tul_rate_tbl[8] = {
d94 1
a94 1
static struct nvram tul_nvram;
d96 77
a172 72
static u_int8_t tul_dftNvRam[64] = {
	/* -- Header ------------------------------------ */
	0x25, 0xc9,		/* NVM_Signature          */
	0x40,			/* NVM_Size	          */
	0x01,			/* NVM_Revision	          */

	/* -- Host Adapter Structure -------------------- */
	0x95,			/* NVM_ModelByte0	  */
	0x00,			/* NVM_ModelByte1	  */
	0x00,			/* NVM_ModelInfo	  */
	0x01,			/* NVM_NumOfCh	          */
	BIOSCFG_DEFAULT,	/* NVM_BIOSConfig1	  */
	0,			/* NVM_BIOSConfig2	  */
	0,			/* NVM_HAConfig1	  */
	0,			/* NVM_HAConfig2	  */

	/* -- NVM_Scsi[0] ------------------------------- */
	7,			/* NVM_SCSI_Id            */
	CFG_DEFAULT,		/* NVM_SCSI_Cfg           */
	0,			/* NVM_SCSI_CfgByte2      */
	8,			/* NVM_SCSI_Targets       */
				/* NVM_SCSI_TargetFlags   */
	FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT,
	FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT,
	FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT,
	FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT,

	/* -- NVM_Scsi[1] ------------------------------- */
	7,			/* NVM_SCSI_Id            */
	CFG_DEFAULT,		/* NVM_SCSI_Cfg           */
	0,			/* NVM_SCSI_CfgByte2      */
	8,			/* NVM_SCSI_Targets       */
				/* NVM_SCSI_TargetFlags   */
	FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT,
	FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT,
	FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT,
	FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT, FLAG_DEFAULT,
				
	0,0,0,0,0,0,0,0,0,0,	/* NVM_Reserved[10]       */
	0,0			/* NVM_CheckSum           */
};

static u_int8_t tul_data_over_run __P((struct iha_scsi_req_q *));

static void tul_push_sense_request __P((struct iha_softc *,
					   struct iha_scsi_req_q *));
static void tul_timeout __P((void *));
static int  tul_alloc_scbs __P((struct iha_softc *));

static void	 tul_read_eeprom    __P((bus_space_tag_t, bus_space_handle_t));
static void	 tul_se2_update_all __P((bus_space_tag_t, bus_space_handle_t));
static int	 tul_se2_rd_all	    __P((bus_space_tag_t, bus_space_handle_t));
static void	 tul_se2_wr	    __P((bus_space_tag_t, bus_space_handle_t,
					    u_int8_t, u_int16_t));
static void	 tul_se2_instr	    __P((bus_space_tag_t, bus_space_handle_t,
					    u_int8_t));
static u_int16_t tul_se2_rd	    __P((bus_space_tag_t, bus_space_handle_t,
					    u_int8_t));

static void tul_reset_scsi_bus __P((struct iha_softc *));
static void tul_reset_chip     __P((struct iha_softc *,
				       bus_space_tag_t, bus_space_handle_t));
static void tul_reset_dma      __P((bus_space_tag_t, bus_space_handle_t));

static void tul_reset_tcs  __P((struct tcs *, u_int8_t));

static void tul_print_info __P((struct iha_softc *, int));

static void tul_done_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
static void tul_exec_scb __P((struct iha_softc *, struct iha_scsi_req_q *));

static void tul_main __P((struct iha_softc *,
d174 1
a174 1
static void tul_scsi __P((struct iha_softc *,
d176 7
a182 95

static int  tul_wait __P((struct iha_softc *,
			     bus_space_tag_t, bus_space_handle_t, u_int8_t));

static void tul_mark_busy_scb	__P((struct iha_scsi_req_q *));

static void tul_append_free_scb __P((struct iha_softc *,
					struct iha_scsi_req_q *));
static struct iha_scsi_req_q *tul_pop_free_scb __P((struct iha_softc *));

static void tul_append_done_scb __P((struct iha_softc *,
					struct iha_scsi_req_q *, u_int8_t));
static struct iha_scsi_req_q *tul_pop_done_scb	  __P((struct iha_softc *));

static void tul_append_pend_scb __P((struct iha_softc *,
					struct iha_scsi_req_q *));
static void tul_push_pend_scb	__P((struct iha_softc *,
					struct iha_scsi_req_q *));
static void tul_del_pend_scb	__P((struct iha_softc *,
					struct iha_scsi_req_q *));
static struct iha_scsi_req_q *tul_find_pend_scb	  __P((struct iha_softc *));

static void tul_sync_done __P((struct iha_softc *,
				  bus_space_tag_t, bus_space_handle_t));
static void tul_wide_done __P((struct iha_softc *,
				  bus_space_tag_t, bus_space_handle_t));
static void tul_bad_seq	  __P((struct iha_softc *));

static int  tul_next_state __P((struct iha_softc *,
				   bus_space_tag_t, bus_space_handle_t));
static int  tul_state_1	   __P((struct iha_softc *,
				   bus_space_tag_t, bus_space_handle_t));
static int  tul_state_2	   __P((struct iha_softc *,
				   bus_space_tag_t, bus_space_handle_t));
static int  tul_state_3	   __P((struct iha_softc *,
				   bus_space_tag_t, bus_space_handle_t));
static int  tul_state_4	   __P((struct iha_softc *,
				   bus_space_tag_t, bus_space_handle_t));
static int  tul_state_5	   __P((struct iha_softc *,
				   bus_space_tag_t, bus_space_handle_t));
static int  tul_state_6	   __P((struct iha_softc *,
				   bus_space_tag_t, bus_space_handle_t));
static int  tul_state_8	   __P((struct iha_softc *,
				   bus_space_tag_t, bus_space_handle_t));

static void tul_set_ssig __P((bus_space_tag_t,
				 bus_space_handle_t, u_int8_t, u_int8_t));

static int  tul_xpad_in	 __P((struct iha_softc *,
				 bus_space_tag_t, bus_space_handle_t));
static int  tul_xpad_out __P((struct iha_softc *,
				 bus_space_tag_t, bus_space_handle_t));

static int  tul_xfer_data __P((struct iha_scsi_req_q *,
				  bus_space_tag_t, bus_space_handle_t,
				  int direction));

static int  tul_status_msg __P((struct iha_softc *,
				   bus_space_tag_t, bus_space_handle_t));

static int  tul_msgin        __P((struct iha_softc *,
				     bus_space_tag_t, bus_space_handle_t));
static int  tul_msgin_sdtr   __P((struct iha_softc *));
static int  tul_msgin_extended __P((struct iha_softc *,
				     bus_space_tag_t, bus_space_handle_t));
static int  tul_msgin_ignore_wid_resid __P((struct iha_softc *,
					       bus_space_tag_t,
					       bus_space_handle_t));

static int  tul_msgout	      __P((struct iha_softc *,
				      bus_space_tag_t, bus_space_handle_t,
				      u_int8_t));
static int  tul_msgout_extended __P((struct iha_softc *,
					bus_space_tag_t, bus_space_handle_t));
static void tul_msgout_abort  __P((struct iha_softc *,
				      bus_space_tag_t, bus_space_handle_t,
				      u_int8_t));
static int  tul_msgout_reject __P((struct iha_softc *,
				      bus_space_tag_t, bus_space_handle_t));
static int  tul_msgout_sdtr   __P((struct iha_softc *,
				      bus_space_tag_t, bus_space_handle_t));
static int  tul_msgout_wdtr   __P((struct iha_softc *,
				      bus_space_tag_t, bus_space_handle_t));

static void tul_select __P((struct iha_softc *,
			       bus_space_tag_t, bus_space_handle_t,
			       struct iha_scsi_req_q *, u_int8_t));

static void tul_busfree	 __P((struct iha_softc *,
				 bus_space_tag_t, bus_space_handle_t));
static int  tul_resel	 __P((struct iha_softc *,
				 bus_space_tag_t, bus_space_handle_t));

static void tul_abort_xs __P((struct iha_softc *,
				 struct scsi_xfer *, u_int8_t));
d210 1
a210 1
		tul_main(sc, iot, ioh);
d242 1
a242 1
	pScb = tul_pop_free_scb(sc);
d289 1
a289 1
			tul_append_free_scb(sc, pScb); 
d326 1
a326 1
	timeout_set(&xs->stimeout, tul_timeout, pScb);
d330 1
a330 1
	tul_exec_scb(sc, pScb);
d348 1
a348 1
	struct nvram_scsi *pScsi;
d355 1
a355 1
	tul_read_eeprom(iot, ioh);
d357 1
a357 1
	pScsi = &tul_nvram.NVM_Scsi[0];
d380 1
a380 1
	error = tul_alloc_scbs(sc);
d412 1
a412 1
	tul_reset_dma(iot, ioh);
d420 1
a420 1
	 * into tul_nvram by tul_read_eeprom() above.
d442 1
a442 1
		tul_reset_tcs(&sc->HCS_Tcs[i], sc->HCS_SConf1);
d445 1
a445 1
	tul_reset_chip(sc, iot, ioh);
d468 1
a468 1
 * tul_reset_dma - abort any active DMA xfer, reset tulip FIFO.
d470 2
a471 2
static void
tul_reset_dma(iot, ioh)
d487 1
a487 1
 * tul_pop_free_scb - return the first free SCB, or NULL if there are none.
d489 2
a490 2
static struct iha_scsi_req_q *
tul_pop_free_scb(sc)
d511 1
a511 1
 * tul_append_free_scb - append the supplied SCB to the tail of the
d515 2
a516 2
static void
tul_append_free_scb(sc, pScb)
d566 2
a567 2
static void
tul_append_pend_scb(sc, pScb)
d581 2
a582 2
static void
tul_push_pend_scb(sc, pScb)
d601 1
a601 1
 * tul_find_pend_scb - scan the pending queue for a SCB that can be
d606 2
a607 2
static struct iha_scsi_req_q *
tul_find_pend_scb(sc)
d662 1
a662 1
 * tul_del_pend_scb - remove pScb from HCS_PendScb
d664 2
a665 2
static void
tul_del_pend_scb(sc, pScb)
d678 2
a679 2
static void
tul_mark_busy_scb(pScb)
d696 2
a697 2
static void
tul_append_done_scb(sc, pScb, hastat)
d729 2
a730 2
static struct iha_scsi_req_q *
tul_pop_done_scb(sc)
d751 1
a751 1
 * tul_abort_xs - find the SCB associated with the supplied xs and
d755 2
a756 2
static void
tul_abort_xs(sc, xs, hastat)
d770 2
a771 2
			tul_del_pend_scb(sc, pScb);
			tul_append_done_scb(sc, pScb, hastat);
d786 1
a786 1
				tul_append_done_scb(sc, pScb, hastat);
d799 1
a799 1
 * tul_bad_seq - a SCSI bus phase was encountered out of the
d802 2
a803 2
static void
tul_bad_seq(sc)
d809 1
a809 1
		tul_append_done_scb(sc, pScb, HOST_BAD_PHAS);
d811 2
a812 2
	tul_reset_scsi_bus(sc);
	tul_reset_chip(sc, sc->sc_iot, sc->sc_ioh);
d816 1
a816 1
 * tul_push_sense_request - obtain auto sense data by pushing the
d820 2
a821 2
static void
tul_push_sense_request(sc, pScb)
d846 1
a846 1
	tul_push_pend_scb(sc, pScb);
d850 1
a850 1
 * tul_main - process the active SCB, taking one off pending and making it
d855 2
a856 2
static void
tul_main(sc, iot, ioh)
d864 2
a865 2
tul_scsi_label:
		tul_scsi(sc, iot, ioh);
d867 1
a867 1
		while ((pScb = tul_pop_done_scb(sc)) != NULL) {
d881 2
a882 2
					tul_push_sense_request(sc, pScb);
					goto tul_scsi_label;
d897 1
a897 1
			tul_done_scb(sc, pScb);
d904 1
a904 1
		 * tul_scsi().
d907 1
a907 1
		    && (tul_find_pend_scb(sc) == NULL))
d913 1
a913 1
 * tul_scsi - service any outstanding interrupts. If there are none, try to
d916 2
a917 2
static void
tul_scsi(sc, iot, ioh)
d937 1
a937 1
			tul_reset_scsi_bus(sc);
d942 1
a942 1
			tul_resel(sc, iot, ioh);
d947 1
a947 1
			tul_busfree(sc, iot, ioh);
d952 1
a952 1
			tul_next_state(sc, iot, ioh);
d957 1
a957 1
			tul_set_ssig(iot, ioh, 0, 0);
d964 1
a964 1
	if ((pScb = tul_find_pend_scb(sc)) == NULL)
d979 1
a979 1
			tul_select(sc, iot, ioh, pScb, SELATNSTOP);
d982 1
a982 1
			tul_select(sc, iot, ioh, pScb, SEL_ATN3);
d985 1
a985 1
			tul_select(sc, iot, ioh, pScb, SEL_ATN);
d988 1
a988 1
		tul_select(sc, iot, ioh, pScb, SELATNSTOP);
d994 1
a994 1
			if (tul_wait(sc, iot, ioh, NO_OP) == -1)
d996 1
a996 1
			if (tul_next_state(sc, iot, ioh) == -1)
d1009 1
a1009 1
			tul_timeout(pScb);
d1015 1
a1015 1
			tul_print_info(sc, pScb->SCB_Target);
d1020 1
a1020 1
 * tul_data_over_run - return HOST_OK for all SCSI opcodes where BufLen
d1029 2
a1030 2
static u_int8_t
tul_data_over_run(pScb)
d1081 1
a1081 1
 * tul_next_state - prcess the current SCB as requested in it's 
d1084 2
a1085 2
static int
tul_next_state(sc, iot, ioh)
d1095 1
a1095 1
		if (tul_state_1(sc, iot, ioh) == 3)
d1100 1
a1100 1
		switch (tul_state_2(sc, iot, ioh)) {
d1109 1
a1109 1
		if (tul_state_3(sc, iot, ioh) == 4)
d1115 1
a1115 1
		switch (tul_state_4(sc, iot, ioh)) {
d1123 1
a1123 1
		switch (tul_state_5(sc, iot, ioh)) {
d1132 1
a1132 1
		tul_state_6(sc, iot, ioh);
d1136 1
a1136 1
		tul_state_8(sc, iot, ioh);
d1144 1
a1144 1
		tul_bad_seq(sc);
d1152 1
a1152 1
 * tul_state_1 - selection is complete after a SELATNSTOP. If the target
d1157 2
a1158 2
static int
tul_state_1(sc, iot, ioh)
d1167 1
a1167 1
	tul_mark_busy_scb(pScb);
d1197 1
a1197 1
			if (tul_msgout_wdtr(sc, iot, ioh) == -1)
d1200 1
a1200 1
			if (tul_msgout_sdtr(sc, iot, ioh) == -1)
d1206 1
a1206 1
		tul_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
d1213 1
a1213 1
 * tul_state_2 - selection is complete after a SEL_ATN or SEL_ATN3. If the SCSI
d1218 2
a1219 2
static int
tul_state_2(sc, iot, ioh)
d1226 1
a1226 1
	tul_mark_busy_scb(pScb);
d1235 1
a1235 1
	tul_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
d1241 1
a1241 1
 * tul_state_3 - send the SCSI CDB to the target, processing any status
d1245 2
a1246 2
static int
tul_state_3(sc, iot, ioh)
d1259 1
a1259 1
			if (tul_wait(sc, iot, ioh, XF_FIFO_OUT) == -1)
d1262 1
a1262 1
				tul_bad_seq(sc);
d1269 1
a1269 1
			if (tul_msgin(sc, iot, ioh) == -1)
d1274 1
a1274 1
			if (tul_status_msg(sc, iot, ioh) == -1)
d1281 1
a1281 1
				if (tul_msgout(sc, iot, ioh, MSG_NOOP) == -1)
d1283 1
a1283 1
			} else if (tul_msgout_sdtr(sc, iot, ioh) == -1)
d1289 1
a1289 1
			tul_bad_seq(sc);
d1295 1
a1295 1
 * tul_state_4 - start a data xfer. Handle any bus state
d1301 2
a1302 2
static int
tul_state_4(sc, iot, ioh)
d1319 2
a1320 2
				pScb->SCB_HaStat = tul_data_over_run(pScb);
			if ((tul_status_msg(sc, iot, ioh)) == -1)
d1326 1
a1326 1
			if (tul_msgin(sc, iot, ioh) == -1)
d1334 1
a1334 1
				if (tul_msgout(sc, iot, ioh,
d1340 1
a1340 1
				if (tul_msgout(sc, iot, ioh, MSG_NOOP) == -1)
d1346 1
a1346 1
			return (tul_xfer_data(pScb, iot, ioh, SCSI_DATA_IN));
d1349 1
a1349 1
			return (tul_xfer_data(pScb, iot, ioh, SCSI_DATA_OUT));
d1352 1
a1352 1
			tul_bad_seq(sc);
d1359 1
a1359 1
 * tul_state_5 - handle the partial or final completion of the current
d1364 2
a1365 2
static int
tul_state_5(sc, iot, ioh)
d1416 1
a1416 1
			if (tul_wait(sc, iot, ioh, XF_FIFO_OUT) == -1)
d1461 1
a1461 1
 * tul_state_6 - finish off the active scb (may require several
d1465 2
a1466 2
static int
tul_state_6(sc, iot, ioh)
d1474 1
a1474 1
			if (tul_status_msg(sc, iot, ioh) == -1)
d1480 1
a1480 1
			if ((tul_msgin(sc, iot, ioh)) == -1)
d1485 1
a1485 1
			if ((tul_msgout(sc, iot, ioh, MSG_NOOP)) == -1)
d1490 1
a1490 1
			if (tul_xpad_in(sc, iot, ioh) == -1)
d1495 1
a1495 1
			if (tul_xpad_out(sc, iot, ioh) == -1)
d1500 1
a1500 1
			tul_bad_seq(sc);
d1506 1
a1506 1
 * tul_state_8 - reset the active device and all busy SCBs using it
d1508 2
a1509 2
static int
tul_state_8(sc, iot, ioh)
d1524 1
a1524 1
		tul_append_done_scb(sc, pScb, HOST_OK);
d1526 1
a1526 1
		tul_reset_tcs(pScb->SCB_Tcs, sc->HCS_SConf1);
d1533 1
a1533 1
					tul_append_done_scb(sc,
d1538 1
a1538 1
					tul_push_pend_scb(sc, pScb);
d1547 1
a1547 1
		if (tul_wait(sc, iot, ioh, XF_FIFO_OUT) == -1)
d1551 1
a1551 1
	tul_bad_seq(sc);
d1556 1
a1556 1
 * tul_xfer_data - initiate the DMA xfer of the data
d1558 2
a1559 2
static int
tul_xfer_data(pScb, iot, ioh, direction)
d1594 2
a1595 2
static int
tul_xpad_in(sc, iot, ioh)
d1611 1
a1611 1
		switch (tul_wait(sc, iot, ioh, XF_FIFO_IN)) {
d1626 2
a1627 2
static int
tul_xpad_out(sc, iot, ioh)
d1645 1
a1645 1
		switch (tul_wait(sc, iot, ioh, XF_FIFO_OUT)) {
d1661 2
a1662 2
static int
tul_status_msg(sc, iot, ioh)
d1671 1
a1671 1
	if ((phase = tul_wait(sc, iot, ioh, CMD_COMP)) == -1)
d1686 1
a1686 1
		return (tul_wait(sc, iot, ioh, XF_FIFO_OUT));
d1692 1
a1692 1
			switch (tul_wait(sc, iot, ioh, MSG_ACCEPT)) {
d1698 1
a1698 1
				return (tul_wait(sc, iot, ioh, XF_FIFO_OUT));
d1700 1
a1700 1
				tul_bad_seq(sc);
d1707 1
a1707 1
				tul_bad_seq(sc);
d1712 1
a1712 1
			return (tul_wait(sc, iot, ioh, MSG_ACCEPT));
d1719 1
a1719 1
				return (tul_wait(sc, iot, ioh, MSG_ACCEPT));
d1723 1
a1723 1
	tul_bad_seq(sc);
d1728 1
a1728 1
 * tul_busfree - SCSI bus free detected as a result of a TIMEOUT or
d1734 2
a1735 2
static void
tul_busfree(sc, iot, ioh)
d1751 1
a1751 1
			tul_append_done_scb(sc, pScb, HOST_SEL_TOUT);
d1754 1
a1754 1
			tul_append_done_scb(sc, pScb, HOST_BAD_PHAS);
d1759 2
a1760 2
static void
tul_reset_scsi_bus(sc)
d1769 1
a1769 1
	tul_reset_dma(sc->sc_iot, sc->sc_ioh);
d1774 1
a1774 1
			tul_append_done_scb(sc, pScb, HOST_SCSI_RST);
d1778 1
a1778 1
			tul_push_pend_scb(sc, pScb);
d1786 1
a1786 1
		tul_reset_tcs(pTcs, sc->HCS_SConf1);
d1792 1
a1792 1
 * tul_resel - handle a detected SCSI bus reselection request.
d1794 2
a1795 2
static int
tul_resel(sc, iot, ioh)
d1806 1
a1806 1
			tul_push_pend_scb(sc, sc->HCS_ActScb);
d1832 1
a1832 1
		switch (tul_wait(sc, iot, ioh, MSG_ACCEPT)) {
d1837 1
a1837 1
			if ((tul_wait(sc, iot, ioh, XF_FIFO_IN)) == -1)
d1849 1
a1849 1
		switch (tul_wait(sc, iot, ioh, MSG_ACCEPT)) {
d1854 1
a1854 1
			if ((tul_wait(sc, iot, ioh, XF_FIFO_IN)) == -1)
d1871 1
a1871 1
		tul_msgout_abort(sc, iot, ioh, abortmsg);
d1877 1
a1877 1
	if (tul_wait(sc, iot, ioh, MSG_ACCEPT) == -1)
d1880 1
a1880 1
	return(tul_next_state(sc, iot, ioh));
d1883 2
a1884 2
static int
tul_msgin(sc, iot, ioh)
d1899 1
a1899 1
		phase = tul_wait(sc, iot, ioh, XF_FIFO_IN);
d1905 2
a1906 2
			if (tul_wait(sc, iot, ioh, MSG_ACCEPT) != -1)
				tul_bad_seq(sc);
d1912 1
a1912 1
			phase = tul_wait(sc, iot, ioh, MSG_ACCEPT);
d1916 1
a1916 1
			tul_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
d1919 2
a1920 2
				tul_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
			phase = tul_wait(sc, iot, ioh, MSG_ACCEPT);
d1923 1
a1923 1
			phase = tul_msgin_extended(sc, iot, ioh);
d1926 1
a1926 1
			phase = tul_msgin_ignore_wid_resid(sc, iot, ioh);
d1931 1
a1931 1
			phase = tul_wait(sc, iot, ioh, MSG_ACCEPT);
d1933 1
a1933 1
				tul_bad_seq(sc);
d1938 2
a1939 2
			printf("[debug] tul_msgin: bad msg type: %d\n", msg);
			phase = tul_msgout_reject(sc, iot, ioh);
d1949 2
a1950 2
static int
tul_msgin_ignore_wid_resid(sc, iot, ioh)
d1957 1
a1957 1
	phase = tul_wait(sc, iot, ioh, MSG_ACCEPT);
d1960 1
a1960 1
		phase = tul_wait(sc, iot, ioh, XF_FIFO_IN);
d1967 1
a1967 1
			phase = tul_wait(sc, iot, ioh, MSG_ACCEPT);
d1974 2
a1975 2
static int
tul_msgin_extended(sc, iot, ioh)
d1987 1
a1987 1
		phase = tul_wait(sc, iot, ioh, MSG_ACCEPT);
d1994 1
a1994 1
		if (tul_wait(sc, iot, ioh, XF_FIFO_IN) == -1)
d2007 3
a2009 3
		if (tul_msgin_sdtr(sc) == 0) {
			tul_sync_done(sc, iot, ioh);
			return (tul_wait(sc, iot, ioh, MSG_ACCEPT));
d2012 1
a2012 1
		tul_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
d2014 1
a2014 1
		phase = tul_wait(sc, iot, ioh, MSG_ACCEPT);
d2021 1
a2021 1
		tul_sync_done(sc, iot, ioh); /* This is our final offer */
d2031 1
a2031 1
			return (tul_msgout_reject(sc, iot, ioh));
d2037 1
a2037 1
			tul_wide_done(sc, iot, ioh);
d2039 2
a2040 2
				tul_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
			return (tul_wait(sc, iot, ioh, MSG_ACCEPT));
d2043 1
a2043 1
		tul_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
d2045 1
a2045 1
		phase = tul_wait(sc, iot, ioh, MSG_ACCEPT);
d2050 1
a2050 1
		return (tul_msgout_reject(sc, iot, ioh));
d2053 1
a2053 1
	return (tul_msgout_extended(sc, iot, ioh));
d2057 1
a2057 1
 * tul_msgin_sdtr - check SDTR msg in HCS_Msg. If the offer is
d2062 2
a2063 2
static int
tul_msgin_sdtr(sc)
d2072 1
a2072 1
	default_period = tul_rate_tbl[flags & FLAG_SCSI_RATE];
d2102 2
a2103 2
static int
tul_msgout(sc, iot, ioh, msg)
d2111 1
a2111 1
	return (tul_wait(sc, iot, ioh, XF_FIFO_OUT));
d2114 2
a2115 2
static void
tul_msgout_abort(sc, iot, ioh,	aborttype)
d2121 1
a2121 1
	tul_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
d2123 1
a2123 1
	switch (tul_wait(sc, iot, ioh, MSG_ACCEPT)) {
d2129 2
a2130 2
		if (tul_msgout(sc, iot, ioh, aborttype) != -1)
			tul_bad_seq(sc);
d2134 1
a2134 1
		tul_bad_seq(sc);
d2139 2
a2140 2
static int
tul_msgout_reject(sc, iot, ioh)
d2145 1
a2145 1
	tul_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
d2147 2
a2148 2
	if (tul_wait(sc, iot, ioh, MSG_ACCEPT) == PHASE_MSG_OUT)
		return (tul_msgout(sc, iot, ioh, MSG_MESSAGE_REJECT));
d2153 2
a2154 2
static int
tul_msgout_extended(sc, iot, ioh)
d2166 1
a2166 1
	phase = tul_wait(sc, iot, ioh, XF_FIFO_OUT);
d2169 1
a2169 1
	tul_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
d2174 2
a2175 2
static int
tul_msgout_wdtr(sc, iot, ioh)
d2186 1
a2186 1
	return (tul_msgout_extended(sc, iot, ioh));
d2189 2
a2190 2
static int
tul_msgout_sdtr(sc, iot, ioh)
d2200 1
a2200 1
	sync_rate = tul_rate_tbl[rateindex];
d2207 1
a2207 1
	return (tul_msgout_extended(sc, iot, ioh));
d2210 2
a2211 2
static void
tul_wide_done(sc, iot, ioh)
d2231 2
a2232 2
static void
tul_sync_done(sc, iot, ioh)
d2246 1
a2246 1
				if (tul_rate_tbl[i] >= sc->HCS_Msg[2])
d2261 1
a2261 1
tul_reset_chip(sc, iot, ioh)
d2276 1
a2276 1
	tul_set_ssig(iot, ioh, 0, 0);
d2287 2
a2288 2
static void
tul_select(sc, iot, ioh, pScb, select_type)
d2320 1
a2320 1
		printf("[debug] tul_select() - unknown select type = 0x%02x\n",
d2325 1
a2325 1
	tul_del_pend_scb(sc, pScb);
d2334 1
a2334 1
 * tul_wait - wait for an interrupt to service or a SCSI bus phase change
d2338 2
a2339 2
static int
tul_wait(sc, iot, ioh, cmd)
d2363 1
a2363 1
		tul_reset_scsi_bus(sc);
d2369 1
a2369 1
		return (tul_resel(sc, iot, ioh));
d2373 1
a2373 1
		tul_busfree(sc, iot, ioh);
d2384 1
a2384 1
			tul_append_done_scb(sc, sc->HCS_ActScb, HOST_OK);
d2396 1
a2396 1
			tul_busfree(sc, iot, ioh);
d2405 1
a2405 1
 * tul_done_scb - We have a scb which has been processed by the
d2408 2
a2409 2
static void
tul_done_scb(sc, pScb)
d2489 1
a2489 1
	tul_append_free_scb(sc, pScb);
d2492 2
a2493 2
static void
tul_timeout(arg)
d2501 1
a2501 1
		printf("[debug] tul_timeout called with xs == NULL\n");
d2508 1
a2508 1
		tul_abort_xs(xs->sc_link->adapter_softc, xs, HOST_TIMED_OUT);
d2512 2
a2513 2
static void
tul_exec_scb(sc, pScb)
d2525 1
a2525 1
		tul_push_pend_scb(sc, pScb);   /* Insert SCB at head of Pend */
d2527 1
a2527 1
		tul_append_pend_scb(sc, pScb); /* Append SCB to tail of Pend */
d2530 1
a2530 1
	 * Run through tul_main() to ensure something is active, if
d2541 1
a2541 1
		tul_main(sc, iot, ioh);
d2553 1
a2553 1
 * tul_set_ssig - read the current scsi signal mask, then write a new
d2556 2
a2557 2
static void
tul_set_ssig( iot, ioh, offsigs, onsigs)
d2568 2
a2569 2
static void
tul_print_info(sc, target)
d2598 1
a2598 1
 * tul_alloc_scbs - allocate and map the SCB's for the supplied IHA_SOFTC
d2600 2
a2601 2
static int
tul_alloc_scbs(sc)
d2654 1
a2654 1
 * tul_read_eeprom - read Serial EEPROM value & set to defaults
d2658 1
a2658 1
tul_read_eeprom(iot, ioh)
d2664 1
a2664 1
	/*------Enable EEProm programming ---*/
d2668 3
a2670 6
	/*------ Program default pattern ----*/
	if (tul_se2_rd_all(iot, ioh) == 0) {
		tul_se2_update_all(iot, ioh);
		if(tul_se2_rd_all(iot, ioh) == 0)
			panic("could not program iha Tulip EEPROM\n");
	}
d2672 1
a2672 1
	/*------ Disable EEProm programming ---*/
d2678 1
a2678 88
 * tul_se2_update_all - Update SCSI H/A configuration parameters from
 *			serial EEPROM Setup default pattern. Only
 *			change those values different from the values
 *			in tul_nvram.
 */
void
tul_se2_update_all(iot, ioh)
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
{
	u_int16_t *np, *np1;
	u_int32_t chksum;
	u_int8_t i;

	/* Enable erase/write state of EEPROM */
	tul_se2_instr(iot, ioh, ENABLE_ERASE);
	bus_space_write_1(iot, ioh, TUL_NVRAM, 0);
	DELAY(5);

	np  = (u_int16_t *)tul_dftNvRam;
	np1 = (u_int16_t *)&tul_nvram;

	for (i = 0, chksum = 0; i < 31; i++, np++, np1++) {
		if (*np != *np1)
			tul_se2_wr(iot, ioh, i, *np);
		chksum += *np;
	}

	chksum &= 0x0000ffff;
	tul_se2_wr(iot, ioh, 31, chksum);

	/* Disable erase/write state of EEPROM */
	tul_se2_instr(iot, ioh, 0);
	bus_space_write_1(iot, ioh, TUL_NVRAM, 0);
	DELAY(5);
}

/*
 * tul_se2_wr - write the given 16 bit value into the Serial EEPROM
 *		at the specified offset
 */
void
tul_se2_wr(iot, ioh, addr, writeWord)
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
	u_int8_t	   addr;
	u_int16_t	   writeWord;
{
	u_int8_t bit;
	int i;

	/* send 'WRITE' Instruction == address | WRITE bit */
	tul_se2_instr(iot, ioh, (addr | WRITE));

	for (i = 15; i >= 0; i--, writeWord <<= 1) {
		if (writeWord & 0x8000)
			bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS | NVRDO);
		else
			bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS);
		DELAY(5);
		bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS | NVRCK);
		DELAY(5);
	}

	bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS);
	DELAY(5);
	bus_space_write_1(iot, ioh, TUL_NVRAM, 0);
	DELAY(5);
	bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS);
	DELAY(5);

	for (;;) {
		bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS | NVRCK);
		DELAY(5);
		bus_space_write_1(iot, ioh, TUL_NVRAM, NVRCS);
		DELAY(5);
		bit = bus_space_read_1(iot, ioh, TUL_NVRAM) & NVRDI;
		DELAY(5);
		if (bit != 0)
			break; /* write complete */
	}

	bus_space_write_1(iot, ioh, TUL_NVRAM, 0);
	DELAY(5);
}

/*
 * tul_se2_rd - read & return the 16 bit value at the specified
d2683 1
a2683 1
tul_se2_rd(iot, ioh, addr)
d2693 1
a2693 1
	tul_se2_instr(iot, ioh, (addr | READ));
d2717 2
a2718 2
 * tul_se2_rd_all - Read SCSI H/A config parameters from serial EEPROM
 *		    into tul_nvram static variable.
d2721 1
a2721 1
tul_se2_rd_all(iot, ioh)
d2725 1
a2725 1
	u_int16_t *np, *np1;
d2729 1
a2729 2
	np = (u_int16_t *)&tul_nvram;
	np1 = (u_int16_t *)&tul_dftNvRam;
d2731 2
a2732 2
	for (i = 0, chksum = 0; i < 31; i++, np++, np1++) {
		*np = tul_se2_rd(iot, ioh, i);
d2735 1
a2735 1
	*np = tul_se2_rd(iot, ioh, 31); /* read checksum from eeprom */
d2739 1
a2739 1
	return (tul_nvram.NVM_Signature == SIGNATURE)
d2741 1
a2741 1
	       (tul_nvram.NVM_CheckSum	== chksum);
d2745 1
a2745 1
 * tul_se2_instr - write an octet to serial E2PROM one bit at a time
d2748 1
a2748 1
tul_se2_instr(iot, ioh, instr)
d2782 1
a2782 1
 * tul_reset_tcs - reset the target control structure pointed
d2788 1
a2788 1
tul_reset_tcs(pTcs, config0)
@


1.5
log
@Minor code clean ups.

Rename some functions for better consistancy/clarity, e.g.

   tul_wdtr_done -> tul_wide_done
   tul_msgout_wide -> tul_msgout_wdtr

Consolidate extended message generation into new function
tul_msgout_extended() by using HCS_Msg[] array, replacing
several repetitive bus_write_*() code sections.

A couple of minor code clarifications to eliminate extra
return statements and make absolutely sure HCS_ActScb is
NULL during a reselect.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.4 2001/07/09 15:20:28 krw Exp $ */
d471 1
a471 1
		    + OFFSETOF(struct iha_scsi_req_q, SCB_SGList);
d476 1
a476 1
		    + OFFSETOF(struct iha_scsi_req_q, SCB_ScsiSenseData);
@


1.4
log
@Fix incorrect logic 'optimization' so that sync is negotiated even if
wide is not.

Now my CD drives on the narrow channel of the INI-9100UW negotiate to
the same configuration they do on other cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.3 2001/02/20 00:47:33 krw Exp $ */
d195 1
a195 1
static void tul_wdtr_done __P((struct iha_softc *,
d233 2
a234 2
static int  tul_msgin_sync   __P((struct iha_softc *));
static int  tul_msgin_extend __P((struct iha_softc *,
d243 2
d250 1
a250 1
static int  tul_msgout_sync   __P((struct iha_softc *,
d252 1
a252 1
static int  tul_msgout_wide   __P((struct iha_softc *,
d1280 1
a1280 1
			if (tul_msgout_wide(sc, iot, ioh) == -1)
d1283 1
a1283 1
			if (tul_msgout_sync(sc, iot, ioh) == -1)
d1366 1
a1366 1
			} else if (tul_msgout_sync(sc, iot, ioh) == -1)
d1889 2
a1890 3
			tul_push_pend_scb(sc, sc->HCS_ActScb); /* sets ActScb to NULL */
		else
			sc->HCS_ActScb = NULL;
d2006 1
a2006 1
			phase = tul_msgin_extend(sc, iot, ioh);
d2043 1
a2043 2
		if (tul_wait(sc, iot, ioh, XF_FIFO_IN) == -1)
			return (-1);
d2045 4
a2048 3
		bus_space_write_1(iot, ioh, TUL_SFIFO, 0); /* put pad	     */
		bus_space_read_1 (iot, ioh, TUL_SFIFO);	   /* get IGNORE     */
		bus_space_read_1 (iot, ioh, TUL_SFIFO);	   /* get pad	     */
d2050 2
a2051 1
		return (tul_wait(sc, iot, ioh, MSG_ACCEPT));
d2053 2
a2054 2
	else
		return (phase);
d2058 1
a2058 1
tul_msgin_extend(sc, iot, ioh)
d2090 1
a2090 1
		if (tul_msgin_sync(sc) == 0) {
a2105 6
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXTENDED);
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXT_SDTR_LEN);
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXT_SDTR);
		bus_space_write_1(iot, ioh, TUL_SFIFO, sc->HCS_Msg[2]);
		bus_space_write_1(iot, ioh, TUL_SFIFO, sc->HCS_Msg[3]);

d2120 1
a2120 1
			tul_wdtr_done(sc, iot, ioh);
a2131 6
		/* WDTR msg out */
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXTENDED);
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXT_WDTR_LEN);
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXT_WDTR);
		bus_space_write_1(iot, ioh, TUL_SFIFO, sc->HCS_Msg[2]);

d2135 2
a2136 1
	return (tul_wait(sc, iot, ioh, XF_FIFO_OUT));
d2140 1
a2140 1
 * tul_msgin_sync - check SDTR msg in HCS_Msg. If the offer is
d2146 1
a2146 1
tul_msgin_sync(sc)
a2210 2
		bus_space_write_1(iot, ioh, TUL_SFIFO, aborttype );

d2212 1
a2212 2

		if (tul_wait(sc, iot, ioh, XF_FIFO_OUT) != -1)
a2227 2
	int phase;

d2230 2
a2231 2
	if ((phase = tul_wait(sc, iot, ioh, MSG_ACCEPT)) == -1)
		return (-1);
d2233 1
a2233 6
	if (phase == PHASE_MSG_OUT) {
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_MESSAGE_REJECT);
		return (tul_wait(sc, iot, ioh, XF_FIFO_OUT));
	}

	return (phase);
d2237 1
a2237 1
tul_msgout_wide(sc, iot, ioh)
d2244 1
a2244 1
	sc->HCS_ActScb->SCB_Tcs->TCS_Flags |= FLAG_WIDE_DONE;
d2246 2
a2247 4
	bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXTENDED);
	bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXT_WDTR_LEN);
	bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXT_WDTR);
	bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXT_WDTR_BUS_16_BIT);
d2258 16
a2273 1
tul_msgout_sync(sc, iot, ioh)
a2279 1
	int phase;
d2285 4
a2288 5
	bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXTENDED);
	bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXT_SDTR_LEN);
	bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXT_SDTR);
	bus_space_write_1(iot, ioh, TUL_SFIFO, sync_rate);
	bus_space_write_1(iot, ioh, TUL_SFIFO, IHA_MAX_TARGETS-1); /* REQ/ACK*/
d2290 1
a2290 6
	phase = tul_wait(sc, iot, ioh, XF_FIFO_OUT);

	bus_space_write_1(iot, ioh, TUL_SCTRL0, RSFIFO);
	tul_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);

	return (phase);
d2294 1
a2294 1
tul_wdtr_done(sc, iot, ioh)
d2909 1
a2909 1
	*np = tul_se2_rd(iot, ioh, 31); /* just read checksum		    */
d2911 1
a2911 1
	chksum &= 0x0000ffff;		/* checksum is lower 16 bits of sum */
@


1.3
log
@Tone down the verbosity level slightly on the iha driver, print
negotiation results on one line, during boot polling only, in same
format as now used in siop.

Move checking for probe INQUIRY commands to poll loop rather than
checking every good I/O.

Remove an unwanted debug statement and unneeded (resolved) XXX
comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.2 2001/02/08 17:35:05 krw Exp $ */
d1057 3
a1059 1
		if ((pTcs->TCS_Flags & FLAG_NO_NEGOTIATE) == 0)
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.3 2001/02/20 00:47:33 krw Exp $ */
@


1.3.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.3.4.1 2001/05/14 22:23:52 niklas Exp $ */
d5 1
a5 1
 * Copyright (c) 2000-2001 Ken Westerback
d81 1
a81 1
static const u_int8_t iha_rate_tbl[8] = {
d94 74
a167 77
u_int8_t iha_data_over_run __P((struct iha_scsi_req_q *));
void iha_push_sense_request __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_timeout __P((void *));
int  iha_alloc_scbs __P((struct iha_softc *));
void iha_read_eeprom __P((bus_space_tag_t, bus_space_handle_t,
			     struct iha_nvram *));
void iha_se2_instr __P((bus_space_tag_t, bus_space_handle_t, u_int8_t));
u_int16_t iha_se2_rd __P((bus_space_tag_t, bus_space_handle_t, u_int8_t));
void iha_reset_scsi_bus __P((struct iha_softc *));
void iha_reset_chip __P((struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t));
void iha_reset_dma __P((bus_space_tag_t, bus_space_handle_t));
void iha_reset_tcs __P((struct tcs *, u_int8_t));
void iha_print_info __P((struct iha_softc *, int));
void iha_done_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_exec_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_main __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t));
void iha_scsi __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t));
int  iha_wait __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t,
		      u_int8_t));
void iha_mark_busy_scb __P((struct iha_scsi_req_q *));
void iha_append_free_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
struct iha_scsi_req_q *iha_pop_free_scb __P((struct iha_softc *));
void iha_append_done_scb __P((struct iha_softc *, struct iha_scsi_req_q *,
				 u_int8_t));
struct iha_scsi_req_q *iha_pop_done_scb __P((struct iha_softc *));
void iha_append_pend_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_push_pend_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
void iha_del_pend_scb __P((struct iha_softc *, struct iha_scsi_req_q *));
struct iha_scsi_req_q *iha_find_pend_scb __P((struct iha_softc *));
void iha_sync_done __P((struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t));
void iha_wide_done __P((struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t));
void iha_bad_seq __P((struct iha_softc *));
int  iha_next_state __P((struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t));
int  iha_state_1 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_2 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_3 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_4 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_5 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_6 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_state_8 __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
void iha_set_ssig __P((bus_space_tag_t,
			  bus_space_handle_t, u_int8_t, u_int8_t));
int  iha_xpad_in __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_xpad_out __P((struct iha_softc *,
			  bus_space_tag_t, bus_space_handle_t));
int  iha_xfer_data __P((struct iha_scsi_req_q *,
			   bus_space_tag_t, bus_space_handle_t,
			   int direction));
int  iha_status_msg __P((struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t));
int  iha_msgin __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t));
int  iha_msgin_sdtr __P((struct iha_softc *));
int  iha_msgin_extended __P((struct iha_softc *,
				bus_space_tag_t, bus_space_handle_t));
int  iha_msgin_ignore_wid_resid __P((struct iha_softc *,
					bus_space_tag_t, bus_space_handle_t));
int  iha_msgout __P((struct iha_softc *,
			bus_space_tag_t, bus_space_handle_t, u_int8_t));
int  iha_msgout_extended __P((struct iha_softc *,
				 bus_space_tag_t, bus_space_handle_t));
void iha_msgout_abort __P((struct iha_softc *,
			      bus_space_tag_t, bus_space_handle_t,  u_int8_t));
int  iha_msgout_reject __P((struct iha_softc *,
			       bus_space_tag_t, bus_space_handle_t));
int  iha_msgout_sdtr __P((struct iha_softc *,
d169 1
a169 1
int  iha_msgout_wdtr __P((struct iha_softc *,
d171 93
a263 7
void iha_select __P((struct iha_softc *,
			bus_space_tag_t, bus_space_handle_t,
			struct iha_scsi_req_q *, u_int8_t));
void iha_busfree __P((struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t));
int  iha_resel __P((struct iha_softc *, bus_space_tag_t, bus_space_handle_t));
void iha_abort_xs __P((struct iha_softc *, struct scsi_xfer *, u_int8_t));
d291 1
a291 1
		iha_main(sc, iot, ioh);
d323 1
a323 1
	pScb = iha_pop_free_scb(sc);
d370 1
a370 1
			iha_append_free_scb(sc, pScb); 
d394 1
a394 2
		iha_bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap, 
		    0, pScb->SCB_Dmamap->dm_mapsize,
d407 1
a407 1
	timeout_set(&xs->stimeout, iha_timeout, pScb);
d411 1
a411 1
	iha_exec_scb(sc, pScb);
d420 2
a421 2
 * iha_init_tulip - initialize the inic-940/950 card and the rest of the
 *		    iha_softc structure supplied
a427 1
	struct iha_nvram_scsi *pScsi;
d429 1
a429 1
	struct iha_nvram iha_nvram;
d436 1
a436 1
	iha_read_eeprom(iot, ioh, &iha_nvram);
d438 1
a438 1
	pScsi = &iha_nvram.NVM_Scsi[0];
d451 1
a451 1
	 * fill in the rest of the iha_softc fields
d461 1
a461 1
	error = iha_alloc_scbs(sc);
d469 1
a469 1
		    + offsetof(struct iha_scsi_req_q, SCB_SGList);
d474 1
a474 1
		    + offsetof(struct iha_scsi_req_q, SCB_ScsiSenseData);
d493 1
a493 1
	iha_reset_dma(iot, ioh);
d501 1
a501 1
	 * into iha_nvram by iha_read_eeprom() above.
d523 1
a523 1
		iha_reset_tcs(&sc->HCS_Tcs[i], sc->HCS_SConf1);
d526 1
a526 1
	iha_reset_chip(sc, iot, ioh);
d549 1
a549 1
 * iha_reset_dma - abort any active DMA xfer, reset tulip FIFO.
d551 2
a552 2
void
iha_reset_dma(iot, ioh)
d568 1
a568 1
 * iha_pop_free_scb - return the first free SCB, or NULL if there are none.
d570 2
a571 2
struct iha_scsi_req_q *
iha_pop_free_scb(sc)
d592 1
a592 1
 * iha_append_free_scb - append the supplied SCB to the tail of the
d596 2
a597 2
void
iha_append_free_scb(sc, pScb)
d605 3
d647 2
a648 2
void
iha_append_pend_scb(sc, pScb)
d662 2
a663 2
void
iha_push_pend_scb(sc, pScb)
d682 1
a682 1
 * iha_find_pend_scb - scan the pending queue for a SCB that can be
d687 2
a688 2
struct iha_scsi_req_q *
iha_find_pend_scb(sc)
d743 1
a743 1
 * iha_del_pend_scb - remove pScb from HCS_PendScb
d745 2
a746 2
void
iha_del_pend_scb(sc, pScb)
d759 2
a760 2
void
iha_mark_busy_scb(pScb)
d777 2
a778 2
void
iha_append_done_scb(sc, pScb, hastat)
d810 2
a811 2
struct iha_scsi_req_q *
iha_pop_done_scb(sc)
d832 1
a832 1
 * iha_abort_xs - find the SCB associated with the supplied xs and
d836 2
a837 2
void
iha_abort_xs(sc, xs, hastat)
d851 2
a852 2
			iha_del_pend_scb(sc, pScb);
			iha_append_done_scb(sc, pScb, hastat);
d867 1
a867 1
				iha_append_done_scb(sc, pScb, hastat);
d880 1
a880 1
 * iha_bad_seq - a SCSI bus phase was encountered out of the
d883 2
a884 2
void
iha_bad_seq(sc)
d890 1
a890 1
		iha_append_done_scb(sc, pScb, HOST_BAD_PHAS);
d892 2
a893 2
	iha_reset_scsi_bus(sc);
	iha_reset_chip(sc, sc->sc_iot, sc->sc_ioh);
d897 1
a897 1
 * iha_push_sense_request - obtain auto sense data by pushing the
d901 2
a902 2
void
iha_push_sense_request(sc, pScb)
d927 1
a927 1
	iha_push_pend_scb(sc, pScb);
d931 1
a931 1
 * iha_main - process the active SCB, taking one off pending and making it
d936 2
a937 2
void
iha_main(sc, iot, ioh)
d945 2
a946 2
iha_scsi_label:
		iha_scsi(sc, iot, ioh);
d948 1
a948 1
		while ((pScb = iha_pop_done_scb(sc)) != NULL) {
d962 2
a963 2
					iha_push_sense_request(sc, pScb);
					goto iha_scsi_label;
d978 1
a978 1
			iha_done_scb(sc, pScb);
d985 1
a985 1
		 * iha_scsi().
d988 1
a988 1
		    && (iha_find_pend_scb(sc) == NULL))
d994 1
a994 1
 * iha_scsi - service any outstanding interrupts. If there are none, try to
d997 2
a998 2
void
iha_scsi(sc, iot, ioh)
d1018 1
a1018 1
			iha_reset_scsi_bus(sc);
d1023 1
a1023 1
			iha_resel(sc, iot, ioh);
d1028 1
a1028 1
			iha_busfree(sc, iot, ioh);
d1033 1
a1033 1
			iha_next_state(sc, iot, ioh);
d1038 1
a1038 1
			iha_set_ssig(iot, ioh, 0, 0);
d1045 1
a1045 1
	if ((pScb = iha_find_pend_scb(sc)) == NULL)
d1057 2
a1058 4
		if (((pTcs->TCS_Flags & FLAG_NO_NEG_WIDE) == 0)
		    ||
		    ((pTcs->TCS_Flags & FLAG_NO_NEG_SYNC) == 0))
			iha_select(sc, iot, ioh, pScb, SELATNSTOP);
d1061 1
a1061 1
			iha_select(sc, iot, ioh, pScb, SEL_ATN3);
d1064 1
a1064 1
			iha_select(sc, iot, ioh, pScb, SEL_ATN);
d1067 1
a1067 1
		iha_select(sc, iot, ioh, pScb, SELATNSTOP);
d1073 1
a1073 1
			if (iha_wait(sc, iot, ioh, NO_OP) == -1)
d1075 1
a1075 1
			if (iha_next_state(sc, iot, ioh) == -1)
d1088 1
a1088 1
			iha_timeout(pScb);
d1094 1
a1094 1
			iha_print_info(sc, pScb->SCB_Target);
d1099 1
a1099 1
 * iha_data_over_run - return HOST_OK for all SCSI opcodes where BufLen
d1108 2
a1109 2
u_int8_t
iha_data_over_run(pScb)
d1160 1
a1160 1
 * iha_next_state - prcess the current SCB as requested in it's 
d1163 2
a1164 2
int
iha_next_state(sc, iot, ioh)
d1174 1
a1174 1
		if (iha_state_1(sc, iot, ioh) == 3)
d1179 1
a1179 1
		switch (iha_state_2(sc, iot, ioh)) {
d1188 1
a1188 1
		if (iha_state_3(sc, iot, ioh) == 4)
d1194 1
a1194 1
		switch (iha_state_4(sc, iot, ioh)) {
d1202 1
a1202 1
		switch (iha_state_5(sc, iot, ioh)) {
d1211 1
a1211 1
		iha_state_6(sc, iot, ioh);
d1215 1
a1215 1
		iha_state_8(sc, iot, ioh);
d1223 1
a1223 1
		iha_bad_seq(sc);
d1231 1
a1231 1
 * iha_state_1 - selection is complete after a SELATNSTOP. If the target
d1236 2
a1237 2
int
iha_state_1(sc, iot, ioh)
d1246 1
a1246 1
	iha_mark_busy_scb(pScb);
d1276 1
a1276 1
			if (iha_msgout_wdtr(sc, iot, ioh) == -1)
d1279 1
a1279 1
			if (iha_msgout_sdtr(sc, iot, ioh) == -1)
d1285 1
a1285 1
		iha_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
d1292 1
a1292 1
 * iha_state_2 - selection is complete after a SEL_ATN or SEL_ATN3. If the SCSI
d1297 2
a1298 2
int
iha_state_2(sc, iot, ioh)
d1305 1
a1305 1
	iha_mark_busy_scb(pScb);
d1314 1
a1314 1
	iha_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
d1320 1
a1320 1
 * iha_state_3 - send the SCSI CDB to the target, processing any status
d1324 2
a1325 2
int
iha_state_3(sc, iot, ioh)
d1338 1
a1338 1
			if (iha_wait(sc, iot, ioh, XF_FIFO_OUT) == -1)
d1341 1
a1341 1
				iha_bad_seq(sc);
d1348 1
a1348 1
			if (iha_msgin(sc, iot, ioh) == -1)
d1353 1
a1353 1
			if (iha_status_msg(sc, iot, ioh) == -1)
d1360 1
a1360 1
				if (iha_msgout(sc, iot, ioh, MSG_NOOP) == -1)
d1362 1
a1362 1
			} else if (iha_msgout_sdtr(sc, iot, ioh) == -1)
d1368 1
a1368 1
			iha_bad_seq(sc);
d1374 1
a1374 1
 * iha_state_4 - start a data xfer. Handle any bus state
d1380 2
a1381 2
int
iha_state_4(sc, iot, ioh)
d1398 2
a1399 2
				pScb->SCB_HaStat = iha_data_over_run(pScb);
			if ((iha_status_msg(sc, iot, ioh)) == -1)
d1405 1
a1405 1
			if (iha_msgin(sc, iot, ioh) == -1)
d1413 1
a1413 1
				if (iha_msgout(sc, iot, ioh,
d1419 1
a1419 1
				if (iha_msgout(sc, iot, ioh, MSG_NOOP) == -1)
d1425 1
a1425 1
			return (iha_xfer_data(pScb, iot, ioh, SCSI_DATA_IN));
d1428 1
a1428 1
			return (iha_xfer_data(pScb, iot, ioh, SCSI_DATA_OUT));
d1431 1
a1431 1
			iha_bad_seq(sc);
d1438 1
a1438 1
 * iha_state_5 - handle the partial or final completion of the current
d1443 2
a1444 2
int
iha_state_5(sc, iot, ioh)
d1495 1
a1495 1
			if (iha_wait(sc, iot, ioh, XF_FIFO_OUT) == -1)
d1540 1
a1540 1
 * iha_state_6 - finish off the active scb (may require several
d1544 2
a1545 2
int
iha_state_6(sc, iot, ioh)
d1553 1
a1553 1
			if (iha_status_msg(sc, iot, ioh) == -1)
d1559 1
a1559 1
			if ((iha_msgin(sc, iot, ioh)) == -1)
d1564 1
a1564 1
			if ((iha_msgout(sc, iot, ioh, MSG_NOOP)) == -1)
d1569 1
a1569 1
			if (iha_xpad_in(sc, iot, ioh) == -1)
d1574 1
a1574 1
			if (iha_xpad_out(sc, iot, ioh) == -1)
d1579 1
a1579 1
			iha_bad_seq(sc);
d1585 1
a1585 1
 * iha_state_8 - reset the active device and all busy SCBs using it
d1587 2
a1588 2
int
iha_state_8(sc, iot, ioh)
d1603 1
a1603 1
		iha_append_done_scb(sc, pScb, HOST_OK);
d1605 1
a1605 1
		iha_reset_tcs(pScb->SCB_Tcs, sc->HCS_SConf1);
d1612 1
a1612 1
					iha_append_done_scb(sc,
d1617 1
a1617 1
					iha_push_pend_scb(sc, pScb);
d1626 1
a1626 1
		if (iha_wait(sc, iot, ioh, XF_FIFO_OUT) == -1)
d1630 1
a1630 1
	iha_bad_seq(sc);
d1635 1
a1635 1
 * iha_xfer_data - initiate the DMA xfer of the data
d1637 2
a1638 2
int
iha_xfer_data(pScb, iot, ioh, direction)
d1673 2
a1674 2
int
iha_xpad_in(sc, iot, ioh)
d1690 1
a1690 1
		switch (iha_wait(sc, iot, ioh, XF_FIFO_IN)) {
d1705 2
a1706 2
int
iha_xpad_out(sc, iot, ioh)
d1724 1
a1724 1
		switch (iha_wait(sc, iot, ioh, XF_FIFO_OUT)) {
d1740 2
a1741 2
int
iha_status_msg(sc, iot, ioh)
d1750 1
a1750 1
	if ((phase = iha_wait(sc, iot, ioh, CMD_COMP)) == -1)
d1765 1
a1765 1
		return (iha_wait(sc, iot, ioh, XF_FIFO_OUT));
d1771 1
a1771 1
			switch (iha_wait(sc, iot, ioh, MSG_ACCEPT)) {
d1777 1
a1777 1
				return (iha_wait(sc, iot, ioh, XF_FIFO_OUT));
d1779 1
a1779 1
				iha_bad_seq(sc);
d1786 1
a1786 1
				iha_bad_seq(sc);
d1791 1
a1791 1
			return (iha_wait(sc, iot, ioh, MSG_ACCEPT));
d1798 1
a1798 1
				return (iha_wait(sc, iot, ioh, MSG_ACCEPT));
d1802 1
a1802 1
	iha_bad_seq(sc);
d1807 1
a1807 1
 * iha_busfree - SCSI bus free detected as a result of a TIMEOUT or
d1813 2
a1814 2
void
iha_busfree(sc, iot, ioh)
d1830 1
a1830 1
			iha_append_done_scb(sc, pScb, HOST_SEL_TOUT);
d1833 1
a1833 1
			iha_append_done_scb(sc, pScb, HOST_BAD_PHAS);
d1838 2
a1839 2
void
iha_reset_scsi_bus(sc)
d1848 1
a1848 1
	iha_reset_dma(sc->sc_iot, sc->sc_ioh);
d1853 1
a1853 1
			iha_append_done_scb(sc, pScb, HOST_SCSI_RST);
d1857 1
a1857 1
			iha_push_pend_scb(sc, pScb);
d1865 1
a1865 1
		iha_reset_tcs(pTcs, sc->HCS_SConf1);
d1871 1
a1871 1
 * iha_resel - handle a detected SCSI bus reselection request.
d1873 2
a1874 2
int
iha_resel(sc, iot, ioh)
d1885 3
a1887 2
			iha_push_pend_scb(sc, sc->HCS_ActScb);
		sc->HCS_ActScb = NULL;
d1912 1
a1912 1
		switch (iha_wait(sc, iot, ioh, MSG_ACCEPT)) {
d1917 1
a1917 1
			if ((iha_wait(sc, iot, ioh, XF_FIFO_IN)) == -1)
d1929 1
a1929 1
		switch (iha_wait(sc, iot, ioh, MSG_ACCEPT)) {
d1934 1
a1934 1
			if ((iha_wait(sc, iot, ioh, XF_FIFO_IN)) == -1)
d1951 1
a1951 1
		iha_msgout_abort(sc, iot, ioh, abortmsg);
d1957 1
a1957 1
	if (iha_wait(sc, iot, ioh, MSG_ACCEPT) == -1)
d1960 1
a1960 1
	return(iha_next_state(sc, iot, ioh));
d1963 2
a1964 2
int
iha_msgin(sc, iot, ioh)
d1979 1
a1979 1
		phase = iha_wait(sc, iot, ioh, XF_FIFO_IN);
d1985 2
a1986 2
			if (iha_wait(sc, iot, ioh, MSG_ACCEPT) != -1)
				iha_bad_seq(sc);
d1992 1
a1992 1
			phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
d1996 1
a1996 1
			iha_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
d1999 2
a2000 2
				iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
			phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
d2003 1
a2003 1
			phase = iha_msgin_extended(sc, iot, ioh);
d2006 1
a2006 1
			phase = iha_msgin_ignore_wid_resid(sc, iot, ioh);
d2011 1
a2011 1
			phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
d2013 1
a2013 1
				iha_bad_seq(sc);
d2018 2
a2019 2
			printf("[debug] iha_msgin: bad msg type: %d\n", msg);
			phase = iha_msgout_reject(sc, iot, ioh);
d2029 2
a2030 2
int
iha_msgin_ignore_wid_resid(sc, iot, ioh)
d2037 1
a2037 1
	phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
d2040 2
a2041 1
		phase = iha_wait(sc, iot, ioh, XF_FIFO_IN);
d2043 3
a2045 4
		if (phase != -1) {
			bus_space_write_1(iot, ioh, TUL_SFIFO, 0);
			bus_space_read_1 (iot, ioh, TUL_SFIFO);
			bus_space_read_1 (iot, ioh, TUL_SFIFO);
d2047 1
a2047 2
			phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
		}
d2049 2
a2050 2

	return (phase);
d2053 2
a2054 2
int
iha_msgin_extended(sc, iot, ioh)
d2066 1
a2066 1
		phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
d2073 1
a2073 1
		if (iha_wait(sc, iot, ioh, XF_FIFO_IN) == -1)
d2086 3
a2088 3
		if (iha_msgin_sdtr(sc) == 0) {
			iha_sync_done(sc, iot, ioh);
			return (iha_wait(sc, iot, ioh, MSG_ACCEPT));
d2091 1
a2091 1
		iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
d2093 1
a2093 1
		phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
d2100 7
a2106 1
		iha_sync_done(sc, iot, ioh); /* This is our final offer */
d2116 1
a2116 1
			return (iha_msgout_reject(sc, iot, ioh));
d2122 1
a2122 1
			iha_wide_done(sc, iot, ioh);
d2124 2
a2125 2
				iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
			return (iha_wait(sc, iot, ioh, MSG_ACCEPT));
d2128 1
a2128 1
		iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
d2130 1
a2130 1
		phase = iha_wait(sc, iot, ioh, MSG_ACCEPT);
d2134 6
d2141 1
a2141 1
		return (iha_msgout_reject(sc, iot, ioh));
d2143 1
a2143 2
	/* Send message built in sc->HCS_Msg[] */
	return (iha_msgout_extended(sc, iot, ioh));
d2147 1
a2147 1
 * iha_msgin_sdtr - check SDTR msg in HCS_Msg. If the offer is
d2152 2
a2153 2
int
iha_msgin_sdtr(sc)
d2162 1
a2162 1
	default_period = iha_rate_tbl[flags & FLAG_SCSI_RATE];
d2192 2
a2193 2
int
iha_msgout(sc, iot, ioh, msg)
d2201 1
a2201 1
	return (iha_wait(sc, iot, ioh, XF_FIFO_OUT));
d2204 2
a2205 2
void
iha_msgout_abort(sc, iot, ioh,	aborttype)
d2211 1
a2211 1
	iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
d2213 1
a2213 1
	switch (iha_wait(sc, iot, ioh, MSG_ACCEPT)) {
d2218 2
d2221 3
a2223 2
		if (iha_msgout(sc, iot, ioh, aborttype) != -1)
			iha_bad_seq(sc);
d2227 1
a2227 1
		iha_bad_seq(sc);
d2232 2
a2233 2
int
iha_msgout_reject(sc, iot, ioh)
d2238 6
a2243 1
	iha_set_ssig(iot, ioh, REQ | BSY | SEL, ATN);
d2245 4
a2248 2
	if (iha_wait(sc, iot, ioh, MSG_ACCEPT) == PHASE_MSG_OUT)
		return (iha_msgout(sc, iot, ioh, MSG_MESSAGE_REJECT));
d2250 1
a2250 1
	return (-1);
d2253 2
a2254 2
int
iha_msgout_extended(sc, iot, ioh)
d2261 2
d2264 3
d2268 1
a2268 4
	bus_space_write_multi_1(iot, ioh, TUL_SFIFO, 
	    sc->HCS_Msg, sc->HCS_Msg[0]+1);

	phase = iha_wait(sc, iot, ioh, XF_FIFO_OUT);
d2271 1
a2271 1
	iha_set_ssig(iot, ioh, REQ | BSY | SEL | ATN, 0);
d2276 2
a2277 17
int
iha_msgout_wdtr(sc, iot, ioh)
	struct iha_softc  *sc;
	bus_space_tag_t	   iot;
	bus_space_handle_t ioh;
{
	sc->HCS_ActScb->SCB_Tcs->TCS_Flags |= FLAG_WIDE_DONE;

	sc->HCS_Msg[0] = MSG_EXT_WDTR_LEN;
	sc->HCS_Msg[1] = MSG_EXT_WDTR;
	sc->HCS_Msg[2] = MSG_EXT_WDTR_BUS_16_BIT;

	return (iha_msgout_extended(sc, iot, ioh));
}

int
iha_msgout_sdtr(sc, iot, ioh)
d2284 1
d2288 9
a2296 1
	sync_rate = iha_rate_tbl[rateindex];
d2298 2
a2299 4
	sc->HCS_Msg[0] = MSG_EXT_SDTR_LEN;
	sc->HCS_Msg[1] = MSG_EXT_SDTR;
	sc->HCS_Msg[2] = sync_rate;
	sc->HCS_Msg[3] = IHA_MAX_TARGETS-1; /* REQ/ACK */
d2301 1
a2301 1
	return (iha_msgout_extended(sc, iot, ioh));
d2304 2
a2305 2
void
iha_wide_done(sc, iot, ioh)
d2325 2
a2326 2
void
iha_sync_done(sc, iot, ioh)
d2340 1
a2340 1
				if (iha_rate_tbl[i] >= sc->HCS_Msg[2])
d2355 1
a2355 1
iha_reset_chip(sc, iot, ioh)
d2370 1
a2370 1
	iha_set_ssig(iot, ioh, 0, 0);
d2381 2
a2382 2
void
iha_select(sc, iot, ioh, pScb, select_type)
d2414 1
a2414 1
		printf("[debug] iha_select() - unknown select type = 0x%02x\n",
d2419 1
a2419 1
	iha_del_pend_scb(sc, pScb);
d2428 1
a2428 1
 * iha_wait - wait for an interrupt to service or a SCSI bus phase change
d2432 2
a2433 2
int
iha_wait(sc, iot, ioh, cmd)
d2457 1
a2457 1
		iha_reset_scsi_bus(sc);
d2463 1
a2463 1
		return (iha_resel(sc, iot, ioh));
d2467 1
a2467 1
		iha_busfree(sc, iot, ioh);
d2478 1
a2478 1
			iha_append_done_scb(sc, sc->HCS_ActScb, HOST_OK);
d2490 1
a2490 1
			iha_busfree(sc, iot, ioh);
d2499 1
a2499 1
 * iha_done_scb - We have a scb which has been processed by the
d2502 2
a2503 2
void
iha_done_scb(sc, pScb)
d2573 3
a2575 4
			iha_bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap,
			    0, pScb->SCB_Dmamap->dm_mapsize,
			    ((xs->flags & SCSI_DATA_IN) ? 
				BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
a2578 1
		timeout_del(&xs->stimeout);
d2582 2
a2583 2
	
	iha_append_free_scb(sc, pScb);
d2586 2
a2587 2
void
iha_timeout(arg)
d2595 1
a2595 1
		printf("[debug] iha_timeout called with xs == NULL\n");
d2602 1
a2602 1
		iha_abort_xs(xs->sc_link->adapter_softc, xs, HOST_TIMED_OUT);
d2606 2
a2607 2
void
iha_exec_scb(sc, pScb)
d2619 1
a2619 1
		iha_push_pend_scb(sc, pScb);   /* Insert SCB at head of Pend */
d2621 1
a2621 1
		iha_append_pend_scb(sc, pScb); /* Append SCB to tail of Pend */
d2624 1
a2624 1
	 * Run through iha_main() to ensure something is active, if
d2635 1
a2635 1
		iha_main(sc, iot, ioh);
d2647 1
a2647 1
 * iha_set_ssig - read the current scsi signal mask, then write a new
d2650 2
a2651 2
void
iha_set_ssig( iot, ioh, offsigs, onsigs)
d2662 2
a2663 2
void
iha_print_info(sc, target)
d2692 1
a2692 1
 * iha_alloc_scbs - allocate and map the SCB's for the supplied iha_softc
d2694 2
a2695 2
int
iha_alloc_scbs(sc)
d2748 2
a2749 2
 * iha_read_eeprom - read contents of serial EEPROM into iha_nvram pointed at
 *                                        by parameter nvram.
d2752 1
a2752 1
iha_read_eeprom(iot, ioh, nvram)
a2754 1
	struct iha_nvram *nvram;
d2756 30
d2787 1
a2787 2
	u_int16_t *np;
	u_int8_t gctrl, addr;
d2789 4
a2792 1
	const int chksum_addr = offsetof(struct iha_nvram, NVM_CheckSum) / 2;
d2794 2
a2795 3
	/* Enable EEProm programming */
	gctrl = bus_space_read_1(iot, ioh, TUL_GCTRL0) | EEPRG;
	bus_space_write_1(iot, ioh, TUL_GCTRL0, gctrl);
d2797 3
a2799 4
	/* Read EEProm */
	np = (u_int16_t *)nvram;
	for (addr=0, chksum=0; addr < chksum_addr; addr++, np++) {
		*np = iha_se2_rd(iot, ioh, addr);
d2804 7
a2810 1
	nvram->NVM_CheckSum = iha_se2_rd(iot, ioh, chksum_addr);
d2812 44
a2855 3
	/* Disable EEProm programming */
	gctrl = bus_space_read_1(iot, ioh, TUL_GCTRL0) & ~EEPRG;
	bus_space_write_1(iot, ioh, TUL_GCTRL0, gctrl);
d2857 2
a2858 4
	if ((nvram->NVM_Signature != SIGNATURE)
	    ||
	    (nvram->NVM_CheckSum  != chksum))
		panic("iha: invalid EEPROM,  bad signature or checksum\n");
d2862 1
a2862 1
 * iha_se2_rd - read & return the 16 bit value at the specified
d2867 1
a2867 1
iha_se2_rd(iot, ioh, addr)
d2877 1
a2877 1
	iha_se2_instr(iot, ioh, (addr | READ));
d2901 30
a2930 1
 * iha_se2_instr - write an octet to serial E2PROM one bit at a time
d2933 1
a2933 1
iha_se2_instr(iot, ioh, instr)
d2967 1
a2967 1
 * iha_reset_tcs - reset the target control structure pointed
d2973 1
a2973 1
iha_reset_tcs(pTcs, config0)
@


1.3.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d311 1
a311 1
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap, 
d867 1
a867 1
			case SCSI_TERMINATED:
d2420 1
a2420 1
			case SCSI_COND_MET:
d2427 1
a2427 1
			case SCSI_RESV_CONFLICT:
d2433 1
a2433 1
			case SCSI_TERMINATED:
d2476 1
a2476 1
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_Dmamap,
@


1.3.4.4
log
@Merge in -current from about a week ago
@
text
@d64 4
a67 4
	iha_scsi_cmd,	/*  int (*scsi_cmd)(struct scsi_xfer *); */
	iha_minphys,	/* void (*scsi_minphys)(struct buf *);   */
	NULL,		/*  int (*open_target_lu)(void);         */
	NULL		/*  int (*close_target_lu)(void);        */
d94 58
a151 58
u_int8_t iha_data_over_run(struct iha_scsi_req_q *);
void iha_push_sense_request(struct iha_softc *, struct iha_scsi_req_q *);
void iha_timeout(void *);
int  iha_alloc_scbs(struct iha_softc *);
void iha_read_eeprom(bus_space_tag_t, bus_space_handle_t,
			     struct iha_nvram *);
void iha_se2_instr(bus_space_tag_t, bus_space_handle_t, u_int8_t);
u_int16_t iha_se2_rd(bus_space_tag_t, bus_space_handle_t, u_int8_t);
void iha_reset_scsi_bus(struct iha_softc *);
void iha_reset_chip(struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t);
void iha_reset_dma(bus_space_tag_t, bus_space_handle_t);
void iha_reset_tcs(struct tcs *, u_int8_t);
void iha_print_info(struct iha_softc *, int);
void iha_done_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_exec_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_main(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
void iha_scsi(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
int  iha_wait(struct iha_softc *, bus_space_tag_t, bus_space_handle_t,
		      u_int8_t);
void iha_mark_busy_scb(struct iha_scsi_req_q *);
void iha_append_free_scb(struct iha_softc *, struct iha_scsi_req_q *);
struct iha_scsi_req_q *iha_pop_free_scb(struct iha_softc *);
void iha_append_done_scb(struct iha_softc *, struct iha_scsi_req_q *,
				 u_int8_t);
struct iha_scsi_req_q *iha_pop_done_scb(struct iha_softc *);
void iha_append_pend_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_push_pend_scb(struct iha_softc *, struct iha_scsi_req_q *);
void iha_del_pend_scb(struct iha_softc *, struct iha_scsi_req_q *);
struct iha_scsi_req_q *iha_find_pend_scb(struct iha_softc *);
void iha_sync_done(struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t);
void iha_wide_done(struct iha_softc *,
			   bus_space_tag_t, bus_space_handle_t);
void iha_bad_seq(struct iha_softc *);
int  iha_next_state(struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t);
int  iha_state_1(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_2(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_3(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_4(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_5(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_6(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_state_8(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
void iha_set_ssig(bus_space_tag_t,
			  bus_space_handle_t, u_int8_t, u_int8_t);
int  iha_xpad_in(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_xpad_out(struct iha_softc *,
			  bus_space_tag_t, bus_space_handle_t);
int  iha_xfer_data(struct iha_scsi_req_q *,
d153 22
a174 22
			   int direction);
int  iha_status_msg(struct iha_softc *,
			    bus_space_tag_t, bus_space_handle_t);
int  iha_msgin(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
int  iha_msgin_sdtr(struct iha_softc *);
int  iha_msgin_extended(struct iha_softc *,
				bus_space_tag_t, bus_space_handle_t);
int  iha_msgin_ignore_wid_resid(struct iha_softc *,
					bus_space_tag_t, bus_space_handle_t);
int  iha_msgout(struct iha_softc *,
			bus_space_tag_t, bus_space_handle_t, u_int8_t);
int  iha_msgout_extended(struct iha_softc *,
				 bus_space_tag_t, bus_space_handle_t);
void iha_msgout_abort(struct iha_softc *,
			      bus_space_tag_t, bus_space_handle_t,  u_int8_t);
int  iha_msgout_reject(struct iha_softc *,
			       bus_space_tag_t, bus_space_handle_t);
int  iha_msgout_sdtr(struct iha_softc *,
			     bus_space_tag_t, bus_space_handle_t);
int  iha_msgout_wdtr(struct iha_softc *,
			     bus_space_tag_t, bus_space_handle_t);
void iha_select(struct iha_softc *,
d176 5
a180 5
			struct iha_scsi_req_q *, u_int8_t);
void iha_busfree(struct iha_softc *,
			 bus_space_tag_t, bus_space_handle_t);
int  iha_resel(struct iha_softc *, bus_space_tag_t, bus_space_handle_t);
void iha_abort_xs(struct iha_softc *, struct scsi_xfer *, u_int8_t);
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@d2 2
a3 3
/*-------------------------------------------------------------------------
 *
 * Device driver for the INI-9XXXU/UW or INIC-940/950  PCI SCSI Controller.
d5 2
a6 5
 * Written for 386bsd and FreeBSD by
 *	Winston Hung		<winstonh@@initio.com>
 *
 * Copyright (c) 1997-1999 Initio Corp
 * Copyright (c) 2000-2002 Ken Westerback
d30 13
d637 1
a637 1
				 * started, because we don't allow any
d2689 1
a2689 1
		panic("iha: invalid EEPROM,  bad signature or checksum");
@


1.3.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.3.4.5 2003/03/28 00:38:13 niklas Exp $ */
a49 2
/* #define IHA_DEBUG_STATE */

d72 1
a72 1
static const u_int8_t iha_rate_tbl[] = {
d85 2
a86 3
int iha_setup_sg_list(struct iha_softc *, struct iha_scb *);
u_int8_t iha_data_over_run(struct iha_scb *);
int iha_push_sense_request(struct iha_softc *, struct iha_scb *);
d99 2
a100 2
void iha_done_scb(struct iha_softc *, struct iha_scb *);
void iha_exec_scb(struct iha_softc *, struct iha_scb *);
d105 4
a108 4
void iha_mark_busy_scb(struct iha_scb *);
void iha_append_free_scb(struct iha_softc *, struct iha_scb *);
struct iha_scb *iha_pop_free_scb(struct iha_softc *);
void iha_append_done_scb(struct iha_softc *, struct iha_scb *,
d110 5
a114 5
struct iha_scb *iha_pop_done_scb(struct iha_softc *);
void iha_append_pend_scb(struct iha_softc *, struct iha_scb *);
void iha_push_pend_scb(struct iha_softc *, struct iha_scb *);
void iha_del_pend_scb(struct iha_softc *, struct iha_scb *);
struct iha_scb *iha_find_pend_scb(struct iha_softc *);
d142 1
a142 1
int  iha_xfer_data(struct iha_scb *,
d167 1
a167 1
			struct iha_scb *, u_int8_t);
a210 45
 * iha_setup_sg_list -	initialize scatter gather list of pScb from
 *			pScb->SCB_DataDma.
 */
int
iha_setup_sg_list(sc, pScb)
	struct iha_softc *sc;
	struct iha_scb *pScb;
{
	bus_dma_segment_t *segs = pScb->SCB_DataDma->dm_segs;
	int i, error, nseg = pScb->SCB_DataDma->dm_nsegs;

	if (nseg > 1) {
		error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_SGDma,
				pScb->SCB_SGList, sizeof(pScb->SCB_SGList), NULL,
				(pScb->SCB_Flags & SCSI_NOSLEEP) ?
					BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			sc_print_addr(pScb->SCB_Xs->sc_link);
			printf("error %d loading SG list dma map\n", error);
			return (error);
		}

		/*
		 * Only set FLAG_SG when SCB_SGDma is loaded so iha_scsi_done
		 * will not unload an unloaded map.
		 */
		pScb->SCB_Flags	|= FLAG_SG;
		bzero(pScb->SCB_SGList, sizeof(pScb->SCB_SGList));

		pScb->SCB_SGIdx	  = 0;
		pScb->SCB_SGCount = nseg;

		for (i=0; i < nseg; i++) {
			pScb->SCB_SGList[i].SG_Len  = segs[i].ds_len;
			pScb->SCB_SGList[i].SG_Addr = segs[i].ds_addr;
		}

		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma, 
			0, sizeof(pScb->SCB_SGList), BUS_DMASYNC_PREWRITE);
	}

	return (0);
}

/*
d219 2
a220 1
	struct iha_scb *pScb;
d223 2
a224 1
	int error;
d254 1
a254 1
	pScb->SCB_BufCharsLeft = pScb->SCB_BufChars = xs->datalen;
d256 1
a256 1
	if ((pScb->SCB_Flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) != 0) {
d258 1
a258 1
		if (pScb->SCB_Flags & SCSI_DATA_UIO)
d260 2
a261 2
			    pScb->SCB_DataDma, (struct uio *)xs->data,
			    (pScb->SCB_Flags & SCSI_NOSLEEP) ?
d265 3
a267 3
			error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_DataDma,
			    xs->data, pScb->SCB_BufChars, NULL,
			    (pScb->SCB_Flags & SCSI_NOSLEEP) ?
a270 1
			sc_print_addr(xs->sc_link);
d272 2
a273 2
				printf("buffer needs >%d dma segments\n",
				    IHA_MAX_SG_ENTRIES);
d275 2
a276 2
				printf("error %d loading buffer dma map\n",
				    error);
a282 4
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma, 
			0, pScb->SCB_BufChars,
			(pScb->SCB_Flags & SCSI_DATA_IN) ?
				BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
d284 17
a300 6
		error = iha_setup_sg_list(sc, pScb);
		if (error) {
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
			xs->error = XS_DRIVER_STUFFUP;
			return (COMPLETE);
		}
d302 4
d308 3
d317 1
a317 1
	if ((pScb->SCB_Flags & SCSI_POLL) == 0)
d336 1
a336 1
	struct iha_scb *pScb;
d377 8
d389 1
a389 1
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &pScb->SCB_DataDma);
d392 1
a392 1
			printf("%s: couldn't create SCB data DMA map, error = %d\n",
a395 12

		error = bus_dmamap_create(sc->sc_dmat,
				sizeof(pScb->SCB_SGList), 1,
				sizeof(pScb->SCB_SGList), 0,
				BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
				&pScb->SCB_SGDma);
		if (error != 0) {
			printf("%s: couldn't create SCB SG DMA map, error = %d\n",
			    sc->sc_dev.dv_xname, error);
			return (error);
		}

d480 1
a480 1
struct iha_scb *
d484 1
a484 1
	struct iha_scb *pScb;
d509 1
a509 1
	struct iha_scb *pScb;
d518 3
a520 3
	pScb->SCB_Status = STATUS_QUEUED;
	pScb->SCB_HaStat = HOST_OK;
	pScb->SCB_TaStat = SCSI_OK;
d523 2
d528 2
d533 2
a534 3

	pScb->SCB_BufChars     = 0;
	pScb->SCB_BufCharsLeft = 0;
d539 3
a541 1
	bzero(pScb->SCB_CDB, sizeof(pScb->SCB_CDB));
d544 3
a546 1
	 * SCB_TagId is set at initialization and never changes
d557 1
a557 1
	struct iha_scb *pScb;
d572 1
a572 1
	struct iha_scb *pScb;
d594 1
a594 1
struct iha_scb *
d598 1
a598 1
	struct iha_scb *pScb;
d655 1
a655 1
	struct iha_scb *pScb;
d668 1
a668 1
	struct iha_scb *pScb;
d687 1
a687 1
	struct iha_scb *pScb;
d717 1
a717 1
struct iha_scb *
d721 1
a721 1
	struct iha_scb *pScb;
d749 1
a749 1
	struct iha_scb *pScb;
d794 1
a794 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d808 1
a808 1
int
d811 1
a811 1
	struct iha_scb *pScb;
d813 2
a814 39
	struct scsi_sense *sensecmd;
	int error;

	/* First sync & unload any existing DataDma and SGDma maps */
	if ((pScb->SCB_Flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) != 0) {
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma,
			0, pScb->SCB_BufChars,
			((pScb->SCB_Flags & SCSI_DATA_IN) ? 
				BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
		bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
		/* Don't unload this map again until it is reloaded */
		pScb->SCB_Flags &= ~(SCSI_DATA_IN | SCSI_DATA_OUT);
	}
	if ((pScb->SCB_Flags & FLAG_SG) != 0) {
		bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma,
			0, sizeof(pScb->SCB_SGList),
			BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, pScb->SCB_SGDma);
		/* Don't unload this map again until it is reloaded */
		pScb->SCB_Flags &= ~FLAG_SG;
	}

	pScb->SCB_BufChars     = sizeof(pScb->SCB_ScsiSenseData);
	pScb->SCB_BufCharsLeft = sizeof(pScb->SCB_ScsiSenseData);
	bzero(&pScb->SCB_ScsiSenseData, sizeof(pScb->SCB_ScsiSenseData)); 

	error = bus_dmamap_load(sc->sc_dmat, pScb->SCB_DataDma,
			&pScb->SCB_ScsiSenseData,
			sizeof(pScb->SCB_ScsiSenseData), NULL,
			(pScb->SCB_Flags & SCSI_NOSLEEP) ?
				BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error) {
		sc_print_addr(pScb->SCB_Xs->sc_link);
		printf("error %d loading request sense buffer dma map\n",
			error);
		return (error);
	}
	bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma, 
		0, pScb->SCB_BufChars, BUS_DMASYNC_PREREAD);
d816 1
a816 2
	/* Save _POLL and _NOSLEEP flags. */ 
	pScb->SCB_Flags &= SCSI_POLL | SCSI_NOSLEEP;
a818 4
	error = iha_setup_sg_list(sc, pScb);
	if (error)
		return (error);

d826 3
a828 5
	sensecmd = (struct scsi_sense *)pScb->SCB_CDB;
	pScb->SCB_CDBLen = sizeof(*sensecmd);
	sensecmd->opcode = REQUEST_SENSE;
	sensecmd->byte2  = pScb->SCB_Xs->sc_link->lun << 5;
	sensecmd->length = sizeof(pScb->SCB_ScsiSenseData);
d832 1
a832 1
		    (pScb->SCB_Xs->timeout/1000) * hz);
a834 2

	return (0);
d849 1
a849 1
	struct iha_scb *pScb;
d867 3
a869 5
				else if (iha_push_sense_request(sc, pScb) != 0)
					/* Could not push sense request */
					pScb->SCB_HaStat = HOST_BAD_PHAS;
				else
					/* REQUEST SENSE ready to process */
d871 1
d910 1
a910 1
	struct iha_scb *pScb;
a912 1
	int i;
d981 1
a981 1
		for (i = pScb->SCB_Xs->timeout; i > 0; i--) {
d996 1
a996 1
		if (i == 0)
d1008 1
a1008 1
 * iha_data_over_run - return HOST_OK for all SCSI opcodes where BufCharsLeft
d1019 1
a1019 1
	struct iha_scb *pScb;
a1128 1
		sc_print_addr(sc->HCS_ActScb->SCB_Xs->sc_link);
d1151 1
a1151 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1212 1
a1212 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1239 1
a1239 1
	struct iha_scb *pScb = sc->HCS_ActScb;
a1275 2
#ifdef IHA_DEBUG_STATE
			sc_print_addr(pScb->SCB_Xs->sc_link);
a1276 1
#endif
d1295 1
a1295 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1301 1
a1301 1
		if (pScb->SCB_BufCharsLeft == 0)
d1320 1
a1320 1
				pScb->SCB_BufCharsLeft = 0;
d1358 1
a1358 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1364 1
d1413 1
a1413 1
		pScb->SCB_BufCharsLeft = 0;
d1419 2
a1420 5
	xcnt = pScb->SCB_BufCharsLeft - cnt;	/* xcnt == bytes xferred */
	pScb->SCB_BufCharsLeft = cnt;		/* cnt  == bytes left    */

	bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma, 
		0, sizeof(pScb->SCB_SGList), BUS_DMASYNC_POSTWRITE);
d1424 1
a1424 1
		for (; pScb->SCB_SGIdx < pScb->SCB_SGCount; pSg++, pScb->SCB_SGIdx++) {
d1429 1
a1429 1
				pSg->SG_Addr += xcnt;
d1432 4
a1435 3
				bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma, 
					0, sizeof(pScb->SCB_SGList),
					BUS_DMASYNC_PREWRITE);
d1442 2
a1443 1
	}
d1502 1
a1502 1
	struct iha_scb *pScb;
d1548 1
a1548 1
	struct iha_scb *pScb;
d1553 1
a1553 1
	u_int32_t xferaddr, xferlen;
d1559 1
a1559 1
	bus_space_write_4(iot, ioh, TUL_STCNT0, pScb->SCB_BufCharsLeft);
d1562 1
a1562 3
		xferaddr = pScb->SCB_DataDma->dm_segs[0].ds_addr
				+ (pScb->SCB_BufChars - pScb->SCB_BufCharsLeft);
		xferlen  = pScb->SCB_BufCharsLeft;
d1566 1
a1566 4
		xferaddr = pScb->SCB_SGDma->dm_segs[0].ds_addr
				+ (pScb->SCB_SGIdx * sizeof(struct iha_sg_element));
		xferlen  = (pScb->SCB_SGCount - pScb->SCB_SGIdx)
				* sizeof(struct iha_sg_element);
d1571 1
a1571 1
	bus_space_write_4(iot, ioh, TUL_DXPA, xferaddr);
d1588 1
a1588 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1620 1
a1620 1
	struct iha_scb *pScb = sc->HCS_ActScb;
d1655 1
a1655 1
	struct iha_scb *pScb;
d1728 1
a1728 1
	struct iha_scb *pScb;
d1751 1
a1751 1
	struct iha_scb *pScb;
d1788 1
a1788 1
	struct iha_scb *pScb;
a1925 1
#ifdef IHA_DEBUG_STATE
a1926 1
#endif
d2016 1
a2016 2
			/* Offer 8 bit xfers only */
			sc->HCS_Msg[2] = MSG_EXT_WDTR_BUS_8_BIT;
d2018 1
a2018 1
		else if (sc->HCS_Msg[2] > MSG_EXT_WDTR_BUS_32_BIT)
d2021 2
a2022 3
		else if (sc->HCS_Msg[2] == MSG_EXT_WDTR_BUS_32_BIT)
			/* Offer 16 instead */
			sc->HCS_Msg[2] = MSG_EXT_WDTR_BUS_32_BIT;
d2233 1
a2233 1
			for (i = 0; i < sizeof(iha_rate_tbl); i++)
d2280 1
a2280 1
	struct iha_scb *pScb;
a2307 2
#ifdef IHA_DEBUG_STATE
		sc_print_addr(pScb->SCB_Xs->sc_link);
a2309 1
#endif
d2399 1
a2399 1
	struct iha_scb *pScb;
a2404 2
		timeout_del(&xs->stimeout);

a2406 14
		if ((pScb->SCB_Flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) != 0) {
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_DataDma,
				0, pScb->SCB_BufChars,
				((pScb->SCB_Flags & SCSI_DATA_IN) ? 
					BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE));
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_DataDma);
		}
		if ((pScb->SCB_Flags & FLAG_SG) != 0) {
			bus_dmamap_sync(sc->sc_dmat, pScb->SCB_SGDma,
				0, sizeof(pScb->SCB_SGList),
				BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, pScb->SCB_SGDma);
		}

d2414 1
a2414 1
				xs->resid = pScb->SCB_BufCharsLeft;
d2450 2
a2451 2
			sc_print_addr(xs->sc_link);
			printf("SCSI Parity error detected\n");
d2466 9
d2486 1
a2486 1
	struct iha_scb *pScb = (struct iha_scb *)arg;
d2488 1
d2490 5
a2494 1
	if (xs != NULL) {
d2497 1
d2505 1
a2505 1
	struct iha_scb *pScb;
d2528 1
a2528 1
		sc->HCS_Semaph = SEMAPH_IN_MAIN;
d2534 1
a2534 1
		sc->HCS_Semaph = ~SEMAPH_IN_MAIN;
d2568 2
a2569 2
		(period & PERIOD_WIDE_SCSI) ? 16 : 8);
 
d2582 1
a2582 1

d2601 1
a2601 1
		 sizeof(struct iha_scb)*IHA_MAX_SCB,
d2609 1
a2609 1
		 &seg, rseg, sizeof(struct iha_scb)*IHA_MAX_SCB,
d2616 23
a2638 1
	bzero(sc->HCS_Scb, sizeof(struct iha_scb)*IHA_MAX_SCB);
@


1.3.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1123 1
a1123 1
	case 0x5e: /* Persistent Reserve In           SPC-2 */
d1147 1
a1147 1
 * iha_next_state - process the current SCB as requested in it's 
d2772 1
a2772 1
	iha_se2_instr(iot, ioh, (addr | NVREAD));
@


1.2
log
@Use <scsi/scsi_message.h> defines rather than homegrown ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: iha.c,v 1.1 2001/01/23 04:19:41 krw Exp $ */
a369 1
			/* XXX - need to scsi_done() xs? i.e. put in doneq? */
d1071 1
a1071 1
	if (pScb->SCB_Flags & SCSI_POLL) {
d1074 1
a1074 1
				return;
d1076 1
a1076 1
				return;
d1079 16
a1094 1
		tul_timeout(pScb);
a2519 5
				if (((pScb->SCB_Flags & SCSI_POLL) != 0)
				    && (pScb->SCB_CDB[0] == INQUIRY)
				    && (pScb->SCB_Lun == 0))
					tul_print_info(sc, pScb->SCB_Target);

a2582 3
	if (xs->flags & SCSI_RESET)
		printf("[debug] tul_done_scb - finished a reset request\n");

d2667 2
a2668 1
	struct tcs *pTcs = &sc->HCS_Tcs[target];
d2671 2
a2672 1
	printf("%s: target %d ", sc->sc_dev.dv_xname, target);
d2674 5
a2678 9
	if ((pTcs->TCS_JS_Period & PERIOD_WIDE_SCSI) != 0)
		printf("using 16 bit ");
	else
		printf("using 8 bit ");

	if ((pTcs->TCS_JS_Period & PERIOD_SYOFS) != 0) {
		printf("synchronous transfers at ");
		rate = (pTcs->TCS_JS_Period & PERIOD_SYXPD) >> 4;
		if ((pTcs->TCS_SConfig0 & ALTPD) == 0)
d2683 2
a2684 2
		printf("%d.%d MHz ",  rate / 1000000
		    ,(rate % 1000000 + 99999) / 100000);
d2686 2
a2687 7
	else
		printf("asynchronous transfers ");

	printf("with ");
	if ((pTcs->TCS_SConfig0 & SPCHK) == 0)
		printf("no ");
	printf("parity\n");
@


1.1
log
@Add support for Initio INI-91xx SCSI Cards
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d55 1
d335 2
a336 1
	pScb->SCB_Ident  = IDENT_IDENTITY | (pScb->SCB_Lun & IDENT_LUN);
d340 1
a340 1
		pScb->SCB_Ident |= IDENT_DISC_PRIV;
d913 1
a913 1
	pScb->SCB_Ident &= ~IDENT_DISC_PRIV;
d1346 1
a1346 1
				if (tul_msgout(sc, iot, ioh, MSG_NOP) == -1)
d1399 2
a1400 1
				if (tul_msgout(sc, iot, ioh, MSG_IDE) == -1)
d1405 1
a1405 1
				if (tul_msgout(sc, iot, ioh, MSG_NOP) == -1)
d1550 1
a1550 1
			if ((tul_msgout(sc, iot, ioh, MSG_NOP)) == -1)
d1584 1
a1584 1
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_DEVRST);
d1745 2
a1746 1
			bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_NOP);
d1748 2
a1749 1
			bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_PARITY);
d1762 1
a1762 1
				    MSG_PARITY);
d1769 1
a1769 1
		if (msg == MSG_COMP) {
d1780 2
a1781 1
		if ((msg == MSG_LINK_COMP) || (msg == MSG_LINK_FLAG)) {
d1877 1
a1877 1
	lun    = bus_space_read_1(iot, ioh, TUL_SALVC) & IDENT_LUN;
d1912 1
a1912 1
		if ((msg < MSG_STAG) || (msg > MSG_OTAG))
d1969 1
a1969 1
		case MSG_DISC:
d1975 3
a1977 3
		case MSG_SDP:
		case MSG_RESTORE:
		case MSG_NOP:
d1980 1
a1980 1
		case MSG_REJ:
d1988 1
a1988 1
		case MSG_EXTEND:
d1991 1
a1991 1
		case MSG_IGNOREWIDE:
d1994 1
a1994 1
		case MSG_COMP:
d2071 1
a2071 1
	if ((msglen == MSG_LEN_SYNC_XFER) && (msgcode == MSG_CODE_SYNC_XFER)) {
d2088 3
a2090 3
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXTEND);
		bus_space_write_1(iot, ioh, TUL_SFIFO, 3);
		bus_space_write_1(iot, ioh, TUL_SFIFO, 1);
d2094 1
a2094 2
	} else if ((msglen == MSG_LEN_WIDE_XFER)
	               && (msgcode == MSG_CODE_WIDE_XFER)) {
d2121 3
a2123 3
		bus_space_write_1(iot, ioh, TUL_SFIFO,	   MSG_EXTEND);
		bus_space_write_1(iot, ioh, TUL_SFIFO,		    2);
		bus_space_write_1(iot, ioh, TUL_SFIFO,		    3);
d2232 1
a2232 1
		bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_REJ);
d2249 4
a2252 4
	bus_space_write_1(iot, ioh, TUL_SFIFO, MSG_EXTEND);
	bus_space_write_1(iot, ioh, TUL_SFIFO,		2); /* Message length*/
	bus_space_write_1(iot, ioh, TUL_SFIFO,		3); /* WDTR request  */
	bus_space_write_1(iot, ioh, TUL_SFIFO,		1); /* 16 bits xfer  */
d2276 4
a2279 4
	bus_space_write_1(iot, ioh, TUL_SFIFO,	      MSG_EXTEND);
	bus_space_write_1(iot, ioh, TUL_SFIFO,		       3); /* Msg len*/
	bus_space_write_1(iot, ioh, TUL_SFIFO,		       1); /* SDTR   */
	bus_space_write_1(iot, ioh, TUL_SFIFO,	       sync_rate);
@

