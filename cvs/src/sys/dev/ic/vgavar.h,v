head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.6
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.11.0.14
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.18
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.16
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.26
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.24
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.22
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.20
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.18
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.16
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.14
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.12
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.10
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.10
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2015.07.26.03.17.07;	author miod;	state Exp;
branches;
next	1.12;
commitid	0kywYp2i1cqnzJaY;

1.12
date	2015.03.29.18.45.22;	author miod;	state Exp;
branches;
next	1.11;
commitid	Zn8MYTvkjKcNFl7W;

1.11
date	2010.08.28.12.48.14;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.08.17.21.05;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.01.14.37.22;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.08.16.16.10;	author mickey;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.11.15.20.17.38;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	97.11.06.08.11.57;	author niklas;	state Exp;
branches
	1.3.10.1;
next	1.2;

1.2
date	97.08.22.22.25.59;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.07.09.02.58.36;	author deraadt;	state Exp;
branches;
next	;

1.3.10.1
date	2001.05.14.22.24.23;	author niklas;	state Exp;
branches;
next	1.3.10.2;

1.3.10.2
date	2001.07.04.10.41.16;	author niklas;	state Exp;
branches;
next	1.3.10.3;

1.3.10.3
date	2002.03.28.12.09.41;	author niklas;	state Exp;
branches;
next	1.3.10.4;

1.3.10.4
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@When attaching on an alpha system, get the current textmode resolution by
querying the 6845 registers, and preserve it if it is larger than 80x25 yet
plausible.

This is necessary to properly operate on the Alphabook 1 where the vga display
is running in a 100x37 textmode.

Other platforms are not affected.
@
text
@/* $OpenBSD: vgavar.h,v 1.12 2015/03/29 18:45:22 miod Exp $ */
/* $NetBSD: vgavar.h,v 1.4 2000/06/17 07:11:50 soda Exp $ */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/timeout.h>

struct vga_handle {
	struct pcdisplay_handle vh_ph;
	bus_space_handle_t vh_ioh_vga, vh_allmemh;
	int vh_mono;
};
#define vh_iot vh_ph.ph_iot
#define vh_memt vh_ph.ph_memt
#define vh_ioh_6845 vh_ph.ph_ioh_6845
#define vh_memh vh_ph.ph_memh

struct vgascreen {
	struct pcdisplayscreen pcs;
	LIST_ENTRY(vgascreen) next;

	/* videostate */
	struct vga_config *cfg;
	/* font data */
	struct vgafont *fontset1, *fontset2;

	int mindispoffset, maxdispoffset;
	int vga_rollover;
};

struct vga_config {
	struct vga_handle hdl;

	struct device *vc_softc;
	int vc_type;
	int nscreens;
	LIST_HEAD(, vgascreen) screens;
	struct vgascreen *active; /* current display */
	const struct wsscreen_descr *currenttype;
	int currentfontset1, currentfontset2;

#define	VGA_MAXFONT 8
	struct vgafont *vc_fonts[VGA_MAXFONT];
	uint8_t vc_palette[256 * 3];

	struct vgascreen *wantedscreen;
	void (*switchcb)(void *, int, int);
	void *switchcbarg;

	paddr_t (*vc_mmap)(void *, off_t, int);

	struct timeout vc_switch_timeout;

#ifdef __alpha__
	/* placeholder for a custom wsscreen_descr for odd resolutions */
	struct wsscreen_descr custom_scr;
	struct wsscreen_descr *custom_scrlist[1];
	struct wsscreen_list custom_list;
#endif
};

static inline u_int8_t _vga_attr_read(struct vga_handle *, int);
static inline void _vga_attr_write(struct vga_handle *, int, u_int8_t);
static inline u_int8_t _vga_ts_read(struct vga_handle *, int);
static inline void _vga_ts_write(struct vga_handle *, int, u_int8_t);
static inline u_int8_t _vga_gdc_read(struct vga_handle *, int);
static inline void _vga_gdc_write(struct vga_handle *, int, u_int8_t);

#define	vga_raw_read(vh, reg) \
	bus_space_read_1(vh->vh_iot, vh->vh_ioh_vga, reg)
#define	vga_raw_write(vh, reg, value) \
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, reg, value)

#define	vga_enable(vh) \
	vga_raw_write(vh, 0, 0x20);

static inline u_int8_t
_vga_attr_read(struct vga_handle *vh, int reg)
{
	u_int8_t res;

	/* reset state */
	(void) bus_space_read_1(vh->vh_iot, vh->vh_ioh_6845, 10);

	vga_raw_write(vh, VGA_ATC_INDEX, reg);
	res = vga_raw_read(vh, VGA_ATC_DATAR);

	/* reset state XXX unneeded? */
	(void) bus_space_read_1(vh->vh_iot, vh->vh_ioh_6845, 10);

	vga_enable(vh);

	return (res);
}

static inline void
_vga_attr_write(struct vga_handle *vh, int reg, u_int8_t val)
{
	/* reset state */
	(void) bus_space_read_1(vh->vh_iot, vh->vh_ioh_6845, 10);

	vga_raw_write(vh, VGA_ATC_INDEX, reg);
	vga_raw_write(vh, VGA_ATC_DATAW, val);

	/* reset state XXX unneeded? */
	(void) bus_space_read_1(vh->vh_iot, vh->vh_ioh_6845, 10);

	vga_enable(vh);
}

static inline u_int8_t
_vga_ts_read(struct vga_handle *vh, int reg)
{
	vga_raw_write(vh, VGA_TS_INDEX, reg);
	return (vga_raw_read(vh, VGA_TS_DATA));
}

static inline void
_vga_ts_write(struct vga_handle *vh, int reg, u_int8_t val)
{
	vga_raw_write(vh, VGA_TS_INDEX, reg);
	vga_raw_write(vh, VGA_TS_DATA, val);
}

static inline u_int8_t
_vga_gdc_read(struct vga_handle *vh, int reg)
{
	vga_raw_write(vh, VGA_GDC_INDEX, reg);
	return (vga_raw_read(vh, VGA_GDC_DATA));
}

static inline void
_vga_gdc_write(struct vga_handle *vh, int reg, u_int8_t val)
{
	vga_raw_write(vh, VGA_GDC_INDEX, reg);
	vga_raw_write(vh, VGA_GDC_DATA, val);
}

#define vga_attr_read(vh, reg) \
	_vga_attr_read(vh, offsetof(struct reg_vgaattr, reg))
#define vga_attr_write(vh, reg, val) \
	_vga_attr_write(vh, offsetof(struct reg_vgaattr, reg), val)
#define vga_ts_read(vh, reg) \
	_vga_ts_read(vh, offsetof(struct reg_vgats, reg))
#define vga_ts_write(vh, reg, val) \
	_vga_ts_write(vh, offsetof(struct reg_vgats, reg), val)
#define vga_gdc_read(vh, reg) \
	_vga_gdc_read(vh, offsetof(struct reg_vgagdc, reg))
#define vga_gdc_write(vh, reg, val) \
	_vga_gdc_write(vh, offsetof(struct reg_vgagdc, reg), val)

#define vga_6845_read(vh, reg) \
	pcdisplay_6845_read(&(vh)->vh_ph, reg)
#define vga_6845_write(vh, reg, val) \
	pcdisplay_6845_write(&(vh)->vh_ph, reg, val)

int	vga_common_probe(bus_space_tag_t, bus_space_tag_t);
struct vga_config *
	vga_common_attach(struct device *, bus_space_tag_t, bus_space_tag_t,
	    int);
struct vga_config *
	vga_extended_attach(struct device *, bus_space_tag_t, bus_space_tag_t,
	    int, paddr_t (*)(void *, off_t, int));
int	vga_is_console(bus_space_tag_t, int);
int	vga_cnattach(bus_space_tag_t, bus_space_tag_t, int, int);

struct wsscreen_descr;
void	vga_loadchars(struct vga_handle *, int, int, int, int, char *);
void	vga_restore_fonts(struct vga_config *);
void	vga_restore_palette(struct vga_config *);
void	vga_save_palette(struct vga_config *);
void	vga_setfontset(struct vga_handle *, int, int);
void	vga_setscreentype(struct vga_handle *, const struct wsscreen_descr *);
#if NVGA_PCI > 0
int	vga_pci_ioctl(void *, u_long, caddr_t, int, struct proc *); 
#endif
@


1.12
log
@Restore user-loaded vga fonts upon X11->VT switch and upon resume; from
dan mclaughlin, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.11 2010/08/28 12:48:14 miod Exp $ */
d78 7
@


1.11
log
@ansify function definitions, and constify a few arrays while there.
no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.10 2010/08/08 17:21:05 miod Exp $ */
d67 2
a68 1
	struct vgafont *vc_fonts[8];
d187 1
@


1.10
log
@Try to save the vga hardware state around suspend, and also redisplay the
textmode video memory contents if we had to POST the vga bios.
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.9 2009/02/01 14:37:22 miod Exp $ */
d94 2
a95 3
static inline u_int8_t _vga_attr_read(vh, reg)
	struct vga_handle *vh;
	int reg;
d113 2
a114 4
static inline void _vga_attr_write(vh, reg, val)
	struct vga_handle *vh;
	int reg;
	u_int8_t val;
d128 2
a129 3
static inline u_int8_t _vga_ts_read(vh, reg)
	struct vga_handle *vh;
	int reg;
d135 2
a136 4
static inline void _vga_ts_write(vh, reg, val)
	struct vga_handle *vh;
	int reg;
	u_int8_t val;
d142 2
a143 3
static inline u_int8_t _vga_gdc_read(vh, reg)
	struct vga_handle *vh;
	int reg;
d149 2
a150 4
static inline void _vga_gdc_write(vh, reg, val)
	struct vga_handle *vh;
	int reg;
	u_int8_t val;
@


1.9
log
@Save the text mode color palette upon startup, and restore it when
switching consoles or when X11 exits. Almost all other operating systems
do this, and thus do not suffer from palette bugs in some X11 drivers.

From FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.8 2002/07/12 20:17:03 mickey Exp $ */
d43 13
d184 6
a189 4
void	vga_common_attach(struct device *, bus_space_tag_t,
			       bus_space_tag_t, int);
void	vga_extended_attach(struct device *, bus_space_tag_t,
    bus_space_tag_t, int, paddr_t (*)(void *, off_t, int));
@


1.8
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.7 2002/03/14 03:16:05 millert Exp $ */
d55 1
d73 8
d90 2
a91 2
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_ATC_INDEX, reg);
	res = bus_space_read_1(vh->vh_iot, vh->vh_ioh_vga, VGA_ATC_DATAR);
d96 1
a96 2
	/* enable */
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, 0, 0x20);
d109 2
a110 2
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_ATC_INDEX, reg);
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_ATC_DATAW, val);
d115 1
a115 2
	/* enable */
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, 0, 0x20);
d122 2
a123 2
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_TS_INDEX, reg);
	return (bus_space_read_1(vh->vh_iot, vh->vh_ioh_vga, VGA_TS_DATA));
d131 2
a132 2
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_TS_INDEX, reg);
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_TS_DATA, val);
d139 2
a140 2
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_GDC_INDEX, reg);
	return (bus_space_read_1(vh->vh_iot, vh->vh_ioh_vga, VGA_GDC_DATA));
d148 2
a149 2
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_GDC_INDEX, reg);
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_GDC_DATA, val);
d179 5
a183 4
void vga_loadchars(struct vga_handle *, int, int, int, int, char *);
void vga_setfontset(struct vga_handle *, int, int);
void vga_setscreentype(struct vga_handle *,
		       const struct wsscreen_descr *);
d185 1
a185 1
int vga_pci_ioctl(void *, u_long, caddr_t, int, struct proc *); 
@


1.7
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.6 2002/03/14 01:26:55 millert Exp $ */
a59 1
#ifdef arc
a60 1
#endif
d165 1
a165 2
			  bus_space_tag_t, int);
#ifdef arc
d167 1
a167 3
			    bus_space_tag_t, int,
			    int (*)(void *, off_t, int));
#endif
a168 1

@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.5 2001/05/08 16:16:10 mickey Exp $ */
d167 1
a167 1
			       bus_space_tag_t, int);
d169 3
a171 3
void	vga_extended_attach __P((struct device *, bus_space_tag_t,
				 bus_space_tag_t, int,
				 int (*)(void *, off_t, int)));
d181 1
a181 1
			    const struct wsscreen_descr *);
@


1.5
log
@support a hook for vga_pci-based ioctls; aaron@@ ook
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.4 2000/11/15 20:17:38 aaron Exp $ */
d57 1
a57 1
	void (*switchcb) __P((void *, int, int));
d61 1
a61 1
	paddr_t (*vc_mmap) __P((void *, off_t, int));
d67 6
a72 6
static inline u_int8_t _vga_attr_read __P((struct vga_handle *, int));
static inline void _vga_attr_write __P((struct vga_handle *, int, u_int8_t));
static inline u_int8_t _vga_ts_read __P((struct vga_handle *, int));
static inline void _vga_ts_write __P((struct vga_handle *, int, u_int8_t));
static inline u_int8_t _vga_gdc_read __P((struct vga_handle *, int));
static inline void _vga_gdc_write __P((struct vga_handle *, int, u_int8_t));
d165 3
a167 3
int	vga_common_probe __P((bus_space_tag_t, bus_space_tag_t));
void	vga_common_attach __P((struct device *, bus_space_tag_t,
			       bus_space_tag_t, int));
d171 1
a171 1
				 int (*) __P((void *, off_t, int))));
d173 1
a173 1
int	vga_is_console __P((bus_space_tag_t, int));
d175 1
a175 1
int	vga_cnattach __P((bus_space_tag_t, bus_space_tag_t, int, int));
d178 4
a181 4
void vga_loadchars __P((struct vga_handle *, int, int, int, int, char *));
void vga_setfontset __P((struct vga_handle *, int, int));
void vga_setscreentype __P((struct vga_handle *,
			    const struct wsscreen_descr *));
d183 1
a183 1
int vga_pci_ioctl __P((void *, u_long, caddr_t, int, struct proc *)); 
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.5 2001/05/08 16:16:10 mickey Exp $ */
d57 1
a57 1
	void (*switchcb)(void *, int, int);
d61 1
a61 1
	paddr_t (*vc_mmap)(void *, off_t, int);
d67 6
a72 6
static inline u_int8_t _vga_attr_read(struct vga_handle *, int);
static inline void _vga_attr_write(struct vga_handle *, int, u_int8_t);
static inline u_int8_t _vga_ts_read(struct vga_handle *, int);
static inline void _vga_ts_write(struct vga_handle *, int, u_int8_t);
static inline u_int8_t _vga_gdc_read(struct vga_handle *, int);
static inline void _vga_gdc_write(struct vga_handle *, int, u_int8_t);
d165 3
a167 3
int	vga_common_probe(bus_space_tag_t, bus_space_tag_t);
void	vga_common_attach(struct device *, bus_space_tag_t,
			  bus_space_tag_t, int);
d169 3
a171 3
void	vga_extended_attach(struct device *, bus_space_tag_t,
			    bus_space_tag_t, int,
			    int (*)(void *, off_t, int));
d173 1
a173 1
int	vga_is_console(bus_space_tag_t, int);
d175 1
a175 1
int	vga_cnattach(bus_space_tag_t, bus_space_tag_t, int, int);
d178 4
a181 4
void vga_loadchars(struct vga_handle *, int, int, int, int, char *);
void vga_setfontset(struct vga_handle *, int, int);
void vga_setscreentype(struct vga_handle *,
		       const struct wsscreen_descr *);
d183 1
a183 1
int vga_pci_ioctl(void *, u_long, caddr_t, int, struct proc *); 
@


1.5.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.5.4.1 2002/06/11 03:42:20 art Exp $ */
d60 1
d62 1
d167 2
a168 1
			       bus_space_tag_t, int);
d170 3
a172 1
    bus_space_tag_t, int, paddr_t (*)(void *, off_t, int));
d174 1
@


1.4
log
@Updated VGA driver; from NetBSD. Needed for wscons on i386 and alpha. These
files could probably be updated even a bit further (they are from mid-summer).

In addition, I've added support for console scrollback, somewhat inspired by
Linux's vgacon driver. Basically, instead of allocating our own buffer and
doing lots of copies, we take advantage of Video RAM and just modify the VGA
display origin register as appropriate. This approach has a few advantages:
simple to implement, no wasted KVM, it's fast, and after a boot you can now
scroll back all the way to the BIOS messages (assuming your msgbuf is of a
typical length :). Disadvantages are that the VRAM buffer is relatively
small (only 32k) and we do not support raster devices through this method.
(thanks to mickey@@ for pointing this out).

The code for this is fairly unobtrusive, so should we come up with a better
approach to console scrollback at a later time (i.e., even more platform
independent) it should be easy to revert this.

We're one step further in porting nice features of PCVT over to wscons.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d31 2
d43 24
d182 3
@


1.3
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: vgavar.h,v 1.2 1996/11/23 06:06:43 cgd Exp $	*/
/*	$NetBSD: vgavar.h,v 1.2 1996/11/23 06:06:43 cgd Exp $	*/
d31 4
a34 21
struct vga_config {
	/*
	 * Filled in by front-ends.
	 */
	bus_space_tag_t	vc_iot, vc_memt;
	bus_space_handle_t vc_ioh_b, vc_ioh_c, vc_ioh_d, vc_memh;

	/*
	 * Private to back-end.
	 */
	int		vc_ncol, vc_nrow; /* screen width & height */
	int		vc_ccol, vc_crow; /* current cursor position */

	char		vc_so;		/* in standout mode? */
	char		vc_at;		/* normal attributes */
	char		vc_so_at;	/* standout attributes */

	int	(*vc_ioctl) __P((void *, u_long,
		    caddr_t, int, struct proc *));
	int	(*vc_mmap) __P((void *, off_t, int));
	
d36 102
d140 16
a155 6
void	vga_common_setup __P((bus_space_tag_t, bus_space_tag_t,
	    struct vga_config *));
void	vga_wscons_attach __P((struct device *, struct vga_config *, int));
void	vga_wscons_console __P((struct vga_config *));
int	vgaioctl __P((void *, u_long, caddr_t, int, struct proc *));
int	vgammap __P((void *, off_t, int));
@


1.3.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/* $OpenBSD: vgavar.h,v 1.4 2000/11/15 20:17:38 aaron Exp $ */
/* $NetBSD: vgavar.h,v 1.4 2000/06/17 07:11:50 soda Exp $ */
d31 21
a51 4
struct vga_handle {
	struct pcdisplay_handle vh_ph;
	bus_space_handle_t vh_ioh_vga, vh_allmemh;
	int vh_mono;
a52 102
#define vh_iot vh_ph.ph_iot
#define vh_memt vh_ph.ph_memt
#define vh_ioh_6845 vh_ph.ph_ioh_6845
#define vh_memh vh_ph.ph_memh

static inline u_int8_t _vga_attr_read __P((struct vga_handle *, int));
static inline void _vga_attr_write __P((struct vga_handle *, int, u_int8_t));
static inline u_int8_t _vga_ts_read __P((struct vga_handle *, int));
static inline void _vga_ts_write __P((struct vga_handle *, int, u_int8_t));
static inline u_int8_t _vga_gdc_read __P((struct vga_handle *, int));
static inline void _vga_gdc_write __P((struct vga_handle *, int, u_int8_t));

static inline u_int8_t _vga_attr_read(vh, reg)
	struct vga_handle *vh;
	int reg;
{
	u_int8_t res;

	/* reset state */
	(void) bus_space_read_1(vh->vh_iot, vh->vh_ioh_6845, 10);

	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_ATC_INDEX, reg);
	res = bus_space_read_1(vh->vh_iot, vh->vh_ioh_vga, VGA_ATC_DATAR);

	/* reset state XXX unneeded? */
	(void) bus_space_read_1(vh->vh_iot, vh->vh_ioh_6845, 10);

	/* enable */
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, 0, 0x20);

	return (res);
}

static inline void _vga_attr_write(vh, reg, val)
	struct vga_handle *vh;
	int reg;
	u_int8_t val;
{
	/* reset state */
	(void) bus_space_read_1(vh->vh_iot, vh->vh_ioh_6845, 10);

	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_ATC_INDEX, reg);
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_ATC_DATAW, val);

	/* reset state XXX unneeded? */
	(void) bus_space_read_1(vh->vh_iot, vh->vh_ioh_6845, 10);

	/* enable */
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, 0, 0x20);
}

static inline u_int8_t _vga_ts_read(vh, reg)
	struct vga_handle *vh;
	int reg;
{
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_TS_INDEX, reg);
	return (bus_space_read_1(vh->vh_iot, vh->vh_ioh_vga, VGA_TS_DATA));
}

static inline void _vga_ts_write(vh, reg, val)
	struct vga_handle *vh;
	int reg;
	u_int8_t val;
{
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_TS_INDEX, reg);
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_TS_DATA, val);
}

static inline u_int8_t _vga_gdc_read(vh, reg)
	struct vga_handle *vh;
	int reg;
{
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_GDC_INDEX, reg);
	return (bus_space_read_1(vh->vh_iot, vh->vh_ioh_vga, VGA_GDC_DATA));
}

static inline void _vga_gdc_write(vh, reg, val)
	struct vga_handle *vh;
	int reg;
	u_int8_t val;
{
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_GDC_INDEX, reg);
	bus_space_write_1(vh->vh_iot, vh->vh_ioh_vga, VGA_GDC_DATA, val);
}

#define vga_attr_read(vh, reg) \
	_vga_attr_read(vh, offsetof(struct reg_vgaattr, reg))
#define vga_attr_write(vh, reg, val) \
	_vga_attr_write(vh, offsetof(struct reg_vgaattr, reg), val)
#define vga_ts_read(vh, reg) \
	_vga_ts_read(vh, offsetof(struct reg_vgats, reg))
#define vga_ts_write(vh, reg, val) \
	_vga_ts_write(vh, offsetof(struct reg_vgats, reg), val)
#define vga_gdc_read(vh, reg) \
	_vga_gdc_read(vh, offsetof(struct reg_vgagdc, reg))
#define vga_gdc_write(vh, reg, val) \
	_vga_gdc_write(vh, offsetof(struct reg_vgagdc, reg), val)

#define vga_6845_read(vh, reg) \
	pcdisplay_6845_read(&(vh)->vh_ph, reg)
#define vga_6845_write(vh, reg, val) \
	pcdisplay_6845_write(&(vh)->vh_ph, reg, val)
d55 6
a60 16
void	vga_common_attach __P((struct device *, bus_space_tag_t,
			       bus_space_tag_t, int));
#ifdef arc
void	vga_extended_attach __P((struct device *, bus_space_tag_t,
				 bus_space_tag_t, int,
				 int (*) __P((void *, off_t, int))));
#endif
int	vga_is_console __P((bus_space_tag_t, int));

int	vga_cnattach __P((bus_space_tag_t, bus_space_tag_t, int, int));

struct wsscreen_descr;
void vga_loadchars __P((struct vga_handle *, int, int, int, int, char *));
void vga_setfontset __P((struct vga_handle *, int, int));
void vga_setscreentype __P((struct vga_handle *,
			    const struct wsscreen_descr *));
@


1.3.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: vgavar.h,v 1.3.10.1 2001/05/14 22:24:23 niklas Exp $ */
a30 2
#include <sys/timeout.h>

a40 24
struct vga_config {
	struct vga_handle hdl;

	struct device *vc_softc;
	int vc_type;
	int nscreens;
	LIST_HEAD(, vgascreen) screens;
	struct vgascreen *active; /* current display */
	const struct wsscreen_descr *currenttype;
	int currentfontset1, currentfontset2;

	struct vgafont *vc_fonts[8];

	struct vgascreen *wantedscreen;
	void (*switchcb) __P((void *, int, int));
	void *switchcbarg;

#ifdef arc
	paddr_t (*vc_mmap) __P((void *, off_t, int));
#endif

	struct timeout vc_switch_timeout;
};

a155 3
#if NVGA_PCI > 0
int vga_pci_ioctl __P((void *, u_long, caddr_t, int, struct proc *)); 
#endif
@


1.3.10.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d57 1
a57 1
	void (*switchcb)(void *, int, int);
d61 1
a61 1
	paddr_t (*vc_mmap)(void *, off_t, int);
d67 6
a72 6
static inline u_int8_t _vga_attr_read(struct vga_handle *, int);
static inline void _vga_attr_write(struct vga_handle *, int, u_int8_t);
static inline u_int8_t _vga_ts_read(struct vga_handle *, int);
static inline void _vga_ts_write(struct vga_handle *, int, u_int8_t);
static inline u_int8_t _vga_gdc_read(struct vga_handle *, int);
static inline void _vga_gdc_write(struct vga_handle *, int, u_int8_t);
d165 3
a167 3
int	vga_common_probe(bus_space_tag_t, bus_space_tag_t);
void	vga_common_attach(struct device *, bus_space_tag_t,
			  bus_space_tag_t, int);
d169 3
a171 3
void	vga_extended_attach(struct device *, bus_space_tag_t,
			    bus_space_tag_t, int,
			    int (*)(void *, off_t, int));
d173 1
a173 1
int	vga_is_console(bus_space_tag_t, int);
d175 1
a175 1
int	vga_cnattach(bus_space_tag_t, bus_space_tag_t, int, int);
d178 4
a181 4
void vga_loadchars(struct vga_handle *, int, int, int, int, char *);
void vga_setfontset(struct vga_handle *, int, int);
void vga_setscreentype(struct vga_handle *,
		       const struct wsscreen_descr *);
d183 1
a183 1
int vga_pci_ioctl(void *, u_long, caddr_t, int, struct proc *); 
@


1.3.10.4
log
@Sync the SMP branch with 3.3
@
text
@d60 1
d62 1
d167 2
a168 1
			       bus_space_tag_t, int);
d170 3
a172 1
    bus_space_tag_t, int, paddr_t (*)(void *, off_t, int));
d174 1
@


1.2
log
@wscons -> vga_xxx -> vga mmap() support. first cut
@
text
@d1 1
@


1.1
log
@alpha/common/ insults my filec
@
text
@d46 5
d58 2
@
