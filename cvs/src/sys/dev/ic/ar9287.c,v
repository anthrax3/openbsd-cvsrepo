head	1.25;
access;
symbols
	OPENBSD_6_0:1.24.0.6
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.6
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.4
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.25
date	2017.01.12.16.32.28;	author stsp;	state Exp;
branches;
next	1.24;
commitid	1Zd7y0b8dZf1uELZ;

1.24
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.23;
commitid	2QagMjdMhQhIaQgu;

1.23
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.22;
commitid	5gdEnqVoJuTuwdTu;

1.22
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.21;
commitid	FuSD2mFDJWATHIDx;

1.21
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.20;
commitid	5DvsamK0GblTp8ww;

1.20
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.19;
commitid	LS2TNeCue5R9L67C;

1.19
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.18;
commitid	TGHgrLxu6sxZoiFt;

1.18
date	2013.08.07.01.06.28;	author bluhm;	state Exp;
branches;
next	1.17;

1.17
date	2012.06.10.21.23.36;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.31.17.50.48;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.31.14.06.05;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2010.08.12.16.32.31;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.15.19.29.00;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.15.19.07.43;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.03.18.02.50;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.10.17.44.21;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.23.16.05.39;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.05.19.09.00;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.05.19.00.50;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.28.13.02.57;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.17.19.32.22;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.15.14.04.02;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.14.20.18.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.14.16.55.11;	author damien;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Finish initial 11n support for athn(4).

The heavy lifting was done by damien@@ years ago. I didn't even have
to figure out what the hardware expects, the code was already there.

This driver now supports MCS 0-15 in client and hostap mode.
No Tx aggregation and no 40 MHz channels yet.

tested by vgross@@, bmercer@@, tb@@, jmc@@, Vadim Vygonets, Peter Kay
ok bmercer@@ tb@@ phessler@@
@
text
@/*	$OpenBSD: ar9287.c,v 1.24 2016/01/05 18:41:15 stsp Exp $	*/

/*-
 * Copyright (c) 2009 Damien Bergamini <damien.bergamini@@free.fr>
 * Copyright (c) 2008-2009 Atheros Communications Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Atheros 802.11a/g/n chipsets.
 * Routines for AR9227 and AR9287 chipsets.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_mira.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/athnreg.h>
#include <dev/ic/athnvar.h>

#include <dev/ic/ar5008reg.h>
#include <dev/ic/ar9280reg.h>
#include <dev/ic/ar9287reg.h>

int	ar9287_attach(struct athn_softc *);
void	ar9287_setup(struct athn_softc *);
void	ar9287_swap_rom(struct athn_softc *);
const	struct ar_spur_chan *ar9287_get_spur_chans(struct athn_softc *, int);
void	ar9287_init_from_rom(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9287_get_pdadcs(struct athn_softc *, struct ieee80211_channel *,
	    int, int, uint8_t, uint8_t *, uint8_t *);
void	ar9287_olpc_get_pdgain(struct athn_softc *, struct ieee80211_channel *,
	    int, int8_t *);
void	ar9287_set_power_calib(struct athn_softc *,
	    struct ieee80211_channel *);
void	ar9287_set_txpower(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9287_olpc_init(struct athn_softc *);
void	ar9287_olpc_temp_compensation(struct athn_softc *);
void	ar9287_1_3_enable_async_fifo(struct athn_softc *);
void	ar9287_1_3_setup_async_fifo(struct athn_softc *);

/* Extern functions. */
uint8_t	athn_chan2fbin(struct ieee80211_channel *);
void	athn_get_pier_ival(uint8_t, const uint8_t *, int, int *, int *);
int	ar5008_attach(struct athn_softc *);
void	ar5008_write_txpower(struct athn_softc *, int16_t power[]);
void	ar5008_get_pdadcs(struct athn_softc *, uint8_t, struct athn_pier *,
	    struct athn_pier *, int, int, uint8_t, uint8_t *, uint8_t *);
void	ar5008_get_lg_tpow(struct athn_softc *, struct ieee80211_channel *,
	    uint8_t, const struct ar_cal_target_power_leg *, int, uint8_t[]);
void	ar5008_get_ht_tpow(struct athn_softc *, struct ieee80211_channel *,
	    uint8_t, const struct ar_cal_target_power_ht *, int, uint8_t[]);
int	ar9280_set_synth(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9280_spur_mitigate(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);


int
ar9287_attach(struct athn_softc *sc)
{
	sc->eep_base = AR9287_EEP_START_LOC;
	sc->eep_size = sizeof(struct ar9287_eeprom);
	sc->def_nf = AR9287_PHY_CCA_MAX_GOOD_VALUE;
	sc->ngpiopins = (sc->flags & ATHN_FLAG_USB) ? 16 : 11;
	sc->led_pin = 8;
	sc->workaround = AR9285_WA_DEFAULT;
	sc->ops.setup = ar9287_setup;
	sc->ops.swap_rom = ar9287_swap_rom;
	sc->ops.init_from_rom = ar9287_init_from_rom;
	sc->ops.set_txpower = ar9287_set_txpower;
	sc->ops.set_synth = ar9280_set_synth;
	sc->ops.spur_mitigate = ar9280_spur_mitigate;
	sc->ops.get_spur_chans = ar9287_get_spur_chans;
	sc->ops.olpc_init = ar9287_olpc_init;
	sc->ops.olpc_temp_compensation = ar9287_olpc_temp_compensation;
	sc->ini = &ar9287_1_1_ini;
	sc->serdes = &ar9280_2_0_serdes;

	return (ar5008_attach(sc));
}

void
ar9287_setup(struct athn_softc *sc)
{
	const struct ar9287_eeprom *eep = sc->eep;

	/* Determine if open loop power control should be used. */
	if (eep->baseEepHeader.openLoopPwrCntl)
		sc->flags |= ATHN_FLAG_OLPC;

	sc->rx_gain = &ar9287_1_1_rx_gain;
	sc->tx_gain = &ar9287_1_1_tx_gain;
}

void
ar9287_swap_rom(struct athn_softc *sc)
{
	struct ar9287_eeprom *eep = sc->eep;
	int i;

	eep->modalHeader.antCtrlCommon =
	    swap32(eep->modalHeader.antCtrlCommon);

	for (i = 0; i < AR9287_MAX_CHAINS; i++) {
		eep->modalHeader.antCtrlChain[i] =
		    swap32(eep->modalHeader.antCtrlChain[i]);
	}
	for (i = 0; i < AR_EEPROM_MODAL_SPURS; i++) {
		eep->modalHeader.spurChans[i].spurChan =
		    swap16(eep->modalHeader.spurChans[i].spurChan);
	}
}

const struct ar_spur_chan *
ar9287_get_spur_chans(struct athn_softc *sc, int is2ghz)
{
	const struct ar9287_eeprom *eep = sc->eep;

	KASSERT(is2ghz);
	return (eep->modalHeader.spurChans);
}

void
ar9287_init_from_rom(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	const struct ar9287_eeprom *eep = sc->eep;
	const struct ar9287_modal_eep_header *modal = &eep->modalHeader;
	uint32_t reg, offset;
	int i;

	AR_WRITE(sc, AR_PHY_SWITCH_COM, modal->antCtrlCommon);

	for (i = 0; i < AR9287_MAX_CHAINS; i++) {
		offset = i * 0x1000;

		AR_WRITE(sc, AR_PHY_SWITCH_CHAIN_0 + offset,
		    modal->antCtrlChain[i]);

		reg = AR_READ(sc, AR_PHY_TIMING_CTRL4_0 + offset);
		reg = RW(reg, AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF,
		    modal->iqCalICh[i]);
		reg = RW(reg, AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF,
		    modal->iqCalQCh[i]);
		AR_WRITE(sc, AR_PHY_TIMING_CTRL4_0 + offset, reg);

		reg = AR_READ(sc, AR_PHY_GAIN_2GHZ + offset);
		reg = RW(reg, AR_PHY_GAIN_2GHZ_XATTEN1_MARGIN,
		    modal->bswMargin[i]);
		reg = RW(reg, AR_PHY_GAIN_2GHZ_XATTEN1_DB,
		    modal->bswAtten[i]);
		AR_WRITE(sc, AR_PHY_GAIN_2GHZ + offset, reg);

		reg = AR_READ(sc, AR_PHY_RXGAIN + offset);
		reg = RW(reg, AR9280_PHY_RXGAIN_TXRX_MARGIN,
		    modal->rxTxMarginCh[i]);
		reg = RW(reg, AR9280_PHY_RXGAIN_TXRX_ATTEN,
		    modal->txRxAttenCh[i]);
		AR_WRITE(sc, AR_PHY_RXGAIN + offset, reg);
	}

	reg = AR_READ(sc, AR_PHY_SETTLING);
	if (extc != NULL)
		reg = RW(reg, AR_PHY_SETTLING_SWITCH, modal->swSettleHt40);
	else
		reg = RW(reg, AR_PHY_SETTLING_SWITCH, modal->switchSettling);
	AR_WRITE(sc, AR_PHY_SETTLING, reg);

	reg = AR_READ(sc, AR_PHY_DESIRED_SZ);
	reg = RW(reg, AR_PHY_DESIRED_SZ_ADC, modal->adcDesiredSize);
	AR_WRITE(sc, AR_PHY_DESIRED_SZ, reg);

	reg  = SM(AR_PHY_RF_CTL4_TX_END_XPAA_OFF, modal->txEndToXpaOff);
	reg |= SM(AR_PHY_RF_CTL4_TX_END_XPAB_OFF, modal->txEndToXpaOff);
	reg |= SM(AR_PHY_RF_CTL4_FRAME_XPAA_ON, modal->txFrameToXpaOn);
	reg |= SM(AR_PHY_RF_CTL4_FRAME_XPAB_ON, modal->txFrameToXpaOn);
	AR_WRITE(sc, AR_PHY_RF_CTL4, reg);

	reg = AR_READ(sc, AR_PHY_RF_CTL3);
	reg = RW(reg, AR_PHY_TX_END_TO_A2_RX_ON, modal->txEndToRxOn);
	AR_WRITE(sc, AR_PHY_RF_CTL3, reg);

	reg = AR_READ(sc, AR_PHY_CCA(0));
	reg = RW(reg, AR9280_PHY_CCA_THRESH62, modal->thresh62);
	AR_WRITE(sc, AR_PHY_CCA(0), reg);

	reg = AR_READ(sc, AR_PHY_EXT_CCA0);
	reg = RW(reg, AR_PHY_EXT_CCA0_THRESH62, modal->thresh62);
	AR_WRITE(sc, AR_PHY_EXT_CCA0, reg);

	reg = AR_READ(sc, AR9287_AN_RF2G3_CH0);
	reg = RW(reg, AR9287_AN_RF2G3_DB1, modal->db1);
	reg = RW(reg, AR9287_AN_RF2G3_DB2, modal->db2);
	reg = RW(reg, AR9287_AN_RF2G3_OB_CCK, modal->ob_cck);
	reg = RW(reg, AR9287_AN_RF2G3_OB_PSK, modal->ob_psk);
	reg = RW(reg, AR9287_AN_RF2G3_OB_QAM, modal->ob_qam);
	reg = RW(reg, AR9287_AN_RF2G3_OB_PAL_OFF, modal->ob_pal_off);
	AR_WRITE(sc, AR9287_AN_RF2G3_CH0, reg);
	AR_WRITE_BARRIER(sc);
	DELAY(100);

	reg = AR_READ(sc, AR9287_AN_RF2G3_CH1);
	reg = RW(reg, AR9287_AN_RF2G3_DB1, modal->db1);
	reg = RW(reg, AR9287_AN_RF2G3_DB2, modal->db2);
	reg = RW(reg, AR9287_AN_RF2G3_OB_CCK, modal->ob_cck);
	reg = RW(reg, AR9287_AN_RF2G3_OB_PSK, modal->ob_psk);
	reg = RW(reg, AR9287_AN_RF2G3_OB_QAM, modal->ob_qam);
	reg = RW(reg, AR9287_AN_RF2G3_OB_PAL_OFF, modal->ob_pal_off);
	AR_WRITE(sc, AR9287_AN_RF2G3_CH1, reg);
	AR_WRITE_BARRIER(sc);
	DELAY(100);

	reg = AR_READ(sc, AR_PHY_RF_CTL2);
	reg = RW(reg, AR_PHY_TX_END_DATA_START, modal->txFrameToDataStart);
	reg = RW(reg, AR_PHY_TX_END_PA_ON, modal->txFrameToPaOn);
	AR_WRITE(sc, AR_PHY_RF_CTL2, reg);

	reg = AR_READ(sc, AR9287_AN_TOP2);
	reg = RW(reg, AR9287_AN_TOP2_XPABIAS_LVL, modal->xpaBiasLvl);
	AR_WRITE(sc, AR9287_AN_TOP2, reg);
	AR_WRITE_BARRIER(sc);
	DELAY(100);
}

void
ar9287_get_pdadcs(struct athn_softc *sc, struct ieee80211_channel *c,
    int chain, int nxpdgains, uint8_t overlap, uint8_t *boundaries,
    uint8_t *pdadcs)
{
	const struct ar9287_eeprom *eep = sc->eep;
	const struct ar9287_cal_data_per_freq *pierdata;
	const uint8_t *pierfreq;
	struct athn_pier lopier, hipier;
	int16_t delta;
	uint8_t fbin;
	int i, lo, hi, npiers;

	pierfreq = eep->calFreqPier2G;
	pierdata = (const struct ar9287_cal_data_per_freq *)
	    eep->calPierData2G[chain];
	npiers = AR9287_NUM_2G_CAL_PIERS;

	/* Find channel in ROM pier table. */
	fbin = athn_chan2fbin(c);
	athn_get_pier_ival(fbin, pierfreq, npiers, &lo, &hi);

	lopier.fbin = pierfreq[lo];
	hipier.fbin = pierfreq[hi];
	for (i = 0; i < nxpdgains; i++) {
		lopier.pwr[i] = pierdata[lo].pwrPdg[i];
		lopier.vpd[i] = pierdata[lo].vpdPdg[i];
		hipier.pwr[i] = pierdata[lo].pwrPdg[i];
		hipier.vpd[i] = pierdata[lo].vpdPdg[i];
	}
	ar5008_get_pdadcs(sc, fbin, &lopier, &hipier, nxpdgains,
	    AR9287_PD_GAIN_ICEPTS, overlap, boundaries, pdadcs);

	delta = (eep->baseEepHeader.pwrTableOffset -
	    AR_PWR_TABLE_OFFSET_DB) * 2;	/* In half dB. */
	if (delta != 0) {
		/* Shift the PDADC table to start at the new offset. */
		/* XXX Our padding value differs from Linux. */
		for (i = 0; i < AR_NUM_PDADC_VALUES; i++)
			pdadcs[i] = pdadcs[MIN(i + delta,
			    AR_NUM_PDADC_VALUES - 1)];
	}
}

void
ar9287_olpc_get_pdgain(struct athn_softc *sc, struct ieee80211_channel *c,
    int chain, int8_t *pwr)
{
	const struct ar9287_eeprom *eep = sc->eep;
	const struct ar_cal_data_per_freq_olpc *pierdata;
	const uint8_t *pierfreq;
	uint8_t fbin;
	int lo, hi, npiers;

	pierfreq = eep->calFreqPier2G;
	pierdata = (const struct ar_cal_data_per_freq_olpc *)
	    eep->calPierData2G[chain];
	npiers = AR9287_NUM_2G_CAL_PIERS;

	/* Find channel in ROM pier table. */
	fbin = athn_chan2fbin(c);
	athn_get_pier_ival(fbin, pierfreq, npiers, &lo, &hi);

#if 0
	*pwr = athn_interpolate(fbin,
	    pierfreq[lo], pierdata[lo].pwrPdg[0][0],
	    pierfreq[hi], pierdata[hi].pwrPdg[0][0]);
#else
	*pwr = (pierdata[lo].pwrPdg[0][0] + pierdata[hi].pwrPdg[0][0]) / 2;
#endif
}

void
ar9287_set_power_calib(struct athn_softc *sc, struct ieee80211_channel *c)
{
	const struct ar9287_eeprom *eep = sc->eep;
	uint8_t boundaries[AR_PD_GAINS_IN_MASK];
	uint8_t pdadcs[AR_NUM_PDADC_VALUES];
	uint8_t xpdgains[AR9287_NUM_PD_GAINS];
	int8_t txpower;
	uint8_t overlap;
	uint32_t reg, offset;
	int i, j, nxpdgains;

	if (sc->eep_rev < AR_EEP_MINOR_VER_2) {
		overlap = MS(AR_READ(sc, AR_PHY_TPCRG5),
		    AR_PHY_TPCRG5_PD_GAIN_OVERLAP);
	} else
		overlap = eep->modalHeader.pdGainOverlap;

	if (sc->flags & ATHN_FLAG_OLPC) {
		/* XXX not here. */
		sc->pdadc =
		    ((const struct ar_cal_data_per_freq_olpc *)
		     eep->calPierData2G[0])->vpdPdg[0][0];
	}

	nxpdgains = 0;
	memset(xpdgains, 0, sizeof(xpdgains));
	for (i = AR9287_PD_GAINS_IN_MASK - 1; i >= 0; i--) {
		if (nxpdgains >= AR9287_NUM_PD_GAINS)
			break;		/* Can't happen. */
		if (eep->modalHeader.xpdGain & (1 << i))
			xpdgains[nxpdgains++] = i;
	}
	reg = AR_READ(sc, AR_PHY_TPCRG1);
	reg = RW(reg, AR_PHY_TPCRG1_NUM_PD_GAIN, nxpdgains - 1);
	reg = RW(reg, AR_PHY_TPCRG1_PD_GAIN_1, xpdgains[0]);
	reg = RW(reg, AR_PHY_TPCRG1_PD_GAIN_2, xpdgains[1]);
	AR_WRITE(sc, AR_PHY_TPCRG1, reg);
	AR_WRITE_BARRIER(sc);

	for (i = 0; i < AR9287_MAX_CHAINS; i++)	{
		if (!(sc->txchainmask & (1 << i)))
			continue;

		offset = i * 0x1000;

		if (sc->flags & ATHN_FLAG_OLPC) {
			ar9287_olpc_get_pdgain(sc, c, i, &txpower);

			reg = AR_READ(sc, AR_PHY_TX_PWRCTRL6_0);
			reg = RW(reg, AR_PHY_TX_PWRCTRL_ERR_EST_MODE, 3);
			AR_WRITE(sc, AR_PHY_TX_PWRCTRL6_0, reg);

			reg = AR_READ(sc, AR_PHY_TX_PWRCTRL6_1);
			reg = RW(reg, AR_PHY_TX_PWRCTRL_ERR_EST_MODE, 3);
			AR_WRITE(sc, AR_PHY_TX_PWRCTRL6_1, reg);

			/* NB: txpower is in half dB. */
			reg = AR_READ(sc, AR_PHY_CH0_TX_PWRCTRL11 + offset);
			reg = RW(reg, AR_PHY_TX_PWRCTRL_OLPC_PWR, txpower);
			AR_WRITE(sc, AR_PHY_CH0_TX_PWRCTRL11 + offset, reg);

			AR_WRITE_BARRIER(sc);
			continue;	/* That's it for open loop mode. */
		}

		/* Closed loop power control. */
		ar9287_get_pdadcs(sc, c, i, nxpdgains, overlap,
		    boundaries, pdadcs);

		/* Write boundaries. */
		if (i == 0) {
			reg  = SM(AR_PHY_TPCRG5_PD_GAIN_OVERLAP,
			    overlap);
			reg |= SM(AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_1,
			    boundaries[0]);
			reg |= SM(AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_2,
			    boundaries[1]);
			reg |= SM(AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_3,
			    boundaries[2]);
			reg |= SM(AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_4,
			    boundaries[3]);
			AR_WRITE(sc, AR_PHY_TPCRG5 + offset, reg);
		}
		/* Write PDADC values. */
		for (j = 0; j < AR_NUM_PDADC_VALUES; j += 4) {
			AR_WRITE(sc, AR_PHY_PDADC_TBL_BASE + offset + j,
			    pdadcs[j + 0] <<  0 |
			    pdadcs[j + 1] <<  8 |
			    pdadcs[j + 2] << 16 |
			    pdadcs[j + 3] << 24);
		}
		AR_WRITE_BARRIER(sc);
	}
}

void
ar9287_set_txpower(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	const struct ar9287_eeprom *eep = sc->eep;
	const struct ar9287_modal_eep_header *modal = &eep->modalHeader;
	uint8_t tpow_cck[4], tpow_ofdm[4];
	uint8_t tpow_cck_ext[4], tpow_ofdm_ext[4];
	uint8_t tpow_ht20[8], tpow_ht40[8];
	uint8_t ht40inc;
	int16_t pwr = 0, max_ant_gain, power[ATHN_POWER_COUNT];
	int i;

	ar9287_set_power_calib(sc, c);

	/* Compute transmit power reduction due to antenna gain. */
	max_ant_gain = MAX(modal->antennaGainCh[0], modal->antennaGainCh[1]);
	/* XXX */

	/*
	 * Reduce scaled power by number of active chains to get per-chain
	 * transmit power level.
	 */
	if (sc->ntxchains == 2)
		pwr -= AR_PWR_DECREASE_FOR_2_CHAIN;
	if (pwr < 0)
		pwr = 0;

	/* Get CCK target powers. */
	ar5008_get_lg_tpow(sc, c, AR_CTL_11B, eep->calTargetPowerCck,
	    AR9287_NUM_2G_CCK_TARGET_POWERS, tpow_cck);

	/* Get OFDM target powers. */
	ar5008_get_lg_tpow(sc, c, AR_CTL_11G, eep->calTargetPower2G,
	    AR9287_NUM_2G_20_TARGET_POWERS, tpow_ofdm);

	/* Get HT-20 target powers. */
	ar5008_get_ht_tpow(sc, c, AR_CTL_2GHT20, eep->calTargetPower2GHT20,
	    AR9287_NUM_2G_20_TARGET_POWERS, tpow_ht20);

	if (extc != NULL) {
		/* Get HT-40 target powers. */
		ar5008_get_ht_tpow(sc, c, AR_CTL_2GHT40,
		    eep->calTargetPower2GHT40, AR9287_NUM_2G_40_TARGET_POWERS,
		    tpow_ht40);

		/* Get secondary channel CCK target powers. */
		ar5008_get_lg_tpow(sc, extc, AR_CTL_11B,
		    eep->calTargetPowerCck, AR9287_NUM_2G_CCK_TARGET_POWERS,
		    tpow_cck_ext);

		/* Get secondary channel OFDM target powers. */
		ar5008_get_lg_tpow(sc, extc, AR_CTL_11G,
		    eep->calTargetPower2G, AR9287_NUM_2G_20_TARGET_POWERS,
		    tpow_ofdm_ext);
	}

	memset(power, 0, sizeof(power));
	/* Shuffle target powers accross transmit rates. */
	power[ATHN_POWER_OFDM6   ] =
	power[ATHN_POWER_OFDM9   ] =
	power[ATHN_POWER_OFDM12  ] =
	power[ATHN_POWER_OFDM18  ] =
	power[ATHN_POWER_OFDM24  ] = tpow_ofdm[0];
	power[ATHN_POWER_OFDM36  ] = tpow_ofdm[1];
	power[ATHN_POWER_OFDM48  ] = tpow_ofdm[2];
	power[ATHN_POWER_OFDM54  ] = tpow_ofdm[3];
	power[ATHN_POWER_XR      ] = tpow_ofdm[0];
	power[ATHN_POWER_CCK1_LP ] = tpow_cck[0];
	power[ATHN_POWER_CCK2_LP ] =
	power[ATHN_POWER_CCK2_SP ] = tpow_cck[1];
	power[ATHN_POWER_CCK55_LP] =
	power[ATHN_POWER_CCK55_SP] = tpow_cck[2];
	power[ATHN_POWER_CCK11_LP] =
	power[ATHN_POWER_CCK11_SP] = tpow_cck[3];
	for (i = 0; i < nitems(tpow_ht20); i++)
		power[ATHN_POWER_HT20(i)] = tpow_ht20[i];
	if (extc != NULL) {
		/* Correct PAR difference between HT40 and HT20/Legacy. */
		if (sc->eep_rev >= AR_EEP_MINOR_VER_2)
			ht40inc = modal->ht40PowerIncForPdadc;
		else
			ht40inc = AR_HT40_POWER_INC_FOR_PDADC;
		for (i = 0; i < nitems(tpow_ht40); i++)
			power[ATHN_POWER_HT40(i)] = tpow_ht40[i] + ht40inc;
		power[ATHN_POWER_OFDM_DUP] = tpow_ht40[0];
		power[ATHN_POWER_CCK_DUP ] = tpow_ht40[0];
		power[ATHN_POWER_OFDM_EXT] = tpow_ofdm_ext[0];
		if (IEEE80211_IS_CHAN_2GHZ(c))
			power[ATHN_POWER_CCK_EXT] = tpow_cck_ext[0];
	}

	for (i = 0; i < ATHN_POWER_COUNT; i++) {
		power[i] -= AR_PWR_TABLE_OFFSET_DB * 2;	/* In half dB. */
		if (power[i] > AR_MAX_RATE_POWER)
			power[i] = AR_MAX_RATE_POWER;
	}
	/* Commit transmit power values to hardware. */
	ar5008_write_txpower(sc, power);
}

void
ar9287_olpc_init(struct athn_softc *sc)
{
	uint32_t reg;

	AR_SETBITS(sc, AR_PHY_TX_PWRCTRL9, AR_PHY_TX_PWRCTRL9_RES_DC_REMOVAL);

	reg = AR_READ(sc, AR9287_AN_TXPC0);
	reg = RW(reg, AR9287_AN_TXPC0_TXPCMODE,
	    AR9287_AN_TXPC0_TXPCMODE_TEMPSENSE);
	AR_WRITE(sc, AR9287_AN_TXPC0, reg);
	AR_WRITE_BARRIER(sc);
	DELAY(100);
}

void
ar9287_olpc_temp_compensation(struct athn_softc *sc)
{
	const struct ar9287_eeprom *eep = sc->eep;
	int8_t pdadc, slope, tcomp;
	uint32_t reg;

	reg = AR_READ(sc, AR_PHY_TX_PWRCTRL4);
	pdadc = MS(reg, AR_PHY_TX_PWRCTRL_PD_AVG_OUT);
	DPRINTFN(3, ("PD Avg Out=%d\n", pdadc));

	if (sc->pdadc == 0 || pdadc == 0)
		return;	/* No frames transmitted yet. */

	/* Compute Tx gain temperature compensation. */
	if (sc->eep_rev >= AR_EEP_MINOR_VER_2)
		slope = eep->baseEepHeader.tempSensSlope;
	else
		slope = 0;
	if (slope != 0)	/* Prevents division by zero. */
		tcomp = ((pdadc - sc->pdadc) * 4) / slope;
	else
		tcomp = 0;
	DPRINTFN(3, ("OLPC temp compensation=%d\n", tcomp));

	/* Write compensation value for both Tx chains. */
	reg = AR_READ(sc, AR_PHY_CH0_TX_PWRCTRL11);
	reg = RW(reg, AR_PHY_TX_PWRCTRL_OLPC_TEMP_COMP, tcomp);
	AR_WRITE(sc, AR_PHY_CH0_TX_PWRCTRL11, reg);

	reg = AR_READ(sc, AR_PHY_CH1_TX_PWRCTRL11);
	reg = RW(reg, AR_PHY_TX_PWRCTRL_OLPC_TEMP_COMP, tcomp);
	AR_WRITE(sc, AR_PHY_CH1_TX_PWRCTRL11, reg);
	AR_WRITE_BARRIER(sc);
}

void
ar9287_1_3_enable_async_fifo(struct athn_softc *sc)
{
	/* Enable ASYNC FIFO. */
	AR_SETBITS(sc, AR_MAC_PCU_ASYNC_FIFO_REG3,
	    AR_MAC_PCU_ASYNC_FIFO_REG3_DATAPATH_SEL);
	AR_SETBITS(sc, AR_PHY_MODE, AR_PHY_MODE_ASYNCFIFO);
	AR_CLRBITS(sc, AR_MAC_PCU_ASYNC_FIFO_REG3,
	    AR_MAC_PCU_ASYNC_FIFO_REG3_SOFT_RESET);
	AR_SETBITS(sc, AR_MAC_PCU_ASYNC_FIFO_REG3,
	    AR_MAC_PCU_ASYNC_FIFO_REG3_SOFT_RESET);
	AR_WRITE_BARRIER(sc);
}

void
ar9287_1_3_setup_async_fifo(struct athn_softc *sc)
{
	uint32_t reg;

	/*
	 * MAC runs at 117MHz (instead of 88/44MHz) when ASYNC FIFO is
	 * enabled, so the following counters have to be changed.
	 */
	AR_WRITE(sc, AR_D_GBL_IFS_SIFS, AR_D_GBL_IFS_SIFS_ASYNC_FIFO_DUR);
	AR_WRITE(sc, AR_D_GBL_IFS_SLOT, AR_D_GBL_IFS_SLOT_ASYNC_FIFO_DUR);
	AR_WRITE(sc, AR_D_GBL_IFS_EIFS, AR_D_GBL_IFS_EIFS_ASYNC_FIFO_DUR);

	AR_WRITE(sc, AR_TIME_OUT, AR_TIME_OUT_ACK_CTS_ASYNC_FIFO_DUR);
	AR_WRITE(sc, AR_USEC, AR_USEC_ASYNC_FIFO_DUR);

	AR_SETBITS(sc, AR_MAC_PCU_LOGIC_ANALYZER,
	    AR_MAC_PCU_LOGIC_ANALYZER_DISBUG20768);

	reg = AR_READ(sc, AR_AHB_MODE);
	reg = RW(reg, AR_AHB_CUSTOM_BURST, AR_AHB_CUSTOM_BURST_ASYNC_FIFO_VAL);
	AR_WRITE(sc, AR_AHB_MODE, reg);

	AR_SETBITS(sc, AR_PCU_MISC_MODE2, AR_PCU_MISC_MODE2_ENABLE_AGGWEP);
	AR_WRITE_BARRIER(sc);
}
@


1.24
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.23 2015/11/24 17:11:39 mpi Exp $	*/
d54 1
@


1.23
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.22 2015/11/24 13:45:06 mpi Exp $	*/
a203 1
#ifndef IEEE80211_NO_HT
a206 1
#endif
a440 1
#ifndef IEEE80211_NO_HT
a443 1
#endif
a469 1
#ifndef IEEE80211_NO_HT
a489 1
#endif
a508 1
#ifndef IEEE80211_NO_HT
a524 1
#endif
@


1.22
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.21 2015/11/24 13:33:17 mpi Exp $	*/
a46 1
#include <net/if_dl.h>
@


1.21
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.20 2014/12/19 22:44:58 guenther Exp $	*/
a46 1
#include <net/if_arp.h>
@


1.20
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.19 2014/07/22 13:12:11 mpi Exp $	*/
a49 1
#include <net/if_types.h>
@


1.19
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.18 2013/08/07 01:06:28 bluhm Exp $	*/
d38 1
a40 1
#include <machine/endian.h>
@


1.18
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.17 2012/06/10 21:23:36 kettenis Exp $	*/
a52 1
#include <netinet/in_systm.h>
a53 1
#include <netinet/ip.h>
@


1.17
log
@Allow a variable number of words for the Serializer/Deserializer programming.
Probably not enought to make the AR9380 chips to work, but at least the kernel
shouldn't crash anymore when we see one.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.16 2010/12/31 17:50:48 damien Exp $	*/
a53 1
#include <netinet/in_var.h>
@


1.16
log
@of course, GPIO handling on AR9271 and AR7010 had to be different
from all other chips... quite nightmarish.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.15 2010/12/31 14:06:05 damien Exp $	*/
d124 1
a124 1
	sc->serdes = ar9280_2_0_serdes;
@


1.15
log
@Make the athn(4) back-end more bus agnostic by moving read and write
operations to callbacks in the PCI and CardBus front-ends.
This will allow support of other buses like USB.
Assume the following memory model:
- writes are ordered but may be buffered and require explicit flush
- a read always flushes all buffered writes
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.14 2010/08/12 16:32:31 damien Exp $	*/
d111 1
a111 1
	sc->ngpiopins = 11;
@


1.14
log
@For chips in open-loop power control mode, periodically (every 30 secs)
compensate Tx gain for temperature changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.13 2010/07/15 19:29:00 damien Exp $	*/
d248 1
d259 1
d270 1
d384 1
d408 1
d438 1
d560 1
d597 1
d611 1
d638 1
@


1.13
log
@On AR9285, the antCtrlCommon ROM field may have the upper 16 bits set.
Remove an incorrect mask to fix antenna diversity on some chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.12 2010/07/15 19:07:43 damien Exp $	*/
d122 1
@


1.12
log
@Remove initialization values for chips that never made it into production:
- AR9280 1.0
- AR9285 1.0 and 1.1
- AR9287 1.0

Remove checks that are now useless since we know we will never see those
chips, and rename some functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.11 2010/06/03 18:02:50 damien Exp $	*/
d178 1
a178 1
	AR_WRITE(sc, AR_PHY_SWITCH_COM, modal->antCtrlCommon & 0xffff);
@


1.11
log
@enable async fifo for >=AR9287 1.3 only.
from ath9k.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.10 2010/05/10 17:44:21 damien Exp $	*/
d122 1
a122 4
	if (AR_SREV_9287_11_OR_LATER(sc))
		sc->ini = &ar9287_1_1_ini;
	else
		sc->ini = &ar9287_1_0_ini;
d137 2
a138 7
	if (AR_SREV_9287_11_OR_LATER(sc)) {
		sc->rx_gain = &ar9287_1_1_rx_gain;
		sc->tx_gain = &ar9287_1_1_tx_gain;
	} else {
		sc->rx_gain = &ar9287_1_0_rx_gain;
		sc->tx_gain = &ar9287_1_0_tx_gain;
	}
@


1.10
log
@athn(4) is going to support a new family of Atheros 802.11n
chips (AR9003), which differs from the currently supported
families (AR5008, AR9001 and AR9002).

The main differences (from a driver point of view) are:

* DMA:
Tx and Rx descriptors have changed.
A single Tx descriptor can now reference up to 4 scatter/gather
DMA segments.
There is now a DMA ring for reporting Tx status with separate
Tx status descriptors (this ring is used to report Tx status for
all the Tx FIFOs).
Rx status descriptors are now put at the beginning of Rx buffers
and do not need to be allocated separately from buffers.
There are two Rx FIFOs (low priority and high priority) instead
of one.

* ROM:
The AR9003 family uses OTP-ROM instead of EEPROM.
Reading the ROM is totally insane since vendors can provide only
the chunks of ROM that differ from a default image (and thus the
default image has to be stored in the driver).
This is referenced as "compressed ROM" in the Linux driver, though
there is no real compression involved, at least for the moment.

* PHY registers:
All PHY registers have changed.
Some registers offsets do not fit on 16 bits anymore, but
since they are 32-bit aligned, we can still make them fit on
16 bits to save .rodata space in initialization tables.

* MAC registers:
Some MAC registers offsets have changed (GPIO, interrupt masks)
which is quite annoying (though ~98% remain the same.)

* Initialization values:
Initialization values are now split in mac/soc/bb/radio blocks
and pre/core/post phases in the Linux driver.  I have chosen to
not go that road and merge these blocks in modal and non-modal
initialization values (similar to the other families).
The initialization order remains exactly the same as the Linux
driver though.

To manage these differences, I have split athn.c in two backends:
ar5008.c contains the bits that are specific to the AR5008,
AR9001 and AR9002 families (used by ar5416.c, ar9280.c,
ar9285.c and ar9287.c) and that were previously in athn.c.

ar9003.c contains the bits that are specific to the new
AR9003 family (used by ar9380.c only for now.)

I have introduced a thin hardware abstraction layer (actually
a set of pointers to functions) that is used in athn.c.
My intent is to keep this abstraction layer as thin as possible
and not to create another ugly pile of abstraction layers a la
MadWifi.

I think I've managed to keep things sane, probably at the expense
of duplicating some code in both ar5008.c and ar9003.c, but at
least we do not have to dig through layers and layers of virtual
descriptors to figure out what is mapped to the hardware.

Tested for non-regression on various AR5416 (sparc64+i386), AR9281
and AR9285 (i386 only) adapters.
AR9380 part is not tested (hardware is not available to the general
public yet).

Committed over my AR9285 2.0.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.5 2010/03/28 13:02:57 krw Exp $	*/
d85 2
a86 2
void	ar9287_1_2_enable_async_fifo(struct athn_softc *);
void	ar9287_1_2_setup_async_fifo(struct athn_softc *);
d600 1
a600 1
ar9287_1_2_enable_async_fifo(struct athn_softc *sc)
d613 1
a613 1
ar9287_1_2_setup_async_fifo(struct athn_softc *sc)
@


1.9
log
@give AR9287 some chance to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.8 2010/04/20 22:05:43 tedu Exp $	*/
d65 1
d85 19
d109 1
a109 1
	sc->eep_size = sizeof (struct ar9287_eeprom);
d127 2
a128 1
	return (0);
d174 1
a174 1
	return eep->modalHeader.spurChans;
d308 1
a308 1
	athn_get_pdadcs(sc, fbin, &lopier, &hipier, nxpdgains,
d376 1
a376 1
	memset(xpdgains, 0, sizeof xpdgains);
d474 1
a474 1
	athn_get_lg_tpow(sc, c, AR_CTL_11B, eep->calTargetPowerCck,
d478 1
a478 1
	athn_get_lg_tpow(sc, c, AR_CTL_11G, eep->calTargetPower2G,
d483 1
a483 1
	athn_get_ht_tpow(sc, c, AR_CTL_2GHT20, eep->calTargetPower2GHT20,
d488 1
a488 1
		athn_get_ht_tpow(sc, c, AR_CTL_2GHT40,
d493 3
a495 2
		athn_get_lg_tpow(sc, extc, AR_CTL_11B, eep->calTargetPowerCck,
		    AR9287_NUM_2G_CCK_TARGET_POWERS, tpow_cck_ext);
d498 3
a500 2
		athn_get_lg_tpow(sc, extc, AR_CTL_11G, eep->calTargetPower2G,
		    AR9287_NUM_2G_20_TARGET_POWERS, tpow_ofdm_ext);
d504 1
a504 1
	memset(power, 0, sizeof power);
d547 1
a547 1
	athn_write_txpower(sc, power);
@


1.8
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.7 2010/04/05 19:09:00 damien Exp $	*/
d118 5
a122 1
	if (AR_SREV_9287_10(sc))
a123 3
	else
		sc->rx_gain = &ar9287_1_1_rx_gain;
	if (AR_SREV_9287_10(sc))
d125 1
a125 2
	else
		sc->tx_gain = &ar9287_1_1_tx_gain;
d437 2
d594 4
@


1.7
log
@backout these two files i committed by accident.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.5 2010/03/28 13:02:57 krw Exp $	*/
a28 1
#include <sys/sysctl.h>
@


1.6
log
@fix regression on RT2860C introduced in previous commit.
@
text
@a592 4
	/*
	 * MAC runs at 117MHz (instead of 88/44MHz) when ASYNC FIFO is
	 * enabled, so the following counters have to be changed.
	 */
@


1.5
log
@Four uses of uninitialized variables found by clang via jsg@@. ar5416, ar9287
and athn are only theoretically interesting. i33380211_node fixes a real
bug in occupied channel detection.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.4 2009/11/17 19:32:22 damien Exp $	*/
d593 4
@


1.4
log
@cleanup the printf/DPRINTF mess.
use proper debug levels for diagnostic messages such that we don't
spam the logs when athn_debug is low.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.3 2009/11/15 14:04:02 damien Exp $	*/
d435 1
a435 1
	int16_t pwr, max_ant_gain, power[ATHN_POWER_COUNT];
@


1.3
log
@AR9287 uses GPIO pin 8 for LED, not 1.
Turn link LED on while associated.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.2 2009/11/14 20:18:25 deraadt Exp $	*/
d549 1
a549 1
	DPRINTF(("PD Avg Out=%d\n", pdadc));
d563 1
a563 1
	DPRINTF(("OLPC temp compensation=%d\n", tcomp));
@


1.2
log
@make ramdisks compile
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9287.c,v 1.1 2009/11/14 16:55:11 damien Exp $	*/
d93 1
@


1.1
log
@athn(4), a driver for Atheros 802.11a/g/n devices.
written from scratch based on the vendor driver for Linux (ath9k).
AR9285 and AR9287 parts are 100% untested.
only basic functionnalities are enabled for now.

committed over an AR9281.

"commit" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d429 1
d432 2
a434 1
	uint8_t ht40inc;
@

