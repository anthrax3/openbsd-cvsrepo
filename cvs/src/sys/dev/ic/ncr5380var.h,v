head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.16
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.14
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.8
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.10
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.14
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.12
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.12
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.14
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.10
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.8
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.18
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.12
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.01.18.07.36.35;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.25.13.18.03;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.13.21.12.58;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.24.00.41.51;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.20.23.30.29;	author miod;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.08.08.21.15.42;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	97.09.11.01.07.13;	author kstailey;	state Exp;
branches
	1.5.12.1;
next	1.4;

1.4
date	96.05.26.00.27.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.23.47.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.04.01.31.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.32;	author deraadt;	state Exp;
branches;
next	;

1.5.12.1
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.5.12.2;

1.5.12.2
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.5.12.3;

1.5.12.3
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	1.5.12.4;

1.5.12.4
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.05.19.21.54.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@replace XS_NO_CCB with iopools.

compiled and tweaked by martin@@
@
text
@/*	$OpenBSD: ncr5380var.h,v 1.12 2010/03/25 13:18:03 otto Exp $	*/
/*	$NetBSD: ncr5380var.h,v 1.6 1996/05/10 18:04:06 gwr Exp $	*/

/*
 * Copyright (c) 1995 David Jones, Gordon W. Ross
 * Copyright (c) 1994 Jarle Greipsland
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by
 *      David Jones and Gordon Ross
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file defines the interface between the machine-dependent
 * module and the machine-independent ncr5380sbc.c module.
 */

#define SCI_CLR_INTR(sc)	(*(sc)->sci_iack)
#define	SCI_BUSY(sc)		(*sc->sci_bus_csr & SCI_BUS_BSY)

/* These are NOT arbitrary, but map to bits in sci_tcmd */
#define PHASE_DATA_OUT	0x0
#define PHASE_DATA_IN	0x1
#define PHASE_COMMAND	0x2
#define PHASE_STATUS	0x3
#define PHASE_UNSPEC1	0x4
#define PHASE_UNSPEC2	0x5
#define PHASE_MSG_OUT	0x6
#define PHASE_MSG_IN	0x7

/*
 * This illegal phase is used to prevent the 5380 from having
 * a phase-match condition when we don't want one, such as
 * when setting up the DMA engine or whatever...
 */
#define PHASE_INVALID	PHASE_UNSPEC1


/* Per-request state.  This is required in order to support reselection. */
struct sci_req {
	struct		scsi_xfer *sr_xs;	/* Pointer to xfer struct, NULL=unused */
	int		sr_target, sr_lun;	/* For fast access */
	void		*sr_dma_hand;		/* Current DMA hnadle */
	u_char		*sr_dataptr;		/* Saved data pointer */
	int		sr_datalen;
	int		sr_flags;		/* Internal error code */
#define	SR_IMMED			1	/* Immediate command */
#define	SR_SENSE			2	/* We are getting sense */
#define	SR_OVERDUE			4	/* Timeout while not current */
#define	SR_ERROR			8	/* Error occurred */
#define SR_FREE				16	/* We are free */
	int		sr_status;		/* Status code from last cmd */

	struct timeout	sr_timeout;
};
#define	SCI_OPENINGS	16		/* How many commands we can enqueue. */


struct ncr5380_softc {
	struct device	sc_dev;
	struct		scsi_link sc_link;

	/* Pointers to 5380 registers.  See ncr5380reg.h */
	volatile u_char *sci_r0;
	volatile u_char *sci_r1;
	volatile u_char *sci_r2;
	volatile u_char *sci_r3;
	volatile u_char *sci_r4;
	volatile u_char *sci_r5;
	volatile u_char *sci_r6;
	volatile u_char *sci_r7;

	/* Functions set from MD code */
	int		(*sc_pio_out)(struct ncr5380_softc *,
					   int, int, u_char *);
	int		(*sc_pio_in)(struct ncr5380_softc *,
					  int, int, u_char *);
	void		(*sc_dma_alloc)(struct ncr5380_softc *);
	void		(*sc_dma_free)(struct ncr5380_softc *);

	void		(*sc_dma_setup)(struct ncr5380_softc *);
	void		(*sc_dma_start)(struct ncr5380_softc *);
	void		(*sc_dma_poll)(struct ncr5380_softc *);
	void		(*sc_dma_stop)(struct ncr5380_softc *);

	void		(*sc_intr_on)(struct ncr5380_softc *);
	void		(*sc_intr_off)(struct ncr5380_softc *);

	int		sc_flags;	/* Misc. flags and capabilities */
#define	NCR5380_PERMIT_RESELECT		1  /* Allow disconnect/reselect */
#define	NCR5380_FORCE_POLLING		2  /* Do not use interrupts. */

	/* Set bits in this to disable disconnect per-target. */
	int	sc_no_disconnect;

	/* Set bits in this to disable parity for some target. */
	int		sc_parity_disable;

	int 	sc_min_dma_len;	/* Smaller than this is done with PIO */

	/* Begin MI shared data */

	int		sc_state;
#define	NCR_IDLE		   0	/* Ready for new work. */
#define NCR_WORKING 	0x01	/* Some command is in progress. */
#define	NCR_ABORTING	0x02	/* Bailing out */
#define NCR_DOINGDMA	0x04	/* The FIFO data path is active! */
#define NCR_DROP_MSGIN	0x10	/* Discard all msgs (parity err detected) */

	/* The request that has the bus now. */
	struct		sci_req *sc_current;

	/* Active data pointer for current SCSI command. */
	u_char		*sc_dataptr;
	int		sc_datalen;

	/* Begin MI private data */

	/* The number of operations in progress on the bus */
	volatile int	sc_ncmds;

	/* Ring buffer of pending/active requests */
	struct		sci_req sc_ring[SCI_OPENINGS];
	int		sc_rr;		/* Round-robin scan pointer */

	struct scsi_iopool sc_iopool;

	/* Active requests, by target/LUN */
	struct		sci_req *sc_matrix[8][8];

	/* Message stuff */
	int	sc_prevphase;

	u_int	sc_msgpriq;	/* Messages we want to send */
	u_int	sc_msgoutq;	/* Messages sent during last MESSAGE OUT */
	u_int	sc_msgout;	/* Message last transmitted */
#define SEND_DEV_RESET		0x01
#define SEND_PARITY_ERROR	0x02
#define SEND_ABORT		0x04
#define SEND_REJECT		0x08
#define SEND_INIT_DET_ERR	0x10
#define SEND_IDENTIFY  		0x20
#define SEND_SDTR		0x40
#define	SEND_WDTR		0x80
#define NCR_MAX_MSG_LEN 8
	u_char  sc_omess[NCR_MAX_MSG_LEN];
	u_char	*sc_omp;		/* Outgoing message pointer */
	u_char	sc_imess[NCR_MAX_MSG_LEN];
	u_char	*sc_imp;		/* Incoming message pointer */
};

void	ncr5380_init(struct ncr5380_softc *);
void	ncr5380_reset_scsibus(struct ncr5380_softc *);
int 	ncr5380_intr(struct ncr5380_softc *);
void 	ncr5380_scsi_cmd(struct scsi_xfer *);
int 	ncr5380_pio_in(struct ncr5380_softc *, int, int, u_char *);
int 	ncr5380_pio_out(struct ncr5380_softc *, int, int, u_char *);

#ifdef	NCR5380_DEBUG
struct ncr5380_softc *ncr5380_debug_sc;
void ncr5380_trace(char *msg, long val);
#define	NCR_TRACE(msg, val) ncr5380_trace(msg, val)
#else	/* NCR5380_DEBUG */
#define	NCR_TRACE(msg, val)	/* nada */
#endif	/* NCR5380_DEBUG */
@


1.12
log
@fix fallout of previous; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.11 2006/12/13 21:12:58 miod Exp $	*/
d74 1
d148 2
@


1.11
log
@Remove the dma_eop callback in the ncr5380 driver md attachment, it was always
doing nothing and the mi code does not use it anymore anyway. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.10 2003/10/21 18:58:49 jmc Exp $	*/
d175 1
a175 1
int 	ncr5380_scsi_cmd(struct scsi_xfer *);
@


1.10
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.9 2003/02/24 00:41:51 miod Exp $	*/
a105 1
	void		(*sc_dma_eop)(struct ncr5380_softc *);
@


1.9
log
@Various typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.8 2002/03/14 01:26:55 millert Exp $	*/
d38 1
a38 1
 * module and the machine-indepenedent ncr5380sbc.c module.
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.7 2001/09/20 23:30:29 miod Exp $	*/
d44 1
a44 1
/* These are NOT artibtrary, but map to bits in sci_tcmd */
@


1.7
log
@Better timeout usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.6 2001/08/08 21:15:42 miod Exp $	*/
d96 12
a107 12
	int		(*sc_pio_out) __P((struct ncr5380_softc *,
					   int, int, u_char *));
	int		(*sc_pio_in) __P((struct ncr5380_softc *,
					  int, int, u_char *));
	void		(*sc_dma_alloc) __P((struct ncr5380_softc *));
	void		(*sc_dma_free) __P((struct ncr5380_softc *));

	void		(*sc_dma_setup) __P((struct ncr5380_softc *));
	void		(*sc_dma_start) __P((struct ncr5380_softc *));
	void		(*sc_dma_poll) __P((struct ncr5380_softc *));
	void		(*sc_dma_eop) __P((struct ncr5380_softc *));
	void		(*sc_dma_stop) __P((struct ncr5380_softc *));
d109 2
a110 2
	void		(*sc_intr_on) __P((struct ncr5380_softc *));
	void		(*sc_intr_off) __P((struct ncr5380_softc *));
d173 6
a178 6
void	ncr5380_init __P((struct ncr5380_softc *));
void	ncr5380_reset_scsibus __P((struct ncr5380_softc *));
int 	ncr5380_intr __P((struct ncr5380_softc *));
int 	ncr5380_scsi_cmd __P((struct scsi_xfer *));
int 	ncr5380_pio_in __P((struct ncr5380_softc *, int, int, u_char *));
int 	ncr5380_pio_out __P((struct ncr5380_softc *, int, int, u_char *));
d182 1
a182 1
void ncr5380_trace __P((char *msg, long val));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.7 2001/09/20 23:30:29 miod Exp $	*/
d96 12
a107 12
	int		(*sc_pio_out)(struct ncr5380_softc *,
					   int, int, u_char *);
	int		(*sc_pio_in)(struct ncr5380_softc *,
					  int, int, u_char *);
	void		(*sc_dma_alloc)(struct ncr5380_softc *);
	void		(*sc_dma_free)(struct ncr5380_softc *);

	void		(*sc_dma_setup)(struct ncr5380_softc *);
	void		(*sc_dma_start)(struct ncr5380_softc *);
	void		(*sc_dma_poll)(struct ncr5380_softc *);
	void		(*sc_dma_eop)(struct ncr5380_softc *);
	void		(*sc_dma_stop)(struct ncr5380_softc *);
d109 2
a110 2
	void		(*sc_intr_on)(struct ncr5380_softc *);
	void		(*sc_intr_off)(struct ncr5380_softc *);
d173 6
a178 6
void	ncr5380_init(struct ncr5380_softc *);
void	ncr5380_reset_scsibus(struct ncr5380_softc *);
int 	ncr5380_intr(struct ncr5380_softc *);
int 	ncr5380_scsi_cmd(struct scsi_xfer *);
int 	ncr5380_pio_in(struct ncr5380_softc *, int, int, u_char *);
int 	ncr5380_pio_out(struct ncr5380_softc *, int, int, u_char *);
d182 1
a182 1
void ncr5380_trace(char *msg, long val);
@


1.7.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
/* These are NOT arbitrary, but map to bits in sci_tcmd */
@


1.6
log
@New timeouts. I've been running this since almost a whole  year.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.5 1997/09/11 01:07:13 kstailey Exp $	*/
d75 2
a170 2

	struct timeout sc_timeout;
@


1.5
log
@add sc_no_disconnect
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.3 1996/04/18 23:47:21 niklas Exp $	*/
d170 1
@


1.5.12.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr5380var.h,v 1.5 1997/09/11 01:07:13 kstailey Exp $	*/
a74 2

	struct timeout	sr_timeout;
d169 1
@


1.5.12.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 12
a107 12
	int		(*sc_pio_out)(struct ncr5380_softc *,
					   int, int, u_char *);
	int		(*sc_pio_in)(struct ncr5380_softc *,
					  int, int, u_char *);
	void		(*sc_dma_alloc)(struct ncr5380_softc *);
	void		(*sc_dma_free)(struct ncr5380_softc *);

	void		(*sc_dma_setup)(struct ncr5380_softc *);
	void		(*sc_dma_start)(struct ncr5380_softc *);
	void		(*sc_dma_poll)(struct ncr5380_softc *);
	void		(*sc_dma_eop)(struct ncr5380_softc *);
	void		(*sc_dma_stop)(struct ncr5380_softc *);
d109 2
a110 2
	void		(*sc_intr_on)(struct ncr5380_softc *);
	void		(*sc_intr_off)(struct ncr5380_softc *);
d173 6
a178 6
void	ncr5380_init(struct ncr5380_softc *);
void	ncr5380_reset_scsibus(struct ncr5380_softc *);
int 	ncr5380_intr(struct ncr5380_softc *);
int 	ncr5380_scsi_cmd(struct scsi_xfer *);
int 	ncr5380_pio_in(struct ncr5380_softc *, int, int, u_char *);
int 	ncr5380_pio_out(struct ncr5380_softc *, int, int, u_char *);
d182 1
a182 1
void ncr5380_trace(char *msg, long val);
@


1.5.12.3
log
@Sync the SMP branch with 3.3
@
text
@d44 1
a44 1
/* These are NOT arbitrary, but map to bits in sci_tcmd */
@


1.5.12.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d38 1
a38 1
 * module and the machine-independent ncr5380sbc.c module.
@


1.4
log
@sync 0521
@
text
@d114 3
@


1.3
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ncr5380var.h,v 1.5 1996/03/01 01:42:07 gwr Exp $	*/
d113 3
@


1.2
log
@mi 5380 driver
@
text
@d1 2
a2 1
/*	$NetBSD: ncr5380var.h,v 1.4 1996/01/01 22:24:38 thorpej Exp $	*/
d173 1
a173 1
#ifdef	DEBUG
d177 1
a177 1
#else
d179 1
a179 1
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ncr5380var.h,v 1.3 1995/09/26 19:24:26 thorpej Exp $	*/
d4 2
a5 4
 * Copyright (C) 1994 Adam Glass, Gordon W. Ross
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
d16 3
a18 1
 * 3. All advertising materials mentioning features or use of this software
d20 2
a21 4
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
d23 1
a23 1
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
d26 1
a26 1
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
d31 2
a32 2
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d35 42
a76 47
#define SCI_PHASE_DISC		0	/* sort of ... */
#define SCI_CLR_INTR(regs)	((volatile)(regs->sci_iack))
#define SCI_ACK(ptr,phase)	(ptr)->sci_tcmd = (phase)
#define SCSI_TIMEOUT_VAL	1000000
#define WAIT_FOR_NOT_REQ(ptr) {	\
	int scsi_timeout = SCSI_TIMEOUT_VAL; \
	while ( ((ptr)->sci_bus_csr & SCI_BUS_REQ) && \
		 ((ptr)->sci_bus_csr & SCI_BUS_REQ) && \
		 ((ptr)->sci_bus_csr & SCI_BUS_REQ) && \
		 (--scsi_timeout) ); \
	if (!scsi_timeout) { \
		printf("scsi timeout--WAIT_FOR_NOT_REQ---%s, line %d.\n", \
			__FILE__, __LINE__); \
		goto scsi_timeout_error; \
	} \
	}
#define WAIT_FOR_REQ(ptr) {	\
	int scsi_timeout = SCSI_TIMEOUT_VAL; \
	while ( (((ptr)->sci_bus_csr & SCI_BUS_REQ) == 0) && \
		(((ptr)->sci_bus_csr & SCI_BUS_REQ) == 0) && \
		(((ptr)->sci_bus_csr & SCI_BUS_REQ) == 0) && \
		 (--scsi_timeout) ); \
	if (!scsi_timeout) { \
		printf("scsi timeout--WAIT_FOR_REQ---%s, line %d.\n", \
			__FILE__, __LINE__); \
		goto scsi_timeout_error; \
	} \
	}
#define WAIT_FOR_BSY(ptr) {	\
	int scsi_timeout = SCSI_TIMEOUT_VAL; \
	while ( (((ptr)->sci_bus_csr & SCI_BUS_BSY) == 0) && \
		(((ptr)->sci_bus_csr & SCI_BUS_BSY) == 0) && \
		(((ptr)->sci_bus_csr & SCI_BUS_BSY) == 0) && \
		 (--scsi_timeout) ); \
	if (!scsi_timeout) { \
		printf("scsi timeout--WAIT_FOR_BSY---%s, line %d.\n", \
			__FILE__, __LINE__); \
		goto scsi_timeout_error; \
	} \
	}

#define ARBITRATION_RETRIES 1000

#ifndef DDB
#define Debugger() panic("Should call Debugger here %s:%d", \
			 __FILE__, __LINE__)
#endif /* ! DDB */
d80 1
a80 6
	struct intrhand	sc_ih;	/* interrupt info */
	volatile void	*sc_regs;
	int		sc_adapter_type;
	int		sc_adapter_iv_am; /* int. vec + address modifier */
	struct scsi_link sc_link;
};
d82 80
a161 20
static int	ncr5380_reset_scsibus __P((struct ncr5380_softc *));
static int	ncr5380_poll __P((int, int));
static void	ncr5380_sbc_intr __P((struct ncr5380_softc *));
static int	ncr5380_send_cmd __P((struct scsi_xfer *));
static int	ncr5380_scsi_cmd __P((struct scsi_xfer *));
static int	ncr5380_data_in __P((sci_regmap_t *, int, int, u_char *));
static int	ncr5380_data_out __P((sci_regmap_t *, int, int, u_char *));
static int	ncr5380_select_target __P((volatile sci_regmap_t *, u_char,
					   u_char, int));
static int	ncr5380_command_transfer __P((volatile sci_regmap_t *, int,
					      u_char *, u_char *, u_char *));
static int	ncr5380_data_transfer __P((volatile sci_regmap_t *, int,
					   u_char *, u_char *, u_char *));
static int	ncr5380_dorequest __P((struct ncr5380_softc *, int, int,
				       u_char *, int, char *, int, int *));

static int	ncr5380_generic __P((void *, int, int, struct scsi_generic *,
				     int, void *, int));
static int	ncr5380_group0 __P((void *, int, int, int, int, int,
				    int, caddr_t, int));
d163 1
d165 14
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
