head	1.40;
access;
symbols
	OPENBSD_6_0:1.40.0.24
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.18
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.20
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.12
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.40.0.16
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.14
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.40.0.10
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.8
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.4
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.6
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.39.0.14
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.12
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.8
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.10
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.6
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.38.0.8
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.38.0.6
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.4
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.35.0.4
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.34.0.4
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.30
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	SMP:1.5.0.2;
locks; strict;
comment	@ * @;


1.40
date	2011.06.21.16.52.45;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2008.02.03.15.04.37;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2005.10.18.13.37.48;	author fgsch;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.17.10.55.07;	author fgsch;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.15.00.20.49;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.15.19.44.15;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.02.21.59.29;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.25.17.38.55;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.01.10.22.10.19;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.27.16.20.48;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.10.20.27.46;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.12.03.48.31;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.10.08.21.35;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.13.03.49.51;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.10.19.29.15;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.27.15.11.44;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.26.21.34.01;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.23.10.33.21;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.22.22.10.38;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.21.03.02.00;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.01.04.31.07;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.06.23.48.38;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.06.20.31.56;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.30.21.57.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.28.20.49.39;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.28.18.21.06;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.28.17.41.02;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.26.20.42.51;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.21.23.00.15;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.19.01.24.58;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.21.15.48.20;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.20.17.48.25;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.25.19.40.06;	author mickey;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.10.25.16.39.25;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.25.18.04.23;	author drahn;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.06.07.18.51.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.07.05.07.27;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.06.18.53.50;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.15.02.40.36;	author millert;	state Exp;
branches;
next	;

1.5.2.1
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2004.06.05.23.12.42;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.40
log
@remove some unnecessary casts.  ok blambert deraadt kettenis matthew
@
text
@/*	$OpenBSD: if_wireg.h,v 1.39 2008/02/03 15:04:37 kettenis Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	From: if_wireg.h,v 1.8.2.2 2001/08/25 00:48:25 nsayer Exp $
 */

#define WI_DELAY	5
#define WI_TIMEOUT	(500000/WI_DELAY)	/* 500ms */

#define WI_PORT0	0
#define WI_PORT1	1
#define WI_PORT2	2
#define WI_PORT3	3
#define WI_PORT4	4
#define WI_PORT5	5

/* Default port: 0 (only 0 exists on stations) */
#define WI_DEFAULT_PORT	(WI_PORT0 << 8)

/* Default TX rate: 2Mbps, auto fallback */
#define WI_DEFAULT_TX_RATE	3

/* Default network name (wildcard) */
#define WI_DEFAULT_NETNAME	""

#define WI_DEFAULT_AP_DENSITY	1

#define WI_DEFAULT_RTS_THRESH	2347

#define WI_DEFAULT_DATALEN	2304

#define WI_DEFAULT_CREATE_IBSS	0

#define WI_DEFAULT_PM_ENABLED	0

#define WI_DEFAULT_MAX_SLEEP	100

#define WI_DEFAULT_NODENAME	"WaveLAN/IEEE node"

#define WI_DEFAULT_IBSS		"IBSS"

#define WI_DEFAULT_CHAN		3

#define	WI_DEFAULT_ROAMING	1

#define	WI_DEFAULT_AUTHTYPE	1

#define	WI_DEFAULT_DIVERSITY	0

/*
 * register space access macros
 */

#define CSR_WRITE_4(sc, reg, val)				\
	bus_space_write_4(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg), (val))
#define CSR_WRITE_2(sc, reg, val)				\
	bus_space_write_2(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg), (val))
#define CSR_WRITE_1(sc, reg, val)				\
	bus_space_write_1(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg), val)

#define CSR_READ_4(sc, reg)					\
	bus_space_read_4(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg))
#define CSR_READ_2(sc, reg)					\
	bus_space_read_2(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg))
#define CSR_READ_1(sc, reg)					\
	bus_space_read_1(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg))

#define CSR_READ_RAW_2(sc, ba, dst, sz)				\
	bus_space_read_raw_multi_2((sc)->wi_btag,		\
	    (sc)->wi_bhandle,					\
	    (sc->sc_pci? ba * 2: ba), (dst), (sz))
#define CSR_WRITE_RAW_2(sc, ba, dst, sz)			\
	bus_space_write_raw_multi_2((sc)->wi_btag,		\
	    (sc)->wi_bhandle,					\
	    (sc->sc_pci? ba * 2: ba), (dst), (sz))

/*
 * The WaveLAN/IEEE cards contain an 802.11 MAC controller which Lucent
 * calls 'Hermes.' In typical fashion, getting documentation about this
 * controller is about as easy as squeezing blood from a stone. Here
 * is more or less what I know:
 *
 * - The Hermes controller is firmware driven, and the host interacts
 *   with the Hermes via a firmware interface, which can change.
 *
 * - The Hermes is described in a document called: "Hermes Firmware
 *   WaveLAN/IEEE Station Functions," document #010245, which of course
 *   Lucent will not release without an NDA.
 *
 * - Lucent has created a library called HCF (Hardware Control Functions)
 *   though which it wants developers to interact with the card. The HCF
 *   is needlessly complex, ill conceived and badly documented. Actually,
 *   the comments in the HCP code itself aren't bad, but the publicly
 *   available manual that comes with it is awful, probably due largely to
 *   the fact that it has been emasculated in order to hide information
 *   that Lucent wants to keep proprietary. The purpose of the HCF seems
 *   to be to insulate the driver programmer from the Hermes itself so that
 *   Lucent has an excuse not to release programming in for it.
 *
 * - Lucent only makes available documentation and code for 'HCF Light'
 *   which is a stripped down version of HCF with certain features not
 *   implemented, most notably support for 802.11 frames.
 *
 * - The HCF code which I have seen blows goats. Whoever decided to
 *   use a 132 column format should be shot.
 *
 * Rather than actually use the Lucent HCF library, I have stripped all
 * the useful information from it and used it to create a driver in the
 * usual BSD form. Note: I don't want to hear anybody whining about the
 * fact that the Lucent code is GPLed and mine isn't. I did not actually
 * put any of Lucent's code in this driver: I only used it as a reference
 * to obtain information about the underlying hardware. The Hermes
 * programming interface is not GPLed, so bite me.
 */

/*
 * Size of Hermes & Prism2 I/O space.
 */
#define WI_IOSIZ		0x40

/*
 * Hermes register definitions and what little I know about them.
 */

/* Hermes command/status registers. */
#define WI_COMMAND		0x00
#define WI_PARAM0		0x02
#define WI_PARAM1		0x04
#define WI_PARAM2		0x06
#define WI_STATUS		0x08
#define WI_RESP0		0x0A
#define WI_RESP1		0x0C
#define WI_RESP2		0x0E

/* Command register values. */
#define WI_CMD_BUSY		0x8000 /* busy bit */
#define WI_CMD_INI		0x0000 /* initialize */
#define WI_CMD_ENABLE		0x0001 /* enable */
#define WI_CMD_DISABLE		0x0002 /* disable */
#define WI_CMD_DIAG		0x0003
#define WI_CMD_ALLOC_MEM	0x000A /* allocate NIC memory */
#define WI_CMD_TX		0x000B /* transmit */
#define WI_CMD_NOTIFY		0x0010
#define WI_CMD_INQUIRE		0x0011
#define WI_CMD_ACCESS		0x0021
#define WI_CMD_PROGRAM		0x0022
#define WI_CMD_READ_MIF		0x0030 /* prism2 */
#define WI_CMD_WRITE_MIF	0x0031 /* prism2 */

#define WI_CMD_CODE_MASK	0x003F

/*
 * Reclaim qualifier bit, applicable to the
 * TX and INQUIRE commands.
 */
#define WI_RECLAIM		0x0100 /* reclaim NIC memory */

/*
 * ACCESS command qualifier bits.
 */
#define WI_ACCESS_READ		0x0000
#define WI_ACCESS_WRITE		0x0100

/*
 * PROGRAM command qualifier bits.
 */
#define WI_PROGRAM_DISABLE	0x0000
#define WI_PROGRAM_ENABLE_RAM	0x0100
#define WI_PROGRAM_ENABLE_NVRAM	0x0200
#define WI_PROGRAM_NVRAM	0x0300

/* Status register values */
#define WI_STAT_CMD_CODE	0x003F
#define WI_STAT_DIAG_ERR	0x0100
#define WI_STAT_INQ_ERR		0x0500
#define WI_STAT_CMD_RESULT	0x7F00

/* memory handle management registers */
#define WI_INFO_FID		0x10
#define WI_RX_FID		0x20
#define WI_ALLOC_FID		0x22
#define WI_TX_CMP_FID		0x24

/*
 * Buffer Access Path (BAP) registers.
 * These are I/O channels. I believe you can use each one for
 * any desired purpose independently of the other. In general
 * though, we use BAP1 for reading and writing LTV records and
 * reading received data frames, and BAP0 for writing transmit
 * frames. This is a convention though, not a rule.
 */
#define WI_SEL0			0x18
#define WI_SEL1			0x1A
#define WI_OFF0			0x1C
#define WI_OFF1			0x1E
#define WI_DATA0		0x36
#define WI_DATA1		0x38
#define WI_BAP0			WI_DATA0
#define WI_BAP1			WI_DATA1

#define WI_OFF_BUSY		0x8000
#define WI_OFF_ERR		0x4000
#define WI_OFF_DATAOFF		0x0FFF

/* Event registers */
#define WI_EVENT_STAT		0x30	/* Event status */
#define WI_INT_EN		0x32	/* Interrupt enable/disable */
#define WI_EVENT_ACK		0x34	/* Ack event */

/* Events */
#define WI_EV_TICK		0x8000	/* aux timer tick */
#define WI_EV_RES		0x4000	/* controller h/w error (time out) */
#define WI_EV_INFO_DROP		0x2000	/* no RAM to build unsolicited frame */
#define WI_EV_NO_CARD		0x0800	/* card removed (hunh?) */
#define WI_EV_DUIF_RX		0x0400	/* wavelan management packet received */
#define WI_EV_INFO		0x0080	/* async info frame */
#define WI_EV_CMD		0x0010	/* command completed */
#define WI_EV_ALLOC		0x0008	/* async alloc/reclaim completed */
#define WI_EV_TX_EXC		0x0004	/* async xmit completed with failure */
#define WI_EV_TX		0x0002	/* async xmit completed successfully */
#define WI_EV_RX		0x0001	/* async rx completed */

#define WI_INTRS	\
	(WI_EV_RX|WI_EV_TX|WI_EV_TX_EXC|WI_EV_ALLOC|WI_EV_INFO|WI_EV_INFO_DROP)

/* Host software registers */
#define WI_SW0			0x28
#define WI_SW1			0x2A
#define WI_SW2			0x2C
#define WI_SW3			0x2E

#define WI_CNTL			0x14

#define WI_CNTL_AUX_ENA		0xC000
#define WI_CNTL_AUX_ENA_STAT	0xC000
#define WI_CNTL_AUX_DIS_STAT	0x0000
#define WI_CNTL_AUX_ENA_CNTL	0x8000
#define WI_CNTL_AUX_DIS_CNTL	0x4000

#define WI_AUX_PAGE		0x3A
#define WI_AUX_OFFSET		0x3C
#define WI_AUX_DATA		0x3E

#define WI_COR_OFFSET		0x40	/* COR attribute offset of card */
#define WI_COR_IOMODE		0x41	/* Enable i/o mode with level irqs */

#define WI_PLX_LOCALRES		0x14	/* PLX chip's local registers */
#define WI_PLX_MEMRES		0x18	/* Prism attribute memory (PLX) */
#define WI_PLX_IORES		0x1C	/* Prism I/O space (PLX) */
#define WI_PLX_INTCSR		0x4C	/* PLX Interrupt CSR */
#define WI_PLX_INTEN		0x40	/* PCI Interrupt Enable bit */
#define WI_PLX_LINT1STAT	0x04	/* Local interrupt 1 status bit */
#define WI_PLX_COR_OFFSET	0x3E0	/* COR attribute offset of card */

#define	WI_ACEX_CMDRES		0x10	/* BAR0 (I/O) for ACEX-based bridge */
#define	WI_ACEX_LOCALRES	0x14	/* BAR1 (I/O) for ACEX-based bridge */
#define	WI_ACEX_IORES		0x18	/* BAR2 (I/O) for ACEX-based bridge */
#define	WI_ACEX_COR_OFFSET	0xe0	/* COR attribute offset of card */

#define WI_TMD_LOCALRES		0x14	/* TMD chip's local registers */
#define WI_TMD_IORES		0x18	/* Prism I/O space (TMD) */

#define	WI_DRVR_MAGIC		0x4A2D	/* Magic number for card detection */

/*
 * PCI Host Interface Registers (HFA3842 Specific)
 * The value of all Register's Offset, such as WI_INFO_FID and WI_PARAM0,
 * has doubled.
 * About WI_PCI_COR: In this Register, only soft-reset bit implement; Bit(7).
 */
#define WI_PCI_CBMA		0x10
#define WI_PCI_COR_OFFSET	0x4C
#define WI_PCI_HCR		0x5C
#define WI_PCI_MASTER0_ADDRH	0x80
#define WI_PCI_MASTER0_ADDRL	0x84
#define WI_PCI_MASTER0_LEN	0x88
#define WI_PCI_MASTER0_CON	0x8C

#define WI_PCI_STATUS		0x98

#define WI_PCI_MASTER1_ADDRH	0xA0
#define WI_PCI_MASTER1_ADDRL	0xA4
#define WI_PCI_MASTER1_LEN	0xA8
#define WI_PCI_MASTER1_CON	0xAC

#define WI_COR_SOFT_RESET	(1 << 7)
#define WI_COR_CLEAR		0x00

/*
 * One form of communication with the Hermes is with what Lucent calls
 * LTV records, where LTV stands for Length, Type and Value. The length
 * and type are 16 bits and are in native byte order. The value is in
 * multiples of 16 bits and is in little endian byte order.
 */
struct wi_ltv_gen {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_val;
};

struct wi_ltv_str {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_str[17];
};

#define WI_SETVAL(recno, val)			\
	do {					\
		struct wi_ltv_gen	g;	\
						\
		g.wi_len = 2;			\
		g.wi_type = recno;		\
		g.wi_val = htole16(val);	\
		wi_write_record(sc, &g);	\
	} while (0)

#define WI_SETSTR(recno, str)					\
	do {							\
		struct wi_ltv_str	s;			\
		int			l;			\
								\
		l = (str.i_len + 1) & ~0x1;			\
		bzero(&s, sizeof(s));				\
		s.wi_len = (l / 2) + 2;				\
		s.wi_type = recno;				\
		s.wi_str[0] = htole16(str.i_len);		\
		bcopy(str.i_nwid, &s.wi_str[1], str.i_len);	\
		wi_write_record(sc, (struct wi_ltv_gen *)&s);	\
	} while (0)

/*
 * Download buffer location and length (0xFD01).
 */
#define WI_RID_DNLD_BUF		0xFD01
struct wi_ltv_dnld_buf {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_buf_pg; /* page addr of intermediate dl buf*/
	u_int16_t		wi_buf_off; /* offset of idb */
	u_int16_t		wi_buf_len; /* len of idb */
};

/*
 * Mem sizes (0xFD02).
 */
#define WI_RID_MEMSZ		0xFD02
struct wi_ltv_memsz {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_mem_ram;
	u_int16_t		wi_mem_nvram;
};

/*
 * NIC Identification (0xFD0B == WI_RID_CARD_ID)
 */
struct wi_ltv_ver {
	u_int16_t	wi_len;
	u_int16_t	wi_type;
	u_int16_t	wi_ver[4];
};

/*
 * List of intended regulatory domains (WI_RID_DOMAINS = 0xFD11).
 */
struct wi_ltv_domains {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_domains[6];
};

/*
 * CIS struct (0xFD13 == WI_RID_CIS).
 */
struct wi_ltv_cis {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_cis[240];
};

/*
 * Communications quality (0xFD43 == WI_RID_COMMQUAL).
 */
struct wi_ltv_commqual {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_coms_qual;
	u_int16_t		wi_sig_lvl;
	u_int16_t		wi_noise_lvl;
};

/*
 * Actual system scale thresholds (0xFD46 == WI_RID_SCALETHRESH).
 */
struct wi_ltv_scalethresh {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_energy_detect;
	u_int16_t		wi_carrier_detect;
	u_int16_t		wi_defer;
	u_int16_t		wi_cell_search;
	u_int16_t		wi_out_of_range;
	u_int16_t		wi_delta_snr;
};

/*
 * PCF info struct (0xFD87 == WI_RID_PCF).
 */
struct wi_ltv_pcf {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_energy_detect;
	u_int16_t		wi_carrier_detect;
	u_int16_t		wi_defer;
	u_int16_t		wi_cell_search;
	u_int16_t		wi_range;
};

/*
 * Connection control characteristics (0xFC00 == WI_RID_PORTTYPE).
 * 1 == Basic Service Set (BSS)
 * 2 == Wireless Distribution System (WDS)
 * 3 == Pseudo IBSS (aka ad-hoc demo)
 * 4 == IBSS
 */
#define WI_PORTTYPE_BSS		0x1
#define WI_PORTTYPE_WDS		0x2
#define WI_PORTTYPE_ADHOC	0x3
#define WI_PORTTYPE_IBSS	0x4
#define WI_PORTTYPE_HOSTAP	0x6

/*
 * Mac addresses.
 */
struct wi_ltv_macaddr {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_mac_addr[3];
};

/*
 * Station set identification (SSID).
 */
struct wi_ltv_ssid {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_id[17];
};

/*
 * Set our station name (0xFC0E == WI_RID_NODENAME).
 */
struct wi_ltv_nodename {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int16_t		wi_nodename[17];
};

/*
 * Multicast addresses to be put in filter. We're allowed up
 * to 16 addresses in the filter (0xFC80 == WI_RID_MCAST).
 */
struct wi_ltv_mcast {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	struct ether_addr	wi_mcast[16];
};


/*
 * Get supported data rates (0xFDC6 == WI_RID_DATA_RATES).
 */
struct wi_ltv_rates {
	u_int16_t		wi_len;
	u_int16_t		wi_type;
	u_int8_t		wi_rates[10];
};

/*
 * Supported rates.
 */
#define WI_SUPPRATES_1M		0x0001
#define WI_SUPPRATES_2M		0x0002
#define WI_SUPPRATES_5M		0x0004
#define WI_SUPPRATES_11M	0x0008
#define	WI_RATES_BITS	"\20\0011M\0022M\0035.5M\00411M"

/*
 * Information frame types.
 */
#define WI_INFO_NOTIFY		0xF000	/* Handover address */
#define WI_INFO_COUNTERS	0xF100	/* Statistics counters */
#define WI_INFO_SCAN_RESULTS	0xF101	/* Scan results */
#define WI_INFO_LINK_STAT	0xF200	/* Link status */
#define WI_INFO_ASSOC_STAT	0xF201	/* Association status */

/*
 * Hermes transmit/receive frame structure
 */
struct wi_frame {
	u_int16_t		wi_status;	/* 0x00 */
	u_int16_t		wi_rsvd0;	/* 0x02 */
	u_int16_t		wi_rsvd1;	/* 0x04 */
	u_int16_t		wi_q_info;	/* 0x06 */
	u_int16_t		wi_rsvd2;	/* 0x08 */
	u_int8_t		wi_tx_rtry;	/* 0x0A */
	u_int8_t		wi_tx_rate;	/* 0x0A */
	u_int16_t		wi_tx_ctl;	/* 0x0C */
	u_int16_t		wi_frame_ctl;	/* 0x0E */
	u_int16_t		wi_id;		/* 0x10 */
	u_int8_t		wi_addr1[6];	/* 0x12 */
	u_int8_t		wi_addr2[6];	/* 0x18 */
	u_int8_t		wi_addr3[6];	/* 0x1E */
	u_int16_t		wi_seq_ctl;	/* 0x24 */
	u_int8_t		wi_addr4[6];	/* 0x26 */
	u_int16_t		wi_dat_len;	/* 0x2C */
	u_int8_t		wi_dst_addr[6];	/* 0x2E */
	u_int8_t		wi_src_addr[6];	/* 0x34 */
	u_int16_t		wi_len;		/* 0x3A */
	u_int16_t		wi_dat[3];	/* 0x3C */ /* SNAP header */
	u_int16_t		wi_type;	/* 0x42 */
};

#define WI_802_3_OFFSET		0x2E
#define WI_802_11_OFFSET	0x44
#define WI_802_11_OFFSET_RAW	0x3C
#define WI_802_11_OFFSET_HDR	0x0E

#define WI_STAT_BADCRC		0x0001
#define WI_STAT_UNDECRYPTABLE	0x0002
#define WI_STAT_ERRSTAT		0x0003
#define WI_STAT_MAC_PORT	0x0700
#define WI_STAT_1042		0x2000	/* RFC1042 encoded */
#define WI_STAT_TUNNEL		0x4000	/* Bridge-tunnel encoded */
#define WI_STAT_WMP_MSG		0x6000	/* WaveLAN-II management protocol */
#define WI_STAT_MGMT		0x8000	/* 802.11b management frames */
#define WI_RXSTAT_MSG_TYPE	0xE000

#define WI_ENC_TX_802_3		0x00
#define WI_ENC_TX_802_11	0x11
#define	WI_ENC_TX_MGMT		0x08
#define WI_ENC_TX_E_II		0x0E

#define WI_ENC_TX_1042		0x00
#define WI_ENC_TX_TUNNEL	0xF8

#define WI_TXCNTL_MACPORT	0x00FF
#define WI_TXCNTL_STRUCTTYPE	0xFF00
#define WI_TXCNTL_TX_EX		0x0004
#define WI_TXCNTL_TX_OK		0x0002
#define WI_TXCNTL_NOCRYPT	0x0080


/*
 * SNAP (sub-network access protocol) constants for transmission
 * of IP datagrams over IEEE 802 networks, taken from RFC1042.
 * We need these for the LLC/SNAP header fields in the TX/RX frame
 * structure.
 */
#define WI_SNAP_K1		0xaa	/* assigned global SAP for SNAP */
#define WI_SNAP_K2		0x00
#define WI_SNAP_CONTROL		0x03	/* unnumbered information format */
#define WI_SNAP_WORD0		(WI_SNAP_K1 | (WI_SNAP_K1 << 8))
#define WI_SNAP_WORD1		(WI_SNAP_K2 | (WI_SNAP_CONTROL << 8))
#define WI_SNAPHDR_LEN		0x6
#define WI_FCS_LEN		0x4

#define	WI_ETHERTYPE_LEN	0x2

/*
 * HFA3861/3863 (BBP) Control Registers
 */
#define WI_HFA384X_CR_A_D_TEST_MODES2	0x1a
#define WI_HFA384X_CR_MANUAL_TX_POWER	0x3e
@


1.39
log
@Remove sparc64-specific hack to byteswap pcmcia bus_space access.  This is no
longer necessary now that stp(4) maps the pcmcia windows little-endian.
Makes wi(4) behind cbb(4) work on sparc64.

tested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.38 2005/10/18 13:37:48 fgsch Exp $	*/
d359 1
a359 1
		bzero((char *)&s, sizeof(s));			\
@


1.38
log
@remove wrong definition since result really belongs to stat (which is
already there).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.37 2005/10/17 10:55:07 fgsch Exp $	*/
a83 6
#if defined(__sparc64__)
#define WI_BIG_ENDIAN_POSSIBLE	(sc->wi_flags & WI_FLAGS_BUS_PCMCIA)
#else
#define WI_BIG_ENDIAN_POSSIBLE 	0
#endif

d86 1
a86 2
	    (sc->sc_pci ? reg * 2: reg),			\
	     WI_BIG_ENDIAN_POSSIBLE ? htole32(val) : (val))
d89 1
a89 2
	    (sc->sc_pci ? reg * 2: reg),			\
	    WI_BIG_ENDIAN_POSSIBLE ? htole16(val) : (val))
a94 3
	(WI_BIG_ENDIAN_POSSIBLE ?				\
	letoh32(bus_space_read_4(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci ? reg * 2: reg))) :			\
d96 1
a96 1
	    (sc->sc_pci ? reg * 2: reg)))
a97 3
	(WI_BIG_ENDIAN_POSSIBLE ?				\
	letoh16(bus_space_read_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci ? reg * 2: reg))) :			\
d99 1
a99 1
	    (sc->sc_pci ? reg * 2: reg)))
@


1.37
log
@define a mask to extract the result from status.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.36 2005/10/15 00:20:49 fgsch Exp $	*/
a200 1
#define WI_CMD_RESULT_MASK	0x7F00
@


1.36
log
@correctly parse the supported data rates. needed by wi@@usb.
tested by jsg@@ and joris@@, deraadt@@ go ahead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.35 2005/02/15 19:44:15 reyk Exp $	*/
d201 1
@


1.35
log
@add the manual tx power option. this is supported by some prism2/2.5/3
cards in hostap mode but it depends on the firmware version. support
for other wireless chipsets will be added in the future using the
net80211-framework.

ok robert@@ bob@@ danh@@, tested by some others
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.34 2004/03/02 21:59:29 millert Exp $	*/
d517 10
@


1.34
log
@Fix timing issues with newer Prism firmware and retry card reset up
to three times (only once for Symbol though).  This fixes intermittent
problems on Prism-based cards with newer firmware.  Tested with a
wide variety of cards and firmware revisions.  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.33 2003/10/21 18:58:49 jmc Exp $	*/
d197 2
d609 6
@


1.33
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.32 2003/06/25 17:38:55 miod Exp $	*/
d37 2
a38 1
#define WI_TIMEOUT	50000	/* 10x XXX just a guess at a good value.  */
@


1.32
log
@Extend the sparc bus_space_tag_t to store access endianness in it, and
adapt all bus_space functions to do proper endianness conversion whenever
necessary, except for the raw ones.

This allows us to remove the forced endianness conversions in if_wi.

with help from and ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.31 2003/01/10 22:10:19 millert Exp $	*/
d142 1
a142 1
 *   the comments in the HCP code itself aren't bad, but the publically
d267 1
a267 1
#define WI_EV_TX		0x0002	/* async xmit completed succesfully */
d469 1
a469 1
 * 2 == Wireless Distribudion System (WDS)
@


1.31
log
@Add support for Symbol LA4123 and Nortel E-mobility 211818-A PCI
cards.  These use an ACEX EP1K30 programmable logic device (PLD)
as the PCMCIA->PCI bridge.  There's no documentation available on
how Symbol has this configured; the magic bits are based on
modifications to the Linux orinoco driver by Tobias Hoffmann.
He, in turn, figured out the magic from the Windows driver.
This does mean we have undocuemnted hex constants; sigh.

I also moved commented bridge chip info to right before the appropriate
bridge attachment.  The massive comment at the top of the file was
becoming illegible.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.30 2002/10/27 16:20:48 millert Exp $	*/
a84 2
#elif defined(__sparc__)
#define WI_BIG_ENDIAN_POSSIBLE 	1
@


1.30
log
@Add an option to use software WEP now that we have a software decrypt
function.  Can be useful for cards that only support 40-bit WEP or
where the card firmware lacks weak IVs avoidance.  Prism/Symbol only.
In the future this will be expanded to support proposed WEP replacements.
Based on code from Jamison Adcock.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.29 2002/10/10 20:27:46 millert Exp $	*/
d304 4
a307 1
#define	WI_DRVR_MAGIC		0x4A2D	/* Magic number for card detection */
d311 2
@


1.29
log
@Make wi_get_id() table driven, similar to NetBSD and FreeBSD but
make the table itself a #define so we can reuse it in wicontrol.
Also add a bunch of chip IDs from NetBSD/FreeBSD.
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.28 2002/09/12 03:48:31 millert Exp $	*/
d601 2
@


1.28
log
@o break up wi_pci_attach() into device-specific parts for better readability
o kludge around a problem with Netgear MA301 hanging when booted w/o a card.
o better card detection w/ PLX adapters
o correct the info in some comments
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.27 2002/09/10 08:21:35 fgsch Exp $	*/
a404 13
#define	WI_NIC_LUCENT		0x0001
#define	WI_NIC_SONY		0x0002
#define	WI_NIC_LUCENT_EM	0x0005
#define	WI_NIC_EVB2		0x8000
#define	WI_NIC_HWB3763		0x8001
#define	WI_NIC_HWB3163		0x8002
#define	WI_NIC_HWB3163B		0x8003
#define	WI_NIC_EVB3		0x8004
#define	WI_NIC_HWB1153		0x8007
#define	WI_NIC_P2_SST		0x8008  /* Prism2 with SST flush */
#define	WI_NIC_PRISM2_5		0x800C
#define	WI_NIC_3874A		0x8013	/* Prism2.5 Mini-PCI */
#define	WI_NIC_37300P		0x801a
a600 1

@


1.27
log
@no need for pragma here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.25 2002/07/10 19:29:15 millert Exp $	*/
d294 1
d300 2
a301 2
#define WI_PLX_INTEN		0x40	/* Interrupt Enable bit */
#define WI_PLX_COR_VALUE	0x41	/* Enable with irq in level trigger */
d304 2
a307 2
#define WI_TMD_COR_OFFSET	0x00	/* COR attribute offset of Prism2 */
#define WI_TMD_COR_VALUE	0x45
@


1.26
log
@change WI_PORTTYPE_AP -> WI_PORTTYPE_HOSTAP to match FreeBSD and NetBSD.
The reason for this is that it is possible in the future to have
wi(4) be a real AP using the AP tertiary firmware.
mickey@@ OK
@
text
@a36 2
#pragma pack(1)

a613 1
#pragma pack()
@


1.25
log
@Use the correct COR offset for pcmcia card; noted by Warner Losh
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.24 2002/06/27 15:11:44 fgsch Exp $	*/
d488 1
a488 1
#define WI_PORTTYPE_AP		0x6
@


1.24
log
@missing parenthesis in this macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.23 2002/06/26 21:34:01 fgsch Exp $	*/
d295 1
a295 1
#define WI_COR_OFFSET		0x3E0	/* COR attribute offset of card */
d303 1
@


1.23
log
@stp at sparc will map this card always as big-endian.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.22 2002/06/23 10:33:21 deraadt Exp $	*/
d95 1
a95 1
	    sc->sc_pci ? reg * 2: reg),				\
@


1.22
log
@cleanup WI_IS_BE macros
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.21 2002/06/22 22:10:38 fgsch Exp $	*/
d85 1
a85 1
#if defined(__sparc__)
d87 2
@


1.21
log
@Add new flag, WI_FLAGS_BUS_PCMCIA and mark pcmcia attachment as such.
Replace ugly kludge with a macro that tests on sparc if it's pcmcia
and tries to deal with it correctly (card mapped as be).
This makes possible to have wi at pcmcia and pci on sparc64; from theo
and myself.  Tested with the PLX adapter and the SBus pcmcia bridge.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.20 2002/06/21 03:02:00 fgsch Exp $	*/
d86 1
a86 1
#define WI_IS_BE	(sc->wi_flags & WI_FLAGS_BUS_PCMCIA)
d88 1
a88 1
#define WI_IS_BE 	0
d91 10
a100 8
#define CSR_WRITE_4(sc, reg, val)	\
	bus_space_write_4(sc->wi_btag, sc->wi_bhandle,	\
	    sc->sc_pci ? reg * 2: reg), WI_IS_BE ? htole32(val) : (val))
#define CSR_WRITE_2(sc, reg, val)	\
	bus_space_write_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci ? reg * 2: reg), WI_IS_BE ? htole16(val) : (val))
#define CSR_WRITE_1(sc, reg, val)	\
	bus_space_write_1(sc->wi_btag, sc->wi_bhandle,	\
d103 2
a104 2
#define CSR_READ_4(sc, reg)		\
	(WI_IS_BE ?			\
d109 2
a110 2
#define CSR_READ_2(sc, reg)		\
	(WI_IS_BE ?			\
d115 2
a116 2
#define CSR_READ_1(sc, reg)		\
	bus_space_read_1(sc->wi_btag, sc->wi_bhandle,	\
d119 3
a121 2
#define CSR_READ_RAW_2(sc, ba, dst, sz) \
	bus_space_read_raw_multi_2((sc)->wi_btag, (sc)->wi_bhandle, \
d123 3
a125 2
#define CSR_WRITE_RAW_2(sc, ba, dst, sz) \
	bus_space_write_raw_multi_2((sc)->wi_btag, (sc)->wi_bhandle, \
@


1.20
log
@ugly kludge to deal correctly with endianess in sparc and sparc64.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.19 2002/05/01 04:31:07 millert Exp $	*/
d86 4
d93 1
a93 1
	    (sc->sc_pci? reg * 2: reg), htole32(val))
d96 1
a96 1
	    (sc->sc_pci? reg * 2: reg), htole16(val))
d99 1
a99 1
	    (sc->sc_pci? reg * 2: reg), val)
d102 1
d104 3
a106 1
	    (sc->sc_pci? reg * 2: reg)))
d108 1
d110 3
a112 23
	    (sc->sc_pci? reg * 2: reg)))
#define CSR_READ_1(sc, reg)		\
	bus_space_read_1(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg))

#else

#define CSR_WRITE_4(sc, reg, val)	\
	bus_space_write_4(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg), val)
#define CSR_WRITE_2(sc, reg, val)	\
	bus_space_write_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg), val)
#define CSR_WRITE_1(sc, reg, val)	\
	bus_space_write_1(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg), val)

#define CSR_READ_4(sc, reg)		\
	bus_space_read_4(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg))
#define CSR_READ_2(sc, reg)		\
	bus_space_read_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg))
d115 1
a115 3
	    (sc->sc_pci? reg * 2: reg))

#endif
@


1.19
log
@Change WI_PORTTYPE_IBSS to 4.  This change got lost in the big ibss
simplication a while back.  Luckily, it is basically cosmetic...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.18 2002/04/06 23:48:38 millert Exp $	*/
d84 3
d89 1
a89 1
	    (sc->sc_pci? reg * 2: reg) , val)
d92 1
a92 1
	    (sc->sc_pci? reg * 2: reg) , val)
d95 23
a117 1
	    (sc->sc_pci? reg * 2: reg) , val)
d128 2
@


1.18
log
@Add support for setting antenna diversity on Symbol cards.
Also add some more Symbol-specific RID values I noticed in the
Linux orinoco driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.17 2002/04/06 20:31:56 millert Exp $	*/
d461 2
a462 1
 * 3 == Pseudo IBSS
a463 1
#define WI_PORTTYPE_IBSS	0x0
d467 1
@


1.17
log
@Add support for Symbol cards and printing of the primary station
firmware version.  Adapted from NetBSD and the Linux orinoco driver.
The Symbol firmware requires that we do a COR soft reset before
initializing the card in wi_reset().  Also, setting WI_RID_ROAMING_MODE
caused the Symbol card to go into a strange (non-working) mode with
firmware 2.x.x.

There are some other Symbol additions/oddities that will need to be
addressed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.16 2002/03/30 21:57:40 millert Exp $	*/
d78 2
@


1.16
log
@o Move register definitions to if_wireg.h
o Rename some register defines to be more useful (adapted from FreeBSD)
o Enable interrupts on PLX chip since some boards don't have this in
the EEPROM (adapted from FreeBSD and Linux).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.15 2002/03/28 20:49:39 mickey Exp $	*/
d274 5
a278 3
#define WI_PCI_PLX_LOCALRES	0x14	/* PLX chip's local registers */
#define WI_PCI_PLX_MEMRES	0x18	/* Prism attribute memory (PLX) */
#define WI_PCI_PLX_IORES	0x1C	/* Prism I/O space (PLX) */
a280 1
#define WI_PLX_COR_OFFSET	0x3E0	/* COR attribute offset of Prism2 */
d283 3
a285 2
#define WI_PCI_TMD_LOCALRES	0x14	/* TMD chip's local registers */
#define WI_PCI_TMD_IORES	0x18	/* Prism I/O space (TMD) */
d295 1
a295 1
#define WI_PCI_COR		0x4C
d309 2
a310 1
#define WI_PCI_SOFT_RESET       (1 << 7)
d384 13
a396 10
#define	WI_NIC_EVB2	0x8000
#define	WI_NIC_HWB3763	0x8001
#define	WI_NIC_HWB3163	0x8002
#define	WI_NIC_HWB3163B	0x8003
#define	WI_NIC_EVB3	0x8004
#define	WI_NIC_HWB1153	0x8007
#define	WI_NIC_P2_SST	0x8008  /* Prism2 with SST flush */
#define	WI_NIC_PRISM2_5	0x800C
#define	WI_NIC_3874A	0x8013	/* Prism2.5 Mini-PCI */
#define	WI_NIC_37300P	0x801a
@


1.15
log
@some BITS defs for %b
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.14 2002/03/28 18:21:06 mickey Exp $	*/
d149 1
a149 1
 * Size of Hermes I/O space.
d274 7
a280 2
#define WI_PLX_COR_OFFSET	0x3E0
#define WI_PLX_COR_VALUE	0x41
d282 2
d292 1
@


1.14
log
@basic host-ap implementation, more work is needed; from Thomas Skibo <skibo@@pacbell.net>; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.13 2002/03/28 17:41:02 mickey Exp $	*/
d497 1
@


1.13
log
@recognize isl37300p as a prism2.5, for niels baby
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.12 2002/03/26 20:42:51 millert Exp $	*/
d34 1
a34 1
 *	From: if_wireg.h,v 1.5 1999/07/20 20:03:42 wpaul Exp $
d37 2
d447 1
d451 1
d491 8
d516 2
a517 1
	u_int16_t		wi_rsvd3;	/* 0x0A */
d537 1
d546 1
d551 1
d559 4
d576 3
@


1.12
log
@Add support for the TMD7160 dumb PCI-ISA bridge (similar in function to
the PLX905x).  Info gleaned from patches to the Linux wlan driver
from NDC.  This makes the NDC NCP130 rev A2 work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.11 2002/02/21 23:00:15 millert Exp $	*/
d380 1
@


1.11
log
@In WI_SETSTR round up i_len to be an even number if needed since we
are going to divide it by 2.  More or less based on NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.10 2002/02/19 01:24:58 mickey Exp $	*/
d274 2
@


1.10
log
@add support for media and other generic 802.11 ioctls, elliminates need for wicontrol on the ramdisk floppy, pretty much; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.9 2001/12/21 15:48:20 mickey Exp $	*/
d328 1
d330 1
d332 1
a332 1
		s.wi_len = (str.i_len / 2) + 2;			\
@


1.9
log
@increase the timeout 10x, it seems some cards cannot keep up w/ our pace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.8 2001/12/20 17:48:25 mickey Exp $	*/
a327 1
		int			l;			\
a328 1
		l = (strlen(str) + 1) & ~0x1;			\
d330 1
a330 1
		s.wi_len = (l / 2) + 2;				\
d332 2
a333 2
		s.wi_str[0] = htole16(strlen(str));		\
		bcopy(str, (char *)&s.wi_str[1], strlen(str));	\
@


1.8
log
@for mimi-pci cards registers are word in a dword, missed that in bringing over support from netbsd; partially successfully tested by ellidz@@eridu.uchicago.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.7 2001/10/25 19:40:06 mickey Exp $	*/
d37 1
a37 1
#define WI_TIMEOUT	50000	/* XXX just a guess at a good value.  */
@


1.7
log
@implement "the other" pci interface for wavelans, found on intersil
mini-pci cards. inspired by the netbsd's if_wi_pci.c .
rename WI_COR_* into WI_PLX_COR_*, per millert@@'s suggestion.
tested by millert@@ for the plx-based cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.6 2001/10/25 16:39:25 mickey Exp $	*/
d81 2
a82 1
	bus_space_write_4(sc->wi_btag, sc->wi_bhandle, reg, val)
d84 2
a85 1
	bus_space_write_2(sc->wi_btag, sc->wi_bhandle, reg, val)
d87 2
a88 1
	bus_space_write_1(sc->wi_btag, sc->wi_bhandle, reg, val)
d91 2
a92 1
	bus_space_read_4(sc->wi_btag, sc->wi_bhandle, reg)
d94 2
a95 1
	bus_space_read_2(sc->wi_btag, sc->wi_bhandle, reg)
d97 2
a98 1
	bus_space_read_1(sc->wi_btag, sc->wi_bhandle, reg)
d101 2
a102 2
	bus_space_read_raw_multi_2((sc)->wi_btag, (sc)->wi_bhandle, (ba), \
		(dst), (sz))
d104 2
a105 2
	bus_space_write_raw_multi_2((sc)->wi_btag, (sc)->wi_bhandle, (ba), \
		(dst), (sz))
@


1.7.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.9 2001/12/21 15:48:20 mickey Exp $	*/
d37 1
a37 1
#define WI_TIMEOUT	50000	/* 10x XXX just a guess at a good value.  */
d81 1
a81 2
	bus_space_write_4(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg) , val)
d83 1
a83 2
	bus_space_write_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg) , val)
d85 1
a85 2
	bus_space_write_1(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg) , val)
d88 1
a88 2
	bus_space_read_4(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg))
d90 1
a90 2
	bus_space_read_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg))
d92 1
a92 2
	bus_space_read_1(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg))
d95 2
a96 2
	bus_space_read_raw_multi_2((sc)->wi_btag, (sc)->wi_bhandle, \
	    (sc->sc_pci? ba * 2: ba), (dst), (sz))
d98 2
a99 2
	bus_space_write_raw_multi_2((sc)->wi_btag, (sc)->wi_bhandle, \
	    (sc->sc_pci? ba * 2: ba), (dst), (sz))
@


1.7.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.7.2.1 2002/01/31 22:55:31 niklas Exp $	*/
d34 1
a34 1
 *	From: if_wireg.h,v 1.8.2.2 2001/08/25 00:48:25 nsayer Exp $
a36 2
#pragma pack(1)

a76 2
#define	WI_DEFAULT_DIVERSITY	0

d147 1
a147 1
 * Size of Hermes & Prism2 I/O space.
d272 2
a273 13
#define WI_COR_OFFSET		0x3E0	/* COR attribute offset of card */

#define WI_PLX_LOCALRES		0x14	/* PLX chip's local registers */
#define WI_PLX_MEMRES		0x18	/* Prism attribute memory (PLX) */
#define WI_PLX_IORES		0x1C	/* Prism I/O space (PLX) */
#define WI_PLX_INTCSR		0x4C	/* PLX Interrupt CSR */
#define WI_PLX_INTEN		0x40	/* Interrupt Enable bit */
#define WI_PLX_COR_VALUE	0x41	/* Enable with irq in level trigger */

#define WI_TMD_LOCALRES		0x14	/* TMD chip's local registers */
#define WI_TMD_IORES		0x18	/* Prism I/O space (TMD) */
#define WI_TMD_COR_OFFSET	0x00	/* COR attribute offset of Prism2 */
#define WI_TMD_COR_VALUE	0x45
d281 1
a281 2
#define WI_PCI_CBMA		0x10
#define WI_PCI_COR_OFFSET	0x4C
d295 1
a295 2
#define WI_COR_SOFT_RESET	(1 << 7)
#define WI_COR_CLEAR		0x00
d330 1
a330 1
		l = (str.i_len + 1) & ~0x1;			\
d334 2
a335 2
		s.wi_str[0] = htole16(str.i_len);		\
		bcopy(str.i_nwid, &s.wi_str[1], str.i_len);	\
d369 9
a377 13
#define	WI_NIC_LUCENT		0x0001
#define	WI_NIC_SONY		0x0002
#define	WI_NIC_LUCENT_EM	0x0005
#define	WI_NIC_EVB2		0x8000
#define	WI_NIC_HWB3763		0x8001
#define	WI_NIC_HWB3163		0x8002
#define	WI_NIC_HWB3163B		0x8003
#define	WI_NIC_EVB3		0x8004
#define	WI_NIC_HWB1153		0x8007
#define	WI_NIC_P2_SST		0x8008  /* Prism2 with SST flush */
#define	WI_NIC_PRISM2_5		0x800C
#define	WI_NIC_3874A		0x8013	/* Prism2.5 Mini-PCI */
#define	WI_NIC_37300P		0x801a
d440 1
a440 2
 * 3 == Pseudo IBSS (aka ad-hoc demo)
 * 4 == IBSS
a444 2
#define WI_PORTTYPE_IBSS	0x4
#define WI_PORTTYPE_AP		0x6
a483 9
 * Supported rates.
 */
#define WI_SUPPRATES_1M		0x0001
#define WI_SUPPRATES_2M		0x0002
#define WI_SUPPRATES_5M		0x0004
#define WI_SUPPRATES_11M	0x0008
#define	WI_RATES_BITS	"\20\0011M\0022M\0035.5M\00411M"

/*
d501 1
a501 2
	u_int8_t		wi_tx_rtry;	/* 0x0A */
	u_int8_t		wi_tx_rate;	/* 0x0A */
a520 1
#define WI_802_11_OFFSET_HDR	0x0E
a528 1
#define WI_STAT_MGMT		0x8000	/* 802.11b management frames */
a532 1
#define	WI_ENC_TX_MGMT		0x08
a539 4
#define WI_TXCNTL_TX_EX		0x0004
#define WI_TXCNTL_TX_OK		0x0002
#define WI_TXCNTL_NOCRYPT	0x0080

a552 3
#define WI_FCS_LEN		0x4

#pragma pack()
@


1.7.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.7.2.2 2002/06/11 03:42:18 art Exp $	*/
d37 2
d84 19
d104 2
a105 39
#if defined(__sparc64__)
#define WI_BIG_ENDIAN_POSSIBLE	(sc->wi_flags & WI_FLAGS_BUS_PCMCIA)
#elif defined(__sparc__)
#define WI_BIG_ENDIAN_POSSIBLE 	1
#else
#define WI_BIG_ENDIAN_POSSIBLE 	0
#endif

#define CSR_WRITE_4(sc, reg, val)				\
	bus_space_write_4(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg),			\
	     WI_BIG_ENDIAN_POSSIBLE ? htole32(val) : (val))
#define CSR_WRITE_2(sc, reg, val)				\
	bus_space_write_2(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg),			\
	    WI_BIG_ENDIAN_POSSIBLE ? htole16(val) : (val))
#define CSR_WRITE_1(sc, reg, val)				\
	bus_space_write_1(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg), val)

#define CSR_READ_4(sc, reg)					\
	(WI_BIG_ENDIAN_POSSIBLE ?				\
	letoh32(bus_space_read_4(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci ? reg * 2: reg))) :			\
	bus_space_read_4(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg)))
#define CSR_READ_2(sc, reg)					\
	(WI_BIG_ENDIAN_POSSIBLE ?				\
	letoh16(bus_space_read_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci ? reg * 2: reg))) :			\
	bus_space_read_2(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg)))
#define CSR_READ_1(sc, reg)					\
	bus_space_read_1(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg))

#define CSR_READ_RAW_2(sc, ba, dst, sz)				\
	bus_space_read_raw_multi_2((sc)->wi_btag,		\
	    (sc)->wi_bhandle,					\
d107 2
a108 3
#define CSR_WRITE_RAW_2(sc, ba, dst, sz)			\
	bus_space_write_raw_multi_2((sc)->wi_btag,		\
	    (sc)->wi_bhandle,					\
d276 1
a276 2
#define WI_COR_OFFSET		0x40	/* COR attribute offset of card */
#define WI_COR_IOMODE		0x41	/* Enable i/o mode with level irqs */
d282 2
a283 5
#define WI_PLX_INTEN		0x40	/* PCI Interrupt Enable bit */
#define WI_PLX_LINT1STAT	0x04	/* Local interrupt 1 status bit */
#define WI_PLX_COR_OFFSET	0x3E0	/* COR attribute offset of card */

#define	WI_DRVR_MAGIC		0x4A2D	/* Magic number for card detection */
d287 2
d386 13
d468 1
a468 1
#define WI_PORTTYPE_HOSTAP	0x6
d596 1
a596 1
#define	WI_ETHERTYPE_LEN	0x2
@


1.7.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d304 1
a304 4
#define	WI_ACEX_CMDRES		0x10	/* BAR0 (I/O) for ACEX-based bridge */
#define	WI_ACEX_LOCALRES	0x14	/* BAR1 (I/O) for ACEX-based bridge */
#define	WI_ACEX_IORES		0x18	/* BAR2 (I/O) for ACEX-based bridge */
#define	WI_ACEX_COR_OFFSET	0xe0	/* COR attribute offset of card */
a307 2

#define	WI_DRVR_MAGIC		0x4A2D	/* Magic number for card detection */
@


1.6
log
@add prism2.5 mini-pci nic id
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.5 2001/06/25 18:04:23 drahn Exp $	*/
d266 24
a289 2
#define WI_COR_OFFSET		0x3E0
#define WI_COR_VALUE		0x41
@


1.5
log
@Add the missing endian pieces to wavelan driver.
ok, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.4 2001/06/07 18:51:59 millert Exp $	*/
d349 1
@


1.5.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.5 2001/06/25 18:04:23 drahn Exp $	*/
d266 2
a267 24
#define WI_PLX_COR_OFFSET	0x3E0
#define WI_PLX_COR_VALUE	0x41

/*
 * PCI Host Interface Registers (HFA3842 Specific)
 * The value of all Register's Offset, such as WI_INFO_FID and WI_PARAM0,
 * has doubled.
 * About WI_PCI_COR: In this Register, only soft-reset bit implement; Bit(7).
 */
#define WI_PCI_COR		0x4C
#define WI_PCI_HCR		0x5C
#define WI_PCI_MASTER0_ADDRH	0x80
#define WI_PCI_MASTER0_ADDRL	0x84
#define WI_PCI_MASTER0_LEN	0x88
#define WI_PCI_MASTER0_CON	0x8C

#define WI_PCI_STATUS		0x98

#define WI_PCI_MASTER1_ADDRH	0xA0
#define WI_PCI_MASTER1_ADDRL	0xA4
#define WI_PCI_MASTER1_LEN	0xA8
#define WI_PCI_MASTER1_CON	0xAC

#define WI_PCI_SOFT_RESET       (1 << 7)
a348 1
#define	WI_NIC_3874A	0x8013	/* Prism2.5 Mini-PCI */
@


1.5.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
#define WI_TIMEOUT	50000	/* 10x XXX just a guess at a good value.  */
d81 1
a81 2
	bus_space_write_4(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg) , val)
d83 1
a83 2
	bus_space_write_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg) , val)
d85 1
a85 2
	bus_space_write_1(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg) , val)
d88 1
a88 2
	bus_space_read_4(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg))
d90 1
a90 2
	bus_space_read_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg))
d92 1
a92 2
	bus_space_read_1(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci? reg * 2: reg))
d95 2
a96 2
	bus_space_read_raw_multi_2((sc)->wi_btag, (sc)->wi_bhandle, \
	    (sc->sc_pci? ba * 2: ba), (dst), (sz))
d98 2
a99 2
	bus_space_write_raw_multi_2((sc)->wi_btag, (sc)->wi_bhandle, \
	    (sc->sc_pci? ba * 2: ba), (dst), (sz))
d324 1
a324 1
		l = (str.i_len + 1) & ~0x1;			\
d328 2
a329 2
		s.wi_str[0] = htole16(str.i_len);		\
		bcopy(str.i_nwid, &s.wi_str[1], str.i_len);	\
@


1.5.2.3
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a34 1
 *	From: if_wireg.h,v 1.8.2.2 2001/08/25 00:48:25 nsayer Exp $
a76 2
#define	WI_DEFAULT_DIVERSITY	0

d80 19
d100 2
a101 39
#if defined(__sparc64__)
#define WI_BIG_ENDIAN_POSSIBLE	(sc->wi_flags & WI_FLAGS_BUS_PCMCIA)
#elif defined(__sparc__)
#define WI_BIG_ENDIAN_POSSIBLE 	1
#else
#define WI_BIG_ENDIAN_POSSIBLE 	0
#endif

#define CSR_WRITE_4(sc, reg, val)				\
	bus_space_write_4(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg),			\
	     WI_BIG_ENDIAN_POSSIBLE ? htole32(val) : (val))
#define CSR_WRITE_2(sc, reg, val)				\
	bus_space_write_2(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg),			\
	    WI_BIG_ENDIAN_POSSIBLE ? htole16(val) : (val))
#define CSR_WRITE_1(sc, reg, val)				\
	bus_space_write_1(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg), val)

#define CSR_READ_4(sc, reg)					\
	(WI_BIG_ENDIAN_POSSIBLE ?				\
	letoh32(bus_space_read_4(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci ? reg * 2: reg))) :			\
	bus_space_read_4(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg)))
#define CSR_READ_2(sc, reg)					\
	(WI_BIG_ENDIAN_POSSIBLE ?				\
	letoh16(bus_space_read_2(sc->wi_btag, sc->wi_bhandle,	\
	    (sc->sc_pci ? reg * 2: reg))) :			\
	bus_space_read_2(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg)))
#define CSR_READ_1(sc, reg)					\
	bus_space_read_1(sc->wi_btag, sc->wi_bhandle,		\
	    (sc->sc_pci ? reg * 2: reg))

#define CSR_READ_RAW_2(sc, ba, dst, sz)				\
	bus_space_read_raw_multi_2((sc)->wi_btag,		\
	    (sc)->wi_bhandle,					\
d103 2
a104 3
#define CSR_WRITE_RAW_2(sc, ba, dst, sz)			\
	bus_space_write_raw_multi_2((sc)->wi_btag,		\
	    (sc)->wi_bhandle,					\
d147 1
a147 1
 * Size of Hermes & Prism2 I/O space.
d272 2
a273 20
#define WI_COR_OFFSET		0x40	/* COR attribute offset of card */
#define WI_COR_IOMODE		0x41	/* Enable i/o mode with level irqs */

#define WI_PLX_LOCALRES		0x14	/* PLX chip's local registers */
#define WI_PLX_MEMRES		0x18	/* Prism attribute memory (PLX) */
#define WI_PLX_IORES		0x1C	/* Prism I/O space (PLX) */
#define WI_PLX_INTCSR		0x4C	/* PLX Interrupt CSR */
#define WI_PLX_INTEN		0x40	/* PCI Interrupt Enable bit */
#define WI_PLX_LINT1STAT	0x04	/* Local interrupt 1 status bit */
#define WI_PLX_COR_OFFSET	0x3E0	/* COR attribute offset of card */

#define	WI_ACEX_CMDRES		0x10	/* BAR0 (I/O) for ACEX-based bridge */
#define	WI_ACEX_LOCALRES	0x14	/* BAR1 (I/O) for ACEX-based bridge */
#define	WI_ACEX_IORES		0x18	/* BAR2 (I/O) for ACEX-based bridge */
#define	WI_ACEX_COR_OFFSET	0xe0	/* COR attribute offset of card */

#define WI_TMD_LOCALRES		0x14	/* TMD chip's local registers */
#define WI_TMD_IORES		0x18	/* Prism I/O space (TMD) */

#define	WI_DRVR_MAGIC		0x4A2D	/* Magic number for card detection */
d281 1
a281 2
#define WI_PCI_CBMA		0x10
#define WI_PCI_COR_OFFSET	0x4C
d295 1
a295 2
#define WI_COR_SOFT_RESET	(1 << 7)
#define WI_COR_CLEAR		0x00
d369 9
d440 1
a440 2
 * 3 == Pseudo IBSS (aka ad-hoc demo)
 * 4 == IBSS
a444 2
#define WI_PORTTYPE_IBSS	0x4
#define WI_PORTTYPE_HOSTAP	0x6
a483 9
 * Supported rates.
 */
#define WI_SUPPRATES_1M		0x0001
#define WI_SUPPRATES_2M		0x0002
#define WI_SUPPRATES_5M		0x0004
#define WI_SUPPRATES_11M	0x0008
#define	WI_RATES_BITS	"\20\0011M\0022M\0035.5M\00411M"

/*
d501 1
a501 2
	u_int8_t		wi_tx_rtry;	/* 0x0A */
	u_int8_t		wi_tx_rate;	/* 0x0A */
a520 1
#define WI_802_11_OFFSET_HDR	0x0E
a528 1
#define WI_STAT_MGMT		0x8000	/* 802.11b management frames */
a532 1
#define	WI_ENC_TX_MGMT		0x08
a539 4
#define WI_TXCNTL_TX_EX		0x0004
#define WI_TXCNTL_TX_OK		0x0002
#define WI_TXCNTL_NOCRYPT	0x0080

a552 3
#define WI_FCS_LEN		0x4

#define	WI_ETHERTYPE_LEN	0x2
@


1.5.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d85 2
d144 1
a144 1
 *   the comments in the HCP code itself aren't bad, but the publicly
d269 1
a269 1
#define WI_EV_TX		0x0002	/* async xmit completed successfully */
d471 1
a471 1
 * 2 == Wireless Distribution System (WDS)
@


1.5.2.5
log
@Merge with the trunk
@
text
@d37 1
a37 2
#define WI_DELAY	5
#define WI_TIMEOUT	(500000/WI_DELAY)	/* 500ms */
@


1.4
log
@Kill #define duplicates between if_wireg.h and if_wi_ieee.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.3 2001/06/07 05:07:27 mickey Exp $	*/
d94 7
d293 1
a293 1
		g.wi_val = val;			\
d306 1
a306 1
		s.wi_str[0] = strlen(str);			\
@


1.3
log
@no, definately *wi.* does not work here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.2 2001/06/06 18:53:50 millert Exp $	*/
d328 1
a328 1
 * NIC Identification (0xFD0B)
a329 2
#define	WI_RID_CARDID	0xFD0B
#define	WI_RID_IDENT	0xFD20
d345 1
a345 1
 * List of intended regulatory domains (0xFD11).
a346 1
#define WI_RID_DOMAINS		0xFD11
d354 1
a354 1
 * CIS struct (0xFD13).
a355 1
#define WI_RID_CIS		0xFD13
d363 1
a363 1
 * Communications quality (0xFD43).
a364 1
#define WI_RID_COMMQUAL		0xFD43
a372 2
#define	WI_RID_CUR_TX_RATE	0xFD44	/* current TX rate */

d374 1
a374 1
 * Actual system scale thresholds (0xFD46).
a375 2
#define WI_RID_SYSTEM_SCALE	0xFC06
#define WI_RID_SCALETHRESH	0xFD46
d388 1
a388 1
 * PCF info struct (0xFD87).
a389 1
#define WI_RID_PCF		0xFD87
d401 1
a401 1
 * Connection control characteristics.
a405 1
#define WI_RID_PORTTYPE		0xFC00
a412 2
#define WI_RID_MAC_NODE		0xFC01
#define WI_RID_MAC_WDS		0xFC08
a421 2
#define WI_RID_DESIRED_SSID	0xFC02
#define WI_RID_OWN_SSID		0xFC04
d429 1
a429 21
 * Set communications channel (radio frequency).
 */
#define WI_RID_OWN_CHNL		0xFC03

/*
 * Frame data size.
 */
#define WI_RID_MAX_DATALEN	0xFC07

/*
 * ESS power management enable
 */
#define WI_RID_PM_ENABLED	0xFC09

/*
 * ESS max PM sleep internal
 */
#define WI_RID_MAX_SLEEP	0xFC0C

/*
 * Set our station name.
a430 1
#define WI_RID_NODENAME		0xFC0E
d438 2
a439 2
 * Multicast addresses to be put in filter. We're
 * allowed up to 16 addresses in the filter.
a440 1
#define WI_RID_MCAST		0xFC80
a445 26

/*
 * Create IBSS.
 */
#define WI_RID_CREATE_IBSS	0xFC81

#define WI_RID_FRAG_THRESH	0xFC82
#define WI_RID_RTS_THRESH	0xFC83

/*
 * TX rate control
 * 0 == Fixed 1mbps
 * 1 == Fixed 2mbps
 * 2 == auto fallback
 */
#define WI_RID_TX_RATE		0xFC84

/*
 * promiscuous mode.
 */
#define WI_RID_PROMISC		0xFC85

/*
 * Auxiliary Timer tick interval
 */
#define WI_RID_TICK_TIME	0xFCE0
@


1.2
log
@PCI shim for if_wi.c as	promised.  Magic for setting the PLX up
correctly take from the FreeBSD driver and explained by imp@@
Currently this is hard-coded for PrismII cards but that will change
when the PrismII auto-detect code is added to if_wi.c.
Tested with a LinkSys WPC11 in a Global Sun GL24110P02 (aka LinSys WDT11)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.1 2001/05/15 02:40:36 millert Exp $	*/
d73 4
d325 19
@


1.1
log
@Split wi(4) into bus-dependent and bus-independent bits similar to
an(4) -- no real code changes at this point.
Rename if_wavelan_ieee.h to if_wi_ieee.h while I'm at it and
create an if_wivar.h similar to NetBSD.
PCI adaptors exist that are not true PCMCIA controllers so
wi(4) @@ PCI is possible (though the code is not working yet ;-).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wireg.h,v 1.10 2001/04/04 20:13:12 mickey Exp $	*/
d254 3
@

