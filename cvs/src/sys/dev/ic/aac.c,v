head	1.70;
access;
symbols
	OPENBSD_6_2:1.70.0.4
	OPENBSD_6_2_BASE:1.70
	OPENBSD_6_1:1.67.0.6
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.67.0.4
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.66.0.4
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.65.0.4
	OPENBSD_5_6_BASE:1.65
	OPENBSD_5_5:1.62.0.4
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.55.0.2
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.54.0.8
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.4
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.6
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.39.0.6
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.37.0.4
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2;
locks; strict;
comment	@ * @;


1.70
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.69;
commitid	zztPc3QpQPdWwQ6h;

1.69
date	2017.04.09.18.07.19;	author dhill;	state Exp;
branches;
next	1.68;
commitid	O6yENjmyJQKVKwHV;

1.68
date	2017.04.08.02.57.24;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	6s3MfY9d6ZKdL2Uz;

1.67
date	2016.03.27.11.06.19;	author mpi;	state Exp;
branches;
next	1.66;
commitid	rK6tTz2ZiYAggeVt;

1.66
date	2015.05.02.18.13.42;	author krw;	state Exp;
branches;
next	1.65;
commitid	GwVFL9Z1lJ52NlGu;

1.65
date	2014.07.31.18.14.46;	author jasper;	state Exp;
branches;
next	1.64;
commitid	Gj4xQK1MZ9yBdQ5m;

1.64
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.63;
commitid	I19imNlAX05zJOED;

1.63
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	EF98ch02VpFassUi;

1.62
date	2014.01.17.22.52.32;	author dlg;	state Exp;
branches;
next	1.61;

1.61
date	2014.01.17.22.51.10;	author dlg;	state Exp;
branches;
next	1.60;

1.60
date	2014.01.17.22.20.32;	author dlg;	state Exp;
branches;
next	1.59;

1.59
date	2014.01.17.22.18.27;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2013.11.13.05.47.58;	author mlarkin;	state Exp;
branches;
next	1.56;

1.56
date	2013.11.13.05.26.23;	author mlarkin;	state Exp;
branches;
next	1.55;

1.55
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2011.04.04.20.29.45;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.21.05.28.58;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.18.20.57.20;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.10.16.17.38;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.04.04.57.14;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.02.12.12.12;	author martin;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.20.10.30.32;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.18.14.44.33;	author mpf;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.21.19.11.11;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.28.02.51.27;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.22.02.36.26;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.06.22.11.32;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.13.01.01.40;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.03.16.53.15;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.18.05.39.10;	author nate;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.15.05.33.39;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.24.01.19.47;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.21.02.31.13;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.03.22.31.27;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.26.23.53.14;	author martin;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.20.03.58.09;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.10.00.13.36;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.02.21.20.40;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.27.15.02.59;	author niklas;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.05.07.46.44;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.05.06.51.39;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.12.20.12.11;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.04.06.49.28;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.27.01.55.28;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.06.04.42.06;	author csapuntz;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2000.12.13.16.03.11;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.13.15.32.39;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.10.09.39.35;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.23.18;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.10.40.20;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2001.11.13.21.09.59;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	1.4.4.7;

1.4.4.7
date	2003.03.28.00.38.11;	author niklas;	state Exp;
branches;
next	1.4.4.8;

1.4.4.8
date	2003.05.13.19.34.57;	author ho;	state Exp;
branches;
next	1.4.4.9;

1.4.4.9
date	2004.02.19.10.56.15;	author niklas;	state Exp;
branches;
next	1.4.4.10;

1.4.4.10
date	2004.06.05.23.12.38;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2003.05.19.21.54.23;	author tedu;	state Exp;
branches;
next	;

1.14.6.1
date	2003.10.31.06.32.46;	author brad;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@/*	$OpenBSD: aac.c,v 1.69 2017/04/09 18:07:19 dhill Exp $	*/

/*-
 * Copyright (c) 2000 Michael Smith
 * Copyright (c) 2001 Scott Long
 * Copyright (c) 2000 BSDi
 * Copyright (c) 2001 Adaptec, Inc.
 * Copyright (c) 2000 Niklas Hallqvist
 * Copyright (c) 2004 Nathan Binkert
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: /c/ncvs/src/sys/dev/aac/aac.c,v 1.1 2000/09/13 03:20:34 msmith Exp $
 */

/*
 * Driver for the Adaptec 'FSA' family of PCI/SCSI RAID adapters.
 */

/*
 * This driver would not have rewritten for OpenBSD if it was not for the
 * hardware donation from Nocom.  I want to thank them for their support.
 * Of course, credit should go to Mike Smith for the original work he did
 * in the FreeBSD driver where I found lots of reusable code and inspiration.
 * - Niklas Hallqvist
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/malloc.h>
#include <sys/rwlock.h>
#include <sys/time.h>

#include <machine/bus.h>

#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/ic/aacreg.h>
#include <dev/ic/aacvar.h>
#include <dev/ic/aac_tables.h>

/* Geometry constants. */
#define AAC_MAXCYLS		1024
#define AAC_HEADS		64
#define AAC_SECS		32	/* mapping 64*32 */
#define AAC_MEDHEADS		127
#define AAC_MEDSECS		63	/* mapping 127*63 */
#define AAC_BIGHEADS		255
#define AAC_BIGSECS		63	/* mapping 255*63 */
#define AAC_SECS32		0x1f	/* round capacity */

struct scsi_xfer;

void	aac_copy_internal_data(struct scsi_xfer *, u_int8_t *, size_t);
char   *aac_describe_code(struct aac_code_lookup *, u_int32_t);
void	aac_describe_controller(struct aac_softc *);
int	aac_enqueue_fib(struct aac_softc *, int, struct aac_command *);
int	aac_dequeue_fib(struct aac_softc *, int, u_int32_t *,
			struct aac_fib **);
int	aac_enqueue_response(struct aac_softc *sc, int queue,
			     struct aac_fib *fib);

void	aac_eval_mapping(u_int32_t, int *, int *, int *);
void	aac_print_printf(struct aac_softc *);
int	aac_init(struct aac_softc *);
int	aac_check_firmware(struct aac_softc *);
void	aac_internal_cache_cmd(struct scsi_xfer *);

/* Command Processing */
void	aac_timeout(struct aac_softc *);
void	aac_command_timeout(struct aac_command *);
int	aac_map_command(struct aac_command *);
void	aac_complete(void *);
int	aac_bio_command(struct aac_softc *, struct aac_command **);
void	aac_bio_complete(struct aac_command *);
int	aac_wait_command(struct aac_command *, int);
void	aac_create_thread(void *);
void	aac_command_thread(void *);

/* Command Buffer Management */
void	aac_map_command_sg(void *, bus_dma_segment_t *, int, int);
int	aac_alloc_commands(struct aac_softc *);
void	aac_free_commands(struct aac_softc *);
void	aac_unmap_command(struct aac_command *);
int	aac_wait_command(struct aac_command *, int);
void *	aac_alloc_command(void *);
void	aac_scrub_command(struct aac_command *);
void	aac_release_command(void *, void *);
int	aac_alloc_sync_fib(struct aac_softc *, struct aac_fib **, int);
void	aac_release_sync_fib(struct aac_softc *);
int	aac_sync_fib(struct aac_softc *, u_int32_t, u_int32_t,
	    struct aac_fib *, u_int16_t);

void	aac_scsi_cmd(struct scsi_xfer *);
void	aac_startio(struct aac_softc *);
void	aac_startup(struct aac_softc *);
int	aac_sync_command(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t, u_int32_t *);

struct cfdriver aac_cd = {
	NULL, "aac", DV_DULL
};

struct scsi_adapter aac_switch = {
	aac_scsi_cmd,
	scsi_minphys,
	NULL,		/* probe */
	NULL,		/* free */
	NULL		/* ioctl */
};

/* Falcon/PPC interface */
int	aac_fa_get_fwstatus(struct aac_softc *);
void	aac_fa_qnotify(struct aac_softc *, int);
int	aac_fa_get_istatus(struct aac_softc *);
void	aac_fa_clear_istatus(struct aac_softc *, int);
void	aac_fa_set_mailbox(struct aac_softc *, u_int32_t, u_int32_t, u_int32_t,
			   u_int32_t, u_int32_t);
int	aac_fa_get_mailbox(struct aac_softc *, int);
void	aac_fa_set_interrupts(struct aac_softc *, int);

struct aac_interface aac_fa_interface = {
	aac_fa_get_fwstatus,
	aac_fa_qnotify,
	aac_fa_get_istatus,
	aac_fa_clear_istatus,
	aac_fa_set_mailbox,
	aac_fa_get_mailbox,
	aac_fa_set_interrupts
};

/* StrongARM interface */
int	aac_sa_get_fwstatus(struct aac_softc *);
void	aac_sa_qnotify(struct aac_softc *, int);
int	aac_sa_get_istatus(struct aac_softc *);
void	aac_sa_clear_istatus(struct aac_softc *, int);
void	aac_sa_set_mailbox(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t);
int	aac_sa_get_mailbox(struct aac_softc *, int);
void	aac_sa_set_interrupts(struct aac_softc *, int);

struct aac_interface aac_sa_interface = {
	aac_sa_get_fwstatus,
	aac_sa_qnotify,
	aac_sa_get_istatus,
	aac_sa_clear_istatus,
	aac_sa_set_mailbox,
	aac_sa_get_mailbox,
	aac_sa_set_interrupts
};

/* i960Rx interface */
int	aac_rx_get_fwstatus(struct aac_softc *);
void	aac_rx_qnotify(struct aac_softc *, int);
int	aac_rx_get_istatus(struct aac_softc *);
void	aac_rx_clear_istatus(struct aac_softc *, int);
void	aac_rx_set_mailbox(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t);
int	aac_rx_get_mailbox(struct aac_softc *, int);
void	aac_rx_set_interrupts(struct aac_softc *, int);

struct aac_interface aac_rx_interface = {
	aac_rx_get_fwstatus,
	aac_rx_qnotify,
	aac_rx_get_istatus,
	aac_rx_clear_istatus,
	aac_rx_set_mailbox,
	aac_rx_get_mailbox,
	aac_rx_set_interrupts
};

/* Rocket/MIPS interface */
int	aac_rkt_get_fwstatus(struct aac_softc *);
void	aac_rkt_qnotify(struct aac_softc *, int);
int	aac_rkt_get_istatus(struct aac_softc *);
void	aac_rkt_clear_istatus(struct aac_softc *, int);
void	aac_rkt_set_mailbox(struct aac_softc *, u_int32_t,
				    u_int32_t, u_int32_t,
				    u_int32_t, u_int32_t);
int	aac_rkt_get_mailbox(struct aac_softc *, int);
void	aac_rkt_set_interrupts(struct aac_softc *, int);

struct aac_interface aac_rkt_interface = {
	aac_rkt_get_fwstatus,
	aac_rkt_qnotify,
	aac_rkt_get_istatus,
	aac_rkt_clear_istatus,
	aac_rkt_set_mailbox,
	aac_rkt_get_mailbox,
	aac_rkt_set_interrupts
};

#ifdef AAC_DEBUG
int	aac_debug = AAC_DEBUG;
#endif

int
aac_attach(struct aac_softc *sc)
{
	struct scsibus_attach_args saa;
	int error;

	/*
	 * Initialise per-controller queues.
	 */
	mtx_init(&sc->aac_free_mtx, IPL_BIO);
	aac_initq_free(sc);
	aac_initq_ready(sc);
	aac_initq_busy(sc);
	aac_initq_bio(sc);

	/* disable interrupts before we enable anything */
	AAC_MASK_INTERRUPTS(sc);

	/* mark controller as suspended until we get ourselves organised */
	sc->aac_state |= AAC_STATE_SUSPEND;

	/*
	 * Check that the firmware on the card is supported.
	 */
	error = aac_check_firmware(sc);
	if (error)
		return (error);

	/*
	 * Initialize locks
	 */
	AAC_LOCK_INIT(&sc->aac_sync_lock, "AAC sync FIB lock");
	AAC_LOCK_INIT(&sc->aac_aifq_lock, "AAC AIF lock");
	AAC_LOCK_INIT(&sc->aac_io_lock, "AAC I/O lock");
	AAC_LOCK_INIT(&sc->aac_container_lock, "AAC container lock");
	TAILQ_INIT(&sc->aac_container_tqh);

	/* Initialize the local AIF queue pointers */
	sc->aac_aifq_head = sc->aac_aifq_tail = AAC_AIFQ_LENGTH;

	/*
	 * Initialise the adapter.
	 */
	error = aac_init(sc);
	if (error)
		return (error);

	/* Fill in the prototype scsi_link. */
	sc->aac_link.adapter_softc = sc;
	sc->aac_link.adapter = &aac_switch;
	sc->aac_link.openings = (sc->total_fibs - 8) /
	    (sc->aac_container_count ? sc->aac_container_count : 1);
	sc->aac_link.adapter_buswidth = AAC_MAX_CONTAINERS;
	sc->aac_link.adapter_target = AAC_MAX_CONTAINERS;
	sc->aac_link.pool = &sc->aac_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->aac_link;

	config_found(&sc->aac_dev, &saa, scsiprint);

	/* Create the AIF thread */
	sc->aifthread = 0;
	sc->aifflags = 0;
	kthread_create_deferred(aac_create_thread, sc);

	return (0);
}

void
aac_create_thread(void *arg)
{
	struct aac_softc *sc = arg;

	if (kthread_create(aac_command_thread, sc, &sc->aifthread,
	    sc->aac_dev.dv_xname)) {
		/* TODO disable aac */
		printf("%s: failed to create kernel thread, disabled",
		sc->aac_dev.dv_xname);
	}
	AAC_DPRINTF(AAC_D_MISC, ("%s: aac_create_thread\n",
	    sc->aac_dev.dv_xname));

}

/*
 * Probe for containers, create disks.
 */
void
aac_startup(struct aac_softc *sc)
{
	struct aac_fib *fib;
	struct aac_mntinfo *mi;
	struct aac_mntinforesp *mir = NULL;
	int count = 0, i = 0;


	aac_alloc_sync_fib(sc, &fib, 0);
	mi = (struct aac_mntinfo *)&fib->data[0];

	AAC_DPRINTF(AAC_D_MISC, ("%s: aac startup\n", sc->aac_dev.dv_xname));

	sc->aac_container_count = 0;
	/* loop over possible containers */
	do {
		/* request information on this container */
		bzero(mi, sizeof(struct aac_mntinfo));
		mi->Command = VM_NameServe;
		mi->MntType = FT_FILESYS;
		mi->MntCount = i;
		if (aac_sync_fib(sc, ContainerCommand, 0, fib,
				 sizeof(struct aac_mntinfo))) {
			printf("%s: error probing container %d\n",
			       sc->aac_dev.dv_xname, i);
			continue;
		}

		mir = (struct aac_mntinforesp *)&fib->data[0];
		/* XXX Need to check if count changed */
		count = mir->MntRespCount;

		/*
		 * Check container volume type for validity.  Note
		 * that many of the possible types may never show up.
		 */
		if (mir->Status == ST_OK &&
		    mir->MntTable[0].VolType != CT_NONE) {
			int drv_cyls, drv_hds, drv_secs;

			AAC_DPRINTF(AAC_D_MISC,
			    ("%s: %d: id %x  name '%.16s'  size %u  type %d\n",
			     sc->aac_dev.dv_xname, i,
			     mir->MntTable[0].ObjectId,
			     mir->MntTable[0].FileSystemName,
			     mir->MntTable[0].Capacity,
			     mir->MntTable[0].VolType));

			sc->aac_container_count++;
			sc->aac_hdr[i].hd_present = 1;
			sc->aac_hdr[i].hd_size = mir->MntTable[0].Capacity;

			/*
			 * Evaluate mapping (sectors per head, heads per cyl)
			 */
			sc->aac_hdr[i].hd_size &= ~AAC_SECS32;
			aac_eval_mapping(sc->aac_hdr[i].hd_size, &drv_cyls,
					 &drv_hds, &drv_secs);
			sc->aac_hdr[i].hd_heads = drv_hds;
			sc->aac_hdr[i].hd_secs = drv_secs;
			/* Round the size */
			sc->aac_hdr[i].hd_size = drv_cyls * drv_hds * drv_secs;

			sc->aac_hdr[i].hd_devtype = mir->MntTable[0].VolType;

			/* XXX Save the name too for use in IDENTIFY later */
		}

		i++;
	} while ((i < count) && (i < AAC_MAX_CONTAINERS));

	aac_release_sync_fib(sc);

	/* mark the controller up */
	sc->aac_state &= ~AAC_STATE_SUSPEND;

	/* enable interrupts now */
	AAC_UNMASK_INTERRUPTS(sc);
}

/*
 * Take an interrupt.
 */
int
aac_intr(void *arg)
{
	struct aac_softc *sc = arg;
	u_int16_t reason;


	/*
	 * Read the status register directly.  This is faster than taking the
	 * driver lock and reading the queues directly.  It also saves having
	 * to turn parts of the driver lock into a spin mutex, which would be
	 * ugly.
	 */
	reason = AAC_GET_ISTATUS(sc);
	AAC_CLEAR_ISTATUS(sc, reason);
	(void)AAC_GET_ISTATUS(sc);

	if (reason == 0)
		return (0);

	AAC_DPRINTF(AAC_D_INTR, ("%s: intr: sc=%p: reason=%#x\n",
				 sc->aac_dev.dv_xname, sc, reason));

	/* controller wants to talk to us */
	if (reason & (AAC_DB_PRINTF | AAC_DB_COMMAND_READY |
		      AAC_DB_RESPONSE_READY)) {

		if (reason & AAC_DB_RESPONSE_READY) {
			/* handle completion processing */
			if (sc->aifflags & AAC_AIFFLAGS_RUNNING) {
				sc->aifflags |= AAC_AIFFLAGS_COMPLETE;
			} else {
				AAC_LOCK_ACQUIRE(&sc->aac_io_lock);
				aac_complete(sc);
				AAC_LOCK_RELEASE(&sc->aac_io_lock);
			}
		}


		/*
		 * XXX Make sure that we don't get fooled by strange messages
		 * that start with a NULL.
		 */
		if (reason & AAC_DB_PRINTF)
			if (sc->aac_common->ac_printf[0] == 0)
				sc->aac_common->ac_printf[0] = 32;

		/*
		 * This might miss doing the actual wakeup.  However, the
		 * msleep that this is waking up has a timeout, so it will
		 * wake up eventually.  AIFs and printfs are low enough
		 * priority that they can handle hanging out for a few seconds
		 * if needed.
		 */
		if (sc->aifthread)
			wakeup(sc->aifthread);

	}

	return (1);
}

/*
 * Command Processing
 */

/*
 * Start as much queued I/O as possible on the controller
 */
void
aac_startio(struct aac_softc *sc)
{
	struct aac_command *cm;

	AAC_DPRINTF(AAC_D_CMD, ("%s: start command", sc->aac_dev.dv_xname));

	if (sc->flags & AAC_QUEUE_FRZN) {
		AAC_DPRINTF(AAC_D_CMD, (": queue frozen"));
		return;
	}

	AAC_DPRINTF(AAC_D_CMD, ("\n"));

	for (;;) {
		/*
		 * Try to get a command that's been put off for lack of 
		 * resources
		 */
		cm = aac_dequeue_ready(sc);

		/*
		 * Try to build a command off the bio queue (ignore error 
		 * return)
		 */
		if (cm == NULL) {
			AAC_DPRINTF(AAC_D_CMD, ("\n"));
			aac_bio_command(sc, &cm);
			AAC_DPRINTF(AAC_D_CMD, ("%s: start done bio",
						sc->aac_dev.dv_xname));
		}

		/* nothing to do? */
		if (cm == NULL)
			break;

		/*
		 * Try to give the command to the controller.  Any error is
		 * catastrophic since it means that bus_dmamap_load() failed.
		 */
		if (aac_map_command(cm) != 0)
			panic("aac: error mapping command %p", cm);

		AAC_DPRINTF(AAC_D_CMD, ("\n%s: another command",
					sc->aac_dev.dv_xname));
	}

	AAC_DPRINTF(AAC_D_CMD, ("\n"));
}

/*
 * Deliver a command to the controller; allocate controller resources at the
 * last moment when possible.
 */
int
aac_map_command(struct aac_command *cm)
{
	struct aac_softc *sc = cm->cm_sc;
	int error = 0;

	AAC_DPRINTF(AAC_D_CMD, (": map command"));

	/* don't map more than once */
	if (cm->cm_flags & AAC_CMD_MAPPED)
		panic("aac: command %p already mapped", cm);

	if (cm->cm_datalen != 0) {
		error = bus_dmamap_load(sc->aac_dmat, cm->cm_datamap,
					cm->cm_data, cm->cm_datalen, NULL,
					BUS_DMA_NOWAIT);
		if (error)
			return (error);

		aac_map_command_sg(cm, cm->cm_datamap->dm_segs,
				   cm->cm_datamap->dm_nsegs, 0);
	} else {
		aac_map_command_sg(cm, NULL, 0, 0);
	}

	return (error);
}

/*
 * Handle notification of one or more FIBs coming from the controller.
 */
void
aac_command_thread(void *arg)
{
	struct aac_softc *sc = arg;
	struct aac_fib *fib;
	u_int32_t fib_size;
	int size, retval;

	AAC_DPRINTF(AAC_D_THREAD, ("%s: aac_command_thread: starting\n",
	    sc->aac_dev.dv_xname));
	AAC_LOCK_ACQUIRE(&sc->aac_io_lock);
	sc->aifflags = AAC_AIFFLAGS_RUNNING;

	while ((sc->aifflags & AAC_AIFFLAGS_EXIT) == 0) {

		AAC_DPRINTF(AAC_D_THREAD,
		    ("%s: aac_command_thread: aifflags=%#x\n",
		    sc->aac_dev.dv_xname, sc->aifflags));
		retval = 0;

		if ((sc->aifflags & AAC_AIFFLAGS_PENDING) == 0) {
			AAC_DPRINTF(AAC_D_THREAD,
				    ("%s: command thread sleeping\n",
				     sc->aac_dev.dv_xname));
			AAC_LOCK_RELEASE(&sc->aac_io_lock);
			retval = tsleep(sc->aifthread, PRIBIO, "aifthd",
					AAC_PERIODIC_INTERVAL * hz);
			AAC_LOCK_ACQUIRE(&sc->aac_io_lock);
		}

		if ((sc->aifflags & AAC_AIFFLAGS_COMPLETE) != 0) {
			aac_complete(sc);
			sc->aifflags &= ~AAC_AIFFLAGS_COMPLETE;
		}

		/*
		 * While we're here, check to see if any commands are stuck.
		 * This is pretty low-priority, so it's ok if it doesn't
		 * always fire.
		 */
		if (retval == EWOULDBLOCK)
			aac_timeout(sc);

		/* Check the hardware printf message buffer */
		if (sc->aac_common->ac_printf[0] != 0)
			aac_print_printf(sc);

		/* Also check to see if the adapter has a command for us. */
		while (aac_dequeue_fib(sc, AAC_HOST_NORM_CMD_QUEUE,
				       &fib_size, &fib) == 0) {
	
			AAC_PRINT_FIB(sc, fib);
	
			switch (fib->Header.Command) {
			case AifRequest:
				//aac_handle_aif(sc, fib);
				break;
			default:
				printf("%s: unknown command from controller\n",
				       sc->aac_dev.dv_xname);
				break;
			}

			if ((fib->Header.XferState == 0) ||
			    (fib->Header.StructType != AAC_FIBTYPE_TFIB))
				break;

			/* Return the AIF to the controller. */
			if (fib->Header.XferState & AAC_FIBSTATE_FROMADAP) {
				fib->Header.XferState |= AAC_FIBSTATE_DONEHOST;
				*(AAC_FSAStatus*)fib->data = ST_OK;

				/* XXX Compute the Size field? */
				size = fib->Header.Size;
				if (size > sizeof(struct aac_fib)) {
					size = sizeof(struct aac_fib);
					fib->Header.Size = size;
				}
		
				/*
				 * Since we did not generate this command, it
				 * cannot go through the normal
				 * enqueue->startio chain.
				 */
				aac_enqueue_response(sc,
						     AAC_ADAP_NORM_RESP_QUEUE,
						     fib);
			}
		}
	}
	sc->aifflags &= ~AAC_AIFFLAGS_RUNNING;
	AAC_LOCK_RELEASE(&sc->aac_io_lock);

	AAC_DPRINTF(AAC_D_THREAD, ("%s: aac_command_thread: exiting\n",
	    sc->aac_dev.dv_xname));
	kthread_exit(0);
}

/*
 * Process completed commands.
 */
void
aac_complete(void *context)
{
	struct aac_softc *sc = (struct aac_softc *)context;
	struct aac_command *cm;
	struct aac_fib *fib;
	u_int32_t fib_size;

	AAC_DPRINTF(AAC_D_CMD, ("%s: complete", sc->aac_dev.dv_xname));

	/* pull completed commands off the queue */
	for (;;) {
		/* look for completed FIBs on our queue */
		if (aac_dequeue_fib(sc, AAC_HOST_NORM_RESP_QUEUE, &fib_size,
				    &fib))
			break;	/* nothing to do */

		/* get the command, unmap and hand off for processing */
		cm = sc->aac_commands + fib->Header.SenderData;
		if (cm == NULL) {
			AAC_PRINT_FIB(sc, fib);
			break;
		}

		aac_remove_busy(cm);
		aac_unmap_command(cm);
		cm->cm_flags |= AAC_CMD_COMPLETED;

		/* is there a completion handler? */
		if (cm->cm_complete != NULL) {
			cm->cm_complete(cm);
		} else {
			/* assume that someone is sleeping on this command */
			wakeup(cm);
		}
	}

	AAC_DPRINTF(AAC_D_CMD, ("\n"));
	/* see if we can start some more I/O */
	sc->flags &= ~AAC_QUEUE_FRZN;
	aac_startio(sc);
}

/*
 * Get a bio and build a command to go with it.
 */
int
aac_bio_command(struct aac_softc *sc, struct aac_command **cmp)
{
	struct aac_command *cm;
	struct aac_fib *fib;
	struct scsi_xfer *xs;
	u_int8_t opcode = 0;

	AAC_DPRINTF(AAC_D_CMD, ("%s: bio command", sc->aac_dev.dv_xname));

	/* get the resources we will need */
	if ((cm = aac_dequeue_bio(sc)) == NULL)
		goto fail;
	xs = cm->cm_private;

	/* build the FIB */
	fib = cm->cm_fib;
	fib->Header.Size = sizeof(struct aac_fib_header);
	fib->Header.XferState =  
		AAC_FIBSTATE_HOSTOWNED   | 
		AAC_FIBSTATE_INITIALISED | 
		AAC_FIBSTATE_EMPTY	 | 
		AAC_FIBSTATE_FROMHOST	 |
		AAC_FIBSTATE_REXPECTED   |
		AAC_FIBSTATE_NORM	 |
		AAC_FIBSTATE_ASYNC	 |
		AAC_FIBSTATE_FAST_RESPONSE;

	switch(xs->cmd->opcode) {
	case READ_COMMAND:
	case READ_BIG:
		opcode = READ_COMMAND;
		break;
	case WRITE_COMMAND:
	case WRITE_BIG:
		opcode = WRITE_COMMAND;
		break;
	default:
		panic("%s: invalid opcode %#x", sc->aac_dev.dv_xname,
		      xs->cmd->opcode);
	}

	/* build the read/write request */
	if ((sc->flags & AAC_FLAGS_SG_64BIT) == 0) {
		fib->Header.Command = ContainerCommand;
		if (opcode == READ_COMMAND) {
			struct aac_blockread *br;
			br = (struct aac_blockread *)&fib->data[0];
			br->Command = VM_CtBlockRead;
			br->ContainerId = xs->sc_link->target;
			br->BlockNumber = cm->cm_blkno;
			br->ByteCount = cm->cm_bcount * AAC_BLOCK_SIZE;
			fib->Header.Size += sizeof(struct aac_blockread);
			cm->cm_sgtable = &br->SgMap;
			cm->cm_flags |= AAC_CMD_DATAIN;
		} else {
			struct aac_blockwrite *bw;
			bw = (struct aac_blockwrite *)&fib->data[0];
			bw->Command = VM_CtBlockWrite;
			bw->ContainerId = xs->sc_link->target;
			bw->BlockNumber = cm->cm_blkno;
			bw->ByteCount = cm->cm_bcount * AAC_BLOCK_SIZE;
			bw->Stable = CUNSTABLE;
			fib->Header.Size += sizeof(struct aac_blockwrite);
			cm->cm_flags |= AAC_CMD_DATAOUT;
			cm->cm_sgtable = &bw->SgMap;
		}
	} else {
		fib->Header.Command = ContainerCommand64;
		if (opcode == READ_COMMAND) {
			struct aac_blockread64 *br;
			br = (struct aac_blockread64 *)&fib->data[0];
			br->Command = VM_CtHostRead64;
			br->ContainerId = xs->sc_link->target;
			br->BlockNumber = cm->cm_blkno;
			br->SectorCount = cm->cm_bcount;
			br->Pad = 0;
			br->Flags = 0;
			fib->Header.Size += sizeof(struct aac_blockread64);
			cm->cm_flags |= AAC_CMD_DATAOUT;
			cm->cm_sgtable = (struct aac_sg_table *)&br->SgMap64;
		} else {
			struct aac_blockwrite64 *bw;
			bw = (struct aac_blockwrite64 *)&fib->data[0];
			bw->Command = VM_CtHostWrite64;
			bw->ContainerId = xs->sc_link->target;
			bw->BlockNumber = cm->cm_blkno;
			bw->SectorCount = cm->cm_bcount;
			bw->Pad = 0;
			bw->Flags = 0;
			fib->Header.Size += sizeof(struct aac_blockwrite64);
			cm->cm_flags |= AAC_CMD_DATAIN;
			cm->cm_sgtable = (struct aac_sg_table *)&bw->SgMap64;
		}
	}

	*cmp = cm;
	AAC_DPRINTF(AAC_D_CMD, ("\n"));
	return(0);

fail:
	AAC_DPRINTF(AAC_D_CMD, ("\n"));
	return(ENOMEM);
}

/*
 * Handle a bio-instigated command that has been completed.
 */
void
aac_bio_complete(struct aac_command *cm)
{
	struct aac_blockread_response *brr;
	struct aac_blockwrite_response *bwr;
	struct scsi_xfer *xs = (struct scsi_xfer *)cm->cm_private;
	AAC_FSAStatus status;
	int s;

	AAC_DPRINTF(AAC_D_CMD,
		    ("%s: bio complete\n", cm->cm_sc->aac_dev.dv_xname));

	/* fetch relevant status and then release the command */
	if (xs->flags & SCSI_DATA_IN) {
		brr = (struct aac_blockread_response *)&cm->cm_fib->data[0];
		status = brr->Status;
	} else {
		bwr = (struct aac_blockwrite_response *)&cm->cm_fib->data[0];
		status = bwr->Status;
	}

	xs->error = status == ST_OK? XS_NOERROR : XS_DRIVER_STUFFUP;
	xs->resid = 0;
	s = splbio();
	scsi_done(xs);
	splx(s);
}

/*
 * Submit a command to the controller, return when it completes.
 * XXX This is very dangerous!  If the card has gone out to lunch, we could
 *     be stuck here forever.  At the same time, signals are not caught
 *     because there is a risk that a signal could wakeup the tsleep before
 *     the card has a chance to complete the command.  The passed in timeout
 *     is ignored for the same reason.  Since there is no way to cancel a
 *     command in progress, we should probably create a 'dead' queue where
 *     commands go that have been interrupted/timed-out/etc, that keeps them
 *     out of the free pool.  That way, if the card is just slow, it won't
 *     spam the memory of a command that has been recycled.
 */
int
aac_wait_command(struct aac_command *cm, int timeout)
{
	struct aac_softc *sc = cm->cm_sc;
	int error = 0;

	AAC_DPRINTF(AAC_D_CMD, (": wait for command"));

	/* Put the command on the ready queue and get things going */
	cm->cm_queue = AAC_ADAP_NORM_CMD_QUEUE;
	aac_enqueue_ready(cm);
	AAC_DPRINTF(AAC_D_CMD, ("\n"));
	aac_startio(sc);
	while (!(cm->cm_flags & AAC_CMD_COMPLETED) && (error != EWOULDBLOCK)) {
		AAC_DPRINTF(AAC_D_MISC, ("%s: sleeping until command done\n",
					 sc->aac_dev.dv_xname));
		AAC_LOCK_RELEASE(&sc->aac_io_lock);
		error = tsleep(cm, PRIBIO, "aacwait", timeout);
		AAC_LOCK_ACQUIRE(&sc->aac_io_lock);
	}
	return (error);
}

/*
 *Command Buffer Management
 */

/*
 * Allocate a command.
 */
void *
aac_alloc_command(void *xsc)
{
	struct aac_softc *sc = xsc;
	struct aac_command *cm;

	AAC_DPRINTF(AAC_D_CMD, (": allocate command"));
	mtx_enter(&sc->aac_free_mtx);
	cm = aac_dequeue_free(sc);
	mtx_leave(&sc->aac_free_mtx);

	return (cm);
}

void
aac_scrub_command(struct aac_command *cm)
{
	cm->cm_sgtable = NULL;
	cm->cm_flags = 0;
	cm->cm_complete = NULL;
	cm->cm_private = NULL;
	cm->cm_fib->Header.XferState = AAC_FIBSTATE_EMPTY;
	cm->cm_fib->Header.StructType = AAC_FIBTYPE_TFIB;
	cm->cm_fib->Header.Flags = 0;
	cm->cm_fib->Header.SenderSize = sizeof(struct aac_fib);
}

/*
 * Release a command back to the freelist.
 */
void
aac_release_command(void *xsc, void *xcm)
{
	struct aac_softc *sc = xsc;
	struct aac_command *cm = xcm;
	AAC_DPRINTF(AAC_D_CMD, (": release command"));

	mtx_enter(&sc->aac_free_mtx);
	aac_enqueue_free(cm);
	mtx_leave(&sc->aac_free_mtx);
}

/*
 * Allocate and initialise commands/FIBs for this adapter.
 */
int
aac_alloc_commands(struct aac_softc *sc)
{
	struct aac_command *cm;
	struct aac_fibmap *fm;
	int i, error = ENOMEM;

	if (sc->total_fibs + AAC_FIB_COUNT > sc->aac_max_fibs)
		return (ENOMEM);

	fm = malloc(sizeof(*fm), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (fm == NULL)
		goto exit;

	/* allocate the FIBs in DMAable memory and load them */
	if (bus_dmamem_alloc(sc->aac_dmat, AAC_FIBMAP_SIZE, PAGE_SIZE, 0,
	    &fm->aac_seg, 1, &fm->aac_nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf("%s: can't alloc FIBs\n", sc->aac_dev.dv_xname);
		error = ENOBUFS;
		goto exit_alloc;
	}

	if (bus_dmamem_map(sc->aac_dmat, &fm->aac_seg, 1,
	    AAC_FIBMAP_SIZE, (caddr_t *)&fm->aac_fibs, BUS_DMA_NOWAIT)) {
		printf("%s: can't map FIB structure\n", sc->aac_dev.dv_xname);
		error = ENOBUFS;
		goto exit_map;
	}

	if (bus_dmamap_create(sc->aac_dmat, AAC_FIBMAP_SIZE, 1,
	    AAC_FIBMAP_SIZE, 0, BUS_DMA_NOWAIT, &fm->aac_fibmap)) {
		printf("%s: can't create dma map\n", sc->aac_dev.dv_xname);
		error = ENOBUFS;
		goto exit_create;
	}

	if (bus_dmamap_load(sc->aac_dmat, fm->aac_fibmap, fm->aac_fibs,
	    AAC_FIBMAP_SIZE, NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->aac_dev.dv_xname);
		error = ENOBUFS;
		goto exit_load;
	}

	/* initialise constant fields in the command structure */
	AAC_LOCK_ACQUIRE(&sc->aac_io_lock);
	for (i = 0; i < AAC_FIB_COUNT; i++) {
		cm = sc->aac_commands + sc->total_fibs;
		fm->aac_commands = cm;
		cm->cm_sc = sc;
		cm->cm_fib = fm->aac_fibs + i;
		cm->cm_fibphys = fm->aac_fibmap->dm_segs[0].ds_addr +
			(i * sizeof(struct aac_fib));
		cm->cm_index = sc->total_fibs;

		if (bus_dmamap_create(sc->aac_dmat, MAXBSIZE, AAC_MAXSGENTRIES,
		    MAXBSIZE, 0, BUS_DMA_NOWAIT, &cm->cm_datamap)) {
			break;
		}
		aac_release_command(sc, cm);
		sc->total_fibs++;
	}

	if (i > 0) {
		TAILQ_INSERT_TAIL(&sc->aac_fibmap_tqh, fm, fm_link);
		AAC_DPRINTF(AAC_D_MISC, ("%s: total_fibs= %d\n",
					 sc->aac_dev.dv_xname,
					 sc->total_fibs));
		AAC_LOCK_RELEASE(&sc->aac_io_lock);
		return (0);
	}

 exit_load:
	bus_dmamap_destroy(sc->aac_dmat, fm->aac_fibmap);
 exit_create:
	bus_dmamem_unmap(sc->aac_dmat, (caddr_t)fm->aac_fibs, AAC_FIBMAP_SIZE);
 exit_map:
	bus_dmamem_free(sc->aac_dmat, &fm->aac_seg, fm->aac_nsegs);
 exit_alloc:
	free(fm, M_DEVBUF, sizeof *fm);
 exit:
	AAC_LOCK_RELEASE(&sc->aac_io_lock);
	return (error);
}

/*
 * Free FIBs owned by this adapter.
 */
void
aac_free_commands(struct aac_softc *sc)
{
	struct aac_fibmap *fm;
	struct aac_command *cm;
	int i;

	while ((fm = TAILQ_FIRST(&sc->aac_fibmap_tqh)) != NULL) {

		TAILQ_REMOVE(&sc->aac_fibmap_tqh, fm, fm_link);

		/*
		 * We check against total_fibs to handle partially
		 * allocated blocks.
		 */
		for (i = 0; i < AAC_FIB_COUNT && sc->total_fibs--; i++) {
			cm = fm->aac_commands + i;
			bus_dmamap_destroy(sc->aac_dmat, cm->cm_datamap);
		}

		bus_dmamap_unload(sc->aac_dmat, fm->aac_fibmap);
		bus_dmamap_destroy(sc->aac_dmat, fm->aac_fibmap);
		bus_dmamem_unmap(sc->aac_dmat, (caddr_t)fm->aac_fibs,
				 AAC_FIBMAP_SIZE);
		bus_dmamem_free(sc->aac_dmat, &fm->aac_seg, fm->aac_nsegs);
		free(fm, M_DEVBUF, sizeof *fm);
	}
}


/*
 * Command-mapping helper function - populate this command's s/g table.
 */
void
aac_map_command_sg(void *arg, bus_dma_segment_t *segs, int nseg, int error)
{
	struct aac_command *cm = arg;
	struct aac_softc *sc = cm->cm_sc;
	struct aac_fib *fib = cm->cm_fib;
	int i;

	/* copy into the FIB */
	if (cm->cm_sgtable != NULL) {
		if ((cm->cm_sc->flags & AAC_FLAGS_SG_64BIT) == 0) {
			struct aac_sg_table *sg = cm->cm_sgtable;
			sg->SgCount = nseg;
			for (i = 0; i < nseg; i++) {
				sg->SgEntry[i].SgAddress = segs[i].ds_addr;
				sg->SgEntry[i].SgByteCount = segs[i].ds_len;
			}
			/* update the FIB size for the s/g count */
			fib->Header.Size += nseg * sizeof(struct aac_sg_entry);
		} else {
			struct aac_sg_table64 *sg;
			sg = (struct aac_sg_table64 *)cm->cm_sgtable;
			sg->SgCount = nseg;
			for (i = 0; i < nseg; i++) {
				sg->SgEntry64[i].SgAddress = segs[i].ds_addr;
				sg->SgEntry64[i].SgByteCount = segs[i].ds_len;
			}
			/* update the FIB size for the s/g count */
			fib->Header.Size += nseg*sizeof(struct aac_sg_entry64);
		}
	}

	/* Fix up the address values in the FIB.  Use the command array index
	 * instead of a pointer since these fields are only 32 bits.  Shift
	 * the SenderFibAddress over to make room for the fast response bit.
	 */
	cm->cm_fib->Header.SenderFibAddress = (cm->cm_index << 1);
	cm->cm_fib->Header.ReceiverFibAddress = cm->cm_fibphys;

	/* save a pointer to the command for speedy reverse-lookup */
	cm->cm_fib->Header.SenderData = cm->cm_index;

	if (cm->cm_flags & AAC_CMD_DATAIN)
		bus_dmamap_sync(sc->aac_dmat, cm->cm_datamap, 0,
				cm->cm_datamap->dm_mapsize,
				BUS_DMASYNC_PREREAD);
	if (cm->cm_flags & AAC_CMD_DATAOUT)
		bus_dmamap_sync(sc->aac_dmat, cm->cm_datamap, 0,
				cm->cm_datamap->dm_mapsize,
				BUS_DMASYNC_PREWRITE);
	cm->cm_flags |= AAC_CMD_MAPPED;

	/* put the FIB on the outbound queue */
	if (aac_enqueue_fib(sc, cm->cm_queue, cm) == EBUSY) {
		aac_remove_busy(cm);
		aac_unmap_command(cm);
		aac_requeue_ready(cm);
	}
}

/*
 * Unmap a command from controller-visible space.
 */
void
aac_unmap_command(struct aac_command *cm)
{
	struct aac_softc *sc = cm->cm_sc;

	if (!(cm->cm_flags & AAC_CMD_MAPPED))
		return;

	if (cm->cm_datalen != 0) {
		if (cm->cm_flags & AAC_CMD_DATAIN)
			bus_dmamap_sync(sc->aac_dmat, cm->cm_datamap, 0,
					cm->cm_datamap->dm_mapsize,
					BUS_DMASYNC_POSTREAD);
		if (cm->cm_flags & AAC_CMD_DATAOUT)
			bus_dmamap_sync(sc->aac_dmat, cm->cm_datamap, 0,
					cm->cm_datamap->dm_mapsize,
					BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->aac_dmat, cm->cm_datamap);
	}
	cm->cm_flags &= ~AAC_CMD_MAPPED;
}

/*
 * Hardware Interface
 */

/*
 * Initialise the adapter.
 */
int
aac_check_firmware(struct aac_softc *sc)
{
	u_int32_t major, minor, options;

	/*
	 * Retrieve the firmware version numbers.  Dell PERC2/QC cards with
	 * firmware version 1.x are not compatible with this driver.
	 */
	if (sc->flags & AAC_FLAGS_PERC2QC) {
		if (aac_sync_command(sc, AAC_MONKER_GETKERNVER, 0, 0, 0, 0,
				     NULL)) {
			printf("%s: Error reading firmware version\n",
			       sc->aac_dev.dv_xname);
			return (EIO);
		}

		/* These numbers are stored as ASCII! */
		major = (AAC_GET_MAILBOX(sc, 1) & 0xff) - 0x30;
		minor = (AAC_GET_MAILBOX(sc, 2) & 0xff) - 0x30;
		if (major == 1) {
			printf("%s: Firmware version %d.%d is not supported\n",
			       sc->aac_dev.dv_xname, major, minor);
			return (EINVAL);
		}
	}

	/*
	 * Retrieve the capabilities/supported options word so we know what
	 * work-arounds to enable.
	 */
	if (aac_sync_command(sc, AAC_MONKER_GETINFO, 0, 0, 0, 0, NULL)) {
		printf("%s: RequestAdapterInfo failed\n",
		       sc->aac_dev.dv_xname);
		return (EIO);
	}
	options = AAC_GET_MAILBOX(sc, 1);
	sc->supported_options = options;

	if ((options & AAC_SUPPORTED_4GB_WINDOW) != 0 &&
	    (sc->flags & AAC_FLAGS_NO4GB) == 0)
		sc->flags |= AAC_FLAGS_4GB_WINDOW;
	if (options & AAC_SUPPORTED_NONDASD)
		sc->flags |= AAC_FLAGS_ENABLE_CAM;
	if ((options & AAC_SUPPORTED_SGMAP_HOST64) != 0
	     && (sizeof(bus_addr_t) > 4)) {
		printf("%s: Enabling 64-bit address support\n",
		       sc->aac_dev.dv_xname);
		sc->flags |= AAC_FLAGS_SG_64BIT;
	}

	/* Check for broken hardware that does a lower number of commands */
	if ((sc->flags & AAC_FLAGS_256FIBS) == 0)
		sc->aac_max_fibs = AAC_MAX_FIBS;
	else
		sc->aac_max_fibs = 256;

	return (0);
}

int
aac_init(struct aac_softc *sc)
{
	bus_dma_segment_t seg;
	int nsegs;
	int i, error;
	int state = 0;
	struct aac_adapter_init	*ip;
	time_t then;
	u_int32_t code, qoffset;

	/*
	 * First wait for the adapter to come ready.
	 */
	then = time_uptime;
	for (i = 0; i < AAC_BOOT_TIMEOUT * 1000; i++) {
		code = AAC_GET_FWSTATUS(sc);
		if (code & AAC_SELF_TEST_FAILED) {
			printf("%s: FATAL: selftest failed\n",
			    sc->aac_dev.dv_xname);
			return (ENXIO);
		}
		if (code & AAC_KERNEL_PANIC) {
			printf("%s: FATAL: controller kernel panic\n",
			    sc->aac_dev.dv_xname);
			return (ENXIO);
		}
		if (code & AAC_UP_AND_RUNNING)
			break;
		DELAY(1000);
	}
	if (i == AAC_BOOT_TIMEOUT * 1000) {
		printf("%s: FATAL: controller not coming ready, status %x\n",
		    sc->aac_dev.dv_xname, code);
		return (ENXIO);
	}

	/*
	 * Work around a bug in the 2120 and 2200 that cannot DMA commands
	 * below address 8192 in physical memory.
	 * XXX If the padding is not needed, can it be put to use instead
	 * of ignored?
	 */
	if (bus_dmamem_alloc(sc->aac_dmat, AAC_COMMON_ALLOCSIZE, PAGE_SIZE, 0,
			     &seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf("%s: can't allocate common structure\n",
		    sc->aac_dev.dv_xname);
		return (ENOMEM);
	}
	state++;

	if (bus_dmamem_map(sc->aac_dmat, &seg, nsegs, AAC_COMMON_ALLOCSIZE,
			   (caddr_t *)&sc->aac_common, BUS_DMA_NOWAIT)) {
		printf("%s: can't map common structure\n",
		    sc->aac_dev.dv_xname);
		error = ENOMEM;
		goto bail_out;
	}
	state++;

	if (bus_dmamap_create(sc->aac_dmat, AAC_COMMON_ALLOCSIZE, 1,
	    AAC_COMMON_ALLOCSIZE, 0, BUS_DMA_NOWAIT, &sc->aac_common_map)) {
		printf("%s: can't create dma map\n", sc->aac_dev.dv_xname);
		error = ENOBUFS;
		goto bail_out;
	}
	state++;

	if (bus_dmamap_load(sc->aac_dmat, sc->aac_common_map, sc->aac_common,
	    AAC_COMMON_ALLOCSIZE, NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->aac_dev.dv_xname);
		error = ENOBUFS;
		goto bail_out;
	}
	state++;

	sc->aac_common_busaddr = sc->aac_common_map->dm_segs[0].ds_addr;

	if (sc->aac_common_busaddr < 8192) {
		sc->aac_common = (struct aac_common *)
		    ((uint8_t *)sc->aac_common + 8192);
		sc->aac_common_busaddr += 8192;
	}

	/* Allocate some FIBs and associated command structs */
	TAILQ_INIT(&sc->aac_fibmap_tqh);
	sc->aac_commands = malloc(AAC_MAX_FIBS * sizeof(struct aac_command),
	    M_DEVBUF, M_WAITOK | M_ZERO);
	while (sc->total_fibs < AAC_MAX_FIBS) {
		if (aac_alloc_commands(sc) != 0)
			break;
	}
	if (sc->total_fibs == 0)
		goto out;

	scsi_iopool_init(&sc->aac_iopool, sc,
	    aac_alloc_command, aac_release_command);

	/*
	 * Fill in the init structure.  This tells the adapter about the
	 * physical location of various important shared data structures.
	 */
	ip = &sc->aac_common->ac_init;
	ip->InitStructRevision = AAC_INIT_STRUCT_REVISION;
	ip->MiniPortRevision = AAC_INIT_STRUCT_MINIPORT_REVISION;

	ip->AdapterFibsPhysicalAddress = sc->aac_common_busaddr +
					 offsetof(struct aac_common, ac_fibs);
	ip->AdapterFibsVirtualAddress = 0;
	ip->AdapterFibsSize = AAC_ADAPTER_FIBS * sizeof(struct aac_fib);
	ip->AdapterFibAlign = sizeof(struct aac_fib);

	ip->PrintfBufferAddress = sc->aac_common_busaddr +
				  offsetof(struct aac_common, ac_printf);
	ip->PrintfBufferSize = AAC_PRINTF_BUFSIZE;

	/*
	 * The adapter assumes that pages are 4K in size, except on some
	 * broken firmware versions that do the page->byte conversion twice,
	 * therefore 'assuming' that this value is in 16MB units (2^24).
	 * Round up since the granularity is so high.
	 */
	ip->HostPhysMemPages = ptoa(physmem) / AAC_PAGE_SIZE;
	if (sc->flags & AAC_FLAGS_BROKEN_MEMMAP) {
		ip->HostPhysMemPages =
		    (ip->HostPhysMemPages + AAC_PAGE_SIZE) / AAC_PAGE_SIZE;
	}
	ip->HostElapsedSeconds = time_uptime; /* reset later if invalid */

	/*
	 * Initialise FIB queues.  Note that it appears that the layout of the
	 * indexes and the segmentation of the entries may be mandated by the
	 * adapter, which is only told about the base of the queue index fields.
	 *
	 * The initial values of the indices are assumed to inform the adapter
	 * of the sizes of the respective queues, and theoretically it could
	 * work out the entire layout of the queue structures from this.  We
	 * take the easy route and just lay this area out like everyone else
	 * does.
	 *
	 * The Linux driver uses a much more complex scheme whereby several
	 * header records are kept for each queue.  We use a couple of generic
	 * list manipulation functions which 'know' the size of each list by
	 * virtue of a table.
	 */
	qoffset = offsetof(struct aac_common, ac_qbuf) + AAC_QUEUE_ALIGN;
	qoffset &= ~(AAC_QUEUE_ALIGN - 1);
	sc->aac_queues =
	    (struct aac_queue_table *)((caddr_t)sc->aac_common + qoffset);
	ip->CommHeaderAddress = sc->aac_common_busaddr + qoffset;

	sc->aac_queues->qt_qindex[AAC_HOST_NORM_CMD_QUEUE][AAC_PRODUCER_INDEX] =
		AAC_HOST_NORM_CMD_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_HOST_NORM_CMD_QUEUE][AAC_CONSUMER_INDEX] =
		AAC_HOST_NORM_CMD_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_HOST_HIGH_CMD_QUEUE][AAC_PRODUCER_INDEX] =
		AAC_HOST_HIGH_CMD_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_HOST_HIGH_CMD_QUEUE][AAC_CONSUMER_INDEX] =
		AAC_HOST_HIGH_CMD_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_ADAP_NORM_CMD_QUEUE][AAC_PRODUCER_INDEX] =
		AAC_ADAP_NORM_CMD_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_ADAP_NORM_CMD_QUEUE][AAC_CONSUMER_INDEX] =
		AAC_ADAP_NORM_CMD_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_ADAP_HIGH_CMD_QUEUE][AAC_PRODUCER_INDEX] =
		AAC_ADAP_HIGH_CMD_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_ADAP_HIGH_CMD_QUEUE][AAC_CONSUMER_INDEX] =
		AAC_ADAP_HIGH_CMD_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_HOST_NORM_RESP_QUEUE][AAC_PRODUCER_INDEX]=
		AAC_HOST_NORM_RESP_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_HOST_NORM_RESP_QUEUE][AAC_CONSUMER_INDEX]=
		AAC_HOST_NORM_RESP_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_HOST_HIGH_RESP_QUEUE][AAC_PRODUCER_INDEX]=
		AAC_HOST_HIGH_RESP_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_HOST_HIGH_RESP_QUEUE][AAC_CONSUMER_INDEX]=
		AAC_HOST_HIGH_RESP_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_ADAP_NORM_RESP_QUEUE][AAC_PRODUCER_INDEX]=
		AAC_ADAP_NORM_RESP_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_ADAP_NORM_RESP_QUEUE][AAC_CONSUMER_INDEX]=
		AAC_ADAP_NORM_RESP_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_ADAP_HIGH_RESP_QUEUE][AAC_PRODUCER_INDEX]=
		AAC_ADAP_HIGH_RESP_ENTRIES;
	sc->aac_queues->qt_qindex[AAC_ADAP_HIGH_RESP_QUEUE][AAC_CONSUMER_INDEX]=
		AAC_ADAP_HIGH_RESP_ENTRIES;
	sc->aac_qentries[AAC_HOST_NORM_CMD_QUEUE] =
		&sc->aac_queues->qt_HostNormCmdQueue[0];
	sc->aac_qentries[AAC_HOST_HIGH_CMD_QUEUE] =
		&sc->aac_queues->qt_HostHighCmdQueue[0];
	sc->aac_qentries[AAC_ADAP_NORM_CMD_QUEUE] =
		&sc->aac_queues->qt_AdapNormCmdQueue[0];
	sc->aac_qentries[AAC_ADAP_HIGH_CMD_QUEUE] =
		&sc->aac_queues->qt_AdapHighCmdQueue[0];
	sc->aac_qentries[AAC_HOST_NORM_RESP_QUEUE] =
		&sc->aac_queues->qt_HostNormRespQueue[0];
	sc->aac_qentries[AAC_HOST_HIGH_RESP_QUEUE] =
		&sc->aac_queues->qt_HostHighRespQueue[0];
	sc->aac_qentries[AAC_ADAP_NORM_RESP_QUEUE] =
		&sc->aac_queues->qt_AdapNormRespQueue[0];
	sc->aac_qentries[AAC_ADAP_HIGH_RESP_QUEUE] =
		&sc->aac_queues->qt_AdapHighRespQueue[0];

	/*
	 * Do controller-type-specific initialisation
	 */
	switch (sc->aac_hwif) {
	case AAC_HWIF_I960RX:
		AAC_SETREG4(sc, AAC_RX_ODBR, ~0);
		break;
	case AAC_HWIF_RKT:
		AAC_SETREG4(sc, AAC_RKT_ODBR, ~0);
		break;
	default:
		break;
	}

	/*
	 * Give the init structure to the controller.
	 */
	if (aac_sync_command(sc, AAC_MONKER_INITSTRUCT,
			     sc->aac_common_busaddr +
			     offsetof(struct aac_common, ac_init), 0, 0, 0,
			     NULL)) {
		printf("%s: error establishing init structure\n",
		    sc->aac_dev.dv_xname);
		error = EIO;
		goto bail_out;
	}

	aac_describe_controller(sc);
	aac_startup(sc);

	return (0);

 bail_out:
	if (state > 3)
		bus_dmamap_unload(sc->aac_dmat, sc->aac_common_map);
	if (state > 2)
		bus_dmamap_destroy(sc->aac_dmat, sc->aac_common_map);
	if (state > 1)
		bus_dmamem_unmap(sc->aac_dmat, (caddr_t)sc->aac_common,
		    sizeof *sc->aac_common);
	if (state > 0)
		bus_dmamem_free(sc->aac_dmat, &seg, 1);

 out:
	return (error);
}

/*
 * Send a synchronous command to the controller and wait for a result.
 */
int
aac_sync_command(struct aac_softc *sc, u_int32_t command, u_int32_t arg0,
		 u_int32_t arg1, u_int32_t arg2, u_int32_t arg3, u_int32_t *sp)
{
//	time_t then;
	int i;
	u_int32_t status;
	u_int16_t reason;

	/* populate the mailbox */
	AAC_SET_MAILBOX(sc, command, arg0, arg1, arg2, arg3);

	/* ensure the sync command doorbell flag is cleared */
	AAC_CLEAR_ISTATUS(sc, AAC_DB_SYNC_COMMAND);

	/* then set it to signal the adapter */
	AAC_QNOTIFY(sc, AAC_DB_SYNC_COMMAND);

	DELAY(AAC_SYNC_DELAY);

	/* spin waiting for the command to complete */
	for (i = 0; i < AAC_IMMEDIATE_TIMEOUT * 1000; i++) {
		reason = AAC_GET_ISTATUS(sc);
		if (reason & AAC_DB_SYNC_COMMAND)
			break;
		reason = AAC_GET_ISTATUS(sc);
		if (reason & AAC_DB_SYNC_COMMAND)
			break;
		reason = AAC_GET_ISTATUS(sc);
		if (reason & AAC_DB_SYNC_COMMAND)
			break;
		DELAY(1000);
	}
	if (i == AAC_IMMEDIATE_TIMEOUT * 1000) {
		printf("aac_sync_command: failed, reason=%#x\n", reason);
		return (EIO);
	}

	/* clear the completion flag */
	AAC_CLEAR_ISTATUS(sc, AAC_DB_SYNC_COMMAND);

	/* get the command status */
	status = AAC_GET_MAILBOX(sc, 0);

	if (sp != NULL)
		*sp = status;

	return(0);
}

/*
 * Grab the sync fib area.
 */
int
aac_alloc_sync_fib(struct aac_softc *sc, struct aac_fib **fib, int flags)
{

	/*
	 * If the force flag is set, the system is shutting down, or in
	 * trouble.  Ignore the mutex.
	 */
	if (!(flags & AAC_SYNC_LOCK_FORCE))
		AAC_LOCK_ACQUIRE(&sc->aac_sync_lock);

	*fib = &sc->aac_common->ac_sync_fib;

	return (1);
}

/*
 * Release the sync fib area.
 */
void
aac_release_sync_fib(struct aac_softc *sc)
{
	AAC_LOCK_RELEASE(&sc->aac_sync_lock);
}

/*
 * Send a synchronous FIB to the controller and wait for a result.
 */
int
aac_sync_fib(struct aac_softc *sc, u_int32_t command, u_int32_t xferstate,
	     struct aac_fib *fib, u_int16_t datasize)
{

	if (datasize > AAC_FIB_DATASIZE) {
		printf("aac_sync_fib 1: datasize=%d AAC_FIB_DATASIZE %lu\n",
		    datasize, AAC_FIB_DATASIZE);
		return(EINVAL);
	}

	/*
	 * Set up the sync FIB
	 */
	fib->Header.XferState = AAC_FIBSTATE_HOSTOWNED |
				AAC_FIBSTATE_INITIALISED |
				AAC_FIBSTATE_EMPTY;
	fib->Header.XferState |= xferstate;
	fib->Header.Command = command;
	fib->Header.StructType = AAC_FIBTYPE_TFIB;
	fib->Header.Size = sizeof(struct aac_fib) + datasize;
	fib->Header.SenderSize = sizeof(struct aac_fib);
	fib->Header.SenderFibAddress = 0;	/* Not needed */
	fib->Header.ReceiverFibAddress = sc->aac_common_busaddr +
					 offsetof(struct aac_common,
						  ac_sync_fib);

	/*
	 * Give the FIB to the controller, wait for a response.
	 */
	if (aac_sync_command(sc, AAC_MONKER_SYNCFIB,
			     fib->Header.ReceiverFibAddress, 0, 0, 0, NULL)) {
		AAC_DPRINTF(AAC_D_IO, ("%s: aac_sync_fib: IO error\n",
				       sc->aac_dev.dv_xname));
		printf("aac_sync_fib 2\n");
		return(EIO);
	}

	return (0);
}

/*****************************************************************************
 * Adapter-space FIB queue manipulation
 *
 * Note that the queue implementation here is a little funky; neither the PI or
 * CI will ever be zero.  This behaviour is a controller feature.
 */
static struct {
	int size;
	int notify;
} aac_qinfo[] = {
	{ AAC_HOST_NORM_CMD_ENTRIES, AAC_DB_COMMAND_NOT_FULL },
	{ AAC_HOST_HIGH_CMD_ENTRIES, 0 },
	{ AAC_ADAP_NORM_CMD_ENTRIES, AAC_DB_COMMAND_READY },
	{ AAC_ADAP_HIGH_CMD_ENTRIES, 0 },
	{ AAC_HOST_NORM_RESP_ENTRIES, AAC_DB_RESPONSE_NOT_FULL },
	{ AAC_HOST_HIGH_RESP_ENTRIES, 0 },
	{ AAC_ADAP_NORM_RESP_ENTRIES, AAC_DB_RESPONSE_READY },
	{ AAC_ADAP_HIGH_RESP_ENTRIES, 0 }
};

/*
 * Atomically insert an entry into the nominated queue, returns 0 on success
 * or EBUSY if the queue is full.
 *
 * Note: it would be more efficient to defer notifying the controller in
 *	 the case where we may be inserting several entries in rapid
 *	 succession, but implementing this usefully may be difficult
 *	 (it would involve a separate queue/notify interface).
 */
int
aac_enqueue_fib(struct aac_softc *sc, int queue, struct aac_command *cm)
{
	u_int32_t pi, ci;
	int error;
	u_int32_t fib_size;
	u_int32_t fib_addr;

	fib_size = cm->cm_fib->Header.Size;
	fib_addr = cm->cm_fib->Header.ReceiverFibAddress;

	/* get the producer/consumer indices */
	pi = sc->aac_queues->qt_qindex[queue][AAC_PRODUCER_INDEX];
	ci = sc->aac_queues->qt_qindex[queue][AAC_CONSUMER_INDEX];

	/* wrap the queue? */
	if (pi >= aac_qinfo[queue].size)
		pi = 0;

	/* check for queue full */
	if ((pi + 1) == ci) {
		error = EBUSY;
		goto out;
	}

	/* populate queue entry */
	(sc->aac_qentries[queue] + pi)->aq_fib_size = fib_size;
	(sc->aac_qentries[queue] + pi)->aq_fib_addr = fib_addr;

	/* update producer index */
	sc->aac_queues->qt_qindex[queue][AAC_PRODUCER_INDEX] = pi + 1;

	/*
	 * To avoid a race with its completion interrupt, place this command on
	 * the busy queue prior to advertising it to the controller.
	 */
	aac_enqueue_busy(cm);

	/* notify the adapter if we know how */
	if (aac_qinfo[queue].notify != 0)
		AAC_QNOTIFY(sc, aac_qinfo[queue].notify);

	error = 0;

out:
	return (error);
}

/*
 * Atomically remove one entry from the nominated queue, returns 0 on success
 * or ENOENT if the queue is empty.
 */
int
aac_dequeue_fib(struct aac_softc *sc, int queue, u_int32_t *fib_size,
		struct aac_fib **fib_addr)
{
	u_int32_t pi, ci;
	u_int32_t fib_index;
	int notify;
	int error;

	/* get the producer/consumer indices */
	pi = sc->aac_queues->qt_qindex[queue][AAC_PRODUCER_INDEX];
	ci = sc->aac_queues->qt_qindex[queue][AAC_CONSUMER_INDEX];

	/* check for queue empty */
	if (ci == pi) {
		error = ENOENT;
		goto out;
	}

	/* wrap the pi so the following test works */
	if (pi >= aac_qinfo[queue].size)
		pi = 0;

	notify = 0;
	if (ci == pi + 1)
		notify++;

	/* wrap the queue? */
	if (ci >= aac_qinfo[queue].size)
		ci = 0;

	/* fetch the entry */
	*fib_size = (sc->aac_qentries[queue] + ci)->aq_fib_size;

	switch (queue) {
	case AAC_HOST_NORM_CMD_QUEUE:
	case AAC_HOST_HIGH_CMD_QUEUE:
		/*
		 * The aq_fib_addr is only 32 bits wide so it can't be counted
		 * on to hold an address.  For AIF's, the adapter assumes
		 * that it's giving us an address into the array of AIF fibs.
		 * Therefore, we have to convert it to an index.
		 */
		fib_index = (sc->aac_qentries[queue] + ci)->aq_fib_addr /
			sizeof(struct aac_fib);
		*fib_addr = &sc->aac_common->ac_fibs[fib_index];
		break;

	case AAC_HOST_NORM_RESP_QUEUE:
	case AAC_HOST_HIGH_RESP_QUEUE:
	{
		struct aac_command *cm;

		/*
		 * As above, an index is used instead of an actual address.
		 * Gotta shift the index to account for the fast response
		 * bit.  No other correction is needed since this value was
		 * originally provided by the driver via the SenderFibAddress
		 * field.
		 */
		fib_index = (sc->aac_qentries[queue] + ci)->aq_fib_addr;
		cm = sc->aac_commands + (fib_index >> 1);
		*fib_addr = cm->cm_fib;

		/*
		 * Is this a fast response? If it is, update the fib fields in
		 * local memory since the whole fib isn't DMA'd back up.
		 */
		if (fib_index & 0x01) {
			(*fib_addr)->Header.XferState |= AAC_FIBSTATE_DONEADAP;
			*((u_int32_t*)((*fib_addr)->data)) = AAC_ERROR_NORMAL;
		}
		break;
	}
	default:
		panic("Invalid queue in aac_dequeue_fib()");
		break;
	}


	/* update consumer index */
	sc->aac_queues->qt_qindex[queue][AAC_CONSUMER_INDEX] = ci + 1;

	/* if we have made the queue un-full, notify the adapter */
	if (notify && (aac_qinfo[queue].notify != 0))
		AAC_QNOTIFY(sc, aac_qinfo[queue].notify);
	error = 0;

out:
	return (error);
}

/*
 * Put our response to an Adapter Initialed Fib on the response queue
 */
int
aac_enqueue_response(struct aac_softc *sc, int queue, struct aac_fib *fib)
{
	u_int32_t pi, ci;
	int error;
	u_int32_t fib_size;
	u_int32_t fib_addr;

	/* Tell the adapter where the FIB is */
	fib_size = fib->Header.Size;
	fib_addr = fib->Header.SenderFibAddress;
	fib->Header.ReceiverFibAddress = fib_addr;

	/* get the producer/consumer indices */
	pi = sc->aac_queues->qt_qindex[queue][AAC_PRODUCER_INDEX];
	ci = sc->aac_queues->qt_qindex[queue][AAC_CONSUMER_INDEX];

	/* wrap the queue? */
	if (pi >= aac_qinfo[queue].size)
		pi = 0;

	/* check for queue full */
	if ((pi + 1) == ci) {
		error = EBUSY;
		goto out;
	}

	/* populate queue entry */
	(sc->aac_qentries[queue] + pi)->aq_fib_size = fib_size;
	(sc->aac_qentries[queue] + pi)->aq_fib_addr = fib_addr;

	/* update producer index */
	sc->aac_queues->qt_qindex[queue][AAC_PRODUCER_INDEX] = pi + 1;

	/* notify the adapter if we know how */
	if (aac_qinfo[queue].notify != 0)
		AAC_QNOTIFY(sc, aac_qinfo[queue].notify);

	error = 0;

out:
	return(error);
}

void
aac_command_timeout(struct aac_command *cm)
{
	struct aac_softc *sc = cm->cm_sc;

	printf("%s: COMMAND %p (flags=%#x) TIMEOUT AFTER %d SECONDS\n",
	       sc->aac_dev.dv_xname, cm, cm->cm_flags,
	       (int)(time_uptime - cm->cm_timestamp));

	if (cm->cm_flags & AAC_CMD_TIMEDOUT)
		return;

	cm->cm_flags |= AAC_CMD_TIMEDOUT;

	AAC_PRINT_FIB(sc, cm->cm_fib);

	if (cm->cm_flags & AAC_ON_AACQ_BIO) {
		struct scsi_xfer *xs = cm->cm_private;
		int s = splbio();
		xs->error = XS_DRIVER_STUFFUP;
		splx(s);
		scsi_done(xs);

		aac_remove_bio(cm);
		aac_unmap_command(cm);
	}
}

void
aac_timeout(struct aac_softc *sc)
{
	struct aac_command *cm;
	time_t deadline;

	/*
	 * Traverse the busy command list and timeout any commands
	 * that are past their deadline.
	 */
	deadline = time_uptime - AAC_CMD_TIMEOUT;
	TAILQ_FOREACH(cm, &sc->aac_busy, cm_link) {
		if (cm->cm_timestamp  < deadline)
			aac_command_timeout(cm);
	}
}

/*
 * Interface Function Vectors
 */

/*
 * Read the current firmware status word.
 */
int
aac_sa_get_fwstatus(struct aac_softc *sc)
{
	return (AAC_GETREG4(sc, AAC_SA_FWSTATUS));
}

int
aac_rx_get_fwstatus(struct aac_softc *sc)
{
	return (AAC_GETREG4(sc, AAC_RX_FWSTATUS));
}

int
aac_fa_get_fwstatus(struct aac_softc *sc)
{
	return (AAC_GETREG4(sc, AAC_FA_FWSTATUS));
}

int
aac_rkt_get_fwstatus(struct aac_softc *sc)
{
	return(AAC_GETREG4(sc, AAC_RKT_FWSTATUS));
}

/*
 * Notify the controller of a change in a given queue
 */

void
aac_sa_qnotify(struct aac_softc *sc, int qbit)
{
	AAC_SETREG2(sc, AAC_SA_DOORBELL1_SET, qbit);
}

void
aac_rx_qnotify(struct aac_softc *sc, int qbit)
{
	AAC_SETREG4(sc, AAC_RX_IDBR, qbit);
}

void
aac_fa_qnotify(struct aac_softc *sc, int qbit)
{
	AAC_SETREG2(sc, AAC_FA_DOORBELL1, qbit);
	AAC_FA_HACK(sc);
}

void
aac_rkt_qnotify(struct aac_softc *sc, int qbit)
{
	AAC_SETREG4(sc, AAC_RKT_IDBR, qbit);
}

/*
 * Get the interrupt reason bits
 */
int
aac_sa_get_istatus(struct aac_softc *sc)
{
	return (AAC_GETREG2(sc, AAC_SA_DOORBELL0));
}

int
aac_rx_get_istatus(struct aac_softc *sc)
{
	return (AAC_GETREG4(sc, AAC_RX_ODBR));
}

int
aac_fa_get_istatus(struct aac_softc *sc)
{
	return (AAC_GETREG2(sc, AAC_FA_DOORBELL0));
}

int
aac_rkt_get_istatus(struct aac_softc *sc)
{
	return(AAC_GETREG4(sc, AAC_RKT_ODBR));
}

/*
 * Clear some interrupt reason bits
 */
void
aac_sa_clear_istatus(struct aac_softc *sc, int mask)
{
	AAC_SETREG2(sc, AAC_SA_DOORBELL0_CLEAR, mask);
}

void
aac_rx_clear_istatus(struct aac_softc *sc, int mask)
{
	AAC_SETREG4(sc, AAC_RX_ODBR, mask);
}

void
aac_fa_clear_istatus(struct aac_softc *sc, int mask)
{
	AAC_SETREG2(sc, AAC_FA_DOORBELL0_CLEAR, mask);
	AAC_FA_HACK(sc);
}

void
aac_rkt_clear_istatus(struct aac_softc *sc, int mask)
{
	AAC_SETREG4(sc, AAC_RKT_ODBR, mask);
}

/*
 * Populate the mailbox and set the command word
 */
void
aac_sa_set_mailbox(struct aac_softc *sc, u_int32_t command, u_int32_t arg0,
		   u_int32_t arg1, u_int32_t arg2, u_int32_t arg3)
{
	AAC_SETREG4(sc, AAC_SA_MAILBOX, command);
	AAC_SETREG4(sc, AAC_SA_MAILBOX + 4, arg0);
	AAC_SETREG4(sc, AAC_SA_MAILBOX + 8, arg1);
	AAC_SETREG4(sc, AAC_SA_MAILBOX + 12, arg2);
	AAC_SETREG4(sc, AAC_SA_MAILBOX + 16, arg3);
}

void
aac_rx_set_mailbox(struct aac_softc *sc, u_int32_t command, u_int32_t arg0,
		   u_int32_t arg1, u_int32_t arg2, u_int32_t arg3)
{
	AAC_SETREG4(sc, AAC_RX_MAILBOX, command);
	AAC_SETREG4(sc, AAC_RX_MAILBOX + 4, arg0);
	AAC_SETREG4(sc, AAC_RX_MAILBOX + 8, arg1);
	AAC_SETREG4(sc, AAC_RX_MAILBOX + 12, arg2);
	AAC_SETREG4(sc, AAC_RX_MAILBOX + 16, arg3);
}

void
aac_fa_set_mailbox(struct aac_softc *sc, u_int32_t command, u_int32_t arg0,
		   u_int32_t arg1, u_int32_t arg2, u_int32_t arg3)
{
	AAC_SETREG4(sc, AAC_FA_MAILBOX, command);
	AAC_FA_HACK(sc);
	AAC_SETREG4(sc, AAC_FA_MAILBOX + 4, arg0);
	AAC_FA_HACK(sc);
	AAC_SETREG4(sc, AAC_FA_MAILBOX + 8, arg1);
	AAC_FA_HACK(sc);
	AAC_SETREG4(sc, AAC_FA_MAILBOX + 12, arg2);
	AAC_FA_HACK(sc);
	AAC_SETREG4(sc, AAC_FA_MAILBOX + 16, arg3);
	AAC_FA_HACK(sc);
}

void
aac_rkt_set_mailbox(struct aac_softc *sc, u_int32_t command, u_int32_t arg0,
		    u_int32_t arg1, u_int32_t arg2, u_int32_t arg3)
{
	AAC_SETREG4(sc, AAC_RKT_MAILBOX, command);
	AAC_SETREG4(sc, AAC_RKT_MAILBOX + 4, arg0);
	AAC_SETREG4(sc, AAC_RKT_MAILBOX + 8, arg1);
	AAC_SETREG4(sc, AAC_RKT_MAILBOX + 12, arg2);
	AAC_SETREG4(sc, AAC_RKT_MAILBOX + 16, arg3);
}

/*
 * Fetch the immediate command status word
 */
int
aac_sa_get_mailbox(struct aac_softc *sc, int mb)
{
	return (AAC_GETREG4(sc, AAC_SA_MAILBOX + (mb * 4)));
}

int
aac_rx_get_mailbox(struct aac_softc *sc, int mb)
{
	return (AAC_GETREG4(sc, AAC_RX_MAILBOX + (mb * 4)));
}

int
aac_fa_get_mailbox(struct aac_softc *sc, int mb)
{
	return (AAC_GETREG4(sc, AAC_FA_MAILBOX + (mb * 4)));
}

int
aac_rkt_get_mailbox(struct aac_softc *sc, int mb)
{
	return(AAC_GETREG4(sc, AAC_RKT_MAILBOX + (mb * 4)));
}

/*
 * Set/clear interrupt masks
 */
void
aac_sa_set_interrupts(struct aac_softc *sc, int enable)
{
	AAC_DPRINTF(AAC_D_INTR, ("%s: %sable interrupts\n",
				 sc->aac_dev.dv_xname, enable ? "en" : "dis"));

	if (enable)
		AAC_SETREG2((sc), AAC_SA_MASK0_CLEAR, AAC_DB_INTERRUPTS);
	else
		AAC_SETREG2((sc), AAC_SA_MASK0_SET, ~0);
}

void
aac_rx_set_interrupts(struct aac_softc *sc, int enable)
{
	AAC_DPRINTF(AAC_D_INTR, ("%s: %sable interrupts",
				 sc->aac_dev.dv_xname, enable ? "en" : "dis"));

	if (enable)
		AAC_SETREG4(sc, AAC_RX_OIMR, ~AAC_DB_INTERRUPTS);
	else
		AAC_SETREG4(sc, AAC_RX_OIMR, ~0);
}

void
aac_fa_set_interrupts(struct aac_softc *sc, int enable)
{
	AAC_DPRINTF(AAC_D_INTR, ("%s: %sable interrupts",
				 sc->aac_dev.dv_xname, enable ? "en" : "dis"));

	if (enable) {
		AAC_SETREG2((sc), AAC_FA_MASK0_CLEAR, AAC_DB_INTERRUPTS);
		AAC_FA_HACK(sc);
	} else {
		AAC_SETREG2((sc), AAC_FA_MASK0, ~0);
		AAC_FA_HACK(sc);
	}
}

void
aac_rkt_set_interrupts(struct aac_softc *sc, int enable)
{
	AAC_DPRINTF(AAC_D_INTR, ("%s: %sable interrupts",
				 sc->aac_dev.dv_xname, enable ? "en" : "dis"));

	if (enable)
		AAC_SETREG4(sc, AAC_RKT_OIMR, ~AAC_DB_INTERRUPTS);
	else
		AAC_SETREG4(sc, AAC_RKT_OIMR, ~0);
}

void
aac_eval_mapping(size, cyls, heads, secs)
	u_int32_t size;
	int *cyls, *heads, *secs;
{
	*cyls = size / AAC_HEADS / AAC_SECS;
	if (*cyls < AAC_MAXCYLS) {
		*heads = AAC_HEADS;
		*secs = AAC_SECS;
	} else {
		/* Too high for 64 * 32 */
		*cyls = size / AAC_MEDHEADS / AAC_MEDSECS;
		if (*cyls < AAC_MAXCYLS) {
			*heads = AAC_MEDHEADS;
			*secs = AAC_MEDSECS;
		} else {
			/* Too high for 127 * 63 */
			*cyls = size / AAC_BIGHEADS / AAC_BIGSECS;
			*heads = AAC_BIGHEADS;
			*secs = AAC_BIGSECS;
		}
	}
}

void
aac_copy_internal_data(struct scsi_xfer *xs, u_int8_t *data, size_t size)
{
	struct aac_softc *sc = xs->sc_link->adapter_softc;
	size_t copy_cnt;

	AAC_DPRINTF(AAC_D_MISC, ("%s: aac_copy_internal_data\n",
				 sc->aac_dev.dv_xname));

	if (!xs->datalen)
		printf("%s: uio move not yet supported\n",
		       sc->aac_dev.dv_xname);
	else {
		copy_cnt = MIN(size, xs->datalen);
		bcopy(data, xs->data, copy_cnt);
	}
}

/* Emulated SCSI operation on cache device */
void
aac_internal_cache_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct aac_softc *sc = link->adapter_softc;
	struct scsi_inquiry_data inq;
	struct scsi_sense_data sd;
	struct scsi_read_cap_data rcd;
	u_int8_t target = link->target;

	AAC_DPRINTF(AAC_D_CMD, ("aac_internal_cache_cmd: ",
				sc->aac_dev.dv_xname));

	switch (xs->cmd->opcode) {
	case TEST_UNIT_READY:
	case START_STOP:
#if 0
	case VERIFY:
#endif
		AAC_DPRINTF(AAC_D_CMD, ("opc %#x tgt %d ", xs->cmd->opcode,
		    target));
		break;

	case REQUEST_SENSE:
		AAC_DPRINTF(AAC_D_CMD, ("REQUEST SENSE tgt %d ", target));
		bzero(&sd, sizeof sd);
		sd.error_code = SSD_ERRCODE_CURRENT;
		sd.segment = 0;
		sd.flags = SKEY_NO_SENSE;
		aac_enc32(sd.info, 0);
		sd.extra_len = 0;
		aac_copy_internal_data(xs, (u_int8_t *)&sd, sizeof sd);
		break;

	case INQUIRY:
		AAC_DPRINTF(AAC_D_CMD, ("INQUIRY tgt %d devtype %x ", target,
		    sc->aac_hdr[target].hd_devtype));
		bzero(&inq, sizeof inq);
		/* XXX How do we detect removable/CD-ROM devices?  */
		inq.device = T_DIRECT;
		inq.dev_qual2 = 0;
		inq.version = 2;
		inq.response_format = 2;
		inq.additional_length = 32;
		inq.flags |= SID_CmdQue;
		strlcpy(inq.vendor, "Adaptec", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Container #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
		aac_copy_internal_data(xs, (u_int8_t *)&inq, sizeof inq);
		break;

	case READ_CAPACITY:
		AAC_DPRINTF(AAC_D_CMD, ("READ CAPACITY tgt %d ", target));
		bzero(&rcd, sizeof rcd);
		_lto4b(sc->aac_hdr[target].hd_size - 1, rcd.addr);
		_lto4b(AAC_BLOCK_SIZE, rcd.length);
		aac_copy_internal_data(xs, (u_int8_t *)&rcd, sizeof rcd);
		break;

	default:
		AAC_DPRINTF(AAC_D_CMD, ("\n"));
		printf("aac_internal_cache_cmd got bad opcode: %#x\n",
		    xs->cmd->opcode);
		xs->error = XS_DRIVER_STUFFUP;
		return;
	}

	xs->error = XS_NOERROR;
}

void
aac_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct aac_softc *sc = link->adapter_softc;
	u_int8_t target = link->target;
	struct aac_command *cm;
	u_int32_t blockno, blockcnt;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	int s;

	s = splbio();

	xs->error = XS_NOERROR;

	if (target >= AAC_MAX_CONTAINERS || !sc->aac_hdr[target].hd_present ||
	    link->lun != 0) {
		/*
		 * XXX Should be XS_SENSE but that would require setting up a
		 * faked sense too.
		 */
		splx(s);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	AAC_DPRINTF(AAC_D_CMD, ("%s: aac_scsi_cmd: ", sc->aac_dev.dv_xname));

	xs->error = XS_NOERROR;
	cm = NULL;
	link = xs->sc_link;
	target = link->target;

	switch (xs->cmd->opcode) {
	case TEST_UNIT_READY:
	case REQUEST_SENSE:
	case INQUIRY:
	case START_STOP:
	case READ_CAPACITY:
#if 0
	case VERIFY:
#endif
		aac_internal_cache_cmd(xs);
		scsi_done(xs);
		goto ready;

	case PREVENT_ALLOW:
		AAC_DPRINTF(AAC_D_CMD, ("PREVENT/ALLOW "));
		/* XXX Not yet implemented */
		xs->error = XS_NOERROR;
		scsi_done(xs);
		goto ready;

	case SYNCHRONIZE_CACHE:
		AAC_DPRINTF(AAC_D_CMD, ("SYNCHRONIZE_CACHE "));
		/* XXX Not yet implemented */
		xs->error = XS_NOERROR;
		scsi_done(xs);
		goto ready;

	default:
		AAC_DPRINTF(AAC_D_CMD, ("unknown opc %#x ", xs->cmd->opcode));
		/* XXX Not yet implemented */
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		goto ready;

	case READ_COMMAND:
	case READ_BIG:
	case WRITE_COMMAND:
	case WRITE_BIG:
		AAC_DPRINTF(AAC_D_CMD, ("rw opc %#x ", xs->cmd->opcode));

		/* A read or write operation. */
		if (xs->cmdlen == 6) {
			rw = (struct scsi_rw *)xs->cmd;
			blockno = _3btol(rw->addr) &
				(SRW_TOPADDR << 16 | 0xffff);
			blockcnt = rw->length ? rw->length : 0x100;
		} else {
			rwb = (struct scsi_rw_big *)xs->cmd;
			blockno = _4btol(rwb->addr);
			blockcnt = _2btol(rwb->length);
		}

		AAC_DPRINTF(AAC_D_CMD, ("blkno=%d bcount=%d ",
					xs->cmd->opcode, blockno, blockcnt));

		if (blockno >= sc->aac_hdr[target].hd_size ||
		    blockno + blockcnt > sc->aac_hdr[target].hd_size) {
			AAC_DPRINTF(AAC_D_CMD, ("\n"));
			printf("%s: out of bounds %u-%u >= %u\n",
			       sc->aac_dev.dv_xname, blockno,
			       blockcnt, sc->aac_hdr[target].hd_size);
			/*
			 * XXX Should be XS_SENSE but that
			 * would require setting up a faked
			 * sense too.
			 */
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			goto ready;
		}

		cm = xs->io;
		aac_scrub_command(cm);

		/* fill out the command */
		cm->cm_data = (void *)xs->data;
		cm->cm_datalen = xs->datalen;
		cm->cm_complete = aac_bio_complete;
		cm->cm_private = xs;
		cm->cm_timestamp = time_uptime;
		cm->cm_queue = AAC_ADAP_NORM_CMD_QUEUE;
		cm->cm_blkno = blockno;
		cm->cm_bcount = blockcnt;

		AAC_DPRINTF(AAC_D_CMD, ("\n"));
		aac_enqueue_bio(cm);
		aac_startio(sc);

		/* XXX what if enqueue did not start a transfer? */
		if (xs->flags & SCSI_POLL) {
			if (!aac_wait_command(cm, xs->timeout))
			{
				printf("%s: command timed out\n",
				       sc->aac_dev.dv_xname);
				xs->error = XS_DRIVER_STUFFUP;
				scsi_done(xs);
				splx(s);
				return;
			}
			scsi_done(xs);
		}
	}

 ready:
	splx(s);
	AAC_DPRINTF(AAC_D_CMD, ("%s: scsi_cmd complete\n",
				sc->aac_dev.dv_xname));
}

/*
 * Debugging and Diagnostics
 */

/*
 * Print some information about the controller.
 */
void
aac_describe_controller(struct aac_softc *sc)
{
	struct aac_fib *fib;
	struct aac_adapter_info	*info;

	aac_alloc_sync_fib(sc, &fib, 0);

	fib->data[0] = 0;
	if (aac_sync_fib(sc, RequestAdapterInfo, 0, fib, 1)) {
		printf("%s: RequestAdapterInfo failed 2\n",
		       sc->aac_dev.dv_xname);
		aac_release_sync_fib(sc);
		return;
	}
	info = (struct aac_adapter_info *)&fib->data[0];

	printf("%s: %s %dMHz, %dMB cache memory, %s\n", sc->aac_dev.dv_xname,
	       aac_describe_code(aac_cpu_variant, info->CpuVariant),
	       info->ClockSpeed, info->BufferMem / (1024 * 1024),
	       aac_describe_code(aac_battery_platform, info->batteryPlatform));

	/* save the kernel revision structure for later use */
	sc->aac_revision = info->KernelRevision;
	printf("%s: Kernel %d.%d-%d, Build %d, S/N %6X\n",
	       sc->aac_dev.dv_xname,
	       info->KernelRevision.external.comp.major,
	       info->KernelRevision.external.comp.minor,
	       info->KernelRevision.external.comp.dash,
	       info->KernelRevision.buildNumber,
	       (u_int32_t)(info->SerialNumber & 0xffffff));

	aac_release_sync_fib(sc);
}

/*
 * Look up a text description of a numeric error code and return a pointer to
 * same.
 */
char *
aac_describe_code(struct aac_code_lookup *table, u_int32_t code)
{
	int i;

	for (i = 0; table[i].string != NULL; i++)
		if (table[i].code == code)
			return(table[i].string);
	return(table[i + 1].string);
}

#ifdef AAC_DEBUG
/*
 * Print a FIB
 */
void
aac_print_fib(struct aac_softc *sc, struct aac_fib *fib, const char *caller)
{
	printf("%s: FIB @@ %p\n", caller, fib);
	printf("  XferState %b\n", fib->Header.XferState, "\20"
	    "\1HOSTOWNED"
	    "\2ADAPTEROWNED"
	    "\3INITIALISED"
	    "\4EMPTY"
	    "\5FROMPOOL"
	    "\6FROMHOST"
	    "\7FROMADAP"
	    "\10REXPECTED"
	    "\11RNOTEXPECTED"
	    "\12DONEADAP"
	    "\13DONEHOST"
	    "\14HIGH"
	    "\15NORM"
	    "\16ASYNC"
	    "\17PAGEFILEIO"
	    "\20SHUTDOWN"
	    "\21LAZYWRITE"
	    "\22ADAPMICROFIB"
	    "\23BIOSFIB"
	    "\24FAST_RESPONSE"
	    "\25APIFIB\n");
	printf("  Command         %d\n", fib->Header.Command);
	printf("  StructType      %d\n", fib->Header.StructType);
	printf("  Flags           0x%x\n", fib->Header.Flags);
	printf("  Size            %d\n", fib->Header.Size);
	printf("  SenderSize      %d\n", fib->Header.SenderSize);
	printf("  SenderAddress   0x%x\n", fib->Header.SenderFibAddress);
	printf("  ReceiverAddress 0x%x\n", fib->Header.ReceiverFibAddress);
	printf("  SenderData      0x%x\n", fib->Header.SenderData);
	switch(fib->Header.Command) {
	case ContainerCommand: {
		struct aac_blockread *br = (struct aac_blockread *)fib->data;
		struct aac_blockwrite *bw = (struct aac_blockwrite *)fib->data;
		struct aac_sg_table *sg = NULL;
		int i;

		if (br->Command == VM_CtBlockRead) {
			printf("  BlockRead: container %d  0x%x/%d\n",
			    br->ContainerId, br->BlockNumber, br->ByteCount);
			    sg = &br->SgMap;
		}
		if (bw->Command == VM_CtBlockWrite) {
			printf("  BlockWrite: container %d  0x%x/%d (%s)\n",
			    bw->ContainerId, bw->BlockNumber, bw->ByteCount,
			    bw->Stable == CSTABLE ? "stable" : "unstable");
			sg = &bw->SgMap;
		}
		if (sg != NULL) {
			printf("  %d s/g entries\n", sg->SgCount);
			for (i = 0; i < sg->SgCount; i++)
				printf("  0x%08x/%d\n",
				       sg->SgEntry[i].SgAddress,
				       sg->SgEntry[i].SgByteCount);
		}
		break;
	}
	default:
		printf("   %16D\n", fib->data, " ");
		printf("   %16D\n", fib->data + 16, " ");
	break;
	}
}

/*
 * Describe an AIF we have received.
 */
void
aac_print_aif(struct aac_softc *sc, struct aac_aif_command *aif)
{
	printf("%s: print_aif: ", sc->aac_dev.dv_xname);

	switch(aif->command) {
	case AifCmdEventNotify:
		printf("EventNotify(%d)\n", aif->seqNumber);

		switch(aif->data.EN.type) {
		case AifEnGeneric:
			/* Generic notification */
			printf("\t(Generic) %.*s\n",
			       (int)sizeof(aif->data.EN.data.EG),
			       aif->data.EN.data.EG.text);
			break;
		case AifEnTaskComplete:
			/* Task has completed */
			printf("\t(TaskComplete)\n");
			break;
		case AifEnConfigChange:
			/* Adapter configuration change occurred */
			printf("\t(ConfigChange)\n");
			break;
		case AifEnContainerChange:
			/* Adapter specific container configuration change */
			printf("\t(ContainerChange) container %d,%d\n",
			       aif->data.EN.data.ECC.container[0],
			       aif->data.EN.data.ECC.container[1]);
			break;
		case AifEnDeviceFailure:
			/* SCSI device failed */
			printf("\t(DeviceFailure) handle %d\n",
			       aif->data.EN.data.EDF.deviceHandle);
			break;
		case AifEnMirrorFailover:
			/* Mirror failover started */
			printf("\t(MirrorFailover) container %d failed, "
			       "migrating from slice %d to %d\n",
			       aif->data.EN.data.EMF.container,
			       aif->data.EN.data.EMF.failedSlice,
			       aif->data.EN.data.EMF.creatingSlice);
			break;
		case AifEnContainerEvent:
			/* Significant container event */
			printf("\t(ContainerEvent) container %d event %d\n",
			       aif->data.EN.data.ECE.container,
			       aif->data.EN.data.ECE.eventType);
			break;
		case AifEnFileSystemChange:
			/* File system changed */
			printf("\t(FileSystemChange)\n");
			break;
		case AifEnConfigPause:
			/* Container pause event */
			printf("\t(ConfigPause)\n");
			break;
		case AifEnConfigResume:
			/* Container resume event */
			printf("\t(ConfigResume)\n");
			break;
		case AifEnFailoverChange:
			/* Failover space assignment changed */
			printf("\t(FailoverChange)\n");
			break;
		case AifEnRAID5RebuildDone:
			/* RAID5 rebuild finished */
			printf("\t(RAID5RebuildDone)\n");
			break;
		case AifEnEnclosureManagement:
			/* Enclosure management event */
			printf("\t(EnclosureManagement) EMPID %d unit %d "
			       "event %d\n",
			       aif->data.EN.data.EEE.empID,
			       aif->data.EN.data.EEE.unitID,
			       aif->data.EN.data.EEE.eventType);
			break;
		case AifEnBatteryEvent:
			/* Significant NV battery event */
			printf("\t(BatteryEvent) %d (state was %d, is %d\n",
			       aif->data.EN.data.EBE.transition_type,
			       aif->data.EN.data.EBE.current_state,
			       aif->data.EN.data.EBE.prior_state);
			break;
		case AifEnAddContainer:
			/* A new container was created. */
			printf("\t(AddContainer)\n");
			break;
		case AifEnDeleteContainer:
			/* A container was deleted. */
			printf("\t(DeleteContainer)\n");
			break;
		case AifEnBatteryNeedsRecond:
			/* The battery needs reconditioning */
			printf("\t(BatteryNeedsRecond)\n");
			break;
		case AifEnClusterEvent:
			/* Some cluster event */
			printf("\t(ClusterEvent) event %d\n",
			       aif->data.EN.data.ECLE.eventType);
			break;
		case AifEnDiskSetEvent:
			/* A disk set event occured. */
			printf("(DiskSetEvent) event %d "
			       "diskset %lld creator %lld\n",
			       aif->data.EN.data.EDS.eventType,
			       aif->data.EN.data.EDS.DsNum,
			       aif->data.EN.data.EDS.CreatorId);
			break;
		case AifDenMorphComplete:
			/* A morph operation completed */
			printf("\t(MorphComplete)\n");
			break;
		case AifDenVolumeExtendComplete:
			/* A volume expand operation completed */
			printf("\t(VolumeExtendComplete)\n");
			break;
		default:
			printf("\t(%d)\n", aif->data.EN.type);
			break;
		}
		break;
	case AifCmdJobProgress:
	{
		char	*status;
		switch(aif->data.PR[0].status) {
		case AifJobStsSuccess:
			status = "success"; break;
		case AifJobStsFinished:
			status = "finished"; break;
		case AifJobStsAborted:
			status = "aborted"; break;
		case AifJobStsFailed:
			status = "failed"; break;
		case AifJobStsSuspended:
			status = "suspended"; break;
		case AifJobStsRunning:
			status = "running"; break;
		default:
			status = "unknown status"; break;
		}

		printf("JobProgress (%d) - %s (%d, %d)\n",
		       aif->seqNumber, status,
		       aif->data.PR[0].currentTick,
		       aif->data.PR[0].finalTick);

		switch(aif->data.PR[0].jd.type) {
		case AifJobScsiZero:
			/* SCSI dev clear operation */
			printf("\t(ScsiZero) handle %d\n",
				      aif->data.PR[0].jd.client.scsi_dh);
			break;
		case AifJobScsiVerify:
			/* SCSI device Verify operation NO REPAIR */
			printf("\t(ScsiVerify) handle %d\n",
				      aif->data.PR[0].jd.client.scsi_dh);
			break;
		case AifJobScsiExercise:
			/* SCSI device Exercise operation */
			printf("\t(ScsiExercise) handle %d\n",
			       aif->data.PR[0].jd.client.scsi_dh);
			break;
		case AifJobScsiVerifyRepair:
			/* SCSI device Verify operation WITH repair */
			printf("\t(ScsiVerifyRepair) handle %d\n",
			       aif->data.PR[0].jd.client.scsi_dh);
			break;
		case AifJobCtrZero:
			/* Container clear operation */
			printf("\t(ContainerZero) container %d\n",
			       aif->data.PR[0].jd.client.container.src);
			break;
		case AifJobCtrCopy:
			/* Container copy operation */
			printf("\t(ContainerCopy) container %d to %d\n",
			       aif->data.PR[0].jd.client.container.src,
			       aif->data.PR[0].jd.client.container.dst);
			break;
		case AifJobCtrCreateMirror:
			/* Container Create Mirror operation */
			printf("\t(ContainerCreateMirror) container %d\n",
			       aif->data.PR[0].jd.client.container.src);
			/* XXX two containers? */
			break;
		case AifJobCtrMergeMirror:
			/* Container Merge Mirror operation */
			printf("\t(ContainerMergeMirror) container %d\n",
			       aif->data.PR[0].jd.client.container.src);
			/* XXX two containers? */
			break;
		case AifJobCtrScrubMirror:
			/* Container Scrub Mirror operation */
			printf("\t(ContainerScrubMirror) container %d\n",
			       aif->data.PR[0].jd.client.container.src);
			break;
		case AifJobCtrRebuildRaid5:
			/* Container Rebuild Raid5 operation */
			printf("\t(ContainerRebuildRaid5) container %d\n",
			       aif->data.PR[0].jd.client.container.src);
			break;
		case AifJobCtrScrubRaid5:
			/* Container Scrub Raid5 operation */
			printf("\t(ContainerScrubRaid5) container %d\n",
			       aif->data.PR[0].jd.client.container.src);
			break;
		case AifJobCtrMorph:
			/* Container morph operation */
			printf("\t(ContainerMorph) container %d\n",
			       aif->data.PR[0].jd.client.container.src);
			/* XXX two containers? */
			break;
		case AifJobCtrPartCopy:
			/* Container Partition copy operation */
			printf("\t(ContainerPartCopy) container %d to %d\n",
			       aif->data.PR[0].jd.client.container.src,
			       aif->data.PR[0].jd.client.container.dst);
			break;
		case AifJobCtrRebuildMirror:
			/* Container Rebuild Mirror operation */
			printf("\t(ContainerRebuildMirror) container %d\n",
			       aif->data.PR[0].jd.client.container.src);
			break;
		case AifJobCtrCrazyCache:
			/* crazy cache */
			printf("\t(ContainerCrazyCache) container %d\n",
			       aif->data.PR[0].jd.client.container.src);
			/* XXX two containers? */
			break;
		case AifJobFsCreate:
			/* File System Create operation */
			printf("\t(FsCreate)\n");
			break;
		case AifJobFsVerify:
			/* File System Verify operation */
			printf("\t(FsVerivy)\n");
			break;
		case AifJobFsExtend:
			/* File System Extend operation */
			printf("\t(FsExtend)\n");
			break;
		case AifJobApiFormatNTFS:
			/* Format a drive to NTFS */
			printf("\t(FormatNTFS)\n");
			break;
		case AifJobApiFormatFAT:
			/* Format a drive to FAT */
			printf("\t(FormatFAT)\n");
			break;
		case AifJobApiUpdateSnapshot:
			/* update the read/write half of a snapshot */
			printf("\t(UpdateSnapshot)\n");
			break;
		case AifJobApiFormatFAT32:
			/* Format a drive to FAT32 */
			printf("\t(FormatFAT32)\n");
			break;
		case AifJobCtlContinuousCtrVerify:
			/* Adapter operation */
			printf("\t(ContinuousCtrVerify)\n");
			break;
		default:
			printf("\t(%d)\n", aif->data.PR[0].jd.type);
			break;
		}
		break;
	}
	case AifCmdAPIReport:
		printf("APIReport (%d)\n", aif->seqNumber);
		break;
	case AifCmdDriverNotify:
		printf("DriverNotify (%d)\n", aif->seqNumber);
		break;
	default:
		printf("AIF %d (%d)\n", aif->command, aif->seqNumber);
		break;
	}
}
#endif
@


1.69
log
@Convert some malloc(9) to mallocarray(9)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.68 2017/04/08 02:57:24 deraadt Exp $	*/
d1280 1
a1280 1
	sc->aac_commands = mallocarray(AAC_MAX_FIBS, sizeof(struct aac_command),
@


1.68
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.67 2016/03/27 11:06:19 mpi Exp $	*/
d1280 1
a1280 1
	sc->aac_commands = malloc(AAC_MAX_FIBS * sizeof(struct aac_command),
@


1.67
log
@Kill async code commented out for more than 10 years.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.66 2015/05/02 18:13:42 krw Exp $	*/
d999 1
a999 1
	free(fm, M_DEVBUF, 0);
d1033 1
a1033 1
		free(fm, M_DEVBUF, 0);
@


1.66
log
@Die, damned distracting red space.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.65 2014/07/31 18:14:46 jasper Exp $	*/
a124 2
void	aac_add_container(struct aac_softc *, struct aac_mntinforesp *, int);
void	aac_shutdown(void *);
a345 3
#if 0
		aac_add_container(sc, mir, 0);
#else
a380 1
#endif
a386 8
#if 0
	/* poke the bus to actually attach the child devices */
	if (bus_generic_attach(sc->aac_dev))
		printf("%s: bus_generic_attach failed\n",
		       sc->aac_dev.dv_xname);
#endif


a393 251
#if 0
/*
 * Create a device to respresent a new container
 */
void
aac_add_container(struct aac_softc *sc, struct aac_mntinforesp *mir, int f)
{
	struct aac_container *co;
	device_t child;

	/* 
	 * Check container volume type for validity.  Note that many of
	 * the possible types may never show up.
	 */
	if ((mir->Status == ST_OK) && (mir->MntTable[0].VolType != CT_NONE)) {
		co = (struct aac_container *)malloc(sizeof *co, M_DEVBUF,
		       M_NOWAIT);
		if (co == NULL)
			panic("Out of memory?!");
		bzero(co, sizeof *co);
		AAC_DPRINTF(AAC_D_MISC,
			    ("%s: id %x  name '%.16s'  size %u  type %d\n", 
			     sc->aac_dev.dv_xname,
			     mir->MntTable[0].ObjectId,
			     mir->MntTable[0].FileSystemName,
			     mir->MntTable[0].Capacity,
			     mir->MntTable[0].VolType);
	
		if ((child = device_add_child(sc->aac_dev, "aacd", -1)) == NULL)
			printf("%s: device_add_child failed\n",
			       sc->aac_dev.dv_xname);
		else
			device_set_ivars(child, co);
		device_set_desc(child, aac_describe_code(aac_container_types,
				mir->MntTable[0].VolType));
		co->co_disk = child;
		co->co_found = f;
		bcopy(&mir->MntTable[0], &co->co_mntobj,
		      sizeof(struct aac_mntobj));
		AAC_LOCK_ACQUIRE(&sc->aac_container_lock);
		TAILQ_INSERT_TAIL(&sc->aac_container_tqh, co, co_link);
		AAC_LOCK_RELEASE(&sc->aac_container_lock);
	}
}
#endif

#if 0
/*
 * Free all of the resources associated with (sc)
 *
 * Should not be called if the controller is active.
 */
void
aac_free(struct aac_softc *sc)
{

	debug_called(1);

	/* remove the control device */
	if (sc->aac_dev_t != NULL)
		destroy_dev(sc->aac_dev_t);

	/* throw away any FIB buffers, discard the FIB DMA tag */
	aac_free_commands(sc);
	if (sc->aac_fib_dmat)
		bus_dma_tag_destroy(sc->aac_fib_dmat);

	free(sc->aac_commands, M_AACBUF, 0);

	/* destroy the common area */
	if (sc->aac_common) {
		bus_dmamap_unload(sc->aac_common_dmat, sc->aac_common_dmamap);
		bus_dmamem_free(sc->aac_common_dmat, sc->aac_common,
				sc->aac_common_dmamap);
	}
	if (sc->aac_common_dmat)
		bus_dma_tag_destroy(sc->aac_common_dmat);

	/* disconnect the interrupt handler */
	if (sc->aac_intr)
		bus_teardown_intr(sc->aac_dev, sc->aac_irq, sc->aac_intr);
	if (sc->aac_irq != NULL)
		bus_release_resource(sc->aac_dev, SYS_RES_IRQ, sc->aac_irq_rid,
				     sc->aac_irq);

	/* destroy data-transfer DMA tag */
	if (sc->aac_buffer_dmat)
		bus_dma_tag_destroy(sc->aac_buffer_dmat);

	/* destroy the parent DMA tag */
	if (sc->aac_parent_dmat)
		bus_dma_tag_destroy(sc->aac_parent_dmat);

	/* release the register window mapping */
	if (sc->aac_regs_resource != NULL)
		bus_release_resource(sc->aac_dev, SYS_RES_MEMORY,
				     sc->aac_regs_rid, sc->aac_regs_resource);
}

/*
 * Disconnect from the controller completely, in preparation for unload.
 */
int
aac_detach(device_t dev)
{
	struct aac_softc *sc;
	struct aac_container *co;
	struct aac_sim	*sim;
	int error;

	debug_called(1);

	sc = device_get_softc(dev);

	if (sc->aac_state & AAC_STATE_OPEN)
		return(EBUSY);

	/* Remove the child containers */
	while ((co = TAILQ_FIRST(&sc->aac_container_tqh)) != NULL) {
		error = device_delete_child(dev, co->co_disk);
		if (error)
			return (error);
		TAILQ_REMOVE(&sc->aac_container_tqh, co, co_link);
		free(co, M_AACBUF, 0);
	}

	/* Remove the CAM SIMs */
	while ((sim = TAILQ_FIRST(&sc->aac_sim_tqh)) != NULL) {
		TAILQ_REMOVE(&sc->aac_sim_tqh, sim, sim_link);
		error = device_delete_child(dev, sim->sim_dev);
		if (error)
			return (error);
		free(sim, M_AACBUF, 0);
	}

	if (sc->aifflags & AAC_AIFFLAGS_RUNNING) {
		sc->aifflags |= AAC_AIFFLAGS_EXIT;
		wakeup(sc->aifthread);
		tsleep(sc->aac_dev, PUSER | PCATCH, "aacdch", 30 * hz);
	}

	if (sc->aifflags & AAC_AIFFLAGS_RUNNING)
		panic("Cannot shutdown AIF thread");

	if ((error = aac_shutdown(dev)))
		return(error);

	EVENTHANDLER_DEREGISTER(shutdown_final, sc->eh);

	aac_free(sc);

	return(0);
}

/*
 * Bring the controller down to a dormant state and detach all child devices.
 *
 * This function is called before detach or system shutdown.
 *
 * Note that we can assume that the bioq on the controller is empty, as we won't
 * allow shutdown if any device is open.
 */
int
aac_shutdown(device_t dev)
{
	struct aac_softc *sc;
	struct aac_fib *fib;
	struct aac_close_command *cc;

	debug_called(1);

	sc = device_get_softc(dev);

	sc->aac_state |= AAC_STATE_SUSPEND;

	/* 
	 * Send a Container shutdown followed by a HostShutdown FIB to the
	 * controller to convince it that we don't want to talk to it anymore.
	 * We've been closed and all I/O completed already
	 */
	device_printf(sc->aac_dev, "shutting down controller...");

	aac_alloc_sync_fib(sc, &fib, AAC_SYNC_LOCK_FORCE);
	cc = (struct aac_close_command *)&fib->data[0];

	bzero(cc, sizeof(struct aac_close_command));
	cc->Command = VM_CloseAll;
	cc->ContainerId = 0xffffffff;
	if (aac_sync_fib(sc, ContainerCommand, 0, fib,
	    sizeof(struct aac_close_command)))
		printf("FAILED.\n");
	else
		printf("done\n");
	else {
		fib->data[0] = 0;
		/*
		 * XXX Issuing this command to the controller makes it
		 * shut down but also keeps it from coming back up
		 * without a reset of the PCI bus.  This is not
		 * desirable if you are just unloading the driver
		 * module with the intent to reload it later.
		 */
		if (aac_sync_fib(sc, FsaHostShutdown, AAC_FIBSTATE_SHUTDOWN,
		    fib, 1)) {
			printf("FAILED.\n");
		} else {
			printf("done.\n");
		}
	}

	AAC_MASK_INTERRUPTS(sc);

	return(0);
}

/*
 * Bring the controller to a quiescent state, ready for system suspend.
 */
int
aac_suspend(device_t dev)
{
	struct aac_softc *sc;

	debug_called(1);

	sc = device_get_softc(dev);

	sc->aac_state |= AAC_STATE_SUSPEND;
	
	AAC_MASK_INTERRUPTS(sc);
	return(0);
}

/*
 * Bring the controller back to a state ready for operation.
 */
int
aac_resume(device_t dev)
{
	struct aac_softc *sc;

	debug_called(1);

	sc = device_get_softc(dev);

	sc->aac_state &= ~AAC_STATE_SUSPEND;
	AAC_UNMASK_INTERRUPTS(sc);
	return(0);
}
#endif

a643 8
#if 0
	/*
	 * if we ever implement detach, we should have detach tsleep
	 * to wait for this thread to finish
	 */
	wakeup(sc->aac_dev);
#endif

a1461 10
#if 0
	/* spin waiting for the command to complete */
	then = time_uptime;
	do {
		if (time_uptime > (then + AAC_IMMEDIATE_TIMEOUT)) {
			AAC_DPRINTF(AAC_D_MISC, ("timed out"));
			return(EIO);
		}
	} while (!(AAC_GET_ISTATUS(sc) & AAC_DB_SYNC_COMMAND));
#else
a1480 1
#endif
a2376 21

#if 0
	if (1 || bootverbose) {
		device_printf(sc->aac_dev, "Supported Options=%b\n",
			      sc->supported_options,
			      "\20"
			      "\1SNAPSHOT"
			      "\2CLUSTERS"
			      "\3WCACHE"
			      "\4DATA64"
			      "\5HOSTTIME"
			      "\6RAID50"
			      "\7WINDOW4GB"
			      "\10SCSIUPGD"
			      "\11SOFTERR"
			      "\12NORECOND"
			      "\13SGMAP64"
			      "\14ALARM"
			      "\15NONDASD");
	}
#endif
@


1.65
log
@unbreak aac(4) by re-adding uvm_extern.h for ptoa()

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.64 2014/07/12 18:48:17 tedu Exp $	*/
d119 1
a119 1
int	aac_sync_fib(struct aac_softc *, u_int32_t, u_int32_t, 
d182 1
a182 1
/* i960Rx interface */    
d202 1
a202 1
/* Rocket/MIPS interface */	
d277 1
a277 1
	sc->aac_link.openings = (sc->total_fibs - 8) / 
d351 1
a351 1
		/* 
d355 1
a355 1
		if (mir->Status == ST_OK && 
d1230 1
a1230 1
	if (bus_dmamap_load(sc->aac_dmat, fm->aac_fibmap, fm->aac_fibs, 
d1263 1
a1263 1
	} 
d1535 1
a1535 1
	if (bus_dmamap_load(sc->aac_dmat, sc->aac_common_map, sc->aac_common, 
d1550 1
a1550 1
    
d1564 1
a1564 1
	
d1583 1
a1583 1
	/* 
d1585 1
a1585 1
 	 * broken firmware versions that do the page->byte conversion twice,
d1602 1
a1602 1
	 * of the sizes of the respective queues, and theoretically it could 
d1607 2
a1608 2
	 * The Linux driver uses a much more complex scheme whereby several 
	 * header records are kept for each queue.  We use a couple of generic 
d1684 1
a1684 1
	if (aac_sync_command(sc, AAC_MONKER_INITSTRUCT, 
d1810 1
a1810 1
aac_sync_fib(struct aac_softc *sc, u_int32_t command, u_int32_t xferstate, 
d2035 1
a2035 1
	fib_size = fib->Header.Size; 
d2137 1
a2137 1
 	return (AAC_GETREG4(sc, AAC_FA_FWSTATUS));
d2551 1
a2551 1
			
d2555 1
a2555 1
			blockno = _3btol(rw->addr) & 
d2643 1
a2643 1
	info = (struct aac_adapter_info *)&fib->data[0];   
d2647 1
a2647 1
	       info->ClockSpeed, info->BufferMem / (1024 * 1024), 
d2745 1
a2745 1
			printf("  BlockRead: container %d  0x%x/%d\n", 
d2750 1
a2750 1
			printf("  BlockWrite: container %d  0x%x/%d (%s)\n", 
d2786 1
a2786 1
			printf("\t(Generic) %.*s\n", 
d2800 2
a2801 2
			printf("\t(ContainerChange) container %d,%d\n", 
			       aif->data.EN.data.ECC.container[0], 
d2806 1
a2806 1
			printf("\t(DeviceFailure) handle %d\n", 
d2813 2
a2814 2
			       aif->data.EN.data.EMF.container, 
			       aif->data.EN.data.EMF.failedSlice, 
d2821 1
a2821 1
			       aif->data.EN.data.ECE.eventType);	
d2848 1
a2848 1
			       aif->data.EN.data.EEE.unitID, 
d2861 1
a2861 1
			break;		
d2872 1
a2872 1
			printf("\t(ClusterEvent) event %d\n", 
d2879 2
a2880 2
			       aif->data.EN.data.EDS.eventType, 
			       aif->data.EN.data.EDS.DsNum, 
d2914 2
a2915 2
		}		
	
d2917 1
a2917 1
		       aif->seqNumber, status, 
d2944 1
a2944 1
			printf("\t(ContainerZero) container %d\n", 
d2949 1
a2949 1
			printf("\t(ContainerCopy) container %d to %d\n", 
d2977 1
a2977 1
			printf("\t(ContainerScrubRaid5) container %d\n", 
d2999 1
a2999 1
			printf("\t(ContainerCrazyCache) container %d\n", 
@


1.64
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.63 2014/07/08 17:19:25 deraadt Exp $	*/
d59 2
@


1.63
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.62 2014/01/17 22:52:32 dlg Exp $	*/
d473 1
a473 1
	free(sc->aac_commands, M_AACBUF);
d529 1
a529 1
		free(co, M_AACBUF);
d538 1
a538 1
		free(sim, M_AACBUF);
d1270 1
a1270 1
	free(fm, M_DEVBUF);
d1304 1
a1304 1
		free(fm, M_DEVBUF);
@


1.62
log
@a polled command timing out isnt a software resource shortage, its
a driver stuffup.

aac is XS_NO_CCB clean now.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.61 2014/01/17 22:51:10 dlg Exp $	*/
a58 2

#include <uvm/uvm_extern.h>
@


1.61
log
@remove a XS_NO_CCB case by moving aac to iopools.

eyes and ok by krw@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.60 2014/01/17 22:20:32 dlg Exp $	*/
d2606 1
a2606 1
				xs->error = XS_NO_CCB;
@


1.60
log
@replace aacminphys with scsi_minphys. both are just wrappers around
minphys.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.59 2014/01/17 22:18:27 dlg Exp $	*/
d114 3
a116 2
int	aac_alloc_command(struct aac_softc *, struct aac_command **);
void	aac_release_command(struct aac_command *);
d236 1
d281 1
a1099 3
	s = splbio();
	aac_release_command(cm);

d1102 1
d1149 2
a1150 2
int
aac_alloc_command(struct aac_softc *sc, struct aac_command **cmp)
d1152 1
d1156 3
a1158 4
	if ((cm = aac_dequeue_free(sc)) == NULL) {
		AAC_DPRINTF(AAC_D_CMD, (" failed"));
		return (EBUSY);
	}
d1160 1
a1160 2
	*cmp = cm;
	return(0);
a1162 3
/*
 * Release a command back to the freelist.
 */
d1164 1
a1164 1
aac_release_command(struct aac_command *cm)
a1165 3
	AAC_DPRINTF(AAC_D_CMD, (": release command"));

	/* (re)initialise the command/FIB */
d1174 1
d1176 9
a1184 7
	/* 
	 * These are duplicated in aac_start to cover the case where an
	 * intermediate stage may have destroyed them.  They're left
	 * initialised here for debugging purposes only.
	 */
	cm->cm_fib->Header.ReceiverFibAddress = (u_int32_t)cm->cm_fibphys;
	cm->cm_fib->Header.SenderData = 0;
d1186 1
d1188 1
d1252 1
a1252 1
		aac_release_command(cm);
d1561 3
d2583 2
a2584 12
		if (aac_alloc_command(sc, &cm)) {
			AAC_DPRINTF(AAC_D_CMD,
				    (": out of commands, try later\n"));
			/*
			 * We are out of commands, try again
			 * in a little while.
			 */
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			splx(s);
			return;
		}
@


1.59
log
@aacvar advertises a public api which is only used inside aac.c. make it
"private" so i dont feel bad about changing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.58 2013/11/18 20:21:51 deraadt Exp $	*/
d134 5
a138 1
	aac_scsi_cmd, aacminphys, 0, 0,
a2472 13
}

void
aacminphys(struct buf *bp, struct scsi_link *sl)
{
	AAC_DPRINTF(AAC_D_MISC, ("aacminphys(0x%x)\n", bp));

#if 0	/* As this is way more than MAXPHYS it's really not necessary. */
	if (bp->b_bcount > ((AAC_MAXOFFSETS - 1) * PAGE_SIZE))
		bp->b_bcount = ((AAC_MAXOFFSETS - 1) * PAGE_SIZE);
#endif

	minphys(bp);
@


1.58
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.57 2013/11/13 05:47:58 mlarkin Exp $	*/
d113 7
@


1.57
log
@

ENOMEM is probably more appropriate than 0 in this error case.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.56 2013/11/13 05:26:23 mlarkin Exp $	*/
d287 1
a287 1
	if (kthread_create(aac_command_thread, sc, &sc->aifthread, "%s",
@


1.56
log
@

Use of uninitialized variable. There are obvious locking problems also
present in this function, but I've been advised to walk away, and it
have been this way forever (and this code is not even enabled in GENERIC
by default anyway)

original bug found by Maxime Villard, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.55 2013/05/30 16:15:02 deraadt Exp $	*/
d1189 1
a1189 1
	int i, error = 0;
@


1.55
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.54 2011/07/17 22:46:48 matthew Exp $	*/
d1189 1
a1189 1
	int i, error;
@


1.54
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.53 2011/07/08 22:09:27 matthew Exp $	*/
a277 5

#if 0
	/* Register the shutdown method to only be called post-dump */
	sc->aac_sdh = shutdownhook_establish(aac_shutdown, (void *)sc);
#endif
@


1.53
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.52 2011/04/04 20:29:45 krw Exp $	*/
d266 1
a270 1
	saa.saa_targets = AAC_MAX_CONTAINERS;
@


1.52
log
@Kill some #if 0'ed code (the 'raw' scsi path). Move splx()
to before scsi_done(). This doesn't mean aac will ever enabled!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.51 2010/10/12 00:53:32 krw Exp $	*/
a265 1
	sc->aac_link.adapter_buswidth = AAC_MAX_CONTAINERS;
d270 1
@


1.51
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.50 2010/09/21 05:28:58 krw Exp $	*/
a113 3
#if 0
int	aac_raw_scsi_cmd(struct scsi_xfer *);
#endif
a129 6
#if 0
struct scsi_adapter aac_raw_switch = {
	aac_raw_scsi_cmd, aacminphys, 0, 0,
};
#endif

a2481 18
#if 0
int
aac_raw_scsi_cmd(struct scsi_xfer *xs)
{
#ifdef AAC_DEBUG
	struct aac_softc *sc = xs->sc_link->adapter_softc;
#endif
	int s;

	AAC_DPRINTF(AAC_D_CMD, ("%s: aac_raw_scsi_cmd\n",
				sc->aac_dev.dv_xname));

	/* XXX Not yet implemented */
	xs->error = XS_DRIVER_STUFFUP;
	scsi_done(xs);
}
#endif

d2492 3
a2494 1
	int s = splbio();
d2504 1
a2506 1
		splx(s);
@


1.50
log
@Stefan Rinkes pointed that the disabled aac(4) driver does not compile
with gcc4. Use his diff to make it compile.

Submitted & tested by Stefan Rinkes. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.49 2010/09/20 06:17:49 krw Exp $	*/
d2451 1
@


1.49
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.48 2010/08/07 03:50:01 krw Exp $	*/
d1051 1
a1051 1
			(struct aac_sg_table64 *)cm->cm_sgtable = &br->SgMap64;
d1063 1
a1063 1
			(struct aac_sg_table64 *)cm->cm_sgtable = &bw->SgMap64;
d1550 2
a1551 1
		(uint8_t *)sc->aac_common += 8192;
@


1.48
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.47 2010/06/28 18:31:01 krw Exp $	*/
d2432 1
a2432 1
		sd.error_code = 0x70;
@


1.47
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.46 2010/05/20 00:55:17 krw Exp $	*/
d426 1
a426 1
			panic("Out of memory?!\n");
d550 1
a550 1
		panic("Cannot shutdown AIF thread\n");
d772 1
a772 1
			panic("aac: error mapping command %p\n", cm);
d1009 1
a1009 1
		panic("%s: invalid opcode %#x\n", sc->aac_dev.dv_xname,
@


1.46
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.45 2010/05/18 20:57:20 oga Exp $	*/
a138 4
struct scsi_device aac_dev = {
	NULL, NULL, NULL, NULL
};

a272 1
	sc->aac_link.device = &aac_dev;
@


1.45
log
@more BUS_DMA_ZERO love.

ok marco.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.44 2010/04/10 16:17:38 oga Exp $	*/
d2095 1
a2096 1
		splx(s);
a2507 1
	s = splbio();
a2508 1
	splx(s);
@


1.44
log
@Remove a bunch of if 0ed out code that used vtophys. it hasn't been used
by now, probably won't be in the future.

ok krw. "Correctski" from miod@@ after I put back another chunk he wanted
to remain.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.43 2010/03/23 01:57:19 krw Exp $	*/
d1219 1
a1219 1
	    &fm->aac_seg, 1, &fm->aac_nsegs, BUS_DMA_NOWAIT)) {
a1247 1
	bzero(fm->aac_fibs, AAC_FIB_COUNT * sizeof(struct aac_fib));
d1520 1
a1520 1
			     &seg, 1, &nsegs, BUS_DMA_NOWAIT)) {
a1557 1
	bzero(sc->aac_common, sizeof *sc->aac_common);
@


1.43
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.42 2010/01/09 23:15:06 krw Exp $	*/
a2485 6
#if 0
	u_int8_t *buf = bp->b_data;
	paddr_t pa;
	long off;
#endif

a2492 8
#if 0
	for (off = PAGE_SIZE, pa = vtophys(buf); off < bp->b_bcount;
	    off += PAGE_SIZE)
		if (pa + off != vtophys(buf + off)) {
			bp->b_bcount = off;
			break;
		}
#endif
@


1.42
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.41 2009/11/22 14:14:10 krw Exp $	*/
d117 1
a117 1
int	aac_scsi_cmd(struct scsi_xfer *);
a2526 1
	return (COMPLETE);
d2530 1
a2530 1
int
a2539 1
	int retval = SUCCESSFULLY_QUEUED;
d2553 1
a2553 1
		return (COMPLETE);
d2641 2
d2644 1
a2644 1
			return (NO_CCB);
d2667 2
d2670 1
a2670 1
				return (NO_CCB);
a2676 6
	/*
	 * Don't process the queue if we are polling.
	 */
	if (xs->flags & SCSI_POLL)
		retval = COMPLETE;

a2679 1
	return (retval);
@


1.41
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.40 2009/09/04 04:57:14 miod Exp $	*/
a1109 1
	xs->flags |= ITSDONE;
a2096 1
		xs->flags |= ITSDONE;
a2523 1
	xs->flags |= ITSDONE;
a2552 1
		xs->flags |= ITSDONE;
a2574 1
		xs->flags |= ITSDONE;
a2581 1
		xs->flags |= ITSDONE;
a2588 1
		xs->flags |= ITSDONE;
a2595 1
		xs->flags |= ITSDONE;
a2631 1
			xs->flags |= ITSDONE;
a2669 1
			xs->flags |= ITSDONE;
@


1.40
log
@Missing scsi_done() in some error path returning COMPLETE; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.39 2009/02/16 21:19:06 miod Exp $	*/
d2677 1
a2677 1
				return (TRY_AGAIN_LATER);
@


1.39
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.38 2008/11/24 00:31:35 krw Exp $	*/
d114 1
d116 1
d133 1
d137 1
d2512 1
d2519 2
d2526 4
d2532 1
@


1.38
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.37 2007/10/01 04:03:51 krw Exp $	*/
d2482 1
a2482 1
aacminphys(struct buf *bp)
@


1.37
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.36 2007/09/02 12:12:12 martin Exp $	*/
d2641 1
a2641 1
			return (TRY_AGAIN_LATER);
@


1.36
log
@ctob is gone, use ptoa

tested by ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.35 2007/03/20 10:30:32 mickey Exp $	*/
d1210 1
a1210 1
	fm = malloc(sizeof(struct aac_fibmap), M_DEVBUF, M_NOWAIT);
a1212 1
	bzero(fm, sizeof(struct aac_fibmap));
d1561 1
a1561 2
				  M_DEVBUF, M_WAITOK);
	bzero(sc->aac_commands, AAC_MAX_FIBS * sizeof(struct aac_command));
@


1.35
log
@missing include and also use time_uptime as art suggested; compiles now
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.34 2006/12/18 14:44:33 mpf Exp $	*/
d1595 1
a1595 1
	ip->HostPhysMemPages = ctob(physmem) / AAC_PAGE_SIZE;
@


1.34
log
@-       struct scsibus_attach_args;
+       struct scsibus_attach_args saa;

OK miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.33 2006/11/28 23:59:45 dlg Exp $	*/
d56 1
d1489 1
a1489 1
	then = time_second;
d1600 1
a1600 1
	ip->HostElapsedSeconds = time_second; /* reset later if invalid */
d1743 1
a1743 1
	then = time_second;
d1745 1
a1745 1
		if (time_second > (then + AAC_IMMEDIATE_TIMEOUT)) {
d2083 1
a2083 1
	       (int)(time_second - cm->cm_timestamp));
d2115 1
a2115 1
	deadline = time_second - AAC_CMD_TIMEOUT;
d2651 1
a2651 1
		cm->cm_timestamp = time_second;
@


1.33
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.32 2006/07/21 19:11:11 mickey Exp $	*/
d226 1
a226 1
	struct scsibus_attach_args;
@


1.32
log
@properly report errors thru scsi layer and not bio that will be overwritten later by scsi no no error; tested by mesel and nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.31 2006/04/28 02:51:27 brad Exp $	*/
d226 1
d278 4
a281 1
	config_found(&sc->aac_dev, &sc->aac_link, scsiprint);
@


1.31
log
@remove function prototypes for a few functions removed in rev 1.25.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.30 2006/04/22 02:36:26 brad Exp $	*/
a1080 1
	struct buf *bp = xs->bp;
a1086 5
	s = splbio();
	aac_release_command(cm);
	if (bp == NULL)
		goto exit;

d1088 1
a1088 1
	if (bp->b_flags & B_READ) {
d1096 2
a1097 10
	/* fix up the bio based on status */
	if (status == ST_OK) {
		bp->b_resid = 0;
	} else {
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;

		/* pass an error string out to the disk layer */
		aac_describe_code(aac_command_status_table, status);
	}
d1099 1
a1099 2
 exit:
	xs->error = XS_NOERROR;
@


1.30
log
@Add support for the Adaptec RAID-On-Chip architecture.  This in turn
provides support for the Adaptec 2130S and 2230SLP adapters.

From FreeBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.29 2006/04/20 20:31:12 miod Exp $	*/
a83 1
void	aac_enqueue(struct aac_softc *, struct scsi_xfer *, int);
a91 2
void	aac_host_command(struct aac_softc *);
void	aac_host_response(struct aac_softc *);
a120 1
void	aac_watchdog(void *);
@


1.29
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.28 2006/02/06 22:11:32 jmc Exp $	*/
d202 21
d1694 5
d2161 6
d2190 6
d2217 6
d2245 6
d2292 11
d2324 6
d2370 12
@


1.28
log
@typos from alexey dobriyan;
ok mickey marco mbalmer niklas brad
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.27 2005/12/13 01:01:40 krw Exp $	*/
d1809 1
a1809 1
		printf("aac_sync_fib 1: datasize=%d AAC_FIB_DATASIZE\n",
@


1.27
log
@Don't retry unsupported SCSI commands, causing large delays during
boot process. Same as done to gdt and ioprbs.

ok nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.26 2005/12/03 16:53:15 krw Exp $	*/
d2945 1
a2945 1
			printf("\t(ConatainerZero) container %d\n", 
d2950 1
a2950 1
			printf("\t(ConatainerCopy) container %d to %d\n", 
d2956 1
a2956 1
			printf("\t(ConatainerCreateMirror) container %d\n",
d2962 1
a2962 1
			printf("\t(ConatainerMergeMirror) container %d\n",
d2968 1
a2968 1
			printf("\t(ConatainerScrubMirror) container %d\n",
d2973 1
a2973 1
			printf("\t(ConatainerRebuildRaid5) container %d\n",
d2978 1
a2978 1
			printf("\t(ConatainerScrubRaid5) container %d\n", 
d2983 1
a2983 1
			printf("\t(ConatainerMorph) container %d\n",
d2989 1
a2989 1
			printf("\t(ConatainerPartCopy) container %d to %d\n",
d2995 1
a2995 1
			printf("\t(ConatainerRebuildMirror) container %d\n",
d3000 1
a3000 1
			printf("\t(ConatainerCrazyCache) container %d\n", 
@


1.26
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.25 2005/11/18 05:39:10 nate Exp $	*/
d97 1
a97 1
int	aac_internal_cache_cmd(struct scsi_xfer *);
d2348 1
a2348 1
int
d2412 1
a2412 1
		return (0);
a2415 1
	return (1);
d2503 1
a2503 4
		if (!aac_internal_cache_cmd(xs)) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}
@


1.25
log
@Major improvements to the aac(4) device driver.
- decouple the command structures from scsi structures, allowing non block
oriented commands (e.g. management commands) to be built.
- redesign the various command queues to remove race conditions and to allow
commands from multiple sources to coexist in the system
- move major processing of commands and messages to a dedicated kernel
thread to avoid spending too long in the interrupt handler
- add device data structures for various management commands to the header
file

Much code from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.24 2005/09/15 05:33:39 krw Exp $	*/
a2580 1
			xs->error = XS_DRIVER_STUFFUP;
a2604 1
				xs->error = XS_TIMEOUT;
@


1.24
log
@Don't fake MODE SENSE page 4 info inside raid drivers, just let sd
fake a geometry. Page 4 info does not get used for size information.
Eliminate now unused union scsi_disk_pages.

ok marco@@ mickey@@ pre-lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.23 2005/08/24 01:19:47 krw Exp $	*/
d5 1
d7 1
d9 1
d53 1
d55 1
d79 2
a80 2
void	aac_bio_complete(struct aac_ccb *);
void	aac_complete(void *, int);
a81 3
struct scsi_xfer *aac_dequeue(struct aac_softc *);
int	aac_dequeue_fib(struct aac_softc *, int, u_int32_t *,
    struct aac_fib **);
d85 6
a90 2
void	aac_enqueue_ccb(struct aac_softc *, struct aac_ccb *);
int	aac_enqueue_fib(struct aac_softc *, int, struct aac_ccb *);
d92 1
a92 6
int	aac_exec_ccb(struct aac_ccb *);
void	aac_free_ccb(struct aac_softc *, struct aac_ccb *);
struct aac_ccb *aac_get_ccb(struct aac_softc *, int);
#if 0
void	aac_handle_aif(struct aac_softc *, struct aac_aif_command *);
#endif
d96 1
d98 18
a115 4
int	aac_map_command(struct aac_ccb *);
#ifdef AAC_DEBUG
void	aac_print_fib(struct aac_softc *, struct aac_fib *, const char *);
#endif
d118 1
a118 2
int	aac_start(struct aac_ccb *);
void	aac_start_ccbs(struct aac_softc *);
d120 2
a123 4
int	aac_sync_fib(struct aac_softc *, u_int32_t, u_int32_t, void *,
    u_int16_t, void *, u_int16_t *);
void	aac_timeout(void *);
void	aac_unmap_command(struct aac_ccb *);
d142 19
a160 9
/* i960Rx interface */    
int	aac_rx_get_fwstatus(struct aac_softc *);
void	aac_rx_qnotify(struct aac_softc *, int);
int	aac_rx_get_istatus(struct aac_softc *);
void	aac_rx_clear_istatus(struct aac_softc *, int);
void	aac_rx_set_mailbox(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t);
int	aac_rx_get_mailboxstatus(struct aac_softc *);
void	aac_rx_set_interrupts(struct aac_softc *, int);
d169 1
a169 1
int	aac_sa_get_mailboxstatus(struct aac_softc *);
d172 20
d198 1
a198 1
	aac_rx_get_mailboxstatus,
a201 10
struct aac_interface aac_sa_interface = {
	aac_sa_get_fwstatus,
	aac_sa_qnotify,
	aac_sa_get_istatus,
	aac_sa_clear_istatus,
	aac_sa_set_mailbox,
	aac_sa_get_mailboxstatus,
	aac_sa_set_interrupts
};

d207 1
a207 2
aac_attach(sc)
	struct aac_softc *sc;
d209 1
a209 4
	int i, error;
	bus_dma_segment_t seg;
	int nsegs;
	struct aac_ccb *ccb;
d211 7
a217 4
	TAILQ_INIT(&sc->sc_free_ccb);
	TAILQ_INIT(&sc->sc_ccbq);
	TAILQ_INIT(&sc->sc_completed);
	LIST_INIT(&sc->sc_queue);
d223 1
a223 1
	sc->sc_state |= AAC_STATE_SUSPEND;
d226 1
a226 1
	 * Initialise the adapter.
d228 1
a228 1
	error = aac_init(sc);
d232 2
a233 2
	/* 
	 * Print a little information about the controller.
d235 5
a239 1
	aac_describe_controller(sc);
d241 2
a242 30
	/* Initialize the ccbs */
	for (i = 0; i < AAC_ADAP_NORM_CMD_ENTRIES; i++) {
		ccb = &sc->sc_ccbs[i];
		error = bus_dmamap_create(sc->sc_dmat,
		    (AAC_MAXSGENTRIES - 1) << PGSHIFT, AAC_MAXSGENTRIES,
		    (AAC_MAXSGENTRIES - 1) << PGSHIFT, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->ac_dmamap_xfer);
		if (error) {
			printf("%s: cannot create ccb dmamap (%d)",
			    sc->sc_dev.dv_xname, error);
			/* XXX cleanup */
			return (1);
		}

		/* allocate the FIB cluster in DMAable memory and load it */
		if (bus_dmamem_alloc(sc->sc_dmat, sizeof *ccb->ac_fib, 1, 0,
		    &seg, 1, &nsegs, BUS_DMA_NOWAIT)) {
			printf("%s: can't allocate FIB structure\n",
			    sc->sc_dev.dv_xname);
			/* XXX cleanup */
			return (1);
		}
		ccb->ac_fibphys = seg.ds_addr;
		if (bus_dmamem_map(sc->sc_dmat, &seg, nsegs,
		    sizeof *ccb->ac_fib, (caddr_t *)&ccb->ac_fib, 0)) {
			printf("%s: can't map FIB structure\n",
			    sc->sc_dev.dv_xname);
			/* XXX cleanup */
			return (1);
		}
d244 6
a249 3
		TAILQ_INSERT_TAIL(&sc->sc_free_ccb, &sc->sc_ccbs[i],
		    ac_chain);
	}
d252 14
a265 11
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &aac_switch;
	sc->sc_link.device = &aac_dev;
	/*
	 * XXX Theoretically this should be AAC_ADAP_NORM_CMD_ENTRIES but
	 * XXX in some configurations this can cause "not queued" errors.
	 * XXX A quarter of that number has been reported to be safe.
	 */
	sc->sc_link.openings = AAC_ADAP_NORM_CMD_ENTRIES / 4;
	sc->sc_link.adapter_buswidth = AAC_MAX_CONTAINERS;
	sc->sc_link.adapter_target = AAC_MAX_CONTAINERS;
d267 4
a270 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
a274 17
/*
 * Look up a text description of a numeric error code and return a pointer to
 * same.
 */
char *
aac_describe_code(table, code)
	struct aac_code_lookup *table;
	u_int32_t code;
{
	int i;

	for (i = 0; table[i].string != NULL; i++)
		if (table[i].code == code)
			return (table[i].string);
	return (table[i + 1].string);
}

d276 1
a276 2
aac_describe_controller(sc)
	struct aac_softc *sc;
d278 1
a278 194
	u_int8_t buf[AAC_FIB_DATASIZE];	/* XXX a bit big for the stack */
	u_int16_t bufsize;
	struct aac_adapter_info *info;
	u_int8_t arg;

	arg = 0;
	if (aac_sync_fib(sc, RequestAdapterInfo, 0, &arg, sizeof arg, &buf,
	    &bufsize)) {
		printf("%s: RequestAdapterInfo failed\n", sc->sc_dev.dv_xname);
		return;
	}
	if (bufsize != sizeof *info) {
		printf("%s: "
		    "RequestAdapterInfo returned wrong data size (%d != %d)\n",
		    sc->sc_dev.dv_xname, bufsize, sizeof *info);
		return;
	}
	info = (struct aac_adapter_info *)&buf[0];

	printf("%s: %s %dMHz, %dMB, %s (%d) Kernel %d.%d-%d\n",
	    sc->sc_dev.dv_xname,
	    aac_describe_code(aac_cpu_variant, info->CpuVariant),
	    info->ClockSpeed, info->TotalMem / (1024 * 1024),
	    aac_describe_code(aac_battery_platform, info->batteryPlatform),
	    info->batteryPlatform, info->KernelRevision.external.comp.major,
	    info->KernelRevision.external.comp.minor,
	    info->KernelRevision.external.comp.dash);

	/* save the kernel revision structure for later use */
	sc->sc_revision = info->KernelRevision;
}

int
aac_init(sc)
	struct aac_softc *sc;
{
	bus_dma_segment_t seg;
	int nsegs;
	int i, error;
	int state = 0;
	struct aac_adapter_init	*ip;
	u_int32_t code;
	u_int8_t *qaddr;

	/*
	 * First wait for the adapter to come ready.
	 */
	for (i = 0; i < AAC_BOOT_TIMEOUT * 1000; i++) {
		code = AAC_GET_FWSTATUS(sc);
		if (code & AAC_SELF_TEST_FAILED) {
			printf("%s: FATAL: selftest failed\n",
			    sc->sc_dev.dv_xname);
			return (ENXIO);
		}
		if (code & AAC_KERNEL_PANIC) {
			printf("%s: FATAL: controller kernel panic\n",
			    sc->sc_dev.dv_xname);
			return (ENXIO);
		}
		if (code & AAC_UP_AND_RUNNING)
			break;
		DELAY(1000);
	}
	if (i == AAC_BOOT_TIMEOUT * 1000) {
		printf("%s: FATAL: controller not coming ready, status %x\n",
		    sc->sc_dev.dv_xname, code);
		return (ENXIO);
	}

	if (bus_dmamem_alloc(sc->sc_dmat, sizeof *sc->sc_common, 1, 0, &seg, 1,
	    &nsegs, BUS_DMA_NOWAIT)) {
		printf("%s: can't allocate common structure\n",
		    sc->sc_dev.dv_xname);
		return (ENOMEM);
	}
	state++;
	sc->sc_common_busaddr = seg.ds_addr;
	if (bus_dmamem_map(sc->sc_dmat, &seg, nsegs, sizeof *sc->sc_common,
	    (caddr_t *)&sc->sc_common, 0)) {
		printf("%s: can't map common structure\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto bail_out;
	}
	state++;
	bzero(sc->sc_common, sizeof *sc->sc_common);
    
	/*
	 * Fill in the init structure.  This tells the adapter about
	 * the physical location * of various important shared data
	 * structures.
	 */
	ip = &sc->sc_common->ac_init;
	ip->InitStructRevision = AAC_INIT_STRUCT_REVISION;

	ip->AdapterFibsPhysicalAddress =
	    sc->sc_common_busaddr + offsetof(struct aac_common, ac_fibs);
	ip->AdapterFibsVirtualAddress = &sc->sc_common->ac_fibs[0];
	ip->AdapterFibsSize = AAC_ADAPTER_FIBS * sizeof(struct aac_fib);
	ip->AdapterFibAlign = sizeof(struct aac_fib);

	ip->PrintfBufferAddress =
	    sc->sc_common_busaddr + offsetof(struct aac_common, ac_printf);
	ip->PrintfBufferSize = AAC_PRINTF_BUFSIZE;

	ip->HostPhysMemPages = 0;	/* not used? */
	ip->HostElapsedSeconds = 0;	/* reset later if invalid */

	/*
	 * Initialise FIB queues.  Note that it appears that the
	 * layout of the indexes and the segmentation of the entries
	 * is mandated by the adapter, which is only told about the
	 * base of the queue index fields.
	 *
	 * The initial values of the indices are assumed to inform the
	 * adapter of the sizes of the respective queues.
	 *
	 * The Linux driver uses a much more complex scheme whereby
	 * several header * records are kept for each queue.  We use a
	 * couple of generic list manipulation functions which
	 * 'know' the size of each list by virtue of a table.
	 */
	qaddr = &sc->sc_common->ac_qbuf[0] + AAC_QUEUE_ALIGN;
	qaddr -= (u_int32_t)qaddr % AAC_QUEUE_ALIGN; 	/* XXX not portable */
	sc->sc_queues = (struct aac_queue_table *)qaddr;
	ip->CommHeaderAddress = sc->sc_common_busaddr +
	    ((char *)sc->sc_queues - (char *)sc->sc_common);
	bzero(sc->sc_queues, sizeof(struct aac_queue_table));

	sc->sc_queues->qt_qindex[AAC_HOST_NORM_CMD_QUEUE][AAC_PRODUCER_INDEX] =
	    AAC_HOST_NORM_CMD_ENTRIES;
	sc->sc_queues->qt_qindex[AAC_HOST_NORM_CMD_QUEUE][AAC_CONSUMER_INDEX] =
	    AAC_HOST_NORM_CMD_ENTRIES;
	sc->sc_queues->qt_qindex[AAC_HOST_HIGH_CMD_QUEUE][AAC_PRODUCER_INDEX] =
	    AAC_HOST_HIGH_CMD_ENTRIES;
	sc->sc_queues->qt_qindex[AAC_HOST_HIGH_CMD_QUEUE][AAC_CONSUMER_INDEX] =
	    AAC_HOST_HIGH_CMD_ENTRIES;
	sc->sc_queues->qt_qindex[AAC_ADAP_NORM_CMD_QUEUE][AAC_PRODUCER_INDEX] =
	    AAC_ADAP_NORM_CMD_ENTRIES;
	sc->sc_queues->qt_qindex[AAC_ADAP_NORM_CMD_QUEUE][AAC_CONSUMER_INDEX] =
	    AAC_ADAP_NORM_CMD_ENTRIES;
	sc->sc_queues->qt_qindex[AAC_ADAP_HIGH_CMD_QUEUE][AAC_PRODUCER_INDEX] =
	    AAC_ADAP_HIGH_CMD_ENTRIES;
	sc->sc_queues->qt_qindex[AAC_ADAP_HIGH_CMD_QUEUE][AAC_CONSUMER_INDEX] =
	    AAC_ADAP_HIGH_CMD_ENTRIES;
	sc->sc_queues->
	    qt_qindex[AAC_HOST_NORM_RESP_QUEUE][AAC_PRODUCER_INDEX] =
	    AAC_HOST_NORM_RESP_ENTRIES;
	sc->sc_queues->
	    qt_qindex[AAC_HOST_NORM_RESP_QUEUE][AAC_CONSUMER_INDEX] =
	    AAC_HOST_NORM_RESP_ENTRIES;
	sc->sc_queues->
	    qt_qindex[AAC_HOST_HIGH_RESP_QUEUE][AAC_PRODUCER_INDEX] =
	    AAC_HOST_HIGH_RESP_ENTRIES;
	sc->sc_queues->
	    qt_qindex[AAC_HOST_HIGH_RESP_QUEUE][AAC_CONSUMER_INDEX] =
	    AAC_HOST_HIGH_RESP_ENTRIES;
	sc->sc_queues->
	    qt_qindex[AAC_ADAP_NORM_RESP_QUEUE][AAC_PRODUCER_INDEX] =
	    AAC_ADAP_NORM_RESP_ENTRIES;
	sc->sc_queues->
	    qt_qindex[AAC_ADAP_NORM_RESP_QUEUE][AAC_CONSUMER_INDEX] =
	    AAC_ADAP_NORM_RESP_ENTRIES;
	sc->sc_queues->
	    qt_qindex[AAC_ADAP_HIGH_RESP_QUEUE][AAC_PRODUCER_INDEX] =
	    AAC_ADAP_HIGH_RESP_ENTRIES;
	sc->sc_queues->
	    qt_qindex[AAC_ADAP_HIGH_RESP_QUEUE][AAC_CONSUMER_INDEX] =
	    AAC_ADAP_HIGH_RESP_ENTRIES;
	sc->sc_qentries[AAC_HOST_NORM_CMD_QUEUE] =
	    &sc->sc_queues->qt_HostNormCmdQueue[0];
	sc->sc_qentries[AAC_HOST_HIGH_CMD_QUEUE] =
	    &sc->sc_queues->qt_HostHighCmdQueue[0];
	sc->sc_qentries[AAC_ADAP_NORM_CMD_QUEUE] =
	    &sc->sc_queues->qt_AdapNormCmdQueue[0];
	sc->sc_qentries[AAC_ADAP_HIGH_CMD_QUEUE] =
	    &sc->sc_queues->qt_AdapHighCmdQueue[0];
	sc->sc_qentries[AAC_HOST_NORM_RESP_QUEUE] =
	    &sc->sc_queues->qt_HostNormRespQueue[0];
	sc->sc_qentries[AAC_HOST_HIGH_RESP_QUEUE] =
	    &sc->sc_queues->qt_HostHighRespQueue[0];
	sc->sc_qentries[AAC_ADAP_NORM_RESP_QUEUE] =
	    &sc->sc_queues->qt_AdapNormRespQueue[0];
	sc->sc_qentries[AAC_ADAP_HIGH_RESP_QUEUE] =
	    &sc->sc_queues->qt_AdapHighRespQueue[0];

	/*
	 * Do controller-type-specific initialisation
	 */
	switch (sc->sc_hwif) {
	case AAC_HWIF_I960RX:
		AAC_SETREG4(sc, AAC_RX_ODBR, ~0);
		break;
	}
d280 5
a284 10
	/*
	 * Give the init structure to the controller.
	 */
	if (aac_sync_command(sc, AAC_MONKER_INITSTRUCT, 
	    sc->sc_common_busaddr + offsetof(struct aac_common, ac_init), 0, 0,
	    0, NULL)) {
		printf("%s: error establishing init structure\n",
		    sc->sc_dev.dv_xname);
		error = EIO;
		goto bail_out;
d286 2
a288 11
	aac_startup(sc);

	return (0);

 bail_out:
	if (state > 1)
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_common,
		    sizeof *sc->sc_common);
	if (state > 0)
		bus_dmamem_free(sc->sc_dmat, &seg, 1);
	return (error);
d295 1
a295 2
aac_startup (sc)
	struct aac_softc *sc;
d297 5
a301 4
	struct aac_mntinfo mi;
	struct aac_mntinforesponse mir;
	u_int16_t rsize;	
	int i, drv_cyls, drv_hds, drv_secs;
d303 6
d310 1
a310 3
	mi.Command = VM_NameServe;
	mi.MntType = FT_FILESYS;
	for (i = 0; i < AAC_MAX_CONTAINERS; i++) {
d312 8
a319 12
		mi.MntCount = i;
		if (aac_sync_fib(sc, ContainerCommand, 0, &mi, sizeof mi, &mir,
		    &rsize)) {
			printf("%s: error probing container %d",
			    sc->sc_dev.dv_xname, i);
			continue;
		}
		/* check response size */
		if (rsize != sizeof mir) {
			printf("%s: container info response wrong size "
			    "(%d should be %d)",
			    sc->sc_dev.dv_xname, rsize, sizeof mir);
d323 7
d332 1
a332 2
		 * that many of the possible types * may never show
		 * up.
d334 4
a337 2
		if (mir.Status == ST_OK &&
		    mir.MntTable[0].VolType != CT_NONE) {
d339 10
a348 8
			    ("%d: id %x  name '%.16s'  size %u  type %d", i,
			    mir.MntTable[0].ObjectId,
			    mir.MntTable[0].FileSystemName,
			    mir.MntTable[0].Capacity,
			    mir.MntTable[0].VolType));

			sc->sc_hdr[i].hd_present = 1;
			sc->sc_hdr[i].hd_size = mir.MntTable[0].Capacity;
d353 5
a357 5
			sc->sc_hdr[i].hd_size &= ~AAC_SECS32;
			aac_eval_mapping(sc->sc_hdr[i].hd_size, &drv_cyls,
			    &drv_hds, &drv_secs);
			sc->sc_hdr[i].hd_heads = drv_hds;
			sc->sc_hdr[i].hd_secs = drv_secs;
d359 1
a359 1
			sc->sc_hdr[i].hd_size = drv_cyls * drv_hds * drv_secs;
d361 1
a361 1
			sc->sc_hdr[i].hd_devtype = mir.MntTable[0].VolType;
d365 14
a378 1
	}
d381 1
a381 1
	sc->sc_state &= ~AAC_STATE_SUSPEND;
d387 4
d392 1
a392 3
aac_eval_mapping(size, cyls, heads, secs)
	u_int32_t size;
	int *cyls, *heads, *secs;
d394 35
a428 16
	*cyls = size / AAC_HEADS / AAC_SECS;
	if (*cyls < AAC_MAXCYLS) {
		*heads = AAC_HEADS;
		*secs = AAC_SECS;
	} else {
		/* Too high for 64 * 32 */
		*cyls = size / AAC_MEDHEADS / AAC_MEDSECS;
		if (*cyls < AAC_MAXCYLS) {
			*heads = AAC_MEDHEADS;
			*secs = AAC_MEDSECS;
		} else {
			/* Too high for 127 * 63 */
			*cyls = size / AAC_BIGHEADS / AAC_BIGSECS;
			*heads = AAC_BIGHEADS;
			*secs = AAC_BIGSECS;
		}
d431 1
d433 8
a440 3
int
aac_raw_scsi_cmd(xs)
	struct scsi_xfer *xs;
a441 1
	AAC_DPRINTF(AAC_D_CMD, ("aac_raw_scsi_cmd "));
d443 1
a443 4
	/* XXX Not yet implemented */
	xs->error = XS_DRIVER_STUFFUP;
	return (COMPLETE);
}
d445 3
a447 13
int
aac_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *link = xs->sc_link;
	struct aac_softc *sc = link->adapter_softc;
	u_int8_t target = link->target;
	struct aac_ccb *ccb;
	u_int32_t blockno, blockcnt;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	aac_lock_t lock;
	int retval = SUCCESSFULLY_QUEUED;
d449 4
a452 1
	AAC_DPRINTF(AAC_D_CMD, ("aac_scsi_cmd "));
d454 1
a454 1
	xs->error = XS_NOERROR;
d456 5
a460 10
	if (target >= AAC_MAX_CONTAINERS || !sc->sc_hdr[target].hd_present ||
	    link->lun != 0) {
		/*
		 * XXX Should be XS_SENSE but that would require setting up a
		 * faked sense too.
		 */
		xs->error = XS_DRIVER_STUFFUP;
		xs->flags |= ITSDONE;
		scsi_done(xs);
		return (COMPLETE);
d462 2
d465 6
a470 1
	lock = AAC_LOCK(sc);
d472 3
a474 3
	/* Don't double enqueue if we came from aac_chain. */
	if (xs != LIST_FIRST(&sc->sc_queue))
		aac_enqueue(sc, xs, 0);
d476 3
a478 23
	while ((xs = aac_dequeue(sc))) {
		xs->error = XS_NOERROR;
		ccb = NULL;
		link = xs->sc_link;
		target = link->target;

		switch (xs->cmd->opcode) {
		case TEST_UNIT_READY:
		case REQUEST_SENSE:
		case INQUIRY:
		case MODE_SENSE:
		case START_STOP:
		case READ_CAPACITY:
#if 0
		case VERIFY:
#endif
			if (!aac_internal_cache_cmd(xs)) {
				AAC_UNLOCK(sc, lock);
				return (TRY_AGAIN_LATER);
			}
			xs->flags |= ITSDONE;
			scsi_done(xs);
			goto ready;
d480 18
a497 7
		case PREVENT_ALLOW:
			AAC_DPRINTF(AAC_D_CMD, ("PREVENT/ALLOW "));
			/* XXX Not yet implemented */
			xs->error = XS_NOERROR;
			xs->flags |= ITSDONE;
			scsi_done(xs);
			goto ready;
d499 1
a499 7
		case SYNCHRONIZE_CACHE:
			AAC_DPRINTF(AAC_D_CMD, ("SYNCHRONIZE_CACHE "));
			/* XXX Not yet implemented */
			xs->error = XS_NOERROR;
			xs->flags |= ITSDONE;
			scsi_done(xs);
			goto ready;
d501 2
a502 8
		default:
			AAC_DPRINTF(AAC_D_CMD,
			    ("unknown opc %d ", xs->cmd->opcode));
			/* XXX Not yet implemented */
			xs->error = XS_DRIVER_STUFFUP;
			xs->flags |= ITSDONE;
			scsi_done(xs);
			goto ready;
d504 8
a511 6
		case READ_COMMAND:
		case READ_BIG:
		case WRITE_COMMAND:
		case WRITE_BIG:
			AAC_DPRINTF(AAC_D_CMD,
			    ("rw opc %d ", xs->cmd->opcode));
d513 8
a520 32
			if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
				/* A read or write operation. */
				if (xs->cmdlen == 6) {
					rw = (struct scsi_rw *)xs->cmd;
					blockno = _3btol(rw->addr) &
					    (SRW_TOPADDR << 16 | 0xffff);
					blockcnt =
					    rw->length ? rw->length : 0x100;
				} else {
					rwb = (struct scsi_rw_big *)xs->cmd;
					blockno = _4btol(rwb->addr);
					blockcnt = _2btol(rwb->length);
				}
				if (blockno >= sc->sc_hdr[target].hd_size ||
				    blockno + blockcnt >
				    sc->sc_hdr[target].hd_size) {
					printf(
					    "%s: out of bounds %u-%u >= %u\n",
					    sc->sc_dev.dv_xname, blockno,
					    blockcnt,
					    sc->sc_hdr[target].hd_size);
					/*
					 * XXX Should be XS_SENSE but that
					 * would require setting up a faked
					 * sense too.
					 */
					xs->error = XS_DRIVER_STUFFUP;
					xs->flags |= ITSDONE;
					scsi_done(xs);
					goto ready;
				}
			}
d522 5
a526 1
			ccb = aac_get_ccb(sc, xs->flags);
d528 2
a529 8
			/*
			 * We are out of commands, try again in a little while.
			 */
			if (ccb == NULL) {
				xs->error = XS_DRIVER_STUFFUP;
				AAC_UNLOCK(sc, lock);
				return (TRY_AGAIN_LATER);
			}
d531 2
a532 13
			ccb->ac_blockno = blockno;
			ccb->ac_blockcnt = blockcnt;
			ccb->ac_xs = xs;
			ccb->ac_timeout = xs->timeout;

			if (xs->cmd->opcode != SYNCHRONIZE_CACHE &&
			    aac_map_command(ccb)) {
				aac_free_ccb(sc, ccb);
				xs->error = XS_DRIVER_STUFFUP;
				xs->flags |= ITSDONE;
				scsi_done(xs);
				goto ready;
			}
d534 1
a534 16
			aac_enqueue_ccb(sc, ccb);
			/* XXX what if enqueue did not start a transfer? */
			if (xs->flags & SCSI_POLL) {
#if 0
				if (!aac_wait(sc, ccb, ccb->ac_timeout)) {
					AAC_UNLOCK(sc, lock);
					printf("%s: command timed out\n",
					    sc->sc_dev.dv_xname);
					xs->error = XS_TIMEOUT;
					return (TRY_AGAIN_LATER);
				}
				xs->flags |= ITSDONE;
				scsi_done(xs);
#endif
			}
		}
d536 1
a536 9
	ready:
		/*
		 * Don't process the queue if we are polling.
		 */
		if (xs->flags & SCSI_POLL) {
			retval = COMPLETE;
			break;
		}
	}
d538 1
a538 2
	AAC_UNLOCK(sc, lock);
	return (retval);
d541 10
a550 5
void
aac_copy_internal_data(xs, data, size)
	struct scsi_xfer *xs;
	u_int8_t *data;
	size_t size;
d552 16
a567 1
	size_t copy_cnt;
d569 2
a570 1
	AAC_DPRINTF(AAC_D_MISC, ("aac_copy_internal_data "));
d572 8
a579 2
	if (!xs->datalen)
		printf("uio move not yet supported\n");
d581 14
a594 2
		copy_cnt = MIN(size, xs->datalen);
		bcopy(data, xs->data, copy_cnt);
d596 4
d602 3
a604 1
/* Emulated SCSI operation on cache device */
d606 1
a606 2
aac_internal_cache_cmd(xs)
	struct scsi_xfer *xs;
d608 1
a608 6
	struct scsi_link *link = xs->sc_link;
	struct aac_softc *sc = link->adapter_softc;
	struct scsi_inquiry_data inq;
	struct scsi_sense_data sd;
	struct scsi_read_cap_data rcd;
	u_int8_t target = link->target;
d610 1
a610 1
	AAC_DPRINTF(AAC_D_CMD, ("aac_internal_cache_cmd "));
d612 1
a612 9
	switch (xs->cmd->opcode) {
	case TEST_UNIT_READY:
	case START_STOP:
#if 0
	case VERIFY:
#endif
		AAC_DPRINTF(AAC_D_CMD, ("opc %d tgt %d ", xs->cmd->opcode,
		    target));
		break;
d614 5
a618 10
	case REQUEST_SENSE:
		AAC_DPRINTF(AAC_D_CMD, ("REQUEST SENSE tgt %d ", target));
		bzero(&sd, sizeof sd);
		sd.error_code = 0x70;
		sd.segment = 0;
		sd.flags = SKEY_NO_SENSE;
		aac_enc32(sd.info, 0);
		sd.extra_len = 0;
		aac_copy_internal_data(xs, (u_int8_t *)&sd, sizeof sd);
		break;
d620 7
a626 16
	case INQUIRY:
		AAC_DPRINTF(AAC_D_CMD, ("INQUIRY tgt %d devtype %x ", target,
		    sc->sc_hdr[target].hd_devtype));
		bzero(&inq, sizeof inq);
		/* XXX How do we detect removable/CD-ROM devices?  */
		inq.device = T_DIRECT;
		inq.dev_qual2 = 0;
		inq.version = 2;
		inq.response_format = 2;
		inq.additional_length = 32;
		strlcpy(inq.vendor, "Adaptec", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Container #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
		aac_copy_internal_data(xs, (u_int8_t *)&inq, sizeof inq);
		break;
d628 1
a628 7
	case READ_CAPACITY:
		AAC_DPRINTF(AAC_D_CMD, ("READ CAPACITY tgt %d ", target));
		bzero(&rcd, sizeof rcd);
		_lto4b(sc->sc_hdr[target].hd_size - 1, rcd.addr);
		_lto4b(AAC_BLOCK_SIZE, rcd.length);
		aac_copy_internal_data(xs, (u_int8_t *)&rcd, sizeof rcd);
		break;
d630 1
a630 6
	default:
		AAC_DPRINTF(AAC_D_CMD, ("unsupported scsi command %#x tgt %d ",
		    xs->cmd->opcode, target));
		xs->error = XS_DRIVER_STUFFUP;
		return (0);
	}
d632 3
a634 2
	xs->error = XS_NOERROR;
	return (1);
d636 1
d642 1
a642 2
aac_intr(arg)
	void *arg;
a645 1
	int claimed = 0;
a646 1
	AAC_DPRINTF(AAC_D_INTR, ("aac_intr(%p) ", sc));
d648 6
d655 8
a662 1
	AAC_DPRINTF(AAC_D_INTR, ("istatus 0x%04x ", reason));
d664 33
a696 25
	/* controller wants to talk to the log?  XXX should we defer this? */
	if (reason & AAC_DB_PRINTF) {
		if (sc->sc_common->ac_printf[0]) {
			printf("%s: ** %.*s", sc->sc_dev.dv_xname,
			    AAC_PRINTF_BUFSIZE, sc->sc_common->ac_printf);
			sc->sc_common->ac_printf[0] = 0;
		}
		AAC_CLEAR_ISTATUS(sc, AAC_DB_PRINTF);
		AAC_QNOTIFY(sc, AAC_DB_PRINTF);
		claimed = 1;
	}

	/* Controller has a message for us? */
	if (reason & AAC_DB_COMMAND_READY) {
		aac_host_command(sc);
		AAC_CLEAR_ISTATUS(sc, AAC_DB_COMMAND_READY);
		claimed = 1;
	}
    
	/* Controller has a response for us? */
	if (reason & AAC_DB_RESPONSE_READY) {
		aac_host_response(sc);
		AAC_CLEAR_ISTATUS(sc, AAC_DB_RESPONSE_READY);
		claimed = 1;
	}
a697 10
	/*
	 * Spurious interrupts that we don't use - reset the mask and clear
	 * the interrupts.
	 */
	if (reason & (AAC_DB_SYNC_COMMAND | AAC_DB_COMMAND_NOT_FULL |
            AAC_DB_RESPONSE_NOT_FULL)) {
		AAC_UNMASK_INTERRUPTS(sc);
		AAC_CLEAR_ISTATUS(sc, AAC_DB_SYNC_COMMAND |
		    AAC_DB_COMMAND_NOT_FULL | AAC_DB_RESPONSE_NOT_FULL);
		claimed = 1;
d700 1
a700 1
	return (claimed);
d704 5
a708 1
 * Handle notification of one or more FIBs coming from the controller.
d711 1
a711 1
aac_host_command(struct aac_softc *sc)
d713 10
a722 2
	struct aac_fib *fib;
	u_int32_t fib_size;
d725 5
a729 3
		if (aac_dequeue_fib(sc, AAC_HOST_NORM_CMD_QUEUE, &fib_size,
		    &fib))
			break;	/* nothing to do */
d731 10
a740 6
		switch(fib->Header.Command) {
		case AifRequest:
#if 0
			aac_handle_aif(sc,
			    (struct aac_aif_command *)&fib->data[0]);
#endif
d742 2
a744 6
		default:
			printf("%s: unknown command from controller\n",
			    sc->sc_dev.dv_xname);
			AAC_PRINT_FIB(sc, fib);
			break;
		}
d746 41
a786 2
		/* XXX reply to FIBs requesting responses ?? */
		/* XXX how do we return these FIBs to the controller? */
d788 2
d793 1
a793 1
 * Handle notification of one or more FIBs completed by the controller
d796 1
a796 1
aac_host_response(struct aac_softc *sc)
d798 1
a798 1
	struct aac_ccb *ccb;
d801 28
d830 15
a844 5
	for (;;) {
		/* look for completed FIBs on our queue */
		if (aac_dequeue_fib(sc, AAC_HOST_NORM_RESP_QUEUE, &fib_size,
		    &fib))
			break;	/* nothing to do */
a845 3
		/* get the command, unmap and queue for later processing */
		ccb = (struct aac_ccb *)fib->Header.SenderData;
		if (ccb == NULL) {
d847 36
a882 4
		} else {
			timeout_del(&ccb->ac_xs->stimeout);
			aac_unmap_command(ccb);		/* XXX defer? */
			aac_enqueue_completed(ccb);
d885 10
d896 3
a898 2
	/* handle completion processing */
	aac_complete(sc, 0);
d905 1
a905 1
aac_complete(void *context, int pending)
d908 5
a912 1
	struct aac_ccb *ccb;
d916 15
a930 4
		ccb = aac_dequeue_completed(sc);
		if (ccb == NULL)
			return;
		ccb->ac_flags |= AAC_ACF_COMPLETED;
a931 1
#if 0
d933 2
a934 2
		if (ccb->ac_complete != NULL) {
			ccb->ac_complete(ccb);
d937 1
a937 1
			wakeup(ccb);
a938 3
#else
		aac_bio_complete(ccb);
#endif
d940 5
d948 1
a948 1
 * Handle a bio-instigated command that has been completed.
d950 2
a951 2
void
aac_bio_complete(struct aac_ccb *ccb)
d953 11
a963 6
	struct scsi_xfer *xs = ccb->ac_xs;
	struct aac_softc *sc = xs->sc_link->adapter_softc;
	struct buf *bp = xs->bp;
	struct aac_blockread_response *brr;
	struct aac_blockwrite_response *bwr;
	AAC_FSAStatus status;
d965 110
a1074 2
	if (bp == NULL)
		goto done;
d1078 1
a1078 1
		brr = (struct aac_blockread_response *)&ccb->ac_fib->data[0];
d1081 1
a1081 1
		bwr = (struct aac_blockwrite_response *)&ccb->ac_fib->data[0];
a1083 1
	aac_free_ccb(sc, ccb);
d1091 472
d1564 122
a1685 3
		/* XXX be more verbose? */
		printf("%s: I/O error %d (%s)\n", sc->sc_dev.dv_xname,
		    status, AAC_COMMAND_STATUS(status));
d1688 18
a1705 2
done:
	scsi_done(xs);
d1712 2
a1713 8
aac_sync_command(sc, command, arg0, arg1, arg2, arg3, sp)
	struct aac_softc *sc;
	u_int32_t command;
	u_int32_t arg0;
	u_int32_t arg1;
	u_int32_t arg2;
	u_int32_t arg3;
	u_int32_t *sp;
d1715 1
d1718 1
a1718 1
	aac_lock_t lock = AAC_LOCK(sc);
d1728 11
d1743 8
a1750 1
		if (AAC_GET_ISTATUS(sc) & AAC_DB_SYNC_COMMAND)
d1755 1
a1755 1
		AAC_UNLOCK(sc, lock);
d1758 1
d1764 2
a1765 2
	status = AAC_GET_MAILBOXSTATUS(sc);
	AAC_UNLOCK(sc, lock);
d1768 30
a1797 1
	return (0);	/* check command return status? */
d1803 263
a2065 9
int
aac_sync_fib(sc, command, xferstate, data, datasize, result, resultsize)
	struct aac_softc *sc;
	u_int32_t command;
	u_int32_t xferstate;
	void *data;
	u_int16_t datasize;
	void *result;
	u_int16_t *resultsize;
d2067 1
a2067 1
	struct aac_fib *fib = &sc->sc_common->ac_sync_fib;
d2069 6
a2074 2
	if (datasize > AAC_FIB_DATASIZE)
		return (EINVAL);
d2076 1
a2076 13
	/*
	 * Set up the sync FIB
	 */
	fib->Header.XferState = AAC_FIBSTATE_HOSTOWNED |
	    AAC_FIBSTATE_INITIALISED | AAC_FIBSTATE_EMPTY;
	fib->Header.XferState |= xferstate;
	fib->Header.Command = command;
	fib->Header.StructType = AAC_FIBTYPE_TFIB;
	fib->Header.Size = sizeof fib + datasize;
	fib->Header.SenderSize = sizeof *fib;
	fib->Header.SenderFibAddress = (u_int32_t)fib;
	fib->Header.ReceiverFibAddress =
	    sc->sc_common_busaddr + offsetof(struct aac_common, ac_sync_fib);
d2078 1
a2078 8
	/*
	 * Copy in data.
	 */
	if (data != NULL) {
		bcopy(data, fib->data, datasize);
		fib->Header.XferState |=
		    AAC_FIBSTATE_FROMHOST | AAC_FIBSTATE_NORM;
	}
d2080 7
a2086 7
	/*
	 * Give the FIB to the controller, wait for a response.
	 */
	if (aac_sync_command(sc, AAC_MONKER_SYNCFIB,
	    fib->Header.ReceiverFibAddress, 0, 0, 0, NULL)) {
		return (EIO);
	}
d2088 2
a2089 6
	/* 
	 * Copy out the result
	 */
	if (result != NULL) {
		*resultsize = fib->Header.Size - sizeof fib->Header;
		bcopy(fib->data, result, *resultsize);
a2090 1
	return (0);
d2094 1
a2094 2
aacminphys(bp)
	struct buf *bp;
d2096 2
a2097 5
#if 0
	u_int8_t *buf = bp->b_data;
	paddr_t pa;
	long off;
#endif
d2099 10
a2108 1
	AAC_DPRINTF(AAC_D_MISC, ("aacminphys(0x%x) ", bp));
d2110 3
a2112 2
	minphys(bp);
}
d2118 1
a2118 2
aac_sa_get_fwstatus(sc)
	struct aac_softc *sc;
d2124 1
a2124 2
aac_rx_get_fwstatus(sc)
	struct aac_softc *sc;
d2129 6
d2140 1
a2140 3
aac_sa_qnotify(sc, qbit)
	struct aac_softc *sc;
	int qbit;
d2146 1
a2146 3
aac_rx_qnotify(sc, qbit)
	struct aac_softc *sc;
	int qbit;
d2151 7
d2162 1
a2162 2
aac_sa_get_istatus(sc)
	struct aac_softc *sc;
d2168 1
a2168 2
aac_rx_get_istatus(sc)
	struct aac_softc *sc;
d2173 6
d2183 1
a2183 3
aac_sa_clear_istatus(sc, mask)
	struct aac_softc *sc;
	int mask;
d2189 1
a2189 3
aac_rx_clear_istatus(sc, mask)
	struct aac_softc *sc;
	int mask;
d2194 7
d2205 2
a2206 7
aac_sa_set_mailbox(sc, command, arg0, arg1, arg2, arg3)
	struct aac_softc *sc;
	u_int32_t command;
	u_int32_t arg0;
	u_int32_t arg1;
	u_int32_t arg2;
	u_int32_t arg3;
d2216 2
a2217 7
aac_rx_set_mailbox(sc, command, arg0, arg1, arg2, arg3)
	struct aac_softc *sc;
	u_int32_t command;
	u_int32_t arg0;
	u_int32_t arg1;
	u_int32_t arg2;
	u_int32_t arg3;
d2226 16
d2246 7
a2252 2
aac_sa_get_mailboxstatus(sc)
	struct aac_softc *sc;
d2254 1
a2254 1
	return (AAC_GETREG4(sc, AAC_SA_MAILBOX));
d2258 1
a2258 2
aac_rx_get_mailboxstatus(sc)
	struct aac_softc *sc;
d2260 1
a2260 1
	return (AAC_GETREG4(sc, AAC_RX_MAILBOX));
d2267 1
a2267 3
aac_sa_set_interrupts(sc, enable)
	struct aac_softc *sc;
	int enable;
d2269 3
d2279 1
a2279 3
aac_rx_set_interrupts(sc, enable)
	struct aac_softc *sc;
	int enable;
d2281 3
a2289 44
struct aac_ccb *
aac_get_ccb(sc, flags)
	struct aac_softc *sc;
	int flags;
{
	struct aac_ccb *ccb;
	aac_lock_t lock;

	AAC_DPRINTF(AAC_D_QUEUE, ("aac_get_ccb(%p, 0x%x) ", sc, flags));

	lock = AAC_LOCK(sc);

	for (;;) {
		ccb = TAILQ_FIRST(&sc->sc_free_ccb);
		if (ccb != NULL)
			break;
		if (flags & SCSI_NOSLEEP)
			goto bail_out;
		tsleep(&sc->sc_free_ccb, PRIBIO, "aac_ccb", 0);
	}

	TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ac_chain);

	/* initialise the command/FIB */
	ccb->ac_sgtable = NULL;
	ccb->ac_flags = 0;
	ccb->ac_fib->Header.XferState = AAC_FIBSTATE_EMPTY;
	ccb->ac_fib->Header.StructType = AAC_FIBTYPE_TFIB;
	ccb->ac_fib->Header.Flags = 0;
	ccb->ac_fib->Header.SenderSize = sizeof(struct aac_fib);

	/* 
	 * These are duplicated in aac_start to cover the case where an
	 * intermediate stage may have destroyed them.  They're left
	 * initialised here for debugging purposes only.
	 */
	ccb->ac_fib->Header.SenderFibAddress = (u_int32_t)ccb->ac_fib;
	ccb->ac_fib->Header.ReceiverFibAddress = ccb->ac_fibphys;

 bail_out:
	AAC_UNLOCK(sc, lock);
	return (ccb);
}

d2291 1
a2291 3
aac_free_ccb(sc, ccb)
	struct aac_softc *sc;
	struct aac_ccb *ccb;
d2293 2
a2294 1
	aac_lock_t lock;
d2296 7
a2302 11
	AAC_DPRINTF(AAC_D_QUEUE, ("aac_free_ccb(%p, %p) ", sc, ccb));

	lock = AAC_LOCK(sc);

	TAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, ac_chain);

	/* If the free list was empty, wake up potential waiters. */
	if (TAILQ_NEXT(ccb, ac_chain) == NULL)
		wakeup(&sc->sc_free_ccb);

	AAC_UNLOCK(sc, lock);
d2306 3
a2308 3
aac_enqueue_ccb(sc, ccb)
	struct aac_softc *sc;
	struct aac_ccb *ccb;
d2310 17
a2326 5
	AAC_DPRINTF(AAC_D_QUEUE, ("aac_enqueue_ccb(%p, %p) ", sc, ccb));

	timeout_set(&ccb->ac_xs->stimeout, aac_timeout, ccb);
	TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ac_chain);
	aac_start_ccbs(sc);
d2330 1
a2330 2
aac_start_ccbs(sc)
	struct aac_softc *sc;
d2332 2
a2333 2
	struct aac_ccb *ccb;
	struct scsi_xfer *xs;
d2335 2
a2336 1
	AAC_DPRINTF(AAC_D_QUEUE, ("aac_start_ccbs(%p) ", sc));
d2338 6
a2343 20
	while ((ccb = TAILQ_FIRST(&sc->sc_ccbq)) != NULL) {

		xs = ccb->ac_xs;
		if (ccb->ac_flags & AAC_ACF_WATCHDOG)
			timeout_del(&xs->stimeout);

		if (aac_exec_ccb(ccb) == 0) {
			ccb->ac_flags |= AAC_ACF_WATCHDOG;
			timeout_set(&ccb->ac_xs->stimeout, aac_watchdog, ccb);
			timeout_add(&xs->stimeout,
			    (AAC_WATCH_TIMEOUT * hz) / 1000);
			break;
		}
		TAILQ_REMOVE(&sc->sc_ccbq, ccb, ac_chain);

		if ((xs->flags & SCSI_POLL) == 0) {
			timeout_set(&ccb->ac_xs->stimeout, aac_timeout, ccb);
			timeout_add(&xs->stimeout,
			    (ccb->ac_timeout * hz) / 1000);
		}
d2347 1
d2349 1
a2349 2
aac_exec_ccb(ccb)
	struct aac_ccb *ccb;
a2350 1
	struct scsi_xfer *xs = ccb->ac_xs;
d2352 4
a2356 5
	int i;
	struct aac_fib *fib;
	struct aac_blockread *br;
	struct aac_blockwrite *bw;
	bus_dmamap_t xfer;
d2358 2
a2359 1
	AAC_DPRINTF(AAC_D_CMD, ("aac_exec_ccb(%p, %p) ", xs, ccb));
d2361 9
a2369 7
	/* build the FIB */
	fib = ccb->ac_fib;
	fib->Header.XferState = AAC_FIBSTATE_HOSTOWNED |
	    AAC_FIBSTATE_INITIALISED | AAC_FIBSTATE_FROMHOST |
	    AAC_FIBSTATE_REXPECTED | AAC_FIBSTATE_NORM;
	fib->Header.Command = ContainerCommand;
	fib->Header.Size = sizeof(struct aac_fib_header);
d2371 9
a2379 9
	switch (xs->cmd->opcode) {
	case PREVENT_ALLOW:
	case SYNCHRONIZE_CACHE:
		if (xs->cmd->opcode == PREVENT_ALLOW) {
			/* XXX PREVENT_ALLOW support goes here */
		} else {
			AAC_DPRINTF(AAC_D_CMD,
			    ("SYNCHRONIZE CACHE tgt %d ", target));
		}
d2382 15
a2396 10
	case WRITE_COMMAND:
	case WRITE_BIG:
		bw = (struct aac_blockwrite *)&fib->data[0];
		bw->Command = VM_CtBlockWrite;
		bw->ContainerId = target;
		bw->BlockNumber = ccb->ac_blockno;
		bw->ByteCount = ccb->ac_blockcnt * DEV_BSIZE;
		bw->Stable = CUNSTABLE;	/* XXX what's appropriate here? */
		fib->Header.Size += sizeof(struct aac_blockwrite);
		ccb->ac_sgtable = &bw->SgMap;
d2399 6
a2404 9
	case READ_COMMAND:
	case READ_BIG:
		br = (struct aac_blockread *)&fib->data[0];
		br->Command = VM_CtBlockRead;
		br->ContainerId = target;
		br->BlockNumber = ccb->ac_blockno;
		br->ByteCount = ccb->ac_blockcnt * DEV_BSIZE;
		fib->Header.Size += sizeof(struct aac_blockread);
		ccb->ac_sgtable = &br->SgMap;
a2405 1
	}
d2407 6
a2412 18
	if (xs->cmd->opcode != PREVENT_ALLOW &&
	    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
		xfer = ccb->ac_dmamap_xfer;
		ccb->ac_sgtable->SgCount = xfer->dm_nsegs;
		for (i = 0; i < xfer->dm_nsegs; i++) {
			ccb->ac_sgtable->SgEntry[i].SgAddress =
			    xfer->dm_segs[i].ds_addr;
			ccb->ac_sgtable->SgEntry[i].SgByteCount =
			    xfer->dm_segs[i].ds_len;
			AAC_DPRINTF(AAC_D_IO,
			    ("#%d va %p pa %p len %x\n", i, buf,
			    xfer->dm_segs[i].ds_addr,
			    xfer->dm_segs[i].ds_len));
		}

		/* update the FIB size for the s/g count */
		fib->Header.Size += xfer->dm_nsegs *
		    sizeof(struct aac_sg_entry);
d2415 2
a2416 6
	if (aac_start(ccb) == 0) {
		xs->error = XS_NOERROR;
		xs->resid = 0;
		return (1);
	}
	return (0);
d2419 2
a2420 6
/********************************************************************************
 * Deliver a command to the controller; allocate controller resources at the
 * last moment when possible.
 */
int
aac_start(struct aac_ccb *ccb)
a2421 2
	struct aac_softc *sc = ccb->ac_xs->sc_link->adapter_softc;

d2423 3
a2425 2
	/* get the command mapped */
	aac_map_command(ccb);
d2428 6
a2433 3
	/* fix up the address values */
	ccb->ac_fib->Header.SenderFibAddress = (u_int32_t)ccb->ac_fib;
	ccb->ac_fib->Header.ReceiverFibAddress = ccb->ac_fibphys;
d2435 10
a2444 2
	/* save a pointer to the command for speedy reverse-lookup */
	ccb->ac_fib->Header.SenderData = (u_int32_t)ccb; /* XXX ack, sizing */
d2446 8
a2453 3
	/* put the FIB on the outbound queue */
	if (aac_enqueue_fib(sc, AAC_ADAP_NORM_CMD_QUEUE, ccb))
		return (EBUSY);
d2455 3
a2457 1
	return (0);
a2459 3
/*
 * Map a command into controller-visible space.
 */
d2461 1
a2461 1
aac_map_command(struct aac_ccb *ccb)
d2463 11
a2473 3
	struct scsi_xfer *xs = ccb->ac_xs;
	struct aac_softc *sc = xs->sc_link->adapter_softc;
	int error;
d2475 11
a2485 25
#if 0
	/* don't map more than once */
	if (ccb->ac_flags & AAC_CMD_MAPPED)
		return;
#endif

	if (xs->datalen != 0) {
		error = bus_dmamap_load(sc->sc_dmat, ccb->ac_dmamap_xfer,
		    xs->data, xs->datalen, NULL,
		    (xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT :
		    BUS_DMA_WAITOK);
		if (error) {
			printf("%s: aac_scsi_cmd: ", sc->sc_dev.dv_xname);
			if (error == EFBIG)
				printf("more than %d dma segs\n",
				    AAC_MAXSGENTRIES);
			else
				printf("error %d loading dma map\n", error);
			return (error);
		}

		bus_dmamap_sync(sc->sc_dmat, ccb->ac_dmamap_xfer, 0,
		    ccb->ac_dmamap_xfer->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
		    BUS_DMASYNC_PREWRITE);
d2488 1
a2488 5
#if 0
	ccb->ac_flags |= AAC_CMD_MAPPED;
#endif
	return (0);
}
d2490 4
a2493 8
/*
 * Unmap a command from controller-visible space.
 */
void
aac_unmap_command(struct aac_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->ac_xs;
	struct aac_softc *sc = xs->sc_link->adapter_softc;
d2495 6
d2502 1
a2502 2
	if (!(ccb->ac_flags & AAC_CMD_MAPPED))
		return;
d2504 7
d2512 7
a2518 5
	if (xs->datalen != 0) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ac_dmamap_xfer, 0,
		    ccb->ac_dmamap_xfer->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);
d2520 7
a2526 6
		bus_dmamap_unload(sc->sc_dmat, ccb->ac_dmamap_xfer);
	}
#if 0
	ccb->ac_flags &= ~AAC_CMD_MAPPED;
#endif
}
d2528 7
a2534 8
void
aac_timeout(arg)
	void *arg;
{
	struct aac_ccb *ccb = arg;
	struct scsi_link *link = ccb->ac_xs->sc_link;
	struct aac_softc *sc = link->adapter_softc;
	aac_lock_t lock;
d2536 17
a2552 2
	sc_print_addr(link);
	printf("timed out\n");
d2554 19
a2572 1
	/* XXX Test for multiple timeouts */
d2574 11
a2584 5
	ccb->ac_xs->error = XS_TIMEOUT;
	lock = AAC_LOCK(sc);
	aac_enqueue_ccb(sc, ccb);
	AAC_UNLOCK(sc, lock);
}
d2586 13
a2598 8
void
aac_watchdog(arg)
	void *arg;
{
	struct aac_ccb *ccb = arg;
	struct scsi_link *link = ccb->ac_xs->sc_link;
	struct aac_softc *sc = link->adapter_softc;
	aac_lock_t lock;
d2600 13
a2612 21
	lock = AAC_LOCK(sc);
	ccb->ac_flags &= ~AAC_ACF_WATCHDOG;
	aac_start_ccbs(sc);
	AAC_UNLOCK(sc, lock);
}
/*
 * Insert a command into the driver queue, either at the front or at the tail.
 * It's ok to overload the freelist link as these structures are never on
 * the freelist at this time.
 */
void
aac_enqueue(sc, xs, infront)
	struct aac_softc *sc;
	struct scsi_xfer *xs;
	int infront;
{
	if (infront || LIST_FIRST(&sc->sc_queue) == NULL) {
		if (LIST_FIRST(&sc->sc_queue) == NULL)
			sc->sc_queuelast = xs;
		LIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);
		return;
a2613 3
	LIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);
	sc->sc_queuelast = xs;
}
d2615 6
a2620 8
/*
 * Pull a command off the front of the driver queue.
 */
struct scsi_xfer *
aac_dequeue(sc)
	struct aac_softc *sc;
{
	struct scsi_xfer *xs;
d2622 4
a2625 9
	xs = LIST_FIRST(&sc->sc_queue);
	if (xs == NULL)
		return (NULL);
	LIST_REMOVE(xs, free_list);

	if (LIST_FIRST(&sc->sc_queue) == NULL)
		sc->sc_queuelast = NULL;

	return (xs);
d2628 2
a2629 5
/********************************************************************************
 * Adapter-space FIB queue manipulation
 *
 * Note that the queue implementation here is a little funky; neither the PI or
 * CI will ever be zero.  This behaviour is a controller feature.
a2630 13
static struct {
	int size;
	int notify;
} aac_qinfo[] = {
	{ AAC_HOST_NORM_CMD_ENTRIES, AAC_DB_COMMAND_NOT_FULL },
	{ AAC_HOST_HIGH_CMD_ENTRIES, 0 },
	{ AAC_ADAP_NORM_CMD_ENTRIES, AAC_DB_COMMAND_READY },
	{ AAC_ADAP_HIGH_CMD_ENTRIES, 0 },
	{ AAC_HOST_NORM_RESP_ENTRIES, AAC_DB_RESPONSE_NOT_FULL },
	{ AAC_HOST_HIGH_RESP_ENTRIES, 0 },
	{ AAC_ADAP_NORM_RESP_ENTRIES, AAC_DB_RESPONSE_READY },
	{ AAC_ADAP_HIGH_RESP_ENTRIES, 0 }
};
d2633 1
a2633 6
 * Atomically insert an entry into the nominated queue, returns 0 on success
 * or EBUSY if the queue is full.
 *
 * XXX Note that it would be more efficient to defer notifying the controller
 * in the case where we may be inserting several entries in rapid succession,
 * but implementing this usefully is difficult.
d2635 2
a2636 2
int
aac_enqueue_fib(struct aac_softc *sc, int queue, struct aac_ccb *ccb)
d2638 2
a2639 5
	u_int32_t pi, ci;
	int error;
	aac_lock_t lock;
	u_int32_t fib_size;
	u_int32_t fib_addr;
d2641 1
a2641 2
	fib_size = ccb->ac_fib->Header.Size;
	fib_addr = ccb->ac_fib->Header.ReceiverFibAddress;
d2643 6
a2648 14
	lock = AAC_LOCK(sc);

	/* get the producer/consumer indices */
	pi = sc->sc_queues->qt_qindex[queue][AAC_PRODUCER_INDEX];
	ci = sc->sc_queues->qt_qindex[queue][AAC_CONSUMER_INDEX];

	/* wrap the queue? */
	if (pi >= aac_qinfo[queue].size)
		pi = 0;

	/* check for queue full */
	if ((pi + 1) == ci) {
		error = EBUSY;
		goto out;
d2650 1
d2652 4
a2655 3
	/* populate queue entry */
	(sc->sc_qentries[queue] + pi)->aq_fib_size = fib_size;
	(sc->sc_qentries[queue] + pi)->aq_fib_addr = fib_addr;
d2657 9
a2665 2
	/* update producer index */
	sc->sc_queues->qt_qindex[queue][AAC_PRODUCER_INDEX] = pi + 1;
d2667 1
a2667 3
	/* notify the adapter if we know how */
	if (aac_qinfo[queue].notify != 0)
		AAC_QNOTIFY(sc, aac_qinfo[queue].notify);
d2669 20
a2688 5
	error = 0;

out:
	AAC_UNLOCK(sc, lock);
	return (error);
d2692 2
a2693 2
 * Atomically remove one entry from the nominated queue, returns 0 on success
 * or ENOENT if the queue is empty.
d2695 2
a2696 3
int
aac_dequeue_fib(struct aac_softc *sc, int queue, u_int32_t *fib_size,
    struct aac_fib **fib_addr)
d2698 1
a2698 4
	u_int32_t pi, ci;
	int notify;
	int error;
	aac_lock_t lock;
d2700 4
a2703 36
	lock = AAC_LOCK(sc);

	/* get the producer/consumer indices */
	pi = sc->sc_queues->qt_qindex[queue][AAC_PRODUCER_INDEX];
	ci = sc->sc_queues->qt_qindex[queue][AAC_CONSUMER_INDEX];

	/* check for queue empty */
	if (ci == pi) {
		error = ENOENT;
		goto out;
	}

	notify = 0;
	if (ci == pi + 1)
		notify++;

	/* wrap the queue? */
	if (ci >= aac_qinfo[queue].size)
		ci = 0;

	/* fetch the entry */
	*fib_size = (sc->sc_qentries[queue] + ci)->aq_fib_size;
	*fib_addr =
	    (struct aac_fib *)(sc->sc_qentries[queue] + ci)->aq_fib_addr;

	/* update consumer index */
	sc->sc_queues->qt_qindex[queue][AAC_CONSUMER_INDEX] = ci + 1;

	/* if we have made the queue un-full, notify the adapter */
	if (notify && (aac_qinfo[queue].notify != 0))
		AAC_QNOTIFY(sc, aac_qinfo[queue].notify);
	error = 0;

out:
	AAC_UNLOCK(sc, lock);
	return (error);
d2775 282
@


1.23
log
@Test xs->bp before de-referencing it. Initialize it to NULL, not 0.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.22 2005/08/21 02:31:13 krw Exp $	*/
a814 5
	struct {
		struct scsi_mode_header hd;
		struct scsi_blk_desc bd;
		union scsi_disk_pages dp;
	} mpd;
a857 36
	case MODE_SENSE:
		AAC_DPRINTF(AAC_D_CMD, ("MODE SENSE tgt %d ", target));

		bzero(&mpd, sizeof mpd);
		switch (((struct scsi_mode_sense *)xs->cmd)->page) {
		case 4:
			/* scsi_disk.h says this should be 0x16 */
			mpd.dp.rigid_geometry.pg_length = 0x16;
			mpd.hd.data_length = sizeof mpd.hd -
			    sizeof mpd.hd.data_length + sizeof mpd.bd +
			    sizeof mpd.dp.rigid_geometry;
			mpd.hd.blk_desc_len = sizeof mpd.bd;

			/* XXX */
			mpd.hd.dev_spec = 0;
			_lto3b(AAC_BLOCK_SIZE, mpd.bd.blklen);
			mpd.dp.rigid_geometry.pg_code = 4;
			_lto3b(sc->sc_hdr[target].hd_size /
			    sc->sc_hdr[target].hd_heads /
			    sc->sc_hdr[target].hd_secs,
			    mpd.dp.rigid_geometry.ncyl);
			mpd.dp.rigid_geometry.nheads =
			    sc->sc_hdr[target].hd_heads;
			aac_copy_internal_data(xs, (u_int8_t *)&mpd,
			    sizeof mpd);
			break;

		default:
			printf("%s: mode sense page %d not simulated\n",
			    sc->sc_dev.dv_xname,
			    ((struct scsi_mode_sense *)xs->cmd)->page);
			xs->error = XS_DRIVER_STUFFUP;
			return (0);
		}
		break;

d867 2
a868 2
		printf("aac_internal_cache_cmd got bad opcode: %d\n",
		    xs->cmd->opcode);
@


1.22
log
@Parameter being passed __func__ must be const char *. Allows aac to
compile with AAC_DEBUG set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.21 2005/07/03 22:31:27 krw Exp $	*/
d1083 3
d1107 2
@


1.21
log
@Fix data_length values in simulationed MODE SENSE page 4 responses so
that scsi_do_mode_sense() accepts them.

The data_length value does not include itself, and the pg_length value
in a mode page does not include itself or the page_code fields. We
were +1 on the former and -2 on the latter resulting in a data_length
value that was too small by one.

Eliminates 'mode sense page 5 not simulated' messages.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.20 2005/05/26 23:53:14 martin Exp $	*/
d98 1
a98 1
void	aac_print_fib(struct aac_softc *, struct aac_fib *, char *);
d1877 1
a1877 1
aac_print_fib(struct aac_softc *sc, struct aac_fib *fib, char *caller)
@


1.20
log
@remove unused vtophys stuff

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.19 2004/03/20 03:58:09 aaron Exp $	*/
d871 3
a873 2
			mpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +
			    mpd.dp.rigid_geometry.pg_length;
@


1.19
log
@Remove errant ';' at end of if() statement that was causing pre-mature
termination of the timeout loop in aac_sync_command().  Appears to only have
affected attach/init time procedure.  Thanks Marco Peereboom for testing, and
ok'd by others.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.18 2004/01/10 00:13:36 brad Exp $	*/
a1225 13
#if 1
#if 0	/* As this is way more than MAXPHYS it's really not necessary. */
	if (bp->b_bcount > ((AAC_MAXOFFSETS - 1) * PAGE_SIZE))
		bp->b_bcount = ((AAC_MAXOFFSETS - 1) * PAGE_SIZE);
#endif
#else
	for (off = PAGE_SIZE, pa = vtophys(buf); off < bp->b_bcount;
	    off += PAGE_SIZE)
		if (pa + off != vtophys(buf + off)) {
			bp->b_bcount = off;
			break;
		}
#endif
@


1.18
log
@oops, revert change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.17 2004/01/09 21:32:23 brad Exp $	*/
d1135 1
a1135 1
		if (AAC_GET_ISTATUS(sc) & AAC_DB_SYNC_COMMAND);
@


1.17
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.16 2003/09/02 21:20:40 fgsch Exp $	*/
d53 2
@


1.16
log
@- drop number of openings by 4 to avoid "not queued" errors.
- check return from aac_start() and return correctly in case
  we need to reschedule the watchdog.

convervative fix from niklas@@, prompted by several ppl.
krw and deraadt ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.15 2003/04/27 11:22:52 ho Exp $	*/
a52 2

#include <uvm/uvm_extern.h>
@


1.15
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.14 2002/03/27 15:02:59 niklas Exp $	*/
d244 6
a249 1
	sc->sc_link.openings = AAC_ADAP_NORM_CMD_ENTRIES; /* XXX optimal? */
d1578 6
a1583 5
	aac_start(ccb);

	xs->error = XS_NOERROR;
	xs->resid = 0;
	return (1);
@


1.14
log
@From FreeBSD: check for FIFO becoming unfull correctly, in the case of consumer index wrapping.
Improve an internal API. ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.13 2002/03/14 01:26:53 millert Exp $	*/
d851 4
a854 3
		strcpy(inq.vendor, "Adaptec");
		sprintf(inq.product, "Container #%02d", target);
		strcpy(inq.revision, "   ");
@


1.14.6.1
log
@MFC:
Fix by fgsch@@

- drop number of openings by 4 to avoid "not queued" errors.
- check return from aac_start() and return correctly in case
we need to reschedule the watchdog.

convervative fix from niklas@@, prompted by several ppl.
krw and deraadt ok.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.14 2002/03/27 15:02:59 niklas Exp $	*/
d244 1
a244 6
	/*
	 * XXX Theoretically this should be AAC_ADAP_NORM_CMD_ENTRIES but
	 * XXX in some configurations this can cause "not queued" errors.
	 * XXX A quarter of that number has been reported to be safe.
	 */
	sc->sc_link.openings = AAC_ADAP_NORM_CMD_ENTRIES / 4;
d1572 5
a1576 6
	if (aac_start(ccb) == 0) {
		xs->error = XS_NOERROR;
		xs->resid = 0;
		return (1);
	}
	return (0);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.12 2002/03/05 07:46:44 niklas Exp $	*/
d84 1
a84 1
int	aac_enqueue_fib(struct aac_softc *, int, u_int32_t, u_int32_t);
d1601 1
a1601 2
	if (aac_enqueue_fib(sc, AAC_ADAP_NORM_CMD_QUEUE,
	    ccb->ac_fib->Header.Size, ccb->ac_fib->Header.ReceiverFibAddress))
d1781 1
a1781 2
aac_enqueue_fib(struct aac_softc *sc, int queue, u_int32_t fib_size,
    u_int32_t fib_addr)
d1786 5
d1835 1
d1850 5
a1854 1
    
d1868 1
a1868 1
	if (((pi + 1) == ci) && (aac_qinfo[queue].notify != 0))
@


1.12
log
@doh, thanks mickey!
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.11 2002/03/05 06:51:39 niklas Exp $	*/
d74 15
a88 15
void	aac_bio_complete __P((struct aac_ccb *));
void	aac_complete __P((void *, int));
void	aac_copy_internal_data __P((struct scsi_xfer *, u_int8_t *, size_t));
struct scsi_xfer *aac_dequeue __P((struct aac_softc *));
int	aac_dequeue_fib __P((struct aac_softc *, int, u_int32_t *,
    struct aac_fib **));
char   *aac_describe_code __P((struct aac_code_lookup *, u_int32_t));
void	aac_describe_controller __P((struct aac_softc *));
void	aac_enqueue __P((struct aac_softc *, struct scsi_xfer *, int));
void	aac_enqueue_ccb __P((struct aac_softc *, struct aac_ccb *));
int	aac_enqueue_fib __P((struct aac_softc *, int, u_int32_t, u_int32_t));
void	aac_eval_mapping __P((u_int32_t, int *, int *, int *));
int	aac_exec_ccb __P((struct aac_ccb *));
void	aac_free_ccb __P((struct aac_softc *, struct aac_ccb *));
struct aac_ccb *aac_get_ccb __P((struct aac_softc *, int));
d90 1
a90 1
void	aac_handle_aif __P((struct aac_softc *, struct aac_aif_command *));
d92 5
a96 5
void	aac_host_command __P((struct aac_softc *));
void	aac_host_response __P((struct aac_softc *));
int	aac_init __P((struct aac_softc *));
int	aac_internal_cache_cmd __P((struct scsi_xfer *));
int	aac_map_command __P((struct aac_ccb *));
d98 1
a98 1
void	aac_print_fib __P((struct aac_softc *, struct aac_fib *, char *));
d100 12
a111 12
int	aac_raw_scsi_cmd __P((struct scsi_xfer *));
int	aac_scsi_cmd __P((struct scsi_xfer *));
int	aac_start __P((struct aac_ccb *));
void	aac_start_ccbs __P((struct aac_softc *));
void	aac_startup __P((struct aac_softc *));
int	aac_sync_command __P((struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t, u_int32_t *));
int	aac_sync_fib __P((struct aac_softc *, u_int32_t, u_int32_t, void *,
    u_int16_t, void *, u_int16_t *));
void	aac_timeout __P((void *));
void	aac_unmap_command __P((struct aac_ccb *));
void	aac_watchdog __P((void *));
d130 8
a137 8
int	aac_rx_get_fwstatus __P((struct aac_softc *));
void	aac_rx_qnotify __P((struct aac_softc *, int));
int	aac_rx_get_istatus __P((struct aac_softc *));
void	aac_rx_clear_istatus __P((struct aac_softc *, int));
void	aac_rx_set_mailbox __P((struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t));
int	aac_rx_get_mailboxstatus __P((struct aac_softc *));
void	aac_rx_set_interrupts __P((struct aac_softc *, int));
d140 8
a147 8
int	aac_sa_get_fwstatus __P((struct aac_softc *));
void	aac_sa_qnotify __P((struct aac_softc *, int));
int	aac_sa_get_istatus __P((struct aac_softc *));
void	aac_sa_clear_istatus __P((struct aac_softc *, int));
void	aac_sa_set_mailbox __P((struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t));
int	aac_sa_get_mailboxstatus __P((struct aac_softc *));
void	aac_sa_set_interrupts __P((struct aac_softc *, int));
@


1.11
log
@Deal gracefully with ccb starvation
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.10 2001/11/06 19:53:18 miod Exp $	*/
d734 2
a735 2
				xs->flags |= TRY_AGAIN_LATER;
				goto ready;
@


1.10
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.9 2001/11/05 17:25:58 art Exp $	*/
d730 1
a730 2
			 * Are we out of commands, something is wrong.
			 * 
a732 2
				printf("%s: no ccb in aac_scsi_cmd",
				    sc->sc_dev.dv_xname);
d734 1
a734 2
				xs->flags |= ITSDONE;
				scsi_done(xs);
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.10 2001/11/06 19:53:18 miod Exp $	*/
d74 15
a88 15
void	aac_bio_complete(struct aac_ccb *);
void	aac_complete(void *, int);
void	aac_copy_internal_data(struct scsi_xfer *, u_int8_t *, size_t);
struct scsi_xfer *aac_dequeue(struct aac_softc *);
int	aac_dequeue_fib(struct aac_softc *, int, u_int32_t *,
    struct aac_fib **);
char   *aac_describe_code(struct aac_code_lookup *, u_int32_t);
void	aac_describe_controller(struct aac_softc *);
void	aac_enqueue(struct aac_softc *, struct scsi_xfer *, int);
void	aac_enqueue_ccb(struct aac_softc *, struct aac_ccb *);
int	aac_enqueue_fib(struct aac_softc *, int, struct aac_ccb *);
void	aac_eval_mapping(u_int32_t, int *, int *, int *);
int	aac_exec_ccb(struct aac_ccb *);
void	aac_free_ccb(struct aac_softc *, struct aac_ccb *);
struct aac_ccb *aac_get_ccb(struct aac_softc *, int);
d90 1
a90 1
void	aac_handle_aif(struct aac_softc *, struct aac_aif_command *);
d92 5
a96 5
void	aac_host_command(struct aac_softc *);
void	aac_host_response(struct aac_softc *);
int	aac_init(struct aac_softc *);
int	aac_internal_cache_cmd(struct scsi_xfer *);
int	aac_map_command(struct aac_ccb *);
d98 1
a98 1
void	aac_print_fib(struct aac_softc *, struct aac_fib *, char *);
d100 12
a111 12
int	aac_raw_scsi_cmd(struct scsi_xfer *);
int	aac_scsi_cmd(struct scsi_xfer *);
int	aac_start(struct aac_ccb *);
void	aac_start_ccbs(struct aac_softc *);
void	aac_startup(struct aac_softc *);
int	aac_sync_command(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t, u_int32_t *);
int	aac_sync_fib(struct aac_softc *, u_int32_t, u_int32_t, void *,
    u_int16_t, void *, u_int16_t *);
void	aac_timeout(void *);
void	aac_unmap_command(struct aac_ccb *);
void	aac_watchdog(void *);
d130 8
a137 8
int	aac_rx_get_fwstatus(struct aac_softc *);
void	aac_rx_qnotify(struct aac_softc *, int);
int	aac_rx_get_istatus(struct aac_softc *);
void	aac_rx_clear_istatus(struct aac_softc *, int);
void	aac_rx_set_mailbox(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t);
int	aac_rx_get_mailboxstatus(struct aac_softc *);
void	aac_rx_set_interrupts(struct aac_softc *, int);
d140 8
a147 8
int	aac_sa_get_fwstatus(struct aac_softc *);
void	aac_sa_qnotify(struct aac_softc *, int);
int	aac_sa_get_istatus(struct aac_softc *);
void	aac_sa_clear_istatus(struct aac_softc *, int);
void	aac_sa_set_mailbox(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t);
int	aac_sa_get_mailboxstatus(struct aac_softc *);
void	aac_sa_set_interrupts(struct aac_softc *, int);
d730 2
a731 1
			 * We are out of commands, try again in a little while.
d734 2
d737 3
a739 2
				AAC_UNLOCK(sc, lock);
				return (TRY_AGAIN_LATER);
d1605 2
a1606 1
	if (aac_enqueue_fib(sc, AAC_ADAP_NORM_CMD_QUEUE, ccb))
d1786 2
a1787 1
aac_enqueue_fib(struct aac_softc *sc, int queue, struct aac_ccb *ccb)
a1791 5
	u_int32_t fib_size;
	u_int32_t fib_addr;

	fib_size = ccb->ac_fib->Header.Size;
	fib_addr = ccb->ac_fib->Header.ReceiverFibAddress;
a1835 1
	int notify;
d1850 1
a1850 5

	notify = 0;
	if (ci == pi + 1)
		notify++;

d1864 1
a1864 1
	if (notify && (aac_qinfo[queue].notify != 0))
@


1.10.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d851 3
a853 4
		strlcpy(inq.vendor, "Adaptec", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Container #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
@


1.9
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.8 2001/09/21 17:55:43 miod Exp $	*/
d54 1
a54 1
#include <vm/vm.h>
@


1.8
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.7 2001/08/12 20:12:11 mickey Exp $	*/
d1643 2
a1644 1
		bus_dmamap_sync(sc->sc_dmat, ccb->ac_dmamap_xfer,
d1670 2
a1671 1
		bus_dmamap_sync(sc->sc_dmat, ccb->ac_dmamap_xfer,
@


1.7
log
@remove some of the redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.6 2001/07/04 06:49:28 niklas Exp $	*/
d1098 2
a1099 2
		printf("%s: I/O error %d (%s)\n", status,
		    AAC_COMMAND_STATUS(status));
@


1.6
log
@Use the right target when checking for out of bounds.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.5 2001/06/27 01:55:28 niklas Exp $	*/
a54 1
#include <vm/pmap.h>
@


1.5
log
@Pastos from the inception
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.4 2001/04/06 04:42:06 csapuntz Exp $	*/
d642 2
@


1.4
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.3 2000/12/13 16:03:11 mickey Exp $	*/
d635 1
a635 1
	/* Don't double enqueue if we came from gdt_chain. */
d1225 2
a1226 2
	if (bp->b_bcount > ((GDT_MAXOFFSETS - 1) * PAGE_SIZE))
		bp->b_bcount = ((GDT_MAXOFFSETS - 1) * PAGE_SIZE);
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.4 2001/04/06 04:42:06 csapuntz Exp $	*/
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.4.4.1 2001/05/14 22:23:18 niklas Exp $	*/
d635 1
a635 1
	/* Don't double enqueue if we came from aac_chain. */
d1225 2
a1226 2
	if (bp->b_bcount > ((AAC_MAXOFFSETS - 1) * PAGE_SIZE))
		bp->b_bcount = ((AAC_MAXOFFSETS - 1) * PAGE_SIZE);
@


1.4.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.4.4.2 2001/07/04 10:40:20 niklas Exp $	*/
d55 1
a641 2
		link = xs->sc_link;
		target = link->target;
d1097 2
a1098 2
		printf("%s: I/O error %d (%s)\n", sc->sc_dev.dv_xname,
		    status, AAC_COMMAND_STATUS(status));
@


1.4.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
#include <uvm/uvm_extern.h>
d1643 1
a1643 2
		bus_dmamap_sync(sc->sc_dmat, ccb->ac_dmamap_xfer, 0,
		    ccb->ac_dmamap_xfer->dm_mapsize,
d1669 1
a1669 2
		bus_dmamap_sync(sc->sc_dmat, ccb->ac_dmamap_xfer, 0,
		    ccb->ac_dmamap_xfer->dm_mapsize,
@


1.4.4.5
log
@Merge in trunk
@
text
@d730 2
a731 1
			 * We are out of commands, try again in a little while.
d734 2
d737 3
a739 2
				AAC_UNLOCK(sc, lock);
				return (TRY_AGAIN_LATER);
@


1.4.4.6
log
@Merge in -current from about a week ago
@
text
@d74 15
a88 15
void	aac_bio_complete(struct aac_ccb *);
void	aac_complete(void *, int);
void	aac_copy_internal_data(struct scsi_xfer *, u_int8_t *, size_t);
struct scsi_xfer *aac_dequeue(struct aac_softc *);
int	aac_dequeue_fib(struct aac_softc *, int, u_int32_t *,
    struct aac_fib **);
char   *aac_describe_code(struct aac_code_lookup *, u_int32_t);
void	aac_describe_controller(struct aac_softc *);
void	aac_enqueue(struct aac_softc *, struct scsi_xfer *, int);
void	aac_enqueue_ccb(struct aac_softc *, struct aac_ccb *);
int	aac_enqueue_fib(struct aac_softc *, int, u_int32_t, u_int32_t);
void	aac_eval_mapping(u_int32_t, int *, int *, int *);
int	aac_exec_ccb(struct aac_ccb *);
void	aac_free_ccb(struct aac_softc *, struct aac_ccb *);
struct aac_ccb *aac_get_ccb(struct aac_softc *, int);
d90 1
a90 1
void	aac_handle_aif(struct aac_softc *, struct aac_aif_command *);
d92 5
a96 5
void	aac_host_command(struct aac_softc *);
void	aac_host_response(struct aac_softc *);
int	aac_init(struct aac_softc *);
int	aac_internal_cache_cmd(struct scsi_xfer *);
int	aac_map_command(struct aac_ccb *);
d98 1
a98 1
void	aac_print_fib(struct aac_softc *, struct aac_fib *, char *);
d100 12
a111 12
int	aac_raw_scsi_cmd(struct scsi_xfer *);
int	aac_scsi_cmd(struct scsi_xfer *);
int	aac_start(struct aac_ccb *);
void	aac_start_ccbs(struct aac_softc *);
void	aac_startup(struct aac_softc *);
int	aac_sync_command(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t, u_int32_t *);
int	aac_sync_fib(struct aac_softc *, u_int32_t, u_int32_t, void *,
    u_int16_t, void *, u_int16_t *);
void	aac_timeout(void *);
void	aac_unmap_command(struct aac_ccb *);
void	aac_watchdog(void *);
d130 8
a137 8
int	aac_rx_get_fwstatus(struct aac_softc *);
void	aac_rx_qnotify(struct aac_softc *, int);
int	aac_rx_get_istatus(struct aac_softc *);
void	aac_rx_clear_istatus(struct aac_softc *, int);
void	aac_rx_set_mailbox(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t);
int	aac_rx_get_mailboxstatus(struct aac_softc *);
void	aac_rx_set_interrupts(struct aac_softc *, int);
d140 8
a147 8
int	aac_sa_get_fwstatus(struct aac_softc *);
void	aac_sa_qnotify(struct aac_softc *, int);
int	aac_sa_get_istatus(struct aac_softc *);
void	aac_sa_clear_istatus(struct aac_softc *, int);
void	aac_sa_set_mailbox(struct aac_softc *, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, u_int32_t);
int	aac_sa_get_mailboxstatus(struct aac_softc *);
void	aac_sa_set_interrupts(struct aac_softc *, int);
@


1.4.4.7
log
@Sync the SMP branch with 3.3
@
text
@d84 1
a84 1
int	aac_enqueue_fib(struct aac_softc *, int, struct aac_ccb *);
d1601 2
a1602 1
	if (aac_enqueue_fib(sc, AAC_ADAP_NORM_CMD_QUEUE, ccb))
d1782 2
a1783 1
aac_enqueue_fib(struct aac_softc *sc, int queue, struct aac_ccb *ccb)
a1787 5
	u_int32_t fib_size;
	u_int32_t fib_addr;

	fib_size = ccb->ac_fib->Header.Size;
	fib_addr = ccb->ac_fib->Header.ReceiverFibAddress;
a1831 1
	int notify;
d1846 1
a1846 5

	notify = 0;
	if (ci == pi + 1)
		notify++;

d1860 1
a1860 1
	if (notify && (aac_qinfo[queue].notify != 0))
@


1.4.4.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.4.4.7 2003/03/28 00:38:11 niklas Exp $	*/
d851 3
a853 4
		strlcpy(inq.vendor, "Adaptec", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Container #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
@


1.4.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d244 1
a244 6
	/*
	 * XXX Theoretically this should be AAC_ADAP_NORM_CMD_ENTRIES but
	 * XXX in some configurations this can cause "not queued" errors.
	 * XXX A quarter of that number has been reported to be safe.
	 */
	sc->sc_link.openings = AAC_ADAP_NORM_CMD_ENTRIES / 4;
d1573 5
a1577 6
	if (aac_start(ccb) == 0) {
		xs->error = XS_NOERROR;
		xs->resid = 0;
		return (1);
	}
	return (0);
@


1.4.4.10
log
@Merge with the trunk
@
text
@d1135 1
a1135 1
		if (AAC_GET_ISTATUS(sc) & AAC_DB_SYNC_COMMAND)
@


1.3
log
@better new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.2 2000/12/13 15:32:39 mickey Exp $	*/
a63 3

/* XXX from stddef.h */
#define	offsetof(type, member)	((size_t)(&((type *)0)->member))
@


1.2
log
@new timwouts; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: aac.c,v 1.1 2000/11/10 09:39:35 niklas Exp $	*/
d1485 1
d1492 2
a1493 1
		if ((xs->flags & SCSI_POLL) == 0)
d1496 1
@


1.1
log
@Adaptec "FSA" RAID driver
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1029 1
a1029 1
			untimeout(aac_timeout, ccb);
d1463 1
d1473 1
d1478 2
d1481 1
a1481 1
			untimeout(aac_watchdog, ccb);
d1485 1
a1485 1
			timeout(aac_watchdog, ccb,
d1491 2
a1492 2
		if ((ccb->ac_xs->flags & SCSI_POLL) == 0)
			timeout(aac_timeout, ccb,
@

