head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.16
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.10
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.12
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.4
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.8
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.6
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.4
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.5.0.6
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.2
	SMP_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2013.03.04.00.41.54;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2012.08.15.02.38.14;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.08.08.26.41;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.19.23.59.11;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.19.21.17.07;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.12.17.51.33;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.01.17.30.56;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.11.14.03.35;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.28.00.34.25;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.07.23.18.59;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.07.20.34.09;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.26.23.44.44;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.16.09.29.35;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.20.49.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.11.03.34.53;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.10.09.42.14;	author niklas;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2000.08.05.18.52.34;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.01.22.38.51;	author niklas;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.02.07.04.30.21;	author itojun;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.02.07.00.33.03;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2000.03.02.07.04.38;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.05.14.22.23.48;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2000.10.20.18.29.27;	author jason;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@replace the LIST_ENTRY in scsi_xfer with a SIMPLEQ_ENTRY. the things that
use it want something they can add to the end of they do horrible things
to be able to do that with the LIST_ENTRY.

this makes those horrible things a bit less horrible, and makes it easier
to use lists of scsi_xfers in other things.
@
text
@/*	$OpenBSD: gdtvar.h,v 1.21 2012/08/15 02:38:14 jsg Exp $	*/

/*
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This driver would not have written if it was not for the hardware donations
 * from both ICP-Vortex and Öko.neT.  I want to thank them for their support.
 */

#define DEVNAME(s)  ((s)->sc_dev.dv_xname)
#define GDT_CMD_RESERVE	4	/* Internal driver cmd reserve. */

#define GDT_SCRATCH_SZ 4096

#ifdef _KERNEL

/* Debugging */
/* #define GDT_DEBUG	GDT_D_IOCTL | GDT_D_INFO */
#ifdef GDT_DEBUG
#define GDT_DPRINTF(mask, args) if (gdt_debug & (mask)) printf args
#define GDT_D_INTR	0x01
#define GDT_D_MISC	0x02
#define GDT_D_CMD	0x04
#define GDT_D_QUEUE	0x08
#define GDT_D_IO	0x10
#define GDT_D_IOCTL	0x20
#define GDT_D_INFO	0x40
extern int gdt_debug;
#else
#define GDT_DPRINTF(mask, args)
#endif

/* Miscellaneous constants */
#define GDT_RETRIES		100000000	/* 100000 * 1us = 100s */
#define GDT_TIMEOUT		100000000	/* 100000 * 1us = 100s */
#define GDT_POLL_TIMEOUT	10000		/* 10000 * 1ms = 10s */
#define GDT_WATCH_TIMEOUT	10000		/* 10000 * 1ms = 10s */

/* Context structure for interrupt services */
struct gdt_intr_ctx {
	u_int32_t info, info2;
	u_int16_t cmd_status, service;
	u_int8_t istatus;
};

/*
 * A command contol block, one for each corresponding command index of the
 * controller.
 */
struct gdt_ccb {
	TAILQ_ENTRY(gdt_ccb) gc_chain;
	struct scsi_xfer *gc_xs;
	struct gdt_ucmd *gc_ucmd;
	bus_dmamap_t gc_dmamap_xfer;
	int gc_timeout;
	u_int32_t gc_info;
	u_int32_t gc_blockno;
	u_int32_t gc_blockcnt;
	u_int16_t gc_status;
	u_int8_t gc_service;
	u_int8_t gc_cmd_index;
	u_int8_t gc_flags;
#define GDT_GCF_CMD_MASK	0x3
#define GDT_GCF_UNUSED		0	
#define GDT_GCF_INTERNAL	1
#define GDT_GCF_SCREEN 		2
#define GDT_GCF_SCSI 		3
#define GDT_GCF_WATCHDOG 	0x4
};

static inline int gdt_ccb_set_cmd(struct gdt_ccb *, int);
static inline int
gdt_ccb_set_cmd(struct gdt_ccb *ccb, int flag)
{
	int rv = ccb->gc_flags & GDT_GCF_CMD_MASK;

	ccb->gc_flags &= ~GDT_GCF_CMD_MASK;
	ccb->gc_flags |= flag;
	return (rv);
}

struct gdt_softc {
	struct	device sc_dev;
	void   *sc_ih;
	struct	scsi_link sc_link;	/* Virtual SCSI bus for cache devs */

	int	sc_class;		/* Controller class */
#define GDT_ISA		0x01
#define GDT_EISA	0x02
#define GDT_PCI		0x03
#define GDT_PCINEW	0x04
#define GDT_MPR		0x05
#define GDT_CLASS_MASK	0x07
#define GDT_FC		0x10
#define GDT_CLASS(gdt)	((gdt)->sc_class & GDT_CLASS_MASK)

	bus_space_tag_t sc_dpmemt;
	bus_space_handle_t sc_dpmemh;
	bus_addr_t sc_dpmembase;
	bus_dma_tag_t sc_dmat;

	/* XXX These could go into a class-dependent opaque struct instead */
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
	bus_addr_t sc_iobase;

	u_int16_t sc_ic_all_size;

	struct gdt_ccb sc_ccbs[GDT_MAXCMDS];
	TAILQ_HEAD(, gdt_ccb) sc_free_ccb, sc_ccbq;
	TAILQ_HEAD(, gdt_ucmd) sc_ucmdq;
	struct scsi_xfer_list sc_queue;

	struct mutex		sc_ccb_mtx;
	struct scsi_iopool	sc_iopool;

	int	sc_ndevs;

	u_int16_t sc_cmd_len;
	u_int16_t sc_cmd_off;
	u_int16_t sc_cmd_cnt;
	u_int8_t sc_cmd[GDT_CMD_SZ];

	u_int32_t sc_info;
	u_int32_t sc_info2;
	bus_dma_segment_t sc_scratch_seg;
	caddr_t sc_scratch;
	u_int16_t sc_status;

	u_int8_t sc_bus_cnt;
	u_int8_t sc_bus_id[GDT_MAXBUS];
	u_int8_t sc_more_proc;

	u_int32_t sc_total_disks;

	struct {
		u_int8_t hd_present;
		u_int8_t hd_is_logdrv;
		u_int8_t hd_is_arraydrv;
		u_int8_t hd_is_master;
		u_int8_t hd_is_parity;
		u_int8_t hd_is_hotfix;
		u_int8_t hd_master_no;
		u_int8_t hd_lock;
		u_int8_t hd_heads;
		u_int8_t hd_secs;
		u_int16_t hd_devtype;
		u_int32_t hd_size;
		u_int8_t hd_ldr_no;
		u_int8_t hd_rw_attribs;
		u_int32_t hd_start_sec;
	} sc_hdr[GDT_MAX_HDRIVES];

	struct {
		u_int8_t	ra_lock;	/* chan locked? (hot plug */
		u_int8_t	ra_phys_cnt;	/* physical disk count */
		u_int8_t	ra_local_no;	/* local channel number */
		u_int8_t	ra_io_cnt[GDT_MAXID];	/* current IO count */
		u_int32_t	ra_address;	/* channel address */
		u_int32_t	ra_id_list[GDT_MAXID];	/* IDs of phys disks */
	} sc_raw[GDT_MAXBUS];			/* SCSI channels */

	struct {
		u_int32_t cp_version;
		u_int16_t cp_state;
		u_int16_t cp_strategy;
		u_int16_t cp_write_back;
		u_int16_t cp_block_size;
	} sc_cpar;

	struct {
		u_int32_t bi_ser_no;		/* serial number */
		u_int8_t bi_oem_id[2];		/* u_int8_t OEM ID */
		u_int16_t bi_ep_flags;		/* eprom flags */
		u_int32_t bi_proc_id;		/* processor ID */
		u_int32_t bi_memsize;		/* memory size (bytes) */
		u_int8_t bi_mem_banks;		/* memory banks */
		u_int8_t bi_chan_type;		/* channel type */
		u_int8_t bi_chan_count;		/* channel count */
		u_int8_t bi_rdongle_pres;	/* dongle present */
		u_int32_t bi_epr_fw_ver;	/* (eprom) firmware ver */
		u_int32_t bi_upd_fw_ver;	/* (update) firmware ver */
		u_int32_t bi_upd_revision;	/* update revision */
		char bi_type_string[16];	/* char controller name */
		char bi_raid_string[16];	/* char RAID firmware name */
		u_int8_t bi_update_pres;	/* update present? */
		u_int8_t bi_xor_pres;		/* XOR engine present */
		u_int8_t bi_prom_type;		/* ROM type (eprom/flash) */
		u_int8_t bi_prom_count;		/* number of ROM devices */
		u_int32_t bi_dup_pres;		/* duplexing module pres? */
		u_int32_t bi_chan_pres;		/* # of exp. channels */
		u_int32_t bi_mem_pres;		/* memory expansion inst? */
		u_int8_t bi_ft_bus_system;	/* fault bus supported? */
		u_int8_t bi_subtype_valid;	/* board_subtype valid */
		u_int8_t bi_board_subtype;	/* subtype/hardware level */
		u_int8_t bi_rampar_pres;	/* RAM parity check hw? */
	} sc_binfo;

	struct {
		u_int8_t bf_chaining;	/* chaining supported */
		u_int8_t bf_striping;	/* striping (RAID-0) supported */
		u_int8_t bf_mirroring;	/* mirroring (RAID-1) supported */
		u_int8_t bf_raid;	/* RAID-4/5/10 supported */
	} sc_bfeat;

	u_int16_t sc_raw_feat;
	u_int16_t sc_cache_feat;

	void (*sc_copy_cmd)(struct gdt_softc *, struct gdt_ccb *);
	u_int8_t (*sc_get_status)(struct gdt_softc *);
	void (*sc_intr)(struct gdt_softc *, struct gdt_intr_ctx *);
	void (*sc_release_event)(struct gdt_softc *, struct gdt_ccb *);
	void (*sc_set_sema0)(struct gdt_softc *);
	int (*sc_test_busy)(struct gdt_softc *);
};

void	gdtminphys(struct buf *, struct scsi_link *);
int	gdt_attach(struct gdt_softc *);
int	gdt_intr(void *);

/* These all require correctly aligned buffers */
static inline void gdt_enc16(u_int8_t *, u_int16_t);
static inline void gdt_enc32(u_int8_t *, u_int32_t);
static inline u_int8_t gdt_dec8(u_int8_t *);
static inline u_int16_t gdt_dec16(u_int8_t *);
static inline u_int32_t gdt_dec32(u_int8_t *);

static inline void
gdt_enc16(u_int8_t *addr, u_int16_t value)
{
	*(u_int16_t *)addr = htole16(value);
}

static inline void
gdt_enc32(u_int8_t *addr, u_int32_t value)
{
	*(u_int32_t *)addr = htole32(value);
}

static inline u_int8_t
gdt_dec8(u_int8_t *addr)
{
	return *(u_int8_t *)addr;
}

static inline u_int16_t
gdt_dec16(u_int8_t *addr)
{
	return letoh16(*(u_int16_t *)addr);
}

static inline u_int32_t
gdt_dec32(u_int8_t *addr)
{
	return letoh32(*(u_int32_t *)addr);
}

extern u_int8_t gdt_polling;

#endif
@


1.21
log
@Remove the old ioctl interface which has been disabled for over
six years (since bioctl support was added).

ok krw@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.20 2011/07/08 08:26:41 jsg Exp $	*/
d134 1
a134 2
	LIST_HEAD(, scsi_xfer) sc_queue;
	struct scsi_xfer *sc_queuelast;
@


1.20
log
@ansi, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.19 2011/04/19 23:59:11 krw Exp $	*/
a34 6
#define GDT_IOCTL_DUMMY _IOWR('B', 32, struct gdt_dummy)
struct gdt_dummy {
	void *cookie;
	int x;
};

a35 155

#define GDT_IOCTL_GENERAL _IOWR('B', 33, gdt_ucmd_t)	/* general IOCTL */
typedef struct gdt_ucmd {
	void *cookie;
	u_int16_t io_node;
	u_int16_t service;
	u_int32_t timeout;
	u_int16_t status;
	u_int32_t info;

	u_int32_t BoardNode;			/* board node (always 0) */
	u_int32_t CommandIndex;			/* command number */
	u_int16_t OpCode;			/* the command (READ,..) */
	union {
		struct {
			u_int16_t DeviceNo;	/* number of cache drive */
			u_int32_t BlockNo;	/* block number */
			u_int32_t BlockCnt;	/* block count */
			void	*DestAddr;	/* data */
		} cache;			/* cache service cmd. str. */
		struct {
			u_int16_t param_size;	/* size of p_param buffer */
			u_int32_t subfunc;	/* IOCTL function */
			u_int32_t channel;	/* device */
			void	*p_param;	/* data */
		} ioctl;			/* IOCTL command structure */
		struct {
			u_int16_t reserved;
			u_int32_t direction;	/* data direction */
			u_int32_t mdisc_time;	/* disc. time (0: no timeout)*/
			u_int32_t mcon_time;	/* connect time(0: no to.) */
			void	*sdata;		/* dest. addr. (if s/g: -1) */
			u_int32_t sdlen;	/* data length (bytes) */
			u_int32_t clen;		/* SCSI cmd. length(6,10,12) */
			u_int8_t cmd[12];	/* SCSI command */
			u_int8_t target;	/* target ID */
			u_int8_t lun;		/* LUN */
			u_int8_t bus;		/* SCSI bus number */
			u_int8_t priority;	/* only 0 used */
			u_int32_t sense_len;	/* sense data length */
			void	*sense_data;	/* sense data addr. */
			u_int32_t link_p;	/* linked cmds (not supp.) */
		} raw;				/* raw service cmd. struct. */
	} u;
	u_int8_t data[GDT_SCRATCH_SZ];
	int	complete_flag;
	TAILQ_ENTRY(gdt_ucmd) links;
} gdt_ucmd_t;

#define GDT_IOCTL_DRVERS _IOWR('B', 34, int)	/* get driver version */
typedef struct gdt_drvers {
	void *cookie;
	int vers;
} gdt_drvers_t;

#define GDT_IOCTL_CTRTYPE _IOR('B', 35, gdt_ctrt_t)	/* get ctr. type */
typedef struct gdt_ctrt {
	void *cookie;
	u_int16_t io_node;
	u_int16_t oem_id;
	u_int16_t type;
	u_int32_t info;
	u_int8_t access;
	u_int8_t remote;
	u_int16_t ext_type;
	u_int16_t device_id;
	u_int16_t sub_device_id;
} gdt_ctrt_t;

#define GDT_IOCTL_OSVERS _IOR('B', 36, gdt_osv_t)	/* get OS version */
typedef struct gdt_osv {
	void *cookie;
	u_int8_t oscode;
	u_int8_t version;
	u_int8_t subversion;
	u_int16_t revision;
	char	name[64];
} gdt_osv_t;

#define GDT_IOCTL_CTRCNT _IOR('B', 37, int)	/* get ctr. count */
typedef struct gdt_ctrcnt {
	void *cookie;
	int cnt;
} gdt_ctrcnt_t;

#define GDT_IOCTL_EVENT _IOWR('B', 38, gdt_event_t)	/* get event */

typedef struct {
	u_int16_t size;		/* size of structure */
	union {
		char	stream[16];
		struct {
			u_int16_t ionode;
			u_int16_t service;
			u_int32_t index;
		} driver;
		struct {
			u_int16_t ionode;
			u_int16_t service;
			u_int16_t status;
			u_int32_t info;
			u_int8_t scsi_coord[3];
		} async;
		struct {
			u_int16_t ionode;
			u_int16_t service;
			u_int16_t status;
			u_int32_t info;
			u_int16_t hostdrive;
			u_int8_t scsi_coord[3];
			u_int8_t sense_key;
		} sync;
		struct {
			u_int32_t l1, l2, l3, l4;
		} test;
	} eu;
	u_int32_t severity;
	u_int8_t event_string[256];          
} gdt_evt_data;
#define GDT_ES_ASYNC	1
#define GDT_ES_DRIVER	2
#define GDT_ES_TEST	3
#define GDT_ES_SYNC	4

/* dvrevt structure */
typedef struct {
	u_int32_t first_stamp;
	u_int32_t last_stamp;
	u_int16_t same_count;
	u_int16_t event_source;
	u_int16_t event_idx;
	u_int8_t application;
	u_int8_t reserved;
	gdt_evt_data event_data;
} gdt_evt_str;

typedef struct gdt_event {
	void *cookie;
	int erase;
	int handle;
	gdt_evt_str dvr;
} gdt_event_t;

#define GDT_IOCTL_STATIST _IOR('B', 39, gdt_statist_t) /* get statistics */
typedef struct gdt_statist {
	void *cookie;
	u_int16_t io_count_act;
	u_int16_t io_count_max;
	u_int16_t req_queue_act;
	u_int16_t req_queue_max;
	u_int16_t cmd_index_act;
	u_int16_t cmd_index_max;
	u_int16_t sg_count_act;
	u_int16_t sg_count_max;
} gdt_statist_t;
@


1.19
log
@Iopoolification. Much simpler version than the one revived at k2k11.
This one works. For me at least.

Botch spotted by matthew@@.

ok matthew@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.18 2011/04/19 21:17:07 krw Exp $	*/
d256 1
a256 3
gdt_ccb_set_cmd(ccb, flag)
	struct gdt_ccb *ccb;
	int flag;
d413 1
a413 3
gdt_enc16(addr, value)
	u_int8_t *addr;
	u_int16_t value;
d419 1
a419 3
gdt_enc32(addr, value)
	u_int8_t *addr;
	u_int32_t value;
d425 1
a425 2
gdt_dec8(addr)
	u_int8_t *addr;
d431 1
a431 2
gdt_dec16(addr)
	u_int8_t *addr;
d437 1
a437 2
gdt_dec32(addr)
	u_int8_t *addr;
@


1.18
log
@Cease to pretend RAW SCSI mode exists. Eradicate all traces.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.17 2009/08/12 17:51:33 jsg Exp $	*/
d299 3
@


1.17
log
@Let this work with C99 compilers that do not define __GNUC__

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.16 2009/02/16 21:19:06 miod Exp $	*/
a270 1
	struct	scsi_link *sc_raw_link;	/* Raw SCSI busses */
@


1.16
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.15 2008/09/01 17:30:56 deraadt Exp $	*/
d254 2
a255 2
static __inline__ int gdt_ccb_set_cmd(struct gdt_ccb *, int);
static __inline__ int
a404 1
#ifdef __GNUC__
d406 5
a410 5
static __inline__ void gdt_enc16(u_int8_t *, u_int16_t);
static __inline__ void gdt_enc32(u_int8_t *, u_int32_t);
static __inline__ u_int8_t gdt_dec8(u_int8_t *);
static __inline__ u_int16_t gdt_dec16(u_int8_t *);
static __inline__ u_int32_t gdt_dec32(u_int8_t *);
d412 1
a412 1
static __inline__ void
d420 1
a420 1
static __inline__ void
d428 1
a428 1
static __inline__ u_int8_t
d435 1
a435 1
static __inline__ u_int16_t
d442 1
a442 1
static __inline__ u_int32_t
a447 1
#endif
@


1.15
log
@Avoid #pragma pack(1) and unify everything towards using __packed.
This requires that structures defined within __packed structures must
independently request that they themselves become __packed, too.
worked on with toby
 CVS: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.14 2007/11/11 14:03:35 krw Exp $	*/
d401 1
a401 1
void	gdtminphys(struct buf *);
@


1.14
log
@The interrupt routine doesn't need to explicity invoke splbio/splx.
But the polling routine needs to wraps its call of the interrupt
routine with splbio/splx. This ensures scsi_done() is properly
protected.

While in the polling routine, fix the timing code so milliseconds are
not treated as microseconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.13 2007/04/28 00:34:25 deraadt Exp $	*/
a40 3
/* XXX Is this pragma necessary?  */
#pragma pack(1)

a196 2

#pragma pack()
@


1.13
log
@remove abstraction around splbio/splx; they just confuse things; ok dlg marco krw
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.12 2006/05/07 23:18:59 marco Exp $	*/
d224 1
a224 1
#define GDT_POLL_TIMEOUT	10000000	/* 10000 * 1us = 10s */
@


1.12
log
@Add remaining glue for physical disk count.
Fix a bugglet in the size of GDT_IOCHAN_DESC structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.11 2006/05/07 20:34:09 marco Exp $	*/
a404 5

/* XXX These have to become spinlocks in case of SMP */
#define GDT_LOCK_GDT(gdt) splbio()
#define GDT_UNLOCK_GDT(gdt, lock) splx(lock)
typedef int gdt_lock_t;
@


1.11
log
@Add bio framework (not functional yet).
Replace index into struct for device name with DEVNAME macro.
Started translating linux driver back into swedish for gdt->sc_more_proc part.
Added initial scsi passthrough magic.
Added 2 new debug bits.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.10 2005/05/26 23:44:44 jason Exp $	*/
d323 2
d349 1
a349 1
		u_int32_t	ra_id_lis[GDT_MAXID];	/* IDs of phys disks */
d443 1
a443 1
	return *addr;
@


1.10
log
@remove vtophys (it wasn't used anyway)
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.9 2003/12/16 09:29:35 niklas Exp $	*/
d32 1
d206 1
d214 2
d342 9
d417 1
d435 7
@


1.9
log
@Compute openings value, out of boot-time count of devices.
Add reentrancy check of gdt_exec_ccb.  The latter change changes timing enough
to not trigger a timing bug on really fast machines too often.
A real fix is being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.8 2003/06/03 20:49:28 deraadt Exp $	*/
a435 6
#endif

#if defined(__alpha__)
/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
#undef vtophys
#define	vtophys(va)	alpha_XXX_dmamap((vm_offset_t)(va))
@


1.8
log
@fix various 3/4 licenses according to "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.7 2002/06/11 03:34:53 niklas Exp $	*/
d32 2
d301 2
@


1.7
log
@Checkpoint my work.  Register with bio, implement part of
the FreeBSD iir driver ioctl set.  Remove vtophys.  Some style.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.6 2002/03/14 01:26:54 millert Exp $	*/
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.5 2000/11/10 09:42:14 niklas Exp $	*/
d37 170
a224 1
#define GDT_SCRATCH_SZ		4096		/* 4KB scratch buffer */
d240 1
d301 1
d312 2
a314 1
	u_int8_t sc_scratch[GDT_SCRATCH_SZ];
d446 2
@


1.5
log
@improved queue handling + some small bug fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.4 2000/08/05 18:52:34 niklas Exp $	*/
d88 1
a88 1
static __inline__ int gdt_ccb_set_cmd __P((struct gdt_ccb *, int));
d212 6
a217 6
	void (*sc_copy_cmd) __P((struct gdt_softc *, struct gdt_ccb *));
	u_int8_t (*sc_get_status) __P((struct gdt_softc *));
	void (*sc_intr) __P((struct gdt_softc *, struct gdt_intr_ctx *));
	void (*sc_release_event) __P((struct gdt_softc *, struct gdt_ccb *));
	void (*sc_set_sema0) __P((struct gdt_softc *));
	int (*sc_test_busy) __P((struct gdt_softc *));
d225 3
a227 3
void	gdtminphys __P((struct buf *));
int	gdt_attach __P((struct gdt_softc *));
int	gdt_intr __P((void *));
d231 4
a234 4
static __inline__ void gdt_enc16 __P((u_int8_t *, u_int16_t));
static __inline__ void gdt_enc32 __P((u_int8_t *, u_int32_t));
static __inline__ u_int16_t gdt_dec16 __P((u_int8_t *));
static __inline__ u_int32_t gdt_dec32 __P((u_int8_t *));
@


1.5.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.5 2000/11/10 09:42:14 niklas Exp $	*/
d88 1
a88 1
static __inline__ int gdt_ccb_set_cmd(struct gdt_ccb *, int);
d212 6
a217 6
	void (*sc_copy_cmd)(struct gdt_softc *, struct gdt_ccb *);
	u_int8_t (*sc_get_status)(struct gdt_softc *);
	void (*sc_intr)(struct gdt_softc *, struct gdt_intr_ctx *);
	void (*sc_release_event)(struct gdt_softc *, struct gdt_ccb *);
	void (*sc_set_sema0)(struct gdt_softc *);
	int (*sc_test_busy)(struct gdt_softc *);
d225 3
a227 3
void	gdtminphys(struct buf *);
int	gdt_attach(struct gdt_softc *);
int	gdt_intr(void *);
d231 4
a234 4
static __inline__ void gdt_enc16(u_int8_t *, u_int16_t);
static __inline__ void gdt_enc32(u_int8_t *, u_int32_t);
static __inline__ u_int16_t gdt_dec16(u_int8_t *);
static __inline__ u_int32_t gdt_dec32(u_int8_t *);
@


1.5.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.5.6.1 2002/06/11 03:42:18 art Exp $	*/
a36 170
#define GDT_IOCTL_DUMMY _IOWR('B', 32, struct gdt_dummy)
struct gdt_dummy {
	void *cookie;
	int x;
};

/* XXX Is this pragma necessary?  */
#pragma pack(1)

#define GDT_SCRATCH_SZ 4096

#define GDT_IOCTL_GENERAL _IOWR('B', 33, gdt_ucmd_t)	/* general IOCTL */
typedef struct gdt_ucmd {
	void *cookie;
	u_int16_t io_node;
	u_int16_t service;
	u_int32_t timeout;
	u_int16_t status;
	u_int32_t info;

	u_int32_t BoardNode;			/* board node (always 0) */
	u_int32_t CommandIndex;			/* command number */
	u_int16_t OpCode;			/* the command (READ,..) */
	union {
		struct {
			u_int16_t DeviceNo;	/* number of cache drive */
			u_int32_t BlockNo;	/* block number */
			u_int32_t BlockCnt;	/* block count */
			void	*DestAddr;	/* data */
		} cache;			/* cache service cmd. str. */
		struct {
			u_int16_t param_size;	/* size of p_param buffer */
			u_int32_t subfunc;	/* IOCTL function */
			u_int32_t channel;	/* device */
			void	*p_param;	/* data */
		} ioctl;			/* IOCTL command structure */
		struct {
			u_int16_t reserved;
			u_int32_t direction;	/* data direction */
			u_int32_t mdisc_time;	/* disc. time (0: no timeout)*/
			u_int32_t mcon_time;	/* connect time(0: no to.) */
			void	*sdata;		/* dest. addr. (if s/g: -1) */
			u_int32_t sdlen;	/* data length (bytes) */
			u_int32_t clen;		/* SCSI cmd. length(6,10,12) */
			u_int8_t cmd[12];	/* SCSI command */
			u_int8_t target;	/* target ID */
			u_int8_t lun;		/* LUN */
			u_int8_t bus;		/* SCSI bus number */
			u_int8_t priority;	/* only 0 used */
			u_int32_t sense_len;	/* sense data length */
			void	*sense_data;	/* sense data addr. */
			u_int32_t link_p;	/* linked cmds (not supp.) */
		} raw;				/* raw service cmd. struct. */
	} u;
	u_int8_t data[GDT_SCRATCH_SZ];
	int	complete_flag;
	TAILQ_ENTRY(gdt_ucmd) links;
} gdt_ucmd_t;

#define GDT_IOCTL_DRVERS _IOWR('B', 34, int)	/* get driver version */
typedef struct gdt_drvers {
	void *cookie;
	int vers;
} gdt_drvers_t;

#define GDT_IOCTL_CTRTYPE _IOR('B', 35, gdt_ctrt_t)	/* get ctr. type */
typedef struct gdt_ctrt {
	void *cookie;
	u_int16_t io_node;
	u_int16_t oem_id;
	u_int16_t type;
	u_int32_t info;
	u_int8_t access;
	u_int8_t remote;
	u_int16_t ext_type;
	u_int16_t device_id;
	u_int16_t sub_device_id;
} gdt_ctrt_t;

#define GDT_IOCTL_OSVERS _IOR('B', 36, gdt_osv_t)	/* get OS version */
typedef struct gdt_osv {
	void *cookie;
	u_int8_t oscode;
	u_int8_t version;
	u_int8_t subversion;
	u_int16_t revision;
	char	name[64];
} gdt_osv_t;

#define GDT_IOCTL_CTRCNT _IOR('B', 37, int)	/* get ctr. count */
typedef struct gdt_ctrcnt {
	void *cookie;
	int cnt;
} gdt_ctrcnt_t;

#define GDT_IOCTL_EVENT _IOWR('B', 38, gdt_event_t)	/* get event */

typedef struct {
	u_int16_t size;		/* size of structure */
	union {
		char	stream[16];
		struct {
			u_int16_t ionode;
			u_int16_t service;
			u_int32_t index;
		} driver;
		struct {
			u_int16_t ionode;
			u_int16_t service;
			u_int16_t status;
			u_int32_t info;
			u_int8_t scsi_coord[3];
		} async;
		struct {
			u_int16_t ionode;
			u_int16_t service;
			u_int16_t status;
			u_int32_t info;
			u_int16_t hostdrive;
			u_int8_t scsi_coord[3];
			u_int8_t sense_key;
		} sync;
		struct {
			u_int32_t l1, l2, l3, l4;
		} test;
	} eu;
	u_int32_t severity;
	u_int8_t event_string[256];          
} gdt_evt_data;
#define GDT_ES_ASYNC	1
#define GDT_ES_DRIVER	2
#define GDT_ES_TEST	3
#define GDT_ES_SYNC	4

/* dvrevt structure */
typedef struct {
	u_int32_t first_stamp;
	u_int32_t last_stamp;
	u_int16_t same_count;
	u_int16_t event_source;
	u_int16_t event_idx;
	u_int8_t application;
	u_int8_t reserved;
	gdt_evt_data event_data;
} gdt_evt_str;

typedef struct gdt_event {
	void *cookie;
	int erase;
	int handle;
	gdt_evt_str dvr;
} gdt_event_t;

#define GDT_IOCTL_STATIST _IOR('B', 39, gdt_statist_t) /* get statistics */
typedef struct gdt_statist {
	void *cookie;
	u_int16_t io_count_act;
	u_int16_t io_count_max;
	u_int16_t req_queue_act;
	u_int16_t req_queue_max;
	u_int16_t cmd_index_act;
	u_int16_t cmd_index_max;
	u_int16_t sg_count_act;
	u_int16_t sg_count_max;
} gdt_statist_t;

#pragma pack()

#ifdef _KERNEL

d55 1
a70 1
	struct gdt_ucmd *gc_ucmd;
a130 1
	TAILQ_HEAD(, gdt_ucmd) sc_ucmdq;
a140 2
	bus_dma_segment_t sc_scratch_seg;
	caddr_t sc_scratch;
d142 1
a273 2

#endif
@


1.4
log
@Use better (working) locking macros around critical regions.  Implement
SCSI_POLL operations.  Implement SYNCHRONIZE_CACHE scsi operation emulation .
Do not call busdma operations unless we are really either a READ or WRITE
operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.3 2000/03/01 22:38:51 niklas Exp $	*/
d54 1
a54 1
#define GDT_WATCH_TIMEOUT	10000000	/* 10000 * 1us = 10s */
@


1.3
log
@Proper bus_dma usage, fixes cache incosistencies
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.2 2000/02/07 04:30:21 itojun Exp $	*/
a211 2
	int sc_spl;

d221 3
a223 2
#define GDT_LOCK_GDT(gdt) (gdt)->sc_spl = splbio()
#define GDT_UNLOCK_GDT(gdt) splx((gdt)->sc_spl)
@


1.3.2.1
log
@Pull in patch from current:
Fix (niklas):
Use better (working) locking macros around critical regions.  Implement
SCSI_POLL operations.  Implement SYNCHRONIZE_CACHE scsi operation emulation .
Do not call busdma operations unless we are really either a READ or WRITE
operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.4 2000/08/05 18:52:34 niklas Exp $	*/
d212 2
d223 2
a224 3
#define GDT_LOCK_GDT(gdt) splbio()
#define GDT_UNLOCK_GDT(gdt, lock) splx(lock)
typedef int gdt_lock_t;
@


1.2
log
@make it compilable without "options DEBUG"
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.1 2000/02/07 00:33:03 niklas Exp $	*/
d71 1
d120 1
@


1.2.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.2 2000/02/07 04:30:21 itojun Exp $	*/
a70 1
	bus_dmamap_t gc_dmamap_xfer;
a118 1
	bus_dma_tag_t sc_dmat;
@


1.2.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.5 2000/11/10 09:42:14 niklas Exp $	*/
d54 1
a54 1
#define GDT_WATCH_TIMEOUT	10000		/* 10000 * 1ms = 10s */
d212 2
d223 2
a224 3
#define GDT_LOCK_GDT(gdt) splbio()
#define GDT_UNLOCK_GDT(gdt, lock) splx(lock)
typedef int gdt_lock_t;
@


1.2.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
a88 1
static __inline__ int gdt_ccb_set_cmd(struct gdt_ccb *, int);
d212 6
a217 6
	void (*sc_copy_cmd)(struct gdt_softc *, struct gdt_ccb *);
	u_int8_t (*sc_get_status)(struct gdt_softc *);
	void (*sc_intr)(struct gdt_softc *, struct gdt_intr_ctx *);
	void (*sc_release_event)(struct gdt_softc *, struct gdt_ccb *);
	void (*sc_set_sema0)(struct gdt_softc *);
	int (*sc_test_busy)(struct gdt_softc *);
d225 3
a227 3
void	gdtminphys(struct buf *);
int	gdt_attach(struct gdt_softc *);
int	gdt_intr(void *);
d231 4
a234 4
static __inline__ void gdt_enc16(u_int8_t *, u_int16_t);
static __inline__ void gdt_enc32(u_int8_t *, u_int32_t);
static __inline__ u_int16_t gdt_dec16(u_int8_t *);
static __inline__ u_int32_t gdt_dec32(u_int8_t *);
@


1.2.2.4
log
@Sync the SMP branch with 3.3
@
text
@a36 170
#define GDT_IOCTL_DUMMY _IOWR('B', 32, struct gdt_dummy)
struct gdt_dummy {
	void *cookie;
	int x;
};

/* XXX Is this pragma necessary?  */
#pragma pack(1)

#define GDT_SCRATCH_SZ 4096

#define GDT_IOCTL_GENERAL _IOWR('B', 33, gdt_ucmd_t)	/* general IOCTL */
typedef struct gdt_ucmd {
	void *cookie;
	u_int16_t io_node;
	u_int16_t service;
	u_int32_t timeout;
	u_int16_t status;
	u_int32_t info;

	u_int32_t BoardNode;			/* board node (always 0) */
	u_int32_t CommandIndex;			/* command number */
	u_int16_t OpCode;			/* the command (READ,..) */
	union {
		struct {
			u_int16_t DeviceNo;	/* number of cache drive */
			u_int32_t BlockNo;	/* block number */
			u_int32_t BlockCnt;	/* block count */
			void	*DestAddr;	/* data */
		} cache;			/* cache service cmd. str. */
		struct {
			u_int16_t param_size;	/* size of p_param buffer */
			u_int32_t subfunc;	/* IOCTL function */
			u_int32_t channel;	/* device */
			void	*p_param;	/* data */
		} ioctl;			/* IOCTL command structure */
		struct {
			u_int16_t reserved;
			u_int32_t direction;	/* data direction */
			u_int32_t mdisc_time;	/* disc. time (0: no timeout)*/
			u_int32_t mcon_time;	/* connect time(0: no to.) */
			void	*sdata;		/* dest. addr. (if s/g: -1) */
			u_int32_t sdlen;	/* data length (bytes) */
			u_int32_t clen;		/* SCSI cmd. length(6,10,12) */
			u_int8_t cmd[12];	/* SCSI command */
			u_int8_t target;	/* target ID */
			u_int8_t lun;		/* LUN */
			u_int8_t bus;		/* SCSI bus number */
			u_int8_t priority;	/* only 0 used */
			u_int32_t sense_len;	/* sense data length */
			void	*sense_data;	/* sense data addr. */
			u_int32_t link_p;	/* linked cmds (not supp.) */
		} raw;				/* raw service cmd. struct. */
	} u;
	u_int8_t data[GDT_SCRATCH_SZ];
	int	complete_flag;
	TAILQ_ENTRY(gdt_ucmd) links;
} gdt_ucmd_t;

#define GDT_IOCTL_DRVERS _IOWR('B', 34, int)	/* get driver version */
typedef struct gdt_drvers {
	void *cookie;
	int vers;
} gdt_drvers_t;

#define GDT_IOCTL_CTRTYPE _IOR('B', 35, gdt_ctrt_t)	/* get ctr. type */
typedef struct gdt_ctrt {
	void *cookie;
	u_int16_t io_node;
	u_int16_t oem_id;
	u_int16_t type;
	u_int32_t info;
	u_int8_t access;
	u_int8_t remote;
	u_int16_t ext_type;
	u_int16_t device_id;
	u_int16_t sub_device_id;
} gdt_ctrt_t;

#define GDT_IOCTL_OSVERS _IOR('B', 36, gdt_osv_t)	/* get OS version */
typedef struct gdt_osv {
	void *cookie;
	u_int8_t oscode;
	u_int8_t version;
	u_int8_t subversion;
	u_int16_t revision;
	char	name[64];
} gdt_osv_t;

#define GDT_IOCTL_CTRCNT _IOR('B', 37, int)	/* get ctr. count */
typedef struct gdt_ctrcnt {
	void *cookie;
	int cnt;
} gdt_ctrcnt_t;

#define GDT_IOCTL_EVENT _IOWR('B', 38, gdt_event_t)	/* get event */

typedef struct {
	u_int16_t size;		/* size of structure */
	union {
		char	stream[16];
		struct {
			u_int16_t ionode;
			u_int16_t service;
			u_int32_t index;
		} driver;
		struct {
			u_int16_t ionode;
			u_int16_t service;
			u_int16_t status;
			u_int32_t info;
			u_int8_t scsi_coord[3];
		} async;
		struct {
			u_int16_t ionode;
			u_int16_t service;
			u_int16_t status;
			u_int32_t info;
			u_int16_t hostdrive;
			u_int8_t scsi_coord[3];
			u_int8_t sense_key;
		} sync;
		struct {
			u_int32_t l1, l2, l3, l4;
		} test;
	} eu;
	u_int32_t severity;
	u_int8_t event_string[256];          
} gdt_evt_data;
#define GDT_ES_ASYNC	1
#define GDT_ES_DRIVER	2
#define GDT_ES_TEST	3
#define GDT_ES_SYNC	4

/* dvrevt structure */
typedef struct {
	u_int32_t first_stamp;
	u_int32_t last_stamp;
	u_int16_t same_count;
	u_int16_t event_source;
	u_int16_t event_idx;
	u_int8_t application;
	u_int8_t reserved;
	gdt_evt_data event_data;
} gdt_evt_str;

typedef struct gdt_event {
	void *cookie;
	int erase;
	int handle;
	gdt_evt_str dvr;
} gdt_event_t;

#define GDT_IOCTL_STATIST _IOR('B', 39, gdt_statist_t) /* get statistics */
typedef struct gdt_statist {
	void *cookie;
	u_int16_t io_count_act;
	u_int16_t io_count_max;
	u_int16_t req_queue_act;
	u_int16_t req_queue_max;
	u_int16_t cmd_index_act;
	u_int16_t cmd_index_max;
	u_int16_t sg_count_act;
	u_int16_t sg_count_max;
} gdt_statist_t;

#pragma pack()

#ifdef _KERNEL

d55 1
a70 1
	struct gdt_ucmd *gc_ucmd;
a130 1
	TAILQ_HEAD(, gdt_ucmd) sc_ucmdq;
a140 2
	bus_dma_segment_t sc_scratch_seg;
	caddr_t sc_scratch;
d142 1
a273 2

#endif
@


1.2.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdtvar.h,v 1.2.2.4 2003/03/28 00:38:13 niklas Exp $	*/
d14 5
@


1.2.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a31 2
#define GDT_CMD_RESERVE	4	/* Internal driver cmd reserve. */

a298 2

	int	sc_ndevs;
@


1.1
log
@Rough but working driver for ICP-Vortex RAID
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
#define GDT_PRINTF(args)
@

