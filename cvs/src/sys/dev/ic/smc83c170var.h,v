head	1.4;
access;
symbols
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.8
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.6
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.3.0.26
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.18
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.22
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.20
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.16
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.14
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.12
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.8
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.1.0.12
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.10
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.8
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.6
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.3;
commitid	6vhYvh5CxZAHMnsN;

1.3
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.10.01.16.32;	author brad;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@/*	$OpenBSD: smc83c170var.h,v 1.3 2009/08/10 20:29:54 deraadt Exp $	*/
/*	$NetBSD: smc83c170var.h,v 1.9 2005/02/04 02:10:37 perry Exp $	*/

/*-
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _DEV_IC_SMC83C170VAR_H_
#define _DEV_IC_SMC83C170VAR_H_

#include <sys/timeout.h>

/*
 * Misc. definitions for the Standard Microsystems Corp. 83C170
 * Ethernet PCI Integrated Controller (EPIC/100) driver.
 */

/*
 * Transmit descriptor list size.
 */
#define	EPIC_NTXDESC		128
#define	EPIC_NTXDESC_MASK	(EPIC_NTXDESC - 1)
#define	EPIC_NEXTTX(x)		((x + 1) & EPIC_NTXDESC_MASK)

/*
 * Receive descriptor list size.
 */
#define	EPIC_NRXDESC		64
#define	EPIC_NRXDESC_MASK	(EPIC_NRXDESC - 1)
#define	EPIC_NEXTRX(x)		((x + 1) & EPIC_NRXDESC_MASK)

/*
 * Control structures are DMA'd to the EPIC chip.  We allocate them in
 * a single clump that maps to a single DMA segment to make several things
 * easier.
 */
struct epic_control_data {
	/*
	 * The transmit descriptors.
	 */
	struct epic_txdesc ecd_txdescs[EPIC_NTXDESC];

	/*
	 * The receive descriptors.
	 */
	struct epic_rxdesc ecd_rxdescs[EPIC_NRXDESC];

	/*
	 * The transmit fraglists.
	 */
	struct epic_fraglist ecd_txfrags[EPIC_NTXDESC];
};

#define	EPIC_CDOFF(x)	offsetof(struct epic_control_data, x)
#define	EPIC_CDTXOFF(x)	EPIC_CDOFF(ecd_txdescs[(x)])
#define	EPIC_CDRXOFF(x)	EPIC_CDOFF(ecd_rxdescs[(x)])
#define	EPIC_CDFLOFF(x)	EPIC_CDOFF(ecd_txfrags[(x)])

/*
 * Software state for transmit and receive desciptors.
 */
struct epic_descsoft {
	struct mbuf *ds_mbuf;		/* head of mbuf chain */
	bus_dmamap_t ds_dmamap;		/* our DMA map */
};

/*
 * Software state per device.
 */
struct epic_softc {
	struct device sc_dev;		/* generic device information */
	bus_space_tag_t sc_st;		/* bus space tag */
	bus_space_handle_t sc_sh;	/* bus space handle */
	bus_dma_tag_t sc_dmat;		/* bus DMA tag */
	struct arpcom sc_arpcom;	/* ethernet common data */

	int sc_hwflags;			/* info about board */
#define EPIC_HAS_BNC		0x01	/* BNC on serial interface */
#define EPIC_HAS_MII_FIBER	0x02	/* fiber on MII lxtphy */
#define EPIC_DUPLEXLED_ON_694	0x04	/* duplex LED by software */

	struct mii_data sc_mii;		/* MII/media information */
	struct timeout sc_mii_timeout;	/* MII timeout */

	bus_dmamap_t sc_cddmamap;	/* control data DMA map */
#define	sc_cddma	sc_cddmamap->dm_segs[0].ds_addr
	bus_dmamap_t sc_nulldmamap;	/* DMA map for the pad buffer */
#define sc_nulldma	sc_nulldmamap->dm_segs[0].ds_addr

	/*
	 * Software state for transmit and receive descriptors.
	 */
	struct epic_descsoft sc_txsoft[EPIC_NTXDESC];
	struct epic_descsoft sc_rxsoft[EPIC_NRXDESC];

	/*
	 * Control data structures.
	 */
	struct epic_control_data *sc_control_data;

	int	sc_txpending;		/* number of TX requests pending */
	int	sc_txdirty;		/* first dirty TX descriptor */
	int	sc_txlast;		/* last used TX descriptor */

	int	sc_rxptr;		/* next ready RX descriptor */

	uint64_t	sc_serinst;	/* ifmedia instance for serial mode */
};

#define	EPIC_CDTXADDR(sc, x)	((sc)->sc_cddma + EPIC_CDTXOFF((x)))
#define	EPIC_CDRXADDR(sc, x)	((sc)->sc_cddma + EPIC_CDRXOFF((x)))
#define	EPIC_CDFLADDR(sc, x)	((sc)->sc_cddma + EPIC_CDFLOFF((x)))

#define	EPIC_CDTX(sc, x)	(&(sc)->sc_control_data->ecd_txdescs[(x)])
#define	EPIC_CDRX(sc, x)	(&(sc)->sc_control_data->ecd_rxdescs[(x)])
#define	EPIC_CDFL(sc, x)	(&(sc)->sc_control_data->ecd_txfrags[(x)])

#define	EPIC_DSTX(sc, x)	(&(sc)->sc_txsoft[(x)])
#define	EPIC_DSRX(sc, x)	(&(sc)->sc_rxsoft[(x)])

#define	EPIC_CDTXSYNC(sc, x, ops)					\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_cddmamap,		\
	    EPIC_CDTXOFF((x)), sizeof(struct epic_txdesc), (ops))

#define	EPIC_CDRXSYNC(sc, x, ops)					\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_cddmamap,		\
	    EPIC_CDRXOFF((x)), sizeof(struct epic_rxdesc), (ops))

#define	EPIC_CDFLSYNC(sc, x, ops)					\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_cddmamap,		\
	    EPIC_CDFLOFF((x)), sizeof(struct epic_fraglist), (ops))

#define	EPIC_INIT_RXDESC(sc, x)						\
do {									\
	struct epic_descsoft *__ds = EPIC_DSRX((sc), (x));		\
	struct epic_rxdesc *__rxd = EPIC_CDRX((sc), (x));		\
	struct mbuf *__m = __ds->ds_mbuf;				\
									\
	/*								\
	 * Note we scoot the packet forward 2 bytes in the buffer	\
	 * so that the payload after the Ethernet header is aligned	\
	 * to a 4 byte boundary.					\
	 */								\
	__m->m_data = __m->m_ext.ext_buf + 2;				\
	__rxd->er_bufaddr = __ds->ds_dmamap->dm_segs[0].ds_addr + 2;	\
	__rxd->er_control = RXCTL_BUFLENGTH(__m->m_ext.ext_size - 2);	\
	__rxd->er_rxstatus = ER_RXSTAT_OWNER;				\
	__rxd->er_nextdesc = EPIC_CDRXADDR((sc), EPIC_NEXTRX((x)));	\
	EPIC_CDRXSYNC((sc), (x), BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE); \
} while (/* CONSTCOND */ 0)

#ifdef _KERNEL
void	epic_attach(struct epic_softc *, const char *);
int	epic_intr(void *);
#endif /* _KERNEL */

#endif /* _DEV_IC_SMC83C170VAR_H_ */
@


1.3
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: smc83c170var.h,v 1.2 2008/06/26 05:42:16 ray Exp $	*/
d133 1
a133 1
	u_int	sc_serinst;		/* ifmedia instance for serial mode */
@


1.2
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smc83c170var.h,v 1.1 2005/05/10 01:16:32 brad Exp $	*/
a101 1
	void *sc_sdhook;		/* shutdown hook */
@


1.1
log
@Add epic(4) driver which supersedes tx(4).

This buys us..
- bus_dma
- big endian support
- multicast
- support for another EPIC chipset

From NetBSD

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@

