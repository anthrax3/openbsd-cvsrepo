head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.2
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.10.0.14
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.12
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.11
date	2017.06.05.04.57.37;	author dlg;	state Exp;
branches;
next	1.10;
commitid	sx75IQVBJRZPzSp7;

1.10
date	2014.05.17.11.51.21;	author jmatthew;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.27.08.40.13;	author jmatthew;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.14.04.14.11;	author jmatthew;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.05.12.49.27;	author jmatthew;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.31.11.25.45;	author jmatthew;	state Exp;
branches;
next	1.5;

1.5
date	2014.02.20.00.23.00;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2014.02.19.13.41.23;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2014.02.02.07.53.33;	author jmatthew;	state Exp;
branches;
next	1.2;

1.2
date	2014.02.01.09.11.30;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2014.01.19.06.04.03;	author jmatthew;	state Exp;
branches;
next	;


desc
@@


1.11
log
@use byte swapping loads and stores.

shrinks the code a bit on sparc64.

ok jmatthew@@
@
text
@/*	$OpenBSD: qlavar.h,v 1.10 2014/05/17 11:51:21 jmatthew Exp $ */

/*
 * Copyright (c) 2013, 2014 Jonathan Matthew <jmatthew@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/task.h>

#define QLA_DEFAULT_PORT_NAME		0x400000007F000003ULL /* from isp(4) */

#define QLA_WAIT_FOR_LOOP		10

/* maximum number of segments allowed for in a single io */
#define QLA_MAX_SEGS			16

struct qla_softc;

enum qla_isp_gen {
	QLA_GEN_ISP2100 = 1,
	QLA_GEN_ISP2200,
	QLA_GEN_ISP23XX,
};

enum qla_isp_type {
	QLA_ISP2100 = 1,
	QLA_ISP2200,
	QLA_ISP2300,
	QLA_ISP2312,
	QLA_ISP2322
};

struct qla_regs {
	u_int16_t	(*read)(struct qla_softc *, bus_size_t);
	int		(*read_isr)(struct qla_softc *,
			    u_int16_t *, u_int16_t *);

	bus_size_t	req_in;
	bus_size_t	req_out;
	bus_size_t	res_in;
	bus_size_t	res_out;
};

/* port database things */
#define QLA_SCRATCH_SIZE		0x1000

enum qla_port_disp {
	QLA_PORT_DISP_NEW,
	QLA_PORT_DISP_GONE,
	QLA_PORT_DISP_SAME,
	QLA_PORT_DISP_CHANGED,
	QLA_PORT_DISP_MOVED,
	QLA_PORT_DISP_DUP
};

#define QLA_LOCATION_LOOP		(1 << 24)
#define QLA_LOCATION_FABRIC		(2 << 24)
#define QLA_LOCATION_LOOP_ID(l)		(l | QLA_LOCATION_LOOP)
#define QLA_LOCATION_PORT_ID(p)		(p | QLA_LOCATION_FABRIC)

struct qla_fc_port {
	TAILQ_ENTRY(qla_fc_port) ports;
	TAILQ_ENTRY(qla_fc_port) update;

	u_int64_t	node_name;
	u_int64_t	port_name;
	u_int32_t	location;	/* port id or loop id */

	int		flags;
#define QLA_PORT_FLAG_IS_TARGET		1
#define QLA_PORT_FLAG_NEEDS_LOGIN	2

	u_int32_t	portid;
	u_int16_t	loopid;
};


/* request/response queue stuff */
#define QLA_QUEUE_ENTRY_SIZE		64

struct qla_ccb {
	struct qla_softc 	*ccb_sc;
	int			ccb_id;
	struct scsi_xfer	*ccb_xs;

	bus_dmamap_t		ccb_dmamap;

	struct qla_iocb_seg	*ccb_t4segs;
	u_int64_t		ccb_seg_offset;
	u_int64_t		ccb_seg_dva;

	SIMPLEQ_ENTRY(qla_ccb)	ccb_link;
};

SIMPLEQ_HEAD(qla_ccb_list, qla_ccb);

struct qla_dmamem {
	bus_dmamap_t		qdm_map;
	bus_dma_segment_t	qdm_seg;
	size_t			qdm_size;
	caddr_t			qdm_kva;
};
#define QLA_DMA_MAP(_qdm)	((_qdm)->qdm_map)
#define QLA_DMA_LEN(_qdm)	((_qdm)->qdm_size)
#define QLA_DMA_DVA(_qdm)	((u_int64_t)(_qdm)->qdm_map->dm_segs[0].ds_addr)
#define QLA_DMA_KVA(_qdm)	((void *)(_qdm)->qdm_kva)

struct qla_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	bus_dma_tag_t		sc_dmat;

	struct scsi_link	sc_link;

	struct scsibus_softc	*sc_scsibus;

	enum qla_isp_type	sc_isp_type;
	enum qla_isp_gen	sc_isp_gen;
	int			sc_port;
	int			sc_expanded_lun;
	int			sc_fabric;
	int			sc_2k_logins;

	const struct qla_regs	*sc_regs;

	int			sc_mbox_base;
	u_int16_t		sc_mbox[12];
	int			sc_mbox_pending;
	struct mutex		sc_mbox_mtx;

	int			sc_loop_up;
	int			sc_topology;
	int			sc_loop_id;
	int			sc_port_id;
	int			sc_loop_max_id;
	u_int64_t		sc_sns_port_name;

	struct mutex		sc_port_mtx;
	TAILQ_HEAD(, qla_fc_port) sc_ports;
	TAILQ_HEAD(, qla_fc_port) sc_ports_new;
	TAILQ_HEAD(, qla_fc_port) sc_ports_gone;
	TAILQ_HEAD(, qla_fc_port) sc_ports_found;
	struct qla_fc_port	*sc_targets[QLA_2KL_BUSWIDTH];

	struct taskq		*sc_update_taskq;
	struct task		sc_update_task;
	int			sc_update;
	int			sc_update_tasks;
#define QLA_UPDATE_TASK_CLEAR_ALL	0x00000001
#define QLA_UPDATE_TASK_SOFTRESET	0x00000002
#define QLA_UPDATE_TASK_UPDATE_TOPO	0x00000004
#define QLA_UPDATE_TASK_GET_PORT_LIST	0x00000008
#define QLA_UPDATE_TASK_PORT_LIST	0x00000010
#define QLA_UPDATE_TASK_SCAN_FABRIC	0x00000020
#define QLA_UPDATE_TASK_SCANNING_FABRIC	0x00000040
#define QLA_UPDATE_TASK_FABRIC_LOGIN	0x00000080
#define QLA_UPDATE_TASK_FABRIC_RELOGIN	0x00000100
#define QLA_UPDATE_TASK_DETACH_TARGET	0x00000200
#define QLA_UPDATE_TASK_ATTACH_TARGET	0x00000400

	int			sc_maxcmds;
	struct qla_dmamem	*sc_requests;
	struct qla_dmamem	*sc_responses;
	struct qla_dmamem	*sc_segments;
	struct qla_dmamem	*sc_scratch;
	struct qla_ccb		*sc_ccbs;
	struct qla_ccb_list	sc_ccb_free;
	struct mutex		sc_ccb_mtx;
	struct mutex		sc_queue_mtx;
	struct scsi_iopool	sc_iopool;
	u_int16_t		sc_next_req_id;
	u_int16_t		sc_last_resp_id;
	int			sc_marker_required;

	struct qla_nvram	sc_nvram;
	int			sc_nvram_valid;
	u_int64_t		sc_node_name;
	u_int64_t		sc_port_name;
};
#define DEVNAME(_sc) ((_sc)->sc_dev.dv_xname)

int	qla_attach(struct qla_softc *);
int	qla_detach(struct qla_softc *, int);

int	qla_intr(void *);
@


1.10
log
@When the firmware tells us a loop id is already in use, add the device
there to our port lists, then find the next available loop id and carry on
rather than restarting.  This way, we're less likely to get stuck looping
when the firmware behaves inconsistently.  We also don't need to treat domain
controller logins specially.

additional complications discovered by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qlavar.h,v 1.9 2014/04/27 08:40:13 jmatthew Exp $ */
d101 1
@


1.9
log
@transplant hotplug code over from qle(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: qlavar.h,v 1.8 2014/04/14 04:14:11 jmatthew Exp $ */
a65 3

#define QLA_DOMAIN_CTRL_MASK		0xffff00
#define QLA_DOMAIN_CTRL			0xfffc00
@


1.8
log
@Always copy out all mailbox registers and use msleep in a loop to ensure that
post-attach mailbox operations work reliably.
@
text
@d1 1
a1 1
/*	$OpenBSD: qlavar.h,v 1.7 2014/04/05 12:49:27 jmatthew Exp $ */
d19 1
d67 2
a68 6
#define QLA_UPDATE_DISCARD		0
#define QLA_UPDATE_SOFTRESET		1
#define QLA_UPDATE_FULL_SCAN		2
#define QLA_UPDATE_LOOP_SCAN		3
#define QLA_UPDATE_FABRIC_SCAN		4
#define QLA_UPDATE_FABRIC_RELOGIN	5
d160 16
a175 1
	struct taskq		*sc_scan_taskq;
@


1.7
log
@set adapter buswidth according to the number of loop ids supported by the
firmware (2048 for 2k login firmware, 256 otherwise)

pointed out by deraadt@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qlavar.h,v 1.6 2014/03/31 11:25:45 jmatthew Exp $ */
d148 1
@


1.6
log
@Rather than scanning local loop ids sequentially, just ask the chip which
local devices it has logged in to.  This will also be useful for hotplug
later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: qlavar.h,v 1.5 2014/02/20 00:23:00 dlg Exp $ */
a23 3
/* rounded up range of assignable handles for 2k login firmware */
#define QLA_MAX_TARGETS			2048

d161 1
a161 1
	struct qla_fc_port	*sc_targets[QLA_MAX_TARGETS];
@


1.5
log
@pull the isr reads out into per chip variants we get to via pointers
in a per generation structure. this avoids code on every isr to figure
out what version of the chip we are, which is silly since we know that
at attach time.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qlavar.h,v 1.3 2014/02/02 07:53:33 jmatthew Exp $ */
d76 4
a79 2
#define QLA_LOCATION_LOOP_ID(l)		(l | (1 << 24))
#define QLA_LOCATION_PORT_ID(p)		(p | (2 << 24))
d163 1
@


1.4
log
@tweak the response queue handling so it looks like qle. the important
bit is to post to the resp_out register once outside the loop rather
than inside every loop.

rework the code for finding the queue registers so its done once
on attach by pointing the sc at a map, rather than running big
conditionals in code on every register operation based on teh chip
version.

tested on 2200s by me and 2312s by jmatthew@@
ok jmatthew@@
@
text
@d46 1
a46 1
struct qla_queue_regs {
d48 2
d144 1
a144 1
	const struct qla_queue_regs *sc_q;
@


1.3
log
@carve up qla_attach() into bits we can use to process loop and fabric changes
later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: qlavar.h,v 1.2 2014/02/01 09:11:30 kettenis Exp $ */
d30 2
d46 7
a52 6
/* needed as <2300 use mailbox registers for queue pointers */
enum qla_qptr {
	QLA_REQ_QUEUE_IN,
	QLA_REQ_QUEUE_OUT,
	QLA_RESP_QUEUE_IN,
	QLA_RESP_QUEUE_OUT
d131 1
a131 1
	struct scsi_link        sc_link;
d141 2
@


1.2
log
@On sparc64, use the WWNs from Open Firmware, as the onboard ISP2200 that can
be found on some Sun hardware doesn't have an NVRAM.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qlavar.h,v 1.1 2014/01/19 06:04:03 jmatthew Exp $ */
d147 2
@


1.1
log
@Introduce qla(4), a new driver for Qlogic fibre channel HBAs (only ISP23xx
so far).  Works reasonably well now, so it's going in the tree so others can
try it out.

with some help and fixes from dlg@@, general encouragement from basically
everyone
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d171 2
@

