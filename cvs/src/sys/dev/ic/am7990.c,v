head	1.53;
access;
symbols
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.52.0.6
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.44.0.14
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.10
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.12
	OPENBSD_5_0:1.44.0.8
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.6
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.4
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.41.0.10
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.8
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.6
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.41.0.4
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.39.0.2
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.38.0.4
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.38.0.2
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.33.0.4
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.28.0.4
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	UBC_SYNC_B:1.28
	UBC:1.27.0.4
	UBC_BASE:1.27
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.19.0.4
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	SMP:1.16.0.2
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.52;
commitid	VyLWTsbepAOk7VQM;

1.52
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.51;
commitid	B0kwmVGiD5DVx4kv;

1.51
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.50;
commitid	hN5bFCE56DrAjl99;

1.50
date	2015.05.01.14.56.18;	author mpi;	state Exp;
branches;
next	1.49;
commitid	yStxEgxXh5L7rDZs;

1.49
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.48;
commitid	yM2VFFhpDTeFQlve;

1.48
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.47;
commitid	TGHgrLxu6sxZoiFt;

1.47
date	2013.09.24.20.10.55;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2013.08.07.01.06.27;	author bluhm;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.21.20.08.45;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.25.22.41.42;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.07.03.20.00;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.01.03.59.52;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.28.04.37.32;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.01.12.58.51;	author mcbride;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.18.18.23.58;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.18.17.14.19;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.02.23.28.01;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.13.12.10.46;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2002.12.02.18.48.52;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.27.15.30.42;	author tholo;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2001.06.27.06.34.39;	author kjc;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.24.22.36.57;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.24.04.48.02;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.24.04.24.18;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.23.23.17.35;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.01.07.37.17;	author bjc;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.20.19.39.36;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.15.14.37.49;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.14.19.50.13;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.10.00.53.58;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	99.12.08.06.08.04;	author itojun;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	99.02.28.05.02.16;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	98.09.16.22.41.20;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	98.06.24.20.05.03;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.06.08.17.14.43;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.03.09.09.33.04;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.08.08.08.05.40;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.11.28.23.27.46;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.10.12.41.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.05.13.39.31;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.05.02.13.51.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.21.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.23.47.17;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.05.15.56.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.02.35.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.31;	author deraadt;	state Exp;
branches;
next	;

1.16.2.1
date	2000.03.24.09.09.09;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.05.14.22.23.26;	author niklas;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.07.04.10.40.29;	author niklas;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.16.2.7;

1.16.2.7
date	2003.05.16.00.29.41;	author niklas;	state Exp;
branches;
next	1.16.2.8;

1.16.2.8
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.16.2.9;

1.16.2.9
date	2004.06.05.23.12.40;	author niklas;	state Exp;
branches;
next	;

1.27.4.1
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.53
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: am7990.c,v 1.52 2015/11/25 03:09:58 dlg Exp $	*/
/*	$NetBSD: am7990.c,v 1.74 2012/02/02 19:43:02 tls Exp $	*/

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Jason R. Thorpe of the Numerical Aerospace
 * Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 11/16/93
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/ic/lancereg.h>
#include <dev/ic/lancevar.h>
#include <dev/ic/am7990reg.h>
#include <dev/ic/am7990var.h>

void	am7990_meminit(struct lance_softc *);
void	am7990_start(struct ifnet *);

void	am7990_rint(struct lance_softc *);
void	am7990_tint(struct lance_softc *);

#ifdef LEDEBUG
void	am7990_recv_print(struct lance_softc *, int);
void	am7990_xmit_print(struct lance_softc *, int);
#endif

/*
 * am7990 configuration driver.  Attachments are provided by
 * machine-dependent driver front-ends.
 */
void
am7990_config(struct am7990_softc *sc)
{
	int mem, i;

	sc->lsc.sc_meminit = am7990_meminit;
	sc->lsc.sc_start = am7990_start;

	lance_config(&sc->lsc);

	mem = 0;
	sc->lsc.sc_initaddr = mem;
	mem += sizeof(struct leinit);
	sc->lsc.sc_rmdaddr = mem;
	mem += sizeof(struct lermd) * sc->lsc.sc_nrbuf;
	sc->lsc.sc_tmdaddr = mem;
	mem += sizeof(struct letmd) * sc->lsc.sc_ntbuf;
	for (i = 0; i < sc->lsc.sc_nrbuf; i++, mem += LEBLEN)
		sc->lsc.sc_rbufaddr[i] = mem;
	for (i = 0; i < sc->lsc.sc_ntbuf; i++, mem += LEBLEN)
		sc->lsc.sc_tbufaddr[i] = mem;
#ifdef notyet
	if (mem > ...)
		panic(...);
#endif
}

/*
 * Set up the initialization block and the descriptor rings.
 */
void
am7990_meminit(struct lance_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_long a;
	int bix;
	struct leinit init;
	struct lermd rmd;
	struct letmd tmd;
	uint8_t *myaddr;

	if (ifp->if_flags & IFF_PROMISC)
		init.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;
	else
		init.init_mode = LE_MODE_NORMAL;
	if (sc->sc_initmodemedia == 1)
		init.init_mode |= LE_MODE_PSEL0;

	/*
	 * Update our private copy of the Ethernet address.
	 * We NEED the copy so we can ensure its alignment!
	 */
	memcpy(sc->sc_enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
	myaddr = sc->sc_enaddr;

	init.init_padr[0] = (myaddr[1] << 8) | myaddr[0];
	init.init_padr[1] = (myaddr[3] << 8) | myaddr[2];
	init.init_padr[2] = (myaddr[5] << 8) | myaddr[4];
	lance_setladrf(&sc->sc_arpcom, init.init_ladrf);

	sc->sc_last_rd = 0;
	sc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;

	a = sc->sc_addr + LE_RMDADDR(sc, 0);
	init.init_rdra = a;
	init.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);

	a = sc->sc_addr + LE_TMDADDR(sc, 0);
	init.init_tdra = a;
	init.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);

	(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));

	/*
	 * Set up receive ring descriptors.
	 */
	for (bix = 0; bix < sc->sc_nrbuf; bix++) {
		a = sc->sc_addr + LE_RBUFADDR(sc, bix);
		rmd.rmd0 = a;
		rmd.rmd1_hadr = a >> 16;
		rmd.rmd1_bits = LE_R1_OWN;
		rmd.rmd2 = -LEBLEN | LE_XMD2_ONES;
		rmd.rmd3 = 0;
		(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),
		    sizeof(rmd));
	}

	/*
	 * Set up transmit ring descriptors.
	 */
	for (bix = 0; bix < sc->sc_ntbuf; bix++) {
		a = sc->sc_addr + LE_TBUFADDR(sc, bix);
		tmd.tmd0 = a;
		tmd.tmd1_hadr = a >> 16;
		tmd.tmd1_bits = 0;
		tmd.tmd2 = 0 | LE_XMD2_ONES;
		tmd.tmd3 = 0;
		(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),
		    sizeof(tmd));
	}
}

void
am7990_rint(struct lance_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	int bix;
	int rp;
	struct lermd rmd;

	bix = sc->sc_last_rd;

	/* Process all buffers with valid data. */
	for (;;) {
		rp = LE_RMDADDR(sc, bix);
		(*sc->sc_copyfromdesc)(sc, &rmd, rp, sizeof(rmd));

		if (rmd.rmd1_bits & LE_R1_OWN)
			break;

		if (rmd.rmd1_bits & LE_R1_ERR) {
			if (rmd.rmd1_bits & LE_R1_ENP) {
#ifdef LEDEBUG
				if ((rmd.rmd1_bits & LE_R1_OFLO) == 0) {
					if (rmd.rmd1_bits & LE_R1_FRAM)
						printf("%s: framing error\n",
						    sc->sc_dev.dv_xname);
					if (rmd.rmd1_bits & LE_R1_CRC)
						printf("%s: crc mismatch\n",
						    sc->sc_dev.dv_xname);
				}
#endif
			} else {
				if (rmd.rmd1_bits & LE_R1_OFLO)
					printf("%s: overflow\n",
					    sc->sc_dev.dv_xname);
			}
			if (rmd.rmd1_bits & LE_R1_BUFF)
				printf("%s: receive buffer error\n",
				    sc->sc_dev.dv_xname);
			ifp->if_ierrors++;
		} else if ((rmd.rmd1_bits & (LE_R1_STP | LE_R1_ENP)) !=
		    (LE_R1_STP | LE_R1_ENP)) {
			printf("%s: dropping chained buffer\n",
			    sc->sc_dev.dv_xname);
			ifp->if_ierrors++;
		} else {
#ifdef LEDEBUG
			if (sc->sc_debug > 1)
				am7990_recv_print(sc, sc->sc_last_rd);
#endif
			m = lance_read(sc, LE_RBUFADDR(sc, bix),
			    (int)rmd.rmd3 - 4);
			if (m != NULL)
				ml_enqueue(&ml, m);
		}

		rmd.rmd1_bits = LE_R1_OWN;
		rmd.rmd2 = -LEBLEN | LE_XMD2_ONES;
		rmd.rmd3 = 0;
		(*sc->sc_copytodesc)(sc, &rmd, rp, sizeof(rmd));

#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("sc->sc_last_rd = %x, rmd: "
			       "ladr %04x, hadr %02x, flags %02x, "
			       "bcnt %04x, mcnt %04x\n",
				sc->sc_last_rd,
				rmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits,
				rmd.rmd2, rmd.rmd3);
#endif

		if (++bix == sc->sc_nrbuf)
			bix = 0;
	}

	sc->sc_last_rd = bix;

	if_input(ifp, &ml);
}

void
am7990_tint(struct lance_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int bix;
	struct letmd tmd;

	bix = sc->sc_first_td;

	for (;;) {
		if (sc->sc_no_td <= 0)
			break;

		(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, bix),
		    sizeof(tmd));

#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("trans tmd: "
			    "ladr %04x, hadr %02x, flags %02x, "
			    "bcnt %04x, mcnt %04x\n",
			    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits,
			    tmd.tmd2, tmd.tmd3);
#endif

		if (tmd.tmd1_bits & LE_T1_OWN)
			break;

		ifq_clr_oactive(&ifp->if_snd);

		if (tmd.tmd1_bits & LE_T1_ERR) {
			if (tmd.tmd3 & LE_T3_BUFF)
				printf("%s: transmit buffer error\n",
				    sc->sc_dev.dv_xname);
			else if (tmd.tmd3 & LE_T3_UFLO)
				printf("%s: underflow\n", sc->sc_dev.dv_xname);
			if (tmd.tmd3 & (LE_T3_BUFF | LE_T3_UFLO)) {
				lance_reset(sc);
				return;
			}
			if (tmd.tmd3 & LE_T3_LCAR) {
				sc->sc_havecarrier = 0;
				if (sc->sc_nocarrier)
					(*sc->sc_nocarrier)(sc);
				else
					printf("%s: lost carrier\n",
					    sc->sc_dev.dv_xname);
			}
			if (tmd.tmd3 & LE_T3_LCOL)
				ifp->if_collisions++;
			if (tmd.tmd3 & LE_T3_RTRY) {
#ifdef LEDEBUG
				printf("%s: excessive collisions, tdr %d\n",
				    sc->sc_dev.dv_xname,
				    tmd.tmd3 & LE_T3_TDR_MASK);
#endif
				ifp->if_collisions += 16;
			}
			ifp->if_oerrors++;
		} else {
			if (tmd.tmd1_bits & LE_T1_ONE)
				ifp->if_collisions++;
			else if (tmd.tmd1_bits & LE_T1_MORE)
				/* Real number is unknown. */
				ifp->if_collisions += 2;
		}

		if (++bix == sc->sc_ntbuf)
			bix = 0;

		--sc->sc_no_td;
	}

	sc->sc_first_td = bix;

	am7990_start(ifp);

	if (sc->sc_no_td == 0)
		ifp->if_timer = 0;
}

/*
 * Controller interrupt.
 */
int
am7990_intr(void *arg)
{
	struct lance_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	uint16_t isr;

	isr = (*sc->sc_rdcsr)(sc, LE_CSR0) | sc->sc_saved_csr0;
	sc->sc_saved_csr0 = 0;
#if defined(LEDEBUG) && LEDEBUG > 1
	if (sc->sc_debug)
		printf("%s: am7990_intr entering with isr=%04x\n",
		    sc->sc_dev.dv_xname, isr);
#endif
	if ((isr & LE_C0_INTR) == 0)
		return (0);

	/*
	 * After receiving an interrupt, we need to toggle the interrupt
	 * enable bit in order to keep receiving them (some chips works
	 * without this, some do not)
	 */
	(*sc->sc_wrcsr)(sc, LE_CSR0, isr & ~LE_C0_INEA);
	(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA);

	if (isr & LE_C0_ERR) {
		if (isr & LE_C0_BABL) {
#ifdef LEDEBUG
			printf("%s: babble\n", sc->sc_dev.dv_xname);
#endif
			ifp->if_oerrors++;
		}
#if 0
		if (isr & LE_C0_CERR) {
			printf("%s: collision error\n", sc->sc_dev.dv_xname);
			ifp->if_collisions++;
		}
#endif
		if (isr & LE_C0_MISS) {
#ifdef LEDEBUG
			printf("%s: missed packet\n", sc->sc_dev.dv_xname);
#endif
			ifp->if_ierrors++;
		}
		if (isr & LE_C0_MERR) {
			printf("%s: memory error\n", sc->sc_dev.dv_xname);
			lance_reset(sc);
			return (1);
		}
	}

	if ((isr & LE_C0_RXON) == 0) {
		printf("%s: receiver disabled\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		lance_reset(sc);
		return (1);
	}
	if ((isr & LE_C0_TXON) == 0) {
		printf("%s: transmitter disabled\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		lance_reset(sc);
		return (1);
	}

	/*
	 * Pretend we have carrier; if we don't this will be cleared
	 * shortly.
	 */
	sc->sc_havecarrier = 1;

	if (isr & LE_C0_RINT)
		am7990_rint(sc);
	if (isr & LE_C0_TINT)
		am7990_tint(sc);

	return (1);
}

/*
 * Setup output on interface.
 * Get another datagram to send off of the interface queue, and map it to the
 * interface before starting the output.
 * Called only at splnet or interrupt level.
 */
void
am7990_start(struct ifnet *ifp)
{
	struct lance_softc *sc = ifp->if_softc;
	int bix;
	struct mbuf *m;
	struct letmd tmd;
	int rp;
	int len;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	bix = sc->sc_last_td;

	for (;;) {
		rp = LE_TMDADDR(sc, bix);
		(*sc->sc_copyfromdesc)(sc, &tmd, rp, sizeof(tmd));

		if (tmd.tmd1_bits & LE_T1_OWN) {
			ifq_set_oactive(&ifp->if_snd);
			printf("missing buffer, no_td = %d, last_td = %d\n",
			    sc->sc_no_td, sc->sc_last_td);
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the packet
		 * before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		len = lance_put(sc, LE_TBUFADDR(sc, bix), m);

#ifdef LEDEBUG
		if (len > ETHERMTU + sizeof(struct ether_header))
			printf("packet length %d\n", len);
#endif

		ifp->if_timer = 5;

		/*
		 * Init transmit registers, and set transmit start flag.
		 */
		tmd.tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;
		tmd.tmd2 = -len | LE_XMD2_ONES;
		tmd.tmd3 = 0;

		(*sc->sc_copytodesc)(sc, &tmd, rp, sizeof(tmd));

#ifdef LEDEBUG
		if (sc->sc_debug > 1)
			am7990_xmit_print(sc, sc->sc_last_td);
#endif

		(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_TDMD);

		if (++bix == sc->sc_ntbuf)
			bix = 0;

		if (++sc->sc_no_td == sc->sc_ntbuf) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

	}

	sc->sc_last_td = bix;
}

#ifdef LEDEBUG
void
am7990_recv_print(struct lance_softc *sc, int no)
{
	struct lermd rmd;
	uint16_t len;
	struct ether_header eh;

	(*sc->sc_copyfromdesc)(sc, &rmd, LE_RMDADDR(sc, no), sizeof(rmd));
	len = rmd.rmd3;
	printf("%s: receive buffer %d, len = %d\n",
	    sc->sc_dev.dv_xname, no, len);
	printf("%s: status %04x\n", sc->sc_dev.dv_xname,
	    (*sc->sc_rdcsr)(sc, LE_CSR0));
	printf("%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\n",
	    sc->sc_dev.dv_xname,
	    rmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits, rmd.rmd2, rmd.rmd3);
	if (len >= sizeof(eh)) {
		(*sc->sc_copyfrombuf)(sc, &eh, LE_RBUFADDR(sc, no), sizeof(eh));
		printf("%s: dst %s", sc->sc_dev.dv_xname,
			ether_sprintf(eh.ether_dhost));
		printf(" src %s type %04x\n", ether_sprintf(eh.ether_shost),
			ntohs(eh.ether_type));
	}
}

void
am7990_xmit_print(struct lance_softc *sc, int no)
{
	struct letmd tmd;
	uint16_t len;
	struct ether_header eh;

	(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, no), sizeof(tmd));
	len = -tmd.tmd2;
	printf("%s: transmit buffer %d, len = %d\n",
	    sc->sc_dev.dv_xname, no, len);
	printf("%s: status %04x\n", sc->sc_dev.dv_xname,
	    (*sc->sc_rdcsr)(sc, LE_CSR0));
	printf("%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\n",
	    sc->sc_dev.dv_xname,
	    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits, tmd.tmd2, tmd.tmd3);
	if (len >= sizeof(eh)) {
		(*sc->sc_copyfrombuf)(sc, &eh, LE_TBUFADDR(sc, no), sizeof(eh));
		printf("%s: dst %s", sc->sc_dev.dv_xname,
			ether_sprintf(eh.ether_dhost));
		printf(" src %s type %04x\n", ether_sprintf(eh.ether_shost),
		    ntohs(eh.ether_type));
	}
}
#endif /* LEDEBUG */
@


1.52
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.51 2015/05/13 10:42:46 jsg Exp $	*/
a357 1
			ifp->if_opackets++;
@


1.51
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.50 2015/05/01 14:56:18 mpi Exp $	*/
d321 1
a321 1
		ifp->if_flags &= ~IFF_OACTIVE;
d472 1
a472 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d482 1
a482 1
			ifp->if_flags |= IFF_OACTIVE;
d532 1
a532 1
			ifp->if_flags |= IFF_OACTIVE;
@


1.50
log
@Convert to if_input(), ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.49 2014/12/22 02:28:51 tedu Exp $	*/
d488 1
a488 1
		if (m == 0)
@


1.49
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.48 2014/07/22 13:12:11 mpi Exp $	*/
d216 2
d263 1
a263 1
			lance_read(sc, LE_RBUFADDR(sc, bix),
d265 2
d289 2
@


1.48
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.47 2013/09/24 20:10:55 miod Exp $	*/
a82 1
#ifdef INET
a84 1
#endif
@


1.47
log
@Sync the MI LANCE code ( le(4) ) with NetBSD, except for the following:
- the am7990_get() - now lance_get() - is unchanged.
- the interrupt acknowledge logic is unchanged, and will disable interrupts,
  then acknowledge all interrupt conditions.

Add ILACC (79900) support (from NetBSD).

Both LANCE (am7990.c) and ILACC (am79900.c) code share as much common code
(lance.c) as possible. This affects all le(4) attachments, but the changes
are mostly mechanical, to split am7990-specific parts from lance-agnostic
parts.

Compile tested on all affected platforms. Tested on alpha, hp300, luna88k,
mvme88k, sparc, sparc64 and vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.46 2013/08/07 01:06:27 bluhm Exp $	*/
a85 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.46
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 32
a32 2
/*	$OpenBSD: am7990.c,v 1.45 2013/05/21 20:08:45 brad Exp $	*/
/*	$NetBSD: am7990.c,v 1.22 1996/10/13 01:37:19 christos Exp $	*/
a34 1
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
d72 1
a72 1
#include <sys/mbuf.h> 
d94 2
d99 2
a100 7
#ifdef LEDEBUG
void am7990_recv_print(struct am7990_softc *, int);
void am7990_xmit_print(struct am7990_softc *, int);
#endif

integrate void am7990_rint(struct am7990_softc *);
integrate void am7990_tint(struct am7990_softc *);
d102 2
a103 3
integrate int am7990_put(struct am7990_softc *, int, struct mbuf *);
integrate struct mbuf *am7990_get(struct am7990_softc *, int, int);
integrate void am7990_read(struct am7990_softc *, int, int); 
d105 3
a107 33
#define	ifp	(&sc->sc_arpcom.ac_if)

#if 0	/* XXX what do we do about this?!  --thorpej */
static inline u_int16_t ether_cmp(void *, void *);

/*
 * Compare two Ether/802 addresses for equality, inlined and
 * unrolled for speed.  I'd love to have an inline assembler
 * version of this...   XXX: Who wanted that? mycroft?
 * I wrote one, but the following is just as efficient.
 * This expands to 10 short m68k instructions! -gwr
 * Note: use this like bcmp()
 */
static inline u_short
ether_cmp(one, two)
	void *one, *two;
{
	register u_int16_t *a = (u_short *) one;
	register u_int16_t *b = (u_short *) two;
	register u_int16_t diff;

	diff  = *a++ - *b++;
	diff |= *a++ - *b++;
	diff |= *a++ - *b++;

	return (diff);
}

#define ETHER_CMP	ether_cmp
#endif /* XXX */

#ifndef	ETHER_CMP
#define	ETHER_CMP(a, b) bcmp((a), (b), ETHER_ADDR_LEN)
a113 4
struct cfdriver le_cd = {
	NULL, "le", DV_IFNET
};

d115 1
a115 2
am7990_config(sc)
	struct am7990_softc *sc;
d117 1
a117 1
	int mem;
d119 2
a120 2
	/* Make sure the chip is stopped. */
	am7990_stop(sc);
d122 1
a122 55
	/* Initialize ifnet structure. */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = am7990_start;
	ifp->if_ioctl = am7990_ioctl;
	ifp->if_watchdog = am7990_watchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
#ifdef LANCE_REVC_BUG
	ifp->if_flags &= ~IFF_MULTICAST;
#endif
	ifp->if_baudrate = IF_Mbps(10);
	IFQ_SET_READY(&ifp->if_snd);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	if (sc->sc_memsize > 262144)
		sc->sc_memsize = 262144;

	switch (sc->sc_memsize) {
	case 8192:
		sc->sc_nrbuf = 4;
		sc->sc_ntbuf = 1;
		break;
	case 16384:
		sc->sc_nrbuf = 8;
		sc->sc_ntbuf = 2;
		break;
	case 32768:
		sc->sc_nrbuf = 16;
		sc->sc_ntbuf = 4;
		break;
	case 65536:
		sc->sc_nrbuf = 32;
		sc->sc_ntbuf = 8;
		break;
	case 131072:
		sc->sc_nrbuf = 64;
		sc->sc_ntbuf = 16;
		break;
	case 262144:
		sc->sc_nrbuf = 128;
		sc->sc_ntbuf = 32;
		break;
	default:
		panic("am7990_config: weird memory size %lu", sc->sc_memsize);
	}

	printf(": address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
	printf("%s: %d receive buffers, %d transmit buffers\n",
	    sc->sc_dev.dv_xname, sc->sc_nrbuf, sc->sc_ntbuf);
d125 1
a125 1
	sc->sc_initaddr = mem;
d127 8
a134 8
	sc->sc_rmdaddr = mem;
	mem += sizeof(struct lermd) * sc->sc_nrbuf;
	sc->sc_tmdaddr = mem;
	mem += sizeof(struct letmd) * sc->sc_ntbuf;
	sc->sc_rbufaddr = mem;
	mem += ETHER_MAX_DIX_LEN * sc->sc_nrbuf;
	sc->sc_tbufaddr = mem;
	mem += ETHER_MAX_DIX_LEN * sc->sc_ntbuf;
a140 11
void
am7990_reset(sc)
	struct am7990_softc *sc;
{
	int s;

	s = splnet();
	am7990_init(sc);
	splx(s);
}

d145 1
a145 2
am7990_meminit(sc)
	register struct am7990_softc *sc;
d147 1
d153 1
a154 1
#if NBPFILTER > 0
a157 1
#endif
d159 14
a172 7
	init.init_padr[0] =
	    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];
	init.init_padr[1] =
	    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];
	init.init_padr[2] =
	    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];
	am7990_setladrf(&sc->sc_arpcom, init.init_ladrf);
d195 1
a195 1
		rmd.rmd2 = -ETHER_MAX_DIX_LEN | LE_XMD2_ONES;
d217 1
a217 2
am7990_stop(sc)
	struct am7990_softc *sc;
d219 2
a220 209

	(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);
}

/*
 * Initialization of interface; set up initialization block
 * and transmit/receive descriptor rings.
 */
void
am7990_init(sc)
	register struct am7990_softc *sc;
{
	register int timo;
	u_long a;

	(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);
	DELAY(100);

	/* Newer LANCE chips have a reset register */
	if (sc->sc_hwreset)
		(*sc->sc_hwreset)(sc);

	/* Set the correct byte swapping mode, etc. */
	(*sc->sc_wrcsr)(sc, LE_CSR3, sc->sc_conf3);

	/* Set up LANCE init block. */
	am7990_meminit(sc);

	/* Give LANCE the physical address of its init block. */
	a = sc->sc_addr + LE_INITADDR(sc);
	(*sc->sc_wrcsr)(sc, LE_CSR1, a);
	(*sc->sc_wrcsr)(sc, LE_CSR2, a >> 16);

	/* Try to initialize the LANCE. */
	DELAY(100);
	(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INIT);

	/* Wait for initialization to finish. */
	for (timo = 100000; timo; timo--)
		if ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON)
			break;

	if ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON) {
		/* Start the LANCE. */
		(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_STRT |
		    LE_C0_IDON);
		ifp->if_flags |= IFF_RUNNING;
		ifp->if_flags &= ~IFF_OACTIVE;
		ifp->if_timer = 0;
		am7990_start(ifp);
	} else
		printf("%s: controller failed to initialize\n", sc->sc_dev.dv_xname);
	if (sc->sc_hwinit)
		(*sc->sc_hwinit)(sc);
}

/*
 * Routine to copy from mbuf chain to transmit buffer in
 * network buffer memory.
 */
integrate int
am7990_put(sc, boff, m)
	struct am7990_softc *sc;
	int boff;
	register struct mbuf *m;
{
	register struct mbuf *n;
	register int len, tlen = 0;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			MFREE(m, n);
			continue;
		}
		(*sc->sc_copytobuf)(sc, mtod(m, caddr_t), boff, len);
		boff += len;
		tlen += len;
		MFREE(m, n);
	}
	if (tlen < LEMINSIZE) {
		(*sc->sc_zerobuf)(sc, boff, LEMINSIZE - tlen);
		tlen = LEMINSIZE;
	}
	return (tlen);
}

/*
 * Pull data off an interface.
 * Len is length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present
 * we copy into clusters.
 */
integrate struct mbuf *
am7990_get(sc, boff, totlen)
	struct am7990_softc *sc;
	int boff, totlen;
{
	register struct mbuf *m;
	struct mbuf *top, **mp;
	int len, pad;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return (0);
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m->m_data += pad;
	len = MHLEN - pad;
	top = 0;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return 0;
			}
			len = MLEN;
		}
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT) {
				len = MCLBYTES;
				if (!top) {
					m->m_data += pad;
					len -= pad;
				}
			}
		}
		m->m_len = len = min(totlen, len);
		(*sc->sc_copyfrombuf)(sc, mtod(m, caddr_t), boff, len);
		boff += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}

/*
 * Pass a packet to the higher levels.
 */
integrate void
am7990_read(sc, boff, len)
	register struct am7990_softc *sc;
	int boff, len;
{
	struct mbuf *m;
#ifdef LANCE_REVC_BUG
	struct ether_header *eh;
#endif

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + ETHER_VLAN_ENCAP_LEN + sizeof(struct ether_header)) {
#ifdef LEDEBUG
		printf("%s: invalid packet size %d; dropping\n",
		    sc->sc_dev.dv_xname, len);
#endif
		ifp->if_ierrors++;
		return;
	}

	/* Pull packet off interface. */
	m = am7990_get(sc, boff, len);
	if (m == 0) {
		ifp->if_ierrors++;
		return;
	}

	ifp->if_ipackets++;

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

#ifdef LANCE_REVC_BUG
	/*
	 * The old LANCE (Rev. C) chips have a bug which causes
	 * garbage to be inserted in front of the received packet.
	 * The work-around is to ignore packets with an invalid
	 * destination address (garbage will usually not match).
	 * Of course, this precludes multicast support...
	 */
	eh = mtod(m, struct ether_header *);
	if (ETHER_CMP(eh->ether_dhost, sc->sc_arpcom.ac_enaddr) &&
	    ETHER_CMP(eh->ether_dhost, etherbroadcastaddr)) {
		m_freem(m);
		return;
	}
#endif

	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
}

integrate void
am7990_rint(sc)
	struct am7990_softc *sc;
{
	register int bix;
d261 2
a262 2
#ifdef LEDEBUG1
			if (sc->sc_debug)
d265 1
a265 1
			am7990_read(sc, LE_RBUFADDR(sc, bix),
d270 1
a270 1
		rmd.rmd2 = -ETHER_MAX_DIX_LEN | LE_XMD2_ONES;
d274 1
a274 1
#ifdef LEDEBUG1
d291 2
a292 3
integrate void
am7990_tint(sc)
	register struct am7990_softc *sc;
d294 2
a295 1
	register int bix;
d328 1
a328 1
				am7990_reset(sc);
d332 1
d335 3
d342 1
d346 1
d377 1
a377 2
am7990_intr(arg)
	register void *arg;
d379 8
a386 6
	register struct am7990_softc *sc = arg;
	register u_int16_t isr;

	isr = (*sc->sc_rdcsr)(sc, LE_CSR0);
#ifdef LEDEBUG
	if (sc->sc_debug){
a388 2
		printf(" isr: 0x%b\n", isr, LE_C0_BITS);
	}
d422 1
a422 1
			am7990_reset(sc);
d430 1
a430 1
		am7990_reset(sc);
d436 1
a436 1
		am7990_reset(sc);
d440 6
a453 14
#undef	ifp

void
am7990_watchdog(ifp)
	struct ifnet *ifp;
{
	struct am7990_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++ifp->if_oerrors;

	am7990_reset(sc);
}

d461 1
a461 2
am7990_start(ifp)
	register struct ifnet *ifp;
d463 3
a465 3
	register struct am7990_softc *sc = ifp->if_softc;
	register int bix;
	register struct mbuf *m;
d501 1
a501 1
		len = am7990_put(sc, LE_TBUFADDR(sc, bix), m);
d520 1
a520 1
		if (sc->sc_debug)
a529 3
#ifdef LEDEBUG
			printf("\nequal!\n");
#endif
a538 70
/*
 * Process an ioctl request.
 */
int
am7990_ioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	register struct am7990_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			am7990_init(sc);
#ifdef INET
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
#endif
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				am7990_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING) {
				am7990_stop(sc);
				ifp->if_flags &= ~IFF_RUNNING;
			}
		}

#ifdef LEDEBUG
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = 1;
		else
			sc->sc_debug = 0;
#endif
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		if (sc->sc_hasifmedia)
			error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		else
			error = EINVAL;
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			am7990_reset(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

d541 1
a541 3
am7990_recv_print(sc, no)
	struct am7990_softc *sc;
	int no;
d544 1
a544 1
	u_int16_t len;
d549 2
a550 2
	printf("%s: receive buffer %d, len = %d\n", sc->sc_dev.dv_xname, no,
	    len);
d566 1
a566 3
am7990_xmit_print(sc, no)
	struct am7990_softc *sc;
	int no;
d569 1
a569 1
	u_int16_t len;
d574 2
a575 2
	printf("%s: transmit buffer %d, len = %d\n", sc->sc_dev.dv_xname, no,
	    len);
a589 283

/*
 * Set up the logical address filter.
 */
void
am7990_setladrf(ac, af)
	struct arpcom *ac;
	u_int16_t *af;
{
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	register u_int32_t crc;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ifp->if_flags & IFF_PROMISC)
		goto allmulti;

	af[0] = af[1] = af[2] = af[3] = 0x0000;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (ETHER_CMP(enm->enm_addrlo, enm->enm_addrhi)) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			goto allmulti;
		}

		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;

		/* Set the corresponding bit in the filter. */
		af[crc >> 4] |= 1 << (crc & 0xf);

		ETHER_NEXT_MULTI(step, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
	return;

allmulti:
	ifp->if_flags |= IFF_ALLMULTI;
	af[0] = af[1] = af[2] = af[3] = 0xffff;
}


/*
 * Routines for accessing the transmit and receive buffers.
 * The various CPU and adapter configurations supported by this
 * driver require three different access methods for buffers
 * and descriptors:
 *	(1) contig (contiguous data; no padding),
 *	(2) gap2 (two bytes of data followed by two bytes of padding),
 *	(3) gap16 (16 bytes of data followed by 16 bytes of padding).
 */

/*
 * contig: contiguous data with no padding.
 *
 * Buffers may have any alignment.
 */

void
am7990_copytobuf_contig(sc, from, boff, len)
	struct am7990_softc *sc;
	void *from;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(from, buf + boff, len);
}

void
am7990_copyfrombuf_contig(sc, to, boff, len)
	struct am7990_softc *sc;
	void *to;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(buf + boff, to, len);
}

void
am7990_zerobuf_contig(sc, boff, len)
	struct am7990_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just let bzero() do the work
	 */
	bzero(buf + boff, len);
}

#if 0
/*
 * Examples only; duplicate these and tweak (if necessary) in
 * machine-specific front-ends.
 */

/*
 * gap2: two bytes of data followed by two bytes of pad.
 *
 * Buffers must be 4-byte aligned.  The code doesn't worry about
 * doing an extra byte.
 */

void
am7990_copytobuf_gap2(sc, fromv, boff, len)
	struct am7990_softc *sc;
	void *fromv;
	int boff;
	register int len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t from = fromv;
	register volatile u_int16_t *bptr;

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*bptr = (*from++ << 8) | (*bptr & 0xff);
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 1) {
		*bptr = (from[1] << 8) | (from[0] & 0xff);
		bptr += 2;
		from += 2;
		len -= 2;
	}
	if (len == 1)
		*bptr = (u_int16_t)*from;
}

void
am7990_copyfrombuf_gap2(sc, tov, boff, len)
	struct am7990_softc *sc;
	void *tov;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t to = tov;
	register volatile u_int16_t *bptr;
	register u_int16_t tmp;

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*to++ = (*bptr >> 8) & 0xff;
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 1) {
		tmp = *bptr;
		*to++ = tmp & 0xff;
		*to++ = (tmp >> 8) & 0xff;
		bptr += 2;
		len -= 2;
	}
	if (len == 1)
		*to = *bptr & 0xff;
}

void
am7990_zerobuf_gap2(sc, boff, len)
	struct am7990_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register volatile u_int16_t *bptr;

	if ((unsigned)boff & 0x1) {
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*bptr &= 0xff;
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 0) {
		*bptr = 0;
		bptr += 2;
		len -= 2;
	}
}

/*
 * gap16: 16 bytes of data followed by 16 bytes of pad.
 *
 * Buffers must be 32-byte aligned.
 */

void
am7990_copytobuf_gap16(sc, fromv, boff, len)
	struct am7990_softc *sc;
	void *fromv;
	int boff;
	register int len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t from = fromv;
	register caddr_t bptr;
	register int xfer;

	bptr = buf + ((boff << 1) & ~0x1f);
	boff &= 0xf;
	xfer = min(len, 16 - boff);
	while (len > 0) {
		bcopy(from, bptr + boff, xfer);
		from += xfer;
		bptr += 32;
		boff = 0;
		len -= xfer;
		xfer = min(len, 16);
	}
}

void
am7990_copyfrombuf_gap16(sc, tov, boff, len)
	struct am7990_softc *sc;
	void *tov;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t to = tov;
	register caddr_t bptr;
	register int xfer;

	bptr = buf + ((boff << 1) & ~0x1f);
	boff &= 0xf;
	xfer = min(len, 16 - boff);
	while (len > 0) {
		bcopy(bptr + boff, to, xfer);
		to += xfer;
		bptr += 32;
		boff = 0;
		len -= xfer;
		xfer = min(len, 16);
	}
}

void
am7990_zerobuf_gap16(sc, boff, len)
	struct am7990_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t bptr;
	register int xfer;

	bptr = buf + ((boff << 1) & ~0x1f);
	boff &= 0xf;
	xfer = min(len, 16 - boff);
	while (len > 0) {
		bzero(bptr + boff, xfer);
		bptr += 32;
		boff = 0;
		len -= xfer;
		xfer = min(len, 16);
	}
}
#endif /* Example only */
@


1.45
log
@Rewrite ioctl handling bits.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.44 2009/08/10 20:29:54 deraadt Exp $	*/
a57 1
#include <netinet/in_var.h>
@


1.44
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.43 2008/11/28 02:44:17 brad Exp $	*/
d843 2
a844 2

		switch (ifa->ifa_addr->sa_family) {
d846 1
a846 2
		case AF_INET:
			am7990_init(sc);
a847 1
			break;
a848 4
		default:
			am7990_init(sc);
			break;
		}
d852 5
a856 15
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			am7990_stop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			am7990_init(sc);
d858 4
a861 6
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			/*am7990_stop(sc);*/
			am7990_init(sc);
d863 1
@


1.43
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.42 2008/10/02 20:21:13 brad Exp $	*/
a80 2
hide void am7990_shutdown(void *);

a188 4
	sc->sc_sh = shutdownhook_establish(am7990_shutdown, sc);
	if (sc->sc_sh == NULL)
		panic("am7990_config: can't establish shutdownhook");

a908 8
}

hide void
am7990_shutdown(arg)
	void *arg;
{

	am7990_stop((struct am7990_softc *)arg);
@


1.42
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.41 2006/04/20 20:31:12 miod Exp $	*/
a894 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				am7990_reset(sc);
			error = 0;
		}
		break;

d905 6
@


1.41
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.40 2006/03/25 22:41:42 djm Exp $	*/
a845 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}

a846 1

d921 1
a921 2
		error = EINVAL;
		break;
@


1.40
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.39 2005/11/07 03:20:00 brad Exp $	*/
d184 1
a184 1
		panic("am7990_config: weird memory size %d", sc->sc_memsize);
@


1.39
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.38 2005/01/15 05:24:10 brad Exp $	*/
d477 1
a477 1
		bpf_mtap(ifp->if_bpf, m);
d783 1
a783 1
			bpf_mtap(ifp->if_bpf, m);
@


1.38
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.37 2005/01/01 03:59:52 brad Exp $	*/
d218 1
a218 1
	s = splimp();
d745 1
a745 1
 * Called only at splimp or interrupt level.
d844 1
a844 1
	s = splimp();
@


1.37
log
@allow reception of VLAN sized frames.

tested and ok niklas@@

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.36 2004/09/28 04:37:32 brad Exp $	*/
d912 2
a913 1
			am7990_reset(sc);
@


1.36
log
@Use ETHER_MAX_DIX_LEN/ETHER_MIN_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.35 2004/06/01 12:58:51 mcbride Exp $	*/
d149 2
d453 1
a453 1
	    len > ETHERMTU + sizeof(struct ether_header)) {
@


1.35
log
@Replace hand-rolled crc32 with ether_crc32_le().
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.34 2004/05/12 06:35:10 tedu Exp $	*/
d201 1
a201 1
	mem += LEBLEN * sc->sc_nrbuf;
d203 1
a203 1
	mem += LEBLEN * sc->sc_ntbuf;
d269 1
a269 1
		rmd.rmd2 = -LEBLEN | LE_XMD2_ONES;
d552 1
a552 1
		rmd.rmd2 = -LEBLEN | LE_XMD2_ONES;
@


1.34
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.33 2003/08/18 18:23:58 jason Exp $	*/
a1005 1
	register u_char *cp, c;
a1006 1
	register int i, len;
d1035 1
a1035 15
		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			c = *cp++;
			for (i = 8; --i >= 0;) {
				if ((crc & 0x01) ^ (c & 0x01)) {
					crc >>= 1;
					crc ^= 0xedb88320;
				} else
					crc >>= 1;
				c >>= 1;
			}
		}
		/* Just want the 6 most significant bits. */
		crc >>= 26;
@


1.33
log
@back out previous.  miod pointed out that we don't recover from this
correctly, so complaining gives a better description of what's going on.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.31 2003/06/02 23:28:01 millert Exp $	*/
a63 1
#include <net/bpfdesc.h>
@


1.32
log
@#ifdef warning about chained buffers
@
text
@a539 1
#ifdef LEDEBUG
a541 1
#endif
@


1.31
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.30 2003/05/13 12:10:46 todd Exp $	*/
d540 1
d543 1
@


1.30
log
@remove annoying sputtering that no other ethernet driver does; ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.29 2002/12/02 18:48:52 henning Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.29
log
@set if_baudrate
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.28 2002/03/14 01:26:54 millert Exp $	*/
a620 3
				else
					printf("%s: lost carrier\n",
					    sc->sc_dev.dv_xname);
@


1.28
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.27 2001/07/27 15:30:42 tholo Exp $	*/
d151 1
@


1.27
log
@Change how interrupts are acknowledged -- this is how the specification say
they should be acknowledged, and makes things work under VMware without the
timeout problems.  miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.26 2001/06/27 06:34:39 kjc Exp $	*/
d75 2
a76 2
void am7990_recv_print __P((struct am7990_softc *, int));
void am7990_xmit_print __P((struct am7990_softc *, int));
d79 2
a80 2
integrate void am7990_rint __P((struct am7990_softc *));
integrate void am7990_tint __P((struct am7990_softc *));
d82 3
a84 3
integrate int am7990_put __P((struct am7990_softc *, int, struct mbuf *));
integrate struct mbuf *am7990_get __P((struct am7990_softc *, int, int));
integrate void am7990_read __P((struct am7990_softc *, int, int)); 
d86 1
a86 1
hide void am7990_shutdown __P((void *));
d91 1
a91 1
static inline u_int16_t ether_cmp __P((void *, void *));
@


1.27.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.27 2001/07/27 15:30:42 tholo Exp $	*/
d75 2
a76 2
void am7990_recv_print(struct am7990_softc *, int);
void am7990_xmit_print(struct am7990_softc *, int);
d79 2
a80 2
integrate void am7990_rint(struct am7990_softc *);
integrate void am7990_tint(struct am7990_softc *);
d82 3
a84 3
integrate int am7990_put(struct am7990_softc *, int, struct mbuf *);
integrate struct mbuf *am7990_get(struct am7990_softc *, int, int);
integrate void am7990_read(struct am7990_softc *, int, int); 
d86 1
a86 1
hide void am7990_shutdown(void *);
d91 1
a91 1
static inline u_int16_t ether_cmp(void *, void *);
@


1.27.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a150 1
	ifp->if_baudrate = IF_Mbps(10);
d620 3
@


1.26
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.25 2001/06/24 22:36:57 miod Exp $	*/
a676 1
#ifdef __vax__
d678 3
a680 2
	 * DEC needs this write order to the registers, don't know
	 * the results on other arch's.  Ragge 991029
d682 1
a682 2
	isr &= ~LE_C0_INEA;
	(*sc->sc_wrcsr)(sc, LE_CSR0, isr);
d684 1
a684 5
#else
	(*sc->sc_wrcsr)(sc, LE_CSR0,
	    isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_CERR | LE_C0_MISS | LE_C0_MERR |
		   LE_C0_RINT | LE_C0_TINT | LE_C0_IDON));
#endif
@


1.25
log
@Spelling ifdef correctly is not enough, you have to spell the conditionnal
correctly, too...
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.24 2001/06/24 04:48:02 fgsch Exp $	*/
d151 1
d783 1
a783 1
		IF_DEQUEUE(&ifp->if_snd, m);
@


1.24
log
@damn, correctly spell ifdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.23 2001/06/24 04:24:18 fgsch Exp $	*/
d449 1
a449 1
#ifdef LANCE_RECV_BUG
@


1.23
log
@better.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.22 2001/06/23 23:17:35 fgsch Exp $	*/
d449 1
a449 1
#ifedef LANCE_RECV_BUG
@


1.22
log
@ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.21 2001/03/01 07:37:17 bjc Exp $	*/
d449 3
a481 4
	{
	struct ether_header *eh;
	eh = mtod(m, struct ether_header *);

d489 1
a494 1
	}
d497 1
@


1.21
log
@(all changes made behind #ifdef __vax__)

For the vax, write CSR0 in two steps instead of one.  Why?  DEC says so.
This eliminates most (or all) of the le* timeout errors under heavy
cpu/net usage.  Fix from netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.20 2001/02/20 19:39:36 mickey Exp $	*/
a448 1
	struct ether_header *eh;
a468 3
	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d479 4
d495 1
d498 1
a498 3
	/* Pass the packet up, with the ether header sort-of removed. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.20
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.19 2000/03/15 14:37:49 deraadt Exp $	*/
d677 9
d689 1
@


1.19
log
@more smurph damage control
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.18 2000/03/14 19:50:13 deraadt Exp $	*/
a154 4

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.18
log
@sloppy smurph, leaving debug garbage behind...
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.17 2000/03/10 00:53:58 smurph Exp $	*/
d822 1
d824 1
@


1.17
log
@increased buffer size.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.16 1999/12/08 06:08:04 itojun Exp $	*/
a70 1
#define LEDEBUG 1
@


1.16
log
@fix mbuf chain allocation to comply with m_devget() way.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.15 1999/02/28 05:02:16 jason Exp $	*/
d71 1
d161 2
a162 2
	if (sc->sc_memsize > 131072)
		sc->sc_memsize = 131072;
d185 4
d552 1
a552 1
#ifdef LEDEBUG
d565 1
a565 1
#ifdef LEDEBUG
d673 1
a673 1
	if (sc->sc_debug)
d676 2
d683 1
a683 1
	    isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_MISS | LE_C0_MERR |
d823 1
@


1.16.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d160 2
a161 2
	if (sc->sc_memsize > 262144)
		sc->sc_memsize = 262144;
a183 4
	case 262144:
		sc->sc_nrbuf = 128;
		sc->sc_ntbuf = 32;
		break;
d547 1
a547 1
#ifdef LEDEBUG1
d560 1
a560 1
#ifdef LEDEBUG1
d668 1
a668 1
	if (sc->sc_debug){
a670 2
		printf(" isr: 0x%b\n", isr, LE_C0_BITS);
	}
d676 1
a676 1
	    isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_CERR | LE_C0_MISS | LE_C0_MERR |
a815 3
#ifdef LEDEBUG
			printf("\nequal!\n");
#endif
@


1.16.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.21 2001/03/01 07:37:17 bjc Exp $	*/
d156 4
a680 9
#ifdef __vax__
	/*
	 * DEC needs this write order to the registers, don't know
	 * the results on other arch's.  Ragge 991029
	 */
	isr &= ~LE_C0_INEA;
	(*sc->sc_wrcsr)(sc, LE_CSR0, isr);
	(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA);
#else
a683 1
#endif
@


1.16.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.16.2.2 2001/05/14 22:23:26 niklas Exp $	*/
a150 1
	IFQ_SET_READY(&ifp->if_snd);
a448 1
#ifdef LANCE_REVC_BUG
a449 1
#endif
d470 3
a489 1
	eh = mtod(m, struct ether_header *);
d497 3
a499 2
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
d783 1
a783 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.16.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.16.2.3 2001/07/04 10:40:29 niklas Exp $	*/
d677 1
d679 2
a680 3
	 * After receiving an interrupt, we need to toggle the interrupt
	 * enable bit in order to keep receiving them (some chips works
	 * without this, some do not)
d682 2
a683 1
	(*sc->sc_wrcsr)(sc, LE_CSR0, isr & ~LE_C0_INEA);
d685 5
a689 1

@


1.16.2.5
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 2
a76 2
void am7990_recv_print(struct am7990_softc *, int);
void am7990_xmit_print(struct am7990_softc *, int);
d79 2
a80 2
integrate void am7990_rint(struct am7990_softc *);
integrate void am7990_tint(struct am7990_softc *);
d82 3
a84 3
integrate int am7990_put(struct am7990_softc *, int, struct mbuf *);
integrate struct mbuf *am7990_get(struct am7990_softc *, int, int);
integrate void am7990_read(struct am7990_softc *, int, int); 
d86 1
a86 1
hide void am7990_shutdown(void *);
d91 1
a91 1
static inline u_int16_t ether_cmp(void *, void *);
@


1.16.2.6
log
@Sync the SMP branch with 3.3
@
text
@a150 1
	ifp->if_baudrate = IF_Mbps(10);
@


1.16.2.7
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d621 3
@


1.16.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.16.2.7 2003/05/16 00:29:41 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.16.2.9
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
d1007 1
d1009 1
d1038 15
a1052 1
		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
@


1.15
log
@compensate for check on unicast packets rx'd in promisc mode being moved
to ether_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.14 1998/09/16 22:41:20 jason Exp $	*/
d419 1
a419 1
		if (top && totlen >= MINCLSIZE) {
d421 1
a421 1
			if (m->m_flags & M_EXT)
d423 5
@


1.14
log
@o if_media'fied am7990
o if_media'fied sun4m le.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.13 1998/06/24 20:05:03 deraadt Exp $	*/
d473 1
a473 1
	if (ifp->if_bpf) {
a474 15

#ifndef LANCE_REVC_BUG
		/*
		 * Note that the interface cannot be in promiscuous mode if
		 * there are no BPF listeners.  And if we are in promiscuous
		 * mode, we have to check if this packet is really ours.
		 */
		if ((ifp->if_flags & IFF_PROMISC) != 0 &&
		    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    ETHER_CMP(eh->ether_dhost, sc->sc_arpcom.ac_enaddr)) {
			m_freem(m);
			return;
		}
#endif
	}
@


1.13
log
@initialization error; joel@@wmi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.12 1998/06/08 17:14:43 deraadt Exp $	*/
d56 1
d920 8
@


1.12
log
@am7990 is a chip
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.11 1998/03/09 09:33:04 deraadt Exp $	*/
d599 3
a609 3

		(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, bix),
		    sizeof(tmd));
@


1.11
log
@handle 128KB if_le chunks
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.10 1997/08/08 08:05:40 downsj Exp $	*/
d347 1
a347 1
		printf("%s: card failed to initialize\n", sc->sc_dev.dv_xname);
@


1.10
log
@Add hwreset callback; drivers need to set this appropiately.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.9 1996/11/28 23:27:46 niklas Exp $	*/
d159 3
d179 4
d184 1
a184 1
		panic("am7990_config: weird memory size");
@


1.9
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: am7990.c,v 1.5 1996/04/21 22:21:15 deraadt Exp $	*/
d306 4
@


1.8
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d2 1
a2 1
/*	$NetBSD: am7990.c,v 1.19 1996/05/07 01:38:35 thorpej Exp $	*/
d591 4
a594 4
			       "ladr %04x, hadr %02x, flags %02x, "
			       "bcnt %04x, mcnt %04x\n",
				tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits,
				tmd.tmd2, tmd.tmd3);
d615 7
a621 3
			if (tmd.tmd3 & LE_T3_LCAR)
				printf("%s: lost carrier\n",
				    sc->sc_dev.dv_xname);
@


1.7
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d2 1
a2 1
/*	$NetBSD: am7990.c,v 1.18 1996/04/22 02:40:50 christos Exp $	*/
d43 9
d55 2
d58 2
d70 3
d74 2
a75 2
void recv_print __P((struct le_softc *, int));
void xmit_print __P((struct le_softc *, int));
d78 9
d89 29
d122 8
d131 2
a132 2
leconfig(sc)
	struct le_softc *sc;
d137 1
a137 1
	lestop(sc);
d140 5
a144 4
	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_start = lestart;
	ifp->if_ioctl = leioctl;
	ifp->if_watchdog = lewatchdog;
d177 1
a177 1
		panic("leconfig: weird memory size");
d184 4
d206 2
a207 2
lereset(sc)
	struct le_softc *sc;
d212 1
a212 1
	leinit(sc);
a215 12
void
lewatchdog(unit)
	int unit;
{
	struct le_softc *sc = LE_SOFTC(unit);

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++ifp->if_oerrors;

	lereset(sc);
}

d220 2
a221 2
lememinit(sc)
	register struct le_softc *sc;
d241 1
a241 1
	lesetladrf(&sc->sc_arpcom, init.init_ladrf);
d286 2
a287 2
lestop(sc)
	struct le_softc *sc;
d290 1
a290 1
	lewrcsr(sc, LE_CSR0, LE_C0_STOP);
d298 2
a299 2
leinit(sc)
	register struct le_softc *sc;
d304 2
a305 2
	lewrcsr(sc, LE_CSR0, LE_C0_STOP);
	LE_DELAY(100);
d308 1
a308 1
	lewrcsr(sc, LE_CSR3, sc->sc_conf3);
d311 1
a311 1
	lememinit(sc);
d315 2
a316 2
	lewrcsr(sc, LE_CSR1, a);
	lewrcsr(sc, LE_CSR2, a >> 16);
d319 2
a320 2
	LE_DELAY(100);
	lewrcsr(sc, LE_CSR0, LE_C0_INIT);
d324 1
a324 1
		if (lerdcsr(sc, LE_CSR0) & LE_C0_IDON)
d327 1
a327 1
	if (lerdcsr(sc, LE_CSR0) & LE_C0_IDON) {
d329 2
a330 1
		lewrcsr(sc, LE_CSR0, LE_C0_INEA | LE_C0_STRT | LE_C0_IDON);
d334 1
a334 1
		lestart(ifp);
d337 2
a338 1
	lehwinit(sc);
d346 2
a347 2
leput(sc, boff, m)
	struct le_softc *sc;
d379 2
a380 2
leget(sc, boff, totlen)
	struct le_softc *sc;
d427 2
a428 2
leread(sc, boff, len)
	register struct le_softc *sc;
d445 1
a445 1
	m = leget(sc, boff, len);
d501 2
a502 2
lerint(sc)
	struct le_softc *sc;
d547 1
a547 1
				recv_print(sc, sc->sc_last_rd);
d549 2
a550 1
			leread(sc, LE_RBUFADDR(sc, bix), (int)rmd.rmd3 - 4);
d576 2
a577 2
letint(sc)
	register struct le_softc *sc;
d607 2
a608 1
				printf("%s: transmit buffer error\n", sc->sc_dev.dv_xname);
d612 1
a612 1
				lereset(sc);
d616 2
a617 1
				printf("%s: lost carrier\n", sc->sc_dev.dv_xname);
d622 2
a623 1
				    sc->sc_dev.dv_xname, tmd.tmd3 & LE_T3_TDR_MASK);
d644 1
a644 1
	lestart(ifp);
d654 1
a654 1
leintr(arg)
d657 1
a657 1
	register struct le_softc *sc = arg;
d660 1
a660 1
	isr = lerdcsr(sc, LE_CSR0);
d663 1
a663 1
		printf("%s: leintr entering with isr=%04x\n",
d669 1
a669 1
	lewrcsr(sc, LE_CSR0,
d693 1
a693 1
			lereset(sc);
d701 1
a701 1
		lereset(sc);
d707 1
a707 1
		lereset(sc);
d712 1
a712 1
		lerint(sc);
d714 1
a714 1
		letint(sc);
d721 12
d740 1
a740 1
lestart(ifp)
d743 1
a743 1
	register struct le_softc *sc = LE_SOFTC(ifp->if_unit);
d781 1
a781 1
		len = leput(sc, LE_TBUFADDR(sc, bix), m);
d801 1
a801 1
			xmit_print(sc, sc->sc_last_td);
d804 1
a804 1
		lewrcsr(sc, LE_CSR0, LE_C0_INEA | LE_C0_TDMD);
d823 1
a823 1
leioctl(ifp, cmd, data)
d828 1
a828 1
	struct le_softc *sc = LE_SOFTC(ifp->if_unit);
d848 1
a848 1
			leinit(sc);
d853 1
a853 1
			leinit(sc);
d865 1
a865 1
			lestop(sc);
d873 1
a873 1
			leinit(sc);
d879 2
a880 2
			/*lestop(sc);*/
			leinit(sc);
d901 1
a901 1
			lereset(sc);
d915 8
d925 2
a926 2
recv_print(sc, no)
	struct le_softc *sc;
d937 2
a938 1
	printf("%s: status %04x\n", sc->sc_dev.dv_xname, lerdcsr(sc, LE_CSR0));
d952 2
a953 2
xmit_print(sc, no)
	struct le_softc *sc;
d964 2
a965 1
	printf("%s: status %04x\n", sc->sc_dev.dv_xname, lerdcsr(sc, LE_CSR0));
d983 1
a983 1
lesetladrf(ac, af)
a1059 1
#ifdef LE_NEED_BUF_CONTIG
d1068 1
a1068 1
	struct le_softc *sc;
d1082 1
a1082 1
	struct le_softc *sc;
d1096 1
a1096 1
	struct le_softc *sc;
a1105 1
#endif /* LE_NEED_BUF_CONTIG */
d1107 6
a1112 1
#ifdef LE_NEED_BUF_GAP2
d1122 1
a1122 1
	struct le_softc *sc;
d1151 1
a1151 1
	struct le_softc *sc;
d1181 1
a1181 1
	struct le_softc *sc;
a1199 1
#endif /* LE_NEED_BUF_GAP2 */
a1200 1
#ifdef LE_NEED_BUF_GAP16
d1209 1
a1209 1
	struct le_softc *sc;
d1234 1
a1234 1
	struct le_softc *sc;
d1258 1
a1258 1
	struct le_softc *sc;
d1276 1
a1276 1
#endif /* LE_NEED_BUF_GAP16 */
@


1.6
log
@make these work together
@
text
@a51 13
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#if defined(CCITT) && defined(LLC)
#include <sys/socketvar.h>
#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>
#endif

d762 5
a778 17
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			leinit(sc);
			break;
		    }
#endif
a783 10

#if defined(CCITT) && defined(LLC)
	case SIOCSIFCONF_X25:
		ifp->if_flags |= IFF_UP;
		ifa->ifa_rtrequest = cons_rtrequest; /* XXX */
		error = x25_llcglue(PRC_IFUP, ifa->ifa_addr);
		if (error == 0)
			leinit(sc);
		break;
#endif /* CCITT && LLC */
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: am7990.c,v 1.4 1996/04/18 23:47:17 niklas Exp $	*/
/*	$NetBSD: am7990.c,v 1.16 1996/04/09 15:21:59 pk Exp $	*/
d294 1
d1019 2
a1020 2
integrate void
copytobuf_contig(sc, from, boff, len)
d1033 2
a1034 2
integrate void
copyfrombuf_contig(sc, to, boff, len)
d1047 2
a1048 2
integrate void
zerobuf_contig(sc, boff, len)
d1069 2
a1070 2
integrate void
copytobuf_gap2(sc, fromv, boff, len)
d1098 2
a1099 2
integrate void
copyfrombuf_gap2(sc, tov, boff, len)
d1128 2
a1129 2
integrate void
zerobuf_gap2(sc, boff, len)
d1158 2
a1159 2
integrate void
copytobuf_gap16(sc, fromv, boff, len)
d1183 2
a1184 2
integrate void
copyfrombuf_gap16(sc, tov, boff, len)
d1207 2
a1208 2
integrate void
zerobuf_gap16(sc, boff, len)
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: am7990.c,v 1.11 1996/03/14 19:05:07 christos Exp $	*/
d77 4
d130 2
a131 2
	printf(": address %s\n%s: %d receive buffers, %d transmit buffers\n",
	    ether_sprintf(sc->sc_arpcom.ac_enaddr),
d427 1
a427 2
		    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
			    sizeof(eh->ether_dhost)) != 0) {
d436 9
a444 4
	if (bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
		    sizeof(eh->ether_dhost)) != 0 &&
	    bcmp(eh->ether_dhost, etherbroadcastaddr,
		    sizeof(eh->ether_dhost)) != 0) {
d494 1
a494 1
		} else if (rmd.rmd1_bits & (LE_R1_STP | LE_R1_ENP) !=
d514 6
a519 2
			printf("sc->sc_last_rd = %x, rmd = %x\n",
			    sc->sc_last_rd, rmd);
d544 5
a548 1
			printf("trans tmd = %x\n", tmd);
d896 2
a897 1
		printf("%s: dst %s", ether_sprintf(eh.ether_dhost));
d899 1
a899 1
		    ntohs(eh.ether_type));
d922 2
a923 1
		printf("%s: dst %s", ether_sprintf(eh.ether_dhost));
d959 1
a959 2
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    sizeof(enm->enm_addrlo)) != 0) {
a1077 1
	register int xfer;
a1106 1
	register int xfer;
@


1.3
log
@from netbsd: LEINTR_UNIT goes away
@
text
@d1 2
a2 1
/*	$NetBSD: am7990.c,v 1.10 1996/01/02 21:51:56 thorpej Exp $	*/
d60 3
a62 1
extern llc_ctlinput(), cons_rtrequest();
d796 1
a796 1
		ifa->ifa_rtrequest = (void (*)())cons_rtrequest; /* XXX */
@


1.2
log
@from netbsd; mi lance driver
@
text
@d1 1
a1 1
/*	$NetBSD: am7990.c,v 1.8 1995/12/11 19:48:53 mycroft Exp $	*/
a584 7
#ifdef LEINTR_UNIT
int
leintr(unit)
	int unit;
{
	register struct le_softc *sc = LE_SOFTC(unit);
#else
a589 1
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: am7990.c,v 1.3 1995/07/24 04:34:51 mycroft Exp $	*/
d72 2
a77 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d90 3
d123 1
a123 1
	printf(": address %s, %d receive buffers, %d transmit buffers\n",
d125 1
a125 1
	    sc->sc_nrbuf, sc->sc_ntbuf);
d157 1
a157 1
	short unit;
d162 1
a162 1
	++sc->sc_arpcom.ac_if.if_oerrors;
a173 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a251 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d338 1
a338 1
	m->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
a378 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d384 1
d387 1
d412 1
d425 11
d464 1
d473 1
d482 1
d487 1
a517 1
	register struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d614 1
d616 2
a617 1
			sc->sc_arpcom.ac_if.if_oerrors++;
d622 1
a622 1
			sc->sc_arpcom.ac_if.if_collisions++;
d625 6
a630 2
		if (isr & LE_C0_MISS)
			sc->sc_arpcom.ac_if.if_ierrors++;
d640 1
a640 1
		sc->sc_arpcom.ac_if.if_ierrors++;
d646 1
a646 1
		sc->sc_arpcom.ac_if.if_oerrors++;
d659 2
a988 1
#if 0	/* USE OF THE FOLLOWING IS MACHINE-SPECIFIC */
d990 7
a996 8
 * Routines for accessing the transmit and receive buffers. Unfortunately,
 * CPU addressing of these buffers is done in one of 3 ways:
 * - contiguous (for the 3max and turbochannel option card)
 * - gap2, which means shorts (2 bytes) interspersed with short (2 byte)
 *   spaces (for the pmax)
 * - gap16, which means 16bytes interspersed with 16byte spaces
 *   for buffers which must begin on a 32byte boundary (for 3min and maxine)
 * The buffer offset is the logical byte offset, assuming contiguous storage.
a997 7
void
copytodesc_contig(sc, from, boff, len)
	struct le_softc *sc;
	caddr_t from;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
d999 6
a1004 5
	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(from, buf + boff, len);
}
d1006 1
a1006 15
void
copyfromdesc_contig(sc, to, boff, len)
	struct le_softc *sc;
	caddr_t to;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(buf + boff, to, len);
}

void
d1009 1
a1009 1
	caddr_t from;
d1020 1
a1020 1
void
d1023 1
a1023 1
	caddr_t to;
d1034 1
a1034 1
void
d1046 1
d1048 1
d1050 4
a1053 3
 * For the pmax the buffer consists of shorts (2 bytes) interspersed with
 * short (2 byte) spaces and must be accessed with halfword load/stores.
 * (don't worry about doing an extra byte)
d1055 3
a1057 2
void
copytobuf_gap2(sc, from, boff, len)
d1059 1
a1059 1
	register caddr_t from;
d1064 2
a1065 1
	register volatile u_short *bptr;
d1070 1
a1070 1
		bptr = ((volatile u_short *)buf) + (boff - 1);
d1075 6
a1080 15
		bptr = ((volatile u_short *)buf) + boff;
	if ((unsigned)from & 0x1) {
		while (len > 1) {
			*bptr = (from[1] << 8) | (from[0] & 0xff);
			bptr += 2;
			from += 2;
			len -= 2;
		}
	} else {
		/* optimize for aligned transfers */
		xfer = (int)((unsigned)len & ~0x1);
		CopyToBuffer((u_short *)from, bptr, xfer);
		bptr += xfer;
		from += xfer;
		len -= xfer;
d1083 1
a1083 1
		*bptr = (u_short)*from;
d1086 2
a1087 2
void
copyfrombuf_gap2(sc, to, boff, len)
d1089 1
a1089 1
	register caddr_t to;
d1093 3
a1095 2
	register volatile u_short *bptr;
	register u_short tmp;
d1100 1
a1100 1
		bptr = ((volatile u_short *)buf) + (boff - 1);
d1105 7
a1111 16
		bptr = ((volatile u_short *)buf) + boff;
	if ((unsigned)to & 0x1) {
		while (len > 1) {
			tmp = *bptr;
			*to++ = tmp & 0xff;
			*to++ = (tmp >> 8) & 0xff;
			bptr += 2;
			len -= 2;
		}
	} else {
		/* optimize for aligned transfers */
		xfer = (int)((unsigned)len & ~0x1);
		CopyFromBuffer(bptr, to, xfer);
		bptr += xfer;
		to += xfer;
		len -= xfer;
d1117 1
a1117 1
void
d1123 1
a1123 1
	register volatile u_short *bptr;
d1126 1
a1126 1
		bptr = ((volatile u_short *)buf) + (boff - 1);
d1131 1
a1131 1
		bptr = ((volatile u_short *)buf) + boff;
d1138 1
d1140 1
d1142 3
a1144 2
 * For the 3min and maxine, the buffers are in main memory filled in with
 * 16byte blocks interspersed with 16byte spaces.
d1146 3
a1148 2
void
copytobuf_gap16(sc, from, boff, len)
d1150 1
a1150 1
	register caddr_t from;
d1155 1
d1172 2
a1173 2
void
copyfrombuf_gap16(sc, to, boff, len)
d1175 1
a1175 1
	register caddr_t to;
d1179 1
d1196 1
a1196 1
void
d1216 1
a1216 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

