head	1.152;
access;
symbols
	OPENBSD_6_1_BASE:1.152
	OPENBSD_6_0:1.151.0.4
	OPENBSD_6_0_BASE:1.151
	OPENBSD_5_9:1.149.0.2
	OPENBSD_5_9_BASE:1.149
	OPENBSD_5_8:1.141.0.4
	OPENBSD_5_8_BASE:1.141
	OPENBSD_5_7:1.137.0.2
	OPENBSD_5_7_BASE:1.137
	OPENBSD_5_6:1.134.0.4
	OPENBSD_5_6_BASE:1.134
	OPENBSD_5_5:1.131.0.4
	OPENBSD_5_5_BASE:1.131
	OPENBSD_5_4:1.125.0.4
	OPENBSD_5_4_BASE:1.125
	OPENBSD_5_3:1.125.0.2
	OPENBSD_5_3_BASE:1.125
	OPENBSD_5_2:1.124.0.4
	OPENBSD_5_2_BASE:1.124
	OPENBSD_5_1_BASE:1.124
	OPENBSD_5_1:1.124.0.6
	OPENBSD_5_0:1.124.0.2
	OPENBSD_5_0_BASE:1.124
	OPENBSD_4_9:1.121.0.2
	OPENBSD_4_9_BASE:1.121
	OPENBSD_4_8:1.116.0.2
	OPENBSD_4_8_BASE:1.116
	OPENBSD_4_7:1.113.0.2
	OPENBSD_4_7_BASE:1.113
	OPENBSD_4_6:1.111.0.4
	OPENBSD_4_6_BASE:1.111
	OPENBSD_4_5:1.108.0.2
	OPENBSD_4_5_BASE:1.108
	OPENBSD_4_4:1.99.0.4
	OPENBSD_4_4_BASE:1.99
	OPENBSD_4_3:1.99.0.2
	OPENBSD_4_3_BASE:1.99
	OPENBSD_4_2:1.97.0.2
	OPENBSD_4_2_BASE:1.97
	OPENBSD_4_1:1.96.0.4
	OPENBSD_4_1_BASE:1.96
	OPENBSD_4_0:1.96.0.2
	OPENBSD_4_0_BASE:1.96
	OPENBSD_3_9:1.91.0.2
	OPENBSD_3_9_BASE:1.91
	OPENBSD_3_8:1.88.0.2
	OPENBSD_3_8_BASE:1.88
	OPENBSD_3_7:1.80.0.2
	OPENBSD_3_7_BASE:1.80
	OPENBSD_3_6:1.67.0.2
	OPENBSD_3_6_BASE:1.67
	SMP_SYNC_A:1.67
	SMP_SYNC_B:1.67
	OPENBSD_3_5:1.65.0.2
	OPENBSD_3_5_BASE:1.65
	OPENBSD_3_4:1.62.0.2
	OPENBSD_3_4_BASE:1.62
	UBC_SYNC_A:1.59
	OPENBSD_3_3:1.55.0.2
	OPENBSD_3_3_BASE:1.55
	OPENBSD_3_2:1.51.0.2
	OPENBSD_3_2_BASE:1.51
	OPENBSD_3_1:1.47.0.2
	OPENBSD_3_1_BASE:1.47
	UBC_SYNC_B:1.53
	UBC:1.44.0.2
	UBC_BASE:1.44
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	SMP:1.27.0.4
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.152
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.151;
commitid	VyLWTsbepAOk7VQM;

1.151
date	2016.05.04.18.38.57;	author kettenis;	state Exp;
branches;
next	1.150;
commitid	tipE4BwMBpEqOXaB;

1.150
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.149;
commitid	QHiEhS9DHyE6oiIr;

1.149
date	2015.11.28.22.57.43;	author dlg;	state Exp;
branches;
next	1.148;
commitid	QpgyUK95kRmPSRqj;

1.148
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.147;
commitid	B0kwmVGiD5DVx4kv;

1.147
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.146;
commitid	5DvsamK0GblTp8ww;

1.146
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.145;
commitid	eYnPulzvLjDImPCa;

1.145
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.144;
commitid	p0v5tuE1Ch6fY0Nj;

1.144
date	2015.09.12.09.56.36;	author miod;	state Exp;
branches;
next	1.143;
commitid	T0uA02ZBU2EazyUh;

1.143
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.142;
commitid	6vhYvh5CxZAHMnsN;

1.142
date	2015.08.30.02.12.23;	author deraadt;	state Exp;
branches;
next	1.141;
commitid	8ejCDnVRQj6IRdEv;

1.141
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.140;
commitid	MVWrtktB46JRxFWT;

1.140
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.139;
commitid	aiRvgNOa4qke9vft;

1.139
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.138;
commitid	p4LJxGKbi0BU2cG6;

1.138
date	2015.03.13.15.57.43;	author jasper;	state Exp;
branches;
next	1.137;
commitid	7ShhDNmcdmqbSLFX;

1.137
date	2015.01.23.12.49.13;	author dlg;	state Exp;
branches;
next	1.136;
commitid	6S434ANHnnjAlwPp;

1.136
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.135;
commitid	yM2VFFhpDTeFQlve;

1.135
date	2014.11.18.22.53.56;	author brad;	state Exp;
branches;
next	1.134;
commitid	Bt0DCMuB03ZvHc0Y;

1.134
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.133;
commitid	TGHgrLxu6sxZoiFt;

1.133
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.132;
commitid	I19imNlAX05zJOED;

1.132
date	2014.04.18.14.56.59;	author henning;	state Exp;
branches;
next	1.131;

1.131
date	2013.12.28.03.34.59;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2013.12.02.23.40.41;	author brad;	state Exp;
branches;
next	1.128;

1.128
date	2013.11.20.08.36.36;	author mpi;	state Exp;
branches;
next	1.127;

1.127
date	2013.08.21.05.21.43;	author dlg;	state Exp;
branches;
next	1.126;

1.126
date	2013.08.07.01.06.29;	author bluhm;	state Exp;
branches;
next	1.125;

1.125
date	2012.11.29.21.10.31;	author brad;	state Exp;
branches;
next	1.124;

1.124
date	2011.07.07.20.42.56;	author henning;	state Exp;
branches;
next	1.123;

1.123
date	2011.06.21.16.52.45;	author tedu;	state Exp;
branches;
next	1.122;

1.122
date	2011.03.05.13.39.26;	author kettenis;	state Exp;
branches;
next	1.121;

1.121
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2010.09.06.15.59.03;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2010.08.31.17.13.46;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2010.08.30.23.25.15;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2010.08.27.19.54.02;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2010.08.05.07.57.04;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2010.07.02.15.47.54;	author blambert;	state Exp;
branches;
next	1.114;

1.114
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.113;

1.113
date	2009.10.15.17.54.54;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2009.06.26.19.11.17;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2009.06.26.16.58.46;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2009.06.02.15.39.35;	author jsg;	state Exp;
branches;
next	1.108;

1.108
date	2009.01.11.16.54.59;	author blambert;	state Exp;
branches;
next	1.107;

1.107
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.106;

1.106
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.105;

1.105
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.104;

1.104
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.103;

1.103
date	2008.09.12.05.44.52;	author brad;	state Exp;
branches;
next	1.102;

1.102
date	2008.09.11.06.49.14;	author brad;	state Exp;
branches;
next	1.101;

1.101
date	2008.09.11.03.21.03;	author brad;	state Exp;
branches;
next	1.100;

1.100
date	2008.09.03.19.29.48;	author brad;	state Exp;
branches;
next	1.99;

1.99
date	2007.11.26.17.45.14;	author brad;	state Exp;
branches;
next	1.98;

1.98
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2007.05.08.00.04.47;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2006.08.10.20.52.54;	author brad;	state Exp;
branches;
next	1.95;

1.95
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2006.05.07.03.56.25;	author brad;	state Exp;
branches;
next	1.93;

1.93
date	2006.04.23.19.44.31;	author kettenis;	state Exp;
branches;
next	1.92;

1.92
date	2006.03.25.22.41.42;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2006.01.28.10.08.38;	author brad;	state Exp;
branches;
next	1.90;

1.90
date	2006.01.28.01.48.21;	author brad;	state Exp;
branches;
next	1.89;

1.89
date	2005.11.07.03.20.00;	author brad;	state Exp;
branches;
next	1.88;

1.88
date	2005.06.25.23.27.43;	author brad;	state Exp;
branches;
next	1.87;

1.87
date	2005.06.23.15.41.01;	author brad;	state Exp;
branches;
next	1.86;

1.86
date	2005.05.22.19.29.55;	author martin;	state Exp;
branches;
next	1.85;

1.85
date	2005.05.22.01.10.23;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2005.04.30.21.38.05;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2005.04.23.22.36.42;	author brad;	state Exp;
branches;
next	1.82;

1.82
date	2005.04.23.04.55.44;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2005.03.31.15.38.15;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2005.01.14.15.04.51;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2005.01.08.06.02.59;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2004.12.17.02.26.27;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2004.12.02.02.28.35;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2004.11.28.02.10.59;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2004.11.16.14.26.21;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2004.10.29.01.10.43;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2004.10.14.15.34.28;	author brad;	state Exp;
branches;
next	1.71;

1.71
date	2004.10.06.17.02.47;	author brad;	state Exp;
branches;
next	1.70;

1.70
date	2004.10.06.17.00.03;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2004.09.28.16.58.56;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.67;

1.67
date	2004.05.31.03.53.53;	author mcbride;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.15.08.34.48;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.29.18.53.58;	author mickey;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.25.21.45.11;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2003.08.28.12.32.07;	author mickey;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.16.03.26.00;	author mickey;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.20.18.48.43;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.17.01.55.28;	author jason;	state Exp;
branches;
next	1.58;

1.58
date	2003.04.29.21.44.06;	author jason;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.29.21.39.34;	author jason;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.29.15.19.12;	author jason;	state Exp;
branches;
next	1.55;

1.55
date	2003.02.25.17.29.09;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.31.14.22.38;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2002.10.21.20.30.32;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2002.10.20.16.46.27;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.05.13.45.21;	author aaron;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.09.00.07.10;	author nordin;	state Exp;
branches;
next	1.48;

1.48
date	2002.04.18.19.11.18;	author jason;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.17.07.38.06;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.13.17.43.02;	author nate;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2001.12.08.04.44.37;	author jason;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.08.04.39.09;	author jason;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.06.22.19.35;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2001.12.06.21.22.07;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.06.20.12.00;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.06.17.32.59;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.06.16.51.30;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2001.12.06.06.25.17;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.06.05.42.12;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.22.16.38.38;	author aaron;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.12.20.12.12;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.03.23.24.56;	author chris;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.02.01.28.20;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.27.06.34.40;	author kjc;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.23.23.17.35;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.13.15.56.10;	author aaron;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2001.04.13.15.55.16;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.06.17.14.13;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.20.19.39.38;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.09.05.14.08;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.09.03.45.53;	author aaron;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.09.02.23.34;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.16.06.08.31;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.30.18.20.14;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.26.20.50.43;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.18.16.19.34;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.17.16.08.52;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.16.17.08.07;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.11.17.01.24;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.28.18.32.59;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.13.00.29.34;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.07.20.26.15;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.26.12.53.57;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.08.16.43.50;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.02.19.01.06;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.02.17.40.58;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.02.08.40.54;	author peter;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.21.15.52.10;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.12.16.49.24;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.12.16.46.53;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.12.15.17.13;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.18.19.35.30;	author jason;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.08.03.04.33.40;	author jason;	state Exp;
branches;
next	;

1.27.4.1
date	2001.05.14.22.23.40;	author niklas;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2001.07.04.10.40.48;	author niklas;	state Exp;
branches;
next	1.27.4.3;

1.27.4.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.27.4.4;

1.27.4.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.27.4.5;

1.27.4.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.27.4.6;

1.27.4.6
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.27.4.7;

1.27.4.7
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.27.4.8;

1.27.4.8
date	2003.05.13.19.35.00;	author ho;	state Exp;
branches;
next	1.27.4.9;

1.27.4.9
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.27.4.10;

1.27.4.10
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	1.27.4.11;

1.27.4.11
date	2004.06.05.23.12.41;	author niklas;	state Exp;
branches;
next	;

1.44.2.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.152
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: dc.c,v 1.151 2016/05/04 18:38:57 kettenis Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_dc.c,v 1.43 2001/01/19 23:55:07 wpaul Exp $
 */

/*
 * DEC "tulip" clone ethernet driver. Supports the DEC/Intel 21143
 * series chips and several workalikes including the following:
 *
 * Macronix 98713/98715/98725/98727/98732 PMAC (www.macronix.com)
 * Macronix/Lite-On 82c115 PNIC II (www.macronix.com)
 * Lite-On 82c168/82c169 PNIC (www.litecom.com)
 * ASIX Electronics AX88140A (www.asix.com.tw)
 * ASIX Electronics AX88141 (www.asix.com.tw)
 * ADMtek AL981 (www.admtek.com.tw)
 * ADMtek AN983 (www.admtek.com.tw)
 * Davicom DM9100, DM9102, DM9102A (www.davicom8.com)
 * Accton EN1217, EN2242 (www.accton.com)
 * Xircom X3201 (www.xircom.com)
 *
 * Datasheets for the 21143 are available at developer.intel.com.
 * Datasheets for the clone parts can be found at their respective sites.
 * (Except for the PNIC; see www.freebsd.org/~wpaul/PNIC/pnic.ps.gz.)
 * The PNIC II is essentially a Macronix 98715A chip; the only difference
 * worth noting is that its multicast hash table is only 128 bits wide
 * instead of 512.
 *
 * Written by Bill Paul <wpaul@@ee.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The Intel 21143 is the successor to the DEC 21140. It is basically
 * the same as the 21140 but with a few new features. The 21143 supports
 * three kinds of media attachments:
 *
 * o MII port, for 10Mbps and 100Mbps support and NWAY
 *   autonegotiation provided by an external PHY.
 * o SYM port, for symbol mode 100Mbps support.
 * o 10baseT port.
 * o AUI/BNC port.
 *
 * The 100Mbps SYM port and 10baseT port can be used together in
 * combination with the internal NWAY support to create a 10/100
 * autosensing configuration.
 *
 * Note that not all tulip workalikes are handled in this driver: we only
 * deal with those which are relatively well behaved. The Winbond is
 * handled separately due to its different register offsets and the
 * special handling needed for its various bugs. The PNIC is handled
 * here, but I'm not thrilled about it.
 *
 * All of the workalike chips use some form of MII transceiver support
 * with the exception of the Macronix chips, which also have a SYM port.
 * The ASIX AX88140A is also documented to have a SYM port, but all
 * the cards I've seen use an MII transceiver, probably because the
 * AX88140A doesn't support internal NWAY.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <machine/bus.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/dcreg.h>

/*
 * The Davicom DM9102 has a broken DMA engine that reads beyond the
 * end of the programmed transfer.  Architectures with a proper IOMMU
 * (such as sparc64) will trap on this access.  To avoid having to
 * copy each transmitted mbuf to guarantee enough trailing space,
 * those architectures should implement BUS_DMA_OVERRUN that takes
 * appropriate action to tolerate this behaviour.
 */
#ifndef BUS_DMA_OVERRUN
#define BUS_DMA_OVERRUN 0
#endif

int dc_intr(void *);
struct dc_type *dc_devtype(void *);
int dc_newbuf(struct dc_softc *, int, struct mbuf *);
int dc_encap(struct dc_softc *, bus_dmamap_t, struct mbuf *, u_int32_t *);

void dc_pnic_rx_bug_war(struct dc_softc *, int);
int dc_rx_resync(struct dc_softc *);
int dc_rxeof(struct dc_softc *);
void dc_txeof(struct dc_softc *);
void dc_tick(void *);
void dc_tx_underrun(struct dc_softc *);
void dc_start(struct ifnet *);
int dc_ioctl(struct ifnet *, u_long, caddr_t);
void dc_watchdog(struct ifnet *);
int dc_ifmedia_upd(struct ifnet *);
void dc_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void dc_delay(struct dc_softc *);
void dc_eeprom_width(struct dc_softc *);
void dc_eeprom_idle(struct dc_softc *);
void dc_eeprom_putbyte(struct dc_softc *, int);
void dc_eeprom_getword(struct dc_softc *, int, u_int16_t *);
void dc_eeprom_getword_pnic(struct dc_softc *, int, u_int16_t *);
void dc_eeprom_getword_xircom(struct dc_softc *, int, u_int16_t *);
void dc_read_eeprom(struct dc_softc *, caddr_t, int, int, int);

void dc_mii_writebit(struct dc_softc *, int);
int dc_mii_readbit(struct dc_softc *);
void dc_mii_sync(struct dc_softc *);
void dc_mii_send(struct dc_softc *, u_int32_t, int);
int dc_mii_readreg(struct dc_softc *, struct dc_mii_frame *);
int dc_mii_writereg(struct dc_softc *, struct dc_mii_frame *);
int dc_miibus_readreg(struct device *, int, int);
void dc_miibus_writereg(struct device *, int, int, int);
void dc_miibus_statchg(struct device *);

void dc_setcfg(struct dc_softc *, uint64_t);
u_int32_t dc_crc_le(struct dc_softc *, caddr_t);
u_int32_t dc_crc_be(caddr_t);
void dc_setfilt_21143(struct dc_softc *);
void dc_setfilt_asix(struct dc_softc *);
void dc_setfilt_admtek(struct dc_softc *);
void dc_setfilt_xircom(struct dc_softc *);

void dc_setfilt(struct dc_softc *);

void dc_reset(struct dc_softc *);
int dc_list_rx_init(struct dc_softc *);
int dc_list_tx_init(struct dc_softc *);

void dc_read_srom(struct dc_softc *, int);
void dc_parse_21143_srom(struct dc_softc *);
void dc_decode_leaf_sia(struct dc_softc *,
				     struct dc_eblock_sia *);
void dc_decode_leaf_mii(struct dc_softc *,
				     struct dc_eblock_mii *);
void dc_decode_leaf_sym(struct dc_softc *,
				     struct dc_eblock_sym *);
void dc_apply_fixup(struct dc_softc *, uint64_t);

#define DC_SETBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) | (x))

#define DC_CLRBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) & ~(x))

#define SIO_SET(x)	DC_SETBIT(sc, DC_SIO, (x))
#define SIO_CLR(x)	DC_CLRBIT(sc, DC_SIO, (x))

void
dc_delay(struct dc_softc *sc)
{
	int idx;

	for (idx = (300 / 33) + 1; idx > 0; idx--)
		CSR_READ_4(sc, DC_BUSCTL);
}

void
dc_eeprom_width(struct dc_softc *sc)
{
	int i;

	/* Force EEPROM to idle state. */
	dc_eeprom_idle(sc);

	/* Enter EEPROM access mode. */
	CSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);
	dc_delay(sc);
	DC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);
	dc_delay(sc);
	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
	dc_delay(sc);
	DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);
	dc_delay(sc);

	for (i = 3; i--;) {
		if (6 & (1 << i))
			DC_SETBIT(sc, DC_SIO, DC_SIO_EE_DATAIN);
		else
			DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_DATAIN);
		dc_delay(sc);
		DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);
		dc_delay(sc);
		DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
		dc_delay(sc);
	}

	for (i = 1; i <= 12; i++) {
		DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);
		dc_delay(sc);
		if (!(CSR_READ_4(sc, DC_SIO) & DC_SIO_EE_DATAOUT)) {
			DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
			dc_delay(sc);
			break;
		}
		DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
		dc_delay(sc);
	}

	/* Turn off EEPROM access mode. */
	dc_eeprom_idle(sc);

	if (i < 4 || i > 12)
		sc->dc_romwidth = 6;
	else
		sc->dc_romwidth = i;

	/* Enter EEPROM access mode. */
	CSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);
	dc_delay(sc);
	DC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);
	dc_delay(sc);
	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
	dc_delay(sc);
	DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);
	dc_delay(sc);

	/* Turn off EEPROM access mode. */
	dc_eeprom_idle(sc);
}

void
dc_eeprom_idle(struct dc_softc *sc)
{
	int i;

	CSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);
	dc_delay(sc);
	DC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);
	dc_delay(sc);
	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
	dc_delay(sc);
	DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);
	dc_delay(sc);

	for (i = 0; i < 25; i++) {
		DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
		dc_delay(sc);
		DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);
		dc_delay(sc);
	}

	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
	dc_delay(sc);
	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CS);
	dc_delay(sc);
	CSR_WRITE_4(sc, DC_SIO, 0x00000000);
}

/*
 * Send a read command and address to the EEPROM, check for ACK.
 */
void
dc_eeprom_putbyte(struct dc_softc *sc, int addr)
{
	int d, i;

	d = DC_EECMD_READ >> 6;

	for (i = 3; i--; ) {
		if (d & (1 << i))
			DC_SETBIT(sc, DC_SIO, DC_SIO_EE_DATAIN);
		else
			DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_DATAIN);
		dc_delay(sc);
		DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);
		dc_delay(sc);
		DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
		dc_delay(sc);
	}

	/*
	 * Feed in each bit and strobe the clock.
	 */
	for (i = sc->dc_romwidth; i--;) {
		if (addr & (1 << i)) {
			SIO_SET(DC_SIO_EE_DATAIN);
		} else {
			SIO_CLR(DC_SIO_EE_DATAIN);
		}
		dc_delay(sc);
		SIO_SET(DC_SIO_EE_CLK);
		dc_delay(sc);
		SIO_CLR(DC_SIO_EE_CLK);
		dc_delay(sc);
	}
}

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 * The PNIC 82c168/82c169 has its own non-standard way to read
 * the EEPROM.
 */
void
dc_eeprom_getword_pnic(struct dc_softc *sc, int addr, u_int16_t *dest)
{
	int i;
	u_int32_t r;

	CSR_WRITE_4(sc, DC_PN_SIOCTL, DC_PN_EEOPCODE_READ|addr);

	for (i = 0; i < DC_TIMEOUT; i++) {
		DELAY(1);
		r = CSR_READ_4(sc, DC_SIO);
		if (!(r & DC_PN_SIOCTL_BUSY)) {
			*dest = (u_int16_t)(r & 0xFFFF);
			return;
		}
	}
}

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 * The Xircom X3201 has its own non-standard way to read
 * the EEPROM, too.
 */
void
dc_eeprom_getword_xircom(struct dc_softc *sc, int addr, u_int16_t *dest)
{
	SIO_SET(DC_SIO_ROMSEL | DC_SIO_ROMCTL_READ);

	addr *= 2;
	CSR_WRITE_4(sc, DC_ROM, addr | 0x160);
	*dest = (u_int16_t)CSR_READ_4(sc, DC_SIO) & 0xff;
	addr += 1;
	CSR_WRITE_4(sc, DC_ROM, addr | 0x160);
	*dest |= ((u_int16_t)CSR_READ_4(sc, DC_SIO) & 0xff) << 8;

	SIO_CLR(DC_SIO_ROMSEL | DC_SIO_ROMCTL_READ);
}

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 */
void
dc_eeprom_getword(struct dc_softc *sc, int addr, u_int16_t *dest)
{
	int i;
	u_int16_t word = 0;

	/* Force EEPROM to idle state. */
	dc_eeprom_idle(sc);

	/* Enter EEPROM access mode. */
	CSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);
	dc_delay(sc);
	DC_SETBIT(sc, DC_SIO,  DC_SIO_ROMCTL_READ);
	dc_delay(sc);
	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);
	dc_delay(sc);
	DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);
	dc_delay(sc);

	/*
	 * Send address of word we want to read.
	 */
	dc_eeprom_putbyte(sc, addr);

	/*
	 * Start reading bits from EEPROM.
	 */
	for (i = 0x8000; i; i >>= 1) {
		SIO_SET(DC_SIO_EE_CLK);
		dc_delay(sc);
		if (CSR_READ_4(sc, DC_SIO) & DC_SIO_EE_DATAOUT)
			word |= i;
		dc_delay(sc);
		SIO_CLR(DC_SIO_EE_CLK);
		dc_delay(sc);
	}

	/* Turn off EEPROM access mode. */
	dc_eeprom_idle(sc);

	*dest = word;
}

/*
 * Read a sequence of words from the EEPROM.
 */
void
dc_read_eeprom(struct dc_softc *sc, caddr_t dest, int off, int cnt,
    int swap)
{
	int i;
	u_int16_t word = 0, *ptr;

	for (i = 0; i < cnt; i++) {
		if (DC_IS_PNIC(sc))
			dc_eeprom_getword_pnic(sc, off + i, &word);
		else if (DC_IS_XIRCOM(sc))
			dc_eeprom_getword_xircom(sc, off + i, &word);
		else
			dc_eeprom_getword(sc, off + i, &word);
		ptr = (u_int16_t *)(dest + (i * 2));
		if (swap)
			*ptr = betoh16(word);
		else
			*ptr = letoh16(word);
	}
}

/*
 * The following two routines are taken from the Macronix 98713
 * Application Notes pp.19-21.
 */
/*
 * Write a bit to the MII bus.
 */
void
dc_mii_writebit(struct dc_softc *sc, int bit)
{
	if (bit)
		CSR_WRITE_4(sc, DC_SIO,
		    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);
	else
		CSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);

	DC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);
	DC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);
}

/*
 * Read a bit from the MII bus.
 */
int
dc_mii_readbit(struct dc_softc *sc)
{
	CSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_READ|DC_SIO_MII_DIR);
	CSR_READ_4(sc, DC_SIO);
	DC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);
	DC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);
	if (CSR_READ_4(sc, DC_SIO) & DC_SIO_MII_DATAIN)
		return (1);
	return (0);
}

/*
 * Sync the PHYs by setting data bit and strobing the clock 32 times.
 */
void
dc_mii_sync(struct dc_softc *sc)
{
	int i;

	CSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);

	for (i = 0; i < 32; i++)
		dc_mii_writebit(sc, 1);
}

/*
 * Clock a series of bits through the MII.
 */
void
dc_mii_send(struct dc_softc *sc, u_int32_t bits, int cnt)
{
	int i;

	for (i = (0x1 << (cnt - 1)); i; i >>= 1)
		dc_mii_writebit(sc, bits & i);
}

/*
 * Read an PHY register through the MII.
 */
int
dc_mii_readreg(struct dc_softc *sc, struct dc_mii_frame *frame)
{
	int i, ack, s;

	s = splnet();

	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = DC_MII_STARTDELIM;
	frame->mii_opcode = DC_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;
	
	/*
	 * Sync the PHYs.
	 */
	dc_mii_sync(sc);

	/*
	 * Send command/address info.
	 */
	dc_mii_send(sc, frame->mii_stdelim, 2);
	dc_mii_send(sc, frame->mii_opcode, 2);
	dc_mii_send(sc, frame->mii_phyaddr, 5);
	dc_mii_send(sc, frame->mii_regaddr, 5);

#ifdef notdef
	/* Idle bit */
	dc_mii_writebit(sc, 1);
	dc_mii_writebit(sc, 0);
#endif

	/* Check for ack */
	ack = dc_mii_readbit(sc);

	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHY(s) in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			dc_mii_readbit(sc);
		}
		goto fail;
	}

	for (i = 0x8000; i; i >>= 1) {
		if (!ack) {
			if (dc_mii_readbit(sc))
				frame->mii_data |= i;
		}
	}

fail:

	dc_mii_writebit(sc, 0);
	dc_mii_writebit(sc, 0);

	splx(s);

	if (ack)
		return (1);
	return (0);
}

/*
 * Write to a PHY register through the MII.
 */
int
dc_mii_writereg(struct dc_softc *sc, struct dc_mii_frame *frame)
{
	int s;

	s = splnet();
	/*
	 * Set up frame for TX.
	 */

	frame->mii_stdelim = DC_MII_STARTDELIM;
	frame->mii_opcode = DC_MII_WRITEOP;
	frame->mii_turnaround = DC_MII_TURNAROUND;

	/*
	 * Sync the PHYs.
	 */	
	dc_mii_sync(sc);

	dc_mii_send(sc, frame->mii_stdelim, 2);
	dc_mii_send(sc, frame->mii_opcode, 2);
	dc_mii_send(sc, frame->mii_phyaddr, 5);
	dc_mii_send(sc, frame->mii_regaddr, 5);
	dc_mii_send(sc, frame->mii_turnaround, 2);
	dc_mii_send(sc, frame->mii_data, 16);

	/* Idle bit. */
	dc_mii_writebit(sc, 0);
	dc_mii_writebit(sc, 0);

	splx(s);
	return (0);
}

int
dc_miibus_readreg(struct device *self, int phy, int reg)
{
	struct dc_mii_frame frame;
	struct dc_softc *sc = (struct dc_softc *)self;
	int i, rval, phy_reg;

	/*
	 * Note: both the AL981 and AN983 have internal PHYs,
	 * however the AL981 provides direct access to the PHY
	 * registers while the AN983 uses a serial MII interface.
	 * The AN983's MII interface is also buggy in that you
	 * can read from any MII address (0 to 31), but only address 1
	 * behaves normally. To deal with both cases, we pretend
	 * that the PHY is at MII address 1.
	 */
	if (DC_IS_ADMTEK(sc) && phy != DC_ADMTEK_PHYADDR)
		return (0);

	/*
	 * Note: the ukphy probs of the RS7112 report a PHY at
	 * MII address 0 (possibly HomePNA?) and 1 (ethernet)
	 * so we only respond to correct one.
	 */
	if (DC_IS_CONEXANT(sc) && phy != DC_CONEXANT_PHYADDR)
		return (0);

	if (sc->dc_pmode != DC_PMODE_MII) {
		if (phy == (MII_NPHY - 1)) {
			switch(reg) {
			case MII_BMSR:
				/*
				 * Fake something to make the probe
				 * code think there's a PHY here.
				 */
				return (BMSR_MEDIAMASK);
				break;
			case MII_PHYIDR1:
				if (DC_IS_PNIC(sc))
					return (PCI_VENDOR_LITEON);
				return (PCI_VENDOR_DEC);
				break;
			case MII_PHYIDR2:
				if (DC_IS_PNIC(sc))
					return (PCI_PRODUCT_LITEON_PNIC);
				return (PCI_PRODUCT_DEC_21142);
				break;
			default:
				return (0);
				break;
			}
		} else
			return (0);
	}

	if (DC_IS_PNIC(sc)) {
		CSR_WRITE_4(sc, DC_PN_MII, DC_PN_MIIOPCODE_READ |
		    (phy << 23) | (reg << 18));
		for (i = 0; i < DC_TIMEOUT; i++) {
			DELAY(1);
			rval = CSR_READ_4(sc, DC_PN_MII);
			if (!(rval & DC_PN_MII_BUSY)) {
				rval &= 0xFFFF;
				return (rval == 0xFFFF ? 0 : rval);
			}
		}
		return (0);
	}

	if (DC_IS_COMET(sc)) {
		switch(reg) {
		case MII_BMCR:
			phy_reg = DC_AL_BMCR;
			break;
		case MII_BMSR:
			phy_reg = DC_AL_BMSR;
			break;
		case MII_PHYIDR1:
			phy_reg = DC_AL_VENID;
			break;
		case MII_PHYIDR2:
			phy_reg = DC_AL_DEVID;
			break;
		case MII_ANAR:
			phy_reg = DC_AL_ANAR;
			break;
		case MII_ANLPAR:
			phy_reg = DC_AL_LPAR;
			break;
		case MII_ANER:
			phy_reg = DC_AL_ANER;
			break;
		default:
			printf("%s: phy_read: bad phy register %x\n",
			    sc->sc_dev.dv_xname, reg);
			return (0);
			break;
		}

		rval = CSR_READ_4(sc, phy_reg) & 0x0000FFFF;

		if (rval == 0xFFFF)
			return (0);
		return (rval);
	}

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	if (sc->dc_type == DC_TYPE_98713) {
		phy_reg = CSR_READ_4(sc, DC_NETCFG);
		CSR_WRITE_4(sc, DC_NETCFG, phy_reg & ~DC_NETCFG_PORTSEL);
	}
	dc_mii_readreg(sc, &frame);
	if (sc->dc_type == DC_TYPE_98713)
		CSR_WRITE_4(sc, DC_NETCFG, phy_reg);

	return (frame.mii_data);
}

void
dc_miibus_writereg(struct device *self, int phy, int reg, int data)
{
	struct dc_softc *sc = (struct dc_softc *)self;
	struct dc_mii_frame frame;
	int i, phy_reg;

	bzero(&frame, sizeof(frame));

	if (DC_IS_ADMTEK(sc) && phy != DC_ADMTEK_PHYADDR)
		return;
	if (DC_IS_CONEXANT(sc) && phy != DC_CONEXANT_PHYADDR)
		return;

	if (DC_IS_PNIC(sc)) {
		CSR_WRITE_4(sc, DC_PN_MII, DC_PN_MIIOPCODE_WRITE |
		    (phy << 23) | (reg << 10) | data);
		for (i = 0; i < DC_TIMEOUT; i++) {
			if (!(CSR_READ_4(sc, DC_PN_MII) & DC_PN_MII_BUSY))
				break;
		}
		return;
	}

	if (DC_IS_COMET(sc)) {
		switch(reg) {
		case MII_BMCR:
			phy_reg = DC_AL_BMCR;
			break;
		case MII_BMSR:
			phy_reg = DC_AL_BMSR;
			break;
		case MII_PHYIDR1:
			phy_reg = DC_AL_VENID;
			break;
		case MII_PHYIDR2:
			phy_reg = DC_AL_DEVID;
			break;
		case MII_ANAR:
			phy_reg = DC_AL_ANAR;
			break;
		case MII_ANLPAR:
			phy_reg = DC_AL_LPAR;
			break;
		case MII_ANER:
			phy_reg = DC_AL_ANER;
			break;
		default:
			printf("%s: phy_write: bad phy register %x\n",
			    sc->sc_dev.dv_xname, reg);
			return;
		}

		CSR_WRITE_4(sc, phy_reg, data);
		return;
	}

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	frame.mii_data = data;

	if (sc->dc_type == DC_TYPE_98713) {
		phy_reg = CSR_READ_4(sc, DC_NETCFG);
		CSR_WRITE_4(sc, DC_NETCFG, phy_reg & ~DC_NETCFG_PORTSEL);
	}
	dc_mii_writereg(sc, &frame);
	if (sc->dc_type == DC_TYPE_98713)
		CSR_WRITE_4(sc, DC_NETCFG, phy_reg);
}

void
dc_miibus_statchg(struct device *self)
{
	struct dc_softc *sc = (struct dc_softc *)self;
	struct mii_data *mii;
	struct ifmedia *ifm;

	if (DC_IS_ADMTEK(sc))
		return;

	mii = &sc->sc_mii;
	ifm = &mii->mii_media;
	if (DC_IS_DAVICOM(sc) && IFM_SUBTYPE(ifm->ifm_media) == IFM_HPNA_1) {
		dc_setcfg(sc, ifm->ifm_media);
		sc->dc_if_media = ifm->ifm_media;
	} else {
		dc_setcfg(sc, mii->mii_media_active);
		sc->dc_if_media = mii->mii_media_active;
	}
}

#define DC_BITS_512	9
#define DC_BITS_128	7
#define DC_BITS_64	6

u_int32_t
dc_crc_le(struct dc_softc *sc, caddr_t addr)
{
	u_int32_t crc;

	/* Compute CRC for the address value. */
	crc = ether_crc32_le(addr, ETHER_ADDR_LEN);

	/*
	 * The hash table on the PNIC II and the MX98715AEC-C/D/E
	 * chips is only 128 bits wide.
	 */
	if (sc->dc_flags & DC_128BIT_HASH)
		return (crc & ((1 << DC_BITS_128) - 1));

	/* The hash table on the MX98715BEC is only 64 bits wide. */
	if (sc->dc_flags & DC_64BIT_HASH)
		return (crc & ((1 << DC_BITS_64) - 1));

	/* Xircom's hash filtering table is different (read: weird) */
	/* Xircom uses the LEAST significant bits */
	if (DC_IS_XIRCOM(sc)) {
		if ((crc & 0x180) == 0x180)
			return (crc & 0x0F) + (crc	& 0x70)*3 + (14 << 4);
		else
			return (crc & 0x1F) + ((crc>>1) & 0xF0)*3 + (12 << 4);
	}

	return (crc & ((1 << DC_BITS_512) - 1));
}

/*
 * Calculate CRC of a multicast group address, return the lower 6 bits.
 */
#define dc_crc_be(addr)	((ether_crc32_be(addr,ETHER_ADDR_LEN) >> 26) \
	& 0x0000003F)

/*
 * 21143-style RX filter setup routine. Filter programming is done by
 * downloading a special setup frame into the TX engine. 21143, Macronix,
 * PNIC, PNIC II and Davicom chips are programmed this way.
 *
 * We always program the chip using 'hash perfect' mode, i.e. one perfect
 * address (our node address) and a 512-bit hash filter for multicast
 * frames. We also sneak the broadcast address into the hash filter since
 * we need that too.
 */
void
dc_setfilt_21143(struct dc_softc *sc)
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	struct dc_desc *sframe;
	u_int32_t h, *sp;
	int i;

	i = sc->dc_cdata.dc_tx_prod;
	DC_INC(sc->dc_cdata.dc_tx_prod, DC_TX_LIST_CNT);
	sc->dc_cdata.dc_tx_cnt++;
	sframe = &sc->dc_ldata->dc_tx_list[i];
	sp = &sc->dc_ldata->dc_sbuf[0];
	bzero(sp, DC_SFRAME_LEN);

	sframe->dc_data = htole32(sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_sbuf));
	sframe->dc_ctl = htole32(DC_SFRAME_LEN | DC_TXCTL_SETUP |
	    DC_TXCTL_TLINK | DC_FILTER_HASHPERF | DC_TXCTL_FINT);

	sc->dc_cdata.dc_tx_chain[i].sd_mbuf =
	    (struct mbuf *)&sc->dc_ldata->dc_sbuf[0];

	DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ALLMULTI | DC_NETCFG_RX_PROMISC));
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
		else
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);
	} else {
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = dc_crc_le(sc, enm->enm_addrlo);

			sp[h >> 4] |= htole32(1 << (h & 0xF));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	/*
	 * Always accept broadcast frames.
	 */
	h = dc_crc_le(sc, (caddr_t)&etherbroadcastaddr);
	sp[h >> 4] |= htole32(1 << (h & 0xF));

	/* Set our MAC address */
	sp[39] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 0);
	sp[40] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 1);
	sp[41] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 2);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_sbuf[0]),
	    sizeof(struct dc_list_data) - 
	    offsetof(struct dc_list_data, dc_sbuf[0]),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	sframe->dc_status = htole32(DC_TXSTAT_OWN);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_tx_list[i]),
	    sizeof(struct dc_desc), BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);

	/*
	 * The PNIC takes an exceedingly long time to process its
	 * setup frame; wait 10ms after posting the setup frame
	 * before proceeding, just so it has time to swallow its
	 * medicine.
	 */
	DELAY(10000);

	ifp->if_timer = 5;
}

void
dc_setfilt_admtek(struct dc_softc *sc)
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t hashes[2];
	int h = 0;

	DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ALLMULTI | DC_NETCFG_RX_PROMISC));
	bzero(hashes, sizeof(hashes));
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
		else
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);
	} else {
		/* now program new ones */
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			if (DC_IS_CENTAUR(sc))
				h = dc_crc_le(sc, enm->enm_addrlo);
			else
				h = dc_crc_be(enm->enm_addrlo);

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	/* Init our MAC address */
	CSR_WRITE_4(sc, DC_AL_PAR0, ac->ac_enaddr[3] << 24 |
	    ac->ac_enaddr[2] << 16 | ac->ac_enaddr[1] << 8 | ac->ac_enaddr[0]);
	CSR_WRITE_4(sc, DC_AL_PAR1, ac->ac_enaddr[5] << 8 | ac->ac_enaddr[4]);

	CSR_WRITE_4(sc, DC_AL_MAR0, hashes[0]);
	CSR_WRITE_4(sc, DC_AL_MAR1, hashes[1]);
}

void
dc_setfilt_asix(struct dc_softc *sc)
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t hashes[2];
	int h = 0;

	DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ALLMULTI | DC_AX_NETCFG_RX_BROAD |
	    DC_NETCFG_RX_PROMISC));
	bzero(hashes, sizeof(hashes));
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept broadcast frames.
	 */
	DC_SETBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
		else
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);
	} else {
		/* now program new ones */
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = dc_crc_be(enm->enm_addrlo);

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	/* Init our MAC address */
	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR0);
	CSR_WRITE_4(sc, DC_AX_FILTDATA,
	    *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[0]));
	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR1);
	CSR_WRITE_4(sc, DC_AX_FILTDATA,
	    *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[4]));

	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);
	CSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[0]);
	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);
	CSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[1]);
}

void
dc_setfilt_xircom(struct dc_softc *sc)
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	struct dc_desc *sframe;
	u_int32_t h, *sp;
	int i;

	DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));

	i = sc->dc_cdata.dc_tx_prod;
	DC_INC(sc->dc_cdata.dc_tx_prod, DC_TX_LIST_CNT);
	sc->dc_cdata.dc_tx_cnt++;
	sframe = &sc->dc_ldata->dc_tx_list[i];
	sp = &sc->dc_ldata->dc_sbuf[0];
	bzero(sp, DC_SFRAME_LEN);

	sframe->dc_data = htole32(sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_sbuf));
	sframe->dc_ctl = htole32(DC_SFRAME_LEN | DC_TXCTL_SETUP |
	    DC_TXCTL_TLINK | DC_FILTER_HASHPERF | DC_TXCTL_FINT);

	sc->dc_cdata.dc_tx_chain[i].sd_mbuf =
	    (struct mbuf *)&sc->dc_ldata->dc_sbuf[0];

	DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ALLMULTI | DC_NETCFG_RX_PROMISC));
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
		else
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);
	} else {
		/* now program new ones */
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = dc_crc_le(sc, enm->enm_addrlo);

			sp[h >> 4] |= htole32(1 << (h & 0xF));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	/*
	 * Always accept broadcast frames.
	 */
	h = dc_crc_le(sc, (caddr_t)&etherbroadcastaddr);
	sp[h >> 4] |= htole32(1 << (h & 0xF));

	/* Set our MAC address */
	sp[0] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 0);
	sp[1] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 1);
	sp[2] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 2);

	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);
	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);
	ifp->if_flags |= IFF_RUNNING;
	sframe->dc_status = htole32(DC_TXSTAT_OWN);
	CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);

	/*
	 * wait some time...
	 */
	DELAY(1000);

	ifp->if_timer = 5;
}

void
dc_setfilt(struct dc_softc *sc)
{
	if (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||
	    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc) || DC_IS_CONEXANT(sc))
		dc_setfilt_21143(sc);

	if (DC_IS_ASIX(sc))
		dc_setfilt_asix(sc);

	if (DC_IS_ADMTEK(sc))
		dc_setfilt_admtek(sc);

	if (DC_IS_XIRCOM(sc))
		dc_setfilt_xircom(sc);
}

/*
 * In order to fiddle with the
 * 'full-duplex' and '100Mbps' bits in the netconfig register, we
 * first have to put the transmit and/or receive logic in the idle state.
 */
void
dc_setcfg(struct dc_softc *sc, uint64_t media)
{
	int i, restart = 0;
	u_int32_t isr;

	if (IFM_SUBTYPE(media) == IFM_NONE)
		return;

	if (CSR_READ_4(sc, DC_NETCFG) & (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)) {
		restart = 1;
		DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));

		for (i = 0; i < DC_TIMEOUT; i++) {
			isr = CSR_READ_4(sc, DC_ISR);
			if (isr & DC_ISR_TX_IDLE &&
			    ((isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED ||
			    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_WAIT))
				break;
			DELAY(10);
		}

		if (i == DC_TIMEOUT) {
			if (!(isr & DC_ISR_TX_IDLE) && !DC_IS_ASIX(sc))
				printf("%s: failed to force tx to idle state\n",
				    sc->sc_dev.dv_xname);
			if (!((isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED ||
			    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_WAIT) &&
			    !DC_HAS_BROKEN_RXSTATE(sc))
				printf("%s: failed to force rx to idle state\n",
				    sc->sc_dev.dv_xname);
		}
	}

	if (IFM_SUBTYPE(media) == IFM_100_TX) {
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);
		if (sc->dc_pmode == DC_PMODE_MII) {
			int watchdogreg;

			if (DC_IS_INTEL(sc)) {
			/* there's a write enable bit here that reads as 1 */
				watchdogreg = CSR_READ_4(sc, DC_WATCHDOG);
				watchdogreg &= ~DC_WDOG_CTLWREN;
				watchdogreg |= DC_WDOG_JABBERDIS;
				CSR_WRITE_4(sc, DC_WATCHDOG, watchdogreg);
			} else {
				DC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);
			}
			DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|
			    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));
			if (sc->dc_type == DC_TYPE_98713)
				DC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|
				    DC_NETCFG_SCRAMBLER));
			if (!DC_IS_DAVICOM(sc))
				DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);
			DC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);
			if (DC_IS_INTEL(sc))
				dc_apply_fixup(sc, IFM_AUTO);
		} else {
			if (DC_IS_PNIC(sc)) {
				DC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);
				DC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);
				DC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);
			}
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);
			if (DC_IS_INTEL(sc))
				dc_apply_fixup(sc,
				    (media & IFM_GMASK) == IFM_FDX ?
				    IFM_100_TX|IFM_FDX : IFM_100_TX);
		}
	}

	if (IFM_SUBTYPE(media) == IFM_10_T) {
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);
		if (sc->dc_pmode == DC_PMODE_MII) {
			int watchdogreg;

			if (DC_IS_INTEL(sc)) {
			/* there's a write enable bit here that reads as 1 */
				watchdogreg = CSR_READ_4(sc, DC_WATCHDOG);
				watchdogreg &= ~DC_WDOG_CTLWREN;
				watchdogreg |= DC_WDOG_JABBERDIS;
				CSR_WRITE_4(sc, DC_WATCHDOG, watchdogreg);
			} else {
				DC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);
			}
			DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|
			    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));
			if (sc->dc_type == DC_TYPE_98713)
				DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);
			if (!DC_IS_DAVICOM(sc))
				DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);
			DC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);
			if (DC_IS_INTEL(sc))
				dc_apply_fixup(sc, IFM_AUTO);
		} else {
			if (DC_IS_PNIC(sc)) {
				DC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);
				DC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);
				DC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);
			}
			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);
			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PCS);
			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);
			if (DC_IS_INTEL(sc)) {
				DC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);
				DC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);
				if ((media & IFM_GMASK) == IFM_FDX)
					DC_SETBIT(sc, DC_10BTCTRL, 0x7F3D);
				else
					DC_SETBIT(sc, DC_10BTCTRL, 0x7F3F);
				DC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);
				DC_CLRBIT(sc, DC_10BTCTRL,
				    DC_TCTL_AUTONEGENBL);
				dc_apply_fixup(sc,
				    (media & IFM_GMASK) == IFM_FDX ?
				    IFM_10_T|IFM_FDX : IFM_10_T);
				DELAY(20000);
			}
		}
	}

	/*
	 * If this is a Davicom DM9102A card with a DM9801 HomePNA
	 * PHY and we want HomePNA mode, set the portsel bit to turn
	 * on the external MII port.
	 */
	if (DC_IS_DAVICOM(sc)) {
		if (IFM_SUBTYPE(media) == IFM_HPNA_1) {
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);
			sc->dc_link = 1;
		} else {
			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);
		}
	}

	if ((media & IFM_GMASK) == IFM_FDX) {
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);
		if (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))
			DC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);
	} else {
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);
		if (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))
			DC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);
	}

	if (restart)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON|DC_NETCFG_RX_ON);
}

void
dc_reset(struct dc_softc *sc)
{
	int i;

	DC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);

	for (i = 0; i < DC_TIMEOUT; i++) {
		DELAY(10);
		if (!(CSR_READ_4(sc, DC_BUSCTL) & DC_BUSCTL_RESET))
			break;
	}

	if (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc) || DC_IS_XIRCOM(sc) ||
	    DC_IS_INTEL(sc) || DC_IS_CONEXANT(sc)) {
		DELAY(10000);
		DC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);
		i = 0;
	}

	if (i == DC_TIMEOUT)
		printf("%s: reset never completed!\n", sc->sc_dev.dv_xname);

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);

	CSR_WRITE_4(sc, DC_IMR, 0x00000000);
	CSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);
	CSR_WRITE_4(sc, DC_NETCFG, 0x00000000);

	/*
	 * Bring the SIA out of reset. In some cases, it looks
	 * like failing to unreset the SIA soon enough gets it
	 * into a state where it will never come out of reset
	 * until we reset the whole chip again.
	 */
	if (DC_IS_INTEL(sc)) {
		DC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);
		CSR_WRITE_4(sc, DC_10BTCTRL, 0);
		CSR_WRITE_4(sc, DC_WATCHDOG, 0);
	}

	if (sc->dc_type == DC_TYPE_21145)
		dc_setcfg(sc, IFM_10_T);
}

void
dc_apply_fixup(struct dc_softc *sc, uint64_t media)
{
	struct dc_mediainfo *m;
	u_int8_t *p;
	int i;
	u_int32_t reg;

	m = sc->dc_mi;

	while (m != NULL) {
		if (m->dc_media == media)
			break;
		m = m->dc_next;
	}

	if (m == NULL)
		return;

	for (i = 0, p = m->dc_reset_ptr; i < m->dc_reset_len; i++, p += 2) {
		reg = (p[0] | (p[1] << 8)) << 16;
		CSR_WRITE_4(sc, DC_WATCHDOG, reg);
	}

	for (i = 0, p = m->dc_gp_ptr; i < m->dc_gp_len; i++, p += 2) {
		reg = (p[0] | (p[1] << 8)) << 16;
		CSR_WRITE_4(sc, DC_WATCHDOG, reg);
	}
}

void
dc_decode_leaf_sia(struct dc_softc *sc, struct dc_eblock_sia *l)
{
	struct dc_mediainfo *m;

	m = malloc(sizeof(*m), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (m == NULL)
		return;
	switch (l->dc_sia_code & ~DC_SIA_CODE_EXT) {
	case DC_SIA_CODE_10BT:
		m->dc_media = IFM_10_T;
		break;
	case DC_SIA_CODE_10BT_FDX:
		m->dc_media = IFM_10_T|IFM_FDX;
		break;
	case DC_SIA_CODE_10B2:
		m->dc_media = IFM_10_2;
		break;
	case DC_SIA_CODE_10B5:
		m->dc_media = IFM_10_5;
		break;
	default:
		break;
	}

	/*
	 * We need to ignore CSR13, CSR14, CSR15 for SIA mode.
	 * Things apparently already work for cards that do
	 * supply Media Specific Data.
	 */
	if (l->dc_sia_code & DC_SIA_CODE_EXT) {
		m->dc_gp_len = 2;
		m->dc_gp_ptr =
		(u_int8_t *)&l->dc_un.dc_sia_ext.dc_sia_gpio_ctl;
	} else {
		m->dc_gp_len = 2;
		m->dc_gp_ptr =
		(u_int8_t *)&l->dc_un.dc_sia_noext.dc_sia_gpio_ctl;
	}

	m->dc_next = sc->dc_mi;
	sc->dc_mi = m;

	sc->dc_pmode = DC_PMODE_SIA;
}

void
dc_decode_leaf_sym(struct dc_softc *sc, struct dc_eblock_sym *l)
{
	struct dc_mediainfo *m;

	m = malloc(sizeof(*m), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (m == NULL)
		return;
	if (l->dc_sym_code == DC_SYM_CODE_100BT)
		m->dc_media = IFM_100_TX;

	if (l->dc_sym_code == DC_SYM_CODE_100BT_FDX)
		m->dc_media = IFM_100_TX|IFM_FDX;

	m->dc_gp_len = 2;
	m->dc_gp_ptr = (u_int8_t *)&l->dc_sym_gpio_ctl;

	m->dc_next = sc->dc_mi;
	sc->dc_mi = m;

	sc->dc_pmode = DC_PMODE_SYM;
}

void
dc_decode_leaf_mii(struct dc_softc *sc, struct dc_eblock_mii *l)
{
	u_int8_t *p;
	struct dc_mediainfo *m;

	m = malloc(sizeof(*m), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (m == NULL)
		return;
	/* We abuse IFM_AUTO to represent MII. */
	m->dc_media = IFM_AUTO;
	m->dc_gp_len = l->dc_gpr_len;

	p = (u_int8_t *)l;
	p += sizeof(struct dc_eblock_mii);
	m->dc_gp_ptr = p;
	p += 2 * l->dc_gpr_len;
	m->dc_reset_len = *p;
	p++;
	m->dc_reset_ptr = p;

	m->dc_next = sc->dc_mi;
	sc->dc_mi = m;
}

void
dc_read_srom(struct dc_softc *sc, int bits)
{
	sc->dc_sromsize = 2 << bits;
	sc->dc_srom = malloc(sc->dc_sromsize, M_DEVBUF, M_NOWAIT);
	if (sc->dc_srom == NULL)
		return;
	dc_read_eeprom(sc, (caddr_t)sc->dc_srom, 0, (sc->dc_sromsize / 2), 0);
}

void
dc_parse_21143_srom(struct dc_softc *sc)
{
	struct dc_leaf_hdr *lhdr;
	struct dc_eblock_hdr *hdr;
	int have_mii, i, loff;
	char *ptr;

	have_mii = 0;
	loff = sc->dc_srom[27];
	lhdr = (struct dc_leaf_hdr *)&(sc->dc_srom[loff]);

	ptr = (char *)lhdr;
	ptr += sizeof(struct dc_leaf_hdr) - 1;
	/*
	 * Look if we got a MII media block.
	 */
	for (i = 0; i < lhdr->dc_mcnt; i++) {
		hdr = (struct dc_eblock_hdr *)ptr;
		if (hdr->dc_type == DC_EBLOCK_MII)
		    have_mii++;

		ptr += (hdr->dc_len & 0x7F);
		ptr++;
	}

	/*
	 * Do the same thing again. Only use SIA and SYM media
	 * blocks if no MII media block is available.
	 */
	ptr = (char *)lhdr;
	ptr += sizeof(struct dc_leaf_hdr) - 1;
	for (i = 0; i < lhdr->dc_mcnt; i++) {
		hdr = (struct dc_eblock_hdr *)ptr;
		switch(hdr->dc_type) {
		case DC_EBLOCK_MII:
			dc_decode_leaf_mii(sc, (struct dc_eblock_mii *)hdr);
			break;
		case DC_EBLOCK_SIA:
			if (! have_mii)
			    dc_decode_leaf_sia(sc,
				(struct dc_eblock_sia *)hdr);
			break;
		case DC_EBLOCK_SYM:
			if (! have_mii)
			    dc_decode_leaf_sym(sc,
				(struct dc_eblock_sym *)hdr);
			break;
		default:
			/* Don't care. Yet. */
			break;
		}
		ptr += (hdr->dc_len & 0x7F);
		ptr++;
	}
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
dc_attach(struct dc_softc *sc)
{
	struct ifnet *ifp;
	int mac_offset, tmp, i;
	u_int32_t reg;

	/*
	 * Get station address from the EEPROM.
	 */
	if (sc->sc_hasmac)
		goto hasmac;

	switch(sc->dc_type) {
	case DC_TYPE_98713:
	case DC_TYPE_98713A:
	case DC_TYPE_987x5:
	case DC_TYPE_PNICII:
		dc_read_eeprom(sc, (caddr_t)&mac_offset,
		    (DC_EE_NODEADDR_OFFSET / 2), 1, 0);
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr,
		    (mac_offset / 2), 3, 0);
		break;
	case DC_TYPE_PNIC:
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr, 0, 3, 1);
		break;
	case DC_TYPE_DM9102:
	case DC_TYPE_21143:
	case DC_TYPE_21145:
	case DC_TYPE_ASIX:
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr,	
		    DC_EE_NODEADDR, 3, 0);
		break;
	case DC_TYPE_AL981:
	case DC_TYPE_AN983:
		reg = CSR_READ_4(sc, DC_AL_PAR0);
		sc->sc_arpcom.ac_enaddr[0] = (reg & 0xff);
		sc->sc_arpcom.ac_enaddr[1] = (reg >> 8) & 0xff;
		sc->sc_arpcom.ac_enaddr[2] = (reg >> 16) & 0xff;
		sc->sc_arpcom.ac_enaddr[3] = (reg >> 24) & 0xff;
		reg = CSR_READ_4(sc, DC_AL_PAR1);
		sc->sc_arpcom.ac_enaddr[4] = (reg & 0xff);
		sc->sc_arpcom.ac_enaddr[5] = (reg >> 8) & 0xff;
		break;
	case DC_TYPE_CONEXANT:
		bcopy(&sc->dc_srom + DC_CONEXANT_EE_NODEADDR,
		    &sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
		break;
	case DC_TYPE_XIRCOM:
		/* Some newer units have the MAC at offset 8 */
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr, 8, 3, 0);

		if (sc->sc_arpcom.ac_enaddr[0] == 0x00 &&
		    sc->sc_arpcom.ac_enaddr[1] == 0x10 &&
		    sc->sc_arpcom.ac_enaddr[2] == 0xa4)
			break;
		if (sc->sc_arpcom.ac_enaddr[0] == 0x00 &&
		    sc->sc_arpcom.ac_enaddr[1] == 0x80 &&
		    sc->sc_arpcom.ac_enaddr[2] == 0xc7)
			break;
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr, 3, 3, 0);
		break;
	default:
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr,
		    DC_EE_NODEADDR, 3, 0);
		break;
	}
hasmac:

	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct dc_list_data),
	    PAGE_SIZE, 0, sc->sc_listseg, 1, &sc->sc_listnseg,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0) {
		printf(": can't alloc list mem\n");
		goto fail;
	}
	if (bus_dmamem_map(sc->sc_dmat, sc->sc_listseg, sc->sc_listnseg,
	    sizeof(struct dc_list_data), &sc->sc_listkva,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": can't map list mem\n");
		goto fail;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct dc_list_data), 1,
	    sizeof(struct dc_list_data), 0, BUS_DMA_NOWAIT,
	    &sc->sc_listmap) != 0) {
		printf(": can't alloc list map\n");
		goto fail;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_listmap, sc->sc_listkva,
	    sizeof(struct dc_list_data), NULL, BUS_DMA_NOWAIT) != 0) {
		printf(": can't load list map\n");
		goto fail;
	}
	sc->dc_ldata = (struct dc_list_data *)sc->sc_listkva;

	for (i = 0; i < DC_RX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT,
		    &sc->dc_cdata.dc_rx_chain[i].sd_map) != 0) {
			printf(": can't create rx map\n");
			return;
		}
	}
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
	    BUS_DMA_NOWAIT, &sc->sc_rx_sparemap) != 0) {
		printf(": can't create rx spare map\n");
		return;
	}	

	for (i = 0; i < DC_TX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    (sc->dc_flags & DC_TX_COALESCE) ? 1 : DC_TX_LIST_CNT - 5,
		    MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->dc_cdata.dc_tx_chain[i].sd_map) != 0) {
			printf(": can't create tx map\n");
			return;
		}
	}
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES,
	    (sc->dc_flags & DC_TX_COALESCE) ? 1 : DC_TX_LIST_CNT - 5,
	    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->sc_tx_sparemap) != 0) {
		printf(": can't create tx spare map\n");
		return;
	}

	/*
	 * A 21143 or clone chip was detected. Inform the world.
	 */
	printf(", address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	ifp = &sc->sc_arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = dc_ioctl;
	ifp->if_start = dc_start;
	ifp->if_watchdog = dc_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, DC_TX_LIST_CNT - 1);
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Do MII setup. If this is a 21143, check for a PHY on the
	 * MII bus after applying any necessary fixups to twiddle the
	 * GPIO bits. If we don't end up finding a PHY, restore the
	 * old selection (SIA only or SIA/SYM) and attach the dcphy
	 * driver instead.
	 */
	if (DC_IS_INTEL(sc)) {
		dc_apply_fixup(sc, IFM_AUTO);
		tmp = sc->dc_pmode;
		sc->dc_pmode = DC_PMODE_MII;
	}

	/*
	 * Setup General Purpose port mode and data so the tulip can talk
	 * to the MII.  This needs to be done before mii_attach so that
	 * we can actually see them.
	 */
	if (DC_IS_XIRCOM(sc)) {
		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_WRITE_EN | DC_SIAGP_INT1_EN |
		    DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);
		DELAY(10);
		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_INT1_EN |
		    DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);
		DELAY(10);
	}

	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = dc_miibus_readreg;
	sc->sc_mii.mii_writereg = dc_miibus_writereg;
	sc->sc_mii.mii_statchg = dc_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, dc_ifmedia_upd, dc_ifmedia_sts);
	mii_attach(&sc->sc_dev, &sc->sc_mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, 0);

	if (DC_IS_INTEL(sc)) {
		if (LIST_EMPTY(&sc->sc_mii.mii_phys)) {
			sc->dc_pmode = tmp;
			if (sc->dc_pmode != DC_PMODE_SIA)
				sc->dc_pmode = DC_PMODE_SYM;
			sc->dc_flags |= DC_21143_NWAY;
			if (sc->dc_flags & DC_MOMENCO_BOTCH)
				sc->dc_pmode = DC_PMODE_MII;
			mii_attach(&sc->sc_dev, &sc->sc_mii, 0xffffffff,
			    MII_PHY_ANY, MII_OFFSET_ANY, 0);
		} else {
			/* we have a PHY, so we must clear this bit */
			sc->dc_flags &= ~DC_TULIP_LEDS;
		}
	}

	if (LIST_EMPTY(&sc->sc_mii.mii_phys)) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
		printf("%s: MII without any PHY!\n", sc->sc_dev.dv_xname);
	} else if (sc->dc_type == DC_TYPE_21145) {
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	if (DC_IS_DAVICOM(sc) && sc->dc_revision >= DC_REVISION_DM9102A)
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_HPNA_1,0,NULL);

	if (DC_IS_ADMTEK(sc)) {
		/*
		 * Set automatic TX underrun recovery for the ADMtek chips
		 */
		DC_SETBIT(sc, DC_AL_CR, DC_AL_CR_ATUR);
	}

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

fail:
	return;
}

/*
 * Initialize the transmit descriptors.
 */
int
dc_list_tx_init(struct dc_softc *sc)
{
	struct dc_chain_data *cd;
	struct dc_list_data *ld;
	int i;
	bus_addr_t next;

	cd = &sc->dc_cdata;
	ld = sc->dc_ldata;
	for (i = 0; i < DC_TX_LIST_CNT; i++) {
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (DC_TX_LIST_CNT - 1))
			next +=
			    offsetof(struct dc_list_data, dc_tx_list[0]);
		else
			next +=
			    offsetof(struct dc_list_data, dc_tx_list[i + 1]);
		cd->dc_tx_chain[i].sd_mbuf = NULL;
		ld->dc_tx_list[i].dc_data = htole32(0);
		ld->dc_tx_list[i].dc_ctl = htole32(0);
		ld->dc_tx_list[i].dc_next = htole32(next);
	}

	cd->dc_tx_prod = cd->dc_tx_cons = cd->dc_tx_cnt = 0;

	return (0);
}


/*
 * Initialize the RX descriptors and allocate mbufs for them. Note that
 * we arrange the descriptors in a closed ring, so that the last descriptor
 * points back to the first.
 */
int
dc_list_rx_init(struct dc_softc *sc)
{
	struct dc_chain_data *cd;
	struct dc_list_data *ld;
	int i;
	bus_addr_t next;

	cd = &sc->dc_cdata;
	ld = sc->dc_ldata;

	for (i = 0; i < DC_RX_LIST_CNT; i++) {
		if (dc_newbuf(sc, i, NULL) == ENOBUFS)
			return (ENOBUFS);
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (DC_RX_LIST_CNT - 1))
			next +=
			    offsetof(struct dc_list_data, dc_rx_list[0]);
		else
			next +=
			    offsetof(struct dc_list_data, dc_rx_list[i + 1]);
		ld->dc_rx_list[i].dc_next = htole32(next);
	}

	cd->dc_rx_prod = 0;

	return (0);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
int
dc_newbuf(struct dc_softc *sc, int i, struct mbuf *m)
{
	struct mbuf *m_new = NULL;
	struct dc_desc *c;
	bus_dmamap_t map;

	c = &sc->dc_ldata->dc_rx_list[i];

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		if (bus_dmamap_load_mbuf(sc->sc_dmat, sc->sc_rx_sparemap,
		    m_new, BUS_DMA_NOWAIT) != 0) {
			m_freem(m_new);
			return (ENOBUFS);
		}
		map = sc->dc_cdata.dc_rx_chain[i].sd_map;
		sc->dc_cdata.dc_rx_chain[i].sd_map = sc->sc_rx_sparemap;
		sc->sc_rx_sparemap = map;
	} else {
		/*
		 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, sizeof(u_int64_t));

	/*
	 * If this is a PNIC chip, zero the buffer. This is part
	 * of the workaround for the receive bug in the 82c168 and
	 * 82c169 chips.
	 */
	if (sc->dc_flags & DC_PNIC_RX_BUG_WAR)
		bzero(mtod(m_new, char *), m_new->m_len);

	bus_dmamap_sync(sc->sc_dmat, sc->dc_cdata.dc_rx_chain[i].sd_map, 0,
	    sc->dc_cdata.dc_rx_chain[i].sd_map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

	sc->dc_cdata.dc_rx_chain[i].sd_mbuf = m_new;
	c->dc_data = htole32(
	    sc->dc_cdata.dc_rx_chain[i].sd_map->dm_segs[0].ds_addr +
	    sizeof(u_int64_t));
	c->dc_ctl = htole32(DC_RXCTL_RLINK | ETHER_MAX_DIX_LEN);
	c->dc_status = htole32(DC_RXSTAT_OWN);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_rx_list[i]),
	    sizeof(struct dc_desc),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	return (0);
}

/*
 * Grrrrr.
 * The PNIC chip has a terrible bug in it that manifests itself during
 * periods of heavy activity. The exact mode of failure if difficult to
 * pinpoint: sometimes it only happens in promiscuous mode, sometimes it
 * will happen on slow machines. The bug is that sometimes instead of
 * uploading one complete frame during reception, it uploads what looks
 * like the entire contents of its FIFO memory. The frame we want is at
 * the end of the whole mess, but we never know exactly how much data has
 * been uploaded, so salvaging the frame is hard.
 *
 * There is only one way to do it reliably, and it's disgusting.
 * Here's what we know:
 *
 * - We know there will always be somewhere between one and three extra
 *   descriptors uploaded.
 *
 * - We know the desired received frame will always be at the end of the
 *   total data upload.
 *
 * - We know the size of the desired received frame because it will be
 *   provided in the length field of the status word in the last descriptor.
 *
 * Here's what we do:
 *
 * - When we allocate buffers for the receive ring, we bzero() them.
 *   This means that we know that the buffer contents should be all
 *   zeros, except for data uploaded by the chip.
 *
 * - We also force the PNIC chip to upload frames that include the
 *   ethernet CRC at the end.
 *
 * - We gather all of the bogus frame data into a single buffer.
 *
 * - We then position a pointer at the end of this buffer and scan
 *   backwards until we encounter the first non-zero byte of data.
 *   This is the end of the received frame. We know we will encounter
 *   some data at the end of the frame because the CRC will always be
 *   there, so even if the sender transmits a packet of all zeros,
 *   we won't be fooled.
 *
 * - We know the size of the actual received frame, so we subtract
 *   that value from the current pointer location. This brings us
 *   to the start of the actual received packet.
 *
 * - We copy this into an mbuf and pass it on, along with the actual
 *   frame length.
 *
 * The performance hit is tremendous, but it beats dropping frames all
 * the time.
 */

#define DC_WHOLEFRAME	(DC_RXSTAT_FIRSTFRAG|DC_RXSTAT_LASTFRAG)
void
dc_pnic_rx_bug_war(struct dc_softc *sc, int idx)
{
	struct dc_desc		*cur_rx;
	struct dc_desc		*c = NULL;
	struct mbuf		*m = NULL;
	unsigned char		*ptr;
	int			i, total_len;
	u_int32_t		rxstat = 0;

	i = sc->dc_pnic_rx_bug_save;
	cur_rx = &sc->dc_ldata->dc_rx_list[idx];
	ptr = sc->dc_pnic_rx_buf;
	bzero(ptr, ETHER_MAX_DIX_LEN * 5);

	/* Copy all the bytes from the bogus buffers. */
	while (1) {
		c = &sc->dc_ldata->dc_rx_list[i];
		rxstat = letoh32(c->dc_status);
		m = sc->dc_cdata.dc_rx_chain[i].sd_mbuf;
		bcopy(mtod(m, char *), ptr, ETHER_MAX_DIX_LEN);
		ptr += ETHER_MAX_DIX_LEN;
		/* If this is the last buffer, break out. */
		if (i == idx || rxstat & DC_RXSTAT_LASTFRAG)
			break;
		dc_newbuf(sc, i, m);
		DC_INC(i, DC_RX_LIST_CNT);
	}

	/* Find the length of the actual receive frame. */
	total_len = DC_RXBYTES(rxstat);

	/* Scan backwards until we hit a non-zero byte. */
	while(*ptr == 0x00)
		ptr--;

	/* Round off. */
	if ((unsigned long)(ptr) & 0x3)
		ptr -= 1;

	/* Now find the start of the frame. */
	ptr -= total_len;
	if (ptr < sc->dc_pnic_rx_buf)
		ptr = sc->dc_pnic_rx_buf;

	/*
	 * Now copy the salvaged frame to the last mbuf and fake up
	 * the status word to make it look like a successful
 	 * frame reception.
	 */
	dc_newbuf(sc, i, m);
	bcopy(ptr, mtod(m, char *), total_len);	
	cur_rx->dc_status = htole32(rxstat | DC_RXSTAT_FIRSTFRAG);
}

/*
 * This routine searches the RX ring for dirty descriptors in the
 * event that the rxeof routine falls out of sync with the chip's
 * current descriptor pointer. This may happen sometimes as a result
 * of a "no RX buffer available" condition that happens when the chip
 * consumes all of the RX buffers before the driver has a chance to
 * process the RX ring. This routine may need to be called more than
 * once to bring the driver back in sync with the chip, however we
 * should still be getting RX DONE interrupts to drive the search
 * for new packets in the RX ring, so we should catch up eventually.
 */
int
dc_rx_resync(struct dc_softc *sc)
{
	u_int32_t stat;
	int i, pos, offset;

	pos = sc->dc_cdata.dc_rx_prod;

	for (i = 0; i < DC_RX_LIST_CNT; i++) {

		offset = offsetof(struct dc_list_data, dc_rx_list[pos]);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    offset, sizeof(struct dc_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		stat = sc->dc_ldata->dc_rx_list[pos].dc_status;
		if (!(stat & htole32(DC_RXSTAT_OWN)))
			break;
		DC_INC(pos, DC_RX_LIST_CNT);
	}

	/* If the ring really is empty, then just return. */
	if (i == DC_RX_LIST_CNT)
		return (0);

	/* We've fallen behind the chip: catch it. */
	sc->dc_cdata.dc_rx_prod = pos;

	return (EAGAIN);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
int
dc_rxeof(struct dc_softc *sc)
{
	struct mbuf *m;
	struct ifnet *ifp;
	struct dc_desc *cur_rx;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	int i, offset, total_len = 0, consumed = 0;
	u_int32_t rxstat;

	ifp = &sc->sc_arpcom.ac_if;
	i = sc->dc_cdata.dc_rx_prod;

	for(;;) {
		struct mbuf	*m0 = NULL;

		offset = offsetof(struct dc_list_data, dc_rx_list[i]);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    offset, sizeof(struct dc_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		cur_rx = &sc->dc_ldata->dc_rx_list[i];
		rxstat = letoh32(cur_rx->dc_status);
		if (rxstat & DC_RXSTAT_OWN)
			break;

		m = sc->dc_cdata.dc_rx_chain[i].sd_mbuf;
		total_len = DC_RXBYTES(rxstat);

		bus_dmamap_sync(sc->sc_dmat, sc->dc_cdata.dc_rx_chain[i].sd_map,
		    0, sc->dc_cdata.dc_rx_chain[i].sd_map->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);

		if (sc->dc_flags & DC_PNIC_RX_BUG_WAR) {
			if ((rxstat & DC_WHOLEFRAME) != DC_WHOLEFRAME) {
				if (rxstat & DC_RXSTAT_FIRSTFRAG)
					sc->dc_pnic_rx_bug_save = i;
				if ((rxstat & DC_RXSTAT_LASTFRAG) == 0) {
					DC_INC(i, DC_RX_LIST_CNT);
					continue;
				}
				dc_pnic_rx_bug_war(sc, i);
				rxstat = letoh32(cur_rx->dc_status);
				total_len = DC_RXBYTES(rxstat);
			}
		}

		sc->dc_cdata.dc_rx_chain[i].sd_mbuf = NULL;

		/*
		 * If an error occurs, update stats, clear the
		 * status word and leave the mbuf cluster in place:
		 * it should simply get re-used next time this descriptor
		 * comes up in the ring.  However, don't report long
		 * frames as errors since they could be VLANs.
		 */
		if ((rxstat & DC_RXSTAT_RXERR)) {
			if (!(rxstat & DC_RXSTAT_GIANT) ||
			    (rxstat & (DC_RXSTAT_CRCERR | DC_RXSTAT_DRIBBLE |
				       DC_RXSTAT_MIIERE | DC_RXSTAT_COLLSEEN |
				       DC_RXSTAT_RUNT   | DC_RXSTAT_DE))) {
				ifp->if_ierrors++;
				if (rxstat & DC_RXSTAT_COLLSEEN)
					ifp->if_collisions++;
				dc_newbuf(sc, i, m);
				if (rxstat & DC_RXSTAT_CRCERR) {
					DC_INC(i, DC_RX_LIST_CNT);
					continue;
				} else {
					dc_init(sc);
					break;
				}
			}
		}

		/* No errors; receive the packet. */	
		total_len -= ETHER_CRC_LEN;

		m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN);
		dc_newbuf(sc, i, m);
		DC_INC(i, DC_RX_LIST_CNT);
		if (m0 == NULL) {
			ifp->if_ierrors++;
			continue;
		}
		m = m0;

		consumed++;
		ml_enqueue(&ml, m);
	}

	sc->dc_cdata.dc_rx_prod = i;

	if_input(ifp, &ml);

	return (consumed);
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
dc_txeof(struct dc_softc *sc)
{
	struct dc_desc *cur_tx = NULL;
	struct ifnet *ifp;
	int idx, offset;

	ifp = &sc->sc_arpcom.ac_if;

	/*
	 * Go through our tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	idx = sc->dc_cdata.dc_tx_cons;
	while(idx != sc->dc_cdata.dc_tx_prod) {
		u_int32_t		txstat;

		offset = offsetof(struct dc_list_data, dc_tx_list[idx]);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    offset, sizeof(struct dc_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		cur_tx = &sc->dc_ldata->dc_tx_list[idx];
		txstat = letoh32(cur_tx->dc_status);

		if (txstat & DC_TXSTAT_OWN)
			break;

		if (!(cur_tx->dc_ctl & htole32(DC_TXCTL_LASTFRAG)) ||
		    cur_tx->dc_ctl & htole32(DC_TXCTL_SETUP)) {
			if (cur_tx->dc_ctl & htole32(DC_TXCTL_SETUP)) {
				/*
				 * Yes, the PNIC is so brain damaged
				 * that it will sometimes generate a TX
				 * underrun error while DMAing the RX
				 * filter setup frame. If we detect this,
				 * we have to send the setup frame again,
				 * or else the filter won't be programmed
				 * correctly.
				 */
				if (DC_IS_PNIC(sc)) {
					if (txstat & DC_TXSTAT_ERRSUM)
						dc_setfilt(sc);
				}
				sc->dc_cdata.dc_tx_chain[idx].sd_mbuf = NULL;
			}
			sc->dc_cdata.dc_tx_cnt--;
			DC_INC(idx, DC_TX_LIST_CNT);
			continue;
		}

		if (DC_IS_XIRCOM(sc) || DC_IS_CONEXANT(sc)) {
			/*
			 * XXX: Why does my Xircom taunt me so?
			 * For some reason it likes setting the CARRLOST flag
			 * even when the carrier is there. wtf?!
			 * Who knows, but Conexant chips have the
			 * same problem. Maybe they took lessons
			 * from Xircom.
			 */
			if (/*sc->dc_type == DC_TYPE_21143 &&*/
			    sc->dc_pmode == DC_PMODE_MII &&
			    ((txstat & 0xFFFF) & ~(DC_TXSTAT_ERRSUM|
			    DC_TXSTAT_NOCARRIER)))
				txstat &= ~DC_TXSTAT_ERRSUM;
		} else {
			if (/*sc->dc_type == DC_TYPE_21143 &&*/
			    sc->dc_pmode == DC_PMODE_MII &&
		    	    ((txstat & 0xFFFF) & ~(DC_TXSTAT_ERRSUM|
		    	    DC_TXSTAT_NOCARRIER|DC_TXSTAT_CARRLOST)))
				txstat &= ~DC_TXSTAT_ERRSUM;
		}

		if (txstat & DC_TXSTAT_ERRSUM) {
			ifp->if_oerrors++;
			if (txstat & DC_TXSTAT_EXCESSCOLL)
				ifp->if_collisions++;
			if (txstat & DC_TXSTAT_LATECOLL)
				ifp->if_collisions++;
			if (!(txstat & DC_TXSTAT_UNDERRUN)) {
				dc_init(sc);
				return;
			}
		}

		ifp->if_collisions += (txstat & DC_TXSTAT_COLLCNT) >> 3;

		if (sc->dc_cdata.dc_tx_chain[idx].sd_map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->dc_cdata.dc_tx_chain[idx].sd_map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
		if (sc->dc_cdata.dc_tx_chain[idx].sd_mbuf != NULL) {
			m_freem(sc->dc_cdata.dc_tx_chain[idx].sd_mbuf);
			sc->dc_cdata.dc_tx_chain[idx].sd_mbuf = NULL;
		}

		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    offset, sizeof(struct dc_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		sc->dc_cdata.dc_tx_cnt--;
		DC_INC(idx, DC_TX_LIST_CNT);
	}
	sc->dc_cdata.dc_tx_cons = idx;

	if (DC_TX_LIST_CNT - sc->dc_cdata.dc_tx_cnt > 5)
		ifq_clr_oactive(&ifp->if_snd);
	if (sc->dc_cdata.dc_tx_cnt == 0)
		ifp->if_timer = 0;
}

void
dc_tick(void *xsc)
{
	struct dc_softc *sc = (struct dc_softc *)xsc;
	struct mii_data *mii;
	struct ifnet *ifp;
	int s;
	u_int32_t r;

	s = splnet();

	ifp = &sc->sc_arpcom.ac_if;
	mii = &sc->sc_mii;

	if (sc->dc_flags & DC_REDUCED_MII_POLL) {
		if (sc->dc_flags & DC_21143_NWAY) {
			r = CSR_READ_4(sc, DC_10BTSTAT);
			if (IFM_SUBTYPE(mii->mii_media_active) ==
			    IFM_100_TX && (r & DC_TSTAT_LS100)) {
				sc->dc_link = 0;
				mii_mediachg(mii);
			}
			if (IFM_SUBTYPE(mii->mii_media_active) ==
			    IFM_10_T && (r & DC_TSTAT_LS10)) {
				sc->dc_link = 0;
				mii_mediachg(mii);
			}
			if (sc->dc_link == 0)
				mii_tick(mii);
		} else {
			/*
			 * For NICs which never report DC_RXSTATE_WAIT, we
			 * have to bite the bullet...
			 */
			if ((DC_HAS_BROKEN_RXSTATE(sc) || (CSR_READ_4(sc,
			    DC_ISR) & DC_ISR_RX_STATE) == DC_RXSTATE_WAIT) &&
			    sc->dc_cdata.dc_tx_cnt == 0 && !DC_IS_ASIX(sc)) {
				mii_tick(mii);
				if (!(mii->mii_media_status & IFM_ACTIVE))
					sc->dc_link = 0;
			}
		}
	} else
		mii_tick(mii);

	/*
	 * When the init routine completes, we expect to be able to send
	 * packets right away, and in fact the network code will send a
	 * gratuitous ARP the moment the init routine marks the interface
	 * as running. However, even though the MAC may have been initialized,
	 * there may be a delay of a few seconds before the PHY completes
	 * autonegotiation and the link is brought up. Any transmissions
	 * made during that delay will be lost. Dealing with this is tricky:
	 * we can't just pause in the init routine while waiting for the
	 * PHY to come ready since that would bring the whole system to
	 * a screeching halt for several seconds.
	 *
	 * What we do here is prevent the TX start routine from sending
	 * any packets until a link has been established. After the
	 * interface has been initialized, the tick routine will poll
	 * the state of the PHY until the IFM_ACTIVE flag is set. Until
	 * that time, packets will stay in the send queue, and once the
	 * link comes up, they will be flushed out to the wire.
	 */
	if (!sc->dc_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		sc->dc_link++;
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
	 	    dc_start(ifp);
	}

	if (sc->dc_flags & DC_21143_NWAY && !sc->dc_link)
		timeout_add_msec(&sc->dc_tick_tmo, 100);
	else
		timeout_add_sec(&sc->dc_tick_tmo, 1);

	splx(s);
}

/* A transmit underrun has occurred.  Back off the transmit threshold,
 * or switch to store and forward mode if we have to.
 */
void
dc_tx_underrun(struct dc_softc *sc)
{
	u_int32_t	isr;
	int		i;

	if (DC_IS_DAVICOM(sc))
		dc_init(sc);

	if (DC_IS_INTEL(sc)) {
		/*
		 * The real 21143 requires that the transmitter be idle
		 * in order to change the transmit threshold or store
		 * and forward state.
		 */
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);

		for (i = 0; i < DC_TIMEOUT; i++) {
			isr = CSR_READ_4(sc, DC_ISR);
			if (isr & DC_ISR_TX_IDLE)
				break;
			DELAY(10);
		}
		if (i == DC_TIMEOUT) {
			printf("%s: failed to force tx to idle state\n",
			    sc->sc_dev.dv_xname);
			dc_init(sc);
		}
	}

	sc->dc_txthresh += DC_TXTHRESH_INC;
	if (sc->dc_txthresh > DC_TXTHRESH_MAX) {
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);
	} else {
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);
		DC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);
	}

	if (DC_IS_INTEL(sc))
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);

	return;
}

int
dc_intr(void *arg)
{
	struct dc_softc *sc;
	struct ifnet *ifp;
	u_int32_t status, ints;
	int claimed = 0;

	sc = arg;

	ifp = &sc->sc_arpcom.ac_if;

	ints = CSR_READ_4(sc, DC_ISR);
	if ((ints & DC_INTRS) == 0)
		return (claimed);
	if (ints == 0xffffffff)
		return (0);

	/* Suppress unwanted interrupts */
	if (!(ifp->if_flags & IFF_UP)) {
		if (CSR_READ_4(sc, DC_ISR) & DC_INTRS)
			dc_stop(sc, 0);
		return (claimed);
	}

	/* Disable interrupts. */
	CSR_WRITE_4(sc, DC_IMR, 0x00000000);

	while (((status = CSR_READ_4(sc, DC_ISR)) & DC_INTRS) &&
	    status != 0xFFFFFFFF &&
	    (ifp->if_flags & IFF_RUNNING)) {

		claimed = 1;
		CSR_WRITE_4(sc, DC_ISR, status);

		if (status & DC_ISR_RX_OK) {
			if (dc_rxeof(sc) == 0) {
				while(dc_rx_resync(sc))
					dc_rxeof(sc);
			}
		}

		if (status & (DC_ISR_TX_OK|DC_ISR_TX_NOBUF))
			dc_txeof(sc);

		if (status & DC_ISR_TX_IDLE) {
			dc_txeof(sc);
			if (sc->dc_cdata.dc_tx_cnt) {
				DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);
				CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);
			}
		}

		if (status & DC_ISR_TX_UNDERRUN)
			dc_tx_underrun(sc);

		if ((status & DC_ISR_RX_WATDOGTIMEO)
		    || (status & DC_ISR_RX_NOBUF)) {
			if (dc_rxeof(sc) == 0) {
				while(dc_rx_resync(sc))
					dc_rxeof(sc);
			}
		}

		if (status & DC_ISR_BUS_ERR)
			dc_init(sc);
	}

	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, DC_IMR, DC_INTRS);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		dc_start(ifp);

	return (claimed);
}

/*
 * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data
 * pointers to the fragment pointers.
 */
int
dc_encap(struct dc_softc *sc, bus_dmamap_t map, struct mbuf *m, u_int32_t *idx)
{
	struct dc_desc *f = NULL;
	int frag, cur, cnt = 0, i;

	cur = frag = *idx;

	for (i = 0; i < map->dm_nsegs; i++) {
		f = &sc->dc_ldata->dc_tx_list[frag];
		f->dc_ctl = htole32(DC_TXCTL_TLINK | map->dm_segs[i].ds_len);
		if (cnt == 0) {
			f->dc_status = htole32(0);
			f->dc_ctl |= htole32(DC_TXCTL_FIRSTFRAG);
		} else
			f->dc_status = htole32(DC_TXSTAT_OWN);
		f->dc_data = htole32(map->dm_segs[i].ds_addr);
		cur = frag;
		DC_INC(frag, DC_TX_LIST_CNT);
		cnt++;
	}

	sc->dc_cdata.dc_tx_cnt += cnt;
	sc->dc_cdata.dc_tx_chain[cur].sd_mbuf = m;
	sc->sc_tx_sparemap = sc->dc_cdata.dc_tx_chain[cur].sd_map;
	sc->dc_cdata.dc_tx_chain[cur].sd_map = map;
	sc->dc_ldata->dc_tx_list[cur].dc_ctl |= htole32(DC_TXCTL_LASTFRAG);
	if (sc->dc_flags & DC_TX_INTR_FIRSTFRAG)
		sc->dc_ldata->dc_tx_list[*idx].dc_ctl |=
		    htole32(DC_TXCTL_FINT);
	if (sc->dc_flags & DC_TX_INTR_ALWAYS)
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |=
		    htole32(DC_TXCTL_FINT);
	if (sc->dc_flags & DC_TX_USE_TX_INTR && sc->dc_cdata.dc_tx_cnt > 64)
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |=
		    htole32(DC_TXCTL_FINT);
	bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	sc->dc_ldata->dc_tx_list[*idx].dc_status = htole32(DC_TXSTAT_OWN);

	*idx = frag;

	return (0);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit lists. We also save a
 * copy of the pointers since the transmit list fragment pointers are
 * physical addresses.
 */

static inline int
dc_fits(struct dc_softc *sc, int idx, bus_dmamap_t map)
{
	if (sc->dc_flags & DC_TX_ADMTEK_WAR) {
		if (sc->dc_cdata.dc_tx_prod != idx &&
		    idx + map->dm_nsegs >= DC_TX_LIST_CNT)
			return (0);
	}

	if (sc->dc_cdata.dc_tx_cnt + map->dm_nsegs + 5 > DC_TX_LIST_CNT)
		return (0);

	return (1);
}

void
dc_start(struct ifnet *ifp)
{
	struct dc_softc *sc = ifp->if_softc;
	bus_dmamap_t map;
	struct mbuf *m;
	int idx;

	if (!sc->dc_link && IFQ_LEN(&ifp->if_snd) < 10)
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	idx = sc->dc_cdata.dc_tx_prod;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_tx_list),
	    sizeof(struct dc_desc) * DC_TX_LIST_CNT,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	for (;;) {
		m = ifq_deq_begin(&ifp->if_snd);
		if (m == NULL)
			break;

		map = sc->sc_tx_sparemap;
		switch (bus_dmamap_load_mbuf(sc->sc_dmat, map, m,
		    BUS_DMA_NOWAIT | BUS_DMA_OVERRUN)) {
		case 0:
			break;
		case EFBIG:
			if (m_defrag(m, M_DONTWAIT) == 0 &&
			    bus_dmamap_load_mbuf(sc->sc_dmat, map, m,
			     BUS_DMA_NOWAIT | BUS_DMA_OVERRUN) == 0)
				break;

			/* FALLTHROUGH */
		default:
			ifq_deq_commit(&ifp->if_snd, m);
			m_freem(m);
			ifp->if_oerrors++;
			continue;
		}

		if (!dc_fits(sc, idx, map)) {
			bus_dmamap_unload(sc->sc_dmat, map);
			ifq_deq_rollback(&ifp->if_snd, m);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		/* now we are committed to transmit the packet */
		ifq_deq_commit(&ifp->if_snd, m);

		if (dc_encap(sc, map, m, &idx) != 0) {
			m_freem(m);
			ifp->if_oerrors++;
			continue;
		}

		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		if (sc->dc_flags & DC_TX_ONE) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
	}

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_tx_list),
	    sizeof(struct dc_desc) * DC_TX_LIST_CNT,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	if (idx == sc->dc_cdata.dc_tx_prod)
		return;

	/* Transmit */
	sc->dc_cdata.dc_tx_prod = idx;
	if (!(sc->dc_flags & DC_TX_POLL))
		CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
}

void
dc_init(void *xsc)
{
	struct dc_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mii_data *mii;
	int s;

	s = splnet();

	mii = &sc->sc_mii;

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	dc_stop(sc, 0);
	dc_reset(sc);

	/*
	 * Set cache alignment and burst length.
	 */
	if (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))
		CSR_WRITE_4(sc, DC_BUSCTL, 0);
	else
		CSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);
	/*
	 * Evenly share the bus between receive and transmit process.
	 */
	if (DC_IS_INTEL(sc))
		DC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_ARBITRATION);
	if (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {
		DC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);
	} else {
		DC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);
	}
	if (sc->dc_flags & DC_TX_POLL)
		DC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);
	switch(sc->dc_cachesize) {
	case 32:
		DC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);
		break;
	case 16:
		DC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);
		break; 
	case 8:
		DC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);
		break;  
	case 0:
	default:
		DC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);
		break;
	}

	if (sc->dc_flags & DC_TX_STORENFWD)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);
	else {
		if (sc->dc_txthresh > DC_TXTHRESH_MAX) {
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);
		} else {
			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);
			DC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);
		}
	}

	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);
	DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);

	if (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {
		/*
		 * The app notes for the 98713 and 98715A say that
		 * in order to have the chips operate properly, a magic
		 * number must be written to CSR16. Macronix does not
		 * document the meaning of these bits so there's no way
		 * to know exactly what they do. The 98713 has a magic
		 * number all its own; the rest all use a different one.
		 */
		DC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);
		if (sc->dc_type == DC_TYPE_98713)
			DC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);
		else
			DC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);
	}

	if (DC_IS_XIRCOM(sc)) {
		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_WRITE_EN | DC_SIAGP_INT1_EN |
		    DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);
		DELAY(10);
		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_INT1_EN |
		    DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);
		DELAY(10);
	}

	DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);
	DC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_MIN);

	/* Init circular RX list. */
	if (dc_list_rx_init(sc) == ENOBUFS) {
		printf("%s: initialization failed: no "
		    "memory for rx buffers\n", sc->sc_dev.dv_xname);
		dc_stop(sc, 0);
		splx(s);
		return;
	}

	/*
	 * Init tx descriptors.
	 */
	dc_list_tx_init(sc);

	/*
	 * Sync down both lists initialized.
	 */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    0, sc->sc_listmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	/*
	 * Load the address of the RX list.
	 */
	CSR_WRITE_4(sc, DC_RXADDR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_rx_list[0]));
	CSR_WRITE_4(sc, DC_TXADDR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_tx_list[0]));

	/*
	 * Enable interrupts.
	 */
	CSR_WRITE_4(sc, DC_IMR, DC_INTRS);
	CSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);

	/* Enable transmitter. */
	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);

	/*
	 * If this is an Intel 21143 and we're not using the
	 * MII port, program the LED control pins so we get
	 * link and activity indications.
	 */
	if (sc->dc_flags & DC_TULIP_LEDS) {
		CSR_WRITE_4(sc, DC_WATCHDOG,
		    DC_WDOG_CTLWREN|DC_WDOG_LINK|DC_WDOG_ACTIVITY);
		CSR_WRITE_4(sc, DC_WATCHDOG, 0);
	}

	/*
	 * Load the RX/multicast filter. We do this sort of late
	 * because the filter programming scheme on the 21143 and
	 * some clones requires DMAing a setup frame via the TX
	 * engine, and we need the transmitter enabled for that.
	 */
	dc_setfilt(sc);

	/* Enable receiver. */
	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);
	CSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);

	mii_mediachg(mii);
	dc_setcfg(sc, sc->dc_if_media);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_set(&sc->dc_tick_tmo, dc_tick, sc);

	if (IFM_SUBTYPE(mii->mii_media.ifm_media) == IFM_HPNA_1)
		sc->dc_link = 1;
	else {
		if (sc->dc_flags & DC_21143_NWAY)
			timeout_add_msec(&sc->dc_tick_tmo, 100);
		else
			timeout_add_sec(&sc->dc_tick_tmo, 1);
	}

#ifdef SRM_MEDIA
	if(sc->dc_srm_media) {
		struct ifreq ifr;

		ifr.ifr_media = sc->dc_srm_media;
		ifmedia_ioctl(ifp, &ifr, &mii->mii_media, SIOCSIFMEDIA);
		sc->dc_srm_media = 0;
	}
#endif
}

/*
 * Set media options.
 */
int
dc_ifmedia_upd(struct ifnet *ifp)
{
	struct dc_softc *sc;
	struct mii_data *mii;
	struct ifmedia *ifm;

	sc = ifp->if_softc;
	mii = &sc->sc_mii;
	mii_mediachg(mii);

	ifm = &mii->mii_media;

	if (DC_IS_DAVICOM(sc) &&
	    IFM_SUBTYPE(ifm->ifm_media) == IFM_HPNA_1)
		dc_setcfg(sc, ifm->ifm_media);
	else
		sc->dc_link = 0;

	return (0);
}

/*
 * Report current media status.
 */
void
dc_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct dc_softc *sc;
	struct mii_data *mii;
	struct ifmedia *ifm;

	sc = ifp->if_softc;
	mii = &sc->sc_mii;
	mii_pollstat(mii);
	ifm = &mii->mii_media;
	if (DC_IS_DAVICOM(sc)) {
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_HPNA_1) {
			ifmr->ifm_active = ifm->ifm_media;
			ifmr->ifm_status = 0;
			return;
		}
	}
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

int
dc_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct dc_softc		*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	int			s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			dc_init(sc);
		break;
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else {
				sc->dc_txthresh = 0;
				dc_init(sc);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				dc_stop(sc, 0);
		}
		break;
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
#ifdef SRM_MEDIA
		if (sc->dc_srm_media)
			sc->dc_srm_media = 0;
#endif
		break;
	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			dc_setfilt(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
dc_watchdog(struct ifnet *ifp)
{
	struct dc_softc *sc;

	sc = ifp->if_softc;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);

	dc_init(sc);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		dc_start(ifp);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
dc_stop(struct dc_softc *sc, int softonly)
{
	struct ifnet *ifp;
	u_int32_t isr;
	int i;

	ifp = &sc->sc_arpcom.ac_if;
	ifp->if_timer = 0;

	timeout_del(&sc->dc_tick_tmo);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (!softonly) {
		DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));

		for (i = 0; i < DC_TIMEOUT; i++) {
			isr = CSR_READ_4(sc, DC_ISR);
			if ((isr & DC_ISR_TX_IDLE ||
			    (isr & DC_ISR_TX_STATE) == DC_TXSTATE_RESET) &&
			    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)
				break;
			DELAY(10);
		}

		if (i == DC_TIMEOUT) {
			if (!((isr & DC_ISR_TX_IDLE) ||
			    (isr & DC_ISR_TX_STATE) == DC_TXSTATE_RESET) &&
			    !DC_IS_ASIX(sc) && !DC_IS_DAVICOM(sc))
				printf("%s: failed to force tx to idle state\n",
				    sc->sc_dev.dv_xname);
			if (!((isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED) &&
			    !DC_HAS_BROKEN_RXSTATE(sc))
				printf("%s: failed to force rx to idle state\n",
				    sc->sc_dev.dv_xname);
		}

		CSR_WRITE_4(sc, DC_IMR, 0x00000000);
		CSR_WRITE_4(sc, DC_TXADDR, 0x00000000);
		CSR_WRITE_4(sc, DC_RXADDR, 0x00000000);
		sc->dc_link = 0;
	}

	/*
	 * Free data in the RX lists.
	 */
	for (i = 0; i < DC_RX_LIST_CNT; i++) {
		if (sc->dc_cdata.dc_rx_chain[i].sd_map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->dc_cdata.dc_rx_chain[i].sd_map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
		if (sc->dc_cdata.dc_rx_chain[i].sd_mbuf != NULL) {
			m_freem(sc->dc_cdata.dc_rx_chain[i].sd_mbuf);
			sc->dc_cdata.dc_rx_chain[i].sd_mbuf = NULL;
		}
	}
	bzero(&sc->dc_ldata->dc_rx_list, sizeof(sc->dc_ldata->dc_rx_list));

	/*
	 * Free the TX list buffers.
	 */
	for (i = 0; i < DC_TX_LIST_CNT; i++) {
		if (sc->dc_cdata.dc_tx_chain[i].sd_map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->dc_cdata.dc_tx_chain[i].sd_map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
		if (sc->dc_cdata.dc_tx_chain[i].sd_mbuf != NULL) {
			if (sc->dc_ldata->dc_tx_list[i].dc_ctl &
			    htole32(DC_TXCTL_SETUP)) {
				sc->dc_cdata.dc_tx_chain[i].sd_mbuf = NULL;
				continue;
			}
			m_freem(sc->dc_cdata.dc_tx_chain[i].sd_mbuf);
			sc->dc_cdata.dc_tx_chain[i].sd_mbuf = NULL;
		}
	}
	bzero(&sc->dc_ldata->dc_tx_list, sizeof(sc->dc_ldata->dc_tx_list));

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    0, sc->sc_listmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
}

int
dc_activate(struct device *self, int act)
{
	struct dc_softc *sc = (struct dc_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			dc_stop(sc, 0);
		rv = config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP)
			dc_init(sc);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
dc_detach(struct dc_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int i;

	dc_stop(sc, 1);

	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	if (sc->dc_srom)
		free(sc->dc_srom, M_DEVBUF, sc->dc_sromsize);

	for (i = 0; i < DC_RX_LIST_CNT; i++)
		bus_dmamap_destroy(sc->sc_dmat, sc->dc_cdata.dc_rx_chain[i].sd_map);
	if (sc->sc_rx_sparemap)
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_rx_sparemap);
	for (i = 0; i < DC_TX_LIST_CNT; i++)
		bus_dmamap_destroy(sc->sc_dmat, sc->dc_cdata.dc_tx_chain[i].sd_map);
	if (sc->sc_tx_sparemap)
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_tx_sparemap);

	/// XXX bus_dmamap_sync
	bus_dmamap_unload(sc->sc_dmat, sc->sc_listmap);
	bus_dmamem_unmap(sc->sc_dmat, sc->sc_listkva, sc->sc_listnseg);
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_listmap);
	bus_dmamem_free(sc->sc_dmat, sc->sc_listseg, sc->sc_listnseg);

	ether_ifdetach(ifp);
	if_detach(ifp);
	return (0);
}

struct cfdriver dc_cd = {
	0, "dc", DV_IFNET
};
@


1.151
log
@Use BUS_DMA_OVERRUN to cope with the broken DMA engine of the Davicom DM9102
found on some Sun sparc64 machines.  This fixes the unrecoverable DMA errors
people have been seeing ever since dlg@@ made changes to the pool code that
changes the memory layout.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.150 2016/04/13 10:49:26 mpi Exp $	*/
a2266 1
		ifp->if_opackets++;
@


1.150
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.149 2015/11/28 22:57:43 dlg Exp $	*/
d125 12
d2598 1
a2598 1
		    BUS_DMA_NOWAIT)) {
d2604 1
a2604 1
			     BUS_DMA_NOWAIT) == 0)
@


1.149
log
@rework dc_start and dc_encap to take advantage of m_defrag.

if the chip needs coalesced packages in tx, set the tx dmamaps up
to only use a single dma descriptor. use m_defrag when bus_dmamap_load_mbuf
returns EFBIG rather than copying the packet to a separate mbuf
with hand rolled code in dc_coal. that in turn makes the ifq_deq_begin,
ifq_deq_commit, and ifq_deq_rollback handling more straightforward.

tested by me on a hppa a180c with a "DEC 21142/3", and fred on bugs@@
with a sparc64 netra x1 "Davicom DM9102".
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.148 2015/11/25 03:09:58 dlg Exp $	*/
a1689 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.148
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.147 2015/11/24 13:33:17 mpi Exp $	*/
d128 1
a128 2
int dc_encap(struct dc_softc *, struct mbuf *, u_int32_t *);
int dc_coal(struct dc_softc *, struct mbuf **);
d1660 1
a1660 1
	}
d1664 2
a1665 1
		    DC_TX_LIST_CNT - 5, MCLBYTES, 0, BUS_DMA_NOWAIT,
d1671 2
a1672 1
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, DC_TX_LIST_CNT - 5,
d2492 1
a2492 1
dc_encap(struct dc_softc *sc, struct mbuf *m_head, u_int32_t *txidx)
a2495 12
	bus_dmamap_t map;

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	map = sc->sc_tx_sparemap;

	if (bus_dmamap_load_mbuf(sc->sc_dmat, map,
	    m_head, BUS_DMA_NOWAIT) != 0)
		return (ENOBUFS);
d2497 1
a2497 1
	cur = frag = *txidx;
a2499 13
		if (sc->dc_flags & DC_TX_ADMTEK_WAR) {
			if (*txidx != sc->dc_cdata.dc_tx_prod &&
			    frag == (DC_TX_LIST_CNT - 1)) {
				bus_dmamap_unload(sc->sc_dmat, map);
				return (ENOBUFS);
			}
		}
		if ((DC_TX_LIST_CNT -
		    (sc->dc_cdata.dc_tx_cnt + cnt)) < 5) {
			bus_dmamap_unload(sc->sc_dmat, map);
			return (ENOBUFS);
		}

d2514 1
a2514 1
	sc->dc_cdata.dc_tx_chain[cur].sd_mbuf = m_head;
d2519 1
a2519 1
		sc->dc_ldata->dc_tx_list[*txidx].dc_ctl |=
d2530 1
a2530 1
	sc->dc_ldata->dc_tx_list[*txidx].dc_status = htole32(DC_TXSTAT_OWN);
d2532 1
a2532 6
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_tx_list[*txidx]),
	    sizeof(struct dc_desc) * cnt,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	*txidx = frag;
d2538 4
a2541 3
 * Coalesce an mbuf chain into a single mbuf cluster buffer.
 * Needed for some really badly behaved chips that just can't
 * do scatter/gather correctly.
d2543 3
a2545 2
int
dc_coal(struct dc_softc *sc, struct mbuf **m_head)
d2547 5
a2551 1
	struct mbuf		*m_new, *m;
d2553 2
a2554 15
	m = *m_head;
	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL)
		return (ENOBUFS);
	if (m->m_pkthdr.len > MHLEN) {
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return (ENOBUFS);
		}
	}
	m_copydata(m, 0, m->m_pkthdr.len, mtod(m_new, caddr_t));
	m_new->m_pkthdr.len = m_new->m_len = m->m_pkthdr.len;
	m_freem(m);
	*m_head = m_new;
d2556 1
a2556 1
	return (0);
a2558 7
/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit lists. We also save a
 * copy of the pointers since the transmit list fragment pointers are
 * physical addresses.
 */

d2562 3
a2564 2
	struct dc_softc *sc;
	struct mbuf *m_head = NULL;
a2566 2
	sc = ifp->if_softc;

d2575 20
a2594 4
	while(sc->dc_cdata.dc_tx_chain[idx].sd_mbuf == NULL) {
		m_head = ifq_deq_begin(&ifp->if_snd);
		if (m_head == NULL)
			break;
d2596 6
a2601 11
		if (sc->dc_flags & DC_TX_COALESCE &&
		    (m_head->m_next != NULL ||
			sc->dc_flags & DC_TX_ALIGN)) {
			/* note: dc_coal breaks the poll-and-dequeue rule.
			 * if dc_coal fails, we lose the packet.
			 */
			ifq_deq_commit(&ifp->if_snd, m_head);
			if (dc_coal(sc, &m_head)) {
				ifq_set_oactive(&ifp->if_snd);
				break;
			}
d2604 3
a2606 4
		if (dc_encap(sc, m_head, &idx)) {
			if ((sc->dc_flags & DC_TX_COALESCE) == 0)
				ifq_deq_rollback(&ifp->if_snd, m_head);

d2612 7
a2618 4
		if (sc->dc_flags & DC_TX_COALESCE) {
			/* if mbuf is coalesced, it is already dequeued */
		} else
			ifq_deq_commit(&ifp->if_snd, m_head);
d2626 1
a2626 1
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
d2628 1
d2634 6
@


1.147
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.146 2015/11/20 03:35:22 dlg Exp $	*/
d2278 1
a2278 1
		ifp->if_flags &= ~IFF_OACTIVE;
d2614 1
a2614 1
	if (ifp->if_flags & IFF_OACTIVE)
d2632 1
a2632 1
				ifp->if_flags |= IFF_OACTIVE;
d2641 1
a2641 1
			ifp->if_flags |= IFF_OACTIVE;
d2660 1
a2660 1
			ifp->if_flags |= IFF_OACTIVE;
d2838 1
a2838 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2996 2
a2997 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.146
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.145 2015/10/25 12:48:46 mpi Exp $	*/
a106 1
#include <net/if_types.h>
@


1.145
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.144 2015/09/12 09:56:36 miod Exp $	*/
d2621 1
a2621 1
		IFQ_POLL(&ifp->if_snd, m_head);
d2631 1
a2631 1
			IFQ_DEQUEUE(&ifp->if_snd, m_head);
d2639 3
d2650 1
a2650 1
			IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.144
log
@ifmedia64 fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.143 2015/09/11 13:02:28 stsp Exp $	*/
a2916 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a2925 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.143
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.142 2015/08/30 02:12:23 deraadt Exp $	*/
d163 1
a163 1
void dc_setcfg(struct dc_softc *, int);
d1162 1
a1162 1
dc_setcfg(struct dc_softc *sc, int media)
@


1.142
log
@Track rom size, for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.141 2015/06/24 09:40:54 mpi Exp $	*/
d185 1
a185 1
void dc_apply_fixup(struct dc_softc *, int);
d1362 1
a1362 1
dc_apply_fixup(struct dc_softc *sc, int media)
@


1.141
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.140 2015/04/13 08:45:48 mpi Exp $	*/
d1488 2
a1489 4
	int size;

	size = 2 << bits;
	sc->dc_srom = malloc(size, M_DEVBUF, M_NOWAIT);
d1492 1
a1492 1
	dc_read_eeprom(sc, (caddr_t)sc->dc_srom, 0, (size / 2), 0);
d3111 1
a3111 1
		free(sc->dc_srom, M_DEVBUF, 0);
@


1.140
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.139 2015/03/14 03:38:47 jsg Exp $	*/
d134 1
a134 1
void dc_rxeof(struct dc_softc *);
d2068 1
a2068 1
void
d2075 1
a2075 1
	int i, offset, total_len = 0;
d2138 1
a2138 1
					return;
d2155 1
a2155 1
		ifp->if_ipackets++;
d2162 2
d2448 1
a2448 4
			int		curpkts;
			curpkts = ifp->if_ipackets;
			dc_rxeof(sc);
			if (curpkts == ifp->if_ipackets) {
d2470 1
a2470 4
			int		curpkts;
			curpkts = ifp->if_ipackets;
			dc_rxeof(sc);
			if (curpkts == ifp->if_ipackets) {
@


1.139
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.138 2015/03/13 15:57:43 jasper Exp $	*/
d2146 1
a2146 1
		m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN, ifp);
@


1.138
log
@convert to if_input()

tested by landry@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.137 2015/01/23 12:49:13 dlg Exp $	*/
a106 1
#include <net/if_dl.h>
@


1.137
log
@break after return is useless.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.136 2014/12/22 02:28:51 tedu Exp $	*/
d2075 1
a2146 1
		m->m_pkthdr.rcvif = ifp;
d2157 1
a2157 5
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
		ether_input_mbuf(ifp, m);
d2161 2
@


1.136
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.135 2014/11/18 22:53:56 brad Exp $	*/
a790 1
			break;
@


1.135
log
@dc_init() calls dc_stop() and dc_reset() so remove some redundant calls
to those functions before dc_init() within dc_watchdog() and dc_intr().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.134 2014/07/22 13:12:11 mpi Exp $	*/
a2936 1
#ifdef INET
a2938 1
#endif
@


1.134
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.133 2014/07/12 18:48:17 tedu Exp $	*/
d2484 1
a2484 2
		if (status & DC_ISR_BUS_ERR) {
			dc_reset(sc);
a2485 1
		}
a2986 2
	dc_stop(sc, 0);
	dc_reset(sc);
@


1.133
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.132 2014/04/18 14:56:59 henning Exp $	*/
a109 1
#ifdef INET
a110 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a111 1
#endif
@


1.132
log
@reaching into altq unconditionally (and w/o ifdef ALTQ) is bad, mmkay?
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.130 2013/12/06 21:03:03 deraadt Exp $	*/
d3131 1
a3131 1
		free(sc->dc_srom, M_DEVBUF);
@


1.131
log
@The few network drivers that called their children's (ie. mii PHY
drivers) activate functions at DVACT_RESUME time do not need to do
so, since their PHYs are repaired by IFF_UP.
@
text
@a2567 4
	else if ((sc->dc_flags & DC_TX_USE_TX_INTR) &&
		 TBR_IS_ENABLED(&sc->sc_arpcom.ac_if.if_snd))
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |=
		    htole32(DC_TXCTL_FINT);
@


1.130
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.129 2013/12/02 23:40:41 brad Exp $	*/
a3112 1
		rv = config_activate_children(self, act);
@


1.129
log
@Rewrite receive filter handling and ioctl bits. Fixes not being able to
bring the interface out of all multicast mode once a range of multicast
addresses has been found and missing multicast range checking for some
of the dc(4) variants.

Tested with 21143 (represents most of the dc(4) variants and boards) and
ADMtek based adapters. Untested with ASIX and Xircom based adapters.
Putting it in to move forward. I don't expect any issues with the
ASIX/Xircom adapters with the changes as is.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.128 2013/11/20 08:36:36 mpi Exp $	*/
a3106 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d3116 3
@


1.128
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

Tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.127 2013/08/21 05:21:43 dlg Exp $	*/
a889 2
	struct dc_desc *sframe;
	u_int32_t h, *sp;
d891 1
d894 2
a895 1
	struct ifnet *ifp;
a897 2
	ifp = &sc->sc_arpcom.ac_if;

d913 2
a914 5
	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
	else
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
d916 1
a916 1
	if (ac->ac_multirangecnt > 0)
d918 5
a922 6

	if (ifp->if_flags & IFF_ALLMULTI)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);
	else {
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);

d926 1
d928 1
d933 5
a937 4
	if (ifp->if_flags & IFF_BROADCAST) {
		h = dc_crc_le(sc, (caddr_t)&etherbroadcastaddr);
		sp[h >> 4] |= htole32(1 << (h & 0xF));
	}
a971 1
	struct ifnet *ifp;
d973 1
d976 1
a977 1
	u_int32_t hashes[2] = { 0, 0 };
d979 27
a1005 1
	ifp = &sc->sc_arpcom.ac_if;
a1011 39
	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
	else
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);
	else
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);

	/* first, zot all the existing hash bits */
	CSR_WRITE_4(sc, DC_AL_MAR0, 0);
	CSR_WRITE_4(sc, DC_AL_MAR1, 0);

	/*
	 * If we're already in promisc or allmulti mode, we
	 * don't have to bother programming the multicast filter.
	 */
	if (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))
		return;

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (DC_IS_CENTAUR(sc))
			h = dc_crc_le(sc, enm->enm_addrlo);
		else
			h = dc_crc_be(enm->enm_addrlo);
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h - 32));
		ETHER_NEXT_MULTI(step, enm);
	}

a1018 1
	struct ifnet *ifp;
d1020 1
d1023 1
a1024 1
	u_int32_t hashes[2] = { 0, 0 };
d1026 30
a1055 1
	ifp = &sc->sc_arpcom.ac_if;
a1064 44
	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
	else
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);

	if (ifp->if_flags & IFF_ALLMULTI)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);
	else
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);

	/*
	 * The ASIX chip has a special bit to enable reception
	 * of broadcast frames.
	 */
	if (ifp->if_flags & IFF_BROADCAST)
		DC_SETBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);
	else
		DC_CLRBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);

	/* first, zot all the existing hash bits */
	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);
	CSR_WRITE_4(sc, DC_AX_FILTDATA, 0);
	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);
	CSR_WRITE_4(sc, DC_AX_FILTDATA, 0);

	/*
	 * If we're already in promisc or allmulti mode, we
	 * don't have to bother programming the multicast filter.
	 */
	if (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))
		return;

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = dc_crc_be(enm->enm_addrlo);
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h - 32));
		ETHER_NEXT_MULTI(step, enm);
	}

a1073 1
	struct dc_desc *sframe;
d1075 1
d1078 1
a1079 1
	struct ifnet *ifp;
a1081 1
	ifp = &sc->sc_arpcom.ac_if;
d1099 14
a1112 5
	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
	else
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);
d1114 1
a1114 4
	if (ifp->if_flags & IFF_ALLMULTI)
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);
	else
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);
d1116 2
a1117 6
	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = dc_crc_le(sc, enm->enm_addrlo);
		sp[h >> 4] |= htole32(1 << (h & 0xF));
		ETHER_NEXT_MULTI(step, enm);
d1120 5
a1124 4
	if (ifp->if_flags & IFF_BROADCAST) {
		h = dc_crc_le(sc, (caddr_t)&etherbroadcastaddr);
		sp[h >> 4] |= htole32(1 << (h & 0xF));
	}
a2937 1
	struct mii_data		*mii;
d2954 5
a2958 9
			if (ifp->if_flags & IFF_RUNNING &&
			    (ifp->if_flags ^ sc->dc_if_flags) &
			     IFF_PROMISC) {
				dc_setfilt(sc);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING)) {
					sc->dc_txthresh = 0;
					dc_init(sc);
				}
a2963 1
		sc->dc_if_flags = ifp->if_flags;
d2967 1
a2967 2
		mii = &sc->sc_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
@


1.127
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.126 2013/08/07 01:06:29 bluhm Exp $	*/
d921 3
a923 1
allmulti:
a930 6
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
			    ETHER_ADDR_LEN)) {
				ifp->if_flags |= IFF_ALLMULTI;
				goto allmulti;
			}

d995 3
a997 1
allmulti:
a1016 5
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}

@


1.126
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.125 2012/11/29 21:10:31 brad Exp $	*/
d2188 1
a2188 2
		m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN,
		    ifp, NULL);
@


1.125
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.124 2011/07/07 20:42:56 henning Exp $	*/
a112 1
#include <netinet/in_var.h>
@


1.124
log
@use IF_LEN/IFQ_LEN to access and ifqueue's length field. ryan ok
with this nothing in the tree fiddles if ifqueue internals any more, of
course except if.c and if.h (and some altq)
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.123 2011/06/21 16:52:45 tedu Exp $	*/
a1733 1
	ifp->if_baudrate = 10000000;
@


1.123
log
@remove some unnecessary casts.  ok blambert deraadt kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.122 2011/03/05 13:39:26 kettenis Exp $	*/
d2671 1
a2671 1
	if (!sc->dc_link && ifp->if_snd.ifq_len < 10)
@


1.122
log
@Wait until the DMA engine is stopped before unmapping buffers and descriptors.
Fixes DMA errors seen on sparc64.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.121 2010/09/07 16:21:42 deraadt Exp $	*/
d752 1
a752 1
	bzero((char *)&frame, sizeof(frame));
d906 1
a906 1
	bzero((char *)sp, DC_SFRAME_LEN);
d1129 1
a1129 1
	bzero((char *)sp, DC_SFRAME_LEN);
d1937 1
a1937 1
		bzero((char *)mtod(m_new, char *), m_new->m_len);
d3115 1
a3115 2
	bzero((char *)&sc->dc_ldata->dc_rx_list,
		sizeof(sc->dc_ldata->dc_rx_list));
d3138 1
a3138 2
	bzero((char *)&sc->dc_ldata->dc_tx_list,
		sizeof(sc->dc_ldata->dc_tx_list));
@


1.121
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.120 2010/09/06 15:59:03 deraadt Exp $	*/
d3059 1
d3071 22
@


1.120
log
@initialize rv to 0 in the activate function
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.119 2010/08/31 17:13:46 deraadt Exp $	*/
a132 1
void dc_powerhook(int, void *);
a1815 2
	sc->sc_pwrhook = powerhook_establish(dc_powerhook, sc);

a3148 6
void
dc_powerhook(int why, void *arg)
{
	dc_activate(arg, why);
}

a3179 4

	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);

@


1.119
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.118 2010/08/30 23:25:15 deraadt Exp $	*/
d3132 1
a3132 1
	int rv;
@


1.118
log
@activate functions, when they do not add value, should return the result of config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.117 2010/08/27 19:54:02 deraadt Exp $	*/
d3135 3
d3149 1
a3149 1
	return rv;
@


1.117
log
@Move the dc_pci_activate function to dc.c, and mangle it up with some of
the gunk in dc_powerhook.  Then make dc_powerhook just call it
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.116 2010/08/05 07:57:04 deraadt Exp $	*/
d3132 1
d3138 1
a3138 1
		config_activate_children(self, act);
d3141 1
a3141 1
		config_activate_children(self, act);
d3146 1
a3146 1
	return (0);
@


1.116
log
@ca_activate function for suspend/resume; tested by mlarkin on a
Davicom DM9102.  (bit of noise on suspend or resume, but that can be
dealt with later)
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.115 2010/07/02 15:47:54 blambert Exp $	*/
d133 1
a133 1
void dc_power(int, void *);
d1817 1
a1817 1
	sc->sc_pwrhook = powerhook_establish(dc_power, sc);
d3127 2
a3128 2
void
dc_power(int why, void *arg)
d3130 2
a3131 3
	struct dc_softc *sc = arg;
	struct ifnet *ifp;
	int s;
d3133 8
a3140 5
	s = splnet();
	if (why != PWR_RESUME)
		dc_stop(sc, 0);
	else {
		ifp = &sc->sc_arpcom.ac_if;
d3143 1
d3145 7
a3151 1
	splx(s);
@


1.115
log
@timeout_add -> timeout_add_msec

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.114 2010/05/19 15:27:35 oga Exp $	*/
a146 2
void dc_init(void *);
void dc_stop(struct dc_softc *, int);
@


1.114
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.113 2009/10/15 17:54:54 deraadt Exp $	*/
d2408 1
a2408 1
		timeout_add(&sc->dc_tick_tmo, hz / 10);
d2910 1
a2910 1
			timeout_add(&sc->dc_tick_tmo, hz / 10);
@


1.113
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.112 2009/08/10 20:29:54 deraadt Exp $	*/
d1675 1
a1675 1
	    BUS_DMA_NOWAIT) != 0) {
a1696 1
	bzero(sc->dc_ldata, sizeof(struct dc_list_data));
@


1.112
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.111 2009/06/26 19:11:17 deraadt Exp $	*/
d148 1
a148 1
void dc_stop(struct dc_softc *);
d2468 1
a2468 1
	u_int32_t status;
d2475 2
a2476 1
	if ((CSR_READ_4(sc, DC_ISR) & DC_INTRS) == 0)
d2478 2
d2484 1
a2484 1
			dc_stop(sc);
d2756 1
a2756 1
	dc_stop(sc);
d2840 1
a2840 1
		dc_stop(sc);
d3012 1
a3012 1
				dc_stop(sc);
d3049 1
a3049 1
	dc_stop(sc);
d3062 1
a3062 1
dc_stop(struct dc_softc *sc)
d3074 7
a3080 5
	DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));
	CSR_WRITE_4(sc, DC_IMR, 0x00000000);
	CSR_WRITE_4(sc, DC_TXADDR, 0x00000000);
	CSR_WRITE_4(sc, DC_RXADDR, 0x00000000);
	sc->dc_link = 0;
d3139 1
a3139 1
		dc_stop(sc);
d3152 3
d3162 14
a3175 1
	timeout_del(&sc->dc_tick_tmo);
@


1.111
log
@If we are going to move to the eeprom-based MAC address finding instead of
CIS-based... some newer devices have the MAC address at offset 8 instead of
offset 3.  But we can tell by the first three octets, Intel says.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.110 2009/06/26 16:58:46 deraadt Exp $	*/
a132 1
void dc_shutdown(void *);
a1819 1
	sc->sc_dhook = shutdownhook_establish(dc_shutdown, sc);
a3124 12
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
dc_shutdown(void *v)
{
	struct dc_softc *sc = (struct dc_softc *)v;

	dc_stop(sc);
}

a3158 2
	if (sc->sc_dhook != NULL)
		shutdownhook_disestablish(sc->sc_dhook);
@


1.110
log
@Using information gleamed from the FreeBSD driver, change the MAC address
reading to use the eeprom instead of CIS, and then the Xircom Cardbus cards
can work in the expresscard adaptor, as pci devices.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.109 2009/06/02 15:39:35 jsg Exp $	*/
d1654 11
@


1.109
log
@make dc at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.108 2009/01/11 16:54:59 blambert Exp $	*/
d1654 1
@


1.108
log
@Actual final round of timeout_add(to, n * hz) -> timeout_add_sec(to, n)
conversions.

ok kettenis@@
ok krw@@ (possibly for the second time :)
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.107 2008/11/28 02:44:17 brad Exp $	*/
d3143 24
@


1.107
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.106 2008/10/15 19:12:19 blambert Exp $	*/
d2401 1
a2401 1
		timeout_add(&sc->dc_tick_tmo, hz);
@


1.106
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.105 2008/10/14 18:01:53 naddy Exp $	*/
a3002 23
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				dc_setfilt(sc);
			error = 0;
		}
		break;
d3014 6
@


1.105
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.104 2008/10/02 20:21:13 brad Exp $	*/
d2900 1
a2900 1
			timeout_add(&sc->dc_tick_tmo, hz);
@


1.104
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.103 2008/09/12 05:44:52 brad Exp $	*/
d2186 2
a2187 2
		m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
		    total_len + ETHER_ALIGN, 0, ifp, NULL);
a2193 1
		m_adj(m0, ETHER_ALIGN);
@


1.103
log
@Some fixes for dc_txeof()..
- Don't reload the watchdog timer in case there are still unhandled
  descriptors.
- Don't clear IFF_OACTIVE unless there are at least 6 free TX
  descriptors. The function dc_encap() will bail if there are
  only 5 or fewer free TX descriptors, causing dc_start() to
  abort so it makes no sense to pretend we could process mbufs
  again when in fact we can't.
- Always assign idx to sc->dc_cdata.dc_tx_cons; it doesn't make
  much sense to exclude the idx == sc->dc_cdata.dc_tx_cons case.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.102 2008/09/11 06:49:14 brad Exp $	*/
a2975 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}

d3037 1
a3037 2
		error = EINVAL;
		break;
a3040 1

@


1.102
log
@ANSI function declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.101 2008/09/11 03:21:03 brad Exp $	*/
d2320 1
d2322 1
a2322 3
	if (idx != sc->dc_cdata.dc_tx_cons) {
		/* some buffers have been freed */
		sc->dc_cdata.dc_tx_cons = idx;
d2324 2
a2325 2
	}
	ifp->if_timer = (sc->dc_cdata.dc_tx_cnt == 0) ? 0 : 5;
@


1.101
log
@For chips with a broken DC_ISR_RX_STATE which never signals
stopped nor the waiting state and also no other means to check
whether the receiver is idle, we have no choice but to call
mii_tick unconditionally even in the case of the DC_REDUCED_MII_POLL
handling as far as the RX side is concerned. This isn't necessarily
worse than checking whether RX is idle though because unlike as
with TX we're racing with the hardware, which might receive packets
any time while we poll the MII, anyway. Fixes the use of trunk(4)
with the affected interfaces.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.100 2008/09/03 19:29:48 brad Exp $	*/
d207 1
a207 2
dc_delay(sc)
	struct dc_softc *sc;
d216 1
a216 2
dc_eeprom_width(sc)
	struct dc_softc *sc;
d280 1
a280 2
dc_eeprom_idle(sc)
	struct dc_softc *sc;
d311 1
a311 3
dc_eeprom_putbyte(sc, addr)
	struct dc_softc *sc;
	int addr;
d352 1
a352 4
dc_eeprom_getword_pnic(sc, addr, dest)
	struct dc_softc *sc;
	int addr;
	u_int16_t *dest;
d393 1
a393 4
dc_eeprom_getword(sc, addr, dest)
	struct dc_softc *sc;
	int addr;
	u_int16_t *dest;
d438 3
a440 4
void dc_read_eeprom(sc, dest, off, cnt, swap)
	struct dc_softc *sc;
	caddr_t dest;
	int off, cnt, swap;
d468 1
a468 3
dc_mii_writebit(sc, bit)
	struct dc_softc *sc;
	int bit;
d484 1
a484 2
dc_mii_readbit(sc)
	struct dc_softc *sc;
d499 1
a499 2
dc_mii_sync(sc)
	struct dc_softc *sc;
d513 1
a513 4
dc_mii_send(sc, bits, cnt)
	struct dc_softc *sc;
	u_int32_t bits;
	int cnt;
d525 1
a525 3
dc_mii_readreg(sc, frame)
	struct dc_softc *sc;
	struct dc_mii_frame *frame;
d595 1
a595 3
dc_mii_writereg(sc, frame)
	struct dc_softc *sc;
	struct dc_mii_frame *frame;
d629 1
a629 3
dc_miibus_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
d750 1
a750 3
dc_miibus_writereg(self, phy, reg, data)
	struct device *self;
	int phy, reg, data;
d821 1
a821 2
dc_miibus_statchg(self)
	struct device *self;
d846 1
a846 3
dc_crc_le(sc, addr)
	struct dc_softc *sc;
	caddr_t addr;
d893 1
a893 2
dc_setfilt_21143(sc)
	struct dc_softc *sc;
d982 1
a982 2
dc_setfilt_admtek(sc)
	struct dc_softc *sc;
d1045 1
a1045 2
dc_setfilt_asix(sc)
	struct dc_softc *sc;
d1115 1
a1115 2
dc_setfilt_xircom(sc)
	struct dc_softc *sc;
d1187 1
a1187 2
dc_setfilt(sc)
	struct dc_softc *sc;
d1209 1
a1209 3
dc_setcfg(sc, media)
	struct dc_softc *sc;
	int media;
d1363 1
a1363 2
dc_reset(sc)
	struct dc_softc *sc;
d1409 1
a1409 3
dc_apply_fixup(sc, media)
	struct dc_softc *sc;
	int media;
d1439 1
a1439 3
dc_decode_leaf_sia(sc, l)
	struct dc_softc *sc;
	struct dc_eblock_sia *l;
d1485 1
a1485 3
dc_decode_leaf_sym(sc, l)
	struct dc_softc *sc;
	struct dc_eblock_sym *l;
d1508 1
a1508 3
dc_decode_leaf_mii(sc, l)
	struct dc_softc *sc;
	struct dc_eblock_mii *l;
d1533 1
a1533 3
dc_read_srom(sc, bits)
	struct dc_softc *sc;
	int bits;
d1545 1
a1545 2
dc_parse_21143_srom(sc)
	struct dc_softc *sc;
d1606 1
a1606 2
dc_attach(sc)
	struct dc_softc *sc;
d1820 1
a1820 2
dc_list_tx_init(sc)
	struct dc_softc *sc;
d1855 1
a1855 2
dc_list_rx_init(sc)
	struct dc_softc *sc;
d1887 1
a1887 4
dc_newbuf(sc, i, m)
	struct dc_softc *sc;
	int i;
	struct mbuf *m;
d2008 1
a2008 3
dc_pnic_rx_bug_war(sc, idx)
	struct dc_softc *sc;
	int idx;
d2074 1
a2074 2
dc_rx_resync(sc)
	struct dc_softc *sc;
d2109 1
a2109 2
dc_rxeof(sc)
	struct dc_softc *sc;
d2214 1
a2214 2
dc_txeof(sc)
	struct dc_softc *sc;
d2330 1
a2330 2
dc_tick(xsc)
	void *xsc;
d2412 1
a2412 2
dc_tx_underrun(sc)
	struct dc_softc	*sc;
d2456 1
a2456 2
dc_intr(arg)
	void *arg;
d2542 1
a2542 4
dc_encap(sc, m_head, txidx)
	struct dc_softc *sc;
	struct mbuf *m_head;
	u_int32_t *txidx;
d2627 1
a2627 3
dc_coal(sc, m_head)
	struct dc_softc *sc;
	struct mbuf **m_head;
d2658 1
a2658 2
dc_start(ifp)
	struct ifnet *ifp;
d2731 1
a2731 2
dc_init(xsc)
	void *xsc;
d2920 1
a2920 2
dc_ifmedia_upd(ifp)
	struct ifnet *ifp;
d2945 1
a2945 3
dc_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d2967 1
a2967 4
dc_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
d3053 1
a3053 2
dc_watchdog(ifp)
	struct ifnet *ifp;
d3075 1
a3075 2
dc_stop(sc)
	struct dc_softc *sc;
d3146 1
a3146 2
dc_shutdown(v)
	void *v;
d3154 1
a3154 3
dc_power(why, arg)
	int why;
	void *arg;
@


1.100
log
@In dc_setcfg() suppress printing a warning when forcing the receiver
and transmitter to idle state times out for chips where the status
bits in question never change (observed in detail with DM9102A) and
therefore the warning would highly likely be a false positive.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.99 2007/11/26 17:45:14 brad Exp $	*/
d2420 6
a2425 2
			r = CSR_READ_4(sc, DC_ISR);
			if ((r & DC_ISR_RX_STATE) == DC_RXSTATE_WAIT &&
@


1.99
log
@print the comma before the MAC address string in dc_attach() instead of the
PCI front end attach function. This corrects the dmesg output for CardBus
adapters and ensures proper dmesg output if an error occurs in dc_attach().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.98 2007/10/01 04:03:51 krw Exp $	*/
d1267 10
a1276 3
		if (i == DC_TIMEOUT)
			printf("%s: failed to force tx and "
			    "rx to idle state\n", sc->sc_dev.dv_xname);
@


1.98
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.97 2007/05/08 00:04:47 deraadt Exp $	*/
d1762 1
a1762 1
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
@


1.97
log
@dc_detach() is only used by cardbus code, so move it there; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.96 2006/08/10 20:52:54 brad Exp $	*/
d1478 1
a1478 1
	m = malloc(sizeof(struct dc_mediainfo), M_DEVBUF, M_NOWAIT);
a1480 1
	bzero(m, sizeof(struct dc_mediainfo));
d1526 1
a1526 1
	m = malloc(sizeof(struct dc_mediainfo), M_DEVBUF, M_NOWAIT);
a1528 1
	bzero(m, sizeof(struct dc_mediainfo));
d1552 1
a1552 1
	m = malloc(sizeof(struct dc_mediainfo), M_DEVBUF, M_NOWAIT);
a1554 1
	bzero(m, sizeof(struct dc_mediainfo));
@


1.96
log
@- eliminate re-initialization's when adding IP addresses.
- simplify ioctl handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.95 2006/05/22 20:35:12 krw Exp $	*/
a1859 25
}

int
dc_detach(sc)
	struct dc_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	if (sc->dc_srom)
		free(sc->dc_srom, M_DEVBUF);

	timeout_del(&sc->dc_tick_tmo);

	ether_ifdetach(ifp);
	if_detach(ifp);

	if (sc->sc_dhook != NULL)
		shutdownhook_disestablish(sc->sc_dhook);
	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);

	return (0);
@


1.95
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.94 2006/05/07 03:56:25 brad Exp $	*/
d3078 1
a3078 2
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
d3080 2
d3083 1
a3083 5
			break;
		default:
			dc_init(sc);
			break;
		}
d3088 2
a3089 2
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->dc_if_flags & IFF_PROMISC)) {
d3091 5
a3095 7
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->dc_if_flags & IFF_PROMISC) {
				dc_setfilt(sc);
			} else if (!(ifp->if_flags & IFF_RUNNING)) {
				sc->dc_txthresh = 0;
				dc_init(sc);
a3101 1
		error = 0;
@


1.94
log
@- Return if there is nothing to do in the interrupt handler.
- Check for IFF_RUNNING in the interrupt loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.93 2006/04/23 19:44:31 kettenis Exp $	*/
d1879 4
a1882 2
	shutdownhook_disestablish(sc->sc_dhook);
	powerhook_disestablish(sc->sc_pwrhook);
@


1.93
log
@Make code path for ADMTek variant endian-safe; fixes dc(4) on macppc.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.92 2006/03/25 22:41:42 djm Exp $	*/
d2545 3
d2558 3
a2560 2
	while(((status = CSR_READ_4(sc, DC_ISR)) & DC_INTRS) &&
	    status != 0xFFFFFFFF) {
@


1.92
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.91 2006/01/28 10:08:38 brad Exp $	*/
d1026 3
a1028 2
	CSR_WRITE_4(sc, DC_AL_PAR0, *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[0]));
	CSR_WRITE_4(sc, DC_AL_PAR1, *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[4]));
d1656 1
d1686 8
a1693 4
		*(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[0]) =
			CSR_READ_4(sc, DC_AL_PAR0);
		*(u_int16_t *)(&sc->sc_arpcom.ac_enaddr[4]) =
			CSR_READ_4(sc, DC_AL_PAR1);
@


1.91
log
@remove 2 printf's from dc_coal() too.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.90 2006/01/28 01:48:21 brad Exp $	*/
d2272 1
a2272 1
			bpf_mtap(ifp->if_bpf, m);
d2783 1
a2783 1
			bpf_mtap(ifp->if_bpf, m_head);
@


1.90
log
@remove printf's from dc_newbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.89 2005/11/07 03:20:00 brad Exp $	*/
d2706 1
a2706 2
	if (m_new == NULL) {
		printf("%s: no memory for tx list", sc->sc_dev.dv_xname);
a2707 1
	}
a2711 2
			printf("%s: no memory for tx list",
			    sc->sc_dev.dv_xname);
@


1.89
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.88 2005/06/25 23:27:43 brad Exp $	*/
d1965 1
a1965 3
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->sc_dev.dv_xname);
a1966 1
		}
a1969 2
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->sc_dev.dv_xname);
a1975 1
			printf("%s: rx load failed\n", sc->sc_dev.dv_xname);
d1983 5
@


1.88
log
@re-add ASIX check lost in rev 1.77
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.87 2005/06/23 15:41:01 brad Exp $	*/
d550 1
a550 1
	s = splimp();
d622 1
a622 1
	s = splimp();
d2413 1
a2413 1
	s = splimp();
d2818 1
a2818 1
	s = splimp();
d3061 1
a3061 1
	s = splimp();
d3257 1
a3257 1
	s = splimp();
@


1.87
log
@clear IFF_RUNNING & IFF_OACTIVE in dc_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.86 2005/05/22 19:29:55 martin Exp $	*/
d2436 1
a2436 1
			    sc->dc_cdata.dc_tx_cnt == 0) {
@


1.86
log
@ALTQ cleanout

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.85 2005/05/22 01:10:23 brad Exp $	*/
d3179 2
a3232 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.85
log
@add power hook
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.84 2005/04/30 21:38:05 brad Exp $	*/
a2673 1
#ifdef ALTQ
a2677 1
#endif
a2760 1
#ifdef ALTQ
a2763 1
#endif
@


1.84
log
@try to drain send queue if we lose link during heavy transmit
activity instead of letting it sit and return 'no buffer available'
errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.83 2005/04/23 22:36:42 brad Exp $	*/
d134 1
d1850 1
d1874 1
d3250 20
@


1.83
log
@- always accept VLAN-sized frames
- support setting the MTU
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.82 2005/04/23 04:55:44 brad Exp $	*/
d2744 1
a2744 1
	if (!sc->dc_link)
@


1.82
log
@Fix newer Xircom CBE2-100 cards.

We have to enable the connection to the MII first.  Doing so fixes the
problem cards without breaking the older, working cards.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.81 2005/03/31 15:38:15 brad Exp $	*/
a92 1
#include "vlan.h"
a1770 1
#if NVLAN > 0
a1771 1
#endif
d2230 2
a2231 1
	 	 * comes up in the ring.
d2233 16
a2248 21
		if (rxstat & DC_RXSTAT_RXERR
#if NVLAN > 0
		/*
		 * If VLANs are enabled, allow frames up to 4 bytes
		 * longer than the MTU. This should really check if
		 * the giant packet has a vlan tag
		 */
		 && ((rxstat & (DC_RXSTAT_GIANT|DC_RXSTAT_LASTFRAG)) == 0
		 && total_len <= ifp->if_mtu + 4) 
#endif
		    ) {
			ifp->if_ierrors++;
			if (rxstat & DC_RXSTAT_COLLSEEN)
				ifp->if_collisions++;
			dc_newbuf(sc, i, m);
			if (rxstat & DC_RXSTAT_CRCERR) {
				DC_INC(i, DC_RX_LIST_CNT);
				continue;
			} else {
				dc_init(sc);
				return;
d3102 7
@


1.81
log
@- add support for reading Xircom's EEPROM
- sync dc_mii_readreg()

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.80 2005/01/15 05:24:11 brad Exp $	*/
d1788 14
a1836 13

	if (DC_IS_XIRCOM(sc)) {
		/*
		 * setup General Purpose Port mode and data so the tulip
		 * can talk to the MII.
		 */
		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_WRITE_EN | DC_SIAGP_INT1_EN |
		    DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);
		DELAY(10);
		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_INT1_EN |
		    DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);
		DELAY(10);
	}
@


1.80
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.79 2005/01/14 15:04:51 brad Exp $	*/
d160 1
d379 20
d460 2
d594 4
a597 2
		if (dc_mii_readbit(sc))
			frame->mii_data |= i;
d1593 1
a1593 1
	int i, loff;
a1594 1
	int have_mii;
a1688 2
	case DC_TYPE_XIRCOM:
		break;
d1693 2
a2539 3

	if ( (CSR_READ_4(sc, DC_ISR) & DC_INTRS) == 0)
		return (0);
@


1.79
log
@rev 1.63

Avoid an unnecessary copy of a packet if it is already in a single mbuf.
Introduce an additional device flag for those NICs which require the
transmit buffers to be aligned to 32-bit boundaries.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.78 2005/01/08 06:02:59 brad Exp $	*/
d3099 2
a3100 1
			dc_setfilt(sc);
@


1.78
log
@rev 1.125

Don't read the MAC address from a copy of the EEPROM in the softc
that has been recorded earlier and overwrite it again later by
reading it directly from the EEPROM again.

Read the MAC address from the PAR0/PAR1 registers instead, which
are autoloaded on reboot.

From FreeBSD

Thanks to David Snyder <dasnyderx at yahoo dot com> for testing on
a AN983 based card which used to come up with a MAC address of
ff:ff:ff:ff:ff:ff.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.77 2004/12/17 02:26:27 brad Exp $	*/
d2742 3
a2744 1
		if (sc->dc_flags & DC_TX_COALESCE) {
@


1.77
log
@add missing braces.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.76 2004/12/02 02:28:35 brad Exp $	*/
d1660 4
a1663 2
		bcopy(&sc->dc_srom[DC_AL_EE_NODEADDR], &sc->sc_arpcom.ac_enaddr,
		    ETHER_ADDR_LEN);
@


1.76
log
@rev 1.126

Ignore CSR13, CSR14, CSR15 'Media Specific Data' registers
for 21143 based cards which use SIA mode.

This fixes 10mbit mode for ZNYX ZX346Q cards and other
21143 based cards.

rev 1.108

Only use a SIA/SYM media info block if no MII block is detected.
The submitter of PR 32118 told me that this patch also fixes autoselecting
for znyx 4 port cards (10baseT, 100baseTX did work already).

From FreeBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.75 2004/11/28 02:10:59 brad Exp $	*/
d2413 1
a2413 1
			    sc->dc_cdata.dc_tx_cnt == 0 && !DC_IS_ASIX(sc))
d2415 3
a2417 2
			if (!(mii->mii_media_status & IFM_ACTIVE))
				sc->dc_link = 0;
@


1.75
log
@rev 1.74

Fix if_timer logic to make sure that there is always a timeout
pending if there are packets queued for transmission.

From FreeBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.74 2004/11/16 14:26:21 brad Exp $	*/
d1456 2
a1457 1
	if (l->dc_sia_code == DC_SIA_CODE_10BT)
d1459 2
a1460 2

	if (l->dc_sia_code == DC_SIA_CODE_10BT_FDX)
d1462 2
a1463 2

	if (l->dc_sia_code == DC_SIA_CODE_10B2)
d1465 2
a1466 2

	if (l->dc_sia_code == DC_SIA_CODE_10B5)
d1468 4
d1473 14
a1486 2
	m->dc_gp_len = 2;
	m->dc_gp_ptr = (u_int8_t *)&l->dc_sia_gpio_ctl;
d1570 1
d1572 1
d1578 18
d1603 3
a1605 1
			dc_decode_leaf_sia(sc, (struct dc_eblock_sia *)hdr);
d1608 3
a1610 1
			dc_decode_leaf_sym(sc, (struct dc_eblock_sym *)hdr);
@


1.74
log
@if_dc.c rev 1.56

Do not call mii_pollstat() from within device tick routines; the status
information is updated by mii_tick().

dcphy.c rev 1.13

Work around an Intel 21143 chip bug.

Rev 1.56 of if_dc.c removed calls to mii_pollstat() from the dc_tick()
routine.  dc_tick() is called regularly to detect link up and link down
status, especially when autonegotiating.

The expectation was that mii_tick() (which is still called from dc_tick())
would update status information automatically in all cases where it would
be sensible to do so.

Unfortunately, with authentic 21143 chips this is not the case, and
the driver never successfully autonegotiates.  This is because (despite
what it says in the 21143 manual) the chip always claims that link is not
present while the autonegotiation enable bit is set.  Autonegotation takes
place and succeeds, but the driver tests the link bits before it switches
off the autonegotiation enable bit, and success is not recognised.

The simplest solution is to call dcphy_status() more often for MII_TICK
calls by dropping out of the switch statement instead of exiting when
we are autonegotiating and link appears to not be present.  When
autonegotiation succeeds, dcphy_status() will note the speed and fdx/hdx
state and turn off the autonegotiation enable bit.  The next call to
dcphy_status() will notice that link is present, and the dc driver code
will be notified.

Macronix chips also use this code, but implement link detection as
described in the manual, and hence don't need this patch.  However, tests
on a Macronix 98715AEC-C show that it does not adversely affect them.

From FreeBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.73 2004/10/29 01:10:43 brad Exp $	*/
a2231 3
	/* Clear the timeout timer. */
	ifp->if_timer = 0;

a2252 1
			sc->dc_cdata.dc_tx_cnt--;
d2269 1
d2331 3
a2333 2
	sc->dc_cdata.dc_tx_cons = idx;
	if (cur_tx != NULL)
d2335 2
@


1.73
log
@rev 1.78

Enable the automatic TX underrun recovery for the ADMtek chips.
This solves cvsup update on my laptop which aborts after a while
without this patch.

rev 1.79

Fix the support for the AN985/983 chips, which do not set the
RXSTATE to STOPPED, but to WAIT. This should fix hangs which
could only be solved by replugging the cable.

From FreeBSD

Thanks to C. Bensend <benny at bennyvision dot com> for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.72 2004/10/14 15:34:28 brad Exp $	*/
d2399 5
a2403 8
	if (!sc->dc_link) {
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
			sc->dc_link++;
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
				dc_start(ifp);
		}
@


1.72
log
@rev 1.47

Add a check in the interrupt service routine to return quickly in
case there is nothing to do. This happens normally when the card shares
the interrupt line with other devices.

This code saves a couple of microseconds per interrupt even on a
fast CPU. You normally would not care, except under heavy tinygram
traffic where you can have some 50-100.000 interrupts per second...

rev 1.51

Patch to allow TX underrun handling without issuing a complete
chip reset. Just temporarily turn off the transmitter instead.

From FreeBSD

ok mcbride@@
tested by mcbride@@, jaredy@@, marco@@, grange@@, <harding at motd dot ca>
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.71 2004/10/06 17:02:47 brad Exp $	*/
d1235 2
a1236 1
			    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)
d1768 7
@


1.71
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.70 2004/10/06 17:00:03 brad Exp $	*/
d145 1
a1232 1
			DELAY(10);
d1234 1
a1234 1
			if (isr & DC_ISR_TX_IDLE ||
d1237 1
a1242 1

d2409 48
d2467 4
d2510 2
a2511 17
		if (status & DC_ISR_TX_UNDERRUN) {
			u_int32_t		cfg;

			if (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc))
				dc_init(sc);
			cfg = CSR_READ_4(sc, DC_NETCFG);
			cfg &= ~DC_NETCFG_TX_THRESH;
			if (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {
				DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);
			} else if (sc->dc_flags & DC_TX_STORENFWD) {
			} else {
				sc->dc_txthresh += 0x4000;
				CSR_WRITE_4(sc, DC_NETCFG, cfg);
				DC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);
				DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);
			}
		}
d2801 1
a2801 1
		if (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {
d2838 1
a2838 1
	DC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);
@


1.70
log
@Enable round-robin arbitration between transmit and receive unit
in the 21143, instead of giving priority to the receive unit.
This gives a 10-15% performance improvement in the forwarding rate
under heavy load.

From FreeBSD

ok mcbride@@ nick@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.69 2004/09/28 16:58:56 brad Exp $	*/
d2421 1
a2421 1
	/* Supress unwanted interrupts */
@


1.69
log
@Use ETHER_MIN_LEN/ETHER_MAX_DIX_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.68 2004/09/23 17:45:16 brad Exp $	*/
d2733 5
@


1.68
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.67 2004/05/31 03:53:53 mcbride Exp $	*/
d1936 1
a1936 1
	c->dc_ctl = htole32(DC_RXCTL_RLINK | DC_RXLEN);
d2015 1
a2015 1
	bzero(ptr, DC_RXLEN * 5);
d2022 2
a2023 2
		bcopy(mtod(m, char *), ptr, DC_RXLEN);
		ptr += DC_RXLEN;
@


1.67
log
@multicast cleanups:
- get rid of hand rolled crc32 logic, use ether_crc32_{le,be}
- accept all multicast if a range is encountered
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.66 2004/04/15 08:34:48 mickey Exp $	*/
a1694 1
	ifp->if_mtu = ETHERMTU;
a1696 1
	ifp->if_output = ether_output;
@


1.66
log
@user bus_dmamap_load_mbuf and set rcvif on receive
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.65 2003/10/21 18:58:49 jmc Exp $	*/
a842 1
#define DC_POLY		0xEDB88320
d852 1
a852 1
	u_int32_t idx, bit, data, crc;
d855 1
a855 6
	crc = 0xFFFFFFFF; /* initial value */

	for (idx = 0; idx < 6; idx++) {
		for (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)
			crc = (crc >> 1) ^ (((crc ^ data) & 1) ? DC_POLY : 0);
	}
d883 2
a884 25
u_int32_t
dc_crc_be(addr)
	caddr_t addr;
{
	u_int32_t crc, carry;
	int i, j;
	u_int8_t c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/* return the filter bit position */
	return ((crc >> 26) & 0x0000003F);
}
d931 1
d934 1
a934 1
	else
d937 12
a948 5
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = dc_crc_le(sc, enm->enm_addrlo);
		sp[h >> 4] |= htole32(1 << (h & 0xF));
		ETHER_NEXT_MULTI(step, enm);
d1009 1
d1029 5
@


1.65
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.64 2003/09/29 18:53:58 mickey Exp $	*/
d1920 2
a1921 3
		if (bus_dmamap_load(sc->sc_dmat, sc->sc_rx_sparemap,
		    mtod(m_new, caddr_t), MCLBYTES, NULL,
		    BUS_DMA_NOWAIT) != 0) {
d2203 1
@


1.64
log
@add more dmamap_sync()s where appropriate modify loops to insure proper syncing; jason@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.63 2003/09/25 21:45:11 mickey Exp $	*/
d2112 1
a2112 1
	/* We've fallen behing the chip: catch it. */
@


1.63
log
@no need for a redundant check; from form@@ and jason ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.62 2003/08/28 12:32:07 mickey Exp $	*/
d2090 2
a2091 2
	int i, pos;
	struct dc_desc *cur_rx;
d2096 2
d2099 1
a2099 2
		    offsetof(struct dc_list_data, dc_rx_list[pos]),
		    sizeof(struct dc_desc),
d2102 2
a2103 2
		cur_rx = &sc->dc_ldata->dc_rx_list[pos];
		if (!(cur_rx->dc_status & htole32(DC_RXSTAT_OWN)))
d2129 1
a2129 1
	int i, total_len = 0;
d2135 2
a2136 3
	while(!(sc->dc_ldata->dc_rx_list[i].dc_status &
	    htole32(DC_RXSTAT_OWN))) {
		struct mbuf		*m0 = NULL;
d2138 1
d2140 1
a2140 2
		    offsetof(struct dc_list_data, dc_rx_list[i]),
		    sizeof(struct dc_desc),
d2145 3
d2151 4
a2203 4
		bus_dmamap_sync(sc->sc_dmat, sc->dc_cdata.dc_rx_chain[i].sd_map,
		    0, sc->dc_cdata.dc_rx_chain[i].sd_map->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);

a2215 1

d2237 1
a2237 1
	int idx;
d2252 1
d2254 1
a2254 2
		    offsetof(struct dc_list_data, dc_tx_list[idx]),
		    sizeof(struct dc_desc),
d2334 5
d2599 2
a2600 2
	    offsetof(struct dc_list_data, dc_tx_list[0]),
	    sizeof(struct dc_desc) * DC_TX_LIST_CNT,
d2830 7
a3126 1

d3129 4
@


1.62
log
@fix bzero size; from pechkin
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.61 2003/06/16 03:26:00 mickey Exp $	*/
a2444 1

a2445 4
		if ((status & DC_INTRS) == 0) {
			claimed = 0;
			break;
		}
@


1.61
log
@be more sane w/ byte swapping and leave the le archs at the same behaviour and give be archs a better chance at getting the correct mac address as tested on the mac and hppa where mac has an additional bug w/ the phy bit still remaining and hppa seems fine; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.60 2003/05/20 18:48:43 henning Exp $	*/
d2033 1
a2033 1
	bzero(ptr, sizeof(DC_RXLEN * 5));
@


1.60
log
@AN983 endian issue; from FreeBSD via PR 3263 with minor style fixes by me

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.59 2003/05/17 01:55:28 jason Exp $	*/
d442 1
a442 1
			*ptr = ntohs(word);
d444 1
a444 1
			*ptr = word;
@


1.59
log
@fix up the media handling for the intel based MACs.  Also hack around a
bug in the Momenco firmware on the Leopard-V, which now has one port
working.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.58 2003/04/29 21:44:06 jason Exp $	*/
d1049 4
a1052 1
		h = dc_crc_be(enm->enm_addrlo);
@


1.58
log
@grr... %s, not dc%s
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.57 2003/04/29 21:39:34 jason Exp $	*/
d1600 1
a1600 1
	int error = 0, mac_offset, tmp, i;
a1741 12
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		error = ENXIO;
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else if (sc->dc_type == DC_TYPE_21145) {
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	if (DC_IS_DAVICOM(sc) && sc->dc_revision >= DC_REVISION_DM9102A)
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_HPNA_1,0,NULL);

d1743 1
a1743 1
		if (error) {
d1748 2
a1751 1
			error = 0;
d1758 3
a1760 1
	if (error) {
d1762 7
a1768 3
		error = ENXIO;
		goto fail;
	}
@


1.57
log
@- remove last vestige of "old autoconf": dc_unit is dead, long live dv_xname
- remove a bunch of #if 0 stuff (most of which referred to dc_unit, grr)
- delay a bzero until necessary
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.56 2003/04/29 15:19:12 jason Exp $	*/
d720 1
a720 1
			printf("dc%s: phy_read: bad phy register %x\n",
d1909 1
a1909 1
			printf("dc%s: no memory for rx list "
d1916 1
a1916 1
			printf("dc%s: no memory for rx list "
d2623 1
a2623 1
		printf("dc%s: no memory for tx list", sc->sc_dev.dv_xname);
d2630 1
a2630 1
			printf("dc%s: no memory for tx list",
@


1.56
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.55 2003/02/25 17:29:09 tedu Exp $	*/
a633 2
	bzero((char *)&frame, sizeof(frame));

a650 1
	
d720 2
a721 2
			printf("dc%d: phy_read: bad phy register %x\n",
			    sc->dc_unit, reg);
d733 2
d798 2
a799 2
			printf("dc%d: phy_write: bad phy register %x\n",
			    sc->dc_unit, reg);
d1252 2
a1253 2
			printf("dc%d: failed to force tx and "
				"rx to idle state\n", sc->dc_unit);
d1399 1
a1399 1
		printf("dc%d: reset never completed!\n", sc->dc_unit);
d1770 1
a1770 1
		printf("dc%d: MII without any PHY!\n", sc->dc_unit);
d1909 2
a1910 2
			printf("dc%d: no memory for rx list "
			    "-- packet dropped!\n", sc->dc_unit);
d1916 2
a1917 2
			printf("dc%d: no memory for rx list "
			    "-- packet dropped!\n", sc->dc_unit);
a2477 3
#if 0
			printf("dc%d: TX underrun -- ", sc->dc_unit);
#endif
a2482 3
#if 0
				printf("using store and forward mode\n");
#endif
a2484 3
#if 0
				printf("resetting\n");
#endif
a2486 3
#if 0
				printf("increasing TX threshold\n");
#endif
d2623 1
a2623 1
		printf("dc%d: no memory for tx list", sc->dc_unit);
d2630 2
a2631 1
			printf("dc%d: no memory for tx list", sc->dc_unit);
d2817 2
a2818 2
		printf("dc%d: initialization failed: no "
		    "memory for rx buffers\n", sc->dc_unit);
d3048 1
a3048 1
	printf("dc%d: watchdog timeout\n", sc->dc_unit);
@


1.55
log
@remove redundant check.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.54 2003/01/31 14:22:38 deraadt Exp $	*/
d204 3
a206 2
void dc_delay(sc)
	struct dc_softc		*sc;
d208 1
a208 1
	int			idx;
d214 3
a216 2
void dc_eeprom_width(sc)
	struct dc_softc		*sc;
d279 3
a281 2
void dc_eeprom_idle(sc)
	struct dc_softc		*sc;
d283 1
a283 1
	register int		i;
a305 2

	return;
d311 4
a314 3
void dc_eeprom_putbyte(sc, addr)
	struct dc_softc		*sc;
	int			addr;
d316 1
a316 1
	register int		d, i;
a346 2

	return;
d354 5
a358 4
void dc_eeprom_getword_pnic(sc, addr, dest)
	struct dc_softc		*sc;
	int			addr;
	u_int16_t		*dest;
d360 2
a361 2
	register int		i;
	u_int32_t		r;
a372 2

	return;
d378 5
a382 4
void dc_eeprom_getword(sc, addr, dest)
	struct dc_softc		*sc;
	int			addr;
	u_int16_t		*dest;
d384 2
a385 2
	register int		i;
	u_int16_t		word = 0;
a421 2

	return;
d428 3
a430 5
	struct dc_softc		*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
	int			swap;
d432 2
a433 2
	int			i;
	u_int16_t		word = 0, *ptr;
a445 2

	return;
d455 4
a458 3
void dc_mii_writebit(sc, bit)
	struct dc_softc		*sc;
	int			bit;
a467 2

	return;
d473 3
a475 2
int dc_mii_readbit(sc)
	struct dc_softc		*sc;
d482 2
a483 3
		return(1);

	return(0);
d489 3
a491 2
void dc_mii_sync(sc)
	struct dc_softc		*sc;
d493 1
a493 1
	register int		i;
a498 2

	return;
d504 5
a508 4
void dc_mii_send(sc, bits, cnt)
	struct dc_softc		*sc;
	u_int32_t		bits;
	int			cnt;
d510 1
a510 1
	int			i;
d519 4
a522 4
int dc_mii_readreg(sc, frame)
	struct dc_softc		*sc;
	struct dc_mii_frame	*frame;
	
d524 1
a524 1
	int			i, ack, s;
d582 2
a583 2
		return(1);
	return(0);
d589 4
a592 4
int dc_mii_writereg(sc, frame)
	struct dc_softc		*sc;
	struct dc_mii_frame	*frame;
	
d594 1
a594 1
	int			s;
d622 1
a622 2

	return(0);
d625 4
a628 3
int dc_miibus_readreg(self, phy, reg)
	struct device		*self;
	int			phy, reg;
d630 3
a632 3
	struct dc_mii_frame	frame;
	struct dc_softc		*sc = (struct dc_softc *)self;
	int			i, rval, phy_reg;
d646 1
a646 1
		return(0);
d661 5
a665 5
			/*
			 * Fake something to make the probe
			 * code think there's a PHY here.
			 */
				return(BMSR_MEDIAMASK);
d669 2
a670 2
					return(PCI_VENDOR_LITEON);
				return(PCI_VENDOR_DEC);
d674 2
a675 2
					return(PCI_PRODUCT_LITEON_PNIC);
				return(PCI_PRODUCT_DEC_21142);
d678 1
a678 1
				return(0);
d682 1
a682 1
			return(0);
d693 1
a693 1
				return(rval == 0xFFFF ? 0 : rval);
d696 1
a696 1
		return(0);
d725 1
a725 1
			return(0);
d732 2
a733 2
			return(0);
		return(rval);
d746 1
a746 1
	return(frame.mii_data);
d749 4
a752 3
void dc_miibus_writereg(self, phy, reg, data)
	struct device		*self;
	int			phy, reg, data;
d754 3
a756 3
	struct dc_softc		*sc = (struct dc_softc *)self;
	struct dc_mii_frame	frame;
	int			i, phy_reg;
a819 2

	return;
d822 2
a823 1
void dc_miibus_statchg(self)
a841 2

	return;
d849 4
a852 3
u_int32_t dc_crc_le(sc, addr)
	struct dc_softc		*sc;
	caddr_t			addr;
d854 1
a854 1
	u_int32_t		idx, bit, data, crc;
d890 7
a896 6
u_int32_t dc_crc_be(addr)
	caddr_t			addr;
{
	u_int32_t		crc, carry;
	int			i, j;
	u_int8_t		c;
d913 1
a913 1
	return((crc >> 26) & 0x0000003F);
d926 3
a928 2
void dc_setfilt_21143(sc)
	struct dc_softc		*sc;
d930 7
a936 7
	struct dc_desc		*sframe;
	u_int32_t		h, *sp;
	struct arpcom		*ac = &sc->sc_arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	struct ifnet		*ifp;
	int			i;
a1005 2

	return;
d1008 3
a1010 2
void dc_setfilt_admtek(sc)
	struct dc_softc		*sc;
d1012 6
a1017 6
	struct ifnet		*ifp;
	struct arpcom		*ac = &sc->sc_arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	int			h = 0;
	u_int32_t		hashes[2] = { 0, 0 };
a1059 2

	return;
d1062 3
a1064 2
void dc_setfilt_asix(sc)
	struct dc_softc		*sc;
d1066 6
a1071 6
	struct ifnet		*ifp;
	struct arpcom		*ac = &sc->sc_arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	int			h = 0;
	u_int32_t		hashes[2] = { 0, 0 };
a1130 2

	return;
d1133 3
a1135 2
void dc_setfilt_xircom(sc)
	struct dc_softc		*sc;
d1137 7
a1143 7
	struct dc_desc		*sframe;
	struct arpcom		*ac = &sc->sc_arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int32_t		h, *sp;
	struct ifnet		*ifp;
	int			i;
a1203 2

	return;
d1206 3
a1208 2
void dc_setfilt(sc)
	struct dc_softc		*sc;
a1221 2

	return;
d1229 4
a1232 3
void dc_setcfg(sc, media)
	struct dc_softc		*sc;
	int			media;
d1234 2
a1235 2
	int			i, restart = 0;
	u_int32_t		isr;
a1375 2

	return;
d1378 3
a1380 2
void dc_reset(sc)
	struct dc_softc		*sc;
d1382 1
a1382 1
	register int		i;
a1422 2

	return;
d1425 9
a1433 8
void dc_apply_fixup(sc, media)
	struct dc_softc		*sc;
	int			media;
{
	struct dc_mediainfo	*m;
	u_int8_t		*p;
	int			i;
	u_int32_t		reg;
a1454 2

	return;
d1457 4
a1460 3
void dc_decode_leaf_sia(sc, l)
	struct dc_softc		*sc;
	struct dc_eblock_sia	*l;
d1462 1
a1462 1
	struct dc_mediainfo	*m;
a1486 2

	return;
d1489 4
a1492 3
void dc_decode_leaf_sym(sc, l)
	struct dc_softc		*sc;
	struct dc_eblock_sym	*l;
d1494 1
a1494 1
	struct dc_mediainfo	*m;
a1512 2

	return;
d1515 4
a1518 3
void dc_decode_leaf_mii(sc, l)
	struct dc_softc		*sc;
	struct dc_eblock_mii	*l;
d1520 2
a1521 2
	u_int8_t		*p;
	struct dc_mediainfo	*m;
a1540 2

	return;
d1543 4
a1546 3
void dc_read_srom(sc, bits)
	struct dc_softc		*sc;
	int			bits;
d1557 3
a1559 2
void dc_parse_21143_srom(sc)
	struct dc_softc		*sc;
d1561 4
a1564 4
	struct dc_leaf_hdr	*lhdr;
	struct dc_eblock_hdr	*hdr;
	int			i, loff;
	char			*ptr;
a1589 2

	return;
d1596 2
a1597 1
void dc_attach(sc)
d1600 2
a1601 2
	struct ifnet		*ifp;
	int			error = 0, mac_offset, tmp, i;
d1801 3
a1803 2
int dc_detach(sc)
	struct dc_softc		*sc;
d1826 3
a1828 2
int dc_list_tx_init(sc)
	struct dc_softc		*sc;
d1830 4
a1833 4
	struct dc_chain_data	*cd;
	struct dc_list_data	*ld;
	int			i;
	bus_addr_t		next;
d1853 1
a1853 1
	return(0);
d1862 3
a1864 2
int dc_list_rx_init(sc)
	struct dc_softc		*sc;
d1866 4
a1869 4
	struct dc_chain_data	*cd;
	struct dc_list_data	*ld;
	int			i;
	bus_addr_t		next;
d1876 1
a1876 1
			return(ENOBUFS);
d1889 1
a1889 1
	return(0);
d1895 9
a1903 8
int dc_newbuf(sc, i, m)
	struct dc_softc		*sc;
	int			i;
	struct mbuf		*m;
{
	struct mbuf		*m_new = NULL;
	struct dc_desc		*c;
	bus_dmamap_t		map;
d1912 1
a1912 1
			return(ENOBUFS);
d1920 1
a1920 1
			return(ENOBUFS);
d1965 1
a1965 1
	return(0);
d2021 4
a2024 3
void dc_pnic_rx_bug_war(sc, idx)
	struct dc_softc		*sc;
	int			idx;
a2075 2

	return;
d2089 3
a2091 2
int dc_rx_resync(sc)
	struct dc_softc		*sc;
d2093 2
a2094 2
	int			i, pos;
	struct dc_desc		*cur_rx;
d2112 1
a2112 1
		return(0);
d2117 1
a2117 1
	return(EAGAIN);
d2124 3
a2126 2
void dc_rxeof(sc)
	struct dc_softc		*sc;
d2128 5
a2132 5
	struct mbuf		*m;
	struct ifnet		*ifp;
	struct dc_desc		*cur_rx;
	int			i, total_len = 0;
	u_int32_t		rxstat;
a2224 2

	return;
d2232 3
a2234 2
void dc_txeof(sc)
	struct dc_softc		*sc;
d2236 3
a2238 3
	struct dc_desc		*cur_tx = NULL;
	struct ifnet		*ifp;
	int			idx;
a2341 2

	return;
d2344 3
a2346 2
void dc_tick(xsc)
	void			*xsc;
d2348 5
a2352 5
	struct dc_softc		*sc = (struct dc_softc *)xsc;
	struct mii_data		*mii;
	struct ifnet		*ifp;
	int			s;
	u_int32_t		r;
a2419 2

	return;
d2422 3
a2424 2
int dc_intr(arg)
	void			*arg;
d2426 4
a2429 4
	struct dc_softc		*sc;
	struct ifnet		*ifp;
	u_int32_t		status;
	int			claimed = 0;
d2438 1
a2438 1
		return claimed;
d2536 9
a2544 8
int dc_encap(sc, m_head, txidx)
	struct dc_softc		*sc;
	struct mbuf		*m_head;
	u_int32_t		*txidx;
{
	struct dc_desc		*f = NULL;
	int			frag, cur, cnt = 0, i;
	bus_dmamap_t		map;
d2564 1
a2564 1
				return(ENOBUFS);
d2570 1
a2570 1
			return(ENOBUFS);
d2618 1
a2618 1
	return(0);
d2626 4
a2629 3
int dc_coal(sc, m_head)
	struct dc_softc		*sc;
	struct mbuf		**m_head;
d2637 1
a2637 1
		return(ENOBUFS);
d2644 1
a2644 1
			return(ENOBUFS);
d2652 1
a2652 1
	return(0);
d2662 3
a2664 2
void dc_start(ifp)
	struct ifnet		*ifp;
d2666 3
a2668 3
	struct dc_softc		*sc;
	struct mbuf		*m_head = NULL;
	int			idx;
a2733 2

	return;
d2736 3
a2738 2
void dc_init(xsc)
	void			*xsc;
d2740 4
a2743 4
	struct dc_softc		*sc = xsc;
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
	struct mii_data		*mii;
	int			s;
a2908 2

	return;
d2914 3
a2916 2
int dc_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d2918 2
a2919 2
	struct dc_softc		*sc;
	struct mii_data		*mii;
d2934 1
a2934 1
	return(0);
d2940 4
a2943 3
void dc_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d2945 3
a2947 3
	struct dc_softc		*sc;
	struct mii_data		*mii;
	struct ifmedia		*ifm;
a2961 2

	return;
d2964 5
a2968 4
int dc_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d2980 1
a2980 1
		return error;
d3048 1
a3048 1
	return(error);
d3051 3
a3053 2
void dc_watchdog(ifp)
	struct ifnet		*ifp;
d3055 1
a3055 1
	struct dc_softc		*sc;
a3067 2

	return;
d3074 3
a3076 2
void dc_stop(sc)
	struct dc_softc		*sc;
d3078 2
a3079 2
	register int		i;
	struct ifnet		*ifp;
a3136 2

	return;
d3143 3
a3145 2
void dc_shutdown(v)
	void			*v;
d3147 1
a3147 1
	struct dc_softc		*sc = (struct dc_softc *)v;
a3154 1

@


1.54
log
@more quiet
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.53 2002/10/21 20:30:32 henning Exp $	*/
d577 2
a578 4
		if (!ack) {
			if (dc_mii_readbit(sc))
				frame->mii_data |= i;
		}
@


1.53
log
@ugly hack to make the 21145 work without manual media setting.

many many many thanks to nick@@, who booted no less then 8 kernels for me today
while hacking on that (and this includes going downstairs to the basement
and up again 8 times...)

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.52 2002/10/20 16:46:27 henning Exp $	*/
d2509 1
d2511 1
@


1.52
log
@add support for intel 21145
This chip is some strange abnormal 21143 variant. It really only works with
10 MBit/s halfduplex only and autonegotiation is totally broken in hardware.
Should also have a HomePNA phy, but we don't support that.
for now requires and explicit "media 10BaseT".
if anybody has such a chip please mail me.

nick@@ is the only one who has the hardware and did an incredible amount of
testing. Thanks for all the help, Nick!

some hints and ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.51 2002/07/05 13:45:21 aaron Exp $	*/
d1434 3
@


1.51
log
@Remove an unused #define (belongs only in the PCI attachment source file).
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.50 2002/06/09 03:14:18 todd Exp $	*/
d1640 1
d1763 2
@


1.50
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.49 2002/06/09 00:07:10 nordin Exp $	*/
a130 1
#define DC_USEIOSPACE
@


1.49
log
@Handle out of memory gracefully. ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.48 2002/04/18 19:11:18 jason Exp $	*/
d941 1
a941 1
	struct arpcom		*ac = &sc->arpcom;
d947 1
a947 1
	ifp = &sc->arpcom.ac_if;
d988 3
a990 3
	sp[39] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 0);
	sp[40] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 1);
	sp[41] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 2);
d1023 1
a1023 1
	struct arpcom		*ac = &sc->arpcom;
d1029 1
a1029 1
	ifp = &sc->arpcom.ac_if;
d1032 2
a1033 2
	CSR_WRITE_4(sc, DC_AL_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));
	CSR_WRITE_4(sc, DC_AL_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));
d1078 1
a1078 1
	struct arpcom		*ac = &sc->arpcom;
d1084 1
a1084 1
	ifp = &sc->arpcom.ac_if;
d1089 1
a1089 1
	    *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));
d1092 1
a1092 1
	    *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));
d1150 1
a1150 1
	struct arpcom		*ac = &sc->arpcom;
d1157 1
a1157 1
	ifp = &sc->arpcom.ac_if;
d1200 3
a1202 3
	sp[0] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 0);
	sp[1] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 1);
	sp[2] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 2);
d1633 1
a1633 1
		dc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
d1637 1
a1637 1
		dc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0, 3, 1);
d1642 1
a1642 1
		dc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,	
d1647 1
a1647 1
		bcopy(&sc->dc_srom[DC_AL_EE_NODEADDR], &sc->arpcom.ac_enaddr,
d1654 1
a1654 1
		    &sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);
d1657 1
a1657 1
		dc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
d1720 1
a1720 1
	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));
d1722 1
a1722 1
	ifp = &sc->arpcom.ac_if;
d1818 1
a1818 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d2143 1
a2143 1
	ifp = &sc->arpcom.ac_if;
d2250 1
a2250 1
	ifp = &sc->arpcom.ac_if;
d2367 1
a2367 1
	ifp = &sc->arpcom.ac_if;
d2444 1
a2444 1
	ifp = &sc->arpcom.ac_if;
d2611 1
a2611 1
		 TBR_IS_ENABLED(&sc->arpcom.ac_if.if_snd))
d2749 1
a2749 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d2987 1
a2987 1
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
d2998 1
a2998 1
			arp_ifinit(&sc->arpcom, ifa);
d3029 2
a3030 2
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
d3090 1
a3090 1
	ifp = &sc->arpcom.ac_if;
@


1.48
log
@add support for Conexant LANfinity RS7112; based on patch from Maurice Nonnekes <maurice@@amaze.nl> based on FreeBSD (only minor surgery necessary)
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.47 2002/03/14 01:26:54 millert Exp $	*/
d1479 2
d1512 2
d1540 2
d1569 2
@


1.47
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.46 2002/02/17 07:38:06 deraadt Exp $	*/
d658 9
d771 2
d1224 1
a1224 1
	    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc))
d1408 1
a1408 1
	    DC_IS_INTEL(sc)) {
d1644 4
d2289 1
a2289 1
		if (DC_IS_XIRCOM(sc)) {
d2293 5
a2297 1
			 * even when the carrier is there. wtf?! */
@


1.46
log
@drivers may not be noisy
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.45 2002/02/15 20:45:31 nordin Exp $	*/
d134 61
a194 61
int dc_intr		__P((void *));
void dc_shutdown	__P((void *));
struct dc_type *dc_devtype	__P((void *));
int dc_newbuf		__P((struct dc_softc *, int, struct mbuf *));
int dc_encap		__P((struct dc_softc *, struct mbuf *, u_int32_t *));
int dc_coal		__P((struct dc_softc *, struct mbuf **));

void dc_pnic_rx_bug_war	__P((struct dc_softc *, int));
int dc_rx_resync	__P((struct dc_softc *));
void dc_rxeof		__P((struct dc_softc *));
void dc_txeof		__P((struct dc_softc *));
void dc_tick		__P((void *));
void dc_start		__P((struct ifnet *));
int dc_ioctl		__P((struct ifnet *, u_long, caddr_t));
void dc_init		__P((void *));
void dc_stop		__P((struct dc_softc *));
void dc_watchdog		__P((struct ifnet *));
int dc_ifmedia_upd	__P((struct ifnet *));
void dc_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

void dc_delay		__P((struct dc_softc *));
void dc_eeprom_width	__P((struct dc_softc *));
void dc_eeprom_idle	__P((struct dc_softc *));
void dc_eeprom_putbyte	__P((struct dc_softc *, int));
void dc_eeprom_getword	__P((struct dc_softc *, int, u_int16_t *));
void dc_eeprom_getword_pnic	__P((struct dc_softc *, int, u_int16_t *));
void dc_read_eeprom	__P((struct dc_softc *, caddr_t, int, int, int));

void dc_mii_writebit	__P((struct dc_softc *, int));
int dc_mii_readbit	__P((struct dc_softc *));
void dc_mii_sync	__P((struct dc_softc *));
void dc_mii_send	__P((struct dc_softc *, u_int32_t, int));
int dc_mii_readreg	__P((struct dc_softc *, struct dc_mii_frame *));
int dc_mii_writereg	__P((struct dc_softc *, struct dc_mii_frame *));
int dc_miibus_readreg	__P((struct device *, int, int));
void dc_miibus_writereg	__P((struct device *, int, int, int));
void dc_miibus_statchg	__P((struct device *));

void dc_setcfg		__P((struct dc_softc *, int));
u_int32_t dc_crc_le	__P((struct dc_softc *, caddr_t));
u_int32_t dc_crc_be	__P((caddr_t));
void dc_setfilt_21143	__P((struct dc_softc *));
void dc_setfilt_asix	__P((struct dc_softc *));
void dc_setfilt_admtek	__P((struct dc_softc *));
void dc_setfilt_xircom	__P((struct dc_softc *));

void dc_setfilt		__P((struct dc_softc *));

void dc_reset		__P((struct dc_softc *));
int dc_list_rx_init	__P((struct dc_softc *));
int dc_list_tx_init	__P((struct dc_softc *));

void dc_read_srom		__P((struct dc_softc *, int));
void dc_parse_21143_srom	__P((struct dc_softc *));
void dc_decode_leaf_sia		__P((struct dc_softc *,
				     struct dc_eblock_sia *));
void dc_decode_leaf_mii		__P((struct dc_softc *,
				     struct dc_eblock_mii *));
void dc_decode_leaf_sym		__P((struct dc_softc *,
				     struct dc_eblock_sym *));
void dc_apply_fixup		__P((struct dc_softc *, int));
@


1.45
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.44 2001/12/13 17:43:02 nate Exp $	*/
d2464 1
d2466 1
d2472 1
d2474 1
d2480 1
d2482 1
@


1.44
log
@Fix old alpha bug recently triggered by conversion to busdma.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.43 2001/12/08 04:44:37 jason Exp $	*/
d2807 1
a2807 1
		(void)splx(s);
d2862 1
a2862 1
	(void)splx(s);
d3022 1
a3022 1
	(void)splx(s);
@


1.44.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.44 2001/12/13 17:43:02 nate Exp $	*/
d134 61
a194 61
int dc_intr(void *);
void dc_shutdown(void *);
struct dc_type *dc_devtype(void *);
int dc_newbuf(struct dc_softc *, int, struct mbuf *);
int dc_encap(struct dc_softc *, struct mbuf *, u_int32_t *);
int dc_coal(struct dc_softc *, struct mbuf **);

void dc_pnic_rx_bug_war(struct dc_softc *, int);
int dc_rx_resync(struct dc_softc *);
void dc_rxeof(struct dc_softc *);
void dc_txeof(struct dc_softc *);
void dc_tick(void *);
void dc_start(struct ifnet *);
int dc_ioctl(struct ifnet *, u_long, caddr_t);
void dc_init(void *);
void dc_stop(struct dc_softc *);
void dc_watchdog(struct ifnet *);
int dc_ifmedia_upd(struct ifnet *);
void dc_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void dc_delay(struct dc_softc *);
void dc_eeprom_width(struct dc_softc *);
void dc_eeprom_idle(struct dc_softc *);
void dc_eeprom_putbyte(struct dc_softc *, int);
void dc_eeprom_getword(struct dc_softc *, int, u_int16_t *);
void dc_eeprom_getword_pnic(struct dc_softc *, int, u_int16_t *);
void dc_read_eeprom(struct dc_softc *, caddr_t, int, int, int);

void dc_mii_writebit(struct dc_softc *, int);
int dc_mii_readbit(struct dc_softc *);
void dc_mii_sync(struct dc_softc *);
void dc_mii_send(struct dc_softc *, u_int32_t, int);
int dc_mii_readreg(struct dc_softc *, struct dc_mii_frame *);
int dc_mii_writereg(struct dc_softc *, struct dc_mii_frame *);
int dc_miibus_readreg(struct device *, int, int);
void dc_miibus_writereg(struct device *, int, int, int);
void dc_miibus_statchg(struct device *);

void dc_setcfg(struct dc_softc *, int);
u_int32_t dc_crc_le(struct dc_softc *, caddr_t);
u_int32_t dc_crc_be(caddr_t);
void dc_setfilt_21143(struct dc_softc *);
void dc_setfilt_asix(struct dc_softc *);
void dc_setfilt_admtek(struct dc_softc *);
void dc_setfilt_xircom(struct dc_softc *);

void dc_setfilt(struct dc_softc *);

void dc_reset(struct dc_softc *);
int dc_list_rx_init(struct dc_softc *);
int dc_list_tx_init(struct dc_softc *);

void dc_read_srom(struct dc_softc *, int);
void dc_parse_21143_srom(struct dc_softc *);
void dc_decode_leaf_sia(struct dc_softc *,
				     struct dc_eblock_sia *);
void dc_decode_leaf_mii(struct dc_softc *,
				     struct dc_eblock_mii *);
void dc_decode_leaf_sym(struct dc_softc *,
				     struct dc_eblock_sym *);
void dc_apply_fixup(struct dc_softc *, int);
a657 9
	/*
	 * Note: the ukphy probs of the RS7112 report a PHY at
	 * MII address 0 (possibly HomePNA?) and 1 (ethernet)
	 * so we only respond to correct one.
	 */
	
	if (DC_IS_CONEXANT(sc) && phy != DC_CONEXANT_PHYADDR)
		return (0);

a761 2
	if (DC_IS_CONEXANT(sc) && phy != DC_CONEXANT_PHYADDR)
		return;
d930 1
a930 1
	struct arpcom		*ac = &sc->sc_arpcom;
d936 1
a936 1
	ifp = &sc->sc_arpcom.ac_if;
d977 3
a979 3
	sp[39] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 0);
	sp[40] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 1);
	sp[41] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 2);
d1012 1
a1012 1
	struct arpcom		*ac = &sc->sc_arpcom;
d1018 1
a1018 1
	ifp = &sc->sc_arpcom.ac_if;
d1021 2
a1022 2
	CSR_WRITE_4(sc, DC_AL_PAR0, *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[0]));
	CSR_WRITE_4(sc, DC_AL_PAR1, *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[4]));
d1067 1
a1067 1
	struct arpcom		*ac = &sc->sc_arpcom;
d1073 1
a1073 1
	ifp = &sc->sc_arpcom.ac_if;
d1078 1
a1078 1
	    *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[0]));
d1081 1
a1081 1
	    *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[4]));
d1139 1
a1139 1
	struct arpcom		*ac = &sc->sc_arpcom;
d1146 1
a1146 1
	ifp = &sc->sc_arpcom.ac_if;
d1189 3
a1191 3
	sp[0] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 0);
	sp[1] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 1);
	sp[2] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 2);
d1213 1
a1213 1
	    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc) || DC_IS_CONEXANT(sc))
d1397 1
a1397 1
	    DC_IS_INTEL(sc) || DC_IS_CONEXANT(sc)) {
a1467 2
	if (m == NULL)
		return;
a1498 2
	if (m == NULL)
		return;
a1524 2
	if (m == NULL)
		return;
a1551 2
	if (sc->dc_srom == NULL)
		return;
d1614 1
a1614 1
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr,
d1618 1
a1618 1
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr, 0, 3, 1);
d1623 1
a1623 1
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr,	
d1628 1
a1628 1
		bcopy(&sc->dc_srom[DC_AL_EE_NODEADDR], &sc->sc_arpcom.ac_enaddr,
a1632 4
	case DC_TYPE_CONEXANT:
		bcopy(&sc->dc_srom + DC_CONEXANT_EE_NODEADDR,
		    &sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
		break;
d1634 1
a1634 1
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr,
d1697 1
a1697 1
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d1699 1
a1699 1
	ifp = &sc->sc_arpcom.ac_if;
d1795 1
a1795 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d2120 1
a2120 1
	ifp = &sc->sc_arpcom.ac_if;
d2227 1
a2227 1
	ifp = &sc->sc_arpcom.ac_if;
d2274 1
a2274 1
		if (DC_IS_XIRCOM(sc) || DC_IS_CONEXANT(sc)) {
d2278 1
a2278 5
			 * even when the carrier is there. wtf?!
			 * Who knows, but Conexant chips have the
			 * same problem. Maybe they took lessons
			 * from Xircom.
			 */
d2340 1
a2340 1
	ifp = &sc->sc_arpcom.ac_if;
d2417 1
a2417 1
	ifp = &sc->sc_arpcom.ac_if;
a2463 1
#if 0
a2464 1
#endif
a2469 1
#if 0
a2470 1
#endif
a2475 1
#if 0
a2476 1
#endif
d2578 1
a2578 1
		 TBR_IS_ENABLED(&sc->sc_arpcom.ac_if.if_snd))
d2716 1
a2716 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d2807 1
a2807 1
		splx(s);
d2862 1
a2862 1
	splx(s);
d2954 1
a2954 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d2965 1
a2965 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d2996 2
a2997 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
d3022 1
a3022 1
	splx(s);
d3057 1
a3057 1
	ifp = &sc->sc_arpcom.ac_if;
@


1.44.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.44.2.1 2002/06/11 03:42:18 art Exp $	*/
d131 1
a1435 3
	if (sc->dc_type == DC_TYPE_21145)
		dc_setcfg(sc, IFM_10_T);

a1640 1
	case DC_TYPE_21145:
a1762 2
	} else if (sc->dc_type == DC_TYPE_21145) {
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);
@


1.44.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d204 2
a205 3
void
dc_delay(sc)
	struct dc_softc *sc;
d207 1
a207 1
	int idx;
d213 2
a214 3
void
dc_eeprom_width(sc)
	struct dc_softc *sc;
d277 2
a278 3
void
dc_eeprom_idle(sc)
	struct dc_softc *sc;
d280 1
a280 1
	int i;
d303 2
d310 3
a312 4
void
dc_eeprom_putbyte(sc, addr)
	struct dc_softc *sc;
	int addr;
d314 1
a314 1
	int d, i;
d345 2
d354 4
a357 5
void
dc_eeprom_getword_pnic(sc, addr, dest)
	struct dc_softc *sc;
	int addr;
	u_int16_t *dest;
d359 2
a360 2
	int i;
	u_int32_t r;
d372 2
d379 4
a382 5
void
dc_eeprom_getword(sc, addr, dest)
	struct dc_softc *sc;
	int addr;
	u_int16_t *dest;
d384 2
a385 2
	int i;
	u_int16_t word = 0;
d422 2
d430 5
a434 3
	struct dc_softc *sc;
	caddr_t dest;
	int off, cnt, swap;
d436 2
a437 2
	int i;
	u_int16_t word = 0, *ptr;
d450 2
d461 3
a463 4
void
dc_mii_writebit(sc, bit)
	struct dc_softc *sc;
	int bit;
d473 2
d480 2
a481 3
int
dc_mii_readbit(sc)
	struct dc_softc *sc;
d488 3
a490 2
		return (1);
	return (0);
d496 2
a497 3
void
dc_mii_sync(sc)
	struct dc_softc *sc;
d499 1
a499 1
	int i;
d505 2
d512 4
a515 5
void
dc_mii_send(sc, bits, cnt)
	struct dc_softc *sc;
	u_int32_t bits;
	int cnt;
d517 1
a517 1
	int i;
d526 4
a529 4
int
dc_mii_readreg(sc, frame)
	struct dc_softc *sc;
	struct dc_mii_frame *frame;
d531 1
a531 1
	int i, ack, s;
d577 4
a580 2
		if (dc_mii_readbit(sc))
			frame->mii_data |= i;
d591 2
a592 2
		return (1);
	return (0);
d598 4
a601 4
int
dc_mii_writereg(sc, frame)
	struct dc_softc *sc;
	struct dc_mii_frame *frame;
d603 1
a603 1
	int s;
d631 2
a632 1
	return (0);
d635 3
a637 4
int
dc_miibus_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
d639 5
a643 3
	struct dc_mii_frame frame;
	struct dc_softc *sc = (struct dc_softc *)self;
	int i, rval, phy_reg;
d655 1
a655 1
		return (0);
d662 1
d670 5
a674 5
				/*
				 * Fake something to make the probe
				 * code think there's a PHY here.
				 */
				return (BMSR_MEDIAMASK);
d678 2
a679 2
					return (PCI_VENDOR_LITEON);
				return (PCI_VENDOR_DEC);
d683 2
a684 2
					return (PCI_PRODUCT_LITEON_PNIC);
				return (PCI_PRODUCT_DEC_21142);
d687 1
a687 1
				return (0);
d691 1
a691 1
			return (0);
d702 1
a702 1
				return (rval == 0xFFFF ? 0 : rval);
d705 1
a705 1
		return (0);
d732 3
a734 3
			printf("%s: phy_read: bad phy register %x\n",
			    sc->sc_dev.dv_xname, reg);
			return (0);
d741 2
a742 2
			return (0);
		return (rval);
a744 2
	bzero(&frame, sizeof(frame));

d755 1
a755 1
	return (frame.mii_data);
d758 3
a760 4
void
dc_miibus_writereg(self, phy, reg, data)
	struct device *self;
	int phy, reg, data;
d762 3
a764 3
	struct dc_softc *sc = (struct dc_softc *)self;
	struct dc_mii_frame frame;
	int i, phy_reg;
d807 2
a808 2
			printf("%s: phy_write: bad phy register %x\n",
			    sc->sc_dev.dv_xname, reg);
d828 2
d832 1
a832 2
void
dc_miibus_statchg(self)
d851 2
d860 3
a862 4
u_int32_t
dc_crc_le(sc, addr)
	struct dc_softc *sc;
	caddr_t addr;
d864 1
a864 1
	u_int32_t idx, bit, data, crc;
d900 6
a905 7
u_int32_t
dc_crc_be(addr)
	caddr_t addr;
{
	u_int32_t crc, carry;
	int i, j;
	u_int8_t c;
d922 1
a922 1
	return ((crc >> 26) & 0x0000003F);
d935 2
a936 3
void
dc_setfilt_21143(sc)
	struct dc_softc *sc;
d938 7
a944 7
	struct dc_desc *sframe;
	u_int32_t h, *sp;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	struct ifnet *ifp;
	int i;
d1014 2
d1018 2
a1019 3
void
dc_setfilt_admtek(sc)
	struct dc_softc *sc;
d1021 6
a1026 6
	struct ifnet *ifp;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	int h = 0;
	u_int32_t hashes[2] = { 0, 0 };
d1069 2
d1073 2
a1074 3
void
dc_setfilt_asix(sc)
	struct dc_softc *sc;
d1076 6
a1081 6
	struct ifnet *ifp;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	int h = 0;
	u_int32_t hashes[2] = { 0, 0 };
d1141 2
d1145 2
a1146 3
void
dc_setfilt_xircom(sc)
	struct dc_softc *sc;
d1148 7
a1154 7
	struct dc_desc *sframe;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t h, *sp;
	struct ifnet *ifp;
	int i;
d1215 2
d1219 2
a1220 3
void
dc_setfilt(sc)
	struct dc_softc *sc;
d1234 2
d1243 3
a1245 4
void
dc_setcfg(sc, media)
	struct dc_softc *sc;
	int media;
d1247 2
a1248 2
	int i, restart = 0;
	u_int32_t isr;
d1266 2
a1267 2
			printf("%s: failed to force tx and "
			    "rx to idle state\n", sc->sc_dev.dv_xname);
d1389 2
d1393 2
a1394 3
void
dc_reset(sc)
	struct dc_softc *sc;
d1396 1
a1396 1
	int i;
d1414 1
a1414 1
		printf("%s: reset never completed!\n", sc->sc_dev.dv_xname);
d1437 2
d1441 8
a1448 9
void
dc_apply_fixup(sc, media)
	struct dc_softc *sc;
	int media;
{
	struct dc_mediainfo *m;
	u_int8_t *p;
	int i;
	u_int32_t reg;
d1470 2
d1474 3
a1476 4
void
dc_decode_leaf_sia(sc, l)
	struct dc_softc *sc;
	struct dc_eblock_sia *l;
d1478 1
a1478 1
	struct dc_mediainfo *m;
d1503 2
d1507 3
a1509 4
void
dc_decode_leaf_sym(sc, l)
	struct dc_softc *sc;
	struct dc_eblock_sym *l;
d1511 1
a1511 1
	struct dc_mediainfo *m;
d1530 2
d1534 3
a1536 4
void
dc_decode_leaf_mii(sc, l)
	struct dc_softc *sc;
	struct dc_eblock_mii *l;
d1538 2
a1539 2
	u_int8_t *p;
	struct dc_mediainfo *m;
d1559 2
d1563 3
a1565 4
void
dc_read_srom(sc, bits)
	struct dc_softc *sc;
	int bits;
d1576 2
a1577 3
void
dc_parse_21143_srom(sc)
	struct dc_softc *sc;
d1579 4
a1582 4
	struct dc_leaf_hdr *lhdr;
	struct dc_eblock_hdr *hdr;
	int i, loff;
	char *ptr;
d1608 2
d1616 1
a1616 2
void
dc_attach(sc)
d1619 2
a1620 2
	struct ifnet *ifp;
	int mac_offset, tmp, i;
d1762 12
d1775 1
a1775 1
		if (LIST_EMPTY(&sc->sc_mii.mii_phys)) {
a1779 2
			if (sc->dc_flags & DC_MOMENCO_BOTCH)
				sc->dc_pmode = DC_PMODE_MII;
d1782 1
d1789 5
a1793 11
	if (LIST_EMPTY(&sc->sc_mii.mii_phys)) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
		printf("%s: MII without any PHY!\n", sc->sc_dev.dv_xname);
	} else if (sc->dc_type == DC_TYPE_21145) {
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	if (DC_IS_DAVICOM(sc) && sc->dc_revision >= DC_REVISION_DM9102A)
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_HPNA_1,0,NULL);
d1820 2
a1821 3
int
dc_detach(sc)
	struct dc_softc *sc;
d1844 2
a1845 3
int
dc_list_tx_init(sc)
	struct dc_softc *sc;
d1847 4
a1850 4
	struct dc_chain_data *cd;
	struct dc_list_data *ld;
	int i;
	bus_addr_t next;
d1870 1
a1870 1
	return (0);
d1879 2
a1880 3
int
dc_list_rx_init(sc)
	struct dc_softc *sc;
d1882 4
a1885 4
	struct dc_chain_data *cd;
	struct dc_list_data *ld;
	int i;
	bus_addr_t next;
d1892 1
a1892 1
			return (ENOBUFS);
d1905 1
a1905 1
	return (0);
d1911 8
a1918 9
int
dc_newbuf(sc, i, m)
	struct dc_softc *sc;
	int i;
	struct mbuf *m;
{
	struct mbuf *m_new = NULL;
	struct dc_desc *c;
	bus_dmamap_t map;
d1925 3
a1927 3
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->sc_dev.dv_xname);
			return (ENOBUFS);
d1932 2
a1933 2
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->sc_dev.dv_xname);
d1935 1
a1935 1
			return (ENOBUFS);
d1980 1
a1980 1
	return (0);
d2036 3
a2038 4
void
dc_pnic_rx_bug_war(sc, idx)
	struct dc_softc *sc;
	int idx;
d2090 2
d2105 2
a2106 3
int
dc_rx_resync(sc)
	struct dc_softc *sc;
d2108 2
a2109 2
	int i, pos;
	struct dc_desc *cur_rx;
d2127 1
a2127 1
		return (0);
d2132 1
a2132 1
	return (EAGAIN);
d2139 2
a2140 3
void
dc_rxeof(sc)
	struct dc_softc *sc;
d2142 5
a2146 5
	struct mbuf *m;
	struct ifnet *ifp;
	struct dc_desc *cur_rx;
	int i, total_len = 0;
	u_int32_t rxstat;
d2239 2
d2248 2
a2249 3
void
dc_txeof(sc)
	struct dc_softc *sc;
d2251 3
a2253 3
	struct dc_desc *cur_tx = NULL;
	struct ifnet *ifp;
	int idx;
d2357 2
d2361 2
a2362 3
void
dc_tick(xsc)
	void *xsc;
d2364 5
a2368 5
	struct dc_softc *sc = (struct dc_softc *)xsc;
	struct mii_data *mii;
	struct ifnet *ifp;
	int s;
	u_int32_t r;
d2436 2
d2440 2
a2441 3
int
dc_intr(arg)
	void *arg;
d2443 4
a2446 4
	struct dc_softc *sc;
	struct ifnet *ifp;
	u_int32_t status;
	int claimed = 0;
d2455 1
a2455 1
		return (claimed);
d2496 3
d2504 3
d2509 1
d2512 3
d2551 8
a2558 9
int
dc_encap(sc, m_head, txidx)
	struct dc_softc *sc;
	struct mbuf *m_head;
	u_int32_t *txidx;
{
	struct dc_desc *f = NULL;
	int frag, cur, cnt = 0, i;
	bus_dmamap_t map;
d2578 1
a2578 1
				return (ENOBUFS);
d2584 1
a2584 1
			return (ENOBUFS);
d2632 1
a2632 1
	return (0);
d2640 3
a2642 4
int
dc_coal(sc, m_head)
	struct dc_softc *sc;
	struct mbuf **m_head;
d2649 2
a2650 2
		printf("%s: no memory for tx list", sc->sc_dev.dv_xname);
		return (ENOBUFS);
d2656 2
a2657 3
			printf("%s: no memory for tx list",
			    sc->sc_dev.dv_xname);
			return (ENOBUFS);
d2665 1
a2665 1
	return (0);
d2675 2
a2676 3
void
dc_start(ifp)
	struct ifnet *ifp;
d2678 3
a2680 3
	struct dc_softc *sc;
	struct mbuf *m_head = NULL;
	int idx;
d2746 2
d2750 2
a2751 3
void
dc_init(xsc)
	void *xsc;
d2753 4
a2756 4
	struct dc_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mii_data *mii;
	int s;
d2842 2
a2843 2
		printf("%s: initialization failed: no "
		    "memory for rx buffers\n", sc->sc_dev.dv_xname);
d2922 2
d2929 2
a2930 3
int
dc_ifmedia_upd(ifp)
	struct ifnet *ifp;
d2932 2
a2933 2
	struct dc_softc *sc;
	struct mii_data *mii;
d2948 1
a2948 1
	return (0);
d2954 3
a2956 4
void
dc_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d2958 3
a2960 3
	struct dc_softc *sc;
	struct mii_data *mii;
	struct ifmedia *ifm;
d2975 2
d2979 4
a2982 5
int
dc_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
d2994 1
a2994 1
		return (error);
d3062 1
a3062 1
	return (error);
d3065 2
a3066 3
void
dc_watchdog(ifp)
	struct ifnet *ifp;
d3068 1
a3068 1
	struct dc_softc *sc;
d3073 1
a3073 1
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);
d3081 2
d3089 2
a3090 3
void
dc_stop(sc)
	struct dc_softc *sc;
d3092 2
a3093 2
	struct ifnet *ifp;
	int i;
d3151 2
d3159 2
a3160 3
void
dc_shutdown(v)
	void *v;
d3162 1
a3162 1
	struct dc_softc *sc = (struct dc_softc *)v;
d3170 1
@


1.43
log
@Go ahead and fix the xircom filter setup to work on big endian too (untested, but it's pretty similiar to the tested 21143 case).
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.42 2001/12/08 04:39:09 jason Exp $	*/
a131 4
#ifdef __alpha__
#define SRM_MEDIA
#endif

@


1.42
log
@use htole32() on the data going into the setup frame for the dc_setfilt_21143() case at least.
XXX I'm looking at the other filter setups and they appear to need work for BE too.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.41 2001/12/06 22:19:35 jason Exp $	*/
d1183 1
a1183 1
		sp[h >> 4] |= 1 << (h & 0xF);
d1189 1
a1189 1
		sp[h >> 4] |= 1 << (h & 0xF);
d1193 3
a1195 3
	sp[0] = ((u_int16_t *)sc->arpcom.ac_enaddr)[0];
	sp[1] = ((u_int16_t *)sc->arpcom.ac_enaddr)[1];
	sp[2] = ((u_int16_t *)sc->arpcom.ac_enaddr)[2];
@


1.41
log
@add bus_dmamap_sync()'s on the descriptors too
(with all this, my Netra X1 is up and running with an NFS root)
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.40 2001/12/06 21:22:07 jason Exp $	*/
d971 1
a971 1
		sp[h >> 4] |= 1 << (h & 0xF);
d977 1
a977 1
		sp[h >> 4] |= 1 << (h & 0xF);
@


1.40
log
@a few more bus_dmamap_sync()'s and some borrowed setup frame macros from NetBSD, and RX works on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.39 2001/12/06 20:12:00 jason Exp $	*/
d1951 5
d2090 5
d2131 5
d2244 5
d2588 1
d2590 6
@


1.39
log
@enough bus_dmamap_sync() and htole()/letoh() to get TX working on sparc64.
ALso, get the MAC address from myetheraddr() instead of trying to use the eeprom on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.38 2001/12/06 17:32:59 jason Exp $	*/
d981 9
a989 3
	sp[39] = ((u_int16_t *)sc->arpcom.ac_enaddr)[0];
	sp[40] = ((u_int16_t *)sc->arpcom.ac_enaddr)[1];
	sp[41] = ((u_int16_t *)sc->arpcom.ac_enaddr)[2];
d992 5
@


1.38
log
@vtophys, R.I.P. (tx now uses bus_dma)
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.37 2001/12/06 16:51:30 jason Exp $	*/
d949 4
a952 4
	sframe->dc_data = sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_sbuf);
	sframe->dc_ctl = DC_SFRAME_LEN | DC_TXCTL_SETUP | DC_TXCTL_TLINK |
	    DC_FILTER_HASHPERF | DC_TXCTL_FINT;
d985 1
a985 1
	sframe->dc_status = DC_TXSTAT_OWN;
d1149 4
a1152 4
	sframe->dc_data = sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_sbuf);
	sframe->dc_ctl = DC_SFRAME_LEN | DC_TXCTL_SETUP | DC_TXCTL_TLINK |
	    DC_FILTER_HASHPERF | DC_TXCTL_FINT;
d1189 1
a1189 1
	sframe->dc_status = DC_TXSTAT_OWN;
d1597 3
d1631 1
d1828 3
a1830 3
		ld->dc_tx_list[i].dc_data = 0;
		ld->dc_tx_list[i].dc_ctl = 0;
		ld->dc_tx_list[i].dc_next = next;
d1865 1
a1865 1
		ld->dc_rx_list[i].dc_next = next;
d1929 4
d1934 5
a1938 4
	c->dc_data = sc->dc_cdata.dc_rx_chain[i].sd_map->dm_segs[0].ds_addr +
	    sizeof(u_int64_t);
	c->dc_ctl = DC_RXCTL_RLINK | DC_RXLEN;
	c->dc_status = DC_RXSTAT_OWN;
d2015 1
a2015 1
		rxstat = c->dc_status;
d2049 1
a2049 1
	cur_rx->dc_status = rxstat | DC_RXSTAT_FIRSTFRAG;
d2075 1
a2075 1
		if (!(cur_rx->dc_status & DC_RXSTAT_OWN))
d2106 2
a2107 1
	while(!(sc->dc_ldata->dc_rx_list[i].dc_status & DC_RXSTAT_OWN)) {
d2111 1
a2111 1
		rxstat = cur_rx->dc_status;
d2124 1
a2124 1
				rxstat = cur_rx->dc_status;
d2164 4
d2219 1
a2219 1
		txstat = cur_tx->dc_status;
d2224 2
a2225 2
		if (!(cur_tx->dc_ctl & DC_TXCTL_LASTFRAG) ||
		    cur_tx->dc_ctl & DC_TXCTL_SETUP) {
d2227 1
a2227 1
			if (cur_tx->dc_ctl & DC_TXCTL_SETUP) {
d2281 5
a2285 2
			bus_dmamap_unload(sc->sc_dmat,
			    sc->dc_cdata.dc_tx_chain[idx].sd_map);
d2523 1
a2523 1
		f->dc_ctl = DC_TXCTL_TLINK | map->dm_segs[i].ds_len;
d2525 2
a2526 2
			f->dc_status = 0;
			f->dc_ctl |= DC_TXCTL_FIRSTFRAG;
d2528 2
a2529 2
			f->dc_status = DC_TXSTAT_OWN;
		f->dc_data = map->dm_segs[i].ds_addr;
d2539 1
a2539 1
	sc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_LASTFRAG;
d2541 2
a2542 1
		sc->dc_ldata->dc_tx_list[*txidx].dc_ctl |= DC_TXCTL_FINT;
d2544 2
a2545 1
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;
d2547 2
a2548 1
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;
d2552 2
a2553 1
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;
d2555 3
a2557 1
	sc->dc_ldata->dc_tx_list[*txidx].dc_status = DC_TXSTAT_OWN;
d3039 5
a3043 2
			bus_dmamap_unload(sc->sc_dmat,
			    sc->dc_cdata.dc_rx_chain[i].sd_map);
d3058 5
a3062 2
			bus_dmamap_unload(sc->sc_dmat,
			    sc->dc_cdata.dc_tx_chain[i].sd_map);
d3066 1
a3066 1
			    DC_TXCTL_SETUP) {
@


1.37
log
@move rx handling over to bus_dma... that just leaves one vtophys() in tx.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.36 2001/12/06 06:25:17 jason Exp $	*/
a124 2
#include <uvm/uvm_extern.h>		/* for vtophys */

d954 1
a954 1
	sc->dc_cdata.dc_tx_chain[i] =
d1154 1
a1154 1
	sc->dc_cdata.dc_tx_chain[i] =
a1668 1
#if 0
d1670 2
a1671 2
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT,
d1677 5
a1681 1
#endif
d1823 1
a1823 1
		cd->dc_tx_chain[i] = NULL;
d2227 1
a2227 1
				sc->dc_cdata.dc_tx_chain[idx] = NULL;
d2266 7
a2272 3
		if (sc->dc_cdata.dc_tx_chain[idx] != NULL) {
			m_freem(sc->dc_cdata.dc_tx_chain[idx]);
			sc->dc_cdata.dc_tx_chain[idx] = NULL;
a2273 1

d2475 2
a2476 2
	struct mbuf		*m;
	int			frag, cur, cnt = 0;
d2483 6
a2488 1
	m = m_head;
d2491 6
a2496 6
	for (m = m_head; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if (sc->dc_flags & DC_TX_ADMTEK_WAR) {
				if (*txidx != sc->dc_cdata.dc_tx_prod &&
				    frag == (DC_TX_LIST_CNT - 1))
					return(ENOBUFS);
d2498 6
a2503 3
			if ((DC_TX_LIST_CNT -
			    (sc->dc_cdata.dc_tx_cnt + cnt)) < 5)
				return(ENOBUFS);
d2505 11
a2515 12
			f = &sc->dc_ldata->dc_tx_list[frag];
			f->dc_ctl = DC_TXCTL_TLINK | m->m_len;
			if (cnt == 0) {
				f->dc_status = 0;
				f->dc_ctl |= DC_TXCTL_FIRSTFRAG;
			} else
				f->dc_status = DC_TXSTAT_OWN;
			f->dc_data = vtophys(mtod(m, vm_offset_t));
			cur = frag;
			DC_INC(frag, DC_TX_LIST_CNT);
			cnt++;
		}
a2517 3
	if (m != NULL)
		return(ENOBUFS);

d2519 3
a2521 1
	sc->dc_cdata.dc_tx_chain[cur] = m_head;
d2597 1
a2597 1
	while(sc->dc_cdata.dc_tx_chain[idx] == NULL) {
d3031 5
a3035 1
		if (sc->dc_cdata.dc_tx_chain[i] != NULL) {
d3038 1
a3038 1
				sc->dc_cdata.dc_tx_chain[i] = NULL;
d3041 2
a3042 2
			m_freem(sc->dc_cdata.dc_tx_chain[i]);
			sc->dc_cdata.dc_tx_chain[i] = NULL;
@


1.36
log
@move the setup buffer and pad into a bus_dma alloced area
(current score: 2 vtophys calls to go...)
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.35 2001/12/06 05:42:12 jason Exp $	*/
d1657 12
a1668 11
	for (i = 0; i < DC_TX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_NOWAIT, &sc->sc_txsd[i].sd_map) != 0) {
			printf(": tx dmamap create failed\n");
			goto fail;
		}
		sc->sc_txsd[i].sd_mbuf = NULL;
		if (i == DC_TX_LIST_CNT - 1)
			sc->sc_txsd[i].sd_next = sc->sc_txsd;
		else
			sc->sc_txsd[i].sd_next = sc->sc_txsd + (i + 1);
d1671 8
a1678 11
	for (i = 0; i < DC_RX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_NOWAIT, &sc->sc_rxsd[i].sd_map) != 0) {
			printf(": rx dmamap create failed\n");
			goto fail;
		}
		sc->sc_rxsd[i].sd_mbuf = NULL;
		if (i == DC_RX_LIST_CNT - 1)
			sc->sc_rxsd[i].sd_next = sc->sc_rxsd;
		else
			sc->sc_rxsd[i].sd_next = sc->sc_rxsd + (i + 1);
d1680 1
d1878 1
d1898 10
d1924 3
a1926 2
	sc->dc_cdata.dc_rx_chain[i] = m_new;
	c->dc_data = vtophys(mtod(m_new, caddr_t));
d2006 1
a2006 1
		m = sc->dc_cdata.dc_rx_chain[i];
d2101 1
a2101 1
		m = sc->dc_cdata.dc_rx_chain[i];
d2118 1
a2118 1
		sc->dc_cdata.dc_rx_chain[i] = NULL;
d3005 7
a3011 3
		if (sc->dc_cdata.dc_rx_chain[i] != NULL) {
			m_freem(sc->dc_cdata.dc_rx_chain[i]);
			sc->dc_cdata.dc_rx_chain[i] = NULL;
@


1.35
log
@Checkpoint bus_dma work in progress:
- descriptor lists are now bus_dma allocated and manipulated
(for those keeping score: 6 vtophys dead, 4 to go)
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.34 2001/11/06 19:53:18 miod Exp $	*/
d948 1
a948 1
	sp = (u_int32_t *)&sc->dc_cdata.dc_sbuf;
d951 2
a952 1
	sframe->dc_data = vtophys(&sc->dc_cdata.dc_sbuf);
d956 2
a957 1
	sc->dc_cdata.dc_tx_chain[i] = (struct mbuf *)&sc->dc_cdata.dc_sbuf;
d1148 1
a1148 1
	sp = (u_int32_t *)&sc->dc_cdata.dc_sbuf;
d1151 2
a1152 1
	sframe->dc_data = vtophys(&sc->dc_cdata.dc_sbuf);
d1156 2
a1157 1
	sc->dc_cdata.dc_tx_chain[i] = (struct mbuf *)&sc->dc_cdata.dc_sbuf;
@


1.34
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.33 2001/08/22 16:38:38 aaron Exp $	*/
d1590 1
a1590 1
	int			error = 0, mac_offset, tmp;
d1627 52
a1683 10
	sc->dc_ldata_ptr = malloc(sizeof(struct dc_list_data), M_DEVBUF,
				M_NOWAIT);
	if (sc->dc_ldata_ptr == NULL) {
		printf("%s: no memory for list buffers!\n", sc->dc_unit);
		goto fail;
	}

	sc->dc_ldata = (struct dc_list_data *)sc->dc_ldata_ptr;
	bzero(sc->dc_ldata, sizeof(struct dc_list_data));

d1807 1
d1812 7
a1818 7
		if (i == (DC_TX_LIST_CNT - 1)) {
			ld->dc_tx_list[i].dc_next =
			    vtophys(&ld->dc_tx_list[0]);
		} else {
			ld->dc_tx_list[i].dc_next =
			    vtophys(&ld->dc_tx_list[i + 1]);
		}
d1822 1
d1842 1
d1850 8
a1857 7
		if (i == (DC_RX_LIST_CNT - 1)) {
			ld->dc_rx_list[i].dc_next =
			    vtophys(&ld->dc_rx_list[0]);
		} else {
			ld->dc_rx_list[i].dc_next =
			    vtophys(&ld->dc_rx_list[i + 1]);
		}
d2737 4
a2740 2
	CSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));
	CSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));
@


1.33
log
@Support more dc(4) CardBus devices, including the AN985-based Linksys PCMPC200
10/100 CardBus Ethernet adapter (thanks to beck@@ for the donation).
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.32 2001/08/12 20:12:12 mickey Exp $	*/
d125 1
a125 1
#include <vm/vm.h>		/* for vtophys */
@


1.32
log
@remove some of the redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.31 2001/08/03 23:24:56 chris Exp $	*/
d1616 2
a1617 2
		dc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
		    DC_AL_EE_NODEADDR, 3, 0);
@


1.31
log
@Set IFCAP_VLAN_MTU, this driver already allows vlan-size frames
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.30 2001/07/02 01:28:20 jason Exp $	*/
a125 1
#include <vm/pmap.h>		/* for vtophys */
@


1.30
log
@these don't depend on pci register defs
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.29 2001/06/27 06:34:40 kjc Exp $	*/
d1655 4
@


1.29
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.28 2001/06/23 23:17:35 fgsch Exp $	*/
d131 1
a131 2
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
@


1.28
log
@ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.27 2001/04/13 15:56:10 aaron Exp $	*/
d1653 2
a1654 1
	ifp->if_snd.ifq_maxlen = DC_TX_LIST_CNT - 1;
d2282 1
a2282 1
			if (ifp->if_snd.ifq_head != NULL)
d2392 1
a2392 1
	if (ifp->if_snd.ifq_head != NULL)
d2456 5
d2525 1
a2525 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
d2530 6
a2536 1
				IF_PREPEND(&ifp->if_snd, m_head);
a2542 1
			IF_PREPEND(&ifp->if_snd, m_head);
d2547 6
d2566 2
d2909 1
a2909 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.27
log
@Oops, remove an unrelated debugging #if 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.26 2001/04/13 15:55:16 aaron Exp $	*/
a2022 1
	struct ether_header	*eh;
a2100 1
		eh = mtod(m, struct ether_header *);
d2106 1
a2106 4

		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, eh, m);
@


1.27.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.27 2001/04/13 15:56:10 aaron Exp $	*/
@


1.27.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.27.4.1 2001/05/14 22:23:40 niklas Exp $	*/
d131 2
a132 1
#include <machine/bus.h>
d1653 1
a1653 2
	IFQ_SET_MAXLEN(&ifp->if_snd, DC_TX_LIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d2023 1
d2102 1
d2108 4
a2111 1
		ether_input_mbuf(ifp, m);
d2286 1
a2286 1
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d2396 1
a2396 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
a2459 5
#ifdef ALTQ
	else if ((sc->dc_flags & DC_TX_USE_TX_INTR) &&
		 TBR_IS_ENABLED(&sc->arpcom.ac_if.if_snd))
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;
#endif
d2524 1
a2524 1
		IFQ_POLL(&ifp->if_snd, m_head);
a2528 6
#ifdef ALTQ
			/* note: dc_coal breaks the poll-and-dequeue rule.
			 * if dc_coal fails, we lose the packet.
			 */
#endif
			IFQ_DEQUEUE(&ifp->if_snd, m_head);
d2530 1
d2537 1
a2541 6
		/* now we are committed to transmit the packet */
		if (sc->dc_flags & DC_TX_COALESCE) {
			/* if mbuf is coalesced, it is already dequeued */
		} else
			IFQ_DEQUEUE(&ifp->if_snd, m_head);

a2554 2
	if (idx == sc->dc_cdata.dc_tx_prod)
		return;
d2896 1
a2896 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
@


1.27.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.27.4.2 2001/07/04 10:40:48 niklas Exp $	*/
d126 1
d1617 2
a1618 2
		bcopy(&sc->dc_srom[DC_AL_EE_NODEADDR], &sc->arpcom.ac_enaddr,
		    ETHER_ADDR_LEN);
a1654 4

#if NVLAN > 0
	ifp->if_capabilities = IFCAP_VLAN_MTU;
#endif
@


1.27.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 1
a125 1
#include <uvm/uvm_extern.h>		/* for vtophys */
@


1.27.4.5
log
@Merge in trunk
@
text
@d125 2
d134 4
d948 1
a948 1
	sp = &sc->dc_ldata->dc_sbuf[0];
d951 3
a953 4
	sframe->dc_data = htole32(sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_sbuf));
	sframe->dc_ctl = htole32(DC_SFRAME_LEN | DC_TXCTL_SETUP |
	    DC_TXCTL_TLINK | DC_FILTER_HASHPERF | DC_TXCTL_FINT);
d955 1
a955 2
	sc->dc_cdata.dc_tx_chain[i].sd_mbuf =
	    (struct mbuf *)&sc->dc_ldata->dc_sbuf[0];
d971 1
a971 1
		sp[h >> 4] |= htole32(1 << (h & 0xF));
d977 1
a977 1
		sp[h >> 4] |= htole32(1 << (h & 0xF));
d981 3
a983 15
	sp[39] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 0);
	sp[40] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 1);
	sp[41] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 2);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_sbuf[0]),
	    sizeof(struct dc_list_data) - 
	    offsetof(struct dc_list_data, dc_sbuf[0]),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	sframe->dc_status = htole32(DC_TXSTAT_OWN);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_tx_list[i]),
	    sizeof(struct dc_desc), BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d985 1
d1146 1
a1146 1
	sp = &sc->dc_ldata->dc_sbuf[0];
d1149 3
a1151 4
	sframe->dc_data = htole32(sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_sbuf));
	sframe->dc_ctl = htole32(DC_SFRAME_LEN | DC_TXCTL_SETUP |
	    DC_TXCTL_TLINK | DC_FILTER_HASHPERF | DC_TXCTL_FINT);
d1153 1
a1153 2
	sc->dc_cdata.dc_tx_chain[i].sd_mbuf =
	    (struct mbuf *)&sc->dc_ldata->dc_sbuf[0];
d1170 1
a1170 1
		sp[h >> 4] |= htole32(1 << (h & 0xF));
d1176 1
a1176 1
		sp[h >> 4] |= htole32(1 << (h & 0xF));
d1180 3
a1182 3
	sp[0] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 0);
	sp[1] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 1);
	sp[2] = DC_SP_FIELD(sc->arpcom.ac_enaddr, 2);
d1187 1
a1187 1
	sframe->dc_status = htole32(DC_TXSTAT_OWN);
d1590 1
a1590 1
	int			error = 0, mac_offset, tmp, i;
a1594 3
	if (sc->sc_hasmac)
		goto hasmac;

a1625 55
hasmac:

	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct dc_list_data),
	    PAGE_SIZE, 0, sc->sc_listseg, 1, &sc->sc_listnseg,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": can't alloc list mem\n");
		goto fail;
	}
	if (bus_dmamem_map(sc->sc_dmat, sc->sc_listseg, sc->sc_listnseg,
	    sizeof(struct dc_list_data), &sc->sc_listkva,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": can't map list mem\n");
		goto fail;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct dc_list_data), 1,
	    sizeof(struct dc_list_data), 0, BUS_DMA_NOWAIT,
	    &sc->sc_listmap) != 0) {
		printf(": can't alloc list map\n");
		goto fail;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_listmap, sc->sc_listkva,
	    sizeof(struct dc_list_data), NULL, BUS_DMA_NOWAIT) != 0) {
		printf(": can't load list map\n");
		goto fail;
	}
	sc->dc_ldata = (struct dc_list_data *)sc->sc_listkva;
	bzero(sc->dc_ldata, sizeof(struct dc_list_data));

	for (i = 0; i < DC_RX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT,
		    &sc->dc_cdata.dc_rx_chain[i].sd_map) != 0) {
			printf(": can't create rx map\n");
			return;
		}
	}
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
	    BUS_DMA_NOWAIT, &sc->sc_rx_sparemap) != 0) {
		printf(": can't create rx spare map\n");
		return;
	}

	for (i = 0; i < DC_TX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    DC_TX_LIST_CNT - 5, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->dc_cdata.dc_tx_chain[i].sd_map) != 0) {
			printf(": can't create tx map\n");
			return;
		}
	}
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, DC_TX_LIST_CNT - 5,
	    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->sc_tx_sparemap) != 0) {
		printf(": can't create tx spare map\n");
		return;
	}
d1632 10
a1764 1
	bus_addr_t		next;
d1769 10
a1778 11
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (DC_TX_LIST_CNT - 1))
			next +=
			    offsetof(struct dc_list_data, dc_tx_list[0]);
		else
			next +=
			    offsetof(struct dc_list_data, dc_tx_list[i + 1]);
		cd->dc_tx_chain[i].sd_mbuf = NULL;
		ld->dc_tx_list[i].dc_data = htole32(0);
		ld->dc_tx_list[i].dc_ctl = htole32(0);
		ld->dc_tx_list[i].dc_next = htole32(next);
a1797 1
	bus_addr_t		next;
d1805 7
a1811 8
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (DC_RX_LIST_CNT - 1))
			next +=
			    offsetof(struct dc_list_data, dc_rx_list[0]);
		else
			next +=
			    offsetof(struct dc_list_data, dc_rx_list[i + 1]);
		ld->dc_rx_list[i].dc_next = htole32(next);
a1828 1
	bus_dmamap_t		map;
a1847 10
		if (bus_dmamap_load(sc->sc_dmat, sc->sc_rx_sparemap,
		    mtod(m_new, caddr_t), MCLBYTES, NULL,
		    BUS_DMA_NOWAIT) != 0) {
			printf("%s: rx load failed\n", sc->sc_dev.dv_xname);
			m_freem(m_new);
			return (ENOBUFS);
		}
		map = sc->dc_cdata.dc_rx_chain[i].sd_map;
		sc->dc_cdata.dc_rx_chain[i].sd_map = sc->sc_rx_sparemap;
		sc->sc_rx_sparemap = map;
d1864 4
a1867 15
	bus_dmamap_sync(sc->sc_dmat, sc->dc_cdata.dc_rx_chain[i].sd_map, 0,
	    sc->dc_cdata.dc_rx_chain[i].sd_map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

	sc->dc_cdata.dc_rx_chain[i].sd_mbuf = m_new;
	c->dc_data = htole32(
	    sc->dc_cdata.dc_rx_chain[i].sd_map->dm_segs[0].ds_addr +
	    sizeof(u_int64_t));
	c->dc_ctl = htole32(DC_RXCTL_RLINK | DC_RXLEN);
	c->dc_status = htole32(DC_RXSTAT_OWN);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_rx_list[i]),
	    sizeof(struct dc_desc),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1944 2
a1945 2
		rxstat = letoh32(c->dc_status);
		m = sc->dc_cdata.dc_rx_chain[i].sd_mbuf;
d1978 1
a1978 1
	cur_rx->dc_status = htole32(rxstat | DC_RXSTAT_FIRSTFRAG);
a2002 5
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    offsetof(struct dc_list_data, dc_rx_list[pos]),
		    sizeof(struct dc_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d2004 1
a2004 1
		if (!(cur_rx->dc_status & htole32(DC_RXSTAT_OWN)))
d2035 1
a2035 2
	while(!(sc->dc_ldata->dc_rx_list[i].dc_status &
	    htole32(DC_RXSTAT_OWN))) {
a2037 5
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    offsetof(struct dc_list_data, dc_rx_list[i]),
		    sizeof(struct dc_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d2039 2
a2040 2
		rxstat = letoh32(cur_rx->dc_status);
		m = sc->dc_cdata.dc_rx_chain[i].sd_mbuf;
d2052 1
a2052 1
				rxstat = letoh32(cur_rx->dc_status);
d2057 1
a2057 1
		sc->dc_cdata.dc_rx_chain[i].sd_mbuf = NULL;
a2091 4
		bus_dmamap_sync(sc->sc_dmat, sc->dc_cdata.dc_rx_chain[i].sd_map,
		    0, sc->dc_cdata.dc_rx_chain[i].sd_map->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);

a2141 5
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    offsetof(struct dc_list_data, dc_tx_list[idx]),
		    sizeof(struct dc_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d2143 1
a2143 1
		txstat = letoh32(cur_tx->dc_status);
d2148 2
a2149 2
		if (!(cur_tx->dc_ctl & htole32(DC_TXCTL_LASTFRAG)) ||
		    cur_tx->dc_ctl & htole32(DC_TXCTL_SETUP)) {
d2151 1
a2151 1
			if (cur_tx->dc_ctl & htole32(DC_TXCTL_SETUP)) {
d2165 1
a2165 1
				sc->dc_cdata.dc_tx_chain[idx].sd_mbuf = NULL;
d2204 4
a2207 2
		if (sc->dc_cdata.dc_tx_chain[idx].sd_map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->dc_cdata.dc_tx_chain[idx].sd_map;
a2208 8
			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
		if (sc->dc_cdata.dc_tx_chain[idx].sd_mbuf != NULL) {
			m_freem(sc->dc_cdata.dc_tx_chain[idx].sd_mbuf);
			sc->dc_cdata.dc_tx_chain[idx].sd_mbuf = NULL;
		}
a2354 1
#if 0
a2355 1
#endif
a2360 1
#if 0
a2361 1
#endif
a2366 1
#if 0
a2367 1
#endif
d2410 2
a2411 2
	int			frag, cur, cnt = 0, i;
	bus_dmamap_t		map;
d2418 1
a2418 6
	map = sc->sc_tx_sparemap;

	if (bus_dmamap_load_mbuf(sc->sc_dmat, map,
	    m_head, BUS_DMA_NOWAIT) != 0)
		return (ENOBUFS);

d2421 9
a2429 5
	for (i = 0; i < map->dm_nsegs; i++) {
		if (sc->dc_flags & DC_TX_ADMTEK_WAR) {
			if (*txidx != sc->dc_cdata.dc_tx_prod &&
			    frag == (DC_TX_LIST_CNT - 1)) {
				bus_dmamap_unload(sc->sc_dmat, map);
d2431 12
a2442 6
			}
		}
		if ((DC_TX_LIST_CNT -
		    (sc->dc_cdata.dc_tx_cnt + cnt)) < 5) {
			bus_dmamap_unload(sc->sc_dmat, map);
			return(ENOBUFS);
d2444 1
d2446 2
a2447 12
		f = &sc->dc_ldata->dc_tx_list[frag];
		f->dc_ctl = htole32(DC_TXCTL_TLINK | map->dm_segs[i].ds_len);
		if (cnt == 0) {
			f->dc_status = htole32(0);
			f->dc_ctl |= htole32(DC_TXCTL_FIRSTFRAG);
		} else
			f->dc_status = htole32(DC_TXSTAT_OWN);
		f->dc_data = htole32(map->dm_segs[i].ds_addr);
		cur = frag;
		DC_INC(frag, DC_TX_LIST_CNT);
		cnt++;
	}
d2450 2
a2451 4
	sc->dc_cdata.dc_tx_chain[cur].sd_mbuf = m_head;
	sc->sc_tx_sparemap = sc->dc_cdata.dc_tx_chain[cur].sd_map;
	sc->dc_cdata.dc_tx_chain[cur].sd_map = map;
	sc->dc_ldata->dc_tx_list[cur].dc_ctl |= htole32(DC_TXCTL_LASTFRAG);
d2453 1
a2453 2
		sc->dc_ldata->dc_tx_list[*txidx].dc_ctl |=
		    htole32(DC_TXCTL_FINT);
d2455 1
a2455 2
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |=
		    htole32(DC_TXCTL_FINT);
d2457 1
a2457 2
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |=
		    htole32(DC_TXCTL_FINT);
d2461 1
a2461 2
		sc->dc_ldata->dc_tx_list[cur].dc_ctl |=
		    htole32(DC_TXCTL_FINT);
d2463 1
a2463 10
	bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	sc->dc_ldata->dc_tx_list[*txidx].dc_status = htole32(DC_TXSTAT_OWN);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct dc_list_data, dc_tx_list[0]),
	    sizeof(struct dc_desc) * DC_TX_LIST_CNT,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d2526 1
a2526 1
	while(sc->dc_cdata.dc_tx_chain[idx].sd_mbuf == NULL) {
d2679 1
a2679 1
		splx(s);
d2691 2
a2692 4
	CSR_WRITE_4(sc, DC_RXADDR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_rx_list[0]));
	CSR_WRITE_4(sc, DC_TXADDR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct dc_list_data, dc_tx_list[0]));
d2732 1
a2732 1
	splx(s);
d2892 1
a2892 1
	splx(s);
d2942 3
a2944 10
		if (sc->dc_cdata.dc_rx_chain[i].sd_map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->dc_cdata.dc_rx_chain[i].sd_map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
		if (sc->dc_cdata.dc_rx_chain[i].sd_mbuf != NULL) {
			m_freem(sc->dc_cdata.dc_rx_chain[i].sd_mbuf);
			sc->dc_cdata.dc_rx_chain[i].sd_mbuf = NULL;
d2954 1
a2954 8
		if (sc->dc_cdata.dc_tx_chain[i].sd_map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->dc_cdata.dc_tx_chain[i].sd_map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
		if (sc->dc_cdata.dc_tx_chain[i].sd_mbuf != NULL) {
d2956 2
a2957 2
			    htole32(DC_TXCTL_SETUP)) {
				sc->dc_cdata.dc_tx_chain[i].sd_mbuf = NULL;
d2960 2
a2961 2
			m_freem(sc->dc_cdata.dc_tx_chain[i].sd_mbuf);
			sc->dc_cdata.dc_tx_chain[i].sd_mbuf = NULL;
@


1.27.4.6
log
@Merge in -current from about a week ago
@
text
@d134 61
a194 61
int dc_intr(void *);
void dc_shutdown(void *);
struct dc_type *dc_devtype(void *);
int dc_newbuf(struct dc_softc *, int, struct mbuf *);
int dc_encap(struct dc_softc *, struct mbuf *, u_int32_t *);
int dc_coal(struct dc_softc *, struct mbuf **);

void dc_pnic_rx_bug_war(struct dc_softc *, int);
int dc_rx_resync(struct dc_softc *);
void dc_rxeof(struct dc_softc *);
void dc_txeof(struct dc_softc *);
void dc_tick(void *);
void dc_start(struct ifnet *);
int dc_ioctl(struct ifnet *, u_long, caddr_t);
void dc_init(void *);
void dc_stop(struct dc_softc *);
void dc_watchdog(struct ifnet *);
int dc_ifmedia_upd(struct ifnet *);
void dc_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void dc_delay(struct dc_softc *);
void dc_eeprom_width(struct dc_softc *);
void dc_eeprom_idle(struct dc_softc *);
void dc_eeprom_putbyte(struct dc_softc *, int);
void dc_eeprom_getword(struct dc_softc *, int, u_int16_t *);
void dc_eeprom_getword_pnic(struct dc_softc *, int, u_int16_t *);
void dc_read_eeprom(struct dc_softc *, caddr_t, int, int, int);

void dc_mii_writebit(struct dc_softc *, int);
int dc_mii_readbit(struct dc_softc *);
void dc_mii_sync(struct dc_softc *);
void dc_mii_send(struct dc_softc *, u_int32_t, int);
int dc_mii_readreg(struct dc_softc *, struct dc_mii_frame *);
int dc_mii_writereg(struct dc_softc *, struct dc_mii_frame *);
int dc_miibus_readreg(struct device *, int, int);
void dc_miibus_writereg(struct device *, int, int, int);
void dc_miibus_statchg(struct device *);

void dc_setcfg(struct dc_softc *, int);
u_int32_t dc_crc_le(struct dc_softc *, caddr_t);
u_int32_t dc_crc_be(caddr_t);
void dc_setfilt_21143(struct dc_softc *);
void dc_setfilt_asix(struct dc_softc *);
void dc_setfilt_admtek(struct dc_softc *);
void dc_setfilt_xircom(struct dc_softc *);

void dc_setfilt(struct dc_softc *);

void dc_reset(struct dc_softc *);
int dc_list_rx_init(struct dc_softc *);
int dc_list_tx_init(struct dc_softc *);

void dc_read_srom(struct dc_softc *, int);
void dc_parse_21143_srom(struct dc_softc *);
void dc_decode_leaf_sia(struct dc_softc *,
				     struct dc_eblock_sia *);
void dc_decode_leaf_mii(struct dc_softc *,
				     struct dc_eblock_mii *);
void dc_decode_leaf_sym(struct dc_softc *,
				     struct dc_eblock_sym *);
void dc_apply_fixup(struct dc_softc *, int);
@


1.27.4.7
log
@Sync the SMP branch with 3.3
@
text
@d131 1
d578 4
a581 2
		if (dc_mii_readbit(sc))
			frame->mii_data |= i;
a657 9
	/*
	 * Note: the ukphy probs of the RS7112 report a PHY at
	 * MII address 0 (possibly HomePNA?) and 1 (ethernet)
	 * so we only respond to correct one.
	 */
	
	if (DC_IS_CONEXANT(sc) && phy != DC_CONEXANT_PHYADDR)
		return (0);

a761 2
	if (DC_IS_CONEXANT(sc) && phy != DC_CONEXANT_PHYADDR)
		return;
d930 1
a930 1
	struct arpcom		*ac = &sc->sc_arpcom;
d936 1
a936 1
	ifp = &sc->sc_arpcom.ac_if;
d977 3
a979 3
	sp[39] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 0);
	sp[40] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 1);
	sp[41] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 2);
d1012 1
a1012 1
	struct arpcom		*ac = &sc->sc_arpcom;
d1018 1
a1018 1
	ifp = &sc->sc_arpcom.ac_if;
d1021 2
a1022 2
	CSR_WRITE_4(sc, DC_AL_PAR0, *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[0]));
	CSR_WRITE_4(sc, DC_AL_PAR1, *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[4]));
d1067 1
a1067 1
	struct arpcom		*ac = &sc->sc_arpcom;
d1073 1
a1073 1
	ifp = &sc->sc_arpcom.ac_if;
d1078 1
a1078 1
	    *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[0]));
d1081 1
a1081 1
	    *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[4]));
d1139 1
a1139 1
	struct arpcom		*ac = &sc->sc_arpcom;
d1146 1
a1146 1
	ifp = &sc->sc_arpcom.ac_if;
d1189 3
a1191 3
	sp[0] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 0);
	sp[1] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 1);
	sp[2] = DC_SP_FIELD(sc->sc_arpcom.ac_enaddr, 2);
d1213 1
a1213 1
	    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc) || DC_IS_CONEXANT(sc))
d1397 1
a1397 1
	    DC_IS_INTEL(sc) || DC_IS_CONEXANT(sc)) {
a1424 3
	if (sc->dc_type == DC_TYPE_21145)
		dc_setcfg(sc, IFM_10_T);

a1467 2
	if (m == NULL)
		return;
a1498 2
	if (m == NULL)
		return;
a1524 2
	if (m == NULL)
		return;
a1551 2
	if (sc->dc_srom == NULL)
		return;
d1614 1
a1614 1
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr,
d1618 1
a1618 1
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr, 0, 3, 1);
a1621 1
	case DC_TYPE_21145:
d1623 1
a1623 1
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr,	
d1628 1
a1628 1
		bcopy(&sc->dc_srom[DC_AL_EE_NODEADDR], &sc->sc_arpcom.ac_enaddr,
a1632 4
	case DC_TYPE_CONEXANT:
		bcopy(&sc->dc_srom + DC_CONEXANT_EE_NODEADDR,
		    &sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
		break;
d1634 1
a1634 1
		dc_read_eeprom(sc, (caddr_t)&sc->sc_arpcom.ac_enaddr,
d1697 1
a1697 1
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d1699 1
a1699 1
	ifp = &sc->sc_arpcom.ac_if;
a1739 2
	} else if (sc->dc_type == DC_TYPE_21145) {
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);
d1795 1
a1795 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d2120 1
a2120 1
	ifp = &sc->sc_arpcom.ac_if;
d2227 1
a2227 1
	ifp = &sc->sc_arpcom.ac_if;
d2274 1
a2274 1
		if (DC_IS_XIRCOM(sc) || DC_IS_CONEXANT(sc)) {
d2278 1
a2278 5
			 * even when the carrier is there. wtf?!
			 * Who knows, but Conexant chips have the
			 * same problem. Maybe they took lessons
			 * from Xircom.
			 */
d2340 1
a2340 1
	ifp = &sc->sc_arpcom.ac_if;
d2417 1
a2417 1
	ifp = &sc->sc_arpcom.ac_if;
a2476 1
#if 0
a2477 1
#endif
d2584 1
a2584 1
		 TBR_IS_ENABLED(&sc->sc_arpcom.ac_if.if_snd))
d2722 1
a2722 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d2960 1
a2960 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d2971 1
a2971 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d3002 2
a3003 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
d3063 1
a3063 1
	ifp = &sc->sc_arpcom.ac_if;
@


1.27.4.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.27.4.7 2003/03/28 00:38:12 niklas Exp $	*/
d204 2
a205 3
void
dc_delay(sc)
	struct dc_softc *sc;
d207 1
a207 1
	int idx;
d213 2
a214 3
void
dc_eeprom_width(sc)
	struct dc_softc *sc;
d277 2
a278 3
void
dc_eeprom_idle(sc)
	struct dc_softc *sc;
d280 1
a280 1
	int i;
d303 2
d310 3
a312 4
void
dc_eeprom_putbyte(sc, addr)
	struct dc_softc *sc;
	int addr;
d314 1
a314 1
	int d, i;
d345 2
d354 4
a357 5
void
dc_eeprom_getword_pnic(sc, addr, dest)
	struct dc_softc *sc;
	int addr;
	u_int16_t *dest;
d359 2
a360 2
	int i;
	u_int32_t r;
d372 2
d379 4
a382 5
void
dc_eeprom_getword(sc, addr, dest)
	struct dc_softc *sc;
	int addr;
	u_int16_t *dest;
d384 2
a385 2
	int i;
	u_int16_t word = 0;
d422 2
d430 5
a434 3
	struct dc_softc *sc;
	caddr_t dest;
	int off, cnt, swap;
d436 2
a437 2
	int i;
	u_int16_t word = 0, *ptr;
d450 2
d461 3
a463 4
void
dc_mii_writebit(sc, bit)
	struct dc_softc *sc;
	int bit;
d473 2
d480 2
a481 3
int
dc_mii_readbit(sc)
	struct dc_softc *sc;
d488 3
a490 2
		return (1);
	return (0);
d496 2
a497 3
void
dc_mii_sync(sc)
	struct dc_softc *sc;
d499 1
a499 1
	int i;
d505 2
d512 4
a515 5
void
dc_mii_send(sc, bits, cnt)
	struct dc_softc *sc;
	u_int32_t bits;
	int cnt;
d517 1
a517 1
	int i;
d526 4
a529 4
int
dc_mii_readreg(sc, frame)
	struct dc_softc *sc;
	struct dc_mii_frame *frame;
d531 1
a531 1
	int i, ack, s;
d589 2
a590 2
		return (1);
	return (0);
d596 4
a599 4
int
dc_mii_writereg(sc, frame)
	struct dc_softc *sc;
	struct dc_mii_frame *frame;
d601 1
a601 1
	int s;
d629 2
a630 1
	return (0);
d633 3
a635 4
int
dc_miibus_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
d637 5
a641 3
	struct dc_mii_frame frame;
	struct dc_softc *sc = (struct dc_softc *)self;
	int i, rval, phy_reg;
d653 1
a653 1
		return (0);
d660 1
d668 5
a672 5
				/*
				 * Fake something to make the probe
				 * code think there's a PHY here.
				 */
				return (BMSR_MEDIAMASK);
d676 2
a677 2
					return (PCI_VENDOR_LITEON);
				return (PCI_VENDOR_DEC);
d681 2
a682 2
					return (PCI_PRODUCT_LITEON_PNIC);
				return (PCI_PRODUCT_DEC_21142);
d685 1
a685 1
				return (0);
d689 1
a689 1
			return (0);
d700 1
a700 1
				return (rval == 0xFFFF ? 0 : rval);
d703 1
a703 1
		return (0);
d730 3
a732 3
			printf("%s: phy_read: bad phy register %x\n",
			    sc->sc_dev.dv_xname, reg);
			return (0);
d739 2
a740 2
			return (0);
		return (rval);
a742 2
	bzero(&frame, sizeof(frame));

d753 1
a753 1
	return (frame.mii_data);
d756 3
a758 4
void
dc_miibus_writereg(self, phy, reg, data)
	struct device *self;
	int phy, reg, data;
d760 3
a762 3
	struct dc_softc *sc = (struct dc_softc *)self;
	struct dc_mii_frame frame;
	int i, phy_reg;
d805 2
a806 2
			printf("%s: phy_write: bad phy register %x\n",
			    sc->sc_dev.dv_xname, reg);
d826 2
d830 1
a830 2
void
dc_miibus_statchg(self)
d849 2
d858 3
a860 4
u_int32_t
dc_crc_le(sc, addr)
	struct dc_softc *sc;
	caddr_t addr;
d862 1
a862 1
	u_int32_t idx, bit, data, crc;
d898 6
a903 7
u_int32_t
dc_crc_be(addr)
	caddr_t addr;
{
	u_int32_t crc, carry;
	int i, j;
	u_int8_t c;
d920 1
a920 1
	return ((crc >> 26) & 0x0000003F);
d933 2
a934 3
void
dc_setfilt_21143(sc)
	struct dc_softc *sc;
d936 7
a942 7
	struct dc_desc *sframe;
	u_int32_t h, *sp;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	struct ifnet *ifp;
	int i;
d1012 2
d1016 2
a1017 3
void
dc_setfilt_admtek(sc)
	struct dc_softc *sc;
d1019 6
a1024 6
	struct ifnet *ifp;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	int h = 0;
	u_int32_t hashes[2] = { 0, 0 };
d1067 2
d1071 2
a1072 3
void
dc_setfilt_asix(sc)
	struct dc_softc *sc;
d1074 6
a1079 6
	struct ifnet *ifp;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	int h = 0;
	u_int32_t hashes[2] = { 0, 0 };
d1139 2
d1143 2
a1144 3
void
dc_setfilt_xircom(sc)
	struct dc_softc *sc;
d1146 7
a1152 7
	struct dc_desc *sframe;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t h, *sp;
	struct ifnet *ifp;
	int i;
d1213 2
d1217 2
a1218 3
void
dc_setfilt(sc)
	struct dc_softc *sc;
d1232 2
d1241 3
a1243 4
void
dc_setcfg(sc, media)
	struct dc_softc *sc;
	int media;
d1245 2
a1246 2
	int i, restart = 0;
	u_int32_t isr;
d1264 2
a1265 2
			printf("%s: failed to force tx and "
			    "rx to idle state\n", sc->sc_dev.dv_xname);
d1387 2
d1391 2
a1392 3
void
dc_reset(sc)
	struct dc_softc *sc;
d1394 1
a1394 1
	int i;
d1412 1
a1412 1
		printf("%s: reset never completed!\n", sc->sc_dev.dv_xname);
d1435 2
d1439 8
a1446 9
void
dc_apply_fixup(sc, media)
	struct dc_softc *sc;
	int media;
{
	struct dc_mediainfo *m;
	u_int8_t *p;
	int i;
	u_int32_t reg;
d1468 2
d1472 3
a1474 4
void
dc_decode_leaf_sia(sc, l)
	struct dc_softc *sc;
	struct dc_eblock_sia *l;
d1476 1
a1476 1
	struct dc_mediainfo *m;
d1501 2
d1505 3
a1507 4
void
dc_decode_leaf_sym(sc, l)
	struct dc_softc *sc;
	struct dc_eblock_sym *l;
d1509 1
a1509 1
	struct dc_mediainfo *m;
d1528 2
d1532 3
a1534 4
void
dc_decode_leaf_mii(sc, l)
	struct dc_softc *sc;
	struct dc_eblock_mii *l;
d1536 2
a1537 2
	u_int8_t *p;
	struct dc_mediainfo *m;
d1557 2
d1561 3
a1563 4
void
dc_read_srom(sc, bits)
	struct dc_softc *sc;
	int bits;
d1574 2
a1575 3
void
dc_parse_21143_srom(sc)
	struct dc_softc *sc;
d1577 4
a1580 4
	struct dc_leaf_hdr *lhdr;
	struct dc_eblock_hdr *hdr;
	int i, loff;
	char *ptr;
d1606 2
d1614 1
a1614 2
void
dc_attach(sc)
d1617 2
a1618 2
	struct ifnet *ifp;
	int error = 0, mac_offset, tmp, i;
d1788 1
a1788 1
		printf("%s: MII without any PHY!\n", sc->sc_dev.dv_xname);
d1818 2
a1819 3
int
dc_detach(sc)
	struct dc_softc *sc;
d1842 2
a1843 3
int
dc_list_tx_init(sc)
	struct dc_softc *sc;
d1845 4
a1848 4
	struct dc_chain_data *cd;
	struct dc_list_data *ld;
	int i;
	bus_addr_t next;
d1868 1
a1868 1
	return (0);
d1877 2
a1878 3
int
dc_list_rx_init(sc)
	struct dc_softc *sc;
d1880 4
a1883 4
	struct dc_chain_data *cd;
	struct dc_list_data *ld;
	int i;
	bus_addr_t next;
d1890 1
a1890 1
			return (ENOBUFS);
d1903 1
a1903 1
	return (0);
d1909 8
a1916 9
int
dc_newbuf(sc, i, m)
	struct dc_softc *sc;
	int i;
	struct mbuf *m;
{
	struct mbuf *m_new = NULL;
	struct dc_desc *c;
	bus_dmamap_t map;
d1923 3
a1925 3
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->sc_dev.dv_xname);
			return (ENOBUFS);
d1930 2
a1931 2
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->sc_dev.dv_xname);
d1933 1
a1933 1
			return (ENOBUFS);
d1978 1
a1978 1
	return (0);
d2034 3
a2036 4
void
dc_pnic_rx_bug_war(sc, idx)
	struct dc_softc *sc;
	int idx;
d2088 2
d2103 2
a2104 3
int
dc_rx_resync(sc)
	struct dc_softc *sc;
d2106 2
a2107 2
	int i, pos;
	struct dc_desc *cur_rx;
d2125 1
a2125 1
		return (0);
d2130 1
a2130 1
	return (EAGAIN);
d2137 2
a2138 3
void
dc_rxeof(sc)
	struct dc_softc *sc;
d2140 5
a2144 5
	struct mbuf *m;
	struct ifnet *ifp;
	struct dc_desc *cur_rx;
	int i, total_len = 0;
	u_int32_t rxstat;
d2237 2
d2246 2
a2247 3
void
dc_txeof(sc)
	struct dc_softc *sc;
d2249 3
a2251 3
	struct dc_desc *cur_tx = NULL;
	struct ifnet *ifp;
	int idx;
d2355 2
d2359 2
a2360 3
void
dc_tick(xsc)
	void *xsc;
d2362 5
a2366 5
	struct dc_softc *sc = (struct dc_softc *)xsc;
	struct mii_data *mii;
	struct ifnet *ifp;
	int s;
	u_int32_t r;
d2434 2
d2438 2
a2439 3
int
dc_intr(arg)
	void *arg;
d2441 4
a2444 4
	struct dc_softc *sc;
	struct ifnet *ifp;
	u_int32_t status;
	int claimed = 0;
d2453 1
a2453 1
		return (claimed);
d2494 3
d2502 3
d2507 3
d2512 3
d2551 8
a2558 9
int
dc_encap(sc, m_head, txidx)
	struct dc_softc *sc;
	struct mbuf *m_head;
	u_int32_t *txidx;
{
	struct dc_desc *f = NULL;
	int frag, cur, cnt = 0, i;
	bus_dmamap_t map;
d2578 1
a2578 1
				return (ENOBUFS);
d2584 1
a2584 1
			return (ENOBUFS);
d2632 1
a2632 1
	return (0);
d2640 3
a2642 4
int
dc_coal(sc, m_head)
	struct dc_softc *sc;
	struct mbuf **m_head;
d2649 2
a2650 2
		printf("%s: no memory for tx list", sc->sc_dev.dv_xname);
		return (ENOBUFS);
d2656 2
a2657 3
			printf("%s: no memory for tx list",
			    sc->sc_dev.dv_xname);
			return (ENOBUFS);
d2665 1
a2665 1
	return (0);
d2675 2
a2676 3
void
dc_start(ifp)
	struct ifnet *ifp;
d2678 3
a2680 3
	struct dc_softc *sc;
	struct mbuf *m_head = NULL;
	int idx;
d2746 2
d2750 2
a2751 3
void
dc_init(xsc)
	void *xsc;
d2753 4
a2756 4
	struct dc_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mii_data *mii;
	int s;
d2842 2
a2843 2
		printf("%s: initialization failed: no "
		    "memory for rx buffers\n", sc->sc_dev.dv_xname);
d2922 2
d2929 2
a2930 3
int
dc_ifmedia_upd(ifp)
	struct ifnet *ifp;
d2932 2
a2933 2
	struct dc_softc *sc;
	struct mii_data *mii;
d2948 1
a2948 1
	return (0);
d2954 3
a2956 4
void
dc_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d2958 3
a2960 3
	struct dc_softc *sc;
	struct mii_data *mii;
	struct ifmedia *ifm;
d2975 2
d2979 4
a2982 5
int
dc_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
d2994 1
a2994 1
		return (error);
d3062 1
a3062 1
	return (error);
d3065 2
a3066 3
void
dc_watchdog(ifp)
	struct ifnet *ifp;
d3068 1
a3068 1
	struct dc_softc *sc;
d3073 1
a3073 1
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);
d3081 2
d3089 2
a3090 3
void
dc_stop(sc)
	struct dc_softc *sc;
d3092 2
a3093 2
	struct ifnet *ifp;
	int i;
d3151 2
d3159 2
a3160 3
void
dc_shutdown(v)
	void *v;
d3162 1
a3162 1
	struct dc_softc *sc = (struct dc_softc *)v;
d3170 1
@


1.27.4.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.27.4.8 2003/05/13 19:35:00 ho Exp $	*/
d1049 1
a1049 4
		if (DC_IS_CENTAUR(sc))
			h = dc_crc_le(sc, enm->enm_addrlo);
		else
			h = dc_crc_be(enm->enm_addrlo);
d1600 1
a1600 1
	int mac_offset, tmp, i;
d1742 12
d1755 1
a1755 1
		if (LIST_EMPTY(&sc->sc_mii.mii_phys)) {
a1759 2
			if (sc->dc_flags & DC_MOMENCO_BOTCH)
				sc->dc_pmode = DC_PMODE_MII;
d1762 1
d1769 1
a1769 3
	if (LIST_EMPTY(&sc->sc_mii.mii_phys)) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
d1771 3
a1773 7
	} else if (sc->dc_type == DC_TYPE_21145) {
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	if (DC_IS_DAVICOM(sc) && sc->dc_revision >= DC_REVISION_DM9102A)
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_HPNA_1,0,NULL);
@


1.27.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d442 1
a442 1
			*ptr = betoh16(word);
d444 1
a444 1
			*ptr = letoh16(word);
d2033 1
a2033 1
	bzero(ptr, DC_RXLEN * 5);
d2090 2
a2091 2
	u_int32_t stat;
	int i, pos, offset;
a2095 2

		offset = offsetof(struct dc_list_data, dc_rx_list[pos]);
d2097 2
a2098 1
		    offset, sizeof(struct dc_desc),
d2101 2
a2102 2
		stat = sc->dc_ldata->dc_rx_list[pos].dc_status;
		if (!(stat & htole32(DC_RXSTAT_OWN)))
d2111 1
a2111 1
	/* We've fallen behind the chip: catch it. */
d2128 1
a2128 1
	int i, offset, total_len = 0;
d2134 3
a2136 2
	for(;;) {
		struct mbuf	*m0 = NULL;
a2137 1
		offset = offsetof(struct dc_list_data, dc_rx_list[i]);
d2139 2
a2140 1
		    offset, sizeof(struct dc_desc),
a2144 3
		if (rxstat & DC_RXSTAT_OWN)
			break;

a2147 4
		bus_dmamap_sync(sc->sc_dmat, sc->dc_cdata.dc_rx_chain[i].sd_map,
		    0, sc->dc_cdata.dc_rx_chain[i].sd_map->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);

d2197 4
d2213 1
d2235 1
a2235 1
	int idx, offset;
a2249 1
		offset = offsetof(struct dc_list_data, dc_tx_list[idx]);
d2251 2
a2252 1
		    offset, sizeof(struct dc_desc),
a2331 5

		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    offset, sizeof(struct dc_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d2445 1
d2447 4
d2597 2
a2598 2
	    offsetof(struct dc_list_data, dc_tx_list[*txidx]),
	    sizeof(struct dc_desc) * cnt,
a2827 7
	 * Sync down both lists initialized.
	 */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    0, sc->sc_listmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	/*
d3118 1
a3120 4

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    0, sc->sc_listmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
@


1.27.4.11
log
@Merge with the trunk
@
text
@d843 1
d853 1
a853 1
	u_int32_t crc;
d856 6
a861 1
	crc = ether_crc32_le(addr, ETHER_ADDR_LEN);
d889 25
a913 2
#define dc_crc_be(addr)	((ether_crc32_be(addr,ETHER_ADDR_LEN) >> 26) \
	& 0x0000003F)
a959 1
allmulti:
d962 1
a962 1
	else {
d965 5
a969 12
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
			    ETHER_ADDR_LEN)) {
				ifp->if_flags |= IFF_ALLMULTI;
				goto allmulti;
			}

			h = dc_crc_le(sc, enm->enm_addrlo);
			sp[h >> 4] |= htole32(1 << (h & 0xF));
			ETHER_NEXT_MULTI(step, enm);
		}
a1029 1
allmulti:
a1048 5
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}

d1920 3
a1922 2
		if (bus_dmamap_load_mbuf(sc->sc_dmat, sc->sc_rx_sparemap,
		    m_new, BUS_DMA_NOWAIT) != 0) {
a2203 1
		m->m_pkthdr.rcvif = ifp;
@


1.26
log
@Disestablish the shutdownhook on detach.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.25 2001/04/06 17:14:13 aaron Exp $	*/
a2710 1
#if 0
a2711 1
#endif
@


1.25
log
@- For CardBus 21143 cards, parse the SROM. Makes my SMC EZ CardBus 10/100 work.
- General cleanup in the dc CardBus attachment.
- Split detach up into bus-dependent and bus-independent parts.
- Some function and variable renaming for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.24 2001/02/20 19:39:38 mickey Exp $	*/
d1726 1
a1726 1
	shutdownhook_establish(dc_shutdown, sc);
d1748 2
d2711 1
d2713 1
@


1.24
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.23 2001/02/09 05:14:08 art Exp $	*/
d194 1
d1537 11
d1588 1
a1588 1
void dc_attach_common(sc)
a1593 3
	if (!DC_IS_XIRCOM(sc))
		dc_eeprom_width(sc);

d1730 19
@


1.23
log
@Bad aaron. Broke alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.22 2001/02/09 03:45:53 aaron Exp $	*/
a1716 4
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif
@


1.22
log
@Sync with FreeBSD:
- Bugfix: 'reg' variable in dc_apply_fixup() needs to be u_int32_t.
- Bugfix: bzero() mediainfo structures after allocation.
- Call dc_apply_fixup() in dc_setcfg() for the MII case.
- Conditionalize some code in miibus_{read,write}reg to make non-mx98713
  cards happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.21 2001/02/09 02:23:34 aaron Exp $	*/
d2711 1
@


1.21
log
@Add support for parsing the media blocks from the SROM on the 21143 adapters.
These changes should make the driver work with the built-in Ethernet on the
Alpha Miata machines. From FreeBSD.

To make sure I didn't break anything (and as a general test), I tested the
modified driver with the following dc(4) variants: Macronix PMAC 98715,
Lite-On PNIC, Lite-On PNIC-II, ADMtek AL981, and ADMtek AN983.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.20 2000/11/16 06:08:31 aaron Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_dc.c,v 1.22 2000/09/07 18:51:04 wpaul Exp $
d746 4
a749 2
	phy_reg = CSR_READ_4(sc, DC_NETCFG);
	CSR_WRITE_4(sc, DC_NETCFG, phy_reg & ~DC_NETCFG_PORTSEL);
d751 2
a752 1
	CSR_WRITE_4(sc, DC_NETCFG, phy_reg);
d818 4
a821 2
	phy_reg = CSR_READ_4(sc, DC_NETCFG);
	CSR_WRITE_4(sc, DC_NETCFG, phy_reg & ~DC_NETCFG_PORTSEL);
d823 2
a824 1
	CSR_WRITE_4(sc, DC_NETCFG, phy_reg);
d1276 2
d1316 2
d1427 1
a1427 1
	u_int8_t		reg;
d1460 1
d1491 1
d1517 1
@


1.20
log
@Note support for Accton EN1217 and EN2242 Ethernet adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.19 2000/10/30 18:20:14 aaron Exp $	*/
a78 21
 * Knowing which media is available on a given card is tough: you're
 * supposed to go slogging through the EEPROM looking for media
 * description structures. Unfortunately, some card vendors that use
 * the 21143 don't obey the DEC SROM spec correctly, which means that
 * what you find in the EEPROM may not agree with reality. Fortunately,
 * the 21143 provides us a way to get around this issue: lurking in
 * PCI configuration space is the Configuration Wake-Up Command Register.
 * This register is loaded with a value from the EEPROM when wake on LAN
 * mode is enabled; this value tells us quite clearly what kind of media
 * is attached to the NIC. The main purpose of this register is to tell
 * the NIC what media to scan when in wake on LAN mode, however by
 * forcibly enabling wake on LAN mode, we can use to learn what kind of
 * media a given NIC has available and adapt ourselves accordingly.
 *
 * Of course, if the media description blocks in the EEPROM are bogus.
 * what are the odds that the CWUC aren't bogus as well, right? Well,
 * the CWUC value is more likely to be correct since wake on LAN mode
 * won't work correctly without it, and wake on LAN is a big selling
 * point these days. It's also harder to screw up a single byte than
 * a whole media descriptor block.
 *
d136 3
d194 9
d665 1
a665 1
	if (sc->dc_pmode == DC_PMODE_SYM) {
d832 1
d1177 1
a1177 1
	sp[2] = ((u_int16_t *)sc->arpcom.ac_enaddr)[2];      
d1279 4
d1317 15
d1401 1
a1401 1
	 if (DC_IS_INTEL(sc))
d1403 152
d1567 1
a1567 1
	int			error = 0, mac_offset;
d1634 12
d1666 3
a1668 1
			sc->dc_pmode = DC_PMODE_SYM;
d2511 4
d2691 9
d2827 4
@


1.19
log
@Match the Macronix 98727/98732 chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.18 2000/10/26 20:50:43 aaron Exp $	*/
d49 1
a49 1
 * Accton EN1217 (www.accton.com)
@


1.18
log
@Add support for Xircom X3201-based CardBus Ethernet cards. Tested successfully
on four different models, including the CBEM56G-100, RBE-100 RealPort, and the
RBEM56G-100 RealPort. This commit adds support only for the LAN components; the
modem is not configured yet. Detach support to come. Based on work from
FreeBSD, mickey@@, nate@@, and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.17 2000/10/18 16:19:34 aaron Exp $	*/
d41 1
a41 1
 * Macronix 98713/98715/98725 PMAC (www.macronix.com)
@


1.17
log
@Sigh. According to the ASIX data sheets, these boards don't even have RX
or TX state registers (these bits are reserved). So instead, don't do
mii_tick() at all for ASIX boards, since we can't seem to figure out how
to call it at just the right time. Hopefully this will be a temporary hack
until a better solution is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.16 2000/10/17 16:08:52 aaron Exp $	*/
d48 3
a50 1
 * Davicom DM9100, DM9102 (www.davicom8.com)
d146 2
a147 2
#include <vm/vm.h>              /* for vtophys */
#include <vm/pmap.h>            /* for vtophys */
d204 1
d884 9
d1071 3
a1073 3
        /* Init our MAC address */
        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR0);
        CSR_WRITE_4(sc, DC_AX_FILTDATA,
d1075 2
a1076 2
        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR1);
        CSR_WRITE_4(sc, DC_AX_FILTDATA,
d1131 72
d1216 3
d1367 2
a1368 1
	if (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc)) {
d1393 1
a1393 1
        return;
d1406 2
a1407 1
	dc_eeprom_width(sc);
d1436 2
d1508 13
d1807 3
a1809 3
        struct ether_header	*eh;
        struct mbuf		*m;
        struct ifnet		*ifp;
d1957 17
a1973 5
		if (/*sc->dc_type == DC_TYPE_21143 &&*/
		    sc->dc_pmode == DC_PMODE_MII &&
		    ((txstat & 0xFFFF) & ~(DC_TXSTAT_ERRSUM|
		    DC_TXSTAT_NOCARRIER|DC_TXSTAT_CARRLOST)))
			txstat &= ~DC_TXSTAT_ERRSUM;
d2106 2
a2107 1
	while((status = CSR_READ_4(sc, DC_ISR)) & DC_INTRS) {
d2259 1
a2259 1
        struct mbuf		*m_new, *m;
d2425 9
@


1.16
log
@Undo the incorrect fix for my ASIX 88141. Instead of just relying on tx_cnt,
now we check the TX state in the ISR to make sure we are not transmitting
when we run mii_tick(). Based on a suggestion by Bill Paul. The dc driver
should now be ready for some heavy pre-2.8 testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.15 2000/10/16 17:08:07 aaron Exp $	*/
d1922 1
a1922 2
			    (r & DC_ISR_TX_STATE) == DC_TXSTATE_RESET &&
			    sc->dc_cdata.dc_tx_cnt == 0)
@


1.15
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.14 2000/10/11 17:01:24 aaron Exp $	*/
d1922 2
a1923 1
			    sc->dc_cdata.dc_tx_prod == 0)
@


1.14
log
@For some reason, with the eeprom width detection code mickey added awhile ago,
special care for the ADMtek AN983 (Centaur-P) chip is no longer needed. This
fixes Ethernet address reading for these cards. Thanks to todd@@ for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.13 2000/09/28 18:32:59 aaron Exp $	*/
d1385 3
a1387 1
	mii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);
d1402 2
a1403 1
			mii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);
@


1.13
log
@If this is a Davicom DM9102A and we're enabling the homePNA link, force
dc_link to 1 and don't activate the tick routine. Without this, dc_start()
always thinks the link is down and never transmits in homePNA mode; from
FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.12 2000/09/13 00:29:34 aaron Exp $	*/
d330 1
a330 9
	/*
	 * The AN983 has a 93C66 EEPROM on it instead of
	 * a 93C46. It uses a different bit sequence for
	 * specifying the "read" opcode.
	 */
	if (DC_IS_CENTAUR(sc))
		d = DC_EECMD_READ >> 4;
	else
		d = DC_EECMD_READ >> 6;
@


1.12
log
@Sync with FreeBSD. Finally make the OpenBSD-specific changes necessary to make
non-MII 21143-based cards work. The sync just fixes the LED handling on these
kinds of adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.11 2000/09/07 20:26:15 aaron Exp $	*/
d2380 8
a2387 4
	if (sc->dc_flags & DC_21143_NWAY)
		timeout_add(&sc->dc_tick_tmo, hz / 10);
	else
		timeout_add(&sc->dc_tick_tmo, hz);
@


1.11
log
@Indentation fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.10 2000/08/26 12:53:57 aaron Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_dc.c,v 1.19 2000/08/01 19:34:13 wpaul Exp $
d1324 1
a1324 1
	int			mac_offset;
d1395 1
d1404 10
a1413 6
	/* if (error && DC_IS_INTEL(sc)) {
		sc->dc_pmode = DC_PMODE_SYM;
		sc->dc_flags |= DC_21143_NWAY;
		mii_phy_probe(dev, &sc->dc_miibus,
		    dc_ifmedia_upd, dc_ifmedia_sts);
		error = 0;
a1417 3
		bus_teardown_intr(dev, sc->dc_irq, sc->dc_intrhand);
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->dc_irq);
		bus_release_resource(dev, DC_RES, DC_RID, sc->dc_res);
d1420 1
a1420 1
	} */
d2346 11
@


1.10
log
@Revert a minor FreeBSD tweak that tends to freeze my machine solid after
large amounts of data transfer (ASIX 88141 card).
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.9 2000/08/08 16:43:50 aaron Exp $	*/
d1927 2
a1928 2
				if (!(mii->mii_media_status & IFM_ACTIVE))
					sc->dc_link = 0;
@


1.9
log
@Make fix for preserving LED settings conditional on presence of an Intel
21143 chip; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.8 2000/08/02 19:01:06 aaron Exp $	*/
d1925 1
a1925 1
			    sc->dc_cdata.dc_tx_cnt == 0)
@


1.8
log
@Sync with FreeBSD. Summary of changes:

- Add support for Accton EN1217 Ethernet adapters.
- Fix problems with LEDs on some cards when clearing the jabber disable bit.
- Handle new Macronix chips whose multicast hash tables are only 128 bits.
- Fix timing issues during autonegotiation with Macronix and PNIC II.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.7 2000/08/02 17:40:58 aaron Exp $	*/
d1182 1
d1184 7
a1190 4
			watchdogreg = CSR_READ_4(sc, DC_WATCHDOG);
			watchdogreg &= ~DC_WDOG_CTLWREN;
			watchdogreg |= DC_WDOG_JABBERDIS;
			CSR_WRITE_4(sc, DC_WATCHDOG, watchdogreg);
d1217 1
d1219 7
a1225 4
			watchdogreg = CSR_READ_4(sc, DC_WATCHDOG);
			watchdogreg &= ~DC_WDOG_CTLWREN;
			watchdogreg |= DC_WDOG_JABBERDIS;
			CSR_WRITE_4(sc, DC_WATCHDOG, watchdogreg);
@


1.7
log
@Don't print out the eeprom width.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.6 2000/08/02 08:40:54 peter Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_dc.c,v 1.8 2000/03/09 19:28:19 rwatson Exp $
d860 3
a862 2
#define DC_BITS		9
#define DC_BITS_PNIC_II	7
d878 6
a883 3
	/* The hash table on the PNIC II is only 128 bits wide. */
	if (DC_IS_PNICII(sc))
		return (crc & ((1 << DC_BITS_PNIC_II) - 1));
d885 5
a889 1
	return (crc & ((1 << DC_BITS) - 1));
d1180 7
a1186 1
			DC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);
d1201 3
a1203 2
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL|
			    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER);
d1211 7
a1217 1
			DC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);
d1232 1
a1233 1
			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);
d1397 1
d1900 9
a1908 3
		r = CSR_READ_4(sc, DC_ISR);
		if (DC_IS_INTEL(sc)) {
			if (r & DC_ISR_LINKFAIL) 
d1910 2
d1915 1
d1917 1
a1917 1
			    sc->dc_cdata.dc_tx_prod == 0)
d1919 2
d1954 4
a1957 1
	timeout_add(&sc->dc_tick_tmo, hz);
d2358 5
a2362 1
	timeout_add(&sc->dc_tick_tmo, hz);
@


1.6
log
@Add support for accepting packets up to 4 octets larger than the
interface MTU IFF vlans are enabled.

Additional logic should be added by someone who understand 802.1q to
test if this oversize packet is actually a 802.1q encapsulated, and
reject others.

Fix as per kernel/1328.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.5 2000/07/21 15:52:10 mickey Exp $	*/
d272 1
a272 2
	if (i < 4 || i > 12) {
		printf("forcing eeprom width to 12, ");
d274 1
a274 2
	} else {
		printf("eeprom width is %d, ", i);
a275 1
	}
@


1.5
log
@convert to new timeouts; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.4 2000/06/12 16:49:24 mickey Exp $	*/
d112 1
d1719 11
a1729 1
		if (rxstat & DC_RXSTAT_RXERR) {
@


1.4
log
@remove debugging prom dump, sorry
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.3 2000/06/12 16:46:53 mickey Exp $	*/
d123 1
d1913 1
a1913 1
	timeout(dc_tick, sc, hz);
d2313 2
a2314 1
	timeout(dc_tick, sc, hz);
d2487 1
a2487 1
	untimeout(dc_tick, sc);
@


1.3
log
@eeprom width detection code.
idea from netbsd tulip driver.
there is problem w/ an983 card, but aaron@@ said he'll work it out.
aaron@@ & jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.2 2000/06/12 15:17:13 aaron Exp $	*/
a227 1
	u_int16_t word;
a286 9

	printf("\n");
	for (i = 0; i < 256; i++) {
		if (DC_IS_PNIC(sc))
			dc_eeprom_getword_pnic(sc, i, &word);
		else
			dc_eeprom_getword(sc, i, &word);
		printf("%04x%s", word, ((i & 15) == 15)? "\n": " ");
	}
@


1.2
log
@Fix ADMtek identity crisis.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.1 2000/04/18 19:35:30 jason Exp $	*/
d177 1
d225 77
d347 1
a347 1
		d = addr | (DC_EECMD_READ << 2);
d349 13
a361 1
		d = addr | DC_EECMD_READ;
d366 2
a367 2
	for (i = 0x400; i; i >>= 1) {
		if (d & i) {
d1307 2
@


1.1
log
@split dc driver into bus dependent and bus independent (pci) parts
(cardbus to come later).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc.c,v 1.11 2000/03/17 01:27:13 aaron Exp $	*/
d47 1
a47 1
 * ADMtek AN985 (www.admtek.com.tw)
d264 1
a264 1
	 * The AN985 has a 93C66 EEPROM on it instead of
d589 1
a589 1
	 * Note: both the AL981 and AN985 have internal PHYs,
d591 2
a592 2
	 * registers while the AN985 uses a serial MII interface.
	 * The AN985's MII interface is also buggy in that you
d1241 1
a1241 1
	case DC_TYPE_AN985:
@


1.1.2.1
log
@Pull in patch from current:
Fix (peter):
Add support for accepting packets up to 4 octets larger than the
interface MTU IFF vlans are enabled.

Additional logic should be added by someone who understand 802.1q to
test if this oversize packet is actually a 802.1q encapsulated, and
reject others.

Fix as per kernel/1328.
@
text
@d1 1
a1 1
/*	$OpenBSD: dc.c,v 1.1 2000/04/18 19:35:30 jason Exp $	*/
a111 1
#include "vlan.h"
d1635 1
a1635 11
		if (rxstat & DC_RXSTAT_RXERR
#if NVLAN > 0
		/*
		 * If VLANs are enabled, allow frames up to 4 bytes
		 * longer than the MTU. This should really check if
		 * the giant packet has a vlan tag
		 */
		 && ((rxstat & (DC_RXSTAT_GIANT|DC_RXSTAT_LASTFRAG)) == 0
		 && total_len <= ifp->if_mtu + 4) 
#endif
		    ) {
@


