head	1.55;
access;
symbols
	OPENBSD_6_2_BASE:1.55
	OPENBSD_6_1:1.55.0.4
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.54.0.8
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.54.0.4
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.51.0.10
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.51.0.8
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.4
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.6
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.48.0.4
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.42.0.6
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	UBC:1.9.0.4
	UBC_SYNC_B:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.55
date	2016.08.17.01.17.54;	author krw;	state Exp;
branches;
next	1.54;
commitid	ABXin5xH6wOo5rmV;

1.54
date	2015.07.17.21.42.49;	author krw;	state Exp;
branches;
next	1.53;
commitid	bEhopXwWgYXDvWRJ;

1.53
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.52;
commitid	I19imNlAX05zJOED;

1.52
date	2014.01.17.23.25.07;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.05.22.40.57;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.04.22.17.23;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.02.08.19.35;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.20.08.40.41;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.25.18.10.00;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.20.00.21.49;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.07.17.58.39;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2007.08.04.14.37.34;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.02.02.20.37;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.04.14.20.37;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.28.03.00.07;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.02.03.27.39;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.12.15.32.12;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.12.00.50.17;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.08.03.44.36;	author kevlo;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.28.04.12.24;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.24.04.28.33;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.24.14.56.56;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.13.23.38.54;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.01.01.36.23;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.24.15.49.31;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.17.14.40.55;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.17.04.56.33;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.07.17.08.32;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.05.01.09.18;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.28.21.29.27;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.24.22.45.45;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.21.18.58.48;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.29.19.28.16;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.21.14.58.06;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.05.22.41.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.06.05.04.41;	author smurph;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2002.07.05.05.41.03;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.01.23.31.05;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.28.05.01.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.28.00.34.54;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.19.02.49.20;	author millert;	state dead;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.00.04.09;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.28.11.51.00;	author niklas;	state dead;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.03.28.14.05.52;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.05.13.19.34.59;	author ho;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Move to iopool. No voluntary testers after several years of requests so now
everybody gets to test!
@
text
@/*	$OpenBSD: aic7xxx_openbsd.c,v 1.54 2015/07/17 21:42:49 krw Exp $	*/
/*	$NetBSD: aic7xxx_osm.c,v 1.14 2003/11/02 11:07:44 wiz Exp $	*/

/*
 * Bus independent OpenBSD shim for the aic7xxx based adaptec SCSI controllers
 *
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2001-2002 Steve Murphree, Jr.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#12 $
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx_osm.c,v 1.31 2002/11/30 19:08:58 scottl Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
 */

#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>

#ifndef AHC_TMODE_ENABLE
#define AHC_TMODE_ENABLE 0
#endif


void	ahc_action(struct scsi_xfer *);
void	ahc_execute_scb(void *, bus_dma_segment_t *, int);
int	ahc_poll(struct ahc_softc *, int);
void	ahc_setup_data(struct ahc_softc *, struct scsi_xfer *, struct scb *);

void	ahc_minphys(struct buf *, struct scsi_link *);
void	ahc_adapter_req_set_xfer_mode(struct ahc_softc *, struct scb *);


struct cfdriver ahc_cd = {
	NULL, "ahc", DV_DULL
};

static struct scsi_adapter ahc_switch =
{
	ahc_action,
	ahc_minphys,
	0,
	0,
};

/*
 * Attach all the sub-devices we can find
 */
int
ahc_attach(struct ahc_softc *ahc)
{
	struct scsibus_attach_args saa;
	int s;

        s = splbio();

	/*
	 * fill in the prototype scsi_links.
	 */
	ahc->sc_channel.adapter_target = ahc->our_id;
	if (ahc->features & AHC_WIDE)
		ahc->sc_channel.adapter_buswidth = 16;
	ahc->sc_channel.adapter_softc = ahc;
	ahc->sc_channel.adapter = &ahc_switch;
	ahc->sc_channel.openings = 16;
	ahc->sc_channel.pool = &ahc->sc_iopool;

	if (ahc->features & AHC_TWIN) {
		/* Configure the second scsi bus */
		ahc->sc_channel_b = ahc->sc_channel;
		ahc->sc_channel_b.adapter_target = ahc->our_id_b;
	}

#ifndef DEBUG
	if (bootverbose) {
		char ahc_info[256];
		ahc_controller_info(ahc, ahc_info, sizeof ahc_info);
		printf("%s: %s\n", ahc->sc_dev.dv_xname, ahc_info);
	}
#endif

	ahc_intr_enable(ahc, TRUE);

	if (ahc->flags & AHC_RESET_BUS_A)
		ahc_reset_channel(ahc, 'A', TRUE);
	if ((ahc->features & AHC_TWIN) && ahc->flags & AHC_RESET_BUS_B)
		ahc_reset_channel(ahc, 'B', TRUE);

	bzero(&saa, sizeof(saa));
	if ((ahc->flags & AHC_PRIMARY_CHANNEL) == 0) {
		saa.saa_sc_link = &ahc->sc_channel;
		ahc->sc_child = config_found((void *)&ahc->sc_dev,
		    &saa, scsiprint);
		if (ahc->features & AHC_TWIN) {
			saa.saa_sc_link = &ahc->sc_channel_b;
			ahc->sc_child_b = config_found((void *)&ahc->sc_dev,
			    &saa, scsiprint);
		}
	} else {
		if (ahc->features & AHC_TWIN) {
			saa.saa_sc_link = &ahc->sc_channel_b;
			ahc->sc_child = config_found((void *)&ahc->sc_dev,
			    &saa, scsiprint);
		}
		saa.saa_sc_link = &ahc->sc_channel;
		ahc->sc_child_b = config_found((void *)&ahc->sc_dev,
		    &saa, scsiprint);
	}

	splx(s);
	return (1);
}

/*
 * Catch an interrupt from the adapter
 */
int
ahc_platform_intr(void *arg)
{
	struct	ahc_softc *ahc = (struct ahc_softc *)arg;

	bus_dmamap_sync(ahc->parent_dmat, ahc->scb_data->hscb_dmamap,
	    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	return ahc_intr(ahc);
}

/*
 * We have an scb which has been processed by the
 * adaptor, now we look to see how the operation
 * went.
 */
void
ahc_done(struct ahc_softc *ahc, struct scb *scb)
{
	struct scsi_xfer *xs = scb->xs;

	bus_dmamap_sync(ahc->parent_dmat, ahc->scb_data->hscb_dmamap,
	    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	LIST_REMOVE(scb, pending_links);
	if ((scb->flags & SCB_UNTAGGEDQ) != 0) {
		struct scb_tailq *untagged_q;
		int target_offset;

		target_offset = SCB_GET_TARGET_OFFSET(ahc, scb);
		untagged_q = &ahc->untagged_queues[target_offset];
		TAILQ_REMOVE(untagged_q, scb, links.tqe);
		scb->flags &= ~SCB_UNTAGGEDQ;
		ahc_run_untagged_queue(ahc, untagged_q);
	}

	timeout_del(&xs->stimeout);

	if (xs->datalen) {
		int op;

		if ((xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_POSTREAD;
		else
			op = BUS_DMASYNC_POSTWRITE;
		bus_dmamap_sync(ahc->parent_dmat, scb->dmamap, 0,
				scb->dmamap->dm_mapsize, op);
		bus_dmamap_unload(ahc->parent_dmat, scb->dmamap);
	}

	/* Translate the CAM status code to a SCSI error code. */
	switch (xs->error) {
	case CAM_SCSI_STATUS_ERROR:
	case CAM_REQ_INPROG:
	case CAM_REQ_CMP:
		switch (xs->status) {
		case SCSI_TASKSET_FULL:
		case SCSI_BUSY:
			xs->error = XS_BUSY;
			break;
		case SCSI_CHECK:
		case SCSI_TERMINATED:
			if ((scb->flags & SCB_SENSE) == 0) {
				/* CHECK on CHECK? */
				xs->error = XS_DRIVER_STUFFUP;
			} else
				xs->error = XS_NOERROR;
			break;
		default:
			xs->error = XS_NOERROR;
			break;
		}
		break;
	case CAM_REQUEUE_REQ:
	case CAM_BUSY:
		xs->error = XS_BUSY;
		break;
	case CAM_CMD_TIMEOUT:
		xs->error = XS_TIMEOUT;
		break;
	case CAM_BDR_SENT:
	case CAM_SCSI_BUS_RESET:
		xs->error = XS_RESET;
		break;
	case CAM_SEL_TIMEOUT:
		xs->error = XS_SELTIMEOUT;
		break;
	default:
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	/* Don't clobber any existing error state */
	if (xs->error != XS_NOERROR) {
	  /* Don't clobber any existing error state */
	} else if ((scb->flags & SCB_SENSE) != 0) {
		/*
		 * We performed autosense retrieval.
		 *
		 * Zero any sense not transferred by the
		 * device.  The SCSI spec mandates that any
		 * untransferred data should be assumed to be
		 * zero.  Complete the 'bounce' of sense information
		 * through buffers accessible via bus-space by
		 * copying it into the clients csio.
		 */
		memset(&xs->sense, 0, sizeof(struct scsi_sense_data));
		memcpy(&xs->sense, ahc_get_sense_buf(ahc, scb),
		    aic_le32toh(scb->sg_list->len) & AHC_SG_LEN_MASK);
		xs->error = XS_SENSE;
	}

	scsi_done(xs);
}

void
ahc_minphys(struct buf *bp, struct scsi_link *sl)
{
	/*
	 * Even though the card can transfer up to 16megs per command
	 * we are limited by the number of segments in the dma segment
	 * list that we can hold.  The worst case is that all pages are
	 * discontinuous physically, hence the "page per segment" limit
	 * enforced here.
	 */
	if (bp->b_bcount > ((AHC_NSEG - 1) * PAGE_SIZE)) {
		bp->b_bcount = ((AHC_NSEG - 1) * PAGE_SIZE);
	}
	minphys(bp);
}

void
ahc_action(struct scsi_xfer *xs)
{
	struct ahc_softc *ahc;
	struct scb *scb;
	struct hardware_scb *hscb;
	u_int target_id;
	u_int our_id;

	SC_DEBUG(xs->sc_link, SDEV_DB3, ("ahc_action\n"));
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;

	target_id = xs->sc_link->target;
	our_id = SCSI_SCSI_ID(ahc, xs->sc_link);

	/*
	 * get the scb to use.
	 */
	scb = xs->io;

	/* Clean up for the next user */
	scb->flags = SCB_FLAG_NONE;

	hscb = scb->hscb;
	hscb->control = 0;
	ahc->scb_data->scbindex[hscb->tag] = NULL;

	SC_DEBUG(xs->sc_link, SDEV_DB3, ("start scb(%p)\n", scb));
	scb->xs = xs;
	timeout_set(&xs->stimeout, ahc_timeout, scb);

	/*
	 * Put all the arguments for the xfer in the scb
	 */
	hscb->control = 0;
	hscb->scsiid = BUILD_SCSIID(ahc, xs->sc_link, target_id, our_id);
	hscb->lun = xs->sc_link->lun;
	if (xs->xs_control & XS_CTL_RESET) {
		hscb->cdb_len = 0;
		scb->flags |= SCB_DEVICE_RESET;
		hscb->control |= MK_MESSAGE;
		ahc_execute_scb(scb, NULL, 0);
		return;
	}

	ahc_setup_data(ahc, xs, scb);
}

void
ahc_execute_scb(void *arg, bus_dma_segment_t *dm_segs, int nsegments)
{
	struct	scb *scb;
	struct	scsi_xfer *xs;
	struct	ahc_softc *ahc;
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;

	u_int	mask;
	int	s;

	scb = (struct scb *)arg;
	xs = scb->xs;
	xs->error = CAM_REQ_INPROG;
	xs->status = 0;
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;

	if (nsegments != 0) {
		struct	  ahc_dma_seg *sg;
		bus_dma_segment_t *end_seg;
		int op;

		end_seg = dm_segs + nsegments;

		/* Copy the segments into our SG list */
		sg = scb->sg_list;
		while (dm_segs < end_seg) {
			uint32_t len;

			sg->addr = aic_htole32(dm_segs->ds_addr);
			len = dm_segs->ds_len
			    | ((dm_segs->ds_addr >> 8) & 0x7F000000);
			sg->len = aic_htole32(len);
			sg++;
			dm_segs++;
		}

		/*
		 * Note where to find the SG entries in bus space.
		 * We also set the full residual flag which the
		 * sequencer will clear as soon as a data transfer
		 * occurs.
		 */
		scb->hscb->sgptr = aic_htole32(scb->sg_list_phys|SG_FULL_RESID);

		if ((xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_PREREAD;
		else
			op = BUS_DMASYNC_PREWRITE;

		bus_dmamap_sync(ahc->parent_dmat, scb->dmamap, 0,
				scb->dmamap->dm_mapsize, op);

		sg--;
		sg->len |= aic_htole32(AHC_DMA_LAST_SEG);

		bus_dmamap_sync(ahc->parent_dmat, scb->sg_map->sg_dmamap,
		    0, scb->sg_map->sg_dmamap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

		/* Copy the first SG into the "current" data pointer area */
		scb->hscb->dataptr = scb->sg_list->addr;
		scb->hscb->datacnt = scb->sg_list->len;
	} else {
		scb->hscb->sgptr = aic_htole32(SG_LIST_NULL);
		scb->hscb->dataptr = 0;
		scb->hscb->datacnt = 0;
	}

	scb->sg_count = nsegments;

	s = splbio();

	tinfo = ahc_fetch_transinfo(ahc, SCSIID_CHANNEL(ahc, scb->hscb->scsiid),
				    SCSIID_OUR_ID(scb->hscb->scsiid),
				    SCSIID_TARGET(ahc, scb->hscb->scsiid),
				    &tstate);

	mask = SCB_GET_TARGET_MASK(ahc, scb);
	scb->hscb->scsirate = tinfo->scsirate;
	scb->hscb->scsioffset = tinfo->curr.offset;

	if ((tstate->ultraenb & mask) != 0)
		scb->hscb->control |= ULTRAENB;

	if ((tstate->discenable & mask) != 0)
		scb->hscb->control |= DISCENB;

	if ((tstate->auto_negotiate & mask) != 0) {
		scb->flags |= SCB_AUTO_NEGOTIATE;
		scb->hscb->control |= MK_MESSAGE;
	}

	if ((tstate->tagenable & mask) != 0)
		scb->hscb->control |= TAG_ENB;

	bus_dmamap_sync(ahc->parent_dmat, ahc->scb_data->hscb_dmamap,
	    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	LIST_INSERT_HEAD(&ahc->pending_scbs, scb, pending_links);

	if (!(xs->flags & SCSI_POLL))
		timeout_add_msec(&xs->stimeout, xs->timeout);

	/*
	 * We only allow one untagged transaction
	 * per target in the initiator role unless
	 * we are storing a full busy target *lun*
	 * table in SCB space.
	 *
	 * This really should not be of any
	 * concern, as we take care to avoid this
	 * in ahc_done().  XXX smurph
	 */
	if ((scb->hscb->control & (TARGET_SCB|TAG_ENB)) == 0
	    && (ahc->flags & AHC_SCB_BTT) == 0) {
		struct scb_tailq *untagged_q;
		int target_offset;

		target_offset = SCB_GET_TARGET_OFFSET(ahc, scb);
		untagged_q = &(ahc->untagged_queues[target_offset]);
		TAILQ_INSERT_TAIL(untagged_q, scb, links.tqe);
		scb->flags |= SCB_UNTAGGEDQ;
		if (TAILQ_FIRST(untagged_q) != scb) {
			if (xs->flags & SCSI_POLL)
				goto poll;
			else {
				splx(s);
				return;
			}
		}
	}
	scb->flags |= SCB_ACTIVE;

	if ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {
		/* Define a mapping from our tag to the SCB. */
		ahc->scb_data->scbindex[scb->hscb->tag] = scb;
		ahc_pause(ahc);
		if ((ahc->flags & AHC_PAGESCBS) == 0)
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
		ahc_outb(ahc, TARG_IMMEDIATE_SCB, scb->hscb->tag);
		ahc_unpause(ahc);
	} else {
		ahc_queue_scb(ahc, scb);
	}

	if (!(xs->flags & SCSI_POLL)) {
		if (ahc->inited_target[xs->sc_link->target] == 0) {
			struct	ahc_devinfo devinfo;

			ahc_adapter_req_set_xfer_mode(ahc, scb);
			ahc_scb_devinfo(ahc, &devinfo, scb);
			ahc_update_neg_request(ahc, &devinfo, tstate, tinfo,
			    AHC_NEG_IF_NON_ASYNC);

			ahc->inited_target[xs->sc_link->target] = 1;
		}
		splx(s);
		return;
	}

	/*
	 * If we can't use interrupts, poll for completion
	 */
poll:
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("cmd_poll\n"));

	do {
		if (ahc_poll(ahc, xs->timeout)) {
			if (!(xs->flags & SCSI_SILENT))
				printf("cmd fail\n");
			ahc_timeout(scb);
			break;
		}
	} while (!(xs->flags & ITSDONE));

	splx(s);
}

int
ahc_poll(struct ahc_softc *ahc, int wait)
{
	while (--wait) {
		DELAY(1000);
		if (ahc_inb(ahc, INTSTAT) & INT_PEND)
			break;
	}

	if (wait == 0) {
		printf("%s: board is not responding\n", ahc_name(ahc));
		return (EIO);
	}

	ahc_intr((void *)ahc);
	return (0);
}

void
ahc_setup_data(struct ahc_softc *ahc, struct scsi_xfer *xs,
	       struct scb *scb)
{
	struct hardware_scb *hscb;

	hscb = scb->hscb;
	xs->resid = xs->status = 0;
	xs->error = CAM_REQ_INPROG;

	hscb->cdb_len = xs->cmdlen;
	if (hscb->cdb_len > sizeof(hscb->cdb32)) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	if (hscb->cdb_len > 12) {
		memcpy(hscb->cdb32, xs->cmd, hscb->cdb_len);
		scb->flags |= SCB_CDB32_PTR;
	} else {
		memcpy(hscb->shared_data.cdb, xs->cmd, hscb->cdb_len);
	}

	/* Only use S/G if there is a transfer */
	if (xs->datalen) {
		int error;

                error = bus_dmamap_load(ahc->parent_dmat,
					scb->dmamap, xs->data,
					xs->datalen, NULL,
					(xs->flags & SCSI_NOSLEEP) ?
					BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
#ifdef AHC_DEBUG
                        printf("%s: in ahc_setup_data(): bus_dmamap_load() "
			       "= %d\n",
			       ahc_name(ahc), error);
#endif
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}
		ahc_execute_scb(scb, scb->dmamap->dm_segs,
		    scb->dmamap->dm_nsegs);
	} else {
		ahc_execute_scb(scb, NULL, 0);
	}
}

void
ahc_timeout(void *arg)
{
	struct	scb *scb, *list_scb;
	struct	ahc_softc *ahc;
	int	s;
	int	found;
	char	channel;

	scb = (struct scb *)arg;
	ahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;

	s = splbio();

#ifdef AHC_DEBUG
	printf("%s: SCB %d timed out\n", ahc_name(ahc), scb->hscb->tag);
	ahc_dump_card_state(ahc);
#endif

	ahc_pause(ahc);

	if (scb->flags & SCB_ACTIVE) {
		channel = SCB_GET_CHANNEL(ahc, scb);
		ahc_set_transaction_status(scb, CAM_CMD_TIMEOUT);
		/*
		 * Go through all of our pending SCBs and remove
		 * any scheduled timeouts for them. They're about to be
		 * aborted so no need for them to timeout.
		 */
		LIST_FOREACH(list_scb, &ahc->pending_scbs, pending_links) {
			if (list_scb->xs)
				timeout_del(&list_scb->xs->stimeout);
		}
		found = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);
#ifdef AHC_DEBUG
		printf("%s: Issued Channel %c Bus Reset %d SCBs aborted\n",
		    ahc_name(ahc), channel, found);
#endif
	}

	ahc_unpause(ahc);
	splx(s);
}


void
ahc_platform_set_tags(struct ahc_softc *ahc,
		      struct ahc_devinfo *devinfo, int alg)
{
	struct ahc_tmode_tstate *tstate;

	ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
			    devinfo->target, &tstate);

	/* XXXX Need to check quirks before doing this! XXXX */

	switch (alg) {
	case AHC_QUEUE_BASIC:
	case AHC_QUEUE_TAGGED:
		tstate->tagenable |= devinfo->target_mask;
		break;
	case AHC_QUEUE_NONE:
		tstate->tagenable &= ~devinfo->target_mask;
		break;
	}
}

int
ahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg)
{
	if (sizeof(struct ahc_platform_data) > 0) {
		ahc->platform_data = malloc(sizeof(struct ahc_platform_data),
		    M_DEVBUF, M_NOWAIT | M_ZERO);
		if (ahc->platform_data == NULL)
			return (ENOMEM);
	}

	return (0);
}

void
ahc_platform_free(struct ahc_softc *ahc)
{
	if (sizeof(struct ahc_platform_data) > 0)
		free(ahc->platform_data, M_DEVBUF, 0);
}

int
ahc_softc_comp(struct ahc_softc *lahc, struct ahc_softc *rahc)
{
	return (0);
}

void
ahc_send_async(struct ahc_softc *ahc, char channel, u_int target, u_int lun,
		ac_code code, void *opt_arg)
{
	/* Nothing to do here for OpenBSD */
}

void
ahc_adapter_req_set_xfer_mode(struct ahc_softc *ahc, struct scb *scb)
{
	struct ahc_initiator_tinfo *tinfo;
	struct ahc_tmode_tstate *tstate;
	struct ahc_syncrate *syncrate;
	struct ahc_devinfo devinfo;
	u_int16_t quirks;
	u_int width, ppr_options, period, offset;
	int s;

	s = splbio();

	ahc_scb_devinfo(ahc, &devinfo, scb);
	quirks = scb->xs->sc_link->quirks;
	tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
	    devinfo.our_scsiid, devinfo.target, &tstate);

	tstate->discenable |= (ahc->user_discenable & devinfo.target_mask);

	if (quirks & SDEV_NOTAGS)
		tstate->tagenable &= ~devinfo.target_mask;
	else if (ahc->user_tagenable & devinfo.target_mask)
		tstate->tagenable |= devinfo.target_mask;

	if (quirks & SDEV_NOWIDE)
		width = MSG_EXT_WDTR_BUS_8_BIT;
	else
		width = MSG_EXT_WDTR_BUS_16_BIT;

	ahc_validate_width(ahc, NULL, &width, ROLE_UNKNOWN);
	if (width > tinfo->user.width)
		width = tinfo->user.width;
	ahc_set_width(ahc, &devinfo, width, AHC_TRANS_GOAL, FALSE);

	if (quirks & SDEV_NOSYNC) {
		period = 0;
		offset = 0;
	} else {
		period = tinfo->user.period;
		offset = tinfo->user.offset;
	}

	/* XXX Look at saved INQUIRY flags for PPR capabilities XXX */
	ppr_options = tinfo->user.ppr_options;
	/* XXX Other reasons to avoid ppr? XXX */
	if (width < MSG_EXT_WDTR_BUS_16_BIT)
		ppr_options = 0;

	if ((tstate->discenable & devinfo.target_mask) == 0 ||
	    (tstate->tagenable & devinfo.target_mask) == 0)
		ppr_options &= ~MSG_EXT_PPR_PROT_IUS;

	syncrate = ahc_find_syncrate(ahc, &period, &ppr_options,
	    AHC_SYNCRATE_MAX);
	ahc_validate_offset(ahc, NULL, syncrate, &offset, width,
	    ROLE_UNKNOWN);

	if (offset == 0) {
		period = 0;
		ppr_options = 0;
	}

	if (ppr_options != 0 && tinfo->user.transport_version >= 3) {
		tinfo->goal.transport_version = tinfo->user.transport_version;
		tinfo->curr.transport_version = tinfo->user.transport_version;
	}

	ahc_set_syncrate(ahc, &devinfo, syncrate, period, offset, ppr_options,
	    AHC_TRANS_GOAL, FALSE);

	splx(s);
}

/*
 * Get a free scb. If there are none, see if we can allocate a new SCB.
 */
void *
ahc_scb_alloc(void *xahc)
{
	struct ahc_softc *ahc = xahc;
	struct scb *scb;

	mtx_enter(&ahc->sc_scb_mtx);
	scb = SLIST_FIRST(&ahc->scb_data->free_scbs);

	if (scb != NULL)
		SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links.sle);

	mtx_leave(&ahc->sc_scb_mtx);

	return (scb);
}

/*
 * Return an SCB resource to the free list.
 */
void
ahc_scb_free(void *xahc, void *io)
{
	struct ahc_softc *ahc = xahc;
	struct scb *scb = io;
	struct hardware_scb *hscb;

	hscb = scb->hscb;
	/* Clean up for the next user */
	ahc->scb_data->scbindex[hscb->tag] = NULL;
	scb->flags = SCB_FLAG_NONE;
	hscb->control = 0;

	mtx_enter(&ahc->sc_scb_mtx);
	SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links.sle);
	mtx_leave(&ahc->sc_scb_mtx);

	/* Notify the OSM that a resource is now available. */
	ahc_platform_scb_free(ahc, scb);
}
@


1.54
log
@Nuke a bunch of leading and trailing whitespace so I don't go blind
reading this code. No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.53 2014/07/12 18:48:17 tedu Exp $	*/
d92 1
a163 1
	int s;
a256 2
        s = splbio();
	ahc_free_scb(ahc, scb);
a257 1
        splx(s);
a283 1
	int s;
d292 1
a292 1
	 * get an scb to use.
d294 4
a297 8
	s = splbio();
	scb = ahc_get_scb(ahc);
	splx(s);
	if (scb == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
d300 2
a527 1
	int s;
a534 3
		s = splbio();
		ahc_free_scb(ahc, scb);
		splx(s);
a561 3
			s = splbio();
			ahc_free_scb(ahc, scb);
			splx(s);
d745 44
@


1.53
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.52 2014/01/17 23:25:07 dlg Exp $	*/
d99 1
a99 1
#ifndef DEBUG		
d257 1
a257 1
        s = splbio();       
d260 1
a260 1
        splx(s);       
d352 1
a352 1
		
d370 1
a370 1
		 * We also set the full residual flag which the 
d417 1
a417 1
	    	scb->hscb->control |= DISCENB;
d458 1
a458 1
			else {		
d556 1
a556 1
		
d729 1
a729 1
	/* XXX Look at saved INQUIRY flags for PPR capabilities XXX */ 
@


1.52
log
@if the hardware is too busy or its queues are too full, return XS_BUSY,
not XS_NO_CCB.

discussed with krw@@ who agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.51 2011/07/17 22:46:48 matthew Exp $	*/
d670 1
a670 1
		free(ahc->platform_data, M_DEVBUF);
@


1.51
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.50 2011/07/05 22:40:57 matthew Exp $	*/
a201 2
			xs->error = XS_NO_CCB;
			break;
d218 1
a227 3
		break;
	case CAM_REQUEUE_REQ:
		xs->error = XS_NO_CCB;
@


1.50
log
@Call bzero(&saa, sizeof(saa)) each time we use saa to attach
something.  Doesn't matter right now because scsibus_attach_args only
has one field and it's mandatory, but I'm planning to move some more
fields from scsi_link to scsibus_attach_args+scsibus_softc.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.49 2011/07/04 22:17:23 matthew Exp $	*/
a96 1
		ahc->sc_channel_b.flags |= SDEV_2NDBUS;
d114 1
a115 1
		bzero(&saa, sizeof(saa));
a119 1
			bzero(&saa, sizeof(saa));
a125 1
			bzero(&saa, sizeof(saa));
a129 1
		bzero(&saa, sizeof(saa));
@


1.49
log
@Use the SDEV_2NDBUS flag like isp(4) instead of the current
scsi_link::scsibus hack to determine which channel the link is
associated with.

"looks sane" dlg@@, but haven't found any testers yet; committing so
further SCSI refactorings can go in.  dlg@@ or I will back out or fix
if anything breaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.48 2010/06/28 18:31:02 krw Exp $	*/
a114 1
	bzero(&saa, sizeof(saa));
d116 1
d121 1
d128 1
d133 1
@


1.48
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.47 2010/06/02 08:19:35 dlg Exp $	*/
d97 1
@


1.47
log
@dont drop out of handling a command if ITSDONE is set. return a better
error to the midlayer if something screws up.

scrub the code slightly while here.

this plus src/sys/scsi/scsi_base.c r1.174 seems to fix problems henning has
had with tape drives plugged into ahc.

tested by and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.46 2010/03/23 01:57:19 krw Exp $	*/
a71 9
/* the below structure is so we have a default dev struct for our link struct */
static struct scsi_device ahc_dev =
{
	NULL, /* Use default error handler */
	NULL, /* have a queue, served by this */
	NULL, /* have no async handler */
	NULL, /* Use default 'done' routine */
};

a91 1
	ahc->sc_channel.device = &ahc_dev;
@


1.46
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.45 2010/01/20 08:40:41 krw Exp $	*/
d313 3
a315 1
	if ((scb = ahc_get_scb(ahc)) == NULL) {
a317 1
		splx(s);
a319 1
	splx(s);
a417 13
	/*
	 * Last time we need to check if this SCB needs to
	 * be aborted.
	 */
	if (xs->flags & ITSDONE) {
		if (nsegments != 0)
			bus_dmamap_unload(ahc->parent_dmat, scb->dmamap);

		ahc_free_scb(ahc, scb);
		splx(s);
		return;
	}

d558 1
a560 1
		splx(s);
d588 2
a589 1
			xs->error = XS_NO_CCB;
a590 1
			splx(s);
d592 1
a592 1
}
@


1.45
log
@Remove horrible hack in ahc/ahd that made some commands retry
endlessly.  Use the shiny new XS_NO_CCB instead to retry commands
that can't start. Neither dlg@@ nor I can figure out why 4.6 and
earlier worked.

Problem noted, debugged with and fix tested by Jeff Ross and his
new external enclosure. Thanks!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.44 2010/01/10 00:10:23 krw Exp $	*/
d51 2
a52 2
int	ahc_action(struct scsi_xfer *);
int	ahc_execute_scb(void *, bus_dma_segment_t *, int);
d54 1
a54 1
int	ahc_setup_data(struct ahc_softc *, struct scsi_xfer *, struct scb *);
d293 1
a293 1
int32_t
d314 2
d317 1
a317 1
		return (NO_CCB);
d337 2
a338 1
		return (ahc_execute_scb(scb, NULL, 0));
d341 1
a341 1
	return (ahc_setup_data(ahc, xs, scb));
d344 1
a344 1
int
d428 1
a428 1
		return (COMPLETE);
d487 1
a487 1
				return (SUCCESSFULLY_QUEUED);
d517 1
a517 1
		return (SUCCESSFULLY_QUEUED);
a535 1
	return (COMPLETE);
d556 1
a556 1
int
d574 1
a574 1
		return (COMPLETE);
d601 2
d604 1
a604 1
			return (NO_CCB);	/* XXX fvdl */
d606 2
a607 4
		error = ahc_execute_scb(scb,
					scb->dmamap->dm_segs,
					scb->dmamap->dm_nsegs);
		return error;
d609 1
a609 1
		return ahc_execute_scb(scb, NULL, 0);
@


1.44
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.43 2009/11/22 14:14:10 krw Exp $	*/
d212 1
a212 8
			/* SCSI Layer won't requeue, so we force infinite
			 * retries until queue space is available. XS_BUSY
			 * is dangerous because if the NOSLEEP flag is set
			 * it can cause the I/O to return EIO. XS_BUSY code
			 * falls through to XS_TIMEOUT anyway.
			 */
			xs->error = XS_TIMEOUT;
			xs->retries++;
d241 1
a241 2
		xs->error = XS_TIMEOUT;
		xs->retries++;
@


1.43
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.42 2009/02/16 21:19:06 miod Exp $	*/
a280 1
	xs->flags |= ITSDONE;
a577 1
		xs->flags |= ITSDONE;
@


1.42
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.41 2009/01/21 21:53:59 grange Exp $	*/
d610 1
a610 1
			return (TRY_AGAIN_LATER);	/* XXX fvdl */
@


1.41
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.40 2008/11/25 18:10:00 krw Exp $	*/
d56 1
a56 1
void	ahc_minphys(struct buf *);
d287 1
a287 2
ahc_minphys(bp)
	struct buf *bp;
@


1.40
log
@dontqueue is set but never used. garbage collect it.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.39 2008/11/24 00:31:35 krw Exp $	*/
d468 1
a468 1
		timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);
@


1.39
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.38 2008/05/13 02:24:08 brad Exp $	*/
a311 1
	int dontqueue = 0;
a314 3

	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;
@


1.38
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.37 2007/10/20 00:21:49 krw Exp $	*/
d329 1
a329 1
		return (TRY_AGAIN_LATER);
@


1.37
log
@Put scsi_done() invocations inside existing splbio/splx pairs to make
damned sure scsi_done is invoked at splbio. Noted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.36 2007/09/07 17:58:39 krw Exp $	*/
a41 3

#include <sys/cdefs.h>
/* __KERNEL_RCSID(0, "$NetBSD: aic7xxx_osm.c,v 1.14 2003/11/02 11:07:44 wiz Exp $"); */
@


1.36
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.35 2007/08/04 14:37:34 krw Exp $	*/
a283 2
        splx(s);       

d286 1
a585 1
		splx(s);
d589 1
@


1.35
log
@Since ahc_controller_info()'s definition is inside #ifndef DEBUG, put
it's declaration and only use inside #ifndef DEBUG too. Lets DEBUG
kernel compile again. Non-DEBUG kernel still compiles too.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.34 2007/05/02 02:20:37 krw Exp $	*/
d702 1
a702 1
		    M_DEVBUF, M_NOWAIT);
a704 1
		bzero(ahc->platform_data, sizeof(struct ahc_platform_data));
@


1.34
log
@Eliminate unused inline functions and replace ahc_lock() which
resolves to s = splbio() and ahc_unlock() which resolves to splx(s)
with splbio/splx calls.

ok marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.33 2006/11/28 23:59:45 dlg Exp $	*/
a90 1
	char ahc_info[256];
d112 1
d114 1
d118 1
@


1.33
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.32 2006/03/04 14:20:37 krw Exp $	*/
d94 1
a94 1
        ahc_lock(ahc, &s);
d146 1
a146 1
	ahc_unlock(ahc, &s);
d280 1
a280 1
        ahc_lock(ahc, &s);       
d282 1
a282 1
        ahc_unlock(ahc, &s);       
d328 1
a328 1
	ahc_lock(ahc, &s);
d330 1
a330 1
		ahc_unlock(ahc, &s);
d333 1
a333 1
	ahc_unlock(ahc, &s);
d429 1
a429 1
	ahc_lock(ahc, &s);
d440 1
a440 1
		ahc_unlock(ahc, &s);
d499 1
a499 1
				ahc_unlock(ahc, &s);
d529 1
a529 1
		ahc_unlock(ahc, &s);
d548 1
a548 1
	ahc_unlock(ahc, &s);
d583 1
a583 1
		ahc_lock(ahc, &s);
d585 1
a585 1
		ahc_unlock(ahc, &s);
d614 1
a614 1
			ahc_lock(ahc, &s);
d616 1
a616 1
			ahc_unlock(ahc, &s);
d640 1
a640 1
	ahc_lock(ahc, &s);
d669 1
a669 1
	ahc_unlock(ahc, &s);
@


1.32
log
@All CAM_* values stored in xs->error must be 'interpreted' by
ah[cd]_done() into XS_* values understood by the SCSI code before
returning xs to the tender mercies of the SCSI code.

So if we bail out without calling ah[cd]_done(), because the request
cdb length is excessive, don't use ah[cd]_set_transaction() to put
CAM_REQ_INVALID into xs->error, just jam in XS_DRIVER_STUFFUP as
ah[cd]_done() would have. If CAM_REQ_INVALID escapes it will be
interpreted as XS_SHORT_SENSE as far as I can tell.

This code path should never be trod so the net effect should be
minimal.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.31 2005/12/28 03:00:07 krw Exp $	*/
d90 1
d125 1
d127 1
d129 3
a131 2
		    &ahc->sc_channel, scsiprint);
		if (ahc->features & AHC_TWIN)
d133 2
a134 1
			    &ahc->sc_channel_b, scsiprint);
d136 2
a137 1
		if (ahc->features & AHC_TWIN)
d139 3
a141 1
			    &ahc->sc_channel_b, scsiprint);
d143 1
a143 1
		    &ahc->sc_channel, scsiprint);
@


1.31
log
@Strip out fancy timeout code that attempts to mimic FreeBSD's thread
based timeout handling. Use the simple timeout == bus reset model
instead. Also move verbose debug output inside #ifdef/#endif.

Fixes pulling out a raidctl disk causing a crash noted by kurt@@.
Rebuilding the raid still problematic.

Reduces but does not eliminate crashes with 'smartctl -d scsi -a
/dev/rcd0c' seen by Sigfried H?versen.

Should only impact timeout handling. No change to normal processing.

Thanks to kurt@@ and Sigfied for testing.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.30 2005/11/02 03:27:39 krw Exp $	*/
a574 1
		ahc_set_transaction_status(scb, CAM_REQ_INVALID);
d578 1
@


1.30
log
@It is invalid to scsi_done(xs) and then return TRY_AGAIN_LATER.
scsi_done() can release the scsi_request xs and TRY_AGAIN_LATER will
refer to it and submit it for re-execution. This was being done only
if bus_dmamap_load() failed.

Ensure the controller resources are freed before returning
TRY_AGAIN_LATER, since new resources will be allocated when the
command is executed again.

Don't bother setting xs->error before returning TRY_AGAIN_LATER as the
code returned to sets xs->error to XS_BUSY.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.29 2005/02/12 15:32:12 krw Exp $	*/
a57 1
void	ahc_set_recoveryscb(struct ahc_softc *, struct scb *);
a197 25
	/*
	 * If the recovery SCB completes, we have to be
	 * out of our timeout.
	 */
	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
		struct	scb *list_scb;

		/*
		 * We were able to complete the command successfully,
		 * so reinstate the timeouts for all other pending
		 * commands.
		 */
		LIST_FOREACH(list_scb, &ahc->pending_scbs, pending_links) {
			struct scsi_xfer *txs = list_scb->xs;
			if (!(txs->flags & SCSI_POLL))
				timeout_add(&list_scb->xs->stimeout,
				    (list_scb->xs->timeout * hz)/1000);
		}

		if (xs->error != CAM_REQ_INPROG)
			ahc_set_transaction_status(scb, CAM_CMD_TIMEOUT);
		ahc_print_path(ahc, scb);
		printf("no longer in timeout, status = %x\n", xs->status);
	}

a620 19
ahc_set_recoveryscb(struct ahc_softc *ahc, struct scb *scb) {

	if ((scb->flags & SCB_RECOVERY_SCB) == 0) {
		struct scb *list_scb;

		scb->flags |= SCB_RECOVERY_SCB;

		/*
		 * Go through all of our pending SCBs and remove
		 * any scheduled timeouts for them.  We will reschedule
		 * them after we've successfully fixed this problem.
		 */
		LIST_FOREACH(list_scb, &ahc->pending_scbs, pending_links) {
			timeout_del(&list_scb->xs->stimeout);
		}
	}
}

void
d623 1
a623 1
	struct	scb *scb;
a626 4
	u_int	last_phase;
	int	target;
	int	lun;
	int	i;
d634 4
a637 10
	ahc_pause_and_flushwork(ahc);

	if ((scb->flags & SCB_ACTIVE) == 0) {
		/* Previous timeout took care of me already */
		printf("%s: Timed out SCB already complete. "
		       "Interrupts may not be functioning.\n", ahc_name(ahc));
		ahc_unpause(ahc);
		ahc_unlock(ahc, &s);
		return;
	}
d639 1
a639 3
	target = SCB_GET_TARGET(ahc, scb);
	channel = SCB_GET_CHANNEL(ahc, scb);
	lun = SCB_GET_LUN(scb);
d641 2
a642 18
	ahc_print_path(ahc, scb);
	printf("SCB 0x%x - timed out\n", scb->hscb->tag);
	ahc_dump_card_state(ahc);
	last_phase = ahc_inb(ahc, LASTPHASE);
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x : Length %d\n",
			       i,
			       scb->sg_list[i].addr,
			       scb->sg_list[i].len & AHC_SG_LEN_MASK);
		}
	}
	if (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {
		/*
		 * Been down this road before.
		 * Do a full bus reset.
		 */
bus_reset:
a643 4
		found = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), channel, found);
	} else {
d645 3
a647 20
		 * If we are a target, transition to bus free and report
		 * the timeout.
		 * 
		 * The target/initiator that is holding up the bus may not
		 * be the same as the one that triggered this timeout
		 * (different commands have different timeout lengths).
		 * If the bus is idle and we are acting as the initiator
		 * for this request, queue a BDR message to the timed out
		 * target.  Otherwise, if the timed out transaction is
		 * active:
		 *   Initiator transaction:
		 *	Stuff the message buffer with a BDR message and assert
		 *	ATN in the hopes that the target will let go of the bus
		 *	and go to the mesgout phase.  If this fails, we'll
		 *	get another timeout 2 seconds later which will attempt
		 *	a bus reset.
		 *
		 *   Target transaction:
		 *	Transition to BUS FREE and report the error.
		 *	It's good to be the target!
d649 3
a651 174
		u_int active_scb_index;
		u_int saved_scbptr;

		bus_dmamap_sync(ahc->parent_dmat,
		    ahc->scb_data->hscb_dmamap,
		    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		saved_scbptr = ahc_inb(ahc, SCBPTR);
		active_scb_index = ahc_inb(ahc, SCB_TAG);

		if ((ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) == 0
		  && (active_scb_index < ahc->scb_data->numscbs)) {
			struct scb *active_scb;

			/*
			 * If the active SCB is not us, assume that
			 * the active SCB has a longer timeout than
			 * the timedout SCB, and wait for the active
			 * SCB to timeout.
			 */ 
			active_scb = ahc_lookup_scb(ahc, active_scb_index);
			if (active_scb != scb) {
				u_int	newtimeout;

				ahc_print_path(ahc, active_scb);
				printf("Other SCB Timeout%s",
			 	       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
				       ? " again\n" : "\n");
				scb->flags |= SCB_OTHERTCL_TIMEOUT;
				newtimeout = MAX(active_scb->xs->timeout,
						 scb->xs->timeout);
				timeout_add(&scb->xs->stimeout,
				    (newtimeout * hz) / 1000);
				ahc_unpause(ahc);
				ahc_unlock(ahc, &s);
				return;
			} 

			/* It's us */
			if ((scb->flags & SCB_TARGET_SCB) != 0) {

				/*
				 * Send back any queued up transactions
				 * and properly record the error condition.
				 */
				ahc_abort_scbs(ahc, SCB_GET_TARGET(ahc, scb),
					       SCB_GET_CHANNEL(ahc, scb),
					       SCB_GET_LUN(scb),
					       scb->hscb->tag,
					       ROLE_TARGET,
					       CAM_CMD_TIMEOUT);

				/* Will clear us from the bus */
				ahc_restart(ahc);
				ahc_unlock(ahc, &s);
				return;
			}

			ahc_set_recoveryscb(ahc, active_scb);
			ahc_outb(ahc, MSG_OUT, HOST_MSG);
			ahc_outb(ahc, SCSISIGO, last_phase|ATNO);
			ahc_print_path(ahc, active_scb);
			printf("BDR message in message buffer\n");
			active_scb->flags |=  SCB_DEVICE_RESET;
			timeout_add(&active_scb->xs->stimeout, 2 * hz);
			ahc_unpause(ahc);
		} else {
			int	 disconnected;

			bus_dmamap_sync(ahc->parent_dmat,
			    ahc->scb_data->hscb_dmamap,
			    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
			/* XXX Shouldn't panic.  Just punt instead */
			if ((scb->flags & SCB_TARGET_SCB) != 0)
				panic("Timed-out target SCB but bus idle");

			if (last_phase != P_BUSFREE
			 && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {
				/* XXX What happened to the SCB? */
				/* Hung target selection.  Goto busfree */
				printf("%s: Hung target selection\n",
				       ahc_name(ahc));
				ahc_restart(ahc);
				ahc_unlock(ahc, &s);
				return;
			}

			if (ahc_search_qinfifo(ahc, target, channel, lun,
					       scb->hscb->tag, ROLE_INITIATOR,
					       /*status*/0, SEARCH_COUNT) > 0) {
				disconnected = FALSE;
			} else {
				disconnected = TRUE;
			}

			if (disconnected) {

				ahc_set_recoveryscb(ahc, scb);
				/*
				 * Actually re-queue this SCB in an attempt
				 * to select the device before it reconnects.
				 * In either case (selection or reselection),
				 * we will now issue a target reset to the
				 * timed-out device.
				 *
				 * Set the MK_MESSAGE control bit indicating
				 * that we desire to send a message.  We
				 * also set the disconnected flag since
				 * in the paging case there is no guarantee
				 * that our SCB control byte matches the
				 * version on the card.  We don't want the
				 * sequencer to abort the command thinking
				 * an unsolicited reselection occurred.
				 */
				scb->hscb->control |= MK_MESSAGE|DISCONNECTED;
				scb->flags |= SCB_DEVICE_RESET;

				/*
				 * Remove any cached copy of this SCB in the
				 * disconnected list in preparation for the
				 * queuing of our abort SCB.  We use the
				 * same element in the SCB, SCB_NEXT, for
				 * both the qinfifo and the disconnected list.
				 */
				ahc_search_disc_list(ahc, target, channel,
						     lun, scb->hscb->tag,
						     /*stop_on_first*/TRUE,
						     /*remove*/TRUE,
						     /*save_state*/FALSE);

				/*
				 * In the non-paging case, the sequencer will
				 * never re-reference the in-core SCB.
				 * To make sure we are notified during
				 * reslection, set the MK_MESSAGE flag in
				 * the card's copy of the SCB.
				 */
				if ((ahc->flags & AHC_PAGESCBS) == 0) {
					ahc_outb(ahc, SCBPTR, scb->hscb->tag);
					ahc_outb(ahc, SCB_CONTROL,
						 ahc_inb(ahc, SCB_CONTROL)
						| MK_MESSAGE);
				}

				/*
				 * Clear out any entries in the QINFIFO first
				 * so we are the next SCB for this target
				 * to run.
				 */
				ahc_search_qinfifo(ahc,
						   SCB_GET_TARGET(ahc, scb),
						   channel, SCB_GET_LUN(scb),
						   SCB_LIST_NULL,
						   ROLE_INITIATOR,
						   CAM_REQUEUE_REQ,
						   SEARCH_COMPLETE);
				ahc_print_path(ahc, scb);
				printf("Queuing a BDR SCB\n");
				ahc_qinfifo_requeue_tail(ahc, scb);
				ahc_outb(ahc, SCBPTR, saved_scbptr);
				timeout_add(&scb->xs->stimeout, 2 * hz);
				ahc_unpause(ahc);
			} else {
				/* Go "immediately" to the bus reset. */
				/* This shouldn't happen. */
				ahc_set_recoveryscb(ahc, scb);
				ahc_print_path(ahc, scb);
				printf("SCB %d: Immediate reset.  "
					"Flags = 0x%x\n", scb->hscb->tag,
					scb->flags);
				goto bus_reset;
			}
d653 5
d659 2
@


1.29
log
@Fix crashes during probe by ensuring that SCSI_IS_SCSIBUS_B() returns
false until scsi bus b is initialized.

Set TWIN_CHNLB bit that is used elsewhere. Missed chunk from last code
sync.

Problem found and fixes tested on HP Proliant ML310 by Valov Oleg.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.28 2005/01/12 00:50:17 krw Exp $	*/
a348 1
		xs->error = XS_DRIVER_STUFFUP;
d593 2
a594 1
	
a600 2
		int s;

d632 3
a634 3
			xs->error = XS_BUSY;
			xs->flags |= ITSDONE;
			scsi_done(xs);
@


1.28
log
@Don't call ahc_setup_data() after calling ahc_execute_scb() since the
scb may have been freed or made active. Only affects XS_RESET case.
More correctly mirrors FreeBSD code. Already done to aic79xx_openbsd.c
in r1.16.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.27 2005/01/08 03:44:36 kevlo Exp $	*/
a125 6
		/*
		 * Ensure SCSI_IS_SCSIBUS_B() returns false for sc_channel
		 * until sc_channel_b has been properly initialized by scsi
		 * layer.
		 */
		ahc->sc_channel_b.scsibus = 0xff;
a131 6
		/*
		 * Ensure SCSI_IS_SCSIBUS_B() returns false for sc_channel_b
		 * until sc_channel has been properly initialized by scsi
		 * layer.
		 */
		ahc->sc_channel.scsibus = 0xff;
@


1.27
log
@fix conflicting types for ahc_send_async().
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.26 2004/12/28 04:12:24 krw Exp $	*/
d382 1
a382 1
		ahc_execute_scb(scb, NULL, 0);
d385 1
a385 1
	return ahc_setup_data(ahc, xs, scb);
@


1.26
log
@Don't allow an infinite number of SCSI bus resets per i/o.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.25 2004/10/24 04:28:33 krw Exp $	*/
d988 1
a988 1
		u_int code, void *opt_arg)
@


1.25
log
@Shuffle defines around so that ahc and ahd use the aic_ names that
come with the freebsd sources, rather than duplicating those names in
the ahd_ and ahc_ namespaces. Big reduction in delta to freebsd
sources, which reduces noise when updating the code.

No .o differences found on i386.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.24 2004/09/24 14:56:56 henning Exp $	*/
d277 1
@


1.24
log
@timedout is not an english word, complaint from theo, ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.23 2004/08/13 23:38:54 krw Exp $	*/
d305 1
a305 1
		    ahc_le32toh(scb->sg_list->len) & AHC_SG_LEN_MASK);
d417 1
a417 1
			sg->addr = ahc_htole32(dm_segs->ds_addr);
d420 1
a420 1
			sg->len = ahc_htole32(len);
d431 1
a431 1
		scb->hscb->sgptr = ahc_htole32(scb->sg_list_phys|SG_FULL_RESID);
d442 1
a442 1
		sg->len |= ahc_htole32(AHC_DMA_LAST_SEG);
d452 1
a452 1
		scb->hscb->sgptr = ahc_htole32(SG_LIST_NULL);
@


1.23
log
@Fix issue with auto request sense handling for both ahc and ahd.

Restore hppa functionality, add sgi functionality for ahc.

ok deraadt@@, plus marco@@, mickey@@, pefo@@ for various bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.22 2004/08/01 01:36:23 krw Exp $	*/
d700 1
a700 1
		printf("%s: Timedout SCB already complete. "
@


1.22
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.21 2004/01/24 15:49:31 krw Exp $	*/
d238 1
@


1.21
log
@Do *not* set scsi_link flags to SCSIDEBUG_LEVEL for every ahc device.
Let scsi_probedev() set the flags based on scsidebug_targets and
scsidebug_luns when a device scsi link is created.

Elminates indisciminate flood of debug info for ahc scsi buses and solves
mystery of why ahc devices produced info when other devices were silent.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.20 2004/01/17 14:40:55 krw Exp $	*/
d92 1
a92 5
	int i, s;

	LIST_INIT(&ahc->pending_scbs);
	for (i = 0; i < AHC_NUM_TARGETS; i++)
		TAILQ_INIT(&ahc->untagged_queues[i]);
a306 3
	if (scb->flags & SCB_FREEZE_QUEUE) {
		scb->flags &= ~SCB_FREEZE_QUEUE;
	}
d368 1
a382 2
	timeout_set(&xs->stimeout, ahc_timeout, scb);

a557 1

@


1.20
log
@Major stability improvement. Fix a variety of systems and problems
by dealing with various error conditions.

Testing by Marco Peereboom, Olivier Cherrier, Alex Holst, Daniel Lucq,
deraadt@@, beck@@ and others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.19 2004/01/17 04:56:33 krw Exp $	*/
a109 1
	ahc->sc_channel.flags = SCSIDEBUG_LEVEL;
@


1.19
log
@Fix SC_DEBUG() call so ahc compiles with SCSIDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.18 2004/01/07 17:08:32 krw Exp $	*/
d54 5
a58 9
int32_t		ahc_action(struct scsi_xfer *);
int		ahc_execute_scb(void *, bus_dma_segment_t *, int);
int		ahc_poll(struct ahc_softc *, int);
int		ahc_setup_data(struct ahc_softc *, struct scsi_xfer *,
			       struct scb *);
void		ahc_set_recoveryscb(struct ahc_softc *, struct scb *);

static void	ahc_minphys(struct buf *);
void		ahc_adapter_req_set_xfer_mode(struct ahc_softc *, struct scb *);
d60 2
d245 26
a270 1
		xs->error = XS_NOERROR;
d280 1
d282 2
a283 1
		xs->error = XS_RESET;
d324 1
a324 1
static void
d405 1
a405 1
	int	s, target;
d503 1
a503 1
		ahc_set_transaction_tag(scb, TRUE, MSG_SIMPLE_TASK);
d557 11
a577 17
	target = xs->sc_link->target;
	if (ahc->inited_target[target] == INITED_TARGET_INQUIRYOK) {
		struct	ahc_initiator_tinfo *tinfo;
		struct	ahc_tmode_tstate *tstate;
		struct	ahc_devinfo devinfo;

		ahc_adapter_req_set_xfer_mode(ahc, scb);

		ahc_scb_devinfo(ahc, &devinfo, scb);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
		    devinfo.our_scsiid, devinfo.target, &tstate);
		ahc_update_neg_request(ahc, &devinfo, tstate, tinfo,
		    AHC_NEG_IF_NON_ASYNC);

		ahc->inited_target[target] = INITED_TARGET_MODEOK;
	}

a586 5
	if (ahc->inited_target[target] == INITED_TARGET_START) {
		if ((xs->cmd->opcode == INQUIRY) && (xs->error == XS_NOERROR))
			ahc->inited_target[target] = INITED_TARGET_INQUIRYOK;
	}

d627 1
d655 1
@


1.18
log
@Fix crash reported in pr/3630. Poll all scsi requests that have SCSI_POLL set.

ok miod@@ tdeval@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.17 2004/01/05 01:09:18 krw Exp $	*/
d349 1
a349 1
	SC_DEBUG(periph, SCSIPI_DB3, ("start scb(%p)\n", scb));
@


1.17
log
@Reduce ahc verbosity. Put chip details inside an if (bootverbose) {}
block. Put irq on first ahc line after 'rev 0xYY', rather than a
separate line.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.16 2003/12/28 21:29:27 krw Exp $	*/
d509 6
a514 2
			ahc_unlock(ahc, &s);
			return (SUCCESSFULLY_QUEUED);
d539 1
@


1.16
log
@Give i/o's requeued as a result of aborts, timeouts, etc. a status of
XS_RESET rather than XS_NOERROR. This prevents unfinished i/o's from
being treated as successfully completed ones.

Don't bother setting SCB_REQUEUE in scb->flags since the scb is
immediately thrown away.

Make setting TAG_ENB a little more correct by doing it somewhere both
the initial scb setup and subsequent tag resets have access to.

Fix a typo.

ok miod "I'm not an authoritative person on SCSI issues... though I'm
learning!" @@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.c,v 1.15 2003/12/24 22:45:45 krw Exp $	*/
d120 4
a123 2
	ahc_controller_info(ahc, ahc_info, sizeof ahc_info);
	printf("%s: %s\n", ahc->sc_dev.dv_xname, ahc_info);
@


1.15
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d255 1
a260 4
	case CAM_REQUEUE_REQ:
		scb->flags |= SCB_REQUEUE;
		xs->error = XS_NOERROR;
		break;
d475 2
a476 12
	if ((tstate->tagenable & mask) != 0) {
		switch (xs->cmd->opcode) {
		case INQUIRY:
		case TEST_UNIT_READY:
		case REQUEST_SENSE:
			/* Don't use tagged i/o on these commands */
			break;
		default:
			scb->hscb->control |= TAG_ENB;
			break;
		}
	}
d907 2
a908 2
				/* Go "immediatly" to the bus reset */
				/* This shouldn't happen */
@


1.14
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 3
d35 1
a35 1
 * $Id: aic7xxx_openbsd.c,v 1.13 2003/09/29 19:28:16 mickey Exp $
d37 4
a40 2
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx_freebsd.c,v 1.26 2001/07/18 21:39:47 gibbs Exp $
 * $OpenBSD: aic7xxx_openbsd.c,v 1.13 2003/09/29 19:28:16 mickey Exp $
d43 3
d49 17
a69 3
int32_t		ahc_action(struct scsi_xfer *xs);
static void	ahc_minphys(struct buf *bp);

a86 31
#ifndef AHC_TMODE_ENABLE
#define AHC_TMODE_ENABLE 0
#endif

#define ccb_scb_ptr spriv_ptr0

#ifdef AHC_DEBUG
int     ahc_debug = AHC_DEBUG;
#endif

#if UNUSED
static void     ahc_dump_targcmd(struct target_cmd *cmd);
#endif
void		ahc_build_free_scb_list(struct ahc_softc *ahc);
int		ahc_execute_scb(void *arg, bus_dma_segment_t *dm_segs,
				int nsegments);
int		ahc_poll(struct ahc_softc *ahc, int wait);
void		ahc_timeout(void *);
int		ahc_setup_data(struct ahc_softc *ahc,
				    struct scsi_xfer *xs,
			       struct scb *scb);
void		ahc_set_recoveryscb(struct ahc_softc *ahc,
				    struct scb *scb);
int		ahc_init_scbdata(struct ahc_softc *ahc);
void		ahc_fini_scbdata(struct ahc_softc *ahc);
int		ahc_istagged_device(struct ahc_softc *ahc,
					 struct scsi_xfer *xs,
				    int nocmdcheck);
void		ahc_check_tags(struct ahc_softc *ahc,
			       struct scsi_xfer *xs);

d88 1
a88 5
 * Routines to manage busy targets.  The old driver didn't need to
 * pause the sequencer because no device registers were accessed.  Now
 * busy targets are controlled via the device registers and thus, we
 * have to pause the sequencer for chips that don't have the
 * auto-pause feature.  XXX smurph
a89 251
u_int ahc_pause_index_busy_tcl(struct ahc_softc *ahc, u_int tcl);
void  ahc_pause_unbusy_tcl(struct ahc_softc *ahc, u_int tcl);
void  ahc_pause_busy_tcl(struct ahc_softc *ahc, u_int tcl, u_int busyid);

u_int
ahc_pause_index_busy_tcl(ahc, tcl)
	struct ahc_softc *ahc;
	u_int tcl;
{
	u_int retval;
	if (ahc->features & AHC_AUTOPAUSE) {
		retval = ahc_index_busy_tcl(ahc, tcl);
	} else {
		ahc_pause(ahc);
		retval = ahc_index_busy_tcl(ahc, tcl);
		ahc_unpause(ahc);
	}
	return retval;
}

void
ahc_pause_unbusy_tcl(ahc, tcl)
	struct ahc_softc *ahc;
	u_int tcl;
{
	if (ahc->features & AHC_AUTOPAUSE) {
		ahc_unbusy_tcl(ahc, tcl);
	} else {
		ahc_pause(ahc);
		ahc_unbusy_tcl(ahc, tcl);
		ahc_unpause(ahc);
	}
}

void
ahc_pause_busy_tcl(ahc, tcl, busyid)
	struct ahc_softc *ahc;
	u_int tcl;
	u_int busyid;
{
	if (ahc->features & AHC_AUTOPAUSE) {
		ahc_busy_tcl(ahc, tcl, busyid);
	} else {
		ahc_pause(ahc);
		ahc_busy_tcl(ahc, tcl, busyid);
		ahc_unpause(ahc);
	}
}

/* Special routine to force negotiation for OpenBSD */
void
ahc_force_neg(ahc)
	struct ahc_softc *ahc;
{
	int num_targets = AHC_NUM_TARGETS;
	int i;

	if ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)
		num_targets = 8;

	for (i = 0; i < num_targets; i++) {
		struct ahc_initiator_tinfo *tinfo;
		struct ahc_tmode_tstate *tstate;
		u_int our_id;
		u_int target_id;
		char channel;

		channel = 'A';
		our_id = ahc->our_id;
		target_id = i;
		if (i > 7 && (ahc->features & AHC_TWIN) != 0) {
			channel = 'B';
			our_id = ahc->our_id_b;
			target_id = i % 8;
		}
		tinfo = ahc_fetch_transinfo(ahc, channel, our_id,
					    target_id, &tstate);
		tinfo->goal = tinfo->user; /* force negotiation */
		tstate->discenable = ahc->user_discenable;
	}
}

int
ahc_createdmamem(ahc, dmat, size, mapp, vaddr, baddr, seg, nseg, what)
	struct ahc_softc *ahc;
	bus_dma_tag_t dmat;
	int size;
	bus_dmamap_t *mapp;
	caddr_t *vaddr;
	bus_addr_t *baddr;
	bus_dma_segment_t *seg;
	int *nseg;
	const char *what;
{
	int error, level = 0;
	int dma_flags = BUS_DMA_NOWAIT;

	dmat = ahc->parent_dmat;

	if ((ahc->chip & AHC_VL) !=0)
		dma_flags |= ISABUS_DMA_32BIT;

	if ((error = bus_dmamem_alloc(dmat, size, NBPG, 0,
			seg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to %s DMA map for %s, error = %d\n",
			"allocate", ahc_name(ahc), what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamem_map(dmat, seg, *nseg, size, vaddr,
			BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: failed to %s DMA map for %s, error = %d\n",
			"map", ahc_name(ahc), what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamap_create(dmat, size, 1, size, 0,
			dma_flags, mapp)) != 0) {
		printf("%s: failed to %s DMA map for %s, error = %d\n",
			"create", ahc_name(ahc), what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamap_load(dmat, *mapp, *vaddr, size, NULL,
			BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to %s DMA map for %s, error = %d\n",
			"load", ahc_name(ahc), what, error);
		goto out;
	}

	*baddr = (*mapp)->dm_segs[0].ds_addr;
	return 0;
out:
	switch (level) {
	case 3:
		bus_dmamap_destroy(dmat, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(dmat, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(dmat, seg, *nseg);
		break;
	default:
		break;
	}

	return error;
}

void
ahc_freedmamem(tag, size, map, vaddr, seg, nseg)
	bus_dma_tag_t tag;
	int size;
	bus_dmamap_t map;
	caddr_t vaddr;
	bus_dma_segment_t *seg;
	int nseg;
{
	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
}

void
ahc_alloc_scbs(ahc)
	struct ahc_softc *ahc;
{
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;
	int dma_flags = 0;

	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX)
		/* Can't allocate any more */
		return;

	next_scb = &scb_data->scbarray[scb_data->numscbs];

	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);

	if (sg_map == NULL)
		return;

	if (ahc_createdmamem(ahc, scb_data->sg_dmat, PAGE_SIZE,
			     &sg_map->sg_dmamap, (caddr_t *)&sg_map->sg_vaddr,
			     &sg_map->sg_physaddr, &sg_map->sg_dmasegs,
			     &sg_map->sg_nseg, "SG space") < 0) {
		free(sg_map, M_DEVBUF);
		return;
	}

	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);

	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;

	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));
	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		struct scb_platform_data *pdata;
		int error;

		pdata = (struct scb_platform_data *)malloc(sizeof(*pdata),
							   M_DEVBUF, M_NOWAIT);
		if (pdata == NULL)
			break;
		bzero(pdata, sizeof(*pdata));
		next_scb->platform_data = pdata;
		next_scb->sg_map = sg_map;
		next_scb->sg_list = segs;
		/*
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
		 */
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->ahc_softc = ahc;
		next_scb->flags = SCB_FREE;

		/* set up AHA-284x correctly. */
		dma_flags = ((ahc->chip & AHC_VL) !=0) ?
			BUS_DMA_NOWAIT|ISABUS_DMA_32BIT :
			BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW;

		ahc->buffer_dmat = ahc->parent_dmat;
		error = bus_dmamap_create(ahc->buffer_dmat,
					  AHC_MAXTRANSFER_SIZE, AHC_NSEG,
					  MAXBSIZE, 0, dma_flags,
					  &next_scb->dmamap);
		if (error !=0)
			break;

		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs,
				  next_scb, links.sle);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
	}
}

d91 1
a91 2
ahc_init_scbdata(ahc)
	struct ahc_softc *ahc;
d93 2
a94 28
	struct scb_data *scb_data;

	scb_data = ahc->scb_data;
	scb_data->init_level = 0;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);

	/* Allocate SCB resources */
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
				 M_DEVBUF, M_NOWAIT);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);
	memset(scb_data->scbarray, 0, sizeof(struct scb) * AHC_SCB_MAX);

	/* set dma tags */
	scb_data->hscb_dmat = ahc->parent_dmat;
	scb_data->sense_dmat = ahc->parent_dmat;
	scb_data->sg_dmat = ahc->parent_dmat;

	/* Determine the number of hardware SCBs and initialize them */
	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		/* SCB 0 heads the free list */
		ahc_outb(ahc, FREE_SCBH, 0);
	} else {
		ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	}
d96 3
a98 4
	if (ahc->scb_data->maxhscbs == 0) {
		printf("%s: No SCB space found\n", ahc_name(ahc));
		return (ENXIO);
	}
d100 1
a100 1
	ahc_build_free_scb_list(ahc);
d103 1
a103 7
	 * Create our DMA mappings.  These tags define the kinds of device
	 * accessible memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
d105 8
a112 29
	if (ahc_createdmamem(ahc, scb_data->hscb_dmat,
	    AHC_SCB_MAX * sizeof(struct hardware_scb),
	    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs,
	    &scb_data->hscb_busaddr, &scb_data->hscb_seg,
	    &scb_data->hscb_nseg, "hardware SCB structures") < 0)
		goto error_exit;

	scb_data->init_level++;

	/* DMA for our sense buffers */
	if (ahc_createdmamem(ahc, scb_data->sense_dmat,
	    AHC_SCB_MAX * sizeof(struct scsi_sense_data),
	    &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,
	    &scb_data->sense_busaddr, &scb_data->sense_seg,
	    &scb_data->sense_nseg, "sense buffers") < 0)
		goto error_exit;

	scb_data->init_level++;

	/* Perform initial CCB allocation */
	memset(scb_data->hscbs, 0, AHC_SCB_MAX * sizeof(struct hardware_scb));
	ahc_alloc_scbs(ahc);

	if (scb_data->numscbs == 0) {
		printf("%s: Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
	}
	scb_data->init_level++;
d114 4
a117 38
	/*
	 * Tell the sequencer which SCB will be the next one it receives.
	 */
	ahc->next_queued_scb = ahc_get_scb(ahc);
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);

	/*
	 * Note that we were successful
	 */
	return (0);

error_exit:

	return (ENOMEM);
}

void
ahc_fini_scbdata(ahc)
	struct ahc_softc *ahc;
{
	struct scb_data *scb_data;

	scb_data = ahc->scb_data;

	switch (scb_data->init_level) {
	default:
	case 3:
	{
		struct sg_map_node *sg_map;

		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_freedmamem(ahc->parent_dmat, PAGE_SIZE,
				       sg_map->sg_dmamap,
				       (caddr_t)sg_map->sg_vaddr,
				       &sg_map->sg_dmasegs, sg_map->sg_nseg);
			free(sg_map, M_DEVBUF);
		}
a118 43
	/*FALLTHROUGH*/
	case 2:
		ahc_freedmamem(ahc->parent_dmat,
			       AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			       scb_data->sense_dmamap, (caddr_t)scb_data->sense,
			       &scb_data->sense_seg, scb_data->sense_nseg);
	/*FALLTHROUGH*/
	case 1:
		ahc_freedmamem(ahc->parent_dmat,
			       AHC_SCB_MAX * sizeof(struct hardware_scb),
			       scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,
			       &scb_data->hscb_seg, scb_data->hscb_nseg);
	/*FALLTHROUGH*/
	}
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF);
}

void
ahc_free(ahc)
	struct ahc_softc *ahc;
{
	ahc_fini_scbdata(ahc);
	if (ahc->init_level != 0)
		ahc_freedmamem(ahc->parent_dmat, ahc->shared_data_size,
		    ahc->shared_data_dmamap, ahc->qoutfifo,
		    &ahc->shared_data_seg, ahc->shared_data_nseg);

	if (ahc->scb_data != NULL)
		free(ahc->scb_data, M_DEVBUF);
	return;
}

/*
 * Attach all the sub-devices we can find
 */
int
ahc_attach(ahc)
	struct ahc_softc *ahc;
{
	char   ahc_info[256];
	int s;
	ahc_lock(ahc, &s);
d121 1
a121 5
	printf("%s: %s\n", ahc_name(ahc), ahc_info);
	/*
	 * Initialize the software queue.
	 */
	LIST_INIT(&ahc->platform_data->sc_xxxq);
d123 1
a123 15
#ifdef AHC_BROKEN_CACHE
	if (cpu_class == CPUCLASS_386)	/* doesn't have "wbinvd" instruction */
		ahc_broken_cache = 0;
#endif
	/*
	 * fill in the prototype scsi_links.
	 */
	ahc->platform_data->sc_link.adapter_target = ahc->our_id;
	if (ahc->features & AHC_WIDE)
		ahc->platform_data->sc_link.adapter_buswidth = 16;
	ahc->platform_data->sc_link.adapter_softc = ahc;
	ahc->platform_data->sc_link.adapter = &ahc_switch;
	ahc->platform_data->sc_link.openings = 2;
	ahc->platform_data->sc_link.device = &ahc_dev;
	ahc->platform_data->sc_link.flags = SCSIDEBUG_LEVEL;
d125 4
a128 12
	if (ahc->features & AHC_TWIN) {
		/* Configure the second scsi bus */
		ahc->platform_data->sc_link_b = ahc->platform_data->sc_link;
		ahc->platform_data->sc_link_b.adapter_target = ahc->our_id_b;
		if (ahc->features & AHC_WIDE)
			ahc->platform_data->sc_link.adapter_buswidth = 16;
		ahc->platform_data->sc_link_b.adapter_softc = ahc;
		ahc->platform_data->sc_link_b.adapter = &ahc_switch;
		ahc->platform_data->sc_link_b.openings = 2;
		ahc->platform_data->sc_link_b.device = &ahc_dev;
		ahc->platform_data->sc_link_b.flags = SCSIDEBUG_LEVEL;
	}
d130 9
a138 7
	/*
	 * ask the adapter what subunits are present
	 */
	if (ahc->platform_data->channel_b_primary == FALSE) {
		/* make SCSI_IS_SCSIBUS_B() == false, while probing channel A */
		ahc->platform_data->sc_link_b.scsibus = 0xff;
		config_found((void *)ahc, &ahc->platform_data->sc_link, scsiprint);
d140 2
a141 1
			config_found((void *)ahc, &ahc->platform_data->sc_link_b, scsiprint);
d144 3
a146 3
		 * if implementation of SCSI_IS_SCSIBUS_B() is changed to use
		 * ahc->sc_link.scsibus, then "ahc->sc_link.scsibus = 0xff;"
		 * is needed, here.
d148 1
d150 4
a153 2
			config_found((void *)ahc, &ahc->platform_data->sc_link_b, scsiprint);
		config_found((void *)ahc, &ahc->platform_data->sc_link, scsiprint);
d155 1
d157 1
a157 1
	return 1;
d164 1
a164 2
ahc_platform_intr(arg)
	void *arg;
d166 1
a166 8
	struct	ahc_softc *ahc;
	u_int	intstat = 0;
	u_int	errstat = 0;

	/*
	 * Any interrupts to process?
	 */
	ahc = (struct ahc_softc *)arg;
d168 1
a168 22
	intstat = ahc_inb(ahc, INTSTAT);

	/* Only check PCI error on PCI cards */
	if ((ahc->chip & AHC_PCI) != 0) {
		errstat = ahc_inb(ahc, ERROR);
		if ((intstat & INT_PEND) == 0 && (errstat & PCIERRSTAT)) {
			if (ahc->unsolicited_ints > 500) {
				ahc->unsolicited_ints = 0;
				ahc->bus_intr(ahc);
			}
			ahc->unsolicited_ints++;
			/* claim the interrupt */
			return 1;
		}
	}

	if ((intstat & INT_PEND) == 0){
		/* This interrupt is not for us */
		return 0;
	}

	bus_dmamap_sync(ahc->scb_data->hscb_dmat, ahc->scb_data->hscb_dmamap,
d172 1
a172 2
	ahc_intr(ahc);
	return 1;
d181 1
a181 3
ahc_done(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d183 2
a184 5
	struct scsi_xfer *xs = scb->io_ctx;
	struct scsi_link *sc_link = xs->sc_link;
	int requeue = 0;
	int target;
	int lun;
d186 1
a186 3
	SC_DEBUG(xs->sc_link, SDEV_DB2, ("ahc_done\n"));

	bus_dmamap_sync(ahc->scb_data->hscb_dmat, ahc->scb_data->hscb_dmamap,
a189 10
#ifdef maybe_not_such_a_good_idea
	/* Don't smash a disconnected SCB */
	if ((scb->hscb->control & DISCONNECTED) != 0){
		printf("disconnected sbc (tag %d) in ahc_done(ahc)!!!\n");
		if ((xs = ahc->platform_data->sc_xxxq.lh_first) != NULL)
			(void) ahc_action(xs);
		return;
	}
#endif

a203 12
#ifdef AHC_DEBUG
	if ((ahc_debug & AHC_SHOWCMDS)) {
		ahc_print_path(ahc, scb);
		printf("ahc_done: opcode 0x%x tag %x flags %x status %d error %d\n",
		    xs->cmdstore.opcode, scb->hscb->tag,
		    scb->flags, xs->status, xs->error);
	}
#endif

	target = sc_link->target;
	lun = sc_link->lun;

d211 3
a213 14
		ahc->buffer_dmat = ahc->parent_dmat;
		bus_dmamap_sync(ahc->buffer_dmat, scb->dmamap,
		    0, scb->dmamap->dm_mapsize, op);

		bus_dmamap_unload(ahc->buffer_dmat, scb->dmamap);
	}

	/*
	 * Unbusy this target/channel/lun.
	 * XXX if we are holding two commands per lun,
	 *     send the next command.
	 */
	if (!(scb->hscb->control & TAG_ENB)){
		ahc_pause_unbusy_tcl(ahc, XS_TCL(xs));
d229 1
a229 1
			struct scsi_xfer *txs = list_scb->io_ctx;
d231 2
a232 2
				timeout_add(&list_scb->io_ctx->stimeout,
				    (list_scb->io_ctx->timeout * hz)/1000);
d235 1
a235 1
		if (xs->error != XS_NOERROR)
d241 29
d271 1
a271 1
		/* Don't clobber any existing error state */
d276 6
a281 7
		 * Zero the sense data before having
		 * the drive fill it.  The SCSI spec mandates
		 * that any untransferred data should be
		 * assumed to be zero.  Complete the 'bounce'
		 * of sense information through buffers accessible
		 * via bus-space by copying it into the clients
		 * csio.
d288 2
a289 7

	if (scb->platform_data->flags & SCB_FREEZE_QUEUE) {
		/* keep negs from happening */
		if (ahc->platform_data->devqueue_blocked[target] > 0) {
			ahc->platform_data->devqueue_blocked[target]--;
		}
		scb->platform_data->flags &= ~SCB_FREEZE_QUEUE;
d292 1
a292 1
	requeue = scb->platform_data->flags & SCB_REQUEUE;
d294 1
d296 2
a297 28
	if (requeue) {
		/*
		 * Re-insert at the front of the private queue to
		 * preserve order.
		 */
		int s;
		ahc_lock(ahc, &s);
		ahc_list_insert_head(ahc, xs);
		ahc_unlock(ahc, &s);
	} else {
		if ((xs->sc_link->lun == 0) &&
		    (xs->flags & SCSI_POLL) &&
		    (xs->error == XS_NOERROR))
		ahc_check_tags(ahc, xs);
		xs->flags |= ITSDONE;
		scsi_done(xs);
	}

	/*
	 * If there are entries in the software queue, try to
	 * run the first one.  We should be more or less guaranteed
	 * to succeed, since we just freed an SCB.
	 *
	 * NOTE: ahc_action() relies on our calling it with
	 * the first entry in the queue.
	 */
	if ((xs = ahc->platform_data->sc_xxxq.lh_first) != NULL)
		(void) ahc_action(xs);
d318 1
a318 2
ahc_action(xs)
	struct scsi_xfer *xs;
a319 1
	struct scsi_xfer *first_xs, *next_xs = NULL;
a322 2
	struct ahc_initiator_tinfo *tinfo;
	struct ahc_tmode_tstate *tstate;
d325 2
a326 4
	char channel;
	int s, tcl;
	u_int16_t mask;
	int dontqueue = 0, fromqueue = 0;
a330 52
	/* must protect the queue */
	ahc_lock(ahc, &s);

	if (xs == ahc->platform_data->sc_xxxq.lh_first) {
		/*
		 * Called from ahc_done. Calling with the first entry in
		 * the queue is really just a way of seeing where we're
		 * called from. Now, find the first eligible SCB to send,
		 * e.g. one which will be accepted immediately.
		 */
		if (ahc->platform_data->queue_blocked) {
			ahc_unlock(ahc, &s);
			return (TRY_AGAIN_LATER);
		}

		xs = ahc_first_xs(ahc);
		if (xs == NULL) {
			ahc_unlock(ahc, &s);
			return (TRY_AGAIN_LATER);
		}

		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
		fromqueue = 1;
		goto get_scb;
	}

	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;

	/*
	 * If no new requests are accepted, just insert into the
	 * private queue to wait for our turn.
	 */
	tcl = XS_TCL(xs);

	if (ahc->platform_data->queue_blocked ||
	    ahc->platform_data->devqueue_blocked[xs->sc_link->target] ||
	    (!ahc_istagged_device(ahc, xs, 0) &&
	     ahc_pause_index_busy_tcl(ahc, tcl) != SCB_LIST_NULL)) {
		if (dontqueue) {
			ahc_unlock(ahc, &s);
			xs->error = XS_DRIVER_STUFFUP;
			return TRY_AGAIN_LATER;
		}
		ahc_list_insert_tail(ahc, xs);
		ahc_unlock(ahc, &s);
		return SUCCESSFULLY_QUEUED;
	}

	first_xs = ahc_first_xs(ahc);

a333 27
	/*
	 * Handle situations where there's already entries in the
	 * queue.
	 */
	if (first_xs != NULL) {
		/*
		 * If we can't queue, we have to abort, since
		 * we have to preserve order.
		 */
		if (dontqueue) {
			ahc_unlock(ahc, &s);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}

		/*
		 * Swap with the first queue entry.
		 */
		ahc_list_insert_tail(ahc, xs);
		xs = first_xs;
		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
		fromqueue = 1;
	}

get_scb:

d340 1
a341 16
		if (dontqueue) {
			ahc_unlock(ahc, &s);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}

		/*
		 * If we were pulled off the queue, put ourselves
		 * back to where we came from, otherwise tack ourselves
		 * onto the end.
		 */
		if (fromqueue && next_xs != NULL)
			ahc_list_insert_before(ahc, xs, next_xs);
		else
			ahc_list_insert_tail(ahc, xs);

d343 2
a344 1
		return (SUCCESSFULLY_QUEUED);
d346 1
a347 9
	tcl = XS_TCL(xs);

#ifdef DIAGNOSTIC
	if (!ahc_istagged_device(ahc, xs, 0) &&
	    ahc_pause_index_busy_tcl(ahc, tcl) != SCB_LIST_NULL)
		panic("ahc: queuing for busy target");
#endif

	scb->io_ctx = xs;
d350 2
a351 22
	hscb->control = 0;

	timeout_set(&xs->stimeout, ahc_timeout, scb);

	if (ahc_istagged_device(ahc, xs, 0)){
		hscb->control |= TAG_ENB;
	} else {
		ahc_pause_busy_tcl(ahc, tcl, scb->hscb->tag);
	}

	ahc_unlock(ahc, &s);

	channel = SCSI_CHANNEL(ahc, xs->sc_link);
	if (ahc->platform_data->inited_channels[channel - 'A'] == 0) {
		if ((channel == 'A' && (ahc->flags & AHC_RESET_BUS_A)) ||
		    (channel == 'B' && (ahc->flags & AHC_RESET_BUS_B))) {
			ahc_lock(ahc, &s);
			ahc_reset_channel(ahc, channel, TRUE);
			ahc_unlock(ahc, &s);
		}
		ahc->platform_data->inited_channels[channel - 'A'] = 1;
	}
d356 1
d358 4
a361 29
	hscb->lun = XS_LUN(xs);

	mask = SCB_GET_TARGET_MASK(ahc, scb);
	tinfo = ahc_fetch_transinfo(ahc, SCSI_CHANNEL(ahc, xs->sc_link), our_id,
				    target_id, &tstate);

	if (ahc->platform_data->inited_targets[target_id] == 0) {
		struct ahc_devinfo devinfo;

		ahc_lock(ahc, &s);
		ahc_compile_devinfo(&devinfo, our_id, target_id,
		    XS_LUN(xs), SCSI_CHANNEL(ahc, xs->sc_link),
		    ROLE_INITIATOR);
		ahc_update_neg_request(ahc, &devinfo, tstate, tinfo,
				       /*force*/TRUE);
		ahc->platform_data->inited_targets[target_id] = 1;
		ahc_unlock(ahc, &s);
	}

	hscb->scsirate = tinfo->scsirate;
	hscb->scsioffset = tinfo->curr.offset;
	if ((tstate->ultraenb & mask) != 0)
		hscb->control |= ULTRAENB;

	if ((tstate->discenable & mask) != 0)
		hscb->control |= DISCENB;

	if ((tstate->auto_negotiate & mask) != 0) {
		scb->flags |= SCB_AUTO_NEGOTIATE;
d363 1
d366 1
a366 5
	if (xs->flags & SCSI_RESET) {
		scb->flags |= SCB_DEVICE_RESET;
		hscb->control |= MK_MESSAGE;
		return ahc_execute_scb(scb, NULL, 0);
	}
d372 1
a372 4
ahc_execute_scb(arg, dm_segs, nsegments)
	void *arg;
	bus_dma_segment_t *dm_segs;
	int nsegments;
d379 1
d381 1
a381 1
	int	s;
d384 3
a386 1
	xs = scb->io_ctx;
d393 1
a393 1

d411 1
a411 1
		 * We also set the full residual flag which the
d422 2
a423 3
		ahc->buffer_dmat = ahc->parent_dmat;
		bus_dmamap_sync(ahc->buffer_dmat, scb->dmamap,
				0, scb->dmamap->dm_mapsize, op);
d428 1
a428 1
		bus_dmamap_sync(ahc->scb_data->sg_dmat, scb->sg_map->sg_dmamap,
a449 5

		if (!ahc_istagged_device(ahc, xs, 0)){
			ahc_pause_unbusy_tcl(ahc, XS_TCL(xs));
		}

d451 1
a451 1
			bus_dmamap_unload(ahc->buffer_dmat, scb->dmamap);
a457 5
#ifdef DIAGNOSTIC
	if (scb->sg_count > 255)
		panic("ahc bad sg_count");
#endif

d466 1
d471 1
a471 1
		scb->hscb->control |= DISCENB;
d478 14
a491 1
	bus_dmamap_sync(ahc->scb_data->hscb_dmat, ahc->scb_data->hscb_dmamap,
d497 2
a498 11
#ifdef AHC_DEBUG
	if ((ahc_debug & AHC_SHOWCMDS)) {
		ahc_print_path(ahc, scb);
		printf("opcode 0x%x tag %x len %d flags %x "
		       "control %x fpos %u rate %x\n",
		       xs->cmdstore.opcode, scb->hscb->tag,
		       scb->hscb->cdb_len, scb->flags,
		       scb->hscb->control, ahc->qinfifonext,
		       scb->hscb->scsirate);
	}
#endif
d511 1
a511 1
	 && (ahc->flags & AHC_SCB_BTT) == 0) {
a523 1

a525 3
	if (!(xs->flags & SCSI_POLL))
		timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);

d532 1
a532 2
		ahc_outb(ahc, SCB_TAG, scb->hscb->tag);
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
a537 1

d547 18
d573 6
d584 1
a584 3
ahc_poll(ahc, wait)
	struct	ahc_softc *ahc;
	int	wait;	/* in msec */
a587 2
		if ((ahc->chip & AHC_PCI) != 0 && (ahc_inb(ahc, ERROR) & PCIERRSTAT) != 0)
			ahc->bus_intr(ahc);
a597 1

d602 2
a603 4
ahc_setup_data(ahc, xs, scb)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scb *scb;
d606 1
a606 1

d609 1
a609 1
	xs->error = XS_NOERROR;
d612 10
d624 1
a624 2
		memcpy(hscb->cdb32, xs->cmd,
		       hscb->cdb_len);
d627 1
a627 3
		memcpy(hscb->shared_data.cdb,
		       xs->cmd,
		       hscb->cdb_len);
d629 1
a629 1

d634 1
a634 2
		ahc->buffer_dmat = ahc->parent_dmat;
		error = bus_dmamap_load(ahc->buffer_dmat,
d640 7
a646 3
			if (!ahc_istagged_device(ahc, xs, 0)) {
				ahc_pause_unbusy_tcl(ahc, XS_TCL(xs));
			}
d648 1
a648 1
		}
d659 1
a659 4
ahc_set_recoveryscb(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
a666 7
		 * Take all queued, but not sent SCBs out of the equation.
		 * Also ensure that no new CCBs are queued to us while we
		 * try to fix this problem.
		 */
		ahc->platform_data->queue_blocked = 1;

		/*
d672 1
a672 1
			timeout_del(&list_scb->io_ctx->stimeout);
d678 1
a678 2
ahc_timeout(arg)
	void *arg;
d682 2
a683 1
	int	s, found;
d691 1
a691 1
	ahc = (struct ahc_softc *)scb->io_ctx->sc_link->adapter_softc;
a694 6
	/*
	 * Ensure that the card doesn't do anything
	 * behind our back.  Also make sure that we
	 * didn't "just" miss an interrupt that would
	 * affect this timeout.
	 */
a711 5

	/*
	 * Take a snapshot of the bus state and print out
	 * some information so we can track down driver bugs.
	 */
a713 1

a721 1

d736 1
a736 1
		 *
d758 1
a758 1
		bus_dmamap_sync(ahc->scb_data->hscb_dmat,
d766 1
a766 2
		if (last_phase != P_BUSFREE
		  && (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) != 0
d771 5
a775 5
			 * If the active SCB is not from our device,
			 * assume that another device is hogging the bus
			 * and wait for it's timeout to expire before
			 * taking additional action.
			 */
d782 1
a782 1
				       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
d785 3
a787 3
				newtimeout = MAX(active_scb->io_ctx->timeout,
						 scb->io_ctx->timeout);
				timeout_add(&scb->io_ctx->stimeout,
d792 1
a792 1
			}
d795 1
a795 1
			if ((scb->hscb->control & TARGET_SCB) != 0) {
d801 6
a806 5
				ahc_freeze_devq(ahc, scb);
				ahc_set_transaction_status(scb,
							   CAM_CMD_TIMEOUT);
				ahc_freeze_scb(scb);
				ahc_done(ahc, scb);
d815 1
a815 1
			ahc_outb(ahc, MSG_OUT, MSG_BUS_DEV_RESET);
d820 1
a820 1
			timeout_add(&active_scb->io_ctx->stimeout, 2 * hz);
d825 1
a825 1
			bus_dmamap_sync(ahc->scb_data->hscb_dmat,
d830 1
a830 1
			if ((scb->hscb->control & TARGET_SCB) != 0)
d843 1
d872 1
a872 2
				scb->flags |= /*SCB_QUEUED_MSG | */
					SCB_DEVICE_RESET;
d900 1
d917 1
a917 1
				timeout_add(&scb->io_ctx->stimeout, 2 * hz);
a933 9
void
ahc_send_async(ahc, channel, target, lun, code, opt_arg)
	struct ahc_softc *ahc;
	char channel;
	u_int target, lun, code;
	void *opt_arg;
{
	/* Nothing to do here for OpenBSD */
}
d936 2
a937 4
ahc_platform_set_tags(ahc, devinfo, alg)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	ahc_queue_alg alg;
a938 1
	struct ahc_initiator_tinfo *tinfo;
d941 4
a944 4
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target,
				    &tstate);
d958 1
a958 3
ahc_platform_alloc(ahc, platform_arg)
	struct ahc_softc *ahc;
	void *platform_arg;
d960 7
a966 10
	ahc->platform_data = malloc(sizeof(struct ahc_platform_data), M_DEVBUF,
	    M_NOWAIT);
	if (ahc->platform_data == NULL)
		return (ENOMEM);
	bzero(ahc->platform_data, sizeof(struct ahc_platform_data));

	/* Just do some initialization... */
	ahc->scb_data = NULL;
	ahc->platform_data->ih = NULL;
	ahc->platform_data->channel_b_primary = FALSE;
d972 1
a972 2
ahc_platform_free(ahc)
	struct ahc_softc *ahc;
d974 2
a975 1
	free(ahc->platform_data, M_DEVBUF);
d979 1
a979 3
ahc_softc_comp(lahc, rahc)
	struct ahc_softc *lahc;
	struct ahc_softc *rahc;
a980 1
	/* We don't sort softcs under OpenBSD so report equal always */
d985 2
a986 3
ahc_check_tags(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
d988 1
a988 35
	struct ahc_devinfo devinfo;

	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return;

	if (ahc_istagged_device(ahc, xs, 1))
		return;

	ahc_compile_devinfo(&devinfo,
			    SCSI_SCSI_ID(ahc, xs->sc_link),
			    XS_SCSI_ID(xs),
			    XS_LUN(xs),
			    SCSI_CHANNEL(ahc, xs->sc_link),
			    ROLE_INITIATOR);

	ahc_set_tags(ahc, &devinfo, AHC_QUEUE_TAGGED);

	printf("%s: target %d using tagged queuing\n",
	       ahc_name(ahc), XS_SCSI_ID(xs));

	if (ahc->scb_data->maxhscbs >= 16 ||
	    (ahc->flags & AHC_PAGESCBS)) {
		/* Default to 16 tags */
		xs->sc_link->openings += 14;
	} else {
		/*
		 * Default to 4 tags on whimpy
		 * cards that don't have much SCB
		 * space and can't page.  This prevents
		 * a single device from hogging all
		 * slots.  We should really have a better
		 * way of providing fairness.
		 */
		xs->sc_link->openings += 2;
	}
d991 2
a992 5
int
ahc_istagged_device(ahc, xs, nocmdcheck)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	int nocmdcheck;
d994 1
a994 2
	char channel;
	u_int our_id, target;
d996 1
d998 3
d1002 1
a1002 2
	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return 0;
d1004 29
a1032 8
	/*
	 * XXX never do these commands with tags. Should really be
	 * in a higher layer.
	 */
	if (!nocmdcheck && (xs->cmd->opcode == INQUIRY ||
	     xs->cmd->opcode == TEST_UNIT_READY ||
	     xs->cmd->opcode == REQUEST_SENSE))
		return 0;
d1034 5
a1038 4
	channel = SCSI_CHANNEL(ahc, xs->sc_link);
	our_id = SCSI_SCSI_ID(ahc, xs->sc_link);
	target = XS_SCSI_ID(xs);
	(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);
d1040 3
a1042 2
	ahc_compile_devinfo(&devinfo, our_id, target, XS_LUN(xs),
			    channel, ROLE_INITIATOR);
d1044 4
a1047 2
	return (tstate->tagenable & devinfo.target_mask);
}
d1049 3
a1051 25
#if UNUSED
static void
ahc_dump_targcmd(cmd)
	struct target_cmd *cmd;
{
	uint8_t *byte;
	uint8_t *last_byte;
	int i;

	byte = &cmd->initiator_channel;
	/* Debugging info for received commands */
	last_byte = &cmd[1].initiator_channel;

	i = 0;
	while (byte < last_byte) {
		if (i == 0)
			printf("\t");
		printf("%#x", *byte++);
		i++;
		if (i == 8) {
			printf("\n");
			i = 0;
		} else {
			printf(", ");
		}
a1052 2
}
#endif
d1054 3
a1056 41
#ifndef AHC_INLINES
/*
 * This is a hack to keep from modifying the main
 * driver code as much as possible.  This function
 * does CAM to SCSI api stuff.
 */
void ahc_set_transaction_status(scb, status)
	struct scb *scb;
	uint32_t status;
{
	/* don't wipe the error */
	if (scb->io_ctx->error == XS_NOERROR){
		switch (status) {
		case CAM_CMD_TIMEOUT:
			status = XS_TIMEOUT;
			break;
		case CAM_BDR_SENT:
		case CAM_SCSI_BUS_RESET:
			status = XS_RESET;
			break;
		case CAM_UNEXP_BUSFREE:
		case CAM_REQ_TOO_BIG:
		case CAM_REQ_ABORTED:
		case CAM_AUTOSENSE_FAIL:
		case CAM_NO_HBA:
			status = XS_DRIVER_STUFFUP;
			break;
		case CAM_SEL_TIMEOUT:
			status = XS_SELTIMEOUT;
			break;
		case CAM_REQUEUE_REQ:
			scb->platform_data->flags |= SCB_REQUEUE;
			scb->io_ctx->error = XS_NOERROR;
			break;
		case CAM_SCSI_STATUS_ERROR:
		default:
			status = scb->io_ctx->error;
			break;
		}
	} else {
		status = scb->io_ctx->error;
a1057 2
	scb->io_ctx->error = status;
}
d1059 2
a1060 16
void ahc_set_transaction_tag(scb, enabled, type)
	struct scb *scb;
	int enabled;
	u_int type;
{
	struct scsi_xfer *xs = scb->io_ctx;
	switch (type) {
	case MSG_SIMPLE_TASK:
	case MSG_ORDERED_TASK:
		if (enabled)
			xs->sc_link->quirks &= ~SDEV_NOTAGS;
		else
			xs->sc_link->quirks |= SDEV_NOTAGS;
		break;
	}
}
d1062 1
a1062 17
void ahc_platform_scb_free(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	int s;

	ahc_lock(ahc, &s);

	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||
	    (scb->flags & SCB_RECOVERY_SCB) != 0) {
		ahc->flags &= ~AHC_RESOURCE_SHORTAGE;
		ahc->platform_data->queue_blocked = 0;
	}

	timeout_del(&scb->io_ctx->stimeout);

	ahc_unlock(ahc, &s);
a1063 1
#endif
@


1.13
log
@more dmamp_sync()s; krw@@ ok
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.12 2003/04/27 11:22:52 ho Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.12 2003/04/27 11:22:52 ho Exp $
d734 1
a734 1
		 * that any untransfered data should be
d795 1
a795 1
	 * discontinuous physically, hense the "page per segment" limit
d1389 1
a1389 1
		 * If the bus is idle and we are actiing as the initiator
@


1.12
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.11 2003/03/21 14:58:06 drahn Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.11 2003/03/21 14:58:06 drahn Exp $
d97 1
a97 1
 * Routines to manage busy targets.  The old driver didn't need to 
d112 1
a112 1
	u_int retval; 
d136 1
a136 1
					     
d153 1
a153 1
void 
d159 1
a159 1
	
d201 1
a201 1
	
d204 1
a204 1
	
d295 2
a296 2
	
	if (ahc_createdmamem(ahc, scb_data->sg_dmat, PAGE_SIZE, 
d298 1
a298 1
			     &sg_map->sg_physaddr, &sg_map->sg_dmasegs, 
d313 1
a313 1
		
d329 1
a329 1
		
d331 1
a331 1
		dma_flags = ((ahc->chip & AHC_VL) !=0) ? 
d334 1
a334 1
		
d338 1
a338 1
					  MAXBSIZE, 0, dma_flags, 
d340 1
a340 1
		if (error !=0) 
d342 1
a342 1
		
d377 1
a377 1
	
d404 2
a405 2
	    AHC_SCB_MAX * sizeof(struct hardware_scb), 
	    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs, 
d409 1
a409 1
	
d421 1
a421 1
	
d442 1
a442 1
	return (0); 
d481 1
a481 1
			       AHC_SCB_MAX * sizeof(struct hardware_scb), 
d515 1
a515 1
	
d538 1
a538 1
	
d589 2
a590 2
	ahc = (struct ahc_softc *)arg; 
	
d592 1
a592 1
	
d594 1
a594 1
        if ((ahc->chip & AHC_PCI) != 0) {
d606 1
a606 1
	
d611 5
a615 1
	
d617 1
a617 1
	return 1; 
d637 5
a641 1
	
d650 2
a651 2
#endif	
	
d663 1
a663 1
	
d669 3
a671 3
		printf("ahc_done: opcode 0x%x tag %x flags %x status %d error %d\n", 
		       xs->cmdstore.opcode, scb->hscb->tag, 
		       scb->flags, xs->status, xs->error);
d674 1
a674 1
	
d680 1
a680 1
	
d688 1
a688 1
		
d694 1
a694 1
	 * XXX if we are holding two commands per lun, 
d742 1
a742 1
		       ahc_le32toh(scb->sg_list->len) & AHC_SG_LEN_MASK);
d745 1
a745 1
	
d753 1
a753 1
	
d811 1
a811 1
	struct hardware_scb *hscb;	
d853 1
a853 1
	
d859 1
a859 1
	
d940 1
a940 1
	
d943 1
a943 1
	
d945 1
a945 1
	
d955 1
a955 1
 
d972 1
a972 1
	
d976 1
a976 1
	
d994 1
a994 1
		
d1029 1
a1029 1
	
d1049 1
a1049 1
		
d1052 1
a1052 1
		 * We also set the full residual flag which the 
d1057 1
a1057 1
		
d1066 1
a1066 1
		
d1070 4
d1082 1
a1082 1
	
d1096 1
a1096 1
			
d1099 1
a1099 1
		
d1128 5
a1132 1
	
d1140 2
a1141 2
		       xs->cmdstore.opcode, scb->hscb->tag, 
		       scb->hscb->cdb_len, scb->flags, 
d1153 1
a1153 1
	 * This really should not be of any 
d1171 1
a1171 1
	
d1195 1
a1195 1
	
d1229 1
a1229 1
	
d1231 1
a1231 1
	
d1242 1
a1242 1
	
d1246 1
a1246 1
	
d1263 1
d1270 1
a1270 1
			if (!ahc_istagged_device(ahc, xs, 0)){
d1326 1
a1326 1
	scb = (struct scb *)arg; 
d1347 1
a1347 1
	
d1354 1
a1354 1
	
d1361 1
a1361 1
	
d1370 1
a1370 1
	
d1385 1
a1385 1
		 * 
d1407 5
d1414 2
a1415 2
		
		if (last_phase != P_BUSFREE 
d1425 1
a1425 1
			 */ 
d1442 2
a1443 2
			} 
			
d1461 1
a1461 1
			} 
d1474 4
d1499 1
a1499 1
			
d1522 1
a1522 1
				
d1627 1
a1627 1
	
d1677 1
a1677 1
	if (ahc->scb_data->maxhscbs >= 16 || 
d1682 1
a1682 1
		/*	
d1758 1
a1758 1
/* 
d1826 1
a1826 1
	
d1832 1
a1832 1
	
d1834 1
a1834 1
	
@


1.11
log
@Endian fixes for ahc driver. These are a no-op for i386.  Now works on macppc.
ok millert@@ miod@@ krw@@
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.10 2003/01/05 22:41:35 deraadt Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.10 2003/01/05 22:41:35 deraadt Exp $
d516 1
a516 1
	ahc_controller_info(ahc, ahc_info);
@


1.10
log
@spelling
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.9 2002/09/06 05:04:41 smurph Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.9 2002/09/06 05:04:41 smurph Exp $
d734 1
a734 1
		       ahc_le32toh((scb->sg_list->len & AHC_SG_LEN_MASK)));
d1066 1
a1066 1
		scb->hscb->sgptr = SG_LIST_NULL;
a1097 5
	/* Fixup byte order */
	scb->hscb->dataptr = ahc_htole32(scb->hscb->dataptr); 
	scb->hscb->datacnt = ahc_htole32(scb->hscb->datacnt);
	scb->hscb->sgptr = ahc_htole32(scb->hscb->sgptr);
	
@


1.9
log
@Share interrupts nicely.  Add tag type.
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.8 2002/07/05 05:41:03 smurph Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.8 2002/07/05 05:41:03 smurph Exp $
d440 1
a440 1
	 * Note that we were successfull
@


1.9.4.1
log
@sync to -current
@
text
@d32 1
a32 1
 * $Id$
d35 1
a35 1
 * $OpenBSD$
@


1.9.4.2
log
@sync
@
text
@d440 1
a440 1
	 * Note that we were successful
d516 1
a516 1
	ahc_controller_info(ahc, ahc_info, sizeof ahc_info);
d734 1
a734 1
		       ahc_le32toh(scb->sg_list->len) & AHC_SG_LEN_MASK);
d1066 1
a1066 1
		scb->hscb->sgptr = ahc_htole32(SG_LIST_NULL);
d1098 5
@


1.8
log
@attempt to make ahc smaller.  change PCI interrupt handler.
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.6 2002/06/28 05:01:28 millert Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.6 2002/06/28 05:01:28 millert Exp $
d583 2
a584 1
	u_int	intstat;
d593 6
a598 5
	if ((intstat & INT_PEND) == 0) {
		if (ahc->unsolicited_ints > 500) {
			ahc->unsolicited_ints = 0;
			if ((ahc->chip & AHC_PCI) != 0
			 && (ahc_inb(ahc, ERROR) & PCIERRSTAT) != 0){
a599 1

d601 3
d605 5
a609 2
		ahc->unsolicited_ints++;
		return 1;
d1789 1
@


1.7
log
@Ensure scb is setup correctly.  Add debugging info.
@
text
@d103 3
a105 6
static __inline u_int	ahc_pause_index_busy_tcl(struct ahc_softc *ahc, 
						 u_int tcl);
static __inline void	ahc_pause_unbusy_tcl(struct ahc_softc *ahc,
					     u_int tcl);
static __inline void	ahc_pause_busy_tcl(struct ahc_softc *ahc,
					   u_int tcl, u_int busyid);
d107 1
a107 1
static __inline u_int
d123 1
a123 1
static __inline void
d137 1
a137 1
static __inline void
a198 1
	const char *myname = ahc_name(ahc);
d207 2
a208 2
		printf("%s: failed to allocate DMA mem for %s, error = %d\n",
			myname, what, error);
d215 2
a216 2
		printf("%s: failed to map DMA mem for %s, error = %d\n",
			myname, what, error);
d223 2
a224 2
		printf("%s: failed to create DMA map for %s, error = %d\n",
			myname, what, error);
d231 2
a232 2
		printf("%s: failed to load DMA map for %s, error = %d\n",
			myname, what, error);
d427 1
a427 2
		printf("%s: ahc_init_scbdata - "
		       "Unable to allocate initial scbs\n",
d517 1
a517 1
	printf("%s: %s %s\n", ahc_name(ahc), ahc_info, (ahc->flags & AHC_SCB_BTT) ? "BTT" : "");
d593 7
a599 16
		if (ahc->platform_data->pci_intr_func && 
		    (int)ahc->platform_data->pci_intr_func(ahc)) {
#ifdef AHC_DEBUG
			printf("%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\n",
			    ahc_name(ahc),
			    ahc_inb(ahc, CCHADDR) |
			    (ahc_inb(ahc, CCHADDR+1) << 8)
			    | (ahc_inb(ahc, CCHADDR+2) << 16)
			    | (ahc_inb(ahc, CCHADDR+3) << 24),
			    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)
			    | (ahc_inb(ahc, HADDR+2) << 16)
			    | (ahc_inb(ahc, HADDR+3) << 24),
			    ahc_inb(ahc, SEQADDR0) |
			    (ahc_inb(ahc, SEQADDR1) << 8));
#endif
			return 1;
d601 2
a602 1
		return 0;
d604 1
a604 1

d627 10
a925 1
	scb->flags = SCB_FREE;
d928 1
d1117 12
d1150 1
a1150 1
			return (COMPLETE);
a1171 11
#ifdef AHC_DEBUG
	if ((ahc_debug & AHC_SHOWCMDS)) {
		ahc_print_path(ahc, scb);
		printf("opcode 0x%x tag %x len %d flags %x "
		       "control %x fpos %u rate %x\n",
		       xs->cmdstore.opcode, scb->hscb->tag, 
		       scb->hscb->cdb_len, scb->flags, 
		       scb->hscb->control, ahc->qinfifonext,
		       scb->hscb->scsirate);
	}
#endif
a1199 2
		if (ahc->platform_data->pci_intr_func) 
		    (void)ahc->platform_data->pci_intr_func(ahc);
d1201 2
a1602 1
	ahc->platform_data->pci_intr_func = NULL;
d1638 5
a1642 5
	    SCSI_SCSI_ID(ahc, xs->sc_link),
	    XS_SCSI_ID(xs),
	    XS_LUN(xs),
	    SCSI_CHANNEL(ahc, xs->sc_link),
	    ROLE_INITIATOR);
d1647 1
a1647 1
	    ahc_name(ahc), XS_SCSI_ID(xs));
d1649 1
a1649 1
	if (ahc->scb_data->maxhscbs >= 16 ||
d1729 80
@


1.6
log
@Move the calculation of sc_link->openings to after the printf about
tagged queueing which is where it was last time around.  This fixes
a panic I was seeing when there were lots of transactions (e.g.
when i read my mail).
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.5 2002/06/28 00:34:54 smurph Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.5 2002/06/28 00:34:54 smurph Exp $
d522 1
a522 1
	printf("%s: %s\n", ahc_name(ahc), ahc_info);
d929 1
a931 1
	
@


1.5
log
@Return of new ahc
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.3 2002/03/14 01:26:54 millert Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.3 2002/03/14 01:26:54 millert Exp $
a1633 16
	if (ahc->scb_data->maxhscbs >= 16 ||
	    (ahc->flags & AHC_PAGESCBS)) {
		/* Default to 16 tags */
		xs->sc_link->openings += 14;
	} else {
		/*
		 * Default to 4 tags on whimpy
		 * cards that don't have much SCB
		 * space and can't page.  This prevents
		 * a single device from hogging all
		 * slots.  We should really have a better
		 * way of providing fairness.
		 */
		xs->sc_link->openings += 2;
	}
	
d1652 15
@


1.4
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d76 1
a76 1
static void	ahc_dump_targcmd(struct target_cmd *cmd);
d80 1
a80 1
				     int nsegments);
d85 2
a87 2
void		ahc_set_recoveryscb(struct ahc_softc *ahc,
					 struct scb *scb);
a89 1

d92 1
a92 1
					 int nocmdcheck);
d94 1
a94 1
				    struct scsi_xfer *xs);
d97 1
a97 1
 * Routines to manage busy targets.  The old driver didn't need to
d104 1
a104 1
						      u_int tcl);
d106 1
a106 1
						  u_int tcl);
d108 1
a108 1
						u_int tcl, u_int busyid);
d230 1
a230 1
        }
d238 1
a238 1
        }
d365 1
a365 1
        scb_data->init_level = 0;
d380 1
a380 1
        scb_data->sg_dmat = ahc->parent_dmat;
d758 1
a758 1
			ahc_check_tags(ahc, xs);
d1410 1
a1410 1
			 	       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
d1561 1
a1561 1
        void *opt_arg;
d1604 1
a1604 1
        ahc->platform_data->ih = NULL;
d1634 16
a1667 15
	if (ahc->scb_data->maxhscbs >= 16 ||
	    (ahc->flags & AHC_PAGESCBS)) {
		/* Default to 16 tags */
		xs->sc_link->openings += 14;
	} else {
		/*	
		 * Default to 4 tags on whimpy
		 * cards that don't have much SCB
		 * space and can't page.  This prevents
		 * a single device from hogging all
		 * slots.  We should really have a better
		 * way of providing fairness.
		 */
		xs->sc_link->openings += 2;
	}
@


1.3
log
@First round of __P removal in sys
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.2 2002/03/14 00:04:09 krw Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.2 2002/03/14 00:04:09 krw Exp $
@


1.2
log
@Fix *some* problems with new ahc driver that were surfaced with
the recent changes to scsiconf.c.

a) Restore marking of appropriate devices as tagged
b) Fix an off-by-one error that sprayed bits around
c) Use correct field (quirks) when setting SDEV_NOTAGS bit
d) Use TAG_ENB define instead of MSG_SIMPLE_Q_TAG when
   manipulating hscb->control. Both were defined to the
   same value, but TAG_ENB is the define used to extract
   the bit later on.

This leaves problems, most often seen as faults when accessing
a CD drive and disk drive on the same bus.

ok smurph@@
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.1 2002/02/16 04:36:33 smurph Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.1 2002/02/16 04:36:33 smurph Exp $
d45 2
a46 2
int32_t		ahc_action __P((struct scsi_xfer *xs));
static void	ahc_minphys __P((struct buf *bp));
d76 1
a76 1
static void	ahc_dump_targcmd __P((struct target_cmd *cmd));
d78 6
a83 6
void		ahc_build_free_scb_list __P((struct ahc_softc *ahc));
int		ahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,
				     int nsegments));
int		ahc_poll __P((struct ahc_softc *ahc, int wait));
void		ahc_timeout __P((void *));
int		ahc_setup_data __P((struct ahc_softc *ahc,
d85 5
a89 5
				    struct scb *scb));
void		ahc_set_recoveryscb __P((struct ahc_softc *ahc,
					 struct scb *scb));
int		ahc_init_scbdata __P((struct ahc_softc *ahc));
void		ahc_fini_scbdata __P((struct ahc_softc *ahc));
d91 1
a91 1
int		ahc_istagged_device __P((struct ahc_softc *ahc,
d93 3
a95 3
					 int nocmdcheck));
void		ahc_check_tags __P((struct ahc_softc *ahc,
				    struct scsi_xfer *xs));
d104 6
a109 6
static __inline u_int	ahc_pause_index_busy_tcl __P((struct ahc_softc *ahc, 
						      u_int tcl));
static __inline void	ahc_pause_unbusy_tcl __P((struct ahc_softc *ahc,
						  u_int tcl));
static __inline void	ahc_pause_busy_tcl __P((struct ahc_softc *ahc,
						u_int tcl, u_int busyid));
@


1.1
log
@New port of FreeBSD's ahc driver
@
text
@d32 1
a32 1
 * $Id$
d35 1
a35 1
 * $OpenBSD: src/sys/dev/aic7xxx/aic7xxx_openbsd.c,v 1.26 2001/07/18 21:39:47 smurph Exp $
d98 4
a101 4
 * Routines to manage busy targets.  The old driver didn't need to 
 * pause the sequecer because no device registers were acessed.  Now
 * busy targetes are controlled via the device registers and thus, 
 * we have to pause the sequencer for chips that don't have the 
d161 1
a161 1
	int max_targ = AHC_NUM_TARGETS;
d165 1
a165 1
		max_targ = 7;
d167 1
a167 1
	for (i = 0; i <= max_targ; i++) {
a269 1

d721 1
a721 1
		 * bzero the sense data before having
d756 4
a760 1
                ahc_check_tags(ahc, xs);
d938 1
a938 1
		hscb->control |= MSG_SIMPLE_Q_TAG;
d1580 1
a1587 1
		tstate->tagdisable |= devinfo->target_mask;
a1632 1
	struct scsi_inquiry_data *inq;
a1633 6
	struct ahc_tmode_tstate *tstate;
	int target_id, our_id;
	char channel;

	if (xs->cmd->opcode != INQUIRY || xs->error != XS_NOERROR)
		return;
d1638 1
a1638 9
	target_id = xs->sc_link->target;
	our_id = SCSI_SCSI_ID(ahc, xs->sc_link);
	channel = SCSI_CHANNEL(ahc, xs->sc_link);

	(void)ahc_fetch_transinfo(ahc, channel, our_id, target_id, &tstate);
	ahc_compile_devinfo(&devinfo, our_id, target_id,
	    xs->sc_link->lun, channel, ROLE_INITIATOR);

	if (tstate->tagdisable & devinfo.target_mask)
d1641 26
a1666 28
	/*
	 * Sneak a look at the results of the SCSI Inquiry
	 * command and see if we can do Tagged queing.  This
	 * should really be done by the higher level drivers.
	 */
	inq = (struct scsi_inquiry_data *)xs->data;
	if ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs, 1))) {
#ifdef AHC_DEBUG 
		printf("%s: target %d using tagged queuing\n",
			ahc_name(ahc), xs->sc_link->target);
#endif 
		ahc_set_tags(ahc, &devinfo, AHC_QUEUE_TAGGED);

		if (ahc->scb_data->maxhscbs >= 16 ||
		    (ahc->flags & AHC_PAGESCBS)) {
			/* Default to 16 tags */
			xs->sc_link->openings += 14;
		} else {
			/*
			 * Default to 4 tags on whimpy
			 * cards that don't have much SCB
			 * space and can't page.  This prevents
			 * a single device from hogging all
			 * slots.  We should really have a better
			 * way of providing fairness.
			 */
			xs->sc_link->openings += 2;
		}
@


1.1.2.1
log
@Merge in -current from about a week ago
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.1 2002/02/16 04:36:33 smurph Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.1 2002/02/16 04:36:33 smurph Exp $
@


1.1.2.2
log
@Sync SMP to 3.3, files that CVS misses due to some bug
@
text
@d32 1
a32 1
 * $Id$
d35 1
a35 1
 * $OpenBSD$
d45 2
a46 2
int32_t		ahc_action(struct scsi_xfer *xs);
static void	ahc_minphys(struct buf *bp);
d76 1
a76 1
static void     ahc_dump_targcmd(struct target_cmd *cmd);
d78 6
a83 6
void		ahc_build_free_scb_list(struct ahc_softc *ahc);
int		ahc_execute_scb(void *arg, bus_dma_segment_t *dm_segs,
				int nsegments);
int		ahc_poll(struct ahc_softc *ahc, int wait);
void		ahc_timeout(void *);
int		ahc_setup_data(struct ahc_softc *ahc,
d85 7
a91 6
			       struct scb *scb);
void		ahc_set_recoveryscb(struct ahc_softc *ahc,
				    struct scb *scb);
int		ahc_init_scbdata(struct ahc_softc *ahc);
void		ahc_fini_scbdata(struct ahc_softc *ahc);
int		ahc_istagged_device(struct ahc_softc *ahc,
d93 3
a95 3
				    int nocmdcheck);
void		ahc_check_tags(struct ahc_softc *ahc,
			       struct scsi_xfer *xs);
d99 3
a101 3
 * pause the sequencer because no device registers were accessed.  Now
 * busy targets are controlled via the device registers and thus, we
 * have to pause the sequencer for chips that don't have the
d104 6
a109 3
u_int ahc_pause_index_busy_tcl(struct ahc_softc *ahc, u_int tcl);
void  ahc_pause_unbusy_tcl(struct ahc_softc *ahc, u_int tcl);
void  ahc_pause_busy_tcl(struct ahc_softc *ahc, u_int tcl, u_int busyid);
d111 1
a111 1
u_int
d127 1
a127 1
void
d141 1
a141 1
void
d161 1
a161 1
	int num_targets = AHC_NUM_TARGETS;
d165 1
a165 1
		num_targets = 8;
d167 1
a167 1
	for (i = 0; i < num_targets; i++) {
d203 1
d212 2
a213 2
		printf("%s: failed to %s DMA map for %s, error = %d\n",
			"allocate", ahc_name(ahc), what, error);
d220 2
a221 2
		printf("%s: failed to %s DMA map for %s, error = %d\n",
			"map", ahc_name(ahc), what, error);
d228 2
a229 2
		printf("%s: failed to %s DMA map for %s, error = %d\n",
			"create", ahc_name(ahc), what, error);
d231 1
a231 1
	}
d236 2
a237 2
		printf("%s: failed to %s DMA map for %s, error = %d\n",
			"load", ahc_name(ahc), what, error);
d239 1
a239 1
	}
d270 1
d367 1
a367 1
	scb_data->init_level = 0;
d382 1
a382 1
	scb_data->sg_dmat = ahc->parent_dmat;
d433 2
a434 1
		printf("%s: Unable to allocate initial scbs\n",
d447 1
a447 1
	 * Note that we were successful
d590 1
a590 2
	u_int	intstat = 0;
	u_int	errstat = 0;
d599 16
a614 10
	/* Only check PCI error on PCI cards */
        if ((ahc->chip & AHC_PCI) != 0) {
		errstat = ahc_inb(ahc, ERROR);
		if ((intstat & INT_PEND) == 0 && (errstat & PCIERRSTAT)) {
			if (ahc->unsolicited_ints > 500) {
				ahc->unsolicited_ints = 0;
				ahc->bus_intr(ahc);
			}
			ahc->unsolicited_ints++;
			/* claim the interrupt */
a616 4
	}
	
	if ((intstat & INT_PEND) == 0){
		/* This interrupt is not for us */
d619 1
a619 1
	
a641 10
#ifdef maybe_not_such_a_good_idea
	/* Don't smash a disconnected SCB */
	if ((scb->hscb->control & DISCONNECTED) != 0){
		printf("disconnected sbc (tag %d) in ahc_done(ahc)!!!\n");
		if ((xs = ahc->platform_data->sc_xxxq.lh_first) != NULL)
			(void) ahc_action(xs);
		return;
	}
#endif	
	
d722 1
a722 1
		 * Zero the sense data before having
d732 1
a732 1
		       ahc_le32toh(scb->sg_list->len) & AHC_SG_LEN_MASK);
a756 4
		if ((xs->sc_link->lun == 0) &&
		    (xs->flags & SCSI_POLL) &&
		    (xs->error == XS_NOERROR))
		ahc_check_tags(ahc, xs);
d758 1
d936 1
a936 1
		hscb->control |= TAG_ENB;
d1061 1
a1061 1
		scb->hscb->sgptr = ahc_htole32(SG_LIST_NULL);
d1093 5
a1118 12
#ifdef AHC_DEBUG
	if ((ahc_debug & AHC_SHOWCMDS)) {
		ahc_print_path(ahc, scb);
		printf("opcode 0x%x tag %x len %d flags %x "
		       "control %x fpos %u rate %x\n",
		       xs->cmdstore.opcode, scb->hscb->tag, 
		       scb->hscb->cdb_len, scb->flags, 
		       scb->hscb->control, ahc->qinfifonext,
		       scb->hscb->scsirate);
	}
#endif

d1140 1
a1140 1
			return (SUCCESSFULLY_QUEUED);
d1162 11
d1201 2
a1203 2
		if ((ahc->chip & AHC_PCI) != 0 && (ahc_inb(ahc, ERROR) & PCIERRSTAT) != 0)
			ahc->bus_intr(ahc);
d1409 1
a1409 1
				       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
d1560 1
a1560 1
	void *opt_arg;
a1577 1

d1585 1
d1603 2
a1604 1
	ahc->platform_data->ih = NULL;
d1631 1
d1633 6
d1643 9
a1651 1
	if (ahc_istagged_device(ahc, xs, 1))
d1654 28
a1681 26
	ahc_compile_devinfo(&devinfo,
			    SCSI_SCSI_ID(ahc, xs->sc_link),
			    XS_SCSI_ID(xs),
			    XS_LUN(xs),
			    SCSI_CHANNEL(ahc, xs->sc_link),
			    ROLE_INITIATOR);

	ahc_set_tags(ahc, &devinfo, AHC_QUEUE_TAGGED);

	printf("%s: target %d using tagged queuing\n",
	       ahc_name(ahc), XS_SCSI_ID(xs));

	if (ahc->scb_data->maxhscbs >= 16 || 
	    (ahc->flags & AHC_PAGESCBS)) {
		/* Default to 16 tags */
		xs->sc_link->openings += 14;
	} else {
		/*	
		 * Default to 4 tags on whimpy
		 * cards that don't have much SCB
		 * space and can't page.  This prevents
		 * a single device from hogging all
		 * slots.  We should really have a better
		 * way of providing fairness.
		 */
		xs->sc_link->openings += 2;
a1747 81
#ifndef AHC_INLINES
/* 
 * This is a hack to keep from modifying the main
 * driver code as much as possible.  This function
 * does CAM to SCSI api stuff.
 */
void ahc_set_transaction_status(scb, status)
	struct scb *scb;
	uint32_t status;
{
	/* don't wipe the error */
	if (scb->io_ctx->error == XS_NOERROR){
		switch (status) {
		case CAM_CMD_TIMEOUT:
			status = XS_TIMEOUT;
			break;
		case CAM_BDR_SENT:
		case CAM_SCSI_BUS_RESET:
			status = XS_RESET;
			break;
		case CAM_UNEXP_BUSFREE:
		case CAM_REQ_TOO_BIG:
		case CAM_REQ_ABORTED:
		case CAM_AUTOSENSE_FAIL:
		case CAM_NO_HBA:
			status = XS_DRIVER_STUFFUP;
			break;
		case CAM_SEL_TIMEOUT:
			status = XS_SELTIMEOUT;
			break;
		case CAM_REQUEUE_REQ:
			scb->platform_data->flags |= SCB_REQUEUE;
			scb->io_ctx->error = XS_NOERROR;
			break;
		case CAM_SCSI_STATUS_ERROR:
		default:
			status = scb->io_ctx->error;
			break;
		}
	} else {
		status = scb->io_ctx->error;
	}
	scb->io_ctx->error = status;
}

void ahc_set_transaction_tag(scb, enabled, type)
	struct scb *scb;
	int enabled;
	u_int type;
{
	struct scsi_xfer *xs = scb->io_ctx;
	switch (type) {
	case MSG_SIMPLE_TASK:
	case MSG_ORDERED_TASK:
		if (enabled)
			xs->sc_link->quirks &= ~SDEV_NOTAGS;
		else
			xs->sc_link->quirks |= SDEV_NOTAGS;
		break;
	}
}

void ahc_platform_scb_free(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	int s;

	ahc_lock(ahc, &s);
	
	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||
	    (scb->flags & SCB_RECOVERY_SCB) != 0) {
		ahc->flags &= ~AHC_RESOURCE_SHORTAGE;
		ahc->platform_data->queue_blocked = 0;
	}
	
	timeout_del(&scb->io_ctx->stimeout);
	
	ahc_unlock(ahc, &s);
}
#endif
@


1.1.2.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d32 1
a32 1
 * $Id: aic7xxx_openbsd.c,v 1.1.2.2 2003/03/28 14:05:52 niklas Exp $
d35 1
a35 1
 * $OpenBSD: aic7xxx_openbsd.c,v 1.1.2.2 2003/03/28 14:05:52 niklas Exp $
d516 1
a516 1
	ahc_controller_info(ahc, ahc_info, sizeof ahc_info);
@


1.1.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a0 3
/*	$OpenBSD$	*/
/*	$NetBSD: aic7xxx_osm.c,v 1.14 2003/11/02 11:07:44 wiz Exp $	*/

d32 1
a32 1
 * //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#12 $
d34 2
a35 4
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx_osm.c,v 1.31 2002/11/30 19:08:58 scottl Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
a37 3
#include <sys/cdefs.h>
/* __KERNEL_RCSID(0, "$NetBSD: aic7xxx_osm.c,v 1.14 2003/11/02 11:07:44 wiz Exp $"); */

a40 15
#ifndef AHC_TMODE_ENABLE
#define AHC_TMODE_ENABLE 0
#endif


int	ahc_action(struct scsi_xfer *);
int	ahc_execute_scb(void *, bus_dma_segment_t *, int);
int	ahc_poll(struct ahc_softc *, int);
int	ahc_setup_data(struct ahc_softc *, struct scsi_xfer *, struct scb *);
void	ahc_set_recoveryscb(struct ahc_softc *, struct scb *);

void	ahc_minphys(struct buf *);
void	ahc_adapter_req_set_xfer_mode(struct ahc_softc *, struct scb *);


d45 3
d65 31
d97 5
a101 1
 * Attach all the sub-devices we can find
d103 251
d355 2
a356 1
ahc_attach(struct ahc_softc *ahc)
d358 28
a385 2
	char ahc_info[256];
	int i, s;
d387 4
a390 3
	LIST_INIT(&ahc->pending_scbs);
	for (i = 0; i < AHC_NUM_TARGETS; i++)
		TAILQ_INIT(&ahc->untagged_queues[i]);
d392 1
a392 1
        ahc_lock(ahc, &s);
d395 7
a401 1
	 * fill in the prototype scsi_links.
d403 16
a418 7
	ahc->sc_channel.adapter_target = ahc->our_id;
	if (ahc->features & AHC_WIDE)
		ahc->sc_channel.adapter_buswidth = 16;
	ahc->sc_channel.adapter_softc = ahc;
	ahc->sc_channel.adapter = &ahc_switch;
	ahc->sc_channel.openings = 16;
	ahc->sc_channel.device = &ahc_dev;
d420 10
a429 4
	if (ahc->features & AHC_TWIN) {
		/* Configure the second scsi bus */
		ahc->sc_channel_b = ahc->sc_channel;
		ahc->sc_channel_b.adapter_target = ahc->our_id_b;
d431 1
d433 52
a484 3
	if (bootverbose) {
		ahc_controller_info(ahc, ahc_info, sizeof ahc_info);
		printf("%s: %s\n", ahc->sc_dev.dv_xname, ahc_info);
d486 18
d505 17
a521 1
	ahc_intr_enable(ahc, TRUE);
d523 28
a550 4
	if (ahc->flags & AHC_RESET_BUS_A)
		ahc_reset_channel(ahc, 'A', TRUE);
	if ((ahc->features & AHC_TWIN) && ahc->flags & AHC_RESET_BUS_B)
		ahc_reset_channel(ahc, 'B', TRUE);
d552 7
a558 9
	if ((ahc->flags & AHC_PRIMARY_CHANNEL) == 0) {
		/*
		 * Ensure SCSI_IS_SCSIBUS_B() returns false for sc_channel
		 * until sc_channel_b has been properly initialized by scsi
		 * layer.
		 */
		ahc->sc_channel_b.scsibus = 0xff;
		ahc->sc_child = config_found((void *)&ahc->sc_dev,
		    &ahc->sc_channel, scsiprint);
d560 1
a560 2
			ahc->sc_child_b = config_found((void *)&ahc->sc_dev,
			    &ahc->sc_channel_b, scsiprint);
d563 3
a565 3
		 * Ensure SCSI_IS_SCSIBUS_B() returns false for sc_channel_b
		 * until sc_channel has been properly initialized by scsi
		 * layer.
a566 1
		ahc->sc_channel.scsibus = 0xff;
d568 2
a569 4
			ahc->sc_child = config_found((void *)&ahc->sc_dev,
			    &ahc->sc_channel_b, scsiprint);
		ahc->sc_child_b = config_found((void *)&ahc->sc_dev,
		    &ahc->sc_channel, scsiprint);
a570 1

d572 1
a572 1
	return (1);
d579 2
a580 1
ahc_platform_intr(void *arg)
d582 3
a584 1
	struct	ahc_softc *ahc = (struct ahc_softc *)arg;
d586 28
a613 5
	bus_dmamap_sync(ahc->parent_dmat, ahc->scb_data->hscb_dmamap,
	    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	return ahc_intr(ahc);
d622 3
a624 1
ahc_done(struct ahc_softc *ahc, struct scb *scb)
d626 5
a630 6
	struct scsi_xfer *xs = scb->xs;
	int s;

	bus_dmamap_sync(ahc->parent_dmat, ahc->scb_data->hscb_dmamap,
	    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
d632 12
d655 2
d658 11
a668 1
	timeout_del(&xs->stimeout);
d672 1
a672 1

d677 14
a690 3
		bus_dmamap_sync(ahc->parent_dmat, scb->dmamap, 0,
				scb->dmamap->dm_mapsize, op);
		bus_dmamap_unload(ahc->parent_dmat, scb->dmamap);
d706 1
a706 1
			struct scsi_xfer *txs = list_scb->xs;
d708 2
a709 2
				timeout_add(&list_scb->xs->stimeout,
				    (list_scb->xs->timeout * hz)/1000);
d712 1
a712 1
		if (xs->error != CAM_REQ_INPROG)
a717 53
	/* Translate the CAM status code to a SCSI error code. */
	switch (xs->error) {
	case CAM_REQ_INPROG:
	case CAM_REQ_CMP:
		switch (xs->status) {
		case SCSI_TASKSET_FULL:
			/* SCSI Layer won't requeue, so we force infinite
			 * retries until queue space is available. XS_BUSY
			 * is dangerous because if the NOSLEEP flag is set
			 * it can cause the I/O to return EIO. XS_BUSY code
			 * falls through to XS_TIMEOUT anyway.
			 */
			xs->error = XS_TIMEOUT;
			xs->retries++;
			break;
		case SCSI_BUSY:
			xs->error = XS_BUSY;
			break;
		case SCSI_CHECK:
		case SCSI_TERMINATED:
			if ((scb->flags & SCB_SENSE) == 0) {
				/* CHECK on CHECK? */
				xs->error = XS_DRIVER_STUFFUP;
			} else
				xs->error = XS_NOERROR;
			break;
		default:
			xs->error = XS_NOERROR;
			break;
		}
		break;
	case CAM_BUSY:
		xs->error = XS_BUSY;
		break;
	case CAM_CMD_TIMEOUT:
		xs->error = XS_TIMEOUT;
		break;
	case CAM_BDR_SENT:
	case CAM_SCSI_BUS_RESET:
		xs->error = XS_RESET;
	case CAM_REQUEUE_REQ:
		xs->error = XS_TIMEOUT;
		xs->retries++;
		break;
	case CAM_SEL_TIMEOUT:
		xs->error = XS_SELTIMEOUT;
		break;
	default:
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	/* Don't clobber any existing error state */
d719 1
a719 1
	  /* Don't clobber any existing error state */
d724 7
a730 6
		 * Zero any sense not transferred by the
		 * device.  The SCSI spec mandates that any
		 * untransferred data should be assumed to be
		 * zero.  Complete the 'bounce' of sense information
		 * through buffers accessible via bus-space by
		 * copying it into the clients csio.
d734 1
a734 1
		    ahc_le32toh(scb->sg_list->len) & AHC_SG_LEN_MASK);
d737 7
a743 2
	if (scb->flags & SCB_FREEZE_QUEUE) {
		scb->flags &= ~SCB_FREEZE_QUEUE;
d745 3
d749 17
a765 3
        ahc_lock(ahc, &s);       
	ahc_free_scb(ahc, scb);
        ahc_unlock(ahc, &s);       
d767 10
a776 2
	xs->flags |= ITSDONE;
	scsi_done(xs);
d779 1
a779 1
void
d787 1
a787 1
	 * discontinuous physically, hence the "page per segment" limit
d797 2
a798 1
ahc_action(struct scsi_xfer *xs)
d800 1
d803 3
a805 1
	struct hardware_scb *hscb;
d808 4
a811 2
	int s;
	int dontqueue = 0;
d816 52
d871 27
a903 1
	ahc_lock(ahc, &s);
d905 16
d922 1
a922 2
		xs->error = XS_DRIVER_STUFFUP;
		return (TRY_AGAIN_LATER);
a923 1
	ahc_unlock(ahc, &s);
d925 9
d935 10
d946 12
a957 2
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("start scb(%p)\n", scb));
	scb->xs = xs;
a961 1
	hscb->control = 0;
d963 33
a995 3
	hscb->lun = xs->sc_link->lun;
	if (xs->xs_control & XS_CTL_RESET) {
		hscb->cdb_len = 0;
d998 1
a998 1
		ahc_execute_scb(scb, NULL, 0);
a1000 2
	timeout_set(&xs->stimeout, ahc_timeout, scb);

d1005 4
a1008 1
ahc_execute_scb(void *arg, bus_dma_segment_t *dm_segs, int nsegments)
a1014 1

d1019 1
a1019 3
	xs = scb->xs;
	xs->error = CAM_REQ_INPROG;
	xs->status = 0;
d1021 1
a1021 1

d1026 1
a1026 1
		
d1041 1
a1041 1

d1049 1
a1049 1

d1055 4
a1058 3
		bus_dmamap_sync(ahc->parent_dmat, scb->dmamap, 0,
				scb->dmamap->dm_mapsize, op);

a1061 4
		bus_dmamap_sync(ahc->parent_dmat, scb->sg_map->sg_dmamap,
		    0, scb->sg_map->sg_dmamap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

d1070 1
a1070 1

d1080 5
d1086 2
a1087 2
			bus_dmamap_unload(ahc->parent_dmat, scb->dmamap);

d1093 5
a1105 1

d1110 1
a1110 1
	    	scb->hscb->control |= DISCENB;
d1116 1
a1116 8

	if ((tstate->tagenable & mask) != 0)
		scb->hscb->control |= TAG_ENB;

	bus_dmamap_sync(ahc->parent_dmat, ahc->scb_data->hscb_dmamap,
	    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d1119 11
a1129 2
	if (!(xs->flags & SCSI_POLL))
		timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);
d1137 1
a1137 1
	 * This really should not be of any
d1142 1
a1142 1
	    && (ahc->flags & AHC_SCB_BTT) == 0) {
d1151 2
a1152 6
			if (xs->flags & SCSI_POLL)
				goto poll;
			else {		
				ahc_unlock(ahc, &s);
				return (SUCCESSFULLY_QUEUED);
			}
d1155 1
d1158 3
d1167 2
a1168 1
		ahc_outb(ahc, TARG_IMMEDIATE_SCB, scb->hscb->tag);
d1174 1
a1175 11
		if (ahc->inited_target[xs->sc_link->target] == 0) {
			struct	ahc_devinfo devinfo;

			ahc_adapter_req_set_xfer_mode(ahc, scb);
			ahc_scb_devinfo(ahc, &devinfo, scb);
			ahc_update_neg_request(ahc, &devinfo, tstate, tinfo,
			    AHC_NEG_IF_NON_ASYNC);

			ahc->inited_target[xs->sc_link->target] = 1;
		}

d1179 1
a1179 1

a1182 1
poll:
a1183 1

a1191 1

d1197 3
a1199 1
ahc_poll(struct ahc_softc *ahc, int wait)
d1203 2
d1213 1
a1213 1

d1215 1
d1220 4
a1223 2
ahc_setup_data(struct ahc_softc *ahc, struct scsi_xfer *xs,
	       struct scb *scb)
d1229 2
a1230 2
	xs->error = CAM_REQ_INPROG;

a1231 11
	if (hscb->cdb_len > sizeof(hscb->cdb32)) {
		int s;

		ahc_set_transaction_status(scb, CAM_REQ_INVALID);
		ahc_lock(ahc, &s);
		ahc_free_scb(ahc, scb);
		ahc_unlock(ahc, &s);
		xs->flags |= ITSDONE;
		scsi_done(xs);
		return (COMPLETE);
	}
d1234 2
a1235 1
		memcpy(hscb->cdb32, xs->cmd, hscb->cdb_len);
d1238 3
a1240 1
		memcpy(hscb->shared_data.cdb, xs->cmd, hscb->cdb_len);
d1242 1
a1242 1
		
d1247 1
a1247 1
                error = bus_dmamap_load(ahc->parent_dmat,
d1253 3
a1255 8
#ifdef AHC_DEBUG
                        printf("%s: in ahc_setup_data(): bus_dmamap_load() "
			       "= %d\n",
			       ahc_name(ahc), error);
#endif
			xs->error = XS_BUSY;
			xs->flags |= ITSDONE;
			scsi_done(xs);
d1257 1
a1257 1
}
d1268 4
a1271 1
ahc_set_recoveryscb(struct ahc_softc *ahc, struct scb *scb) {
d1279 7
d1291 1
a1291 1
			timeout_del(&list_scb->xs->stimeout);
d1297 2
a1298 1
ahc_timeout(void *arg)
d1302 1
a1302 2
	int	s;
	int	found;
d1309 2
a1310 2
	scb = (struct scb *)arg;
	ahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;
d1314 6
d1330 1
a1330 1

d1337 5
d1344 1
d1353 1
d1372 1
a1372 1
		 * If the bus is idle and we are acting as the initiator
a1389 5
		bus_dmamap_sync(ahc->parent_dmat,
		    ahc->scb_data->hscb_dmamap,
		    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d1392 3
a1394 2

		if ((ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) == 0
d1399 4
a1402 4
			 * If the active SCB is not us, assume that
			 * the active SCB has a longer timeout than
			 * the timedout SCB, and wait for the active
			 * SCB to timeout.
d1410 1
a1410 1
			 	       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
d1413 3
a1415 3
				newtimeout = MAX(active_scb->xs->timeout,
						 scb->xs->timeout);
				timeout_add(&scb->xs->stimeout,
d1421 1
a1421 1

d1423 1
a1423 1
			if ((scb->flags & SCB_TARGET_SCB) != 0) {
d1429 5
a1433 6
				ahc_abort_scbs(ahc, SCB_GET_TARGET(ahc, scb),
					       SCB_GET_CHANNEL(ahc, scb),
					       SCB_GET_LUN(scb),
					       scb->hscb->tag,
					       ROLE_TARGET,
					       CAM_CMD_TIMEOUT);
d1439 1
a1439 1
			}
d1442 1
a1442 1
			ahc_outb(ahc, MSG_OUT, HOST_MSG);
d1447 1
a1447 1
			timeout_add(&active_scb->xs->stimeout, 2 * hz);
a1451 4
			bus_dmamap_sync(ahc->parent_dmat,
			    ahc->scb_data->hscb_dmamap,
			    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
d1453 1
a1453 1
			if ((scb->flags & SCB_TARGET_SCB) != 0)
a1465 1

d1473 1
a1473 1

d1494 3
a1496 2
				scb->flags |= SCB_DEVICE_RESET;

a1522 1

d1539 1
a1539 1
				timeout_add(&scb->xs->stimeout, 2 * hz);
d1542 2
a1543 2
				/* Go "immediately" to the bus reset. */
				/* This shouldn't happen. */
d1556 9
d1567 4
a1570 2
ahc_platform_set_tags(struct ahc_softc *ahc,
		      struct ahc_devinfo *devinfo, int alg)
d1572 1
d1575 4
a1578 4
	ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
			    devinfo->target, &tstate);

	/* XXXX Need to check quirks before doing this! XXXX */
d1592 3
a1594 1
ahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg)
d1596 10
a1605 7
	if (sizeof(struct ahc_platform_data) > 0) {
		ahc->platform_data = malloc(sizeof(struct ahc_platform_data),
		    M_DEVBUF, M_NOWAIT);
		if (ahc->platform_data == NULL)
			return (ENOMEM);
		bzero(ahc->platform_data, sizeof(struct ahc_platform_data));
	}
d1611 2
a1612 1
ahc_platform_free(struct ahc_softc *ahc)
d1614 1
a1614 2
	if (sizeof(struct ahc_platform_data) > 0)
		free(ahc->platform_data, M_DEVBUF);
d1618 3
a1620 1
ahc_softc_comp(struct ahc_softc *lahc, struct ahc_softc *rahc)
d1622 1
d1627 3
a1629 2
ahc_send_async(struct ahc_softc *ahc, char channel, u_int target, u_int lun,
		u_int code, void *opt_arg)
d1631 35
a1665 1
	/* Nothing to do here for OpenBSD */
d1668 5
a1672 2
void
ahc_adapter_req_set_xfer_mode(struct ahc_softc *ahc, struct scb *scb)
d1674 2
a1675 1
	struct ahc_initiator_tinfo *tinfo;
a1676 1
	struct ahc_syncrate *syncrate;
a1677 3
	u_int16_t quirks;
	u_int width, ppr_options, period, offset;
	int s;
d1679 2
a1680 1
	s = splbio();
d1682 8
a1689 29
	ahc_scb_devinfo(ahc, &devinfo, scb);
	quirks = scb->xs->sc_link->quirks;
	tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
	    devinfo.our_scsiid, devinfo.target, &tstate);

	tstate->discenable |= (ahc->user_discenable & devinfo.target_mask);

	if (quirks & SDEV_NOTAGS)
		tstate->tagenable &= ~devinfo.target_mask;
	else if (ahc->user_tagenable & devinfo.target_mask)
		tstate->tagenable |= devinfo.target_mask;

	if (quirks & SDEV_NOWIDE)
		width = MSG_EXT_WDTR_BUS_8_BIT;
	else
		width = MSG_EXT_WDTR_BUS_16_BIT;

	ahc_validate_width(ahc, NULL, &width, ROLE_UNKNOWN);
	if (width > tinfo->user.width)
		width = tinfo->user.width;
	ahc_set_width(ahc, &devinfo, width, AHC_TRANS_GOAL, FALSE);

	if (quirks & SDEV_NOSYNC) {
		period = 0;
		offset = 0;
	} else {
		period = tinfo->user.period;
		offset = tinfo->user.offset;
	}
d1691 4
a1694 5
	/* XXX Look at saved INQUIRY flags for PPR capabilities XXX */ 
	ppr_options = tinfo->user.ppr_options;
	/* XXX Other reasons to avoid ppr? XXX */
	if (width < MSG_EXT_WDTR_BUS_16_BIT)
		ppr_options = 0;
d1696 2
a1697 3
	if ((tstate->discenable & devinfo.target_mask) == 0 ||
	    (tstate->tagenable & devinfo.target_mask) == 0)
		ppr_options &= ~MSG_EXT_PPR_PROT_IUS;
d1699 2
a1700 4
	syncrate = ahc_find_syncrate(ahc, &period, &ppr_options,
	    AHC_SYNCRATE_MAX);
	ahc_validate_offset(ahc, NULL, syncrate, &offset, width,
	    ROLE_UNKNOWN);
d1702 25
a1726 3
	if (offset == 0) {
		period = 0;
		ppr_options = 0;
d1728 2
d1731 41
a1771 3
	if (ppr_options != 0 && tinfo->user.transport_version >= 3) {
		tinfo->goal.transport_version = tinfo->user.transport_version;
		tinfo->curr.transport_version = tinfo->user.transport_version;
d1773 2
d1776 22
a1797 2
	ahc_set_syncrate(ahc, &devinfo, syncrate, period, offset, ppr_options,
	    AHC_TRANS_GOAL, FALSE);
d1799 11
a1809 1
	splx(s);
d1811 1
@


