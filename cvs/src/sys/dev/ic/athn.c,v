head	1.97;
access;
symbols
	OPENBSD_6_1:1.96.0.4
	OPENBSD_6_1_BASE:1.96
	OPENBSD_6_0:1.93.0.4
	OPENBSD_6_0_BASE:1.93
	OPENBSD_5_9:1.92.0.2
	OPENBSD_5_9_BASE:1.92
	OPENBSD_5_8:1.86.0.4
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.85.0.2
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.83.0.4
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.80.0.4
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.75.0.4
	OPENBSD_5_4_BASE:1.75
	OPENBSD_5_3:1.75.0.2
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.72.0.2
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.71
	OPENBSD_5_1:1.71.0.8
	OPENBSD_5_0:1.71.0.4
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.71.0.2
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.58.0.2
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28;
locks; strict;
comment	@ * @;


1.97
date	2017.05.18.08.35.56;	author stsp;	state Exp;
branches;
next	1.96;
commitid	4sldeuK6cxhhPc1Z;

1.96
date	2017.01.17.20.07.39;	author stsp;	state Exp;
branches;
next	1.95;
commitid	T1Sn6ol1Ii7QjC4F;

1.95
date	2017.01.12.18.06.57;	author stsp;	state Exp;
branches;
next	1.94;
commitid	j9xl1Hx6fze7kB7x;

1.94
date	2017.01.12.16.32.28;	author stsp;	state Exp;
branches;
next	1.93;
commitid	1Zd7y0b8dZf1uELZ;

1.93
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.92;
commitid	QHiEhS9DHyE6oiIr;

1.92
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.91;
commitid	2QagMjdMhQhIaQgu;

1.91
date	2015.12.03.14.39.37;	author stsp;	state Exp;
branches;
next	1.90;
commitid	jwEmqj61FSSrwTyU;

1.90
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.89;
commitid	B0kwmVGiD5DVx4kv;

1.89
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.88;
commitid	5DvsamK0GblTp8ww;

1.88
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.87;
commitid	YT6fyIEviv9qwbl6;

1.87
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.86;
commitid	p0v5tuE1Ch6fY0Nj;

1.86
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.85;
commitid	p4LJxGKbi0BU2cG6;

1.85
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.84;
commitid	yM2VFFhpDTeFQlve;

1.84
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.83;
commitid	LS2TNeCue5R9L67C;

1.83
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.82;
commitid	TGHgrLxu6sxZoiFt;

1.82
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.81;
commitid	I19imNlAX05zJOED;

1.81
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.80;

1.80
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2013.11.26.09.50.32;	author mpi;	state Exp;
branches;
next	1.78;

1.78
date	2013.11.15.01.45.44;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2013.11.11.03.08.20;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2013.08.07.01.06.28;	author bluhm;	state Exp;
branches;
next	1.75;

1.75
date	2013.01.14.09.50.31;	author jsing;	state Exp;
branches;
next	1.74;

1.74
date	2012.10.20.09.54.20;	author stsp;	state Exp;
branches;
next	1.73;

1.73
date	2012.08.25.12.14.31;	author kettenis;	state Exp;
branches;
next	1.72;

1.72
date	2012.06.10.21.23.36;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2011.01.08.15.05.24;	author damien;	state Exp;
branches;
next	1.70;

1.70
date	2011.01.08.10.42.18;	author damien;	state Exp;
branches;
next	1.69;

1.69
date	2011.01.06.07.27.15;	author damien;	state Exp;
branches;
next	1.68;

1.68
date	2010.12.31.21.44.38;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2010.12.31.18.24.41;	author damien;	state Exp;
branches;
next	1.66;

1.66
date	2010.12.31.17.17.14;	author damien;	state Exp;
branches;
next	1.65;

1.65
date	2010.12.31.14.52.47;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2010.12.31.14.06.05;	author damien;	state Exp;
branches;
next	1.63;

1.63
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.18.18.58.01;	author damien;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.12.16.51.30;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2010.08.12.16.32.31;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2010.08.11.07.27.36;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2010.08.02.19.28.31;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.22.10.19.37;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2010.07.21.14.01.58;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.15.20.37.38;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.15.19.07.43;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2010.06.21.19.56.42;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2010.06.21.19.46.50;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.21.19.40.08;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.12.16.30.45;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.05.18.43.57;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.03.18.02.50;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.16.18.01.15;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.16.17.46.38;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.16.14.50.28;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.16.14.34.19;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.16.09.42.04;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.16.09.19.48;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.16.09.02.13;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.16.08.50.58;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.16.08.45.25;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.11.19.34.20;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.10.17.44.21;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.10.19.07.24;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.10.10.59.12;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.07.16.31.16;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.07.16.19.33;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.05.19.09.00;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.05.19.00.50;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2010.03.28.13.02.57;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2010.02.24.20.09.19;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2010.02.24.19.39.43;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2010.02.21.19.57.05;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2010.02.16.18.49.31;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2010.02.15.17.16.36;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2010.02.15.17.00.41;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.27.18.26.45;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.05.23.10.33;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.25.19.53.37;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.25.17.54.37;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.23.19.54.54;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.23.19.11.06;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.23.18.42.50;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.23.17.14.50;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.22.08.52.45;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.21.16.36.59;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.21.15.17.46;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.19.19.19.59;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.17.20.38.29;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.17.19.32.22;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.17.18.46.35;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.17.18.21.07;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.17.18.01.40;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.16.17.09.31;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.16.17.08.14;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.15.14.04.02;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.15.10.25.27;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.14.16.55.11;	author damien;	state Exp;
branches;
next	;


desc
@@


1.97
log
@Fix a uvm fault in athn_clock_rate():
Don't deref an IEEE80211_CHAN_ANYC channel pointer.
ok mpi@@
@
text
@/*	$OpenBSD: athn.c,v 1.96 2017/01/17 20:07:39 stsp Exp $	*/

/*-
 * Copyright (c) 2009 Damien Bergamini <damien.bergamini@@free.fr>
 * Copyright (c) 2008-2010 Atheros Communications Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Atheros 802.11a/g/n chipsets.
 */

#include "athn_usb.h"
#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/stdint.h>	/* uintptr_t */
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_mira.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/athnreg.h>
#include <dev/ic/athnvar.h>

#ifdef ATHN_DEBUG
int athn_debug = 0;
#endif

void		athn_radiotap_attach(struct athn_softc *);
void		athn_get_chanlist(struct athn_softc *);
const char *	athn_get_mac_name(struct athn_softc *);
const char *	athn_get_rf_name(struct athn_softc *);
void		athn_led_init(struct athn_softc *);
void		athn_set_led(struct athn_softc *, int);
void		athn_btcoex_init(struct athn_softc *);
void		athn_btcoex_enable(struct athn_softc *);
void		athn_btcoex_disable(struct athn_softc *);
void		athn_set_rxfilter(struct athn_softc *, uint32_t);
void		athn_get_chipid(struct athn_softc *);
int		athn_reset_power_on(struct athn_softc *);
int		athn_reset(struct athn_softc *, int);
void		athn_init_pll(struct athn_softc *,
		    const struct ieee80211_channel *);
int		athn_set_power_awake(struct athn_softc *);
void		athn_set_power_sleep(struct athn_softc *);
void		athn_write_serdes(struct athn_softc *,
		    const struct athn_serdes *);
void		athn_config_pcie(struct athn_softc *);
void		athn_config_nonpcie(struct athn_softc *);
int		athn_set_chan(struct athn_softc *, struct ieee80211_channel *,
		    struct ieee80211_channel *);
int		athn_switch_chan(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
void		athn_get_delta_slope(uint32_t, uint32_t *, uint32_t *);
void		athn_reset_key(struct athn_softc *, int);
int		athn_set_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
void		athn_delete_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
void		athn_iter_calib(void *, struct ieee80211_node *);
void		athn_calib_to(void *);
int		athn_init_calib(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
uint8_t		athn_chan2fbin(struct ieee80211_channel *);
int		athn_interpolate(int, int, int, int, int);
void		athn_get_pier_ival(uint8_t, const uint8_t *, int, int *,
		    int *);
void		athn_init_dma(struct athn_softc *);
void		athn_rx_start(struct athn_softc *);
void		athn_inc_tx_trigger_level(struct athn_softc *);
int		athn_stop_rx_dma(struct athn_softc *);
int		athn_rx_abort(struct athn_softc *);
void		athn_tx_reclaim(struct athn_softc *, int);
int		athn_tx_pending(struct athn_softc *, int);
void		athn_stop_tx_dma(struct athn_softc *, int);
int		athn_txtime(struct athn_softc *, int, int, u_int);
void		athn_set_sta_timers(struct athn_softc *);
void		athn_set_hostap_timers(struct athn_softc *);
void		athn_set_opmode(struct athn_softc *);
void		athn_set_bss(struct athn_softc *, struct ieee80211_node *);
void		athn_enable_interrupts(struct athn_softc *);
void		athn_disable_interrupts(struct athn_softc *);
void		athn_init_qos(struct athn_softc *);
int		athn_hw_reset(struct athn_softc *, struct ieee80211_channel *,
		    struct ieee80211_channel *, int);
struct		ieee80211_node *athn_node_alloc(struct ieee80211com *);
void		athn_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
void		athn_node_leave(struct ieee80211com *, struct ieee80211_node *);
int		athn_media_change(struct ifnet *);
void		athn_next_scan(void *);
void		athn_iter_mira_delete(void *, struct ieee80211_node *);
void		athn_delete_mira_nodes(struct athn_softc *);
int		athn_newstate(struct ieee80211com *, enum ieee80211_state,
		    int);
void		athn_updateedca(struct ieee80211com *);
int		athn_clock_rate(struct athn_softc *);
void		athn_updateslot(struct ieee80211com *);
void		athn_start(struct ifnet *);
void		athn_watchdog(struct ifnet *);
void		athn_set_multi(struct athn_softc *);
int		athn_ioctl(struct ifnet *, u_long, caddr_t);
int		athn_init(struct ifnet *);
void		athn_stop(struct ifnet *, int);
void		athn_init_tx_queues(struct athn_softc *);
int32_t		athn_ani_get_rssi(struct athn_softc *);
void		athn_ani_ofdm_err_trigger(struct athn_softc *);
void		athn_ani_cck_err_trigger(struct athn_softc *);
void		athn_ani_lower_immunity(struct athn_softc *);
void		athn_ani_restart(struct athn_softc *);
void		athn_ani_monitor(struct athn_softc *);

/* Extern functions. */
int		ar5416_attach(struct athn_softc *);
int		ar9280_attach(struct athn_softc *);
int		ar9285_attach(struct athn_softc *);
int		ar9287_attach(struct athn_softc *);
int		ar9380_attach(struct athn_softc *);
int		ar5416_init_calib(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
int		ar9285_init_calib(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
int		ar9003_init_calib(struct athn_softc *);
void		ar9285_pa_calib(struct athn_softc *);
void		ar9271_pa_calib(struct athn_softc *);
void		ar9287_1_3_enable_async_fifo(struct athn_softc *);
void		ar9287_1_3_setup_async_fifo(struct athn_softc *);
void		ar9003_reset_txsring(struct athn_softc *);

struct cfdriver athn_cd = {
	NULL, "athn", DV_IFNET
};

int
athn_attach(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int error;

	/* Read hardware revision. */
	athn_get_chipid(sc);

	if ((error = athn_reset_power_on(sc)) != 0) {
		printf("%s: could not reset chip\n", sc->sc_dev.dv_xname);
		return (error);
	}

	if ((error = athn_set_power_awake(sc)) != 0) {
		printf("%s: could not wakeup chip\n", sc->sc_dev.dv_xname);
		return (error);
	}

	if (AR_SREV_5416(sc) || AR_SREV_9160(sc))
		error = ar5416_attach(sc);
	else if (AR_SREV_9280(sc))
		error = ar9280_attach(sc);
	else if (AR_SREV_9285(sc))
		error = ar9285_attach(sc);
#if NATHN_USB > 0
	else if (AR_SREV_9271(sc))
		error = ar9285_attach(sc);
#endif
	else if (AR_SREV_9287(sc))
		error = ar9287_attach(sc);
	else if (AR_SREV_9380(sc) || AR_SREV_9485(sc))
		error = ar9380_attach(sc);
	else
		error = ENOTSUP;
	if (error != 0) {
		printf("%s: could not attach chip\n", sc->sc_dev.dv_xname);
		return (error);
	}

	/* We can put the chip in sleep state now. */
	athn_set_power_sleep(sc);

	if (!(sc->flags & ATHN_FLAG_USB)) {
		error = sc->ops.dma_alloc(sc);
		if (error != 0) {
			printf("%s: could not allocate DMA resources\n",
			    sc->sc_dev.dv_xname);
			return (error);
		}
		/* Steal one Tx buffer for beacons. */
		sc->bcnbuf = SIMPLEQ_FIRST(&sc->txbufs);
		SIMPLEQ_REMOVE_HEAD(&sc->txbufs, bf_list);
	}

	if (sc->flags & ATHN_FLAG_RFSILENT) {
		DPRINTF(("found RF switch connected to GPIO pin %d\n",
		    sc->rfsilent_pin));
	}
	DPRINTF(("%d key cache entries\n", sc->kc_entries));
	/*
	 * In HostAP mode, the number of STAs that we can handle is
	 * limited by the number of entries in the HW key cache.
	 * TKIP keys consume 2 entries in the cache.
	 */
	ic->ic_max_nnodes = (sc->kc_entries / 2) - IEEE80211_WEP_NKID;
	if (ic->ic_max_nnodes > IEEE80211_CACHE_SIZE)
		ic->ic_max_nnodes = IEEE80211_CACHE_SIZE;

	DPRINTF(("using %s loop power control\n",
	    (sc->flags & ATHN_FLAG_OLPC) ? "open" : "closed"));

	DPRINTF(("txchainmask=0x%x rxchainmask=0x%x\n",
	    sc->txchainmask, sc->rxchainmask));
	/* Count the number of bits set (in lowest 3 bits). */
	sc->ntxchains =
	    ((sc->txchainmask >> 2) & 1) +
	    ((sc->txchainmask >> 1) & 1) +
	    ((sc->txchainmask >> 0) & 1);
	sc->nrxchains =
	    ((sc->rxchainmask >> 2) & 1) +
	    ((sc->rxchainmask >> 1) & 1) +
	    ((sc->rxchainmask >> 0) & 1);

	if (AR_SINGLE_CHIP(sc)) {
		printf("%s: %s rev %d (%dT%dR), ROM rev %d, address %s\n",
		    sc->sc_dev.dv_xname, athn_get_mac_name(sc), sc->mac_rev,
		    sc->ntxchains, sc->nrxchains, sc->eep_rev,
		    ether_sprintf(ic->ic_myaddr));
	} else {
		printf("%s: MAC %s rev %d, RF %s (%dT%dR), ROM rev %d, "
		    "address %s\n",
		    sc->sc_dev.dv_xname, athn_get_mac_name(sc), sc->mac_rev,
		    athn_get_rf_name(sc), sc->ntxchains, sc->nrxchains,
		    sc->eep_rev, ether_sprintf(ic->ic_myaddr));
	}

	timeout_set(&sc->scan_to, athn_next_scan, sc);
	timeout_set(&sc->calib_to, athn_calib_to, sc);

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 15;

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* Set device capabilities. */
	ic->ic_caps =
	    IEEE80211_C_WEP |		/* WEP. */
	    IEEE80211_C_RSN |		/* WPA/RSN. */
#ifndef IEEE80211_STA_ONLY
	    IEEE80211_C_HOSTAP |	/* Host AP mode supported. */
	    IEEE80211_C_APPMGT |	/* Host AP power saving supported. */
#endif
	    IEEE80211_C_MONITOR |	/* Monitor mode supported. */
	    IEEE80211_C_SHSLOT |	/* Short slot time supported. */
	    IEEE80211_C_SHPREAMBLE |	/* Short preamble supported. */
	    IEEE80211_C_PMGT;		/* Power saving supported. */

	if (sc->flags & ATHN_FLAG_11N) {
		int i, ntxstreams, nrxstreams;

		/* Set HT capabilities. */
		ic->ic_htcaps = (IEEE80211_HTCAP_SMPS_DIS <<
		    IEEE80211_HTCAP_SMPS_SHIFT);
#ifdef notyet
		ic->ic_htcaps |= IEEE80211_HTCAP_CBW20_40 |
		    IEEE80211_HTCAP_SGI40 |
		    IEEE80211_HTCAP_DSSSCCK40;
#endif
		ic->ic_htxcaps = 0;
#ifdef notyet
		if (AR_SREV_9271(sc) || AR_SREV_9287_10_OR_LATER(sc))
			ic->ic_htcaps |= IEEE80211_HTCAP_SGI20;
		if (AR_SREV_9380_10_OR_LATER(sc))
			ic->ic_htcaps |= IEEE80211_HTCAP_LDPC;
		if (AR_SREV_9280_10_OR_LATER(sc)) {
			ic->ic_htcaps |= IEEE80211_HTCAP_TXSTBC;
			ic->ic_htcaps |= 1 << IEEE80211_HTCAP_RXSTBC_SHIFT;
		}
#endif
		ntxstreams = sc->ntxchains;
		nrxstreams = sc->nrxchains;
		if (!AR_SREV_9380_10_OR_LATER(sc)) {
			ntxstreams = MIN(ntxstreams, 2);
			nrxstreams = MIN(nrxstreams, 2);
		}
		/* Set supported HT rates. */
		for (i = 0; i < nrxstreams; i++)
			ic->ic_sup_mcs[i] = 0xff;
		ic->ic_tx_mcs_set |= IEEE80211_TX_MCS_SET_DEFINED;
		if (ntxstreams != nrxstreams) {
			ic->ic_tx_mcs_set |= IEEE80211_TX_RX_MCS_NOT_EQUAL;
			ic->ic_tx_mcs_set |= (ntxstreams - 1) << 2;
		}
	}

	/* Set supported rates. */
	if (sc->flags & ATHN_FLAG_11G) {
		ic->ic_sup_rates[IEEE80211_MODE_11B] =
		    ieee80211_std_rateset_11b;
		ic->ic_sup_rates[IEEE80211_MODE_11G] =
		    ieee80211_std_rateset_11g;
	}
	if (sc->flags & ATHN_FLAG_11A) {
		ic->ic_sup_rates[IEEE80211_MODE_11A] =
		    ieee80211_std_rateset_11a;
	}

	/* Get the list of authorized/supported channels. */
	athn_get_chanlist(sc);

	/* IBSS channel undefined for now. */
	ic->ic_ibss_chan = &ic->ic_channels[0];

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = athn_ioctl;
	ifp->if_start = athn_start;
	ifp->if_watchdog = athn_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_node_alloc = athn_node_alloc;
#ifndef IEEE80211_STA_ONLY
	ic->ic_node_leave = athn_node_leave;
#endif
	ic->ic_newassoc = athn_newassoc;
	ic->ic_updateslot = athn_updateslot;
	ic->ic_updateedca = athn_updateedca;
#ifdef notyet
	ic->ic_set_key = athn_set_key;
	ic->ic_delete_key = athn_delete_key;
#endif

	/* Override 802.11 state transition machine. */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = athn_newstate;
	ieee80211_media_init(ifp, athn_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	athn_radiotap_attach(sc);
#endif

	return (0);
}

void
athn_detach(struct athn_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct ieee80211com *ic = &sc->sc_ic;
	int qid;

	timeout_del(&sc->scan_to);
	timeout_del(&sc->calib_to);
	if (ic->ic_flags & IEEE80211_F_HTON)
		athn_delete_mira_nodes(sc);

	if (!(sc->flags & ATHN_FLAG_USB)) {
		for (qid = 0; qid < ATHN_QID_COUNT; qid++)
			athn_tx_reclaim(sc, qid);

		/* Free Tx/Rx DMA resources. */
		sc->ops.dma_free(sc);
	}
	/* Free ROM copy. */
	if (sc->eep != NULL)
		free(sc->eep, M_DEVBUF, 0);

	ieee80211_ifdetach(ifp);
	if_detach(ifp);
}

#if NBPFILTER > 0
/*
 * Attach the interface to 802.11 radiotap.
 */
void
athn_radiotap_attach(struct athn_softc *sc)
{
	bpfattach(&sc->sc_drvbpf, &sc->sc_ic.ic_if, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(ATHN_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(ATHN_TX_RADIOTAP_PRESENT);
}
#endif

void
athn_get_chanlist(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t chan;
	int i;

	if (sc->flags & ATHN_FLAG_11G) {
		for (i = 1; i <= 14; i++) {
			chan = i;
			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_2GHZ);
			ic->ic_channels[chan].ic_flags =
			    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
			    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
			if (sc->flags & ATHN_FLAG_11N)
				ic->ic_channels[chan].ic_flags |=
				    IEEE80211_CHAN_HT;
		}
	}
	if (sc->flags & ATHN_FLAG_11A) {
		for (i = 0; i < nitems(athn_5ghz_chans); i++) {
			chan = athn_5ghz_chans[i];
			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[chan].ic_flags = IEEE80211_CHAN_A;
			if (sc->flags & ATHN_FLAG_11N)
				ic->ic_channels[chan].ic_flags |=
				    IEEE80211_CHAN_HT;
		}
	}
}

void
athn_rx_start(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t rfilt;

	/* Setup Rx DMA descriptors. */
	sc->ops.rx_enable(sc);

	/* Set Rx filter. */
	rfilt = AR_RX_FILTER_UCAST | AR_RX_FILTER_BCAST | AR_RX_FILTER_MCAST;
	/* Want Compressed Block Ack Requests. */
	rfilt |= AR_RX_FILTER_COMPR_BAR;
	rfilt |= AR_RX_FILTER_BEACON;
	if (ic->ic_opmode != IEEE80211_M_STA) {
		rfilt |= AR_RX_FILTER_PROBEREQ;
		if (ic->ic_opmode == IEEE80211_M_MONITOR)
			rfilt |= AR_RX_FILTER_PROM;
#ifndef IEEE80211_STA_ONLY
		if (AR_SREV_9280_10_OR_LATER(sc) &&
		    ic->ic_opmode == IEEE80211_M_HOSTAP)
			rfilt |= AR_RX_FILTER_PSPOLL;
#endif
	}
	athn_set_rxfilter(sc, rfilt);

	/* Set BSSID mask. */
	AR_WRITE(sc, AR_BSSMSKL, 0xffffffff);
	AR_WRITE(sc, AR_BSSMSKU, 0xffff);

	athn_set_opmode(sc);

	/* Set multicast filter. */
	AR_WRITE(sc, AR_MCAST_FIL0, 0xffffffff);
	AR_WRITE(sc, AR_MCAST_FIL1, 0xffffffff);

	AR_WRITE(sc, AR_FILT_OFDM, 0);
	AR_WRITE(sc, AR_FILT_CCK, 0);
	AR_WRITE(sc, AR_MIBC, 0);
	AR_WRITE(sc, AR_PHY_ERR_MASK_1, AR_PHY_ERR_OFDM_TIMING);
	AR_WRITE(sc, AR_PHY_ERR_MASK_2, AR_PHY_ERR_CCK_TIMING);

	/* XXX ANI. */
	AR_WRITE(sc, AR_PHY_ERR_1, 0);
	AR_WRITE(sc, AR_PHY_ERR_2, 0);

	/* Disable HW crypto for now. */
	AR_SETBITS(sc, AR_DIAG_SW, AR_DIAG_ENCRYPT_DIS | AR_DIAG_DECRYPT_DIS);

	/* Start PCU Rx. */
	AR_CLRBITS(sc, AR_DIAG_SW, AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT);
	AR_WRITE_BARRIER(sc);
}

void
athn_set_rxfilter(struct athn_softc *sc, uint32_t rfilt)
{
	AR_WRITE(sc, AR_RX_FILTER, rfilt);

#ifdef notyet
	reg = AR_READ(sc, AR_PHY_ERR);
	reg &= (AR_PHY_ERR_RADAR | AR_PHY_ERR_OFDM_TIMING |
	    AR_PHY_ERR_CCK_TIMING);
	AR_WRITE(sc, AR_PHY_ERR, reg);
	if (reg != 0)
		AR_SETBITS(sc, AR_RXCFG, AR_RXCFG_ZLFDMA);
	else
		AR_CLRBITS(sc, AR_RXCFG, AR_RXCFG_ZLFDMA);
#else
	AR_WRITE(sc, AR_PHY_ERR, 0);
	AR_CLRBITS(sc, AR_RXCFG, AR_RXCFG_ZLFDMA);
#endif
	AR_WRITE_BARRIER(sc);
}

int
athn_intr(void *xsc)
{
	struct athn_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) !=
	    (IFF_UP | IFF_RUNNING))
		return (0);

	return (sc->ops.intr(sc));
}

void
athn_get_chipid(struct athn_softc *sc)
{
	uint32_t reg;

	reg = AR_READ(sc, AR_SREV);
	if (MS(reg, AR_SREV_ID) == 0xff) {
		sc->mac_ver = MS(reg, AR_SREV_VERSION2);
		sc->mac_rev = MS(reg, AR_SREV_REVISION2);
		if (!(reg & AR_SREV_TYPE2_HOST_MODE))
			sc->flags |= ATHN_FLAG_PCIE;
	} else {
		sc->mac_ver = MS(reg, AR_SREV_VERSION);
		sc->mac_rev = MS(reg, AR_SREV_REVISION);
		if (sc->mac_ver == AR_SREV_VERSION_5416_PCIE)
			sc->flags |= ATHN_FLAG_PCIE;
	}
}

const char *
athn_get_mac_name(struct athn_softc *sc)
{
	switch (sc->mac_ver) {
	case AR_SREV_VERSION_5416_PCI:
		return ("AR5416");
	case AR_SREV_VERSION_5416_PCIE:
		return ("AR5418");
	case AR_SREV_VERSION_9160:
		return ("AR9160");
	case AR_SREV_VERSION_9280:
		return ("AR9280");
	case AR_SREV_VERSION_9285:
		return ("AR9285");
	case AR_SREV_VERSION_9271:
		return ("AR9271");
	case AR_SREV_VERSION_9287:
		return ("AR9287");
	case AR_SREV_VERSION_9380:
		return ("AR9380");
	case AR_SREV_VERSION_9485:
		return ("AR9485");
	}
	return ("unknown");
}

/*
 * Return RF chip name (not for single-chip solutions).
 */
const char *
athn_get_rf_name(struct athn_softc *sc)
{
	KASSERT(!AR_SINGLE_CHIP(sc));

	switch (sc->rf_rev) {
	case AR_RAD5133_SREV_MAJOR:	/* Dual-band 3T3R. */
		return ("AR5133");
	case AR_RAD2133_SREV_MAJOR:	/* Single-band 3T3R. */
		return ("AR2133");
	case AR_RAD5122_SREV_MAJOR:	/* Dual-band 2T2R. */
		return ("AR5122");
	case AR_RAD2122_SREV_MAJOR:	/* Single-band 2T2R. */
		return ("AR2122");
	}
	return ("unknown");
}

int
athn_reset_power_on(struct athn_softc *sc)
{
	int ntries;

	/* Set force wake. */
	AR_WRITE(sc, AR_RTC_FORCE_WAKE,
	    AR_RTC_FORCE_WAKE_EN | AR_RTC_FORCE_WAKE_ON_INT);

	if (!AR_SREV_9380_10_OR_LATER(sc)) {
		/* Make sure no DMA is active by doing an AHB reset. */
		AR_WRITE(sc, AR_RC, AR_RC_AHB);
	}
	/* RTC reset and clear. */
	AR_WRITE(sc, AR_RTC_RESET, 0);
	AR_WRITE_BARRIER(sc);
	DELAY(2);
	if (!AR_SREV_9380_10_OR_LATER(sc))
		AR_WRITE(sc, AR_RC, 0);
	AR_WRITE(sc, AR_RTC_RESET, 1);

	/* Poll until RTC is ON. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if ((AR_READ(sc, AR_RTC_STATUS) & AR_RTC_STATUS_M) ==
		    AR_RTC_STATUS_ON)
			break;
		DELAY(10);
	}
	if (ntries == 1000) {
		DPRINTF(("RTC not waking up\n"));
		return (ETIMEDOUT);
	}
	return (athn_reset(sc, 0));
}

int
athn_reset(struct athn_softc *sc, int cold)
{
	int ntries;

	/* Set force wake. */
	AR_WRITE(sc, AR_RTC_FORCE_WAKE,
	    AR_RTC_FORCE_WAKE_EN | AR_RTC_FORCE_WAKE_ON_INT);

	if (AR_READ(sc, AR_INTR_SYNC_CAUSE) &
	    (AR_INTR_SYNC_LOCAL_TIMEOUT | AR_INTR_SYNC_RADM_CPL_TIMEOUT)) {
		AR_WRITE(sc, AR_INTR_SYNC_ENABLE, 0);
		AR_WRITE(sc, AR_RC, AR_RC_HOSTIF |
		    (!AR_SREV_9380_10_OR_LATER(sc) ? AR_RC_AHB : 0));
	} else if (!AR_SREV_9380_10_OR_LATER(sc))
		AR_WRITE(sc, AR_RC, AR_RC_AHB);

	AR_WRITE(sc, AR_RTC_RC, AR_RTC_RC_MAC_WARM |
	    (cold ? AR_RTC_RC_MAC_COLD : 0));
	AR_WRITE_BARRIER(sc);
	DELAY(50);
	AR_WRITE(sc, AR_RTC_RC, 0);
	for (ntries = 0; ntries < 1000; ntries++) {
		if (!(AR_READ(sc, AR_RTC_RC) &
		      (AR_RTC_RC_MAC_WARM | AR_RTC_RC_MAC_COLD)))
			break;
		DELAY(10);
	}
	if (ntries == 1000) {
		DPRINTF(("RTC stuck in MAC reset\n"));
		return (ETIMEDOUT);
	}
	AR_WRITE(sc, AR_RC, 0);
	AR_WRITE_BARRIER(sc);
	return (0);
}

int
athn_set_power_awake(struct athn_softc *sc)
{
	int ntries, error;

	/* Do a Power-On-Reset if shutdown. */
	if ((AR_READ(sc, AR_RTC_STATUS) & AR_RTC_STATUS_M) ==
	    AR_RTC_STATUS_SHUTDOWN) {
		if ((error = athn_reset_power_on(sc)) != 0)
			return (error);
		if (!AR_SREV_9380_10_OR_LATER(sc))
			athn_init_pll(sc, NULL);
	}
	AR_SETBITS(sc, AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_EN);
	AR_WRITE_BARRIER(sc);
	DELAY(50);	/* Give chip the chance to awake. */

	/* Poll until RTC is ON. */
	for (ntries = 0; ntries < 4000; ntries++) {
		if ((AR_READ(sc, AR_RTC_STATUS) & AR_RTC_STATUS_M) ==
		    AR_RTC_STATUS_ON)
			break;
		DELAY(50);
		AR_SETBITS(sc, AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_EN);
	}
	if (ntries == 4000) {
		DPRINTF(("RTC not waking up\n"));
		return (ETIMEDOUT);
	}

	AR_CLRBITS(sc, AR_STA_ID1, AR_STA_ID1_PWR_SAV);
	AR_WRITE_BARRIER(sc);
	return (0);
}

void
athn_set_power_sleep(struct athn_softc *sc)
{
	AR_SETBITS(sc, AR_STA_ID1, AR_STA_ID1_PWR_SAV);
	/* Allow the MAC to go to sleep. */
	AR_CLRBITS(sc, AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_EN);
	if (!AR_SREV_9380_10_OR_LATER(sc))
		AR_WRITE(sc, AR_RC, AR_RC_AHB | AR_RC_HOSTIF);
	/*
	 * NB: Clearing RTC_RESET_EN when setting the chip to sleep mode
	 * results in high power consumption on AR5416 chipsets.
	 */
	if (!AR_SREV_5416(sc) && !AR_SREV_9271(sc))
		AR_CLRBITS(sc, AR_RTC_RESET, AR_RTC_RESET_EN);
	AR_WRITE_BARRIER(sc);
}

void
athn_init_pll(struct athn_softc *sc, const struct ieee80211_channel *c)
{
	uint32_t pll;

	if (AR_SREV_9380_10_OR_LATER(sc)) {
		if (AR_SREV_9485(sc))
			AR_WRITE(sc, AR_RTC_PLL_CONTROL2, 0x886666);
		pll = SM(AR_RTC_9160_PLL_REFDIV, 0x5);
		pll |= SM(AR_RTC_9160_PLL_DIV, 0x2c);
	} else if (AR_SREV_9280_10_OR_LATER(sc)) {
		pll = SM(AR_RTC_9160_PLL_REFDIV, 0x05);
		if (c != NULL && IEEE80211_IS_CHAN_5GHZ(c)) {
			if (sc->flags & ATHN_FLAG_FAST_PLL_CLOCK)
				pll = 0x142c;
			else if (AR_SREV_9280_20(sc))
		 		pll = 0x2850;
			else
				pll |= SM(AR_RTC_9160_PLL_DIV, 0x28);
		} else
			pll |= SM(AR_RTC_9160_PLL_DIV, 0x2c);
	} else if (AR_SREV_9160_10_OR_LATER(sc)) {
		pll = SM(AR_RTC_9160_PLL_REFDIV, 0x05);
		if (c != NULL && IEEE80211_IS_CHAN_5GHZ(c))
			pll |= SM(AR_RTC_9160_PLL_DIV, 0x50);
		else
			pll |= SM(AR_RTC_9160_PLL_DIV, 0x58);
	} else {
		pll = AR_RTC_PLL_REFDIV_5 | AR_RTC_PLL_DIV2;
		if (c != NULL && IEEE80211_IS_CHAN_5GHZ(c))
			pll |= SM(AR_RTC_PLL_DIV, 0x0a);
		else
			pll |= SM(AR_RTC_PLL_DIV, 0x0b);
	}
	DPRINTFN(5, ("AR_RTC_PLL_CONTROL=0x%08x\n", pll));
	AR_WRITE(sc, AR_RTC_PLL_CONTROL, pll);
	if (AR_SREV_9271(sc)) {
		/* Switch core clock to 117MHz. */
		AR_WRITE_BARRIER(sc);
		DELAY(500);
		AR_WRITE(sc, 0x50050, 0x304);
	}
	AR_WRITE_BARRIER(sc);
	DELAY(100);
	AR_WRITE(sc, AR_RTC_SLEEP_CLK, AR_RTC_FORCE_DERIVED_CLK);
	AR_WRITE_BARRIER(sc);
}

void
athn_write_serdes(struct athn_softc *sc, const struct athn_serdes *serdes)
{
	int i;

	/* Write sequence to Serializer/Deserializer. */
	for (i = 0; i < serdes->nvals; i++)
		AR_WRITE(sc, serdes->regs[i], serdes->vals[i]);
	AR_WRITE_BARRIER(sc);
}

void
athn_config_pcie(struct athn_softc *sc)
{
	/* Disable PLL when in L0s as well as receiver clock when in L1. */
	athn_write_serdes(sc, sc->serdes);

	DELAY(1000);
	/* Allow forcing of PCIe core into L1 state. */
	AR_SETBITS(sc, AR_PCIE_PM_CTRL, AR_PCIE_PM_CTRL_ENA);

#ifndef ATHN_PCIE_WAEN
	AR_WRITE(sc, AR_WA, sc->workaround);
#else
	AR_WRITE(sc, AR_WA, ATHN_PCIE_WAEN);
#endif
	AR_WRITE_BARRIER(sc);
}

/*
 * Serializer/Deserializer programming for non-PCIe devices.
 */
static const uint32_t ar_nonpcie_serdes_regs[] = {
	AR_PCIE_SERDES,
	AR_PCIE_SERDES,
	AR_PCIE_SERDES,
	AR_PCIE_SERDES,
	AR_PCIE_SERDES,
	AR_PCIE_SERDES,
	AR_PCIE_SERDES,
	AR_PCIE_SERDES,
	AR_PCIE_SERDES,
	AR_PCIE_SERDES2,
};

static const uint32_t ar_nonpcie_serdes_vals[] = {
	0x9248fc00,
	0x24924924,
	0x28000029,
	0x57160824,
	0x25980579,
	0x00000000,
	0x1aaabe40,
	0xbe105554,
	0x000e1007,
	0x00000000
};

static const struct athn_serdes ar_nonpcie_serdes = {
	nitems(ar_nonpcie_serdes_vals),
	ar_nonpcie_serdes_regs,
	ar_nonpcie_serdes_vals
};

void
athn_config_nonpcie(struct athn_softc *sc)
{
	athn_write_serdes(sc, &ar_nonpcie_serdes);
}

int
athn_set_chan(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	struct athn_ops *ops = &sc->ops;
	int error, qid;

	/* Check that Tx is stopped, otherwise RF Bus grant will not work. */
	for (qid = 0; qid < ATHN_QID_COUNT; qid++)
		if (athn_tx_pending(sc, qid))
			return (EBUSY);

	/* Request RF Bus grant. */
	if ((error = ops->rf_bus_request(sc)) != 0)
		return (error);

	ops->set_phy(sc, c, extc);

	/* Change the synthesizer. */
	if ((error = ops->set_synth(sc, c, extc)) != 0)
		return (error);

	sc->curchan = c;
	sc->curchanext = extc;

	/* Set transmit power values for new channel. */
	ops->set_txpower(sc, c, extc);

	/* Release the RF Bus grant. */
	ops->rf_bus_release(sc);

	/* Write delta slope coeffs for modes where OFDM may be used. */
	if (sc->sc_ic.ic_curmode != IEEE80211_MODE_11B)
		ops->set_delta_slope(sc, c, extc);

	ops->spur_mitigate(sc, c, extc);
	/* XXX Load noisefloor values and start calibration. */

	return (0);
}

int
athn_switch_chan(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	int error, qid;

	/* Disable interrupts. */
	athn_disable_interrupts(sc);

	/* Stop all Tx queues. */
	for (qid = 0; qid < ATHN_QID_COUNT; qid++)
		athn_stop_tx_dma(sc, qid);
	for (qid = 0; qid < ATHN_QID_COUNT; qid++)
		athn_tx_reclaim(sc, qid);

	/* Stop Rx. */
	AR_SETBITS(sc, AR_DIAG_SW, AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT);
	AR_WRITE(sc, AR_MIBC, AR_MIBC_FMC);
	AR_WRITE(sc, AR_MIBC, AR_MIBC_CMC);
	AR_WRITE(sc, AR_FILT_OFDM, 0);
	AR_WRITE(sc, AR_FILT_CCK, 0);
	athn_set_rxfilter(sc, 0);
	error = athn_stop_rx_dma(sc);
	if (error != 0)
		goto reset;

#ifdef notyet
	/* AR9280 needs a full reset. */
	if (AR_SREV_9280(sc))
#endif
		goto reset;

	/* If band or bandwidth changes, we need to do a full reset. */
	if (c->ic_flags != sc->curchan->ic_flags ||
	    ((extc != NULL) ^ (sc->curchanext != NULL))) {
		DPRINTFN(2, ("channel band switch\n"));
		goto reset;
	}
	error = athn_set_power_awake(sc);
	if (error != 0)
		goto reset;

	error = athn_set_chan(sc, c, extc);
	if (error != 0) {
 reset:		/* Error found, try a full reset. */
		DPRINTFN(3, ("needs a full reset\n"));
		error = athn_hw_reset(sc, c, extc, 0);
		if (error != 0)	/* Hopeless case. */
			return (error);
	}
	athn_rx_start(sc);

	/* Re-enable interrupts. */
	athn_enable_interrupts(sc);
	return (0);
}

void
athn_get_delta_slope(uint32_t coeff, uint32_t *exponent, uint32_t *mantissa)
{
#define COEFF_SCALE_SHIFT	24
	uint32_t exp, man;

	/* exponent = 14 - floor(log2(coeff)) */
	for (exp = 31; exp > 0; exp--)
		if (coeff & (1 << exp))
			break;
	exp = 14 - (exp - COEFF_SCALE_SHIFT);

	/* mantissa = floor(coeff * 2^exponent + 0.5) */
	man = coeff + (1 << (COEFF_SCALE_SHIFT - exp - 1));

	*mantissa = man >> (COEFF_SCALE_SHIFT - exp);
	*exponent = exp - 16;
#undef COEFF_SCALE_SHIFT
}

void
athn_reset_key(struct athn_softc *sc, int entry)
{
	/*
	 * NB: Key cache registers access special memory area that requires
	 * two 32-bit writes to actually update the values in the internal
	 * memory.  Consequently, writes must be grouped by pair.
	 */
	AR_WRITE(sc, AR_KEYTABLE_KEY0(entry), 0);
	AR_WRITE(sc, AR_KEYTABLE_KEY1(entry), 0);

	AR_WRITE(sc, AR_KEYTABLE_KEY2(entry), 0);
	AR_WRITE(sc, AR_KEYTABLE_KEY3(entry), 0);

	AR_WRITE(sc, AR_KEYTABLE_KEY4(entry), 0);
	AR_WRITE(sc, AR_KEYTABLE_TYPE(entry), AR_KEYTABLE_TYPE_CLR);

	AR_WRITE(sc, AR_KEYTABLE_MAC0(entry), 0);
	AR_WRITE(sc, AR_KEYTABLE_MAC1(entry), 0);

	AR_WRITE_BARRIER(sc);
}

int
athn_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct athn_softc *sc = ic->ic_softc;
	const uint8_t *txmic, *rxmic, *key, *addr;
	uintptr_t entry, micentry;
	uint32_t type, lo, hi;

	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
		type = AR_KEYTABLE_TYPE_40;
		break;
	case IEEE80211_CIPHER_WEP104:
		type = AR_KEYTABLE_TYPE_104;
		break;
	case IEEE80211_CIPHER_TKIP:
		type = AR_KEYTABLE_TYPE_TKIP;
		break;
	case IEEE80211_CIPHER_CCMP:
		type = AR_KEYTABLE_TYPE_CCM;
		break;
	default:
		/* Fallback to software crypto for other ciphers. */
		return (ieee80211_set_key(ic, ni, k));
	}

	if (!(k->k_flags & IEEE80211_KEY_GROUP))
		entry = IEEE80211_WEP_NKID + IEEE80211_AID(ni->ni_associd);
	else
		entry = k->k_id;
	k->k_priv = (void *)entry;

	/* NB: See note about key cache registers access above. */
	key = k->k_key;
	if (type == AR_KEYTABLE_TYPE_TKIP) {
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
			txmic = &key[16];
			rxmic = &key[24];
		} else
#endif
		{
			rxmic = &key[16];
			txmic = &key[24];
		}
		/* Tx+Rx MIC key is at entry + 64. */
		micentry = entry + 64;
		AR_WRITE(sc, AR_KEYTABLE_KEY0(micentry), LE_READ_4(&rxmic[0]));
		AR_WRITE(sc, AR_KEYTABLE_KEY1(micentry), LE_READ_2(&txmic[2]));

		AR_WRITE(sc, AR_KEYTABLE_KEY2(micentry), LE_READ_4(&rxmic[4]));
		AR_WRITE(sc, AR_KEYTABLE_KEY3(micentry), LE_READ_2(&txmic[0]));

		AR_WRITE(sc, AR_KEYTABLE_KEY4(micentry), LE_READ_4(&txmic[4]));
		AR_WRITE(sc, AR_KEYTABLE_TYPE(micentry), AR_KEYTABLE_TYPE_CLR);
	}
	AR_WRITE(sc, AR_KEYTABLE_KEY0(entry), LE_READ_4(&key[ 0]));
	AR_WRITE(sc, AR_KEYTABLE_KEY1(entry), LE_READ_2(&key[ 4]));

	AR_WRITE(sc, AR_KEYTABLE_KEY2(entry), LE_READ_4(&key[ 6]));
	AR_WRITE(sc, AR_KEYTABLE_KEY3(entry), LE_READ_2(&key[10]));

	AR_WRITE(sc, AR_KEYTABLE_KEY4(entry), LE_READ_4(&key[12]));
	AR_WRITE(sc, AR_KEYTABLE_TYPE(entry), type);

	if (!(k->k_flags & IEEE80211_KEY_GROUP)) {
		addr = ni->ni_macaddr;
		lo = LE_READ_4(&addr[0]);
		hi = LE_READ_2(&addr[4]);
		lo = lo >> 1 | hi << 31;
		hi = hi >> 1;
	} else
		lo = hi = 0;
	AR_WRITE(sc, AR_KEYTABLE_MAC0(entry), lo);
	AR_WRITE(sc, AR_KEYTABLE_MAC1(entry), hi | AR_KEYTABLE_VALID);
	AR_WRITE_BARRIER(sc);
	return (0);
}

void
athn_delete_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct athn_softc *sc = ic->ic_softc;
	uintptr_t entry;

	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
	case IEEE80211_CIPHER_WEP104:
	case IEEE80211_CIPHER_CCMP:
		entry = (uintptr_t)k->k_priv;
		athn_reset_key(sc, entry);
		break;
	case IEEE80211_CIPHER_TKIP:
		entry = (uintptr_t)k->k_priv;
		athn_reset_key(sc, entry);
		athn_reset_key(sc, entry + 64);
		break;
	default:
		/* Fallback to software crypto for other ciphers. */
		ieee80211_delete_key(ic, ni, k);
	}
}

void
athn_led_init(struct athn_softc *sc)
{
	struct athn_ops *ops = &sc->ops;

	ops->gpio_config_output(sc, sc->led_pin, AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
	/* LED off, active low. */
	athn_set_led(sc, 0);
}

void
athn_set_led(struct athn_softc *sc, int on)
{
	struct athn_ops *ops = &sc->ops;

	sc->led_state = on;
	ops->gpio_write(sc, sc->led_pin, !sc->led_state);
}

#ifdef ATHN_BT_COEXISTENCE
void
athn_btcoex_init(struct athn_softc *sc)
{
	struct athn_ops *ops = &sc->ops;
	uint32_t reg;

	if (sc->flags & ATHN_FLAG_BTCOEX2WIRE) {
		/* Connect bt_active to baseband. */
		AR_CLRBITS(sc, sc->gpio_input_en_off,
		    AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_DEF |
		    AR_GPIO_INPUT_EN_VAL_BT_FREQUENCY_DEF);
		AR_SETBITS(sc, sc->gpio_input_en_off,
		    AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB);

		reg = AR_READ(sc, AR_GPIO_INPUT_MUX1);
		reg = RW(reg, AR_GPIO_INPUT_MUX1_BT_ACTIVE,
		    AR_GPIO_BTACTIVE_PIN);
		AR_WRITE(sc, AR_GPIO_INPUT_MUX1, reg);
		AR_WRITE_BARRIER(sc);

		ops->gpio_config_input(sc, AR_GPIO_BTACTIVE_PIN);
	} else {	/* 3-wire. */
		AR_SETBITS(sc, sc->gpio_input_en_off,
		    AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB |
		    AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB);

		reg = AR_READ(sc, AR_GPIO_INPUT_MUX1);
		reg = RW(reg, AR_GPIO_INPUT_MUX1_BT_ACTIVE,
		    AR_GPIO_BTACTIVE_PIN);
		reg = RW(reg, AR_GPIO_INPUT_MUX1_BT_PRIORITY,
		    AR_GPIO_BTPRIORITY_PIN);
		AR_WRITE(sc, AR_GPIO_INPUT_MUX1, reg);
		AR_WRITE_BARRIER(sc);

		ops->gpio_config_input(sc, AR_GPIO_BTACTIVE_PIN);
		ops->gpio_config_input(sc, AR_GPIO_BTPRIORITY_PIN);
	}
}

void
athn_btcoex_enable(struct athn_softc *sc)
{
	struct athn_ops *ops = &sc->ops;
	uint32_t reg;

	if (sc->flags & ATHN_FLAG_BTCOEX3WIRE) {
		AR_WRITE(sc, AR_BT_COEX_MODE,
		    SM(AR_BT_MODE, AR_BT_MODE_SLOTTED) |
		    SM(AR_BT_PRIORITY_TIME, 2) |
		    SM(AR_BT_FIRST_SLOT_TIME, 5) |
		    SM(AR_BT_QCU_THRESH, ATHN_QID_AC_BE) |
		    AR_BT_TXSTATE_EXTEND | AR_BT_TX_FRAME_EXTEND |
		    AR_BT_QUIET | AR_BT_RX_CLEAR_POLARITY);
		AR_WRITE(sc, AR_BT_COEX_WEIGHT,
		    SM(AR_BTCOEX_BT_WGHT, AR_STOMP_LOW_BT_WGHT) |
		    SM(AR_BTCOEX_WL_WGHT, AR_STOMP_LOW_WL_WGHT));
		AR_WRITE(sc, AR_BT_COEX_MODE2,
		    SM(AR_BT_BCN_MISS_THRESH, 50) |
		    AR_BT_HOLD_RX_CLEAR | AR_BT_DISABLE_BT_ANT);

		AR_SETBITS(sc, AR_QUIET1, AR_QUIET1_QUIET_ACK_CTS_ENABLE);
		AR_CLRBITS(sc, AR_PCU_MISC, AR_PCU_BT_ANT_PREVENT_RX);
		AR_WRITE_BARRIER(sc);

		ops->gpio_config_output(sc, AR_GPIO_WLANACTIVE_PIN,
		    AR_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL);

	} else {	/* 2-wire. */
		ops->gpio_config_output(sc, AR_GPIO_WLANACTIVE_PIN,
		    AR_GPIO_OUTPUT_MUX_AS_TX_FRAME);
	}
	reg = AR_READ(sc, AR_GPIO_PDPU);
	reg &= ~(0x3 << (AR_GPIO_WLANACTIVE_PIN * 2));
	reg |= 0x2 << (AR_GPIO_WLANACTIVE_PIN * 2);
	AR_WRITE(sc, AR_GPIO_PDPU, reg);
	AR_WRITE_BARRIER(sc);

	/* Disable PCIe Active State Power Management (ASPM). */
	if (sc->sc_disable_aspm != NULL)
		sc->sc_disable_aspm(sc);

	/* XXX Start periodic timer. */
}

void
athn_btcoex_disable(struct athn_softc *sc)
{
	struct athn_ops *ops = &sc->ops;

	ops->gpio_write(sc, AR_GPIO_WLANACTIVE_PIN, 0);

	ops->gpio_config_output(sc, AR_GPIO_WLANACTIVE_PIN,
	    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);

	if (sc->flags & ATHN_FLAG_BTCOEX3WIRE) {
		AR_WRITE(sc, AR_BT_COEX_MODE,
		    SM(AR_BT_MODE, AR_BT_MODE_DISABLED) | AR_BT_QUIET);
		AR_WRITE(sc, AR_BT_COEX_WEIGHT, 0);
		AR_WRITE(sc, AR_BT_COEX_MODE2, 0);
		/* XXX Stop periodic timer. */
	}
	AR_WRITE_BARRIER(sc);
	/* XXX Restore ASPM setting? */
}
#endif

void
athn_iter_calib(void *arg, struct ieee80211_node *ni)
{
	struct athn_softc *sc = arg;
	struct athn_node *an = (struct athn_node *)ni;

	if ((ni->ni_flags & IEEE80211_NODE_HT) == 0)
		ieee80211_amrr_choose(&sc->amrr, ni, &an->amn);
}

void
athn_calib_to(void *arg)
{
	extern int ticks;
	struct athn_softc *sc = arg;
	struct athn_ops *ops = &sc->ops;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	s = splnet();

	/* Do periodic (every 4 minutes) PA calibration. */
	if (AR_SREV_9285_11_OR_LATER(sc) &&
	    !AR_SREV_9380_10_OR_LATER(sc) &&
	    (ticks - (sc->pa_calib_ticks + 240 * hz)) >= 0) {
		sc->pa_calib_ticks = ticks;
		if (AR_SREV_9271(sc))
			ar9271_pa_calib(sc);
		else
			ar9285_pa_calib(sc);
	}

	/* Do periodic (every 30 seconds) temperature compensation. */
	if ((sc->flags & ATHN_FLAG_OLPC) &&
	    ticks >= sc->olpc_ticks + 30 * hz) {
		sc->olpc_ticks = ticks;
		ops->olpc_temp_compensation(sc);
	}

#ifdef notyet
	/* XXX ANI. */
	athn_ani_monitor(sc);

	ops->next_calib(sc);
#endif
	if (ic->ic_fixed_rate == -1) {
		if (ic->ic_opmode == IEEE80211_M_STA)
			athn_iter_calib(sc, ic->ic_bss);
		else
			ieee80211_iterate_nodes(ic, athn_iter_calib, sc);
	}
	timeout_add_msec(&sc->calib_to, 500);
	splx(s);
}

int
athn_init_calib(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	struct athn_ops *ops = &sc->ops;
	int error;

	if (AR_SREV_9380_10_OR_LATER(sc))
		error = ar9003_init_calib(sc);
	else if (AR_SREV_9285_10_OR_LATER(sc))
		error = ar9285_init_calib(sc, c, extc);
	else
		error = ar5416_init_calib(sc, c, extc);
	if (error != 0)
		return (error);

	if (!AR_SREV_9380_10_OR_LATER(sc)) {
		/* Do PA calibration. */
		if (AR_SREV_9285_11_OR_LATER(sc)) {
			extern int ticks;
			sc->pa_calib_ticks = ticks;
			if (AR_SREV_9271(sc))
				ar9271_pa_calib(sc);
			else
				ar9285_pa_calib(sc);
		}
		/* Do noisefloor calibration. */
		ops->noisefloor_calib(sc);
	}
	if (AR_SREV_9160_10_OR_LATER(sc)) {
		/* Support IQ calibration. */
		sc->sup_calib_mask = ATHN_CAL_IQ;
		if (AR_SREV_9380_10_OR_LATER(sc)) {
			/* Support temperature compensation calibration. */
			sc->sup_calib_mask |= ATHN_CAL_TEMP;
		} else if (IEEE80211_IS_CHAN_5GHZ(c) || extc != NULL) {
			/*
			 * ADC gain calibration causes uplink throughput
			 * drops in HT40 mode on AR9287.
			 */
			if (!AR_SREV_9287(sc)) {
				/* Support ADC gain calibration. */
				sc->sup_calib_mask |= ATHN_CAL_ADC_GAIN;
			}
			/* Support ADC DC offset calibration. */
			sc->sup_calib_mask |= ATHN_CAL_ADC_DC;
		}
	}
	return (0);
}

/*
 * Adaptive noise immunity.
 */
int32_t
athn_ani_get_rssi(struct athn_softc *sc)
{
	return (0);	/* XXX */
}

void
athn_ani_ofdm_err_trigger(struct athn_softc *sc)
{
	struct athn_ani *ani = &sc->ani;
	struct athn_ops *ops = &sc->ops;
	int32_t rssi;

	/* First, raise noise immunity level, up to max. */
	if (ani->noise_immunity_level < 4) {
		ani->noise_immunity_level++;
		ops->set_noise_immunity_level(sc, ani->noise_immunity_level);
		return;
	}

	/* Then, raise our spur immunity level, up to max. */
	if (ani->spur_immunity_level < 7) {
		ani->spur_immunity_level++;
		ops->set_spur_immunity_level(sc, ani->spur_immunity_level);
		return;
	}

#ifndef IEEE80211_STA_ONLY
	if (sc->sc_ic.ic_opmode == IEEE80211_M_HOSTAP) {
		if (ani->firstep_level < 2) {
			ani->firstep_level++;
			ops->set_firstep_level(sc, ani->firstep_level);
		}
		return;
	}
#endif
	rssi = athn_ani_get_rssi(sc);
	if (rssi > ATHN_ANI_RSSI_THR_HIGH) {
		/*
		 * Beacon RSSI is high, turn off OFDM weak signal detection
		 * or raise first step level as last resort.
		 */
		if (ani->ofdm_weak_signal) {
			ani->ofdm_weak_signal = 0;
			ops->disable_ofdm_weak_signal(sc);
			ani->spur_immunity_level = 0;
			ops->set_spur_immunity_level(sc, 0);
		} else if (ani->firstep_level < 2) {
			ani->firstep_level++;
			ops->set_firstep_level(sc, ani->firstep_level);
		}
	} else if (rssi > ATHN_ANI_RSSI_THR_LOW) {
		/*
		 * Beacon RSSI is in mid range, we need OFDM weak signal
		 * detection but we can raise first step level.
		 */
		if (!ani->ofdm_weak_signal) {
			ani->ofdm_weak_signal = 1;
			ops->enable_ofdm_weak_signal(sc);
		}
		if (ani->firstep_level < 2) {
			ani->firstep_level++;
			ops->set_firstep_level(sc, ani->firstep_level);
		}
	} else if (IEEE80211_IS_CHAN_2GHZ(sc->sc_ic.ic_bss->ni_chan)) {
		/*
		 * Beacon RSSI is low, if in b/g mode, turn off OFDM weak
		 * signal detection and zero first step level to maximize
		 * CCK sensitivity.
		 */
		if (ani->ofdm_weak_signal) {
			ani->ofdm_weak_signal = 0;
			ops->disable_ofdm_weak_signal(sc);
		}
		if (ani->firstep_level > 0) {
			ani->firstep_level = 0;
			ops->set_firstep_level(sc, 0);
		}
	}
}

void
athn_ani_cck_err_trigger(struct athn_softc *sc)
{
	struct athn_ani *ani = &sc->ani;
	struct athn_ops *ops = &sc->ops;
	int32_t rssi;

	/* Raise noise immunity level, up to max. */
	if (ani->noise_immunity_level < 4) {
		ani->noise_immunity_level++;
		ops->set_noise_immunity_level(sc, ani->noise_immunity_level);
		return;
	}

#ifndef IEEE80211_STA_ONLY
	if (sc->sc_ic.ic_opmode == IEEE80211_M_HOSTAP) {
		if (ani->firstep_level < 2) {
			ani->firstep_level++;
			ops->set_firstep_level(sc, ani->firstep_level);
		}
		return;
	}
#endif
	rssi = athn_ani_get_rssi(sc);
	if (rssi > ATHN_ANI_RSSI_THR_LOW) {
		/*
		 * Beacon RSSI is in mid or high range, raise first step
		 * level.
		 */
		if (ani->firstep_level < 2) {
			ani->firstep_level++;
			ops->set_firstep_level(sc, ani->firstep_level);
		}
	} else if (IEEE80211_IS_CHAN_2GHZ(sc->sc_ic.ic_bss->ni_chan)) {
		/*
		 * Beacon RSSI is low, zero first step level to maximize
		 * CCK sensitivity.
		 */
		if (ani->firstep_level > 0) {
			ani->firstep_level = 0;
			ops->set_firstep_level(sc, 0);
		}
	}
}

void
athn_ani_lower_immunity(struct athn_softc *sc)
{
	struct athn_ani *ani = &sc->ani;
	struct athn_ops *ops = &sc->ops;
	int32_t rssi;

#ifndef IEEE80211_STA_ONLY
	if (sc->sc_ic.ic_opmode == IEEE80211_M_HOSTAP) {
		if (ani->firstep_level > 0) {
			ani->firstep_level--;
			ops->set_firstep_level(sc, ani->firstep_level);
		}
		return;
	}
#endif
	rssi = athn_ani_get_rssi(sc);
	if (rssi > ATHN_ANI_RSSI_THR_HIGH) {
		/*
		 * Beacon RSSI is high, leave OFDM weak signal detection
		 * off or it may oscillate.
		 */
	} else if (rssi > ATHN_ANI_RSSI_THR_LOW) {
		/*
		 * Beacon RSSI is in mid range, turn on OFDM weak signal
		 * detection or lower first step level.
		 */
		if (!ani->ofdm_weak_signal) {
			ani->ofdm_weak_signal = 1;
			ops->enable_ofdm_weak_signal(sc);
			return;
		}
		if (ani->firstep_level > 0) {
			ani->firstep_level--;
			ops->set_firstep_level(sc, ani->firstep_level);
			return;
		}
	} else {
		/* Beacon RSSI is low, lower first step level. */
		if (ani->firstep_level > 0) {
			ani->firstep_level--;
			ops->set_firstep_level(sc, ani->firstep_level);
			return;
		}
	}
	/*
	 * Lower spur immunity level down to zero, or if all else fails,
	 * lower noise immunity level down to zero.
	 */
	if (ani->spur_immunity_level > 0) {
		ani->spur_immunity_level--;
		ops->set_spur_immunity_level(sc, ani->spur_immunity_level);
	} else if (ani->noise_immunity_level > 0) {
		ani->noise_immunity_level--;
		ops->set_noise_immunity_level(sc, ani->noise_immunity_level);
	}
}

void
athn_ani_restart(struct athn_softc *sc)
{
	struct athn_ani *ani = &sc->ani;

	AR_WRITE(sc, AR_PHY_ERR_1, 0);
	AR_WRITE(sc, AR_PHY_ERR_2, 0);
	AR_WRITE(sc, AR_PHY_ERR_MASK_1, AR_PHY_ERR_OFDM_TIMING);
	AR_WRITE(sc, AR_PHY_ERR_MASK_2, AR_PHY_ERR_CCK_TIMING);
	AR_WRITE_BARRIER(sc);

	ani->listen_time = 0;
	ani->ofdm_phy_err_count = 0;
	ani->cck_phy_err_count = 0;
}

void
athn_ani_monitor(struct athn_softc *sc)
{
	struct athn_ani *ani = &sc->ani;
	uint32_t cyccnt, txfcnt, rxfcnt, phy1, phy2;
	int32_t cycdelta, txfdelta, rxfdelta;
	int32_t listen_time;

	txfcnt = AR_READ(sc, AR_TFCNT);	/* Tx frame count. */
	rxfcnt = AR_READ(sc, AR_RFCNT);	/* Rx frame count. */
	cyccnt = AR_READ(sc, AR_CCCNT);	/* Cycle count. */

	if (ani->cyccnt != 0 && ani->cyccnt <= cyccnt) {
		cycdelta = cyccnt - ani->cyccnt;
		txfdelta = txfcnt - ani->txfcnt;
		rxfdelta = rxfcnt - ani->rxfcnt;

		listen_time = (cycdelta - txfdelta - rxfdelta) /
		    (athn_clock_rate(sc) * 1000);
	} else
		listen_time = 0;

	ani->cyccnt = cyccnt;
	ani->txfcnt = txfcnt;
	ani->rxfcnt = rxfcnt;

	if (listen_time < 0) {
		athn_ani_restart(sc);
		return;
	}
	ani->listen_time += listen_time;

	phy1 = AR_READ(sc, AR_PHY_ERR_1);
	phy2 = AR_READ(sc, AR_PHY_ERR_2);

	if (phy1 < ani->ofdm_phy_err_base) {
		AR_WRITE(sc, AR_PHY_ERR_1, ani->ofdm_phy_err_base);
		AR_WRITE(sc, AR_PHY_ERR_MASK_1, AR_PHY_ERR_OFDM_TIMING);
	}
	if (phy2 < ani->cck_phy_err_base) {
		AR_WRITE(sc, AR_PHY_ERR_2, ani->cck_phy_err_base);
		AR_WRITE(sc, AR_PHY_ERR_MASK_2, AR_PHY_ERR_CCK_TIMING);
	}
	if (phy1 < ani->ofdm_phy_err_base || phy2 < ani->cck_phy_err_base) {
		AR_WRITE_BARRIER(sc);
		return;
	}
	ani->ofdm_phy_err_count = phy1 - ani->ofdm_phy_err_base;
	ani->cck_phy_err_count = phy2 - ani->cck_phy_err_base;

	if (ani->listen_time > 5 * ATHN_ANI_PERIOD) {
		/* Check to see if we need to lower immunity. */
		if (ani->ofdm_phy_err_count <=
		    ani->listen_time * ani->ofdm_trig_low / 1000 &&
		    ani->cck_phy_err_count <=
		    ani->listen_time * ani->cck_trig_low / 1000)
			athn_ani_lower_immunity(sc);
		athn_ani_restart(sc);

	} else if (ani->listen_time > ATHN_ANI_PERIOD) {
		/* Check to see if we need to raise immunity. */
		if (ani->ofdm_phy_err_count >
		    ani->listen_time * ani->ofdm_trig_high / 1000) {
			athn_ani_ofdm_err_trigger(sc);
			athn_ani_restart(sc);
		} else if (ani->cck_phy_err_count >
		    ani->listen_time * ani->cck_trig_high / 1000) {
			athn_ani_cck_err_trigger(sc);
			athn_ani_restart(sc);
		}
	}
}

uint8_t
athn_chan2fbin(struct ieee80211_channel *c)
{
	if (IEEE80211_IS_CHAN_2GHZ(c))
		return (c->ic_freq - 2300);
	else
		return ((c->ic_freq - 4800) / 5);
}

int
athn_interpolate(int x, int x1, int y1, int x2, int y2)
{
	if (x1 == x2)	/* Prevents division by zero. */
		return (y1);
	/* Linear interpolation. */
	return (y1 + ((x - x1) * (y2 - y1)) / (x2 - x1));
}

void
athn_get_pier_ival(uint8_t fbin, const uint8_t *pierfreq, int npiers,
    int *lo, int *hi)
{
	int i;

	for (i = 0; i < npiers; i++)
		if (pierfreq[i] == AR_BCHAN_UNUSED ||
		    pierfreq[i] > fbin)
			break;
	*hi = i;
	*lo = *hi - 1;
	if (*lo == -1)
		*lo = *hi;
	else if (*hi == npiers || pierfreq[*hi] == AR_BCHAN_UNUSED)
		*hi = *lo;
}

void
athn_init_dma(struct athn_softc *sc)
{
	uint32_t reg;

	if (!AR_SREV_9380_10_OR_LATER(sc)) {
		/* Set AHB not to do cacheline prefetches. */
		AR_SETBITS(sc, AR_AHB_MODE, AR_AHB_PREFETCH_RD_EN);
	}
	reg = AR_READ(sc, AR_TXCFG);
	/* Let MAC DMA reads be in 128-byte chunks. */
	reg = RW(reg, AR_TXCFG_DMASZ, AR_DMASZ_128B);

	/* Set initial Tx trigger level. */
	if (AR_SREV_9285(sc) || AR_SREV_9271(sc))
		reg = RW(reg, AR_TXCFG_FTRIG, AR_TXCFG_FTRIG_256B);
	else if (!AR_SREV_9380_10_OR_LATER(sc))
		reg = RW(reg, AR_TXCFG_FTRIG, AR_TXCFG_FTRIG_512B);
	AR_WRITE(sc, AR_TXCFG, reg);

	/* Let MAC DMA writes be in 128-byte chunks. */
	reg = AR_READ(sc, AR_RXCFG);
	reg = RW(reg, AR_RXCFG_DMASZ, AR_DMASZ_128B);
	AR_WRITE(sc, AR_RXCFG, reg);

	/* Setup Rx FIFO threshold to hold off Tx activities. */
	AR_WRITE(sc, AR_RXFIFO_CFG, 512);

	/* Reduce the number of entries in PCU TXBUF to avoid wrap around. */
	if (AR_SREV_9285(sc)) {
		AR_WRITE(sc, AR_PCU_TXBUF_CTRL,
		    AR9285_PCU_TXBUF_CTRL_USABLE_SIZE);
	} else if (!AR_SREV_9271(sc)) {
		AR_WRITE(sc, AR_PCU_TXBUF_CTRL,
		    AR_PCU_TXBUF_CTRL_USABLE_SIZE);
	}
	AR_WRITE_BARRIER(sc);

	/* Reset Tx status ring. */
	if (AR_SREV_9380_10_OR_LATER(sc))
		ar9003_reset_txsring(sc);
}

void
athn_inc_tx_trigger_level(struct athn_softc *sc)
{
	uint32_t reg, ftrig;

	reg = AR_READ(sc, AR_TXCFG);
	ftrig = MS(reg, AR_TXCFG_FTRIG);
	/*
	 * NB: The AR9285 and all single-stream parts have an issue that
	 * limits the size of the PCU Tx FIFO to 2KB instead of 4KB.
	 */
	if (ftrig == ((AR_SREV_9285(sc) || AR_SREV_9271(sc)) ? 0x1f : 0x3f))
		return;		/* Already at max. */
	reg = RW(reg, AR_TXCFG_FTRIG, ftrig + 1);
	AR_WRITE(sc, AR_TXCFG, reg);
	AR_WRITE_BARRIER(sc);
}

int
athn_stop_rx_dma(struct athn_softc *sc)
{
	int ntries;

	AR_WRITE(sc, AR_CR, AR_CR_RXD);
	/* Wait for Rx enable bit to go low. */
	for (ntries = 0; ntries < 100; ntries++) {
		if (!(AR_READ(sc, AR_CR) & AR_CR_RXE))
			return (0);
		DELAY(100);
	}
	DPRINTF(("Rx DMA failed to stop\n"));
	return (ETIMEDOUT);
}

int
athn_rx_abort(struct athn_softc *sc)
{
	int ntries;

	AR_SETBITS(sc, AR_DIAG_SW, AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT);
	for (ntries = 0; ntries < 1000; ntries++) {
		if (MS(AR_READ(sc, AR_OBS_BUS_1), AR_OBS_BUS_1_RX_STATE) == 0)
			return (0);
		DELAY(10);
	}
	DPRINTF(("Rx failed to go idle in 10ms\n"));
	AR_CLRBITS(sc, AR_DIAG_SW, AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT);
	AR_WRITE_BARRIER(sc);
	return (ETIMEDOUT);
}

void
athn_tx_reclaim(struct athn_softc *sc, int qid)
{
	struct athn_txq *txq = &sc->txq[qid];
	struct athn_tx_buf *bf;

	/* Reclaim all buffers queued in the specified Tx queue. */
	/* NB: Tx DMA must be stopped. */
	while ((bf = SIMPLEQ_FIRST(&txq->head)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&txq->head, bf_list);

		bus_dmamap_sync(sc->sc_dmat, bf->bf_map, 0,
		    bf->bf_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, bf->bf_map);
		m_freem(bf->bf_m);
		bf->bf_m = NULL;
		bf->bf_ni = NULL;	/* Nodes already freed! */

		/* Link Tx buffer back to global free list. */
		SIMPLEQ_INSERT_TAIL(&sc->txbufs, bf, bf_list);
	}
}

int
athn_tx_pending(struct athn_softc *sc, int qid)
{
	return (MS(AR_READ(sc, AR_QSTS(qid)), AR_Q_STS_PEND_FR_CNT) != 0 ||
	    (AR_READ(sc, AR_Q_TXE) & (1 << qid)) != 0);
}

void
athn_stop_tx_dma(struct athn_softc *sc, int qid)
{
	uint32_t tsflo;
	int ntries, i;

	AR_WRITE(sc, AR_Q_TXD, 1 << qid);
	for (ntries = 0; ntries < 40; ntries++) {
		if (!athn_tx_pending(sc, qid))
			break;
		DELAY(100);
	}
	if (ntries == 40) {
		for (i = 0; i < 2; i++) {
			tsflo = AR_READ(sc, AR_TSF_L32) / 1024;
			AR_WRITE(sc, AR_QUIET2,
			    SM(AR_QUIET2_QUIET_DUR, 10));
			AR_WRITE(sc, AR_QUIET_PERIOD, 100);
			AR_WRITE(sc, AR_NEXT_QUIET_TIMER, tsflo);
			AR_SETBITS(sc, AR_TIMER_MODE, AR_QUIET_TIMER_EN);
			if (AR_READ(sc, AR_TSF_L32) / 1024 == tsflo)
				break;
		}
		AR_SETBITS(sc, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
		AR_WRITE_BARRIER(sc);
		DELAY(200);
		AR_CLRBITS(sc, AR_TIMER_MODE, AR_QUIET_TIMER_EN);
		AR_WRITE_BARRIER(sc);

		for (ntries = 0; ntries < 40; ntries++) {
			if (!athn_tx_pending(sc, qid))
				break;
			DELAY(100);
		}

		AR_CLRBITS(sc, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
	}
	AR_WRITE(sc, AR_Q_TXD, 0);
	AR_WRITE_BARRIER(sc);
}

int
athn_txtime(struct athn_softc *sc, int len, int ridx, u_int flags)
{
	struct ieee80211com *ic = &sc->sc_ic;
#define divround(a, b)	(((a) + (b) - 1) / (b))
	int txtime;

	if (athn_rates[ridx].hwrate & 0x80) { /* MCS */
	 	/* Assumes a 20MHz channel, HT-mixed frame format, no STBC. */
		txtime = 8 + 8 + 4 + 4 + 4 * 4 + 8 /* HT PLCP */
		    + 4 * ((8 * len + 16 + 6) / (athn_rates[ridx].rate * 2));
		if (IEEE80211_IS_CHAN_2GHZ(ic->ic_bss->ni_chan))
			txtime += 6; /* aSignalExtension */
	} else if (athn_rates[ridx].phy == IEEE80211_T_OFDM) {
		txtime = divround(8 + 4 * len + 3, athn_rates[ridx].rate);
		/* SIFS is 10us for 11g but Signal Extension adds 6us. */
		txtime = 16 + 4 + 4 * txtime + 16;
	} else {
		txtime = divround(16 * len, athn_rates[ridx].rate);
		if (ridx != ATHN_RIDX_CCK1 && (flags & IEEE80211_F_SHPREAMBLE))
			txtime +=  72 + 24;
		else
			txtime += 144 + 48;
		txtime += 10;	/* 10us SIFS. */
	}
	return (txtime);
#undef divround
}

void
athn_init_tx_queues(struct athn_softc *sc)
{
	int qid;

	for (qid = 0; qid < ATHN_QID_COUNT; qid++) {
		SIMPLEQ_INIT(&sc->txq[qid].head);
		sc->txq[qid].lastds = NULL;
		sc->txq[qid].wait = NULL;
		sc->txq[qid].queued = 0;

		AR_WRITE(sc, AR_DRETRY_LIMIT(qid),
		    SM(AR_D_RETRY_LIMIT_STA_SH, 32) |
		    SM(AR_D_RETRY_LIMIT_STA_LG, 32) |
		    SM(AR_D_RETRY_LIMIT_FR_SH, 10));
		AR_WRITE(sc, AR_QMISC(qid),
		    AR_Q_MISC_DCU_EARLY_TERM_REQ);
		AR_WRITE(sc, AR_DMISC(qid),
		    SM(AR_D_MISC_BKOFF_THRESH, 2) |
		    AR_D_MISC_CW_BKOFF_EN | AR_D_MISC_FRAG_WAIT_EN);
	}

	/* Init beacon queue. */
	AR_SETBITS(sc, AR_QMISC(ATHN_QID_BEACON),
	    AR_Q_MISC_FSP_DBA_GATED | AR_Q_MISC_BEACON_USE |
	    AR_Q_MISC_CBR_INCR_DIS1);
	AR_SETBITS(sc, AR_DMISC(ATHN_QID_BEACON),
	    SM(AR_D_MISC_ARB_LOCKOUT_CNTRL,
	       AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL) |
	    AR_D_MISC_BEACON_USE |
	    AR_D_MISC_POST_FR_BKOFF_DIS);
	AR_WRITE(sc, AR_DLCL_IFS(ATHN_QID_BEACON),
	    SM(AR_D_LCL_IFS_CWMIN, 0) |
	    SM(AR_D_LCL_IFS_CWMAX, 0) |
	    SM(AR_D_LCL_IFS_AIFS,  1));

	/* Init CAB (Content After Beacon) queue. */
	AR_SETBITS(sc, AR_QMISC(ATHN_QID_CAB),
	    AR_Q_MISC_FSP_DBA_GATED | AR_Q_MISC_CBR_INCR_DIS1 |
	    AR_Q_MISC_CBR_INCR_DIS0);
	AR_SETBITS(sc, AR_DMISC(ATHN_QID_CAB),
	    SM(AR_D_MISC_ARB_LOCKOUT_CNTRL,
	       AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL));

	/* Init PS-Poll queue. */
	AR_SETBITS(sc, AR_QMISC(ATHN_QID_PSPOLL),
	    AR_Q_MISC_CBR_INCR_DIS1);

	/* Init UAPSD queue. */
	AR_SETBITS(sc, AR_DMISC(ATHN_QID_UAPSD),
	    AR_D_MISC_POST_FR_BKOFF_DIS);

	if (AR_SREV_9380_10_OR_LATER(sc)) {
		/* Enable MAC descriptor CRC check. */
		AR_WRITE(sc, AR_Q_DESC_CRCCHK, AR_Q_DESC_CRCCHK_EN);
	}
	/* Enable DESC interrupts for all Tx queues. */
	AR_WRITE(sc, AR_IMR_S0, 0x00ff0000);
	/* Enable EOL interrupts for all Tx queues except UAPSD. */
	AR_WRITE(sc, AR_IMR_S1, 0x00df0000);
	AR_WRITE_BARRIER(sc);
}

void
athn_set_sta_timers(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tsfhi, tsflo, tsftu, reg;
	uint32_t intval, next_tbtt, next_dtim;
	int dtim_period, dtim_count, rem_dtim_count;

	tsfhi = AR_READ(sc, AR_TSF_U32);
	tsflo = AR_READ(sc, AR_TSF_L32);
	tsftu = AR_TSF_TO_TU(tsfhi, tsflo) + AR_FUDGE;

	/* Beacon interval in TU. */
	intval = ic->ic_bss->ni_intval;

	next_tbtt = roundup(tsftu, intval);
#ifdef notyet
	dtim_period = ic->ic_dtim_period;
	if (dtim_period <= 0)
#endif
		dtim_period = 1;	/* Assume all TIMs are DTIMs. */

#ifdef notyet
	dtim_count = ic->ic_dtim_count;
	if (dtim_count >= dtim_period)	/* Should not happen. */
#endif
		dtim_count = 0;	/* Assume last TIM was a DTIM. */

	/* Compute number of remaining TIMs until next DTIM. */
	rem_dtim_count = 0;	/* XXX */
	next_dtim = next_tbtt + rem_dtim_count * intval;

	AR_WRITE(sc, AR_NEXT_TBTT_TIMER, next_tbtt * IEEE80211_DUR_TU);
	AR_WRITE(sc, AR_BEACON_PERIOD, intval * IEEE80211_DUR_TU);
	AR_WRITE(sc, AR_DMA_BEACON_PERIOD, intval * IEEE80211_DUR_TU);

	/*
	 * Set the number of consecutive beacons to miss before raising
	 * a BMISS interrupt to 10.
	 */
	reg = AR_READ(sc, AR_RSSI_THR);
	reg = RW(reg, AR_RSSI_THR_BM_THR, 10);
	AR_WRITE(sc, AR_RSSI_THR, reg);

	AR_WRITE(sc, AR_NEXT_DTIM,
	    (next_dtim - AR_SLEEP_SLOP) * IEEE80211_DUR_TU);
	AR_WRITE(sc, AR_NEXT_TIM,
	    (next_tbtt - AR_SLEEP_SLOP) * IEEE80211_DUR_TU);

	/* CAB timeout is in 1/8 TU. */
	AR_WRITE(sc, AR_SLEEP1,
	    SM(AR_SLEEP1_CAB_TIMEOUT, AR_CAB_TIMEOUT_VAL * 8) |
	    AR_SLEEP1_ASSUME_DTIM);
	AR_WRITE(sc, AR_SLEEP2,
	    SM(AR_SLEEP2_BEACON_TIMEOUT, AR_MIN_BEACON_TIMEOUT_VAL));

	AR_WRITE(sc, AR_TIM_PERIOD, intval * IEEE80211_DUR_TU);
	AR_WRITE(sc, AR_DTIM_PERIOD, dtim_period * intval * IEEE80211_DUR_TU);

	AR_SETBITS(sc, AR_TIMER_MODE,
	    AR_TBTT_TIMER_EN | AR_TIM_TIMER_EN | AR_DTIM_TIMER_EN);

	/* Set TSF out-of-range threshold (fixed at 16k us). */
	AR_WRITE(sc, AR_TSFOOR_THRESHOLD, 0x4240);

	AR_WRITE_BARRIER(sc);
}

#ifndef IEEE80211_STA_ONLY
void
athn_set_hostap_timers(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t intval, next_tbtt;

	/* Beacon interval in TU. */
	intval = ic->ic_bss->ni_intval;
	next_tbtt = intval;

	AR_WRITE(sc, AR_NEXT_TBTT_TIMER, next_tbtt * IEEE80211_DUR_TU);
	AR_WRITE(sc, AR_NEXT_DMA_BEACON_ALERT,
	    (next_tbtt - AR_BEACON_DMA_DELAY) * IEEE80211_DUR_TU);
	AR_WRITE(sc, AR_NEXT_CFP,
	    (next_tbtt - AR_SWBA_DELAY) * IEEE80211_DUR_TU);

	AR_WRITE(sc, AR_BEACON_PERIOD, intval * IEEE80211_DUR_TU);
	AR_WRITE(sc, AR_DMA_BEACON_PERIOD, intval * IEEE80211_DUR_TU);
	AR_WRITE(sc, AR_SWBA_PERIOD, intval * IEEE80211_DUR_TU);
	AR_WRITE(sc, AR_NDP_PERIOD, intval * IEEE80211_DUR_TU);

	AR_WRITE(sc, AR_TIMER_MODE,
	    AR_TBTT_TIMER_EN | AR_DBA_TIMER_EN | AR_SWBA_TIMER_EN);

	AR_WRITE_BARRIER(sc);
}
#endif

void
athn_set_opmode(struct athn_softc *sc)
{
	uint32_t reg;

	switch (sc->sc_ic.ic_opmode) {
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_HOSTAP:
		reg = AR_READ(sc, AR_STA_ID1);
		reg &= ~AR_STA_ID1_ADHOC;
		reg |= AR_STA_ID1_STA_AP | AR_STA_ID1_KSRCH_MODE;
		AR_WRITE(sc, AR_STA_ID1, reg);

		AR_CLRBITS(sc, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);
		break;
	case IEEE80211_M_IBSS:
	case IEEE80211_M_AHDEMO:
		reg = AR_READ(sc, AR_STA_ID1);
		reg &= ~AR_STA_ID1_STA_AP;
		reg |= AR_STA_ID1_ADHOC | AR_STA_ID1_KSRCH_MODE;
		AR_WRITE(sc, AR_STA_ID1, reg);

		AR_SETBITS(sc, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);
		break;
#endif
	default:
		reg = AR_READ(sc, AR_STA_ID1);
		reg &= ~(AR_STA_ID1_ADHOC | AR_STA_ID1_STA_AP);
		reg |= AR_STA_ID1_KSRCH_MODE;
		AR_WRITE(sc, AR_STA_ID1, reg);
		break;
	}
	AR_WRITE_BARRIER(sc);
}

void
athn_set_bss(struct athn_softc *sc, struct ieee80211_node *ni)
{
	const uint8_t *bssid = ni->ni_bssid;

	AR_WRITE(sc, AR_BSS_ID0, LE_READ_4(&bssid[0]));
	AR_WRITE(sc, AR_BSS_ID1, LE_READ_2(&bssid[4]) |
	    SM(AR_BSS_ID1_AID, IEEE80211_AID(ni->ni_associd)));
	AR_WRITE_BARRIER(sc);
}

void
athn_enable_interrupts(struct athn_softc *sc)
{
	uint32_t mask2;

	athn_disable_interrupts(sc);	/* XXX */

	AR_WRITE(sc, AR_IMR, sc->imask);

	mask2 = AR_READ(sc, AR_IMR_S2);
	mask2 &= ~(AR_IMR_S2_TIM | AR_IMR_S2_DTIM | AR_IMR_S2_DTIMSYNC |
	    AR_IMR_S2_CABEND | AR_IMR_S2_CABTO | AR_IMR_S2_TSFOOR);
	mask2 |= AR_IMR_S2_GTT | AR_IMR_S2_CST;
	AR_WRITE(sc, AR_IMR_S2, mask2);

	AR_CLRBITS(sc, AR_IMR_S5, AR_IMR_S5_TIM_TIMER);

	AR_WRITE(sc, AR_IER, AR_IER_ENABLE);

	AR_WRITE(sc, AR_INTR_ASYNC_ENABLE, AR_INTR_MAC_IRQ);
	AR_WRITE(sc, AR_INTR_ASYNC_MASK, AR_INTR_MAC_IRQ);

	AR_WRITE(sc, AR_INTR_SYNC_ENABLE, sc->isync);
	AR_WRITE(sc, AR_INTR_SYNC_MASK, sc->isync);
	AR_WRITE_BARRIER(sc);
}

void
athn_disable_interrupts(struct athn_softc *sc)
{
	AR_WRITE(sc, AR_IER, 0);
	(void)AR_READ(sc, AR_IER);

	AR_WRITE(sc, AR_INTR_ASYNC_ENABLE, 0);
	(void)AR_READ(sc, AR_INTR_ASYNC_ENABLE);

	AR_WRITE(sc, AR_INTR_SYNC_ENABLE, 0);
	(void)AR_READ(sc, AR_INTR_SYNC_ENABLE);

	AR_WRITE(sc, AR_IMR, 0);

	AR_CLRBITS(sc, AR_IMR_S2, AR_IMR_S2_TIM | AR_IMR_S2_DTIM |
	    AR_IMR_S2_DTIMSYNC | AR_IMR_S2_CABEND | AR_IMR_S2_CABTO |
	    AR_IMR_S2_TSFOOR | AR_IMR_S2_GTT | AR_IMR_S2_CST);

	AR_CLRBITS(sc, AR_IMR_S5, AR_IMR_S5_TIM_TIMER);
	AR_WRITE_BARRIER(sc);
}

void
athn_init_qos(struct athn_softc *sc)
{
	/* Initialize QoS settings. */
	AR_WRITE(sc, AR_MIC_QOS_CONTROL, 0x100aa);
	AR_WRITE(sc, AR_MIC_QOS_SELECT, 0x3210);
	AR_WRITE(sc, AR_QOS_NO_ACK,
	    SM(AR_QOS_NO_ACK_TWO_BIT, 2) |
	    SM(AR_QOS_NO_ACK_BIT_OFF, 5) |
	    SM(AR_QOS_NO_ACK_BYTE_OFF, 0));
	AR_WRITE(sc, AR_TXOP_X, AR_TXOP_X_VAL);
	/* Initialize TXOP for all TIDs. */
	AR_WRITE(sc, AR_TXOP_0_3,   0xffffffff);
	AR_WRITE(sc, AR_TXOP_4_7,   0xffffffff);
	AR_WRITE(sc, AR_TXOP_8_11,  0xffffffff);
	AR_WRITE(sc, AR_TXOP_12_15, 0xffffffff);
	AR_WRITE_BARRIER(sc);
}

int
athn_hw_reset(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc, int init)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct athn_ops *ops = &sc->ops;
	uint32_t reg, def_ant, sta_id1, cfg_led, tsflo, tsfhi;
	int i, error;

	/* XXX not if already awake */
	if ((error = athn_set_power_awake(sc)) != 0) {
		printf("%s: could not wakeup chip\n", sc->sc_dev.dv_xname);
		return (error);
	}

	/* Preserve the antenna on a channel switch. */
	if ((def_ant = AR_READ(sc, AR_DEF_ANTENNA)) == 0)
		def_ant = 1;
	/* Preserve other registers. */
	sta_id1 = AR_READ(sc, AR_STA_ID1) & AR_STA_ID1_BASE_RATE_11B;
	cfg_led = AR_READ(sc, AR_CFG_LED) & (AR_CFG_LED_ASSOC_CTL_M |
	    AR_CFG_LED_MODE_SEL_M | AR_CFG_LED_BLINK_THRESH_SEL_M |
	    AR_CFG_LED_BLINK_SLOW);

	/* Mark PHY as inactive. */
	ops->disable_phy(sc);

	if (init && AR_SREV_9271(sc)) {
		AR_WRITE(sc, AR9271_RESET_POWER_DOWN_CONTROL,
		    AR9271_RADIO_RF_RST);
		DELAY(50);
	}
	if (AR_SREV_9280(sc) && (sc->flags & ATHN_FLAG_OLPC)) {
		/* Save TSF before it gets cleared. */
		tsfhi = AR_READ(sc, AR_TSF_U32);
		tsflo = AR_READ(sc, AR_TSF_L32);

		/* NB: RTC reset clears TSF. */
		error = athn_reset_power_on(sc);
	} else
		error = athn_reset(sc, 0);
	if (error != 0) {
		printf("%s: could not reset chip (error=%d)\n",
		    sc->sc_dev.dv_xname, error);
		return (error);
	}

	/* XXX not if already awake */
	if ((error = athn_set_power_awake(sc)) != 0) {
		printf("%s: could not wakeup chip\n", sc->sc_dev.dv_xname);
		return (error);
	}

	athn_init_pll(sc, c);
	ops->set_rf_mode(sc, c);

	if (sc->flags & ATHN_FLAG_RFSILENT) {
		/* Check that the radio is not disabled by hardware switch. */
		reg = ops->gpio_read(sc, sc->rfsilent_pin);
		if (sc->flags & ATHN_FLAG_RFSILENT_REVERSED)
			reg = !reg;
		if (!reg) {
			printf("%s: radio is disabled by hardware switch\n",
			    sc->sc_dev.dv_xname);
			return (EPERM);
		}
	}
	if (init && AR_SREV_9271(sc)) {
		AR_WRITE(sc, AR9271_RESET_POWER_DOWN_CONTROL,
		    AR9271_GATE_MAC_CTL);
		DELAY(50);
	}
	if (AR_SREV_9280(sc) && (sc->flags & ATHN_FLAG_OLPC)) {
		/* Restore TSF if it got cleared. */
		AR_WRITE(sc, AR_TSF_L32, tsflo);
		AR_WRITE(sc, AR_TSF_U32, tsfhi);
	}

	if (AR_SREV_9280_10_OR_LATER(sc))
		AR_SETBITS(sc, sc->gpio_input_en_off, AR_GPIO_JTAG_DISABLE);

	if (AR_SREV_9287_13_OR_LATER(sc) && !AR_SREV_9380_10_OR_LATER(sc))
		ar9287_1_3_enable_async_fifo(sc);

	/* Write init values to hardware. */
	ops->hw_init(sc, c, extc);

	/*
	 * Only >=AR9280 2.0 parts are capable of encrypting unicast
	 * management frames using CCMP.
	 */
	if (AR_SREV_9280_20_OR_LATER(sc)) {
		reg = AR_READ(sc, AR_AES_MUTE_MASK1);
		/* Do not mask the subtype field in management frames. */
		reg = RW(reg, AR_AES_MUTE_MASK1_FC0_MGMT, 0xff);
		reg = RW(reg, AR_AES_MUTE_MASK1_FC1_MGMT,
		    ~(IEEE80211_FC1_RETRY | IEEE80211_FC1_PWR_MGT |
		      IEEE80211_FC1_MORE_DATA));
		AR_WRITE(sc, AR_AES_MUTE_MASK1, reg);
	} else if (AR_SREV_9160_10_OR_LATER(sc)) {
		/* Disable hardware crypto for management frames. */
		AR_CLRBITS(sc, AR_PCU_MISC_MODE2,
		    AR_PCU_MISC_MODE2_MGMT_CRYPTO_ENABLE);
		AR_SETBITS(sc, AR_PCU_MISC_MODE2,
		    AR_PCU_MISC_MODE2_NO_CRYPTO_FOR_NON_DATA_PKT);
	}

	if (ic->ic_curmode != IEEE80211_MODE_11B)
		ops->set_delta_slope(sc, c, extc);

	ops->spur_mitigate(sc, c, extc);
	ops->init_from_rom(sc, c, extc);

	/* XXX */
	AR_WRITE(sc, AR_STA_ID0, LE_READ_4(&ic->ic_myaddr[0]));
	AR_WRITE(sc, AR_STA_ID1, LE_READ_2(&ic->ic_myaddr[4]) |
	    sta_id1 | AR_STA_ID1_RTS_USE_DEF | AR_STA_ID1_CRPT_MIC_ENABLE);

	athn_set_opmode(sc);

	AR_WRITE(sc, AR_BSSMSKL, 0xffffffff);
	AR_WRITE(sc, AR_BSSMSKU, 0xffff);

	/* Restore previous antenna. */
	AR_WRITE(sc, AR_DEF_ANTENNA, def_ant);

	AR_WRITE(sc, AR_BSS_ID0, 0);
	AR_WRITE(sc, AR_BSS_ID1, 0);

	AR_WRITE(sc, AR_ISR, 0xffffffff);

	AR_WRITE(sc, AR_RSSI_THR, SM(AR_RSSI_THR_BM_THR, 7));

	if ((error = ops->set_synth(sc, c, extc)) != 0) {
		printf("%s: could not set channel\n", sc->sc_dev.dv_xname);
		return (error);
	}
	sc->curchan = c;
	sc->curchanext = extc;

	for (i = 0; i < AR_NUM_DCU; i++)
		AR_WRITE(sc, AR_DQCUMASK(i), 1 << i);

	athn_init_tx_queues(sc);

	/* Initialize interrupt mask. */
	sc->imask =
	    AR_IMR_TXDESC | AR_IMR_TXEOL |
	    AR_IMR_RXERR | AR_IMR_RXEOL | AR_IMR_RXORN |
	    AR_IMR_RXMINTR | AR_IMR_RXINTM |
	    AR_IMR_GENTMR | AR_IMR_BCNMISC;
	if (AR_SREV_9380_10_OR_LATER(sc))
		sc->imask |= AR_IMR_RXERR | AR_IMR_HP_RXOK;
#ifndef IEEE80211_STA_ONLY
	if (0 && ic->ic_opmode == IEEE80211_M_HOSTAP)
		sc->imask |= AR_IMR_MIB;
#endif
	AR_WRITE(sc, AR_IMR, sc->imask);
	AR_SETBITS(sc, AR_IMR_S2, AR_IMR_S2_GTT);
	AR_WRITE(sc, AR_INTR_SYNC_CAUSE, 0xffffffff);
	sc->isync = AR_INTR_SYNC_DEFAULT;
	if (sc->flags & ATHN_FLAG_RFSILENT)
		sc->isync |= AR_INTR_SYNC_GPIO_PIN(sc->rfsilent_pin);
	AR_WRITE(sc, AR_INTR_SYNC_ENABLE, sc->isync);
	AR_WRITE(sc, AR_INTR_SYNC_MASK, 0);
	if (AR_SREV_9380_10_OR_LATER(sc)) {
		AR_WRITE(sc, AR_INTR_PRIO_ASYNC_ENABLE, 0);
		AR_WRITE(sc, AR_INTR_PRIO_ASYNC_MASK, 0);
		AR_WRITE(sc, AR_INTR_PRIO_SYNC_ENABLE, 0);
		AR_WRITE(sc, AR_INTR_PRIO_SYNC_MASK, 0);
	}

	athn_init_qos(sc);

	AR_SETBITS(sc, AR_PCU_MISC, AR_PCU_MIC_NEW_LOC_ENA);

	if (AR_SREV_9287_13_OR_LATER(sc) && !AR_SREV_9380_10_OR_LATER(sc))
		ar9287_1_3_setup_async_fifo(sc);

	/* Disable sequence number generation in hardware. */
	AR_SETBITS(sc, AR_STA_ID1, AR_STA_ID1_PRESERVE_SEQNUM);

	athn_init_dma(sc);

	/* Program observation bus to see MAC interrupts. */
	AR_WRITE(sc, sc->obs_off, 8);

	/* Setup Rx interrupt mitigation. */
	AR_WRITE(sc, AR_RIMT, SM(AR_RIMT_FIRST, 2000) | SM(AR_RIMT_LAST, 500));

	ops->init_baseband(sc);

	if ((error = athn_init_calib(sc, c, extc)) != 0) {
		printf("%s: could not initialize calibration\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	ops->set_rxchains(sc);

	AR_WRITE(sc, AR_CFG_LED, cfg_led | AR_CFG_SCLK_32KHZ);

	if (sc->flags & ATHN_FLAG_USB) {
		if (AR_SREV_9271(sc))
			AR_WRITE(sc, AR_CFG, AR_CFG_SWRB | AR_CFG_SWTB);
		else
			AR_WRITE(sc, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);
	}
#if BYTE_ORDER == BIG_ENDIAN
	else {
		/* Default is LE, turn on swapping for BE. */
		AR_WRITE(sc, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);
	}
#endif
	AR_WRITE_BARRIER(sc);

	return (0);
}

struct ieee80211_node *
athn_node_alloc(struct ieee80211com *ic)
{
	struct athn_node *an;

	an = malloc(sizeof(struct athn_node), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (an && (ic->ic_flags & IEEE80211_F_HTON))
		ieee80211_mira_node_init(&an->mn);
	return (struct ieee80211_node *)an;
}

void
athn_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct athn_softc *sc = ic->ic_softc;
	struct athn_node *an = (void *)ni;
	struct ieee80211_rateset *rs = &ni->ni_rates;
	uint8_t rate;
	int ridx, i, j;

	if ((ni->ni_flags & IEEE80211_NODE_HT) == 0)
		ieee80211_amrr_node_init(&sc->amrr, &an->amn);
	else if (ic->ic_opmode == IEEE80211_M_STA)
		ieee80211_mira_node_init(&an->mn);

	/* Start at lowest available bit-rate, AMRR will raise. */
	ni->ni_txrate = 0;

	for (i = 0; i < rs->rs_nrates; i++) {
		rate = rs->rs_rates[i] & IEEE80211_RATE_VAL;

		/* Map 802.11 rate to HW rate index. */
		for (ridx = 0; ridx <= ATHN_RIDX_MAX; ridx++)
			if (athn_rates[ridx].rate == rate)
				break;
		an->ridx[i] = ridx;
		DPRINTFN(2, ("rate %d index %d\n", rate, ridx));

		/* Compute fallback rate for retries. */
		an->fallback[i] = i;
		for (j = i - 1; j >= 0; j--) {
			if (athn_rates[an->ridx[j]].phy ==
			    athn_rates[an->ridx[i]].phy) {
				an->fallback[i] = j;
				break;
			}
		}
		DPRINTFN(2, ("%d fallbacks to %d\n", i, an->fallback[i]));
	}

	/* In 11n mode, start at lowest available bit-rate, MiRA will raise. */
	ni->ni_txmcs = 0;

	for (i = 0; i <= ATHN_MCS_MAX; i++) {
		/* Map MCS index to HW rate index. */
		ridx = ATHN_NUM_LEGACY_RATES + i;
		an->ridx[ridx] = ATHN_RIDX_MCS0 + i;

		DPRINTFN(2, ("mcs %d index %d ", i, ridx));
		/* Compute fallback rate for retries. */
		if (i == 0 || i == 8) {
		 	/* MCS 0 and 8 fall back to the lowest legacy rate. */
			if (IEEE80211_IS_CHAN_5GHZ(ni->ni_chan))
				an->fallback[ridx] = ATHN_RIDX_OFDM6;
			else
				an->fallback[ridx] = ATHN_RIDX_CCK1;
		} else {
			/* Other MCS fall back to next supported lower MCS. */
			an->fallback[ridx] = ATHN_NUM_LEGACY_RATES + i;
			for (j = i - 1; j >= 0; j--) {
				if (!isset(ni->ni_rxmcs, j))
					continue;
				an->fallback[ridx] = ATHN_NUM_LEGACY_RATES + j;
				break;
			}
		}
		DPRINTFN(2, (" fallback to %d\n", an->fallback[ridx]));
	}
}

#ifndef IEEE80211_STA_ONLY
void
athn_node_leave(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct athn_node *an = (void *)ni;
	if (ic->ic_flags & IEEE80211_F_HTON)
		ieee80211_mira_cancel_timeouts(&an->mn);
}
#endif

int
athn_media_change(struct ifnet *ifp)
{
	struct athn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t rate, ridx;
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return (error);

	if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate] & IEEE80211_RATE_VAL;
		/* Map 802.11 rate to HW rate index. */
		for (ridx = 0; ridx <= ATHN_RIDX_MAX; ridx++)
			if (athn_rates[ridx].rate == rate)
				break;
		sc->fixed_ridx = ridx;
	}
	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
	    (IFF_UP | IFF_RUNNING)) {
		athn_stop(ifp, 0);
		error = athn_init(ifp);
	}
	return (error);
}

void
athn_next_scan(void *arg)
{
	struct athn_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	s = splnet();
	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(&ic->ic_if);
	splx(s);
}

void
athn_iter_mira_delete(void *arg, struct ieee80211_node *ni)
{
	struct athn_node *an = (struct athn_node *)ni;
	ieee80211_mira_cancel_timeouts(&an->mn);
}

/* Delete pending timeouts managed by MiRA. */
void
athn_delete_mira_nodes(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	if (ic->ic_opmode == IEEE80211_M_STA) {
		struct athn_node *an = (struct athn_node *)ic->ic_bss;
		ieee80211_mira_cancel_timeouts(&an->mn);
	} else
		ieee80211_iterate_nodes(ic, athn_iter_mira_delete, sc);
}

int
athn_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ifnet *ifp = &ic->ic_if;
	struct athn_softc *sc = ifp->if_softc;
	uint32_t reg;
	int error;

	timeout_del(&sc->calib_to);

	if ((ic->ic_flags & IEEE80211_F_HTON) &&
	    ic->ic_state == IEEE80211_S_RUN && nstate != IEEE80211_S_RUN)
		athn_delete_mira_nodes(sc);

	switch (nstate) {
	case IEEE80211_S_INIT:
		athn_set_led(sc, 0);
		break;
	case IEEE80211_S_SCAN:
		/* Make the LED blink while scanning. */
		athn_set_led(sc, !sc->led_state);
		error = athn_switch_chan(sc, ic->ic_bss->ni_chan, NULL);
		if (error != 0)
			return (error);
		timeout_add_msec(&sc->scan_to, 200);
		break;
	case IEEE80211_S_AUTH:
		athn_set_led(sc, 0);
		error = athn_switch_chan(sc, ic->ic_bss->ni_chan, NULL);
		if (error != 0)
			return (error);
		break;
	case IEEE80211_S_ASSOC:
		break;
	case IEEE80211_S_RUN:
		athn_set_led(sc, 1);

		if (ic->ic_opmode == IEEE80211_M_MONITOR)
			break;

		/* Fake a join to initialize the Tx rate. */
		athn_newassoc(ic, ic->ic_bss, 1);

		athn_set_bss(sc, ic->ic_bss);
		athn_disable_interrupts(sc);
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
			athn_set_hostap_timers(sc);
			/* Enable software beacon alert interrupts. */
			sc->imask |= AR_IMR_SWBA;
		} else
#endif
		{
			athn_set_sta_timers(sc);
			/* Enable beacon miss interrupts. */
			sc->imask |= AR_IMR_BMISS;

			/* Stop receiving beacons from other BSS. */
			reg = AR_READ(sc, AR_RX_FILTER);
			reg = (reg & ~AR_RX_FILTER_BEACON) |
			    AR_RX_FILTER_MYBEACON;
			AR_WRITE(sc, AR_RX_FILTER, reg);
			AR_WRITE_BARRIER(sc);
		}
		athn_enable_interrupts(sc);

		if (sc->sup_calib_mask != 0) {
			memset(&sc->calib, 0, sizeof(sc->calib));
			sc->cur_calib_mask = sc->sup_calib_mask;
			/* ops->do_calib(sc); */
		}
		/* XXX Start ANI. */

		timeout_add_msec(&sc->calib_to, 500);
		break;
	}

	return (sc->sc_newstate(ic, nstate, arg));
}

void
athn_updateedca(struct ieee80211com *ic)
{
#define ATHN_EXP2(x)	((1 << (x)) - 1)	/* CWmin = 2^ECWmin - 1 */
	struct athn_softc *sc = ic->ic_softc;
	const struct ieee80211_edca_ac_params *ac;
	int aci, qid;

	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		ac = &ic->ic_edca_ac[aci];
		qid = athn_ac2qid[aci];

		AR_WRITE(sc, AR_DLCL_IFS(qid),
		    SM(AR_D_LCL_IFS_CWMIN, ATHN_EXP2(ac->ac_ecwmin)) |
		    SM(AR_D_LCL_IFS_CWMAX, ATHN_EXP2(ac->ac_ecwmax)) |
		    SM(AR_D_LCL_IFS_AIFS, ac->ac_aifsn));
		if (ac->ac_txoplimit != 0) {
			AR_WRITE(sc, AR_DCHNTIME(qid),
			    SM(AR_D_CHNTIME_DUR,
			       IEEE80211_TXOP_TO_US(ac->ac_txoplimit)) |
			    AR_D_CHNTIME_EN);
		} else
			AR_WRITE(sc, AR_DCHNTIME(qid), 0);
	}
	AR_WRITE_BARRIER(sc);
#undef ATHN_EXP2
}

int
athn_clock_rate(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int clockrate;	/* MHz. */

	if (ic->ic_bss->ni_chan != IEEE80211_CHAN_ANYC &&
	    IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
		if (sc->flags & ATHN_FLAG_FAST_PLL_CLOCK)
			clockrate = AR_CLOCK_RATE_FAST_5GHZ_OFDM;
		else
			clockrate = AR_CLOCK_RATE_5GHZ_OFDM;
	} else if (ic->ic_curmode == IEEE80211_MODE_11B) {
		clockrate = AR_CLOCK_RATE_CCK;
	} else
		clockrate = AR_CLOCK_RATE_2GHZ_OFDM;
	if (sc->curchanext != NULL)
		clockrate *= 2;

	return (clockrate);
}

void
athn_updateslot(struct ieee80211com *ic)
{
	struct athn_softc *sc = ic->ic_softc;
	int slot;

	slot = (ic->ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;
	AR_WRITE(sc, AR_D_GBL_IFS_SLOT, slot * athn_clock_rate(sc));
	AR_WRITE_BARRIER(sc);
}

void
athn_start(struct ifnet *ifp)
{
	struct athn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (SIMPLEQ_EMPTY(&sc->txbufs)) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		/* Send pending management frames first. */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}
		if (ic->ic_state != IEEE80211_S_RUN)
			break;

		m = mq_dequeue(&ic->ic_pwrsaveq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}
		if (ic->ic_state != IEEE80211_S_RUN)
			break;

		/* Encapsulate and send data frames. */
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		if ((m = ieee80211_encap(ifp, m, &ni)) == NULL)
			continue;
 sendit:
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		if (sc->ops.tx(sc, m, ni, 0) != 0) {
			ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
athn_watchdog(struct ifnet *ifp)
{
	struct athn_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			athn_stop(ifp, 1);
			(void)athn_init(ifp);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

void
athn_set_multi(struct athn_softc *sc)
{
	struct arpcom *ac = &sc->sc_ic.ic_ac;
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	const uint8_t *addr;
	uint32_t val, lo, hi;
	uint8_t bit;

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if ((ifp->if_flags & (IFF_ALLMULTI | IFF_PROMISC)) != 0) {
		lo = hi = 0xffffffff;
		goto done;
	}
	lo = hi = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		addr = enm->enm_addrlo;
		/* Calculate the XOR value of all eight 6-bit words. */
		val = addr[0] | addr[1] << 8 | addr[2] << 16;
		bit  = (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ val;
		val = addr[3] | addr[4] << 8 | addr[5] << 16;
		bit ^= (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ val;
		bit &= 0x3f;
		if (bit < 32)
			lo |= 1 << bit;
		else
			hi |= 1 << (bit - 32);
		ETHER_NEXT_MULTI(step, enm);
	}
 done:
	AR_WRITE(sc, AR_MCAST_FIL0, lo);
	AR_WRITE(sc, AR_MCAST_FIL1, hi);
	AR_WRITE_BARRIER(sc);
}

int
athn_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct athn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) &&
			    ((ifp->if_flags ^ sc->sc_if_flags) &
			     (IFF_ALLMULTI | IFF_PROMISC)) != 0) {
				athn_set_multi(sc);
			} else if (!(ifp->if_flags & IFF_RUNNING))
				error = athn_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				athn_stop(ifp, 1);
		}
		sc->sc_if_flags = ifp->if_flags;
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);
		if (error == ENETRESET) {
			athn_set_multi(sc);
			error = 0;
		}
		break;

	case SIOCS80211CHANNEL:
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING))
				athn_switch_chan(sc, ic->ic_ibss_chan, NULL);
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		error = 0;
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING)) {
			athn_stop(ifp, 0);
			error = athn_init(ifp);
		}
	}

	splx(s);
	return (error);
}

int
athn_init(struct ifnet *ifp)
{
	struct athn_softc *sc = ifp->if_softc;
	struct athn_ops *ops = &sc->ops;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *c, *extc;
	int i, error;

	c = ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	extc = NULL;

	/* In case a new MAC address has been configured. */
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));

	/* For CardBus, power on the socket. */
	if (sc->sc_enable != NULL) {
		if ((error = sc->sc_enable(sc)) != 0) {
			printf("%s: could not enable device\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
		if ((error = athn_reset_power_on(sc)) != 0) {
			printf("%s: could not power on device\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}
	if (!(sc->flags & ATHN_FLAG_PCIE))
		athn_config_nonpcie(sc);
	else
		athn_config_pcie(sc);

	/* Reset HW key cache entries. */
	for (i = 0; i < sc->kc_entries; i++)
		athn_reset_key(sc, i);

	ops->enable_antenna_diversity(sc);

#ifdef ATHN_BT_COEXISTENCE
	/* Configure bluetooth coexistence for combo chips. */
	if (sc->flags & ATHN_FLAG_BTCOEX)
		athn_btcoex_init(sc);
#endif

	/* Configure LED. */
	athn_led_init(sc);

	/* Configure hardware radio switch. */
	if (sc->flags & ATHN_FLAG_RFSILENT)
		ops->rfsilent_init(sc);

	if ((error = athn_hw_reset(sc, c, extc, 1)) != 0) {
		printf("%s: unable to reset hardware; reset status %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail;
	}

	/* Enable Rx. */
	athn_rx_start(sc);

	/* Enable interrupts. */
	athn_enable_interrupts(sc);

#ifdef ATHN_BT_COEXISTENCE
	/* Enable bluetooth coexistence for combo chips. */
	if (sc->flags & ATHN_FLAG_BTCOEX)
		athn_btcoex_enable(sc);
#endif

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

#ifdef notyet
	if (ic->ic_flags & IEEE80211_F_WEPON) {
		/* Configure WEP keys. */
		for (i = 0; i < IEEE80211_WEP_NKID; i++)
			athn_set_key(ic, NULL, &ic->ic_nw_keys[i]);
	}
#endif
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	return (0);
 fail:
	athn_stop(ifp, 1);
	return (error);
}

void
athn_stop(struct ifnet *ifp, int disable)
{
	struct athn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int qid;

	ifp->if_timer = sc->sc_tx_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_del(&sc->scan_to);
	/* In case we were scanning, release the scan "lock". */
	ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

#ifdef ATHN_BT_COEXISTENCE
	/* Disable bluetooth coexistence for combo chips. */
	if (sc->flags & ATHN_FLAG_BTCOEX)
		athn_btcoex_disable(sc);
#endif

	/* Disable interrupts. */
	athn_disable_interrupts(sc);
	/* Acknowledge interrupts (avoids interrupt storms). */
	AR_WRITE(sc, AR_INTR_SYNC_CAUSE, 0xffffffff);
	AR_WRITE(sc, AR_INTR_SYNC_MASK, 0);

	for (qid = 0; qid < ATHN_QID_COUNT; qid++)
		athn_stop_tx_dma(sc, qid);
	/* XXX call athn_hw_reset if Tx still pending? */
	for (qid = 0; qid < ATHN_QID_COUNT; qid++)
		athn_tx_reclaim(sc, qid);

	/* Stop Rx. */
	AR_SETBITS(sc, AR_DIAG_SW, AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT);
	AR_WRITE(sc, AR_MIBC, AR_MIBC_FMC);
	AR_WRITE(sc, AR_MIBC, AR_MIBC_CMC);
	AR_WRITE(sc, AR_FILT_OFDM, 0);
	AR_WRITE(sc, AR_FILT_CCK, 0);
	AR_WRITE_BARRIER(sc);
	athn_set_rxfilter(sc, 0);
	athn_stop_rx_dma(sc);

	athn_reset(sc, 0);
	athn_init_pll(sc, NULL);
	athn_set_power_awake(sc);
	athn_reset(sc, 1);
	athn_init_pll(sc, NULL);

	athn_set_power_sleep(sc);

	/* For CardBus, power down the socket. */
	if (disable && sc->sc_disable != NULL)
		sc->sc_disable(sc);
}

void
athn_suspend(struct athn_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (ifp->if_flags & IFF_RUNNING)
		athn_stop(ifp, 1);
}

void
athn_wakeup(struct athn_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (ifp->if_flags & IFF_UP)
		athn_init(ifp);
}
@


1.96
log
@Add missing malloc(9) return value check in athn_node_alloc().
ok millert@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.95 2017/01/12 18:06:57 stsp Exp $	*/
d2600 2
a2601 1
	if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
@


1.95
log
@Rename ieee80211_mira_node_destroy() to ieee80211_mira_cancel_timeouts().
No functional change.

The previous name was chosen at a time when I could not yet anticipate
what this function would really end up doing.
The new name should make this function's purpose more obvious, especially
where it appears at strategic places in driver code.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.94 2017/01/12 16:32:28 stsp Exp $	*/
d2340 1
a2340 1
	if (ic->ic_flags & IEEE80211_F_HTON)
@


1.94
log
@Finish initial 11n support for athn(4).

The heavy lifting was done by damien@@ years ago. I didn't even have
to figure out what the hardware expects, the code was already there.

This driver now supports MCS 0-15 in client and hostap mode.
No Tx aggregation and no 40 MHz channels yet.

tested by vgross@@, bmercer@@, tb@@, jmc@@, Vadim Vygonets, Peter Kay
ok bmercer@@ tb@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.93 2016/04/13 10:49:26 mpi Exp $	*/
d2420 1
a2420 1
		ieee80211_mira_node_destroy(&an->mn);
d2470 1
a2470 1
	ieee80211_mira_node_destroy(&an->mn);
d2481 1
a2481 1
		ieee80211_mira_node_destroy(&an->mn);
@


1.93
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.92 2016/01/05 18:41:15 stsp Exp $	*/
d56 1
d97 1
a97 1
void		athn_iter_func(void *, struct ieee80211_node *);
d126 1
d129 2
d296 4
a299 3
		ic->ic_htcaps =
		    IEEE80211_HTCAP_SMPS_DIS |
		    IEEE80211_HTCAP_CBW20_40 |
d302 3
d313 1
d358 3
d385 1
d390 2
d443 3
d454 3
d1230 1
a1230 1
athn_iter_func(void *arg, struct ieee80211_node *ni)
d1235 2
a1236 1
	ieee80211_amrr_choose(&sc->amrr, ni, &an->amn);
d1276 1
a1276 1
			athn_iter_func(sc, ic->ic_bss);
d1278 1
a1278 1
			ieee80211_iterate_nodes(ic, athn_iter_func, sc);
d1402 1
a1402 1
	} else if (sc->sc_ic.ic_curmode != IEEE80211_MODE_11A) {
d1452 1
a1452 1
	} else if (sc->sc_ic.ic_curmode != IEEE80211_MODE_11A) {
d1815 1
d1819 7
a1825 2
	/* XXX HT. */
	if (athn_rates[ridx].phy == IEEE80211_T_OFDM) {
d2337 6
a2342 1
	return (malloc(sizeof(struct athn_node), M_DEVBUF, M_NOWAIT | M_ZERO));
d2354 5
a2358 1
	ieee80211_amrr_node_init(&sc->amrr, &an->amn);
d2383 29
d2414 10
d2466 20
d2496 4
d2600 1
a2600 1
	if (ic->ic_curmode == IEEE80211_MODE_11A) {
@


1.92
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.91 2015/12/03 14:39:37 stsp Exp $	*/
a343 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.91
log
@ieee80211com's ic_sup_mcs array is smaller than it used to be because part of
it has been split out into new struct fields. The athn(4) driver was still
assuming the old size and wrote beyond the ic_sup_mcs array. Make the driver
write to the new ic_tx_mcs_set field instead.
found by daniel@@ with gcc 4.9
ok sthen@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.90 2015/11/25 03:09:58 dlg Exp $	*/
a287 1
#ifndef IEEE80211_NO_HT
a319 1
#endif
a451 1
#ifndef IEEE80211_NO_HT
a453 1
#endif
a2509 1
#ifndef IEEE80211_NO_HT
d2512 1
a2512 1
#endif
@


1.90
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.89 2015/11/24 13:33:17 mpi Exp $	*/
d315 1
a315 2
		/* Set the "Tx MCS Set Defined" bit. */
		ic->ic_sup_mcs[12] |= 0x01;
d317 2
a318 3
			/* Set "Tx Rx MCS Set Not Equal" bit. */
			ic->ic_sup_mcs[12] |= 0x02;
			ic->ic_sup_mcs[12] |= (ntxstreams - 1) << 2;
@


1.89
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.88 2015/11/04 12:11:59 dlg Exp $	*/
d2542 1
a2542 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d2547 1
a2547 1
			ifp->if_flags |= IFF_OACTIVE;
d2793 1
a2793 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2822 2
a2823 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.88
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.87 2015/10/25 12:48:46 mpi Exp $	*/
a49 1
#include <net/if_types.h>
@


1.87
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.86 2015/03/14 03:38:47 jsg Exp $	*/
d2552 1
a2552 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
d2560 1
a2560 1
		IF_DEQUEUE(&ic->ic_pwrsaveq, m);
@


1.86
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.85 2014/12/22 02:28:51 tedu Exp $	*/
a2659 1
	struct ifaddr *ifa;
a2666 1
		ifa = (struct ifaddr *)data;
a2667 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.85
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.84 2014/12/19 22:44:58 guenther Exp $	*/
a47 1
#include <net/if_arp.h>
@


1.84
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.83 2014/07/22 13:12:11 mpi Exp $	*/
a2670 1
#ifdef INET
a2672 1
#endif
@


1.83
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.82 2014/07/12 18:48:17 tedu Exp $	*/
d39 1
a41 1
#include <machine/endian.h>
@


1.82
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.81 2014/03/19 10:09:19 mpi Exp $	*/
a53 1
#include <netinet/in_systm.h>
a54 1
#include <netinet/ip.h>
@


1.81
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.80 2013/12/06 21:03:02 deraadt Exp $	*/
d396 1
a396 1
		free(sc->eep, M_DEVBUF);
@


1.80
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.79 2013/11/26 09:50:32 mpi Exp $	*/
d2557 1
a2557 1
			ni = (void *)m->m_pkthdr.rcvif;
d2565 1
a2565 1
			ni = (void *)m->m_pkthdr.rcvif;
@


1.79
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.78 2013/11/15 01:45:44 krw Exp $	*/
d2891 1
a2891 1
athn_resume(struct athn_softc *sc)
@


1.78
log
@Add missing parenthesis to make tick calculation work as intended. Should
fix excessive timeouts and 'Michael mic' errors.

Problem pointed out by vigdis via bugs@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.77 2013/11/11 03:08:20 dlg Exp $	*/
d2629 3
a2638 5
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {
			ifp->if_flags |= IFF_ALLMULTI;
			lo = hi = 0xffffffff;
			goto done;
		}
@


1.77
log
@replace things like "start + interval > ticks" with
"ticks - start > interval" because the latter copes with ticks wrapping.

pointed out by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.76 2013/08/07 01:06:28 bluhm Exp $	*/
d1242 1
a1242 1
	    (ticks - sc->pa_calib_ticks + 240 * hz) >= 0) {
@


1.76
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.75 2013/01/14 09:50:31 jsing Exp $	*/
d1242 1
a1242 1
	    ticks >= sc->pa_calib_ticks + 240 * hz) {
@


1.75
log
@Fix the sotfware.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.73 2012/08/25 12:14:31 kettenis Exp $	*/
a54 1
#include <netinet/in_var.h>
@


1.74
log
@Init values for the AR9485 were for version 1.0 of this chip, which according
to Atheros Linux developers was never sold. So update initvals to what Linux
is using for the 1.1 generation. Because the serdes values are written to
different registers on the AR9485 this involves tweaking the serdes init code
for all athn(4) chip families. This commit doesn't make AR9485 devices work
yet but is a step in the right direction.

Tested by krw, kettenis, and Andrew Ngo.  ok kettenis@@
@
text
@d2446 1
a2446 1
			/* Enable sotfware beacon alert interrupts. */
@


1.73
log
@Add support for power saving in Host AP mode.

ok stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.72 2012/06/10 21:23:36 kettenis Exp $	*/
d785 1
a785 2
		AR_WRITE(sc, AR_PCIE_SERDES, serdes->vals[i]);
	AR_WRITE(sc, AR_PCIE_SERDES2, 0);
d810 13
d832 2
a833 1
	0x000e1007
d838 1
@


1.72
log
@Allow a variable number of words for the Serializer/Deserializer programming.
Probably not enought to make the AR9380 chips to work, but at least the kernel
shouldn't crash anymore when we see one.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.71 2011/01/08 15:05:24 damien Exp $	*/
d285 2
a286 1
	    IEEE80211_C_HOSTAP |	/* Host Ap mode supported. */
d2543 8
@


1.71
log
@fix LEDs handling.
do not read back the LED GPIO pin since it is configured in output
only mode.
makes the link LED blink on the WiFiStation EXT when scanning (the
LEDs indicating the signal strength are not working yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.70 2011/01/08 10:42:18 damien Exp $	*/
d87 2
a88 1
void		athn_write_serdes(struct athn_softc *, const uint32_t [9]);
d778 1
a778 1
athn_write_serdes(struct athn_softc *sc, const uint32_t val[9])
d782 3
a784 3
	/* Write 288-bit value to Serializer/Deserializer. */
	for (i = 0; i < 288 / 32; i++)
		AR_WRITE(sc, AR_PCIE_SERDES, val[i]);
d807 20
d830 1
a830 1
	athn_write_serdes(sc, ar_nonpcie_serdes);
@


1.70
log
@the USB frontend has its own switch_chan() function, so no need to
do AR9271-specific stuff here.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.69 2011/01/06 07:27:15 damien Exp $	*/
d75 1
d880 2
a881 2
	/* AR9280 (but not AR9280+AR7010) needs a full reset. */
	if (AR_SREV_9280(sc) && !(sc->flags & ATHN_FLAG_USB))
d1065 10
a1074 1
	ops->gpio_write(sc, sc->led_pin, 1);
a2370 1
	struct athn_ops *ops = &sc->ops;
a2374 2
	if (nstate != IEEE80211_S_SCAN)
		ops->gpio_write(sc, sc->led_pin, 1);
d2378 1
d2382 1
a2382 2
		ops->gpio_write(sc, sc->led_pin,
		    !ops->gpio_read(sc, sc->led_pin));
d2389 1
d2397 1
a2397 1
		ops->gpio_write(sc, sc->led_pin, 0);
@


1.69
log
@"athn* at uhub? port ?"
this adds preliminary support for the Atheros AR9271 chipset and
probably the AR9280+AR7010 and AR9287+AR7010 too though those were
not tested.
scanning still takes a very long time (~1 sec per channel) but
otherwise, operation in STA mode seems stable.
will implement fast channel change soon.

committed over the Ubiquiti WifiStation EXT (AR9271) on i386 with WPA.
requires firmware (see man page for details)

ok deraadt@@ (who checked the .h files)
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.68 2010/12/31 21:44:38 damien Exp $	*/
a154 1
void		ar9271_load_ani(struct athn_softc *);
a894 2
	if (AR_SREV_9271(sc) && error == 0)
		ar9271_load_ani(sc);
@


1.68
log
@when stopping Rx, set the AR_DIAG_RX_ABORT bit too.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.67 2010/12/31 18:24:41 damien Exp $	*/
d24 1
d124 1
a124 1
		    struct ieee80211_channel *);
d195 4
a198 1
	else if (AR_SREV_9285(sc) || AR_SREV_9271(sc))
d200 1
d901 1
a901 1
		error = athn_hw_reset(sc, c, extc);
d1267 8
a1274 2
			/* Support ADC gain calibration. */
			sc->sup_calib_mask |= ATHN_CAL_ADC_GAIN;
d1648 1
a1648 1
	if (ftrig == (AR_SREV_9285(sc) ? 0x1f : 0x3f))
d2058 1
a2058 1
    struct ieee80211_channel *extc)
d2083 5
d2123 5
d2258 6
d2265 4
a2268 2
	/* Default is little-endian, turn on swapping for big-endian. */
	AR_WRITE(sc, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);
d2739 1
a2739 1
	if ((error = athn_hw_reset(sc, c, extc)) != 0) {
@


1.67
log
@move reading of the hardware revision earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.66 2010/12/31 17:17:14 damien Exp $	*/
d864 1
a864 1
	AR_SETBITS(sc, AR_DIAG_SW, AR_DIAG_RX_DIS);
d2784 1
a2784 1
	AR_SETBITS(sc, AR_DIAG_SW, AR_DIAG_RX_DIS);
@


1.66
log
@commit some bits that will be required by AR9271/AR7010
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.65 2010/12/31 14:52:47 damien Exp $	*/
d177 3
a607 1
	/* XXX on first call, we do not know the chip id yet. */
a630 4

	/* Read hardware revision. */
	athn_get_chipid(sc);

@


1.65
log
@move the printing of the MAC address to the same line than the MAC rev.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.64 2010/12/31 14:06:05 damien Exp $	*/
d154 1
d161 1
d191 1
a191 1
	else if (AR_SREV_9285(sc))
d195 1
a195 1
	else if (AR_SREV_9380(sc))
d207 10
a216 5
	error = sc->ops.dma_alloc(sc);
	if (error != 0) {
		printf("%s: could not allocate DMA resources\n",
		    sc->sc_dev.dv_xname);
		return (error);
a217 3
	/* Steal one Tx buffer for beacons. */
	sc->bcnbuf = SIMPLEQ_FIRST(&sc->txbufs);
	SIMPLEQ_REMOVE_HEAD(&sc->txbufs, bf_list);
d293 1
a293 1
		if (AR_SREV_9287_10_OR_LATER(sc))
d378 3
a380 5
	for (qid = 0; qid < ATHN_QID_COUNT; qid++)
		athn_tx_reclaim(sc, qid);

	/* Free Tx/Rx DMA resources. */
	sc->ops.dma_free(sc);
d382 3
d563 2
d569 2
d576 1
a576 1
 * Return RF chip name (not for single-chip solutions.)
d720 1
a720 1
	if (!AR_SREV_5416(sc))
d731 2
d761 6
d876 4
a879 2
	/* AR9280 always needs a full reset. */
/*	if (AR_SREV_9280(sc))*/
d893 2
d1199 4
a1202 1
		ar9285_pa_calib(sc);
d1249 4
a1252 1
			ar9285_pa_calib(sc);
d1599 1
a1599 1
	if (AR_SREV_9285(sc))
d1614 7
a1620 3
	AR_WRITE(sc, AR_PCU_TXBUF_CTRL, AR_SREV_9285(sc) ?
	    AR9285_PCU_TXBUF_CTRL_USABLE_SIZE :
	    AR_PCU_TXBUF_CTRL_USABLE_SIZE);
d2775 1
a2775 1
	/* Acknowledge interrupts (avoids interrupt storms.) */
@


1.64
log
@Make the athn(4) back-end more bus agnostic by moving read and write
operations to callbacks in the PCI and CardBus front-ends.
This will allow support of other buses like USB.
Assume the following memory model:
- writes are ordered but may be buffered and require explicit flush
- a read always flushes all buffered writes
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.63 2010/08/27 17:08:00 jsg Exp $	*/
d176 1
a176 1
		printf(": could not reset chip\n");
d181 1
a181 1
		printf(": could not wakeup chip\n");
d195 2
d198 1
a198 1
		printf(": could not attach chip\n");
a200 1
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));
d245 1
a245 1
		printf("%s: %s rev %d (%dT%dR), ROM rev %d\n",
d247 2
a248 1
		    sc->ntxchains, sc->nrxchains, sc->eep_rev);
d250 2
a251 1
		printf("%s: MAC %s rev %d, RF %s (%dT%dR), ROM rev %d\n",
d254 1
a254 1
		    sc->eep_rev);
@


1.63
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.62 2010/08/18 18:58:01 damien Exp $	*/
d485 1
d506 1
d600 1
d643 1
d657 1
d675 1
d692 1
d710 1
d747 1
d750 1
d762 1
d780 1
d924 2
d1004 1
d1062 1
d1076 1
d1106 1
d1119 1
d1145 1
d1439 1
d1489 2
a1490 1
	if (phy1 < ani->ofdm_phy_err_base || phy2 < ani->cck_phy_err_base)
d1492 1
a1492 1

d1587 1
d1609 1
d1641 1
d1699 1
d1702 1
d1713 1
d1799 1
d1866 2
d1894 2
d1931 1
d1942 1
d1969 1
d1991 1
d2010 1
d2209 2
d2358 1
d2400 1
d2434 1
d2548 1
d2757 1
@


1.62
log
@- in STA mode, when associated, stop receiving beacons from other BSS.
  tested by ray@@
- no periodic PA calibration for the Osprey (AR9380)
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.61 2010/08/12 16:51:30 damien Exp $	*/
a332 1
	ifp->if_init = athn_init;
@


1.61
log
@Enable periodic (every 4 minutes) power amplifier calibration
on AR9285 and AR9287.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.60 2010/08/12 16:32:31 damien Exp $	*/
d448 1
d458 1
a458 3
		rfilt |= AR_RX_FILTER_BEACON;
	} else
		rfilt |= AR_RX_FILTER_BEACON; /* XXX AR_RX_FILTER_MYBEACON */
d1153 2
a1154 1
	    sc->pa_calib_ticks + 240 * hz < ticks) {
d1161 1
a1161 1
	    sc->olpc_ticks + 30 * hz < ticks) {
d2265 1
d2313 6
@


1.60
log
@For chips in open-loop power control mode, periodically (every 30 secs)
compensate Tx gain for temperature changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.59 2010/08/11 07:27:36 ray Exp $	*/
d1152 8
a1161 1
		/* Compensate for temperature changes. */
d1200 3
a1202 1
		if (AR_SREV_9285_11_OR_LATER(sc))
d1204 1
a1204 1

@


1.59
log
@Typo in comment: auhtorized->authorized
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.58 2010/08/02 19:28:31 kettenis Exp $	*/
d1144 1
d1146 1
d1151 8
a1161 1
	/* XXX OLPC temperature compensation. */
d1163 1
a1163 1
	sc->ops.next_calib(sc);
@


1.58
log
@There is no reason to call the start function upon resume; the network stack
is perfectly capable to get things going again all by itself.

ok damien@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.57 2010/07/22 10:19:37 kettenis Exp $	*/
d325 1
a325 1
	/* Get the list of auhtorized/supported channels. */
@


1.57
log
@When suspending, only call athn_stop() when IFF_RUNNING is set.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.56 2010/07/21 14:01:58 kettenis Exp $	*/
d2719 1
a2719 1
	if (ifp->if_flags & IFF_UP) {
a2720 3
		if (ifp->if_flags & IFF_RUNNING)
			athn_start(ifp);
	}
@


1.56
log
@Add suspend/unsuspend logic.

ok damien@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.55 2010/07/15 20:37:38 damien Exp $	*/
d2710 2
a2711 1
	athn_stop(ifp, 1);
@


1.55
log
@According to Linux ath9k, the AR9280 1.0 was never sold.
Since this is the only chip revision that requires split TKIP MIC keys,
remove code that deal with that.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.54 2010/07/15 19:07:43 damien Exp $	*/
d2703 20
@


1.54
log
@Remove initialization values for chips that never made it into production:
- AR9280 1.0
- AR9285 1.0 and 1.1
- AR9287 1.0

Remove checks that are now useless since we know we will never see those
chips, and rename some functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.53 2010/06/21 19:56:42 damien Exp $	*/
d222 1
a222 1
	 * TKIP keys consume 2 or 4 entries in the cache.
d224 1
a224 5
	if (sc->flags & ATHN_FLAG_SPLIT_TKIP_MIC)
		ic->ic_max_nnodes = sc->kc_entries / 4;
	else
		ic->ic_max_nnodes = sc->kc_entries / 2;
	ic->ic_max_nnodes -= IEEE80211_WEP_NKID;
d962 10
a971 38
		if (sc->flags & ATHN_FLAG_SPLIT_TKIP_MIC) {
			/* Tx MIC is at entry + 64. */
			micentry = entry + 64;
			AR_WRITE(sc, AR_KEYTABLE_KEY0(micentry),
			    LE_READ_4(&txmic[0]));
			AR_WRITE(sc, AR_KEYTABLE_KEY1(micentry), 0);

			AR_WRITE(sc, AR_KEYTABLE_KEY2(micentry),
			    LE_READ_4(&txmic[4]));
			AR_WRITE(sc, AR_KEYTABLE_KEY3(micentry), 0);

			/* Rx MIC key is at entry + 64 + 32. */
			micentry = entry + 64 + 32;
			AR_WRITE(sc, AR_KEYTABLE_KEY0(micentry),
			    LE_READ_4(&rxmic[0]));
			AR_WRITE(sc, AR_KEYTABLE_KEY1(micentry), 0);

			AR_WRITE(sc, AR_KEYTABLE_KEY2(micentry),
			    LE_READ_4(&rxmic[4]));
			AR_WRITE(sc, AR_KEYTABLE_KEY3(micentry), 0);
		} else {
			/* Tx+Rx MIC key is at entry + 64. */
			micentry = entry + 64;
			AR_WRITE(sc, AR_KEYTABLE_KEY0(micentry),
			    LE_READ_4(&rxmic[0]));
			AR_WRITE(sc, AR_KEYTABLE_KEY1(micentry),
			    LE_READ_2(&txmic[2]));

			AR_WRITE(sc, AR_KEYTABLE_KEY2(micentry),
			    LE_READ_4(&rxmic[4]));
			AR_WRITE(sc, AR_KEYTABLE_KEY3(micentry),
			    LE_READ_2(&txmic[0]));

			AR_WRITE(sc, AR_KEYTABLE_KEY4(micentry),
			    LE_READ_4(&txmic[4]));
			AR_WRITE(sc, AR_KEYTABLE_TYPE(micentry),
			    AR_KEYTABLE_TYPE_CLR);
		}
a1012 2
		if (sc->flags & ATHN_FLAG_SPLIT_TKIP_MIC)
			athn_reset_key(sc, entry + 64 + 32);
d2122 1
a2122 2
	if (!(sc->flags & ATHN_FLAG_SPLIT_TKIP_MIC))
		AR_SETBITS(sc, AR_PCU_MISC, AR_PCU_MIC_NEW_LOC_ENA);
@


1.53
log
@use LE_READ_4/LE_READ_2 instead of hardcoding
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.52 2010/06/21 19:46:50 damien Exp $	*/
d156 1
a156 1
int		ar9285_1_2_init_calib(struct athn_softc *,
d1209 2
a1210 2
	else if (AR_SREV_9285_12_OR_LATER(sc))
		error = ar9285_1_2_init_calib(sc, c, extc);
@


1.52
log
@allow Tx flags to be passed to the tx() routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.51 2010/06/21 19:40:08 damien Exp $	*/
d1016 2
a1017 2
		lo = addr[0] | addr[1] << 8 | addr[2] << 16 | addr[3] << 24;
		hi = addr[4] | addr[5] << 8;
@


1.51
log
@use correct clock rate when computing the listen time for ANI
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.50 2010/06/12 16:30:45 jsg Exp $	*/
d2445 1
a2445 1
		if (sc->ops.tx(sc, m, ni) != 0) {
@


1.50
log
@Add missing arg to a printf call.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.49 2010/06/05 18:43:57 damien Exp $	*/
d132 1
d1458 3
a1460 1
		listen_time = (cycdelta - txfdelta - rxfdelta) / 44000;
d2373 2
a2374 2
void
athn_updateslot(struct ieee80211com *ic)
d2376 2
a2377 2
	struct athn_softc *sc = ic->ic_softc;
	uint32_t clks;
d2381 1
a2381 1
			clks = AR_CLOCK_RATE_FAST_5GHZ_OFDM;
d2383 1
a2383 1
			clks = AR_CLOCK_RATE_5GHZ_OFDM;
d2385 1
a2385 1
		clks = AR_CLOCK_RATE_CCK;
d2387 1
a2387 1
		clks = AR_CLOCK_RATE_2GHZ_OFDM;
d2390 1
a2390 1
		clks *= 2;
d2392 8
a2399 1
	clks *= (ic->ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;
d2401 2
a2402 1
	AR_WRITE(sc, AR_D_GBL_IFS_SLOT, clks);
@


1.49
log
@- fix athn_set_key() on big-endian machines (function is not used yet)
- change sign extension such that we do not rely on >> being an
  arithmetic shift on signed integers
- various changes to AR9003 code, fix Tx path, enable Tx IQ calibration
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.48 2010/06/03 18:02:50 damien Exp $	*/
d2027 1
a2027 1
		    sc->sc_dev.dv_xname);
@


1.48
log
@enable async fifo for >=AR9287 1.3 only.
from ath9k.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.47 2010/05/16 18:01:15 damien Exp $	*/
d924 2
a926 3
	uint16_t keybuf[8], micbuf[8];
	const uint8_t *addr;
	uintptr_t entry, micentry;
a945 3
	memset(keybuf, 0, sizeof(keybuf));
	memcpy(keybuf, k->k_key, MIN(k->k_len, 16));

d953 1
d955 10
a967 1
			memcpy(micbuf, &k->k_key[16], 8);
d969 3
a971 1
			    micbuf[0] | micbuf[1] << 16);
d973 2
a974 3
			    micbuf[2] | micbuf[3] << 16);
			AR_WRITE(sc, AR_KEYTABLE_TYPE(micentry),
			    AR_KEYTABLE_TYPE_CLR);
d976 1
a976 1
			/* Rx MIC is at entry + 64 + 32. */
a977 1
			memcpy(micbuf, &k->k_key[24], 8);
d979 3
a981 1
			    micbuf[0] | micbuf[1] << 16);
d983 2
a984 3
			    micbuf[2] | micbuf[3] << 16);
			AR_WRITE(sc, AR_KEYTABLE_TYPE(micentry),
			    AR_KEYTABLE_TYPE_CLR);
d986 1
a986 1
			/* Tx+Rx MIC is at entry + 64. */
a987 1
			memcpy(micbuf, &k->k_key[16], 16);
d989 1
a989 1
			    micbuf[0] | micbuf[1] << 16);
d991 2
a992 1
			    micbuf[5]);
d994 1
a994 1
			    micbuf[2] | micbuf[3] << 16);
d996 2
a997 1
			    micbuf[4]);
d999 1
a999 1
			    micbuf[6] | micbuf[7] << 16);
d1004 7
a1010 5
	AR_WRITE(sc, AR_KEYTABLE_KEY0(entry), keybuf[0] | keybuf[1] << 16);
	AR_WRITE(sc, AR_KEYTABLE_KEY1(entry), keybuf[2]);
	AR_WRITE(sc, AR_KEYTABLE_KEY2(entry), keybuf[3] | keybuf[4] << 16);
	AR_WRITE(sc, AR_KEYTABLE_KEY3(entry), keybuf[5]);
	AR_WRITE(sc, AR_KEYTABLE_KEY4(entry), keybuf[6] | keybuf[7] << 16);
a1012 4
	/* Clear keys from the stack. */
	memset(keybuf, 0, sizeof(keybuf));
	memset(micbuf, 0, sizeof(micbuf));

d1733 2
d1919 2
a1920 3
	AR_WRITE(sc, AR_BSS_ID0, bssid[0] | bssid[1] << 8 |
	    bssid[2] << 16 | bssid[3] << 24);
	AR_WRITE(sc, AR_BSS_ID1, bssid[4] | bssid[5] << 8 |
a2091 3
	AR_WRITE(sc, AR_STA_ID0,
	    ic->ic_myaddr[0] <<  0 | ic->ic_myaddr[1] <<  8 |
	    ic->ic_myaddr[2] << 16 | ic->ic_myaddr[3] << 24);
d2093 2
a2094 2
	AR_WRITE(sc, AR_STA_ID1,
	    ic->ic_myaddr[4] <<  0 | ic->ic_myaddr[5] <<  8 |
d2659 1
a2659 1
			(void)athn_set_key(ic, NULL, &ic->ic_nw_keys[i]);
@


1.47
log
@fix (again) TKIP MIC entries in set_key().
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.46 2010/05/16 17:46:38 damien Exp $	*/
d159 2
a160 2
void		ar9287_1_2_enable_async_fifo(struct athn_softc *);
void		ar9287_1_2_setup_async_fifo(struct athn_softc *);
d2053 2
a2054 2
	if (AR_SREV_9287_12_OR_LATER(sc) && !AR_SREV_9380_10_OR_LATER(sc))
		ar9287_1_2_enable_async_fifo(sc);
d2152 2
a2153 2
	if (AR_SREV_9287_12_OR_LATER(sc))
		ar9287_1_2_setup_async_fifo(sc);
@


1.46
log
@fix ic_max_nnodes computation.
no need to set KEY3&KEY4 entries in the split TKIP MIC case (these
entries are set to 0 already.)
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.45 2010/05/16 14:50:28 damien Exp $	*/
a963 2
			AR_WRITE(sc, AR_KEYTABLE_KEY1(micentry),
			    micbuf[2]);
d965 1
a965 1
			    micbuf[3] | micbuf[4] << 16);
a973 2
			AR_WRITE(sc, AR_KEYTABLE_KEY1(micentry),
			    micbuf[2]);
d975 1
a975 1
			    micbuf[3] | micbuf[4] << 16);
d985 1
a985 1
			    micbuf[2]);
d987 1
a987 1
			    micbuf[3] | micbuf[4] << 16);
d989 1
a989 1
			    micbuf[5]);
@


1.45
log
@no need to set the MAC address to 0 for TKIP MIC entries; the key
cache is already cleared at startup and entries >64 will never have
their MAC addresses set.  removes pairs of writes in set_key.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.44 2010/05/16 14:34:19 damien Exp $	*/
a222 1
	ic->ic_max_nnodes = sc->kc_entries - IEEE80211_WEP_NKID;
d224 1
a224 1
		ic->ic_max_nnodes /= 4;
d226 2
a227 1
		ic->ic_max_nnodes /= 2;
a967 2
			AR_WRITE(sc, AR_KEYTABLE_KEY3(micentry), 0);
			AR_WRITE(sc, AR_KEYTABLE_KEY4(micentry), 0);
a979 2
			AR_WRITE(sc, AR_KEYTABLE_KEY3(micentry), 0);
			AR_WRITE(sc, AR_KEYTABLE_KEY4(micentry), 0);
@


1.44
log
@cleanup hardware key cache management (not used yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.43 2010/05/16 09:42:04 damien Exp $	*/
a971 3
			/* MAC address is reserved for the MIC entry. */
			AR_WRITE(sc, AR_KEYTABLE_MAC0(micentry), 0);
			AR_WRITE(sc, AR_KEYTABLE_MAC1(micentry), 0);
a985 3
			/* MAC address is reserved for the MIC entry. */
			AR_WRITE(sc, AR_KEYTABLE_MAC0(micentry), 0);
			AR_WRITE(sc, AR_KEYTABLE_MAC1(micentry), 0);
a1001 3
			/* MAC address is reserved for the MIC entry. */
			AR_WRITE(sc, AR_KEYTABLE_MAC0(micentry), 0);
			AR_WRITE(sc, AR_KEYTABLE_MAC1(micentry), 0);
@


1.43
log
@cleanup calibration bits (not everything is enabled yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.42 2010/05/16 09:19:48 damien Exp $	*/
a217 1

d221 1
a221 1
	 * XXX TKIP MMIC
d223 7
a229 1
	ic->ic_max_nnodes = sc->kc_entries - IEEE80211_GROUP_NKID;
d397 1
a397 1
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);
d399 1
a399 1
	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
d403 1
a403 1
	sc->sc_txtap_len = sizeof sc->sc_txtapu;
d947 1
a947 1
	memset(keybuf, 0, sizeof keybuf);
d951 1
a951 1
		entry = IEEE80211_GROUP_NKID + IEEE80211_AID(ni->ni_associd);
d958 61
a1018 31
		micentry = entry + 64;

		/* XXX Split MIC. */
		AR_WRITE(sc, AR_KEYTABLE_KEY0(micentry),
		    micbuf[0] | micbuf[1] << 16);
		AR_WRITE(sc, AR_KEYTABLE_KEY1(micentry), micbuf[2]);

		AR_WRITE(sc, AR_KEYTABLE_KEY2(micentry),
		    micbuf[3] | micbuf[4] << 16);
		AR_WRITE(sc, AR_KEYTABLE_KEY3(micentry), micbuf[5]);

		AR_WRITE(sc, AR_KEYTABLE_KEY4(micentry),
		    micbuf[6] | micbuf[7] << 16);
		AR_WRITE(sc, AR_KEYTABLE_TYPE(micentry), AR_KEYTABLE_TYPE_CLR);

		/* MAC address registers are reserved for the MIC entry. */
		AR_WRITE(sc, AR_KEYTABLE_MAC0(micentry), 0);
		AR_WRITE(sc, AR_KEYTABLE_MAC1(micentry), 0);
	} else {
		AR_WRITE(sc, AR_KEYTABLE_KEY0(entry),
		    keybuf[0] | keybuf[1] << 16);
		AR_WRITE(sc, AR_KEYTABLE_KEY1(entry), keybuf[2]);

		AR_WRITE(sc, AR_KEYTABLE_KEY2(entry),
		    keybuf[3] | keybuf[4] << 16);
		AR_WRITE(sc, AR_KEYTABLE_KEY3(entry), keybuf[5]);

		AR_WRITE(sc, AR_KEYTABLE_KEY4(entry),
		    keybuf[6] | keybuf[7] << 16);
		AR_WRITE(sc, AR_KEYTABLE_TYPE(entry), type);
	}
d1021 2
a1022 2
	memset(keybuf, 0, sizeof keybuf);
	memset(micbuf, 0, sizeof micbuf);
d1047 4
a1051 1
	case IEEE80211_CIPHER_CCMP:
d1054 3
d2166 1
a2166 1
	if (!AR_SREV_9280_10(sc))
d2205 1
a2205 2
	return (malloc(sizeof (struct athn_node), M_DEVBUF,
	    M_NOWAIT | M_ZERO));
@


1.42
log
@initial Host AP bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.41 2010/05/16 09:02:13 damien Exp $	*/
d1185 20
a1204 17
	/* Do PA calibration. */
	if (AR_SREV_9285_11_OR_LATER(sc))
		ar9285_pa_calib(sc);

	/* Do noisefloor calibration. */
	ops->noisefloor_calib(sc);

	if (!AR_SREV_9160_10_OR_LATER(sc))
		return (0);

	/* Enable IQ calibration. */
	sc->calib_mask = ATHN_CAL_IQ;

	if (!AR_SREV_9380_10_OR_LATER(sc) &&
	    (IEEE80211_IS_CHAN_5GHZ(c) || extc != NULL)) {
		/* Enable ADC gain and ADC DC offset calibrations. */
		sc->calib_mask |= ATHN_CAL_ADC_GAIN | ATHN_CAL_ADC_DC;
a1205 2

	ops->do_calib(sc);
d2301 6
@


1.41
log
@>=AR9287 devices support short GI in 20MHz channels, so indicate this
capability in the HT Capabilities field of the HT IE (not used yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.40 2010/05/16 08:50:58 damien Exp $	*/
d115 2
a116 1
void		athn_set_beacon_timers(struct athn_softc *);
d198 1
d209 3
a211 2

	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));
d264 9
a272 6
	    IEEE80211_C_WEP |		/* WEP */
	    IEEE80211_C_RSN |		/* WPA/RSN */
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_PMGT;		/* power saving supported */
a1696 1
	uint32_t reg;
d1723 4
a1726 7
	if (AR_SREV_9380_10_OR_LATER(sc)) {
		/* CWmin and CWmax should be 0 for beacon queue. */
		reg = AR_READ(sc, AR_DLCL_IFS(ATHN_QID_BEACON));
		reg = RW(reg, AR_D_LCL_IFS_CWMIN, 0);
		reg = RW(reg, AR_D_LCL_IFS_CWMAX, 0);
		AR_WRITE(sc, AR_DLCL_IFS(ATHN_QID_BEACON), reg);
	}
d1755 1
a1755 1
athn_set_beacon_timers(struct athn_softc *sc)
a1757 1
	struct ieee80211_node *ni = ic->ic_bss;
d1767 1
a1767 1
	intval = ni->ni_intval;
d1820 27
d2287 12
a2298 3
		athn_set_beacon_timers(sc);
		/* Enable beacon miss interrupts. */
		sc->imask |= AR_IMR_BMISS;
@


1.40
log
@fix athn_updateslot for fast PLL clock and 40MHz CBW
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.39 2010/05/16 08:45:25 damien Exp $	*/
d278 2
@


1.39
log
@cleanup interrupts mask management.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.38 2010/05/11 19:34:20 damien Exp $	*/
d2303 6
a2308 1
	if (ic->ic_curmode == IEEE80211_MODE_11B)
d2310 1
a2310 3
	else if (ic->ic_curmode == IEEE80211_MODE_11A)
		clks = AR_CLOCK_RATE_5GHZ_OFDM;
	else
d2312 4
a2316 2

	/* XXX 40MHz. */
@


1.38
log
@enable fast PLL clock for 5GHz on AR9280 >=2.0 (unless EEPROM says the
opposite) and on AR9380 2.0.

tested on my AR9280 2.1 with a NETGEAR WNHDE111 AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.37 2010/05/10 17:44:21 damien Exp $	*/
d1865 1
a1865 1
	uint32_t mask, mask2;
d1869 1
a1869 7
	/* XXX cleanup, use sc->imask */
	mask = AR_IMR_TXDESC | AR_IMR_TXEOL | AR_IMR_RXERR | AR_IMR_RXEOL |
	    AR_IMR_RXORN | AR_IMR_GENTMR | AR_IMR_BCNMISC | AR_IMR_RXMINTR |
	    AR_IMR_RXINTM;
	if (AR_SREV_9380_10_OR_LATER(sc))
		mask |= AR_IMR_RXERR | AR_IMR_HP_RXOK;
	AR_WRITE(sc, AR_IMR, mask);
d2066 5
a2070 1
	sc->imask = AR_IMR_DEFAULT;
d2072 1
a2072 1
		sc->imask |= AR_IMR_HP_RXOK;
d2074 1
a2074 1
	if (ic->ic_opmode == IEEE80211_M_HOSTAP)
d2258 2
a2259 1
		/* XXX Enable BMISS interrupts. */
@


1.37
log
@athn(4) is going to support a new family of Atheros 802.11n
chips (AR9003), which differs from the currently supported
families (AR5008, AR9001 and AR9002).

The main differences (from a driver point of view) are:

* DMA:
Tx and Rx descriptors have changed.
A single Tx descriptor can now reference up to 4 scatter/gather
DMA segments.
There is now a DMA ring for reporting Tx status with separate
Tx status descriptors (this ring is used to report Tx status for
all the Tx FIFOs).
Rx status descriptors are now put at the beginning of Rx buffers
and do not need to be allocated separately from buffers.
There are two Rx FIFOs (low priority and high priority) instead
of one.

* ROM:
The AR9003 family uses OTP-ROM instead of EEPROM.
Reading the ROM is totally insane since vendors can provide only
the chunks of ROM that differ from a default image (and thus the
default image has to be stored in the driver).
This is referenced as "compressed ROM" in the Linux driver, though
there is no real compression involved, at least for the moment.

* PHY registers:
All PHY registers have changed.
Some registers offsets do not fit on 16 bits anymore, but
since they are 32-bit aligned, we can still make them fit on
16 bits to save .rodata space in initialization tables.

* MAC registers:
Some MAC registers offsets have changed (GPIO, interrupt masks)
which is quite annoying (though ~98% remain the same.)

* Initialization values:
Initialization values are now split in mac/soc/bb/radio blocks
and pre/core/post phases in the Linux driver.  I have chosen to
not go that road and merge these blocks in modal and non-modal
initialization values (similar to the other families).
The initialization order remains exactly the same as the Linux
driver though.

To manage these differences, I have split athn.c in two backends:
ar5008.c contains the bits that are specific to the AR5008,
AR9001 and AR9002 families (used by ar5416.c, ar9280.c,
ar9285.c and ar9287.c) and that were previously in athn.c.

ar9003.c contains the bits that are specific to the new
AR9003 family (used by ar9380.c only for now.)

I have introduced a thin hardware abstraction layer (actually
a set of pointers to functions) that is used in athn.c.
My intent is to keep this abstraction layer as thin as possible
and not to create another ugly pile of abstraction layers a la
MadWifi.

I think I've managed to keep things sane, probably at the expense
of duplicating some code in both ar5008.c and ar9003.c, but at
least we do not have to dig through layers and layers of virtual
descriptors to figure out what is mapped to the hardware.

Tested for non-regression on various AR5416 (sparc64+i386), AR9281
and AR9285 (i386 only) adapters.
AR9380 part is not tested (hardware is not available to the general
public yet).

Committed over my AR9285 2.0.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.33 2010/04/07 16:31:16 damien Exp $	*/
d708 5
a712 8
			if (AR_SREV_9280_20(sc)) {
		 		/* Workaround for AR9280 2.0/5GHz. */
				if ((c->ic_freq % 20) == 0 ||
				    (c->ic_freq % 10) == 0)
					pll = 0x2850;
				else
					pll = 0x142c;
			} else
d2107 1
a2107 1
	/* Program OBS bus to see MAC interrupts. */
d2110 1
a2110 1
	/* Setup interrupt mitigation. */
@


1.36
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.35 2010/04/10 19:07:24 damien Exp $	*/
d5 1
a5 1
 * Copyright (c) 2008-2009 Atheros Communications Inc.
a72 5
int		athn_tx_alloc(struct athn_softc *);
void		athn_tx_free(struct athn_softc *);
int		athn_rx_alloc(struct athn_softc *);
void		athn_rx_free(struct athn_softc *);
void		athn_rx_start(struct athn_softc *);
a76 1
void		athn_rfsilent_init(struct athn_softc *);
a77 4
int		athn_gpio_read(struct athn_softc *, int);
void		athn_gpio_write(struct athn_softc *, int, int);
void		athn_gpio_config_output(struct athn_softc *, int, int);
void		athn_gpio_config_input(struct athn_softc *, int);
a87 1
uint8_t		athn_get_rf_rev(struct athn_softc *);
a92 7
void		athn_set_delta_slope(struct athn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
void		athn_set_phy(struct athn_softc *, struct ieee80211_channel *,
		    struct ieee80211_channel *);
int		athn_read_rom_word(struct athn_softc *, uint32_t, uint16_t *);
int		athn_read_rom(struct athn_softc *);
void		athn_swap_rom(struct athn_softc *);
a99 1
void		athn_do_calib(struct athn_softc *);
d102 1
a102 2
void		athn_init_chains(struct athn_softc *);
uint8_t		athn_get_vpd(uint8_t, const uint8_t *, const uint8_t *, int);
d104 2
a105 1
void		athn_init_baseband(struct athn_softc *);
d107 1
d111 1
a113 6
void		athn_tx_reclaim(struct athn_softc *, int);
void		athn_rx_radiotap(struct athn_softc *, struct mbuf *,
		    struct ar_rx_desc *);
void		athn_rx_intr(struct athn_softc *);
int		athn_tx_process(struct athn_softc *, int);
void		athn_tx_intr(struct athn_softc *);
a114 2
int		athn_tx(struct athn_softc *, struct mbuf *,
		    struct ieee80211_node *);
a115 2
void		athn_set_rf_mode(struct athn_softc *,
		    struct ieee80211_channel *);
a119 2
void		athn_hw_init(struct athn_softc *, struct ieee80211_channel *,
		    struct ieee80211_channel *);
a138 11
void		athn_calib_iq(struct athn_softc *);
void		athn_calib_adc_gain(struct athn_softc *);
void		athn_calib_adc_dc_off(struct athn_softc *);
void		athn_read_noisefloor(struct athn_softc *, int16_t *,
		    int16_t *);
void		athn_get_noisefloor(struct athn_softc *,
		    struct ieee80211_channel *);
void		athn_write_noisefloor(struct athn_softc *, int16_t *,
		    int16_t *);
void		athn_bb_load_noisefloor(struct athn_softc *);
void		athn_noisefloor_calib(struct athn_softc *);
a139 6
void		athn_ani_set_noise_immunity_level(struct athn_softc *, int);
void		athn_ani_ena_ofdm_weak_signal(struct athn_softc *);
void		athn_ani_dis_ofdm_weak_signal(struct athn_softc *);
void		athn_ani_set_cck_weak_signal(struct athn_softc *, int);
void		athn_ani_set_firstep_level(struct athn_softc *, int);
void		athn_ani_set_spur_immunity_level(struct athn_softc *, int);
d146 16
a170 2
	struct ar_base_eep_header *base;
	uint8_t eep_ver, kc_entries_exp;
d178 5
d184 1
a184 1
		ar5416_attach(sc);
d186 1
a186 1
		ar9280_attach(sc);
d188 1
a188 1
		ar9285_attach(sc);
d190 5
a194 4
		ar9287_attach(sc);

	if ((error = athn_set_power_awake(sc)) != 0) {
		printf(": could not wakeup chip\n");
d198 2
a199 2
	/* Retrieve PHY Revision. */
	sc->phy_rev = AR_READ(sc, AR_PHY_CHIP_ID);
d201 4
a204 13
	if (!(sc->flags & ATHN_FLAG_PCIE))
		athn_config_nonpcie(sc);
	else
		athn_config_pcie(sc);

	/* Allow access to analog chips. */
	AR_WRITE(sc, AR_PHY(0), 0x00000007);
	/* Get RF revision. */
	sc->rf_rev = athn_get_rf_rev(sc);

	/* Read entire ROM content. */
	if ((error = athn_read_rom(sc)) != 0) {
		printf(": could not read ROM\n");
a206 13
	base = sc->eep;

	eep_ver = (base->version >> 12) & 0xf;
	sc->eep_rev = (base->version & 0xfff);
	if (eep_ver != AR_EEP_VER || sc->eep_rev == 0) {
		printf(": unsupported ROM version %d.%d\n",  eep_ver,
		    sc->eep_rev);
		return (EINVAL);
	}
	sc->ops.setup(sc);

	/* We can put the chip in sleep state now. */
	athn_set_power_sleep(sc);
a207 1
	IEEE80211_ADDR_COPY(ic->ic_myaddr, base->macAddr);
d210 2
a211 10
	/* Check if we have a hardware radio switch. */
	if (base->rfSilent & AR_EEP_RFSILENT_ENABLED) {
		sc->flags |= ATHN_FLAG_RFSILENT;
		/* Get GPIO pin used by hardware radio switch. */
		sc->rfsilent_pin = MS(base->rfSilent,
		    AR_EEP_RFSILENT_GPIO_SEL);
		/* Get polarity of hardware radio switch. */
		if (base->rfSilent & AR_EEP_RFSILENT_POLARITY)
			sc->flags |= ATHN_FLAG_RFSILENT_REVERSED;
		DPRINTF(("Found RF switch connected to GPIO pin %d\n",
d214 1
a215 5
	/* Get the number of HW key cache entries. */
	kc_entries_exp = MS(base->deviceCap, AR_EEP_DEVCAP_KC_ENTRIES);
	sc->kc_entries = (kc_entries_exp != 0) ?
	    1 << kc_entries_exp : AR_KEYTABLE_SIZE;
	DPRINTF(("%d key cache entries\n", sc->kc_entries));
a225 8
	sc->txchainmask = base->txMask;
	if (sc->mac_ver == AR_SREV_VERSION_5416_PCI &&
	    !(base->opCapFlags & AR_OPFLAGS_11A)) {
		/* NB: Linux has a bug here. */
		/* For single-band AR5416 PCI, use GPIO pin 0. */
		sc->rxchainmask = athn_gpio_read(sc, 0) ? 0x5 : 0x7;
	} else
		sc->rxchainmask = base->rxMask;
a237 13
	error = athn_tx_alloc(sc);
	if (error != 0) {
		printf("%s: could not allocate Tx DMA resources\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}
	error = athn_rx_alloc(sc);
	if (error != 0) {
		printf("%s: could not allocate Rx DMA resources\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

d269 3
a271 1
	if (base->opCapFlags & AR_OPFLAGS_11N) {
d278 22
d304 1
a304 1
	if (base->opCapFlags & AR_OPFLAGS_11G) {
d310 1
a310 1
	if (base->opCapFlags & AR_OPFLAGS_11A) {
a313 8
#ifndef IEEE80211_NO_HT
	if (base->opCapFlags & AR_OPFLAGS_11N) {
		/* Set supported HT rates. */
		ic->ic_sup_mcs[0] = 0xff;
		if (sc->nrxchains > 1)
			ic->ic_sup_mcs[1] = 0xff;
	}
#endif
a361 1
	/* Free Tx/Rx DMA resources. */
d364 4
a367 2
	athn_tx_free(sc);
	athn_rx_free(sc);
a398 1
	struct ar_base_eep_header *base = sc->eep;
d403 1
a403 2
	/* XXX Regulatory domain. */
	if (base->opCapFlags & AR_OPFLAGS_11G) {
d413 1
a413 1
	if (base->opCapFlags & AR_OPFLAGS_11A) {
a422 185
int
athn_tx_alloc(struct athn_softc *sc)
{
	struct athn_tx_buf *bf;
	bus_size_t size;
	int error, nsegs, i;

	/*
	 * Allocate a pool of Tx descriptors shared between all Tx queues.
	 */
	size = ATHN_NTXBUFS * ATHN_MAX_SCATTER * sizeof (struct ar_tx_desc);

	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &sc->map);
	if (error != 0)
		goto fail;

	error = bus_dmamem_alloc(sc->sc_dmat, size, 4, 0, &sc->seg, 1,
	    &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0)
		goto fail;

	error = bus_dmamem_map(sc->sc_dmat, &sc->seg, 1, size,
	    (caddr_t *)&sc->descs, BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (error != 0)
		goto fail;

	error = bus_dmamap_load_raw(sc->sc_dmat, sc->map, &sc->seg, 1, size,
	    BUS_DMA_NOWAIT);
	if (error != 0)
		goto fail;

	SIMPLEQ_INIT(&sc->txbufs);
	for (i = 0; i < ATHN_NTXBUFS; i++) {
		bf = &sc->txpool[i];

		error = bus_dmamap_create(sc->sc_dmat, ATHN_TXBUFSZ,
		    ATHN_MAX_SCATTER, ATHN_TXBUFSZ, 0, BUS_DMA_NOWAIT,
		    &bf->bf_map);
		if (error != 0) {
			printf("%s: could not create Tx buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		bf->bf_descs = &sc->descs[i * ATHN_MAX_SCATTER];
		bf->bf_daddr = sc->map->dm_segs[0].ds_addr +
		    i * ATHN_MAX_SCATTER * sizeof (struct ar_tx_desc);

		SIMPLEQ_INSERT_TAIL(&sc->txbufs, bf, bf_list);
	}
	return (0);
 fail:
	athn_tx_free(sc);
	return (error);
}

void
athn_tx_free(struct athn_softc *sc)
{
	struct athn_tx_buf *bf;
	int i;

	for (i = 0; i < ATHN_NTXBUFS; i++) {
		bf = &sc->txpool[i];

		if (bf->bf_map != NULL)
			bus_dmamap_destroy(sc->sc_dmat, bf->bf_map);
	}
	/* Free Tx descriptors. */
	if (sc->map != NULL) {
		if (sc->descs != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->descs,
			    ATHN_NTXBUFS * ATHN_MAX_SCATTER *
			    sizeof (struct ar_tx_desc));
			bus_dmamem_free(sc->sc_dmat, &sc->seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->map);
	}
}

int
athn_rx_alloc(struct athn_softc *sc)
{
	struct athn_rxq *rxq = &sc->rxq;
	struct athn_rx_buf *bf;
	struct ar_rx_desc *ds;
	bus_size_t size;
	int error, nsegs, i;

	size = ATHN_NRXBUFS * sizeof (struct ar_rx_desc);

	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &rxq->map);
	if (error != 0)
		goto fail;

	error = bus_dmamem_alloc(sc->sc_dmat, size, 0, 0, &rxq->seg, 1,
	    &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0)
		goto fail;

	error = bus_dmamem_map(sc->sc_dmat, &rxq->seg, 1, size,
	    (caddr_t *)&rxq->descs, BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (error != 0)
		goto fail;

	error = bus_dmamap_load_raw(sc->sc_dmat, rxq->map, &rxq->seg, 1,
	    size, BUS_DMA_NOWAIT);
	if (error != 0)
		goto fail;

	for (i = 0; i < ATHN_NRXBUFS; i++) {
		bf = &rxq->bf[i];
		ds = &rxq->descs[i];

		error = bus_dmamap_create(sc->sc_dmat, ATHN_RXBUFSZ, 1,
		    ATHN_RXBUFSZ, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &bf->bf_map);
		if (error != 0) {
			printf("%s: could not create Rx buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
		/*
		 * Assumes MCLGETI returns cache-line-size aligned buffers.
		 */
		bf->bf_m = MCLGETI(NULL, M_DONTWAIT, NULL, ATHN_RXBUFSZ);
		if (bf->bf_m == NULL) {
			printf("%s: could not allocate Rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOBUFS;
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, bf->bf_map,
		    mtod(bf->bf_m, void *), ATHN_RXBUFSZ, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_READ);
		if (error != 0) {
			printf("%s: could not DMA map Rx buffer\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		bus_dmamap_sync(sc->sc_dmat, bf->bf_map, 0,
		    bf->bf_map->dm_mapsize, BUS_DMASYNC_PREREAD);

		bf->bf_desc = ds;
		bf->bf_daddr = rxq->map->dm_segs[0].ds_addr +
		    i * sizeof (struct ar_rx_desc);
	}
	return (0);
 fail:
	athn_rx_free(sc);
	return (error);
}

void
athn_rx_free(struct athn_softc *sc)
{
	struct athn_rxq *rxq = &sc->rxq;
	struct athn_rx_buf *bf;
	int i;

	for (i = 0; i < ATHN_NRXBUFS; i++) {
		bf = &rxq->bf[i];

		if (bf->bf_map != NULL)
			bus_dmamap_destroy(sc->sc_dmat, bf->bf_map);
		if (bf->bf_m != NULL)
			m_freem(bf->bf_m);
	}
	/* Free Rx descriptors. */
	if (rxq->descs != NULL) {
		if (rxq->descs != NULL) {
			bus_dmamap_unload(sc->sc_dmat, rxq->map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)rxq->descs,
			    ATHN_NRXBUFS * sizeof (struct ar_rx_desc));
			bus_dmamem_free(sc->sc_dmat, &rxq->seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, rxq->map);
	}
}

a426 3
	struct athn_rxq *rxq = &sc->rxq;
	struct athn_rx_buf *bf;
	struct ar_rx_desc *ds;
a427 1
	int i;
d429 2
a430 22
	/* Setup and link Rx descriptors. */
	SIMPLEQ_INIT(&rxq->head);
	rxq->lastds = NULL;
	for (i = 0; i < ATHN_NRXBUFS; i++) {
		bf = &rxq->bf[i];
		ds = bf->bf_desc;

		memset(ds, 0, sizeof (*ds));
		ds->ds_data = bf->bf_map->dm_segs[0].ds_addr;
		ds->ds_ctl1 = SM(AR_RXC1_BUF_LEN, ATHN_RXBUFSZ);

		if (rxq->lastds != NULL)
			rxq->lastds->ds_link = bf->bf_daddr;
		SIMPLEQ_INSERT_TAIL(&rxq->head, bf, bf_list);
		rxq->lastds = ds;
	}
	bus_dmamap_sync(sc->sc_dmat, rxq->map, 0, rxq->map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

	/* Enable Rx. */
	AR_WRITE(sc, AR_RXDP, SIMPLEQ_FIRST(&rxq->head)->bf_daddr);
	AR_WRITE(sc, AR_CR, AR_CR_RXE);
a503 1
	uint32_t intr, intr2, intr5, sync;
d509 1
a509 132
	/* Get pending interrupts. */
	intr = AR_READ(sc, AR_INTR_ASYNC_CAUSE);
	if (!(intr & AR_INTR_MAC_IRQ) || intr == AR_INTR_SPURIOUS) {
		intr = AR_READ(sc, AR_INTR_SYNC_CAUSE);
		if (intr == AR_INTR_SPURIOUS || (intr & sc->isync) == 0)
			return (0);	/* Not for us. */
	}

	if ((AR_READ(sc, AR_INTR_ASYNC_CAUSE) & AR_INTR_MAC_IRQ) &&
	    (AR_READ(sc, AR_RTC_STATUS) & AR_RTC_STATUS_M) == AR_RTC_STATUS_ON)
		intr = AR_READ(sc, AR_ISR);
	else
		intr = 0;
	sync = AR_READ(sc, AR_INTR_SYNC_CAUSE) & sc->isync;
	if (intr == 0 && sync == 0)
		return (0);	/* Not for us. */

	if (intr != 0) {
		if (intr & AR_ISR_BCNMISC) {
			intr2 = AR_READ(sc, AR_ISR_S2);
			if (intr2 & AR_ISR_S2_TIM)
				/* TBD */;
			if (intr2 & AR_ISR_S2_TSFOOR)
				/* TBD */;
		}
		intr = AR_READ(sc, AR_ISR_RAC);
		if (intr == AR_INTR_SPURIOUS)
			return (1);

		if (intr & (AR_ISR_RXMINTR | AR_ISR_RXINTM))
			athn_rx_intr(sc);
		if (intr & (AR_ISR_RXOK | AR_ISR_RXERR | AR_ISR_RXORN))
			athn_rx_intr(sc);

		if (intr & (AR_ISR_TXOK | AR_ISR_TXDESC |
		    AR_ISR_TXERR | AR_ISR_TXEOL))
			athn_tx_intr(sc);

		if (intr & AR_ISR_GENTMR) {
			intr5 = AR_READ(sc, AR_ISR_S5_S);
			if (intr5 & AR_ISR_GENTMR) {
				DPRINTF(("GENTMR trigger=%d thresh=%d\n",
				    MS(intr5, AR_ISR_S5_GENTIMER_TRIG),
				    MS(intr5, AR_ISR_S5_GENTIMER_THRESH)));
			}
		}

		intr5 = AR_READ(sc, AR_ISR_S5_S);
		if (intr5 & AR_ISR_S5_TIM_TIMER)
			/* TBD */;
	}
	if (sync != 0) {
		if (sync & (AR_INTR_SYNC_HOST1_FATAL |
		    AR_INTR_SYNC_HOST1_PERR))
			/* TBD */;

		if (sync & AR_INTR_SYNC_RADM_CPL_TIMEOUT) {
			AR_WRITE(sc, AR_RC, AR_RC_HOSTIF);
			AR_WRITE(sc, AR_RC, 0);
		}

		if ((sc->flags & ATHN_FLAG_RFSILENT) &&
		    (sync & AR_INTR_SYNC_GPIO_PIN(sc->rfsilent_pin))) {
			printf("%s: radio switch turned off\n",
			    sc->sc_dev.dv_xname);
			/* Turn the interface down. */
			ifp->if_flags &= ~IFF_UP;
			athn_stop(ifp, 1);
			return (1);
		}

		AR_WRITE(sc, AR_INTR_SYNC_CAUSE, sync);
		(void)AR_READ(sc, AR_INTR_SYNC_CAUSE);
	}
	return (1);
}

/*
 * Access to General Purpose Input/Output ports.
 */
int
athn_gpio_read(struct athn_softc *sc, int pin)
{
	KASSERT(pin < sc->ngpiopins);
	return ((AR_READ(sc, AR_GPIO_IN_OUT) >> (sc->ngpiopins + pin)) & 1);
}

void
athn_gpio_write(struct athn_softc *sc, int pin, int set)
{
	uint32_t reg;

	KASSERT(pin < sc->ngpiopins);
	reg = AR_READ(sc, AR_GPIO_IN_OUT);
	if (set)
		reg |= 1 << pin;
	else
		reg &= ~(1 << pin);
	AR_WRITE(sc, AR_GPIO_IN_OUT, reg);
}

void
athn_gpio_config_input(struct athn_softc *sc, int pin)
{
	uint32_t reg;

	reg = AR_READ(sc, AR_GPIO_OE_OUT);
	reg &= ~(AR_GPIO_OE_OUT_DRV_M << (pin * 2));
	reg |= AR_GPIO_OE_OUT_DRV_NO << (pin * 2);
	AR_WRITE(sc, AR_GPIO_OE_OUT, reg);
}

void
athn_gpio_config_output(struct athn_softc *sc, int pin, int type)
{
	uint32_t reg;
	int mux, off;

	mux = pin / 6;
	off = pin % 6;

	reg = AR_READ(sc, AR_GPIO_OUTPUT_MUX(mux));
	if (!AR_SREV_9280_20_OR_LATER(sc) && mux == 0)
		reg = (reg & ~0x1f0) | (reg & 0x1f0) << 1;
	reg &= ~(0x1f << (off * 5));
	reg |= (type & 0x1f) << (off * 5);
	AR_WRITE(sc, AR_GPIO_OUTPUT_MUX(mux), reg);

	reg = AR_READ(sc, AR_GPIO_OE_OUT);
	reg &= ~(AR_GPIO_OE_OUT_DRV_M << (pin * 2));
	reg |= AR_GPIO_OE_OUT_DRV_ALL << (pin * 2);
	AR_WRITE(sc, AR_GPIO_OE_OUT, reg);
d547 2
d553 3
d559 2
d583 5
a587 3
	/* Make sure no DMA is active by doing an AHB reset. */
	AR_WRITE(sc, AR_RC, AR_RC_AHB);

d591 2
a592 1
	AR_WRITE(sc, AR_RC, 0);
d625 3
a627 2
		AR_WRITE(sc, AR_RC, AR_RC_AHB | AR_RC_HOSTIF);
	} else
d658 2
a659 1
		athn_init_pll(sc, NULL);
d685 1
d687 2
a688 1
	AR_WRITE(sc, AR_RC, AR_RC_AHB | AR_RC_HOSTIF);
d702 4
a705 1
	if (AR_SREV_9280_10_OR_LATER(sc)) {
a771 41
uint8_t
athn_reverse_bits(uint8_t v, int nbits)
{
	KASSERT(nbits <= 8);
	v = ((v >> 1) & 0x55) | ((v & 0x55) << 1);
	v = ((v >> 2) & 0x33) | ((v & 0x33) << 2);
	v = ((v >> 4) & 0x0f) | ((v & 0x0f) << 4);
	return (v >> (8 - nbits));
}

uint8_t
athn_get_rf_rev(struct athn_softc *sc)
{
	uint8_t rev, reg;
	int i;

	AR_WRITE(sc, AR_PHY(0x36), 0x00007058);
	for (i = 0; i < 8; i++)
		AR_WRITE(sc, AR_PHY(0x20), 0x00010000);
	reg = (AR_READ(sc, AR_PHY(256)) >> 24) & 0xff;
	reg = (reg & 0xf0) >> 4 | (reg & 0x0f) << 4;

	rev = athn_reverse_bits(reg, 8);
	if ((rev & AR_RADIO_SREV_MAJOR) == 0)
		rev = AR_RAD5133_SREV_MAJOR;
	return (rev);
}

static __inline uint32_t
athn_synth_delay(struct athn_softc *sc)
{
	uint32_t delay;

	delay = MS(AR_READ(sc, AR_PHY_RX_DELAY), AR_PHY_RX_DELAY_DELAY);
	if (sc->sc_ic.ic_curmode == IEEE80211_MODE_11B)
		delay = (delay * 4) / 22;
	else
		delay = delay / 10;	/* in 100ns steps */
	return (delay);
}

d777 1
a777 1
	int error, qid, ntries;
d785 2
a786 10
	AR_WRITE(sc, AR_PHY_RFBUS_REQ, AR_PHY_RFBUS_REQ_EN);
	for (ntries = 0; ntries < 10000; ntries++) {
		if (AR_READ(sc, AR_PHY_RFBUS_GRANT) & AR_PHY_RFBUS_GRANT_EN)
			break;
		DELAY(10);
	}
	if (ntries == 10000) {
		DPRINTF(("could not kill baseband Rx"));
		return (ETIMEDOUT);
	}
d788 1
a788 1
	athn_set_phy(sc, c, extc);
a799 3
	/* Wait for the synthesizer to settle. */
	DELAY(AR_BASE_PHY_ACTIVE_DELAY + athn_synth_delay(sc));

d801 1
a801 1
	AR_WRITE(sc, AR_PHY_RFBUS_REQ, 0);
d805 1
a805 1
		athn_set_delta_slope(sc, c, extc);
d840 1
a840 1
/*	if (AR_SREV_9280(sc)) */
d889 1
a889 2
athn_set_delta_slope(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
d891 7
a897 1
	uint32_t coeff, exp, man, reg;
d899 2
a900 4
	/* Set Delta Slope (exponent and mantissa). */
	coeff = (100 << 24) / c->ic_freq;
	athn_get_delta_slope(coeff, &exp, &man);
	DPRINTFN(5, ("delta slope coeff exp=%u man=%u\n", exp, man));
d902 2
a903 4
	reg = AR_READ(sc, AR_PHY_TIMING3);
	reg = RW(reg, AR_PHY_TIMING3_DSC_EXP, exp);
	reg = RW(reg, AR_PHY_TIMING3_DSC_MAN, man);
	AR_WRITE(sc, AR_PHY_TIMING3, reg);
d905 2
a906 9
	/* For Short GI, coeff is 9/10 that of normal coeff. */
	coeff = (9 * coeff) / 10;
	athn_get_delta_slope(coeff, &exp, &man);
	DPRINTFN(5, ("delta slope coeff exp=%u man=%u\n", exp, man));

	reg = AR_READ(sc, AR_PHY_HALFGI);
	reg = RW(reg, AR_PHY_HALFGI_DSC_EXP, exp);
	reg = RW(reg, AR_PHY_HALFGI_DSC_MAN, man);
	AR_WRITE(sc, AR_PHY_HALFGI, reg);
d909 3
a911 3
void
athn_set_phy(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
d913 5
a917 1
	uint32_t phy;
d919 16
a934 10
	if (AR_SREV_9285_10_OR_LATER(sc))
		phy = AR_READ(sc, AR_PHY_TURBO) & AR_PHY_FC_ENABLE_DAC_FIFO;
	else
		phy = 0;
	phy |= AR_PHY_FC_HT_EN | AR_PHY_FC_SHORT_GI_40 |
	    AR_PHY_FC_SINGLE_HT_LTF1 | AR_PHY_FC_WALSH;
	if (extc != NULL) {
		phy |= AR_PHY_FC_DYN2040_EN;
		if (extc > c)	/* XXX */
			phy |= AR_PHY_FC_DYN2040_PRI_CH;
a935 1
	AR_WRITE(sc, AR_PHY_TURBO, phy);
d937 2
a938 2
	AR_WRITE(sc, AR_2040_MODE,
	    (extc != NULL) ? AR_2040_JOINED_RX_CLEAR : 0);
d940 2
a941 148
	AR_WRITE(sc, AR_GTXTO, SM(AR_GTXTO_TIMEOUT_LIMIT, 25));
	AR_WRITE(sc, AR_CST, SM(AR_CST_TIMEOUT_LIMIT, 15));
}

int
athn_read_rom_word(struct athn_softc *sc, uint32_t addr, uint16_t *val)
{
	uint32_t reg;
	int ntries;

	/* Read 16-bit value from ROM. */
	reg = AR_READ(sc, AR_EEPROM_OFFSET(addr));
	for (ntries = 0; ntries < 1000; ntries++) {
		reg = AR_READ(sc, AR_EEPROM_STATUS_DATA);
		if (!(reg & (AR_EEPROM_STATUS_DATA_BUSY |
		    AR_EEPROM_STATUS_DATA_PROT_ACCESS))) {
			*val = MS(reg, AR_EEPROM_STATUS_DATA_VAL);
			return (0);
		}
		DELAY(10);
	}
	*val = 0xffff;
	return (ETIMEDOUT);
}

int
athn_read_rom(struct athn_softc *sc)
{
	uint32_t addr, end;
	uint16_t magic, sum, *eep;
	int need_swap = 0;
	int error;

	/* Determine ROM endianness. */
	error = athn_read_rom_word(sc, AR_EEPROM_MAGIC_OFFSET, &magic);
	if (error != 0)
		return (error);
	if (magic != AR_EEPROM_MAGIC) {
		if (magic != swap16(AR_EEPROM_MAGIC)) {
			DPRINTF(("invalid ROM magic 0x%x != 0x%x\n",
			    magic, AR_EEPROM_MAGIC));
			return (EIO);
		}
		DPRINTF(("non-native ROM endianness\n"));
		need_swap = 1;
	}

	/* Allocate space to store ROM in host memory. */
	sc->eep = malloc(sc->eep_size, M_DEVBUF, M_NOWAIT);
	if (sc->eep == NULL)
		return (ENOMEM);

	/* Read entire ROM and compute checksum. */
	sum = 0;
	eep = sc->eep;
	end = sc->eep_base + sc->eep_size / sizeof (uint16_t);
	for (addr = sc->eep_base; addr < end; addr++, eep++) {
		if ((error = athn_read_rom_word(sc, addr, eep)) != 0) {
			DPRINTF(("could not read ROM at 0x%x\n", addr));
			return (error);
		}
		if (need_swap)
			*eep = swap16(*eep);
		sum ^= *eep;
	}
	if (sum != 0xffff) {
		printf("%s: bad ROM checksum 0x%04x\n",
		    sc->sc_dev.dv_xname, sum);
		return (EIO);
	}
	if (need_swap)
		athn_swap_rom(sc);

	return (0);
}

void
athn_swap_rom(struct athn_softc *sc)
{
	struct ar_base_eep_header *base = sc->eep;

	/* Swap common fields first. */
	base->length = swap16(base->length);
	base->version = swap16(base->version);
	base->regDmn[0] = swap16(base->regDmn[0]);
	base->regDmn[1] = swap16(base->regDmn[1]);
	base->rfSilent = swap16(base->rfSilent);
	base->blueToothOptions = swap16(base->blueToothOptions);
	base->deviceCap = swap16(base->deviceCap);

	/* Swap device-dependent fields. */
	sc->ops.swap_rom(sc);
}

void
athn_reset_key(struct athn_softc *sc, int entry)
{
	/*
	 * NB: Key cache registers access special memory area that requires
	 * two 32-bit writes to actually update the values in the internal
	 * memory.  Consequently, writes must be grouped by pair.
	 */
	AR_WRITE(sc, AR_KEYTABLE_KEY0(entry), 0);
	AR_WRITE(sc, AR_KEYTABLE_KEY1(entry), 0);

	AR_WRITE(sc, AR_KEYTABLE_KEY2(entry), 0);
	AR_WRITE(sc, AR_KEYTABLE_KEY3(entry), 0);

	AR_WRITE(sc, AR_KEYTABLE_KEY4(entry), 0);
	AR_WRITE(sc, AR_KEYTABLE_TYPE(entry), AR_KEYTABLE_TYPE_CLR);

	AR_WRITE(sc, AR_KEYTABLE_MAC0(entry), 0);
	AR_WRITE(sc, AR_KEYTABLE_MAC1(entry), 0);
}

int
athn_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct athn_softc *sc = ic->ic_softc;
	uint32_t type, lo, hi;
	uint16_t keybuf[8], micbuf[8];
	const uint8_t *addr;
	uintptr_t entry, micentry;

	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
		type = AR_KEYTABLE_TYPE_40;
		break;
	case IEEE80211_CIPHER_WEP104:
		type = AR_KEYTABLE_TYPE_104;
		break;
	case IEEE80211_CIPHER_TKIP:
		type = AR_KEYTABLE_TYPE_TKIP;
		break;
	case IEEE80211_CIPHER_CCMP:
		type = AR_KEYTABLE_TYPE_CCM;
		break;
	default:
		/* Fallback to software crypto for other ciphers. */
		return (ieee80211_set_key(ic, ni, k));
	}

	memset(keybuf, 0, sizeof keybuf);
	memcpy(keybuf, k->k_key, MIN(k->k_len, 16));

	if (!(k->k_flags & IEEE80211_KEY_GROUP))
		entry = IEEE80211_GROUP_NKID + IEEE80211_AID(ni->ni_associd);
d1021 3
a1023 1
	athn_gpio_config_output(sc, sc->led_pin, AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
d1025 1
a1025 1
	athn_gpio_write(sc, sc->led_pin, 1);
d1032 1
d1037 1
a1037 1
		AR_CLRBITS(sc, AR_GPIO_INPUT_EN_VAL,
d1040 1
a1040 1
		AR_SETBITS(sc, AR_GPIO_INPUT_EN_VAL,
d1048 1
a1048 1
		athn_gpio_config_input(sc, AR_GPIO_BTACTIVE_PIN);
d1050 1
a1050 1
		AR_SETBITS(sc, AR_GPIO_INPUT_EN_VAL,
d1061 2
a1062 2
		athn_gpio_config_input(sc, AR_GPIO_BTACTIVE_PIN);
		athn_gpio_config_input(sc, AR_GPIO_BTPRIORITY_PIN);
d1069 1
d1090 1
a1090 1
		athn_gpio_config_output(sc, AR_GPIO_WLANACTIVE_PIN,
d1094 1
a1094 1
		athn_gpio_config_output(sc, AR_GPIO_WLANACTIVE_PIN,
d1112 3
a1114 1
	athn_gpio_write(sc, AR_GPIO_WLANACTIVE_PIN, 0);
d1116 1
a1116 1
	athn_gpio_config_output(sc, AR_GPIO_WLANACTIVE_PIN,
a1130 18
athn_rfsilent_init(struct athn_softc *sc)
{
	uint32_t reg;

	/* Configure hardware radio switch. */
	AR_SETBITS(sc, AR_GPIO_INPUT_EN_VAL, AR_GPIO_INPUT_EN_VAL_RFSILENT_BB);
	reg = AR_READ(sc, AR_GPIO_INPUT_MUX2);
	reg = RW(reg, AR_GPIO_INPUT_MUX2_RFSILENT, 0);
	AR_WRITE(sc, AR_GPIO_INPUT_MUX2, reg);
	athn_gpio_config_input(sc, sc->rfsilent_pin);
	AR_SETBITS(sc, AR_PHY_TEST, AR_PHY_TEST_RFSILENT_BB);
	if (!(sc->flags & ATHN_FLAG_RFSILENT_REVERSED)) {
		AR_SETBITS(sc, AR_GPIO_INTR_POL,
		    AR_GPIO_INTR_POL_PIN(sc->rfsilent_pin));
	}
}

void
d1149 1
d1152 1
a1152 12
	if (AR_READ(sc, AR_PHY_TIMING_CTRL4_0) & AR_PHY_TIMING_CTRL4_DO_CAL) {
		/* Calibration in progress, come back later. */
		timeout_add_msec(&sc->calib_to, 500);
		splx(s);
		return;
	}
	if (sc->calib_mask & ATHN_CAL_ADC_GAIN)
		athn_calib_iq(sc);
	else if (sc->calib_mask & ATHN_CAL_ADC_DC)
		athn_calib_adc_gain(sc);
	else if (sc->calib_mask & ATHN_CAL_IQ)
		athn_calib_adc_dc_off(sc);
a1163 279
void
athn_do_calib(struct athn_softc *sc)
{
	int log = AR_MAX_LOG_CAL;	/* XXX */
	uint32_t mode = 0, reg;

	reg = AR_READ(sc, AR_PHY_TIMING_CTRL4_0);
	reg = RW(reg, AR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX, log);
	AR_WRITE(sc, AR_PHY_TIMING_CTRL4_0, reg);

	if (sc->calib_mask & ATHN_CAL_ADC_GAIN)
		mode = AR_PHY_CALMODE_ADC_GAIN;
	else if (sc->calib_mask & ATHN_CAL_ADC_DC)
		mode = AR_PHY_CALMODE_ADC_DC_PER;
	else if (sc->calib_mask & ATHN_CAL_IQ)
		mode = AR_PHY_CALMODE_IQ;
	AR_WRITE(sc, AR_PHY_CALMODE, mode);

	AR_SETBITS(sc, AR_PHY_TIMING_CTRL4_0, AR_PHY_TIMING_CTRL4_DO_CAL);
}

void
athn_calib_iq(struct athn_softc *sc)
{
	struct athn_iq_cal *cal;
	uint32_t reg, i_coff_denom, q_coff_denom;
	int32_t i_coff, q_coff;
	int i, iq_corr_neg;

	for (i = 0; i < AR_MAX_CHAINS; i++) {
		cal = &sc->calib.iq[i];

		/* Accumulate IQ calibration measures (clear on read). */
		cal->pwr_meas_i += AR_READ(sc, AR_PHY_CAL_MEAS_0(i));
		cal->pwr_meas_q += AR_READ(sc, AR_PHY_CAL_MEAS_1(i));
		cal->iq_corr_meas +=
		    (int32_t)AR_READ(sc, AR_PHY_CAL_MEAS_2(i));
	}
	if (++sc->calib.nsamples < AR_CAL_SAMPLES) {
		/* Not enough samples accumulated, continue. */
		athn_do_calib(sc);
		return;
	}

	for (i = 0; i < sc->nrxchains; i++) {
		cal = &sc->calib.iq[i];

		if (cal->pwr_meas_q == 0)
			continue;

		if ((iq_corr_neg = cal->iq_corr_meas < 0))
			cal->iq_corr_meas = -cal->iq_corr_meas;

		i_coff_denom =
		    (cal->pwr_meas_i / 2 + cal->pwr_meas_q / 2) / 128;
		q_coff_denom = cal->pwr_meas_q / 64;

		if (i_coff_denom == 0 || q_coff_denom == 0)
			continue;	/* Prevents division by zero. */

		i_coff = cal->iq_corr_meas / i_coff_denom;
		q_coff = (cal->pwr_meas_i / q_coff_denom) - 64;

		/* Negate i_coff if iq_corr_meas is positive. */
		if (!iq_corr_neg)
			i_coff = 0x40 - (i_coff & 0x3f);
		if (q_coff > 15)
			q_coff = 15;
		else if (q_coff <= -16)
			q_coff = 16;

		DPRINTFN(2, ("IQ calibration for chain %d\n", i));
		reg = AR_READ(sc, AR_PHY_TIMING_CTRL4(i));
		reg = RW(reg, AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF, i_coff);
		reg = RW(reg, AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF, q_coff);
		AR_WRITE(sc, AR_PHY_TIMING_CTRL4(i), reg);
	}

	AR_SETBITS(sc, AR_PHY_TIMING_CTRL4_0,
	    AR_PHY_TIMING_CTRL4_IQCORR_ENABLE);
}

void
athn_calib_adc_gain(struct athn_softc *sc)
{
	struct athn_adc_cal *cal;
	uint32_t reg, gain_mismatch_i, gain_mismatch_q;
	int i;

	for (i = 0; i < AR_MAX_CHAINS; i++) {
		cal = &sc->calib.adc_gain[i];

		/* Accumulate ADC gain measures (clear on read). */
		cal->pwr_meas_odd_i  += AR_READ(sc, AR_PHY_CAL_MEAS_0(i));
		cal->pwr_meas_even_i += AR_READ(sc, AR_PHY_CAL_MEAS_1(i));
		cal->pwr_meas_odd_q  += AR_READ(sc, AR_PHY_CAL_MEAS_2(i));
		cal->pwr_meas_even_q += AR_READ(sc, AR_PHY_CAL_MEAS_3(i));
	}
	if (++sc->calib.nsamples < AR_CAL_SAMPLES) {
		/* Not enough samples accumulated, continue. */
		athn_do_calib(sc);
		return;
	}

	for (i = 0; i < sc->nrxchains; i++) {
		cal = &sc->calib.adc_gain[i];

		if (cal->pwr_meas_odd_i == 0 || cal->pwr_meas_even_q == 0)
			continue;	/* Prevents division by zero. */

		gain_mismatch_i =
		    (cal->pwr_meas_even_i * 32) / cal->pwr_meas_odd_i;
		gain_mismatch_q =
		    (cal->pwr_meas_odd_q * 32) / cal->pwr_meas_even_q;

		DPRINTFN(2, ("ADC gain calibration for chain %d\n", i));
		reg = AR_READ(sc, AR_PHY_NEW_ADC_DC_GAIN_CORR(i));
		reg = RW(reg, AR_PHY_NEW_ADC_DC_GAIN_IGAIN, gain_mismatch_i);
		reg = RW(reg, AR_PHY_NEW_ADC_DC_GAIN_QGAIN, gain_mismatch_q);
		AR_WRITE(sc, AR_PHY_NEW_ADC_DC_GAIN_CORR(i), reg);
	}

	AR_SETBITS(sc, AR_PHY_NEW_ADC_DC_GAIN_CORR(0),
	    AR_PHY_NEW_ADC_GAIN_CORR_ENABLE);
}

void
athn_calib_adc_dc_off(struct athn_softc *sc)
{
	struct athn_adc_cal *cal;
	int32_t dc_offset_mismatch_i, dc_offset_mismatch_q;
	uint32_t reg;
	int count, i;

	for (i = 0; i < AR_MAX_CHAINS; i++) {
		cal = &sc->calib.adc_dc_offset[i];

		/* Accumulate ADC DC offset measures (clear on read). */
		cal->pwr_meas_odd_i  += AR_READ(sc, AR_PHY_CAL_MEAS_0(i));
		cal->pwr_meas_even_i += AR_READ(sc, AR_PHY_CAL_MEAS_1(i));
		cal->pwr_meas_odd_q  += AR_READ(sc, AR_PHY_CAL_MEAS_2(i));
		cal->pwr_meas_even_q += AR_READ(sc, AR_PHY_CAL_MEAS_3(i));
	}
	if (++sc->calib.nsamples < AR_CAL_SAMPLES) {
		/* Not enough samples accumulated, continue. */
		athn_do_calib(sc);
		return;
	}

	count = (1 << (AR_MAX_LOG_CAL + 5)) * sc->calib.nsamples;

	for (i = 0; i < sc->nrxchains; i++) {
		cal = &sc->calib.adc_dc_offset[i];

		dc_offset_mismatch_i =
		    (cal->pwr_meas_even_i - cal->pwr_meas_odd_i * 2) / count;
		dc_offset_mismatch_q =
		    (cal->pwr_meas_odd_q - cal->pwr_meas_even_q * 2) / count;

		DPRINTFN(2, ("ADC DC offset calibration for chain %d\n", i));
		reg = AR_READ(sc, AR_PHY_NEW_ADC_DC_GAIN_CORR(i));
		reg = RW(reg, AR_PHY_NEW_ADC_DC_GAIN_QDC,
		    dc_offset_mismatch_q);
		reg = RW(reg, AR_PHY_NEW_ADC_DC_GAIN_IDC,
		    dc_offset_mismatch_i);
		AR_WRITE(sc, AR_PHY_NEW_ADC_DC_GAIN_CORR(i), reg);
	}

	AR_SETBITS(sc, AR_PHY_NEW_ADC_DC_GAIN_CORR(0),
	    AR_PHY_NEW_ADC_DC_OFFSET_CORR_ENABLE);
}

void
athn_read_noisefloor(struct athn_softc *sc, int16_t *nf, int16_t *nf_ext)
{
/* Sign-extend 9-bit value to 16-bit. */
#define SIGN_EXT(v)	((((int16_t)(v)) << 7) >> 7)
	uint32_t reg;
	int i;

	for (i = 0; i < sc->nrxchains; i++) {
		reg = AR_READ(sc, AR_PHY_CCA(i));
		if (AR_SREV_9280_10_OR_LATER(sc))
			nf[i] = MS(reg, AR9280_PHY_MINCCA_PWR);
		else
			nf[i] = MS(reg, AR_PHY_MINCCA_PWR);
		nf[i] = SIGN_EXT(nf[i]);

		reg = AR_READ(sc, AR_PHY_EXT_CCA(i));
		if (AR_SREV_9280_10_OR_LATER(sc))
			nf_ext[i] = MS(reg, AR9280_PHY_EXT_MINCCA_PWR);
		else
			nf_ext[i] = MS(reg, AR_PHY_EXT_MINCCA_PWR);
		nf_ext[i] = SIGN_EXT(nf_ext[i]);
	}
#undef SIGN_EXT
}

void
athn_write_noisefloor(struct athn_softc *sc, int16_t *nf, int16_t *nf_ext)
{
	uint32_t reg;
	int i;

	for (i = 0; i < sc->nrxchains; i++) {
		reg = AR_READ(sc, AR_PHY_CCA(i));
		reg = RW(reg, AR_PHY_MAXCCA_PWR, nf[i]);
		AR_WRITE(sc, AR_PHY_CCA(i), reg);

		reg = AR_READ(sc, AR_PHY_EXT_CCA(i));
		reg = RW(reg, AR_PHY_EXT_MAXCCA_PWR, nf_ext[i]);
		AR_WRITE(sc, AR_PHY_EXT_CCA(i), reg);
	}
}

void
athn_get_noisefloor(struct athn_softc *sc, struct ieee80211_channel *c)
{
	int16_t nf[AR_MAX_CHAINS], nf_ext[AR_MAX_CHAINS];
	int i;

	if (AR_READ(sc, AR_PHY_AGC_CONTROL) & AR_PHY_AGC_CONTROL_NF) {
		/* Noisefloor calibration not finished. */
		return;
	}
	/* Noisefloor calibration is finished. */
	athn_read_noisefloor(sc, nf, nf_ext);

	/* Update noisefloor history. */
	for (i = 0; i < sc->nrxchains; i++) {
		sc->nf_hist[sc->nf_hist_cur].nf[i] = nf[i];
		sc->nf_hist[sc->nf_hist_cur].nf_ext[i] = nf_ext[i];
	}
	if (++sc->nf_hist_cur >= ATHN_NF_CAL_HIST_MAX)
		sc->nf_hist_cur = 0;
}

void
athn_bb_load_noisefloor(struct athn_softc *sc)
{
	int16_t nf[AR_MAX_CHAINS], nf_ext[AR_MAX_CHAINS];
	int i, ntries;

	/* Write filtered noisefloor values. */
	for (i = 0; i < sc->nrxchains; i++) {
		nf[i] = sc->nf_priv[i] * 2;
		nf_ext[i] = sc->nf_ext_priv[i] * 2;
	}
	athn_write_noisefloor(sc, nf, nf_ext);

	/* Load filtered noisefloor values into baseband. */
	AR_CLRBITS(sc, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_ENABLE_NF);
	AR_CLRBITS(sc, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NO_UPDATE_NF);
	AR_SETBITS(sc, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);
	/* Wait for load to complete. */
	for (ntries = 0; ntries < 5; ntries++) {
		if (!(AR_READ(sc, AR_PHY_AGC_CONTROL) & AR_PHY_AGC_CONTROL_NF))
			break;
		DELAY(50);
	}
#ifdef ATHN_DEBUG
	if (ntries == 5 && athn_debug > 0)
		printf("failed to load noisefloor values\n");
#endif

	/* Restore noisefloor values to initial (max) values. */
	for (i = 0; i < AR_MAX_CHAINS; i++)
		nf[i] = nf_ext[i] = -50 * 2;
	athn_write_noisefloor(sc, nf, nf_ext);
}

void
athn_noisefloor_calib(struct athn_softc *sc)
{
	AR_SETBITS(sc, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_ENABLE_NF);
	AR_SETBITS(sc, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NO_UPDATE_NF);
	AR_SETBITS(sc, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);
}

d1168 1
d1171 3
a1173 1
	if (AR_SREV_9285_12_OR_LATER(sc))
d1185 1
a1185 1
	AR_SETBITS(sc, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);
d1187 5
a1191 3
	if (AR_SREV_9160_10_OR_LATER(sc)) {
		/* Enable IQ calibration. */
		sc->calib_mask = ATHN_CAL_IQ;
d1193 2
d1196 2
a1197 2
		if (IEEE80211_IS_CHAN_5GHZ(c) || extc != NULL)
			sc->calib_mask |= ATHN_CAL_ADC_GAIN | ATHN_CAL_ADC_DC;
d1199 1
a1199 2
		athn_do_calib(sc);
	}
d1204 1
a1204 1
 * Anti-noise immunity.
a1212 118
athn_ani_set_noise_immunity_level(struct athn_softc *sc, int level)
{
	int high = level == 4;
	uint32_t reg;

	reg = AR_READ(sc, AR_PHY_DESIRED_SZ);
	reg = RW(reg, AR_PHY_DESIRED_SZ_TOT_DES, high ? -62 : -55);
	AR_WRITE(sc, AR_PHY_DESIRED_SZ, reg);

	reg = AR_READ(sc, AR_PHY_AGC_CTL1);
	reg = RW(reg, AR_PHY_AGC_CTL1_COARSE_LOW, high ? -70 : -64);
	reg = RW(reg, AR_PHY_AGC_CTL1_COARSE_HIGH, high ? -12 : -14);
	AR_WRITE(sc, AR_PHY_AGC_CTL1, reg);

	reg = AR_READ(sc, AR_PHY_FIND_SIG);
	reg = RW(reg, AR_PHY_FIND_SIG_FIRPWR, high ? -80 : -78);
	AR_WRITE(sc, AR_PHY_FIND_SIG, reg);

	sc->ani.noise_immunity_level = level;
}

void
athn_ani_ena_ofdm_weak_signal(struct athn_softc *sc)
{
	uint32_t reg;

	reg = AR_READ(sc, AR_PHY_SFCORR_LOW);
	reg = RW(reg, AR_PHY_SFCORR_LOW_M1_THRESH_LOW, 50);
	reg = RW(reg, AR_PHY_SFCORR_LOW_M2_THRESH_LOW, 40);
	reg = RW(reg, AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW, 48);
	AR_WRITE(sc, AR_PHY_SFCORR_LOW, reg);

	reg = AR_READ(sc, AR_PHY_SFCORR);
	reg = RW(reg, AR_PHY_SFCORR_M1_THRESH, 77);
	reg = RW(reg, AR_PHY_SFCORR_M2_THRESH, 64);
	reg = RW(reg, AR_PHY_SFCORR_M2COUNT_THR, 16);
	AR_WRITE(sc, AR_PHY_SFCORR, reg);

	reg = AR_READ(sc, AR_PHY_SFCORR_EXT);
	reg = RW(reg, AR_PHY_SFCORR_EXT_M1_THRESH_LOW, 50);
	reg = RW(reg, AR_PHY_SFCORR_EXT_M2_THRESH_LOW, 40);
	reg = RW(reg, AR_PHY_SFCORR_EXT_M1_THRESH, 77);
	reg = RW(reg, AR_PHY_SFCORR_EXT_M2_THRESH, 64);
	AR_WRITE(sc, AR_PHY_SFCORR_EXT, reg);

	AR_SETBITS(sc, AR_PHY_SFCORR_LOW,
	    AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);

	sc->ani.ofdm_weak_signal = 1;
}

void
athn_ani_dis_ofdm_weak_signal(struct athn_softc *sc)
{
	uint32_t reg;

	reg = AR_READ(sc, AR_PHY_SFCORR_LOW);
	reg = RW(reg, AR_PHY_SFCORR_LOW_M1_THRESH_LOW, 127);
	reg = RW(reg, AR_PHY_SFCORR_LOW_M2_THRESH_LOW, 127);
	reg = RW(reg, AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW, 63);
	AR_WRITE(sc, AR_PHY_SFCORR_LOW, reg);

	reg = AR_READ(sc, AR_PHY_SFCORR);
	reg = RW(reg, AR_PHY_SFCORR_M1_THRESH, 127);
	reg = RW(reg, AR_PHY_SFCORR_M2_THRESH, 127);
	reg = RW(reg, AR_PHY_SFCORR_M2COUNT_THR, 31);
	AR_WRITE(sc, AR_PHY_SFCORR, reg);

	reg = AR_READ(sc, AR_PHY_SFCORR_EXT);
	reg = RW(reg, AR_PHY_SFCORR_EXT_M1_THRESH_LOW, 127);
	reg = RW(reg, AR_PHY_SFCORR_EXT_M2_THRESH_LOW, 127);
	reg = RW(reg, AR_PHY_SFCORR_EXT_M1_THRESH, 127);
	reg = RW(reg, AR_PHY_SFCORR_EXT_M2_THRESH, 127);
	AR_WRITE(sc, AR_PHY_SFCORR_EXT, reg);

	AR_CLRBITS(sc, AR_PHY_SFCORR_LOW,
	    AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);

	sc->ani.ofdm_weak_signal = 0;
}

void
athn_ani_set_cck_weak_signal(struct athn_softc *sc, int high)
{
	uint32_t reg;

	reg = AR_READ(sc, AR_PHY_CCK_DETECT);
	reg = RW(reg, AR_PHY_CCK_DETECT_WEAK_SIG_THR_CCK, high ? 6 : 8);
	AR_WRITE(sc, AR_PHY_CCK_DETECT, reg);

	sc->ani.cck_weak_signal = high;
}

void
athn_ani_set_firstep_level(struct athn_softc *sc, int level)
{
	uint32_t reg;

	reg = AR_READ(sc, AR_PHY_FIND_SIG);
	reg = RW(reg, AR_PHY_FIND_SIG_FIRSTEP, level * 4);
	AR_WRITE(sc, AR_PHY_FIND_SIG, reg);

	sc->ani.firstep_level = level;
}

void
athn_ani_set_spur_immunity_level(struct athn_softc *sc, int level)
{
	uint32_t reg;

	reg = AR_READ(sc, AR_PHY_TIMING5);
	reg = RW(reg, AR_PHY_TIMING5_CYCPWR_THR1, (level + 1) * 2);
	AR_WRITE(sc, AR_PHY_TIMING5, reg);

	sc->ani.spur_immunity_level = level;
}

void
d1216 1
d1221 2
a1222 2
		athn_ani_set_noise_immunity_level(sc,
		    ani->noise_immunity_level + 1);
d1228 2
a1229 2
		athn_ani_set_spur_immunity_level(sc,
		    ani->spur_immunity_level + 1);
d1235 4
a1238 3
		if (ani->firstep_level < 2)
			athn_ani_set_firstep_level(sc,
			    ani->firstep_level + 1);
d1249 4
a1252 2
			athn_ani_dis_ofdm_weak_signal(sc);
			athn_ani_set_spur_immunity_level(sc, 0);
d1254 2
a1255 2
			athn_ani_set_firstep_level(sc,
			    ani->firstep_level + 1);
d1262 4
a1265 2
		if (!ani->ofdm_weak_signal)
			athn_ani_ena_ofdm_weak_signal(sc);
d1267 2
a1268 2
			athn_ani_set_firstep_level(sc,
			    ani->firstep_level + 1);
d1276 8
a1283 4
		if (ani->ofdm_weak_signal)
			athn_ani_dis_ofdm_weak_signal(sc);
		if (ani->firstep_level > 0)
			athn_ani_set_firstep_level(sc, 0);
d1291 1
d1296 2
a1297 2
		athn_ani_set_noise_immunity_level(sc,
		    ani->noise_immunity_level + 1);
d1303 4
a1306 3
		if (ani->firstep_level < 2)
			athn_ani_set_firstep_level(sc,
			    ani->firstep_level + 1);
d1316 4
a1319 3
		if (ani->firstep_level < 2)
			athn_ani_set_firstep_level(sc,
			    ani->firstep_level + 1);
d1325 4
a1328 2
		if (ani->firstep_level > 0)
			athn_ani_set_firstep_level(sc, 0);
d1336 1
d1341 4
a1344 3
		if (ani->firstep_level > 0)
			athn_ani_set_firstep_level(sc,
			    ani->firstep_level - 1);
d1360 2
a1361 1
			athn_ani_ena_ofdm_weak_signal(sc);
d1365 2
a1366 2
			athn_ani_set_firstep_level(sc,
			    ani->firstep_level - 1);
d1372 2
a1373 2
			athn_ani_set_firstep_level(sc,
			    ani->firstep_level - 1);
d1381 7
a1387 6
	if (ani->spur_immunity_level > 0)
		athn_ani_set_spur_immunity_level(sc,
		    ani->spur_immunity_level - 1);
	else if (ani->noise_immunity_level > 0)
		athn_ani_set_noise_immunity_level(sc,
		    ani->noise_immunity_level - 1);
a1483 165
void
athn_init_chains(struct athn_softc *sc)
{
	if (sc->rxchainmask == 0x5 || sc->txchainmask == 0x5)
		AR_SETBITS(sc, AR_PHY_ANALOG_SWAP, AR_PHY_SWAP_ALT_CHAIN);

	/* Setup chain masks. */
	if (sc->mac_ver <= AR_SREV_VERSION_9160 &&
	    (sc->rxchainmask == 0x3 || sc->rxchainmask == 0x5)) {
		AR_WRITE(sc, AR_PHY_RX_CHAINMASK,  0x7);
		AR_WRITE(sc, AR_PHY_CAL_CHAINMASK, 0x7);
	} else {
		AR_WRITE(sc, AR_PHY_RX_CHAINMASK,  sc->rxchainmask);
		AR_WRITE(sc, AR_PHY_CAL_CHAINMASK, sc->rxchainmask);
	}
	AR_WRITE(sc, AR_SELFGEN_MASK, sc->txchainmask);
}

void
athn_get_pier_ival(uint8_t fbin, const uint8_t *pierfreq, int npiers,
    int *lo, int *hi)
{
	int i;

	for (i = 0; i < npiers; i++)
		if (pierfreq[i] == AR_BCHAN_UNUSED ||
		    pierfreq[i] > fbin)
			break;
	*hi = i;
	*lo = *hi - 1;
	if (*lo == -1)
		*lo = *hi;
	else if (*hi == npiers || pierfreq[*hi] == AR_BCHAN_UNUSED)
		*hi = *lo;
}

uint8_t
athn_get_vpd(uint8_t pwr, const uint8_t *pwrPdg, const uint8_t *vpdPdg,
    int nicepts)
{
	uint8_t vpd;
	int i, lo, hi;

	for (i = 0; i < nicepts; i++)
		if (pwrPdg[i] > pwr)
			break;
	hi = i;
	lo = hi - 1;
	if (lo == -1)
		lo = hi;
	else if (hi == nicepts)
		hi = lo;

	vpd = athn_interpolate(pwr, pwrPdg[lo], vpdPdg[lo],
	    pwrPdg[hi], vpdPdg[hi]);
	return (vpd);
}

void
athn_get_pdadcs(struct athn_softc *sc, uint8_t fbin, struct athn_pier *lopier,
    struct athn_pier *hipier, int nxpdgains, int nicepts, uint8_t overlap,
    uint8_t *boundaries, uint8_t *pdadcs)
{
#define DB(x)	((x) / 2)	/* Convert half dB to dB. */
	uint8_t minpwr[AR_PD_GAINS_IN_MASK], maxpwr[AR_PD_GAINS_IN_MASK];
	uint8_t vpd[AR_MAX_PWR_RANGE_IN_HALF_DB], pwr;
	uint8_t lovpd, hivpd, boundary;
	int16_t ss, delta, vpdstep, val;
	int i, j, npdadcs, nvpds, maxidx, tgtidx;

	/* Compute min and max power in half dB for each pdGain. */
	for (i = 0; i < nxpdgains; i++) {
		minpwr[i] = MAX(lopier->pwr[i][0], hipier->pwr[i][0]);
		maxpwr[i] = MIN(lopier->pwr[i][nicepts - 1],
		    hipier->pwr[i][nicepts - 1]);
	}

	npdadcs = 0;
	for (i = 0; i < nxpdgains; i++) {
		if (i != nxpdgains - 1)
			boundaries[i] = DB(maxpwr[i] + minpwr[i + 1]) / 2;
		else
			boundaries[i] = DB(maxpwr[i]);
		if (boundaries[i] > AR_MAX_RATE_POWER)
			boundaries[i] = AR_MAX_RATE_POWER;

		if (i == 0 && !AR_SREV_5416_20_OR_LATER(sc)) {
			/* Fix the gain delta (AR5416 1.0 only.) */
			delta = boundaries[0] - 23;
			boundaries[0] = 23;
		} else
			delta = 0;

		/* Find starting index for this pdGain. */
		if (i != 0) {
			ss = boundaries[i - 1] - DB(minpwr[i]) -
			    overlap + 1 + delta;
		} else if (AR_SREV_9280_10_OR_LATER(sc)) {
			ss = -DB(minpwr[i]);
		} else
			ss = 0;

		/* Compute Vpd table for this pdGain. */
		nvpds = DB(maxpwr[i] - minpwr[i]) + 1;
		memset(vpd, 0, sizeof(vpd));
		pwr = minpwr[i];
		for (j = 0; j < nvpds; j++) {
			/* Get lower and higher Vpd. */
			lovpd = athn_get_vpd(pwr, lopier->pwr[i],
			    lopier->vpd[i], nicepts);
			hivpd = athn_get_vpd(pwr, hipier->pwr[i],
			    hipier->vpd[i], nicepts);

			/* Interpolate the final Vpd. */
			vpd[j] = athn_interpolate(fbin,
			    lopier->fbin, lovpd, hipier->fbin, hivpd);

			pwr += 2;	/* In half dB. */
		}

		/* Extrapolate data for ss < 0. */
		if (vpd[1] > vpd[0])
			vpdstep = vpd[1] - vpd[0];
		else
			vpdstep = 1;
		while (ss < 0 && npdadcs < AR_NUM_PDADC_VALUES - 1) {
			val = vpd[0] + ss * vpdstep;
			pdadcs[npdadcs++] = MAX(val, 0);
			ss++;
		}

		tgtidx = boundaries[i] + overlap - DB(minpwr[i]);
		maxidx = MIN(tgtidx, nvpds);
		while (ss < maxidx && npdadcs < AR_NUM_PDADC_VALUES - 1)
			pdadcs[npdadcs++] = vpd[ss++];

		if (tgtidx <= maxidx)
			continue;

		/* Extrapolate data for maxidx <= ss <= tgtidx. */
		if (vpd[nvpds - 1] > vpd[nvpds - 2])
			vpdstep = vpd[nvpds - 1] - vpd[nvpds - 2];
		else
			vpdstep = 1;
		while (ss <= tgtidx && npdadcs < AR_NUM_PDADC_VALUES - 1) {
			val = vpd[nvpds - 1] + (ss - maxidx + 1) * vpdstep;
			pdadcs[npdadcs++] = MIN(val, 255);
			ss++;
		}
	}

	/* Fill remaining PDADC and boundaries entries. */
	if (AR_SREV_9285(sc))
		boundary = AR9285_PD_GAIN_BOUNDARY_DEFAULT;
	else	/* Fill with latest. */
		boundary = boundaries[nxpdgains - 1];

	for (; nxpdgains < AR_PD_GAINS_IN_MASK; nxpdgains++)
		boundaries[nxpdgains] = boundary;

	for (; npdadcs < AR_NUM_PDADC_VALUES; npdadcs++)
		pdadcs[npdadcs] = pdadcs[npdadcs - 1];
#undef DB
}

d1494 2
a1495 117
athn_get_lg_tpow(struct athn_softc *sc, struct ieee80211_channel *c,
    uint8_t ctl, const struct ar_cal_target_power_leg *tgt, int nchans,
    uint8_t tpow[4])
{
	uint8_t fbin;
	int i, lo, hi;

	/* Find interval (lower and upper indices.) */
	fbin = athn_chan2fbin(c);
	for (i = 0; i < nchans; i++) {
		if (tgt[i].bChannel == AR_BCHAN_UNUSED ||
		    tgt[i].bChannel > fbin)
			break;
	}
	hi = i;
	lo = hi - 1;
	if (lo == -1)
		lo = hi;
	else if (hi == nchans || tgt[hi].bChannel == AR_BCHAN_UNUSED)
		hi = lo;

	/* Interpolate values. */
	for (i = 0; i < 4; i++) {
		tpow[i] = athn_interpolate(fbin,
		    tgt[lo].bChannel, tgt[lo].tPow2x[i],
		    tgt[hi].bChannel, tgt[hi].tPow2x[i]);
	}
	/* XXX Apply conformance test limit. */
}

#ifndef IEEE80211_NO_HT
void
athn_get_ht_tpow(struct athn_softc *sc, struct ieee80211_channel *c,
    uint8_t ctl, const struct ar_cal_target_power_ht *tgt, int nchans,
    uint8_t tpow[8])
{
	uint8_t fbin;
	int i, lo, hi;

	/* Find interval (lower and upper indices.) */
	fbin = athn_chan2fbin(c);
	for (i = 0; i < nchans; i++) {
		if (tgt[i].bChannel == AR_BCHAN_UNUSED ||
		    tgt[i].bChannel > fbin)
			break;
	}
	hi = i;
	lo = hi - 1;
	if (lo == -1)
		lo = hi;
	else if (hi == nchans || tgt[hi].bChannel == AR_BCHAN_UNUSED)
		hi = lo;

	/* Interpolate values. */
	for (i = 0; i < 8; i++) {
		tpow[i] = athn_interpolate(fbin,
		    tgt[lo].bChannel, tgt[lo].tPow2x[i],
		    tgt[hi].bChannel, tgt[hi].tPow2x[i]);
	}
	/* XXX Apply conformance test limit. */
}
#endif

void
athn_write_txpower(struct athn_softc *sc, int16_t power[ATHN_POWER_COUNT])
{
	AR_WRITE(sc, AR_PHY_POWER_TX_RATE1,
	    (power[ATHN_POWER_OFDM18  ] & 0x3f) << 24 |
	    (power[ATHN_POWER_OFDM12  ] & 0x3f) << 16 |
	    (power[ATHN_POWER_OFDM9   ] & 0x3f) <<  8 |
	    (power[ATHN_POWER_OFDM6   ] & 0x3f));
	AR_WRITE(sc, AR_PHY_POWER_TX_RATE2,
	    (power[ATHN_POWER_OFDM54  ] & 0x3f) << 24 |
	    (power[ATHN_POWER_OFDM48  ] & 0x3f) << 16 |
	    (power[ATHN_POWER_OFDM36  ] & 0x3f) <<  8 |
	    (power[ATHN_POWER_OFDM24  ] & 0x3f));
	AR_WRITE(sc, AR_PHY_POWER_TX_RATE3,
	    (power[ATHN_POWER_CCK2_SP ] & 0x3f) << 24 |
	    (power[ATHN_POWER_CCK2_LP ] & 0x3f) << 16 |
	    (power[ATHN_POWER_XR      ] & 0x3f) <<  8 |
	    (power[ATHN_POWER_CCK1_LP ] & 0x3f));
	AR_WRITE(sc, AR_PHY_POWER_TX_RATE4,
	    (power[ATHN_POWER_CCK11_SP] & 0x3f) << 24 |
	    (power[ATHN_POWER_CCK11_LP] & 0x3f) << 16 |
	    (power[ATHN_POWER_CCK55_SP] & 0x3f) <<  8 |
	    (power[ATHN_POWER_CCK55_LP] & 0x3f));
#ifndef IEEE80211_NO_HT
	AR_WRITE(sc, AR_PHY_POWER_TX_RATE5,
	    (power[ATHN_POWER_HT20(3) ] & 0x3f) << 24 |
	    (power[ATHN_POWER_HT20(2) ] & 0x3f) << 16 |
	    (power[ATHN_POWER_HT20(1) ] & 0x3f) <<  8 |
	    (power[ATHN_POWER_HT20(0) ] & 0x3f));
	AR_WRITE(sc, AR_PHY_POWER_TX_RATE6,
	    (power[ATHN_POWER_HT20(7) ] & 0x3f) << 24 |
	    (power[ATHN_POWER_HT20(6) ] & 0x3f) << 16 |
	    (power[ATHN_POWER_HT20(5) ] & 0x3f) <<  8 |
	    (power[ATHN_POWER_HT20(4) ] & 0x3f));
	AR_WRITE(sc, AR_PHY_POWER_TX_RATE7,
	    (power[ATHN_POWER_HT40(3) ] & 0x3f) << 24 |
	    (power[ATHN_POWER_HT40(2) ] & 0x3f) << 16 |
	    (power[ATHN_POWER_HT40(1) ] & 0x3f) <<  8 |
	    (power[ATHN_POWER_HT40(0) ] & 0x3f));
	AR_WRITE(sc, AR_PHY_POWER_TX_RATE8,
	    (power[ATHN_POWER_HT40(7) ] & 0x3f) << 24 |
	    (power[ATHN_POWER_HT40(6) ] & 0x3f) << 16 |
	    (power[ATHN_POWER_HT40(5) ] & 0x3f) <<  8 |
	    (power[ATHN_POWER_HT40(4) ] & 0x3f));
	AR_WRITE(sc, AR_PHY_POWER_TX_RATE9,
	    (power[ATHN_POWER_OFDM_EXT] & 0x3f) << 24 |
	    (power[ATHN_POWER_CCK_EXT ] & 0x3f) << 16 |
	    (power[ATHN_POWER_OFDM_DUP] & 0x3f) <<  8 |
	    (power[ATHN_POWER_CCK_DUP ] & 0x3f));
#endif
}

void
athn_init_baseband(struct athn_softc *sc)
d1497 1
a1497 1
	uint32_t synth_delay;
d1499 10
a1508 4
	synth_delay = athn_synth_delay(sc);
	/* Activate the PHY (includes baseband activate and synthesizer on). */
	AR_WRITE(sc, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
	DELAY(AR_BASE_PHY_ACTIVE_DELAY + synth_delay);
d1516 4
a1519 3
	/* Set AHB not to do cacheline prefetches. */
	AR_SETBITS(sc, AR_AHB_MODE, AR_AHB_PREFETCH_RD_EN);

d1527 1
a1527 1
	else
d1543 4
d1598 23
a1665 356
void
athn_tx_reclaim(struct athn_softc *sc, int qid)
{
	struct athn_txq *txq = &sc->txq[qid];
	struct athn_tx_buf *bf;

	/* Reclaim all buffers queued in the specified Tx queue. */
	/* NB: Tx DMA must be stopped. */
	while ((bf = SIMPLEQ_FIRST(&txq->head)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&txq->head, bf_list);

		bus_dmamap_sync(sc->sc_dmat, bf->bf_map, 0,
		    bf->bf_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, bf->bf_map);
		m_freem(bf->bf_m);
		bf->bf_m = NULL;
		bf->bf_ni = NULL;	/* Nodes already freed! */

		/* Link Tx buffer back to global free list. */
		SIMPLEQ_INSERT_TAIL(&sc->txbufs, bf, bf_list);
	}
}

#if NBPFILTER > 0
void
athn_rx_radiotap(struct athn_softc *sc, struct mbuf *m, struct ar_rx_desc *ds)
{
#define IEEE80211_RADIOTAP_F_SHORTGI	0x80	/* XXX from FBSD */

	struct athn_rx_radiotap_header *tap = &sc->sc_rxtap;
	struct ieee80211com *ic = &sc->sc_ic;
	struct mbuf mb;
	uint64_t tsf;
	uint32_t tstamp;
	uint8_t rate;

	/* Extend the 15-bit timestamp from Rx descriptor to 64-bit TSF. */
	tstamp = ds->ds_status2;
	tsf = AR_READ(sc, AR_TSF_U32);
	tsf = tsf << 32 | AR_READ(sc, AR_TSF_L32);
	if ((tsf & 0x7fff) < tstamp)
		tsf -= 0x8000;
	tsf = (tsf & ~0x7fff) | tstamp;

	tap->wr_flags = IEEE80211_RADIOTAP_F_FCS;
	tap->wr_tsft = htole64(tsf);
	tap->wr_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
	tap->wr_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
	tap->wr_dbm_antsignal = MS(ds->ds_status4, AR_RXS4_RSSI_COMBINED);
	/* XXX noise. */
	tap->wr_antenna = MS(ds->ds_status3, AR_RXS3_ANTENNA);
	tap->wr_rate = 0;	/* In case it can't be found below. */
	if (AR_SREV_5416_20_OR_LATER(sc))
		rate = MS(ds->ds_status0, AR_RXS0_RATE);
	else
		rate = MS(ds->ds_status3, AR_RXS3_RATE);
	if (rate & 0x80) {		/* HT. */
		/* Bit 7 set means HT MCS instead of rate. */
		tap->wr_rate = rate;
		if (!(ds->ds_status3 & AR_RXS3_GI))
			tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTGI;

	} else if (rate & 0x10) {	/* CCK. */
		if (rate & 0x04)
			tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
		switch (rate & ~0x14) {
		case 0xb: tap->wr_rate =   2; break;
		case 0xa: tap->wr_rate =   4; break;
		case 0x9: tap->wr_rate =  11; break;
		case 0x8: tap->wr_rate =  22; break;
		}
	} else {			/* OFDM. */
		switch (rate) {
		case 0xb: tap->wr_rate =  12; break;
		case 0xf: tap->wr_rate =  18; break;
		case 0xa: tap->wr_rate =  24; break;
		case 0xe: tap->wr_rate =  36; break;
		case 0x9: tap->wr_rate =  48; break;
		case 0xd: tap->wr_rate =  72; break;
		case 0x8: tap->wr_rate =  96; break;
		case 0xc: tap->wr_rate = 108; break;
		}
	}
	mb.m_data = (caddr_t)tap;
	mb.m_len = sc->sc_rxtap_len;
	mb.m_next = m;
	mb.m_nextpkt = NULL;
	mb.m_type = 0;
	mb.m_flags = 0;
	bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
}
#endif

static __inline int
athn_rx_process(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct athn_rxq *rxq = &sc->rxq;
	struct athn_rx_buf *bf, *nbf;
	struct ar_rx_desc *ds;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *m, *m1;
	int error, len;

	bf = SIMPLEQ_FIRST(&rxq->head);
	if (__predict_false(bf == NULL)) {	/* Should not happen. */
		printf("%s: Rx queue is empty!\n", sc->sc_dev.dv_xname);
		return (ENOENT);
	}
	ds = bf->bf_desc;

	if (!(ds->ds_status8 & AR_RXS8_DONE)) {
		/*
		 * On some parts, the status words can get corrupted
		 * (including the "done" bit), so we check the next
		 * descriptor "done" bit.  If it is set, it is a good
		 * indication that the status words are corrupted, so
		 * we skip this descriptor and drop the frame.
		 */
		nbf = SIMPLEQ_NEXT(bf, bf_list);
		if (nbf != NULL &&
		    (nbf->bf_desc->ds_status8 & AR_RXS8_DONE)) {
			DPRINTF(("corrupted descriptor status=0x%x\n",
			    ds->ds_status8));
			/* HW will not "move" RXDP in this case, so do it. */
			AR_WRITE(sc, AR_RXDP, nbf->bf_daddr);
			ifp->if_ierrors++;
			goto skip;
		}
		return (EBUSY);
	}

	if (__predict_false(ds->ds_status1 & AR_RXS1_MORE)) {
		/* Drop frames that span multiple Rx descriptors. */
		DPRINTF(("dropping split frame\n"));
		ifp->if_ierrors++;
		goto skip;
	}
	if (!(ds->ds_status8 & AR_RXS8_FRAME_OK)) {
		if (ds->ds_status8 & AR_RXS8_CRC_ERR)
			DPRINTFN(6, ("CRC error\n"));
		else if (ds->ds_status8 & AR_RXS8_PHY_ERR)
			DPRINTFN(6, ("PHY error=0x%x\n",
			    MS(ds->ds_status8, AR_RXS8_PHY_ERR_CODE)));
		else if (ds->ds_status8 & AR_RXS8_DECRYPT_CRC_ERR)
			DPRINTFN(6, ("Decryption CRC error\n"));
		else if (ds->ds_status8 & AR_RXS8_MICHAEL_ERR) {
			DPRINTFN(2, ("Michael MIC failure\n"));
			/* Report Michael MIC failures to net80211. */
			ic->ic_stats.is_rx_locmicfail++;
			ieee80211_michael_mic_failure(ic, 0);
			/*
			 * XXX Check that it is not a control frame
			 * (invalid MIC failures on valid ctl frames.)
			 */
		}
		ifp->if_ierrors++;
		goto skip;
	}

	len = MS(ds->ds_status1, AR_RXS1_DATA_LEN);
	if (__predict_false(len == 0 || len > ATHN_RXBUFSZ)) {
		DPRINTF(("corrupted descriptor length=%d\n", len));
		ifp->if_ierrors++;
		goto skip;
	}

	/* Allocate a new Rx buffer. */
	m1 = MCLGETI(NULL, M_DONTWAIT, NULL, ATHN_RXBUFSZ);
	if (__predict_false(m1 == NULL)) {
		ic->ic_stats.is_rx_nombuf++;
		ifp->if_ierrors++;
		goto skip;
	}

	/* Sync and unmap the old Rx buffer. */
	bus_dmamap_sync(sc->sc_dmat, bf->bf_map, 0, ATHN_RXBUFSZ,
	    BUS_DMASYNC_POSTREAD);
	bus_dmamap_unload(sc->sc_dmat, bf->bf_map);

	/* Map the new Rx buffer. */
	error = bus_dmamap_load(sc->sc_dmat, bf->bf_map, mtod(m1, void *),
	    ATHN_RXBUFSZ, NULL, BUS_DMA_NOWAIT | BUS_DMA_READ);
	if (__predict_false(error != 0)) {
		m_freem(m1);

		/* Remap the old Rx buffer or panic. */
		error = bus_dmamap_load(sc->sc_dmat, bf->bf_map,
		    mtod(bf->bf_m, void *), ATHN_RXBUFSZ, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_READ);
		KASSERT(error != 0);
		ifp->if_ierrors++;
		goto skip;
	}

	bus_dmamap_sync(sc->sc_dmat, bf->bf_map, 0, bf->bf_map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

	/* Write physical address of new Rx buffer. */
	ds->ds_data = bf->bf_map->dm_segs[0].ds_addr;

	m = bf->bf_m;
	bf->bf_m = m1;

	/* Finalize mbuf. */
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = m->m_len = len;

	/* Grab a reference to the source node. */
	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

	/* Remove any HW padding after the 802.11 header. */
	if (!(wh->i_fc[0] & IEEE80211_FC0_TYPE_CTL)) {
		u_int hdrlen = ieee80211_get_hdrlen(wh);
		if (hdrlen & 3) {
			ovbcopy(wh, (caddr_t)wh + 2, hdrlen);
			m_adj(m, 2);	/* XXX sure? */
		}
	}
#if NBPFILTER > 0
	if (__predict_false(sc->sc_drvbpf != NULL))
		athn_rx_radiotap(sc, m, ds);
#endif
	/* Trim 802.11 FCS after radiotap. */
	m_adj(m, -IEEE80211_CRC_LEN);

	/* Send the frame to the 802.11 layer. */
	rxi.rxi_flags = 0;	/* XXX */
	rxi.rxi_rssi = MS(ds->ds_status4, AR_RXS4_RSSI_COMBINED);
	rxi.rxi_tstamp = ds->ds_status2;
	ieee80211_input(ifp, m, ni, &rxi);

	/* Node is no longer needed. */
	ieee80211_release_node(ic, ni);

 skip:
	/* Unlink this descriptor from head. */
	SIMPLEQ_REMOVE_HEAD(&rxq->head, bf_list);
	memset(&ds->ds_status0, 0, 36);	/* XXX Really needed? */
	ds->ds_status8 &= ~AR_RXS8_DONE;
	ds->ds_link = 0;

	/* Re-use this descriptor and link it to tail. */
	if (__predict_true(!SIMPLEQ_EMPTY(&rxq->head)))
		rxq->lastds->ds_link = bf->bf_daddr;
	else
		AR_WRITE(sc, AR_RXDP, bf->bf_daddr);
	SIMPLEQ_INSERT_TAIL(&rxq->head, bf, bf_list);
	rxq->lastds = ds;

	/* Re-enable Rx. */
	AR_WRITE(sc, AR_CR, AR_CR_RXE);
	return (0);
}

void
athn_rx_intr(struct athn_softc *sc)
{
	while (athn_rx_process(sc) == 0);
}

int
athn_tx_process(struct athn_softc *sc, int qid)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct athn_txq *txq = &sc->txq[qid];
	struct athn_node *an;
	struct athn_tx_buf *bf;
	struct ar_tx_desc *ds;
	uint8_t failcnt;

	bf = SIMPLEQ_FIRST(&txq->head);
	if (__predict_false(bf == NULL))
		return (ENOENT);
	/* Get descriptor of last DMA segment. */
	ds = &bf->bf_descs[bf->bf_map->dm_nsegs - 1];

	if (!(ds->ds_status9 & AR_TXS9_DONE))
		return (EBUSY);

	SIMPLEQ_REMOVE_HEAD(&txq->head, bf_list);
	ifp->if_opackets++;

	sc->sc_tx_timer = 0;

	if (ds->ds_status1 & AR_TXS1_EXCESSIVE_RETRIES)
		ifp->if_oerrors++;

	if (ds->ds_status1 & AR_TXS1_UNDERRUN)
		athn_inc_tx_trigger_level(sc);

	an = (struct athn_node *)bf->bf_ni;
	/*
	 * NB: the data fail count contains the number of un-acked tries
	 * for the final series used.  We must add the number of tries for
	 * each series that was fully processed.
	 */
	failcnt  = MS(ds->ds_status1, AR_TXS1_DATA_FAIL_CNT);
	/* XXX Assume two tries per series. */
	failcnt += MS(ds->ds_status9, AR_TXS9_FINAL_IDX) * 2;

	/* Update rate control statistics. */
	an->amn.amn_txcnt++;
	if (failcnt > 0)
		an->amn.amn_retrycnt++;

	DPRINTFN(5, ("Tx done qid=%d status1=%d fail count=%d\n",
	    qid, ds->ds_status1, failcnt));

	bus_dmamap_sync(sc->sc_dmat, bf->bf_map, 0, bf->bf_map->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, bf->bf_map);

	m_freem(bf->bf_m);
	bf->bf_m = NULL;
	ieee80211_release_node(ic, bf->bf_ni);
	bf->bf_ni = NULL;

	/* Link Tx buffer back to global free list. */
	SIMPLEQ_INSERT_TAIL(&sc->txbufs, bf, bf_list);
	return (0);
}

void
athn_tx_intr(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	uint16_t mask = 0;
	uint32_t reg;
	int qid;

	reg = AR_READ(sc, AR_ISR_S0_S);
	mask |= MS(reg, AR_ISR_S0_QCU_TXOK);
	mask |= MS(reg, AR_ISR_S0_QCU_TXDESC);

	reg = AR_READ(sc, AR_ISR_S1_S);
	mask |= MS(reg, AR_ISR_S1_QCU_TXERR);
	mask |= MS(reg, AR_ISR_S1_QCU_TXEOL);

	DPRINTFN(4, ("Tx interrupt mask=0x%x\n", mask));
	for (qid = 0; mask != 0; mask >>= 1, qid++) {
		if (mask & 1)
			while (athn_tx_process(sc, qid) == 0);
	}
	if (!SIMPLEQ_EMPTY(&sc->txbufs)) {
		ifp->if_flags &= ~IFF_OACTIVE;
		athn_start(ifp);
	}
}

a1688 355
int
athn_tx(struct athn_softc *sc, struct mbuf *m, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_key *k = NULL;
	struct ieee80211_frame *wh;
	struct athn_series series[4];
	struct ar_tx_desc *ds, *lastds;
	struct athn_txq *txq;
	struct athn_tx_buf *bf;
	struct athn_node *an = (void *)ni;
	struct mbuf *m1;
	uintptr_t entry;
	uint16_t qos;
	uint8_t txpower, type, encrtype, tid, ridx[4];
	int i, error, totlen, hasqos, qid;

	/* Grab a Tx buffer from our global free list. */
	bf = SIMPLEQ_FIRST(&sc->txbufs);
	KASSERT(bf != NULL);
	SIMPLEQ_REMOVE_HEAD(&sc->txbufs, bf_list);

	/* Map 802.11 frame type to hardware frame type. */
	wh = mtod(m, struct ieee80211_frame *);
	if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
	    (IEEE80211_FC0_TYPE_MGT  | IEEE80211_FC0_SUBTYPE_BEACON))
		type = AR_FRAME_TYPE_BEACON;
	else if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
	    (IEEE80211_FC0_TYPE_MGT  | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
		type = AR_FRAME_TYPE_PROBE_RESP;
	else if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
	    (IEEE80211_FC0_TYPE_MGT  | IEEE80211_FC0_SUBTYPE_ATIM))
		type = AR_FRAME_TYPE_ATIM;
	else if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
	    (IEEE80211_FC0_TYPE_CTL  | IEEE80211_FC0_SUBTYPE_PS_POLL))
		type = AR_FRAME_TYPE_PSPOLL;
	else
		type = AR_FRAME_TYPE_NORMAL;

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);
		if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
			return (ENOBUFS);
		wh = mtod(m, struct ieee80211_frame *);
	}

	/* XXX 2-byte padding for QoS and 4-addr headers. */

	/* Select the HW Tx queue to use for this frame. */
	if ((hasqos = ieee80211_has_qos(wh))) {
		qos = ieee80211_get_qos(wh);
		tid = qos & IEEE80211_QOS_TID;
		qid = athn_ac2qid[ieee80211_up_to_ac(ic, tid)];
	} else if (type == AR_FRAME_TYPE_BEACON) {
		qid = ATHN_QID_BEACON;
	} else if (type == AR_FRAME_TYPE_PSPOLL) {
		qid = ATHN_QID_PSPOLL;
	} else
		qid = ATHN_QID_AC_BE;
	txq = &sc->txq[qid];

	/* Select the transmit rates to use for this frame. */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) !=
	    IEEE80211_FC0_TYPE_DATA) {
		/* Use lowest rate for all tries. */
		ridx[0] = ridx[1] = ridx[2] = ridx[3] =
		    (ic->ic_curmode == IEEE80211_MODE_11A) ?
			ATHN_RIDX_OFDM6 : ATHN_RIDX_CCK1;
	} else if (ic->ic_fixed_rate != -1) {
		/* Use same fixed rate for all tries. */
		ridx[0] = ridx[1] = ridx[2] = ridx[3] =
		    sc->fixed_ridx;
	} else {
		int txrate = ni->ni_txrate;
		/* Use fallback table of the node. */
		for (i = 0; i < 4; i++) {
			ridx[i] = an->ridx[txrate];
			txrate = an->fallback[txrate];
		}
	}

#if NBPFILTER > 0
	if (__predict_false(sc->sc_drvbpf != NULL)) {
		struct athn_tx_radiotap_header *tap = &sc->sc_txtap;
		struct mbuf mb;

		tap->wt_flags = 0;
		/* Use initial transmit rate. */
		tap->wt_rate = athn_rates[ridx[0]].rate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wt_hwqueue = qid;
		if (ridx[0] != ATHN_RIDX_CCK1 &&
		    (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
			tap->wt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	/* DMA map mbuf. */
	error = bus_dmamap_load_mbuf(sc->sc_dmat, bf->bf_map, m,
	    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
	if (__predict_false(error != 0)) {
		if (error != EFBIG) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m);
			return (error);
		}
		/*
		 * DMA mapping requires too many DMA segments; linearize
		 * mbuf in kernel virtual address space and retry.
		 */
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
			m_freem(m);
			return (ENOBUFS);
		}
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(m1);
				return (ENOBUFS);
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_pkthdr.len = m1->m_len = m->m_pkthdr.len;
		m_freem(m);
		m = m1;

		error = bus_dmamap_load_mbuf(sc->sc_dmat, bf->bf_map, m,
		    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m);
			return (error);
		}
	}
	bf->bf_m = m;
	bf->bf_ni = ni;

	wh = mtod(m, struct ieee80211_frame *);

	totlen = m->m_pkthdr.len + IEEE80211_CRC_LEN;

	/* Clear all Tx descriptors that we will use. */
	memset(bf->bf_descs, 0, bf->bf_map->dm_nsegs * sizeof (*ds));

	/* Setup first Tx descriptor. */
	ds = &bf->bf_descs[0];

	ds->ds_ctl0 = AR_TXC0_INTR_REQ | AR_TXC0_CLR_DEST_MASK;
	txpower = AR_MAX_RATE_POWER;	/* Get from per-rate registers. */
	ds->ds_ctl0 |= SM(AR_TXC0_XMIT_POWER, txpower);

	ds->ds_ctl1 = SM(AR_TXC1_FRAME_TYPE, type);

	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    (hasqos && (qos & IEEE80211_QOS_ACK_POLICY_MASK) ==
	     IEEE80211_QOS_ACK_POLICY_NOACK))
		ds->ds_ctl1 |= AR_TXC1_NO_ACK;

	if (0 && wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		/* Retrieve key for encryption. */
		k = ieee80211_get_txkey(ic, wh, ni);
		/*
		 * Map 802.11 cipher to hardware encryption type and
		 * compute crypto overhead.
		 */
		switch (k->k_cipher) {
		case IEEE80211_CIPHER_WEP40:
		case IEEE80211_CIPHER_WEP104:
			encrtype = AR_ENCR_TYPE_WEP;
			totlen += 8;
			break;
		case IEEE80211_CIPHER_TKIP:
			encrtype = AR_ENCR_TYPE_TKIP;
			totlen += 20;
			break;
		case IEEE80211_CIPHER_CCMP:
			encrtype = AR_ENCR_TYPE_AES;
			totlen += 16;
			break;
		default:
			panic("unsupported cipher");	/* XXX BIP? */
		}
		/*
		 * NB: The key cache entry index is stored in the key
		 * private field when the key is installed.
		 */
		entry = (uintptr_t)k->k_priv;
		ds->ds_ctl1 |= SM(AR_TXC1_DEST_IDX, entry);
		ds->ds_ctl0 |= AR_TXC0_DEST_IDX_VALID;
	} else
		encrtype = AR_ENCR_TYPE_CLEAR;
	ds->ds_ctl6 = SM(AR_TXC6_ENCR_TYPE, encrtype);

	/* Check if frame must be protected using RTS/CTS or CTS-to-self. */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* NB: Group frames are sent using CCK in 802.11b/g. */
		if (totlen > ic->ic_rtsthreshold) {
			ds->ds_ctl0 |= AR_TXC0_RTS_ENABLE;
		} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
		    athn_rates[ridx[0]].phy == IEEE80211_T_OFDM) {
			if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				ds->ds_ctl0 |= AR_TXC0_RTS_ENABLE;
			else if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				ds->ds_ctl0 |= AR_TXC0_CTS_ENABLE;
		}
	}
	if (ds->ds_ctl0 & (AR_TXC0_RTS_ENABLE | AR_TXC0_CTS_ENABLE)) {
		/* Disable multi-rate retries when protection is used. */
		ridx[1] = ridx[2] = ridx[3] = ridx[0];
	}
	/* Setup multi-rate retries. */
	for (i = 0; i < 4; i++) {
		series[i].hwrate = athn_rates[ridx[i]].hwrate;
		if (athn_rates[ridx[i]].phy == IEEE80211_T_DS &&
		    ridx[i] != ATHN_RIDX_CCK1 &&
		    (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
			series[i].hwrate |= 0x04;
		series[i].dur = 0;
	}
	if (!(ds->ds_ctl1 & AR_TXC1_NO_ACK)) {
		/* Compute duration for each series. */
		for (i = 0; i < 4; i++) {
			series[i].dur = athn_txtime(sc, IEEE80211_ACK_LEN,
			    athn_rates[ridx[i]].rspridx, ic->ic_flags);
		}
	}

	/* Write number of tries for each series. */
	ds->ds_ctl2 =
	    SM(AR_TXC2_XMIT_DATA_TRIES0, 2) |
	    SM(AR_TXC2_XMIT_DATA_TRIES1, 2) |
	    SM(AR_TXC2_XMIT_DATA_TRIES2, 2) |
	    SM(AR_TXC2_XMIT_DATA_TRIES3, 4);

	/* Tell HW to update duration field in 802.11 header. */
	if (type != AR_FRAME_TYPE_PSPOLL)
		ds->ds_ctl2 |= AR_TXC2_DUR_UPDATE_ENA;

	/* Write Tx rate for each series. */
	ds->ds_ctl3 =
	    SM(AR_TXC3_XMIT_RATE0, series[0].hwrate) |
	    SM(AR_TXC3_XMIT_RATE1, series[1].hwrate) |
	    SM(AR_TXC3_XMIT_RATE2, series[2].hwrate) |
	    SM(AR_TXC3_XMIT_RATE3, series[3].hwrate);

	/* Write duration for each series. */
	ds->ds_ctl4 =
	    SM(AR_TXC4_PACKET_DUR0, series[0].dur) |
	    SM(AR_TXC4_PACKET_DUR1, series[1].dur);
	ds->ds_ctl5 =
	    SM(AR_TXC5_PACKET_DUR2, series[2].dur) |
	    SM(AR_TXC5_PACKET_DUR3, series[3].dur);

	/* Use the same Tx chains for all tries. */
	ds->ds_ctl7 =
	    SM(AR_TXC7_CHAIN_SEL0, sc->txchainmask) |
	    SM(AR_TXC7_CHAIN_SEL1, sc->txchainmask) |
	    SM(AR_TXC7_CHAIN_SEL2, sc->txchainmask) |
	    SM(AR_TXC7_CHAIN_SEL3, sc->txchainmask);
#ifdef notyet
#ifndef IEEE80211_NO_HT
	/* Use the same short GI setting for all tries. */
	if (ic->ic_flags & IEEE80211_F_SHGI)
		ds->ds_ctl7 |= AR_TXC7_GI0123;
	/* Use the same channel width for all tries. */
	if (ic->ic_flags & IEEE80211_F_CBW40)
		ds->ds_ctl7 |= AR_TXC7_2040_0123;
#endif
#endif

	if (ds->ds_ctl0 & (AR_TXC0_RTS_ENABLE | AR_TXC0_CTS_ENABLE)) {
		uint8_t protridx, hwrate;
		uint16_t dur = 0;

		/* Use the same protection mode for all tries. */
		if (ds->ds_ctl0 & AR_TXC0_RTS_ENABLE) {
			ds->ds_ctl4 |= AR_TXC4_RTSCTS_QUAL01;
			ds->ds_ctl5 |= AR_TXC5_RTSCTS_QUAL23;
		}
		/* Select protection rate (suboptimal but ok.) */
		protridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
		    ATHN_RIDX_OFDM6 : ATHN_RIDX_CCK2;
		if (ds->ds_ctl0 & AR_TXC0_RTS_ENABLE) {
			/* Account for CTS duration. */
			dur += athn_txtime(sc, IEEE80211_ACK_LEN,
			    athn_rates[protridx].rspridx, ic->ic_flags);
		}
		dur += athn_txtime(sc, totlen, ridx[0], ic->ic_flags);
		if (!(ds->ds_ctl1 & AR_TXC1_NO_ACK)) {
			/* Account for ACK duration. */
			dur += athn_txtime(sc, IEEE80211_ACK_LEN,
			    athn_rates[ridx[0]].rspridx, ic->ic_flags);
		}
		/* Write protection frame duration and rate. */
		ds->ds_ctl2 |= SM(AR_TXC2_BURST_DUR, dur);
		hwrate = athn_rates[protridx].hwrate;
		if (protridx == ATHN_RIDX_CCK2 &&
		    (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
			hwrate |= 0x04;
		ds->ds_ctl7 |= SM(AR_TXC7_RTSCTS_RATE, hwrate);
	}

	/* Finalize first Tx descriptor and fill others (if any.) */
	ds->ds_ctl0 |= SM(AR_TXC0_FRAME_LEN, totlen);

	for (i = 0; i < bf->bf_map->dm_nsegs; i++, ds++) {
		ds->ds_data = bf->bf_map->dm_segs[i].ds_addr;
		ds->ds_ctl1 |= SM(AR_TXC1_BUF_LEN,
		    bf->bf_map->dm_segs[i].ds_len);

		if (i != bf->bf_map->dm_nsegs - 1)
			ds->ds_ctl1 |= AR_TXC1_MORE;
		ds->ds_link = 0;

		/* Chain Tx descriptor. */
		if (i != 0)
			lastds->ds_link = bf->bf_daddr + i * sizeof (*ds);
		lastds = ds;
	}
	if (!SIMPLEQ_EMPTY(&txq->head))
		txq->lastds->ds_link = bf->bf_daddr;
	else
		AR_WRITE(sc, AR_QTXDP(qid), bf->bf_daddr);
	txq->lastds = lastds;
	SIMPLEQ_INSERT_TAIL(&txq->head, bf, bf_list);

	DPRINTFN(6, ("Tx qid=%d nsegs=%d ctl0=0x%x ctl1=0x%x ctl3=0x%x\n",
	    qid, bf->bf_map->dm_nsegs, bf->bf_descs[0].ds_ctl0,
	    bf->bf_descs[0].ds_ctl1, bf->bf_descs[0].ds_ctl3));

	bus_dmamap_sync(sc->sc_dmat, bf->bf_map, 0, bf->bf_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	/* Kick Tx. */
	AR_WRITE(sc, AR_Q_TXE, 1 << qid);
	return (0);
}

d1692 1
d1719 7
d1727 1
a1727 1
	/* Init CAB queue. */
d1743 4
a1753 102
athn_set_viterbi_mask(struct athn_softc *sc, int bin)
{
	uint32_t mask[4], reg;
	uint8_t m[62], p[62];	/* XXX use bit arrays? */
	int i, bit, cur;

	/* Compute pilot mask. */
	cur = -6000;
	for (i = 0; i < 4; i++) {
		mask[i] = 0;
		for (bit = 0; bit < 30; bit++) {
			if (abs(cur - bin) < 100)
				mask[i] |= 1 << bit;
			cur += 100;
		}
		if (cur == 0)	/* Skip entry "0". */
			cur = 100;
	}
	/* Write entries from -6000 to -3100. */
	AR_WRITE(sc, AR_PHY_TIMING7, mask[0]);
	AR_WRITE(sc, AR_PHY_TIMING9, mask[0]);
	/* Write entries from -3000 to -100. */
	AR_WRITE(sc, AR_PHY_TIMING8, mask[1]);
	AR_WRITE(sc, AR_PHY_TIMING10, mask[1]);
	/* Write entries from 100 to 3000. */
	AR_WRITE(sc, AR_PHY_PILOT_MASK_01_30, mask[2]);
	AR_WRITE(sc, AR_PHY_CHANNEL_MASK_01_30, mask[2]);
	/* Write entries from 3100 to 6000. */
	AR_WRITE(sc, AR_PHY_PILOT_MASK_31_60, mask[3]);
	AR_WRITE(sc, AR_PHY_CHANNEL_MASK_31_60, mask[3]);

	/* Compute viterbi mask. */
	for (cur = 6100; cur >= 0; cur -= 100)
		p[+cur / 100] = abs(cur - bin) < 75;
	for (cur = -100; cur >= -6100; cur -= 100)
		m[-cur / 100] = abs(cur - bin) < 75;

	/* Write viterbi mask (XXX needs to be reworked.) */
	reg =
	    m[46] << 30 | m[47] << 28 | m[48] << 26 | m[49] << 24 |
	    m[50] << 22 | m[51] << 20 | m[52] << 18 | m[53] << 16 |
	    m[54] << 14 | m[55] << 12 | m[56] << 10 | m[57] <<  8 |
	    m[58] <<  6 | m[59] <<  4 | m[60] <<  2 | m[61] <<  0;
	AR_WRITE(sc, AR_PHY_BIN_MASK_1, reg);
	AR_WRITE(sc, AR_PHY_VIT_MASK2_M_46_61, reg);

	/* XXX m[48] should be m[38] ? */
	reg =             m[31] << 28 | m[32] << 26 | m[33] << 24 |
	    m[34] << 22 | m[35] << 20 | m[36] << 18 | m[37] << 16 |
	    m[48] << 14 | m[39] << 12 | m[40] << 10 | m[41] <<  8 |
	    m[42] <<  6 | m[43] <<  4 | m[44] <<  2 | m[45] <<  0;
	AR_WRITE(sc, AR_PHY_BIN_MASK_2, reg);
	AR_WRITE(sc, AR_PHY_VIT_MASK2_M_31_45, reg);

	/* XXX This one is weird too. */
	reg =
	    m[16] << 30 | m[16] << 28 | m[18] << 26 | m[18] << 24 |
	    m[20] << 22 | m[20] << 20 | m[22] << 18 | m[22] << 16 |
	    m[24] << 14 | m[24] << 12 | m[25] << 10 | m[26] <<  8 |
	    m[27] <<  6 | m[28] <<  4 | m[29] <<  2 | m[30] <<  0;
	AR_WRITE(sc, AR_PHY_BIN_MASK_3, reg);
	AR_WRITE(sc, AR_PHY_VIT_MASK2_M_16_30, reg);

	reg =
	    m[ 0] << 30 | m[ 1] << 28 | m[ 2] << 26 | m[ 3] << 24 |
	    m[ 4] << 22 | m[ 5] << 20 | m[ 6] << 18 | m[ 7] << 16 |
	    m[ 8] << 14 | m[ 9] << 12 | m[10] << 10 | m[11] <<  8 |
	    m[12] <<  6 | m[13] <<  4 | m[14] <<  2 | m[15] <<  0;
	AR_WRITE(sc, AR_PHY_MASK_CTL, reg);
	AR_WRITE(sc, AR_PHY_VIT_MASK2_M_00_15, reg);

	reg =             p[15] << 28 | p[14] << 26 | p[13] << 24 |
	    p[12] << 22 | p[11] << 20 | p[10] << 18 | p[ 9] << 16 |
	    p[ 8] << 14 | p[ 7] << 12 | p[ 6] << 10 | p[ 5] <<  8 |
	    p[ 4] <<  6 | p[ 3] <<  4 | p[ 2] <<  2 | p[ 1] <<  0;
	AR_WRITE(sc, AR_PHY_BIN_MASK2_1, reg);
	AR_WRITE(sc, AR_PHY_VIT_MASK2_P_15_01, reg);

	reg =             p[30] << 28 | p[29] << 26 | p[28] << 24 |
	    p[27] << 22 | p[26] << 20 | p[25] << 18 | p[24] << 16 |
	    p[23] << 14 | p[22] << 12 | p[21] << 10 | p[20] <<  8 |
	    p[19] <<  6 | p[18] <<  4 | p[17] <<  2 | p[16] <<  0;
	AR_WRITE(sc, AR_PHY_BIN_MASK2_2, reg);
	AR_WRITE(sc, AR_PHY_VIT_MASK2_P_30_16, reg);

	reg =             p[45] << 28 | p[44] << 26 | p[43] << 24 |
	    p[42] << 22 | p[41] << 20 | p[40] << 18 | p[39] << 16 |
	    p[38] << 14 | p[37] << 12 | p[36] << 10 | p[35] <<  8 |
	    p[34] <<  6 | p[33] <<  4 | p[32] <<  2 | p[31] <<  0;
	AR_WRITE(sc, AR_PHY_BIN_MASK2_3, reg);
	AR_WRITE(sc, AR_PHY_VIT_MASK2_P_45_31, reg);

	reg =
	    p[61] << 30 | p[60] << 28 | p[59] << 26 | p[58] << 24 |
	    p[57] << 22 | p[56] << 20 | p[55] << 18 | p[54] << 16 |
	    p[53] << 14 | p[52] << 12 | p[51] << 10 | p[50] <<  8 |
	    p[49] <<  6 | p[48] <<  4 | p[47] <<  2 | p[46] <<  0;
	AR_WRITE(sc, AR_PHY_BIN_MASK2_4, reg);
	AR_WRITE(sc, AR_PHY_VIT_MASK2_P_61_46, reg);
}

void
a1820 16
athn_set_rf_mode(struct athn_softc *sc, struct ieee80211_channel *c)
{
	uint32_t reg;

	reg = IEEE80211_IS_CHAN_2GHZ(c) ?
	    AR_PHY_MODE_DYNAMIC : AR_PHY_MODE_OFDM;
	if (!AR_SREV_9280_10_OR_LATER(sc)) {
		reg |= IEEE80211_IS_CHAN_2GHZ(c) ?
		    AR_PHY_MODE_RF2GHZ : AR_PHY_MODE_RF5GHZ;
	} else if (AR_SREV_9280_20(sc) && 0 /* XXX */) {
		reg |= AR_PHY_MODE_DYNAMIC | AR_PHY_MODE_DYN_CCK_DISABLE;
	}
	AR_WRITE(sc, AR_PHY_MODE, reg);
}

void
d1872 1
d1876 2
a1918 96
athn_hw_init(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	struct athn_ops *ops = &sc->ops;
	const struct athn_ini *ini = sc->ini;
	const uint32_t *pvals;
	int i;

	AR_WRITE(sc, AR_PHY(0), 0x00000007);
	AR_WRITE(sc, AR_PHY_ADC_SERIAL_CTL, AR_PHY_SEL_EXTERNAL_RADIO);

	if (!AR_SINGLE_CHIP(sc))
		ar5416_reset_addac(sc, c);

	AR_WRITE(sc, AR_PHY_ADC_SERIAL_CTL, AR_PHY_SEL_INTERNAL_ADDAC);

	/* First initialization step (depends on channel band/bandwidth). */
#ifndef IEEE80211_NO_HT
	if (extc != NULL) {
		if (IEEE80211_IS_CHAN_2GHZ(c))
			pvals = ini->vals_2g40;
		else
			pvals = ini->vals_5g40;
	} else
#endif
	{
		if (IEEE80211_IS_CHAN_2GHZ(c))
			pvals = ini->vals_2g20;
		else
			pvals = ini->vals_5g20;
	}
	DPRINTFN(4, ("writing per-mode init vals\n"));
	for (i = 0; i < ini->nregs; i++) {
		AR_WRITE(sc, ini->regs[i], pvals[i]);
		if (AR_IS_ANALOG_REG(ini->regs[i]))
			DELAY(100);
		if ((i & 0x1f) == 0)
			DELAY(1);
	}

	if (AR_SREV_9280_20(sc) || AR_SREV_9287_10_OR_LATER(sc))
		ar9280_reset_rx_gain(sc, c);
	if (AR_SREV_9280_20(sc) || AR_SREV_9285_12(sc) ||
	    AR_SREV_9287_10_OR_LATER(sc))
		ar9280_reset_tx_gain(sc, c);

	/* Second initialization step (common to all channels). */
	DPRINTFN(4, ("writing common init vals\n"));
	for (i = 0; i < ini->ncmregs; i++) {
		AR_WRITE(sc, ini->cmregs[i], ini->cmvals[i]);
		if (AR_IS_ANALOG_REG(ini->cmregs[i]))
			DELAY(100);
		if ((i & 0x1f) == 0)
			DELAY(1);
	}

	if (!AR_SINGLE_CHIP(sc))
		ar5416_reset_bb_gain(sc, c);

	/*
	 * Set the RX_ABORT and RX_DIS bits to prevent frames with corrupted
	 * descriptor status.
	 */
	AR_SETBITS(sc, AR_DIAG_SW, AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT);

	/* Hardware workarounds for occasional Rx data corruption. */
	if (AR_SREV_9287_10_OR_LATER(sc))
		AR_CLRBITS(sc, AR_PCU_MISC_MODE2, AR_PCU_MISC_MODE2_HWWAR1);
	else if (AR_SREV_9280_10_OR_LATER(sc))
		AR_CLRBITS(sc, AR_PCU_MISC_MODE2, AR_PCU_MISC_MODE2_HWWAR1 |
		    AR_PCU_MISC_MODE2_HWWAR2);

	if (AR_SREV_5416_20_OR_LATER(sc) && !AR_SREV_9280_10_OR_LATER(sc)) {
		/* Disable baseband clock gating. */
		AR_WRITE(sc, AR_PHY(651), 0x11);

		if (AR_SREV_9160(sc)) {
			/* Disable RIFS search to fix baseband hang. */
			AR_CLRBITS(sc, AR_PHY_HEAVY_CLIP_FACTOR_RIFS,
			    AR_PHY_RIFS_INIT_DELAY_M);
		}
	}

	athn_set_phy(sc, c, extc);
	athn_init_chains(sc);

	if (sc->flags & ATHN_FLAG_OLPC)
		sc->ops.olpc_init(sc);

	ops->set_txpower(sc, c, extc);

	if (!AR_SINGLE_CHIP(sc))
		ar5416_rf_reset(sc, c);
}

void
d1961 1
a1961 1
	AR_WRITE(sc, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);
d1985 1
a1985 1
	athn_set_rf_mode(sc, c);
d1989 1
a1989 1
		reg = athn_gpio_read(sc, sc->rfsilent_pin);
d2005 1
a2005 1
		AR_SETBITS(sc, AR_GPIO_INPUT_EN_VAL, AR_GPIO_JTAG_DISABLE);
d2007 1
a2007 1
	if (AR_SREV_9287_12_OR_LATER(sc))
d2011 1
a2011 1
	athn_hw_init(sc, c, extc);
d2034 1
a2034 1
		athn_set_delta_slope(sc, c, extc);
d2076 2
d2090 6
d2111 1
a2111 1
	AR_WRITE(sc, AR_OBS, 8);
d2116 1
a2116 1
	athn_init_baseband(sc);
d2124 1
a2124 5
	if (sc->rxchainmask == 0x3 || sc->rxchainmask == 0x5) {
		/* XXX why again? */
		AR_WRITE(sc, AR_PHY_RX_CHAINMASK,  sc->rxchainmask);
		AR_WRITE(sc, AR_PHY_CAL_CHAINMASK, sc->rxchainmask);
	}
d2225 1
d2230 1
a2230 1
		athn_gpio_write(sc, sc->led_pin, 1);
d2237 2
a2238 2
		athn_gpio_write(sc, sc->led_pin,
		    !athn_gpio_read(sc, sc->led_pin));
d2252 1
a2252 1
		athn_gpio_write(sc, sc->led_pin, 0);
d2360 1
a2360 1
		if (athn_tx(sc, m, ni) != 0) {
d2512 1
d2545 1
a2545 2
	AR_SETBITS(sc, AR_PHY_CCK_DETECT,
	    AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);
d2558 1
a2558 1
		athn_rfsilent_init(sc);
@


1.35
log
@fix athn_stop_tx_dma
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.34 2010/04/10 10:59:12 damien Exp $	*/
a27 1
#include <sys/sysctl.h>
@


1.34
log
@always do a full reset when changing the channel on AR5008 devices,
until i figure out why TX sometimes gets stucked.
a full reset was already necessary on AR9280 devices, so there is
no change for these devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.33 2010/04/07 16:31:16 damien Exp $	*/
d2875 1
a2875 1
			if (AR_READ(sc, AR_TSF_L32) / 1024 != tsflo)
@


1.33
log
@txq->lastds is only valid when txq is not empty.
Check for emptiness of the TX queue instead of lastds != NULL.

I have a feeling this might fix the "device timeout" issues reported
by Rivo Nurges on his AR5418 unveiled by athn.c r1.28 commit, though
he is not around to confirm.

This is a candidate for -stable.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.32 2010/04/07 16:19:33 damien Exp $	*/
d1284 1
a1284 1
	if (AR_SREV_9280(sc))
@


1.32
log
@update initvals and TX gains for AR9285 >=1.2
check result of carrier leakage calibration and redo calibration if needed
add support for newer AR9285 chips (AR9285 XE 2.0).

tested for non-regression on a DNXA-95
"Still seems to work here" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.31 2010/04/05 19:09:00 damien Exp $	*/
d3608 1
a3608 1
	if (txq->lastds != NULL)
@


1.31
log
@backout these two files i committed by accident.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.29 2010/03/28 13:02:57 krw Exp $	*/
a244 3
	/* We can put the chip in sleep state now. */
	athn_set_power_sleep(sc);

d252 1
d254 2
a255 1
	sc->ops.setup(sc);
@


1.30
log
@fix regression on RT2860C introduced in previous commit.
@
text
@d2087 1
a2087 1
 * Adaptive noise immunity.
a3922 1
printf("%s IMR_S2=0x%08x\n", __func__, mask2);
d3953 1
a3953 5
{
uint32_t tmp;
tmp = AR_READ(sc, AR_IMR_S2);
printf("%s IMR_S2=0x%08x\n", __func__, tmp);
tmp &= ~(AR_IMR_S2_TIM | AR_IMR_S2_DTIM |
a3955 5
AR_WRITE(sc, AR_IMR_S2, tmp);
/*	AR_CLRBITS(sc, AR_IMR_S2, AR_IMR_S2_TIM | AR_IMR_S2_DTIM |
	    AR_IMR_S2_DTIMSYNC | AR_IMR_S2_CABEND | AR_IMR_S2_CABTO |
	    AR_IMR_S2_TSFOOR | AR_IMR_S2_GTT | AR_IMR_S2_CST);*/
}
d4219 1
a4219 5
reg = AR_READ(sc, AR_IMR_S2);
printf("%s AR_IMR_S2=0x%08x\n", __func__, reg);
reg |= AR_IMR_S2_GTT;
AR_WRITE(sc, AR_IMR_S2, reg);
//	AR_SETBITS(sc, AR_IMR_S2, AR_IMR_S2_GTT);
@


1.29
log
@Four uses of uninitialized variables found by clang via jsg@@. ar5416, ar9287
and athn are only theoretically interesting. i33380211_node fixes a real
bug in occupied channel detection.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.28 2010/02/24 20:09:19 damien Exp $	*/
d2087 1
a2087 1
 * Anti-noise immunity.
d3923 1
d3954 5
a3958 1
	AR_CLRBITS(sc, AR_IMR_S2, AR_IMR_S2_TIM | AR_IMR_S2_DTIM |
d3961 5
d4229 5
a4233 1
	AR_SETBITS(sc, AR_IMR_S2, AR_IMR_S2_GTT);
@


1.28
log
@- properly maintain sc->curchan
- return 1 in athn_intr for the gpio intr too
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.27 2010/02/24 19:39:43 damien Exp $	*/
d2570 1
@


1.27
log
@Disable Reduced Interframe Space search on AR9160 to workaround
baseband issues.
It would be cleaner to modify directly the initvals for AR9160 but
I want to keep the exact same initvals as the Linux ath9k driver.

from ath9k
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.26 2010/02/21 19:57:05 kettenis Exp $	*/
d856 1
a856 1
			return (0);
d4199 1
a4199 2
	error = ops->set_synth(sc, c, extc);
	if (error != 0) {
d4203 2
d4648 2
a4649 2
	c = sc->curchan = ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	extc = sc->curchanext = NULL;
@


1.26
log
@Make sure athn_intr() returns 1 if it claims an interrupt and 0 if not,
instead of the other way around.  Fixes interrupt accounting.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.25 2010/02/16 18:49:31 damien Exp $	*/
d4035 6
@


1.25
log
@fix AR_DTIM_PERIOD
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.24 2010/02/15 17:16:36 damien Exp $	*/
d786 1
a786 1
		return (1);
d793 1
a793 1
			return (1);	/* Not for us. */
d803 1
a803 1
		return (1);	/* Not for us. */
d815 1
a815 1
			return (0);
d862 1
a862 1
	return (0);
@


1.24
log
@Properly detect when the band changes from 2GHz to 5GHz and
vice-versa, and do a full reset of the chip when it happens.
This does not affect the AR9280 since a full reset is always
necessary when the channel changes.

Should fix dual-band AR5416 devices (problem reported by Rivo Nurges).
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.23 2010/02/15 17:00:41 damien Exp $	*/
d3839 1
a3839 1
	AR_WRITE(sc, AR_DTIM_PERIOD, dtim_period * IEEE80211_DUR_TU);
@


1.23
log
@- handle SIOCS80211CHANNEL in monitor mode without doing a full reset
- call athn_set_multi on SIOCADDMULTI/SIOCDELMULTI
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.22 2010/01/27 18:26:45 damien Exp $	*/
d1236 3
a1261 1
	struct ieee80211com *ic = &sc->sc_ic;
d1289 2
a1290 1
	if (c->ic_flags != ic->ic_bss->ni_chan->ic_flags) {
d4641 2
a4642 2
	c = ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	extc = NULL;
@


1.22
log
@change the MRR pattern from 1/1/1/1 to 2/2/2/4
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.21 2009/12/05 23:10:33 jsg Exp $	*/
a4591 1
		/* XXX Update hardware multicast filter. */
d4596 2
a4597 1
		if (error == ENETRESET)
d4599 12
@


1.21
log
@Use the correct member of the ieee80211com struct when testing
if the current mode is 802.11a or 802.11b.

found by gcc svn.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.20 2009/11/25 19:53:37 damien Exp $	*/
d3193 2
a3194 2
	/* XXX Assume one single try per series. */
	failcnt += MS(ds->ds_status9, AR_TXS9_FINAL_IDX);
a3497 1
		series[i].tries = 1;	/* XXX more for last. */
d3515 4
a3518 4
	    SM(AR_TXC2_XMIT_DATA_TRIES0, series[0].tries) |
	    SM(AR_TXC2_XMIT_DATA_TRIES1, series[1].tries) |
	    SM(AR_TXC2_XMIT_DATA_TRIES2, series[2].tries) |
	    SM(AR_TXC2_XMIT_DATA_TRIES3, series[3].tries);
@


1.20
log
@fix previous
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.19 2009/11/25 17:54:37 damien Exp $	*/
d4430 1
a4430 1
	if (ic->ic_opmode == IEEE80211_MODE_11B)
d4432 1
a4432 1
	else if (ic->ic_opmode == IEEE80211_MODE_11A)
@


1.19
log
@single-stream parts (AR9285) have a hardware bug that limits the
usable size of the PCU TX FIFO to 2KB even though the hardware
has 4KB.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.18 2009/11/23 19:54:54 damien Exp $	*/
d2807 1
a2807 1
	if (ftrig == AR_SREV_9285(sc) ? 0x1f : 0x3f)
@


1.18
log
@prevent interrupts storm when the radio switch is turned off while
the interface is up and running by properly clearing the condition.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.17 2009/11/23 19:11:06 damien Exp $	*/
d270 1
a270 1
		DPRINTFN(2, ("Found RF switch connected to GPIO pin %d\n",
d2799 1
a2799 1
	uint32_t reg;
a2800 1
	/* XXX Disable interrupts? */
d2802 8
a2809 3
	if ((reg & 0x3f0) == 0x3f0)	/* Already at max. */
		return;
	reg += 0x10;	/* Increment Tx trigger level by 1. */
d4352 1
a4352 1
	if (ic->ic_state != IEEE80211_S_SCAN)
@


1.17
log
@move things from athn_attach() to athn_init() such that we can
power off the cardbus slot after athn_attach() and in athn_stop().
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.16 2009/11/23 18:42:50 damien Exp $	*/
d4730 3
@


1.16
log
@cleanup athn_set_key (not used yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.15 2009/11/23 17:14:50 damien Exp $	*/
d79 1
d204 1
a204 1
	int i, error;
d245 3
d261 2
a262 1
	if (base->rfSilent & AR_EEP_RFSILENT_ENABLED)
d264 9
a321 19
	/* Reset HW key cache entries (XXX not here.) */
	for (i = 0; i < sc->kc_entries; i++)
		athn_reset_key(sc, i);

	/* XXX not here. */
	AR_SETBITS(sc, AR_PHY_CCK_DETECT,
	    AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);

#ifdef ATHN_BT_COEXISTENCE
	/* Initialize bluetooth coexistence for combo chips. */
	if (sc->flags & ATHN_FLAG_BTCOEX)
		athn_btcoex_init(sc);
#endif

	athn_gpio_config_output(sc, sc->led_pin,
	    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
	/* LED off, active low. */
	athn_gpio_write(sc, sc->led_pin, 1);

d1603 8
a1711 1
	struct ar_base_eep_header *base = sc->eep;
a1713 8
	/* Get GPIO pin used by hardware radio switch. */
	sc->rfsilent_pin = MS(base->rfSilent, AR_EEP_RFSILENT_GPIO_SEL);
	/* Get polarity of hardware radio switch. */
	if (base->rfSilent & AR_EEP_RFSILENT_POLARITY)
		sc->flags |= ATHN_FLAG_RFSILENT_REVERSED;
	DPRINTFN(2, ("Found RF switch connected to GPIO pin %d\n",
	    sc->rfsilent_pin));

a4111 4
	/* XXX move to attach? */
	if (sc->flags & ATHN_FLAG_RFSILENT)
		athn_rfsilent_init(sc);

d4621 1
a4621 1
	int error;
a4628 1
#ifdef notyet
d4642 16
d4660 6
a4665 2
	if (sc->flags & ATHN_FLAG_PCIE)
		athn_config_pcie(sc);
a4753 1
#ifdef notyet
a4756 1
#endif
@


1.15
log
@remove a global that i used to test protection modes.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.14 2009/11/22 08:52:45 damien Exp $	*/
d268 1
d270 1
a270 1
	ic->ic_max_nnodes = sc->kc_entries;	/* XXX MIC. */
d1505 1
a1505 1
	uint32_t keybuf[4], micbuf[4];
d1530 3
a1532 1
	if (k->k_flags & IEEE80211_KEY_GROUP)
a1533 2
	else
		entry = IEEE80211_AID(ni->ni_associd);	/* XXX +offset. */
d1541 7
a1547 5
		AR_WRITE(sc, AR_KEYTABLE_KEY0(micentry), micbuf[0]);
		AR_WRITE(sc, AR_KEYTABLE_KEY1(micentry), micbuf[1]);

		AR_WRITE(sc, AR_KEYTABLE_KEY2(micentry), micbuf[2]);
		AR_WRITE(sc, AR_KEYTABLE_KEY3(micentry), micbuf[3]);
d1549 2
a1550 1
		AR_WRITE(sc, AR_KEYTABLE_KEY4(micentry), micbuf[4]);
d1557 7
a1563 2
		AR_WRITE(sc, AR_KEYTABLE_KEY0(entry), keybuf[0]);
		AR_WRITE(sc, AR_KEYTABLE_KEY1(entry), keybuf[1]);
d1565 2
a1566 4
		AR_WRITE(sc, AR_KEYTABLE_KEY2(entry), keybuf[2]);
		AR_WRITE(sc, AR_KEYTABLE_KEY3(entry), keybuf[3]);

		AR_WRITE(sc, AR_KEYTABLE_KEY4(entry), keybuf[4]);
d1574 8
a1581 6
	/* XXX Group keys? */
	addr = ni->ni_macaddr;
	lo = addr[0] | addr[1] << 8 | addr[2] << 16 | addr[3] << 24;
	hi = addr[4] | addr[5] << 8;
	lo = lo >> 1 | hi << 31;
	hi = hi >> 1;
@


1.14
log
@fix RTS/CTS and CTS-to-self protection modes.
fix 802.11a TXTIME computation (802.11a has a 16us SIFS interval
but does not have the 6us signal extension that ERP-OFDM has so
we can use the same code for 11a and 11g provided that we add
the SIFS nterval in the athn_txtime() function itself.)
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.11 2009/11/19 19:19:59 damien Exp $	*/
a3260 2

int athn_prot = 0;
@


1.13
log
@make the led blink during a scan.

prodded by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.12 2009/11/21 15:17:46 damien Exp $	*/
a1384 2
	/* Set Short Interframe Space. */
	sc->sifs = IEEE80211_IS_CHAN_5GHZ(c) ? 16 : 10;
d3248 2
a3249 1
		txtime = 16 + 4 + 4 * txtime + 6;
d3256 1
d3262 2
d3480 1
a3480 1
		    ATHN_IS_OFDM_RIDX(ridx[0])) {
d3487 4
a3490 1

d3505 1
a3505 1
			    ridx[i], ic->ic_flags) + sc->sifs;
d3553 3
d3561 14
d3576 6
a3581 4
		ds->ds_ctl2 |= SM(AR_TXC2_BURST_DUR, 0 /* XXX */);
		ds->ds_ctl7 |= SM(AR_TXC7_RTSCTS_RATE,
		    athn_rates[0].hwrate /* XXX */);
		/* XXX short preamble. */
d4286 1
d4297 1
a4297 12
#if 0
		/* Compute rate for protection frames. */
		an->ctlridx[i] = athn_rates[ridx].ctlridx;
		for (j = i; j >= 0; j--) {
			if ((rs->rs_rates[j] & IEEE80211_RATE_BASIC) &&
			    athn_rates[an->ridx[j]].phy ==
			    athn_rates[an->ridx[i]].phy) {
				an->ctlridx[i] = an->ridx[j];
				break;
			}
		}
#endif
@


1.12
log
@debug off

reminded by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.11 2009/11/19 19:19:59 damien Exp $	*/
d4337 1
a4337 1
	if (ic->ic_state == IEEE80211_S_RUN)
d4344 3
@


1.11
log
@if a radio switch exists, configure the GPIO pin to which it is
connected to raise an interrupt when the pin goes low (or high
depending on the polarity of the radio switch.)
turn the interface down when the interrupt occurs.
this is the same behaviour as in wpi(4) and iwn(4).

cleanup interrupts processing while i'm here.
remove ATHN_INTR_MITIGATION compile option (it is set by default.)
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.10 2009/11/17 20:38:29 damien Exp $	*/
d67 1
a67 1
int athn_debug = 1;
@


1.10
log
@fix a DPRINTF format string.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.9 2009/11/17 19:32:22 damien Exp $	*/
d794 1
a794 1
	if ((intr & AR_INTR_MAC_IRQ) == 0 || intr == AR_INTR_SPURIOUS) {
d796 1
a796 2
		if (intr == AR_INTR_SPURIOUS ||
		    (intr & AR_INTR_SYNC_DEFAULT) == 0)
d800 1
a800 1
	if ((AR_READ(sc, AR_INTR_ASYNC_CAUSE) & AR_INTR_MAC_IRQ) != 0 &&
d805 1
a805 1
	sync = AR_READ(sc, AR_INTR_SYNC_CAUSE) & AR_INTR_SYNC_DEFAULT;
d853 10
d1720 4
d3196 1
a3196 1
	DPRINTFN(6, ("Tx done qid=%d status1=%d fail count=%d\n",
d3230 1
a3230 1
	DPRINTFN(5, ("Tx interrupt mask=0x%x\n", mask));
d3584 1
a3584 1
	DPRINTFN(4, ("Tx qid=%d nsegs=%d ctl0=0x%x ctl1=0x%x ctl3=0x%x\n",
d3886 2
a3887 6
	    AR_IMR_RXORN | AR_IMR_GENTMR | AR_IMR_BCNMISC;
#ifndef ATHN_INTR_MITIGATION
	mask |= AR_IMR_RXOK | AR_IMR_RXDESC;
#else
	mask |= AR_IMR_RXMINTR | AR_IMR_RXINTM;
#endif
d3892 1
a3892 2
	    AR_IMR_S2_CABEND | AR_IMR_S2_CABTO | AR_IMR_S2_TSFOOR |
	    AR_IMR_S2_GTT | AR_IMR_S2_CST);
d3903 2
a3904 2
	AR_WRITE(sc, AR_INTR_SYNC_ENABLE, AR_INTR_SYNC_DEFAULT);
	AR_WRITE(sc, AR_INTR_SYNC_MASK, AR_INTR_SYNC_DEFAULT);
d4178 1
d4181 1
a4181 2
		AR_WRITE(sc, AR_IMR, AR_IMR_HOSTAP);
	else
d4183 1
a4183 1
		AR_WRITE(sc, AR_IMR, AR_IMR_DEFAULT);
d4186 4
a4189 1
	AR_WRITE(sc, AR_INTR_SYNC_ENABLE, AR_INTR_SYNC_DEFAULT);
a4207 1
#ifdef ATHN_INTR_MITIGATION
a4209 1
#endif
@


1.9
log
@cleanup the printf/DPRINTF mess.
use proper debug levels for diagnostic messages such that we don't
spam the logs when athn_debug is low.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.8 2009/11/17 18:46:35 damien Exp $	*/
d1701 1
a1701 1
	DPRINTFN(2, ("%s: Found RF switch connected to GPIO pin %d\n",
@


1.8
log
@fix previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.7 2009/11/17 18:21:07 damien Exp $	*/
d67 1
a67 1
int athn_debug = 4;
d1283 1
a1283 1
		DPRINTF(("channel band switch\n"));
d1293 1
a1293 1
		DPRINTF(("needs a full reset\n"));
d1701 2
a1702 2
	printf("%s: Found RF switch connected to GPIO pin %d\n",
	    sc->sc_dev.dv_xname, sc->rfsilent_pin);
d1828 1
a1828 1
		DPRINTF(("IQ calibration for chain %d\n", i));
d1872 1
a1872 1
		DPRINTF(("ADC gain calibration for chain %d\n", i));
d1916 1
a1916 1
		DPRINTF(("ADC DC offset calibration for chain %d\n", i));
d3952 1
a3952 1
	DPRINTF(("writing per-mode init vals\n"));
d3968 1
a3968 1
	DPRINTF(("writing common init vals\n"));
@


1.7
log
@update hardware multicast filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.6 2009/11/17 18:01:40 damien Exp $	*/
d4514 1
a4514 1
		bit  = (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ (val & 0x3f);
d4516 2
a4517 1
		bit ^= (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ (val & 0x3f);
@


1.6
log
@add short interframe space to duration since the athn_txtime
function does not take it into account. oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.5 2009/11/16 17:09:31 damien Exp $	*/
d163 1
d4488 40
d4550 5
a4554 1
			if (!(ifp->if_flags & IFF_RUNNING))
d4560 1
@


1.5
log
@it is better if it compiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.4 2009/11/16 17:08:14 damien Exp $	*/
d1375 2
d3486 1
a3486 1
			    ridx[i], ic->ic_flags);
@


1.4
log
@do not panic when wep is enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.3 2009/11/15 14:04:02 damien Exp $	*/
d4549 1
a4549 1
	int i, error;
@


1.3
log
@AR9287 uses GPIO pin 8 for LED, not 1.
Turn link LED on while associated.
@
text
@d1 1
a1 1
/*	$OpenBSD: athn.c,v 1.2 2009/11/15 10:25:27 damien Exp $	*/
d4597 1
d4603 1
a4603 1

@


1.2
log
@fix athn_stop_tx_dma().
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d320 1
a320 1
	athn_gpio_config_output(sc, AR_GPIO_LED_PIN,
d323 1
a323 1
	athn_gpio_write(sc, AR_GPIO_LED_PIN, 1);
d4325 2
d4345 2
@


1.1
log
@athn(4), a driver for Atheros 802.11a/g/n devices.
written from scratch based on the vendor driver for Linux (ath9k).
AR9285 and AR9287 parts are 100% untested.
only basic functionnalities are enabled for now.

committed over an AR9281.

"commit" deraadt
@
text
@d2839 1
a2839 1
		if (athn_tx_pending(sc, qid))
d2859 1
a2859 1
			if (athn_tx_pending(sc, qid))
@

