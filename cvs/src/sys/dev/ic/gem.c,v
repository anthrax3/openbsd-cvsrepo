head	1.121;
access;
symbols
	OPENBSD_6_1:1.121.0.4
	OPENBSD_6_1_BASE:1.121
	OPENBSD_6_0:1.120.0.4
	OPENBSD_6_0_BASE:1.120
	OPENBSD_5_9:1.119.0.2
	OPENBSD_5_9_BASE:1.119
	OPENBSD_5_8:1.112.0.4
	OPENBSD_5_8_BASE:1.112
	OPENBSD_5_7:1.110.0.2
	OPENBSD_5_7_BASE:1.110
	OPENBSD_5_6:1.105.0.4
	OPENBSD_5_6_BASE:1.105
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.100.0.2
	OPENBSD_5_4_BASE:1.100
	OPENBSD_5_3:1.98.0.2
	OPENBSD_5_3_BASE:1.98
	OPENBSD_5_2:1.96.0.10
	OPENBSD_5_2_BASE:1.96
	OPENBSD_5_1_BASE:1.96
	OPENBSD_5_1:1.96.0.12
	OPENBSD_5_0:1.96.0.8
	OPENBSD_5_0_BASE:1.96
	OPENBSD_4_9:1.96.0.6
	OPENBSD_4_9_BASE:1.96
	OPENBSD_4_8:1.96.0.4
	OPENBSD_4_8_BASE:1.96
	OPENBSD_4_7:1.96.0.2
	OPENBSD_4_7_BASE:1.96
	OPENBSD_4_6:1.90.0.4
	OPENBSD_4_6_BASE:1.90
	OPENBSD_4_5:1.87.0.2
	OPENBSD_4_5_BASE:1.87
	OPENBSD_4_4:1.75.0.2
	OPENBSD_4_4_BASE:1.75
	OPENBSD_4_3:1.73.0.2
	OPENBSD_4_3_BASE:1.73
	OPENBSD_4_2:1.69.0.2
	OPENBSD_4_2_BASE:1.69
	OPENBSD_4_1:1.68.0.2
	OPENBSD_4_1_BASE:1.68
	OPENBSD_4_0:1.59.0.2
	OPENBSD_4_0_BASE:1.59
	OPENBSD_3_9:1.56.0.2
	OPENBSD_3_9_BASE:1.56
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.28
	UBC:1.13.0.2
	UBC_BASE:1.13
	SMP:1.11.0.4
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11;
locks; strict;
comment	@ * @;


1.121
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.120;
commitid	VyLWTsbepAOk7VQM;

1.120
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.119;
commitid	QHiEhS9DHyE6oiIr;

1.119
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.118;
commitid	J9apD0jq2AjFmqZc;

1.118
date	2015.11.28.09.42.10;	author jmatthew;	state Exp;
branches;
next	1.117;
commitid	H1hUCw2u7OaGgYvP;

1.117
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.116;
commitid	B0kwmVGiD5DVx4kv;

1.116
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.115;
commitid	5gdEnqVoJuTuwdTu;

1.115
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.114;
commitid	eYnPulzvLjDImPCa;

1.114
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.113;
commitid	p0v5tuE1Ch6fY0Nj;

1.113
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.112;
commitid	6vhYvh5CxZAHMnsN;

1.112
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.111;
commitid	MVWrtktB46JRxFWT;

1.111
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.110;
commitid	p4LJxGKbi0BU2cG6;

1.110
date	2015.02.09.03.09.57;	author dlg;	state Exp;
branches;
next	1.109;
commitid	fE9MPAUoNdw8sZYO;

1.109
date	2015.02.08.06.02.03;	author mpi;	state Exp;
branches;
next	1.108;
commitid	BHezNZDDrirlVJCp;

1.108
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.107;
commitid	yM2VFFhpDTeFQlve;

1.107
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.106;
commitid	LS2TNeCue5R9L67C;

1.106
date	2014.08.27.05.54.15;	author dlg;	state Exp;
branches;
next	1.105;
commitid	j0Qurj94awT2fZ1K;

1.105
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.104;
commitid	TGHgrLxu6sxZoiFt;

1.104
date	2014.07.08.05.35.18;	author dlg;	state Exp;
branches;
next	1.103;
commitid	0QJleeeWqZmC5anF;

1.103
date	2014.04.22.15.52.05;	author naddy;	state Exp;
branches;
next	1.102;

1.102
date	2014.03.14.11.04.24;	author dlg;	state Exp;
branches;
next	1.101;

1.101
date	2013.08.08.16.01.34;	author kettenis;	state Exp;
branches;
next	1.100;

1.100
date	2013.07.25.19.50.56;	author kettenis;	state Exp;
branches;
next	1.99;

1.99
date	2013.03.09.17.57.00;	author mpi;	state Exp;
branches;
next	1.98;

1.98
date	2012.12.01.10.04.58;	author brad;	state Exp;
branches;
next	1.97;

1.97
date	2012.10.22.05.05.57;	author brad;	state Exp;
branches;
next	1.96;

1.96
date	2009.10.15.17.54.54;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2009.08.09.11.40.58;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2009.08.03.11.09.10;	author sthen;	state Exp;
branches;
next	1.92;

1.92
date	2009.07.18.14.42.47;	author sthen;	state Exp;
branches;
next	1.91;

1.91
date	2009.07.18.12.56.16;	author sthen;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.29.11.53.47;	author kettenis;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.22.21.46.31;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2009.03.20.23.29.47;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2009.01.27.09.17.51;	author dlg;	state Exp;
branches;
next	1.86;

1.86
date	2008.12.14.21.31.50;	author kettenis;	state Exp;
branches;
next	1.85;

1.85
date	2008.12.10.20.37.48;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2008.11.26.18.34.31;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2008.11.07.18.03.52;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2008.11.07.18.00.31;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2008.11.07.17.37.59;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.77;

1.77
date	2008.08.30.07.39.12;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2008.08.26.21.06.29;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2008.05.31.02.41.25;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.09.21.22.44;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.10.16.54.23;	author kettenis;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.08.15.03.36;	author thib;	state Exp;
branches;
next	1.71;

1.71
date	2008.01.11.22.50.18;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2007.09.30.11.33.14;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.19.19.00.01;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2006.12.21.22.13.36;	author jason;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.25.17.47.40;	author brad;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.25.04.52.49;	author brad;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.25.02.12.04;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.25.00.26.07;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.11.00.23.21;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.10.23.58.47;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.10.23.56.36;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2006.10.17.22.22.49;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2006.07.11.00.52.38;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.15.04.10.06;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2006.02.21.19.46.52;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2006.02.21.19.34.48;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2006.02.08.22.11.02;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2006.02.05.00.24.26;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.15.19.20.25;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.07.03.20.00;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.02.02.15.12;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.02.00.45.15;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.31.23.53.13;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.31.18.38.35;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.17.03.03.24;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.11.23.58.36;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.10.20.42.32;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2005.08.01.05.45.03;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.02.23.10.16;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.06.08.17.02.59;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.27.23.59.27;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.20.20.50.41;	author pvalchev;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.02.08.40.48;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.01.07.00.25;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.29.23.06.55;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.15.03.52.30;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.09.18.21.45;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.02.02.59.10;	author henric;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.23.22.55.52;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.26.06.01.27;	author nate;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.22.15.56.17;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.28.11.05.02;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.10.18.08.13;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.09.03.38.40;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.07.23.44.05;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.07.20.44.41;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.03.15.33.07;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.22.05.41.55;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.22.20.29.09;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.22.20.15.28;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.28.01.04.02;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.25.16.51.57;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.13.03.51.10;	author drahn;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.03.18.18.01;	author jason;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.10.02.15.24.09;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.29.16.43.15;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.28.13.09.06;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.24.15.54.41;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.23.20.03.01;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.21.22.27.51;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.21.22.00.42;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.21.21.35.53;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.21.21.26.31;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.21.00.01.20;	author art;	state Exp;
branches;
next	;

1.11.4.1
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.11.4.4;

1.11.4.4
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.11.4.5;

1.11.4.5
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.11.4.6;

1.11.4.6
date	2003.05.13.19.35.00;	author ho;	state Exp;
branches;
next	1.11.4.7;

1.11.4.7
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.121
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: gem.c,v 1.120 2016/04/13 10:49:26 mpi Exp $	*/
/*	$NetBSD: gem.c,v 1.1 2001/09/16 00:11:43 eeh Exp $ */

/*
 *
 * Copyright (C) 2001 Eduardo Horvath.
 * All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Driver for Sun GEM ethernet controllers.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/endian.h>
#include <sys/atomic.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/ic/gemreg.h>
#include <dev/ic/gemvar.h>

#define TRIES	10000

struct cfdriver gem_cd = {
	NULL, "gem", DV_IFNET
};

void		gem_start(struct ifnet *);
void		gem_stop(struct ifnet *, int);
int		gem_ioctl(struct ifnet *, u_long, caddr_t);
void		gem_tick(void *);
void		gem_watchdog(struct ifnet *);
int		gem_init(struct ifnet *);
void		gem_init_regs(struct gem_softc *);
int		gem_ringsize(int);
int		gem_meminit(struct gem_softc *);
void		gem_mifinit(struct gem_softc *);
int		gem_bitwait(struct gem_softc *, bus_space_handle_t, int,
		    u_int32_t, u_int32_t);
void		gem_reset(struct gem_softc *);
int		gem_reset_rx(struct gem_softc *);
int		gem_reset_tx(struct gem_softc *);
int		gem_disable_rx(struct gem_softc *);
int		gem_disable_tx(struct gem_softc *);
void		gem_rx_watchdog(void *);
void		gem_rxdrain(struct gem_softc *);
void		gem_fill_rx_ring(struct gem_softc *);
int		gem_add_rxbuf(struct gem_softc *, int idx);
int		gem_load_mbuf(struct gem_softc *, struct gem_sxd *,
		    struct mbuf *);
void		gem_iff(struct gem_softc *);

/* MII methods & callbacks */
int		gem_mii_readreg(struct device *, int, int);
void		gem_mii_writereg(struct device *, int, int, int);
void		gem_mii_statchg(struct device *);
int		gem_pcs_readreg(struct device *, int, int);
void		gem_pcs_writereg(struct device *, int, int, int);

int		gem_mediachange(struct ifnet *);
void		gem_mediastatus(struct ifnet *, struct ifmediareq *);

int		gem_eint(struct gem_softc *, u_int);
int		gem_rint(struct gem_softc *);
int		gem_tint(struct gem_softc *, u_int32_t);
int		gem_pint(struct gem_softc *);

#ifdef GEM_DEBUG
#define	DPRINTF(sc, x)	if ((sc)->sc_arpcom.ac_if.if_flags & IFF_DEBUG) \
				printf x
#else
#define	DPRINTF(sc, x)	/* nothing */
#endif

/*
 * Attach a Gem interface to the system.
 */
void
gem_config(struct gem_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mii_data *mii = &sc->sc_mii;
	struct mii_softc *child;
	int i, error, mii_flags, phyad;
	struct ifmedia_entry *ifm;

	/* Make sure the chip is stopped. */
	ifp->if_softc = sc;
	gem_reset(sc);

	/*
	 * Allocate the control data structures, and create and load the
	 * DMA map for it.
	 */
	if ((error = bus_dmamem_alloc(sc->sc_dmatag,
	    sizeof(struct gem_control_data), PAGE_SIZE, 0, &sc->sc_cdseg,
	    1, &sc->sc_cdnseg, 0)) != 0) {
		printf("\n%s: unable to allocate control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_0;
	}

	/* XXX should map this in with correct endianness */
	if ((error = bus_dmamem_map(sc->sc_dmatag, &sc->sc_cdseg, sc->sc_cdnseg,
	    sizeof(struct gem_control_data), (caddr_t *)&sc->sc_control_data,
	    BUS_DMA_COHERENT)) != 0) {
		printf("\n%s: unable to map control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_1;
	}

	if ((error = bus_dmamap_create(sc->sc_dmatag,
	    sizeof(struct gem_control_data), 1,
	    sizeof(struct gem_control_data), 0, 0, &sc->sc_cddmamap)) != 0) {
		printf("\n%s: unable to create control data DMA map, "
		    "error = %d\n", sc->sc_dev.dv_xname, error);
		goto fail_2;
	}

	if ((error = bus_dmamap_load(sc->sc_dmatag, sc->sc_cddmamap,
	    sc->sc_control_data, sizeof(struct gem_control_data), NULL,
	    0)) != 0) {
		printf("\n%s: unable to load control data DMA map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_3;
	}

	/*
	 * Create the receive buffer DMA maps.
	 */
	for (i = 0; i < GEM_NRXDESC; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &sc->sc_rxsoft[i].rxs_dmamap)) != 0) {
			printf("\n%s: unable to create rx DMA map %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_5;
		}
		sc->sc_rxsoft[i].rxs_mbuf = NULL;
	}
	/*
	 * Create the transmit buffer DMA maps.
	 */
	for (i = 0; i < GEM_NTXDESC; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmatag, MCLBYTES,
		    GEM_NTXSEGS, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->sc_txd[i].sd_map)) != 0) {
			printf("\n%s: unable to create tx DMA map %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_6;
		}
		sc->sc_txd[i].sd_mbuf = NULL;
	}

	/*
	 * From this point forward, the attachment cannot fail.  A failure
	 * before this point releases all resources that may have been
	 * allocated.
	 */

	/* Announce ourselves. */
	printf(", address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/* Get RX FIFO size */
	sc->sc_rxfifosize = 64 *
	    bus_space_read_4(sc->sc_bustag, sc->sc_h1, GEM_RX_FIFO_SIZE);

	/* Initialize ifnet structure. */
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
	ifp->if_softc = sc;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_start = gem_start;
	ifp->if_ioctl = gem_ioctl;
	ifp->if_watchdog = gem_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, GEM_NTXDESC - 1);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Initialize ifmedia structures and MII info */
	mii->mii_ifp = ifp;
	mii->mii_readreg = gem_mii_readreg;
	mii->mii_writereg = gem_mii_writereg;
	mii->mii_statchg = gem_mii_statchg;

	ifmedia_init(&mii->mii_media, 0, gem_mediachange, gem_mediastatus);

	/* Bad things will happen if we touch this register on ERI. */
	if (sc->sc_variant != GEM_SUN_ERI)
		bus_space_write_4(sc->sc_bustag, sc->sc_h1,
		    GEM_MII_DATAPATH_MODE, 0);

	gem_mifinit(sc);

	mii_flags = MIIF_DOPAUSE;

	/* 
	 * Look for an external PHY.
	 */
	if (sc->sc_mif_config & GEM_MIF_CONFIG_MDI1) {
		sc->sc_mif_config |= GEM_MIF_CONFIG_PHY_SEL;
		bus_space_write_4(sc->sc_bustag, sc->sc_h1,
	            GEM_MIF_CONFIG, sc->sc_mif_config);

		switch (sc->sc_variant) {
		case GEM_SUN_ERI:
			phyad = GEM_PHYAD_EXTERNAL;
			break;
		default:
			phyad = MII_PHY_ANY;
			break;
		}

		mii_attach(&sc->sc_dev, mii, 0xffffffff, phyad,
		    MII_OFFSET_ANY, mii_flags);
	}

	/*
	 * Fall back on an internal PHY if no external PHY was found.
	 * Note that with Apple (K2) GMACs GEM_MIF_CONFIG_MDI0 can't be
	 * trusted when the firmware has powered down the chip
	 */
	child = LIST_FIRST(&mii->mii_phys);
	if (child == NULL &&
	    (sc->sc_mif_config & GEM_MIF_CONFIG_MDI0 || GEM_IS_APPLE(sc))) {
		sc->sc_mif_config &= ~GEM_MIF_CONFIG_PHY_SEL;
		bus_space_write_4(sc->sc_bustag, sc->sc_h1,
	            GEM_MIF_CONFIG, sc->sc_mif_config);

		switch (sc->sc_variant) {
		case GEM_SUN_ERI:
		case GEM_APPLE_K2_GMAC:
			phyad = GEM_PHYAD_INTERNAL;
			break;
		case GEM_APPLE_GMAC:
			phyad = GEM_PHYAD_EXTERNAL;
			break;
		default:
			phyad = MII_PHY_ANY;
			break;
		}

		mii_attach(&sc->sc_dev, mii, 0xffffffff, phyad,
		    MII_OFFSET_ANY, mii_flags);
	}

	/* 
	 * Try the external PCS SERDES if we didn't find any MII
	 * devices.
	 */
	child = LIST_FIRST(&mii->mii_phys);
	if (child == NULL && sc->sc_variant != GEM_SUN_ERI) {
		bus_space_write_4(sc->sc_bustag, sc->sc_h1,
		    GEM_MII_DATAPATH_MODE, GEM_MII_DATAPATH_SERDES);

		bus_space_write_4(sc->sc_bustag, sc->sc_h1,
		    GEM_MII_SLINK_CONTROL,
		    GEM_MII_SLINK_LOOPBACK|GEM_MII_SLINK_EN_SYNC_D);

		bus_space_write_4(sc->sc_bustag, sc->sc_h1,
		     GEM_MII_CONFIG, GEM_MII_CONFIG_ENABLE);

		mii->mii_readreg = gem_pcs_readreg;
		mii->mii_writereg = gem_pcs_writereg;

		mii_flags |= MIIF_NOISOLATE;

		mii_attach(&sc->sc_dev, mii, 0xffffffff, MII_PHY_ANY,
		    MII_OFFSET_ANY, mii_flags);
	}

	child = LIST_FIRST(&mii->mii_phys);
	if (child == NULL) {
		/* No PHY attached */
		ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);
		ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);
	} else {
		/*
		 * XXX - we can really do the following ONLY if the
		 * phy indeed has the auto negotiation capability!!
		 */
		ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_AUTO);
	}

	/* Check if we support GigE media. */
	TAILQ_FOREACH(ifm, &sc->sc_media.ifm_list, ifm_list) {
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_T ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_SX ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_LX ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_CX) {
			sc->sc_flags |= GEM_GIGABIT;
			break;
		}
	}

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->sc_tick_ch, gem_tick, sc);
	timeout_set(&sc->sc_rx_watchdog, gem_rx_watchdog, sc);
	return;

	/*
	 * Free any resources we've allocated during the failed attach
	 * attempt.  Do this in reverse order and fall through.
	 */
 fail_6:
	for (i = 0; i < GEM_NTXDESC; i++) {
		if (sc->sc_txd[i].sd_map != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc->sc_txd[i].sd_map);
	}
 fail_5:
	for (i = 0; i < GEM_NRXDESC; i++) {
		if (sc->sc_rxsoft[i].rxs_dmamap != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc->sc_rxsoft[i].rxs_dmamap);
	}
	bus_dmamap_unload(sc->sc_dmatag, sc->sc_cddmamap);
 fail_3:
	bus_dmamap_destroy(sc->sc_dmatag, sc->sc_cddmamap);
 fail_2:
	bus_dmamem_unmap(sc->sc_dmatag, (caddr_t)sc->sc_control_data,
	    sizeof(struct gem_control_data));
 fail_1:
	bus_dmamem_free(sc->sc_dmatag, &sc->sc_cdseg, sc->sc_cdnseg);
 fail_0:
	return;
}

void
gem_unconfig(struct gem_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int i;

	gem_stop(ifp, 1);

	for (i = 0; i < GEM_NTXDESC; i++) {
		if (sc->sc_txd[i].sd_map != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc->sc_txd[i].sd_map);
	}
	for (i = 0; i < GEM_NRXDESC; i++) {
		if (sc->sc_rxsoft[i].rxs_dmamap != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc->sc_rxsoft[i].rxs_dmamap);
	}
	bus_dmamap_unload(sc->sc_dmatag, sc->sc_cddmamap);
	bus_dmamap_destroy(sc->sc_dmatag, sc->sc_cddmamap);
	bus_dmamem_unmap(sc->sc_dmatag, (caddr_t)sc->sc_control_data,
	    sizeof(struct gem_control_data));
	bus_dmamem_free(sc->sc_dmatag, &sc->sc_cdseg, sc->sc_cdnseg);

	/* Detach all PHYs */
	mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete all remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);
}


void
gem_tick(void *arg)
{
	struct gem_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_h1;
	int s;
	u_int32_t v;

	/* unload collisions counters */
	v = bus_space_read_4(t, mac, GEM_MAC_EXCESS_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_LATE_COLL_CNT);
	ifp->if_collisions += v +
	    bus_space_read_4(t, mac, GEM_MAC_NORM_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_FIRST_COLL_CNT);
	ifp->if_oerrors += v;

	/* read error counters */
	ifp->if_ierrors +=
	    bus_space_read_4(t, mac, GEM_MAC_RX_LEN_ERR_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_RX_ALIGN_ERR) +
	    bus_space_read_4(t, mac, GEM_MAC_RX_CRC_ERR_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_RX_CODE_VIOL);

	/* clear the hardware counters */
	bus_space_write_4(t, mac, GEM_MAC_NORM_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_FIRST_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_EXCESS_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_LATE_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_RX_LEN_ERR_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_RX_ALIGN_ERR, 0);
	bus_space_write_4(t, mac, GEM_MAC_RX_CRC_ERR_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_RX_CODE_VIOL, 0);

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick_ch, 1);
}

int
gem_bitwait(struct gem_softc *sc, bus_space_handle_t h, int r,
   u_int32_t clr, u_int32_t set)
{
	int i;
	u_int32_t reg;

	for (i = TRIES; i--; DELAY(100)) {
		reg = bus_space_read_4(sc->sc_bustag, h, r);
		if ((reg & clr) == 0 && (reg & set) == set)
			return (1);
	}

	return (0);
}

void
gem_reset(struct gem_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h2;
	int s;

	s = splnet();
	DPRINTF(sc, ("%s: gem_reset\n", sc->sc_dev.dv_xname));
	gem_reset_rx(sc);
	gem_reset_tx(sc);

	/* Do a full reset */
	bus_space_write_4(t, h, GEM_RESET, GEM_RESET_RX|GEM_RESET_TX);
	if (!gem_bitwait(sc, h, GEM_RESET, GEM_RESET_RX | GEM_RESET_TX, 0))
		printf("%s: cannot reset device\n", sc->sc_dev.dv_xname);
	splx(s);
}


/*
 * Drain the receive queue.
 */
void
gem_rxdrain(struct gem_softc *sc)
{
	struct gem_rxsoft *rxs;
	int i;

	for (i = 0; i < GEM_NRXDESC; i++) {
		rxs = &sc->sc_rxsoft[i];
		if (rxs->rxs_mbuf != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
			    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmatag, rxs->rxs_dmamap);
			m_freem(rxs->rxs_mbuf);
			rxs->rxs_mbuf = NULL;
		}
	}
	sc->sc_rx_prod = sc->sc_rx_cons = 0;
}

/*
 * Reset the whole thing.
 */
void
gem_stop(struct ifnet *ifp, int softonly)
{
	struct gem_softc *sc = (struct gem_softc *)ifp->if_softc;
	struct gem_sxd *sd;
	u_int32_t i;

	DPRINTF(sc, ("%s: gem_stop\n", sc->sc_dev.dv_xname));

	timeout_del(&sc->sc_tick_ch);

	/*
	 * Mark the interface down and cancel the watchdog timer.
	 */
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	if (!softonly) {
		mii_down(&sc->sc_mii);

		gem_reset_rx(sc);
		gem_reset_tx(sc);
	}

	intr_barrier(sc->sc_ih);

	KASSERT((ifp->if_flags & IFF_RUNNING) == 0);

	/*
	 * Release any queued transmit buffers.
	 */
	for (i = 0; i < GEM_NTXDESC; i++) {
		sd = &sc->sc_txd[i];
		if (sd->sd_mbuf != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			m_freem(sd->sd_mbuf);
			sd->sd_mbuf = NULL;
		}
	}
	sc->sc_tx_cnt = sc->sc_tx_prod = sc->sc_tx_cons = 0;

	gem_rxdrain(sc);
}


/*
 * Reset the receiver
 */
int
gem_reset_rx(struct gem_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h1, h2 = sc->sc_h2;

	/*
	 * Resetting while DMA is in progress can cause a bus hang, so we
	 * disable DMA first.
	 */
	gem_disable_rx(sc);
	bus_space_write_4(t, h, GEM_RX_CONFIG, 0);
	/* Wait till it finishes */
	if (!gem_bitwait(sc, h, GEM_RX_CONFIG, 1, 0))
		printf("%s: cannot disable rx dma\n", sc->sc_dev.dv_xname);
	/* Wait 5ms extra. */
	delay(5000);

	/* Finally, reset the ERX */
	bus_space_write_4(t, h2, GEM_RESET, GEM_RESET_RX);
	/* Wait till it finishes */
	if (!gem_bitwait(sc, h2, GEM_RESET, GEM_RESET_RX, 0)) {
		printf("%s: cannot reset receiver\n", sc->sc_dev.dv_xname);
		return (1);
	}
	return (0);
}


/*
 * Reset the transmitter
 */
int
gem_reset_tx(struct gem_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h1, h2 = sc->sc_h2;

	/*
	 * Resetting while DMA is in progress can cause a bus hang, so we
	 * disable DMA first.
	 */
	gem_disable_tx(sc);
	bus_space_write_4(t, h, GEM_TX_CONFIG, 0);
	/* Wait till it finishes */
	if (!gem_bitwait(sc, h, GEM_TX_CONFIG, 1, 0))
		printf("%s: cannot disable tx dma\n", sc->sc_dev.dv_xname);
	/* Wait 5ms extra. */
	delay(5000);

	/* Finally, reset the ETX */
	bus_space_write_4(t, h2, GEM_RESET, GEM_RESET_TX);
	/* Wait till it finishes */
	if (!gem_bitwait(sc, h2, GEM_RESET, GEM_RESET_TX, 0)) {
		printf("%s: cannot reset transmitter\n",
			sc->sc_dev.dv_xname);
		return (1);
	}
	return (0);
}

/*
 * Disable receiver.
 */
int
gem_disable_rx(struct gem_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h1;
	u_int32_t cfg;

	/* Flip the enable bit */
	cfg = bus_space_read_4(t, h, GEM_MAC_RX_CONFIG);
	cfg &= ~GEM_MAC_RX_ENABLE;
	bus_space_write_4(t, h, GEM_MAC_RX_CONFIG, cfg);

	/* Wait for it to finish */
	return (gem_bitwait(sc, h, GEM_MAC_RX_CONFIG, GEM_MAC_RX_ENABLE, 0));
}

/*
 * Disable transmitter.
 */
int
gem_disable_tx(struct gem_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h1;
	u_int32_t cfg;

	/* Flip the enable bit */
	cfg = bus_space_read_4(t, h, GEM_MAC_TX_CONFIG);
	cfg &= ~GEM_MAC_TX_ENABLE;
	bus_space_write_4(t, h, GEM_MAC_TX_CONFIG, cfg);

	/* Wait for it to finish */
	return (gem_bitwait(sc, h, GEM_MAC_TX_CONFIG, GEM_MAC_TX_ENABLE, 0));
}

/*
 * Initialize interface.
 */
int
gem_meminit(struct gem_softc *sc)
{
	int i;

	/*
	 * Initialize the transmit descriptor ring.
	 */
	for (i = 0; i < GEM_NTXDESC; i++) {
		sc->sc_txdescs[i].gd_flags = 0;
		sc->sc_txdescs[i].gd_addr = 0;
	}
	GEM_CDTXSYNC(sc, 0, GEM_NTXDESC,
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	/*
	 * Initialize the receive descriptor and receive job
	 * descriptor rings.
	 */
	for (i = 0; i < GEM_NRXDESC; i++) {
		sc->sc_rxdescs[i].gd_flags = 0;
		sc->sc_rxdescs[i].gd_addr = 0;
	}
	/* Hardware reads RX descriptors in multiples of four. */
	if_rxr_init(&sc->sc_rx_ring, 4, GEM_NRXDESC - 4);
	gem_fill_rx_ring(sc);

	return (0);
}

int
gem_ringsize(int sz)
{
	switch (sz) {
	case 32:
		return GEM_RING_SZ_32;
	case 64:
		return GEM_RING_SZ_64;
	case 128:
		return GEM_RING_SZ_128;
	case 256:
		return GEM_RING_SZ_256;
	case 512:
		return GEM_RING_SZ_512;
	case 1024:
		return GEM_RING_SZ_1024;
	case 2048:
		return GEM_RING_SZ_2048;
	case 4096:
		return GEM_RING_SZ_4096;
	case 8192:
		return GEM_RING_SZ_8192;
	default:
		printf("gem: invalid Receive Descriptor ring size %d\n", sz);
		return GEM_RING_SZ_32;
	}
}

/*
 * Initialization of interface; set up initialization block
 * and transmit/receive descriptor rings.
 */
int
gem_init(struct ifnet *ifp)
{

	struct gem_softc *sc = (struct gem_softc *)ifp->if_softc;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h1;
	int s;
	u_int32_t v;

	s = splnet();

	DPRINTF(sc, ("%s: gem_init: calling stop\n", sc->sc_dev.dv_xname));
	/*
	 * Initialization sequence. The numbered steps below correspond
	 * to the sequence outlined in section 6.3.5.1 in the Ethernet
	 * Channel Engine manual (part of the PCIO manual).
	 * See also the STP2002-STQ document from Sun Microsystems.
	 */

	/* step 1 & 2. Reset the Ethernet Channel */
	gem_stop(ifp, 0);
	gem_reset(sc);
	DPRINTF(sc, ("%s: gem_init: restarting\n", sc->sc_dev.dv_xname));

	/* Re-initialize the MIF */
	gem_mifinit(sc);

	/* Call MI reset function if any */
	if (sc->sc_hwreset)
		(*sc->sc_hwreset)(sc);

	/* step 3. Setup data structures in host memory */
	gem_meminit(sc);

	/* step 4. TX MAC registers & counters */
	gem_init_regs(sc);

	/* step 5. RX MAC registers & counters */
	gem_iff(sc);

	/* step 6 & 7. Program Descriptor Ring Base Addresses */
	bus_space_write_4(t, h, GEM_TX_RING_PTR_HI, 
	    (((uint64_t)GEM_CDTXADDR(sc,0)) >> 32));
	bus_space_write_4(t, h, GEM_TX_RING_PTR_LO, GEM_CDTXADDR(sc, 0));

	bus_space_write_4(t, h, GEM_RX_RING_PTR_HI, 
	    (((uint64_t)GEM_CDRXADDR(sc,0)) >> 32));
	bus_space_write_4(t, h, GEM_RX_RING_PTR_LO, GEM_CDRXADDR(sc, 0));

	/* step 8. Global Configuration & Interrupt Mask */
	bus_space_write_4(t, h, GEM_INTMASK,
		      ~(GEM_INTR_TX_INTME|
			GEM_INTR_TX_EMPTY|
			GEM_INTR_RX_DONE|GEM_INTR_RX_NOBUF|
			GEM_INTR_RX_TAG_ERR|GEM_INTR_PCS|
			GEM_INTR_MAC_CONTROL|GEM_INTR_MIF|
			GEM_INTR_BERR));
	bus_space_write_4(t, h, GEM_MAC_RX_MASK,
	    GEM_MAC_RX_DONE|GEM_MAC_RX_FRAME_CNT);
	bus_space_write_4(t, h, GEM_MAC_TX_MASK, 0xffff); /* XXXX */
	bus_space_write_4(t, h, GEM_MAC_CONTROL_MASK, 0); /* XXXX */

	/* step 9. ETX Configuration: use mostly default values */

	/* Enable DMA */
	v = gem_ringsize(GEM_NTXDESC /*XXX*/);
	v |= ((sc->sc_variant == GEM_SUN_ERI ? 0x100 : 0x04ff) << 10) &
	    GEM_TX_CONFIG_TXFIFO_TH;
	bus_space_write_4(t, h, GEM_TX_CONFIG, v | GEM_TX_CONFIG_TXDMA_EN);
	bus_space_write_4(t, h, GEM_TX_KICK, 0);

	/* step 10. ERX Configuration */

	/* Encode Receive Descriptor ring size: four possible values */
	v = gem_ringsize(GEM_NRXDESC /*XXX*/);
	/* Enable DMA */
	bus_space_write_4(t, h, GEM_RX_CONFIG, 
		v|(GEM_THRSH_1024<<GEM_RX_CONFIG_FIFO_THRS_SHIFT)|
		(2<<GEM_RX_CONFIG_FBOFF_SHFT)|GEM_RX_CONFIG_RXDMA_EN|
		(0<<GEM_RX_CONFIG_CXM_START_SHFT));
	/*
	 * The following value is for an OFF Threshold of about 3/4 full
	 * and an ON Threshold of 1/4 full.
	 */
	bus_space_write_4(t, h, GEM_RX_PAUSE_THRESH,
	    (3 * sc->sc_rxfifosize / 256) |
	    ((sc->sc_rxfifosize / 256) << 12));
	bus_space_write_4(t, h, GEM_RX_BLANKING, (6 << 12) | 6);

	/* step 11. Configure Media */
	mii_mediachg(&sc->sc_mii);

	/* step 12. RX_MAC Configuration Register */
	v = bus_space_read_4(t, h, GEM_MAC_RX_CONFIG);
	v |= GEM_MAC_RX_ENABLE | GEM_MAC_RX_STRIP_CRC;
	bus_space_write_4(t, h, GEM_MAC_RX_CONFIG, v);

	/* step 14. Issue Transmit Pending command */

	/* Call MI initialization function if any */
	if (sc->sc_hwinit)
		(*sc->sc_hwinit)(sc);

	/* step 15.  Give the receiver a swift kick */
	bus_space_write_4(t, h, GEM_RX_KICK, sc->sc_rx_prod);

	/* Start the one second timer. */
	timeout_add_sec(&sc->sc_tick_ch, 1);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	return (0);
}

void
gem_init_regs(struct gem_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h1;
	u_int32_t v;

	/* These regs are not cleared on reset */
	sc->sc_inited = 0;
	if (!sc->sc_inited) {
		/* Load recommended values */
		bus_space_write_4(t, h, GEM_MAC_IPG0, 0x00);
		bus_space_write_4(t, h, GEM_MAC_IPG1, 0x08);
		bus_space_write_4(t, h, GEM_MAC_IPG2, 0x04);

		bus_space_write_4(t, h, GEM_MAC_MAC_MIN_FRAME, ETHER_MIN_LEN);
		/* Max frame and max burst size */
		bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME,
		    (ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN) | (0x2000 << 16));

		bus_space_write_4(t, h, GEM_MAC_PREAMBLE_LEN, 0x07);
		bus_space_write_4(t, h, GEM_MAC_JAM_SIZE, 0x04);
		bus_space_write_4(t, h, GEM_MAC_ATTEMPT_LIMIT, 0x10);
		bus_space_write_4(t, h, GEM_MAC_CONTROL_TYPE, 0x8088);
		bus_space_write_4(t, h, GEM_MAC_RANDOM_SEED,
		    ((sc->sc_arpcom.ac_enaddr[5]<<8)|sc->sc_arpcom.ac_enaddr[4])&0x3ff);

		/* Secondary MAC addr set to 0:0:0:0:0:0 */
		bus_space_write_4(t, h, GEM_MAC_ADDR3, 0);
		bus_space_write_4(t, h, GEM_MAC_ADDR4, 0);
		bus_space_write_4(t, h, GEM_MAC_ADDR5, 0);

		/* MAC control addr set to 0:1:c2:0:1:80 */
		bus_space_write_4(t, h, GEM_MAC_ADDR6, 0x0001);
		bus_space_write_4(t, h, GEM_MAC_ADDR7, 0xc200);
		bus_space_write_4(t, h, GEM_MAC_ADDR8, 0x0180);

		/* MAC filter addr set to 0:0:0:0:0:0 */
		bus_space_write_4(t, h, GEM_MAC_ADDR_FILTER0, 0);
		bus_space_write_4(t, h, GEM_MAC_ADDR_FILTER1, 0);
		bus_space_write_4(t, h, GEM_MAC_ADDR_FILTER2, 0);

		bus_space_write_4(t, h, GEM_MAC_ADR_FLT_MASK1_2, 0);
		bus_space_write_4(t, h, GEM_MAC_ADR_FLT_MASK0, 0);

		sc->sc_inited = 1;
	}

	/* Counters need to be zeroed */
	bus_space_write_4(t, h, GEM_MAC_NORM_COLL_CNT, 0);
	bus_space_write_4(t, h, GEM_MAC_FIRST_COLL_CNT, 0);
	bus_space_write_4(t, h, GEM_MAC_EXCESS_COLL_CNT, 0);
	bus_space_write_4(t, h, GEM_MAC_LATE_COLL_CNT, 0);
	bus_space_write_4(t, h, GEM_MAC_DEFER_TMR_CNT, 0);
	bus_space_write_4(t, h, GEM_MAC_PEAK_ATTEMPTS, 0);
	bus_space_write_4(t, h, GEM_MAC_RX_FRAME_COUNT, 0);
	bus_space_write_4(t, h, GEM_MAC_RX_LEN_ERR_CNT, 0);
	bus_space_write_4(t, h, GEM_MAC_RX_ALIGN_ERR, 0);
	bus_space_write_4(t, h, GEM_MAC_RX_CRC_ERR_CNT, 0);
	bus_space_write_4(t, h, GEM_MAC_RX_CODE_VIOL, 0);

	/* Set XOFF PAUSE time */
	bus_space_write_4(t, h, GEM_MAC_SEND_PAUSE_CMD, 0x1bf0);

	/*
	 * Set the internal arbitration to "infinite" bursts of the
	 * maximum length of 31 * 64 bytes so DMA transfers aren't
	 * split up in cache line size chunks. This greatly improves
	 * especially RX performance.
	 * Enable silicon bug workarounds for the Apple variants.
	 */
	v = GEM_CONFIG_TXDMA_LIMIT | GEM_CONFIG_RXDMA_LIMIT;
	if (sc->sc_pci)
		v |= GEM_CONFIG_BURST_INF;
	else
		v |= GEM_CONFIG_BURST_64;
	if (sc->sc_variant != GEM_SUN_GEM && sc->sc_variant != GEM_SUN_ERI)
		v |= GEM_CONFIG_RONPAULBIT | GEM_CONFIG_BUG2FIX;
	bus_space_write_4(t, h, GEM_CONFIG, v);

	/*
	 * Set the station address.
	 */
	bus_space_write_4(t, h, GEM_MAC_ADDR0, 
		(sc->sc_arpcom.ac_enaddr[4]<<8) | sc->sc_arpcom.ac_enaddr[5]);
	bus_space_write_4(t, h, GEM_MAC_ADDR1, 
		(sc->sc_arpcom.ac_enaddr[2]<<8) | sc->sc_arpcom.ac_enaddr[3]);
	bus_space_write_4(t, h, GEM_MAC_ADDR2, 
		(sc->sc_arpcom.ac_enaddr[0]<<8) | sc->sc_arpcom.ac_enaddr[1]);
}

/*
 * Receive interrupt.
 */
int
gem_rint(struct gem_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h1;
	struct gem_rxsoft *rxs;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	u_int64_t rxstat;
	int i, len;

	if (if_rxr_inuse(&sc->sc_rx_ring) == 0)
		return (0);

	for (i = sc->sc_rx_cons; if_rxr_inuse(&sc->sc_rx_ring) > 0;
	    i = GEM_NEXTRX(i)) {
		rxs = &sc->sc_rxsoft[i];

		GEM_CDRXSYNC(sc, i,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		rxstat = GEM_DMA_READ(sc, &sc->sc_rxdescs[i].gd_flags);

		if (rxstat & GEM_RD_OWN) {
			/* We have processed all of the receive buffers. */
			break;
		}

		bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
		    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmatag, rxs->rxs_dmamap);

		m = rxs->rxs_mbuf;
		rxs->rxs_mbuf = NULL;

		if_rxr_put(&sc->sc_rx_ring, 1);

		if (rxstat & GEM_RD_BAD_CRC) {
			ifp->if_ierrors++;
#ifdef GEM_DEBUG
			printf("%s: receive error: CRC error\n",
				sc->sc_dev.dv_xname);
#endif
			m_freem(m);
			continue;
		}

#ifdef GEM_DEBUG
		if (ifp->if_flags & IFF_DEBUG) {
			printf("    rxsoft %p descriptor %d: ", rxs, i);
			printf("gd_flags: 0x%016llx\t", (long long)
				GEM_DMA_READ(sc, &sc->sc_rxdescs[i].gd_flags));
			printf("gd_addr: 0x%016llx\n", (long long)
				GEM_DMA_READ(sc, &sc->sc_rxdescs[i].gd_addr));
		}
#endif

		/* No errors; receive the packet. */
		len = GEM_RD_BUFLEN(rxstat);

		m->m_data += 2; /* We're already off by two */
		m->m_pkthdr.len = m->m_len = len;

		ml_enqueue(&ml, m);
	}

	/* Update the receive pointer. */
	sc->sc_rx_cons = i;
	gem_fill_rx_ring(sc);
	bus_space_write_4(t, h, GEM_RX_KICK, sc->sc_rx_prod);

	DPRINTF(sc, ("gem_rint: done sc->sc_rx_cons %d, complete %d\n",
		sc->sc_rx_cons, bus_space_read_4(t, h, GEM_RX_COMPLETION)));

	if_input(ifp, &ml);

	return (1);
}

void
gem_fill_rx_ring(struct gem_softc *sc)
{
	u_int slots;

	for (slots = if_rxr_get(&sc->sc_rx_ring, GEM_NRXDESC - 4);
	    slots > 0; slots--) {
		if (gem_add_rxbuf(sc, sc->sc_rx_prod))
			break;
	}
	if_rxr_put(&sc->sc_rx_ring, slots);
}

/*
 * Add a receive buffer to the indicated descriptor.
 */
int
gem_add_rxbuf(struct gem_softc *sc, int idx)
{
	struct gem_rxsoft *rxs = &sc->sc_rxsoft[idx];
	struct mbuf *m;
	int error;

	m = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
	if (!m)
		return (ENOBUFS);
	m->m_len = m->m_pkthdr.len = MCLBYTES;

#ifdef GEM_DEBUG
/* bzero the packet to check dma */
	memset(m->m_ext.ext_buf, 0, m->m_ext.ext_size);
#endif

	rxs->rxs_mbuf = m;

	error = bus_dmamap_load_mbuf(sc->sc_dmatag, rxs->rxs_dmamap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: can't load rx DMA map %d, error = %d\n",
		    sc->sc_dev.dv_xname, idx, error);
		panic("gem_add_rxbuf");	/* XXX */
	}

	bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
	    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	GEM_INIT_RXDESC(sc, idx);

	sc->sc_rx_prod = GEM_NEXTRX(sc->sc_rx_prod);

	return (0);
}

int
gem_eint(struct gem_softc *sc, u_int status)
{
	if ((status & GEM_INTR_MIF) != 0) {
#ifdef GEM_DEBUG
		printf("%s: link status changed\n", sc->sc_dev.dv_xname);
#endif
		return (1);
	}

	printf("%s: status=%b\n", sc->sc_dev.dv_xname, status, GEM_INTR_BITS);
	return (1);
}

int
gem_pint(struct gem_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t seb = sc->sc_h1;
	u_int32_t status;

	status = bus_space_read_4(t, seb, GEM_MII_INTERRUP_STATUS);
	status |= bus_space_read_4(t, seb, GEM_MII_INTERRUP_STATUS);
#ifdef GEM_DEBUG
	if (status)
		printf("%s: link status changed\n", sc->sc_dev.dv_xname);
#endif
	return (1);
}

int
gem_intr(void *v)
{
	struct gem_softc *sc = (struct gem_softc *)v;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t seb = sc->sc_h1;
	u_int32_t status;
	int r = 0;

	status = bus_space_read_4(t, seb, GEM_STATUS);
	DPRINTF(sc, ("%s: gem_intr: cplt %xstatus %b\n",
		sc->sc_dev.dv_xname, (status>>19), status, GEM_INTR_BITS));

	if (status == 0xffffffff)
		return (0);

	if ((status & GEM_INTR_PCS) != 0)
		r |= gem_pint(sc);

	if ((status & (GEM_INTR_RX_TAG_ERR | GEM_INTR_BERR)) != 0)
		r |= gem_eint(sc, status);

	if ((status & (GEM_INTR_TX_EMPTY | GEM_INTR_TX_INTME)) != 0)
		r |= gem_tint(sc, status);

	if ((status & (GEM_INTR_RX_DONE | GEM_INTR_RX_NOBUF)) != 0)
		r |= gem_rint(sc);

	/* We should eventually do more than just print out error stats. */
	if (status & GEM_INTR_TX_MAC) {
		int txstat = bus_space_read_4(t, seb, GEM_MAC_TX_STATUS);
#ifdef GEM_DEBUG
		if (txstat & ~GEM_MAC_TX_XMIT_DONE)
			printf("%s: MAC tx fault, status %x\n",
			    sc->sc_dev.dv_xname, txstat);
#endif
		if (txstat & (GEM_MAC_TX_UNDERRUN | GEM_MAC_TX_PKT_TOO_LONG)) {
			KERNEL_LOCK();
			gem_init(ifp);
			KERNEL_UNLOCK();
		}
	}
	if (status & GEM_INTR_RX_MAC) {
		int rxstat = bus_space_read_4(t, seb, GEM_MAC_RX_STATUS);
#ifdef GEM_DEBUG
 		if (rxstat & ~GEM_MAC_RX_DONE)
 			printf("%s: MAC rx fault, status %x\n",
 			    sc->sc_dev.dv_xname, rxstat);
#endif
		if (rxstat & GEM_MAC_RX_OVERFLOW) {
			ifp->if_ierrors++;

			/*
			 * Apparently a silicon bug causes ERI to hang
			 * from time to time.  So if we detect an RX
			 * FIFO overflow, we fire off a timer, and
			 * check whether we're still making progress
			 * by looking at the RX FIFO write and read
			 * pointers.
			 */
			sc->sc_rx_fifo_wr_ptr =
				bus_space_read_4(t, seb, GEM_RX_FIFO_WR_PTR);
			sc->sc_rx_fifo_rd_ptr =
				bus_space_read_4(t, seb, GEM_RX_FIFO_RD_PTR);
			timeout_add_msec(&sc->sc_rx_watchdog, 400);
		}
#ifdef GEM_DEBUG
		else if (rxstat & ~(GEM_MAC_RX_DONE | GEM_MAC_RX_FRAME_CNT))
			printf("%s: MAC rx fault, status %x\n",
			    sc->sc_dev.dv_xname, rxstat);
#endif
	}
	return (r);
}

void
gem_rx_watchdog(void *arg)
{
	struct gem_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h1;
	u_int32_t rx_fifo_wr_ptr;
	u_int32_t rx_fifo_rd_ptr;
	u_int32_t state;

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	rx_fifo_wr_ptr = bus_space_read_4(t, h, GEM_RX_FIFO_WR_PTR);
	rx_fifo_rd_ptr = bus_space_read_4(t, h, GEM_RX_FIFO_RD_PTR);
	state = bus_space_read_4(t, h, GEM_MAC_MAC_STATE);
	if ((state & GEM_MAC_STATE_OVERFLOW) == GEM_MAC_STATE_OVERFLOW &&
	    ((rx_fifo_wr_ptr == rx_fifo_rd_ptr) ||
	     ((sc->sc_rx_fifo_wr_ptr == rx_fifo_wr_ptr) &&
	      (sc->sc_rx_fifo_rd_ptr == rx_fifo_rd_ptr)))) {
		/*
		 * The RX state machine is still in overflow state and
		 * the RX FIFO write and read pointers seem to be
		 * stuck.  Whack the chip over the head to get things
		 * going again.
		 */
		gem_init(ifp);
	}
}

void
gem_watchdog(struct ifnet *ifp)
{
	struct gem_softc *sc = ifp->if_softc;

	DPRINTF(sc, ("gem_watchdog: GEM_RX_CONFIG %x GEM_MAC_RX_STATUS %x "
		"GEM_MAC_RX_CONFIG %x\n",
		bus_space_read_4(sc->sc_bustag, sc->sc_h1, GEM_RX_CONFIG),
		bus_space_read_4(sc->sc_bustag, sc->sc_h1, GEM_MAC_RX_STATUS),
		bus_space_read_4(sc->sc_bustag, sc->sc_h1, GEM_MAC_RX_CONFIG)));

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++ifp->if_oerrors;

	/* Try to get more packets going. */
	gem_init(ifp);
}

/*
 * Initialize the MII Management Interface
 */
void
gem_mifinit(struct gem_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mif = sc->sc_h1;

	/* Configure the MIF in frame mode */
	sc->sc_mif_config = bus_space_read_4(t, mif, GEM_MIF_CONFIG);
	sc->sc_mif_config &= ~GEM_MIF_CONFIG_BB_ENA;
	bus_space_write_4(t, mif, GEM_MIF_CONFIG, sc->sc_mif_config);
}

/*
 * MII interface
 *
 * The GEM MII interface supports at least three different operating modes:
 *
 * Bitbang mode is implemented using data, clock and output enable registers.
 *
 * Frame mode is implemented by loading a complete frame into the frame
 * register and polling the valid bit for completion.
 *
 * Polling mode uses the frame register but completion is indicated by
 * an interrupt.
 *
 */
int
gem_mii_readreg(struct device *self, int phy, int reg)
{
	struct gem_softc *sc = (void *)self;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mif = sc->sc_h1;
	int n;
	u_int32_t v;

#ifdef GEM_DEBUG
	if (sc->sc_debug)
		printf("gem_mii_readreg: phy %d reg %d\n", phy, reg);
#endif

	/* Construct the frame command */
	v = (reg << GEM_MIF_REG_SHIFT)	| (phy << GEM_MIF_PHY_SHIFT) |
		GEM_MIF_FRAME_READ;

	bus_space_write_4(t, mif, GEM_MIF_FRAME, v);
	for (n = 0; n < 100; n++) {
		DELAY(1);
		v = bus_space_read_4(t, mif, GEM_MIF_FRAME);
		if (v & GEM_MIF_FRAME_TA0)
			return (v & GEM_MIF_FRAME_DATA);
	}

	printf("%s: mii_read timeout\n", sc->sc_dev.dv_xname);
	return (0);
}

void
gem_mii_writereg(struct device *self, int phy, int reg, int val)
{
	struct gem_softc *sc = (void *)self;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mif = sc->sc_h1;
	int n;
	u_int32_t v;

#ifdef GEM_DEBUG
	if (sc->sc_debug)
		printf("gem_mii_writereg: phy %d reg %d val %x\n",
			phy, reg, val);
#endif

	/* Construct the frame command */
	v = GEM_MIF_FRAME_WRITE			|
	    (phy << GEM_MIF_PHY_SHIFT)		|
	    (reg << GEM_MIF_REG_SHIFT)		|
	    (val & GEM_MIF_FRAME_DATA);

	bus_space_write_4(t, mif, GEM_MIF_FRAME, v);
	for (n = 0; n < 100; n++) {
		DELAY(1);
		v = bus_space_read_4(t, mif, GEM_MIF_FRAME);
		if (v & GEM_MIF_FRAME_TA0)
			return;
	}

	printf("%s: mii_write timeout\n", sc->sc_dev.dv_xname);
}

void
gem_mii_statchg(struct device *dev)
{
	struct gem_softc *sc = (void *)dev;
#ifdef GEM_DEBUG
	uint64_t instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
#endif
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_h1;
	u_int32_t v;

#ifdef GEM_DEBUG
	if (sc->sc_debug)
		printf("gem_mii_statchg: status change: phy = %lld\n", instance);
#endif

	/* Set tx full duplex options */
	bus_space_write_4(t, mac, GEM_MAC_TX_CONFIG, 0);
	delay(10000); /* reg must be cleared and delay before changing. */
	v = GEM_MAC_TX_ENA_IPG0|GEM_MAC_TX_NGU|GEM_MAC_TX_NGU_LIMIT|
		GEM_MAC_TX_ENABLE;
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0) {
		v |= GEM_MAC_TX_IGN_CARRIER|GEM_MAC_TX_IGN_COLLIS;
	}
	bus_space_write_4(t, mac, GEM_MAC_TX_CONFIG, v);

	/* XIF Configuration */
	v = GEM_MAC_XIF_TX_MII_ENA;
	v |= GEM_MAC_XIF_LINK_LED;

	/* External MII needs echo disable if half duplex. */
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0)
		/* turn on full duplex LED */
		v |= GEM_MAC_XIF_FDPLX_LED;
	else
		/* half duplex -- disable echo */
		v |= GEM_MAC_XIF_ECHO_DISABL;

	switch (IFM_SUBTYPE(sc->sc_mii.mii_media_active)) {
	case IFM_1000_T:  /* Gigabit using GMII interface */
	case IFM_1000_SX:
		v |= GEM_MAC_XIF_GMII_MODE;
		break;
	default:
		v &= ~GEM_MAC_XIF_GMII_MODE;
	}
	bus_space_write_4(t, mac, GEM_MAC_XIF_CONFIG, v);

	/*
	 * 802.3x flow control
	 */
	v = bus_space_read_4(t, mac, GEM_MAC_CONTROL_CONFIG);
	v &= ~(GEM_MAC_CC_RX_PAUSE | GEM_MAC_CC_TX_PAUSE);
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_ETH_RXPAUSE) != 0)
		v |= GEM_MAC_CC_RX_PAUSE;
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_ETH_TXPAUSE) != 0)
		v |= GEM_MAC_CC_TX_PAUSE;
	bus_space_write_4(t, mac, GEM_MAC_CONTROL_CONFIG, v);
}

int
gem_pcs_readreg(struct device *self, int phy, int reg)
{
	struct gem_softc *sc = (void *)self;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t pcs = sc->sc_h1;

#ifdef GEM_DEBUG
	if (sc->sc_debug)
		printf("gem_pcs_readreg: phy %d reg %d\n", phy, reg);
#endif

	if (phy != GEM_PHYAD_EXTERNAL)
		return (0);

	switch (reg) {
	case MII_BMCR:
		reg = GEM_MII_CONTROL;
		break;
	case MII_BMSR:
		reg = GEM_MII_STATUS;
		break;
	case MII_ANAR:
		reg = GEM_MII_ANAR;
		break;
	case MII_ANLPAR:
		reg = GEM_MII_ANLPAR;
		break;
	case MII_EXTSR:
		return (EXTSR_1000XFDX|EXTSR_1000XHDX);
	default:
		return (0);
	}

	return bus_space_read_4(t, pcs, reg);
}

void
gem_pcs_writereg(struct device *self, int phy, int reg, int val)
{
	struct gem_softc *sc = (void *)self;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t pcs = sc->sc_h1;
	int reset = 0;

#ifdef GEM_DEBUG
	if (sc->sc_debug)
		printf("gem_pcs_writereg: phy %d reg %d val %x\n",
			phy, reg, val);
#endif

	if (phy != GEM_PHYAD_EXTERNAL)
		return;

	if (reg == MII_ANAR)
		bus_space_write_4(t, pcs, GEM_MII_CONFIG, 0);

	switch (reg) {
	case MII_BMCR:
		reset = (val & GEM_MII_CONTROL_RESET);
		reg = GEM_MII_CONTROL;
		break;
	case MII_BMSR:
		reg = GEM_MII_STATUS;
		break;
	case MII_ANAR:
		reg = GEM_MII_ANAR;
		break;
	case MII_ANLPAR:
		reg = GEM_MII_ANLPAR;
		break;
	default:
		return;
	}

	bus_space_write_4(t, pcs, reg, val);

	if (reset)
		gem_bitwait(sc, pcs, GEM_MII_CONTROL, GEM_MII_CONTROL_RESET, 0);

	if (reg == GEM_MII_ANAR || reset) {
		bus_space_write_4(t, pcs, GEM_MII_SLINK_CONTROL,
		    GEM_MII_SLINK_LOOPBACK|GEM_MII_SLINK_EN_SYNC_D);
		bus_space_write_4(t, pcs, GEM_MII_CONFIG,
		    GEM_MII_CONFIG_ENABLE);
	}
}

int
gem_mediachange(struct ifnet *ifp)
{
	struct gem_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->sc_mii;

	if (mii->mii_instance) {
		struct mii_softc *miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}

	return (mii_mediachg(&sc->sc_mii));
}

void
gem_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct gem_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
}

/*
 * Process an ioctl request.
 */
int
gem_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct gem_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if ((ifp->if_flags & IFF_RUNNING) == 0)
			gem_init(ifp);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				gem_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				gem_stop(ifp, 0);
		}
#ifdef GEM_DEBUG
		sc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;
#endif
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	case SIOCGIFRXR:
		error = if_rxr_ioctl((struct if_rxrinfo *)ifr->ifr_data,
		    NULL, MCLBYTES, &sc->sc_rx_ring);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			gem_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
gem_iff(struct gem_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t h = sc->sc_h1;
	u_int32_t crc, hash[16], rxcfg;
	int i;

	rxcfg = bus_space_read_4(t, h, GEM_MAC_RX_CONFIG);
	rxcfg &= ~(GEM_MAC_RX_HASH_FILTER | GEM_MAC_RX_PROMISCUOUS |
	    GEM_MAC_RX_PROMISC_GRP);
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxcfg |= GEM_MAC_RX_PROMISCUOUS;
		else
			rxcfg |= GEM_MAC_RX_PROMISC_GRP;
	} else {
		/*
		 * Set up multicast address filter by passing all multicast
		 * addresses through a crc generator, and then using the
		 * high order 8 bits as an index into the 256 bit logical
		 * address filter.  The high order 4 bits selects the word,
		 * while the other 4 bits select the bit within the word
		 * (where bit 0 is the MSB).
		 */

		rxcfg |= GEM_MAC_RX_HASH_FILTER;

		/* Clear hash table */
		for (i = 0; i < 16; i++)
			hash[i] = 0;

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			crc = ether_crc32_le(enm->enm_addrlo,
			    ETHER_ADDR_LEN);

			/* Just want the 8 most significant bits. */
			crc >>= 24;

			/* Set the corresponding bit in the filter. */
			hash[crc >> 4] |= 1 << (15 - (crc & 15));

			ETHER_NEXT_MULTI(step, enm);
		}

		/* Now load the hash table into the chip (if we are using it) */
		for (i = 0; i < 16; i++) {
			bus_space_write_4(t, h,
			    GEM_MAC_HASH0 + i * (GEM_MAC_HASH1 - GEM_MAC_HASH0),
			    hash[i]);
		}
	}

	bus_space_write_4(t, h, GEM_MAC_RX_CONFIG, rxcfg);
}

/*
 * Transmit interrupt.
 */
int
gem_tint(struct gem_softc *sc, u_int32_t status)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct gem_sxd *sd;
	u_int32_t cons, hwcons;
	u_int32_t used, free = 0;

	hwcons = status >> 19;
	cons = sc->sc_tx_cons;
	while (cons != hwcons) {
		sd = &sc->sc_txd[cons];
		if (sd->sd_mbuf != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			m_freem(sd->sd_mbuf);
			sd->sd_mbuf = NULL;
		}
		free++;
		if (++cons == GEM_NTXDESC)
			cons = 0;
	}

	sc->sc_tx_cons = cons;
	used = atomic_sub_int_nv(&sc->sc_tx_cnt, free);

	if (used == 0)
		ifp->if_timer = 0;

	if (ifq_is_oactive(&ifp->if_snd) && (used + GEM_NTXSEGS <
	    GEM_NTXDESC - 2)) {
		ifq_clr_oactive(&ifp->if_snd);

		KERNEL_LOCK();
		gem_start(ifp);
		KERNEL_UNLOCK();
	}

	return (1);
}

int
gem_load_mbuf(struct gem_softc *sc, struct gem_sxd *sd, struct mbuf *m)
{
	int error;

	error = bus_dmamap_load_mbuf(sc->sc_dmatag, sd->sd_map, m,
	    BUS_DMA_NOWAIT);
	switch (error) {
	case 0:
		break;

	case EFBIG: /* mbuf chain is too fragmented */
		if (m_defrag(m, M_DONTWAIT) == 0 &&
		    bus_dmamap_load_mbuf(sc->sc_dmatag, sd->sd_map, m,
		    BUS_DMA_NOWAIT) == 0)
		    	break;
		/* FALLTHROUGH */
	default:
		return (1);
	}

	return (0);
}

void
gem_start(struct ifnet *ifp)
{
	struct gem_softc *sc = ifp->if_softc;
	struct gem_sxd *sd;
	struct mbuf *m;
	u_int64_t flags;
	bus_dmamap_t map;
	u_int32_t prod, first, last, i;
	unsigned int used, new;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	prod = sc->sc_tx_prod;
	used = sc->sc_tx_cnt;
	new = 0;

	for (;;) {
		if (used + new + GEM_NTXSEGS > (GEM_NTXDESC - 2)) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

		first = prod;
		sd = &sc->sc_txd[prod];
		map = sd->sd_map;

		if (gem_load_mbuf(sc, sd, m)) {
			m_freem(m);
			ifp->if_oerrors++;
			continue;
		}

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		bus_dmamap_sync(sc->sc_dmatag, map, 0, map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

		for (i = 0; i < map->dm_nsegs; i++) {
			GEM_DMA_WRITE(sc, &sc->sc_txdescs[prod].gd_addr,
			    map->dm_segs[i].ds_addr);
			flags = map->dm_segs[i].ds_len & GEM_TD_BUFSIZE;
			if (i == 0)
				flags |= GEM_TD_START_OF_PACKET;
			if (i == (map->dm_nsegs - 1))
				flags |= GEM_TD_END_OF_PACKET;
			GEM_DMA_WRITE(sc, &sc->sc_txdescs[prod].gd_flags,
			    flags);
			bus_dmamap_sync(sc->sc_dmatag, sc->sc_cddmamap,
			    GEM_CDTXOFF(prod), sizeof(struct gem_desc),
			    BUS_DMASYNC_PREWRITE);

			last = prod;
			if (++prod == GEM_NTXDESC)
				prod = 0;
		}

		new += map->dm_nsegs;
		sc->sc_txd[last].sd_mbuf = m;
		sc->sc_txd[first].sd_map = sc->sc_txd[last].sd_map;
		sc->sc_txd[last].sd_map = map;
	}

	if (new == 0)
		return;

	atomic_add_int(&sc->sc_tx_cnt, new);

	/* Commit. */
	sc->sc_tx_prod = prod;

	/* Transmit. */
	bus_space_write_4(sc->sc_bustag, sc->sc_h1, GEM_TX_KICK, prod);

	/* Set timeout in case hardware has problems transmitting. */
	ifp->if_timer = 5;
}
@


1.120
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.119 2015/12/08 13:34:22 tedu Exp $	*/
a1640 1
			ifp->if_opackets++;
@


1.119
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.118 2015/11/28 09:42:10 jmatthew Exp $	*/
a225 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.118
log
@Rework gem_start to check that there's enough space in the ring before
dequeueing a packet, then drop the packet if it can't be sent, rather than
using two phase dequeue then commit.

Adjust sc_tx_cnt using atomic operations, take the kernel lock before
calling gem_start or gem_init from the interrupt handler, and use an
interrupt barrier when taking the interface down.

With all this done, we can mark the interrupt handler for pci (but not sbus)
attached gem(4) as mpsafe.

mpi@@ wrote this initially, I fixed bugs to keep sparc64 happy and kept it up
to date with ifq changes.

ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.117 2015/11/25 03:09:58 dlg Exp $	*/
d221 1
a221 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.117
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.116 2015/11/24 17:11:39 mpi Exp $	*/
d51 1
d99 2
d545 4
d959 3
d1147 2
a1148 1
		if (txstat & (GEM_MAC_TX_UNDERRUN | GEM_MAC_TX_PKT_TOO_LONG))
d1150 2
d1630 1
d1644 1
a1644 1
		sc->sc_tx_cnt--;
d1648 1
d1650 1
d1652 5
a1656 1
	if (sc->sc_tx_cnt < GEM_NTXDESC - 2)
a1657 2
	if (sc->sc_tx_cnt == 0)
		ifp->if_timer = 0;
d1659 4
a1662 1
	gem_start(ifp);
d1667 24
d1695 1
d1699 2
a1700 2
	u_int32_t cur, frag, i;
	int error;
d1705 11
a1715 2
	while (sc->sc_txd[sc->sc_tx_prod].sd_mbuf == NULL) {
		m = ifq_deq_begin(&ifp->if_snd);
d1719 3
a1721 4
		/*
		 * Encapsulate this packet and start it going...
		 * or fail...
		 */
d1723 4
a1726 22
		cur = frag = sc->sc_tx_prod;
		map = sc->sc_txd[cur].sd_map;

		error = bus_dmamap_load_mbuf(sc->sc_dmatag, map, m,
		    BUS_DMA_NOWAIT);
		if (error != 0 && error != EFBIG)
			goto drop;
		if (error != 0) {
			/* Too many fragments, linearize. */
			if (m_defrag(m, M_DONTWAIT))
				goto drop;
			error = bus_dmamap_load_mbuf(sc->sc_dmatag, map, m,
			    BUS_DMA_NOWAIT);
			if (error != 0)
				goto drop;
		}

		if ((sc->sc_tx_cnt + map->dm_nsegs) > (GEM_NTXDESC - 2)) {
			bus_dmamap_unload(sc->sc_dmatag, map);
			ifq_deq_rollback(&ifp->if_snd, m);
			ifq_set_oactive(&ifp->if_snd);
			break;
a1728 3
		/* We are now committed to transmitting the packet. */
		ifq_deq_commit(&ifp->if_snd, m);

a1729 4
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
d1738 1
a1738 1
			GEM_DMA_WRITE(sc, &sc->sc_txdescs[frag].gd_addr,
d1745 1
a1745 1
			GEM_DMA_WRITE(sc, &sc->sc_txdescs[frag].gd_flags,
d1748 1
a1748 1
			    GEM_CDTXOFF(frag), sizeof(struct gem_desc),
d1750 4
a1753 3
			cur = frag;
			if (++frag == GEM_NTXDESC)
				frag = 0;
d1756 8
a1763 4
		sc->sc_tx_cnt += map->dm_nsegs;
		sc->sc_txd[sc->sc_tx_prod].sd_map = sc->sc_txd[cur].sd_map;
		sc->sc_txd[cur].sd_map = map;
		sc->sc_txd[cur].sd_mbuf = m;
d1765 1
a1765 2
		bus_space_write_4(sc->sc_bustag, sc->sc_h1, GEM_TX_KICK, frag);
		sc->sc_tx_prod = frag;
d1767 2
a1768 2
		ifp->if_timer = 5;
	}
d1770 2
a1771 1
	return;
d1773 2
a1774 4
 drop:
	ifq_deq_commit(&ifp->if_snd, m);
	m_freem(m);
	ifp->if_oerrors++;
@


1.116
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.115 2015/11/20 03:35:22 dlg Exp $	*/
d531 2
a532 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d839 1
a839 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1637 1
a1637 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1656 1
a1656 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1689 1
a1689 1
			ifp->if_flags |= IFF_OACTIVE;
@


1.115
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.114 2015/10/25 12:48:46 mpi Exp $	*/
a52 1
#include <net/if_dl.h>
@


1.114
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.113 2015/09/11 13:02:28 stsp Exp $	*/
d1660 1
a1660 1
		IFQ_POLL(&ifp->if_snd, m);
d1688 1
d1694 1
a1694 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d1740 1
a1740 1
	IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.113
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.112 2015/06/24 09:40:54 mpi Exp $	*/
a1492 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1502 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.112
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.111 2015/03/14 03:38:47 jsg Exp $	*/
d1318 1
a1318 1
	int instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
d1326 1
a1326 1
		printf("gem_mii_statchg: status change: phy = %d\n", instance);
@


1.111
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.110 2015/02/09 03:09:57 dlg Exp $	*/
a998 2

		ifp->if_ipackets++;
@


1.110
log
@tweak the new if_input function so it takes an mbuf_list instead
of a single mbuf. this forces us to batch work between the hardware
rx handlers and the stack.

this includes a converstion of bge from ether_input to if_input.

ok claudio@@ pelikan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.109 2015/02/08 06:02:03 mpi Exp $	*/
a67 1
#include <dev/mii/mii_bitbang.h>
@


1.109
log
@Convert to if_input().

ok pelikan@@, reyk@@, blambert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.108 2014/12/22 02:28:51 tedu Exp $	*/
d948 1
d1004 1
a1004 1
		if_input(ifp, m);
d1014 2
@


1.108
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.107 2014/12/19 22:44:58 guenther Exp $	*/
a1000 1
		m->m_pkthdr.rcvif = ifp;
d1003 1
a1003 7
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif /* NBPFILTER > 0 */

		/* Pass it on. */
		ether_input_mbuf(ifp, m);
@


1.107
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.106 2014/08/27 05:54:15 dlg Exp $	*/
a1510 1
#ifdef INET
a1512 1
#endif
@


1.106
log
@rxr ioctl handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.105 2014/07/22 13:12:12 mpi Exp $	*/
d50 1
a50 2

#include <machine/endian.h>
@


1.105
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.104 2014/07/08 05:35:18 dlg Exp $	*/
d1536 5
@


1.104
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.103 2014/04/22 15:52:05 naddy Exp $	*/
a56 1
#ifdef INET
a57 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a58 3
#include <netinet/tcp.h>
#include <netinet/udp.h>
#endif
@


1.103
log
@Remove RX checksum offloading support.  The chip is too limited, and
examining higher protocol layers to adjust the checksum and calculate
the pseudo-header in the driver is too complex to be worthwhile.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.102 2014/03/14 11:04:24 dlg Exp $	*/
a233 3
	/* Hardware reads RX descriptors in multiples of four. */
	m_clsetwms(ifp, MCLBYTES, 4, GEM_NRXDESC - 4);

d520 1
a520 1
	sc->sc_rx_prod = sc->sc_rx_cons = sc->sc_rx_cnt = 0;
d697 2
d959 2
a960 1
	for (i = sc->sc_rx_cons; sc->sc_rx_cnt > 0; i = GEM_NEXTRX(i)) {
d980 1
a980 1
		sc->sc_rx_cnt--;
d1034 4
a1037 1
	while (sc->sc_rx_cnt < (GEM_NRXDESC - 4)) {
d1041 1
d1054 1
a1054 1
	m = MCLGETI(NULL, M_DONTWAIT, &sc->sc_arpcom.ac_if, MCLBYTES);
a1079 1
	sc->sc_rx_cnt++;
@


1.102
log
@use lemtoh64 and htolem64 for reading and writing entries in the rings.

tested on sparc64 and powerpc with and without the MI backends for the
lem ops enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.101 2013/08/08 16:01:34 kettenis Exp $	*/
a122 1
void		gem_rxcksum(struct mbuf *, u_int64_t);
a812 3
	/* RX TCP/UDP checksum offset */
	v |= ((ETHER_HDR_LEN + sizeof(struct ip)) <<
	    GEM_RX_CONFIG_CXM_START_SHFT);
a946 89
 * RX TCP/UDP checksum
 */
void
gem_rxcksum(struct mbuf *m, u_int64_t rxstat)
{
	struct ether_header *eh;
	struct ip *ip;
	struct udphdr *uh;
	int32_t hlen, len, pktlen;
	u_int16_t cksum, *opts;
	u_int32_t temp32;
	union pseudoh {
		struct hdr {
			u_int16_t len;
			u_int8_t ttl;
			u_int8_t proto;
			u_int32_t src;
			u_int32_t dst;
		} h;
		u_int16_t w[6];
	} ph;

	pktlen = m->m_pkthdr.len;
	if (pktlen < sizeof(struct ether_header))
		return;
	eh = mtod(m, struct ether_header *);
	if (eh->ether_type != htons(ETHERTYPE_IP))
		return;
	ip = (struct ip *)(eh + 1);
	if (ip->ip_v != IPVERSION)
		return;

	hlen = ip->ip_hl << 2;
	pktlen -= sizeof(struct ether_header);
	if (hlen < sizeof(struct ip))
		return;
	if (ntohs(ip->ip_len) < hlen)
		return;
	if (ntohs(ip->ip_len) != pktlen) 
		return;
	if (ip->ip_off & htons(IP_MF | IP_OFFMASK))
		return;	/* can't handle fragmented packet */

	switch (ip->ip_p) {
	case IPPROTO_TCP:
		if (pktlen < (hlen + sizeof(struct tcphdr)))
			return;
		break;
	case IPPROTO_UDP:
		if (pktlen < (hlen + sizeof(struct udphdr)))
			return;
		uh = (struct udphdr *)((caddr_t)ip + hlen);
		if (uh->uh_sum == 0)
			return; /* no checksum */
		break;
	default:
		return;
	}

	cksum = htons(~(rxstat & GEM_RD_CHECKSUM));
	/* cksum fixup for IP options */
	len = hlen - sizeof(struct ip);
	if (len > 0) {
		opts = (u_int16_t *)(ip + 1);
		for (; len > 0; len -= sizeof(u_int16_t), opts++) {
			temp32 = cksum - *opts;
			temp32 = (temp32 >> 16) + (temp32 & 65535);
			cksum = temp32 & 65535;
		}
	}

	ph.h.len = htons(ntohs(ip->ip_len) - hlen);
	ph.h.ttl = 0;
	ph.h.proto = ip->ip_p;
	ph.h.src = ip->ip_src.s_addr;
	ph.h.dst = ip->ip_dst.s_addr;
	temp32 = cksum;
	opts = &ph.w[0];
	temp32 += opts[0] + opts[1] + opts[2] + opts[3] + opts[4] + opts[5];
	temp32 = (temp32 >> 16) + (temp32 & 65535);
	temp32 += (temp32 >> 16);
	cksum = ~temp32;
	if (cksum == 0) {
		m->m_pkthdr.csum_flags |=
			M_TCP_CSUM_IN_OK | M_UDP_CSUM_IN_OK;
	}
}

/*
a1009 2

		gem_rxcksum(m, rxstat);	
@


1.101
log
@Turns out neither the flow control diff nor the RX checksum offload diff
is responsible for the hangs seen by Henning.  So put them back.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.100 2013/07/25 19:50:56 kettenis Exp $	*/
d1059 1
a1059 1
		rxstat = GEM_DMA_READ(sc, sc->sc_rxdescs[i].gd_flags);
d1089 1
a1089 1
				GEM_DMA_READ(sc, sc->sc_rxdescs[i].gd_flags));
d1091 1
a1091 1
				GEM_DMA_READ(sc, sc->sc_rxdescs[i].gd_addr));
d1814 2
a1815 2
			sc->sc_txdescs[frag].gd_addr =
			    GEM_DMA_WRITE(sc, map->dm_segs[i].ds_addr);
d1821 2
a1822 2
			sc->sc_txdescs[frag].gd_flags =
			    GEM_DMA_WRITE(sc, flags);
@


1.100
log
@Backout flow control support (rev 1.97) and RX TCP/UDP checksum offload
support (rev 1.98).  There is strong evidence that one of these causes hangs
on the Sun ERI as found on a v120.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.99 2013/03/09 17:57:00 mpi Exp $	*/
d59 2
d62 2
d123 1
d141 1
a141 1
	int i, error, phyad;
d255 2
d275 1
a275 1
		    MII_OFFSET_ANY, 0);
d304 1
a304 1
		    MII_OFFSET_ANY, 0);
d326 2
d329 1
a329 1
		    MII_OFFSET_ANY, MIIF_NOISOLATE);
d814 3
a816 1

d920 2
a921 2
	/* Un-pause stuff */
	bus_space_write_4(t, h, GEM_MAC_SEND_PAUSE_CMD, 0);
d951 89
d1104 2
d1466 11
@


1.99
log
@Always use the internal PHY on Apple variants, from FreeBSD. This unbreaks
gem(4) on some PowerMac G5.

tested by kirby@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.98 2012/12/01 10:04:58 brad Exp $	*/
a58 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a59 2
#include <netinet/tcp.h>
#include <netinet/udp.h>
a118 1
void		gem_rxcksum(struct mbuf *, u_int64_t);
d136 1
a136 1
	int i, error, mii_flags, phyad;
a249 2
	mii_flags = MIIF_DOPAUSE;

d268 1
a268 1
		    MII_OFFSET_ANY, mii_flags);
d297 1
a297 1
		    MII_OFFSET_ANY, mii_flags);
a318 2
		mii_flags |= MIIF_NOISOLATE;

d320 1
a320 1
		    MII_OFFSET_ANY, mii_flags);
d805 1
a805 3
	/* RX TCP/UDP checksum offset */
	v |= ((ETHER_HDR_LEN + sizeof(struct ip)) <<
	    GEM_RX_CONFIG_CXM_START_SHFT);
d909 2
a910 2
	/* Set XOFF PAUSE time */
	bus_space_write_4(t, h, GEM_MAC_SEND_PAUSE_CMD, 0x1bf0);
a939 89
 * RX TCP/UDP checksum
 */
void
gem_rxcksum(struct mbuf *m, u_int64_t rxstat)
{
	struct ether_header *eh;
	struct ip *ip;
	struct udphdr *uh;
	int32_t hlen, len, pktlen;
	u_int16_t cksum, *opts;
	u_int32_t temp32;
	union pseudoh {
		struct hdr {
			u_int16_t len;
			u_int8_t ttl;
			u_int8_t proto;
			u_int32_t src;
			u_int32_t dst;
		} h;
		u_int16_t w[6];
	} ph;

	pktlen = m->m_pkthdr.len;
	if (pktlen < sizeof(struct ether_header))
		return;
	eh = mtod(m, struct ether_header *);
	if (eh->ether_type != htons(ETHERTYPE_IP))
		return;
	ip = (struct ip *)(eh + 1);
	if (ip->ip_v != IPVERSION)
		return;

	hlen = ip->ip_hl << 2;
	pktlen -= sizeof(struct ether_header);
	if (hlen < sizeof(struct ip))
		return;
	if (ntohs(ip->ip_len) < hlen)
		return;
	if (ntohs(ip->ip_len) != pktlen) 
		return;
	if (ip->ip_off & htons(IP_MF | IP_OFFMASK))
		return;	/* can't handle fragmented packet */

	switch (ip->ip_p) {
	case IPPROTO_TCP:
		if (pktlen < (hlen + sizeof(struct tcphdr)))
			return;
		break;
	case IPPROTO_UDP:
		if (pktlen < (hlen + sizeof(struct udphdr)))
			return;
		uh = (struct udphdr *)((caddr_t)ip + hlen);
		if (uh->uh_sum == 0)
			return; /* no checksum */
		break;
	default:
		return;
	}

	cksum = htons(~(rxstat & GEM_RD_CHECKSUM));
	/* cksum fixup for IP options */
	len = hlen - sizeof(struct ip);
	if (len > 0) {
		opts = (u_int16_t *)(ip + 1);
		for (; len > 0; len -= sizeof(u_int16_t), opts++) {
			temp32 = cksum - *opts;
			temp32 = (temp32 >> 16) + (temp32 & 65535);
			cksum = temp32 & 65535;
		}
	}

	ph.h.len = htons(ntohs(ip->ip_len) - hlen);
	ph.h.ttl = 0;
	ph.h.proto = ip->ip_p;
	ph.h.src = ip->ip_src.s_addr;
	ph.h.dst = ip->ip_dst.s_addr;
	temp32 = cksum;
	opts = &ph.w[0];
	temp32 += opts[0] + opts[1] + opts[2] + opts[3] + opts[4] + opts[5];
	temp32 = (temp32 >> 16) + (temp32 & 65535);
	temp32 += (temp32 >> 16);
	cksum = ~temp32;
	if (cksum == 0) {
		m->m_pkthdr.csum_flags |=
			M_TCP_CSUM_IN_OK | M_UDP_CSUM_IN_OK;
	}
}

/*
a1003 2
		gem_rxcksum(m, rxstat);	

a1363 11

	/*
	 * 802.3x flow control
	 */
	v = bus_space_read_4(t, mac, GEM_MAC_CONTROL_CONFIG);
	v &= ~(GEM_MAC_CC_RX_PAUSE | GEM_MAC_CC_TX_PAUSE);
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_ETH_RXPAUSE) != 0)
		v |= GEM_MAC_CC_RX_PAUSE;
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_ETH_TXPAUSE) != 0)
		v |= GEM_MAC_CC_TX_PAUSE;
	bus_space_write_4(t, mac, GEM_MAC_CONTROL_CONFIG, v);
@


1.98
log
@Add RX TCP/UDP checksum offload support.

ok naddy@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.97 2012/10/22 05:05:57 brad Exp $	*/
d278 1
a278 1
	/* 
d280 2
d284 2
a285 1
	if (child == NULL && sc->sc_mif_config & GEM_MIF_CONFIG_MDI0) {
@


1.97
log
@Add flow control support.

Tested with Apple/Sun gem(4) with and without flow control (Sun ERI/Apple GEM
with FastE PHY).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.96 2009/10/15 17:54:54 deraadt Exp $	*/
d59 2
d62 2
d123 1
d811 3
a813 1

d948 89
d1100 2
@


1.96
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.95 2009/08/10 20:29:54 deraadt Exp $	*/
d136 1
a136 1
	int i, error, phyad;
d250 2
d270 1
a270 1
		    MII_OFFSET_ANY, 0);
d296 1
a296 1
		    MII_OFFSET_ANY, 0);
d318 2
d321 1
a321 1
		    MII_OFFSET_ANY, MIIF_NOISOLATE);
d910 2
a911 2
	/* Un-pause stuff */
	bus_space_write_4(t, h, GEM_MAC_SEND_PAUSE_CMD, 0);
d1365 11
@


1.95
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.94 2009/08/09 11:40:58 deraadt Exp $	*/
d83 1
a83 1
void		gem_stop(struct ifnet *);
d380 34
d519 1
a519 1
gem_stop(struct ifnet *ifp)
d535 2
a536 1
	mii_down(&sc->sc_mii);
d538 3
a540 2
	gem_reset_rx(sc);
	gem_reset_tx(sc);
d747 1
a747 1
	gem_stop(ifp);
d1115 3
d1508 1
a1508 1
				gem_stop(ifp);
@


1.94
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.93 2009/08/03 11:09:10 sthen Exp $	*/
a86 1
void		gem_shutdown(void *);
a347 4
	sc->sc_sh = shutdownhook_establish(gem_shutdown, sc);
	if (sc->sc_sh == NULL)
		panic("gem_config: can't establish shutdownhook");

a1492 10
}


void
gem_shutdown(void *arg)
{
	struct gem_softc *sc = (struct gem_softc *)arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	gem_stop(ifp);
@


1.93
log
@Comment fixes and code tidy-up (whitespace and more consistent
numeric values) from Brad. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.92 2009/07/18 14:42:47 sthen Exp $	*/
d1009 2
a1010 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
a1011 6

	MCLGETI(m, M_DONTWAIT, &sc->sc_arpcom.ac_if, MCLBYTES);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}
@


1.92
log
@Remove redundant code for setting the maximum frame receive size
and fix the appropriate code in gem_init_regs(). From Brad,
tested by Brad (sparc64), todd@@ (macppc).
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.91 2009/07/18 12:56:16 sthen Exp $	*/
d783 2
a784 2
	    (   (sc->sc_rxfifosize / 256) << 12));
	bus_space_write_4(t, h, GEM_RX_BLANKING, (6<<12)|6);
d824 4
a827 5

		/* Wooo.  Magic values. */
		bus_space_write_4(t, h, GEM_MAC_IPG0, 0);
		bus_space_write_4(t, h, GEM_MAC_IPG1, 8);
		bus_space_write_4(t, h, GEM_MAC_IPG2, 4);
d834 2
a835 2
		bus_space_write_4(t, h, GEM_MAC_PREAMBLE_LEN, 0x7);
		bus_space_write_4(t, h, GEM_MAC_JAM_SIZE, 0x4);
a836 1
		/* Dunno.... */
d845 1
@


1.91
log
@Simplify receive filter handling, from Brad.
Tested by Brad on sparc64, todd@@ on macppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.90 2009/03/29 11:53:47 kettenis Exp $	*/
a702 1
	u_int max_frame_size;
a731 3
	max_frame_size = ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN;
	v = (max_frame_size) | (0x2000 << 16) /* Burst size */;
	bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME, v);
d832 2
a833 2
		v = ETHER_MAX_LEN | (0x2000 << 16) /* Burst size */;
		bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME, v);
@


1.90
log
@Remove unused prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.89 2009/03/22 21:46:31 kettenis Exp $	*/
d104 1
a104 1
void		gem_setladrf(struct gem_softc *);
d738 1
a738 1
	gem_setladrf(sc);
d812 1
a812 1
	ifp->if_timer = 0;
d1480 1
a1480 1
				gem_setladrf(sc);
d1503 1
a1503 1
			gem_setladrf(sc);
a1520 3
/*
 * Set up the logical address filter.
 */
d1522 1
a1522 1
gem_setladrf(struct gem_softc *sc)
d1525 1
a1527 1
	struct arpcom *ac = &sc->sc_arpcom;
d1530 1
a1530 1
	u_int32_t crc, hash[16], v;
d1533 2
a1534 10
	/* Get current RX configuration */
	v = bus_space_read_4(t, h, GEM_MAC_RX_CONFIG);


	/*
	 * Turn off promiscuous mode, promiscuous group mode (all multicast),
	 * and hash filter.  Depending on the case, the right bit will be
	 * enabled.
	 */
	v &= ~(GEM_MAC_RX_PROMISCUOUS|GEM_MAC_RX_HASH_FILTER|
d1536 1
d1538 1
a1538 3
	if ((ifp->if_flags & IFF_PROMISC) != 0) {
		/* Turn on promiscuous mode */
		v |= GEM_MAC_RX_PROMISCUOUS;
d1540 13
a1552 2
		goto chipit;
	}
d1554 1
a1554 7
	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 8 bits as an
	 * index into the 256 bit logical address filter.  The high order 4
	 * bits selects the word, while the other 4 bits select the bit within
	 * the word (where bit 0 is the MSB).
	 */
d1556 3
a1558 3
	/* Clear hash table */
	for (i = 0; i < 16; i++)
		hash[i] = 0;
d1560 4
d1565 2
a1566 16
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 * XXX use the addr filter for this
			 */
			ifp->if_flags |= IFF_ALLMULTI;
			v |= GEM_MAC_RX_PROMISC_GRP;
			goto chipit;
		}
d1568 2
a1569 1
		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);
d1571 2
a1572 2
		/* Just want the 8 most significant bits. */
		crc >>= 24;
d1574 6
a1579 4
		/* Set the corresponding bit in the filter. */
		hash[crc >> 4] |= 1 << (15 - (crc & 15));

		ETHER_NEXT_MULTI(step, enm);
d1582 1
a1582 12
	v |= GEM_MAC_RX_HASH_FILTER;
	ifp->if_flags &= ~IFF_ALLMULTI;

	/* Now load the hash table into the chip (if we are using it) */
	for (i = 0; i < 16; i++) {
		bus_space_write_4(t, h,
		    GEM_MAC_HASH0 + i * (GEM_MAC_HASH1-GEM_MAC_HASH0),
		    hash[i]);
	}

chipit:
	bus_space_write_4(t, h, GEM_MAC_RX_CONFIG, v);
@


1.89
log
@Add workaround for RX MAC/FIFO hangs on ERI.  Tested by matthieu@@ and naddy@@.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.88 2009/03/20 23:29:47 kettenis Exp $	*/
a115 1
struct mbuf	*gem_get(struct gem_softc *, int, int);
@


1.88
log
@Unconditionally drain the RX ring when stpping the chip.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.87 2009/01/27 09:17:51 dlg Exp $	*/
d100 1
d355 1
a1051 1

d1126 1
a1126 1
		if (rxstat & GEM_MAC_RX_OVERFLOW)
d1128 15
d1152 30
@


1.87
log
@make drivers tell the mclgeti allocator what their maximum ring size is
to prevent the hwm growing beyond that. this allows the livelock mitigation
to do something where the hwm used to grow beyond twice the rx rings size.

ok kettenis@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.86 2008/12/14 21:31:50 kettenis Exp $	*/
d83 1
a83 1
void		gem_stop(struct ifnet *, int);
d489 1
a489 1
gem_stop(struct ifnet *ifp, int disable)
d525 1
a525 2
	if (disable)
		gem_rxdrain(sc);
d716 1
a716 1
	gem_stop(ifp, 0);
d1440 1
a1440 1
				gem_stop(ifp, 1);
d1473 1
a1473 1
	gem_stop(ifp, 1);
@


1.86
log
@Switch gem(4) over to using MCLGETI when allocating mbufs for the rx ring.

help from dlg@@, tested by a few, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.85 2008/12/10 20:37:48 brad Exp $	*/
d232 1
a232 1
	m_clsetlwm(ifp, MCLBYTES, 4);
@


1.85
log
@Replace m_free() with m_freem() in foo_start() to ensure that upon error
the full mbuf chain is freed.

ok claudio@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.84 2008/11/28 02:44:17 brad Exp $	*/
d101 1
d231 3
d482 1
d638 1
a638 2
	struct gem_rxsoft *rxs;
	int i, error;
d655 2
a656 15
		rxs = &sc->sc_rxsoft[i];
		if (rxs->rxs_mbuf == NULL) {
			if ((error = gem_add_rxbuf(sc, i)) != 0) {
				printf("%s: unable to allocate or map rx "
				    "buffer %d, error = %d\n",
				    sc->sc_dev.dv_xname, i, error);
				/*
				 * XXX Should attempt to run with fewer receive
				 * XXX buffers instead of just failing.
				 */
				gem_rxdrain(sc);
				return (1);
			}
		} else
			GEM_INIT_RXDESC(sc, i);
d658 1
a658 1
	sc->sc_rxptr = 0;
a803 1

d805 1
a805 1
	bus_space_write_4(t, h, GEM_RX_KICK, GEM_NRXDESC-4);
d924 1
a924 1
	for (i = sc->sc_rxptr;; i = GEM_NEXTRX(i)) {
d933 1
a933 3
			/*
			 * We have processed all of the receive buffers.
			 */
d937 9
d947 1
d952 1
a952 1
			GEM_INIT_RXDESC(sc, i);
a955 2
		bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
		    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
a968 13
		/*
		 * Allocate a new mbuf cluster.  If that fails, we are
		 * out of memory, and must drop the packet and recycle
		 * the buffer that's already attached to this descriptor.
		 */
		m = rxs->rxs_mbuf;
		if (gem_add_rxbuf(sc, i) != 0) {
			ifp->if_ierrors++;
			GEM_INIT_RXDESC(sc, i);
			bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
			    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
			continue;
		}
a975 4
		/*
		 * Pass this up to any BPF listeners, but only
		 * pass it up the stack if its for us.
		 */
d985 3
a987 2
	sc->sc_rxptr = i;
	bus_space_write_4(t, h, GEM_RX_KICK, i);
d989 2
a990 2
	DPRINTF(sc, ("gem_rint: done sc->rxptr %d, complete %d\n",
		sc->sc_rxptr, bus_space_read_4(t, h, GEM_RX_COMPLETION)));
d995 8
d1018 1
a1018 1
	MCLGET(m, M_DONTWAIT);
d1023 1
a1029 3
	if (rxs->rxs_mbuf != NULL)
		bus_dmamap_unload(sc->sc_dmatag, rxs->rxs_dmamap);

d1032 1
a1032 2
	error = bus_dmamap_load(sc->sc_dmatag, rxs->rxs_dmamap,
	    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
d1045 3
d1126 1
a1126 5
		/*
		 * On some chip revisions GEM_MAC_RX_OVERFLOW happen often
		 * due to a silicon bug so handle them silently.
		 */
		if (rxstat & GEM_MAC_RX_OVERFLOW) {
a1127 2
			gem_init(ifp);
		}
@


1.84
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.83 2008/11/26 18:34:31 kettenis Exp $	*/
d1716 1
a1716 1
	m_free(m);
@


1.83
log
@Use m_defrag instead of collapsing mbufs ourselves.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.82 2008/11/07 18:03:52 brad Exp $	*/
a1465 25
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				gem_setladrf(sc);
			error = 0;
		}
		break;

d1473 6
@


1.82
log
@Simplify the interface flag handling in the ioctl handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.81 2008/11/07 18:00:31 brad Exp $	*/
d1645 1
a1645 1
	struct mbuf *m, *m0;
a1665 1
		m0 = NULL;
d1673 1
a1673 2
			MGETHDR(m0, M_DONTWAIT, MT_DATA);
			if (m0 == NULL)
d1675 1
a1675 10
			if (m->m_pkthdr.len > MHLEN) {
				MCLGET(m0, M_DONTWAIT);
				if (!(m0->m_flags & M_EXT)) {
					m_freem(m0);
					goto drop;
				}
			}
			m_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));
			m0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;
			error = bus_dmamap_load_mbuf(sc->sc_dmatag, map, m0,
d1677 1
a1677 2
			if (error != 0) {
				m_freem(m0);
a1678 1
			}
a1683 2
			if (m0 != NULL)
				m_free(m0);
a1687 1

a1688 4
		if (m0 != NULL) {
			m_free(m);
			m = m0;
		}
@


1.81
log
@Remove storing the Ethernet header in the receve interrupt handler, the
disabled code that used to use this was removed 7 years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.80 2008/11/07 17:37:59 brad Exp $	*/
d1453 1
a1453 3
			if ((ifp->if_flags & IFF_RUNNING) &&
			    ((ifp->if_flags ^ sc->sc_if_flags) &
			     (IFF_ALLMULTI | IFF_PROMISC)) != 0)
d1455 2
a1456 4
			else {
				if ((ifp->if_flags & IFF_RUNNING) == 0)
					gem_init(ifp);
			}
a1460 2
		sc->sc_if_flags = ifp->if_flags;

@


1.80
log
@- According to the Apple GMAC driver, the GEM ASIC specification and
  the OpenSolaris eri(7D) the TX FIFO threshold has to be set to 0x4ff
  for the Gigabit variants and 0x100 for the ERI in order to avoid TX
  underruns.
- Turn on workarounds for silicon bugs in the Apple GMAC variants.
  This was based on information obtained from the Darwin GMAC and Linux GEM
  drivers.
- Turn on "infinite" (i.e. maximum 31 * 64 bytes in length) DMA bursts.

From FreeBSD

Tested by a few users with Apple GMAC's and Sun ERI.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.79 2008/10/02 20:21:13 brad Exp $	*/
a928 1
	struct ether_header *eh;
a988 1
		eh = mtod(m, struct ether_header *);
@


1.79
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.78 2008/09/10 14:01:22 blambert Exp $	*/
d775 3
a777 3
	bus_space_write_4(t, h, GEM_TX_CONFIG,
		v|GEM_TX_CONFIG_TXDMA_EN|
		((0x4ff<<10)&GEM_TX_CONFIG_TXFIFO_TH));
d892 16
@


1.78
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.77 2008/08/30 07:39:12 brad Exp $	*/
a1425 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

a1426 1

d1489 1
a1489 2
		error = ENOTTY;
		break;
@


1.77
log
@Fix an issue initially reported by drahn@@ with gem(4) where these
drivers can report 2-3x times the number of actual packets being
transmitted by only incrementing the counter for descriptors with
buffers being freed.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.76 2008/08/26 21:06:29 kettenis Exp $	*/
d420 1
a420 1
	timeout_add(&sc->sc_tick_ch, hz);
d818 1
a818 1
	timeout_add(&sc->sc_tick_ch, hz);
@


1.76
log
@Fix a couple of problems that may make gem(4) get stuck:

1. If bus_dmamap_load_mbuf() fails because there are not enough
   segments in the map, defrag the mbuf.

2. If there are not enough free (hardware ring) descriptors, set
   IFF_OACTIVE and keep the packet on the queue.

3. If there is some other resource starvation that makes
   bus_dmamap_load_mbuf() or defragmentation fail, drop the packet.
   Don't set IFF_OACTIVE, since the Tx ring could be empty and we'd be
   stuck.

4. Only pass packets that are actually handed off to the hardware to
   BPF.  Do so before handing them off to the hardware to make sure
   the packet isn't freed behind our back.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.75 2008/05/31 02:41:25 brad Exp $	*/
d1622 1
a1624 1
		ifp->if_opackets++;
@


1.75
log
@Properly set the IFF_OACTIVE flag if all the descriptrs are in use for
the TX ring and clear the flag when some have been freed.

ok dlg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.74 2008/05/09 21:22:44 brad Exp $	*/
a102 1
int		gem_encap(struct gem_softc *, struct mbuf *, u_int32_t *);
a1601 52
int
gem_encap(struct gem_softc *sc, struct mbuf *mhead, u_int32_t *bixp)
{
	u_int64_t flags;
	u_int32_t cur, frag, i;
	bus_dmamap_t map;

	cur = frag = *bixp;
	map = sc->sc_txd[cur].sd_map;

	if (bus_dmamap_load_mbuf(sc->sc_dmatag, map, mhead,
	    BUS_DMA_NOWAIT) != 0) {
		return (ENOBUFS);
	}

	if ((sc->sc_tx_cnt + map->dm_nsegs) > (GEM_NTXDESC - 2)) {
		bus_dmamap_unload(sc->sc_dmatag, map);
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc->sc_dmatag, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	for (i = 0; i < map->dm_nsegs; i++) {
		sc->sc_txdescs[frag].gd_addr =
		    GEM_DMA_WRITE(sc, map->dm_segs[i].ds_addr);
		flags = (map->dm_segs[i].ds_len & GEM_TD_BUFSIZE) |
		    (i == 0 ? GEM_TD_START_OF_PACKET : 0) |
		    ((i == (map->dm_nsegs - 1)) ? GEM_TD_END_OF_PACKET : 0);
		sc->sc_txdescs[frag].gd_flags = GEM_DMA_WRITE(sc, flags);
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_cddmamap,
		    GEM_CDTXOFF(frag), sizeof(struct gem_desc),
		    BUS_DMASYNC_PREWRITE);
		cur = frag;
		if (++frag == GEM_NTXDESC)
			frag = 0;
	}

	sc->sc_tx_cnt += map->dm_nsegs;
	sc->sc_txd[*bixp].sd_map = sc->sc_txd[cur].sd_map;
	sc->sc_txd[cur].sd_map = map;
	sc->sc_txd[cur].sd_mbuf = mhead;

	bus_space_write_4(sc->sc_bustag, sc->sc_h1, GEM_TX_KICK, frag);

	*bixp = frag;

	/* sync descriptors */

	return (0);
}

d1644 5
a1648 2
	struct mbuf *m;
	u_int32_t bix;
d1653 1
a1653 2
	bix = sc->sc_tx_prod;
	while (sc->sc_txd[bix].sd_mbuf == NULL) {
d1658 51
d1718 19
a1736 7
		/*
		 * Encapsulate this packet and start it going...
		 * or fail...
		 */
		if (gem_encap(sc, m, &bix)) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
d1739 8
a1746 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d1750 6
a1755 1
	sc->sc_tx_prod = bix;
@


1.74
log
@- Count excess and late collisions as output errors.
- Count receive errors as input errors.

Based on similar change to the gem(4) driver from NetBSD.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.73 2008/02/10 16:54:23 kettenis Exp $	*/
d1683 2
a1684 2
	gem_start(ifp);

d1688 2
d1723 1
a1723 1
			ifp->if_timer = 2;
@


1.73
log
@Set reserved bits in the TX Configuration Register the value from the Sun docs.
Seems to fix watchdog timeout issues in Sun ERI variants.

tested by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.72 2008/02/08 15:03:36 thib Exp $	*/
d390 1
d393 3
a395 1
	ifp->if_collisions +=
d397 9
a405 3
	    bus_space_read_4(t, mac, GEM_MAC_FIRST_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_EXCESS_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_LATE_COLL_CNT);
d412 4
@


1.72
log
@Return ENOTTY not EINVAL for unsupported ioctl's;

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.71 2008/01/11 22:50:18 kettenis Exp $	*/
d765 1
a765 1
		((0x400<<10)&GEM_TX_CONFIG_TXFIFO_TH));
@


1.71
log
@Fall back on using SERDES if MDI0/MDI1 bits aren't set too.  Fix PCS handling.
Makes the onboard fiber gem(4) in the Sun Fire V880 work.

tested by many; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.70 2007/09/30 11:33:14 kettenis Exp $	*/
d1483 1
a1483 1
		error = EINVAL;
@


1.70
log
@s/NPBFILTER/NBPFILTER/ in #endif comment. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.69 2007/04/19 19:00:01 kettenis Exp $	*/
d300 1
a300 2
	if (child == NULL && sc->sc_variant != GEM_SUN_ERI &&
	    sc->sc_mif_config & (GEM_MIF_CONFIG_MDI0|GEM_MIF_CONFIG_MDI1)) {
a889 13


	/*
	 * Enable MII outputs.  Enable GMII if there is a gigabit PHY.
	 */
	sc->sc_mif_config = bus_space_read_4(t, h, GEM_MIF_CONFIG);
	v = GEM_MAC_XIF_TX_MII_ENA;
	if (sc->sc_mif_config & GEM_MIF_CONFIG_MDI1) {
		v |= GEM_MAC_XIF_FDPLX_LED;
		if (sc->sc_flags & GEM_GIGABIT)
			v |= GEM_MAC_XIF_GMII_MODE;
	}
	bus_space_write_4(t, h, GEM_MAC_XIF_CONFIG, v);
d1266 19
a1284 26
 /* We should really calculate all this rather than rely on defaults */
	v = bus_space_read_4(t, mac, GEM_MAC_XIF_CONFIG);
	v = GEM_MAC_XIF_LINK_LED;
	v |= GEM_MAC_XIF_TX_MII_ENA;
	/* If an external transceiver is connected, enable its MII drivers */
	sc->sc_mif_config = bus_space_read_4(t, mac, GEM_MIF_CONFIG);
	if ((sc->sc_mif_config & GEM_MIF_CONFIG_MDI1) != 0) {
		/* External MII needs echo disable if half duplex. */
		if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0)
			/* turn on full duplex LED */
			v |= GEM_MAC_XIF_FDPLX_LED;
 		else
	 		/* half duplex -- disable echo */
		 	v |= GEM_MAC_XIF_ECHO_DISABL;

		switch (IFM_SUBTYPE(sc->sc_mii.mii_media_active)) {
		case IFM_1000_T:  /* Gigabit using GMII interface */
		case IFM_1000_SX:
			v |= GEM_MAC_XIF_GMII_MODE;
			break;
		default:
			v &= ~GEM_MAC_XIF_GMII_MODE;
		}
	} else
		/* Internal MII needs buf enable */
		v |= GEM_MAC_XIF_MII_BUF_ENA;
d1331 1
d1342 3
d1347 1
d1365 4
a1368 1
	if (reg == GEM_MII_ANAR) {
@


1.69
log
@Cleanup phy selection code, simplifying the code considerably.  Attach only
one phy on Sun ERI; gets rid of the duplicate phy on the blade1k.

tested by many, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.68 2006/12/21 22:13:36 jason Exp $	*/
d987 1
a987 1
#endif /* NPBFILTER > 0 */
@


1.68
log
@betetr yet, just nuke sc_enaddr all together, just fill in arpcom and
everybody is happy
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.67 2006/11/25 17:47:40 brad Exp $	*/
d129 1
a129 3
 * gem_config:
 *
 *	Attach a Gem interface to the system.
d137 1
a137 1
	int i, error;
d241 5
d248 46
a293 6
	if (sc->sc_tcvr == -1)
		mii_attach(&sc->sc_dev, mii, 0xffffffff, MII_PHY_ANY,
				MII_OFFSET_ANY, 0);
	else
		mii_attach(&sc->sc_dev, mii, 0xffffffff, sc->sc_tcvr,
				MII_OFFSET_ANY, 0);
d295 4
d300 1
a300 1
	if (child == NULL &&
a301 4
		/* 
		 * Try the external PCS SERDES if we didn't find any
		 * MII devices.
		 */
a325 45
		 * Walk along the list of attached MII devices and
		 * establish an `MII instance' to `phy number'
		 * mapping. We'll use this mapping in media change
		 * requests to determine which phy to use to program
		 * the MIF configuration register.
		 */
		for (; child != NULL; child = LIST_NEXT(child, mii_list)) {
			/*
			 * Note: we support just two PHYs: the built-in
			 * internal device and an external on the MII
			 * connector.
			 */
			if (child->mii_phy > 1 || child->mii_inst > 1) {
				printf("%s: cannot accommodate MII device %s"
				       " at phy %d, instance %d\n",
				       sc->sc_dev.dv_xname,
				       child->mii_dev.dv_xname,
				       child->mii_phy, child->mii_inst);
				continue;
			}

			sc->sc_phys[child->mii_inst] = child->mii_phy;
		}

		/*
		 * Now select and activate the PHY we will use.
		 *
		 * The order of preference is External (MDI1),
		 * Internal (MDI0), Serial Link (no MII).
		 */
		if (sc->sc_phys[1]) {
#ifdef GEM_DEBUG
			printf("using external phy\n");
#endif
			sc->sc_mif_config |= GEM_MIF_CONFIG_PHY_SEL;
		} else {
#ifdef GEM_DEBUG
			printf("using internal phy\n");
#endif
			sc->sc_mif_config &= ~GEM_MIF_CONFIG_PHY_SEL;
		}
		bus_space_write_4(sc->sc_bustag, sc->sc_h1, GEM_MIF_CONFIG, 
			sc->sc_mif_config);

		/*
d332 1
a332 4
	/*
	 * If we support GigE media, we support jumbo frames too.
	 * Unless we are Apple.
	 */
d449 1
a449 3
 * gem_rxdrain:
 *
 *	Drain the receive queue.
d579 1
a579 1
 * disable receiver.
d598 1
a598 1
 * disable transmitter.
d1005 1
a1005 3
 * gem_add_rxbuf:
 *
 *	Add a receive buffer to the indicated descriptor.
a1170 9
	if (GEM_IS_APPLE(sc)) {
		if (sc->sc_variant == GEM_APPLE_K2_GMAC)
			sc->sc_tcvr = 1;
		else
			sc->sc_tcvr = 0;
	} else {
		sc->sc_tcvr = -1;
	}

a1235 10
#if 0
	/* Select the desired PHY in the MIF configuration register */
	v = bus_space_read_4(t, mif, GEM_MIF_CONFIG);
	/* Clear PHY select bit */
	v &= ~GEM_MIF_CONFIG_PHY_SEL;
	if (phy == GEM_PHYAD_EXTERNAL)
		/* Set PHY select bit to get at external device */
		v |= GEM_MIF_CONFIG_PHY_SEL;
	bus_space_write_4(t, mif, GEM_MIF_CONFIG, v);
#endif
d1266 1
a1266 2
		printf("gem_mii_statchg: status change: phy = %d\n",
		    sc->sc_phys[instance]);
a1267 1

@


1.67
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.66 2006/11/25 04:52:49 brad Exp $	*/
a141 2
	bcopy(sc->sc_enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);

d216 1
a216 1
	printf(", address %s\n", ether_sprintf(sc->sc_enaddr));
a736 1
	bcopy(sc->sc_arpcom.ac_enaddr, sc->sc_enaddr, ETHER_ADDR_LEN);
d851 1
a851 1
		    ((sc->sc_enaddr[5]<<8)|sc->sc_enaddr[4])&0x3ff);
d893 1
a893 1
		(sc->sc_enaddr[4]<<8) | sc->sc_enaddr[5]);
d895 1
a895 1
		(sc->sc_enaddr[2]<<8) | sc->sc_enaddr[3]);
d897 1
a897 1
		(sc->sc_enaddr[0]<<8) | sc->sc_enaddr[1]);
@


1.66
log
@fix use of gem_bitwait().
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.65 2006/11/25 02:12:04 brad Exp $	*/
a127 1

d134 1
a134 2
gem_config(sc)
	struct gem_softc *sc;
d391 1
a391 2
gem_tick(arg)
	void *arg;
d420 2
a421 6
gem_bitwait(sc, h, r, clr, set)
	struct gem_softc *sc;
	bus_space_handle_t h;
	int r;
	u_int32_t clr;
	u_int32_t set;
d436 1
a436 2
gem_reset(sc)
	struct gem_softc *sc;
d920 1
a920 2
gem_rint(sc)
	struct gem_softc *sc;
d1065 1
a1065 3
gem_eint(sc, status)
	struct gem_softc *sc;
	u_int status;
d1079 1
a1079 2
gem_pint(sc)
	struct gem_softc *sc;
d1095 1
a1095 2
gem_intr(v)
	void *v;
d1157 1
a1157 2
gem_watchdog(ifp)
	struct ifnet *ifp;
d1178 1
a1178 2
gem_mifinit(sc)
	struct gem_softc *sc;
d1213 1
a1213 3
gem_mii_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
d1243 1
a1243 3
gem_mii_writereg(self, phy, reg, val)
	struct device *self;
	int phy, reg, val;
d1285 1
a1285 2
gem_mii_statchg(dev)
	struct device *dev;
d1343 1
a1343 3
gem_pcs_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
d1380 1
a1380 3
gem_pcs_writereg(self, phy, reg, val)
	struct device *self;
	int phy, reg, val;
d1423 1
a1423 2
gem_mediachange(ifp)
	struct ifnet *ifp;
d1438 1
a1438 3
gem_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d1451 1
a1451 4
gem_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d1539 1
a1539 2
gem_shutdown(arg)
	void *arg;
d1551 1
a1551 2
gem_setladrf(sc)
	struct gem_softc *sc;
d1637 1
a1637 4
gem_encap(sc, mhead, bixp)
	struct gem_softc *sc;
	struct mbuf *mhead;
	u_int32_t *bixp;
d1692 1
a1692 3
gem_tint(sc, status)
	struct gem_softc *sc;
	u_int32_t status;
d1725 1
a1725 2
gem_start(ifp)
	struct ifnet *ifp;
@


1.65
log
@Split the GEM registers into two halfs and provide a bus_space_handle_t
for each. While there, fix a typo in gem_bitwait().

From martin@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.64 2006/11/25 00:26:07 brad Exp $	*/
d547 1
a547 1
	if (!gem_bitwait(sc, h, GEM_RESET, 1, 0))
@


1.64
log
@Fix a copy and pasto.

From martin@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.63 2006/11/11 00:23:21 deraadt Exp $	*/
d93 2
a94 1
int		gem_bitwait(struct gem_softc *, int, u_int32_t, u_int32_t);
d224 1
a224 1
	    bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_RX_FIFO_SIZE);
d263 1
a263 1
		bus_space_write_4(sc->sc_bustag, sc->sc_h,
d266 1
a266 1
		bus_space_write_4(sc->sc_bustag, sc->sc_h,
d270 1
a270 1
		bus_space_write_4(sc->sc_bustag, sc->sc_h,
d328 1
a328 1
		bus_space_write_4(sc->sc_bustag, sc->sc_h, GEM_MIF_CONFIG, 
d399 1
a399 1
	bus_space_handle_t mac = sc->sc_h;
d423 1
a423 1
gem_bitwait(sc, r, clr, set)
d425 1
d434 2
a435 2
		reg = bus_space_read_4(sc->sc_bustag, sc->sc_h, r);
		if ((r & clr) == 0 && (r & set) == set)
d447 1
a447 1
	bus_space_handle_t h = sc->sc_h;
d457 1
a457 1
	if (!gem_bitwait(sc, GEM_RESET, GEM_RESET_RX | GEM_RESET_TX, 0))
d538 1
a538 1
	bus_space_handle_t h = sc->sc_h;
d547 1
a547 1
	if (!gem_bitwait(sc, GEM_RESET, GEM_RESET_RX, 0))
d553 1
a553 1
	bus_space_write_4(t, h, GEM_RESET, GEM_RESET_RX);
d555 1
a555 1
	if (!gem_bitwait(sc, GEM_RESET, GEM_RESET_RX, 0)) {
d570 1
a570 1
	bus_space_handle_t h = sc->sc_h;
d579 1
a579 1
	if (!gem_bitwait(sc, GEM_TX_CONFIG, 1, 0))
d585 1
a585 1
	bus_space_write_4(t, h, GEM_RESET, GEM_RESET_TX);
d587 1
a587 1
	if (!gem_bitwait(sc, GEM_RESET, GEM_RESET_TX, 0)) {
d602 1
a602 1
	bus_space_handle_t h = sc->sc_h;
d611 1
a611 1
	return (gem_bitwait(sc, GEM_MAC_RX_CONFIG, GEM_MAC_RX_ENABLE, 0));
d621 1
a621 1
	bus_space_handle_t h = sc->sc_h;
d630 1
a630 1
	return (gem_bitwait(sc, GEM_MAC_TX_CONFIG, GEM_MAC_TX_ENABLE, 0));
d716 1
a716 1
	bus_space_handle_t h = sc->sc_h;
d839 1
a839 1
	bus_space_handle_t h = sc->sc_h;
d933 1
a933 1
	bus_space_handle_t h = sc->sc_h;
d1094 1
a1094 1
	bus_space_handle_t seb = sc->sc_h;
d1113 1
a1113 1
	bus_space_handle_t seb = sc->sc_h;
d1177 3
a1179 3
		bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_RX_CONFIG),
		bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_MAC_RX_STATUS),
		bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_MAC_RX_CONFIG)));
d1196 1
a1196 1
	bus_space_handle_t mif = sc->sc_h;
d1234 1
a1234 1
	bus_space_handle_t mif = sc->sc_h;
d1266 1
a1266 1
	bus_space_handle_t mif = sc->sc_h;
d1312 1
a1312 1
	bus_space_handle_t mac = sc->sc_h;
d1369 1
a1369 1
	bus_space_handle_t pcs = sc->sc_h;
d1408 1
a1408 1
	bus_space_handle_t pcs = sc->sc_h;
d1590 1
a1590 1
	bus_space_handle_t h = sc->sc_h;
d1714 1
a1714 1
	bus_space_write_4(sc->sc_bustag, sc->sc_h, GEM_TX_KICK, frag);
@


1.63
log
@be silent
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.62 2006/11/10 23:58:47 kettenis Exp $	*/
d545 1
a545 1
	if (!gem_bitwait(sc, GEM_RESET, GEM_RESET_TX, 0))
d553 1
a553 1
	if (!gem_bitwait(sc, GEM_RESET, GEM_RESET_TX, 0)) {
@


1.62
log
@Fix typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.61 2006/11/10 23:56:36 kettenis Exp $	*/
d1077 1
d1079 1
d1097 1
d1100 1
a1100 1

@


1.61
log
@Add support for Sun 1000baseSX cards.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.60 2006/10/17 22:22:49 brad Exp $	*/
d1096 1
a1096 1
		printf("%s: link status changedn", sc->sc_dev.dv_xname);
@


1.60
log
@replace hand rolled code with LIST_FOREACH in gem_mediachange().

ok kettenis@@ "Looks correct to me" krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.59 2006/07/11 00:52:38 brad Exp $	*/
d108 2
d118 1
d256 24
d1085 15
d1116 3
d1345 1
d1355 84
@


1.59
log
@put CRC error message under GEM_DEBUG. this just spews out like crazy
on a heavily loaded hub.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.58 2006/04/15 04:10:06 brad Exp $	*/
d1319 3
a1321 4
		struct mii_softc        *miisc;
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		miisc = LIST_NEXT(miisc, mii_list))
		mii_phy_reset(miisc);
@


1.58
log
@check for IFF_RUNNING being set before calling gem_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.57 2006/03/25 22:41:43 djm Exp $	*/
d927 1
d930 1
@


1.57
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.56 2006/02/21 19:46:52 brad Exp $	*/
a693 5
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return (0);
	}

d1089 1
a1089 2
		if (txstat & (GEM_MAC_TX_UNDERRUN | GEM_MAC_TX_PKT_TOO_LONG)) {
			ifp->if_flags &= ~IFF_RUNNING;
a1090 1
		}
a1104 1
			ifp->if_flags &= ~IFF_RUNNING;
a1132 1
	ifp->if_flags &= ~IFF_RUNNING;
d1363 2
a1364 2
		gem_init(ifp);
		switch (ifa->ifa_addr->sa_family) {
d1366 1
a1366 1
		case AF_INET:
a1367 1
			break;
a1368 3
		default:
			break;
		}
d1377 4
a1380 2
			else
				gem_init(ifp);
@


1.56
log
@remove some commented out and NetBSD-specific code.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.55 2006/02/21 19:34:48 brad Exp $	*/
d979 1
a979 1
			bpf_mtap(ifp->if_bpf, m);
d1659 1
a1659 1
			bpf_mtap(ifp->if_bpf, m);
@


1.55
log
@add missing MTU ioctl switch case.

Noticed by: Ben Lovett <ben at tilderoot dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.54 2006/02/08 22:11:02 brad Exp $	*/
a318 6
#if 0
			if (sc->sc_variant != GEM_APPLE_GMAC)
				sc->sc_ethercom.ec_capabilities
				    |= ETHERCAP_JUMBO_MTU;
#endif

@


1.54
log
@eliminate a reset when configuring the IP address.

tested by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.53 2006/02/05 00:24:26 brad Exp $	*/
d1378 1
a1378 1

a1381 1
			gem_init(ifp);
a1385 1
			gem_init(ifp);
d1407 8
@


1.53
log
@call gem_setladrf() if the NIC is already running and only the
PROMISC or ALLMULTI flags are being adjusted or if adjusting
the multicast addresses instead of doing a full re-init of the
chip.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.52 2005/11/15 19:20:25 brad Exp $	*/
d700 5
d1100 2
a1101 1
		if (txstat & (GEM_MAC_TX_UNDERRUN | GEM_MAC_TX_PKT_TOO_LONG))
d1103 1
d1118 1
d1147 1
@


1.52
log
@add IFQ_SET_MAXLEN().
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.51 2005/11/07 03:20:00 brad Exp $	*/
d1384 10
a1393 22
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			gem_stop(ifp, 1);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			gem_init(ifp);
		} else if ((ifp->if_flags & IFF_UP) != 0) {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			/*gem_stop(sc);*/
			gem_init(ifp);
d1395 2
d1414 1
a1414 1
				gem_init(ifp);
@


1.51
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.50 2005/11/02 02:15:12 brad Exp $	*/
d230 1
@


1.50
log
@sync mbuf before unloading in gem_rxdrain().

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.49 2005/11/02 00:45:15 brad Exp $	*/
d392 1
a392 1
	s = splimp();
d426 1
a426 1
	s = splimp();
d697 1
a697 1
	s = splimp();
d1357 1
a1357 1
	s = splimp();
@


1.49
log
@handle TX underrun and packet too long errors by resetting the chip.

From NetBSD

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.48 2005/10/31 23:53:13 brad Exp $	*/
d453 2
d502 1
a502 1
	if (disable) {
a503 1
	}
@


1.48
log
@- some DEBUG should be GEM_DEBUG
- introduce gem_bitwait() to factor out some of the register wait code

From NetBSD

- remove some statics
- remove parameter names from prototypes

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.47 2005/10/31 18:38:35 brad Exp $	*/
d1066 1
d1088 1
d1092 3
d1098 9
a1106 2

		rxstat &= ~(GEM_MAC_RX_DONE | GEM_MAC_RX_FRAME_CNT);
d1108 1
a1108 2
			struct ifnet *ifp = &sc->sc_arpcom.ac_if;

d1110 3
a1112 6
			ifp->if_ierrors++;
		} else {
			/*
			 * Leave this in here until I figure out what to do
			 * about other errors.
			 */
d1115 1
a1115 1
		}
@


1.47
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.46 2005/10/17 03:03:24 brad Exp $	*/
d89 2
a90 2
void		gem_init_regs(struct gem_softc *sc);
static int	gem_ringsize(int sz);
d93 1
d95 6
a100 6
int		gem_reset_rx(struct gem_softc *sc);
int		gem_reset_tx(struct gem_softc *sc);
int		gem_disable_rx(struct gem_softc *sc);
int		gem_disable_tx(struct gem_softc *sc);
void		gem_rxdrain(struct gem_softc *sc);
int		gem_add_rxbuf(struct gem_softc *sc, int idx);
d105 3
a107 3
static int	gem_mii_readreg(struct device *, int, int);
static void	gem_mii_writereg(struct device *, int, int, int);
static void	gem_mii_statchg(struct device *);
d289 1
a289 1
#ifdef DEBUG
d294 1
a294 1
#ifdef DEBUG
d399 19
a423 1
	int i;
d433 2
a434 9
	for (i=TRIES; i--; delay(100))
		if ((bus_space_read_4(t, h, GEM_RESET) &
			(GEM_RESET_RX|GEM_RESET_TX)) == 0)
			break;
	if ((bus_space_read_4(t, h, GEM_RESET) &
		(GEM_RESET_RX|GEM_RESET_TX)) != 0) {
		printf("%s: cannot reset device\n",
			sc->sc_dev.dv_xname);
	}
a513 1
	int i;
d522 2
a523 7
	for (i = TRIES; i--; delay(100))
		if ((bus_space_read_4(t, h, GEM_RX_CONFIG) & 1) == 0)
			break;
	if ((bus_space_read_4(t, h, GEM_RX_CONFIG) & 1) != 0)
		printf("%s: cannot disable rx dma\n",
			sc->sc_dev.dv_xname);

d530 2
a531 6
	for (i = TRIES; i--; delay(100))
		if ((bus_space_read_4(t, h, GEM_RESET) & GEM_RESET_RX) == 0)
			break;
	if ((bus_space_read_4(t, h, GEM_RESET) & GEM_RESET_RX) != 0) {
		printf("%s: cannot reset receiver\n",
			sc->sc_dev.dv_xname);
a545 1
	int i;
d554 2
a555 7
	for (i = TRIES; i--; delay(100))
		if ((bus_space_read_4(t, h, GEM_TX_CONFIG) & 1) == 0)
			break;
	if ((bus_space_read_4(t, h, GEM_TX_CONFIG) & 1) != 0)
		printf("%s: cannot disable tx dma\n",
			sc->sc_dev.dv_xname);

d562 1
a562 4
	for (i = TRIES; i--; delay(100))
		if ((bus_space_read_4(t, h, GEM_RESET) & GEM_RESET_TX) == 0)
			break;
	if ((bus_space_read_4(t, h, GEM_RESET) & GEM_RESET_TX) != 0) {
a577 1
	int i;
d586 1
a586 5
	for (i = TRIES; i--; delay(100))
		if ((bus_space_read_4(t, h, GEM_MAC_RX_CONFIG) &
			GEM_MAC_RX_ENABLE) == 0)
			return (0);
	return (1);
a596 1
	int i;
d605 1
a605 5
	for (i = TRIES; i--; delay(100))
		if ((bus_space_read_4(t, h, GEM_MAC_TX_CONFIG) &
			GEM_MAC_TX_ENABLE) == 0)
			return (0);
	return (1);
d653 1
a653 1
static int
d1171 1
a1171 1
static int
d1203 1
a1203 1
static void
d1247 1
a1247 1
static void
d1397 1
a1397 1
#ifdef HMEDEBUG
@


1.46
log
@Start using the unused sc_variant to identify the GMAC vendor and chipset
model to the MI part of the driver. On Apple systems only attach the PHY to
location 0, unless using a K2 GMAC, then use location 1.

Tested by drahn@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.45 2005/10/11 23:58:36 brad Exp $	*/
d1500 1
a1500 1
	 * bits select the word, while the other 4 bits select the bit within
@


1.45
log
@have gem strip off the Ethernet FCS before passing it to bpf.

ok krw@@, also tested by Peter Hessler on macppc
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.44 2005/09/10 20:42:32 brad Exp $	*/
d243 6
a248 2
	mii_attach(&sc->sc_dev, mii, 0xffffffff,
			MII_PHY_ANY, MII_OFFSET_ANY, 0);
d1158 9
@


1.44
log
@copy the MAC address from sc_arpcom.ac_enaddr to sc_enaddr in
gem_init() just before calling gem_init_regs() so the proper
MAC address gets programmed into the card (if it has been
changed by say ifconfig lladdr for example).

Noticed and diff tested by: Troex Nevelin <troex at fury dot scancode dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.43 2005/08/01 05:45:03 brad Exp $	*/
d799 1
a799 1
	v |= GEM_MAC_RX_ENABLE;
d962 1
a962 4
		/*
		 * No errors; receive the packet.  Note the Gem
		 * includes the CRC with every packet.
		 */
@


1.43
log
@remove whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.42 2005/07/02 23:10:16 brad Exp $	*/
d735 1
@


1.42
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.41 2005/06/08 17:02:59 henning Exp $	*/
d5 1
a5 1
 * 
d18 1
a18 1
 *  
a37 1
#include "vlan.h"
d40 1
a40 1
#include <sys/systm.h> 
d42 1
a42 1
#include <sys/mbuf.h>   
d62 1
a62 1
#if NBPFILTER > 0 
d64 1
a64 1
#endif 
d230 1
d235 1
a235 1
	mii->mii_readreg = gem_mii_readreg; 
d411 1
a411 1
		if ((bus_space_read_4(t, h, GEM_RESET) & 
d444 1
a444 1
/* 
d590 1
a590 1
	for (i = TRIES; i--; delay(100)) 
d614 1
a614 1
	for (i = TRIES; i--; delay(100)) 
d769 1
a769 1
	bus_space_write_4(t, h, GEM_TX_CONFIG, 
d1222 1
a1222 1
		printf("gem_mii_writereg: phy %d reg %d val %x\n", 
d1305 1
a1305 1
	} else 
@


1.41
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.40 2005/01/15 05:24:11 brad Exp $	*/
d457 7
a486 6

	/*
	 * Mark the interface down and cancel the watchdog timer.
	 */
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
	ifp->if_timer = 0;
@


1.40
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.39 2004/09/27 23:59:27 brad Exp $	*/
a1370 17
#endif
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else {
				memcpy(LLADDR(ifp->if_sadl),
				    ina->x_host.c_host, sizeof(sc->sc_enaddr));
			}	
			/* Set new address. */
			gem_init(ifp);
			break;
		    }
@


1.39
log
@allow for VLAN-sized frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.38 2004/06/20 20:50:41 pvalchev Exp $	*/
d1435 2
a1436 1
			gem_init(ifp);
@


1.38
log
@take 2 times less room in dmesg, prettier too
allocate interrupts early on (before PHY attachment, etc) just like all
other drivers do to allow the above; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.37 2004/02/02 08:40:48 brad Exp $	*/
a66 4
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

d231 1
d735 1
a735 6
	max_frame_size = max(ifp->if_mtu, ETHERMTU);
	max_frame_size += ETHER_HDR_LEN + ETHER_CRC_LEN;
#if 0
	if (sc->sc_ethercom.ec_capenable & ETHERCAP_VLAN_MTU)
		max_frame_size += ETHER_VLAN_ENCAP_LEN;
#endif
@


1.37
log
@Don't return random garbage in the default case; return the smallest ring
descriptor instead.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.35 2003/12/29 23:06:55 brad Exp $	*/
d157 1
a157 1
		printf("%s: unable to allocate control data, error = %d\n",
d166 1
a166 1
		printf("%s: unable to map control data, error = %d\n",
d174 1
a174 1
		printf("%s: unable to create control data DMA map, "
d182 1
a182 1
		printf("%s: unable to load control data DMA map, error = %d\n",
d193 1
a193 1
			printf("%s: unable to create rx DMA map %d, "
d206 1
a206 1
			printf("%s: unable to create tx DMA map %d, "
d220 1
a220 2
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_enaddr));
@


1.36
log
@remove prototypes for non-existant functions.

ok deraadt@@
@
text
@a671 2
	int v;

d674 1
a674 2
		v = GEM_RING_SZ_32;
		break;
d676 1
a676 2
		v = GEM_RING_SZ_64;
		break;
d678 1
a678 2
		v = GEM_RING_SZ_128;
		break;
d680 1
a680 2
		v = GEM_RING_SZ_256;
		break;
d682 1
a682 2
		v = GEM_RING_SZ_512;
		break;
d684 1
a684 2
		v = GEM_RING_SZ_1024;
		break;
d686 1
a686 2
		v = GEM_RING_SZ_2048;
		break;
d688 1
a688 2
		v = GEM_RING_SZ_4096;
		break;
d690 1
a690 2
		v = GEM_RING_SZ_8192;
		break;
d692 2
a693 3
		v = GEM_RING_SZ_32;
		printf("gem: invalid Receive Descriptor ring size\n");
		break;
a694 1
	return (v);
d1196 1
a1196 1
#ifdef GEM_DEBUG1
d1228 1
a1228 1
#ifdef GEM_DEBUG1
@


1.35
log
@no vtophys(), don't need uvm_extern.h anymore.

tested on alpha, i386, macppc and sparc64.

ok millert@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.34 2003/07/15 03:52:30 jason Exp $	*/
a116 2
int		gem_put(struct gem_softc *, int, struct mbuf *);
void		gem_read(struct gem_softc *, int, int);
a119 1
void		gem_power(int, void *);
@


1.34
log
@correct some debugging printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.33 2003/07/09 18:21:45 krw Exp $	*/
a53 2
#include <uvm/uvm_extern.h>
 
@


1.33
log
@Eliminate creation/destruction of dmamap's for every xmit by reusing
statically allocated maps.

Significant performance boost on both sparc64 and macppc.

Tested on macppc by drahn@@.

ok jason@@ drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.32 2003/04/27 11:22:52 ho Exp $	*/
a507 1

d519 1
a519 1
		printf("%s: cannot disable read dma\n",
d561 1
a561 1
		printf("%s: cannot disable read dma\n",
d574 1
a574 1
		printf("%s: cannot reset receiver\n",
@


1.32
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.31 2003/03/02 02:59:10 henric Exp $	*/
d204 13
d348 6
d476 1
a476 1
		if (sd->sd_map != NULL) {
a479 4
			bus_dmamap_destroy(sc->sc_dmatag, sd->sd_map);
			sd->sd_map = NULL;
		}
		if (sd->sd_mbuf != NULL) {
d1594 1
a1594 5

	if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, GEM_NTXDESC,
	    MCLBYTES, 0, BUS_DMA_NOWAIT, &map) != 0) {
		return (ENOBUFS);
	}
a1597 1
		bus_dmamap_destroy(sc->sc_dmatag, map);
a1602 1
		bus_dmamap_destroy(sc->sc_dmatag, map);
d1625 1
d1654 1
a1654 1
		if (sd->sd_map != NULL) {
a1657 4
			bus_dmamap_destroy(sc->sc_dmatag, sd->sd_map);
			sd->sd_map = NULL;
		}
		if (sd->sd_mbuf != NULL) {
@


1.31
log
@The gem driver will sometimes unmap bus_dma mappings that are still
in use by the hardware.  Since the sparc64 has IOMMUs, an access by
the hardware after the unmap operation will cause a fault.

This replaces "disable" calls by "reset" calls.  This increases
the time between the command to disable DMA and when the maps
are actually unloaded.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.30 2003/01/23 22:55:52 jason Exp $	*/
d220 1
a220 1
	strcpy(ifp->if_xname, sc->sc_dev.dv_xname);
@


1.30
log
@- Either memset() or loop and set to zero, not both
- reading RX_COMPLETION is a waste of time (and a -slow- PCI read vs. an,
albeit uncached, memory access to determine the same thing).
- on RX_OVERFLOW, reset the board; the RX unit has probably wedged
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.29 2002/11/26 06:01:27 nate Exp $	*/
d449 2
a450 3
	/* XXX - Should we reset these instead? */
	gem_disable_rx(sc);
	gem_disable_tx(sc);
@


1.29
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.28 2002/09/22 15:56:17 jason Exp $	*/
a627 1
	memset((void *)sc->sc_txdescs, 0, sizeof(sc->sc_txdescs));
a937 1
	u_int32_t rxcomp;
d940 1
a940 4
	DPRINTF(sc, ("gem_rint: sc->rxptr %d, complete %d\n",
		sc->sc_rxptr, bus_space_read_4(t, h, GEM_RX_COMPLETION)));
	rxcomp = bus_space_read_4(t, h, GEM_RX_COMPLETION);
	for (i = sc->sc_rxptr; i != rxcomp; i = GEM_NEXTRX(i)) {
d1123 10
a1132 1
		if (rxstat != 0)
d1135 1
@


1.28
log
@Update ifp->if_opackets correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.27 2002/08/28 11:05:02 art Exp $	*/
d305 1
a305 1
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_TX ||
d1307 1
a1307 1
		case IFM_1000_TX:  /* Gigabit using GMII interface */
@


1.27
log
@ - Fix one typo (instead of two disable_rx, one disable_rx and one disable_tx)
 - Instead of setting OACTIVE on the interface when encap fails and never
   clearing it, set a 2 second timer instead and hope that the memory
   situation will improve. This stops the lockups of the interface when
   memory is running low.
jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.26 2002/07/10 18:08:13 deraadt Exp $	*/
d1652 1
@


1.26
log
@shorten address printout
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.25 2002/06/14 21:34:59 todd Exp $	*/
d451 1
a451 1
	gem_disable_rx(sc);
d1696 1
a1696 1
			ifp->if_flags |= IFF_OACTIVE;
@


1.25
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.24 2002/06/09 03:38:40 drahn Exp $	*/
d212 1
a212 1
	printf("%s: Ethernet address %s\n", sc->sc_dev.dv_xname,
@


1.24
log
@make gem compile, arpcom is sc_arpcom.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.23 2002/06/09 03:14:18 todd Exp $	*/
d262 1
a262 1
				printf("%s: cannot accomodate MII device %s"
d822 1
a822 1
	/* step 15.  Give the reciever a swift kick */
@


1.23
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.22 2002/06/07 23:44:05 drahn Exp $	*/
d1364 1
a1364 1
	if ((error = ether_ioctl(ifp, &sc->arpcom, cmd, data)) > 0) {
d1378 1
a1378 1
			arp_ifinit(&sc->arpcom, ifa);
@


1.22
log
@Multicast fixes, Gig-E support, mostly from netbsd. ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.21 2002/05/07 20:44:41 jason Exp $	*/
d1364 1
a1364 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
d1378 1
a1378 1
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.21
log
@Simplify multicast handling based on powerpc's gm.c and remove ether_cmp()
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.20 2002/04/03 15:33:07 jason Exp $	*/
d147 1
d215 4
d300 20
d710 1
d715 1
d745 7
a751 1
	v = (GEM_MTU) | (0x2000 << 16) /* Burst size */;
d774 2
a775 1
	bus_space_write_4(t, h, GEM_MAC_RX_MASK, 0); /* XXXX */
a781 1
	bus_space_write_4(t, h, GEM_TX_KICK, 0);
d786 1
d799 2
a800 2
	 * The following value is for an OFF Threshold of about 15.5 Kbytes
	 * and an ON Threshold of 4K bytes.
d802 4
a805 2
	bus_space_write_4(t, h, GEM_RX_PAUSE_THRESH, 0xf8 | (0x40 << 12));
	bus_space_write_4(t, h, GEM_RX_BLANKING, (2<<12)|6);
d808 1
a808 1
	gem_mii_statchg(&sc->sc_dev);
d854 1
a854 1
		v = (GEM_MTU) | (0x2000 << 16) /* Burst size */;
d856 1
d863 2
a864 1
			((sc->sc_enaddr[5]<<8)|sc->sc_enaddr[4])&0x3ff);
d911 12
d1302 11
a1312 3
 			else
	 			/* half duplex -- disable echo */
		 		v |= GEM_MAC_XIF_ECHO_DISABL;
d1324 1
d1326 6
a1331 2
	if (IFM_TYPE(sc->sc_media.ifm_media) != IFM_ETHER)
		return (EINVAL);
a1342 3
	if ((ifp->if_flags & IFF_UP) == 0)
		return;

a1489 4
	/* Clear hash table */
	for (i = 0; i < 16; i++)
		hash[i] = 0;

d1493 9
d1503 1
a1503 1
		/* Turn on promiscuous mode; turn off the hash filter */
a1504 1
		v &= ~GEM_MAC_RX_HASH_FILTER;
a1508 4
	/* Turn off promiscuous mode; turn on the hash filter */
	v &= ~GEM_MAC_RX_PROMISCUOUS;
	v |= GEM_MAC_RX_HASH_FILTER;

d1511 4
a1514 4
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 256 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
d1517 5
d1532 1
a1533 2
			for (i = 0; i < 16; i++)
				hash[i] = 0xffff;
d1535 1
d1541 1
a1541 1
		/* Just want the 8 most sigificant bits. */
d1545 1
a1545 1
		hash[crc >> 4] |= 1 << (crc & 0xf);
d1550 1
d1553 7
a1560 4
	/* Now load the hash table into the chip */
	for (i = 0; i < 16; i++)
		bus_space_write_4(t, h, GEM_MAC_HASH0 + (i * 4), hash[i]);

@


1.20
log
@- read the rx completion register exactly once.
- don't complain about still owned descriptors
tested by myself and Joey Coleman <joeycoleman@@acm.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.19 2002/03/22 05:41:55 jason Exp $	*/
a125 2
static int	ether_cmp(u_char *, u_char *);

a799 16
/*
 * Compare two Ether/802 addresses for equality, inlined and unrolled for
 * speed.
 */
static __inline__ int
ether_cmp(a, b)
	u_char *a, *b;
{       
        
	if (a[5] != b[5] || a[4] != b[4] || a[3] != b[3] ||
	    a[2] != b[2] || a[1] != b[1] || a[0] != b[0])
		return (0);
	return (1);
}


d1384 1
a1384 1
			gem_setladrf(sc);
d1427 2
a1428 5
	u_char *cp;
	u_int32_t crc;
	u_int32_t hash[16];
	u_int32_t v;
	int len;
d1431 2
a1432 1
	memset(hash, 0, sizeof(hash));
d1459 1
a1459 1
		if (ether_cmp(enm->enm_addrlo, enm->enm_addrhi)) {
d1468 2
a1469 1
			hash[3] = hash[2] = hash[1] = hash[0] = 0xffff;
d1474 3
a1476 18
		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			int octet = *cp++;
			int i;

#define MC_POLY_LE	0xedb88320UL	/* mcast crc, little endian */
			for (i = 0; i < 8; i++) {
				if ((crc & 1) ^ (octet & 1)) {
					crc >>= 1;
					crc ^= MC_POLY_LE;
				} else {
					crc >>= 1;
				}
				octet >>= 1;
			}
		}
		/* Just want the 8 most significant bits. */
d1489 2
a1490 16
	bus_space_write_4(t, h, GEM_MAC_HASH0, hash[0]);
	bus_space_write_4(t, h, GEM_MAC_HASH1, hash[1]);
	bus_space_write_4(t, h, GEM_MAC_HASH2, hash[2]);
	bus_space_write_4(t, h, GEM_MAC_HASH3, hash[3]);
	bus_space_write_4(t, h, GEM_MAC_HASH4, hash[4]);
	bus_space_write_4(t, h, GEM_MAC_HASH5, hash[5]);
	bus_space_write_4(t, h, GEM_MAC_HASH6, hash[6]);
	bus_space_write_4(t, h, GEM_MAC_HASH7, hash[7]);
	bus_space_write_4(t, h, GEM_MAC_HASH8, hash[8]);
	bus_space_write_4(t, h, GEM_MAC_HASH9, hash[9]);
	bus_space_write_4(t, h, GEM_MAC_HASH10, hash[10]);
	bus_space_write_4(t, h, GEM_MAC_HASH11, hash[11]);
	bus_space_write_4(t, h, GEM_MAC_HASH12, hash[12]);
	bus_space_write_4(t, h, GEM_MAC_HASH13, hash[13]);
	bus_space_write_4(t, h, GEM_MAC_HASH14, hash[14]);
	bus_space_write_4(t, h, GEM_MAC_HASH15, hash[15]);
@


1.19
log
@- Move reading collision counters out of splimp()
- all non-debug prints should print the interface name
- quite whining about RX counter expiring, who cares.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.18 2002/03/14 01:26:54 millert Exp $	*/
d907 1
a909 3
	/*
	 * XXXX Read the lastrx only once at the top for speed.
	 */
d912 2
a913 2
	for (i = sc->sc_rxptr; i != bus_space_read_4(t, h, GEM_RX_COMPLETION);
	     i = GEM_NEXTRX(i)) {
a921 2
			printf("%s: gem_rint: completed descriptor "
				"still owned %d\n", sc->sc_dev.dv_xname, i);
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.17 2002/02/22 20:29:09 jason Exp $	*/
a340 2
	s = splimp();

d354 1
d924 2
a925 2
			printf("gem_rint: completed descriptor "
				"still owned %d\n", i);
d1057 1
a1057 1
		printf("%s: XXXlink status changed\n", sc->sc_dev.dv_xname);
d1093 2
a1094 1
			printf("MAC tx fault, status %x\n", txstat);
d1098 5
a1102 2
		if (rxstat & ~GEM_MAC_RX_DONE)
			printf("MAC rx fault, status %x\n", rxstat);
@


1.17
log
@Call ether_ioctl() the way [insert favorite diety] intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.16 2002/02/22 20:15:28 jason Exp $	*/
d89 7
a95 7
void		gem_start __P((struct ifnet *));
void		gem_stop __P((struct ifnet *, int));
int		gem_ioctl __P((struct ifnet *, u_long, caddr_t));
void		gem_tick __P((void *));
void		gem_watchdog __P((struct ifnet *));
void		gem_shutdown __P((void *));
int		gem_init __P((struct ifnet *));
d98 3
a100 3
int		gem_meminit __P((struct gem_softc *));
void		gem_mifinit __P((struct gem_softc *));
void		gem_reset __P((struct gem_softc *));
d107 2
a108 2
void		gem_setladrf __P((struct gem_softc *));
int		gem_encap __P((struct gem_softc *, struct mbuf *, u_int32_t *));
d111 14
a124 14
static int	gem_mii_readreg __P((struct device *, int, int));
static void	gem_mii_writereg __P((struct device *, int, int, int));
static void	gem_mii_statchg __P((struct device *));

int		gem_mediachange __P((struct ifnet *));
void		gem_mediastatus __P((struct ifnet *, struct ifmediareq *));

struct mbuf	*gem_get __P((struct gem_softc *, int, int));
int		gem_put __P((struct gem_softc *, int, struct mbuf *));
void		gem_read __P((struct gem_softc *, int, int));
int		gem_eint __P((struct gem_softc *, u_int));
int		gem_rint __P((struct gem_softc *));
int		gem_tint __P((struct gem_softc *, u_int32_t));
void		gem_power __P((int, void *));
d126 1
a126 1
static int	ether_cmp __P((u_char *, u_char *));
@


1.16
log
@Revert to previous (non hacked =) version now that the iommu is handled
correctly and it doesn't crash
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.14 2002/01/25 16:51:57 jason Exp $	*/
a1306 1
int gem_ioctldebug = 0;
d1322 5
@


1.15
log
@Re-port the NetBSD driver, but rewrite tx logic to use static buffers (and
copies).  This makes the Blade100 gem stable for me.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: gem.c,v 1.11 2001/11/17 00:56:04 thorpej Exp $ */
a39 2
#include <sys/cdefs.h>

a61 3
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
d85 4
d108 1
d123 1
a123 1
int		gem_tint __P((struct gem_softc *));
d126 2
d137 1
a137 1
 * gem_attach:
d142 1
a142 1
gem_attach(sc, enaddr)
a143 1
	uint8_t *enaddr;
d150 2
d168 1
d214 1
a214 3
	    ether_sprintf(enaddr));

	bcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
a296 5
#if 0
	/* claim 802.1q capability */
	sc->sc_arpcom.ac_capabilities |= ETHERCAP_VLAN_MTU;
#endif

a304 17
#if NRND > 0
	rnd_attach_source(&sc->rnd_source, sc->sc_dev.dv_xname,
			  RND_TYPE_NET, 0);
#endif


#if notyet
	/*
	 * Add a suspend hook to make sure we come back up after a
	 * resume.
	 */
	sc->sc_powerhook = powerhook_establish(gem_power, sc);
	if (sc->sc_powerhook == NULL)
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);
#endif

d336 3
d341 15
a355 1
	s = splnet();
a359 1
	
d371 1
a371 1
	s = splnet();
d419 2
d428 21
a448 2
	gem_reset_rx(sc);
	gem_reset_tx(sc);
d480 1
a480 1
	for (i=TRIES; i--; delay(100))
d493 1
a493 1
	for (i=TRIES; i--; delay(100))
d522 1
a522 1
	for (i=TRIES; i--; delay(100))
d535 1
a535 1
	for (i=TRIES; i--; delay(100))
d563 1
a563 1
	for (i=TRIES; i--; delay(100)) 
d587 1
a587 1
	for (i=TRIES; i--; delay(100)) 
a612 1
	sc->sc_tx_cons = sc->sc_tx_prod = 0;
d674 1
d694 1
a694 1
	s = splnet();
d721 2
a722 2
	bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME,
	    GEM_MTU | (0x2000 << 16));
d728 2
a729 2
	/* NOTE: we use only 32-bit DMA addresses here. */
	bus_space_write_4(t, h, GEM_TX_RING_PTR_HI, 0);
d732 2
a733 1
	bus_space_write_4(t, h, GEM_RX_RING_PTR_HI, 0);
d751 1
a755 1
	bus_space_write_4(t, h, GEM_TX_KICK, 0);
a776 3
/* XXXX Serial link needs a whole different setup. */


d803 16
a821 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d824 1
d827 1
d837 2
a838 2
		bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME,
			(ifp->if_mtu+18) | (0x2000<<16)/* Burst size */);
d845 1
a845 3
		    ((sc->sc_arpcom.ac_enaddr[5] << 8) |
		     (sc->sc_arpcom.ac_enaddr[4]) << 0) & 0x3ff);

a879 3
#if 0
	bus_space_write_4(t, h, GEM_MAC_SEND_PAUSE_CMD, 0x1BF0);
#else
a880 1
#endif
d886 1
a886 1
	    (sc->sc_arpcom.ac_enaddr[4] << 8) | sc->sc_arpcom.ac_enaddr[5]);
d888 1
a888 1
	    (sc->sc_arpcom.ac_enaddr[2] << 8) | sc->sc_arpcom.ac_enaddr[3]);
d890 1
a890 30
	    (sc->sc_arpcom.ac_enaddr[0] << 8) | sc->sc_arpcom.ac_enaddr[1]);
}



void
gem_start(ifp)
	struct ifnet *ifp;
{
	struct gem_softc *sc = (struct gem_softc *)ifp->if_softc;
	struct mbuf *m0;
	u_int32_t prod;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

	prod = sc->sc_tx_prod;
	for (;;) {
		IFQ_POLL(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;

		if (sc->sc_tx_cnt == (GEM_NTXDESC - 2)) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;
a891 72
		m_copydata(m0, 0, m0->m_pkthdr.len,
		    &sc->sc_control_data->gcd_txbufs[prod][0]);
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_cddmamap,
		    offsetof(struct gem_control_data, gcd_txbufs[prod][0]),
		    m0->m_pkthdr.len, BUS_DMASYNC_PREWRITE);

		sc->sc_txdescs[prod].gd_addr =
		    GEM_DMA_WRITE(sc, sc->sc_cddmamap->dm_segs[0].ds_addr +
		    offsetof(struct gem_control_data, gcd_txbufs[prod][0]));
		sc->sc_txdescs[prod].gd_flags = GEM_DMA_WRITE(sc,
		    (m0->m_pkthdr.len & GEM_TD_BUFSIZE) |
		    GEM_TD_START_OF_PACKET | GEM_TD_END_OF_PACKET);

		m_freem(m0);

		GEM_CDTXSYNC(sc, prod, 1,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		if (++prod == GEM_NTXDESC)
			prod = 0;
		++sc->sc_tx_cnt;
	}
	if (prod != sc->sc_tx_prod)
		bus_space_write_4(sc->sc_bustag, sc->sc_h, GEM_TX_KICK, prod);
	sc->sc_tx_prod = prod;
}

/*
 * Transmit interrupt.
 */
int
gem_tint(sc)
	struct gem_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_h;
	u_int32_t hwcons, cons;

	/*
	 * Unload collision counters
	 */
	ifp->if_collisions +=
	    bus_space_read_4(t, mac, GEM_MAC_NORM_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_FIRST_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_EXCESS_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_LATE_COLL_CNT);

	/*
	 * then clear the hardware counters.
	 */
	bus_space_write_4(t, mac, GEM_MAC_NORM_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_FIRST_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_EXCESS_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_LATE_COLL_CNT, 0);

	/*
	 * Go through our Tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	cons = sc->sc_tx_cons;
	hwcons = bus_space_read_4(t, mac, GEM_TX_COMPLETION);
	while (cons != hwcons) {
		if (++cons == GEM_NTXDESC)
			cons = 0;
		--sc->sc_tx_cnt;
	}
	sc->sc_tx_cons = cons;

	ifp->if_flags &= ~IFF_OACTIVE;

	return (1);
a909 1
	DPRINTF(sc, ("%s: gem_rint\n", sc->sc_dev.dv_xname));
d1062 1
a1062 1
	printf("%s: status=%x\n", sc->sc_dev.dv_xname, status);
a1075 3
#ifdef GEM_DEBUG
	char bits[128];
#endif
d1078 2
a1079 3
	DPRINTF(sc, ("%s: gem_intr: cplt %xstatus %s\n",
		sc->sc_dev.dv_xname, (status>>19),
		bitmask_snprintf(status, GEM_INTR_BITS, bits, sizeof(bits))));
d1084 2
a1085 4
	if ((status & 
		(GEM_INTR_TX_EMPTY | GEM_INTR_TX_INTME))
		!= 0)
		r |= gem_tint(sc);
d1121 1
a1121 1
	gem_start(ifp);
a1169 11
#if 0
	/* Select the desired PHY in the MIF configuration register */
	v = bus_space_read_4(t, mif, GEM_MIF_CONFIG);
	/* Clear PHY select bit */
	v &= ~GEM_MIF_CONFIG_PHY_SEL;
	if (phy == GEM_PHYAD_EXTERNAL)
		/* Set PHY select bit to get at external device */
		v |= GEM_MIF_CONFIG_PHY_SEL;
	bus_space_write_4(t, mif, GEM_MIF_CONFIG, v);
#endif

d1244 2
a1245 2
		printf("gem_mii_statchg: status change: phy = %d\n", 
			sc->sc_phys[instance];);
d1324 1
a1324 4
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}
a1325 1
	switch (cmd) {
d1328 1
d1335 1
a1335 1
#endif /* INET */
a1336 1
		/* XXX - This code is probably wrong. */
d1342 6
a1347 6
				ina->x_host = 
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
d1352 1
a1352 1
#endif /* NS */
d1369 1
a1369 1
			   (ifp->if_flags & IFF_RUNNING) == 0) {
d1375 1
a1375 1
		} else {
d1380 1
a1380 1
			gem_stop(ifp, 0);
d1383 3
d1391 2
a1392 2
			ether_addmulti(ifr, &sc->sc_arpcom):
			ether_delmulti(ifr, &sc->sc_arpcom);
d1399 1
a1399 1
			gem_init(ifp);
d1410 1
d1414 1
a1414 3
	if (ifp->if_flags & IFF_UP)
		gem_start(ifp);

d1476 1
a1476 1
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
d1540 59
a1598 1
#if notyet
d1601 1
a1601 3
 * gem_power:
 *
 *	Power management (suspend/resume) hook.
d1603 4
a1606 4
void
gem_power(why, arg)
	int why;
	void *arg;
a1607 1
	struct gem_softc *sc = arg;
d1609 2
a1610 1
	int s;
d1612 14
a1625 13
	s = splnet();
	switch (why) {
	case PWR_SUSPEND:
	case PWR_STANDBY:
		gem_stop(ifp, 1);
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
		break;
	case PWR_RESUME:
		if (ifp->if_flags & IFF_UP) {
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, why);
			gem_init(ifp);
d1627 3
a1629 5
		break;
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
d1631 8
a1638 1
	splx(s);
d1640 25
d1667 15
a1681 3
struct cfdriver gem_cd = {
	NULL, "gem", DV_IFNET
};
@


1.14
log
@In encap, sync mbuf before writing descriptors
@
text
@d1 2
a2 2
/*	$OpenBSD: gem.c,v 1.13 2001/12/13 03:51:10 drahn Exp $	*/
/*	$NetBSD: gem.c,v 1.1 2001/09/16 00:11:43 eeh Exp $ */
d40 2
d64 3
a89 4
struct cfdriver gem_cd = {
	NULL, "gem", DV_IFNET
};

a108 1
int		gem_encap __P((struct gem_softc *, struct mbuf *, u_int32_t *));
d123 1
a123 1
int		gem_tint __P((struct gem_softc *, u_int32_t));
a125 2
static int	ether_cmp __P((u_char *, u_char *));

d135 1
a135 1
 * gem_config:
d140 1
a140 1
gem_config(sc)
d142 1
a148 2
	bcopy(sc->sc_enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);

a164 1
	/* XXX should map this in with correct endianness */
d210 3
a212 1
	    ether_sprintf(sc->sc_enaddr));
d295 5
d308 17
a355 3
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_h;
d358 1
a358 15
	s = splimp();

	/* unload collisions counters */
	ifp->if_collisions +=
	    bus_space_read_4(t, mac, GEM_MAC_NORM_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_FIRST_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_EXCESS_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_LATE_COLL_CNT);

	/* clear the hardware counters */
	bus_space_write_4(t, mac, GEM_MAC_NORM_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_FIRST_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_EXCESS_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_LATE_COLL_CNT, 0);

d363 1
d375 1
a375 1
	s = splimp();
a422 2
	struct gem_sxd *sd;
	u_int32_t i;
d430 2
a431 21
	gem_disable_rx(sc);
	gem_disable_rx(sc);

	/*
	 * Release any queued transmit buffers.
	 */
	for (i = 0; i < GEM_NTXDESC; i++) {
		sd = &sc->sc_txd[i];
		if (sd->sd_map != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			bus_dmamap_destroy(sc->sc_dmatag, sd->sd_map);
			sd->sd_map = NULL;
		}
		if (sd->sd_mbuf != NULL) {
			m_freem(sd->sd_mbuf);
			sd->sd_mbuf = NULL;
		}
	}
	sc->sc_tx_cnt = sc->sc_tx_prod = sc->sc_tx_cons = 0;
d463 1
a463 1
	for (i = TRIES; i--; delay(100))
d476 1
a476 1
	for (i = TRIES; i--; delay(100))
d505 1
a505 1
	for (i = TRIES; i--; delay(100))
d518 1
a518 1
	for (i = TRIES; i--; delay(100))
d546 1
a546 1
	for (i = TRIES; i--; delay(100)) 
d570 1
a570 1
	for (i = TRIES; i--; delay(100)) 
d596 1
a657 1
		v = GEM_RING_SZ_32;
d677 1
a677 1
	s = splimp();
d704 2
a705 2
	v = (GEM_MTU) | (0x2000 << 16) /* Burst size */;
	bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME, v);
d711 2
a712 2
	bus_space_write_4(t, h, GEM_TX_RING_PTR_HI, 
	    (((uint64_t)GEM_CDTXADDR(sc,0)) >> 32));
d715 1
a715 2
	bus_space_write_4(t, h, GEM_RX_RING_PTR_HI, 
	    (((uint64_t)GEM_CDRXADDR(sc,0)) >> 32));
a732 1
	bus_space_write_4(t, h, GEM_TX_KICK, 0);
d737 1
d759 3
a787 16
/*
 * Compare two Ether/802 addresses for equality, inlined and unrolled for
 * speed.
 */
static __inline__ int
ether_cmp(a, b)
	u_char *a, *b;
{       
        
	if (a[5] != b[5] || a[4] != b[4] || a[3] != b[3] ||
	    a[2] != b[2] || a[1] != b[1] || a[0] != b[0])
		return (0);
	return (1);
}


d791 1
a793 1
	u_int32_t v;
a795 1
	sc->sc_inited = 0;
d805 2
a806 2
		v = (GEM_MTU) | (0x2000 << 16) /* Burst size */;
		bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME, v);
d813 3
a815 1
			((sc->sc_enaddr[5]<<8)|sc->sc_enaddr[4])&0x3ff);
d850 3
d854 1
d860 1
a860 1
		(sc->sc_enaddr[4]<<8) | sc->sc_enaddr[5]);
d862 1
a862 1
		(sc->sc_enaddr[2]<<8) | sc->sc_enaddr[3]);
d864 30
a893 1
		(sc->sc_enaddr[0]<<8) | sc->sc_enaddr[1]);
d895 72
d985 1
d1138 1
a1138 1
	printf("%s: status=%b\n", sc->sc_dev.dv_xname, status, GEM_INTR_BITS);
d1152 3
d1157 3
a1159 2
	DPRINTF(sc, ("%s: gem_intr: cplt %xstatus %b\n",
		sc->sc_dev.dv_xname, (status>>19), status, GEM_INTR_BITS));
d1164 4
a1167 2
	if ((status & (GEM_INTR_TX_EMPTY | GEM_INTR_TX_INTME)) != 0)
		r |= gem_tint(sc, status);
d1203 1
a1203 1
	gem_init(ifp);
d1252 11
d1337 2
a1338 2
		printf("gem_mii_statchg: status change: phy = %d\n",
		    sc->sc_phys[instance]);
d1417 5
a1422 1

a1424 1

d1431 1
a1431 1
#endif
d1433 1
d1439 6
a1444 6
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else {
				memcpy(LLADDR(ifp->if_sadl),
				    ina->x_host.c_host, sizeof(sc->sc_enaddr));
			}	
d1449 1
a1449 1
#endif
d1466 1
a1466 1
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
d1472 1
a1472 1
		} else if ((ifp->if_flags & IFF_UP) != 0) {
d1477 1
a1477 1
			/*gem_stop(sc);*/
a1479 3
#ifdef HMEDEBUG
		sc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;
#endif
d1485 2
a1486 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
d1493 1
a1493 1
			gem_setladrf(sc);
a1503 1
		error = EINVAL;
d1507 3
a1509 1
	splx(s);
d1571 1
a1571 1
		if (ether_cmp(enm->enm_addrlo, enm->enm_addrhi)) {
d1635 1
a1635 59
int
gem_encap(sc, mhead, bixp)
	struct gem_softc *sc;
	struct mbuf *mhead;
	u_int32_t *bixp;
{
	u_int64_t flags;
	u_int32_t cur, frag, i;
	bus_dmamap_t map;

	cur = frag = *bixp;

	if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, GEM_NTXDESC,
	    MCLBYTES, 0, BUS_DMA_NOWAIT, &map) != 0) {
		return (ENOBUFS);
	}

	if (bus_dmamap_load_mbuf(sc->sc_dmatag, map, mhead,
	    BUS_DMA_NOWAIT) != 0) {
		bus_dmamap_destroy(sc->sc_dmatag, map);
		return (ENOBUFS);
	}

	if ((sc->sc_tx_cnt + map->dm_nsegs) > (GEM_NTXDESC - 2)) {
		bus_dmamap_unload(sc->sc_dmatag, map);
		bus_dmamap_destroy(sc->sc_dmatag, map);
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc->sc_dmatag, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	for (i = 0; i < map->dm_nsegs; i++) {
		sc->sc_txdescs[frag].gd_addr =
		    GEM_DMA_WRITE(sc, map->dm_segs[i].ds_addr);
		flags = (map->dm_segs[i].ds_len & GEM_TD_BUFSIZE) |
		    (i == 0 ? GEM_TD_START_OF_PACKET : 0) |
		    ((i == (map->dm_nsegs - 1)) ? GEM_TD_END_OF_PACKET : 0);
		sc->sc_txdescs[frag].gd_flags = GEM_DMA_WRITE(sc, flags);
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_cddmamap,
		    GEM_CDTXOFF(frag), sizeof(struct gem_desc),
		    BUS_DMASYNC_PREWRITE);
		cur = frag;
		if (++frag == GEM_NTXDESC)
			frag = 0;
	}

	sc->sc_tx_cnt += map->dm_nsegs;
	sc->sc_txd[cur].sd_map = map;
	sc->sc_txd[cur].sd_mbuf = mhead;

	bus_space_write_4(sc->sc_bustag, sc->sc_h, GEM_TX_KICK, frag);

	*bixp = frag;

	/* sync descriptors */

	return (0);
}
d1638 3
a1640 1
 * Transmit interrupt.
d1642 4
a1645 4
int
gem_tint(sc, status)
	struct gem_softc *sc;
	u_int32_t status;
d1647 1
d1649 1
a1649 2
	struct gem_sxd *sd;
	u_int32_t cons, hwcons;
d1651 13
a1663 10
	hwcons = status >> 19;
	cons = sc->sc_tx_cons;
	while (cons != hwcons) {
		sd = &sc->sc_txd[cons];
		if (sd->sd_map != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			bus_dmamap_destroy(sc->sc_dmatag, sd->sd_map);
			sd->sd_map = NULL;
d1665 5
a1669 7
		if (sd->sd_mbuf != NULL) {
			m_freem(sd->sd_mbuf);
			sd->sd_mbuf = NULL;
		}
		sc->sc_tx_cnt--;
		if (++cons == GEM_NTXDESC)
			cons = 0;
d1671 1
a1671 8
	sc->sc_tx_cons = cons;

	gem_start(ifp);

	if (sc->sc_tx_cnt == 0)
		ifp->if_timer = 0;

	return (1);
a1672 25

void
gem_start(ifp)
	struct ifnet *ifp;
{
	struct gem_softc *sc = ifp->if_softc;
	struct mbuf *m;
	u_int32_t bix;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

	bix = sc->sc_tx_prod;
	while (sc->sc_txd[bix].sd_mbuf == NULL) {
		IFQ_POLL(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
d1675 3
a1677 15
		/*
		 * Encapsulate this packet and start it going...
		 * or fail...
		 */
		if (gem_encap(sc, m, &bix)) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);
		ifp->if_timer = 5;
	}

	sc->sc_tx_prod = bix;
}
@


1.13
log
@changes to work with 32bit platforms and get ethernet address on powerpc.
Inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.12 2001/11/06 19:53:18 miod Exp $	*/
d1569 3
d1586 1
a1586 2
	bus_dmamap_sync(sc->sc_dmatag, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
@


1.13.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 2
a2 2
/*	$OpenBSD: gem.c,v 1.15 2002/01/28 01:04:02 jason Exp $	*/
/*	$NetBSD: gem.c,v 1.11 2001/11/17 00:56:04 thorpej Exp $ */
a39 2
#include <sys/cdefs.h>

a61 3
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
d85 4
d108 1
d123 1
a123 1
int		gem_tint __P((struct gem_softc *));
d126 2
d137 1
a137 1
 * gem_attach:
d142 1
a142 1
gem_attach(sc, enaddr)
a143 1
	uint8_t *enaddr;
d150 2
d168 1
d214 1
a214 3
	    ether_sprintf(enaddr));

	bcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
a296 5
#if 0
	/* claim 802.1q capability */
	sc->sc_arpcom.ac_capabilities |= ETHERCAP_VLAN_MTU;
#endif

a304 17
#if NRND > 0
	rnd_attach_source(&sc->rnd_source, sc->sc_dev.dv_xname,
			  RND_TYPE_NET, 0);
#endif


#if notyet
	/*
	 * Add a suspend hook to make sure we come back up after a
	 * resume.
	 */
	sc->sc_powerhook = powerhook_establish(gem_power, sc);
	if (sc->sc_powerhook == NULL)
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);
#endif

d336 3
d341 15
a355 1
	s = splnet();
a359 1
	
d371 1
a371 1
	s = splnet();
d419 2
d428 21
a448 2
	gem_reset_rx(sc);
	gem_reset_tx(sc);
d480 1
a480 1
	for (i=TRIES; i--; delay(100))
d493 1
a493 1
	for (i=TRIES; i--; delay(100))
d522 1
a522 1
	for (i=TRIES; i--; delay(100))
d535 1
a535 1
	for (i=TRIES; i--; delay(100))
d563 1
a563 1
	for (i=TRIES; i--; delay(100)) 
d587 1
a587 1
	for (i=TRIES; i--; delay(100)) 
a612 1
	sc->sc_tx_cons = sc->sc_tx_prod = 0;
d674 1
d694 1
a694 1
	s = splnet();
d721 2
a722 2
	bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME,
	    GEM_MTU | (0x2000 << 16));
d728 2
a729 2
	/* NOTE: we use only 32-bit DMA addresses here. */
	bus_space_write_4(t, h, GEM_TX_RING_PTR_HI, 0);
d732 2
a733 1
	bus_space_write_4(t, h, GEM_RX_RING_PTR_HI, 0);
d751 1
a755 1
	bus_space_write_4(t, h, GEM_TX_KICK, 0);
a776 3
/* XXXX Serial link needs a whole different setup. */


d803 16
a821 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d824 1
d827 1
d837 2
a838 2
		bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME,
			(ifp->if_mtu+18) | (0x2000<<16)/* Burst size */);
d845 1
a845 3
		    ((sc->sc_arpcom.ac_enaddr[5] << 8) |
		     (sc->sc_arpcom.ac_enaddr[4]) << 0) & 0x3ff);

a879 3
#if 0
	bus_space_write_4(t, h, GEM_MAC_SEND_PAUSE_CMD, 0x1BF0);
#else
a880 1
#endif
d886 1
a886 1
	    (sc->sc_arpcom.ac_enaddr[4] << 8) | sc->sc_arpcom.ac_enaddr[5]);
d888 1
a888 1
	    (sc->sc_arpcom.ac_enaddr[2] << 8) | sc->sc_arpcom.ac_enaddr[3]);
d890 1
a890 86
	    (sc->sc_arpcom.ac_enaddr[0] << 8) | sc->sc_arpcom.ac_enaddr[1]);
}



void
gem_start(ifp)
	struct ifnet *ifp;
{
	struct gem_softc *sc = (struct gem_softc *)ifp->if_softc;
	struct mbuf *m0;
	u_int32_t prod;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

	prod = sc->sc_tx_prod;
	for (;;) {
		IFQ_POLL(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;

		if (sc->sc_tx_cnt == (GEM_NTXDESC - 2)) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;

		m_copydata(m0, 0, m0->m_pkthdr.len,
		    &sc->sc_control_data->gcd_txbufs[prod][0]);
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_cddmamap,
		    offsetof(struct gem_control_data, gcd_txbufs[prod][0]),
		    m0->m_pkthdr.len, BUS_DMASYNC_PREWRITE);

		sc->sc_txdescs[prod].gd_addr =
		    GEM_DMA_WRITE(sc, sc->sc_cddmamap->dm_segs[0].ds_addr +
		    offsetof(struct gem_control_data, gcd_txbufs[prod][0]));
		sc->sc_txdescs[prod].gd_flags = GEM_DMA_WRITE(sc,
		    (m0->m_pkthdr.len & GEM_TD_BUFSIZE) |
		    GEM_TD_START_OF_PACKET | GEM_TD_END_OF_PACKET);

		m_freem(m0);

		GEM_CDTXSYNC(sc, prod, 1,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		if (++prod == GEM_NTXDESC)
			prod = 0;
		++sc->sc_tx_cnt;
	}
	if (prod != sc->sc_tx_prod)
		bus_space_write_4(sc->sc_bustag, sc->sc_h, GEM_TX_KICK, prod);
	sc->sc_tx_prod = prod;
}

/*
 * Transmit interrupt.
 */
int
gem_tint(sc)
	struct gem_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_h;
	u_int32_t hwcons, cons;

	/*
	 * Unload collision counters
	 */
	ifp->if_collisions +=
	    bus_space_read_4(t, mac, GEM_MAC_NORM_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_FIRST_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_EXCESS_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_LATE_COLL_CNT);

	/*
	 * then clear the hardware counters.
	 */
	bus_space_write_4(t, mac, GEM_MAC_NORM_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_FIRST_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_EXCESS_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_LATE_COLL_CNT, 0);
a891 16
	/*
	 * Go through our Tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	cons = sc->sc_tx_cons;
	hwcons = bus_space_read_4(t, mac, GEM_TX_COMPLETION);
	while (cons != hwcons) {
		if (++cons == GEM_NTXDESC)
			cons = 0;
		--sc->sc_tx_cnt;
	}
	sc->sc_tx_cons = cons;

	ifp->if_flags &= ~IFF_OACTIVE;

	return (1);
a909 1
	DPRINTF(sc, ("%s: gem_rint\n", sc->sc_dev.dv_xname));
d1062 1
a1062 1
	printf("%s: status=%x\n", sc->sc_dev.dv_xname, status);
a1075 3
#ifdef GEM_DEBUG
	char bits[128];
#endif
d1078 2
a1079 3
	DPRINTF(sc, ("%s: gem_intr: cplt %xstatus %s\n",
		sc->sc_dev.dv_xname, (status>>19),
		bitmask_snprintf(status, GEM_INTR_BITS, bits, sizeof(bits))));
d1084 2
a1085 4
	if ((status & 
		(GEM_INTR_TX_EMPTY | GEM_INTR_TX_INTME))
		!= 0)
		r |= gem_tint(sc);
d1121 1
a1121 1
	gem_start(ifp);
a1169 11
#if 0
	/* Select the desired PHY in the MIF configuration register */
	v = bus_space_read_4(t, mif, GEM_MIF_CONFIG);
	/* Clear PHY select bit */
	v &= ~GEM_MIF_CONFIG_PHY_SEL;
	if (phy == GEM_PHYAD_EXTERNAL)
		/* Set PHY select bit to get at external device */
		v |= GEM_MIF_CONFIG_PHY_SEL;
	bus_space_write_4(t, mif, GEM_MIF_CONFIG, v);
#endif

d1244 2
a1245 2
		printf("gem_mii_statchg: status change: phy = %d\n", 
			sc->sc_phys[instance];);
d1324 1
a1324 4
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}
a1325 1
	switch (cmd) {
d1328 1
d1335 1
a1335 1
#endif /* INET */
a1336 1
		/* XXX - This code is probably wrong. */
d1342 6
a1347 6
				ina->x_host = 
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
d1352 1
a1352 1
#endif /* NS */
d1369 1
a1369 1
			   (ifp->if_flags & IFF_RUNNING) == 0) {
d1375 1
a1375 1
		} else {
d1380 1
a1380 1
			gem_stop(ifp, 0);
d1383 3
d1391 2
a1392 2
			ether_addmulti(ifr, &sc->sc_arpcom):
			ether_delmulti(ifr, &sc->sc_arpcom);
d1399 1
a1399 1
			gem_init(ifp);
d1410 1
d1414 1
a1414 3
	if (ifp->if_flags & IFF_UP)
		gem_start(ifp);

d1476 1
a1476 1
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
d1540 57
a1596 1
#if notyet
d1599 1
a1599 3
 * gem_power:
 *
 *	Power management (suspend/resume) hook.
d1601 4
a1604 4
void
gem_power(why, arg)
	int why;
	void *arg;
a1605 1
	struct gem_softc *sc = arg;
d1607 2
a1608 1
	int s;
d1610 14
a1623 13
	s = splnet();
	switch (why) {
	case PWR_SUSPEND:
	case PWR_STANDBY:
		gem_stop(ifp, 1);
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
		break;
	case PWR_RESUME:
		if (ifp->if_flags & IFF_UP) {
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, why);
			gem_init(ifp);
d1625 3
a1627 5
		break;
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
d1629 8
a1636 1
	splx(s);
d1638 25
d1665 15
a1679 3
struct cfdriver gem_cd = {
	NULL, "gem", DV_IFNET
};
@


1.13.2.2
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: gem.c,v 1.1 2001/09/16 00:11:43 eeh Exp $ */
d40 2
d64 3
d90 7
a96 11
struct cfdriver gem_cd = {
	NULL, "gem", DV_IFNET
};

void		gem_start(struct ifnet *);
void		gem_stop(struct ifnet *, int);
int		gem_ioctl(struct ifnet *, u_long, caddr_t);
void		gem_tick(void *);
void		gem_watchdog(struct ifnet *);
void		gem_shutdown(void *);
int		gem_init(struct ifnet *);
d99 3
a101 3
int		gem_meminit(struct gem_softc *);
void		gem_mifinit(struct gem_softc *);
void		gem_reset(struct gem_softc *);
d108 1
a108 2
void		gem_setladrf(struct gem_softc *);
int		gem_encap(struct gem_softc *, struct mbuf *, u_int32_t *);
d111 14
a124 14
static int	gem_mii_readreg(struct device *, int, int);
static void	gem_mii_writereg(struct device *, int, int, int);
static void	gem_mii_statchg(struct device *);

int		gem_mediachange(struct ifnet *);
void		gem_mediastatus(struct ifnet *, struct ifmediareq *);

struct mbuf	*gem_get(struct gem_softc *, int, int);
int		gem_put(struct gem_softc *, int, struct mbuf *);
void		gem_read(struct gem_softc *, int, int);
int		gem_eint(struct gem_softc *, u_int);
int		gem_rint(struct gem_softc *);
int		gem_tint(struct gem_softc *, u_int32_t);
void		gem_power(int, void *);
d135 1
a135 1
 * gem_config:
d140 1
a140 1
gem_config(sc)
d142 1
a147 3
	struct ifmedia_entry *ifm;

	bcopy(sc->sc_enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
a164 1
	/* XXX should map this in with correct endianness */
d210 1
a210 1
	    ether_sprintf(sc->sc_enaddr));
d212 1
a212 3
	/* Get RX FIFO size */
	sc->sc_rxfifosize = 64 *
	    bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_RX_FIFO_SIZE);
a294 9
	/*
	 * If we support GigE media, we support jumbo frames too.
	 * Unless we are Apple.
	 */
	TAILQ_FOREACH(ifm, &sc->sc_media.ifm_list, ifm_list) {
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_TX ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_SX ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_LX ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_CX) {
d296 2
a297 3
			if (sc->sc_variant != GEM_APPLE_GMAC)
				sc->sc_ethercom.ec_capabilities
				    |= ETHERCAP_JUMBO_MTU;
a299 5
			sc->sc_flags |= GEM_GIGABIT;
			break;
		}
	}

d308 17
a355 3
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_h;
d358 1
a358 14
	/* unload collisions counters */
	ifp->if_collisions +=
	    bus_space_read_4(t, mac, GEM_MAC_NORM_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_FIRST_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_EXCESS_COLL_CNT) +
	    bus_space_read_4(t, mac, GEM_MAC_LATE_COLL_CNT);

	/* clear the hardware counters */
	bus_space_write_4(t, mac, GEM_MAC_NORM_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_FIRST_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_EXCESS_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_LATE_COLL_CNT, 0);

	s = splimp();
d363 1
d375 1
a375 1
	s = splimp();
a422 2
	struct gem_sxd *sd;
	u_int32_t i;
d430 2
a431 21
	gem_disable_rx(sc);
	gem_disable_rx(sc);

	/*
	 * Release any queued transmit buffers.
	 */
	for (i = 0; i < GEM_NTXDESC; i++) {
		sd = &sc->sc_txd[i];
		if (sd->sd_map != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			bus_dmamap_destroy(sc->sc_dmatag, sd->sd_map);
			sd->sd_map = NULL;
		}
		if (sd->sd_mbuf != NULL) {
			m_freem(sd->sd_mbuf);
			sd->sd_mbuf = NULL;
		}
	}
	sc->sc_tx_cnt = sc->sc_tx_prod = sc->sc_tx_cons = 0;
d463 1
a463 1
	for (i = TRIES; i--; delay(100))
d476 1
a476 1
	for (i = TRIES; i--; delay(100))
d505 1
a505 1
	for (i = TRIES; i--; delay(100))
d518 1
a518 1
	for (i = TRIES; i--; delay(100))
d546 1
a546 1
	for (i = TRIES; i--; delay(100)) 
d570 1
a570 1
	for (i = TRIES; i--; delay(100)) 
d596 1
a657 1
		v = GEM_RING_SZ_32;
a670 1

a674 1
	u_int max_frame_size;
d677 1
a677 1
	s = splimp();
d704 2
a705 8
	max_frame_size = max(ifp->if_mtu, ETHERMTU);
	max_frame_size += ETHER_HDR_LEN + ETHER_CRC_LEN;
#if 0
	if (sc->sc_ethercom.ec_capenable & ETHERCAP_VLAN_MTU)
		max_frame_size += ETHER_VLAN_ENCAP_LEN;
#endif
	v = (max_frame_size) | (0x2000 << 16) /* Burst size */;
	bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME, v);
d711 2
a712 2
	bus_space_write_4(t, h, GEM_TX_RING_PTR_HI, 
	    (((uint64_t)GEM_CDTXADDR(sc,0)) >> 32));
d715 1
a715 2
	bus_space_write_4(t, h, GEM_RX_RING_PTR_HI, 
	    (((uint64_t)GEM_CDRXADDR(sc,0)) >> 32));
d726 1
a726 2
	bus_space_write_4(t, h, GEM_MAC_RX_MASK,
	    GEM_MAC_RX_DONE|GEM_MAC_RX_FRAME_CNT);
d750 2
a751 2
	 * The following value is for an OFF Threshold of about 3/4 full
	 * and an ON Threshold of 1/4 full.
d753 2
a754 4
	bus_space_write_4(t, h, GEM_RX_PAUSE_THRESH,
	    (3 * sc->sc_rxfifosize / 256) |
	    (   (sc->sc_rxfifosize / 256) << 12));
	bus_space_write_4(t, h, GEM_RX_BLANKING, (6<<12)|6);
d757 4
a760 1
	mii_mediachg(&sc->sc_mii);
d791 1
a793 1
	u_int32_t v;
a795 1
	sc->sc_inited = 0;
d805 2
a806 3
		v = ETHER_MAX_LEN | (0x2000 << 16) /* Burst size */;
		bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME, v);

d813 2
a814 1
		    ((sc->sc_enaddr[5]<<8)|sc->sc_enaddr[4])&0x3ff);
d850 3
d854 1
d860 1
a860 1
		(sc->sc_enaddr[4]<<8) | sc->sc_enaddr[5]);
d862 1
a862 1
		(sc->sc_enaddr[2]<<8) | sc->sc_enaddr[3]);
d864 30
a893 1
		(sc->sc_enaddr[0]<<8) | sc->sc_enaddr[1]);
d895 55
d952 2
a953 1
	 * Enable MII outputs.  Enable GMII if there is a gigabit PHY.
d955 6
a960 6
	sc->sc_mif_config = bus_space_read_4(t, h, GEM_MIF_CONFIG);
	v = GEM_MAC_XIF_TX_MII_ENA;
	if (sc->sc_mif_config & GEM_MIF_CONFIG_MDI1) {
		v |= GEM_MAC_XIF_FDPLX_LED;
		if (sc->sc_flags & GEM_GIGABIT)
			v |= GEM_MAC_XIF_GMII_MODE;
d962 5
a966 1
	bus_space_write_4(t, h, GEM_MAC_XIF_CONFIG, v);
a982 1
	u_int32_t rxcomp;
d985 4
d991 2
a992 2
	rxcomp = bus_space_read_4(t, h, GEM_RX_COMPLETION);
	for (i = sc->sc_rxptr; i != rxcomp; i = GEM_NEXTRX(i)) {
d1001 2
d1134 1
a1134 1
		printf("%s: link status changed\n", sc->sc_dev.dv_xname);
d1138 1
a1138 1
	printf("%s: status=%b\n", sc->sc_dev.dv_xname, status, GEM_INTR_BITS);
d1152 3
d1157 3
a1159 2
	DPRINTF(sc, ("%s: gem_intr: cplt %xstatus %b\n",
		sc->sc_dev.dv_xname, (status>>19), status, GEM_INTR_BITS));
d1164 4
a1167 2
	if ((status & (GEM_INTR_TX_EMPTY | GEM_INTR_TX_INTME)) != 0)
		r |= gem_tint(sc, status);
d1176 1
a1176 2
			printf("%s: MAC tx fault, status %x\n",
			    sc->sc_dev.dv_xname, txstat);
d1180 2
a1181 5

		rxstat &= ~(GEM_MAC_RX_DONE | GEM_MAC_RX_FRAME_CNT);
		if (rxstat != 0)
			printf("%s: MAC rx fault, status %x\n",
			    sc->sc_dev.dv_xname, rxstat);
d1203 1
a1203 1
	gem_init(ifp);
d1252 11
d1337 2
a1338 2
		printf("gem_mii_statchg: status change: phy = %d\n",
		    sc->sc_phys[instance]);
d1364 3
a1366 11
 		else
	 		/* half duplex -- disable echo */
		 	v |= GEM_MAC_XIF_ECHO_DISABL;

		switch (IFM_SUBTYPE(sc->sc_mii.mii_media_active)) {
		case IFM_1000_TX:  /* Gigabit using GMII interface */
			v |= GEM_MAC_XIF_GMII_MODE;
			break;
		default:
			v &= ~GEM_MAC_XIF_GMII_MODE;
		}
a1377 1
	struct mii_data *mii = &sc->sc_mii;
d1379 2
a1380 6
	if (mii->mii_instance) {
		struct mii_softc        *miisc;
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		miisc = LIST_NEXT(miisc, mii_list))
		mii_phy_reset(miisc);
	}
d1392 3
d1400 1
d1419 1
a1419 1
		return (error);
a1422 1

a1424 1

d1431 1
a1431 1
#endif
d1433 1
d1439 6
a1444 6
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else {
				memcpy(LLADDR(ifp->if_sadl),
				    ina->x_host.c_host, sizeof(sc->sc_enaddr));
			}	
d1449 1
a1449 1
#endif
d1466 1
a1466 1
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
d1472 1
a1472 1
		} else if ((ifp->if_flags & IFF_UP) != 0) {
d1477 1
a1477 1
			/*gem_stop(sc);*/
a1479 3
#ifdef HMEDEBUG
		sc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;
#endif
d1485 2
a1486 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
a1503 1
		error = EINVAL;
d1507 3
a1509 1
	splx(s);
d1537 8
a1544 2
	u_int32_t crc, hash[16], v;
	int i;
a1548 9

	/*
	 * Turn off promiscuous mode, promiscuous group mode (all multicast),
	 * and hash filter.  Depending on the case, the right bit will be
	 * enabled.
	 */
	v &= ~(GEM_MAC_RX_PROMISCUOUS|GEM_MAC_RX_HASH_FILTER|
	    GEM_MAC_RX_PROMISC_GRP);

d1550 1
a1550 1
		/* Turn on promiscuous mode */
d1552 1
d1557 4
d1563 4
a1566 4
	 * through a crc generator, and then using the high order 8 bits as an
	 * index into the 256 bit logical address filter.  The high order 4
	 * bits select the word, while the other 4 bits select the bit within
	 * the word (where bit 0 is the MSB).
a1568 5
	/* Clear hash table */
	for (i = 0; i < 16; i++)
		hash[i] = 0;


d1571 1
a1571 1
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
a1578 1
			 * XXX use the addr filter for this
d1580 1
a1581 1
			v |= GEM_MAC_RX_PROMISC_GRP;
d1585 17
a1601 2
		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);

d1606 1
a1606 1
		hash[crc >> 4] |= 1 << (15 - (crc & 15));
a1610 1
	v |= GEM_MAC_RX_HASH_FILTER;
d1613 18
a1630 6
	/* Now load the hash table into the chip (if we are using it) */
	for (i = 0; i < 16; i++) {
		bus_space_write_4(t, h,
		    GEM_MAC_HASH0 + i * (GEM_MAC_HASH1-GEM_MAC_HASH0),
		    hash[i]);
	}
a1631 1
chipit:
d1635 1
a1635 59
int
gem_encap(sc, mhead, bixp)
	struct gem_softc *sc;
	struct mbuf *mhead;
	u_int32_t *bixp;
{
	u_int64_t flags;
	u_int32_t cur, frag, i;
	bus_dmamap_t map;

	cur = frag = *bixp;

	if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, GEM_NTXDESC,
	    MCLBYTES, 0, BUS_DMA_NOWAIT, &map) != 0) {
		return (ENOBUFS);
	}

	if (bus_dmamap_load_mbuf(sc->sc_dmatag, map, mhead,
	    BUS_DMA_NOWAIT) != 0) {
		bus_dmamap_destroy(sc->sc_dmatag, map);
		return (ENOBUFS);
	}

	if ((sc->sc_tx_cnt + map->dm_nsegs) > (GEM_NTXDESC - 2)) {
		bus_dmamap_unload(sc->sc_dmatag, map);
		bus_dmamap_destroy(sc->sc_dmatag, map);
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc->sc_dmatag, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	for (i = 0; i < map->dm_nsegs; i++) {
		sc->sc_txdescs[frag].gd_addr =
		    GEM_DMA_WRITE(sc, map->dm_segs[i].ds_addr);
		flags = (map->dm_segs[i].ds_len & GEM_TD_BUFSIZE) |
		    (i == 0 ? GEM_TD_START_OF_PACKET : 0) |
		    ((i == (map->dm_nsegs - 1)) ? GEM_TD_END_OF_PACKET : 0);
		sc->sc_txdescs[frag].gd_flags = GEM_DMA_WRITE(sc, flags);
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_cddmamap,
		    GEM_CDTXOFF(frag), sizeof(struct gem_desc),
		    BUS_DMASYNC_PREWRITE);
		cur = frag;
		if (++frag == GEM_NTXDESC)
			frag = 0;
	}

	sc->sc_tx_cnt += map->dm_nsegs;
	sc->sc_txd[cur].sd_map = map;
	sc->sc_txd[cur].sd_mbuf = mhead;

	bus_space_write_4(sc->sc_bustag, sc->sc_h, GEM_TX_KICK, frag);

	*bixp = frag;

	/* sync descriptors */

	return (0);
}
d1638 3
a1640 1
 * Transmit interrupt.
d1642 4
a1645 4
int
gem_tint(sc, status)
	struct gem_softc *sc;
	u_int32_t status;
d1647 1
d1649 1
a1649 2
	struct gem_sxd *sd;
	u_int32_t cons, hwcons;
d1651 13
a1663 10
	hwcons = status >> 19;
	cons = sc->sc_tx_cons;
	while (cons != hwcons) {
		sd = &sc->sc_txd[cons];
		if (sd->sd_map != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			bus_dmamap_destroy(sc->sc_dmatag, sd->sd_map);
			sd->sd_map = NULL;
d1665 5
a1669 7
		if (sd->sd_mbuf != NULL) {
			m_freem(sd->sd_mbuf);
			sd->sd_mbuf = NULL;
		}
		sc->sc_tx_cnt--;
		if (++cons == GEM_NTXDESC)
			cons = 0;
d1671 1
a1671 8
	sc->sc_tx_cons = cons;

	gem_start(ifp);

	if (sc->sc_tx_cnt == 0)
		ifp->if_timer = 0;

	return (1);
a1672 25

void
gem_start(ifp)
	struct ifnet *ifp;
{
	struct gem_softc *sc = ifp->if_softc;
	struct mbuf *m;
	u_int32_t bix;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

	bix = sc->sc_tx_prod;
	while (sc->sc_txd[bix].sd_mbuf == NULL) {
		IFQ_POLL(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
d1675 3
a1677 15
		/*
		 * Encapsulate this packet and start it going...
		 * or fail...
		 */
		if (gem_encap(sc, m, &bix)) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);
		ifp->if_timer = 5;
	}

	sc->sc_tx_prod = bix;
}
@


1.13.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.13.2.2 2002/06/11 03:42:18 art Exp $	*/
d212 1
a212 1
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
d262 1
a262 1
				printf("%s: cannot accommodate MII device %s"
d451 1
a451 1
	gem_disable_tx(sc);
d822 1
a822 1
	/* step 15.  Give the receiver a swift kick */
a1651 1
		ifp->if_opackets++;
d1696 1
a1696 1
			ifp->if_timer = 2;
@


1.13.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d220 1
a220 1
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
d305 1
a305 1
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_T ||
d449 3
a451 2
	gem_reset_rx(sc);
	gem_reset_tx(sc);
d628 1
d939 1
d942 4
a945 1
	for (i = sc->sc_rxptr;; i = GEM_NEXTRX(i)) {
d1128 1
a1128 10
		if (rxstat & GEM_MAC_RX_OVERFLOW) {
			struct ifnet *ifp = &sc->sc_arpcom.ac_if;

			gem_init(ifp);
			ifp->if_ierrors++;
		} else {
			/*
			 * Leave this in here until I figure out what to do
			 * about other errors.
			 */
a1130 1
		}
d1307 1
a1307 1
		case IFM_1000_T:  /* Gigabit using GMII interface */
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.11 2001/10/03 18:18:01 jason Exp $	*/
d728 7
a734 7
	bus_space_write_8(t, h, GEM_TX_RING_PTR,
		GEM_CDTXADDR(sc, 0));
	/* Yeeech.  The following has endianness issues. */
	bus_space_write_4(t, h, GEM_RX_RING_PTR_HI,
		(((uint64_t)GEM_CDRXADDR(sc, 0))>>32));
	bus_space_write_4(t, h, GEM_RX_RING_PTR_LO,
		GEM_CDRXADDR(sc, 0));
@


1.11
log
@Rewrite transmit handling (looks something more like hme), also takes advantage
of some register shadowing provided by the asic.
[This still isn't optimal, but it's getting closer...]
Move all of the stat stuff out of the interrupt context and into the timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.10 2001/10/02 15:24:09 jason Exp $	*/
a53 1
#include <vm/vm.h>
@


1.11.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.11.4.2
log
@Merge in -current
@
text
@d54 1
@


1.11.4.3
log
@Merge in trunk
@
text
@d728 7
a734 7
	bus_space_write_4(t, h, GEM_TX_RING_PTR_HI, 
	    (((uint64_t)GEM_CDTXADDR(sc,0)) >> 32));
	bus_space_write_4(t, h, GEM_TX_RING_PTR_LO, GEM_CDTXADDR(sc, 0));

	bus_space_write_4(t, h, GEM_RX_RING_PTR_HI, 
	    (((uint64_t)GEM_CDRXADDR(sc,0)) >> 32));
	bus_space_write_4(t, h, GEM_RX_RING_PTR_LO, GEM_CDRXADDR(sc, 0));
d1307 1
a1323 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

a1568 3
	bus_dmamap_sync(sc->sc_dmatag, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

d1583 2
a1584 1

@


1.11.4.4
log
@Merge in -current from about a week ago
@
text
@d89 7
a95 7
void		gem_start(struct ifnet *);
void		gem_stop(struct ifnet *, int);
int		gem_ioctl(struct ifnet *, u_long, caddr_t);
void		gem_tick(void *);
void		gem_watchdog(struct ifnet *);
void		gem_shutdown(void *);
int		gem_init(struct ifnet *);
d98 3
a100 3
int		gem_meminit(struct gem_softc *);
void		gem_mifinit(struct gem_softc *);
void		gem_reset(struct gem_softc *);
d107 2
a108 2
void		gem_setladrf(struct gem_softc *);
int		gem_encap(struct gem_softc *, struct mbuf *, u_int32_t *);
d111 3
a113 3
static int	gem_mii_readreg(struct device *, int, int);
static void	gem_mii_writereg(struct device *, int, int, int);
static void	gem_mii_statchg(struct device *);
d115 2
a116 2
int		gem_mediachange(struct ifnet *);
void		gem_mediastatus(struct ifnet *, struct ifmediareq *);
d118 7
a124 7
struct mbuf	*gem_get(struct gem_softc *, int, int);
int		gem_put(struct gem_softc *, int, struct mbuf *);
void		gem_read(struct gem_softc *, int, int);
int		gem_eint(struct gem_softc *, u_int);
int		gem_rint(struct gem_softc *);
int		gem_tint(struct gem_softc *, u_int32_t);
void		gem_power(int, void *);
d126 1
a126 1
static int	ether_cmp(u_char *, u_char *);
@


1.11.4.5
log
@Sync the SMP branch with 3.3
@
text
@d126 2
a148 1
	struct ifmedia_entry *ifm;
d213 1
a213 1
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
a215 4
	/* Get RX FIFO size */
	sc->sc_rxfifosize = 64 *
	    bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_RX_FIFO_SIZE);

d259 1
a259 1
				printf("%s: cannot accommodate MII device %s"
a296 20
	/*
	 * If we support GigE media, we support jumbo frames too.
	 * Unless we are Apple.
	 */
	TAILQ_FOREACH(ifm, &sc->sc_media.ifm_list, ifm_list) {
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_T ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_SX ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_LX ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_1000_CX) {
#if 0
			if (sc->sc_variant != GEM_APPLE_GMAC)
				sc->sc_ethercom.ec_capabilities
				    |= ETHERCAP_JUMBO_MTU;
#endif

			sc->sc_flags |= GEM_GIGABIT;
			break;
		}
	}

d341 2
a355 1
	s = splimp();
d427 3
a429 2
	gem_reset_rx(sc);
	gem_reset_tx(sc);
d606 1
a687 1

a691 1
	u_int max_frame_size;
d721 1
a721 7
	max_frame_size = max(ifp->if_mtu, ETHERMTU);
	max_frame_size += ETHER_HDR_LEN + ETHER_CRC_LEN;
#if 0
	if (sc->sc_ethercom.ec_capenable & ETHERCAP_VLAN_MTU)
		max_frame_size += ETHER_VLAN_ENCAP_LEN;
#endif
	v = (max_frame_size) | (0x2000 << 16) /* Burst size */;
d744 1
a744 2
	bus_space_write_4(t, h, GEM_MAC_RX_MASK,
	    GEM_MAC_RX_DONE|GEM_MAC_RX_FRAME_CNT);
d751 1
a755 1
	bus_space_write_4(t, h, GEM_TX_KICK, 0);
d768 2
a769 2
	 * The following value is for an OFF Threshold of about 3/4 full
	 * and an ON Threshold of 1/4 full.
d771 2
a772 4
	bus_space_write_4(t, h, GEM_RX_PAUSE_THRESH,
	    (3 * sc->sc_rxfifosize / 256) |
	    (   (sc->sc_rxfifosize / 256) << 12));
	bus_space_write_4(t, h, GEM_RX_BLANKING, (6<<12)|6);
d775 1
a775 1
	mii_mediachg(&sc->sc_mii);
d789 1
a789 1
	/* step 15.  Give the receiver a swift kick */
d803 16
d837 1
a837 1
		v = ETHER_MAX_LEN | (0x2000 << 16) /* Burst size */;
a838 1

d845 1
a845 2
		    ((sc->sc_enaddr[5]<<8)|sc->sc_enaddr[4])&0x3ff);

a891 12

	/*
	 * Enable MII outputs.  Enable GMII if there is a gigabit PHY.
	 */
	sc->sc_mif_config = bus_space_read_4(t, h, GEM_MIF_CONFIG);
	v = GEM_MAC_XIF_TX_MII_ENA;
	if (sc->sc_mif_config & GEM_MIF_CONFIG_MDI1) {
		v |= GEM_MAC_XIF_FDPLX_LED;
		if (sc->sc_flags & GEM_GIGABIT)
			v |= GEM_MAC_XIF_GMII_MODE;
	}
	bus_space_write_4(t, h, GEM_MAC_XIF_CONFIG, v);
d910 7
a916 1
	for (i = sc->sc_rxptr;; i = GEM_NEXTRX(i)) {
d925 2
d1058 1
a1058 1
		printf("%s: link status changed\n", sc->sc_dev.dv_xname);
d1094 1
a1094 2
			printf("%s: MAC tx fault, status %x\n",
			    sc->sc_dev.dv_xname, txstat);
d1098 2
a1099 15

		rxstat &= ~(GEM_MAC_RX_DONE | GEM_MAC_RX_FRAME_CNT);
		if (rxstat & GEM_MAC_RX_OVERFLOW) {
			struct ifnet *ifp = &sc->sc_arpcom.ac_if;

			gem_init(ifp);
			ifp->if_ierrors++;
		} else {
			/*
			 * Leave this in here until I figure out what to do
			 * about other errors.
			 */
			printf("%s: MAC rx fault, status %x\n",
			    sc->sc_dev.dv_xname, rxstat);
		}
d1271 3
a1273 11
 		else
	 		/* half duplex -- disable echo */
		 	v |= GEM_MAC_XIF_ECHO_DISABL;

		switch (IFM_SUBTYPE(sc->sc_mii.mii_media_active)) {
		case IFM_1000_T:  /* Gigabit using GMII interface */
			v |= GEM_MAC_XIF_GMII_MODE;
			break;
		default:
			v &= ~GEM_MAC_XIF_GMII_MODE;
		}
a1284 1
	struct mii_data *mii = &sc->sc_mii;
d1286 2
a1287 6
	if (mii->mii_instance) {
		struct mii_softc        *miisc;
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		miisc = LIST_NEXT(miisc, mii_list))
		mii_phy_reset(miisc);
	}
d1299 3
d1403 1
a1403 1
			gem_init(ifp);
d1446 8
a1453 2
	u_int32_t crc, hash[16], v;
	int i;
a1457 9

	/*
	 * Turn off promiscuous mode, promiscuous group mode (all multicast),
	 * and hash filter.  Depending on the case, the right bit will be
	 * enabled.
	 */
	v &= ~(GEM_MAC_RX_PROMISCUOUS|GEM_MAC_RX_HASH_FILTER|
	    GEM_MAC_RX_PROMISC_GRP);

d1459 1
a1459 1
		/* Turn on promiscuous mode */
d1461 1
d1466 4
d1472 4
a1475 4
	 * through a crc generator, and then using the high order 8 bits as an
	 * index into the 256 bit logical address filter.  The high order 4
	 * bits select the word, while the other 4 bits select the bit within
	 * the word (where bit 0 is the MSB).
a1477 5
	/* Clear hash table */
	for (i = 0; i < 16; i++)
		hash[i] = 0;


d1480 1
a1480 1
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
a1487 1
			 * XXX use the addr filter for this
d1489 1
a1490 1
			v |= GEM_MAC_RX_PROMISC_GRP;
d1494 17
a1510 2
		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);

d1515 1
a1515 1
		hash[crc >> 4] |= 1 << (15 - (crc & 15));
a1519 1
	v |= GEM_MAC_RX_HASH_FILTER;
d1522 18
a1539 6
	/* Now load the hash table into the chip (if we are using it) */
	for (i = 0; i < 16; i++) {
		bus_space_write_4(t, h,
		    GEM_MAC_HASH0 + i * (GEM_MAC_HASH1-GEM_MAC_HASH0),
		    hash[i]);
	}
a1540 1
chipit:
a1631 1
		ifp->if_opackets++;
d1676 1
a1676 1
			ifp->if_timer = 2;
@


1.11.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.11.4.5 2003/03/28 00:38:13 niklas Exp $	*/
d220 1
a220 1
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
@


1.11.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 2
d119 2
d124 1
a203 13
	/*
	 * Create the transmit buffer DMA maps.
	 */
	for (i = 0; i < GEM_NTXDESC; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmatag, MCLBYTES,
		    GEM_NTXSEGS, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->sc_txd[i].sd_map)) != 0) {
			printf("%s: unable to create tx DMA map %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_6;
		}
		sc->sc_txd[i].sd_mbuf = NULL;
	}
a334 6
 fail_6:
	for (i = 0; i < GEM_NTXDESC; i++) {
		if (sc->sc_txd[i].sd_map != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc->sc_txd[i].sd_map);
	}
d457 1
a457 1
		if (sd->sd_mbuf != NULL) {
d461 4
d493 1
d505 1
a505 1
		printf("%s: cannot disable rx dma\n",
d547 1
a547 1
		printf("%s: cannot disable tx dma\n",
d560 1
a560 1
		printf("%s: cannot reset transmitter\n",
d663 2
d667 2
a668 1
		return GEM_RING_SZ_32;
d670 2
a671 1
		return GEM_RING_SZ_64;
d673 2
a674 1
		return GEM_RING_SZ_128;
d676 2
a677 1
		return GEM_RING_SZ_256;
d679 2
a680 1
		return GEM_RING_SZ_512;
d682 2
a683 1
		return GEM_RING_SZ_1024;
d685 2
a686 1
		return GEM_RING_SZ_2048;
d688 2
a689 1
		return GEM_RING_SZ_4096;
d691 2
a692 1
		return GEM_RING_SZ_8192;
d694 3
a696 2
		printf("gem: invalid Receive Descriptor ring size %d\n", sz);
		return GEM_RING_SZ_32;
d698 1
d1200 1
a1200 1
#ifdef GEM_DEBUG
d1232 1
a1232 1
#ifdef GEM_DEBUG
d1579 5
a1583 1
	map = sc->sc_txd[cur].sd_map;
d1587 1
d1593 1
a1615 1
	sc->sc_txd[*bixp].sd_map = sc->sc_txd[cur].sd_map;
d1644 1
a1644 1
		if (sd->sd_mbuf != NULL) {
d1648 4
@


1.10
log
@increase rx descriptors, remove some debugging code, deal with different endian; NetBSD
general cleanup; me.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.9 2001/09/29 16:43:15 art Exp $	*/
d109 1
d124 1
a124 1
int		gem_tint __P((struct gem_softc *));
a194 24
	 * Initialize the transmit job descriptors.
	 */
	SIMPLEQ_INIT(&sc->sc_txfreeq);
	SIMPLEQ_INIT(&sc->sc_txdirtyq);

	/*
	 * Create the transmit buffer DMA maps.
	 */
	for (i = 0; i < GEM_TXQUEUELEN; i++) {
		struct gem_txsoft *txs;

		txs = &sc->sc_txsoft[i];
		txs->txs_mbuf = NULL;
		if ((error = bus_dmamap_create(sc->sc_dmatag, MCLBYTES,
		    GEM_NTXSEGS, MCLBYTES, 0, 0,
		    &txs->txs_dmamap)) != 0) {
			printf("%s: unable to create tx DMA map %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_4;
		}
		SIMPLEQ_INSERT_TAIL(&sc->sc_txfreeq, txs, txs_q);
	}

	/*
a318 6
 fail_4:
	for (i = 0; i < GEM_TXQUEUELEN; i++) {
		if (sc->sc_txsoft[i].txs_dmamap != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc->sc_txsoft[i].txs_dmamap);
	}
d337 3
d343 14
d420 2
a421 1
	struct gem_txsoft *txs;
d435 12
a446 6
	while ((txs = SIMPLEQ_FIRST(&sc->sc_txdirtyq)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_txdirtyq, txs, txs_q);
		if (txs->txs_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmatag, txs->txs_dmamap);
			m_freem(txs->txs_mbuf);
			txs->txs_mbuf = NULL;
a447 1
		SIMPLEQ_INSERT_TAIL(&sc->sc_txfreeq, txs, txs_q);
d449 1
a613 2
	sc->sc_txfree = GEM_NTXDESC;
	sc->sc_txnext = 0;
d675 1
d752 1
a756 1
	bus_space_write_4(t, h, GEM_TX_KICK, sc->sc_txnext);
a894 330


void
gem_start(ifp)
	struct ifnet *ifp;
{
	struct gem_softc *sc = (struct gem_softc *)ifp->if_softc;
	struct mbuf *m0, *m;
	struct gem_txsoft *txs, *last_txs;
	bus_dmamap_t dmamap;
	int error, firsttx, nexttx, lasttx, ofree, seg;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

	/*
	 * Remember the previous number of free descriptors and
	 * the first descriptor we'll use.
	 */
	ofree = sc->sc_txfree;
	firsttx = sc->sc_txnext;

	DPRINTF(sc, ("%s: gem_start: txfree %d, txnext %d\n",
	    sc->sc_dev.dv_xname, ofree, firsttx));

	/*
	 * Loop through the send queue, setting up transmit descriptors
	 * until we drain the queue, or use up all available transmit
	 * descriptors.
	 */
	while ((txs = SIMPLEQ_FIRST(&sc->sc_txfreeq)) != NULL &&
	       sc->sc_txfree != 0) {
		/*
		 * Grab a packet off the queue.
		 */
		IFQ_POLL(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;
		m = NULL;

		dmamap = txs->txs_dmamap;

		/*
		 * Load the DMA map.  If this fails, the packet either
		 * didn't fit in the alloted number of segments, or we were
		 * short on resources.  In this case, we'll copy and try
		 * again.
		 */
		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m0,
		      BUS_DMA_WRITE|BUS_DMA_NOWAIT) != 0) {
			MGETHDR(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				printf("%s: unable to allocate Tx mbuf\n",
				    sc->sc_dev.dv_xname);
				break;
			}
			if (m0->m_pkthdr.len > MHLEN) {
				MCLGET(m, M_DONTWAIT);
				if ((m->m_flags & M_EXT) == 0) {
					printf("%s: unable to allocate Tx "
					    "cluster\n", sc->sc_dev.dv_xname);
					m_freem(m);
					break;
				}
			}
			m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m, caddr_t));
			m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;
			error = bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap,
			    m, BUS_DMA_WRITE|BUS_DMA_NOWAIT);
			if (error) {
				printf("%s: unable to load Tx buffer, "
				    "error = %d\n", sc->sc_dev.dv_xname, error);
				break;
			}
		}

		/*
		 * Ensure we have enough descriptors free to describe
		 * the packet.
		 */
		if (dmamap->dm_nsegs > sc->sc_txfree) {
			/*
			 * Not enough free descriptors to transmit this
			 * packet.  We haven't committed to anything yet,
			 * so just unload the DMA map, put the packet
			 * back on the queue, and punt.  Notify the upper
			 * layer that there are no more slots left.
			 *
			 * XXX We could allocate an mbuf and copy, but
			 * XXX it is worth it?
			 */
			ifp->if_flags |= IFF_OACTIVE;
			bus_dmamap_unload(sc->sc_dmatag, dmamap);
			if (m != NULL)
				m_freem(m);
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m != NULL) {
			m_freem(m0);
			m0 = m;
		}

		/*
		 * WE ARE NOW COMMITTED TO TRANSMITTING THE PACKET.
		 */

		/* Sync the DMA map. */
		bus_dmamap_sync(sc->sc_dmatag, dmamap, 0, dmamap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

		/*
		 * Initialize the transmit descriptors.
		 */
		for (nexttx = sc->sc_txnext, seg = 0;
		     seg < dmamap->dm_nsegs;
		     seg++, nexttx = GEM_NEXTTX(nexttx)) {
			uint64_t flags;

			/*
			 * If this is the first descriptor we're
			 * enqueueing, set the start of packet flag,
			 * and the checksum stuff if we want the hardware
			 * to do it.
			 */
			sc->sc_txdescs[nexttx].gd_addr =
			    GEM_DMA_WRITE(sc, dmamap->dm_segs[seg].ds_addr);
			flags = dmamap->dm_segs[seg].ds_len & GEM_TD_BUFSIZE;
			if (nexttx == firsttx)
				flags |= GEM_TD_START_OF_PACKET;
			if (seg == dmamap->dm_nsegs - 1)
				flags |= GEM_TD_END_OF_PACKET;
			sc->sc_txdescs[nexttx].gd_flags =
				GEM_DMA_WRITE(sc, flags);
			lasttx = nexttx;
		}

#ifdef GEM_DEBUG
		if (ifp->if_flags & IFF_DEBUG) {
			printf("     gem_start %p transmit chain:\n", txs);
			for (seg = sc->sc_txnext;; seg = GEM_NEXTTX(seg)) {
				printf("descriptor %d:\t", seg);
				printf("gd_flags:   0x%016llx\t", (long long)
				    GEM_DMA_READ(sc, sc->sc_txdescs[seg].gd_flags));
				printf("gd_addr: 0x%016llx\n", (long long)
				    GEM_DMA_READ(sc, sc->sc_txdescs[seg].gd_addr));
				if (seg == lasttx)
					break;
			}
		}
#endif

		/* Sync the descriptors we're using. */
		GEM_CDTXSYNC(sc, sc->sc_txnext, dmamap->dm_nsegs,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		/*
		 * Store a pointer to the packet so we can free it later,
		 * and remember what txdirty will be once the packet is
		 * done.
		 */
		txs->txs_mbuf = m0;
		txs->txs_firstdesc = sc->sc_txnext;
		txs->txs_lastdesc = lasttx;
		txs->txs_ndescs = dmamap->dm_nsegs;

		/* Advance the tx pointer. */
		sc->sc_txfree -= dmamap->dm_nsegs;
		sc->sc_txnext = nexttx;

		SIMPLEQ_REMOVE_HEAD(&sc->sc_txfreeq, txs, txs_q);
		SIMPLEQ_INSERT_TAIL(&sc->sc_txdirtyq, txs, txs_q);

		last_txs = txs;

#if NBPFILTER > 0
		/*
		 * Pass the packet to any BPF listeners.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0);
#endif /* NBPFILTER > 0 */
	}

	if (txs == NULL || sc->sc_txfree == 0) {
		/* No more slots left; notify upper layer. */
		ifp->if_flags |= IFF_OACTIVE;
	}

	if (sc->sc_txfree != ofree) {
		DPRINTF(sc, ("%s: packets enqueued, IC on %d, OWN on %d\n",
		    sc->sc_dev.dv_xname, lasttx, firsttx));
		/*
		 * The entire packet chain is set up.  
		 * Kick the transmitter.
		 */
		DPRINTF(sc, ("%s: gem_start: kicking tx %d\n",
			sc->sc_dev.dv_xname, nexttx));
		bus_space_write_4(sc->sc_bustag, sc->sc_h, GEM_TX_KICK,
			sc->sc_txnext);

		/* Set a watchdog timer in case the chip flakes out. */
		ifp->if_timer = 5;
		DPRINTF(sc, ("%s: gem_start: watchdog %d\n",
			sc->sc_dev.dv_xname, ifp->if_timer));
	}
}

/*
 * Transmit interrupt.
 */
int
gem_tint(sc)
	struct gem_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_h;
	struct gem_txsoft *txs;
	int txlast;


	DPRINTF(sc, ("%s: gem_tint\n", sc->sc_dev.dv_xname));

	/*
	 * Unload collision counters
	 */
	ifp->if_collisions +=
		bus_space_read_4(t, mac, GEM_MAC_NORM_COLL_CNT) +
		bus_space_read_4(t, mac, GEM_MAC_FIRST_COLL_CNT) +
		bus_space_read_4(t, mac, GEM_MAC_EXCESS_COLL_CNT) +
		bus_space_read_4(t, mac, GEM_MAC_LATE_COLL_CNT);

	/*
	 * then clear the hardware counters.
	 */
	bus_space_write_4(t, mac, GEM_MAC_NORM_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_FIRST_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_EXCESS_COLL_CNT, 0);
	bus_space_write_4(t, mac, GEM_MAC_LATE_COLL_CNT, 0);

	/*
	 * Go through our Tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	while ((txs = SIMPLEQ_FIRST(&sc->sc_txdirtyq)) != NULL) {
		GEM_CDTXSYNC(sc, txs->txs_firstdesc,
		    txs->txs_ndescs,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

#ifdef GEM_DEBUG
		if (ifp->if_flags & IFF_DEBUG) {
			int i;
			printf("    txsoft %p transmit chain:\n", txs);
			for (i = txs->txs_firstdesc;; i = GEM_NEXTTX(i)) {
				printf("descriptor %d: ", i);
				printf("gd_flags: 0x%016llx\t", (long long)
					GEM_DMA_READ(sc, sc->sc_txdescs[i].gd_flags));
				printf("gd_addr: 0x%016llx\n", (long long)
					GEM_DMA_READ(sc, sc->sc_txdescs[i].gd_addr));
				if (i == txs->txs_lastdesc)
					break;
			}
		}
#endif

		/*
		 * In theory, we could harveast some descriptors before
		 * the ring is empty, but that's a bit complicated.
		 *
		 * GEM_TX_COMPLETION points to the last descriptor
		 * processed +1.
		 */
		txlast = bus_space_read_4(t, mac, GEM_TX_COMPLETION);
		DPRINTF(sc,
			("gem_tint: txs->txs_lastdesc = %d, txlast = %d\n",
				txs->txs_lastdesc, txlast));
		if (txs->txs_firstdesc <= txs->txs_lastdesc) {
			if ((txlast >= txs->txs_firstdesc) &&
				(txlast <= txs->txs_lastdesc))
				break;
		} else {
			/* Ick -- this command wraps */
			if ((txlast >= txs->txs_firstdesc) ||
				(txlast <= txs->txs_lastdesc))
				break;
		}

		DPRINTF(sc, ("gem_tint: releasing a desc\n"));
		SIMPLEQ_REMOVE_HEAD(&sc->sc_txdirtyq, txs, txs_q);

		sc->sc_txfree += txs->txs_ndescs;

#ifdef DIAGNOSTIC
		if (txs->txs_mbuf == NULL) {
			panic("gem_txintr: null mbuf");
		}
#endif

		bus_dmamap_sync(sc->sc_dmatag, txs->txs_dmamap,
		    0, txs->txs_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmatag, txs->txs_dmamap);
		m_freem(txs->txs_mbuf);
		txs->txs_mbuf = NULL;

		SIMPLEQ_INSERT_TAIL(&sc->sc_txfreeq, txs, txs_q);

		ifp->if_opackets++;
	}

	DPRINTF(sc, ("gem_tint: GEM_TX_STATE_MACHINE %x "
		"GEM_TX_DATA_PTR %llx "
		"GEM_TX_COMPLETION %x\n",
		bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_TX_STATE_MACHINE),
		(long long)bus_space_read_8(sc->sc_bustag, sc->sc_h,
			GEM_TX_DATA_PTR),
		bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_TX_COMPLETION)));

	gem_start(ifp);

	if (SIMPLEQ_FIRST(&sc->sc_txdirtyq) == NULL)
		ifp->if_timer = 0;
	DPRINTF(sc, ("%s: gem_tint: watchdog %d\n",
		sc->sc_dev.dv_xname, ifp->if_timer));

	return (1);
}

a910 2
	DPRINTF(sc, ("%s: gem_rint: sc_flags 0x%08x\n",
		sc->sc_dev.dv_xname, sc->sc_flags));
d1085 2
a1086 4
	if ((status & 
		(GEM_INTR_TX_EMPTY | GEM_INTR_TX_INTME))
		!= 0)
		r |= gem_tint(sc);
d1122 1
a1122 1
	gem_start(ifp);
d1539 141
@


1.9
log
@Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: gem.c,v 1.8 2001/09/28 13:09:06 art Exp $	*/
a36 3
#define	GEM_DEBUG
int gem_opdebug = 0;

a127 6
/* Default buffer copy routines */
void	gem_copytobuf_contig __P((struct gem_softc *, void *, int, int));
void	gem_copyfrombuf_contig __P((struct gem_softc *, void *, int, int));
void	gem_zerobuf_contig __P((struct gem_softc *, int, int));


d168 1
a168 1
/* XXX should map this in with correct endianness */
a234 1
	sc->sc_flags |= GEMF_ATTACHED;
a328 12

#if notyet
	/*
	 * Add a suspend hook to make sure we come back up after a
	 * resume.
	 */
	sc->sc_powerhook = powerhook_establish(gem_power, sc);
	if (sc->sc_powerhook == NULL)
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);
#endif

a433 1
if (gem_opdebug) printf("in stop %d\n", disable);
a712 1
if (gem_opdebug) printf("in init\n");
d754 1
a754 21
#if 0
	if (!sc->sc_pci) {
		/* Config SBus */
		switch (sc->sc_burst) {
		default:
			v = 0;
			break;
		case 16:
			v = GEM_SEB_CFG_BURST16;
			break;
		case 32:
			v = GEM_SEB_CFG_BURST32;
			break;
		case 64:
			v = GEM_SEB_CFG_BURST64;
			break;
		}
		bus_space_write_4(t, seb, GEM_SEBI_CFG, 
			v|GE_SIOCFG_PARITY|GE_SIOCFG_BMODE64);
	}
#endif
a783 3
/* XXXX Serial link needs a whole different setup. */


a886 3
#if 0
	bus_space_write_4(t, h, GEM_MAC_SEND_PAUSE_CMD, 0x1BF0);
#else
a887 1
#endif
a912 3
if (gem_opdebug) printf("in start free %x next %x kick %x\n", 
sc->sc_txfree, sc->sc_txnext, 	
bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_TX_KICK));
d1028 1
a1028 1
			    htole64(dmamap->dm_segs[seg].ds_addr);
d1030 1
a1030 1
			if (nexttx == firsttx) {
d1032 1
a1032 2
			}
			if (seg == dmamap->dm_nsegs - 1) {
a1033 1
			}
d1035 1
a1035 1
				htole64(flags);
d1045 1
a1045 1
					letoh64(sc->sc_txdescs[seg].gd_flags));
d1047 1
a1047 1
					letoh64(sc->sc_txdescs[seg].gd_addr));
a1093 9
#if 0
		/*
		 * Cause a transmit interrupt to happen on the
		 * last packet we enqueued.
		 */
		sc->sc_txdescs[lasttx].gd_flags |= htole64(GEM_TD_INTERRUPT_ME);
		GEM_CDTXSYNC(sc, lasttx, 1,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
#endif
a1099 18
if (gem_opdebug) {
	int i;
	int64_t pa;
	i = bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_TX_KICK);
	printf("GEM_TX_KICK %x GEM_TX_DATA_PTR %llx GEM_TX_RING_PTR %llx\n",
		i, 
		(long long)bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_TX_DATA_PTR),
		(long long)bus_space_read_8(sc->sc_bustag, sc->sc_h, GEM_TX_RING_PTR));
	printf("descriptor %d: ", (i = lasttx));
	printf("gd_flags: 0x%016llx\t", (long long)
		letoh64(sc->sc_txdescs[i].gd_flags));
		pa = letoh64(sc->sc_txdescs[i].gd_addr);
	printf("gd_addr: 0x%016llx\n", (long long) pa);
	printf("GEM_TX_CONFIG %x GEM_MAC_XIF_CONFIG %x GEM_MAC_TX_CONFIG %x\n", 
		bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_TX_CONFIG),
		bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_MAC_XIF_CONFIG),
		bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_MAC_TX_CONFIG));
}
a1101 2
if (gem_opdebug) printf("gem_start: txkick %x\n", 
	bus_space_read_4(sc->sc_bustag, sc->sc_h, GEM_TX_KICK));
d1124 1
a1124 2
	DPRINTF(sc, ("%s: gem_tint: sc_flags 0x%08x\n",
	    sc->sc_dev.dv_xname, sc->sc_flags));
d1148 1
a1148 1
		GEM_CDTXSYNC(sc, txs->txs_lastdesc,
d1159 1
a1159 1
					letoh64(sc->sc_txdescs[i].gd_flags));
d1161 1
a1161 1
					letoh64(sc->sc_txdescs[i].gd_addr));
d1261 1
a1261 1
		rxstat = letoh64(sc->sc_rxdescs[i].gd_flags);
d1285 1
a1285 1
				letoh64(sc->sc_rxdescs[i].gd_flags));
d1287 1
a1287 1
				letoh64(sc->sc_rxdescs[i].gd_addr));
a1297 6
		 * We align the mbuf data in gem_add_rxbuf() so
		 * we can use __NO_STRICT_ALIGNMENT here
		 */
#define __NO_STRICT_ALIGNMENT
#ifdef __NO_STRICT_ALIGNMENT
		/*
a1310 36
#else
		/*
		 * The Gem's receive buffers must be 4-byte aligned.
		 * But this means that the data after the Ethernet header
		 * is misaligned.  We must allocate a new buffer and
		 * copy the data, shifted forward 2 bytes.
		 */
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
 dropit:
			ifp->if_ierrors++;
			GEM_INIT_RXDESC(sc, i);
			bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
			    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
			continue;
		}
		if (len > (MHLEN - 2)) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_freem(m);
				goto dropit;
			}
		}
		m->m_data += 2;

		/*
		 * Note that we use clusters for incoming frames, so the
		 * buffer is virtually contiguous.
		 */
		memcpy(mtod(m, caddr_t), mtod(rxs->rxs_mbuf, caddr_t), len);

		/* Allow the receive descriptor to continue using its mbuf. */
		GEM_INIT_RXDESC(sc, i);
		bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
		    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
#endif /* __NO_STRICT_ALIGNMENT */
a1325 17
#if 0
		/*
		 * We sometimes have to run the 21140 in Hash-Only
		 * mode.  If we're in that mode, and not in promiscuous
		 * mode, and we have a unicast packet that isn't for
		 * us, then drop it.
		 */
		if (sc->sc_filtmode == TDCTL_Tx_FT_HASHONLY &&
		    (ifp->if_flags & IFF_PROMISC) == 0 &&
		    ETHER_IS_MULTICAST(eh->ether_dhost) == 0 &&
		    memcmp(LLADDR(ifp->if_sadl), eh->ether_dhost,
			   ETHER_ADDR_LEN) != 0) {
			m_freem(m);
			continue;
		}
#endif

a1418 21
if (gem_opdebug) printf("%s: gem_intr: cplt %x status %b\n",
	sc->sc_dev.dv_xname, (status>>19), status, GEM_INTR_BITS);
if (gem_opdebug && (status & GEM_INTR_TX_DONE)) {
	int i;
	int64_t pa;
	i = bus_space_read_4(t, seb, GEM_TX_KICK);
	printf("GEM_TX_KICK %x GEM_TX_DATA_PTR %llx GEM_TX_RING_PTR %llx\n",
		i, (long long)bus_space_read_4(t, seb, GEM_TX_DATA_PTR),
		(long long)bus_space_read_8(t, seb, GEM_TX_RING_PTR));
	printf("descriptor %d: ", --i);
	printf("gd_flags: 0x%016llx\t", (long long)
		letoh64(sc->sc_txdescs[i].gd_flags));
		pa = letoh64(sc->sc_txdescs[i].gd_addr);
	printf("gd_addr: 0x%016llx\n", (long long) pa);
	printf("GEM_TX_CONFIG %x GEM_MAC_XIF_CONFIG %x GEM_MAC_TX_CONFIG %x "
		"GEM_MAC_TX_STATUS %x\n",
		bus_space_read_4(t, seb, GEM_TX_CONFIG),
		bus_space_read_4(t, seb, GEM_MAC_XIF_CONFIG),
		bus_space_read_4(t, seb, GEM_MAC_TX_CONFIG),
		bus_space_read_4(t, seb, GEM_MAC_TX_STATUS));
}
a1461 1
//	gem_reset(sc);
a1510 11
#if 0
	/* Select the desired PHY in the MIF configuration register */
	v = bus_space_read_4(t, mif, GEM_MIF_CONFIG);
	/* Clear PHY select bit */
	v &= ~GEM_MIF_CONFIG_PHY_SEL;
	if (phy == GEM_PHYAD_EXTERNAL)
		/* Set PHY select bit to get at external device */
		v |= GEM_MIF_CONFIG_PHY_SEL;
	bus_space_write_4(t, mif, GEM_MIF_CONFIG, v);
#endif

d1576 1
d1578 1
a1578 1
	int phy = sc->sc_phys[instance];
d1585 2
a1586 1
		printf("gem_mii_statchg: status change: phy = %d\n", phy);
a1879 40

#if notyet

/*
 * gem_power:
 *
 *	Power management (suspend/resume) hook.
 */
void
gem_power(why, arg)
	int why;
	void *arg;
{
	struct gem_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int s;

	s = splimp();
	switch (why) {
	case PWR_SUSPEND:
	case PWR_STANDBY:
		gem_stop(ifp, 1);
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
		break;
	case PWR_RESUME:
		if (ifp->if_flags & IFF_UP) {
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, why);
			gem_init(ifp);
		}
		break;
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
	}
	splx(s);
}
#endif
@


1.8
log
@Fix a DIAGNOSTIC check.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d509 1
a509 1
	for (i=TRIES; i--; delay(100))
d522 1
a522 1
	for (i=TRIES; i--; delay(100))
d551 1
a551 1
	for (i=TRIES; i--; delay(100))
d564 1
a564 1
	for (i=TRIES; i--; delay(100))
d592 1
a592 1
	for (i=TRIES; i--; delay(100)) 
d616 1
a616 1
	for (i=TRIES; i--; delay(100)) 
@


1.7
log
@Use splimp instead of splnet in some places.
I don't understand why, but it helps stability a lot.
@
text
@d1 1
d1281 1
d1283 2
a1284 2
#ifdef DIAGNOSTIC
				panic("gem_txintr: null mbuf");
a1285 1
		}
@


1.6
log
@solve mtu problem a little more elegantly (ramdisk works on blade100 and
u5 now).
@
text
@d389 1
a389 1
	s = splnet();
d405 1
a405 1
	s = splnet();
d723 1
a723 1
	s = splnet();
d1838 1
a1838 1
	s = splnet();
d2072 1
a2072 1
	s = splnet();
@


1.5
log
@configured mtu in BOTH places (grumble)
Also, make it a bit higher than normal (this is an ugly hack and will be
removed when I figure out what this thing wants).
@
text
@d751 2
a752 6
	v = ETHERMTU + sizeof(struct ether_header) + 50 +
#if NVLAN > 0
	    EVL_ENCAPLEN +
#endif
	    0;
	bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME, (v) | (0x2000<<16));
d890 1
a890 5
		v = ((ETHERMTU + sizeof(struct ether_header) + 50 +
#if NVLAN > 0
		    EVL_ENCAPLEN +
#endif
		    0) | (0x2000<<16) /* Burst size */);
@


1.4
log
@openbsd style %b handling
@
text
@d751 1
a751 1
	v = ETHERMTU + sizeof(struct ether_header) +
a878 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d881 1
d894 6
a899 2
		bus_space_write_4(t, h, GEM_MAC_MAC_MAX_FRAME,
			(ifp->if_mtu+18) | (0x2000<<16)/* Burst size */);
@


1.3
log
@another ETHERMTU + sizeof(struct ether_header) problem
@
text
@a1444 3
#if 0 /* XXXART */
		m->m_flags |= M_HASFCS;
#endif
a1543 4
#if 0
	char bits[128];
#endif

d1549 1
a1549 4
#if 0 /* XXXART - I'm lazy */
	printf("%s: status=%s\n", sc->sc_dev.dv_xname,
		bitmask_snprintf(status, GEM_INTR_BITS, bits, sizeof(bits)));
#endif
a1563 4
#if 0
	char bits[128];
#endif

d1565 4
a1568 10
#if 0 /* XXXART - I'm lazy */
	DPRINTF(sc, ("%s: gem_intr: cplt %xstatus %s\n",
		sc->sc_dev.dv_xname, (status>>19),
		bitmask_snprintf(status, GEM_INTR_BITS, bits, sizeof(bits))));
#endif
#if 0 /* XXXART */
if (gem_opdebug) printf("%s: gem_intr: cplt %x status %s\n",
	sc->sc_dev.dv_xname, (status>>19),
	bitmask_snprintf(status, GEM_INTR_BITS, bits, sizeof(bits)));
#endif
@


1.2
log
@adapt to OpenBSD ioctl structure
@
text
@d751 1
a751 1
	v = ETHERMTU +
@


1.1
log
@Driver for Sun GEM ethernet. Not ready yet.
From NetBSD
@
text
@d1858 1
d1862 1
d1865 61
a1925 3
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
d1928 7
a1934 3
	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
		if (error == ENETRESET) { 
d1939 1
a1939 3
if (gem_ioctldebug) printf("reset1\n");
			gem_init(ifp);
			delay(50000);
d1943 9
a1953 5
	/* Try to get things going again */
	if (ifp->if_flags & IFF_UP) {
if (gem_ioctldebug) printf("start\n");
		gem_start(ifp);
	}
@

