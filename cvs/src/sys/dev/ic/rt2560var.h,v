head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.12
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.16
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.14
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.8
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.10
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.14
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.10
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.8
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.11
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2012.07.13.10.08.15;	author stsp;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.08.27.16.06.25;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2010.08.04.19.48.33;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.10.17.47.23;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.22.12.14.44;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.18.18.44.04;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.02.04.30.40;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.14.12.43.27;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.09.20.03.34;	author damien;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@/*	$OpenBSD: rt2560var.h,v 1.10 2012/07/13 10:08:15 stsp Exp $  */

/*-
 * Copyright (c) 2005, 2006
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

struct rt2560_rx_radiotap_header {
	struct ieee80211_radiotap_header wr_ihdr;
	uint64_t	wr_tsf;
	uint8_t		wr_flags;
	uint8_t		wr_rate;
	uint16_t	wr_chan_freq;
	uint16_t	wr_chan_flags;
	uint8_t		wr_antenna;
	uint8_t		wr_antsignal;
} __packed;

#define RT2560_RX_RADIOTAP_PRESENT					\
	((1 << IEEE80211_RADIOTAP_TSFT) |				\
	 (1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_RATE) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL) |				\
	 (1 << IEEE80211_RADIOTAP_ANTENNA) |				\
	 (1 << IEEE80211_RADIOTAP_DB_ANTSIGNAL))

struct rt2560_tx_radiotap_header {
	struct ieee80211_radiotap_header wt_ihdr;
	uint8_t		wt_flags;
	uint8_t		wt_rate;
	uint16_t	wt_chan_freq;
	uint16_t	wt_chan_flags;
	uint8_t		wt_antenna;
} __packed;

#define RT2560_TX_RADIOTAP_PRESENT					\
	((1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_RATE) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL) |				\
	 (1 << IEEE80211_RADIOTAP_ANTENNA))

struct rt2560_tx_data {
	bus_dmamap_t			map;
	struct mbuf			*m;
	struct ieee80211_node		*ni;
};

struct rt2560_tx_ring {
	bus_dmamap_t		map;
	bus_dma_segment_t	seg;
	bus_addr_t		physaddr;
	struct rt2560_tx_desc	*desc;
	struct rt2560_tx_data	*data;
	int			count;
	int			queued;
	int			cur;
	int			next;
	int			cur_encrypt;
	int			next_encrypt;
};

struct rt2560_rx_data {
	bus_dmamap_t	map;
	struct mbuf	*m;
	int		drop;
};

struct rt2560_rx_ring {
	bus_dmamap_t		map;
	bus_dma_segment_t	seg;
	bus_addr_t		physaddr;
	struct rt2560_rx_desc	*desc;
	struct rt2560_rx_data	*data;
	int			count;
	int			cur;
	int			next;
	int			cur_decrypt;
};

struct rt2560_node {
	struct ieee80211_node		ni;
	struct ieee80211_amrr_node	amn;
};

struct rt2560_softc {
	struct device		sc_dev;

	struct ieee80211com	sc_ic;
	int			(*sc_newstate)(struct ieee80211com *,
				    enum ieee80211_state, int);
	struct ieee80211_amrr	amrr;

	int			(*sc_enable)(struct rt2560_softc *);
	void			(*sc_disable)(struct rt2560_softc *);

	bus_dma_tag_t		sc_dmat;
	bus_space_tag_t		sc_st;
	bus_space_handle_t	sc_sh;

	struct timeout		scan_to;
	struct timeout		amrr_to;

	int			sc_flags;
#define RT2560_ENABLED		(1 << 0)
#define RT2560_UPDATE_SLOT	(1 << 1)
#define RT2560_SET_SLOTTIME	(1 << 2)
#define RT2560_PRIO_OACTIVE	(1 << 3)
#define RT2560_DATA_OACTIVE	(1 << 4)

	int			sc_tx_timer;

	uint32_t		asic_rev;
	uint8_t			rf_rev;

	struct rt2560_tx_ring	txq;
	struct rt2560_tx_ring	prioq;
	struct rt2560_tx_ring	atimq;
	struct rt2560_tx_ring	bcnq;
	struct rt2560_rx_ring	rxq;

	uint32_t		rf_regs[4];
	uint8_t			txpow[14];

	struct {
		uint8_t	reg;
		uint8_t	val;
	}			bbp_prom[16];

	int			led_mode;
	int			hw_radio;
	int			rx_ant;
	int			tx_ant;
	int			nb_ant;

	uint8_t			*erp;

#if NBPFILTER > 0
	caddr_t			sc_drvbpf;

	union {
		struct rt2560_rx_radiotap_header th;
		uint8_t	pad[64];
	}			sc_rxtapu;
#define sc_rxtap		sc_rxtapu.th
	int			sc_rxtap_len;

	union {
		struct rt2560_tx_radiotap_header th;
		uint8_t	pad[64];
	}			sc_txtapu;
#define sc_txtap		sc_txtapu.th
	int			sc_txtap_len;
#endif
};

int	rt2560_attach(void *, int);
int	rt2560_detach(void *);
void	rt2560_suspend(void *);
void	rt2560_wakeup(void *);
int	rt2560_intr(void *);
@


1.10
log
@Keep separate OACTIVE flags to mark full management/data tx queues,
and set the interface's IFF_OACTIVE flag if either queue is full and
clear it only if both queues have free slots. Before this change both
queues were setting/clearing the same flag with no regard for the
other queue's state.

Also, don't reset the tx watchdog counter if either queue still has frames
queued when we exit the frame-processing loop in the per-queue interrupt
handlers.

Both changes originally from sephe@@dragonfly.

Tested by myself and edd on a slow busy soekris which before this
change required occasional 'ifconfig ral0 down up' to recover.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560var.h,v 1.9 2010/09/07 16:21:42 deraadt Exp $  */
d171 1
a171 1
void	rt2560_resume(void *);
@


1.9
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560var.h,v 1.8 2010/08/27 16:06:25 kettenis Exp $  */
d119 2
@


1.8
log
@Stop calling xxx_power() from xxx_resume(); instead do it the other way around.
Get rid of the sc_power() callback, which isn't used anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560var.h,v 1.7 2010/08/04 19:48:33 damien Exp $  */
a163 1
	void			*sc_powerhook;	/* power management hook */
@


1.7
log
@add suspend/resume support for PCI ral(4) devices.

ok deraadt@@, sthen@@

tested by matthew@@ (RT2560), dcoppa@@ (RT2790), okan@@ (RT2860), todd@@ (RT2560)
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560var.h,v 1.6 2009/08/10 17:47:23 damien Exp $  */
a106 1
	void			(*sc_power)(struct rt2560_softc *, int);
@


1.6
log
@three more shutdown hooks bite the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560var.h,v 1.5 2006/10/22 12:14:44 damien Exp $  */
d170 2
@


1.5
log
@replace rssadapt(9) with amrr for automatic rate control.
as a side-effect, this should fix all the "bogus xmit rate" panics
users have been complaining about for some time when operating in
HostAP mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560var.h,v 1.4 2006/06/18 18:44:04 damien Exp $  */
a164 1
	void			*sc_sdhook;	/* shutdown hook */
a170 1
void	rt2560_shutdown(void *);
@


1.4
log
@- implement new ic_updateslot() callback.
- in hostap mode, we defer update of the slot time until all associated
  STAs are notified with updated beacons.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560var.h,v 1.3 2006/06/02 04:30:40 robert Exp $  */
a57 1
	struct ieee80211_rssdesc	id;
d94 1
a94 1
	struct ieee80211_rssadapt	rssadapt;
d103 1
d113 2
a114 2
	struct timeout		scan_ch;
	struct timeout		rssadapt_ch;
@


1.3
log
@add powerhooks for ral(4) cards with the RT2560 chipset;

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560var.h,v 1.2 2006/01/14 12:43:27 damien Exp $  */
d117 3
a119 1
#define RT2560_ENABLED	(1 << 0)
d145 2
@


1.2
log
@- give rate to rx radiotap
- read TSF high 32bit word before low 32bit word to avoid wraparounds
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2560var.h,v 1.1 2006/01/09 20:03:34 damien Exp $  */
d161 2
d168 1
@


1.1
log
@- add preliminary support for Ralink Technology RT2561, RT2561S and RT2661
  chipsets in ral(4).
- restructure the code a bit; split ic/ral.c into ic/rt2560.c and ic/rt2661.c
- import the 8051 microcode files required by these chipsets.
- more to come;  there is currently no automatic rate control and some
  features are untested (hostap and ibss modes for instance).  most of
  the pre-802.11n capabilities of the RT2661 chipset are not supported
  (like frame aggregation, piggy-back).  MIMO should work though the
  performance/range gain has not been measured.
@
text
@d1 1
a1 1
/*	$OpenBSD: ralvar.h,v 1.8 2005/10/02 13:50:29 damien Exp $  */
d24 1
d34 1
@

