head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.12
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.6
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.8
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.28
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.24
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.22
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.18
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.20
	OPENBSD_5_0:1.13.0.16
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.14
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.12
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.8
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.20
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.18
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.16
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.14
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.12
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.10
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.8
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	EF98ch02VpFassUi;

1.13
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.09.22.51.48;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.02.16.13.07;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.01.11.26.32;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.16.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.06.27.04.45.58;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.21.20.03.54;	author aaron;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.04.20.21.58.11;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.12.17.52.00;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.29.19.39.19;	author nate;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.04.16.04.36;	author ericj;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.23.35;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.40.42;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@/* $OpenBSD: bt485.c,v 1.13 2007/11/26 09:28:33 martynas Exp $ */
/* $NetBSD: bt485.c,v 1.2 2000/04/02 18:55:01 nathanw Exp $ */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

 /* This code was derived from and originally located in sys/dev/pci/
  *	 NetBSD: tga_bt485.c,v 1.4 1999/03/24 05:51:21 mrg Exp 
  */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>

#include <dev/pci/pcivar.h>
#include <dev/ic/bt485reg.h>
#include <dev/ic/bt485var.h>
#include <dev/ic/ramdac.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

/*
 * Functions exported via the RAMDAC configuration table.
 */
void	bt485_init(struct ramdac_cookie *);
int	bt485_set_cmap(struct ramdac_cookie *,
	    struct wsdisplay_cmap *);
int	bt485_get_cmap(struct ramdac_cookie *,
	    struct wsdisplay_cmap *);
int	bt485_set_cursor(struct ramdac_cookie *,
	    struct wsdisplay_cursor *);
int	bt485_get_cursor(struct ramdac_cookie *,
	    struct wsdisplay_cursor *);
int	bt485_set_curpos(struct ramdac_cookie *,
	    struct wsdisplay_curpos *);
int	bt485_get_curpos(struct ramdac_cookie *,
	    struct wsdisplay_curpos *);
int	bt485_get_curmax(struct ramdac_cookie *,
	    struct wsdisplay_curpos *);

/* XXX const */
struct ramdac_funcs bt485_funcsstruct = {
	"Bt485",
	bt485_register,
	bt485_init,
	bt485_set_cmap,
	bt485_get_cmap,
	bt485_set_cursor,
	bt485_get_cursor,
	bt485_set_curpos,
	bt485_get_curpos,
	bt485_get_curmax,
	NULL,			/* check_curcmap; not needed */
	NULL,			/* set_curcmap; not needed */
	NULL,			/* get_curcmap; not needed */
	NULL,			/* no dot clock to set */
};

/*
 * Private data.
 */
struct bt485data {
	void            *cookie;        /* This is what is passed
					 * around, and is probably
					 * struct tga_devconfig *
					 */
	
	int             (*ramdac_sched_update)(void *, void (*)(void *));
	void            (*ramdac_wr)(void *, u_int, u_int8_t);
	u_int8_t        (*ramdac_rd)(void *, u_int);

	int	changed;			/* what changed; see below */
	int	curenb;				/* cursor enabled */
	struct wsdisplay_curpos curpos;		/* current cursor position */
	struct wsdisplay_curpos curhot;		/* cursor hotspot */
	char curcmap_r[2];			/* cursor colormap */
	char curcmap_g[2];
	char curcmap_b[2];
	struct wsdisplay_curpos cursize;	/* current cursor size */
	char curimage[512];			/* cursor image data */
	char curmask[512];			/* cursor mask data */
	char cmap_r[256];				/* colormap */
	char cmap_g[256];
	char cmap_b[256];
};

#define	DATA_ENB_CHANGED	0x01	/* cursor enable changed */
#define	DATA_CURCMAP_CHANGED	0x02	/* cursor colormap changed */
#define	DATA_CURSHAPE_CHANGED	0x04	/* cursor size, image, mask changed */
#define	DATA_CMAP_CHANGED	0x08	/* colormap changed */
#define	DATA_ALL_CHANGED	0x0f

#define	CURSOR_MAX_SIZE		64

/*
 * Internal functions.
 */
inline void	bt485_wr_i(struct bt485data *, u_int8_t, u_int8_t);
inline u_int8_t bt485_rd_i(struct bt485data *, u_int8_t);
void	bt485_update(void *);
void	bt485_update_curpos(struct bt485data *);

/*****************************************************************************/

/*
 * Functions exported via the RAMDAC configuration table.
 */

struct ramdac_funcs *
bt485_funcs(void)
{
	return &bt485_funcsstruct;
}

struct ramdac_cookie *
bt485_register(v, sched_update, wr, rd)
	void *v;
	int (*sched_update)(void *, void (*)(void *));
	void (*wr)(void *, u_int, u_int8_t);
	u_int8_t (*rd)(void *, u_int);
{
	struct bt485data *data;
	/*
	 * XXX -- comment out of date.  rcd.
	 * If we should allocate a new private info struct, do so.
	 * Otherwise, use the one we have (if it's there), or
	 * use the temporary one on the stack.
	 */
	data = malloc(sizeof *data, M_DEVBUF, M_WAITOK);
	/* XXX -- if !data */
	data->cookie = v;
	data->ramdac_sched_update = sched_update;
	data->ramdac_wr = wr;
	data->ramdac_rd = rd;
	return (struct ramdac_cookie *)data;
}

/*
 * This function exists solely to provide a means to init
 * the RAMDAC without first registering.  It is useful for
 * initializing the console early on.
 */
void
bt485_cninit(v, sched_update, wr, rd)
	void *v;
	int (*sched_update)(void *, void (*)(void *));
	void (*wr)(void *, u_int, u_int8_t);
	u_int8_t (*rd)(void *, u_int);
{
	struct bt485data tmp, *data = &tmp;
	data->cookie = v;
	data->ramdac_sched_update = sched_update;
	data->ramdac_wr = wr;
	data->ramdac_rd = rd;
	bt485_init((struct ramdac_cookie *)data);
}

void
bt485_init(rc)
	struct ramdac_cookie *rc;
{
	u_int8_t regval;
	struct bt485data *data = (struct bt485data *)rc;
	int i;

	/*
	 * Init the BT485 for normal operation.
	 */

	/*
	 * Allow indirect register access.  (Actually, this is
	 * already enabled.  In fact, if it is _disabled_, for
	 * some reason the monitor appears to lose sync!!! (?!?!)
	 */
	regval = data->ramdac_rd(data->cookie, BT485_REG_COMMAND_0);
	regval |= 0x80;
	/*
	 * Set the RAMDAC to 8 bit resolution, rather than 6 bit
	 * resolution.
	 */
	regval |= 0x02;
	data->ramdac_wr(data->cookie, BT485_REG_COMMAND_0, regval);

	/* Set the RAMDAC to 8BPP (no interestion options). */
	data->ramdac_wr(data->cookie, BT485_REG_COMMAND_1, 0x40);

	/* Disable the cursor (for now) */
	regval = data->ramdac_rd(data->cookie, BT485_REG_COMMAND_2);
	regval &= ~0x03;
	regval |= 0x24;
	data->ramdac_wr(data->cookie, BT485_REG_COMMAND_2, regval);

	/* Use a 64x64x2 cursor */
	regval = bt485_rd_i(data, BT485_IREG_COMMAND_3);
	regval |= 0x04;
	regval |= 0x08;
	bt485_wr_i(data, BT485_IREG_COMMAND_3, regval);

	/* Set the Pixel Mask to something useful */
	data->ramdac_wr(data->cookie, BT485_REG_PIXMASK, 0xff);

	/*
	 * Initialize the RAMDAC info struct to hold all of our
	 * data, and fill it in.
	 */
	data->changed = DATA_ALL_CHANGED;

	data->curenb = 0;				/* cursor disabled */
	data->curpos.x = data->curpos.y = 0;		/* right now at 0,0 */
	data->curhot.x = data->curhot.y = 0;		/* hot spot at 0,0 */

	/* initial cursor colormap: 0 is black, 1 is white */
	data->curcmap_r[0] = data->curcmap_g[0] = data->curcmap_b[0] = 0;
	data->curcmap_r[1] = data->curcmap_g[1] = data->curcmap_b[1] = 0xff;

	/* initial cursor data: 64x64 block of white. */
	data->cursize.x = data->cursize.y = 64;
	for (i = 0; i < 512; i++)
		data->curimage[i] = data->curmask[i] = 0xff;

	/* Initial colormap: 0 is black, everything else is white */
	data->cmap_r[0] = data->cmap_g[0] = data->cmap_b[0] = 0;
	for (i = 0; i < 256; i++) {
		data->cmap_r[i] = rasops_cmap[3*i + 0];
		data->cmap_g[i] = rasops_cmap[3*i + 1];
		data->cmap_b[i] = rasops_cmap[3*i + 2];
	}

	bt485_update((void *)data);
}

int
bt485_set_cmap(rc, cmapp)
	struct ramdac_cookie *rc;
	struct wsdisplay_cmap *cmapp;
{
	struct bt485data *data = (struct bt485data *)rc;
	u_int count, index;
	int s, error;

#ifdef DIAGNOSTIC
	if (rc == NULL)
		panic("bt485_set_cmap: rc");
	if (cmapp == NULL)
		panic("bt485_set_cmap: cmapp");
#endif
	index = cmapp->index;
	count = cmapp->count;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	s = spltty();

	if ((error = copyin(cmapp->red, &data->cmap_r[index], count)) != 0) {
		splx(s);
		return (error);
	}
	if ((error = copyin(cmapp->green, &data->cmap_g[index], count)) != 0) {
		splx(s);
		return (error);
	}
	if ((error = copyin(cmapp->blue, &data->cmap_b[index], count)) != 0) {
		splx(s);
		return (error);
	}

	data->changed |= DATA_CMAP_CHANGED;

	data->ramdac_sched_update(data->cookie, bt485_update);
#ifdef __alpha__
	alpha_mb();
#endif
	splx(s);

	return (0);
}

int
bt485_get_cmap(rc, cmapp)
	struct ramdac_cookie *rc;
	struct wsdisplay_cmap *cmapp;
{
	struct bt485data *data = (struct bt485data *)rc;
	u_int count, index;
	int error;

	if (cmapp->index >= 256 || cmapp->count > 256 - cmapp->index)
		return (EINVAL);

	count = cmapp->count;
	index = cmapp->index;

	error = copyout(&data->cmap_r[index], cmapp->red, count);
	if (error)
		return (error);
	error = copyout(&data->cmap_g[index], cmapp->green, count);
	if (error)
		return (error);
	error = copyout(&data->cmap_b[index], cmapp->blue, count);
	return (error);
}

int
bt485_set_cursor(rc, cursorp)
	struct ramdac_cookie *rc;
	struct wsdisplay_cursor *cursorp;
{
	struct bt485data *data = (struct bt485data *)rc;
	u_int count, index;
	int error;
	int v, s;

	v = cursorp->which;

	/*
	 * For DOCMAP and DOSHAPE, verify that parameters are OK
	 * before we do anything that we can't recover from.
	 */
	if (v & WSDISPLAY_CURSOR_DOCMAP) {
		index = cursorp->cmap.index;
		count = cursorp->cmap.count;
		if (index >= 2 || count > 2 - index)
			return (EINVAL);
	}
	if (v & WSDISPLAY_CURSOR_DOSHAPE) {
		if ((u_int)cursorp->size.x > CURSOR_MAX_SIZE ||
		    (u_int)cursorp->size.y > CURSOR_MAX_SIZE)
			return (EINVAL);
	}

	if (v & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOCUR)) {
		if (v & WSDISPLAY_CURSOR_DOPOS)
			data->curpos = cursorp->pos;
		if (v & WSDISPLAY_CURSOR_DOCUR)
			data->curhot = cursorp->hot;
		bt485_update_curpos(data);
	}

	s = spltty();

	/* Parameters are OK; perform the requested operations. */
	if (v & WSDISPLAY_CURSOR_DOCUR) {
		data->curenb = cursorp->enable;
		data->changed |= DATA_ENB_CHANGED;
	}
	if (v & WSDISPLAY_CURSOR_DOCMAP) {
		index = cursorp->cmap.index;
		count = cursorp->cmap.count;
		if ((error = copyin(cursorp->cmap.red,
		    &data->curcmap_r[index], count)) != 0) {
			splx(s);
			return (error);
		}
		if ((error = copyin(cursorp->cmap.green,
		    &data->curcmap_g[index], count)) != 0) {
			splx(s);
			return (error);
		}
		if ((error = copyin(cursorp->cmap.blue,
		    &data->curcmap_b[index], count)) != 0) {
			splx(s);
			return (error);
		}
		data->changed |= DATA_CURCMAP_CHANGED;
	}
	if (v & WSDISPLAY_CURSOR_DOSHAPE) {
		data->cursize = cursorp->size;
		count = (CURSOR_MAX_SIZE / NBBY) * data->cursize.y;
		bzero(data->curimage, sizeof data->curimage);
		bzero(data->curmask, sizeof data->curmask);
		if ((error = copyin(cursorp->image, data->curimage,
		    count)) != 0) {
			splx(s);
			return (error);
		}
		if ((error = copyin(cursorp->mask, data->curmask,
		    count)) != 0) {
			splx(s);
			return (error);
		}
		data->changed |= DATA_CURSHAPE_CHANGED;
	}

	if (data->changed)
		data->ramdac_sched_update(data->cookie, bt485_update);
	splx(s);

	return (0);
}

int
bt485_get_cursor(rc, cursorp)
	struct ramdac_cookie *rc;
	struct wsdisplay_cursor *cursorp;
{
	struct bt485data *data = (struct bt485data *)rc;
	int error, count;

	/* we return everything they want */
	cursorp->which = WSDISPLAY_CURSOR_DOALL;

	cursorp->enable = data->curenb;	/* DOCUR */
	cursorp->pos = data->curpos;	/* DOPOS */
	cursorp->hot = data->curhot;	/* DOHOT */

	cursorp->cmap.index = 0;	/* DOCMAP */
	cursorp->cmap.count = 2;
	if (cursorp->cmap.red != NULL) {
		error = copyout(data->curcmap_r, cursorp->cmap.red, 2);
		if (error)
			return (error);
	}
	if (cursorp->cmap.green != NULL) {
		error = copyout(data->curcmap_g, cursorp->cmap.green, 2);
		if (error)
			return (error);
	}
	if (cursorp->cmap.blue != NULL) {
		error = copyout(data->curcmap_b, cursorp->cmap.blue, 2);
		if (error)
			return (error);
	}

	cursorp->size = data->cursize;	/* DOSHAPE */
	if (cursorp->image != NULL) {
		count = (CURSOR_MAX_SIZE / NBBY) * data->cursize.y;
		error = copyout(data->curimage, cursorp->image, count);
		if (error)
			return (error);
		error = copyout(data->curmask, cursorp->mask, count);
		if (error)
			return (error);
	}

	return (0);
}

int
bt485_set_curpos(rc, curposp)
	struct ramdac_cookie *rc;
	struct wsdisplay_curpos *curposp;
{
	struct bt485data *data = (struct bt485data *)rc;

	data->curpos = *curposp;
	bt485_update_curpos(data);

	return (0);
}

int
bt485_get_curpos(rc, curposp)
	struct ramdac_cookie *rc;
	struct wsdisplay_curpos *curposp;
{
	struct bt485data *data = (struct bt485data *)rc;

	*curposp = data->curpos;
	return (0);
}

int
bt485_get_curmax(rc, curposp)
	struct ramdac_cookie *rc;
	struct wsdisplay_curpos *curposp;
{

	curposp->x = curposp->y = CURSOR_MAX_SIZE;
	return (0);
}

/*****************************************************************************/

/*
 * Internal functions.
 */

inline void
bt485_wr_i(data, ireg, val)
	struct bt485data *data;
	u_int8_t ireg;
	u_int8_t val;
{
	data->ramdac_wr(data->cookie, BT485_REG_PCRAM_WRADDR, ireg);
	data->ramdac_wr(data->cookie, BT485_REG_EXTENDED, val);
}

inline u_int8_t
bt485_rd_i(data, ireg)
	struct bt485data *data;
	u_int8_t ireg;
{
	data->ramdac_wr(data->cookie, BT485_REG_PCRAM_WRADDR, ireg);
	return (data->ramdac_rd(data->cookie, BT485_REG_EXTENDED));
}

void
bt485_update(vp)
	void *vp;
{
	struct bt485data *data = vp;
	u_int8_t regval;
	int count, i, v;

	v = data->changed;
	data->changed = 0;

	if (v & DATA_ENB_CHANGED) {
		regval = data->ramdac_rd(data->cookie, BT485_REG_COMMAND_2);
		if (data->curenb)
			regval |= 0x01;
		else
			regval &= ~0x03;
                data->ramdac_wr(data->cookie, BT485_REG_COMMAND_2, regval);
	}

	if (v & DATA_CURCMAP_CHANGED) {
		/* addr[9:0] assumed to be 0 */
		/* set addr[7:0] to 1 */
                data->ramdac_wr(data->cookie, BT485_REG_COC_WRADDR, 0x01);

		/* spit out the cursor data */
		for (i = 0; i < 2; i++) {
                	data->ramdac_wr(data->cookie, BT485_REG_COCDATA,
			    data->curcmap_r[i]);
                	data->ramdac_wr(data->cookie, BT485_REG_COCDATA,
			    data->curcmap_g[i]);
                	data->ramdac_wr(data->cookie, BT485_REG_COCDATA,
			    data->curcmap_b[i]);
		}
	}

	if (v & DATA_CURSHAPE_CHANGED) {
		count = (CURSOR_MAX_SIZE / NBBY) * data->cursize.y;

		/*
		 * Write the cursor image data:
		 *	set addr[9:8] to 0,
		 *	set addr[7:0] to 0,
		 *	spit it all out.
		 */
		regval = bt485_rd_i(data, BT485_IREG_COMMAND_3);
		regval &= ~0x03;
		bt485_wr_i(data, BT485_IREG_COMMAND_3, regval);
                data->ramdac_wr(data->cookie, BT485_REG_PCRAM_WRADDR, 0);
		for (i = 0; i < count; i++)
			data->ramdac_wr(data->cookie, BT485_REG_CURSOR_RAM,
			    data->curimage[i]);
		
		/*
		 * Write the cursor mask data:
		 *	set addr[9:8] to 2,
		 *	set addr[7:0] to 0,
		 *	spit it all out.
		 */
		regval = bt485_rd_i(data, BT485_IREG_COMMAND_3);
		regval &= ~0x03; regval |= 0x02;
		bt485_wr_i(data, BT485_IREG_COMMAND_3, regval);
                data->ramdac_wr(data->cookie, BT485_REG_PCRAM_WRADDR, 0);
		for (i = 0; i < count; i++)
			data->ramdac_wr(data->cookie, BT485_REG_CURSOR_RAM,
			    data->curmask[i]);

		/* set addr[9:0] back to 0 */
		regval = bt485_rd_i(data, BT485_IREG_COMMAND_3);
		regval &= ~0x03;
		bt485_wr_i(data, BT485_IREG_COMMAND_3, regval);
	}

	if (v & DATA_CMAP_CHANGED) {
		/* addr[9:0] assumed to be 0 */
		/* set addr[7:0] to 0 */
                data->ramdac_wr(data->cookie, BT485_REG_PCRAM_WRADDR, 0x00);

		/* spit out the cursor data */
		for (i = 0; i < 256; i++) {
                	data->ramdac_wr(data->cookie, BT485_REG_PALETTE,
			    data->cmap_r[i]);
                	data->ramdac_wr(data->cookie, BT485_REG_PALETTE,
			    data->cmap_g[i]);
                	data->ramdac_wr(data->cookie, BT485_REG_PALETTE,
			    data->cmap_b[i]);
		}
	}
}

void
bt485_update_curpos(data)
	struct bt485data *data;
{
	void *cookie = data->cookie;
	int s, x, y;

	s = spltty();

	x = data->curpos.x + CURSOR_MAX_SIZE - data->curhot.x;
	y = data->curpos.y + CURSOR_MAX_SIZE - data->curhot.y;
	data->ramdac_wr(cookie, BT485_REG_CURSOR_X_LOW, x & 0xff);
	data->ramdac_wr(cookie, BT485_REG_CURSOR_X_HIGH, (x >> 8) & 0x0f);
	data->ramdac_wr(cookie, BT485_REG_CURSOR_Y_LOW, y & 0xff);
	data->ramdac_wr(cookie, BT485_REG_CURSOR_Y_HIGH, (y >> 8) & 0x0f);

	splx(s);
}
@


1.13
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.12 2002/11/09 22:51:48 miod Exp $ */
a40 2

#include <uvm/uvm_extern.h>
@


1.12
log
@Instead of relying on uvm_useracc(), get a false sense of security, and
do not check copyin() result, take care and properly handle copyin() failure.

This was not harmful, but a bit more correctness never harms.
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.11 2002/08/02 16:13:07 millert Exp $ */
d234 1
a234 1
	 * Initalize the RAMDAC info struct to hold all of our
@


1.11
log
@Do correct bounds checking in get/set/put cmap routines.  A few of
these check were already OK but have been modified for consistency.
Problem found by Silvio Cesare.
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.10 2002/04/01 11:26:32 matthieu Exp $ */
d270 1
a270 1
	int s;
d278 4
a281 1
	if (cmapp->index >= 256 || cmapp->count > 256 - cmapp->index)
a282 4
	if (!uvm_useracc(cmapp->red, cmapp->count, B_READ) ||
	    !uvm_useracc(cmapp->green, cmapp->count, B_READ) ||
	    !uvm_useracc(cmapp->blue, cmapp->count, B_READ))
		return (EFAULT);
d286 12
a297 5
	index = cmapp->index;
	count = cmapp->count;
	copyin(cmapp->red, &data->cmap_r[index], count);
	copyin(cmapp->green, &data->cmap_g[index], count);
	copyin(cmapp->blue, &data->cmap_b[index], count);
d341 3
a343 1
	int count, index, v, s;
d352 3
a354 3
		if ((u_int)cursorp->cmap.index > 2 ||
		    ((u_int)cursorp->cmap.index +
		     (u_int)cursorp->cmap.count) > 2)
a355 5
		count = cursorp->cmap.count;
		if (!uvm_useracc(cursorp->cmap.red, count, B_READ) ||
		    !uvm_useracc(cursorp->cmap.green, count, B_READ) ||
		    !uvm_useracc(cursorp->cmap.blue, count, B_READ))
			return (EFAULT);
a360 4
		count = (CURSOR_MAX_SIZE / NBBY) * data->cursize.y;
		if (!uvm_useracc(cursorp->image, count, B_READ) ||
		    !uvm_useracc(cursorp->mask, count, B_READ))
			return (EFAULT);
d379 1
d381 15
a395 4
		index = cursorp->cmap.index;
		copyin(cursorp->cmap.red, &data->curcmap_r[index], count);
		copyin(cursorp->cmap.green, &data->curcmap_g[index], count);
		copyin(cursorp->cmap.blue, &data->curcmap_b[index], count);
d403 10
a412 2
		copyin(cursorp->image, data->curimage, count);	/* can't fail */
		copyin(cursorp->mask, data->curmask, count);	/* can't fail */
@


1.10
log
@Add support for PowerStorm 4D20 TGA boqrds with IBM 561 ramdac (aka
32bit TGA) From NetBSD, ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.9 2002/03/14 03:16:04 millert Exp $ */
d269 2
a270 1
	int count, index, s;
d278 1
a278 2
	if ((u_int)cmapp->index >= 256 ||
	    ((u_int)cmapp->index + (u_int)cmapp->count) > 256)
d310 2
a311 1
	int error, count, index;
d313 1
a313 2
	if ((u_int)cmapp->index >= 256 ||
	    ((u_int)cmapp->index + (u_int)cmapp->count) > 256)
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.8 2002/03/14 01:26:54 millert Exp $ */
d87 1
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.7 2001/11/06 19:53:18 miod Exp $ */
d98 1
a98 1
	int             (*ramdac_sched_update) __P((void *, void (*)(void *)));
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.6 2001/06/27 04:45:58 art Exp $ */
d56 15
a70 15
void	bt485_init __P((struct ramdac_cookie *));
int	bt485_set_cmap __P((struct ramdac_cookie *,
	    struct wsdisplay_cmap *));
int	bt485_get_cmap __P((struct ramdac_cookie *,
	    struct wsdisplay_cmap *));
int	bt485_set_cursor __P((struct ramdac_cookie *,
	    struct wsdisplay_cursor *));
int	bt485_get_cursor __P((struct ramdac_cookie *,
	    struct wsdisplay_cursor *));
int	bt485_set_curpos __P((struct ramdac_cookie *,
	    struct wsdisplay_curpos *));
int	bt485_get_curpos __P((struct ramdac_cookie *,
	    struct wsdisplay_curpos *));
int	bt485_get_curmax __P((struct ramdac_cookie *,
	    struct wsdisplay_curpos *));
d99 2
a100 2
	void            (*ramdac_wr) __P((void *, u_int, u_int8_t));
	u_int8_t        (*ramdac_rd) __P((void *, u_int));
d128 4
a131 4
inline void	bt485_wr_i  __P((struct bt485data *, u_int8_t, u_int8_t));
inline u_int8_t bt485_rd_i __P((struct bt485data *, u_int8_t));
void	bt485_update __P((void *));
void	bt485_update_curpos __P((struct bt485data *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.7 2001/11/06 19:53:18 miod Exp $ */
d56 15
a70 15
void	bt485_init(struct ramdac_cookie *);
int	bt485_set_cmap(struct ramdac_cookie *,
	    struct wsdisplay_cmap *);
int	bt485_get_cmap(struct ramdac_cookie *,
	    struct wsdisplay_cmap *);
int	bt485_set_cursor(struct ramdac_cookie *,
	    struct wsdisplay_cursor *);
int	bt485_get_cursor(struct ramdac_cookie *,
	    struct wsdisplay_cursor *);
int	bt485_set_curpos(struct ramdac_cookie *,
	    struct wsdisplay_curpos *);
int	bt485_get_curpos(struct ramdac_cookie *,
	    struct wsdisplay_curpos *);
int	bt485_get_curmax(struct ramdac_cookie *,
	    struct wsdisplay_curpos *);
a86 1
	NULL,			/* no dot clock to set */
d98 3
a100 3
	int             (*ramdac_sched_update)(void *, void (*)(void *));
	void            (*ramdac_wr)(void *, u_int, u_int8_t);
	u_int8_t        (*ramdac_rd)(void *, u_int);
d128 4
a131 4
inline void	bt485_wr_i(struct bt485data *, u_int8_t, u_int8_t);
inline u_int8_t bt485_rd_i(struct bt485data *, u_int8_t);
void	bt485_update(void *);
void	bt485_update_curpos(struct bt485data *);
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.7.2.1 2002/06/11 03:42:17 art Exp $ */
d269 1
a269 2
	u_int count, index;
	int s;
d277 2
a278 1
	if (cmapp->index >= 256 || cmapp->count > 256 - cmapp->index)
d310 1
a310 2
	u_int count, index;
	int error;
d312 2
a313 1
	if (cmapp->index >= 256 || cmapp->count > 256 - cmapp->index)
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d270 1
a270 1
	int s, error;
d278 1
a278 4
	index = cmapp->index;
	count = cmapp->count;

	if (index >= 256 || count > 256 - index)
d280 4
d287 5
a291 12
	if ((error = copyin(cmapp->red, &data->cmap_r[index], count)) != 0) {
		splx(s);
		return (error);
	}
	if ((error = copyin(cmapp->green, &data->cmap_g[index], count)) != 0) {
		splx(s);
		return (error);
	}
	if ((error = copyin(cmapp->blue, &data->cmap_b[index], count)) != 0) {
		splx(s);
		return (error);
	}
d335 1
a335 3
	u_int count, index;
	int error;
	int v, s;
d344 4
a347 1
		index = cursorp->cmap.index;
d349 4
a352 2
		if (index >= 2 || count > 2 - index)
			return (EINVAL);
d358 4
d380 1
d382 3
a384 16
		count = cursorp->cmap.count;
		if ((error = copyin(cursorp->cmap.red,
		    &data->curcmap_r[index], count)) != 0) {
			splx(s);
			return (error);
		}
		if ((error = copyin(cursorp->cmap.green,
		    &data->curcmap_g[index], count)) != 0) {
			splx(s);
			return (error);
		}
		if ((error = copyin(cursorp->cmap.blue,
		    &data->curcmap_b[index], count)) != 0) {
			splx(s);
			return (error);
		}
d392 2
a393 10
		if ((error = copyin(cursorp->image, data->curimage,
		    count)) != 0) {
			splx(s);
			return (error);
		}
		if ((error = copyin(cursorp->mask, data->curmask,
		    count)) != 0) {
			splx(s);
			return (error);
		}
@


1.6
log
@zap old vm
@
text
@d1 1
a1 1
/* $OpenBSD: bt485.c,v 1.5 2001/04/21 20:03:54 aaron Exp $ */
d42 1
a42 1
#include <vm/vm.h>
@


1.5
log
@Add $OpenBSD$ tags.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a278 1
#if defined(UVM)
a282 6
#else
	if (!useracc(cmapp->red, cmapp->count, B_READ) ||
            !useracc(cmapp->green, cmapp->count, B_READ) ||
            !useracc(cmapp->blue, cmapp->count, B_READ))
                return (EFAULT);
#endif
a347 1
#if defined(UVM)
a351 6
#else
		if (!useracc(cursorp->cmap.red, count, B_READ) ||
                    !useracc(cursorp->cmap.green, count, B_READ) ||
                    !useracc(cursorp->cmap.blue, count, B_READ))
                        return (EFAULT);
#endif
a357 1
#if defined(UVM)
a360 5
#else
		if (!useracc(cursorp->image, count, B_READ) ||
                    !useracc(cursorp->mask, count, B_READ))
                        return (EFAULT);
#endif
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
d50 2
d253 5
a257 2
	for (i = 1; i < 256; i++)
		data->cmap_r[i] = data->cmap_g[i] = data->cmap_b[i] = 255;
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@a0 1
/* $OpenBSD$ */
a48 2
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
d250 2
a251 5
	for (i = 0; i < 256; i++) {
		data->cmap_r[i] = rasops_cmap[3*i + 0];
		data->cmap_g[i] = rasops_cmap[3*i + 1];
		data->cmap_b[i] = rasops_cmap[3*i + 2];
	}
d273 1
d278 6
d349 1
d354 6
d366 1
d370 5
@


1.5.4.3
log
@Merge in -current
@
text
@d42 1
a42 1
#include <uvm/uvm_extern.h>
@


1.5.4.4
log
@Merge in -current from about a week ago
@
text
@d56 15
a70 15
void	bt485_init(struct ramdac_cookie *);
int	bt485_set_cmap(struct ramdac_cookie *,
	    struct wsdisplay_cmap *);
int	bt485_get_cmap(struct ramdac_cookie *,
	    struct wsdisplay_cmap *);
int	bt485_set_cursor(struct ramdac_cookie *,
	    struct wsdisplay_cursor *);
int	bt485_get_cursor(struct ramdac_cookie *,
	    struct wsdisplay_cursor *);
int	bt485_set_curpos(struct ramdac_cookie *,
	    struct wsdisplay_curpos *);
int	bt485_get_curpos(struct ramdac_cookie *,
	    struct wsdisplay_curpos *);
int	bt485_get_curmax(struct ramdac_cookie *,
	    struct wsdisplay_curpos *);
d98 3
a100 3
	int             (*ramdac_sched_update)(void *, void (*)(void *));
	void            (*ramdac_wr)(void *, u_int, u_int8_t);
	u_int8_t        (*ramdac_rd)(void *, u_int);
d128 4
a131 4
inline void	bt485_wr_i(struct bt485data *, u_int8_t, u_int8_t);
inline u_int8_t bt485_rd_i(struct bt485data *, u_int8_t);
void	bt485_update(void *);
void	bt485_update_curpos(struct bt485data *);
@


1.5.4.5
log
@Sync the SMP branch with 3.3
@
text
@a86 1
	NULL,			/* no dot clock to set */
d268 1
a268 2
	u_int count, index;
	int s, error;
d276 2
a277 4
	index = cmapp->index;
	count = cmapp->count;

	if (index >= 256 || count > 256 - index)
d279 4
d286 5
a290 12
	if ((error = copyin(cmapp->red, &data->cmap_r[index], count)) != 0) {
		splx(s);
		return (error);
	}
	if ((error = copyin(cmapp->green, &data->cmap_g[index], count)) != 0) {
		splx(s);
		return (error);
	}
	if ((error = copyin(cmapp->blue, &data->cmap_b[index], count)) != 0) {
		splx(s);
		return (error);
	}
d309 1
a309 2
	u_int count, index;
	int error;
d311 2
a312 1
	if (cmapp->index >= 256 || cmapp->count > 256 - cmapp->index)
d334 1
a334 3
	u_int count, index;
	int error;
	int v, s;
d343 4
a346 1
		index = cursorp->cmap.index;
d348 4
a351 2
		if (index >= 2 || count > 2 - index)
			return (EINVAL);
d357 4
d379 1
d381 3
a383 16
		count = cursorp->cmap.count;
		if ((error = copyin(cursorp->cmap.red,
		    &data->curcmap_r[index], count)) != 0) {
			splx(s);
			return (error);
		}
		if ((error = copyin(cursorp->cmap.green,
		    &data->curcmap_g[index], count)) != 0) {
			splx(s);
			return (error);
		}
		if ((error = copyin(cursorp->cmap.blue,
		    &data->curcmap_b[index], count)) != 0) {
			splx(s);
			return (error);
		}
d391 2
a392 10
		if ((error = copyin(cursorp->image, data->curimage,
		    count)) != 0) {
			splx(s);
			return (error);
		}
		if ((error = copyin(cursorp->mask, data->curmask,
		    count)) != 0) {
			splx(s);
			return (error);
		}
@


1.4
log
@Instead of initializing the colormap to me black & white, initialize the
colormap to use ansi colors.  This makes alpha kernel messages come out
in color during boot, and it allows console users to get ansi colors.
ok deraadt@@
@
text
@d1 1
@


1.3
log
@Replace delay(1) with an alpha_mb() since it just makes more sense.  ok art@@
@
text
@d49 2
d252 5
a256 2
	for (i = 1; i < 256; i++)
		data->cmap_r[i] = data->cmap_g[i] = data->cmap_b[i] = 255;
@


1.2
log
@Add diagnostic message.
Insert short delay before coming out of spltty in set_cmap function.
This prevents a panic on alpha when trying to run the Xtga driver.
@
text
@d296 3
a298 1
	delay(1);
@


1.1
log
@
rest of the work needed for tga2; from NetBSD
@
text
@d264 6
d296 1
@

