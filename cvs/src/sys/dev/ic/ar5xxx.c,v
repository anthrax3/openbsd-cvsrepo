head	1.59;
access;
symbols
	OPENBSD_6_0:1.59.0.6
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.58.0.8
	OPENBSD_5_8_BASE:1.58
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.56.0.12
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.56.0.8
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.56.0.6
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.56.0.2
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.4
	OPENBSD_5_0:1.55.0.8
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.55.0.6
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.55.0.4
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.52.0.4
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.52.0.2
	OPENBSD_4_4_BASE:1.52
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.42.0.2
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20;
locks; strict;
comment	@ * @;


1.59
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.58;
commitid	1npmDuWgN1zBR6BQ;

1.58
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	JtO5uXxVcnZfhUkR;

1.57
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.56;
commitid	I19imNlAX05zJOED;

1.56
date	2012.01.28.12.45.48;	author stsp;	state Exp;
branches;
next	1.55;

1.55
date	2009.09.23.18.03.30;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.02.12.39.02;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.02.12.09.26;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2008.07.30.07.43.01;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2008.07.30.07.15.39;	author reyk;	state Exp;
branches;
next	1.50;

1.50
date	2008.07.29.00.18.25;	author reyk;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.28.16.56.06;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.28.10.02.32;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.03.19.14.04;	author fgsch;	state Exp;
branches;
next	1.46;

1.46
date	2007.10.13.01.54.22;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2007.10.12.15.34.11;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.11.13.39.33;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.07.10.57.23;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.26.10.53.01;	author tom;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.09.16.41.14;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.13.14.44.41;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.12.01.04.52;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.05.16.54.33;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.05.15.13.26;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.06.08.48.49;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2006.09.19.17.08.01;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2006.09.19.13.14.32;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.05.15.21.43;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.18.17.59.58;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.23.20.06.50;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.19.10.27.08;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.10.14.36.46;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.17.12.22.49;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.02.12.55.11;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.17.12.51.08;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.28.23.45.10;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.27.04.10.06;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.16.04.54.31;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.08.18.13.17;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.18.18.42.55;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.20.04.21.55;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.19.17.27.46;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.18.20.46.32;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.10.08.30.56;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.03.16.39.54;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.25.22.25.30;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.23.14.26.54;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.19.16.58.00;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.17.23.52.05;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.17.23.21.49;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.17.22.32.48;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.03.03.21.37;	author kevlo;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.09.18.18.15;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.31.03.39.01;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.31.01.00.23;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.11.20.11.28;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.06.03.05.20;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.03.16.40.46;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.14.05.49;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.02.03.01.16;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@/*	$OpenBSD: ar5xxx.c,v 1.58 2014/07/13 23:10:23 deraadt Exp $	*/

/*
 * Copyright (c) 2004, 2005, 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * HAL interface for Atheros Wireless LAN devices.
 * (Please have a look at ar5xxx.h for further information)
 */

#include <dev/pci/pcidevs.h>
#include <dev/ic/ar5xxx.h>

extern ar5k_attach_t ar5k_ar5210_attach;
extern ar5k_attach_t ar5k_ar5211_attach;
extern ar5k_attach_t ar5k_ar5212_attach;

static const struct {
	u_int16_t	vendor;
	u_int16_t	device;
	ar5k_attach_t	(*attach);
} ar5k_known_products[] = {
	/*
	 * From pcidevs_data.h
	 */
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5210,
	    ar5k_ar5210_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5210_AP,
	    ar5k_ar5210_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5210_DEFAULT,
	    ar5k_ar5210_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5211,
	    ar5k_ar5211_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5211_DEFAULT,
	    ar5k_ar5211_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5311,
	    ar5k_ar5211_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5211_FPGA11B,
	    ar5k_ar5211_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5211_LEGACY,
	    ar5k_ar5211_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5212,
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5212_DEFAULT,
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5212_FPGA,
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5212_IBM,
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR2413,
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5413,
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5424,
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRDAG675,
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_3COM2, PCI_PRODUCT_3COM2_3CRPAG175,
	    ar5k_ar5212_attach }
};

static const HAL_RATE_TABLE ar5k_rt_11a = AR5K_RATES_11A;
static const HAL_RATE_TABLE ar5k_rt_11b = AR5K_RATES_11B;
static const HAL_RATE_TABLE ar5k_rt_11g = AR5K_RATES_11G;
static const HAL_RATE_TABLE ar5k_rt_xr = AR5K_RATES_XR;

int		 ar5k_eeprom_read_ants(struct ath_hal *, u_int32_t *, u_int);
int		 ar5k_eeprom_read_modes(struct ath_hal *, u_int32_t *, u_int);
u_int16_t	 ar5k_eeprom_bin2freq(struct ath_hal *, u_int16_t, u_int);

HAL_BOOL	 ar5k_ar5110_channel(struct ath_hal *, HAL_CHANNEL *);
u_int32_t	 ar5k_ar5110_chan2athchan(HAL_CHANNEL *);
HAL_BOOL	 ar5k_ar5111_channel(struct ath_hal *, HAL_CHANNEL *);
HAL_BOOL	 ar5k_ar5111_chan2athchan(u_int, struct ar5k_athchan_2ghz *);
HAL_BOOL	 ar5k_ar5112_channel(struct ath_hal *, HAL_CHANNEL *);
HAL_BOOL	 ar5k_check_channel(struct ath_hal *, u_int16_t, u_int flags);

HAL_BOOL	 ar5k_ar5111_rfregs(struct ath_hal *, HAL_CHANNEL *, u_int);
HAL_BOOL	 ar5k_ar5112_rfregs(struct ath_hal *, HAL_CHANNEL *, u_int);
HAL_BOOL	 ar5k_arxxxx_rfregs(struct ath_hal *, HAL_CHANNEL *, u_int);
u_int		 ar5k_rfregs_op(u_int32_t *, u_int32_t, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t, HAL_BOOL);

/*
 * Supported channels
 */
static const struct
ieee80211_regchannel ar5k_5ghz_channels[] = IEEE80211_CHANNELS_5GHZ;
static const struct
ieee80211_regchannel ar5k_2ghz_channels[] = IEEE80211_CHANNELS_2GHZ;

/*
 * Initial gain optimization values
 */
static const struct ar5k_gain_opt ar5111_gain_opt = AR5K_AR5111_GAIN_OPT;
static const struct ar5k_gain_opt ar5112_gain_opt = AR5K_AR5112_GAIN_OPT;

/*
 * Initial register for the radio chipsets
 */
static const struct ar5k_ini_rf ar5111_rf[] = AR5K_AR5111_INI_RF;
static const struct ar5k_ini_rf ar5112_rf[] = AR5K_AR5112_INI_RF;
static const struct ar5k_ini_rf ar5112a_rf[] = AR5K_AR5112A_INI_RF;
static const struct ar5k_ini_rf ar5413_rf[] = AR5K_AR5413_INI_RF;
static const struct ar5k_ini_rf ar2413_rf[] = AR5K_AR2413_INI_RF;
static const struct ar5k_ini_rf ar2425_rf[] = AR5K_AR2425_INI_RF;
static const struct ar5k_ini_rfgain ar5111_rfg[] = AR5K_AR5111_INI_RFGAIN;
static const struct ar5k_ini_rfgain ar5112_rfg[] = AR5K_AR5112_INI_RFGAIN;
static const struct ar5k_ini_rfgain ar5413_rfg[] = AR5K_AR5413_INI_RFGAIN;
static const struct ar5k_ini_rfgain ar2413_rfg[] = AR5K_AR2413_INI_RFGAIN;

/*
 * Enable to overwrite the country code (use "00" for debug)
 */
#if 0
#define COUNTRYCODE "00"
#endif

/*
 * Perform a lookup if the device is supported by the HAL
 */
const char *
ath_hal_probe(u_int16_t vendor, u_int16_t device)
{
	int i;

	/*
	 * Perform a linear search on the table of supported devices
	 */
	for (i = 0; i < nitems(ar5k_known_products); i++) {
		if (vendor == ar5k_known_products[i].vendor &&
		    device == ar5k_known_products[i].device)
			return ("");
	}

	return (NULL);
}

/*
 * Fills in the HAL structure and initialises the device
 */
struct ath_hal *
ath_hal_attach(u_int16_t device, void *arg, bus_space_tag_t st,
    bus_space_handle_t sh, u_int is_pcie, int *status)
{
	struct ath_softc *sc = (struct ath_softc *)arg;
	struct ath_hal *hal = NULL;
	ar5k_attach_t *attach = NULL;
	u_int8_t mac[IEEE80211_ADDR_LEN];
	int i;

	*status = EINVAL;

	/*
	 * Call the chipset-dependent attach routine by device id
	 */
	for (i = 0; i < nitems(ar5k_known_products); i++) {
		if (device == ar5k_known_products[i].device &&
		    ar5k_known_products[i].attach != NULL)
			attach = ar5k_known_products[i].attach;
	}

	if (attach == NULL) {
		*status = ENXIO;
		AR5K_PRINTF("device not supported: 0x%04x\n", device);
		return (NULL);
	}

	if ((hal = malloc(sizeof(struct ath_hal),
		 M_DEVBUF, M_NOWAIT | M_ZERO)) == NULL) {
		*status = ENOMEM;
		AR5K_PRINT("out of memory\n");
		return (NULL);
	}

	hal->ah_sc = sc;
	hal->ah_st = st;
	hal->ah_sh = sh;
	hal->ah_device = device;
	hal->ah_sub_vendor = 0; /* XXX unknown?! */

	/*
	 * HAL information
	 */
	hal->ah_abi = HAL_ABI_VERSION;
	hal->ah_op_mode = HAL_M_STA;
	hal->ah_radar.r_enabled = AR5K_TUNE_RADAR_ALERT;
	hal->ah_txpower.txp_tpc = AR5K_TUNE_TPC_TXPOWER;
	hal->ah_imr = 0;
	hal->ah_atim_window = 0;
	hal->ah_aifs = AR5K_TUNE_AIFS;
	hal->ah_cw_min = AR5K_TUNE_CWMIN;
	hal->ah_limit_tx_retries = AR5K_INIT_TX_RETRY;
	hal->ah_software_retry = AH_FALSE;
	hal->ah_ant_diversity = AR5K_TUNE_ANT_DIVERSITY;
	hal->ah_pci_express = is_pcie ? AH_TRUE : AH_FALSE;

	switch (device) {
	case PCI_PRODUCT_ATHEROS_AR2413:
	case PCI_PRODUCT_ATHEROS_AR5413:
	case PCI_PRODUCT_ATHEROS_AR5424:
		/*
		 * Known single chip solutions
		 */
		hal->ah_single_chip = AH_TRUE;
		break;
	default:
		/*
		 * Multi chip solutions
		 */
		hal->ah_single_chip = AH_FALSE;
		break;
	}

	if ((attach)(device, hal, st, sh, status) == NULL)
		goto failed;

#ifdef AR5K_DEBUG
	hal->ah_dump_state(hal);
#endif

	/*
	 * Get card capabilities, values, ...
	 */

	if (ar5k_eeprom_init(hal) != 0) {
		AR5K_PRINT("unable to init EEPROM\n");
		goto failed;
	}

	/* Get misc capabilities */
	if (hal->ah_get_capabilities(hal) != AH_TRUE) {
		AR5K_PRINTF("unable to get device capabilities: 0x%04x\n",
		    device);
		goto failed;
	}

	/* Get MAC address */
	if ((*status = ar5k_eeprom_read_mac(hal, mac)) != 0) {
		AR5K_PRINTF("unable to read address from EEPROM: 0x%04x\n",
		    device);
		goto failed;
	}

	hal->ah_set_lladdr(hal, mac);

	/* Get rate tables */
	if (hal->ah_capabilities.cap_mode & HAL_MODE_11A)
		ar5k_rt_copy(&hal->ah_rt_11a, &ar5k_rt_11a);
	if (hal->ah_capabilities.cap_mode & HAL_MODE_11B)
		ar5k_rt_copy(&hal->ah_rt_11b, &ar5k_rt_11b);
	if (hal->ah_capabilities.cap_mode & HAL_MODE_11G)
		ar5k_rt_copy(&hal->ah_rt_11g, &ar5k_rt_11g);
	if (hal->ah_capabilities.cap_mode & HAL_MODE_XR)
		ar5k_rt_copy(&hal->ah_rt_xr, &ar5k_rt_xr);

	/* Initialize the gain optimization values */
	if (hal->ah_radio == AR5K_AR5111) {
		hal->ah_gain.g_step_idx = ar5111_gain_opt.go_default;
		hal->ah_gain.g_step =
		    &ar5111_gain_opt.go_step[hal->ah_gain.g_step_idx];
		hal->ah_gain.g_low = 20;
		hal->ah_gain.g_high = 35;
		hal->ah_gain.g_active = 1;
	} else if (hal->ah_radio == AR5K_AR5112) {
		hal->ah_gain.g_step_idx = ar5112_gain_opt.go_default;
		hal->ah_gain.g_step =
		    &ar5111_gain_opt.go_step[hal->ah_gain.g_step_idx];
		hal->ah_gain.g_low = 20;
		hal->ah_gain.g_high = 85;
		hal->ah_gain.g_active = 1;
	} else {
		/* XXX not needed for newer chipsets? */
	}

	*status = HAL_OK;

	return (hal);

 failed:
	free(hal, M_DEVBUF, 0);
	return (NULL);
}

u_int16_t
ath_hal_computetxtime(struct ath_hal *hal, const HAL_RATE_TABLE *rates,
    u_int32_t frame_length, u_int16_t rate_index, HAL_BOOL short_preamble)
{
	const HAL_RATE *rate;
	u_int32_t value;

	AR5K_ASSERT_ENTRY(rate_index, rates->rateCount);

	/*
	 * Get rate by index
	 */
	rate = &rates->info[rate_index];

	/*
	 * Calculate the transmission time by operation (PHY) mode
	 */
	switch (rate->phy) {
	case IEEE80211_T_CCK:
		/*
		 * CCK / DS mode (802.11b)
		 */
		value = AR5K_CCK_TX_TIME(rate->rateKbps, frame_length,
		    (short_preamble && rate->shortPreamble));
		break;

	case IEEE80211_T_OFDM:
		/*
		 * Orthogonal Frequency Division Multiplexing
		 */
		if (AR5K_OFDM_NUM_BITS_PER_SYM(rate->rateKbps) == 0)
			return (0);
		value = AR5K_OFDM_TX_TIME(rate->rateKbps, frame_length);
		break;

	case IEEE80211_T_XR:
		/*
		 * Orthogonal Frequency Division Multiplexing
		 * Atheros "eXtended Range" (XR)
		 */
		if (AR5K_XR_NUM_BITS_PER_SYM(rate->rateKbps) == 0)
			return (0);
		value = AR5K_XR_TX_TIME(rate->rateKbps, frame_length);
		break;

	default:
		return (0);
	}

	return (value);
}

HAL_BOOL
ar5k_check_channel(struct ath_hal *hal, u_int16_t freq, u_int flags)
{
	/* Check if the channel is in our supported range */
	if (flags & IEEE80211_CHAN_2GHZ) {
		if ((freq >= hal->ah_capabilities.cap_range.range_2ghz_min) &&
		    (freq <= hal->ah_capabilities.cap_range.range_2ghz_max))
			return (AH_TRUE);
	} else if (flags & IEEE80211_CHAN_5GHZ) {
		if ((freq >= hal->ah_capabilities.cap_range.range_5ghz_min) &&
		    (freq <= hal->ah_capabilities.cap_range.range_5ghz_max))
			return (AH_TRUE);
	}

	return (AH_FALSE);
}

HAL_BOOL
ath_hal_init_channels(struct ath_hal *hal, HAL_CHANNEL *channels,
    u_int max_channels, u_int *channels_size, u_int16_t mode,
    HAL_BOOL outdoor, HAL_BOOL extended)
{
	u_int i, c;
	u_int32_t domain_current;
	u_int domain_5ghz, domain_2ghz;
	HAL_CHANNEL *all_channels;

	if ((all_channels = mallocarray(max_channels, sizeof(HAL_CHANNEL),
	    M_TEMP, M_NOWAIT | M_ZERO)) == NULL)
		return (AH_FALSE);

	i = c = 0;
	domain_current = hal->ah_regdomain;

	/*
	 * In debugging mode, enable all channels supported by the chipset
	 */
	if (domain_current == DMN_DEFAULT) {
		int min, max, freq;
		u_int flags;

		min = ieee80211_mhz2ieee(IEEE80211_CHANNELS_2GHZ_MIN,
		    IEEE80211_CHAN_2GHZ);
		max = ieee80211_mhz2ieee(IEEE80211_CHANNELS_2GHZ_MAX,
		    IEEE80211_CHAN_2GHZ);
		flags = CHANNEL_B |
		    (hal->ah_version == AR5K_AR5211 ?
		    CHANNEL_PUREG : CHANNEL_G);

 debugchan:
		for (i = min; i <= max && c < max_channels; i++) {
			freq = ieee80211_ieee2mhz(i, flags);
			if (ar5k_check_channel(hal, freq, flags) == AH_FALSE)
				continue;
			all_channels[c].c_channel = freq;
			all_channels[c++].c_channel_flags = flags;
		}

		if (flags & IEEE80211_CHAN_2GHZ) {
			min = ieee80211_mhz2ieee(IEEE80211_CHANNELS_5GHZ_MIN,
			    IEEE80211_CHAN_5GHZ);
			max = ieee80211_mhz2ieee(IEEE80211_CHANNELS_5GHZ_MAX,
			    IEEE80211_CHAN_5GHZ);
			flags = CHANNEL_A | CHANNEL_XR;
			goto debugchan;
		}

		goto done;
	}

	domain_5ghz = ieee80211_regdomain2flag(domain_current,
	    IEEE80211_CHANNELS_5GHZ_MIN);
	domain_2ghz = ieee80211_regdomain2flag(domain_current,
	    IEEE80211_CHANNELS_2GHZ_MIN);

	/*
	 * Create channel list based on chipset capabilities, regulation domain
	 * and mode. 5GHz...
	 */
	for (i = 0; (hal->ah_capabilities.cap_range.range_5ghz_max > 0) &&
		 (i < nitems(ar5k_5ghz_channels)) &&
		 (c < max_channels); i++) {
		/* Check if channel is supported by the chipset */
		if (ar5k_check_channel(hal,
		    ar5k_5ghz_channels[i].rc_channel,
		    IEEE80211_CHAN_5GHZ) == AH_FALSE)
			continue;

		/* Match regulation domain */
		if ((IEEE80211_DMN(ar5k_5ghz_channels[i].rc_domain) &
			IEEE80211_DMN(domain_5ghz)) == 0)
			continue;

		/* Match modes */
		if (ar5k_5ghz_channels[i].rc_mode & IEEE80211_CHAN_OFDM)
			all_channels[c].c_channel_flags = CHANNEL_A;
		else
			continue;

		/* Write channel and increment counter */
		all_channels[c++].channel = ar5k_5ghz_channels[i].rc_channel;
	}

	/*
	 * ...and 2GHz.
	 */
	for (i = 0; (hal->ah_capabilities.cap_range.range_2ghz_max > 0) &&
		 (i < nitems(ar5k_2ghz_channels)) &&
		 (c < max_channels); i++) {
		/* Check if channel is supported by the chipset */
		if (ar5k_check_channel(hal,
		    ar5k_2ghz_channels[i].rc_channel,
		    IEEE80211_CHAN_2GHZ) == AH_FALSE)
			continue;

		/* Match regulation domain */
		if ((IEEE80211_DMN(ar5k_2ghz_channels[i].rc_domain) &
			IEEE80211_DMN(domain_2ghz)) == 0)
			continue;

		/* Match modes */
		if ((hal->ah_capabilities.cap_mode & HAL_MODE_11B) &&
		    (ar5k_2ghz_channels[i].rc_mode & IEEE80211_CHAN_CCK))
			all_channels[c].c_channel_flags = CHANNEL_B;

		if ((hal->ah_capabilities.cap_mode & HAL_MODE_11G) &&
		    (ar5k_2ghz_channels[i].rc_mode & IEEE80211_CHAN_OFDM)) {
			all_channels[c].c_channel_flags |=
			    hal->ah_version == AR5K_AR5211 ?
			    CHANNEL_PUREG : CHANNEL_G;
		}

		/* Write channel and increment counter */
		all_channels[c++].channel = ar5k_2ghz_channels[i].rc_channel;
	}

 done:
	bcopy(all_channels, channels, sizeof(HAL_CHANNEL) * max_channels);
	*channels_size = c;
	free(all_channels, M_TEMP, 0);
	return (AH_TRUE);
}

/*
 * Common internal functions
 */

const char *
ar5k_printver(enum ar5k_srev_type type, u_int32_t val)
{
	struct ar5k_srev_name names[] = AR5K_SREV_NAME;
	const char *name = "xxxx";
	int i;

	for (i = 0; i < nitems(names); i++) {
		if (type == AR5K_VERSION_DEV) {
			if (names[i].sr_type == type &&
			    names[i].sr_val == val) {
				name = names[i].sr_name;
				break;
			}
			continue;
		}
		if (names[i].sr_type != type ||
		    names[i].sr_val == AR5K_SREV_UNKNOWN)
			continue;
		if ((val & 0xff) < names[i + 1].sr_val) {
			name = names[i].sr_name;
			break;
		}
	}

	return (name);
}

void
ar5k_radar_alert(struct ath_hal *hal)
{
	/*
	 * Limit ~1/s
	 */
	if (hal->ah_radar.r_last_channel.channel ==
	    hal->ah_current_channel.channel &&
	    tick < (hal->ah_radar.r_last_alert + hz))
		return;

	hal->ah_radar.r_last_channel.channel =
	    hal->ah_current_channel.channel;
	hal->ah_radar.r_last_channel.c_channel_flags =
	    hal->ah_current_channel.c_channel_flags;
	hal->ah_radar.r_last_alert = tick;

	AR5K_PRINTF("Possible radar activity detected at %u MHz (tick %u)\n",
	    hal->ah_radar.r_last_alert, hal->ah_current_channel.channel);
}

u_int16_t
ar5k_regdomain_from_ieee(ieee80211_regdomain_t ieee)
{
	u_int32_t regdomain = (u_int32_t)ieee;

	/*
	 * Use the default regulation domain if the value is empty
	 * or not supported by the net80211 regulation code.
	 */
	if (ieee80211_regdomain2flag(regdomain,
	    IEEE80211_CHANNELS_5GHZ_MIN) == DMN_DEBUG)
		return ((u_int16_t)AR5K_TUNE_REGDOMAIN);

	/* It is supported, just return the value */
	return (regdomain);
}

ieee80211_regdomain_t
ar5k_regdomain_to_ieee(u_int16_t regdomain)
{
	ieee80211_regdomain_t ieee = (ieee80211_regdomain_t)regdomain;

	return (ieee);
}

u_int16_t
ar5k_get_regdomain(struct ath_hal *hal)
{
	u_int16_t regdomain;
	ieee80211_regdomain_t ieee_regdomain;
#ifdef COUNTRYCODE
	u_int16_t code;
#endif

	ar5k_eeprom_regulation_domain(hal, AH_FALSE, &ieee_regdomain);
	hal->ah_capabilities.cap_regdomain.reg_hw = ieee_regdomain;

#ifdef COUNTRYCODE
	/*
	 * Get the regulation domain by country code. This will ignore
	 * the settings found in the EEPROM.
	 */
	code = ieee80211_name2countrycode(COUNTRYCODE);
	ieee_regdomain = ieee80211_countrycode2regdomain(code);
#endif

	regdomain = ar5k_regdomain_from_ieee(ieee_regdomain);
	hal->ah_capabilities.cap_regdomain.reg_current = regdomain;

	return (regdomain);
}

u_int32_t
ar5k_bitswap(u_int32_t val, u_int bits)
{
	if (bits == 8) {
		val = ((val & 0xF0) >>  4) | ((val & 0x0F) <<  4);
		val = ((val & 0xCC) >>  2) | ((val & 0x33) <<  2);
		val = ((val & 0xAA) >>  1) | ((val & 0x55) <<  1);

		return val;
	} else {
		u_int32_t retval = 0, bit, i;

		for (i = 0; i < bits; i++) {
			bit = (val >> i) & 1;
			retval = (retval << 1) | bit;
		}

		return retval;
	}
}

u_int
ar5k_htoclock(u_int usec)
{
	return (usec * 40);
}

u_int
ar5k_clocktoh(u_int clock)
{
	return (clock / 40);
}

void
ar5k_rt_copy(HAL_RATE_TABLE *dst, const HAL_RATE_TABLE *src)
{
	bzero(dst, sizeof(HAL_RATE_TABLE));
	dst->rateCount = src->rateCount;
	bcopy(src->rateCodeToIndex, dst->rateCodeToIndex,
	    sizeof(dst->rateCodeToIndex));
	bcopy(src->info, dst->info, sizeof(dst->info));
}

HAL_BOOL
ar5k_register_timeout(struct ath_hal *hal, u_int32_t reg, u_int32_t flag,
    u_int32_t val, HAL_BOOL is_set)
{
	int i;
	u_int32_t data;

	for (i = AR5K_TUNE_REGISTER_TIMEOUT; i > 0; i--) {
		data = AR5K_REG_READ(reg);
		if ((is_set == AH_TRUE) && (data & flag))
			break;
		else if ((data & flag) == val)
			break;
		AR5K_DELAY(15);
	}

	if (i <= 0)
		return (AH_FALSE);

	return (AH_TRUE);
}

/*
 * Common ar5xx EEPROM access functions
 */

u_int16_t
ar5k_eeprom_bin2freq(struct ath_hal *hal, u_int16_t bin, u_int mode)
{
	u_int16_t val;

	if (bin == AR5K_EEPROM_CHANNEL_DIS)
		return (bin);

	if (mode == AR5K_EEPROM_MODE_11A) {
		if (hal->ah_ee_version > AR5K_EEPROM_VERSION_3_2)
			val = (5 * bin) + 4800;
		else
			val = bin > 62 ?
			    (10 * 62) + (5 * (bin - 62)) + 5100 :
			    (bin * 10) + 5100;
	} else {
		if (hal->ah_ee_version > AR5K_EEPROM_VERSION_3_2)
			val = bin + 2300;
		else
			val = bin + 2400;
	}

	return (val);
}

int
ar5k_eeprom_read_ants(struct ath_hal *hal, u_int32_t *offset, u_int mode)
{
	struct ar5k_eeprom_info *ee = &hal->ah_capabilities.cap_eeprom;
	u_int32_t o = *offset;
	u_int16_t val;
	int ret, i = 0;

	AR5K_EEPROM_READ(o++, val);
	ee->ee_switch_settling[mode]	= (val >> 8) & 0x7f;
	ee->ee_ant_tx_rx[mode]		= (val >> 2) & 0x3f;
	ee->ee_ant_control[mode][i]	= (val << 4) & 0x3f;

	AR5K_EEPROM_READ(o++, val);
	ee->ee_ant_control[mode][i++]	|= (val >> 12) & 0xf;
	ee->ee_ant_control[mode][i++]	= (val >> 6) & 0x3f;
	ee->ee_ant_control[mode][i++]	= val & 0x3f;

	AR5K_EEPROM_READ(o++, val);
	ee->ee_ant_control[mode][i++]	= (val >> 10) & 0x3f;
	ee->ee_ant_control[mode][i++]	= (val >> 4) & 0x3f;
	ee->ee_ant_control[mode][i]	= (val << 2) & 0x3f;

	AR5K_EEPROM_READ(o++, val);
	ee->ee_ant_control[mode][i++]	|= (val >> 14) & 0x3;
	ee->ee_ant_control[mode][i++]	= (val >> 8) & 0x3f;
	ee->ee_ant_control[mode][i++]	= (val >> 2) & 0x3f;
	ee->ee_ant_control[mode][i]	= (val << 4) & 0x3f;

	AR5K_EEPROM_READ(o++, val);
	ee->ee_ant_control[mode][i++]	|= (val >> 12) & 0xf;
	ee->ee_ant_control[mode][i++]	= (val >> 6) & 0x3f;
	ee->ee_ant_control[mode][i++]	= val & 0x3f;

	/* Get antenna modes */
	hal->ah_antenna[mode][0] =
	    (ee->ee_ant_control[mode][0] << 4) | 0x1;
	hal->ah_antenna[mode][HAL_ANT_FIXED_A] =
	    ee->ee_ant_control[mode][1] |
	    (ee->ee_ant_control[mode][2] << 6) |
	    (ee->ee_ant_control[mode][3] << 12) |
	    (ee->ee_ant_control[mode][4] << 18) |
	    (ee->ee_ant_control[mode][5] << 24);
	hal->ah_antenna[mode][HAL_ANT_FIXED_B] =
	    ee->ee_ant_control[mode][6] |
	    (ee->ee_ant_control[mode][7] << 6) |
	    (ee->ee_ant_control[mode][8] << 12) |
	    (ee->ee_ant_control[mode][9] << 18) |
	    (ee->ee_ant_control[mode][10] << 24);

	/* return new offset */
	*offset = o;

	return (0);
}

int
ar5k_eeprom_read_modes(struct ath_hal *hal, u_int32_t *offset, u_int mode)
{
	struct ar5k_eeprom_info *ee = &hal->ah_capabilities.cap_eeprom;
	u_int32_t o = *offset;
	u_int16_t val;
	int ret;

	AR5K_EEPROM_READ(o++, val);
	ee->ee_tx_end2xlna_enable[mode]	= (val >> 8) & 0xff;
	ee->ee_thr_62[mode]		= val & 0xff;

	if (hal->ah_ee_version <= AR5K_EEPROM_VERSION_3_2)
		ee->ee_thr_62[mode] =
		    mode == AR5K_EEPROM_MODE_11A ? 15 : 28;

	AR5K_EEPROM_READ(o++, val);
	ee->ee_tx_end2xpa_disable[mode]	= (val >> 8) & 0xff;
	ee->ee_tx_frm2xpa_enable[mode]	= val & 0xff;

	AR5K_EEPROM_READ(o++, val);
	ee->ee_pga_desired_size[mode]	= (val >> 8) & 0xff;

	if ((val & 0xff) & 0x80)
		ee->ee_noise_floor_thr[mode] = -((((val & 0xff) ^ 0xff)) + 1);
	else
		ee->ee_noise_floor_thr[mode] = val & 0xff;

	if (hal->ah_ee_version <= AR5K_EEPROM_VERSION_3_2)
		ee->ee_noise_floor_thr[mode] =
		    mode == AR5K_EEPROM_MODE_11A ? -54 : -1;

	AR5K_EEPROM_READ(o++, val);
	ee->ee_xlna_gain[mode]		= (val >> 5) & 0xff;
	ee->ee_x_gain[mode]		= (val >> 1) & 0xf;
	ee->ee_xpd[mode]		= val & 0x1;

	if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_0)
		ee->ee_fixed_bias[mode] = (val >> 13) & 0x1;

	if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_3_3) {
		AR5K_EEPROM_READ(o++, val);
		ee->ee_false_detect[mode] = (val >> 6) & 0x7f;

		if (mode == AR5K_EEPROM_MODE_11A)
			ee->ee_xr_power[mode] = val & 0x3f;
		else {
			ee->ee_ob[mode][0] = val & 0x7;
			ee->ee_db[mode][0] = (val >> 3) & 0x7;
		}
	}

	if (hal->ah_ee_version < AR5K_EEPROM_VERSION_3_4) {
		ee->ee_i_gain[mode] = AR5K_EEPROM_I_GAIN;
		ee->ee_cck_ofdm_power_delta = AR5K_EEPROM_CCK_OFDM_DELTA;
	} else {
		ee->ee_i_gain[mode] = (val >> 13) & 0x7;

		AR5K_EEPROM_READ(o++, val);
		ee->ee_i_gain[mode] |= (val << 3) & 0x38;

		if (mode == AR5K_EEPROM_MODE_11G)
			ee->ee_cck_ofdm_power_delta = (val >> 3) & 0xff;
	}

	if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_0 &&
	    mode == AR5K_EEPROM_MODE_11A) {
		ee->ee_i_cal[mode] = (val >> 8) & 0x3f;
		ee->ee_q_cal[mode] = (val >> 3) & 0x1f;
	}

	if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_6 &&
	    mode == AR5K_EEPROM_MODE_11G)
		ee->ee_scaled_cck_delta = (val >> 11) & 0x1f;

	/* return new offset */
	*offset = o;

	return (0);
}

int
ar5k_eeprom_init(struct ath_hal *hal)
{
	struct ar5k_eeprom_info *ee = &hal->ah_capabilities.cap_eeprom;
	u_int32_t offset;
	u_int16_t val;
	int ret, i;
	u_int mode;

	/* Initial TX thermal adjustment values */
	ee->ee_tx_clip = 4;
	ee->ee_pwd_84 = ee->ee_pwd_90 = 1;
	ee->ee_gain_select = 1;

	/*
	 * Read values from EEPROM and store them in the capability structure
	 */
	AR5K_EEPROM_READ_HDR(AR5K_EEPROM_MAGIC, ee_magic);
	AR5K_EEPROM_READ_HDR(AR5K_EEPROM_PROTECT, ee_protect);
	AR5K_EEPROM_READ_HDR(AR5K_EEPROM_REG_DOMAIN, ee_regdomain);
	AR5K_EEPROM_READ_HDR(AR5K_EEPROM_VERSION, ee_version);
	AR5K_EEPROM_READ_HDR(AR5K_EEPROM_HDR, ee_header);

	/* Return if we have an old EEPROM */
	if (hal->ah_ee_version < AR5K_EEPROM_VERSION_3_0)
		return (0);

#ifdef notyet
	/*
	 * Validate the checksum of the EEPROM date. There are some
	 * devices with invalid EEPROMs.
	 */
	for (cksum = 0, offset = 0; offset < AR5K_EEPROM_INFO_MAX; offset++) {
		AR5K_EEPROM_READ(AR5K_EEPROM_INFO(offset), val);
		cksum ^= val;
	}
	if (cksum != AR5K_EEPROM_INFO_CKSUM) {
		AR5K_PRINTF("Invalid EEPROM checksum 0x%04x\n", cksum);
		return (EINVAL);
	}
#endif

	AR5K_EEPROM_READ_HDR(AR5K_EEPROM_ANT_GAIN(hal->ah_ee_version),
	    ee_ant_gain);

	if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_0) {
		AR5K_EEPROM_READ_HDR(AR5K_EEPROM_MISC0, ee_misc0);
		AR5K_EEPROM_READ_HDR(AR5K_EEPROM_MISC1, ee_misc1);
	}

	if (hal->ah_ee_version < AR5K_EEPROM_VERSION_3_3) {
		AR5K_EEPROM_READ(AR5K_EEPROM_OBDB0_2GHZ, val);
		ee->ee_ob[AR5K_EEPROM_MODE_11B][0] = val & 0x7;
		ee->ee_db[AR5K_EEPROM_MODE_11B][0] = (val >> 3) & 0x7;

		AR5K_EEPROM_READ(AR5K_EEPROM_OBDB1_2GHZ, val);
		ee->ee_ob[AR5K_EEPROM_MODE_11G][0] = val & 0x7;
		ee->ee_db[AR5K_EEPROM_MODE_11G][0] = (val >> 3) & 0x7;
	}

	/*
	 * Get conformance test limit values
	 */
	offset = AR5K_EEPROM_CTL(hal->ah_ee_version);
	ee->ee_ctls = AR5K_EEPROM_N_CTLS(hal->ah_ee_version);

	for (i = 0; i < ee->ee_ctls; i++) {
		AR5K_EEPROM_READ(offset++, val);
		ee->ee_ctl[i] = (val >> 8) & 0xff;
		ee->ee_ctl[i + 1] = val & 0xff;
	}

	/*
	 * Get values for 802.11a (5GHz)
	 */
	mode = AR5K_EEPROM_MODE_11A;

	offset = AR5K_EEPROM_MODES_11A(hal->ah_ee_version);

	if ((ret = ar5k_eeprom_read_ants(hal, &offset, mode)) != 0)
		return (ret);

	AR5K_EEPROM_READ(offset++, val);
	ee->ee_adc_desired_size[mode]	= (int8_t)((val >> 8) & 0xff);
	ee->ee_ob[mode][3]		= (val >> 5) & 0x7;
	ee->ee_db[mode][3]		= (val >> 2) & 0x7;
	ee->ee_ob[mode][2]		= (val << 1) & 0x7;

	AR5K_EEPROM_READ(offset++, val);
	ee->ee_ob[mode][2]		|= (val >> 15) & 0x1;
	ee->ee_db[mode][2]		= (val >> 12) & 0x7;
	ee->ee_ob[mode][1]		= (val >> 9) & 0x7;
	ee->ee_db[mode][1]		= (val >> 6) & 0x7;
	ee->ee_ob[mode][0]		= (val >> 3) & 0x7;
	ee->ee_db[mode][0]		= val & 0x7;

	if ((ret = ar5k_eeprom_read_modes(hal, &offset, mode)) != 0)
		return (ret);

	if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_1) {
		AR5K_EEPROM_READ(offset++, val);
		ee->ee_margin_tx_rx[mode] = val & 0x3f;
	}

	/*
	 * Get values for 802.11b (2.4GHz)
	 */
	mode = AR5K_EEPROM_MODE_11B;
	offset = AR5K_EEPROM_MODES_11B(hal->ah_ee_version);

	if ((ret = ar5k_eeprom_read_ants(hal, &offset, mode)) != 0)
		return (ret);

	AR5K_EEPROM_READ(offset++, val);
	ee->ee_adc_desired_size[mode]	= (int8_t)((val >> 8) & 0xff);
	ee->ee_ob[mode][1]		= (val >> 4) & 0x7;
	ee->ee_db[mode][1]		= val & 0x7;

	if ((ret = ar5k_eeprom_read_modes(hal, &offset, mode)) != 0)
		return (ret);

	if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_0) {
		AR5K_EEPROM_READ(offset++, val);
		ee->ee_cal_pier[mode][0] =
		    ar5k_eeprom_bin2freq(hal, val & 0xff, mode);
		ee->ee_cal_pier[mode][1] =
		    ar5k_eeprom_bin2freq(hal, (val >> 8) & 0xff, mode);

		AR5K_EEPROM_READ(offset++, val);
		ee->ee_cal_pier[mode][2] =
		    ar5k_eeprom_bin2freq(hal, val & 0xff, mode);
	}

	if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_1) {
		ee->ee_margin_tx_rx[mode] = (val >> 8) & 0x3f;
	}

	/*
	 * Get values for 802.11g (2.4GHz)
	 */
	mode = AR5K_EEPROM_MODE_11G;
	offset = AR5K_EEPROM_MODES_11G(hal->ah_ee_version);

	if ((ret = ar5k_eeprom_read_ants(hal, &offset, mode)) != 0)
		return (ret);

	AR5K_EEPROM_READ(offset++, val);
	ee->ee_adc_desired_size[mode]	= (int8_t)((val >> 8) & 0xff);
	ee->ee_ob[mode][1]		= (val >> 4) & 0x7;
	ee->ee_db[mode][1]		= val & 0x7;

	if ((ret = ar5k_eeprom_read_modes(hal, &offset, mode)) != 0)
		return (ret);

	if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_0) {
		AR5K_EEPROM_READ(offset++, val);
		ee->ee_cal_pier[mode][0] =
		    ar5k_eeprom_bin2freq(hal, val & 0xff, mode);
		ee->ee_cal_pier[mode][1] =
		    ar5k_eeprom_bin2freq(hal, (val >> 8) & 0xff, mode);

		AR5K_EEPROM_READ(offset++, val);
		ee->ee_xr_power[mode] = (val >> 7) & 0x3f;

		AR5K_EEPROM_READ(offset++, val);
		ee->ee_cal_pier[mode][2] =
		    ar5k_eeprom_bin2freq(hal, val & 0xff, mode);

		if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_1) {
			ee->ee_margin_tx_rx[mode] = (val >> 8) & 0x3f;
		}

		AR5K_EEPROM_READ(offset++, val);
		ee->ee_i_cal[mode] = (val >> 8) & 0x3f;
		ee->ee_q_cal[mode] = (val >> 3) & 0x1f;

		if (hal->ah_ee_version >= AR5K_EEPROM_VERSION_4_2) {
			AR5K_EEPROM_READ(offset++, val);
			ee->ee_cck_ofdm_gain_delta = val & 0xff;
		}
	}

	/*
	 * Read 5GHz EEPROM channels
	 */

	return (0);
}

int
ar5k_eeprom_read_mac(struct ath_hal *hal, u_int8_t *mac)
{
	u_int32_t total, offset;
	u_int16_t data;
	int octet;
	u_int8_t mac_d[IEEE80211_ADDR_LEN];

	bzero(mac, IEEE80211_ADDR_LEN);
	bzero(&mac_d, IEEE80211_ADDR_LEN);

	if (hal->ah_eeprom_read(hal, 0x20, &data) != 0)
		return (EIO);

	for (offset = 0x1f, octet = 0, total = 0;
	     offset >= 0x1d; offset--) {
		if (hal->ah_eeprom_read(hal, offset, &data) != 0)
			return (EIO);

		total += data;
		mac_d[octet + 1] = data & 0xff;
		mac_d[octet] = data >> 8;
		octet += 2;
	}

	bcopy(mac_d, mac, IEEE80211_ADDR_LEN);

	if ((!total) || total == (3 * 0xffff))
		return (EINVAL);

	return (0);
}

HAL_BOOL
ar5k_eeprom_regulation_domain(struct ath_hal *hal, HAL_BOOL write,
    ieee80211_regdomain_t *regdomain)
{
	u_int16_t ee_regdomain;

	/* Read current value */
	if (write != AH_TRUE) {
		ee_regdomain = hal->ah_capabilities.cap_eeprom.ee_regdomain;
		*regdomain = ar5k_regdomain_to_ieee(ee_regdomain);
		return (AH_TRUE);
	}

	ee_regdomain = ar5k_regdomain_from_ieee(*regdomain);

	/* Try to write a new value */
	if (hal->ah_capabilities.cap_eeprom.ee_protect &
	    AR5K_EEPROM_PROTECT_WR_128_191)
		return (AH_FALSE);
	if (hal->ah_eeprom_write(hal, AR5K_EEPROM_REG_DOMAIN,
	    ee_regdomain) != 0)
		return (AH_FALSE);

	hal->ah_capabilities.cap_eeprom.ee_regdomain = ee_regdomain;

	return (AH_TRUE);
}

/*
 * PHY/RF access functions
 */

HAL_BOOL
ar5k_channel(struct ath_hal *hal, HAL_CHANNEL *channel)
{
	HAL_BOOL ret;

	/*
	 * Check bounds supported by the PHY
	 * (don't care about regulation restrictions at this point)
	 */
	if ((channel->channel < hal->ah_capabilities.cap_range.range_2ghz_min ||
	    channel->channel > hal->ah_capabilities.cap_range.range_2ghz_max) &&
	    (channel->channel < hal->ah_capabilities.cap_range.range_5ghz_min ||
	    channel->channel > hal->ah_capabilities.cap_range.range_5ghz_max)) {
		AR5K_PRINTF("channel out of supported range (%u MHz)\n",
		    channel->channel);
		return (AH_FALSE);
	}

	/*
	 * Set the channel and wait
	 */
	if (hal->ah_radio == AR5K_AR5110)
		ret = ar5k_ar5110_channel(hal, channel);
	else if (hal->ah_radio == AR5K_AR5111)
		ret = ar5k_ar5111_channel(hal, channel);
	else
		ret = ar5k_ar5112_channel(hal, channel);

	if (ret == AH_FALSE)
		return (ret);

	hal->ah_current_channel.c_channel = channel->c_channel;
	hal->ah_current_channel.c_channel_flags = channel->c_channel_flags;

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5110_chan2athchan(HAL_CHANNEL *channel)
{
	u_int32_t athchan;

	/*
	 * Convert IEEE channel/MHz to an internal channel value used
	 * by the AR5210 chipset. This has not been verified with
	 * newer chipsets like the AR5212A who have a completely
	 * different RF/PHY part.
	 */
	athchan = (ar5k_bitswap((ieee80211_mhz2ieee(channel->c_channel,
	    channel->c_channel_flags) - 24) / 2, 5) << 1) |
	    (1 << 6) | 0x1;

	return (athchan);
}

HAL_BOOL
ar5k_ar5110_channel(struct ath_hal *hal, HAL_CHANNEL *channel)
{
	u_int32_t data;

	/*
	 * Set the channel and wait
	 */
	data = ar5k_ar5110_chan2athchan(channel);
	AR5K_PHY_WRITE(0x27, data);
	AR5K_PHY_WRITE(0x30, 0);
	AR5K_DELAY(1000);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5111_chan2athchan(u_int ieee, struct ar5k_athchan_2ghz *athchan)
{
	int channel;

	/* Cast this value to catch negative channel numbers (>= -19) */ 
	channel = (int)ieee;

	/*
	 * Map 2GHz IEEE channel to 5GHz Atheros channel
	 */
	if (channel <= 13) {
		athchan->a2_athchan = 115 + channel;
		athchan->a2_flags = 0x46;
	} else if (channel == 14) {
		athchan->a2_athchan = 124;
		athchan->a2_flags = 0x44;
	} else if (channel >= 15 && channel <= 26) {
		athchan->a2_athchan = ((channel - 14) * 4) + 132;
		athchan->a2_flags = 0x46;
	} else
		return (AH_FALSE);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5111_channel(struct ath_hal *hal, HAL_CHANNEL *channel)
{
	u_int ieee_channel, ath_channel;
	u_int32_t data0, data1, clock;
	struct ar5k_athchan_2ghz ath_channel_2ghz;

	/*
	 * Set the channel on the AR5111 radio
	 */
	data0 = data1 = 0;
	ath_channel = ieee_channel = ieee80211_mhz2ieee(channel->c_channel,
	    channel->c_channel_flags);

	if (channel->c_channel_flags & IEEE80211_CHAN_2GHZ) {
		/* Map 2GHz channel to 5GHz Atheros channel ID */
		if (ar5k_ar5111_chan2athchan(ieee_channel,
			&ath_channel_2ghz) == AH_FALSE)
			return (AH_FALSE);

		ath_channel = ath_channel_2ghz.a2_athchan;
		data0 = ((ar5k_bitswap(ath_channel_2ghz.a2_flags, 8) & 0xff)
		    << 5) | (1 << 4);
	}

	if (ath_channel < 145 || !(ath_channel & 1)) {
		clock = 1;
		data1 = ((ar5k_bitswap(ath_channel - 24, 8) & 0xff) << 2)
		    | (clock << 1) | (1 << 10) | 1;
	} else {
		clock = 0;
		data1 = ((ar5k_bitswap((ath_channel - 24) / 2, 8) & 0xff) << 2)
		    | (clock << 1) | (1 << 10) | 1;
	}

	AR5K_PHY_WRITE(0x27, (data1 & 0xff) | ((data0 & 0xff) << 8));
	AR5K_PHY_WRITE(0x34, ((data1 >> 8) & 0xff) | (data0 & 0xff00));

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5112_channel(struct ath_hal *hal, HAL_CHANNEL *channel)
{
	u_int32_t data, data0, data1, data2;
	u_int16_t c;

	data = data0 = data1 = data2 = 0;
	c = channel->c_channel + hal->ah_chanoff;

	/*
	 * Set the channel on the AR5112 or newer
	 */
	if (c < 4800) {
		if (!((c - 2224) % 5)) {
			data0 = ((2 * (c - 704)) - 3040) / 10;
			data1 = 1;
		} else if (!((c - 2192) % 5)) {
			data0 = ((2 * (c - 672)) - 3040) / 10;
			data1 = 0;
		} else
			return (AH_FALSE);

		data0 = ar5k_bitswap((data0 << 2) & 0xff, 8);
	} else {
		if (!(c % 20) && c >= 5120) {
			data0 = ar5k_bitswap(((c - 4800) / 20 << 2), 8);
			data2 = ar5k_bitswap(3, 2);
		} else if (!(c % 10)) {
			data0 = ar5k_bitswap(((c - 4800) / 10 << 1), 8);
			data2 = ar5k_bitswap(2, 2);
		} else if (!(c % 5)) {
			data0 = ar5k_bitswap((c - 4800) / 5, 8);
			data2 = ar5k_bitswap(1, 2);
		} else
			return (AH_FALSE);
	}

	data = (data0 << 4) | (data1 << 1) | (data2 << 2) | 0x1001;

	AR5K_PHY_WRITE(0x27, data & 0xff);
	AR5K_PHY_WRITE(0x36, (data >> 8) & 0x7f);

	return (AH_TRUE);
}

u_int
ar5k_rfregs_op(u_int32_t *rf, u_int32_t offset, u_int32_t reg, u_int32_t bits,
    u_int32_t first, u_int32_t col, HAL_BOOL set)
{
	u_int32_t mask, entry, last, data, shift, position;
	int32_t left;
	int i;

	if (rf == NULL) {
		/* should not happen */
		return (0);
	}

	if (!(col <= 3 && bits <= 32 && first + bits <= 319)) {
		AR5K_PRINTF("invalid values at offset %u\n", offset);
		return (0);
	}

	entry = ((first - 1) / 8) + offset;
	position = (first - 1) % 8;

	if (set == AH_TRUE)
		data = ar5k_bitswap(reg, bits);

	for (i = shift = 0, left = bits; left > 0; position = 0, entry++, i++) {
		last = (position + left > 8) ? 8 : position + left;
		mask = (((1 << last) - 1) ^ ((1 << position) - 1)) <<
		    (col * 8);

		if (set == AH_TRUE) {
			rf[entry] &= ~mask;
			rf[entry] |= ((data << position) << (col * 8)) & mask;
			data >>= (8 - position);
		} else {
			data = (((rf[entry] & mask) >> (col * 8)) >>
			    position) << shift;
			shift += last - position;
		}

		left -= 8 - position;
	}

	data = set == AH_TRUE ? 1 : ar5k_bitswap(data, bits);

	return (data);
}

u_int32_t
ar5k_rfregs_gainf_corr(struct ath_hal *hal)
{
	u_int32_t mix, step;
	u_int32_t *rf;

	if (hal->ah_rf_banks == NULL)
		return (0);

	rf = hal->ah_rf_banks;
	hal->ah_gain.g_f_corr = 0;

	if (ar5k_rfregs_op(rf, hal->ah_offset[7], 0, 1, 36, 0, AH_FALSE) != 1)
		return (0);

	step = ar5k_rfregs_op(rf, hal->ah_offset[7], 0, 4, 32, 0, AH_FALSE);
	mix = hal->ah_gain.g_step->gos_param[0];

	switch (mix) {
	case 3:
		hal->ah_gain.g_f_corr = step * 2;
		break;
	case 2:
		hal->ah_gain.g_f_corr = (step - 5) * 2;
		break;
	case 1:
		hal->ah_gain.g_f_corr = step;
		break;
	default:
		hal->ah_gain.g_f_corr = 0;
		break;
	}

	return (hal->ah_gain.g_f_corr);
}

HAL_BOOL
ar5k_rfregs_gain_readback(struct ath_hal *hal)
{
	u_int32_t step, mix, level[4];
	u_int32_t *rf;

	if (hal->ah_rf_banks == NULL)
		return (0);

	rf = hal->ah_rf_banks;

	if (hal->ah_radio == AR5K_AR5111) {
		step = ar5k_rfregs_op(rf, hal->ah_offset[7],
		    0, 6, 37, 0, AH_FALSE);
		level[0] = 0;
		level[1] = (step == 0x3f) ? 0x32 : step + 4;
		level[2] = (step != 0x3f) ? 0x40 : level[0];
		level[3] = level[2] + 0x32;

		hal->ah_gain.g_high = level[3] -
		    (step == 0x3f ? AR5K_GAIN_DYN_ADJUST_HI_MARGIN : -5);
		hal->ah_gain.g_low = level[0] +
		    (step == 0x3f ? AR5K_GAIN_DYN_ADJUST_LO_MARGIN : 0);
	} else {
		mix = ar5k_rfregs_op(rf, hal->ah_offset[7],
		    0, 1, 36, 0, AH_FALSE);
		level[0] = level[2] = 0;

		if (mix == 1) {
			level[1] = level[3] = 83;
		} else {
			level[1] = level[3] = 107;
			hal->ah_gain.g_high = 55;
		}
	}

	return ((hal->ah_gain.g_current >= level[0] &&
	    hal->ah_gain.g_current <= level[1]) ||
	    (hal->ah_gain.g_current >= level[2] &&
	    hal->ah_gain.g_current <= level[3]));
}

int32_t
ar5k_rfregs_gain_adjust(struct ath_hal *hal)
{
	int ret = 0;
	const struct ar5k_gain_opt *go;

	go = hal->ah_radio == AR5K_AR5111 ?
	    &ar5111_gain_opt : &ar5112_gain_opt;

	hal->ah_gain.g_step = &go->go_step[hal->ah_gain.g_step_idx];

	if (hal->ah_gain.g_current >= hal->ah_gain.g_high) {
		if (hal->ah_gain.g_step_idx == 0)
			return (-1);
		for (hal->ah_gain.g_target = hal->ah_gain.g_current;
		    hal->ah_gain.g_target >=  hal->ah_gain.g_high &&
		    hal->ah_gain.g_step_idx > 0;
		    hal->ah_gain.g_step =
		    &go->go_step[hal->ah_gain.g_step_idx]) {
			hal->ah_gain.g_target -= 2 *
			    (go->go_step[--(hal->ah_gain.g_step_idx)].gos_gain -
			    hal->ah_gain.g_step->gos_gain);
		}

		ret = 1;
		goto done;
	}

	if (hal->ah_gain.g_current <= hal->ah_gain.g_low) {
		if (hal->ah_gain.g_step_idx == (go->go_steps_count - 1))
			return (-2);
		for (hal->ah_gain.g_target = hal->ah_gain.g_current;
		    hal->ah_gain.g_target <=  hal->ah_gain.g_low &&
		    hal->ah_gain.g_step_idx < (go->go_steps_count - 1);
		    hal->ah_gain.g_step =
		    &go->go_step[hal->ah_gain.g_step_idx]) {
			hal->ah_gain.g_target -= 2 *
			    (go->go_step[++(hal->ah_gain.g_step_idx)].gos_gain -
			    hal->ah_gain.g_step->gos_gain);
		}

		ret = 2;
		goto done;
	}

 done:
#ifdef AR5K_DEBUG
	AR5K_PRINTF("ret %d, gain step %u, current gain %u, target gain %u\n",
	    ret,
	    hal->ah_gain.g_step_idx,
	    hal->ah_gain.g_current,
	    hal->ah_gain.g_target);
#endif

	return (ret);
}

HAL_BOOL
ar5k_rfregs(struct ath_hal *hal, HAL_CHANNEL *channel, u_int mode)
{
	ar5k_rfgain_t *func = NULL;
	HAL_BOOL ret;

	switch (hal->ah_radio) {
	case AR5K_AR5111:
		hal->ah_rf_banks_size = sizeof(ar5111_rf);
		func = ar5k_ar5111_rfregs;
		break;
	case AR5K_AR5112:
		if (hal->ah_radio_5ghz_revision >= AR5K_SREV_RAD_5112A)
			hal->ah_rf_banks_size = sizeof(ar5112a_rf);
		else
			hal->ah_rf_banks_size = sizeof(ar5112_rf);
		func = ar5k_ar5112_rfregs;
		break;
	case AR5K_AR5413:
		hal->ah_rf_banks_size = sizeof(ar5413_rf);
		func = ar5k_arxxxx_rfregs;
		break;
	case AR5K_AR2413:
		hal->ah_rf_banks_size = sizeof(ar2413_rf);
		func = ar5k_arxxxx_rfregs;
		break;
	case AR5K_AR2425:
		hal->ah_rf_banks_size = sizeof(ar2425_rf);
		func = ar5k_arxxxx_rfregs;
		break;
	default:
		return (AH_FALSE);
	}

	if (hal->ah_rf_banks == NULL) {
		/* XXX do extra checks? */
		if ((hal->ah_rf_banks = malloc(hal->ah_rf_banks_size,
		    M_DEVBUF, M_NOWAIT | M_ZERO)) == NULL) {
			AR5K_PRINT("out of memory\n");
			return (AH_FALSE);
		}
	}

	ret = (func)(hal, channel, mode);

	if (ret == AH_TRUE)
		hal->ah_rf_gain = HAL_RFGAIN_INACTIVE;

	return (ret);
}

HAL_BOOL
ar5k_ar5111_rfregs(struct ath_hal *hal, HAL_CHANNEL *channel, u_int mode)
{
	struct ar5k_eeprom_info *ee = &hal->ah_capabilities.cap_eeprom;
	const u_int rf_size = nitems(ar5111_rf);
	u_int32_t *rf;
	int i, obdb = -1, bank = -1;
	u_int32_t ee_mode;

	AR5K_ASSERT_ENTRY(mode, AR5K_INI_VAL_MAX);

	rf = hal->ah_rf_banks;

	/* Copy values to modify them */
	for (i = 0; i < rf_size; i++) {
		if (ar5111_rf[i].rf_bank >=
		    AR5K_AR5111_INI_RF_MAX_BANKS) {
			AR5K_PRINT("invalid bank\n");
			return (AH_FALSE);
		}

		if (bank != ar5111_rf[i].rf_bank) {
			bank = ar5111_rf[i].rf_bank;
			hal->ah_offset[bank] = i;
		}

		rf[i] = ar5111_rf[i].rf_value[mode];
	}

	if (channel->c_channel_flags & IEEE80211_CHAN_2GHZ) {
		if ((channel->c_channel_flags & IEEE80211_CHAN_G) ==
		    IEEE80211_CHAN_G)
			ee_mode = AR5K_EEPROM_MODE_11G;
		else
			ee_mode = AR5K_EEPROM_MODE_11B;
		obdb = 0;

		if (!ar5k_rfregs_op(rf, hal->ah_offset[0],
			ee->ee_ob[ee_mode][obdb], 3, 119, 0, AH_TRUE))
			return (AH_FALSE);

		if (!ar5k_rfregs_op(rf, hal->ah_offset[0],
			ee->ee_ob[ee_mode][obdb], 3, 122, 0, AH_TRUE))
			return (AH_FALSE);

		obdb = 1;
	} else {
		/* For 11a, Turbo and XR */
		ee_mode = AR5K_EEPROM_MODE_11A;
		obdb = channel->c_channel >= 5725 ? 3 :
		    (channel->c_channel >= 5500 ? 2 :
			(channel->c_channel >= 5260 ? 1 :
			    (channel->c_channel > 4000 ? 0 : -1)));

		if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
			ee->ee_pwd_84, 1, 51, 3, AH_TRUE))
			return (AH_FALSE);

		if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
			ee->ee_pwd_90, 1, 45, 3, AH_TRUE))
			return (AH_FALSE);
	}

	if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
		!ee->ee_xpd[ee_mode], 1, 95, 0, AH_TRUE))
		return (AH_FALSE);

	if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
		ee->ee_x_gain[ee_mode], 4, 96, 0, AH_TRUE))
		return (AH_FALSE);

	if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
		obdb >= 0 ? ee->ee_ob[ee_mode][obdb] : 0, 3, 104, 0, AH_TRUE))
		return (AH_FALSE);

	if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
		obdb >= 0 ? ee->ee_db[ee_mode][obdb] : 0, 3, 107, 0, AH_TRUE))
		return (AH_FALSE);

	if (!ar5k_rfregs_op(rf, hal->ah_offset[7],
		ee->ee_i_gain[ee_mode], 6, 29, 0, AH_TRUE))
		return (AH_FALSE);

	if (!ar5k_rfregs_op(rf, hal->ah_offset[7],
		ee->ee_xpd[ee_mode], 1, 4, 0, AH_TRUE))
		return (AH_FALSE);

	/* Write RF values */
	for (i = 0; i < rf_size; i++) {
		AR5K_REG_WAIT(i);
		AR5K_REG_WRITE(ar5111_rf[i].rf_register, rf[i]);
	}

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5112_rfregs(struct ath_hal *hal, HAL_CHANNEL *channel, u_int mode)
{
	struct ar5k_eeprom_info *ee = &hal->ah_capabilities.cap_eeprom;
	u_int rf_size;
	u_int32_t *rf;
	int i, obdb = -1, bank = -1;
	u_int32_t ee_mode;
	const struct ar5k_ini_rf *rf_ini;

	AR5K_ASSERT_ENTRY(mode, AR5K_INI_VAL_MAX);

	rf = hal->ah_rf_banks;

	if (hal->ah_radio_5ghz_revision >= AR5K_SREV_RAD_5112A) {
		rf_ini = ar5112a_rf;
		rf_size = nitems(ar5112a_rf);
	} else {
		rf_ini = ar5112_rf;
		rf_size = nitems(ar5112_rf);
	}

	/* Copy values to modify them */
	for (i = 0; i < rf_size; i++) {
		if (rf_ini[i].rf_bank >=
		    AR5K_AR5112_INI_RF_MAX_BANKS) {
			AR5K_PRINT("invalid bank\n");
			return (AH_FALSE);
		}

		if (bank != rf_ini[i].rf_bank) {
			bank = rf_ini[i].rf_bank;
			hal->ah_offset[bank] = i;
		}

		rf[i] = rf_ini[i].rf_value[mode];
	}

	if (channel->c_channel_flags & IEEE80211_CHAN_2GHZ) {
		if ((channel->c_channel_flags & IEEE80211_CHAN_G) ==
		    IEEE80211_CHAN_G)
			ee_mode = AR5K_EEPROM_MODE_11G;
		else
			ee_mode = AR5K_EEPROM_MODE_11B;
		obdb = 0;

		if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
			ee->ee_ob[ee_mode][obdb], 3, 287, 0, AH_TRUE))
			return (AH_FALSE);

		if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
			ee->ee_ob[ee_mode][obdb], 3, 290, 0, AH_TRUE))
			return (AH_FALSE);
	} else {
		/* For 11a, Turbo and XR */
		ee_mode = AR5K_EEPROM_MODE_11A;
		obdb = channel->c_channel >= 5725 ? 3 :
		    (channel->c_channel >= 5500 ? 2 :
			(channel->c_channel >= 5260 ? 1 :
			    (channel->c_channel > 4000 ? 0 : -1)));

		/* bogus channel: bad beacon? */
		if (obdb < 0)
			return (AH_FALSE);

		if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
			ee->ee_ob[ee_mode][obdb], 3, 279, 0, AH_TRUE))
			return (AH_FALSE);

		if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
			ee->ee_ob[ee_mode][obdb], 3, 282, 0, AH_TRUE))
			return (AH_FALSE);
	}

#ifdef notyet
	ar5k_rfregs_op(rf, hal->ah_offset[6],
	    ee->ee_x_gain[ee_mode], 2, 270, 0, AH_TRUE);
	ar5k_rfregs_op(rf, hal->ah_offset[6],
	    ee->ee_x_gain[ee_mode], 2, 257, 0, AH_TRUE);
#endif

	if (!ar5k_rfregs_op(rf, hal->ah_offset[6],
		ee->ee_xpd[ee_mode], 1, 302, 0, AH_TRUE))
		return (AH_FALSE);

	if (!ar5k_rfregs_op(rf, hal->ah_offset[7],
		ee->ee_i_gain[ee_mode], 6, 14, 0, AH_TRUE))
		return (AH_FALSE);

	/* Write RF values */
	for (i = 0; i < rf_size; i++)
		AR5K_REG_WRITE(rf_ini[i].rf_register, rf[i]);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_arxxxx_rfregs(struct ath_hal *hal, HAL_CHANNEL *channel, u_int mode)
{
	const struct ar5k_ini_rf	*rf_ini;
	u_int				 rf_size;
	u_int32_t			*rf;
	int				 i, bank = -1;

	AR5K_ASSERT_ENTRY(mode, AR5K_INI_VAL_MAX);

	rf = hal->ah_rf_banks;

	switch (hal->ah_radio) {
	case AR5K_AR5413:
		rf_ini = ar5413_rf;
		rf_size = nitems(ar5413_rf);
		break;
	case AR5K_AR2413:
		rf_ini = ar2413_rf;
		rf_size = nitems(ar2413_rf);
		break;
	case AR5K_AR2425:
		if (mode == AR5K_INI_VAL_11B)
			mode = AR5K_INI_VAL_11G;
		rf_ini = ar2425_rf;
		rf_size = nitems(ar2425_rf);
		break;
	default:
		return (AH_FALSE);
	}

	/* Copy values to modify them */
	for (i = 0; i < rf_size; i++) {
		if (rf_ini[i].rf_bank >= AR5K_MAX_RF_BANKS) {
			AR5K_PRINT("invalid bank\n");
			return (AH_FALSE);
		}

		if (bank != rf_ini[i].rf_bank) {
			bank = rf_ini[i].rf_bank;
			hal->ah_offset[bank] = i;
		}

		rf[i] = rf_ini[i].rf_value[mode];
	}

	/* Write RF values */
	for (i = 0; i < rf_size; i++)
		AR5K_REG_WRITE(rf_ini[i].rf_register, rf[i]);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_rfgain(struct ath_hal *hal, u_int freq)
{
	const struct ar5k_ini_rfgain	*rfg;
	size_t				 rfg_size;
	int				 i;

	switch (hal->ah_radio) {
	case AR5K_AR5111:
		rfg = ar5111_rfg;
		rfg_size = nitems(ar5111_rfg);
		break;
	case AR5K_AR5112:
		rfg = ar5112_rfg;
		rfg_size = nitems(ar5112_rfg);
		break;
	case AR5K_AR5413:
		rfg = ar5413_rfg;
		rfg_size = nitems(ar5413_rfg);
		break;
	case AR5K_AR2413:
	case AR5K_AR2425:
		if (freq == AR5K_INI_RFGAIN_5GHZ)
			return (AH_FALSE);
		rfg = ar2413_rfg;
		rfg_size = nitems(ar2413_rfg);
		break;
	default:
		return (AH_FALSE);
	}

	switch (freq) {
	case AR5K_INI_RFGAIN_2GHZ:
	case AR5K_INI_RFGAIN_5GHZ:
		break;
	default:
		return (AH_FALSE);
	}

	for (i = 0; i < rfg_size; i++) {
		AR5K_REG_WAIT(i);
		AR5K_REG_WRITE((u_int32_t)rfg[i].rfg_register,
		    rfg[i].rfg_value[freq]);
	}

	return (AH_TRUE);
}

/*
 * Common TX power setup
 */
void
ar5k_txpower_table(struct ath_hal *hal, HAL_CHANNEL *channel, int16_t max_power)
{
	u_int16_t txpower, *rates;
	int i, min, max, n;

	rates = hal->ah_txpower.txp_rates;

	txpower = AR5K_TUNE_DEFAULT_TXPOWER * 2;
	if (max_power > txpower) {
		txpower = max_power > AR5K_TUNE_MAX_TXPOWER ?
		    AR5K_TUNE_MAX_TXPOWER : max_power;
	}

	for (i = 0; i < AR5K_MAX_RATES; i++)
		rates[i] = txpower;

	/* XXX setup target powers by rate */

	hal->ah_txpower.txp_min = rates[7];
	hal->ah_txpower.txp_max = rates[0];
	hal->ah_txpower.txp_ofdm = rates[0];

	/* Calculate the power table */
	n = nitems(hal->ah_txpower.txp_pcdac);
	min = AR5K_EEPROM_PCDAC_START;
	max = AR5K_EEPROM_PCDAC_STOP;
	for (i = 0; i < n; i += AR5K_EEPROM_PCDAC_STEP)
		hal->ah_txpower.txp_pcdac[i] =
#ifdef notyet
		    min + ((i * (max - min)) / n);
#else
		    min;
#endif
}

void
ar5k_write_ini(struct ath_hal *hal, const struct ar5k_ini *ini,
    size_t n, HAL_BOOL change_channel)
{
	u_int	 i;

	for (i = 0; i < n; i++) {
		if (change_channel == AH_TRUE &&
		    ini[i].ini_register >= AR5K_PCU_MIN &&
		    ini[i].ini_register <= AR5K_PCU_MAX)
			continue;
		switch (ini[i].ini_mode) {
		case AR5K_INI_READ:
			/* cleared on read */
			AR5K_REG_READ((u_int32_t)ini[i].ini_register);
			break;
		case AR5K_INI_WRITE:
			AR5K_REG_WAIT(i);
			AR5K_REG_WRITE((u_int32_t)ini[i].ini_register,
			    ini[i].ini_value);
			break;
		}
	}
}

void
ar5k_write_mode(struct ath_hal *hal, const struct ar5k_mode *ini,
    size_t n, u_int mode)
{
	u_int	 i;

	for (i = 0; i < n; i++) {
		AR5K_REG_WAIT(i);
		AR5K_REG_WRITE((u_int32_t)ini[i].mode_register,
		    ini[i].mode_value[mode]);
	}
}
@


1.58
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.57 2014/07/12 18:48:17 tedu Exp $	*/
a77 1
static const HAL_RATE_TABLE ar5k_rt_turbo = AR5K_RATES_TURBO;
a200 1
	hal->ah_turbo = AH_FALSE;
a266 2
	if (hal->ah_capabilities.cap_mode & HAL_MODE_TURBO)
		ar5k_rt_copy(&hal->ah_rt_turbo, &ar5k_rt_turbo);
a332 10
	case IEEE80211_T_TURBO:
		/*
		 * Orthogonal Frequency Division Multiplexing
		 * Atheros "Turbo Mode" (doubled rates)
		 */
		if (AR5K_TURBO_NUM_BITS_PER_SYM(rate->rateKbps) == 0)
			return (0);
		value = AR5K_TURBO_TX_TIME(rate->rateKbps, frame_length);
		break;

d395 1
a395 1
		flags = CHANNEL_B | CHANNEL_TG |
d413 1
a413 1
			flags = CHANNEL_A | CHANNEL_T | CHANNEL_XR;
d444 1
a444 4
		if (ar5k_5ghz_channels[i].rc_mode & IEEE80211_CHAN_TURBO) {
			all_channels[c].c_channel_flags = CHANNEL_T;
		} else if (ar5k_5ghz_channels[i].rc_mode &
		    IEEE80211_CHAN_OFDM) {
d446 1
a446 1
		} else
a479 3
			if (ar5k_2ghz_channels[i].rc_mode &
			    IEEE80211_CHAN_TURBO)
				all_channels[c].c_channel_flags |= CHANNEL_TG;
d620 1
a620 1
ar5k_htoclock(u_int usec, HAL_BOOL turbo)
d622 1
a622 1
	return (turbo == AH_TRUE ? (usec * 80) : (usec * 40));
d626 1
a626 1
ar5k_clocktoh(u_int clock, HAL_BOOL turbo)
d628 1
a628 1
	return (turbo == AH_TRUE ? (clock / 80) : (clock / 40));
a905 3
	ee->ee_turbo_max_power[mode] =
	    AR5K_EEPROM_HDR_T_5GHZ_DBM(ee->ee_header);

a990 1
		ee->ee_turbo_max_power[mode] = val & 0x7f;
a1115 2
	hal->ah_turbo = channel->c_channel_flags == CHANNEL_T ?
	    AH_TRUE : AH_FALSE;
@


1.57
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.56 2012/01/28 12:45:48 stsp Exp $	*/
d391 1
a391 1
	if ((all_channels = malloc(sizeof(HAL_CHANNEL) * max_channels,
@


1.56
log
@Fix ar5k_rt_copy() to copy all fields of the HAL_RATE_TABLE struct.
ok mikeb deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.55 2009/09/23 18:03:30 damien Exp $	*/
d298 1
a298 1
	free(hal, M_DEVBUF);
d509 1
a509 1
	free(all_channels, M_TEMP);
@


1.55
log
@do not attach the AR5416 and AR5418 (AR5416 PCIe) to the ath(4)
driver as these chipsets are not currently supported.

noticed by ian@@
"makes sense" millert@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.54 2009/06/02 12:39:02 reyk Exp $	*/
d656 2
@


1.54
log
@replace custom macro AR5K_ELEMENTS() with nitems()
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.53 2009/06/02 12:09:26 guenther Exp $	*/
a67 4
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5416,
	    ar5k_ar5212_attach },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5418,
@


1.53
log
@If a bogus channel is encountered, return an error instead of trying
to use the -1 flag value as an array index.
Found by Parfait.

ok reyk@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.52 2008/07/30 07:43:01 reyk Exp $	*/
d148 1
a148 1
	for (i = 0; i < AR5K_ELEMENTS(ar5k_known_products); i++) {
d175 1
a175 1
	for (i = 0; i < AR5K_ELEMENTS(ar5k_known_products); i++) {
d448 1
a448 1
		 (i < AR5K_ELEMENTS(ar5k_5ghz_channels)) &&
d478 1
a478 1
		 (i < AR5K_ELEMENTS(ar5k_2ghz_channels)) &&
d528 1
a528 1
	for (i = 0; i < AR5K_ELEMENTS(names); i++) {
d1531 1
a1531 1
	const u_int rf_size = AR5K_ELEMENTS(ar5111_rf);
d1639 1
a1639 1
		rf_size = AR5K_ELEMENTS(ar5112a_rf);
d1642 1
a1642 1
		rf_size = AR5K_ELEMENTS(ar5112_rf);
d1734 1
a1734 1
		rf_size = AR5K_ELEMENTS(ar5413_rf);
d1738 1
a1738 1
		rf_size = AR5K_ELEMENTS(ar2413_rf);
d1744 1
a1744 1
		rf_size = AR5K_ELEMENTS(ar2425_rf);
d1782 1
a1782 1
		rfg_size = AR5K_ELEMENTS(ar5111_rfg);
d1786 1
a1786 1
		rfg_size = AR5K_ELEMENTS(ar5112_rfg);
d1790 1
a1790 1
		rfg_size = AR5K_ELEMENTS(ar5413_rfg);
d1797 1
a1797 1
		rfg_size = AR5K_ELEMENTS(ar2413_rfg);
d1847 1
a1847 1
	n = AR5K_ELEMENTS(hal->ah_txpower.txp_pcdac);
@


1.52
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.51 2008/07/30 07:15:39 reyk Exp $	*/
d1683 4
@


1.51
log
@Update the RF, RFGAIN, MODE, INI, and BBGAIN initialization tables
with different versions for various ar5212 variants and add an extra
table for PCI-E devices.  This fixes support for various newer devices
(like the 1st generation MacBook, T61 variants) but it still does not
work on a number of other devices.

Tested by many
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.50 2008/07/29 00:18:25 reyk Exp $	*/
d269 1
a269 1
	if (hal->ah_capabilities.cap_mode & HAL_MODE_11B) {
d271 1
a271 1
	} if (hal->ah_capabilities.cap_mode & HAL_MODE_11G)
@


1.50
log
@- fix FIFO overruns on PCI-E chipsets by setting the DMA size
RX/TX configuration registers to 128 instead of 512 bytes.
- add a few more MAC/RF id strings for the dmesg.
- check for PCI-E instead of single chip variants in a few places.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.49 2008/07/28 16:56:06 reyk Exp $	*/
d98 1
d122 7
a128 1
static const struct ar5k_ini_rfgain ar5k_rfg[] = AR5K_INI_RFGAIN;
a270 7
		/*
		 * XXX Workaround for AR24xx/AR54xx and newer chipsets
		 * XXX to limit 11b operation to 1-2Mbit/s. This
		 * XXX needs to be fixed but allows basic operation for now.
		 */
		if (hal->ah_pci_express == AH_TRUE)
			hal->ah_rt_11b.rateCount = 2;
d293 2
a1261 14
		/*
		 * XXX Workaround for AR24xx/AR54xx and newer chipsets to
		 * XXX set the 2GHz channels correctly.
		 * XXX This needs to be replaced with a true algorithm
		 * XXX after figuring out how to calculate the Atheros
		 * XXX channel for these chipsets.
		 */
		if (hal->ah_pci_express == AH_TRUE) {
			c += c < 2427 ? -45 :		/* channel 1-3 */
			    (c < 2447 ? -40 :		/* channel 4-7 */
			    (c < 2462 ? -35 :		/* channel 8-10 */
			    (c < 2477 ? -30 : -25)));	/* channel 11-13 */
		}

d1482 2
a1483 1
	if (hal->ah_radio == AR5K_AR5111) {
d1486 2
a1487 1
	} else if (hal->ah_radio == AR5K_AR5112) {
d1493 14
a1506 1
	} else
d1508 1
d1710 1
a1710 1
		AR5K_REG_WRITE(ar5112_rf[i].rf_register, rf[i]);
d1716 1
a1716 1
ar5k_rfgain(struct ath_hal *hal, u_int phy, u_int freq)
d1718 49
a1766 1
	int i;
d1768 26
a1793 3
	switch (phy) {
	case AR5K_INI_PHY_5111:
	case AR5K_INI_PHY_5112:
d1807 1
a1807 1
	for (i = 0; i < AR5K_ELEMENTS(ar5k_rfg); i++) {
d1809 2
a1810 2
		AR5K_REG_WRITE((u_int32_t)ar5k_rfg[i].rfg_register,
		    ar5k_rfg[i].rfg_value[phy][freq]);
d1853 38
@


1.49
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.48 2008/07/28 10:02:32 reyk Exp $	*/
d155 1
a155 1
    bus_space_handle_t sh, u_int is_64bit, int *status)
d208 1
a218 16
	case PCI_PRODUCT_ATHEROS_AR5212_IBM:
		/*
		 * IBM ThinkPads use the same device ID for different
		 * chipset versions. Ugh.
		 */
		if (is_64bit) {
			/*
			 * PCI Express "Mini Card" interface based on the
			 * AR5424 chipset
			 */
			hal->ah_single_chip = AH_TRUE;
		} else {
			/* Classic Mini PCI interface based on AR5212 */
			hal->ah_single_chip = AH_FALSE;
		}
		break;
d269 1
a269 1
		if (hal->ah_single_chip == AH_TRUE)
d1267 1
a1267 1
		if (hal->ah_single_chip == AH_TRUE) {
@


1.48
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.47 2007/12/03 19:14:04 fgsch Exp $	*/
d71 1
a71 1
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5416_PCIE,
@


1.47
log
@Check for G channels before B when setting the (eeprom) mode.
based on a change from Luis R. Rodriguez <mcgrof at gmail dot com>. reyk@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.46 2007/10/13 01:54:22 reyk Exp $	*/
d71 1
a71 1
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5418,
@


1.46
log
@add the AR5416 and AR5418 device IDs (needs some more testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.45 2007/10/12 15:34:11 reyk Exp $	*/
d1568 4
a1571 1
		if (channel->c_channel_flags & IEEE80211_CHAN_B)
a1572 2
		else
			ee_mode = AR5K_EEPROM_MODE_11G;
d1673 4
a1676 1
		if (channel->c_channel_flags & IEEE80211_CHAN_B)
a1677 2
		else
			ee_mode = AR5K_EEPROM_MODE_11G;
@


1.45
log
@The newer single chip Atheros wireless chipsets like the AR5424,
AR2423 etc. are mostly compatible to the AR5212 but use a different
algorithm to set the 2GHz RF channel, that's why they didn't work in
OpenBSD.  I figured out that the channels were set with an offset,
setting channel 11 in the driver caused the hardware to set channel 5
etc.  Because I didn't figure out the pattern to fix the algoritm yet,
I fixed it in a workaroundish way by defining a small "table" with
offsets for the 11b channels to get the right results. For example, if
we want to set channel 11 (2462MHz), we add an offset of -30MHz, and
feed the result (2432MHz ^= channel 5) into the unmodified
AR5212/AR5112 RF setup function.

Long description for a commit message, but it needed some time to
figure it out. It is still not perfect, needs some more work, and it
doesn't work in all cases; but it allows to use newer chipsets in 11b
mode restricted to 1 or to 2Mbit/s.  11a mode seems to work without
problems so far.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.44 2007/09/11 13:39:33 gilles Exp $	*/
d68 4
@


1.44
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.43 2007/09/07 10:57:23 reyk Exp $	*/
d273 1
a273 1
	if (hal->ah_capabilities.cap_mode & HAL_MODE_11B)
d275 8
a282 1
	if (hal->ah_capabilities.cap_mode & HAL_MODE_11G)
d1265 1
a1265 1
	c = channel->c_channel;
d1271 14
@


1.43
log
@use M_ZERO
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.42 2007/06/26 10:53:01 tom Exp $	*/
d177 1
a177 1
		 M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL) {
d398 1
a398 1
	    M_TEMP, M_NOWAIT|M_ZERO)) == NULL)
d1499 1
a1499 1
		    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL) {
@


1.42
log
@Implement bit swap for a byte in O(log(N)) rather than O(N), prompted
by an interview question I was asked.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.41 2007/05/09 16:41:14 reyk Exp $	*/
d177 1
a177 1
		 M_DEVBUF, M_NOWAIT)) == NULL) {
a182 2
	bzero(hal, sizeof(struct ath_hal));

d398 1
a398 1
	    M_TEMP, M_NOWAIT)) == NULL)
d1499 1
a1499 1
		    M_DEVBUF, M_NOWAIT)) == NULL) {
@


1.41
log
@remove the internal wrapper functions for ieee80211_mhz2ieee and
ieee80211_ieee2mhz which also removes some dead code.

figured out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.40 2007/04/13 14:44:41 reyk Exp $	*/
d629 13
a641 1
	u_int32_t retval = 0, bit, i;
d643 1
a643 3
	for (i = 0; i < bits; i++) {
		bit = (val >> i) & 1;
		retval = (retval << 1) | bit;
a644 2

	return (retval);
@


1.40
log
@The integrated Atheros NICs found in IBM/Lenovo ThinkPads use the same
device ID for old AR5212-based 32bit and new AR5424-based 64bit (PCI
Express Mini Card) interfaces.  Use an extra check to look if the card
is 64bit and attach it as a single chip device.  This prevents a panic
when attaching the device on some laptops like the T60.

Tested on a T42 (old AR5212 Mini PCI interface),
Tested on a T60 (new AR5424 Mini Card interface)

Nevertheless, the AR5424 does not work yet.

Thanks to Stefan Konrath
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.39 2007/03/12 01:04:52 reyk Exp $	*/
a371 12
u_int
ath_hal_mhz2ieee(u_int mhz, u_int flags)
{
	return (ieee80211_mhz2ieee(mhz, flags));
}

u_int
ath_hal_ieee2mhz(u_int ieee, u_int flags)
{
	return (ieee80211_ieee2mhz(ieee, flags));
}

d1215 1
a1215 1
	ath_channel = ieee_channel = ath_hal_mhz2ieee(channel->c_channel,
@


1.39
log
@add some HAL functions (again) inspired by the changes from the
madwifi-old-openhal project. this was backed out the last time because
it was too close to the release and i didn't respect the ABI/API lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.37 2007/03/05 15:13:26 reyk Exp $	*/
a24 1

d150 2
a151 2
ath_hal_attach(u_int16_t device, void *sc, bus_space_tag_t st,
    bus_space_handle_t sh, int *status)
d153 1
d215 16
@


1.38
log
@back out, reyk is not paying attention
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.36 2006/11/06 08:48:49 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
@


1.37
log
@Add some HAL functions.

From madwifi-old-openhal via Nick Kossifidis (mickflemm at gmail dot com)

Bump copyright while I'm here.
@
text
@d4 1
a4 1
 * Copyright (c) 2004, 2005, 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
@


1.36
log
@figured out by tdeval@@:
>During factorization in 1.57, the switch block was moved too early.
>Hence it's updating an uninitialized ah structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.35 2006/09/19 17:08:01 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
@


1.35
log
@detect the newer single chip generations AR2413, AR5413 and AR5224 but
don't attach them, yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.34 2006/09/19 13:14:32 reyk Exp $	*/
d206 17
@


1.34
log
@disable 11g mode for now
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.33 2006/06/05 15:21:43 reyk Exp $	*/
d64 6
d512 8
@


1.33
log
@start to sync some changes and fixes from various "openhal" ports of
this driver. thanks for contribution (even if i didn't get much
feedback from these projects...).

tested by many during c2k6, like aanriot@@ and ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.32 2005/12/18 17:59:58 reyk Exp $	*/
d469 2
a470 1
		if (ar5k_2ghz_channels[i].rc_mode & IEEE80211_CHAN_CCK)
d473 2
a474 1
		if (ar5k_2ghz_channels[i].rc_mode & IEEE80211_CHAN_OFDM) {
@


1.32
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.31 2005/09/23 20:06:50 reyk Exp $	*/
d111 1
d837 15
d1445 4
a1448 1
		hal->ah_rf_banks_size = sizeof(ar5112_rf);
d1569 1
a1569 1
	const u_int rf_size = AR5K_ELEMENTS(ar5112_rf);
d1573 1
d1579 8
d1589 1
a1589 1
		if (ar5112_rf[i].rf_bank >=
d1595 2
a1596 2
		if (bank != ar5112_rf[i].rf_bank) {
			bank = ar5112_rf[i].rf_bank;
d1600 1
a1600 1
		rf[i] = ar5112_rf[i].rf_value[mode];
d1693 1
a1693 1
	int i;
d1712 11
a1722 2
	for (i = 0; i < AR5K_ELEMENTS(hal->ah_txpower.txp_pcdac); i++)
		hal->ah_txpower.txp_pcdac[i] = AR5K_EEPROM_PCDAC_START;
@


1.31
log
@cleanup and simplify the regulation domain handling. some devices are
known to have a broken/unsupported regulation domain stored in their
EEPROM, we use the default instead (Canada). there's no need to
manually define COUNTRYCODE in ar5xxx.c anymore for invalid EEPROMs
but it's still possible to force a specific country - your choice.

ok aanriot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.30 2005/09/19 10:27:08 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.30
log
@don't attach unsupported radio chipsets

based on a diff by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.29 2005/09/10 14:36:46 jsg Exp $	*/
a146 2
	ieee80211_regdomain_t ieee_regdomain;
	u_int16_t regdomain;
a187 2
	hal->ah_country_code = CTRY_DEFAULT;
	hal->ah_capabilities.cap_regdomain.reg_current = AR5K_TUNE_REGDOMAIN;
a215 15
	/* Set regulation domain */
	if ((regdomain =
		hal->ah_capabilities.cap_eeprom.ee_regdomain) != 0) {
		hal->ah_capabilities.cap_regdomain.reg_current =
		    ieee_regdomain = ar5k_regdomain_to_ieee(regdomain);
	} else {
		ieee_regdomain =
		    hal->ah_capabilities.cap_regdomain.reg_current;

		/* Try to write default regulation domain to EEPROM */
		ar5k_eeprom_regulation_domain(hal, AH_TRUE, &ieee_regdomain);
	}

	hal->ah_capabilities.cap_regdomain.reg_hw = ieee_regdomain;

d363 2
a364 2
    u_int max_channels, u_int *channels_size, HAL_CTRY_CODE country,
    u_int16_t mode, HAL_BOOL outdoor, HAL_BOOL extended)
d376 1
a376 1
	domain_current = hal->ah_get_regdomain(hal);
d541 6
a546 1
	if (regdomain & 0xf0000000)
d549 2
a550 1
	return (regdomain & 0xff);
d556 1
a556 1
	ieee80211_regdomain_t ieee = (ieee80211_regdomain_t)regdomain & 0xff;
a563 5
#ifndef COUNTRYCODE
	/*
	 * Use the regulation domain found in the EEPROM, if not
	 * forced by a static country code.
	 */
d566 3
d570 2
a571 5
	if (ar5k_eeprom_regulation_domain(hal,
	    AH_FALSE, &ieee_regdomain) == AH_TRUE) {
		if ((regdomain = ar5k_regdomain_from_ieee(ieee_regdomain)))
			return (regdomain);
	}
d573 1
a573 2
	return (hal->ah_regdomain);
#else
a577 2
	u_int16_t code;

d579 1
a579 1
	return (ieee80211_countrycode2regdomain(code));
d581 5
d1024 2
d1028 2
a1029 1
		*regdomain = hal->ah_capabilities.cap_regdomain.reg_current;
d1033 2
a1035 2
	hal->ah_capabilities.cap_regdomain.reg_current = *regdomain;

a1038 1

d1040 1
a1040 1
	    hal->ah_capabilities.cap_eeprom.ee_regdomain) != 0)
d1043 1
a1043 2
	hal->ah_capabilities.cap_eeprom.ee_regdomain =
	    ar5k_regdomain_from_ieee(*regdomain);
@


1.29
log
@ansi, no binary change.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.28 2005/08/17 12:22:49 reyk Exp $	*/
d525 1
a525 1
		if (val < names[i + 1].sr_val) {
@


1.28
log
@fix compiling with AR5K_DEBUG. thanks to Bernd Ahlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.27 2005/08/02 12:55:11 reyk Exp $	*/
d124 1
a124 3
ath_hal_probe(vendor, device)
	u_int16_t vendor;
	u_int16_t device;
d144 2
a145 6
ath_hal_attach(device, sc, st, sh, status)
	u_int16_t device;
	void *sc;
	bus_space_tag_t st;
	bus_space_handle_t sh;
	int *status;
d290 2
a291 6
ath_hal_computetxtime(hal, rates, frame_length, rate_index, short_preamble)
	struct ath_hal *hal;
	const HAL_RATE_TABLE *rates;
	u_int32_t frame_length;
	u_int16_t rate_index;
	HAL_BOOL short_preamble;
d352 1
a352 3
ath_hal_mhz2ieee(mhz, flags)
	u_int mhz;
	u_int flags;
d358 1
a358 3
ath_hal_ieee2mhz(ieee, flags)
	u_int ieee;
	u_int flags;
d364 1
a364 4
ar5k_check_channel(hal, freq, flags)
	struct ath_hal *hal;
	u_int16_t freq;
	u_int flags;
d381 3
a383 10
ath_hal_init_channels(hal, channels, max_channels, channels_size, country, mode,
    outdoor, extended)
	struct ath_hal *hal;
	HAL_CHANNEL *channels;
	u_int max_channels;
	u_int *channels_size;
	HAL_CTRY_CODE country;
	u_int16_t mode;
	HAL_BOOL outdoor;
	HAL_BOOL extended;
d515 1
a515 3
ar5k_printver(type, val)
	enum ar5k_srev_type type;
	u_int32_t val;
d535 1
a535 2
ar5k_radar_alert(hal)
	struct ath_hal *hal;
d556 1
a556 2
ar5k_regdomain_from_ieee(ieee)
	ieee80211_regdomain_t ieee;
d567 1
a567 2
ar5k_regdomain_to_ieee(regdomain)
	u_int16_t regdomain;
d575 1
a575 2
ar5k_get_regdomain(hal)
	struct ath_hal *hal;
d605 1
a605 3
ar5k_bitswap(val, bits)
	u_int32_t val;
	u_int bits;
d618 1
a618 3
ar5k_htoclock(usec, turbo)
	u_int usec;
	HAL_BOOL turbo;
d624 1
a624 3
ar5k_clocktoh(clock, turbo)
	u_int clock;
	HAL_BOOL turbo;
d630 1
a630 3
ar5k_rt_copy(dst, src)
	HAL_RATE_TABLE *dst;
	const HAL_RATE_TABLE *src;
d638 2
a639 6
ar5k_register_timeout(hal, reg, flag, val, is_set)
	struct ath_hal *hal;
	u_int32_t reg;
	u_int32_t flag;
	u_int32_t val;
	HAL_BOOL is_set;
d664 1
a664 4
ar5k_eeprom_bin2freq(hal, bin, mode)
	struct ath_hal *hal;
	u_int16_t bin;
	u_int mode;
d689 1
a689 4
ar5k_eeprom_read_ants(hal, offset, mode)
	struct ath_hal *hal;
	u_int32_t *offset;
	u_int mode;
d745 1
a745 4
ar5k_eeprom_read_modes(hal, offset, mode)
	struct ath_hal *hal;
	u_int32_t *offset;
	u_int mode;
d826 1
a826 2
ar5k_eeprom_init(hal)
	struct ath_hal *hal;
d1004 1
a1004 3
ar5k_eeprom_read_mac(hal, mac)
	struct ath_hal *hal;
	u_int8_t *mac;
d1037 2
a1038 4
ar5k_eeprom_regulation_domain(hal, write, regdomain)
	struct ath_hal *hal;
	HAL_BOOL write;
	ieee80211_regdomain_t *regdomain;
d1068 1
a1068 3
ar5k_channel(hal, channel)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
d1107 1
a1107 2
ar5k_ar5110_chan2athchan(channel)
	HAL_CHANNEL *channel;
d1125 1
a1125 3
ar5k_ar5110_channel(hal, channel)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
d1141 1
a1141 3
ar5k_ar5111_chan2athchan(ieee, athchan)
	u_int ieee;
	struct ar5k_athchan_2ghz *athchan;
d1167 1
a1167 3
ar5k_ar5111_channel(hal, channel)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
d1208 1
a1208 3
ar5k_ar5112_channel(hal, channel)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
d1253 2
a1254 4
ar5k_rfregs_op(rf, offset, reg, bits, first, col, set)
	u_int32_t *rf;
	u_int32_t offset, reg, bits, first, col;
	HAL_BOOL set;
d1300 1
a1300 2
ar5k_rfregs_gainf_corr(hal)
	struct ath_hal *hal;
d1336 1
a1336 2
ar5k_rfregs_gain_readback(hal)
	struct ath_hal *hal;
d1378 1
a1378 2
ar5k_rfregs_gain_adjust(hal)
	struct ath_hal *hal;
d1435 1
a1435 4
ar5k_rfregs(hal, channel, mode)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
	u_int mode;
d1467 1
a1467 4
ar5k_ar5111_rfregs(hal, channel, mode)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
	u_int mode;
d1562 1
a1562 4
ar5k_ar5112_rfregs(hal, channel, mode)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
	u_int mode;
d1644 1
a1644 3
ar5k_rfgain(hal, phy, freq)
	struct ath_hal *hal;
	u_int phy, freq;
d1677 1
a1677 4
ar5k_txpower_table(hal, channel, max_power)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
	int16_t max_power;
@


1.27
log
@reduce stack usage

spotted out by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.26 2005/06/17 12:51:08 reyk Exp $	*/
d1497 1
a1497 1
	    g,
@


1.26
log
@remove non-constant array initializers which is a GNU extension.
suggested by anil some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.25 2005/05/28 23:45:10 reyk Exp $	*/
d70 6
a153 5
	HAL_RATE_TABLE rt_11a = AR5K_RATES_11A;
	HAL_RATE_TABLE rt_11b = AR5K_RATES_11B;
	HAL_RATE_TABLE rt_11g = AR5K_RATES_11G;
	HAL_RATE_TABLE rt_turbo = AR5K_RATES_TURBO;
	HAL_RATE_TABLE rt_xr = AR5K_RATES_XR;
d259 1
a259 1
		ar5k_rt_copy(&hal->ah_rt_11a, &rt_11a);
d261 1
a261 1
		ar5k_rt_copy(&hal->ah_rt_11b, &rt_11b);
d263 1
a263 1
		ar5k_rt_copy(&hal->ah_rt_11g, &rt_11g);
d265 1
a265 1
		ar5k_rt_copy(&hal->ah_rt_turbo, &rt_turbo);
d267 1
a267 1
		ar5k_rt_copy(&hal->ah_rt_xr, &rt_xr);
d668 1
a668 1
	HAL_RATE_TABLE *src;
@


1.25
log
@fix hostap mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.24 2005/05/27 04:10:06 reyk Exp $	*/
d411 5
a415 1
	HAL_CHANNEL all_channels[max_channels];
d527 1
a527 1
	bcopy(all_channels, channels, sizeof(all_channels));
d529 1
a529 1

@


1.24
log
@- disable the gpio user interface for now, it's just an unimportant
button which is not yet available on non-i386 platforms
- fix endianess and attachement on big endian platforms (tested on
macppc - ath attaches correctly, receives frames but assoc still
fails)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.23 2005/05/16 04:54:31 reyk Exp $	*/
d611 1
a611 1
		AH_FALSE, &ieee_regdomain) == AH_TRUE) {
@


1.23
log
@remove an extra delay in rf register init
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.22 2005/05/08 18:13:17 reyk Exp $	*/
d248 1
a248 1
	if ((*status = ar5k_eeprom_read_mac(hal, mac)) != HAL_OK) {
a880 4
	/* Check if EEPROM is busy */
	if (hal->ah_eeprom_is_busy(hal) == AH_TRUE)
		return (EBUSY);

a1061 3

	if (hal->ah_eeprom_is_busy(hal))
		return (EBUSY);
@


1.22
log
@change the dmesg output: print known chipset names, don't print the
supported 802.11a/b/g modes (this could be discovered with ifconfig -m
athX). inspired by Johan M:son Lindman and others asking about the
several different ARxxxx chipset combos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.21 2005/04/18 18:42:55 reyk Exp $	*/
d1720 1
a1720 1
	for (i = 0; i < rf_size; i++) {
a1721 2
		AR5K_DELAY(1);
	}
@


1.21
log
@beautify the code by renaming HAL functions with capitalized words (i
always wanted to do that). this breaks HAL compatibility but porting
should be easy, have a look at athvar.h. no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.20 2005/03/20 04:21:55 reyk Exp $	*/
d532 22
@


1.20
log
@some fixes for wep and reset.

btw.: this is a commit using an ar5212 in 11b mode...

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.19 2005/03/19 17:27:46 reyk Exp $	*/
d213 1
a213 1
	hal->ah_dumpState(hal);
d254 1
a254 1
	hal->ah_setMacAddress(hal, mac);
d414 1
a414 1
	domain_current = hal->ah_getRegDomain(hal);
d1498 1
a1498 1
	} else if (hal->ah_radio == AR5K_AR5112) {		
d1506 2
a1507 2
		if ((hal->ah_rf_banks =
		    malloc(hal->ah_rf_banks_size, M_DEVBUF, M_NOWAIT)) == NULL) {
d1749 1
a1749 1
	
@


1.19
log
@further fixes for ar5212.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.18 2005/03/18 20:46:32 reyk Exp $	*/
d462 1
a462 2
		 (i < (sizeof(ar5k_5ghz_channels) /
		     sizeof(ar5k_5ghz_channels[0]))) &&
d481 2
a482 1
		}
d492 1
a492 2
		 (i < (sizeof(ar5k_2ghz_channels) /
		     sizeof(ar5k_2ghz_channels[0]))) &&
@


1.18
log
@improve ar5212 init on reset
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.17 2005/03/10 08:30:56 reyk Exp $	*/
d83 1
a83 1
int		 ar5k_rfregs_op(u_int32_t *, u_int32_t, u_int32_t, u_int32_t,
d209 1
a209 1
	if (attach(device, hal, st, sh, status) == NULL)
d1300 1
a1300 1
int
d1310 5
d1354 4
d1359 1
d1362 1
a1362 1
	if (ar5k_rfregs_op(NULL, hal->ah_offset[7], 0, 1, 36, 0, AH_FALSE) != 1)
d1365 1
a1365 1
	step = ar5k_rfregs_op(NULL, hal->ah_offset[7], 0, 4, 32, 0, AH_FALSE);
d1391 6
d1399 1
a1399 1
		step = ar5k_rfregs_op(NULL, hal->ah_offset[7],
d1411 1
a1411 1
		mix = ar5k_rfregs_op(NULL, hal->ah_offset[7],
d1493 1
d1496 7
a1502 1
	if (hal->ah_radio < AR5K_AR5111)
d1505 10
a1514 4
	if (hal->ah_radio == AR5K_AR5111)
		ret = ar5k_ar5111_rfregs(hal, channel, mode);
	else
		ret = ar5k_ar5112_rfregs(hal, channel, mode);
d1530 1
a1530 1
	u_int32_t rf[rf_size];
d1536 2
d1613 1
a1614 1
		AR5K_DELAY(1);
d1628 1
a1628 1
	u_int32_t rf[rf_size];
d1634 2
d1731 1
d1737 33
@


1.17
log
@fix beacon handling
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.16 2005/03/03 16:39:54 reyk Exp $	*/
a31 6
static const struct
ieee80211_regchannel ar5k_5ghz_channels[] = IEEE80211_CHANNELS_5GHZ;

static const struct
ieee80211_regchannel ar5k_2ghz_channels[] = IEEE80211_CHANNELS_2GHZ;

d83 16
a98 2
int		 ar5k_rfregs_set(u_int32_t *, u_int32_t, u_int32_t, u_int32_t,
    u_int32_t, u_int32_t);
d103 3
a105 6
static const struct ar5k_ini_rf ar5111_rf[] =
    AR5K_AR5111_INI_RF;
static const struct ar5k_ini_rf ar5112_rf[] =
    AR5K_AR5112_INI_RF;
static const struct ar5k_ini_rfgain ar5k_rfg[] =
    AR5K_INI_RFGAIN;
d152 1
d265 19
d1301 1
a1301 1
ar5k_rfregs_set(rf, offset, reg, bits, first, col)
d1304 1
d1306 2
a1307 2
	u_int32_t tmp, mask, entry, last;
	int32_t position, left;
d1312 1
a1312 1
		return (-1);
a1314 1
	tmp = ar5k_bitswap(reg, bits);
d1318 4
a1321 1
	for (i = 0, left = bits; left > 0; position = 0, entry++, i++) {
d1325 11
a1335 2
		rf[entry] &= ~mask;
		rf[entry] |= ((tmp << position) << (col * 8)) & mask;
a1336 1
		tmp >>= (8 - position);
d1339 130
a1468 1
	return (i);
d1477 2
a1480 2
	else if (hal->ah_radio < AR5K_AR5112)
		return (ar5k_ar5111_rfregs(hal, channel, mode));
d1482 9
a1490 1
	return (ar5k_ar5112_rfregs(hal, channel, mode));
d1503 1
a1503 1
	u_int32_t ee_mode, offset[AR5K_AR5111_INI_RF_MAX_BANKS];
d1517 1
a1517 1
			offset[bank] = i;
d1530 2
a1531 2
		if (ar5k_rfregs_set(rf, offset[0],
			ee->ee_ob[ee_mode][obdb], 3, 119, 0) < 0)
d1534 2
a1535 2
		if (ar5k_rfregs_set(rf, offset[0],
			ee->ee_ob[ee_mode][obdb], 3, 122, 0) < 0)
d1547 2
a1548 2
		if (ar5k_rfregs_set(rf, offset[6],
			ee->ee_pwd_84, 1, 51, 3) < 0)
d1551 2
a1552 2
		if (ar5k_rfregs_set(rf, offset[6],
			ee->ee_pwd_90, 1, 45, 3) < 0)
d1556 2
a1557 2
	if (ar5k_rfregs_set(rf, offset[6],
		!ee->ee_xpd[ee_mode], 1, 95, 0) < 0)
d1560 2
a1561 2
	if (ar5k_rfregs_set(rf, offset[6],
		ee->ee_x_gain[ee_mode], 4, 96, 0) < 0)
d1564 2
a1565 2
	if (ar5k_rfregs_set(rf, offset[6],
		obdb >= 0 ? ee->ee_ob[ee_mode][obdb] : 0, 3, 104, 0) < 0)
d1568 2
a1569 2
	if (ar5k_rfregs_set(rf, offset[6],
		obdb >= 0 ? ee->ee_db[ee_mode][obdb] : 0, 3, 107, 0) < 0)
d1572 2
a1573 2
	if (ar5k_rfregs_set(rf, offset[7],
		ee->ee_i_gain[ee_mode], 6, 29, 0) < 0)
d1576 2
a1577 2
	if (ar5k_rfregs_set(rf, offset[7],
		ee->ee_xpd[ee_mode], 1, 4, 0) < 0)
d1599 1
a1599 1
	u_int32_t ee_mode, offset[AR5K_AR5112_INI_RF_MAX_BANKS];
d1613 1
a1613 1
			offset[bank] = i;
d1626 2
a1627 2
		if (ar5k_rfregs_set(rf, offset[6],
			ee->ee_ob[ee_mode][obdb], 3, 287, 0) < 0)
d1630 2
a1631 2
		if (ar5k_rfregs_set(rf, offset[6],
			ee->ee_ob[ee_mode][obdb], 3, 290, 0) < 0)
d1641 2
a1642 2
		if (ar5k_rfregs_set(rf, offset[6],
			ee->ee_ob[ee_mode][obdb], 3, 279, 0) < 0)
d1645 2
a1646 2
		if (ar5k_rfregs_set(rf, offset[6],
			ee->ee_ob[ee_mode][obdb], 3, 282, 0) < 0)
d1651 4
a1654 2
	ar5k_rfregs_set(rf, offset[6], ee->ee_x_gain[ee_mode], 2, 270, 0);
	ar5k_rfregs_set(rf, offset[6], ee->ee_x_gain[ee_mode], 2, 257, 0);
d1657 2
a1658 2
	if (ar5k_rfregs_set(rf, offset[6],
		ee->ee_xpd[ee_mode], 1, 302, 0) < 0)
d1661 2
a1662 2
	if (ar5k_rfregs_set(rf, offset[7],
		ee->ee_i_gain[ee_mode], 6, 14, 0) < 0)
@


1.16
log
@improve radiotap support, fix some minor bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.15 2005/02/25 22:25:30 reyk Exp $	*/
d206 4
d499 1
a499 1
	memcpy(channels, &all_channels, sizeof(all_channels));
d619 1
a619 1
	memset(dst, 0, sizeof(HAL_RATE_TABLE));
d621 1
a621 1
	memcpy(&dst->info, &src->info, sizeof(dst->info));
d1038 1
a1038 1
	memcpy(mac, &mac_d, IEEE80211_ADDR_LEN);
a1084 1
	AR5K_TRACE;
@


1.15
log
@add support for the atheros ar5211 802.11A/B/g wireless chipset.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.14 2005/02/23 14:26:54 reyk Exp $	*/
d1194 1
a1194 1
	data0 = 0;
d1233 1
@


1.14
log
@add all supported regulation domains. the forced COUNTRYCODE in ar5xxx
is now disabled by default to use the value found in EEPROM.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.13 2005/02/19 16:58:00 reyk Exp $	*/
a28 1
#ifdef notyet
a29 1
#endif
a51 1
#ifdef notyet
a61 1
#endif
d99 2
d1490 31
@


1.13
log
@add support for the atheros ar5212 wireless chipsets. it is not
finished yet and still misses some channel initialization and
calibration bits.

(if you want to hand in your dmesg output, please build a kernel with
an uncommented COUNTRYCODE in line 109 of dev/ic/ar5xxx.c to get the
value stored in your card's eeprom.)

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.12 2005/02/17 23:52:05 reyk Exp $	*/
a53 1

d89 1
d105 1
a105 2
 * XXX Overwrite the country code (use "00" for debug)
 * XXX as long as ieee80211_regdomain is not finished
d107 2
a108 2
#ifndef COUNTRYCODE
#define COUNTRYCODE "us"
d350 20
d386 1
a386 1
	c = 0;
d388 37
d439 3
a441 4
		if ((ar5k_5ghz_channels[i].rc_channel <
			hal->ah_capabilities.cap_range.range_5ghz_min) ||
		    (ar5k_5ghz_channels[i].rc_channel >
			hal->ah_capabilities.cap_range.range_5ghz_max))
d445 1
a445 1
		if ((IEEE80211_DMN(ar5k_5ghz_channels[i].rc_domains) &
d450 6
a455 6
		if (ar5k_5ghz_channels[i].rc_mode & IEEE80211_CHAN_TURBO)
			all_channels[c].channelFlags = CHANNEL_T;
		else if (ar5k_5ghz_channels[i].rc_mode & IEEE80211_CHAN_OFDM)
			all_channels[c].channelFlags = CHANNEL_A;
		else
			continue;
d469 3
a471 4
		if ((ar5k_2ghz_channels[i].rc_channel <
			hal->ah_capabilities.cap_range.range_2ghz_min) ||
		    (ar5k_2ghz_channels[i].rc_channel >
			hal->ah_capabilities.cap_range.range_2ghz_max))
d475 1
a475 1
		if ((IEEE80211_DMN(ar5k_2ghz_channels[i].rc_domains) &
d481 10
a490 7
			all_channels[c].channelFlags = CHANNEL_B;
		else if (ar5k_2ghz_channels[i].rc_mode & IEEE80211_CHAN_TURBO)
			all_channels[c].channelFlags = CHANNEL_TG;
		else if (ar5k_2ghz_channels[i].rc_mode & IEEE80211_CHAN_OFDM)
			all_channels[c].channelFlags = CHANNEL_G;
		else
			continue;
d496 1
d521 2
a522 2
	hal->ah_radar.r_last_channel.channelFlags =
	    hal->ah_current_channel.channelFlags;
@


1.12
log
@a new year and a new, less restrictive license. because it has to be
free.

go ahead miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.11 2005/02/17 23:21:49 reyk Exp $	*/
d31 1
a32 1
#endif
d66 1
d78 1
a78 3
	    ar5k_ar5212_attach },
#endif

d103 8
@


1.11
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.10 2005/02/17 22:32:48 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004 Reyk Floeter <reyk@@vantronix.net>.
d6 3
a8 1
 * All rights reserved.
d10 7
a16 18
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY
 * SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
 * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.10
log
@cosmetic changes, fix regdomain code and beacon handling
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.9 2005/02/03 03:21:37 kevlo Exp $	*/
d58 1
a58 1
	  ar5k_ar5210_attach },
d60 1
a60 1
	  ar5k_ar5210_attach },
d62 1
a62 1
	  ar5k_ar5210_attach },
d66 1
a66 1
	  ar5k_ar5211_attach },
d68 1
a68 1
	  ar5k_ar5211_attach },
d70 1
a70 1
	  ar5k_ar5211_attach },
d72 1
a72 1
	  ar5k_ar5211_attach },
d74 1
a74 1
	  ar5k_ar5211_attach },
d76 1
a76 1
	  ar5k_ar5212_attach },
d78 1
a78 1
	  ar5k_ar5212_attach },
d80 1
a80 1
	  ar5k_ar5212_attach },
d82 1
a82 1
	  ar5k_ar5212_attach },
d84 1
a84 1
	  ar5k_ar5212_attach },
d86 1
a86 1
	  ar5k_ar5212_attach },
d95 1
a95 1
HAL_BOOL 	 ar5k_ar5110_channel(struct ath_hal *, HAL_CHANNEL *);
d97 1
a97 1
HAL_BOOL 	 ar5k_ar5111_channel(struct ath_hal *, HAL_CHANNEL *);
d99 1
a99 1
HAL_BOOL 	 ar5k_ar5112_channel(struct ath_hal *, HAL_CHANNEL *);
d175 1
a175 1
        if ((hal = malloc(sizeof(struct ath_hal),
d215 4
a218 4
 	if (ar5k_eeprom_init(hal) != 0) {
 		AR5K_PRINT("unable to init EEPROM\n");
 		goto failed;
 	}
d230 1
a230 1
 		ar5k_eeprom_regulation_domain(hal, AH_TRUE, &ieee_regdomain);
d482 1
a482 1
        return (regdomain & 0xff);
d519 1
a519 1
	
d591 1
a591 1
	
d606 1
a606 1
	
d743 1
a743 1
		
d758 1
a758 1
	    mode == AR5K_EEPROM_MODE_11G) 
d799 2
a800 1
	AR5K_EEPROM_READ_HDR(AR5K_EEPROM_ANT_GAIN(hal->ah_ee_version), ee_ant_gain);
d1008 1
a1008 1
		hal->ah_capabilities.cap_eeprom.ee_regdomain) != 0) 
d1076 2
a1077 2
				     channel->c_channel_flags) - 24)
		       / 2, 5) << 1) | (1 << 6) | 0x1;
d1136 1
a1136 1
	
d1153 1
a1153 1
	} 
d1178 1
a1178 1
	
d1193 1
a1193 1
		
d1302 1
a1302 1
		
d1323 1
a1323 1
	}	
d1398 1
a1398 1
		
d1417 1
a1417 1
	}	
@


1.9
log
@make prototype match function for ar5k_ar5110_chan2athchan
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.8 2005/01/09 18:18:15 reyk Exp $	*/
a199 1
	hal->ah_txpower.txp_max = AR5K_TUNE_MAX_TXPOWER;
d230 1
a230 1
 		ar5k_eeprom_regulation_domain(hal, AH_TRUE, ieee_regdomain);
d480 1
a480 1
		return ((u_int16_t)DMN_DEFAULT);
d494 31
a623 12
#define EEPROM_READ_VAL(_o, _v)	{					\
	if ((ret = hal->ah_eeprom_read(hal, (_o),			\
		 &(_v))) != 0)						\
		return (ret);						\
}			

#define EEPROM_READ_HDR(_o, _v)	{					\
	if ((ret = hal->ah_eeprom_read(hal, (_o),			\
		 &hal->ah_capabilities.cap_eeprom._v)) != 0)		\
		return (ret);						\
}

d635 1
a635 1
	EEPROM_READ_VAL(o++, val);
d640 1
a640 1
	EEPROM_READ_VAL(o++, val);
d645 1
a645 1
	EEPROM_READ_VAL(o++, val);
d650 1
a650 1
	EEPROM_READ_VAL(o++, val);
d656 1
a656 1
	EEPROM_READ_VAL(o++, val);
d694 1
a694 1
	EEPROM_READ_VAL(o++, val);
d702 1
a702 1
	EEPROM_READ_VAL(o++, val);
d706 1
a706 1
	EEPROM_READ_VAL(o++, val);
d718 1
a718 1
	EEPROM_READ_VAL(o++, val);
d727 1
a727 1
		EEPROM_READ_VAL(o++, val);
d744 1
a744 1
		EEPROM_READ_VAL(o++, val);
d789 5
a793 5
	EEPROM_READ_HDR(AR5K_EEPROM_MAGIC, ee_magic);
	EEPROM_READ_HDR(AR5K_EEPROM_PROTECT, ee_protect);
	EEPROM_READ_HDR(AR5K_EEPROM_REG_DOMAIN, ee_regdomain);
	EEPROM_READ_HDR(AR5K_EEPROM_VERSION, ee_version);
	EEPROM_READ_HDR(AR5K_EEPROM_HDR, ee_header);
d799 1
a799 1
	EEPROM_READ_HDR(AR5K_EEPROM_ANT_GAIN(hal->ah_ee_version), ee_ant_gain);
d802 2
a803 2
		EEPROM_READ_HDR(AR5K_EEPROM_MISC0, ee_misc0);
		EEPROM_READ_HDR(AR5K_EEPROM_MISC1, ee_misc1);
d807 1
a807 1
		EEPROM_READ_VAL(AR5K_EEPROM_OBDB0_2GHZ, val);
d811 1
a811 1
		EEPROM_READ_VAL(AR5K_EEPROM_OBDB1_2GHZ, val);
d823 1
a823 1
		EEPROM_READ_VAL(offset++, val);
d841 1
a841 1
	EEPROM_READ_VAL(offset++, val);
d847 1
a847 1
	EEPROM_READ_VAL(offset++, val);
d859 1
a859 1
		EEPROM_READ_VAL(offset++, val);
d872 1
a872 1
	EEPROM_READ_VAL(offset++, val);
d881 1
a881 1
		EEPROM_READ_VAL(offset++, val);
d887 1
a887 1
		EEPROM_READ_VAL(offset++, val);
d905 1
a905 1
	EEPROM_READ_VAL(offset++, val);
d914 1
a914 1
		EEPROM_READ_VAL(offset++, val);
d920 1
a920 1
		EEPROM_READ_VAL(offset++, val);
d924 1
a924 1
		EEPROM_READ_VAL(offset++, val);
d932 1
a932 1
		EEPROM_READ_VAL(offset++, val);
d937 1
a937 1
			EEPROM_READ_VAL(offset++, val);
a948 3
#undef EEPROM_READ_VAL
#undef EEPROM_READ_HDR

d991 1
a991 1
	ieee80211_regdomain_t regdomain;
d995 1
a995 1
		regdomain = hal->ah_capabilities.cap_regdomain.reg_current;
d1000 1
a1000 1
	hal->ah_capabilities.cap_regdomain.reg_current = regdomain;
a1005 3
	hal->ah_capabilities.cap_eeprom.ee_regdomain =
	    ar5k_regdomain_from_ieee(regdomain);

d1010 3
d1044 1
a1044 1
	if (hal->ah_radio == AR5K_AR5110) {
d1046 1
a1046 1
	} else if (hal->ah_radio == AR5K_AR5111) {
d1048 1
a1048 1
	} else {
a1049 1
	}
a1135 2
	AR5K_TRACE;

a1177 2
	AR5K_TRACE;

@


1.8
log
@fix regulation domain handling
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.7 2004/12/31 03:39:01 espie Exp $	*/
d96 1
a96 1
HAL_BOOL	 ar5k_ar5110_chan2athchan(HAL_CHANNEL *);
@


1.7
log
@people who don't understand the preprocessor should stay away from the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.6 2004/12/31 01:00:23 reyk Exp $	*/
d223 3
a225 4
	    (u_int16_t)hal->ah_capabilities.cap_eeprom.ee_regdomain) != 0) {
		ieee_regdomain = *ar5k_regdomain_to_ieee(regdomain);
		memcpy(&hal->ah_capabilities.cap_regdomain.reg_current,
		    &ieee_regdomain, sizeof(ieee80211_regdomain_t));
d231 1
a231 1
 		ar5k_eeprom_regulation_domain(hal, AH_TRUE, &ieee_regdomain);
d234 1
a234 2
	memcpy(&hal->ah_capabilities.cap_regdomain.reg_hw,
	    &ieee_regdomain, sizeof(ieee80211_regdomain_t));
d475 2
a476 2
ar5k_regdomain_from_ieee(regdomain)
	ieee80211_regdomain_t *regdomain;
d478 6
a483 4
	/*
	 * XXX Fix
	 */
	return ((u_int16_t)*regdomain);
d486 1
a486 1
ieee80211_regdomain_t *
d490 3
a492 4
	/*
	 * XXX Fix
	 */
	return ((ieee80211_regdomain_t*)&regdomain);
d976 1
a976 1
	ieee80211_regdomain_t *regdomain;
d980 1
a980 3
		memcpy(regdomain,
		    &hal->ah_capabilities.cap_regdomain.reg_current,
		    sizeof(ieee80211_regdomain_t));
d985 1
a985 2
	memcpy(&hal->ah_capabilities.cap_regdomain.reg_current, regdomain,
	    sizeof(ieee80211_regdomain_t));
@


1.6
log
@sync with the latest work and add some stuff needed by the upcoming ar5211/ar5212
support. some further cleanups and changes will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.5 2004/11/11 20:11:28 reyk Exp $	*/
d603 1
a603 1
		 &hal->ah_capabilities.cap_eeprom.##_v)) != 0)		\
@


1.5
log
@some fixes for beeing compatible with gcc3 as noticed by some people.
thanks to Joerg Sonnenberger and Nathan Binkert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.4 2004/11/06 03:05:20 reyk Exp $	*/
d30 1
a30 1
 * (Please have a look at ar5k.h for further information)
a37 1

d63 1
d88 1
d91 23
d147 1
d152 1
d195 1
a197 1
	hal->ah_capabilities.cap_eeprom.ee_regdomain = DMN_DEFAULT;
d199 2
d207 1
d216 23
d245 1
d254 1
d476 1
a476 42
int
ar5k_eeprom_read_mac(hal, mac)
	struct ath_hal *hal;
	u_int8_t *mac;
{
	u_int32_t total, offset;
	u_int16_t data;
	int octet;
	u_int8_t mac_d[IEEE80211_ADDR_LEN];

	bzero(mac, IEEE80211_ADDR_LEN);
	bzero(&mac_d, IEEE80211_ADDR_LEN);

	if (hal->ah_eeprom_is_busy(hal))
		return (EBUSY);

	/*
	 * XXX Does this work with newer EEPROMs?
	 */
	if (hal->ah_eeprom_read(hal, 0x20, &data) != 0)
		return (EIO);

	for (offset = 0x1f, octet = 0, total = 0;
	     offset >= 0x1d; offset--) {
		if (hal->ah_eeprom_read(hal, offset, &data) != 0)
			return (EIO);

		total += data;
		mac_d[octet + 1] = data & 0xff;
		mac_d[octet] = data >> 8;
		octet += 2;
	}

	memcpy(mac, &mac_d, IEEE80211_ADDR_LEN);

	if ((!total) || total == (3 * 0xffff))
		return (EINVAL);

	return (0);
}

u_int8_t
d483 1
a483 1
	return ((u_int8_t)*regdomain);
d488 1
a488 1
	u_int8_t regdomain;
d546 1
d549 2
a550 1
		if ((is_set == AH_TRUE) && (AR5K_REG_READ(reg) & flag))
d552 1
a552 1
		else if ((AR5K_REG_READ(reg) & flag) == val)
d559 871
@


1.4
log
@sync pci ids
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.3 2004/11/03 16:40:46 reyk Exp $	*/
d128 1
a128 1
	ar5k_attach_t *attach;
d145 1
a145 1
		AR5K_PRINTF("device not supported\n");
d152 1
a152 1
		AR5K_PRINTF("out of memory\n");
d188 2
a189 1
		AR5K_PRINTF("unable to get device capabilities\n");
d194 2
a195 1
		AR5K_PRINTF("unable to read address from EEPROM\n");
d227 1
a227 1
	HAL_RATE *rate;
d235 1
a235 1
	rate = (HAL_RATE*)&rates->info[rate_index];
@


1.3
log
@knf, use positive error values (suggested by miod@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.2 2004/11/02 14:05:49 reyk Exp $	*/
a52 1
	const char *	name;
d59 1
a59 1
	  "AR5210 Wireless LAN", ar5k_ar5210_attach },
d61 1
a61 1
	  "AR5210 Wireless LAN (AP11)", ar5k_ar5210_attach },
d63 1
a63 1
	  "AR5210 Wireless LAN (no eeprom)", ar5k_ar5210_attach },
d66 1
a66 1
	  "AR5211 Wireless LAN", ar5k_ar5211_attach },
d68 1
a68 1
	  "AR5211 Wireless LAN (no eeprom)", ar5k_ar5211_attach },
d70 1
a70 1
	  "AR5211 Wireless LAN", ar5k_ar5211_attach },
d72 1
a72 1
	  "AR5211 Wireless LAN Reference Card", ar5k_ar5211_attach },
d74 1
a74 1
	  "AR5211 Wireless LAN Reference Card", ar5k_ar5211_attach },
d76 1
a76 1
	  "AR5212 Wireless LAN", ar5k_ar5212_attach },
d78 1
a78 1
	  "AR5212 Wireless LAN (no eeprom)", ar5k_ar5212_attach },
d80 7
a86 1
	  "AR5212 Wireless LAN Reference Card", ar5k_ar5212_attach },
d106 1
a106 1
			return (ar5k_known_products[i].name);
@


1.2
log
@spacing, beautify dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5xxx.c,v 1.1 2004/11/02 03:01:16 reyk Exp $	*/
a36 1
#ifdef AR5K_SUPPORT_AR5210
a37 1
#endif
a39 1
#ifdef AR5K_SUPPORT_AR5211
a40 2
#endif
#ifdef AR5K_SUPPORT_AR5212
a42 1
#endif
d51 2
a52 2
	u_int16_t 	vendor;
	u_int16_t 	device;
d54 1
a54 1
	ar5k_attach_t 	(*attach);
a58 1
#ifdef AR5K_SUPPORT_AR5210
a64 1
#endif
a65 1
#ifdef AR5K_SUPPORT_AR5211
a75 2
#endif
#ifdef AR5K_SUPPORT_AR5212
a82 1
#endif
d98 2
a99 2
	for(i = 0; i < AR5K_ELEMENTS(ar5k_known_products); i++) {
		if(vendor == ar5k_known_products[i].vendor &&
d101 1
a101 1
			return(ar5k_known_products[i].name);
d104 1
a104 1
	return(NULL);
d127 1
a127 1
	*status = -EINVAL;
d132 2
a133 2
	for(i = 0; i < AR5K_ELEMENTS(ar5k_known_products); i++) {
		if(device == ar5k_known_products[i].device &&
d138 2
a139 2
	if(attach == NULL) {
		*status = -ENXIO;
d141 1
a141 1
		return(NULL);
d144 3
a146 2
        if((hal = malloc(sizeof(struct ath_hal), M_DEVBUF, M_NOWAIT)) == NULL) {
		*status = -ENOMEM;
d148 1
a148 1
		return(NULL);
d175 1
a175 1
	if(attach(device, hal, st, sh, status) == NULL)
d182 1
a182 1
	if(hal->ah_get_capabilities(hal) != AH_TRUE) {
d187 1
a187 1
	if((*status = ar5k_eeprom_read_mac(hal, mac)) != HAL_OK) {
d194 1
a194 1
	if(hal->ah_capabilities.cap_mode & HAL_MODE_11A)
d196 1
a196 1
	if(hal->ah_capabilities.cap_mode & HAL_MODE_11B)
d198 1
a198 1
	if(hal->ah_capabilities.cap_mode & HAL_MODE_11G)
d200 1
a200 1
	if(hal->ah_capabilities.cap_mode & HAL_MODE_TURBO)
d205 1
a205 1
	return(hal);
d209 1
a209 1
	return(NULL);
d233 1
a233 1
	switch(rate->phy) {
d246 2
a247 2
		if(AR5K_OFDM_NUM_BITS_PER_SYM(rate->rateKbps) == 0)
			return(0);
d256 2
a257 2
		if(AR5K_TURBO_NUM_BITS_PER_SYM(rate->rateKbps) == 0)
			return(0);
d266 2
a267 2
		if(AR5K_XR_NUM_BITS_PER_SYM(rate->rateKbps) == 0)
			return(0);
d272 1
a272 1
		return(0);
d275 1
a275 1
	return(value);
d283 1
a283 1
	return(ieee80211_mhz2ieee(mhz, flags));
d291 1
a291 1
	return(ieee80211_ieee2mhz(ieee, flags));
d322 4
a325 4
	for(i = 0; (hal->ah_capabilities.cap_range.range_5ghz_max > 0) &&
		(i < (sizeof(ar5k_5ghz_channels) /
		sizeof(ar5k_5ghz_channels[0]))) &&
		(c < max_channels); i++) {
d327 2
a328 2
		if((ar5k_5ghz_channels[i].rc_channel <
		       hal->ah_capabilities.cap_range.range_5ghz_min) ||
d334 2
a335 2
		if((IEEE80211_DMN(ar5k_5ghz_channels[i].rc_domains) &
		       IEEE80211_DMN(domain_5ghz)) == 0)
d339 1
a339 1
		if(ar5k_5ghz_channels[i].rc_mode & IEEE80211_CHAN_TURBO)
d341 1
a341 1
		else if(ar5k_5ghz_channels[i].rc_mode & IEEE80211_CHAN_OFDM)
d354 3
a356 3
	    (i < (sizeof(ar5k_2ghz_channels) /
	    sizeof(ar5k_2ghz_channels[0]))) &&
	    (c < max_channels); i++) {
d358 2
a359 2
		if((ar5k_2ghz_channels[i].rc_channel <
		       hal->ah_capabilities.cap_range.range_2ghz_min) ||
d365 2
a366 2
		if((IEEE80211_DMN(ar5k_2ghz_channels[i].rc_domains) &
		       IEEE80211_DMN(domain_2ghz)) == 0)
d370 1
a370 1
		if(ar5k_2ghz_channels[i].rc_mode & IEEE80211_CHAN_CCK)
d372 1
a372 1
		else if(ar5k_2ghz_channels[i].rc_mode & IEEE80211_CHAN_TURBO)
d374 1
a374 1
		else if(ar5k_2ghz_channels[i].rc_mode & IEEE80211_CHAN_OFDM)
d386 1
a386 1
	return(AH_TRUE);
d400 1
a400 1
	if(hal->ah_radar.r_last_channel.channel ==
d428 2
a429 2
	if(hal->ah_eeprom_is_busy(hal))
		return(-EBUSY);
d434 2
a435 2
	if(hal->ah_eeprom_read(hal, 0x20, &data) != 0)
		return(-EIO);
d437 4
a440 4
	for(offset = 0x1f, octet = 0, total = 0;
	    offset >= 0x1d; offset--) {
		if(hal->ah_eeprom_read(hal, offset, &data) != 0)
			return(-EIO);
d450 2
a451 2
	if((!total) || total == (3 * 0xffff))
		return(-EINVAL);
d453 1
a453 1
	return(0);
d463 1
a463 1
	return((u_int8_t)*regdomain);
d473 1
a473 1
	return((ieee80211_regdomain_t*)&regdomain);
d488 1
a488 1
	return(retval);
d496 1
a496 1
	return(turbo == AH_TRUE ? (usec * 80) : (usec * 40));
d504 1
a504 1
	return(turbo == AH_TRUE ? (clock / 80) : (clock / 40));
d527 2
a528 2
	for(i = AR5K_TUNE_REGISTER_TIMEOUT; i > 0; i--) {
		if((is_set == AH_TRUE) && (AR5K_REG_READ(reg) & flag))
d530 1
a530 1
		else if((AR5K_REG_READ(reg) & flag) == val)
d535 2
a536 2
	if(i <= 0)
		return(AH_FALSE);
d538 1
a538 1
	return(AH_TRUE);
@


1.1
log
@import of a free hal part for the ath driver as a replacement for the
binary-only hal module found in FreeBSD and NetBSD. OpenBSD's approach
is based on reverse engineering because it is _not_ possible to
include a non-free and binary-only piece of software in a 100% free
operating system. it still lacks some features found in the "official" hal
module but this will be done very soon with a help by a lot of
contributors - because it's free.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2004 Reyk Floeter <reyk@@vantronix.net>. 
d140 1
a140 1
	
d197 1
a197 1
	
d223 1
a223 1
u_int16_t 
d249 1
a249 1
		value = AR5K_CCK_TX_TIME(rate->rateKbps, frame_length, 
d255 1
a255 1
		 * Orthogonal Frequency Division Multiplexing 
d264 1
a264 1
		 * Orthogonal Frequency Division Multiplexing 
d274 1
a274 1
		 * Orthogonal Frequency Division Multiplexing 
d324 4
a327 2
	domain_5ghz = ieee80211_regdomain2flag(domain_current, IEEE80211_CHANNELS_5GHZ_MIN);
	domain_2ghz = ieee80211_regdomain2flag(domain_current, IEEE80211_CHANNELS_2GHZ_MIN);
d334 2
a335 1
		(i < (sizeof(ar5k_5ghz_channels) / sizeof(ar5k_5ghz_channels[0]))) &&
d343 1
a343 1
		
d348 1
a348 1
		
d354 1
a354 1
		else 
d356 1
a356 1
		
d364 4
a367 3
	for(i = 0; (hal->ah_capabilities.cap_range.range_2ghz_max > 0) &&
		(i < (sizeof(ar5k_2ghz_channels) / sizeof(ar5k_2ghz_channels[0]))) &&
		(c < max_channels); i++) {
d374 1
a374 1
		
d387 1
a387 1
		else 
d409 1
a409 1
	 * Limit ~1/s 
d428 1
a428 1
	struct ath_hal *hal; 
d461 2
a462 2
	if((!total) || total == (3 * 0xffff)) 
		return(-EINVAL); 
d493 1
a493 1
	
d498 1
a498 1
	
a550 2


@

