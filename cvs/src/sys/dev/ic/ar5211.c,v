head	1.48;
access;
symbols
	OPENBSD_6_1:1.48.0.4
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.48.0.6
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.45.0.8
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.12
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.14
	OPENBSD_5_0:1.44.0.10
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.8
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.6
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.48
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.47;
commitid	1npmDuWgN1zBR6BQ;

1.47
date	2015.03.20.11.05.49;	author stsp;	state Exp;
branches;
next	1.46;
commitid	gNCoB8jCzgWi3ZfR;

1.46
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.45;
commitid	I19imNlAX05zJOED;

1.45
date	2012.08.30.11.03.57;	author jsg;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.02.12.39.02;	author reyk;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.02.12.09.26;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.06.17.06.45;	author grange;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.15.07.55.22;	author grange;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.13.13.35.06;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.29.10.05.00;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.30.07.15.39;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.01.20.32.16;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.29.09.39.35;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.12.01.04.52;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.12.00.41.32;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.05.16.54.33;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.05.15.13.26;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2006.09.19.16.42.29;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.19.13.37.11;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2006.09.19.13.14.32;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.18.17.59.58;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.07.22.03.25;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.04.13.50.00;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.19.10.27.08;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.10.14.36.46;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.14.11.02.33;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.30.17.13.17;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.17.12.51.08;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.28.23.45.09;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.27.11.42.52;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.24.21.46.18;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.21.20.14.55;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.08.14.46.50;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.20.01.46.02;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.18.18.42.55;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.08.22.12.21;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.08.22.02.49;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.06.09.14.53;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.23.16.23.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.20.04.21.55;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.19.17.27.46;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.13.18.32.21;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.10.08.30.56;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.03.16.39.54;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.25.22.25.30;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@/*	$OpenBSD: ar5211.c,v 1.47 2015/03/20 11:05:49 stsp Exp $	*/

/*
 * Copyright (c) 2004, 2005, 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * HAL interface for the Atheros AR5001 Wireless LAN chipset
 * (AR5211 + AR5111).
 */

#include <dev/ic/ar5xxx.h>
#include <dev/ic/ar5211reg.h>
#include <dev/ic/ar5211var.h>

HAL_BOOL	 ar5k_ar5211_nic_reset(struct ath_hal *, u_int32_t);
HAL_BOOL	 ar5k_ar5211_nic_wakeup(struct ath_hal *, u_int16_t);
u_int16_t	 ar5k_ar5211_radio_revision(struct ath_hal *, HAL_CHIP);
void		 ar5k_ar5211_fill(struct ath_hal *);
HAL_BOOL	 ar5k_ar5211_rfregs(struct ath_hal *, HAL_CHANNEL *, u_int,
    u_int);

/*
 * Initial register setting for the AR5211
 */
static const struct ar5k_ini ar5211_ini[] =
    AR5K_AR5211_INI;
static const struct ar5k_ar5211_ini_mode ar5211_mode[] =
    AR5K_AR5211_INI_MODE;
static const struct ar5k_ar5211_ini_rf ar5211_rf[] =
    AR5K_AR5211_INI_RF;

AR5K_HAL_FUNCTIONS(extern, ar5k_ar5211,);

void
ar5k_ar5211_fill(struct ath_hal *hal)
{
	hal->ah_magic = AR5K_AR5211_MAGIC;

	/*
	 * Init/Exit functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, get_rate_table);
	AR5K_HAL_FUNCTION(hal, ar5211, detach);

	/*
	 * Reset functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, reset);
	AR5K_HAL_FUNCTION(hal, ar5211, set_opmode);
	AR5K_HAL_FUNCTION(hal, ar5211, calibrate);

	/*
	 * TX functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, update_tx_triglevel);
	AR5K_HAL_FUNCTION(hal, ar5211, setup_tx_queue);
	AR5K_HAL_FUNCTION(hal, ar5211, setup_tx_queueprops);
	AR5K_HAL_FUNCTION(hal, ar5211, release_tx_queue);
	AR5K_HAL_FUNCTION(hal, ar5211, reset_tx_queue);
	AR5K_HAL_FUNCTION(hal, ar5211, get_tx_buf);
	AR5K_HAL_FUNCTION(hal, ar5211, put_tx_buf);
	AR5K_HAL_FUNCTION(hal, ar5211, tx_start);
	AR5K_HAL_FUNCTION(hal, ar5211, stop_tx_dma);
	AR5K_HAL_FUNCTION(hal, ar5211, setup_tx_desc);
	AR5K_HAL_FUNCTION(hal, ar5211, setup_xtx_desc);
	AR5K_HAL_FUNCTION(hal, ar5211, fill_tx_desc);
	AR5K_HAL_FUNCTION(hal, ar5211, proc_tx_desc);
	AR5K_HAL_FUNCTION(hal, ar5211, has_veol);

	/*
	 * RX functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, get_rx_buf);
	AR5K_HAL_FUNCTION(hal, ar5211, put_rx_buf);
	AR5K_HAL_FUNCTION(hal, ar5211, start_rx);
	AR5K_HAL_FUNCTION(hal, ar5211, stop_rx_dma);
	AR5K_HAL_FUNCTION(hal, ar5211, start_rx_pcu);
	AR5K_HAL_FUNCTION(hal, ar5211, stop_pcu_recv);
	AR5K_HAL_FUNCTION(hal, ar5211, set_mcast_filter);
	AR5K_HAL_FUNCTION(hal, ar5211, set_mcast_filterindex);
	AR5K_HAL_FUNCTION(hal, ar5211, clear_mcast_filter_idx);
	AR5K_HAL_FUNCTION(hal, ar5211, get_rx_filter);
	AR5K_HAL_FUNCTION(hal, ar5211, set_rx_filter);
	AR5K_HAL_FUNCTION(hal, ar5211, setup_rx_desc);
	AR5K_HAL_FUNCTION(hal, ar5211, proc_rx_desc);
	AR5K_HAL_FUNCTION(hal, ar5211, set_rx_signal);

	/*
	 * Misc functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, dump_state);
	AR5K_HAL_FUNCTION(hal, ar5211, get_diag_state);
	AR5K_HAL_FUNCTION(hal, ar5211, get_lladdr);
	AR5K_HAL_FUNCTION(hal, ar5211, set_lladdr);
	AR5K_HAL_FUNCTION(hal, ar5211, set_regdomain);
	AR5K_HAL_FUNCTION(hal, ar5211, set_ledstate);
	AR5K_HAL_FUNCTION(hal, ar5211, set_associd);
	AR5K_HAL_FUNCTION(hal, ar5211, set_gpio_input);
	AR5K_HAL_FUNCTION(hal, ar5211, set_gpio_output);
	AR5K_HAL_FUNCTION(hal, ar5211, get_gpio);
	AR5K_HAL_FUNCTION(hal, ar5211, set_gpio);
	AR5K_HAL_FUNCTION(hal, ar5211, set_gpio_intr);
	AR5K_HAL_FUNCTION(hal, ar5211, get_tsf32);
	AR5K_HAL_FUNCTION(hal, ar5211, get_tsf64);
	AR5K_HAL_FUNCTION(hal, ar5211, reset_tsf);
	AR5K_HAL_FUNCTION(hal, ar5211, get_regdomain);
	AR5K_HAL_FUNCTION(hal, ar5211, detect_card_present);
	AR5K_HAL_FUNCTION(hal, ar5211, update_mib_counters);
	AR5K_HAL_FUNCTION(hal, ar5211, get_rf_gain);
	AR5K_HAL_FUNCTION(hal, ar5211, set_slot_time);
	AR5K_HAL_FUNCTION(hal, ar5211, get_slot_time);
	AR5K_HAL_FUNCTION(hal, ar5211, set_ack_timeout);
	AR5K_HAL_FUNCTION(hal, ar5211, get_ack_timeout);
	AR5K_HAL_FUNCTION(hal, ar5211, set_cts_timeout);
	AR5K_HAL_FUNCTION(hal, ar5211, get_cts_timeout);

	/*
	 * Key table (WEP) functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, is_cipher_supported);
	AR5K_HAL_FUNCTION(hal, ar5211, get_keycache_size);
	AR5K_HAL_FUNCTION(hal, ar5211, reset_key);
	AR5K_HAL_FUNCTION(hal, ar5211, is_key_valid);
	AR5K_HAL_FUNCTION(hal, ar5211, set_key);
	AR5K_HAL_FUNCTION(hal, ar5211, set_key_lladdr);
	AR5K_HAL_FUNCTION(hal, ar5211, softcrypto);

	/*
	 * Power management functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, set_power);
	AR5K_HAL_FUNCTION(hal, ar5211, get_power_mode);
	AR5K_HAL_FUNCTION(hal, ar5211, query_pspoll_support);
	AR5K_HAL_FUNCTION(hal, ar5211, init_pspoll);
	AR5K_HAL_FUNCTION(hal, ar5211, enable_pspoll);
	AR5K_HAL_FUNCTION(hal, ar5211, disable_pspoll);

	/*
	 * Beacon functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, init_beacon);
	AR5K_HAL_FUNCTION(hal, ar5211, set_beacon_timers);
	AR5K_HAL_FUNCTION(hal, ar5211, reset_beacon);
	AR5K_HAL_FUNCTION(hal, ar5211, wait_for_beacon);

	/*
	 * Interrupt functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, is_intr_pending);
	AR5K_HAL_FUNCTION(hal, ar5211, get_isr);
	AR5K_HAL_FUNCTION(hal, ar5211, get_intr);
	AR5K_HAL_FUNCTION(hal, ar5211, set_intr);

	/*
	 * Chipset functions (ar5k-specific, non-HAL)
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, get_capabilities);
	AR5K_HAL_FUNCTION(hal, ar5211, radar_alert);

	/*
	 * EEPROM access
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, eeprom_is_busy);
	AR5K_HAL_FUNCTION(hal, ar5211, eeprom_read);
	AR5K_HAL_FUNCTION(hal, ar5211, eeprom_write);

	/*
	 * Unused functions or functions not implemented
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, get_tx_queueprops);
	AR5K_HAL_FUNCTION(hal, ar5211, num_tx_pending);
	AR5K_HAL_FUNCTION(hal, ar5211, phy_disable);
	AR5K_HAL_FUNCTION(hal, ar5211, set_txpower_limit);
	AR5K_HAL_FUNCTION(hal, ar5211, set_def_antenna);
	AR5K_HAL_FUNCTION(hal, ar5211, get_def_antenna);
	AR5K_HAL_FUNCTION(hal, ar5211, set_bssid_mask);
#ifdef notyet
	AR5K_HAL_FUNCTION(hal, ar5211, set_capability);
	AR5K_HAL_FUNCTION(hal, ar5211, proc_mib_event);
	AR5K_HAL_FUNCTION(hal, ar5211, get_tx_inter_queue);
#endif
}

struct ath_hal *
ar5k_ar5211_attach(u_int16_t device, void *sc, bus_space_tag_t st,
    bus_space_handle_t sh, int *status)
{
	struct ath_hal *hal = (struct ath_hal*) sc;
	u_int8_t mac[IEEE80211_ADDR_LEN];
	u_int32_t srev;

	ar5k_ar5211_fill(hal);

	/* Bring device out of sleep and reset its units */
	if (ar5k_ar5211_nic_wakeup(hal, AR5K_INIT_MODE) != AH_TRUE)
		return (NULL);

	/* Get MAC, PHY and RADIO revisions */
	srev = AR5K_REG_READ(AR5K_AR5211_SREV);
	hal->ah_mac_srev = srev;
	hal->ah_mac_version = AR5K_REG_MS(srev, AR5K_AR5211_SREV_VER);
	hal->ah_mac_revision = AR5K_REG_MS(srev, AR5K_AR5211_SREV_REV);
	hal->ah_phy_revision = AR5K_REG_READ(AR5K_AR5211_PHY_CHIP_ID) &
	    0x00ffffffff;
	hal->ah_radio_5ghz_revision =
	    ar5k_ar5211_radio_revision(hal, HAL_CHIP_5GHZ);
	hal->ah_radio_2ghz_revision = 0;

	/* Identify the chipset (this has to be done in an early step) */
	hal->ah_version = AR5K_AR5211;
	hal->ah_radio = AR5K_AR5111;
	hal->ah_phy = AR5K_AR5211_PHY(0);

	bcopy(etherbroadcastaddr, mac, IEEE80211_ADDR_LEN);
	ar5k_ar5211_set_associd(hal, mac, 0, 0);
	ar5k_ar5211_get_lladdr(hal, mac);
	ar5k_ar5211_set_opmode(hal);

	return (hal);
}

HAL_BOOL
ar5k_ar5211_nic_reset(struct ath_hal *hal, u_int32_t val)
{
	HAL_BOOL ret = AH_FALSE;
	u_int32_t mask = val ? val : ~0;

	/* Read-and-clear */
	AR5K_REG_READ(AR5K_AR5211_RXDP);

	/*
	 * Reset the device and wait until success
	 */
	AR5K_REG_WRITE(AR5K_AR5211_RC, val);

	/* Wait at least 128 PCI clocks */
	AR5K_DELAY(15);

	val &=
	    AR5K_AR5211_RC_PCU | AR5K_AR5211_RC_BB;

	mask &=
	    AR5K_AR5211_RC_PCU | AR5K_AR5211_RC_BB;

	ret = ar5k_register_timeout(hal, AR5K_AR5211_RC, mask, val, AH_FALSE);

	/*
	 * Reset configuration register
	 */
	if ((val & AR5K_AR5211_RC_PCU) == 0)
		AR5K_REG_WRITE(AR5K_AR5211_CFG, AR5K_AR5211_INIT_CFG);

	return (ret);
}

HAL_BOOL
ar5k_ar5211_nic_wakeup(struct ath_hal *hal, u_int16_t flags)
{
	u_int32_t turbo, mode, clock;

	turbo = 0;
	mode = 0;
	clock = 0;

	/*
	 * Get channel mode flags
	 */

	if (flags & IEEE80211_CHAN_2GHZ) {
		mode |= AR5K_AR5211_PHY_MODE_FREQ_2GHZ;
		clock |= AR5K_AR5211_PHY_PLL_44MHZ;
	} else if (flags & IEEE80211_CHAN_5GHZ) {
		mode |= AR5K_AR5211_PHY_MODE_FREQ_5GHZ;
		clock |= AR5K_AR5211_PHY_PLL_40MHZ;
	} else {
		AR5K_PRINT("invalid radio frequency mode\n");
		return (AH_FALSE);
	}

	if ((flags & IEEE80211_CHAN_CCK) ||
	    (flags & IEEE80211_CHAN_DYN)) {
		/* Dynamic OFDM/CCK is not supported by the AR5211 */
		mode |= AR5K_AR5211_PHY_MODE_MOD_CCK;
	} else if (flags & IEEE80211_CHAN_OFDM) {
		mode |= AR5K_AR5211_PHY_MODE_MOD_OFDM;
	} else {
		AR5K_PRINT("invalid radio frequency mode\n");
		return (AH_FALSE);
	}

	/*
	 * Reset and wakeup the device
	 */

	/* ...reset chipset and PCI device */
	if (ar5k_ar5211_nic_reset(hal,
		AR5K_AR5211_RC_CHIP | AR5K_AR5211_RC_PCI) == AH_FALSE) {
		AR5K_PRINT("failed to reset the AR5211 + PCI chipset\n");
		return (AH_FALSE);
	}

	/* ...wakeup */
	if (ar5k_ar5211_set_power(hal,
		HAL_PM_AWAKE, AH_TRUE, 0) == AH_FALSE) {
		AR5K_PRINT("failed to resume the AR5211 (again)\n");
		return (AH_FALSE);
	}

	/* ...final warm reset */
	if (ar5k_ar5211_nic_reset(hal, 0) == AH_FALSE) {
		AR5K_PRINT("failed to warm reset the AR5211\n");
		return (AH_FALSE);
	}

	/* ...set the PHY operating mode */
	AR5K_REG_WRITE(AR5K_AR5211_PHY_PLL, clock);
	AR5K_DELAY(300);

	AR5K_REG_WRITE(AR5K_AR5211_PHY_MODE, mode);
	AR5K_REG_WRITE(AR5K_AR5211_PHY_TURBO, turbo);

	return (AH_TRUE);
}

u_int16_t
ar5k_ar5211_radio_revision(struct ath_hal *hal, HAL_CHIP chip)
{
	int i;
	u_int32_t srev;
	u_int16_t ret;

	/*
	 * Set the radio chip access register
	 */
	switch (chip) {
	case HAL_CHIP_2GHZ:
		AR5K_REG_WRITE(AR5K_AR5211_PHY(0), AR5K_AR5211_PHY_SHIFT_2GHZ);
		break;
	case HAL_CHIP_5GHZ:
		AR5K_REG_WRITE(AR5K_AR5211_PHY(0), AR5K_AR5211_PHY_SHIFT_5GHZ);
		break;
	default:
		return (0);
	}

	AR5K_DELAY(2000);

	/* ...wait until PHY is ready and read the selected radio revision */
	AR5K_REG_WRITE(AR5K_AR5211_PHY(0x34), 0x00001c16);

	for (i = 0; i < 8; i++)
		AR5K_REG_WRITE(AR5K_AR5211_PHY(0x20), 0x00010000);
	srev = (AR5K_REG_READ(AR5K_AR5211_PHY(0x100)) >> 24) & 0xff;

	ret = ar5k_bitswap(((srev & 0xf0) >> 4) | ((srev & 0x0f) << 4), 8);

	/* Reset to the 5GHz mode */
	AR5K_REG_WRITE(AR5K_AR5211_PHY(0), AR5K_AR5211_PHY_SHIFT_5GHZ);

	return (ret);
}

const HAL_RATE_TABLE *
ar5k_ar5211_get_rate_table(struct ath_hal *hal, u_int mode)
{
	switch (mode) {
	case HAL_MODE_11A:
		return (&hal->ah_rt_11a);
	case HAL_MODE_11B:
		return (&hal->ah_rt_11b);
	case HAL_MODE_11G:
	case HAL_MODE_PUREG:
		return (&hal->ah_rt_11g);
	default:
		return (NULL);
	}

	return (NULL);
}

void
ar5k_ar5211_detach(struct ath_hal *hal)
{
	/*
	 * Free HAL structure, assume interrupts are down
	 */
	free(hal, M_DEVBUF, 0);
}

HAL_BOOL
ar5k_ar5211_phy_disable(struct ath_hal *hal)
{
	AR5K_REG_WRITE(AR5K_AR5211_PHY_ACTIVE, AR5K_AR5211_PHY_DISABLE);
	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_reset(struct ath_hal *hal, HAL_OPMODE op_mode, HAL_CHANNEL *channel,
    HAL_BOOL change_channel, HAL_STATUS *status)
{
	struct ar5k_eeprom_info *ee = &hal->ah_capabilities.cap_eeprom;
	u_int8_t mac[IEEE80211_ADDR_LEN];
	u_int32_t data, s_seq, s_ant, s_led[3];
	u_int i, mode, freq, ee_mode, ant[2];

	/*
	 * Save some registers before a reset
	 */
	if (change_channel == AH_TRUE) {
		s_seq = AR5K_REG_READ(AR5K_AR5211_DCU_SEQNUM(0));
		s_ant = AR5K_REG_READ(AR5K_AR5211_DEFAULT_ANTENNA);
	} else {
		s_seq = 0;
		s_ant = 1;
	}

	s_led[0] = AR5K_REG_READ(AR5K_AR5211_PCICFG) &
	    AR5K_AR5211_PCICFG_LEDSTATE;
	s_led[1] = AR5K_REG_READ(AR5K_AR5211_GPIOCR);
	s_led[2] = AR5K_REG_READ(AR5K_AR5211_GPIODO);

	if (ar5k_ar5211_nic_wakeup(hal, channel->c_channel_flags) == AH_FALSE)
		return (AH_FALSE);

	/*
	 * Initialize operating mode
	 */
	hal->ah_op_mode = op_mode;

	switch (channel->c_channel_flags & CHANNEL_MODES) {
	case CHANNEL_A:
		mode = AR5K_INI_VAL_11A;
		freq = AR5K_INI_RFGAIN_5GHZ;
		ee_mode = AR5K_EEPROM_MODE_11A;
		break;
	case CHANNEL_B:
		mode = AR5K_INI_VAL_11B;
		freq = AR5K_INI_RFGAIN_2GHZ;
		ee_mode = AR5K_EEPROM_MODE_11B;
		break;
	case CHANNEL_G:
	case CHANNEL_PUREG:
		mode = AR5K_INI_VAL_11G;
		freq = AR5K_INI_RFGAIN_2GHZ;
		ee_mode = AR5K_EEPROM_MODE_11G;
		break;
	default:
		AR5K_PRINTF("invalid channel: %d\n", channel->c_channel);
		return (AH_FALSE);
	}

	/* PHY access enable */
	AR5K_REG_WRITE(AR5K_AR5211_PHY(0), AR5K_AR5211_PHY_SHIFT_5GHZ);

	/*
	 * Write initial RF registers
	 */
	if (ar5k_ar5211_rfregs(hal, channel, freq, ee_mode) == AH_FALSE)
		return (AH_FALSE);

	/*
	 * Write initial mode settings
	 */
	for (i = 0; i < nitems(ar5211_mode); i++) {
		AR5K_REG_WAIT(i);
		AR5K_REG_WRITE((u_int32_t)ar5211_mode[i].mode_register,
		    ar5211_mode[i].mode_value[mode]);
	}

	/*
	 * Write initial register settings
	 */
	for (i = 0; i < nitems(ar5211_ini); i++) {
		if (change_channel == AH_TRUE &&
		    ar5211_ini[i].ini_register >= AR5K_AR5211_PCU_MIN &&
		    ar5211_ini[i].ini_register <= AR5K_AR5211_PCU_MAX)
			continue;

		AR5K_REG_WAIT(i);
		AR5K_REG_WRITE((u_int32_t)ar5211_ini[i].ini_register,
		    ar5211_ini[i].ini_value);
	}

	/*
	 * Write initial RF gain settings
	 */
	if (ar5k_rfgain(hal, freq) == AH_FALSE)
		return (AH_FALSE);

	AR5K_DELAY(1000);

	/*
	 * Configure additional registers
	 */

	if (hal->ah_radio == AR5K_AR5111) {
		if (channel->c_channel_flags & IEEE80211_CHAN_B)
			AR5K_REG_ENABLE_BITS(AR5K_AR5211_TXCFG,
			    AR5K_AR5211_TXCFG_B_MODE);
		else
			AR5K_REG_DISABLE_BITS(AR5K_AR5211_TXCFG,
			    AR5K_AR5211_TXCFG_B_MODE);
	}

	/* Set antenna mode */
	AR5K_REG_MASKED_BITS(AR5K_AR5211_PHY(0x44),
	    hal->ah_antenna[ee_mode][0], 0xfffffc06);

	if (freq == AR5K_INI_RFGAIN_2GHZ)
		ant[0] = ant[1] = HAL_ANT_FIXED_B;
	else
		ant[0] = ant[1] = HAL_ANT_FIXED_A;

	AR5K_REG_WRITE(AR5K_AR5211_PHY_ANT_SWITCH_TABLE_0,
	    hal->ah_antenna[ee_mode][ant[0]]);
	AR5K_REG_WRITE(AR5K_AR5211_PHY_ANT_SWITCH_TABLE_1,
	    hal->ah_antenna[ee_mode][ant[1]]);

	/* Commit values from EEPROM */
	AR5K_REG_WRITE_BITS(AR5K_AR5211_PHY_FC,
	    AR5K_AR5211_PHY_FC_TX_CLIP, ee->ee_tx_clip);

	AR5K_REG_WRITE(AR5K_AR5211_PHY(0x5a),
	    AR5K_AR5211_PHY_NF_SVAL(ee->ee_noise_floor_thr[ee_mode]));

	AR5K_REG_MASKED_BITS(AR5K_AR5211_PHY(0x11),
	    (ee->ee_switch_settling[ee_mode] << 7) & 0x3f80, 0xffffc07f);
	AR5K_REG_MASKED_BITS(AR5K_AR5211_PHY(0x12),
	    (ee->ee_ant_tx_rx[ee_mode] << 12) & 0x3f000, 0xfffc0fff);
	AR5K_REG_MASKED_BITS(AR5K_AR5211_PHY(0x14),
	    (ee->ee_adc_desired_size[ee_mode] & 0x00ff) |
	    ((ee->ee_pga_desired_size[ee_mode] << 8) & 0xff00), 0xffff0000);

	AR5K_REG_WRITE(AR5K_AR5211_PHY(0x0d),
	    (ee->ee_tx_end2xpa_disable[ee_mode] << 24) |
	    (ee->ee_tx_end2xpa_disable[ee_mode] << 16) |
	    (ee->ee_tx_frm2xpa_enable[ee_mode] << 8) |
	    (ee->ee_tx_frm2xpa_enable[ee_mode]));

	AR5K_REG_MASKED_BITS(AR5K_AR5211_PHY(0x0a),
	    ee->ee_tx_end2xlna_enable[ee_mode] << 8, 0xffff00ff);
	AR5K_REG_MASKED_BITS(AR5K_AR5211_PHY(0x19),
	    (ee->ee_thr_62[ee_mode] << 12) & 0x7f000, 0xfff80fff);
	AR5K_REG_MASKED_BITS(AR5K_AR5211_PHY(0x49), 4, 0xffffff01);

	AR5K_REG_ENABLE_BITS(AR5K_AR5211_PHY_IQ,
	    AR5K_AR5211_PHY_IQ_CORR_ENABLE |
	    (ee->ee_i_cal[ee_mode] << AR5K_AR5211_PHY_IQ_CORR_Q_I_COFF_S) |
	    ee->ee_q_cal[ee_mode]);

	/*
	 * Restore saved values
	 */
	AR5K_REG_WRITE(AR5K_AR5211_DCU_SEQNUM(0), s_seq);
	AR5K_REG_WRITE(AR5K_AR5211_DEFAULT_ANTENNA, s_ant);
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_PCICFG, s_led[0]);
	AR5K_REG_WRITE(AR5K_AR5211_GPIOCR, s_led[1]);
	AR5K_REG_WRITE(AR5K_AR5211_GPIODO, s_led[2]);

	/*
	 * Misc
	 */
	bcopy(etherbroadcastaddr, mac, IEEE80211_ADDR_LEN);
	ar5k_ar5211_set_associd(hal, mac, 0, 0);
	ar5k_ar5211_set_opmode(hal);
	AR5K_REG_WRITE(AR5K_AR5211_PISR, 0xffffffff);
	AR5K_REG_WRITE(AR5K_AR5211_RSSI_THR, AR5K_TUNE_RSSI_THRES);

	/*
	 * Set Rx/Tx DMA Configuration
	 */
	AR5K_REG_WRITE_BITS(AR5K_AR5211_TXCFG, AR5K_AR5211_TXCFG_SDMAMR,
	    AR5K_AR5211_DMASIZE_512B | AR5K_AR5211_TXCFG_DMASIZE);
	AR5K_REG_WRITE_BITS(AR5K_AR5211_RXCFG, AR5K_AR5211_RXCFG_SDMAMW,
	    AR5K_AR5211_DMASIZE_512B);

	/*
	 * Set channel and calibrate the PHY
	 */
	if (ar5k_channel(hal, channel) == AH_FALSE)
		return (AH_FALSE);

	/*
	 * Enable the PHY and wait until completion
	 */
	AR5K_REG_WRITE(AR5K_AR5211_PHY_ACTIVE, AR5K_AR5211_PHY_ENABLE);

	data = AR5K_REG_READ(AR5K_AR5211_PHY_RX_DELAY) &
	    AR5K_AR5211_PHY_RX_DELAY_M;
	data = (channel->c_channel_flags & IEEE80211_CHAN_CCK) ?
	    ((data << 2) / 22) : (data / 10);

	AR5K_DELAY(100 + data);

	/*
	 * Start calibration
	 */
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_PHY_AGCCTL,
	    AR5K_AR5211_PHY_AGCCTL_NF |
	    AR5K_AR5211_PHY_AGCCTL_CAL);

	if (channel->c_channel_flags & IEEE80211_CHAN_B) {
		hal->ah_calibration = AH_FALSE;
	} else {
		hal->ah_calibration = AH_TRUE;
		AR5K_REG_WRITE_BITS(AR5K_AR5211_PHY_IQ,
		    AR5K_AR5211_PHY_IQ_CAL_NUM_LOG_MAX, 15);
		AR5K_REG_ENABLE_BITS(AR5K_AR5211_PHY_IQ,
		    AR5K_AR5211_PHY_IQ_RUN);
	}

	/*
	 * Reset queues and start beacon timers at the end of the reset routine
	 */
	for (i = 0; i < hal->ah_capabilities.cap_queues.q_tx_num; i++) {
		AR5K_REG_WRITE_Q(AR5K_AR5211_DCU_QCUMASK(i), i);
		if (ar5k_ar5211_reset_tx_queue(hal, i) == AH_FALSE) {
			AR5K_PRINTF("failed to reset TX queue #%d\n", i);
			return (AH_FALSE);
		}
	}

	/* Pre-enable interrupts */
	ar5k_ar5211_set_intr(hal, HAL_INT_RX | HAL_INT_TX | HAL_INT_FATAL);

	/*
	 * Set RF kill flags if supported by the device (read from the EEPROM)
	 */
	if (AR5K_EEPROM_HDR_RFKILL(hal->ah_capabilities.cap_eeprom.ee_header)) {
		ar5k_ar5211_set_gpio_input(hal, 0);
		if ((hal->ah_gpio[0] = ar5k_ar5211_get_gpio(hal, 0)) == 0)
			ar5k_ar5211_set_gpio_intr(hal, 0, 1);
		else
			ar5k_ar5211_set_gpio_intr(hal, 0, 0);
	}

	/* 
	 * Disable beacons and reset the register
	 */
	AR5K_REG_DISABLE_BITS(AR5K_AR5211_BEACON,
	    AR5K_AR5211_BEACON_ENABLE | AR5K_AR5211_BEACON_RESET_TSF);

	return (AH_TRUE);
}

void
ar5k_ar5211_set_def_antenna(struct ath_hal *hal, u_int ant)
{
	AR5K_REG_WRITE(AR5K_AR5211_DEFAULT_ANTENNA, ant);
}

u_int
ar5k_ar5211_get_def_antenna(struct ath_hal *hal)
{
	return AR5K_REG_READ(AR5K_AR5211_DEFAULT_ANTENNA);
}

void
ar5k_ar5211_set_opmode(struct ath_hal *hal)
{
	u_int32_t pcu_reg, low_id, high_id;

	pcu_reg = 0;

	switch (hal->ah_op_mode) {
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		pcu_reg |= AR5K_AR5211_STA_ID1_ADHOC |
		    AR5K_AR5211_STA_ID1_DESC_ANTENNA;
		break;

	case IEEE80211_M_HOSTAP:
		pcu_reg |= AR5K_AR5211_STA_ID1_AP |
		    AR5K_AR5211_STA_ID1_RTS_DEFAULT_ANTENNA;
		break;
#endif

	case IEEE80211_M_STA:
	case IEEE80211_M_MONITOR:
		pcu_reg |= AR5K_AR5211_STA_ID1_DEFAULT_ANTENNA;
		break;

	default:
		return;
	}

	/*
	 * Set PCU registers
	 */
	low_id = AR5K_LOW_ID(hal->ah_sta_id);
	high_id = AR5K_HIGH_ID(hal->ah_sta_id);
	AR5K_REG_WRITE(AR5K_AR5211_STA_ID0, low_id);
	AR5K_REG_WRITE(AR5K_AR5211_STA_ID1, pcu_reg | high_id);

	return;
}

HAL_BOOL
ar5k_ar5211_calibrate(struct ath_hal *hal, HAL_CHANNEL *channel)
{
	u_int32_t i_pwr, q_pwr;
	int32_t iq_corr, i_coff, i_coffd, q_coff, q_coffd;

	if (hal->ah_calibration == AH_FALSE ||
	    AR5K_REG_READ(AR5K_AR5211_PHY_IQ) & AR5K_AR5211_PHY_IQ_RUN)
		goto done;

	hal->ah_calibration = AH_FALSE;

	iq_corr = AR5K_REG_READ(AR5K_AR5211_PHY_IQRES_CAL_CORR);
	i_pwr = AR5K_REG_READ(AR5K_AR5211_PHY_IQRES_CAL_PWR_I);
	q_pwr = AR5K_REG_READ(AR5K_AR5211_PHY_IQRES_CAL_PWR_Q);
	i_coffd = ((i_pwr >> 1) + (q_pwr >> 1)) >> 7;
	q_coffd = q_pwr >> 6;

	if (i_coffd == 0 || q_coffd == 0)
		goto done;

	i_coff = ((-iq_corr) / i_coffd) & 0x3f;
	q_coff = (((int32_t)i_pwr / q_coffd) - 64) & 0x1f;

	/* Commit new IQ value */
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_PHY_IQ,
	    AR5K_AR5211_PHY_IQ_CORR_ENABLE |
	    ((u_int32_t)q_coff) |
	    ((u_int32_t)i_coff << AR5K_AR5211_PHY_IQ_CORR_Q_I_COFF_S));

 done:
	/* Start noise floor calibration */
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_PHY_AGCCTL,
	    AR5K_AR5211_PHY_AGCCTL_NF);

	return (AH_TRUE);
}

/*
 * Transmit functions
 */

HAL_BOOL
ar5k_ar5211_update_tx_triglevel(struct ath_hal *hal, HAL_BOOL increase)
{
	u_int32_t trigger_level, imr;
	HAL_BOOL status = AH_FALSE;

	/*
	 * Disable interrupts by setting the mask
	 */
	imr = ar5k_ar5211_set_intr(hal, hal->ah_imr & ~HAL_INT_GLOBAL);

	trigger_level = AR5K_REG_MS(AR5K_REG_READ(AR5K_AR5211_TXCFG),
	    AR5K_AR5211_TXCFG_TXFULL);

	if (increase == AH_FALSE) {
		if (--trigger_level < AR5K_TUNE_MIN_TX_FIFO_THRES)
			goto done;
	} else
		trigger_level +=
		    ((AR5K_TUNE_MAX_TX_FIFO_THRES - trigger_level) / 2);

	/*
	 * Update trigger level on success
	 */
	AR5K_REG_WRITE_BITS(AR5K_AR5211_TXCFG,
	    AR5K_AR5211_TXCFG_TXFULL, trigger_level);
	status = AH_TRUE;

 done:
	/*
	 * Restore interrupt mask
	 */
	ar5k_ar5211_set_intr(hal, imr);

	return (status);
}

int
ar5k_ar5211_setup_tx_queue(struct ath_hal *hal, HAL_TX_QUEUE queue_type,
    const HAL_TXQ_INFO *queue_info)
{
	u_int queue;

	/*
	 * Get queue by type
	 */
	if (queue_type == HAL_TX_QUEUE_DATA) {
		for (queue = HAL_TX_QUEUE_ID_DATA_MIN;
		     hal->ah_txq[queue].tqi_type != HAL_TX_QUEUE_INACTIVE;
		     queue++)
			if (queue > HAL_TX_QUEUE_ID_DATA_MAX)
				return (-1);
	} else if (queue_type == HAL_TX_QUEUE_PSPOLL) {
		queue = HAL_TX_QUEUE_ID_PSPOLL;
	} else if (queue_type == HAL_TX_QUEUE_BEACON) {
		queue = HAL_TX_QUEUE_ID_BEACON;
	} else if (queue_type == HAL_TX_QUEUE_CAB) {
		queue = HAL_TX_QUEUE_ID_CAB;
	} else
		return (-1);

	/*
	 * Setup internal queue structure
	 */
	bzero(&hal->ah_txq[queue], sizeof(HAL_TXQ_INFO));
	hal->ah_txq[queue].tqi_type = queue_type;

	if (queue_info != NULL) {
		if (ar5k_ar5211_setup_tx_queueprops(hal, queue, queue_info)
		    != AH_TRUE)
			return (-1);
	}

	AR5K_Q_ENABLE_BITS(hal->ah_txq_interrupts, queue);

	return (queue);
}

HAL_BOOL
ar5k_ar5211_setup_tx_queueprops(struct ath_hal *hal, int queue,
    const HAL_TXQ_INFO *queue_info)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	if (hal->ah_txq[queue].tqi_type == HAL_TX_QUEUE_INACTIVE)
		return (AH_FALSE);

	bcopy(queue_info, &hal->ah_txq[queue], sizeof(HAL_TXQ_INFO));

	if (queue_info->tqi_type == HAL_TX_QUEUE_DATA &&
	    (queue_info->tqi_subtype >= HAL_WME_AC_VI) &&
	    (queue_info->tqi_subtype <= HAL_WME_UPSD))
		hal->ah_txq[queue].tqi_flags |=
		    AR5K_TXQ_FLAG_POST_FR_BKOFF_DIS;

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_get_tx_queueprops(struct ath_hal *hal, int queue,
    HAL_TXQ_INFO *queue_info)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);
	bcopy(&hal->ah_txq[queue], queue_info, sizeof(HAL_TXQ_INFO));
	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_release_tx_queue(struct ath_hal *hal, u_int queue)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	/* This queue will be skipped in further operations */
	hal->ah_txq[queue].tqi_type = HAL_TX_QUEUE_INACTIVE;
	AR5K_Q_DISABLE_BITS(hal->ah_txq_interrupts, queue);

	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5211_reset_tx_queue(struct ath_hal *hal, u_int queue)
{
	u_int32_t cw_min, cw_max, retry_lg, retry_sh;
	struct ieee80211_channel *channel = (struct ieee80211_channel*)
	    &hal->ah_current_channel;
	HAL_TXQ_INFO *tq;

	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	tq = &hal->ah_txq[queue];

	if (tq->tqi_type == HAL_TX_QUEUE_INACTIVE)
		return (AH_TRUE);

	/*
	 * Set registers by channel mode
	 */
	if (IEEE80211_IS_CHAN_B(channel)) {
		hal->ah_cw_min = AR5K_TUNE_CWMIN_11B;
		cw_max = hal->ah_cw_max = AR5K_TUNE_CWMAX_11B;
		hal->ah_aifs = AR5K_TUNE_AIFS_11B;
	} else {
		hal->ah_cw_min = AR5K_TUNE_CWMIN;
		cw_max = hal->ah_cw_max = AR5K_TUNE_CWMAX;
		hal->ah_aifs = AR5K_TUNE_AIFS;
	}

	/*
	 * Set retry limits
	 */
	if (hal->ah_software_retry == AH_TRUE) {
		/* XXX Need to test this */
		retry_lg = hal->ah_limit_tx_retries;
		retry_sh = retry_lg =
		    retry_lg > AR5K_AR5211_DCU_RETRY_LMT_SH_RETRY ?
		    AR5K_AR5211_DCU_RETRY_LMT_SH_RETRY : retry_lg;
	} else {
		retry_lg = AR5K_INIT_LG_RETRY;
		retry_sh = AR5K_INIT_SH_RETRY;
	}

	AR5K_REG_WRITE(AR5K_AR5211_DCU_RETRY_LMT(queue),
	    AR5K_REG_SM(AR5K_INIT_SLG_RETRY,
	    AR5K_AR5211_DCU_RETRY_LMT_SLG_RETRY) |
	    AR5K_REG_SM(AR5K_INIT_SSH_RETRY,
	    AR5K_AR5211_DCU_RETRY_LMT_SSH_RETRY) |
	    AR5K_REG_SM(retry_lg, AR5K_AR5211_DCU_RETRY_LMT_LG_RETRY) |
	    AR5K_REG_SM(retry_sh, AR5K_AR5211_DCU_RETRY_LMT_SH_RETRY));

	/*
	 * Set initial content window (cw_min/cw_max)
	 */
	cw_min = 1;
	while (cw_min < hal->ah_cw_min)
		cw_min = (cw_min << 1) | 1;

	cw_min = tq->tqi_cw_min < 0 ?
	    (cw_min >> (-tq->tqi_cw_min)) :
	    ((cw_min << tq->tqi_cw_min) + (1 << tq->tqi_cw_min) - 1);
	cw_max = tq->tqi_cw_max < 0 ?
	    (cw_max >> (-tq->tqi_cw_max)) :
	    ((cw_max << tq->tqi_cw_max) + (1 << tq->tqi_cw_max) - 1);

	AR5K_REG_WRITE(AR5K_AR5211_DCU_LCL_IFS(queue),
	    AR5K_REG_SM(cw_min, AR5K_AR5211_DCU_LCL_IFS_CW_MIN) |
	    AR5K_REG_SM(cw_max, AR5K_AR5211_DCU_LCL_IFS_CW_MAX) |
	    AR5K_REG_SM(hal->ah_aifs + tq->tqi_aifs,
	    AR5K_AR5211_DCU_LCL_IFS_AIFS));

	/*
	 * Set misc registers
	 */
	AR5K_REG_WRITE(AR5K_AR5211_QCU_MISC(queue),
	    AR5K_AR5211_QCU_MISC_DCU_EARLY);

	if (tq->tqi_cbr_period) {
		AR5K_REG_WRITE(AR5K_AR5211_QCU_CBRCFG(queue),
		    AR5K_REG_SM(tq->tqi_cbr_period,
		    AR5K_AR5211_QCU_CBRCFG_INTVAL) |
		    AR5K_REG_SM(tq->tqi_cbr_overflow_limit,
		    AR5K_AR5211_QCU_CBRCFG_ORN_THRES));
		AR5K_REG_ENABLE_BITS(AR5K_AR5211_QCU_MISC(queue),
		    AR5K_AR5211_QCU_MISC_FRSHED_CBR);
		if (tq->tqi_cbr_overflow_limit)
			AR5K_REG_ENABLE_BITS(AR5K_AR5211_QCU_MISC(queue),
			    AR5K_AR5211_QCU_MISC_CBR_THRES_ENABLE);
	}

	if (tq->tqi_ready_time) {
		AR5K_REG_WRITE(AR5K_AR5211_QCU_RDYTIMECFG(queue),
		    AR5K_REG_SM(tq->tqi_ready_time,
		    AR5K_AR5211_QCU_RDYTIMECFG_INTVAL) |
		    AR5K_AR5211_QCU_RDYTIMECFG_ENABLE);
	}

	if (tq->tqi_burst_time) {
		AR5K_REG_WRITE(AR5K_AR5211_DCU_CHAN_TIME(queue),
		    AR5K_REG_SM(tq->tqi_burst_time,
		    AR5K_AR5211_DCU_CHAN_TIME_DUR) |
		    AR5K_AR5211_DCU_CHAN_TIME_ENABLE);

		if (tq->tqi_flags & AR5K_TXQ_FLAG_RDYTIME_EXP_POLICY_ENABLE) {
			AR5K_REG_ENABLE_BITS(AR5K_AR5211_QCU_MISC(queue),
			    AR5K_AR5211_QCU_MISC_TXE);
		}
	}

	if (tq->tqi_flags & AR5K_TXQ_FLAG_BACKOFF_DISABLE) {
		AR5K_REG_WRITE(AR5K_AR5211_DCU_MISC(queue),
		    AR5K_AR5211_DCU_MISC_POST_FR_BKOFF_DIS);
	}

	if (tq->tqi_flags & AR5K_TXQ_FLAG_FRAG_BURST_BACKOFF_ENABLE) {
		AR5K_REG_WRITE(AR5K_AR5211_DCU_MISC(queue),
		    AR5K_AR5211_DCU_MISC_BACKOFF_FRAG);
	}

	/*
	 * Set registers by queue type
	 */
	switch (tq->tqi_type) {
	case HAL_TX_QUEUE_BEACON:
		AR5K_REG_ENABLE_BITS(AR5K_AR5211_QCU_MISC(queue),
		    AR5K_AR5211_QCU_MISC_FRSHED_DBA_GT |
		    AR5K_AR5211_QCU_MISC_CBREXP_BCN |
		    AR5K_AR5211_QCU_MISC_BCN_ENABLE);

		AR5K_REG_ENABLE_BITS(AR5K_AR5211_DCU_MISC(queue),
		    (AR5K_AR5211_DCU_MISC_ARBLOCK_CTL_GLOBAL <<
		    AR5K_AR5211_DCU_MISC_ARBLOCK_CTL_GLOBAL) |
		    AR5K_AR5211_DCU_MISC_POST_FR_BKOFF_DIS |
		    AR5K_AR5211_DCU_MISC_BCN_ENABLE);

		AR5K_REG_WRITE(AR5K_AR5211_QCU_RDYTIMECFG(queue),
		    ((AR5K_TUNE_BEACON_INTERVAL -
		    (AR5K_TUNE_SW_BEACON_RESP - AR5K_TUNE_DMA_BEACON_RESP) -
		    AR5K_TUNE_ADDITIONAL_SWBA_BACKOFF) * 1024) |
		    AR5K_AR5211_QCU_RDYTIMECFG_ENABLE);
		break;

	case HAL_TX_QUEUE_CAB:
		AR5K_REG_ENABLE_BITS(AR5K_AR5211_QCU_MISC(queue),
		    AR5K_AR5211_QCU_MISC_FRSHED_DBA_GT |
		    AR5K_AR5211_QCU_MISC_CBREXP |
		    AR5K_AR5211_QCU_MISC_CBREXP_BCN);

		AR5K_REG_ENABLE_BITS(AR5K_AR5211_DCU_MISC(queue),
		    (AR5K_AR5211_DCU_MISC_ARBLOCK_CTL_GLOBAL <<
		    AR5K_AR5211_DCU_MISC_ARBLOCK_CTL_GLOBAL));
		break;

	case HAL_TX_QUEUE_PSPOLL:
		AR5K_REG_ENABLE_BITS(AR5K_AR5211_QCU_MISC(queue),
		    AR5K_AR5211_QCU_MISC_CBREXP);
		break;

	case HAL_TX_QUEUE_DATA:
	default:
		break;
	}

	/*
	 * Enable tx queue in the secondary interrupt mask registers
	 */
	AR5K_REG_WRITE(AR5K_AR5211_SIMR0,
	    AR5K_REG_SM(hal->ah_txq_interrupts, AR5K_AR5211_SIMR0_QCU_TXOK) |
	    AR5K_REG_SM(hal->ah_txq_interrupts, AR5K_AR5211_SIMR0_QCU_TXDESC));
	AR5K_REG_WRITE(AR5K_AR5211_SIMR1,
	    AR5K_REG_SM(hal->ah_txq_interrupts, AR5K_AR5211_SIMR1_QCU_TXERR));
	AR5K_REG_WRITE(AR5K_AR5211_SIMR2,
	    AR5K_REG_SM(hal->ah_txq_interrupts, AR5K_AR5211_SIMR2_QCU_TXURN));

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5211_get_tx_buf(struct ath_hal *hal, u_int queue)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	/*
	 * Get the transmit queue descriptor pointer from the selected queue
	 */
	return (AR5K_REG_READ(AR5K_AR5211_QCU_TXDP(queue)));
}

HAL_BOOL
ar5k_ar5211_put_tx_buf(struct ath_hal *hal, u_int queue, u_int32_t phys_addr)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	/*
	 * Set the transmit queue descriptor pointer for the selected queue
	 * (this won't work if the queue is still active)
	 */
	if (AR5K_REG_READ_Q(AR5K_AR5211_QCU_TXE, queue))
		return (AH_FALSE);

	AR5K_REG_WRITE(AR5K_AR5211_QCU_TXDP(queue), phys_addr);

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5211_num_tx_pending(struct ath_hal *hal, u_int queue)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);
	return (AR5K_AR5211_QCU_STS(queue) & AR5K_AR5211_QCU_STS_FRMPENDCNT);
}

HAL_BOOL
ar5k_ar5211_tx_start(struct ath_hal *hal, u_int queue)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	/* Return if queue is disabled */
	if (AR5K_REG_READ_Q(AR5K_AR5211_QCU_TXD, queue))
		return (AH_FALSE);

	/* Start queue */
	AR5K_REG_WRITE_Q(AR5K_AR5211_QCU_TXE, queue);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_stop_tx_dma(struct ath_hal *hal, u_int queue)
{
	int i = 100, pending;

	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	/*
	 * Schedule TX disable and wait until queue is empty
	 */
	AR5K_REG_WRITE_Q(AR5K_AR5211_QCU_TXD, queue);

	do {
		pending = AR5K_REG_READ(AR5K_AR5211_QCU_STS(queue)) &
		     AR5K_AR5211_QCU_STS_FRMPENDCNT;
		delay(100);
	} while (--i && pending);

	/* Clear register */
	AR5K_REG_WRITE(AR5K_AR5211_QCU_TXD, 0);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_setup_tx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int packet_length, u_int header_length, HAL_PKT_TYPE type, u_int tx_power,
    u_int tx_rate0, u_int tx_tries0, u_int key_index, u_int antenna_mode,
    u_int flags, u_int rtscts_rate, u_int rtscts_duration)
{
	struct ar5k_ar5211_tx_desc *tx_desc;

	tx_desc = (struct ar5k_ar5211_tx_desc*)&desc->ds_ctl0;

	/*
	 * Validate input
	 */
	if (tx_tries0 == 0)
		return (AH_FALSE);

	if ((tx_desc->tx_control_0 = (packet_length &
	    AR5K_AR5211_DESC_TX_CTL0_FRAME_LEN)) != packet_length)
		return (AH_FALSE);

	tx_desc->tx_control_0 |=
	    AR5K_REG_SM(tx_rate0, AR5K_AR5211_DESC_TX_CTL0_XMIT_RATE) |
	    AR5K_REG_SM(antenna_mode, AR5K_AR5211_DESC_TX_CTL0_ANT_MODE_XMIT);
	tx_desc->tx_control_1 =
	    AR5K_REG_SM(type, AR5K_AR5211_DESC_TX_CTL1_FRAME_TYPE);

#define _TX_FLAGS(_c, _flag)						\
	if (flags & HAL_TXDESC_##_flag)					\
		tx_desc->tx_control_##_c |=				\
			AR5K_AR5211_DESC_TX_CTL##_c##_##_flag

	_TX_FLAGS(0, CLRDMASK);
	_TX_FLAGS(0, VEOL);
	_TX_FLAGS(0, INTREQ);
	_TX_FLAGS(0, RTSENA);
	_TX_FLAGS(1, NOACK);

#undef _TX_FLAGS

	/*
	 * WEP crap
	 */
	if (key_index != HAL_TXKEYIX_INVALID) {
		tx_desc->tx_control_0 |=
		    AR5K_AR5211_DESC_TX_CTL0_ENCRYPT_KEY_VALID;
		tx_desc->tx_control_1 |=
		    AR5K_REG_SM(key_index,
		    AR5K_AR5211_DESC_TX_CTL1_ENCRYPT_KEY_INDEX);
	}

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_fill_tx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int segment_length, HAL_BOOL first_segment, HAL_BOOL last_segment)
{
	struct ar5k_ar5211_tx_desc *tx_desc;

	tx_desc = (struct ar5k_ar5211_tx_desc*)&desc->ds_ctl0;

	/* Clear status descriptor */
	bzero(desc->ds_hw, sizeof(desc->ds_hw));

	/* Validate segment length and initialize the descriptor */
	if (segment_length & ~AR5K_AR5211_DESC_TX_CTL1_BUF_LEN)
		return (AH_FALSE);
	tx_desc->tx_control_1 =
#if 0
	    (tx_desc->tx_control_1 & ~AR5K_AR5211_DESC_TX_CTL1_BUF_LEN) |
#endif
	    segment_length;

	if (first_segment != AH_TRUE)
		tx_desc->tx_control_0 &= ~AR5K_AR5211_DESC_TX_CTL0_FRAME_LEN;

	if (last_segment != AH_TRUE)
		tx_desc->tx_control_1 |= AR5K_AR5211_DESC_TX_CTL1_MORE;

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_setup_xtx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int tx_rate1, u_int tx_tries1, u_int tx_rate2, u_int tx_tries2,
    u_int tx_rate3, u_int tx_tries3)
{
	return (AH_FALSE);
}

HAL_STATUS
ar5k_ar5211_proc_tx_desc(struct ath_hal *hal, struct ath_desc *desc)
{
	struct ar5k_ar5211_tx_status *tx_status;
	struct ar5k_ar5211_tx_desc *tx_desc;

	tx_desc = (struct ar5k_ar5211_tx_desc*)&desc->ds_ctl0;
	tx_status = (struct ar5k_ar5211_tx_status*)&desc->ds_hw[0];

	/* No frame has been send or error */
	if ((tx_status->tx_status_1 & AR5K_AR5211_DESC_TX_STATUS1_DONE) == 0)
		return (HAL_EINPROGRESS);

	/*
	 * Get descriptor status
	 */
	desc->ds_us.tx.ts_tstamp =
	    AR5K_REG_MS(tx_status->tx_status_0,
	    AR5K_AR5211_DESC_TX_STATUS0_SEND_TIMESTAMP);
	desc->ds_us.tx.ts_shortretry =
	    AR5K_REG_MS(tx_status->tx_status_0,
	    AR5K_AR5211_DESC_TX_STATUS0_RTS_FAIL_COUNT);
	desc->ds_us.tx.ts_longretry =
	    AR5K_REG_MS(tx_status->tx_status_0,
	    AR5K_AR5211_DESC_TX_STATUS0_DATA_FAIL_COUNT);
	desc->ds_us.tx.ts_seqnum =
	    AR5K_REG_MS(tx_status->tx_status_1,
	    AR5K_AR5211_DESC_TX_STATUS1_SEQ_NUM);
	desc->ds_us.tx.ts_rssi =
	    AR5K_REG_MS(tx_status->tx_status_1,
	    AR5K_AR5211_DESC_TX_STATUS1_ACK_SIG_STRENGTH);
	desc->ds_us.tx.ts_antenna = 1;
	desc->ds_us.tx.ts_status = 0;
	desc->ds_us.tx.ts_rate =
	    AR5K_REG_MS(tx_desc->tx_control_0,
	    AR5K_AR5211_DESC_TX_CTL0_XMIT_RATE);

	if ((tx_status->tx_status_0 &
	    AR5K_AR5211_DESC_TX_STATUS0_FRAME_XMIT_OK) == 0) {
		if (tx_status->tx_status_0 &
		    AR5K_AR5211_DESC_TX_STATUS0_EXCESSIVE_RETRIES)
			desc->ds_us.tx.ts_status |= HAL_TXERR_XRETRY;

		if (tx_status->tx_status_0 &
		    AR5K_AR5211_DESC_TX_STATUS0_FIFO_UNDERRUN)
			desc->ds_us.tx.ts_status |= HAL_TXERR_FIFO;

		if (tx_status->tx_status_0 &
		    AR5K_AR5211_DESC_TX_STATUS0_FILTERED)
			desc->ds_us.tx.ts_status |= HAL_TXERR_FILT;
	}

	return (HAL_OK);
}

HAL_BOOL
ar5k_ar5211_has_veol(struct ath_hal *hal)
{
	return (AH_TRUE);
}

/*
 * Receive functions
 */

u_int32_t
ar5k_ar5211_get_rx_buf(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5211_RXDP));
}

void
ar5k_ar5211_put_rx_buf(struct ath_hal *hal, u_int32_t phys_addr)
{
	AR5K_REG_WRITE(AR5K_AR5211_RXDP, phys_addr);
}

void
ar5k_ar5211_start_rx(struct ath_hal *hal)
{
	AR5K_REG_WRITE(AR5K_AR5211_CR, AR5K_AR5211_CR_RXE);
}

HAL_BOOL
ar5k_ar5211_stop_rx_dma(struct ath_hal *hal)
{
	int i;

	AR5K_REG_WRITE(AR5K_AR5211_CR, AR5K_AR5211_CR_RXD);

	/*
	 * It may take some time to disable the DMA receive unit
	 */
	for (i = 2000;
	     i > 0 && (AR5K_REG_READ(AR5K_AR5211_CR) & AR5K_AR5211_CR_RXE) != 0;
	     i--)
		AR5K_DELAY(10);

	return (i > 0 ? AH_TRUE : AH_FALSE);
}

void
ar5k_ar5211_start_rx_pcu(struct ath_hal *hal)
{
	AR5K_REG_DISABLE_BITS(AR5K_AR5211_DIAG_SW, AR5K_AR5211_DIAG_SW_DIS_RX);
}

void
ar5k_ar5211_stop_pcu_recv(struct ath_hal *hal)
{
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_DIAG_SW, AR5K_AR5211_DIAG_SW_DIS_RX);
}

void
ar5k_ar5211_set_mcast_filter(struct ath_hal *hal, u_int32_t filter0,
    u_int32_t filter1)
{
	/* Set the multicat filter */
	AR5K_REG_WRITE(AR5K_AR5211_MCAST_FIL0, filter0);
	AR5K_REG_WRITE(AR5K_AR5211_MCAST_FIL1, filter1);
}

HAL_BOOL
ar5k_ar5211_set_mcast_filterindex(struct ath_hal *hal, u_int32_t index)
{
	if (index >= 64) {
	    return (AH_FALSE);
	} else if (index >= 32) {
	    AR5K_REG_ENABLE_BITS(AR5K_AR5211_MCAST_FIL1,
		(1 << (index - 32)));
	} else {
	    AR5K_REG_ENABLE_BITS(AR5K_AR5211_MCAST_FIL0,
		(1 << index));
	}

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_clear_mcast_filter_idx(struct ath_hal *hal, u_int32_t index)
{

	if (index >= 64) {
	    return (AH_FALSE);
	} else if (index >= 32) {
	    AR5K_REG_DISABLE_BITS(AR5K_AR5211_MCAST_FIL1,
		(1 << (index - 32)));
	} else {
	    AR5K_REG_DISABLE_BITS(AR5K_AR5211_MCAST_FIL0,
		(1 << index));
	}

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5211_get_rx_filter(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5211_RX_FILTER));
}

void
ar5k_ar5211_set_rx_filter(struct ath_hal *hal, u_int32_t filter)
{
	AR5K_REG_WRITE(AR5K_AR5211_RX_FILTER, filter);
}

HAL_BOOL
ar5k_ar5211_setup_rx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int32_t size, u_int flags)
{
	struct ar5k_ar5211_rx_desc *rx_desc;

	rx_desc = (struct ar5k_ar5211_rx_desc*)&desc->ds_ctl0;

	if ((rx_desc->rx_control_1 = (size &
	    AR5K_AR5211_DESC_RX_CTL1_BUF_LEN)) != size)
		return (AH_FALSE);

	if (flags & HAL_RXDESC_INTREQ)
		rx_desc->rx_control_1 |= AR5K_AR5211_DESC_RX_CTL1_INTREQ;

	return (AH_TRUE);
}

HAL_STATUS
ar5k_ar5211_proc_rx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int32_t phys_addr, struct ath_desc *next)
{
	struct ar5k_ar5211_rx_status *rx_status;

	rx_status = (struct ar5k_ar5211_rx_status*)&desc->ds_hw[0];

	/* No frame received / not ready */
	if ((rx_status->rx_status_1 & AR5K_AR5211_DESC_RX_STATUS1_DONE) == 0)
		return (HAL_EINPROGRESS);

	/*
	 * Frame receive status
	 */
	desc->ds_us.rx.rs_datalen = rx_status->rx_status_0 &
	    AR5K_AR5211_DESC_RX_STATUS0_DATA_LEN;
	desc->ds_us.rx.rs_rssi =
	    AR5K_REG_MS(rx_status->rx_status_0,
	    AR5K_AR5211_DESC_RX_STATUS0_RECEIVE_SIGNAL);
	desc->ds_us.rx.rs_rate =
	    AR5K_REG_MS(rx_status->rx_status_0,
	    AR5K_AR5211_DESC_RX_STATUS0_RECEIVE_RATE);
	desc->ds_us.rx.rs_antenna = rx_status->rx_status_0 &
	    AR5K_AR5211_DESC_RX_STATUS0_RECEIVE_ANTENNA;
	desc->ds_us.rx.rs_more = rx_status->rx_status_0 &
	    AR5K_AR5211_DESC_RX_STATUS0_MORE;
	desc->ds_us.rx.rs_tstamp =
	    AR5K_REG_MS(rx_status->rx_status_1,
	    AR5K_AR5211_DESC_RX_STATUS1_RECEIVE_TIMESTAMP);
	desc->ds_us.rx.rs_status = 0;

	/*
	 * Key table status
	 */
	if (rx_status->rx_status_1 &
	    AR5K_AR5211_DESC_RX_STATUS1_KEY_INDEX_VALID) {
		desc->ds_us.rx.rs_keyix =
		    AR5K_REG_MS(rx_status->rx_status_1,
		    AR5K_AR5211_DESC_RX_STATUS1_KEY_INDEX);
	} else {
		desc->ds_us.rx.rs_keyix = HAL_RXKEYIX_INVALID;
	}

	/*
	 * Receive/descriptor errors
	 */
	if ((rx_status->rx_status_1 &
	    AR5K_AR5211_DESC_RX_STATUS1_FRAME_RECEIVE_OK) == 0) {
		if (rx_status->rx_status_1 &
		    AR5K_AR5211_DESC_RX_STATUS1_CRC_ERROR)
			desc->ds_us.rx.rs_status |= HAL_RXERR_CRC;

		if (rx_status->rx_status_1 &
		    AR5K_AR5211_DESC_RX_STATUS1_PHY_ERROR) {
			desc->ds_us.rx.rs_status |= HAL_RXERR_PHY;
			desc->ds_us.rx.rs_phyerr =
			    AR5K_REG_MS(rx_status->rx_status_1,
			    AR5K_AR5211_DESC_RX_STATUS1_PHY_ERROR);
		}

		if (rx_status->rx_status_1 &
		    AR5K_AR5211_DESC_RX_STATUS1_DECRYPT_CRC_ERROR)
			desc->ds_us.rx.rs_status |= HAL_RXERR_DECRYPT;
	}

	return (HAL_OK);
}

void
ar5k_ar5211_set_rx_signal(struct ath_hal *hal)
{
	/* Signal state monitoring is not yet supported */
}

/*
 * Misc functions
 */

void
ar5k_ar5211_dump_state(struct ath_hal *hal)
{
#ifdef AR5K_DEBUG
#define AR5K_PRINT_REGISTER(_x)						\
	printf("(%s: %08x) ", #_x, AR5K_REG_READ(AR5K_AR5211_##_x));

	printf("MAC registers:\n");
	AR5K_PRINT_REGISTER(CR);
	AR5K_PRINT_REGISTER(CFG);
	AR5K_PRINT_REGISTER(IER);
	AR5K_PRINT_REGISTER(RTSD0);
	AR5K_PRINT_REGISTER(TXCFG);
	AR5K_PRINT_REGISTER(RXCFG);
	AR5K_PRINT_REGISTER(RXJLA);
	AR5K_PRINT_REGISTER(MIBC);
	AR5K_PRINT_REGISTER(TOPS);
	AR5K_PRINT_REGISTER(RXNOFRM);
	AR5K_PRINT_REGISTER(RPGTO);
	AR5K_PRINT_REGISTER(RFCNT);
	AR5K_PRINT_REGISTER(MISC);
	AR5K_PRINT_REGISTER(PISR);
	AR5K_PRINT_REGISTER(SISR0);
	AR5K_PRINT_REGISTER(SISR1);
	AR5K_PRINT_REGISTER(SISR3);
	AR5K_PRINT_REGISTER(SISR4);
	AR5K_PRINT_REGISTER(QCU_TXE);
	AR5K_PRINT_REGISTER(QCU_TXD);
	AR5K_PRINT_REGISTER(DCU_GBL_IFS_SIFS);
	AR5K_PRINT_REGISTER(DCU_GBL_IFS_SLOT);
	AR5K_PRINT_REGISTER(DCU_FP);
	AR5K_PRINT_REGISTER(DCU_TXP);
	AR5K_PRINT_REGISTER(DCU_TX_FILTER);
	AR5K_PRINT_REGISTER(RC);
	AR5K_PRINT_REGISTER(SCR);
	AR5K_PRINT_REGISTER(INTPEND);
	AR5K_PRINT_REGISTER(PCICFG);
	AR5K_PRINT_REGISTER(GPIOCR);
	AR5K_PRINT_REGISTER(GPIODO);
	AR5K_PRINT_REGISTER(SREV);
	AR5K_PRINT_REGISTER(EEPROM_BASE);
	AR5K_PRINT_REGISTER(EEPROM_DATA);
	AR5K_PRINT_REGISTER(EEPROM_CMD);
	AR5K_PRINT_REGISTER(EEPROM_CFG);
	AR5K_PRINT_REGISTER(PCU_MIN);
	AR5K_PRINT_REGISTER(STA_ID0);
	AR5K_PRINT_REGISTER(STA_ID1);
	AR5K_PRINT_REGISTER(BSS_ID0);
	AR5K_PRINT_REGISTER(SLOT_TIME);
	AR5K_PRINT_REGISTER(TIME_OUT);
	AR5K_PRINT_REGISTER(RSSI_THR);
	AR5K_PRINT_REGISTER(BEACON);
	AR5K_PRINT_REGISTER(CFP_PERIOD);
	AR5K_PRINT_REGISTER(TIMER0);
	AR5K_PRINT_REGISTER(TIMER2);
	AR5K_PRINT_REGISTER(TIMER3);
	AR5K_PRINT_REGISTER(CFP_DUR);
	AR5K_PRINT_REGISTER(MCAST_FIL0);
	AR5K_PRINT_REGISTER(MCAST_FIL1);
	AR5K_PRINT_REGISTER(DIAG_SW);
	AR5K_PRINT_REGISTER(TSF_U32);
	AR5K_PRINT_REGISTER(ADDAC_TEST);
	AR5K_PRINT_REGISTER(DEFAULT_ANTENNA);
	AR5K_PRINT_REGISTER(LAST_TSTP);
	AR5K_PRINT_REGISTER(NAV);
	AR5K_PRINT_REGISTER(RTS_OK);
	AR5K_PRINT_REGISTER(ACK_FAIL);
	AR5K_PRINT_REGISTER(FCS_FAIL);
	AR5K_PRINT_REGISTER(BEACON_CNT);
	AR5K_PRINT_REGISTER(KEYTABLE_0);
	printf("\n");

	printf("PHY registers:\n");
	AR5K_PRINT_REGISTER(PHY_TURBO);
	AR5K_PRINT_REGISTER(PHY_AGC);
	AR5K_PRINT_REGISTER(PHY_CHIP_ID);
	AR5K_PRINT_REGISTER(PHY_AGCCTL);
	AR5K_PRINT_REGISTER(PHY_NF);
	AR5K_PRINT_REGISTER(PHY_RX_DELAY);
	AR5K_PRINT_REGISTER(PHY_IQ);
	AR5K_PRINT_REGISTER(PHY_PAPD_PROBE);
	AR5K_PRINT_REGISTER(PHY_FC);
	AR5K_PRINT_REGISTER(PHY_RADAR);
	AR5K_PRINT_REGISTER(PHY_ANT_SWITCH_TABLE_0);
	AR5K_PRINT_REGISTER(PHY_ANT_SWITCH_TABLE_1);
	printf("\n");
#endif
}

HAL_BOOL
ar5k_ar5211_get_diag_state(struct ath_hal *hal, int id, void **device,
    u_int *size)
{
	/*
	 * We'll ignore this right now. This seems to be some kind of an obscure
	 * debugging interface for the binary-only HAL.
	 */
	return (AH_FALSE);
}

void
ar5k_ar5211_get_lladdr(struct ath_hal *hal, u_int8_t *mac)
{
	bcopy(hal->ah_sta_id, mac, IEEE80211_ADDR_LEN);
}

HAL_BOOL
ar5k_ar5211_set_lladdr(struct ath_hal *hal, const u_int8_t *mac)
{
	u_int32_t low_id, high_id;

	/* Set new station ID */
	bcopy(mac, hal->ah_sta_id, IEEE80211_ADDR_LEN);

	low_id = AR5K_LOW_ID(mac);
	high_id = 0x0000ffff & AR5K_HIGH_ID(mac);

	AR5K_REG_WRITE(AR5K_AR5211_STA_ID0, low_id);
	AR5K_REG_WRITE(AR5K_AR5211_STA_ID1, high_id);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_set_regdomain(struct ath_hal *hal, u_int16_t regdomain,
    HAL_STATUS *status)
{
	ieee80211_regdomain_t ieee_regdomain;

	ieee_regdomain = ar5k_regdomain_to_ieee(regdomain);

	if (ar5k_eeprom_regulation_domain(hal, AH_TRUE,
		&ieee_regdomain) == AH_TRUE) {
		*status = HAL_OK;
		return (AH_TRUE);
	}

	*status = EIO;

	return (AH_FALSE);
}

void
ar5k_ar5211_set_ledstate(struct ath_hal *hal, HAL_LED_STATE state)
{
	u_int32_t led;

	AR5K_REG_DISABLE_BITS(AR5K_AR5211_PCICFG,
	    AR5K_AR5211_PCICFG_LEDMODE |  AR5K_AR5211_PCICFG_LED);

	/*
	 * Some blinking values, define at your wish
	 */
	switch (state) {
	case IEEE80211_S_SCAN:
	case IEEE80211_S_AUTH:
		led = AR5K_AR5211_PCICFG_LEDMODE_PROP |
		    AR5K_AR5211_PCICFG_LED_PEND;
		break;

	case IEEE80211_S_INIT:
		led = AR5K_AR5211_PCICFG_LEDMODE_PROP |
		    AR5K_AR5211_PCICFG_LED_NONE;
		break;

	case IEEE80211_S_ASSOC:
	case IEEE80211_S_RUN:
		led = AR5K_AR5211_PCICFG_LEDMODE_PROP |
		    AR5K_AR5211_PCICFG_LED_ASSOC;
		break;

	default:
		led = AR5K_AR5211_PCICFG_LEDMODE_PROM |
		    AR5K_AR5211_PCICFG_LED_NONE;
		break;
	}

	AR5K_REG_ENABLE_BITS(AR5K_AR5211_PCICFG, led);
}

void
ar5k_ar5211_set_associd(struct ath_hal *hal, const u_int8_t *bssid,
    u_int16_t assoc_id, u_int16_t tim_offset)
{
	u_int32_t low_id, high_id;

	/*
	 * Set BSSID which triggers the "SME Join" operation
	 */
	low_id = AR5K_LOW_ID(bssid);
	high_id = AR5K_HIGH_ID(bssid);
	AR5K_REG_WRITE(AR5K_AR5211_BSS_ID0, low_id);
	AR5K_REG_WRITE(AR5K_AR5211_BSS_ID1, high_id |
	    ((assoc_id & 0x3fff) << AR5K_AR5211_BSS_ID1_AID_S));
	bcopy(bssid, hal->ah_bssid, IEEE80211_ADDR_LEN);

	if (assoc_id == 0) {
		ar5k_ar5211_disable_pspoll(hal);
		return;
	}

	AR5K_REG_WRITE(AR5K_AR5211_BEACON,
	    (AR5K_REG_READ(AR5K_AR5211_BEACON) &
	    ~AR5K_AR5211_BEACON_TIM) |
	    (((tim_offset ? tim_offset + 4 : 0) <<
	    AR5K_AR5211_BEACON_TIM_S) &
	    AR5K_AR5211_BEACON_TIM));

	ar5k_ar5211_enable_pspoll(hal, NULL, 0);
}

HAL_BOOL
ar5k_ar5211_set_bssid_mask(struct ath_hal *hal, const u_int8_t* mask)
{
	/* Not supported in 5211 */
	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5211_set_gpio_output(struct ath_hal *hal, u_int32_t gpio)
{
	if (gpio > AR5K_AR5211_NUM_GPIO)
		return (AH_FALSE);

	AR5K_REG_WRITE(AR5K_AR5211_GPIOCR,
	    (AR5K_REG_READ(AR5K_AR5211_GPIOCR) &~ AR5K_AR5211_GPIOCR_ALL(gpio))
	    | AR5K_AR5211_GPIOCR_ALL(gpio));

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_set_gpio_input(struct ath_hal *hal, u_int32_t gpio)
{
	if (gpio > AR5K_AR5211_NUM_GPIO)
		return (AH_FALSE);

	AR5K_REG_WRITE(AR5K_AR5211_GPIOCR,
	    (AR5K_REG_READ(AR5K_AR5211_GPIOCR) &~ AR5K_AR5211_GPIOCR_ALL(gpio))
	    | AR5K_AR5211_GPIOCR_NONE(gpio));

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5211_get_gpio(struct ath_hal *hal, u_int32_t gpio)
{
	if (gpio > AR5K_AR5211_NUM_GPIO)
		return (0xffffffff);

	/* GPIO input magic */
	return (((AR5K_REG_READ(AR5K_AR5211_GPIODI) &
	    AR5K_AR5211_GPIODI_M) >> gpio) & 0x1);
}

HAL_BOOL
ar5k_ar5211_set_gpio(struct ath_hal *hal, u_int32_t gpio, u_int32_t val)
{
	u_int32_t data;

	if (gpio > AR5K_AR5211_NUM_GPIO)
		return (0xffffffff);

	/* GPIO output magic */
	data =  AR5K_REG_READ(AR5K_AR5211_GPIODO);

	data &= ~(1 << gpio);
	data |= (val&1) << gpio;

	AR5K_REG_WRITE(AR5K_AR5211_GPIODO, data);

	return (AH_TRUE);
}

void
ar5k_ar5211_set_gpio_intr(struct ath_hal *hal, u_int gpio,
    u_int32_t interrupt_level)
{
	u_int32_t data;

	if (gpio > AR5K_AR5211_NUM_GPIO)
		return;

	/*
	 * Set the GPIO interrupt
	 */
	data = (AR5K_REG_READ(AR5K_AR5211_GPIOCR) &
	    ~(AR5K_AR5211_GPIOCR_INT_SEL(gpio) | AR5K_AR5211_GPIOCR_INT_SELH |
	    AR5K_AR5211_GPIOCR_INT_ENA | AR5K_AR5211_GPIOCR_ALL(gpio))) |
	    (AR5K_AR5211_GPIOCR_INT_SEL(gpio) | AR5K_AR5211_GPIOCR_INT_ENA);

	AR5K_REG_WRITE(AR5K_AR5211_GPIOCR,
	    interrupt_level ? data : (data | AR5K_AR5211_GPIOCR_INT_SELH));

	hal->ah_imr |= AR5K_AR5211_PIMR_GPIO;

	/* Enable GPIO interrupts */
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_PIMR, AR5K_AR5211_PIMR_GPIO);
}

u_int32_t
ar5k_ar5211_get_tsf32(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5211_TSF_L32));
}

u_int64_t
ar5k_ar5211_get_tsf64(struct ath_hal *hal)
{
	u_int64_t tsf = AR5K_REG_READ(AR5K_AR5211_TSF_U32);

	return (AR5K_REG_READ(AR5K_AR5211_TSF_L32) | (tsf << 32));
}

void
ar5k_ar5211_reset_tsf(struct ath_hal *hal)
{
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_BEACON,
	    AR5K_AR5211_BEACON_RESET_TSF);
}

u_int16_t
ar5k_ar5211_get_regdomain(struct ath_hal *hal)
{
	return (ar5k_get_regdomain(hal));
}

HAL_BOOL
ar5k_ar5211_detect_card_present(struct ath_hal *hal)
{
	u_int16_t magic;

	/*
	 * Checking the EEPROM's magic value could be an indication
	 * if the card is still present. I didn't find another suitable
	 * way to do this.
	 */
	if (ar5k_ar5211_eeprom_read(hal, AR5K_EEPROM_MAGIC, &magic) != 0)
		return (AH_FALSE);

	return (magic == AR5K_EEPROM_MAGIC_VALUE ? AH_TRUE : AH_FALSE);
}

void
ar5k_ar5211_update_mib_counters(struct ath_hal *hal, HAL_MIB_STATS *statistics)
{
	statistics->ackrcv_bad += AR5K_REG_READ(AR5K_AR5211_ACK_FAIL);
	statistics->rts_bad += AR5K_REG_READ(AR5K_AR5211_RTS_FAIL);
	statistics->rts_good += AR5K_REG_READ(AR5K_AR5211_RTS_OK);
	statistics->fcs_bad += AR5K_REG_READ(AR5K_AR5211_FCS_FAIL);
	statistics->beacons += AR5K_REG_READ(AR5K_AR5211_BEACON_CNT);
}

HAL_RFGAIN
ar5k_ar5211_get_rf_gain(struct ath_hal *hal)
{
	return (HAL_RFGAIN_INACTIVE);
}

HAL_BOOL
ar5k_ar5211_set_slot_time(struct ath_hal *hal, u_int slot_time)
{
	if (slot_time < HAL_SLOT_TIME_9 || slot_time > HAL_SLOT_TIME_MAX)
		return (AH_FALSE);

	AR5K_REG_WRITE(AR5K_AR5211_DCU_GBL_IFS_SLOT, slot_time);

	return (AH_TRUE);
}

u_int
ar5k_ar5211_get_slot_time(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5211_DCU_GBL_IFS_SLOT) & 0xffff);
}

HAL_BOOL
ar5k_ar5211_set_ack_timeout(struct ath_hal *hal, u_int timeout)
{
	if (ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5211_TIME_OUT_ACK))
	    <= timeout)
		return (AH_FALSE);

	AR5K_REG_WRITE_BITS(AR5K_AR5211_TIME_OUT, AR5K_AR5211_TIME_OUT_ACK,
	    ar5k_htoclock(timeout));

	return (AH_TRUE);
}

u_int
ar5k_ar5211_get_ack_timeout(struct ath_hal *hal)
{
	return (ar5k_clocktoh(AR5K_REG_MS(AR5K_REG_READ(AR5K_AR5211_TIME_OUT),
	    AR5K_AR5211_TIME_OUT_ACK)));
}

HAL_BOOL
ar5k_ar5211_set_cts_timeout(struct ath_hal *hal, u_int timeout)
{
	if (ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5211_TIME_OUT_CTS))
	    <= timeout)
		return (AH_FALSE);

	AR5K_REG_WRITE_BITS(AR5K_AR5211_TIME_OUT, AR5K_AR5211_TIME_OUT_CTS,
	    ar5k_htoclock(timeout));

	return (AH_TRUE);
}

u_int
ar5k_ar5211_get_cts_timeout(struct ath_hal *hal)
{
	return (ar5k_clocktoh(AR5K_REG_MS(AR5K_REG_READ(AR5K_AR5211_TIME_OUT),
	    AR5K_AR5211_TIME_OUT_CTS)));
}

/*
 * Key table (WEP) functions
 */

HAL_BOOL
ar5k_ar5211_is_cipher_supported(struct ath_hal *hal, HAL_CIPHER cipher)
{
	/*
	 * The AR5211 only supports WEP
	 */
	if (cipher == HAL_CIPHER_WEP)
		return (AH_TRUE);

	return (AH_FALSE);
}

u_int32_t
ar5k_ar5211_get_keycache_size(struct ath_hal *hal)
{
	return (AR5K_AR5211_KEYCACHE_SIZE);
}

HAL_BOOL
ar5k_ar5211_reset_key(struct ath_hal *hal, u_int16_t entry)
{
	int i;

	AR5K_ASSERT_ENTRY(entry, AR5K_AR5211_KEYTABLE_SIZE);

	for (i = 0; i < AR5K_AR5211_KEYCACHE_SIZE; i++)
		AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE_OFF(entry, i), 0);

	/* Set NULL encryption */
	AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE_TYPE(entry),
	    AR5K_AR5211_KEYTABLE_TYPE_NULL);

	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5211_is_key_valid(struct ath_hal *hal, u_int16_t entry)
{
	AR5K_ASSERT_ENTRY(entry, AR5K_AR5211_KEYTABLE_SIZE);

	/*
	 * Check the validation flag at the end of the entry
	 */
	if (AR5K_REG_READ(AR5K_AR5211_KEYTABLE_MAC1(entry)) &
	    AR5K_AR5211_KEYTABLE_VALID)
		return (AH_TRUE);

	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5211_set_key(struct ath_hal *hal, u_int16_t entry,
    const HAL_KEYVAL *keyval, const u_int8_t *mac, int xor_notused)
{
	int i;
	u_int32_t key_v[AR5K_AR5211_KEYCACHE_SIZE - 2];

	AR5K_ASSERT_ENTRY(entry, AR5K_AR5211_KEYTABLE_SIZE);

	bzero(&key_v, sizeof(key_v));

	switch (keyval->wk_len) {
	case AR5K_KEYVAL_LENGTH_40:
		bcopy(keyval->wk_key, &key_v[0], 4);
		bcopy(keyval->wk_key + 4, &key_v[1], 1);
		key_v[5] = AR5K_AR5211_KEYTABLE_TYPE_40;
		break;

	case AR5K_KEYVAL_LENGTH_104:
		bcopy(keyval->wk_key, &key_v[0], 4);
		bcopy(keyval->wk_key + 4, &key_v[1], 2);
		bcopy(keyval->wk_key + 6, &key_v[2], 4);
		bcopy(keyval->wk_key + 10, &key_v[3], 2);
		bcopy(keyval->wk_key + 12, &key_v[4], 1);
		key_v[5] = AR5K_AR5211_KEYTABLE_TYPE_104;
		break;

	case AR5K_KEYVAL_LENGTH_128:
		bcopy(keyval->wk_key, &key_v[0], 4);
		bcopy(keyval->wk_key + 4, &key_v[1], 2);
		bcopy(keyval->wk_key + 6, &key_v[2], 4);
		bcopy(keyval->wk_key + 10, &key_v[3], 2);
		bcopy(keyval->wk_key + 12, &key_v[4], 4);
		key_v[5] = AR5K_AR5211_KEYTABLE_TYPE_128;
		break;

	default:
		/* Unsupported key length (not WEP40/104/128) */
		return (AH_FALSE);
	}

	for (i = 0; i < nitems(key_v); i++)
		AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE_OFF(entry, i), key_v[i]);

	return (ar5k_ar5211_set_key_lladdr(hal, entry, mac));
}

HAL_BOOL
ar5k_ar5211_set_key_lladdr(struct ath_hal *hal, u_int16_t entry,
    const u_int8_t *mac)
{
	u_int32_t low_id, high_id;
	const u_int8_t *mac_v;

	/*
	 * Invalid entry (key table overflow)
	 */
	AR5K_ASSERT_ENTRY(entry, AR5K_AR5211_KEYTABLE_SIZE);

	/* MAC may be NULL if it's a broadcast key */
	mac_v = mac == NULL ? etherbroadcastaddr : mac;

	low_id = AR5K_LOW_ID(mac_v);
	high_id = AR5K_HIGH_ID(mac_v) | AR5K_AR5211_KEYTABLE_VALID;

	AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE_MAC0(entry), low_id);
	AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE_MAC1(entry), high_id);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_softcrypto(struct ath_hal *hal, HAL_BOOL enable)
{
	u_int32_t bits;
	int i;

	bits = AR5K_AR5211_DIAG_SW_DIS_ENC | AR5K_AR5211_DIAG_SW_DIS_DEC;
	if (enable == AH_TRUE) {
		/* Disable the hardware crypto engine */
		AR5K_REG_ENABLE_BITS(AR5K_AR5211_DIAG_SW, bits);
	} else {
		/* Enable the hardware crypto engine */
		AR5K_REG_DISABLE_BITS(AR5K_AR5211_DIAG_SW, bits);
	}

	/* Reset the key cache */
	for (i = 0; i < AR5K_AR5211_KEYTABLE_SIZE; i++)
		ar5k_ar5211_reset_key(hal, i);

	return (AH_TRUE);
}

/*
 * Power management functions
 */

HAL_BOOL
ar5k_ar5211_set_power(struct ath_hal *hal, HAL_POWER_MODE mode,
    HAL_BOOL set_chip, u_int16_t sleep_duration)
{
	u_int32_t staid;
	int i;

	staid = AR5K_REG_READ(AR5K_AR5211_STA_ID1);

	switch (mode) {
	case HAL_PM_AUTO:
		staid &= ~AR5K_AR5211_STA_ID1_DEFAULT_ANTENNA;
		/* FALLTHROUGH */
	case HAL_PM_NETWORK_SLEEP:
		if (set_chip == AH_TRUE) {
			AR5K_REG_WRITE(AR5K_AR5211_SCR,
			    AR5K_AR5211_SCR_SLE | sleep_duration);
		}
		staid |= AR5K_AR5211_STA_ID1_PWR_SV;
		break;

	case HAL_PM_FULL_SLEEP:
		if (set_chip == AH_TRUE) {
			AR5K_REG_WRITE(AR5K_AR5211_SCR,
			    AR5K_AR5211_SCR_SLE_SLP);
		}
		staid |= AR5K_AR5211_STA_ID1_PWR_SV;
		break;

	case HAL_PM_AWAKE:
		if (set_chip == AH_FALSE)
			goto commit;

		AR5K_REG_WRITE(AR5K_AR5211_SCR, AR5K_AR5211_SCR_SLE_WAKE);

		for (i = 5000; i > 0; i--) {
			/* Check if the AR5211 did wake up */
			if ((AR5K_REG_READ(AR5K_AR5211_PCICFG) &
			    AR5K_AR5211_PCICFG_SPWR_DN) == 0)
				break;

			/* Wait a bit and retry */
			AR5K_DELAY(200);
			AR5K_REG_WRITE(AR5K_AR5211_SCR,
			    AR5K_AR5211_SCR_SLE_WAKE);
		}

		/* Fail if the AR5211 didn't wake up */
		if (i <= 0)
			return (AH_FALSE);

		staid &= ~AR5K_AR5211_STA_ID1_PWR_SV;
		break;

	default:
		return (AH_FALSE);
	}

 commit:
	hal->ah_power_mode = mode;

	AR5K_REG_WRITE(AR5K_AR5211_STA_ID1, staid);

	return (AH_TRUE);
}

HAL_POWER_MODE
ar5k_ar5211_get_power_mode(struct ath_hal *hal)
{
	return (hal->ah_power_mode);
}

HAL_BOOL
ar5k_ar5211_query_pspoll_support(struct ath_hal *hal)
{
	/* nope */
	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5211_init_pspoll(struct ath_hal *hal)
{
	/*
	 * Not used on the AR5211
	 */
	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5211_enable_pspoll(struct ath_hal *hal, u_int8_t *bssid,
    u_int16_t assoc_id)
{
	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5211_disable_pspoll(struct ath_hal *hal)
{
	return (AH_FALSE);
}

/*
 * Beacon functions
 */

void
ar5k_ar5211_init_beacon(struct ath_hal *hal, u_int32_t next_beacon,
    u_int32_t interval)
{
	u_int32_t timer1, timer2, timer3;

	/*
	 * Set the additional timers by mode
	 */
	switch (hal->ah_op_mode) {
	case HAL_M_STA:
		timer1 = 0x0000ffff;
		timer2 = 0x0007ffff;
		break;

	default:
		timer1 = (next_beacon - AR5K_TUNE_DMA_BEACON_RESP) <<
		    0x00000003;
		timer2 = (next_beacon - AR5K_TUNE_SW_BEACON_RESP) <<
		    0x00000003;
	}

	timer3 = next_beacon +
	    (hal->ah_atim_window ? hal->ah_atim_window : 1);

	/*
	 * Enable all timers and set the beacon register
	 * (next beacon, DMA beacon, software beacon, ATIM window time)
	 */
	AR5K_REG_WRITE(AR5K_AR5211_TIMER0, next_beacon);
	AR5K_REG_WRITE(AR5K_AR5211_TIMER1, timer1);
	AR5K_REG_WRITE(AR5K_AR5211_TIMER2, timer2);
	AR5K_REG_WRITE(AR5K_AR5211_TIMER3, timer3);

	AR5K_REG_WRITE(AR5K_AR5211_BEACON, interval &
	    (AR5K_AR5211_BEACON_PERIOD | AR5K_AR5211_BEACON_RESET_TSF |
	    AR5K_AR5211_BEACON_ENABLE));
}

void
ar5k_ar5211_set_beacon_timers(struct ath_hal *hal,
    const HAL_BEACON_STATE *state, u_int32_t tsf, u_int32_t dtim_count,
    u_int32_t cfp_count)
{
	u_int32_t cfp_period, next_cfp;

	/* Return on an invalid beacon state */
	if (state->bs_interval < 1)
		return;

	/*
	 * PCF support?
	 */
	if (state->bs_cfp_period > 0) {
		/* Enable CFP mode and set the CFP and timer registers */
		cfp_period = state->bs_cfp_period * state->bs_dtim_period *
		    state->bs_interval;
		next_cfp = (cfp_count * state->bs_dtim_period + dtim_count) *
		    state->bs_interval;

		AR5K_REG_DISABLE_BITS(AR5K_AR5211_STA_ID1,
		    AR5K_AR5211_STA_ID1_DEFAULT_ANTENNA |
		    AR5K_AR5211_STA_ID1_PCF);
		AR5K_REG_WRITE(AR5K_AR5211_CFP_PERIOD, cfp_period);
		AR5K_REG_WRITE(AR5K_AR5211_CFP_DUR, state->bs_cfp_max_duration);
		AR5K_REG_WRITE(AR5K_AR5211_TIMER2,
		    (tsf + (next_cfp == 0 ? cfp_period : next_cfp)) << 3);
	} else {
		/* Disable PCF mode */
		AR5K_REG_DISABLE_BITS(AR5K_AR5211_STA_ID1,
		    AR5K_AR5211_STA_ID1_DEFAULT_ANTENNA |
		    AR5K_AR5211_STA_ID1_PCF);
	}

	/*
	 * Enable the beacon timer register
	 */
	AR5K_REG_WRITE(AR5K_AR5211_TIMER0, state->bs_next_beacon);

	/*
	 * Start the beacon timers
	 */
	AR5K_REG_WRITE(AR5K_AR5211_BEACON,
	    (AR5K_REG_READ(AR5K_AR5211_BEACON) &~
	    (AR5K_AR5211_BEACON_PERIOD | AR5K_AR5211_BEACON_TIM)) |
	    AR5K_REG_SM(state->bs_tim_offset ? state->bs_tim_offset + 4 : 0,
	    AR5K_AR5211_BEACON_TIM) | AR5K_REG_SM(state->bs_interval,
	    AR5K_AR5211_BEACON_PERIOD));

	/*
	 * Write new beacon miss threshold, if it appears to be valid
	 */
	if ((AR5K_AR5211_RSSI_THR_BMISS >> AR5K_AR5211_RSSI_THR_BMISS_S) <
	    state->bs_bmiss_threshold)
		return;

	AR5K_REG_WRITE_BITS(AR5K_AR5211_RSSI_THR_M,
	    AR5K_AR5211_RSSI_THR_BMISS, state->bs_bmiss_threshold);
	AR5K_REG_WRITE_BITS(AR5K_AR5211_SCR, AR5K_AR5211_SCR_SLDUR,
	    (state->bs_sleepduration - 3) << 3);
}

void
ar5k_ar5211_reset_beacon(struct ath_hal *hal)
{
	/*
	 * Disable beacon timer
	 */
	AR5K_REG_WRITE(AR5K_AR5211_TIMER0, 0);

	/*
	 * Disable some beacon register values
	 */
	AR5K_REG_DISABLE_BITS(AR5K_AR5211_STA_ID1,
	    AR5K_AR5211_STA_ID1_DEFAULT_ANTENNA | AR5K_AR5211_STA_ID1_PCF);
	AR5K_REG_WRITE(AR5K_AR5211_BEACON, AR5K_AR5211_BEACON_PERIOD);
}

HAL_BOOL
ar5k_ar5211_wait_for_beacon(struct ath_hal *hal, bus_addr_t phys_addr)
{
	HAL_BOOL ret;

	/*
	 * Wait for beaconn queue to be done
	 */
	ret = ar5k_register_timeout(hal,
	    AR5K_AR5211_QCU_STS(HAL_TX_QUEUE_ID_BEACON),
	    AR5K_AR5211_QCU_STS_FRMPENDCNT, 0, AH_FALSE);

	if (AR5K_REG_READ_Q(AR5K_AR5211_QCU_TXE, HAL_TX_QUEUE_ID_BEACON))
		return (AH_FALSE);

	return (ret);
}

/*
 * Interrupt handling
 */

HAL_BOOL
ar5k_ar5211_is_intr_pending(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5211_INTPEND) == 0 ? AH_FALSE : AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_get_isr(struct ath_hal *hal, u_int32_t *interrupt_mask)
{
	u_int32_t data;

	/*
	 * Read interrupt status from the Read-And-Clear shadow register
	 */
	data = AR5K_REG_READ(AR5K_AR5211_RAC_PISR);

	/*
	 * Get abstract interrupt mask (HAL-compatible)
	 */
	*interrupt_mask = (data & HAL_INT_COMMON) & hal->ah_imr;

	if (data == HAL_INT_NOCARD)
		return (AH_FALSE);

	if (data & (AR5K_AR5211_PISR_RXOK | AR5K_AR5211_PISR_RXERR))
		*interrupt_mask |= HAL_INT_RX;

	if (data & (AR5K_AR5211_PISR_TXOK | AR5K_AR5211_PISR_TXERR))
		*interrupt_mask |= HAL_INT_TX;

	if (data & (AR5K_AR5211_PISR_HIUERR))
		*interrupt_mask |= HAL_INT_FATAL;

	/*
	 * Special interrupt handling (not caught by the driver)
	 */
	if (((*interrupt_mask) & AR5K_AR5211_PISR_RXPHY) &&
	    hal->ah_radar.r_enabled == AH_TRUE)
		ar5k_radar_alert(hal);

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5211_get_intr(struct ath_hal *hal)
{
	/* Return the interrupt mask stored previously */
	return (hal->ah_imr);
}

HAL_INT
ar5k_ar5211_set_intr(struct ath_hal *hal, HAL_INT new_mask)
{
	HAL_INT old_mask, int_mask;

	/*
	 * Disable card interrupts to prevent any race conditions
	 * (they will be re-enabled afterwards).
	 */
	AR5K_REG_WRITE(AR5K_AR5211_IER, AR5K_AR5211_IER_DISABLE);

	old_mask = hal->ah_imr;

	/*
	 * Add additional, chipset-dependent interrupt mask flags
	 * and write them to the IMR (interrupt mask register).
	 */
	int_mask = new_mask & HAL_INT_COMMON;

	if (new_mask & HAL_INT_RX)
		int_mask |=
		    AR5K_AR5211_PIMR_RXOK |
		    AR5K_AR5211_PIMR_RXERR |
		    AR5K_AR5211_PIMR_RXORN |
		    AR5K_AR5211_PIMR_RXDESC;

	if (new_mask & HAL_INT_TX)
		int_mask |=
		    AR5K_AR5211_PIMR_TXOK |
		    AR5K_AR5211_PIMR_TXERR |
		    AR5K_AR5211_PIMR_TXDESC |
		    AR5K_AR5211_PIMR_TXURN;

	if (new_mask & HAL_INT_FATAL) {
		int_mask |= AR5K_AR5211_PIMR_HIUERR;
		AR5K_REG_ENABLE_BITS(AR5K_AR5211_SIMR2,
		    AR5K_AR5211_SIMR2_MCABT |
		    AR5K_AR5211_SIMR2_SSERR |
		    AR5K_AR5211_SIMR2_DPERR);
	}

	AR5K_REG_WRITE(AR5K_AR5211_PIMR, int_mask);

	/* Store new interrupt mask */
	hal->ah_imr = new_mask;

	/* ..re-enable interrupts */
	AR5K_REG_WRITE(AR5K_AR5211_IER, AR5K_AR5211_IER_ENABLE);

	return (old_mask);
}

/*
 * Misc internal functions
 */

HAL_BOOL
ar5k_ar5211_get_capabilities(struct ath_hal *hal)
{
	u_int16_t ee_header;
	u_int a, b, g;

	/* Capabilities stored in the EEPROM */
	ee_header = hal->ah_capabilities.cap_eeprom.ee_header;

	a = AR5K_EEPROM_HDR_11A(ee_header);
	b = AR5K_EEPROM_HDR_11B(ee_header);
	g = AR5K_EEPROM_HDR_11G(ee_header);

	/*
	 * If the EEPROM is not reporting any mode, we try 11b.
	 * This might fix a few broken devices with invalid EEPROM.
	 */
	if (!a && !b && !g)
		b = 1;

	/*
	 * XXX The AR5211 tranceiver supports frequencies from 4920 to 6100GHz
	 * XXX and from 2312 to 2732GHz. There are problems with the current
	 * XXX ieee80211 implementation because the IEEE channel mapping
	 * XXX does not support negative channel numbers (2312MHz is channel
	 * XXX -19). Of course, this doesn't matter because these channels
	 * XXX are out of range but some regulation domains like MKK (Japan)
	 * XXX will support frequencies somewhere around 4.8GHz.
	 */

	/*
	 * Set radio capabilities
	 */

	if (a) {
		hal->ah_capabilities.cap_range.range_5ghz_min = 5005; /* 4920 */
		hal->ah_capabilities.cap_range.range_5ghz_max = 6100;

		/* Set supported modes */
		hal->ah_capabilities.cap_mode = HAL_MODE_11A | HAL_MODE_TURBO;
	}

	/* This chip will support 802.11b if the 2GHz radio is connected */
	if (b || g) {
		hal->ah_capabilities.cap_range.range_2ghz_min = 2412; /* 2312 */
		hal->ah_capabilities.cap_range.range_2ghz_max = 2732;

		if (b)
			hal->ah_capabilities.cap_mode |= HAL_MODE_11B;
#if 0
		if (g)
			hal->ah_capabilities.cap_mode |= HAL_MODE_11G;
#endif
	}

	/* GPIO */
	hal->ah_gpio_npins = AR5K_AR5211_NUM_GPIO;

	/* Set number of supported TX queues */
	hal->ah_capabilities.cap_queues.q_tx_num = AR5K_AR5211_TX_NUM_QUEUES;

	return (AH_TRUE);
}

void
ar5k_ar5211_radar_alert(struct ath_hal *hal, HAL_BOOL enable)
{
	/*
	 * Enable radar detection
	 */
	AR5K_REG_WRITE(AR5K_AR5211_IER, AR5K_AR5211_IER_DISABLE);

	if (enable == AH_TRUE) {
		AR5K_REG_WRITE(AR5K_AR5211_PHY_RADAR,
		    AR5K_AR5211_PHY_RADAR_ENABLE);
		AR5K_REG_ENABLE_BITS(AR5K_AR5211_PIMR,
		    AR5K_AR5211_PIMR_RXPHY);
	} else {
		AR5K_REG_WRITE(AR5K_AR5211_PHY_RADAR,
		    AR5K_AR5211_PHY_RADAR_DISABLE);
		AR5K_REG_DISABLE_BITS(AR5K_AR5211_PIMR,
		    AR5K_AR5211_PIMR_RXPHY);
	}

	AR5K_REG_WRITE(AR5K_AR5211_IER, AR5K_AR5211_IER_ENABLE);
}

/*
 * EEPROM access functions
 */

HAL_BOOL
ar5k_ar5211_eeprom_is_busy(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5211_CFG) & AR5K_AR5211_CFG_EEBS ?
	    AH_TRUE : AH_FALSE);
}

int
ar5k_ar5211_eeprom_read(struct ath_hal *hal, u_int32_t offset, u_int16_t *data)
{
	u_int32_t status, i;

	/*
	 * Initialize EEPROM access
	 */
	AR5K_REG_WRITE(AR5K_AR5211_EEPROM_BASE, (u_int8_t)offset);
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_EEPROM_CMD,
	    AR5K_AR5211_EEPROM_CMD_READ);

	for (i = AR5K_TUNE_REGISTER_TIMEOUT; i > 0; i--) {
		status = AR5K_REG_READ(AR5K_AR5211_EEPROM_STATUS);
		if (status & AR5K_AR5211_EEPROM_STAT_RDDONE) {
			if (status & AR5K_AR5211_EEPROM_STAT_RDERR)
				return (EIO);
			*data = (u_int16_t)
			    (AR5K_REG_READ(AR5K_AR5211_EEPROM_DATA) & 0xffff);
			return (0);
		}
		AR5K_DELAY(15);
	}

	return (ETIMEDOUT);
}

int
ar5k_ar5211_eeprom_write(struct ath_hal *hal, u_int32_t offset, u_int16_t data)
{
	u_int32_t status, timeout;

	/* Enable eeprom access */
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_EEPROM_CMD,
	    AR5K_AR5211_EEPROM_CMD_RESET);
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_EEPROM_CMD,
	    AR5K_AR5211_EEPROM_CMD_WRITE);

	/*
	 * Prime write pump
	 */
	AR5K_REG_WRITE(AR5K_AR5211_EEPROM_BASE, (u_int8_t)offset - 1);

	for (timeout = 10000; timeout > 0; timeout--) {
		AR5K_DELAY(1);
		status = AR5K_REG_READ(AR5K_AR5211_EEPROM_STATUS);
		if (status & AR5K_AR5211_EEPROM_STAT_WRDONE) {
			if (status & AR5K_AR5211_EEPROM_STAT_WRERR)
				return (EIO);
			return (0);
		}
	}

	return (ETIMEDOUT);
}

/*
 * RF register settings
 */

HAL_BOOL
ar5k_ar5211_rfregs(struct ath_hal *hal, HAL_CHANNEL *channel, u_int freq,
    u_int ee_mode)
{
	struct ar5k_eeprom_info *ee = &hal->ah_capabilities.cap_eeprom;
	struct ar5k_ar5211_ini_rf rf[nitems(ar5211_rf)];
	u_int32_t ob, db, xpds, xpdp, x_gain;
	u_int i;
	int obdb;

	bcopy(ar5211_rf, rf, sizeof(rf));
	obdb = 0;

	if (freq == AR5K_INI_RFGAIN_2GHZ &&
	    hal->ah_ee_version >= AR5K_EEPROM_VERSION_3_1) {
		ob = ar5k_bitswap(ee->ee_ob[ee_mode][0], 3);
		db = ar5k_bitswap(ee->ee_db[ee_mode][0], 3);
		rf[25].rf_value[freq] =
		    ((ob << 6) & 0xc0) | (rf[25].rf_value[freq] & ~0xc0);
		rf[26].rf_value[freq] =
		    (((ob >> 2) & 0x1) | ((db << 1) & 0xe)) |
		    (rf[26].rf_value[freq] & ~0xf);
	}

	if (freq == AR5K_INI_RFGAIN_5GHZ) {
		/* For 11a and Turbo */
		obdb = channel->c_channel >= 5725 ? 3 :
		    (channel->c_channel >= 5500 ? 2 :
			(channel->c_channel >= 5260 ? 1 :
			    (channel->c_channel > 4000 ? 0 : -1)));
	}

	/* bogus channel: bad beacon? */
	if (obdb < 0)
		return (AH_FALSE);

	ob = ee->ee_ob[ee_mode][obdb];
	db = ee->ee_db[ee_mode][obdb];
	x_gain = ee->ee_x_gain[ee_mode];
	xpds = ee->ee_xpd[ee_mode];
	xpdp = !xpds;

	rf[11].rf_value[freq] = (rf[11].rf_value[freq] & ~0xc0) |
		(((ar5k_bitswap(x_gain, 4) << 7) | (xpdp << 6)) & 0xc0);
	rf[12].rf_value[freq] = (rf[12].rf_value[freq] & ~0x7) |
		((ar5k_bitswap(x_gain, 4) >> 1) & 0x7);
	rf[12].rf_value[freq] = (rf[12].rf_value[freq] & ~0x80) |
		((ar5k_bitswap(ob, 3) << 7) & 0x80);
	rf[13].rf_value[freq] = (rf[13].rf_value[freq] & ~0x3) |
		((ar5k_bitswap(ob, 3) >> 1) & 0x3);
	rf[13].rf_value[freq] = (rf[13].rf_value[freq] & ~0x1c) |
		((ar5k_bitswap(db, 3) << 2) & 0x1c);
	rf[17].rf_value[freq] = (rf[17].rf_value[freq] & ~0x8) |
		((xpds << 3) & 0x8);

	for (i = 0; i < nitems(rf); i++) {
		AR5K_REG_WAIT(i);
		AR5K_REG_WRITE((u_int32_t)rf[i].rf_register,
		    rf[i].rf_value[freq]);
	}

	hal->ah_rf_gain = HAL_RFGAIN_INACTIVE;

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5211_set_txpower_limit(struct ath_hal *hal, u_int power)
{
	/* Not implemented */
	return (AH_FALSE);
}
@


1.47
log
@Unbreak WEP/WPA on AR5211 ath(4) devices by setting hardware WEP keytable
entry types to NULL, as done for AR5212 devices. ath(4) uses software crypto.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.46 2014/07/12 18:48:17 tedu Exp $	*/
a303 5
	if (flags & IEEE80211_CHAN_TURBO) {
		turbo = AR5K_AR5211_PHY_TURBO_MODE |
		    AR5K_AR5211_PHY_TURBO_SHORT;
	}

a381 2
	case HAL_MODE_TURBO:
		return (&hal->ah_rt_turbo);
a448 5
	case CHANNEL_T:
		mode = AR5K_INI_VAL_11A_TURBO;
		freq = AR5K_INI_RFGAIN_5GHZ;
		ee_mode = AR5K_EEPROM_MODE_11A;
		break;
d1855 2
a1856 2
	if (ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5211_TIME_OUT_ACK),
	    hal->ah_turbo) <= timeout)
d1860 1
a1860 1
	    ar5k_htoclock(timeout, hal->ah_turbo));
d1869 1
a1869 1
	    AR5K_AR5211_TIME_OUT_ACK), hal->ah_turbo));
d1875 2
a1876 2
	if (ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5211_TIME_OUT_CTS),
	    hal->ah_turbo) <= timeout)
d1880 1
a1880 1
	    ar5k_htoclock(timeout, hal->ah_turbo));
d1889 1
a1889 1
	    AR5K_AR5211_TIME_OUT_CTS), hal->ah_turbo));
@


1.46
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.45 2012/08/30 11:03:57 jsg Exp $	*/
d1935 4
@


1.45
log
@make a variable that can take a value of -1 signed to match what the
rest of the code expects.

from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.44 2009/06/02 12:39:02 reyk Exp $	*/
d407 1
a407 1
	free(hal, M_DEVBUF);
@


1.44
log
@replace custom macro AR5K_ELEMENTS() with nitems()
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.43 2009/06/02 12:09:26 guenther Exp $	*/
d2566 1
a2566 1
	u_int32_t ob, db, obdb, xpds, xpdp, x_gain;
d2568 1
@


1.43
log
@If a bogus channel is encountered, return an error instead of trying
to use the -1 flag value as an array index.
Found by Parfait.

ok reyk@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.42 2009/02/06 17:06:45 grange Exp $	*/
d489 1
a489 1
	for (i = 0; i < AR5K_ELEMENTS(ar5211_mode); i++) {
d498 1
a498 1
	for (i = 0; i < AR5K_ELEMENTS(ar5211_ini); i++) {
d1995 1
a1995 1
	for (i = 0; i < AR5K_ELEMENTS(key_v); i++)
d2565 1
a2565 1
	struct ar5k_ar5211_ini_rf rf[AR5K_ELEMENTS(ar5211_rf)];
d2614 1
a2614 1
	for (i = 0; i < AR5K_ELEMENTS(rf); i++) {
@


1.42
log
@Replace comparision between boolean expression result and an integer
that may confuse gcc with a simple boolean expression.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.41 2009/01/15 07:55:22 grange Exp $	*/
d32 1
a32 1
void		 ar5k_ar5211_rfregs(struct ath_hal *, HAL_CHANNEL *, u_int,
d483 2
a484 1
	ar5k_ar5211_rfregs(hal, channel, freq, ee_mode);
d2560 1
a2560 1
void
d2591 4
d2621 2
@


1.41
log
@const void foo() makes no sense. No binary change.

ok niklas@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.40 2008/09/13 13:35:06 reyk Exp $	*/
d2418 1
a2418 1
	if (a == b == g == 0)
@


1.40
log
@fallback to 11b support if the EEPROM is not reporting any available mode.
there is probably a new EEPROM format here, but i don't know how to parse
the AR5424 version yet, so just set some defaults for these chipsets for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.39 2008/08/29 10:05:00 reyk Exp $	*/
d31 1
a31 1
const void	 ar5k_ar5211_fill(struct ath_hal *);
d47 1
a47 1
const void
@


1.39
log
@add a HAL function to force disabling the hardware crypto engine
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.38 2008/08/27 09:05:03 damien Exp $	*/
d2405 1
d2410 11
d2435 1
a2435 1
	if (AR5K_EEPROM_HDR_11A(ee_header)) {
d2444 1
a2444 1
	if (AR5K_EEPROM_HDR_11B(ee_header) || AR5K_EEPROM_HDR_11G(ee_header)) {
d2448 1
a2448 1
		if (AR5K_EEPROM_HDR_11B(ee_header))
d2451 1
a2451 1
		if (AR5K_EEPROM_HDR_11G(ee_header))
@


1.38
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.37 2008/07/30 07:15:39 reyk Exp $	*/
d139 1
d2020 22
@


1.37
log
@Update the RF, RFGAIN, MODE, INI, and BBGAIN initialization tables
with different versions for various ar5212 variants and add an extra
table for PCI-E devices.  This fixes support for various newer devices
(like the 1st generation MacBook, T61 variants) but it still does not
work on a number of other devices.

Tested by many
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.36 2007/11/01 20:32:16 reyk Exp $	*/
d689 1
d699 1
@


1.36
log
@backout last "fix" because it breaks operation on some devices.  even
if the fix looks right, it seems to expose another problem that i
haven't found yet.

figured out by Denis Doroshenko at gmail dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.35 2007/10/29 09:39:35 reyk Exp $	*/
d510 1
a510 1
	if (ar5k_rfgain(hal, AR5K_INI_PHY_5111, freq) == AH_FALSE)
@


1.35
log
@fix the setup of Tx descriptors. the frame type and "no ack" bits were
initialized in ar5k_ar521*_setup_tx_desc() but cleared in
ar5k_ar521*_fill_tx_desc() by setting the segment length incorrectly.

From ath5k via Nick Kossifidis (mickflemm at gmail dot com)*

---snip---
The missing no_ack in broadcast frames caused them to be retried up to
the retry_limit(1+4=5 transmissions by default).
---snap---

* it was explicitly mentioned that it is ISC-licensed now
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.34 2007/04/10 17:47:55 miod Exp $	*/
d1198 1
d1200 1
@


1.34
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.33 2007/03/12 01:04:52 reyk Exp $	*/
d1195 1
a1195 2
	if ((tx_desc->tx_control_1 = (segment_length &
	    AR5K_AR5211_DESC_TX_CTL1_BUF_LEN)) != segment_length)
d1197 3
@


1.33
log
@add some HAL functions (again) inspired by the changes from the
madwifi-old-openhal project. this was backed out the last time because
it was too close to the release and i didn't respect the ABI/API lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.30 2007/03/05 15:13:26 reyk Exp $	*/
d206 1
a206 1
	/* Bring device out of sleep and reset it's units */
@


1.32
log
@do not use bcopy to set the mac address registers. this diff should
fix the "hal" on big endian systems.

thanks to the madwifi-old-openhal people
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.31 2007/03/05 16:54:33 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
d178 16
d410 7
d670 12
d860 9
d1084 7
d1692 7
d2575 7
@


1.31
log
@back out, reyk is not paying attention
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.29 2007/02/14 00:53:48 jsg Exp $	*/
d676 2
a677 2
	bcopy(&(hal->ah_sta_id[0]), &low_id, 4);
	bcopy(&(hal->ah_sta_id[4]), &high_id, 2);
d1543 2
a1544 3
	bcopy(mac, &low_id, 4);
	bcopy(mac + 4, &high_id, 2);
	high_id = 0x0000ffff & high_id;
d1618 2
a1619 2
	bcopy(bssid, &low_id, 4);
	bcopy(bssid + 4, &high_id, 2);
d1950 2
a1951 3
	bcopy(mac_v, &low_id, 4);
	bcopy(mac_v + 4, &high_id, 2);
	high_id |= AR5K_AR5211_KEYTABLE_VALID;
@


1.30
log
@Add some HAL functions.

From madwifi-old-openhal via Nick Kossifidis (mickflemm at gmail dot com)

Bump copyright while I'm here.
@
text
@d4 1
a4 1
 * Copyright (c) 2004, 2005, 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
a177 16

	/*
	 * Unused functions or functions not implemented
	 */
	AR5K_HAL_FUNCTION(hal, ar5211, get_tx_queueprops);
	AR5K_HAL_FUNCTION(hal, ar5211, num_tx_pending);
	AR5K_HAL_FUNCTION(hal, ar5211, phy_disable);
	AR5K_HAL_FUNCTION(hal, ar5211, set_txpower_limit);
	AR5K_HAL_FUNCTION(hal, ar5211, set_def_antenna);
	AR5K_HAL_FUNCTION(hal, ar5211, get_def_antenna);
	AR5K_HAL_FUNCTION(hal, ar5211, set_bssid_mask);
#ifdef notyet
	AR5K_HAL_FUNCTION(hal, ar5211, set_capability);
	AR5K_HAL_FUNCTION(hal, ar5211, proc_mib_event);
	AR5K_HAL_FUNCTION(hal, ar5211, get_tx_inter_queue);
#endif
a393 7
ar5k_ar5211_phy_disable(struct ath_hal *hal)
{
	AR5K_REG_WRITE(AR5K_AR5211_PHY_ACTIVE, AR5K_AR5211_PHY_DISABLE);
	return (AH_TRUE);
}

HAL_BOOL
a646 12
ar5k_ar5211_set_def_antenna(struct ath_hal *hal, u_int ant)
{
	AR5K_REG_WRITE(AR5K_AR5211_DEFAULT_ANTENNA, ant);
}

u_int
ar5k_ar5211_get_def_antenna(struct ath_hal *hal)
{
	return AR5K_REG_READ(AR5K_AR5211_DEFAULT_ANTENNA);
}

void
a824 9
ar5k_ar5211_get_tx_queueprops(struct ath_hal *hal, int queue,
    HAL_TXQ_INFO *queue_info)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);
	bcopy(&hal->ah_txq[queue], queue_info, sizeof(HAL_TXQ_INFO));
	return (AH_TRUE);
}

HAL_BOOL
a1039 7
u_int32_t
ar5k_ar5211_num_tx_pending(struct ath_hal *hal, u_int queue)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);
	return (AR5K_AR5211_QCU_STS(queue) & AR5K_AR5211_QCU_STS_FRMPENDCNT);
}

a1641 7
ar5k_ar5211_set_bssid_mask(struct ath_hal *hal, const u_int8_t* mask)
{
	/* Not supported in 5211 */
	return (AH_FALSE);
}

HAL_BOOL
a2518 7
}

HAL_BOOL
ar5k_ar5211_set_txpower_limit(struct ath_hal *hal, u_int power)
{
	/* Not implemented */
	return (AH_FALSE);
@


1.29
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.28 2006/09/19 16:42:29 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
d178 16
d410 7
d670 12
d860 9
d1084 7
d1693 7
d2577 7
@


1.28
log
@better mode setup in the ar5211 and ar5212 reset functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.27 2006/09/19 13:37:11 reyk Exp $	*/
d1977 1
a1977 1
		/* fallthrough */
@


1.27
log
@fix 11a/b antenna mode setup
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.26 2006/09/19 13:14:32 reyk Exp $	*/
d426 2
a427 1
	if (channel->c_channel_flags & IEEE80211_CHAN_A) {
d431 2
a432 1
	} else if (channel->c_channel_flags & IEEE80211_CHAN_T) {
d436 2
a437 1
	} else if (channel->c_channel_flags & IEEE80211_CHAN_B) {
d441 3
a443 1
	} else if (channel->c_channel_flags & IEEE80211_CHAN_G) {
d447 2
a448 1
	} else {
@


1.26
log
@disable 11g mode for now
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.25 2005/12/18 17:59:58 reyk Exp $	*/
d503 4
a506 9
	ant[0] = HAL_ANT_FIXED_A;
	ant[1] = HAL_ANT_FIXED_B;

	if (hal->ah_ant_diversity == AH_FALSE) {
		if (freq == AR5K_INI_RFGAIN_2GHZ)
			ant[0] = HAL_ANT_FIXED_B;
		else if (freq == AR5K_INI_RFGAIN_5GHZ)
			ant[1] = HAL_ANT_FIXED_A;
	}
@


1.25
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.24 2005/10/07 22:03:25 reyk Exp $	*/
a2348 1
		hal->ah_capabilities.cap_mode |= HAL_MODE_11B;
d2352 1
d2355 1
@


1.24
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.23 2005/10/04 13:50:00 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.23
log
@fix a bug in Tx descriptor processing.

found by David Malone
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.22 2005/09/19 10:27:08 reyk Exp $	*/
d2014 1
a2014 1
		
d2514 1
a2514 1
	}	
@


1.22
log
@don't attach unsupported radio chipsets

based on a diff by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.21 2005/09/10 14:36:46 jsg Exp $	*/
d1197 1
a1197 1
	desc->ds_us.tx.ts_tstamp =
@


1.21
log
@ansi, no binary change.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.20 2005/08/14 11:02:33 miod Exp $	*/
d196 1
a200 1

d203 1
a203 5

	/* Get the 2GHz radio revision if it's supported */
	if (hal->ah_mac_version >= AR5K_SREV_VER_AR5211)
		hal->ah_radio_2ghz_revision =
		    ar5k_ar5211_radio_revision(hal, HAL_CHIP_2GHZ);
@


1.20
log
@catched->caught
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.19 2005/07/30 17:13:17 reyk Exp $	*/
d48 1
a48 2
ar5k_ar5211_fill(hal)
	struct ath_hal *hal;
d181 2
a182 6
ar5k_ar5211_attach(device, sc, st, sh, status)
	u_int16_t device;
	void *sc;
	bus_space_tag_t st;
	bus_space_handle_t sh;
	int *status;
d223 1
a223 3
ar5k_ar5211_nic_reset(hal, val)
	struct ath_hal *hal;
	u_int32_t val;
d257 1
a257 3
ar5k_ar5211_nic_wakeup(hal, flags)
	struct ath_hal *hal;
	u_int16_t flags;
d331 1
a331 3
ar5k_ar5211_radio_revision(hal, chip)
	struct ath_hal *hal;
	HAL_CHIP chip;
d369 1
a369 3
ar5k_ar5211_get_rate_table(hal, mode)
	struct ath_hal *hal;
	u_int mode;
d389 1
a389 2
ar5k_ar5211_detach(hal)
	struct ath_hal *hal;
d398 2
a399 6
ar5k_ar5211_reset(hal, op_mode, channel, change_channel, status)
	struct ath_hal *hal;
	HAL_OPMODE op_mode;
	HAL_CHANNEL *channel;
	HAL_BOOL change_channel;
	HAL_STATUS *status;
d650 1
a650 2
ar5k_ar5211_set_opmode(hal)
	struct ath_hal *hal;
d688 1
a688 3
ar5k_ar5211_calibrate(hal, channel)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
d730 1
a730 3
ar5k_ar5211_update_tx_triglevel(hal, increase)
	struct ath_hal *hal;
	HAL_BOOL increase;
d767 2
a768 4
ar5k_ar5211_setup_tx_queue(hal, queue_type, queue_info)
	struct ath_hal *hal;
	HAL_TX_QUEUE queue_type;
	const HAL_TXQ_INFO *queue_info;
d808 2
a809 4
ar5k_ar5211_setup_tx_queueprops(hal, queue, queue_info)
	struct ath_hal *hal;
	int queue;
	const HAL_TXQ_INFO *queue_info;
d828 1
a828 3
ar5k_ar5211_release_tx_queue(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d840 1
a840 3
ar5k_ar5211_reset_tx_queue(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d1016 1
a1016 3
ar5k_ar5211_get_tx_buf(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d1027 1
a1027 4
ar5k_ar5211_put_tx_buf(hal, queue, phys_addr)
	struct ath_hal *hal;
	u_int queue;
	u_int32_t phys_addr;
d1044 1
a1044 3
ar5k_ar5211_tx_start(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d1059 1
a1059 3
ar5k_ar5211_stop_tx_dma(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d1083 4
a1086 16
ar5k_ar5211_setup_tx_desc(hal, desc, packet_length, header_length, type,
    tx_power, tx_rate0, tx_tries0, key_index, antenna_mode, flags, rtscts_rate,
    rtscts_duration)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int packet_length;
	u_int header_length;
	HAL_PKT_TYPE type;
	u_int tx_power;
	u_int tx_rate0;
	u_int tx_tries0;
	u_int key_index;
	u_int antenna_mode;
	u_int flags;
	u_int rtscts_rate;
	u_int rtscts_duration;
d1136 2
a1137 6
ar5k_ar5211_fill_tx_desc(hal, desc, segment_length, first_segment, last_segment)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int segment_length;
	HAL_BOOL first_segment;
	HAL_BOOL last_segment;
d1161 3
a1163 10
ar5k_ar5211_setup_xtx_desc(hal, desc, tx_rate1, tx_tries1, tx_rate2, tx_tries2,
    tx_rate3, tx_tries3)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int tx_rate1;
	u_int tx_tries1;
	u_int tx_rate2;
	u_int tx_tries2;
	u_int tx_rate3;
	u_int tx_tries3;
d1169 1
a1169 3
ar5k_ar5211_proc_tx_desc(hal, desc)
	struct ath_hal *hal;
	struct ath_desc *desc;
d1224 1
a1224 2
ar5k_ar5211_has_veol(hal)
	struct ath_hal *hal;
d1234 1
a1234 2
ar5k_ar5211_get_rx_buf(hal)
	struct ath_hal *hal;
d1240 1
a1240 3
ar5k_ar5211_put_rx_buf(hal, phys_addr)
	struct ath_hal *hal;
	u_int32_t phys_addr;
d1246 1
a1246 2
ar5k_ar5211_start_rx(hal)
	struct ath_hal *hal;
d1252 1
a1252 2
ar5k_ar5211_stop_rx_dma(hal)
	struct ath_hal *hal;
d1270 1
a1270 2
ar5k_ar5211_start_rx_pcu(hal)
	struct ath_hal *hal;
d1276 1
a1276 2
ar5k_ar5211_stop_pcu_recv(hal)
	struct ath_hal *hal;
d1282 2
a1283 4
ar5k_ar5211_set_mcast_filter(hal, filter0, filter1)
	struct ath_hal *hal;
	u_int32_t filter0;
	u_int32_t filter1;
d1291 1
a1291 3
ar5k_ar5211_set_mcast_filterindex(hal, index)
	struct ath_hal *hal;
	u_int32_t index;
d1307 1
a1307 3
ar5k_ar5211_clear_mcast_filter_idx(hal, index)
	struct ath_hal *hal;
	u_int32_t index;
d1324 1
a1324 2
ar5k_ar5211_get_rx_filter(hal)
	struct ath_hal *hal;
d1330 1
a1330 3
ar5k_ar5211_set_rx_filter(hal, filter)
	struct ath_hal *hal;
	u_int32_t filter;
d1336 2
a1337 5
ar5k_ar5211_setup_rx_desc(hal, desc, size, flags)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int32_t size;
	u_int flags;
d1354 2
a1355 5
ar5k_ar5211_proc_rx_desc(hal, desc, phys_addr, next)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int32_t phys_addr;
	struct ath_desc *next;
d1423 1
a1423 2
ar5k_ar5211_set_rx_signal(hal)
	struct ath_hal *hal;
d1433 1
a1433 2
ar5k_ar5211_dump_state(hal)
	struct ath_hal *hal;
d1522 2
a1523 6
ar5k_ar5211_get_diag_state(hal, id, device, size)
	struct ath_hal *hal;
	int id;
	void **device;
	u_int *size;

d1533 1
a1533 3
ar5k_ar5211_get_lladdr(hal, mac)
	struct ath_hal *hal;
	u_int8_t *mac;
d1539 1
a1539 3
ar5k_ar5211_set_lladdr(hal, mac)
	struct ath_hal *hal;
	const u_int8_t *mac;
d1557 2
a1558 5
ar5k_ar5211_set_regdomain(hal, regdomain, status)
	struct ath_hal *hal;
	u_int16_t regdomain;
	HAL_STATUS *status;

d1576 1
a1576 3
ar5k_ar5211_set_ledstate(hal, state)
	struct ath_hal *hal;
	HAL_LED_STATE state;
d1614 2
a1615 5
ar5k_ar5211_set_associd(hal, bssid, assoc_id, tim_offset)
	struct ath_hal *hal;
	const u_int8_t *bssid;
	u_int16_t assoc_id;
	u_int16_t tim_offset;
d1645 1
a1645 3
ar5k_ar5211_set_gpio_output(hal, gpio)
	struct ath_hal *hal;
	u_int32_t gpio;
d1658 1
a1658 3
ar5k_ar5211_set_gpio_input(hal, gpio)
	struct ath_hal *hal;
	u_int32_t gpio;
d1671 1
a1671 3
ar5k_ar5211_get_gpio(hal, gpio)
	struct ath_hal *hal;
	u_int32_t gpio;
d1682 1
a1682 4
ar5k_ar5211_set_gpio(hal, gpio, val)
	struct ath_hal *hal;
	u_int32_t gpio;
	u_int32_t val;
d1701 2
a1702 4
ar5k_ar5211_set_gpio_intr(hal, gpio, interrupt_level)
	struct ath_hal *hal;
	u_int gpio;
	u_int32_t interrupt_level;
d1727 1
a1727 2
ar5k_ar5211_get_tsf32(hal)
	struct ath_hal *hal;
d1733 1
a1733 2
ar5k_ar5211_get_tsf64(hal)
	struct ath_hal *hal;
d1741 1
a1741 2
ar5k_ar5211_reset_tsf(hal)
	struct ath_hal *hal;
d1748 1
a1748 2
ar5k_ar5211_get_regdomain(hal)
	struct ath_hal *hal;
d1754 1
a1754 2
ar5k_ar5211_detect_card_present(hal)
	struct ath_hal *hal;
d1770 1
a1770 3
ar5k_ar5211_update_mib_counters(hal, statistics)
	struct ath_hal *hal;
	HAL_MIB_STATS *statistics;
d1780 1
a1780 2
ar5k_ar5211_get_rf_gain(hal)
	struct ath_hal *hal;
d1786 1
a1786 3
ar5k_ar5211_set_slot_time(hal, slot_time)
	struct ath_hal *hal;
	u_int slot_time;
d1797 1
a1797 2
ar5k_ar5211_get_slot_time(hal)
	struct ath_hal *hal;
d1803 1
a1803 3
ar5k_ar5211_set_ack_timeout(hal, timeout)
	struct ath_hal *hal;
	u_int timeout;
d1816 1
a1816 2
ar5k_ar5211_get_ack_timeout(hal)
	struct ath_hal *hal;
d1823 1
a1823 3
ar5k_ar5211_set_cts_timeout(hal, timeout)
	struct ath_hal *hal;
	u_int timeout;
d1836 1
a1836 2
ar5k_ar5211_get_cts_timeout(hal)
	struct ath_hal *hal;
d1847 1
a1847 3
ar5k_ar5211_is_cipher_supported(hal, cipher)
	struct ath_hal *hal;
	HAL_CIPHER cipher;
d1859 1
a1859 2
ar5k_ar5211_get_keycache_size(hal)
	struct ath_hal *hal;
d1865 1
a1865 3
ar5k_ar5211_reset_key(hal, entry)
	struct ath_hal *hal;
	u_int16_t entry;
d1878 1
a1878 3
ar5k_ar5211_is_key_valid(hal, entry)
	struct ath_hal *hal;
	u_int16_t entry;
d1893 2
a1894 6
ar5k_ar5211_set_key(hal, entry, keyval, mac, xor_notused)
	struct ath_hal *hal;
	u_int16_t entry;
	const HAL_KEYVAL *keyval;
	const u_int8_t *mac;
	int xor_notused;
d1940 2
a1941 4
ar5k_ar5211_set_key_lladdr(hal, entry, mac)
	struct ath_hal *hal;
	u_int16_t entry;
	const u_int8_t *mac;
d1969 2
a1970 5
ar5k_ar5211_set_power(hal, mode, set_chip, sleep_duration)
	struct ath_hal *hal;
	HAL_POWER_MODE mode;
	HAL_BOOL set_chip;
	u_int16_t sleep_duration;
d2035 1
a2035 2
ar5k_ar5211_get_power_mode(hal)
	struct ath_hal *hal;
d2041 1
a2041 2
ar5k_ar5211_query_pspoll_support(hal)
	struct ath_hal *hal;
d2048 1
a2048 2
ar5k_ar5211_init_pspoll(hal)
	struct ath_hal *hal;
d2057 2
a2058 4
ar5k_ar5211_enable_pspoll(hal, bssid, assoc_id)
	struct ath_hal *hal;
	u_int8_t *bssid;
	u_int16_t assoc_id;
d2064 1
a2064 2
ar5k_ar5211_disable_pspoll(hal)
	struct ath_hal *hal;
d2074 2
a2075 4
ar5k_ar5211_init_beacon(hal, next_beacon, interval)
	struct ath_hal *hal;
	u_int32_t next_beacon;
	u_int32_t interval;
d2113 3
a2115 7
ar5k_ar5211_set_beacon_timers(hal, state, tsf, dtim_count, cfp_count)
	struct ath_hal *hal;
	const HAL_BEACON_STATE *state;
	u_int32_t tsf;
	u_int32_t dtim_count;
	u_int32_t cfp_count;

d2176 1
a2176 2
ar5k_ar5211_reset_beacon(hal)
	struct ath_hal *hal;
d2192 1
a2192 3
ar5k_ar5211_wait_for_beacon(hal, phys_addr)
	struct ath_hal *hal;
	bus_addr_t phys_addr;
d2214 1
a2214 2
ar5k_ar5211_is_intr_pending(hal)
	struct ath_hal *hal;
d2220 1
a2220 3
ar5k_ar5211_get_isr(hal, interrupt_mask)
	struct ath_hal *hal;
	u_int32_t *interrupt_mask;
d2257 1
a2257 2
ar5k_ar5211_get_intr(hal)
	struct ath_hal *hal;
d2264 1
a2264 3
ar5k_ar5211_set_intr(hal, new_mask)
	struct ath_hal *hal;
	HAL_INT new_mask;
d2320 1
a2320 2
ar5k_ar5211_get_capabilities(hal)
	struct ath_hal *hal;
d2371 1
a2371 3
ar5k_ar5211_radar_alert(hal, enable)
	struct ath_hal *hal;
	HAL_BOOL enable;
d2398 1
a2398 2
ar5k_ar5211_eeprom_is_busy(hal)
	struct ath_hal *hal;
d2405 1
a2405 4
ar5k_ar5211_eeprom_read(hal, offset, data)
	struct ath_hal *hal;
	u_int32_t offset;
	u_int16_t *data;
d2432 1
a2432 4
ar5k_ar5211_eeprom_write(hal, offset, data)
	struct ath_hal *hal;
	u_int32_t offset;
	u_int16_t data;
d2465 2
a2466 4
ar5k_ar5211_rfregs(hal, channel, freq, ee_mode)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
	u_int freq, ee_mode;
@


1.19
log
@remove a useless timeout after tx (decrease nasty delays while
scanning) and fix various other minor things in the ath(4) driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.18 2005/06/17 12:51:08 reyk Exp $	*/
d2415 1
a2415 1
	 * Special interrupt handling (not catched by the driver)
@


1.18
log
@remove non-constant array initializers which is a GNU extension.
suggested by anil some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.17 2005/05/28 23:45:09 reyk Exp $	*/
d512 9
d591 8
d1101 2
d1110 5
a1114 5
	ar5k_register_timeout(hal, AR5K_AR5211_QCU_STS(queue),
	    AR5K_AR5211_QCU_STS_FRMPENDCNT, 0, AH_FALSE);

	if (AR5K_REG_READ_Q(AR5K_AR5211_QCU_TXE, queue))
		return (AH_FALSE);
d1918 1
a1918 2
	AR5K_REG_WRITE(AR5K_AR5211_DCU_GBL_IFS_SLOT,
	    ar5k_htoclock(slot_time, hal->ah_turbo));
d1927 1
a1927 2
	return (ar5k_clocktoh(AR5K_REG_READ(AR5K_AR5211_DCU_GBL_IFS_SLOT) &
	    0xffff, hal->ah_turbo));
@


1.17
log
@fix hostap mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.16 2005/05/27 11:42:52 reyk Exp $	*/
d2024 2
a2025 2
	int elements = AR5K_AR5211_KEYCACHE_SIZE - 2, i;
	u_int32_t key_v[elements];
d2061 1
a2061 1
	for (i = 0; i < elements; i++)
@


1.16
log
@remove some misplaced htole32s
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.15 2005/05/24 21:46:18 reyk Exp $	*/
a1083 2
	HAL_BOOL ret;

d1091 1
a1091 1
	ret = ar5k_register_timeout(hal, AR5K_AR5211_QCU_STS(queue),
a2455 6
	}

	if (hal->ah_op_mode & HAL_M_HOSTAP) {
		int_mask |= AR5K_AR5211_PIMR_MIB;
	} else {
		int_mask &= ~AR5K_AR5211_PIMR_MIB;
@


1.15
log
@ath_hal_rx_monitor should be used for link state monitoring instead of
setting the promisc mode. rename it to ath_hal_rx_signal and remove
the incorrect promisc flag. this should fix some problems with ath
running in forwarding mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.14 2005/05/21 20:14:55 reyk Exp $	*/
d1629 1
a1629 1
	high_id = 0x0000ffff & htole32(high_id);
d1631 1
a1631 1
	AR5K_REG_WRITE(AR5K_AR5211_STA_ID0, htole32(low_id));
d1713 2
a1714 2
	AR5K_REG_WRITE(AR5K_AR5211_BSS_ID0, htole32(low_id));
	AR5K_REG_WRITE(AR5K_AR5211_BSS_ID1, htole32(high_id) |
d2090 2
a2091 2
	AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE_MAC0(entry), htole32(low_id));
	AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE_MAC1(entry), htole32(high_id));
@


1.14
log
@sync power management settings. this should fix some unrecoverable
sleep mode timeouts for ar5210, ar5211 and ar5212.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.13 2005/05/08 14:46:50 reyk Exp $	*/
d100 1
a100 1
	AR5K_HAL_FUNCTION(hal, ar5211, set_rx_monitor);
d1494 1
a1494 1
ar5k_ar5211_set_rx_monitor(hal)
d1497 1
a1497 2
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_RX_FILTER,
	    AR5K_AR5211_RX_FILTER_PROMISC);
@


1.13
log
@fix silicon version number reporting. ie. ath0: mac 80.6 -> ath0: mac 5.6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.12 2005/04/20 01:46:02 reyk Exp $	*/
d2108 1
d2111 2
d2115 3
d2122 1
d2130 1
d2154 2
a2157 2
	case HAL_PM_NETWORK_SLEEP:
	case HAL_PM_UNDEFINED:
d2165 1
a2165 4
	AR5K_REG_DISABLE_BITS(AR5K_AR5211_STA_ID1,
	    AR5K_AR5211_STA_ID1_DEFAULT_ANTENNA);
	AR5K_REG_ENABLE_BITS(AR5K_AR5211_STA_ID1,
	    AR5K_AR5211_STA_ID1_PWR_SV);
@


1.12
log
@support 11b and 11a mode on the ar5211. "pure" 11g mode is not yet
tested but should work as well. thanks for the hardware donation!
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.11 2005/04/18 18:42:55 reyk Exp $	*/
d200 3
a202 3
	srev = AR5K_REG_READ(AR5K_AR5211_SREV) & AR5K_AR5211_SREV_M;
	hal->ah_mac_version = srev & AR5K_AR5211_SREV_VERSION;
	hal->ah_mac_revision = srev & AR5K_AR5211_SREV_REVISION;
@


1.11
log
@beautify the code by renaming HAL functions with capitalized words (i
always wanted to do that). this breaks HAL compatibility but porting
should be easy, have a look at athvar.h. no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.10 2005/04/08 22:12:21 reyk Exp $	*/
d32 2
d42 2
a404 3
	if (hal->ah_rf_banks != NULL)
		free(hal->ah_rf_banks, M_DEVBUF);

d473 5
d2626 65
@


1.10
log
@move reset of HAL descriptors to ath.c
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.9 2005/04/08 22:02:49 reyk Exp $	*/
d52 1
a52 1
	AR5K_HAL_FUNCTION(hal, ar5211, getRateTable);
d59 2
a60 2
	AR5K_HAL_FUNCTION(hal, ar5211, setPCUConfig);
	AR5K_HAL_FUNCTION(hal, ar5211, perCalibration);
d65 14
a78 14
	AR5K_HAL_FUNCTION(hal, ar5211, updateTxTrigLevel);
	AR5K_HAL_FUNCTION(hal, ar5211, setupTxQueue);
	AR5K_HAL_FUNCTION(hal, ar5211, setTxQueueProps);
	AR5K_HAL_FUNCTION(hal, ar5211, releaseTxQueue);
	AR5K_HAL_FUNCTION(hal, ar5211, resetTxQueue);
	AR5K_HAL_FUNCTION(hal, ar5211, getTxDP);
	AR5K_HAL_FUNCTION(hal, ar5211, setTxDP);
	AR5K_HAL_FUNCTION(hal, ar5211, startTxDma);
	AR5K_HAL_FUNCTION(hal, ar5211, stopTxDma);
	AR5K_HAL_FUNCTION(hal, ar5211, setupTxDesc);
	AR5K_HAL_FUNCTION(hal, ar5211, setupXTxDesc);
	AR5K_HAL_FUNCTION(hal, ar5211, fillTxDesc);
	AR5K_HAL_FUNCTION(hal, ar5211, procTxDesc);
	AR5K_HAL_FUNCTION(hal, ar5211, hasVEOL);
d83 14
a96 14
	AR5K_HAL_FUNCTION(hal, ar5211, getRxDP);
	AR5K_HAL_FUNCTION(hal, ar5211, setRxDP);
	AR5K_HAL_FUNCTION(hal, ar5211, enableReceive);
	AR5K_HAL_FUNCTION(hal, ar5211, stopDmaReceive);
	AR5K_HAL_FUNCTION(hal, ar5211, startPcuReceive);
	AR5K_HAL_FUNCTION(hal, ar5211, stopPcuReceive);
	AR5K_HAL_FUNCTION(hal, ar5211, setMulticastFilter);
	AR5K_HAL_FUNCTION(hal, ar5211, setMulticastFilterIndex);
	AR5K_HAL_FUNCTION(hal, ar5211, clrMulticastFilterIndex);
	AR5K_HAL_FUNCTION(hal, ar5211, getRxFilter);
	AR5K_HAL_FUNCTION(hal, ar5211, setRxFilter);
	AR5K_HAL_FUNCTION(hal, ar5211, setupRxDesc);
	AR5K_HAL_FUNCTION(hal, ar5211, procRxDesc);
	AR5K_HAL_FUNCTION(hal, ar5211, rxMonitor);
d101 25
a125 25
	AR5K_HAL_FUNCTION(hal, ar5211, dumpState);
	AR5K_HAL_FUNCTION(hal, ar5211, getDiagState);
	AR5K_HAL_FUNCTION(hal, ar5211, getMacAddress);
	AR5K_HAL_FUNCTION(hal, ar5211, setMacAddress);
	AR5K_HAL_FUNCTION(hal, ar5211, setRegulatoryDomain);
	AR5K_HAL_FUNCTION(hal, ar5211, setLedState);
	AR5K_HAL_FUNCTION(hal, ar5211, writeAssocid);
	AR5K_HAL_FUNCTION(hal, ar5211, gpioCfgInput);
	AR5K_HAL_FUNCTION(hal, ar5211, gpioCfgOutput);
	AR5K_HAL_FUNCTION(hal, ar5211, gpioGet);
	AR5K_HAL_FUNCTION(hal, ar5211, gpioSet);
	AR5K_HAL_FUNCTION(hal, ar5211, gpioSetIntr);
	AR5K_HAL_FUNCTION(hal, ar5211, getTsf32);
	AR5K_HAL_FUNCTION(hal, ar5211, getTsf64);
	AR5K_HAL_FUNCTION(hal, ar5211, resetTsf);
	AR5K_HAL_FUNCTION(hal, ar5211, getRegDomain);
	AR5K_HAL_FUNCTION(hal, ar5211, detectCardPresent);
	AR5K_HAL_FUNCTION(hal, ar5211, updateMibCounters);
	AR5K_HAL_FUNCTION(hal, ar5211, getRfGain);
	AR5K_HAL_FUNCTION(hal, ar5211, setSlotTime);
	AR5K_HAL_FUNCTION(hal, ar5211, getSlotTime);
	AR5K_HAL_FUNCTION(hal, ar5211, setAckTimeout);
	AR5K_HAL_FUNCTION(hal, ar5211, getAckTimeout);
	AR5K_HAL_FUNCTION(hal, ar5211, setCTSTimeout);
	AR5K_HAL_FUNCTION(hal, ar5211, getCTSTimeout);
d130 6
a135 6
	AR5K_HAL_FUNCTION(hal, ar5211, isHwCipherSupported);
	AR5K_HAL_FUNCTION(hal, ar5211, getKeyCacheSize);
	AR5K_HAL_FUNCTION(hal, ar5211, resetKeyCacheEntry);
	AR5K_HAL_FUNCTION(hal, ar5211, isKeyCacheEntryValid);
	AR5K_HAL_FUNCTION(hal, ar5211, setKeyCacheEntry);
	AR5K_HAL_FUNCTION(hal, ar5211, setKeyCacheEntryMac);
d140 6
a145 6
	AR5K_HAL_FUNCTION(hal, ar5211, setPowerMode);
	AR5K_HAL_FUNCTION(hal, ar5211, getPowerMode);
	AR5K_HAL_FUNCTION(hal, ar5211, queryPSPollSupport);
	AR5K_HAL_FUNCTION(hal, ar5211, initPSPoll);
	AR5K_HAL_FUNCTION(hal, ar5211, enablePSPoll);
	AR5K_HAL_FUNCTION(hal, ar5211, disablePSPoll);
d150 4
a153 4
	AR5K_HAL_FUNCTION(hal, ar5211, beaconInit);
	AR5K_HAL_FUNCTION(hal, ar5211, setStationBeaconTimers);
	AR5K_HAL_FUNCTION(hal, ar5211, resetStationBeaconTimers);
	AR5K_HAL_FUNCTION(hal, ar5211, waitForBeaconDone);
d158 4
a161 4
	AR5K_HAL_FUNCTION(hal, ar5211, isInterruptPending);
	AR5K_HAL_FUNCTION(hal, ar5211, getPendingInterrupts);
	AR5K_HAL_FUNCTION(hal, ar5211, getInterrupts);
	AR5K_HAL_FUNCTION(hal, ar5211, setInterrupts);
d216 3
a218 3
	ar5k_ar5211_writeAssocid(hal, mac, 0, 0);
	ar5k_ar5211_getMacAddress(hal, mac);
	ar5k_ar5211_setPCUConfig(hal);
d313 1
a313 1
	if (ar5k_ar5211_setPowerMode(hal,
d376 1
a376 1
ar5k_ar5211_getRateTable(hal, mode)
d570 2
a571 2
	ar5k_ar5211_writeAssocid(hal, mac, 0, 0);
	ar5k_ar5211_setPCUConfig(hal);
d615 1
a615 1
		if (ar5k_ar5211_resetTxQueue(hal, i) == AH_FALSE) {
d622 1
a622 1
	ar5k_ar5211_setInterrupts(hal, HAL_INT_RX | HAL_INT_TX | HAL_INT_FATAL);
d628 3
a630 3
		ar5k_ar5211_gpioCfgInput(hal, 0);
		if ((hal->ah_gpio[0] = ar5k_ar5211_gpioGet(hal, 0)) == 0)
			ar5k_ar5211_gpioSetIntr(hal, 0, 1);
d632 1
a632 1
			ar5k_ar5211_gpioSetIntr(hal, 0, 0);
d645 1
a645 1
ar5k_ar5211_setPCUConfig(hal)
d684 1
a684 1
ar5k_ar5211_perCalibration(hal, channel)
d728 1
a728 1
ar5k_ar5211_updateTxTrigLevel(hal, increase)
d738 1
a738 1
	imr = ar5k_ar5211_setInterrupts(hal, hal->ah_imr & ~HAL_INT_GLOBAL);
d761 1
a761 1
	ar5k_ar5211_setInterrupts(hal, imr);
d767 1
a767 1
ar5k_ar5211_setupTxQueue(hal, queue_type, queue_info)
d799 1
a799 1
		if (ar5k_ar5211_setTxQueueProps(hal, queue, queue_info)
d810 1
a810 1
ar5k_ar5211_setTxQueueProps(hal, queue, queue_info)
d832 1
a832 1
ar5k_ar5211_releaseTxQueue(hal, queue)
d846 1
a846 1
ar5k_ar5211_resetTxQueue(hal, queue)
d1024 1
a1024 1
ar5k_ar5211_getTxDP(hal, queue)
d1037 1
a1037 1
ar5k_ar5211_setTxDP(hal, queue, phys_addr)
d1057 1
a1057 1
ar5k_ar5211_startTxDma(hal, queue)
d1074 1
a1074 1
ar5k_ar5211_stopTxDma(hal, queue)
d1100 2
a1101 2
ar5k_ar5211_setupTxDesc(hal, desc, packet_length, header_length, type, tx_power,
    tx_rate0, tx_tries0, key_index, antenna_mode, flags, rtscts_rate,
d1137 1
a1137 1
#define _TX_FLAGS(_c, _flag)	 					\
d1139 1
a1139 1
		tx_desc->tx_control_##_c |=    				\
d1165 1
a1165 1
ar5k_ar5211_fillTxDesc(hal, desc, segment_length, first_segment, last_segment)
d1194 1
a1194 1
ar5k_ar5211_setupXTxDesc(hal, desc, tx_rate1, tx_tries1, tx_rate2, tx_tries2,
d1209 1
a1209 1
ar5k_ar5211_procTxDesc(hal, desc)
d1266 1
a1266 1
ar5k_ar5211_hasVEOL(hal)
d1277 1
a1277 1
ar5k_ar5211_getRxDP(hal)
d1284 1
a1284 1
ar5k_ar5211_setRxDP(hal, phys_addr)
d1292 1
a1292 1
ar5k_ar5211_enableReceive(hal)
d1299 1
a1299 1
ar5k_ar5211_stopDmaReceive(hal)
d1318 1
a1318 1
ar5k_ar5211_startPcuReceive(hal)
d1325 1
a1325 1
ar5k_ar5211_stopPcuReceive(hal)
d1332 1
a1332 1
ar5k_ar5211_setMulticastFilter(hal, filter0, filter1)
d1343 1
a1343 1
ar5k_ar5211_setMulticastFilterIndex(hal, index)
d1361 1
a1361 1
ar5k_ar5211_clrMulticastFilterIndex(hal, index)
d1380 1
a1380 1
ar5k_ar5211_getRxFilter(hal)
d1387 1
a1387 1
ar5k_ar5211_setRxFilter(hal, filter)
d1395 1
a1395 1
ar5k_ar5211_setupRxDesc(hal, desc, size, flags)
d1416 1
a1416 1
ar5k_ar5211_procRxDesc(hal, desc, phys_addr, next)
d1488 1
a1488 1
ar5k_ar5211_rxMonitor(hal)
d1500 1
a1500 1
ar5k_ar5211_dumpState(hal)
d1590 1
a1590 1
ar5k_ar5211_getDiagState(hal, id, device, size)
d1605 1
a1605 1
ar5k_ar5211_getMacAddress(hal, mac)
d1613 1
a1613 1
ar5k_ar5211_setMacAddress(hal, mac)
d1633 1
a1633 1
ar5k_ar5211_setRegulatoryDomain(hal, regdomain, status)
d1655 1
a1655 1
ar5k_ar5211_setLedState(hal, state)
d1695 1
a1695 1
ar5k_ar5211_writeAssocid(hal, bssid, assoc_id, tim_offset)
d1714 1
a1714 1
		ar5k_ar5211_disablePSPoll(hal);
d1725 1
a1725 1
	ar5k_ar5211_enablePSPoll(hal, NULL, 0);
d1729 1
a1729 1
ar5k_ar5211_gpioCfgOutput(hal, gpio)
d1744 1
a1744 1
ar5k_ar5211_gpioCfgInput(hal, gpio)
d1759 1
a1759 1
ar5k_ar5211_gpioGet(hal, gpio)
d1772 1
a1772 1
ar5k_ar5211_gpioSet(hal, gpio, val)
d1794 1
a1794 1
ar5k_ar5211_gpioSetIntr(hal, gpio, interrupt_level)
d1822 1
a1822 1
ar5k_ar5211_getTsf32(hal)
d1829 1
a1829 1
ar5k_ar5211_getTsf64(hal)
d1838 1
a1838 1
ar5k_ar5211_resetTsf(hal)
d1846 1
a1846 1
ar5k_ar5211_getRegDomain(hal)
d1853 1
a1853 1
ar5k_ar5211_detectCardPresent(hal)
d1870 1
a1870 1
ar5k_ar5211_updateMibCounters(hal, statistics)
d1882 1
a1882 1
ar5k_ar5211_getRfGain(hal)
d1889 1
a1889 1
ar5k_ar5211_setSlotTime(hal, slot_time)
d1903 1
a1903 1
ar5k_ar5211_getSlotTime(hal)
d1911 1
a1911 1
ar5k_ar5211_setAckTimeout(hal, timeout)
d1926 1
a1926 1
ar5k_ar5211_getAckTimeout(hal)
d1934 1
a1934 1
ar5k_ar5211_setCTSTimeout(hal, timeout)
d1949 1
a1949 1
ar5k_ar5211_getCTSTimeout(hal)
d1961 1
a1961 1
ar5k_ar5211_isHwCipherSupported(hal, cipher)
d1975 1
a1975 1
ar5k_ar5211_getKeyCacheSize(hal)
d1982 1
a1982 1
ar5k_ar5211_resetKeyCacheEntry(hal, entry)
d1997 1
a1997 1
ar5k_ar5211_isKeyCacheEntryValid(hal, entry)
d2014 1
a2014 1
ar5k_ar5211_setKeyCacheEntry(hal, entry, keyval, mac, xor_notused)
d2061 1
a2061 1
	return (ar5k_ar5211_setKeyCacheEntryMac(hal, entry, mac));
d2065 1
a2065 1
ar5k_ar5211_setKeyCacheEntryMac(hal, entry, mac)
d2096 1
a2096 1
ar5k_ar5211_setPowerMode(hal, mode, set_chip, sleep_duration)
d2160 1
a2160 1
ar5k_ar5211_getPowerMode(hal)
d2167 1
a2167 1
ar5k_ar5211_queryPSPollSupport(hal)
d2175 1
a2175 1
ar5k_ar5211_initPSPoll(hal)
d2185 1
a2185 1
ar5k_ar5211_enablePSPoll(hal, bssid, assoc_id)
d2194 1
a2194 1
ar5k_ar5211_disablePSPoll(hal)
d2205 1
a2205 1
ar5k_ar5211_beaconInit(hal, next_beacon, interval)
d2246 1
a2246 1
ar5k_ar5211_setStationBeaconTimers(hal, state, tsf, dtim_count, cfp_count)
d2313 1
a2313 1
ar5k_ar5211_resetStationBeaconTimers(hal)
d2330 1
a2330 1
ar5k_ar5211_waitForBeaconDone(hal, phys_addr)
d2354 1
a2354 1
ar5k_ar5211_isInterruptPending(hal)
d2361 1
a2361 1
ar5k_ar5211_getPendingInterrupts(hal, interrupt_mask)
d2400 1
a2400 1
ar5k_ar5211_getInterrupts(hal)
d2408 1
a2408 1
ar5k_ar5211_setInterrupts(hal, new_mask)
@


1.9
log
@bye bye unportable bitfields
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.8 2005/04/06 09:14:53 reyk Exp $	*/
a1120 3
	/* Clear descriptor */
	bzero(tx_desc, sizeof(struct ar5k_ar5211_tx_desc));

a1401 5

	/* Reset descriptor */
	desc->ds_ctl0 = 0;
	desc->ds_ctl1 = 0;
	bzero(&desc->ds_hw[0], sizeof(struct ar5k_ar5211_rx_status));
@


1.8
log
@pad keys with zeros to a supported key length. this is bad but seems
to be the default WEP behaviour for string-based keys and allows
commands like "ifconfig ath0 nwkey yuck" to work...
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.7 2005/03/23 16:23:18 reyk Exp $	*/
d1130 2
a1131 1
	if ((tx_desc->frame_len = packet_length) != packet_length)
d1134 16
a1149 12
	tx_desc->frame_type = type;
	tx_desc->xmit_rate = tx_rate0;
	tx_desc->ant_mode_xmit = antenna_mode;

#define _TX_FLAGS(_flag, _field) \
	tx_desc->_field = flags & HAL_TXDESC_##_flag ? 1 : 0

	_TX_FLAGS(CLRDMASK, clear_dest_mask);
	_TX_FLAGS(VEOL, veol);
	_TX_FLAGS(INTREQ, inter_req);
	_TX_FLAGS(NOACK, no_ack);
	_TX_FLAGS(RTSENA, rts_cts_enable);
d1157 5
a1161 2
		tx_desc->encrypt_key_valid = 1;
		tx_desc->encrypt_key_index = key_index;
d1183 2
a1184 1
	if ((tx_desc->buf_len = segment_length) != segment_length)
d1188 1
a1188 1
		tx_desc->frame_len = 0;
d1190 2
a1191 1
	tx_desc->more = last_segment == AH_TRUE ? 0 : 1;
d1223 1
a1223 1
	if (tx_status->done == 0)
d1229 16
a1244 8
	desc->ds_us.tx.ts_seqnum = tx_status->seq_num;
	desc->ds_us.tx.ts_tstamp = tx_status->send_timestamp;
	desc->ds_us.tx.ts_shortretry = tx_status->rts_fail_count ?
	    (tx_status->rts_fail_count + 1) : 0;
	desc->ds_us.tx.ts_longretry = tx_status->data_fail_count ?
	    (tx_status->data_fail_count + 1) : 0;
	desc->ds_us.tx.ts_rssi = tx_status->ack_sig_strength;
	desc->ds_us.tx.ts_antenna = 0;
d1246 8
a1253 4
	desc->ds_us.tx.ts_rate = tx_desc->xmit_rate;

	if (tx_status->frame_xmit_ok == 0) {
		if (tx_status->excessive_retries)
d1256 2
a1257 1
		if (tx_status->fifo_underrun)
d1260 2
a1261 1
		if (tx_status->filtered)
d1413 2
a1414 1
	if ((rx_desc->buf_len = size) != size)
d1418 1
a1418 1
		rx_desc->inter_req = 1;
a1429 1
	u_int32_t now, tstamp;
d1435 1
a1435 1
	if (!rx_status->done)
d1441 15
a1455 11
	now = (AR5K_REG_READ(AR5K_AR5211_TSF_L32) >> 10) & 0xffff;
	tstamp = ((now & 0x1fff) < rx_status->receive_timestamp) ?
	    (((now - 0x2000) & 0xffff) |
	    (u_int32_t)rx_status->receive_timestamp) :
	    (now | (u_int32_t)rx_status->receive_timestamp);
	desc->ds_us.rx.rs_tstamp = rx_status->receive_timestamp & 0x7fff;
	desc->ds_us.rx.rs_datalen = rx_status->data_len;
	desc->ds_us.rx.rs_rssi = rx_status->receive_sig_strength;
	desc->ds_us.rx.rs_rate = rx_status->receive_rate;
	desc->ds_us.rx.rs_antenna = rx_status->receive_antenna ? 1 : 0;
	desc->ds_us.rx.rs_more = rx_status->more ? 1 : 0;
d1461 6
a1466 1
	if (!rx_status->key_index_valid) {
a1467 2
	} else {
		desc->ds_us.rx.rs_keyix = rx_status->key_index;
d1473 4
a1476 2
	if (!rx_status->frame_receive_ok) {
		if (rx_status->crc_error)
d1479 2
a1480 1
		if (rx_status->phy_error) {
d1482 3
a1484 1
			desc->ds_us.rx.rs_phyerr = rx_status->phy_error;
d1487 2
a1488 1
		if (rx_status->decrypt_crc_error)
@


1.7
log
@fix a possible kernel panic in the ar5211 and ar5212 detach functions.
closes PR #4153.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.6 2005/03/20 04:21:55 reyk Exp $	*/
d2000 1
a2000 1
	case 5:
d2006 1
a2006 1
	case 13:
d2015 1
a2015 1
	case 16:
@


1.6
log
@some fixes for wep and reset.

btw.: this is a commit using an ar5212 in 11b mode...

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.5 2005/03/19 17:27:46 reyk Exp $	*/
d402 1
a402 1
		free(hal, M_DEVBUF);
@


1.5
log
@further fixes for ar5212.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.4 2005/03/13 18:32:21 reyk Exp $	*/
d1949 1
a1949 1
	return (AR5K_AR5211_KEYTABLE_SIZE);
d1962 1
a1962 1
		AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE(entry) + (i * 4), 0);
a1971 2
	int offset;

d1977 1
a1977 2
	offset = (AR5K_AR5211_KEYCACHE_SIZE - 1) * 4;
	if (AR5K_REG_READ(AR5K_AR5211_KEYTABLE(entry) + offset) &
d1979 1
a1979 1
		return AH_TRUE;
d1992 1
a1992 1
	int elements = AR5K_AR5211_KEYCACHE_SIZE - 2;
a1993 1
	int i, offset = 0;
d1997 2
a1998 3
	/*
	 * Store the key type in the last field
	 */
d2001 3
a2003 1
		key_v[elements - 1] = AR5K_AR5211_KEYTABLE_TYPE_40;
d2007 6
a2012 1
		key_v[elements - 1] = AR5K_AR5211_KEYTABLE_TYPE_104;
d2016 6
a2021 1
		key_v[elements - 1] = AR5K_AR5211_KEYTABLE_TYPE_128;
d2029 2
a2030 22
	/*
	 * Write key cache entry
	 */
	for (i = 0; i < elements; i++) {
		if (elements < 5) {
			if (i % 2) {
				key_v[i] = AR5K_LE_READ_2(keyval->wk_key +
				    offset) & 0xffff;
				offset += 2;
			} else {
				key_v[i] = AR5K_LE_READ_4(keyval->wk_key +
				    offset);
				offset += 4;
			}

			if (i == 4 && keyval->wk_len <= 13)
				key_v[i] &= 0xff;
		}

		/* Write value */
		AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE(entry) + (i * 4), key_v[i]);
	}
d2042 1
a2042 1
	int offset;
a2048 3
	offset = AR5K_AR5211_KEYCACHE_SIZE - 2;
	low_id = high_id = 0;

d2050 1
a2050 4
	if (mac != NULL) {
		bcopy(mac, &low_id, 4);
		bcopy(mac + 4, &high_id, 2);
	}
d2052 3
a2054 1
	high_id = 0x0000ffff & htole32(high_id);
d2056 2
a2057 3
	AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE(entry) + (offset++ * 4),
	    htole32(low_id));
	AR5K_REG_WRITE(AR5K_AR5211_KEYTABLE(entry) + (offset * 4), high_id);
@


1.4
log
@the wep mac may be NULL if it's a broadcast key

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.3 2005/03/10 08:30:56 reyk Exp $	*/
d401 3
d420 1
a420 1
	u_int32_t data;
d423 16
d472 9
d489 1
a494 8
	 * Write initial mode settings
	 */
	for (i = 0; i < AR5K_ELEMENTS(ar5211_mode); i++) {
		AR5K_REG_WRITE((u_int32_t)ar5211_mode[i].mode_register,
		    ar5211_mode[i].mode_value[mode]);
	}

	/*
d557 12
a568 1
	/* Misc */
@


1.3
log
@fix beacon handling
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.2 2005/03/03 16:39:54 reyk Exp $	*/
d2031 1
d2033 5
a2037 3
	/* XXX big endian problems? */
	bcopy(mac, &low_id, 4);
	bcopy(mac + 4, &high_id, 2);
@


1.2
log
@improve radiotap support, fix some minor bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5211.c,v 1.1 2005/02/25 22:25:30 reyk Exp $	*/
d215 1
a215 1
	memset(&mac, 0xff, sizeof(mac));
d537 1
a537 1
	memset(&mac, 0xff, sizeof(mac));
d643 2
a644 2
	memcpy(&low_id, &(hal->ah_sta_id[0]), 4);
	memcpy(&high_id, &(hal->ah_sta_id[4]), 2);
d1058 3
d1140 1
a1140 1
	desc->ds_hw[0] = desc->ds_hw[1] = 0;
d1442 84
a1525 2
	/* Not used */
	return;
d1548 1
a1548 1
	memcpy(mac, hal->ah_sta_id, IEEE80211_ADDR_LEN);
d1559 1
a1559 1
	memcpy(hal->ah_sta_id, mac, IEEE80211_ADDR_LEN);
d1561 2
a1562 2
	memcpy(&low_id, mac, 4);
	memcpy(&high_id, mac + 4, 2);
d1645 2
a1646 2
	memcpy(&low_id, bssid, 4);
	memcpy(&high_id, bssid + 4, 2);
d1650 1
a1650 1
	memcpy(&hal->ah_bssid, bssid, IEEE80211_ADDR_LEN);
d2256 8
a2263 6
	if ((state->bs_bmiss_threshold > (AR5K_AR5211_RSSI_THR_BMISS >>
	    AR5K_AR5211_RSSI_THR_BMISS_S)) &&
	    (state->bs_bmiss_threshold & 0x00007) != 0) {
		AR5K_REG_WRITE_BITS(AR5K_AR5211_RSSI_THR_M,
		    AR5K_AR5211_RSSI_THR_BMISS, state->bs_bmiss_threshold);
	}
d2294 1
a2294 1
	    AR5K_AR5211_QCU_STS(HAL_TX_QUEUE_BEACON),
d2296 3
@


1.1
log
@add support for the atheros ar5211 802.11A/B/g wireless chipset.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d835 1
a835 1
		hal->ah_cw_max = AR5K_TUNE_CWMAX_11B;
d839 1
a839 1
		hal->ah_cw_max = AR5K_TUNE_CWMAX;
d859 5
a863 5
		AR5K_AR5211_DCU_RETRY_LMT_SLG_RETRY)
	    | AR5K_REG_SM(AR5K_INIT_SSH_RETRY,
		AR5K_AR5211_DCU_RETRY_LMT_SSH_RETRY)
	    | AR5K_REG_SM(retry_lg, AR5K_AR5211_DCU_RETRY_LMT_LG_RETRY)
	    | AR5K_REG_SM(retry_sh, AR5K_AR5211_DCU_RETRY_LMT_SH_RETRY));
d1524 1
a1524 2
		led =
		    AR5K_AR5211_PCICFG_LEDMODE_PROP |
d1529 1
a1529 2
		led =
		    AR5K_AR5211_PCICFG_LEDMODE_PROP |
d1535 1
a1535 2
		led |=
		    AR5K_AR5211_PCICFG_LEDMODE_PROP |
d1540 1
a1540 2
		led |=
		    AR5K_AR5211_PCICFG_LEDMODE_PROM |
@

