head	1.115;
access;
symbols
	OPENBSD_6_2:1.115.0.2
	OPENBSD_6_2_BASE:1.115
	OPENBSD_6_1:1.113.0.4
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.112.0.4
	OPENBSD_6_0_BASE:1.112
	OPENBSD_5_9:1.111.0.2
	OPENBSD_5_9_BASE:1.111
	OPENBSD_5_8:1.106.0.4
	OPENBSD_5_8_BASE:1.106
	OPENBSD_5_7:1.105.0.2
	OPENBSD_5_7_BASE:1.105
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.97.0.4
	OPENBSD_5_5_BASE:1.97
	OPENBSD_5_4:1.95.0.4
	OPENBSD_5_4_BASE:1.95
	OPENBSD_5_3:1.95.0.2
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.93.0.4
	OPENBSD_5_2_BASE:1.93
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.6
	OPENBSD_5_0:1.93.0.2
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.92.0.2
	OPENBSD_4_9_BASE:1.92
	OPENBSD_4_8:1.91.0.2
	OPENBSD_4_8_BASE:1.91
	OPENBSD_4_7:1.89.0.2
	OPENBSD_4_7_BASE:1.89
	OPENBSD_4_6:1.87.0.4
	OPENBSD_4_6_BASE:1.87
	OPENBSD_4_5:1.86.0.2
	OPENBSD_4_5_BASE:1.86
	OPENBSD_4_4:1.84.0.2
	OPENBSD_4_4_BASE:1.84
	OPENBSD_4_3:1.81.0.2
	OPENBSD_4_3_BASE:1.81
	OPENBSD_4_2:1.72.0.2
	OPENBSD_4_2_BASE:1.72
	OPENBSD_4_1:1.63.0.2
	OPENBSD_4_1_BASE:1.63;
locks; strict;
comment	@ * @;


1.115
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.114;
commitid	uRv5pa9QDlZaYgwD;

1.114
date	2017.04.04.04.38.31;	author deraadt;	state Exp;
branches;
next	1.113;
commitid	6lK7PmXfXsReiBx0;

1.113
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.112;
commitid	VyLWTsbepAOk7VQM;

1.112
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.111;
commitid	QHiEhS9DHyE6oiIr;

1.111
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.110;
commitid	B0kwmVGiD5DVx4kv;

1.110
date	2015.11.16.10.03.01;	author mpi;	state Exp;
branches;
next	1.109;
commitid	qeJg4odGyshncgKG;

1.109
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.108;
commitid	YT6fyIEviv9qwbl6;

1.108
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.107;
commitid	p0v5tuE1Ch6fY0Nj;

1.107
date	2015.09.09.18.23.55;	author deraadt;	state Exp;
branches;
next	1.106;
commitid	pxEWup0rbECbQnbF;

1.106
date	2015.07.06.07.20.03;	author stsp;	state Exp;
branches;
next	1.105;
commitid	MHhBGJ6gvnfQYCo6;

1.105
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.104;
commitid	Hly9lJn6CNMylcFu;

1.104
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.103;
commitid	yM2VFFhpDTeFQlve;

1.103
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.102;
commitid	LS2TNeCue5R9L67C;

1.102
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.101;
commitid	uzzBR7hz9ncd4O6G;

1.101
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.100;
commitid	TGHgrLxu6sxZoiFt;

1.100
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.99;
commitid	JtO5uXxVcnZfhUkR;

1.99
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.98;
commitid	I19imNlAX05zJOED;

1.98
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.97;

1.97
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2013.11.14.12.21.13;	author dlg;	state Exp;
branches;
next	1.95;

1.95
date	2012.12.05.23.20.18;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2012.09.04.19.01.33;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2011.07.03.21.35.38;	author dhill;	state Exp;
branches;
next	1.92;

1.92
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.91;

1.91
date	2010.08.08.16.36.33;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.89;

1.89
date	2009.07.12.18.24.23;	author mglocker;	state Exp;
branches;
next	1.88;

1.88
date	2009.07.10.07.34.02;	author blambert;	state Exp;
branches;
next	1.87;

1.87
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.86;

1.86
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.85;

1.85
date	2008.08.14.16.02.24;	author damien;	state Exp;
branches;
next	1.84;

1.84
date	2008.07.27.11.28.17;	author mbalmer;	state Exp;
branches;
next	1.83;

1.83
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.82;

1.82
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.10.14.20.15;	author mglocker;	state Exp;
branches;
next	1.80;

1.80
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2007.08.28.17.04.18;	author mglocker;	state Exp;
branches;
next	1.77;

1.77
date	2007.08.27.19.11.13;	author mglocker;	state Exp;
branches;
next	1.76;

1.76
date	2007.08.26.08.49.55;	author mglocker;	state Exp;
branches;
next	1.75;

1.75
date	2007.08.25.23.59.11;	author mglocker;	state Exp;
branches;
next	1.74;

1.74
date	2007.08.25.20.57.12;	author mglocker;	state Exp;
branches;
next	1.73;

1.73
date	2007.08.25.20.55.04;	author mglocker;	state Exp;
branches;
next	1.72;

1.72
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.29.18.03.25;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.25.18.31.02;	author mglocker;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.09.19.34.07;	author mglocker;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.05.14.41.14;	author jsg;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.03.15.06.09;	author mglocker;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.20.17.08.34;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2007.04.17.19.45.20;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2007.03.14.08.23.09;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2007.02.14.20.52.26;	author mglocker;	state Exp;
branches;
next	1.62;

1.62
date	2007.02.09.10.35.43;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2006.12.31.16.58.02;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2006.12.31.16.50.31;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2006.12.31.16.42.37;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2006.12.31.16.35.49;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.31.16.32.44;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.31.16.27.55;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2006.12.30.23.31.26;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2006.12.30.22.43.01;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2006.12.30.01.10.16;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2006.12.29.20.27.50;	author mglocker;	state Exp;
branches;
next	1.51;

1.51
date	2006.12.12.10.06.29;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.10.21.01.53;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.03.10.30.47;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.03.10.14.39;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.30.17.23.34;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2006.11.30.08.20.25;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.29.21.39.46;	author mglocker;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.29.12.51.29;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.28.09.55.57;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.27.15.32.12;	author mglocker;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.26.23.46.47;	author mglocker;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.26.14.50.39;	author mglocker;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.26.11.14.18;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.25.14.20.48;	author mglocker;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.25.10.52.45;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.24.23.29.39;	author mglocker;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.24.23.28.24;	author mglocker;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.24.20.45.33;	author mglocker;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.23.22.03.07;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.23.20.19.19;	author mglocker;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.22.22.06.48;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.21.22.06.26;	author mglocker;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.16.21.18.42;	author mglocker;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.16.15.11.01;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.15.21.44.04;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.15.16.27.37;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.15.13.18.26;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.12.14.54.58;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.12.14.26.04;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.12.14.18.29;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.10.22.29.44;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.09.10.25.12;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.07.21.39.32;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.06.23.03.44;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.06.19.00.49;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.29.16.43.34;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.29.16.41.35;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.29.16.14.56;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.29.16.00.49;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.29.11.41.34;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.25.20.42.57;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.24.19.20.01;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2006.10.22.00.18.42;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.21.23.16.34;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.17.21.23.32;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.17.19.40.39;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.17.10.31.26;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.15.21.56.49;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.15.20.33.39;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.15.20.07.31;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.15.19.55.47;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.115
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: malo.c,v 1.114 2017/04/04 04:38:31 deraadt Exp $ */

/*
 * Copyright (c) 2006 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2006 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bpfilter.h"

#include <sys/param.h>

#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/systm.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/malo.h>

#ifdef MALO_DEBUG
int malo_d = 1;
#define DPRINTF(l, x...)	do { if ((l) <= malo_d) printf(x); } while (0)
#else
#define DPRINTF(l, x...)
#endif

/* internal structures and defines */
struct malo_node {
	struct ieee80211_node		ni;
};

struct malo_rx_data {
	bus_dmamap_t	map;
	struct mbuf	*m;
};

struct malo_tx_data {
	bus_dmamap_t		map;
	struct mbuf		*m;
	uint32_t		softstat;
	struct ieee80211_node	*ni;
};

/* RX descriptor used by HW */
struct malo_rx_desc {
	uint8_t		rxctrl;
	uint8_t		rssi;
	uint8_t		status;
	uint8_t		channel;
	uint16_t	len;
	uint8_t		reserved1;	/* actually unused */
	uint8_t		datarate;
	uint32_t	physdata;	/* DMA address of data */
	uint32_t	physnext;	/* DMA address of next control block */
	uint16_t	qosctrl;
	uint16_t	reserved2;
} __packed;

/* TX descriptor used by HW */
struct malo_tx_desc {
	uint32_t	status;
	uint8_t		datarate;
	uint8_t		txpriority;
	uint16_t	qosctrl;
	uint32_t	physdata;	/* DMA address of data */
	uint16_t	len;
	uint8_t		destaddr[6];
	uint32_t	physnext;	/* DMA address of next control block */
	uint32_t	reserved1;	/* SAP packet info ??? */
	uint32_t	reserved2;
} __packed;

#define MALO_RX_RING_COUNT	256
#define MALO_TX_RING_COUNT	256
#define MALO_MAX_SCATTER	8	/* XXX unknown, wild guess */
#define MALO_CMD_TIMEOUT	50	/* MALO_CMD_TIMEOUT * 100us */

/*
 * Firmware commands
 */
#define MALO_CMD_GET_HW_SPEC		0x0003
#define MALO_CMD_SET_RADIO		0x001c
#define MALO_CMD_SET_AID		0x010d
#define MALO_CMD_SET_TXPOWER		0x001e
#define MALO_CMD_SET_ANTENNA		0x0020
#define MALO_CMD_SET_PRESCAN		0x0107
#define MALO_CMD_SET_POSTSCAN		0x0108
#define MALO_CMD_SET_RATE		0x0110
#define MALO_CMD_SET_CHANNEL		0x010a
#define MALO_CMD_SET_RTS		0x0113
#define MALO_CMD_SET_SLOT		0x0114
#define MALO_CMD_RESPONSE		0x8000

#define MALO_CMD_RESULT_OK		0x0000	/* everything is fine */
#define MALO_CMD_RESULT_ERROR		0x0001	/* general error */
#define MALO_CMD_RESULT_NOSUPPORT	0x0002	/* command not valid */
#define MALO_CMD_RESULT_PENDING		0x0003	/* will be processed */
#define MALO_CMD_RESULT_BUSY		0x0004	/* command ignored */
#define MALO_CMD_RESULT_PARTIALDATA	0x0005	/* buffer too small */

struct malo_cmdheader {
	uint16_t	cmd;
	uint16_t	size;		/* size of the command, incl. header */
	uint16_t	seqnum;		/* seems not to matter that much */
	uint16_t	result;		/* set to 0 on request */
	/* following the data payload, up to 256 bytes */
};

struct malo_hw_spec {
	uint16_t	HwVersion;
	uint16_t	NumOfWCB;
	uint16_t	NumOfMCastAdr;
	uint8_t		PermanentAddress[6];
	uint16_t	RegionCode;
	uint16_t	NumberOfAntenna;
	uint32_t	FWReleaseNumber;
	uint32_t	WcbBase0;
	uint32_t	RxPdWrPtr;
	uint32_t	RxPdRdPtr;
	uint32_t	CookiePtr;
	uint32_t	WcbBase1;
	uint32_t	WcbBase2;
	uint32_t	WcbBase3;
} __packed;

struct malo_cmd_radio {
	uint16_t	action;
	uint16_t	preamble_mode;
	uint16_t	enable;
} __packed;

struct malo_cmd_aid {
	uint16_t	associd;
	uint8_t		macaddr[6];
	uint32_t	gprotection;
	uint8_t		aprates[14];
} __packed;

struct malo_cmd_txpower {
	uint16_t	action;
	uint16_t	supportpowerlvl;
	uint16_t	currentpowerlvl;
	uint16_t	reserved;
	uint16_t	powerlvllist[8];
} __packed;

struct malo_cmd_antenna {
	uint16_t	action;
	uint16_t	mode;
} __packed;

struct malo_cmd_postscan {
	uint32_t	isibss;
	uint8_t		bssid[6];
} __packed;

struct malo_cmd_channel {
	uint16_t	action;
	uint8_t		channel;
} __packed;

struct malo_cmd_rate {
	uint8_t		dataratetype;
	uint8_t		rateindex;
	uint8_t		aprates[14];
} __packed;

struct malo_cmd_rts {
	uint16_t	action;
	uint32_t	threshold;
} __packed;

struct malo_cmd_slot {
	uint16_t	action;
	uint8_t		slot;
} __packed;

#define malo_mem_write4(sc, off, x) \
	bus_space_write_4((sc)->sc_mem1_bt, (sc)->sc_mem1_bh, (off), (x))
#define malo_mem_write2(sc, off, x) \
	bus_space_write_2((sc)->sc_mem1_bt, (sc)->sc_mem1_bh, (off), (x))
#define malo_mem_write1(sc, off, x) \
	bus_space_write_1((sc)->sc_mem1_bt, (sc)->sc_mem1_bh, (off), (x))

#define malo_mem_read4(sc, off) \
	bus_space_read_4((sc)->sc_mem1_bt, (sc)->sc_mem1_bh, (off))
#define malo_mem_read1(sc, off) \
	bus_space_read_1((sc)->sc_mem1_bt, (sc)->sc_mem1_bh, (off))

#define malo_ctl_write4(sc, off, x) \
	bus_space_write_4((sc)->sc_mem2_bt, (sc)->sc_mem2_bh, (off), (x))
#define malo_ctl_read4(sc, off) \
	bus_space_read_4((sc)->sc_mem2_bt, (sc)->sc_mem2_bh, (off))
#define malo_ctl_read1(sc, off) \
	bus_space_read_1((sc)->sc_mem2_bt, (sc)->sc_mem2_bh, (off))

#define malo_ctl_barrier(sc, t) \
	bus_space_barrier((sc)->sc_mem2_bt, (sc)->sc_mem2_bh, 0x0c00, 0xff, (t))

struct cfdriver malo_cd = {
	NULL, "malo", DV_IFNET
};

int	malo_alloc_cmd(struct malo_softc *sc);
void	malo_free_cmd(struct malo_softc *sc);
void	malo_send_cmd(struct malo_softc *sc, bus_addr_t addr);
int	malo_send_cmd_dma(struct malo_softc *sc, bus_addr_t addr);
int	malo_alloc_rx_ring(struct malo_softc *sc, struct malo_rx_ring *ring,
	    int count);
void	malo_reset_rx_ring(struct malo_softc *sc, struct malo_rx_ring *ring);
void	malo_free_rx_ring(struct malo_softc *sc, struct malo_rx_ring *ring);
int	malo_alloc_tx_ring(struct malo_softc *sc, struct malo_tx_ring *ring,
	    int count);
void	malo_reset_tx_ring(struct malo_softc *sc, struct malo_tx_ring *ring);
void	malo_free_tx_ring(struct malo_softc *sc, struct malo_tx_ring *ring);
int	malo_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
void	malo_start(struct ifnet *ifp);
void	malo_watchdog(struct ifnet *ifp);
int	malo_newstate(struct ieee80211com *ic, enum ieee80211_state nstate,
	    int arg);
void	malo_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni,
	    int isnew);
struct ieee80211_node *
	malo_node_alloc(struct ieee80211com *ic);
int	malo_media_change(struct ifnet *ifp);
void	malo_media_status(struct ifnet *ifp, struct ifmediareq *imr);
int	malo_chip2rate(int chip_rate);
int	malo_fix2rate(int fix_rate);
void	malo_next_scan(void *arg);
void	malo_tx_intr(struct malo_softc *sc);
int	malo_tx_mgt(struct malo_softc *sc, struct mbuf *m0,
	    struct ieee80211_node *ni);
int	malo_tx_data(struct malo_softc *sc, struct mbuf *m0,
	    struct ieee80211_node *ni);
void	malo_tx_setup_desc(struct malo_softc *sc, struct malo_tx_desc *desc,
	    int len, int rate, const bus_dma_segment_t *segs, int nsegs);
void	malo_rx_intr(struct malo_softc *sc);
int	malo_load_bootimg(struct malo_softc *sc);
int	malo_load_firmware(struct malo_softc *sc);

int	malo_set_slot(struct malo_softc *sc);
void	malo_update_slot(struct ieee80211com *ic);
#ifdef MALO_DEBUG
void	malo_hexdump(void *buf, int len);
#endif
static char *
	malo_cmd_string(uint16_t cmd);
static char *
	malo_cmd_string_result(uint16_t result);
int	malo_cmd_get_spec(struct malo_softc *sc);
int	malo_cmd_set_prescan(struct malo_softc *sc);
int	malo_cmd_set_postscan(struct malo_softc *sc, uint8_t *macaddr,
	    uint8_t ibsson);
int	malo_cmd_set_channel(struct malo_softc *sc, uint8_t channel);
int	malo_cmd_set_antenna(struct malo_softc *sc, uint16_t antenna_type);
int	malo_cmd_set_radio(struct malo_softc *sc, uint16_t mode,
	    uint16_t preamble);
int	malo_cmd_set_aid(struct malo_softc *sc, uint8_t *bssid,
	    uint16_t associd);
int	malo_cmd_set_txpower(struct malo_softc *sc, unsigned int powerlevel);
int	malo_cmd_set_rts(struct malo_softc *sc, uint32_t threshold);
int	malo_cmd_set_slot(struct malo_softc *sc, uint8_t slot);
int	malo_cmd_set_rate(struct malo_softc *sc, uint8_t rate);
void	malo_cmd_response(struct malo_softc *sc);

int
malo_intr(void *arg)
{
	struct malo_softc *sc = arg;
	uint32_t status;

	status = malo_ctl_read4(sc, 0x0c30);
	if (status == 0xffffffff || status == 0)
		/* not for us */
		return (0);

	if (status & 0x1)
		malo_tx_intr(sc);
	if (status & 0x2)
		malo_rx_intr(sc);
	if (status & 0x4) {
		/* XXX cmd done interrupt handling doesn't work yet */
		DPRINTF(1, "%s: got cmd done interrupt\n", sc->sc_dev.dv_xname);
		//malo_cmd_response(sc);
	}

	if (status & ~0x7)
		DPRINTF(1, "%s: unknown interrupt %x\n",
		    sc->sc_dev.dv_xname, status);

	/* just ack the interrupt */
	malo_ctl_write4(sc, 0x0c30, 0);

	return (1);
}

int
malo_attach(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int i;

	/* initialize channel scanning timer */
	timeout_set(&sc->sc_scan_to, malo_next_scan, sc);

	/* allocate DMA structures */
	malo_alloc_cmd(sc);
	malo_alloc_rx_ring(sc, &sc->sc_rxring, MALO_RX_RING_COUNT);
	malo_alloc_tx_ring(sc, &sc->sc_txring, MALO_TX_RING_COUNT);

	/* setup interface */
	ifp->if_softc = sc;
	ifp->if_ioctl = malo_ioctl;
	ifp->if_start = malo_start;
	ifp->if_watchdog = malo_watchdog;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

	/* set supported rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;
	sc->sc_last_txrate = -1;

	/* set channels */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_PUREG |
		    IEEE80211_CHAN_B |
		    IEEE80211_CHAN_G;
	}

	/* set the rest */
	ic->ic_caps =
	    IEEE80211_C_IBSS |
	    IEEE80211_C_MONITOR |
	    IEEE80211_C_SHPREAMBLE |
	    IEEE80211_C_SHSLOT |
	    IEEE80211_C_WEP |
	    IEEE80211_C_RSN;
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_state = IEEE80211_S_INIT;
	ic->ic_max_rssi = 75;
	for (i = 0; i < 6; i++)
		ic->ic_myaddr[i] = malo_ctl_read1(sc, 0xa528 + i);

	/* show our mac address */
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	/* attach interface */
	if_attach(ifp);
	ieee80211_ifattach(ifp);

	/* post attach vector functions */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = malo_newstate;
	ic->ic_newassoc = malo_newassoc;
	ic->ic_node_alloc = malo_node_alloc;
	ic->ic_updateslot = malo_update_slot;

	ieee80211_media_init(ifp, malo_media_change, malo_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + 64);

	sc->sc_rxtap_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(MALO_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(MALO_TX_RADIOTAP_PRESENT);
#endif

	return (0);
}

int
malo_detach(void *arg)
{
	struct malo_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	/* remove channel scanning timer */
	timeout_del(&sc->sc_scan_to);

	malo_stop(sc);
	ieee80211_ifdetach(ifp);
	if_detach(ifp);
	malo_free_cmd(sc);
	malo_free_rx_ring(sc, &sc->sc_rxring);
	malo_free_tx_ring(sc, &sc->sc_txring);

	return (0);
}

int
malo_alloc_cmd(struct malo_softc *sc)
{
	int error, nsegs;

	error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1,
	    PAGE_SIZE, 0, BUS_DMA_ALLOCNOW, &sc->sc_cmd_dmam);
	if (error != 0) {
		printf("%s: can not create DMA tag\n", sc->sc_dev.dv_xname);
		return (-1);
	}

	error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, PAGE_SIZE,
	    0, &sc->sc_cmd_dmas, 1, &nsegs, BUS_DMA_WAITOK);
	if (error != 0) {
		printf("%s: error alloc dma memory\n", sc->sc_dev.dv_xname);
		return (-1);
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->sc_cmd_dmas, nsegs,
	    PAGE_SIZE, (caddr_t *)&sc->sc_cmd_mem, BUS_DMA_WAITOK);
	if (error != 0) {
		printf("%s: error map dma memory\n", sc->sc_dev.dv_xname);
		return (-1);
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->sc_cmd_dmam,
	    sc->sc_cmd_mem, PAGE_SIZE, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: error load dma memory\n", sc->sc_dev.dv_xname);
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cmd_dmas, nsegs);
		return (-1);
	}

	sc->sc_cookie = sc->sc_cmd_mem;
	*sc->sc_cookie = htole32(0xaa55aa55);
	sc->sc_cmd_mem = (caddr_t)sc->sc_cmd_mem + sizeof(uint32_t);
	sc->sc_cookie_dmaaddr = sc->sc_cmd_dmam->dm_segs[0].ds_addr;
	sc->sc_cmd_dmaaddr = sc->sc_cmd_dmam->dm_segs[0].ds_addr +
	    sizeof(uint32_t);

	return (0);
}

void
malo_free_cmd(struct malo_softc *sc)
{
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, sc->sc_cmd_dmam);
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_cookie, PAGE_SIZE);
	bus_dmamem_free(sc->sc_dmat, &sc->sc_cmd_dmas, 1);
}

void
malo_send_cmd(struct malo_softc *sc, bus_addr_t addr)
{
	malo_ctl_write4(sc, 0x0c10, (uint32_t)addr);
	malo_ctl_barrier(sc, BUS_SPACE_BARRIER_WRITE);
	malo_ctl_write4(sc, 0x0c18, 2); /* CPU_TRANSFER_CMD */
	malo_ctl_barrier(sc, BUS_SPACE_BARRIER_WRITE);
}

int
malo_send_cmd_dma(struct malo_softc *sc, bus_addr_t addr)
{
	int i;
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;

	malo_ctl_write4(sc, 0x0c10, (uint32_t)addr);
	malo_ctl_barrier(sc, BUS_SPACE_BARRIER_WRITE);
	malo_ctl_write4(sc, 0x0c18, 2); /* CPU_TRANSFER_CMD */
	malo_ctl_barrier(sc, BUS_SPACE_BARRIER_WRITE);

	for (i = 0; i < MALO_CMD_TIMEOUT; i++) {
		delay(100);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
		if (hdr->cmd & htole16(0x8000))
			break;
	}
	if (i == MALO_CMD_TIMEOUT) {
		printf("%s: timeout while waiting for cmd response!\n",
		    sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}

	malo_cmd_response(sc);

	return (0);
}

int
malo_alloc_rx_ring(struct malo_softc *sc, struct malo_rx_ring *ring, int count)
{
	struct malo_rx_desc *desc;
	struct malo_rx_data *data;
	int i, nsegs, error;

	ring->count = count;
	ring->cur = ring->next = 0;

	error = bus_dmamap_create(sc->sc_dmat,
	    count * sizeof(struct malo_rx_desc), 1,
	    count * sizeof(struct malo_rx_desc), 0,
	    BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat,
	    count * sizeof(struct malo_rx_desc),
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    count * sizeof(struct malo_rx_desc), (caddr_t *)&ring->desc,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    count * sizeof(struct malo_rx_desc), NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ring->physaddr = ring->map->dm_segs->ds_addr;

	ring->data = mallocarray(count, sizeof (struct malo_rx_data),
	    M_DEVBUF, M_NOWAIT);
	if (ring->data == NULL) {
		printf("%s: could not allocate soft data\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}

	/*
	 * Pre-allocate Rx buffers and populate Rx ring.
	 */
	bzero(ring->data, count * sizeof (struct malo_rx_data));
	for (i = 0; i < count; i++) {
		desc = &ring->desc[i];
		data = &ring->data[i];

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &data->map);
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: could not load rx buf DMA map",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		desc->status = htole16(1);
		desc->physdata = htole32(data->map->dm_segs->ds_addr);
		desc->physnext = htole32(ring->physaddr +
		    (i + 1) % count * sizeof(struct malo_rx_desc));
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	return (0);

fail:	malo_free_rx_ring(sc, ring);
	return (error);
}

void
malo_reset_rx_ring(struct malo_softc *sc, struct malo_rx_ring *ring)
{
	int i;

	for (i = 0; i < ring->count; i++)
		ring->desc[i].status = 0;

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ring->cur = ring->next = 0;
}

void
malo_free_rx_ring(struct malo_softc *sc, struct malo_rx_ring *ring)
{
	struct malo_rx_data *data;
	int i;

	if (ring->desc != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    ring->count * sizeof(struct malo_rx_desc));
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}

	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    data->map->dm_mapsize,
				    BUS_DMASYNC_POSTREAD);
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}

			if (data->map != NULL)
				bus_dmamap_destroy(sc->sc_dmat, data->map);
		}
		free(ring->data, M_DEVBUF, 0);
	}
}

int
malo_alloc_tx_ring(struct malo_softc *sc, struct malo_tx_ring *ring,
    int count)
{
	int i, nsegs, error;

	ring->count = count;
	ring->queued = 0;
	ring->cur = ring->next = ring->stat = 0;

	error = bus_dmamap_create(sc->sc_dmat,
	    count * sizeof(struct malo_tx_desc), 1,
	    count * sizeof(struct malo_tx_desc), 0, BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat,
	    count * sizeof(struct malo_tx_desc), PAGE_SIZE, 0,
	    &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    count * sizeof(struct malo_tx_desc), (caddr_t *)&ring->desc,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    count * sizeof(struct malo_tx_desc), NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ring->physaddr = ring->map->dm_segs->ds_addr;

	ring->data = mallocarray(count, sizeof(struct malo_tx_data),
	    M_DEVBUF, M_NOWAIT);
	if (ring->data == NULL) {
		printf("%s: could not allocate soft data\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}

	memset(ring->data, 0, count * sizeof(struct malo_tx_data));
	for (i = 0; i < count; i++) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    MALO_MAX_SCATTER, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &ring->data[i].map);
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
		ring->desc[i].physnext = htole32(ring->physaddr +
		    (i + 1) % count * sizeof(struct malo_tx_desc));
	}

	return (0);

fail:	malo_free_tx_ring(sc, ring);
	return (error);
}

void
malo_reset_tx_ring(struct malo_softc *sc, struct malo_tx_ring *ring)
{
	struct malo_tx_desc *desc;
	struct malo_tx_data *data;
	int i;

	for (i = 0; i < ring->count; i++) {
		desc = &ring->desc[i];
		data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}

		/*
		 * The node has already been freed at that point so don't call
		 * ieee80211_release_node() here.
		 */
		data->ni = NULL;

		desc->status = 0;
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ring->queued = 0;
	ring->cur = ring->next = ring->stat = 0;
}

void
malo_free_tx_ring(struct malo_softc *sc, struct malo_tx_ring *ring)
{
	struct malo_tx_data *data;
	int i;

	if (ring->desc != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    ring->count * sizeof(struct malo_tx_desc));
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}

	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    data->map->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}

			/*
			 * The node has already been freed at that point so
			 * don't call ieee80211_release_node() here.
			 */
			data->ni = NULL;

			if (data->map != NULL)
				bus_dmamap_destroy(sc->sc_dmat, data->map);
		}
		free(ring->data, M_DEVBUF, 0);
	}
}

int
malo_init(struct ifnet *ifp)
{
	struct malo_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t chan;
	int error;

	DPRINTF(1, "%s: %s\n", ifp->if_xname, __func__);

	/* if interface already runs stop it first */
	if (ifp->if_flags & IFF_RUNNING)
		malo_stop(sc);

	/* power on cardbus socket */
	if (sc->sc_enable)
		sc->sc_enable(sc);

	/* disable interrupts */
	malo_ctl_read4(sc, 0x0c30);
	malo_ctl_write4(sc, 0x0c30, 0);
	malo_ctl_write4(sc, 0x0c34, 0);
	malo_ctl_write4(sc, 0x0c3c, 0);

	/* load firmware */
	if ((error = malo_load_bootimg(sc)))
		goto fail;
	if ((error = malo_load_firmware(sc)))
		goto fail;

	/* enable interrupts */
	malo_ctl_write4(sc, 0x0c34, 0x1f);
	malo_ctl_barrier(sc, BUS_SPACE_BARRIER_WRITE);
	malo_ctl_write4(sc, 0x0c3c, 0x1f);
	malo_ctl_barrier(sc, BUS_SPACE_BARRIER_WRITE);

	if ((error = malo_cmd_get_spec(sc)))
		goto fail;

	/* select default channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);

	/* initialize hardware */
	if ((error = malo_cmd_set_channel(sc, chan))) {
		printf("%s: setting channel failed!\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if ((error = malo_cmd_set_antenna(sc, 1))) {
		printf("%s: setting RX antenna failed!\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if ((error = malo_cmd_set_antenna(sc, 2))) {
		printf("%s: setting TX antenna failed!\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if ((error = malo_cmd_set_radio(sc, 1, 5))) {
		printf("%s: turn radio on failed!\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if ((error = malo_cmd_set_txpower(sc, 100))) {
		printf("%s: setting TX power failed!\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if ((error = malo_cmd_set_rts(sc, IEEE80211_RTS_MAX))) {
		printf("%s: setting RTS failed!\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ifp->if_flags |= IFF_RUNNING;

	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		/* start background scanning */
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	else
		/* in monitor mode change directly into run state */
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	return (0);

fail:
	/* reset adapter */
	DPRINTF(1, "%s: malo_init failed, resetting card\n",
	    sc->sc_dev.dv_xname);
	malo_stop(sc);
	return (error);
}

int
malo_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct malo_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;
	uint8_t chan;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) == 0)
				malo_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				malo_stop(sc);
		}
		break;
        case SIOCADDMULTI:
        case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;
	case SIOCS80211CHANNEL:
		/* allow fast channel switching in monitor mode */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING)) {
				ic->ic_bss->ni_chan = ic->ic_ibss_chan;
				chan = ieee80211_chan2ieee(ic,
				    ic->ic_bss->ni_chan);
				malo_cmd_set_channel(sc, chan);
			}
			error = 0;
		}
		break;
	default:
		error = ieee80211_ioctl(ifp, cmd, data);
		break;
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			malo_init(ifp);
		error = 0;
	}

	splx(s);

	return (error);
}

void
malo_start(struct ifnet *ifp)
{
	struct malo_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct mbuf *m0;
	struct ieee80211_node *ni;

	DPRINTF(2, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->sc_txring.queued >= MALO_TX_RING_COUNT - 1) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		m0 = mq_dequeue(&ic->ic_mgtq);
		if (m0 != NULL) {
			ni = m0->m_pkthdr.ph_cookie;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (malo_tx_mgt(sc, m0, ni) != 0)
				break;
		} else {
			if (ic->ic_state != IEEE80211_S_RUN)
				break;

			IFQ_DEQUEUE(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (malo_tx_data(sc, m0, ni) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
		}
	}
}

void
malo_stop(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	DPRINTF(1, "%s: %s\n", ifp->if_xname, __func__);

	/* reset adapter */
	if (ifp->if_flags & IFF_RUNNING)
		malo_ctl_write4(sc, 0x0c18, (1 << 15));

	/* device is not running anymore */
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* change back to initial state */
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

	/* reset RX / TX rings */
	malo_reset_tx_ring(sc, &sc->sc_txring);
	malo_reset_rx_ring(sc, &sc->sc_rxring);

	/* set initial rate */
	sc->sc_last_txrate = -1;

	/* power off cardbus socket */
	if (sc->sc_disable)
		sc->sc_disable(sc);
}

void
malo_watchdog(struct ifnet *ifp)
{

}

int
malo_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct malo_softc *sc = ic->ic_if.if_softc;
	enum ieee80211_state ostate;
	uint8_t chan;
	int rate;

	DPRINTF(2, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	ostate = ic->ic_state;
	timeout_del(&sc->sc_scan_to);

	switch (nstate) {
	case IEEE80211_S_INIT:
		break;
	case IEEE80211_S_SCAN:
		if (ostate == IEEE80211_S_INIT) {
			if (malo_cmd_set_prescan(sc) != 0)
				DPRINTF(1, "%s: can't set prescan\n",
				    sc->sc_dev.dv_xname);
		} else {
			chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);

			malo_cmd_set_channel(sc, chan);
		}
		timeout_add_msec(&sc->sc_scan_to, 500);
		break;
	case IEEE80211_S_AUTH:
		DPRINTF(1, "%s: newstate AUTH\n", sc->sc_dev.dv_xname);
		malo_cmd_set_postscan(sc, ic->ic_myaddr, 1);
		chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
		malo_cmd_set_channel(sc, chan);
		break;
	case IEEE80211_S_ASSOC:
		DPRINTF(1, "%s: newstate ASSOC\n", sc->sc_dev.dv_xname);
		if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
			malo_cmd_set_radio(sc, 1, 3); /* short preamble */
		else
			malo_cmd_set_radio(sc, 1, 1); /* long preamble */

		malo_cmd_set_aid(sc, ic->ic_bss->ni_bssid,
		    ic->ic_bss->ni_associd);

		if (ic->ic_fixed_rate == -1)
			/* automatic rate adaption */
			malo_cmd_set_rate(sc, 0);
		else {
			/* fixed rate */
			rate = malo_fix2rate(ic->ic_fixed_rate);
			malo_cmd_set_rate(sc, rate);
		}

		malo_set_slot(sc);
		break;
	case IEEE80211_S_RUN:
		DPRINTF(1, "%s: newstate RUN\n", sc->sc_dev.dv_xname);
		break;
	default:
		break;
	}

	return (sc->sc_newstate(ic, nstate, arg));
}

void
malo_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{

}

struct ieee80211_node *
malo_node_alloc(struct ieee80211com *ic)
{
	struct malo_node *wn;

	wn = malloc(sizeof(*wn), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (wn == NULL)
		return (NULL);

	return ((struct ieee80211_node *)wn);
}

int
malo_media_change(struct ifnet *ifp)
{
	int error;

	DPRINTF(1, "%s: %s\n", ifp->if_xname, __func__);

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return (error);

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		malo_init(ifp);

	return (0);
}

void
malo_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct malo_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	imr->ifm_status = IFM_AVALID;
	imr->ifm_active = IFM_IEEE80211;
	if (ic->ic_state == IEEE80211_S_RUN)
		imr->ifm_status |= IFM_ACTIVE;

	/* report last TX rate used by chip */
	imr->ifm_active |= ieee80211_rate2media(ic, sc->sc_last_txrate,
	    ic->ic_curmode);

	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		imr->ifm_active |= IFM_IEEE80211_ADHOC;
		break;
	case IEEE80211_M_AHDEMO:
		break;
	case IEEE80211_M_HOSTAP:
		break;
#endif
	case IEEE80211_M_MONITOR:
		imr->ifm_active |= IFM_IEEE80211_MONITOR;
		break;
	default:
		break;
	}

	switch (ic->ic_curmode) {
		case IEEE80211_MODE_11B:
			imr->ifm_active |= IFM_IEEE80211_11B;
			break;
		case IEEE80211_MODE_11G:
			imr->ifm_active |= IFM_IEEE80211_11G;
			break;
	}
}

int
malo_chip2rate(int chip_rate)
{
	switch (chip_rate) {
	/* CCK rates */
	case  0:	return (2);
	case  1:	return (4);
	case  2:	return (11);
	case  3:	return (22);

	/* OFDM rates */
	case  4:	return (0); /* reserved */
	case  5:	return (12);
	case  6:	return (18);
	case  7:	return (24);
	case  8:	return (36);
	case  9:	return (48);
	case 10:	return (72);
	case 11:	return (96);
	case 12:	return (108);

	/* no rate select yet or unknown rate */
	default:	return (-1);
	}
}

int
malo_fix2rate(int fix_rate)
{
	switch (fix_rate) {
	/* CCK rates */
	case  0:	return (2);
	case  1:	return (4);
	case  2:	return (11);
	case  3:	return (22);

	/* OFDM rates */
	case  4:	return (12);
	case  5:	return (18);
	case  6:	return (24);
	case  7:	return (36);
	case  8:	return (48);
	case  9:	return (72);
	case 10:	return (96);
	case 11:	return (108);

	/* unknown rate: should not happen */
	default:	return (0);
	}
}

void
malo_next_scan(void *arg)
{
	struct malo_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	DPRINTF(1, "%s: %s\n", ifp->if_xname, __func__);

	s = splnet();

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);

	splx(s);
}

void
malo_tx_intr(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct malo_tx_desc *desc;
	struct malo_tx_data *data;
	struct malo_node *rn;
	int stat;

	DPRINTF(2, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	stat = sc->sc_txring.stat;
	for (;;) {
		desc = &sc->sc_txring.desc[sc->sc_txring.stat];
		data = &sc->sc_txring.data[sc->sc_txring.stat];
		rn = (struct malo_node *)data->ni;

		/* check if TX descriptor is not owned by FW anymore */
		if ((letoh32(desc->status) & 0x80000000) ||
		    !(letoh32(data->softstat) & 0x80))
			break;

		/* if no frame has been sent, ignore */
		if (rn == NULL)
			goto next;

		/* check TX state */
		switch (letoh32(desc->status) & 0x1) {
		case 0x1:
			DPRINTF(2, "%s: data frame was sent successfully\n",
			    sc->sc_dev.dv_xname);
			break;
		default:
			DPRINTF(1, "%s: data frame sending error\n",
			    sc->sc_dev.dv_xname);
			ifp->if_oerrors++;
			break;
		}

		/* save last used TX rate */
		sc->sc_last_txrate = malo_chip2rate(desc->datarate);

		/* cleanup TX data and TX descriptor */
		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		ieee80211_release_node(ic, data->ni);
		data->m = NULL;
		data->ni = NULL;
		data->softstat &= htole32(~0x80);
		desc->status = 0;
		desc->len = 0;

		DPRINTF(2, "%s: tx done idx=%d\n",
		    sc->sc_dev.dv_xname, sc->sc_txring.stat);

		sc->sc_txring.queued--;
next:
		if (++sc->sc_txring.stat >= sc->sc_txring.count)
			sc->sc_txring.stat = 0;
		if (sc->sc_txring.stat == stat)
			break;
	}

	sc->sc_tx_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
	malo_start(ifp);
}

int
malo_tx_mgt(struct malo_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct malo_tx_desc *desc;
	struct malo_tx_data *data;
	struct ieee80211_frame *wh;
	int error;

	DPRINTF(2, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	desc = &sc->sc_txring.desc[sc->sc_txring.cur];
	data = &sc->sc_txring.data[sc->sc_txring.cur];

	if (m0->m_len < sizeof(struct ieee80211_frame)) {
		m0 = m_pullup(m0, sizeof(struct ieee80211_frame));
		if (m0 == NULL) {
			ifp->if_ierrors++;
			return (ENOBUFS);
		}
	}
	wh = mtod(m0, struct ieee80211_frame *);

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct malo_tx_radiotap_hdr *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = sc->sc_last_txrate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif
	/*
	 * inject FW specific fields into the 802.11 frame
	 *
	 *  2 bytes FW len (inject)
	 * 24 bytes 802.11 frame header
	 *  6 bytes addr4 (inject)
	 *  n bytes 802.11 frame body
	 */
	if (M_LEADINGSPACE(m0) < 8) {
		if (M_TRAILINGSPACE(m0) < 8)
			panic("%s: not enough space for mbuf dance",
			    sc->sc_dev.dv_xname);
		bcopy(m0->m_data, m0->m_data + 8, m0->m_len);
		m0->m_data += 8;
	}

	/* move frame header */
	bcopy(m0->m_data, m0->m_data - 6, sizeof(*wh));
	m0->m_data -= 8;
	m0->m_len += 8;
	m0->m_pkthdr.len += 8;
	*mtod(m0, uint16_t *) = htole16(m0->m_len - 32); /* FW len */

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return (error);
	}

	data->m = m0;
	data->ni = ni;
	data->softstat |= htole32(0x80);

	malo_tx_setup_desc(sc, desc, m0->m_pkthdr.len, 0,
	    data->map->dm_segs, data->map->dm_nsegs);

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_txring.map,
	    sc->sc_txring.cur * sizeof(struct malo_tx_desc),
	    sizeof(struct malo_tx_desc), BUS_DMASYNC_PREWRITE);

	DPRINTF(2, "%s: sending mgmt frame, pktlen=%u, idx=%u\n",
	    sc->sc_dev.dv_xname, m0->m_pkthdr.len, sc->sc_txring.cur);

	sc->sc_txring.queued++;
	sc->sc_txring.cur = (sc->sc_txring.cur + 1) % MALO_TX_RING_COUNT;

	/* kick mgmt TX */
	malo_ctl_write4(sc, 0x0c18, 1);
	malo_ctl_barrier(sc, BUS_SPACE_BARRIER_WRITE);

	return (0);
}

int
malo_tx_data(struct malo_softc *sc, struct mbuf *m0,
    struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct malo_tx_desc *desc;
	struct malo_tx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct mbuf *mnew;
	int error;

	DPRINTF(2, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	desc = &sc->sc_txring.desc[sc->sc_txring.cur];
	data = &sc->sc_txring.data[sc->sc_txring.cur];

	if (m0->m_len < sizeof(struct ieee80211_frame)) {
		m0 = m_pullup(m0, sizeof(struct ieee80211_frame));
		if (m0 == NULL) {
			ifp->if_ierrors++;
			return (ENOBUFS);
		}
	}
	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		k = ieee80211_get_txkey(ic, wh, ni);
		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return (ENOBUFS);

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct malo_tx_radiotap_hdr *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = sc->sc_last_txrate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	/*
	 * inject FW specific fields into the 802.11 frame
	 *
	 *  2 bytes FW len (inject)
	 * 24 bytes 802.11 frame header
	 *  6 bytes addr4 (inject)
	 *  n bytes 802.11 frame body
	 *
	 * For now copy all into a new mcluster.
	 */
	MGETHDR(mnew, M_DONTWAIT, MT_DATA);
	if (mnew == NULL)
		return (ENOBUFS);
	MCLGET(mnew, M_DONTWAIT);
	if (!(mnew->m_flags & M_EXT)) {
		m_free(mnew);
		return (ENOBUFS);
	}

	*mtod(mnew, uint16_t *) = htole16(m0->m_pkthdr.len - 24); /* FW len */
	bcopy(wh, mtod(mnew, caddr_t) + 2, sizeof(*wh));
	bzero(mtod(mnew, caddr_t) + 26, 6);
	m_copydata(m0, sizeof(*wh), m0->m_pkthdr.len - sizeof(*wh),
	    mtod(mnew, caddr_t) + 32);
	mnew->m_pkthdr.len = mnew->m_len = m0->m_pkthdr.len + 8;
	m_freem(m0);
	m0 = mnew;

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return (error);
	}

	data->m = m0;
	data->ni = ni;
	data->softstat |= htole32(0x80);

	malo_tx_setup_desc(sc, desc, m0->m_pkthdr.len, 1,
	    data->map->dm_segs, data->map->dm_nsegs);

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_txring.map,
	    sc->sc_txring.cur * sizeof(struct malo_tx_desc),
	    sizeof(struct malo_tx_desc), BUS_DMASYNC_PREWRITE);

	DPRINTF(2, "%s: sending data frame, pktlen=%u, idx=%u\n",
	    sc->sc_dev.dv_xname, m0->m_pkthdr.len, sc->sc_txring.cur);

	sc->sc_txring.queued++;
	sc->sc_txring.cur = (sc->sc_txring.cur + 1) % MALO_TX_RING_COUNT;

	/* kick data TX */
	malo_ctl_write4(sc, 0x0c18, 1);
	malo_ctl_barrier(sc, BUS_SPACE_BARRIER_WRITE);

	return (0);
}

void
malo_tx_setup_desc(struct malo_softc *sc, struct malo_tx_desc *desc,
    int len, int rate, const bus_dma_segment_t *segs, int nsegs)
{
	desc->len = htole16(segs[0].ds_len);
	desc->datarate = rate; /* 0 = mgmt frame, 1 = data frame */
	desc->physdata = htole32(segs[0].ds_addr);
	desc->status = htole32(0x00000001 | 0x80000000);
}

void
malo_rx_intr(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct malo_rx_desc *desc;
	struct malo_rx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *mnew, *m;
	uint32_t rxRdPtr, rxWrPtr;
	int error, i;

	rxRdPtr = malo_mem_read4(sc, sc->sc_RxPdRdPtr);
	rxWrPtr = malo_mem_read4(sc, sc->sc_RxPdWrPtr);

	for (i = 0; i < MALO_RX_RING_COUNT && rxRdPtr != rxWrPtr; i++) {
		desc = &sc->sc_rxring.desc[sc->sc_rxring.cur];
		data = &sc->sc_rxring.data[sc->sc_rxring.cur];

		bus_dmamap_sync(sc->sc_dmat, sc->sc_rxring.map,
		    sc->sc_rxring.cur * sizeof(struct malo_rx_desc),
		    sizeof(struct malo_rx_desc), BUS_DMASYNC_POSTREAD);

		DPRINTF(3, "%s: rx intr idx=%d, rxctrl=0x%02x, rssi=%d, "
		    "status=0x%02x, channel=%d, len=%d, res1=%02x, rate=%d, "
		    "physdata=0x%04x, physnext=0x%04x, qosctrl=%02x, res2=%d\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_rxring.cur, desc->rxctrl, desc->rssi, desc->status,
		    desc->channel, letoh16(desc->len), desc->reserved1,
		    desc->datarate, letoh32(desc->physdata),
		    letoh32(desc->physnext), desc->qosctrl, desc->reserved2);

		if ((desc->rxctrl & 0x80) == 0)
			break;

		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
			ifp->if_ierrors++;
			goto skip;
		}

		MCLGET(mnew, M_DONTWAIT);
		if (!(mnew->m_flags & M_EXT)) {
			m_freem(mnew);
			ifp->if_ierrors++;
			goto skip;
		}

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmat, data->map);

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(mnew, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			m_freem(mnew);

			error = bus_dmamap_load(sc->sc_dmat, data->map,
			    mtod(data->m, void *), MCLBYTES, NULL,
			    BUS_DMA_NOWAIT);
			if (error != 0) {
				panic("%s: could not load old rx mbuf",
				    sc->sc_dev.dv_xname);
			}
			ifp->if_ierrors++;
			goto skip;
		}

		/*
		 * New mbuf mbuf successfully loaded
		 */
		m = data->m;
		data->m = mnew;
		desc->physdata = htole32(data->map->dm_segs->ds_addr);

		/* finalize mbuf */
		m->m_pkthdr.len = m->m_len = letoh16(desc->len);

		/*
		 * cut out FW specific fields from the 802.11 frame
		 *
		 *  2 bytes FW len (cut out)
		 * 24 bytes 802.11 frame header
		 *  6 bytes addr4 (cut out)
		 *  n bytes 802.11 frame data
		 */
		bcopy(m->m_data, m->m_data + 6, 26);
		m_adj(m, 8);

#if NBPFILTER > 0
		if (sc->sc_drvbpf != NULL) {
			struct mbuf mb;
			struct malo_rx_radiotap_hdr *tap = &sc->sc_rxtap;

			tap->wr_flags = 0;
			tap->wr_chan_freq =
			    htole16(ic->ic_bss->ni_chan->ic_freq);
			tap->wr_chan_flags =
			    htole16(ic->ic_bss->ni_chan->ic_flags);
			tap->wr_rssi = desc->rssi;
			tap->wr_max_rssi = ic->ic_max_rssi;

			mb.m_data = (caddr_t)tap;
			mb.m_len = sc->sc_rxtap_len;
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
		}
#endif

		wh = mtod(m, struct ieee80211_frame *);
		ni = ieee80211_find_rxnode(ic, wh);

		/* send the frame to the 802.11 layer */
		rxi.rxi_flags = 0;
		rxi.rxi_rssi = desc->rssi;
		rxi.rxi_tstamp = 0;	/* unused */
		ieee80211_input(ifp, m, ni, &rxi);

		/* node is no longer needed */
		ieee80211_release_node(ic, ni);

skip:
		desc->rxctrl = 0;
		rxRdPtr = letoh32(desc->physnext);

		bus_dmamap_sync(sc->sc_dmat, sc->sc_rxring.map,
		    sc->sc_rxring.cur * sizeof(struct malo_rx_desc),
		    sizeof(struct malo_rx_desc), BUS_DMASYNC_PREWRITE);

		sc->sc_rxring.cur = (sc->sc_rxring.cur + 1) %
		    MALO_RX_RING_COUNT;
	}

	malo_mem_write4(sc, sc->sc_RxPdRdPtr, rxRdPtr);
}

int
malo_load_bootimg(struct malo_softc *sc)
{
	char *name = "malo8335-h";
	uint8_t	*ucode;
	size_t usize;
	int error, i;

	/* load boot firmware */
	if ((error = loadfirmware(name, &ucode, &usize)) != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, name);
		return (EIO);
	}

	/*
	 * It seems we are putting this code directly onto the stack of
	 * the ARM cpu. I don't know why we need to instruct the DMA
	 * engine to move the code. This is a big riddle without docu.
	 */
	DPRINTF(1, "%s: loading boot firmware\n", sc->sc_dev.dv_xname);
	malo_mem_write2(sc, 0xbef8, 0x001);
	malo_mem_write2(sc, 0xbefa, usize);
	malo_mem_write4(sc, 0xbefc, 0);

	bus_space_write_region_1(sc->sc_mem1_bt, sc->sc_mem1_bh, 0xbf00,
	    ucode, usize);

	/*
	 * we loaded the firmware into card memory now tell the CPU
	 * to fetch the code and execute it. The memory mapped via the
	 * first bar is internaly mapped to 0xc0000000.
	 */
	malo_send_cmd(sc, 0xc000bef8);

	/* wait for the device to go into FW loading mode */
	for (i = 0; i < 10; i++) {
		delay(50);
		malo_ctl_barrier(sc, BUS_SPACE_BARRIER_READ);
		if (malo_ctl_read4(sc, 0x0c14) == 0x5)
			break;
	}
	if (i == 10) {
		printf("%s: timeout at boot firmware load!\n",
		    sc->sc_dev.dv_xname);
		free(ucode, M_DEVBUF, usize);
		return (ETIMEDOUT);
	}
	free(ucode, M_DEVBUF, usize);

	/* tell the card we're done and... */
	malo_mem_write2(sc, 0xbef8, 0x001);
	malo_mem_write2(sc, 0xbefa, 0);
	malo_mem_write4(sc, 0xbefc, 0);
	malo_send_cmd(sc, 0xc000bef8);

	DPRINTF(1, "%s: boot firmware loaded\n", sc->sc_dev.dv_xname);

	return (0);
}

int
malo_load_firmware(struct malo_softc *sc)
{
	struct malo_cmdheader *hdr;
	char *name = "malo8335-m";
	void *data;
	uint8_t *ucode;
	size_t size, count, bsize;
	int i, sn, error;

	/* load real firmware now */
	if ((error = loadfirmware(name, &ucode, &size)) != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, name);
		return (EIO);
	}

	DPRINTF(1, "%s: uploading firmware\n", sc->sc_dev.dv_xname);

	hdr = sc->sc_cmd_mem;
	data = hdr + 1;
	sn = 1;
	for (count = 0; count < size; count += bsize) {
		bsize = MIN(256, size - count);

		hdr->cmd = htole16(0x0001);
		hdr->size = htole16(bsize);
		hdr->seqnum = htole16(sn++);
		hdr->result = 0;

		bcopy(ucode + count, data, bsize);

		bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
		    BUS_DMASYNC_PREWRITE);
		malo_send_cmd(sc, sc->sc_cmd_dmaaddr);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
		    BUS_DMASYNC_POSTWRITE);
		delay(500);
	}
	free(ucode, M_DEVBUF, size);

	DPRINTF(1, "%s: firmware upload finished\n", sc->sc_dev.dv_xname);

	/*
	 * send a command with size 0 to tell that the firmware has been
	 * uploaded
	 */
	hdr->cmd = htole16(0x0001);
	hdr->size = 0;
	hdr->seqnum = htole16(sn++);
	hdr->result = 0;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE);
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE);
	delay(100);

	DPRINTF(1, "%s: loading firmware\n", sc->sc_dev.dv_xname);

	/* wait until firmware has been loaded */
	for (i = 0; i < 200; i++) {
		malo_ctl_write4(sc, 0x0c10, 0x5a);
		delay(500);
		malo_ctl_barrier(sc, BUS_SPACE_BARRIER_WRITE |
		     BUS_SPACE_BARRIER_READ);
		if (malo_ctl_read4(sc, 0x0c14) == 0xf0f1f2f4)
			break;
	}
	if (i == 200) {
		printf("%s: timeout at firmware load!\n", sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}

	DPRINTF(1, "%s: firmware loaded\n", sc->sc_dev.dv_xname);

	return (0);
}

int
malo_set_slot(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	if (ic->ic_flags & IEEE80211_F_SHSLOT) {
		/* set short slot */
		if (malo_cmd_set_slot(sc, 1)) {
			printf("%s: setting short slot failed\n",
			    sc->sc_dev.dv_xname);
			return (ENXIO);
		}
	} else {
		/* set long slot */
		if (malo_cmd_set_slot(sc, 0)) {
			printf("%s: setting long slot failed\n",
			    sc->sc_dev.dv_xname);
			return (ENXIO);
		}
	}

	return (0);
}

void
malo_update_slot(struct ieee80211com *ic)
{
	struct malo_softc *sc = ic->ic_if.if_softc;

	malo_set_slot(sc);

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
		/* TODO */
	}
#endif
}

#ifdef MALO_DEBUG
void
malo_hexdump(void *buf, int len)
{
	u_char b[16];
	int i, j, l;

	for (i = 0; i < len; i += l) {
		printf("%4i:", i);
		l = min(sizeof(b), len - i);
		bcopy(buf + i, b, l);
		
		for (j = 0; j < sizeof(b); j++) {
			if (j % 2 == 0)
				printf(" ");
			if (j % 8 == 0)
				printf(" ");
			if (j < l)
				printf("%02x", (int)b[j]);
			else
				printf("  ");
		}
		printf("  |");
		for (j = 0; j < l; j++) {
			if (b[j] >= 0x20 && b[j] <= 0x7e)
				printf("%c", b[j]);
			else
				printf(".");
		}
		printf("|\n");
	}
}
#endif

static char *
malo_cmd_string(uint16_t cmd)
{
	int i;
	static char cmd_buf[16];
	static const struct {
		uint16_t	 cmd_code;
		char		*cmd_string;
	} cmds[] = {
		{ MALO_CMD_GET_HW_SPEC,		"GetHwSpecifications"	},
		{ MALO_CMD_SET_RADIO,		"SetRadio"		},
		{ MALO_CMD_SET_AID,		"SetAid"		},
		{ MALO_CMD_SET_TXPOWER,		"SetTxPower"		},
		{ MALO_CMD_SET_ANTENNA,		"SetAntenna"		},
		{ MALO_CMD_SET_PRESCAN,		"SetPrescan"		},
		{ MALO_CMD_SET_POSTSCAN,	"SetPostscan"		},
		{ MALO_CMD_SET_RATE,		"SetRate"		},
		{ MALO_CMD_SET_CHANNEL,		"SetChannel"		},
		{ MALO_CMD_SET_RTS,		"SetRTS"		},
		{ MALO_CMD_SET_SLOT,		"SetSlot"		},
	};

	for (i = 0; i < sizeof(cmds) / sizeof(cmds[0]); i++)
		if ((letoh16(cmd) & 0x7fff) == cmds[i].cmd_code)
			return (cmds[i].cmd_string);

	snprintf(cmd_buf, sizeof(cmd_buf), "unknown %#x", cmd);
	return (cmd_buf);
}

static char *
malo_cmd_string_result(uint16_t result)
{
	int i;
	static const struct {
		uint16_t	 result_code;
		char		*result_string;
	} results[] = {
		{ MALO_CMD_RESULT_OK,		"OK"		},
		{ MALO_CMD_RESULT_ERROR,	"general error"	},
		{ MALO_CMD_RESULT_NOSUPPORT,	"not supported" },
		{ MALO_CMD_RESULT_PENDING,	"pending"	},
		{ MALO_CMD_RESULT_BUSY,		"ignored"	},
		{ MALO_CMD_RESULT_PARTIALDATA,	"incomplete"	},
	};

	for (i = 0; i < sizeof(results) / sizeof(results[0]); i++)
		if (letoh16(result) == results[i].result_code)
			return (results[i].result_string);

	return ("unknown");
}

int
malo_cmd_get_spec(struct malo_softc *sc)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_hw_spec *spec;

	hdr->cmd = htole16(MALO_CMD_GET_HW_SPEC);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*spec));
	hdr->seqnum = htole16(42);	/* the one and only */
	hdr->result = 0;
	spec = (struct malo_hw_spec *)(hdr + 1);

	bzero(spec, sizeof(*spec));
	memset(spec->PermanentAddress, 0xff, ETHER_ADDR_LEN);
	spec->CookiePtr = htole32(sc->sc_cookie_dmaaddr);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	if (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr) != 0)
		return (ETIMEDOUT);

	/* get the data from the buffer */
	DPRINTF(1, "%s: get_hw_spec: V%x R%x, #WCB %d, #Mcast %d, Regcode %d, "
	    "#Ant %d\n", sc->sc_dev.dv_xname, htole16(spec->HwVersion),
	    htole32(spec->FWReleaseNumber), htole16(spec->NumOfWCB),
	    htole16(spec->NumOfMCastAdr), htole16(spec->RegionCode),
	    htole16(spec->NumberOfAntenna));

	/* tell the DMA engine where our rings are */
	malo_mem_write4(sc, letoh32(spec->RxPdRdPtr) & 0xffff,
	    sc->sc_rxring.physaddr);
	malo_mem_write4(sc, letoh32(spec->RxPdWrPtr) & 0xffff,
	    sc->sc_rxring.physaddr);
	malo_mem_write4(sc, letoh32(spec->WcbBase0) & 0xffff,
	    sc->sc_txring.physaddr);

	/* save DMA RX pointers for later use */
	sc->sc_RxPdRdPtr = letoh32(spec->RxPdRdPtr) & 0xffff;
	sc->sc_RxPdWrPtr = letoh32(spec->RxPdWrPtr) & 0xffff;

	return (0);
}

int
malo_cmd_set_prescan(struct malo_softc *sc)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;

	hdr->cmd = htole16(MALO_CMD_SET_PRESCAN);
	hdr->size = htole16(sizeof(*hdr));
	hdr->seqnum = 1;
	hdr->result = 0;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

int
malo_cmd_set_postscan(struct malo_softc *sc, uint8_t *macaddr, uint8_t ibsson)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_postscan *body;

	hdr->cmd = htole16(MALO_CMD_SET_POSTSCAN);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_postscan *)(hdr + 1);

	bzero(body, sizeof(*body));
	memcpy(&body->bssid, macaddr, ETHER_ADDR_LEN);
	body->isibss = htole32(ibsson);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

int
malo_cmd_set_channel(struct malo_softc *sc, uint8_t channel)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_channel *body;

	hdr->cmd = htole16(MALO_CMD_SET_CHANNEL);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_channel *)(hdr + 1);

	bzero(body, sizeof(*body));
	body->action = htole16(1);
	body->channel = channel;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

int
malo_cmd_set_antenna(struct malo_softc *sc, uint16_t antenna)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_antenna *body;

	hdr->cmd = htole16(MALO_CMD_SET_ANTENNA);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_antenna *)(hdr + 1);

	bzero(body, sizeof(*body));
	body->action = htole16(antenna);
	if (antenna == 1)
		body->mode = htole16(0xffff);
	else
		body->mode = htole16(2);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

int
malo_cmd_set_radio(struct malo_softc *sc, uint16_t enable,
    uint16_t preamble_mode)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_radio *body;

	hdr->cmd = htole16(MALO_CMD_SET_RADIO);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_radio *)(hdr + 1);

	bzero(body, sizeof(*body));
	body->action = htole16(1);
	body->preamble_mode = htole16(preamble_mode);
	body->enable = htole16(enable);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

int
malo_cmd_set_aid(struct malo_softc *sc, uint8_t *bssid, uint16_t associd)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_aid *body;

	hdr->cmd = htole16(MALO_CMD_SET_AID);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_aid *)(hdr + 1);

	bzero(body, sizeof(*body));
	body->associd = htole16(associd);
	memcpy(&body->macaddr[0], bssid, IEEE80211_ADDR_LEN);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

int
malo_cmd_set_txpower(struct malo_softc *sc, unsigned int powerlevel)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_txpower *body;

	hdr->cmd = htole16(MALO_CMD_SET_TXPOWER);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_txpower *)(hdr + 1);

	bzero(body, sizeof(*body));
	body->action = htole16(1);
	if (powerlevel < 30)
		body->supportpowerlvl = htole16(5);	/* LOW */
	else if (powerlevel >= 30 && powerlevel < 60)
		body->supportpowerlvl = htole16(10);	/* MEDIUM */
	else
		body->supportpowerlvl = htole16(15);	/* HIGH */

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

int
malo_cmd_set_rts(struct malo_softc *sc, uint32_t threshold)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_rts *body;

	hdr->cmd = htole16(MALO_CMD_SET_RTS);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_rts *)(hdr + 1);

	bzero(body, sizeof(*body));
	body->action = htole16(1);
	body->threshold = htole32(threshold);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

int
malo_cmd_set_slot(struct malo_softc *sc, uint8_t slot)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_slot *body;

	hdr->cmd = htole16(MALO_CMD_SET_SLOT);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_slot *)(hdr + 1);

	bzero(body, sizeof(*body));
	body->action = htole16(1);
	body->slot = slot;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

int
malo_cmd_set_rate(struct malo_softc *sc, uint8_t rate)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_rate *body;
	int i;

	hdr->cmd = htole16(MALO_CMD_SET_RATE);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_rate *)(hdr + 1);

	bzero(body, sizeof(*body));

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
		/* TODO */
	} else
#endif
	{
		body->aprates[0] = 2;
		body->aprates[1] = 4;
		body->aprates[2] = 11;
		body->aprates[3] = 22;
		if (ic->ic_curmode == IEEE80211_MODE_11G) {
			body->aprates[4] = 0;
			body->aprates[5] = 12;
			body->aprates[6] = 18;
			body->aprates[7] = 24;
			body->aprates[8] = 36;
			body->aprates[9] = 48;
			body->aprates[10] = 72;
			body->aprates[11] = 96;
			body->aprates[12] = 108;
		}
	}

	if (rate != 0) {
		/* fixed rate */
		for (i = 0; i < 13; i++) {
			if (body->aprates[i] == rate) {
				body->rateindex = i;
				body->dataratetype = 1;
				break;
			}
		}
	}

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
}

void
malo_cmd_response(struct malo_softc *sc)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;

	if (letoh16(hdr->result) != MALO_CMD_RESULT_OK) {
		printf("%s: firmware cmd %s failed with %s\n",
		    sc->sc_dev.dv_xname,
		    malo_cmd_string(hdr->cmd),
		    malo_cmd_string_result(hdr->result));
	}

#ifdef MALO_DEBUG
	printf("%s: cmd answer for %s=%s\n",
	    sc->sc_dev.dv_xname,
	    malo_cmd_string(hdr->cmd),
	    malo_cmd_string_result(hdr->result));

	if (malo_d > 2)
		malo_hexdump(hdr, letoh16(hdr->size));
#endif
}
@


1.114
log
@add a free() size near microcode loading
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.113 2017/01/22 10:17:38 dlg Exp $ */
a22 1
#include <sys/types.h>
@


1.113
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.112 2016/04/13 10:49:26 mpi Exp $ */
d1751 1
a1751 1
	size_t size;
d1755 1
a1755 1
	if ((error = loadfirmware(name, &ucode, &size)) != 0) {
d1768 1
a1768 1
	malo_mem_write2(sc, 0xbefa, size);
d1772 1
a1772 1
	    ucode, size);
d1791 1
a1791 1
		free(ucode, M_DEVBUF, size);
d1794 1
a1794 1
	free(ucode, M_DEVBUF, size);
d1846 1
a1846 1
	free(ucode, M_DEVBUF, 0);
@


1.112
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.111 2015/11/25 03:09:58 dlg Exp $ */
a1335 1
			ifp->if_opackets++;
@


1.111
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.110 2015/11/16 10:03:01 mpi Exp $ */
a351 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.110
log
@Check for space on the ring before dequeuing packets.

Allows us to get rid of mq_requeue(9) and IFQ_POLL(9) because wireless
drivers use a special queue for management frames.

Tested by stsp@@, ok dlg@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.109 2015/11/04 12:11:59 dlg Exp $ */
d1009 1
a1009 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1014 1
a1014 1
			ifp->if_flags |= IFF_OACTIVE;
d1068 2
a1069 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d1373 1
a1373 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.109
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.108 2015/10/25 12:48:46 mpi Exp $ */
d1013 5
a1019 6
			if (sc->sc_txring.queued >= MALO_TX_RING_COUNT) {
				ifp->if_flags |= IFF_OACTIVE;
				mq_requeue(&ic->ic_mgtq, m0);
				break;
			}

d1030 2
a1031 1
			IFQ_POLL(&ifp->if_snd, m0);
a1033 5
			if (sc->sc_txring.queued >= MALO_TX_RING_COUNT - 1) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.108
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.107 2015/09/09 18:23:55 deraadt Exp $ */
d1013 1
a1013 1
		IF_POLL(&ic->ic_mgtq, m0);
d1017 1
a1019 1
			IF_DEQUEUE(&ic->ic_mgtq, m0);
@


1.107
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.106 2015/07/06 07:20:03 stsp Exp $ */
a937 1
	struct ifaddr *ifa;
a945 1
		ifa = (struct ifaddr *)data;
a946 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.106
log
@Make malo(4) compile with MALO_DEBUG. Problem found by Walter Daugherity.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.105 2015/02/10 23:25:46 mpi Exp $ */
d1801 1
a1801 1
		free(ucode, M_DEVBUF, 0);
d1804 1
a1804 1
	free(ucode, M_DEVBUF, 0);
@


1.105
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.104 2014/12/22 02:28:51 tedu Exp $ */
d1369 2
a1370 2
		DPRINTF(2, "%s: tx done idx=%u\n",
		    sc->sc_txring.stat, sc->sc_dev.dv_xname);
@


1.104
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.103 2014/12/19 22:44:58 guenther Exp $ */
a1692 1
		m->m_pkthdr.rcvif = ifp;
@


1.103
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.102 2014/09/14 14:17:24 jsg Exp $ */
a948 1
#ifdef INET
a950 1
#endif
@


1.102
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.101 2014/07/22 13:12:12 mpi Exp $ */
d32 1
a34 1
#include <machine/endian.h>
@


1.101
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.100 2014/07/13 23:10:23 deraadt Exp $ */
a28 1
#include <sys/proc.h>
@


1.100
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.99 2014/07/12 18:48:17 tedu Exp $ */
a45 1
#include <netinet/in_systm.h>
@


1.99
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.98 2014/03/19 10:09:19 mpi Exp $ */
d578 2
a579 2
	ring->data = malloc(count * sizeof (struct malo_rx_data), M_DEVBUF,
	    M_NOWAIT);
d737 2
a738 2
	ring->data = malloc(count * sizeof(struct malo_tx_data), M_DEVBUF,
	    M_NOWAIT);
@


1.98
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.97 2013/12/06 21:03:03 deraadt Exp $ */
d686 1
a686 1
		free(ring->data, M_DEVBUF);
d837 1
a837 1
		free(ring->data, M_DEVBUF);
d1806 1
a1806 1
		free(ucode, M_DEVBUF);
d1809 1
a1809 1
	free(ucode, M_DEVBUF);
d1861 1
a1861 1
	free(ucode, M_DEVBUF);
@


1.97
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.96 2013/11/14 12:21:13 dlg Exp $ */
d1029 1
a1029 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
@


1.96
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.95 2012/12/05 23:20:18 deraadt Exp $ */
a27 1
#include <sys/task.h>
@


1.95
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.94 2012/09/04 19:01:33 claudio Exp $ */
d28 1
a28 1
#include <sys/workq.h>
@


1.94
log
@The powerlevel is an unsigned int, there is no need to check for negative
values and even if this would make more sense. Found by brad some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.93 2011/07/03 21:35:38 dhill Exp $ */
a21 1
#include <sys/cdefs.h>
@


1.93
log
@avoid void * pointer arithmetic.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.92 2010/08/27 17:08:00 jsg Exp $ */
d2219 1
a2219 1
	if (powerlevel >= 0 && powerlevel < 30)
@


1.92
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.91 2010/08/08 16:36:33 deraadt Exp $ */
d475 1
a475 1
	sc->sc_cmd_mem = sc->sc_cmd_mem + sizeof(uint32_t);
@


1.91
log
@activate function for suspend/restore; from mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.90 2010/05/19 15:27:35 oga Exp $ */
a349 1
	ifp->if_init = malo_init;
@


1.90
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.89 2009/07/12 18:24:23 mglocker Exp $ */
d29 1
a251 1
int	malo_init(struct ifnet *ifp);
a253 1
void	malo_stop(struct malo_softc *sc);
@


1.89
log
@In a error case in malo_init (e.g. can't load the firmware),
always call malo_stop which removes the previously registered
interrupt handler from the cardbus interrupt handler chain.
Otherwise, since malo_init gets called twice in a error case,
our interrupt handler got registered twice and on the next
device detach, just the last registered interrupt handler got
removed, which leaves one left.  That caused a kernel page fault
trap as soon our "zombie" interrupt handler got called.

Fix a typo while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.88 2009/07/10 07:34:02 blambert Exp $ */
d555 2
a556 1
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a579 1
	bzero(ring->desc, count * sizeof(struct malo_rx_desc));
d714 2
a715 2
	    count * sizeof(struct malo_tx_desc),
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a738 1
	memset(ring->desc, 0, count * sizeof(struct malo_tx_desc));
@


1.88
log
@timeout_add -> timeout_add_msec

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.87 2009/03/29 21:53:52 sthen Exp $ */
d934 1
a934 1
	DPRINTF(1, "%s: malo_init failed, reseting card\n",
d936 1
a936 1
	malo_ctl_write4(sc, 0x0c18, (1 << 15));
@


1.87
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.86 2008/08/27 09:05:03 damien Exp $ */
d1136 1
a1136 1
		timeout_add(&sc->sc_scan_to, hz / 2);
@


1.86
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.85 2008/08/14 16:02:24 damien Exp $ */
d566 1
a566 1
		printf("%s: could not map desc DMA memory\n",
d726 1
a726 1
		printf("%s: could not map desc DMA memory\n",
d1464 1
a1464 1
		printf("%s: could not map mbuf (error %d)\n",
d1583 1
a1583 1
		printf("%s: could not map mbuf (error %d)\n",
@


1.85
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.84 2008/07/27 11:28:17 mbalmer Exp $ */
d1228 1
d1232 5
d1240 1
a1240 3
	case IEEE80211_M_AHDEMO:
		break;
	case IEEE80211_M_HOSTAP:
d1939 1
d1943 1
d2295 1
d2298 3
a2300 1
	} else {
@


1.84
log
@fix a typo in a comment.

ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.83 2008/07/21 18:43:19 damien Exp $ */
a1760 7

	/*
	 * In HostAP mode, ieee80211_input() will enqueue packets in if_snd
	 * without calling if_start().
	 */
	if (!IFQ_IS_EMPTY(&ifp->if_snd) && !(ifp->if_flags & IFF_OACTIVE))
		(*ifp->if_start)(ifp);
@


1.83
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.82 2008/04/16 18:32:15 damien Exp $ */
d1363 1
a1363 1
		/* cleanup TX data and TX descritpor */
@


1.82
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.81 2007/11/10 14:20:15 mglocker Exp $ */
d1629 1
d1740 4
a1743 1
		ieee80211_input(ifp, m, ni, desc->rssi, 0);
@


1.81
log
@- Fix command timeouts in certain scenarios (like under X11)
- Properly issue the RTS-Threshold firmware command

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.80 2007/10/01 04:03:51 krw Exp $ */
d381 2
a382 1
	    IEEE80211_C_WEP;
a1414 9
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
			return (ENOBUFS);

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

d1501 1
d1520 2
a1521 2
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
@


1.80
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.79 2007/08/28 18:34:38 deraadt Exp $ */
d111 1
d203 5
d514 1
a514 1
	for (i = 0; i < 10; i++) {
d521 1
a521 1
	if (i == 10) {
d2243 1
d2246 1
a2246 1
	hdr->size = htole16(sizeof(*hdr) + sizeof(threshold));
d2249 1
d2251 3
a2253 1
	*(uint32_t *)(hdr + 1) = htole32(threshold);
@


1.79
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.78 2007/08/28 17:04:18 mglocker Exp $ */
d1179 1
a1179 1
	wn = malloc(sizeof(struct malo_node), M_DEVBUF, M_NOWAIT);
a1181 2

	bzero(wn, sizeof(struct malo_node));
@


1.78
log
@Unify DPRINTF's and use the device name argument for all outputs.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.77 2007/08/27 19:11:13 mglocker Exp $ */
d1779 1
a1779 1
		printf("%s: error %d, could not read microcode %s!\n",
d1842 1
a1842 1
		printf("%s: error %d, could not read microcode %s!\n",
@


1.77
log
@Process all FW command responses, and therefore make them visible in debug
mode.  Make a note that processing of command-done interrupts doesn't
work yet.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.76 2007/08/26 08:49:55 mglocker Exp $ */
d56 2
a57 3
#define DPRINTF(x)	do { if (malo_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (malo_debug >= (n)) printf x; } while (0)
int malo_debug = 1;
d59 1
a59 2
#define DPRINTF(x)
#define DPRINTFN(n, x)
d314 1
a314 1
		DPRINTF(("%s: got cmd done interrupt\n", sc->sc_dev.dv_xname));
d319 2
a320 2
		DPRINTF(("%s: unknown interrupt %x\n", sc->sc_dev.dv_xname,
		    status));
d847 1
a847 1
	DPRINTF(("%s: %s\n", ifp->if_xname, __func__));
d927 2
a928 2
	DPRINTF(("%s: malo_init failed, reseting card\n",
	    sc->sc_dev.dv_xname));
d1013 1
a1013 1
	DPRINTFN(2, ("%s: %s\n", sc->sc_dev.dv_xname, __func__));
d1073 1
a1073 1
	DPRINTF(("%s: %s\n", ifp->if_xname, __func__));
d1111 1
a1111 1
	DPRINTFN(2, ("%s: %s\n", sc->sc_dev.dv_xname, __func__));
d1122 2
a1123 2
				DPRINTF(("%s: can't set prescan\n",
				    sc->sc_dev.dv_xname));
d1132 1
a1132 1
		DPRINTF(("newstate AUTH\n"));
d1138 1
a1138 1
		DPRINTF(("newstate ASSOC\n"));
d1159 1
a1159 1
		DPRINTF(("newstate RUN\n"));
d1193 1
a1193 1
	DPRINTF(("%s: %s\n", ifp->if_xname, __func__));
d1304 1
a1304 1
	DPRINTF(("%s: %s\n", ifp->if_xname, __func__));
d1324 1
a1324 1
	DPRINTFN(2, ("%s: %s\n", sc->sc_dev.dv_xname, __func__));
d1344 2
a1345 1
			DPRINTFN(2, ("data frame was sent successfully\n"));
d1349 2
a1350 1
			DPRINTF(("data frame sending error\n"));
d1370 2
a1371 1
		DPRINTFN(2, ("tx done idx=%u\n", sc->sc_txring.stat));
d1396 1
a1396 1
	DPRINTFN(2, ("%s: %s\n", sc->sc_dev.dv_xname, __func__));
d1483 2
a1484 2
	DPRINTFN(2, ("%s: sending mgmt frame, pktlen=%u, idx=%u\n",
	    sc->sc_dev.dv_xname, m0->m_pkthdr.len, sc->sc_txring.cur));
d1508 1
a1508 1
	DPRINTFN(2, ("%s: %s\n", sc->sc_dev.dv_xname, __func__));
d1601 2
a1602 2
	DPRINTFN(2, ("%s: sending data frame, pktlen=%u, idx=%u\n",
	    sc->sc_dev.dv_xname, m0->m_pkthdr.len, sc->sc_txring.cur));
d1648 1
a1648 1
		DPRINTFN(3, ("rx intr idx=%d, rxctrl=0x%02x, rssi=%d, "
d1651 1
d1655 1
a1655 1
		    letoh32(desc->physnext), desc->qosctrl, desc->reserved2));
d1789 1
a1789 1
	DPRINTF(("%s: loading boot firmware\n", sc->sc_dev.dv_xname));
d1825 1
a1825 1
	DPRINTF(("%s: boot firmware loaded\n", sc->sc_dev.dv_xname));
d1847 1
a1847 1
	DPRINTF(("%s: uploading firmware\n", sc->sc_dev.dv_xname));
d1871 1
a1871 1
	DPRINTF(("%s: firmware upload finished\n", sc->sc_dev.dv_xname));
d1889 1
a1889 1
	DPRINTF(("%s: loading firmware\n", sc->sc_dev.dv_xname));
d1905 1
a1905 1
	DPRINTF(("%s: firmware loaded\n", sc->sc_dev.dv_xname));
d2056 1
a2056 1
	DPRINTF(("%s: get_hw_spec: V%x R%x, #WCB %d, #Mcast %d, Regcode %d, "
d2060 1
a2060 1
	    htole16(spec->NumberOfAntenna)));
d2346 1
a2346 1
	if (malo_debug > 2)
@


1.76
log
@Fix XXX comment.  There is nothing wrong with the following statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.75 2007/08/25 23:59:11 mglocker Exp $ */
d297 1
d315 3
a317 16
		struct malo_cmdheader *hdr = sc->sc_cmd_mem;

		if (letoh16(hdr->result) != MALO_CMD_RESULT_OK) {
			printf("%s: firmware cmd %s failed with %s\n",
			    sc->sc_dev.dv_xname,
			    malo_cmd_string(hdr->cmd),
			    malo_cmd_string_result(hdr->result));
		}
#ifdef MALO_DEBUG
		printf("%s: cmd answer for %s=%s\n",
		    sc->sc_dev.dv_xname,
		    malo_cmd_string(hdr->cmd),
		    malo_cmd_string_result(hdr->result));
		if (malo_debug > 2)
			malo_hexdump(hdr, letoh16(hdr->size));
#endif
d517 5
d523 1
a523 2
	if (i == 10)
		return (ETIMEDOUT);
d2324 23
@


1.75
log
@Remove FW command for WEP, it doesn't work with this FW version
(not supported).  We always did software WEP.

Spotted by Mikore dot Li at sun dot com.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.74 2007/08/25 20:57:12 mglocker Exp $ */
d2061 1
a2061 1
	/* XXX get the data from the buffer and feed it to ieee80211 */
@


1.74
log
@Fix typo in debug line.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.73 2007/08/25 20:55:04 mglocker Exp $ */
a117 1
#define MALO_CMD_SET_WEPKEY		0x0013
a161 12
struct malo_cmd_wepkey {
	uint16_t	action;
	uint8_t		len;
	uint8_t		flags;
	uint16_t	index;
	uint8_t		value[IEEE80211_KEYBUF_SIZE];
	uint8_t		txmickey[IEEE80211_WEP_MICLEN];
	uint8_t		rxmickey[IEEE80211_WEP_MICLEN];
	uint64_t	rxseqctr;
	uint64_t	txseqctr;
} __packed;

a273 1
int	malo_set_wepkey(struct malo_softc *sc);
a283 2
int	malo_cmd_set_wepkey(struct malo_softc *sc, struct ieee80211_key *k,
	    uint16_t k_index);
a923 10
	/* WEP */
	if (sc->sc_ic.ic_flags & IEEE80211_F_WEPON) {
		/* set key */
		if (malo_set_wepkey(sc)) {
			printf("%s: setting WEP key failed!\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

a1916 19
malo_set_wepkey(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int i;

	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		struct ieee80211_key *k = &ic->ic_nw_keys[i];

		if (k->k_len == 0)
			continue;

		if (malo_cmd_set_wepkey(sc, k, i))
			return (ENXIO);
	}

	return (0);
}

int
a1995 1
		{ MALO_CMD_SET_WEPKEY,		"SetWep"		},
a2080 26
}

int
malo_cmd_set_wepkey(struct malo_softc *sc, struct ieee80211_key *k,
    uint16_t k_index)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_cmd_wepkey *body;

	hdr->cmd = htole16(MALO_CMD_SET_WEPKEY);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
	hdr->seqnum = 1;
	hdr->result = 0;
	body = (struct malo_cmd_wepkey *)(hdr + 1);

	bzero(body, sizeof(*body));
	body->action = htole16(1);
	body->flags = 0;
	body->index = k_index;
	body->len = k->k_len;
	memcpy(body->value, k->k_key, k->k_len);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
@


1.73
log
@Fix debug output for some FW commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.72 2007/07/18 18:10:31 damien Exp $ */
d349 1
a349 1
		DPRINTF(("%s: unkown interrupt %x\n", sc->sc_dev.dv_xname,
@


1.72
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.71 2007/05/29 18:03:25 claudio Exp $ */
d2041 1
d2043 1
d2048 1
d2051 1
@


1.71
log
@Beef up malo_hexdump() to emulate hexdump -C output. Helps to see hidden
agendas in buffers that stupidly encode numbers as strings so that we need
to parse them in the kernel as seen on che(4). OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.70 2007/05/25 18:31:02 mglocker Exp $ */
d298 2
a299 2
int	malo_cmd_set_wepkey(struct malo_softc *sc, struct ieee80211_wepkey *wk,
	    uint16_t wk_i);
d1949 1
a1949 1
		struct ieee80211_wepkey *wk = &ic->ic_nw_keys[i];
d1951 1
a1951 1
		if (wk->wk_len == 0)
d1954 1
a1954 1
		if (malo_cmd_set_wepkey(sc, wk, i))
d2126 2
a2127 2
malo_cmd_set_wepkey(struct malo_softc *sc, struct ieee80211_wepkey *wk,
    uint16_t wk_index)
d2141 3
a2143 3
	body->index = wk_index;
	body->len = wk->wk_len;
	memcpy(body->value, wk->wk_key, wk->wk_len);
@


1.70
log
@Bump firmware package version;  Better naming of the malo firmware files.

discussed with, and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.69 2007/05/09 19:34:07 mglocker Exp $ */
d2001 2
a2002 1
	int i;
d2004 23
a2026 6
	for (i = 0; i < len; i++) {
		if (i % 16 == 0)
			printf("%s%4i:", i ? "\n" : "", i);
		if (i % 4 == 0)
			printf(" ");
		printf("%02x", (int)*((u_char *)buf + i));
a2027 1
	printf("\n");
@


1.69
log
@Remove an obsolete comment which guesses about a register write an never
was used anyway.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.68 2007/05/05 14:41:14 jsg Exp $ */
d1804 1
a1804 1
	char *name = "mrv8k-b.fw";
d1866 1
a1866 1
	char *name = "mrv8k-f.fw";
@


1.68
log
@malo_hexdump() is only used by code under MALO_DEBUG, so ifdef it

ok mglocker@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.67 2007/05/03 15:06:09 mglocker Exp $ */
a882 2
	/* ???, what is this for, seems unnecessary */
	/* malo_ctl_write4(sc, 0x0c38, 0x1f); */
@


1.67
log
@Enable fast channel switching in monitor mode, which makes apps like
kismet happy.  Previously system got very slow because at every channel
switch an ENETRESET was issued.

Reported and diff by Steffen Schuetz <st.sch@@gmx.net>.  Closes PR 5452.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.66 2007/04/20 17:08:34 claudio Exp $ */
d290 1
d292 1
d1999 1
d2014 1
@


1.66
log
@Increase the delay while uploading a firmware buffer in malo_load_firmware().
We're doing DMA transfers without interrupts or some other indication and
100 microseconds is not enough on my X40 and so the firmware gets corrupted.
Increasing it to 500 microseconds this should give us enough safety margin.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.65 2007/04/17 19:45:20 claudio Exp $ */
d977 1
d1008 15
@


1.65
log
@The debug printf in malo_newstate() is too verbose so require debug level 2
to print it.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.64 2007/03/14 08:23:09 claudio Exp $ */
d1883 1
a1883 1
		delay(100);
@


1.64
log
@Call ifp->if_start() at the end of the rx interrupt handling just in case
ieee80211_input() enqueued a packet beforehand. malo(4) does not support
hostap mode so this should not happen but perhaps mglocker@@ gets it working
someday.  OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.63 2007/02/14 20:52:26 mglocker Exp $ */
d1131 1
a1131 1
	DPRINTF(("%s: %s\n", sc->sc_dev.dv_xname, __func__));
@


1.63
log
@Sync with pgt(4) multicast fix.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.62 2007/02/09 10:35:43 claudio Exp $ */
d1776 7
@


1.62
log
@Spaces, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.61 2006/12/31 16:58:02 claudio Exp $ */
d975 1
d997 10
@


1.61
log
@Add a debug printf to warn when malo_init() fails and resets the card.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.60 2006/12/31 16:50:31 claudio Exp $ */
d488 1
a488 1
	error = bus_dmamap_load(sc->sc_dmat, sc->sc_cmd_dmam, 
d1762 1
a1762 1
        }
d1814 1
a1814 1
	} 
d1969 1
a1969 1
		if (i % 16 == 0) 
d1987 1
a1987 1
		{ MALO_CMD_GET_HW_SPEC, 	"GetHwSpecifications"	},
d2210 2
a2211 2
        struct malo_cmdheader *hdr = sc->sc_cmd_mem;
        struct malo_cmd_aid *body;
d2266 1
a2266 1
	*(uint32_t *)(hdr + 1) = htole32(threshold);	
@


1.60
log
@There is no need to busy wait in malo_send_cmd(). 0x0c14 only stores the
current state of the card (not running, loading FW, running). Now instead
wait after loading the boot firmware for the magical 0x5 to appear.
Also add a few missing bus_dmamap_sync() calls. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.59 2006/12/31 16:42:37 claudio Exp $ */
d963 2
@


1.59
log
@Use a bus_space_barrier instead of those stupid 0x0c14 reads to make sure
that access is done in correct order. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.58 2006/12/31 16:35:49 claudio Exp $ */
d250 1
a250 1
int	malo_send_cmd(struct malo_softc *sc, bus_addr_t addr, uint32_t waitfor);
d516 2
a517 2
int
malo_send_cmd(struct malo_softc *sc, bus_addr_t addr, uint32_t waitfor)
a518 2
	int i;

a522 16

	if (waitfor == 0)
		return (0);

	/* wait for the DMA engine to finish the transfer */
	for (i = 0; i < 100; i++) {
		delay(50);
		malo_ctl_barrier(sc, BUS_SPACE_BARRIER_READ);
		if (malo_ctl_read4(sc, 0x0c14) == waitfor)
			break;
	}

	if (i == 100)
		return (ETIMEDOUT);

	return (0);
d1771 1
a1771 1
	int error;
d1798 10
a1807 1
	if (malo_send_cmd(sc, 0xc000bef8, 5) != 0) {
d1819 1
a1819 1
	malo_send_cmd(sc, 0xc000bef8, 5);
d1859 4
a1862 8
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
		if (malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 5) != 0) {
			printf("%s: timeout at firmware upload!\n",
			    sc->sc_dev.dv_xname);
			free(ucode, M_DEVBUF);
			return (ETIMEDOUT);
		}

d1879 5
a1883 6
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
	if (malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 5) != 0) {
		printf("%s: timeout at sending firmware upload ACK\n",
		    sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}
@


1.58
log
@In malo_init() check for firmware loading errors and in case of an error
reset the card so that we have a chance that a later malo_init() works.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.57 2006/12/31 16:32:44 claudio Exp $ */
d241 3
d522 1
a522 1
	malo_ctl_read4(sc, 0x0c14);
d524 1
a524 1
	malo_ctl_read4(sc, 0x0c14);
d532 1
d550 1
a550 1
	malo_ctl_read4(sc, 0x0c14);
d552 1
a552 1
	malo_ctl_read4(sc, 0x0c14);
d915 1
a915 1
	malo_ctl_read4(sc, 0x0c14);
d917 1
a917 1
	malo_ctl_read4(sc, 0x0c14);
d1513 1
a1513 1
	malo_ctl_read4(sc, 0x0c14);
d1631 1
a1631 1
	malo_ctl_read4(sc, 0x0c14);
d1905 2
@


1.57
log
@malo_stop() never fails so no need to return an error. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.56 2006/12/31 16:27:55 claudio Exp $ */
d904 4
a907 2
	malo_load_bootimg(sc);
	malo_load_firmware(sc);
d916 1
a916 1
		return (error);
d926 1
a926 1
		return (error);
d931 1
a931 1
		return (error);
d936 1
a936 1
		return (error);
d941 1
a941 1
		return (error);
d946 1
a946 1
		return (error);
d951 1
a951 1
		return (error);
d960 1
a960 1
			return (error);
d974 5
@


1.56
log
@Use #ifdef MALO_DEBUG else a simple #define MALO_DEBUG will not work.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.55 2006/12/30 23:31:26 claudio Exp $ */
d260 1
a260 1
int	malo_stop(struct malo_softc *sc);
d1081 1
a1081 1
int
a1108 2

	return (0);
@


1.55
log
@Fix another printf where the format string did not match with the varargs.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.54 2006/12/30 22:43:01 claudio Exp $ */
d333 1
a333 1
#if MALO_DEBUG
@


1.54
log
@Don't use M_DUP_PKTHDR() on static mbufs. M_DUP_PKTHDR() copies the mtag
chain and so a later MFREE() is needed to free the chain again.
Just initialize a minimal mbuf header for bpf_mtap().
See earlier rum(4) commit for the full story.
OK mglocker@@ Sounds good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.53 2006/12/30 01:10:16 claudio Exp $ */
d1885 2
a1886 1
		printf("%s: timeout at sending firmware upload ACK\n");
@


1.53
log
@Why doing something as complex as for () bus_space_write_1(); when there
is bus_space_write_region_1() that does the same. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.52 2006/12/29 20:27:50 mglocker Exp $ */
a1441 1
		M_DUP_PKTHDR(&mb, m0);
d1445 3
a1447 1
		mb.m_pkthdr.len += mb.m_len;
a1553 1
		M_DUP_PKTHDR(&mb, m0);
d1557 3
a1559 1
		mb.m_pkthdr.len += mb.m_len;
a1739 1
			M_DUP_PKTHDR(&mb, m);
d1743 3
a1745 1
			mb.m_pkthdr.len += mb.m_len;
@


1.52
log
@No colon after "address".
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.51 2006/12/12 10:06:29 claudio Exp $ */
d1776 1
a1776 1
	size_t size, count;
d1796 2
a1797 2
	for (count = 0; count < size; count++)
		malo_mem_write1(sc, 0xbf00 + count, ucode[count]);
@


1.51
log
@Make malo(4) work on macppc by adding a few letoh32(), removing some htole32()
-- bus_space(9) does the endian switch for us -- and finaly change one
letoh32() to letoh16(). The last one being by far the nastiest one.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.50 2006/12/10 21:01:53 claudio Exp $ */
d408 1
a408 1
	printf(", address: %s\n", ether_sprintf(ic->ic_myaddr));
@


1.50
log
@Add missing argument to a DPRINTF call.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.49 2006/12/03 10:30:47 claudio Exp $ */
d1349 2
a1350 1
		if ((desc->status & 0x80000000) || !(data->softstat & 0x80))
d1358 1
a1358 1
		switch (desc->status & 0x1) {
d1380 1
a1380 1
		data->softstat &= ~ 0x80;
d1484 1
a1484 1
	data->softstat |= 0x80;
d1601 1
a1601 1
	data->softstat |= 0x80;
d1664 2
a1665 2
		    desc->datarate, desc->physdata, desc->physnext,
		    desc->qosctrl, desc->reserved2));
d1667 1
a1667 1
		if ((letoh32(desc->rxctrl) & 0x80) == 0)
d1712 1
a1712 1
		m->m_pkthdr.len = m->m_len = letoh32(desc->len);
d1758 1
a1758 1
		rxRdPtr = desc->physnext;
d2056 1
a2056 1
	    htole32(sc->sc_rxring.physaddr));
d2058 1
a2058 1
	    htole32(sc->sc_rxring.physaddr));
d2060 1
a2060 1
	    htole32(sc->sc_txring.physaddr));
@


1.49
log
@First bits of endian cleanup more still needed but commit early, commit often.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.48 2006/12/03 10:14:39 claudio Exp $ */
d344 2
a345 1
		DPRINTF(("%s: unkown interrupt %x\n", status));
@


1.48
log
@Print the number of unknown commands in malo_cmd_string(). Also don't
print an empty newline in malo_hexdump(). OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.47 2006/11/30 17:23:34 damien Exp $ */
d327 1
a327 1
		if (hdr->result != MALO_CMD_RESULT_OK) {
d339 1
a339 1
			malo_hexdump(hdr, hdr->size);
d553 1
a553 1
		if (hdr->cmd & 0x8000)
d2017 1
a2017 1
		if (result == results[i].result_code)
@


1.47
log
@fix wep key index in firmware command.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.46 2006/11/30 08:20:25 mglocker Exp $ */
d1965 1
a1965 1
			printf("\n%4i:", i);
d1977 1
d1993 1
a1993 1
		if ((cmd & 0x7fff) == cmds[i].cmd_code)
d1996 2
a1997 1
	return ("unknown");
@


1.46
log
@Yay, forgot to add IEEE80211_C_SHPREAMBLE and IEEE80211_C_SHSLOT
capapility.

Spotted by damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.45 2006/11/29 21:39:46 mglocker Exp $ */
d1915 1
a1915 1
		if (malo_cmd_set_wepkey(sc, wk, ic->ic_wep_txkey))
@


1.45
log
@Enable short slots, which should increase / stableize throughput
performance a bit.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.44 2006/11/29 12:51:29 mglocker Exp $ */
d397 2
@


1.44
log
@Enable monitor mode.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.43 2006/11/28 09:55:57 mglocker Exp $ */
d128 1
d217 5
d285 2
d306 1
d416 1
d1168 2
d1920 36
d2258 22
@


1.43
log
@Instead debug message for WEP key setting, just complain if WEP key
setting fails.  Always return with error in malo_init() if someting
fails.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.42 2006/11/27 15:32:12 mglocker Exp $ */
d385 4
a388 1
	ic->ic_caps = IEEE80211_C_IBSS | IEEE80211_C_WEP;
d869 1
d905 1
d908 5
d951 6
a956 2
	/* start background scanning */
	ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
@


1.42
log
@Enable WEP.

Tested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.41 2006/11/26 23:46:47 mglocker Exp $ */
d921 1
d926 1
d930 1
a930 1
	if (sc->sc_ic.ic_flags & IEEE80211_F_WEPON)
d932 6
a937 1
		malo_set_wepkey(sc);
d1887 2
a1888 2
		if (malo_cmd_set_wepkey(sc, wk, ic->ic_wep_txkey) == 0)
			DPRINTF(("WEP key successfully set\n"));
@


1.41
log
@Replace the firmware reset command by a register write which also
causes a device reset.  This enables resetting also on amd64,
and therefore reinitializing after the 'up' 'down' dance works
now there.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.40 2006/11/26 14:50:39 mglocker Exp $ */
d118 1
d162 12
d278 1
d285 2
d385 1
a385 1
	ic->ic_caps = IEEE80211_C_IBSS;
d927 5
d973 6
a978 2
	if (error == ENETRESET)
		error = malo_init(ifp);
d1868 19
d1992 26
@


1.40
log
@It's sizeof(struct ieee80211_frame) not sizeof(struct ieee80211_frame *).

Spotted by damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.39 2006/11/26 11:14:18 deraadt Exp $ */
a117 1
#define MALO_CMD_SET_RESET		0x0005
a270 1
int	malo_cmd_reset(struct malo_softc *sc);
d1030 1
a1030 1
	/* try to reset card, if the firmware is loaded */
d1032 1
a1032 1
		malo_cmd_reset(sc);
a1947 16
}

int
malo_cmd_reset(struct malo_softc *sc)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;

	hdr->cmd = htole16(MALO_CMD_SET_RESET);
	hdr->size = htole16(sizeof(*hdr));
	hdr->seqnum = 1;
	hdr->result = 0;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (malo_send_cmd_dma(sc, sc->sc_cmd_dmaaddr));
@


1.39
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.38 2006/11/25 14:20:48 mglocker Exp $ */
d1354 2
a1355 2
	if (m0->m_len < sizeof(struct ieee80211_frame *)) {
		m0 = m_pullup(m0, sizeof(struct ieee80211_frame *));
d1465 2
a1466 2
	if (m0->m_len < sizeof(struct ieee80211_frame *)) {
		m0 = m_pullup(m0, sizeof(struct ieee80211_frame *));
@


1.38
log
@Cleanup obsolete rate bits and pass right value to the TX rate descriptor.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.37 2006/11/25 10:52:45 mglocker Exp $ */
a285 6
/* supported rates */
const struct ieee80211_rateset  malo_rates_11b =
    { 4, { 2, 4, 11, 22 } };
const struct ieee80211_rateset  malo_rates_11g =
    { 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d356 2
a357 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = malo_rates_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = malo_rates_11g;
@


1.37
log
@If no TX rate has been calculated yet, set rate value to autoselect
instead DS1.  Add 'mode' informations to malo_media_status().  Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.36 2006/11/24 23:29:39 mglocker Exp $ */
a1172 1
	int rate;
d1179 3
a1181 3
	/* convert chip bitmap rate to 802.11 rate */
	rate = malo_chip2rate(sc->sc_last_txrate);
	imr->ifm_active |= ieee80211_rate2media(ic, rate, ic->ic_curmode);
d1316 1
a1316 3
		sc->sc_last_txrate = desc->datarate;
		DPRINTFN(2, ("%s: datarate=%d\n",
		    sc->sc_dev.dv_xname, sc->sc_last_txrate));
d1353 1
a1353 1
	int rate, error;
a1359 3
	/* send mgt frames at the lowest available rate */
	rate = 2;

d1384 1
a1384 1
		tap->wt_rate = rate;
d1432 1
a1432 1
	malo_tx_setup_desc(sc, desc, m0->m_pkthdr.len, rate,
d1441 2
a1442 2
	DPRINTFN(2, ("%s: sending mgmt frame, pktlen=%u, idx=%u, rate=%u\n",
	    sc->sc_dev.dv_xname, m0->m_pkthdr.len, sc->sc_txring.cur, rate));
d1464 1
a1464 1
	int rate, error;
a1470 3
	/* XXX we care later about rate control */
	rate = 2;

d1495 1
a1495 1
		tap->wt_rate = rate;
d1549 1
a1549 1
	malo_tx_setup_desc(sc, desc, m0->m_pkthdr.len, rate,
d1558 2
a1559 2
	DPRINTFN(2, ("%s: sending data frame, pktlen=%u, idx=%u, rate=%u\n",
	    sc->sc_dev.dv_xname, m0->m_pkthdr.len, sc->sc_txring.cur, rate));
d1576 1
a1576 1
	desc->datarate = rate;
@


1.36
log
@Small KNF fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.35 2006/11/24 23:28:24 mglocker Exp $ */
d364 1
d1053 1
a1053 1
	sc->sc_last_txrate = 0;
d1198 9
d1214 4
a1217 4
	case  0:	return 2;
	case  1:	return 4;
	case  2:	return 11;
	case  3:	return 22;
d1220 9
a1228 8
	case  5:	return 12;
	case  6:	return 18;
	case  7:	return 24;
	case  8:	return 36;
	case  9:	return 48;
	case 10:	return 72;
	case 11:	return 96;
	case 12:	return 108;
d1230 2
a1231 2
	/* unknown rate: should not happen */
	default:	return 0;
d1240 4
a1243 4
	case  0:	return 2;
	case  1:	return 4;
	case  2:	return 11;
	case  3:	return 22;
d1246 8
a1253 8
	case  4:	return 12;
	case  5:	return 18;
	case  6:	return 24;
	case  7:	return 36;
	case  8:	return 48;
	case  9:	return 72;
	case 10:	return 96;
	case 11:	return 108;
d1256 1
a1256 1
	default:	return 0;
@


1.35
log
@Enable setting of fixed rates.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.34 2006/11/24 20:45:33 mglocker Exp $ */
d1203 15
a1217 15
		/* CCK rates */
		case  0:	return 2;
		case  1:	return 4;
		case  2:	return 11;
		case  3:	return 22;

		/* OFDM rates */
		case  5:	return 12;
		case  6:	return 18;
		case  7:	return 24;
		case  8:	return 36;
		case  9:	return 48;
		case 10:	return 72;
		case 11:	return 96;
		case 12:	return 108;
d1219 2
a1220 2
		/* unknown rate: should not happen */
		default:	return 0;
@


1.34
log
@Enable automatic rate adapation (done by firmware and hardware).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.33 2006/11/23 22:03:07 mglocker Exp $ */
d253 1
d1073 1
d1114 1
a1114 1
		else
d1116 3
a1118 1
			malo_cmd_set_rate(sc, 0); /* XXX */
d1224 25
d1307 2
d2154 1
d2185 8
a2192 1
		/* TODO */
@


1.33
log
@Remove 802.11a stuff.  There is one RF chip (88W8030) which supports 5GHz,
but it seems rarely used and we don't know in connecton with which
chip.  88W8335/88W8310 uses 88W8000G RF (2.4GHz).
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.32 2006/11/23 20:19:19 mglocker Exp $ */
d125 1
d198 6
d251 2
d283 1
d395 1
a395 1
	ieee80211_media_init(ifp, malo_media_change, ieee80211_media_status);
d1040 1
d1043 1
d1046 1
d1050 3
a1100 1
#if 0
d1108 7
a1114 1
#endif
d1164 57
d1276 3
d2110 45
@


1.32
log
@The duration field is calculated by the firmware.  Remove malo_txtime()
therefore.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.31 2006/11/22 22:06:48 mglocker Exp $ */
a112 1
#define MALO_RATE_IS_OFDM(rate)	((rate) >= 12 && (rate) != 22)
d1241 1
a1241 1
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;
@


1.31
log
@Remove rssadapt(9) bits;  Firmware supports rate adaption.  Also,
remove unused arguments in the TX descriptor setup routine.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.30 2006/11/21 22:06:26 mglocker Exp $ */
a252 2
uint16_t
	malo_txtime(int len, int rate, uint32_t flags);
a1233 1
	uint16_t dur;
a1279 6

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		dur = malo_txtime(14, rate, ic->ic_flags);
		*(uint16_t *)wh->i_dur = htole16(dur);
	}

a1465 21
}

uint16_t
malo_txtime(int len, int rate, uint32_t flags)
{
	uint16_t txtime;

	if (MALO_RATE_IS_OFDM(rate)) {
		/* IEEE Std 802.11g-2003, pp. 44 */
		txtime = (8 + 4 * len + 3 + rate - 1) / rate;
		txtime = 16 + 4 + 4 * txtime + 6;
	} else {
		/* IEEE Std 802.11b-1999, pp. 28 */
		txtime = (16 * len + rate - 1) / rate;
		if (rate != 2 && (flags & IEEE80211_F_SHPREAMBLE))
			txtime +=  72 + 24;
		else
			txtime += 144 + 48;
	}

	return (txtime);
@


1.30
log
@Free allocated mbufs at TX done.  While there also reset some TX descriptor
values.

Fixes "WARNING: mclpool limit reached; increase kern.maxclusters"

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.29 2006/11/16 21:18:42 mglocker Exp $ */
a50 1
#include <net80211/ieee80211_rssadapt.h>
a66 1
	struct ieee80211_rssadapt	rssadapt; /* XXX maybe no need */
d252 1
a252 2
	    uint32_t flags, uint16_t xflags, int len, int rate,
	    const bus_dma_segment_t *segs, int nsegs, int ac);
a1236 1
	uint32_t flags = 0;
d1325 2
a1326 2
	malo_tx_setup_desc(sc, desc, flags, 0, m0->m_pkthdr.len, rate,
	    data->map->dm_segs, data->map->dm_nsegs, 0);
a1356 1
	uint32_t flags = 0;
d1445 2
a1446 2
	malo_tx_setup_desc(sc, desc, flags, 0, m0->m_pkthdr.len, rate,
	    data->map->dm_segs, data->map->dm_nsegs, 0);
d1469 1
a1469 2
    uint32_t flags, uint16_t xflags, int len, int rate,
    const bus_dma_segment_t *segs, int nsegs, int ac)
a1504 1
	struct malo_node *rn;
a1614 4

		/* give rssi to the rate adaption algorithm */
		rn = (struct malo_node *)ni;
		ieee80211_rssadapt_input(ic, ni, &rn->rssadapt, desc->rssi);
@


1.29
log
@Drop malo_reset() for now and do ENETRESET and media changes using
malo_stop() / malo_init().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.28 2006/11/16 15:11:01 mglocker Exp $ */
d1204 5
d1210 1
d1213 2
@


1.28
log
@Minor cleanup; reactivate malo_cmd_reset() which seems to work now, remove
some dead code, protect ieee80211_next_scan() from network interrupts,
fix some comments.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.27 2006/11/15 21:44:04 mglocker Exp $ */
a246 1
int	malo_reset(struct ifnet *ifp);
d854 7
a860 1
	DPRINTF(("%s: malo_init\n", ifp->if_xname));
d955 1
a955 1
		error = malo_reset(ifp);
d1030 2
d1043 1
a1043 1
	DPRINTF(("%s: malo_stop\n", ifp->if_xname));
d1143 1
a1143 53
		malo_reset(ifp);

	return (0);
}

int
malo_reset(struct ifnet *ifp)
{
	struct malo_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	u_int chan;

	DPRINTF(("%s: %s\n", sc->sc_dev.dv_xname, __func__));

	if (ic->ic_state == IEEE80211_S_RUN) {
		if (malo_cmd_set_antenna(sc, 1) != 0) {
			DPRINTF(("%s: can't set RX antenna\n",
			    sc->sc_dev.dv_xname));
			return (EIO);
		}

		if (malo_cmd_set_antenna(sc, 2) != 0) {
			DPRINTF(("%s: can't set TX antenna\n",
			    sc->sc_dev.dv_xname));
			return (EIO);
		}
	}

	if (ic->ic_state == IEEE80211_S_RUN &&
	    ic->ic_opmode != IEEE80211_M_HOSTAP) {
		/*
		 * The prescan and postscan commands are mandatory
		 * required.  Otherwise FW will not be able to send or
		 * receive any frame.
		 */
		if (malo_cmd_set_prescan(sc) != 0) {
			DPRINTF(("%s: can't prescan\n", sc->sc_dev.dv_xname));
			return (EIO);
		}

		if (malo_cmd_set_postscan(sc, ic->ic_myaddr, 1) != 0) {
			DPRINTF(("%s: can't postscan\n", sc->sc_dev.dv_xname));
			return (EIO);
		}

		chan = ieee80211_chan2ieee(ic, ic->ic_ibss_chan);
		if (malo_cmd_set_channel(sc, chan) != 0) {
			DPRINTF(("%s: can't set channel\n",
			    sc->sc_dev.dv_xname));
			return (EIO);
		} else
			DPRINTF(("%s: set channel to %u\n", chan));
	}
@


1.27
log
@Quiet down debug output by default.  Improve cmd response/result handling.

discussed with claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.26 2006/11/15 16:27:37 mglocker Exp $ */
d37 1
a37 1
//#include <machine/intr.h>
d68 1
a68 1
	struct ieee80211_rssadapt	rssadapt;
d77 4
a80 6
	bus_dmamap_t			map;
	struct mbuf			*m;
	uint32_t			softstat;
	/* additional info for rate adaption */
	struct ieee80211_node		*ni;
//	struct ieee80211_rssdesc	id;
d121 1
a340 9
#if 0
	/* ???, what is this for, seems unnecessary */
	/* malo_ctl_write4(sc, 0x0c38, 0x1f); */
	/* disable interrupts */
	malo_ctl_read4(sc, 0x0c30);
	malo_ctl_write4(sc, 0x0c30, 0);
	malo_ctl_write4(sc, 0x0c34, 0);
	malo_ctl_write4(sc, 0x0c3c, 0);
#endif
a1025 1
#if 0
d1027 1
a1027 2
		malo_cmd_reset(sc); /* returns a command error */
#endif
d1199 1
d1203 2
d1207 2
d1928 1
a1928 1
	hdr->cmd = htole16(5);
d1990 1
a1990 1
	body->action = htole16(1); /* seems this is needed */
@


1.26
log
@Enable data packet transmission.

Diff done in co-operation with claudio, commited via malo(4).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.25 2006/11/15 13:18:26 claudio Exp $ */
d57 3
a59 1
#define DPRINTF(x)	do { printf x; } while (0)
d62 1
d122 17
a138 10
#define MALO_CMD_GET_HW_SPEC	0x0003
#define MALO_CMD_SET_RADIO	0x001c
#define MALO_CMD_SET_AID	0x010d
#define MALO_CMD_SET_TXPOWER	0x001e
#define MALO_CMD_SET_ANTENNA	0x0020
#define MALO_CMD_SET_PRESCAN	0x0107
#define MALO_CMD_SET_POSTSCAN	0x0108
#define MALO_CMD_SET_CHANNEL	0x010a
#define MALO_CMD_SET_RTS	0x0113
#define MALO_CMD_RESPONSE	0x8000
d264 5
d307 5
a311 37
		switch (hdr->cmd & ~MALO_CMD_RESPONSE) {
		case MALO_CMD_GET_HW_SPEC:
			DPRINTF(("%s: cmd answer for MALO_CMD_GET_SPEC=%x",
			    sc->sc_dev.dv_xname, hdr->result));
			break;
		case MALO_CMD_SET_RADIO:
			DPRINTF(("%s: cmd answer for MALO_CMD_SET_RADIO=%x",
			    sc->sc_dev.dv_xname, hdr->result));
			break;
		case MALO_CMD_SET_TXPOWER:
			DPRINTF(("%s: cmd answer for MALO_CMD_SET_TXPOWER=%x",
			    sc->sc_dev.dv_xname, hdr->result));
			break;
		case MALO_CMD_SET_ANTENNA:
			DPRINTF(("%s: cmd answer for MALO_CMD_SET_ANTENNA=%x",
			    sc->sc_dev.dv_xname, hdr->result));
			break;
		case MALO_CMD_SET_PRESCAN:
			DPRINTF(("%s: cmd answer for MALO_CMD_SET_PRESCAN=%x",
			    sc->sc_dev.dv_xname, hdr->result));
			break;
		case MALO_CMD_SET_POSTSCAN:
			DPRINTF(("%s: cmd answer for MALO_CMD_SET_POSTSCAN=%x",
			    sc->sc_dev.dv_xname, hdr->result));
			break;
		case MALO_CMD_SET_CHANNEL:
			DPRINTF(("%s: cmd answer for MALO_CMD_SET_CHANNEL=%x",
			   sc->sc_dev.dv_xname, hdr->result));
			break;
		case MALO_CMD_SET_RTS:
			DPRINTF(("%s: cmd answer for MALO_CMD_SET_RTS=%x",
			    sc->sc_dev.dv_xname, hdr->result));
			break;
		default:
			DPRINTF(("%s: cmd answer for UNKNOWN=%x",
			    sc->sc_dev.dv_xname, hdr->result));
			break;
d314 6
a319 10
		int i;

		for (i = 0; i < hdr->size; i++) {
			if (i % 16 == 0) 
				printf("\n%4i:", i);
			if (i % 4 == 0)
				printf(" ");
			printf("%02x", (int)*((u_char *)hdr + i));
		}
		printf("\n");
d975 1
a975 1
	DPRINTF(("%s: %s\n", sc->sc_dev.dv_xname, __func__));
a1080 3
			else
				DPRINTF(("%s: prescan done\n",
				    sc->sc_dev.dv_xname));
d1089 1
a1089 1
		DPRINTF(("AUTH\n"));
d1095 1
a1095 1
		DPRINTF(("ASSOC\n"));
d1107 1
a1107 1
		DPRINTF(("RUN\n"));
d1228 1
a1228 1
	DPRINTF(("%s: %s\n", sc->sc_dev.dv_xname, __func__));
d1247 1
a1247 1
			DPRINTF(("data frame was sent successfully\n"));
d1260 1
a1260 1
		DPRINTF(("tx done idx=%u\n", sc->sc_txring.stat));
d1287 1
a1287 1
	DPRINTF(("%s: %s\n", sc->sc_dev.dv_xname, __func__));
d1382 1
a1382 1
	DPRINTF(("%s: sending mgmt frame, pktlen=%u, idx=%u, rate=%u\n",
d1408 1
a1408 1
	DPRINTF(("%s: %s\n", sc->sc_dev.dv_xname, __func__));
d1503 1
a1503 1
	DPRINTF(("%s: sending data frame, pktlen=%u, idx=%u, rate=%u\n",
d1572 2
a1573 2
#if 0
		DPRINTF(("rx intr idx=%d, rxctrl=0x%02x, rssi=%d, "
d1580 1
a1580 1
#endif
d1699 2
a1700 2
		DPRINTF(("%s: error %d, could not read microcode %s!\n",
		    sc->sc_dev.dv_xname, error, name));
d1753 2
a1754 2
		DPRINTF(("%s: error %d, could not read microcode %s!\n",
		    sc->sc_dev.dv_xname, error, name));
d1821 63
@


1.25
log
@Fix the loop in malo_tx_intr(). This fixes a infinit loop that happend after
resetting the card. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.24 2006/11/12 14:54:58 claudio Exp $ */
d243 2
d1040 6
a1045 1
			/* TODO malo_tx_data() */
d1410 1
a1410 2
	sc->sc_txring.cur = (sc->sc_txring.cur + 1) %
	    sizeof(struct malo_tx_desc);
d1413 121
@


1.24
log
@In malo_send_cmd_dma() reduce the poll loop to 10 and increase the delay
to 100. Even the slowest command take only about half of the time so this
should be enough. Discussed with mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.23 2006/11/12 14:26:04 claudio Exp $ */
d1243 1
d1247 1
d1259 1
a1259 1
			continue;
d1280 1
d1283 2
@


1.23
log
@Rewrite part of malo_tx_mgt() to do the mbuf dance in a nicer way. This
is still ugly beyond any help but what do you expect from HW that needs
to insert unused fields between header and data? OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.22 2006/11/12 14:18:29 claudio Exp $ */
d550 2
a551 2
	for (i = 0; i < 100; i++) {
		delay(50);
d558 1
a558 1
	if (i == 100)
@


1.22
log
@Simplify code and remove a delay() by actually waiting for the command to
finish. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.21 2006/11/10 22:29:44 mglocker Exp $ */
d1307 7
d1357 11
a1367 5
	m0 = m_pullup(m0, sizeof(*wh));
	if (M_TRAILINGSPACE(m0) < 8)
		return (1);
	bcopy(m0->m_data + 24, m0->m_data + 32, m0->m_len - 24);
	bcopy(m0->m_data, m0->m_data + 2, 24);
d1370 1
a1370 1
	*(uint16_t *)m0->m_data = htole16(m0->m_len - 32); /* FW len */
@


1.21
log
@Fix DMA firmware command interface (poll for command response), and get the
card to associate successfully with an AP.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.20 2006/11/09 10:25:12 mglocker Exp $ */
d1260 2
a1261 2
		switch (desc->status & 0x00000001) {
		case 0x00000001:
d1613 1
a1613 1
	malo_send_cmd(sc, 0xc000bef8, 0);
a1614 2
	/* give card a bit time to init */
	delay(50);
@


1.20
log
@Fix a bug in the firmware command function and check if the main firmware
has been loaded by polling for the firmware response instead just waiting
a static amount of time.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.19 2006/11/07 21:39:32 mglocker Exp $ */
d114 1
d121 1
d161 7
d181 5
d217 1
d246 2
d255 2
a256 1
int	malo_cmd_set_postscan(struct malo_softc *sc);
d261 2
a313 2
			/* wakeup caller */
			wakeup(sc);
a315 3
			bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0,
			    PAGE_SIZE, BUS_DMASYNC_POSTWRITE |
			    BUS_DMASYNC_POSTREAD);
d540 25
d939 3
a1088 8
		if (ostate == IEEE80211_S_SCAN) {
			if (malo_cmd_set_postscan(sc) != 0)
				DPRINTF(("%s: can't set postscan\n",
				    sc->sc_dev.dv_xname));
			else
				DPRINTF(("%s: postscan done\n",
				    sc->sc_dev.dv_xname));
		}
d1105 21
d1205 1
a1205 1
		if (malo_cmd_set_postscan(sc) != 0) {
d1295 1
d1337 5
d1350 1
d1406 21
d1723 1
a1723 7
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malocmd", hz);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);

	if ((hdr->cmd & MALO_CMD_RESPONSE) == 0)
d1761 1
a1761 10
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malocmd", hz);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	if (hdr->cmd & MALO_CMD_RESPONSE)
		return (0);
	else
		return (ETIMEDOUT);
d1777 1
a1777 10
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malocmd", hz);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	if (hdr->cmd & MALO_CMD_RESPONSE)
		return (0);
	else
		return (ETIMEDOUT);
d1781 1
a1781 1
malo_cmd_set_postscan(struct malo_softc *sc)
d1784 1
d1787 1
a1787 1
	hdr->size = htole16(sizeof(*hdr));
d1790 5
d1799 1
a1799 10
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malocmd", hz);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	if (hdr->cmd & MALO_CMD_RESPONSE)
		return (0);
	else
		return (ETIMEDOUT);
d1815 1
a1815 1
	body->action = 0;	/* seems this is needed */
d1821 1
a1821 3
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);

	return (0);
d1846 1
a1846 10
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malocmd", hz);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	if (hdr->cmd & MALO_CMD_RESPONSE)
		return (0);
	else
		return (ETIMEDOUT);
d1870 18
a1887 2
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malocmd", hz);
d1890 1
a1890 1
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
d1892 1
a1892 4
	if (hdr->cmd & MALO_CMD_RESPONSE)
		return (0);
	else
		return (ETIMEDOUT);
d1919 1
a1919 10
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malocmd", hz);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	if (hdr->cmd & MALO_CMD_RESPONSE)
		return (0);
	else
		return (ETIMEDOUT);
d1937 1
a1937 10
	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malocmd", hz);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	if (hdr->cmd & MALO_CMD_RESPONSE)
		return (0);
	else
		return (ETIMEDOUT);
@


1.19
log
@Add TX done cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.18 2006/11/06 23:03:44 mglocker Exp $ */
d514 1
a514 1
		if (malo_ctl_read4(sc, 0x0c14) == waitfor);
d1546 1
a1546 1
	int sn, error;
d1555 2
a1556 1
	DPRINTF(("%s: loading firmware\n", sc->sc_dev.dv_xname));
d1584 5
a1588 1
	
d1596 15
a1610 1
	if (malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0xf0f1f2f4) != 0) {
a1614 2
	/* give card a bit time to load firmware */
	delay(20000);
@


1.18
log
@Also reset the TX ring if the card gets stopped.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.17 2006/11/06 19:00:49 mglocker Exp $ */
d76 1
d1184 3
d1190 35
a1224 1
	/* TODO */
d1226 1
d1307 1
@


1.17
log
@Enable TX of management frames.  Fix/add firmware commands, add more debug
informations, minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.16 2006/10/29 16:43:34 claudio Exp $ */
d208 1
d762 35
a822 1
#if 0
a827 1
#endif
d1015 1
@


1.16
log
@Reorganize malo_intr() a bit. Check for unhandled interrupt flags and
do not call wakeup() for each and every command sent. I think more and more
will not tsleep(). OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.15 2006/10/29 16:41:35 claudio Exp $ */
a75 1
	uint32_t			softstat;
d81 1
a81 1
/* Rx descriptor used by HW */
d96 1
d114 3
a116 1
/* firmware commands as found in a document describing the Libertas FW */
d118 3
d124 1
d152 24
d232 1
d238 5
d266 47
a312 3
		struct malo_cmdheader	*hdr = sc->sc_cmd_mem;
#ifdef MALO_DEBUG
		int			 i;
a313 1
		printf("%s: command answer", sc->sc_dev.dv_xname);
d323 1
a323 17
		switch (hdr->cmd & ~MALO_CMD_RESPONSE) {
		case MALO_CMD_SET_CHANNEL:
			bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0,
			    PAGE_SIZE, BUS_DMASYNC_POSTWRITE |
			    BUS_DMASYNC_POSTREAD);
			if (hdr->result != 0)
				DPRINTF(("%s: command failed: %x\n",
				    sc->sc_dev.dv_xname, hdr->result));
			break;
		case MALO_CMD_GET_HW_SPEC:
		case MALO_CMD_SET_PRESCAN:
		case MALO_CMD_SET_POSTSCAN:
			/* wakeup caller */
			wakeup(sc);
			break;
		}
	} 
d377 4
a380 1
		ic->ic_channels[i].ic_flags = IEEE80211_CHAN_PUREG;
d387 1
d731 1
a731 1
	ring->data = malloc(count * sizeof (struct malo_tx_data), M_DEVBUF,
d740 1
a740 1
	memset(ring->data, 0, count * sizeof (struct malo_tx_data));
d754 1
a754 1
	return 0;
d757 1
a757 1
	return error;
d806 1
d834 28
d972 1
d974 2
a975 1
		malo_cmd_reset(sc);
d1027 4
a1031 5

		chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);

		malo_cmd_set_channel(sc, chan);

d1087 38
a1124 6
	/* set channel */
	chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
	if (malo_cmd_set_channel(sc, chan) != 0) {
		DPRINTF(("%s: setting channel to %u failed!\n",
		    sc->sc_dev.dv_xname, chan));
		return (EIO);
a1126 1
	DPRINTF(("%s: setting channel to %u\n", sc->sc_dev.dv_xname, chan));
d1151 3
a1172 3
	if (data->softstat & 0x80)
		return (EAGAIN);

d1183 1
a1186 9
	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return (error);
	}

d1206 25
a1232 1
	data->softstat |= 0x80;
d1243 1
a1243 1
	DPRINTF(("%s: sending mgmt frame, len=%u idx=%u rate=%u\n",
d1322 1
a1322 1
		   mtod(mnew, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
d1349 6
a1354 2
		 * cut out chip specific control blocks from the 802.11 frame:
		 * 2 bytes ctrl, 24 bytes header, 6 byte ctrl, n bytes data
a1364 1
			/*
a1368 1
			*/
d1370 1
a1370 1
			tap->wr_max_rssi = 75;
a1539 3
	DPRINTF(("%s: fw cmd %04x size %d\n", sc->sc_dev.dv_xname,
	    hdr->cmd, hdr->size));

d1548 1
a1548 1
	tsleep(sc, 0, "malospc", hz);
d1556 1
a1556 1
	/* XXX get the data form the buffer and feed it to ieee80211 */
d1592 1
a1592 1
	tsleep(sc, 0, "malorst", hz);
d1608 1
a1608 1
	hdr->cmd = MALO_CMD_SET_PRESCAN;
d1617 1
a1617 1
	tsleep(sc, 0, "malosca", hz);
d1633 1
a1633 1
	hdr->cmd = MALO_CMD_SET_POSTSCAN;
d1642 1
a1642 1
	tsleep(sc, 0, "malosca", hz);
d1657 1
d1660 1
a1660 1
	hdr->size = htole16(sizeof(*hdr) + sizeof(channel));
d1663 1
d1665 3
a1667 1
	*(uint8_t *)(hdr + 1) = channel;
d1675 130
@


1.15
log
@In malo_ioctl() if the returned error is ENETRESET reset the device.
This is net80211 way of telling the driver that settings have changed.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.14 2006/10/29 16:14:56 claudio Exp $ */
d225 4
d230 1
a231 1
		struct malo_cmdheader	*hdr = sc->sc_cmd_mem;
d244 17
a260 6
		/* wakeup caller */
		wakeup(sc);
	}

	if (status & 0x1)
		malo_tx_intr(sc);
d262 2
a263 2
	if (status & 0x2)
		malo_rx_intr(sc);
@


1.14
log
@MALO_CMD_RESPONSE is acting just as a flag so move it to the end of the list.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.13 2006/10/29 16:00:49 claudio Exp $ */
d788 3
@


1.13
log
@Fix some nasty bugs in malo_reset() and malo_cmd_set_channel() and simplify
the code a bit. Still impossible to correctly set a channel but it is no
longer crashing.  OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.12 2006/10/29 11:41:34 mglocker Exp $ */
a115 1
#define MALO_CMD_RESPONSE	0x8000
d119 1
@


1.12
log
@Add first TX path and active scan bits.  Don't expect to much yet.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.11 2006/10/25 20:42:57 mglocker Exp $ */
d968 1
a968 1
	int chan;
d974 5
a978 4
	if (malo_cmd_set_channel(sc, chan) == 0)
		DPRINTF(("%s: setting channel to %d\n", chan));
	else
		DPRINTF(("%s: setting channel to %d failed!\n", chan));
d980 1
d1502 1
a1502 1
	bcopy(&channel, (void *)hdr + 1, sizeof(channel));
a1507 1
	//tsleep(sc, 0, "malochn", hz);
d1509 1
a1509 7
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	if (hdr->cmd & MALO_CMD_RESPONSE)
		return (0);
	else
		return (ETIMEDOUT);
@


1.11
log
@Resort some functions, tiny cleanup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.10 2006/10/24 19:20:01 mglocker Exp $ */
d5 1
d76 1
d78 1
a78 1
//	struct ieee80211_node		*ni;
d117 3
d190 9
d204 3
a224 2
	DPRINTF(("%s: INTERRUPT %08x\n", sc->sc_dev.dv_xname, status));

d244 3
d262 4
d322 1
a322 2
	ieee80211_media_init(ifp, ieee80211_media_change,
	    ieee80211_media_status);
d347 3
d797 18
d816 33
d863 2
d883 41
a923 1
	return (0);
d946 158
d1128 1
a1128 1

d1136 1
a1136 1

d1204 1
a1204 1
			tap->wr_max_rssi = 100; /* XXX find out correct max */
d1430 77
@


1.10
log
@Fix RX DMA handling; until now the card stopped receiving interrupts
after it went one time through the RX ring (256 descriptors).  Also
reset RX rings correctly after ifconfig down / up.

"COMMIT IT!!!" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.9 2006/10/22 00:18:42 mglocker Exp $ */
a140 1

d166 1
a173 5
int	malo_load_bootimg(struct malo_softc *sc);
int	malo_load_firmware(struct malo_softc *sc);
int	malo_send_cmd(struct malo_softc *sc, bus_addr_t addr, uint32_t waitfor);
int	malo_reset(struct malo_softc *sc);
int	malo_get_spec(struct malo_softc *sc);
d186 4
d234 1
d245 2
a246 2
	/* ??? */
	//malo_ctl_write4(sc, 0x0c38, 0x1f);
d391 26
a696 223
malo_load_bootimg(struct malo_softc *sc)
{
	char *name = "mrv8k-b.fw";
	uint8_t	*ucode;
	size_t size, count;
	int error;

	/* load boot firmware */
	if ((error = loadfirmware(name, &ucode, &size)) != 0) {
		DPRINTF(("%s: error %d, could not read microcode %s!\n",
		    sc->sc_dev.dv_xname, error, name));
		return (EIO);
	}

	/*
	 * It seems we are putting this code directly onto the stack of
	 * the ARM cpu. I don't know why we need to instruct the DMA
	 * engine to move the code. This is a big riddle without docu.
	 */
	DPRINTF(("%s: loading boot firmware\n", sc->sc_dev.dv_xname));
	malo_mem_write2(sc, 0xbef8, 0x001);
	malo_mem_write2(sc, 0xbefa, size);
	malo_mem_write4(sc, 0xbefc, 0);

	for (count = 0; count < size; count++)
		malo_mem_write1(sc, 0xbf00 + count, ucode[count]);

	/*
	 * we loaded the firmware into card memory now tell the CPU
	 * to fetch the code and execute it. The memory mapped via the
	 * first bar is internaly mapped to 0xc0000000.
	 */
	if (malo_send_cmd(sc, 0xc000bef8, 5) != 0) {
		printf("%s: timeout at boot firmware load!\n",
		    sc->sc_dev.dv_xname);
		free(ucode, M_DEVBUF);
		return (ETIMEDOUT);
	} 
	free(ucode, M_DEVBUF);

	/* tell the card we're done and... */
	malo_mem_write2(sc, 0xbef8, 0x001);
	malo_mem_write2(sc, 0xbefa, 0);
	malo_mem_write4(sc, 0xbefc, 0);
	malo_send_cmd(sc, 0xc000bef8, 0);

	/* give card a bit time to init */
	delay(50);
	DPRINTF(("%s: boot firmware loaded\n", sc->sc_dev.dv_xname));

	return (0);
}

int
malo_load_firmware(struct malo_softc *sc)
{
	struct malo_cmdheader *hdr;
	char *name = "mrv8k-f.fw";
	void *data;
	uint8_t *ucode;
	size_t size, count, bsize;
	int sn, error;

	/* load real firmware now */
	if ((error = loadfirmware(name, &ucode, &size)) != 0) {
		DPRINTF(("%s: error %d, could not read microcode %s!\n",
		    sc->sc_dev.dv_xname, error, name));
		return (EIO);
	}

	DPRINTF(("%s: loading firmware\n", sc->sc_dev.dv_xname));
	hdr = sc->sc_cmd_mem;
	data = hdr + 1;
	sn = 1;
	for (count = 0; count < size; count += bsize) {
		bsize = MIN(256, size - count);

		hdr->cmd = htole16(0x0001);
		hdr->size = htole16(bsize);
		hdr->seqnum = htole16(sn++);
		hdr->result = 0;

		bcopy(ucode + count, data, bsize);

		bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
		if (malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 5) != 0) {
			printf("%s: timeout at firmware upload!\n",
			    sc->sc_dev.dv_xname);
			free(ucode, M_DEVBUF);
			return (ETIMEDOUT);
		}

		delay(100);
	}
	free(ucode, M_DEVBUF);

	DPRINTF(("%s: firmware upload finished\n", sc->sc_dev.dv_xname));
	
	hdr->cmd = htole16(0x0001);
	hdr->size = 0;
	hdr->seqnum = htole16(sn++);
	hdr->result = 0;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
	if (malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0xf0f1f2f4) != 0) {
		printf("%s: timeout at firmware load!\n", sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}

	/* give card a bit time to load firmware */
	delay(20000);
	DPRINTF(("%s: firmware loaded\n", sc->sc_dev.dv_xname));

	return (0);
}

int
malo_send_cmd(struct malo_softc *sc, bus_addr_t addr, uint32_t waitfor)
{
	int i;

	malo_ctl_write4(sc, 0x0c10, (uint32_t)addr);
	malo_ctl_read4(sc, 0x0c14);
	malo_ctl_write4(sc, 0x0c18, 2); /* CPU_TRANSFER_CMD */
	malo_ctl_read4(sc, 0x0c14);

	if (waitfor == 0)
		return (0);

	/* wait for the DMA engine to finish the transfer */
	for (i = 0; i < 100; i++) {
		delay(50);
		if (malo_ctl_read4(sc, 0x0c14) == waitfor);
			break;
	}

	if (i == 100)
		return (ETIMEDOUT);

	return (0);
}

int
malo_reset(struct malo_softc *sc)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;

	hdr->cmd = htole16(5);
	hdr->size = htole16(sizeof(*hdr));
	hdr->seqnum = 1;
	hdr->result = 0;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malorst", hz);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);

	if (hdr->cmd & MALO_CMD_RESPONSE)
		return (0);
	else
		return (ETIMEDOUT);
}

int
malo_get_spec(struct malo_softc *sc)
{
	struct malo_cmdheader *hdr = sc->sc_cmd_mem;
	struct malo_hw_spec *spec;

	hdr->cmd = htole16(MALO_CMD_GET_HW_SPEC);
	hdr->size = htole16(sizeof(*hdr) + sizeof(*spec));
	hdr->seqnum = htole16(42);	/* the one and only */
	hdr->result = 0;
	spec = (struct malo_hw_spec *)(hdr + 1);

	DPRINTF(("%s: fw cmd %04x size %d\n", sc->sc_dev.dv_xname,
	    hdr->cmd, hdr->size));

	bzero(spec, sizeof(*spec));
	memset(spec->PermanentAddress, 0xff, ETHER_ADDR_LEN);
	spec->CookiePtr = htole32(sc->sc_cookie_dmaaddr);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	malo_send_cmd(sc, sc->sc_cmd_dmaaddr, 0);
	tsleep(sc, 0, "malospc", hz);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cmd_dmam, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);

	if ((hdr->cmd & MALO_CMD_RESPONSE) == 0)
		return (ETIMEDOUT);

	/* XXX get the data form the buffer and feed it to ieee80211 */
	DPRINTF(("%s: get_hw_spec: V%x R%x, #WCB %d, #Mcast %d, Regcode %d, "
	    "#Ant %d\n", sc->sc_dev.dv_xname, htole16(spec->HwVersion),
	    htole32(spec->FWReleaseNumber), htole16(spec->NumOfWCB),
	    htole16(spec->NumOfMCastAdr), htole16(spec->RegionCode),
	    htole16(spec->NumberOfAntenna)));

	/* tell the DMA engine where our rings are */
	malo_mem_write4(sc, letoh32(spec->RxPdRdPtr) & 0xffff,
	    htole32(sc->sc_rxring.physaddr));
	malo_mem_write4(sc, letoh32(spec->RxPdWrPtr) & 0xffff,
	    htole32(sc->sc_rxring.physaddr));
	malo_mem_write4(sc, letoh32(spec->WcbBase0) & 0xffff,
	    htole32(sc->sc_txring.physaddr));

	/* save DMA RX pointers for later use */
	sc->sc_RxPdRdPtr = letoh32(spec->RxPdRdPtr) & 0xffff;
	sc->sc_RxPdWrPtr = letoh32(spec->RxPdWrPtr) & 0xffff;

	return (0);
}

int
d724 1
a724 1
	if ((error = malo_get_spec(sc)))
d784 1
a784 1
		malo_reset(sc);
d966 197
@


1.9
log
@Activate RX radiotap.  We have RSSI for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.8 2006/10/21 23:16:34 mglocker Exp $ */
d169 1
d488 1
a488 1
		desc->reserved1 = htole16(1);
d504 14
d886 4
d985 2
d1037 1
d1040 4
a1043 1
	for (i = 0; i < MALO_RX_RING_COUNT; i++) {
d1054 4
a1057 4
		    i, desc->rxctrl, desc->rssi, desc->status, desc->channel,
		    letoh16(desc->len), desc->reserved1, desc->datarate,
		    desc->physdata, desc->physnext, desc->qosctrl,
		    desc->reserved2));
d1152 1
d1161 2
@


1.8
log
@Fix RX handling; the chip injects control data in front and between
a 802.11 frame which needs to be cut off.  Looks like we receive
the first correct looking management frames now.

Add first radio bpf mtap bits but don't activate them in the RX handler
yet.  Need first to find out which radio data the card delivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.7 2006/10/17 21:23:32 mglocker Exp $ */
a1089 1
			/*
d1094 1
d1099 1
d1101 1
a1101 1
			tap->wr_max_rssi = 100;
a1108 1
			*/
@


1.7
log
@Add first bits of a RX intr handler routine.  Needs further clarification.
Try to get bpf mtaps working soon to see what exactly happens there.
Based on rt2661.c, your code is just nice to read damien ;)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.6 2006/10/17 19:40:39 claudio Exp $ */
d51 1
d303 10
a312 1
	/* TODO bpf mtap */
d1026 9
a1034 1
		if (!(letoh32(desc->status) & 0x01))
d1081 29
a1109 2
#if NBPFILER > 0
		/* TODO bpf mtap */
d1126 2
a1130 3

		DPRINTF(("rx intr idx=%d, status=0x%02x, len=%d\n",
		    i, desc->status, desc->len));
@


1.6
log
@Allocate and free TX DMA rings additionally change some of the structures to
match more the actual reality. Still unsure about it as we don't have any
documentation to verify against. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.5 2006/10/17 10:31:26 claudio Exp $ */
d50 1
d62 2
a63 1
	struct ieee80211_node	ni;
d188 1
d228 3
d993 98
@


1.5
log
@Allocate and free RX DMA ring. Mostly form rt2661.c with adaption for malo.
Seems to fit pretty well. Does not do anything useful right now. The bits
in the interrupt handler and of course the TX ring are still missing.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.4 2006/10/15 21:56:49 claudio Exp $ */
d69 8
d79 2
d82 1
a82 2
	uint8_t		rssi;
	uint16_t	reserved1;	/* needs to be 1 */
d84 2
a85 2
	uint8_t		reserved2;	/* actually unkown */
	uint8_t		reserved3;
d88 2
a89 1
	uint32_t	id;		/* id for the host to id buffer ??? */
d92 16
a107 1
#define MALO_RX_RING_COUNT	48
d123 1
a123 1
	uint16_t	NumOfWCB;	/* reserved */
d129 1
a129 2
	uint32_t	RxPdRd1Ptr;
	uint32_t	RxPdRd2Ptr;
d131 1
d133 3
d167 3
d247 2
a248 2
	malo_alloc_rx_ring(sc, &sc->sc_rxring0, MALO_RX_RING_COUNT);
	malo_alloc_rx_ring(sc, &sc->sc_rxring1, MALO_RX_RING_COUNT);
d313 2
a314 2
	malo_free_rx_ring(sc, &sc->sc_rxring0);
	malo_free_rx_ring(sc, &sc->sc_rxring1);
a474 1
		desc->id = i;	/* ignored by the card ??? */
d521 119
d841 5
a845 4
	DPRINTF(("%s: get_hw_spec: V%x R%x, #Mcast %d, Regcode %d, #Ant %d\n",
	    sc->sc_dev.dv_xname, htole16(spec->HwVersion),
	    htole32(spec->FWReleaseNumber), htole16(spec->NumOfMCastAdr),
	    htole16(spec->RegionCode), htole16(spec->NumberOfAntenna)));
d848 6
a853 4
	malo_mem_write4(sc, letoh32(spec->RxPdRd1Ptr) & 0xffff,
	    htole32(sc->sc_rxring0.physaddr));
	malo_mem_write4(sc, letoh32(spec->RxPdRd2Ptr) & 0xffff,
	    htole32(sc->sc_rxring1.physaddr));
@


1.4
log
@Place bus_dmamap_sync() around malo_send_cmd this should help porting to
other archs later. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.3 2006/10/15 20:33:39 mglocker Exp $ */
d59 25
d134 5
a138 1
int	malo_dma_alloc_cmd(struct malo_softc *sc);
d214 5
d281 3
a283 1
	//malo_dma_free(sc);
d289 1
a289 1
malo_dma_alloc_cmd(struct malo_softc *sc)
d332 158
d692 11
a724 1
	malo_dma_alloc_cmd(sc);
@


1.3
log
@More serious firmware load error messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malo.c,v 1.2 2006/10/15 20:07:31 claudio Exp $ */
d381 2
d401 2
d451 3
d455 1
d457 2
a458 1
	tsleep(sc, 0, "malorst", hz);
d485 3
d489 1
d491 2
a492 1
	tsleep(sc, 0, "malospc", hz);
@


1.2
log
@Add $OpenBSD$ tag
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d330 2
a331 1
		printf("%s: BUMMER: timeout\n", sc->sc_dev.dv_xname);
d382 2
a383 1
			printf("%s: GRUMBLE: timeout\n", sc->sc_dev.dv_xname);
d400 1
a400 1
		printf("%s: GOPF: timeout\n", sc->sc_dev.dv_xname);
@


1.1
log
@First stubs for a new driver for the Marvell Libertas chips.
The card correctly loads the firmware and it is possible to send a few
simple commands to the card but that's it. No packet are sent or received.
Only the Netgear WG511v2 cardbus card is tested.
A cheese fondue and a bigger amount of white wine was needed to make the
interrupts work -- until last night the driver was uploading the firmware
to fast and the card garbled the image without moaning. It took us a full
day and hundreds of test kernels to figure that out.
Joint work with mglocker@@, fondue by mbalmer@@
OK mglocker@@, get it in deraadt@@
@
text
@d1 2
@

