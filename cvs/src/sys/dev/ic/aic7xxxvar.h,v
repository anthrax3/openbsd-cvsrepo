head	1.30;
access;
symbols
	OPENBSD_6_0:1.29.0.6
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.10
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.6
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.4
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.22
	OPENBSD_5_0:1.24.0.18
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.16
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.14
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.10
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.12
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.8
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	UBC_SYNC_A:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.13.0.8
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.6
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.14
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.12
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.10
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.08.17.01.17.54;	author krw;	state Exp;
branches;
next	1.29;
commitid	ABXin5xH6wOo5rmV;

1.29
date	2015.12.17.19.35.24;	author tedu;	state Exp;
branches;
next	1.28;
commitid	bqZCWxAb96aOkg0E;

1.28
date	2015.11.14.14.47.56;	author miod;	state Exp;
branches;
next	1.27;
commitid	2pkGyPKPBHGgYDCE;

1.27
date	2015.07.17.21.42.49;	author krw;	state Exp;
branches;
next	1.26;
commitid	bEhopXwWgYXDvWRJ;

1.26
date	2014.07.09.12.56.28;	author mpi;	state Exp;
branches;
next	1.25;
commitid	NKtrbjFVOj3sQBuE;

1.25
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.04.14.37.34;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.14.01.37.49;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.28.03.00.07;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.01.01.36.23;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.12.22.12.32;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.17.14.40.55;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.24.23.10.21;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.30.18.23.47;	author smurph;	state dead;
branches;
next	1.15;

1.15
date	2002.03.26.00.56.10;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.03.22.18.36;	author smurph;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2000.06.16.21.47.13;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.22.02.48.47;	author smurph;	state Exp;
branches;
next	1.10;

1.10
date	97.04.10.22.52.20;	author deraadt;	state Exp;
branches
	1.10.14.1;
next	1.9;

1.9
date	96.11.28.23.27.45;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.10.31.01.01.25;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.08.21.22.27.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.06.27.21.15.49;	author shawn;	state Exp;
branches;
next	1.5;

1.5
date	96.05.26.00.26.58;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.05.12.42.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.21.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.23.47.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.30;	author deraadt;	state Exp;
branches;
next	;

1.10.14.1
date	2000.03.24.09.09.09;	author niklas;	state Exp;
branches;
next	1.10.14.2;

1.10.14.2
date	2001.05.14.22.23.26;	author niklas;	state Exp;
branches;
next	1.10.14.3;

1.10.14.3
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.10.14.4;

1.10.14.4
date	2003.03.28.00.38.12;	author niklas;	state dead;
branches;
next	1.10.14.5;

1.10.14.5
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	1.10.14.6;

1.10.14.6
date	2004.06.05.23.12.40;	author niklas;	state Exp;
branches;
next	;

1.13.8.1
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.13.8.2;

1.13.8.2
date	2002.10.29.00.33.24;	author art;	state dead;
branches;
next	;


desc
@@


1.30
log
@Move to iopool. No voluntary testers after several years of requests so now
everybody gets to test!
@
text
@/*	$OpenBSD: aic7xxxvar.h,v 1.29 2015/12/17 19:35:24 tedu Exp $	*/
/*
 * Core definitions and data structures shareable across OS platforms.
 *
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2001 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $Id: aic7xxxvar.h,v 1.29 2015/12/17 19:35:24 tedu Exp $
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.h,v 1.50 2003/12/17 00:02:09 gibbs Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
 */

#ifndef _AIC7XXXVAR_H_
#define _AIC7XXXVAR_H_

#undef AHC_DEBUG

/* Register Definitions */
#include <dev/microcode/aic7xxx/aic7xxx_reg.h>

#include <dev/ic/aic7xxx_cam.h>
/************************* Forward Declarations *******************************/
struct ahc_platform_data;
struct scb_platform_data;
struct seeprom_descriptor;

/****************************** Useful Macros *********************************/
#ifndef MAX
#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

#define NUM_ELEMENTS(array) (sizeof(array) / sizeof(*array))

#define ALL_CHANNELS '\0'
#define ALL_TARGETS_MASK 0xFFFF
#define INITIATOR_WILDCARD	(~0)

#define SCSIID_TARGET(ahc, scsiid) \
	(((scsiid) & ((((ahc)->features & AHC_TWIN) != 0) ? TWIN_TID : TID)) \
	>> TID_SHIFT)
#define SCSIID_OUR_ID(scsiid) \
	((scsiid) & OID)
#define SCSIID_CHANNEL(ahc, scsiid) \
	((((ahc)->features & AHC_TWIN) != 0) \
        ? ((((scsiid) & TWIN_CHNLB) != 0) ? 'B' : 'A') \
       : 'A')
#define	SCB_IS_SCSIBUS_B(ahc, scb) \
	(SCSIID_CHANNEL(ahc, (scb)->hscb->scsiid) == 'B')
#define	SCB_GET_OUR_ID(scb) \
	SCSIID_OUR_ID((scb)->hscb->scsiid)
#define	SCB_GET_TARGET(ahc, scb) \
	SCSIID_TARGET((ahc), (scb)->hscb->scsiid)
#define	SCB_GET_CHANNEL(ahc, scb) \
	SCSIID_CHANNEL(ahc, (scb)->hscb->scsiid)
#define	SCB_GET_LUN(scb) \
	((scb)->hscb->lun & LID)
#define SCB_GET_TARGET_OFFSET(ahc, scb)	\
	(SCB_GET_TARGET(ahc, scb))
#define SCB_GET_TARGET_MASK(ahc, scb) \
	(0x01 << (SCB_GET_TARGET_OFFSET(ahc, scb)))
#ifdef AHC_DEBUG
#define SCB_IS_SILENT(scb)					\
	((ahc_debug & AHC_SHOW_MASKED_ERRORS) == 0		\
      && (((scb)->flags & SCB_SILENT) != 0))
#else
#define SCB_IS_SILENT(scb)					\
	(((scb)->flags & SCB_SILENT) != 0)
#endif
#define TCL_TARGET_OFFSET(tcl) \
	((((tcl) >> 4) & TID) >> 4)
#define TCL_LUN(tcl) \
	(tcl & (AHC_NUM_LUNS - 1))
#define BUILD_TCL(scsiid, lun) \
	((lun) | (((scsiid) & TID) << 4))

#ifndef	AHC_TARGET_MODE
#undef	AHC_TMODE_ENABLE
#define	AHC_TMODE_ENABLE 0
#endif

/**************************** Driver Constants ********************************/
/*
 * The maximum number of supported targets.
 */
#define AHC_NUM_TARGETS 16

/*
 * The maximum number of supported luns.
 * The identify message only supports 64 luns in SPI3.
 * You can have 2^64 luns when information unit transfers are enabled,
 * but it is doubtful this driver will ever support IUTs.
 */
#define AHC_NUM_LUNS 64

/*
 * The maximum transfer per S/G segment.
 * Limited by MAXPHYS or a 24-bit counter.
 */
#define AHC_MAXTRANSFER_SIZE	 MIN(MAXPHYS,0x00ffffff)

/*
 * The maximum amount of SCB storage in hardware on a controller.
 * This value represents an upper bound.  Controllers vary in the number
 * they actually support.
 */
#define AHC_SCB_MAX	255

/*
 * The maximum number of concurrent transactions supported per driver instance.
 * Sequencer Control Blocks (SCBs) store per-transaction information.  Although
 * the space for SCBs on the host adapter varies by model, the driver will
 * page the SCBs between host and controller memory as needed.  We are limited
 * to 253 because:
 *	1) The 8bit nature of the RISC engine holds us to an 8bit value.
 *	2) We reserve one value, 255, to represent the invalid element.
 *	3) Our input queue scheme requires one SCB to always be reserved
 *	   in advance of queuing any SCBs.  This takes us down to 254.
 *	4) To handle our output queue correctly on machines that only
 *	   support 32bit stores, we must clear the array 4 bytes at a
 *	   time.  To avoid colliding with a DMA write from the sequencer,
 *	   we must be sure that 4 slots are empty when we write to clear
 *	   the queue.  This reduces us to 253 SCBs: 1 that just completed
 *	   and the known three additional empty slots in the queue that
 *	   precede it.
 */
#define AHC_MAX_QUEUE	253

/*
 * The maximum amount of SCB storage we allocate in host memory.  This
 * number should reflect the 1 additional SCB we require to handle our
 * qinfifo mechanism.
 */
#define AHC_SCB_MAX_ALLOC (AHC_MAX_QUEUE+1)

/*
 * Ring Buffer of incoming target commands.
 * We allocate 256 to simplify the logic in the sequencer
 * by using the natural wrap point of an 8bit counter.
 */
#define AHC_TMODE_CMDS	256

/* Reset line assertion time in us */
#define AHC_BUSRESET_DELAY	25

/******************* Chip Characteristics/Operating Settings  *****************/
/*
 * Chip Type
 * The chip order is from least sophisticated to most sophisticated.
 */
typedef enum {
	AHC_NONE	= 0x0000,
	AHC_CHIPID_MASK	= 0x00FF,
	AHC_AIC7770	= 0x0001,
	AHC_AIC7850	= 0x0002,
	AHC_AIC7855	= 0x0003,
	AHC_AIC7859	= 0x0004,
	AHC_AIC7860	= 0x0005,
	AHC_AIC7870	= 0x0006,
	AHC_AIC7880	= 0x0007,
	AHC_AIC7895	= 0x0008,
	AHC_AIC7895C	= 0x0009,
	AHC_AIC7890	= 0x000a,
	AHC_AIC7896	= 0x000b,
	AHC_AIC7892	= 0x000c,
	AHC_AIC7899	= 0x000d,
	AHC_VL		= 0x0100,	/* Bus type VL */
	AHC_EISA	= 0x0200,	/* Bus type EISA */
	AHC_PCI		= 0x0400,	/* Bus type PCI */
	AHC_BUS_MASK	= 0x0F00
} ahc_chip;

/*
 * Features available in each chip type.
 */
typedef enum {
	AHC_FENONE	= 0x00000,
	AHC_ULTRA	= 0x00001,	/* Supports 20MHz Transfers */
	AHC_ULTRA2	= 0x00002,	/* Supports 40MHz Transfers */
	AHC_WIDE	= 0x00004,	/* Wide Channel */
	AHC_TWIN	= 0x00008,	/* Twin Channel */
	AHC_MORE_SRAM	= 0x00010,	/* 80 bytes instead of 64 */
	AHC_CMD_CHAN	= 0x00020,	/* Has a Command DMA Channel */
	AHC_QUEUE_REGS	= 0x00040,	/* Has Queue management registers */
	AHC_SG_PRELOAD	= 0x00080,	/* Can perform auto-SG preload */
	AHC_SPIOCAP	= 0x00100,	/* Has a Serial Port I/O Cap Register */
	AHC_MULTI_TID	= 0x00200,	/* Has bitmask of TIDs for select-in */
	AHC_HS_MAILBOX	= 0x00400,	/* Has HS_MAILBOX register */
	AHC_DT		= 0x00800,	/* Double Transition transfers */
	AHC_NEW_TERMCTL	= 0x01000,	/* Newer termination scheme */
	AHC_MULTI_FUNC	= 0x02000,	/* Multi-Function Twin Channel Device */
	AHC_LARGE_SCBS	= 0x04000,	/* 64byte SCBs */
	AHC_AUTORATE	= 0x08000,	/* Automatic update of SCSIRATE/OFFSET*/
	AHC_AUTOPAUSE	= 0x10000,	/* Automatic pause on register access */
	AHC_TARGETMODE	= 0x20000,	/* Has tested target mode support */
	AHC_MULTIROLE	= 0x40000,	/* Space for two roles at a time */
	AHC_REMOVABLE	= 0x80000,	/* Hot-Swap supported */
	AHC_AIC7770_FE	= AHC_FENONE,
	/*
	 * The real 7850 does not support Ultra modes, but there are
	 * several cards that use the generic 7850 PCI ID even though
	 * they are using an Ultra capable chip (7859/7860).  We start
	 * out with the AHC_ULTRA feature set and then check the DEVSTATUS
	 * register to determine if the capability is really present.
	 */
	AHC_AIC7850_FE	= AHC_SPIOCAP|AHC_AUTOPAUSE|AHC_TARGETMODE|AHC_ULTRA,
	AHC_AIC7860_FE	= AHC_AIC7850_FE,
	AHC_AIC7870_FE	= AHC_TARGETMODE|AHC_AUTOPAUSE,
	AHC_AIC7880_FE	= AHC_AIC7870_FE|AHC_ULTRA,
	/*
	 * Although we have space for both the initiator and
	 * target roles on ULTRA2 chips, we currently disable
	 * the initiator role to allow multi-scsi-id target mode
	 * configurations.  We can only respond on the same SCSI
	 * ID as our initiator role if we allow initiator operation.
	 * At some point, we should add a configuration knob to
	 * allow both roles to be loaded.
	 */
	AHC_AIC7890_FE	= AHC_MORE_SRAM|AHC_CMD_CHAN|AHC_ULTRA2
			  |AHC_QUEUE_REGS|AHC_SG_PRELOAD|AHC_MULTI_TID
			  |AHC_HS_MAILBOX|AHC_NEW_TERMCTL|AHC_LARGE_SCBS
			  |AHC_TARGETMODE,
	AHC_AIC7892_FE	= AHC_AIC7890_FE|AHC_DT|AHC_AUTORATE|AHC_AUTOPAUSE,
	AHC_AIC7895_FE	= AHC_AIC7880_FE|AHC_MORE_SRAM|AHC_AUTOPAUSE
			  |AHC_CMD_CHAN|AHC_MULTI_FUNC|AHC_LARGE_SCBS,
	AHC_AIC7895C_FE	= AHC_AIC7895_FE|AHC_MULTI_TID,
	AHC_AIC7896_FE	= AHC_AIC7890_FE|AHC_MULTI_FUNC,
	AHC_AIC7899_FE	= AHC_AIC7892_FE|AHC_MULTI_FUNC
} ahc_feature;

/*
 * Bugs in the silicon that we work around in software.
 */
typedef enum {
	AHC_BUGNONE		= 0x00,
	/*
	 * On all chips prior to the U2 product line,
	 * the WIDEODD S/G segment feature does not
	 * work during scsi->HostBus transfers.
	 */
	AHC_TMODE_WIDEODD_BUG	= 0x01,
	/*
	 * On the aic7890/91 Rev 0 chips, the autoflush
	 * feature does not work.  A manual flush of
	 * the DMA FIFO is required.
	 */
	AHC_AUTOFLUSH_BUG	= 0x02,
	/*
	 * On many chips, cacheline streaming does not work.
	 */
	AHC_CACHETHEN_BUG	= 0x04,
	/*
	 * On the aic7896/97 chips, cacheline
	 * streaming must be enabled.
	 */
	AHC_CACHETHEN_DIS_BUG	= 0x08,
	/*
	 * PCI 2.1 Retry failure on non-empty data fifo.
	 */
	AHC_PCI_2_1_RETRY_BUG	= 0x10,
	/*
	 * Controller does not handle cacheline residuals
	 * properly on S/G segments if PCI MWI instructions
	 * are allowed.
	 */
	AHC_PCI_MWI_BUG		= 0x20,
	/*
	 * An SCB upload using the SCB channel's
	 * auto array entry copy feature may
	 * corrupt data.  This appears to only
	 * occur on 66MHz systems.
	 */
	AHC_SCBCHAN_UPLOAD_BUG	= 0x40
} ahc_bug;

/*
 * Configuration specific settings.
 * The driver determines these settings by probing the
 * chip/controller's configuration.
 */
typedef enum {
	AHC_FNONE	      = 0x000,
	AHC_PRIMARY_CHANNEL   = 0x003,  /*
					 * The channel that should
					 * be probed first.
					 */
	AHC_USEDEFAULTS	      = 0x004,  /*
					 * For cards without an seeprom
					 * or a BIOS to initialize the chip's
					 * SRAM, we use the default target
					 * settings.
					 */
	AHC_SEQUENCER_DEBUG   = 0x008,
	AHC_SHARED_SRAM	      = 0x010,
	AHC_LARGE_SEEPROM     = 0x020,  /* Uses C56_66 not C46 */
	AHC_RESET_BUS_A	      = 0x040,
	AHC_RESET_BUS_B	      = 0x080,
	AHC_EXTENDED_TRANS_A  = 0x100,
	AHC_EXTENDED_TRANS_B  = 0x200,
	AHC_TERM_ENB_A	      = 0x400,
	AHC_TERM_ENB_B	      = 0x800,
	AHC_INITIATORROLE     = 0x1000,  /*
					  * Allow initiator operations on
					  * this controller.
					  */
	AHC_TARGETROLE	      = 0x2000,  /*
					  * Allow target operations on this
					  * controller.
					  */
	AHC_NEWEEPROM_FMT     = 0x4000,
	AHC_RESOURCE_SHORTAGE = 0x8000,
	AHC_TQINFIFO_BLOCKED  = 0x10000,  /* Blocked waiting for ATIOs */
	AHC_INT50_SPEEDFLEX   = 0x20000,  /*
					   * Internal 50pin connector
					   * sits behind an aic3860
					   */
	AHC_SCB_BTT	      = 0x40000,  /*
					   * The busy targets table is
					   * stored in SCB space rather
					   * than SRAM.
					   */
	AHC_BIOS_ENABLED      = 0x80000,
	AHC_ALL_INTERRUPTS    = 0x100000,
	AHC_PAGESCBS	      = 0x400000,  /* Enable SCB paging */
	AHC_EDGE_INTERRUPT    = 0x800000,  /* Device uses edge triggered ints */
	AHC_39BIT_ADDRESSING  = 0x1000000, /* Use 39 bit addressing scheme. */
	AHC_LSCBS_ENABLED     = 0x2000000, /* 64Byte SCBs enabled */
	AHC_SCB_CONFIG_USED   = 0x4000000, /* No SEEPROM but SCB2 had info. */
	AHC_NO_BIOS_INIT      = 0x8000000, /* No BIOS left over settings. */
	AHC_DISABLE_PCI_PERR  = 0x10000000,
	AHC_HAS_TERM_LOGIC    = 0x20000000,
	AHC_SHUTDOWN_RECOVERY = 0x40000000 /* Terminate recovery thread. */
} ahc_flag;

/************************* Hardware  SCB Definition ***************************/

/*
 * The driver keeps up to MAX_SCB scb structures per card in memory.  The SCB
 * consists of a "hardware SCB" mirroring the fields available on the card
 * and additional information the kernel stores for each transaction.
 *
 * To minimize space utilization, a portion of the hardware scb stores
 * different data during different portions of a SCSI transaction.
 * As initialized by the host driver for the initiator role, this area
 * contains the SCSI cdb (or a pointer to the  cdb) to be executed.  After
 * the cdb has been presented to the target, this area serves to store
 * residual transfer information and the SCSI status byte.
 * For the target role, the contents of this area do not change, but
 * still serve a different purpose than for the initiator role.  See
 * struct target_data for details.
 */

/*
 * Status information embedded in the shared portion of
 * an SCB after passing the cdb to the target.  The kernel
 * driver will only read this data for transactions that
 * complete abnormally (non-zero status byte).
 */
struct status_pkt {
	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
	uint32_t residual_sg_ptr;	/* The next S/G for this transfer */
	uint8_t	 scsi_status;		/* Standard SCSI status byte */
};

/*
 * Target mode version of the shared data SCB segment.
 */
struct target_data {
	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
	uint32_t residual_sg_ptr;	/* The next S/G for this transfer */
	uint8_t  scsi_status;		/* SCSI status to give to initiator */
	uint8_t  target_phases;		/* Bitmap of phases to execute */
	uint8_t  data_phase;		/* Data-In or Data-Out */
	uint8_t  initiator_tag;		/* Initiator's transaction tag */
};

struct hardware_scb {
/*0*/	union {
		/*
		 * If the cdb is 12 bytes or less, we embed it directly
		 * in the SCB.  For longer cdbs, we embed the address
		 * of the cdb payload as seen by the chip and a DMA
		 * is used to pull it in.
		 */
		uint8_t	 cdb[12];
		uint32_t cdb_ptr;
		struct	 status_pkt status;
		struct	 target_data tdata;
	} shared_data;
/*
 * A word about residuals.
 * The scb is presented to the sequencer with the dataptr and datacnt
 * fields initialized to the contents of the first S/G element to
 * transfer.  The sgptr field is initialized to the bus address for
 * the S/G element that follows the first in the in core S/G array
 * or'ed with the SG_FULL_RESID flag.  Sgptr may point to an invalid
 * S/G entry for this transfer (single S/G element transfer with the
 * first elements address and length preloaded in the dataptr/datacnt
 * fields).  If no transfer is to occur, sgptr is set to SG_LIST_NULL.
 * The SG_FULL_RESID flag ensures that the residual will be correctly
 * noted even if no data transfers occur.  Once the data phase is entered,
 * the residual sgptr and datacnt are loaded from the sgptr and the
 * datacnt fields.  After each S/G element's dataptr and length are
 * loaded into the hardware, the residual sgptr is advanced.  After
 * each S/G element is expired, its datacnt field is checked to see
 * if the LAST_SEG flag is set.  If so, SG_LIST_NULL is set in the
 * residual sg ptr and the transfer is considered complete.  If the
 * sequencer determines that there is a residual in the transfer, it
 * will set the SG_RESID_VALID flag in sgptr and DMA the scb back into
 * host memory.  To summarize:
 *
 * Sequencer:
 *	o A residual has occurred if SG_FULL_RESID is set in sgptr,
 *	  or residual_sgptr does not have SG_LIST_NULL set.
 *
 *	o We are transferring the last segment if residual_datacnt has
 *	  the SG_LAST_SEG flag set.
 *
 * Host:
 *	o A residual has occurred if a completed scb has the
 *	  SG_RESID_VALID flag set.
 *
 *	o residual_sgptr and sgptr refer to the "next" sg entry
 *	  and so may point beyond the last valid sg entry for the
 *	  transfer.
 */
/*12*/	uint32_t dataptr;
/*16*/	uint32_t datacnt;		/*
					 * Byte 3 (numbered from 0) of
					 * the datacnt is really the
					 * 4th byte in that data address.
					 */
/*20*/	uint32_t sgptr;
#define SG_PTR_MASK	0xFFFFFFF8
/*24*/	uint8_t  control;	/* See SCB_CONTROL in aic7xxx.reg for details */
/*25*/	uint8_t  scsiid;	/* what to load in the SCSIID register */
/*26*/	uint8_t  lun;
/*27*/	uint8_t  tag;			/*
					 * Index into our kernel SCB array.
					 * Also used as the tag for tagged I/O
					 */
/*28*/	uint8_t  cdb_len;
/*29*/	uint8_t  scsirate;		/* Value for SCSIRATE register */
/*30*/	uint8_t  scsioffset;		/* Value for SCSIOFFSET register */
/*31*/	uint8_t  next;			/*
					 * Used for threading SCBs in the
					 * "Waiting for Selection" and
					 * "Disconnected SCB" lists down
					 * in the sequencer.
					 */
/*32*/	uint8_t  cdb32[32];		/*
					 * CDB storage for cdbs of size
					 * 13->32.  We store them here
					 * because hardware scbs are
					 * allocated from DMA safe
					 * memory so we are guaranteed
					 * the controller can access
					 * this data.
					 */
};

/************************ Kernel SCB Definitions ******************************/
/*
 * Some fields of the SCB are OS dependent.  Here we collect the
 * definitions for elements that all OS platforms need to include
 * in there SCB definition.
 */

/*
 * Definition of a scatter/gather element as transferred to the controller.
 * The aic7xxx chips only support a 24bit length.  We use the top byte of
 * the length to store additional address bits and a flag to indicate
 * that a given segment terminates the transfer.  This gives us an
 * addressable range of 512GB on machines with 64bit PCI or with chips
 * that can support dual address cycles on 32bit PCI busses.
 */
struct ahc_dma_seg {
	uint32_t	addr;
	uint32_t	len;
#define	AHC_DMA_LAST_SEG	0x80000000
#define	AHC_SG_HIGH_ADDR_MASK	0x7F000000
#define	AHC_SG_LEN_MASK		0x00FFFFFF
};

struct sg_map_node {
	bus_dmamap_t		 sg_dmamap;
	bus_addr_t		 sg_physaddr;
	bus_dma_segment_t	 sg_dmasegs;
	int			 sg_nseg;
	struct ahc_dma_seg*	 sg_vaddr;
	SLIST_ENTRY(sg_map_node) links;
};

struct ahc_pci_busdata {
	pci_chipset_tag_t pc;
	pcitag_t tag;
	u_int dev;
	u_int func;
	pcireg_t class;
};

/*
 * The current state of this SCB.
 */
typedef enum {
	SCB_FLAG_NONE		= 0x0000,
	SCB_OTHERTCL_TIMEOUT	= 0x0002,/*
					  * Another device was active
					  * during the first timeout for
					  * this SCB so we gave ourselves
					  * an additional timeout period
					  * in case it was hogging the
					  * bus.
				          */
	SCB_DEVICE_RESET	= 0x0004,
	SCB_SENSE		= 0x0008,
	SCB_CDB32_PTR		= 0x0010,
	SCB_AUTO_NEGOTIATE	= 0x0040,/* Negotiate to achieve goal. */
	SCB_NEGOTIATE		= 0x0080,/* Negotiation forced for command. */
	SCB_ABORT		= 0x0100,
	SCB_UNTAGGEDQ		= 0x0200,
	SCB_ACTIVE		= 0x0400,
	SCB_TARGET_IMMEDIATE	= 0x0800,
	SCB_TRANSMISSION_ERROR	= 0x1000,/*
					  * We detected a parity or CRC
					  * error that has effected the
					  * payload of the command.  This
					  * flag is checked when normal
					  * status is returned to catch
					  * the case of a target not
					  * responding to our attempt
					  * to report the error.
					  */
	SCB_TARGET_SCB		= 0x2000,
	SCB_SILENT		= 0x4000 /*
					  * Be quiet about transmission type
					  * errors.  They are expected and we
					  * don't want to upset the user.  This
					  * flag is typically used during DV.
					  */
} scb_flag;

struct scb {
	struct	hardware_scb	 *hscb;
	union {
		SLIST_ENTRY(scb)  sle;
		TAILQ_ENTRY(scb)  tqe;
	} links;
	LIST_ENTRY(scb)		  pending_links;

	struct scsipi_xfer	 *xs;
	struct ahc_softc	 *ahc_softc;
	scb_flag		  flags;
	bus_dmamap_t		  dmamap;
	struct scb_platform_data *platform_data;
	struct sg_map_node	 *sg_map;
	struct ahc_dma_seg	 *sg_list;
	bus_addr_t		  sg_list_phys;
	u_int			  sg_count;/* How full ahc_dma_seg is */
};

struct scb_data {
	SLIST_HEAD(, scb) free_scbs;	/*
					 * Pool of SCBs ready to be assigned
					 * commands to execute.
					 */
	struct	scb *scbindex[256];	/*
					 * Mapping from tag to SCB.
					 * As tag identifiers are an
					 * 8bit value, we provide space
					 * for all possible tag values.
					 * Any lookups to entries at or
					 * above AHC_SCB_MAX_ALLOC will
					 * always fail.
					 */
	struct	hardware_scb	*hscbs;	/* Array of hardware SCBs */
	struct	scb *scbarray;		/* Array of kernel SCBs */
	struct	scsipi_sense_data *sense; /* Per SCB sense data */

	/*
	 * "Bus" addresses of our data structures.
	 */
	bus_dmamap_t	 hscb_dmamap;
	bus_addr_t	 hscb_busaddr;
	bus_dma_segment_t hscb_seg;
	int		  hscb_nseg;
	int		  hscb_size;

	bus_dmamap_t	 sense_dmamap;
	bus_addr_t	 sense_busaddr;
	bus_dma_segment_t sense_seg;
	int		  sense_nseg;
	int		  sense_size;

	SLIST_HEAD(, sg_map_node) sg_maps;
	uint8_t	numscbs;
	uint8_t	maxhscbs;		/* Number of SCBs on the card */
	uint8_t	init_level;		/*
					 * How far we've initialized
					 * this structure.
					 */
};

/************************ Target Mode Definitions *****************************/

/*
 * Connection desciptor for select-in requests in target mode.
 */
struct target_cmd {
	uint8_t scsiid;		/* Our ID and the initiator's ID */
	uint8_t identify;	/* Identify message */
	uint8_t bytes[22];	/*
				 * Bytes contains any additional message
				 * bytes terminated by 0xFF.  The remainder
				 * is the cdb to execute.
				 */
	uint8_t cmd_valid;	/*
				 * When a command is complete, the firmware
				 * will set cmd_valid to all bits set.
				 * After the host has seen the command,
				 * the bits are cleared.  This allows us
				 * to just peek at host memory to determine
				 * if more work is complete. cmd_valid is on
				 * an 8 byte boundary to simplify setting
				 * it on aic7880 hardware which only has
				 * limited direct access to the DMA FIFO.
				 */
	uint8_t pad[7];
};

/*
 * Number of events we can buffer up if we run out
 * of immediate notify ccbs.
 */
#define AHC_TMODE_EVENT_BUFFER_SIZE 8
struct ahc_tmode_event {
	uint8_t initiator_id;
	uint8_t event_type;	/* MSG type or EVENT_TYPE_BUS_RESET */
#define	EVENT_TYPE_BUS_RESET 0xFF
	uint8_t event_arg;
};

/*
 * Per enabled lun target mode state.
 * As this state is directly influenced by the host OS'es target mode
 * environment, we let the OS module define it.  Forward declare the
 * structure here so we can store arrays of them, etc. in OS neutral
 * data structures.
 */
#ifdef AHC_TARGET_MODE
struct ahc_tmode_lstate {
#if 0
	struct cam_path *path;
	struct ccb_hdr_slist accept_tios;
	struct ccb_hdr_slist immed_notifies;
#endif
	struct ahc_tmode_event event_buffer[AHC_TMODE_EVENT_BUFFER_SIZE];
	uint8_t event_r_idx;
	uint8_t event_w_idx;
};
#else
struct ahc_tmode_lstate;
#endif

/******************** Transfer Negotiation Datastructures *********************/
#define AHC_TRANS_CUR		0x01	/* Modify current negotiation status */
#define AHC_TRANS_ACTIVE	0x03	/* Assume this target is on the bus */
#define AHC_TRANS_GOAL		0x04	/* Modify negotiation goal */
#define AHC_TRANS_USER		0x08	/* Modify user negotiation settings */

#define AHC_WIDTH_UNKNOWN	0xFF
#define AHC_PERIOD_UNKNOWN	0xFF
#define AHC_OFFSET_UNKNOWN	0xFF
#define AHC_PPR_OPTS_UNKNOWN	0xFF

/*
 * Transfer Negotiation Information.
 */
struct ahc_transinfo {
	uint8_t protocol_version;	/* SCSI Revision level */
	uint8_t transport_version;	/* SPI Revision level */
	uint8_t width;			/* Bus width */
	uint8_t period;			/* Sync rate factor */
	uint8_t offset;			/* Sync offset */
	uint8_t ppr_options;		/* Parallel Protocol Request options */
};

/*
 * Per-initiator current, goal and user transfer negotiation information. */
struct ahc_initiator_tinfo {
	uint8_t scsirate;		/* Computed value for SCSIRATE reg */
	struct ahc_transinfo curr;
	struct ahc_transinfo goal;
	struct ahc_transinfo user;
};

/*
 * Per enabled target ID state.
 * Pointers to lun target state as well as sync/wide negotiation information
 * for each initiator<->target mapping.  For the initiator role we pretend
 * that we are the target and the targets are the initiators since the
 * negotiation is the same regardless of role.
 */
struct ahc_tmode_tstate {
	struct ahc_tmode_lstate*	enabled_luns[AHC_NUM_LUNS];
	struct ahc_initiator_tinfo	transinfo[AHC_NUM_TARGETS];

	/*
	 * Per initiator state bitmasks.
	 */
	uint16_t	 auto_negotiate;/* Auto Negotiation Required */
	uint16_t	 ultraenb;	/* Using ultra sync rate  */
	uint16_t	 discenable;	/* Disconnection allowed  */
	uint16_t	 tagenable;	/* Tagged Queuing allowed */
};

/*
 * Data structure for our table of allowed synchronous transfer rates.
 */
struct ahc_syncrate {
	u_int sxfr_u2;	/* Value of the SXFR parameter for Ultra2+ Chips */
	u_int sxfr;	/* Value of the SXFR parameter for <= Ultra Chips */
#define		ULTRA_SXFR 0x100	/* Rate Requires Ultra Mode set */
#define		ST_SXFR	   0x010	/* Rate Single Transition Only */
#define		DT_SXFR	   0x040	/* Rate Double Transition Only */
	uint8_t period; /* Period to send to SCSI target */
	char *rate;
};

/* Safe and valid period for async negotiations. */
#define	AHC_ASYNC_XFER_PERIOD 0x45
#define	AHC_ULTRA2_XFER_PERIOD 0x0a

/*
 * Indexes into our table of synchronous transfer rates.
 */
#define AHC_SYNCRATE_DT		0
#define AHC_SYNCRATE_ULTRA2	1
#define AHC_SYNCRATE_ULTRA	3
#define AHC_SYNCRATE_FAST	6
#define AHC_SYNCRATE_MAX	AHC_SYNCRATE_DT
#define	AHC_SYNCRATE_MIN	13

/***************************** Lookup Tables **********************************/
/*
 * Phase -> name and message out response
 * to parity errors in each phase table.
 */
struct ahc_phase_table_entry {
        uint8_t phase;
        uint8_t mesg_out; /* Message response to parity errors */
	char *phasemsg;
};

/************************** Serial EEPROM Format ******************************/

struct seeprom_config {
/*
 * Per SCSI ID Configuration Flags
 */
	uint16_t device_flags[16];	/* words 0-15 */
#define		CFXFER		0x0007	/* synchronous transfer rate */
#define		CFSYNCH		0x0008	/* enable synchronous transfer */
#define		CFDISC		0x0010	/* enable disconnection */
#define		CFWIDEB		0x0020	/* wide bus device */
#define		CFSYNCHISULTRA	0x0040	/* CFSYNCH is an ultra offset (2940AU)*/
#define		CFSYNCSINGLE	0x0080	/* Single-Transition signalling */
#define		CFSTART		0x0100	/* send start unit SCSI command */
#define		CFINCBIOS	0x0200	/* include in BIOS scan */
#define		CFRNFOUND	0x0400	/* report even if not found */
#define		CFMULTILUNDEV	0x0800	/* Probe multiple luns in BIOS scan */
#define		CFWBCACHEENB	0x4000	/* Enable W-Behind Cache on disks */
#define		CFWBCACHENOP	0xc000	/* Don't touch W-Behind Cache */

/*
 * BIOS Control Bits
 */
	uint16_t bios_control;		/* word 16 */
#define		CFSUPREM	0x0001	/* support all removable drives */
#define		CFSUPREMB	0x0002	/* support removable boot drives */
#define		CFBIOSEN	0x0004	/* BIOS enabled */
#define		CFBIOS_BUSSCAN	0x0008	/* Have the BIOS Scan the Bus */
#define		CFSM2DRV	0x0010	/* support more than two drives */
#define		CFSTPWLEVEL	0x0010	/* Termination level control */
#define		CF284XEXTEND	0x0020	/* extended translation (284x cards) */	
#define		CFCTRL_A	0x0020	/* BIOS displays Ctrl-A message */
#define		CFTERM_MENU	0x0040	/* BIOS displays termination menu */
#define		CFEXTEND	0x0080	/* extended translation enabled */
#define		CFSCAMEN	0x0100	/* SCAM enable */
#define		CFMSG_LEVEL	0x0600	/* BIOS Message Level */
#define			CFMSG_VERBOSE	0x0000
#define			CFMSG_SILENT	0x0200
#define			CFMSG_DIAG	0x0400
#define		CFBOOTCD	0x0800  /* Support Bootable CD-ROM */
/*		UNUSED		0xff00	*/

/*
 * Host Adapter Control Bits
 */
	uint16_t adapter_control;	/* word 17 */
#define		CFAUTOTERM	0x0001	/* Perform Auto termination */
#define		CFULTRAEN	0x0002	/* Ultra SCSI speed enable */
#define		CF284XSELTO     0x0003	/* Selection timeout (284x cards) */
#define		CF284XFIFO      0x000C	/* FIFO Threshold (284x cards) */
#define		CFSTERM		0x0004	/* SCSI low byte termination */
#define		CFWSTERM	0x0008	/* SCSI high byte termination */
#define		CFSPARITY	0x0010	/* SCSI parity */
#define		CF284XSTERM     0x0020	/* SCSI low byte term (284x cards) */
#define		CFMULTILUN	0x0020
#define		CFRESETB	0x0040	/* reset SCSI bus at boot */
#define		CFCLUSTERENB	0x0080	/* Cluster Enable */
#define		CFBOOTCHAN	0x0300	/* probe this channel first */
#define		CFBOOTCHANSHIFT 8
#define		CFSEAUTOTERM	0x0400	/* Ultra2 Perform secondary Auto Term*/
#define		CFSELOWTERM	0x0800	/* Ultra2 secondary low term */
#define		CFSEHIGHTERM	0x1000	/* Ultra2 secondary high term */
#define		CFENABLEDV	0x4000	/* Perform Domain Validation*/

/*
 * Bus Release Time, Host Adapter ID
 */
	uint16_t brtime_id;		/* word 18 */
#define		CFSCSIID	0x000f	/* host adapter SCSI ID */
/*		UNUSED		0x00f0	*/
#define		CFBRTIME	0xff00	/* bus release time */

/*
 * Maximum targets
 */
	uint16_t max_targets;		/* word 19 */
#define		CFMAXTARG	0x00ff	/* maximum targets */
#define		CFBOOTLUN	0x0f00	/* Lun to boot from */
#define		CFBOOTID	0xf000	/* Target to boot from */
	uint16_t res_1[10];		/* words 20-29 */
	uint16_t signature;		/* Signature == 0x250 */
#define		CFSIGNATURE	0x250
#define		CFSIGNATURE2	0x300
	uint16_t checksum;		/* word 31 */
};

/****************************  Message Buffer *********************************/
typedef enum {
	MSG_TYPE_NONE			= 0x00,
	MSG_TYPE_INITIATOR_MSGOUT	= 0x01,
	MSG_TYPE_INITIATOR_MSGIN	= 0x02,
	MSG_TYPE_TARGET_MSGOUT		= 0x03,
	MSG_TYPE_TARGET_MSGIN		= 0x04
} ahc_msg_type;

typedef enum {
	MSGLOOP_IN_PROG,
	MSGLOOP_MSGCOMPLETE,
	MSGLOOP_TERMINATED
} msg_loop_stat;

/*********************** Software Configuration Structure *********************/
TAILQ_HEAD(scb_tailq, scb);

struct ahc_aic7770_softc {
	/*
	 * Saved register state used for chip_init().
	 */
	uint8_t busspd;
	uint8_t bustime;
};

struct ahc_pci_softc {
	/*
	 * Saved register state used for chip_init().
	 */
	uint32_t  devconfig;
	uint16_t  targcrccnt;
	uint8_t   command;
	uint8_t   csize_lattime;
	uint8_t   optionmode;
	uint8_t   crccontrol1;
	uint8_t   dscommand0;
	uint8_t   dspcistatus;
	uint8_t   scbbaddr;
	uint8_t   dff_thrsh;
};

union ahc_bus_softc {
	struct ahc_aic7770_softc aic7770_softc;
	struct ahc_pci_softc pci_softc;
};

typedef void (*ahc_bus_intr_t)(struct ahc_softc *);
typedef int (*ahc_bus_chip_init_t)(struct ahc_softc *);
typedef void ahc_callback_t (void *);

struct ahc_softc {
	struct device		  sc_dev;

	struct scsipi_channel	  sc_channel;
	struct scsipi_channel	  sc_channel_b;
	struct device *		  sc_child;
	struct device *		  sc_child_b;
	struct scsipi_adapter	  sc_adapter;

	bus_space_tag_t           tag;
	bus_space_handle_t        bsh;

	struct mutex		  sc_scb_mtx;
	struct scsi_iopool	  sc_iopool;

	bus_dma_tag_t		  buffer_dmat;   /* dmat for buffer I/O */
	struct scb_data		 *scb_data;

	struct scb		 *next_queued_scb;

	/*
	 * SCBs that have been sent to the controller
	 */
	LIST_HEAD(, scb)	  pending_scbs;

	/*
	 * Counting lock for deferring the release of additional
	 * untagged transactions from the untagged_queues.  When
	 * the lock is decremented to 0, all queues in the
	 * untagged_queues array are run.
	 */
	u_int			  untagged_queue_lock;

	/*
	 * Per-target queue of untagged-transactions.  The
	 * transaction at the head of the queue is the
	 * currently pending untagged transaction for the
	 * target.  The driver only allows a single untagged
	 * transaction per target.
	 */
	struct scb_tailq	  untagged_queues[AHC_NUM_TARGETS];

	/*
	 * Bus attachment specific data.
	 */
	union ahc_bus_softc	  bus_softc;

	/*
	 * Platform specific data.
	 */
	struct ahc_platform_data *platform_data;

	/*
	 * Platform specific device information.
	 */
	ahc_dev_softc_t		  dev_softc;

	/*
	 * Bus specific device information.
	 */
	ahc_bus_intr_t		  bus_intr;

	/*
	 * Bus specific initialization required
	 * after a chip reset.
	 */
	ahc_bus_chip_init_t	  bus_chip_init;

	/*
	 * Target mode related state kept on a per enabled lun basis.
	 * Targets that are not enabled will have null entries.
	 * As an initiator, we keep one target entry for our initiator
	 * ID to store our sync/wide transfer settings.
	 */
	struct ahc_tmode_tstate  *enabled_targets[AHC_NUM_TARGETS];

	char inited_target[AHC_NUM_TARGETS];

	/*
	 * The black hole device responsible for handling requests for
	 * disabled luns on enabled targets.
	 */
	struct ahc_tmode_lstate  *black_hole;

	/*
	 * Device instance currently on the bus awaiting a continue TIO
	 * for a command that was not given the disconnect privilege.
	 */
	struct ahc_tmode_lstate  *pending_device;

	/*
	 * Card characteristics
	 */
	ahc_chip		  chip;
	ahc_feature		  features;
	ahc_bug			  bugs;
	ahc_flag		  flags;
	struct seeprom_config	 *seep_config;

	/* Values to store in the SEQCTL register for pause and unpause */
	uint8_t			  unpause;
	uint8_t			  pause;

	/* Command Queues */
	uint8_t			  qoutfifonext;
	uint8_t			  qinfifonext;
	uint8_t			 *qoutfifo;
	uint8_t			 *qinfifo;

	/* Critical Section Data */
	struct cs		 *critical_sections;
	u_int			  num_critical_sections;

	/* Links for chaining softcs */
	TAILQ_ENTRY(ahc_softc)	  links;

	/* Channel Names ('A', 'B', etc.) */
	char			  channel;
	char			  channel_b;

	/* Initiator Bus ID */
	uint8_t			  our_id;
	uint8_t			  our_id_b;

	/*
	 * PCI error detection.
	 */
	int			  unsolicited_ints;

	/*
	 * Target incoming command FIFO.
	 */
	struct target_cmd	 *targetcmds;
	uint8_t			  tqinfifonext;

	/*
	 * Cached copy of the sequencer control register.
	 */
	uint8_t			  seqctl;

	/*
	 * Incoming and outgoing message handling.
	 */
	uint8_t			  send_msg_perror;
	ahc_msg_type		  msg_type;
	uint8_t			  msgout_buf[12];/* Message we are sending */
	uint8_t			  msgin_buf[12];/* Message we are receiving */
	u_int			  msgout_len;	/* Length of message to send */
	u_int			  msgout_index;	/* Current index in msgout */
	u_int			  msgin_index;	/* Current index in msgin */

	/* Interrupt routine */
	void			 *ih;

	/*
	 * Mapping information for data structures shared
	 * between the sequencer and kernel.
	 */
	bus_dma_tag_t		  parent_dmat;
	bus_dmamap_t		  shared_data_dmamap;
	bus_addr_t		  shared_data_busaddr;

	bus_dma_segment_t	  shared_data_seg;
	int			  shared_data_nseg;
	int			  shared_data_size;
	int			  sc_dmaflags;

	/*
	 * Bus address of the one byte buffer used to
	 * work-around a DMA bug for chips <= aic7880
	 * in target mode.
	 */
	bus_addr_t		  dma_bug_buf;

	/* Number of enabled target mode device on this card */
	u_int			  enabled_luns;

	/* Initialization level of this data structure */
	u_int			  init_level;

	/* PCI cacheline size. */
	u_int			  pci_cachesize;

	/*
	 * Count of parity errors we have seen as a target.
	 * We auto-disable parity error checking after seeing
	 * AHC_PCI_TARGET_PERR_THRESH number of errors.
	 */
	u_int			  pci_target_perr_count;
#define		AHC_PCI_TARGET_PERR_THRESH	10

	/* Maximum number of sequencer instructions supported. */
	u_int			  instruction_ram_size;

	/* Per-Unit descriptive information */
	char			 *name;
	int			  unit;

	/* Selection Timer settings */
	int			  seltime;
	int			  seltime_b;

	uint16_t		  user_discenable;/* Disconnection allowed  */
	uint16_t		  user_tagenable;/* Tagged Queuing allowed */

	struct ahc_pci_busdata	  *bd;
};

TAILQ_HEAD(ahc_softc_tailq, ahc_softc);
extern struct ahc_softc_tailq ahc_tailq;

/************************ Active Device Information ***************************/
typedef enum {
	ROLE_UNKNOWN,
	ROLE_INITIATOR,
	ROLE_TARGET
} role_t;

struct ahc_devinfo {
	int	 our_scsiid;
	int	 target_offset;
	uint16_t target_mask;
	u_int	 target;
	u_int	 lun;
	char	 channel;
	role_t	 role;		/*
				 * Only guaranteed to be correct if not
				 * in the busfree state.
				 */
};

/****************************** PCI Structures ********************************/
typedef int (ahc_device_setup_t)(struct ahc_softc *);

struct ahc_pci_identity {
	uint64_t		 full_id;
	uint64_t		 id_mask;
	ahc_device_setup_t	*setup;
};
extern struct ahc_pci_identity ahc_pci_ident_table[];

/***************************** VL/EISA Declarations ***************************/
struct aic7770_identity {
	uint32_t		 full_id;
	uint32_t		 id_mask;
	const char		*name;
	ahc_device_setup_t	*setup;
};
extern struct aic7770_identity aic7770_ident_table[];
extern const int ahc_num_aic7770_devs;

#define AHC_EISA_SLOT_OFFSET	0xc00
#define AHC_EISA_IOSIZE		0x100

/*************************** Function Declarations ****************************/
/******************************************************************************/
u_int			ahc_index_busy_tcl(struct ahc_softc *, u_int);
void			ahc_unbusy_tcl(struct ahc_softc *, u_int);
void			ahc_busy_tcl(struct ahc_softc *, u_int, u_int);

/***************************** PCI Front End *********************************/
const struct ahc_pci_identity	*ahc_find_pci_device(pcireg_t, pcireg_t, u_int);
int			 ahc_pci_config(struct ahc_softc *,
			    struct ahc_pci_identity *);
int			 ahc_pci_test_register_access(struct ahc_softc *);

/*************************** EISA/VL Front End ********************************/
struct aic7770_identity *aic7770_find_device(uint32_t);
int			 aic7770_config(struct ahc_softc *,
			    struct aic7770_identity *, u_int);

/************************** SCB and SCB queue management **********************/
int		ahc_probe_scbs(struct ahc_softc *);
void		ahc_run_untagged_queues(struct ahc_softc *ahc);
void		ahc_run_untagged_queue(struct ahc_softc *ahc,
				       struct scb_tailq *queue);
void		ahc_qinfifo_requeue_tail(struct ahc_softc *ahc,
					 struct scb *scb);
int		ahc_match_scb(struct ahc_softc *ahc, struct scb *scb,
			      int target, char channel, int lun,
			      u_int tag, role_t role);

/****************************** Initialization ********************************/
int			 ahc_softc_init(struct ahc_softc *);
#ifndef DEBUG
void			 ahc_controller_info(struct ahc_softc *, char *, size_t);
#endif
int			 ahc_chip_init(struct ahc_softc *ahc);
int			 ahc_init(struct ahc_softc *ahc);
void			 ahc_intr_enable(struct ahc_softc *ahc, int enable);
void			 ahc_softc_insert(struct ahc_softc *);
void			 ahc_set_unit(struct ahc_softc *, int);
void			 ahc_set_name(struct ahc_softc *, char *);
void			 ahc_alloc_scbs(struct ahc_softc *ahc);
void			 ahc_free(struct ahc_softc *ahc);
int			 ahc_reset(struct ahc_softc *ahc, int reinit);
void			 ahc_shutdown(void *arg);

/*************************** Interrupt Services *******************************/
void			ahc_pci_intr(struct ahc_softc *);
void			ahc_clear_intstat(struct ahc_softc *);
void			ahc_run_qoutfifo(struct ahc_softc *);
#ifdef AHC_TARGET_MODE
void			ahc_run_tqinfifo(struct ahc_softc *ahc, int paused);
#endif
void			ahc_handle_brkadrint(struct ahc_softc *ahc);
void			ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat);
void			ahc_handle_scsiint(struct ahc_softc *ahc,
					   u_int intstat);
void			ahc_clear_critical_section(struct ahc_softc *ahc);

/***************************** Error Recovery *********************************/
typedef enum {
	SEARCH_COMPLETE,
	SEARCH_COUNT,
	SEARCH_REMOVE
} ahc_search_action;
int			ahc_search_qinfifo(struct ahc_softc *, int, char,
			    int, u_int, role_t, uint32_t, ahc_search_action);
int			ahc_search_untagged_queues(struct ahc_softc *,
			    struct scsipi_xfer *, int, char, int, uint32_t,
			    ahc_search_action);
int			ahc_search_disc_list(struct ahc_softc *, int, char,
			    int, u_int, int, int, int);
void			ahc_freeze_devq(struct ahc_softc *, struct scb *);
int			ahc_reset_channel(struct ahc_softc *, char, int);
int			ahc_abort_scbs(struct ahc_softc *, int, char, int,
			    u_int, role_t, uint32_t);
void			ahc_restart(struct ahc_softc *);
void			ahc_calc_residual(struct ahc_softc *, struct scb *);
/*************************** Utility Functions ********************************/
struct ahc_phase_table_entry*
			ahc_lookup_phase_entry(int phase);
void			ahc_compile_devinfo(struct ahc_devinfo *devinfo,
					    u_int our_id, u_int target,
					    u_int lun, char channel,
					    role_t role);
/************************** Transfer Negotiation ******************************/
struct ahc_syncrate*	ahc_find_syncrate(struct ahc_softc *ahc, u_int *period,
					  u_int *ppr_options, u_int maxsync);
u_int			ahc_find_period(struct ahc_softc *ahc,
					u_int scsirate, u_int maxsync);
void			ahc_validate_offset(struct ahc_softc *ahc,
					    struct ahc_initiator_tinfo *tinfo,
					    struct ahc_syncrate *syncrate,
					    u_int *offset, int wide,
					    role_t role);
void			ahc_validate_width(struct ahc_softc *ahc,
					   struct ahc_initiator_tinfo *tinfo,
					   u_int *bus_width,
					   role_t role);
/*
 * Negotiation types.  These are used to qualify if we should renegotiate
 * even if our goal and current transport parameters are identical.
 */
typedef enum {
	AHC_NEG_TO_GOAL,	/* Renegotiate only if goal and curr differ. */
	AHC_NEG_IF_NON_ASYNC,	/* Renegotiate so long as goal is non-async. */
	AHC_NEG_ALWAYS		/* Renegotiate even if goal is async. */
} ahc_neg_type;
int			ahc_update_neg_request(struct ahc_softc *,
			    struct ahc_devinfo *, struct ahc_tmode_tstate *,
			    struct ahc_initiator_tinfo*, ahc_neg_type);
void			ahc_set_width(struct ahc_softc *, struct ahc_devinfo *,
			    u_int, u_int, int);
void			ahc_set_syncrate(struct ahc_softc *,
			    struct ahc_devinfo *, struct ahc_syncrate *,
			    u_int, u_int, u_int, u_int, int);
void			ahc_scb_devinfo(struct ahc_softc *,
					struct ahc_devinfo *, struct scb *);


typedef enum {
	AHC_QUEUE_NONE,
	AHC_QUEUE_BASIC,
	AHC_QUEUE_TAGGED
} ahc_queue_alg;

void			ahc_set_tags(struct ahc_softc *ahc,
				     struct ahc_devinfo *devinfo,
				     ahc_queue_alg alg);

/**************************** Target Mode *************************************/
#ifdef AHC_TARGET_MODE
void		ahc_send_lstate_events(struct ahc_softc *,
		    struct ahc_tmode_lstate *);
void		ahc_handle_en_lun(struct ahc_softc *, struct scsipi_xfer *);
cam_status	ahc_find_tmode_devs(struct ahc_softc *,
		    struct ahc_tmode_tstate **, struct ahc_tmode_lstate **,
		    int);
#ifndef AHC_TMODE_ENABLE
#define AHC_TMODE_ENABLE 0
#endif
#endif
/******************************* Debug ***************************************/
#ifdef AHC_DEBUG
extern uint32_t ahc_debug;
#define	AHC_SHOW_MISC		0x0001
#define	AHC_SHOW_SENSE		0x0002
#define AHC_DUMP_SEEPROM	0x0004
#define AHC_SHOW_TERMCTL	0x0008
#define AHC_SHOW_MEMORY		0x0010
#define AHC_SHOW_MESSAGES	0x0020
#define	AHC_SHOW_DV		0x0040
#define AHC_SHOW_SELTO		0x0080
#define AHC_SHOW_QFULL		0x0200
#define AHC_SHOW_QUEUE		0x0400
#define AHC_SHOW_TQIN		0x0800
#define AHC_SHOW_MASKED_ERRORS	0x1000
#define AHC_DEBUG_SEQUENCER	0x2000
#endif
void			ahc_print_scb(struct scb *scb);
void			ahc_print_devinfo(struct ahc_softc *ahc,
					  struct ahc_devinfo *dev);
void			ahc_dump_card_state(struct ahc_softc *ahc);
int			ahc_print_register(ahc_reg_parse_entry_t *table,
					   u_int num_entries,
					   const char *name,
					   u_int address,
					   u_int value,
					   u_int *cur_column,
					   u_int wrap_point);
/******************************* SEEPROM *************************************/
int		ahc_acquire_seeprom(struct ahc_softc *ahc,
				    struct seeprom_descriptor *sd);
void		ahc_release_seeprom(struct seeprom_descriptor *sd);

void		ahc_check_extport(struct ahc_softc *, u_int *);
#endif /* _AIC7XXXVAR_H_ */
@


1.29
log
@sprinkling ifndef __linux__ around two variable declarations could not
possibly make this driver portable
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.28 2015/11/14 14:47:56 miod Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.28 2015/11/14 14:47:56 miod Exp $
d949 3
@


1.28
log
@Various *syncron* -> *synchron* typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.27 2015/07/17 21:42:49 krw Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.27 2015/07/17 21:42:49 krw Exp $
a599 1
#ifndef __linux__
a600 1
#endif
a949 1
#ifndef __linux__
a950 1
#endif
@


1.27
log
@Nuke a bunch of leading and trailing whitespace so I don't go blind
reading this code. No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.26 2014/07/09 12:56:28 mpi Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.26 2014/07/09 12:56:28 mpi Exp $
d783 1
a783 1
 * Indexes into our table of syncronous transfer rates.
@


1.26
log
@Kill unused shutdown hook pointers.

ok miod@@, deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.25 2012/02/24 06:19:00 guenther Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.25 2012/02/24 06:19:00 guenther Exp $
d161 2
a162 2
 * 	1) The 8bit nature of the RISC engine holds us to an 8bit value.
 * 	2) We reserve one value, 255, to represent the invalid element.
d166 1
a166 1
 * 	   support 32bit stores, we must clear the array 4 bytes at a
d226 1
a226 1
	AHC_WIDE  	= 0x00004,	/* Wide Channel */
d315 1
a315 1
	 * auto array entry copy feature may 
d472 1
a472 1
 */ 
d605 1
a605 1
	struct ahc_dma_seg 	 *sg_list;
d660 1
a660 1
	uint8_t bytes[22];	/* 
d698 1
a698 1
#ifdef AHC_TARGET_MODE 
d795 1
a795 1
 * to parity errors in each phase table. 
d834 2
a835 2
#define		CFCTRL_A	0x0020	/* BIOS displays Ctrl-A message */	
#define		CFTERM_MENU	0x0040	/* BIOS displays termination menu */	
d848 1
a848 1
	uint16_t adapter_control;	/* word 17 */	
d856 1
a856 1
#define		CF284XSTERM     0x0020	/* SCSI low byte term (284x cards) */	
d878 1
a878 1
	uint16_t max_targets;		/* word 19 */	
d941 1
a941 1
	struct device 		  sc_dev; 
d944 1
a944 1
	struct scsipi_channel 	  sc_channel_b;
d1091 1
a1091 1
	void 			 *ih;
d1141 1
a1141 1
	uint16_t	 	  user_discenable;/* Disconnection allowed  */
d1144 1
a1144 1
	struct ahc_pci_busdata 	  *bd;
@


1.25
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.24 2007/08/04 14:37:34 krw Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.24 2007/08/04 14:37:34 krw Exp $
a1144 2

	void			  *shutdown_hook;
@


1.24
log
@Since ahc_controller_info()'s definition is inside #ifndef DEBUG, put
it's declaration and only use inside #ifndef DEBUG too. Lets DEBUG
kernel compile again. Non-DEBUG kernel still compiles too.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.23 2007/05/14 01:37:49 deraadt Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.23 2007/05/14 01:37:49 deraadt Exp $
d462 1
a462 1
 *	o We are transfering the last segment if residual_datacnt has
@


1.23
log
@delete unused code; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.22 2006/03/04 19:33:21 miod Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.22 2006/03/04 19:33:21 miod Exp $
d1225 1
d1227 1
@


1.22
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.21 2005/12/28 03:00:07 krw Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.21 2005/12/28 03:00:07 krw Exp $
a1180 1
extern const u_int ahc_num_pci_devs;
a1228 3
void			 ahc_pause_and_flushwork(struct ahc_softc *ahc);
int			 ahc_suspend(struct ahc_softc *ahc); 
int			 ahc_resume(struct ahc_softc *ahc);
a1229 1
struct ahc_softc	*ahc_find_softc(struct ahc_softc *ahc);
@


1.21
log
@Strip out fancy timeout code that attempts to mimic FreeBSD's thread
based timeout handling. Use the simple timeout == bus reset model
instead. Also move verbose debug output inside #ifdef/#endif.

Fixes pulling out a raidctl disk causing a crash noted by kurt@@.
Rebuilding the raid still problematic.

Reduces but does not eliminate crashes with 'smartctl -d scsi -a
/dev/rcd0c' seen by Sigfried H?versen.

Should only impact timeout handling. No change to normal processing.

Thanks to kurt@@ and Sigfied for testing.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.20 2004/08/01 01:36:23 krw Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.20 2004/08/01 01:36:23 krw Exp $
d1025 1
a1025 1
	 * for a command that was not given the disconnect priviledge.
@


1.20
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.19 2004/04/12 22:12:32 jmc Exp $	*/
d41 1
a41 1
 * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.h#85 $
a563 1
	SCB_RECOVERY_SCB	= 0x0020,
d581 1
a581 1
	SCB_SILENT		= 0x4000,/*
a585 4
					  */
	SCB_TIMEDOUT		= 0x8000 /*
					  * SCB has timed out and is on the
					  * timedout list.
@


1.19
log
@removeable -> removable;
ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.18 2004/01/17 14:40:55 krw Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.18 2004/01/17 14:40:55 krw Exp $
d43 1
a43 1
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx.h,v 1.44 2003/01/20 20:44:55 gibbs Exp $
a57 23

#define	AIC_OP_OR	0x0
#define	AIC_OP_AND	0x1
#define AIC_OP_XOR	0x2
#define	AIC_OP_ADD	0x3
#define	AIC_OP_ADC	0x4
#define	AIC_OP_ROL	0x5
#define	AIC_OP_BMOV	0x6

#define	AIC_OP_JMP	0x8
#define AIC_OP_JC	0x9
#define AIC_OP_JNC	0xa
#define AIC_OP_CALL	0xb
#define	AIC_OP_JNE	0xc
#define	AIC_OP_JNZ	0xd
#define	AIC_OP_JE	0xe
#define	AIC_OP_JZ	0xf

/* Pseudo Ops */
#define	AIC_OP_SHL	0x10
#define	AIC_OP_SHR	0x20
#define	AIC_OP_ROR	0x30

d103 1
a103 1
	((scb)->hscb->lun)
d254 1
a254 1
	AHC_AIC7870_FE	= AHC_TARGETMODE,
d376 3
a378 1
	AHC_DISABLE_PCI_PERR  = 0x10000000
d552 1
a552 2
	SCB_FREE		= 0x0000,
	SCB_REQUEUE		= 0x0001,
d588 4
a591 1
	SCB_FREEZE_QUEUE	= 0x8000
d726 1
a726 1
#define AHC_OFFSET_UNKNOWN	0x0
d912 27
a938 22
struct ahc_suspend_channel_state {
	uint8_t	scsiseq;
	uint8_t	sxfrctl0;
	uint8_t	sxfrctl1;
	uint8_t	simode0;
	uint8_t	simode1;
	uint8_t	seltimer;
	uint8_t	seqctl;
};

struct ahc_suspend_state {
	struct	ahc_suspend_channel_state channel[2];
	uint8_t	optionmode;
	uint8_t	dscommand0;
	uint8_t	dspcistatus;
	/* hsmailbox */
	uint8_t	crccontrol1;
	uint8_t	scbbaddr;
	/* Host and sequencer SCB counts */
	uint8_t	dff_thrsh;
	uint8_t	*scratch_ram;
	uint8_t	*btt;
d942 1
d987 5
d1007 6
d1062 1
d1080 5
a1117 3
	/* Information saved through suspend/resume cycles */
	struct ahc_suspend_state  suspend_state;

d1127 10
a1136 1
	u_int			  stack_size;
d1185 1
a1185 1
extern struct ahc_pci_identity ahc_pci_ident_table [];
d1192 1
a1192 1
	char			*name;
d1195 1
a1195 1
extern struct aic7770_identity aic7770_ident_table [];
d1220 8
a1227 5
void		ahc_run_untagged_queues(struct ahc_softc *);
void		ahc_run_untagged_queue(struct ahc_softc *, struct scb_tailq *);
void		ahc_qinfifo_requeue_tail(struct ahc_softc *, struct scb *);
int		ahc_match_scb(struct ahc_softc *, struct scb *,
		    int, char, int, u_int, role_t);
d1232 6
a1237 5
int			 ahc_init(struct ahc_softc *);
void			 ahc_intr_enable(struct ahc_softc *, int);
void			 ahc_pause_and_flushwork(struct ahc_softc *);
int			 ahc_suspend(struct ahc_softc *); 
int			 ahc_resume(struct ahc_softc *);
d1239 1
a1239 1
struct ahc_softc	*ahc_find_softc(struct ahc_softc *);
d1242 4
a1245 4
void			 ahc_alloc_scbs(struct ahc_softc *);
void			 ahc_free(struct ahc_softc *);
int			 ahc_reset(struct ahc_softc *);
void			 ahc_shutdown(void *);
d1252 1
a1252 1
void			ahc_run_tqinfifo(struct ahc_softc *, int);
d1254 5
a1258 4
void			ahc_handle_brkadrint(struct ahc_softc *);
void			ahc_handle_seqint(struct ahc_softc *, u_int);
void			ahc_handle_scsiint(struct ahc_softc *, u_int);
void			ahc_clear_critical_section(struct ahc_softc *);
d1281 5
a1285 3
			ahc_lookup_phase_entry(int);
void			ahc_compile_devinfo(struct ahc_devinfo *, u_int, u_int,
			    u_int, char, role_t);
d1287 13
a1299 8
struct ahc_syncrate*	ahc_find_syncrate(struct ahc_softc *, u_int *,
			    u_int *, u_int);
u_int			ahc_find_period(struct ahc_softc *, u_int, u_int);
void			ahc_validate_offset(struct ahc_softc *,
			    struct ahc_initiator_tinfo *, struct ahc_syncrate *,
			    u_int *, int, role_t);
void			ahc_validate_width(struct ahc_softc *,
			    struct ahc_initiator_tinfo *, u_int *, role_t);
d1318 2
a1319 1
			    struct ahc_devinfo *, struct scb *);
d1327 3
a1329 2
void			ahc_set_tags(struct ahc_softc *, struct ahc_devinfo *,
			    ahc_queue_alg);
a1353 1
#define AHC_SHOW_CMDS		0x0100
d1360 11
a1370 6
void			ahc_print_scb(struct scb *);
void			ahc_print_devinfo(struct ahc_softc *,
			    struct ahc_devinfo *);
void			ahc_dump_card_state(struct ahc_softc *);
int			ahc_print_register(ahc_reg_parse_entry_t *, u_int,
			    const char *, u_int, u_int, u_int *, u_int);
d1372 3
a1374 3
int		ahc_acquire_seeprom(struct ahc_softc *,
		    struct seeprom_descriptor *);
void		ahc_release_seeprom(struct seeprom_descriptor *);
@


1.18
log
@Major stability improvement. Fix a variety of systems and problems
by dealing with various error conditions.

Testing by Marco Peereboom, Olivier Cherrier, Alex Holst, Daniel Lucq,
deraadt@@, beck@@ and others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.17 2003/12/24 23:10:21 krw Exp $	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.17 2003/12/24 23:10:21 krw Exp $
d851 2
a852 2
#define		CFSUPREM	0x0001	/* support all removeable drives */
#define		CFSUPREMB	0x0002	/* support removeable boot drives */
@


1.17
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
 * $Id: aic7xxxvar.h,v 1.43 2003/11/02 11:07:44 wiz Exp $
a1022 3
#define	INITED_TARGET_START	0
#define INITED_TARGET_INQUIRYOK	1
#define INITED_TARGET_MODEOK	2
@


1.16
log
@This file is no longer needed.
@
text
@d1 1
d3 1
a3 3
 * Interface to the generic driver for the aic7xxx based adaptec
 * SCSI controllers.  This is used to implement product specific
 * probe and attach routines.
d5 2
a6 1
 * Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Justin T. Gibbs.
d15 8
a22 2
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d25 2
a26 1
 * the GNU Public License ("GPL").
d28 6
a33 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d36 4
a39 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d41 6
a46 2
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.h,v 1.15 2000/01/07 23:08:18 gibbs Exp $
 * $OpenBSD: aic7xxxvar.h,v 1.15 2002/03/26 00:56:10 krw Exp $
d52 46
d102 47
a148 2
#ifndef TRUE
#define TRUE 1
d151 1
d153 1
a153 1
 * convert FreeBSD's <sys/queue.h> symbols to NetBSD's
d155 9
a163 9
#define	STAILQ_ENTRY		SIMPLEQ_ENTRY
#define	STAILQ_HEAD		SIMPLEQ_HEAD
#define	STAILQ_INIT		SIMPLEQ_INIT
#define	STAILQ_INSERT_HEAD	SIMPLEQ_INSERT_HEAD
#define	STAILQ_INSERT_TAIL	SIMPLEQ_INSERT_TAIL
#define	STAILQ_REMOVE_HEAD(head, field)	\
	SIMPLEQ_REMOVE_HEAD(head, (head)->sqh_first, field)
#define	stqh_first		sqh_first
#define	stqe_next		sqe_next
d167 28
d196 1
a196 1
#define AHC_MAXTRANSFER_SIZE	 0x00ffffff	/* limited by 24bit counter */
d199 5
a203 17
 * The number of dma segments supported.  The current implementation limits
 * us to 255 S/G entries (this may change to be unlimited at some point).
 * To reduce the driver's memory consumption, we further limit the number
 * supported to be sufficient to handle the largest mapping supported by
 * the kernel, MAXPHYS.  Assuming the transfer is as fragmented as possible
 * and unaligned, this turns out to be the number of paged sized transfers
 * in MAXPHYS plus an extra element to handle any unaligned residual.
 */
#define AHC_NSEG (MIN(btoc(MAXPHYS) + 1, 255))

#define AHC_SCB_MAX	255	/*
				 * Up to 255 SCBs on some types of aic7xxx
				 * based boards.  The aic7870 have 16 internal
				 * SCBs, but external SRAM bumps this to 255.
				 * The aic7770 family have only 4, and the 
				 * aic7850 has only 3.
				 */
d205 6
a210 6
#define AHC_TMODE_CMDS	256    /*
				* Ring Buffer of incoming target commands.
				* We allocate 256 to simplify the logic
				* in the sequencer by using the natural
				* wrap point of an 8bit counter.
				*/
d212 2
a213 4
struct ahc_dma_seg {
	u_int32_t	addr;
	u_int32_t	len;
};
d215 5
d230 3
a232 3
	AHC_AIC7890	= 0x0008,
	AHC_AIC7892	= 0x0009,
	AHC_AIC7895	= 0x000a,
d234 2
a235 1
	AHC_AIC7899	= 0x000c,
d242 3
a244 2
extern char *ahc_chip_names[];

d246 49
a294 29
	AHC_FENONE	= 0x0000,
	AHC_ULTRA	= 0x0001,	/* Supports 20MHz Transfers */
	AHC_ULTRA2	= 0x0002,	/* Supports 40MHz Transfers */
	AHC_WIDE  	= 0x0004,	/* Wide Channel */
	AHC_TWIN	= 0x0008,	/* Twin Channel */
	AHC_MORE_SRAM	= 0x0010,	/* 80 bytes instead of 64 */
	AHC_CMD_CHAN	= 0x0020,	/* Has a Command DMA Channel */
	AHC_QUEUE_REGS	= 0x0040,	/* Has Queue management registers */
	AHC_SG_PRELOAD	= 0x0080,	/* Can perform auto-SG preload */
	AHC_SPIOCAP	= 0x0100,	/* Has a Serial Port I/O Cap Register */
	AHC_MULTI_TID	= 0x0200,	/* Has bitmask of TIDs for select-in */
	AHC_HS_MAILBOX	= 0x0400,	/* Has HS_MAILBOX register */
	AHC_DT		= 0x0800,	/* Double Transition transfers */
	AHC_NEW_TERMCTL	= 0x1000,
	AHC_MULTI_FUNC	= 0x2000,	/* Multi-Function Twin Channel Device */
	AHC_TARG_DMABUG	= 0x4000,	/* WideOdd Data-In bug in TMODE */
	AHC_AIC7770_FE	= AHC_TARG_DMABUG,
	AHC_AIC7850_FE	= AHC_TARG_DMABUG|AHC_SPIOCAP,
	AHC_AIC7855_FE	= AHC_AIC7850_FE,
	AHC_AIC7859_FE	= AHC_AIC7850_FE|AHC_ULTRA,
	AHC_AIC7860_FE	= AHC_AIC7859_FE,
	AHC_AIC7870_FE	= AHC_TARG_DMABUG,
	AHC_AIC7880_FE	= AHC_TARG_DMABUG|AHC_ULTRA,
	AHC_AIC7890_FE	= AHC_MORE_SRAM|AHC_CMD_CHAN|AHC_ULTRA2|AHC_QUEUE_REGS
			  |AHC_SG_PRELOAD|AHC_MULTI_TID|AHC_HS_MAILBOX
			  |AHC_NEW_TERMCTL,
	AHC_AIC7892_FE	= AHC_AIC7890_FE|AHC_DT,
	AHC_AIC7895_FE	= AHC_AIC7880_FE|AHC_MORE_SRAM
			  |AHC_CMD_CHAN|AHC_MULTI_FUNC,
d300 50
d351 4
a354 6
	AHC_FNONE		= 0x000,
	AHC_PAGESCBS		= 0x001,/* Enable SCB paging */
	AHC_CHANNEL_B_PRIMARY	= 0x002,/*
					 * On twin channel adapters, probe
					 * channel B first since it is the
					 * primary bus.
d356 1
a356 1
	AHC_USEDEFAULTS		= 0x004,/*
d362 10
a371 9
	AHC_SHARED_SRAM		= 0x010,
	AHC_LARGE_SEEPROM	= 0x020,/* Uses C56_66 not C46 */
	AHC_RESET_BUS_A		= 0x040,
	AHC_RESET_BUS_B		= 0x080,
	AHC_EXTENDED_TRANS_A	= 0x100,
	AHC_EXTENDED_TRANS_B	= 0x200,
	AHC_TERM_ENB_A		= 0x400,
	AHC_TERM_ENB_B		= 0x800,
	AHC_INITIATORMODE	= 0x1000,/*
d375 1
a375 1
	AHC_TARGETMODE		= 0x2000,/*
d379 4
a382 4
	AHC_NEWEEPROM_FMT	= 0x4000,
	AHC_RESOURCE_SHORTAGE	= 0x8000,
	AHC_TQINFIFO_BLOCKED	= 0x10000,/* Blocked waiting for ATIOs */
	AHC_INT50_SPEEDFLEX	= 0x20000,/*
d386 14
d402 170
d574 1
d585 26
a610 7
	SCB_FREEZE_QUEUE	= 0x0010,
	SCB_REQUEUE		= 0x0020,
	SCB_RECOVERY_SCB	= 0x0040,
	SCB_ABORT		= 0x1000,
	SCB_QUEUED_MSG		= 0x2000,
	SCB_ACTIVE		= 0x4000,
	SCB_TARGET_IMMEDIATE	= 0x8000
d613 25
a637 17
/*
 * The driver keeps up to MAX_SCB scb structures per card in memory.  The SCB
 * consists of a "hardware SCB" mirroring the fields availible on the card
 * and additional information the kernel stores for each transaction.
 */
struct hardware_scb {
/*0*/   u_int8_t  control;
/*1*/	u_int8_t  tcl;		/* 4/1/3 bits */
/*2*/	u_int8_t  status;
/*3*/	u_int8_t  SG_count;
/*4*/	u_int32_t SG_pointer;
/*8*/	u_int8_t  residual_SG_count;
/*9*/	u_int8_t  residual_data_count[3];
/*12*/	u_int32_t data;
/*16*/	u_int32_t datalen;		/* Really only three bytes, but its
					 * faster to treat it as a long on
					 * a quad boundary.
d639 8
a646 4
/*20*/	u_int32_t cmdpointer;
/*24*/	u_int8_t  cmdlen;
/*25*/	u_int8_t  tag;			/* Index into our kernel SCB array.
					 * Also used as the tag for tagged I/O
d648 25
a672 21
/*26*/	u_int8_t  next;			/* Used for threading SCBs in the
					 * "Waiting for Selection" and
					 * "Disconnected SCB" lists down
					 * in the sequencer.
					 */
/*27*/	u_int8_t  scsirate;		/* Value for SCSIRATE register */
/*28*/	u_int8_t  scsioffset;		/* Value for SCSIOFFSET register */
/*29*/	u_int8_t  spare[3];		/*
					 * Spare space available on
					 * all controller types.
					 */
/*32*/	u_int8_t  cmdstore[16];		/*
					 * CDB storage for controllers
					 * supporting 64 byte SCBs.
					 */
/*48*/	u_int32_t cmdstore_busaddr;	/*
					 * Address of command store for
					 * 32byte SCB adapters
					 */
/*48*/	u_int8_t  spare_64[12];		/*
					 * Pad to 64 bytes.
d676 1
a676 11
struct scb {
	struct	hardware_scb	*hscb;
	SLIST_ENTRY(scb)	 links;	 /* for chaining */
	LIST_ENTRY(scb)	 pend_links;	 /* for pending scbs*/
	struct scsi_xfer *xs;	/* the scsi_xfer for this cmd */
	scb_flag		 flags;
	bus_dmamap_t		 dmamap;
	struct	ahc_dma_seg 	*sg_list;
	bus_addr_t		 sg_list_phys;
	u_int			 sg_count;/* How full ahc_dma_seg is */
};
a679 5
 * The first byte is the connecting target, followed by identify
 * message and optional tag information, terminated by 0xFF.  The
 * remainder is the command to execute.  The cmd_valid byte is on
 * an 8 byte boundary to simplify setting it on aic7880 hardware
 * which only has limited direct access to the DMA FIFO.
d682 19
a700 6
	u_int8_t initiator_channel;
	u_int8_t targ_id;	/* Target ID we were selected at */
	u_int8_t identify;	/* Identify message */
	u_int8_t bytes[21];
	u_int8_t cmd_valid;
	u_int8_t pad[7];
d709 2
a710 2
	u_int8_t initiator_id;
	u_int8_t event_type;	/* MSG type or EVENT_TYPE_BUS_RESET */
d712 1
a712 1
	u_int8_t event_arg;
d716 5
a720 2
 * Per lun target mode state including accept TIO CCB
 * and immediate notify CCB pools.
d722 10
a731 2
struct tmode_lstate {
	u_int8_t not_yet;
d733 3
d737 3
a739 2
#define AHC_TRANS_CUR		0x01	/* Modify current neogtiation status */
#define AHC_TRANS_ACTIVE	0x03	/* Assume this is the active target */
d743 8
d752 6
a757 4
	u_int8_t width;
	u_int8_t period;
	u_int8_t offset;
	u_int8_t ppr_flags;
d760 2
d763 2
a764 2
	u_int8_t scsirate;
	struct ahc_transinfo current;
d770 5
a774 4
 * Per target mode enabled target state.  Esentially just an array of
 * pointers to lun target state as well as sync/wide negotiation information
 * for each initiator<->target mapping (including the mapping for when we
 * are the initiator).
d776 3
a778 2
struct tmode_tstate {
	struct ahc_initiator_tinfo	transinfo[16];
d783 17
a799 3
	u_int16_t		 ultraenb;	/* Using ultra sync rate  */
	u_int16_t	 	 discenable;	/* Disconnection allowed  */
	u_int16_t		 tagenable;	/* Tagged Queuing allowed */
d802 3
a804 2
#define ALL_TARGETS -1
#define ALL_LUNS -1
d807 1
a807 1
 * Define the format of the aic7XXX SEEPROM registers (16 bits).
d809 19
d831 1
a831 1
 * SCSI ID Configuration Flags
d833 1
a833 1
	u_int16_t device_flags[16];	/* words 0-15 */
d843 1
a843 1
#define		CFMULTILUN	0x0800	/* Probe multiple luns in BIOS scan */
d850 1
a850 1
	u_int16_t bios_control;		/* word 16 */
d854 1
a854 1
/*		UNUSED		0x0008	*/
d856 1
d858 2
a859 1
/*		UNUSED		0x0040	*/
d861 6
d872 1
a872 1
	u_int16_t adapter_control;	/* word 17 */	
d881 1
d883 7
a889 4
#define		CFCHNLBPRIMARY	0x0100	/* aic7895 probe B channel first */
#define		CFSEAUTOTERM	0x0400	/* aic7890 Perform SE Auto Termination*/
#define		CFLVDSTERM	0x0800	/* aic7890 LVD Termination */
/*		UNUSED		0xf280	*/
d892 1
a892 1
 * Bus Release, Host Adapter ID
d894 1
a894 1
	u_int16_t brtime_id;		/* word 18 */
d902 1
a902 1
	u_int16_t max_targets;		/* word 19 */	
d904 7
a910 13
/*		UNUSED		0xff00	*/
	u_int16_t res_1[11];		/* words 20-30 */
	u_int16_t checksum;		/* word 31 */
};

struct ahc_syncrate {
	int sxfr_u2;
	int sxfr;
	/* Rates in Ultra mode have bit 8 of sxfr set */
#define		ULTRA_SXFR 0x100
#define		ST_SXFR	   0x010
	u_int8_t period; /* Period to send to SCSI target */
	char *rate;
d913 1
d922 31
a952 7
struct sg_map_node {
	bus_dmamap_t		 sg_dmamap;
	bus_addr_t		 sg_physaddr;
	bus_dma_segment_t	 sg_dmasegs;
	int			 sg_nseg;
	struct ahc_dma_seg*	 sg_vaddr;
	SLIST_ENTRY(sg_map_node) links;
d954 27
a980 9
	
struct scb_data {
	struct	hardware_scb	*hscbs;	    /* Array of hardware SCBs */
	struct	scb *scbarray;		    /* Array of kernel SCBs */
	SLIST_HEAD(, scb) free_scbs;	/*
					 * Pool of SCBs ready to be assigned
					 * commands to execute.
					 */
	struct	scsi_sense_data *sense; /* Per SCB sense data */
d983 4
a986 1
	 * "Bus" addresses of our data structures.
d988 1
a988 5
	bus_dmamap_t	 hscb_dmamap;
	bus_addr_t	 hscb_busaddr;
	bus_dma_segment_t hscb_seg;
	int		  hscb_nseg;
	int		  hscb_size;
d990 8
a997 5
	bus_dmamap_t	 sense_dmamap;
	bus_addr_t	 sense_busaddr;
	bus_dma_segment_t sense_seg;
	int		  sense_nseg;
	int		  sense_size;
d999 4
a1002 8
	SLIST_HEAD(, sg_map_node) sg_maps;
	u_int8_t	numscbs;
	u_int8_t	maxhscbs;	/* Number of SCBs on the card */
	u_int8_t	init_level;	/*
					 * How far we've initialized
					 * this structure.
					 */
};
d1004 4
a1007 21
struct ahc_softc {
	struct device sc_dev;
	void	*sc_ih;
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
	bus_dma_tag_t		sc_dmat;
	bus_dmamap_t		sc_dmamap_fifo;	/* maps the FIFOs */
	bus_dma_tag_t		 buffer_dmat;	/* dmat for buffer I/O */
	struct scb_data		*scb_data;
	void	*pci_data;			/* for pci config read/write */
	int	(*pci_intr_func)(struct ahc_softc *);	/* for pci error interrupts  */
	LIST_HEAD(, scsi_xfer) sc_xxxq;	/* XXX software request queue */
	struct scsi_xfer *sc_xxxqlast;	/* last entry in queue */
	
	int			queue_blocked;
	u_int16_t		devqueue_blocked[16];
#define AHC_NEG_PENDING		0x01
#define AHC_NEG_SDTRDONE	0x02
#define AHC_NEG_WDTRDONE	0x04
	u_int8_t		inited_targets[16];
	u_int8_t		inited_channels[2];
d1010 1
a1010 1
	 * SCBs that have been send to the controller
d1012 1
a1012 1
	LIST_HEAD(, scb)	 pending_scbs;
d1020 6
a1025 1
	struct tmode_tstate*	 enabled_targets[16];
d1031 1
a1031 1
	struct tmode_lstate*	 black_hole;
d1035 1
a1035 1
	 * for a command that was not given the disconnect priveledge.
d1037 1
a1037 1
	struct tmode_lstate*	 pending_device;
d1042 5
a1046 3
	ahc_chip		 chip;
	ahc_feature		 features;
	ahc_flag		 flags;
d1049 2
a1050 2
	u_int8_t		 unpause;
	u_int8_t		 pause;
d1053 8
a1060 4
	u_int8_t		 qoutfifonext;
	u_int8_t		 qinfifonext;
	u_int8_t		*qoutfifo;
	u_int8_t		*qinfifo;
d1062 2
a1063 13
	/*
	 * 256 byte array storing the SCBID of outstanding
	 * untagged SCBs indexed by TCL.
	 */	
	u_int8_t		 *untagged_scbs;

	/*
	 * Hooks into the XPT.
	 */
	struct	scsi_link sc_link;
	struct	scsi_link sc_link_b;	/* Second bus for Twin channel cards */

	int			 unit;
d1066 1
a1066 2
	char			 channel;
	char			 channel_b;
d1069 2
a1070 2
	u_int8_t		 our_id;
	u_int8_t		 our_id_b;
d1072 4
a1075 2
	/* Targets that need negotiation messages */
	u_int16_t		 targ_msg_req;
d1080 2
a1081 2
	struct target_cmd	*targetcmds;
	u_int8_t		 tqinfifonext;
d1086 33
a1118 14
	u_int8_t		 send_msg_perror;
	ahc_msg_type		 msg_type;
	u_int8_t		 msgout_buf[8];	/* Message we are sending */
	u_int8_t		 msgin_buf[8];	/* Message we are receiving */
	u_int			 msgout_len;	/* Length of message to send */
	u_int			 msgout_index;	/* Current index in msgout */
	u_int			 msgin_index;	/* Current index in msgin */

	void			*ih;
	bus_dmamap_t		 shared_data_dmamap;
	bus_addr_t		 shared_data_busaddr;
	bus_dma_segment_t	 shared_data_seg;
	int			 shared_data_nseg;
	int			 shared_data_size;
d1121 1
a1121 1
	u_int			 enabled_luns;
d1124 45
a1168 1
	u_int			 init_level;
d1170 10
a1179 2
	u_int16_t	 	 user_discenable;/* Disconnection allowed  */
	u_int16_t		 user_tagenable; /* Tagged Queuing allowed */
d1181 6
d1188 2
d1191 132
a1322 1
/* #define AHC_DEBUG */
d1324 26
a1349 42
/* Different debugging levels used when AHC_DEBUG is defined */
#define AHC_SHOWMISC	0x0001
#define AHC_SHOWCMDS	0x0002
#define AHC_SHOWSCBS	0x0004
#define AHC_SHOWABORTS	0x0008
#define AHC_SHOWSENSE	0x0010
#define AHC_SHOWSCBCNT	0x0020

extern int ahc_debug; /* Initialized in i386/scsi/aic7xxx.c */
#endif

#define	ahc_name(ahc)	(ahc)->sc_dev.dv_xname

void	ahc_construct(struct ahc_softc *ahc, bus_space_tag_t iot,
		bus_space_handle_t ioh, ahc_chip chip, ahc_flag flags, 
		ahc_feature features, u_char channel);
int   ahc_probe_scbs(struct ahc_softc *ahc);
void	ahc_free(struct ahc_softc *);
int	ahc_init(struct ahc_softc *);
int	ahc_attach(struct ahc_softc *);
int	ahc_intr(void *arg);
int	ahc_reset(struct ahc_softc *ahc);
void  ahc_xxx_reset(char *devname, bus_space_tag_t iot, bus_space_handle_t ioh);
#define ahc_isa_reset ahc_xxx_reset
#define ahc_eisa_reset ahc_xxx_reset

#define	AHC_INB(ahc, port)	\
	bus_space_read_1((ahc)->sc_iot, (ahc)->sc_ioh, port)
#define	AHC_INSB(ahc, port, valp, size)	\
	bus_space_read_multi_1((ahc)->sc_iot, (ahc)->sc_ioh, port, (u_int8_t *) valp, size)
#define	AHC_OUTB(ahc, port, val)	\
	bus_space_write_1((ahc)->sc_iot, (ahc)->sc_ioh, port, val)
#define	AHC_OUTSB(ahc, port, valp, size)	\
	bus_space_write_multi_1((ahc)->sc_iot, (ahc)->sc_ioh, port, (u_int8_t *) valp, size)
#define	AHC_OUTSL(ahc, port, valp, size)	\
	bus_space_write_multi_4((ahc)->sc_iot, (ahc)->sc_ioh, port, (u_int32_t *) valp, size)

#define ahc_inb AHC_INB
#define ahc_insb AHC_INSB
#define ahc_outb AHC_OUTB
#define ahc_outsb AHC_OUTSB
#define ahc_outsl AHC_OUTSL
d1351 2
a1352 1
#endif  /* _AIC7XXXVAR_H_ */
@


1.15
log
@Fix problems the ahc driver was having with the recent changes to
scsiconf.c. The fact that both this ('original') ahc driver and the
new ahc driver (since reverted) crashed if devices capable of tagged
queuing were not correctly flagged as such must be a clue to some
interesting problem.

a) Restore marking of appropriate devices as tagged.
b) Use TAG_ENB define instead of MSG_SIMPLE_Q_TAG when
   manipulating hscb->control. Both were defined to the
   same value, but TAG_ENB is the define used to extract
   the bit later on.
c) Delete unused field 'tagdisable'.

ok millert@@, also tested by naddy@@
@
text
@d34 1
a34 1
 * $OpenBSD: aic7xxxvar.h,v 1.14 2002/03/14 01:26:54 millert Exp $
@


1.14
log
@First round of __P removal in sys
@
text
@d34 1
a34 1
 * $OpenBSD: aic7xxxvar.h,v 1.13 2000/07/03 22:18:36 smurph Exp $
a344 1
	u_int16_t		 tagdisable;	/* Tagged Queuing NOT allowed */
@


1.13
log
@Add support for big endian hardware.  Clean up memory vs. io mapping code.
Fix for drives with Tag quirks.
@
text
@d34 1
a34 1
 * $OpenBSD: aic7xxxvar.h,v 1.12 2000/06/16 21:47:13 provos Exp $
d493 1
a493 1
	int	(*pci_intr_func) __P((struct ahc_softc *));	/* for pci error interrupts  */
d622 1
a622 1
void	ahc_construct __P((struct ahc_softc *ahc, bus_space_tag_t iot,
d624 8
a631 8
		ahc_feature features, u_char channel));
int   ahc_probe_scbs __P((struct ahc_softc *ahc));
void	ahc_free __P((struct ahc_softc *));
int	ahc_init __P((struct ahc_softc *));
int	ahc_attach __P((struct ahc_softc *));
int	ahc_intr __P((void *arg));
int	ahc_reset __P((struct ahc_softc *ahc));
void  ahc_xxx_reset __P((char *devname, bus_space_tag_t iot, bus_space_handle_t ioh));
@


1.13.8.1
log
@Sync UBC branch to -current
@
text
@d34 1
a34 1
 * $OpenBSD: aic7xxxvar.h,v 1.13 2000/07/03 22:18:36 smurph Exp $
d345 1
d493 1
a493 1
	int	(*pci_intr_func)(struct ahc_softc *);	/* for pci error interrupts  */
d622 1
a622 1
void	ahc_construct(struct ahc_softc *ahc, bus_space_tag_t iot,
d624 8
a631 8
		ahc_feature features, u_char channel);
int   ahc_probe_scbs(struct ahc_softc *ahc);
void	ahc_free(struct ahc_softc *);
int	ahc_init(struct ahc_softc *);
int	ahc_attach(struct ahc_softc *);
int	ahc_intr(void *arg);
int	ahc_reset(struct ahc_softc *ahc);
void  ahc_xxx_reset(char *devname, bus_space_tag_t iot, bus_space_handle_t ioh);
@


1.13.8.2
log
@sync to -current
@
text
@d34 1
a34 1
 * $OpenBSD: aic7xxxvar.h,v 1.13.8.1 2002/06/11 03:42:17 art Exp $
@


1.12
log
@take MIN/MAX from param.h, okay theo@@
@
text
@d34 1
a34 1
 * $OpenBSD: aic7xxxvar.h,v 1.11 2000/03/22 02:48:47 smurph Exp $
d345 1
d499 3
d503 1
@


1.11
log
@new ahc driver.  Adds suport for newer Adaptec controllers.  This represents two months of work.
@
text
@d34 1
a34 1
 * $OpenBSD: src/sys/dev/aic7xxx/aic7xxxvar.h,v 1.0 2000/03/09 23:08:18 smurph Exp $
a38 8

#ifndef MAX
#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#endif
@


1.10
log
@queue handling hacks for chips like aic7860 which have small numbers of SCB's.
by gibbs@@freebsd.org
@
text
@a0 2
/*	$OpenBSD: aic7xxxvar.h,v 1.9 1996/11/28 23:27:45 niklas Exp $	*/
/*	$NetBSD: aic7xxxvar.h,v 1.10 1996/10/21 22:34:09 thorpej Exp $	*/
d6 1
a6 1
 * Copyright (c) 1994, 1995, 1996 Justin T. Gibbs.
d13 3
a15 6
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
d18 3
d32 3
d37 14
a50 2
#ifndef _AIC7XXX_H_
#define _AIC7XXX_H_
d52 2
a53 2
#if defined(__FreeBSD__)
#include "ahc.h"                /* for NAHC from config */
a55 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a67 1
#endif
d69 4
a72 23
#if defined(__FreeBSD__)
#define	AHC_INB(ahc, port)	\
	inb((ahc)->baseport+(port))
#define	AHC_INSB(ahc, port, valp, size)	\
	insb((ahc)->baseport+(port), valp, size)
#define	AHC_OUTB(ahc, port, val)	\
	outb((ahc)->baseport+(port), val)
#define	AHC_OUTSB(ahc, port, valp, size)	\
	outsb((ahc)->baseport+(port), valp, size)
#define	AHC_OUTSL(ahc, port, valp, size)	\
	outsl((ahc)->baseport+(port), valp, size)
#elif defined(__NetBSD__) || defined(__OpenBSD__)
#define	AHC_INB(ahc, port)	\
	bus_space_read_1((ahc)->sc_iot, (ahc)->sc_ioh, port)
#define	AHC_INSB(ahc, port, valp, size)	\
	bus_space_read_multi_1((ahc)->sc_iot, (ahc)->sc_ioh, port, (u_int8_t *) valp, size)
#define	AHC_OUTB(ahc, port, val)	\
	bus_space_write_1((ahc)->sc_iot, (ahc)->sc_ioh, port, val)
#define	AHC_OUTSB(ahc, port, valp, size)	\
	bus_space_write_multi_1((ahc)->sc_iot, (ahc)->sc_ioh, port, (u_int8_t *) valp, size)
#define	AHC_OUTSL(ahc, port, valp, size)	\
	bus_space_write_multi_4((ahc)->sc_iot, (ahc)->sc_ioh, port, (u_int32_t *) valp, size)
#endif
d74 10
a83 1
#define	AHC_NSEG	256	/* number of dma segments supported */
d93 6
a98 5

typedef u_int32_t physaddr;
#if defined(__FreeBSD__)
extern u_long ahc_unit;
#endif
d101 1
a101 1
	physaddr	addr;
d106 56
a161 18
	AHC_NONE	= 0x000,
	AHC_ULTRA	= 0x001,	/* Supports 20MHz Transfers */
	AHC_WIDE  	= 0x002,	/* Wide Channel */
	AHC_TWIN	= 0x008,	/* Twin Channel */
	AHC_AIC7770	= 0x010,
	AHC_AIC7850	= 0x020,
	AHC_AIC7860	= 0x021,	/* ULTRA version of the aic7850 */
	AHC_AIC7870	= 0x040,
	AHC_AIC7880	= 0x041,
	AHC_AIC78X0	= 0x060,	/* PCI Based Controller */
	AHC_274		= 0x110,	/* EISA Based Controller */
	AHC_284		= 0x210,	/* VL/ISA Based Controller */
	AHC_294AU	= 0x421,	/* aic7860 based '2940' */
	AHC_294		= 0x440,	/* PCI Based Controller */
	AHC_294U	= 0x441,	/* ULTRA PCI Based Controller */
	AHC_394		= 0x840,	/* Twin Channel PCI Controller */
	AHC_394U	= 0x841,	/* Twin, ULTRA Channel PCI Controller */
}ahc_type;
d164 3
a166 5
	AHC_FNONE		= 0x00,
	AHC_INIT		= 0x01,
	AHC_RUNNING		= 0x02,
	AHC_PAGESCBS		= 0x04,	/* Enable SCB paging */
	AHC_CHANNEL_B_PRIMARY	= 0x08,	/*
d171 1
a171 1
	AHC_USEDEFAULTS		= 0x10,	/*
d177 24
a200 6
	AHC_CHNLB		= 0x20,	/* 
					 * Second controller on 3940 
					 * Also encodes the offset in the
					 * SEEPROM for CHNLB info (32)
					 */
}ahc_flag;
d204 8
a211 2
	SCB_ACTIVE		= 0x0001,
	SCB_ABORTED		= 0x0002,
d213 14
a226 17
	SCB_IMMED		= 0x0008,
	SCB_SENSE		= 0x0010,
	SCB_TIMEDOUT		= 0x0020,
	SCB_QUEUED_FOR_DONE	= 0x0040,
	SCB_PAGED_OUT		= 0x0080,
	SCB_WAITINGQ		= 0x0100,
	SCB_ASSIGNEDQ		= 0x0200,
	SCB_SENTORDEREDTAG	= 0x0400,
	SCB_MSGOUT_SDTR		= 0x0800,
	SCB_MSGOUT_WDTR		= 0x1000
}scb_flag;

/*
 * The driver keeps up to MAX_SCB scb structures per card in memory.  Only the
 * first 28 bytes of the structure need to be transfered to the card during
 * normal operation.  The fields starting at byte 28 are used for kernel level
 * bookkeeping.  
d228 10
a237 11
struct scb {
/* ------------    Begin hardware supported fields    ---------------- */
/*0*/   u_char control;
/*1*/	u_char tcl;		/* 4/1/3 bits */
/*2*/	u_char status;
/*3*/	u_char SG_segment_count;
/*4*/	physaddr SG_list_pointer;
/*8*/	u_char residual_SG_segment_count;
/*9*/	u_char residual_data_count[3];
/*12*/	physaddr data;
/*16*/  u_int32_t datalen;		/* Really only three bits, but its
d241 3
a243 3
/*20*/	physaddr cmdpointer;
/*24*/	u_char cmdlen;
/*25*/	u_char tag;			/* Index into our kernel SCB array.
d246 1
a246 4
#define SCB_PIO_TRANSFER_SIZE	26 	/* amount we need to upload/download
					 * via PIO to initialize a transaction.
					 */
/*26*/	u_char next;			/* Used for threading SCBs in the
d251 23
a273 3
/*27*/	u_char prev;
/*-----------------end of hardware supported fields----------------*/
	STAILQ_ENTRY(scb)	links;	/* for chaining */
d275 5
a279 4
	scb_flag flags;
	u_char	position;	/* Position in card's scbarray */
	struct ahc_dma_seg ahc_dma[AHC_NSEG];
	struct scsi_sense sense_cmd;	/* SCSI command block */
d282 209
a490 4
struct ahc_data {
#if defined(__FreeBSD__)
	int	unit;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d495 6
d503 56
a558 28
#endif
	ahc_type type;
	ahc_flag flags;
#if defined(__FreeBSD__)
	u_long	baseport;
#endif
	struct	scb *scbarray[AHC_SCB_MAX]; /* Mirror boards scbarray */
	struct	scb *pagedout_ntscbs[16];/* 
					  * Paged out, non-tagged scbs
					  * indexed by target.
					  */
	STAILQ_HEAD(, scb) free_scbs;	/*
					 * SCBs assigned to free slots
					 * on the card. (no paging required)
					 */
	STAILQ_HEAD(, scb) page_scbs;	/*
					 * SCBs that will require paging
					 * before use (no assigned slot)
					 */
	STAILQ_HEAD(, scb) waiting_scbs;/*
					 * SCBs waiting to be paged in
					 * and started.
					 */
	STAILQ_HEAD(, scb)assigned_scbs;/*
					 * SCBs that were waiting but have
					 * now been assigned a slot by
					 * ahc_free_scb.
					 */
d561 47
a607 22
	u_short	needsdtr_orig;		/* Targets we initiate sync neg with */
	u_short	needwdtr_orig;		/* Targets we initiate wide neg with */
	u_short	needsdtr;		/* Current list of negotiated targets */
	u_short needwdtr;		/* Current list of negotiated targets */
	u_short sdtrpending;		/* Pending SDTR to these targets */
	u_short wdtrpending;		/* Pending WDTR to these targets */
	u_short	tagenable;		/* Targets that can handle tagqueing */
	u_short	orderedtag;		/* Targets to use ordered tag on */
	u_short	discenable;		/* Targets allowed to disconnect */
	u_char	our_id;			/* our scsi id */
	u_char	our_id_b;		/* B channel scsi id */
	u_char	numscbs;
	u_char	activescbs;
	u_char  maxhscbs;		/* Number of SCBs on the card */
	u_char	maxscbs;		/*
					 * Max SCBs we allocate total including
					 * any that will force us to page SCBs
					 */
	u_char	qcntmask;
	u_char	unpause;
	u_char	pause;
	u_char	in_timeout;
d623 1
a623 1
#if defined(__FreeBSD__)
d625 12
a636 1
char *ahc_name __P((struct ahc_data *ahc));
d638 10
a647 5
void ahc_reset __P((u_long iobase));
struct ahc_data *ahc_alloc __P((int unit, u_long io_base, ahc_type type, ahc_flag flags));
#elif defined(__NetBSD__) || defined(__OpenBSD__)

#define	ahc_name(ahc)	(ahc)->sc_dev.dv_xname
d649 5
a653 13
void	ahc_reset __P((char *devname, bus_space_tag_t iot,
	    bus_space_handle_t ioh));
void	ahc_construct __P((struct ahc_data *ahc, bus_space_tag_t iot,
	    bus_space_handle_t ioh, ahc_type type, ahc_flag flags));
#endif
void	ahc_free __P((struct ahc_data *));
int	ahc_init __P((struct ahc_data *));
int	ahc_attach __P((struct ahc_data *));
#if defined(__FreeBSD__)
void	ahc_intr __P((void *arg));
#elif defined(__NetBSD__) || defined(__OpenBSD__)
int	ahc_intr __P((void *arg));
#endif
d655 1
a655 1
#endif  /* _AIC7XXX_H_ */
@


1.10.14.1
log
@Sync with -current
@
text
@d1 2
d8 1
a8 1
 * Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Justin T. Gibbs.
d15 6
a20 3
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. The name of the author may not be used to endorse or promote products
a22 3
 * Alternatively, this software may be distributed under the terms of the
 * the GNU Public License ("GPL").
 *
a33 3
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.h,v 1.15 2000/01/07 23:08:18 gibbs Exp $
 * $OpenBSD$
d36 2
a37 14
#ifndef _AIC7XXXVAR_H_
#define _AIC7XXXVAR_H_

#ifndef MAX
#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef FALSE
#define FALSE 0
#endif
d39 2
a40 2
#ifndef TRUE
#define TRUE 1
d43 1
d56 1
d58 23
a80 4
/*
 * The maximum transfer per S/G segment.
 */
#define AHC_MAXTRANSFER_SIZE	 0x00ffffff	/* limited by 24bit counter */
d82 1
a82 10
/*
 * The number of dma segments supported.  The current implementation limits
 * us to 255 S/G entries (this may change to be unlimited at some point).
 * To reduce the driver's memory consumption, we further limit the number
 * supported to be sufficient to handle the largest mapping supported by
 * the kernel, MAXPHYS.  Assuming the transfer is as fragmented as possible
 * and unaligned, this turns out to be the number of paged sized transfers
 * in MAXPHYS plus an extra element to handle any unaligned residual.
 */
#define AHC_NSEG (MIN(btoc(MAXPHYS) + 1, 255))
d92 5
a96 6
#define AHC_TMODE_CMDS	256    /*
				* Ring Buffer of incoming target commands.
				* We allocate 256 to simplify the logic
				* in the sequencer by using the natural
				* wrap point of an 8bit counter.
				*/
d99 1
a99 1
	u_int32_t	addr;
d104 18
a121 56
	AHC_NONE	= 0x0000,
	AHC_CHIPID_MASK	= 0x00FF,
	AHC_AIC7770	= 0x0001,
	AHC_AIC7850	= 0x0002,
	AHC_AIC7855	= 0x0003,
	AHC_AIC7859	= 0x0004,
	AHC_AIC7860	= 0x0005,
	AHC_AIC7870	= 0x0006,
	AHC_AIC7880	= 0x0007,
	AHC_AIC7890	= 0x0008,
	AHC_AIC7892	= 0x0009,
	AHC_AIC7895	= 0x000a,
	AHC_AIC7896	= 0x000b,
	AHC_AIC7899	= 0x000c,
	AHC_VL		= 0x0100,	/* Bus type VL */
	AHC_EISA	= 0x0200,	/* Bus type EISA */
	AHC_PCI		= 0x0400,	/* Bus type PCI */
	AHC_BUS_MASK	= 0x0F00
} ahc_chip;

extern char *ahc_chip_names[];

typedef enum {
	AHC_FENONE	= 0x0000,
	AHC_ULTRA	= 0x0001,	/* Supports 20MHz Transfers */
	AHC_ULTRA2	= 0x0002,	/* Supports 40MHz Transfers */
	AHC_WIDE  	= 0x0004,	/* Wide Channel */
	AHC_TWIN	= 0x0008,	/* Twin Channel */
	AHC_MORE_SRAM	= 0x0010,	/* 80 bytes instead of 64 */
	AHC_CMD_CHAN	= 0x0020,	/* Has a Command DMA Channel */
	AHC_QUEUE_REGS	= 0x0040,	/* Has Queue management registers */
	AHC_SG_PRELOAD	= 0x0080,	/* Can perform auto-SG preload */
	AHC_SPIOCAP	= 0x0100,	/* Has a Serial Port I/O Cap Register */
	AHC_MULTI_TID	= 0x0200,	/* Has bitmask of TIDs for select-in */
	AHC_HS_MAILBOX	= 0x0400,	/* Has HS_MAILBOX register */
	AHC_DT		= 0x0800,	/* Double Transition transfers */
	AHC_NEW_TERMCTL	= 0x1000,
	AHC_MULTI_FUNC	= 0x2000,	/* Multi-Function Twin Channel Device */
	AHC_TARG_DMABUG	= 0x4000,	/* WideOdd Data-In bug in TMODE */
	AHC_AIC7770_FE	= AHC_TARG_DMABUG,
	AHC_AIC7850_FE	= AHC_TARG_DMABUG|AHC_SPIOCAP,
	AHC_AIC7855_FE	= AHC_AIC7850_FE,
	AHC_AIC7859_FE	= AHC_AIC7850_FE|AHC_ULTRA,
	AHC_AIC7860_FE	= AHC_AIC7859_FE,
	AHC_AIC7870_FE	= AHC_TARG_DMABUG,
	AHC_AIC7880_FE	= AHC_TARG_DMABUG|AHC_ULTRA,
	AHC_AIC7890_FE	= AHC_MORE_SRAM|AHC_CMD_CHAN|AHC_ULTRA2|AHC_QUEUE_REGS
			  |AHC_SG_PRELOAD|AHC_MULTI_TID|AHC_HS_MAILBOX
			  |AHC_NEW_TERMCTL,
	AHC_AIC7892_FE	= AHC_AIC7890_FE|AHC_DT,
	AHC_AIC7895_FE	= AHC_AIC7880_FE|AHC_MORE_SRAM
			  |AHC_CMD_CHAN|AHC_MULTI_FUNC,
	AHC_AIC7895C_FE	= AHC_AIC7895_FE|AHC_MULTI_TID,
	AHC_AIC7896_FE	= AHC_AIC7890_FE|AHC_MULTI_FUNC,
	AHC_AIC7899_FE	= AHC_AIC7892_FE|AHC_MULTI_FUNC
} ahc_feature;
d124 5
a128 3
	AHC_FNONE		= 0x000,
	AHC_PAGESCBS		= 0x001,/* Enable SCB paging */
	AHC_CHANNEL_B_PRIMARY	= 0x002,/*
d133 1
a133 1
	AHC_USEDEFAULTS		= 0x004,/*
d139 6
a144 24
	AHC_SHARED_SRAM		= 0x010,
	AHC_LARGE_SEEPROM	= 0x020,/* Uses C56_66 not C46 */
	AHC_RESET_BUS_A		= 0x040,
	AHC_RESET_BUS_B		= 0x080,
	AHC_EXTENDED_TRANS_A	= 0x100,
	AHC_EXTENDED_TRANS_B	= 0x200,
	AHC_TERM_ENB_A		= 0x400,
	AHC_TERM_ENB_B		= 0x800,
	AHC_INITIATORMODE	= 0x1000,/*
					  * Allow initiator operations on
					  * this controller.
					  */
	AHC_TARGETMODE		= 0x2000,/*
					  * Allow target operations on this
					  * controller.
					  */
	AHC_NEWEEPROM_FMT	= 0x4000,
	AHC_RESOURCE_SHORTAGE	= 0x8000,
	AHC_TQINFIFO_BLOCKED	= 0x10000,/* Blocked waiting for ATIOs */
	AHC_INT50_SPEEDFLEX	= 0x20000,/*
					   * Internal 50pin connector
					   * sits behind an aic3860
					   */
} ahc_flag;
d148 2
a149 8
	SCB_OTHERTCL_TIMEOUT	= 0x0002,/*
					  * Another device was active
					  * during the first timeout for
					  * this SCB so we gave ourselves
					  * an additional timeout period
					  * in case it was hogging the
					  * bus.
				          */
d151 17
a167 14
	SCB_SENSE		= 0x0008,
	SCB_FREEZE_QUEUE	= 0x0010,
	SCB_REQUEUE		= 0x0020,
	SCB_RECOVERY_SCB	= 0x0040,
	SCB_ABORT		= 0x1000,
	SCB_QUEUED_MSG		= 0x2000,
	SCB_ACTIVE		= 0x4000,
	SCB_TARGET_IMMEDIATE	= 0x8000
} scb_flag;

/*
 * The driver keeps up to MAX_SCB scb structures per card in memory.  The SCB
 * consists of a "hardware SCB" mirroring the fields availible on the card
 * and additional information the kernel stores for each transaction.
d169 11
a179 10
struct hardware_scb {
/*0*/   u_int8_t  control;
/*1*/	u_int8_t  tcl;		/* 4/1/3 bits */
/*2*/	u_int8_t  status;
/*3*/	u_int8_t  SG_count;
/*4*/	u_int32_t SG_pointer;
/*8*/	u_int8_t  residual_SG_count;
/*9*/	u_int8_t  residual_data_count[3];
/*12*/	u_int32_t data;
/*16*/	u_int32_t datalen;		/* Really only three bytes, but its
d183 3
a185 3
/*20*/	u_int32_t cmdpointer;
/*24*/	u_int8_t  cmdlen;
/*25*/	u_int8_t  tag;			/* Index into our kernel SCB array.
d188 4
a191 1
/*26*/	u_int8_t  next;			/* Used for threading SCBs in the
d196 3
a198 23
/*27*/	u_int8_t  scsirate;		/* Value for SCSIRATE register */
/*28*/	u_int8_t  scsioffset;		/* Value for SCSIOFFSET register */
/*29*/	u_int8_t  spare[3];		/*
					 * Spare space available on
					 * all controller types.
					 */
/*32*/	u_int8_t  cmdstore[16];		/*
					 * CDB storage for controllers
					 * supporting 64 byte SCBs.
					 */
/*48*/	u_int32_t cmdstore_busaddr;	/*
					 * Address of command store for
					 * 32byte SCB adapters
					 */
/*48*/	u_int8_t  spare_64[12];		/*
					 * Pad to 64 bytes.
					 */
};

struct scb {
	struct	hardware_scb	*hscb;
	SLIST_ENTRY(scb)	 links;	 /* for chaining */
	LIST_ENTRY(scb)	 pend_links;	 /* for pending scbs*/
d200 4
a203 5
	scb_flag		 flags;
	bus_dmamap_t		 dmamap;
	struct	ahc_dma_seg 	*sg_list;
	bus_addr_t		 sg_list_phys;
	u_int			 sg_count;/* How full ahc_dma_seg is */
d206 4
a209 209
/*
 * Connection desciptor for select-in requests in target mode.
 * The first byte is the connecting target, followed by identify
 * message and optional tag information, terminated by 0xFF.  The
 * remainder is the command to execute.  The cmd_valid byte is on
 * an 8 byte boundary to simplify setting it on aic7880 hardware
 * which only has limited direct access to the DMA FIFO.
 */
struct target_cmd {
	u_int8_t initiator_channel;
	u_int8_t targ_id;	/* Target ID we were selected at */
	u_int8_t identify;	/* Identify message */
	u_int8_t bytes[21];
	u_int8_t cmd_valid;
	u_int8_t pad[7];
};

/*
 * Number of events we can buffer up if we run out
 * of immediate notify ccbs.
 */
#define AHC_TMODE_EVENT_BUFFER_SIZE 8
struct ahc_tmode_event {
	u_int8_t initiator_id;
	u_int8_t event_type;	/* MSG type or EVENT_TYPE_BUS_RESET */
#define	EVENT_TYPE_BUS_RESET 0xFF
	u_int8_t event_arg;
};

/*
 * Per lun target mode state including accept TIO CCB
 * and immediate notify CCB pools.
 */
struct tmode_lstate {
	u_int8_t not_yet;
};

#define AHC_TRANS_CUR		0x01	/* Modify current neogtiation status */
#define AHC_TRANS_ACTIVE	0x03	/* Assume this is the active target */
#define AHC_TRANS_GOAL		0x04	/* Modify negotiation goal */
#define AHC_TRANS_USER		0x08	/* Modify user negotiation settings */

struct ahc_transinfo {
	u_int8_t width;
	u_int8_t period;
	u_int8_t offset;
	u_int8_t ppr_flags;
};

struct ahc_initiator_tinfo {
	u_int8_t scsirate;
	struct ahc_transinfo current;
	struct ahc_transinfo goal;
	struct ahc_transinfo user;
};

/*
 * Per target mode enabled target state.  Esentially just an array of
 * pointers to lun target state as well as sync/wide negotiation information
 * for each initiator<->target mapping (including the mapping for when we
 * are the initiator).
 */
struct tmode_tstate {
	struct ahc_initiator_tinfo	transinfo[16];

	/*
	 * Per initiator state bitmasks.
	 */
	u_int16_t		 ultraenb;	/* Using ultra sync rate  */
	u_int16_t	 	 discenable;	/* Disconnection allowed  */
	u_int16_t		 tagenable;	/* Tagged Queuing allowed */
};

#define ALL_TARGETS -1
#define ALL_LUNS -1

/*
 * Define the format of the aic7XXX SEEPROM registers (16 bits).
 */

struct seeprom_config {
/*
 * SCSI ID Configuration Flags
 */
	u_int16_t device_flags[16];	/* words 0-15 */
#define		CFXFER		0x0007	/* synchronous transfer rate */
#define		CFSYNCH		0x0008	/* enable synchronous transfer */
#define		CFDISC		0x0010	/* enable disconnection */
#define		CFWIDEB		0x0020	/* wide bus device */
#define		CFSYNCHISULTRA	0x0040	/* CFSYNCH is an ultra offset (2940AU)*/
#define		CFSYNCSINGLE	0x0080	/* Single-Transition signalling */
#define		CFSTART		0x0100	/* send start unit SCSI command */
#define		CFINCBIOS	0x0200	/* include in BIOS scan */
#define		CFRNFOUND	0x0400	/* report even if not found */
#define		CFMULTILUN	0x0800	/* Probe multiple luns in BIOS scan */
#define		CFWBCACHEENB	0x4000	/* Enable W-Behind Cache on disks */
#define		CFWBCACHENOP	0xc000	/* Don't touch W-Behind Cache */

/*
 * BIOS Control Bits
 */
	u_int16_t bios_control;		/* word 16 */
#define		CFSUPREM	0x0001	/* support all removeable drives */
#define		CFSUPREMB	0x0002	/* support removeable boot drives */
#define		CFBIOSEN	0x0004	/* BIOS enabled */
/*		UNUSED		0x0008	*/
#define		CFSM2DRV	0x0010	/* support more than two drives */
#define		CF284XEXTEND	0x0020	/* extended translation (284x cards) */	
/*		UNUSED		0x0040	*/
#define		CFEXTEND	0x0080	/* extended translation enabled */
/*		UNUSED		0xff00	*/

/*
 * Host Adapter Control Bits
 */
	u_int16_t adapter_control;	/* word 17 */	
#define		CFAUTOTERM	0x0001	/* Perform Auto termination */
#define		CFULTRAEN	0x0002	/* Ultra SCSI speed enable */
#define		CF284XSELTO     0x0003	/* Selection timeout (284x cards) */
#define		CF284XFIFO      0x000C	/* FIFO Threshold (284x cards) */
#define		CFSTERM		0x0004	/* SCSI low byte termination */
#define		CFWSTERM	0x0008	/* SCSI high byte termination */
#define		CFSPARITY	0x0010	/* SCSI parity */
#define		CF284XSTERM     0x0020	/* SCSI low byte term (284x cards) */	
#define		CFRESETB	0x0040	/* reset SCSI bus at boot */
#define		CFCHNLBPRIMARY	0x0100	/* aic7895 probe B channel first */
#define		CFSEAUTOTERM	0x0400	/* aic7890 Perform SE Auto Termination*/
#define		CFLVDSTERM	0x0800	/* aic7890 LVD Termination */
/*		UNUSED		0xf280	*/

/*
 * Bus Release, Host Adapter ID
 */
	u_int16_t brtime_id;		/* word 18 */
#define		CFSCSIID	0x000f	/* host adapter SCSI ID */
/*		UNUSED		0x00f0	*/
#define		CFBRTIME	0xff00	/* bus release time */

/*
 * Maximum targets
 */
	u_int16_t max_targets;		/* word 19 */	
#define		CFMAXTARG	0x00ff	/* maximum targets */
/*		UNUSED		0xff00	*/
	u_int16_t res_1[11];		/* words 20-30 */
	u_int16_t checksum;		/* word 31 */
};

struct ahc_syncrate {
	int sxfr_u2;
	int sxfr;
	/* Rates in Ultra mode have bit 8 of sxfr set */
#define		ULTRA_SXFR 0x100
#define		ST_SXFR	   0x010
	u_int8_t period; /* Period to send to SCSI target */
	char *rate;
};

typedef enum {
	MSG_TYPE_NONE			= 0x00,
	MSG_TYPE_INITIATOR_MSGOUT	= 0x01,
	MSG_TYPE_INITIATOR_MSGIN	= 0x02,
	MSG_TYPE_TARGET_MSGOUT		= 0x03,
	MSG_TYPE_TARGET_MSGIN		= 0x04
} ahc_msg_type;

struct sg_map_node {
	bus_dmamap_t		 sg_dmamap;
	bus_addr_t		 sg_physaddr;
	bus_dma_segment_t	 sg_dmasegs;
	int			 sg_nseg;
	struct ahc_dma_seg*	 sg_vaddr;
	SLIST_ENTRY(sg_map_node) links;
};
	
struct scb_data {
	struct	hardware_scb	*hscbs;	    /* Array of hardware SCBs */
	struct	scb *scbarray;		    /* Array of kernel SCBs */
	SLIST_HEAD(, scb) free_scbs;	/*
					 * Pool of SCBs ready to be assigned
					 * commands to execute.
					 */
	struct	scsi_sense_data *sense; /* Per SCB sense data */

	/*
	 * "Bus" addresses of our data structures.
	 */
	bus_dmamap_t	 hscb_dmamap;
	bus_addr_t	 hscb_busaddr;
	bus_dma_segment_t hscb_seg;
	int		  hscb_nseg;
	int		  hscb_size;

	bus_dmamap_t	 sense_dmamap;
	bus_addr_t	 sense_busaddr;
	bus_dma_segment_t sense_seg;
	int		  sense_nseg;
	int		  sense_size;

	SLIST_HEAD(, sg_map_node) sg_maps;
	u_int8_t	numscbs;
	u_int8_t	maxhscbs;	/* Number of SCBs on the card */
	u_int8_t	init_level;	/*
					 * How far we've initialized
					 * this structure.
					 */
};

struct ahc_softc {
a213 6
	bus_dma_tag_t		sc_dmat;
	bus_dmamap_t		sc_dmamap_fifo;	/* maps the FIFOs */
	bus_dma_tag_t		 buffer_dmat;	/* dmat for buffer I/O */
	struct scb_data		*scb_data;
	void	*pci_data;			/* for pci config read/write */
	int	(*pci_intr_func) __P((struct ahc_softc *));	/* for pci error interrupts  */
d216 28
a243 56
	
	int			queue_blocked;
	u_int16_t		devqueue_blocked[16];
	u_int8_t		inited_targets[16];

	/*
	 * SCBs that have been send to the controller
	 */
	LIST_HEAD(, scb)	 pending_scbs;

	/*
	 * Target mode related state kept on a per enabled lun basis.
	 * Targets that are not enabled will have null entries.
	 * As an initiator, we keep one target entry for our initiator
	 * ID to store our sync/wide transfer settings.
	 */
	struct tmode_tstate*	 enabled_targets[16];

	/*
	 * The black hole device responsible for handling requests for
	 * disabled luns on enabled targets.
	 */
	struct tmode_lstate*	 black_hole;

	/*
	 * Device instance currently on the bus awaiting a continue TIO
	 * for a command that was not given the disconnect priveledge.
	 */
	struct tmode_lstate*	 pending_device;

	/*
	 * Card characteristics
	 */
	ahc_chip		 chip;
	ahc_feature		 features;
	ahc_flag		 flags;

	/* Values to store in the SEQCTL register for pause and unpause */
	u_int8_t		 unpause;
	u_int8_t		 pause;

	/* Command Queues */
	u_int8_t		 qoutfifonext;
	u_int8_t		 qinfifonext;
	u_int8_t		*qoutfifo;
	u_int8_t		*qinfifo;

	/*
	 * 256 byte array storing the SCBID of outstanding
	 * untagged SCBs indexed by TCL.
	 */	
	u_int8_t		 *untagged_scbs;

	/*
	 * Hooks into the XPT.
	 */
d246 22
a267 47

	int			 unit;

	/* Channel Names ('A', 'B', etc.) */
	char			 channel;
	char			 channel_b;

	/* Initiator Bus ID */
	u_int8_t		 our_id;
	u_int8_t		 our_id_b;

	/* Targets that need negotiation messages */
	u_int16_t		 targ_msg_req;

	/*
	 * Target incoming command FIFO.
	 */
	struct target_cmd	*targetcmds;
	u_int8_t		 tqinfifonext;

	/*
	 * Incoming and outgoing message handling.
	 */
	u_int8_t		 send_msg_perror;
	ahc_msg_type		 msg_type;
	u_int8_t		 msgout_buf[8];	/* Message we are sending */
	u_int8_t		 msgin_buf[8];	/* Message we are receiving */
	u_int			 msgout_len;	/* Length of message to send */
	u_int			 msgout_index;	/* Current index in msgout */
	u_int			 msgin_index;	/* Current index in msgin */

	void			*ih;
	bus_dmamap_t		 shared_data_dmamap;
	bus_addr_t		 shared_data_busaddr;
	bus_dma_segment_t	 shared_data_seg;
	int			 shared_data_nseg;
	int			 shared_data_size;

	/* Number of enabled target mode device on this card */
	u_int			 enabled_luns;

	/* Initialization level of this data structure */
	u_int			 init_level;

	u_int16_t	 	 user_discenable;/* Disconnection allowed  */
	u_int16_t		 user_tagenable; /* Tagged Queuing allowed */

d283 8
d293 11
a303 7
void	ahc_construct __P((struct ahc_softc *ahc, bus_space_tag_t iot,
		bus_space_handle_t ioh, ahc_chip chip, ahc_flag flags, 
		ahc_feature features, u_char channel));
int   ahc_probe_scbs __P((struct ahc_softc *ahc));
void	ahc_free __P((struct ahc_softc *));
int	ahc_init __P((struct ahc_softc *));
int	ahc_attach __P((struct ahc_softc *));
d305 1
a305 21
int	ahc_reset __P((struct ahc_softc *ahc));
void  ahc_xxx_reset __P((char *devname, bus_space_tag_t iot, bus_space_handle_t ioh));
#define ahc_isa_reset ahc_xxx_reset
#define ahc_eisa_reset ahc_xxx_reset

#define	AHC_INB(ahc, port)	\
	bus_space_read_1((ahc)->sc_iot, (ahc)->sc_ioh, port)
#define	AHC_INSB(ahc, port, valp, size)	\
	bus_space_read_multi_1((ahc)->sc_iot, (ahc)->sc_ioh, port, (u_int8_t *) valp, size)
#define	AHC_OUTB(ahc, port, val)	\
	bus_space_write_1((ahc)->sc_iot, (ahc)->sc_ioh, port, val)
#define	AHC_OUTSB(ahc, port, valp, size)	\
	bus_space_write_multi_1((ahc)->sc_iot, (ahc)->sc_ioh, port, (u_int8_t *) valp, size)
#define	AHC_OUTSL(ahc, port, valp, size)	\
	bus_space_write_multi_4((ahc)->sc_iot, (ahc)->sc_ioh, port, (u_int32_t *) valp, size)

#define ahc_inb AHC_INB
#define ahc_insb AHC_INSB
#define ahc_outb AHC_OUTB
#define ahc_outsb AHC_OUTSB
#define ahc_outsl AHC_OUTSL
d307 1
a307 1
#endif  /* _AIC7XXXVAR_H_ */
@


1.10.14.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d34 1
a34 1
 * $OpenBSD: aic7xxxvar.h,v 1.13 2000/07/03 22:18:36 smurph Exp $
d40 8
a352 1
	u_int16_t		 tagdisable;	/* Tagged Queuing NOT allowed */
a505 3
#define AHC_NEG_PENDING		0x01
#define AHC_NEG_SDTRDONE	0x02
#define AHC_NEG_WDTRDONE	0x04
a506 1
	u_int8_t		inited_channels[2];
@


1.10.14.3
log
@Merge in -current from about a week ago
@
text
@d34 1
a34 1
 * $OpenBSD$
d493 1
a493 1
	int	(*pci_intr_func)(struct ahc_softc *);	/* for pci error interrupts  */
d622 1
a622 1
void	ahc_construct(struct ahc_softc *ahc, bus_space_tag_t iot,
d624 8
a631 8
		ahc_feature features, u_char channel);
int   ahc_probe_scbs(struct ahc_softc *ahc);
void	ahc_free(struct ahc_softc *);
int	ahc_init(struct ahc_softc *);
int	ahc_attach(struct ahc_softc *);
int	ahc_intr(void *arg);
int	ahc_reset(struct ahc_softc *ahc);
void  ahc_xxx_reset(char *devname, bus_space_tag_t iot, bus_space_handle_t ioh);
@


1.10.14.4
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a34 1
 * $OpenBSD: aic7xxxvar.h,v 1.10.14.3 2002/03/28 11:51:00 niklas Exp $
@


1.10.14.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a0 1
/*	$OpenBSD$	*/
d2 3
a4 1
 * Core definitions and data structures shareable across OS platforms.
d6 1
a6 2
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2001 Adaptec Inc.
d15 2
a16 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d19 1
a19 2
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
d21 5
a25 6
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d28 4
a31 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d33 2
a34 6
 * $Id$
 *
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx.h,v 1.44 2003/01/20 20:44:55 gibbs Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
d40 2
a41 41
#undef AHC_DEBUG

/* Register Definitions */
#include <dev/microcode/aic7xxx/aic7xxx_reg.h>

#include <dev/ic/aic7xxx_cam.h>

#define	AIC_OP_OR	0x0
#define	AIC_OP_AND	0x1
#define AIC_OP_XOR	0x2
#define	AIC_OP_ADD	0x3
#define	AIC_OP_ADC	0x4
#define	AIC_OP_ROL	0x5
#define	AIC_OP_BMOV	0x6

#define	AIC_OP_JMP	0x8
#define AIC_OP_JC	0x9
#define AIC_OP_JNC	0xa
#define AIC_OP_CALL	0xb
#define	AIC_OP_JNE	0xc
#define	AIC_OP_JNZ	0xd
#define	AIC_OP_JE	0xe
#define	AIC_OP_JZ	0xf

/* Pseudo Ops */
#define	AIC_OP_SHL	0x10
#define	AIC_OP_SHR	0x20
#define	AIC_OP_ROR	0x30

/************************* Forward Declarations *******************************/
struct ahc_platform_data;
struct scb_platform_data;
struct seeprom_descriptor;

/****************************** Useful Macros *********************************/
#ifndef MAX
#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
a46 52
#ifndef FALSE
#define FALSE 0
#endif

#define NUM_ELEMENTS(array) (sizeof(array) / sizeof(*array))

#define ALL_CHANNELS '\0'
#define ALL_TARGETS_MASK 0xFFFF
#define INITIATOR_WILDCARD	(~0)

#define SCSIID_TARGET(ahc, scsiid) \
	(((scsiid) & ((((ahc)->features & AHC_TWIN) != 0) ? TWIN_TID : TID)) \
	>> TID_SHIFT)
#define SCSIID_OUR_ID(scsiid) \
	((scsiid) & OID)
#define SCSIID_CHANNEL(ahc, scsiid) \
	((((ahc)->features & AHC_TWIN) != 0) \
        ? ((((scsiid) & TWIN_CHNLB) != 0) ? 'B' : 'A') \
       : 'A')
#define	SCB_IS_SCSIBUS_B(ahc, scb) \
	(SCSIID_CHANNEL(ahc, (scb)->hscb->scsiid) == 'B')
#define	SCB_GET_OUR_ID(scb) \
	SCSIID_OUR_ID((scb)->hscb->scsiid)
#define	SCB_GET_TARGET(ahc, scb) \
	SCSIID_TARGET((ahc), (scb)->hscb->scsiid)
#define	SCB_GET_CHANNEL(ahc, scb) \
	SCSIID_CHANNEL(ahc, (scb)->hscb->scsiid)
#define	SCB_GET_LUN(scb) \
	((scb)->hscb->lun)
#define SCB_GET_TARGET_OFFSET(ahc, scb)	\
	(SCB_GET_TARGET(ahc, scb))
#define SCB_GET_TARGET_MASK(ahc, scb) \
	(0x01 << (SCB_GET_TARGET_OFFSET(ahc, scb)))
#ifdef AHC_DEBUG
#define SCB_IS_SILENT(scb)					\
	((ahc_debug & AHC_SHOW_MASKED_ERRORS) == 0		\
      && (((scb)->flags & SCB_SILENT) != 0))
#else
#define SCB_IS_SILENT(scb)					\
	(((scb)->flags & SCB_SILENT) != 0)
#endif
#define TCL_TARGET_OFFSET(tcl) \
	((((tcl) >> 4) & TID) >> 4)
#define TCL_LUN(tcl) \
	(tcl & (AHC_NUM_LUNS - 1))
#define BUILD_TCL(scsiid, lun) \
	((lun) | (((scsiid) & TID) << 4))

#ifndef	AHC_TARGET_MODE
#undef	AHC_TMODE_ENABLE
#define	AHC_TMODE_ENABLE 0
#endif
a47 1
/**************************** Driver Constants ********************************/
d49 1
a49 1
 * The maximum number of supported targets.
d51 9
a59 9
#define AHC_NUM_TARGETS 16

/*
 * The maximum number of supported luns.
 * The identify message only supports 64 luns in SPI3.
 * You can have 2^64 luns when information unit transfers are enabled,
 * but it is doubtful this driver will ever support IUTs.
 */
#define AHC_NUM_LUNS 64
a62 1
 * Limited by MAXPHYS or a 24-bit counter.
d64 1
a64 1
#define AHC_MAXTRANSFER_SIZE	 MIN(MAXPHYS,0x00ffffff)
d67 17
a83 5
 * The maximum amount of SCB storage in hardware on a controller.
 * This value represents an upper bound.  Controllers vary in the number
 * they actually support.
 */
#define AHC_SCB_MAX	255
d85 6
a90 19
/*
 * The maximum number of concurrent transactions supported per driver instance.
 * Sequencer Control Blocks (SCBs) store per-transaction information.  Although
 * the space for SCBs on the host adapter varies by model, the driver will
 * page the SCBs between host and controller memory as needed.  We are limited
 * to 253 because:
 * 	1) The 8bit nature of the RISC engine holds us to an 8bit value.
 * 	2) We reserve one value, 255, to represent the invalid element.
 *	3) Our input queue scheme requires one SCB to always be reserved
 *	   in advance of queuing any SCBs.  This takes us down to 254.
 *	4) To handle our output queue correctly on machines that only
 * 	   support 32bit stores, we must clear the array 4 bytes at a
 *	   time.  To avoid colliding with a DMA write from the sequencer,
 *	   we must be sure that 4 slots are empty when we write to clear
 *	   the queue.  This reduces us to 253 SCBs: 1 that just completed
 *	   and the known three additional empty slots in the queue that
 *	   precede it.
 */
#define AHC_MAX_QUEUE	253
d92 4
a95 16
/*
 * The maximum amount of SCB storage we allocate in host memory.  This
 * number should reflect the 1 additional SCB we require to handle our
 * qinfifo mechanism.
 */
#define AHC_SCB_MAX_ALLOC (AHC_MAX_QUEUE+1)

/*
 * Ring Buffer of incoming target commands.
 * We allocate 256 to simplify the logic in the sequencer
 * by using the natural wrap point of an 8bit counter.
 */
#define AHC_TMODE_CMDS	256

/* Reset line assertion time in us */
#define AHC_BUSRESET_DELAY	25
a96 5
/******************* Chip Characteristics/Operating Settings  *****************/
/*
 * Chip Type
 * The chip order is from least sophisticated to most sophisticated.
 */
d107 3
a109 3
	AHC_AIC7895	= 0x0008,
	AHC_AIC7895C	= 0x0009,
	AHC_AIC7890	= 0x000a,
d111 1
a111 2
	AHC_AIC7892	= 0x000c,
	AHC_AIC7899	= 0x000d,
d118 2
a119 3
/*
 * Features available in each chip type.
 */
d121 29
a149 49
	AHC_FENONE	= 0x00000,
	AHC_ULTRA	= 0x00001,	/* Supports 20MHz Transfers */
	AHC_ULTRA2	= 0x00002,	/* Supports 40MHz Transfers */
	AHC_WIDE  	= 0x00004,	/* Wide Channel */
	AHC_TWIN	= 0x00008,	/* Twin Channel */
	AHC_MORE_SRAM	= 0x00010,	/* 80 bytes instead of 64 */
	AHC_CMD_CHAN	= 0x00020,	/* Has a Command DMA Channel */
	AHC_QUEUE_REGS	= 0x00040,	/* Has Queue management registers */
	AHC_SG_PRELOAD	= 0x00080,	/* Can perform auto-SG preload */
	AHC_SPIOCAP	= 0x00100,	/* Has a Serial Port I/O Cap Register */
	AHC_MULTI_TID	= 0x00200,	/* Has bitmask of TIDs for select-in */
	AHC_HS_MAILBOX	= 0x00400,	/* Has HS_MAILBOX register */
	AHC_DT		= 0x00800,	/* Double Transition transfers */
	AHC_NEW_TERMCTL	= 0x01000,	/* Newer termination scheme */
	AHC_MULTI_FUNC	= 0x02000,	/* Multi-Function Twin Channel Device */
	AHC_LARGE_SCBS	= 0x04000,	/* 64byte SCBs */
	AHC_AUTORATE	= 0x08000,	/* Automatic update of SCSIRATE/OFFSET*/
	AHC_AUTOPAUSE	= 0x10000,	/* Automatic pause on register access */
	AHC_TARGETMODE	= 0x20000,	/* Has tested target mode support */
	AHC_MULTIROLE	= 0x40000,	/* Space for two roles at a time */
	AHC_REMOVABLE	= 0x80000,	/* Hot-Swap supported */
	AHC_AIC7770_FE	= AHC_FENONE,
	/*
	 * The real 7850 does not support Ultra modes, but there are
	 * several cards that use the generic 7850 PCI ID even though
	 * they are using an Ultra capable chip (7859/7860).  We start
	 * out with the AHC_ULTRA feature set and then check the DEVSTATUS
	 * register to determine if the capability is really present.
	 */
	AHC_AIC7850_FE	= AHC_SPIOCAP|AHC_AUTOPAUSE|AHC_TARGETMODE|AHC_ULTRA,
	AHC_AIC7860_FE	= AHC_AIC7850_FE,
	AHC_AIC7870_FE	= AHC_TARGETMODE,
	AHC_AIC7880_FE	= AHC_AIC7870_FE|AHC_ULTRA,
	/*
	 * Although we have space for both the initiator and
	 * target roles on ULTRA2 chips, we currently disable
	 * the initiator role to allow multi-scsi-id target mode
	 * configurations.  We can only respond on the same SCSI
	 * ID as our initiator role if we allow initiator operation.
	 * At some point, we should add a configuration knob to
	 * allow both roles to be loaded.
	 */
	AHC_AIC7890_FE	= AHC_MORE_SRAM|AHC_CMD_CHAN|AHC_ULTRA2
			  |AHC_QUEUE_REGS|AHC_SG_PRELOAD|AHC_MULTI_TID
			  |AHC_HS_MAILBOX|AHC_NEW_TERMCTL|AHC_LARGE_SCBS
			  |AHC_TARGETMODE,
	AHC_AIC7892_FE	= AHC_AIC7890_FE|AHC_DT|AHC_AUTORATE|AHC_AUTOPAUSE,
	AHC_AIC7895_FE	= AHC_AIC7880_FE|AHC_MORE_SRAM|AHC_AUTOPAUSE
			  |AHC_CMD_CHAN|AHC_MULTI_FUNC|AHC_LARGE_SCBS,
a154 50
/*
 * Bugs in the silicon that we work around in software.
 */
typedef enum {
	AHC_BUGNONE		= 0x00,
	/*
	 * On all chips prior to the U2 product line,
	 * the WIDEODD S/G segment feature does not
	 * work during scsi->HostBus transfers.
	 */
	AHC_TMODE_WIDEODD_BUG	= 0x01,
	/*
	 * On the aic7890/91 Rev 0 chips, the autoflush
	 * feature does not work.  A manual flush of
	 * the DMA FIFO is required.
	 */
	AHC_AUTOFLUSH_BUG	= 0x02,
	/*
	 * On many chips, cacheline streaming does not work.
	 */
	AHC_CACHETHEN_BUG	= 0x04,
	/*
	 * On the aic7896/97 chips, cacheline
	 * streaming must be enabled.
	 */
	AHC_CACHETHEN_DIS_BUG	= 0x08,
	/*
	 * PCI 2.1 Retry failure on non-empty data fifo.
	 */
	AHC_PCI_2_1_RETRY_BUG	= 0x10,
	/*
	 * Controller does not handle cacheline residuals
	 * properly on S/G segments if PCI MWI instructions
	 * are allowed.
	 */
	AHC_PCI_MWI_BUG		= 0x20,
	/*
	 * An SCB upload using the SCB channel's
	 * auto array entry copy feature may 
	 * corrupt data.  This appears to only
	 * occur on 66MHz systems.
	 */
	AHC_SCBCHAN_UPLOAD_BUG	= 0x40
} ahc_bug;

/*
 * Configuration specific settings.
 * The driver determines these settings by probing the
 * chip/controller's configuration.
 */
d156 6
a161 4
	AHC_FNONE	      = 0x000,
	AHC_PRIMARY_CHANNEL   = 0x003,  /*
					 * The channel that should
					 * be probed first.
d163 1
a163 1
	AHC_USEDEFAULTS	      = 0x004,  /*
d169 9
a177 10
	AHC_SEQUENCER_DEBUG   = 0x008,
	AHC_SHARED_SRAM	      = 0x010,
	AHC_LARGE_SEEPROM     = 0x020,  /* Uses C56_66 not C46 */
	AHC_RESET_BUS_A	      = 0x040,
	AHC_RESET_BUS_B	      = 0x080,
	AHC_EXTENDED_TRANS_A  = 0x100,
	AHC_EXTENDED_TRANS_B  = 0x200,
	AHC_TERM_ENB_A	      = 0x400,
	AHC_TERM_ENB_B	      = 0x800,
	AHC_INITIATORROLE     = 0x1000,  /*
d181 1
a181 1
	AHC_TARGETROLE	      = 0x2000,  /*
d185 4
a188 4
	AHC_NEWEEPROM_FMT     = 0x4000,
	AHC_RESOURCE_SHORTAGE = 0x8000,
	AHC_TQINFIFO_BLOCKED  = 0x10000,  /* Blocked waiting for ATIOs */
	AHC_INT50_SPEEDFLEX   = 0x20000,  /*
a191 14
	AHC_SCB_BTT	      = 0x40000,  /*
					   * The busy targets table is
					   * stored in SCB space rather
					   * than SRAM.
					   */
	AHC_BIOS_ENABLED      = 0x80000,
	AHC_ALL_INTERRUPTS    = 0x100000,
	AHC_PAGESCBS	      = 0x400000,  /* Enable SCB paging */
	AHC_EDGE_INTERRUPT    = 0x800000,  /* Device uses edge triggered ints */
	AHC_39BIT_ADDRESSING  = 0x1000000, /* Use 39 bit addressing scheme. */
	AHC_LSCBS_ENABLED     = 0x2000000, /* 64Byte SCBs enabled */
	AHC_SCB_CONFIG_USED   = 0x4000000, /* No SEEPROM but SCB2 had info. */
	AHC_NO_BIOS_INIT      = 0x8000000, /* No BIOS left over settings. */
	AHC_DISABLE_PCI_PERR  = 0x10000000
d194 20
a213 1
/************************* Hardware  SCB Definition ***************************/
d217 1
a217 1
 * consists of a "hardware SCB" mirroring the fields available on the card
a218 17
 *
 * To minimize space utilization, a portion of the hardware scb stores
 * different data during different portions of a SCSI transaction.
 * As initialized by the host driver for the initiator role, this area
 * contains the SCSI cdb (or a pointer to the  cdb) to be executed.  After
 * the cdb has been presented to the target, this area serves to store
 * residual transfer information and the SCSI status byte.
 * For the target role, the contents of this area do not change, but
 * still serve a different purpose than for the initiator role.  See
 * struct target_data for details.
 */

/*
 * Status information embedded in the shared portion of
 * an SCB after passing the cdb to the target.  The kernel
 * driver will only read this data for transactions that
 * complete abnormally (non-zero status byte).
a219 18
struct status_pkt {
	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
	uint32_t residual_sg_ptr;	/* The next S/G for this transfer */
	uint8_t	 scsi_status;		/* Standard SCSI status byte */
};

/*
 * Target mode version of the shared data SCB segment.
 */
struct target_data {
	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
	uint32_t residual_sg_ptr;	/* The next S/G for this transfer */
	uint8_t  scsi_status;		/* SCSI status to give to initiator */
	uint8_t  target_phases;		/* Bitmap of phases to execute */
	uint8_t  data_phase;		/* Data-In or Data-Out */
	uint8_t  initiator_tag;		/* Initiator's transaction tag */
};

d221 11
a231 54
/*0*/	union {
		/*
		 * If the cdb is 12 bytes or less, we embed it directly
		 * in the SCB.  For longer cdbs, we embed the address
		 * of the cdb payload as seen by the chip and a DMA
		 * is used to pull it in.
		 */
		uint8_t	 cdb[12];
		uint32_t cdb_ptr;
		struct	 status_pkt status;
		struct	 target_data tdata;
	} shared_data;
/*
 * A word about residuals.
 * The scb is presented to the sequencer with the dataptr and datacnt
 * fields initialized to the contents of the first S/G element to
 * transfer.  The sgptr field is initialized to the bus address for
 * the S/G element that follows the first in the in core S/G array
 * or'ed with the SG_FULL_RESID flag.  Sgptr may point to an invalid
 * S/G entry for this transfer (single S/G element transfer with the
 * first elements address and length preloaded in the dataptr/datacnt
 * fields).  If no transfer is to occur, sgptr is set to SG_LIST_NULL.
 * The SG_FULL_RESID flag ensures that the residual will be correctly
 * noted even if no data transfers occur.  Once the data phase is entered,
 * the residual sgptr and datacnt are loaded from the sgptr and the
 * datacnt fields.  After each S/G element's dataptr and length are
 * loaded into the hardware, the residual sgptr is advanced.  After
 * each S/G element is expired, its datacnt field is checked to see
 * if the LAST_SEG flag is set.  If so, SG_LIST_NULL is set in the
 * residual sg ptr and the transfer is considered complete.  If the
 * sequencer determines that there is a residual in the transfer, it
 * will set the SG_RESID_VALID flag in sgptr and DMA the scb back into
 * host memory.  To summarize:
 *
 * Sequencer:
 *	o A residual has occurred if SG_FULL_RESID is set in sgptr,
 *	  or residual_sgptr does not have SG_LIST_NULL set.
 *
 *	o We are transfering the last segment if residual_datacnt has
 *	  the SG_LAST_SEG flag set.
 *
 * Host:
 *	o A residual has occurred if a completed scb has the
 *	  SG_RESID_VALID flag set.
 *
 *	o residual_sgptr and sgptr refer to the "next" sg entry
 *	  and so may point beyond the last valid sg entry for the
 *	  transfer.
 */ 
/*12*/	uint32_t dataptr;
/*16*/	uint32_t datacnt;		/*
					 * Byte 3 (numbered from 0) of
					 * the datacnt is really the
					 * 4th byte in that data address.
d233 3
a235 7
/*20*/	uint32_t sgptr;
#define SG_PTR_MASK	0xFFFFFFF8
/*24*/	uint8_t  control;	/* See SCB_CONTROL in aic7xxx.reg for details */
/*25*/	uint8_t  scsiid;	/* what to load in the SCSIID register */
/*26*/	uint8_t  lun;
/*27*/	uint8_t  tag;			/*
					 * Index into our kernel SCB array.
d238 1
a238 5
/*28*/	uint8_t  cdb_len;
/*29*/	uint8_t  scsirate;		/* Value for SCSIRATE register */
/*30*/	uint8_t  scsioffset;		/* Value for SCSIOFFSET register */
/*31*/	uint8_t  next;			/*
					 * Used for threading SCBs in the
d243 5
a247 8
/*32*/	uint8_t  cdb32[32];		/*
					 * CDB storage for cdbs of size
					 * 13->32.  We store them here
					 * because hardware scbs are
					 * allocated from DMA safe
					 * memory so we are guaranteed
					 * the controller can access
					 * this data.
d249 3
a251 111
};

/************************ Kernel SCB Definitions ******************************/
/*
 * Some fields of the SCB are OS dependent.  Here we collect the
 * definitions for elements that all OS platforms need to include
 * in there SCB definition.
 */

/*
 * Definition of a scatter/gather element as transferred to the controller.
 * The aic7xxx chips only support a 24bit length.  We use the top byte of
 * the length to store additional address bits and a flag to indicate
 * that a given segment terminates the transfer.  This gives us an
 * addressable range of 512GB on machines with 64bit PCI or with chips
 * that can support dual address cycles on 32bit PCI busses.
 */
struct ahc_dma_seg {
	uint32_t	addr;
	uint32_t	len;
#define	AHC_DMA_LAST_SEG	0x80000000
#define	AHC_SG_HIGH_ADDR_MASK	0x7F000000
#define	AHC_SG_LEN_MASK		0x00FFFFFF
};

struct sg_map_node {
	bus_dmamap_t		 sg_dmamap;
	bus_addr_t		 sg_physaddr;
	bus_dma_segment_t	 sg_dmasegs;
	int			 sg_nseg;
	struct ahc_dma_seg*	 sg_vaddr;
	SLIST_ENTRY(sg_map_node) links;
};

struct ahc_pci_busdata {
	pci_chipset_tag_t pc;
	pcitag_t tag;
	u_int dev;
	u_int func;
	pcireg_t class;
};

/*
 * The current state of this SCB.
 */
typedef enum {
	SCB_FREE		= 0x0000,
	SCB_REQUEUE		= 0x0001,
	SCB_OTHERTCL_TIMEOUT	= 0x0002,/*
					  * Another device was active
					  * during the first timeout for
					  * this SCB so we gave ourselves
					  * an additional timeout period
					  * in case it was hogging the
					  * bus.
				          */
	SCB_DEVICE_RESET	= 0x0004,
	SCB_SENSE		= 0x0008,
	SCB_CDB32_PTR		= 0x0010,
	SCB_RECOVERY_SCB	= 0x0020,
	SCB_AUTO_NEGOTIATE	= 0x0040,/* Negotiate to achieve goal. */
	SCB_NEGOTIATE		= 0x0080,/* Negotiation forced for command. */
	SCB_ABORT		= 0x0100,
	SCB_UNTAGGEDQ		= 0x0200,
	SCB_ACTIVE		= 0x0400,
	SCB_TARGET_IMMEDIATE	= 0x0800,
	SCB_TRANSMISSION_ERROR	= 0x1000,/*
					  * We detected a parity or CRC
					  * error that has effected the
					  * payload of the command.  This
					  * flag is checked when normal
					  * status is returned to catch
					  * the case of a target not
					  * responding to our attempt
					  * to report the error.
					  */
	SCB_TARGET_SCB		= 0x2000,
	SCB_SILENT		= 0x4000,/*
					  * Be quiet about transmission type
					  * errors.  They are expected and we
					  * don't want to upset the user.  This
					  * flag is typically used during DV.
					  */
	SCB_FREEZE_QUEUE	= 0x8000
} scb_flag;

struct scb {
	struct	hardware_scb	 *hscb;
	union {
		SLIST_ENTRY(scb)  sle;
		TAILQ_ENTRY(scb)  tqe;
	} links;
	LIST_ENTRY(scb)		  pending_links;

	struct scsipi_xfer	 *xs;
	struct ahc_softc	 *ahc_softc;
	scb_flag		  flags;
#ifndef __linux__
	bus_dmamap_t		  dmamap;
#endif
	struct scb_platform_data *platform_data;
	struct sg_map_node	 *sg_map;
	struct ahc_dma_seg 	 *sg_list;
	bus_addr_t		  sg_list_phys;
	u_int			  sg_count;/* How full ahc_dma_seg is */
};

struct scb_data {
	SLIST_HEAD(, scb) free_scbs;	/*
					 * Pool of SCBs ready to be assigned
					 * commands to execute.
d253 3
a255 8
	struct	scb *scbindex[256];	/*
					 * Mapping from tag to SCB.
					 * As tag identifiers are an
					 * 8bit value, we provide space
					 * for all possible tag values.
					 * Any lookups to entries at or
					 * above AHC_SCB_MAX_ALLOC will
					 * always fail.
d257 2
a258 25
	struct	hardware_scb	*hscbs;	/* Array of hardware SCBs */
	struct	scb *scbarray;		/* Array of kernel SCBs */
	struct	scsipi_sense_data *sense; /* Per SCB sense data */

	/*
	 * "Bus" addresses of our data structures.
	 */
	bus_dmamap_t	 hscb_dmamap;
	bus_addr_t	 hscb_busaddr;
	bus_dma_segment_t hscb_seg;
	int		  hscb_nseg;
	int		  hscb_size;

	bus_dmamap_t	 sense_dmamap;
	bus_addr_t	 sense_busaddr;
	bus_dma_segment_t sense_seg;
	int		  sense_nseg;
	int		  sense_size;

	SLIST_HEAD(, sg_map_node) sg_maps;
	uint8_t	numscbs;
	uint8_t	maxhscbs;		/* Number of SCBs on the card */
	uint8_t	init_level;		/*
					 * How far we've initialized
					 * this structure.
d262 11
a272 1
/************************ Target Mode Definitions *****************************/
d276 5
d283 6
a288 19
	uint8_t scsiid;		/* Our ID and the initiator's ID */
	uint8_t identify;	/* Identify message */
	uint8_t bytes[22];	/* 
				 * Bytes contains any additional message
				 * bytes terminated by 0xFF.  The remainder
				 * is the cdb to execute.
				 */
	uint8_t cmd_valid;	/*
				 * When a command is complete, the firmware
				 * will set cmd_valid to all bits set.
				 * After the host has seen the command,
				 * the bits are cleared.  This allows us
				 * to just peek at host memory to determine
				 * if more work is complete. cmd_valid is on
				 * an 8 byte boundary to simplify setting
				 * it on aic7880 hardware which only has
				 * limited direct access to the DMA FIFO.
				 */
	uint8_t pad[7];
d297 2
a298 2
	uint8_t initiator_id;
	uint8_t event_type;	/* MSG type or EVENT_TYPE_BUS_RESET */
d300 1
a300 1
	uint8_t event_arg;
d304 2
a305 5
 * Per enabled lun target mode state.
 * As this state is directly influenced by the host OS'es target mode
 * environment, we let the OS module define it.  Forward declare the
 * structure here so we can store arrays of them, etc. in OS neutral
 * data structures.
d307 2
a308 10
#ifdef AHC_TARGET_MODE 
struct ahc_tmode_lstate {
#if 0
	struct cam_path *path;
	struct ccb_hdr_slist accept_tios;
	struct ccb_hdr_slist immed_notifies;
#endif
	struct ahc_tmode_event event_buffer[AHC_TMODE_EVENT_BUFFER_SIZE];
	uint8_t event_r_idx;
	uint8_t event_w_idx;
a309 3
#else
struct ahc_tmode_lstate;
#endif
d311 2
a312 3
/******************** Transfer Negotiation Datastructures *********************/
#define AHC_TRANS_CUR		0x01	/* Modify current negotiation status */
#define AHC_TRANS_ACTIVE	0x03	/* Assume this target is on the bus */
a315 8
#define AHC_WIDTH_UNKNOWN	0xFF
#define AHC_PERIOD_UNKNOWN	0xFF
#define AHC_OFFSET_UNKNOWN	0x0
#define AHC_PPR_OPTS_UNKNOWN	0xFF

/*
 * Transfer Negotiation Information.
 */
d317 4
a320 6
	uint8_t protocol_version;	/* SCSI Revision level */
	uint8_t transport_version;	/* SPI Revision level */
	uint8_t width;			/* Bus width */
	uint8_t period;			/* Sync rate factor */
	uint8_t offset;			/* Sync offset */
	uint8_t ppr_options;		/* Parallel Protocol Request options */
a322 2
/*
 * Per-initiator current, goal and user transfer negotiation information. */
d324 2
a325 2
	uint8_t scsirate;		/* Computed value for SCSIRATE reg */
	struct ahc_transinfo curr;
d331 4
a334 5
 * Per enabled target ID state.
 * Pointers to lun target state as well as sync/wide negotiation information
 * for each initiator<->target mapping.  For the initiator role we pretend
 * that we are the target and the targets are the initiators since the
 * negotiation is the same regardless of role.
d336 2
a337 3
struct ahc_tmode_tstate {
	struct ahc_tmode_lstate*	enabled_luns[AHC_NUM_LUNS];
	struct ahc_initiator_tinfo	transinfo[AHC_NUM_TARGETS];
d342 4
a345 17
	uint16_t	 auto_negotiate;/* Auto Negotiation Required */
	uint16_t	 ultraenb;	/* Using ultra sync rate  */
	uint16_t	 discenable;	/* Disconnection allowed  */
	uint16_t	 tagenable;	/* Tagged Queuing allowed */
};

/*
 * Data structure for our table of allowed synchronous transfer rates.
 */
struct ahc_syncrate {
	u_int sxfr_u2;	/* Value of the SXFR parameter for Ultra2+ Chips */
	u_int sxfr;	/* Value of the SXFR parameter for <= Ultra Chips */
#define		ULTRA_SXFR 0x100	/* Rate Requires Ultra Mode set */
#define		ST_SXFR	   0x010	/* Rate Single Transition Only */
#define		DT_SXFR	   0x040	/* Rate Double Transition Only */
	uint8_t period; /* Period to send to SCSI target */
	char *rate;
d348 2
a349 3
/* Safe and valid period for async negotiations. */
#define	AHC_ASYNC_XFER_PERIOD 0x45
#define	AHC_ULTRA2_XFER_PERIOD 0x0a
d352 1
a352 1
 * Indexes into our table of syncronous transfer rates.
a353 19
#define AHC_SYNCRATE_DT		0
#define AHC_SYNCRATE_ULTRA2	1
#define AHC_SYNCRATE_ULTRA	3
#define AHC_SYNCRATE_FAST	6
#define AHC_SYNCRATE_MAX	AHC_SYNCRATE_DT
#define	AHC_SYNCRATE_MIN	13

/***************************** Lookup Tables **********************************/
/*
 * Phase -> name and message out response
 * to parity errors in each phase table. 
 */
struct ahc_phase_table_entry {
        uint8_t phase;
        uint8_t mesg_out; /* Message response to parity errors */
	char *phasemsg;
};

/************************** Serial EEPROM Format ******************************/
d357 1
a357 1
 * Per SCSI ID Configuration Flags
d359 1
a359 1
	uint16_t device_flags[16];	/* words 0-15 */
d369 1
a369 1
#define		CFMULTILUNDEV	0x0800	/* Probe multiple luns in BIOS scan */
d376 1
a376 1
	uint16_t bios_control;		/* word 16 */
d380 1
a380 1
#define		CFBIOS_BUSSCAN	0x0008	/* Have the BIOS Scan the Bus */
a381 1
#define		CFSTPWLEVEL	0x0010	/* Termination level control */
d383 1
a383 2
#define		CFCTRL_A	0x0020	/* BIOS displays Ctrl-A message */	
#define		CFTERM_MENU	0x0040	/* BIOS displays termination menu */	
a384 6
#define		CFSCAMEN	0x0100	/* SCAM enable */
#define		CFMSG_LEVEL	0x0600	/* BIOS Message Level */
#define			CFMSG_VERBOSE	0x0000
#define			CFMSG_SILENT	0x0200
#define			CFMSG_DIAG	0x0400
#define		CFBOOTCD	0x0800  /* Support Bootable CD-ROM */
d390 1
a390 1
	uint16_t adapter_control;	/* word 17 */	
a398 1
#define		CFMULTILUN	0x0020
d400 4
a403 7
#define		CFCLUSTERENB	0x0080	/* Cluster Enable */
#define		CFBOOTCHAN	0x0300	/* probe this channel first */
#define		CFBOOTCHANSHIFT 8
#define		CFSEAUTOTERM	0x0400	/* Ultra2 Perform secondary Auto Term*/
#define		CFSELOWTERM	0x0800	/* Ultra2 secondary low term */
#define		CFSEHIGHTERM	0x1000	/* Ultra2 secondary high term */
#define		CFENABLEDV	0x4000	/* Perform Domain Validation*/
d406 1
a406 1
 * Bus Release Time, Host Adapter ID
d408 1
a408 1
	uint16_t brtime_id;		/* word 18 */
d416 1
a416 1
	uint16_t max_targets;		/* word 19 */	
d418 13
a430 7
#define		CFBOOTLUN	0x0f00	/* Lun to boot from */
#define		CFBOOTID	0xf000	/* Target to boot from */
	uint16_t res_1[10];		/* words 20-29 */
	uint16_t signature;		/* Signature == 0x250 */
#define		CFSIGNATURE	0x250
#define		CFSIGNATURE2	0x300
	uint16_t checksum;		/* word 31 */
a432 1
/****************************  Message Buffer *********************************/
d441 7
a447 17
typedef enum {
	MSGLOOP_IN_PROG,
	MSGLOOP_MSGCOMPLETE,
	MSGLOOP_TERMINATED
} msg_loop_stat;

/*********************** Software Configuration Structure *********************/
TAILQ_HEAD(scb_tailq, scb);

struct ahc_suspend_channel_state {
	uint8_t	scsiseq;
	uint8_t	sxfrctl0;
	uint8_t	sxfrctl1;
	uint8_t	simode0;
	uint8_t	simode1;
	uint8_t	seltimer;
	uint8_t	seqctl;
d449 9
a457 36

struct ahc_suspend_state {
	struct	ahc_suspend_channel_state channel[2];
	uint8_t	optionmode;
	uint8_t	dscommand0;
	uint8_t	dspcistatus;
	/* hsmailbox */
	uint8_t	crccontrol1;
	uint8_t	scbbaddr;
	/* Host and sequencer SCB counts */
	uint8_t	dff_thrsh;
	uint8_t	*scratch_ram;
	uint8_t	*btt;
};

typedef void (*ahc_bus_intr_t)(struct ahc_softc *);
typedef void ahc_callback_t (void *);

struct ahc_softc {
	struct device 		  sc_dev; 

	struct scsipi_channel	  sc_channel;
	struct scsipi_channel 	  sc_channel_b;
	struct device *		  sc_child;
	struct device *		  sc_child_b;
	struct scsipi_adapter	  sc_adapter;

	bus_space_tag_t           tag;
	bus_space_handle_t        bsh;

#ifndef __linux__
	bus_dma_tag_t		  buffer_dmat;   /* dmat for buffer I/O */
#endif
	struct scb_data		 *scb_data;

	struct scb		 *next_queued_scb;
d460 1
a460 1
	 * SCBs that have been sent to the controller
d462 5
a466 1
	LIST_HEAD(, scb)	  pending_scbs;
d468 5
a472 7
	/*
	 * Counting lock for deferring the release of additional
	 * untagged transactions from the untagged_queues.  When
	 * the lock is decremented to 0, all queues in the
	 * untagged_queues array are run.
	 */
	u_int			  untagged_queue_lock;
d474 8
a481 8
	/*
	 * Per-target queue of untagged-transactions.  The
	 * transaction at the head of the queue is the
	 * currently pending untagged transaction for the
	 * target.  The driver only allows a single untagged
	 * transaction per target.
	 */
	struct scb_tailq	  untagged_queues[AHC_NUM_TARGETS];
d483 21
a503 4
	/*
	 * Platform specific data.
	 */
	struct ahc_platform_data *platform_data;
d506 1
a506 1
	 * Platform specific device information.
d508 1
a508 6
	ahc_dev_softc_t		  dev_softc;

	/*
	 * Bus specific device information.
	 */
	ahc_bus_intr_t		  bus_intr;
d516 1
a516 3
	struct ahc_tmode_tstate  *enabled_targets[AHC_NUM_TARGETS];

	char inited_target[AHC_NUM_TARGETS];
d522 1
a522 1
	struct ahc_tmode_lstate  *black_hole;
d526 1
a526 1
	 * for a command that was not given the disconnect priviledge.
d528 1
a528 1
	struct ahc_tmode_lstate  *pending_device;
d533 3
a535 5
	ahc_chip		  chip;
	ahc_feature		  features;
	ahc_bug			  bugs;
	ahc_flag		  flags;
	struct seeprom_config	 *seep_config;
d538 2
a539 2
	uint8_t			  unpause;
	uint8_t			  pause;
d542 4
a545 8
	uint8_t			  qoutfifonext;
	uint8_t			  qinfifonext;
	uint8_t			 *qoutfifo;
	uint8_t			 *qinfifo;

	/* Critical Section Data */
	struct cs		 *critical_sections;
	u_int			  num_critical_sections;
d547 13
a559 2
	/* Links for chaining softcs */
	TAILQ_ENTRY(ahc_softc)	  links;
d562 2
a563 1
	char			  channel;
d566 2
a567 2
	uint8_t			  our_id;
	uint8_t			  our_id_b;
d569 2
a570 4
	/*
	 * PCI error detection.
	 */
	int			  unsolicited_ints;
d575 2
a576 2
	struct target_cmd	 *targetcmds;
	uint8_t			  tqinfifonext;
d581 14
a594 33
	uint8_t			  send_msg_perror;
	ahc_msg_type		  msg_type;
	uint8_t			  msgout_buf[12];/* Message we are sending */
	uint8_t			  msgin_buf[12];/* Message we are receiving */
	u_int			  msgout_len;	/* Length of message to send */
	u_int			  msgout_index;	/* Current index in msgout */
	u_int			  msgin_index;	/* Current index in msgin */

	/* Interrupt routine */
	void 			 *ih;

	/*
	 * Mapping information for data structures shared
	 * between the sequencer and kernel.
	 */
	bus_dma_tag_t		  parent_dmat;
	bus_dmamap_t		  shared_data_dmamap;
	bus_addr_t		  shared_data_busaddr;

	bus_dma_segment_t	  shared_data_seg;
	int			  shared_data_nseg;
	int			  shared_data_size;
	int			  sc_dmaflags;

	/*
	 * Bus address of the one byte buffer used to
	 * work-around a DMA bug for chips <= aic7880
	 * in target mode.
	 */
	bus_addr_t		  dma_bug_buf;

	/* Information saved through suspend/resume cycles */
	struct ahc_suspend_state  suspend_state;
d597 1
a597 1
	u_int			  enabled_luns;
d600 1
a600 45
	u_int			  init_level;

	/* PCI cacheline size. */
	u_int			  pci_cachesize;

	u_int			  stack_size;

	/* Per-Unit descriptive information */
	char			 *name;
	int			  unit;

	/* Selection Timer settings */
	int			  seltime;
	int			  seltime_b;

	uint16_t	 	  user_discenable;/* Disconnection allowed  */
	uint16_t		  user_tagenable;/* Tagged Queuing allowed */

	struct ahc_pci_busdata 	  *bd;

	void			  *shutdown_hook;
};

TAILQ_HEAD(ahc_softc_tailq, ahc_softc);
extern struct ahc_softc_tailq ahc_tailq;

/************************ Active Device Information ***************************/
typedef enum {
	ROLE_UNKNOWN,
	ROLE_INITIATOR,
	ROLE_TARGET
} role_t;

struct ahc_devinfo {
	int	 our_scsiid;
	int	 target_offset;
	uint16_t target_mask;
	u_int	 target;
	u_int	 lun;
	char	 channel;
	role_t	 role;		/*
				 * Only guaranteed to be correct if not
				 * in the busfree state.
				 */
};
d602 2
a603 10
/****************************** PCI Structures ********************************/
typedef int (ahc_device_setup_t)(struct ahc_softc *);

struct ahc_pci_identity {
	uint64_t		 full_id;
	uint64_t		 id_mask;
	ahc_device_setup_t	*setup;
};
extern struct ahc_pci_identity ahc_pci_ident_table [];
extern const u_int ahc_num_pci_devs;
a604 6
/***************************** VL/EISA Declarations ***************************/
struct aic7770_identity {
	uint32_t		 full_id;
	uint32_t		 id_mask;
	char			*name;
	ahc_device_setup_t	*setup;
a605 2
extern struct aic7770_identity aic7770_ident_table [];
extern const int ahc_num_aic7770_devs;
d607 1
a607 132
#define AHC_EISA_SLOT_OFFSET	0xc00
#define AHC_EISA_IOSIZE		0x100

/*************************** Function Declarations ****************************/
/******************************************************************************/
u_int			ahc_index_busy_tcl(struct ahc_softc *, u_int);
void			ahc_unbusy_tcl(struct ahc_softc *, u_int);
void			ahc_busy_tcl(struct ahc_softc *, u_int, u_int);

/***************************** PCI Front End *********************************/
const struct ahc_pci_identity	*ahc_find_pci_device(pcireg_t, pcireg_t, u_int);
int			 ahc_pci_config(struct ahc_softc *,
			    struct ahc_pci_identity *);
int			 ahc_pci_test_register_access(struct ahc_softc *);

/*************************** EISA/VL Front End ********************************/
struct aic7770_identity *aic7770_find_device(uint32_t);
int			 aic7770_config(struct ahc_softc *,
			    struct aic7770_identity *, u_int);

/************************** SCB and SCB queue management **********************/
int		ahc_probe_scbs(struct ahc_softc *);
void		ahc_run_untagged_queues(struct ahc_softc *);
void		ahc_run_untagged_queue(struct ahc_softc *, struct scb_tailq *);
void		ahc_qinfifo_requeue_tail(struct ahc_softc *, struct scb *);
int		ahc_match_scb(struct ahc_softc *, struct scb *,
		    int, char, int, u_int, role_t);

/****************************** Initialization ********************************/
int			 ahc_softc_init(struct ahc_softc *);
void			 ahc_controller_info(struct ahc_softc *, char *, size_t);
int			 ahc_init(struct ahc_softc *);
void			 ahc_intr_enable(struct ahc_softc *, int);
void			 ahc_pause_and_flushwork(struct ahc_softc *);
int			 ahc_suspend(struct ahc_softc *); 
int			 ahc_resume(struct ahc_softc *);
void			 ahc_softc_insert(struct ahc_softc *);
struct ahc_softc	*ahc_find_softc(struct ahc_softc *);
void			 ahc_set_unit(struct ahc_softc *, int);
void			 ahc_set_name(struct ahc_softc *, char *);
void			 ahc_alloc_scbs(struct ahc_softc *);
void			 ahc_free(struct ahc_softc *);
int			 ahc_reset(struct ahc_softc *);
void			 ahc_shutdown(void *);

/*************************** Interrupt Services *******************************/
void			ahc_pci_intr(struct ahc_softc *);
void			ahc_clear_intstat(struct ahc_softc *);
void			ahc_run_qoutfifo(struct ahc_softc *);
#ifdef AHC_TARGET_MODE
void			ahc_run_tqinfifo(struct ahc_softc *, int);
#endif
void			ahc_handle_brkadrint(struct ahc_softc *);
void			ahc_handle_seqint(struct ahc_softc *, u_int);
void			ahc_handle_scsiint(struct ahc_softc *, u_int);
void			ahc_clear_critical_section(struct ahc_softc *);

/***************************** Error Recovery *********************************/
typedef enum {
	SEARCH_COMPLETE,
	SEARCH_COUNT,
	SEARCH_REMOVE
} ahc_search_action;
int			ahc_search_qinfifo(struct ahc_softc *, int, char,
			    int, u_int, role_t, uint32_t, ahc_search_action);
int			ahc_search_untagged_queues(struct ahc_softc *,
			    struct scsipi_xfer *, int, char, int, uint32_t,
			    ahc_search_action);
int			ahc_search_disc_list(struct ahc_softc *, int, char,
			    int, u_int, int, int, int);
void			ahc_freeze_devq(struct ahc_softc *, struct scb *);
int			ahc_reset_channel(struct ahc_softc *, char, int);
int			ahc_abort_scbs(struct ahc_softc *, int, char, int,
			    u_int, role_t, uint32_t);
void			ahc_restart(struct ahc_softc *);
void			ahc_calc_residual(struct ahc_softc *, struct scb *);
/*************************** Utility Functions ********************************/
struct ahc_phase_table_entry*
			ahc_lookup_phase_entry(int);
void			ahc_compile_devinfo(struct ahc_devinfo *, u_int, u_int,
			    u_int, char, role_t);
/************************** Transfer Negotiation ******************************/
struct ahc_syncrate*	ahc_find_syncrate(struct ahc_softc *, u_int *,
			    u_int *, u_int);
u_int			ahc_find_period(struct ahc_softc *, u_int, u_int);
void			ahc_validate_offset(struct ahc_softc *,
			    struct ahc_initiator_tinfo *, struct ahc_syncrate *,
			    u_int *, int, role_t);
void			ahc_validate_width(struct ahc_softc *,
			    struct ahc_initiator_tinfo *, u_int *, role_t);
/*
 * Negotiation types.  These are used to qualify if we should renegotiate
 * even if our goal and current transport parameters are identical.
 */
typedef enum {
	AHC_NEG_TO_GOAL,	/* Renegotiate only if goal and curr differ. */
	AHC_NEG_IF_NON_ASYNC,	/* Renegotiate so long as goal is non-async. */
	AHC_NEG_ALWAYS		/* Renegotiate even if goal is async. */
} ahc_neg_type;
int			ahc_update_neg_request(struct ahc_softc *,
			    struct ahc_devinfo *, struct ahc_tmode_tstate *,
			    struct ahc_initiator_tinfo*, ahc_neg_type);
void			ahc_set_width(struct ahc_softc *, struct ahc_devinfo *,
			    u_int, u_int, int);
void			ahc_set_syncrate(struct ahc_softc *,
			    struct ahc_devinfo *, struct ahc_syncrate *,
			    u_int, u_int, u_int, u_int, int);
void			ahc_scb_devinfo(struct ahc_softc *,
			    struct ahc_devinfo *, struct scb *);

typedef enum {
	AHC_QUEUE_NONE,
	AHC_QUEUE_BASIC,
	AHC_QUEUE_TAGGED
} ahc_queue_alg;

void			ahc_set_tags(struct ahc_softc *, struct ahc_devinfo *,
			    ahc_queue_alg);

/**************************** Target Mode *************************************/
#ifdef AHC_TARGET_MODE
void		ahc_send_lstate_events(struct ahc_softc *,
		    struct ahc_tmode_lstate *);
void		ahc_handle_en_lun(struct ahc_softc *, struct scsipi_xfer *);
cam_status	ahc_find_tmode_devs(struct ahc_softc *,
		    struct ahc_tmode_tstate **, struct ahc_tmode_lstate **,
		    int);
#ifndef AHC_TMODE_ENABLE
#define AHC_TMODE_ENABLE 0
#endif
#endif
/******************************* Debug ***************************************/
d609 42
a650 26
extern uint32_t ahc_debug;
#define	AHC_SHOW_MISC		0x0001
#define	AHC_SHOW_SENSE		0x0002
#define AHC_DUMP_SEEPROM	0x0004
#define AHC_SHOW_TERMCTL	0x0008
#define AHC_SHOW_MEMORY		0x0010
#define AHC_SHOW_MESSAGES	0x0020
#define	AHC_SHOW_DV		0x0040
#define AHC_SHOW_SELTO		0x0080
#define AHC_SHOW_CMDS		0x0100
#define AHC_SHOW_QFULL		0x0200
#define AHC_SHOW_QUEUE		0x0400
#define AHC_SHOW_TQIN		0x0800
#define AHC_SHOW_MASKED_ERRORS	0x1000
#define AHC_DEBUG_SEQUENCER	0x2000
#endif
void			ahc_print_scb(struct scb *);
void			ahc_print_devinfo(struct ahc_softc *,
			    struct ahc_devinfo *);
void			ahc_dump_card_state(struct ahc_softc *);
int			ahc_print_register(ahc_reg_parse_entry_t *, u_int,
			    const char *, u_int, u_int, u_int *, u_int);
/******************************* SEEPROM *************************************/
int		ahc_acquire_seeprom(struct ahc_softc *,
		    struct seeprom_descriptor *);
void		ahc_release_seeprom(struct seeprom_descriptor *);
d652 1
a652 2
void		ahc_check_extport(struct ahc_softc *, u_int *);
#endif /* _AIC7XXXVAR_H_ */
@


1.10.14.6
log
@Merge with the trunk
@
text
@d851 2
a852 2
#define		CFSUPREM	0x0001	/* support all removable drives */
#define		CFSUPREMB	0x0002	/* support removable boot drives */
@


1.9
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxxvar.h,v 1.8 1996/10/31 01:01:25 niklas Exp $	*/
d73 1
a73 1
	bus_space_read_multi_1((ahc)->sc_iot, (ahc)->sc_ioh, port, valp, size)
d77 1
a77 1
	bus_space_write_multi_1((ahc)->sc_iot, (ahc)->sc_ioh, port, valp, size)
d79 1
a79 1
	bus_space_write_multi_4((ahc)->sc_iot, (ahc)->sc_ioh, port, valp, size)
d202 1
a202 1
	struct ahc_dma_seg ahc_dma[AHC_NSEG] __attribute__ ((packed));
d214 2
@


1.8
log
@$OpenBSD RCSIDs
@
text
@d1 2
a2 1
/*	$OpenBSD: aic7xxxvar.h,v 1.7 1996/08/21 22:27:36 deraadt Exp $	*/
d71 1
a71 1
	bus_io_read_1((ahc)->sc_bc, (ahc)->sc_ioh, port)
d73 1
a73 1
	bus_io_read_multi_1((ahc)->sc_bc, (ahc)->sc_ioh, port, valp, size)
d75 1
a75 1
	bus_io_write_1((ahc)->sc_bc, (ahc)->sc_ioh, port, val)
d77 1
a77 1
	bus_io_write_multi_1((ahc)->sc_bc, (ahc)->sc_ioh, port, valp, size)
d79 1
a79 1
	bus_io_write_multi_4((ahc)->sc_bc, (ahc)->sc_ioh, port, valp, size)
d93 1
a93 1
typedef unsigned long int physaddr;
d99 2
a100 2
        physaddr addr;
            long len;
d116 1
d147 14
a160 12
	SCB_FREE		= 0x000,
	SCB_ACTIVE		= 0x001,
	SCB_ABORTED		= 0x002,
	SCB_DEVICE_RESET	= 0x004,
	SCB_IMMED		= 0x008,
	SCB_SENSE		= 0x010,
	SCB_TIMEDOUT		= 0x020,
	SCB_QUEUED_FOR_DONE	= 0x040,
	SCB_PAGED_OUT		= 0x080,
	SCB_WAITINGQ		= 0x100,
	SCB_ASSIGNEDQ		= 0x200,
	SCB_SENTORDEREDTAG	= 0x400
d179 1
a179 1
/*16*/  u_long datalen;			/* Really only three bits, but its
d212 2
a213 2
	bus_chipset_tag_t sc_bc;
	bus_io_handle_t sc_ioh;
d291 4
a294 2
void ahc_reset __P((char *devname, bus_chipset_tag_t bc, bus_io_handle_t ioh));
void ahc_construct __P((struct ahc_data *ahc, bus_chipset_tag_t bc, bus_io_handle_t ioh, ahc_type type, ahc_flag flags));
d296 3
a298 3
void ahc_free __P((struct ahc_data *));
int ahc_init __P((struct ahc_data *));
int ahc_attach __P((struct ahc_data *));
d300 1
a300 1
void ahc_intr __P((void *arg));
d302 1
a302 1
int ahc_intr __P((void *arg));
@


1.7
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@d1 1
a32 2
 *
 *	$Id: aic7xxxvar.h,v 1.6 1996/06/27 21:15:49 shawn Exp $
@


1.6
log
@new 2940 driver merged from freebsd sources 960623
@
text
@d33 1
a33 1
 *	$Id: aic7xxx.h,v 1.28 1996/05/30 07:19:59 gibbs Exp $
d43 1
a43 1
#if defined(__NetBSD__)
d69 1
a69 1
#elif defined(__NetBSD__)
d206 1
a206 1
#elif defined(__NetBSD__)
d284 1
a284 1
#elif defined(__NetBSD__)
d296 1
a296 1
#elif defined(__NetBSD__)
@


1.5
log
@sync 0521
@
text
@a0 2
/*	$NetBSD: aic7xxxvar.h,v 1.7 1996/05/20 00:58:11 thorpej Exp $	*/

d32 2
d43 15
d195 1
a195 1
	SIMPLEQ_ENTRY(scb)	links;	/* for chaining */
d222 1
a222 1
	SIMPLEQ_HEAD(, scb) free_scbs;	/*
d226 1
a226 1
	SIMPLEQ_HEAD(, scb) page_scbs;	/*
d230 1
a230 1
	SIMPLEQ_HEAD(, scb) waiting_scbs;/*
d234 1
a234 1
	SIMPLEQ_HEAD(, scb)assigned_scbs;/*
@


1.4
log
@ahc/ahe driver update from freebsd; merged by soda@@sra.co.jp and
pete@@demon.net
@
text
@d1 2
a33 2
 *
 *	$Id: aic7xxx.h,v 1.26 1996/04/28 19:21:20 gibbs Exp $
d43 1
a43 68
#ifndef STAILQ_ENTRY /* for NetBSD, from FreeBSD <sys/queue.h> */
/*
 * Singly-linked Tail queue definitions.
 */
#define STAILQ_HEAD(name, type)						\
struct name {								\
	struct type *stqh_first;/* first element */			\
	struct type **stqh_last;/* addr of last next element */		\
}

#define STAILQ_ENTRY(type)						\
struct {								\
	struct type *stqe_next;	/* next element */			\
}

/*
 * Singly-linked Tail queue functions.
 */
#define	STAILQ_INIT(head) {						\
	(head)->stqh_first = NULL;					\
	(head)->stqh_last = &(head)->stqh_first;			\
}

#define STAILQ_INSERT_HEAD(head, elm, field) {				\
	if (((elm)->field.stqe_next = (head)->stqh_first) == NULL)	\
		(head)->stqh_last = &(elm)->field.stqe_next;		\
	(head)->stqh_first = (elm);					\
}

#define STAILQ_INSERT_TAIL(head, elm, field) {				\
	(elm)->field.stqe_next = NULL;					\
	*(head)->stqh_last = (elm);					\
	(head)->stqh_last = &(elm)->field.stqe_next;			\
}

#define STAILQ_INSERT_AFTER(head, tqelm, elm, field) {			\
	if (((elm)->field.stqe_next = (tqelm)->field.stqe_next) == NULL)\
		(head)->stqh_last = &(elm)->field.stqe_next;		\
	(tqelm)->field.stqe_next = (elm);				\
}

#define STAILQ_REMOVE_HEAD(head, field) {				\
	if (((head)->stqh_first =					\
	     (head)->stqh_first->field.stqe_next) == NULL)		\
		(head)->stqh_last = &(head)->stqh_first;		\
}

#define STAILQ_REMOVE(head, elm, type, field) {				\
	if ((head)->stqh_first == (elm)) {				\
		STAILQ_REMOVE_HEAD(head, field);			\
	}								\
	else {								\
		struct type *curelm = (head)->stqh_first;		\
		while( curelm->field.stqe_next != (elm) )		\
			curelm = curelm->field.stqe_next;		\
		if((curelm->field.stqe_next =				\
		    curelm->field.stqe_next->field.stqe_next) == NULL)	\
			(head)->stqh_last = &(curelm)->field.stqe_next;	\
	}								\
}

#endif /* STAILQ_ENTRY */

#ifndef NetBSD1_1
#define	NetBSD1_1	0
#endif

#if defined(__FreeBSD__) || NetBSD1_1 < 3
d56 1
a56 1
	bus_io_read_1((ahc)->sc_bc, ahc->baseport, port)
d58 1
a58 1
	bus_io_read_multi_1((ahc)->sc_bc, ahc->baseport, port, valp, size)
d60 1
a60 1
	bus_io_write_1((ahc)->sc_bc, ahc->baseport, port, val)
d62 1
a62 1
	bus_io_write_multi_1((ahc)->sc_bc, ahc->baseport, port, valp, size)
d64 1
a64 1
	bus_io_write_multi_4((ahc)->sc_bc, ahc->baseport, port, valp, size)
d79 1
d81 1
d108 10
a117 5
	AHC_FNONE	= 0x00,
	AHC_INIT	= 0x01,
	AHC_RUNNING	= 0x02,
	AHC_PAGESCBS	= 0x04,		/* Enable SCB paging */
	AHC_USEDEFAULTS = 0x10,		/*
d120 2
a121 2
					 * SRAM, we use the default chip and
					 * target settings.
d123 1
a123 1
	AHC_CHNLB	= 0x20,		/* 
d130 15
d147 2
a148 2
 * first 26 bytes of the structure need to be transfered to the card during
 * normal operation.  The fields starting at byte 32 are used for kernel level
d180 1
a180 1
	STAILQ_ENTRY(scb)	links;	/* for chaining */
d182 1
a182 13
	int	flags;
#define	SCB_FREE		0x000
#define	SCB_ACTIVE		0x001
#define	SCB_ABORTED		0x002
#define	SCB_DEVICE_RESET	0x004
#define	SCB_IMMED		0x008
#define	SCB_SENSE		0x010
#define	SCB_TIMEDOUT		0x020
#define	SCB_QUEUED_FOR_DONE	0x040
#define	SCB_PAGED_OUT		0x080
#define	SCB_WAITINGQ		0x100
#define	SCB_ASSIGNEDQ		0x200
#define	SCB_SENTORDEREDTAG	0x400
a187 7
#if defined(__NetBSD__)
#if NetBSD1_1 < 3 /* NetBSD-1.1 */
typedef int bus_chipset_tag_t;
typedef int bus_io_handle_t;
#endif
#endif

d189 3
a191 1
#if defined(__NetBSD__)
d195 1
a196 1
	int	unit;
d199 1
d201 1
d207 1
a207 1
	STAILQ_HEAD(, scb) free_scbs;	/*
d211 1
a211 1
	STAILQ_HEAD(, scb) page_scbs;	/*
d215 1
a215 1
	STAILQ_HEAD(, scb) waiting_scbs;/*
d219 1
a219 1
	STAILQ_HEAD(, scb)assigned_scbs;/*
d264 3
d270 3
d274 1
a274 1
void ahc_construct __P((struct ahc_data *ahc, int unit, bus_chipset_tag_t bc, bus_io_handle_t ioh, ahc_type type, ahc_flag flags));
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@a0 3
/*	$OpenBSD: aic7xxxvar.h,v 1.2 1996/04/18 23:47:16 niklas Exp $	*/
/*	$NetBSD: aic7xxxvar.h,v 1.3 1996/03/29 00:25:02 mycroft Exp $	*/

d2 2
a3 2
 * Interface to the generic driver for the aic7xxx based adaptec 
 * SCSI controllers.  This is used to implement product specific 
d6 1
a6 1
 * Copyright (c) 1994, 1995 Justin T. Gibbs.
d18 16
a33 4
 * 3. Absolutely no warranty of function or purpose is made by the author
 *    Justin T. Gibbs.
 * 4. Modifications may be freely made to this file if the above conditions
 *    are met.
d39 95
d136 6
a141 3
#define AHC_SCB_MAX	16	/*
				 * Up to 16 SCBs on some types of aic7xxx based
				 * boards.  The aic7770 family only have 4
a143 1
/* #define AHCDEBUG */
d145 2
a146 2
typedef u_long physaddr;
typedef u_long physlen;
d149 2
a150 2
        physaddr seg_addr;
	physlen seg_len;
d152 37
a188 9
 
typedef u_char ahc_type;
#define	AHC_NONE	0x00
#define	AHC_WIDE	0x02	/* Wide Channel */
#define AHC_TWIN	0x08	/* Twin Channel */
#define	AHC_274		0x10	/* EISA Based Controller */
#define	AHC_284		0x20	/* VL/ISA Based Controller */
#define	AHC_AIC7870	0x40	/* PCI Based Controller */
#define	AHC_294		0xc0	/* PCI Based Controller */
d192 3
a194 7
 * first 26 bytes of the structure are valid for the hardware, the rest used
 * for driver level bookeeping.  The "__attribute ((packed))" tags ensure that
 * gcc does not attempt to pad the long ints in the structure to word
 * boundaries since the first 26 bytes of this structure must have the correct
 * offsets for the hardware to find them.  The driver is further optimized
 * so that we only have to download the first 19 bytes since as long
 * as we always use S/G, the last fields should be zero anyway.  
d196 1
a196 7
#if __GNUC__ >= 2
#if  __GNUC_MINOR__ <5
#pragma pack(1)
#endif
#endif

struct ahc_scb {
d198 3
a200 11
/*1*/   u_char control;
#define	SCB_NEEDWDTR 0x80			/* Initiate Wide Negotiation */
#define SCB_NEEDSDTR 0x40			/* Initiate Sync Negotiation */
#define	SCB_TE	     0x20			/* Tag enable */
#define	SCB_NEEDDMA  0x08			/* Refresh SCB from host ram */
#define	SCB_DIS 0x04
#define	SCB_TAG_TYPE 0x3
#define		SIMPLE_QUEUE 0x0
#define		HEAD_QUEUE 0x1
#define		OR_QUEUE 0x2
/*2*/	u_char target_channel_lun;		/* 4/1/3 bits */
d202 24
a225 32
/*7*/	physaddr SG_list_pointer	__attribute__ ((packed));
/*11*/	physaddr cmdpointer		__attribute__ ((packed));
/*12*/	u_char cmdlen;
/*14*/	u_char RESERVED[2];			/* must be zero */
/*15*/	u_char target_status;
/*18*/	u_char residual_data_count[3];
/*19*/	u_char residual_SG_segment_count;
#define	SCB_DOWN_SIZE 19		/* amount to actually download */
#define SCB_BZERO_SIZE 19		/* 
					 * amount we need to clear between
					 * commands
					 */
/*23*/	physaddr data			 __attribute__ ((packed));
/*26*/  u_char datalen[3];
#define SCB_UP_SIZE 26			/* 
					 * amount we need to upload to perform
					 * a request sense.
					 */
/*30*/	physaddr host_scb			 __attribute__ ((packed));
/*31*/	u_char next_waiting;		/* Used to thread SCBs awaiting 
					 * selection
					 */
#define SCB_LIST_NULL 0x10		/* SCB list equivelent to NULL */
#if 0
	/*
	 *  No real point in transferring this to the
	 *  SCB registers.
	*/
	unsigned char RESERVED[1];
#endif
	/*-----------------end of hardware supported fields----------------*/
	TAILQ_ENTRY(ahc_scb) chain;
d227 14
a240 8
	int flags;
#define	SCB_FREE	0
#define	SCB_ACTIVE	1
#define	SCB_ABORTED	2
#define	SCB_CHKSENSE	3
#define	SCB_IMMED	4
#define	SCB_IMMED_FAIL	8
	int	position;	/* Position in scbarray */
d245 4
a248 3
#if __GNUC__ >= 2
#if  __GNUC_MINOR__ <5
#pragma pack(4)
a250 7
 
struct ahc_softc {
        struct device sc_dev;  
        void *sc_ih;

	int sc_iobase;
	int sc_irq;
d252 7
d260 24
a283 6

	struct	ahc_scb *scbarray[AHC_SCB_MAX]; /* Mirror boards scbarray */
	TAILQ_HEAD(, ahc_scb) free_scb;
	int	ahc_scsi_dev;		/* our scsi id */
	int	ahc_scsi_dev_b;		/* B channel scsi id */
	struct	ahc_scb *immed_ecb;	/* an outstanding immediete command */
d293 12
a304 3
	int	numscbs;
	int	activescbs;
	u_char	maxscbs;
d307 1
d309 29
@


1.2
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: aic7xxxvar.h,v 1.2 1996/03/14 02:30:30 cgd Exp $	*/
a28 2

/*#include "ahc.h"                /* for NAHC from config */
@


1.1
log
@Initial revision
@
text
@d1 3
a24 2
 *
 *	$Id: aic7xxxvar.h,v 1.1 1995/10/09 09:49:31 mycroft Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
