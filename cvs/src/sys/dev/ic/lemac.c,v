head	1.30;
access;
symbols
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.12
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.3
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.30
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.29;
commitid	VyLWTsbepAOk7VQM;

1.29
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.28;
commitid	QHiEhS9DHyE6oiIr;

1.28
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.27;
commitid	J9apD0jq2AjFmqZc;

1.27
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.26;
commitid	f4dx5ry1aOiKJw33;

1.26
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.25;
commitid	B0kwmVGiD5DVx4kv;

1.25
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.24;
commitid	5gdEnqVoJuTuwdTu;

1.24
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.23;
commitid	5DvsamK0GblTp8ww;

1.23
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.22;
commitid	eYnPulzvLjDImPCa;

1.22
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.21;
commitid	p0v5tuE1Ch6fY0Nj;

1.21
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.20;
commitid	6vhYvh5CxZAHMnsN;

1.20
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.19;
commitid	MVWrtktB46JRxFWT;

1.19
date	2015.04.06.09.13.55;	author miod;	state Exp;
branches;
next	1.18;
commitid	AVkctdqJCMxzh0gO;

1.18
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.17;
commitid	yM2VFFhpDTeFQlve;

1.17
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.16;
commitid	TGHgrLxu6sxZoiFt;

1.16
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	EF98ch02VpFassUi;

1.15
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.14;

1.14
date	2013.08.07.01.06.30;	author bluhm;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.10.22.08.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.16.16.32.08;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.14.14.46.41;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.08.17.03.00;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.30.02.30.48;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.07.19.28.59;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.25.08.48.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.13.17.26.44;	author niklas;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.56.19;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.30
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/* $OpenBSD: lemac.c,v 1.29 2016/04/13 10:49:26 mpi Exp $ */
/* $NetBSD: lemac.c,v 1.20 2001/06/13 10:46:02 wiz Exp $ */

/*-
 * Copyright (c) 1994, 1995, 1997 Matt Thomas <matt@@3am-software.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * DEC EtherWORKS 3 Ethernet Controllers
 *
 * Written by Matt Thomas
 * BPF support code stolen directly from if_ec.c
 *
 *   This driver supports the LEMAC DE203/204/205 cards.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>

#include <dev/ic/lemacreg.h>
#include <dev/ic/lemacvar.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

int	lemac_ifioctl(struct ifnet *, u_long, caddr_t);
int	lemac_ifmedia_change(struct ifnet *const);
void	lemac_ifmedia_status(struct ifnet *const, struct ifmediareq *);
void	lemac_ifstart(struct ifnet *);
void	lemac_init(struct lemac_softc *);
void	lemac_init_adapmem(struct lemac_softc *);
struct mbuf *lemac_input(struct lemac_softc *, bus_size_t, size_t);
void	lemac_multicast_filter(struct lemac_softc *);
void	lemac_multicast_op(u_int16_t *, const u_char *, int);
int	lemac_read_eeprom(struct lemac_softc *);
int	lemac_read_macaddr(unsigned char *, const bus_space_tag_t,
    const bus_space_handle_t, const bus_size_t, int);
void	lemac_reset(struct lemac_softc *);
void	lemac_rne_intr(struct lemac_softc *);
void	lemac_rxd_intr(struct lemac_softc *, unsigned);
void	lemac_tne_intr(struct lemac_softc *);
void	lemac_txd_intr(struct lemac_softc *, unsigned);

struct cfdriver lc_cd = {
	NULL, "lc", DV_IFNET
};

static const u_int16_t lemac_allmulti_mctbl[LEMAC_MCTBL_SIZE/sizeof(u_int16_t)] = {
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
};

/*
 * Some tuning/monitoring variables.
 */
unsigned lemac_txmax = 16;

void
lemac_rxd_intr(struct lemac_softc *sc, unsigned cs_value)
{
	/*
	 * Handle CS_RXD (Receiver disabled) here.
	 *
	 * Check Free Memory Queue Count. If not equal to zero
	 * then just turn Receiver back on. If it is equal to
	 * zero then check to see if transmitter is disabled.
	 * Process transmit TXD loop once more.  If all else
	 * fails then do software init (0xC0 to EEPROM Init)
	 * and rebuild Free Memory Queue.
	 */

	sc->sc_cntrs.cntr_rxd_intrs++;

	/*
	 *  Re-enable Receiver.
	 */

	cs_value &= ~LEMAC_CS_RXD;
	LEMAC_OUTB(sc, LEMAC_REG_CS, cs_value);

	if (LEMAC_INB(sc, LEMAC_REG_FMC) > 0)
		return;

	if (cs_value & LEMAC_CS_TXD)
		lemac_txd_intr(sc, cs_value);

	if ((LEMAC_INB(sc, LEMAC_REG_CS) & LEMAC_CS_RXD) == 0)
		return;

	printf("%s: fatal RXD error, attempting recovery\n",
	    sc->sc_if.if_xname);

	lemac_reset(sc);
	if (sc->sc_if.if_flags & IFF_UP) {
		lemac_init(sc);
		return;
	}

	/*
	 *  Error during initialization.  Mark card as disabled.
	 */
	printf("%s: recovery failed -- board disabled\n", sc->sc_if.if_xname);
}

void
lemac_tne_intr(struct lemac_softc *sc)
{
	unsigned txcount = LEMAC_INB(sc, LEMAC_REG_TDC);

	sc->sc_cntrs.cntr_tne_intrs++;
	while (txcount-- > 0) {
		unsigned txsts = LEMAC_INB(sc, LEMAC_REG_TDQ);
		if ((txsts & (LEMAC_TDQ_LCL|LEMAC_TDQ_NCL))
		    || (txsts & LEMAC_TDQ_COL) == LEMAC_TDQ_EXCCOL) {
			if (txsts & LEMAC_TDQ_NCL)
				sc->sc_flags &= ~LEMAC_LINKUP;
			sc->sc_if.if_oerrors++;
		} else {
			sc->sc_flags |= LEMAC_LINKUP;
			if ((txsts & LEMAC_TDQ_COL) != LEMAC_TDQ_NOCOL)
				sc->sc_if.if_collisions++;
		}
	}
	ifq_clr_oactive(&sc->sc_if.if_snd);
	lemac_ifstart(&sc->sc_if);
}

void
lemac_txd_intr(struct lemac_softc *sc, unsigned cs_value)
{
	/*
	 * Read transmit status, remove transmit buffer from
	 * transmit queue and place on free memory queue,
	 * then reset transmitter.
	 * Increment appropriate counters.
	 */

	sc->sc_cntrs.cntr_txd_intrs++;
	if (sc->sc_txctl & LEMAC_TX_STP) {
		sc->sc_if.if_oerrors++;
		/* return page to free queue */
		LEMAC_OUTB(sc, LEMAC_REG_FMQ, LEMAC_INB(sc, LEMAC_REG_TDQ));
	}

	/* Turn back on transmitter if disabled */
	LEMAC_OUTB(sc, LEMAC_REG_CS, cs_value & ~LEMAC_CS_TXD);
	ifq_clr_oactive(&sc->sc_if.if_snd);
}

int
lemac_read_eeprom(struct lemac_softc *sc)
{
	int	word_off, cksum;

	u_char *ep;

	cksum = 0;
	ep = sc->sc_eeprom;
	for (word_off = 0; word_off < LEMAC_EEP_SIZE / 2; word_off++) {
		LEMAC_OUTB(sc, LEMAC_REG_PI1, word_off);
		LEMAC_OUTB(sc, LEMAC_REG_IOP, LEMAC_IOP_EEREAD);

		DELAY(LEMAC_EEP_DELAY);

		*ep = LEMAC_INB(sc, LEMAC_REG_EE1);
		cksum += *ep++;
		*ep = LEMAC_INB(sc, LEMAC_REG_EE2);
		cksum += *ep++;
	}

	/*
	 *  Set up Transmit Control Byte for use later during transmit.
	 */

	sc->sc_txctl |= LEMAC_TX_FLAGS;

	if ((sc->sc_eeprom[LEMAC_EEP_SWFLAGS] & LEMAC_EEP_SW_SQE) == 0)
		sc->sc_txctl &= ~LEMAC_TX_SQE;

	if (sc->sc_eeprom[LEMAC_EEP_SWFLAGS] & LEMAC_EEP_SW_LAB)
		sc->sc_txctl |= LEMAC_TX_LAB;

	bcopy(&sc->sc_eeprom[LEMAC_EEP_PRDNM], sc->sc_prodname,
	    LEMAC_EEP_PRDNMSZ);
	sc->sc_prodname[LEMAC_EEP_PRDNMSZ] = '\0';

	return (cksum % 256);
}

void
lemac_init_adapmem(struct lemac_softc *sc)
{
	int pg, conf;

	conf = LEMAC_INB(sc, LEMAC_REG_CNF);

	if ((sc->sc_eeprom[LEMAC_EEP_SETUP] & LEMAC_EEP_ST_DRAM) == 0) {
		sc->sc_lastpage = 63;
		conf &= ~LEMAC_CNF_DRAM;
	} else {
		sc->sc_lastpage = 127;
		conf |= LEMAC_CNF_DRAM;
	}

	LEMAC_OUTB(sc, LEMAC_REG_CNF, conf);

	for (pg = 1; pg <= sc->sc_lastpage; pg++)
		LEMAC_OUTB(sc, LEMAC_REG_FMQ, pg);
}

struct mbuf *
lemac_input(struct lemac_softc *sc, bus_size_t offset, size_t length)
{
	struct ether_header eh;
	struct mbuf *m;

	if (length - sizeof(eh) > ETHERMTU ||
	    length - sizeof(eh) < ETHERMIN)
		return NULL;
	if (LEMAC_USE_PIO_MODE(sc)) {
		LEMAC_INSB(sc, LEMAC_REG_DAT, sizeof(eh), (void *)&eh);
	} else {
		LEMAC_GETBUF16(sc, offset, sizeof(eh) / 2, (void *)&eh);
	}

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return NULL;
	if (length + 2 > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			return NULL;
		}
	}
	m->m_data += 2;
	bcopy((caddr_t)&eh, m->m_data, sizeof(eh));
	if (LEMAC_USE_PIO_MODE(sc)) {
		LEMAC_INSB(sc, LEMAC_REG_DAT, length - sizeof(eh),
		    mtod(m, caddr_t) + sizeof(eh));
	} else {
		LEMAC_GETBUF16(sc, offset + sizeof(eh),
		    (length - sizeof(eh)) / 2,
		    (void *)(mtod(m, caddr_t) + sizeof(eh)));
		if (length & 1)
			m->m_data[length - 1] = LEMAC_GET8(sc,
			    offset + length - 1);
	}

	m->m_pkthdr.len = m->m_len = length;
	return m;
}

void
lemac_rne_intr(struct lemac_softc *sc)
{
	struct ifnet *ifp = &sc->sc_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	int rxcount;

	sc->sc_cntrs.cntr_rne_intrs++;
	rxcount = LEMAC_INB(sc, LEMAC_REG_RQC);
	while (rxcount--) {
		unsigned rxpg = LEMAC_INB(sc, LEMAC_REG_RQ);
		u_int32_t rxlen;

		if (LEMAC_USE_PIO_MODE(sc)) {
			LEMAC_OUTB(sc, LEMAC_REG_IOP, rxpg);
			LEMAC_OUTB(sc, LEMAC_REG_PI1, 0);
			LEMAC_OUTB(sc, LEMAC_REG_PI2, 0);
			LEMAC_INSB(sc, LEMAC_REG_DAT, sizeof(rxlen),
			    (void *)&rxlen);
		} else {
			LEMAC_OUTB(sc, LEMAC_REG_MPN, rxpg);
			rxlen = LEMAC_GET32(sc, 0);
		}
		if (rxlen & LEMAC_RX_OK) {
			sc->sc_flags |= LEMAC_LINKUP;
			/*
			 * Get receive length - subtract out checksum.
			 */
			rxlen = ((rxlen >> 8) & 0x7FF) - 4;
			m = lemac_input(sc, sizeof(rxlen), rxlen);
		} else
			m = NULL;

		if (m != NULL)
			ml_enqueue(&ml, m);
		else
			ifp->if_ierrors++;

		/* Return this page to Free Memory Queue */
		LEMAC_OUTB(sc, LEMAC_REG_FMQ, rxpg);
	}  /* end while (recv_count--) */

	if_input(ifp, &ml);
}

/*
 *  This is the standard method of reading the DEC Address ROMS.
 *  I don't understand it but it does work.
 */
int
lemac_read_macaddr(unsigned char *hwaddr, const bus_space_tag_t iot,
    const bus_space_handle_t ioh, const bus_size_t ioreg, int skippat)
{
	int cksum, rom_cksum;
	unsigned char addrbuf[6];
    
	if (!skippat) {
		int idx, idx2, found, octet;
		static u_char testpat[] = {
			0xFF, 0, 0x55, 0xAA, 0xFF, 0, 0x55, 0xAA
		};
		idx2 = found = 0;
    
		for (idx = 0; idx < 32; idx++) {
			octet = bus_space_read_1(iot, ioh, ioreg);
	    
			if (octet == testpat[idx2]) {
				if (++idx2 == sizeof(testpat)) {
					++found;
					break;
				}
			} else {
				idx2 = 0;
			}
		}

		if (!found)
			return (-1);
	}

	if (hwaddr == NULL)
		hwaddr = addrbuf;

	cksum = 0;
	hwaddr[0] = bus_space_read_1(iot, ioh, ioreg);
	hwaddr[1] = bus_space_read_1(iot, ioh, ioreg);

	/* hardware address can't be multicast */
	if (hwaddr[0] & 1)
		return (-1);

#if BYTE_ORDER == LITTLE_ENDIAN
	cksum = *(u_short *)&hwaddr[0];
#else
	cksum = ((u_short)hwaddr[1] << 8) | (u_short)hwaddr[0];
#endif

	hwaddr[2] = bus_space_read_1(iot, ioh, ioreg);
	hwaddr[3] = bus_space_read_1(iot, ioh, ioreg);
	cksum *= 2;
	if (cksum > 65535)
		cksum -= 65535;
#if BYTE_ORDER == LITTLE_ENDIAN
	cksum += *(u_short *)&hwaddr[2];
#else
	cksum += ((u_short)hwaddr[3] << 8) | (u_short)hwaddr[2];
#endif
	if (cksum > 65535)
		cksum -= 65535;

	hwaddr[4] = bus_space_read_1(iot, ioh, ioreg);
	hwaddr[5] = bus_space_read_1(iot, ioh, ioreg);
	cksum *= 2;
	if (cksum > 65535)
		cksum -= 65535;
#if BYTE_ORDER == LITTLE_ENDIAN
	cksum += *(u_short *)&hwaddr[4];
#else
	cksum += ((u_short)hwaddr[5] << 8) | (u_short)hwaddr[4];
#endif
	if (cksum >= 65535)
		cksum -= 65535;

	/* 00-00-00 is an illegal OUI */
	if (hwaddr[0] == 0 && hwaddr[1] == 0 && hwaddr[2] == 0)
		return (-1);

	rom_cksum = bus_space_read_1(iot, ioh, ioreg);
	rom_cksum |= bus_space_read_1(iot, ioh, ioreg) << 8;
	
	if (cksum != rom_cksum)
		return (-1);
	return (0);
}

void
lemac_multicast_op(u_int16_t *mctbl, const u_char *mca, int enable)
{
	u_int idx, bit, crc;

	crc = ether_crc32_le(mca, ETHER_ADDR_LEN);

	/*
	 * The following two lines convert the N bit index into a
	 * longword index and a longword mask.
	 */
#if LEMAC_MCTBL_BITS < 0
	crc >>= (32 + LEMAC_MCTBL_BITS);
	crc &= (1 << -LEMAC_MCTBL_BITS) - 1;
#else
	crc &= (1 << LEMAC_MCTBL_BITS) - 1;
#endif
	bit = 1 << (crc & 0x0F);
	idx = crc >> 4;

	/*
	 * Set or clear hash filter bit in our table.
	 */
	if (enable) {
		mctbl[idx] |= bit;		/* Set Bit */
	} else {
		mctbl[idx] &= ~bit;		/* Clear Bit */
	}
}

void
lemac_multicast_filter(struct lemac_softc *sc)
{
#if 0
	struct arpcom *ac = &sc->sc_ec;
	struct ether_multistep step;
	struct ether_multi *enm;
#endif

	bzero(sc->sc_mctbl, LEMAC_MCTBL_BITS / 8);

	lemac_multicast_op(sc->sc_mctbl, etherbroadcastaddr, 1);

#if 0
	if (ac->ac_multirangecnt > 0) {
		sc->sc_flags |= LEMAC_ALLMULTI;
		sc->sc_if.if_flags |= IFF_ALLMULTI;
		return;
	}

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		lemac_multicast_op(sc->sc_mctbl, enm->enm_addrlo, TRUE);
		ETHER_NEXT_MULTI(step, enm);
	}
#endif
	sc->sc_flags &= ~LEMAC_ALLMULTI;
	sc->sc_if.if_flags &= ~IFF_ALLMULTI;
}

/* 
 * Do a hard reset of the board;
 */
void
lemac_reset(struct lemac_softc *const sc)
{
	unsigned data;

	/*
	 * Initialize board..
	 */
	sc->sc_flags &= ~LEMAC_LINKUP;
	ifq_clr_oactive(&sc->sc_if.if_snd);
	LEMAC_INTR_DISABLE(sc);

	LEMAC_OUTB(sc, LEMAC_REG_IOP, LEMAC_IOP_EEINIT);
	DELAY(LEMAC_EEP_DELAY);

	/*
	 * Read EEPROM information.  NOTE - the placement of this function
	 * is important because functions hereafter may rely on information
	 * read from the EEPROM.
	 */
	if ((data = lemac_read_eeprom(sc)) != LEMAC_EEP_CKSUM) { 
		printf("%s: reset: EEPROM checksum failed (0x%x)\n",
		    sc->sc_if.if_xname, data);
		return;
	}

	/*
	 * Update the control register to reflect the media choice
	 */
	data = LEMAC_INB(sc, LEMAC_REG_CTL);
	if ((data & (LEMAC_CTL_APD|LEMAC_CTL_PSL)) != sc->sc_ctlmode) {
		data &= ~(LEMAC_CTL_APD|LEMAC_CTL_PSL);
		data |= sc->sc_ctlmode;
		LEMAC_OUTB(sc, LEMAC_REG_CTL, data);
	}

	/*
	 *  Force to 2K mode if not already configured.
	 */

	data = LEMAC_INB(sc, LEMAC_REG_MBR);
	if (LEMAC_IS_2K_MODE(data)) {
		sc->sc_flags |= LEMAC_2K_MODE;
	} else if (LEMAC_IS_64K_MODE(data)) {
		data = (((data * 2) & 0xF) << 4);
		sc->sc_flags |= LEMAC_WAS_64K_MODE;
		LEMAC_OUTB(sc, LEMAC_REG_MBR, data);
	} else if (LEMAC_IS_32K_MODE(data)) {
		data = ((data & 0xF) << 4);
		sc->sc_flags |= LEMAC_WAS_32K_MODE;
		LEMAC_OUTB(sc, LEMAC_REG_MBR, data);
	} else {
		sc->sc_flags |= LEMAC_PIO_MODE;
		/* PIO mode */
	}

	/*
	 *  Initialize Free Memory Queue, Init mcast table with broadcast.
	 */

	lemac_init_adapmem(sc);
	sc->sc_flags |= LEMAC_ALIVE;
}

void
lemac_init(struct lemac_softc *const sc)
{
	if ((sc->sc_flags & LEMAC_ALIVE) == 0)
		return;

	/*
	 * If the interface has the up flag
	 */
	if (sc->sc_if.if_flags & IFF_UP) {
		int saved_cs = LEMAC_INB(sc, LEMAC_REG_CS);
		LEMAC_OUTB(sc, LEMAC_REG_CS,
		    saved_cs | (LEMAC_CS_TXD | LEMAC_CS_RXD));
		LEMAC_OUTB(sc, LEMAC_REG_PA0, sc->sc_arpcom.ac_enaddr[0]);
		LEMAC_OUTB(sc, LEMAC_REG_PA1, sc->sc_arpcom.ac_enaddr[1]);
		LEMAC_OUTB(sc, LEMAC_REG_PA2, sc->sc_arpcom.ac_enaddr[2]);
		LEMAC_OUTB(sc, LEMAC_REG_PA3, sc->sc_arpcom.ac_enaddr[3]);
		LEMAC_OUTB(sc, LEMAC_REG_PA4, sc->sc_arpcom.ac_enaddr[4]);
		LEMAC_OUTB(sc, LEMAC_REG_PA5, sc->sc_arpcom.ac_enaddr[5]);

		LEMAC_OUTB(sc, LEMAC_REG_IC,
		    LEMAC_INB(sc, LEMAC_REG_IC) | LEMAC_IC_IE);

		if (sc->sc_if.if_flags & IFF_PROMISC) {
			LEMAC_OUTB(sc, LEMAC_REG_CS,
			    LEMAC_CS_MCE | LEMAC_CS_PME);
		} else {
			LEMAC_INTR_DISABLE(sc);
			lemac_multicast_filter(sc);
			if (sc->sc_flags & LEMAC_ALLMULTI)
				bcopy(lemac_allmulti_mctbl, sc->sc_mctbl,
				    sizeof(sc->sc_mctbl));
			if (LEMAC_USE_PIO_MODE(sc)) {
				LEMAC_OUTB(sc, LEMAC_REG_IOP, 0);
				LEMAC_OUTB(sc, LEMAC_REG_PI1,
				    LEMAC_MCTBL_OFF & 0xFF);
				LEMAC_OUTB(sc, LEMAC_REG_PI2,
				    LEMAC_MCTBL_OFF >> 8);
				LEMAC_OUTSB(sc, LEMAC_REG_DAT,
				    sizeof(sc->sc_mctbl),
				    (void *)sc->sc_mctbl);
			} else {
				LEMAC_OUTB(sc, LEMAC_REG_MPN, 0);
				LEMAC_PUTBUF8(sc, LEMAC_MCTBL_OFF,
				    sizeof(sc->sc_mctbl),
				    (void *)sc->sc_mctbl);
			}

			LEMAC_OUTB(sc, LEMAC_REG_CS, LEMAC_CS_MCE);
		}

		LEMAC_OUTB(sc, LEMAC_REG_CTL,
		    LEMAC_INB(sc, LEMAC_REG_CTL) ^ LEMAC_CTL_LED);

		LEMAC_INTR_ENABLE(sc);
		sc->sc_if.if_flags |= IFF_RUNNING;
		lemac_ifstart(&sc->sc_if);
	} else {
		LEMAC_OUTB(sc, LEMAC_REG_CS, LEMAC_CS_RXD|LEMAC_CS_TXD);

		LEMAC_INTR_DISABLE(sc);
		sc->sc_if.if_flags &= ~IFF_RUNNING;
	}
}

void 
lemac_ifstart(struct ifnet *ifp)
{
	struct lemac_softc *const sc = LEMAC_IFP_TO_SOFTC(ifp);

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	LEMAC_INTR_DISABLE(sc);

	for (;;) {
		struct mbuf *m;
		struct mbuf *m0;
		int tx_pg;

		m = ifq_deq_begin(&ifp->if_snd);
		if (m == NULL)
			break;

		if ((sc->sc_csr.csr_tqc = LEMAC_INB(sc, LEMAC_REG_TQC)) >=
		    lemac_txmax) {
			sc->sc_cntrs.cntr_txfull++;
			ifq_deq_rollback(&ifp->if_snd, m);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		/*
		 * get free memory page
		 */
		tx_pg = sc->sc_csr.csr_fmq = LEMAC_INB(sc, LEMAC_REG_FMQ);

		/*
		 * Check for good transmit page.
		 */
		if (tx_pg == 0 || tx_pg > sc->sc_lastpage) {
			sc->sc_cntrs.cntr_txnospc++;
			ifq_deq_rollback(&ifp->if_snd, m);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		ifq_deq_commit(&ifp->if_snd, m);

		/*
		 * The first four bytes of each transmit buffer are for
		 * control information.  The first byte is the control
		 * byte, then the length (why not word aligned?), then
		 * the offset to the buffer.
		 */

		if (LEMAC_USE_PIO_MODE(sc)) {
			/* Shift 2K window. */
			LEMAC_OUTB(sc, LEMAC_REG_IOP, tx_pg);
			LEMAC_OUTB(sc, LEMAC_REG_PI1, 0);
			LEMAC_OUTB(sc, LEMAC_REG_PI2, 0);
			LEMAC_OUTB(sc, LEMAC_REG_DAT, sc->sc_txctl);
			LEMAC_OUTB(sc, LEMAC_REG_DAT,
			    (m->m_pkthdr.len >> 0) & 0xFF);
			LEMAC_OUTB(sc, LEMAC_REG_DAT,
			    (m->m_pkthdr.len >> 8) & 0xFF);
			LEMAC_OUTB(sc, LEMAC_REG_DAT, LEMAC_TX_HDRSZ);
			for (m0 = m; m0 != NULL; m0 = m0->m_next)
				LEMAC_OUTSB(sc, LEMAC_REG_DAT,
				    m0->m_len, m0->m_data);
		} else {
			bus_size_t txoff = /* (mtod(m, u_int32_t) &
			    (sizeof(u_int32_t) - 1)) + */ LEMAC_TX_HDRSZ;
			/* Shift 2K window. */
			LEMAC_OUTB(sc, LEMAC_REG_MPN, tx_pg);
			LEMAC_PUT8(sc, 0, sc->sc_txctl);
			LEMAC_PUT8(sc, 1, (m->m_pkthdr.len >> 0) & 0xFF);
			LEMAC_PUT8(sc, 2, (m->m_pkthdr.len >> 8) & 0xFF);
			LEMAC_PUT8(sc, 3, txoff);

			/*
			 * Copy the packet to the board
			 */
			for (m0 = m; m0 != NULL; m0 = m0->m_next) {
#if 0
				LEMAC_PUTBUF8(sc, txoff, m0->m_len,
				    m0->m_data);
				txoff += m0->m_len;
#else
				const u_int8_t *cp = m0->m_data;
				int len = m0->m_len;
#if 0
				if ((txoff & 3) == (((long)cp) & 3) &&
				    len >= 4) {
					if (txoff & 3) {
						int alen = (~txoff & 3);
						LEMAC_PUTBUF8(sc, txoff, alen,
						    cp);
						cp += alen;
						txoff += alen;
						len -= alen;
					}
					if (len >= 4) {
						LEMAC_PUTBUF32(sc, txoff,
						    len / 4, cp);
						cp += len & ~3;
						txoff += len & ~3;
						len &= 3;
					}
				}
#endif
				if ((txoff & 1) == (((long)cp) & 1) &&
				    len >= 2) {
					if (txoff & 1) {
						int alen = (~txoff & 1);
						LEMAC_PUTBUF8(sc, txoff, alen,
						    cp);
						cp += alen;
						txoff += alen;
						len -= alen;
					}
					if (len >= 2) {
						LEMAC_PUTBUF16(sc, txoff,
						    len / 2, (void *)cp);
						cp += len & ~1;
						txoff += len & ~1;
						len &= 1;
					}
				}
				if (len > 0) {
					LEMAC_PUTBUF8(sc, txoff, len, cp);
					txoff += len;
				}
#endif
			}
		}

		/* tell chip to transmit this packet */
		LEMAC_OUTB(sc, LEMAC_REG_TQ, tx_pg);
#if NBPFILTER > 0
		if (sc->sc_if.if_bpf != NULL)
			bpf_mtap(sc->sc_if.if_bpf, m, BPF_DIRECTION_OUT);
#endif
		m_freem(m);			/* free the mbuf */
	}
	LEMAC_INTR_ENABLE(sc);
}

int
lemac_ifioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct lemac_softc *const sc = LEMAC_IFP_TO_SOFTC(ifp);
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		lemac_init(sc);
		break;

	case SIOCSIFFLAGS:
		lemac_init(sc);
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			lemac_init(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

int
lemac_ifmedia_change(struct ifnet *const ifp)
{
	struct lemac_softc *const sc = LEMAC_IFP_TO_SOFTC(ifp);
	unsigned new_ctl;

	switch (IFM_SUBTYPE(sc->sc_ifmedia.ifm_media)) {
	case IFM_10_T:
		new_ctl = LEMAC_CTL_APD;
		break;
	case IFM_10_2:
	case IFM_10_5:
		new_ctl = LEMAC_CTL_APD|LEMAC_CTL_PSL;
		break;
	case IFM_AUTO:
		new_ctl = 0;
		break;
	default:
		return (EINVAL);
	}
	if (sc->sc_ctlmode != new_ctl) {
		sc->sc_ctlmode = new_ctl;
		lemac_reset(sc);
		if (sc->sc_if.if_flags & IFF_UP)
			lemac_init(sc);
	}
	return (0);
}

/*
 * Media status callback
 */
void
lemac_ifmedia_status(struct ifnet *const ifp, struct ifmediareq *req)
{
	struct lemac_softc *sc = LEMAC_IFP_TO_SOFTC(ifp);
	unsigned data = LEMAC_INB(sc, LEMAC_REG_CNF);

	req->ifm_status = IFM_AVALID;
	if (sc->sc_flags & LEMAC_LINKUP)
		req->ifm_status |= IFM_ACTIVE;

	if (sc->sc_ctlmode & LEMAC_CTL_APD) {
		if (sc->sc_ctlmode & LEMAC_CTL_PSL) {
			req->ifm_active = IFM_10_5;
		} else {
			req->ifm_active = IFM_10_T;
		}
	} else {
		/*
		 * The link bit of the configuration register reflects the
		 * current media choice when auto-port is enabled.
		 */
		if (data & LEMAC_CNF_NOLINK) {
			req->ifm_active = IFM_10_5;
		} else {
			req->ifm_active = IFM_10_T;
		}
	}

	req->ifm_active |= IFM_ETHER;
}

int
lemac_port_check(const bus_space_tag_t iot, const bus_space_handle_t ioh)
{
	unsigned char hwaddr[6];

	if (lemac_read_macaddr(hwaddr, iot, ioh, LEMAC_REG_APD, 0) == 0)
		return (1);
	if (lemac_read_macaddr(hwaddr, iot, ioh, LEMAC_REG_APD, 1) == 0)
		return (1);
	return (0);
}

void
lemac_info_get(const bus_space_tag_t iot, const bus_space_handle_t ioh,
    bus_addr_t *maddr_p, bus_size_t *msize_p, int *irq_p)
{
	unsigned data;

	*irq_p = LEMAC_DECODEIRQ(bus_space_read_1(iot, ioh, LEMAC_REG_IC) &
	    LEMAC_IC_IRQMSK);

	data = bus_space_read_1(iot, ioh, LEMAC_REG_MBR);
	if (LEMAC_IS_2K_MODE(data)) {
		*maddr_p = data * (2 * 1024) + (512 * 1024);
		*msize_p =  2 * 1024;
	} else if (LEMAC_IS_64K_MODE(data)) {
		*maddr_p = data * 64 * 1024;
		*msize_p = 64 * 1024;
	} else if (LEMAC_IS_32K_MODE(data)) {
		*maddr_p = data * 32 * 1024;
		*msize_p = 32* 1024;
	} else {
		*maddr_p = 0;
		*msize_p = 0;
	}
}

/*
 * What to do upon receipt of an interrupt.
 */
int
lemac_intr(void *arg)
{
	struct lemac_softc *const sc = arg;
	int cs_value;

	LEMAC_INTR_DISABLE(sc);	/* Mask interrupts */

	/*
	 * Determine cause of interrupt.  Receive events take
	 * priority over Transmit.
	 */

	cs_value = LEMAC_INB(sc, LEMAC_REG_CS);

	/*
	 * Check for Receive Queue not being empty.
	 * Check for Transmit Done Queue not being empty.
	 */

	if (cs_value & LEMAC_CS_RNE)
		lemac_rne_intr(sc);
	if (cs_value & LEMAC_CS_TNE)
		lemac_tne_intr(sc);

	/*
	 * Check for Transmitter Disabled.
	 * Check for Receiver Disabled.
	 */

	if (cs_value & LEMAC_CS_TXD)
		lemac_txd_intr(sc, cs_value);
	if (cs_value & LEMAC_CS_RXD)
		lemac_rxd_intr(sc, cs_value);

	/*
	 * Toggle LED and unmask interrupts.
	 */

	sc->sc_csr.csr_cs = LEMAC_INB(sc, LEMAC_REG_CS);

	LEMAC_OUTB(sc, LEMAC_REG_CTL,
	    LEMAC_INB(sc, LEMAC_REG_CTL) ^ LEMAC_CTL_LED);
	LEMAC_INTR_ENABLE(sc);		/* Unmask interrupts */

#if 0
	if (cs_value)
		rnd_add_uint32(&sc->rnd_source, cs_value);
#endif

	return (1);
}

const char *const lemac_modes[4] = {
	"PIO mode (internal 2KB window)",
	"2KB window",
	"changed 32KB window to 2KB",
	"changed 64KB window to 2KB",
};

void
lemac_ifattach(struct lemac_softc *sc)
{
	struct ifnet *const ifp = &sc->sc_if;

	bcopy(sc->sc_dv.dv_xname, ifp->if_xname, IFNAMSIZ);

	lemac_reset(sc);

	lemac_read_macaddr(sc->sc_arpcom.ac_enaddr, sc->sc_iot, sc->sc_ioh,
	    LEMAC_REG_APD, 0);
	
	printf(": %s\n", sc->sc_prodname);

	printf("%s: address %s, %dKB RAM, %s\n", ifp->if_xname,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr), sc->sc_lastpage * 2 + 2,
	    lemac_modes[sc->sc_flags & LEMAC_MODE_MASK]);

	ifp->if_softc = (void *)sc;
	ifp->if_start = lemac_ifstart;
	ifp->if_ioctl = lemac_ifioctl;

	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;

	if (sc->sc_flags & LEMAC_ALIVE) {
		uint64_t media;

		if_attach(ifp);
		ether_ifattach(ifp);

#if 0
		rnd_attach_source(&sc->rnd_source, sc->sc_dv.dv_xname,
		    RND_TYPE_NET, 0);
#endif

		ifmedia_init(&sc->sc_ifmedia, 0, lemac_ifmedia_change,
		    lemac_ifmedia_status);
		if (sc->sc_prodname[4] == '5')	/* DE205 is UTP/AUI */
			ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_AUTO, 0,
			    0);
		if (sc->sc_prodname[4] != '3')	/* DE204 & 205 have UTP */
			ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T, 0,
			    0);
		if (sc->sc_prodname[4] != '4')	/* DE203 & 205 have BNC */
			ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_5, 0,
			    0);
		switch (sc->sc_prodname[4]) {
		case '3':
			media = IFM_10_5;
			break;
		case '4':
			media = IFM_10_T;
			break;
		default:
			media = IFM_AUTO;
			break;
		}
		ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | media);
	} else {
		printf("%s: disabled due to error\n", ifp->if_xname);
	}
}
@


1.29
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.28 2015/12/08 13:34:22 tedu Exp $ */
a155 1
		sc->sc_if.if_opackets++;		/* another one done */
@


1.28
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.27 2015/11/25 11:20:38 mpi Exp $ */
a995 2

		IFQ_SET_READY(&ifp->if_snd);
@


1.27
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.26 2015/11/25 03:09:58 dlg Exp $ */
d992 1
a992 5
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX
#ifdef IFF_NOTRAILERS
		| IFF_NOTRAILERS
#endif
		| IFF_MULTICAST;
@


1.26
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.25 2015/11/24 17:11:39 mpi Exp $ */
a47 1
#include <net/route.h>
@


1.25
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.24 2015/11/24 13:33:17 mpi Exp $ */
d169 1
a169 1
	sc->sc_if.if_flags &= ~IFF_OACTIVE;
d192 1
a192 1
	sc->sc_if.if_flags &= ~IFF_OACTIVE;
d507 1
a507 1
	sc->sc_if.if_flags &= ~IFF_OACTIVE;
d650 1
a650 1
			ifp->if_flags |= IFF_OACTIVE;
d665 1
a665 1
			ifp->if_flags |= IFF_OACTIVE;
@


1.24
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.23 2015/11/20 03:35:22 dlg Exp $ */
a47 1
#include <net/if_dl.h>
@


1.23
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.22 2015/10/25 12:48:46 mpi Exp $ */
a47 1
#include <net/if_types.h>
@


1.22
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.21 2015/09/11 13:02:28 stsp Exp $ */
d644 1
a644 1
		IFQ_POLL(&ifp->if_snd, m);
d651 1
d666 1
d671 1
a671 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.21
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.20 2015/06/24 09:40:54 mpi Exp $ */
a773 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a782 8
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;

		default:
			break;
		}
@


1.20
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.19 2015/04/06 09:13:55 miod Exp $ */
d1009 1
a1009 1
		int media;
@


1.19
log
@Convert to if_input(); ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.18 2014/12/22 02:28:51 tedu Exp $ */
a314 1
		ifp->if_ipackets++;
@


1.18
log
@unifdef INET
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.17 2014/07/22 13:12:12 mpi Exp $ */
d72 1
a72 1
void	lemac_input(struct lemac_softc *, bus_size_t, size_t);
d258 1
a258 1
void
d265 2
a266 4
	    length - sizeof(eh) < ETHERMIN) {
		sc->sc_if.if_ierrors++;
		return;
	}
d274 2
a275 4
	if (m == NULL) {
		sc->sc_if.if_ierrors++;
		return;
	}
d280 1
a280 2
			sc->sc_if.if_ierrors++;
			return;
a295 5
#if NBPFILTER > 0
	if (sc->sc_if.if_bpf != NULL) {
		m->m_pkthdr.len = m->m_len = length;
		bpf_mtap(sc->sc_if.if_bpf, m, BPF_DIRECTION_IN);
	}
a296 10
	/*
	 * If this is single cast but not to us
	 * drop it!
	 */
	if ((eh.ether_dhost[0] & 1) == 0 &&
	    !LEMAC_ADDREQUAL(eh.ether_dhost, sc->sc_arpcom.ac_enaddr)) {
		m_freem(m);
		return;
	}
#endif
d298 1
a298 2
	m->m_pkthdr.rcvif = &sc->sc_if;
	ether_input_mbuf(&sc->sc_if, m);
d304 3
d315 1
a315 1
		sc->sc_if.if_ipackets++;
d332 9
a340 4
			lemac_input(sc, sizeof(rxlen), rxlen);
		} else {
			sc->sc_if.if_ierrors++;
		}
d345 1
a345 1
	return;
@


1.17
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.16 2014/07/08 17:19:25 deraadt Exp $ */
a52 1
#ifdef INET
a54 1
#endif
a798 1
#ifdef INET
a801 1
#endif /* INET */
@


1.16
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.15 2013/11/26 09:50:33 mpi Exp $ */
a54 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.15
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.14 2013/08/07 01:06:30 bluhm Exp $ */
a63 4

#if 0
#include <uvm/uvm_extern.h>
#endif
@


1.14
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.13 2009/08/10 22:08:04 deraadt Exp $ */
d493 1
d503 7
a509 1
	ETHER_FIRST_MULTI(step, &sc->sc_ec, enm);
a510 5
		if (!LEMAC_ADDREQUAL(enm->enm_addrlo, enm->enm_addrhi)) {
			sc->sc_flags |= LEMAC_ALLMULTI;
			sc->sc_if.if_flags |= IFF_ALLMULTI;
			return;
		}
@


1.13
log
@This does not need a shutdown function either (though the equilevant
to stop is not called because the ioctl function is a masterpiece)
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.12 2008/11/28 02:44:17 brad Exp $ */
a55 1
#include <netinet/in_var.h>
@


1.12
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.11 2008/10/02 20:21:13 brad Exp $ */
a993 6
}

void
lemac_shutdown(void *arg)
{
	lemac_reset((struct lemac_softc *)arg);
@


1.11
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.10 2006/04/16 16:32:08 miod Exp $ */
a794 2
	int s;
	int error = 0;
d797 1
a820 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		/*
		 * Update multicast listeners
		 */
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/* Reset multicast filtering. */
			if (ifp->if_flags & IFF_RUNNING)
				lemac_init(sc);
			error = 0;
		}
		break;

d823 1
a823 10
		error = ifmedia_ioctl(ifp, (struct ifreq *)data,
		    &sc->sc_ifmedia, cmd);
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
d828 6
@


1.10
log
@Correctly computed the mac address checksum on big-endian platforms.
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.9 2006/03/25 22:41:43 djm Exp $ */
a801 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d854 1
a854 2
		error = EINVAL;
		break;
@


1.9
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.8 2005/11/14 14:46:41 mickey Exp $ */
d416 1
d418 3
d427 1
d429 3
d440 1
d442 3
@


1.8
log
@register offsets [against bh] are expected bus_size_t and not bus_addr_t
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.7 2005/06/08 17:03:00 henning Exp $ */
d313 1
a313 1
		bpf_mtap(sc->sc_if.if_bpf, m);
d772 1
a772 1
			bpf_mtap(sc->sc_if.if_bpf, m);
@


1.7
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.6 2005/01/15 05:24:11 brad Exp $ */
d81 1
a81 1
void	lemac_input(struct lemac_softc *, bus_addr_t, size_t);
d86 1
a86 1
    const bus_space_handle_t, const bus_addr_t, int);
d268 1
a268 1
lemac_input(struct lemac_softc *sc, bus_addr_t offset, size_t length)
d376 1
a376 1
    const bus_space_handle_t ioh, const bus_addr_t ioreg, int skippat)
@


1.6
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.5 2003/10/30 02:30:48 itojun Exp $ */
a60 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a804 18

#ifdef NS
		/* This magic copied from if_is.c; I don't use XNS,
		 * so I have no way of telling if this actually
		 * works or not.
		 */
		case AF_NS: {
			struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);
			if (ns_nullhost(*ina)) {
				ina->x_host =
				    *(union ns_host *)sc->sc_arpcom.ac_enaddr;
			} else {
				bcopy((caddr_t)ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);
			}
			break;
		}
#endif /* NS */
@


1.5
log
@array for multicast filter intialization mismatches.  millert ok
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.4 2003/10/21 18:58:49 jmc Exp $ */
d849 2
a850 1
			lemac_init(sc);
@


1.4
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.3 2002/05/07 19:28:59 nate Exp $ */
d102 5
a106 1
static const u_int16_t lemac_allmulti_mctbl[16] = {
@


1.3
log
@move ether_crc32_le to if_ethersubr.c.  Add ether_crc32_be
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.2 2002/02/25 08:48:30 niklas Exp $ */
d156 1
a156 1
	 *  Error during initializion.  Mark card as disabled.
d413 1
a413 1
	/* hardware adddress can't be multicast */
@


1.2
log
@Accept ethernet broadcasts too :-)  This patch contains a copy of
ether_crc32_le from NetBSD, which might be bettter placed in if_ethersubr.c
later, if any other driver needs it.
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.2 2002/02/25 08:38:38 niklas Exp $ */
a79 3
/* XXX Should be in if_ethersubr.c */
u_int32_t ether_crc32_le(const u_int8_t *, size_t);

a446 24
}

/* XXX Should be moved to if_ethersubr.c */
u_int32_t
ether_crc32_le(const u_int8_t *buf, size_t len)
{
	static const u_int32_t crctab[] = {
		0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
		0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
		0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
	};
	u_int32_t crc;
	int i;

	crc = 0xffffffffU;	/* initial value */

	for (i = 0; i < len; i++) {
		crc ^= buf[i];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
	}

	return (crc);
@


1.1
log
@On my 10th wedding anniversary I am celebrating by
committing this driver for technology from back when I got married :-)
It is for DEC EtherWorks cards, and comes from NetBSD.  I have done severe
KNF, and fixed the driver to work with PIO-only cards. Enjoy!
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.20 2001/06/13 10:46:02 wiz Exp $ */
d80 3
d452 24
a475 1
#if 0
a504 1
#endif
a515 1
#if 0
d518 1
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: lemac.c,v 1.1 2001/07/13 17:26:44 niklas Exp $ */
d449 1
d479 1
d491 1
a493 1
#if 0
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.1.4.2
log
@Merge in trunk
@
text
@a79 3
/* XXX Should be in if_ethersubr.c */
u_int32_t ether_crc32_le(const u_int8_t *, size_t);

d449 1
a449 24
/* XXX Should be moved to if_ethersubr.c */
u_int32_t
ether_crc32_le(const u_int8_t *buf, size_t len)
{
	static const u_int32_t crctab[] = {
		0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
		0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
		0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
	};
	u_int32_t crc;
	int i;

	crc = 0xffffffffU;	/* initial value */

	for (i = 0; i < len; i++) {
		crc ^= buf[i];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
	}

	return (crc);
}

d479 1
d491 1
a493 1
#if 0
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d80 3
d450 24
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d102 1
a102 5
static const u_int16_t lemac_allmulti_mctbl[LEMAC_MCTBL_SIZE/sizeof(u_int16_t)] = {
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
	0xFFFFU, 0xFFFFU, 0xFFFFU, 0xFFFFU,
d156 1
a156 1
	 *  Error during initialization.  Mark card as disabled.
d413 1
a413 1
	/* hardware address can't be multicast */
@


