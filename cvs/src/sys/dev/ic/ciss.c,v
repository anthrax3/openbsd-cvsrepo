head	1.75;
access;
symbols
	OPENBSD_6_2:1.75.0.6
	OPENBSD_6_2_BASE:1.75
	OPENBSD_6_1:1.75.0.4
	OPENBSD_6_1_BASE:1.75
	OPENBSD_6_0:1.74.0.6
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.73.0.4
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.70.0.4
	OPENBSD_5_6_BASE:1.70
	OPENBSD_5_5:1.68.0.6
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.68.0.2
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.67.0.6
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.67.0.2
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.4
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.34.0.4
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.75
date	2016.08.14.04.08.03;	author dlg;	state Exp;
branches;
next	1.74;
commitid	7Sh26Zh99sH8viYr;

1.74
date	2015.09.09.18.23.55;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	pxEWup0rbECbQnbF;

1.73
date	2015.05.03.02.10.13;	author jsg;	state Exp;
branches;
next	1.72;
commitid	DmfrAmpb3K0IXIua;

1.72
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.71;
commitid	p4LJxGKbi0BU2cG6;

1.71
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.70;
commitid	uzzBR7hz9ncd4O6G;

1.70
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	JtO5uXxVcnZfhUkR;

1.69
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.68;
commitid	I19imNlAX05zJOED;

1.68
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2011.11.10.12.05.11;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.05.19.54.35;	author jasper;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.20.04.08.36;	author dlg;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.07.10.12.13;	author dlg;	state Exp;
branches;
next	1.60;

1.60
date	2010.07.02.08.12.17;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	2010.07.01.16.24.37;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.26.22.14.32;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.54;

1.54
date	2010.06.03.01.03.55;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2010.06.03.01.02.13;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2010.06.03.00.56.42;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.02.13.34.21;	author dlg;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.02.05.38.00;	author dlg;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.02.05.07.58;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.02.01.45.14;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.02.01.33.57;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.02.01.27.20;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2010.06.02.01.18.36;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.02.01.16.12;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.31.19.35.03;	author halex;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.41;

1.41
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.09.06.35.11;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.07.11.03.37;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.07.10.58.37;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2009.12.17.19.42.39;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.15.14.13.12;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2009.04.29.08.24.26;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2008.11.10.15.55.06;	author cnst;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.24.09.04.14;	author jakob;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.20.16.10.09;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.18.00.46.41;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.29.22.17.50;	author todd;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.18.14.46.24;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.15.23.47.52;	author krw;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2006.08.31.23.19.35;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.28.02.56.33;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.28.02.50.14;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.28.01.32.06;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.27.22.12.10;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.27.20.51.09;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.13.16.02.23;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.02.22.13.04;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.13.15.55.58;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.12.11.31.54;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.02.11.35.10;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.23.14.46.47;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.18.14.08.04;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.07.04.00.16;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.20.18.01.35;	author mickey;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2005.08.03.00.09.38;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.03.00.01.08;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.02.23.56.34;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.01.23.55.22;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.06.01.52.13;	author mickey;	state Exp;
branches;
next	;

1.6.2.1
date	2005.12.22.04.20.17;	author brad;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2006.01.11.01.18.32;	author brad;	state Exp;
branches;
next	;

1.21.2.1
date	2007.03.14.03.50.27;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.75
log
@change some types in bio from u_quad_t to uint64_t, and fix casts in
drivers that fill that field in too.

quad types are going away.
@
text
@/*	$OpenBSD: ciss.c,v 1.74 2015/09/09 18:23:55 deraadt Exp $	*/

/*
 * Copyright (c) 2005,2006 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

/* #define CISS_DEBUG */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/cissreg.h>
#include <dev/ic/cissvar.h>

#if NBIO > 0
#include <dev/biovar.h>
#endif
#include <sys/sensors.h>

#ifdef CISS_DEBUG
#define	CISS_DPRINTF(m,a)	if (ciss_debug & (m)) printf a
#define	CISS_D_CMD	0x0001
#define	CISS_D_INTR	0x0002
#define	CISS_D_MISC	0x0004
#define	CISS_D_DMA	0x0008
#define	CISS_D_IOCTL	0x0010
#define	CISS_D_ERR	0x0020
int ciss_debug = 0
/*	| CISS_D_CMD */
/*	| CISS_D_INTR */
/*	| CISS_D_MISC */
/*	| CISS_D_DMA */
/*	| CISS_D_IOCTL */
/*	| CISS_D_ERR */
	;
#else
#define	CISS_DPRINTF(m,a)	/* m, a */
#endif

struct cfdriver ciss_cd = {
	NULL, "ciss", DV_DULL
};

void	ciss_scsi_cmd(struct scsi_xfer *xs);
int	ciss_scsi_ioctl(struct scsi_link *, u_long, caddr_t, int);
void	cissminphys(struct buf *bp, struct scsi_link *sl);

struct scsi_adapter ciss_switch = {
	ciss_scsi_cmd, cissminphys, NULL, NULL, ciss_scsi_ioctl
};

#if NBIO > 0
int	ciss_ioctl(struct device *, u_long, caddr_t);
#endif
int	ciss_sync(struct ciss_softc *sc);
void	ciss_heartbeat(void *v);
#ifndef SMALL_KERNEL
void	ciss_sensors(void *);
#endif

void *	ciss_get_ccb(void *);
void	ciss_put_ccb(void *, void *);
int	ciss_cmd(struct ciss_ccb *ccb, int flags, int wait);
int	ciss_done(struct ciss_ccb *ccb);
int	ciss_error(struct ciss_ccb *ccb);

struct ciss_ld *ciss_pdscan(struct ciss_softc *sc, int ld);
int	ciss_inq(struct ciss_softc *sc, struct ciss_inquiry *inq);
int	ciss_ldmap(struct ciss_softc *sc);
int	ciss_ldid(struct ciss_softc *, int, struct ciss_ldid *);
int	ciss_ldstat(struct ciss_softc *, int, struct ciss_ldstat *);
int	ciss_pdid(struct ciss_softc *, u_int8_t, struct ciss_pdid *, int);
int	ciss_blink(struct ciss_softc *, int, int, int, struct ciss_blink *);

void *
ciss_get_ccb(void *xsc)
{
	struct ciss_softc *sc = xsc;
	struct ciss_ccb *ccb;

	mtx_enter(&sc->sc_free_ccb_mtx);
	ccb = SLIST_FIRST(&sc->sc_free_ccb);
	if (ccb != NULL) {
		SLIST_REMOVE_HEAD(&sc->sc_free_ccb, ccb_link);
		ccb->ccb_state = CISS_CCB_READY;
		ccb->ccb_xs = NULL;
	}
	mtx_leave(&sc->sc_free_ccb_mtx);

	return (ccb);
}

void
ciss_put_ccb(void *xsc, void *xccb)
{
	struct ciss_softc *sc = xsc;
	struct ciss_ccb *ccb = xccb;

	ccb->ccb_state = CISS_CCB_FREE;
	ccb->ccb_xs = NULL;
	ccb->ccb_data = NULL;

	mtx_enter(&sc->sc_free_ccb_mtx);
	SLIST_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_link);
	mtx_leave(&sc->sc_free_ccb_mtx);
}

int
ciss_attach(struct ciss_softc *sc)
{
	struct scsibus_attach_args saa;
	struct scsibus_softc *scsibus;
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	struct ciss_inquiry *inq;
	bus_dma_segment_t seg[1];
	int error, i, total, rseg, maxfer;
	ciss_lock_t lock;
	paddr_t pa;

	bus_space_read_region_4(sc->iot, sc->cfg_ioh, sc->cfgoff,
	    (u_int32_t *)&sc->cfg, sizeof(sc->cfg) / 4);

	if (sc->cfg.signature != CISS_SIGNATURE) {
		printf(": bad sign 0x%08x\n", sc->cfg.signature);
		return -1;
	}

	if (!(sc->cfg.methods & CISS_METH_SIMPL)) {
		printf(": not simple 0x%08x\n", sc->cfg.methods);
		return -1;
	}

	sc->cfg.rmethod = CISS_METH_SIMPL;
	sc->cfg.paddr_lim = 0;			/* 32bit addrs */
	sc->cfg.int_delay = 0;			/* disable coalescing */
	sc->cfg.int_count = 0;
	strlcpy(sc->cfg.hostname, "HUMPPA", sizeof(sc->cfg.hostname));
	sc->cfg.driverf |= CISS_DRV_PRF;	/* enable prefetch */
	if (!sc->cfg.maxsg)
		sc->cfg.maxsg = MAXPHYS / PAGE_SIZE;

	bus_space_write_region_4(sc->iot, sc->cfg_ioh, sc->cfgoff,
	    (u_int32_t *)&sc->cfg, sizeof(sc->cfg) / 4);
	bus_space_barrier(sc->iot, sc->cfg_ioh, sc->cfgoff, sizeof(sc->cfg),
	    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);

	bus_space_write_4(sc->iot, sc->ioh, CISS_IDB, CISS_IDB_CFG);
	bus_space_barrier(sc->iot, sc->ioh, CISS_IDB, 4,
	    BUS_SPACE_BARRIER_WRITE);
	for (i = 1000; i--; DELAY(1000)) {
		/* XXX maybe IDB is really 64bit? - hp dl380 needs this */
		(void)bus_space_read_4(sc->iot, sc->ioh, CISS_IDB + 4);
		if (!(bus_space_read_4(sc->iot, sc->ioh, CISS_IDB) & CISS_IDB_CFG))
			break;
		bus_space_barrier(sc->iot, sc->ioh, CISS_IDB, 4,
		    BUS_SPACE_BARRIER_READ);
	}

	if (bus_space_read_4(sc->iot, sc->ioh, CISS_IDB) & CISS_IDB_CFG) {
		printf(": cannot set config\n");
		return -1;
	}

	bus_space_read_region_4(sc->iot, sc->cfg_ioh, sc->cfgoff,
	    (u_int32_t *)&sc->cfg, sizeof(sc->cfg) / 4);

	if (!(sc->cfg.amethod & CISS_METH_SIMPL)) {
		printf(": cannot simplify 0x%08x\n", sc->cfg.amethod);
		return -1;
	}

	/* i'm ready for you and i hope you're ready for me */
	for (i = 30000; i--; DELAY(1000)) {
		if (bus_space_read_4(sc->iot, sc->cfg_ioh, sc->cfgoff +
		    offsetof(struct ciss_config, amethod)) & CISS_METH_READY)
			break;
		bus_space_barrier(sc->iot, sc->cfg_ioh, sc->cfgoff +
		    offsetof(struct ciss_config, amethod), 4,
		    BUS_SPACE_BARRIER_READ);
	}

	if (!(bus_space_read_4(sc->iot, sc->cfg_ioh, sc->cfgoff +
	    offsetof(struct ciss_config, amethod)) & CISS_METH_READY)) {
		printf(": she never came ready for me 0x%08x\n",
		    sc->cfg.amethod);
		return -1;
	}

	sc->maxcmd = sc->cfg.maxcmd;
	sc->maxsg = sc->cfg.maxsg;
	if (sc->maxsg > MAXPHYS / PAGE_SIZE)
		sc->maxsg = MAXPHYS / PAGE_SIZE;
	i = sizeof(struct ciss_ccb) +
	    sizeof(ccb->ccb_cmd.sgl[0]) * (sc->maxsg - 1);
	for (sc->ccblen = 0x10; sc->ccblen < i; sc->ccblen <<= 1);

	total = sc->ccblen * sc->maxcmd;
	if ((error = bus_dmamem_alloc(sc->dmat, total, PAGE_SIZE, 0,
	    sc->cmdseg, 1, &rseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO))) {
		printf(": cannot allocate CCBs (%d)\n", error);
		return -1;
	}

	if ((error = bus_dmamem_map(sc->dmat, sc->cmdseg, rseg, total,
	    (caddr_t *)&sc->ccbs, BUS_DMA_NOWAIT))) {
		printf(": cannot map CCBs (%d)\n", error);
		return -1;
	}

	if ((error = bus_dmamap_create(sc->dmat, total, 1,
	    total, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->cmdmap))) {
		printf(": cannot create CCBs dmamap (%d)\n", error);
		bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
		return -1;
	}

	if ((error = bus_dmamap_load(sc->dmat, sc->cmdmap, sc->ccbs, total,
	    NULL, BUS_DMA_NOWAIT))) {
		printf(": cannot load CCBs dmamap (%d)\n", error);
		bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
		bus_dmamap_destroy(sc->dmat, sc->cmdmap);
		return -1;
	}

	SLIST_INIT(&sc->sc_free_ccb);
	mtx_init(&sc->sc_free_ccb_mtx, IPL_BIO);

	maxfer = sc->maxsg * PAGE_SIZE;
	for (i = 0; total; i++, total -= sc->ccblen) {
		ccb = sc->ccbs + i * sc->ccblen;
		cmd = &ccb->ccb_cmd;
		pa = sc->cmdseg[0].ds_addr + i * sc->ccblen;

		ccb->ccb_sc = sc;
		ccb->ccb_cmdpa = pa + offsetof(struct ciss_ccb, ccb_cmd);
		ccb->ccb_state = CISS_CCB_FREE;

		cmd->id = htole32(i << 2);
		cmd->id_hi = htole32(0);
		cmd->sgin = sc->maxsg;
		cmd->sglen = htole16((u_int16_t)cmd->sgin);
		cmd->err_len = htole32(sizeof(ccb->ccb_err));
		pa += offsetof(struct ciss_ccb, ccb_err);
		cmd->err_pa = htole64((u_int64_t)pa);

		if ((error = bus_dmamap_create(sc->dmat, maxfer, sc->maxsg,
		    maxfer, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &ccb->ccb_dmamap)))
			break;

		SLIST_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_link);
	}

	scsi_iopool_init(&sc->sc_iopool, sc, ciss_get_ccb, ciss_put_ccb);

	if (i < sc->maxcmd) {
		printf(": cannot create ccb#%d dmamap (%d)\n", i, error);
		if (i == 0) {
			/* TODO leaking cmd's dmamaps and shitz */
			bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
			bus_dmamap_destroy(sc->dmat, sc->cmdmap);
			return -1;
		}
	}

	if ((error = bus_dmamem_alloc(sc->dmat, PAGE_SIZE, PAGE_SIZE, 0,
	    seg, 1, &rseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO))) {
		printf(": cannot allocate scratch buffer (%d)\n", error);
		return -1;
	}

	if ((error = bus_dmamem_map(sc->dmat, seg, rseg, PAGE_SIZE,
	    (caddr_t *)&sc->scratch, BUS_DMA_NOWAIT))) {
		printf(": cannot map scratch buffer (%d)\n", error);
		return -1;
	}

	lock = CISS_LOCK_SCRATCH(sc);
	inq = sc->scratch;
	if (ciss_inq(sc, inq)) {
		printf(": adapter inquiry failed\n");
		CISS_UNLOCK_SCRATCH(sc, lock);
		bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
		bus_dmamap_destroy(sc->dmat, sc->cmdmap);
		return -1;
	}

	if (!(inq->flags & CISS_INQ_BIGMAP)) {
		printf(": big map is not supported, flags=%b\n",
		    inq->flags, CISS_INQ_BITS);
		CISS_UNLOCK_SCRATCH(sc, lock);
		bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
		bus_dmamap_destroy(sc->dmat, sc->cmdmap);
		return -1;
	}

	sc->maxunits = inq->numld;
	sc->nbus = inq->nscsi_bus;
	sc->ndrives = inq->buswidth? inq->buswidth : 256;
	printf(": %d LD%s, HW rev %d, FW %4.4s/%4.4s",
	    inq->numld, inq->numld == 1? "" : "s",
	    inq->hw_rev, inq->fw_running, inq->fw_stored);
	if (sc->cfg.methods & CISS_METH_FIFO64)
		printf(", 64bit fifo");
	else if (sc->cfg.methods & CISS_METH_FIFO64_RRO)
		printf(", 64bit fifo rro");
	printf("\n");

	CISS_UNLOCK_SCRATCH(sc, lock);

	timeout_set(&sc->sc_hb, ciss_heartbeat, sc);
	timeout_add_sec(&sc->sc_hb, 3);

	/* map LDs */
	if (ciss_ldmap(sc)) {
		printf("%s: adapter LD map failed\n", sc->sc_dev.dv_xname);
		bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
		bus_dmamap_destroy(sc->dmat, sc->cmdmap);
		return -1;
	}

	if (!(sc->sc_lds = mallocarray(sc->maxunits, sizeof(*sc->sc_lds),
	    M_DEVBUF, M_NOWAIT | M_ZERO))) {
		bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
		bus_dmamap_destroy(sc->dmat, sc->cmdmap);
		return -1;
	}

	sc->sc_flush = CISS_FLUSH_ENABLE;

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.openings = sc->maxcmd;
	sc->sc_link.adapter = &ciss_switch;
	sc->sc_link.luns = 1;
	sc->sc_link.adapter_target = sc->maxunits;
	sc->sc_link.adapter_buswidth = sc->maxunits;
	sc->sc_link.pool = &sc->sc_iopool;
	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;
	scsibus = (struct scsibus_softc *)config_found_sm(&sc->sc_dev,
	    &saa, scsiprint, NULL);

#if NBIO > 0
	/* XXX for now we can only deal w/ one volume. */
	if (!scsibus || sc->maxunits > 1)
		return 0;

	/* now map all the physdevs into their lds */
	/* XXX currently we assign all pf 'em into ld#0 */
	for (i = 0; i < sc->maxunits; i++)
		if (!(sc->sc_lds[i] = ciss_pdscan(sc, i)))
			return 0;

	if (bio_register(&sc->sc_dev, ciss_ioctl) != 0)
		printf("%s: controller registration failed",
		    sc->sc_dev.dv_xname);

	sc->sc_flags |= CISS_BIO;
#ifndef SMALL_KERNEL
	sc->sensors = mallocarray(sc->maxunits, sizeof(struct ksensor),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sensors) {
		struct device *dev;

		strlcpy(sc->sensordev.xname, sc->sc_dev.dv_xname,
		    sizeof(sc->sensordev.xname));
		for (i = 0; i < sc->maxunits; i++) {
			sc->sensors[i].type = SENSOR_DRIVE;
			sc->sensors[i].status = SENSOR_S_UNKNOWN;
			dev = scsi_get_link(scsibus, i, 0)->device_softc;
			strlcpy(sc->sensors[i].desc, dev->dv_xname,
			    sizeof(sc->sensors[i].desc));
			strlcpy(sc->sc_lds[i]->xname, dev->dv_xname,
			    sizeof(sc->sc_lds[i]->xname));
			sensor_attach(&sc->sensordev, &sc->sensors[i]);
		}
		if (sensor_task_register(sc, ciss_sensors, 10) == NULL)
			free(sc->sensors, M_DEVBUF,
			    sc->maxunits * sizeof(struct ksensor));
		else
			sensordev_install(&sc->sensordev);
	}
#endif /* SMALL_KERNEL */
#endif /* BIO > 0 */

	return 0;
}

void
ciss_shutdown(void *v)
{
	struct ciss_softc *sc = v;

	sc->sc_flush = CISS_FLUSH_DISABLE;
	timeout_del(&sc->sc_hb);
	ciss_sync(sc);
}

void
cissminphys(struct buf *bp, struct scsi_link *sl)
{
#if 0	/* TODO */
#define	CISS_MAXFER	(PAGE_SIZE * (sc->maxsg + 1))
	if (bp->b_bcount > CISS_MAXFER)
		bp->b_bcount = CISS_MAXFER;
#endif
	minphys(bp);
}

/*
 * submit a command and optionally wait for completition.
 * wait arg abuses SCSI_POLL|SCSI_NOSLEEP flags to request
 * to wait (SCSI_POLL) and to allow tsleep() (!SCSI_NOSLEEP)
 * instead of busy loop waiting
 */
int
ciss_cmd(struct ciss_ccb *ccb, int flags, int wait)
{
	struct ciss_softc *sc = ccb->ccb_sc;
	struct ciss_cmd *cmd = &ccb->ccb_cmd;
	struct ciss_ccb *ccb1;
	bus_dmamap_t dmap = ccb->ccb_dmamap;
	u_int64_t addr;
	u_int32_t id;
	int i, tohz, error = 0;

	splassert(IPL_BIO);

	if (ccb->ccb_state != CISS_CCB_READY) {
		printf("%s: ccb %d not ready state=%b\n", sc->sc_dev.dv_xname,
		    cmd->id, ccb->ccb_state, CISS_CCB_BITS);
		return (EINVAL);
	}

	if (ccb->ccb_data) {
		bus_dma_segment_t *sgd;

		if ((error = bus_dmamap_load(sc->dmat, dmap, ccb->ccb_data,
		    ccb->ccb_len, NULL, flags))) {
			if (error == EFBIG)
				printf("more than %d dma segs\n", sc->maxsg);
			else
				printf("error %d loading dma map\n", error);
			if (ccb->ccb_xs) {
				ccb->ccb_xs->error = XS_DRIVER_STUFFUP;
				scsi_done(ccb->ccb_xs);
				ccb->ccb_xs = NULL;
			}
			return (error);
		}
		cmd->sgin = dmap->dm_nsegs;

		sgd = dmap->dm_segs;
		CISS_DPRINTF(CISS_D_DMA, ("data=%p/%u<0x%lx/%u",
		    ccb->ccb_data, ccb->ccb_len, sgd->ds_addr, sgd->ds_len));

		for (i = 0; i < dmap->dm_nsegs; sgd++, i++) {
			cmd->sgl[i].addr_lo = htole32(sgd->ds_addr);
			cmd->sgl[i].addr_hi =
			    htole32((u_int64_t)sgd->ds_addr >> 32);
			cmd->sgl[i].len = htole32(sgd->ds_len);
			cmd->sgl[i].flags = htole32(0);
			if (i)
				CISS_DPRINTF(CISS_D_DMA,
				    (",0x%lx/%u", sgd->ds_addr, sgd->ds_len));
		}

		CISS_DPRINTF(CISS_D_DMA, ("> "));

		bus_dmamap_sync(sc->dmat, dmap, 0, dmap->dm_mapsize,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	} else
		cmd->sgin = 0;
	cmd->sglen = htole16((u_int16_t)cmd->sgin);
	bzero(&ccb->ccb_err, sizeof(ccb->ccb_err));

	bus_dmamap_sync(sc->dmat, sc->cmdmap, 0, sc->cmdmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ccb->ccb_state = CISS_CCB_ONQ;
	CISS_DPRINTF(CISS_D_CMD, ("submit=0x%x ", cmd->id));
	if (sc->cfg.methods & (CISS_METH_FIFO64|CISS_METH_FIFO64_RRO)) {
		/*
		 * Write the upper 32bits immediately before the lower
		 * 32bits and set bit 63 to indicate 64bit FIFO mode.
		 */
		addr = (u_int64_t)ccb->ccb_cmdpa;
		bus_space_write_4(sc->iot, sc->ioh, CISS_INQ64_HI,
		    (addr >> 32) | 0x80000000);
		bus_space_write_4(sc->iot, sc->ioh, CISS_INQ64_LO,
		    addr & 0x00000000ffffffffULL);
	} else
		bus_space_write_4(sc->iot, sc->ioh, CISS_INQ, ccb->ccb_cmdpa);

	if (wait & SCSI_POLL) {
		struct timeval tv;
		int etick;
		CISS_DPRINTF(CISS_D_CMD, ("waiting "));

		i = ccb->ccb_xs? ccb->ccb_xs->timeout : 60000;
		tv.tv_sec = i / 1000;
		tv.tv_usec = (i % 1000) * 1000;
		tohz = tvtohz(&tv);
		if (tohz == 0)
			tohz = 1;
		for (i *= 100, etick = tick + tohz; i--; ) {
			if (!(wait & SCSI_NOSLEEP)) {
				ccb->ccb_state = CISS_CCB_POLL;
				CISS_DPRINTF(CISS_D_CMD, ("tsleep(%d) ", tohz));
				if (tsleep(ccb, PRIBIO + 1, "ciss_cmd",
				    tohz) == EWOULDBLOCK) {
					break;
				}
				if (ccb->ccb_state != CISS_CCB_ONQ) {
					tohz = etick - tick;
					if (tohz <= 0)
						break;
					CISS_DPRINTF(CISS_D_CMD, ("T"));
					continue;
				}
				ccb1 = ccb;
			} else {
				DELAY(10);

				if (!(bus_space_read_4(sc->iot, sc->ioh,
				    CISS_ISR) & sc->iem)) {
					CISS_DPRINTF(CISS_D_CMD, ("N"));
					continue;
				}

				if (sc->cfg.methods & CISS_METH_FIFO64) {
					if (bus_space_read_4(sc->iot, sc->ioh,
					    CISS_OUTQ64_HI) == 0xffffffff) {
						CISS_DPRINTF(CISS_D_CMD, ("Q"));
						continue;
					}
					id = bus_space_read_4(sc->iot, sc->ioh,
					    CISS_OUTQ64_LO);
				} else if (sc->cfg.methods &
				    CISS_METH_FIFO64_RRO) {
					id = bus_space_read_4(sc->iot, sc->ioh,
					    CISS_OUTQ64_LO);
					if (id == 0xffffffff) {
						CISS_DPRINTF(CISS_D_CMD, ("Q"));
						continue;
					}
					(void)bus_space_read_4(sc->iot,
					    sc->ioh, CISS_OUTQ64_HI);
				} else {
					id = bus_space_read_4(sc->iot, sc->ioh,
					    CISS_OUTQ);
					if (id == 0xffffffff) {
						CISS_DPRINTF(CISS_D_CMD, ("Q"));
						continue;
					}
				}

				CISS_DPRINTF(CISS_D_CMD, ("got=0x%x ", id));
				ccb1 = sc->ccbs + (id >> 2) * sc->ccblen;
				ccb1->ccb_cmd.id = htole32(id);
				ccb1->ccb_cmd.id_hi = htole32(0);
			}

			error = ciss_done(ccb1);
			if (ccb1 == ccb)
				return (error);
		}

		/* if never got a chance to be done above... */
		ccb->ccb_err.cmd_stat = CISS_ERR_TMO;
		error = ciss_done(ccb);

		CISS_DPRINTF(CISS_D_CMD, ("done %d:%d",
		    ccb->ccb_err.cmd_stat, ccb->ccb_err.scsi_stat));
	}

	return (error);
}

int
ciss_done(struct ciss_ccb *ccb)
{
	struct ciss_softc *sc = ccb->ccb_sc;
	struct scsi_xfer *xs = ccb->ccb_xs;
	struct ciss_cmd *cmd = &ccb->ccb_cmd;
	ciss_lock_t lock;
	int error = 0;

	CISS_DPRINTF(CISS_D_CMD, ("ciss_done(%p) ", ccb));

	if (ccb->ccb_state != CISS_CCB_ONQ) {
		printf("%s: unqueued ccb %p ready, state=%b\n",
		    sc->sc_dev.dv_xname, ccb, ccb->ccb_state, CISS_CCB_BITS);
		return 1;
	}
	lock = CISS_LOCK(sc);
	ccb->ccb_state = CISS_CCB_READY;

	if (ccb->ccb_cmd.id & CISS_CMD_ERR)
		error = ciss_error(ccb);

	if (ccb->ccb_data) {
		bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize, (cmd->flags & CISS_CDB_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
	}

	if (xs) {
		xs->resid = 0;
		scsi_done(xs);
	}

	CISS_UNLOCK(sc, lock);

	return error;
}

int
ciss_error(struct ciss_ccb *ccb)
{
	struct ciss_softc *sc = ccb->ccb_sc;
	struct ciss_error *err = &ccb->ccb_err;
	struct scsi_xfer *xs = ccb->ccb_xs;
	int rv;

	switch ((rv = letoh16(err->cmd_stat))) {
	case CISS_ERR_OK:
		rv = 0;
		break;

	case CISS_ERR_INVCMD:
		printf("%s: invalid cmd 0x%x: 0x%x is not valid @@ 0x%x[%d]\n",
		    sc->sc_dev.dv_xname, ccb->ccb_cmd.id,
		    err->err_info, err->err_type[3], err->err_type[2]);
		if (xs) {
			bzero(&xs->sense, sizeof(xs->sense));
			xs->sense.error_code = SSD_ERRCODE_VALID |
			    SSD_ERRCODE_CURRENT;
			xs->sense.flags = SKEY_ILLEGAL_REQUEST;
			xs->sense.add_sense_code = 0x24; /* ill field */
			xs->error = XS_SENSE;
		}
		rv = EIO;
		break;

	case CISS_ERR_TMO:
		xs->error = XS_TIMEOUT;
		rv = ETIMEDOUT;
		break;

	default:
		if (xs) {
			switch (err->scsi_stat) {
			case SCSI_CHECK:
				xs->error = XS_SENSE;
				bcopy(&err->sense[0], &xs->sense,
				    sizeof(xs->sense));
				rv = EIO;
				break;

			case SCSI_BUSY:
				xs->error = XS_BUSY;
				rv = EBUSY;
				break;

			default:
				CISS_DPRINTF(CISS_D_ERR, ("%s: "
				    "cmd_stat %x scsi_stat 0x%x\n",
				    sc->sc_dev.dv_xname, rv, err->scsi_stat));
				xs->error = XS_DRIVER_STUFFUP;
				rv = EIO;
				break;
			}
			xs->resid = letoh32(err->resid);
		} else
			rv = EIO;
	}
	ccb->ccb_cmd.id &= htole32(~3);

	return rv;
}

int
ciss_inq(struct ciss_softc *sc, struct ciss_inquiry *inq)
{
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	int rv;
	int s;

	ccb = scsi_io_get(&sc->sc_iopool, SCSI_POLL|SCSI_NOSLEEP);
	if (ccb == NULL)
		return ENOMEM;

	ccb->ccb_len = sizeof(*inq);
	ccb->ccb_data = inq;
	cmd = &ccb->ccb_cmd;
	cmd->tgt = htole32(CISS_CMD_MODE_PERIPH);
	cmd->tgt2 = 0;
	cmd->cdblen = 10;
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL | CISS_CDB_IN;
	cmd->tmo = htole16(0);
	bzero(&cmd->cdb[0], sizeof(cmd->cdb));
	cmd->cdb[0] = CISS_CMD_CTRL_GET;
	cmd->cdb[6] = CISS_CMS_CTRL_CTRL;
	cmd->cdb[7] = sizeof(*inq) >> 8;	/* biiiig endian */
	cmd->cdb[8] = sizeof(*inq) & 0xff;

	s = splbio();
	rv = ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL|SCSI_NOSLEEP);
	splx(s);

	scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}

int
ciss_ldmap(struct ciss_softc *sc)
{
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	struct ciss_ldmap *lmap;
	ciss_lock_t lock;
	int total, rv;

	lock = CISS_LOCK_SCRATCH(sc);
	lmap = sc->scratch;
	lmap->size = htobe32(sc->maxunits * sizeof(lmap->map));
	total = sizeof(*lmap) + (sc->maxunits - 1) * sizeof(lmap->map);

	ccb = scsi_io_get(&sc->sc_iopool, SCSI_POLL|SCSI_NOSLEEP);
	if (ccb == NULL) {
		CISS_UNLOCK_SCRATCH(sc, lock);
		return ENOMEM;
	}

	ccb->ccb_len = total;
	ccb->ccb_data = lmap;
	cmd = &ccb->ccb_cmd;
	cmd->tgt = CISS_CMD_MODE_PERIPH;
	cmd->tgt2 = 0;
	cmd->cdblen = 12;
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL | CISS_CDB_IN;
	cmd->tmo = htole16(30);
	bzero(&cmd->cdb[0], sizeof(cmd->cdb));
	cmd->cdb[0] = CISS_CMD_LDMAP;
	cmd->cdb[8] = total >> 8;	/* biiiig endian */
	cmd->cdb[9] = total & 0xff;

	rv = ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL|SCSI_NOSLEEP);
	scsi_io_put(&sc->sc_iopool, ccb);
	CISS_UNLOCK_SCRATCH(sc, lock);

	if (rv)
		return rv;

	CISS_DPRINTF(CISS_D_MISC, ("lmap %x:%x\n",
	    lmap->map[0].tgt, lmap->map[0].tgt2));

	return 0;
}

int
ciss_sync(struct ciss_softc *sc)
{
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	struct ciss_flush *flush;
	ciss_lock_t lock;
	int rv;

	lock = CISS_LOCK_SCRATCH(sc);
	flush = sc->scratch;
	bzero(flush, sizeof(*flush));
	flush->flush = sc->sc_flush;

	ccb = scsi_io_get(&sc->sc_iopool, SCSI_POLL|SCSI_NOSLEEP);
	if (ccb == NULL) {
		CISS_UNLOCK_SCRATCH(sc, lock);
		return ENOMEM;
	}

	ccb->ccb_len = sizeof(*flush);
	ccb->ccb_data = flush;
	cmd = &ccb->ccb_cmd;
	cmd->tgt = CISS_CMD_MODE_PERIPH;
	cmd->tgt2 = 0;
	cmd->cdblen = 10;
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL | CISS_CDB_OUT;
	cmd->tmo = htole16(0);
	bzero(&cmd->cdb[0], sizeof(cmd->cdb));
	cmd->cdb[0] = CISS_CMD_CTRL_SET;
	cmd->cdb[6] = CISS_CMS_CTRL_FLUSH;
	cmd->cdb[7] = sizeof(*flush) >> 8;	/* biiiig endian */
	cmd->cdb[8] = sizeof(*flush) & 0xff;

	rv = ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL|SCSI_NOSLEEP);
	scsi_io_put(&sc->sc_iopool, ccb);
	CISS_UNLOCK_SCRATCH(sc, lock);

	return rv;
}

void
ciss_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	u_int8_t target = link->target;
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	ciss_lock_t lock;

	CISS_DPRINTF(CISS_D_CMD, ("ciss_scsi_cmd "));

	if (xs->cmdlen > CISS_MAX_CDB) {
		CISS_DPRINTF(CISS_D_CMD, ("CDB too big %p ", xs));
		bzero(&xs->sense, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | SSD_ERRCODE_CURRENT;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* illcmd, 0x24 illfield */
		xs->error = XS_SENSE;
		scsi_done(xs);
		return;
	}

	xs->error = XS_NOERROR;

	/* XXX emulate SYNCHRONIZE_CACHE ??? */

	ccb = xs->io;

	cmd = &ccb->ccb_cmd;
	ccb->ccb_len = xs->datalen;
	ccb->ccb_data = xs->data;
	ccb->ccb_xs = xs;
	cmd->tgt = CISS_CMD_MODE_LD | target;
	cmd->tgt2 = 0;
	cmd->cdblen = xs->cmdlen;
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL;
	if (xs->flags & SCSI_DATA_IN)
		cmd->flags |= CISS_CDB_IN;
	else if (xs->flags & SCSI_DATA_OUT)
		cmd->flags |= CISS_CDB_OUT;
	cmd->tmo = htole16(xs->timeout < 1000? 1 : xs->timeout / 1000);
	bzero(&cmd->cdb[0], sizeof(cmd->cdb));
	bcopy(xs->cmd, &cmd->cdb[0], CISS_MAX_CDB);

	lock = CISS_LOCK(sc);
	ciss_cmd(ccb, BUS_DMA_WAITOK, xs->flags & (SCSI_POLL|SCSI_NOSLEEP));
	CISS_UNLOCK(sc, lock);
}

int
ciss_intr(void *v)
{
	struct ciss_softc *sc = v;
	struct ciss_ccb *ccb;
	bus_size_t reg;
	u_int32_t id;
	int hit = 0;

	CISS_DPRINTF(CISS_D_INTR, ("intr "));

	if (!(bus_space_read_4(sc->iot, sc->ioh, CISS_ISR) & sc->iem))
		return 0;

	if (sc->cfg.methods & CISS_METH_FIFO64)
		reg = CISS_OUTQ64_HI;
	else if (sc->cfg.methods & CISS_METH_FIFO64_RRO)
		reg = CISS_OUTQ64_LO;
	else
		reg = CISS_OUTQ;
	while ((id = bus_space_read_4(sc->iot, sc->ioh, reg)) != 0xffffffff) {
		if (reg == CISS_OUTQ64_HI)
			id = bus_space_read_4(sc->iot, sc->ioh,
			    CISS_OUTQ64_LO);
		else if (reg == CISS_OUTQ64_LO)
			(void)bus_space_read_4(sc->iot, sc->ioh,
			    CISS_OUTQ64_HI);
		ccb = sc->ccbs + (id >> 2) * sc->ccblen;
		ccb->ccb_cmd.id = htole32(id);
		ccb->ccb_cmd.id_hi = htole32(0); /* ignore the upper 32bits */
		if (ccb->ccb_state == CISS_CCB_POLL) {
			ccb->ccb_state = CISS_CCB_ONQ;
			wakeup(ccb);
		} else
			ciss_done(ccb);

		hit = 1;
	}
	CISS_DPRINTF(CISS_D_INTR, ("exit "));
	return hit;
}

void
ciss_heartbeat(void *v)
{
	struct ciss_softc *sc = v;
	u_int32_t hb;

	hb = bus_space_read_4(sc->iot, sc->cfg_ioh,
	    sc->cfgoff + offsetof(struct ciss_config, heartbeat));
	if (hb == sc->heartbeat) {
		sc->fibrillation++;
		CISS_DPRINTF(CISS_D_ERR, ("%s: fibrillation #%d (value=%d)\n",
		    sc->sc_dev.dv_xname, sc->fibrillation, hb));
		if (sc->fibrillation >= 11) {
			/* No heartbeat for 33 seconds */
			panic("%s: dead", sc->sc_dev.dv_xname);	/* XXX reset! */
		}
	} else {
		sc->heartbeat = hb;
		if (sc->fibrillation) {
			CISS_DPRINTF(CISS_D_ERR, ("%s: "
			    "fibrillation ended (value=%d)\n",
			    sc->sc_dev.dv_xname, hb));
		}
		sc->fibrillation = 0;
	}

	timeout_add_sec(&sc->sc_hb, 3);
}

int
ciss_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag)
{
#if NBIO > 0
	return ciss_ioctl(link->adapter_softc, cmd, addr);
#else
	return ENOTTY;
#endif
}

#if NBIO > 0
const int ciss_level[] = { 0, 4, 1, 5, 51, 7 };
const int ciss_stat[] = { BIOC_SVONLINE, BIOC_SVOFFLINE, BIOC_SVOFFLINE,
    BIOC_SVDEGRADED, BIOC_SVREBUILD, BIOC_SVREBUILD, BIOC_SVDEGRADED,
    BIOC_SVDEGRADED, BIOC_SVINVALID, BIOC_SVINVALID, BIOC_SVBUILDING,
    BIOC_SVOFFLINE, BIOC_SVBUILDING };

int
ciss_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct ciss_softc *sc = (struct ciss_softc *)dev;
	struct bioc_inq *bi;
	struct bioc_vol *bv;
	struct bioc_disk *bd;
	struct bioc_blink *bb;
	/* struct bioc_alarm *ba; */
	/* struct bioc_setstate *bss; */
	struct ciss_ldid *ldid;
	struct ciss_ldstat *ldstat;
	struct ciss_pdid *pdid;
	struct ciss_blink *blink;
	struct ciss_ld *ldp;
	ciss_lock_t lock;
	u_int8_t drv;
	int ld, pd, error = 0;
	u_int blks;

	if (!(sc->sc_flags & CISS_BIO))
		return ENOTTY;

	lock = CISS_LOCK(sc);
	switch (cmd) {
	case BIOCINQ:
		bi = (struct bioc_inq *)addr;
		strlcpy(bi->bi_dev, sc->sc_dev.dv_xname, sizeof(bi->bi_dev));
		bi->bi_novol = sc->maxunits;
		bi->bi_nodisk = sc->ndrives;
		break;

	case BIOCVOL:
		bv = (struct bioc_vol *)addr;
		if (bv->bv_volid > sc->maxunits) {
			error = EINVAL;
			break;
		}
		ldp = sc->sc_lds[bv->bv_volid];
		if (!ldp) {
			error = EINVAL;
			break;
		}
		ldid = sc->scratch;
		if ((error = ciss_ldid(sc, bv->bv_volid, ldid)))
			break;
		/* params 30:88:ff:00:00:00:00:00:00:00:00:00:00:00:20:00 */
		bv->bv_status = BIOC_SVINVALID;
		blks = (u_int)letoh16(ldid->nblocks[1]) << 16 |
		    letoh16(ldid->nblocks[0]);
		bv->bv_size = blks * (uint64_t)letoh16(ldid->blksize);
		bv->bv_level = ciss_level[ldid->type];
		bv->bv_nodisk = ldp->ndrives;
		strlcpy(bv->bv_dev, ldp->xname, sizeof(bv->bv_dev));
		strlcpy(bv->bv_vendor, "CISS", sizeof(bv->bv_vendor));
		ldstat = sc->scratch;
		bzero(ldstat, sizeof(*ldstat));
		if ((error = ciss_ldstat(sc, bv->bv_volid, ldstat)))
			break;
		bv->bv_percent = -1;
		bv->bv_seconds = 0;
		if (ldstat->stat < nitems(ciss_stat))
			bv->bv_status = ciss_stat[ldstat->stat];
		if (bv->bv_status == BIOC_SVREBUILD ||
		    bv->bv_status == BIOC_SVBUILDING)
			bv->bv_percent = (blks -
			    (((u_int)ldstat->prog[3] << 24) |
			    ((u_int)ldstat->prog[2] << 16) |
			    ((u_int)ldstat->prog[1] << 8) |
			    (u_int)ldstat->prog[0])) * 100ULL / blks;
		break;

	case BIOCDISK:
		bd = (struct bioc_disk *)addr;
		if (bd->bd_volid > sc->maxunits) {
			error = EINVAL;
			break;
		}
		ldp = sc->sc_lds[bd->bd_volid];
		if (!ldp || (pd = bd->bd_diskid) > ldp->ndrives) {
			error = EINVAL;
			break;
		}
		ldstat = sc->scratch;
		if ((error = ciss_ldstat(sc, bd->bd_volid, ldstat)))
			break;
		bd->bd_status = -1;
		if (ldstat->stat == CISS_LD_REBLD &&
		    ldstat->bigrebuild == ldp->tgts[pd])
			bd->bd_status = BIOC_SDREBUILD;
		if (ciss_bitset(ldp->tgts[pd] & (~CISS_BIGBIT),
		    ldstat->bigfailed)) {
			bd->bd_status = BIOC_SDFAILED;
			bd->bd_size = 0;
			bd->bd_channel = (ldp->tgts[pd] & (~CISS_BIGBIT)) /
			    sc->ndrives;
			bd->bd_target = ldp->tgts[pd] % sc->ndrives;
			bd->bd_lun = 0;
			bd->bd_vendor[0] = '\0';
			bd->bd_serial[0] = '\0';
			bd->bd_procdev[0] = '\0';
		} else {
			pdid = sc->scratch;
			if ((error = ciss_pdid(sc, ldp->tgts[pd], pdid,
			    SCSI_POLL)))
				break;
			if (bd->bd_status < 0) {
				if (pdid->config & CISS_PD_SPARE)
					bd->bd_status = BIOC_SDHOTSPARE;
				else if (pdid->present & CISS_PD_PRESENT)
					bd->bd_status = BIOC_SDONLINE;
				else
					bd->bd_status = BIOC_SDINVALID;
			}
			bd->bd_size = (u_int64_t)letoh32(pdid->nblocks) *
			    letoh16(pdid->blksz);
			bd->bd_channel = pdid->bus;
			bd->bd_target = pdid->target;
			bd->bd_lun = 0;
			strlcpy(bd->bd_vendor, pdid->model,
			    sizeof(bd->bd_vendor));
			strlcpy(bd->bd_serial, pdid->serial,
			    sizeof(bd->bd_serial));
			bd->bd_procdev[0] = '\0';
		}
		break;

	case BIOCBLINK:
		bb = (struct bioc_blink *)addr;
		blink = sc->scratch;
		error = EINVAL;
		/* XXX workaround completely dumb scsi addressing */
		for (ld = 0; ld < sc->maxunits; ld++) {
			ldp = sc->sc_lds[ld];
			if (!ldp)
				continue;
			if (sc->ndrives == 256)
				drv = bb->bb_target;
			else
				drv = CISS_BIGBIT +
				    bb->bb_channel * sc->ndrives +
				    bb->bb_target;
			for (pd = 0; pd < ldp->ndrives; pd++)
				if (ldp->tgts[pd] == drv)
					error = ciss_blink(sc, ld, pd,
					    bb->bb_status, blink);
		}
		break;

	case BIOCALARM:
	case BIOCSETSTATE:
	default:
		CISS_DPRINTF(CISS_D_IOCTL, ("%s: invalid ioctl\n",
		    sc->sc_dev.dv_xname));
		error = ENOTTY;
	}
	CISS_UNLOCK(sc, lock);

	return error;
}

#ifndef SMALL_KERNEL
void
ciss_sensors(void *v)
{
	struct ciss_softc *sc = v;
	struct ciss_ldstat *ldstat;
	int i, error;

	for (i = 0; i < sc->maxunits; i++) {
		ldstat = sc->scratch;
		if ((error = ciss_ldstat(sc, i, ldstat))) {
			sc->sensors[i].value = 0;
			sc->sensors[i].status = SENSOR_S_UNKNOWN;
			continue;
		}

		switch (ldstat->stat) {
		case CISS_LD_OK:
			sc->sensors[i].value = SENSOR_DRIVE_ONLINE;
			sc->sensors[i].status = SENSOR_S_OK;
			break;

		case CISS_LD_DEGRAD:
			sc->sensors[i].value = SENSOR_DRIVE_PFAIL;
			sc->sensors[i].status = SENSOR_S_WARN;
			break;

		case CISS_LD_EXPND:
		case CISS_LD_QEXPND:
		case CISS_LD_RBLDRD:
		case CISS_LD_REBLD:
			sc->sensors[i].value = SENSOR_DRIVE_REBUILD;
			sc->sensors[i].status = SENSOR_S_WARN;
			break;

		case CISS_LD_NORDY:
		case CISS_LD_PDINV:
		case CISS_LD_PDUNC:
		case CISS_LD_FAILED:
		case CISS_LD_UNCONF:
			sc->sensors[i].value = SENSOR_DRIVE_FAIL;
			sc->sensors[i].status = SENSOR_S_CRIT;
			break;

		default:
			sc->sensors[i].value = 0;
			sc->sensors[i].status = SENSOR_S_UNKNOWN;
		}
	}
}
#endif /* SMALL_KERNEL */

int
ciss_ldid(struct ciss_softc *sc, int target, struct ciss_ldid *id)
{
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	int rv;
	int s;

	ccb = scsi_io_get(&sc->sc_iopool, SCSI_POLL);
	if (ccb == NULL)
		return ENOMEM;

	ccb->ccb_len = sizeof(*id);
	ccb->ccb_data = id;
	cmd = &ccb->ccb_cmd;
	cmd->tgt = htole32(CISS_CMD_MODE_PERIPH);
	cmd->tgt2 = 0;
	cmd->cdblen = 10;
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL | CISS_CDB_IN;
	cmd->tmo = htole16(0);
	bzero(&cmd->cdb[0], sizeof(cmd->cdb));
	cmd->cdb[0] = CISS_CMD_CTRL_GET;
	cmd->cdb[5] = target;
	cmd->cdb[6] = CISS_CMS_CTRL_LDIDEXT;
	cmd->cdb[7] = sizeof(*id) >> 8;	/* biiiig endian */
	cmd->cdb[8] = sizeof(*id) & 0xff;

	s = splbio();
	rv = ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL);
	splx(s);

	scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}

int
ciss_ldstat(struct ciss_softc *sc, int target, struct ciss_ldstat *stat)
{
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	int rv;
	int s;

	ccb = scsi_io_get(&sc->sc_iopool, SCSI_POLL);
	if (ccb == NULL)
		return ENOMEM;

	ccb->ccb_len = sizeof(*stat);
	ccb->ccb_data = stat;
	cmd = &ccb->ccb_cmd;
	cmd->tgt = htole32(CISS_CMD_MODE_PERIPH);
	cmd->tgt2 = 0;
	cmd->cdblen = 10;
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL | CISS_CDB_IN;
	cmd->tmo = htole16(0);
	bzero(&cmd->cdb[0], sizeof(cmd->cdb));
	cmd->cdb[0] = CISS_CMD_CTRL_GET;
	cmd->cdb[5] = target;
	cmd->cdb[6] = CISS_CMS_CTRL_LDSTAT;
	cmd->cdb[7] = sizeof(*stat) >> 8;	/* biiiig endian */
	cmd->cdb[8] = sizeof(*stat) & 0xff;

	s = splbio();
	rv = ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL);
	splx(s);

	scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}

int
ciss_pdid(struct ciss_softc *sc, u_int8_t drv, struct ciss_pdid *id, int wait)
{
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	int rv;
	int s;

	ccb = scsi_io_get(&sc->sc_iopool, SCSI_POLL);
	if (ccb == NULL)
		return ENOMEM;

	ccb->ccb_len = sizeof(*id);
	ccb->ccb_data = id;
	cmd = &ccb->ccb_cmd;
	cmd->tgt = htole32(CISS_CMD_MODE_PERIPH);
	cmd->tgt2 = 0;
	cmd->cdblen = 10;
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL | CISS_CDB_IN;
	cmd->tmo = htole16(0);
	bzero(&cmd->cdb[0], sizeof(cmd->cdb));
	cmd->cdb[0] = CISS_CMD_CTRL_GET;
	cmd->cdb[2] = drv;
	cmd->cdb[6] = CISS_CMS_CTRL_PDID;
	cmd->cdb[7] = sizeof(*id) >> 8;	/* biiiig endian */
	cmd->cdb[8] = sizeof(*id) & 0xff;

	s = splbio();
	rv = ciss_cmd(ccb, BUS_DMA_NOWAIT, wait);
	splx(s);

	scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}


struct ciss_ld *
ciss_pdscan(struct ciss_softc *sc, int ld)
{
	struct ciss_pdid *pdid;
	struct ciss_ld *ldp;
	u_int8_t drv, buf[128];
	int i, j, k = 0;

	pdid = sc->scratch;
	if (sc->ndrives == 256) {
		for (i = 0; i < CISS_BIGBIT; i++)
			if (!ciss_pdid(sc, i, pdid, SCSI_NOSLEEP|SCSI_POLL) &&
			    (pdid->present & CISS_PD_PRESENT))
				buf[k++] = i;
	} else
		for (i = 0; i < sc->nbus; i++)
			for (j = 0; j < sc->ndrives; j++) {
				drv = CISS_BIGBIT + i * sc->ndrives + j;
				if (!ciss_pdid(sc, drv, pdid,
				    SCSI_NOSLEEP|SCSI_POLL))
					buf[k++] = drv;
			}

	if (!k)
		return NULL;

	ldp = malloc(sizeof(*ldp) + (k-1), M_DEVBUF, M_NOWAIT);
	if (!ldp)
		return NULL;

	bzero(&ldp->bling, sizeof(ldp->bling));
	ldp->ndrives = k;
	bcopy(buf, ldp->tgts, k);
	return ldp;
}

int
ciss_blink(struct ciss_softc *sc, int ld, int pd, int stat,
    struct ciss_blink *blink)
{
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	struct ciss_ld *ldp;
	int rv;
	int s;

	if (ld > sc->maxunits)
		return EINVAL;

	ldp = sc->sc_lds[ld];
	if (!ldp || pd > ldp->ndrives)
		return EINVAL;

	ldp->bling.pdtab[ldp->tgts[pd]] = stat == BIOC_SBUNBLINK? 0 :
	    CISS_BLINK_ALL;
	bcopy(&ldp->bling, blink, sizeof(*blink));

	ccb = scsi_io_get(&sc->sc_iopool, SCSI_POLL);
	if (ccb == NULL)
		return ENOMEM;

	ccb->ccb_len = sizeof(*blink);
	ccb->ccb_data = blink;
	cmd = &ccb->ccb_cmd;
	cmd->tgt = htole32(CISS_CMD_MODE_PERIPH);
	cmd->tgt2 = 0;
	cmd->cdblen = 10;
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL | CISS_CDB_OUT;
	cmd->tmo = htole16(0);
	bzero(&cmd->cdb[0], sizeof(cmd->cdb));
	cmd->cdb[0] = CISS_CMD_CTRL_SET;
	cmd->cdb[6] = CISS_CMS_CTRL_PDBLINK;
	cmd->cdb[7] = sizeof(*blink) >> 8;	/* biiiig endian */
	cmd->cdb[8] = sizeof(*blink) & 0xff;

	s = splbio();
	rv = ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL);
	splx(s);

	scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}
#endif
@


1.74
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.73 2015/05/03 02:10:13 jsg Exp $	*/
d1019 1
a1019 1
		bv->bv_size = blks * (u_quad_t)letoh16(ldid->blksize);
@


1.73
log
@add missing CISS_UNLOCK_SCRATCH/splx calls
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.72 2015/03/14 03:38:47 jsg Exp $	*/
d404 2
a405 1
			free(sc->sensors, M_DEVBUF, 0);
@


1.72
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.71 2014/09/14 14:17:24 jsg Exp $	*/
d759 2
a760 1
	if (ccb == NULL)
d762 1
d805 2
a806 1
	if (ccb == NULL)
d808 1
@


1.71
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.70 2014/07/13 23:10:23 deraadt Exp $	*/
a34 1
#include <scsi/scsi_disk.h>
@


1.70
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.69 2014/07/12 18:48:17 tedu Exp $	*/
a30 1
#include <sys/proc.h>
@


1.69
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.68 2013/05/30 16:15:02 deraadt Exp $	*/
d350 1
a350 1
	if (!(sc->sc_lds = malloc(sc->maxunits * sizeof(*sc->sc_lds),
d388 1
a388 1
	sc->sensors = malloc(sizeof(struct ksensor) * sc->maxunits,
@


1.68
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.67 2011/11/10 12:05:11 krw Exp $	*/
d406 1
a406 1
			free(sc->sensors, M_DEVBUF);
@


1.67
log
@Death to inappropriate whitespace. First one pointed out by Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.66 2011/07/17 22:46:48 matthew Exp $	*/
a83 1
void	ciss_shutdown(void *v);
a357 6
	if (!(sc->sc_sh = shutdownhook_establish(ciss_shutdown, sc))) {
		printf(": unable to establish shutdown hook\n");
		bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
		bus_dmamap_destroy(sc->dmat, sc->cmdmap);
		return -1;
	}
@


1.66
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.65 2011/07/08 22:09:27 matthew Exp $	*/
d442 1
a442 1
}               
d619 1
a619 1
        struct ciss_cmd *cmd = &ccb->ccb_cmd;
d1089 1
a1089 1
			bd->bd_channel = pdid->bus;  
@


1.65
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.64 2011/04/05 19:54:35 jasper Exp $	*/
d369 1
d371 1
a374 2
	saa.saa_targets = sc->maxunits;
	saa.saa_luns = 1;
@


1.64
log
@- use nitems() no binary change on amd64

"reads OK" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.63 2010/09/20 06:17:49 krw Exp $	*/
a368 1
	sc->sc_link.luns = 1;
a369 1
	sc->sc_link.adapter_buswidth = sc->maxunits;
d373 2
@


1.63
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.62 2010/09/20 04:08:36 dlg Exp $	*/
d1034 1
a1034 1
		if (ldstat->stat < sizeof(ciss_stat)/sizeof(ciss_stat[0]))
@


1.62
log
@bus_dmamap_sync was using xs->flags to determine which direction
to sync the map. unfortunately xs is not set for internal ciss
commands, so this is a null deref. it wasnt until kettenis made
bus_dmamap_sync a real function which needed its arguments evaluated
that this became a real problem though.

hit by mcbride@@ and sakurai-san. fixed by krw@@ over my shoulder
when we figured out which specific chunk of code was faulting.
tested by sakurai-san
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.61 2010/07/07 10:12:13 dlg Exp $	*/
d481 1
d672 2
a673 1
			xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
d850 1
a850 1
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
@


1.61
log
@set each disks openings to the maximum number the controller can handle.
iopools make sure resources arent overallocated, while scheduling them
evenly between devices.

tested by and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.60 2010/07/02 08:12:17 matthew Exp $	*/
d618 1
a628 1

d637 1
a637 1
		    ccb->ccb_dmamap->dm_mapsize, (xs->flags & SCSI_DATA_IN) ?
d644 1
a644 1
		scsi_done(ccb->ccb_xs);
@


1.60
log
@Make the sensor setup loop less awkward by moving the call to
sensor_attach() out of the for loop header.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.59 2010/07/01 16:24:37 deraadt Exp $	*/
d367 1
a367 1
	sc->sc_link.openings = sc->maxcmd / (sc->maxunits? sc->maxunits : 1);
@


1.59
log
@compile when SMALL_KERNEL is set
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.58 2010/07/01 03:20:38 matthew Exp $	*/
d402 1
a402 2
		for (i = 0; i < sc->maxunits;
		    sensor_attach(&sc->sensordev, &sc->sensors[i++])) {
d410 1
@


1.58
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.57 2010/06/28 18:31:02 krw Exp $	*/
a143 1
	struct device *dev;
d398 2
@


1.57
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.56 2010/06/26 22:14:32 krw Exp $	*/
d144 1
d405 2
a406 2
			strlcpy(sc->sensors[i].desc, ((struct device *)
			    scsibus->sc_link[i][0]->device_softc)->dv_xname,
d408 1
a408 2
			strlcpy(sc->sc_lds[i]->xname, ((struct device *)
			    scsibus->sc_link[i][0]->device_softc)->dv_xname,
@


1.56
log
@If you put CISS_LOCK()/CISS_UNLOCK() around a switch statement, you
must break out of the cases, not directly 'return' error codes. I
think the error case is currently impossible, but why leave an armed
bear trap lying about?
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.55 2010/06/15 04:11:34 dlg Exp $	*/
a78 4
struct scsi_device ciss_dev = {
	NULL, NULL, NULL, NULL
};

a365 1
	sc->sc_link.device = &ciss_dev;
@


1.55
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.54 2010/06/03 01:03:55 dlg Exp $	*/
d1014 4
a1017 2
		if (!ldp)
			return EINVAL;
@


1.54
log
@get rid of the kthread. it is unused and just bloats the kernel.

pointed out by brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.53 2010/06/03 01:02:13 dlg Exp $	*/
d72 1
a72 2
int	ciss_scsi_ioctl(struct scsi_link *link, u_long cmd,
    caddr_t addr, int flag, struct proc *p);
d959 1
a959 2
ciss_scsi_ioctl(struct scsi_link *link, u_long cmd,
    caddr_t addr, int flag, struct proc *p)
@


1.53
log
@replace TAILQs with SLISTs for managing the ccb free list. theyre smaller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.52 2010/06/03 00:56:42 dlg Exp $	*/
a31 1
#include <sys/kthread.h>
a89 1
void	ciss_kthread(void *v);
a370 10
#if 0
	if (kthread_create(ciss_kthread, sc, NULL, "%s", sc->sc_dev.dv_xname)) {
		printf(": unable to create kernel thread\n");
		shutdownhook_disestablish(sc->sc_sh);
		bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
		bus_dmamap_destroy(sc->dmat, sc->cmdmap);
		return -1;
	}
#endif

a956 17
}

void
ciss_kthread(void *v)
{
	struct ciss_softc *sc = v;
	ciss_lock_t lock;

	for (;;) {
		tsleep(sc, PRIBIO, sc->sc_dev.dv_xname, 0);

		lock = CISS_LOCK(sc);



		CISS_UNLOCK(sc, lock);
	}
@


1.52
log
@useless abstraction is, by definition, useless.

dont typedef the tailq head struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.51 2010/06/02 13:34:21 dlg Exp $	*/
d117 3
a119 2
	if ((ccb = TAILQ_LAST(&sc->sc_free_ccb, ciss_ccb_list))) {
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ccb_link);
d139 1
a139 1
	TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_link);
d261 1
a261 1
	TAILQ_INIT(&sc->sc_free_ccb);
d287 1
a287 1
		TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_link);
@


1.51
log
@convert ciss(4) over to using iopools. this is fairly easy after the recent
tweaks ive made.

this provides better concurrent access to multiple volumes on the same hba,
while improving the reliability of the ioctl and sensor codepaths.

tested by okan@@ halex@@
ok krw@@ okan@@ halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.50 2010/06/02 05:38:00 dlg Exp $	*/
d117 1
a117 1
	if ((ccb = TAILQ_LAST(&sc->sc_free_ccb, ciss_queue_head))) {
@


1.50
log
@its pretty obvious that ciss_cmd should be called with splbio being held,
especially if you're passing it SCSI_POLL too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.49 2010/06/02 05:07:58 dlg Exp $	*/
d96 2
a97 2
struct ciss_ccb *ciss_get_ccb(struct ciss_softc *sc);
void	ciss_put_ccb(struct ciss_ccb *ccb);
d110 2
a111 2
struct ciss_ccb *
ciss_get_ccb(struct ciss_softc *sc)
d113 1
d128 1
a128 1
ciss_put_ccb(struct ciss_ccb *ccb)
d130 2
a131 1
	struct ciss_softc *sc = ccb->ccb_sc;
d289 2
d389 1
a497 1
			ciss_put_ccb(ccb);
a528 4
	if ((wait & (SCSI_POLL|SCSI_NOSLEEP)) == (SCSI_POLL|SCSI_NOSLEEP))
		bus_space_write_4(sc->iot, sc->ioh, CISS_IMR,
		    bus_space_read_4(sc->iot, sc->ioh, CISS_IMR) | sc->iem);

d615 1
a615 1
				break;
d619 2
a620 4
		if (ccb->ccb_state != CISS_CCB_FREE) {
			ccb->ccb_err.cmd_stat = CISS_ERR_TMO;
			error = ciss_done(ccb);
		}
a625 4
	if ((wait & (SCSI_POLL|SCSI_NOSLEEP)) == (SCSI_POLL|SCSI_NOSLEEP))
		bus_space_write_4(sc->iot, sc->ioh, CISS_IMR,
		    bus_space_read_4(sc->iot, sc->ioh, CISS_IMR) & ~sc->iem);

a662 2
	ciss_put_ccb(ccb);

d740 1
a740 1
	ccb = ciss_get_ccb(sc);
d762 2
d781 1
a781 1
	ccb = ciss_get_ccb(sc);
d799 1
d825 1
a825 1
	ccb = ciss_get_ccb(sc);
d844 1
a853 1
	struct ciss_softc *sc = link->adapter_softc;
d876 1
a876 6
	ccb = ciss_get_ccb(sc);
	if (ccb == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
d1224 1
a1224 1
	ccb = ciss_get_ccb(sc);
d1247 2
d1260 1
a1260 1
	ccb = ciss_get_ccb(sc);
d1283 2
d1296 1
a1296 1
	ccb = ciss_get_ccb(sc);
d1319 2
d1382 1
a1382 1
	ccb = ciss_get_ccb(sc);
d1403 2
@


1.49
log
@call scsi_done before put_ccb, rather than have put_ccb call scsi_done
for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.48 2010/06/02 01:45:14 dlg Exp $	*/
d472 2
d745 2
d766 5
a770 1
	return ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL|SCSI_NOSLEEP);
d1231 2
d1253 5
a1257 1
	return ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL);
d1265 2
d1287 5
a1291 1
	return ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL);
d1299 2
d1321 5
a1325 1
	return ciss_cmd(ccb, BUS_DMA_NOWAIT, wait);
d1372 2
d1404 5
a1408 1
	return ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL);
@


1.48
log
@push the "locking" in ciss_scsi_cmd down. we dont need splbio to call
scsi_done or to get or put ccbs anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.47 2010/06/02 01:33:57 dlg Exp $	*/
a130 5
	if (ccb->ccb_xs) {
		CISS_DPRINTF(CISS_D_CMD, ("scsi_done(%p) ", ccb->ccb_xs));
		scsi_done(ccb->ccb_xs);
	}

d487 1
a487 1
			if (ccb->ccb_xs)
d489 2
d662 1
a662 1
	if (xs)
d664 2
@


1.47
log
@protect the ccb free queue with its own mutex
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.46 2010/06/02 01:27:20 dlg Exp $	*/
a858 1
	lock = CISS_LOCK(sc);
a866 1
		CISS_UNLOCK(sc, lock);
a877 1
		CISS_UNLOCK(sc, lock);
d897 1
a898 1

@


1.46
log
@get rid of useless ccb queues. when the ccb is on the chip, we mark its
state as such, putting it on a queue is silly. one of the queues was
initted by never used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.45 2010/06/02 01:18:36 dlg Exp $	*/
d115 1
d121 3
a123 1
	return ccb;
d139 2
d142 1
d264 1
@


1.45
log
@get rid of the code for the passthru bus support. it was never enabled and
confuses the code and bloats the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.44 2010/06/02 01:16:12 dlg Exp $	*/
a256 2
	TAILQ_INIT(&sc->sc_ccbq);
	TAILQ_INIT(&sc->sc_ccbdone);
a522 1
	TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);
a646 1
	TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
@


1.44
log
@interrupt handlers are run at their IPL, so there's no need to go splbio
in a disk controllers handler, even if it has a useless bunch of macros
around it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.43 2010/05/31 19:35:03 halex Exp $	*/
a84 10
void	ciss_scsi_raw_cmd(struct scsi_xfer *xs);

struct scsi_adapter ciss_raw_switch = {
	ciss_scsi_raw_cmd, cissminphys, NULL, NULL,
};

struct scsi_device ciss_raw_dev = {
	NULL, NULL, NULL, NULL
};

a389 13
#if 0
	sc->sc_link_raw.device = &ciss_raw_dev;
	sc->sc_link_raw.adapter_softc = sc;
	sc->sc_link.openings = sc->maxcmd / (sc->maxunits? sc->maxunits : 1);
	sc->sc_link_raw.adapter = &ciss_raw_switch;
	sc->sc_link_raw.adapter_target = sc->ndrives;
	sc->sc_link_raw.adapter_buswidth = sc->ndrives;
	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link_raw;
	rawbus = (struct scsibus_softc *)config_found_sm(&sc->sc_dev,
	    &saa, scsiprint, NULL);
#endif

a841 57
}

void
ciss_scsi_raw_cmd(struct scsi_xfer *xs)	/* TODO */
{
	struct scsi_link *link = xs->sc_link;
	struct ciss_rawsoftc *rsc = link->adapter_softc;
	struct ciss_softc *sc = rsc->sc_softc;
	struct ciss_ccb *ccb;
	struct ciss_cmd *cmd;
	ciss_lock_t lock;

	CISS_DPRINTF(CISS_D_CMD, ("ciss_scsi_raw_cmd "));

	lock = CISS_LOCK(sc);
	if (xs->cmdlen > CISS_MAX_CDB) {
		CISS_DPRINTF(CISS_D_CMD, ("CDB too big %p ", xs));
		bzero(&xs->sense, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* illcmd, 0x24 illfield */
		xs->error = XS_SENSE;
		scsi_done(xs);
		CISS_UNLOCK(sc, lock);
		return;
	}

	xs->error = XS_NOERROR;

	/* TODO check this target has not yet employed w/ any volume */

	ccb = ciss_get_ccb(sc);
	if (ccb == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		CISS_UNLOCK(sc, lock);
		return;
	}

	cmd = &ccb->ccb_cmd;
	ccb->ccb_len = xs->datalen;
	ccb->ccb_data = xs->data;
	ccb->ccb_xs = xs;

	cmd->cdblen = xs->cmdlen;
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL;
	if (xs->flags & SCSI_DATA_IN)
		cmd->flags |= CISS_CDB_IN;
	else if (xs->flags & SCSI_DATA_OUT)
		cmd->flags |= CISS_CDB_OUT;
	cmd->tmo = htole16(xs->timeout < 1000? 1 : xs->timeout / 1000);
	bzero(&cmd->cdb[0], sizeof(cmd->cdb));
	bcopy(xs->cmd, &cmd->cdb[0], CISS_MAX_CDB);

	ciss_cmd(ccb, BUS_DMA_WAITOK, xs->flags & (SCSI_POLL|SCSI_NOSLEEP));

	CISS_UNLOCK(sc, lock);
@


1.43
log
@do not immediately panic if we find a non-increasing heartbeat counter but
keep count for at least 33 seconds. then panic.

ok marco@@, moral support johan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.42 2010/05/19 15:27:35 oga Exp $	*/
a986 1
	ciss_lock_t lock;
a995 2
	lock = CISS_LOCK(sc);

a1019 2
	CISS_UNLOCK(sc, lock);

@


1.42
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.41 2010/03/23 01:57:19 krw Exp $	*/
d1037 9
a1045 3
	if (hb == sc->heartbeat)
		panic("%s: dead", sc->sc_dev.dv_xname);	/* XXX reset! */
	else
d1047 7
@


1.41
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.40 2010/01/09 23:15:06 krw Exp $	*/
d241 1
a241 1
	    sc->cmdseg, 1, &rseg, BUS_DMA_NOWAIT))) {
a250 1
	bzero(sc->ccbs, total);
d308 1
a308 1
	    seg, 1, &rseg, BUS_DMA_NOWAIT))) {
a317 1
	bzero(sc->scratch, PAGE_SIZE);
@


1.40
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.39 2010/01/09 06:35:11 krw Exp $	*/
d72 1
a72 1
int	ciss_scsi_cmd(struct scsi_xfer *xs);
d85 1
a85 1
int	ciss_scsi_raw_cmd(struct scsi_xfer *xs);
d138 5
d512 1
a512 1
			if (ccb->ccb_xs) {
a513 2
				scsi_done(ccb->ccb_xs);
			}
d687 3
a691 5
	if (xs) {
		xs->resid = 0;
		CISS_DPRINTF(CISS_D_CMD, ("scsi_done(%p) ", xs));
		scsi_done(xs);
	}
d869 1
a869 1
int
d891 1
a891 1
		return (COMPLETE);
d903 1
a903 1
		return (COMPLETE);
a923 1
	return (COMPLETE);
d926 1
a926 1
int
d948 1
a948 1
		return (COMPLETE);
d960 1
a960 1
		return (COMPLETE);
a981 1
	return (COMPLETE);
a1304 1
	ccb->ccb_xs = NULL;
a1332 1
	ccb->ccb_xs = NULL;
a1360 1
	ccb->ccb_xs = NULL;
a1438 1
	ccb->ccb_xs = NULL;
@


1.39
log
@Avoid mulitple calls to scsi_done() on the same xs by having
ciss_cmd() call scsi_done() in the one case where ciss_done() was
not calling ciss_done() before erroring out, and not calling
scsi_done() after ciss_cmd() errors out.

Okan's box can now boot. And work fine afterwards.

Tested by okan@@. ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.38 2010/01/07 11:03:37 dlg Exp $	*/
a687 1
		xs->flags |= ITSDONE;
@


1.38
log
@dont use the xs in the scsi_cmd routines after calling ciss_cmd, it might
have been completed. the xs was used to figure out if we should return
COMPLETED or SUCCESFULLY_QUEUED. the return value doesnt mean anything
anymore, so just return COMPLETE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.36 2009/12/17 19:42:39 krw Exp $	*/
d139 2
d507 4
a681 2
		ccb->ccb_xs = NULL;
		ccb->ccb_data = NULL;
d921 1
a921 7
	if (ciss_cmd(ccb, BUS_DMA_WAITOK,
	    xs->flags & (SCSI_POLL|SCSI_NOSLEEP))) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		CISS_UNLOCK(sc, lock);
		return (COMPLETE);
	}
d980 1
a980 7
	if (ciss_cmd(ccb, BUS_DMA_WAITOK,
	    xs->flags & (SCSI_POLL|SCSI_NOSLEEP))) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		CISS_UNLOCK(sc, lock);
		return (COMPLETE);
	}
@


1.37
log
@CISS_UNLOCK before returning from the scsi_cmd handler when we hit NO_CCB.
this should solve problems like this:

WARNING: SPL NOT LOWERED ON SYSCALL 16384 8 EXIT dae4560 6
Stopped at      Xsyscall+0x1eb: movl    $0,%gs:0x3d4
ddb{3}>
@
text
@d926 1
a926 1
	return xs->flags & SCSI_POLL? COMPLETE : SUCCESSFULLY_QUEUED;
d991 1
a991 1
	return xs->flags & SCSI_POLL? COMPLETE : SUCCESSFULLY_QUEUED;
@


1.36
log
@Initialize ccb_xs to NULL when taking a ccb off the free list. This
prevents calling xs->done() for internal commands that don't have an
xs associated with them. In turn, this prevents crashes when calling
ciss_sync(), e.g. when rebooting.

Reported on misc@@ by Peter Huncar.

Prodded by kettenis@@, halex@@ and johan@@. Fix tested by halex@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.35 2009/11/15 14:13:12 krw Exp $	*/
d895 6
a900 2
	if (ccb == NULL)
		return NO_CCB;
d959 6
a964 2
	if (ccb == NULL)
		return NO_CCB;
@


1.35
log
@Move ciss(4) to NO_CCB. Add some extra paranoia by always testing
the results of attempting to get a ccb. Eliminates manual reservation
of ccb's for bioctl and sensors. Tested by johan@@ and okan@@.

Eyes from brad@@, dlg@@ and marco@@. tech@@ did its Thomas More thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.34 2009/04/29 08:24:26 reyk Exp $	*/
d128 1
@


1.34
log
@Implement the 64bit FIFO modes (based on the OpenCISS Specification
1.06).  It is required to run ciss(4) with amd64 bigmem, even when
using the iommu.

Tested by many on 32bit and 64bit low- and bigmem systems
With feedback from mk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.33 2009/02/16 21:19:06 miod Exp $	*/
a384 5
#if NBIO > 0
	/* XXX Reserve some ccb's for sensor and bioctl. */
	if (sc->maxunits < 2 && sc->sc_link.openings > 2)
		sc->sc_link.openings -= 2;
#endif
d386 1
d408 2
a409 2
	/* XXX for now we can only deal w/ one volume and need reserved ccbs. */
	if (!scsibus || sc->maxunits > 1 || sc->sc_link.openings == sc->maxcmd)
d763 3
d798 3
d841 3
d894 3
a901 2


d954 3
d1303 1
d1332 1
d1361 1
d1440 1
@


1.33
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.32 2008/11/10 15:55:06 cnst Exp $	*/
d335 1
a335 1
	printf(": %d LD%s, HW rev %d, FW %4.4s/%4.4s\n",
d338 5
d489 1
d547 12
a558 1
	bus_space_write_4(sc->iot, sc->ioh, CISS_INQ, ccb->ccb_cmdpa);
d596 25
a620 4
				if ((id = bus_space_read_4(sc->iot, sc->ioh,
				    CISS_OUTQ)) == 0xffffffff) {
					CISS_DPRINTF(CISS_D_CMD, ("Q"));
					continue;
d626 1
d982 1
a991 2
	while ((id = bus_space_read_4(sc->iot, sc->ioh, CISS_OUTQ)) !=
	    0xffffffff) {
d993 13
d1008 1
@


1.32
log
@remove unused variable 'error' from two functions;  llvm/clang;  ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.31 2008/09/10 14:01:22 blambert Exp $	*/
d75 1
a75 1
void	cissminphys(struct buf *bp);
d461 1
a461 1
cissminphys(struct buf *bp)
@


1.31
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.30 2008/04/24 09:04:14 jakob Exp $	*/
a828 1
	int error;
a844 1
	error = 0;
a886 1
	int error;
a903 1
	error = 0;
@


1.30
log
@some ciss(4) firmwares use different physical drive addressing, resulting
in bioctl(8) functions not available; pr#5682.
code from mickey. tested by several people.
ok dlg@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.29 2007/10/20 16:10:09 krw Exp $	*/
d342 1
a342 1
	timeout_add(&sc->sc_hb, hz * 3);
d988 1
a988 1
	timeout_add(&sc->sc_hb, hz * 3);
@


1.29
log
@Call scsi_done() at SPLBIO. 'looks olright' says mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.28 2007/09/18 00:46:41 krw Exp $	*/
d334 1
a334 1
	sc->ndrives = inq->buswidth;
d1042 1
d1111 2
a1112 1
		if (ldstat->bigrebuild == ldp->tgts[pd])
d1160 6
d1167 1
a1167 3
				if (ldp->tgts[pd] == (CISS_BIGBIT +
				    bb->bb_channel * sc->ndrives +
				    bb->bb_target))
d1331 13
a1343 6
	for (i = 0; i < sc->nbus; i++)
		for (j = 0; j < sc->ndrives; j++) {
			drv = CISS_BIGBIT + i * sc->ndrives + j;
			if (!ciss_pdid(sc, drv, pdid, SCSI_NOSLEEP|SCSI_POLL))
				buf[k++] = drv;
		}
@


1.28
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.27 2007/06/24 05:34:35 dlg Exp $	*/
d833 1
d842 1
a845 1
	lock = CISS_LOCK(sc);
d894 1
d903 1
a906 1
	lock = CISS_LOCK(sc);
@


1.27
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.26 2007/05/29 22:17:50 todd Exp $	*/
d353 1
a353 1
	    M_DEVBUF, M_NOWAIT))) {
a357 1
	bzero(sc->sc_lds, sc->maxunits * sizeof(*sc->sc_lds));
d424 1
a424 1
	    M_DEVBUF, M_NOWAIT);
a425 1
		bzero(sc->sensors, sizeof(struct ksensor) * sc->maxunits);
@


1.26
log
@sprinkle some SMALL_KERNEL to permit bio/softraid to run on boot media
ok marco@@ then suggested deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.25 2007/03/22 16:55:31 deraadt Exp $	*/
d441 1
a441 1
		if (sensor_task_register(sc, ciss_sensors, 10))
@


1.25
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.24 2007/01/18 14:46:24 mickey Exp $	*/
d102 1
d104 1
d423 1
d446 2
a447 1
#endif
d1179 1
d1229 1
@


1.24
log
@do not freak out if cannot map physdrives into volumes and handle it proper everywhere
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.23 2006/12/23 17:46:39 deraadt Exp $	*/
d421 1
a421 1
	sc->sensors = malloc(sizeof(struct sensor) * sc->maxunits,
d424 1
a424 1
		bzero(sc->sensors, sizeof(struct sensor) * sc->maxunits);
@


1.23
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.22 2006/11/28 23:59:45 dlg Exp $	*/
d356 1
d413 2
a414 6
		if (!(sc->sc_lds[i] = ciss_pdscan(sc, i))) {
			shutdownhook_disestablish(sc->sc_sh);
			bus_dmamem_free(sc->dmat, sc->cmdseg, 1);
			bus_dmamap_destroy(sc->dmat, sc->cmdmap);
			return -1;
		}
d1060 2
d1098 1
a1098 1
		if ((pd = bd->bd_diskid) > ldp->ndrives) {
d1152 2
d1351 1
a1351 1
	if (pd > ldp->ndrives)
@


1.22
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.21 2006/09/15 23:47:52 krw Exp $	*/
d428 4
a431 1
		for (i = 0; i < sc->maxunits; sensor_add(&sc->sensors[i++])) {
a433 2
			strlcpy(sc->sensors[i].device, sc->sc_dev.dv_xname,
			    sizeof(sc->sensors[i].device));
d441 1
a441 3
		if (sensor_task_register(sc, ciss_sensors, 10)) {
			for (i = sc->maxunits; i--; )
				sensor_del(&sc->sensors[i]);
d443 2
a444 1
		}
@


1.21
log
@Reserve some commands slot for bioctl/sensorsd so ciss doesn't crash
under load when bioctl/sensorsd are active. Better fix post-4.0.

Problem found, fix tested by Johan Mson Lindman.

ok dlg@@ marco@@ mickey@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.20 2006/08/31 23:19:35 krw Exp $	*/
d142 1
d386 2
d389 1
a389 1
	    &sc->sc_link, scsiprint, NULL);
d398 2
d401 1
a401 1
	    &sc->sc_link_raw, scsiprint, NULL);
@


1.21.2.1
log
@MFC: do not freak out if cannot map physdrives into volumes and handle it
proper everywhere - commit message from mickey, -stable patch from Reyk

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.24 2007/01/18 14:46:24 mickey Exp $	*/
a354 1
	bzero(sc->sc_lds, sc->maxunits * sizeof(*sc->sc_lds));
d407 6
a412 2
		if (!(sc->sc_lds[i] = ciss_pdscan(sc, i)))
			return 0;
a1057 2
		if (!ldp)
			return EINVAL;
d1094 1
a1094 1
		if (!ldp || (pd = bd->bd_diskid) > ldp->ndrives) {
a1147 2
			if (!ldp)
				continue;
d1345 1
a1345 1
	if (!ldp || pd > ldp->ndrives)
@


1.20
log
@ciss can't do bio ioctl's when >1 logical device is defined. Bail out
of ciss_ioctl if >1 logical device is present. Fixes dereferencing of
uninitialized pointer.

From mickey@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.19 2006/08/28 02:56:33 mickey Exp $	*/
d377 5
d400 2
a401 2
	/* XXX for now we can only deal w/ one volume */
	if (!scsibus || sc->maxunits > 1)
d1226 2
d1254 2
d1282 2
d1353 2
@


1.19
log
@make a define for dealing w/ the big bit (0x80); no func change
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.18 2006/08/28 02:50:14 mickey Exp $	*/
d413 1
d1033 3
@


1.18
log
@properly detect failed drives and do not crash bioctl; krw@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.17 2006/08/28 01:32:06 mickey Exp $	*/
d1095 2
a1096 1
		if (ciss_bitset(ldp->tgts[pd] & 0x7f, ldstat->bigfailed)) {
d1099 2
a1100 1
			bd->bd_channel = (ldp->tgts[pd] & 0x7f) / sc->ndrives;
d1140 3
a1142 2
				if (ldp->tgts[pd] == (0x80 + bb->bb_channel *
				    sc->ndrives + bb->bb_target))
d1300 1
a1300 1
			drv = 0x80 + i * sc->ndrives + j;
@


1.17
log
@set error and break -- not return an error before spl is set back in ioctl! found by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.16 2006/08/27 22:12:10 mickey Exp $	*/
a1079 1
		pdid = sc->scratch;
a1088 16
		if ((error = ciss_pdid(sc, ldp->tgts[pd], pdid, SCSI_POLL)))
			break;
		if (pdid->config & CISS_PD_SPARE)
			bd->bd_status = BIOC_SDHOTSPARE;
		else if (pdid->present & CISS_PD_PRESENT)
			bd->bd_status = BIOC_SDONLINE;
		else
			bd->bd_status = BIOC_SDINVALID;
		bd->bd_size = (u_int64_t)letoh32(pdid->nblocks) *
		    letoh16(pdid->blksz);
		bd->bd_channel = pdid->bus;  
		bd->bd_target = pdid->target;
		bd->bd_lun = 0;
		strlcpy(bd->bd_vendor, pdid->model, sizeof(bd->bd_vendor));
		strlcpy(bd->bd_serial, pdid->serial, sizeof(bd->bd_serial));
		bd->bd_procdev[0] = '\0';
d1092 1
d1095 33
@


1.16
log
@display proper volume device name in the volume line (; krw@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.15 2006/08/27 20:51:09 mickey Exp $	*/
d1044 4
a1047 2
		if (bv->bv_volid > sc->maxunits)
			return EINVAL;
d1081 4
a1084 2
		if (bd->bd_volid > sc->maxunits)
			return EINVAL;
d1086 4
a1089 2
		if ((pd = bd->bd_diskid) > ldp->ndrives)
			return EINVAL;
@


1.15
log
@basic monitoring and management support. there are a few more things to fix but fetching array status and rebuild/blinking works on compaq/hp boxen; testing and some fixes by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.14 2006/03/13 16:02:23 mickey Exp $	*/
d422 2
a423 2
			strlcpy(sc->sensors[i].desc,
			    ((struct device *)scsibus->sc_link[i][0]->device_softc)->dv_xname,
d425 3
d1057 1
a1057 1
		strlcpy(bv->bv_dev, ldid->label, sizeof(bv->bv_dev));
@


1.14
log
@repair commands w/ no scsi_xfer but the affected code was currently dead anyway; pointed out by Tonnerre LOMBARD <tonnerre@@thebsh.sygroup.ch>
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.13 2006/02/02 22:13:04 brad Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Michael Shalayeff
d20 2
d43 1
d45 2
a46 1
#include "bio.h"
d57 6
a62 6
	| CISS_D_CMD
	| CISS_D_INTR
	| CISS_D_MISC
	| CISS_D_DMA
	| CISS_D_IOCTL
	| CISS_D_ERR
d102 1
d109 2
d113 4
d142 1
d349 6
a354 2
/* TODO scan all physdev */
/* TODO scan all logdev */
d380 2
a381 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
d390 2
a391 1
	config_found(&sc->sc_dev, &sc->sc_link_raw, scsiprint);
d394 15
a408 1
#if NBIO1 > 0
d412 20
d450 1
a450 1
#if 0	/* TOSO */
d456 1
a456 1
}
a603 1
	struct ciss_cmd *cmd;
a621 1
	cmd = &ccb->ccb_cmd;
d624 1
a624 1
		    ccb->ccb_dmamap->dm_mapsize, (cmd->flags & CISS_CDB_IN) ?
d654 1
d668 1
d673 1
d683 1
d688 1
d696 1
d700 2
a701 1
		}
a716 1
	ccb->ccb_xs = NULL;
a748 1
	ccb->ccb_xs = NULL;
d766 1
a766 1
	CISS_DPRINTF(CISS_D_MISC, ("lmap %x:%x\n"
a788 1
	ccb->ccb_xs = NULL;
d794 1
a794 1
	cmd->tmo = 0;
d843 2
d851 1
a851 1
	cmd->tmo = xs->timeout < 1000? 1 : xs->timeout / 1000;
d910 1
a910 1
	cmd->tmo = xs->timeout < 1000? 1 : xs->timeout / 1000;
d969 1
a969 1
		panic("ciss: dead");	/* XX reset! */
d1005 6
d1012 1
a1012 1
ciss_ioctl(struct device *dev, u_long cmd, caddr_t addr)	/* TODO */
d1014 12
a1025 1
	/* struct ciss_softc *sc = (struct ciss_softc *)dev; */
d1027 2
a1028 1
	int error;
d1033 6
d1040 33
d1074 45
a1119 1
	case BIOCBLINK:
d1129 196
@


1.13
log
@make an exposed printf for debugging a debug printf and add a few commas
in the dmesg printing to make the dmesg entry look a little nicer.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.12 2005/12/13 15:55:58 brad Exp $	*/
d404 1
a404 1
}               
d552 1
d571 1
d574 1
a574 1
		    ccb->ccb_dmamap->dm_mapsize, (xs->flags & SCSI_DATA_IN) ?
d660 1
d693 1
d734 1
a787 2


@


1.12
log
@- Add a whole bunch of new PCI ids.
- Remove the version ("valance") check as it is not necessary.

From FreeBSD

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.11 2005/12/12 11:31:54 mickey Exp $	*/
d320 1
a320 1
	printf(": %d LD%s HW rev %d FW %4.4s/%4.4s\n",
d706 3
a708 1
printf("lmap %x:%x ", lmap->map[0].tgt, lmap->map[0].tgt2);
@


1.11
log
@make printf debug-only so some people would just shuddup
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.10 2005/12/02 11:35:10 mickey Exp $	*/
a143 6
		return -1;
	}

	if (sc->cfg.version != CISS_VERSION &&
	    sc->cfg.version != CISS_VERSION3) {
		printf(": unsupported version 0x%08x\n", sc->cfg.version);
@


1.10
log
@only poll if scsi_poll was requested
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.9 2005/11/23 14:46:47 mickey Exp $	*/
d51 1
d58 1
d641 3
a643 2
				printf("%s: cmd_stat %x scsi_stat 0x%x\n",
				    sc->sc_dev.dv_xname, rv, err->scsi_stat);
@


1.9
log
@hp sa p600 sas; from Srebrenko Sehic <haver@@insecure.dk>
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.8 2005/11/18 14:08:04 mickey Exp $	*/
d482 1
a482 1
	if (wait) {
@


1.8
log
@do not devide by zero
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.7 2005/09/07 04:00:16 mickey Exp $	*/
d145 2
a146 1
	if (sc->cfg.version != CISS_VERSION) {
@


1.7
log
@sync on shutdown
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.6 2005/08/20 18:01:35 mickey Exp $	*/
d363 1
a363 1
	sc->sc_link.openings = sc->maxcmd / sc->maxunits;	/* XXX */
d372 1
@


1.6
log
@handle timeouts and errors better
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.5 2005/08/03 00:09:38 mickey Exp $	*/
d134 1
d301 1
d305 1
d314 1
d327 5
d343 1
a343 1
#if 0
d351 1
a360 3
	timeout_set(&sc->sc_hb, ciss_heartbeat, sc);
	timeout_add(&sc->sc_hb, hz * 3);

d392 2
a394 1
	timeout_del(&sc->sc_hb);
d550 1
a550 1
ciss_done(struct ciss_ccb *ccb)		/* TODO */
d680 2
a681 1
	int total, error;
d683 1
d687 1
d702 2
a703 2
	if ((error = ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL|SCSI_NOSLEEP)))
		return error;
d705 2
d713 1
a713 1
ciss_sync(struct ciss_softc *sc)	/* TODO */
a714 1
#if 0
d717 8
a725 1
	inq = sc->scratch;
d727 2
a728 2
	ccb->ccb_len = sizeof(*inq);
	ccb->ccb_data = inq;
d733 1
a733 1
	cmd->flags = CISS_CDB_CMD | CISS_CDB_SIMPL | CISS_CDB_IN;
d736 7
a742 4
	cmd->cdb[0] = CISS_CMD_CTRL_GET;
	cmd->cdb[6] = CISS_CMS_CTRL_CTRL;
	cmd->cdb[7] = sizeof(*inq) >> 8;	/* biiiig endian */
	cmd->cdb[8] = sizeof(*inq) & 0xff;
d744 1
a744 4
	return ciss_cmd(ccb, BUS_DMA_NOWAIT, SCSI_POLL|SCSI_NOSLEEP);
#else
	return 0;
#endif
d784 1
d835 2
d958 2
@


1.6.2.1
log
@MFC:
Fixes by mickey@@

rev 1.9

make printf debug-only so some people would just shuddup

rev 1.10

only poll if scsi_poll was requested

ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.6 2005/08/20 18:01:35 mickey Exp $	*/
a50 1
#define	CISS_D_ERR	0x0020
a56 1
	| CISS_D_ERR
d472 1
a472 1
	if (wait && SCSI_POLL) {
d629 2
a630 3
				CISS_DPRINTF(CISS_D_ERR, ("%s: "
				    "cmd_stat %x scsi_stat 0x%x\n",
				    sc->sc_dev.dv_xname, rv, err->scsi_stat));
@


1.6.2.2
log
@fix a mistake in the last commit.

noticed by mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.6.2.1 2005/12/22 04:20:17 brad Exp $	*/
d474 1
a474 1
	if (wait & SCSI_POLL) {
@


1.5
log
@if fw provides no max sgl len -- suggest some of our own
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.4 2005/08/03 00:01:08 mickey Exp $	*/
d414 1
a414 1
	int i, error = 0;
d473 2
d477 7
a483 1
		for (;;) {
d486 10
a495 3
				tsleep(ccb, PRIBIO + 1, "ciss_cmd", 0);
				/* handle FAIL TODO */
				if (ccb->ccb_state != CISS_CCB_ONQ)
d497 1
d500 1
a500 1
				DELAY(1);
d522 6
@


1.4
log
@in config loop: make delay longer and less iterations to make it run in a better second
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.3 2005/08/02 23:56:34 mickey Exp $	*/
d160 2
@


1.3
log
@apparently reading idb sometimes produces better results if prepend
w/ a read from the next register (hell knows what's in it).
this whole driver work is done w/ help of genua.de and
also a card donated earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.2 2005/08/01 23:55:22 mickey Exp $	*/
d169 1
a169 1
	for (i = 1000000; i--; DELAY(1)) {
@


1.2
log
@make compile again
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss.c,v 1.1 2005/07/06 01:52:13 mickey Exp $	*/
d170 2
d194 1
a194 1
		    offsetof(struct ciss_config, amethod)) & CISS_METH_SIMPL)
a623 1
	inq = sc->scratch;
@


1.1
log
@smartarray 5* raid controller; does io but needs more work; commented out in configs for now
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d901 2
a902 1
	struct ciss_softc *sc = (struct ciss_softc *)dev;
d905 1
d907 3
a909 2
	case BIOCPING:
	case BIOCCAPABILITIES:
a910 4
	case BIOCBLINK:
	case BIOCSTARTSTOP:
	case BIOCSTATUS:
	case BIOCSCSICMD:
d916 1
@

