head	1.46;
access;
symbols
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.6
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.43.0.6
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.41.0.10
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.8
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.4
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.6
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.4
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.8
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.6
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	SMP:1.10.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.46
date	2016.01.22.00.40.25;	author jsg;	state Exp;
branches;
next	1.45;
commitid	Em10h35MtrblT55E;

1.45
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.44;
commitid	p4LJxGKbi0BU2cG6;

1.44
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.43;
commitid	uzzBR7hz9ncd4O6G;

1.43
date	2013.11.18.23.32.23;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.03.15.49.16;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.29.23.33.39;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.03.10.58.38;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2008.07.24.19.03.08;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.20.16.10.09;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.03.16.53.16;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.15.05.33.39;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.03.22.31.27;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.19.24.22;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.09.20.44.57;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.17.13.45.38;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.31.23.15.35;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.06.09.30.31;	author mickey;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.24.06.52.33;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.04.22.53.24;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.18.17.09.09;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.10.20.07.35;	author mickey;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.03.14.02.21.32;	author mickey;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.03.09.17.06.12;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.19.20.47.02;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.07.20.27.46;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.08.20.44.56;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.07.20.15.53;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.25.23.50.20;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.15.17.00.24;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.15.16.56.13;	author mickey;	state Exp;
branches;
next	;

1.9.2.1
date	2001.05.11.04.49.50;	author jason;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.05.22.23.00.23;	author jason;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.14.22.24.18;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.07.04.10.41.13;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.28.12.09.41;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2003.05.13.19.35.02;	author ho;	state Exp;
branches;
next	1.10.2.9;

1.10.2.9
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.10.2.10;

1.10.2.10
date	2004.02.19.10.56.21;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.05.19.21.59.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.46
log
@remove a surplus splbio
ok deraadt@@ krw@@
@
text
@/*	$OpenBSD: twe.c,v 1.45 2015/03/14 03:38:47 jsg Exp $	*/

/*
 * Copyright (c) 2000-2002 Michael Shalayeff.  All rights reserved.
 *
 * The SCSI emulation layer is derived from gdt(4) driver,
 * Copyright (c) 1999, 2000 Niklas Hallqvist. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/* #define	TWE_DEBUG */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/kthread.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/ic/twereg.h>
#include <dev/ic/twevar.h>

#ifdef TWE_DEBUG
#define	TWE_DPRINTF(m,a)	if (twe_debug & (m)) printf a
#define	TWE_D_CMD	0x0001
#define	TWE_D_INTR	0x0002
#define	TWE_D_MISC	0x0004
#define	TWE_D_DMA	0x0008
#define	TWE_D_AEN	0x0010
int twe_debug = 0;
#else
#define	TWE_DPRINTF(m,a)	/* m, a */
#endif

struct cfdriver twe_cd = {
	NULL, "twe", DV_DULL
};

void	twe_scsi_cmd(struct scsi_xfer *);

struct scsi_adapter twe_switch = {
	twe_scsi_cmd, tweminphys, 0, 0,
};

void *twe_get_ccb(void *);
void twe_put_ccb(void *, void *);
void twe_dispose(struct twe_softc *sc);
int  twe_cmd(struct twe_ccb *ccb, int flags, int wait);
int  twe_start(struct twe_ccb *ccb, int wait);
int  twe_complete(struct twe_ccb *ccb);
int  twe_done(struct twe_softc *sc, struct twe_ccb *ccb);
void twe_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size);
void twe_thread_create(void *v);
void twe_thread(void *v);
void twe_aen(void *, void *);

void *
twe_get_ccb(void *xsc)
{
	struct twe_softc *sc = xsc;
	struct twe_ccb *ccb;

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = TAILQ_LAST(&sc->sc_free_ccb, twe_queue_head);
	if (ccb != NULL)
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ccb_link);
	mtx_leave(&sc->sc_ccb_mtx);

	return (ccb);
}

void
twe_put_ccb(void *xsc, void *xccb)
{
	struct twe_softc *sc = xsc;
	struct twe_ccb *ccb = xccb;

	ccb->ccb_state = TWE_CCB_FREE;
	mtx_enter(&sc->sc_ccb_mtx);
	TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_link);
	mtx_leave(&sc->sc_ccb_mtx);
}

void
twe_dispose(sc)
	struct twe_softc *sc;
{
	register struct twe_ccb *ccb;
	if (sc->sc_cmdmap != NULL) {
		bus_dmamap_destroy(sc->dmat, sc->sc_cmdmap);
		/* traverse the ccbs and destroy the maps */
		for (ccb = &sc->sc_ccbs[TWE_MAXCMDS - 1]; ccb >= sc->sc_ccbs; ccb--)
			if (ccb->ccb_dmamap)
				bus_dmamap_destroy(sc->dmat, ccb->ccb_dmamap);
	}
	bus_dmamem_unmap(sc->dmat, sc->sc_cmds, 
	    sizeof(struct twe_cmd) * TWE_MAXCMDS);
	bus_dmamem_free(sc->dmat, sc->sc_cmdseg, 1);
}

int
twe_attach(sc)
	struct twe_softc *sc;
{
	struct scsibus_attach_args saa;
	/* this includes a buffer for drive config req, and a capacity req */
	u_int8_t	param_buf[2 * TWE_SECTOR_SIZE + TWE_ALIGN - 1];
	struct twe_param *pb = (void *)
	    (((u_long)param_buf + TWE_ALIGN - 1) & ~(TWE_ALIGN - 1));
	struct twe_param *cap = (void *)((u_int8_t *)pb + TWE_SECTOR_SIZE);
	struct twe_ccb	*ccb;
	struct twe_cmd	*cmd;
	u_int32_t	status;
	int		error, i, retry, nunits, nseg;
	const char	*errstr;
	twe_lock_t	lock;
	paddr_t		pa;

	error = bus_dmamem_alloc(sc->dmat, sizeof(struct twe_cmd) * TWE_MAXCMDS,
	    PAGE_SIZE, 0, sc->sc_cmdseg, 1, &nseg, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot allocate commands (%d)\n", error);
		return (1);
	}

	error = bus_dmamem_map(sc->dmat, sc->sc_cmdseg, nseg,
	    sizeof(struct twe_cmd) * TWE_MAXCMDS,
	    (caddr_t *)&sc->sc_cmds, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot map commands (%d)\n", error);
		bus_dmamem_free(sc->dmat, sc->sc_cmdseg, 1);
		return (1);
	}

	error = bus_dmamap_create(sc->dmat,
	    sizeof(struct twe_cmd) * TWE_MAXCMDS, TWE_MAXCMDS,
	    sizeof(struct twe_cmd) * TWE_MAXCMDS, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_cmdmap);
	if (error) {
		printf(": cannot create ccb cmd dmamap (%d)\n", error);
		twe_dispose(sc);
		return (1);
	}
	error = bus_dmamap_load(sc->dmat, sc->sc_cmdmap, sc->sc_cmds,
	    sizeof(struct twe_cmd) * TWE_MAXCMDS, NULL, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot load command dma map (%d)\n", error);
		twe_dispose(sc);
		return (1);
	}

	TAILQ_INIT(&sc->sc_ccb2q);
	TAILQ_INIT(&sc->sc_ccbq);
	TAILQ_INIT(&sc->sc_free_ccb);
	TAILQ_INIT(&sc->sc_done_ccb);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, twe_get_ccb, twe_put_ccb);

	scsi_ioh_set(&sc->sc_aen, &sc->sc_iopool, twe_aen, sc);

	pa = sc->sc_cmdmap->dm_segs[0].ds_addr +
	    sizeof(struct twe_cmd) * (TWE_MAXCMDS - 1);
	for (cmd = (struct twe_cmd *)sc->sc_cmds + TWE_MAXCMDS - 1;
	     cmd >= (struct twe_cmd *)sc->sc_cmds; cmd--, pa -= sizeof(*cmd)) {

		cmd->cmd_index = cmd - (struct twe_cmd *)sc->sc_cmds;
		ccb = &sc->sc_ccbs[cmd->cmd_index];
		error = bus_dmamap_create(sc->dmat,
		    TWE_MAXFER, TWE_MAXOFFSETS, TWE_MAXFER, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->ccb_dmamap);
		if (error) {
			printf(": cannot create ccb dmamap (%d)\n", error);
			twe_dispose(sc);
			return (1);
		}
		ccb->ccb_sc = sc;
		ccb->ccb_cmd = cmd;
		ccb->ccb_cmdpa = pa;
		ccb->ccb_state = TWE_CCB_FREE;
		TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_link);
	}

	for (errstr = NULL, retry = 3; retry--; ) {
		int		veseen_srst;
		u_int16_t	aen;

		if (errstr)
			TWE_DPRINTF(TWE_D_MISC, ("%s ", errstr));

		for (i = 350000; i--; DELAY(100)) {
			status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
			if (status & TWE_STAT_CPURDY)
				break;
		}

		if (!(status & TWE_STAT_CPURDY)) {
			errstr = ": card CPU is not ready\n";
			continue;
		}

		/* soft reset, disable ints */
		bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
		    TWE_CTRL_SRST |
		    TWE_CTRL_CHOSTI | TWE_CTRL_CATTNI | TWE_CTRL_CERR |
		    TWE_CTRL_MCMDI | TWE_CTRL_MRDYI |
		    TWE_CTRL_MINT);

		for (i = 350000; i--; DELAY(100)) {
			status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
			if (status & TWE_STAT_ATTNI)
				break;
		}

		if (!(status & TWE_STAT_ATTNI)) {
			errstr = ": cannot get card's attention\n";
			continue;
		}

		/* drain aen queue */
		for (veseen_srst = 0, aen = -1; aen != TWE_AEN_QEMPTY; ) {

			ccb = scsi_io_get(&sc->sc_iopool, 0);
			if (ccb == NULL) {
				errstr = ": out of ccbs\n";
				break;
			}

			ccb->ccb_xs = NULL;
			ccb->ccb_data = pb;
			ccb->ccb_length = TWE_SECTOR_SIZE;
			ccb->ccb_state = TWE_CCB_READY;
			cmd = ccb->ccb_cmd;
			cmd->cmd_unit_host = TWE_UNITHOST(0, 0);
			cmd->cmd_op = TWE_CMD_GPARAM;
			cmd->cmd_param.count = 1;

			pb->table_id = TWE_PARAM_AEN;
			pb->param_id = 2;
			pb->param_size = 2;

			error = twe_cmd(ccb, BUS_DMA_NOWAIT, 1);
			scsi_io_put(&sc->sc_iopool, ccb);
			if (error) {
				errstr = ": error draining attention queue\n";
				break;
			}

			aen = *(u_int16_t *)pb->data;
			TWE_DPRINTF(TWE_D_AEN, ("aen=%x ", aen));
			if (aen == TWE_AEN_SRST)
				veseen_srst++;
		}

		if (!veseen_srst) {
			errstr = ": we don't get it\n";
			continue;
		}

		if (status & TWE_STAT_CPUERR) {
			errstr = ": card CPU error detected\n";
			continue;
		}

		if (status & TWE_STAT_PCIPAR) {
			errstr = ": PCI parity error detected\n";
			continue;
		}

		if (status & TWE_STAT_QUEUEE ) {
			errstr = ": queuing error detected\n";
			continue;
		}

		if (status & TWE_STAT_PCIABR) {
			errstr = ": PCI abort\n";
			continue;
		}

		while (!(status & TWE_STAT_RQE)) {
			bus_space_read_4(sc->iot, sc->ioh, TWE_READYQUEUE);
			status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
		}

		break;
	}

	if (retry < 0) {
		printf("%s", errstr);
		twe_dispose(sc);
		return 1;
	}

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL) {
		printf(": out of ccbs\n");
		twe_dispose(sc);
		return 1;
	}

	ccb->ccb_xs = NULL;
	ccb->ccb_data = pb;
	ccb->ccb_length = TWE_SECTOR_SIZE;
	ccb->ccb_state = TWE_CCB_READY;
	cmd = ccb->ccb_cmd;
	cmd->cmd_unit_host = TWE_UNITHOST(0, 0);
	cmd->cmd_op = TWE_CMD_GPARAM;
	cmd->cmd_param.count = 1;

	pb->table_id = TWE_PARAM_UC;
	pb->param_id = TWE_PARAM_UC;
	pb->param_size = TWE_MAX_UNITS;

	error = twe_cmd(ccb, BUS_DMA_NOWAIT, 1);
	scsi_io_put(&sc->sc_iopool, ccb);
	if (error) {
		printf(": failed to fetch unit parameters\n");
		twe_dispose(sc);
		return 1;
	}

	/* we are assuming last read status was good */
	printf(": Escalade V%d.%d\n", TWE_MAJV(status), TWE_MINV(status));

	for (nunits = i = 0; i < TWE_MAX_UNITS; i++) {
		if (pb->data[i] == 0)
			continue;

		ccb = scsi_io_get(&sc->sc_iopool, 0);
		if (ccb == NULL) {
			printf(": out of ccbs\n");
			twe_dispose(sc);
			return 1;
		}

		ccb->ccb_xs = NULL;
		ccb->ccb_data = cap;
		ccb->ccb_length = TWE_SECTOR_SIZE;
		ccb->ccb_state = TWE_CCB_READY;
		cmd = ccb->ccb_cmd;
		cmd->cmd_unit_host = TWE_UNITHOST(0, 0);
		cmd->cmd_op = TWE_CMD_GPARAM;
		cmd->cmd_param.count = 1;

		cap->table_id = TWE_PARAM_UI + i;
		cap->param_id = 4;
		cap->param_size = 4;	/* 4 bytes */

		lock = TWE_LOCK(sc);
		twe_cmd(ccb, BUS_DMA_NOWAIT, 1);
		TWE_UNLOCK(sc, lock);
		scsi_io_put(&sc->sc_iopool, ccb);
		if (error) {
			printf("%s: error fetching capacity for unit %d\n",
			    sc->sc_dev.dv_xname, i);
			continue;
		}

		nunits++;
		sc->sc_hdr[i].hd_present = 1;
		sc->sc_hdr[i].hd_devtype = 0;
		sc->sc_hdr[i].hd_size = letoh32(*(u_int32_t *)cap->data);
		TWE_DPRINTF(TWE_D_MISC, ("twed%d: size=%d\n",
		    i, sc->sc_hdr[i].hd_size));
	}

	if (!nunits)
		nunits++;

	/* TODO: fetch & print cache params? */

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &twe_switch;
	sc->sc_link.adapter_target = TWE_MAX_UNITS;
	sc->sc_link.openings = TWE_MAXCMDS / nunits;
	sc->sc_link.adapter_buswidth = TWE_MAX_UNITS;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	config_found(&sc->sc_dev, &saa, scsiprint);

	kthread_create_deferred(twe_thread_create, sc);

	return (0);
}

void
twe_thread_create(void *v)
{
	struct twe_softc *sc = v;

	if (kthread_create(twe_thread, sc, &sc->sc_thread,
	    sc->sc_dev.dv_xname)) {
		/* TODO disable twe */
		printf("%s: failed to create kernel thread, disabled\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	TWE_DPRINTF(TWE_D_CMD, ("stat=%b ",
	    bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS), TWE_STAT_BITS));
	/*
	 * ack all before enable, cannot be done in one
	 * operation as it seems clear is not processed
	 * if enable is specified.
	 */
	bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
	    TWE_CTRL_CHOSTI | TWE_CTRL_CATTNI | TWE_CTRL_CERR);
	TWE_DPRINTF(TWE_D_CMD, ("stat=%b ",
	    bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS), TWE_STAT_BITS));
	/* enable interrupts */
	bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
	    TWE_CTRL_EINT | TWE_CTRL_ERDYI |
	    /*TWE_CTRL_HOSTI |*/ TWE_CTRL_MCMDI);
}

void
twe_thread(v)
	void *v;
{
	struct twe_softc *sc = v;
	struct twe_ccb *ccb;
	twe_lock_t lock;
	u_int32_t status;
	int err;

	for (;;) {
		lock = TWE_LOCK(sc);

		while (!TAILQ_EMPTY(&sc->sc_done_ccb)) {
			ccb = TAILQ_FIRST(&sc->sc_done_ccb);
			TAILQ_REMOVE(&sc->sc_done_ccb, ccb, ccb_link);
			if ((err = twe_done(sc, ccb)))
				printf("%s: done failed (%d)\n",
				    sc->sc_dev.dv_xname, err);
		}

		status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
		TWE_DPRINTF(TWE_D_INTR, ("twe_thread stat=%b ",
		    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
		while (!(status & TWE_STAT_CQF) &&
		    !TAILQ_EMPTY(&sc->sc_ccb2q)) {

			ccb = TAILQ_LAST(&sc->sc_ccb2q, twe_queue_head);
			TAILQ_REMOVE(&sc->sc_ccb2q, ccb, ccb_link);

			ccb->ccb_state = TWE_CCB_QUEUED;
			TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);
			bus_space_write_4(sc->iot, sc->ioh, TWE_COMMANDQUEUE,
			    ccb->ccb_cmdpa);

			status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
			TWE_DPRINTF(TWE_D_INTR, ("twe_thread stat=%b ",
			    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
		}

		if (!TAILQ_EMPTY(&sc->sc_ccb2q))
			bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
			    TWE_CTRL_ECMDI);

		TWE_UNLOCK(sc, lock);
		sc->sc_thread_on = 1;
		tsleep(sc, PWAIT, "twespank", 0);
	}
}

int
twe_cmd(ccb, flags, wait)
	struct twe_ccb *ccb;
	int flags, wait;
{
	struct twe_softc *sc = ccb->ccb_sc;
	bus_dmamap_t dmap;
	struct twe_cmd *cmd;
	struct twe_segs *sgp;
	int error, i;

	if (ccb->ccb_data && ((u_long)ccb->ccb_data & (TWE_ALIGN - 1))) {
		TWE_DPRINTF(TWE_D_DMA, ("data=%p is unaligned ",ccb->ccb_data));
		ccb->ccb_realdata = ccb->ccb_data;

		error = bus_dmamem_alloc(sc->dmat, ccb->ccb_length, PAGE_SIZE,
		    0, ccb->ccb_2bseg, TWE_MAXOFFSETS, &ccb->ccb_2nseg,
		    BUS_DMA_NOWAIT);
		if (error) {
			TWE_DPRINTF(TWE_D_DMA, ("2buf alloc failed(%d) ", error));
			return (ENOMEM);
		}

		error = bus_dmamem_map(sc->dmat, ccb->ccb_2bseg, ccb->ccb_2nseg,
		    ccb->ccb_length, (caddr_t *)&ccb->ccb_data, BUS_DMA_NOWAIT);
		if (error) {
			TWE_DPRINTF(TWE_D_DMA, ("2buf map failed(%d) ", error));
			bus_dmamem_free(sc->dmat, ccb->ccb_2bseg, ccb->ccb_2nseg);
			return (ENOMEM);
		}
		bcopy(ccb->ccb_realdata, ccb->ccb_data, ccb->ccb_length);
	} else
		ccb->ccb_realdata = NULL;

	dmap = ccb->ccb_dmamap;
	cmd = ccb->ccb_cmd;
	cmd->cmd_status = 0;

	if (ccb->ccb_data) {
		error = bus_dmamap_load(sc->dmat, dmap, ccb->ccb_data,
		    ccb->ccb_length, NULL, flags);
		if (error) {
			if (error == EFBIG)
				printf("more than %d dma segs\n", TWE_MAXOFFSETS);
			else
				printf("error %d loading dma map\n", error);

			if (ccb->ccb_realdata) {
				bus_dmamem_unmap(sc->dmat, ccb->ccb_data,
				    ccb->ccb_length);
				bus_dmamem_free(sc->dmat, ccb->ccb_2bseg,
				    ccb->ccb_2nseg);
			}
			return error;
		}
		/* load addresses into command */
		switch (cmd->cmd_op) {
		case TWE_CMD_GPARAM:
		case TWE_CMD_SPARAM:
			sgp = cmd->cmd_param.segs;
			break;
		case TWE_CMD_READ:
		case TWE_CMD_WRITE:
			sgp = cmd->cmd_io.segs;
			break;
		default:
			/* no data transfer */
			TWE_DPRINTF(TWE_D_DMA, ("twe_cmd: unknown sgp op=%x\n",
			    cmd->cmd_op));
			sgp = NULL;
			break;
		}
		TWE_DPRINTF(TWE_D_DMA, ("data=%p<", ccb->ccb_data));
		if (sgp) {
			/*
			 * we know that size is in the upper byte,
			 * and we do not worry about overflow
			 */
			cmd->cmd_op += (2 * dmap->dm_nsegs) << 8;
			bzero (sgp, TWE_MAXOFFSETS * sizeof(*sgp));
			for (i = 0; i < dmap->dm_nsegs; i++, sgp++) {
				sgp->twes_addr = htole32(dmap->dm_segs[i].ds_addr);
				sgp->twes_len  = htole32(dmap->dm_segs[i].ds_len);
				TWE_DPRINTF(TWE_D_DMA, ("%x[%x] ",
				    dmap->dm_segs[i].ds_addr,
				    dmap->dm_segs[i].ds_len));
			}
		}
		TWE_DPRINTF(TWE_D_DMA, ("> "));
		bus_dmamap_sync(sc->dmat, dmap, 0, dmap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);
	}
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sc->sc_cmdmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	if ((error = twe_start(ccb, wait))) {
		bus_dmamap_unload(sc->dmat, dmap);
		if (ccb->ccb_realdata) {
			bus_dmamem_unmap(sc->dmat, ccb->ccb_data,
			    ccb->ccb_length);
			bus_dmamem_free(sc->dmat, ccb->ccb_2bseg,
			    ccb->ccb_2nseg);
		}
		return (error);
	}

	return wait? twe_complete(ccb) : 0;
}

int
twe_start(ccb, wait)
	struct twe_ccb *ccb;
	int wait;
{
	struct twe_softc*sc = ccb->ccb_sc;
	struct twe_cmd	*cmd = ccb->ccb_cmd;
	u_int32_t	status;
	int i;

	cmd->cmd_op = htole16(cmd->cmd_op);

	if (!wait) {

		TWE_DPRINTF(TWE_D_CMD, ("prequeue(%d) ", cmd->cmd_index));
		ccb->ccb_state = TWE_CCB_PREQUEUED;
		TAILQ_INSERT_TAIL(&sc->sc_ccb2q, ccb, ccb_link);
		wakeup(sc);
		return 0;
	}

	for (i = 1000; i--; DELAY(10)) {

		status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
		if (!(status & TWE_STAT_CQF))
			break;
		TWE_DPRINTF(TWE_D_CMD,  ("twe_start stat=%b ",
		    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
	}

	if (!(status & TWE_STAT_CQF)) {
		bus_space_write_4(sc->iot, sc->ioh, TWE_COMMANDQUEUE,
		    ccb->ccb_cmdpa);

		TWE_DPRINTF(TWE_D_CMD, ("queue(%d) ", cmd->cmd_index));
		ccb->ccb_state = TWE_CCB_QUEUED;
		TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);
		return 0;

	} else {

		printf("%s: twe_start(%d) timed out\n",
		    sc->sc_dev.dv_xname, cmd->cmd_index);

		return EPERM;
	}
}

int
twe_complete(ccb)
	struct twe_ccb *ccb;
{
	struct twe_softc *sc = ccb->ccb_sc;
	struct scsi_xfer *xs = ccb->ccb_xs;
	int i;

	for (i = 100 * (xs? xs->timeout : 35000); i--; DELAY(10)) {
		u_int32_t status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);

		/* TWE_DPRINTF(TWE_D_CMD,  ("twe_intr stat=%b ",
		    status & TWE_STAT_FLAGS, TWE_STAT_BITS)); */

		while (!(status & TWE_STAT_RQE)) {
			struct twe_ccb *ccb1;
			u_int32_t ready;

			ready = bus_space_read_4(sc->iot, sc->ioh,
			    TWE_READYQUEUE);

			TWE_DPRINTF(TWE_D_CMD, ("ready=%x ", ready));

			ccb1 = &sc->sc_ccbs[TWE_READYID(ready)];
			TAILQ_REMOVE(&sc->sc_ccbq, ccb1, ccb_link);
			ccb1->ccb_state = TWE_CCB_DONE;
			if (!twe_done(sc, ccb1) && ccb1 == ccb) {
				TWE_DPRINTF(TWE_D_CMD, ("complete\n"));
				return 0;
			}

			status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
			/* TWE_DPRINTF(TWE_D_CMD,  ("twe_intr stat=%b ",
			    status & TWE_STAT_FLAGS, TWE_STAT_BITS)); */
		}
	}

	return 1;
}

int
twe_done(sc, ccb)
	struct twe_softc *sc;
	struct twe_ccb *ccb;
{
	struct twe_cmd *cmd = ccb->ccb_cmd;
	struct scsi_xfer *xs = ccb->ccb_xs;
	bus_dmamap_t	dmap;
	twe_lock_t	lock;

	TWE_DPRINTF(TWE_D_CMD, ("done(%d) ", cmd->cmd_index));

	if (ccb->ccb_state != TWE_CCB_DONE) {
		printf("%s: undone ccb %d ready\n",
		     sc->sc_dev.dv_xname, cmd->cmd_index);
		return 1;
	}

	dmap = ccb->ccb_dmamap;
	if (xs) {
		if (xs->cmd->opcode != PREVENT_ALLOW &&
		    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			bus_dmamap_sync(sc->dmat, dmap, 0,
			    dmap->dm_mapsize, (xs->flags & SCSI_DATA_IN) ?
			    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, dmap);
		}
	} else {
		switch (letoh16(cmd->cmd_op)) {
		case TWE_CMD_GPARAM:
		case TWE_CMD_READ:
			bus_dmamap_sync(sc->dmat, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->dmat, dmap);
			break;
		case TWE_CMD_SPARAM:
		case TWE_CMD_WRITE:
			bus_dmamap_sync(sc->dmat, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, dmap);
			break;
		default:
			/* no data */
			break;
		}
	}

	if (ccb->ccb_realdata) {
		bcopy(ccb->ccb_data, ccb->ccb_realdata, ccb->ccb_length);
		bus_dmamem_unmap(sc->dmat, ccb->ccb_data, ccb->ccb_length);
		bus_dmamem_free(sc->dmat, ccb->ccb_2bseg, ccb->ccb_2nseg);
	}

	lock = TWE_LOCK(sc);

	if (xs) {
		xs->resid = 0;
		scsi_done(xs);
	}
	TWE_UNLOCK(sc, lock);

	return 0;
}

void
tweminphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > TWE_MAXFER)
		bp->b_bcount = TWE_MAXFER;
	minphys(bp);
}

void
twe_copy_internal_data(xs, v, size)
	struct scsi_xfer *xs;
	void *v;
	size_t size;
{
	size_t copy_cnt;

	TWE_DPRINTF(TWE_D_MISC, ("twe_copy_internal_data "));

	if (!xs->datalen)
		printf("uio move is not yet supported\n");
	else {
		copy_cnt = MIN(size, xs->datalen);
		bcopy(v, xs->data, copy_cnt);
	}
}

void
twe_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *link = xs->sc_link;
	struct twe_softc *sc = link->adapter_softc;
	struct twe_ccb *ccb = xs->io;
	struct twe_cmd *cmd;
	struct scsi_inquiry_data inq;
	struct scsi_sense_data sd;
	struct scsi_read_cap_data rcd;
	u_int8_t target = link->target;
	u_int32_t blockno, blockcnt;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	int error, op, flags, wait;
	twe_lock_t lock;


	if (target >= TWE_MAX_UNITS || !sc->sc_hdr[target].hd_present ||
	    link->lun != 0) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	TWE_DPRINTF(TWE_D_CMD, ("twe_scsi_cmd "));

	xs->error = XS_NOERROR;

	switch (xs->cmd->opcode) {
	case TEST_UNIT_READY:
	case START_STOP:
#if 0
	case VERIFY:
#endif
		TWE_DPRINTF(TWE_D_CMD, ("opc %d tgt %d ", xs->cmd->opcode,
		    target));
		break;

	case REQUEST_SENSE:
		TWE_DPRINTF(TWE_D_CMD, ("REQUEST SENSE tgt %d ", target));
		bzero(&sd, sizeof sd);
		sd.error_code = SSD_ERRCODE_CURRENT;
		sd.segment = 0;
		sd.flags = SKEY_NO_SENSE;
		*(u_int32_t*)sd.info = htole32(0);
		sd.extra_len = 0;
		twe_copy_internal_data(xs, &sd, sizeof sd);
		break;

	case INQUIRY:
		TWE_DPRINTF(TWE_D_CMD, ("INQUIRY tgt %d devtype %x ", target,
		    sc->sc_hdr[target].hd_devtype));
		bzero(&inq, sizeof inq);
		inq.device =
		    (sc->sc_hdr[target].hd_devtype & 4) ? T_CDROM : T_DIRECT;
		inq.dev_qual2 =
		    (sc->sc_hdr[target].hd_devtype & 1) ? SID_REMOVABLE : 0;
		inq.version = 2;
		inq.response_format = 2;
		inq.additional_length = 32;
		strlcpy(inq.vendor, "3WARE  ", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Host drive  #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
		twe_copy_internal_data(xs, &inq, sizeof inq);
		break;

	case READ_CAPACITY:
		TWE_DPRINTF(TWE_D_CMD, ("READ CAPACITY tgt %d ", target));
		bzero(&rcd, sizeof rcd);
		_lto4b(sc->sc_hdr[target].hd_size - 1, rcd.addr);
		_lto4b(TWE_SECTOR_SIZE, rcd.length);
		twe_copy_internal_data(xs, &rcd, sizeof rcd);
		break;

	case PREVENT_ALLOW:
		TWE_DPRINTF(TWE_D_CMD, ("PREVENT/ALLOW "));
		scsi_done(xs);
		return;

	case READ_COMMAND:
	case READ_BIG:
	case WRITE_COMMAND:
	case WRITE_BIG:
	case SYNCHRONIZE_CACHE:
		lock = TWE_LOCK(sc);

		flags = 0;
		if (xs->cmd->opcode == SYNCHRONIZE_CACHE) {
			blockno = blockcnt = 0;
		} else {
			/* A read or write operation. */
			if (xs->cmdlen == 6) {
				rw = (struct scsi_rw *)xs->cmd;
				blockno = _3btol(rw->addr) &
				    (SRW_TOPADDR << 16 | 0xffff);
				blockcnt = rw->length ? rw->length : 0x100;
			} else {
				rwb = (struct scsi_rw_big *)xs->cmd;
				blockno = _4btol(rwb->addr);
				blockcnt = _2btol(rwb->length);
				/* reflect DPO & FUA flags */
				if (xs->cmd->opcode == WRITE_BIG &&
				    rwb->byte2 & 0x18)
					flags = TWE_FLAGS_CACHEDISABLE;
			}
			if (blockno >= sc->sc_hdr[target].hd_size ||
			    blockno + blockcnt > sc->sc_hdr[target].hd_size) {
				printf("%s: out of bounds %u-%u >= %u\n",
				    sc->sc_dev.dv_xname, blockno, blockcnt,
				    sc->sc_hdr[target].hd_size);
				xs->error = XS_DRIVER_STUFFUP;
				scsi_done(xs);
				TWE_UNLOCK(sc, lock);
				return;
			}
		}

		switch (xs->cmd->opcode) {
		case READ_COMMAND:	op = TWE_CMD_READ;	break;
		case READ_BIG:		op = TWE_CMD_READ;	break;
		case WRITE_COMMAND:	op = TWE_CMD_WRITE;	break;
		case WRITE_BIG:		op = TWE_CMD_WRITE;	break;
		default:		op = TWE_CMD_NOP;	break;
		}

		ccb->ccb_xs = xs;
		ccb->ccb_data = xs->data;
		ccb->ccb_length = xs->datalen;
		ccb->ccb_state = TWE_CCB_READY;
		cmd = ccb->ccb_cmd;
		cmd->cmd_unit_host = TWE_UNITHOST(target, 0); /* XXX why 0? */
		cmd->cmd_op = op;
		cmd->cmd_flags = flags;
		cmd->cmd_io.count = htole16(blockcnt);
		cmd->cmd_io.lba = htole32(blockno);
		wait = xs->flags & SCSI_POLL;
		if (!sc->sc_thread_on)
			wait |= SCSI_POLL;

		if ((error = twe_cmd(ccb, ((xs->flags & SCSI_NOSLEEP)?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK), wait))) {

			TWE_DPRINTF(TWE_D_CMD, ("failed %p ", xs));
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
		}

		TWE_UNLOCK(sc, lock);
		return;

	default:
		TWE_DPRINTF(TWE_D_CMD, ("unsupported scsi command %#x tgt %d ",
		    xs->cmd->opcode, target));
		xs->error = XS_DRIVER_STUFFUP;
	}

	scsi_done(xs);
}

int
twe_intr(v)
	void *v;
{
	struct twe_softc *sc = v;
	struct twe_ccb	*ccb;
	u_int32_t	status;
	int		rv = 0;

	status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
	TWE_DPRINTF(TWE_D_INTR,  ("twe_intr stat=%b ",
	    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
#if 0
	if (status & TWE_STAT_HOSTI) {

		bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
		    TWE_CTRL_CHOSTI);
	}
#endif

	if (status & TWE_STAT_RDYI) {

		while (!(status & TWE_STAT_RQE)) {

			u_int32_t ready;

			/*
			 * it seems that reading ready queue
			 * we get all the status bits in each ready word.
			 * i wonder if it's legal to use those for
			 * status and avoid extra read below
			 */
			ready = bus_space_read_4(sc->iot, sc->ioh,
			    TWE_READYQUEUE);

			ccb = &sc->sc_ccbs[TWE_READYID(ready)];
			TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
			ccb->ccb_state = TWE_CCB_DONE;
			TAILQ_INSERT_TAIL(&sc->sc_done_ccb, ccb, ccb_link);
			rv++;

			status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
			TWE_DPRINTF(TWE_D_INTR, ("twe_intr stat=%b ",
			    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
		}
	}

	if (status & TWE_STAT_CMDI) {
		rv++;
		bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
		    TWE_CTRL_MCMDI);
	}

	if (rv)
		wakeup(sc);

	if (status & TWE_STAT_ATTNI) {
		/*
		 * we know no attentions of interest right now.
		 * one of those would be mirror degradation i think.
		 * or, what else exists in there?
		 * maybe 3ware can answer that?
		 */
		bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
		    TWE_CTRL_CATTNI);

		scsi_ioh_add(&sc->sc_aen);
	}

	return rv;
}

void
twe_aen(void *cookie, void *io)
{
	struct twe_softc *sc = cookie;
	struct twe_ccb *ccb = io;
	struct twe_cmd *cmd = ccb->ccb_cmd;

	u_int8_t param_buf[2 * TWE_SECTOR_SIZE + TWE_ALIGN - 1];
	struct twe_param *pb = (void *) (((u_long)param_buf +
	    TWE_ALIGN - 1) & ~(TWE_ALIGN - 1));
	u_int16_t aen;

	twe_lock_t lock;
	int error;

	ccb->ccb_xs = NULL;
	ccb->ccb_data = pb;
	ccb->ccb_length = TWE_SECTOR_SIZE;
	ccb->ccb_state = TWE_CCB_READY;
	cmd->cmd_unit_host = TWE_UNITHOST(0, 0);
	cmd->cmd_op = TWE_CMD_GPARAM;
	cmd->cmd_flags = 0;
	cmd->cmd_param.count = 1;

	pb->table_id = TWE_PARAM_AEN;
	pb->param_id = 2;
	pb->param_size = 2;

	lock = TWE_LOCK(sc);
	error = twe_cmd(ccb, BUS_DMA_NOWAIT, 1);
	TWE_UNLOCK(sc, lock);
	scsi_io_put(&sc->sc_iopool, ccb);

	if (error) {
		printf("%s: error draining attention queue\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	aen = *(u_int16_t *)pb->data;
	if (aen != TWE_AEN_QEMPTY) 
		scsi_ioh_add(&sc->sc_aen);
}
@


1.45
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.44 2014/09/14 14:17:25 jsg Exp $	*/
a453 1
	splbio();
@


1.44
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.43 2013/11/18 23:32:23 deraadt Exp $	*/
a36 1
#include <sys/kernel.h>
@


1.43
log
@format string
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.42 2013/11/18 20:21:51 deraadt Exp $	*/
a38 1
#include <sys/proc.h>
@


1.42
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.41 2011/07/17 22:46:48 matthew Exp $	*/
d316 1
a316 1
		printf(errstr);
@


1.41
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.40 2011/07/08 22:09:27 matthew Exp $	*/
d422 1
a422 1
	    "%s", sc->sc_dev.dv_xname)) {
@


1.40
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.39 2011/04/03 15:49:16 dlg Exp $	*/
d403 1
a407 1
	saa.saa_targets = TWE_MAX_UNITS;
@


1.39
log
@move twe over to iopools so we can get rid of another NO_CCB user. this
also cuts the aen drain over to using an iohandler so it can be made
reliable.

this compiles, but i havent got hardware to test with. its going in as a
way to force testing. if there's a problem with the code then let me know
or back it out.

"man up" k2k11
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.38 2010/09/20 06:17:49 krw Exp $	*/
a402 1
	sc->sc_link.adapter_buswidth = TWE_MAX_UNITS;
d407 1
@


1.38
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.37 2010/06/28 18:31:02 krw Exp $	*/
d73 2
a74 2
static __inline struct twe_ccb *twe_get_ccb(struct twe_softc *sc);
static __inline void twe_put_ccb(struct twe_ccb *ccb);
d83 1
d85 2
a86 4

static __inline struct twe_ccb *
twe_get_ccb(sc)
	struct twe_softc *sc;
d88 1
d91 1
d93 1
a93 1
	if (ccb)
d95 3
a97 1
	return ccb;
d100 2
a101 3
static __inline void
twe_put_ccb(ccb)
	struct twe_ccb *ccb;
d103 2
a104 1
	struct twe_softc *sc = ccb->ccb_sc;
d107 1
d109 1
d184 4
d250 2
a251 1
			if ((ccb = twe_get_ccb(sc)) == NULL) {
d253 1
a253 1
				continue;
d269 3
a271 1
			if (twe_cmd(ccb, BUS_DMA_NOWAIT, 1)) {
d275 1
d321 2
a322 1
	if ((ccb = twe_get_ccb(sc)) == NULL) {
d340 4
a343 1
	if (twe_cmd(ccb, BUS_DMA_NOWAIT, 1)) {
d356 2
a357 1
		if ((ccb = twe_get_ccb(sc)) == NULL) {
d375 1
d377 4
a380 2
		if (twe_cmd(ccb, BUS_DMA_NOWAIT, 1)) {
			TWE_UNLOCK(sc, lock);
a384 1
		TWE_UNLOCK(sc, lock);
d404 1
a516 1
			twe_put_ccb(ccb);
a524 1
			twe_put_ccb(ccb);
a549 1
			twe_put_ccb(ccb);
a599 1
		twe_put_ccb(ccb);
a747 1
	twe_put_ccb(ccb);
d790 1
a790 1
	struct twe_ccb *ccb;
a911 7
		if ((ccb = twe_get_ccb(sc)) == NULL) {
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			TWE_UNLOCK(sc, lock);
			return;
		}

a951 1
	struct twe_cmd	*cmd;
a952 1
	twe_lock_t	lock;
a1002 2
		u_int16_t aen;

d1012 29
a1040 5
		lock = TWE_LOCK(sc);
		for (aen = -1; aen != TWE_AEN_QEMPTY; ) {
			u_int8_t param_buf[2 * TWE_SECTOR_SIZE + TWE_ALIGN - 1];
			struct twe_param *pb = (void *) (((u_long)param_buf +
			    TWE_ALIGN - 1) & ~(TWE_ALIGN - 1));
d1042 3
a1044 2
			if ((ccb = twe_get_ccb(sc)) == NULL)
				break;
d1046 4
a1049 9
			ccb->ccb_xs = NULL;
			ccb->ccb_data = pb;
			ccb->ccb_length = TWE_SECTOR_SIZE;
			ccb->ccb_state = TWE_CCB_READY;
			cmd = ccb->ccb_cmd;
			cmd->cmd_unit_host = TWE_UNITHOST(0, 0);
			cmd->cmd_op = TWE_CMD_GPARAM;
			cmd->cmd_flags = 0;
			cmd->cmd_param.count = 1;
d1051 4
a1054 11
			pb->table_id = TWE_PARAM_AEN;
			pb->param_id = 2;
			pb->param_size = 2;
			if (twe_cmd(ccb, BUS_DMA_NOWAIT, 1)) {
				printf(": error draining attention queue\n");
				break;
			}
			aen = *(u_int16_t *)pb->data;
			TWE_DPRINTF(TWE_D_AEN, ("aen=%x ", aen));
		}
		TWE_UNLOCK(sc, lock);
d1057 3
a1059 1
	return rv;
@


1.37
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.36 2010/05/20 00:55:17 krw Exp $	*/
d811 1
a811 1
		sd.error_code = 0x70;
@


1.36
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.35 2010/03/29 23:33:39 krw Exp $	*/
a72 4
struct scsi_device twe_dev = {
	NULL, NULL, NULL, NULL
};

a381 1
	sc->sc_link.device = &twe_dev;
@


1.35
log
@Initialize various uninitialized variables. Found by jsg@@ via Clang.

Feedback from miod@@ and kettenis@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.34 2010/03/23 01:57:20 krw Exp $	*/
a794 1
		lock = TWE_LOCK(sc);
a795 1
		TWE_UNLOCK(sc, lock);
a851 1
		lock = TWE_LOCK(sc);
a852 1
		TWE_UNLOCK(sc, lock);
a938 1
	lock = TWE_LOCK(sc);
a939 1
	TWE_UNLOCK(sc, lock);
@


1.34
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.33 2010/01/09 23:15:06 krw Exp $	*/
d867 3
a869 1
		if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
@


1.33
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.32 2009/11/22 14:14:10 krw Exp $	*/
d67 1
a67 1
int	twe_scsi_cmd(struct scsi_xfer *);
d773 1
a773 1
int
d798 1
a798 1
		return (COMPLETE);
d857 1
a857 1
		return (COMPLETE);
d891 1
a891 1
				return (COMPLETE);
d903 6
a908 2
		if ((ccb = twe_get_ccb(sc)) == NULL)
			return (NO_CCB);
a929 2
			TWE_UNLOCK(sc, lock);
			return (COMPLETE);
d933 1
a933 5

		if (wait & SCSI_POLL)
			return (COMPLETE);
		else
			return (SUCCESSFULLY_QUEUED);
a943 2

	return (COMPLETE);
@


1.32
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.31 2009/09/03 10:58:38 dlg Exp $	*/
a739 1
		xs->flags |= ITSDONE;
@


1.31
log
@must call scsi_done before returning complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.30 2009/02/16 21:19:07 miod Exp $	*/
d638 1
a638 1
		return 1;
d904 2
a905 6
		if ((ccb = twe_get_ccb(sc)) == NULL) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			TWE_UNLOCK(sc, lock);
			return (COMPLETE);
		}
d925 4
a928 9
			if (xs->flags & SCSI_POLL) {
				TWE_UNLOCK(sc, lock);
				return (TRY_AGAIN_LATER);
			} else {
				xs->error = XS_DRIVER_STUFFUP;
				scsi_done(xs);
				TWE_UNLOCK(sc, lock);
				return (COMPLETE);
			}
@


1.30
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.29 2008/07/24 19:03:08 thib Exp $	*/
d796 3
d855 3
d952 4
@


1.29
log
@the softc sc_lock lockmgr lock is unused, so remove it.

ok krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.28 2007/10/20 16:10:09 krw Exp $	*/
d749 1
a749 2
tweminphys(bp)
	struct buf *bp;
@


1.28
log
@Call scsi_done() at SPLBIO. 'looks olright' says mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.27 2006/12/29 13:04:37 pedro Exp $	*/
a182 2

	lockinit(&sc->sc_lock, PWAIT, "twelk", 0, 0);
@


1.27
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.26 2006/11/28 23:59:45 dlg Exp $	*/
a924 1
			TWE_UNLOCK(sc, lock);
d927 1
d932 1
@


1.26
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.25 2005/12/03 16:53:16 krw Exp $	*/
d188 1
a188 1
	for (cmd = sc->sc_cmds + sizeof(struct twe_cmd) * (TWE_MAXCMDS - 1);
@


1.25
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.24 2005/09/15 05:33:39 krw Exp $	*/
d132 1
d392 4
a395 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
@


1.24
log
@Don't fake MODE SENSE page 4 info inside raid drivers, just let sd
fake a geometry. Page 4 info does not get used for size information.
Eliminate now unused union scsi_disk_pages.

ok marco@@ mickey@@ pre-lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.23 2005/07/03 22:31:27 krw Exp $	*/
a923 1
				xs->error = XS_TIMEOUT;
@


1.23
log
@Fix data_length values in simulationed MODE SENSE page 4 responses so
that scsi_do_mode_sense() accepts them.

The data_length value does not include itself, and the pg_length value
in a mode page does not include itself or the page_code fields. We
were +1 on the former and -2 on the latter resulting in a data_length
value that was too small by one.

Eliminates 'mode sense page 5 not simulated' messages.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.22 2003/08/06 21:08:06 millert Exp $	*/
d375 2
a376 11
		/* this is evil. they never learn */
		if (sc->sc_hdr[i].hd_size > 0x200000) {
			sc->sc_hdr[i].hd_secs = 63;
			sc->sc_hdr[i].hd_heads = 255;
		} else {
			sc->sc_hdr[i].hd_secs = 32;
			sc->sc_hdr[i].hd_heads = 64;
		}
		TWE_DPRINTF(TWE_D_MISC, ("twed%d: size=%d secs=%d heads=%d\n",
		    i, sc->sc_hdr[i].hd_size, sc->sc_hdr[i].hd_secs,
		    sc->sc_hdr[i].hd_heads));
a782 5
	struct {
		struct scsi_mode_header hd;
		struct scsi_blk_desc bd;
		union scsi_disk_pages dp;
	} mpd;
a840 37
	case MODE_SENSE:
		TWE_DPRINTF(TWE_D_CMD, ("MODE SENSE tgt %d ", target));

		bzero(&mpd, sizeof mpd);
		switch (((struct scsi_mode_sense *)xs->cmd)->page) {
		case 4:
			/* scsi_disk.h says this should be 0x16 */
			mpd.dp.rigid_geometry.pg_length = 0x16;
			mpd.hd.data_length = sizeof mpd.hd -
			    sizeof mpd.hd.data_length + sizeof mpd.bd +
			    sizeof mpd.dp.rigid_geometry;
			mpd.hd.blk_desc_len = sizeof mpd.bd;

			/* XXX */
			mpd.hd.dev_spec =
			    (sc->sc_hdr[target].hd_devtype & 2) ? 0x80 : 0;
			_lto3b(TWE_SECTOR_SIZE, mpd.bd.blklen);
			mpd.dp.rigid_geometry.pg_code = 4;
			_lto3b(sc->sc_hdr[target].hd_size /
			    sc->sc_hdr[target].hd_heads /
			    sc->sc_hdr[target].hd_secs,
			    mpd.dp.rigid_geometry.ncyl);
			mpd.dp.rigid_geometry.nheads =
			    sc->sc_hdr[target].hd_heads;
			twe_copy_internal_data(xs, (u_int8_t *)&mpd,
			    sizeof mpd);
			break;

		default:
			printf("%s: mode sense page %d not simulated\n",
			    sc->sc_dev.dv_xname,
			    ((struct scsi_mode_sense *)xs->cmd)->page);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
		break;

d941 2
a942 1
		TWE_DPRINTF(TWE_D_CMD, ("unknown opc %d ", xs->cmd->opcode));
@


1.22
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.21 2003/06/02 19:24:22 mickey Exp $	*/
d863 3
a865 2
			mpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +
			    mpd.dp.rigid_geometry.pg_length;
@


1.21
log
@kill the caluses three and four on some of my code
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.20 2003/04/27 11:22:52 ho Exp $	*/
d186 1
a186 1
	    sizeof(struct twe_cmd) * (TWE_MAXCMDS - 1);;
@


1.20
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.19 2003/04/09 20:44:57 mickey Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.19
log
@missing nl in the error msg and a return afterwards
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.18 2002/09/17 13:45:38 mickey Exp $	*/
d853 4
a856 3
		strcpy(inq.vendor, "3WARE  ");
		sprintf(inq.product, "Host drive  #%02d", target);
		strcpy(inq.revision, "   ");
@


1.18
log
@deal w/ the dma in a special thread to follow the busdma semantics. this fixes panics on unaligned physio; w/ help and testing from daniel@@lucq.org
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.17 2002/03/14 01:26:55 millert Exp $	*/
d420 1
a420 1
		printf("%s: failed to create kernel thread, disabled",
d422 1
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.16 2002/01/31 23:15:35 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000, 2001 Michael Shalayeff.  All rights reserved.
d44 2
d88 1
a88 1
int  twe_done(struct twe_softc *sc, int idx);
d90 2
d186 3
d367 1
a367 1
		lock = TWE_LOCK_TWE(sc);
d369 1
a369 1
			TWE_UNLOCK_TWE(sc, lock);
d374 1
a374 1
		TWE_UNLOCK_TWE(sc, lock);
d407 17
d439 46
d486 4
a489 1
	return 0;
d622 1
a622 2
		bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
		    TWE_CTRL_ECMDI);
a658 1
	u_int32_t	status;
d662 2
a663 1
		status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
d668 1
d676 4
a679 2
			if (!twe_done(sc, TWE_READYID(ready)) &&
			    ccb->ccb_state == TWE_CCB_FREE) {
d694 1
a694 1
twe_done(sc, idx)
d696 1
a696 1
	int	idx;
a697 1
	struct twe_ccb *ccb = &sc->sc_ccbs[idx];
d703 1
a703 1
	TWE_DPRINTF(TWE_D_CMD, ("done(%d) ", idx));
d705 3
a707 3
	if (ccb->ccb_state != TWE_CCB_QUEUED) {
		printf("%s: unqueued ccb %d ready\n",
		    sc->sc_dev.dv_xname, idx);
d746 1
a746 2
	lock = TWE_LOCK_TWE(sc);
	TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
d754 1
a754 1
	TWE_UNLOCK_TWE(sc, lock);
d758 1
d806 1
a806 1
	int error, op, flags;
d911 1
a911 1
		lock = TWE_LOCK_TWE(sc);
d937 1
a937 1
				TWE_UNLOCK_TWE(sc, lock);
d953 1
a953 1
			TWE_UNLOCK_TWE(sc, lock);
d967 3
d972 1
a972 1
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK), xs->flags & SCSI_POLL))) {
d974 1
a974 1
			TWE_UNLOCK_TWE(sc, lock);
d986 1
a986 1
		TWE_UNLOCK_TWE(sc, lock);
d988 1
a988 1
		if (xs->flags & SCSI_POLL)
a1022 28
	if (status & TWE_STAT_CMDI) {

		lock = TWE_LOCK_TWE(sc);
		while (!(status & TWE_STAT_CQF) &&
		    !TAILQ_EMPTY(&sc->sc_ccb2q)) {

			ccb = TAILQ_LAST(&sc->sc_ccb2q, twe_queue_head);
			TAILQ_REMOVE(&sc->sc_ccb2q, ccb, ccb_link);

			ccb->ccb_state = TWE_CCB_QUEUED;
			TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);
			bus_space_write_4(sc->iot, sc->ioh, TWE_COMMANDQUEUE,
			    ccb->ccb_cmdpa);

			rv++;

			status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
			TWE_DPRINTF(TWE_D_INTR, ("twe_intr stat=%b ",
			    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
		}

		if (TAILQ_EMPTY(&sc->sc_ccb2q))
			bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
			    TWE_CTRL_MCMDI);

		TWE_UNLOCK_TWE(sc, lock);
	}

d1038 5
a1042 2
			if (!twe_done(sc, TWE_READYID(ready)))
				rv++;
d1050 9
d1071 1
a1071 1
		lock = TWE_LOCK_TWE(sc);
d1100 1
a1100 1
		TWE_UNLOCK_TWE(sc, lock);
@


1.16
log
@scsi_done() is unsafe, rearrange locking to compensate
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.15 2001/12/06 09:30:31 mickey Exp $	*/
d70 1
a70 1
int	twe_scsi_cmd __P((struct scsi_xfer *));
d80 8
a87 8
static __inline struct twe_ccb *twe_get_ccb __P((struct twe_softc *sc));
static __inline void twe_put_ccb __P((struct twe_ccb *ccb));
void twe_dispose __P((struct twe_softc *sc));
int  twe_cmd __P((struct twe_ccb *ccb, int flags, int wait));
int  twe_start __P((struct twe_ccb *ccb, int wait));
int  twe_complete __P((struct twe_ccb *ccb));
int  twe_done __P((struct twe_softc *sc, int idx));
void twe_copy_internal_data __P((struct scsi_xfer *xs, void *v, size_t size));
@


1.15
log
@clear all inrterrupts separately and before enabling any.
this prevents stray interrupts and sometimes hangs,
caused by looping on stray unmapped interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.14 2001/11/05 17:25:58 art Exp $	*/
a674 1
	TWE_UNLOCK_TWE(sc, lock);
d681 1
a857 1
				TWE_UNLOCK_TWE(sc, lock);
d863 1
a876 1
			TWE_UNLOCK_TWE(sc, lock);
d879 1
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.15 2001/12/06 09:30:31 mickey Exp $	*/
d70 1
a70 1
int	twe_scsi_cmd(struct scsi_xfer *);
d80 8
a87 8
static __inline struct twe_ccb *twe_get_ccb(struct twe_softc *sc);
static __inline void twe_put_ccb(struct twe_ccb *ccb);
void twe_dispose(struct twe_softc *sc);
int  twe_cmd(struct twe_ccb *ccb, int flags, int wait);
int  twe_start(struct twe_ccb *ccb, int wait);
int  twe_complete(struct twe_ccb *ccb);
int  twe_done(struct twe_softc *sc, int idx);
void twe_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size);
d675 1
a681 1
	TWE_UNLOCK_TWE(sc, lock);
d858 1
a863 1
				TWE_UNLOCK_TWE(sc, lock);
d877 1
a879 1
			TWE_UNLOCK_TWE(sc, lock);
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.15.2.1 2002/06/11 03:42:20 art Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2002 Michael Shalayeff.  All rights reserved.
a43 2
#include <sys/proc.h>
#include <sys/kthread.h>
d86 1
a86 1
int  twe_done(struct twe_softc *sc, struct twe_ccb *ccb);
a87 2
void twe_thread_create(void *v);
void twe_thread(void *v);
a181 3
	TAILQ_INIT(&sc->sc_done_ccb);

	lockinit(&sc->sc_lock, PWAIT, "twelk", 0, 0);
d360 1
a360 1
		lock = TWE_LOCK(sc);
d362 1
a362 1
			TWE_UNLOCK(sc, lock);
d367 1
a367 1
		TWE_UNLOCK(sc, lock);
a399 17
	kthread_create_deferred(twe_thread_create, sc);

	return (0);
}

void
twe_thread_create(void *v)
{
	struct twe_softc *sc = v;

	if (kthread_create(twe_thread, sc, &sc->sc_thread,
	    "%s", sc->sc_dev.dv_xname)) {
		/* TODO disable twe */
		printf("%s: failed to create kernel thread, disabled",
		    sc->sc_dev.dv_xname);
	}

a414 1
}
d416 1
a416 49
void
twe_thread(v)
	void *v;
{
	struct twe_softc *sc = v;
	struct twe_ccb *ccb;
	twe_lock_t lock;
	u_int32_t status;
	int err;

	splbio();
	for (;;) {
		lock = TWE_LOCK(sc);

		while (!TAILQ_EMPTY(&sc->sc_done_ccb)) {
			ccb = TAILQ_FIRST(&sc->sc_done_ccb);
			TAILQ_REMOVE(&sc->sc_done_ccb, ccb, ccb_link);
			if ((err = twe_done(sc, ccb)))
				printf("%s: done failed (%d)\n",
				    sc->sc_dev.dv_xname, err);
		}

		status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
		TWE_DPRINTF(TWE_D_INTR, ("twe_thread stat=%b ",
		    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
		while (!(status & TWE_STAT_CQF) &&
		    !TAILQ_EMPTY(&sc->sc_ccb2q)) {

			ccb = TAILQ_LAST(&sc->sc_ccb2q, twe_queue_head);
			TAILQ_REMOVE(&sc->sc_ccb2q, ccb, ccb_link);

			ccb->ccb_state = TWE_CCB_QUEUED;
			TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);
			bus_space_write_4(sc->iot, sc->ioh, TWE_COMMANDQUEUE,
			    ccb->ccb_cmdpa);

			status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
			TWE_DPRINTF(TWE_D_INTR, ("twe_thread stat=%b ",
			    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
		}

		if (!TAILQ_EMPTY(&sc->sc_ccb2q))
			bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
			    TWE_CTRL_ECMDI);

		TWE_UNLOCK(sc, lock);
		sc->sc_thread_on = 1;
		tsleep(sc, PWAIT, "twespank", 0);
	}
d549 2
a550 1
		wakeup(sc);
d587 1
d591 1
a591 2
		u_int32_t status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);

a595 1
			struct twe_ccb *ccb1;
d603 2
a604 4
			ccb1 = &sc->sc_ccbs[TWE_READYID(ready)];
			TAILQ_REMOVE(&sc->sc_ccbq, ccb1, ccb_link);
			ccb1->ccb_state = TWE_CCB_DONE;
			if (!twe_done(sc, ccb1) && ccb1 == ccb) {
d619 1
a619 1
twe_done(sc, ccb)
d621 1
a621 1
	struct twe_ccb *ccb;
d623 1
d629 1
a629 1
	TWE_DPRINTF(TWE_D_CMD, ("done(%d) ", cmd->cmd_index));
d631 3
a633 3
	if (ccb->ccb_state != TWE_CCB_DONE) {
		printf("%s: undone ccb %d ready\n",
		     sc->sc_dev.dv_xname, cmd->cmd_index);
d672 2
a673 1
	lock = TWE_LOCK(sc);
d681 1
a681 1
	TWE_UNLOCK(sc, lock);
a684 1

d732 1
a732 1
	int error, op, flags, wait;
d837 1
a837 1
		lock = TWE_LOCK(sc);
d863 1
a863 1
				TWE_UNLOCK(sc, lock);
d879 1
a879 1
			TWE_UNLOCK(sc, lock);
a892 3
		wait = xs->flags & SCSI_POLL;
		if (!sc->sc_thread_on)
			wait |= SCSI_POLL;
d895 1
a895 1
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK), wait))) {
d897 1
a897 1
			TWE_UNLOCK(sc, lock);
d909 1
a909 1
		TWE_UNLOCK(sc, lock);
d911 1
a911 1
		if (wait & SCSI_POLL)
d946 28
d989 2
a990 5
			ccb = &sc->sc_ccbs[TWE_READYID(ready)];
			TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
			ccb->ccb_state = TWE_CCB_DONE;
			TAILQ_INSERT_TAIL(&sc->sc_done_ccb, ccb, ccb_link);
			rv++;
a997 9
	if (status & TWE_STAT_CMDI) {
		rv++;
		bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
		    TWE_CTRL_MCMDI);
	}

	if (rv)
		wakeup(sc);

d1010 1
a1010 1
		lock = TWE_LOCK(sc);
d1039 1
a1039 1
		TWE_UNLOCK(sc, lock);
@


1.15.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d420 1
a420 1
		printf("%s: failed to create kernel thread, disabled\n",
a421 1
		return;
d852 3
a854 4
		strlcpy(inq.vendor, "3WARE  ", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Host drive  #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
@


1.14
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.13 2001/09/24 06:52:33 mickey Exp $	*/
d400 11
d412 3
a414 2
	bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL, TWE_CTRL_EINT |
	    /*TWE_CTRL_HOSTI |*/ TWE_CTRL_CATTNI | TWE_CTRL_ERDYI);
@


1.13
log
@get rid of kvtop, not that it matters that much
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.12 2001/07/04 22:53:24 espie Exp $	*/
d499 2
a500 1
		bus_dmamap_sync(sc->dmat, dmap, BUS_DMASYNC_PREWRITE);
d502 2
a503 1
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, BUS_DMASYNC_PREWRITE);
d629 2
a630 2
			bus_dmamap_sync(sc->dmat, dmap,
			    (xs->flags & SCSI_DATA_IN) ?
d638 2
a639 1
			bus_dmamap_sync(sc->dmat, dmap, BUS_DMASYNC_POSTREAD);
d644 2
a645 1
			bus_dmamap_sync(sc->dmat, dmap, BUS_DMASYNC_POSTWRITE);
@


1.12
log
@case labels without statements are not permitted by ANSI C... and gcc 3.0
warns about them.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.11 2001/05/18 17:09:09 mickey Exp $	*/
d61 1
a61 1
int twe_debug = 0xffff;
d144 1
d183 2
d186 1
a186 1
	     cmd >= (struct twe_cmd *)sc->sc_cmds; cmd--) {
d200 1
a201 1
		ccb->ccb_cmdpa = kvtop((caddr_t)cmd);
@


1.11
log
@stupidous debug was left enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.10 2001/05/10 20:07:35 mickey Exp $	*/
d643 1
@


1.10
log
@dmamem_unmap the memory before dmamem_freeig it.
only affects unaligned transfers (such as disklabel, fsck and dump).
we used to get away w/ this due to older pmap, uvm or both.
be more precise w/ double-buffer on command failure as well.
once at it, allow more than 1 segment for double-buffer to be allocated.
also fix a couple of endianesses and command timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.9 2001/03/14 02:21:32 mickey Exp $	*/
d36 1
a36 1
#define	TWE_DEBUG
@


1.10.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff.  All rights reserved.
d36 1
a36 1
#undef	TWE_DEBUG
d117 1
a117 5
	/* TODO: traverse the ccbs and destroy the maps */
	for (ccb = &sc->sc_ccbs[TWE_MAXCMDS - 1]; ccb >= sc->sc_ccbs; ccb--)
		if (ccb->ccb_dmamap)
			bus_dmamap_destroy(sc->dmat, ccb->ccb_dmamap);
	if (sc->sc_cmdmap != NULL)
d119 8
a126 1
	bus_dmamem_free(sc->dmat, &sc->sc_cmdseg, 1);
d143 1
d146 1
a146 1
	    PAGE_SIZE, 0, &sc->sc_cmdseg, 1, &nseg, BUS_DMA_NOWAIT);
d152 1
a152 1
	error = bus_dmamem_map(sc->dmat, &sc->sc_cmdseg, nseg,
d157 1
d357 1
d359 1
d364 1
d413 1
a413 1
	int error, i, nseg;
d419 3
a421 2
		error = bus_dmamem_alloc(sc->dmat, ccb->ccb_length,
		    PAGE_SIZE, 0, &ccb->ccb_2bseg, 1, &nseg, BUS_DMA_NOWAIT);
d423 1
a423 1
			TWE_DPRINTF(TWE_D_DMA, ("2buf alloc failed "));
d428 1
a428 1
		error = bus_dmamem_map(sc->dmat, &ccb->ccb_2bseg, nseg,
d431 2
a432 1
			TWE_DPRINTF(TWE_D_DMA, ("2buf alloc failed "));
d453 6
d502 6
d509 1
a509 1
		return error;
d569 1
d573 1
a573 1
	for (i = 100000; i--; DELAY(10)) {
d609 1
d620 1
d624 1
a624 1
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
d626 2
a627 3
			    BUS_DMASYNC_POSTREAD :
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
d630 1
a630 1
		switch (cmd->cmd_op) {
d633 2
a634 3
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
d638 2
a639 3
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
d648 2
a649 3
		bus_dmamem_free(sc->dmat, &ccb->ccb_2bseg, 1);
		ccb->ccb_data = ccb->ccb_realdata;
		ccb->ccb_realdata = NULL;
d872 1
a872 1
		cmd->cmd_io.lba = blockno;
d982 1
a982 1
		 * we no attentions of interest right now.
d984 2
a985 1
		 * or, what else exist in there? maybe 3ware can answer that.
@


1.10.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.10.2.1 2001/05/14 22:24:18 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000, 2001 Michael Shalayeff.  All rights reserved.
d36 1
a36 1
/* #define	TWE_DEBUG */
d117 5
a121 1
	if (sc->sc_cmdmap != NULL) {
d123 1
a123 8
		/* traverse the ccbs and destroy the maps */
		for (ccb = &sc->sc_ccbs[TWE_MAXCMDS - 1]; ccb >= sc->sc_ccbs; ccb--)
			if (ccb->ccb_dmamap)
				bus_dmamap_destroy(sc->dmat, ccb->ccb_dmamap);
	}
	bus_dmamem_unmap(sc->dmat, sc->sc_cmds, 
	    sizeof(struct twe_cmd) * TWE_MAXCMDS);
	bus_dmamem_free(sc->dmat, sc->sc_cmdseg, 1);
a139 1
	twe_lock_t	lock;
d142 1
a142 1
	    PAGE_SIZE, 0, sc->sc_cmdseg, 1, &nseg, BUS_DMA_NOWAIT);
d148 1
a148 1
	error = bus_dmamem_map(sc->dmat, sc->sc_cmdseg, nseg,
a152 1
		bus_dmamem_free(sc->dmat, sc->sc_cmdseg, 1);
a351 1
		lock = TWE_LOCK_TWE(sc);
a352 1
			TWE_UNLOCK_TWE(sc, lock);
a356 1
		TWE_UNLOCK_TWE(sc, lock);
d405 1
a405 1
	int error, i;
d411 2
a412 3
		error = bus_dmamem_alloc(sc->dmat, ccb->ccb_length, PAGE_SIZE,
		    0, ccb->ccb_2bseg, TWE_MAXOFFSETS, &ccb->ccb_2nseg,
		    BUS_DMA_NOWAIT);
d414 1
a414 1
			TWE_DPRINTF(TWE_D_DMA, ("2buf alloc failed(%d) ", error));
d419 1
a419 1
		error = bus_dmamem_map(sc->dmat, ccb->ccb_2bseg, ccb->ccb_2nseg,
d422 1
a422 2
			TWE_DPRINTF(TWE_D_DMA, ("2buf map failed(%d) ", error));
			bus_dmamem_free(sc->dmat, ccb->ccb_2bseg, ccb->ccb_2nseg);
a442 6
			if (ccb->ccb_realdata) {
				bus_dmamem_unmap(sc->dmat, ccb->ccb_data,
				    ccb->ccb_length);
				bus_dmamem_free(sc->dmat, ccb->ccb_2bseg,
				    ccb->ccb_2nseg);
			}
a485 6
		if (ccb->ccb_realdata) {
			bus_dmamem_unmap(sc->dmat, ccb->ccb_data,
			    ccb->ccb_length);
			bus_dmamem_free(sc->dmat, ccb->ccb_2bseg,
			    ccb->ccb_2nseg);
		}
d487 1
a487 1
		return (error);
a546 1
	struct scsi_xfer *xs = ccb->ccb_xs;
d550 1
a550 1
	for (i = 100 * (xs? xs->timeout : 35000); i--; DELAY(10)) {
a585 1
	bus_dmamap_t	dmap;
a595 1
	dmap = ccb->ccb_dmamap;
d599 1
a599 1
			bus_dmamap_sync(sc->dmat, dmap,
d601 3
a603 2
			    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, dmap);
d606 1
a606 1
		switch (letoh16(cmd->cmd_op)) {
d609 3
a611 2
			bus_dmamap_sync(sc->dmat, dmap, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->dmat, dmap);
d615 3
a617 2
			bus_dmamap_sync(sc->dmat, dmap, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, dmap);
d626 3
a628 2
		bus_dmamem_unmap(sc->dmat, ccb->ccb_data, ccb->ccb_length);
		bus_dmamem_free(sc->dmat, ccb->ccb_2bseg, ccb->ccb_2nseg);
d851 1
a851 1
		cmd->cmd_io.lba = htole32(blockno);
d961 1
a961 1
		 * we know no attentions of interest right now.
d963 1
a963 2
		 * or, what else exists in there?
		 * maybe 3ware can answer that?
@


1.10.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.10.2.2 2001/07/04 10:41:13 niklas Exp $	*/
d61 1
a61 1
int twe_debug = 0;
a143 1
	paddr_t		pa;
a181 2
	pa = sc->sc_cmdmap->dm_segs[0].ds_addr +
	    sizeof(struct twe_cmd) * (TWE_MAXCMDS - 1);;
d183 1
a183 1
	     cmd >= (struct twe_cmd *)sc->sc_cmds; cmd--, pa -= sizeof(*cmd)) {
a196 1
		ccb->ccb_cmdpa = pa;
d198 1
a642 1
			break;
@


1.10.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d499 1
a499 2
		bus_dmamap_sync(sc->dmat, dmap, 0, dmap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);
d501 1
a501 2
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sc->sc_cmdmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
d627 2
a628 2
			bus_dmamap_sync(sc->dmat, dmap, 0,
			    dmap->dm_mapsize, (xs->flags & SCSI_DATA_IN) ?
d636 1
a636 2
			bus_dmamap_sync(sc->dmat, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
d641 1
a641 2
			bus_dmamap_sync(sc->dmat, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
@


1.10.2.5
log
@Merge in trunk
@
text
@a399 11
	TWE_DPRINTF(TWE_D_CMD, ("stat=%b ",
	    bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS), TWE_STAT_BITS));
	/*
	 * ack all before enable, cannot be done in one
	 * operation as it seems clear is not processed
	 * if enable is specified.
	 */
	bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
	    TWE_CTRL_CHOSTI | TWE_CTRL_CATTNI | TWE_CTRL_CERR);
	TWE_DPRINTF(TWE_D_CMD, ("stat=%b ",
	    bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS), TWE_STAT_BITS));
d401 2
a402 3
	bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
	    TWE_CTRL_EINT | TWE_CTRL_ERDYI |
	    /*TWE_CTRL_HOSTI |*/ TWE_CTRL_MCMDI);
d663 1
a669 1
	TWE_UNLOCK_TWE(sc, lock);
d846 1
a851 1
				TWE_UNLOCK_TWE(sc, lock);
d865 1
a867 1
			TWE_UNLOCK_TWE(sc, lock);
@


1.10.2.6
log
@Merge in -current from about a week ago
@
text
@d70 1
a70 1
int	twe_scsi_cmd(struct scsi_xfer *);
d80 8
a87 8
static __inline struct twe_ccb *twe_get_ccb(struct twe_softc *sc);
static __inline void twe_put_ccb(struct twe_ccb *ccb);
void twe_dispose(struct twe_softc *sc);
int  twe_cmd(struct twe_ccb *ccb, int flags, int wait);
int  twe_start(struct twe_ccb *ccb, int wait);
int  twe_complete(struct twe_ccb *ccb);
int  twe_done(struct twe_softc *sc, int idx);
void twe_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size);
@


1.10.2.7
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 Michael Shalayeff.  All rights reserved.
a43 2
#include <sys/proc.h>
#include <sys/kthread.h>
d86 1
a86 1
int  twe_done(struct twe_softc *sc, struct twe_ccb *ccb);
a87 2
void twe_thread_create(void *v);
void twe_thread(void *v);
a181 3
	TAILQ_INIT(&sc->sc_done_ccb);

	lockinit(&sc->sc_lock, PWAIT, "twelk", 0, 0);
d360 1
a360 1
		lock = TWE_LOCK(sc);
d362 1
a362 1
			TWE_UNLOCK(sc, lock);
d367 1
a367 1
		TWE_UNLOCK(sc, lock);
a399 17
	kthread_create_deferred(twe_thread_create, sc);

	return (0);
}

void
twe_thread_create(void *v)
{
	struct twe_softc *sc = v;

	if (kthread_create(twe_thread, sc, &sc->sc_thread,
	    "%s", sc->sc_dev.dv_xname)) {
		/* TODO disable twe */
		printf("%s: failed to create kernel thread, disabled",
		    sc->sc_dev.dv_xname);
	}

a414 1
}
d416 1
a416 49
void
twe_thread(v)
	void *v;
{
	struct twe_softc *sc = v;
	struct twe_ccb *ccb;
	twe_lock_t lock;
	u_int32_t status;
	int err;

	splbio();
	for (;;) {
		lock = TWE_LOCK(sc);

		while (!TAILQ_EMPTY(&sc->sc_done_ccb)) {
			ccb = TAILQ_FIRST(&sc->sc_done_ccb);
			TAILQ_REMOVE(&sc->sc_done_ccb, ccb, ccb_link);
			if ((err = twe_done(sc, ccb)))
				printf("%s: done failed (%d)\n",
				    sc->sc_dev.dv_xname, err);
		}

		status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
		TWE_DPRINTF(TWE_D_INTR, ("twe_thread stat=%b ",
		    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
		while (!(status & TWE_STAT_CQF) &&
		    !TAILQ_EMPTY(&sc->sc_ccb2q)) {

			ccb = TAILQ_LAST(&sc->sc_ccb2q, twe_queue_head);
			TAILQ_REMOVE(&sc->sc_ccb2q, ccb, ccb_link);

			ccb->ccb_state = TWE_CCB_QUEUED;
			TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);
			bus_space_write_4(sc->iot, sc->ioh, TWE_COMMANDQUEUE,
			    ccb->ccb_cmdpa);

			status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);
			TWE_DPRINTF(TWE_D_INTR, ("twe_thread stat=%b ",
			    status & TWE_STAT_FLAGS, TWE_STAT_BITS));
		}

		if (!TAILQ_EMPTY(&sc->sc_ccb2q))
			bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
			    TWE_CTRL_ECMDI);

		TWE_UNLOCK(sc, lock);
		sc->sc_thread_on = 1;
		tsleep(sc, PWAIT, "twespank", 0);
	}
d549 2
a550 1
		wakeup(sc);
d587 1
d591 1
a591 2
		u_int32_t status = bus_space_read_4(sc->iot, sc->ioh, TWE_STATUS);

a595 1
			struct twe_ccb *ccb1;
d603 2
a604 4
			ccb1 = &sc->sc_ccbs[TWE_READYID(ready)];
			TAILQ_REMOVE(&sc->sc_ccbq, ccb1, ccb_link);
			ccb1->ccb_state = TWE_CCB_DONE;
			if (!twe_done(sc, ccb1) && ccb1 == ccb) {
d619 1
a619 1
twe_done(sc, ccb)
d621 1
a621 1
	struct twe_ccb *ccb;
d623 1
d629 1
a629 1
	TWE_DPRINTF(TWE_D_CMD, ("done(%d) ", cmd->cmd_index));
d631 3
a633 3
	if (ccb->ccb_state != TWE_CCB_DONE) {
		printf("%s: undone ccb %d ready\n",
		     sc->sc_dev.dv_xname, cmd->cmd_index);
d672 2
a673 1
	lock = TWE_LOCK(sc);
d681 1
a681 1
	TWE_UNLOCK(sc, lock);
a684 1

d732 1
a732 1
	int error, op, flags, wait;
d837 1
a837 1
		lock = TWE_LOCK(sc);
d863 1
a863 1
				TWE_UNLOCK(sc, lock);
d879 1
a879 1
			TWE_UNLOCK(sc, lock);
a892 3
		wait = xs->flags & SCSI_POLL;
		if (!sc->sc_thread_on)
			wait |= SCSI_POLL;
d895 1
a895 1
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK), wait))) {
d897 1
a897 1
			TWE_UNLOCK(sc, lock);
d909 1
a909 1
		TWE_UNLOCK(sc, lock);
d911 1
a911 1
		if (wait & SCSI_POLL)
d946 28
d989 2
a990 5
			ccb = &sc->sc_ccbs[TWE_READYID(ready)];
			TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
			ccb->ccb_state = TWE_CCB_DONE;
			TAILQ_INSERT_TAIL(&sc->sc_done_ccb, ccb, ccb_link);
			rv++;
a997 9
	if (status & TWE_STAT_CMDI) {
		rv++;
		bus_space_write_4(sc->iot, sc->ioh, TWE_CONTROL,
		    TWE_CTRL_MCMDI);
	}

	if (rv)
		wakeup(sc);

d1010 1
a1010 1
		lock = TWE_LOCK(sc);
d1039 1
a1039 1
		TWE_UNLOCK(sc, lock);
@


1.10.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.10.2.7 2003/03/28 00:38:15 niklas Exp $	*/
d420 1
a420 1
		printf("%s: failed to create kernel thread, disabled\n",
a421 1
		return;
d852 3
a854 4
		strlcpy(inq.vendor, "3WARE  ", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Host drive  #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
@


1.10.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.10.2.8 2003/05/13 19:35:02 ho Exp $	*/
d17 5
@


1.10.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d186 1
a186 1
	    sizeof(struct twe_cmd) * (TWE_MAXCMDS - 1);
@


1.9
log
@it seems sometimes it takes up to 35 seconds to init; from Chris Kuethe ckuethe@@[[gecko.]math.]ualberta.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.8 2001/03/09 17:06:12 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff.  All rights reserved.
d36 1
a36 1
#undef	TWE_DEBUG
d117 1
a117 5
	/* TODO: traverse the ccbs and destroy the maps */
	for (ccb = &sc->sc_ccbs[TWE_MAXCMDS - 1]; ccb >= sc->sc_ccbs; ccb--)
		if (ccb->ccb_dmamap)
			bus_dmamap_destroy(sc->dmat, ccb->ccb_dmamap);
	if (sc->sc_cmdmap != NULL)
d119 8
a126 1
	bus_dmamem_free(sc->dmat, &sc->sc_cmdseg, 1);
d143 1
d146 1
a146 1
	    PAGE_SIZE, 0, &sc->sc_cmdseg, 1, &nseg, BUS_DMA_NOWAIT);
d152 1
a152 1
	error = bus_dmamem_map(sc->dmat, &sc->sc_cmdseg, nseg,
d157 1
d357 1
d359 1
d364 1
d413 1
a413 1
	int error, i, nseg;
d419 3
a421 2
		error = bus_dmamem_alloc(sc->dmat, ccb->ccb_length,
		    PAGE_SIZE, 0, &ccb->ccb_2bseg, 1, &nseg, BUS_DMA_NOWAIT);
d423 1
a423 1
			TWE_DPRINTF(TWE_D_DMA, ("2buf alloc failed "));
d428 1
a428 1
		error = bus_dmamem_map(sc->dmat, &ccb->ccb_2bseg, nseg,
d431 2
a432 1
			TWE_DPRINTF(TWE_D_DMA, ("2buf alloc failed "));
d453 6
d502 6
d509 1
a509 1
		return error;
d569 1
d573 1
a573 1
	for (i = 100000; i--; DELAY(10)) {
d609 1
d620 1
d624 1
a624 1
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
d626 2
a627 3
			    BUS_DMASYNC_POSTREAD :
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
d630 1
a630 1
		switch (cmd->cmd_op) {
d633 2
a634 3
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
d638 2
a639 3
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
d648 2
a649 3
		bus_dmamem_free(sc->dmat, &ccb->ccb_2bseg, 1);
		ccb->ccb_data = ccb->ccb_realdata;
		ccb->ccb_realdata = NULL;
d872 1
a872 1
		cmd->cmd_io.lba = blockno;
d982 1
a982 1
		 * we no attentions of interest right now.
d984 2
a985 1
		 * or, what else exist in there? maybe 3ware can answer that.
@


1.9.2.1
log
@Pull in patch from current:
Fix (mickey):
dmamem_unmap the memory before dmamem_freeig it.
only affects unaligned transfers (such as disklabel, fsck and dump).
we used to get away w/ this due to older pmap, uvm or both.
be more precise w/ double-buffer on command failure as well.
once at it, allow more than 1 segment for double-buffer to be allocated.
also fix a couple of endianesses and command timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.10 2001/05/10 20:07:35 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000, 2001 Michael Shalayeff.  All rights reserved.
d36 1
a36 1
#define	TWE_DEBUG
d117 5
a121 1
	if (sc->sc_cmdmap != NULL) {
d123 1
a123 8
		/* traverse the ccbs and destroy the maps */
		for (ccb = &sc->sc_ccbs[TWE_MAXCMDS - 1]; ccb >= sc->sc_ccbs; ccb--)
			if (ccb->ccb_dmamap)
				bus_dmamap_destroy(sc->dmat, ccb->ccb_dmamap);
	}
	bus_dmamem_unmap(sc->dmat, sc->sc_cmds, 
	    sizeof(struct twe_cmd) * TWE_MAXCMDS);
	bus_dmamem_free(sc->dmat, sc->sc_cmdseg, 1);
a139 1
	twe_lock_t	lock;
d142 1
a142 1
	    PAGE_SIZE, 0, sc->sc_cmdseg, 1, &nseg, BUS_DMA_NOWAIT);
d148 1
a148 1
	error = bus_dmamem_map(sc->dmat, sc->sc_cmdseg, nseg,
a152 1
		bus_dmamem_free(sc->dmat, sc->sc_cmdseg, 1);
a351 1
		lock = TWE_LOCK_TWE(sc);
a352 1
			TWE_UNLOCK_TWE(sc, lock);
a356 1
		TWE_UNLOCK_TWE(sc, lock);
d405 1
a405 1
	int error, i;
d411 2
a412 3
		error = bus_dmamem_alloc(sc->dmat, ccb->ccb_length, PAGE_SIZE,
		    0, ccb->ccb_2bseg, TWE_MAXOFFSETS, &ccb->ccb_2nseg,
		    BUS_DMA_NOWAIT);
d414 1
a414 1
			TWE_DPRINTF(TWE_D_DMA, ("2buf alloc failed(%d) ", error));
d419 1
a419 1
		error = bus_dmamem_map(sc->dmat, ccb->ccb_2bseg, ccb->ccb_2nseg,
d422 1
a422 2
			TWE_DPRINTF(TWE_D_DMA, ("2buf map failed(%d) ", error));
			bus_dmamem_free(sc->dmat, ccb->ccb_2bseg, ccb->ccb_2nseg);
a442 6
			if (ccb->ccb_realdata) {
				bus_dmamem_unmap(sc->dmat, ccb->ccb_data,
				    ccb->ccb_length);
				bus_dmamem_free(sc->dmat, ccb->ccb_2bseg,
				    ccb->ccb_2nseg);
			}
a485 6
		if (ccb->ccb_realdata) {
			bus_dmamem_unmap(sc->dmat, ccb->ccb_data,
			    ccb->ccb_length);
			bus_dmamem_free(sc->dmat, ccb->ccb_2bseg,
			    ccb->ccb_2nseg);
		}
d487 1
a487 1
		return (error);
a546 1
	struct scsi_xfer *xs = ccb->ccb_xs;
d550 1
a550 1
	for (i = 100 * (xs? xs->timeout : 35000); i--; DELAY(10)) {
a585 1
	bus_dmamap_t	dmap;
a595 1
	dmap = ccb->ccb_dmamap;
d599 1
a599 1
			bus_dmamap_sync(sc->dmat, dmap,
d601 3
a603 2
			    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, dmap);
d606 1
a606 1
		switch (letoh16(cmd->cmd_op)) {
d609 3
a611 2
			bus_dmamap_sync(sc->dmat, dmap, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->dmat, dmap);
d615 3
a617 2
			bus_dmamap_sync(sc->dmat, dmap, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, dmap);
d626 3
a628 2
		bus_dmamem_unmap(sc->dmat, ccb->ccb_data, ccb->ccb_length);
		bus_dmamem_free(sc->dmat, ccb->ccb_2bseg, ccb->ccb_2nseg);
d851 1
a851 1
		cmd->cmd_io.lba = htole32(blockno);
d961 1
a961 1
		 * we know no attentions of interest right now.
d963 1
a963 2
		 * or, what else exists in there?
		 * maybe 3ware can answer that?
@


1.9.2.2
log
@Pull in patch from current:
Fix (mickey):
stupidous debug was left enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.9.2.1 2001/05/11 04:49:50 jason Exp $	*/
d36 1
a36 1
/* #define	TWE_DEBUG */
@


1.8
log
@missing twe_unlock for failed get_ccb() for i/o scsi cmd, which was impossible to trigger in twese case because of how maxcmds is calculated
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.7 2001/02/19 20:47:02 mickey Exp $	*/
d204 1
a204 1
		for (i = 60000; i--; DELAY(100)) {
d222 1
a222 1
		for (i = 45000; i--; DELAY(100)) {
@


1.7
log
@propoer dmaable memory allocations
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.6 2001/01/07 20:27:46 mickey Exp $	*/
d836 1
@


1.6
log
@fix a few scsi_done() usages.
simplify locking a bit.
disable write cache if said so in the scsi_xfer.
a few more commands, from freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.5 2000/11/08 20:44:56 mickey Exp $	*/
a46 4
#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <uvm/uvm_extern.h>

a116 2
	if (sc->sc_cmdmap != NULL)
		bus_dmamap_destroy(sc->dmat, sc->sc_cmdmap);
d121 3
a123 2
	uvm_km_free(kmem_map, (vaddr_t)sc->sc_cmds,
	    sizeof(struct twe_cmd) * TWE_MAXCMDS);
d138 1
a138 1
	int		error, i, retry, nunits;
d141 12
a152 7
	TAILQ_INIT(&sc->sc_ccb2q);
	TAILQ_INIT(&sc->sc_ccbq);
	TAILQ_INIT(&sc->sc_free_ccb);
	sc->sc_cmds = (void *)uvm_km_kmemalloc(kmem_map, uvmexp.kmem_object,
	    sizeof(struct twe_cmd) * TWE_MAXCMDS, UVM_KMF_NOWAIT);
	if (sc->sc_cmds == NULL) {
		printf(": cannot allocate commands\n");
d155 1
d172 5
d405 1
a405 1
	int error, i;
d410 12
a421 3
		ccb->ccb_data = (void *)uvm_km_kmemalloc(kmem_map,
		    uvmexp.kmem_object, ccb->ccb_length, UVM_KMF_NOWAIT);
		if (!ccb->ccb_data) {
d626 1
a626 1
		uvm_km_free(kmem_map, (vaddr_t)ccb->ccb_data, ccb->ccb_length);
d869 1
a869 2
		if (xs->flags & SCSI_POLL) {
			scsi_done(xs);
d871 2
a872 2
		}
		return (SUCCESSFULLY_QUEUED);
@


1.5
log
@oops, oops w/ no configured units
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.4 2000/11/07 20:15:53 mickey Exp $	*/
a88 1
void twe_exec_cmd __P((void *v));
d242 1
a242 1
			cmd->cmd_count = 1;
d310 1
a310 1
	cmd->cmd_count = 1;
d341 1
a341 1
		cmd->cmd_count = 1;
a488 1
	cmd->cmd_count = htole16(cmd->cmd_count);
a567 1
	struct scsi_xfer *xs;
d570 2
a574 2
	xs = ccb->ccb_xs;

d616 1
d619 1
d649 1
a649 1
		printf("uio move not yet supported\n");
d676 1
a676 1
	int error, op;
d783 1
d795 4
d806 1
a807 1
				xs->error = XS_DRIVER_STUFFUP;
d821 1
a822 1
			xs->error = XS_DRIVER_STUFFUP;
d833 2
a834 1
		cmd->cmd_count = blockcnt;
d846 1
a847 1
				xs->error = XS_DRIVER_STUFFUP;
a919 1
		lock = TWE_LOCK_TWE(sc);
a939 1
		TWE_UNLOCK_TWE(sc, lock);
d969 2
a970 1
			cmd->cmd_count = 1;
@


1.4
log
@estimate sc_link.openings on the number of configured units
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.3 2000/09/25 23:50:20 mickey Exp $	*/
d369 3
@


1.3
log
@do not do queue locking in get/put_ccb, since calling blocks
have gotten it already locked appropriately.
only try to satiate the command queue if there was a command interrupt,
it seems it's quite well-behaving this way.
dispose allocated resources if twe_attach() fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.2 2000/09/15 17:00:24 mickey Exp $	*/
d144 1
a144 1
	int		error, i, retry;
a191 7
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &twe_switch;
	sc->sc_link.adapter_target = TWE_MAX_UNITS;
	sc->sc_link.device = &twe_dev;
	sc->sc_link.openings = TWE_MAXCMDS;	/* XXX or less? */
	sc->sc_link.adapter_buswidth = TWE_MAX_UNITS;

d325 1
a325 1
	for (i = 0; i < TWE_MAX_UNITS; i++) {
d353 1
d371 7
@


1.2
log
@forgot to turn off debugging
@
text
@d1 1
a1 1
/*	$OpenBSD: twe.c,v 1.1 2000/09/15 16:56:13 mickey Exp $	*/
a69 2
int	twe_scsi_cmd __P((struct scsi_xfer *));

d74 2
d86 1
a99 1
	twe_lock_t lock;
a100 1
	lock = TWE_LOCK_TWE(sc);
a103 1
	TWE_UNLOCK_TWE(sc, lock);
a111 1
	twe_lock_t lock;
a112 1
	lock = TWE_LOCK_TWE(sc);
d115 15
a129 1
	TWE_UNLOCK_TWE(sc, lock);
d144 1
a144 2
	u_int16_t	aen;
	int		error, i, retry, veseen_srst, size;
a149 1
	size = round_page(sizeof(struct twe_cmd) * TWE_MAXCMDS);
d151 1
a151 1
	    size, UVM_KMF_NOWAIT);
d162 1
d169 1
d182 1
d200 3
d301 1
d307 1
d325 1
d338 1
d881 1
a881 1
	if (status & (TWE_STAT_CMDI | TWE_STAT_CQF)) {
a891 1

d946 1
d974 1
a978 1

@


1.1
log
@3ware escalade ide raid controllers
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 1
#define	TWE_DEBUG
@

