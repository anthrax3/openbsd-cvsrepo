head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.22
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.20
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.14
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.16
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.8
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.12
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.10
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.6
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.4
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.36
	OPENBSD_5_0:1.17.0.32
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.30
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.28
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.24
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.26
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.22
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.20
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.18
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.16
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.14
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.12
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.10
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.13
	UBC:1.7.0.12
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.18
date	2012.03.24.20.19.05;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.25.06.43.34;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.15.23.41.47;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.12.10.27.10;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.08.21.34.39;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.30.19.36.58;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.28.01.27.59;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.28.00.40.53;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2002.06.28.00.34.54;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.04.36.33;	author smurph;	state dead;
branches;
next	1.7;

1.7
date	2000.01.31.01.50.54;	author weingart;	state Exp;
branches
	1.7.2.1
	1.7.12.1;
next	1.6;

1.6
date	96.11.28.23.27.53;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.12.20.30.23;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.10.31.01.01.40;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.21.22.27.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.27.21.15.50;	author shawn;	state Exp;
branches;
next	1.1;

1.1
date	96.05.26.00.27.06;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2002.03.06.02.11.43;	author niklas;	state dead;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.03.28.11.58.09;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	;

1.7.12.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Left-pad the eeprom dump with zeroes in the debug dump to make it easier to
read (this code is not compiled unless option AHC_DUMP_EEPROM anyway)
@
text
@/*	$OpenBSD: smc93cx6.c,v 1.17 2003/09/25 06:43:34 fgsch Exp $	*/
/*	$NetBSD: smc93cx6.c,v 1.10 2003/05/02 19:12:19 dyoung Exp $	*/

/*
 * Interface for the 93C66/56/46/26/06 serial eeprom parts.
 *
 * Copyright (c) 1995, 1996 Daniel M. Eischen
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Absolutely no warranty of function or purpose is made by the author
 *    Daniel M. Eischen.
 * 4. Modifications may be freely made to this file if the above conditions
 *    are met.
 *
 * $FreeBSD: src/sys/dev/aic7xxx/93cx6.c,v 1.5 2000/01/07 23:08:17 gibbs Exp $
 */

/*
 *   The instruction set of the 93C66/56/46/26/06 chips are as follows:
 *
 *               Start  OP	    *
 *     Function   Bit  Code  Address**  Data     Description
 *     -------------------------------------------------------------------
 *     READ        1    10   A5 - A0             Reads data stored in memory,
 *                                               starting at specified address
 *     EWEN        1    00   11XXXX              Write enable must precede
 *                                               all programming modes
 *     ERASE       1    11   A5 - A0             Erase register A5A4A3A2A1A0
 *     WRITE       1    01   A5 - A0   D15 - D0  Writes register
 *     ERAL        1    00   10XXXX              Erase all registers
 *     WRAL        1    00   01XXXX    D15 - D0  Writes to all registers
 *     EWDS        1    00   00XXXX              Disables all programming
 *                                               instructions
 *     *Note: A value of X for address is a don't care condition.
 *    **Note: There are 8 address bits for the 93C56/66 chips unlike
 *	      the 93C46/26/06 chips which have 6 address bits.
 *
 *   The 93C46 has a four wire interface: clock, chip select, data in, and
 *   data out.  In order to perform one of the above functions, you need
 *   to enable the chip select for a clock period (typically a minimum of
 *   1 usec, with the clock high and low a minimum of 750 and 250 nsec
 *   respectively).  While the chip select remains high, you can clock in
 *   the instructions (above) starting with the start bit, followed by the
 *   OP code, Address, and Data (if needed).  For the READ instruction, the
 *   requested 16-bit register contents is read from the data out line but
 *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB
 *   first).  The clock cycling from low to high initiates the next data
 *   bit to be sent from the chip.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <machine/bus.h>
#include <dev/ic/smc93cx6var.h>

/*
 * Right now, we only have to read the SEEPROM.  But we make it easier to
 * add other 93Cx6 functions.
 */
static struct seeprom_cmd {
  	unsigned char len;
 	unsigned char bits[3];
} seeprom_read = {3, {1, 1, 0}};

#define CLOCK_PULSE(sd, rdy)	do {					\
	/*								\
	 * Wait for the SEERDY to go high; about 800 ns.		\
	 */								\
	int cpi = 1000;							\
	if (rdy == 0) {							\
		DELAY(4); /* more than long enough */			\
		break;							\
	}								\
	while ((SEEPROM_STATUS_INB(sd) & rdy) == 0 && cpi-- > 0) {	\
		;  /* Do nothing */					\
	}								\
	(void)SEEPROM_INB(sd);	/* Clear clock */			\
} while (0)

/*
 * Read the serial EEPROM and returns 1 if successful and 0 if
 * not successful.
 */
int
read_seeprom(sd, buf, start_addr, count)
	struct seeprom_descriptor *sd;
	u_int16_t *buf;
	bus_size_t start_addr;
	bus_size_t count;
{
	int i = 0;
	u_int k = 0;
	u_int16_t v;
	u_int32_t temp;

	/*
	 * Read the requested registers of the seeprom.  The loop
	 * will range from 0 to count-1.
	 */
	for (k = start_addr; k < count + start_addr; k++) {
		/* Send chip select for one clock cycle. */
		temp = sd->sd_MS ^ sd->sd_CS;
		SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
		CLOCK_PULSE(sd, sd->sd_RDY);

		/*
		 * Now we're ready to send the read command followed by the
		 * address of the 16-bit register we want to read.
		 */
		for (i = 0; i < seeprom_read.len; i++) {
			if (seeprom_read.bits[i] != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if (seeprom_read.bits[i] != 0)
				temp ^= sd->sd_DO;
		}
		/* Send the 6 or 8 bit address (MSB first, LSB last). */
		for (i = (sd->sd_chip - 1); i >= 0; i--) {
			if ((k & (1 << i)) != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if ((k & (1 << i)) != 0)
				temp ^= sd->sd_DO;
		}

		/*
		 * Now read the 16 bit register.  An initial 0 precedes the
		 * register contents which begins with bit 15 (MSB) and ends
		 * with bit 0 (LSB).  The initial 0 will be shifted off the
		 * top of our word as we let the loop run from 0 to 16.
		 */
		v = 0;
		for (i = 16; i >= 0; i--) {
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			v <<= 1;
			if (SEEPROM_DATA_INB(sd) & sd->sd_DI)
				v |= 1;
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
		}

		buf[k - start_addr] = v;

		/* Reset the chip select for the next command cycle. */
		temp = sd->sd_MS;
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
		SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
		CLOCK_PULSE(sd, sd->sd_RDY);
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
	}
#ifdef AHC_DUMP_EEPROM
	printf("\nSerial EEPROM:\n\t");
	for (k = 0; k < count; k = k + 1) {
		if (((k % 8) == 0) && (k != 0)) {
			printf ("\n\t");
		}
		printf (" 0x%04x", buf[k]);
	}
	printf ("\n");
#endif
	return (1);
}
@


1.17
log
@sync with netbsd; fixes some problems with the upcoming atw driver.
krw@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d176 1
a176 1
		printf (" 0x%x", buf[k]);
@


1.16
log
@cleanup.
@
text
@d1 3
a3 2
/*	$OpenBSD: smc93cx6.c,v 1.15 2003/08/12 10:27:10 fgsch Exp $	*/
/* $FreeBSD: sys/dev/aic7xxx/93cx6.c,v 1.5 2000/01/07 23:08:17 gibbs Exp $ */
d23 2
d72 1
a72 1
 	unsigned char bits[9];
d75 14
a88 51
/*
 * Wait for the SEERDY to go high; about 800 ns.
 */
#define CLOCK_PULSE(sd, rdy)				\
	while ((SEEPROM_STATUS_INB(sd) & rdy) == 0) {	\
		;  /* Do nothing */			\
	}						\
	(void)SEEPROM_INB(sd);	/* Clear clock */

/*
 * Send a START condition and the given command
 */
static void
send_seeprom_cmd(struct seeprom_descriptor *sd, struct seeprom_cmd *cmd)
{
	u_int8_t temp;
	int i = 0;

	/* Send chip select for one clock cycle. */
	temp = sd->sd_MS ^ sd->sd_CS;
	SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
	CLOCK_PULSE(sd, sd->sd_RDY);

	for (i = 0; i < cmd->len; i++) {
		if (cmd->bits[i] != 0)
			temp ^= sd->sd_DO;
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
		SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
		CLOCK_PULSE(sd, sd->sd_RDY);
		if (cmd->bits[i] != 0)
			temp ^= sd->sd_DO;
	}
}

/*
 * Clear CS put the chip in the reset state, where it can wait for new commands.
 */
static void
reset_seeprom(struct seeprom_descriptor *sd)
{
	u_int8_t temp;

	temp = sd->sd_MS;
	SEEPROM_OUTB(sd, temp);
	CLOCK_PULSE(sd, sd->sd_RDY);
	SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
	CLOCK_PULSE(sd, sd->sd_RDY);
	SEEPROM_OUTB(sd, temp);
	CLOCK_PULSE(sd, sd->sd_RDY);
}
d104 1
a104 1
	u_int8_t temp;
d111 5
d120 10
a129 2
		send_seeprom_cmd(sd, &seeprom_read);

a130 1
		temp = sd->sd_MS ^ sd->sd_CS;
d162 7
a168 1
		reset_seeprom(sd);
@


1.15
log
@move verify_cksum() to ahc; krw@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.14 2003/08/08 21:34:39 fgsch Exp $	*/
a60 2
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
@


1.14
log
@remove unused code and a some cleanup; deraadt@@ and krw@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.13 2002/06/30 19:36:58 smurph Exp $	*/
a198 22
}

int
verify_cksum(struct seeprom_config *sc)
{
	int i;
	int maxaddr;
	u_int32_t checksum;
	u_int16_t *scarray;

	maxaddr = (sizeof(*sc)/2) - 1;
	checksum = 0;
	scarray = (uint16_t *)sc;

	for (i = 0; i < maxaddr; i++)
		checksum = checksum + scarray[i];
	if (checksum == 0 ||
	    (checksum & 0xFFFF) != sc->checksum) {
		return (0);
	} else {
		return(1);
	}
@


1.13
log
@Add write function to seeprom.
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.12 2002/06/28 01:27:59 millert Exp $	*/
a59 4
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
#include <machine/bus_memio.h>
#include <machine/bus_pio.h>
#endif
a60 1
#if defined(__OpenBSD__)
a61 1
#endif 
a62 3
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
#include <dev/aic7xxx/93cx6.h>
#else
a63 1
#endif
a73 4
static struct seeprom_cmd seeprom_ewen = {9, {1, 0, 0, 1, 1, 0, 0, 0, 0}};
static struct seeprom_cmd seeprom_ewds = {9, {1, 0, 0, 0, 0, 0, 0, 0, 0}};
static struct seeprom_cmd seeprom_write = {3, {1, 0, 1}};

a200 72
/*
 * Write the serial EEPROM and return 1 if successful and 0 if
 * not successful.
 */
int
write_seeprom(sd, buf, start_addr, count)
	struct seeprom_descriptor *sd;
	u_int16_t *buf;
	bus_size_t start_addr;
	bus_size_t count;
{
	u_int16_t v;
	u_int8_t temp;
	int i, k;

	/* Place the chip into write-enable mode */
	send_seeprom_cmd(sd, &seeprom_ewen);
	reset_seeprom(sd);

	/* Write all requested data out to the seeprom. */
	temp = sd->sd_MS ^ sd->sd_CS;
	for (k = start_addr; k < count + start_addr; k++) {
		/* Send the write command */
		send_seeprom_cmd(sd, &seeprom_write);

		/* Send the 6 or 8 bit address (MSB first). */
		for (i = (sd->sd_chip - 1); i >= 0; i--) {
			if ((k & (1 << i)) != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if ((k & (1 << i)) != 0)
				temp ^= sd->sd_DO;
		}

		/* Write the 16 bit value, MSB first */
		v = buf[k - start_addr];
		for (i = 15; i >= 0; i--) {
			if ((v & (1 << i)) != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if ((v & (1 << i)) != 0)
				temp ^= sd->sd_DO;
		}

		/* Wait for the chip to complete the write */
		temp = sd->sd_MS;
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
		temp = sd->sd_MS ^ sd->sd_CS;
		do {
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
		} while ((SEEPROM_DATA_INB(sd) & sd->sd_DI) == 0);

		reset_seeprom(sd);
	}

	/* Put the chip back into write-protect mode */
	send_seeprom_cmd(sd, &seeprom_ewds);
	reset_seeprom(sd);

	return (1);
}

d215 2
a216 2
	if (checksum == 0
	 || (checksum & 0xFFFF) != sc->checksum) {
@


1.12
log
@actually, new new ahc uses these after all
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.10 2002/06/28 00:34:54 smurph Exp $	*/
d81 1
a81 1
 	unsigned char bits[3];
d84 4
d98 43
a160 5
		/* Send chip select for one clock cycle. */
		temp = sd->sd_MS ^ sd->sd_CS;
		SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
		CLOCK_PULSE(sd, sd->sd_RDY);

d165 2
a166 10
		for (i = 0; i < seeprom_read.len; i++) {
			if (seeprom_read.bits[i] != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if (seeprom_read.bits[i] != 0)
				temp ^= sd->sd_DO;
		}
d168 1
d200 1
a200 7
		temp = sd->sd_MS;
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
		SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
		CLOCK_PULSE(sd, sd->sd_RDY);
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
d212 72
@


1.11
log
@not used by new ahc driver
@
text
@@


1.10
log
@Return of new ahc
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.9 2002/03/19 02:49:20 millert Exp $	*/
@


1.9
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.7 2000/01/31 01:50:54 weingart Exp $	*/
d32 1
a32 1
 *     EWEN        1    00   11XXXX              Write enable must preceed
d65 4
d184 22
@


1.8
log
@New port of FreeBSD's ahc driver
@
text
@@


1.7
log
@Add support for 93C66 and 93C56 SEEPROM chips.
Adapted from FreeBSD code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.7.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.7 2000/01/31 01:50:54 weingart Exp $	*/
@


1.7.12.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.7.12.1 2002/06/11 03:42:20 art Exp $	*/
d32 1
a32 1
 *     EWEN        1    00   11XXXX              Write enable must precede
a64 4
#if defined(__OpenBSD__)
#include <dev/ic/aic7xxx_openbsd.h>
#endif 
#include <dev/ic/aic7xxx_inline.h>
d77 1
a77 1
 	unsigned char bits[9];
a79 4
static struct seeprom_cmd seeprom_ewen = {9, {1, 0, 0, 1, 1, 0, 0, 0, 0}};
static struct seeprom_cmd seeprom_ewds = {9, {1, 0, 0, 0, 0, 0, 0, 0, 0}};
static struct seeprom_cmd seeprom_write = {3, {1, 0, 1}};

a89 43
 * Send a START condition and the given command
 */
static void
send_seeprom_cmd(struct seeprom_descriptor *sd, struct seeprom_cmd *cmd)
{
	u_int8_t temp;
	int i = 0;

	/* Send chip select for one clock cycle. */
	temp = sd->sd_MS ^ sd->sd_CS;
	SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
	CLOCK_PULSE(sd, sd->sd_RDY);

	for (i = 0; i < cmd->len; i++) {
		if (cmd->bits[i] != 0)
			temp ^= sd->sd_DO;
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
		SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
		CLOCK_PULSE(sd, sd->sd_RDY);
		if (cmd->bits[i] != 0)
			temp ^= sd->sd_DO;
	}
}

/*
 * Clear CS put the chip in the reset state, where it can wait for new commands.
 */
static void
reset_seeprom(struct seeprom_descriptor *sd)
{
	u_int8_t temp;

	temp = sd->sd_MS;
	SEEPROM_OUTB(sd, temp);
	CLOCK_PULSE(sd, sd->sd_RDY);
	SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
	CLOCK_PULSE(sd, sd->sd_RDY);
	SEEPROM_OUTB(sd, temp);
	CLOCK_PULSE(sd, sd->sd_RDY);
}

/*
d110 5
d119 10
a128 2
		send_seeprom_cmd(sd, &seeprom_read);

a129 1
		temp = sd->sd_MS ^ sd->sd_CS;
d161 7
a167 1
		reset_seeprom(sd);
a179 94
}

/*
 * Write the serial EEPROM and return 1 if successful and 0 if
 * not successful.
 */
int
write_seeprom(sd, buf, start_addr, count)
	struct seeprom_descriptor *sd;
	u_int16_t *buf;
	bus_size_t start_addr;
	bus_size_t count;
{
	u_int16_t v;
	u_int8_t temp;
	int i, k;

	/* Place the chip into write-enable mode */
	send_seeprom_cmd(sd, &seeprom_ewen);
	reset_seeprom(sd);

	/* Write all requested data out to the seeprom. */
	temp = sd->sd_MS ^ sd->sd_CS;
	for (k = start_addr; k < count + start_addr; k++) {
		/* Send the write command */
		send_seeprom_cmd(sd, &seeprom_write);

		/* Send the 6 or 8 bit address (MSB first). */
		for (i = (sd->sd_chip - 1); i >= 0; i--) {
			if ((k & (1 << i)) != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if ((k & (1 << i)) != 0)
				temp ^= sd->sd_DO;
		}

		/* Write the 16 bit value, MSB first */
		v = buf[k - start_addr];
		for (i = 15; i >= 0; i--) {
			if ((v & (1 << i)) != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if ((v & (1 << i)) != 0)
				temp ^= sd->sd_DO;
		}

		/* Wait for the chip to complete the write */
		temp = sd->sd_MS;
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
		temp = sd->sd_MS ^ sd->sd_CS;
		do {
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
		} while ((SEEPROM_DATA_INB(sd) & sd->sd_DI) == 0);

		reset_seeprom(sd);
	}

	/* Put the chip back into write-protect mode */
	send_seeprom_cmd(sd, &seeprom_ewds);
	reset_seeprom(sd);

	return (1);
}

int
verify_cksum(struct seeprom_config *sc)
{
	int i;
	int maxaddr;
	u_int32_t checksum;
	u_int16_t *scarray;

	maxaddr = (sizeof(*sc)/2) - 1;
	checksum = 0;
	scarray = (uint16_t *)sc;

	for (i = 0; i < maxaddr; i++)
		checksum = checksum + scarray[i];
	if (checksum == 0
	 || (checksum & 0xFFFF) != sc->checksum) {
		return (0);
	} else {
		return(1);
	}
@


1.7.2.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.7 2000/01/31 01:50:54 weingart Exp $	*/
@


1.7.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.7.2.3
log
@Sync the SMP branch with 3.3
@
text
@d32 1
a32 1
 *     EWEN        1    00   11XXXX              Write enable must precede
a64 4
#if defined(__OpenBSD__)
#include <dev/ic/aic7xxx_openbsd.h>
#endif 
#include <dev/ic/aic7xxx_inline.h>
d77 1
a77 1
 	unsigned char bits[9];
a79 4
static struct seeprom_cmd seeprom_ewen = {9, {1, 0, 0, 1, 1, 0, 0, 0, 0}};
static struct seeprom_cmd seeprom_ewds = {9, {1, 0, 0, 0, 0, 0, 0, 0, 0}};
static struct seeprom_cmd seeprom_write = {3, {1, 0, 1}};

a89 43
 * Send a START condition and the given command
 */
static void
send_seeprom_cmd(struct seeprom_descriptor *sd, struct seeprom_cmd *cmd)
{
	u_int8_t temp;
	int i = 0;

	/* Send chip select for one clock cycle. */
	temp = sd->sd_MS ^ sd->sd_CS;
	SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
	CLOCK_PULSE(sd, sd->sd_RDY);

	for (i = 0; i < cmd->len; i++) {
		if (cmd->bits[i] != 0)
			temp ^= sd->sd_DO;
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
		SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
		CLOCK_PULSE(sd, sd->sd_RDY);
		if (cmd->bits[i] != 0)
			temp ^= sd->sd_DO;
	}
}

/*
 * Clear CS put the chip in the reset state, where it can wait for new commands.
 */
static void
reset_seeprom(struct seeprom_descriptor *sd)
{
	u_int8_t temp;

	temp = sd->sd_MS;
	SEEPROM_OUTB(sd, temp);
	CLOCK_PULSE(sd, sd->sd_RDY);
	SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
	CLOCK_PULSE(sd, sd->sd_RDY);
	SEEPROM_OUTB(sd, temp);
	CLOCK_PULSE(sd, sd->sd_RDY);
}

/*
d110 5
d119 10
a128 2
		send_seeprom_cmd(sd, &seeprom_read);

a129 1
		temp = sd->sd_MS ^ sd->sd_CS;
d161 7
a167 1
		reset_seeprom(sd);
a179 94
}

/*
 * Write the serial EEPROM and return 1 if successful and 0 if
 * not successful.
 */
int
write_seeprom(sd, buf, start_addr, count)
	struct seeprom_descriptor *sd;
	u_int16_t *buf;
	bus_size_t start_addr;
	bus_size_t count;
{
	u_int16_t v;
	u_int8_t temp;
	int i, k;

	/* Place the chip into write-enable mode */
	send_seeprom_cmd(sd, &seeprom_ewen);
	reset_seeprom(sd);

	/* Write all requested data out to the seeprom. */
	temp = sd->sd_MS ^ sd->sd_CS;
	for (k = start_addr; k < count + start_addr; k++) {
		/* Send the write command */
		send_seeprom_cmd(sd, &seeprom_write);

		/* Send the 6 or 8 bit address (MSB first). */
		for (i = (sd->sd_chip - 1); i >= 0; i--) {
			if ((k & (1 << i)) != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if ((k & (1 << i)) != 0)
				temp ^= sd->sd_DO;
		}

		/* Write the 16 bit value, MSB first */
		v = buf[k - start_addr];
		for (i = 15; i >= 0; i--) {
			if ((v & (1 << i)) != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if ((v & (1 << i)) != 0)
				temp ^= sd->sd_DO;
		}

		/* Wait for the chip to complete the write */
		temp = sd->sd_MS;
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
		temp = sd->sd_MS ^ sd->sd_CS;
		do {
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
		} while ((SEEPROM_DATA_INB(sd) & sd->sd_DI) == 0);

		reset_seeprom(sd);
	}

	/* Put the chip back into write-protect mode */
	send_seeprom_cmd(sd, &seeprom_ewds);
	reset_seeprom(sd);

	return (1);
}

int
verify_cksum(struct seeprom_config *sc)
{
	int i;
	int maxaddr;
	u_int32_t checksum;
	u_int16_t *scarray;

	maxaddr = (sizeof(*sc)/2) - 1;
	checksum = 0;
	scarray = (uint16_t *)sc;

	for (i = 0; i < maxaddr; i++)
		checksum = checksum + scarray[i];
	if (checksum == 0
	 || (checksum & 0xFFFF) != sc->checksum) {
		return (0);
	} else {
		return(1);
	}
@


1.7.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 2
/*	$NetBSD: smc93cx6.c,v 1.10 2003/05/02 19:12:19 dyoung Exp $	*/

a21 2
 *
 * $FreeBSD: src/sys/dev/aic7xxx/93cx6.c,v 1.5 2000/01/07 23:08:17 gibbs Exp $
d60 4
d65 7
d73 1
d81 1
a81 1
 	unsigned char bits[3];
d84 55
a138 14
#define CLOCK_PULSE(sd, rdy)	do {					\
	/*								\
	 * Wait for the SEERDY to go high; about 800 ns.		\
	 */								\
	int cpi = 1000;							\
	if (rdy == 0) {							\
		DELAY(4); /* more than long enough */			\
		break;							\
	}								\
	while ((SEEPROM_STATUS_INB(sd) & rdy) == 0 && cpi-- > 0) {	\
		;  /* Do nothing */					\
	}								\
	(void)SEEPROM_INB(sd);	/* Clear clock */			\
} while (0)
d154 1
a154 1
	u_int32_t temp;
a160 5
		/* Send chip select for one clock cycle. */
		temp = sd->sd_MS ^ sd->sd_CS;
		SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
		CLOCK_PULSE(sd, sd->sd_RDY);

d165 2
a166 10
		for (i = 0; i < seeprom_read.len; i++) {
			if (seeprom_read.bits[i] != 0)
				temp ^= sd->sd_DO;
			SEEPROM_OUTB(sd, temp);
			CLOCK_PULSE(sd, sd->sd_RDY);
			SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
			CLOCK_PULSE(sd, sd->sd_RDY);
			if (seeprom_read.bits[i] != 0)
				temp ^= sd->sd_DO;
		}
d168 1
d200 1
a200 7
		temp = sd->sd_MS;
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
		SEEPROM_OUTB(sd, temp ^ sd->sd_CK);
		CLOCK_PULSE(sd, sd->sd_RDY);
		SEEPROM_OUTB(sd, temp);
		CLOCK_PULSE(sd, sd->sd_RDY);
d213 94
@


1.6
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 2
a2 3
/*	$OpenBSD: smc93cx6.c,v 1.5 1996/11/12 20:30:23 niklas Exp $	*/
/*	$NetBSD: smc93cx6.c,v 1.5 1996/10/21 22:34:38 thorpej Exp $	*/

d4 1
a4 1
 * Interface for the 93C46/26/06 serial eeprom parts.
d6 1
a6 1
 * Copyright (c) 1995 Daniel M. Eischen
d25 1
a25 1
 *   The instruction set of the 93C46/26/06 chips are as follows:
d27 2
a28 2
 *               Start  OP
 *     Function   Bit  Code  Address    Data     Description
d41 2
d48 1
a48 1
 *   respectively.  While the chip select remains high, you can clock in
d60 4
a63 4
#if defined(__FreeBSD__)
#include <machine/clock.h>
#include <i386/scsi/93cx6.h>
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d65 3
d83 5
a87 4
#define CLOCK_PULSE(sd, rdy)			\
	while ((SEEPROM_INB(sd) & rdy) == 0) {		\
		;  /* Do nothing */		\
	}
a96 4
#if defined(__FreeBSD__)
	u_int start_addr;
	int count;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a98 1
#endif
d100 2
a101 1
	int i = 0, k = 0;
d129 2
a130 2
		/* Send the 6 bit address (MSB first, LSB last). */
		for (i = 5; i >= 0; i--) {
d152 1
a152 1
			if (SEEPROM_INB(sd) & sd->sd_DI)
d169 2
a170 2
#if 0
	printf ("Serial EEPROM:");
d172 2
a173 3
		if (((k % 8) == 0) && (k != 0))
		{
			printf ("\n              ");
@


1.5
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 1
/*	$OpenBSD: smc93cx6.c,v 1.4 1996/10/31 01:01:40 niklas Exp $	*/
d63 1
a63 1
#include <machine/bus.old.h>
d96 2
a97 2
	bus_io_size_t start_addr;
	bus_io_size_t count;
@


1.4
log
@$OpenBSD RCSIDs
@
text
@d1 1
a1 1
/*	$OpenBSD: smc93cx6.c,v 1.3 1996/08/21 22:27:43 deraadt Exp $	*/
d62 1
a62 1
#include <machine/bus.h>
@


1.3
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@d1 2
a21 2
 *
 *      $Id: smc93cx6.c,v 1.2 1996/06/27 21:15:50 shawn Exp $
@


1.2
log
@new 2940 driver merged from freebsd sources 960623
@
text
@d21 1
a21 1
 *      $Id: 93cx6.c,v 1.5 1996/05/30 07:19:54 gibbs Exp $
d61 1
a61 1
#elif defined(__NetBSD__)
d94 1
a94 1
#elif defined(__NetBSD__)
@


1.1
log
@sync 0521
@
text
@a0 2
/*	$NetBSD: smc93cx6.c,v 1.1 1996/05/16 03:59:10 mycroft Exp $	*/

d20 2
a74 10
#if defined(__FreeBSD__)
#define	SEEPROM_INB(sd)		inb(sd->sd_iobase)
#define	SEEPROM_OUTB(sd, value)	outb(sd->sd_iobase, value)
#elif defined(__NetBSD__)
#define	SEEPROM_INB(sd) \
	bus_io_read_1(sd->sd_bc, sd->sd_ioh, sd->sd_offset)
#define	SEEPROM_OUTB(sd, value) \
	bus_io_write_1(sd->sd_bc, sd->sd_ioh, sd->sd_offset, value)
#endif

a178 33
}

int
acquire_seeprom(sd)
	struct seeprom_descriptor *sd;
{
	int wait;

	/*
	 * Request access of the memory port.  When access is
	 * granted, SEERDY will go high.  We use a 1 second
	 * timeout which should be near 1 second more than
	 * is needed.  Reason: after the chip reset, there
	 * should be no contention.
	 */
	SEEPROM_OUTB(sd, sd->sd_MS);
	wait = 1000;  /* 1 second timeout in msec */
	while (--wait && ((SEEPROM_INB(sd) & sd->sd_RDY) == 0)) {
		DELAY (1000);  /* delay 1 msec */
        }
	if ((SEEPROM_INB(sd) & sd->sd_RDY) == 0) {
		SEEPROM_OUTB(sd, 0); 
		return (0);
	}         
	return(1);
}

void
release_seeprom(sd)
	struct seeprom_descriptor *sd;
{
	/* Release access to the memory port and the serial EEPROM. */
	SEEPROM_OUTB(sd, 0);
@
