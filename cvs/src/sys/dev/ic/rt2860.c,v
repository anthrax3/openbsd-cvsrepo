head	1.94;
access;
symbols
	OPENBSD_6_1:1.92.0.4
	OPENBSD_6_1_BASE:1.92
	OPENBSD_6_0:1.90.0.4
	OPENBSD_6_0_BASE:1.90
	OPENBSD_5_9:1.87.0.2
	OPENBSD_5_9_BASE:1.87
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.74.0.4
	OPENBSD_5_6_BASE:1.74
	OPENBSD_5_5:1.71.0.4
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.68.0.2
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.65.0.6
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.8
	OPENBSD_5_0:1.65.0.4
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.65.0.2
	OPENBSD_4_9_BASE:1.65
	OPENBSD_4_8:1.57.0.2
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.34.0.4
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11;
locks; strict;
comment	@ * @;


1.94
date	2017.07.03.09.21.09;	author kevlo;	state Exp;
branches;
next	1.93;
commitid	Ssa221KhuyTS2oq4;

1.93
date	2017.05.31.03.45.15;	author jsg;	state Exp;
branches;
next	1.92;
commitid	L4gGaeoJGdu7K7Ou;

1.92
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.91;
commitid	VyLWTsbepAOk7VQM;

1.91
date	2016.08.17.11.50.52;	author stsp;	state Exp;
branches;
next	1.90;
commitid	HEQW3uHEkL9CrHHt;

1.90
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.89;
commitid	QHiEhS9DHyE6oiIr;

1.89
date	2016.03.21.21.16.30;	author stsp;	state Exp;
branches;
next	1.88;
commitid	SFvz494jge4qMbr0;

1.88
date	2016.03.21.21.16.01;	author stsp;	state Exp;
branches;
next	1.87;
commitid	XBQSRFlZr25PQ4cY;

1.87
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.86;
commitid	2QagMjdMhQhIaQgu;

1.86
date	2015.12.11.16.07.01;	author mpi;	state Exp;
branches;
next	1.85;
commitid	fbhqfhfdKxBcsetK;

1.85
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.84;
commitid	B0kwmVGiD5DVx4kv;

1.84
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.83;
commitid	5DvsamK0GblTp8ww;

1.83
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.82;
commitid	YT6fyIEviv9qwbl6;

1.82
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.81;
commitid	p0v5tuE1Ch6fY0Nj;

1.81
date	2015.08.29.20.55.34;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	pUbB7iMiclIsR7nA;

1.80
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.79;
commitid	p4LJxGKbi0BU2cG6;

1.79
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.78;
commitid	Hly9lJn6CNMylcFu;

1.78
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.77;
commitid	yM2VFFhpDTeFQlve;

1.77
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.76;
commitid	LS2TNeCue5R9L67C;

1.76
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.75;
commitid	Z1vcFtHO8wRH0yRt;

1.75
date	2014.09.06.05.41.35;	author jsg;	state Exp;
branches;
next	1.74;
commitid	TZ6gfz2Iz0CRv2Rz;

1.74
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.73;
commitid	TGHgrLxu6sxZoiFt;

1.73
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.72;
commitid	I19imNlAX05zJOED;

1.72
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.71;

1.71
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2013.08.07.01.06.30;	author bluhm;	state Exp;
branches;
next	1.69;

1.69
date	2013.08.01.09.17.02;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2013.06.11.18.15.53;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2012.10.12.19.53.24;	author haesbaert;	state Exp;
branches;
next	1.66;

1.66
date	2012.10.11.09.43.22;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2010.10.23.14.24.54;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.06.19.20.22;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.28.18.08.07;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.60;

1.60
date	2010.08.27.16.06.25;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2010.08.27.04.09.18;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2010.08.25.21.37.59;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2010.08.04.19.48.33;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2010.07.19.19.47.52;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.19.19.22.46;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.19.19.08.28;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2010.05.10.18.17.10;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2010.04.12.18.02.31;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2010.04.10.07.57.21;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.06.19.40.51;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.06.16.49.08;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.06.16.41.54;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2010.04.06.16.14.47;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.05.19.00.50;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.05.14.14.02;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2010.04.04.08.07.50;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2010.03.27.16.13.24;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2010.02.08.18.46.47;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2010.02.08.18.26.31;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2010.02.07.09.14.55;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.10.21.01.29;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.03.17.36.58;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.01.12.08.36;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2009.08.10.17.47.23;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2009.05.11.19.20.27;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.26.19.18.52;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.29.13.59.00;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.29.13.27.27;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.22.18.20.47;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.21.18.19.58;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.15.18.35.59;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.14.18.41.57;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.14.10.23.08;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.13.14.35.19;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.13.12.07.40;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.12.21.18.36;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.12.20.58.48;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.25.21.43.57;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.14.16.02.24;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.21.19.41.44;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.08.19.34.14;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.26.20.08.01;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.17.18.16.05;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.14.21.28.49;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.09.19.55.51;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.07.21.23.14;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.07.19.37.04;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.04.22.26.55;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.19.21.26.19;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.17.15.39.38;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.17.12.04.00;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.16.21.34.28;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.16.01.35.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.15.21.15.34;	author damien;	state Exp;
branches;
next	;


desc
@@


1.94
log
@Replace slot time durations with macros.

ok stsp@@
@
text
@/*	$OpenBSD: rt2860.c,v 1.93 2017/05/31 03:45:15 jsg Exp $	*/

/*-
 * Copyright (c) 2007-2010 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Ralink Technology RT2860/RT3090/RT3390/RT3562/RT5390/RT5392 chipset driver
 * http://www.ralinktech.com/
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/rt2860var.h>
#include <dev/ic/rt2860reg.h>

#include <dev/pci/pcidevs.h>

#ifdef RAL_DEBUG
#define DPRINTF(x)	do { if (rt2860_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (rt2860_debug >= (n)) printf x; } while (0)
int rt2860_debug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

void		rt2860_attachhook(struct device *);
int		rt2860_alloc_tx_ring(struct rt2860_softc *,
		    struct rt2860_tx_ring *);
void		rt2860_reset_tx_ring(struct rt2860_softc *,
		    struct rt2860_tx_ring *);
void		rt2860_free_tx_ring(struct rt2860_softc *,
		    struct rt2860_tx_ring *);
int		rt2860_alloc_tx_pool(struct rt2860_softc *);
void		rt2860_free_tx_pool(struct rt2860_softc *);
int		rt2860_alloc_rx_ring(struct rt2860_softc *,
		    struct rt2860_rx_ring *);
void		rt2860_reset_rx_ring(struct rt2860_softc *,
		    struct rt2860_rx_ring *);
void		rt2860_free_rx_ring(struct rt2860_softc *,
		    struct rt2860_rx_ring *);
struct		ieee80211_node *rt2860_node_alloc(struct ieee80211com *);
int		rt2860_media_change(struct ifnet *);
void		rt2860_iter_func(void *, struct ieee80211_node *);
void		rt2860_updatestats(struct rt2860_softc *);
void		rt2860_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
void		rt2860_node_leave(struct ieee80211com *,
		    struct ieee80211_node *);
int		rt2860_ampdu_rx_start(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
void		rt2860_ampdu_rx_stop(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
int		rt2860_newstate(struct ieee80211com *, enum ieee80211_state,
		    int);
uint16_t	rt3090_efuse_read_2(struct rt2860_softc *, uint16_t);
uint16_t	rt2860_eeprom_read_2(struct rt2860_softc *, uint16_t);
void		rt2860_intr_coherent(struct rt2860_softc *);
void		rt2860_drain_stats_fifo(struct rt2860_softc *);
void		rt2860_tx_intr(struct rt2860_softc *, int);
void		rt2860_rx_intr(struct rt2860_softc *);
void		rt2860_tbtt_intr(struct rt2860_softc *);
void		rt2860_gp_intr(struct rt2860_softc *);
int		rt2860_tx(struct rt2860_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		rt2860_start(struct ifnet *);
void		rt2860_watchdog(struct ifnet *);
int		rt2860_ioctl(struct ifnet *, u_long, caddr_t);
void		rt2860_mcu_bbp_write(struct rt2860_softc *, uint8_t, uint8_t);
uint8_t		rt2860_mcu_bbp_read(struct rt2860_softc *, uint8_t);
void		rt2860_rf_write(struct rt2860_softc *, uint8_t, uint32_t);
uint8_t		rt3090_rf_read(struct rt2860_softc *, uint8_t);
void		rt3090_rf_write(struct rt2860_softc *, uint8_t, uint8_t);
int		rt2860_mcu_cmd(struct rt2860_softc *, uint8_t, uint16_t, int);
void		rt2860_enable_mrr(struct rt2860_softc *);
void		rt2860_set_txpreamble(struct rt2860_softc *);
void		rt2860_set_basicrates(struct rt2860_softc *);
void		rt2860_select_chan_group(struct rt2860_softc *, int);
void		rt2860_set_chan(struct rt2860_softc *, u_int);
void		rt3090_set_chan(struct rt2860_softc *, u_int);
void		rt5390_set_chan(struct rt2860_softc *, u_int);
int		rt3090_rf_init(struct rt2860_softc *);
void		rt5390_rf_init(struct rt2860_softc *);
void		rt3090_rf_wakeup(struct rt2860_softc *);
void		rt5390_rf_wakeup(struct rt2860_softc *);
int		rt3090_filter_calib(struct rt2860_softc *, uint8_t, uint8_t,
		    uint8_t *);
void		rt3090_rf_setup(struct rt2860_softc *);
void		rt2860_set_leds(struct rt2860_softc *, uint16_t);
void		rt2860_set_gp_timer(struct rt2860_softc *, int);
void		rt2860_set_bssid(struct rt2860_softc *, const uint8_t *);
void		rt2860_set_macaddr(struct rt2860_softc *, const uint8_t *);
void		rt2860_updateslot(struct ieee80211com *);
void		rt2860_updateprot(struct ieee80211com *);
void		rt2860_updateedca(struct ieee80211com *);
int		rt2860_set_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
void		rt2860_delete_key(struct ieee80211com *,
		    struct ieee80211_node *, struct ieee80211_key *);
#if NBPFILTER > 0
int8_t		rt2860_rssi2dbm(struct rt2860_softc *, uint8_t, uint8_t);
#endif
const char *	rt2860_get_rf(uint16_t);
int		rt2860_read_eeprom(struct rt2860_softc *);
int		rt2860_bbp_init(struct rt2860_softc *);
void		rt5390_bbp_init(struct rt2860_softc *);
int		rt2860_txrx_enable(struct rt2860_softc *);
int		rt2860_init(struct ifnet *);
void		rt2860_stop(struct ifnet *, int);
int		rt2860_load_microcode(struct rt2860_softc *);
void		rt2860_calib(struct rt2860_softc *);
void		rt3090_set_rx_antenna(struct rt2860_softc *, int);
void		rt2860_switch_chan(struct rt2860_softc *,
		    struct ieee80211_channel *);
#ifndef IEEE80211_STA_ONLY
int		rt2860_setup_beacon(struct rt2860_softc *);
#endif
void		rt2860_enable_tsf_sync(struct rt2860_softc *);

static const struct {
	uint32_t	reg;
	uint32_t	val;
} rt2860_def_mac[] = {
	RT2860_DEF_MAC
};

static const struct {
	uint8_t	reg;
	uint8_t	val;
} rt2860_def_bbp[] = {
	RT2860_DEF_BBP
},rt5390_def_bbp[] = {
	RT5390_DEF_BBP
};

static const struct rfprog {
	uint8_t		chan;
	uint32_t	r1, r2, r3, r4;
} rt2860_rf2850[] = {
	RT2860_RF2850
};

struct {
	uint8_t	n, r, k;
} rt3090_freqs[] = {
	RT3070_RF3052
};

static const struct {
	uint8_t	reg;
	uint8_t	val;
}  rt3090_def_rf[] = {
	RT3070_DEF_RF
}, rt3572_def_rf[] = {
	RT3572_DEF_RF
}, rt5390_def_rf[] = {
	RT5390_DEF_RF
}, rt5392_def_rf[] = {
	RT5392_DEF_RF
};

int
rt2860_attach(void *xsc, int id)
{
	struct rt2860_softc *sc = xsc;
	struct ieee80211com *ic = &sc->sc_ic;
	int qid, ntries, error;
	uint32_t tmp;

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 15;

	/* wait for NIC to initialize */
	for (ntries = 0; ntries < 100; ntries++) {
		tmp = RAL_READ(sc, RT2860_ASIC_VER_ID);
		if (tmp != 0 && tmp != 0xffffffff)
			break;
		DELAY(10);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for NIC to initialize\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}
	sc->mac_ver = tmp >> 16;
	sc->mac_rev = tmp & 0xffff;

	if (sc->mac_ver != 0x2860 &&
	    (id == PCI_PRODUCT_RALINK_RT2890 ||
	     id == PCI_PRODUCT_RALINK_RT2790 ||
	     id == PCI_PRODUCT_AWT_RT2890))
		sc->sc_flags |= RT2860_ADVANCED_PS;

	/* retrieve RF rev. no and various other things from EEPROM */
	rt2860_read_eeprom(sc);
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));
	printf("%s: MAC/BBP RT%X (rev 0x%04X), RF %s (MIMO %dT%dR)\n",
	    sc->sc_dev.dv_xname, sc->mac_ver, sc->mac_rev,
	    rt2860_get_rf(sc->rf_rev), sc->ntxchains, sc->nrxchains);

	/*
	 * Allocate Tx (4 EDCAs + HCCA + Mgt) and Rx rings.
	 */
	for (qid = 0; qid < 6; qid++) {
		if ((error = rt2860_alloc_tx_ring(sc, &sc->txq[qid])) != 0) {
			printf("%s: could not allocate Tx ring %d\n",
			    sc->sc_dev.dv_xname, qid);
			goto fail1;
		}
	}

	if ((error = rt2860_alloc_rx_ring(sc, &sc->rxq)) != 0) {
		printf("%s: could not allocate Rx ring\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}

	if ((error = rt2860_alloc_tx_pool(sc)) != 0) {
		printf("%s: could not allocate Tx pool\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}

	/* mgmt ring is broken on RT2860C, use EDCA AC VO ring instead */
	sc->mgtqid = (sc->mac_ver == 0x2860 && sc->mac_rev == 0x0100) ?
	    EDCA_AC_VO : 5;

	config_mountroot(xsc, rt2860_attachhook);

	return 0;

fail2:	rt2860_free_rx_ring(sc, &sc->rxq);
fail1:	while (--qid >= 0)
		rt2860_free_tx_ring(sc, &sc->txq[qid]);
	return error;
}

void
rt2860_attachhook(struct device *self)
{
	struct rt2860_softc *sc = (struct rt2860_softc *)self;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int i, error;

	error = loadfirmware("ral-rt2860", &sc->ucode, &sc->ucsize);
	if (error != 0) {
		printf("%s: error %d, could not read firmware file %s\n",
		    sc->sc_dev.dv_xname, error, "ral-rt2860");
		return;
	}

	ic->ic_phytype = IEEE80211_T_OFDM; /* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA; /* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
#ifndef IEEE80211_STA_ONLY
	    IEEE80211_C_IBSS |		/* IBSS mode supported */
	    IEEE80211_C_HOSTAP |	/* HostAP mode supported */
	    IEEE80211_C_APPMGT |	/* HostAP power management */
#endif
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_WEP |		/* s/w WEP */
	    IEEE80211_C_RSN;		/* WPA/RSN */

	if (sc->rf_rev == RT2860_RF_2750 || sc->rf_rev == RT2860_RF_2850) {
		/* set supported .11a rates */
		ic->ic_sup_rates[IEEE80211_MODE_11A] =
		    ieee80211_std_rateset_11a;

		/* set supported .11a channels */
		for (i = 14; i < nitems(rt2860_rf2850); i++) {
			uint8_t chan = rt2860_rf2850[i].chan;
			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[chan].ic_flags = IEEE80211_CHAN_A;
		}
	}

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	/* HW supports up to 255 STAs (0-254) in HostAP and IBSS modes */
	ic->ic_max_aid = min(IEEE80211_AID_MAX, RT2860_WCID_MAX);

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = rt2860_ioctl;
	ifp->if_start = rt2860_start;
	ifp->if_watchdog = rt2860_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_node_alloc = rt2860_node_alloc;
	ic->ic_newassoc = rt2860_newassoc;
#ifndef IEEE80211_STA_ONLY
	ic->ic_node_leave = rt2860_node_leave;
#endif
	ic->ic_ampdu_rx_start = rt2860_ampdu_rx_start;
	ic->ic_ampdu_rx_stop = rt2860_ampdu_rx_stop;
	ic->ic_updateslot = rt2860_updateslot;
	ic->ic_updateedca = rt2860_updateedca;
	ic->ic_set_key = rt2860_set_key;
	ic->ic_delete_key = rt2860_delete_key;
	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = rt2860_newstate;
	ieee80211_media_init(ifp, rt2860_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + 64);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(RT2860_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(RT2860_TX_RADIOTAP_PRESENT);
#endif
}

int
rt2860_detach(void *xsc)
{
	struct rt2860_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int qid;

	ieee80211_ifdetach(ifp);	/* free all nodes */
	if_detach(ifp);

	for (qid = 0; qid < 6; qid++)
		rt2860_free_tx_ring(sc, &sc->txq[qid]);
	rt2860_free_rx_ring(sc, &sc->rxq);
	rt2860_free_tx_pool(sc);

	if (sc->ucode != NULL)
		free(sc->ucode, M_DEVBUF, sc->ucsize);

	return 0;
}

void
rt2860_suspend(void *xsc)
{
	struct rt2860_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (ifp->if_flags & IFF_RUNNING)
		rt2860_stop(ifp, 1);
}

void
rt2860_wakeup(void *xsc)
{
	struct rt2860_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (ifp->if_flags & IFF_UP)
		rt2860_init(ifp);
}

int
rt2860_alloc_tx_ring(struct rt2860_softc *sc, struct rt2860_tx_ring *ring)
{
	int nsegs, size, error;

	size = RT2860_TX_RING_COUNT * sizeof (struct rt2860_txd);

	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create DMA map\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Tx rings must be 4-DWORD aligned */
	error = bus_dmamem_alloc(sc->sc_dmat, size, 16, 0, &ring->seg, 1,
	    &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs, size,
	    (caddr_t *)&ring->txd, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map DMA memory\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->txd, size, NULL,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load DMA map\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, size, BUS_DMASYNC_PREWRITE);

	ring->paddr = ring->map->dm_segs[0].ds_addr;

	return 0;

fail:	rt2860_free_tx_ring(sc, ring);
	return error;
}

void
rt2860_reset_tx_ring(struct rt2860_softc *sc, struct rt2860_tx_ring *ring)
{
	struct rt2860_tx_data *data;
	int i;

	for (i = 0; i < RT2860_TX_RING_COUNT; i++) {
		if ((data = ring->data[i]) == NULL)
			continue;	/* nothing mapped in this slot */

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		data->m= NULL;
		data->ni = NULL;	/* node already freed */

		SLIST_INSERT_HEAD(&sc->data_pool, data, next);
		ring->data[i] = NULL;
	}

	ring->queued = 0;
	ring->cur = ring->next = 0;
}

void
rt2860_free_tx_ring(struct rt2860_softc *sc, struct rt2860_tx_ring *ring)
{
	struct rt2860_tx_data *data;
	int i;

	if (ring->txd != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->txd,
		    RT2860_TX_RING_COUNT * sizeof (struct rt2860_txd));
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}
	if (ring->map != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ring->map);

	for (i = 0; i < RT2860_TX_RING_COUNT; i++) {
		if ((data = ring->data[i]) == NULL)
			continue;	/* nothing mapped in this slot */

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);

		SLIST_INSERT_HEAD(&sc->data_pool, data, next);
	}
}

/*
 * Allocate a pool of TX Wireless Information blocks.
 */
int
rt2860_alloc_tx_pool(struct rt2860_softc *sc)
{
	caddr_t vaddr;
	bus_addr_t paddr;
	int i, nsegs, size, error;

	size = RT2860_TX_POOL_COUNT * RT2860_TXWI_DMASZ;

	/* init data_pool early in case of failure.. */
	SLIST_INIT(&sc->data_pool);

	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &sc->txwi_map);
	if (error != 0) {
		printf("%s: could not create DMA map\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0,
	    &sc->txwi_seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->txwi_seg, nsegs, size,
	    &sc->txwi_vaddr, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map DMA memory\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->txwi_map, sc->txwi_vaddr,
	    size, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load DMA map\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	bus_dmamap_sync(sc->sc_dmat, sc->txwi_map, 0, size,
	    BUS_DMASYNC_PREWRITE);

	vaddr = sc->txwi_vaddr;
	paddr = sc->txwi_map->dm_segs[0].ds_addr;
	for (i = 0; i < RT2860_TX_POOL_COUNT; i++) {
		struct rt2860_tx_data *data = &sc->data[i];

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    RT2860_MAX_SCATTER, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &data->map); /* <0> */
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
		data->txwi = (struct rt2860_txwi *)vaddr;
		data->paddr = paddr;
		vaddr += RT2860_TXWI_DMASZ;
		paddr += RT2860_TXWI_DMASZ;

		SLIST_INSERT_HEAD(&sc->data_pool, data, next);
	}

	return 0;

fail:	rt2860_free_tx_pool(sc);
	return error;
}

void
rt2860_free_tx_pool(struct rt2860_softc *sc)
{
	if (sc->txwi_vaddr != NULL) {
		bus_dmamap_sync(sc->sc_dmat, sc->txwi_map, 0,
		    sc->txwi_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, sc->txwi_map);
		bus_dmamem_unmap(sc->sc_dmat, sc->txwi_vaddr,
		    RT2860_TX_POOL_COUNT * RT2860_TXWI_DMASZ);
		bus_dmamem_free(sc->sc_dmat, &sc->txwi_seg, 1);
	}
	if (sc->txwi_map != NULL)
		bus_dmamap_destroy(sc->sc_dmat, sc->txwi_map);

	while (!SLIST_EMPTY(&sc->data_pool)) {
		struct rt2860_tx_data *data;
		data = SLIST_FIRST(&sc->data_pool);
		bus_dmamap_destroy(sc->sc_dmat, data->map);
		SLIST_REMOVE_HEAD(&sc->data_pool, next);
	}
}

int
rt2860_alloc_rx_ring(struct rt2860_softc *sc, struct rt2860_rx_ring *ring)
{
	int i, nsegs, size, error;

	size = RT2860_RX_RING_COUNT * sizeof (struct rt2860_rxd);

	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create DMA map\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Rx ring must be 4-DWORD aligned */
	error = bus_dmamem_alloc(sc->sc_dmat, size, 16, 0, &ring->seg, 1,
	    &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs, size,
	    (caddr_t *)&ring->rxd, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map DMA memory\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->rxd, size, NULL,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load DMA map\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	ring->paddr = ring->map->dm_segs[0].ds_addr;

	for (i = 0; i < RT2860_RX_RING_COUNT; i++) {
		struct rt2860_rx_data *data = &ring->data[i];
		struct rt2860_rxd *rxd = &ring->rxd[i];

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &data->map);
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		data->m = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
		if (data->m == NULL) {
			printf("%s: could not allocate Rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOBUFS;
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL,
		    BUS_DMA_READ | BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: could not load DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		rxd->sdp0 = htole32(data->map->dm_segs[0].ds_addr);
		rxd->sdl0 = htole16(MCLBYTES);
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, size, BUS_DMASYNC_PREWRITE);

	return 0;

fail:	rt2860_free_rx_ring(sc, ring);
	return error;
}

void
rt2860_reset_rx_ring(struct rt2860_softc *sc, struct rt2860_rx_ring *ring)
{
	int i;

	for (i = 0; i < RT2860_RX_RING_COUNT; i++)
		ring->rxd[i].sdl0 &= ~htole16(RT2860_RX_DDONE);

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ring->cur = 0;
}

void
rt2860_free_rx_ring(struct rt2860_softc *sc, struct rt2860_rx_ring *ring)
{
	int i;

	if (ring->rxd != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->rxd,
		    RT2860_RX_RING_COUNT * sizeof (struct rt2860_rxd));
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}
	if (ring->map != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ring->map);

	for (i = 0; i < RT2860_RX_RING_COUNT; i++) {
		struct rt2860_rx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
		}
		if (data->map != NULL)
			bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

struct ieee80211_node *
rt2860_node_alloc(struct ieee80211com *ic)
{
	return malloc(sizeof (struct rt2860_node), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
}

int
rt2860_media_change(struct ifnet *ifp)
{
	struct rt2860_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t rate, ridx;
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate] & IEEE80211_RATE_VAL;
		for (ridx = 0; ridx <= RT2860_RIDX_MAX; ridx++)
			if (rt2860_rates[ridx].rate == rate)
				break;
		sc->fixed_ridx = ridx;
	}

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
	    (IFF_UP | IFF_RUNNING)) {
		rt2860_stop(ifp, 0);
		rt2860_init(ifp);
	}
	return 0;
}

void
rt2860_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct rt2860_softc *sc = arg;
	uint8_t wcid = ((struct rt2860_node *)ni)->wcid;

	ieee80211_amrr_choose(&sc->amrr, ni, &sc->amn[wcid]);
}

void
rt2860_updatestats(struct rt2860_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

#ifndef IEEE80211_STA_ONLY
	/*
	 * In IBSS or HostAP modes (when the hardware sends beacons), the
	 * MAC can run into a livelock and start sending CTS-to-self frames
	 * like crazy if protection is enabled.  Fortunately, we can detect
	 * when such a situation occurs and reset the MAC.
	 */
	if (ic->ic_curmode != IEEE80211_M_STA) {
		/* check if we're in a livelock situation.. */
		uint32_t tmp = RAL_READ(sc, RT2860_DEBUG);
		if ((tmp & (1 << 29)) && (tmp & (1 << 7 | 1 << 5))) {
			/* ..and reset MAC/BBP for a while.. */
			DPRINTF(("CTS-to-self livelock detected\n"));
			RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, RT2860_MAC_SRST);
			RAL_BARRIER_WRITE(sc);
			DELAY(1);
			RAL_WRITE(sc, RT2860_MAC_SYS_CTRL,
			    RT2860_MAC_RX_EN | RT2860_MAC_TX_EN);
		}
	}
#endif
	if (ic->ic_opmode == IEEE80211_M_STA)
		rt2860_iter_func(sc, ic->ic_bss);
#ifndef IEEE80211_STA_ONLY
	else
		ieee80211_iterate_nodes(ic, rt2860_iter_func, sc);
#endif
}

void
rt2860_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct rt2860_softc *sc = ic->ic_softc;
	struct rt2860_node *rn = (void *)ni;
	struct ieee80211_rateset *rs = &ni->ni_rates;
	uint8_t rate, wcid = 0;
	int ridx, i, j;

	if (isnew && ni->ni_associd != 0) {
		/* only interested in true associations */
		wcid = rn->wcid = IEEE80211_AID(ni->ni_associd);

		/* init WCID table entry */
		RAL_WRITE_REGION_1(sc, RT2860_WCID_ENTRY(wcid),
		    ni->ni_macaddr, IEEE80211_ADDR_LEN);
	}
	DPRINTF(("new assoc isnew=%d addr=%s WCID=%d\n",
	    isnew, ether_sprintf(ni->ni_macaddr), wcid));

	ieee80211_amrr_node_init(&sc->amrr, &sc->amn[wcid]);
	/* start at lowest available bit-rate, AMRR will raise */
	ni->ni_txrate = 0;

	for (i = 0; i < rs->rs_nrates; i++) {
		rate = rs->rs_rates[i] & IEEE80211_RATE_VAL;
		/* convert 802.11 rate to hardware rate index */
		for (ridx = 0; ridx < RT2860_RIDX_MAX; ridx++)
			if (rt2860_rates[ridx].rate == rate)
				break;
		rn->ridx[i] = ridx;
		/* determine rate of control response frames */
		for (j = i; j >= 0; j--) {
			if ((rs->rs_rates[j] & IEEE80211_RATE_BASIC) &&
			    rt2860_rates[rn->ridx[i]].phy ==
			    rt2860_rates[rn->ridx[j]].phy)
				break;
		}
		if (j >= 0) {
			rn->ctl_ridx[i] = rn->ridx[j];
		} else {
			/* no basic rate found, use mandatory one */
			rn->ctl_ridx[i] = rt2860_rates[ridx].ctl_ridx;
		}
		DPRINTF(("rate=0x%02x ridx=%d ctl_ridx=%d\n",
		    rs->rs_rates[i], rn->ridx[i], rn->ctl_ridx[i]));
	}
}

#ifndef IEEE80211_STA_ONLY
void
rt2860_node_leave(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct rt2860_softc *sc = ic->ic_softc;
	uint8_t wcid = ((struct rt2860_node *)ni)->wcid;

	/* clear Rx WCID search table entry */
	RAL_SET_REGION_4(sc, RT2860_WCID_ENTRY(wcid), 0, 2);
}
#endif

int
rt2860_ampdu_rx_start(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct rt2860_softc *sc = ic->ic_softc;
	uint8_t wcid = ((struct rt2860_node *)ni)->wcid;
	uint32_t tmp;

	/* update BA session mask */
	tmp = RAL_READ(sc, RT2860_WCID_ENTRY(wcid) + 4);
	tmp |= (1 << tid) << 16;
	RAL_WRITE(sc, RT2860_WCID_ENTRY(wcid) + 4, tmp);
	return 0;
}

void
rt2860_ampdu_rx_stop(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct rt2860_softc *sc = ic->ic_softc;
	uint8_t wcid = ((struct rt2860_node *)ni)->wcid;
	uint32_t tmp;

	/* update BA session mask */
	tmp = RAL_READ(sc, RT2860_WCID_ENTRY(wcid) + 4);
	tmp &= ~((1 << tid) << 16);
	RAL_WRITE(sc, RT2860_WCID_ENTRY(wcid) + 4, tmp);
}

int
rt2860_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct rt2860_softc *sc = ic->ic_if.if_softc;
	enum ieee80211_state ostate;
	uint32_t tmp;

	ostate = ic->ic_state;

	if (ostate == IEEE80211_S_RUN) {
		/* turn link LED off */
		rt2860_set_leds(sc, RT2860_LED_RADIO);
	}

	switch (nstate) {
	case IEEE80211_S_INIT:
		if (ostate == IEEE80211_S_RUN) {
			/* abort TSF synchronization */
			tmp = RAL_READ(sc, RT2860_BCN_TIME_CFG);
			RAL_WRITE(sc, RT2860_BCN_TIME_CFG,
			    tmp & ~(RT2860_BCN_TX_EN | RT2860_TSF_TIMER_EN |
			    RT2860_TBTT_TIMER_EN));
		}
		rt2860_set_gp_timer(sc, 0);
		break;

	case IEEE80211_S_SCAN:
		rt2860_switch_chan(sc, ic->ic_bss->ni_chan);
		if (ostate != IEEE80211_S_SCAN)
			rt2860_set_gp_timer(sc, 150);
		break;

	case IEEE80211_S_AUTH:
	case IEEE80211_S_ASSOC:
		rt2860_set_gp_timer(sc, 0);
		rt2860_switch_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_RUN:
		rt2860_set_gp_timer(sc, 0);
		rt2860_switch_chan(sc, ic->ic_bss->ni_chan);

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			rt2860_updateslot(ic);
			rt2860_enable_mrr(sc);
			rt2860_set_txpreamble(sc);
			rt2860_set_basicrates(sc);
			rt2860_set_bssid(sc, ic->ic_bss->ni_bssid);
		}

#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
		    ic->ic_opmode == IEEE80211_M_IBSS)
			(void)rt2860_setup_beacon(sc);
#endif

		if (ic->ic_opmode == IEEE80211_M_STA) {
			/* fake a join to init the tx rate */
			rt2860_newassoc(ic, ic->ic_bss, 1);
		}

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			rt2860_enable_tsf_sync(sc);
			rt2860_set_gp_timer(sc, 500);
		}

		/* turn link LED on */
		rt2860_set_leds(sc, RT2860_LED_RADIO |
		    (IEEE80211_IS_CHAN_2GHZ(ic->ic_bss->ni_chan) ?
		     RT2860_LED_LINK_2GHZ : RT2860_LED_LINK_5GHZ));
		break;
	}

	return sc->sc_newstate(ic, nstate, arg);
}

/* Read 16-bit from eFUSE ROM (>=RT3071 only.) */
uint16_t
rt3090_efuse_read_2(struct rt2860_softc *sc, uint16_t addr)
{
	uint32_t tmp;
	uint16_t reg;
	int ntries;

	addr *= 2;
	/*-
	 * Read one 16-byte block into registers EFUSE_DATA[0-3]:
	 * DATA0: F E D C
	 * DATA1: B A 9 8
	 * DATA2: 7 6 5 4
	 * DATA3: 3 2 1 0
	 */
	tmp = RAL_READ(sc, RT3070_EFUSE_CTRL);
	tmp &= ~(RT3070_EFSROM_MODE_MASK | RT3070_EFSROM_AIN_MASK);
	tmp |= (addr & ~0xf) << RT3070_EFSROM_AIN_SHIFT | RT3070_EFSROM_KICK;
	RAL_WRITE(sc, RT3070_EFUSE_CTRL, tmp);
	for (ntries = 0; ntries < 500; ntries++) {
		tmp = RAL_READ(sc, RT3070_EFUSE_CTRL);
		if (!(tmp & RT3070_EFSROM_KICK))
			break;
		DELAY(2);
	}
	if (ntries == 500)
		return 0xffff;

	if ((tmp & RT3070_EFUSE_AOUT_MASK) == RT3070_EFUSE_AOUT_MASK)
		return 0xffff;	/* address not found */

	/* determine to which 32-bit register our 16-bit word belongs */
	reg = RT3070_EFUSE_DATA3 - (addr & 0xc);
	tmp = RAL_READ(sc, reg);

	return (addr & 2) ? tmp >> 16 : tmp & 0xffff;
}

/*
 * Read 16 bits at address 'addr' from the serial EEPROM (either 93C46,
 * 93C66 or 93C86).
 */
uint16_t
rt2860_eeprom_read_2(struct rt2860_softc *sc, uint16_t addr)
{
	uint32_t tmp;
	uint16_t val;
	int n;

	/* clock C once before the first command */
	RT2860_EEPROM_CTL(sc, 0);

	RT2860_EEPROM_CTL(sc, RT2860_S);
	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_C);
	RT2860_EEPROM_CTL(sc, RT2860_S);

	/* write start bit (1) */
	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_D);
	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_D | RT2860_C);

	/* write READ opcode (10) */
	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_D);
	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_D | RT2860_C);
	RT2860_EEPROM_CTL(sc, RT2860_S);
	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_C);

	/* write address (A5-A0 or A7-A0) */
	n = ((RAL_READ(sc, RT2860_PCI_EECTRL) & 0x30) == 0) ? 5 : 7;
	for (; n >= 0; n--) {
		RT2860_EEPROM_CTL(sc, RT2860_S |
		    (((addr >> n) & 1) << RT2860_SHIFT_D));
		RT2860_EEPROM_CTL(sc, RT2860_S |
		    (((addr >> n) & 1) << RT2860_SHIFT_D) | RT2860_C);
	}

	RT2860_EEPROM_CTL(sc, RT2860_S);

	/* read data Q15-Q0 */
	val = 0;
	for (n = 15; n >= 0; n--) {
		RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_C);
		tmp = RAL_READ(sc, RT2860_PCI_EECTRL);
		val |= ((tmp & RT2860_Q) >> RT2860_SHIFT_Q) << n;
		RT2860_EEPROM_CTL(sc, RT2860_S);
	}

	RT2860_EEPROM_CTL(sc, 0);

	/* clear Chip Select and clock C */
	RT2860_EEPROM_CTL(sc, RT2860_S);
	RT2860_EEPROM_CTL(sc, 0);
	RT2860_EEPROM_CTL(sc, RT2860_C);

	return val;
}

static __inline uint16_t
rt2860_srom_read(struct rt2860_softc *sc, uint8_t addr)
{
	/* either eFUSE ROM or EEPROM */
	return sc->sc_srom_read(sc, addr);
}

void
rt2860_intr_coherent(struct rt2860_softc *sc)
{
	uint32_t tmp;

	/* DMA finds data coherent event when checking the DDONE bit */

	DPRINTF(("Tx/Rx Coherent interrupt\n"));

	/* restart DMA engine */
	tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);
	tmp &= ~(RT2860_TX_WB_DDONE | RT2860_RX_DMA_EN | RT2860_TX_DMA_EN);
	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);

	(void)rt2860_txrx_enable(sc);
}

void
rt2860_drain_stats_fifo(struct rt2860_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct ieee80211_amrr_node *amn;
	uint32_t stat;
	uint8_t wcid, mcs, pid;

	/* drain Tx status FIFO (maxsize = 16) */
	while ((stat = RAL_READ(sc, RT2860_TX_STAT_FIFO)) & RT2860_TXQ_VLD) {
		DPRINTFN(4, ("tx stat 0x%08x\n", stat));

		wcid = (stat >> RT2860_TXQ_WCID_SHIFT) & 0xff;

		/* if no ACK was requested, no feedback is available */
		if (!(stat & RT2860_TXQ_ACKREQ) || wcid == 0xff)
			continue;

		/* update per-STA AMRR stats */
		amn = &sc->amn[wcid];
		amn->amn_txcnt++;
		if (stat & RT2860_TXQ_OK) {
			/*
			 * Check if there were retries, ie if the Tx success
			 * rate is different from the requested rate.  Note
			 * that it works only because we do not allow rate
			 * fallback from OFDM to CCK.
			 */
			mcs = (stat >> RT2860_TXQ_MCS_SHIFT) & 0x7f;
			pid = (stat >> RT2860_TXQ_PID_SHIFT) & 0xf;
			if (mcs + 1 != pid)
				amn->amn_retrycnt++;
		} else {
			amn->amn_retrycnt++;
			ifp->if_oerrors++;
		}
	}
}

void
rt2860_tx_intr(struct rt2860_softc *sc, int qid)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct rt2860_tx_ring *ring = &sc->txq[qid];
	uint32_t hw;

	rt2860_drain_stats_fifo(sc);

	hw = RAL_READ(sc, RT2860_TX_DTX_IDX(qid));
	while (ring->next != hw) {
		struct rt2860_tx_data *data = ring->data[ring->next];

		if (data != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m= NULL;
			ieee80211_release_node(ic, data->ni);
			data->ni = NULL;

			SLIST_INSERT_HEAD(&sc->data_pool, data, next);
			ring->data[ring->next] = NULL;
		}
		ring->queued--;
		ring->next = (ring->next + 1) % RT2860_TX_RING_COUNT;
	}

	sc->sc_tx_timer = 0;
	if (ring->queued <= RT2860_TX_RING_ONEMORE)
		sc->qfullmsk &= ~(1 << qid);
	ifq_clr_oactive(&ifp->if_snd);
	rt2860_start(ifp);
}

/*
 * Return the Rx chain with the highest RSSI for a given frame.
 */
static __inline uint8_t
rt2860_maxrssi_chain(struct rt2860_softc *sc, const struct rt2860_rxwi *rxwi)
{
	uint8_t rxchain = 0;

	if (sc->nrxchains > 1) {
		if (rxwi->rssi[1] > rxwi->rssi[rxchain])
			rxchain = 1;
		if (sc->nrxchains > 2)
			if (rxwi->rssi[2] > rxwi->rssi[rxchain])
				rxchain = 2;
	}
	return rxchain;
}

void
rt2860_rx_intr(struct rt2860_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *m, *m1;
	uint32_t hw;
	uint8_t ant, rssi;
	int error;
#if NBPFILTER > 0
	struct rt2860_rx_radiotap_header *tap;
	struct mbuf mb;
	uint16_t phy;
#endif

	hw = RAL_READ(sc, RT2860_FS_DRX_IDX) & 0xfff;
	while (sc->rxq.cur != hw) {
		struct rt2860_rx_data *data = &sc->rxq.data[sc->rxq.cur];
		struct rt2860_rxd *rxd = &sc->rxq.rxd[sc->rxq.cur];
		struct rt2860_rxwi *rxwi;

		bus_dmamap_sync(sc->sc_dmat, sc->rxq.map,
		    sc->rxq.cur * sizeof (struct rt2860_rxd),
		    sizeof (struct rt2860_rxd), BUS_DMASYNC_POSTREAD);

		if (__predict_false(!(rxd->sdl0 & htole16(RT2860_RX_DDONE)))) {
			DPRINTF(("RXD DDONE bit not set!\n"));
			break;	/* should not happen */
		}

		if (__predict_false(rxd->flags &
		    htole32(RT2860_RX_CRCERR | RT2860_RX_ICVERR))) {
			ifp->if_ierrors++;
			goto skip;
		}

		if (__predict_false(rxd->flags & htole32(RT2860_RX_MICERR))) {
			/* report MIC failures to net80211 for TKIP */
			ic->ic_stats.is_rx_locmicfail++;
			ieee80211_michael_mic_failure(ic, 0/* XXX */);
			ifp->if_ierrors++;
			goto skip;
		}

		m1 = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
		if (__predict_false(m1 == NULL)) {
			ifp->if_ierrors++;
			goto skip;
		}

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmat, data->map);

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(m1, void *), MCLBYTES, NULL,
		    BUS_DMA_READ | BUS_DMA_NOWAIT);
		if (__predict_false(error != 0)) {
			m_freem(m1);

			/* try to reload the old mbuf */
			error = bus_dmamap_load(sc->sc_dmat, data->map,
			    mtod(data->m, void *), MCLBYTES, NULL,
			    BUS_DMA_READ | BUS_DMA_NOWAIT);
			if (__predict_false(error != 0)) {
				panic("%s: could not load old rx mbuf",
				    sc->sc_dev.dv_xname);
			}
			/* physical address may have changed */
			rxd->sdp0 = htole32(data->map->dm_segs[0].ds_addr);
			ifp->if_ierrors++;
			goto skip;
		}

		/*
		 * New mbuf successfully loaded, update Rx ring and continue
		 * processing.
		 */
		m = data->m;
		data->m = m1;
		rxd->sdp0 = htole32(data->map->dm_segs[0].ds_addr);

		rxwi = mtod(m, struct rt2860_rxwi *);

		/* finalize mbuf */
		m->m_data = (caddr_t)(rxwi + 1);
		m->m_pkthdr.len = m->m_len = letoh16(rxwi->len) & 0xfff;

		wh = mtod(m, struct ieee80211_frame *);
		rxi.rxi_flags = 0;
		if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
			/* frame is decrypted by hardware */
			wh->i_fc[1] &= ~IEEE80211_FC1_PROTECTED;
			rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
		}

		/* HW may insert 2 padding bytes after 802.11 header */
		if (rxd->flags & htole32(RT2860_RX_L2PAD)) {
			u_int hdrlen = ieee80211_get_hdrlen(wh);
			memmove((caddr_t)wh + 2, wh, hdrlen);
			m->m_data += 2;
			wh = mtod(m, struct ieee80211_frame *);
		}

		ant = rt2860_maxrssi_chain(sc, rxwi);
		rssi = rxwi->rssi[ant];

#if NBPFILTER > 0
		if (__predict_true(sc->sc_drvbpf == NULL))
			goto skipbpf;

		tap = &sc->sc_rxtap;
		tap->wr_flags = 0;
		tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
		tap->wr_antsignal = rssi;
		tap->wr_antenna = ant;
		tap->wr_dbm_antsignal = rt2860_rssi2dbm(sc, rssi, ant);
		tap->wr_rate = 2;	/* in case it can't be found below */
		phy = letoh16(rxwi->phy);
		switch (phy & RT2860_PHY_MODE) {
		case RT2860_PHY_CCK:
			switch ((phy & RT2860_PHY_MCS) & ~RT2860_PHY_SHPRE) {
			case 0:	tap->wr_rate =   2; break;
			case 1:	tap->wr_rate =   4; break;
			case 2:	tap->wr_rate =  11; break;
			case 3:	tap->wr_rate =  22; break;
			}
			if (phy & RT2860_PHY_SHPRE)
				tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
			break;
		case RT2860_PHY_OFDM:
			switch (phy & RT2860_PHY_MCS) {
			case 0:	tap->wr_rate =  12; break;
			case 1:	tap->wr_rate =  18; break;
			case 2:	tap->wr_rate =  24; break;
			case 3:	tap->wr_rate =  36; break;
			case 4:	tap->wr_rate =  48; break;
			case 5:	tap->wr_rate =  72; break;
			case 6:	tap->wr_rate =  96; break;
			case 7:	tap->wr_rate = 108; break;
			}
			break;
		}
		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
skipbpf:
#endif
		/* grab a reference to the source node */
		ni = ieee80211_find_rxnode(ic, wh);

		/* send the frame to the 802.11 layer */
		rxi.rxi_rssi = rssi;
		rxi.rxi_tstamp = 0;	/* unused */
		ieee80211_input(ifp, m, ni, &rxi);

		/* node is no longer needed */
		ieee80211_release_node(ic, ni);

skip:		rxd->sdl0 &= ~htole16(RT2860_RX_DDONE);

		bus_dmamap_sync(sc->sc_dmat, sc->rxq.map,
		    sc->rxq.cur * sizeof (struct rt2860_rxd),
		    sizeof (struct rt2860_rxd), BUS_DMASYNC_PREWRITE);

		sc->rxq.cur = (sc->rxq.cur + 1) % RT2860_RX_RING_COUNT;
	}

	/* tell HW what we have processed */
	RAL_WRITE(sc, RT2860_RX_CALC_IDX,
	    (sc->rxq.cur - 1) % RT2860_RX_RING_COUNT);
}

void
rt2860_tbtt_intr(struct rt2860_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
		/* one less beacon until next DTIM */
		if (ic->ic_dtim_count == 0)
			ic->ic_dtim_count = ic->ic_dtim_period - 1;
		else
			ic->ic_dtim_count--;

		/* update dynamic parts of beacon */
		rt2860_setup_beacon(sc);

		/* flush buffered multicast frames */
		if (ic->ic_dtim_count == 0)
			ieee80211_notify_dtim(ic);
	}
#endif
	/* check if protection mode has changed */
	if ((sc->sc_ic_flags ^ ic->ic_flags) & IEEE80211_F_USEPROT) {
		rt2860_updateprot(ic);
		sc->sc_ic_flags = ic->ic_flags;
	}
}

void
rt2860_gp_intr(struct rt2860_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	DPRINTFN(2, ("GP timeout state=%d\n", ic->ic_state));

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(&ic->ic_if);
	else if (ic->ic_state == IEEE80211_S_RUN)
		rt2860_updatestats(sc);
}

int
rt2860_intr(void *arg)
{
	struct rt2860_softc *sc = arg;
	uint32_t r;

	r = RAL_READ(sc, RT2860_INT_STATUS);
	if (__predict_false(r == 0xffffffff))
		return 0;	/* device likely went away */
	if (r == 0)
		return 0;	/* not for us */

	/* acknowledge interrupts */
	RAL_WRITE(sc, RT2860_INT_STATUS, r);

	if (r & RT2860_TX_RX_COHERENT)
		rt2860_intr_coherent(sc);

	if (r & RT2860_MAC_INT_2)	/* TX status */
		rt2860_drain_stats_fifo(sc);

	if (r & RT2860_TX_DONE_INT5)
		rt2860_tx_intr(sc, 5);

	if (r & RT2860_RX_DONE_INT)
		rt2860_rx_intr(sc);

	if (r & RT2860_TX_DONE_INT4)
		rt2860_tx_intr(sc, 4);

	if (r & RT2860_TX_DONE_INT3)
		rt2860_tx_intr(sc, 3);

	if (r & RT2860_TX_DONE_INT2)
		rt2860_tx_intr(sc, 2);

	if (r & RT2860_TX_DONE_INT1)
		rt2860_tx_intr(sc, 1);

	if (r & RT2860_TX_DONE_INT0)
		rt2860_tx_intr(sc, 0);

	if (r & RT2860_MAC_INT_0)	/* TBTT */
		rt2860_tbtt_intr(sc);

	if (r & RT2860_MAC_INT_3)	/* Auto wakeup */
		/* TBD wakeup */;

	if (r & RT2860_MAC_INT_4)	/* GP timer */
		rt2860_gp_intr(sc);

	return 1;
}

int
rt2860_tx(struct rt2860_softc *sc, struct mbuf *m, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rt2860_node *rn = (void *)ni;
	struct rt2860_tx_ring *ring;
	struct rt2860_tx_data *data;
	struct rt2860_txd *txd;
	struct rt2860_txwi *txwi;
	struct ieee80211_frame *wh;
	bus_dma_segment_t *seg;
	u_int hdrlen;
	uint16_t qos, dur;
	uint8_t type, qsel, mcs, pid, tid, qid;
	int nsegs, hasqos, ridx, ctl_ridx;

	/* the data pool contains at least one element, pick the first */
	data = SLIST_FIRST(&sc->data_pool);

	wh = mtod(m, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;

	if ((hasqos = ieee80211_has_qos(wh))) {
		qos = ieee80211_get_qos(wh);
		tid = qos & IEEE80211_QOS_TID;
		qid = ieee80211_up_to_ac(ic, tid);
	} else {
		qos = 0;
		tid = 0;
		qid = (type == IEEE80211_FC0_TYPE_MGT) ?
		    sc->mgtqid : EDCA_AC_BE;
	}
	ring = &sc->txq[qid];

	/* pickup a rate index */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    type != IEEE80211_FC0_TYPE_DATA) {
		ridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
		    RT2860_RIDX_OFDM6 : RT2860_RIDX_CCK1;
		ctl_ridx = rt2860_rates[ridx].ctl_ridx;
	} else if (ic->ic_fixed_rate != -1) {
		ridx = sc->fixed_ridx;
		ctl_ridx = rt2860_rates[ridx].ctl_ridx;
	} else {
		ridx = rn->ridx[ni->ni_txrate];
		ctl_ridx = rn->ctl_ridx[ni->ni_txrate];
	}

	/* get MCS code from rate index */
	mcs = rt2860_rates[ridx].mcs;

	/* setup TX Wireless Information */
	txwi = data->txwi;
	txwi->flags = 0;
	/* let HW generate seq numbers for non-QoS frames */
	txwi->xflags = hasqos ? 0 : RT2860_TX_NSEQ;
	txwi->wcid = (type == IEEE80211_FC0_TYPE_DATA) ? rn->wcid : 0xff;
	txwi->len = htole16(m->m_pkthdr.len);
	if (rt2860_rates[ridx].phy == IEEE80211_T_DS) {
		txwi->phy = htole16(RT2860_PHY_CCK);
		if (ridx != RT2860_RIDX_CCK1 &&
		    (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
			mcs |= RT2860_PHY_SHPRE;
	} else
		txwi->phy = htole16(RT2860_PHY_OFDM);
	txwi->phy |= htole16(mcs);

	/*
	 * We store the MCS code into the driver-private PacketID field.
	 * The PacketID is latched into TX_STAT_FIFO when Tx completes so
	 * that we know at which initial rate the frame was transmitted.
	 * We add 1 to the MCS code because setting the PacketID field to
	 * 0 means that we don't want feedback in TX_STAT_FIFO.
	 */
	pid = (mcs + 1) & 0xf;
	txwi->len |= htole16(pid << RT2860_TX_PID_SHIFT);

	/* check if RTS/CTS or CTS-to-self protection is required */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (m->m_pkthdr.len + IEEE80211_CRC_LEN > ic->ic_rtsthreshold ||
	     ((ic->ic_flags & IEEE80211_F_USEPROT) &&
	      rt2860_rates[ridx].phy == IEEE80211_T_OFDM)))
		txwi->txop = RT2860_TX_TXOP_HT;
	else
		txwi->txop = RT2860_TX_TXOP_BACKOFF;

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (!hasqos || (qos & IEEE80211_QOS_ACK_POLICY_MASK) !=
	     IEEE80211_QOS_ACK_POLICY_NOACK)) {
		txwi->xflags |= RT2860_TX_ACK;

		if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
			dur = rt2860_rates[ctl_ridx].sp_ack_dur;
		else
			dur = rt2860_rates[ctl_ridx].lp_ack_dur;
		*(uint16_t *)wh->i_dur = htole16(dur);
	}
#ifndef IEEE80211_STA_ONLY
	/* ask MAC to insert timestamp into probe responses */
	if ((wh->i_fc[0] &
	     (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
	     (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
	    /* NOTE: beacons do not pass through tx_data() */
		txwi->flags |= RT2860_TX_TS;
#endif

#if NBPFILTER > 0
	if (__predict_false(sc->sc_drvbpf != NULL)) {
		struct rt2860_tx_radiotap_header *tap = &sc->sc_txtap;
		struct mbuf mb;

		tap->wt_flags = 0;
		tap->wt_rate = rt2860_rates[ridx].rate;
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
		tap->wt_hwqueue = qid;
		if (mcs & RT2860_PHY_SHPRE)
			tap->wt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	/* copy and trim 802.11 header */
	memcpy(txwi + 1, wh, hdrlen);
	m_adj(m, hdrlen);

	KASSERT (ring->queued <= RT2860_TX_RING_ONEMORE); /* <1> */

	if (bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m, BUS_DMA_NOWAIT)) {
		if (m_defrag(m, M_DONTWAIT))
			return (ENOBUFS);
		if (bus_dmamap_load_mbuf(sc->sc_dmat,
		    data->map, m, BUS_DMA_NOWAIT))
			return (EFBIG);
	}

	/* The map will fit into the tx ring: (a "full" ring may have a few
	 * unused descriptors, at most (txds(MAX_SCATTER) - 1))
	 *
	 *   ring->queued + txds(data->map->nsegs)
	 * <=	{ <0> data->map->nsegs <= MAX_SCATTER }
	 *   ring->queued + txds(MAX_SCATTER)
	 * <=	{ <1> ring->queued <= TX_RING_MAX - txds(MAX_SCATTER) }
	 *   TX_RING_MAX - txds(MAX_SCATTER) + txds(MAX_SCATTER)
	 * <=   { arithmetic }
	 *   TX_RING_MAX
	 */

	qsel = (qid < EDCA_NUM_AC) ? RT2860_TX_QSEL_EDCA : RT2860_TX_QSEL_MGMT;

	/* first segment is TXWI + 802.11 header */
	txd = &ring->txd[ring->cur];
	txd->sdp0 = htole32(data->paddr);
	txd->sdl0 = htole16(sizeof (struct rt2860_txwi) + hdrlen);
	txd->flags = qsel;

	/* setup payload segments */
	seg = data->map->dm_segs;
	for (nsegs = data->map->dm_nsegs; nsegs >= 2; nsegs -= 2) {
		txd->sdp1 = htole32(seg->ds_addr);
		txd->sdl1 = htole16(seg->ds_len);
		seg++;
		ring->cur = (ring->cur + 1) % RT2860_TX_RING_COUNT;
		/* grab a new Tx descriptor */
		txd = &ring->txd[ring->cur];
		txd->sdp0 = htole32(seg->ds_addr);
		txd->sdl0 = htole16(seg->ds_len);
		txd->flags = qsel;
		seg++;
	}
	/* finalize last segment */
	if (nsegs > 0) {
		txd->sdp1 = htole32(seg->ds_addr);
		txd->sdl1 = htole16(seg->ds_len | RT2860_TX_LS1);
	} else {
		txd->sdl0 |= htole16(RT2860_TX_LS0);
		txd->sdl1 = 0;
	}

	/* remove from the free pool and link it into the SW Tx slot */
	SLIST_REMOVE_HEAD(&sc->data_pool, next);
	data->m = m;
	data->ni = ni;
	ring->data[ring->cur] = data;

	bus_dmamap_sync(sc->sc_dmat, sc->txwi_map,
	    (caddr_t)txwi - sc->txwi_vaddr, RT2860_TXWI_DMASZ,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	DPRINTFN(4, ("sending frame qid=%d wcid=%d nsegs=%d ridx=%d\n",
	    qid, txwi->wcid, data->map->dm_nsegs, ridx));

	ring->cur = (ring->cur + 1) % RT2860_TX_RING_COUNT;
	ring->queued += 1 + (data->map->dm_nsegs / 2);
	if (ring->queued > RT2860_TX_RING_ONEMORE)
		sc->qfullmsk |= 1 << qid;

	/* kick Tx */
	RAL_WRITE(sc, RT2860_TX_CTX_IDX(qid), ring->cur);

	return 0;
}

void
rt2860_start(struct ifnet *ifp)
{
	struct rt2860_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (SLIST_EMPTY(&sc->data_pool) || sc->qfullmsk != 0) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		/* send pending management frames first */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}
		if (ic->ic_state != IEEE80211_S_RUN)
			break;

		/* send buffered frames for power-save mode */
		m = mq_dequeue(&ic->ic_pwrsaveq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}

		/* encapsulate and send data frames */
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		if ((m = ieee80211_encap(ifp, m, &ni)) == NULL)
			continue;
sendit:
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		if (rt2860_tx(sc, m, ni) != 0) {
			m_freem(m);
			ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
rt2860_watchdog(struct ifnet *ifp)
{
	struct rt2860_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			rt2860_stop(ifp, 0);
			rt2860_init(ifp);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
rt2860_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct rt2860_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING))
				rt2860_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				rt2860_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCS80211CHANNEL:
		/*
		 * This allows for fast channel switching in monitor mode
		 * (used by kismet). In IBSS mode, we must explicitly reset
		 * the interface to generate a new beacon frame.
		 */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING))
				rt2860_switch_chan(sc, ic->ic_ibss_chan);
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING)) {
			rt2860_stop(ifp, 0);
			rt2860_init(ifp);
		}
		error = 0;
	}

	splx(s);

	return error;
}

/*
 * Reading and writing from/to the BBP is different from RT2560 and RT2661.
 * We access the BBP through the 8051 microcontroller unit which means that
 * the microcode must be loaded first.
 */
void
rt2860_mcu_bbp_write(struct rt2860_softc *sc, uint8_t reg, uint8_t val)
{
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2860_H2M_BBPAGENT) & RT2860_BBP_CSR_KICK))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not write to BBP through MCU\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	RAL_WRITE(sc, RT2860_H2M_BBPAGENT, RT2860_BBP_RW_PARALLEL |
	    RT2860_BBP_CSR_KICK | reg << 8 | val);
	RAL_BARRIER_WRITE(sc);

	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_BBP, 0, 0);
	DELAY(1000);
}

uint8_t
rt2860_mcu_bbp_read(struct rt2860_softc *sc, uint8_t reg)
{
	uint32_t val;
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2860_H2M_BBPAGENT) & RT2860_BBP_CSR_KICK))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not read from BBP through MCU\n",
		    sc->sc_dev.dv_xname);
		return 0;
	}

	RAL_WRITE(sc, RT2860_H2M_BBPAGENT, RT2860_BBP_RW_PARALLEL |
	    RT2860_BBP_CSR_KICK | RT2860_BBP_CSR_READ | reg << 8);
	RAL_BARRIER_WRITE(sc);

	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_BBP, 0, 0);
	DELAY(1000);

	for (ntries = 0; ntries < 100; ntries++) {
		val = RAL_READ(sc, RT2860_H2M_BBPAGENT);
		if (!(val & RT2860_BBP_CSR_KICK))
			return val & 0xff;
		DELAY(1);
	}
	printf("%s: could not read from BBP through MCU\n",
	    sc->sc_dev.dv_xname);

	return 0;
}

/*
 * Write to one of the 4 programmable 24-bit RF registers.
 */
void
rt2860_rf_write(struct rt2860_softc *sc, uint8_t reg, uint32_t val)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2860_RF_CSR_CFG0) & RT2860_RF_REG_CTRL))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not write to RF\n", sc->sc_dev.dv_xname);
		return;
	}

	/* RF registers are 24-bit on the RT2860 */
	tmp = RT2860_RF_REG_CTRL | 24 << RT2860_RF_REG_WIDTH_SHIFT |
	    (val & 0x3fffff) << 2 | (reg & 3);
	RAL_WRITE(sc, RT2860_RF_CSR_CFG0, tmp);
}

uint8_t
rt3090_rf_read(struct rt2860_softc *sc, uint8_t reg)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT3070_RF_CSR_CFG) & RT3070_RF_KICK))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not read RF register\n",
		    sc->sc_dev.dv_xname);
		return 0xff;
	}
	tmp = RT3070_RF_KICK | reg << 8;
	RAL_WRITE(sc, RT3070_RF_CSR_CFG, tmp);

	for (ntries = 0; ntries < 100; ntries++) {
		tmp = RAL_READ(sc, RT3070_RF_CSR_CFG);
		if (!(tmp & RT3070_RF_KICK))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not read RF register\n",
		    sc->sc_dev.dv_xname);
		return 0xff;
	}
	return tmp & 0xff;
}

void
rt3090_rf_write(struct rt2860_softc *sc, uint8_t reg, uint8_t val)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 10; ntries++) {
		if (!(RAL_READ(sc, RT3070_RF_CSR_CFG) & RT3070_RF_KICK))
			break;
		DELAY(10);
	}
	if (ntries == 10) {
		printf("%s: could not write to RF\n", sc->sc_dev.dv_xname);
		return;
	}

	tmp = RT3070_RF_WRITE | RT3070_RF_KICK | reg << 8 | val;
	RAL_WRITE(sc, RT3070_RF_CSR_CFG, tmp);
}

/*
 * Send a command to the 8051 microcontroller unit.
 */
int
rt2860_mcu_cmd(struct rt2860_softc *sc, uint8_t cmd, uint16_t arg, int wait)
{
	int slot, ntries;
	uint32_t tmp;
	uint8_t cid;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2860_H2M_MAILBOX) & RT2860_H2M_BUSY))
			break;
		DELAY(2);
	}
	if (ntries == 100)
		return EIO;

	cid = wait ? cmd : RT2860_TOKEN_NO_INTR;
	RAL_WRITE(sc, RT2860_H2M_MAILBOX, RT2860_H2M_BUSY | cid << 16 | arg);
	RAL_BARRIER_WRITE(sc);
	RAL_WRITE(sc, RT2860_HOST_CMD, cmd);

	if (!wait)
		return 0;
	/* wait for the command to complete */
	for (ntries = 0; ntries < 200; ntries++) {
		tmp = RAL_READ(sc, RT2860_H2M_MAILBOX_CID);
		/* find the command slot */
		for (slot = 0; slot < 4; slot++, tmp >>= 8)
			if ((tmp & 0xff) == cid)
				break;
		if (slot < 4)
			break;
		DELAY(100);
	}
	if (ntries == 200) {
		/* clear command and status */
		RAL_WRITE(sc, RT2860_H2M_MAILBOX_STATUS, 0xffffffff);
		RAL_WRITE(sc, RT2860_H2M_MAILBOX_CID, 0xffffffff);
		return ETIMEDOUT;
	}
	/* get command status (1 means success) */
	tmp = RAL_READ(sc, RT2860_H2M_MAILBOX_STATUS);
	tmp = (tmp >> (slot * 8)) & 0xff;
	DPRINTF(("MCU command=0x%02x slot=%d status=0x%02x\n",
	    cmd, slot, tmp));
	/* clear command and status */
	RAL_WRITE(sc, RT2860_H2M_MAILBOX_STATUS, 0xffffffff);
	RAL_WRITE(sc, RT2860_H2M_MAILBOX_CID, 0xffffffff);
	return (tmp == 1) ? 0 : EIO;
}

void
rt2860_enable_mrr(struct rt2860_softc *sc)
{
#define CCK(mcs)	(mcs)
#define OFDM(mcs)	(1 << 3 | (mcs))
	RAL_WRITE(sc, RT2860_LG_FBK_CFG0,
	    OFDM(6) << 28 |	/* 54->48 */
	    OFDM(5) << 24 |	/* 48->36 */
	    OFDM(4) << 20 |	/* 36->24 */
	    OFDM(3) << 16 |	/* 24->18 */
	    OFDM(2) << 12 |	/* 18->12 */
	    OFDM(1) <<  8 |	/* 12-> 9 */
	    OFDM(0) <<  4 |	/*  9-> 6 */
	    OFDM(0));		/*  6-> 6 */

	RAL_WRITE(sc, RT2860_LG_FBK_CFG1,
	    CCK(2) << 12 |	/* 11->5.5 */
	    CCK(1) <<  8 |	/* 5.5-> 2 */
	    CCK(0) <<  4 |	/*   2-> 1 */
	    CCK(0));		/*   1-> 1 */
#undef OFDM
#undef CCK
}

void
rt2860_set_txpreamble(struct rt2860_softc *sc)
{
	uint32_t tmp;

	tmp = RAL_READ(sc, RT2860_AUTO_RSP_CFG);
	tmp &= ~RT2860_CCK_SHORT_EN;
	if (sc->sc_ic.ic_flags & IEEE80211_F_SHPREAMBLE)
		tmp |= RT2860_CCK_SHORT_EN;
	RAL_WRITE(sc, RT2860_AUTO_RSP_CFG, tmp);
}

void
rt2860_set_basicrates(struct rt2860_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	/* set basic rates mask */
	if (ic->ic_curmode == IEEE80211_MODE_11B)
		RAL_WRITE(sc, RT2860_LEGACY_BASIC_RATE, 0x003);
	else if (ic->ic_curmode == IEEE80211_MODE_11A)
		RAL_WRITE(sc, RT2860_LEGACY_BASIC_RATE, 0x150);
	else	/* 11g */
		RAL_WRITE(sc, RT2860_LEGACY_BASIC_RATE, 0x15f);
}

void
rt2860_select_chan_group(struct rt2860_softc *sc, int group)
{
	uint32_t tmp;
	uint8_t agc;

	/* Wait for BBP to settle */
	DELAY(1000);

	rt2860_mcu_bbp_write(sc, 62, 0x37 - sc->lna[group]);
	rt2860_mcu_bbp_write(sc, 63, 0x37 - sc->lna[group]);
	rt2860_mcu_bbp_write(sc, 64, 0x37 - sc->lna[group]);
	rt2860_mcu_bbp_write(sc, 86, 0x00);

	if (group == 0) {
		if (sc->ext_2ghz_lna) {
			rt2860_mcu_bbp_write(sc, 82, 0x62);
			rt2860_mcu_bbp_write(sc, 75, 0x46);
		} else {
			rt2860_mcu_bbp_write(sc, 82, 0x84);
			rt2860_mcu_bbp_write(sc, 75, 0x50);
		}
	} else {
		if (sc->mac_ver == 0x3572)
			rt2860_mcu_bbp_write(sc, 82, 0x94);
		else
			rt2860_mcu_bbp_write(sc, 82, 0xf2);

		if (sc->ext_5ghz_lna)
			rt2860_mcu_bbp_write(sc, 75, 0x46);
		else
			rt2860_mcu_bbp_write(sc, 75, 0x50);
	}

	tmp = RAL_READ(sc, RT2860_TX_BAND_CFG);
	tmp &= ~(RT2860_5G_BAND_SEL_N | RT2860_5G_BAND_SEL_P);
	tmp |= (group == 0) ? RT2860_5G_BAND_SEL_N : RT2860_5G_BAND_SEL_P;
	RAL_WRITE(sc, RT2860_TX_BAND_CFG, tmp);

	/* enable appropriate Power Amplifiers and Low Noise Amplifiers */
	tmp = RT2860_RFTR_EN | RT2860_TRSW_EN | RT2860_LNA_PE0_EN;
	if (sc->nrxchains > 1)
		tmp |= RT2860_LNA_PE1_EN;
	if (sc->mac_ver == 0x3593 && sc->nrxchains > 2)
		tmp |= RT3593_LNA_PE2_EN;
	if (group == 0) {	/* 2GHz */
		tmp |= RT2860_PA_PE_G0_EN;
		if (sc->ntxchains > 1)
			tmp |= RT2860_PA_PE_G1_EN;
		if (sc->mac_ver == 0x3593 && sc->ntxchains > 2)
			tmp |= RT3593_PA_PE_G2_EN;
	} else {		/* 5GHz */
		tmp |= RT2860_PA_PE_A0_EN;
		if (sc->ntxchains > 1)
			tmp |= RT2860_PA_PE_A1_EN;
		if (sc->mac_ver == 0x3593 && sc->ntxchains > 2)
			tmp |= RT3593_PA_PE_A2_EN;
	}
	if (sc->mac_ver == 0x3572) {
		rt3090_rf_write(sc, 8, 0x00);
		RAL_WRITE(sc, RT2860_TX_PIN_CFG, tmp);
		rt3090_rf_write(sc, 8, 0x80);
	} else
		RAL_WRITE(sc, RT2860_TX_PIN_CFG, tmp);

	if (sc->mac_ver == 0x3593) {
		tmp = RAL_READ(sc, RT2860_GPIO_CTRL);
		if (sc->sc_flags & RT2860_PCIE) {
			tmp &= ~0x01010000;
			if (group == 0)
				tmp |= 0x00010000;
		} else {
			tmp &= ~0x00008080;
			if (group == 0)
				tmp |= 0x00000080;
		}
		tmp = (tmp & ~0x00001000) | 0x00000010;
		RAL_WRITE(sc, RT2860_GPIO_CTRL, tmp);
	}

	/* set initial AGC value */
	if (group == 0) {	/* 2GHz band */
		if (sc->mac_ver >= 0x3071)
			agc = 0x1c + sc->lna[0] * 2;
		else
			agc = 0x2e + sc->lna[0];
	} else {		/* 5GHz band */
		if (sc->mac_ver == 0x3572)
			agc = 0x22 + (sc->lna[group] * 5) / 3;
		else
			agc = 0x32 + (sc->lna[group] * 5) / 3;
	}
	rt2860_mcu_bbp_write(sc, 66, agc);

	DELAY(1000);
}

void
rt2860_set_chan(struct rt2860_softc *sc, u_int chan)
{
	const struct rfprog *rfprog = rt2860_rf2850;
	uint32_t r2, r3, r4;
	int8_t txpow1, txpow2;
	u_int i;

	/* find the settings for this channel (we know it exists) */
	for (i = 0; rfprog[i].chan != chan; i++);

	r2 = rfprog[i].r2;
	if (sc->ntxchains == 1)
		r2 |= 1 << 12;		/* 1T: disable Tx chain 2 */
	if (sc->nrxchains == 1)
		r2 |= 1 << 15 | 1 << 4;	/* 1R: disable Rx chains 2 & 3 */
	else if (sc->nrxchains == 2)
		r2 |= 1 << 4;		/* 2R: disable Rx chain 3 */

	/* use Tx power values from EEPROM */
	txpow1 = sc->txpow1[i];
	txpow2 = sc->txpow2[i];
	if (chan > 14) {
		if (txpow1 >= 0)
			txpow1 = txpow1 << 1 | 1;
		else
			txpow1 = (7 + txpow1) << 1;
		if (txpow2 >= 0)
			txpow2 = txpow2 << 1 | 1;
		else
			txpow2 = (7 + txpow2) << 1;
	}
	r3 = rfprog[i].r3 | txpow1 << 7;
	r4 = rfprog[i].r4 | sc->freq << 13 | txpow2 << 4;

	rt2860_rf_write(sc, RT2860_RF1, rfprog[i].r1);
	rt2860_rf_write(sc, RT2860_RF2, r2);
	rt2860_rf_write(sc, RT2860_RF3, r3);
	rt2860_rf_write(sc, RT2860_RF4, r4);

	DELAY(200);

	rt2860_rf_write(sc, RT2860_RF1, rfprog[i].r1);
	rt2860_rf_write(sc, RT2860_RF2, r2);
	rt2860_rf_write(sc, RT2860_RF3, r3 | 1);
	rt2860_rf_write(sc, RT2860_RF4, r4);

	DELAY(200);

	rt2860_rf_write(sc, RT2860_RF1, rfprog[i].r1);
	rt2860_rf_write(sc, RT2860_RF2, r2);
	rt2860_rf_write(sc, RT2860_RF3, r3);
	rt2860_rf_write(sc, RT2860_RF4, r4);
}

void
rt3090_set_chan(struct rt2860_softc *sc, u_int chan)
{
	int8_t txpow1, txpow2;
	uint8_t rf;
	int i;

	KASSERT(chan >= 1 && chan <= 14);	/* RT3090 is 2GHz only */

	/* find the settings for this channel (we know it exists) */
	for (i = 0; rt2860_rf2850[i].chan != chan; i++);

	/* use Tx power values from EEPROM */
	txpow1 = sc->txpow1[i];
	txpow2 = sc->txpow2[i];

	rt3090_rf_write(sc, 2, rt3090_freqs[i].n);
	rf = rt3090_rf_read(sc, 3);
	rf = (rf & ~0x0f) | rt3090_freqs[i].k;
	rt3090_rf_write(sc, 3, rf);
	rf = rt3090_rf_read(sc, 6);
	rf = (rf & ~0x03) | rt3090_freqs[i].r;
	rt3090_rf_write(sc, 6, rf);

	/* set Tx0 power */
	rf = rt3090_rf_read(sc, 12);
	rf = (rf & ~0x1f) | txpow1;
	rt3090_rf_write(sc, 12, rf);

	/* set Tx1 power */
	rf = rt3090_rf_read(sc, 13);
	rf = (rf & ~0x1f) | txpow2;
	rt3090_rf_write(sc, 13, rf);

	rf = rt3090_rf_read(sc, 1);
	rf &= ~0xfc;
	if (sc->ntxchains == 1)
		rf |= RT3070_TX1_PD | RT3070_TX2_PD;
	else if (sc->ntxchains == 2)
		rf |= RT3070_TX2_PD;
	if (sc->nrxchains == 1)
		rf |= RT3070_RX1_PD | RT3070_RX2_PD;
	else if (sc->nrxchains == 2)
		rf |= RT3070_RX2_PD;
	rt3090_rf_write(sc, 1, rf);

	/* set RF offset */
	rf = rt3090_rf_read(sc, 23);
	rf = (rf & ~0x7f) | sc->freq;
	rt3090_rf_write(sc, 23, rf);

	/* program RF filter */
	rf = rt3090_rf_read(sc, 24);	/* Tx */
	rf = (rf & ~0x3f) | sc->rf24_20mhz;
	rt3090_rf_write(sc, 24, rf);
	rf = rt3090_rf_read(sc, 31);	/* Rx */
	rf = (rf & ~0x3f) | sc->rf24_20mhz;
	rt3090_rf_write(sc, 31, rf);

	/* enable RF tuning */
	rf = rt3090_rf_read(sc, 7);
	rt3090_rf_write(sc, 7, rf | RT3070_TUNE);
}

void
rt5390_set_chan(struct rt2860_softc *sc, u_int chan)
{
	uint8_t h20mhz, rf, tmp;
	int8_t txpow1, txpow2;
	int i;

	/* RT5390 is 2GHz only */
	KASSERT(chan >= 1 && chan <= 14);

	/* find the settings for this channel (we know it exists) */
	for (i = 0; rt2860_rf2850[i].chan != chan; i++);

	/* use Tx power values from EEPROM */
	txpow1 = sc->txpow1[i];
	txpow2 = sc->txpow2[i];

	rt3090_rf_write(sc, 8, rt3090_freqs[i].n);
	rt3090_rf_write(sc, 9, rt3090_freqs[i].k & 0x0f);
	rf = rt3090_rf_read(sc, 11);
	rf = (rf & ~0x03) | (rt3090_freqs[i].r & 0x03);
	rt3090_rf_write(sc, 11, rf);

	rf = rt3090_rf_read(sc, 49);
	rf = (rf & ~0x3f) | (txpow1 & 0x3f);
	/* the valid range of the RF R49 is 0x00~0x27 */
	if ((rf & 0x3f) > 0x27)
		rf = (rf & ~0x3f) | 0x27;
	rt3090_rf_write(sc, 49, rf);
	if (sc->mac_ver == 0x5392) {
		rf = rt3090_rf_read(sc, 50);
		rf = (rf & ~0x3f) | (txpow2 & 0x3f);
		/* the valid range of the RF R50 is 0x00~0x27 */
		if ((rf & 0x3f) > 0x27)
			rf = (rf & ~0x3f) | 0x27;
		rt3090_rf_write(sc, 50, rf);
	}

	rf = rt3090_rf_read(sc, 1);
	rf |= RT3070_RF_BLOCK | RT3070_PLL_PD | RT3070_RX0_PD | RT3070_TX0_PD;
	if (sc->mac_ver == 0x5392)
		rf |= RT3070_RX1_PD | RT3070_TX1_PD;
	rt3090_rf_write(sc, 1, rf);

	rf = rt3090_rf_read(sc, 2);
	rt3090_rf_write(sc, 2, rf | RT3593_RESCAL);
	DELAY(1000);
	rt3090_rf_write(sc, 2, rf & ~RT3593_RESCAL);

	rf = rt3090_rf_read(sc, 17);
	tmp = rf;
	rf = (rf & ~0x7f) | (sc->freq & 0x7f);
	rf = MIN(rf, 0x5f);
	if (tmp != rf)
		rt2860_mcu_cmd(sc, 0x74, (tmp << 8 ) | rf, 0);

	if (sc->mac_ver == 0x5390) {
		if (chan <= 4)
			rf = 0x73;
		else if (chan >= 5 && chan <= 6)
			rf = 0x63;
		else if (chan >= 7 && chan <= 10)
			rf = 0x53;
		else
			rf = 43;
		rt3090_rf_write(sc, 55, rf);

		if (chan == 1)
			rf = 0x0c;
		else if (chan == 2)
			rf = 0x0b;
		else if (chan == 3)
			rf = 0x0a;
		else if (chan >= 4 && chan <= 6)
			rf = 0x09;
		else if (chan >= 7 && chan <= 12)
			rf = 0x08;
		else if (chan == 13)
			rf = 0x07;
		else
			rf = 0x06;
		rt3090_rf_write(sc, 59, rf);
	}

	/* Tx/Rx h20M */
	h20mhz = (sc->rf24_20mhz & 0x20) >> 5;
	rf = rt3090_rf_read(sc, 30);
	rf = (rf & ~0x06) | (h20mhz << 1) | (h20mhz << 2);
	rt3090_rf_write(sc, 30, rf);

	/* Rx BB filter VCM */
	rf = rt3090_rf_read(sc, 30);
	rf = (rf & ~0x18) | 0x10;
	rt3090_rf_write(sc, 30, rf);

	/* Initiate VCO calibration. */
	rf = rt3090_rf_read(sc, 3);
	rf |= RT3593_VCOCAL;
	rt3090_rf_write(sc, 3, rf);
}

int
rt3090_rf_init(struct rt2860_softc *sc)
{
	uint32_t tmp;
	uint8_t rf, bbp;
	int i;

	rf = rt3090_rf_read(sc, 30);
	/* toggle RF R30 bit 7 */
	rt3090_rf_write(sc, 30, rf | 0x80);
	DELAY(1000);
	rt3090_rf_write(sc, 30, rf & ~0x80);

	tmp = RAL_READ(sc, RT3070_LDO_CFG0);
	tmp &= ~0x1f000000;
	if (sc->patch_dac && sc->mac_rev < 0x0211)
		tmp |= 0x0d000000;	/* 1.35V */
	else
		tmp |= 0x01000000;	/* 1.2V */
	RAL_WRITE(sc, RT3070_LDO_CFG0, tmp);

	/* patch LNA_PE_G1 */
	tmp = RAL_READ(sc, RT3070_GPIO_SWITCH);
	RAL_WRITE(sc, RT3070_GPIO_SWITCH, tmp & ~0x20);

	/* initialize RF registers to default value */
	if (sc->mac_ver == 0x3572) {
		for (i = 0; i < nitems(rt3572_def_rf); i++) {
			rt3090_rf_write(sc, rt3572_def_rf[i].reg,
			    rt3572_def_rf[i].val);
		}
	} else {
		for (i = 0; i < nitems(rt3090_def_rf); i++) {
			rt3090_rf_write(sc, rt3090_def_rf[i].reg,
			    rt3090_def_rf[i].val);
		}
	}

	/* select 20MHz bandwidth */
	rt3090_rf_write(sc, 31, 0x14);

	rf = rt3090_rf_read(sc, 6);
	rt3090_rf_write(sc, 6, rf | 0x40);

	if (sc->mac_ver != 0x3593) {
		/* calibrate filter for 20MHz bandwidth */
		sc->rf24_20mhz = 0x1f;	/* default value */
		rt3090_filter_calib(sc, 0x07, 0x16, &sc->rf24_20mhz);

		/* select 40MHz bandwidth */
		bbp = rt2860_mcu_bbp_read(sc, 4);
		rt2860_mcu_bbp_write(sc, 4, (bbp & ~0x08) | 0x10);
		rf = rt3090_rf_read(sc, 31);
		rt3090_rf_write(sc, 31, rf | 0x20);

		/* calibrate filter for 40MHz bandwidth */
		sc->rf24_40mhz = 0x2f;	/* default value */
		rt3090_filter_calib(sc, 0x27, 0x19, &sc->rf24_40mhz);

		/* go back to 20MHz bandwidth */
		bbp = rt2860_mcu_bbp_read(sc, 4);
		rt2860_mcu_bbp_write(sc, 4, bbp & ~0x18);
	}
	if (sc->mac_rev < 0x0211)
		rt3090_rf_write(sc, 27, 0x03);

	tmp = RAL_READ(sc, RT3070_OPT_14);
	RAL_WRITE(sc, RT3070_OPT_14, tmp | 1);

	if (sc->rf_rev == RT3070_RF_3020)
		rt3090_set_rx_antenna(sc, 0);

	bbp = rt2860_mcu_bbp_read(sc, 138);
	if (sc->mac_ver == 0x3593) {
		if (sc->ntxchains == 1)
			bbp |= 0x60;	/* turn off DAC1 and DAC2 */
		else if (sc->ntxchains == 2)
			bbp |= 0x40;	/* turn off DAC2 */
		if (sc->nrxchains == 1)
			bbp &= ~0x06;	/* turn off ADC1 and ADC2 */
		else if (sc->nrxchains == 2)
			bbp &= ~0x04;	/* turn off ADC2 */
	} else {
		if (sc->ntxchains == 1)
			bbp |= 0x20;	/* turn off DAC1 */
		if (sc->nrxchains == 1)
			bbp &= ~0x02;	/* turn off ADC1 */
	}
	rt2860_mcu_bbp_write(sc, 138, bbp);

	rf = rt3090_rf_read(sc, 1);
	rf &= ~(RT3070_RX0_PD | RT3070_TX0_PD);
	rf |= RT3070_RF_BLOCK | RT3070_RX1_PD | RT3070_TX1_PD;
	rt3090_rf_write(sc, 1, rf);

	rf = rt3090_rf_read(sc, 15);
	rt3090_rf_write(sc, 15, rf & ~RT3070_TX_LO2);

	rf = rt3090_rf_read(sc, 17);
	rf &= ~RT3070_TX_LO1;
	if (sc->mac_rev >= 0x0211 && !sc->ext_2ghz_lna)
		rf |= 0x20;	/* fix for long range Rx issue */
	if (sc->txmixgain_2ghz >= 2)
		rf = (rf & ~0x7) | sc->txmixgain_2ghz;
	rt3090_rf_write(sc, 17, rf);

	rf = rt3090_rf_read(sc, 20);
	rt3090_rf_write(sc, 20, rf & ~RT3070_RX_LO1);

	rf = rt3090_rf_read(sc, 21);
	rt3090_rf_write(sc, 21, rf & ~RT3070_RX_LO2);

	return 0;
}

void
rt5390_rf_init(struct rt2860_softc *sc)
{
	uint8_t rf, bbp;
	int i;

	rf = rt3090_rf_read(sc, 2);
	/* Toggle RF R2 bit 7. */
	rt3090_rf_write(sc, 2, rf | RT3593_RESCAL);
	DELAY(1000);
	rt3090_rf_write(sc, 2, rf & ~RT3593_RESCAL);

	/* Initialize RF registers to default value. */
	if (sc->mac_ver == 0x5392) {
		for (i = 0; i < nitems(rt5392_def_rf); i++) {
			rt3090_rf_write(sc, rt5392_def_rf[i].reg,
			    rt5392_def_rf[i].val);
	 }
	} else {
		for (i = 0; i < nitems(rt5390_def_rf); i++) {
			rt3090_rf_write(sc, rt5390_def_rf[i].reg,
			    rt5390_def_rf[i].val);
		}
	}

	sc->rf24_20mhz = 0x1f;
	sc->rf24_40mhz = 0x2f;

	if (sc->mac_rev < 0x0211)
		rt3090_rf_write(sc, 27, 0x03);

	/* Set led open drain enable. */
	RAL_WRITE(sc, RT3070_OPT_14, RAL_READ(sc, RT3070_OPT_14) | 1);

	RAL_WRITE(sc, RT2860_TX_SW_CFG1, 0);
	RAL_WRITE(sc, RT2860_TX_SW_CFG2, 0);

	if (sc->mac_ver == 0x5390)
		rt3090_set_rx_antenna(sc, 0);

	/* Patch RSSI inaccurate issue. */
	rt2860_mcu_bbp_write(sc, 79, 0x13);
	rt2860_mcu_bbp_write(sc, 80, 0x05);
	rt2860_mcu_bbp_write(sc, 81, 0x33);

	/* Enable DC filter. */
	if (sc->mac_rev >= 0x0211)
		rt2860_mcu_bbp_write(sc, 103, 0xc0);

	bbp = rt2860_mcu_bbp_read(sc, 138);
	if (sc->ntxchains == 1)
		bbp |= 0x20;    /* Turn off DAC1. */
	if (sc->nrxchains == 1)
		bbp &= ~0x02;   /* Turn off ADC1. */
	rt2860_mcu_bbp_write(sc, 138, bbp);

	/* Enable RX LO1 and LO2. */
	rt3090_rf_write(sc, 38, rt3090_rf_read(sc, 38) & ~RT5390_RX_LO1);
	rt3090_rf_write(sc, 39, rt3090_rf_read(sc, 39) & ~RT5390_RX_LO2);

	/* Avoid data lost and CRC error. */
	rt2860_mcu_bbp_write(sc, 4,
	    rt2860_mcu_bbp_read(sc, 4) | RT5390_MAC_IF_CTRL);

	rf = rt3090_rf_read(sc, 30);
	rf = (rf & ~0x18) | 0x10;
	rt3090_rf_write(sc, 30, rf);

	/* Disable hardware antenna diversity. */
	if (sc->mac_ver == 0x5390)
		rt2860_mcu_bbp_write(sc, 154, 0);
}

void
rt3090_rf_wakeup(struct rt2860_softc *sc)
{
	uint32_t tmp;
	uint8_t rf;

	if (sc->mac_ver == 0x3593) {
		/* enable VCO */
		rf = rt3090_rf_read(sc, 1);
		rt3090_rf_write(sc, 1, rf | RT3593_VCO);

		/* initiate VCO calibration */
		rf = rt3090_rf_read(sc, 3);
		rt3090_rf_write(sc, 3, rf | RT3593_VCOCAL);

		/* enable VCO bias current control */
		rf = rt3090_rf_read(sc, 6);
		rt3090_rf_write(sc, 6, rf | RT3593_VCO_IC);

		/* initiate res calibration */
		rf = rt3090_rf_read(sc, 2);
		rt3090_rf_write(sc, 2, rf | RT3593_RESCAL);

		/* set reference current control to 0.33 mA */
		rf = rt3090_rf_read(sc, 22);
		rf &= ~RT3593_CP_IC_MASK;
		rf |= 1 << RT3593_CP_IC_SHIFT;
		rt3090_rf_write(sc, 22, rf);

		/* enable RX CTB */
		rf = rt3090_rf_read(sc, 46);
		rt3090_rf_write(sc, 46, rf | RT3593_RX_CTB);

		rf = rt3090_rf_read(sc, 20);
		rf &= ~(RT3593_LDO_RF_VC_MASK | RT3593_LDO_PLL_VC_MASK);
		rt3090_rf_write(sc, 20, rf);
	} else {
		/* enable RF block */
		rf = rt3090_rf_read(sc, 1);
		rt3090_rf_write(sc, 1, rf | RT3070_RF_BLOCK);

		/* enable VCO bias current control */
		rf = rt3090_rf_read(sc, 7);
		rt3090_rf_write(sc, 7, rf | 0x30);

		rf = rt3090_rf_read(sc, 9);
		rt3090_rf_write(sc, 9, rf | 0x0e);

		/* enable RX CTB */
		rf = rt3090_rf_read(sc, 21);
		rt3090_rf_write(sc, 21, rf | RT3070_RX_CTB);

		/* fix Tx to Rx IQ glitch by raising RF voltage */
		rf = rt3090_rf_read(sc, 27);
		rf &= ~0x77;
		if (sc->mac_rev < 0x0211)
			rf |= 0x03;
		rt3090_rf_write(sc, 27, rf);
	}
	if (sc->patch_dac && sc->mac_rev < 0x0211) {
		tmp = RAL_READ(sc, RT3070_LDO_CFG0);
		tmp = (tmp & ~0x1f000000) | 0x0d000000;
		RAL_WRITE(sc, RT3070_LDO_CFG0, tmp);
	}
}

void
rt5390_rf_wakeup(struct rt2860_softc *sc)
{
	uint32_t tmp;
	uint8_t rf;
	
	rf = rt3090_rf_read(sc, 1);
	rf |= RT3070_RF_BLOCK | RT3070_PLL_PD | RT3070_RX0_PD |
	    RT3070_TX0_PD;
	if (sc->mac_ver == 0x5392)
		rf |= RT3070_RX1_PD | RT3070_TX1_PD;
	rt3090_rf_write(sc, 1, rf);

	rf = rt3090_rf_read(sc, 6);
	rf |= RT3593_VCO_IC | RT3593_VCOCAL;
	if (sc->mac_ver == 0x5390)
		rf &= ~RT3593_VCO_IC;
	rt3090_rf_write(sc, 6, rf);

	rt3090_rf_write(sc, 2, rt3090_rf_read(sc, 2) | RT3593_RESCAL);

	rf = rt3090_rf_read(sc, 22);
	rf = (rf & ~0xe0) | 0x20;
	rt3090_rf_write(sc, 22, rf);

	rt3090_rf_write(sc, 42, rt3090_rf_read(sc, 42) | RT5390_RX_CTB);
	rt3090_rf_write(sc, 20, rt3090_rf_read(sc, 20) & ~0x77);
	rt3090_rf_write(sc, 3, rt3090_rf_read(sc, 3) | RT3593_VCOCAL);

	if (sc->patch_dac && sc->mac_rev < 0x0211) {
		tmp = RAL_READ(sc, RT3070_LDO_CFG0);
		tmp = (tmp & ~0x1f000000) | 0x0d000000;
		RAL_WRITE(sc, RT3070_LDO_CFG0, tmp);
	}
}

int
rt3090_filter_calib(struct rt2860_softc *sc, uint8_t init, uint8_t target,
    uint8_t *val)
{
	uint8_t rf22, rf24;
	uint8_t bbp55_pb, bbp55_sb, delta;
	int ntries;

	/* program filter */
	rf24 = rt3090_rf_read(sc, 24);
	rf24 = (rf24 & 0xc0) | init;	/* initial filter value */
	rt3090_rf_write(sc, 24, rf24);

	/* enable baseband loopback mode */
	rf22 = rt3090_rf_read(sc, 22);
	rt3090_rf_write(sc, 22, rf22 | RT3070_BB_LOOPBACK);

	/* set power and frequency of passband test tone */
	rt2860_mcu_bbp_write(sc, 24, 0x00);
	for (ntries = 0; ntries < 100; ntries++) {
		/* transmit test tone */
		rt2860_mcu_bbp_write(sc, 25, 0x90);
		DELAY(1000);
		/* read received power */
		bbp55_pb = rt2860_mcu_bbp_read(sc, 55);
		if (bbp55_pb != 0)
			break;
	}
	if (ntries == 100)
		return ETIMEDOUT;

	/* set power and frequency of stopband test tone */
	rt2860_mcu_bbp_write(sc, 24, 0x06);
	for (ntries = 0; ntries < 100; ntries++) {
		/* transmit test tone */
		rt2860_mcu_bbp_write(sc, 25, 0x90);
		DELAY(1000);
		/* read received power */
		bbp55_sb = rt2860_mcu_bbp_read(sc, 55);

		delta = bbp55_pb - bbp55_sb;
		if (delta > target)
			break;

		/* reprogram filter */
		rf24++;
		rt3090_rf_write(sc, 24, rf24);
	}
	if (ntries < 100) {
		if (rf24 != init)
			rf24--;	/* backtrack */
		*val = rf24;
		rt3090_rf_write(sc, 24, rf24);
	}

	/* restore initial state */
	rt2860_mcu_bbp_write(sc, 24, 0x00);

	/* disable baseband loopback mode */
	rf22 = rt3090_rf_read(sc, 22);
	rt3090_rf_write(sc, 22, rf22 & ~RT3070_BB_LOOPBACK);

	return 0;
}

void
rt3090_rf_setup(struct rt2860_softc *sc)
{
	uint8_t bbp;
	int i;

	if (sc->mac_rev >= 0x0211) {
		/* enable DC filter */
		rt2860_mcu_bbp_write(sc, 103, 0xc0);

		/* improve power consumption */
		bbp = rt2860_mcu_bbp_read(sc, 31);
		rt2860_mcu_bbp_write(sc, 31, bbp & ~0x03);
	}

	RAL_WRITE(sc, RT2860_TX_SW_CFG1, 0);
	if (sc->mac_rev < 0x0211) {
		RAL_WRITE(sc, RT2860_TX_SW_CFG2,
		    sc->patch_dac ? 0x2c : 0x0f);
	} else
		RAL_WRITE(sc, RT2860_TX_SW_CFG2, 0);

	/* initialize RF registers from ROM */
	if (sc->mac_ver < 0x5390) {
		for (i = 0; i < 10; i++) {
			if (sc->rf[i].reg == 0 || sc->rf[i].reg == 0xff)
			 	continue;
			rt3090_rf_write(sc, sc->rf[i].reg, sc->rf[i].val);
		}
	}
}

void
rt2860_set_leds(struct rt2860_softc *sc, uint16_t which)
{
	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LEDS,
	    which | (sc->leds & 0x7f), 0);
}

/*
 * Hardware has a general-purpose programmable timer interrupt that can
 * periodically raise MAC_INT_4.
 */
void
rt2860_set_gp_timer(struct rt2860_softc *sc, int ms)
{
	uint32_t tmp;

	/* disable GP timer before reprogramming it */
	tmp = RAL_READ(sc, RT2860_INT_TIMER_EN);
	RAL_WRITE(sc, RT2860_INT_TIMER_EN, tmp & ~RT2860_GP_TIMER_EN);

	if (ms == 0)
		return;

	tmp = RAL_READ(sc, RT2860_INT_TIMER_CFG);
	ms *= 16;	/* Unit: 64us */
	tmp = (tmp & 0xffff) | ms << RT2860_GP_TIMER_SHIFT;
	RAL_WRITE(sc, RT2860_INT_TIMER_CFG, tmp);

	/* enable GP timer */
	tmp = RAL_READ(sc, RT2860_INT_TIMER_EN);
	RAL_WRITE(sc, RT2860_INT_TIMER_EN, tmp | RT2860_GP_TIMER_EN);
}

void
rt2860_set_bssid(struct rt2860_softc *sc, const uint8_t *bssid)
{
	RAL_WRITE(sc, RT2860_MAC_BSSID_DW0,
	    bssid[0] | bssid[1] << 8 | bssid[2] << 16 | bssid[3] << 24);
	RAL_WRITE(sc, RT2860_MAC_BSSID_DW1,
	    bssid[4] | bssid[5] << 8);
}

void
rt2860_set_macaddr(struct rt2860_softc *sc, const uint8_t *addr)
{
	RAL_WRITE(sc, RT2860_MAC_ADDR_DW0,
	    addr[0] | addr[1] << 8 | addr[2] << 16 | addr[3] << 24);
	RAL_WRITE(sc, RT2860_MAC_ADDR_DW1,
	    addr[4] | addr[5] << 8 | 0xff << 16);
}

void
rt2860_updateslot(struct ieee80211com *ic)
{
	struct rt2860_softc *sc = ic->ic_softc;
	uint32_t tmp;

	tmp = RAL_READ(sc, RT2860_BKOFF_SLOT_CFG);
	tmp &= ~0xff;
	tmp |= (ic->ic_flags & IEEE80211_F_SHSLOT) ?
	    IEEE80211_DUR_DS_SHSLOT : IEEE80211_DUR_DS_SLOT;
	RAL_WRITE(sc, RT2860_BKOFF_SLOT_CFG, tmp);
}

void
rt2860_updateprot(struct ieee80211com *ic)
{
	struct rt2860_softc *sc = ic->ic_softc;
	uint32_t tmp;

	tmp = RT2860_RTSTH_EN | RT2860_PROT_NAV_SHORT | RT2860_TXOP_ALLOW_ALL;
	/* setup protection frame rate (MCS code) */
	tmp |= (ic->ic_curmode == IEEE80211_MODE_11A) ?
	    rt2860_rates[RT2860_RIDX_OFDM6].mcs :
	    rt2860_rates[RT2860_RIDX_CCK11].mcs;

	/* CCK frames don't require protection */
	RAL_WRITE(sc, RT2860_CCK_PROT_CFG, tmp);

	if (ic->ic_flags & IEEE80211_F_USEPROT) {
		if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
			tmp |= RT2860_PROT_CTRL_RTS_CTS;
		else if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
			tmp |= RT2860_PROT_CTRL_CTS;
	}
	RAL_WRITE(sc, RT2860_OFDM_PROT_CFG, tmp);
}

void
rt2860_updateedca(struct ieee80211com *ic)
{
	struct rt2860_softc *sc = ic->ic_softc;
	int aci;

	/* update MAC TX configuration registers */
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		RAL_WRITE(sc, RT2860_EDCA_AC_CFG(aci),
		    ic->ic_edca_ac[aci].ac_ecwmax << 16 |
		    ic->ic_edca_ac[aci].ac_ecwmin << 12 |
		    ic->ic_edca_ac[aci].ac_aifsn  <<  8 |
		    ic->ic_edca_ac[aci].ac_txoplimit);
	}

	/* update SCH/DMA registers too */
	RAL_WRITE(sc, RT2860_WMM_AIFSN_CFG,
	    ic->ic_edca_ac[EDCA_AC_VO].ac_aifsn  << 12 |
	    ic->ic_edca_ac[EDCA_AC_VI].ac_aifsn  <<  8 |
	    ic->ic_edca_ac[EDCA_AC_BK].ac_aifsn  <<  4 |
	    ic->ic_edca_ac[EDCA_AC_BE].ac_aifsn);
	RAL_WRITE(sc, RT2860_WMM_CWMIN_CFG,
	    ic->ic_edca_ac[EDCA_AC_VO].ac_ecwmin << 12 |
	    ic->ic_edca_ac[EDCA_AC_VI].ac_ecwmin <<  8 |
	    ic->ic_edca_ac[EDCA_AC_BK].ac_ecwmin <<  4 |
	    ic->ic_edca_ac[EDCA_AC_BE].ac_ecwmin);
	RAL_WRITE(sc, RT2860_WMM_CWMAX_CFG,
	    ic->ic_edca_ac[EDCA_AC_VO].ac_ecwmax << 12 |
	    ic->ic_edca_ac[EDCA_AC_VI].ac_ecwmax <<  8 |
	    ic->ic_edca_ac[EDCA_AC_BK].ac_ecwmax <<  4 |
	    ic->ic_edca_ac[EDCA_AC_BE].ac_ecwmax);
	RAL_WRITE(sc, RT2860_WMM_TXOP0_CFG,
	    ic->ic_edca_ac[EDCA_AC_BK].ac_txoplimit << 16 |
	    ic->ic_edca_ac[EDCA_AC_BE].ac_txoplimit);
	RAL_WRITE(sc, RT2860_WMM_TXOP1_CFG,
	    ic->ic_edca_ac[EDCA_AC_VO].ac_txoplimit << 16 |
	    ic->ic_edca_ac[EDCA_AC_VI].ac_txoplimit);
}

int
rt2860_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct rt2860_softc *sc = ic->ic_softc;
	bus_size_t base;
	uint32_t attr;
	uint8_t mode, wcid, iv[8];

	/* defer setting of WEP keys until interface is brought up */
	if ((ic->ic_if.if_flags & (IFF_UP | IFF_RUNNING)) !=
	    (IFF_UP | IFF_RUNNING))
		return 0;

	/* map net80211 cipher to RT2860 security mode */
	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
		mode = RT2860_MODE_WEP40;
		break;
	case IEEE80211_CIPHER_WEP104:
		mode = RT2860_MODE_WEP104;
		break;
	case IEEE80211_CIPHER_TKIP:
		mode = RT2860_MODE_TKIP;
		break;
	case IEEE80211_CIPHER_CCMP:
		mode = RT2860_MODE_AES_CCMP;
		break;
	default:
		return EINVAL;
	}

	if (k->k_flags & IEEE80211_KEY_GROUP) {
		wcid = 0;	/* NB: update WCID0 for group keys */
		base = RT2860_SKEY(0, k->k_id);
	} else {
		wcid = ((struct rt2860_node *)ni)->wcid;
		base = RT2860_PKEY(wcid);
	}

	if (k->k_cipher == IEEE80211_CIPHER_TKIP) {
		RAL_WRITE_REGION_1(sc, base, k->k_key, 16);
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
			RAL_WRITE_REGION_1(sc, base + 16, &k->k_key[16], 8);
			RAL_WRITE_REGION_1(sc, base + 24, &k->k_key[24], 8);
		} else
#endif
		{
			RAL_WRITE_REGION_1(sc, base + 16, &k->k_key[24], 8);
			RAL_WRITE_REGION_1(sc, base + 24, &k->k_key[16], 8);
		}
	} else
		RAL_WRITE_REGION_1(sc, base, k->k_key, k->k_len);

	if (!(k->k_flags & IEEE80211_KEY_GROUP) ||
	    (k->k_flags & IEEE80211_KEY_TX)) {
		/* set initial packet number in IV+EIV */
		if (k->k_cipher == IEEE80211_CIPHER_WEP40 ||
		    k->k_cipher == IEEE80211_CIPHER_WEP104) {
			uint32_t val = arc4random();
			/* skip weak IVs from Fluhrer/Mantin/Shamir */
			if (val >= 0x03ff00 && (val & 0xf8ff00) == 0x00ff00)
				val += 0x000100;
			iv[0] = val;
			iv[1] = val >> 8;
			iv[2] = val >> 16;
			iv[3] = k->k_id << 6;
			iv[4] = iv[5] = iv[6] = iv[7] = 0;
		} else {
			if (k->k_cipher == IEEE80211_CIPHER_TKIP) {
				iv[0] = k->k_tsc >> 8;
				iv[1] = (iv[0] | 0x20) & 0x7f;
				iv[2] = k->k_tsc;
			} else /* CCMP */ {
				iv[0] = k->k_tsc;
				iv[1] = k->k_tsc >> 8;
				iv[2] = 0;
			}
			iv[3] = k->k_id << 6 | IEEE80211_WEP_EXTIV;
			iv[4] = k->k_tsc >> 16;
			iv[5] = k->k_tsc >> 24;
			iv[6] = k->k_tsc >> 32;
			iv[7] = k->k_tsc >> 40;
		}
		RAL_WRITE_REGION_1(sc, RT2860_IVEIV(wcid), iv, 8);
	}

	if (k->k_flags & IEEE80211_KEY_GROUP) {
		/* install group key */
		attr = RAL_READ(sc, RT2860_SKEY_MODE_0_7);
		attr &= ~(0xf << (k->k_id * 4));
		attr |= mode << (k->k_id * 4);
		RAL_WRITE(sc, RT2860_SKEY_MODE_0_7, attr);
	} else {
		/* install pairwise key */
		attr = RAL_READ(sc, RT2860_WCID_ATTR(wcid));
		attr = (attr & ~0xf) | (mode << 1) | RT2860_RX_PKEY_EN;
		RAL_WRITE(sc, RT2860_WCID_ATTR(wcid), attr);
	}
	return 0;
}

void
rt2860_delete_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct rt2860_softc *sc = ic->ic_softc;
	uint32_t attr;
	uint8_t wcid;

	if (k->k_flags & IEEE80211_KEY_GROUP) {
		/* remove group key */
		attr = RAL_READ(sc, RT2860_SKEY_MODE_0_7);
		attr &= ~(0xf << (k->k_id * 4));
		RAL_WRITE(sc, RT2860_SKEY_MODE_0_7, attr);

	} else {
		/* remove pairwise key */
		wcid = ((struct rt2860_node *)ni)->wcid;
		attr = RAL_READ(sc, RT2860_WCID_ATTR(wcid));
		attr &= ~0xf;
		RAL_WRITE(sc, RT2860_WCID_ATTR(wcid), attr);
	}
}

#if NBPFILTER > 0
int8_t
rt2860_rssi2dbm(struct rt2860_softc *sc, uint8_t rssi, uint8_t rxchain)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *c = ic->ic_ibss_chan;
	int delta;

	if (IEEE80211_IS_CHAN_5GHZ(c)) {
		u_int chan = ieee80211_chan2ieee(ic, c);
		delta = sc->rssi_5ghz[rxchain];

		/* determine channel group */
		if (chan <= 64)
			delta -= sc->lna[1];
		else if (chan <= 128)
			delta -= sc->lna[2];
		else
			delta -= sc->lna[3];
	} else
		delta = sc->rssi_2ghz[rxchain] - sc->lna[0];

	return -12 - delta - rssi;
}
#endif

/*
 * Add `delta' (signed) to each 4-bit sub-word of a 32-bit word.
 * Used to adjust per-rate Tx power registers.
 */
static __inline uint32_t
b4inc(uint32_t b32, int8_t delta)
{
	int8_t i, b4;

	for (i = 0; i < 8; i++) {
		b4 = b32 & 0xf;
		b4 += delta;
		if (b4 < 0)
			b4 = 0;
		else if (b4 > 0xf)
			b4 = 0xf;
		b32 = b32 >> 4 | b4 << 28;
	}
	return b32;
}

const char *
rt2860_get_rf(uint16_t rev)
{
	switch (rev) {
	case RT2860_RF_2820:	return "RT2820";
	case RT2860_RF_2850:	return "RT2850";
	case RT2860_RF_2720:	return "RT2720";
	case RT2860_RF_2750:	return "RT2750";
	case RT3070_RF_3020:	return "RT3020";
	case RT3070_RF_2020:	return "RT2020";
	case RT3070_RF_3021:	return "RT3021";
	case RT3070_RF_3022:	return "RT3022";
	case RT3070_RF_3052:	return "RT3052";
	case RT3070_RF_3320:	return "RT3320";
	case RT3070_RF_3053:	return "RT3053";
	case RT5390_RF_5360:	return "RT5360";
	case RT5390_RF_5390:	return "RT5390";
	case RT5390_RF_5392:	return "RT5392";
	default:		return "unknown";
	}
}

int
rt2860_read_eeprom(struct rt2860_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int8_t delta_2ghz, delta_5ghz;
	uint32_t tmp;
	uint16_t val;
	int ridx, ant, i;

	/* check whether the ROM is eFUSE ROM or EEPROM */
	sc->sc_srom_read = rt2860_eeprom_read_2;
	if (sc->mac_ver >= 0x3071) {
		tmp = RAL_READ(sc, RT3070_EFUSE_CTRL);
		DPRINTF(("EFUSE_CTRL=0x%08x\n", tmp));
		if (tmp & RT3070_SEL_EFUSE)
			sc->sc_srom_read = rt3090_efuse_read_2;
	}

	/* read EEPROM version */
	val = rt2860_srom_read(sc, RT2860_EEPROM_VERSION);
	DPRINTF(("EEPROM rev=%d, FAE=%d\n", val & 0xff, val >> 8));

	/* read MAC address */
	val = rt2860_srom_read(sc, RT2860_EEPROM_MAC01);
	ic->ic_myaddr[0] = val & 0xff;
	ic->ic_myaddr[1] = val >> 8;
	val = rt2860_srom_read(sc, RT2860_EEPROM_MAC23);
	ic->ic_myaddr[2] = val & 0xff;
	ic->ic_myaddr[3] = val >> 8;
	val = rt2860_srom_read(sc, RT2860_EEPROM_MAC45);
	ic->ic_myaddr[4] = val & 0xff;
	ic->ic_myaddr[5] = val >> 8;

	/* read country code */
	val = rt2860_srom_read(sc, RT2860_EEPROM_COUNTRY);
	DPRINTF(("EEPROM region code=0x%04x\n", val));

	/* read vendor BBP settings */
	for (i = 0; i < 8; i++) {
		val = rt2860_srom_read(sc, RT2860_EEPROM_BBP_BASE + i);
		sc->bbp[i].val = val & 0xff;
		sc->bbp[i].reg = val >> 8;
		DPRINTF(("BBP%d=0x%02x\n", sc->bbp[i].reg, sc->bbp[i].val));
	}
	if (sc->mac_ver >= 0x3071) {
		/* read vendor RF settings */
		for (i = 0; i < 10; i++) {
			val = rt2860_srom_read(sc, RT3071_EEPROM_RF_BASE + i);
			sc->rf[i].val = val & 0xff;
			sc->rf[i].reg = val >> 8;
			DPRINTF(("RF%d=0x%02x\n", sc->rf[i].reg,
			    sc->rf[i].val));
		}
	}

	/* read RF frequency offset from EEPROM */
	val = rt2860_srom_read(sc, RT2860_EEPROM_FREQ_LEDS);
	sc->freq = ((val & 0xff) != 0xff) ? val & 0xff : 0;
	DPRINTF(("EEPROM freq offset %d\n", sc->freq & 0xff));
	if ((val >> 8) != 0xff) {
		/* read LEDs operating mode */
		sc->leds = val >> 8;
		sc->led[0] = rt2860_srom_read(sc, RT2860_EEPROM_LED1);
		sc->led[1] = rt2860_srom_read(sc, RT2860_EEPROM_LED2);
		sc->led[2] = rt2860_srom_read(sc, RT2860_EEPROM_LED3);
	} else {
		/* broken EEPROM, use default settings */
		sc->leds = 0x01;
		sc->led[0] = 0x5555;
		sc->led[1] = 0x2221;
		sc->led[2] = 0xa9f8;
	}
	DPRINTF(("EEPROM LED mode=0x%02x, LEDs=0x%04x/0x%04x/0x%04x\n",
	    sc->leds, sc->led[0], sc->led[1], sc->led[2]));

	/* read RF information */
	val = rt2860_srom_read(sc, RT2860_EEPROM_ANTENNA);
	if (sc->mac_ver >= 0x5390)
		sc->rf_rev = rt2860_srom_read(sc, RT2860_EEPROM_CHIPID);
	else
		sc->rf_rev = (val >> 8) & 0xf;
	sc->ntxchains = (val >> 4) & 0xf;
	sc->nrxchains = val & 0xf;
	DPRINTF(("EEPROM RF rev=0x%02x chains=%dT%dR\n",
	    sc->rf_rev, sc->ntxchains, sc->nrxchains));

	/* check if RF supports automatic Tx access gain control */
	val = rt2860_srom_read(sc, RT2860_EEPROM_CONFIG);
	DPRINTF(("EEPROM CFG 0x%04x\n", val));
	/* check if driver should patch the DAC issue */
	if ((val >> 8) != 0xff)
		sc->patch_dac = (val >> 15) & 1;
	if ((val & 0xff) != 0xff) {
		sc->ext_5ghz_lna = (val >> 3) & 1;
		sc->ext_2ghz_lna = (val >> 2) & 1;
		/* check if RF supports automatic Tx access gain control */
		sc->calib_2ghz = sc->calib_5ghz = 0; /* XXX (val >> 1) & 1 */;
		/* check if we have a hardware radio switch */
		sc->rfswitch = val & 1;
	}
	if (sc->sc_flags & RT2860_ADVANCED_PS) {
		/* read PCIe power save level */
		val = rt2860_srom_read(sc, RT2860_EEPROM_PCIE_PSLEVEL);
		if ((val & 0xff) != 0xff) {
			sc->pslevel = val & 0x3;
			val = rt2860_srom_read(sc, RT2860_EEPROM_REV);
			if ((val & 0xff80) != 0x9280)
				sc->pslevel = MIN(sc->pslevel, 1);
			DPRINTF(("EEPROM PCIe PS Level=%d\n", sc->pslevel));
		}
	}

	/* read power settings for 2GHz channels */
	for (i = 0; i < 14; i += 2) {
		val = rt2860_srom_read(sc,
		    RT2860_EEPROM_PWR2GHZ_BASE1 + i / 2);
		sc->txpow1[i + 0] = (int8_t)(val & 0xff);
		sc->txpow1[i + 1] = (int8_t)(val >> 8);

		if (sc->mac_ver != 0x5390) {
			val = rt2860_srom_read(sc,
			    RT2860_EEPROM_PWR2GHZ_BASE2 + i / 2);
			sc->txpow2[i + 0] = (int8_t)(val & 0xff);
			sc->txpow2[i + 1] = (int8_t)(val >> 8);
		}
	}
	/* fix broken Tx power entries */
	for (i = 0; i < 14; i++) {
		if (sc->txpow1[i] < 0 ||
		    sc->txpow1[i] > ((sc->mac_ver >= 0x5390) ? 39 : 31))
		        sc->txpow1[i] = 5;
		if (sc->mac_ver != 0x5390) {
			if (sc->txpow2[i] < 0 ||
			    sc->txpow2[i] > ((sc->mac_ver == 0x5392) ? 39 : 31))
			        sc->txpow2[i] = 5;
		}
		DPRINTF(("chan %d: power1=%d, power2=%d\n",
		    rt2860_rf2850[i].chan, sc->txpow1[i], sc->txpow2[i]));
	}
	/* read power settings for 5GHz channels */
	for (i = 0; i < 40; i += 2) {
		val = rt2860_srom_read(sc,
		    RT2860_EEPROM_PWR5GHZ_BASE1 + i / 2);
		sc->txpow1[i + 14] = (int8_t)(val & 0xff);
		sc->txpow1[i + 15] = (int8_t)(val >> 8);

		val = rt2860_srom_read(sc,
		    RT2860_EEPROM_PWR5GHZ_BASE2 + i / 2);
		sc->txpow2[i + 14] = (int8_t)(val & 0xff);
		sc->txpow2[i + 15] = (int8_t)(val >> 8);
	}
	/* fix broken Tx power entries */
	for (i = 0; i < 40; i++) {
		if (sc->txpow1[14 + i] < -7 || sc->txpow1[14 + i] > 15)
			sc->txpow1[14 + i] = 5;
		if (sc->txpow2[14 + i] < -7 || sc->txpow2[14 + i] > 15)
			sc->txpow2[14 + i] = 5;
		DPRINTF(("chan %d: power1=%d, power2=%d\n",
		    rt2860_rf2850[14 + i].chan, sc->txpow1[14 + i],
		    sc->txpow2[14 + i]));
	}

	/* read Tx power compensation for each Tx rate */
	val = rt2860_srom_read(sc, RT2860_EEPROM_DELTAPWR);
	delta_2ghz = delta_5ghz = 0;
	if ((val & 0xff) != 0xff && (val & 0x80)) {
		delta_2ghz = val & 0xf;
		if (!(val & 0x40))	/* negative number */
			delta_2ghz = -delta_2ghz;
	}
	val >>= 8;
	if ((val & 0xff) != 0xff && (val & 0x80)) {
		delta_5ghz = val & 0xf;
		if (!(val & 0x40))	/* negative number */
			delta_5ghz = -delta_5ghz;
	}
	DPRINTF(("power compensation=%d (2GHz), %d (5GHz)\n",
	    delta_2ghz, delta_5ghz));

	for (ridx = 0; ridx < 5; ridx++) {
		uint32_t reg;

		val = rt2860_srom_read(sc, RT2860_EEPROM_RPWR + ridx * 2);
		reg = val;
		val = rt2860_srom_read(sc, RT2860_EEPROM_RPWR + ridx * 2 + 1);
		reg |= (uint32_t)val << 16;

		sc->txpow20mhz[ridx] = reg;
		sc->txpow40mhz_2ghz[ridx] = b4inc(reg, delta_2ghz);
		sc->txpow40mhz_5ghz[ridx] = b4inc(reg, delta_5ghz);

		DPRINTF(("ridx %d: power 20MHz=0x%08x, 40MHz/2GHz=0x%08x, "
		    "40MHz/5GHz=0x%08x\n", ridx, sc->txpow20mhz[ridx],
		    sc->txpow40mhz_2ghz[ridx], sc->txpow40mhz_5ghz[ridx]));
	}

	/* read factory-calibrated samples for temperature compensation */
	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI1_2GHZ);
	sc->tssi_2ghz[0] = val & 0xff;	/* [-4] */
	sc->tssi_2ghz[1] = val >> 8;	/* [-3] */
	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI2_2GHZ);
	sc->tssi_2ghz[2] = val & 0xff;	/* [-2] */
	sc->tssi_2ghz[3] = val >> 8;	/* [-1] */
	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI3_2GHZ);
	sc->tssi_2ghz[4] = val & 0xff;	/* [+0] */
	sc->tssi_2ghz[5] = val >> 8;	/* [+1] */
	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI4_2GHZ);
	sc->tssi_2ghz[6] = val & 0xff;	/* [+2] */
	sc->tssi_2ghz[7] = val >> 8;	/* [+3] */
	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI5_2GHZ);
	sc->tssi_2ghz[8] = val & 0xff;	/* [+4] */
	sc->step_2ghz = val >> 8;
	DPRINTF(("TSSI 2GHz: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x "
	    "0x%02x 0x%02x step=%d\n", sc->tssi_2ghz[0], sc->tssi_2ghz[1],
	    sc->tssi_2ghz[2], sc->tssi_2ghz[3], sc->tssi_2ghz[4],
	    sc->tssi_2ghz[5], sc->tssi_2ghz[6], sc->tssi_2ghz[7],
	    sc->tssi_2ghz[8], sc->step_2ghz));
	/* check that ref value is correct, otherwise disable calibration */
	if (sc->tssi_2ghz[4] == 0xff)
		sc->calib_2ghz = 0;

	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI1_5GHZ);
	sc->tssi_5ghz[0] = val & 0xff;	/* [-4] */
	sc->tssi_5ghz[1] = val >> 8;	/* [-3] */
	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI2_5GHZ);
	sc->tssi_5ghz[2] = val & 0xff;	/* [-2] */
	sc->tssi_5ghz[3] = val >> 8;	/* [-1] */
	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI3_5GHZ);
	sc->tssi_5ghz[4] = val & 0xff;	/* [+0] */
	sc->tssi_5ghz[5] = val >> 8;	/* [+1] */
	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI4_5GHZ);
	sc->tssi_5ghz[6] = val & 0xff;	/* [+2] */
	sc->tssi_5ghz[7] = val >> 8;	/* [+3] */
	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI5_5GHZ);
	sc->tssi_5ghz[8] = val & 0xff;	/* [+4] */
	sc->step_5ghz = val >> 8;
	DPRINTF(("TSSI 5GHz: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x "
	    "0x%02x 0x%02x step=%d\n", sc->tssi_5ghz[0], sc->tssi_5ghz[1],
	    sc->tssi_5ghz[2], sc->tssi_5ghz[3], sc->tssi_5ghz[4],
	    sc->tssi_5ghz[5], sc->tssi_5ghz[6], sc->tssi_5ghz[7],
	    sc->tssi_5ghz[8], sc->step_5ghz));
	/* check that ref value is correct, otherwise disable calibration */
	if (sc->tssi_5ghz[4] == 0xff)
		sc->calib_5ghz = 0;

	/* read RSSI offsets and LNA gains from EEPROM */
	val = rt2860_srom_read(sc, RT2860_EEPROM_RSSI1_2GHZ);
	sc->rssi_2ghz[0] = val & 0xff;	/* Ant A */
	sc->rssi_2ghz[1] = val >> 8;	/* Ant B */
	val = rt2860_srom_read(sc, RT2860_EEPROM_RSSI2_2GHZ);
	if (sc->mac_ver >= 0x3071) {
		/*
		 * On RT3090 chips (limited to 2 Rx chains), this ROM
		 * field contains the Tx mixer gain for the 2GHz band.
		 */
		if ((val & 0xff) != 0xff)
			sc->txmixgain_2ghz = val & 0x7;
		DPRINTF(("tx mixer gain=%u (2GHz)\n", sc->txmixgain_2ghz));
	} else
		sc->rssi_2ghz[2] = val & 0xff;	/* Ant C */
	sc->lna[2] = val >> 8;		/* channel group 2 */

	val = rt2860_srom_read(sc, RT2860_EEPROM_RSSI1_5GHZ);
	sc->rssi_5ghz[0] = val & 0xff;	/* Ant A */
	sc->rssi_5ghz[1] = val >> 8;	/* Ant B */
	val = rt2860_srom_read(sc, RT2860_EEPROM_RSSI2_5GHZ);
	sc->rssi_5ghz[2] = val & 0xff;	/* Ant C */
	sc->lna[3] = val >> 8;		/* channel group 3 */

	val = rt2860_srom_read(sc, RT2860_EEPROM_LNA);
	if (sc->mac_ver >= 0x3071)
		sc->lna[0] = RT3090_DEF_LNA;
	else				/* channel group 0 */
		sc->lna[0] = val & 0xff;
	sc->lna[1] = val >> 8;		/* channel group 1 */

	/* fix broken 5GHz LNA entries */
	if (sc->lna[2] == 0 || sc->lna[2] == 0xff) {
		DPRINTF(("invalid LNA for channel group %d\n", 2));
		sc->lna[2] = sc->lna[1];
	}
	if (sc->lna[3] == 0 || sc->lna[3] == 0xff) {
		DPRINTF(("invalid LNA for channel group %d\n", 3));
		sc->lna[3] = sc->lna[1];
	}

	/* fix broken RSSI offset entries */
	for (ant = 0; ant < 3; ant++) {
		if (sc->rssi_2ghz[ant] < -10 || sc->rssi_2ghz[ant] > 10) {
			DPRINTF(("invalid RSSI%d offset: %d (2GHz)\n",
			    ant + 1, sc->rssi_2ghz[ant]));
			sc->rssi_2ghz[ant] = 0;
		}
		if (sc->rssi_5ghz[ant] < -10 || sc->rssi_5ghz[ant] > 10) {
			DPRINTF(("invalid RSSI%d offset: %d (5GHz)\n",
			    ant + 1, sc->rssi_5ghz[ant]));
			sc->rssi_5ghz[ant] = 0;
		}
	}

	return 0;
}

int
rt2860_bbp_init(struct rt2860_softc *sc)
{
	int i, ntries;

	/* wait for BBP to wake up */
	for (ntries = 0; ntries < 20; ntries++) {
		uint8_t bbp0 = rt2860_mcu_bbp_read(sc, 0);
		if (bbp0 != 0 && bbp0 != 0xff)
			break;
	}
	if (ntries == 20) {
		printf("%s: timeout waiting for BBP to wake up\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

	/* initialize BBP registers to default values */
	if (sc->mac_ver >= 0x5390)
		rt5390_bbp_init(sc);
	else {
		for (i = 0; i < nitems(rt2860_def_bbp); i++) {
			rt2860_mcu_bbp_write(sc, rt2860_def_bbp[i].reg,
			    rt2860_def_bbp[i].val);
		}
	}

	/* fix BBP84 for RT2860E */
	if (sc->mac_ver == 0x2860 && sc->mac_rev != 0x0101)
		rt2860_mcu_bbp_write(sc, 84, 0x19);

	if (sc->mac_ver >= 0x3071) {
		rt2860_mcu_bbp_write(sc, 79, 0x13);
		rt2860_mcu_bbp_write(sc, 80, 0x05);
		rt2860_mcu_bbp_write(sc, 81, 0x33);
	} else if (sc->mac_ver == 0x2860 && sc->mac_rev == 0x0100) {
		rt2860_mcu_bbp_write(sc, 69, 0x16);
		rt2860_mcu_bbp_write(sc, 73, 0x12);
	}

	return 0;
}

void
rt5390_bbp_init(struct rt2860_softc *sc)
{
	uint8_t bbp;
	int i;

	/* Apply maximum likelihood detection for 2 stream case. */
	if (sc->nrxchains > 1) {
		bbp = rt2860_mcu_bbp_read(sc, 105);
		rt2860_mcu_bbp_write(sc, 105, bbp | RT5390_MLD);
	}

	/* Avoid data lost and CRC error. */
	bbp = rt2860_mcu_bbp_read(sc, 4);
	rt2860_mcu_bbp_write(sc, 4, bbp | RT5390_MAC_IF_CTRL);

	for (i = 0; i < nitems(rt5390_def_bbp); i++) {
		rt2860_mcu_bbp_write(sc, rt5390_def_bbp[i].reg,
		    rt5390_def_bbp[i].val);
	}

	if (sc->mac_ver == 0x5392) {
		rt2860_mcu_bbp_write(sc, 84, 0x9a);
		rt2860_mcu_bbp_write(sc, 95, 0x9a);
		rt2860_mcu_bbp_write(sc, 98, 0x12);
		rt2860_mcu_bbp_write(sc, 106, 0x05);
		rt2860_mcu_bbp_write(sc, 134, 0xd0);
		rt2860_mcu_bbp_write(sc, 135, 0xf6);
	}

	bbp = rt2860_mcu_bbp_read(sc, 152);
	rt2860_mcu_bbp_write(sc, 152, bbp | 0x80);

	/* Disable hardware antenna diversity. */
	if (sc->mac_ver == 0x5390)
		rt2860_mcu_bbp_write(sc, 154, 0);
}

int
rt2860_txrx_enable(struct rt2860_softc *sc)
{
	uint32_t tmp;
	int ntries;

	/* enable Tx/Rx DMA engine */
	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, RT2860_MAC_TX_EN);
	RAL_BARRIER_READ_WRITE(sc);
	for (ntries = 0; ntries < 200; ntries++) {
		tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);
		if ((tmp & (RT2860_TX_DMA_BUSY | RT2860_RX_DMA_BUSY)) == 0)
			break;
		DELAY(1000);
	}
	if (ntries == 200) {
		printf("%s: timeout waiting for DMA engine\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

	DELAY(50);

	tmp |= RT2860_RX_DMA_EN | RT2860_TX_DMA_EN |
	    RT2860_WPDMA_BT_SIZE64 << RT2860_WPDMA_BT_SIZE_SHIFT;
	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);

	/* set Rx filter */
	tmp = RT2860_DROP_CRC_ERR | RT2860_DROP_PHY_ERR;
	if (sc->sc_ic.ic_opmode != IEEE80211_M_MONITOR) {
		tmp |= RT2860_DROP_UC_NOME | RT2860_DROP_DUPL |
		    RT2860_DROP_CTS | RT2860_DROP_BA | RT2860_DROP_ACK |
		    RT2860_DROP_VER_ERR | RT2860_DROP_CTRL_RSV |
		    RT2860_DROP_CFACK | RT2860_DROP_CFEND;
		if (sc->sc_ic.ic_opmode == IEEE80211_M_STA)
			tmp |= RT2860_DROP_RTS | RT2860_DROP_PSPOLL;
	}
	RAL_WRITE(sc, RT2860_RX_FILTR_CFG, tmp);

	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL,
	    RT2860_MAC_RX_EN | RT2860_MAC_TX_EN);

	return 0;
}

int
rt2860_init(struct ifnet *ifp)
{
	struct rt2860_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;
	uint8_t bbp1, bbp3;
	int i, qid, ridx, ntries, error;

	/* for CardBus, power on the socket */
	if (!(sc->sc_flags & RT2860_ENABLED)) {
		if (sc->sc_enable != NULL && (*sc->sc_enable)(sc) != 0) {
			printf("%s: could not enable device\n",
			    sc->sc_dev.dv_xname);
			return EIO;
		}
		sc->sc_flags |= RT2860_ENABLED;
	}

	if (sc->rfswitch) {
		/* hardware has a radio switch on GPIO pin 2 */
		if (!(RAL_READ(sc, RT2860_GPIO_CTRL) & (1 << 2))) {
			printf("%s: radio is disabled by hardware switch\n",
			    sc->sc_dev.dv_xname);
#ifdef notyet
			rt2860_stop(ifp, 1);
			return EPERM;
#endif
		}
	}
	RAL_WRITE(sc, RT2860_PWR_PIN_CFG, RT2860_IO_RA_PE);

	/* disable DMA */
	tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);
	tmp &= 0xff0;
	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);

	/* PBF hardware reset */
	RAL_WRITE(sc, RT2860_SYS_CTRL, 0xe1f);
	RAL_BARRIER_WRITE(sc);
	RAL_WRITE(sc, RT2860_SYS_CTRL, 0xe00);

	if ((error = rt2860_load_microcode(sc)) != 0) {
		printf("%s: could not load 8051 microcode\n",
		    sc->sc_dev.dv_xname);
		rt2860_stop(ifp, 1);
		return error;
	}

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	rt2860_set_macaddr(sc, ic->ic_myaddr);

	/* init Tx power for all Tx rates (from EEPROM) */
	for (ridx = 0; ridx < 5; ridx++) {
		if (sc->txpow20mhz[ridx] == 0xffffffff)
			continue;
		RAL_WRITE(sc, RT2860_TX_PWR_CFG(ridx), sc->txpow20mhz[ridx]);
	}

	for (ntries = 0; ntries < 100; ntries++) {
		tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);
		if ((tmp & (RT2860_TX_DMA_BUSY | RT2860_RX_DMA_BUSY)) == 0)
			break;
		DELAY(1000);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for DMA engine\n",
		    sc->sc_dev.dv_xname);
		rt2860_stop(ifp, 1);
		return ETIMEDOUT;
	}
	tmp &= 0xff0;
	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);

	/* reset Rx ring and all 6 Tx rings */
	RAL_WRITE(sc, RT2860_WPDMA_RST_IDX, 0x1003f);

	/* PBF hardware reset */
	RAL_WRITE(sc, RT2860_SYS_CTRL, 0xe1f);
	RAL_BARRIER_WRITE(sc);
	RAL_WRITE(sc, RT2860_SYS_CTRL, 0xe00);

	RAL_WRITE(sc, RT2860_PWR_PIN_CFG, RT2860_IO_RA_PE | RT2860_IO_RF_PE);

	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, RT2860_BBP_HRST | RT2860_MAC_SRST);
	RAL_BARRIER_WRITE(sc);
	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, 0);

	for (i = 0; i < nitems(rt2860_def_mac); i++)
		RAL_WRITE(sc, rt2860_def_mac[i].reg, rt2860_def_mac[i].val);
	if (sc->mac_ver >= 0x5390)
		RAL_WRITE(sc, RT2860_TX_SW_CFG0, 0x00000404);
	else if (sc->mac_ver >= 0x3071) {
		/* set delay of PA_PE assertion to 1us (unit of 0.25us) */
		RAL_WRITE(sc, RT2860_TX_SW_CFG0,
		    4 << RT2860_DLY_PAPE_EN_SHIFT);
	}

	if (!(RAL_READ(sc, RT2860_PCI_CFG) & RT2860_PCI_CFG_PCI)) {
		sc->sc_flags |= RT2860_PCIE;
		/* PCIe has different clock cycle count than PCI */
		tmp = RAL_READ(sc, RT2860_US_CYC_CNT);
		tmp = (tmp & ~0xff) | 0x7d;
		RAL_WRITE(sc, RT2860_US_CYC_CNT, tmp);
	}

	/* wait while MAC is busy */
	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2860_MAC_STATUS_REG) &
		    (RT2860_RX_STATUS_BUSY | RT2860_TX_STATUS_BUSY)))
			break;
		DELAY(1000);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for MAC\n", sc->sc_dev.dv_xname);
		rt2860_stop(ifp, 1);
		return ETIMEDOUT;
	}

	/* clear Host to MCU mailbox */
	RAL_WRITE(sc, RT2860_H2M_BBPAGENT, 0);
	RAL_WRITE(sc, RT2860_H2M_MAILBOX, 0);

	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_RFRESET, 0, 0);
	DELAY(1000);

	if ((error = rt2860_bbp_init(sc)) != 0) {
		rt2860_stop(ifp, 1);
		return error;
	}

	/* clear RX WCID search table */
	RAL_SET_REGION_4(sc, RT2860_WCID_ENTRY(0), 0, 512);
	/* clear pairwise key table */
	RAL_SET_REGION_4(sc, RT2860_PKEY(0), 0, 2048);
	/* clear IV/EIV table */
	RAL_SET_REGION_4(sc, RT2860_IVEIV(0), 0, 512);
	/* clear WCID attribute table */
	RAL_SET_REGION_4(sc, RT2860_WCID_ATTR(0), 0, 256);
	/* clear shared key table */
	RAL_SET_REGION_4(sc, RT2860_SKEY(0, 0), 0, 8 * 32);
	/* clear shared key mode */
	RAL_SET_REGION_4(sc, RT2860_SKEY_MODE_0_7, 0, 4);

	/* init Tx rings (4 EDCAs + HCCA + Mgt) */
	for (qid = 0; qid < 6; qid++) {
		RAL_WRITE(sc, RT2860_TX_BASE_PTR(qid), sc->txq[qid].paddr);
		RAL_WRITE(sc, RT2860_TX_MAX_CNT(qid), RT2860_TX_RING_COUNT);
		RAL_WRITE(sc, RT2860_TX_CTX_IDX(qid), 0);
	}

	/* init Rx ring */
	RAL_WRITE(sc, RT2860_RX_BASE_PTR, sc->rxq.paddr);
	RAL_WRITE(sc, RT2860_RX_MAX_CNT, RT2860_RX_RING_COUNT);
	RAL_WRITE(sc, RT2860_RX_CALC_IDX, RT2860_RX_RING_COUNT - 1);

	/* setup maximum buffer sizes */
	RAL_WRITE(sc, RT2860_MAX_LEN_CFG, 1 << 12 |
	    (MCLBYTES - sizeof (struct rt2860_rxwi) - 2));

	for (ntries = 0; ntries < 100; ntries++) {
		tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);
		if ((tmp & (RT2860_TX_DMA_BUSY | RT2860_RX_DMA_BUSY)) == 0)
			break;
		DELAY(1000);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for DMA engine\n",
		    sc->sc_dev.dv_xname);
		rt2860_stop(ifp, 1);
		return ETIMEDOUT;
	}
	tmp &= 0xff0;
	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);

	/* disable interrupts mitigation */
	RAL_WRITE(sc, RT2860_DELAY_INT_CFG, 0);

	/* write vendor-specific BBP values (from EEPROM) */
	for (i = 0; i < 8; i++) {
		if (sc->bbp[i].reg == 0 || sc->bbp[i].reg == 0xff)
			continue;
		rt2860_mcu_bbp_write(sc, sc->bbp[i].reg, sc->bbp[i].val);
	}

	/* select Main antenna for 1T1R devices */
	if (sc->rf_rev == RT3070_RF_2020 ||
	    sc->rf_rev == RT3070_RF_3020 ||
	    sc->rf_rev == RT3070_RF_3320 ||
	    sc->rf_rev == RT5390_RF_5390)
		rt3090_set_rx_antenna(sc, 0);

	/* send LEDs operating mode to microcontroller */
	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LED1, sc->led[0], 0);
	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LED2, sc->led[1], 0);
	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LED3, sc->led[2], 0);

	if (sc->mac_ver >= 0x5390)
		rt5390_rf_init(sc);
	else if (sc->mac_ver >= 0x3071)
		rt3090_rf_init(sc);

	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_SLEEP, 0x02ff, 1);
	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_WAKEUP, 0, 1);

	if (sc->mac_ver >= 0x5390)
		rt5390_rf_wakeup(sc);
	else if (sc->mac_ver >= 0x3071)
		rt3090_rf_wakeup(sc);

	/* disable non-existing Rx chains */
	bbp3 = rt2860_mcu_bbp_read(sc, 3);
	bbp3 &= ~(1 << 3 | 1 << 4);
	if (sc->nrxchains == 2)
		bbp3 |= 1 << 3;
	else if (sc->nrxchains == 3)
		bbp3 |= 1 << 4;
	rt2860_mcu_bbp_write(sc, 3, bbp3);

	/* disable non-existing Tx chains */
	bbp1 = rt2860_mcu_bbp_read(sc, 1);
	if (sc->ntxchains == 1)
		bbp1 = (bbp1 & ~(1 << 3 | 1 << 4));
	else if (sc->mac_ver == 0x3593 && sc->ntxchains == 2)
		bbp1 = (bbp1 & ~(1 << 4)) | 1 << 3;
	else if (sc->mac_ver == 0x3593 && sc->ntxchains == 3)
		bbp1 = (bbp1 & ~(1 << 3)) | 1 << 4;
	rt2860_mcu_bbp_write(sc, 1, bbp1);

	if (sc->mac_ver >= 0x3071)
		rt3090_rf_setup(sc);

	/* select default channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	rt2860_switch_chan(sc, ic->ic_ibss_chan);

	/* reset RF from MCU */
	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_RFRESET, 0, 0);

	/* set RTS threshold */
	tmp = RAL_READ(sc, RT2860_TX_RTS_CFG);
	tmp &= ~0xffff00;
	tmp |= ic->ic_rtsthreshold << 8;
	RAL_WRITE(sc, RT2860_TX_RTS_CFG, tmp);

	/* setup initial protection mode */
	sc->sc_ic_flags = ic->ic_flags;
	rt2860_updateprot(ic);

	/* turn radio LED on */
	rt2860_set_leds(sc, RT2860_LED_RADIO);

	/* enable Tx/Rx DMA engine */
	if ((error = rt2860_txrx_enable(sc)) != 0) {
		rt2860_stop(ifp, 1);
		return error;
	}

	/* clear pending interrupts */
	RAL_WRITE(sc, RT2860_INT_STATUS, 0xffffffff);
	/* enable interrupts */
	RAL_WRITE(sc, RT2860_INT_MASK, 0x3fffc);

	if (sc->sc_flags & RT2860_ADVANCED_PS)
		rt2860_mcu_cmd(sc, RT2860_MCU_CMD_PSLEVEL, sc->pslevel, 0);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (ic->ic_flags & IEEE80211_F_WEPON) {
		/* install WEP keys */
		for (i = 0; i < IEEE80211_WEP_NKID; i++)
			(void)rt2860_set_key(ic, NULL, &ic->ic_nw_keys[i]);
	}

	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	return 0;
}

void
rt2860_stop(struct ifnet *ifp, int disable)
{
	struct rt2860_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;
	int qid;

	if (ifp->if_flags & IFF_RUNNING)
		rt2860_set_leds(sc, 0);	/* turn all LEDs off */

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);	/* free all nodes */

	/* disable interrupts */
	RAL_WRITE(sc, RT2860_INT_MASK, 0);

	/* disable GP timer */
	rt2860_set_gp_timer(sc, 0);

	/* disable Rx */
	tmp = RAL_READ(sc, RT2860_MAC_SYS_CTRL);
	tmp &= ~(RT2860_MAC_RX_EN | RT2860_MAC_TX_EN);
	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, tmp);

	/* reset adapter */
	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, RT2860_BBP_HRST | RT2860_MAC_SRST);
	RAL_BARRIER_WRITE(sc);
	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, 0);

	/* reset Tx and Rx rings (and reclaim TXWIs) */
	sc->qfullmsk = 0;
	for (qid = 0; qid < 6; qid++)
		rt2860_reset_tx_ring(sc, &sc->txq[qid]);
	rt2860_reset_rx_ring(sc, &sc->rxq);

	/* for CardBus, power down the socket */
	if (disable && sc->sc_disable != NULL) {
		if (sc->sc_flags & RT2860_ENABLED) {
			(*sc->sc_disable)(sc);
			sc->sc_flags &= ~RT2860_ENABLED;
		}
	}
}

int
rt2860_load_microcode(struct rt2860_softc *sc)
{
	int ntries;

	/* set "host program ram write selection" bit */
	RAL_WRITE(sc, RT2860_SYS_CTRL, RT2860_HST_PM_SEL);
	/* write microcode image */
	RAL_WRITE_REGION_1(sc, RT2860_FW_BASE, sc->ucode, sc->ucsize);
	/* kick microcontroller unit */
	RAL_WRITE(sc, RT2860_SYS_CTRL, 0);
	RAL_BARRIER_WRITE(sc);
	RAL_WRITE(sc, RT2860_SYS_CTRL, RT2860_MCU_RESET);

	RAL_WRITE(sc, RT2860_H2M_BBPAGENT, 0);
	RAL_WRITE(sc, RT2860_H2M_MAILBOX, 0);

	/* wait until microcontroller is ready */
	RAL_BARRIER_READ_WRITE(sc);
	for (ntries = 0; ntries < 1000; ntries++) {
		if (RAL_READ(sc, RT2860_SYS_CTRL) & RT2860_MCU_READY)
			break;
		DELAY(1000);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for MCU to initialize\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}
	return 0;
}

/*
 * This function is called periodically to adjust Tx power based on
 * temperature variation.
 */
void
rt2860_calib(struct rt2860_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	const uint8_t *tssi;
	uint8_t step, bbp49;
	int8_t ridx, d;

	/* read current temperature */
	bbp49 = rt2860_mcu_bbp_read(sc, 49);

	if (IEEE80211_IS_CHAN_2GHZ(ic->ic_bss->ni_chan)) {
		tssi = &sc->tssi_2ghz[4];
		step = sc->step_2ghz;
	} else {
		tssi = &sc->tssi_5ghz[4];
		step = sc->step_5ghz;
	}

	if (bbp49 < tssi[0]) {		/* lower than reference */
		/* use higher Tx power than default */
		for (d = 0; d > -4 && bbp49 <= tssi[d - 1]; d--);
	} else if (bbp49 > tssi[0]) {	/* greater than reference */
		/* use lower Tx power than default */
		for (d = 0; d < +4 && bbp49 >= tssi[d + 1]; d++);
	} else {
		/* use default Tx power */
		d = 0;
	}
	d *= step;

	DPRINTF(("BBP49=0x%02x, adjusting Tx power by %d\n", bbp49, d));

	/* write adjusted Tx power values for each Tx rate */
	for (ridx = 0; ridx < 5; ridx++) {
		if (sc->txpow20mhz[ridx] == 0xffffffff)
			continue;
		RAL_WRITE(sc, RT2860_TX_PWR_CFG(ridx),
		    b4inc(sc->txpow20mhz[ridx], d));
	}
}

void
rt3090_set_rx_antenna(struct rt2860_softc *sc, int aux)
{
	uint32_t tmp;
	if (aux) {
		if (sc->mac_ver == 0x5390) {
			rt2860_mcu_bbp_write(sc, 152,
			    rt2860_mcu_bbp_read(sc, 152) & ~0x80);
		} else {
			tmp = RAL_READ(sc, RT2860_PCI_EECTRL);
			RAL_WRITE(sc, RT2860_PCI_EECTRL,
			    tmp & ~RT2860_C);
			tmp = RAL_READ(sc, RT2860_GPIO_CTRL);
			RAL_WRITE(sc, RT2860_GPIO_CTRL,
			    (tmp & ~0x0808) | 0x08);
		}
	} else {
		if (sc->mac_ver == 0x5390) {
			rt2860_mcu_bbp_write(sc, 152,
			    rt2860_mcu_bbp_read(sc, 152) | 0x80);
		} else {
			tmp = RAL_READ(sc, RT2860_PCI_EECTRL);
			RAL_WRITE(sc, RT2860_PCI_EECTRL,
			    tmp | RT2860_C);
			tmp = RAL_READ(sc, RT2860_GPIO_CTRL);
			RAL_WRITE(sc, RT2860_GPIO_CTRL,
			    tmp & ~0x0808);
		}
	}
}

void
rt2860_switch_chan(struct rt2860_softc *sc, struct ieee80211_channel *c)
{
	struct ieee80211com *ic = &sc->sc_ic;
	u_int chan, group;

	chan = ieee80211_chan2ieee(ic, c);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return;

	if (sc->mac_ver >= 0x5390)
		rt5390_set_chan(sc, chan);
	else if (sc->mac_ver >= 0x3071)
		rt3090_set_chan(sc, chan);
	else
		rt2860_set_chan(sc, chan);

	/* determine channel group */
	if (chan <= 14)
		group = 0;
	else if (chan <= 64)
		group = 1;
	else if (chan <= 128)
		group = 2;
	else
		group = 3;

	/* XXX necessary only when group has changed! */
	if (sc->mac_ver <= 0x5390)
		rt2860_select_chan_group(sc, group);

	DELAY(1000);
}

#ifndef IEEE80211_STA_ONLY
int
rt2860_setup_beacon(struct rt2860_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rt2860_txwi txwi;
	struct mbuf *m;
	int ridx;

	if ((m = ieee80211_beacon_alloc(ic, ic->ic_bss)) == NULL)
		return ENOBUFS;

	memset(&txwi, 0, sizeof txwi);
	txwi.wcid = 0xff;
	txwi.len = htole16(m->m_pkthdr.len);
	/* send beacons at the lowest available rate */
	ridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
	    RT2860_RIDX_OFDM6 : RT2860_RIDX_CCK1;
	txwi.phy = htole16(rt2860_rates[ridx].mcs);
	if (rt2860_rates[ridx].phy == IEEE80211_T_OFDM)
		txwi.phy |= htole16(RT2860_PHY_OFDM);
	txwi.txop = RT2860_TX_TXOP_HT;
	txwi.flags = RT2860_TX_TS;
	txwi.xflags = RT2860_TX_NSEQ;

	RAL_WRITE_REGION_1(sc, RT2860_BCN_BASE(0),
	    (uint8_t *)&txwi, sizeof txwi);
	RAL_WRITE_REGION_1(sc, RT2860_BCN_BASE(0) + sizeof txwi,
	    mtod(m, uint8_t *), m->m_pkthdr.len);

	m_freem(m);

	return 0;
}
#endif

void
rt2860_enable_tsf_sync(struct rt2860_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;

	tmp = RAL_READ(sc, RT2860_BCN_TIME_CFG);

	tmp &= ~0x1fffff;
	tmp |= ic->ic_bss->ni_intval * 16;
	tmp |= RT2860_TSF_TIMER_EN | RT2860_TBTT_TIMER_EN;
	if (ic->ic_opmode == IEEE80211_M_STA) {
		/*
		 * Local TSF is always updated with remote TSF on beacon
		 * reception.
		 */
		tmp |= 1 << RT2860_TSF_SYNC_MODE_SHIFT;
	}
#ifndef IEEE80211_STA_ONLY
	else if (ic->ic_opmode == IEEE80211_M_IBSS) {
		tmp |= RT2860_BCN_TX_EN;
		/*
		 * Local TSF is updated with remote TSF on beacon reception
		 * only if the remote TSF is greater than local TSF.
		 */
		tmp |= 2 << RT2860_TSF_SYNC_MODE_SHIFT;
	} else if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
		tmp |= RT2860_BCN_TX_EN;
		/* SYNC with nobody */
		tmp |= 3 << RT2860_TSF_SYNC_MODE_SHIFT;
	}
#endif

	RAL_WRITE(sc, RT2860_BCN_TIME_CFG, tmp);
}
@


1.93
log
@Add support for Ralink RT5360.  From Kevin Lo who tested with a
D-Link DWA-525 rev A2.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.92 2017/01/22 10:17:38 dlg Exp $	*/
d2854 2
a2855 1
	tmp |= (ic->ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;
@


1.92
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.91 2016/08/17 11:50:52 stsp Exp $	*/
d3109 1
@


1.91
log
@Add support for RT5390 and RT5392 chipsets to the ral(4) driver.

Tested by procter@@ on RT2860 and by me on RT2790 and RT3090.
Ported from FreeBSD by James Hastings.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.90 2016/04/13 10:49:26 mpi Exp $	*/
a1174 2

			ifp->if_opackets++;
@


1.90
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.89 2016/03/21 21:16:30 stsp Exp $	*/
d20 1
a20 1
 * Ralink Technology RT2860/RT3090/RT3390/RT3562 chipset driver
d124 1
d126 1
d128 1
d146 1
a146 1
const char *	rt2860_get_rf(uint8_t);
d149 1
d175 2
d199 4
d2099 3
d2309 101
d2526 73
d2664 36
d2788 6
a2793 4
	for (i = 0; i < 10; i++) {
		if (sc->rf[i].reg == 0 || sc->rf[i].reg == 0xff)
			continue;
		rt3090_rf_write(sc, sc->rf[i].reg, sc->rf[i].val);
d3097 1
a3097 1
rt2860_get_rf(uint8_t rev)
d3111 2
d3194 3
a3196 19
	if (val == 0xffff) {
		DPRINTF(("invalid EEPROM antenna info, using default\n"));
		if (sc->mac_ver == 0x3593) {
			/* default to RF3053 3T3R */
			sc->rf_rev = RT3070_RF_3053;
			sc->ntxchains = 3;
			sc->nrxchains = 3;
		} else if (sc->mac_ver >= 0x3071) {
			/* default to RF3020 1T1R */
			sc->rf_rev = RT3070_RF_3020;
			sc->ntxchains = 1;
			sc->nrxchains = 1;
		} else {
			/* default to RF2820 1T2R */
			sc->rf_rev = RT2860_RF_2820;
			sc->ntxchains = 1;
			sc->nrxchains = 2;
		}
	} else {
d3198 2
a3199 3
		sc->ntxchains = (val >> 4) & 0xf;
		sc->nrxchains = val & 0xf;
	}
d3236 6
a3241 4
		val = rt2860_srom_read(sc,
		    RT2860_EEPROM_PWR2GHZ_BASE2 + i / 2);
		sc->txpow2[i + 0] = (int8_t)(val & 0xff);
		sc->txpow2[i + 1] = (int8_t)(val >> 8);
d3245 8
a3252 4
		if (sc->txpow1[i] < 0 || sc->txpow1[i] > 31)
			sc->txpow1[i] = 5;
		if (sc->txpow2[i] < 0 || sc->txpow2[i] > 31)
			sc->txpow2[i] = 5;
d3438 7
a3444 3
	for (i = 0; i < nitems(rt2860_def_bbp); i++) {
		rt2860_mcu_bbp_write(sc, rt2860_def_bbp[i].reg,
		    rt2860_def_bbp[i].val);
d3463 38
d3636 3
a3638 1
	if (sc->mac_ver >= 0x3071) {
d3734 2
a3735 1
	    sc->rf_rev == RT3070_RF_3320)
d3743 3
a3745 1
	if (sc->mac_ver >= 0x3071)
d3751 3
a3753 1
	if (sc->mac_ver >= 0x3071)
a3959 1

d3961 11
a3971 4
		tmp = RAL_READ(sc, RT2860_PCI_EECTRL);
		RAL_WRITE(sc, RT2860_PCI_EECTRL, tmp & ~RT2860_C);
		tmp = RAL_READ(sc, RT2860_GPIO_CTRL);
		RAL_WRITE(sc, RT2860_GPIO_CTRL, (tmp & ~0x0808) | 0x08);
d3973 11
a3983 4
		tmp = RAL_READ(sc, RT2860_PCI_EECTRL);
		RAL_WRITE(sc, RT2860_PCI_EECTRL, tmp | RT2860_C);
		tmp = RAL_READ(sc, RT2860_GPIO_CTRL);
		RAL_WRITE(sc, RT2860_GPIO_CTRL, tmp & ~0x0808);
d3997 3
a3999 1
	if (sc->mac_ver >= 0x3071)
d4015 2
a4016 1
	rt2860_select_chan_group(sc, group);
@


1.89
log
@In ral(4) RT2860 code, replace custom defrag with m_defrag().

This fixes an error in the existing code: the "hopeless case" guard
equivales 'ring now full', so oactive is never set: the code drops any mbuf
that would fill the ring. This occurs often in practice.

The new code avoids some hoop-jumping. Currently, one tx dma-map can fill
the tx ring. Therefore an mbuf that fits a dma-map may yet not fit into the tx
ring's remaining space.  To be sure it can, we must in general count the
mbuf's fragments and, if necessary, defrag it and reload the dmamap.

Patch by Richard Procter via bugs@@
Tested by Richard on RT2860 and by me on RT3090 and RT2700.
ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.88 2016/03/21 21:16:01 stsp Exp $	*/
a337 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.88
log
@Fix watchdog timeouts and dropped frames under load with RT2860 ral(4).

On full tx ring, ring->cur wraps to an active tx descriptor. Passing
that wrapped value to the card was observed to cause general flakiness.
Fix prevents the wrap at the cost of reducing usable tx descriptors by one.

Patch by Richard Procter via bugs@@
Tested by Richard on RT2860 and by me on RT3090 and RT2700.
ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.87 2016/01/05 18:41:15 stsp Exp $	*/
d570 1
a570 1
		    &data->map);
d1174 1
a1174 1
	if (ring->queued < RT2860_TX_RING_MAX)
a1483 1
	struct mbuf *m1;
d1488 1
a1488 1
	int nsegs, ntxds, hasqos, ridx, ctl_ridx, error;
d1608 1
a1608 11
	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
	    BUS_DMA_NOWAIT);
	if (__predict_false(error != 0 && error != EFBIG)) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m);
		return error;
	}
	if (__predict_true(error == 0)) {
		/* determine how many TXDs are required */
		ntxds = 1 + (data->map->dm_nsegs / 2);
d1610 19
a1628 45
		if (ring->queued + ntxds >= RT2860_TX_RING_MAX) {
			/* not enough free TXDs, force mbuf defrag */
			bus_dmamap_unload(sc->sc_dmat, data->map);
			error = EFBIG;
		}
	}
	if (__predict_false(error != 0)) {
		/* too many fragments, linearize */
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
			m_freem(m);
			return ENOBUFS;
		}
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(m1);
				return ENOBUFS;
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_pkthdr.len = m1->m_len = m->m_pkthdr.len;
		m_freem(m);
		m = m1;

		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
		    BUS_DMA_NOWAIT);
		if (__predict_false(error != 0)) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m);
			return error;
		}

		/* determine how many TXDs are now required */
		ntxds = 1 + (data->map->dm_nsegs / 2);

		if (ring->queued + ntxds >= RT2860_TX_RING_MAX) {
			/* this is a hopeless case, drop the mbuf! */
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(m);
			return ENOBUFS;
		}
	}
d1679 2
a1680 2
	ring->queued += ntxds;
	if (ring->queued >= RT2860_TX_RING_MAX)
d1737 1
@


1.87
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.86 2015/12/11 16:07:01 mpi Exp $	*/
d1174 1
a1174 1
	if (ring->queued < RT2860_TX_RING_COUNT)
d1621 1
a1621 1
		if (ring->queued + ntxds >= RT2860_TX_RING_COUNT) {
d1659 1
a1659 1
		if (ring->queued + ntxds >= RT2860_TX_RING_COUNT) {
d1717 1
a1717 1
	if (ring->queued >= RT2860_TX_RING_COUNT)
@


1.86
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.85 2015/11/25 03:09:58 dlg Exp $	*/
a347 1
#ifndef IEEE80211_NO_HT
a349 1
#endif
a875 1
#ifndef IEEE80211_NO_HT
a903 1
#endif
@


1.85
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.84 2015/11/24 13:33:17 mpi Exp $	*/
d70 1
a70 1
void		rt2860_attachhook(void *);
d261 1
a261 4
	if (rootvp == NULL)
		mountroothook_establish(rt2860_attachhook, sc);
	else
		rt2860_attachhook(sc);
d272 1
a272 1
rt2860_attachhook(void *xsc)
d274 1
a274 1
	struct rt2860_softc *sc = xsc;
@


1.84
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.83 2015/11/04 12:11:59 dlg Exp $	*/
d1183 1
a1183 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1741 1
a1741 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1746 1
a1746 1
			ifp->if_flags |= IFF_OACTIVE;
a3590 1
	ifp->if_flags &= ~IFF_OACTIVE;
d3592 1
d3621 2
a3622 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.83
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.82 2015/10/25 12:48:46 mpi Exp $	*/
a47 1
#include <net/if_types.h>
@


1.82
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.81 2015/08/29 20:55:34 deraadt Exp $	*/
d1751 1
a1751 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
d1760 1
a1760 1
		IF_DEQUEUE(&ic->ic_pwrsaveq, m);
@


1.81
log
@firmware sizes are known; use them for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.80 2015/03/14 03:38:47 jsg Exp $	*/
a1817 1
	struct ifaddr *ifa;
a1824 1
		ifa = (struct ifaddr *)data;
a1825 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.80
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.79 2015/02/10 23:25:46 mpi Exp $	*/
d395 1
a395 1
		free(sc->ucode, M_DEVBUF, 0);
@


1.79
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.78 2014/12/22 02:28:51 tedu Exp $	*/
a45 1
#include <net/if_arp.h>
@


1.78
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.77 2014/12/19 22:44:58 guenther Exp $	*/
a1294 1
		m->m_pkthdr.rcvif = ifp;
@


1.77
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.76 2014/11/18 02:37:30 tedu Exp $	*/
a1829 1
#ifdef INET
a1831 1
#endif
@


1.76
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.75 2014/09/06 05:41:35 jsg Exp $	*/
d37 1
a39 1
#include <machine/endian.h>
@


1.75
log
@reduce the amount of pci includes
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.74 2014/07/22 13:12:12 mpi Exp $	*/
a61 2

#include <dev/rndvar.h>
@


1.74
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.73 2014/07/12 18:48:17 tedu Exp $	*/
a60 2
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
@


1.73
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.72 2014/03/19 10:09:19 mpi Exp $	*/
a51 1
#include <netinet/in_systm.h>
a52 1
#include <netinet/ip.h>
@


1.72
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.71 2013/12/06 21:03:03 deraadt Exp $	*/
d402 1
a402 1
		free(sc->ucode, M_DEVBUF);
@


1.71
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.70 2013/08/07 01:06:30 bluhm Exp $	*/
d1761 1
a1761 1
			ni = (void *)m->m_pkthdr.rcvif;
d1770 1
a1770 1
			ni = (void *)m->m_pkthdr.rcvif;
@


1.70
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.69 2013/08/01 09:17:02 kettenis Exp $	*/
d418 1
a418 1
rt2860_resume(void *xsc)
@


1.69
log
@Add support for the RT3572 MAC/BBP.  Crucial bits from Nathan Goings.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.68 2013/06/11 18:15:53 deraadt Exp $	*/
a52 1
#include <netinet/in_var.h>
@


1.68
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.67 2012/10/12 19:53:24 haesbaert Exp $	*/
d200 2
d2163 3
a2165 1
		if (sc->ext_5ghz_lna) {
d2167 2
d2170 1
a2170 2
		} else {
			rt2860_mcu_bbp_write(sc, 82, 0xf2);
a2171 1
		}
d2198 6
a2203 1
	RAL_WRITE(sc, RT2860_TX_PIN_CFG, tmp);
d2227 4
a2230 1
		agc = 0x32 + (sc->lna[group] * 5) / 3;
d2382 10
a2391 3
	for (i = 0; i < nitems(rt3090_def_rf); i++) {
		rt3090_rf_write(sc, rt3090_def_rf[i].reg,
		    rt3090_def_rf[i].val);
@


1.67
log
@Cleanup false positives for uninitialized uses.
Part of the work to remove -Wno-uninitialized.

ok blambert jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.66 2012/10/11 09:43:22 kettenis Exp $	*/
d1315 1
a1315 1
			ovbcopy(wh, (caddr_t)wh + 2, hdrlen);
@


1.66
log
@Enable Host AP power saving support for the RT2700, RT2800 and RT3090 chipsets.

Tested by Nathanael Rensen.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.65 2010/10/23 14:24:54 damien Exp $	*/
d1518 1
@


1.65
log
@fix the two extremely retarded bugs that prevented the RT30XX
devices to work.
shame on me.

committed over an RT3071.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.64 2010/09/07 16:21:42 deraadt Exp $	*/
a305 1
#ifdef notyet
a306 1
#endif
@


1.64
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.63 2010/09/06 19:20:22 deraadt Exp $	*/
a69 2
#define RAL_DEBUG

d227 1
a227 5
#ifdef RAL_DEBUG
	/* temporarily enable debug for >=RT3071 */
	if (sc->mac_ver >= 0x3071)
		rt2860_debug = 10;
#endif
d1018 2
a1019 1
		if (!(RAL_READ(sc, RT3070_EFUSE_CTRL) & RT3070_EFSROM_KICK))
d2006 2
a2007 1
		if (!(RAL_READ(sc, RT3070_RF_CSR_CFG) & RT3070_RF_KICK))
@


1.63
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.62 2010/08/28 18:08:07 deraadt Exp $	*/
a168 1
void		rt2860_powerhook(int, void *);
a278 6
	sc->sc_powerhook = powerhook_establish(rt2860_powerhook, sc);
	if (sc->sc_powerhook == NULL) {
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);
	}

a399 3
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);

a3854 18
}

void
rt2860_powerhook(int why, void *arg)
{
	struct rt2860_softc *sc = arg;
	int s;

	s = splnet();
	switch (why) {
	case DVACT_SUSPEND:
		rt2860_suspend(sc);
		break;
	case DVACT_RESUME:
		rt2860_resume(sc);
		break;
	}
	splx(s);
@


1.62
log
@rename the *_power functions to *_powerhook to indicate that we've been
here already for the activate/powerhook cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.61 2010/08/27 17:08:00 jsg Exp $	*/
d3875 1
a3875 1
	case PWR_SUSPEND:
d3878 1
a3878 1
	case PWR_RESUME:
@


1.61
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.60 2010/08/27 16:06:25 kettenis Exp $	*/
d169 1
a169 1
void		rt2860_power(int, void *);
d280 1
a280 1
	sc->sc_powerhook = powerhook_establish(rt2860_power, sc);
d3868 1
a3868 1
rt2860_power(int why, void *arg)
@


1.60
log
@Stop calling xxx_power() from xxx_resume(); instead do it the other way around.
Get rid of the sc_power() callback, which isn't used anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.59 2010/08/27 04:09:18 deraadt Exp $	*/
a359 1
	ifp->if_init = rt2860_init;
@


1.59
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.58 2010/08/25 21:37:59 kettenis Exp $	*/
d439 1
d441 2
a442 1
	rt2860_power(PWR_RESUME, sc);
a3871 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d3877 1
a3877 3
		rt2860_stop(ifp, 0);
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
d3880 1
a3880 5
		if (ifp->if_flags & IFF_UP) {
			rt2860_init(ifp);
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, why);
		}
@


1.58
log
@Make CardBus ral(4) suspend and resume properly on machines that keep the
CardBus bridge powered up during suspend.  Step zero on the long road
towards fully suspending CardBus on all machines.

ok deraadt@@, damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.57 2010/08/04 19:48:33 damien Exp $	*/
a3875 1
	case PWR_STANDBY:
@


1.57
log
@add suspend/resume support for PCI ral(4) devices.

ok deraadt@@, sthen@@

tested by matthew@@ (RT2560), dcoppa@@ (RT2790), okan@@ (RT2860), todd@@ (RT2560)
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.56 2010/07/19 19:47:52 damien Exp $	*/
d432 1
a432 1
		rt2860_stop(ifp, 0);
@


1.56
log
@store the WCID in the rt2860_node structure at association time
and use this later instead of converting ni_associd into WCID each
time we need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.55 2010/07/19 19:22:46 damien Exp $	*/
d81 1
d210 1
a210 2
	struct ifnet *ifp = &ic->ic_if;
	int i, qid, ntries, error;
d275 34
a398 13

	sc->sc_powerhook = powerhook_establish(rt2860_power, sc);
	if (sc->sc_powerhook == NULL) {
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);
	}

	return 0;

fail2:	rt2860_free_rx_ring(sc, &sc->rxq);
fail1:	while (--qid >= 0)
		rt2860_free_tx_ring(sc, &sc->txq[qid]);
	return error;
d419 3
d425 18
d3385 5
a3389 8
	if (!(sc->sc_flags & RT2860_FWLOADED)) {
		if ((error = rt2860_load_microcode(sc)) != 0) {
			printf("%s: could not load 8051 microcode\n",
			    sc->sc_dev.dv_xname);
			rt2860_stop(ifp, 1);
			return error;
		}
		sc->sc_flags |= RT2860_FWLOADED;
d3662 1
a3662 1
			sc->sc_flags &= ~(RT2860_ENABLED | RT2860_FWLOADED);
d3670 1
a3670 9
	u_char *ucode;
	size_t size;
	int error, ntries;

	if ((error = loadfirmware("ral-rt2860", &ucode, &size)) != 0) {
		printf("%s: error %d, could not read firmware file %s\n",
		    sc->sc_dev.dv_xname, error, "ral-rt2860");
		return error;
	}
d3675 1
a3675 1
	RAL_WRITE_REGION_1(sc, RT2860_FW_BASE, ucode, size);
a3683 2
	free(ucode, M_DEVBUF);

d3877 1
a3877 2
		rt2860_stop(ifp, 1);
		sc->sc_flags &= ~RT2860_FWLOADED;
a3885 2
			if (ifp->if_flags & IFF_RUNNING)
				rt2860_start(ifp);
@


1.55
log
@implement the ic_ampdu_rx_{start,stop} callbacks (not used yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.54 2010/07/19 19:08:28 damien Exp $	*/
d763 1
a763 1
	uint8_t wcid;
a764 1
	wcid = RT2860_AID2WCID(ni->ni_associd);
d813 1
a813 1
		wcid = RT2860_AID2WCID(ni->ni_associd);
d856 1
a856 1
	uint8_t wcid;
a858 1
	wcid = RT2860_AID2WCID(ni->ni_associd);
d869 1
a870 1
	uint8_t wcid;
a872 1
	wcid = RT2860_AID2WCID(ni->ni_associd);
d884 1
a885 1
	uint8_t wcid;
a887 1
	wcid = RT2860_AID2WCID(ni->ni_associd);
d1520 1
a1520 2
	txwi->wcid = (type == IEEE80211_FC0_TYPE_DATA) ?
	    RT2860_AID2WCID(ni->ni_associd) : 0xff;
d2747 1
a2747 1
		wcid = RT2860_AID2WCID(ni->ni_associd);
d2830 1
a2830 1
		wcid = RT2860_AID2WCID(ni->ni_associd);
@


1.54
log
@in hostap mode, when a STA leaves the BSS, clear its entry in the
hardware RX WCID search table.
otherwise, if the same STA reassociates later with a different id,
we would have two entries for the same MAC in the table, leading
to problems with key lookups etc...

big thanks to Nathanael Rensen who found the issue.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.53 2010/05/10 18:17:10 damien Exp $	*/
d103 4
d340 4
d862 33
@


1.53
log
@additionnal bits and fixes for RT3090.
some adapters labelled RT3090 have a MAC version equal to RT3071.
still no luck receiving frames on my AzureWave AW-NE762H though :(
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.52 2010/04/20 22:05:43 tedu Exp $	*/
d101 2
d333 3
d843 13
@


1.52
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.51 2010/04/12 18:02:31 damien Exp $	*/
d225 3
a227 3
	/* temporarily enable debug for >=RT3090 */
	if (sc->mac_ver >= 0x3090)
		rt2860_debug = 1;
d915 1
a915 1
/* Read 16-bit from eFUSE ROM (>=RT3090 only.) */
d2131 1
a2131 1
		if (sc->mac_rev >= 0x3090)
d2235 1
a2235 1
		rf |= 1 << 7 | 1 << 5;	/* 1T: disable Tx chains 2 & 3 */
d2237 1
a2237 1
		rf |= 1 << 7;		/* 2T: disable Tx chain 3 */
d2239 1
a2239 1
		rf |= 1 << 6 | 1 << 4;	/* 1R: disable Rx chains 2 & 3 */
d2241 1
a2241 1
		rf |= 1 << 6;		/* 2R: disable Rx chain 3 */
d2259 1
a2259 1
	rt3090_rf_write(sc, 7, rf | 0x01);
d2379 2
a2380 1
		rt3090_rf_write(sc, 1, rf | 0x01);
d2383 2
a2384 1
		rt3090_rf_write(sc, 3, rf | 0x80);
d2387 2
a2388 1
		rt3090_rf_write(sc, 6, rf | 0x40);
d2391 3
a2393 2
		rt3090_rf_write(sc, 2, rf | 0x80);
		/* set reference current control */
d2395 4
a2398 1
		rt3090_rf_write(sc, 22, (rf & ~0xe0) | 0x80);
d2401 2
a2402 1
		rt3090_rf_write(sc, 46, rf | 0x20);
d2404 2
a2405 7
		rt3090_rf_write(sc, 20, rf & ~0xee);

		rf = rt3090_rf_read(sc, 27);
		rf &= ~0x77;
		if (sc->mac_rev < 0x0211)
			rf |= 0x03;
		rt3090_rf_write(sc, 27, rf);
d2409 2
a2410 1
		rt3090_rf_write(sc, 1, rf | 0x01);
d2414 1
d2417 1
d2420 8
a2427 1
		rt3090_rf_write(sc, 21, rf | 0x80);
d2451 1
a2451 1
	rt3090_rf_write(sc, 22, rf22 | 0x01);
d2496 1
a2496 1
	rt3090_rf_write(sc, 22, rf22 & ~0x01);
d2860 1
a2860 1
	if (sc->mac_ver >= 0x3090) {
d2893 1
a2893 1
	if (sc->mac_ver >= 0x3090) {
d2933 1
a2933 1
		} else if (sc->mac_ver >= 0x3090) {
a2965 1

d2972 1
a2972 1
			if (val >> 8 != 0x92 || !(val & 0x80))
d2977 1
d3110 1
a3110 1
	if (sc->mac_ver >= 0x3090) {
d3130 4
a3133 1
	sc->lna[0] = val & 0xff;	/* channel group 0 */
d3190 1
a3190 1
	if (sc->mac_ver >= 0x3090) {
d3277 1
d3279 1
a3283 2
	RAL_WRITE(sc, RT2860_WPDMA_RST_IDX, 0xffffffff);

d3340 13
a3366 8
	if (!(RAL_READ(sc, RT2860_PCI_CFG) & RT2860_PCI_CFG_PCI)) {
		sc->sc_flags |= RT2860_PCIE;
		/* PCIe has different clock cycle count than PCI */
		tmp = RAL_READ(sc, RT2860_US_CYC_CNT);
		tmp = (tmp & ~0xff) | 0x7d;
		RAL_WRITE(sc, RT2860_US_CYC_CNT, tmp);
	}

d3434 3
a3436 1
	if (sc->rf_rev == RT3070_RF_3020)
d3444 1
a3444 1
	if (sc->mac_ver >= 0x3090)
d3450 1
a3450 1
	if (sc->mac_ver >= 0x3090)
d3472 1
a3472 1
	if (sc->mac_ver >= 0x3090)
d3690 1
a3690 1
	if (sc->mac_ver >= 0x3090)
@


1.51
log
@Make hardware generate 802.11 sequence numbers (except for unicast
QoS data frames) such that the same counter is used for beacons,
management frames and non-QoS data frames.
This will help clients that don't like jumps in sequence numbers,
like the FreeBSD duplicate detection code.

Found after an interesting discussion with Yao Zhao.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.50 2010/04/10 07:57:21 damien Exp $	*/
a27 1
#include <sys/sysctl.h>
@


1.50
log
@enable debug mode for >=RT3090
add a wait flag to rt2860_mcu_cmd to wait for command completion
more RT3090 RF initialization code
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.49 2010/04/06 19:40:51 damien Exp $	*/
d1464 2
a1465 1
	txwi->xflags = 0;
d3712 1
@


1.49
log
@always enable both 2GHz and 5GHz LNAs regardless of the band
we're using.  fixes operation on some 5GHz channels (e.g 153).

great thanks to Yao Zhao (dragonlinux at gmail dot com) for
identifying the issue on run(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.48 2010/04/06 16:49:08 damien Exp $	*/
d71 2
d76 1
a76 1
int rt2860_debug = 1;
d122 1
a122 1
int		rt2860_mcu_cmd(struct rt2860_softc *, uint8_t, uint16_t);
d130 1
d225 5
a229 1

d739 3
a741 1
	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
d743 1
a743 1

d1728 1
d1802 2
a1803 1
		    (IFF_UP | IFF_RUNNING))
d1805 1
d1839 1
a1839 1
	(void)rt2860_mcu_cmd(sc, RT2860_MCU_CMD_BBP, 0);
d1864 1
a1864 1
	(void)rt2860_mcu_cmd(sc, RT2860_MCU_CMD_BBP, 0);
d1960 1
a1960 1
rt2860_mcu_cmd(struct rt2860_softc *sc, uint8_t cmd, uint16_t arg)
d1962 3
a1964 1
	int ntries;
d1974 2
a1975 2
	RAL_WRITE(sc, RT2860_H2M_MAILBOX,
	    RT2860_H2M_BUSY | RT2860_TOKEN_NO_INTR << 16 | arg);
d1979 28
a2006 1
	return 0;
d2370 53
d2521 2
a2522 2
	(void)rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LEDS,
	    which | (sc->leds & 0x7f));
a3249 2
	rt2860_stop(ifp, 0);

d3316 2
d3350 3
d3417 3
a3419 3
	(void)rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LED1, sc->led[0]);
	(void)rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LED2, sc->led[1]);
	(void)rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LED3, sc->led[2]);
d3424 6
d3457 1
a3457 1
	(void)rt2860_mcu_cmd(sc, RT2860_MCU_CMD_RFRESET, 0);
d3484 1
a3484 1
		(void)rt2860_mcu_cmd(sc, RT2860_MCU_CMD_PSLEVEL, sc->pslevel);
@


1.48
log
@on devices that have a radio switch, check GPIO pin 2 and report
that the radio is disabled with the same message as in other drivers.

let initialization continue for the moment until i'm sure it is correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.47 2010/04/06 16:41:54 damien Exp $	*/
d2053 5
a2057 1
	tmp = RT2860_RFTR_EN | RT2860_TRSW_EN;
d2059 1
a2059 1
		tmp |= RT2860_PA_PE_G0_EN | RT2860_LNA_PE_G0_EN;
a2063 4
		if (sc->nrxchains > 1)
			tmp |= RT2860_LNA_PE_G1_EN;
		if (sc->mac_ver == 0x3593 && sc->nrxchains > 2)
			tmp |= RT3593_LNA_PE_G2_EN;
d2065 1
a2065 1
		tmp |= RT2860_PA_PE_A0_EN | RT2860_LNA_PE_A0_EN;
a2069 4
		if (sc->nrxchains > 1)
			tmp |= RT2860_LNA_PE_A1_EN;
		if (sc->mac_ver == 0x3593 && sc->nrxchains > 2)
			tmp |= RT3593_LNA_PE_A2_EN;
@


1.47
log
@On RT3090 chips, read vendor RF settings from ROM and apply them.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.45 2010/04/05 19:00:50 damien Exp $	*/
d3162 12
a3665 2

	DPRINTF(("%s: rt2860_power(%d)\n", sc->sc_dev.dv_xname, why));
@


1.46
log
@Give rt3090_efuse_read_2() a chance to work by using the correct offset.

Found after jbg@@ sent me a horrible dmesg.
@
text
@d130 1
d2399 30
d2783 1
a2783 1
	/* read default BBP settings */
d2790 10
d3331 5
a3335 1
		bbp1 &= ~(1 << 3 | 1 << 4);
d3337 3
@


1.45
log
@fix regression on RT2860C introduced in previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.44 2010/04/05 14:14:02 damien Exp $	*/
d914 1
d931 1
a931 1
	if (ntries == 100)
@


1.44
log
@Initial bits for >=RT3090 support.
Probably not functionnal yet (but test reports are welcome).

Update microcode for RT2860 while I'm here (remember to run
make && make install under sys/dev/microcode/ral/).
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.43 2010/04/04 08:07:50 damien Exp $	*/
d3042 5
a3046 2
	/* fix BBP69 and BBP73 for RT2860C */
	if (sc->mac_ver == 0x2860 && sc->mac_rev != 0x0100) {
@


1.43
log
@Fix 5GHz channels TX power settings for RT2860/RT2870 (does not
affect RT3572.)

Found (again!) by Yao Zhao (dragonlinux at gmail dot com)
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.42 2010/03/27 16:13:24 damien Exp $	*/
d4 1
a4 2
 * Copyright (c) 2007, 2008
 *	Damien Bergamini <damien.bergamini@@free.fr>
d20 1
a20 1
 * Ralink Technology RT2860 chipset driver
d102 2
a103 1
uint16_t	rt2860_eeprom_read(struct rt2860_softc *, uint8_t);
d118 2
d125 5
a129 2
void		rt2860_set_chan(struct rt2860_softc *,
		    struct ieee80211_channel *);
d152 3
d182 13
d202 1
d209 2
a210 2
		sc->mac_rev = RAL_READ(sc, RT2860_ASIC_VER_ID);
		if (sc->mac_rev != 0 && sc->mac_rev != 0xffffffff)
d219 4
a222 1
	if ((sc->mac_rev >> 16) != 0x2860 &&
d232 1
a232 1
	    sc->sc_dev.dv_xname, sc->mac_rev >> 16, sc->mac_rev & 0xffff,
d259 2
a260 1
	sc->mgtqid = (sc->mac_rev == 0x28600100) ? EDCA_AC_VO : 5;
d397 1
a397 1
	    &nsegs, BUS_DMA_NOWAIT);
a417 1
	memset(ring->txd, 0, size);
d506 1
a506 1
	    &sc->txwi_seg, 1, &nsegs, BUS_DMA_NOWAIT);
a526 1
	memset(sc->txwi_vaddr, 0, size);
d595 1
a595 1
	    &nsegs, BUS_DMA_NOWAIT);
a615 1
	memset(ring->rxd, 0, size);
d630 1
a630 1
		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
a636 7
		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate Rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOBUFS;
			goto fail;
		}
d857 1
a857 1
		rt2860_set_chan(sc, ic->ic_bss->ni_chan);
d865 1
a865 1
		rt2860_set_chan(sc, ic->ic_bss->ni_chan);
d870 1
a870 1
		rt2860_set_chan(sc, ic->ic_bss->ni_chan);
d906 37
d948 1
a948 1
rt2860_eeprom_read(struct rt2860_softc *sc, uint8_t addr)
d1001 7
d1168 1
a1168 1
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
a1172 6
		MCLGET(m1, M_DONTWAIT);
		if (__predict_false(!(m1->m_flags & M_EXT))) {
			m_freem(m1);
			ifp->if_ierrors++;
			goto skip;
		}
d1779 1
a1779 1
				rt2860_set_chan(sc, ic->ic_ibss_chan);
d1890 52
d2020 1
d2056 2
d2060 2
d2066 2
d2070 2
d2075 15
d2091 11
a2101 4
	if (group == 0)
		rt2860_mcu_bbp_write(sc, 66, 0x2e + sc->lna[0]);
	else
		rt2860_mcu_bbp_write(sc, 66, 0x32 + (sc->lna[group] * 5) / 3);
d2105 1
a2105 1
rt2860_set_chan(struct rt2860_softc *sc, struct ieee80211_channel *c)
a2106 1
	struct ieee80211com *ic = &sc->sc_ic;
d2110 1
a2110 5
	u_int i, chan, group;

	chan = ieee80211_chan2ieee(ic, c);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return;
d2126 1
a2126 1
	if (IEEE80211_IS_CHAN_5GHZ(c)) {
d2157 17
d2175 65
a2239 7
	/* determine channel group */
	if (chan <= 14)
		group = 0;
	else if (chan <= 64)
		group = 1;
	else if (chan <= 128)
		group = 2;
d2241 133
a2373 1
		group = 3;
d2375 17
a2391 2
	/* XXX necessary only when group has changed! */
	rt2860_select_chan_group(sc, group);
d2393 1
a2393 1
	DELAY(1000);
d2426 1
a2426 1
	RAL_WRITE(sc, RT2860_INT_TIMER_EN, tmp  | RT2860_GP_TIMER_EN);
d2703 7
d2718 2
a2720 1
	int8_t delta_2ghz, delta_5ghz;
d2723 9
d2733 1
a2733 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_VERSION);
d2737 1
a2737 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_MAC01);
d2740 1
a2740 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_MAC23);
d2743 1
a2743 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_MAC45);
d2748 1
a2748 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_COUNTRY);
d2753 1
a2753 1
		val = rt2860_eeprom_read(sc, RT2860_EEPROM_BBP_BASE + i);
d2760 1
a2760 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_FREQ_LEDS);
d2763 1
a2763 2

	if ((sc->leds = val >> 8) != 0xff) {
d2765 4
a2768 3
		sc->led[0] = rt2860_eeprom_read(sc, RT2860_EEPROM_LED1);
		sc->led[1] = rt2860_eeprom_read(sc, RT2860_EEPROM_LED2);
		sc->led[2] = rt2860_eeprom_read(sc, RT2860_EEPROM_LED3);
d2780 1
a2780 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_ANTENNA);
a2781 1
		/* broken EEPROM, default to RF2820 1T2R */
d2783 16
a2798 3
		sc->rf_rev = RT2860_RF_2820;
		sc->ntxchains = 1;
		sc->nrxchains = 2;
d2808 1
a2808 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_CONFIG);
d2810 3
d2816 1
d2818 2
d2824 1
a2824 1
		val = rt2860_eeprom_read(sc, RT2860_EEPROM_PCIE_PSLEVEL);
d2827 1
a2827 1
			val = rt2860_eeprom_read(sc, RT2860_EEPROM_REV);
d2835 1
a2835 1
		val = rt2860_eeprom_read(sc,
d2840 1
a2840 1
		val = rt2860_eeprom_read(sc,
d2856 1
a2856 1
		val = rt2860_eeprom_read(sc,
d2861 1
a2861 1
		val = rt2860_eeprom_read(sc,
d2878 1
a2878 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_DELTAPWR);
d2897 1
a2897 1
		val = rt2860_eeprom_read(sc, RT2860_EEPROM_RPWR + ridx * 2);
d2899 1
a2899 1
		val = rt2860_eeprom_read(sc, RT2860_EEPROM_RPWR + ridx * 2 + 1);
d2912 1
a2912 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI1_2GHZ);
d2915 1
a2915 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI2_2GHZ);
d2918 1
a2918 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI3_2GHZ);
d2921 1
a2921 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI4_2GHZ);
d2924 1
a2924 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI5_2GHZ);
d2936 1
a2936 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI1_5GHZ);
d2939 1
a2939 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI2_5GHZ);
d2942 1
a2942 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI3_5GHZ);
d2945 1
a2945 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI4_5GHZ);
d2948 1
a2948 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_TSSI5_5GHZ);
d2961 1
a2961 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_RSSI1_2GHZ);
d2964 11
a2974 2
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_RSSI2_2GHZ);
	sc->rssi_2ghz[2] = val & 0xff;	/* Ant C */
d2977 1
a2977 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_RSSI1_5GHZ);
d2980 1
a2980 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_RSSI2_5GHZ);
d2984 1
a2984 1
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_LNA);
d3039 1
a3039 1
	if ((sc->mac_rev & 0xffff) != 0x0101)
d3043 1
a3043 1
	if (sc->mac_rev == 0x28600100) {
d3191 8
d3262 4
d3271 3
d3291 1
a3291 1
	rt2860_set_chan(sc, ic->ic_ibss_chan);
d3474 49
@


1.42
log
@Fix TX power per rate settings.

Found by Yao Zhao (dragonlinux at gmail dot com)
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.41 2010/02/08 18:46:47 damien Exp $	*/
d1996 1
a1996 1
			txpow1 = txpow1 << 1;
d1998 1
a1998 1
			txpow1 = (7 + txpow1) << 1 | 1;
d2000 1
a2000 1
			txpow2 = txpow2 << 1;
d2002 1
a2002 1
			txpow2 = (7 + txpow2) << 1 | 1;
@


1.41
log
@add the 10us sifs directly to the pre-computed ack durations.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.40 2010/02/08 18:26:31 damien Exp $	*/
d2508 4
a2511 4
		val = rt2860_eeprom_read(sc, RT2860_EEPROM_RPWR + ridx);
		reg = (uint32_t)val << 16;
		val = rt2860_eeprom_read(sc, RT2860_EEPROM_RPWR + ridx + 1);
		reg |= val;
@


1.40
log
@s/RT2860_MCU_CMD_BOOT/RT2860_MCU_CMD_RFRESET/
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.39 2010/02/07 09:14:55 damien Exp $	*/
d1440 1
a1440 1
		*(uint16_t *)wh->i_dur = htole16(dur + sc->sifs);
a2024 3

	/* 802.11a uses a 16 microseconds short interframe space */
	sc->sifs = IEEE80211_IS_CHAN_5GHZ(c) ? 16 : 10;
@


1.39
log
@add channels 167, 169, 171, 173 for dual-band devices
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.38 2009/12/10 21:01:29 oga Exp $	*/
d2883 2
a2884 2
	/* XXX not clear what the following 8051 command does.. */
	(void)rt2860_mcu_cmd(sc, RT2860_MCU_CMD_BOOT, 0);
@


1.38
log
@fix a theoretical (but not possible) array bound overflow.

since we will always match on a rate, we won't overflow, but in that
case, make it more obvious by if the first 11 rates don't match, we
assume the 12th.

should shut up parfait.

ok damien@@ who came up with an identical diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.37 2009/11/03 17:36:58 damien Exp $	*/
d2469 1
a2469 1
	for (i = 0; i < 36; i += 2) {
d2481 1
a2481 1
	for (i = 0; i < 36; i++) {
@


1.37
log
@setting of WEP keys is defered until interface is brought up,
so do nothing in set_key() if the interface is not up and running.

fixes a panic reported by Steph (frlinux at gmail dot com) with
run(4) on misc
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.36 2009/11/01 12:08:36 damien Exp $	*/
d792 1
a792 1
		for (ridx = 0; ridx <= RT2860_RIDX_MAX; ridx++)
@


1.36
log
@call powerhook_disestablish() and pci_intr_disestablish() earlier.

diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.35 2009/08/10 17:47:23 damien Exp $	*/
d2180 5
a2898 6
	if (ic->ic_flags & IEEE80211_F_WEPON) {
		/* install WEP keys */
		for (i = 0; i < IEEE80211_WEP_NKID; i++)
			(void)rt2860_set_key(ic, NULL, &ic->ic_nw_keys[i]);
	}

d2915 6
@


1.35
log
@three more shutdown hooks bite the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.34 2009/05/11 19:20:27 damien Exp $	*/
d341 3
a345 3

	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);
@


1.34
log
@properly set unicast to me mask in MAC_ADDR_DW1 register.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.33 2009/03/29 21:53:52 sthen Exp $	*/
a318 8
	/*
	 * Make sure the interface is shutdown during reboot.
	 */
	sc->sc_sdhook = shutdownhook_establish(rt2860_shutdown, sc);
	if (sc->sc_sdhook == NULL) {
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    sc->sc_dev.dv_xname);
	}
a346 3
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);

a3160 9
}

void
rt2860_shutdown(void *arg)
{
	struct rt2860_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	rt2860_stop(ifp, 1);
@


1.33
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.32 2009/01/26 19:18:52 damien Exp $	*/
d2104 1
a2104 1
	    addr[4] | addr[5] << 8);
@


1.32
log
@I changed the IEEE80211_QOS_ACK_POLICY_* definitions to be more in line
with other net80211 flags (we no longer need to shift.)
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.31 2008/12/29 13:59:00 damien Exp $	*/
d392 1
a392 1
		printf("%s: could not map DMA memory\n", sc->sc_dev.dv_xname);
d502 1
a502 1
		printf("%s: could not map DMA memory\n", sc->sc_dev.dv_xname);
d592 1
a592 1
		printf("%s: could not map DMA memory\n", sc->sc_dev.dv_xname);
d1492 1
a1492 1
		printf("%s: could not map mbuf (error %d)\n",
d1530 1
a1530 1
			printf("%s: could not map mbuf (error %d)\n",
@


1.31
log
@properly update RT2860_TX_RTS_CFG
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.30 2008/12/29 13:27:27 damien Exp $	*/
d1443 1
a1443 2
	    (!hasqos || (qos & IEEE80211_QOS_ACK_POLICY_MASK) >>
	     IEEE80211_QOS_ACK_POLICY_SHIFT !=
@


1.30
log
@move the 802.11 header out of the TXWI structure.
add some definitions for RT2870/RT3070.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.29 2008/12/22 18:20:47 damien Exp $	*/
d2897 1
@


1.29
log
@I swapped MGETHDR arguments in my m_defrag removal commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.28 2008/12/21 18:19:58 damien Exp $	*/
d136 1
d138 1
d475 2
d479 1
a479 1
	size = RT2860_TX_POOL_COUNT * sizeof (struct rt2860_txwi);
d500 1
a500 1
	    (caddr_t *)&sc->txwi, BUS_DMA_NOWAIT);
d506 2
a507 2
	error = bus_dmamap_load(sc->sc_dmat, sc->txwi_map, sc->txwi, size,
	    NULL, BUS_DMA_NOWAIT);
d513 1
a513 1
	memset(sc->txwi, 0, size);
d517 2
d530 4
a533 4

		data->txwi = &sc->txwi[i];
		data->paddr = sc->txwi_map->dm_segs[0].ds_addr +
		    i * sizeof (struct rt2860_txwi);
d547 1
a547 1
	if (sc->txwi != NULL) {
d551 2
a552 2
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->txwi,
		    RT2860_TX_POOL_COUNT * sizeof (struct rt2860_txwi));
d1487 1
a1487 1
	memcpy(&txwi->wh, wh, hdrlen);
d1553 1
a1553 1
	txd->sdl0 = htole16(16 + hdrlen);
d1586 1
a1586 1
	    (caddr_t)txwi - (caddr_t)sc->txwi, sizeof (struct rt2860_txwi),
d1930 19
a1948 1
	rt2860_mcu_bbp_write(sc, 82, (group == 0) ? 0x62 : 0xf2);
d1972 5
a1976 1
	rt2860_mcu_bbp_write(sc, 66, 0x2e + sc->lna[group]);
d2007 8
a2014 2
		txpow1 = txpow1 << 1 | 1;
		txpow2 = txpow2 << 1 | 1;
d2019 4
a2022 4
	rt2860_rf_write(sc, RAL_RF1, rfprog[i].r1);
	rt2860_rf_write(sc, RAL_RF2, r2);
	rt2860_rf_write(sc, RAL_RF3, r3);
	rt2860_rf_write(sc, RAL_RF4, r4);
d2026 4
a2029 4
	rt2860_rf_write(sc, RAL_RF1, rfprog[i].r1);
	rt2860_rf_write(sc, RAL_RF2, r2);
	rt2860_rf_write(sc, RAL_RF3, r3 | 1);
	rt2860_rf_write(sc, RAL_RF4, r4);
d2033 4
a2036 4
	rt2860_rf_write(sc, RAL_RF1, rfprog[i].r1);
	rt2860_rf_write(sc, RAL_RF2, r2);
	rt2860_rf_write(sc, RAL_RF3, r3);
	rt2860_rf_write(sc, RAL_RF4, r4);
d2304 1
d2328 1
d2437 3
a2439 1
	if ((val & 0xff) != 0xff)
d2441 1
d3097 2
a3098 2
	    (uint8_t *)&txwi, 16);
	RAL_WRITE_REGION_1(sc, RT2860_BCN_BASE(0) + 16,
@


1.28
log
@Undo m_defrag().

m_defrag() does not work.  It seems to assume that if the length of
the mbuf passed as parameter is less than MHLEN, then it is an mbuf
header and not a cluster (or something like that.)
It thus fails miserably in the bcopy path.
I don't have the time to investigate further into this.

Thanks to Okan Demirmen for reporting the issue on a ral(4) RT2560.
The RT2560 chipset does not support TX scatter and thus m_defrag()
was called much more often than in other drivers using m_defrag()
where it was less noticeable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.27 2008/12/15 18:35:59 damien Exp $	*/
d1504 1
a1504 1
		MGETHDR(m1, MT_DATA, M_DONTWAIT);
@


1.27
log
@in rt2860_rx_intr(), rely on RT2860_FS_DRX_IDX instead of the RX_DMA DDONE
bit to know when to stop.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.26 2008/12/14 18:41:57 damien Exp $	*/
d1359 1
d1504 2
a1505 1
		if (m_defrag(m, M_DONTWAIT) != 0) {
d1509 13
@


1.26
log
@Disable TX_DMA writing back DDONE into TXD.
Some micro-optimizations while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.25 2008/12/14 10:23:08 damien Exp $	*/
a136 2
uint8_t		rt2860_maxrssi_chain(struct rt2860_softc *,
		    const struct rt2860_rxwi *);
d1048 18
d1075 1
d1084 2
a1085 1
	for (;;) {
d1094 4
a1097 2
		if (!(rxd->sdl0 & htole16(RT2860_RX_DDONE)))
			break;
a2276 18
}

/*
 * Return the Rx chain with the highest RSSI for a given frame.
 */
uint8_t
rt2860_maxrssi_chain(struct rt2860_softc *sc, const struct rt2860_rxwi *rxwi)
{
	uint8_t rxchain = 0;

	if (sc->nrxchains > 1)
		if (rxwi->rssi[1] > rxwi->rssi[rxchain])
			rxchain = 1;
	if (sc->nrxchains > 2)
		if (rxwi->rssi[2] > rxwi->rssi[rxchain])
			rxchain = 2;

	return rxchain;
@


1.25
log
@- properly handle RT2860_TX_RX_COHERENT interrupts.
- update ic_dtim_count and make use of the new ieee80211_notify_dtim function.
- add explicit barriers.
- cleanup as usual.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.24 2008/12/13 14:35:19 damien Exp $	*/
a420 2
		ring->txd[i].sdl0 &= ~htole16(RT2860_TX_DDONE);

a434 3
	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

a1022 1
		struct rt2860_txd *txd = &ring->txd[ring->next];
a1038 7

		txd->sdl0 &= ~htole16(RT2860_TX_DDONE);

		bus_dmamap_sync(sc->sc_dmat, ring->map,
		    ring->next * sizeof (struct rt2860_txd),
		    sizeof (struct rt2860_txd), BUS_DMASYNC_PREWRITE);

d1382 2
a1383 1
	memset(txwi, 0, sizeof (struct rt2860_txwi));
d1437 1
a1437 1
	if (sc->sc_drvbpf != NULL) {
d1452 1
a1452 1
		mb.m_nextpkt = NULL;   
d1465 1
a1465 1
	if (error != 0 && error != EFBIG) {
d1471 1
a1471 1
	if (error == 0) {
d1481 2
a1482 1
	if (error != 0) {	/* too many fragments, linearize */
d1489 1
a1489 1
		if (error != 0) {
d2059 3
a2061 1
	tmp |= (ic->ic_curmode == IEEE80211_MODE_11A) ? 0 : 3;
d2630 1
a2630 1
	tmp |= RT2860_TX_WB_DDONE | RT2860_RX_DMA_EN | RT2860_TX_DMA_EN |
d2675 1
a2675 1
	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp | RT2860_TX_WB_DDONE);
d2717 1
a2717 1
	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp | RT2860_TX_WB_DDONE);
d2746 1
a2746 1
	
d2798 1
a2798 1
	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp | RT2860_TX_WB_DDONE);
@


1.24
log
@use the hardware general-purpose timer interrupt instead of timeout(9).
clean up the ctl_ridx mess.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.23 2008/12/13 12:07:40 damien Exp $	*/
d104 1
d108 1
d142 1
d246 3
a249 1
	    IEEE80211_C_TXPMGT |	/* tx power management */
d623 1
a623 1
			error = ENOMEM;
d630 1
a630 1
			error = ENOMEM;
d635 2
a636 1
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
d762 1
d855 1
a855 1
			rt2860_set_gp_timer(sc, 200);
d961 17
d1075 1
a1075 1
	struct rt2860_rx_radiotap_header *tap = &sc->sc_rxtap;
d1092 2
a1093 2
		if (rxd->flags &
		    htole32(RT2860_RX_CRCERR | RT2860_RX_ICVERR)) {
d1098 1
a1098 1
		if (rxd->flags & htole32(RT2860_RX_MICERR)) {
d1107 1
a1107 1
		if (m1 == NULL) {
d1112 1
a1112 1
		if (!(m1->m_flags & M_EXT)) {
d1123 3
a1125 2
		    mtod(m1, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
d1131 2
a1132 2
			    BUS_DMA_NOWAIT);
			if (error != 0) {
d1177 1
a1177 1
		if (sc->sc_drvbpf == NULL)
d1180 1
d1248 28
d1295 1
a1295 1
	if (r == 0xffffffff)
d1303 2
a1304 5
	if (r & RT2860_TX_COHERENT)
		/* TBD */;

	if (r & RT2860_RX_COHERENT)
		/* TBD */;
d1306 1
a1306 1
	if (r & RT2860_MAC_INT_2)
d1330 2
a1331 14
	if (r & RT2860_MAC_INT_0) {	/* TBTT */
		struct ieee80211com *ic = &sc->sc_ic;

#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
		    ic->ic_opmode == IEEE80211_M_IBSS)
			(void)rt2860_setup_beacon(sc);
#endif
		/* check if protection mode has changed */
		if ((sc->sc_ic_flags ^ ic->ic_flags) & IEEE80211_F_USEPROT) {
			rt2860_updateprot(ic);
			sc->sc_ic_flags = ic->ic_flags;
		}
	}
d1333 1
a1333 1
	if (r & RT2860_MAC_INT_3)
d1336 1
a1336 1
	if (r & RT2860_MAC_INT_4)
d1496 1
a1496 1
			return ENOMEM;
d1514 1
a1514 1
			return ENOMEM;
d1751 1
d1776 1
d1836 1
d2617 45
d2690 1
d2733 1
d2737 1
a2854 21
	/* enable Tx/Rx DMA engine */
	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, RT2860_MAC_TX_EN);
	for (ntries = 0; ntries < 200; ntries++) {
		tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);
		if ((tmp & (RT2860_TX_DMA_BUSY | RT2860_RX_DMA_BUSY)) == 0)
			break;
		DELAY(1000);
	}
	if (ntries == 200) {
		printf("%s: timeout waiting for DMA engine\n",
		    sc->sc_dev.dv_xname);
		rt2860_stop(ifp, 1);
		return ETIMEDOUT;
	}

	DELAY(50);

	tmp |= RT2860_TX_WB_DDONE | RT2860_RX_DMA_EN | RT2860_TX_DMA_EN |
	    RT2860_WPDMA_BT_SIZE64 << RT2860_WPDMA_BT_SIZE_SHIFT;
	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);

d2864 4
a2867 9
	/* set Rx filter */
	tmp = RT2860_DROP_CRC_ERR | RT2860_DROP_PHY_ERR;
	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
		tmp |= RT2860_DROP_UC_NOME | RT2860_DROP_DUPL |
		    RT2860_DROP_CTS | RT2860_DROP_BA | RT2860_DROP_ACK |
		    RT2860_DROP_VER_ERR | RT2860_DROP_CTRL_RSV |
		    RT2860_DROP_CFACK | RT2860_DROP_CFEND;
		if (ic->ic_opmode == IEEE80211_M_STA)
			tmp |= RT2860_DROP_RTS | RT2860_DROP_PSPOLL;
a2868 4
	RAL_WRITE(sc, RT2860_RX_FILTR_CFG, tmp);

	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL,
	    RT2860_MAC_RX_EN | RT2860_MAC_TX_EN);
d2919 1
d2956 1
d2965 1
d3110 1
a3110 1
		sc->sc_flags &= ~RT2860_FWLOADED; 
d3116 1
a3116 1
			rt2860_init(ifp);	
@


1.23
log
@clear the WCID, pairwise keys, shared keys, IV/EIV tables in NIC memory
*after* resetting the hardware.  otherwise the tables contain garbage.

should fix most of the weird issues people were facing.

scary.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.22 2008/12/12 21:18:36 damien Exp $	*/
a96 1
void		rt2860_next_scan(void *);
d98 1
a98 1
void		rt2860_updatestats(void *);
d107 1
d124 1
a180 2
	timeout_set(&sc->amrr_to, rt2860_updatestats, sc);
	timeout_set(&sc->scan_to, rt2860_next_scan, sc);
a343 3
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);

a726 18
/*
 * This function is called periodically (every 200ms) during scanning to
 * switch from one channel to another.
 */
void
rt2860_next_scan(void *arg)
{
	struct rt2860_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	s = splnet();
	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
	splx(s);
}

d738 1
a738 1
rt2860_updatestats(void *arg)
a739 1
	struct rt2860_softc *sc = arg;
a740 1
	int s;
a761 2

	s = splnet();
d766 1
a766 1
		ieee80211_iterate_nodes(ic, rt2860_iter_func, arg);
a767 3
	splx(s);

	timeout_add(&sc->amrr_to, hz / 2);
d808 3
a810 1
		if (j < 0) {
d812 2
a813 28
			/* XXX ugly, need to be reworked! */
			switch (rate) {
			case 4:
			case 11:
			case 22:
				rn->ctl_ridx[i] =
				    (ic->ic_curmode == IEEE80211_MODE_11B) ?
				    0 : rn->ridx[i];
				break;
			case 12:
			case 18:
				rn->ctl_ridx[i] = 4;
				break;
			case 24:
			case 36:
				rn->ctl_ridx[i] = 6;
				break;
			case 48:
			case 72:
			case 96:
			case 108:
				rn->ctl_ridx[i] = 8;
				break;
			default:
				rn->ctl_ridx[i] = 0;
			}
		} else
			rn->ctl_ridx[i] = rn->ridx[j];
a826 2
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);
d842 1
d847 2
a848 1
		timeout_add(&sc->scan_to, hz / 5);
d853 1
d858 1
d882 1
a882 1
			timeout_add(&sc->amrr_to, hz / 2);
d1221 13
d1297 3
d1340 1
a1340 1
		ctl_ridx = ridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
d1342 1
d1344 2
a1345 1
		ctl_ridx = ridx = sc->fixed_ridx;	/* XXX ctl_ridx */
d1964 26
d2848 3
@


1.22
log
@fix a bug that slipped through my last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.21 2008/12/12 20:58:48 damien Exp $	*/
d1319 1
d2138 31
a2168 27
	/* set initial packet number in IV+EIV */
	if (k->k_cipher == IEEE80211_CIPHER_WEP40 ||
	    k->k_cipher == IEEE80211_CIPHER_WEP104) {
		uint32_t val = arc4random();
		/* skip weak IVs from Fluhrer/Mantin/Shamir */
		if (val >= 0x03ff00 && (val & 0xf8ff00) == 0x00ff00)
			val += 0x000100;
		iv[0] = val;
		iv[1] = val >> 8;
		iv[2] = val >> 16;
		iv[3] = k->k_id << 6;
		iv[4] = iv[5] = iv[6] = iv[7] = 0;
	} else {
		if (k->k_cipher == IEEE80211_CIPHER_TKIP) {
			iv[0] = k->k_tsc >> 8;
			iv[1] = (iv[0] | 0x20) & 0x7f;
			iv[2] = k->k_tsc;
		} else /* CCMP */ {
			iv[0] = k->k_tsc;
			iv[1] = k->k_tsc >> 8;
			iv[2] = 0;
		}
		iv[3] = k->k_id << 6 | IEEE80211_WEP_EXTIV;
		iv[4] = k->k_tsc >> 16;
		iv[5] = k->k_tsc >> 24;
		iv[6] = k->k_tsc >> 32;
		iv[7] = k->k_tsc >> 40;
a2169 1
	RAL_WRITE_REGION_1(sc, RT2860_IVEIV(wcid), iv, 8);
d2682 13
a2851 13

	/* clear RX WCID search table */
	RAL_SET_REGION_4(sc, RT2860_WCID_ENTRY(0), 0, 512);
	/* clear pairwise key table */
	RAL_SET_REGION_4(sc, RT2860_PKEY(0), 0, 2048);
	/* clear IV/EIV table */
	RAL_SET_REGION_4(sc, RT2860_IVEIV(0), 0, 512);
	/* clear WCID attribute table */
	RAL_SET_REGION_4(sc, RT2860_WCID_ATTR(0), 0, 256);
	/* clear shared key table */
	RAL_SET_REGION_4(sc, RT2860_SKEY(0, 0), 0, 8 * 32);
	/* clear shared key mode */
	RAL_SET_REGION_4(sc, RT2860_SKEY_MODE_0_7, 0, 4);
@


1.21
log
@- fix HW crypto using group keys (this should fix the "ExtIV bit not set"
  logged by some WPA supplicants when connecting to a ral(4) WPA AP.)
- get rid of the ugly ack_rate, rate2mcs functions (pre-compute ACKs
  duration for all rates at node association time.)
- lot of clean up, prepare for future enhancements
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.20 2008/11/25 21:43:57 damien Exp $	*/
d1032 1
a1032 1
			mcs = (stat >> RT2860_TXQ_MCS_SHIFT) & 0xffff;
@


1.20
log
@use shiny new m_defrag() and nitems() instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.19 2008/08/27 09:05:03 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007,2008
d70 2
d95 1
d108 2
a109 5
int		rt2860_ack_rate(struct ieee80211com *, int);
uint16_t	rt2860_txtime(int, int, uint32_t);
uint8_t		rt2860_rate2mcs(uint8_t);
int		rt2860_tx_data(struct rt2860_softc *, struct mbuf *,
		    struct ieee80211_node *, int);
d204 1
a204 1
	printf("%s: MAC/BBP RT%X (rev 0x%04X), RF %s (%dT%dR)\n",
d292 1
d697 7
d707 3
d716 9
d803 4
a806 2
	uint8_t wcid = 0;
	int i;
d816 3
d820 2
d823 47
a869 9
	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;

	DPRINTF(("new assoc isnew=%d addr=%s WCID=%d, initial rate=%d\n",
	    isnew, ether_sprintf(ni->ni_macaddr), wcid,
	    ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL));
d923 1
a923 1
			rt2860_setup_beacon(sc);
d1016 1
a1016 1
		wcid = (stat >> 8) & 0xff;
d1032 1
a1032 1
			mcs = (stat >> RT2860_TXQ_MCS_SHIFT) & 0x7f;
d1084 2
d1098 1
a1098 1
	struct mbuf *m, *mnew;
d1133 2
a1134 2
		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
d1138 3
a1140 3
		MCLGET(mnew, M_DONTWAIT);
		if (!(mnew->m_flags & M_EXT)) {
			m_freem(mnew);
d1150 1
a1150 1
		    mtod(mnew, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
d1152 1
a1152 1
			m_freem(mnew);
d1173 1
a1173 1
		data->m = mnew;
d1317 2
d1320 3
a1322 5
	if (r & RT2860_MAC_INT_1) {	/* pre-TBTT */
		if ((sc->sc_flags & RT2860_UPD_BEACON) &&
		    rt2860_setup_beacon(sc) == 0)
			sc->sc_flags &= ~RT2860_UPD_BEACON;
	}
a1323 2
	if (r & RT2860_MAC_INT_0) {	/* TBTT */
		struct ieee80211com *ic = &sc->sc_ic;
a1336 86
/* quickly determine if a given rate is CCK or OFDM */
#define RAL_RATE_IS_OFDM(rate) ((rate) >= 12 && (rate) != 22)

#define RAL_ACK_SIZE	14	/* 10 + 4(FCS) */
#define RAL_SIFS_TIME	10

/*
 * Return the expected ack rate for a frame transmitted at rate `rate'.
 */
int
rt2860_ack_rate(struct ieee80211com *ic, int rate)
{
	switch (rate) {
	/* CCK rates */
	case 2:
		return 2;
	case 4:
	case 11:
	case 22:
		return (ic->ic_curmode == IEEE80211_MODE_11B) ? 4 : rate;

	/* OFDM rates */
	case 12:
	case 18:
		return 12;
	case 24:
	case 36:
		return 24;
	case 48:
	case 72:
	case 96:
	case 108:
		return 48;
	}

	/* default to 1Mbps */
	return 2;
}

/*
 * Compute the duration (in us) needed to transmit `len' bytes at rate `rate'.
 * The function automatically determines the operating mode depending on the
 * given rate. `flags' indicates whether short preamble is in use or not.
 */
uint16_t
rt2860_txtime(int len, int rate, uint32_t flags)
{
	uint16_t txtime;

	if (RAL_RATE_IS_OFDM(rate)) {
		/* IEEE Std 802.11g-2003, pp. 44 */
		txtime = (8 + 4 * len + 3 + rate - 1) / rate;
		txtime = 16 + 4 + 4 * txtime + 6;
	} else {
		/* IEEE Std 802.11b-1999, pp. 28 */
		txtime = (16 * len + rate - 1) / rate;
		if (rate != 2 && (flags & IEEE80211_F_SHPREAMBLE))
			txtime +=  72 + 24;
		else
			txtime += 144 + 48;
	}
	return txtime;
}

uint8_t
rt2860_rate2mcs(uint8_t rate)
{
	switch (rate) {
	/* CCK rates */
	case 2:		return 0;
	case 4:		return 1;
	case 11:	return 2;
	case 22:	return 3;
	/* OFDM rates */
	case 12:	return 0;
	case 18:	return 1;
	case 24:	return 2;
	case 36:	return 3;
	case 48:	return 4;
	case 72:	return 5;
	case 96:	return 6;
	case 108:	return 7;
	}
	return 0;	/* shouldn't get there */
}

d1338 1
a1338 2
rt2860_tx_data(struct rt2860_softc *sc, struct mbuf *m0,
    struct ieee80211_node *ni, int qid)
d1341 2
a1342 1
	struct rt2860_tx_ring *ring = &sc->txq[qid];
d1349 3
a1351 3
	uint16_t dur;
	uint8_t type, qsel, mcs, pid;
	int nsegs, ntxds, rate, error;
d1356 1
a1356 1
	wh = mtod(m0, struct ieee80211_frame *);
d1360 12
a1371 1
	/* pickup a rate */
d1373 9
a1381 8
	    type != IEEE80211_FC0_TYPE_DATA)
		rate = ni->ni_rates.rs_rates[0];
	else if (ic->ic_fixed_rate != -1)
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
	else
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	rate &= IEEE80211_RATE_VAL;
d1383 2
a1384 2
	/* get MCS code from rate */
	mcs = rt2860_rate2mcs(rate);
d1391 2
a1392 2
	txwi->len = htole16(m0->m_pkthdr.len);
	if (!RAL_RATE_IS_OFDM(rate)) {
d1394 2
a1395 1
		if (rate != 2 && (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
d1413 3
a1415 2
	    (m0->m_pkthdr.len + IEEE80211_CRC_LEN > ic->ic_rtsthreshold ||
	     ((ic->ic_flags & IEEE80211_F_USEPROT) && RAL_RATE_IS_OFDM(rate))))
d1420 4
a1423 1
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
d1426 5
a1430 3
		dur = rt2860_txtime(RAL_ACK_SIZE, rt2860_ack_rate(ic, rate),
		    ic->ic_flags) + sc->sifs;
		*(uint16_t *)wh->i_dur = htole16(dur);
d1447 1
a1447 1
		tap->wt_rate = rate;
d1456 1
a1456 1
		mb.m_next = m0;
d1466 1
a1466 1
	m_adj(m0, hdrlen);
d1468 1
a1468 1
	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
d1473 1
a1473 1
		m_freem(m0);
d1487 2
a1488 2
		if (m_defrag(m0, M_DONTWAIT) != 0) {
			m_freem(m0);
d1491 1
a1491 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
d1496 1
a1496 1
			m_freem(m0);
d1504 1
a1504 1
			/* this is an hopeless case, drop the mbuf! */
d1506 1
a1506 1
			m_freem(m0);
d1544 1
a1544 1
	data->m = m0;
d1556 2
a1557 2
	DPRINTFN(4, ("sending frame qid=%d wcid=%d nsegs=%d rate=%d\n",
	    qid, txwi->wcid, data->map->dm_nsegs, rate));
d1559 1
d1561 2
a1562 1
	ring->cur = (ring->cur + 1) % RT2860_TX_RING_COUNT;
d1576 1
a1576 1
	struct mbuf *m0;
a1577 4
	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
d1582 12
a1593 9
		IF_POLL(&ic->ic_mgtq, m0);
		if (m0 != NULL) {
			if (SLIST_EMPTY(&sc->data_pool) ||
			    sc->txq[sc->mgtqid].queued >=
			    RT2860_TX_RING_COUNT) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IF_DEQUEUE(&ic->ic_mgtq, m0);
d1595 6
a1600 8
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (rt2860_tx_data(sc, m0, ni, sc->mgtqid) != 0)
				break;
d1602 4
a1605 13
		} else {
			if (ic->ic_state != IEEE80211_S_RUN)
				break;
			IFQ_POLL(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
			if (SLIST_EMPTY(&sc->data_pool) ||
			    sc->txq[EDCA_AC_BE].queued >=
			    RT2860_TX_RING_COUNT) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IFQ_DEQUEUE(&ifp->if_snd, m0);
d1607 2
a1608 2
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
d1610 3
a1612 3
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
d1614 2
a1615 2
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
d1617 4
a1620 6
			if (rt2860_tx_data(sc, m0, ni, EDCA_AC_BE) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
a2019 5
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP)
		sc->sc_flags |= RT2860_UPD_BEACON;
#endif

d2115 1
a2115 1
		/* install group key */
a2116 23
		if (k->k_cipher == IEEE80211_CIPHER_TKIP) {
			RAL_WRITE_REGION_1(sc, base, k->k_key, 16);
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
				RAL_WRITE_REGION_1(sc, base + 16,
				    &k->k_key[16], 8);
				RAL_WRITE_REGION_1(sc, base + 24,
				    &k->k_key[24], 8);
			} else
#endif
			{
				RAL_WRITE_REGION_1(sc, base + 16,
				    &k->k_key[24], 8);
				RAL_WRITE_REGION_1(sc, base + 24,
				    &k->k_key[16], 8);
			}
		} else
			RAL_WRITE_REGION_1(sc, base, k->k_key, k->k_len);
		attr = RAL_READ(sc, RT2860_SKEY_MODE_0_7);
		attr &= ~(0xf << (k->k_id * 4));
		attr |= mode << (k->k_id * 4);
		RAL_WRITE(sc, RT2860_SKEY_MODE_0_7, attr);

a2117 1
		/* install pairwise key */
d2120 4
a2123 2
		if (k->k_cipher == IEEE80211_CIPHER_TKIP) {
			RAL_WRITE_REGION_1(sc, base, k->k_key, 16);
d2125 4
a2128 6
			if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
				RAL_WRITE_REGION_1(sc, base + 16,
				    &k->k_key[16], 8);
				RAL_WRITE_REGION_1(sc, base + 24,
				    &k->k_key[24], 8);
			} else
d2130 20
a2149 9
			{
				RAL_WRITE_REGION_1(sc, base + 16,
				    &k->k_key[24], 8);
				RAL_WRITE_REGION_1(sc, base + 24,
				    &k->k_key[16], 8);
			}
		} else
			RAL_WRITE_REGION_1(sc, base, k->k_key, k->k_len);
		/* set initial packet number in IV+EIV */
d2164 2
a2165 1
		RAL_WRITE_REGION_1(sc, RT2860_IVEIV(wcid), iv, 8);
d2167 8
d2564 4
d2862 1
a2866 2
	sc->sc_flags &= ~RT2860_UPD_BEACON;

d2969 1
a2969 1
	int rate;
d2978 4
a2981 3
	rate = (ic->ic_curmode == IEEE80211_MODE_11A) ? 12 : 2;
	txwi.phy = htole16(rt2860_rate2mcs(rate));
	if (rate == 12)
d2987 1
a2987 1
	    (u_int8_t *)&txwi, 16);
@


1.19
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.18 2008/08/14 16:02:24 damien Exp $	*/
a172 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d257 1
a257 1
		for (i = 14; i < N(rt2860_rf2850); i++) {
a334 1
#undef N
d1489 1
a1489 4
		struct mbuf *m1;

		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
a1492 14
		M_DUP_PKTHDR(m1, m0);
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(m1);
				return ENOMEM;
			}
		}
		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_len = m1->m_pkthdr.len;
		m_freem(m0);
		m0 = m1;

a2305 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
a2561 1
#undef N
a2566 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d2582 1
a2582 1
	for (i = 0; i < N(rt2860_def_bbp); i++) {
a2593 1
#undef N
a2598 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d2672 1
a2672 1
	for (i = 0; i < N(rt2860_def_mac); i++)
a2835 1
#undef N
@


1.18
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.17 2008/07/21 19:41:44 damien Exp $	*/
d143 1
d145 1
d241 2
a243 1
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
d245 1
a745 1
	uint32_t tmp;
d748 1
d757 1
a757 1
		tmp = RAL_READ(sc, RT2860_DEBUG);
d767 1
d772 1
d775 1
d857 1
d861 1
d1252 1
d1258 1
d1436 1
d1443 1
d2053 1
d2056 1
d2157 1
d2163 3
a2165 1
			} else {
d2184 1
d2190 3
a2192 1
			} else {
d3007 1
d3039 1
d3058 3
a3060 1
	} else if (ic->ic_opmode == IEEE80211_M_IBSS) {
d3072 1
@


1.17
log
@rename rt2860 pci ids to match with reality.
import some fixes for 1T2R adapters from the linux vendor driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.16 2008/07/21 18:43:19 damien Exp $	*/
a1195 7

	/*
	 * In HostAP mode, ieee80211_input() will enqueue packets in if_snd
	 * without calling if_start().
	 */
	if (!IFQ_IS_EMPTY(&ifp->if_snd) && !(ifp->if_flags & IFF_OACTIVE))
		rt2860_start(ifp);
@


1.16
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.15 2008/06/08 19:34:14 jsg Exp $	*/
d63 1
a64 1
#include <dev/ic/rt2860var.h>
d194 5
a1365 3
#if 0
	struct ieee80211_key *k;
#endif
a1392 12
#if 0
	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}
#endif

d1905 1
a1905 1
	else	/* 11a */
a1912 1
	uint8_t bbp66;
a1916 1
	rt2860_mcu_bbp_write(sc, 86, 0x37 - sc->lna[group]);
d1941 1
a1941 2
	bbp66 = (group == 0) ? 0x2e + sc->lna[0] : 0x4c;
	rt2860_mcu_bbp_write(sc, 66, bbp66);
a1967 1
#ifdef notyet
a1970 4
#else
	/* use default Tx power values */
	txpow1 = 0; txpow2 = 5;
#endif
d2386 11
d2409 9
d2419 1
a2419 1
	for (; i < 50; i += 2) {
d2422 2
a2423 2
		sc->txpow1[i + 0] = (int8_t)(val & 0xff);
		sc->txpow1[i + 1] = (int8_t)(val >> 8);
d2427 2
a2428 2
		sc->txpow2[i + 0] = (int8_t)(val & 0xff);
		sc->txpow2[i + 1] = (int8_t)(val >> 8);
a2429 1

d2431 5
a2435 1
	for (i = 0; i < N(rt2860_rf2850); i++) {
d2437 2
a2438 11
		    rt2860_rf2850[i].chan, sc->txpow1[i], sc->txpow2[i]));
		if (sc->txpow1[i] < -6 || sc->txpow1[i] > 36) {
			DPRINTF(("out-of-range Tx power1 for chan %d: %d\n",
			    rt2860_rf2850[i].chan, sc->txpow1[i]));
			sc->txpow1[i] = 5;
		}
		if (sc->txpow2[i] < -6 || sc->txpow2[i] > 36) {
			DPRINTF(("out-of-range Tx power2 for chan %d: %d\n",
			    rt2860_rf2850[i].chan, sc->txpow2[i]));
			sc->txpow2[i] = 5;
		}
d2612 1
a2612 1
	uint8_t bbp3;
d2762 6
d2833 3
@


1.15
log
@Set up shutdown and powerhooks with code adapted from rt2661.
Fixes resume from suspend/hibernate problems mentioned in
PR 5845.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.14 2008/04/26 20:08:01 damien Exp $	*/
d1017 1
d1105 6
a1110 2
		/* frame is decrypted by hardware */
		wh->i_fc[1] &= ~IEEE80211_FC1_PROTECTED;
d1172 3
a1174 1
		ieee80211_input(ifp, m, ni, rssi, 0);
@


1.14
log
@hardware TKIP (including MIC) + CCMP
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.13 2008/04/17 18:16:05 damien Exp $	*/
d145 1
d306 14
d343 6
d3044 31
@


1.13
log
@do not blindly call ieee80211_get_hdrlen() in rt2860_rx_intr().
we may end up passing control frames (ps-poll or others) which
is not supported by ieee80211_get_hdrlen().

first found by pedro la peu, reminded by jsg@@

closes kernel/5750
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.12 2008/04/16 18:32:15 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007
a285 1
#ifdef notyet
a287 1
#endif
d1015 1
a1015 1
		if (!(letoh16(rxd->sdl0) & RT2860_RX_DDONE))
d1018 2
a1019 2
		if (letoh32(rxd->flags) &
		    (RT2860_RX_CRCERR | RT2860_RX_ICVERR)) {
d1024 4
a1027 2
		if (letoh32(rxd->flags) & RT2860_RX_MICERR) {
			/* XXX report MIC failures to net80211 for TKIP */
d1083 2
d1087 1
a1087 1
		if (letoh32(rxd->flags) & RT2860_RX_L2PAD) {
d1333 1
d1335 1
d1363 1
d1373 1
d2114 1
a2114 1
	uint8_t mode, wcid;
d2137 15
a2151 3
		RAL_WRITE_REGION_1(sc, base, k->k_key, k->k_len);
		/* XXX TKIP + HostAP: swap Tx/Rx MIC */

d2156 1
d2161 31
a2191 2
		RAL_WRITE_REGION_1(sc, base, k->k_key, k->k_len);
		/* XXX TKIP + HostAP: swap Tx/Rx MIC */
d2777 6
@


1.12
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.11 2007/12/14 21:28:49 damien Exp $	*/
a999 1
	u_int hdrlen;
a1082 1
		hdrlen = ieee80211_get_hdrlen(wh);
d1086 1
@


1.11
log
@the hardware does not allow to specify the protection mode in each
frame, so track changes to protection mode at each beacon interval
and update the hardware registers appropriately.
cleanup some comments.

undef RAL_DEBUG while i'm here..
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.10 2007/12/09 19:55:51 damien Exp $	*/
d130 1
a130 1
		    const struct ieee80211_key *);
d132 1
a132 1
		    struct ieee80211_node *, int);
d239 2
a240 1
	    IEEE80211_C_WEP;		/* s/w WEP */
d286 1
d289 1
a289 1

a1326 1
	struct ifnet *ifp = &ic->ic_if;
d1332 1
d1361 3
a1363 2
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
d2104 1
a2104 1
    const struct ieee80211_key *k)
d2133 1
a2133 2
		RAL_WRITE_REGION_1(sc, base + 16, k->k_txmic, 8);
		RAL_WRITE_REGION_1(sc, base + 24, k->k_rxmic, 8);
d2144 1
a2144 2
		RAL_WRITE_REGION_1(sc, base + 16, k->k_txmic, 8);
		RAL_WRITE_REGION_1(sc, base + 24, k->k_rxmic, 8);
d2154 2
a2155 1
rt2860_delete_key(struct ieee80211com *ic, struct ieee80211_node *ni, int kid)
d2161 1
a2161 1
	if (ni == NULL) {
d2164 1
a2164 1
		attr &= ~(0xf << (kid * 4));
@


1.10
log
@fix automatic rate control (if the rate falls down to 6Mbps or 1Mbps,
it is no longer stuck at that rate).
workaround for a hardware bug when in HostAP or IBSS mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.9 2007/12/07 21:23:14 damien Exp $	*/
a69 2
#define RAL_DEBUG

d127 1
d720 4
a723 5
	 * In IBSS or HostAP modes (when we're sending beacons), the
	 * hardware can run into a deadlock and start sending CTS-to-self
	 * frames in a loop if RTS/CTS protection is enabled.
	 * Fortunately, we can detect when such a situation occurs and
	 * reset the MAC.
d726 1
a726 1
		/* check if we're in a deadlock situation.. */
d730 1
a730 1
			DPRINTF(("CTS-to-self deadlock occured\n"));
d1214 1
a1214 1
	if (r & RT2860_MAC_INT_1) {	/* Pre-TBTT */
d1219 8
a1226 2
	if (r & RT2860_MAC_INT_0)
		/* TBD TBTT */;
d1382 5
a1386 5
	 * We store the MCS into the PacketID field.  The PacketID field is
	 * latched into TX_STAT_FIFO when Tx completes so that we know at
	 * which rate the frame was transmitted.  We add 1 to the MCS code
	 * because 0 is a valid MCS code but setting the PacketID field to
	 * 0 means that we will get no results in TX_STAT_FIFO.
a2037 1
#if 0
d2041 17
a2057 3
	/* set RTS rate and enable CTS-to-self protection if needed */
	RAL_WRITE(sc, RT2860_CCK_PROT_CFG, );
	RAL_WRITE(sc, RT2860_OFDM_PROT_CFG, );
a2058 1
#endif
d2700 4
@


1.9
log
@LEDs
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.8 2007/12/07 19:37:04 damien Exp $	*/
d717 1
d720 20
d790 1
a790 1
		/* light down link LED */
d840 1
a840 1
		/* light up link LED */
d914 1
a914 1
	uint8_t wcid;
d932 3
a934 1
			 * rate is different from the requested rate.
d936 3
a938 2
			if (((stat >> RT2860_TXQ_RATE_SHIFT) & 0x7f) !=
			    ((stat >> RT2860_TXQ_PID_SHIFT) & 0xf))
d1330 1
a1330 1
	uint8_t type, qsel, mcs;
d1376 10
a1385 2
	/* store MCS into driver-private field for rate control */
	txwi->len |= htole16(mcs << RT2860_TX_PID_SHIFT);
a2273 1
	/* read LEDs operating mode */
d2275 1
d2677 3
d2706 1
a2706 1
	/* light up radio LED */
d2749 3
a2756 3

	/* light down all LEDs */
	rt2860_set_leds(sc, 0);
@


1.8
log
@In hostap mode, update beacon to reflect ERP IE changes.
Fix channel 126 settings.
Workarounds for various hardware bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.7 2007/12/04 22:26:55 deraadt Exp $	*/
d125 1
d768 5
d818 5
d1710 1
a1710 1
	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_BBP, 0);
d1734 1
a1734 1
	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_BBP, 0);
d1963 7
d2237 20
a2402 5
	/* read RF frequency offset from EEPROM */
	val = rt2860_eeprom_read(sc, RT2860_EEPROM_FREQ);
	sc->freq = ((val & 0xff) != 0xff) ? val & 0xff : 0;
	DPRINTF(("EEPROM freq offset %d\n", sc->freq & 0xff));

d2627 5
d2671 3
d2719 3
@


1.7
log
@expresscard ral(4) rt2860 now can attach and detach correctly
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.6 2007/11/19 21:26:19 damien Exp $	*/
d1181 5
a1185 3
	if (r & RT2860_MAC_INT_1)
		/* TBD pre-TBTT */;

d1840 1
d1870 2
a1871 1
	rt2860_mcu_bbp_write(sc, 66, 0x2e + sc->lna[group]);
d1975 3
d2708 2
@


1.6
log
@802.11 radiotap + various tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.5 2007/11/17 15:39:38 damien Exp $	*/
d1143 2
@


1.5
log
@implement ic_set_key() and ic_delete_key() callbacks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.4 2007/11/17 12:04:00 damien Exp $	*/
d109 1
a109 1
uint8_t		rt2860_rate2mcs(struct rt2860_softc *, uint8_t);
d293 13
d732 1
a732 1
	uint8_t wcid;
d735 3
a737 5
	wcid = RT2860_AID2WCID(ni->ni_associd);

	/* init WCID table entry */
	RAL_WRITE_REGION_1(sc, RT2860_WCID_ENTRY(wcid),
	    ni->ni_macaddr, IEEE80211_ADDR_LEN);
d739 4
d751 2
a752 2
	DPRINTF(("new assoc addr=%s WCID=%d, initial rate=%d\n",
	    ether_sprintf(ni->ni_macaddr), wcid,
d966 1
a966 1
	uint8_t rssi;
d968 5
d1058 48
a1109 1
		rssi = rxwi->rssi[rt2860_maxrssi_chain(sc, rxwi)];
d1256 1
a1256 1
rt2860_rate2mcs(struct rt2860_softc *sc, uint8_t rate)
d1258 15
a1272 29
	struct ieee80211com *ic = &sc->sc_ic;

	if (!RAL_RATE_IS_OFDM(rate)) {
		if (ic->ic_flags & IEEE80211_F_SHPREAMBLE) {
			switch (rate) {
			case 2:		return 0;
			case 4:		return 9;
			case 11:	return 10;
			case 22:	return 11;
			}
		} else {
			switch (rate) {
			case 2:		return 0;
			case 4:		return 1;
			case 11:	return 2;
			case 22:	return 3;
			}
		}
	} else {
		switch (rate) {
		case 12:	return 0;
		case 18:	return 1;
		case 24:	return 2;
		case 36:	return 3;
		case 48:	return 4;
		case 72:	return 5;
		case 96:	return 6;
		case 108:	return 7;
		}
d1313 1
a1313 1
	mcs = rt2860_rate2mcs(sc, rate);
d1330 8
a1338 3
	txwi->phy = htole16(mcs);
	if (RAL_RATE_IS_OFDM(rate))
		txwi->phy |= htole16(RT2860_TX_OFDM);
d1362 23
d2033 1
a2033 1
	/* map net80211 ciphers to RT2860 security mode */
d2059 1
a2061 1

d2103 1
a2103 1
	struct ieee80211_channel *c = ic->ic_bss->ni_chan;
d2625 9
a2633 7
	tmp =
	    RT2860_DROP_CRC_ERR | RT2860_DROP_PHY_ERR | RT2860_DROP_UC_NOME |
	    RT2860_DROP_VER_ERR | RT2860_DROP_DUPL | RT2860_DROP_CFACK |
	    RT2860_DROP_CFEND | RT2860_DROP_ACK | RT2860_DROP_CTS |
	    RT2860_DROP_BA | RT2860_DROP_CTRL_RSV;
	if (ic->ic_opmode == IEEE80211_M_STA)
		tmp |= RT2860_DROP_RTS | RT2860_DROP_PSPOLL;
d2681 1
a2681 1
	RAL_SET_REGION_4(sc, 0x7000, 0, 4);
d2811 3
a2813 1
	txwi.phy = htole16(rt2860_rate2mcs(sc, rate));
a2867 1

@


1.4
log
@sync error messages with man page's DIAGNOSTICS section.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.3 2007/11/16 21:34:28 damien Exp $	*/
d129 4
d285 2
d1941 75
@


1.3
log
@clear host to mcu mailbox after loading microcode.
otherwise, talking to the bbp through the mcu may fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.2 2007/11/16 01:35:53 deraadt Exp $	*/
d2314 1
a2314 1
			printf("%s: could not load microcode\n",
d2578 1
a2578 1
		printf("%s: timeout waiting for microcontroller unit\n",
@


1.2
log
@cast pointer to right type
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2860.c,v 1.1 2007/11/15 21:15:34 damien Exp $	*/
d2372 4
d2439 1
a2439 1
	tmp |= (ic->ic_rtsthreshold & 0xffff) << 8;
d2651 2
a2652 1
	RAL_WRITE_REGION_1(sc, RT2860_BCN_BASE(0), (u_int8_t *)&txwi, 16);
@


1.1
log
@New driver for Ralink RT2860 chipset.
Attaches as 'ral' as it shares the PCI and CardBus frontends with
RT2560 and RT2661 though it is actually a separate driver.

Requires a firmware that can't be redistributed with the base system
due to license restrictions (exact same license as iwn(4) firmware).

The 802.11n capabilities not yet supported (except MIMO).
Great thanks to Sam Fourman Jr for donating hardware.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2647 1
a2647 1
	RAL_WRITE_REGION_1(sc, RT2860_BCN_BASE(0), &txwi, 16);
@

