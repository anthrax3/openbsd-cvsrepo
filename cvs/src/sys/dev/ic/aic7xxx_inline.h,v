head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.8
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.12
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.10
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.6
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.22
	OPENBSD_5_0:1.14.0.18
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.16
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.14
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.10
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	UBC:1.4.0.2
	UBC_SYNC_B:1.4
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.17
date	2016.08.17.01.17.54;	author krw;	state Exp;
branches;
next	1.16;
commitid	ABXin5xH6wOo5rmV;

1.16
date	2015.07.17.21.42.49;	author krw;	state Exp;
branches;
next	1.15;
commitid	bEhopXwWgYXDvWRJ;

1.15
date	2012.05.12.21.56.30;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.14.01.37.49;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.23.07.34.51;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.04.03.56.17;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.18.02.43.26;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.01.21.49.54;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.24.04.28.33;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.01.01.36.23;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.24.22.45.45;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.21.18.58.48;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.29.19.28.16;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.09.23.43.11;	author krw;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.06.28.00.34.54;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.19.02.49.20;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.28.11.51.00;	author niklas;	state dead;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.03.28.14.05.52;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.02.19.10.56.16;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Move to iopool. No voluntary testers after several years of requests so now
everybody gets to test!
@
text
@/*	$OpenBSD: aic7xxx_inline.h,v 1.16 2015/07/17 21:42:49 krw Exp $	*/
/*	$NetBSD: aic7xxx_inline.h,v 1.4 2003/11/02 11:07:44 wiz Exp $	*/

/*
 * Inline routines shareable across OS platforms.
 *
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2001 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#39 $
 *
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx_inline.h,v 1.20 2003/01/20 20:44:55 gibbs Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
 */

#ifndef _AIC7XXX_INLINE_H_
#define _AIC7XXX_INLINE_H_

#ifdef SMALL_KERNEL
#define	IO_INLINE
#else
#define	IO_INLINE	static __inline
#define	IO_EXPAND
#endif

/************************* Sequencer Execution Control ************************/
IO_INLINE void ahc_pause_bug_fix(struct ahc_softc *ahc);
IO_INLINE int  ahc_is_paused(struct ahc_softc *ahc);
IO_INLINE void ahc_pause(struct ahc_softc *ahc);
IO_INLINE void ahc_unpause(struct ahc_softc *ahc);

#ifdef IO_EXPAND
/*
 * Work around any chip bugs related to halting sequencer execution.
 * On Ultra2 controllers, we must clear the CIOBUS stretch signal by
 * reading a register that will set this signal and deassert it.
 * Without this workaround, if the chip is paused, by an interrupt or
 * manual pause while accessing scb ram, accesses to certain registers
 * will hang the system (infinite pci retries).
 */
IO_INLINE void
ahc_pause_bug_fix(struct ahc_softc *ahc)
{
	if ((ahc->features & AHC_ULTRA2) != 0)
		(void)ahc_inb(ahc, CCSCBCTL);
}

/*
 * Determine whether the sequencer has halted code execution.
 * Returns non-zero status if the sequencer is stopped.
 */
IO_INLINE int
ahc_is_paused(struct ahc_softc *ahc)
{
	return ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);
}

/*
 * Request that the sequencer stop and wait, indefinitely, for it
 * to stop.  The sequencer will only acknowledge that it is paused
 * once it has reached an instruction boundary and PAUSEDIS is
 * cleared in the SEQCTL register.  The sequencer may use PAUSEDIS
 * for critical sections.
 */
IO_INLINE void
ahc_pause(struct ahc_softc *ahc)
{
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/*
	 * Since the sequencer can disable pausing in a critical section, we
	 * must loop until it actually stops.
	 */
	while (ahc_is_paused(ahc) == 0)
		;

	ahc_pause_bug_fix(ahc);
}

/*
 * Allow the sequencer to continue program execution.
 * We check here to ensure that no additional interrupt
 * sources that would cause the sequencer to halt have been
 * asserted.  If, for example, a SCSI bus reset is detected
 * while we are fielding a different, pausing, interrupt type,
 * we don't want to release the sequencer before going back
 * into our interrupt handler and dealing with this new
 * condition.
 */
IO_INLINE void
ahc_unpause(struct ahc_softc *ahc)
{
	if ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)
		ahc_outb(ahc, HCNTRL, ahc->unpause);
}
#endif /* IO_EXPAND */

/*********************** Untagged Transaction Routines ************************/
IO_INLINE void	ahc_freeze_untagged_queues(struct ahc_softc *ahc);
IO_INLINE void	ahc_release_untagged_queues(struct ahc_softc *ahc);

#ifdef IO_EXPAND
/*
 * Block our completion routine from starting the next untagged
 * transaction for this target or target lun.
 */
IO_INLINE void
ahc_freeze_untagged_queues(struct ahc_softc *ahc)
{
	if ((ahc->flags & AHC_SCB_BTT) == 0)
		ahc->untagged_queue_lock++;
}

/*
 * Allow the next untagged transaction for this target or target lun
 * to be executed.  We use a counting semaphore to allow the lock
 * to be acquired recursively.  Once the count drops to zero, the
 * transaction queues will be run.
 */
IO_INLINE void
ahc_release_untagged_queues(struct ahc_softc *ahc)
{
	if ((ahc->flags & AHC_SCB_BTT) == 0) {
		ahc->untagged_queue_lock--;
		if (ahc->untagged_queue_lock == 0)
			ahc_run_untagged_queues(ahc);
	}
}
#endif /* IO_EXPAND */


/************************** Memory mapping routines ***************************/
IO_INLINE struct ahc_dma_seg *
			ahc_sg_bus_to_virt(struct scb *scb,
					   uint32_t sg_busaddr);
IO_INLINE uint32_t
			ahc_sg_virt_to_bus(struct scb *scb,
					   struct ahc_dma_seg *sg);
IO_INLINE uint32_t
			ahc_hscb_busaddr(struct ahc_softc *ahc, u_int index);
IO_INLINE void		ahc_sync_scb(struct ahc_softc *ahc,
					   struct scb *scb, int op);
#ifdef AHC_TARGET_MODE
IO_INLINE uint32_t
			ahc_targetcmd_offset(struct ahc_softc *ahc,
					     u_int index);
#endif

#ifdef IO_EXPAND

IO_INLINE struct ahc_dma_seg *
ahc_sg_bus_to_virt(struct scb *scb, uint32_t sg_busaddr)
{
	int sg_index;

	sg_index = (sg_busaddr - scb->sg_list_phys)/sizeof(struct ahc_dma_seg);
	/* sg_list_phys points to entry 1, not 0 */
	sg_index++;

	return (&scb->sg_list[sg_index]);
}

IO_INLINE uint32_t
ahc_sg_virt_to_bus(struct scb *scb, struct ahc_dma_seg *sg)
{
	int sg_index;

	/* sg_list_phys points to entry 1, not 0 */
	sg_index = sg - &scb->sg_list[1];

	return (scb->sg_list_phys + (sg_index * sizeof(*scb->sg_list)));
}

IO_INLINE uint32_t
ahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)
{
	return (ahc->scb_data->hscb_busaddr
		+ (sizeof(struct hardware_scb) * index));
}

IO_INLINE void
ahc_sync_scb(struct ahc_softc *ahc, struct scb *scb, int op)
{
	ahc_dmamap_sync(ahc, ahc->parent_dmat,
			ahc->scb_data->hscb_dmamap,
			/*offset*/(scb->hscb - ahc->scb_data->hscbs) * sizeof(*scb->hscb),
			/*len*/sizeof(*scb->hscb), op);
}

#ifdef AHC_TARGET_MODE
IO_INLINE uint32_t
ahc_targetcmd_offset(struct ahc_softc *ahc, u_int index)
{
	return (((uint8_t *)&ahc->targetcmds[index]) - ahc->qoutfifo);
}
#endif /* AHC_TARGET_MODE */
#endif /* IO_EXPAND */

/******************************** Debugging ***********************************/
static __inline char *ahc_name(struct ahc_softc *ahc);

static __inline char *
ahc_name(struct ahc_softc *ahc)
{
	return (ahc->name);
}

/*********************** Miscellaneous Support Functions ***********************/

IO_INLINE void	ahc_update_residual(struct ahc_softc *ahc,
					    struct scb *scb);
IO_INLINE struct ahc_initiator_tinfo *
			ahc_fetch_transinfo(struct ahc_softc *ahc,
					    char channel, u_int our_id,
					    u_int remote_id,
					    struct ahc_tmode_tstate **tstate);

IO_INLINE uint16_t
			ahc_inw(struct ahc_softc *ahc, u_int port);
IO_INLINE void	ahc_outw(struct ahc_softc *ahc, u_int port,
				 u_int value);
IO_INLINE uint32_t
			ahc_inl(struct ahc_softc *ahc, u_int port);
IO_INLINE void	ahc_outl(struct ahc_softc *ahc, u_int port,
				 uint32_t value);
IO_INLINE struct scb *ahc_lookup_scb(struct ahc_softc *ahc, u_int tag);
IO_INLINE void		ahc_swap_with_next_hscb(struct ahc_softc *ahc,
						struct scb *scb);
IO_INLINE void		ahc_queue_scb(struct ahc_softc *ahc, struct scb *scb);
IO_INLINE struct scsi_sense_data *
			ahc_get_sense_buf(struct ahc_softc *ahc,
					  struct scb *scb);
IO_INLINE uint32_t
			ahc_get_sense_bufaddr(struct ahc_softc *ahc,
					      struct scb *scb);

#ifdef IO_EXPAND

/*
 * Determine whether the sequencer reported a residual
 * for this SCB/transaction.
 */
IO_INLINE void
ahc_update_residual(struct ahc_softc *ahc, struct scb *scb)
{
	uint32_t sgptr;

	sgptr = aic_le32toh(scb->hscb->sgptr);
	if ((sgptr & SG_RESID_VALID) != 0)
		ahc_calc_residual(ahc, scb);
}

/*
 * Return pointers to the transfer negotiation information
 * for the specified our_id/remote_id pair.
 */
IO_INLINE struct ahc_initiator_tinfo *
ahc_fetch_transinfo(struct ahc_softc *ahc, char channel, u_int our_id,
		    u_int remote_id, struct ahc_tmode_tstate **tstate)
{
	/*
	 * Transfer data structures are stored from the perspective
	 * of the target role.  Since the parameters for a connection
	 * in the initiator role to a given target are the same as
	 * when the roles are reversed, we pretend we are the target.
	 */
	if (channel == 'B')
		our_id += 8;
	*tstate = ahc->enabled_targets[our_id];
	return (&(*tstate)->transinfo[remote_id]);
}

IO_INLINE uint16_t
ahc_inw(struct ahc_softc *ahc, u_int port)
{
	return ((ahc_inb(ahc, port+1) << 8) | ahc_inb(ahc, port));
}

IO_INLINE void
ahc_outw(struct ahc_softc *ahc, u_int port, u_int value)
{
	ahc_outb(ahc, port, value & 0xFF);
	ahc_outb(ahc, port+1, (value >> 8) & 0xFF);
}

IO_INLINE uint32_t
ahc_inl(struct ahc_softc *ahc, u_int port)
{
	return ((ahc_inb(ahc, port))
	      | (ahc_inb(ahc, port+1) << 8)
	      | (ahc_inb(ahc, port+2) << 16)
	      | (ahc_inb(ahc, port+3) << 24));
}

IO_INLINE void
ahc_outl(struct ahc_softc *ahc, u_int port, uint32_t value)
{
	ahc_outb(ahc, port, (value) & 0xFF);
	ahc_outb(ahc, port+1, ((value) >> 8) & 0xFF);
	ahc_outb(ahc, port+2, ((value) >> 16) & 0xFF);
	ahc_outb(ahc, port+3, ((value) >> 24) & 0xFF);
}

IO_INLINE struct scb *
ahc_lookup_scb(struct ahc_softc *ahc, u_int tag)
{
	struct scb* scb;

	scb = ahc->scb_data->scbindex[tag];
	if (scb != NULL)
		ahc_sync_scb(ahc, scb,
			     BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	return (scb);
}


IO_INLINE void
ahc_swap_with_next_hscb(struct ahc_softc *ahc, struct scb *scb)
{
	struct hardware_scb *q_hscb;
	u_int  saved_tag;

	/*
	 * Our queuing method is a bit tricky.  The card
	 * knows in advance which HSCB to download, and we
	 * can't disappoint it.  To achieve this, the next
	 * SCB to download is saved off in ahc->next_queued_scb.
	 * When we are called to queue "an arbitrary scb",
	 * we copy the contents of the incoming HSCB to the one
	 * the sequencer knows about, swap HSCB pointers and
	 * finally assign the SCB to the tag indexed location
	 * in the scb_array.  This makes sure that we can still
	 * locate the correct SCB by SCB_TAG.
	 */
	q_hscb = ahc->next_queued_scb->hscb;
	saved_tag = q_hscb->tag;
	memcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));
	if ((scb->flags & SCB_CDB32_PTR) != 0) {
		q_hscb->shared_data.cdb_ptr =
		    aic_htole32(ahc_hscb_busaddr(ahc, q_hscb->tag)
			      + offsetof(struct hardware_scb, cdb32));
	}
	q_hscb->tag = saved_tag;
	q_hscb->next = scb->hscb->tag;

	/* Now swap HSCB pointers. */
	ahc->next_queued_scb->hscb = scb->hscb;
	scb->hscb = q_hscb;

	/* Now define the mapping from tag to SCB in the scbindex */
	ahc->scb_data->scbindex[scb->hscb->tag] = scb;
}

/*
 * Tell the sequencer about a new transaction to execute.
 */
IO_INLINE void
ahc_queue_scb(struct ahc_softc *ahc, struct scb *scb)
{
	ahc_swap_with_next_hscb(ahc, scb);

	if (scb->hscb->tag == SCB_LIST_NULL
	 || scb->hscb->next == SCB_LIST_NULL)
		panic("Attempt to queue invalid SCB tag %x:%x",
		      scb->hscb->tag, scb->hscb->next);

	/*
	 * Setup data "oddness".
	 */
	scb->hscb->lun &= LID;
	if (ahc_get_transfer_length(scb) & 0x1)
		scb->hscb->lun |= SCB_XFERLEN_ODD;

	/*
	 * Keep a history of SCBs we've downloaded in the qinfifo.
	 */
	ahc->qinfifo[ahc->qinfifonext] = scb->hscb->tag;
	ahc_dmamap_sync(ahc, ahc->parent_dmat, ahc->shared_data_dmamap,
			/*offset*/ahc->qinfifonext+256, /*len*/1,
			BUS_DMASYNC_PREWRITE);
	ahc->qinfifonext++;

	/*
	 * Make sure our data is consistent from the
	 * perspective of the adapter.
	 */
	ahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	/* Tell the adapter about the newly queued SCB */
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		if ((ahc->features & AHC_AUTOPAUSE) == 0)
			ahc_pause(ahc);
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
		if ((ahc->features & AHC_AUTOPAUSE) == 0)
			ahc_unpause(ahc);
	}
}


IO_INLINE struct scsi_sense_data *
ahc_get_sense_buf(struct ahc_softc *ahc, struct scb *scb)
{
	int offset;

	offset = scb - ahc->scb_data->scbarray;
	return (&ahc->scb_data->sense[offset]);
}

IO_INLINE uint32_t
ahc_get_sense_bufaddr(struct ahc_softc *ahc, struct scb *scb)
{
	int offset;

	offset = scb - ahc->scb_data->scbarray;
	return (ahc->scb_data->sense_busaddr
	      + (offset * sizeof(struct scsi_sense_data)));
}
#endif /* IO_EXPAND */

/************************** Interrupt Processing ******************************/
IO_INLINE void	ahc_sync_qoutfifo(struct ahc_softc *ahc, int op);
IO_INLINE void	ahc_sync_tqinfifo(struct ahc_softc *ahc, int op);
IO_INLINE u_int	ahc_check_cmdcmpltqueues(struct ahc_softc *ahc);
IO_INLINE int	ahc_intr(struct ahc_softc *ahc);

#ifdef IO_EXPAND
IO_INLINE void
ahc_sync_qoutfifo(struct ahc_softc *ahc, int op)
{
	ahc_dmamap_sync(ahc, ahc->parent_dmat, ahc->shared_data_dmamap,
			/*offset*/0, /*len*/256, op);
}

IO_INLINE void
ahc_sync_tqinfifo(struct ahc_softc *ahc, int op)
{
#ifdef AHC_TARGET_MODE
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
	  ahc_dmamap_sync(ahc, ahc->parent_dmat /*shared_data_dmat*/,
				ahc->shared_data_dmamap,
				ahc_targetcmd_offset(ahc, 0),
				sizeof(struct target_cmd) * AHC_TMODE_CMDS,
				op);
	}
#endif
}

/*
 * See if the firmware has posted any completed commands
 * into our in-core command complete fifos.
 */
#define AHC_RUN_QOUTFIFO 0x1
#define AHC_RUN_TQINFIFO 0x2
IO_INLINE u_int
ahc_check_cmdcmpltqueues(struct ahc_softc *ahc)
{
	u_int retval;

	retval = 0;
	ahc_dmamap_sync(ahc, ahc->parent_dmat /*shared_data_dmat*/, ahc->shared_data_dmamap,
			/*offset*/ahc->qoutfifonext, /*len*/1,
			BUS_DMASYNC_POSTREAD);
	if (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL)
		retval |= AHC_RUN_QOUTFIFO;
#ifdef AHC_TARGET_MODE
	if ((ahc->flags & AHC_TARGETROLE) != 0
	    && (ahc->flags & AHC_TQINFIFO_BLOCKED) == 0) {
	  ahc_dmamap_sync(ahc, ahc->parent_dmat /*shared_data_dmat*/,
			  ahc->shared_data_dmamap,
			  ahc_targetcmd_offset(ahc, ahc->tqinfifonext),
			  /*len*/sizeof(struct target_cmd),
			  BUS_DMASYNC_POSTREAD);
		if (ahc->targetcmds[ahc->tqinfifonext].cmd_valid != 0)
			retval |= AHC_RUN_TQINFIFO;
	}
#endif
	return (retval);
}


/*
 * Catch an interrupt from the adapter
 */
IO_INLINE int
ahc_intr(struct ahc_softc *ahc)
{
	u_int	intstat;

	if ((ahc->pause & INTEN) == 0) {
		/*
		 * Our interrupt is not enabled on the chip
		 * and may be disabled for re-entrancy reasons,
		 * so just return.  This is likely just a shared
		 * interrupt.
		 */
		return (0);
	}
	/*
	 * Instead of directly reading the interrupt status register,
	 * infer the cause of the interrupt by checking our in-core
	 * completion queues.  This avoids a costly PCI bus read in
	 * most cases.
	 */
	if ((ahc->flags & (AHC_ALL_INTERRUPTS|AHC_EDGE_INTERRUPT)) == 0
	    && (ahc_check_cmdcmpltqueues(ahc) != 0))
                intstat = CMDCMPLT;
        else {
                intstat = ahc_inb(ahc, INTSTAT);
        }

        if (intstat & CMDCMPLT) {
		ahc_outb(ahc, CLRINT, CLRCMDINT);

		/*
		 * Ensure that the chip sees that we've cleared
		 * this interrupt before we walk the output fifo.
		 * Otherwise, we may, due to posted bus writes,
		 * clear the interrupt after we finish the scan,
		 * and after the sequencer has added new entries
		 * and asserted the interrupt again.
		 */
		ahc_flush_device_writes(ahc);
		ahc_run_qoutfifo(ahc);
#ifdef AHC_TARGET_MODE
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			ahc_run_tqinfifo(ahc, /*paused*/FALSE);
#endif
	}

	if (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0)
		/* Hot eject */
		return 1;

	if ((intstat & INT_PEND) == 0) {
#if AHC_PCI_CONFIG > 0
		if (ahc->unsolicited_ints > 500) {
			ahc->unsolicited_ints = 0;
			if ((ahc->chip & AHC_PCI) != 0
			 && (ahc_inb(ahc, ERROR) & PCIERRSTAT) != 0)
				ahc->bus_intr(ahc);
		}
		ahc->unsolicited_ints++;
#endif
		return 0;
	}
	ahc->unsolicited_ints = 0;

	if (intstat & BRKADRINT) {
		ahc_handle_brkadrint(ahc);
		/* Fatal error, no more interrupts to handle. */
		return 1;
	}

	if ((intstat & (SEQINT|SCSIINT)) != 0)
		ahc_pause_bug_fix(ahc);

	if ((intstat & SEQINT) != 0)
		ahc_handle_seqint(ahc, intstat);

	if ((intstat & SCSIINT) != 0)
		ahc_handle_scsiint(ahc, intstat);

	return (1);
}

#endif	/* IO_EXPAND */

#endif  /* _AIC7XXX_INLINE_H_ */
@


1.16
log
@Nuke a bunch of leading and trailing whitespace so I don't go blind
reading this code. No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_inline.h,v 1.15 2012/05/12 21:56:30 miod Exp $	*/
a260 3
IO_INLINE struct scb*
			ahc_get_scb(struct ahc_softc *ahc);
IO_INLINE void		ahc_free_scb(struct ahc_softc *ahc, struct scb *scb);
a337 37

/*
 * Get a free scb. If there are none, see if we can allocate a new SCB.
 */
IO_INLINE struct scb *
ahc_get_scb(struct ahc_softc *ahc)
{
	struct scb *scb;

	scb = SLIST_FIRST(&ahc->scb_data->free_scbs);

	if (scb != NULL)
		SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links.sle);

	return (scb);
}

/*
 * Return an SCB resource to the free list.
 */
IO_INLINE void
ahc_free_scb(struct ahc_softc *ahc, struct scb *scb)
{
	struct hardware_scb *hscb;

	hscb = scb->hscb;
	/* Clean up for the next user */
	ahc->scb_data->scbindex[hscb->tag] = NULL;
	scb->flags = SCB_FLAG_NONE;
	hscb->control = 0;

	SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links.sle);

	/* Notify the OSM that a resource is now available. */
	ahc_platform_scb_free(ahc, scb);
}

@


1.15
log
@Repairs operation of twin-channel ahc devices. Only affects ahc@@eisa since
none of the ahc@@pci are twin-channel. Broken since 3.6 as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_inline.h,v 1.14 2007/05/14 01:37:49 deraadt Exp $	*/
d363 1
a363 1
{       
@


1.14
log
@delete unused code; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_inline.h,v 1.13 2007/04/23 07:34:51 art Exp $	*/
d305 2
a306 2
	/*if (channel == 'B')
	  our_id += 8;*/
@


1.13
log
@Kill inlines to shave some bytes.

krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_inline.h,v 1.12 2005/12/04 03:56:17 krw Exp $	*/
d176 3
a178 4
IO_INLINE void	ahc_sync_scb(struct ahc_softc *ahc,
				     struct scb *scb, int op);
IO_INLINE void	ahc_sync_sglist(struct ahc_softc *ahc,
					struct scb *scb, int op);
d182 1
d225 1
a225 12
IO_INLINE void
ahc_sync_sglist(struct ahc_softc *ahc, struct scb *scb, int op)
{
	if (scb->sg_count == 0)
		return;

	ahc_dmamap_sync(ahc, ahc->parent_dmat, scb->sg_map->sg_dmamap,
			/*offset*/(scb->sg_list - scb->sg_map->sg_vaddr)
				* sizeof(struct ahc_dma_seg),
			/*len*/sizeof(struct ahc_dma_seg) * scb->sg_count, op);
}

d231 1
a260 4
IO_INLINE uint64_t
			ahc_inq(struct ahc_softc *ahc, u_int port);
IO_INLINE void	ahc_outq(struct ahc_softc *ahc, u_int port,
				 uint64_t value);
a341 26
IO_INLINE uint64_t
ahc_inq(struct ahc_softc *ahc, u_int port)
{
	return ((ahc_inb(ahc, port))
	      | (ahc_inb(ahc, port+1) << 8)
	      | (ahc_inb(ahc, port+2) << 16)
	      | (ahc_inb(ahc, port+3) << 24)
	      | (((uint64_t)ahc_inb(ahc, port+4)) << 32)
	      | (((uint64_t)ahc_inb(ahc, port+5)) << 40)
	      | (((uint64_t)ahc_inb(ahc, port+6)) << 48)
	      | (((uint64_t)ahc_inb(ahc, port+7)) << 56));
}

IO_INLINE void
ahc_outq(struct ahc_softc *ahc, u_int port, uint64_t value)
{
	ahc_outb(ahc, port, value & 0xFF);
	ahc_outb(ahc, port+1, (value >> 8) & 0xFF);
	ahc_outb(ahc, port+2, (value >> 16) & 0xFF);
	ahc_outb(ahc, port+3, (value >> 24) & 0xFF);
	ahc_outb(ahc, port+4, (value >> 32) & 0xFF);
	ahc_outb(ahc, port+5, (value >> 40) & 0xFF);
	ahc_outb(ahc, port+6, (value >> 48) & 0xFF);
	ahc_outb(ahc, port+7, (value >> 56) & 0xFF);
}

a498 1
IO_INLINE void	ahc_sync_qinfifo(struct ahc_softc *ahc, int op);
a508 7
}

IO_INLINE void
ahc_sync_qinfifo(struct ahc_softc *ahc, int op)
{
	ahc_dmamap_sync(ahc, ahc->parent_dmat, ahc->shared_data_dmamap,
			/*offset*/256, /*len*/256, op);
@


1.12
log
@Allocate all scbs during initialization to avoid using
bus_dmamem_alloc() in interrupt context.

Use same logic as ahd.

"Looks good to me" pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_inline.h,v 1.11 2005/07/18 02:43:26 fgsch Exp $	*/
d62 4
a65 4
static __inline void ahc_pause_bug_fix(struct ahc_softc *ahc);
static __inline int  ahc_is_paused(struct ahc_softc *ahc);
static __inline void ahc_pause(struct ahc_softc *ahc);
static __inline void ahc_unpause(struct ahc_softc *ahc);
d67 1
d76 1
a76 1
static __inline void
d87 1
a87 1
static __inline int
d100 1
a100 1
static __inline void
d125 1
a125 1
static __inline void
d131 1
d134 2
a135 2
static __inline void	ahc_freeze_untagged_queues(struct ahc_softc *ahc);
static __inline void	ahc_release_untagged_queues(struct ahc_softc *ahc);
d137 1
d142 1
a142 1
static __inline void
d155 1
a155 1
static __inline void
d164 2
d168 1
a168 1
static __inline struct ahc_dma_seg *
d171 1
a171 1
static __inline uint32_t
d174 1
a174 1
static __inline uint32_t
d176 1
a176 1
static __inline void	ahc_sync_scb(struct ahc_softc *ahc,
d178 1
a178 1
static __inline void	ahc_sync_sglist(struct ahc_softc *ahc,
d180 1
a180 1
static __inline uint32_t
d184 3
a186 1
static __inline struct ahc_dma_seg *
d198 1
a198 1
static __inline uint32_t
d209 1
a209 1
static __inline uint32_t
d216 1
a216 1
static __inline void
d225 1
a225 1
static __inline void
d237 1
a237 1
static __inline uint32_t
d242 1
d255 1
a255 1
static __inline void	ahc_update_residual(struct ahc_softc *ahc,
d257 1
a257 1
static __inline struct ahc_initiator_tinfo *
d263 1
a263 1
static __inline uint16_t
d265 1
a265 1
static __inline void	ahc_outw(struct ahc_softc *ahc, u_int port,
d267 1
a267 1
static __inline uint32_t
d269 1
a269 1
static __inline void	ahc_outl(struct ahc_softc *ahc, u_int port,
d271 1
a271 1
static __inline uint64_t
d273 1
a273 1
static __inline void	ahc_outq(struct ahc_softc *ahc, u_int port,
d278 1
d282 1
a282 1
static __inline struct scsi_sense_data *
d285 1
a285 1
static __inline uint32_t
d289 2
d295 1
a295 1
static __inline void
d309 1
a309 1
static __inline struct ahc_initiator_tinfo *
d325 1
a325 1
static __inline uint16_t
d331 1
a331 1
static __inline void
d338 1
a338 1
static __inline uint32_t
d347 1
a347 1
static __inline void
d356 1
a356 1
static __inline uint64_t
d369 1
a369 1
static __inline void
a381 2
#ifdef IO_EXPAND

a417 1
#endif	/* IO_EXPAND */
d419 1
a419 1
static __inline struct scb *
a430 1
#ifdef IO_EXPAND
a515 1
#endif	/* IO_EXPAND */
d517 1
a517 1
static __inline struct scsi_sense_data *
d526 1
a526 1
static __inline uint32_t
d535 1
d538 4
a541 4
static __inline void	ahc_sync_qoutfifo(struct ahc_softc *ahc, int op);
static __inline void	ahc_sync_qinfifo(struct ahc_softc *ahc, int op);
static __inline void	ahc_sync_tqinfifo(struct ahc_softc *ahc, int op);
static __inline u_int	ahc_check_cmdcmpltqueues(struct ahc_softc *ahc);
d544 2
a545 1
static __inline void
d552 1
a552 1
static __inline void
d559 1
a559 1
static __inline void
d579 1
a579 1
static __inline u_int
a604 1
#ifdef IO_EXPAND
@


1.11
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_inline.h,v 1.10 2005/06/01 21:49:54 miod Exp $	*/
d381 5
a385 7
	if ((scb = SLIST_FIRST(&ahc->scb_data->free_scbs)) == NULL) {
		ahc_alloc_scbs(ahc);
		scb = SLIST_FIRST(&ahc->scb_data->free_scbs);
		if (scb == NULL)
			return (NULL);
	}
	SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links.sle);
@


1.10
log
@De-inline a few functions if option SMALL_KERNEL, and do not compile
ahc_print_scb() unless option AHC_DEBUG.

Saves about 3KB on alpha RAMDISK{,B}.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_inline.h,v 1.9 2004/10/24 04:28:33 krw Exp $	*/
d474 1
a474 1
		panic("Attempt to queue invalid SCB tag %x:%x\n",
@


1.9
log
@Shuffle defines around so that ahc and ahd use the aic_ names that
come with the freebsd sources, rather than duplicating those names in
the ahd_ and ahc_ namespaces. Big reduction in delta to freebsd
sources, which reduces noise when updating the code.

No .o differences found on i386.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_inline.h,v 1.8 2004/08/01 01:36:23 krw Exp $	*/
d54 7
d254 1
d267 1
a267 1
static __inline struct scb*
d269 2
a270 2
static __inline void	ahc_free_scb(struct ahc_softc *ahc, struct scb *scb);
static __inline void	ahc_swap_with_next_hscb(struct ahc_softc *ahc,
d272 1
a272 1
static __inline void	ahc_queue_scb(struct ahc_softc *ahc, struct scb *scb);
d371 2
d376 1
a376 1
static __inline struct scb *
d394 1
a394 1
static __inline void
d411 2
d425 3
a427 1
static __inline void
d467 1
a467 1
static __inline void
d511 2
d537 1
a537 1
static __inline int	ahc_intr(struct ahc_softc *ahc);
d599 2
d604 1
a604 1
static __inline int
d685 2
@


1.8
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_inline.h,v 1.7 2003/12/24 22:45:45 krw Exp $	*/
d281 1
a281 1
	sgptr = ahc_le32toh(scb->hscb->sgptr);
d436 1
a436 1
		    ahc_htole32(ahc_hscb_busaddr(ahc, q_hscb->tag)
@


1.7
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d392 1
a392 1
	scb->flags = SCB_FREE;
d462 8
d598 1
a598 1
		return 0;
d615 1
d665 1
a665 1
	return 1;
@


1.6
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 3
d8 1
d17 8
a24 2
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d27 2
a28 1
 * GNU Public License ("GPL").
d30 6
a35 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d38 4
a41 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d43 1
a43 1
 * $Id: aic7xxx_inline.h,v 1.5 2003/09/29 19:28:16 mickey Exp $
d45 4
a48 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx_inline.h,v 1.17 2001/07/18 21:39:47 gibbs Exp $
d205 1
a205 1
	ahc_dmamap_sync(ahc, ahc->scb_data->hscb_dmat,
d217 1
a217 1
	ahc_dmamap_sync(ahc, ahc->scb_data->sg_dmat, scb->sg_map->sg_dmamap,
d238 1
a238 1
/*********************** Miscellaneous Support Functions **********************/
d240 2
a241 1
static __inline void	ahc_update_residual(struct scb *scb);
d247 12
d277 1
a277 1
ahc_update_residual(struct scb *scb)
d283 1
a283 1
		ahc_calc_residual(scb);
d300 2
a301 2
	if (channel == 'B')
		our_id += 8;
d306 57
d436 2
a437 2
		    ahc_hscb_busaddr(ahc, q_hscb->tag)
		  + offsetof(struct hardware_scb, cdb32);	
d460 1
a460 1
		panic("Attempt to queue invalid SCB tag %x:%x",
a461 1

d466 1
a466 1
	ahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
d513 1
a513 1
static __inline void	ahc_intr(struct ahc_softc *ahc);
d518 1
a518 1
	ahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
d525 1
a525 1
	ahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
d534 1
a534 1
		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
d555 1
a555 1
	ahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
d561 7
a567 6
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
				ahc->shared_data_dmamap,
				ahc_targetcmd_offset(ahc, ahc->tqinfifofnext),
				/*len*/sizeof(struct target_cmd),
				BUS_DMASYNC_POSTREAD);
d578 1
a578 1
static __inline void
a581 1
	u_int 	queuestat;
d583 9
d599 5
a603 10
	 && (queuestat = ahc_check_cmdcmpltqueues(ahc)) != 0)
		intstat = CMDCMPLT;
	else {
		intstat = ahc_inb(ahc, INTSTAT);
		queuestat = AHC_RUN_QOUTFIFO;
#ifdef AHC_TARGET_MODE
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			queuestat |= AHC_RUN_TQINFIFO;
#endif
	}
d605 1
a605 1
	if (intstat & CMDCMPLT) {
a606 1

d616 1
d618 1
a618 5
		if ((queuestat & AHC_RUN_QOUTFIFO) != 0)
#endif
			ahc_run_qoutfifo(ahc);
#ifdef AHC_TARGET_MODE
		if ((queuestat & AHC_RUN_TQINFIFO) != 0)
d625 1
a625 1
		return;
d635 1
d637 1
a637 2
		ahc->unsolicited_ints++;
		return;
d644 1
a644 1
		return;
d655 2
@


1.5
log
@more dmamp_sync()s; krw@@ ok
@
text
@d31 1
a31 1
 * $Id: aic7xxx_inline.h,v 1.4 2002/10/09 23:43:11 krw Exp $
d223 1
a223 1
/*********************** Miscelaneous Support Functions ***********************/
d388 1
a388 1
	 * Make sure our data is consistant from the
@


1.4
log
@Remove trailing '\n's from panic messages.

Started by a commit to siop from provos@@netbsd.org.

ok miod@@ millert@@
@
text
@d31 1
a31 1
 * $Id: aic7xxx_inline.h,v 1.3 2002/06/28 00:34:54 smurph Exp $
d381 5
a385 1
	ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
d426 1
d436 7
@


1.4.2.1
log
@sync to -current
@
text
@d31 1
a31 1
 * $Id$
@


1.3
log
@Return of new ahc
@
text
@d31 1
a31 1
 * $Id: //depot/src/aic7xxx/aic7xxx_inline.h#27 $
d375 1
a375 1
		panic("Attempt to queue invalid SCB tag %x:%x\n",
@


1.2
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d31 1
a31 1
 * $Id: aic7xxx_inline.h,v 1.1 2002/02/16 04:36:33 smurph Exp $
@


1.1
log
@New port of FreeBSD's ahc driver
@
text
@d31 1
a31 1
 * $Id: //depot/src/aic7xxx/aic7xxx_inline.h#27 $
@


1.1.2.1
log
@Merge in -current from about a week ago
@
text
@d31 1
a31 1
 * $Id: aic7xxx_inline.h,v 1.1 2002/02/16 04:36:33 smurph Exp $
@


1.1.2.2
log
@Sync SMP to 3.3, files that CVS misses due to some bug
@
text
@d31 1
a31 1
 * $Id$
d375 1
a375 1
		panic("Attempt to queue invalid SCB tag %x:%x",
@


1.1.2.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a0 3
/*	$OpenBSD$	*/
/*	$NetBSD: aic7xxx_inline.h,v 1.4 2003/11/02 11:07:44 wiz Exp $	*/

a4 1
 * Copyright (c) 2000-2001 Adaptec Inc.
d13 2
a14 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 1
a17 2
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
d19 5
a23 6
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d26 4
a29 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d31 1
a31 1
 * //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#39 $
d33 1
a33 4
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx_inline.h,v 1.20 2003/01/20 20:44:55 gibbs Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
d190 1
a190 1
	ahc_dmamap_sync(ahc, ahc->parent_dmat,
d202 1
a202 1
	ahc_dmamap_sync(ahc, ahc->parent_dmat, scb->sg_map->sg_dmamap,
d223 1
a223 1
/*********************** Miscellaneous Support Functions ***********************/
d225 1
a225 2
static __inline void	ahc_update_residual(struct ahc_softc *ahc,
					    struct scb *scb);
a230 12
static __inline uint16_t
			ahc_inw(struct ahc_softc *ahc, u_int port);
static __inline void	ahc_outw(struct ahc_softc *ahc, u_int port,
				 u_int value);
static __inline uint32_t
			ahc_inl(struct ahc_softc *ahc, u_int port);
static __inline void	ahc_outl(struct ahc_softc *ahc, u_int port,
				 uint32_t value);
static __inline uint64_t
			ahc_inq(struct ahc_softc *ahc, u_int port);
static __inline void	ahc_outq(struct ahc_softc *ahc, u_int port,
				 uint64_t value);
d249 1
a249 1
ahc_update_residual(struct ahc_softc *ahc, struct scb *scb)
d255 1
a255 1
		ahc_calc_residual(ahc, scb);
d272 2
a273 2
	/*if (channel == 'B')
	  our_id += 8;*/
a277 57
static __inline uint16_t
ahc_inw(struct ahc_softc *ahc, u_int port)
{
	return ((ahc_inb(ahc, port+1) << 8) | ahc_inb(ahc, port));
}

static __inline void
ahc_outw(struct ahc_softc *ahc, u_int port, u_int value)
{
	ahc_outb(ahc, port, value & 0xFF);
	ahc_outb(ahc, port+1, (value >> 8) & 0xFF);
}

static __inline uint32_t
ahc_inl(struct ahc_softc *ahc, u_int port)
{
	return ((ahc_inb(ahc, port))
	      | (ahc_inb(ahc, port+1) << 8)
	      | (ahc_inb(ahc, port+2) << 16)
	      | (ahc_inb(ahc, port+3) << 24));
}

static __inline void
ahc_outl(struct ahc_softc *ahc, u_int port, uint32_t value)
{
	ahc_outb(ahc, port, (value) & 0xFF);
	ahc_outb(ahc, port+1, ((value) >> 8) & 0xFF);
	ahc_outb(ahc, port+2, ((value) >> 16) & 0xFF);
	ahc_outb(ahc, port+3, ((value) >> 24) & 0xFF);
}

static __inline uint64_t
ahc_inq(struct ahc_softc *ahc, u_int port)
{
	return ((ahc_inb(ahc, port))
	      | (ahc_inb(ahc, port+1) << 8)
	      | (ahc_inb(ahc, port+2) << 16)
	      | (ahc_inb(ahc, port+3) << 24)
	      | (((uint64_t)ahc_inb(ahc, port+4)) << 32)
	      | (((uint64_t)ahc_inb(ahc, port+5)) << 40)
	      | (((uint64_t)ahc_inb(ahc, port+6)) << 48)
	      | (((uint64_t)ahc_inb(ahc, port+7)) << 56));
}

static __inline void
ahc_outq(struct ahc_softc *ahc, u_int port, uint64_t value)
{
	ahc_outb(ahc, port, value & 0xFF);
	ahc_outb(ahc, port+1, (value >> 8) & 0xFF);
	ahc_outb(ahc, port+2, (value >> 16) & 0xFF);
	ahc_outb(ahc, port+3, (value >> 24) & 0xFF);
	ahc_outb(ahc, port+4, (value >> 32) & 0xFF);
	ahc_outb(ahc, port+5, (value >> 40) & 0xFF);
	ahc_outb(ahc, port+6, (value >> 48) & 0xFF);
	ahc_outb(ahc, port+7, (value >> 56) & 0xFF);
}

d351 2
a352 2
		    ahc_htole32(ahc_hscb_busaddr(ahc, q_hscb->tag)
			      + offsetof(struct hardware_scb, cdb32));
d375 1
a375 1
		panic("Attempt to queue invalid SCB tag %x:%x\n",
d377 1
d381 1
a381 5
	ahc->qinfifo[ahc->qinfifonext] = scb->hscb->tag;
	ahc_dmamap_sync(ahc, ahc->parent_dmat, ahc->shared_data_dmamap,
			/*offset*/ahc->qinfifonext+256, /*len*/1,
			BUS_DMASYNC_PREWRITE);
	ahc->qinfifonext++;
d384 1
a384 1
	 * Make sure our data is consistent from the
a421 1
static __inline void	ahc_sync_qinfifo(struct ahc_softc *ahc, int op);
d424 1
a424 1
static __inline int	ahc_intr(struct ahc_softc *ahc);
d429 1
a429 1
	ahc_dmamap_sync(ahc, ahc->parent_dmat, ahc->shared_data_dmamap,
a433 7
ahc_sync_qinfifo(struct ahc_softc *ahc, int op)
{
	ahc_dmamap_sync(ahc, ahc->parent_dmat, ahc->shared_data_dmamap,
			/*offset*/256, /*len*/256, op);
}

static __inline void
d438 1
a438 1
	  ahc_dmamap_sync(ahc, ahc->parent_dmat /*shared_data_dmat*/,
d459 1
a459 1
	ahc_dmamap_sync(ahc, ahc->parent_dmat /*shared_data_dmat*/, ahc->shared_data_dmamap,
d465 6
a470 7
	if ((ahc->flags & AHC_TARGETROLE) != 0
	    && (ahc->flags & AHC_TQINFIFO_BLOCKED) == 0) {
	  ahc_dmamap_sync(ahc, ahc->parent_dmat /*shared_data_dmat*/,
			  ahc->shared_data_dmamap,
			  ahc_targetcmd_offset(ahc, ahc->tqinfifonext),
			  /*len*/sizeof(struct target_cmd),
			  BUS_DMASYNC_POSTREAD);
d481 1
a481 1
static __inline int
d485 1
a486 9
	if ((ahc->pause & INTEN) == 0) {
		/*
		 * Our interrupt is not enabled on the chip
		 * and may be disabled for re-entrancy reasons,
		 * so just return.  This is likely just a shared
		 * interrupt.
		 */
		return 0;
	}
d494 10
a503 5
	    && (ahc_check_cmdcmpltqueues(ahc) != 0))
                intstat = CMDCMPLT;
        else {
                intstat = ahc_inb(ahc, INTSTAT);
        }
d505 1
a505 1
        if (intstat & CMDCMPLT) {
d507 1
a516 1
		ahc_run_qoutfifo(ahc);
d518 5
a522 1
		if ((ahc->flags & AHC_TARGETROLE) != 0)
d529 1
a529 1
		return 1;
d539 1
d541 1
a541 2
#endif
		return 0;
d548 1
a548 1
		return 1;
a558 2

	return 1;
@


