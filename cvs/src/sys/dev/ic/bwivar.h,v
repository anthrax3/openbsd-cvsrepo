head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.12
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.10
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.4
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.26.0.14
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.12
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.4
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23;
locks; strict;
comment	@ * @;


1.31
date	2014.11.05.01.02.10;	author daniel;	state Exp;
branches;
next	1.30;
commitid	eFshAu2yrXroX4tH;

1.30
date	2014.07.20.11.59.12;	author stsp;	state Exp;
branches;
next	1.29;
commitid	hPCwB7yoKDSfJ35n;

1.29
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.26.20.33.15;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.11.14.12.10.05;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.06.05.26.24;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.07.01.01.41;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.21.04.12.21;	author kevlo;	state Exp;
branches;
next	1.23;

1.23
date	2008.02.25.20.36.54;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2008.02.16.16.45.28;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.16.14.56.00;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.17.16.50.02;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.18.05.56.15;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.04.05.44.43;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.01.11.27.11;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.27.22.17.32;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.27.22.10.25;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.27.09.19.21;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.27.05.58.57;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.24.19.51.18;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.18.17.35.38;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.16.19.02.37;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.15.22.47.14;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.15.13.38.22;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.15.07.20.51;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.14.20.26.04;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.14.13.00.41;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.13.14.48.29;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.13.08.28.37;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.12.22.22.05;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.12.13.13.12;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Functions that say they return void should not try to return something.

ok deraadt@@
"Even though I admire the chutzpah of return(void), I agree". ok krw@@
@
text
@/*	$OpenBSD: bwivar.h,v 1.30 2014/07/20 11:59:12 stsp Exp $	*/

/*
 * Copyright (c) 2007 The DragonFly Project.  All rights reserved.
 * 
 * This code is derived from software contributed to The DragonFly Project
 * by Sepherosa Ziehau <sepherosa@@gmail.com>
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of The DragonFly Project nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific, prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * $DragonFly: src/sys/dev/netif/bwi/if_bwivar.h,v 1.1 2007/09/08 06:15:54 sephe Exp $
 */

#ifndef _IF_BWIVAR_H
#define _IF_BWIVAR_H

#define BWI_ALIGN		0x1000
#define BWI_RING_ALIGN		BWI_ALIGN
#define BWI_BUS_SPACE_MAXADDR	0x3fffffff

#define BWI_TX_NRING		6
#define BWI_TXRX_NRING		6
#define BWI_TX_NDESC		128
#define BWI_RX_NDESC		64
#define BWI_TXSTATS_NDESC	64
#define BWI_TX_NSPRDESC		2
#define BWI_TX_DATA_RING	1

/* XXX Onoe/Sample/AMRR probably need different configuration */
#define BWI_SHRETRY		7
#define BWI_LGRETRY		4
#define BWI_SHRETRY_FB		3
#define BWI_LGRETRY_FB		2

#define BWI_LED_EVENT_NONE	-1
#define BWI_LED_EVENT_POLL	0
#define BWI_LED_EVENT_TX	1
#define BWI_LED_EVENT_RX	2
#define BWI_LED_SLOWDOWN(dur)	(dur) = (((dur) * 3) / 2)

enum bwi_txpwrcb_type {
	BWI_TXPWR_INIT = 0,
	BWI_TXPWR_FORCE = 1,
	BWI_TXPWR_CALIB = 2
};

#define BWI_NOISE_FLOOR		-95	/* TODO: noise floor calc */

#define CSR_READ_4(sc, reg)			\
	bus_space_read_4((sc)->sc_mem_bt, (sc)->sc_mem_bh, (reg))
#define CSR_READ_2(sc, reg)			\
	bus_space_read_2((sc)->sc_mem_bt, (sc)->sc_mem_bh, (reg))

#define CSR_WRITE_4(sc, reg, val)		\
	bus_space_write_4((sc)->sc_mem_bt, (sc)->sc_mem_bh, (reg), (val))
#define CSR_WRITE_2(sc, reg, val)		\
	bus_space_write_2((sc)->sc_mem_bt, (sc)->sc_mem_bh, (reg), (val))

#define CSR_SETBITS_4(sc, reg, bits)		\
	CSR_WRITE_4((sc), (reg), CSR_READ_4((sc), (reg)) | (bits))
#define CSR_SETBITS_2(sc, reg, bits)		\
	CSR_WRITE_2((sc), (reg), CSR_READ_2((sc), (reg)) | (bits))

#define CSR_FILT_SETBITS_4(sc, reg, filt, bits) \
	CSR_WRITE_4((sc), (reg), (CSR_READ_4((sc), (reg)) & (filt)) | (bits))
#define CSR_FILT_SETBITS_2(sc, reg, filt, bits)	\
	CSR_WRITE_2((sc), (reg), (CSR_READ_2((sc), (reg)) & (filt)) | (bits))

#define CSR_CLRBITS_4(sc, reg, bits)		\
	CSR_WRITE_4((sc), (reg), CSR_READ_4((sc), (reg)) & ~(bits))
#define CSR_CLRBITS_2(sc, reg, bits)		\
	CSR_WRITE_2((sc), (reg), CSR_READ_2((sc), (reg)) & ~(bits))

struct bwi_desc32 {
	/* Little endian */
	uint32_t	ctrl;
	uint32_t	addr;	/* BWI_DESC32_A_ */
} __packed;

#define BWI_DESC32_A_FUNC_TXRX		0x1
#define BWI_DESC32_A_FUNC_MASK		0xc0000000
#define BWI_DESC32_A_ADDR_MASK		0x3fffffff

#define BWI_DESC32_C_BUFLEN_MASK	0x00001fff
#define BWI_DESC32_C_ADDRHI_MASK	0x00030000
#define BWI_DESC32_C_EOR		(1 << 28)
#define BWI_DESC32_C_INTR		(1 << 29)
#define BWI_DESC32_C_FRAME_END		(1 << 30)
#define BWI_DESC32_C_FRAME_START	(1U << 31)

struct bwi_desc64 {
	/* Little endian */
	uint32_t	ctrl0;
	uint32_t	ctrl1;
	uint32_t	addr_lo;
	uint32_t	addr_hi;
} __packed;

struct bwi_rxbuf_hdr {
	/* Little endian */
	uint16_t	rxh_buflen;	/* exclude bwi_rxbuf_hdr */
	uint8_t		rxh_pad1[2];
	uint16_t	rxh_flags1;
	uint8_t		rxh_rssi;
	uint8_t		rxh_sq;
	uint16_t	rxh_phyinfo;	/* BWI_RXH_PHYINFO_ */
	uint16_t	rxh_flags3;
	uint16_t	rxh_flags2;	/* BWI_RXH_F2_ */
	uint16_t	rxh_tsf;
	uint8_t		rxh_pad3[14];	/* Padded to 30bytes */
} __packed;

#define BWI_RXH_F1_BCM2053_RSSI (1 << 14)
#define BWI_RXH_F1_OFDM		(1 << 0)

#define BWI_RXH_F2_TYPE2FRAME	(1 << 2)

#define BWI_RXH_F3_BCM2050_RSSI	(1 << 10)

#define BWI_RXH_PHYINFO_LNAGAIN	(3 << 14)

struct bwi_txbuf_hdr {
	/* Little endian */
	uint32_t	txh_mac_ctrl;	/* BWI_TXH_MAC_C_ */
	uint8_t		txh_fc[2];
	uint16_t	txh_unknown1;
	uint16_t	txh_phy_ctrl;	/* BWI_TXH_PHY_C_ */
	uint8_t		txh_ivs[16];
	uint8_t		txh_addr1[IEEE80211_ADDR_LEN];
	uint16_t	txh_unknown2;
	uint8_t		txh_rts_fb_plcp[4];
	uint16_t	txh_rts_fb_duration;
	uint8_t		txh_fb_plcp[4];
	uint16_t	txh_fb_duration;
	uint8_t		txh_pad2[2];
	uint16_t	txh_id;		/* BWI_TXH_ID_ */
	uint16_t	txh_unknown3;
	uint8_t		txh_rts_plcp[6];
	uint8_t		txh_rts_fc[2];
	uint16_t	txh_rts_duration;
	uint8_t		txh_rts_ra[IEEE80211_ADDR_LEN];
	uint8_t		txh_rts_ta[IEEE80211_ADDR_LEN];
	uint8_t		txh_pad3[2];
	uint8_t		txh_plcp[6];
} __packed;

#define BWI_TXH_ID_RING_MASK		0xe000
#define BWI_TXH_ID_IDX_MASK		0x1fff

#define BWI_TXH_PHY_C_OFDM		(1 << 0)
#define BWI_TXH_PHY_C_SHPREAMBLE	(1 << 4)
#define BWI_TXH_PHY_C_ANTMODE_MASK	0x0300

#define BWI_TXH_MAC_C_ACK		(1 << 0)
#define BWI_TXH_MAC_C_FIRST_FRAG	(1 << 3)
#define BWI_TXH_MAC_C_HWSEQ		(1 << 4)
#define BWI_TXH_MAC_C_FB_OFDM		(1 << 8)

struct bwi_txstats {
	/* Little endian */
	uint8_t		txs_pad1[4];
	uint16_t	txs_id;
	uint8_t		txs_flags;
	uint8_t		txs_retry_cnt;
	uint8_t		txs_pad2[2];
	uint16_t	txs_seq;
	uint16_t	txs_unknown;
	uint8_t		txs_pad3[2];	/* Padded to 16bytes */
} __packed;

struct bwi_ring_data {
	uint32_t		 rdata_txrx_ctrl;
	bus_size_t		 rdata_ring_sz;
	bus_dmamap_t		 rdata_dmap;
	bus_addr_t		 rdata_paddr;
	void			*rdata_desc;
};

struct bwi_txbuf {
	struct mbuf		*tb_mbuf;
	bus_dmamap_t		 tb_dmap;

	struct ieee80211_node	*tb_ni;
	int			 tb_rate_idx[2];
};

struct bwi_txbuf_data {
	struct bwi_txbuf	tbd_buf[BWI_TX_NDESC];
	int			tbd_used;
	int			tbd_idx;
};

struct bwi_rxbuf {
	struct mbuf		*rb_mbuf;
	bus_addr_t		 rb_paddr;
	bus_dmamap_t		 rb_dmap;
};

struct bwi_rxbuf_data {
	struct bwi_rxbuf	rbd_buf[BWI_RX_NDESC];
	bus_dmamap_t		rbd_tmp_dmap;
	int			rbd_idx;
};

struct bwi_txstats_data {
	bus_dma_segment_t	 stats_ring_seg;
	bus_dmamap_t		 stats_ring_dmap;
	bus_addr_t		 stats_ring_paddr;
	void			*stats_ring;

	bus_dma_segment_t	 stats_seg;
	bus_dmamap_t		 stats_dmap;
	bus_addr_t		 stats_paddr;
	struct bwi_txstats	*stats;

	uint32_t		 stats_ctrl_base;
	int			 stats_idx;
};

struct bwi_fwhdr {
	/* Big endian */
	uint8_t		fw_type;	/* BWI_FW_T_ */
	uint8_t		fw_gen;		/* BWI_FW_GEN */
	uint8_t		fw_pad[2];
	uint32_t	fw_size;
#define fw_iv_cnt	fw_size
} __packed;

#define BWI_FWHDR_SZ		sizeof(struct bwi_fwhdr)
#define BWI_FW_VERSION3		3
#define BWI_FW_VERSION4		4
#define BWI_FW_VERSION3_REVMAX	0x128
#define BWI_FW_T_UCODE          'u'
#define BWI_FW_T_PCM            'p'
#define BWI_FW_T_IV             'i'
#define BWI_FW_GEN_1            1
#define BWI_FW_IV_OFS_MASK	0x7fff
#define BWI_FW_IV_IS_32BIT	(1 << 15)

struct fwheader {
	char	filename[64];
	int	filesize;
	int	fileoffset;
};

struct bwi_fw_iv {
	/* Big endian */
	uint16_t		iv_ofs;
	union {
		uint32_t	val32;
		uint16_t	val16;
	}			iv_val;
} __packed;

struct bwi_led {
	uint8_t			l_flags;	/* BWI_LED_F_ */
	uint8_t			l_act;		/* BWI_LED_ACT_ */
	uint8_t			l_mask;
};

#define BWI_LED_F_ACTLOW	0x1
#define BWI_LED_F_BLINK		0x2
#define BWI_LED_F_POLLABLE	0x4
#define BWI_LED_F_SLOW		0x8

enum bwi_clock_mode {
	BWI_CLOCK_MODE_SLOW,
	BWI_CLOCK_MODE_FAST,
	BWI_CLOCK_MODE_DYN
};

struct bwi_regwin {
	uint32_t		rw_flags;	/* BWI_REGWIN_F_ */
	uint16_t		rw_type;	/* BWI_REGWIN_T_ */
	uint8_t			rw_id;
	uint8_t			rw_rev;
};

#define BWI_REGWIN_F_EXIST	0x1

#define BWI_CREATE_REGWIN(rw, id, type, rev)	\
do {						\
	(rw)->rw_flags = BWI_REGWIN_F_EXIST;	\
	(rw)->rw_type = (type);			\
	(rw)->rw_id = (id);			\
	(rw)->rw_rev = (rev);			\
} while (0)

#define BWI_REGWIN_EXIST(rw)	((rw)->rw_flags & BWI_REGWIN_F_EXIST)
#define BWI_GPIO_REGWIN(sc)				\
	(BWI_REGWIN_EXIST(&(sc)->sc_com_regwin) ?	\
	&(sc)->sc_com_regwin : &(sc)->sc_bus_regwin)

struct bwi_mac;

struct bwi_phy {
	enum ieee80211_phymode	phy_mode;
	int			phy_rev;
	int			phy_version;

	uint32_t		phy_flags;		/* BWI_PHY_F_ */
	uint16_t		phy_tbl_ctrl;
	uint16_t		phy_tbl_data_lo;
	uint16_t		phy_tbl_data_hi;

	void			(*phy_init)(struct bwi_mac *);
};

#define BWI_PHY_F_CALIBRATED	0x1
#define BWI_PHY_F_LINKED	0x2
#define BWI_CLEAR_PHY_FLAGS	(BWI_PHY_F_CALIBRATED)

/* TX power control */
struct bwi_tpctl {
	uint16_t		bbp_atten;	/* BBP attenuation: 4bits */
	uint16_t		rf_atten;	/* RF attenuation */
	uint16_t		tp_ctrl1;	/* ??: 3bits */
	uint16_t		tp_ctrl2;	/* ??: 4bits */
};

#define BWI_RF_ATTEN_FACTOR	4
#define BWI_RF_ATTEN_MAX0	9
#define BWI_RF_ATTEN_MAX1	31
#define BWI_BBP_ATTEN_MAX	11
#define BWI_TPCTL1_MAX		7

struct bwi_rf_lo {
	int8_t			ctrl_lo;
	int8_t			ctrl_hi;
};

struct bwi_rf {
	uint16_t		rf_type;	/* BWI_RF_T_ */
	uint16_t		rf_manu;
	int			rf_rev;

	uint32_t		rf_flags;	/* BWI_RF_F_ */

#define BWI_RFLO_MAX		56
	struct bwi_rf_lo	rf_lo[BWI_RFLO_MAX];
	uint8_t			rf_lo_used[8];

#define BWI_INVALID_NRSSI	-1000
	int16_t			rf_nrssi[2];	/* Narrow RSSI */
	int32_t			rf_nrssi_slope;

#define BWI_NRSSI_TBLSZ		64
	int8_t			rf_nrssi_table[BWI_NRSSI_TBLSZ];

	uint16_t		rf_lo_gain;	/* loopback gain */
	uint16_t		rf_rx_gain;	/* TRSW RX gain */

	uint16_t		rf_calib;	/* RF calibration value */
	uint			rf_curchan;	/* current channel */

	uint16_t		rf_ctrl_rd;
	int			rf_ctrl_adj;
	void			(*rf_off)(struct bwi_mac *);
	void			(*rf_on)(struct bwi_mac *);

	void			(*rf_set_nrssi_thr)(struct bwi_mac *);
	void			(*rf_calc_nrssi_slope)(struct bwi_mac *);
	int			(*rf_calc_rssi)
				(struct bwi_mac *,
				 const struct bwi_rxbuf_hdr *);

	void			(*rf_lo_update)(struct bwi_mac *);

#define BWI_TSSI_MAX		64
	int8_t			rf_txpower_map0[BWI_TSSI_MAX];
						/* Indexed by TSSI */
	int			rf_idle_tssi0;

	int8_t			rf_txpower_map[BWI_TSSI_MAX];
	int			rf_idle_tssi;

	int			rf_base_tssi;

	int			rf_txpower_max;	/* dBm */

	int			rf_ant_mode;	/* BWI_ANT_MODE_ */
};

#define BWI_RF_F_INITED		0x1
#define BWI_RF_F_ON		0x2
#define BWI_RF_CLEAR_FLAGS	(BWI_RF_F_INITED)

#define BWI_ANT_MODE_0		0
#define BWI_ANT_MODE_1		1
#define BWI_ANT_MODE_UNKN	2
#define BWI_ANT_MODE_AUTO	3

struct fw_image;

struct bwi_mac {
	struct bwi_regwin	 mac_regwin;	/* MUST be first field */
#define mac_rw_flags		 mac_regwin.rw_flags
#define mac_type		 mac_regwin.rw_type
#define mac_id			 mac_regwin.rw_id
#define mac_rev			 mac_regwin.rw_rev
	struct bwi_softc	*mac_sc;

	struct bwi_phy		 mac_phy;	/* PHY I/F */
	struct bwi_rf		 mac_rf;	/* RF I/F */

	struct bwi_tpctl	 mac_tpctl;	/* TX power control */
	uint32_t		 mac_flags;	/* BWI_MAC_F_ */

	uint8_t			*mac_fw;
	size_t			 mac_fw_size;
	uint8_t			*mac_ucode;
	size_t			 mac_ucode_size;
	uint8_t			*mac_pcm;
	size_t			 mac_pcm_size;
	uint8_t			*mac_iv;
	size_t			 mac_iv_size;
	uint8_t			*mac_iv_ext;
	size_t			 mac_iv_ext_size;
};

#define BWI_MAC_F_BSWAP		0x1
#define BWI_MAC_F_TPCTL_INITED	0x2
#define BWI_MAC_F_HAS_TXSTATS	0x4
#define BWI_MAC_F_INITED	0x8
#define BWI_MAC_F_ENABLED	0x10
#define BWI_MAC_F_LOCKED	0x20	/* for debug */
#define BWI_MAC_F_TPCTL_ERROR	0x40
#define BWI_MAC_F_PHYE_RESET	0x80

#define BWI_CREATE_MAC(mac, sc, id, rev)	\
do {						\
	BWI_CREATE_REGWIN(&(mac)->mac_regwin,	\
	    (id), BWI_REGWIN_T_MAC, (rev));	\
	(mac)->mac_sc = (sc);			\
} while (0)

#define BWI_MAC_MAX		2
#define BWI_LED_MAX		4

enum bwi_bus_space {
	BWI_BUS_SPACE_30BIT = 1,
	BWI_BUS_SPACE_32BIT,
	BWI_BUS_SPACE_64BIT
};

#define BWI_TX_RADIOTAP_PRESENT 		\
	((1 << IEEE80211_RADIOTAP_FLAGS) |	\
	 (1 << IEEE80211_RADIOTAP_RATE) |	\
	 (1 << IEEE80211_RADIOTAP_CHANNEL))

struct bwi_tx_radiotap_hdr {
	struct ieee80211_radiotap_header wt_ihdr;
	uint8_t		wt_flags;
	uint8_t		wt_rate;
	uint16_t	wt_chan_freq;
	uint16_t	wt_chan_flags;
};

#define BWI_RX_RADIOTAP_PRESENT				\
	((1 << IEEE80211_RADIOTAP_TSFT) |		\
	 (1 << IEEE80211_RADIOTAP_FLAGS) |		\
	 (1 << IEEE80211_RADIOTAP_RATE) |		\
	 (1 << IEEE80211_RADIOTAP_CHANNEL) |		\
	 (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |	\
	 (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE))

struct bwi_rx_radiotap_hdr {
	struct ieee80211_radiotap_header wr_ihdr;
	uint64_t	wr_tsf;
	uint8_t		wr_flags;
	uint8_t		wr_rate;
	uint16_t	wr_chan_freq;
	uint16_t	wr_chan_flags;
	int8_t		wr_antsignal;
	int8_t		wr_antnoise;
	/* TODO: sq */
};

struct bwi_node {
	struct ieee80211_node		ni;
	struct ieee80211_amrr_node	amn;
};

struct bwi_softc {
	struct device		 sc_dev;
	struct ieee80211com	 sc_ic;
	uint32_t		 sc_flags;	/* BWI_F_ */

	uint32_t		 sc_cap;	/* BWI_CAP_ */
	uint16_t		 sc_bbp_id;	/* BWI_BBPID_ */
	uint8_t			 sc_bbp_rev;
	uint8_t			 sc_bbp_pkg;

	uint8_t			 sc_pci_revid;
	uint16_t		 sc_pci_did;
	uint16_t		 sc_pci_subvid;
	uint16_t		 sc_pci_subdid;

	uint16_t		 sc_card_flags;	/* BWI_CARD_F_ */
	uint16_t		 sc_pwron_delay;
	int			 sc_locale;

	bus_dma_tag_t		 sc_dmat;
	bus_space_tag_t		 sc_mem_bt;
	bus_space_handle_t	 sc_mem_bh;

	struct timeout		 sc_scan_ch;
	struct timeout		 sc_calib_ch;
	struct timeout		 sc_amrr_ch;

	struct ieee80211_amrr	 sc_amrr;

	struct bwi_regwin	*sc_cur_regwin;
	struct bwi_regwin	 sc_com_regwin;
	struct bwi_regwin	 sc_bus_regwin;

	int			 sc_nmac;
	struct bwi_mac		 sc_mac[BWI_MAC_MAX];

	int			 sc_rx_rate;
	int			 sc_tx_rate;
	enum bwi_txpwrcb_type	 sc_txpwrcb_type;

	int			 sc_led_blinking;
	int			 sc_led_ticks;
	struct bwi_led		*sc_blink_led;
	struct timeout		 sc_led_blink_next_ch;
	struct timeout		 sc_led_blink_end_ch;
	int			 sc_led_blink_offdur;
	struct bwi_led		 sc_leds[BWI_LED_MAX];
 
	enum bwi_bus_space	 sc_bus_space;

	/* bounce buffers for 30 bit bus space devices */
	caddr_t			 sc_bounce_tx_data[BWI_TX_NRING];
	caddr_t			 sc_bounce_rx_data;

	struct bwi_txbuf_data	 sc_tx_bdata[BWI_TX_NRING];
	struct bwi_rxbuf_data	 sc_rx_bdata;

	struct bwi_ring_data	 sc_tx_rdata[BWI_TX_NRING];
	struct bwi_ring_data	 sc_rx_rdata;

	struct bwi_txstats_data	*sc_txstats;

	int			 sc_tx_timer;

	int			 (*sc_newstate)
				 (struct ieee80211com *,
				     enum ieee80211_state, int);

	int			 (*sc_init_tx_ring)(struct bwi_softc *, int);
	void			 (*sc_free_tx_ring)(struct bwi_softc *, int);

	int			 (*sc_init_rx_ring)(struct bwi_softc *);
	void			 (*sc_free_rx_ring)(struct bwi_softc *);
	int			 (*sc_newbuf)(struct bwi_softc *, int, int);

	int			 (*sc_init_txstats)(struct bwi_softc *);
	void			 (*sc_free_txstats)(struct bwi_softc *);

	void			 (*sc_setup_rxdesc)
				 (struct bwi_softc *, int, bus_addr_t, int);
	int			 (*sc_rxeof)(struct bwi_softc *);

	void			 (*sc_setup_txdesc)
				 (struct bwi_softc *, struct bwi_ring_data *,
				     int, bus_addr_t, int);
	void			 (*sc_start_tx)
				 (struct bwi_softc *, uint32_t, int);

	void			 (*sc_txeof_status)(struct bwi_softc *);

	int			 (*sc_enable)(struct bwi_softc *); 
	void			 (*sc_disable)(struct bwi_softc *);

	void			 (*sc_conf_write)(void *, uint32_t, uint32_t);
	uint32_t		 (*sc_conf_read)(void *, uint32_t);

	/* Sysctl variables */
	int			 sc_fw_version;	/* BWI_FW_VERSION[34] */
	int			 sc_dwell_time;	/* milliseconds */
	int			 sc_led_idle;
	int			 sc_led_blink;

#if NBPFILTER > 0
        caddr_t                  sc_drvbpf;
 
        union {
                struct bwi_rx_radiotap_hdr th;
                uint8_t pad[64];
        }                        sc_rxtapu;
#define sc_rxtap                 sc_rxtapu.th
        int                      sc_rxtap_len;
 
        union {
                struct bwi_tx_radiotap_hdr th;
                uint8_t pad[64];
        }                        sc_txtapu;
#define sc_txtap                 sc_txtapu.th
        int                      sc_txtap_len;
#endif
};

#define BWI_F_BUS_INITED	0x1
#define BWI_F_PROMISC		0x2

#define MOBJ_WRITE_2(mac, objid, ofs, val)			\
	bwi_memobj_write_2((mac), (objid), (ofs), (val))
#define MOBJ_WRITE_4(mac, objid, ofs, val)			\
	bwi_memobj_write_4((mac), (objid), (ofs), (val))
#define MOBJ_READ_2(mac, objid, ofs)				\
	bwi_memobj_read_2((mac), (objid), (ofs))
#define MOBJ_READ_4(mac, objid, ofs)				\
	bwi_memobj_read_4((mac), (objid), (ofs))

#define MOBJ_SETBITS_4(mac, objid, ofs, bits)			\
	MOBJ_WRITE_4((mac), (objid), (ofs),			\
	MOBJ_READ_4((mac), (objid), (ofs)) | (bits))
#define MOBJ_CLRBITS_4(mac, objid, ofs, bits)			\
	MOBJ_WRITE_4((mac), (objid), (ofs),			\
	MOBJ_READ_4((mac), (objid), (ofs)) & ~(bits))

#define MOBJ_FILT_SETBITS_2(mac, objid, ofs, filt, bits)	\
	MOBJ_WRITE_2((mac), (objid), (ofs),			\
	(MOBJ_READ_2((mac), (objid), (ofs)) & (filt)) | (bits))

#define TMPLT_WRITE_4(mac, ofs, val)	bwi_tmplt_write_4((mac), (ofs), (val))

#define HFLAGS_WRITE(mac, flags)	bwi_hostflags_write((mac), (flags))
#define HFLAGS_READ(mac)		bwi_hostflags_read((mac))
#define HFLAGS_CLRBITS(mac, bits)				\
	HFLAGS_WRITE((mac), HFLAGS_READ((mac)) | (bits))
#define HFLAGS_SETBITS(mac, bits)				\
	HFLAGS_WRITE((mac), HFLAGS_READ((mac)) & ~(bits))

/* PHY */

struct bwi_gains {
	int16_t	tbl_gain1;
	int16_t	tbl_gain2;
	int16_t	phy_gain;
};

static __inline void
bwi_phy_init(struct bwi_mac *_mac)
{
	_mac->mac_phy.phy_init(_mac);
}

#define PHY_WRITE(mac, ctrl, val)	bwi_phy_write((mac), (ctrl), (val))
#define PHY_READ(mac, ctrl)		bwi_phy_read((mac), (ctrl))

#define PHY_SETBITS(mac, ctrl, bits)		\
	PHY_WRITE((mac), (ctrl), PHY_READ((mac), (ctrl)) | (bits))
#define PHY_CLRBITS(mac, ctrl, bits)		\
	PHY_WRITE((mac), (ctrl), PHY_READ((mac), (ctrl)) & ~(bits))
#define PHY_FILT_SETBITS(mac, ctrl, filt, bits)	\
	PHY_WRITE((mac), (ctrl), (PHY_READ((mac), (ctrl)) & (filt)) | (bits))

static __inline void
bwi_rf_off(struct bwi_mac *_mac)
{
	_mac->mac_rf.rf_off(_mac);
	/* TODO: LED */

	_mac->mac_rf.rf_flags &= ~BWI_RF_F_ON;
}

static __inline void
bwi_rf_on(struct bwi_mac *_mac)
{
	if (_mac->mac_rf.rf_flags & BWI_RF_F_ON)
		return;

	_mac->mac_rf.rf_on(_mac);
	/* TODO: LED */

	_mac->mac_rf.rf_flags |= BWI_RF_F_ON;
}

static __inline void
bwi_rf_calc_nrssi_slope(struct bwi_mac *_mac)
{
	_mac->mac_rf.rf_calc_nrssi_slope(_mac);
}

static __inline void
bwi_rf_set_nrssi_thr(struct bwi_mac *_mac)
{
	_mac->mac_rf.rf_set_nrssi_thr(_mac);
}

static __inline int
bwi_rf_calc_rssi(struct bwi_mac *_mac, const struct bwi_rxbuf_hdr *_hdr)
{
	return (_mac->mac_rf.rf_calc_rssi(_mac, _hdr));
}

static __inline void
bwi_rf_lo_update(struct bwi_mac *_mac)
{
	_mac->mac_rf.rf_lo_update(_mac);
}

#define RF_WRITE(mac, ofs, val)		bwi_rf_write((mac), (ofs), (val))
#define RF_READ(mac, ofs)		bwi_rf_read((mac), (ofs))

#define RF_SETBITS(mac, ofs, bits)		\
	RF_WRITE((mac), (ofs), RF_READ((mac), (ofs)) | (bits))
#define RF_CLRBITS(mac, ofs, bits)		\
	RF_WRITE((mac), (ofs), RF_READ((mac), (ofs)) & ~(bits))
#define RF_FILT_SETBITS(mac, ofs, filt, bits)	\
	RF_WRITE((mac), (ofs), (RF_READ((mac), (ofs)) & (filt)) | (bits))

#endif	/* !_IF_BWIVAR_H */

int		bwi_intr(void *);
int		bwi_attach(struct bwi_softc *);
int		bwi_detach(void *);
int		bwi_init(struct ifnet *);
int		bwi_stop(struct bwi_softc *, int);
@


1.30
log
@Always allocate bwi(4) ring descriptors below the 1GB boundary to give 30bit
devices a chance to work. Use bounce buffers for mbufs on 30bit devices.

This fixes "intr fatal TX/RX" errors that render the internal wifi on many
macppc machines unusable. However, packet loss problems remain. In my testing
the device works fine sometimes, but experiences packet loss rates of up
to 80% at other times. Still, this is a step forward.

Helpful hints from claudio@@ and dlg@@
Tested on macppc by mpi@@ and myself
"go ahead" kettenis@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.29 2013/12/06 21:03:02 deraadt Exp $	*/
d728 1
a728 1
	return (_mac->mac_rf.rf_lo_update(_mac));
@


1.29
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.28 2013/11/26 20:33:15 deraadt Exp $	*/
d198 1
a198 1
	bus_dma_segment_t	 rdata_seg;
d559 4
d582 1
@


1.28
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.27 2013/11/14 12:10:05 dlg Exp $	*/
a622 1
	struct task		 sc_resume_t;
@


1.27
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.26 2010/08/06 05:26:24 mglocker Exp $	*/
d114 1
a114 1
#define BWI_DESC32_C_FRAME_START	(1 << 31)
@


1.26
log
@ACPI suspend/resume for bwi(4).  Initial diff from todd@@, finished and
tested by me on X40 with a BCM4306.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.25 2009/01/07 01:01:41 jsg Exp $	*/
d623 1
a623 1
	struct workq_task	 sc_resume_wqt;
@


1.25
log
@Don't attempt to use gcc __builtin_abs, abs is not used
anywhere speed critical and the libkern one is perfectly fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.24 2008/07/21 04:12:21 kevlo Exp $	*/
d623 1
d742 2
@


1.24
log
@cleanup - we don't have resource structure
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.23 2008/02/25 20:36:54 mglocker Exp $	*/
a626 2

#define abs(a)	__builtin_abs(a)
@


1.23
log
@Sync up with DragonFlyBSD driver.  Please read their commit message
for details:

http://leaf.dragonflybsd.org/mailarchive/commits/2008-02/msg00165.html

Tested and OK brad@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.22 2008/02/16 16:45:28 mglocker Exp $	*/
a527 6
	int			 sc_irq_rid;
	struct resource		*sc_irq_res;
	void			*sc_irq_handle;

	int			 sc_mem_rid;
	struct resource		*sc_mem_res;
@


1.22
log
@Report rssi and rate in rx radio tap.

From the DragonFlyBSD driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.21 2008/02/16 14:56:00 mglocker Exp $	*/
d66 6
d453 1
d553 1
@


1.21
log
@Better support for 11b mode.

From the DragonFlyBSD driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.20 2007/11/17 16:50:02 mglocker Exp $	*/
d66 2
d125 1
a125 1
	uint8_t		rxh_pad2[2];
d132 1
d137 4
d712 6
@


1.20
log
@- Add more LED support, like activity blinking (though just supporting
some devices yet).
- Calculate RX rate which can be used later in bpf_mtap().

Diff ported from DragonFlyBSD, tested by some.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.19 2007/10/18 05:56:15 mglocker Exp $	*/
d375 5
d705 6
@


1.19
log
@Add some first LEDs support.  Tested on my cardbus Linksys WPC54G Ver 3.

Diff ported from DragonFlyBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.18 2007/10/04 05:44:43 mglocker Exp $	*/
d60 6
d130 2
d270 1
d274 3
d532 9
d570 1
a570 1
	void			 (*sc_rxeof)(struct bwi_softc *);
d589 2
@


1.18
log
@Since we know the firmware load works, merge the single firmware files
together to one single, finally.

You need to bump the firmware package to version 1.3!

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.17 2007/10/01 11:27:11 mglocker Exp $	*/
d259 7
d432 1
d519 2
@


1.17
log
@Use uint_* consistent.

Agreed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.16 2007/09/27 22:17:32 mglocker Exp $	*/
d397 2
@


1.16
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.15 2007/09/27 22:10:25 mglocker Exp $	*/
d347 1
a347 1
	u_int			rf_curchan;	/* current channel */
@


1.15
log
@Add automatic rate control (AMRR).
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.14 2007/09/27 09:19:21 mglocker Exp $	*/
d638 1
a638 1
	/* TODO:LED */
@


1.14
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.13 2007/09/27 05:58:57 mglocker Exp $	*/
d463 5
d499 3
@


1.13
log
@Kill __BIT* macros.

Help and OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.12 2007/09/24 19:51:18 mglocker Exp $	*/
d60 1
a60 1
#define CSR_READ_4(sc, reg)		\
d62 1
a62 1
#define CSR_READ_2(sc, reg)		\
d65 1
a65 1
#define CSR_WRITE_4(sc, reg, val)	\
d67 1
a67 1
#define CSR_WRITE_2(sc, reg, val)	\
d70 1
a70 1
#define CSR_SETBITS_4(sc, reg, bits)	\
d72 1
a72 1
#define CSR_SETBITS_2(sc, reg, bits)	\
d80 1
a80 1
#define CSR_CLRBITS_4(sc, reg, bits)	\
d82 1
a82 1
#define CSR_CLRBITS_2(sc, reg, bits)	\
d172 1
a172 1
	uint8_t		txs_pad3[2];		/* Padded to 16bytes */
d176 4
a179 4
	uint32_t		rdata_txrx_ctrl;
	bus_dma_segment_t	rdata_seg;
	bus_dmamap_t		rdata_dmap;
	bus_addr_t		rdata_paddr;
d185 1
a185 1
	bus_dmamap_t		tb_dmap;
d188 1
a188 1
	int			tb_rate_idx[2];
d199 2
a200 2
	bus_addr_t		rb_paddr;
	bus_dmamap_t		rb_dmap;
d210 3
a212 3
	bus_dma_segment_t	stats_ring_seg;
	bus_dmamap_t		stats_ring_dmap;
	bus_addr_t		stats_ring_paddr;
d215 3
a217 3
	bus_dma_segment_t	stats_seg;
	bus_dmamap_t		stats_dmap;
	bus_addr_t		stats_paddr;
d220 2
a221 2
	uint32_t		stats_ctrl_base;
	int			stats_idx;
d283 3
a285 3
#define BWI_GPIO_REGWIN(sc) \
	(BWI_REGWIN_EXIST(&(sc)->sc_com_regwin) ? \
		&(sc)->sc_com_regwin : &(sc)->sc_bus_regwin)
d384 5
a388 6
	struct bwi_regwin	mac_regwin;	/* MUST be first field */
#define mac_rw_flags	mac_regwin.rw_flags
#define mac_type	mac_regwin.rw_type
#define mac_id		mac_regwin.rw_id
#define mac_rev		mac_regwin.rw_rev

d391 2
a392 2
	struct bwi_phy		mac_phy;	/* PHY I/F */
	struct bwi_rf		mac_rf;		/* RF I/F */
d394 2
a395 2
	struct bwi_tpctl	mac_tpctl;	/* TX power control */
	uint32_t		mac_flags;	/* BWI_MAC_F_ */
d418 1
a418 3
			  (id),			\
			  BWI_REGWIN_T_MAC,	\
			  (rev));		\
d546 2
a547 2
	int			sc_fw_version;	/* BWI_FW_VERSION[34] */
	int			sc_dwell_time;	/* milliseconds */
d550 1
a550 1
        caddr_t                 sc_drvbpf;
d555 3
a557 3
        }                       sc_rxtapu;
#define sc_rxtap                sc_rxtapu.th
        int                     sc_rxtap_len;
d562 3
a564 3
        }                       sc_txtapu;
#define sc_txtap                sc_txtapu.th
        int                     sc_txtap_len;
d573 1
a573 1
#define MOBJ_WRITE_2(mac, objid, ofs, val)	\
d575 1
a575 1
#define MOBJ_WRITE_4(mac, objid, ofs, val)	\
d577 1
a577 1
#define MOBJ_READ_2(mac, objid, ofs)		\
d579 1
a579 1
#define MOBJ_READ_4(mac, objid, ofs)		\
d582 10
a591 10
#define MOBJ_SETBITS_4(mac, objid, ofs, bits)	\
	MOBJ_WRITE_4((mac), (objid), (ofs),	\
		     MOBJ_READ_4((mac), (objid), (ofs)) | (bits))
#define MOBJ_CLRBITS_4(mac, objid, ofs, bits)	\
	MOBJ_WRITE_4((mac), (objid), (ofs),	\
		     MOBJ_READ_4((mac), (objid), (ofs)) & ~(bits))

#define MOBJ_FILT_SETBITS_2(mac, objid, ofs, filt, bits) \
	MOBJ_WRITE_2((mac), (objid), (ofs),	\
		     (MOBJ_READ_2((mac), (objid), (ofs)) & (filt)) | (bits))
d597 1
a597 1
#define HFLAGS_CLRBITS(mac, bits)	\
d599 1
a599 1
#define HFLAGS_SETBITS(mac, bits)	\
@


1.12
log
@Add radio tap support.  We still need to calculate correct RX rate and
RX signal strength.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.11 2007/09/18 17:35:38 mglocker Exp $	*/
d92 2
a93 2
#define BWI_DESC32_A_FUNC_MASK		__BITS(31, 30)
#define BWI_DESC32_A_ADDR_MASK		__BITS(29, 0)
d95 6
a100 6
#define BWI_DESC32_C_BUFLEN_MASK	__BITS(12, 0)
#define BWI_DESC32_C_ADDRHI_MASK	__BITS(17, 16)
#define BWI_DESC32_C_EOR		__BIT(28)
#define BWI_DESC32_C_INTR		__BIT(29)
#define BWI_DESC32_C_FRAME_END		__BIT(30)
#define BWI_DESC32_C_FRAME_START	__BIT(31)
d124 1
a124 1
#define BWI_RXH_F2_TYPE2FRAME	__BIT(2)
d151 2
a152 2
#define BWI_TXH_ID_RING_MASK		__BITS(15, 13)
#define BWI_TXH_ID_IDX_MASK		__BITS(12, 0)
d154 8
a161 8
#define BWI_TXH_PHY_C_OFDM		__BIT(0)
#define BWI_TXH_PHY_C_SHPREAMBLE	__BIT(4)
#define BWI_TXH_PHY_C_ANTMODE_MASK	__BITS(9, 8)

#define BWI_TXH_MAC_C_ACK		__BIT(0)
#define BWI_TXH_MAC_C_FIRST_FRAG	__BIT(3)
#define BWI_TXH_MAC_C_HWSEQ		__BIT(4)
#define BWI_TXH_MAC_C_FB_OFDM		__BIT(8)
d241 2
a242 2
#define BWI_FW_IV_OFS_MASK	__BITS(14, 0)
#define BWI_FW_IV_IS_32BIT	__BIT(15)
@


1.11
log
@Drag back the original DragonFlyBSD firmware loading routines, so we can
load the same firmware revision as they do.  Our previously used firmware
images seem to contain the wrong revision.  You need to bump your firmware
package to version 1.2.

Other than expected, loading the right firmware revision still doesn't fix
a fatal chip error at initialization time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.10 2007/09/16 19:02:37 mglocker Exp $	*/
d433 33
d551 18
@


1.10
log
@Remove obsolete firmware specific bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.9 2007/09/15 22:47:14 mglocker Exp $	*/
d224 10
d237 6
d252 5
a256 3
	uint16_t		offset;
	uint16_t		size;
	uint32_t		val;
d398 8
a405 4
	struct fw_image		*mac_ucode;
	struct fw_image		*mac_pcm;
	struct fw_image		*mac_iv;
	struct fw_image		*mac_iv_ext;
@


1.9
log
@Get IV load working.  Simplified IV loading routine (mainly a rewrite).
Adapted IV loading routines so we can use it with our one file firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.8 2007/09/15 13:38:22 jsg Exp $	*/
a84 6
struct fwheader {
	char	filename[64];
	int	filesize;
	int	fileoffset;
};

a223 17
struct bwi_fwhdr {
	/* Big endian */
	uint8_t		fw_type;	/* BWI_FW_T_ */
	uint8_t		fw_gen;		/* BWI_FW_GEN */
	uint8_t		fw_pad[2];
	uint32_t	fw_size;
#define fw_iv_cnt	fw_size
} __packed;

#define BWI_FWHDR_SZ		sizeof(struct bwi_fwhdr)

#define BWI_FW_T_UCODE		'u'
#define BWI_FW_T_PCM		'p'
#define BWI_FW_T_IV		'i'

#define BWI_FW_GEN_1		1

d228 5
a232 5
#define BWI_FW_PATH		"bwi/v%d/"
#define BWI_FW_UCODE_PATH	BWI_FW_PATH "ucode%d.fw"
#define BWI_FW_PCM_PATH		BWI_FW_PATH "pcm%d.fw"
#define BWI_FW_IV_PATH		BWI_FW_PATH "b0g0initvals%d.fw"
#define BWI_FW_IV_EXT_PATH	BWI_FW_PATH "b0g0bsinitvals%d.fw"
a239 3

#define BWI_FW_IV_OFS_MASK	__BITS(14, 0)
#define BWI_FW_IV_IS_32BIT	__BIT(15)
@


1.8
log
@most of the remaining bus_dma conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.7 2007/09/15 07:20:51 jsg Exp $	*/
d259 3
a261 5
	uint16_t		iv_ofs;
	union {
		uint32_t	val32;
		uint16_t	val16;
	} 			iv_val;
@


1.7
log
@Properly fill in some of the pci information the driver uses internally.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.6 2007/09/14 20:26:04 mglocker Exp $	*/
d183 1
d216 1
a216 1
	bus_dma_tag_t		stats_ring_dtag;
d221 1
a221 1
	bus_dma_tag_t		stats_dtag;
a478 1
	bus_dma_tag_t		 sc_parent_dtag;
a479 1
	bus_dma_tag_t		 sc_buf_dtag;
a482 1
	bus_dma_tag_t		 sc_txring_dtag;
a483 1
	bus_dma_tag_t		 sc_rxring_dtag;
@


1.6
log
@Get firmware load working.  Adapt firmware routines that way so we can
use our one file firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.5 2007/09/14 13:00:41 mglocker Exp $	*/
d449 1
@


1.5
log
@Sort prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.4 2007/09/13 14:48:29 mglocker Exp $	*/
d84 6
@


1.4
log
@Fix sc_dev tweak.  Device attaches with correct name now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.3 2007/09/13 08:28:37 mglocker Exp $	*/
a524 11
uint16_t	bwi_read_sprom(struct bwi_softc *, uint16_t);
int		bwi_regwin_switch(struct bwi_softc *, struct bwi_regwin *,
		    struct bwi_regwin **);
int		bwi_regwin_is_enabled(struct bwi_softc *, struct bwi_regwin *);
void		bwi_regwin_enable(struct bwi_softc *, struct bwi_regwin *,
		    uint32_t);
void		bwi_regwin_disable(struct bwi_softc *, struct bwi_regwin *,
		    uint32_t);
int		bwi_bus_init(struct bwi_softc *, struct bwi_mac *);
uint8_t		bwi_rate2plcp(uint8_t);	/* XXX belongs to 802.11 */

a526 33
int		bwi_intr(void *);
int		bwi_attach(struct bwi_softc *);
int		bwi_detach(void *);

/* MAC */

int		bwi_mac_attach(struct bwi_softc *, int, uint8_t);
int		bwi_mac_lateattach(struct bwi_mac *);
void		bwi_mac_detach(struct bwi_mac *);
int		bwi_mac_init(struct bwi_mac *);
void		bwi_mac_reset(struct bwi_mac *, int);
int		bwi_mac_start(struct bwi_mac *);
int		bwi_mac_stop(struct bwi_mac *);
void		bwi_mac_shutdown(struct bwi_mac *);
void		bwi_mac_updateslot(struct bwi_mac *, int);
void		bwi_mac_set_promisc(struct bwi_mac *, int);
void		bwi_mac_calibrate_txpower(struct bwi_mac *);
void		bwi_mac_set_tpctl_11bg(struct bwi_mac *,
		    const struct bwi_tpctl *);
void		bwi_mac_init_tpctl_11bg(struct bwi_mac *);
void		bwi_mac_dummy_xmit(struct bwi_mac *);
void		bwi_mac_reset_hwkeys(struct bwi_mac *);
int		bwi_mac_config_ps(struct bwi_mac *);
uint16_t	bwi_memobj_read_2(struct bwi_mac *, uint16_t, uint16_t);
uint32_t	bwi_memobj_read_4(struct bwi_mac *, uint16_t, uint16_t);
void		bwi_memobj_write_2(struct bwi_mac *, uint16_t, uint16_t,
		    uint16_t);
void		bwi_memobj_write_4(struct bwi_mac *, uint16_t, uint16_t,
		    uint32_t);
void		bwi_tmplt_write_4(struct bwi_mac *, uint32_t, uint32_t);
void		bwi_hostflags_write(struct bwi_mac *, uint64_t);
uint64_t	bwi_hostflags_read(struct bwi_mac *);

a563 10
int		bwi_phy_attach(struct bwi_mac *);
void		bwi_phy_clear_state(struct bwi_phy *);
int		bwi_phy_calibrate(struct bwi_mac *);
void		bwi_phy_set_bbp_atten(struct bwi_mac *, uint16_t);
void		bwi_set_gains(struct bwi_mac *, const struct bwi_gains *);
int16_t		bwi_nrssi_read(struct bwi_mac *, uint16_t);
void		bwi_nrssi_write(struct bwi_mac *, uint16_t, int16_t);
uint16_t	bwi_phy_read(struct bwi_mac *, uint16_t);
void		bwi_phy_write(struct bwi_mac *, uint16_t, uint16_t);

a579 17
int		bwi_rf_attach(struct bwi_mac *);
void		bwi_rf_clear_state(struct bwi_rf *);
int		bwi_rf_map_txpower(struct bwi_mac *);
void		bwi_rf_lo_adjust(struct bwi_mac *, const struct bwi_tpctl *);
void		bwi_rf_set_chan(struct bwi_mac *, u_int, int);
void		bwi_rf_get_gains(struct bwi_mac *);
void		bwi_rf_init(struct bwi_mac *);
void		bwi_rf_init_bcm2050(struct bwi_mac *);
void		bwi_rf_lo_update(struct bwi_mac *);
void		bwi_rf_init_hw_nrssi_table(struct bwi_mac *, uint16_t);
void		bwi_rf_set_ant_mode(struct bwi_mac *, int);
void		bwi_rf_clear_tssi(struct bwi_mac *);
int		bwi_rf_get_latest_tssi(struct bwi_mac *, int8_t[], uint16_t);
int		bwi_rf_tssi2dbm(struct bwi_mac *, int8_t, int8_t *);
void		bwi_rf_write(struct bwi_mac *, uint16_t, uint16_t);
uint16_t	bwi_rf_read(struct bwi_mac *, uint16_t);

d624 4
@


1.3
log
@Enable access to PCI and Cardbus config space from the driver.  Lets us
power on the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.2 2007/09/12 22:22:05 mglocker Exp $	*/
a383 1
struct bwi_softc;
d433 1
a435 1
	struct device		 sc_dev;
@


1.2
log
@Spacing run.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwivar.h,v 1.1 2007/09/12 13:13:12 jsg Exp $	*/
d514 3
@


1.1
log
@Initial port of Sepherosa Ziehau's DragonFlyBSD driver
for Broadcom AirForce wireless devices.

Not yet functional, things like DMA and firmware handling
haven't been converted yet.

ok mglocker@@
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d434 16
a449 16
	struct ieee80211com	sc_ic;
	uint32_t		sc_flags;	/* BWI_F_ */
	struct device		sc_dev;

	uint32_t		sc_cap;		/* BWI_CAP_ */
	uint16_t		sc_bbp_id;	/* BWI_BBPID_ */
	uint8_t			sc_bbp_rev;
	uint8_t			sc_bbp_pkg;

	uint8_t			sc_pci_revid;
	uint16_t		sc_pci_subvid;
	uint16_t		sc_pci_subdid;

	uint16_t		sc_card_flags;	/* BWI_CARD_F_ */
	uint16_t		sc_pwron_delay;
	int			sc_locale;
d451 1
a451 1
	int			sc_irq_rid;
d455 1
a455 1
	int			sc_mem_rid;
d457 3
a459 3
	bus_dma_tag_t		sc_dmat;
	bus_space_tag_t		sc_mem_bt;
	bus_space_handle_t	sc_mem_bh;
d461 2
a462 2
	struct timeout		sc_scan_ch;
	struct timeout		sc_calib_ch;
d465 2
a466 8
	struct bwi_regwin	sc_com_regwin;
	struct bwi_regwin	sc_bus_regwin;

	int			sc_nmac;
	struct bwi_mac		sc_mac[BWI_MAC_MAX];

	enum bwi_bus_space	sc_bus_space;
	bus_dma_tag_t		sc_parent_dtag;
d468 14
a481 8
	bus_dma_tag_t		sc_buf_dtag;
	struct bwi_txbuf_data	sc_tx_bdata[BWI_TX_NRING];
	struct bwi_rxbuf_data	sc_rx_bdata;

	bus_dma_tag_t		sc_txring_dtag;
	struct bwi_ring_data	sc_tx_rdata[BWI_TX_NRING];
	bus_dma_tag_t		sc_rxring_dtag;
	struct bwi_ring_data	sc_rx_rdata;
d485 1
a485 1
	int			sc_tx_timer;
d487 3
a489 3
	int			(*sc_newstate)
				(struct ieee80211com *,
				 enum ieee80211_state, int);
d491 2
a492 2
	int			(*sc_init_tx_ring)(struct bwi_softc *, int);
	void			(*sc_free_tx_ring)(struct bwi_softc *, int);
d494 2
a495 2
	int			(*sc_init_rx_ring)(struct bwi_softc *);
	void			(*sc_free_rx_ring)(struct bwi_softc *);
d497 2
a498 2
	int			(*sc_init_txstats)(struct bwi_softc *);
	void			(*sc_free_txstats)(struct bwi_softc *);
d500 3
a502 3
	void			(*sc_setup_rxdesc)
				(struct bwi_softc *, int, bus_addr_t, int);
	void			(*sc_rxeof)(struct bwi_softc *);
d504 5
a508 5
	void			(*sc_setup_txdesc)
				(struct bwi_softc *, struct bwi_ring_data *,
				 int, bus_addr_t, int);
	void			(*sc_start_tx)
				(struct bwi_softc *, uint32_t, int);
d510 1
a510 4
	void			(*sc_txeof_status)(struct bwi_softc *);

	int			(*sc_enable)(struct bwi_softc *); 
	void			(*sc_disable)(struct bwi_softc *);
d512 2
d525 1
a525 1
				  struct bwi_regwin **);
d528 1
a528 1
				  uint32_t);
d530 1
a530 1
				   uint32_t);
a551 1

d554 1
a554 1
				       const struct bwi_tpctl *);
a558 1

d562 1
a562 1
				   uint16_t);
d564 1
a564 1
				   uint32_t);
a607 1

a609 1

a612 1

a633 1

a642 1

a645 1

@

