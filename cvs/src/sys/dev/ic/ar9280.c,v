head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.6
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.6
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.4
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.8
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.26
date	2017.01.12.16.32.28;	author stsp;	state Exp;
branches;
next	1.25;
commitid	1Zd7y0b8dZf1uELZ;

1.25
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.24;
commitid	2QagMjdMhQhIaQgu;

1.24
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.23;
commitid	5gdEnqVoJuTuwdTu;

1.23
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.22;
commitid	FuSD2mFDJWATHIDx;

1.22
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.21;
commitid	5DvsamK0GblTp8ww;

1.21
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.20;
commitid	LS2TNeCue5R9L67C;

1.20
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.19;
commitid	TGHgrLxu6sxZoiFt;

1.19
date	2013.08.07.01.06.28;	author bluhm;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.10.21.23.36;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2011.01.06.07.27.15;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2011.01.01.14.25.03;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.31.17.50.48;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.31.14.06.05;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.03.15.40.08;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.12.16.32.31;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.12.16.04.51;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.15.20.37.38;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.15.19.29.00;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.15.19.07.43;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.16.14.34.19;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.11.18.04.12;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.10.17.44.21;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.17.19.32.22;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.15.14.04.02;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.14.16.55.11;	author damien;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Finish initial 11n support for athn(4).

The heavy lifting was done by damien@@ years ago. I didn't even have
to figure out what the hardware expects, the code was already there.

This driver now supports MCS 0-15 in client and hostap mode.
No Tx aggregation and no 40 MHz channels yet.

tested by vgross@@, bmercer@@, tb@@, jmc@@, Vadim Vygonets, Peter Kay
ok bmercer@@ tb@@ phessler@@
@
text
@/*	$OpenBSD: ar9280.c,v 1.25 2016/01/05 18:41:15 stsp Exp $	*/

/*-
 * Copyright (c) 2009 Damien Bergamini <damien.bergamini@@free.fr>
 * Copyright (c) 2008-2009 Atheros Communications Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Atheros 802.11a/g/n chipsets.
 * Routines for AR9220, AR9223, AR9280 and AR9281 chipsets.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_mira.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/athnreg.h>
#include <dev/ic/athnvar.h>

#include <dev/ic/ar5008reg.h>
#include <dev/ic/ar5416reg.h>	/* We share the ROM layout. */
#include <dev/ic/ar9280reg.h>

int	ar9280_attach(struct athn_softc *);
void	ar9280_setup(struct athn_softc *);
int	ar9280_set_synth(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9280_init_from_rom(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9280_spur_mitigate(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9280_olpc_get_pdadcs(struct athn_softc *,
	    struct ieee80211_channel *, int, uint8_t *, uint8_t *, uint8_t *);
void	ar9280_reset_rx_gain(struct athn_softc *, struct ieee80211_channel *);
void	ar9280_reset_tx_gain(struct athn_softc *, struct ieee80211_channel *);
void	ar9280_olpc_init(struct athn_softc *);
void	ar9280_olpc_temp_compensation(struct athn_softc *);

/* Extern functions. */
uint8_t	athn_chan2fbin(struct ieee80211_channel *);
void	athn_get_pier_ival(uint8_t, const uint8_t *, int, int *, int *);
int	ar5008_attach(struct athn_softc *);
void	ar5008_set_viterbi_mask(struct athn_softc *, int);
void	ar5416_swap_rom(struct athn_softc *);
void	ar5416_set_txpower(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
const struct ar_spur_chan *
	ar5416_get_spur_chans(struct athn_softc *, int);


int
ar9280_attach(struct athn_softc *sc)
{
	sc->eep_base = AR5416_EEP_START_LOC;
	sc->eep_size = sizeof(struct ar5416_eeprom);
	sc->def_nf = AR9280_PHY_CCA_MAX_GOOD_VALUE;
	sc->ngpiopins = (sc->flags & ATHN_FLAG_USB) ? 16 : 10;
	sc->led_pin = 1;
	sc->workaround = AR9280_WA_DEFAULT;
	sc->ops.setup = ar9280_setup;
	sc->ops.swap_rom = ar5416_swap_rom;
	sc->ops.init_from_rom = ar9280_init_from_rom;
	sc->ops.set_txpower = ar5416_set_txpower;
	sc->ops.set_synth = ar9280_set_synth;
	sc->ops.spur_mitigate = ar9280_spur_mitigate;
	sc->ops.get_spur_chans = ar5416_get_spur_chans;
	sc->ops.olpc_init = ar9280_olpc_init;
	sc->ops.olpc_temp_compensation = ar9280_olpc_temp_compensation;
	sc->ini = &ar9280_2_0_ini;
	sc->serdes = &ar9280_2_0_serdes;

	return (ar5008_attach(sc));
}

void
ar9280_setup(struct athn_softc *sc)
{
	const struct ar5416_eeprom *eep = sc->eep;
	uint8_t type;

	/* Determine if open loop power control should be used. */
	if (sc->eep_rev >= AR_EEP_MINOR_VER_19 &&
	    eep->baseEepHeader.openLoopPwrCntl)
		sc->flags |= ATHN_FLAG_OLPC;

	/* Determine if fast PLL clock is supported. */
	if (AR_SREV_9280_20(sc) &&
	    (sc->eep_rev <= AR_EEP_MINOR_VER_16 ||
	     eep->baseEepHeader.fastClk5g))
		sc->flags |= ATHN_FLAG_FAST_PLL_CLOCK;

	/*
	 * Determine if initialization value for AR_AN_TOP2 must be fixed.
	 * This is required for some AR9220 devices such as Ubiquiti SR71-12.
	 */
	if (AR_SREV_9280_20(sc) &&
	    sc->eep_rev > AR_EEP_MINOR_VER_10 &&
	    !eep->baseEepHeader.pwdclkind) {
		DPRINTF(("AR_AN_TOP2 fixup required\n"));
		sc->flags |= ATHN_FLAG_AN_TOP2_FIXUP;
	}

	if (AR_SREV_9280_20(sc)) {
		/* Check if we have a valid rxGainType field in ROM. */
		if (sc->eep_rev >= AR_EEP_MINOR_VER_17) {
			/* Select initialization values based on ROM. */
			type = eep->baseEepHeader.rxGainType;
			DPRINTF(("Rx gain type=0x%x\n", type));
			if (type == AR5416_EEP_RXGAIN_23DB_BACKOFF)
				sc->rx_gain = &ar9280_2_0_rx_gain_23db_backoff;
			else if (type == AR5416_EEP_RXGAIN_13DB_BACKOFF)
				sc->rx_gain = &ar9280_2_0_rx_gain_13db_backoff;
			else
				sc->rx_gain = &ar9280_2_0_rx_gain;
		} else
			sc->rx_gain = &ar9280_2_0_rx_gain;

		/* Check if we have a valid txGainType field in ROM. */
		if (sc->eep_rev >= AR_EEP_MINOR_VER_19) {
			/* Select initialization values based on ROM. */
			type = eep->baseEepHeader.txGainType;
			DPRINTF(("Tx gain type=0x%x\n", type));
			if (type == AR_EEP_TXGAIN_HIGH_POWER)
				sc->tx_gain = &ar9280_2_0_tx_gain_high_power;
			else
				sc->tx_gain = &ar9280_2_0_tx_gain;
		} else
			sc->tx_gain = &ar9280_2_0_tx_gain;
	}
}

int
ar9280_set_synth(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	uint32_t phy, reg, ndiv = 0;
	uint32_t freq = c->ic_freq;

	phy = AR_READ(sc, AR9280_PHY_SYNTH_CONTROL) & ~0x3fffffff;

	if (IEEE80211_IS_CHAN_2GHZ(c)) {
		phy |= (freq << 16) / 15;
		phy |= AR9280_BMODE | AR9280_FRACMODE;

		if (AR_SREV_9287_11_OR_LATER(sc)) {
			/* NB: Magic values from the Linux driver. */
			if (freq == 2484) {	/* Channel 14. */
				/* Japanese regulatory requirements. */
				AR_WRITE(sc, AR_PHY(637), 0x00000000);
				AR_WRITE(sc, AR_PHY(638), 0xefff0301);
				AR_WRITE(sc, AR_PHY(639), 0xca9228ee);
			} else {
				AR_WRITE(sc, AR_PHY(637), 0x00fffeff);
				AR_WRITE(sc, AR_PHY(638), 0x00f5f9ff);
				AR_WRITE(sc, AR_PHY(639), 0xb79f6427);
			}
		} else {
			reg = AR_READ(sc, AR_PHY_CCK_TX_CTRL);
			if (freq == 2484)	/* Channel 14. */
				reg |= AR_PHY_CCK_TX_CTRL_JAPAN;
			else
				reg &= ~AR_PHY_CCK_TX_CTRL_JAPAN;
			AR_WRITE(sc, AR_PHY_CCK_TX_CTRL, reg);
		}
	} else {
		if (AR_SREV_9285_10_OR_LATER(sc) ||
		    sc->eep_rev < AR_EEP_MINOR_VER_22 ||
		    !((struct ar5416_base_eep_header *)sc->eep)->frac_n_5g) {
			if ((freq % 20) == 0) {
				ndiv = (freq * 3) / 60;
				phy |= SM(AR9280_AMODE_REFSEL, 3);
			} else if ((freq % 10) == 0) {
				ndiv = (freq * 6) / 60;
				phy |= SM(AR9280_AMODE_REFSEL, 2);
			}
		}
		if (ndiv != 0) {
			phy |= (ndiv & 0x1ff) << 17;
			phy |= (ndiv & ~0x1ff) * 2;
		} else {
			phy |= (freq << 15) / 15;
			phy |= AR9280_FRACMODE;

			reg = AR_READ(sc, AR_AN_SYNTH9);
			reg = RW(reg, AR_AN_SYNTH9_REFDIVA, 1);
			AR_WRITE(sc, AR_AN_SYNTH9, reg);
		}
	}
	AR_WRITE_BARRIER(sc);
	DPRINTFN(4, ("AR9280_PHY_SYNTH_CONTROL=0x%08x\n", phy));
	AR_WRITE(sc, AR9280_PHY_SYNTH_CONTROL, phy);
	AR_WRITE_BARRIER(sc);
	return (0);
}

void
ar9280_init_from_rom(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	static const uint32_t chainoffset[] = { 0x0000, 0x2000, 0x1000 };
	const struct ar5416_eeprom *eep = sc->eep;
	const struct ar5416_modal_eep_header *modal;
	uint32_t reg, offset;
	uint8_t txRxAtten;
	int i;

	modal = &eep->modalHeader[IEEE80211_IS_CHAN_2GHZ(c)];

	AR_WRITE(sc, AR_PHY_SWITCH_COM, modal->antCtrlCommon);

	for (i = 0; i < AR9280_MAX_CHAINS; i++) {
		if (sc->rxchainmask == 0x5 || sc->txchainmask == 0x5)
			offset = chainoffset[i];
		else
			offset = i * 0x1000;

		AR_WRITE(sc, AR_PHY_SWITCH_CHAIN_0 + offset,
		    modal->antCtrlChain[i]);

		reg = AR_READ(sc, AR_PHY_TIMING_CTRL4_0 + offset);
		reg = RW(reg, AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF,
		    modal->iqCalICh[i]);
		reg = RW(reg, AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF,
		    modal->iqCalQCh[i]);
		AR_WRITE(sc, AR_PHY_TIMING_CTRL4_0 + offset, reg);

		if (sc->eep_rev >= AR_EEP_MINOR_VER_3) {
			reg = AR_READ(sc, AR_PHY_GAIN_2GHZ + offset);
			reg = RW(reg, AR_PHY_GAIN_2GHZ_XATTEN1_MARGIN,
			    modal->bswMargin[i]);
			reg = RW(reg, AR_PHY_GAIN_2GHZ_XATTEN1_DB,
			    modal->bswAtten[i]);
			reg = RW(reg, AR_PHY_GAIN_2GHZ_XATTEN2_MARGIN,
			    modal->xatten2Margin[i]);
			reg = RW(reg, AR_PHY_GAIN_2GHZ_XATTEN2_DB,
			    modal->xatten2Db[i]);
			AR_WRITE(sc, AR_PHY_GAIN_2GHZ + offset, reg);
		}
		if (sc->eep_rev >= AR_EEP_MINOR_VER_3)
			txRxAtten = modal->txRxAttenCh[i];
		else	/* Workaround for ROM versions < 14.3. */
			txRxAtten = IEEE80211_IS_CHAN_2GHZ(c) ? 23 : 44;
		reg = AR_READ(sc, AR_PHY_RXGAIN + offset);
		reg = RW(reg, AR9280_PHY_RXGAIN_TXRX_ATTEN,
		    txRxAtten);
		reg = RW(reg, AR9280_PHY_RXGAIN_TXRX_MARGIN,
		    modal->rxTxMarginCh[i]);
		AR_WRITE(sc, AR_PHY_RXGAIN + offset, reg);
	}
	if (IEEE80211_IS_CHAN_2GHZ(c)) {
		reg = AR_READ(sc, AR_AN_RF2G1_CH0);
		reg = RW(reg, AR_AN_RF2G1_CH0_OB, modal->ob);
		reg = RW(reg, AR_AN_RF2G1_CH0_DB, modal->db);
		AR_WRITE(sc, AR_AN_RF2G1_CH0, reg);
		AR_WRITE_BARRIER(sc);
		DELAY(100);

		reg = AR_READ(sc, AR_AN_RF2G1_CH1);
		reg = RW(reg, AR_AN_RF2G1_CH1_OB, modal->ob_ch1);
		reg = RW(reg, AR_AN_RF2G1_CH1_DB, modal->db_ch1);
		AR_WRITE(sc, AR_AN_RF2G1_CH1, reg);
		AR_WRITE_BARRIER(sc);
		DELAY(100);
	} else {
		reg = AR_READ(sc, AR_AN_RF5G1_CH0);
		reg = RW(reg, AR_AN_RF5G1_CH0_OB5, modal->ob);
		reg = RW(reg, AR_AN_RF5G1_CH0_DB5, modal->db);
		AR_WRITE(sc, AR_AN_RF5G1_CH0, reg);
		AR_WRITE_BARRIER(sc);
		DELAY(100);

		reg = AR_READ(sc, AR_AN_RF5G1_CH1);
		reg = RW(reg, AR_AN_RF5G1_CH1_OB5, modal->ob_ch1);
		reg = RW(reg, AR_AN_RF5G1_CH1_DB5, modal->db_ch1);
		AR_WRITE(sc, AR_AN_RF5G1_CH1, reg);
		AR_WRITE_BARRIER(sc);
		DELAY(100);
	}
	reg = AR_READ(sc, AR_AN_TOP2);
	if ((sc->flags & ATHN_FLAG_USB) && IEEE80211_IS_CHAN_5GHZ(c)) {
		/*
		 * Hardcode the output voltage of x-PA bias LDO to the
		 * lowest value for UB94 such that the card doesn't get
		 * too hot.
		 */
		reg = RW(reg, AR_AN_TOP2_XPABIAS_LVL, 0);
	} else
		reg = RW(reg, AR_AN_TOP2_XPABIAS_LVL, modal->xpaBiasLvl);
	if (modal->flagBits & AR5416_EEP_FLAG_LOCALBIAS)
		reg |= AR_AN_TOP2_LOCALBIAS;
	else
		reg &= ~AR_AN_TOP2_LOCALBIAS;
	AR_WRITE(sc, AR_AN_TOP2, reg);
	AR_WRITE_BARRIER(sc);
	DELAY(100);

	reg = AR_READ(sc, AR_PHY_XPA_CFG);
	if (modal->flagBits & AR5416_EEP_FLAG_FORCEXPAON)
		reg |= AR_PHY_FORCE_XPA_CFG;
	else
		reg &= ~AR_PHY_FORCE_XPA_CFG;
	AR_WRITE(sc, AR_PHY_XPA_CFG, reg);

	reg = AR_READ(sc, AR_PHY_SETTLING);
	reg = RW(reg, AR_PHY_SETTLING_SWITCH, modal->switchSettling);
	AR_WRITE(sc, AR_PHY_SETTLING, reg);

	reg = AR_READ(sc, AR_PHY_DESIRED_SZ);
	reg = RW(reg, AR_PHY_DESIRED_SZ_ADC, modal->adcDesiredSize);
	AR_WRITE(sc, AR_PHY_DESIRED_SZ, reg);

	reg =  SM(AR_PHY_RF_CTL4_TX_END_XPAA_OFF, modal->txEndToXpaOff);
	reg |= SM(AR_PHY_RF_CTL4_TX_END_XPAB_OFF, modal->txEndToXpaOff);
	reg |= SM(AR_PHY_RF_CTL4_FRAME_XPAA_ON, modal->txFrameToXpaOn);
	reg |= SM(AR_PHY_RF_CTL4_FRAME_XPAB_ON, modal->txFrameToXpaOn);
	AR_WRITE(sc, AR_PHY_RF_CTL4, reg);

	reg = AR_READ(sc, AR_PHY_RF_CTL3);
	reg = RW(reg, AR_PHY_TX_END_TO_A2_RX_ON, modal->txEndToRxOn);
	AR_WRITE(sc, AR_PHY_RF_CTL3, reg);

	reg = AR_READ(sc, AR_PHY_CCA(0));
	reg = RW(reg, AR9280_PHY_CCA_THRESH62, modal->thresh62);
	AR_WRITE(sc, AR_PHY_CCA(0), reg);

	reg = AR_READ(sc, AR_PHY_EXT_CCA0);
	reg = RW(reg, AR_PHY_EXT_CCA0_THRESH62, modal->thresh62);
	AR_WRITE(sc, AR_PHY_EXT_CCA0, reg);

	if (sc->eep_rev >= AR_EEP_MINOR_VER_2) {
		reg = AR_READ(sc, AR_PHY_RF_CTL2);
		reg = RW(reg, AR_PHY_TX_END_DATA_START,
		    modal->txFrameToDataStart);
		reg = RW(reg, AR_PHY_TX_END_PA_ON, modal->txFrameToPaOn);
		AR_WRITE(sc, AR_PHY_RF_CTL2, reg);
	}
	if (sc->eep_rev >= AR_EEP_MINOR_VER_3 && extc != NULL) {
		/* Overwrite switch settling with HT-40 value. */
		reg = AR_READ(sc, AR_PHY_SETTLING);
		reg = RW(reg, AR_PHY_SETTLING_SWITCH, modal->swSettleHt40);
		AR_WRITE(sc, AR_PHY_SETTLING, reg);
	}
	if (sc->eep_rev >= AR_EEP_MINOR_VER_19) {
		reg = AR_READ(sc, AR_PHY_CCK_TX_CTRL);
		reg = RW(reg, AR_PHY_CCK_TX_CTRL_TX_DAC_SCALE_CCK,
		    MS(modal->miscBits, AR5416_EEP_MISC_TX_DAC_SCALE_CCK));
		AR_WRITE(sc, AR_PHY_CCK_TX_CTRL, reg);
	}
	if (AR_SREV_9280_20(sc) &&
	    sc->eep_rev >= AR_EEP_MINOR_VER_20) {
		reg = AR_READ(sc, AR_AN_TOP1);
		if (eep->baseEepHeader.dacLpMode &&
		    (IEEE80211_IS_CHAN_2GHZ(c) ||
		     !eep->baseEepHeader.dacHiPwrMode_5G))
			reg |= AR_AN_TOP1_DACLPMODE;
		else
			reg &= ~AR_AN_TOP1_DACLPMODE;
		AR_WRITE(sc, AR_AN_TOP1, reg);
		AR_WRITE_BARRIER(sc);
		DELAY(100);

		reg = AR_READ(sc, AR_PHY_FRAME_CTL);
		reg = RW(reg, AR_PHY_FRAME_CTL_TX_CLIP,
		    MS(modal->miscBits, AR5416_EEP_MISC_TX_CLIP));
		AR_WRITE(sc, AR_PHY_FRAME_CTL, reg);

		reg = AR_READ(sc, AR_PHY_TX_PWRCTRL9);
		reg = RW(reg, AR_PHY_TX_DESIRED_SCALE_CCK,
		    eep->baseEepHeader.desiredScaleCCK);
		AR_WRITE(sc, AR_PHY_TX_PWRCTRL9, reg);
	}
	AR_WRITE_BARRIER(sc);
}

void
ar9280_olpc_get_pdadcs(struct athn_softc *sc, struct ieee80211_channel *c,
    int chain, uint8_t *boundaries, uint8_t *pdadcs, uint8_t *txgain)
{
	const struct ar5416_eeprom *eep = sc->eep;
	const struct ar_cal_data_per_freq_olpc *pierdata;
	const uint8_t *pierfreq;
	uint8_t fbin, pcdac, pwr, idx;
	int i, lo, hi, npiers;

	if (IEEE80211_IS_CHAN_2GHZ(c)) {
		pierfreq = eep->calFreqPier2G;
		pierdata = (const struct ar_cal_data_per_freq_olpc *)
		    eep->calPierData2G[chain];
		npiers = AR5416_NUM_2G_CAL_PIERS;
	} else {
		pierfreq = eep->calFreqPier5G;
		pierdata = (const struct ar_cal_data_per_freq_olpc *)
		    eep->calPierData5G[chain];
		npiers = AR5416_NUM_5G_CAL_PIERS;
	}
	/* Find channel in ROM pier table. */
	fbin = athn_chan2fbin(c);
	athn_get_pier_ival(fbin, pierfreq, npiers, &lo, &hi);

	/* Get average. */
	pwr = (pierdata[lo].pwrPdg[0][0] + pierdata[hi].pwrPdg[0][0]) / 2;
	pwr /= 2;	/* Convert to dB. */

	/* Find power control digital-to-analog converter (PCDAC) value. */
	pcdac = pierdata[hi].pcdac[0][0];
	for (idx = 0; idx < AR9280_TX_GAIN_TABLE_SIZE - 1; idx++)
		if (pcdac <= sc->tx_gain_tbl[idx])
			break;
	*txgain = idx;

	DPRINTFN(3, ("fbin=%d lo=%d hi=%d pwr=%d pcdac=%d txgain=%d\n",
	    fbin, lo, hi, pwr, pcdac, idx));

	/* Fill phase domain analog-to-digital converter (PDADC) table. */
	for (i = 0; i < AR_NUM_PDADC_VALUES; i++)
		pdadcs[i] = (i < pwr) ? 0x00 : 0xff;

	for (i = 0; i < AR_PD_GAINS_IN_MASK; i++)
		boundaries[i] = AR9280_PD_GAIN_BOUNDARY_DEFAULT;
}

void
ar9280_spur_mitigate(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	const struct ar_spur_chan *spurchans;
	int spur, bin, spur_delta_phase, spur_freq_sd, spur_subchannel_sd;
	int spur_off, range, i;

	/* NB: Always clear. */
	AR_CLRBITS(sc, AR_PHY_FORCE_CLKEN_CCK, AR_PHY_FORCE_CLKEN_CCK_MRC_MUX);

	range = (extc != NULL) ? 19 : 10;

	spurchans = sc->ops.get_spur_chans(sc, IEEE80211_IS_CHAN_2GHZ(c));
	for (i = 0; i < AR_EEPROM_MODAL_SPURS; i++) {
		spur = spurchans[i].spurChan;
		if (spur == AR_NO_SPUR)
			return;	/* XXX disable if it was enabled! */
		spur /= 10;
		if (IEEE80211_IS_CHAN_2GHZ(c))
			spur += AR_BASE_FREQ_2GHZ;
		else
			spur += AR_BASE_FREQ_5GHZ;
		spur -= c->ic_freq;
		if (abs(spur) < range)
			break;
	}
	if (i == AR_EEPROM_MODAL_SPURS)
		return;	/* XXX disable if it was enabled! */
	DPRINTFN(2, ("enabling spur mitigation\n"));

	AR_SETBITS(sc, AR_PHY_TIMING_CTRL4_0,
	    AR_PHY_TIMING_CTRL4_ENABLE_SPUR_RSSI |
	    AR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER |
	    AR_PHY_TIMING_CTRL4_ENABLE_CHAN_MASK |
	    AR_PHY_TIMING_CTRL4_ENABLE_PILOT_MASK);

	AR_WRITE(sc, AR_PHY_SPUR_REG,
	    AR_PHY_SPUR_REG_MASK_RATE_CNTL |
	    AR_PHY_SPUR_REG_ENABLE_MASK_PPM |
	    AR_PHY_SPUR_REG_MASK_RATE_SELECT |
	    AR_PHY_SPUR_REG_ENABLE_VIT_SPUR_RSSI |
	    SM(AR_PHY_SPUR_REG_SPUR_RSSI_THRESH, AR_SPUR_RSSI_THRESH));

	if (extc != NULL) {
		spur_delta_phase = (spur * 262144) / 10;
		if (spur < 0) {
			spur_subchannel_sd = 1;
			spur_off = spur + 10;
		} else {
			spur_subchannel_sd = 0;
			spur_off = spur - 10;
		}
	} else {
		spur_delta_phase = (spur * 524288) / 10;
		spur_subchannel_sd = 0;
		spur_off = spur;
	}
	if (IEEE80211_IS_CHAN_2GHZ(c))
		spur_freq_sd = (spur_off * 2048) / 44;
	else
		spur_freq_sd = (spur_off * 2048) / 40;

	AR_WRITE(sc, AR_PHY_TIMING11,
	    AR_PHY_TIMING11_USE_SPUR_IN_AGC |
	    SM(AR_PHY_TIMING11_SPUR_FREQ_SD, spur_freq_sd) |
	    SM(AR_PHY_TIMING11_SPUR_DELTA_PHASE, spur_delta_phase));

	AR_WRITE(sc, AR_PHY_SFCORR_EXT,
	    SM(AR_PHY_SFCORR_SPUR_SUBCHNL_SD, spur_subchannel_sd));
	AR_WRITE_BARRIER(sc);

	bin = spur * 320;
	ar5008_set_viterbi_mask(sc, bin);
}

void
ar9280_reset_rx_gain(struct athn_softc *sc, struct ieee80211_channel *c)
{
	const struct athn_gain *prog = sc->rx_gain;
	const uint32_t *pvals;
	int i;

	if (IEEE80211_IS_CHAN_2GHZ(c))
		pvals = prog->vals_2g;
	else
		pvals = prog->vals_5g;
	for (i = 0; i < prog->nregs; i++)
		AR_WRITE(sc, prog->regs[i], pvals[i]);
}

void
ar9280_reset_tx_gain(struct athn_softc *sc, struct ieee80211_channel *c)
{
	const struct athn_gain *prog = sc->tx_gain;
	const uint32_t *pvals;
	int i;

	if (IEEE80211_IS_CHAN_2GHZ(c))
		pvals = prog->vals_2g;
	else
		pvals = prog->vals_5g;
	for (i = 0; i < prog->nregs; i++)
		AR_WRITE(sc, prog->regs[i], pvals[i]);
}

void
ar9280_olpc_init(struct athn_softc *sc)
{
	uint32_t reg;
	int i;

	/* Save original Tx gain values. */
	for (i = 0; i < AR9280_TX_GAIN_TABLE_SIZE; i++) {
		reg = AR_READ(sc, AR_PHY_TX_GAIN_TBL(i));
		sc->tx_gain_tbl[i] = MS(reg, AR_PHY_TX_GAIN);
	}
	/* Initial Tx gain temperature compensation. */
	sc->tcomp = 0;
}

void
ar9280_olpc_temp_compensation(struct athn_softc *sc)
{
	const struct ar5416_eeprom *eep = sc->eep;
	int8_t pdadc, txgain, tcomp;
	uint32_t reg;
	int i;

	reg = AR_READ(sc, AR_PHY_TX_PWRCTRL4);
	pdadc = MS(reg, AR_PHY_TX_PWRCTRL_PD_AVG_OUT);
	DPRINTFN(3, ("PD Avg Out=%d\n", pdadc));

	if (sc->pdadc == 0 || pdadc == 0)
		return;	/* No frames transmitted yet. */

	/* Compute Tx gain temperature compensation. */
	if (sc->eep_rev >= AR_EEP_MINOR_VER_20 &&
	    eep->baseEepHeader.dacHiPwrMode_5G)
		tcomp = (pdadc - sc->pdadc + 4) / 8;
	else
		tcomp = (pdadc - sc->pdadc + 5) / 10;
	DPRINTFN(3, ("OLPC temp compensation=%d\n", tcomp));

	if (tcomp == sc->tcomp)
		return;	/* Don't rewrite the same values. */
	sc->tcomp = tcomp;

	/* Adjust Tx gain values. */
	for (i = 0; i < AR9280_TX_GAIN_TABLE_SIZE; i++) {
		txgain = sc->tx_gain_tbl[i] - tcomp;
		if (txgain < 0)
			txgain = 0;
		reg = AR_READ(sc, AR_PHY_TX_GAIN_TBL(i));
		reg = RW(reg, AR_PHY_TX_GAIN, txgain);
		AR_WRITE(sc, AR_PHY_TX_GAIN_TBL(i), reg);
	}
	AR_WRITE_BARRIER(sc);
}
@


1.25
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.24 2015/11/24 17:11:39 mpi Exp $	*/
d54 1
@


1.24
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.23 2015/11/24 13:45:06 mpi Exp $	*/
a375 1
#ifndef IEEE80211_NO_HT
a381 1
#endif
a504 1
#ifndef IEEE80211_NO_HT
d514 1
a514 3
	} else
#endif
	{
@


1.23
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.22 2015/11/24 13:33:17 mpi Exp $	*/
a46 1
#include <net/if_dl.h>
@


1.22
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.21 2014/12/19 22:44:58 guenther Exp $	*/
a46 1
#include <net/if_arp.h>
@


1.21
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.20 2014/07/22 13:12:11 mpi Exp $	*/
a49 1
#include <net/if_types.h>
@


1.20
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.19 2013/08/07 01:06:28 bluhm Exp $	*/
d38 1
a40 1
#include <machine/endian.h>
@


1.19
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.18 2012/06/10 21:23:36 kettenis Exp $	*/
a52 1
#include <netinet/in_systm.h>
a53 1
#include <netinet/ip.h>
@


1.18
log
@Allow a variable number of words for the Serializer/Deserializer programming.
Probably not enought to make the AR9380 chips to work, but at least the kernel
shouldn't crash anymore when we see one.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.17 2011/01/06 07:27:15 damien Exp $	*/
a53 1
#include <netinet/in_var.h>
@


1.17
log
@"athn* at uhub? port ?"
this adds preliminary support for the Atheros AR9271 chipset and
probably the AR9280+AR7010 and AR9287+AR7010 too though those were
not tested.
scanning still takes a very long time (~1 sec per channel) but
otherwise, operation in STA mode seems stable.
will implement fast channel change soon.

committed over the Ubiquiti WifiStation EXT (AR9271) on i386 with WPA.
requires firmware (see man page for details)

ok deraadt@@ (who checked the .h files)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.16 2011/01/01 14:25:03 damien Exp $	*/
d115 1
a115 1
	sc->serdes = ar9280_2_0_serdes;
@


1.16
log
@cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.15 2010/12/31 17:50:48 damien Exp $	*/
d325 9
a333 1
	reg = RW(reg, AR_AN_TOP2_XPABIAS_LVL, modal->xpaBiasLvl);
@


1.15
log
@of course, GPIO handling on AR9271 and AR7010 had to be different
from all other chips... quite nightmarish.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.14 2010/12/31 14:06:05 damien Exp $	*/
a476 1
		/* XXX Linux checks this too late? */
@


1.14
log
@Make the athn(4) back-end more bus agnostic by moving read and write
operations to callbacks in the PCI and CardBus front-ends.
This will allow support of other buses like USB.
Assume the following memory model:
- writes are ordered but may be buffered and require explicit flush
- a read always flushes all buffered writes
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.13 2010/09/03 15:40:08 damien Exp $	*/
d102 1
a102 1
	sc->ngpiopins = 10;
@


1.13
log
@fix initialization value of analog register AR_AN_TOP2 on some high
power AR9220 adapters.
this should fix at least Ubiquiti SR71-12 and Winstron DMNA92 adapters.

problem reported by Giuseppe Scalzi and Alex Dervish
fix tested by Giuseppe Scalzi with a Winstron DMNA92
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.12 2010/08/12 16:32:31 damien Exp $	*/
d234 1
d237 1
d300 1
d307 1
d314 1
d321 1
d331 1
d398 1
d411 1
d535 1
d622 1
@


1.12
log
@For chips in open-loop power control mode, periodically (every 30 secs)
compensate Tx gain for temperature changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.11 2010/08/12 16:04:51 damien Exp $	*/
d137 11
a323 8
	/* Fix for dual-band devices. */
	if (sc->eep_rev > AR_EEP_MINOR_VER_10 &&
	    (eep->baseEepHeader.opCapFlags & AR_OPFLAGS_11A)) {
		if (eep->baseEepHeader.pwdclkind)
			reg |= AR_AN_TOP2_PWDCLKIND;
		else
			reg &= ~AR_AN_TOP2_PWDCLKIND;
	}
d434 1
d444 1
@


1.11
log
@Fix look-up of the power control digital-to-analog converter (PCDAC)
value in the Tx gain table.
This fixes AR9280/AR9281 chips in open-loop power control mode, like
the high power solution found in the Acer Aspire One.

tested by ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.10 2010/07/15 20:37:38 damien Exp $	*/
d113 1
@


1.10
log
@According to Linux ath9k, the AR9280 1.0 was never sold.
Since this is the only chip revision that requires split TKIP MIC keys,
remove code that deal with that.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.9 2010/07/15 19:29:00 damien Exp $	*/
d430 1
a430 1
	pcdac = pierdata[hi].pcdac[0][0];	/* XXX lo??? */
d432 1
a432 1
		if (pcdac > sc->tx_gain_tbl[idx])
d435 3
@


1.9
log
@On AR9285, the antCtrlCommon ROM field may have the upper 16 bits set.
Remove an incorrect mask to fix antenna diversity on some chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.8 2010/07/15 19:07:43 damien Exp $	*/
a98 3
	/* AR9280 1.0 needs separate entries for Tx/Rx TKIP MIC. */
	if (AR_SREV_9280_10(sc))
		sc->flags |= ATHN_FLAG_SPLIT_TKIP_MIC;
@


1.8
log
@Remove initialization values for chips that never made it into production:
- AR9280 1.0
- AR9285 1.0 and 1.1
- AR9287 1.0

Remove checks that are now useless since we know we will never see those
chips, and rename some functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.7 2010/05/16 14:34:19 damien Exp $	*/
d243 1
a243 1
	AR_WRITE(sc, AR_PHY_SWITCH_COM, modal->antCtrlCommon & 0xffff);
@


1.7
log
@cleanup hardware key cache management (not used yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.6 2010/05/11 18:04:12 damien Exp $	*/
d77 1
a77 1
void	ar9280_2_0_olpc_get_pdadcs(struct athn_softc *,
d81 2
a82 2
void	ar9280_2_0_olpc_init(struct athn_softc *);
void	ar9280_2_0_olpc_temp_compensation(struct athn_softc *);
d115 3
a117 9
	sc->ops.olpc_init = ar9280_2_0_olpc_init;
	if (AR_SREV_9280_20_OR_LATER(sc))
		sc->ini = &ar9280_2_0_ini;
	else
		sc->ini = &ar9280_1_0_ini;
	if (AR_SREV_9280_20_OR_LATER(sc))
		sc->serdes = ar9280_2_0_serdes;
	else
		sc->serdes = ar9280_1_0_serdes;
d129 1
a129 2
	if (AR_SREV_9280_20_OR_LATER(sc) &&
	    sc->eep_rev >= AR_EEP_MINOR_VER_19 &&
d374 1
a374 2
	if (AR_SREV_9280_20_OR_LATER(sc) &&
	    sc->eep_rev >= AR_EEP_MINOR_VER_19) {
d405 2
a406 3
ar9280_2_0_olpc_get_pdadcs(struct athn_softc *sc,
    struct ieee80211_channel *c, int chain, uint8_t *boundaries,
    uint8_t *pdadcs, uint8_t *txgain)
d556 1
a556 1
ar9280_2_0_olpc_init(struct athn_softc *sc)
d571 1
a571 1
ar9280_2_0_olpc_temp_compensation(struct athn_softc *sc)
@


1.6
log
@put code that is meaningful only if HT is enabled under
#ifndef IEEE80211_NO_HT for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.5 2010/05/10 17:44:21 damien Exp $	*/
d99 3
@


1.5
log
@athn(4) is going to support a new family of Atheros 802.11n
chips (AR9003), which differs from the currently supported
families (AR5008, AR9001 and AR9002).

The main differences (from a driver point of view) are:

* DMA:
Tx and Rx descriptors have changed.
A single Tx descriptor can now reference up to 4 scatter/gather
DMA segments.
There is now a DMA ring for reporting Tx status with separate
Tx status descriptors (this ring is used to report Tx status for
all the Tx FIFOs).
Rx status descriptors are now put at the beginning of Rx buffers
and do not need to be allocated separately from buffers.
There are two Rx FIFOs (low priority and high priority) instead
of one.

* ROM:
The AR9003 family uses OTP-ROM instead of EEPROM.
Reading the ROM is totally insane since vendors can provide only
the chunks of ROM that differ from a default image (and thus the
default image has to be stored in the driver).
This is referenced as "compressed ROM" in the Linux driver, though
there is no real compression involved, at least for the moment.

* PHY registers:
All PHY registers have changed.
Some registers offsets do not fit on 16 bits anymore, but
since they are 32-bit aligned, we can still make them fit on
16 bits to save .rodata space in initialization tables.

* MAC registers:
Some MAC registers offsets have changed (GPIO, interrupt masks)
which is quite annoying (though ~98% remain the same.)

* Initialization values:
Initialization values are now split in mac/soc/bb/radio blocks
and pre/core/post phases in the Linux driver.  I have chosen to
not go that road and merge these blocks in modal and non-modal
initialization values (similar to the other families).
The initialization order remains exactly the same as the Linux
driver though.

To manage these differences, I have split athn.c in two backends:
ar5008.c contains the bits that are specific to the AR5008,
AR9001 and AR9002 families (used by ar5416.c, ar9280.c,
ar9285.c and ar9287.c) and that were previously in athn.c.

ar9003.c contains the bits that are specific to the new
AR9003 family (used by ar9380.c only for now.)

I have introduced a thin hardware abstraction layer (actually
a set of pointers to functions) that is used in athn.c.
My intent is to keep this abstraction layer as thin as possible
and not to create another ugly pile of abstraction layers a la
MadWifi.

I think I've managed to keep things sane, probably at the expense
of duplicating some code in both ar5008.c and ar9003.c, but at
least we do not have to dig through layers and layers of virtual
descriptors to figure out what is mapped to the hardware.

Tested for non-regression on various AR5416 (sparc64+i386), AR9281
and AR9285 (i386 only) adapters.
AR9380 part is not tested (hardware is not available to the general
public yet).

Committed over my AR9285 2.0.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.3 2009/11/17 19:32:22 damien Exp $	*/
d497 1
d507 3
a509 1
	} else {
@


1.4
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d65 1
d71 2
d75 4
d84 12
d100 1
a100 1
	sc->eep_size = sizeof (struct ar5416_eeprom);
d121 2
a122 1
	return (0);
d137 6
d186 1
a186 1
			/* XXX Magic from the Linux driver. */
d458 1
a458 1
	int spur_off, bound, i;
d463 1
a463 1
	bound = (extc != NULL) ? 19 : 10;
d477 1
a477 1
		if (abs(spur) < bound)
d525 1
a525 1
	athn_set_viterbi_mask(sc, bin);
@


1.3
log
@cleanup the printf/DPRINTF mess.
use proper debug levels for diagnostic messages such that we don't
spam the logs when athn_debug is low.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.2 2009/11/15 14:04:02 damien Exp $	*/
a28 1
#include <sys/sysctl.h>
@


1.2
log
@AR9287 uses GPIO pin 8 for LED, not 1.
Turn link LED on while associated.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9280.c,v 1.1 2009/11/14 16:55:11 damien Exp $	*/
d204 1
a204 1
	DPRINTF(("AR9280_PHY_SYNTH_CONTROL=0x%08x\n", phy));
d457 1
a457 1
	DPRINTF(("enabling spur mitigation\n"));
d558 1
a558 1
	DPRINTF(("PD Avg Out=%d\n", pdadc));
d569 1
a569 1
	DPRINTF(("OLPC temp compensation=%d\n", tcomp));
@


1.1
log
@athn(4), a driver for Atheros 802.11a/g/n devices.
written from scratch based on the vendor driver for Linux (ath9k).
AR9285 and AR9287 parts are 100% untested.
only basic functionnalities are enabled for now.

committed over an AR9281.

"commit" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
@

