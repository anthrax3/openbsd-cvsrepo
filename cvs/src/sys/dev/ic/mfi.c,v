head	1.167;
access;
symbols
	OPENBSD_6_1:1.167.0.4
	OPENBSD_6_1_BASE:1.167
	OPENBSD_6_0:1.165.0.6
	OPENBSD_6_0_BASE:1.165
	OPENBSD_5_9:1.165.0.2
	OPENBSD_5_9_BASE:1.165
	OPENBSD_5_8:1.164.0.4
	OPENBSD_5_8_BASE:1.164
	OPENBSD_5_7:1.161.0.2
	OPENBSD_5_7_BASE:1.161
	OPENBSD_5_6:1.154.0.4
	OPENBSD_5_6_BASE:1.154
	OPENBSD_5_5:1.151.0.4
	OPENBSD_5_5_BASE:1.151
	OPENBSD_5_4:1.146.0.2
	OPENBSD_5_4_BASE:1.146
	OPENBSD_5_3:1.138.0.2
	OPENBSD_5_3_BASE:1.138
	OPENBSD_5_2:1.122.0.2
	OPENBSD_5_2_BASE:1.122
	OPENBSD_5_1_BASE:1.122
	OPENBSD_5_1:1.122.0.4
	OPENBSD_5_0:1.121.0.2
	OPENBSD_5_0_BASE:1.121
	OPENBSD_4_9:1.114.0.2
	OPENBSD_4_9_BASE:1.114
	OPENBSD_4_8:1.110.0.2
	OPENBSD_4_8_BASE:1.110
	OPENBSD_4_7:1.99.0.2
	OPENBSD_4_7_BASE:1.99
	OPENBSD_4_6:1.95.0.4
	OPENBSD_4_6_BASE:1.95
	OPENBSD_4_5:1.89.0.2
	OPENBSD_4_5_BASE:1.89
	OPENBSD_4_4:1.80.0.4
	OPENBSD_4_4_BASE:1.80
	OPENBSD_4_3:1.80.0.2
	OPENBSD_4_3_BASE:1.80
	OPENBSD_4_2:1.73.0.2
	OPENBSD_4_2_BASE:1.73
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.65.0.2
	OPENBSD_4_0_BASE:1.65;
locks; strict;
comment	@ * @;


1.167
date	2017.02.02.03.47.41;	author dlg;	state Exp;
branches;
next	1.166;
commitid	fXiD6ENaI1SKujTl;

1.166
date	2017.01.23.01.10.31;	author dlg;	state Exp;
branches;
next	1.165;
commitid	7pJZ4RqwhUBfuMRS;

1.165
date	2015.09.09.18.23.55;	author deraadt;	state Exp;
branches;
next	1.164;
commitid	pxEWup0rbECbQnbF;

1.164
date	2015.05.29.00.33.37;	author uebayasi;	state Exp;
branches;
next	1.163;
commitid	k9pN2wgTn5cUwDek;

1.163
date	2015.05.18.12.21.04;	author mikeb;	state Exp;
branches;
next	1.162;
commitid	fdVpESN9MPnajMYr;

1.162
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.161;
commitid	p4LJxGKbi0BU2cG6;

1.161
date	2015.03.08.04.33.44;	author dlg;	state Exp;
branches;
next	1.160;
commitid	FOeOHeh5v7tILJs3;

1.160
date	2015.02.08.12.17.31;	author yasuoka;	state Exp;
branches;
next	1.159;
commitid	N6ZRRaHxx4c2ytLA;

1.159
date	2015.01.09.11.17.29;	author yasuoka;	state Exp;
branches;
next	1.158;
commitid	kKZF6pFZiduVd9TQ;

1.158
date	2014.12.19.07.23.57;	author deraadt;	state Exp;
branches;
next	1.157;
commitid	cV4v1OA8Ccwr5fwb;

1.157
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.156;
commitid	uzzBR7hz9ncd4O6G;

1.156
date	2014.09.09.03.08.30;	author dlg;	state Exp;
branches;
next	1.155;
commitid	7vQxRhkWrnBVVNjO;

1.155
date	2014.08.15.02.27.02;	author yasuoka;	state Exp;
branches;
next	1.154;
commitid	yBlCT4oSbR2KFU4a;

1.154
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.153;
commitid	JtO5uXxVcnZfhUkR;

1.153
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.152;
commitid	I19imNlAX05zJOED;

1.152
date	2014.05.04.20.09.15;	author sf;	state Exp;
branches;
next	1.151;

1.151
date	2014.02.20.11.13.44;	author kettenis;	state Exp;
branches;
next	1.150;

1.150
date	2014.02.20.11.09.48;	author kettenis;	state Exp;
branches;
next	1.149;

1.149
date	2013.12.04.05.21.57;	author dlg;	state Exp;
branches;
next	1.148;

1.148
date	2013.10.23.13.05.38;	author kettenis;	state Exp;
branches;
next	1.147;

1.147
date	2013.10.09.09.40.01;	author jmatthew;	state Exp;
branches;
next	1.146;

1.146
date	2013.05.18.08.39.47;	author jmc;	state Exp;
branches;
next	1.145;

1.145
date	2013.05.08.03.00.32;	author jsg;	state Exp;
branches;
next	1.144;

1.144
date	2013.05.03.02.46.28;	author dlg;	state Exp;
branches;
next	1.143;

1.143
date	2013.05.02.04.35.44;	author dlg;	state Exp;
branches;
next	1.142;

1.142
date	2013.05.01.03.44.21;	author dlg;	state Exp;
branches;
next	1.141;

1.141
date	2013.05.01.00.47.31;	author dlg;	state Exp;
branches;
next	1.140;

1.140
date	2013.04.30.07.17.36;	author dlg;	state Exp;
branches;
next	1.139;

1.139
date	2013.04.07.02.32.03;	author dlg;	state Exp;
branches;
next	1.138;

1.138
date	2012.09.12.06.53.05;	author haesbaert;	state Exp;
branches;
next	1.137;

1.137
date	2012.08.17.11.31.34;	author dlg;	state Exp;
branches;
next	1.136;

1.136
date	2012.08.16.07.53.22;	author dlg;	state Exp;
branches;
next	1.135;

1.135
date	2012.08.16.07.17.04;	author dlg;	state Exp;
branches;
next	1.134;

1.134
date	2012.08.16.06.45.51;	author dlg;	state Exp;
branches;
next	1.133;

1.133
date	2012.08.16.06.05.56;	author dlg;	state Exp;
branches;
next	1.132;

1.132
date	2012.08.16.05.49.38;	author dlg;	state Exp;
branches;
next	1.131;

1.131
date	2012.08.16.05.38.13;	author dlg;	state Exp;
branches;
next	1.130;

1.130
date	2012.08.14.10.44.36;	author dlg;	state Exp;
branches;
next	1.129;

1.129
date	2012.08.14.10.13.39;	author dlg;	state Exp;
branches;
next	1.128;

1.128
date	2012.08.14.04.07.53;	author dlg;	state Exp;
branches;
next	1.127;

1.127
date	2012.08.14.03.42.03;	author dlg;	state Exp;
branches;
next	1.126;

1.126
date	2012.08.13.06.19.15;	author dlg;	state Exp;
branches;
next	1.125;

1.125
date	2012.08.13.05.20.30;	author dlg;	state Exp;
branches;
next	1.124;

1.124
date	2012.08.13.03.04.51;	author dlg;	state Exp;
branches;
next	1.123;

1.123
date	2012.08.11.00.57.01;	author dlg;	state Exp;
branches;
next	1.122;

1.122
date	2012.01.12.06.12.30;	author dlg;	state Exp;
branches;
next	1.121;

1.121
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.120;

1.120
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.09.20.23.31;	author marco;	state Exp;
branches;
next	1.118;

1.118
date	2011.04.09.03.00.18;	author marco;	state Exp;
branches;
next	1.117;

1.117
date	2011.04.08.19.20.06;	author marco;	state Exp;
branches;
next	1.116;

1.116
date	2011.04.08.19.16.47;	author marco;	state Exp;
branches;
next	1.115;

1.115
date	2011.04.08.19.15.35;	author marco;	state Exp;
branches;
next	1.114;

1.114
date	2010.12.30.08.53.50;	author dlg;	state Exp;
branches;
next	1.113;

1.113
date	2010.09.24.01.30.05;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.111;

1.111
date	2010.08.29.23.23.31;	author dlg;	state Exp;
branches;
next	1.110;

1.110
date	2010.07.22.04.40.41;	author matthew;	state Exp;
branches;
next	1.109;

1.109
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.108;

1.108
date	2010.06.30.19.10.05;	author mk;	state Exp;
branches;
next	1.107;

1.107
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.105;

1.105
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.104;

1.104
date	2010.05.16.20.33.59;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2010.04.22.12.33.30;	author oga;	state Exp;
branches;
next	1.102;

1.102
date	2010.04.10.17.29.59;	author marco;	state Exp;
branches;
next	1.101;

1.101
date	2010.04.10.17.26.10;	author marco;	state Exp;
branches;
next	1.100;

1.100
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.99;

1.99
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2010.01.04.08.04.43;	author dlg;	state Exp;
branches;
next	1.97;

1.97
date	2010.01.04.07.57.28;	author dlg;	state Exp;
branches;
next	1.96;

1.96
date	2010.01.03.14.57.10;	author chl;	state Exp;
branches;
next	1.95;

1.95
date	2009.04.30.01.24.05;	author marco;	state Exp;
branches;
next	1.94;

1.94
date	2009.04.29.00.48.24;	author marco;	state Exp;
branches;
next	1.93;

1.93
date	2009.04.04.03.22.30;	author dlg;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.29.15.03.17;	author marco;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.29.01.05.56;	author dlg;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.29.01.02.35;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2009.01.28.23.45.12;	author marco;	state Exp;
branches;
next	1.87;

1.87
date	2008.10.31.21.39.04;	author marco;	state Exp;
branches;
next	1.86;

1.86
date	2008.10.30.19.20.13;	author marco;	state Exp;
branches;
next	1.85;

1.85
date	2008.10.28.21.44.25;	author marco;	state Exp;
branches;
next	1.84;

1.84
date	2008.10.27.03.11.58;	author marco;	state Exp;
branches;
next	1.83;

1.83
date	2008.10.26.18.56.00;	author marco;	state Exp;
branches;
next	1.82;

1.82
date	2008.10.23.00.30.04;	author marco;	state Exp;
branches;
next	1.81;

1.81
date	2008.09.25.11.23.54;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2008.02.16.15.24.05;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2008.02.11.01.07.02;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.26.08.57.31;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.26.07.13.59;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2008.01.26.07.04.50;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.05.23.43.26;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2007.09.27.08.45.19;	author chl;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.29.22.17.50;	author todd;	state Exp;
branches;
next	1.71;

1.71
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.14.00.53.16;	author dlg;	state Exp;
branches;
next	1.69;

1.69
date	2007.02.13.02.38.31;	author marco;	state Exp;
branches;
next	1.68;

1.68
date	2007.02.08.03.20.52;	author ray;	state Exp;
branches;
next	1.67;

1.67
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.65;

1.65
date	2006.08.31.18.13.17;	author marco;	state Exp;
branches;
next	1.64;

1.64
date	2006.08.30.07.25.52;	author dlg;	state Exp;
branches;
next	1.63;

1.63
date	2006.07.28.20.38.57;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2006.06.19.21.49.44;	author marco;	state Exp;
branches;
next	1.61;

1.61
date	2006.06.19.21.06.22;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2006.06.19.19.09.04;	author marco;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.19.19.05.45;	author marco;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.26.00.53.54;	author marco;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.25.22.04.35;	author marco;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.25.04.23.57;	author marco;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.25.02.15.47;	author marco;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.25.00.21.31;	author marco;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.23.03.55.41;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.23.00.44.41;	author marco;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.23.00.43.57;	author marco;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.22.19.50.43;	author marco;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.22.02.24.11;	author marco;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.22.01.08.39;	author marco;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.21.22.56.45;	author marco;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.21.21.55.44;	author marco;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.21.21.44.50;	author marco;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.21.20.20.17;	author marco;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.21.04.07.10;	author marco;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.21.04.03.06;	author marco;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.18.17.42.00;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.18.17.34.23;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.18.17.25.02;	author marco;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.17.23.40.26;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.17.21.50.21;	author marco;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.17.16.00.52;	author marco;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.16.23.11.48;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.16.23.05.25;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.16.22.51.10;	author marco;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.16.15.50.51;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.16.01.58.46;	author marco;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.16.01.15.29;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.16.01.02.42;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.15.23.31.24;	author marco;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.15.23.28.41;	author marco;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.15.23.20.56;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.10.21.48.50;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.26.01.25.37;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.21.21.43.59;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.21.21.39.32;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.20.14.01.08;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.18.16.29.54;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.18.00.21.06;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.17.16.46.39;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.17.00.48.14;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.16.23.39.43;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.16.23.35.43;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.16.18.14.23;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.16.17.15.36;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.16.17.10.08;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.16.16.53.55;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.16.16.41.29;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.16.16.34.35;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.07.20.27.51;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.07.20.05.31;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.07.17.02.15;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.07.16.28.07;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.07.16.11.21;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.06.22.44.24;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.06.20.22.53;	author marco;	state Exp;
branches;
next	;


desc
@@


1.167
log
@copy the mbox into the dcmd struct, not the pointer to the mbox.

makes bioctl work on mfi(4) again.

while here memset a few mboxes before using them.

bioctl breakage reported by jason george
@
text
@/* $OpenBSD: mfi.c,v 1.166 2017/01/23 01:10:31 dlg Exp $ */
/*
 * Copyright (c) 2006 Marco Peereboom <marco@@peereboom.us>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/rwlock.h>
#include <sys/sensors.h>
#include <sys/dkio.h>
#include <sys/pool.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/biovar.h>
#include <dev/ic/mfireg.h>
#include <dev/ic/mfivar.h>

#ifdef MFI_DEBUG
uint32_t	mfi_debug = 0
/*		    | MFI_D_CMD */
/*		    | MFI_D_INTR */
/*		    | MFI_D_MISC */
/*		    | MFI_D_DMA */
/*		    | MFI_D_IOCTL */
/*		    | MFI_D_RW */
/*		    | MFI_D_MEM */
/*		    | MFI_D_CCB */
		;
#endif

struct cfdriver mfi_cd = {
	NULL, "mfi", DV_DULL
};

void	mfi_scsi_cmd(struct scsi_xfer *);
int	mfi_scsi_ioctl(struct scsi_link *, u_long, caddr_t, int);
int	mfi_ioctl_cache(struct scsi_link *, u_long,  struct dk_cache *);
void	mfiminphys(struct buf *bp, struct scsi_link *sl);

void	mfi_pd_scsi_cmd(struct scsi_xfer *);
int	mfi_pd_scsi_probe(struct scsi_link *);

struct scsi_adapter mfi_switch = {
	mfi_scsi_cmd, mfiminphys, 0, 0, mfi_scsi_ioctl
};

struct scsi_adapter mfi_pd_switch = {
	mfi_pd_scsi_cmd,
	mfiminphys,
	mfi_pd_scsi_probe,
	0,
	mfi_scsi_ioctl
};

void *		mfi_get_ccb(void *);
void		mfi_put_ccb(void *, void *);
void		mfi_scrub_ccb(struct mfi_ccb *);
int		mfi_init_ccb(struct mfi_softc *);

struct mfi_mem	*mfi_allocmem(struct mfi_softc *, size_t);
void		mfi_freemem(struct mfi_softc *, struct mfi_mem *);

int		mfi_transition_firmware(struct mfi_softc *);
int		mfi_initialize_firmware(struct mfi_softc *);
int		mfi_get_info(struct mfi_softc *);
uint32_t	mfi_read(struct mfi_softc *, bus_size_t);
void		mfi_write(struct mfi_softc *, bus_size_t, uint32_t);
void		mfi_poll(struct mfi_softc *, struct mfi_ccb *);
void		mfi_exec(struct mfi_softc *, struct mfi_ccb *);
void		mfi_exec_done(struct mfi_softc *, struct mfi_ccb *);
int		mfi_create_sgl(struct mfi_softc *, struct mfi_ccb *, int);
u_int		mfi_default_sgd_load(struct mfi_softc *, struct mfi_ccb *);
int		mfi_syspd(struct mfi_softc *);

/* commands */
int		mfi_scsi_ld(struct mfi_softc *sc, struct mfi_ccb *,
		    struct scsi_xfer *);
int		mfi_scsi_io(struct mfi_softc *sc, struct mfi_ccb *,
		    struct scsi_xfer *, uint64_t, uint32_t);
void		mfi_scsi_xs_done(struct mfi_softc *sc, struct mfi_ccb *);
int		mfi_mgmt(struct mfi_softc *, uint32_t, uint32_t, uint32_t,
		    void *, const union mfi_mbox *);
int		mfi_do_mgmt(struct mfi_softc *, struct mfi_ccb * , uint32_t,
		    uint32_t, uint32_t, void *, const union mfi_mbox *);
void		mfi_empty_done(struct mfi_softc *, struct mfi_ccb *);

#if NBIO > 0
int		mfi_ioctl(struct device *, u_long, caddr_t);
int		mfi_bio_getitall(struct mfi_softc *);
int		mfi_ioctl_inq(struct mfi_softc *, struct bioc_inq *);
int		mfi_ioctl_vol(struct mfi_softc *, struct bioc_vol *);
int		mfi_ioctl_disk(struct mfi_softc *, struct bioc_disk *);
int		mfi_ioctl_alarm(struct mfi_softc *, struct bioc_alarm *);
int		mfi_ioctl_blink(struct mfi_softc *sc, struct bioc_blink *);
int		mfi_ioctl_setstate(struct mfi_softc *, struct bioc_setstate *);
int		mfi_ioctl_patrol(struct mfi_softc *sc, struct bioc_patrol *);
int		mfi_bio_hs(struct mfi_softc *, int, int, void *);
#ifndef SMALL_KERNEL
int		mfi_create_sensors(struct mfi_softc *);
void		mfi_refresh_sensors(void *);
int		mfi_bbu(struct mfi_softc *);
#endif /* SMALL_KERNEL */
#endif /* NBIO > 0 */

void		mfi_start(struct mfi_softc *, struct mfi_ccb *);
void		mfi_done(struct mfi_softc *, struct mfi_ccb *);
u_int32_t	mfi_xscale_fw_state(struct mfi_softc *);
void		mfi_xscale_intr_ena(struct mfi_softc *);
int		mfi_xscale_intr(struct mfi_softc *);
void		mfi_xscale_post(struct mfi_softc *, struct mfi_ccb *);

static const struct mfi_iop_ops mfi_iop_xscale = {
	mfi_xscale_fw_state,
	mfi_xscale_intr_ena,
	mfi_xscale_intr,
	mfi_xscale_post,
	mfi_default_sgd_load,
	0,
};

u_int32_t	mfi_ppc_fw_state(struct mfi_softc *);
void		mfi_ppc_intr_ena(struct mfi_softc *);
int		mfi_ppc_intr(struct mfi_softc *);
void		mfi_ppc_post(struct mfi_softc *, struct mfi_ccb *);

static const struct mfi_iop_ops mfi_iop_ppc = {
	mfi_ppc_fw_state,
	mfi_ppc_intr_ena,
	mfi_ppc_intr,
	mfi_ppc_post,
	mfi_default_sgd_load,
	MFI_IDB,
	0
};

u_int32_t	mfi_gen2_fw_state(struct mfi_softc *);
void		mfi_gen2_intr_ena(struct mfi_softc *);
int		mfi_gen2_intr(struct mfi_softc *);
void		mfi_gen2_post(struct mfi_softc *, struct mfi_ccb *);

static const struct mfi_iop_ops mfi_iop_gen2 = {
	mfi_gen2_fw_state,
	mfi_gen2_intr_ena,
	mfi_gen2_intr,
	mfi_gen2_post,
	mfi_default_sgd_load,
	MFI_IDB,
	0
};

u_int32_t	mfi_skinny_fw_state(struct mfi_softc *);
void		mfi_skinny_intr_ena(struct mfi_softc *);
int		mfi_skinny_intr(struct mfi_softc *);
void		mfi_skinny_post(struct mfi_softc *, struct mfi_ccb *);
u_int		mfi_skinny_sgd_load(struct mfi_softc *, struct mfi_ccb *);

static const struct mfi_iop_ops mfi_iop_skinny = {
	mfi_skinny_fw_state,
	mfi_skinny_intr_ena,
	mfi_skinny_intr,
	mfi_skinny_post,
	mfi_skinny_sgd_load,
	MFI_SKINNY_IDB,
	MFI_IOP_F_SYSPD
};

#define mfi_fw_state(_s)	((_s)->sc_iop->mio_fw_state(_s))
#define mfi_intr_enable(_s)	((_s)->sc_iop->mio_intr_ena(_s))
#define mfi_my_intr(_s)		((_s)->sc_iop->mio_intr(_s))
#define mfi_post(_s, _c)	((_s)->sc_iop->mio_post((_s), (_c)))
#define mfi_sgd_load(_s, _c)	((_s)->sc_iop->mio_sgd_load((_s), (_c)))

void *
mfi_get_ccb(void *cookie)
{
	struct mfi_softc	*sc = cookie;
	struct mfi_ccb		*ccb;

	KERNEL_UNLOCK();

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = SLIST_FIRST(&sc->sc_ccb_freeq);
	if (ccb != NULL) {
		SLIST_REMOVE_HEAD(&sc->sc_ccb_freeq, ccb_link);
		ccb->ccb_state = MFI_CCB_READY;
	}
	mtx_leave(&sc->sc_ccb_mtx);

	DNPRINTF(MFI_D_CCB, "%s: mfi_get_ccb: %p\n", DEVNAME(sc), ccb);
	KERNEL_LOCK();

	return (ccb);
}

void
mfi_put_ccb(void *cookie, void *io)
{
	struct mfi_softc	*sc = cookie;
	struct mfi_ccb		*ccb = io;

	DNPRINTF(MFI_D_CCB, "%s: mfi_put_ccb: %p\n", DEVNAME(sc), ccb);

	KERNEL_UNLOCK();
	mtx_enter(&sc->sc_ccb_mtx);
	SLIST_INSERT_HEAD(&sc->sc_ccb_freeq, ccb, ccb_link);
	mtx_leave(&sc->sc_ccb_mtx);
	KERNEL_LOCK();
}

void
mfi_scrub_ccb(struct mfi_ccb *ccb)
{
	struct mfi_frame_header	*hdr = &ccb->ccb_frame->mfr_header;

	hdr->mfh_cmd_status = 0x0;
	hdr->mfh_flags = 0x0;
	ccb->ccb_state = MFI_CCB_FREE;
	ccb->ccb_cookie = NULL;
	ccb->ccb_flags = 0;
	ccb->ccb_done = NULL;
	ccb->ccb_direction = 0;
	ccb->ccb_frame_size = 0;
	ccb->ccb_extra_frames = 0;
	ccb->ccb_sgl = NULL;
	ccb->ccb_data = NULL;
	ccb->ccb_len = 0;
}

int
mfi_init_ccb(struct mfi_softc *sc)
{
	struct mfi_ccb		*ccb;
	uint32_t		i;
	int			error;

	DNPRINTF(MFI_D_CCB, "%s: mfi_init_ccb\n", DEVNAME(sc));

	sc->sc_ccb = mallocarray(sc->sc_max_cmds, sizeof(struct mfi_ccb),
	    M_DEVBUF, M_WAITOK|M_ZERO);

	for (i = 0; i < sc->sc_max_cmds; i++) {
		ccb = &sc->sc_ccb[i];

		/* select i'th frame */
		ccb->ccb_frame = (union mfi_frame *)
		    (MFIMEM_KVA(sc->sc_frames) + sc->sc_frames_size * i);
		ccb->ccb_pframe =
		    MFIMEM_DVA(sc->sc_frames) + sc->sc_frames_size * i;
		ccb->ccb_pframe_offset = sc->sc_frames_size * i;
		ccb->ccb_frame->mfr_header.mfh_context = i;

		/* select i'th sense */
		ccb->ccb_sense = (struct mfi_sense *)
		    (MFIMEM_KVA(sc->sc_sense) + MFI_SENSE_SIZE * i);
		ccb->ccb_psense =
		    (MFIMEM_DVA(sc->sc_sense) + MFI_SENSE_SIZE * i);

		/* create a dma map for transfer */
		error = bus_dmamap_create(sc->sc_dmat,
		    MAXPHYS, sc->sc_max_sgl, MAXPHYS, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->ccb_dmamap);
		if (error) {
			printf("%s: cannot create ccb dmamap (%d)\n",
			    DEVNAME(sc), error);
			goto destroy;
		}

		DNPRINTF(MFI_D_CCB,
		    "ccb(%d): %p frame: %#x (%#x) sense: %#x (%#x) map: %#x\n",
		    ccb->ccb_frame->mfr_header.mfh_context, ccb,
		    ccb->ccb_frame, ccb->ccb_pframe,
		    ccb->ccb_sense, ccb->ccb_psense,
		    ccb->ccb_dmamap);

		/* add ccb to queue */
		mfi_put_ccb(sc, ccb);
	}

	return (0);
destroy:
	/* free dma maps and ccb memory */
	while ((ccb = mfi_get_ccb(sc)) != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);

	free(sc->sc_ccb, M_DEVBUF, 0);

	return (1);
}

uint32_t
mfi_read(struct mfi_softc *sc, bus_size_t r)
{
	uint32_t rv;

	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_READ);
	rv = bus_space_read_4(sc->sc_iot, sc->sc_ioh, r);

	DNPRINTF(MFI_D_RW, "%s: mr 0x%x 0x08%x ", DEVNAME(sc), r, rv);
	return (rv);
}

void
mfi_write(struct mfi_softc *sc, bus_size_t r, uint32_t v)
{
	DNPRINTF(MFI_D_RW, "%s: mw 0x%x 0x%08x", DEVNAME(sc), r, v);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, r, v);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_WRITE);
}

struct mfi_mem *
mfi_allocmem(struct mfi_softc *sc, size_t size)
{
	struct mfi_mem		*mm;
	int			nsegs;

	DNPRINTF(MFI_D_MEM, "%s: mfi_allocmem: %d\n", DEVNAME(sc),
	    size);

	mm = malloc(sizeof(struct mfi_mem), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (mm == NULL)
		return (NULL);

	mm->am_size = size;

	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &mm->am_map) != 0)
		goto amfree;

	if (bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &mm->am_seg, 1,
	    &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(sc->sc_dmat, &mm->am_seg, nsegs, size, &mm->am_kva,
	    BUS_DMA_NOWAIT) != 0)
		goto free;

	if (bus_dmamap_load(sc->sc_dmat, mm->am_map, mm->am_kva, size, NULL,
	    BUS_DMA_NOWAIT) != 0)
		goto unmap;

	DNPRINTF(MFI_D_MEM, "  kva: %p  dva: %p  map: %p\n",
	    mm->am_kva, mm->am_map->dm_segs[0].ds_addr, mm->am_map);

	return (mm);

unmap:
	bus_dmamem_unmap(sc->sc_dmat, mm->am_kva, size);
free:
	bus_dmamem_free(sc->sc_dmat, &mm->am_seg, 1);
destroy:
	bus_dmamap_destroy(sc->sc_dmat, mm->am_map);
amfree:
	free(mm, M_DEVBUF, sizeof *mm);

	return (NULL);
}

void
mfi_freemem(struct mfi_softc *sc, struct mfi_mem *mm)
{
	DNPRINTF(MFI_D_MEM, "%s: mfi_freemem: %p\n", DEVNAME(sc), mm);

	bus_dmamap_unload(sc->sc_dmat, mm->am_map);
	bus_dmamem_unmap(sc->sc_dmat, mm->am_kva, mm->am_size);
	bus_dmamem_free(sc->sc_dmat, &mm->am_seg, 1);
	bus_dmamap_destroy(sc->sc_dmat, mm->am_map);
	free(mm, M_DEVBUF, sizeof *mm);
}

int
mfi_transition_firmware(struct mfi_softc *sc)
{
	int32_t			fw_state, cur_state;
	u_int32_t		idb = sc->sc_iop->mio_idb;
	int			max_wait, i;

	fw_state = mfi_fw_state(sc) & MFI_STATE_MASK;

	DNPRINTF(MFI_D_CMD, "%s: mfi_transition_firmware: %#x\n", DEVNAME(sc),
	    fw_state);

	while (fw_state != MFI_STATE_READY) {
		DNPRINTF(MFI_D_MISC,
		    "%s: waiting for firmware to become ready\n",
		    DEVNAME(sc));
		cur_state = fw_state;
		switch (fw_state) {
		case MFI_STATE_FAULT:
			printf("%s: firmware fault\n", DEVNAME(sc));
			return (1);
		case MFI_STATE_WAIT_HANDSHAKE:
			mfi_write(sc, idb, MFI_INIT_CLEAR_HANDSHAKE);
			max_wait = 2;
			break;
		case MFI_STATE_OPERATIONAL:
			mfi_write(sc, idb, MFI_INIT_READY);
			max_wait = 10;
			break;
		case MFI_STATE_UNDEFINED:
		case MFI_STATE_BB_INIT:
			max_wait = 2;
			break;
		case MFI_STATE_FW_INIT:
		case MFI_STATE_DEVICE_SCAN:
		case MFI_STATE_FLUSH_CACHE:
			max_wait = 20;
			break;
		default:
			printf("%s: unknown firmware state %d\n",
			    DEVNAME(sc), fw_state);
			return (1);
		}
		for (i = 0; i < (max_wait * 10); i++) {
			fw_state = mfi_fw_state(sc) & MFI_STATE_MASK;
			if (fw_state == cur_state)
				DELAY(100000);
			else
				break;
		}
		if (fw_state == cur_state) {
			printf("%s: firmware stuck in state %#x\n",
			    DEVNAME(sc), fw_state);
			return (1);
		}
	}

	return (0);
}

int
mfi_initialize_firmware(struct mfi_softc *sc)
{
	struct mfi_ccb		*ccb;
	struct mfi_init_frame	*init;
	struct mfi_init_qinfo	*qinfo;
	int			rv = 0;

	DNPRINTF(MFI_D_MISC, "%s: mfi_initialize_firmware\n", DEVNAME(sc));

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	mfi_scrub_ccb(ccb);

	init = &ccb->ccb_frame->mfr_init;
	qinfo = (struct mfi_init_qinfo *)((uint8_t *)init + MFI_FRAME_SIZE);

	memset(qinfo, 0, sizeof(*qinfo));
	qinfo->miq_rq_entries = htole32(sc->sc_max_cmds + 1);

	qinfo->miq_rq_addr = htole64(MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_reply_q));

	qinfo->miq_pi_addr = htole64(MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_producer));

	qinfo->miq_ci_addr = htole64(MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_consumer));

	init->mif_header.mfh_cmd = MFI_CMD_INIT;
	init->mif_header.mfh_data_len = htole32(sizeof(*qinfo));
	init->mif_qinfo_new_addr = htole64(ccb->ccb_pframe + MFI_FRAME_SIZE);

	bus_dmamap_sync(sc->sc_dmat, MFIMEM_MAP(sc->sc_pcq),
	    0, MFIMEM_LEN(sc->sc_pcq),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	ccb->ccb_done = mfi_empty_done;
	mfi_poll(sc, ccb);
	if (init->mif_header.mfh_cmd_status != MFI_STAT_OK)
		rv = 1;

	mfi_put_ccb(sc, ccb);

	return (rv);
}

void
mfi_empty_done(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	/* nop */
}

int
mfi_get_info(struct mfi_softc *sc)
{
#ifdef MFI_DEBUG
	int i;
#endif
	DNPRINTF(MFI_D_MISC, "%s: mfi_get_info\n", DEVNAME(sc));

	if (mfi_mgmt(sc, MR_DCMD_CTRL_GET_INFO, MFI_DATA_IN,
	    sizeof(sc->sc_info), &sc->sc_info, NULL))
		return (1);

#ifdef MFI_DEBUG
	for (i = 0; i < sc->sc_info.mci_image_component_count; i++) {
		printf("%s: active FW %s Version %s date %s time %s\n",
		    DEVNAME(sc),
		    sc->sc_info.mci_image_component[i].mic_name,
		    sc->sc_info.mci_image_component[i].mic_version,
		    sc->sc_info.mci_image_component[i].mic_build_date,
		    sc->sc_info.mci_image_component[i].mic_build_time);
	}

	for (i = 0; i < sc->sc_info.mci_pending_image_component_count; i++) {
		printf("%s: pending FW %s Version %s date %s time %s\n",
		    DEVNAME(sc),
		    sc->sc_info.mci_pending_image_component[i].mic_name,
		    sc->sc_info.mci_pending_image_component[i].mic_version,
		    sc->sc_info.mci_pending_image_component[i].mic_build_date,
		    sc->sc_info.mci_pending_image_component[i].mic_build_time);
	}

	printf("%s: max_arms %d max_spans %d max_arrs %d max_lds %d name %s\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_max_arms,
	    sc->sc_info.mci_max_spans,
	    sc->sc_info.mci_max_arrays,
	    sc->sc_info.mci_max_lds,
	    sc->sc_info.mci_product_name);

	printf("%s: serial %s present %#x fw time %d max_cmds %d max_sg %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_serial_number,
	    sc->sc_info.mci_hw_present,
	    sc->sc_info.mci_current_fw_time,
	    sc->sc_info.mci_max_cmds,
	    sc->sc_info.mci_max_sg_elements);

	printf("%s: max_rq %d lds_pres %d lds_deg %d lds_off %d pd_pres %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_max_request_size,
	    sc->sc_info.mci_lds_present,
	    sc->sc_info.mci_lds_degraded,
	    sc->sc_info.mci_lds_offline,
	    sc->sc_info.mci_pd_present);

	printf("%s: pd_dsk_prs %d pd_dsk_pred_fail %d pd_dsk_fail %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_pd_disks_present,
	    sc->sc_info.mci_pd_disks_pred_failure,
	    sc->sc_info.mci_pd_disks_failed);

	printf("%s: nvram %d mem %d flash %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_nvram_size,
	    sc->sc_info.mci_memory_size,
	    sc->sc_info.mci_flash_size);

	printf("%s: ram_cor %d ram_uncor %d clus_all %d clus_act %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_ram_correctable_errors,
	    sc->sc_info.mci_ram_uncorrectable_errors,
	    sc->sc_info.mci_cluster_allowed,
	    sc->sc_info.mci_cluster_active);

	printf("%s: max_strps_io %d raid_lvl %#x adapt_ops %#x ld_ops %#x\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_max_strips_per_io,
	    sc->sc_info.mci_raid_levels,
	    sc->sc_info.mci_adapter_ops,
	    sc->sc_info.mci_ld_ops);

	printf("%s: strp_sz_min %d strp_sz_max %d pd_ops %#x pd_mix %#x\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_stripe_sz_ops.min,
	    sc->sc_info.mci_stripe_sz_ops.max,
	    sc->sc_info.mci_pd_ops,
	    sc->sc_info.mci_pd_mix_support);

	printf("%s: ecc_bucket %d pckg_prop %s\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_ecc_bucket_count,
	    sc->sc_info.mci_package_version);

	printf("%s: sq_nm %d prd_fail_poll %d intr_thrtl %d intr_thrtl_to %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_properties.mcp_seq_num,
	    sc->sc_info.mci_properties.mcp_pred_fail_poll_interval,
	    sc->sc_info.mci_properties.mcp_intr_throttle_cnt,
	    sc->sc_info.mci_properties.mcp_intr_throttle_timeout);

	printf("%s: rbld_rate %d patr_rd_rate %d bgi_rate %d cc_rate %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_properties.mcp_rebuild_rate,
	    sc->sc_info.mci_properties.mcp_patrol_read_rate,
	    sc->sc_info.mci_properties.mcp_bgi_rate,
	    sc->sc_info.mci_properties.mcp_cc_rate);

	printf("%s: rc_rate %d ch_flsh %d spin_cnt %d spin_dly %d clus_en %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_properties.mcp_recon_rate,
	    sc->sc_info.mci_properties.mcp_cache_flush_interval,
	    sc->sc_info.mci_properties.mcp_spinup_drv_cnt,
	    sc->sc_info.mci_properties.mcp_spinup_delay,
	    sc->sc_info.mci_properties.mcp_cluster_enable);

	printf("%s: coerc %d alarm %d dis_auto_rbld %d dis_bat_wrn %d ecc %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_properties.mcp_coercion_mode,
	    sc->sc_info.mci_properties.mcp_alarm_enable,
	    sc->sc_info.mci_properties.mcp_disable_auto_rebuild,
	    sc->sc_info.mci_properties.mcp_disable_battery_warn,
	    sc->sc_info.mci_properties.mcp_ecc_bucket_size);

	printf("%s: ecc_leak %d rest_hs %d exp_encl_dev %d\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_properties.mcp_ecc_bucket_leak_rate,
	    sc->sc_info.mci_properties.mcp_restore_hotspare_on_insertion,
	    sc->sc_info.mci_properties.mcp_expose_encl_devices);

	printf("%s: vendor %#x device %#x subvendor %#x subdevice %#x\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_pci.mip_vendor,
	    sc->sc_info.mci_pci.mip_device,
	    sc->sc_info.mci_pci.mip_subvendor,
	    sc->sc_info.mci_pci.mip_subdevice);

	printf("%s: type %#x port_count %d port_addr ",
	    DEVNAME(sc),
	    sc->sc_info.mci_host.mih_type,
	    sc->sc_info.mci_host.mih_port_count);

	for (i = 0; i < 8; i++)
		printf("%.0llx ", sc->sc_info.mci_host.mih_port_addr[i]);
	printf("\n");

	printf("%s: type %.x port_count %d port_addr ",
	    DEVNAME(sc),
	    sc->sc_info.mci_device.mid_type,
	    sc->sc_info.mci_device.mid_port_count);

	for (i = 0; i < 8; i++)
		printf("%.0llx ", sc->sc_info.mci_device.mid_port_addr[i]);
	printf("\n");
#endif /* MFI_DEBUG */

	return (0);
}

void
mfiminphys(struct buf *bp, struct scsi_link *sl)
{
	DNPRINTF(MFI_D_MISC, "mfiminphys: %d\n", bp->b_bcount);

	/* XXX currently using MFI_MAXFER = MAXPHYS */
	if (bp->b_bcount > MFI_MAXFER)
		bp->b_bcount = MFI_MAXFER;
	minphys(bp);
}

int
mfi_attach(struct mfi_softc *sc, enum mfi_iop iop)
{
	struct scsibus_attach_args saa;
	uint32_t		status, frames, max_sgl;
	int			i;

	switch (iop) {
	case MFI_IOP_XSCALE:
		sc->sc_iop = &mfi_iop_xscale;
		break;
	case MFI_IOP_PPC:
		sc->sc_iop = &mfi_iop_ppc;
		break;
	case MFI_IOP_GEN2:
		sc->sc_iop = &mfi_iop_gen2;
		break;
	case MFI_IOP_SKINNY:
		sc->sc_iop = &mfi_iop_skinny;
		break;
	default:
		panic("%s: unknown iop %d", DEVNAME(sc), iop);
	}

	DNPRINTF(MFI_D_MISC, "%s: mfi_attach\n", DEVNAME(sc));

	if (mfi_transition_firmware(sc))
		return (1);

	SLIST_INIT(&sc->sc_ccb_freeq);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, mfi_get_ccb, mfi_put_ccb);

	rw_init(&sc->sc_lock, "mfi_lock");

	status = mfi_fw_state(sc);
	sc->sc_max_cmds = status & MFI_STATE_MAXCMD_MASK;
	max_sgl = (status & MFI_STATE_MAXSGL_MASK) >> 16;
	if (sc->sc_64bit_dma) {
		sc->sc_max_sgl = min(max_sgl, (128 * 1024) / PAGE_SIZE + 1);
		sc->sc_sgl_size = sizeof(struct mfi_sg64);
		sc->sc_sgl_flags = MFI_FRAME_SGL64;
	} else {
		sc->sc_max_sgl = max_sgl;
		sc->sc_sgl_size = sizeof(struct mfi_sg32);
		sc->sc_sgl_flags = MFI_FRAME_SGL32;
	}
	if (iop == MFI_IOP_SKINNY)
		sc->sc_sgl_size = sizeof(struct mfi_sg_skinny);
	DNPRINTF(MFI_D_MISC, "%s: 64bit: %d max commands: %u, max sgl: %u\n",
	    DEVNAME(sc), sc->sc_64bit_dma, sc->sc_max_cmds, sc->sc_max_sgl);

	/* consumer/producer and reply queue memory */
	sc->sc_pcq = mfi_allocmem(sc, (sizeof(uint32_t) * sc->sc_max_cmds) +
	    sizeof(struct mfi_prod_cons));
	if (sc->sc_pcq == NULL) {
		printf("%s: unable to allocate reply queue memory\n",
		    DEVNAME(sc));
		goto nopcq;
	}

	/* frame memory */
	/* we are not doing 64 bit IO so only calculate # of 32 bit frames */
	frames = (sc->sc_sgl_size * sc->sc_max_sgl + MFI_FRAME_SIZE - 1) /
	    MFI_FRAME_SIZE + 1;
	sc->sc_frames_size = frames * MFI_FRAME_SIZE;
	sc->sc_frames = mfi_allocmem(sc, sc->sc_frames_size * sc->sc_max_cmds);
	if (sc->sc_frames == NULL) {
		printf("%s: unable to allocate frame memory\n", DEVNAME(sc));
		goto noframe;
	}
	/* XXX hack, fix this */
	if (MFIMEM_DVA(sc->sc_frames) & 0x3f) {
		printf("%s: improper frame alignment (%#lx) FIXME\n",
		    DEVNAME(sc), MFIMEM_DVA(sc->sc_frames));
		goto noframe;
	}

	/* sense memory */
	sc->sc_sense = mfi_allocmem(sc, sc->sc_max_cmds * MFI_SENSE_SIZE);
	if (sc->sc_sense == NULL) {
		printf("%s: unable to allocate sense memory\n", DEVNAME(sc));
		goto nosense;
	}

	/* now that we have all memory bits go initialize ccbs */
	if (mfi_init_ccb(sc)) {
		printf("%s: could not init ccb list\n", DEVNAME(sc));
		goto noinit;
	}

	/* kickstart firmware with all addresses and pointers */
	if (mfi_initialize_firmware(sc)) {
		printf("%s: could not initialize firmware\n", DEVNAME(sc));
		goto noinit;
	}

	if (mfi_get_info(sc)) {
		printf("%s: could not retrieve controller information\n",
		    DEVNAME(sc));
		goto noinit;
	}

	printf("%s: \"%s\", firmware %s", DEVNAME(sc),
	    sc->sc_info.mci_product_name, sc->sc_info.mci_package_version);
	if (letoh16(sc->sc_info.mci_memory_size) > 0)
		printf(", %uMB cache", letoh16(sc->sc_info.mci_memory_size));
	printf("\n");

	sc->sc_ld_cnt = sc->sc_info.mci_lds_present;
	for (i = 0; i < sc->sc_ld_cnt; i++)
		sc->sc_ld[i].ld_present = 1;

	sc->sc_link.adapter = &mfi_switch;
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_buswidth = sc->sc_info.mci_max_lds;
	sc->sc_link.adapter_target = -1;
	sc->sc_link.luns = 1;
	sc->sc_link.openings = sc->sc_max_cmds - 1;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	sc->sc_scsibus = (struct scsibus_softc *)
	    config_found(&sc->sc_dev, &saa, scsiprint);

	if (ISSET(sc->sc_iop->mio_flags, MFI_IOP_F_SYSPD))
		mfi_syspd(sc);

	/* enable interrupts */
	mfi_intr_enable(sc);

#if NBIO > 0
	if (bio_register(&sc->sc_dev, mfi_ioctl) != 0)
		panic("%s: controller registration failed", DEVNAME(sc));
	else
		sc->sc_ioctl = mfi_ioctl;

#ifndef SMALL_KERNEL
	if (mfi_create_sensors(sc) != 0)
		printf("%s: unable to create sensors\n", DEVNAME(sc));
#endif
#endif /* NBIO > 0 */

	return (0);
noinit:
	mfi_freemem(sc, sc->sc_sense);
nosense:
	mfi_freemem(sc, sc->sc_frames);
noframe:
	mfi_freemem(sc, sc->sc_pcq);
nopcq:
	return (1);
}

int
mfi_syspd(struct mfi_softc *sc)
{
	struct scsibus_attach_args saa;
	struct scsi_link *link;
	struct mfi_pd_link *pl;
	struct mfi_pd_list *pd;
	u_int npds, i;

	sc->sc_pd = malloc(sizeof(*sc->sc_pd), M_DEVBUF, M_WAITOK|M_ZERO);
	if (sc->sc_pd == NULL)
		return (1);

	pd = malloc(sizeof(*pd), M_TEMP, M_WAITOK|M_ZERO);
	if (pd == NULL)
		goto nopdsc;

	if (mfi_mgmt(sc, MR_DCMD_PD_GET_LIST, MFI_DATA_IN,
	    sizeof(*pd), pd, NULL) != 0)
		goto nopd;

	npds = letoh32(pd->mpl_no_pd);
	for (i = 0; i < npds; i++) {
		pl = malloc(sizeof(*pl), M_DEVBUF, M_WAITOK|M_ZERO);
		if (pl == NULL)
			goto nopl;

		pl->pd_id = pd->mpl_address[i].mpa_pd_id;
		sc->sc_pd->pd_links[i] = pl;
	}

	free(pd, M_TEMP, sizeof *pd);

	link = &sc->sc_pd->pd_link;
	link->adapter = &mfi_pd_switch;
	link->adapter_softc = sc;
	link->adapter_buswidth = MFI_MAX_PD;
	link->adapter_target = -1;
	link->openings = sc->sc_max_cmds - 1;
	link->pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = link;

	sc->sc_pd->pd_scsibus = (struct scsibus_softc *)
	    config_found(&sc->sc_dev, &saa, scsiprint);

	return (0);
nopl:
	for (i = 0; i < npds; i++) {
		pl = sc->sc_pd->pd_links[i];
		if (pl == NULL)
			break;

		free(pl, M_DEVBUF, sizeof *pl);
	}
nopd:
	free(pd, M_TEMP, sizeof *pd);
nopdsc:
	free(sc->sc_pd, M_DEVBUF, sizeof *sc->sc_pd);
	return (1);
}

void
mfi_poll(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	struct mfi_frame_header *hdr;
	int to = 0;

	DNPRINTF(MFI_D_CMD, "%s: mfi_poll\n", DEVNAME(sc));

	hdr = &ccb->ccb_frame->mfr_header;
	hdr->mfh_cmd_status = 0xff;
	hdr->mfh_flags |= MFI_FRAME_DONT_POST_IN_REPLY_QUEUE;

	mfi_start(sc, ccb);

	for (;;) {
		delay(1000);

		bus_dmamap_sync(sc->sc_dmat, MFIMEM_MAP(sc->sc_frames),
		    ccb->ccb_pframe_offset, sc->sc_frames_size,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		if (hdr->mfh_cmd_status != 0xff)
			break;

		if (to++ > 5000) {
			printf("%s: timeout on ccb %d\n", DEVNAME(sc),
			    hdr->mfh_context);
			ccb->ccb_flags |= MFI_CCB_F_ERR;
			break;
		}

		bus_dmamap_sync(sc->sc_dmat, MFIMEM_MAP(sc->sc_frames),
		    ccb->ccb_pframe_offset, sc->sc_frames_size,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}

	if (ccb->ccb_len > 0) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (ccb->ccb_direction & MFI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

	ccb->ccb_done(sc, ccb);
}

void
mfi_exec(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	struct mutex m = MUTEX_INITIALIZER(IPL_BIO);

#ifdef DIAGNOSTIC
	if (ccb->ccb_cookie != NULL || ccb->ccb_done != NULL)
		panic("mfi_exec called with cookie or done set");
#endif

	ccb->ccb_cookie = &m;
	ccb->ccb_done = mfi_exec_done;

	mfi_start(sc, ccb);

	mtx_enter(&m);
	while (ccb->ccb_cookie != NULL)
		msleep(ccb, &m, PRIBIO, "mfiexec", 0);
	mtx_leave(&m);
}

void
mfi_exec_done(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	struct mutex *m = ccb->ccb_cookie;

	mtx_enter(m);
	ccb->ccb_cookie = NULL;
	wakeup_one(ccb);
	mtx_leave(m);
}

int
mfi_intr(void *arg)
{
	struct mfi_softc	*sc = arg;
	struct mfi_prod_cons	*pcq = MFIMEM_KVA(sc->sc_pcq);
	struct mfi_ccb		*ccb;
	uint32_t		producer, consumer, ctx;
	int			claimed = 0;

	if (!mfi_my_intr(sc))
		return (0);

	bus_dmamap_sync(sc->sc_dmat, MFIMEM_MAP(sc->sc_pcq),
	    0, MFIMEM_LEN(sc->sc_pcq),
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	producer = letoh32(pcq->mpc_producer);
	consumer = letoh32(pcq->mpc_consumer);

	DNPRINTF(MFI_D_INTR, "%s: mfi_intr %#x %#x\n", DEVNAME(sc), sc, pcq);

	while (consumer != producer) {
		DNPRINTF(MFI_D_INTR, "%s: mfi_intr pi %#x ci %#x\n",
		    DEVNAME(sc), producer, consumer);

		ctx = pcq->mpc_reply_q[consumer];
		pcq->mpc_reply_q[consumer] = MFI_INVALID_CTX;
		if (ctx == MFI_INVALID_CTX)
			printf("%s: invalid context, p: %d c: %d\n",
			    DEVNAME(sc), producer, consumer);
		else {
			/* XXX remove from queue and call scsi_done */
			ccb = &sc->sc_ccb[ctx];
			DNPRINTF(MFI_D_INTR, "%s: mfi_intr context %#x\n",
			    DEVNAME(sc), ctx);
			mfi_done(sc, ccb);

			claimed = 1;
		}
		consumer++;
		if (consumer == (sc->sc_max_cmds + 1))
			consumer = 0;
	}

	pcq->mpc_consumer = htole32(consumer);

	bus_dmamap_sync(sc->sc_dmat, MFIMEM_MAP(sc->sc_pcq),
	    0, MFIMEM_LEN(sc->sc_pcq),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	return (claimed);
}

int
mfi_scsi_io(struct mfi_softc *sc, struct mfi_ccb *ccb,
    struct scsi_xfer *xs, uint64_t blockno, uint32_t blockcnt)
{
	struct scsi_link	*link = xs->sc_link;
	struct mfi_io_frame	*io;

	DNPRINTF(MFI_D_CMD, "%s: mfi_scsi_io: %d\n",
	    DEVNAME((struct mfi_softc *)link->adapter_softc), link->target);

	if (!xs->data)
		return (1);

	io = &ccb->ccb_frame->mfr_io;
	if (xs->flags & SCSI_DATA_IN) {
		io->mif_header.mfh_cmd = MFI_CMD_LD_READ;
		ccb->ccb_direction = MFI_DATA_IN;
	} else {
		io->mif_header.mfh_cmd = MFI_CMD_LD_WRITE;
		ccb->ccb_direction = MFI_DATA_OUT;
	}
	io->mif_header.mfh_target_id = link->target;
	io->mif_header.mfh_timeout = 0;
	io->mif_header.mfh_flags = 0;
	io->mif_header.mfh_sense_len = MFI_SENSE_SIZE;
	io->mif_header.mfh_data_len = htole32(blockcnt);
	io->mif_lba = htole64(blockno);
	io->mif_sense_addr = htole64(ccb->ccb_psense);

	ccb->ccb_done = mfi_scsi_xs_done;
	ccb->ccb_cookie = xs;
	ccb->ccb_frame_size = MFI_IO_FRAME_SIZE;
	ccb->ccb_sgl = &io->mif_sgl;
	ccb->ccb_data = xs->data;
	ccb->ccb_len = xs->datalen;

	if (mfi_create_sgl(sc, ccb, (xs->flags & SCSI_NOSLEEP) ?
	    BUS_DMA_NOWAIT : BUS_DMA_WAITOK))
		return (1);

	return (0);
}

void
mfi_scsi_xs_done(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	struct scsi_xfer	*xs = ccb->ccb_cookie;
	struct mfi_frame_header	*hdr = &ccb->ccb_frame->mfr_header;

	DNPRINTF(MFI_D_INTR, "%s: mfi_scsi_xs_done %#x %#x\n",
	    DEVNAME(sc), ccb, ccb->ccb_frame);

	switch (hdr->mfh_cmd_status) {
	case MFI_STAT_OK:
		xs->resid = 0;
		break;

	case MFI_STAT_SCSI_DONE_WITH_ERROR:
		xs->error = XS_SENSE;
		xs->resid = 0;
		memset(&xs->sense, 0, sizeof(xs->sense));
		memcpy(&xs->sense, ccb->ccb_sense, sizeof(xs->sense));
		break;

	case MFI_STAT_DEVICE_NOT_FOUND:
		xs->error = XS_SELTIMEOUT;
		break;

	default:
		xs->error = XS_DRIVER_STUFFUP;
		DPRINTF(MFI_D_CMD,
		    "%s: mfi_scsi_xs_done stuffup %02x on %02x\n",
		    DEVNAME(sc), hdr->mfh_cmd_status, xs->cmd->opcode);

		if (hdr->mfh_scsi_status != 0) {
			DNPRINTF(MFI_D_INTR,
			    "%s: mfi_scsi_xs_done sense %#x %x %x\n",
			    DEVNAME(sc), hdr->mfh_scsi_status,
			    &xs->sense, ccb->ccb_sense);
			memset(&xs->sense, 0, sizeof(xs->sense));
			memcpy(&xs->sense, ccb->ccb_sense,
			    sizeof(struct scsi_sense_data));
			xs->error = XS_SENSE;
		}
		break;
	}

	KERNEL_LOCK();
	scsi_done(xs);
	KERNEL_UNLOCK();
}

int
mfi_scsi_ld(struct mfi_softc *sc, struct mfi_ccb *ccb, struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct mfi_pass_frame	*pf;

	DNPRINTF(MFI_D_CMD, "%s: mfi_scsi_ld: %d\n",
	    DEVNAME((struct mfi_softc *)link->adapter_softc), link->target);

	pf = &ccb->ccb_frame->mfr_pass;
	pf->mpf_header.mfh_cmd = MFI_CMD_LD_SCSI_IO;
	pf->mpf_header.mfh_target_id = link->target;
	pf->mpf_header.mfh_lun_id = 0;
	pf->mpf_header.mfh_cdb_len = xs->cmdlen;
	pf->mpf_header.mfh_timeout = 0;
	pf->mpf_header.mfh_data_len = htole32(xs->datalen); /* XXX */
	pf->mpf_header.mfh_sense_len = MFI_SENSE_SIZE;

	pf->mpf_sense_addr = htole64(ccb->ccb_psense);

	memset(pf->mpf_cdb, 0, 16);
	memcpy(pf->mpf_cdb, xs->cmd, xs->cmdlen);

	ccb->ccb_done = mfi_scsi_xs_done;
	ccb->ccb_cookie = xs;
	ccb->ccb_frame_size = MFI_PASS_FRAME_SIZE;
	ccb->ccb_sgl = &pf->mpf_sgl;

	if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT))
		ccb->ccb_direction = xs->flags & SCSI_DATA_IN ?
		    MFI_DATA_IN : MFI_DATA_OUT;
	else
		ccb->ccb_direction = MFI_DATA_NONE;

	if (xs->data) {
		ccb->ccb_data = xs->data;
		ccb->ccb_len = xs->datalen;

		if (mfi_create_sgl(sc, ccb, (xs->flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK))
			return (1);
	}

	return (0);
}

void
mfi_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct mfi_softc	*sc = link->adapter_softc;
	struct mfi_ccb		*ccb = xs->io;
	struct scsi_rw		*rw;
	struct scsi_rw_big	*rwb;
	struct scsi_rw_16	*rw16;
	uint64_t		blockno;
	uint32_t		blockcnt;
	uint8_t			target = link->target;
	union mfi_mbox		mbox;

	DNPRINTF(MFI_D_CMD, "%s: mfi_scsi_cmd opcode: %#x\n",
	    DEVNAME(sc), xs->cmd->opcode);

	KERNEL_UNLOCK();

	if (!sc->sc_ld[target].ld_present) {
		DNPRINTF(MFI_D_CMD, "%s: invalid target %d\n",
		    DEVNAME(sc), target);
		goto stuffup;
	}

	mfi_scrub_ccb(ccb);

	xs->error = XS_NOERROR;

	switch (xs->cmd->opcode) {
	/* IO path */
	case READ_BIG:
	case WRITE_BIG:
		rwb = (struct scsi_rw_big *)xs->cmd;
		blockno = (uint64_t)_4btol(rwb->addr);
		blockcnt = _2btol(rwb->length);
		if (mfi_scsi_io(sc, ccb, xs, blockno, blockcnt))
			goto stuffup;
		break;

	case READ_COMMAND:
	case WRITE_COMMAND:
		rw = (struct scsi_rw *)xs->cmd;
		blockno =
		    (uint64_t)(_3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff));
		blockcnt = rw->length ? rw->length : 0x100;
		if (mfi_scsi_io(sc, ccb, xs, blockno, blockcnt))
			goto stuffup;
		break;

	case READ_16:
	case WRITE_16:
		rw16 = (struct scsi_rw_16 *)xs->cmd;
		blockno = _8btol(rw16->addr);
		blockcnt = _4btol(rw16->length);
		if (mfi_scsi_io(sc, ccb, xs, blockno, blockcnt))
			goto stuffup;
		break;

	case SYNCHRONIZE_CACHE:
		mbox.b[0] = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;
		if (mfi_do_mgmt(sc, ccb, MR_DCMD_CTRL_CACHE_FLUSH,
		    MFI_DATA_NONE, 0, NULL, &mbox))
			goto stuffup;

		goto complete;
		/* NOTREACHED */

	default:
		if (mfi_scsi_ld(sc, ccb, xs))
			goto stuffup;
		break;
	}

	DNPRINTF(MFI_D_CMD, "%s: start io %d\n", DEVNAME(sc), target);

	if (xs->flags & SCSI_POLL)
		mfi_poll(sc, ccb);
	else 
		mfi_start(sc, ccb);

	KERNEL_LOCK();
	return;

stuffup:
	xs->error = XS_DRIVER_STUFFUP;
complete:
	KERNEL_LOCK();
	scsi_done(xs);
}

u_int
mfi_default_sgd_load(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	struct mfi_frame_header	*hdr = &ccb->ccb_frame->mfr_header;
	union mfi_sgl		*sgl = ccb->ccb_sgl;
	bus_dma_segment_t	*sgd = ccb->ccb_dmamap->dm_segs;
	int			 i;

	hdr->mfh_flags |= sc->sc_sgl_flags;

	for (i = 0; i < ccb->ccb_dmamap->dm_nsegs; i++) {
		if (sc->sc_64bit_dma) {
			sgl->sg64[i].addr = htole64(sgd[i].ds_addr);
			sgl->sg64[i].len = htole32(sgd[i].ds_len);
			DNPRINTF(MFI_D_DMA, "%s: addr: %#x  len: %#x\n",
			    DEVNAME(sc), sgl->sg64[i].addr, sgl->sg64[i].len);
		} else {
			sgl->sg32[i].addr = htole32(sgd[i].ds_addr);
			sgl->sg32[i].len = htole32(sgd[i].ds_len);
			DNPRINTF(MFI_D_DMA, "%s: addr: %#x  len: %#x\n",
			    DEVNAME(sc), sgl->sg32[i].addr, sgl->sg32[i].len);
		}
	}

	return (ccb->ccb_dmamap->dm_nsegs *
	    (sc->sc_64bit_dma ? sizeof(sgl->sg64) : sizeof(sgl->sg32)));
}

int
mfi_create_sgl(struct mfi_softc *sc, struct mfi_ccb *ccb, int flags)
{
	struct mfi_frame_header	*hdr = &ccb->ccb_frame->mfr_header;
	int			error;

	DNPRINTF(MFI_D_DMA, "%s: mfi_create_sgl %#x\n", DEVNAME(sc),
	    ccb->ccb_data);

	if (!ccb->ccb_data) {
		hdr->mfh_sg_count = 0;
		return (1);
	}

	error = bus_dmamap_load(sc->sc_dmat, ccb->ccb_dmamap,
	    ccb->ccb_data, ccb->ccb_len, NULL, flags);
	if (error) {
		if (error == EFBIG)
			printf("more than %d dma segs\n",
			    sc->sc_max_sgl);
		else
			printf("error %d loading dma map\n", error);
		return (1);
	}

	ccb->ccb_frame_size += mfi_sgd_load(sc, ccb);

	if (ccb->ccb_direction == MFI_DATA_IN) {
		hdr->mfh_flags |= MFI_FRAME_DIR_READ;
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
	} else {
		hdr->mfh_flags |= MFI_FRAME_DIR_WRITE;
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);
	}

	hdr->mfh_sg_count = ccb->ccb_dmamap->dm_nsegs;
	ccb->ccb_extra_frames = (ccb->ccb_frame_size - 1) / MFI_FRAME_SIZE;

	DNPRINTF(MFI_D_DMA, "%s: sg_count: %d  frame_size: %d  frames_size: %d"
	    "  dm_nsegs: %d  extra_frames: %d\n",
	    DEVNAME(sc),
	    hdr->mfh_sg_count,
	    ccb->ccb_frame_size,
	    sc->sc_frames_size,
	    ccb->ccb_dmamap->dm_nsegs,
	    ccb->ccb_extra_frames);

	return (0);
}

int
mfi_mgmt(struct mfi_softc *sc, uint32_t opc, uint32_t dir, uint32_t len,
    void *buf, const union mfi_mbox *mbox)
{
	struct mfi_ccb *ccb;
	int rv;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	mfi_scrub_ccb(ccb);
	rv = mfi_do_mgmt(sc, ccb, opc, dir, len, buf, mbox);
	scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}

int
mfi_do_mgmt(struct mfi_softc *sc, struct mfi_ccb *ccb, uint32_t opc,
    uint32_t dir, uint32_t len, void *buf, const union mfi_mbox *mbox)
{
	struct mfi_dcmd_frame *dcmd;
	uint8_t *dma_buf = NULL;
	int rv = EINVAL;

	DNPRINTF(MFI_D_MISC, "%s: mfi_do_mgmt %#x\n", DEVNAME(sc), opc);

	dma_buf = dma_alloc(len, cold ? PR_NOWAIT : PR_WAITOK);
	if (dma_buf == NULL)
		goto done;

	dcmd = &ccb->ccb_frame->mfr_dcmd;
	memset(&dcmd->mdf_mbox, 0, sizeof(dcmd->mdf_mbox));
	dcmd->mdf_header.mfh_cmd = MFI_CMD_DCMD;
	dcmd->mdf_header.mfh_timeout = 0;

	dcmd->mdf_opcode = opc;
	dcmd->mdf_header.mfh_data_len = 0;
	ccb->ccb_direction = dir;

	ccb->ccb_frame_size = MFI_DCMD_FRAME_SIZE;

	/* handle special opcodes */
	if (mbox != NULL)
		memcpy(&dcmd->mdf_mbox, mbox, sizeof(dcmd->mdf_mbox));

	if (dir != MFI_DATA_NONE) {
		if (dir == MFI_DATA_OUT)
			memcpy(dma_buf, buf, len);
		dcmd->mdf_header.mfh_data_len = len;
		ccb->ccb_data = dma_buf;
		ccb->ccb_len = len;
		ccb->ccb_sgl = &dcmd->mdf_sgl;

		if (mfi_create_sgl(sc, ccb, cold ? BUS_DMA_NOWAIT :
		    BUS_DMA_WAITOK)) {
			rv = EINVAL;
			goto done;
		}
	}

	if (cold) {
		ccb->ccb_done = mfi_empty_done;
		mfi_poll(sc, ccb);
	} else
		mfi_exec(sc, ccb);

	if (dcmd->mdf_header.mfh_cmd_status != MFI_STAT_OK) {
		if (dcmd->mdf_header.mfh_cmd_status == MFI_STAT_WRONG_STATE)
			rv = ENXIO;
		else
			rv = EIO;
		goto done;
	}

	if (dir == MFI_DATA_IN)
		memcpy(buf, dma_buf, len);

	rv = 0;
done:
	if (dma_buf)
		dma_free(dma_buf, len);

	return (rv);
}

int
mfi_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag)
{
	struct mfi_softc	*sc = (struct mfi_softc *)link->adapter_softc;

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_scsi_ioctl\n", DEVNAME(sc));

	switch (cmd) {
	case DIOCGCACHE:
	case DIOCSCACHE:
		return (mfi_ioctl_cache(link, cmd, (struct dk_cache *)addr));
		break;

	default:
		if (sc->sc_ioctl)
			return (sc->sc_ioctl(link->adapter_softc, cmd, addr));
		break;
	}

	return (ENOTTY);
}

int
mfi_ioctl_cache(struct scsi_link *link, u_long cmd,  struct dk_cache *dc)
{
	struct mfi_softc	*sc = (struct mfi_softc *)link->adapter_softc;
	int			 rv, wrenable, rdenable;
	struct mfi_ld_prop	 ldp;
	union mfi_mbox		 mbox;

	if (mfi_get_info(sc)) {
		rv = EIO;
		goto done;
	}

	if (!sc->sc_ld[link->target].ld_present) {
		rv = EIO;
		goto done;
	}

	memset(&mbox, 0, sizeof(mbox));
	mbox.b[0] = link->target;
	if ((rv = mfi_mgmt(sc, MR_DCMD_LD_GET_PROPERTIES, MFI_DATA_IN,
	    sizeof(ldp), &ldp, &mbox)) != 0)
		goto done;

	if (sc->sc_info.mci_memory_size > 0) {
		wrenable = ISSET(ldp.mlp_cur_cache_policy,
		    MR_LD_CACHE_ALLOW_WRITE_CACHE)? 1 : 0;
		rdenable = ISSET(ldp.mlp_cur_cache_policy,
		    MR_LD_CACHE_ALLOW_READ_CACHE)? 1 : 0;
	} else {
		wrenable = ISSET(ldp.mlp_diskcache_policy,
		    MR_LD_DISK_CACHE_ENABLE)? 1 : 0;
		rdenable = 0;
	}

	if (cmd == DIOCGCACHE) {
		dc->wrcache = wrenable;
		dc->rdcache = rdenable;
		goto done;
	} /* else DIOCSCACHE */

	if (((dc->wrcache) ? 1 : 0) == wrenable &&
	    ((dc->rdcache) ? 1 : 0) == rdenable)
		goto done;

	memset(&mbox, 0, sizeof(mbox));
	mbox.b[0] = ldp.mlp_ld.mld_target;
	mbox.b[1] = ldp.mlp_ld.mld_res;
	mbox.s[1] = ldp.mlp_ld.mld_seq;

	if (sc->sc_info.mci_memory_size > 0) {
		if (dc->rdcache)
			SET(ldp.mlp_cur_cache_policy,
			    MR_LD_CACHE_ALLOW_READ_CACHE);
		else
			CLR(ldp.mlp_cur_cache_policy,
			    MR_LD_CACHE_ALLOW_READ_CACHE);
		if (dc->wrcache)
			SET(ldp.mlp_cur_cache_policy,
			    MR_LD_CACHE_ALLOW_WRITE_CACHE);
		else
			CLR(ldp.mlp_cur_cache_policy,
			    MR_LD_CACHE_ALLOW_WRITE_CACHE);
	} else {
		if (dc->rdcache) {
			rv = EOPNOTSUPP;
			goto done;
		}
		if (dc->wrcache)
			ldp.mlp_diskcache_policy = MR_LD_DISK_CACHE_ENABLE;
		else
			ldp.mlp_diskcache_policy = MR_LD_DISK_CACHE_DISABLE;
	}

	if ((rv = mfi_mgmt(sc, MR_DCMD_LD_SET_PROPERTIES, MFI_DATA_OUT,
	    sizeof(ldp), &ldp, &mbox)) != 0)
		goto done;
done:
	return (rv);
}

#if NBIO > 0
int
mfi_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct mfi_softc	*sc = (struct mfi_softc *)dev;
	int error = 0;

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl ", DEVNAME(sc));

	rw_enter_write(&sc->sc_lock);

	switch (cmd) {
	case BIOCINQ:
		DNPRINTF(MFI_D_IOCTL, "inq\n");
		error = mfi_ioctl_inq(sc, (struct bioc_inq *)addr);
		break;

	case BIOCVOL:
		DNPRINTF(MFI_D_IOCTL, "vol\n");
		error = mfi_ioctl_vol(sc, (struct bioc_vol *)addr);
		break;

	case BIOCDISK:
		DNPRINTF(MFI_D_IOCTL, "disk\n");
		error = mfi_ioctl_disk(sc, (struct bioc_disk *)addr);
		break;

	case BIOCALARM:
		DNPRINTF(MFI_D_IOCTL, "alarm\n");
		error = mfi_ioctl_alarm(sc, (struct bioc_alarm *)addr);
		break;

	case BIOCBLINK:
		DNPRINTF(MFI_D_IOCTL, "blink\n");
		error = mfi_ioctl_blink(sc, (struct bioc_blink *)addr);
		break;

	case BIOCSETSTATE:
		DNPRINTF(MFI_D_IOCTL, "setstate\n");
		error = mfi_ioctl_setstate(sc, (struct bioc_setstate *)addr);
		break;

	case BIOCPATROL:
		DNPRINTF(MFI_D_IOCTL, "patrol\n");
		error = mfi_ioctl_patrol(sc, (struct bioc_patrol *)addr);
		break;

	default:
		DNPRINTF(MFI_D_IOCTL, " invalid ioctl\n");
		error = EINVAL;
	}

	rw_exit_write(&sc->sc_lock);

	return (error);
}

int
mfi_bio_getitall(struct mfi_softc *sc)
{
	int			i, d, size, rv = EINVAL;
	union mfi_mbox		mbox;
	struct mfi_conf		*cfg = NULL;
	struct mfi_ld_details	*ld_det = NULL;

	/* get info */
	if (mfi_get_info(sc)) {
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_get_info failed\n",
		    DEVNAME(sc));
		goto done;
	}

	/* send single element command to retrieve size for full structure */
	cfg = malloc(sizeof *cfg, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (cfg == NULL)
		goto done;
	if (mfi_mgmt(sc, MR_DCMD_CONF_GET, MFI_DATA_IN, sizeof *cfg, cfg,
	    NULL)) {
		free(cfg, M_DEVBUF, sizeof *cfg);
		goto done;
	}

	size = cfg->mfc_size;
	free(cfg, M_DEVBUF, sizeof *cfg);

	/* memory for read config */
	cfg = malloc(size, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (cfg == NULL)
		goto done;
	if (mfi_mgmt(sc, MR_DCMD_CONF_GET, MFI_DATA_IN, size, cfg, NULL)) {
		free(cfg, M_DEVBUF, size);
		goto done;
	}

	/* replace current pointer with new one */
	if (sc->sc_cfg)
		free(sc->sc_cfg, M_DEVBUF, 0);
	sc->sc_cfg = cfg;

	/* get all ld info */
	if (mfi_mgmt(sc, MR_DCMD_LD_GET_LIST, MFI_DATA_IN,
	    sizeof(sc->sc_ld_list), &sc->sc_ld_list, NULL))
		goto done;

	/* get memory for all ld structures */
	size = cfg->mfc_no_ld * sizeof(struct mfi_ld_details);
	if (sc->sc_ld_sz != size) {
		if (sc->sc_ld_details)
			free(sc->sc_ld_details, M_DEVBUF, 0);

		ld_det = malloc(size, M_DEVBUF, M_NOWAIT | M_ZERO);
		if (ld_det == NULL)
			goto done;
		sc->sc_ld_sz = size;
		sc->sc_ld_details = ld_det;
	}

	/* find used physical disks */
	size = sizeof(struct mfi_ld_details);
	for (i = 0, d = 0; i < cfg->mfc_no_ld; i++) {
		memset(&mbox, 0, sizeof(mbox));
		mbox.b[0] = sc->sc_ld_list.mll_list[i].mll_ld.mld_target;
		if (mfi_mgmt(sc, MR_DCMD_LD_GET_INFO, MFI_DATA_IN, size,
		    &sc->sc_ld_details[i], &mbox))
			goto done;

		d += sc->sc_ld_details[i].mld_cfg.mlc_parm.mpa_no_drv_per_span *
		    sc->sc_ld_details[i].mld_cfg.mlc_parm.mpa_span_depth;
	}
	sc->sc_no_pd = d;

	rv = 0;
done:
	return (rv);
}

int
mfi_ioctl_inq(struct mfi_softc *sc, struct bioc_inq *bi)
{
	int			rv = EINVAL;
	struct mfi_conf		*cfg = NULL;

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_inq\n", DEVNAME(sc));

	if (mfi_bio_getitall(sc)) {
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_bio_getitall failed\n",
		    DEVNAME(sc));
		goto done;
	}

	/* count unused disks as volumes */
	if (sc->sc_cfg == NULL)
		goto done;
	cfg = sc->sc_cfg;

	bi->bi_nodisk = sc->sc_info.mci_pd_disks_present;
	bi->bi_novol = cfg->mfc_no_ld + cfg->mfc_no_hs;
#if notyet
	bi->bi_novol = cfg->mfc_no_ld + cfg->mfc_no_hs +
	    (bi->bi_nodisk - sc->sc_no_pd);
#endif
	/* tell bio who we are */
	strlcpy(bi->bi_dev, DEVNAME(sc), sizeof(bi->bi_dev));

	rv = 0;
done:
	return (rv);
}

int
mfi_ioctl_vol(struct mfi_softc *sc, struct bioc_vol *bv)
{
	int			i, per, rv = EINVAL;
	struct scsi_link	*link;
	struct device		*dev;

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_vol %#x\n",
	    DEVNAME(sc), bv->bv_volid);

	/* we really could skip and expect that inq took care of it */
	if (mfi_bio_getitall(sc)) {
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_bio_getitall failed\n",
		    DEVNAME(sc));
		goto done;
	}

	if (bv->bv_volid >= sc->sc_ld_list.mll_no_ld) {
		/* go do hotspares & unused disks */
		rv = mfi_bio_hs(sc, bv->bv_volid, MFI_MGMT_VD, bv);
		goto done;
	}

	i = bv->bv_volid;
	link = scsi_get_link(sc->sc_scsibus, i, 0);
	if (link != NULL && link->device_softc != NULL) {
		dev = link->device_softc;
		strlcpy(bv->bv_dev, dev->dv_xname, sizeof(bv->bv_dev));
	}

	switch(sc->sc_ld_list.mll_list[i].mll_state) {
	case MFI_LD_OFFLINE:
		bv->bv_status = BIOC_SVOFFLINE;
		break;

	case MFI_LD_PART_DEGRADED:
	case MFI_LD_DEGRADED:
		bv->bv_status = BIOC_SVDEGRADED;
		break;

	case MFI_LD_ONLINE:
		bv->bv_status = BIOC_SVONLINE;
		break;

	default:
		bv->bv_status = BIOC_SVINVALID;
		DNPRINTF(MFI_D_IOCTL, "%s: invalid logical disk state %#x\n",
		    DEVNAME(sc),
		    sc->sc_ld_list.mll_list[i].mll_state);
	}

	/* additional status can modify MFI status */
	switch (sc->sc_ld_details[i].mld_progress.mlp_in_prog) {
	case MFI_LD_PROG_CC:
	case MFI_LD_PROG_BGI:
		bv->bv_status = BIOC_SVSCRUB;
		per = (int)sc->sc_ld_details[i].mld_progress.mlp_cc.mp_progress;
		bv->bv_percent = (per * 100) / 0xffff;
		bv->bv_seconds =
		    sc->sc_ld_details[i].mld_progress.mlp_cc.mp_elapsed_seconds;
		break;

	case MFI_LD_PROG_FGI:
	case MFI_LD_PROG_RECONSTRUCT:
		/* nothing yet */
		break;
	}

	if (sc->sc_ld_details[i].mld_cfg.mlc_prop.mlp_cur_cache_policy & 0x01)
		bv->bv_cache = BIOC_CVWRITEBACK;
	else
		bv->bv_cache = BIOC_CVWRITETHROUGH;

	/*
	 * The RAID levels are determined per the SNIA DDF spec, this is only
	 * a subset that is valid for the MFI controller.
	 */
	bv->bv_level = sc->sc_ld_details[i].mld_cfg.mlc_parm.mpa_pri_raid;
	if (sc->sc_ld_details[i].mld_cfg.mlc_parm.mpa_sec_raid ==
	    MFI_DDF_SRL_SPANNED)
		bv->bv_level *= 10;

	bv->bv_nodisk = sc->sc_ld_details[i].mld_cfg.mlc_parm.mpa_no_drv_per_span *
	    sc->sc_ld_details[i].mld_cfg.mlc_parm.mpa_span_depth;

	bv->bv_size = sc->sc_ld_details[i].mld_size * 512; /* bytes per block */

	rv = 0;
done:
	return (rv);
}

int
mfi_ioctl_disk(struct mfi_softc *sc, struct bioc_disk *bd)
{
	struct mfi_conf		*cfg;
	struct mfi_array	*ar;
	struct mfi_ld_cfg	*ld;
	struct mfi_pd_details	*pd;
	struct mfi_pd_progress	*mfp;
	struct mfi_progress	*mp;
	struct scsi_inquiry_data *inqbuf;
	char			vend[8+16+4+1], *vendp;
	int			rv = EINVAL;
	int			arr, vol, disk, span;
	union mfi_mbox		mbox;

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_disk %#x\n",
	    DEVNAME(sc), bd->bd_diskid);

	/* we really could skip and expect that inq took care of it */
	if (mfi_bio_getitall(sc)) {
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_bio_getitall failed\n",
		    DEVNAME(sc));
		return (rv);
	}
	cfg = sc->sc_cfg;

	pd = malloc(sizeof *pd, M_DEVBUF, M_WAITOK);

	ar = cfg->mfc_array;
	vol = bd->bd_volid;
	if (vol >= cfg->mfc_no_ld) {
		/* do hotspares */
		rv = mfi_bio_hs(sc, bd->bd_volid, MFI_MGMT_SD, bd);
		goto freeme;
	}

	/* calculate offset to ld structure */
	ld = (struct mfi_ld_cfg *)(
	    ((uint8_t *)cfg) + offsetof(struct mfi_conf, mfc_array) +
	    cfg->mfc_array_size * cfg->mfc_no_array);

	/* use span 0 only when raid group is not spanned */
	if (ld[vol].mlc_parm.mpa_span_depth > 1)
		span = bd->bd_diskid / ld[vol].mlc_parm.mpa_no_drv_per_span;
	else
		span = 0;
	arr = ld[vol].mlc_span[span].mls_index;

	/* offset disk into pd list */
	disk = bd->bd_diskid % ld[vol].mlc_parm.mpa_no_drv_per_span;
	bd->bd_target = ar[arr].pd[disk].mar_enc_slot;

	/* get status */
	switch (ar[arr].pd[disk].mar_pd_state){
	case MFI_PD_UNCONFIG_GOOD:
	case MFI_PD_FAILED:
		bd->bd_status = BIOC_SDFAILED;
		break;

	case MFI_PD_HOTSPARE: /* XXX dedicated hotspare part of array? */
		bd->bd_status = BIOC_SDHOTSPARE;
		break;

	case MFI_PD_OFFLINE:
		bd->bd_status = BIOC_SDOFFLINE;
		break;

	case MFI_PD_REBUILD:
		bd->bd_status = BIOC_SDREBUILD;
		break;

	case MFI_PD_ONLINE:
		bd->bd_status = BIOC_SDONLINE;
		break;

	case MFI_PD_UNCONFIG_BAD: /* XXX define new state in bio */
	default:
		bd->bd_status = BIOC_SDINVALID;
		break;
	}

	/* get the remaining fields */
	memset(&mbox, 0, sizeof(mbox));
	mbox.s[0] = ar[arr].pd[disk].mar_pd.mfp_id;
	if (mfi_mgmt(sc, MR_DCMD_PD_GET_INFO, MFI_DATA_IN,
	    sizeof *pd, pd, &mbox)) {
		/* disk is missing but succeed command */
		rv = 0;
		goto freeme;
	}

	bd->bd_size = pd->mpd_size * 512; /* bytes per block */

	/* if pd->mpd_enc_idx is 0 then it is not in an enclosure */
	bd->bd_channel = pd->mpd_enc_idx;

	inqbuf = (struct scsi_inquiry_data *)&pd->mpd_inq_data;
	vendp = inqbuf->vendor;
	memcpy(vend, vendp, sizeof vend - 1);
	vend[sizeof vend - 1] = '\0';
	strlcpy(bd->bd_vendor, vend, sizeof(bd->bd_vendor));

	/* XXX find a way to retrieve serial nr from drive */
	/* XXX find a way to get bd_procdev */

	mfp = &pd->mpd_progress;
	if (mfp->mfp_in_prog & MFI_PD_PROG_PR) {
		mp = &mfp->mfp_patrol_read;
		bd->bd_patrol.bdp_percent = (mp->mp_progress * 100) / 0xffff;
		bd->bd_patrol.bdp_seconds = mp->mp_elapsed_seconds;
	}

	rv = 0;
freeme:
	free(pd, M_DEVBUF, sizeof *pd);

	return (rv);
}

int
mfi_ioctl_alarm(struct mfi_softc *sc, struct bioc_alarm *ba)
{
	uint32_t		opc, dir = MFI_DATA_NONE;
	int			rv = 0;
	int8_t			ret;

	switch(ba->ba_opcode) {
	case BIOC_SADISABLE:
		opc = MR_DCMD_SPEAKER_DISABLE;
		break;

	case BIOC_SAENABLE:
		opc = MR_DCMD_SPEAKER_ENABLE;
		break;

	case BIOC_SASILENCE:
		opc = MR_DCMD_SPEAKER_SILENCE;
		break;

	case BIOC_GASTATUS:
		opc = MR_DCMD_SPEAKER_GET;
		dir = MFI_DATA_IN;
		break;

	case BIOC_SATEST:
		opc = MR_DCMD_SPEAKER_TEST;
		break;

	default:
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_alarm biocalarm invalid "
		    "opcode %x\n", DEVNAME(sc), ba->ba_opcode);
		return (EINVAL);
	}

	if (mfi_mgmt(sc, opc, dir, sizeof(ret), &ret, NULL))
		rv = EINVAL;
	else
		if (ba->ba_opcode == BIOC_GASTATUS)
			ba->ba_status = ret;
		else
			ba->ba_status = 0;

	return (rv);
}

int
mfi_ioctl_blink(struct mfi_softc *sc, struct bioc_blink *bb)
{
	int			i, found, rv = EINVAL;
	union mfi_mbox		mbox;
	uint32_t		cmd;
	struct mfi_pd_list	*pd;

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_blink %x\n", DEVNAME(sc),
	    bb->bb_status);

	/* channel 0 means not in an enclosure so can't be blinked */
	if (bb->bb_channel == 0)
		return (EINVAL);

	pd = malloc(sizeof(*pd), M_DEVBUF, M_WAITOK);

	if (mfi_mgmt(sc, MR_DCMD_PD_GET_LIST, MFI_DATA_IN,
	    sizeof(*pd), pd, NULL))
		goto done;

	for (i = 0, found = 0; i < pd->mpl_no_pd; i++)
		if (bb->bb_channel == pd->mpl_address[i].mpa_enc_index &&
		    bb->bb_target == pd->mpl_address[i].mpa_enc_slot) {
			found = 1;
			break;
		}

	if (!found)
		goto done;

	memset(&mbox, 0, sizeof(mbox));
	mbox.s[0] = pd->mpl_address[i].mpa_pd_id;

	switch (bb->bb_status) {
	case BIOC_SBUNBLINK:
		cmd = MR_DCMD_PD_UNBLINK;
		break;

	case BIOC_SBBLINK:
		cmd = MR_DCMD_PD_BLINK;
		break;

	case BIOC_SBALARM:
	default:
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_blink biocblink invalid "
		    "opcode %x\n", DEVNAME(sc), bb->bb_status);
		goto done;
	}


	if (mfi_mgmt(sc, cmd, MFI_DATA_NONE, 0, NULL, &mbox))
		goto done;

	rv = 0;
done:
	free(pd, M_DEVBUF, sizeof *pd);
	return (rv);
}

int
mfi_ioctl_setstate(struct mfi_softc *sc, struct bioc_setstate *bs)
{
	struct mfi_pd_list	*pd;
	struct mfi_pd_details	*info;
	int			i, found, rv = EINVAL;
	union mfi_mbox		mbox;

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_setstate %x\n", DEVNAME(sc),
	    bs->bs_status);

	pd = malloc(sizeof(*pd), M_DEVBUF, M_WAITOK);
	info = malloc(sizeof *info, M_DEVBUF, M_WAITOK);

	if (mfi_mgmt(sc, MR_DCMD_PD_GET_LIST, MFI_DATA_IN,
	    sizeof(*pd), pd, NULL))
		goto done;

	for (i = 0, found = 0; i < pd->mpl_no_pd; i++)
		if (bs->bs_channel == pd->mpl_address[i].mpa_enc_index &&
		    bs->bs_target == pd->mpl_address[i].mpa_enc_slot) {
			found = 1;
			break;
		}

	if (!found)
		goto done;

	memset(&mbox, 0, sizeof(mbox));
	mbox.s[0] = pd->mpl_address[i].mpa_pd_id;

	if (mfi_mgmt(sc, MR_DCMD_PD_GET_INFO, MFI_DATA_IN,
	    sizeof *info, info, &mbox))
		goto done;

	mbox.s[0] = pd->mpl_address[i].mpa_pd_id;
	mbox.s[1] = info->mpd_pd.mfp_seq;

	switch (bs->bs_status) {
	case BIOC_SSONLINE:
		mbox.b[4] = MFI_PD_ONLINE;
		break;

	case BIOC_SSOFFLINE:
		mbox.b[4] = MFI_PD_OFFLINE;
		break;

	case BIOC_SSHOTSPARE:
		mbox.b[4] = MFI_PD_HOTSPARE;
		break;

	case BIOC_SSREBUILD:
		mbox.b[4] = MFI_PD_REBUILD;
		break;

	default:
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_setstate invalid "
		    "opcode %x\n", DEVNAME(sc), bs->bs_status);
		goto done;
	}


	if ((rv = mfi_mgmt(sc, MR_DCMD_PD_SET_STATE, MFI_DATA_NONE, 0, NULL,
	    &mbox)))
		goto done;

	rv = 0;
done:
	free(pd, M_DEVBUF, sizeof *pd);
	free(info, M_DEVBUF, sizeof *info);
	return (rv);
}

int
mfi_ioctl_patrol(struct mfi_softc *sc, struct bioc_patrol *bp)
{
	uint32_t		opc, dir = MFI_DATA_NONE;
	int			rv = 0;
	struct mfi_pr_properties prop;
	struct mfi_pr_status	status;
	uint32_t		time, exec_freq;

	switch (bp->bp_opcode) {
	case BIOC_SPSTOP:
	case BIOC_SPSTART:
		if (bp->bp_opcode == BIOC_SPSTART)
			opc = MR_DCMD_PR_START;
		else
			opc = MR_DCMD_PR_STOP;
		dir = MFI_DATA_IN;
		if (mfi_mgmt(sc, opc, dir, 0, NULL, NULL))
			return (EINVAL);
		break;

	case BIOC_SPMANUAL:
	case BIOC_SPDISABLE:
	case BIOC_SPAUTO:
		/* Get device's time. */
		opc = MR_DCMD_TIME_SECS_GET;
		dir = MFI_DATA_IN;
		if (mfi_mgmt(sc, opc, dir, sizeof(time), &time, NULL))
			return (EINVAL);

		opc = MR_DCMD_PR_GET_PROPERTIES;
		dir = MFI_DATA_IN;
		if (mfi_mgmt(sc, opc, dir, sizeof(prop), &prop, NULL))
			return (EINVAL);

		switch (bp->bp_opcode) {
		case BIOC_SPMANUAL:
			prop.op_mode = MFI_PR_OPMODE_MANUAL;
			break;
		case BIOC_SPDISABLE:
			prop.op_mode = MFI_PR_OPMODE_DISABLED;
			break;
		case BIOC_SPAUTO:
			if (bp->bp_autoival != 0) {
				if (bp->bp_autoival == -1)
					/* continuously */
					exec_freq = 0xffffffffU;
				else if (bp->bp_autoival > 0)
					exec_freq = bp->bp_autoival;
				else
					return (EINVAL);
				prop.exec_freq = exec_freq;
			}
			if (bp->bp_autonext != 0) {
				if (bp->bp_autonext < 0)
					return (EINVAL);
				else
					prop.next_exec = time + bp->bp_autonext;
			}
			prop.op_mode = MFI_PR_OPMODE_AUTO;
			break;
		}

		opc = MR_DCMD_PR_SET_PROPERTIES;
		dir = MFI_DATA_OUT;
		if (mfi_mgmt(sc, opc, dir, sizeof(prop), &prop, NULL))
			return (EINVAL);

		break;

	case BIOC_GPSTATUS:
		opc = MR_DCMD_PR_GET_PROPERTIES;
		dir = MFI_DATA_IN;
		if (mfi_mgmt(sc, opc, dir, sizeof(prop), &prop, NULL))
			return (EINVAL);

		opc = MR_DCMD_PR_GET_STATUS;
		dir = MFI_DATA_IN;
		if (mfi_mgmt(sc, opc, dir, sizeof(status), &status, NULL))
			return (EINVAL);

		/* Get device's time. */
		opc = MR_DCMD_TIME_SECS_GET;
		dir = MFI_DATA_IN;
		if (mfi_mgmt(sc, opc, dir, sizeof(time), &time, NULL))
			return (EINVAL);

		switch (prop.op_mode) {
		case MFI_PR_OPMODE_AUTO:
			bp->bp_mode = BIOC_SPMAUTO;
			bp->bp_autoival = prop.exec_freq;
			bp->bp_autonext = prop.next_exec;
			bp->bp_autonow = time;
			break;
		case MFI_PR_OPMODE_MANUAL:
			bp->bp_mode = BIOC_SPMMANUAL;
			break;
		case MFI_PR_OPMODE_DISABLED:
			bp->bp_mode = BIOC_SPMDISABLED;
			break;
		default:
			printf("%s: unknown patrol mode %d\n",
			    DEVNAME(sc), prop.op_mode);
			break;
		}

		switch (status.state) {
		case MFI_PR_STATE_STOPPED:
			bp->bp_status = BIOC_SPSSTOPPED;
			break;
		case MFI_PR_STATE_READY:
			bp->bp_status = BIOC_SPSREADY;
			break;
		case MFI_PR_STATE_ACTIVE:
			bp->bp_status = BIOC_SPSACTIVE;
			break;
		case MFI_PR_STATE_ABORTED:
			bp->bp_status = BIOC_SPSABORTED;
			break;
		default:
			printf("%s: unknown patrol state %d\n",
			    DEVNAME(sc), status.state);
			break;
		}

		break;

	default:
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_patrol biocpatrol invalid "
		    "opcode %x\n", DEVNAME(sc), bp->bp_opcode);
		return (EINVAL);
	}

	return (rv);
}

int
mfi_bio_hs(struct mfi_softc *sc, int volid, int type, void *bio_hs)
{
	struct mfi_conf		*cfg;
	struct mfi_hotspare	*hs;
	struct mfi_pd_details	*pd;
	struct bioc_disk	*sdhs;
	struct bioc_vol		*vdhs;
	struct scsi_inquiry_data *inqbuf;
	char			vend[8+16+4+1], *vendp;
	int			i, rv = EINVAL;
	uint32_t		size;
	union mfi_mbox		mbox;

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_vol_hs %d\n", DEVNAME(sc), volid);

	if (!bio_hs)
		return (EINVAL);

	pd = malloc(sizeof *pd, M_DEVBUF, M_WAITOK);

	/* send single element command to retrieve size for full structure */
	cfg = malloc(sizeof *cfg, M_DEVBUF, M_WAITOK);
	if (mfi_mgmt(sc, MR_DCMD_CONF_GET, MFI_DATA_IN, sizeof *cfg, cfg, NULL))
		goto freeme;

	size = cfg->mfc_size;
	free(cfg, M_DEVBUF, sizeof *cfg);

	/* memory for read config */
	cfg = malloc(size, M_DEVBUF, M_WAITOK|M_ZERO);
	if (mfi_mgmt(sc, MR_DCMD_CONF_GET, MFI_DATA_IN, size, cfg, NULL))
		goto freeme;

	/* calculate offset to hs structure */
	hs = (struct mfi_hotspare *)(
	    ((uint8_t *)cfg) + offsetof(struct mfi_conf, mfc_array) +
	    cfg->mfc_array_size * cfg->mfc_no_array +
	    cfg->mfc_ld_size * cfg->mfc_no_ld);

	if (volid < cfg->mfc_no_ld)
		goto freeme; /* not a hotspare */

	if (volid > (cfg->mfc_no_ld + cfg->mfc_no_hs))
		goto freeme; /* not a hotspare */

	/* offset into hotspare structure */
	i = volid - cfg->mfc_no_ld;

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_vol_hs i %d volid %d no_ld %d no_hs %d "
	    "hs %p cfg %p id %02x\n", DEVNAME(sc), i, volid, cfg->mfc_no_ld,
	    cfg->mfc_no_hs, hs, cfg, hs[i].mhs_pd.mfp_id);

	/* get pd fields */
	memset(&mbox, 0, sizeof(mbox));
	mbox.s[0] = hs[i].mhs_pd.mfp_id;
	if (mfi_mgmt(sc, MR_DCMD_PD_GET_INFO, MFI_DATA_IN,
	    sizeof *pd, pd, &mbox)) {
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_vol_hs illegal PD\n",
		    DEVNAME(sc));
		goto freeme;
	}

	switch (type) {
	case MFI_MGMT_VD:
		vdhs = bio_hs;
		vdhs->bv_status = BIOC_SVONLINE;
		vdhs->bv_size = pd->mpd_size / 2 * 1024; /* XXX why? */
		vdhs->bv_level = -1; /* hotspare */
		vdhs->bv_nodisk = 1;
		break;

	case MFI_MGMT_SD:
		sdhs = bio_hs;
		sdhs->bd_status = BIOC_SDHOTSPARE;
		sdhs->bd_size = pd->mpd_size / 2 * 1024; /* XXX why? */
		sdhs->bd_channel = pd->mpd_enc_idx;
		sdhs->bd_target = pd->mpd_enc_slot;
		inqbuf = (struct scsi_inquiry_data *)&pd->mpd_inq_data;
		vendp = inqbuf->vendor;
		memcpy(vend, vendp, sizeof vend - 1);
		vend[sizeof vend - 1] = '\0';
		strlcpy(sdhs->bd_vendor, vend, sizeof(sdhs->bd_vendor));
		break;

	default:
		goto freeme;
	}

	DNPRINTF(MFI_D_IOCTL, "%s: mfi_vol_hs 6\n", DEVNAME(sc));
	rv = 0;
freeme:
	free(pd, M_DEVBUF, sizeof *pd);
	free(cfg, M_DEVBUF, 0);

	return (rv);
}

#ifndef SMALL_KERNEL

static const char *mfi_bbu_indicators[] = {
	"pack missing",
	"voltage low",
	"temp high",
	"charge active",
	"discharge active",
	"learn cycle req'd",
	"learn cycle active",
	"learn cycle failed",
	"learn cycle timeout",
	"I2C errors",
	"replace pack",
	"low capacity",
	"periodic learn req'd"
};

#define MFI_BBU_SENSORS 4

int
mfi_bbu(struct mfi_softc *sc)
{
	struct mfi_bbu_status bbu;
	u_int32_t status;
	u_int32_t mask;
	u_int32_t soh_bad;
	int i;

	if (mfi_mgmt(sc, MR_DCMD_BBU_GET_STATUS, MFI_DATA_IN,
	    sizeof(bbu), &bbu, NULL) != 0) {
		for (i = 0; i < MFI_BBU_SENSORS; i++) {
			sc->sc_bbu[i].value = 0;
			sc->sc_bbu[i].status = SENSOR_S_UNKNOWN;
		}
		for (i = 0; i < nitems(mfi_bbu_indicators); i++) {
			sc->sc_bbu_status[i].value = 0;
			sc->sc_bbu_status[i].status = SENSOR_S_UNKNOWN;
		}
		return (-1);
	}

	switch (bbu.battery_type) {
	case MFI_BBU_TYPE_IBBU:
		mask = MFI_BBU_STATE_BAD_IBBU;
		soh_bad = 0;
		break;
	case MFI_BBU_TYPE_BBU:
		mask = MFI_BBU_STATE_BAD_BBU;
		soh_bad = (bbu.detail.bbu.is_SOH_good == 0);
		break;

	case MFI_BBU_TYPE_NONE:
	default:
		sc->sc_bbu[0].value = 0;
		sc->sc_bbu[0].status = SENSOR_S_CRIT;
		for (i = 1; i < MFI_BBU_SENSORS; i++) {
			sc->sc_bbu[i].value = 0;
			sc->sc_bbu[i].status = SENSOR_S_UNKNOWN;
		}
		for (i = 0; i < nitems(mfi_bbu_indicators); i++) {
			sc->sc_bbu_status[i].value = 0;
			sc->sc_bbu_status[i].status = SENSOR_S_UNKNOWN;
		}
		return (0);
	}

	status = letoh32(bbu.fw_status);

	sc->sc_bbu[0].value = ((status & mask) || soh_bad) ? 0 : 1;
	sc->sc_bbu[0].status = ((status & mask) || soh_bad) ? SENSOR_S_CRIT :
	    SENSOR_S_OK;

	sc->sc_bbu[1].value = letoh16(bbu.voltage) * 1000;
	sc->sc_bbu[2].value = (int16_t)letoh16(bbu.current) * 1000;
	sc->sc_bbu[3].value = letoh16(bbu.temperature) * 1000000 + 273150000;
	for (i = 1; i < MFI_BBU_SENSORS; i++)
		sc->sc_bbu[i].status = SENSOR_S_UNSPEC;

	for (i = 0; i < nitems(mfi_bbu_indicators); i++) {
		sc->sc_bbu_status[i].value = (status & (1 << i)) ? 1 : 0;
		sc->sc_bbu_status[i].status = SENSOR_S_UNSPEC;
	}

	return (0);
}

int
mfi_create_sensors(struct mfi_softc *sc)
{
	struct device		*dev;
	struct scsi_link	*link;
	int			i;

	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));

	if (ISSET(letoh32(sc->sc_info.mci_adapter_ops ), MFI_INFO_AOPS_BBU)) {
		sc->sc_bbu = mallocarray(4, sizeof(*sc->sc_bbu),
		    M_DEVBUF, M_WAITOK | M_ZERO);

		sc->sc_bbu[0].type = SENSOR_INDICATOR;
		sc->sc_bbu[0].status = SENSOR_S_UNKNOWN;
		strlcpy(sc->sc_bbu[0].desc, "bbu ok",
		    sizeof(sc->sc_bbu[0].desc));
		sensor_attach(&sc->sc_sensordev, &sc->sc_bbu[0]);

		sc->sc_bbu[1].type = SENSOR_VOLTS_DC;
		sc->sc_bbu[1].status = SENSOR_S_UNSPEC;
		sc->sc_bbu[2].type = SENSOR_AMPS;
		sc->sc_bbu[2].status = SENSOR_S_UNSPEC;
		sc->sc_bbu[3].type = SENSOR_TEMP;
		sc->sc_bbu[3].status = SENSOR_S_UNSPEC;
		for (i = 1; i < MFI_BBU_SENSORS; i++) {
			strlcpy(sc->sc_bbu[i].desc, "bbu",
			    sizeof(sc->sc_bbu[i].desc));
			sensor_attach(&sc->sc_sensordev, &sc->sc_bbu[i]);
		}

		sc->sc_bbu_status = malloc(sizeof(*sc->sc_bbu_status) *
		    sizeof(mfi_bbu_indicators), M_DEVBUF, M_WAITOK | M_ZERO);

		for (i = 0; i < nitems(mfi_bbu_indicators); i++) {
			sc->sc_bbu_status[i].type = SENSOR_INDICATOR;
			sc->sc_bbu_status[i].status = SENSOR_S_UNSPEC;
			strlcpy(sc->sc_bbu_status[i].desc,
			    mfi_bbu_indicators[i],
			    sizeof(sc->sc_bbu_status[i].desc));

			sensor_attach(&sc->sc_sensordev, &sc->sc_bbu_status[i]);
		}
	}

	sc->sc_sensors = mallocarray(sc->sc_ld_cnt, sizeof(struct ksensor),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_sensors == NULL)
		return (1);

	for (i = 0; i < sc->sc_ld_cnt; i++) {
		link = scsi_get_link(sc->sc_scsibus, i, 0);
		if (link == NULL)
			goto bad;

		dev = link->device_softc;

		sc->sc_sensors[i].type = SENSOR_DRIVE;
		sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;

		strlcpy(sc->sc_sensors[i].desc, dev->dv_xname,
		    sizeof(sc->sc_sensors[i].desc));

		sensor_attach(&sc->sc_sensordev, &sc->sc_sensors[i]);
	}

	if (sensor_task_register(sc, mfi_refresh_sensors, 10) == NULL)
		goto bad;

	sensordev_install(&sc->sc_sensordev);

	return (0);

bad:
	free(sc->sc_sensors, M_DEVBUF,
	    sc->sc_ld_cnt * sizeof(struct ksensor));

	return (1);
}

void
mfi_refresh_sensors(void *arg)
{
	struct mfi_softc	*sc = arg;
	int			i, rv;
	struct bioc_vol		bv;

	if (sc->sc_bbu != NULL && mfi_bbu(sc) != 0)
		return;

	for (i = 0; i < sc->sc_ld_cnt; i++) {
		bzero(&bv, sizeof(bv));
		bv.bv_volid = i;

		rw_enter_write(&sc->sc_lock);
		rv = mfi_ioctl_vol(sc, &bv);
		rw_exit_write(&sc->sc_lock);

		if (rv != 0)
			return;

		switch(bv.bv_status) {
		case BIOC_SVOFFLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_FAIL;
			sc->sc_sensors[i].status = SENSOR_S_CRIT;
			break;

		case BIOC_SVDEGRADED:
			sc->sc_sensors[i].value = SENSOR_DRIVE_PFAIL;
			sc->sc_sensors[i].status = SENSOR_S_WARN;
			break;

		case BIOC_SVSCRUB:
		case BIOC_SVONLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_ONLINE;
			sc->sc_sensors[i].status = SENSOR_S_OK;
			break;

		case BIOC_SVINVALID:
			/* FALLTRHOUGH */
		default:
			sc->sc_sensors[i].value = 0; /* unknown */
			sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;
			break;
		}
	}
}
#endif /* SMALL_KERNEL */
#endif /* NBIO > 0 */

void
mfi_start(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	bus_dmamap_sync(sc->sc_dmat, MFIMEM_MAP(sc->sc_frames),
	    ccb->ccb_pframe_offset, sc->sc_frames_size,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	mfi_post(sc, ccb);
}

void
mfi_done(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	bus_dmamap_sync(sc->sc_dmat, MFIMEM_MAP(sc->sc_frames),
	    ccb->ccb_pframe_offset, sc->sc_frames_size,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	if (ccb->ccb_len > 0) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap,
		    0, ccb->ccb_dmamap->dm_mapsize,
		    (ccb->ccb_direction == MFI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

	ccb->ccb_done(sc, ccb);
}

u_int32_t
mfi_xscale_fw_state(struct mfi_softc *sc)
{
	return (mfi_read(sc, MFI_OMSG0));
}

void
mfi_xscale_intr_ena(struct mfi_softc *sc)
{
	mfi_write(sc, MFI_OMSK, MFI_ENABLE_INTR);
}

int
mfi_xscale_intr(struct mfi_softc *sc)
{
	u_int32_t status;

	status = mfi_read(sc, MFI_OSTS);
	if (!ISSET(status, MFI_OSTS_INTR_VALID))
		return (0);

	/* write status back to acknowledge interrupt */
	mfi_write(sc, MFI_OSTS, status);

	return (1);
}

void
mfi_xscale_post(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	mfi_write(sc, MFI_IQP, (ccb->ccb_pframe >> 3) |
	    ccb->ccb_extra_frames);
}

u_int32_t
mfi_ppc_fw_state(struct mfi_softc *sc)
{
	return (mfi_read(sc, MFI_OSP));
}

void
mfi_ppc_intr_ena(struct mfi_softc *sc)
{
	mfi_write(sc, MFI_ODC, 0xffffffff);
	mfi_write(sc, MFI_OMSK, ~0x80000004);
}

int
mfi_ppc_intr(struct mfi_softc *sc)
{
	u_int32_t status;

	status = mfi_read(sc, MFI_OSTS);
	if (!ISSET(status, MFI_OSTS_PPC_INTR_VALID))
		return (0);

	/* write status back to acknowledge interrupt */
	mfi_write(sc, MFI_ODC, status);

	return (1);
}

void
mfi_ppc_post(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	mfi_write(sc, MFI_IQP, 0x1 | ccb->ccb_pframe |
	    (ccb->ccb_extra_frames << 1));
}

u_int32_t
mfi_gen2_fw_state(struct mfi_softc *sc)
{
	return (mfi_read(sc, MFI_OSP));
}

void
mfi_gen2_intr_ena(struct mfi_softc *sc)
{
	mfi_write(sc, MFI_ODC, 0xffffffff);
	mfi_write(sc, MFI_OMSK, ~MFI_OSTS_GEN2_INTR_VALID);
}

int
mfi_gen2_intr(struct mfi_softc *sc)
{
	u_int32_t status;

	status = mfi_read(sc, MFI_OSTS);
	if (!ISSET(status, MFI_OSTS_GEN2_INTR_VALID))
		return (0);

	/* write status back to acknowledge interrupt */
	mfi_write(sc, MFI_ODC, status);

	return (1);
}

void
mfi_gen2_post(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	mfi_write(sc, MFI_IQP, 0x1 | ccb->ccb_pframe |
	    (ccb->ccb_extra_frames << 1));
}

u_int32_t
mfi_skinny_fw_state(struct mfi_softc *sc)
{
	return (mfi_read(sc, MFI_OSP));
}

void
mfi_skinny_intr_ena(struct mfi_softc *sc)
{
	mfi_write(sc, MFI_OMSK, ~0x00000001);
}

int
mfi_skinny_intr(struct mfi_softc *sc)
{
	u_int32_t status;

	status = mfi_read(sc, MFI_OSTS);
	if (!ISSET(status, MFI_OSTS_SKINNY_INTR_VALID))
		return (0);

	/* write status back to acknowledge interrupt */
	mfi_write(sc, MFI_OSTS, status);

	return (1);
}

void
mfi_skinny_post(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	mfi_write(sc, MFI_IQPL, 0x1 | ccb->ccb_pframe |
	    (ccb->ccb_extra_frames << 1));
	mfi_write(sc, MFI_IQPH, 0x00000000);
}

u_int
mfi_skinny_sgd_load(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	struct mfi_frame_header	*hdr = &ccb->ccb_frame->mfr_header;
	union mfi_sgl		*sgl = ccb->ccb_sgl;
	bus_dma_segment_t	*sgd = ccb->ccb_dmamap->dm_segs;
	int			 i;

	switch (hdr->mfh_cmd) {
	case MFI_CMD_LD_READ:
	case MFI_CMD_LD_WRITE:
	case MFI_CMD_PD_SCSI_IO:
		/* Use MF_FRAME_IEEE for some IO commands on skinny adapters */
		for (i = 0; i < ccb->ccb_dmamap->dm_nsegs; i++) {
			sgl->sg_skinny[i].addr = htole64(sgd[i].ds_addr);
			sgl->sg_skinny[i].len = htole32(sgd[i].ds_len);
			sgl->sg_skinny[i].flag = 0;
		}
		hdr->mfh_flags |= MFI_FRAME_IEEE | MFI_FRAME_SGL64;

		return (ccb->ccb_dmamap->dm_nsegs * sizeof(sgl->sg_skinny));
	default:
		return (mfi_default_sgd_load(sc, ccb));
	}
}

int
mfi_pd_scsi_probe(struct scsi_link *link)
{
	union mfi_mbox mbox;
	struct mfi_softc *sc = link->adapter_softc;
	struct mfi_pd_link *pl = sc->sc_pd->pd_links[link->target];

	if (link->lun > 0)
		return (0);

	if (pl == NULL)
		return (ENXIO);

	memset(&mbox, 0, sizeof(mbox));
	mbox.s[0] = pl->pd_id;

	if (mfi_mgmt(sc, MR_DCMD_PD_GET_INFO, MFI_DATA_IN,
	    sizeof(pl->pd_info), &pl->pd_info, &mbox))
		return (EIO);

	if (letoh16(pl->pd_info.mpd_fw_state) != MFI_PD_SYSTEM)
		return (ENXIO);

	return (0);
}

void
mfi_pd_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct mfi_softc *sc = link->adapter_softc;
	struct mfi_ccb *ccb = xs->io;
	struct mfi_pass_frame *pf = &ccb->ccb_frame->mfr_pass;
	struct mfi_pd_link *pl = sc->sc_pd->pd_links[link->target];

	KERNEL_UNLOCK();

	mfi_scrub_ccb(ccb);
	xs->error = XS_NOERROR;

	pf->mpf_header.mfh_cmd = MFI_CMD_PD_SCSI_IO;
	pf->mpf_header.mfh_target_id = pl->pd_id;
	pf->mpf_header.mfh_lun_id = link->lun;
	pf->mpf_header.mfh_cdb_len = xs->cmdlen;
	pf->mpf_header.mfh_timeout = 0;
	pf->mpf_header.mfh_data_len = htole32(xs->datalen); /* XXX */
	pf->mpf_header.mfh_sense_len = MFI_SENSE_SIZE;
	pf->mpf_sense_addr = htole64(ccb->ccb_psense);

	memset(pf->mpf_cdb, 0, sizeof(pf->mpf_cdb));
	memcpy(pf->mpf_cdb, xs->cmd, xs->cmdlen);

	ccb->ccb_done = mfi_scsi_xs_done;
	ccb->ccb_cookie = xs;
	ccb->ccb_frame_size = MFI_PASS_FRAME_SIZE;
	ccb->ccb_sgl = &pf->mpf_sgl;

	if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT))
		ccb->ccb_direction = xs->flags & SCSI_DATA_IN ?
		    MFI_DATA_IN : MFI_DATA_OUT;
	else
		ccb->ccb_direction = MFI_DATA_NONE;

	if (xs->data) {
		ccb->ccb_data = xs->data;
		ccb->ccb_len = xs->datalen;

		if (mfi_create_sgl(sc, ccb, (xs->flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK))
			goto stuffup;
	}

	if (xs->flags & SCSI_POLL)
		mfi_poll(sc, ccb);
	else
		mfi_start(sc, ccb);

	KERNEL_LOCK();
	return;

stuffup:
	xs->error = XS_DRIVER_STUFFUP;
	KERNEL_LOCK();
	scsi_done(xs);
}
@


1.166
log
@represent the mbox layout with union instead of an array of bytes.

memcpying uint16_ts into inconsistently addressed offsets is hard
to read, and this makes future work easier to implement.

tested on mfi(4) and mfii(4)
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.165 2015/09/09 18:23:55 deraadt Exp $ */
d1381 1
a1381 1
		memcpy(&dcmd->mdf_mbox, &mbox, sizeof(dcmd->mdf_mbox));
d1463 1
d1490 1
@


1.165
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.164 2015/05/29 00:33:37 uebayasi Exp $ */
d106 1
a106 1
		    void *, uint8_t *);
d108 1
a108 1
		    uint32_t, uint32_t, void *, uint8_t *);
d1180 1
a1180 1
	uint8_t			mbox[MFI_MBOX_SIZE];
d1228 1
a1228 1
		mbox[0] = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;
d1230 1
a1230 1
		    MFI_DATA_NONE, 0, NULL, mbox))
d1341 1
a1341 1
    void *buf, uint8_t *mbox)
d1356 1
a1356 1
    uint32_t dir, uint32_t len, void *buf, uint8_t *mbox)
d1369 1
a1369 1
	memset(dcmd->mdf_mbox, 0, MFI_MBOX_SIZE);
d1380 2
a1381 2
	if (mbox)
		memcpy(dcmd->mdf_mbox, mbox, MFI_MBOX_SIZE);
d1451 1
a1451 1
	uint8_t			 mbox[MFI_MBOX_SIZE];
d1463 1
a1463 1
	mbox[0] = link->target;
d1465 1
a1465 1
	    sizeof(ldp), &ldp, mbox)) != 0)
d1489 3
a1491 3
	mbox[0] = ldp.mlp_ld.mld_target;
	mbox[1] = ldp.mlp_ld.mld_res;
	*(uint16_t *)&mbox[2] = ldp.mlp_ld.mld_seq;
d1518 1
a1518 1
	    sizeof(ldp), &ldp, mbox)) != 0)
d1585 1
a1585 1
	uint8_t			mbox[MFI_MBOX_SIZE];
d1644 2
a1645 1
		mbox[0] = sc->sc_ld_list.mll_list[i].mll_ld.mld_target;
d1647 1
a1647 1
		    &sc->sc_ld_details[i], mbox))
d1798 1
a1798 1
	uint8_t			mbox[MFI_MBOX_SIZE];
d1867 2
a1868 1
	*((uint16_t *)&mbox) = ar[arr].pd[disk].mar_pd.mfp_id;
d1870 1
a1870 1
	    sizeof *pd, pd, mbox)) {
d1954 1
a1954 1
	uint8_t			mbox[MFI_MBOX_SIZE];
d1981 2
a1982 3
	memset(mbox, 0, sizeof mbox);

	*((uint16_t *)&mbox) = pd->mpl_address[i].mpa_pd_id;
d2001 1
a2001 1
	if (mfi_mgmt(sc, cmd, MFI_DATA_NONE, 0, NULL, mbox))
d2016 1
a2016 1
	uint8_t			mbox[MFI_MBOX_SIZE];
d2038 2
a2039 1
	memset(mbox, 0, sizeof mbox);
a2040 1
	*((uint16_t *)&mbox) = pd->mpl_address[i].mpa_pd_id;
d2042 1
a2042 1
	    sizeof *info, info, mbox))
d2045 2
a2046 2
	*((uint16_t *)&mbox[0]) = pd->mpl_address[i].mpa_pd_id;
	*((uint16_t *)&mbox[2]) = info->mpd_pd.mfp_seq;
d2050 1
a2050 1
		mbox[4] = MFI_PD_ONLINE;
d2054 1
a2054 1
		mbox[4] = MFI_PD_OFFLINE;
d2058 1
a2058 1
		mbox[4] = MFI_PD_HOTSPARE;
d2062 1
a2062 1
		mbox[4] = MFI_PD_REBUILD;
d2073 1
a2073 1
	    mbox)))
d2231 1
a2231 1
	uint8_t			mbox[MFI_MBOX_SIZE];
d2273 2
a2274 2
	memset(mbox, 0, sizeof mbox);
	*((uint16_t *)&mbox) = hs[i].mhs_pd.mfp_id;
d2276 1
a2276 1
	    sizeof *pd, pd, mbox)) {
d2732 1
a2732 1
	uint8_t mbox[MFI_MBOX_SIZE];
d2742 2
a2743 2
	bzero(mbox, sizeof(mbox));
	memcpy(&mbox[0], &pl->pd_id, sizeof(pl->pd_id));
d2746 1
a2746 1
	    sizeof(pl->pd_info), &pl->pd_info, mbox))
@


1.164
log
@Initial addition of ``Patrol Read'' support in bio(4), biocto(8), and
mfi(4).  Based on FreeBSD, but done without mfiutil(8).

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d380 1
a380 1
	free(mm, M_DEVBUF, 0);
d394 1
a394 1
	free(mm, M_DEVBUF, 0);
d865 1
a865 1
	free(pd, M_TEMP, 0);
d888 1
a888 1
		free(pl, M_DEVBUF, 0);
d891 1
a891 1
	free(pd, M_TEMP, 0);
d893 1
a893 1
	free(sc->sc_pd, M_DEVBUF, 0);
d1602 1
a1602 1
		free(cfg, M_DEVBUF, 0);
d1607 1
a1607 1
	free(cfg, M_DEVBUF, 0);
d1614 1
a1614 1
		free(cfg, M_DEVBUF, 0);
d1634 1
a1634 1
		ld_det = malloc( size, M_DEVBUF, M_NOWAIT | M_ZERO);
d1897 1
a1897 1
	free(pd, M_DEVBUF, 0);
d2005 1
a2005 1
	free(pd, M_DEVBUF, 0);
d2077 2
a2078 2
	free(pd, M_DEVBUF, 0);
	free(info, M_DEVBUF, 0);
d2245 1
a2245 1
	free(cfg, M_DEVBUF, 0);
d2310 1
a2310 1
	free(pd, M_DEVBUF, 0);
d2478 2
a2479 1
	free(sc->sc_sensors, M_DEVBUF, 0);
@


1.163
log
@Prevent splassert from firing during sd_flush which runs "cold"

While mfi(4) should pass SCSI transfer flags (e.g. SCSI_POLL and
SCSI_NOSLEEP) down to the management function, make it at least
use "cold" consistently for now.

ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.162 2015/03/14 03:38:47 jsg Exp $ */
d120 1
d1566 5
d1791 2
d1888 7
d2079 136
@


1.162
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.161 2015/03/08 04:33:44 dlg Exp $ */
d1363 1
a1363 1
	dma_buf = dma_alloc(len, PR_WAITOK);
d1390 2
a1391 1
		if (mfi_create_sgl(sc, ccb, BUS_DMA_WAITOK)) {
@


1.161
log
@properly set sgl related flags on skinny controllers. this fixes
io against physical disks on my dell perc h310s. logical disks still
work fine.

ok deraadt@@ yasuoka@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.160 2015/02/08 12:17:31 yasuoka Exp $ */
a23 1
#include <sys/ioctl.h>
@


1.160
log
@Fix mfi ioctl to set drive state properly.
diff from Tsubai Masanari

test dlg jmatthew
ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.159 2015/01/09 11:17:29 yasuoka Exp $ */
d1262 1
d1267 2
a1323 1
	hdr->mfh_flags |= sc->sc_sgl_flags;
d2568 1
a2568 1
		hdr->mfh_flags |= MFI_FRAME_IEEE;
@


1.159
log
@Add support DIOC{G,S}CACHE to mfi(4).  Cache of disk on mfi(4) will
be enabled by default.  Also if the controller doesn't have any RAM,
the cache on the physical disk will be enabled.

discuss with jsg tsubai
ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.158 2014/12/19 07:23:57 deraadt Exp $ */
d1402 4
a1405 1
		rv = EIO;
d1996 1
d2004 1
d2023 6
d2032 1
a2032 1
		mbox[2] = MFI_PD_ONLINE;
d2036 1
a2036 1
		mbox[2] = MFI_PD_OFFLINE;
d2040 1
a2040 1
		mbox[2] = MFI_PD_HOTSPARE;
d2042 1
a2042 1
/*
d2044 1
d2046 1
a2046 1
*/
d2054 2
a2055 1
	if (mfi_mgmt(sc, MR_DCMD_PD_SET_STATE, MFI_DATA_NONE, 0, NULL, mbox))
d2061 1
@


1.158
log
@another handful of bcopy -> memcpy because there is no overlap
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.157 2014/09/14 14:17:24 jsg Exp $ */
d30 1
d62 1
d1424 92
a1515 4
	if (sc->sc_ioctl)
		return (sc->sc_ioctl(link->adapter_softc, cmd, addr));
	else
		return (ENOTTY);
@


1.157
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.156 2014/09/09 03:08:30 dlg Exp $ */
d1381 1
a1381 1
			bcopy(buf, dma_buf, len);
d1405 1
a1405 1
		bcopy(dma_buf, buf, len);
d2484 1
a2484 1
	bcopy(&pl->pd_id, &mbox[0], sizeof(pl->pd_id));
@


1.156
log
@mark the interrupt handler mpsafe, and give up biglock in the scsi cmd
submission paths. take biglock again when calling back into the scsi
stack.

tested on a variety of cards here, including the skinny mfis on the
firewall next to mpsafe myx.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.155 2014/08/15 02:27:02 yasuoka Exp $ */
a27 1
#include <sys/proc.h>
@


1.155
log
@Create a function which loads sgd in the mfi_iop_ops struct so that skinny
adapters can use "IEEE sgl".

tested dlg yasuoka
ok dlg jsg
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.154 2014/07/13 23:10:23 deraadt Exp $ */
d202 2
d213 1
d226 1
d230 1
d1116 1
d1118 1
d1184 2
d1248 1
d1254 1
d2506 2
d2548 1
d2553 1
@


1.154
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.153 2014/07/12 18:48:17 tedu Exp $ */
d96 1
d140 1
d154 1
d169 1
d178 1
d185 1
d194 1
d719 2
d1247 25
d1276 1
a1276 3
	bus_dma_segment_t	*sgd;
	union mfi_sgl		*sgl;
	int			error, i;
d1297 1
a1297 15
	sgl = ccb->ccb_sgl;
	sgd = ccb->ccb_dmamap->dm_segs;
	for (i = 0; i < ccb->ccb_dmamap->dm_nsegs; i++) {
		if (sc->sc_64bit_dma) {
			sgl->sg64[i].addr = htole64(sgd[i].ds_addr);
			sgl->sg64[i].len = htole32(sgd[i].ds_len);
			DNPRINTF(MFI_D_DMA, "%s: addr: %#x  len: %#x\n",
			    DEVNAME(sc), sgl->sg64[i].addr, sgl->sg64[i].len);
		} else {
			sgl->sg32[i].addr = htole32(sgd[i].ds_addr);
			sgl->sg32[i].len = htole32(sgd[i].ds_len);
			DNPRINTF(MFI_D_DMA, "%s: addr: %#x  len: %#x\n",
			    DEVNAME(sc), sgl->sg32[i].addr, sgl->sg32[i].len);
		}
	}
a1310 1
	ccb->ccb_frame_size += sc->sc_sgl_size * ccb->ccb_dmamap->dm_nsegs;
d2432 26
@


1.153
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.152 2014/05/04 20:09:15 sf Exp $ */
d249 1
a249 1
	sc->sc_ccb = malloc(sizeof(struct mfi_ccb) * sc->sc_max_cmds,
d2130 1
a2130 1
		sc->sc_bbu = malloc(sizeof(*sc->sc_bbu) * 4,
d2165 1
a2165 1
	sc->sc_sensors = malloc(sizeof(struct ksensor) * sc->sc_ld_cnt,
@


1.152
log
@format string fixes for bus_addr_t and bus_size_t

bus_addr_t and bus_size_t are u_long everywhere

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.151 2014/02/20 11:13:44 kettenis Exp $ */
d296 1
a296 1
	free(sc->sc_ccb, M_DEVBUF);
d367 1
a367 1
	free(mm, M_DEVBUF);
d381 1
a381 1
	free(mm, M_DEVBUF);
d850 1
a850 1
	free(pd, M_TEMP);
d873 1
a873 1
		free(pl, M_DEVBUF);
d876 1
a876 1
	free(pd, M_TEMP);
d878 1
a878 1
	free(sc->sc_pd, M_DEVBUF);
d1474 1
a1474 1
		free(cfg, M_DEVBUF);
d1479 1
a1479 1
	free(cfg, M_DEVBUF);
d1486 1
a1486 1
		free(cfg, M_DEVBUF);
d1492 1
a1492 1
		free(sc->sc_cfg, M_DEVBUF);
d1504 1
a1504 1
			free(sc->sc_ld_details, M_DEVBUF);
d1760 1
a1760 1
	free(pd, M_DEVBUF);
d1868 1
a1868 1
	free(pd, M_DEVBUF);
d1930 1
a1930 1
	free(pd, M_DEVBUF);
d1961 1
a1961 1
	free(cfg, M_DEVBUF);
d2026 2
a2027 2
	free(pd, M_DEVBUF);
	free(cfg, M_DEVBUF);
d2194 1
a2194 1
	free(sc->sc_sensors, M_DEVBUF);
@


1.151
log
@revert previous commit; didn't intend to commit those bits
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.149 2013/12/04 05:21:57 dlg Exp $ */
d736 1
a736 1
		printf("%s: improper frame alignment (%#x) FIXME\n",
@


1.150
log
@Avoid printing the "nvram corrupt" message for onboard 2200s found on Sun
hardware.

ok dlg@@, jmatthew@@
@
text
@d1333 3
a1335 5
	if (len > 0) {
		dma_buf = dma_alloc(len, cold ? PR_NOWAIT : PR_WAITOK);
		if (dma_buf == NULL)
			goto done;
	}
@


1.149
log
@mfi_refresh_sensors calls mfi_ioctl_vol which calls mfi_bio_getitall, which
replaces pointers in the softc and all sorts of fun stuff. this protects
the call to bio_getitall with the sc_lock the ioctl path uses, so we dont
get panics like those reported on bugs@@ recently.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.148 2013/10/23 13:05:38 kettenis Exp $ */
d1333 5
a1337 3
	dma_buf = dma_alloc(len, PR_WAITOK);
	if (dma_buf == NULL)
		goto done;
@


1.148
log
@Add support for displaying the cache write policy of RAID volumes to bioctl(8)
and make mfi(4) pass up the necessary information.  Adding support for other
RAID controllers is left as an excercise to the reader.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.147 2013/10/09 09:40:01 jmatthew Exp $ */
d2203 1
a2203 1
	int			i;
d2212 6
a2217 1
		if (mfi_ioctl_vol(sc, &bv))
@


1.147
log
@Include the 'state of health' field in the bbu ok sensor value.
The dell perc 6/i sets this to zero (meaning bad) when it
decides the battery doesn't have enough capacity for it to
allow write back mode, but doesn't set any of the other flags
to tell us why.

ok dlg@@, tested by sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.146 2013/05/18 08:39:47 jmc Exp $ */
d1631 5
@


1.146
log
@enw->new in comment;
spotted by krw, missed by jsg, and forwarded From: Alexey Suslikov
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.145 2013/05/08 03:00:32 jsg Exp $ */
d2053 1
d2072 1
d2076 1
d2096 3
a2098 2
	sc->sc_bbu[0].value = (status & mask) ? 0 : 1;
	sc->sc_bbu[0].status = (status & mask) ? SENSOR_S_CRIT : SENSOR_S_OK;
@


1.145
log
@fix some leaks in error paths
ok fgsch@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.144 2013/05/03 02:46:28 dlg Exp $ */
d1490 1
a1490 1
	/* replace current pointer with enw one */
@


1.144
log
@break out the battery status into excruciating detail. makes it harder for
$VENDOR to complain about a lack of diagnostic material from their crappy
mgmt tools if you're not running an operating system they support.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.143 2013/05/02 04:35:44 dlg Exp $ */
d1473 2
a1474 1
	    NULL))
d1476 1
d1485 2
a1486 1
	if (mfi_mgmt(sc, MR_DCMD_CONF_GET, MFI_DATA_IN, size, cfg, NULL))
d1488 1
@


1.143
log
@always attach the battery sensor if the adapter lets us query it.
newly replaced batteries dont show up immediately.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.142 2013/05/01 03:44:21 dlg Exp $ */
d2025 18
d2049 1
d2053 8
a2060 2
		sc->sc_bbu->value = 0;
		sc->sc_bbu->status = SENSOR_S_UNKNOWN;
d2074 10
a2083 2
		sc->sc_bbu->value = 0;
		sc->sc_bbu->status = SENSOR_S_CRIT;
d2089 13
a2101 2
	sc->sc_bbu->value = (status & MFI_BBU_STATE_PACK_MISSING) ? 0 : 1;
	sc->sc_bbu->status = (status & mask) ?  SENSOR_S_CRIT : SENSOR_S_OK;
d2117 2
a2118 2
		sc->sc_bbu = malloc(sizeof(*sc->sc_bbu), M_DEVBUF,
		    M_WAITOK | M_ZERO);
d2120 17
a2136 4
		sc->sc_bbu->type = SENSOR_INDICATOR;
		sc->sc_bbu->status = SENSOR_S_UNKNOWN;
		strlcpy(sc->sc_bbu->desc, "Battery Presence",
		    sizeof(sc->sc_bbu->desc));
d2138 12
a2149 1
		sensor_attach(&sc->sc_sensordev, sc->sc_bbu);
@


1.142
log
@provide a sensor for the battery backup unit (bbu) on mfi boards that
support it.

now i can tell (a bit better) why io might be slow on some of my boxes.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.141 2013/05/01 00:47:31 dlg Exp $ */
d2072 1
a2072 2
	if (ISSET(letoh32(sc->sc_info.mci_hw_present), MFI_INFO_HW_BBU) &&
	    ISSET(letoh32(sc->sc_info.mci_adapter_ops ), MFI_INFO_AOPS_BBU)) {
@


1.141
log
@dont need to walk alldevs during sensor creation looking for the logical
disk scsibus when we record that in mfi_attach.

also happens to get rid of a logic error that let it come out of the loop
on alldevs with a reference to something that wasnt the logical disk
scsibus and use that.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.140 2013/04/30 07:17:36 dlg Exp $ */
d123 1
d2024 38
d2069 16
a2089 3
	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));

d2126 2
d2157 1
a2158 1

@


1.140
log
@use MR_DCMD consistently. some MD_DCMD was in there somehow.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.139 2013/04/07 02:32:03 dlg Exp $ */
a2026 1
	struct scsibus_softc	*ssc = NULL;
a2029 13
	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		if (dev->dv_parent != &sc->sc_dev)
			continue;

		/* check if this is the scsibus for the logical disks */
		ssc = (struct scsibus_softc *)dev;
		if (ssc->adapter_link == &sc->sc_link)
			break;
	}

	if (ssc == NULL)
		return (1);

d2039 1
a2039 1
		link = scsi_get_link(ssc, i, 0);
@


1.139
log
@david imhoff points out that the error handling in mfi_init_ccb gets the
index to which ccb to free wrong.

this takes the logic from mpi/mpii/mfii which pulls the ready ccbs off
the free list rather than rely on the current index from the for loop
that we failed inside of.

thanks to david for finding this out.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.138 2012/09/12 06:53:05 haesbaert Exp $ */
d1471 1
a1471 1
	if (mfi_mgmt(sc, MD_DCMD_CONF_GET, MFI_DATA_IN, sizeof *cfg, cfg,
d1482 1
a1482 1
	if (mfi_mgmt(sc, MD_DCMD_CONF_GET, MFI_DATA_IN, size, cfg, NULL))
d1915 1
a1915 1
	if (mfi_mgmt(sc, MD_DCMD_PD_SET_STATE, MFI_DATA_NONE, 0, NULL, mbox))
d1947 1
a1947 1
	if (mfi_mgmt(sc, MD_DCMD_CONF_GET, MFI_DATA_IN, sizeof *cfg, cfg, NULL))
d1955 1
a1955 1
	if (mfi_mgmt(sc, MD_DCMD_CONF_GET, MFI_DATA_IN, size, cfg, NULL))
@


1.138
log
@Make sure we don't sleep on autoconf.

ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.137 2012/08/17 11:31:34 dlg Exp $ */
d292 1
a292 2
	while (i) {
		ccb = &sc->sc_ccb[i];
a293 2
		i--;
	}
@


1.137
log
@add support for "physical devices" on skinny controllers.

these controllers let you specify disks that should be accessed directly
rather than be part of logical volumes. apparently you can plug in things
like tape drives too.

anyway, physical devices are exposed via a separate scsibus attached to
mfi.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.136 2012/08/16 07:53:22 dlg Exp $ */
d2048 1
a2048 1
	    M_DEVBUF, M_WAITOK | M_CANFAIL | M_ZERO);
@


1.136
log
@fix mfi_poll by having it do delays between loops, and breaking on
timeouts. how embarrassment.

implement mfi_exec for doing sync executions of commands in process
contexts and cut mfi_mgmt over to it.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.135 2012/08/16 07:17:04 dlg Exp $ */
d64 3
d71 8
d96 1
d138 1
a138 1
	MFI_IDB
d151 2
a152 1
	MFI_IDB
d165 2
a166 1
	MFI_IDB
d179 2
a180 1
	MFI_SKINNY_IDB
d792 3
d821 63
d1081 4
d1087 3
a1089 2
		printf("%s: mfi_scsi_xs_done stuffup %#x\n",
		    DEVNAME(sc), hdr->mfh_cmd_status);
d1243 1
a1243 1
	struct mfi_frame_header	*hdr;
d1251 2
a1252 1
	if (!ccb->ccb_data)
d1254 1
a1266 1
	hdr = &ccb->ccb_frame->mfr_header;
d1819 1
a1819 1
	pd = malloc(MFI_PD_LIST_SIZE, M_DEVBUF, M_WAITOK);
d1822 1
a1822 1
	    MFI_PD_LIST_SIZE, pd, NULL))
d1875 1
a1875 1
	pd = malloc(MFI_PD_LIST_SIZE, M_DEVBUF, M_WAITOK);
d1878 1
a1878 1
	    MFI_PD_LIST_SIZE, pd, NULL))
d2293 82
@


1.135
log
@rework mfi_poll so it will do all the completions on a ccb including
calling the done handler.

this makes it consistently complete scsi io with all the proper error
checking.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.134 2012/08/16 06:45:51 dlg Exp $ */
d82 2
a95 1
void		mfi_mgmt_done(struct mfi_softc *, struct mfi_ccb *);
d806 2
a807 2
	struct mfi_frame_header	*hdr;
	int			to = 0, rv = 0;
d818 2
d831 1
a831 1
			rv = 1;
d851 32
d1242 3
a1244 3
	struct mfi_dcmd_frame	*dcmd;
	int			s, rv = EINVAL;
	uint8_t			*dma_buf = NULL;
a1259 1
	ccb->ccb_done = mfi_mgmt_done;
d1281 2
a1282 1
	if (cold)
d1284 2
a1285 3
	else {
		s = splbio();
		mfi_start(sc, ccb);
a1286 6
		DNPRINTF(MFI_D_MISC, "%s: mfi_do_mgmt sleeping\n", DEVNAME(sc));
		while (ccb->ccb_state != MFI_CCB_DONE)
			tsleep(ccb, PRIBIO, "mfimgmt", 0);
		splx(s);

	}
a1300 16
}

void
mfi_mgmt_done(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	struct mfi_frame_header	*hdr = &ccb->ccb_frame->mfr_header;

	DNPRINTF(MFI_D_INTR, "%s: mfi_mgmt_done %#x %#x\n",
	    DEVNAME(sc), ccb, ccb->ccb_frame);

	if (hdr->mfh_cmd_status != MFI_STAT_OK)
		ccb->ccb_flags |= MFI_CCB_F_ERR;

	ccb->ccb_state = MFI_CCB_DONE;

	wakeup(ccb);
@


1.134
log
@stop passing mfi_softc around as a member of the ccb, consistently give it
as the first argument to functions. like mfii.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.133 2012/08/16 06:05:56 dlg Exp $ */
d81 1
a81 1
int		mfi_poll(struct mfi_softc *, struct mfi_ccb *);
d95 1
d436 1
a436 1
	int			rv;
d466 4
a469 1
	rv = mfi_poll(sc, ccb);
d476 6
d802 1
a802 1
int
d816 6
a821 3
	while (hdr->mfh_cmd_status == 0xff) {
		delay(1000);
		if (to++ > 5000) /* XXX 5 seconds busywait sucks */
d823 11
a833 6
	}
	if (hdr->mfh_cmd_status == 0xff) {
		printf("%s: timeout on ccb %d\n", DEVNAME(sc),
		    hdr->mfh_context);
		ccb->ccb_flags |= MFI_CCB_F_ERR;
		rv = 1;
d836 1
a836 1
	if (ccb->ccb_direction != MFI_DATA_NONE) {
d845 1
a845 1
	return (rv);
d1106 4
a1109 21
	if (xs->flags & SCSI_POLL) {
		if (mfi_poll(sc, ccb)) {
			/* XXX check for sense in ccb->ccb_sense? */
			printf("%s: mfi_scsi_cmd poll failed\n",
			    DEVNAME(sc));
			bzero(&xs->sense, sizeof(xs->sense));
			xs->sense.error_code = SSD_ERRCODE_VALID |
			    SSD_ERRCODE_CURRENT;
			xs->sense.flags = SKEY_ILLEGAL_REQUEST;
			xs->sense.add_sense_code = 0x20; /* invalid opcode */
			xs->error = XS_SENSE;
		}

		scsi_done(xs);
		return;
	}

	mfi_start(sc, ccb);

	DNPRINTF(MFI_D_DMA, "%s: mfi_scsi_cmd queued %d\n", DEVNAME(sc),
	    ccb->ccb_dmamap->dm_nsegs);
d1247 3
a1249 6
	if (cold) {
		if (mfi_poll(sc, ccb)) {
			rv = EIO;
			goto done;
		}
	} else {
d1258 4
a1261 4
		if (ccb->ccb_flags & MFI_CCB_F_ERR) {
			rv = EIO;
			goto done;
		}
@


1.133
log
@scrub ccbs when we're about to use them, not when we put them back
on the free list. ccbs can be reused, so we dont want old state screwing up
new commands.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.132 2012/08/16 05:49:38 dlg Exp $ */
d81 2
a82 2
int		mfi_poll(struct mfi_ccb *);
int		mfi_create_sgl(struct mfi_ccb *, int);
d85 5
a89 4
int		mfi_scsi_ld(struct mfi_ccb *, struct scsi_xfer *);
int		mfi_scsi_io(struct mfi_ccb *, struct scsi_xfer *, uint64_t,
		    uint32_t);
void		mfi_scsi_xs_done(struct mfi_ccb *);
d94 1
a94 1
void		mfi_mgmt_done(struct mfi_ccb *);
d113 1
a113 1
void		mfi_done(struct mfi_ccb *);
a236 2
		ccb->ccb_sc = sc;

d465 1
a465 1
	rv = mfi_poll(ccb);
d793 1
a793 1
mfi_poll(struct mfi_ccb *ccb)
a794 1
	struct mfi_softc *sc = ccb->ccb_sc;
d865 1
a865 1
			mfi_done(ccb);
d884 2
a885 2
mfi_scsi_io(struct mfi_ccb *ccb, struct scsi_xfer *xs, uint64_t blockno,
    uint32_t blockcnt)
d919 1
a919 1
	if (mfi_create_sgl(ccb, (xs->flags & SCSI_NOSLEEP) ?
d927 1
a927 1
mfi_scsi_xs_done(struct mfi_ccb *ccb)
a929 1
	struct mfi_softc	*sc = ccb->ccb_sc;
d969 1
a969 1
mfi_scsi_ld(struct mfi_ccb *ccb, struct scsi_xfer *xs)
d1006 1
a1006 1
		if (mfi_create_sgl(ccb, (xs->flags & SCSI_NOSLEEP) ?
d1048 1
a1048 1
		if (mfi_scsi_io(ccb, xs, blockno, blockcnt))
d1058 1
a1058 1
		if (mfi_scsi_io(ccb, xs, blockno, blockcnt))
d1067 1
a1067 1
		if (mfi_scsi_io(ccb, xs, blockno, blockcnt))
d1081 1
a1081 1
		if (mfi_scsi_ld(ccb, xs))
d1089 1
a1089 1
		if (mfi_poll(ccb)) {
d1119 1
a1119 1
mfi_create_sgl(struct mfi_ccb *ccb, int flags)
a1120 1
	struct mfi_softc	*sc = ccb->ccb_sc;
d1240 1
a1240 1
		if (mfi_create_sgl(ccb, BUS_DMA_WAITOK)) {
d1247 1
a1247 1
		if (mfi_poll(ccb)) {
d1278 1
a1278 1
mfi_mgmt_done(struct mfi_ccb *ccb)
d2041 1
a2041 1
mfi_done(struct mfi_ccb *ccb)
a2042 2
	struct mfi_softc	*sc = ccb->ccb_sc;

d2056 1
a2056 1
	ccb->ccb_done(ccb);
@


1.132
log
@move the dma syncs for the ccb data into ccb_done, so we can do it once
rather than put the code everywhere.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.131 2012/08/16 05:38:13 dlg Exp $ */
d70 1
a193 1
	struct mfi_frame_header	*hdr = &ccb->ccb_frame->mfr_header;
d197 10
a218 4

	mtx_enter(&sc->sc_ccb_mtx);
	SLIST_INSERT_HEAD(&sc->sc_ccb_freeq, ccb, ccb_link);
	mtx_leave(&sc->sc_ccb_mtx);
d441 1
a441 2
	if (ccb ==  NULL)
		return (1);
d1040 2
d1199 1
@


1.131
log
@fix up the dma sync for the command frame in mfi_done.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.130 2012/08/14 10:44:36 dlg Exp $ */
a932 11
	if (xs->data != NULL) {
		DNPRINTF(MFI_D_INTR, "%s: mfi_scsi_xs_done sync\n",
		    DEVNAME(sc));
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

a1275 1
	struct mfi_softc	*sc = ccb->ccb_sc;
a1280 11
	if (ccb->ccb_data != NULL) {
		DNPRINTF(MFI_D_INTR, "%s: mfi_mgmt_done sync\n",
		    DEVNAME(sc));
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (ccb->ccb_direction & MFI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

d2044 9
@


1.130
log
@use scsi_get_link to find out the name of a child device for bioctl rather
than snoop scsi commands and copy it in an io path.

no functional change, but the code has one less XXX now.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.129 2012/08/14 10:13:39 dlg Exp $ */
d2065 2
a2066 1
	    ccb->ccb_pframe_offset, sc->sc_frames_size, BUS_DMASYNC_PREREAD);
@


1.129
log
@expose the max number of logical volumes the hardware supports as the width
of its scsibus. only advertise 1 lun on logical volumes instead of letting
the midlayer fix it up to 8.

give every target on the bus max_cmds openings. iopools means they will
properly share access to them.

this in particular is useful on skinny controllers which only advertise 31
command slots. if you have 16 volumes, theyll only get 1 opening each with
the old maths. this way round the ones that are busy will share the slots.

tested on a perc5 with two volumes and hard workloads.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.128 2012/08/14 04:07:53 dlg Exp $ */
d759 2
a760 1
	config_found(&sc->sc_dev, &saa, scsiprint);
a1027 1
	struct device		*dev = link->device_softc;
a1086 8
	/* hand it of to the firmware and let it deal with it */
	case TEST_UNIT_READY:
		/* save off sd? after autoconf */
		if (!cold)	/* XXX bogus */
			strlcpy(sc->sc_ld[target].ld_dev, dev->dv_xname,
			    sizeof(sc->sc_ld[target].ld_dev));
		/* FALLTHROUGH */

d1488 2
d1508 5
a1512 1
	strlcpy(bv->bv_dev, sc->sc_ld[i].ld_dev, sizeof(bv->bv_dev));
@


1.128
log
@print the boards name (eg, perc 5/i) according to the firmware like mfii.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.127 2012/08/14 03:42:03 dlg Exp $ */
a744 1
	sc->sc_max_ld = sc->sc_ld_cnt;
d748 1
a748 5
	if (sc->sc_ld_cnt)
		sc->sc_link.openings = sc->sc_max_cmds / sc->sc_ld_cnt;
	else
		sc->sc_link.openings = sc->sc_max_cmds;

d750 4
a753 3
	sc->sc_link.adapter = &mfi_switch;
	sc->sc_link.adapter_target = MFI_MAX_LD;
	sc->sc_link.adapter_buswidth = sc->sc_max_ld;
d1040 1
a1040 2
	if (target >= MFI_MAX_LD || !sc->sc_ld[target].ld_present ||
	    link->lun != 0) {
@


1.127
log
@move knowledge of the location of the inbound doorbell out of code in
transition_firmware into a member of the iop structures.

ok mikeb@@ haesbaert@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.126 2012/08/13 06:19:15 dlg Exp $ */
d738 5
a742 5
	printf("%s: logical drives %d, version %s, %dMB RAM\n",
	    DEVNAME(sc),
	    sc->sc_info.mci_lds_present,
	    sc->sc_info.mci_package_version,
	    sc->sc_info.mci_memory_size);
@


1.126
log
@get rid of the last foo_lo and foo_hi bits i could find in the hardware
structures and use htole64 instead of htole32(addr >> 32); htole32(addr);

gets rid of "handy" stack variables to get the dva to 64bits.

sprinkle some more byte swaps for things that should have it.

tested on a perc5 (xscale)
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.125 2012/08/13 05:20:30 dlg Exp $ */
d121 2
a122 1
	mfi_xscale_post
d134 2
a135 1
	mfi_ppc_post
d147 2
a148 1
	mfi_gen2_post
d160 2
a161 1
	mfi_skinny_post
d368 1
d386 1
a386 4
			if (sc->sc_flags & MFI_IOP_SKINNY)
				mfi_write(sc, MFI_SKINNY_IDB, MFI_INIT_CLEAR_HANDSHAKE);
			else
				mfi_write(sc, MFI_IDB, MFI_INIT_CLEAR_HANDSHAKE);
d390 1
a390 4
			if (sc->sc_flags & MFI_IOP_SKINNY)
				mfi_write(sc, MFI_SKINNY_IDB, MFI_INIT_READY);
			else
				mfi_write(sc, MFI_IDB, MFI_INIT_READY);
@


1.125
log
@do appropriate bus_dmamapy_syncs around the pcq/completion ring.

tested on a perc5 (xscale)
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.124 2012/08/13 03:04:51 dlg Exp $ */
a889 1
	uint64_t		handy;
d909 3
a911 7
	io->mif_header.mfh_data_len= blockcnt;
	io->mif_lba_hi = (uint32_t)(blockno >> 32);
	io->mif_lba_lo = (uint32_t)(blockno & 0xffffffffull);

	handy = ccb->ccb_psense;
	io->mif_sense_addr_hi = htole32((u_int32_t)(handy >> 32));
	io->mif_sense_addr_lo = htole32(handy);
a985 1
	uint64_t		handy;
d996 1
a996 1
	pf->mpf_header.mfh_data_len= xs->datalen; /* XXX */
d999 1
a999 3
	handy = ccb->ccb_psense;
	pf->mpf_sense_addr_hi = htole32((u_int32_t)(handy >> 32));
	pf->mpf_sense_addr_lo = htole32(handy);
@


1.124
log
@replace uint32_ts for hi and lo addresses in the mfi_init_ hardware
descriptors with single uint64_ts. theyre not some weird middle
endian thing. this makes the code more readable.

add some missing htole32s to the code while here.

tested on a perc5 (xscale).
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.123 2012/08/11 00:57:01 dlg Exp $ */
d458 4
d835 1
a835 1
	struct mfi_prod_cons	*pcq;
d843 4
a846 1
	pcq = MFIMEM_KVA(sc->sc_pcq);
d876 4
@


1.123
log
@the producer/consumer values are used by the device, which is little
endian. do appropriate byteswapping for when the host cpu uses them.

tested on a perc5 (xscale) in an amd64.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.122 2012/01/12 06:12:30 dlg Exp $ */
d431 1
a431 1
	uint64_t		handy;
d435 2
a436 1
	if ((ccb = mfi_get_ccb(sc)) == NULL)
d442 2
a443 2
	memset(qinfo, 0, sizeof *qinfo);
	qinfo->miq_rq_entries = sc->sc_max_cmds + 1;
d445 8
a452 14
	handy = MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_reply_q);
	qinfo->miq_rq_addr_hi = htole32(handy >> 32);
	qinfo->miq_rq_addr_lo = htole32(handy);

	handy = MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_producer);
	qinfo->miq_pi_addr_hi = htole32(handy >> 32);
	qinfo->miq_pi_addr_lo = htole32(handy);

	handy = MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_consumer);
	qinfo->miq_ci_addr_hi = htole32(handy >> 32);
	qinfo->miq_ci_addr_lo = htole32(handy);
d455 2
a456 2
	init->mif_header.mfh_data_len = sizeof *qinfo;
	init->mif_qinfo_new_addr_lo = htole32(ccb->ccb_pframe + MFI_FRAME_SIZE);
d458 1
a458 12
	DNPRINTF(MFI_D_MISC, "%s: entries: %08x%08x rq: %08x%08x pi: %#x "
	    "ci: %08x%08x\n",
	    DEVNAME(sc),
	    qinfo->miq_rq_entries,
	    qinfo->miq_rq_addr_hi, qinfo->miq_rq_addr_lo,
	    qinfo->miq_pi_addr_hi, qinfo->miq_pi_addr_lo,
	    qinfo->miq_ci_addr_hi, qinfo->miq_ci_addr_lo);

	if (mfi_poll(ccb)) {
		printf("%s: mfi_initialize_firmware failed\n", DEVNAME(sc));
		return (1);
	}
d462 1
a462 1
	return (0);
@


1.122
log
@add support for skinny variants.

from Alexey Suslikov
reviewed by marco
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.121 2011/07/17 22:46:48 matthew Exp $ */
d856 2
a857 2
	producer = pcq->mpc_producer;
	consumer = pcq->mpc_consumer;
d884 1
a884 1
	pcq->mpc_consumer = consumer;
@


1.121
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.120 2011/07/08 22:09:27 matthew Exp $ */
d148 12
d381 4
a384 1
			mfi_write(sc, MFI_IDB, MFI_INIT_CLEAR_HANDSHAKE);
d388 4
a391 1
			mfi_write(sc, MFI_IDB, MFI_INIT_READY);
d667 3
d2193 35
@


1.120
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.119 2011/04/09 20:23:31 marco Exp $ */
d749 1
a753 1
	saa.saa_targets = sc->sc_max_ld;
@


1.119
log
@add all 64 bit dma plumbing but stick with 32 for now by default.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.118 2011/04/09 03:00:18 marco Exp $ */
a748 1
	sc->sc_link.adapter_buswidth = sc->sc_max_ld;
d753 1
@


1.118
log
@make sure the upper 32 bits are always written to instead of assuming it
is 0.

ok deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.118 2011/04/09 02:06:39 marco Exp $ */
d636 1
a636 1
	uint32_t		status, frames;
d666 12
a677 3
	sc->sc_max_sgl = (status & MFI_STATE_MAXSGL_MASK) >> 16;
	DNPRINTF(MFI_D_MISC, "%s: max commands: %u, max sgl: %u\n",
	    DEVNAME(sc), sc->sc_max_cmds, sc->sc_max_sgl);
d690 2
a691 2
	frames = (sizeof(struct mfi_sg32) * sc->sc_max_sgl +
	    MFI_FRAME_SIZE - 1) / MFI_FRAME_SIZE + 1;
d1161 11
a1171 4
		sgl->sg32[i].addr = htole32(sgd[i].ds_addr);
		sgl->sg32[i].len = htole32(sgd[i].ds_len);
		DNPRINTF(MFI_D_DMA, "%s: addr: %#x  len: %#x\n",
		    DEVNAME(sc), sgl->sg32[i].addr, sgl->sg32[i].len);
d1184 1
d1186 1
a1186 3
	/* for 64 bit io make the sizeof a variable to hold whatever sg size */
	ccb->ccb_frame_size += sizeof(struct mfi_sg32) *
	    ccb->ccb_dmamap->dm_nsegs;
@


1.117
log
@kill some stray spaces
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.116 2011/04/08 19:16:47 marco Exp $ */
d413 1
d425 15
a439 6
	qinfo->miq_rq_addr_lo = htole32(MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_reply_q));
	qinfo->miq_pi_addr_lo = htole32(MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_producer));
	qinfo->miq_ci_addr_lo = htole32(MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_consumer));
d445 2
a446 1
	DNPRINTF(MFI_D_MISC, "%s: entries: %#x rq: %#x pi: %#x ci: %#x\n",
d448 4
a451 2
	    qinfo->miq_rq_entries, qinfo->miq_rq_addr_lo,
	    qinfo->miq_pi_addr_lo, qinfo->miq_ci_addr_lo);
d865 1
d888 4
a891 2
	io->mif_sense_addr_lo = htole32(ccb->ccb_psense);
	io->mif_sense_addr_hi = 0;
d966 1
d980 3
a982 2
	pf->mpf_sense_addr_hi = 0;
	pf->mpf_sense_addr_lo = htole32(ccb->ccb_psense);
@


1.116
log
@rename wiat channel to something less than 8 chars.

prompted by deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.115 2011/04/08 19:15:35 marco Exp $ */
d176 1
a176 1
	struct mfi_ccb 		*ccb = io;
d305 1
a305 1
		goto amfree; 
d1717 1
a1717 1
		    	found = 1;
d1773 1
a1773 1
		    	found = 1;
@


1.115
log
@use dma_alloc for transient management commands.

prodded and ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.114 2010/12/30 08:53:50 dlg Exp $ */
d1237 1
a1237 1
			tsleep(ccb, PRIBIO, "mfi_do_mgmt", 0);
@


1.114
log
@cut mfi over to using iopools.

this gets rid of NO_CCB, provides better scheduling of io between busy
logical volumes on the same controller, and makes the ioctl and sensor
paths more reliable.

this is the least intrusive version of this change i could come up with. it
only took 4 or 5 goes...

ok marco@@
deraadt@@ says this is a good time for this change.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.113 2010/09/24 01:30:05 dlg Exp $ */
d20 1
d31 1
d1187 2
a1188 1
	int			s;
d1190 5
a1194 1
	DNPRINTF(MFI_D_MISC, "%s: mfi_mgmt %#x\n", DEVNAME(sc), opc);
d1213 2
d1216 1
a1216 1
		ccb->ccb_data = buf;
d1220 4
a1223 2
		if (mfi_create_sgl(ccb, BUS_DMA_WAITOK))
			return (EINVAL);
d1227 4
a1230 2
		if (mfi_poll(ccb))
			return (EIO);
d1235 1
a1235 1
		DNPRINTF(MFI_D_MISC, "%s: mfi_mgmt sleeping\n", DEVNAME(sc));
d1237 1
a1237 1
			tsleep(ccb, PRIBIO, "mfi_mgmt", 0);
d1240 4
a1243 2
		if (ccb->ccb_flags & MFI_CCB_F_ERR)
			return (EIO);
d1246 9
a1254 1
	return (0);
@


1.113
log
@no use setting cmd in mfi_ioctl_setstate if you never use it.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.112 2010/09/20 06:17:49 krw Exp $ */
d66 2
a67 2
struct mfi_ccb	*mfi_get_ccb(struct mfi_softc *);
void		mfi_put_ccb(struct mfi_ccb *);
d88 2
d151 2
a152 2
struct mfi_ccb *
mfi_get_ccb(struct mfi_softc *sc)
d154 1
d171 1
a171 1
mfi_put_ccb(struct mfi_ccb *ccb)
d173 2
a174 1
	struct mfi_softc	*sc = ccb->ccb_sc;
d246 1
a246 1
		mfi_put_ccb(ccb);
d443 1
a443 1
	mfi_put_ccb(ccb);
d645 1
d726 1
a939 1
	mfi_put_ccb(ccb);
d996 1
a996 1
	struct mfi_ccb		*ccb;
a1014 7
	if ((ccb = mfi_get_ccb(sc)) == NULL) {
		DNPRINTF(MFI_D_CMD, "%s: mfi_scsi_cmd no ccb\n", DEVNAME(sc));
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}

d1024 1
a1024 2
		if (mfi_scsi_io(ccb, xs, blockno, blockcnt)) {
			mfi_put_ccb(ccb);
a1025 1
		}
d1034 1
a1034 2
		if (mfi_scsi_io(ccb, xs, blockno, blockcnt)) {
			mfi_put_ccb(ccb);
a1035 1
		}
d1043 1
a1043 2
		if (mfi_scsi_io(ccb, xs, blockno, blockcnt)) {
			mfi_put_ccb(ccb);
a1044 1
		}
a1047 2
		mfi_put_ccb(ccb); /* we don't need this */

d1049 2
a1050 2
		if (mfi_mgmt(sc, MR_DCMD_CTRL_CACHE_FLUSH, MFI_DATA_NONE,
		    0, NULL, mbox))
d1065 1
a1065 2
		if (mfi_scsi_ld(ccb, xs)) {
			mfi_put_ccb(ccb);
a1066 1
		}
a1084 1
		mfi_put_ccb(ccb);
d1170 14
a1183 1
	struct mfi_ccb		*ccb;
a1184 1
	int			rv = 1;
a1188 3
	if ((ccb = mfi_get_ccb(sc)) == NULL)
		return (rv);

d1212 1
a1212 1
			goto done;
d1217 1
a1217 1
			goto done;
d1228 1
a1228 1
			goto done;
d1231 1
a1231 5
	rv = 0;

done:
	mfi_put_ccb(ccb);
	return (rv);
d1346 2
a1347 1
	if (mfi_mgmt(sc, MD_DCMD_CONF_GET, MFI_DATA_IN, sizeof *cfg, cfg, NULL))
@


1.112
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.111 2010/08/29 23:23:31 dlg Exp $ */
a1743 1
	uint32_t		cmd;
a1770 1
		cmd = MD_DCMD_PD_SET_STATE;
a1774 1
		cmd = MD_DCMD_PD_SET_STATE;
a1778 1
		cmd = MD_DCMD_PD_SET_STATE;
a1781 1
		cmd = MD_DCMD_PD_REBUILD;
@


1.111
log
@the scsi completion code thinks that if you dont get MFI_STAT_OK
back from the chip on a command then the command completely failed.
MFI_STAT_SCSI_DONE_WITH_ERROR really means the command completed
fine, but there's some sense data too. this tweaks the handling to
be more appropriate, as per the linux and solaris drivers.

timed out waiting for beck@@
putting this in cos its obviously more correct than the current code.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.110 2010/07/22 04:40:41 matthew Exp $ */
d1090 2
a1091 1
			xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
@


1.110
log
@SCSI HBA drivers are supposed to get their SCSI CDBs from xs->cmd, not
xs->cmdstore.

ok krw@@ a while back (contingent upon testing), and deraadt@@ says this
has been in snapshots for weeks now.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.109 2010/07/01 03:20:38 matthew Exp $ */
d904 13
a916 1
	if (hdr->mfh_cmd_status != MFI_STAT_OK) {
d918 1
a918 1
		DNPRINTF(MFI_D_INTR, "%s: mfi_scsi_xs_done stuffup %#x\n",
d931 1
a932 2

	xs->resid = 0;
@


1.109
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.108 2010/06/30 19:10:05 mk Exp $ */
d949 1
a949 1
	memcpy(pf->mpf_cdb, &xs->cmdstore, xs->cmdlen);
@


1.108
log
@Use SLIST for the ccb free list.

ok krw, discontent grunts from marco.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.107 2010/06/28 18:31:02 krw Exp $ */
d1897 1
d1922 2
a1923 1
		if (ssc->sc_link[i][0] == NULL)
d1926 1
a1926 1
		dev = ssc->sc_link[i][0]->device_softc;
@


1.107
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.106 2010/06/15 04:11:34 dlg Exp $ */
d155 1
a155 1
	ccb = TAILQ_FIRST(&sc->sc_ccb_freeq);
d157 1
a157 1
		TAILQ_REMOVE(&sc->sc_ccb_freeq, ccb, ccb_link);
d189 1
a189 1
	TAILQ_INSERT_TAIL(&sc->sc_ccb_freeq, ccb, ccb_link);
d639 1
a639 1
	TAILQ_INIT(&sc->sc_ccb_freeq);
@


1.106
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.105 2010/05/20 00:55:17 krw Exp $ */
a65 4
struct scsi_device mfi_dev = {
	NULL, NULL, NULL, NULL
};

a716 1
	sc->sc_link.device = &mfi_dev;
@


1.105
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.104 2010/05/16 20:33:59 nicm Exp $ */
d59 1
a59 1
int	mfi_scsi_ioctl(struct scsi_link *, u_long, caddr_t, int, struct proc *);
d1264 1
a1264 2
mfi_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag,
    struct proc *p)
@


1.104
log
@Use a temporary variable for now to sidestep -Wbounded checking when
copying vendor[8]/product[16]/revision[4] out of struct scsi_inquiry_data
together with one memcopy.

ok krw
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.103 2010/04/22 12:33:30 oga Exp $ */
a992 1
	int			s;
a1006 1
		s = splbio();
a1007 1
		splx(s);
a1090 1
		s = splbio();
a1091 1
		splx(s);
a1104 1
	s = splbio();
a1105 1
	splx(s);
@


1.103
log
@use BUS_DMA_ZERO on alloc instead of bzeroing after.

ok dlg@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.102 2010/04/10 17:29:59 marco Exp $ */
d1531 1
a1531 1
	char			vend[8+16+4+1];
d1617 2
a1618 1
	memcpy(vend, inqbuf->vendor, sizeof vend - 1);
d1815 1
a1815 1
	char			vend[8+16+4+1];
d1885 2
a1886 1
		memcpy(vend, inqbuf->vendor, sizeof vend - 1);
@


1.102
log
@grrr var names in protos
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.101 2010/04/10 17:26:10 marco Exp $ */
d306 1
a306 1
	    &nsegs, BUS_DMA_NOWAIT) != 0)
a319 1
	memset(mm->am_kva, 0, size);
@


1.101
log
@sprinkle some bus_dmamap_sync around frame access.
prompted by oga
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.100 2010/03/23 01:57:19 krw Exp $ */
d112 4
a115 4
u_int32_t	mfi_xscale_fw_state(struct mfi_softc *sc);
void		mfi_xscale_intr_ena(struct mfi_softc *sc);
int		mfi_xscale_intr(struct mfi_softc *sc);
void		mfi_xscale_post(struct mfi_softc *sc, struct mfi_ccb *ccb);
d124 4
a127 4
u_int32_t	mfi_ppc_fw_state(struct mfi_softc *sc);
void		mfi_ppc_intr_ena(struct mfi_softc *sc);
int		mfi_ppc_intr(struct mfi_softc *sc);
void		mfi_ppc_post(struct mfi_softc *sc, struct mfi_ccb *ccb);
d136 4
a139 4
u_int32_t	mfi_gen2_fw_state(struct mfi_softc *sc);
void		mfi_gen2_intr_ena(struct mfi_softc *sc);
int		mfi_gen2_intr(struct mfi_softc *sc);
void		mfi_gen2_post(struct mfi_softc *sc, struct mfi_ccb *ccb);
@


1.100
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.99 2010/01/09 23:15:06 krw Exp $ */
d110 2
d219 1
d772 1
a772 1
	mfi_post(sc, ccb);
d830 1
a830 1
			ccb->ccb_done(ccb);
d1101 1
a1101 1
	mfi_post(sc, ccb);
d1225 1
a1225 1
		mfi_post(sc, ccb);
d2002 21
@


1.99
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.98 2010/01/04 08:04:43 dlg Exp $ */
d58 1
a58 1
int	mfi_scsi_cmd(struct scsi_xfer *);
d977 1
a977 1
int
d1005 5
a1009 1
		return (NO_CCB);
d1095 1
a1095 1
		return (COMPLETE);
d1103 1
a1103 1
	return (SUCCESSFULLY_QUEUED);
a1110 1
	return (COMPLETE);
@


1.98
log
@rename ccb_xs to ccb_cookie and change its type from a scsi_xfer * to a
void *. this lets us pass things other than scsi_xfers to ccb completion
handlers.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.97 2010/01/04 07:57:28 dlg Exp $ */
a924 1
	xs->flags |= ITSDONE;
a1087 1
		xs->flags |= ITSDONE;
a1103 1
	xs->flags |= ITSDONE;
@


1.97
log
@protect the ccb free queue with a mutex rather than splbio
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.96 2010/01/03 14:57:10 chl Exp $ */
d180 1
a180 1
	ccb->ccb_xs = NULL;
d873 1
a873 1
	ccb->ccb_xs = xs;
d889 1
a889 1
	struct scsi_xfer	*xs = ccb->ccb_xs;
d956 1
a956 1
	ccb->ccb_xs = xs;
@


1.96
log
@change M_WAITOK --> M_WAITOK|M_CANFAIL

with input from marco@@

ok marco@@ krw@@

this was ok looooooooong time ago but lost in my mailbox
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.95 2009/04/30 01:24:05 marco Exp $ */
a154 1
	int			s;
d156 1
a156 1
	s = splbio();
d158 1
a158 1
	if (ccb) {
d162 1
a162 1
	splx(s);
a173 1
	int			s;
d190 1
a190 1
	s = splbio();
d192 1
a192 1
	splx(s);
d642 1
@


1.95
log
@Add READ(16) & WRITE(16) commands.
ok krw
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.94 2009/04/29 00:48:24 marco Exp $ */
d1923 1
a1923 1
	    M_DEVBUF, M_WAITOK|M_ZERO);
@


1.94
log
@MFI_D_IOCTL should be commented out.  No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.93 2009/04/04 03:22:30 dlg Exp $ */
d87 1
a87 1
int		mfi_scsi_io(struct mfi_ccb *, struct scsi_xfer *, uint32_t,
d843 1
a843 1
mfi_scsi_io(struct mfi_ccb *ccb, struct scsi_xfer *xs, uint32_t blockno,
d868 2
a869 2
	io->mif_lba_hi = 0;
	io->mif_lba_lo = blockno;
d988 3
a990 1
	uint32_t		blockno, blockcnt;
d1017 1
a1017 1
		blockno = _4btol(rwb->addr);
d1028 2
a1029 1
		blockno = _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);
d1031 11
@


1.93
log
@scrub more fields in the ccb when returning them to the free list after
theyve been used, in particular the mfi header flags which has a bit
that specifies if a command should be completed via the interrupt path.

if we use a ccb during boot we set that bit, but it isnt necessarily
cleared by things that use it later on. this means a ccb we expected to
complete via an interrupt never actually generates an interrupt or appears
in the reply queue. this obviously stalls the io.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.92 2009/03/29 15:03:17 marco Exp $ */
d47 1
a47 1
		    | MFI_D_IOCTL
@


1.92
log
@spello
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.91 2009/03/29 01:05:56 dlg Exp $ */
d174 1
d179 2
a180 1
	s = splbio();
d191 2
@


1.91
log
@when we steal the SYNC CACHE command in mfi_scsi_cmd we still have to
mark the xs as done and call scsi_done for it rather than just returning
COMPLETE.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.90 2009/03/29 01:02:35 dlg Exp $ */
d1487 1
a1487 1
	 * a subset that is valid for the MFI contrller.
@


1.90
log
@fix a small race in mfi_mgmt between the checking of a ccbs completion and
the sleep waiting for the completion. it is possible to get the interrupt
completing the command just before the tsleep, which will never get a
wakeup because the interrupt with the wakeup has already happened.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.88 2009/01/28 23:45:12 marco Exp $ */
d1038 1
a1038 1
		return (COMPLETE);
d1088 1
@


1.89
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1166 1
d1203 1
d1209 1
@


1.88
log
@Add support for next generation megaraid sas raid controllers.
From Jim Giannoules <gortag@@gmail.com>
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.87 2008/10/31 21:39:04 marco Exp $ */
d60 1
a60 1
void	mfiminphys(struct buf *bp);
d603 1
a603 1
mfiminphys(struct buf *bp)
@


1.87
log
@Generalize function to obtain all details to do bio stuff.  This is in
preparation to start showing unsused disks which will require all this
information to do the math.

While at it fix a size of hotspare volume bug.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.86 2008/10/30 19:20:13 marco Exp $ */
d134 12
d627 3
d2043 35
@


1.86
log
@Fix bug that when there are no volumes but there are hot spares it would
no show the hotspares.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.85 2008/10/28 21:44:25 marco Exp $ */
d96 1
a444 1

d1299 73
a1373 1
	struct mfi_conf		*cfg;
d1375 1
d1379 2
a1380 2
	if (mfi_get_info(sc)) {
		DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_inq failed\n",
d1382 1
a1382 1
		return (EIO);
d1385 4
a1388 4
	/* get figures */
	cfg = malloc(sizeof *cfg, M_DEVBUF, M_WAITOK);
	if (mfi_mgmt(sc, MD_DCMD_CONF_GET, MFI_DATA_IN, sizeof *cfg, cfg, NULL))
		goto freeme;
d1390 7
a1397 2
	bi->bi_novol = cfg->mfc_no_ld + cfg->mfc_no_hs;
	bi->bi_nodisk = sc->sc_info.mci_pd_disks_present;
d1400 1
a1400 2
freeme:
	free(cfg, M_DEVBUF);
a1407 1
	uint8_t			mbox[MFI_MBOX_SIZE];
d1412 4
a1415 2
	if (mfi_mgmt(sc, MR_DCMD_LD_GET_LIST, MFI_DATA_IN,
	    sizeof(sc->sc_ld_list), &sc->sc_ld_list, NULL))
d1417 1
d1420 1
a1420 1
		/* go do hotspares */
a1425 8
	mbox[0] = sc->sc_ld_list.mll_list[i].mll_ld.mld_target;
	DNPRINTF(MFI_D_IOCTL, "%s: mfi_ioctl_vol target %#x\n",
	    DEVNAME(sc), mbox[0]);

	if (mfi_mgmt(sc, MR_DCMD_LD_GET_INFO, MFI_DATA_IN,
	    sizeof(sc->sc_ld_details), &sc->sc_ld_details, mbox))
		goto done;

d1450 1
a1450 1
	switch (sc->sc_ld_details.mld_progress.mlp_in_prog) {
d1454 1
a1454 1
		per = (int)sc->sc_ld_details.mld_progress.mlp_cc.mp_progress;
d1457 1
a1457 1
		    sc->sc_ld_details.mld_progress.mlp_cc.mp_elapsed_seconds;
d1470 2
a1471 2
	bv->bv_level = sc->sc_ld_details.mld_cfg.mlc_parm.mpa_pri_raid;
	if (sc->sc_ld_details.mld_cfg.mlc_parm.mpa_sec_raid ==
d1475 2
a1476 2
	bv->bv_nodisk = sc->sc_ld_details.mld_cfg.mlc_parm.mpa_no_drv_per_span *
	    sc->sc_ld_details.mld_cfg.mlc_parm.mpa_span_depth;
d1478 1
a1478 1
	bv->bv_size = sc->sc_ld_details.mld_size * 512; /* bytes per block */
a1495 1
	uint32_t		size;
d1501 8
a1510 13
	/* send single element command to retrieve size for full structure */
	cfg = malloc(sizeof *cfg, M_DEVBUF, M_WAITOK);
	if (mfi_mgmt(sc, MD_DCMD_CONF_GET, MFI_DATA_IN, sizeof *cfg, cfg, NULL))
		goto freeme;

	size = cfg->mfc_size;
	free(cfg, M_DEVBUF);

	/* memory for read config */
	cfg = malloc(size, M_DEVBUF, M_WAITOK|M_ZERO);
	if (mfi_mgmt(sc, MD_DCMD_CONF_GET, MFI_DATA_IN, size, cfg, NULL))
		goto freeme;

a1561 1

a1588 1
	free(cfg, M_DEVBUF);
d1810 1
a1810 2
	if (volid > (cfg->mfc_no_ld + cfg->mfc_no_hs)) {
		/* deal with unused disks */
a1811 1
	}
d1834 1
a1834 1
		vdhs->bv_size = pd->mpd_size / 2; /* XXX why? / 2 */
d1842 1
a1842 1
		sdhs->bd_size = pd->mpd_size / 2; /* XXX why? / 2 */
@


1.85
log
@Fix output when reporting on multivolume disk groups.

Reported by mitja@@muzenic.net
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.84 2008/10/27 03:11:58 marco Exp $ */
d1340 6
a1354 6
	if (bv->bv_volid >= sc->sc_ld_list.mll_no_ld) {
		/* go do hotspares */
		rv = mfi_bio_hs(sc, bv->bv_volid, MFI_MGMT_VD, bv);
		goto done;
	}

d1747 2
a1748 1
	if (volid > (cfg->mfc_no_ld + cfg->mfc_no_hs))
d1750 1
@


1.84
log
@Move some include stuff around
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.83 2008/10/26 18:56:00 marco Exp $ */
d1423 2
a1424 2
	int			i, rv = EINVAL;
	int			arr, vol, disk;
a1446 6

	/* calculate offset to ld structure */
	ld = (struct mfi_ld_cfg *)(
	    ((uint8_t *)cfg) + offsetof(struct mfi_conf, mfc_array) +
	    cfg->mfc_array_size * cfg->mfc_no_array);

a1447 1

d1454 11
a1464 3
	/* find corresponding array for ld */
	for (i = 0, arr = 0; i < vol; i++)
		arr += ld[i].mlc_parm.mpa_span_depth;
d1468 1
d1470 1
a1470 4
	/* offset array index into the next spans */
	arr += bd->bd_diskid / ld[vol].mlc_parm.mpa_no_drv_per_span;

	bd->bd_target = ar[arr].pd[disk].mar_enc_slot;
@


1.83
log
@Space
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.82 2008/10/23 00:30:04 marco Exp $ */
d29 1
d37 1
a39 5

#if NBIO > 0
#include <dev/biovar.h>
#include <sys/sensors.h>
#endif /* NBIO > 0 */
@


1.82
log
@Fix PR5645
ok dlg
tested beck and others
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.81 2008/09/25 11:23:54 krw Exp $ */
a1233 1

@


1.81
log
@Initialize 'ssc' to NULL since we test it later. Shouldn't ever be
NULL at the point of test unless the device list is confused, but
be consistantly paranoid if we're going to be paranoid.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.80 2008/02/16 15:24:05 krw Exp $ */
d1478 2
a1479 1
		bd->bd_status = BIOC_SDUNUSED;
a1489 4
	case MFI_PD_FAILED:
		bd->bd_status = BIOC_SDFAILED;
		break;

d1508 3
a1510 1
	    sizeof *pd, pd, mbox))
d1512 1
@


1.80
log
@Return NO_CCB and not TRY_AGAIN_LATER when running out of ccb's.
Eliminates 'not queued' errors reported on the mailing lists.

Tested by Michael (belenus at bsdmail dot de).

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.79 2008/02/11 01:07:02 dlg Exp $ */
d1811 1
a1811 1
	struct scsibus_softc	*ssc;
@


1.79
log
@add support for the mfi controllers with the ppc iops, aka, LSI SAS1078 or
Dell PERC6.

committed off a machine booting and rooting off a perc6. tested on a perc5
by marco@@
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.78 2008/01/26 08:57:31 brad Exp $ */
d989 1
a989 1
		return (TRY_AGAIN_LATER);
@


1.78
log
@Set the return value instead of returning right away so that the DMA
memory is actually synched.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.77 2008/01/26 07:13:59 dlg Exp $ */
a85 1
int		mfi_dispatch_cmd(struct mfi_ccb *);
d112 29
d338 1
a338 1
	fw_state = mfi_read(sc, MFI_OMSG0) & MFI_STATE_MASK;
d375 1
a375 1
			fw_state = mfi_read(sc, MFI_OMSG0) & MFI_STATE_MASK;
d605 1
a605 1
mfi_attach(struct mfi_softc *sc)
d611 11
d631 1
a631 1
	status = mfi_read(sc, MFI_OMSG0);
d716 1
a716 1
	mfi_write(sc, MFI_OMSK, MFI_ENABLE_INTR);
a741 12
mfi_dispatch_cmd(struct mfi_ccb *ccb)
{
	DNPRINTF(MFI_D_CMD, "%s: mfi_dispatch_cmd\n",
	    DEVNAME(ccb->ccb_sc));

	mfi_write(ccb->ccb_sc, MFI_IQP, (ccb->ccb_pframe >> 3) |
	    ccb->ccb_extra_frames);

	return(0);
}

int
d754 1
a754 1
	mfi_dispatch_cmd(ccb);
d786 1
a786 1
	uint32_t		status, producer, consumer, ctx;
d789 2
a790 7
	status = mfi_read(sc, MFI_OSTS);
	if ((status & MFI_OSTS_INTR_VALID) == 0)
		return (claimed);
	/* write status back to acknowledge interrupt */
	mfi_write(sc, MFI_OSTS, status);

	DNPRINTF(MFI_D_INTR, "%s: mfi_intr %#x %#x\n", DEVNAME(sc), sc, pcq);
d796 2
a1051 1
			mfi_put_ccb(ccb);
a1056 5
			xs->flags |= ITSDONE;
			s = splbio();
			scsi_done(xs);
			splx(s);
			return (COMPLETE);
a1057 2
		DNPRINTF(MFI_D_DMA, "%s: mfi_scsi_cmd poll complete %d\n",
		    DEVNAME(sc), ccb->ccb_dmamap->dm_nsegs);
d1060 4
d1067 1
a1067 1
	mfi_dispatch_cmd(ccb);
d1190 1
a1190 1
		mfi_dispatch_cmd(ccb);
d1905 69
@


1.77
log
@sync dma mem back to the cpu on poll failure.

from mickey via pr5714
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.76 2008/01/26 07:04:50 dlg Exp $ */
d738 1
a738 1
		return (1);
@


1.76
log
@despatch -> dispatch

disparate spellink fix from mickey
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.75 2007/11/05 23:43:26 krw Exp $ */
d717 1
d719 1
a719 1
	int			to = 0;
d721 1
a721 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_poll\n", DEVNAME(ccb->ccb_sc));
d735 1
a735 1
		printf("%s: timeout on ccb %d\n", DEVNAME(ccb->ccb_sc),
d740 11
a750 2
	
	return (0);
@


1.75
log
@More scsi_done() at SPLBIO.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.74 2007/09/27 08:45:19 chl Exp $ */
d86 1
a86 1
int		mfi_despatch_cmd(struct mfi_ccb *);
d703 1
a703 1
mfi_despatch_cmd(struct mfi_ccb *ccb)
d705 1
a705 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_despatch_cmd\n",
d726 1
a726 1
	mfi_despatch_cmd(ccb);
d1037 1
a1037 1
	mfi_despatch_cmd(ccb);
d1160 1
a1160 1
		mfi_despatch_cmd(ccb);
@


1.74
log
@M_ZERO changes

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.73 2007/06/24 05:34:35 dlg Exp $ */
d941 1
d1025 1
d1027 1
d1047 1
d1049 1
@


1.73
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.72 2007/05/29 22:17:50 todd Exp $ */
d165 1
a165 2
	    M_DEVBUF, M_WAITOK);
	memset(sc->sc_ccb, 0, sizeof(struct mfi_ccb) * sc->sc_max_cmds);
d252 1
a252 1
	mm = malloc(sizeof(struct mfi_mem), M_DEVBUF, M_NOWAIT);
a255 1
	memset(mm, 0, sizeof(struct mfi_mem));
d1411 1
a1411 2
	cfg = malloc(size, M_DEVBUF, M_WAITOK);
	memset(cfg, 0, size);
d1704 1
a1704 2
	cfg = malloc(size, M_DEVBUF, M_WAITOK);
	memset(cfg, 0, size);
d1793 1
a1793 1
	    M_DEVBUF, M_WAITOK);
a1795 1
	bzero(sc->sc_sensors, sizeof(struct ksensor) * sc->sc_ld_cnt);	
@


1.72
log
@sprinkle some SMALL_KERNEL to permit bio/softraid to run on boot media
ok marco@@ then suggested deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.71 2007/03/22 16:55:31 deraadt Exp $ */
d1820 1
a1820 1
	if (sensor_task_register(sc, mfi_refresh_sensors, 10) != 0)
@


1.71
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.70 2007/02/14 00:53:16 dlg Exp $ */
d107 1
d110 1
d687 1
d690 1
d1775 1
d1873 1
@


1.70
log
@bus_space does byte swapping to cope with host endianness for us, so remove
an unnecessary htole32().
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.68 2007/02/08 03:20:52 ray Exp $ */
d1791 1
a1791 1
	sc->sc_sensors = malloc(sizeof(struct sensor) * sc->sc_ld_cnt,
d1795 1
a1795 1
	bzero(sc->sc_sensors, sizeof(struct sensor) * sc->sc_ld_cnt);	
@


1.69
log
@Fix subtle x ? y : z bug when calling mfi_create_sgl.  This worked because
during runtime the bug condition does not happen.

ok krw joris
@
text
@d706 2
a707 2
	mfi_write(ccb->ccb_sc, MFI_IQP, htole32((ccb->ccb_pframe >> 3) |
	    ccb->ccb_extra_frames));
@


1.68
log
@Remove double semicolons.

From Pierre Riteau <pierre dot riteau at free dot fr>.

OK marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.67 2006/12/23 17:46:39 deraadt Exp $ */
d828 2
a829 2
	if (mfi_create_sgl(ccb, xs->flags & SCSI_NOSLEEP) ?
	    BUS_DMA_NOWAIT : BUS_DMA_WAITOK)
d919 2
a920 2
		if (mfi_create_sgl(ccb, xs->flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK)
@


1.67
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.66 2006/11/28 23:59:45 dlg Exp $ */
d1578 1
a1578 1
	*((uint16_t *)&mbox) = pd->mpl_address[i].mpa_pd_id;;
d1635 1
a1635 1
	*((uint16_t *)&mbox) = pd->mpl_address[i].mpa_pd_id;;
@


1.66
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.65 2006/08/31 18:13:17 marco Exp $ */
d1797 3
a1808 2
		strlcpy(sc->sc_sensors[i].device, DEVNAME(sc),
		    sizeof(sc->sc_sensors[i].device));
d1812 1
a1812 1
		sensor_add(&sc->sc_sensors[i]);
d1818 2
a1822 2
	while (--i >= 0)
		sensor_del(&sc->sc_sensors[i]);
@


1.65
log
@Add sensor thread for individual sd devices.

tested dlg
ok dlg deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.64 2006/08/30 07:25:52 dlg Exp $ */
d579 1
d671 4
a674 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
@


1.64
log
@when determining the size of the volumes and disks we want how many
bytes each of them has, not the number of kilobytes. this solves the
"why am i dividing by 2" question. the answer is "you dont, you multiply
by 512".
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.63 2006/07/28 20:38:57 brad Exp $ */
d41 1
d107 2
a641 7
#if NBIO > 0
	if (bio_register(&sc->sc_dev, mfi_ioctl) != 0)
		panic("%s: controller registration failed", DEVNAME(sc));
	else
		sc->sc_ioctl = mfi_ioctl;
#endif /* NBIO > 0 */

d675 10
d1767 96
@


1.63
log
@make dmesg printing look a little bit nicer.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.62 2006/06/19 21:49:44 marco Exp $ */
d1364 1
a1364 1
	bv->bv_size = sc->sc_ld_details.mld_size / 2; /* XXX why? / 2 */
d1468 1
a1468 1
	bd->bd_size = pd->mpd_size / 2; /* XXX why? / 2 */
@


1.62
log
@Factor for disk size is /2.  Odd but tested on all mfis I have.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.61 2006/06/19 21:06:22 miod Exp $ */
d652 1
a652 1
	printf("%s: logical drives %d version %s RAM %dMB\n",
@


1.61
log
@Everytime one forgets an argument in a printf-like function call, God kills
a kitten. Commiters, please think of the kittens when working on code.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.60 2006/06/19 19:09:04 marco Exp $ */
d1364 1
a1364 1
	bv->bv_size = sc->sc_ld_details.mld_size * (u_quad_t)512;
d1468 1
a1468 1
	bd->bd_size = pd->mpd_size;
d1731 1
a1731 1
		vdhs->bv_size = pd->mpd_size;
d1739 1
a1739 1
		sdhs->bd_size = pd->mpd_size;
@


1.60
log
@Make a BGI (Back Ground Init) a scrub instead of rebuild.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.59 2006/06/19 19:05:45 marco Exp $ */
d647 2
a648 1
		printf("%s: could not retrieve controller information\n");
@


1.59
log
@Add hot spare support.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.58 2006/05/26 00:53:54 marco Exp $ */
d1337 1
a1342 8
		break;

	case MFI_LD_PROG_BGI:
		bv->bv_status = BIOC_SVBUILDING;
		per = (int)sc->sc_ld_details.mld_progress.mlp_bgi.mp_progress;
		bv->bv_percent = (per * 100) / 0xffff;
		bv->bv_seconds =
		    sc->sc_ld_details.mld_progress.mlp_bgi.mp_elapsed_seconds;
@


1.58
log
@Add blinking for disks.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.57 2006/05/25 22:04:35 marco Exp $ */
d82 2
a83 2
u_int32_t	mfi_read(struct mfi_softc *, bus_size_t);
void		mfi_write(struct mfi_softc *, bus_size_t, u_int32_t);
d105 1
d216 1
a216 1
u_int32_t
d219 1
a219 1
	u_int32_t rv;
d230 1
a230 1
mfi_write(struct mfi_softc *sc, bus_size_t r, u_int32_t v)
d1257 5
d1268 5
d1274 1
a1274 1
	bi->bi_novol = sc->sc_info.mci_lds_present;
d1277 4
a1280 1
	return (0);
d1305 3
a1307 2
	if (bv->bv_volid > sc->sc_ld_list.mll_no_ld) {
		/* XXX go do hotspares */
d1419 3
a1421 2
	if (vol > cfg->mfc_no_ld) {
		/* XXX do hotspares */
d1441 1
a1441 1
	case MFI_PD_HOTSPARE:
d1549 3
d1574 2
a1577 1
		*((uint16_t *)&mbox) = pd->mpl_address[i].mpa_pd_id;;
a1581 1
		*((uint16_t *)&mbox) = pd->mpl_address[i].mpa_pd_id;;
d1605 62
a1666 1
	return (ENOTTY); /* XXX not yet */
d1668 99
@


1.57
log
@Move a int i; to top of function so that it compiles on non c99 compilers.
Pointed out by miod@@

The enclosure id modifier didn't reflect reality so move it back to whatever
the raid card uses.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.56 2006/05/25 04:23:57 marco Exp $ */
d103 1
d1233 5
d1522 58
@


1.56
log
@And add time and percentage to builds and check consistencies.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.55 2006/05/25 02:15:47 marco Exp $ */
d404 3
a413 1
	int i;
d1455 1
a1455 4
	if (pd->mpd_enc_idx)
		bd->bd_channel = pd->mpd_enc_idx - 1; /* fw numbers ch from 1 */
	else
		bd->bd_channel = 0;
@


1.55
log
@Add last bit of physcal disk stuff.
Remove bogus memset.
Hotspares still don't work.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.54 2006/05/25 00:21:31 marco Exp $ */
d1264 1
a1264 1
	int			i, rv = EINVAL;
d1309 24
@


1.54
log
@Add physical device and read config structures.
Add initial part of BIOCDISK
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.53 2006/05/23 03:55:41 deraadt Exp $ */
d1336 3
d1342 1
d1347 1
a1347 1
	memset(&cfg, 0, sizeof cfg);
d1352 1
a1352 1
		goto done;
a1387 1

d1420 22
d1444 1
d1446 1
a1446 2
	cfg = NULL;
done:
@


1.53
log
@commited with unused variable
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.52 2006/05/23 00:44:41 marco Exp $ */
a673 3
	/* memory for physical disk map */
	sc->sc_pd_list = malloc(MFI_PD_LIST_SIZE, M_DEVBUF, M_WAITOK);

d1333 6
a1338 1
	int			rv = EINVAL;
d1343 5
a1347 2
	if (mfi_mgmt(sc, MR_DCMD_PD_GET_LIST, MFI_DATA_IN,
	    MFI_PD_LIST_SIZE, sc->sc_pd_list, NULL))
d1349 68
d1418 3
@


1.52
log
@Remove some debug cruft.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.51 2006/05/23 00:43:57 marco Exp $ */
d1336 1
a1336 1
	int			i, rv = EINVAL;
@


1.51
log
@Add first half of physical disk data for bio.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.50 2006/05/22 19:50:43 marco Exp $ */
a1312 8

#if 0
	printf("drv/span %d   span depth %d   raid qual %#x   sec raid %#x\n",
	    sc->sc_ld_details.mld_cfg.mlc_parm.mpa_no_drv_per_span,
	    sc->sc_ld_details.mld_cfg.mlc_parm.mpa_span_depth,
	    sc->sc_ld_details.mld_cfg.mlc_parm.mpa_raid_qual,
	    sc->sc_ld_details.mld_cfg.mlc_parm.mpa_sec_raid);
#endif
@


1.50
log
@Add support for raid 50 and 10 in bio.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.49 2006/05/22 02:24:11 marco Exp $ */
d674 3
d1344 11
a1354 1
	return (ENOTTY); /* XXX not yet */
@


1.49
log
@Add mail box to mfi_mgmt to handle sub commands more gracefully.
Remove some debug crud that snuck in the TEST_UNIT_READY case.
Finish other half of BIOCVOL primitive.
Add several structures to fill out the BIOCVOL primitive.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.48 2006/05/22 01:08:39 marco Exp $ */
d1312 1
a1312 1
	printf("drv/span %d   span depth%d\n",
d1314 3
a1316 1
	    sc->sc_ld_details.mld_cfg.mlc_parm.mpa_span_depth);
d1318 5
d1324 4
a1327 1
	
@


1.48
log
@Add first half of BIOCVOL primitive.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.47 2006/05/21 22:56:45 marco Exp $ */
d94 1
a94 1
		    void *);
d407 1
a407 1
	    sizeof(sc->sc_info), &sc->sc_info))
d923 1
a923 1
	uint8_t			flushcmd;
d969 1
a969 1
		flushcmd = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;
d971 2
a972 2
		    sizeof(flushcmd), &flushcmd))
			goto stuffup;;
a978 2
		printf("%#x  %#x  %#x  %d\n", sc, target, dev,
		    sizeof(sc->sc_ld[target].ld_dev));
d1097 1
a1097 1
    void *buf)
d1120 3
a1122 6
	/* handle special opcodes, use the buffer parameter */
	switch (opc) {
	case MR_DCMD_CTRL_CACHE_FLUSH:
		dcmd->mdf_mbox[0] = *((uint8_t *)buf);
		break;
	}
d1265 1
d1271 10
a1280 1
	    sizeof(sc->sc_ld_list), &sc->sc_ld_list))
a1287 2
	i = bv->bv_volid;

d1312 3
a1314 3
	bv->bv_level = 5;
	bv->bv_nodisk = 2;
	bv->bv_size = sc->sc_ld_list.mll_list[i].mll_size;
d1316 7
d1369 1
a1369 1
	if (mfi_mgmt(sc, opc, dir, sizeof(ret), &ret))
@


1.47
log
@Do a giant flush of disk and raid-card memory when SYNCHONIZE_CACHE is called.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.46 2006/05/21 21:55:44 marco Exp $ */
d46 2
a47 2
		    | MFI_D_INTR
		    | MFI_D_MISC
d917 1
d978 9
d1269 47
a1315 1
	return (ENOTTY); /* XXX not yet */
@


1.46
log
@pretty up some debug statements.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.45 2006/05/21 21:44:50 marco Exp $ */
d922 1
d965 11
d1111 7
@


1.45
log
@Add bio alarm function.
Redo mfi_mgmt to deal with zero data commands.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.44 2006/05/21 20:20:17 marco Exp $ */
d1187 1
a1187 1
		DNPRINTF(MFI_D_IOCTL, "inq ");
d1192 1
a1192 1
		DNPRINTF(MFI_D_IOCTL, "vol ");
d1197 1
a1197 1
		DNPRINTF(MFI_D_IOCTL, "disk ");
d1202 1
a1202 1
		DNPRINTF(MFI_D_IOCTL, "alarm ");
d1207 1
a1207 1
		DNPRINTF(MFI_D_IOCTL, "setstate ");
d1279 2
a1280 2
		DNPRINTF(AMI_D_IOCTL, ("%s: biocalarm invalid opcode %x\n",
		    DEVNAME(sc), ba->ba_opcode));
@


1.44
log
@Add generic management function.
Redo ccb_state flags so that we can actually sleep on it.
Redo mfi_get_info to use new mgmt function.
Add rw_locks for mgmt interface.
Make BIOCINQ dynamic.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.43 2006/05/21 04:07:10 marco Exp $ */
a1092 1
	dcmd->mdf_header.mfh_data_len = len;
d1094 1
a1094 2
	ccb->ccb_data = buf;
	ccb->ccb_len = len;
a1098 1
	ccb->ccb_sgl = &dcmd->mdf_sgl;
d1100 9
a1108 2
	if (mfi_create_sgl(ccb, BUS_DMA_WAITOK))
		goto done;
d1252 41
a1292 1
	return (ENOTTY); /* XXX not yet */
@


1.43
log
@Oops, helps to use the right structure field.
Use actual nr of physical disks present.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.42 2006/05/21 04:03:06 marco Exp $ */
d28 1
a28 1
#include <sys/lock.h>
d45 1
a45 1
		    | MFI_D_CMD
d48 1
a48 1
		    | MFI_D_DMA
d51 1
a51 1
		    | MFI_D_MEM
a85 1

d88 2
a89 1
/* LD commands */
d93 3
a95 1
int		mfi_scsi_ld(struct mfi_ccb *, struct scsi_xfer *);
a403 4
	struct mfi_ccb		*ccb;
	struct mfi_dcmd_frame	*dcmd;
	int			rv = 1;

d406 3
a408 24
	if ((ccb = mfi_get_ccb(sc)) == NULL)
		return (rv);

	dcmd = &ccb->ccb_frame->mfr_dcmd;
	memset(dcmd->mdf_mbox, 0, MFI_MBOX_SIZE);
	dcmd->mdf_header.mfh_cmd = MFI_CMD_DCMD;
	dcmd->mdf_header.mfh_timeout = 0;
	dcmd->mdf_header.mfh_data_len = sizeof(struct mfi_ctrl_info);

	dcmd->mdf_opcode = MR_DCMD_CTRL_GET_INFO;

	ccb->ccb_data = &sc->sc_info;
	ccb->ccb_len = sizeof(struct mfi_ctrl_info);
	ccb->ccb_frame_size = MFI_DCMD_FRAME_SIZE;
	ccb->ccb_direction = MFI_DATA_IN;
	ccb->ccb_sgl = &dcmd->mdf_sgl;

	if (mfi_create_sgl(ccb, BUS_DMA_NOWAIT))
		goto done;

	if (mfi_poll(ccb))
		goto done;

	rv = 0;
d555 1
a555 3
done:
	mfi_put_ccb(ccb);
	return (rv);
d582 2
d1076 81
d1177 3
a1179 1
	DNPRINTF(MFI_D_IOCTL, "%s: ioctl ", DEVNAME(sc));
d1212 2
d1220 6
a1225 1
	/* XXX this is static and needs to become dynamic */
@


1.42
log
@Add first BIOCINQ primitive.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.41 2006/05/18 17:42:00 marco Exp $ */
d1161 1
a1161 1
	bi->bi_nodisk = sc->sc_info.mci_pd_present;
@


1.41
log
@Remove some debug cruft and pretty up some debug messages.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.40 2006/05/18 17:34:23 marco Exp $ */
d1158 6
a1163 1
	return (ENOTTY); /* XXX not yet */
@


1.40
log
@Kill splbio/splx in the interrupt handler.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.39 2006/05/18 17:25:02 marco Exp $ */
d221 1
a221 1
	DNPRINTF(MFI_D_RW, "mr 0x%x 0x08%x ", r, rv);
d228 1
a228 1
	DNPRINTF(MFI_D_RW, "mw 0x%x 0x%08x", r, v);
a876 5
	#if 0
			xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
			xs->sense.flags = SKEY_ILLEGAL_REQUEST;
			xs->sense.add_sense_code = 0x20; /* invalid opcode */
	#endif
a939 1
	/* struct device		*dev = link->device_softc; */
a948 8
	/* only issue IO through this path, create seperate path for mgmt */
#if 0
	if (!cold) {
		DNPRINTF(MFI_D_CMD, "%s: no interrupt io yet %02x\n",
		    DEVNAME(sc), xs->cmd->opcode);
		goto stuffup;
	}
#endif
d1104 1
a1104 1
	DNPRINTF(MFI_D_IOCTL, "mfi_scsi_ioctl\n");
@


1.39
log
@And we have lift off!  Was able to create a filesystem and write to the
filesystem.

Collapse both completion routines into one.
Fixup scsi error reporting in the completion routine.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.38 2006/05/17 23:40:26 marco Exp $ */
a756 1
	int			s;
a761 1
	s = splbio();
a793 1
	splx(s);
@


1.38
log
@Add completion routines.
Fix some bugs inside the interrupt handler.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.37 2006/05/17 21:50:21 marco Exp $ */
d92 1
a92 1
void		mfi_scsi_io_done(struct mfi_ccb *);
a93 1
void		mfi_scsi_ld_done(struct mfi_ccb *);
d757 1
d763 1
d796 1
a800 40
void
mfi_scsi_io_done(struct mfi_ccb *ccb)
{
	struct scsi_xfer	*xs = ccb->ccb_xs;
	struct mfi_softc	*sc = ccb->ccb_sc;
	struct mfi_frame_header	*hdr = &ccb->ccb_frame->mfr_header;

	DNPRINTF(MFI_D_CMD, "%s: mfi_scsi_io_done %#x\n", DEVNAME(sc), ccb);

	if (xs->data != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

	if (hdr->mfh_cmd_status == MFI_STAT_OK)
		xs->error = XS_DRIVER_STUFFUP;
	else if (hdr->mfh_scsi_status != 0) {
		bzero(&xs->sense, sizeof(xs->sense));
		memcpy(&xs->sense, ccb->ccb_sense,
		    sizeof(struct scsi_sense_data));
#if 0
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* invalid opcode */
#endif
		xs->error = XS_SENSE;
		xs->flags |= ITSDONE;
	}

	xs->resid = 0;
	xs->flags |= ITSDONE;

	mfi_put_ccb(ccb);
	scsi_done(xs);
}

d832 1
a832 1
	ccb->ccb_done = mfi_scsi_io_done;
d847 1
a847 1
mfi_scsi_ld_done(struct mfi_ccb *ccb)
d853 2
a854 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_scsi_ld_done %#x\n", DEVNAME(sc), ccb);
d857 2
d867 1
a867 1
	if (hdr->mfh_cmd_status == MFI_STAT_OK)
d869 18
a886 11
	else if (hdr->mfh_scsi_status != 0) {
		bzero(&xs->sense, sizeof(xs->sense));
		memcpy(&xs->sense, ccb->ccb_sense,
		    sizeof(struct scsi_sense_data));
#if 0
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* invalid opcode */
#endif
		xs->error = XS_SENSE;
		xs->flags |= ITSDONE;
d920 1
a920 1
	ccb->ccb_done = mfi_scsi_ld_done;
d973 2
a974 1
	if ((ccb = mfi_get_ccb(sc)) == NULL)
d976 1
@


1.37
log
@Add mfi_get_info to obtain all kinds of fun information from the fw.
Print out whole info structure when debug is enabled.
Add a nice print with useful info during attach.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.36 2006/05/17 16:00:52 marco Exp $ */
d90 3
d189 1
a189 1
		    "ccb(%d): %p frame: %x (%x) sense: %x (%x) map: %x\n",
d385 1
a385 1
	DNPRINTF(MFI_D_MISC, "%s: entries: %x rq: %x pi: %x ci: %x\n",
d463 1
a463 1
	printf("%s: serial %s present %.x fw time %d max_cmds %d max_sg %d\n",
d498 1
a498 1
	printf("%s: max_strps_io %d raid_lvl %.x adapt_ops %.x ld_ops %.x\n",
d505 1
a505 1
	printf("%s: strp_sz_min %d strp_sz_max %d pd_ops %.x pd_mix %.x\n",
d553 1
a553 1
	printf("%s: vendor %.x device %.x subvendor %.x subdevice %.x\n",
d560 1
a560 1
	printf("%s: type %.x port_count %d port_addr ",
d636 1
a636 1
		    DEVNAME(sc), MFIMEM_DVA(sc->sc_pcq));
d755 1
d757 1
a757 1
	int			s, claimed = 0;
d765 1
a765 1
	DNPRINTF(MFI_D_INTR, "%s: mfi_intr\n", DEVNAME(sc));
a770 1
	s = splbio();
d772 3
d782 5
d790 1
a790 1
		if (consumer == sc->sc_max_cmds)
a792 1
	splx(s);
d800 85
a886 1
#ifdef MFI_DEBUG
d888 31
a918 1
	struct scsi_link	*link = xs->sc_link;
d920 2
a921 3
	DNPRINTF(MFI_D_CMD, "%s: mfi_ld_done_inquiry: %.0x\n",
	    DEVNAME(ccb->ccb_sc), link->target);
#endif /* MFI_DEBUG */
d978 4
a981 1
	u_int8_t		target = link->target;
d983 1
a983 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_scsi_cmd opcode: %02x\n",
d987 1
a987 1

d993 1
a993 1

d1008 11
a1019 1
	case READ_BIG:
d1021 7
a1027 1
	case WRITE_BIG:
d1086 1
a1086 1
	DNPRINTF(MFI_D_DMA, "%s: mfi_create_sgl %x\n", DEVNAME(sc),
d1109 1
a1109 1
		DNPRINTF(MFI_D_DMA, "%s: addr: %x  len: %x\n",
@


1.36
log
@Refactor scsi path so that we can have a single sgl function for io and non-io
traffic.
Redo parameters on functions that were passing too many parameters around.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.35 2006/05/16 23:11:48 marco Exp $ */
d81 1
d397 184
d596 1
d663 4
a666 1
	sc->sc_max_ld = MFI_MAX_LD;
d668 10
a677 5
	/* XXX fake two lds for now */
	sc->sc_ld_cnt = 2;
	sc->sc_ld[0].ld_present = 1;
	sc->sc_ld[1].ld_present = 1;
	sc->sc_max_ld = 2;
a688 6
#if 0
	printf(", FW %s, BIOS v%s, %dMB RAM\n"
	    "%s: %d channels, %d %ss, %d logical drives\n",
	    sc->sc_fwver, sc->sc_biosver, sc->sc_memory, DEVNAME(sc),
	    sc->sc_channels, sc->sc_targets, p, sc->sc_ld_cnt);
#endif
d834 1
a834 1
		ccb->ccb_direction = 0;
d944 2
a945 1
	DNPRINTF(MFI_D_DMA, "%s: mfi_create_sgl\n", DEVNAME(sc));
@


1.35
log
@Nuke some { }
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.34 2006/05/16 23:05:25 marco Exp $ */
a75 2
u_int32_t	mfi_read(struct mfi_softc *, bus_size_t);
void		mfi_write(struct mfi_softc *, bus_size_t, u_int32_t);
d78 1
d81 4
d86 1
a86 4
int		mfi_despatch_cmd(struct mfi_softc *, struct mfi_ccb *);
int		mfi_poll(struct mfi_softc *, struct mfi_ccb *);
int		mfi_start_xs(struct mfi_softc *, struct mfi_ccb *,
		    struct scsi_xfer *);
d89 2
a90 2
int		mfi_generic_scsi(struct scsi_xfer *);
void		mfi_done_generic_scsi(struct mfi_softc *, struct mfi_ccb *);
d137 2
d386 1
a386 1
	if (mfi_poll(sc, ccb)) {
d519 1
a519 1
mfi_despatch_cmd(struct mfi_softc *sc, struct mfi_ccb *ccb)
d521 2
a522 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_despatch_cmd\n", DEVNAME(sc));
d524 1
a524 1
	mfi_write(sc, MFI_IQP, htole32((ccb->ccb_pframe >> 3) |
d531 1
a531 1
mfi_poll(struct mfi_softc *sc, struct mfi_ccb *ccb)
d536 1
a536 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_poll\n", DEVNAME(sc));
d542 1
a542 1
	mfi_despatch_cmd(sc, ccb);
d550 1
a550 1
		printf("%s: timeout on ccb %d\n", DEVNAME(sc),
d602 1
a602 1
mfi_done_generic_scsi(struct mfi_softc *sc, struct mfi_ccb *ccb)
d609 1
a609 1
	    DEVNAME(sc), link->target);
d614 1
a614 1
mfi_generic_scsi(struct scsi_xfer *xs)
a616 2
	struct mfi_softc	*sc = link->adapter_softc;
	struct mfi_ccb		*ccb;
d619 2
a620 5
	DNPRINTF(MFI_D_CMD, "%s: mfi_generic_scsi: %d\n",
	    DEVNAME(sc), link->target);

	if ((ccb = mfi_get_ccb(sc)) == NULL)
		return (TRY_AGAIN_LATER);
d637 2
a638 2
	ccb->ccb_done = mfi_done_generic_scsi;
	ccb->ccb_xs = xs; /* XXX here or in mfi_start_xs? */
d641 1
d648 10
a657 1
	return (mfi_start_xs(sc, ccb, xs));
d677 1
a677 4
		xs->error = XS_DRIVER_STUFFUP;
		xs->flags |= ITSDONE;
		scsi_done(xs);
		return (COMPLETE);
d684 1
a684 4
		xs->error = XS_DRIVER_STUFFUP;
		xs->flags |= ITSDONE;
		scsi_done(xs);
		return (COMPLETE);
d687 3
d702 5
a706 1
		return (mfi_generic_scsi(xs));
d711 34
a744 1
	return (mfi_start_xs(sc, ccb, xs));
d748 1
a748 2
mfi_start_xs(struct mfi_softc *sc, struct mfi_ccb *ccb,
    struct scsi_xfer *xs)
d750 1
d756 1
a756 2
	DNPRINTF(MFI_D_DMA, "%s: mfi_start_xs: %p %p %d\n", DEVNAME(sc), xs,
	    xs->data, xs->datalen);
d758 2
a759 2
	if (!xs->data)
		goto skipsgl;
d762 1
a762 2
	    xs->data, xs->datalen, NULL,
	    (xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
d765 2
a766 1
			printf("more than %d dma segs\n", sc->sc_max_sgl);
d769 1
a769 6

		mfi_put_ccb(ccb);
		xs->error = XS_DRIVER_STUFFUP;
		xs->flags |= ITSDONE;
		scsi_done(xs);
		return (COMPLETE);
d778 2
a779 2
		DNPRINTF(MFI_D_DMA, "%s: addr: %x  len: %x\n", DEVNAME(sc),
		    sgl->sg32[i].addr, sgl->sg32[i].len);
d807 1
a807 26
skipsgl:
	if (xs->flags & SCSI_POLL) {
		if (mfi_poll(sc, ccb)) {
			printf("%s: mfi_poll failed\n", DEVNAME(sc));
			bzero(&xs->sense, sizeof(xs->sense));
			xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
			xs->sense.flags = SKEY_ILLEGAL_REQUEST;
			xs->sense.add_sense_code = 0x20; /* invalid opcode */
			xs->error = XS_SENSE;
			xs->flags |= ITSDONE;
			scsi_done(xs);
			return (COMPLETE);
		}
		DNPRINTF(MFI_D_DMA, "%s: mfi_start_xs complete %d\n",
		    DEVNAME(sc), ccb->ccb_dmamap->dm_nsegs);

		mfi_put_ccb(ccb);
		return (COMPLETE);
	}

	mfi_despatch_cmd(sc, ccb);

	DNPRINTF(MFI_D_DMA, "%s: mfi_start_xs: queued %d\n", DEVNAME(sc),
	    ccb->ccb_dmamap->dm_nsegs);

	return (SUCCESSFULLY_QUEUED);
@


1.34
log
@Move !xs->data case into mfi_start_xs.
Return proper sense data when a polling command fails.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.33 2006/05/16 22:51:10 marco Exp $ */
d643 1
a643 1
	if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
d646 1
a646 1
	} else {
a647 1
	}
@


1.33
log
@Fix some more htole32 screw-ups.
Colapse all little SCSI functions into a single generic one.
Fix a bug in the SGE calculation.

This brings the driver up to post:
mfi0 at pci12 dev 14 function 0 "Dell PERC SAS" rev 0x00: Dell PERC 5/e irq 5
scsibus3 at mfi0: 2 targets
sd1 at scsibus3 targ 0 lun 0: <DELL, PERC 5/E Adapter, 1.00> SCSI5 0/direct fixed
sd1: 237824MB, 237824 cyl, 64 head, 32 sec, 512 bytes/sec, 487063552 sec total
sd2 at scsibus3 targ 1 lun 0: <DELL, PERC 5/E Adapter, 1.00> SCSI5 0/direct fixed
sd2: 34176MB, 34176 cyl, 64 head, 32 sec, 512 bytes/sec, 69992448 sec total
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.32 2006/05/16 15:50:51 marco Exp $ */
a649 25
	/* XXX don't do this here, make something generic */
	if (xs->cmd->opcode == TEST_UNIT_READY) {
		if (ccb->ccb_xs->flags & SCSI_POLL) {
			if (mfi_poll(sc, ccb)) {
				printf("%s: mfi_poll generic failed\n",
				    DEVNAME(sc));
				bzero(&xs->sense, sizeof(xs->sense));
				xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
				xs->sense.flags = SKEY_ILLEGAL_REQUEST;
				xs->sense.add_sense_code = 0x20; /* invalid opcode */
				xs->error = XS_SENSE;
				xs->flags |= ITSDONE;
				scsi_done(xs);
				return (COMPLETE);
			}
			DNPRINTF(MFI_D_DMA, "%s: mfi_generic complete %d\n",
			    DEVNAME(sc), ccb->ccb_dmamap->dm_nsegs);
			mfi_put_ccb(ccb);

			return (COMPLETE);
		}

		mfi_despatch_cmd(sc, ccb);
	}

d718 3
d772 1
d776 5
a780 1
			xs->error = XS_DRIVER_STUFFUP;
d783 1
@


1.32
log
@Fix some htole32 I missed.
Sprinkle more debug.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.31 2006/05/16 01:58:46 marco Exp $ */
d89 2
a90 6
int		mfi_ld_inquiry(struct scsi_xfer *);
void		mfi_done_ld_inquiry(struct mfi_softc *, struct mfi_ccb *);
int		mfi_ld_tur(struct scsi_xfer *);
void		mfi_done_ld_tur(struct mfi_softc *, struct mfi_ccb *);
int		mfi_ld_readcap(struct scsi_xfer *);
void		mfi_done_ld_readcap(struct mfi_softc *, struct mfi_ccb *);
d162 2
a163 2
		ccb->ccb_pframe = htole32(
		    MFIMEM_DVA(sc->sc_frames) + sc->sc_frames_size * i);
d169 2
a170 2
		ccb->ccb_psense = htole32(
		    (MFIMEM_DVA(sc->sc_sense) + MFI_SENSE_SIZE * i));
d477 1
a477 1
	/* XXX fake one ld for now */
d521 2
a522 1
	mfi_write(sc, MFI_IQP, (ccb->ccb_pframe >> 3) | ccb->ccb_extra_frames);
d599 1
a599 1
mfi_done_ld_inquiry(struct mfi_softc *sc, struct mfi_ccb *ccb)
d601 1
d607 1
d611 1
a611 1
mfi_ld_inquiry(struct scsi_xfer *xs)
d618 1
a618 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_ld_inquiry: %d\n",
d628 1
a628 1
	pf->mpf_header.mfh_cdb_len = 6;
d630 1
a630 1
	pf->mpf_header.mfh_data_len= sizeof(struct scsi_inquiry_data); /* XXX */
d637 1
a637 2
	pf->mpf_cdb[0] = INQUIRY;
	pf->mpf_cdb[4] = sizeof(struct scsi_inquiry_data);
d639 1
a639 1
	ccb->ccb_done = mfi_done_ld_inquiry;
a640 2
	ccb->ccb_sgl = &pf->mpf_sgl;
	ccb->ccb_direction = MFI_DATA_IN;
a641 45

	return (mfi_start_xs(sc, ccb, xs));
}

void
mfi_done_ld_tur(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	struct scsi_xfer	*xs = ccb->ccb_xs;
	struct scsi_link	*link = xs->sc_link;

	DNPRINTF(MFI_D_CMD, "%s: mfi_done_ld_tur: %.0x\n",
	    DEVNAME(sc), link->target);
}

int
mfi_ld_tur(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct mfi_softc	*sc = link->adapter_softc;
	struct mfi_ccb		*ccb;
	struct mfi_pass_frame	*pf;

	DNPRINTF(MFI_D_CMD, "%s: mfi_ld_tur: %d\n",
	    DEVNAME(sc), link->target);

	if ((ccb = mfi_get_ccb(sc)) == NULL)
		return (TRY_AGAIN_LATER);

	pf = &ccb->ccb_frame->mfr_pass;
	pf->mpf_header.mfh_cmd = MFI_CMD_LD_SCSI_IO;
	pf->mpf_header.mfh_target_id = link->target;
	pf->mpf_header.mfh_lun_id = 0;
	pf->mpf_header.mfh_cdb_len = 6;
	pf->mpf_header.mfh_timeout = 0;
	pf->mpf_header.mfh_data_len= 0;
	pf->mpf_header.mfh_sense_len = MFI_SENSE_SIZE;

	pf->mpf_sense_addr_hi = 0;
	pf->mpf_sense_addr_lo = htole32(ccb->ccb_psense);

	memset(pf->mpf_cdb, 0, 16);
	pf->mpf_cdb[0] = TEST_UNIT_READY;

	ccb->ccb_done = mfi_done_ld_tur;
	ccb->ccb_xs = xs; /* XXX here or in mfi_start_xs? */
d643 6
a648 2
	ccb->ccb_direction = 0;
	ccb->ccb_frame_size = MFI_PASS_FRAME_SIZE;
d651 19
a669 6
	if (ccb->ccb_xs->flags & SCSI_POLL) {
		if (mfi_poll(sc, ccb)) {
			printf("%s: mfi_poll failed\n", DEVNAME(sc));
			xs->error = XS_DRIVER_STUFFUP;
			xs->flags |= ITSDONE;
			scsi_done(xs);
d671 2
a672 4
		DNPRINTF(MFI_D_DMA, "%s: mfi_ld_tur complete %d\n",
		    DEVNAME(sc), ccb->ccb_dmamap->dm_nsegs);
		mfi_put_ccb(ccb);
		return (COMPLETE);
a674 53
	mfi_despatch_cmd(sc, ccb);

	DNPRINTF(MFI_D_DMA, "%s: mfi_ld_tur: queued %d\n", DEVNAME(sc),
	    ccb->ccb_dmamap->dm_nsegs);

	return (SUCCESSFULLY_QUEUED);
}

void
mfi_done_ld_readcap(struct mfi_softc *sc, struct mfi_ccb *ccb)
{
	struct scsi_xfer	*xs = ccb->ccb_xs;
	struct scsi_link	*link = xs->sc_link;

	DNPRINTF(MFI_D_CMD, "%s: mfi_ld_done_readcap: %.0x\n",
	    DEVNAME(sc), link->target);
}

int
mfi_ld_readcap(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct mfi_softc	*sc = link->adapter_softc;
	struct mfi_ccb		*ccb;
	struct mfi_pass_frame	*pf;

	DNPRINTF(MFI_D_CMD, "%s: mfi_ld_readcap: %d\n",
	    DEVNAME(sc), link->target);

	if ((ccb = mfi_get_ccb(sc)) == NULL)
		return (TRY_AGAIN_LATER);

	pf = &ccb->ccb_frame->mfr_pass;
	pf->mpf_header.mfh_cmd = MFI_CMD_LD_SCSI_IO;
	pf->mpf_header.mfh_target_id = link->target;
	pf->mpf_header.mfh_lun_id = 0;
	pf->mpf_header.mfh_cdb_len = 6;
	pf->mpf_header.mfh_timeout = 0;
	pf->mpf_header.mfh_data_len= sizeof(struct scsi_read_capacity);
	pf->mpf_header.mfh_sense_len = MFI_SENSE_SIZE;

	pf->mpf_sense_addr_hi = 0;
	pf->mpf_sense_addr_lo = htole32(ccb->ccb_psense);

	memset(pf->mpf_cdb, 0, 16);
	pf->mpf_cdb[0] = READ_CAPACITY; /* XXX other drivers use READCAP 16 */

	ccb->ccb_done = mfi_done_ld_readcap;
	ccb->ccb_xs = xs; /* XXX here or in mfi_start_xs? */
	ccb->ccb_sgl = &pf->mpf_sgl;
	ccb->ccb_direction = MFI_DATA_IN;
	ccb->ccb_frame_size = MFI_PASS_FRAME_SIZE;

d721 1
a721 33
	/* DCDB */
	case INQUIRY:
		return (mfi_ld_inquiry(xs));
		/* NOTREACHED */

	case TEST_UNIT_READY:
		return (mfi_ld_tur(xs));
		/* NOTREACHED */

	case START_STOP:
		DNPRINTF(MFI_D_CMD, "%s: start stop complete %d\n",
		    DEVNAME(sc), target);
		return (COMPLETE);
		
	case READ_CAPACITY:
		return (mfi_ld_readcap(xs));
		/* NOTREACHED */

#if 0
	case VERIFY:
#endif
	case SYNCHRONIZE_CACHE:
	case PREVENT_ALLOW:
	case REQUEST_SENSE:
		DNPRINTF(MFI_D_CMD, "%s: not implemented yet %02x\n",
		    DEVNAME(sc), xs->cmd->opcode);
		xs->error = XS_DRIVER_STUFFUP;
		xs->flags |= ITSDONE;
		scsi_done(xs);
		return (COMPLETE);
		/* NOTREACHED */

	/* illegal opcode */
d723 1
a723 9
		bzero(&xs->sense, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* invalid opcode */
		xs->error = XS_SENSE;
		xs->flags |= ITSDONE;
		scsi_done(xs);
		return (COMPLETE);
		/* NOTREACHED */
d740 2
a741 1
	DNPRINTF(MFI_D_DMA, "%s: mfi_start_xs: %p\n", DEVNAME(sc), xs);
d765 2
d780 3
a782 1
	ccb->ccb_frame_size += sc->sc_frames_size * ccb->ccb_dmamap->dm_nsegs;
d785 9
d803 1
@


1.31
log
@Add READ CAPACITY.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.30 2006/05/16 01:15:29 marco Exp $ */
d186 7
d266 3
d362 1
a362 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_initialize_firmware\n", DEVNAME(sc));
d372 6
a377 6
	qinfo->miq_rq_addr_lo = MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_reply_q);
	qinfo->miq_pi_addr_lo = MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_producer);
	qinfo->miq_ci_addr_lo = MFIMEM_DVA(sc->sc_pcq) +
	    offsetof(struct mfi_prod_cons, mpc_consumer);
d381 6
a386 1
	init->mif_qinfo_new_addr_lo = ccb->ccb_pframe + MFI_FRAME_SIZE;
@


1.30
log
@Oops PREREAD not PREWRITE.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.29 2006/05/16 01:02:42 marco Exp $ */
d93 2
d635 10
d680 1
d703 1
a703 1
mfi_done_ld_tur(struct mfi_softc *sc, struct mfi_ccb *ccb)
d708 1
a708 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_done_ld_tur: %.0x\n",
d713 38
d807 4
a810 1
	case SYNCHRONIZE_CACHE:
d814 1
a816 1
	case READ_CAPACITY:
d865 1
d892 1
a892 1
	if (ccb->ccb_xs->flags & SCSI_POLL) {
@


1.29
log
@Add TUR and make it send it directly to firmware.
Sprinkle some extra debug.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.28 2006/05/15 23:31:24 marco Exp $ */
d826 1
a826 1
		    ccb->ccb_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);
@


1.28
log
@Clear all relevant ccb fields when mfi_put_ccb frees a ccb.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.27 2006/05/15 23:28:41 marco Exp $ */
d91 2
d478 1
a478 1
	sc->sc_link.adapter_target = sc->sc_max_ld;
d590 1
a590 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_ld_inquiry_done: %.0x\n",
d602 1
a602 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_ld_inquiry: %.0x\n",
d634 66
d708 1
a708 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_scsi_cmd opcode: %.0x\n",
d713 9
a746 1
	case SYNCHRONIZE_CACHE:
d748 3
d752 5
d763 1
a763 1
		DNPRINTF(MFI_D_CMD, "%s: not implemented yet %.0x\n",
d784 2
d798 1
a798 1
	DNPRINTF(MFI_D_DMA, "%s: mfi_start_xs:\n", DEVNAME(sc));
d841 2
@


1.27
log
@Oops don't send command twice to firmware when polling.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.26 2006/05/15 23:20:56 marco Exp $ */
d133 2
d136 1
@


1.26
log
@Add INQUIRY command.
Add sgl magic.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.25 2006/05/10 21:48:50 marco Exp $ */
a747 2
	mfi_despatch_cmd(sc, ccb);

d758 2
@


1.25
log
@Add some airplane code.

add bio hooks.
add scsi entry point for io.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.24 2006/04/26 01:25:37 marco Exp $ */
d88 4
a449 3
	/* enable interrupts */
	mfi_write(sc, MFI_OMSK, MFI_ENABLE_INTR);

d457 25
d484 3
d579 49
d637 2
a638 1
	DNPRINTF(MFI_D_CMD, "mfi_scsi_cmd\n");
d644 1
a644 1
		DNPRINTF(MFI_D_CMD, "%s: invalid target %d ",
a653 1

d655 2
a656 1
	case READ_COMMAND:	/* IO path */
d662 33
a694 2
	default:		/* the rest is a DCDB */
		break;
d700 2
a701 1
int mfi_start_xs(struct mfi_softc *sc, struct mfi_ccb *ccb,
d704 61
a764 1
	return (1); /* XXX not yet */
d771 1
a771 1
	struct mfi_softc *sc = (struct mfi_softc *)link->adapter_softc;
d785 1
a785 1
	struct mfi_softc *sc = (struct mfi_softc *)dev;
@


1.24
log
@Fix some debug prints.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.23 2006/04/21 21:43:59 marco Exp $ */
d41 1
a41 1
#endif
d85 11
d377 1
a377 1
#define MFI_MAXFER 4096
d449 9
d551 46
d600 2
a602 2
#if 0
	struct ami_softc *sc = (struct ami_softc *)link->adapter_softc;
d608 67
a674 2
#endif
		return (ENOTTY);
d678 1
a678 1
mfi_scsi_cmd(struct scsi_xfer *xs)
d680 1
a680 7
	DNPRINTF(MFI_D_CMD, "mfi_scsi_cmd\n");
#if 0
	struct scsi_link *link = xs->sc_link;
	struct ami_softc *sc = link->adapter_softc;
	struct device *dev = link->device_softc;
#endif
	return (0);
d682 1
@


1.23
log
@typo
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.22 2006/04/21 21:39:32 marco Exp $ */
d330 1
a330 1
	DNPRINTF(MFI_D_CMD, "mfi_initialize_firmware\n");
d452 1
a452 1
	DNPRINTF(MFI_D_CMD, "mfi_despatch_cmd\n");
d465 1
a465 1
	DNPRINTF(MFI_D_CMD, "mfi_poll\n");
@


1.22
log
@Add mfi_poll and use the new shiny function to setup all the hardware queues.
Lots of ideas from the FreeBSD driver.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.21 2006/04/20 20:31:12 miod Exp $ */
d272 1
a272 1
	DNPRINTF(MFI_D_CMD, "%s: mfi_transition_mfi: %#x\n", DEVNAME(sc),
@


1.21
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.20 2006/04/20 14:01:08 dlg Exp $ */
d81 4
d118 1
d267 2
a268 2
	int32_t fw_state, cur_state;
	int max_wait, i;
d323 38
d375 1
a375 1
	uint32_t	status, frames;
d429 6
d447 39
@


1.20
log
@marco hates typedefs as much as i do, so he asked me to clean mfi like i
just did with ami.  this gets rid of the typedef for the ccb lists.

also uses TAILQ_FIRST to get ccbs off the freelist. this is a proactive
fix for a lint teary.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.19 2006/04/18 16:29:54 marco Exp $ */
d309 2
a310 2
			printf("%s: firmware stuck in state %#x\n", fw_state,
			    DEVNAME(sc));
@


1.19
log
@It helps to initialize a queue before usage.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.18 2006/04/18 00:21:06 marco Exp $ */
d89 1
a89 1
	ccb = TAILQ_LAST(&sc->sc_ccb_freeq, mfi_queue_head);
@


1.18
log
@Actually add ccbs to the queue.
Fix the error path for mfi_init_ccb.
Alter dmamap for io.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.17 2006/04/17 16:46:39 marco Exp $ */
d52 1
a52 1
		    | MFI_D_CCB
d338 2
@


1.17
log
@Sprinkle more debug.  Remove 64 byte boundary; it doesn't seem to like it.
Hack around 64 byte boundary for the frames for now.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.16 2006/04/17 00:48:14 marco Exp $ */
d151 1
a151 2
		    sc->sc_max_sgl * PAGE_SIZE,
		    sc->sc_max_sgl, sc->sc_max_sgl * PAGE_SIZE, 0,
d158 3
d165 9
a173 1
	/* XXX free dma maps */
d426 1
a426 1
			/* remove from queue and call scsi_done */
@


1.16
log
@Setup ccbs and clean up ccb structure.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.15 2006/04/16 23:39:43 marco Exp $ */
d48 2
a49 2
/*		    | MFI_D_DMA */
/*		    | MFI_D_IOCTL */
d51 2
d96 2
d107 2
d125 2
d196 3
d206 1
a206 1
	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 64,
d240 2
d311 2
d324 2
d354 6
d402 2
d434 1
d449 1
@


1.15
log
@Oops, make mfi_allocmem always use 64 byte boundaries since frames have to
have that alignment.  It doesn't matter for the other consumers of the
function.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.14 2006/04/16 23:35:43 marco Exp $ */
d72 1
d112 47
d331 2
a332 1
	sc->sc_frames = mfi_allocmem(sc, frames * MFI_FRAME_SIZE);
d334 1
a334 2
		printf("%s: unable to allocate frame memory\n",
		    DEVNAME(sc));
d341 1
a341 2
		printf("%s: unable to allocate sense memory\n",
		    DEVNAME(sc));
d345 6
d355 2
@


1.14
log
@Add frame memory and sglist allocation.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.13 2006/04/16 18:14:23 marco Exp $ */
d147 1
a147 1
	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
@


1.13
log
@Make memory access use macro.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.12 2006/04/16 17:15:36 marco Exp $ */
d259 1
a259 1
	uint32_t	status;
d276 20
a295 1
		return (1);
d302 6
@


1.12
log
@typo
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.11 2006/04/16 17:10:08 marco Exp $ */
d299 1
a299 1
	pcq = (struct mfi_prod_cons *)sc->sc_pcq->am_kva;
@


1.11
log
@Add get and put ccb functions.  Shuffle some more definitions.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.10 2006/04/16 16:53:55 marco Exp $ */
d120 1
a120 1
	DNPRINTF(MFI_D_RW, "ar 0x%x 0x08%x ", r, rv);
@


1.10
log
@Nicer print when context is invalid.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.9 2006/04/16 16:41:29 marco Exp $ */
d70 3
d78 32
@


1.9
log
@Shuffle some #defines.
Fix comments.
Add human readable enable intrrupt #define.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.8 2006/04/16 16:34:35 marco Exp $ */
d273 2
a274 1
			printf("%s: invalid context\n", DEVNAME(sc));
@


1.8
log
@Add interrupt handler.  Idea borrowed from FreeBSD since it is much nicer
than the Linux one.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.7 2006/04/07 20:27:51 marco Exp $ */
d235 1
a235 1
	/* reply queue memory */
d245 1
a245 1
	mfi_write(sc, MFI_OMSK, 0x01);
@


1.7
log
@Replace bus_space functions with generic ones that do barriers.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.6 2006/04/07 20:05:31 marco Exp $ */
d236 3
a238 3
	sc->sc_reply_q = mfi_allocmem(sc,
	    sizeof(uint32_t) * (sc->sc_max_cmds + 1));
	if (sc->sc_reply_q == NULL) {
d251 1
a251 1
mfi_intr(void *v)
d253 34
a286 1
	return (0); /* XXX unclaimed */
@


1.6
log
@Add memory allocator functions.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.5 2006/04/07 17:02:15 marco Exp $ */
d50 1
d70 2
d76 23
d159 1
a159 2
	fw_state = bus_space_read_4(sc->sc_iot, sc->sc_ioh, MFI_OMSG0) &
	    MFI_STATE_MASK;
d174 1
a174 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    MFI_IDB, MFI_INIT_CLEAR_HANDSHAKE);
d178 1
a178 2
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    MFI_IDB, MFI_INIT_READY);
d196 1
a196 2
			fw_state = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    MFI_OMSG0) & MFI_STATE_MASK;
d229 1
a229 2
	status = bus_space_read_4(sc->sc_iot, sc->sc_ioh, MFI_OMSG0);
	/* XXX add barrier */
d245 1
a245 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, MFI_OMSK, 0x01);
@


1.5
log
@Print state in debug.  Change return vales to 1 instead of ENXIO.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.4 2006/04/07 16:28:07 marco Exp $ */
d69 57
a125 1
int	mfi_transition_firmware(struct mfi_softc *);
d202 2
d206 19
@


1.4
log
@Make a better debug mechanism.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.3 2006/04/07 16:11:21 marco Exp $ */
a76 2
	DNPRINTF(MFI_D_CMD, "%s: mfi_transition_mfi\n", DEVNAME(sc));

d79 4
d91 1
a91 1
			return (ENXIO);
d114 1
a114 1
			return (ENXIO);
d127 1
a127 1
			return (ENXIO);
d149 1
a149 1
	return (1);
@


1.3
log
@Enable  mfi_transition_fw() original code from FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.2 2006/04/06 22:44:24 marco Exp $ */
d43 9
a51 1
#define MFI_DEBUG
d77 1
a77 3
#ifdef MFI_DEBUG
		printf("%s: mfi_transition_mfi\n", DEVNAME(sc));
#endif /* MFI_DEBUG */
d82 2
a83 2
#ifdef MFI_DEBUG
		printf("%s: waiting for firmware to become ready\n",
a84 1
#endif /* MFI_DEBUG */
@


1.2
log
@Add fw transition logic.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi.c,v 1.1 2006/04/06 20:22:53 marco Exp $ */
d43 2
a65 1
#if 0
d69 6
a74 1
	/* fw_state = MFI_READ4(sc, MFI_OMSG0) & MFI_STATE_MASK; */
d77 2
a78 1
		printf("Waiting for firmware to become ready\n");
d83 1
a83 1
			device_printf(sc->mfi_dev, "Firmware fault\n");
d86 2
a87 1
			MFI_WRITE4(sc, MFI_IDB, MFI_INIT_CLEAR_HANDSHAKE);
d91 2
a92 1
			MFI_WRITE4(sc, MFI_IDB, MFI_INIT_READY);
d105 2
a106 2
			device_printf(sc->mfi_dev,"Unknown firmware state %d\n",
			    fw_state);
d110 2
a111 1
			fw_state = MFI_READ4(sc, MFI_OMSG0) & MFI_STATE_MASK;
d118 2
a119 2
			device_printf(sc->mfi_dev, "firmware stuck in state "
			    "%#x\n", fw_state);
d123 1
a123 1
#endif
@


1.1
log
@Add skeleton driver for MegaRAID SAS.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d59 58
d129 3
@

