head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.24
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.18
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.20
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.12
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.16
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.14
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.10
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.8
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.6.0.20
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.18
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.16
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.14
	OPENBSD_2_8:1.1.0.12
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.10
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.8
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.6
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2011.04.06.18.14.35;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.03.12.42.36;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.03.01.51.54;	author martin;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.02.06.26.15;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.23.20.42.21;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.14.09.04.59;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	98.09.11.07.24.57;	author fgsch;	state Exp;
branches
	1.1.8.1
	1.1.18.1;
next	;

1.1.8.1
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2003.05.16.00.29.41;	author niklas;	state Exp;
branches;
next	;

1.1.18.1
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.1.18.2;

1.1.18.2
date	2003.05.19.21.54.23;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Correctly protect the arguments of the AIC_ASSERT() macro.
@
text
@/*	$OpenBSD: aic6360var.h,v 1.7 2011/04/03 12:42:36 krw Exp $	*/
/*	$NetBSD: aic6360.c,v 1.52 1996/12/10 21:27:51 thorpej Exp $	*/

/*
 * Copyright (c) 1994, 1995, 1996 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Copyright (c) 1994 Jarle Greipsland
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Acknowledgements: Many of the algorithms used in this driver are
 * inspired by the work of Julian Elischer (julian@@tfs.com) and
 * Charles Hannum (mycroft@@duality.gnu.ai.mit.edu).  Thanks a million!
 */

#define AIC_NPORTS	0x20	/* I/O port space used */

typedef u_long physaddr;
typedef u_long physlen;

#ifdef notyet
struct aic_dma_seg {
	physaddr seg_addr;
	physlen seg_len;
};

#define AIC_NSEG	16
#endif

/*
 * ACB. Holds additional information for each SCSI command Comments: We
 * need a separate scsi command block because we may need to overwrite it
 * with a request sense command.  Basicly, we refrain from fiddling with
 * the scsi_xfer struct (except do the expected updating of return values).
 * We'll generally update: xs->{flags,resid,error,sense,status} and
 * occasionally xs->retries.
 */
struct aic_acb {
	struct scsi_generic scsi_cmd;
	int scsi_cmd_length;
	u_char *data_addr;		/* Saved data pointer */
	int data_length;		/* Residue */

	u_char target_stat;		/* SCSI status byte */

#ifdef notdef
	struct aic_dma_seg dma[AIC_NSEG]; /* Physical addresses+len */
#endif

	TAILQ_ENTRY(aic_acb) chain;
	struct scsi_xfer *xs;	/* SCSI xfer ctrl block from above */
	int flags;
#define ACB_ALLOC	0x01
#define	ACB_NEXUS	0x02
#define ACB_SENSE	0x04
#define	ACB_ABORT	0x40
#define	ACB_RESET	0x80
	int timeout;
};

/*
 * Some info about each (possible) target on the SCSI bus.  This should
 * probably have been a "per target+lunit" structure, but we'll leave it at
 * this for now.
 */
struct aic_tinfo {
	int	cmds;		/* #commands processed */
	int	dconns;		/* #disconnects */
	int	touts;		/* #timeouts */
	int	perrs;		/* #parity errors */
	int	senses;		/* #request sense commands sent */
	ushort	lubusy;		/* What local units/subr. are busy? */
	u_char  flags;
#define DO_SYNC		0x01	/* (Re)Negotiate synchronous options */
#define	DO_WIDE		0x02	/* (Re)Negotiate wide options */
	u_char  period;		/* Period suggestion */
	u_char  offset;		/* Offset suggestion */
	u_char	width;		/* Width suggestion */
};

struct aic_softc {
	struct device sc_dev;
	void *sc_ih;

	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
	int sc_irq, sc_drq;

	struct scsi_link sc_link;	/* prototype for subdevs */

	TAILQ_HEAD(, aic_acb) free_list, ready_list, nexus_list;
	struct aic_acb *sc_nexus;	/* current command */
	struct aic_acb sc_acb[8];
	struct aic_tinfo sc_tinfo[8];

	struct mutex		sc_acb_mtx;
	struct scsi_iopool	sc_iopool;

	/* Data about the current nexus (updated for every cmd switch) */
	u_char	*sc_dp;		/* Current data pointer */
	size_t	sc_dleft;	/* Data bytes left to transfer */
	u_char	*sc_cp;		/* Current command pointer */
	size_t	sc_cleft;	/* Command bytes left to transfer */

	/* Adapter state */
	u_char	 sc_phase;	/* Current bus phase */
	u_char	 sc_prevphase;	/* Previous bus phase */
	u_char	 sc_state;	/* State applicable to the adapter */
#define	AIC_INIT	0
#define AIC_IDLE	1
#define AIC_SELECTING	2	/* SCSI command is arbiting  */
#define AIC_RESELECTED	3	/* Has been reselected */
#define AIC_CONNECTED	4	/* Actively using the SCSI bus */
#define	AIC_DISCONNECT	5	/* MSG_DISCONNECT received */
#define	AIC_CMDCOMPLETE	6	/* MSG_CMDCOMPLETE received */
#define AIC_CLEANING	7
	u_char	 sc_flags;
#define AIC_DROP_MSGIN	0x01	/* Discard all msgs (parity err detected) */
#define	AIC_ABORTING	0x02	/* Bailing out */
#define AIC_DOINGDMA	0x04	/* The FIFO data path is active! */
	u_char	sc_selid;	/* Reselection ID */

	/* Message stuff */
	u_char	sc_msgpriq;	/* Messages we want to send */
	u_char	sc_msgoutq;	/* Messages sent during last MESSAGE OUT */
	u_char	sc_lastmsg;	/* Message last transmitted */
	u_char	sc_currmsg;	/* Message currently ready to transmit */
#define SEND_DEV_RESET		0x01
#define SEND_PARITY_ERROR	0x02
#define SEND_INIT_DET_ERR	0x04
#define SEND_REJECT		0x08
#define SEND_IDENTIFY  		0x10
#define SEND_ABORT		0x20
#define SEND_SDTR		0x40
#define	SEND_WDTR		0x80
#define AIC_MAX_MSG_LEN 8
	u_char  sc_omess[AIC_MAX_MSG_LEN];
	u_char	*sc_omp;		/* Outgoing message pointer */
	u_char	sc_imess[AIC_MAX_MSG_LEN];
	u_char	*sc_imp;		/* Incoming message pointer */

	/* Hardware stuff */
	int	sc_initiator;		/* Our scsi id */
	int	sc_freq;		/* Clock frequency in MHz */
	int	sc_minsync;		/* Minimum sync period / 4 */
	int	sc_maxsync;		/* Maximum sync period / 4 */
};

#if AIC_DEBUG
#define AIC_SHOWACBS	0x01
#define AIC_SHOWINTS	0x02
#define AIC_SHOWCMDS	0x04
#define AIC_SHOWMISC	0x08
#define AIC_SHOWTRACE	0x10
#define AIC_SHOWSTART	0x20
#define AIC_DOBREAK	0x40
#define	AIC_PRINT(b, s)	do {if ((aic_debug & (b)) != 0) printf s;} while (0)
#define	AIC_BREAK() \
	do { if ((aic_debug & AIC_DOBREAK) != 0) Debugger(); } while (0)
#define	AIC_ASSERT(x) \
	do { \
		if (!(x)) { \
			printf("%s at line %d: assertion failed\n", \
			    sc->sc_dev.dv_xname, __LINE__); \
			Debugger(); \
		} \
	} while (0)
#else
#define	AIC_PRINT(b, s)
#define	AIC_BREAK()
#define	AIC_ASSERT(x)
#endif

#define AIC_ACBS(s)	AIC_PRINT(AIC_SHOWACBS, s)
#define AIC_INTS(s)	AIC_PRINT(AIC_SHOWINTS, s)
#define AIC_CMDS(s)	AIC_PRINT(AIC_SHOWCMDS, s)
#define AIC_MISC(s)	AIC_PRINT(AIC_SHOWMISC, s)
#define AIC_TRACE(s)	AIC_PRINT(AIC_SHOWTRACE, s)
#define AIC_START(s)	AIC_PRINT(AIC_SHOWSTART, s)

void	aicattach(struct aic_softc *);
int	aic_detach(struct device *, int);
int	aicintr(void *);
int 	aic_find(bus_space_tag_t, bus_space_handle_t);
@


1.7
log
@Iopoolification of some less common scsi drivers.

ok dlg@@ ("miod will not object" dlg@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: aic6360var.h,v 1.6 2006/06/03 01:51:54 martin Exp $	*/
d200 1
a200 1
		if (!x) { \
@


1.6
log
@make detachable, inspired by netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: aic6360var.h,v 1.5 2006/06/02 06:26:15 martin Exp $	*/
d133 3
@


1.5
log
@ditch unused struct isadev and in turn the isavar.h include
@
text
@d1 1
a1 1
/*	$OpenBSD: aic6360var.h,v 1.4 2006/05/23 20:42:21 miod Exp $	*/
d217 1
@


1.4
log
@- comment out minphys() wrapper which was intended for DMA code, since there
  is no working DMA support at the moment.
- do not define AIC_DEBUG if SMALL_KERNEL. Saves 4KB.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic6360var.h,v 1.3 2003/05/14 09:04:59 jason Exp $	*/
a120 1
	struct isadev sc_id;
@


1.3
log
@Nuke more commons: ac97_id2, tinfo_t
@
text
@d1 1
a1 1
/*	$OpenBSD: aic6360var.h,v 1.2 2002/03/14 01:26:54 millert Exp $	*/
d59 1
d66 1
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: aic6360var.h,v 1.1 1998/09/11 07:24:57 fgsch Exp $	*/
d115 1
a115 1
} tinfo_t;
@


1.1
log
@Split the aic6360 driver to add support for SCSI pcmcia cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic6360.c,v 1.15 1997/07/30 13:03:50 niklas Exp $	*/
d215 3
a217 3
void	aicattach	__P((struct aic_softc *));
int	aicintr		__P((void *));
int 	aic_find	__P((bus_space_tag_t, bus_space_handle_t));
@


1.1.18.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aic6360var.h,v 1.1 1998/09/11 07:24:57 fgsch Exp $	*/
d215 3
a217 3
void	aicattach(struct aic_softc *);
int	aicintr(void *);
int 	aic_find(bus_space_tag_t, bus_space_handle_t);
@


1.1.18.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d115 1
a115 1
};
@


1.1.8.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d215 3
a217 3
void	aicattach(struct aic_softc *);
int	aicintr(void *);
int 	aic_find(bus_space_tag_t, bus_space_handle_t);
@


1.1.8.2
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d115 1
a115 1
};
@


