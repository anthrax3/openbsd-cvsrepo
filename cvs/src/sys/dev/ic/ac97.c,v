head	1.82;
access;
symbols
	OPENBSD_6_0:1.81.0.6
	OPENBSD_6_0_BASE:1.81
	OPENBSD_5_9:1.81.0.2
	OPENBSD_5_9_BASE:1.81
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.78.0.2
	OPENBSD_5_7_BASE:1.78
	OPENBSD_5_6:1.78.0.4
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.77.0.16
	OPENBSD_5_5_BASE:1.77
	OPENBSD_5_4:1.77.0.12
	OPENBSD_5_4_BASE:1.77
	OPENBSD_5_3:1.77.0.10
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.77.0.6
	OPENBSD_5_2_BASE:1.77
	OPENBSD_5_1_BASE:1.77
	OPENBSD_5_1:1.77.0.8
	OPENBSD_5_0:1.77.0.4
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.77.0.2
	OPENBSD_4_9_BASE:1.77
	OPENBSD_4_8:1.74.0.2
	OPENBSD_4_8_BASE:1.74
	OPENBSD_4_7:1.72.0.2
	OPENBSD_4_7_BASE:1.72
	OPENBSD_4_6:1.70.0.6
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.70.0.2
	OPENBSD_4_5_BASE:1.70
	OPENBSD_4_4:1.68.0.2
	OPENBSD_4_4_BASE:1.68
	OPENBSD_4_3:1.67.0.2
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.63.0.2
	OPENBSD_4_2_BASE:1.63
	OPENBSD_4_1:1.61.0.4
	OPENBSD_4_1_BASE:1.61
	OPENBSD_4_0:1.61.0.2
	OPENBSD_4_0_BASE:1.61
	OPENBSD_3_9:1.59.0.2
	OPENBSD_3_9_BASE:1.59
	OPENBSD_3_8:1.56.0.2
	OPENBSD_3_8_BASE:1.56
	OPENBSD_3_7:1.52.0.2
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.43.0.2
	OPENBSD_3_6_BASE:1.43
	SMP_SYNC_A:1.43
	SMP_SYNC_B:1.43
	OPENBSD_3_5:1.41.0.2
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	UBC_SYNC_A:1.36
	OPENBSD_3_3:1.33.0.4
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	UBC_SYNC_B:1.33
	UBC:1.27.0.2
	UBC_BASE:1.27
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.82
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.81;
commitid	pi1a9KN0itEngOc4;

1.81
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	NdgfPIGUgJxQPnT7;

1.80
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.79;
commitid	RaOGL5SyOGOZylwx;

1.79
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.78;
commitid	p4LJxGKbi0BU2cG6;

1.78
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.77;
commitid	I19imNlAX05zJOED;

1.77
date	2011.01.03.15.28.46;	author fgsch;	state Exp;
branches;
next	1.76;

1.76
date	2011.01.03.10.00.22;	author jakemsr;	state Exp;
branches;
next	1.75;

1.75
date	2010.12.22.09.54.27;	author jakemsr;	state Exp;
branches;
next	1.74;

1.74
date	2010.08.08.20.37.33;	author jakemsr;	state Exp;
branches;
next	1.73;

1.73
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.72;

1.72
date	2010.02.25.21.22.42;	author ratchov;	state Exp;
branches;
next	1.71;

1.71
date	2009.12.15.20.26.21;	author jasper;	state Exp;
branches;
next	1.70;

1.70
date	2008.10.23.21.50.01;	author jakemsr;	state Exp;
branches;
next	1.69;

1.69
date	2008.10.23.20.52.50;	author jakemsr;	state Exp;
branches;
next	1.68;

1.68
date	2008.05.25.23.52.30;	author jakemsr;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.12.13.02.21;	author jakemsr;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.15.02.52.50;	author jakemsr;	state Exp;
branches;
next	1.65;

1.65
date	2008.01.13.21.43.01;	author deanna;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2007.07.27.01.48.04;	author ian;	state Exp;
branches;
next	1.62;

1.62
date	2007.07.09.01.24.54;	author jakemsr;	state Exp;
branches;
next	1.61;

1.61
date	2006.06.30.14.46.11;	author mickey;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.27.21.40.00;	author matthieu;	state Exp;
branches;
next	1.59;

1.59
date	2005.12.28.14.36.25;	author fgsch;	state Exp;
branches;
next	1.58;

1.58
date	2005.12.14.13.59.04;	author fgsch;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.12.14.13.58;	author fgsch;	state Exp;
branches;
next	1.56;

1.56
date	2005.06.18.21.23.59;	author canacar;	state Exp;
branches;
next	1.55;

1.55
date	2005.06.06.21.12.44;	author mjc;	state Exp;
branches;
next	1.54;

1.54
date	2005.06.06.21.08.14;	author mjc;	state Exp;
branches;
next	1.53;

1.53
date	2005.05.25.17.59.23;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.16.22.26.39;	author todd;	state Exp;
branches;
next	1.51;

1.51
date	2005.01.31.15.48.19;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.30.21.43.02;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.17.05.42.41;	author jaredy;	state Exp;
branches;
next	1.48;

1.48
date	2004.11.22.23.06.50;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.18.16.24.30;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2004.10.14.16.02.45;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2004.10.04.20.03.04;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.14.22.06.49;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.23.09.31.47;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.23.09.26.15;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.27.17.37.56;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.05.14.40.26;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.25.21.49.06;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.23.20.53.52;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.15.13.20.31;	author couderc;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.09.20.05.47;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.07.21.01.14;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.17.19.12.17;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.05.17.03.33;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.28.06.27.07;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.08.01.43.13;	author frantzen;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.09.19.27.27;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.17.16.22.58;	author mickey;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2001.12.01.16.29.54;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.28.18.58.12;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.24.16.30.05;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.24.03.52.40;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.15.17.27.12;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.20.18.08.53;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.17.21.06.13;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.16.23.34.53;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.16.19.14.03;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.16.12.51.48;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.16.08.19.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.16.05.32.42;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.15.22.43.20;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.15.22.19.12;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.15.18.25.48;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.03.21.28.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.27.16.34.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.20.21.36.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.19.09.01.35;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.27.20.49.30;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.30.18.34.14;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.27.15.47.17;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.12.23.38.50;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	99.10.05.18.58.22;	author csapuntz;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.09.21.16.06.27;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.09.19.06.45.12;	author csapuntz;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.23.20;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.07.04.10.40.22;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2003.03.28.00.38.11;	author niklas;	state Exp;
branches;
next	1.3.4.9;

1.3.4.9
date	2003.05.13.19.34.57;	author ho;	state Exp;
branches;
next	1.3.4.10;

1.3.4.10
date	2004.02.19.10.56.15;	author niklas;	state Exp;
branches;
next	1.3.4.11;

1.3.4.11
date	2004.06.05.23.12.39;	author niklas;	state Exp;
branches;
next	;

1.27.2.1
date	2002.01.31.22.55.30;	author niklas;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2003.05.19.21.54.23;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@/*	$OpenBSD: ac97.c,v 1.80 2015/05/11 06:46:21 ratchov Exp $	*/

/*
 * Copyright (c) 1999, 2000 Constantine Sapuntzakis
 *
 * Author:	Constantine Sapuntzakis <csapuntz@@stanford.edu>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.  */

/* Partially inspired by FreeBSD's sys/dev/pcm/ac97.c. It came with
   the following copyright */

/*
 * Copyright (c) 1999 Cameron Grant <gandalf@@vilnya.demon.co.uk>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD$
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/ic/ac97.h>


/* default parameters; supported by all ac97 codecs */
const struct audio_params ac97_audio_default = {
	48000,		/* sample_rate */
	AUDIO_ENCODING_SLINEAR_LE, /* encoding */
	16,		/* precision */
	2,		/* bps */
	1,		/* msb */
	2		/* channels */
};

const struct audio_mixer_enum ac97_on_off = {
	2,
	{ { { AudioNoff } , 0 },
	{ { AudioNon }  , 1 } }
};

const struct audio_mixer_enum ac97_mic_select = {
	2,
	{ { { AudioNmicrophone "0" }, 0 },
	{ { AudioNmicrophone "1" }, 1 } }
};

const struct audio_mixer_enum ac97_mono_select = {
	2,
	{ { { AudioNmixerout }, 0 },
	{ { AudioNmicrophone }, 1 } }
};

const struct audio_mixer_enum ac97_source = {
	8,
	{ { { AudioNmicrophone } , 0 },
	{ { AudioNcd }, 1 },
	{ { "video" }, 2 },
	{ { AudioNaux }, 3 },
	{ { AudioNline }, 4 },
	{ { AudioNmixerout }, 5 },
	{ { AudioNmixerout AudioNmono }, 6 },
	{ { "phone" }, 7 }}
};

/*
 * Due to different values for each source that uses these structures,
 * the ac97_query_devinfo function sets delta in mixer_devinfo_t using
 * ac97_source_info.bits.
 */
const struct audio_mixer_value ac97_volume_stereo = {
	{ AudioNvolume },
	2
};

const struct audio_mixer_value ac97_volume_mono = {
	{ AudioNvolume },
	1
};

#define AudioNspdif	"spdif"

#define WRAP(a)  &a, sizeof(a)

const struct ac97_source_info {
	char *class;
	char *device;
	char *qualifier;
	int  type;

	const void *info;
	int16_t info_size;

	u_int8_t  reg;
	u_int16_t default_value;
	u_int8_t  bits:3;
	u_int8_t  ofs:4;
	u_int8_t  mute:1;
	u_int8_t  polarity:1;		/* Does 0 == MAX or MIN */
	enum {
		CHECK_NONE = 0,
		CHECK_SURROUND,
		CHECK_CENTER,
		CHECK_LFE,
		CHECK_HEADPHONES,
		CHECK_TONE,
		CHECK_MIC,
		CHECK_LOUDNESS,
		CHECK_3D,
		CHECK_SPDIF
	} req_feature;

	int16_t  prev;
	int16_t  next;
	int16_t  mixer_class;
} source_info[] = {
	{ AudioCinputs,		NULL,		NULL,
	  AUDIO_MIXER_CLASS, },
	{ AudioCoutputs,	NULL,		NULL,
	  AUDIO_MIXER_CLASS, },
	{ AudioCrecord,		NULL,		NULL,
	  AUDIO_MIXER_CLASS, },
	/* Stereo master volume*/
	{ AudioCoutputs,	AudioNmaster,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_MASTER_VOLUME, 0x8000, 5, 0, 1,
	},
	/* Mono volume */
	{ AudioCoutputs,	AudioNmono,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_mono),
	  AC97_REG_MASTER_VOLUME_MONO, 0x8000, 6, 0, 1,
	},
	{ AudioCoutputs,	AudioNmono,	AudioNsource,
	  AUDIO_MIXER_ENUM, WRAP(ac97_mono_select),
	  AC97_REG_GP, 0x0000, 1, 9, 0,
	},
	/* Headphone volume */
	{ AudioCoutputs,	AudioNheadphone, NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_HEADPHONE_VOLUME, 0x8000, 6, 0, 1, 0, CHECK_HEADPHONES
	},
	/* Surround volume - logic hard coded for mute */
	{ AudioCoutputs,	AudioNsurround,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_SURR_MASTER, 0x8080, 5, 0, 1, 0, CHECK_SURROUND
	},
	/* Center volume*/
	{ AudioCoutputs,	AudioNcenter,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_mono),
	  AC97_REG_CENTER_LFE_MASTER, 0x8080, 5, 0, 0, 0, CHECK_CENTER
	},
	{ AudioCoutputs,	AudioNcenter,	AudioNmute,
	  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
	  AC97_REG_CENTER_LFE_MASTER, 0x8080, 1, 7, 0, 0, CHECK_CENTER
	},
	/* LFE volume*/
	{ AudioCoutputs,	AudioNlfe,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_mono),
	  AC97_REG_CENTER_LFE_MASTER, 0x8080, 5, 8, 0, 0, CHECK_LFE
	},
	{ AudioCoutputs,	AudioNlfe,	AudioNmute,
	  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
	  AC97_REG_CENTER_LFE_MASTER, 0x8080, 1, 15, 0, 0, CHECK_LFE
	},
	/* Tone */
	{ AudioCoutputs,	"tone",	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_MASTER_TONE, 0x0f0f, 4, 0, 0, 0, CHECK_TONE
	},
	/* PC Beep Volume */
	{ AudioCinputs,		AudioNspeaker,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_mono),
	  AC97_REG_PCBEEP_VOLUME, 0x0000, 4, 1, 1,
	},

	/* Phone */
	{ AudioCinputs,		"phone",	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_mono),
	  AC97_REG_PHONE_VOLUME, 0x8008, 5, 0, 1,
	},
	/* Mic Volume */
	{ AudioCinputs,		AudioNmicrophone, NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_mono),
	  AC97_REG_MIC_VOLUME, 0x8008, 5, 0, 1,
	},
	{ AudioCinputs,		AudioNmicrophone, AudioNpreamp,
	  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
	  AC97_REG_MIC_VOLUME, 0x8008, 1, 6, 0,
	},
	{ AudioCinputs,		AudioNmicrophone, AudioNsource,
	  AUDIO_MIXER_ENUM, WRAP(ac97_mic_select),
	  AC97_REG_GP, 0x0000, 1, 8, 0,
	},
	/* Line in Volume */
	{ AudioCinputs,		AudioNline,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_LINEIN_VOLUME, 0x8808, 5, 0, 1,
	},
	/* CD Volume */
	{ AudioCinputs,		AudioNcd,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_CD_VOLUME, 0x8808, 5, 0, 1,
	},
	/* Video Volume */
	{ AudioCinputs,		AudioNvideo,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_VIDEO_VOLUME, 0x8808, 5, 0, 1,
	},
	/* AUX volume */
	{ AudioCinputs,		AudioNaux,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_AUX_VOLUME, 0x8808, 5, 0, 1,
	},
	/* PCM out volume */
	{ AudioCinputs,		AudioNdac,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_PCMOUT_VOLUME, 0x8808, 5, 0, 1,
	},
	/* Record Source - some logic for this is hard coded - see below */
	{ AudioCrecord,		AudioNsource,	NULL,
	  AUDIO_MIXER_ENUM, WRAP(ac97_source),
	  AC97_REG_RECORD_SELECT, 0x0000, 3, 0, 0,
	},
	/* Record Gain */
	{ AudioCrecord,		AudioNvolume,	NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_stereo),
	  AC97_REG_RECORD_GAIN, 0x8000, 4, 0, 1,
	},
	/* Record Gain mic */
	{ AudioCrecord,		AudioNmicrophone, NULL,
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_mono),
	  AC97_REG_RECORD_GAIN_MIC, 0x8000, 4, 0, 1, 1, CHECK_MIC
	},
	/* */
	{ AudioCoutputs,	AudioNloudness,	NULL,
	  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
	  AC97_REG_GP, 0x0000, 1, 12, 0, 0, CHECK_LOUDNESS
	},
	{ AudioCoutputs,	AudioNspatial,	NULL,
	  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
	  AC97_REG_GP, 0x0000, 1, 13, 0, 1, CHECK_3D
	},
	{ AudioCoutputs,	AudioNspatial,	"center",
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_mono),
	  AC97_REG_3D_CONTROL, 0x0000, 4, 8, 0, 1, CHECK_3D
	},
	{ AudioCoutputs,	AudioNspatial,	"depth",
	  AUDIO_MIXER_VALUE, WRAP(ac97_volume_mono),
	  AC97_REG_3D_CONTROL, 0x0000, 4, 0, 0, 1, CHECK_3D
	},
	/* External Amp */
	{ AudioCoutputs,	AudioNextamp,	NULL,
	  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
	  AC97_REG_POWER, 0x0000, 1, 15, 0, 0
	},
	/* S/PDIF output enable */
	{ AudioCoutputs,	AudioNspdif,	NULL,
	  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
	  AC97_REG_EXT_AUDIO_CTRL, 0x0000, 1, 2, 0, 0, CHECK_SPDIF
	}

	/* Missing features: Simulated Stereo, POP, Loopback mode */
};

/*
 * Check out http://www.intel.com/technology/computing/audio/index.htm
 * for information on AC-97
 */

struct ac97_softc {
	/* ac97_codec_if must be at the first of ac97_softc. */
	struct ac97_codec_if codec_if;
	struct ac97_host_if *host_if;
#define MAX_SOURCES	(2 * nitems(source_info))
	struct ac97_source_info source_info[MAX_SOURCES];
	int num_source_info;
	enum ac97_host_flags host_flags;
	unsigned int ac97_clock; /* usually 48000 */
#define AC97_STANDARD_CLOCK	48000U
	u_int16_t caps;		/* -> AC97_REG_RESET */
	u_int16_t ext_id;	/* -> AC97_REG_EXT_AUDIO_ID */
	u_int16_t shadow_reg[128];
	int lock_counter;
};

int	ac97_mixer_get_port(struct ac97_codec_if *, mixer_ctrl_t *);
int	ac97_mixer_set_port(struct ac97_codec_if *, mixer_ctrl_t *);
void	ac97_lock(struct ac97_codec_if *);
void	ac97_unlock(struct ac97_codec_if *);
int	ac97_query_devinfo(struct ac97_codec_if *, mixer_devinfo_t *);
int	ac97_get_portnum_by_name(struct ac97_codec_if *, char *, char *,
	    char *);
void	ac97_restore_shadow(struct ac97_codec_if *);
int	ac97_set_rate(struct ac97_codec_if *codec_if, int target, u_long *rate);
void	ac97_set_clock(struct ac97_codec_if *codec_if, unsigned int clock);
u_int16_t ac97_get_extcaps(struct ac97_codec_if *codec_if);
int	ac97_add_port(struct ac97_softc *as, struct ac97_source_info *src);

void	ac97_ad1885_init(struct ac97_softc *, int);
void	ac97_ad1886_init(struct ac97_softc *, int);
void	ac97_ad198x_init(struct ac97_softc *, int);
void	ac97_alc650_init(struct ac97_softc *, int);
void	ac97_cx20468_init(struct ac97_softc *, int);
void	ac97_vt1616_init(struct ac97_softc *, int);

struct ac97_codec_if_vtbl ac97civ = {
	ac97_mixer_get_port,
	ac97_mixer_set_port,
	ac97_query_devinfo,
	ac97_get_portnum_by_name,
	ac97_restore_shadow,
	ac97_get_extcaps,
	ac97_set_rate,
	ac97_set_clock,
	ac97_lock,
	ac97_unlock
};

const struct ac97_codecid {
	u_int8_t id;
	u_int8_t mask;
	u_int8_t rev;
	u_int8_t shift;	/* no use yet */
	char * const name;
	void (*init)(struct ac97_softc *, int);
}  ac97_ad[] = {
	{ 0x03, 0xff, 0, 0,	"AD1819" },
	{ 0x40, 0xff, 0, 0,	"AD1881" },
	{ 0x48, 0xff, 0, 0,	"AD1881A" },
	{ 0x60, 0xff, 0, 0,	"AD1885", 	ac97_ad1885_init },
	{ 0x61, 0xff, 0, 0,	"AD1886",	ac97_ad1886_init },
	{ 0x63, 0xff, 0, 0,	"AD1886A" },
	{ 0x68, 0xff, 0, 0,	"AD1888",	ac97_ad198x_init },
	{ 0x70, 0xff, 0, 0,	"AD1980",	ac97_ad198x_init },
	{ 0x72, 0xff, 0, 0,	"AD1981A" },
	{ 0x74, 0xff, 0, 0,	"AD1981B" },
	{ 0x75, 0xff, 0, 0,	"AD1985",	ac97_ad198x_init },
}, ac97_ak[] = {
	{ 0x00,	0xfe, 1, 0,	"AK4540" },
	{ 0x01,	0xfe, 1, 0,	"AK4540" },
	{ 0x02,	0xff, 0, 0,	"AK4543" },
	{ 0x05,	0xff, 0, 0,	"AK4544" },
	{ 0x06,	0xff, 0, 0,	"AK4544A" },
	{ 0x07,	0xff, 0, 0,	"AK4545" },
}, ac97_av[] = {
	{ 0x10, 0xff, 0, 0,	"ALC200" },
	{ 0x20, 0xff, 0, 0,	"ALC650" },
	{ 0x21, 0xff, 0, 0,	"ALC650D" },
	{ 0x22, 0xff, 0, 0,	"ALC650E" },
	{ 0x23, 0xff, 0, 0,	"ALC650F" },
	{ 0x30, 0xff, 0, 0,	"ALC101" },
	{ 0x40, 0xff, 0, 0,	"ALC202" },
	{ 0x50, 0xff, 0, 0,	"ALC250" },
	{ 0x52, 0xff, 0, 0,	"ALC250A?" },
	{ 0x60, 0xf0, 0xf, 0,	"ALC655",	ac97_alc650_init },
	{ 0x70, 0xf0, 0xf, 0,	"ALC203" },
	{ 0x80, 0xf0, 0xf, 0,	"ALC658",	ac97_alc650_init },
	{ 0x90, 0xf0, 0xf, 0,	"ALC850" },
}, ac97_rl[] = {
	{ 0x00, 0xf0, 0xf, 0,	"RL5306" },
	{ 0x10, 0xf0, 0xf, 0,	"RL5382" },
	{ 0x20, 0xf0, 0xf, 0,	"RL5383" },
}, ac97_cm[] = {
	{ 0x41,	0xff, 0, 0,	"CMI9738" },
	{ 0x61,	0xff, 0, 0,	"CMI9739" },
	{ 0x78,	0xff, 0, 0,	"CMI9761A" },
	{ 0x82,	0xff, 0, 0,	"CMI9761B" },
	{ 0x83,	0xff, 0, 0,	"CMI9761A+" },
}, ac97_cr[] = {
	{ 0x84,	0xff, 0, 0,	"EV1938" },
}, ac97_cs[] = {
	{ 0x00,	0xf8, 7, 0,	"CS4297" },
	{ 0x10,	0xf8, 7, 0,	"CS4297A" },
	{ 0x20,	0xf8, 7, 0,	"CS4298" },
	{ 0x28,	0xf8, 7, 0,	"CS4294" },
	{ 0x30,	0xf8, 7, 0,	"CS4299" },
	{ 0x48,	0xf8, 7, 0,	"CS4201" },
	{ 0x58,	0xf8, 7, 0,	"CS4205" },
	{ 0x60,	0xf8, 7, 0,	"CS4291" },
	{ 0x70,	0xf8, 7, 0,	"CS4202" },
}, ac97_cx[] = {
	{ 0x21, 0xff, 0, 0,	"HSD11246" },
	{ 0x28, 0xf8, 7, 0,	"CX20468",	ac97_cx20468_init },
	{ 0x30, 0xff, 0, 0,	"CXT48", },
	{ 0x42, 0xff, 0, 0,	"CXT66", },
}, ac97_dt[] = {
	{ 0x00, 0xff, 0, 0,	"DT0398" },
}, ac97_em[] = {
	{ 0x23, 0xff, 0, 0,	"EM28023" },
	{ 0x28, 0xff, 0, 0,	"EM28028" },
}, ac97_es[] = {
	{ 0x08, 0xff, 0, 0,	"ES1921" },
}, ac97_is[] = {
	{ 0x00, 0xff, 0, 0,	"HMP9701" },
}, ac97_ic[] = {
	{ 0x01, 0xff, 0, 0,	"ICE1230" },
	{ 0x11, 0xff, 0, 0,	"ICE1232" },
	{ 0x14, 0xff, 0, 0,	"ICE1232A" },
	{ 0x51, 0xff, 0, 0,	"VIA VT1616" },
	{ 0x52, 0xff, 0, 0,	"VIA VT1616i",	ac97_vt1616_init },
}, ac97_it[] = {
	{ 0x20, 0xff, 0, 0,	"ITE2226E" },
	{ 0x60, 0xff, 0, 0,	"ITE2646E" },
}, ac97_ns[] = {
	{ 0x00,	0xff, 0, 0,	"LM454[03568]" },
	{ 0x31,	0xff, 0, 0,	"LM4549" },
	{ 0x40, 0xff, 0, 0,	"LM4540" },
	{ 0x43, 0xff, 0, 0,	"LM4543" },
	{ 0x46, 0xff, 0, 0,	"LM4546A" },
	{ 0x48, 0xff, 0, 0,	"LM4548A" },
	{ 0x49, 0xff, 0, 0,	"LM4549A" },
	{ 0x50, 0xff, 0, 0,	"LM4550" },
}, ac97_ps[] = {
	{ 0x01,	0xff, 0, 0,	"UCB1510" },
	{ 0x04,	0xff, 0, 0,	"UCB1400" },
}, ac97_sl[] = {
	{ 0x20,	0xe0, 0, 0,	"Si3036/38" },
}, ac97_st[] = {
	{ 0x00,	0xff, 0, 0,	"STAC9700" },
	{ 0x04,	0xff, 0, 0,	"STAC970[135]" },
	{ 0x05,	0xff, 0, 0,	"STAC9704" },
	{ 0x08,	0xff, 0, 0,	"STAC9708/11" },
	{ 0x09,	0xff, 0, 0,	"STAC9721/23" },
	{ 0x44,	0xff, 0, 0,	"STAC9744/45" },
	{ 0x50,	0xff, 0, 0,	"STAC9750/51" },
	{ 0x52,	0xff, 0, 0,	"STAC9752/53" },
	{ 0x56,	0xff, 0, 0,	"STAC9756/57" },
	{ 0x58,	0xff, 0, 0,	"STAC9758/59" },
	{ 0x60,	0xff, 0, 0,	"STAC9760/61" },
	{ 0x62,	0xff, 0, 0,	"STAC9762/63" },
	{ 0x66,	0xff, 0, 0,	"STAC9766/67" },
	{ 0x84,	0xff, 0, 0,	"STAC9784/85" },
}, ac97_vi[] = {
	{ 0x61, 0xff, 0, 0,	"VT1612A" },
	{ 0x70, 0xff, 0, 0,	"VT1617" },
}, ac97_tt[] = {
	{ 0x02,	0xff, 0, 0,	"TR28022" },
	{ 0x03,	0xff, 0, 0,	"TR28023" },
	{ 0x06,	0xff, 0, 0,	"TR28026" },
	{ 0x08,	0xff, 0, 0,	"TR28028" },
	{ 0x23,	0xff, 0, 0,	"TR28602" },
}, ac97_ti[] = {
	{ 0x20, 0xff, 0, 0,	"TLC320AD9xC" },
}, ac97_wb[] = {
	{ 0x01, 0xff, 0, 0,	"W83971D" },
}, ac97_wo[] = {
	{ 0x00,	0xff, 0, 0,	"WM9701A" },
	{ 0x03,	0xff, 0, 0,	"WM9704M/Q-0" }, /* & WM9703 */
	{ 0x04,	0xff, 0, 0,	"WM9704M/Q-1" },
	{ 0x05,	0xff, 0, 0,	"WM9705/10" },
	{ 0x09,	0xff, 0, 0,	"WM9709" },
	{ 0x12,	0xff, 0, 0,	"WM9711/12" },
}, ac97_ym[] = {
	{ 0x00, 0xff, 0, 0,	"YMF743-S" },
	{ 0x02, 0xff, 0, 0,	"YMF752-S" },
	{ 0x03, 0xff, 0, 0,	"YMF753-S" },
};

#define	cl(n)	n, nitems(n)
const struct ac97_vendorid {
	u_int32_t id;
	char * const name;
	const struct ac97_codecid * const codecs;
	u_int8_t num;
} ac97_vendors[] = {
	{ 0x01408300, "Creative",		cl(ac97_cr) },
	{ 0x41445300, "Analog Devices",		cl(ac97_ad) },
	{ 0x414b4D00, "Asahi Kasei",		cl(ac97_ak) },
	{ 0x414c4300, "Realtek",		cl(ac97_rl) },
	{ 0x414c4700, "Avance Logic",		cl(ac97_av) },
	{ 0x434d4900, "C-Media Electronics",	cl(ac97_cm) },
	{ 0x43525900, "Cirrus Logic",		cl(ac97_cs) },
	{ 0x43585400, "Conexant",		cl(ac97_cx) },
	{ 0x44543000, "Diamond Technology",	cl(ac97_dt) },
	{ 0x454d4300, "eMicro",			cl(ac97_em) },
	{ 0x45838300, "ESS Technology",		cl(ac97_es) },
	{ 0x48525300, "Intersil",		cl(ac97_is) },
	{ 0x49434500, "ICEnsemble",		cl(ac97_ic) },
	{ 0x49544500, "ITE, Inc.",		cl(ac97_it) },
	{ 0x4e534300, "National Semiconductor", cl(ac97_ns) },
	{ 0x50534300, "Philips Semiconductor",	cl(ac97_ps) },
	{ 0x53494c00, "Silicon Laboratory",	cl(ac97_sl) },
	{ 0x54524100, "TriTech Microelectronics", cl(ac97_tt) },
	{ 0x54584e00, "Texas Instruments",	cl(ac97_ti) },
	{ 0x56494100, "VIA Technologies",	cl(ac97_vi) },
	{ 0x57454300, "Winbond",		cl(ac97_wb) },
	{ 0x574d4c00, "Wolfson",		cl(ac97_wo) },
	{ 0x594d4800, "Yamaha",			cl(ac97_ym) },
	{ 0x83847600, "SigmaTel",		cl(ac97_st) },
};
#undef cl

const char * const ac97enhancement[] = {
	"No 3D Stereo",
	"Analog Devices Phat Stereo",
	"Creative",
	"National Semi 3D",
	"Yamaha Ymersion",
	"BBE 3D",
	"Crystal Semi 3D",
	"Qsound QXpander",
	"Spatializer 3D",
	"SRS 3D",
	"Platform Tech 3D",
	"AKM 3D",
	"Aureal",
	"AZTECH 3D",
	"Binaura 3D",
	"ESS Technology",
	"Harman International VMAx",
	"Nvidea 3D",
	"Philips Incredible Sound",
	"Texas Instruments 3D",
	"VLSI Technology 3D",
	"TriTech 3D",
	"Realtek 3D",
	"Samsung 3D",
	"Wolfson Microelectronics 3D",
	"Delta Integration 3D",
	"SigmaTel 3D",
	"KS Waves 3D",
	"Rockwell 3D",
	"Unknown 3D",
	"Unknown 3D",
	"Unknown 3D"
};

const char * const ac97feature[] = {
	"mic channel",
	"reserved",
	"tone",
	"simulated stereo",
	"headphone",
	"bass boost",
	"18 bit DAC",
	"20 bit DAC",
	"18 bit ADC",
	"20 bit ADC"
};


int	ac97_str_equal(const char *, const char *);
int	ac97_check_capability(struct ac97_softc *, int);
void	ac97_setup_source_info(struct ac97_softc *);
void	ac97_setup_defaults(struct ac97_softc *);
int	ac97_read(struct ac97_softc *, u_int8_t, u_int16_t *);
int	ac97_write(struct ac97_softc *, u_int8_t, u_int16_t);


#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (ac97debug) printf x
#define DPRINTFN(n,x)	if (ac97debug>(n)) printf x
#ifdef AC97_DEBUG
int	ac97debug = 1;
#else
int	ac97debug = 0;
#endif
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

int
ac97_read(struct ac97_softc *as, u_int8_t reg, u_int16_t *val)
{
	int error;

	if (((as->host_flags & AC97_HOST_DONT_READ) &&
	    (reg != AC97_REG_VENDOR_ID1 && reg != AC97_REG_VENDOR_ID2 &&
	    reg != AC97_REG_RESET)) ||
	    (as->host_flags & AC97_HOST_DONT_READANY)) {
		*val = as->shadow_reg[reg >> 1];
		return (0);
	}

	if ((error = as->host_if->read(as->host_if->arg, reg, val)))
		*val = as->shadow_reg[reg >> 1];
	return (error);
}

int
ac97_write(struct ac97_softc *as, u_int8_t reg, u_int16_t val)
{
	as->shadow_reg[reg >> 1] = val;
	return (as->host_if->write(as->host_if->arg, reg, val));
}

void
ac97_setup_defaults(struct ac97_softc *as)
{
	int idx;

	bzero(as->shadow_reg, sizeof(as->shadow_reg));

	for (idx = 0; idx < nitems(source_info); idx++) {
		const struct ac97_source_info *si = &source_info[idx];

		ac97_write(as, si->reg, si->default_value);
	}
}

void
ac97_restore_shadow(struct ac97_codec_if *self)
{
	struct ac97_softc *as = (struct ac97_softc *)self;
	int idx;

	for (idx = 0; idx < nitems(source_info); idx++) {
		const struct ac97_source_info *si = &source_info[idx];

		ac97_write(as, si->reg, as->shadow_reg[si->reg >> 1]);
	}
}

int
ac97_str_equal(const char *a, const char *b)
{
	return ((a == b) || (a && b && (!strcmp(a, b))));
}

int
ac97_check_capability(struct ac97_softc *as, int check)
{
	switch (check) {
	case CHECK_NONE:
		return 1;
	case CHECK_SURROUND:
		return as->ext_id & AC97_EXT_AUDIO_SDAC;
	case CHECK_CENTER:
		return as->ext_id & AC97_EXT_AUDIO_CDAC;
	case CHECK_LFE:
		return as->ext_id & AC97_EXT_AUDIO_LDAC;
	case CHECK_SPDIF:
		return as->ext_id & AC97_EXT_AUDIO_SPDIF;
	case CHECK_HEADPHONES:
		return as->caps & AC97_CAPS_HEADPHONES;
	case CHECK_TONE:
		return as->caps & AC97_CAPS_TONECTRL;
	case CHECK_MIC:
		return as->caps & AC97_CAPS_MICIN;
	case CHECK_LOUDNESS:
		return as->caps & AC97_CAPS_LOUDNESS;
	case CHECK_3D:
		return AC97_CAPS_ENHANCEMENT(as->caps) != 0;
	default:
		printf("%s: internal error: feature=%d\n", __func__, check);
		return 0;
	}
}

void
ac97_setup_source_info(struct ac97_softc *as)
{
	struct ac97_source_info *si, *si2;
	int idx, ouridx;

	for (idx = 0, ouridx = 0; idx < nitems(source_info); idx++) {
		si = &as->source_info[ouridx];

		if (!ac97_check_capability(as, source_info[idx].req_feature))
			continue;

		bcopy(&source_info[idx], si, sizeof(*si));

		switch (si->type) {
		case AUDIO_MIXER_CLASS:
			si->mixer_class = ouridx;
			ouridx++;
			break;
		case AUDIO_MIXER_VALUE:
			/* Todo - Test to see if it works */
			ouridx++;

			/* Add an entry for mute, if necessary */
			if (si->mute) {
				si = &as->source_info[ouridx];
				bcopy(&source_info[idx], si, sizeof(*si));
				si->qualifier = AudioNmute;
				si->type = AUDIO_MIXER_ENUM;
				si->info = &ac97_on_off;
				si->info_size = sizeof(ac97_on_off);
				si->bits = 1;
				si->ofs = 15;
				si->mute = 0;
				si->polarity = 0;
				ouridx++;
			}
			break;
		case AUDIO_MIXER_ENUM:
			/* Todo - Test to see if it works */
			ouridx++;
			break;
		default:
			printf ("ac97: shouldn't get here\n");
			break;
		}
	}

	as->num_source_info = ouridx;

	for (idx = 0; idx < as->num_source_info; idx++) {
		int idx2, previdx;

		si = &as->source_info[idx];

		/* Find mixer class */
		for (idx2 = 0; idx2 < as->num_source_info; idx2++) {
			si2 = &as->source_info[idx2];

			if (si2->type == AUDIO_MIXER_CLASS &&
			    ac97_str_equal(si->class, si2->class)) {
				si->mixer_class = idx2;
			}
		}


		/* Setup prev and next pointers */
		if (si->prev != 0 || si->qualifier)
			continue;

		si->prev = AUDIO_MIXER_LAST;
		previdx = idx;

		for (idx2 = 0; idx2 < as->num_source_info; idx2++) {
			if (idx2 == idx)
				continue;

			si2 = &as->source_info[idx2];

			if (!si2->prev &&
			    ac97_str_equal(si->class, si2->class) &&
			    ac97_str_equal(si->device, si2->device)) {
				as->source_info[previdx].next = idx2;
				as->source_info[idx2].prev = previdx;

				previdx = idx2;
			}
		}

		as->source_info[previdx].next = AUDIO_MIXER_LAST;
	}
}

int
ac97_attach(struct ac97_host_if *host_if)
{
	struct ac97_softc *as;
	u_int16_t id1, id2, val;
	u_int32_t id;
	u_int16_t extstat, rate;
	mixer_ctrl_t ctl;
	int error, i;
	void (*initfunc)(struct ac97_softc *, int);

	initfunc = NULL;

	if (!(as = malloc(sizeof(*as), M_DEVBUF, M_NOWAIT | M_ZERO)))
		return (ENOMEM);

	as->codec_if.as = as;
	as->codec_if.vtbl = &ac97civ;
	as->host_if = host_if;

	if ((error = host_if->attach(host_if->arg, &as->codec_if))) {
		free(as, M_DEVBUF, sizeof(*as));
		return (error);
	}

	host_if->reset(host_if->arg);
	DELAY(1000);

	host_if->write(host_if->arg, AC97_REG_POWER, 0);
	host_if->write(host_if->arg, AC97_REG_RESET, 0);
	DELAY(10000);

	if (host_if->flags)
		as->host_flags = host_if->flags(host_if->arg);

	ac97_setup_defaults(as);
	ac97_read(as, AC97_REG_VENDOR_ID1, &id1);
	ac97_read(as, AC97_REG_VENDOR_ID2, &id2);
	ac97_read(as, AC97_REG_RESET, &as->caps);

	id = (id1 << 16) | id2;
	if (id) {
		register const struct ac97_vendorid *vendor;
		register const struct ac97_codecid *codec;

		printf("ac97: codec id 0x%08x", id);
		for (vendor = &ac97_vendors[sizeof(ac97_vendors) /
		     sizeof(ac97_vendors[0]) - 1];
		     vendor >= ac97_vendors; vendor--) {
			if (vendor->id == (id & AC97_VENDOR_ID_MASK)) {
				printf(" (%s", vendor->name);
				for (codec = &vendor->codecs[vendor->num-1];
				     codec >= vendor->codecs; codec--) {
					if (codec->id == (id & codec->mask))
						break;
				}
				if (codec >= vendor->codecs && codec->mask) {
					printf(" %s", codec->name);
					initfunc = codec->init;
				} else
					printf(" <%02x>", id & 0xff);
				if (codec >= vendor->codecs && codec->rev)
					printf(" rev %d", id & codec->rev);
				printf(")");
				break;
			}
		}
		printf("\n");
	} else
		printf("ac97: codec id not read\n");

	if (as->caps) {
		printf("ac97: codec features ");
		for (i = 0; i < 10; i++) {
			if (as->caps & (1 << i))
				printf("%s, ", ac97feature[i]);
		}
		printf("%s\n",
		    ac97enhancement[AC97_CAPS_ENHANCEMENT(as->caps)]);
	}


	as->ac97_clock = AC97_STANDARD_CLOCK;
	ac97_read(as, AC97_REG_EXT_AUDIO_ID, &as->ext_id);
	if (as->ext_id & (AC97_EXT_AUDIO_VRA | AC97_EXT_AUDIO_DRA
			  | AC97_EXT_AUDIO_SPDIF | AC97_EXT_AUDIO_VRM
			  | AC97_EXT_AUDIO_CDAC | AC97_EXT_AUDIO_SDAC
			  | AC97_EXT_AUDIO_LDAC)) {

		ac97_read(as, AC97_REG_EXT_AUDIO_CTRL, &extstat);
		extstat &= ~AC97_EXT_AUDIO_DRA;

		if (as->ext_id & AC97_EXT_AUDIO_VRM)
			extstat |= AC97_EXT_AUDIO_VRM;

		if (as->ext_id & AC97_EXT_AUDIO_LDAC)
			extstat |= AC97_EXT_AUDIO_LDAC;
		if (as->ext_id & AC97_EXT_AUDIO_SDAC)
			extstat |= AC97_EXT_AUDIO_SDAC;
		if (as->ext_id & AC97_EXT_AUDIO_CDAC)
			extstat |= AC97_EXT_AUDIO_CDAC;
		if (as->ext_id & AC97_EXT_AUDIO_SPDIF) {
			/* XXX S/PDIF gets same data as DAC?
			 * maybe this should be settable?
			 * default is SPSAAB (10/11) on AD1980 and ALC codecs.
			 */
			extstat &= ~AC97_EXT_AUDIO_SPSA_MASK;
			extstat |= AC97_EXT_AUDIO_SPSA34;
			ac97_read(as, AC97_REG_SPDIF_CTRL, &val);
			val = (val & ~AC97_SPDIF_SPSR_MASK) |
			    AC97_SPDIF_SPSR_48K;
			ac97_write(as, AC97_REG_SPDIF_CTRL, val);
		}
		if (as->ext_id & AC97_EXT_AUDIO_VRA)
			extstat |= AC97_EXT_AUDIO_VRA;
		ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, extstat);
		if (as->ext_id & AC97_EXT_AUDIO_VRA) {
			/* VRA should be enabled. */
			/* so it claims to do variable rate, let's make sure */
			ac97_write(as, AC97_REG_PCM_FRONT_DAC_RATE, 44100);
			ac97_read(as, AC97_REG_PCM_FRONT_DAC_RATE, &rate);
			if (rate != 44100) {
				/* We can't believe ext_id */
				as->ext_id = 0;
			}
			/* restore the default value */
			ac97_write(as, AC97_REG_PCM_FRONT_DAC_RATE,
				   AC97_SINGLE_RATE);
		}
	}

	ac97_setup_source_info(as);

	DELAY(900 * 1000);

	/* use initfunc for specific device */
	as->codec_if.initfunc = initfunc;
	if (initfunc != NULL)
		initfunc(as, 0);

	/* Just enable the DAC and master volumes by default */
	bzero(&ctl, sizeof(ctl));

	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;  /* off */
	ctl.dev = ac97_get_portnum_by_name(&as->codec_if, AudioCoutputs,
	    AudioNmaster, AudioNmute);
	ac97_mixer_set_port(&as->codec_if, &ctl);

	ctl.dev = ac97_get_portnum_by_name(&as->codec_if, AudioCinputs,
	    AudioNdac, AudioNmute);
	ac97_mixer_set_port(&as->codec_if, &ctl);

	ctl.dev = ac97_get_portnum_by_name(&as->codec_if, AudioCrecord,
	    AudioNvolume, AudioNmute);
	ac97_mixer_set_port(&as->codec_if, &ctl);

	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;
	ctl.dev = ac97_get_portnum_by_name(&as->codec_if, AudioCrecord,
	    AudioNsource, NULL);
	ac97_mixer_set_port(&as->codec_if, &ctl);

	return (0);
}

int
ac97_resume(struct ac97_host_if *host_if, struct ac97_codec_if *codec_if)
{
	struct ac97_softc *as = codec_if->as;
	u_int16_t val, extstat;

	host_if->reset(host_if->arg);
	DELAY(1000);

	host_if->write(host_if->arg, AC97_REG_POWER, 0);
	host_if->write(host_if->arg, AC97_REG_RESET, 0);
	DELAY(10000);

	codec_if->vtbl->restore_ports(codec_if);

	if (as->ext_id & (AC97_EXT_AUDIO_VRA | AC97_EXT_AUDIO_DRA
			  | AC97_EXT_AUDIO_SPDIF | AC97_EXT_AUDIO_VRM
			  | AC97_EXT_AUDIO_CDAC | AC97_EXT_AUDIO_SDAC
			  | AC97_EXT_AUDIO_LDAC)) {

		ac97_read(as, AC97_REG_EXT_AUDIO_CTRL, &extstat);
		extstat &= ~AC97_EXT_AUDIO_DRA;

		if (as->ext_id & AC97_EXT_AUDIO_VRM)
			extstat |= AC97_EXT_AUDIO_VRM;

		if (as->ext_id & AC97_EXT_AUDIO_LDAC)
			extstat |= AC97_EXT_AUDIO_LDAC;
		if (as->ext_id & AC97_EXT_AUDIO_SDAC)
			extstat |= AC97_EXT_AUDIO_SDAC;
		if (as->ext_id & AC97_EXT_AUDIO_CDAC)
			extstat |= AC97_EXT_AUDIO_CDAC;

		if (as->ext_id & AC97_EXT_AUDIO_SPDIF) {
			extstat &= ~AC97_EXT_AUDIO_SPSA_MASK;
			extstat |= AC97_EXT_AUDIO_SPSA34;
			ac97_read(as, AC97_REG_SPDIF_CTRL, &val);
			val = (val & ~AC97_SPDIF_SPSR_MASK) |
			    AC97_SPDIF_SPSR_48K;
			ac97_write(as, AC97_REG_SPDIF_CTRL, val);
		}
		if (as->ext_id & AC97_EXT_AUDIO_VRA)
			extstat |= AC97_EXT_AUDIO_VRA;
		ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, extstat);
	}

	/* use initfunc for specific device */
	if (as->codec_if.initfunc != NULL)
		as->codec_if.initfunc(as, 1);

	return (0);
}

void
ac97_lock(struct ac97_codec_if *codec_if)
{
	struct ac97_softc *as = (struct ac97_softc *)codec_if;
	as->lock_counter++;
}

void
ac97_unlock(struct ac97_codec_if *codec_if)
{
	struct ac97_softc *as = (struct ac97_softc *)codec_if;
	as->lock_counter--;
}

int
ac97_query_devinfo(struct ac97_codec_if *codec_if, mixer_devinfo_t *dip)
{
	struct ac97_softc *as = (struct ac97_softc *)codec_if;

	if (dip->index < as->num_source_info && dip->index >= 0) {
		struct ac97_source_info *si = &as->source_info[dip->index];
		const char *name;

		dip->type = si->type;
		dip->mixer_class = si->mixer_class;
		dip->prev = si->prev;
		dip->next = si->next;

		if (si->qualifier)
			name = si->qualifier;
		else if (si->device)
			name = si->device;
		else if (si->class)
			name = si->class;
		else
			name = NULL;

		if (name)
			strlcpy(dip->label.name, name, sizeof dip->label.name);

		bcopy(si->info, &dip->un, si->info_size);

		/* Set the delta for volume sources */
		if (dip->type == AUDIO_MIXER_VALUE)
			dip->un.v.delta = 1 << (8 - si->bits);

		return (0);
	}

	return (ENXIO);
}

int
ac97_mixer_set_port(struct ac97_codec_if *codec_if, mixer_ctrl_t *cp)
{
	struct ac97_softc *as = (struct ac97_softc *)codec_if;
	struct ac97_source_info *si = &as->source_info[cp->dev];
	u_int16_t mask;
	u_int16_t val, newval;
	int error, spdif;

	if (cp->dev < 0 || cp->dev >= as->num_source_info ||
	    cp->type == AUDIO_MIXER_CLASS || cp->type != si->type)
		return (EINVAL);

	spdif = si->req_feature == CHECK_SPDIF &&
	    si->reg == AC97_REG_EXT_AUDIO_CTRL;
	if (spdif && as->lock_counter >= 0)
		return EBUSY;

	ac97_read(as, si->reg, &val);

	DPRINTFN(5, ("read(%x) = %x\n", si->reg, val));

	mask = (1 << si->bits) - 1;

	switch (cp->type) {
	case AUDIO_MIXER_ENUM:
		if (cp->un.ord > mask || cp->un.ord < 0)
			return (EINVAL);

		newval = (cp->un.ord << si->ofs);
		if (si->reg == AC97_REG_RECORD_SELECT) {
			newval |= (newval << (8 + si->ofs));
			mask |= (mask << 8);
			mask = mask << si->ofs;
		} else if (si->reg == AC97_REG_SURR_MASTER) {
			newval = cp->un.ord ? 0x8080 : 0x0000;
			mask = 0x8080;
		} else
			mask = mask << si->ofs;

		if (si->mute) {
			newval |= newval << 8;
			mask |= mask << 8;
		}

		break;
	case AUDIO_MIXER_VALUE:
	{
		const struct audio_mixer_value *value = si->info;
		u_int16_t  l, r;

		if (cp->un.value.num_channels <= 0 ||
		    cp->un.value.num_channels > value->num_channels)
			return (EINVAL);

		if (cp->un.value.num_channels == 1) {
			l = r = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		} else {
			if (!(as->host_flags & AC97_HOST_SWAPPED_CHANNELS)) {
				l = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
				r = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
			} else {
				r = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
				l = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
			}
		}

		if (!si->polarity) {
			l = 255 - l;
			r = 255 - r;
		}

		l >>= 8 - si->bits;
		r >>= 8 - si->bits;

		newval = ((l & mask) << si->ofs);
		if (value->num_channels == 2) {
			newval |= ((r & mask) << (si->ofs + 8));
			mask |= (mask << 8);
		}
		mask = mask << si->ofs;
		break;
	}
	default:
		return (EINVAL);
	}

	error = ac97_write(as, si->reg, (val & ~mask) | newval);
	if (error)
		return (error);

	if (spdif && as->host_if->spdif_event != NULL)
		as->host_if->spdif_event(as->host_if->arg, cp->un.ord);

	return (0);
}


int
ac97_set_rate(struct ac97_codec_if *codec_if, int target, u_long *rate)
{
	struct ac97_softc *as;
	u_long value;
	u_int16_t ext_stat;
	u_int16_t actual;
	u_int16_t power;
	u_int16_t power_bit;

	as = (struct ac97_softc *)codec_if;

	if ((target == AC97_REG_PCM_SURR_DAC_RATE) &&
	    !(as->ext_id & AC97_EXT_AUDIO_SDAC))
			return 0;
	if ((target == AC97_REG_PCM_LFE_DAC_RATE) &&
	    !(as->ext_id & AC97_EXT_AUDIO_LDAC))
			return 0;
	if (target == AC97_REG_PCM_MIC_ADC_RATE) {
		if (!(as->ext_id & AC97_EXT_AUDIO_VRM)) {
			*rate = AC97_SINGLE_RATE;
			return 0;
		}
	} else {
		if (!(as->ext_id & AC97_EXT_AUDIO_VRA)) {
			*rate = AC97_SINGLE_RATE;
			return 0;
		}
	}
	if (as->ac97_clock == 0)
		as->ac97_clock = AC97_STANDARD_CLOCK;
	value = *rate * AC97_STANDARD_CLOCK / as->ac97_clock;
	ext_stat = 0;
	/*
	 * PCM_FRONT_DAC_RATE/PCM_SURR_DAC_RATE/PCM_LFE_DAC_RATE
	 *	Check VRA, DRA
	 * PCM_LR_ADC_RATE
	 *	Check VRA
	 * PCM_MIC_ADC_RATE
	 *	Check VRM
	 */
	switch (target) {
	case AC97_REG_PCM_FRONT_DAC_RATE:
	case AC97_REG_PCM_SURR_DAC_RATE:
	case AC97_REG_PCM_LFE_DAC_RATE:
		power_bit = AC97_POWER_OUT;
		if (as->ext_id & AC97_EXT_AUDIO_DRA) {
			ac97_read(as, AC97_REG_EXT_AUDIO_CTRL, &ext_stat);
			if (value > 0x1ffff) {
				return EINVAL;
			} else if (value > 0xffff) {
				/* Enable DRA */
				ext_stat |= AC97_EXT_AUDIO_DRA;
				ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, ext_stat);
				value /= 2;
			} else {
				/* Disable DRA */
				ext_stat &= ~AC97_EXT_AUDIO_DRA;
				ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, ext_stat);
			}
		} else {
			if (value > 0xffff)
				return EINVAL;
		}
		break;
	case AC97_REG_PCM_LR_ADC_RATE:
		power_bit = AC97_POWER_IN;
		if (value > 0xffff)
			return EINVAL;
		break;
	case AC97_REG_PCM_MIC_ADC_RATE:
		power_bit = AC97_POWER_IN;
		if (value > 0xffff)
			return EINVAL;
		break;
	default:
		printf("%s: Unknown register: 0x%x\n", __func__, target);
		return EINVAL;
	}

	ac97_read(as, AC97_REG_POWER, &power);
	ac97_write(as, AC97_REG_POWER, power | power_bit);

	ac97_write(as, target, (u_int16_t)value);
	ac97_read(as, target, &actual);
	actual = (u_int32_t)actual * as->ac97_clock / AC97_STANDARD_CLOCK;

	ac97_write(as, AC97_REG_POWER, power);
	if (ext_stat & AC97_EXT_AUDIO_DRA) {
		*rate = actual * 2;
	} else {
		*rate = actual;
	}
	return 0;
}

void
ac97_set_clock(struct ac97_codec_if *codec_if, unsigned int clock)
{
	struct ac97_softc *as;

	as = (struct ac97_softc *)codec_if;
	as->ac97_clock = clock;
}

u_int16_t
ac97_get_extcaps(struct ac97_codec_if *codec_if)
{
	struct ac97_softc *as;

	as = (struct ac97_softc *)codec_if;
	return as->ext_id;
}

int
ac97_add_port(struct ac97_softc *as, struct ac97_source_info *src)
{
	struct ac97_source_info *si;
	int ouridx, idx;

	if (as->num_source_info >= MAX_SOURCES) {
		printf("%s: internal error: increase MAX_SOURCES in %s\n",
		       __func__, __FILE__);
		return -1;
	}
	if (!ac97_check_capability(as, src->req_feature))
		return -1;
	ouridx = as->num_source_info;
	si = &as->source_info[ouridx];
	memcpy(si, src, sizeof(*si));

	switch (si->type) {
	case AUDIO_MIXER_CLASS:
	case AUDIO_MIXER_VALUE:
		printf("%s: adding class/value is not supported yet.\n",
		       __func__);
		return -1;
	case AUDIO_MIXER_ENUM:
		break;
	default:
		printf("%s: unknown type: %d\n", __func__, si->type);
		return -1;
	}
	as->num_source_info++;

	si->mixer_class = ac97_get_portnum_by_name(&as->codec_if, si->class,
						   NULL, NULL);
	/* Find the root of the device */
	idx = ac97_get_portnum_by_name(&as->codec_if, si->class,
				       si->device, NULL);
	/* Find the last item */
	while (as->source_info[idx].next != AUDIO_MIXER_LAST)
		idx = as->source_info[idx].next;
	/* Append */
	as->source_info[idx].next = ouridx;
	si->prev = idx;
	si->next = AUDIO_MIXER_LAST;

	return 0;
}

int
ac97_get_portnum_by_name(struct ac97_codec_if *codec_if, char *class,
    char *device, char *qualifier)
{
	struct ac97_softc *as = (struct ac97_softc *)codec_if;
	int idx;

	for (idx = 0; idx < as->num_source_info; idx++) {
		struct ac97_source_info *si = &as->source_info[idx];
		if (ac97_str_equal(class, si->class) &&
		    ac97_str_equal(device, si->device) &&
		    ac97_str_equal(qualifier, si->qualifier))
			return (idx);
	}

	return (-1);
}

int
ac97_mixer_get_port(struct ac97_codec_if *codec_if, mixer_ctrl_t *cp)
{
	struct ac97_softc *as = (struct ac97_softc *)codec_if;
	struct ac97_source_info *si = &as->source_info[cp->dev];
	u_int16_t mask;
	u_int16_t val;

	if (cp->dev < 0 || cp->dev >= as->num_source_info ||
	    cp->type != si->type)
		return (EINVAL);

	ac97_read(as, si->reg, &val);

	DPRINTFN(5, ("read(%x) = %x\n", si->reg, val));

	mask = (1 << si->bits) - 1;

	switch (cp->type) {
	case AUDIO_MIXER_ENUM:
		cp->un.ord = (val >> si->ofs) & mask;
		DPRINTFN(4, ("AUDIO_MIXER_ENUM: %x %d %x %d\n", val, si->ofs,
		    mask, cp->un.ord));
		break;
	case AUDIO_MIXER_VALUE:
	{
		const struct audio_mixer_value *value = si->info;
		u_int16_t  l, r;

		if ((cp->un.value.num_channels <= 0) ||
		    (cp->un.value.num_channels > value->num_channels))
			return (EINVAL);

		if (value->num_channels == 1)
			l = r = (val >> si->ofs) & mask;
		else {
			if (!(as->host_flags & AC97_HOST_SWAPPED_CHANNELS)) {
				l = (val >> si->ofs) & mask;
				r = (val >> (si->ofs + 8)) & mask;
			} else {
				r = (val >> si->ofs) & mask;
				l = (val >> (si->ofs + 8)) & mask;
			}
		}

		l <<= 8 - si->bits;
		r <<= 8 - si->bits;
		if (!si->polarity) {
			l = 255 - l;
			r = 255 - r;
		}

		/*
		 * The EAP driver averages l and r for stereo
		 * channels that are requested in MONO mode. Does this
		 * make sense?
		 */
		if (cp->un.value.num_channels == 1) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = l;
		} else if (cp->un.value.num_channels == 2) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;
		}

		break;
	}
	default:
		return (EINVAL);
	}

	return (0);
}


/*
 * Codec-dependent initialization
 */

void
ac97_ad1885_init(struct ac97_softc *as, int resuming)
{
	int i;

	if (resuming)
		return;

	for (i = 0; i < as->num_source_info; i++) {
		if (as->source_info[i].reg == AC97_REG_HEADPHONE_VOLUME)
			as->source_info[i].reg = AC97_REG_MASTER_VOLUME;
		else if (as->source_info[i].reg == AC97_REG_MASTER_VOLUME)
			as->source_info[i].reg = AC97_REG_HEADPHONE_VOLUME;
	}
}

#define AC97_AD1886_JACK_SENSE	0x72

void
ac97_ad1886_init(struct ac97_softc *as, int resuming)
{
	ac97_write(as, AC97_AD1886_JACK_SENSE, 0x0010);
}

void
ac97_ad198x_init(struct ac97_softc *as, int resuming)
{
	int i;
	u_int16_t misc;

	ac97_read(as, AC97_AD_REG_MISC, &misc);
	ac97_write(as, AC97_AD_REG_MISC,
	    misc|AC97_AD_MISC_HPSEL|AC97_AD_MISC_LOSEL);

	if (resuming)
		return;

	for (i = 0; i < as->num_source_info; i++) {
		if (as->source_info[i].reg == AC97_REG_SURR_MASTER)
			as->source_info[i].reg = AC97_REG_MASTER_VOLUME;
		else if (as->source_info[i].reg == AC97_REG_MASTER_VOLUME)
			as->source_info[i].reg = AC97_REG_SURR_MASTER;
	}
}

void
ac97_alc650_init(struct ac97_softc *as, int resuming)
{
	u_int16_t misc;

	ac97_read(as, AC97_ALC650_REG_MISC, &misc);
	if (as->host_flags & AC97_HOST_ALC650_PIN47_IS_EAPD)
		misc &= ~AC97_ALC650_MISC_PIN47;
	misc &= ~AC97_ALC650_MISC_VREFDIS;
	ac97_write(as, AC97_ALC650_REG_MISC, misc);

	if (resuming)
		return;

	struct ac97_source_info sources[3] = {
		{ AudioCoutputs, AudioNsurround, "lineinjack",
		  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
		  AC97_ALC650_REG_MULTI_CHANNEL_CONTROL,
		  0x0000, 1, 9, 0, 0, CHECK_SURROUND },
		{ AudioCoutputs, AudioNcenter, "micjack",
		  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
		  AC97_ALC650_REG_MULTI_CHANNEL_CONTROL,
		  0x0000, 1, 10, 0, 0, CHECK_CENTER },
		{ AudioCoutputs, AudioNlfe, "micjack",
		  AUDIO_MIXER_ENUM, WRAP(ac97_on_off),
		  AC97_ALC650_REG_MULTI_CHANNEL_CONTROL,
		  0x0000, 1, 10, 0, 0, CHECK_LFE }};

	ac97_add_port(as, &sources[0]);
	ac97_add_port(as, &sources[1]);
	ac97_add_port(as, &sources[2]);
}

void
ac97_cx20468_init(struct ac97_softc *as, int resuming)
{
	u_int16_t misc;

	ac97_read(as, AC97_CX_REG_MISC, &misc);
	ac97_write(as, AC97_CX_REG_MISC, misc &
	    ~(AC97_CX_SPDIFEN | AC97_CX_COPYRIGHT | AC97_CX_MASK));
}

void
ac97_vt1616_init(struct ac97_softc *as, int resuming)
{
	u_int16_t reg;

	if (as->host_flags & AC97_HOST_VT1616_DYNEX) {
		ac97_read(as, AC97_VT_REG_TEST, &reg);

		/* disable 'hp' mixer controls controlling the surround pins */
		reg &= ~(AC97_VT_LVL);

		/* disable downmixing */
		reg &= ~(AC97_VT_LCTF | AC97_VT_STF);

		/* enable DC offset removal */
		reg |= AC97_VT_BPDC;

		ac97_write(as, AC97_VT_REG_TEST, reg);
	}
}
@


1.81
log
@fairly simple sizes for free(); ok tedu
@
text
@a609 6
void
ac97_get_default_params(struct audio_params *params)
{
	*params = ac97_audio_default;
}

@


1.80
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.79 2015/03/14 03:38:47 jsg Exp $	*/
d818 1
a818 1
		free(as, M_DEVBUF, 0);
@


1.79
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.78 2014/07/12 18:48:17 tedu Exp $	*/
d80 1
a80 3
	2,		/* channels */
	NULL,		/* sw_code */
	1		/* factor */
@


1.78
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.77 2011/01/03 15:28:46 fgsch Exp $	*/
a66 1
#include <sys/device.h>
@


1.77
log
@use host_flags directly as they're initialized during attach time.
jakemsr@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.76 2011/01/03 10:00:22 jakemsr Exp $	*/
d821 1
a821 1
		free(as, M_DEVBUF);
@


1.76
log
@the flags method of the ac97 host interface is optional.  check that
it not NULL before using it.
fixes crash reported by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.75 2010/12/22 09:54:27 jakemsr Exp $	*/
d1519 1
a1519 2
	if (as->host_if->flags &&
	    (as->host_if->flags(as->host_if->arg) & AC97_HOST_VT1616_DYNEX)) {
@


1.75
log
@* recognize/support the Dynex DX-SC51 in envy(4)
* allow ac97(4) flags to be set in envy(4), if there is an ac97 codec
* configure the vt1616 codec on the Dynex DX-SC51 for multi-channel
  operation

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.74 2010/08/08 20:37:33 jakemsr Exp $	*/
d1519 2
a1520 1
	if (as->host_if->flags(as->host_if->arg) & AC97_HOST_VT1616_DYNEX) {
@


1.74
log
@suspend/resume support for auich, and some infrastructure in ac97
"commit" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.73 2010/07/15 03:43:11 jakemsr Exp $	*/
d354 1
d450 1
a450 1
	{ 0x52, 0xff, 0, 0,	"VIA VT1616i" },
d1512 21
@


1.73
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.72 2010/02/25 21:22:42 ratchov Exp $	*/
d349 5
a353 5
void	ac97_ad1885_init(struct ac97_softc *);
void	ac97_ad1886_init(struct ac97_softc *);
void	ac97_ad198x_init(struct ac97_softc *);
void	ac97_alc650_init(struct ac97_softc *);
void	ac97_cx20468_init(struct ac97_softc *);
d374 1
a374 1
	void (*init)(struct ac97_softc *);
d808 1
a808 1
	void (*initfunc)(struct ac97_softc *);
d815 1
d935 1
d937 1
a937 1
		initfunc(as);
d965 53
d1426 1
a1426 1
ac97_ad1885_init(struct ac97_softc *as)
d1430 3
d1444 1
a1444 1
ac97_ad1886_init(struct ac97_softc *as)
d1450 1
a1450 1
ac97_ad198x_init(struct ac97_softc *as)
d1459 3
d1471 1
a1471 1
ac97_alc650_init(struct ac97_softc *as)
d1481 3
d1504 1
a1504 1
ac97_cx20468_init(struct ac97_softc *as)
@


1.72
log
@Add VT1617 codec ID used in VIA Tremor 5.1 cards,
from Alexandr Shadchin <alexandr.shadchin at gmail.com>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.71 2009/12/15 20:26:21 jasper Exp $	*/
d79 2
@


1.71
log
@- instead of rolling a macro that is functional equivalent to nitems(),
just use nitems(). (this leaves NENTS() alone for now)

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.70 2008/10/23 21:50:01 jakemsr Exp $	*/
d482 1
@


1.70
log
@
S/PDIF output support in ac97(4), auich(4) and auvia(4)

from NetBSD

tested by a few with no regressions.  optical works for jsg@@.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.69 2008/10/23 20:52:50 jakemsr Exp $	*/
a312 2
#define SOURCE_INFO_SIZE (sizeof(source_info)/sizeof(source_info[0]))

d322 1
a322 1
#define MAX_SOURCES	(2 * SOURCE_INFO_SIZE)
d505 1
a505 1
#define	cl(n)	n, sizeof(n)/sizeof(n[0])
d647 1
a647 1
	for (idx = 0; idx < SOURCE_INFO_SIZE; idx++) {
d660 1
a660 1
	for (idx = 0; idx < SOURCE_INFO_SIZE; idx++) {
d709 1
a709 1
	for (idx = 0, ouridx = 0; idx < SOURCE_INFO_SIZE; idx++) {
@


1.69
log
@reove redundant variable sample rate checks.

ok ratchov (a while ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.68 2008/05/25 23:52:30 jakemsr Exp $	*/
d129 2
d157 2
a158 1
		CHECK_3D
d299 1
d304 5
d333 1
d338 2
d363 3
a365 1
	ac97_set_clock
d687 2
d802 1
a802 1
	u_int16_t id1, id2;
a886 2
		if (as->ext_id & AC97_EXT_AUDIO_VRA)
			extstat |= AC97_EXT_AUDIO_VRA;
d888 1
d891 5
d898 14
a911 4
		if (as->ext_id & AC97_EXT_AUDIO_SDAC)
			extstat |= AC97_EXT_AUDIO_SDAC;
		if (as->ext_id & AC97_EXT_AUDIO_LDAC)
			extstat |= AC97_EXT_AUDIO_LDAC;
d962 14
d1021 1
a1021 1
	int error;
d1024 1
a1024 1
	    cp->type != si->type)
d1027 5
d1104 3
@


1.68
log
@
add a function to get default parameters for ac97 codecs.  all ac97
codecs support 16-bit stereo slinear_le @@ 48kHz.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.67 2008/02/12 13:02:21 jakemsr Exp $	*/
a1105 4
		if (!(as->ext_id & AC97_EXT_AUDIO_VRA)) {
			*rate = AC97_SINGLE_RATE;
			return 0;
		}
a1126 4
		if (!(as->ext_id & AC97_EXT_AUDIO_VRA)) {
			*rate = AC97_SINGLE_RATE;
			return 0;
		}
a1131 4
		if (!(as->ext_id & AC97_EXT_AUDIO_VRM)) {
			*rate = AC97_SINGLE_RATE;
			return 0;
		}
@


1.67
log
@
pin 47 on ALC65{0,5,8} ac97 codecs can be used for either eapd or
spdif-in.  usually the deault of spdif-in is used, but some
ATI devices use pin 47 for eapd.

add a list of subsystem ids (from ALSA) for these devices, and set
bit 1 of register 7a to select the correct function of pin 47 for
these devices.

there was code here to do this prior to the ac97 update, but it
was accidentally removed.  rename the flag and bit to more accurately
reflect what this does and hopefully avoid future confusion.

problem noticed and fix tested/ok'd by matthieu@@, thanks

also some discussion with and pointers from brad@@, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.66 2008/01/15 02:52:50 jakemsr Exp $	*/
d73 11
d596 6
@


1.66
log
@bring in lots of ac97(4) and auvia(4) updates from NetBSD

user visible changes:
- when setting up ac97(4) mixer items, for some features like surround
  sound, check if the feature if supported by the codec and only add
  items for that feature if it is
- auvia(4) now supports multichannel playback with at least some
  multichannel ac97(4) codecs

fixes problems for me and ajacoutot with different auvia(4)
devices/codecs.  no regressions reported by testers.

if you have an ac97(4) audio device and are using mixerctl.conf(5),
you may want/need to update it.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.65 2008/01/13 21:43:01 deanna Exp $	*/
d1354 8
@


1.65
log
@Check for a negative devinfo index, which could get here through
mixer_ioctl.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.64 2007/10/01 04:03:51 krw Exp $	*/
d130 1
d135 11
a145 1
	u_int16_t default_value;
d151 138
a288 134
	{
		AudioCinputs,	NULL,		NULL,	AUDIO_MIXER_CLASS,
	}, {
		AudioCoutputs,	NULL,		NULL,	AUDIO_MIXER_CLASS,
	}, {
		AudioCrecord,	NULL,		NULL,	AUDIO_MIXER_CLASS,
	}, {
		/* Stereo master volume*/
		AudioCoutputs,	AudioNmaster,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_MASTER_VOLUME, 5, 0, 1, 0, 0x8000
	}, {
		/* Mono volume */
		AudioCoutputs,	AudioNmono,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_MASTER_VOLUME_MONO, 6, 0, 1, 0, 0x8000
	}, {
		AudioCoutputs,	AudioNmono, AudioNsource, AUDIO_MIXER_ENUM,
		WRAP(ac97_mono_select),
		AC97_REG_GP, 1, 9, 0, 0, 0x0000
	}, {
		/* Headphone volume */
		AudioCoutputs,	AudioNheadphone, NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_HEADPHONE_VOLUME, 6, 0, 1, 0, 0x8000
	}, {
		AudioCoutputs,	AudioNbass,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_MASTER_TONE, 4, 8, 0, 0, 0x0f0f
	}, {
		AudioCoutputs,	AudioNtreble,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_MASTER_TONE, 4, 0, 0, 0, 0x0f0f
	}, {
		/* PC Beep Volume */
		AudioCinputs,	AudioNspeaker,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_PCBEEP_VOLUME, 4, 1, 1, 0, 0x0000
	}, {
		/* Phone */
		AudioCinputs,	"phone",	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_PHONE_VOLUME, 5, 0, 1, 0, 0x8008
	}, {
		/* Mic Volume */
		AudioCinputs,	AudioNmicrophone, NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_MIC_VOLUME, 5, 0, 1, 0, 0x8008
	}, {
		AudioCinputs,	AudioNmicrophone, AudioNpreamp, AUDIO_MIXER_ENUM,
		WRAP(ac97_on_off),
		AC97_REG_MIC_VOLUME, 1, 6, 0, 0, 0x8008
	}, {
		AudioCinputs,	AudioNmicrophone, AudioNsource, AUDIO_MIXER_ENUM,
		WRAP(ac97_mic_select),
		AC97_REG_GP, 1, 8, 0, 0x0000
	}, {
		/* Line in Volume */
		AudioCinputs,	AudioNline,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_LINEIN_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* CD Volume */
		AudioCinputs,	AudioNcd,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_CD_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* Video Volume */
		AudioCinputs,	"video",	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_VIDEO_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* AUX volume */
		AudioCinputs,	AudioNaux,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_AUX_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* PCM out volume */
		AudioCinputs,	AudioNdac,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_PCMOUT_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* Record Source - some logic for this is hard coded - see below */
		AudioCrecord,	AudioNsource,	NULL,	AUDIO_MIXER_ENUM,
		WRAP(ac97_source),
		AC97_REG_RECORD_SELECT, 3, 0, 0, 0, 0x0000
	}, {
		/* Record Gain */
		AudioCrecord,	AudioNvolume,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_RECORD_GAIN, 4, 0, 1, 0, 0x8000
	}, {
		/* Record Gain mic */
		AudioCrecord,	AudioNmicrophone, NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_RECORD_GAIN_MIC, 4, 0, 1, 1, 0x8000
	}, {
		/* */
		AudioCoutputs,	AudioNloudness,	NULL,	AUDIO_MIXER_ENUM,
		WRAP(ac97_on_off),
		AC97_REG_GP, 1, 12, 0, 0, 0x0000
	}, {
		AudioCoutputs,	AudioNspatial,	NULL,	AUDIO_MIXER_ENUM,
		WRAP(ac97_on_off),
		AC97_REG_GP, 1, 13, 0, 0, 0x0000
	}, {
		AudioCoutputs,	AudioNspatial,	AudioNcenter,AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_3D_CONTROL, 4, 8, 0, 1, 0x0000
	}, {
		AudioCoutputs,	AudioNspatial,	AudioNdepth, AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_3D_CONTROL, 4, 0, 0, 1, 0x0000
	}, {
		/* Surround volume */
		AudioCoutputs,	AudioNsurround,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_SURROUND_VOLUME, 6, 0, 1, 0, 0x8080
	}, {
		/* Center volume */
		AudioCoutputs,	AudioNcenter,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_CENTER_LFE_VOLUME, 6, 0, 1, 0, 0x8080
	}, {
		/* LFE volume */
		AudioCoutputs,	AudioNlfe,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_CENTER_LFE_VOLUME, 6, 8, 1, 0, 0x8080
	}, {
		/* External Amp */
		AudioCoutputs,	AudioNextamp,	NULL,	AUDIO_MIXER_ENUM,
		WRAP(ac97_on_off),
		AC97_REG_POWER, 1, 15, 0, 0, 0x0000
	}
d301 1
d304 2
a305 1
	struct ac97_source_info source_info[2 * SOURCE_INFO_SIZE];
d308 4
a311 1
	u_int16_t caps, ext_id;
d321 4
d326 1
d329 1
a329 1
void	ac97_alc655_init(struct ac97_softc *);
d337 4
a340 1
	ac97_restore_shadow
d354 1
a354 1
	{ 0x60, 0xff, 0, 0,	"AD1885" },
d358 1
a358 1
	{ 0x70, 0xff, 0, 0,	"AD1980" },
d379 1
a379 1
	{ 0x60, 0xf0, 0xf, 0,	"ALC655",	ac97_alc655_init },
d381 1
a381 1
	{ 0x80, 0xf0, 0xf, 0,	"ALC658",	ac97_alc655_init },
d566 1
d644 28
d681 3
d771 1
d845 2
d848 6
a853 5
	if (as->ext_id)
		DPRINTF(("ac97: ext id %b\n", as->ext_id,
		    AC97_EXT_AUDIO_BITS));
	if (as->ext_id & (AC97_EXT_AUDIO_VRA | AC97_EXT_AUDIO_VRM)) {
		ac97_read(as, AC97_REG_EXT_AUDIO_CTRL, &id1);
d855 2
a856 1
			id1 |= AC97_EXT_AUDIO_VRA;
d858 21
a878 2
			id1 |= AC97_EXT_AUDIO_VRM;
		ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, id1);
d883 2
d935 2
d981 6
a986 1
		}
d1028 1
a1028 1

a1034 1
	mask = mask << si->ofs;
d1042 174
d1307 7
a1313 3
int
ac97_set_rate(struct ac97_codec_if *codec_if, struct audio_params *p,
    int mode)
d1315 1
a1315 2
	struct ac97_softc *as = (struct ac97_softc *)codec_if;
	u_int16_t reg, val, regval, id = 0;
d1317 5
a1321 5
	DPRINTFN(5, ("set_rate(%lu) ", p->sample_rate));

	if (!(as->ext_id & AC97_EXT_AUDIO_VRA)) {
		p->sample_rate = AC97_SINGLERATE;
		return (0);
a1322 36

	if (p->sample_rate > 0xffff) {
		if (mode != AUMODE_PLAY)
			return (EINVAL);
		if (!(as->ext_id & AC97_EXT_AUDIO_DRA))
			return (EINVAL);
		if (ac97_read(as, AC97_REG_EXT_AUDIO_CTRL, &id))
			return (EIO);
		id |= AC97_EXT_AUDIO_DRA;
		if (ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, id))
			return (EIO);
		p->sample_rate /= 2;
	}

	/* i guess it's better w/o clicks and squeecks when changing the rate */
	if (ac97_read(as, AC97_REG_POWER, &val) ||
	    ac97_write(as, AC97_REG_POWER, val |
	      (mode == AUMODE_PLAY? AC97_POWER_OUT : AC97_POWER_IN)))
		return (EIO);

	reg = mode == AUMODE_PLAY ?
	    AC97_REG_FRONT_DAC_RATE : AC97_REG_PCM_ADC_RATE;

	if (ac97_write(as, reg, (u_int16_t) p->sample_rate) ||
	    ac97_read(as, reg, &regval))
		return (EIO);
	p->sample_rate = regval;
	if (id & AC97_EXT_AUDIO_DRA)
		p->sample_rate *= 2;

	DPRINTFN(5, (" %lu\n", regval));

	if (ac97_write(as, AC97_REG_POWER, val))
		return (EIO);

	return (0);
a1324 4
/*
 * Codec-dependent initialization
 */

d1332 1
a1332 1
	
d1344 1
a1344 1
		if (as->source_info[i].reg == AC97_REG_SURROUND_VOLUME)
d1346 2
a1347 7
		else if (as->source_info[i].reg == AC97_REG_MASTER_VOLUME) {
			as->source_info[i].reg = AC97_REG_SURROUND_VOLUME;
			if (as->source_info[i].type == AUDIO_MIXER_ENUM) {
				as->source_info[i].mute = 1;
				as->source_info[i].ofs = 7;
			}
		}
d1352 1
a1352 1
ac97_alc655_init(struct ac97_softc *as)
d1354 17
a1370 12
	u_int16_t misc;

	ac97_read(as, AC97_AV_REG_MISC, &misc);
	if (as->host_flags & AC97_HOST_DONT_ENABLE_SPDIF) {
		misc &= ~AC97_AV_MISC_SPDIFEN;
	} else	{
		misc |= AC97_AV_MISC_SPDIFEN;
	}
	misc &= ~AC97_AV_MISC_VREFDIS;
	ac97_write(as, AC97_AV_REG_MISC, misc);

	ac97_write(as, AC97_AV_REG_MULTICH, AC97_AV_MULTICH_MAGIC);
@


1.64
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.63 2007/07/27 01:48:04 ian Exp $	*/
d834 1
a834 1
	if (dip->index < as->num_source_info) {
@


1.63
log
@Add ids for two Conexant codecs; not sure they're official
("does not exist outside of mentions in linux/netbsd on the web"),
gleaned from
http://www.ussg.iu.edu/hypermail/linux/kernel/0504.0/1146.html.
"sure" deraadt@@, ok with above comment jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.62 2007/07/09 01:24:54 jakemsr Exp $	*/
d717 1
a717 1
	if (!(as = malloc(sizeof(struct ac97_softc), M_DEVBUF, M_NOWAIT)))
a718 2

	bzero(as, sizeof(*as));
@


1.62
log
@don't always spew massive debug messages just because AUDIO_DEBUG is
defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.61 2006/06/30 14:46:11 mickey Exp $	*/
d380 2
a381 1
	{ 0x30, 0xff, 0, 0,	"CX?????", },
@


1.61
log
@newer alc codecs have revision in the low bits; pt out by jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.60 2006/04/27 21:40:00 matthieu Exp $	*/
a541 1
#define AC97_DEBUG 10
d547 1
a547 1
int	ac97debug = AC97_DEBUG;
@


1.60
log
@Quirk for MSI Megabook S270 audio output. Ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.59 2005/12/28 14:36:25 fgsch Exp $	*/
d351 4
a354 4
	{ 0x60, 0xff, 0, 0,	"ALC655",	ac97_alc655_init },
	{ 0x70, 0xff, 0, 0,	"ALC203" },
	{ 0x80, 0xff, 0, 0,	"ALC658",	ac97_alc655_init },
	{ 0x90, 0xff, 0, 0,	"ALC850" },
@


1.59
log
@correct CX20468 initialization; mickey@@ ok'ed this some time ago.
if you have this conexant codec give it a try.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.58 2005/12/14 13:59:04 fgsch Exp $	*/
d1135 5
a1139 1
	misc |= AC97_AV_MISC_SPDIFEN;
@


1.58
log
@some codecs have an external amplifier, and in some hw the bit to powering
it down seems to be inverted, so rather than guessing or workaround this,
add a extamp var so it can be toggled in userland via mixerctl(1).
audio works in hp nx6125 now; tested by todd@@, mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.57 2005/12/12 14:13:58 fgsch Exp $	*/
d1148 2
a1149 2
	ac97_write(as, AC97_CX_REG_MISC,
	    AC97_CX_SPDIFEN | AC97_CX_COPYRIGHT | AC97_CX_MASK);
@


1.57
log
@ansi, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.56 2005/06/18 21:23:59 canacar Exp $	*/
d268 5
d276 1
a276 1
} ;
d299 1
a299 1
				  char *);
a305 1
void	ac97_cx_init(struct ac97_softc *);
d380 1
a380 1
	{ 0x30, 0xff, 0, 0,	"CX?????",	ac97_cx_init },
a1149 16
}

void
ac97_cx_init(struct ac97_softc *as)
{
	u_int16_t misc, new;

	ac97_read(as, AC97_CX_REG_MISC, &misc);
	ac97_write(as, AC97_CX_REG_MISC,
	    AC97_CX_SPDIFEN | AC97_CX_COPYRIGHT | AC97_CX_MASK);

	ac97_read(as, AC97_REG_POWER, &misc);
	new = misc | AC97_POWER_EAMP;
	if (new != misc) {
		ac97_write(as, AC97_REG_POWER, new);
	}
@


1.56
log
@Switch master and surround volume controls on AD1888 and AD1985
Control muting of both left and right channels.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.55 2005/06/06 21:12:44 mjc Exp $	*/
d290 4
a293 4
int ac97_mixer_get_port(struct ac97_codec_if *self, mixer_ctrl_t *cp);
int ac97_mixer_set_port(struct ac97_codec_if *self, mixer_ctrl_t *);
int ac97_query_devinfo(struct ac97_codec_if *self, mixer_devinfo_t *);
int ac97_get_portnum_by_name(struct ac97_codec_if *, char *, char *,
d295 1
a295 1
void ac97_restore_shadow(struct ac97_codec_if *self);
d297 5
a301 5
void ac97_ad1886_init(struct ac97_softc *);
void ac97_ad198x_init(struct ac97_softc *);
void ac97_alc655_init(struct ac97_softc *);
void ac97_cx20468_init(struct ac97_softc *);
void ac97_cx_init(struct ac97_softc *);
d532 5
a536 5
int ac97_str_equal(const char *, const char *);
void ac97_setup_source_info(struct ac97_softc *);
void ac97_setup_defaults(struct ac97_softc *);
int ac97_read(struct ac97_softc *, u_int8_t, u_int16_t *);
int ac97_write(struct ac97_softc *, u_int8_t, u_int16_t);
d554 1
a554 4
ac97_read(as, reg, val)
	struct ac97_softc *as;
	u_int8_t	reg;
	u_int16_t	*val;
d572 1
a572 4
ac97_write(as, reg, val)
	struct ac97_softc *as;
	u_int8_t	reg;
	u_int16_t	val;
d579 1
a579 2
ac97_setup_defaults(as)
	struct ac97_softc *as;
d593 1
a593 2
ac97_restore_shadow(self)
	struct ac97_codec_if *self;
d606 1
a606 2
ac97_str_equal(a, b)
	const char *a, *b;
d612 1
a612 2
ac97_setup_source_info(as)
	struct ac97_softc *as;
d702 1
a702 2
ac97_attach(host_if)
	struct ac97_host_if *host_if;
d828 1
a828 3
ac97_query_devinfo(codec_if, dip)
	struct ac97_codec_if *codec_if;
	mixer_devinfo_t *dip;
d864 1
a864 3
ac97_mixer_set_port(codec_if, cp)
	struct ac97_codec_if *codec_if;
	mixer_ctrl_t *cp;
d949 2
a950 3
ac97_get_portnum_by_name(codec_if, class, device, qualifier)
	struct ac97_codec_if *codec_if;
	char *class, *device, *qualifier;
d967 1
a967 3
ac97_mixer_get_port(codec_if, cp)
	struct ac97_codec_if *codec_if;
	mixer_ctrl_t *cp;
d1040 2
a1041 4
ac97_set_rate(codec_if, p, mode)
	struct ac97_codec_if *codec_if;
	struct audio_params *p;
	int mode;
@


1.55
log
@correct names for miscellaneous control bit register
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.54 2005/06/06 21:08:14 mjc Exp $	*/
d808 4
a834 4
	/* use initfunc for specific device */
	if (initfunc != NULL)
		initfunc(as);

d907 6
d1125 1
d1131 12
@


1.54
log
@AD1981 is actually AD1980
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.53 2005/05/25 17:59:23 joris Exp $	*/
d1123 1
a1123 1
	    misc|AC97_AD_MISC_DAM|AC97_AD_MISC_MADPD);
@


1.53
log
@

correctly initialize AD1886.

"go ahead" mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.52 2005/02/16 22:26:39 todd Exp $	*/
d326 1
a326 1
	{ 0x70, 0xff, 0, 0,	"AD1981" },
@


1.52
log
@add support for enabling amp power on a non-documented Conexant codec
ideas from alsa

pointers by jsg@@; mickey@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.51 2005/01/31 15:48:19 mickey Exp $	*/
d297 1
d323 1
a323 1
	{ 0x61, 0xff, 0, 0,	"AD1886" },
d1108 8
@


1.51
log
@add a bunch of more codecs from var srcs. this makes almost everything from the dmesglog to be resolved proper. most unresolvants are bit-errors on the ac link anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.50 2005/01/30 21:43:02 kettenis Exp $	*/
d300 1
d375 1
d1138 16
@


1.50
log
@Fix two Cirrus Logic codec IDs.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.49 2005/01/17 05:42:41 jaredy Exp $	*/
d344 1
d374 2
d386 1
d389 3
d395 6
d405 1
a405 2
	{ 0x22,	0xff, 0, 0,	"Si3036" },
	{ 0x23,	0xff, 0, 0,	"Si3038" },
d416 3
d438 2
d442 1
d461 1
d466 1
@


1.49
log
@update dead URL, from Steve Shockley <steve.shockley@@shockley.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.48 2004/11/22 23:06:50 mickey Exp $	*/
d366 2
a367 2
	{ 0x40,	0xf8, 7, 0,	"CS4201" },
	{ 0x50,	0xf8, 7, 0,	"CS4205" },
@


1.48
log
@ad1981 does not like init; from fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.47 2004/11/18 16:24:30 mickey Exp $	*/
d276 1
a276 1
 * Check out http://www.intel.com/labs/media/audio/index.htm
@


1.47
log
@a few more codecs from nbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.46 2004/10/14 16:02:45 mickey Exp $	*/
d324 1
a324 1
	{ 0x70, 0xff, 0, 0,	"AD1981",	ac97_ad198x_init },
@


1.46
log
@a few more c-media codec ids
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.45 2004/10/04 20:03:04 mickey Exp $	*/
d322 3
a324 1
	{ 0x70, 0xff, 0, 0,	"AD1981" },
d332 1
d347 1
d369 1
d401 1
d422 1
d424 2
a425 1
	{ 0x00, 0xff, 0, 0,	"YMF743" },
@


1.45
log
@a whole bunch of avance logic codecs and also patch for some
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.44 2004/09/14 22:06:49 mickey Exp $	*/
d351 3
@


1.44
log
@two more icensemble codecs. now they are via really...
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.43 2004/04/23 09:31:47 mickey Exp $	*/
d298 1
d335 9
d1077 1
a1077 1
	unsigned short misc;
d1085 13
d1100 1
a1100 1
	unsigned short misc;
@


1.43
log
@kill evil spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.42 2004/04/23 09:26:15 mickey Exp $	*/
d365 2
@


1.42
log
@properly id CX20468 and patch it too, also one more _cx codec; made possible by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.41 2004/02/27 17:37:56 deraadt Exp $	*/
d728 1
a728 2
					printf(" rev %d",
					    id & codec->rev);
d965 1
a965 1
		if (value->num_channels == 1) 
d1061 1
a1061 1
  	 
d1065 1
a1065 1
        unsigned short misc;
d1067 2
a1068 2
        ac97_read(as, AC97_AD_REG_MISC, &misc);
        ac97_write(as, AC97_AD_REG_MISC,
d1075 1
a1075 1
        unsigned short misc;
d1077 2
a1078 2
        ac97_read(as, AC97_CX_REG_MISC, &misc);
        ac97_write(as, AC97_CX_REG_MISC,
@


1.41
log
@change url; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.40 2003/11/05 14:40:26 mickey Exp $	*/
d297 2
a298 1
static void ac97_ad198x_init(struct ac97_softc *);
d353 2
a354 1
	{ 0x29, 0xff, 0, 0,	"CX20468" },
d1063 1
a1063 1
static void
d1071 10
@


1.40
log
@another ad codec
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.39 2003/09/25 21:49:06 mickey Exp $	*/
d276 2
a277 2
 * Check out http://developer.intel.com/pc-supp/platform/ac97/ for
 * information on AC-97
@


1.39
log
@more codec
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.38 2003/07/23 20:53:52 deraadt Exp $	*/
d322 1
@


1.38
log
@VT1612A; matthew.gream@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.37 2003/07/15 13:20:31 couderc Exp $	*/
d336 5
d350 5
d365 3
d409 1
d411 2
a412 1
	{ 0x414B4D00, "Asahi Kasei",		cl(ac97_ak) },
d414 1
a414 2
	{ 0x414c4300, "Realtek",		cl(ac97_rl) },
	{ 0x56494100, "VIA Technologies",	cl(ac97_vi) },
d416 2
d422 1
d426 1
@


1.37
log
@Add support for AD1985, deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.36 2003/04/27 11:22:52 ho Exp $	*/
d369 2
d400 1
@


1.36
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.35 2003/04/09 20:05:47 mickey Exp $	*/
d297 2
d313 1
d322 1
d650 3
d698 1
a698 1
				if (codec >= vendor->codecs && codec->mask)
d700 2
a701 1
				else
d762 4
d1033 14
@


1.35
log
@a couple of sigmatel codec ids
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.34 2003/04/07 21:01:14 mickey Exp $	*/
d781 1
a781 1
			strcpy(dip->label.name, name);
@


1.34
log
@a couple more codec ids from people
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.33 2002/09/17 19:12:17 mickey Exp $	*/
d361 1
d363 1
@


1.33
log
@add ad1981a id; from hunter@@dg.net.ua
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.32 2002/09/05 17:03:33 fgsch Exp $	*/
d317 1
d327 1
@


1.32
log
@Use the value from AUDIO_CTRL, later to be or'ed with VRM or VRA, not
AUDIO_ID which contains what the codec supports, and do it only if the
codec supports VRM or VRA.
discussed with mickey@@ a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.30 2002/04/08 01:43:13 frantzen Exp $	*/
d317 1
@


1.31
log
@minor things from ac97 rev 2.3; mickey@@ ok
@
text
@d715 8
a722 6
	ac97_read(as, AC97_REG_EXT_AUDIO_ID, &id1);
	if (as->ext_id & AC97_EXT_AUDIO_VRA)
		id1 |= AC97_EXT_AUDIO_VRA;
	if (as->ext_id & AC97_EXT_AUDIO_VRM)
		id1 |= AC97_EXT_AUDIO_VRM;
	ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, id1);
@


1.30
log
@add flag to swap channels.  from netbsd.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.29 2002/03/14 01:26:53 millert Exp $	*/
d432 1
a432 1
	"Unknown 3D",
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.28 2002/01/09 19:27:27 mickey Exp $	*/
d832 7
a838 2
			l = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			r = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
d923 11
a933 3
		l = r = (val >> si->ofs) & mask;
		if (value->num_channels > 1) 
			r = (val >> (si->ofs + 8)) & mask;
@


1.28
log
@add ess1921 codec id
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.27 2001/12/17 16:22:58 mickey Exp $	*/
d290 6
a295 6
int ac97_mixer_get_port __P((struct ac97_codec_if *self, mixer_ctrl_t *cp));
int ac97_mixer_set_port __P((struct ac97_codec_if *self, mixer_ctrl_t *));
int ac97_query_devinfo __P((struct ac97_codec_if *self, mixer_devinfo_t *));
int ac97_get_portnum_by_name __P((struct ac97_codec_if *, char *, char *,
				  char *));
void ac97_restore_shadow __P((struct ac97_codec_if *self));
d453 5
a457 5
int ac97_str_equal __P((const char *, const char *));
void ac97_setup_source_info __P((struct ac97_softc *));
void ac97_setup_defaults __P((struct ac97_softc *));
int ac97_read __P((struct ac97_softc *, u_int8_t, u_int16_t *));
int ac97_write __P((struct ac97_softc *, u_int8_t, u_int16_t));
@


1.27
log
@be more accurate in enabling variable rate bits
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.26 2001/12/01 16:29:54 mickey Exp $	*/
d338 2
d390 1
@


1.27.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.28 2002/01/09 19:27:27 mickey Exp $	*/
a337 2
}, ac97_es[] = {
	{ 0x08, 0xff, 0, 0,	"ES1921" },
a387 1
	{ 0x45838300, "ESS Technology",		cl(ac97_es) },
@


1.27.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.27.2.1 2002/01/31 22:55:30 niklas Exp $	*/
d290 6
a295 6
int ac97_mixer_get_port(struct ac97_codec_if *self, mixer_ctrl_t *cp);
int ac97_mixer_set_port(struct ac97_codec_if *self, mixer_ctrl_t *);
int ac97_query_devinfo(struct ac97_codec_if *self, mixer_devinfo_t *);
int ac97_get_portnum_by_name(struct ac97_codec_if *, char *, char *,
				  char *);
void ac97_restore_shadow(struct ac97_codec_if *self);
d453 5
a457 5
int ac97_str_equal(const char *, const char *);
void ac97_setup_source_info(struct ac97_softc *);
void ac97_setup_defaults(struct ac97_softc *);
int ac97_read(struct ac97_softc *, u_int8_t, u_int16_t *);
int ac97_write(struct ac97_softc *, u_int8_t, u_int16_t);
d832 2
a833 7
			if (!(as->host_flags & AC97_HOST_SWAPPED_CHANNELS)) {
				l = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
				r = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
			} else {
				r = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
				l = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
			}
d918 3
a920 11
		if (value->num_channels == 1) 
			l = r = (val >> si->ofs) & mask;
		else {
			if (!(as->host_flags & AC97_HOST_SWAPPED_CHANNELS)) {
				l = (val >> si->ofs) & mask;
				r = (val >> (si->ofs + 8)) & mask;
			} else {
				r = (val >> si->ofs) & mask;
				l = (val >> (si->ofs + 8)) & mask;
			}
		}
@


1.27.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.27.2.2 2002/06/11 03:42:16 art Exp $	*/
a316 1
	{ 0x72, 0xff, 0, 0,	"AD1981A" },
d432 1
a432 1
	"KS Waves 3D",
d715 6
a720 8
	if (as->ext_id & (AC97_EXT_AUDIO_VRA | AC97_EXT_AUDIO_VRM)) {
		ac97_read(as, AC97_REG_EXT_AUDIO_CTRL, &id1);
		if (as->ext_id & AC97_EXT_AUDIO_VRA)
			id1 |= AC97_EXT_AUDIO_VRA;
		if (as->ext_id & AC97_EXT_AUDIO_VRM)
			id1 |= AC97_EXT_AUDIO_VRM;
		ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, id1);
	}
@


1.27.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a316 1
	{ 0x70, 0xff, 0, 0,	"AD1981" },
a325 1
	{ 0x20, 0xff, 0, 0,	"ALC650" },
a358 1
	{ 0x52,	0xff, 0, 0,	"STAC9752/53" },
a359 1
	{ 0x66,	0xff, 0, 0,	"STAC9766/67" },
d777 1
a777 1
			strlcpy(dip->label.name, name, sizeof dip->label.name);
@


1.26
log
@fix realtek codec ids. fxi codec id decode -- from krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.25 2001/10/28 18:58:12 mickey Exp $	*/
d712 1
d714 4
a717 2
		ac97_write(as, AC97_REG_EXT_AUDIO_CTRL,
		    AC97_EXT_AUDIO_VRA | AC97_EXT_AUDIO_VRM);
@


1.25
log
@it appears that some non-vra compatible codecs implement part
of vra protocol by rounding all rates to 48kHz, but some
return 0. fix this by reporting 48kHz for all codecs w/o vra.
problem (finally) identified by hunter@@dg.net.ua, diff by me.
also, while here a/AC97_SOUND_ENHANCEMENT/AC97_CAPS_ENHANCEMENT/ .
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.24 2001/10/24 16:30:05 mickey Exp $	*/
d326 3
a328 3
	{ 0x00, 0xff, 0, 0,	"RL5306" },
	{ 0x10, 0xff, 0, 0,	"RL5382" },
	{ 0x20, 0xff, 0, 0,	"RL5383" },
d683 1
a683 1
				if (codec->mask)
d687 3
a689 2
				if (codec->rev)
					printf(" rev %d", id & codec->rev);
@


1.24
log
@replace strings w/ defined names, missing initializer for pcbeep and split tone into bass/treble
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.23 2001/10/24 03:52:40 mickey Exp $	*/
d286 1
d634 1
a634 1
	u_int16_t id1, id2, caps;
d665 1
a665 1
	ac97_read(as, AC97_REG_RESET, &caps);
d697 1
a697 1
	if (caps) {
d700 1
a700 1
			if (caps & (1 << i))
d703 2
a704 1
		printf("%s\n", ac97enhancement[AC97_SOUND_ENHANCEMENT(caps)]);
d707 5
a711 4
	ac97_read(as, AC97_REG_EXT_AUDIO_ID, &caps);
	if (caps)
		DPRINTF(("ac97: ext id %b\n", caps, AC97_EXT_AUDIO_BITS));
	if (caps & AC97_EXT_AUDIO_VRA)
d954 5
d962 1
a962 3
		if (ac97_read(as, AC97_REG_EXT_AUDIO_ID, &id))
			return (EIO);
		if (!(id & AC97_EXT_AUDIO_DRA))
@


1.23
log
@add several more codecs, from elsa
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.22 2001/09/15 17:27:12 mickey Exp $	*/
d166 6
a171 3
		/* Tone */
		AudioCoutputs,	"tone",		NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
d177 1
a177 1
		AC97_REG_PCBEEP_VOLUME, 4, 1, 1, 0x0000
d246 1
a246 1
		AudioCoutputs,	AudioNspatial,	"center", AUDIO_MIXER_VALUE,
d250 1
a250 1
		AudioCoutputs,	AudioNspatial,	"depth", AUDIO_MIXER_VALUE,
d255 1
a255 1
		AudioCoutputs,	"surround",	NULL,	AUDIO_MIXER_VALUE,
d260 1
a260 1
		AudioCoutputs,	"center",	NULL,	AUDIO_MIXER_VALUE,
d265 1
a265 1
		AudioCoutputs,	"lfe",		NULL,	AUDIO_MIXER_VALUE,
@


1.22
log
@fix unknown codec id printout
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.21 2001/06/20 18:08:53 deraadt Exp $	*/
d308 1
d310 1
d312 1
d317 2
d321 4
d331 8
d340 1
d349 1
a349 1
	{ 0x08,	0xff, 0, 0,	"STAC9708" },
d357 1
d359 5
a363 1
	{ 0x23,	0xff, 0, 0,	"unknown" },
d366 1
a366 1
	{ 0x03,	0xff, 0, 0,	"WM9704M/Q-0" },	/* also WM9703 */
d368 2
d381 2
a382 1
	{ 0x414c4700, "Avance",			cl(ac97_av) },
d384 2
d389 2
d392 1
@


1.21
log
@fix array filling; alaric@@MIT.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.20 2001/06/17 21:06:13 mickey Exp $	*/
a323 1
	{ 0x00, 0x00 }
d364 1
d651 1
a651 1
					printf(" <%2x>", id & codec->mask);
@


1.20
log
@Set the delta for the particular source so telling mixerctl to decrease the
volume (using --) adjusts it far enough to stick.
from Eric Haszlakiewicz <erh@@netbsd.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.19 2001/05/16 23:34:53 mickey Exp $	*/
d369 1
a369 1
	"Creative"
d373 1
a373 1
	"Crystal Semi 3D"
d398 1
a398 1
	"Unknown 3D",
@


1.19
log
@add surrond, center and lfe ports (per 2.2 spec).
provide set_rate function, per 2.2 spec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.18 2001/05/16 19:14:03 mickey Exp $	*/
d103 5
d733 5
@


1.18
log
@call malloc w/ NOWAIT and check for NULL return
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.17 2001/05/16 12:51:48 ho Exp $	*/
d245 16
a260 1
	},
a411 1
void ac97_read __P((struct ac97_softc *, u_int8_t, u_int16_t *));
d413 1
d431 1
a431 2

void
d444 1
a444 1
		return;
d449 1
a449 1
	return;
d666 7
a700 1

d892 50
@


1.17
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.16 2001/05/16 08:19:21 deraadt Exp $	*/
d585 3
a587 1
	as = malloc(sizeof(struct ac97_softc), M_DEVBUF, M_WAITOK);
@


1.16
log
@shorten by one byte :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.15 2001/05/16 05:32:42 mickey Exp $	*/
a585 3
	if (!as)
		return (ENOMEM);

@


1.15
log
@split codec vendor/product into separate tables,
provide meaning for codec revision.
some other size improvelances.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.14 2001/05/15 22:43:20 deraadt Exp $	*/
d286 1
a286 1
	char *const name;
d332 1
a332 1
	const struct ac97_codecid *const codecs;
d366 1
a366 1
	"Texas Instruments' 3D",
@


1.14
log
@partial KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.13 2001/05/15 22:19:12 mickey Exp $	*/
d73 1
a73 1
static const struct audio_mixer_enum ac97_on_off = {
d79 1
a79 1
static const struct audio_mixer_enum ac97_mic_select = {
d85 1
a85 1
static const struct audio_mixer_enum ac97_mono_select = {
d91 1
a91 1
static const struct audio_mixer_enum ac97_source = {
d103 1
a103 1
static const struct audio_mixer_value ac97_volume_stereo = {
d108 1
a108 1
static const struct audio_mixer_value ac97_volume_mono = {
d116 3
a118 3
	const char *class;
	const char *device;
	const char *qualifier;
d122 1
a122 1
	int  info_size;
a124 1
	u_int16_t default_value;
d129 1
d131 3
a133 3
	int  prev;
	int  next;
	int  mixer_class;
d145 1
a145 1
		AC97_REG_MASTER_VOLUME, 0x8000, 5, 0, 1,
d150 1
a150 1
		AC97_REG_MASTER_VOLUME_MONO, 0x8000, 6, 0, 1,
d154 1
a154 1
		AC97_REG_GP, 0x0000, 1, 9, 0,
d159 1
a159 1
		AC97_REG_HEADPHONE_VOLUME, 0x8000, 6, 0, 1,
d164 1
a164 1
		AC97_REG_MASTER_TONE, 0x0f0f, 4, 0, 0,
d169 1
a169 1
		AC97_REG_PCBEEP_VOLUME, 0x0000, 4, 1, 1,
d174 1
a174 1
		AC97_REG_PHONE_VOLUME, 0x8008, 5, 0, 1,
d179 1
a179 1
		AC97_REG_MIC_VOLUME, 0x8008, 5, 0, 1,
d183 1
a183 1
		AC97_REG_MIC_VOLUME, 0x8008, 1, 6, 0,
d187 1
a187 1
		AC97_REG_GP, 0x0000, 1, 8, 0,
d192 1
a192 1
		AC97_REG_LINEIN_VOLUME, 0x8808, 5, 0, 1,
d197 1
a197 1
		AC97_REG_CD_VOLUME, 0x8808, 5, 0, 1,
d202 1
a202 1
		AC97_REG_VIDEO_VOLUME, 0x8808, 5, 0, 1,
d207 1
a207 1
		AC97_REG_AUX_VOLUME, 0x8808, 5, 0, 1,
d212 1
a212 1
		AC97_REG_PCMOUT_VOLUME, 0x8808, 5, 0, 1,
d217 1
a217 1
		AC97_REG_RECORD_SELECT, 0x0000, 3, 0, 0,
d222 1
a222 1
		AC97_REG_RECORD_GAIN, 0x8000, 4, 0, 1,
d227 1
a227 1
		AC97_REG_RECORD_GAIN_MIC, 0x8000, 4, 0, 1, 1,
d232 1
a232 1
		AC97_REG_GP, 0x0000, 1, 12, 0,
d236 1
a236 1
		AC97_REG_GP, 0x0000, 1, 13, 0,
d240 1
a240 1
		AC97_REG_3D_CONTROL, 0x0000, 4, 8, 0, 1,
d244 1
a244 1
		AC97_REG_3D_CONTROL, 0x0000, 4, 0, 0, 1,
d281 49
a329 1
static const struct ac97_codecid {
d332 12
a343 33
} ac97codecid[] = {
	{ 0x41445340,	"Analog Devices AD1881"		},
	{ 0x41445360,	"Analog Devices AD1885"		},
	{ 0x414B4D00,	"Asahi Kasei AK4540 rev 0"	},
	{ 0x414B4D01,	"Asahi Kasei AK4540 rev 1"	},
	{ 0x414B4D02,	"Asahi Kasei AK4543"		},
	{ 0x414c4710,	"Avance ALC200"			},
	{ 0x43525900,	"Cirrus Logic CS4297"		},
	{ 0x43525903,	"Cirrus Logic CS4297"		},
	{ 0x43525913,	"Cirrus Logic CS4297A"		},
	{ 0x43525914,	"Cirrus Logic CS4297A?"		},
	{ 0x43525923,	"Cirrus Logic CS4298"		},
	{ 0x4352592b,	"Cirrus Logic CS4294"		},
	{ 0x43525931,	"Cirrus Logic CS4299"		},
	{ 0x43525933,	"Cirrus Logic CS4298A?"		},
	{ 0x43525934,	"Cirrus Logic CS4299"		},
	{ 0x4e534331,	"National Semiconductor LM4549"	},
	{ 0x53494c22,	"Silicon Laboratory Si3036"	},
	{ 0x53494c23,	"Silicon Laboratory Si3038"	},
	{ 0x54524102,	"TriTech TR28022"		},
	{ 0x54524103,	"TriTech TR28023"		},
	{ 0x54524108,	"TriTech TR28028"		},
	{ 0x54524123,	"TriTech unknown"		},
	{ 0x574d4c00,	"Wolfson WM9704"		},
	{ 0x574d4c03,	"Wolfson WM9707"		},
	{ 0x83847600,	"SigmaTel STAC9700"		},
	{ 0x83847604,	"SigmaTel STAC9701/3/4/5"	},
	{ 0x83847605,	"SigmaTel STAC9704"		},
	{ 0x83847608,	"SigmaTel STAC9708"		},
	{ 0x83847609,	"SigmaTel STAC9721/23"		},
	{ 0x83847644,	"SigmaTel STAC9744/45"		},
	{ 0x83847684,	"SigmaTel STAC9783/84?"		},
	{ 0,		NULL				}
d346 1
a346 1
static const char * const ac97enhancement[] = {
d381 1
a381 1
static const char * const ac97feature[] = {
a451 1
	const struct ac97_source_info *si;
d457 2
a458 1
		si = &source_info[idx];
a467 1
	const struct ac97_source_info *si;
d471 1
a471 1
		si = &source_info[idx];
d488 1
a489 1
	struct ac97_source_info *si, *si2;
d549 1
a549 4
		if (si->prev != 0)
			continue;

		if (si->qualifier)
a579 1
	int error, i, j;
d583 1
d586 2
d589 1
a589 3
	if (!as) return (ENOMEM);

	bzero (as, sizeof(*as));
d595 1
a595 1
		free (as, M_DEVBUF);
d615 3
a618 1
	if (id) {
d620 18
a637 9
		for (i = 0; ac97codecid[i].id; i++) {
			if (ac97codecid[i].id == id)
				printf(" (%s)", ac97codecid[i].name);
		}
		printf("\nac97: codec features ");
		for (i = j = 0; i < 10; i++) {
			if (caps & (1 << i)) {
				printf("%s%s", j? ", " : "", ac97feature[i]);
				j++;
d640 1
a640 2
		printf("%s%s\n", j? ", " : "",
		    ac97enhancement[(caps >> 10) & 0x1f]);
d644 9
d663 1
d666 1
a667 1
	ac97_mixer_set_port(&as->codec_if, &ctl);
d672 2
a673 1

a675 2
	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;
a714 2


d726 2
a727 4
	if (cp->dev < 0 || cp->dev >= as->num_source_info)
		return (EINVAL);

	if (cp->type != si->type)
d768 2
a769 2
		l = l >> (8 - si->bits);
		r = r >> (8 - si->bits);
d820 2
a821 4
	if (cp->dev < 0 || cp->dev >= as->num_source_info)
		return (EINVAL);

	if (cp->type != si->type)
d845 2
a846 4
		if (value->num_channels == 1) {
			l = r = (val >> si->ofs) & mask;
		} else {
			l = (val >> si->ofs) & mask;
a847 1
		}
d849 2
a850 2
		l = (l << (8 - si->bits));
		r = (r << (8 - si->bits));
a875 1

@


1.13
log
@a few more codecs, a few more consts, trailing spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.12 2001/04/15 18:25:48 deraadt Exp $	*/
d73 11
a83 26
static const struct audio_mixer_enum ac97_on_off = { 2,
					       { { { AudioNoff } , 0 },
					         { { AudioNon }  , 1 } }};


static const struct audio_mixer_enum ac97_mic_select = { 2,
					       { { { AudioNmicrophone "0" },
						   0 },
					         { { AudioNmicrophone "1" },
						   1 } }};

static const struct audio_mixer_enum ac97_mono_select = { 2,
					       { { { AudioNmixerout },
						   0 },
					         { { AudioNmicrophone },
						   1 } }};

static const struct audio_mixer_enum ac97_source = { 8,
					       { { { AudioNmicrophone } , 0 },
						 { { AudioNcd }, 1 },
						 { { "video" }, 2 },
						 { { AudioNaux }, 3 },
						 { { AudioNline }, 4 },
						 { { AudioNmixerout }, 5 },
						 { { AudioNmixerout AudioNmono }, 6 },
						 { { "phone" }, 7 }}};
d85 17
a101 2
static const struct audio_mixer_value ac97_volume_stereo = { { AudioNvolume },
						       2 };
d103 4
d108 4
a111 2
static const struct audio_mixer_value ac97_volume_mono = { { AudioNvolume },
						     1 };
d129 1
a129 1
	u_int8_t  polarity:1;   /* Does 0 == MAX or MIN */
d135 110
a244 109
	{ AudioCinputs ,	NULL,		NULL,    AUDIO_MIXER_CLASS,
	},
	{ AudioCoutputs,	NULL,		NULL,    AUDIO_MIXER_CLASS,
	},
	{ AudioCrecord ,	NULL,		NULL,    AUDIO_MIXER_CLASS,
	},
	/* Stereo master volume*/
	{ AudioCoutputs,     AudioNmaster,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo),
	  AC97_REG_MASTER_VOLUME, 0x8000, 5, 0, 1,
	},
	/* Mono volume */
	{ AudioCoutputs,       AudioNmono,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono),
	  AC97_REG_MASTER_VOLUME_MONO, 0x8000, 6, 0, 1,
	},
	{ AudioCoutputs,       AudioNmono,AudioNsource,   AUDIO_MIXER_ENUM,
	  WRAP(ac97_mono_select),
	  AC97_REG_GP, 0x0000, 1, 9, 0,
	},
	/* Headphone volume */
	{ AudioCoutputs,  AudioNheadphone,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo),
	  AC97_REG_HEADPHONE_VOLUME, 0x8000, 6, 0, 1,
	},
	/* Tone */
	{ AudioCoutputs,           "tone",	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo),
	  AC97_REG_MASTER_TONE, 0x0f0f, 4, 0, 0,
	},
	/* PC Beep Volume */
	{ AudioCinputs,     AudioNspeaker,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono),
	  AC97_REG_PCBEEP_VOLUME, 0x0000, 4, 1, 1,
	},
	/* Phone */
	{ AudioCinputs,           "phone",	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono),
	  AC97_REG_PHONE_VOLUME, 0x8008, 5, 0, 1,
	},
	/* Mic Volume */
	{ AudioCinputs,  AudioNmicrophone,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono),
	  AC97_REG_MIC_VOLUME, 0x8008, 5, 0, 1,
	},
	{ AudioCinputs,  AudioNmicrophone, AudioNpreamp,   AUDIO_MIXER_ENUM,
	  WRAP(ac97_on_off),
	  AC97_REG_MIC_VOLUME, 0x8008, 1, 6, 0,
	},
	{ AudioCinputs,  AudioNmicrophone, AudioNsource,   AUDIO_MIXER_ENUM,
	  WRAP(ac97_mic_select),
	  AC97_REG_GP, 0x0000, 1, 8, 0,
	},
	/* Line in Volume */
	{ AudioCinputs,        AudioNline,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo),
	  AC97_REG_LINEIN_VOLUME, 0x8808, 5, 0, 1,
	},
	/* CD Volume */
	{ AudioCinputs,          AudioNcd,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo),
	  AC97_REG_CD_VOLUME, 0x8808, 5, 0, 1,
	},
	/* Video Volume */
	{ AudioCinputs,           "video",	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo),
	  AC97_REG_VIDEO_VOLUME, 0x8808, 5, 0, 1,
	},
	/* AUX volume */
	{ AudioCinputs,         AudioNaux,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo),
	  AC97_REG_AUX_VOLUME, 0x8808, 5, 0, 1,
	},
	/* PCM out volume */
	{ AudioCinputs,         AudioNdac,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo),
	  AC97_REG_PCMOUT_VOLUME, 0x8808, 5, 0, 1,
	},
	/* Record Source - some logic for this is hard coded - see below */
	{ AudioCrecord,      AudioNsource,	NULL,    AUDIO_MIXER_ENUM,
	  WRAP(ac97_source),
	  AC97_REG_RECORD_SELECT, 0x0000, 3, 0, 0,
	},
	/* Record Gain */
	{ AudioCrecord,      AudioNvolume,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo),
	  AC97_REG_RECORD_GAIN, 0x8000, 4, 0, 1,
	},
	/* Record Gain mic */
	{ AudioCrecord,  AudioNmicrophone,	NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono),
	  AC97_REG_RECORD_GAIN_MIC, 0x8000, 4, 0, 1, 1,
	},
	/* */
	{ AudioCoutputs,   AudioNloudness,	NULL,    AUDIO_MIXER_ENUM,
	  WRAP(ac97_on_off),
	  AC97_REG_GP, 0x0000, 1, 12, 0,
	},
	{ AudioCoutputs,    AudioNspatial,	NULL,    AUDIO_MIXER_ENUM,
	  WRAP(ac97_on_off),
	  AC97_REG_GP, 0x0000, 1, 13, 0,
	},
	{ AudioCoutputs,    AudioNspatial,	"center",    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono),
	  AC97_REG_3D_CONTROL, 0x0000, 4, 8, 0, 1,
	},
	{ AudioCoutputs,    AudioNspatial,	"depth",    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono),
	  AC97_REG_3D_CONTROL, 0x0000, 4, 0, 0, 1,
a258 1

a259 1

a261 1

a262 1

d393 2
a394 2
	u_int8_t   reg;
	u_int16_t *val;
d406 1
a406 1
	if ((error = as->host_if->read(as->host_if->arg, reg, val))) {
a407 1
	}
d414 2
a415 2
	u_int8_t   reg;
	u_int16_t  val;
a417 1

d425 1
a426 1
	const struct ac97_source_info *si;
a431 1

d441 1
a442 1
	const struct ac97_source_info *si;
d516 1
a516 2
			    ac97_str_equal(si->class,
					   si2->class)) {
d619 1
a619 1
					   AudioNmaster, AudioNmute);
d622 1
a622 1
					   AudioNdac, AudioNmute);
d626 1
a626 1
					   AudioNvolume, AudioNmute);
d631 1
a631 1
					   AudioNsource, NULL);
d714 2
a715 2
		if ((cp->un.value.num_channels <= 0) ||
		    (cp->un.value.num_channels > value->num_channels))
d797 2
a798 1
		DPRINTFN(4, ("AUDIO_MIXER_ENUM: %x %d %x %d\n", val, si->ofs, mask, cp->un.ord));
d823 5
a827 3
		/* The EAP driver averages l and r for stereo
		   channels that are requested in MONO mode. Does this
		   make sense? */
@


1.12
log
@another
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.11 2001/03/03 21:28:27 deraadt Exp $ */
d6 1
a6 1
 * Author:        Constantine Sapuntzakis <csapuntz@@stanford.edu>
d73 1
a73 1
static struct audio_mixer_enum ac97_on_off = { 2,
d78 2
a79 2
static struct audio_mixer_enum ac97_mic_select = { 2,
					       { { { AudioNmicrophone "0" }, 
d81 1
a81 1
					         { { AudioNmicrophone "1" }, 
d84 1
a84 1
static struct audio_mixer_enum ac97_mono_select = { 2,
d87 1
a87 1
					         { { AudioNmicrophone }, 
d90 1
a90 1
static struct audio_mixer_enum ac97_source = { 8,
d100 1
a100 1
static struct audio_mixer_value ac97_volume_stereo = { { AudioNvolume }, 
d104 1
a104 1
static struct audio_mixer_value ac97_volume_mono = { { AudioNvolume }, 
d109 4
a112 4
struct ac97_source_info {
	char *class;
	char *device;
	char *qualifier;
d115 1
a115 1
	void *info;
d126 1
a126 1
	int  next;	
d129 1
a129 1
	{ AudioCinputs ,            NULL,           NULL,    AUDIO_MIXER_CLASS,
d131 1
a131 1
	{ AudioCoutputs,            NULL,           NULL,    AUDIO_MIXER_CLASS,
d133 1
a133 1
	{ AudioCrecord ,            NULL,           NULL,    AUDIO_MIXER_CLASS,
d136 2
a137 2
	{ AudioCoutputs,     AudioNmaster,        NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_stereo), 
d141 1
a141 1
	{ AudioCoutputs,       AudioNmono,        NULL,    AUDIO_MIXER_VALUE,
d150 1
a150 1
	{ AudioCoutputs,  AudioNheadphone,        NULL,    AUDIO_MIXER_VALUE,
d155 1
a155 1
	{ AudioCoutputs,           "tone",        NULL,    AUDIO_MIXER_VALUE,
d160 2
a161 2
	{ AudioCinputs,     AudioNspeaker,        NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono), 
d165 2
a166 2
	{ AudioCinputs,           "phone",        NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono), 
d170 2
a171 2
	{ AudioCinputs,  AudioNmicrophone,        NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono), 
d183 1
a183 1
	{ AudioCinputs,        AudioNline,        NULL,    AUDIO_MIXER_VALUE,
d188 1
a188 1
	{ AudioCinputs,          AudioNcd,        NULL,    AUDIO_MIXER_VALUE,
d193 1
a193 1
	{ AudioCinputs,           "video",        NULL,    AUDIO_MIXER_VALUE,
d198 1
a198 1
	{ AudioCinputs,         AudioNaux,        NULL,    AUDIO_MIXER_VALUE,
d203 1
a203 1
	{ AudioCinputs,         AudioNdac,        NULL,    AUDIO_MIXER_VALUE,
d208 1
a208 1
	{ AudioCrecord,      AudioNsource,        NULL,    AUDIO_MIXER_ENUM,
d213 1
a213 1
	{ AudioCrecord,      AudioNvolume,        NULL,    AUDIO_MIXER_VALUE,
d218 2
a219 2
	{ AudioCrecord,  AudioNmicrophone,        NULL,    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono), 
d223 1
a223 1
	{ AudioCoutputs,   AudioNloudness,        NULL,    AUDIO_MIXER_ENUM,
d227 1
a227 1
	{ AudioCoutputs,    AudioNspatial,        NULL,    AUDIO_MIXER_ENUM,
d231 2
a232 2
	{ AudioCoutputs,    AudioNspatial,    "center",    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono), 
d235 2
a236 2
	{ AudioCoutputs,    AudioNspatial,     "depth",    AUDIO_MIXER_VALUE,
	  WRAP(ac97_volume_mono), 
d271 1
a271 1
	ac97_mixer_get_port, 
d278 1
a278 1
static struct ac97_codecid {
d280 1
a280 1
	char *name;
d282 32
a313 28
	{ 0x41445340, "Analog Devices AD1881"		},
	{ 0x414b4d00, "Asahi Kasei AK4540" 		},
	{ 0x414b4d02, "Asahi Kasei AK4543" 		},
	{ 0x414c4710, "Avance ALC200"			},
	{ 0x43525900, "Cirrus Logic CS4297" 		},
	{ 0x43525903, "Cirrus Logic CS4297" 		},
	{ 0x43525913, "Cirrus Logic CS4297A" 		},
	{ 0x43525923, "Cirrus Logic CS4298" 		},
	{ 0x4352592b, "Cirrus Logic CS4294" 		},
	{ 0x43525931, "Cirrus Logic CS4299" 		},
	{ 0x43525933, "Cirrus Logic CS4298A?" 		},
	{ 0x4e534331, "National Semiconductor LM4549"	},
	{ 0x53494c22, "Silicon Laboratory Si3036"	},
	{ 0x53494c23, "Silicon Laboratory Si3038"	},
	{ 0x54524102, "TriTech TR28022"			},
	{ 0x54524103, "TriTech TR28023"			},
	{ 0x54524108, "TriTech TR28028"			},
	{ 0x54524123, "TriTech unknown"			},
	{ 0x574d4c00, "Wolfson WM9704"			},
	{ 0x574d4c03, "Wolfson WM9707"			},
	{ 0x83847600, "SigmaTel STAC9700" 		},
	{ 0x83847604, "SigmaTel STAC9701/3/4/5" 	},
	{ 0x83847605, "SigmaTel STAC9704" 		},
	{ 0x83847608, "SigmaTel STAC9708" 		},
	{ 0x83847609, "SigmaTel STAC9721/23" 		},
	{ 0x83847644, "SigmaTel STAC9744/45"		},
	{ 0x83847684, "SigmaTel STAC9783/84?"		},
	{ 0, 	      NULL				}
d316 1
a316 1
static char *ac97enhancement[] = {
d351 1
a351 1
static char *ac97feature[] = {
d365 1
a365 1
int ac97_str_equal __P((char *, char *));
d394 1
a394 1
	
d402 1
a402 1
	
d425 2
a426 2
	struct ac97_source_info *si; 
	
d431 1
a431 1
		
d442 1
a442 1
	struct ac97_source_info *si; 
d446 1
a446 1
		
d453 1
a453 1
	char *a, *b;
d463 1
a463 1
	struct ac97_source_info *si, *si2; 
d472 1
a472 1
		        si->mixer_class = ouridx;
d515 1
a515 1
			if (si2->type == AUDIO_MIXER_CLASS && 
d544 1
a544 1
				
d553 1
a553 1
int 
d593 1
a593 1
	
d597 1
a597 1
			if (ac97codecid[i].id == id) 
d607 1
a607 1
		printf("%s%s\n", j? ", " : "", 
d624 1
a624 1
	
d629 2
a630 2
		
		
d641 1
a641 1
int 
d650 1
a650 1
		char *name;
d656 1
a656 1
		
d663 1
a663 1
		
d712 1
a712 1
		struct audio_mixer_value *value = si->info;
d716 1
a716 1
		    (cp->un.value.num_channels > value->num_channels)) 
d730 1
a730 1
		
d802 1
a802 1
		struct audio_mixer_value *value = si->info;
d806 1
a806 1
		    (cp->un.value.num_channels > value->num_channels)) 
@


1.11
log
@new AC97_HOST_DONT_READANY flag for ac97 chipsets that are _really_ on drugs
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.10 2000/07/27 16:34:45 deraadt Exp $ */
d282 11
a292 10
	{ 0x41445340, "Analog Devices AD1881"	},
	{ 0x414B4D00, "Asahi Kasei AK4540" 	},
	{ 0x414B4D02, "Asahi Kasei AK4543" 	},
	{ 0x43525900, "Cirrus Logic CS4297" 	},
	{ 0x43525903, "Cirrus Logic CS4297" 	},
	{ 0x43525913, "Cirrus Logic CS4297A" 	},
	{ 0x43525923, "Cirrus Logic CS4298" 	},
	{ 0x4352592b, "Cirrus Logic CS4294" 	},
	{ 0x43525931, "Cirrus Logic CS4299" 	},
	{ 0x43525933, "Cirrus Logic CS4298A?" 	},
d296 14
a309 14
	{ 0x54524102, "TriTech TR28022"		},
	{ 0x54524103, "TriTech TR28023"		},
	{ 0x54524108, "TriTech TR28028"		},
	{ 0x54524123, "TriTech unknown"		},
	{ 0x574d4c00, "Wolfson WM9704"		},
	{ 0x574d4c03, "Wolfson WM9707"		},
	{ 0x83847600, "SigmaTel STAC9700" 	},
	{ 0x83847604, "SigmaTel STAC9701/3/4/5" },
	{ 0x83847605, "SigmaTel STAC9704" 	},
	{ 0x83847608, "SigmaTel STAC9708" 	},
	{ 0x83847609, "SigmaTel STAC9721/23" 	},
	{ 0x83847644, "SigmaTel STAC9744/45"	},
	{ 0x83847684, "SigmaTel STAC9783/84?"	},
	{ 0, 	      NULL			}
@


1.10
log
@if avoiding ac97_read because of AC97_HOST_DONT_READ, still permit access to AC97_REG_VENDOR* and AC97_REG_RESET
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.9 2000/07/20 21:36:26 deraadt Exp $ */
d390 1
a390 1
	if ((as->host_flags & AC97_HOST_DONT_READ) &&
d392 2
a393 1
	    reg != AC97_REG_RESET)) {
d589 12
a600 10
	printf("ac97: codec id 0x%8x", id);
	for (i = 0; ac97codecid[i].id; i++) {
		if (ac97codecid[i].id == id) 
			printf(" (%s)", ac97codecid[i].name);
	}
	printf("\nac97: codec features ");
	for (i = j = 0; i < 10; i++) {
		if (caps & (1 << i)) {
			printf("%s%s", j? ", " : "", ac97feature[i]);
			j++;
d602 4
a605 4
	}
	
	printf("%s%s\n", j? ", " : "", 
	    ac97enhancement[(caps >> 10) & 0x1f]);
@


1.9
log
@more guesses at tritech codecs
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.8 2000/07/19 09:01:35 csapuntz Exp $ */
d390 3
a392 1
	if (as->host_flags & AC97_HOST_DONT_READ) {
@


1.8
log
@

Added shadow registers. This adds two capabilities:

- support devices that crash when reading CODEC registers
        - a flags interface was added to the host interface
          and one flags AC97_HOST_DONT_READ defined.

- new API restore_ports restores the user's settings. This can
  be useful for resume after suspend to disk
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.7 2000/06/27 20:49:30 art Exp $ */
d295 2
d298 1
@


1.7
log
@Move ac97 register defines into ac97.h
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.6 2000/05/30 18:34:14 mickey Exp $ */
d4 1
a4 1
 * Copyright (c) 1999 Constantine Sapuntzakis
d16 15
a30 13
 *
 * THIS SOFTWARE IS PROVIDED BY CONSTANTINE SAPUNTZAKIS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d119 1
d138 1
a138 1
	  AC97_REG_MASTER_VOLUME, 5, 0, 1,
d143 1
a143 1
	  AC97_REG_MASTER_VOLUME_MONO, 6, 0, 1,
d147 1
a147 1
	  AC97_REG_GP, 1, 9, 0,
d152 1
a152 1
	  AC97_REG_HEADPHONE_VOLUME, 6, 0, 1,
d157 1
a157 1
	  AC97_REG_MASTER_TONE, 4, 0, 0,
d162 1
a162 1
	  AC97_REG_PCBEEP_VOLUME, 4, 1, 1,
d167 1
a167 1
	  AC97_REG_PHONE_VOLUME, 5, 0, 1,
d172 1
a172 1
	  AC97_REG_MIC_VOLUME, 5, 0, 1,
d176 1
a176 1
	  AC97_REG_MIC_VOLUME, 1, 6, 0,
d180 1
a180 1
	  AC97_REG_GP, 1, 8, 0,
d185 1
a185 1
	  AC97_REG_LINEIN_VOLUME, 5, 0, 1,
d190 1
a190 1
	  AC97_REG_CD_VOLUME, 5, 0, 1,
d195 1
a195 1
	  AC97_REG_VIDEO_VOLUME, 5, 0, 1,
d200 1
a200 1
	  AC97_REG_AUX_VOLUME, 5, 0, 1,
d205 1
a205 1
	  AC97_REG_PCMOUT_VOLUME, 5, 0, 1,
d210 1
a210 1
	  AC97_REG_RECORD_SELECT, 3, 0, 0,
d215 1
a215 1
	  AC97_REG_RECORD_GAIN, 4, 0, 1,
d220 1
a220 1
	  AC97_REG_RECORD_GAIN_MIC, 4, 0, 1, 1,
d225 1
a225 1
	  AC97_REG_GP, 1, 12, 0,
d229 1
a229 1
	  AC97_REG_GP, 1, 13, 0,
d233 1
a233 1
	  AC97_REG_3D_CONTROL, 4, 8, 0, 1,
d237 1
a237 1
	  AC97_REG_3D_CONTROL, 4, 0, 0, 1,
d251 1
a251 1
	struct ac97_codec_if codecIf;
d253 1
a253 1
	struct ac97_host_if *hostIf;
d257 4
d268 1
d274 2
a275 1
	ac97_get_portnum_by_name
d359 3
d379 61
d543 2
a544 2
ac97_attach(hostIf)
	struct ac97_host_if *hostIf;
d556 4
a559 2
	as->codecIf.vtbl = &ac97civ;
	as->hostIf = hostIf;
d561 1
a561 1
	if ((error = hostIf->attach(hostIf->arg, &as->codecIf))) {
d566 1
a566 1
	hostIf->reset(hostIf->arg);
d569 2
a570 2
	hostIf->write(hostIf->arg, AC97_REG_POWER, 0);
	hostIf->write(hostIf->arg, AC97_REG_RESET, 0);
d573 2
a574 5
	if ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID1, &id1)))
		return (error);

	if ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID2, &id2)))
		return (error);
d576 4
a579 2
	if ((error = hostIf->read(hostIf->arg, AC97_REG_RESET, &caps)))
		return (error);
d582 1
a582 1

d595 3
a597 2

	printf("%s%s\n", j? ", " : "", ac97enhancement[(caps >> 10) & 0x1f]);
d606 1
a606 1
	ctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCoutputs,
d608 2
a609 2
	ac97_mixer_set_port(&as->codecIf, &ctl);
	ctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCinputs,
d612 2
a613 2
	ac97_mixer_set_port(&as->codecIf, &ctl);
	ctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,
d615 1
a615 1
	ac97_mixer_set_port(&as->codecIf, &ctl);
d618 1
a618 1
	ctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,
d622 1
a622 1
	ac97_mixer_set_port(&as->codecIf, &ctl);
d680 1
a680 3
	error = as->hostIf->read(as->hostIf->arg, si->reg, &val);
	if (error)
		return (error);
d734 1
a734 1
	error = as->hostIf->write(as->hostIf->arg, si->reg, (val & ~mask) | newval);
a768 1
	int error;
d776 1
a776 3
	error = as->hostIf->read(as->hostIf->arg, si->reg, &val);
	if (error)
		return (error);
@


1.6
log
@a few more codes ids from vendor docs
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.5 2000/05/27 15:47:17 mickey Exp $ */
a69 23

#define AC97_REG_RESET                0x00
#define AC97_SOUND_ENHANCEMENT(reg)   (((reg) >> 10) & 0x1f)
#define AC97_REG_MASTER_VOLUME        0x02
#define AC97_REG_HEADPHONE_VOLUME     0x04
#define AC97_REG_MASTER_VOLUME_MONO   0x06
#define AC97_REG_MASTER_TONE          0x08
#define AC97_REG_PCBEEP_VOLUME        0x0a
#define AC97_REG_PHONE_VOLUME         0x0c
#define AC97_REG_MIC_VOLUME           0x0e
#define AC97_REG_LINEIN_VOLUME        0x10
#define AC97_REG_CD_VOLUME            0x12
#define AC97_REG_VIDEO_VOLUME         0x14
#define AC97_REG_AUX_VOLUME           0x16
#define AC97_REG_PCMOUT_VOLUME        0x18
#define AC97_REG_RECORD_SELECT        0x1a
#define AC97_REG_RECORD_GAIN          0x1c
#define AC97_REG_RECORD_GAIN_MIC      0x1e
#define AC97_REG_GP                   0x20
#define AC97_REG_3D_CONTROL           0x22
#define AC97_REG_POWER                0x26
#define AC97_REG_VENDOR_ID1           0x7c
#define AC97_REG_VENDOR_ID2           0x7e
@


1.5
log
@add a few more codecs
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.4 2000/04/12 23:38:50 csapuntz Exp $ */
d298 1
d303 1
d305 1
d311 2
a312 1
	{ 0x83847600, "SigmaTel STAC????" 	},
d317 2
@


1.4
log
@

Disable DAC, Output, and Record mute by default
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.3 1999/10/05 18:58:22 csapuntz Exp $ */
d296 1
d299 9
d312 1
a312 1
	{ 0x83847609, "SigmaTel STAC9721" 	},
@


1.3
log
@

Don't define AUDIO_DEBUG
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.2 1999/09/21 16:06:27 csapuntz Exp $ */
d484 2
a485 1
	
d532 23
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.12 2001/04/15 18:25:48 deraadt Exp $ */
d4 1
a4 1
 * Copyright (c) 1999, 2000 Constantine Sapuntzakis
d16 13
a28 15
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.  */
d71 23
a139 1
	u_int16_t default_value;
d158 1
a158 1
	  AC97_REG_MASTER_VOLUME, 0x8000, 5, 0, 1,
d163 1
a163 1
	  AC97_REG_MASTER_VOLUME_MONO, 0x8000, 6, 0, 1,
d167 1
a167 1
	  AC97_REG_GP, 0x0000, 1, 9, 0,
d172 1
a172 1
	  AC97_REG_HEADPHONE_VOLUME, 0x8000, 6, 0, 1,
d177 1
a177 1
	  AC97_REG_MASTER_TONE, 0x0f0f, 4, 0, 0,
d182 1
a182 1
	  AC97_REG_PCBEEP_VOLUME, 0x0000, 4, 1, 1,
d187 1
a187 1
	  AC97_REG_PHONE_VOLUME, 0x8008, 5, 0, 1,
d192 1
a192 1
	  AC97_REG_MIC_VOLUME, 0x8008, 5, 0, 1,
d196 1
a196 1
	  AC97_REG_MIC_VOLUME, 0x8008, 1, 6, 0,
d200 1
a200 1
	  AC97_REG_GP, 0x0000, 1, 8, 0,
d205 1
a205 1
	  AC97_REG_LINEIN_VOLUME, 0x8808, 5, 0, 1,
d210 1
a210 1
	  AC97_REG_CD_VOLUME, 0x8808, 5, 0, 1,
d215 1
a215 1
	  AC97_REG_VIDEO_VOLUME, 0x8808, 5, 0, 1,
d220 1
a220 1
	  AC97_REG_AUX_VOLUME, 0x8808, 5, 0, 1,
d225 1
a225 1
	  AC97_REG_PCMOUT_VOLUME, 0x8808, 5, 0, 1,
d230 1
a230 1
	  AC97_REG_RECORD_SELECT, 0x0000, 3, 0, 0,
d235 1
a235 1
	  AC97_REG_RECORD_GAIN, 0x8000, 4, 0, 1,
d240 1
a240 1
	  AC97_REG_RECORD_GAIN_MIC, 0x8000, 4, 0, 1, 1,
d245 1
a245 1
	  AC97_REG_GP, 0x0000, 1, 12, 0,
d249 1
a249 1
	  AC97_REG_GP, 0x0000, 1, 13, 0,
d253 1
a253 1
	  AC97_REG_3D_CONTROL, 0x0000, 4, 8, 0, 1,
d257 1
a257 1
	  AC97_REG_3D_CONTROL, 0x0000, 4, 0, 0, 1,
d271 1
a271 1
	struct ac97_codec_if codec_if;
d273 1
a273 1
	struct ac97_host_if *host_if;
a276 4

	enum ac97_host_flags host_flags;

	u_int16_t shadow_reg[128];
a283 1
void ac97_restore_shadow __P((struct ac97_codec_if *self));
d289 1
a289 2
	ac97_get_portnum_by_name,
	ac97_restore_shadow
d296 8
a303 28
	{ 0x41445340, "Analog Devices AD1881"		},
	{ 0x414b4d00, "Asahi Kasei AK4540" 		},
	{ 0x414b4d02, "Asahi Kasei AK4543" 		},
	{ 0x414c4710, "Avance ALC200"			},
	{ 0x43525900, "Cirrus Logic CS4297" 		},
	{ 0x43525903, "Cirrus Logic CS4297" 		},
	{ 0x43525913, "Cirrus Logic CS4297A" 		},
	{ 0x43525923, "Cirrus Logic CS4298" 		},
	{ 0x4352592b, "Cirrus Logic CS4294" 		},
	{ 0x43525931, "Cirrus Logic CS4299" 		},
	{ 0x43525933, "Cirrus Logic CS4298A?" 		},
	{ 0x4e534331, "National Semiconductor LM4549"	},
	{ 0x53494c22, "Silicon Laboratory Si3036"	},
	{ 0x53494c23, "Silicon Laboratory Si3038"	},
	{ 0x54524102, "TriTech TR28022"			},
	{ 0x54524103, "TriTech TR28023"			},
	{ 0x54524108, "TriTech TR28028"			},
	{ 0x54524123, "TriTech unknown"			},
	{ 0x574d4c00, "Wolfson WM9704"			},
	{ 0x574d4c03, "Wolfson WM9707"			},
	{ 0x83847600, "SigmaTel STAC9700" 		},
	{ 0x83847604, "SigmaTel STAC9701/3/4/5" 	},
	{ 0x83847605, "SigmaTel STAC9704" 		},
	{ 0x83847608, "SigmaTel STAC9708" 		},
	{ 0x83847609, "SigmaTel STAC9721/23" 		},
	{ 0x83847644, "SigmaTel STAC9744/45"		},
	{ 0x83847684, "SigmaTel STAC9783/84?"		},
	{ 0, 	      NULL				}
a356 3
void ac97_read __P((struct ac97_softc *, u_int8_t, u_int16_t *));
void ac97_setup_defaults __P((struct ac97_softc *));
int ac97_write __P((struct ac97_softc *, u_int8_t, u_int16_t));
a373 64
void
ac97_read(as, reg, val)
	struct ac97_softc *as;
	u_int8_t   reg;
	u_int16_t *val;
{
	int error;
	
	if (((as->host_flags & AC97_HOST_DONT_READ) &&
	    (reg != AC97_REG_VENDOR_ID1 && reg != AC97_REG_VENDOR_ID2 &&
	    reg != AC97_REG_RESET)) ||
	    (as->host_flags & AC97_HOST_DONT_READANY)) {
		*val = as->shadow_reg[reg >> 1];
		return;
	}
	
	if ((error = as->host_if->read(as->host_if->arg, reg, val))) {
		*val = as->shadow_reg[reg >> 1];
	}
	return;
}

int
ac97_write(as, reg, val)
	struct ac97_softc *as;
	u_int8_t   reg;
	u_int16_t  val;
{
	as->shadow_reg[reg >> 1] = val;

	return (as->host_if->write(as->host_if->arg, reg, val));
}

void
ac97_setup_defaults(as)
	struct ac97_softc *as;
{
	int idx;
	struct ac97_source_info *si; 
	
	bzero(as->shadow_reg, sizeof(as->shadow_reg));

	for (idx = 0; idx < SOURCE_INFO_SIZE; idx++) {
		si = &source_info[idx];
		
		ac97_write(as, si->reg, si->default_value);
	}
}

void
ac97_restore_shadow(self)
	struct ac97_codec_if *self;
{
	struct ac97_softc *as = (struct ac97_softc *)self;
	int idx;
	struct ac97_source_info *si; 

	for (idx = 0; idx < SOURCE_INFO_SIZE; idx++) {
		si = &source_info[idx];
		
		ac97_write(as, si->reg, as->shadow_reg[si->reg >> 1]);
	}
}

d477 2
a478 2
ac97_attach(host_if)
	struct ac97_host_if *host_if;
d484 1
a484 2
	mixer_ctrl_t ctl;

d489 2
a490 1
	bzero (as, sizeof(*as));
d492 1
a492 4
	as->codec_if.vtbl = &ac97civ;
	as->host_if = host_if;

	if ((error = host_if->attach(host_if->arg, &as->codec_if))) {
d497 1
a497 1
	host_if->reset(host_if->arg);
d500 2
a501 2
	host_if->write(host_if->arg, AC97_REG_POWER, 0);
	host_if->write(host_if->arg, AC97_REG_RESET, 0);
d504 5
a508 2
	if (host_if->flags)
		as->host_flags = host_if->flags(host_if->arg);
d510 2
a511 4
	ac97_setup_defaults(as);
	ac97_read(as, AC97_REG_VENDOR_ID1, &id1);
	ac97_read(as, AC97_REG_VENDOR_ID2, &id2);
	ac97_read(as, AC97_REG_RESET, &caps);
d514 11
a524 6
	
	if (id) {
		printf("ac97: codec id 0x%08x", id);
		for (i = 0; ac97codecid[i].id; i++) {
			if (ac97codecid[i].id == id) 
				printf(" (%s)", ac97codecid[i].name);
d526 3
a528 11
		printf("\nac97: codec features ");
		for (i = j = 0; i < 10; i++) {
			if (caps & (1 << i)) {
				printf("%s%s", j? ", " : "", ac97feature[i]);
				j++;
			}
		}
		printf("%s%s\n", j? ", " : "", 
		    ac97enhancement[(caps >> 10) & 0x1f]);
	} else
		printf("ac97: codec id not read\n");
a531 23
	/* Just enable the DAC and master volumes by default */
	bzero(&ctl, sizeof(ctl));

	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;  /* off */
	ctl.dev = ac97_get_portnum_by_name(&as->codec_if, AudioCoutputs,
					   AudioNmaster, AudioNmute);
	ac97_mixer_set_port(&as->codec_if, &ctl);
	ctl.dev = ac97_get_portnum_by_name(&as->codec_if, AudioCinputs,
					   AudioNdac, AudioNmute);
	
	ac97_mixer_set_port(&as->codec_if, &ctl);
	ctl.dev = ac97_get_portnum_by_name(&as->codec_if, AudioCrecord,
					   AudioNvolume, AudioNmute);
	ac97_mixer_set_port(&as->codec_if, &ctl);
		
		
	ctl.dev = ac97_get_portnum_by_name(&as->codec_if, AudioCrecord,
					   AudioNsource, NULL);
	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;
	ac97_mixer_set_port(&as->codec_if, &ctl);

d588 3
a590 1
	ac97_read(as, si->reg, &val);
d644 1
a644 1
	error = ac97_write(as, si->reg, (val & ~mask) | newval);
d679 1
d687 3
a689 1
	ac97_read(as, si->reg, &val);
@


1.3.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
a6 1
 * Author:	Constantine Sapuntzakis <csapuntz@@stanford.edu>
d73 26
a98 17
const struct audio_mixer_enum ac97_on_off = {
	2,
	{ { { AudioNoff } , 0 },
	{ { AudioNon }  , 1 } }
};

const struct audio_mixer_enum ac97_mic_select = {
	2,
	{ { { AudioNmicrophone "0" }, 0 },
	{ { AudioNmicrophone "1" }, 1 } }
};

const struct audio_mixer_enum ac97_mono_select = {
	2,
	{ { { AudioNmixerout }, 0 },
	{ { AudioNmicrophone }, 1 } }
};
d100 2
a101 11
const struct audio_mixer_enum ac97_source = {
	8,
	{ { { AudioNmicrophone } , 0 },
	{ { AudioNcd }, 1 },
	{ { "video" }, 2 },
	{ { AudioNaux }, 3 },
	{ { AudioNline }, 4 },
	{ { AudioNmixerout }, 5 },
	{ { AudioNmixerout AudioNmono }, 6 },
	{ { "phone" }, 7 }}
};
a102 9
/*
 * Due to different values for each source that uses these structures,
 * the ac97_query_devinfo function sets delta in mixer_devinfo_t using
 * ac97_source_info.bits.
 */
const struct audio_mixer_value ac97_volume_stereo = {
	{ AudioNvolume },
	2
};
d104 2
a105 4
const struct audio_mixer_value ac97_volume_mono = {
	{ AudioNvolume },
	1
};
d109 1
a109 1
const struct ac97_source_info {
d115 2
a116 2
	const void *info;
	int16_t info_size;
d119 1
d123 1
a123 2
	u_int8_t  polarity:1;		/* Does 0 == MAX or MIN */
	u_int16_t default_value;
d125 3
a127 3
	int16_t  prev;
	int16_t  next;
	int16_t  mixer_class;
d129 110
a238 126
	{
		AudioCinputs,	NULL,		NULL,	AUDIO_MIXER_CLASS,
	}, {
		AudioCoutputs,	NULL,		NULL,	AUDIO_MIXER_CLASS,
	}, {
		AudioCrecord,	NULL,		NULL,	AUDIO_MIXER_CLASS,
	}, {
		/* Stereo master volume*/
		AudioCoutputs,	AudioNmaster,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_MASTER_VOLUME, 5, 0, 1, 0, 0x8000
	}, {
		/* Mono volume */
		AudioCoutputs,	AudioNmono,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_MASTER_VOLUME_MONO, 6, 0, 1, 0, 0x8000
	}, {
		AudioCoutputs,	AudioNmono, AudioNsource, AUDIO_MIXER_ENUM,
		WRAP(ac97_mono_select),
		AC97_REG_GP, 1, 9, 0, 0, 0x0000
	}, {
		/* Headphone volume */
		AudioCoutputs,	AudioNheadphone, NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_HEADPHONE_VOLUME, 6, 0, 1, 0, 0x8000
	}, {
		/* Tone */
		AudioCoutputs,	"tone",		NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_MASTER_TONE, 4, 0, 0, 0, 0x0f0f
	}, {
		/* PC Beep Volume */
		AudioCinputs,	AudioNspeaker,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_PCBEEP_VOLUME, 4, 1, 1, 0x0000
	}, {
		/* Phone */
		AudioCinputs,	"phone",	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_PHONE_VOLUME, 5, 0, 1, 0, 0x8008
	}, {
		/* Mic Volume */
		AudioCinputs,	AudioNmicrophone, NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_MIC_VOLUME, 5, 0, 1, 0, 0x8008
	}, {
		AudioCinputs,	AudioNmicrophone, AudioNpreamp, AUDIO_MIXER_ENUM,
		WRAP(ac97_on_off),
		AC97_REG_MIC_VOLUME, 1, 6, 0, 0, 0x8008
	}, {
		AudioCinputs,	AudioNmicrophone, AudioNsource, AUDIO_MIXER_ENUM,
		WRAP(ac97_mic_select),
		AC97_REG_GP, 1, 8, 0, 0x0000
	}, {
		/* Line in Volume */
		AudioCinputs,	AudioNline,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_LINEIN_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* CD Volume */
		AudioCinputs,	AudioNcd,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_CD_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* Video Volume */
		AudioCinputs,	"video",	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_VIDEO_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* AUX volume */
		AudioCinputs,	AudioNaux,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_AUX_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* PCM out volume */
		AudioCinputs,	AudioNdac,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_PCMOUT_VOLUME, 5, 0, 1, 0, 0x8808
	}, {
		/* Record Source - some logic for this is hard coded - see below */
		AudioCrecord,	AudioNsource,	NULL,	AUDIO_MIXER_ENUM,
		WRAP(ac97_source),
		AC97_REG_RECORD_SELECT, 3, 0, 0, 0, 0x0000
	}, {
		/* Record Gain */
		AudioCrecord,	AudioNvolume,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_RECORD_GAIN, 4, 0, 1, 0, 0x8000
	}, {
		/* Record Gain mic */
		AudioCrecord,	AudioNmicrophone, NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_RECORD_GAIN_MIC, 4, 0, 1, 1, 0x8000
	}, {
		/* */
		AudioCoutputs,	AudioNloudness,	NULL,	AUDIO_MIXER_ENUM,
		WRAP(ac97_on_off),
		AC97_REG_GP, 1, 12, 0, 0, 0x0000
	}, {
		AudioCoutputs,	AudioNspatial,	NULL,	AUDIO_MIXER_ENUM,
		WRAP(ac97_on_off),
		AC97_REG_GP, 1, 13, 0, 0, 0x0000
	}, {
		AudioCoutputs,	AudioNspatial,	"center", AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_3D_CONTROL, 4, 8, 0, 1, 0x0000
	}, {
		AudioCoutputs,	AudioNspatial,	"depth", AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_3D_CONTROL, 4, 0, 0, 1, 0x0000
	}, {
		/* Surround volume */
		AudioCoutputs,	"surround",	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_stereo),
		AC97_REG_SURROUND_VOLUME, 6, 0, 1, 0, 0x8080
	}, {
		/* Center volume */
		AudioCoutputs,	"center",	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_CENTER_LFE_VOLUME, 6, 0, 1, 0, 0x8080
	}, {
		/* LFE volume */
		AudioCoutputs,	"lfe",		NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_CENTER_LFE_VOLUME, 6, 8, 1, 0, 0x8080
	}
d252 1
d254 1
d257 1
d259 1
d271 1
a271 1
	ac97_mixer_get_port,
d278 1
a278 49
const struct ac97_codecid {
	u_int8_t id;
	u_int8_t mask;
	u_int8_t rev;
	u_int8_t shift;	/* no use yet */
	char * const name;
}  ac97_ad[] = {
	{ 0x40, 0xff, 0, 0,	"AD1881" },
	{ 0x60, 0xff, 0, 0,	"AD1885" },
}, ac97_ak[] = {
	{ 0x00,	0xfe, 1, 0,	"AK4540" },
	{ 0x01,	0xfe, 1, 0,	"AK4540" },
	{ 0x02,	0xff, 0, 0,	"AK4543" },
}, ac97_av[] = {
	{ 0x10, 0xff, 0, 0,	"ALC200" },
}, ac97_cs[] = {
	{ 0x00,	0xf8, 7, 0,	"CS4297" },
	{ 0x10,	0xf8, 7, 0,	"CS4297A" },
	{ 0x20,	0xf8, 7, 0,	"CS4298" },
	{ 0x28,	0xf8, 7, 0,	"CS4294" },
	{ 0x30,	0xf8, 7, 0,	"CS4299" },
}, ac97_ns[] = {
	{ 0x31,	0xff, 0, 0,	"LM4549" },
	{ 0x00, 0x00 }
}, ac97_sl[] = {
	{ 0x22,	0xff, 0, 0,	"Si3036" },
	{ 0x23,	0xff, 0, 0,	"Si3038" },
}, ac97_st[] = {
	{ 0x00,	0xff, 0, 0,	"STAC9700" },
	{ 0x04,	0xff, 0, 0,	"STAC970[135]" },
	{ 0x05,	0xff, 0, 0,	"STAC9704" },
	{ 0x08,	0xff, 0, 0,	"STAC9708" },
	{ 0x09,	0xff, 0, 0,	"STAC9721/23" },
	{ 0x44,	0xff, 0, 0,	"STAC9744/45" },
	{ 0x56,	0xff, 0, 0,	"STAC9756/57" },
	{ 0x84,	0xff, 0, 0,	"STAC9784/85" },
}, ac97_tt[] = {
	{ 0x02,	0xff, 0, 0,	"TR28022" },
	{ 0x03,	0xff, 0, 0,	"TR28023" },
	{ 0x08,	0xff, 0, 0,	"TR28028" },
	{ 0x23,	0xff, 0, 0,	"unknown" },
}, ac97_wo[] = {
	{ 0x00,	0xff, 0, 0,	"WM9701A" },
	{ 0x03,	0xff, 0, 0,	"WM9704M/Q-0" },	/* also WM9703 */
	{ 0x04,	0xff, 0, 0,	"WM9704M/Q-1" },
};

#define	cl(n)	n, sizeof(n)/sizeof(n[0])
const struct ac97_vendorid {
d280 30
a309 13
	char * const name;
	const struct ac97_codecid * const codecs;
	u_int8_t num;
} ac97_vendors[] = {
	{ 0x41445300, "Analog Devices",		cl(ac97_ad) },
	{ 0x414B4D00, "Asahi Kasei",		cl(ac97_ak) },
	{ 0x414c4700, "Avance",			cl(ac97_av) },
	{ 0x43525900, "Cirrus Logic",		cl(ac97_cs) },
	{ 0x4e534300, "National Semiconductor", cl(ac97_ns) },
	{ 0x53494c00, "Silicon Laboratory",	cl(ac97_sl) },
	{ 0x54524100, "TriTech Microelectronics", cl(ac97_tt) },
	{ 0x574d4c00, "Wolfson",		cl(ac97_wo) },
	{ 0x83847600, "SigmaTel",		cl(ac97_st) },
d312 1
a312 1
const char * const ac97enhancement[] = {
d315 1
a315 1
	"Creative",
d319 1
a319 1
	"Crystal Semi 3D",
d332 1
a332 1
	"Texas Instruments 3D",
d344 1
a344 1
	"Unknown 3D"
d347 1
a347 1
const char * const ac97feature[] = {
d361 1
a361 1
int ac97_str_equal __P((const char *, const char *));
d363 1
a364 1
int ac97_read __P((struct ac97_softc *, u_int8_t, u_int16_t *));
d382 2
a383 1
int
d386 2
a387 2
	u_int8_t	reg;
	u_int16_t	*val;
d390 1
a390 1

d396 1
a396 1
		return (0);
d398 2
a399 2

	if ((error = as->host_if->read(as->host_if->arg, reg, val)))
d401 2
a402 1
	return (error);
d408 2
a409 2
	u_int8_t	reg;
	u_int16_t	val;
d412 1
d421 2
a422 1

d426 2
a427 2
		const struct ac97_source_info *si = &source_info[idx];

d438 1
d441 2
a442 2
		const struct ac97_source_info *si = &source_info[idx];

d449 1
a449 1
	const char *a, *b;
a457 1
	struct ac97_source_info *si, *si2;
d459 1
d468 1
a468 1
			si->mixer_class = ouridx;
d511 3
a513 2
			if (si2->type == AUDIO_MIXER_CLASS &&
			    ac97_str_equal(si->class, si2->class)) {
d520 4
a523 1
		if (si->prev != 0 || si->qualifier)
d540 1
a540 1

d549 1
a549 1
int
d554 1
a557 1
	int error, i;
d559 3
a561 2
	if (!(as = malloc(sizeof(struct ac97_softc), M_DEVBUF, M_NOWAIT)))
		return (ENOMEM);
d563 1
a563 1
	bzero(as, sizeof(*as));
d569 1
a569 1
		free(as, M_DEVBUF);
d589 1
a590 3
		register const struct ac97_vendorid *vendor;
		register const struct ac97_codecid *codec;

d592 9
a600 18
		for (vendor = &ac97_vendors[sizeof(ac97_vendors) /
		     sizeof(ac97_vendors[0]) - 1];
		     vendor >= ac97_vendors; vendor--) {
			if (vendor->id == (id & AC97_VENDOR_ID_MASK)) {
				printf(" (%s", vendor->name);
				for (codec = &vendor->codecs[vendor->num-1];
				     codec >= vendor->codecs; codec--) {
					if (codec->id == (id & codec->mask))
						break;
				}
				if (codec->mask)
					printf(" %s", codec->name);
				else
					printf(" <%2x>", id & codec->mask);
				if (codec->rev)
					printf(" rev %d", id & codec->rev);
				printf(")");
				break;
d603 2
a604 1
		printf("\n");
a607 16
	if (caps) {
		printf("ac97: codec features ");
		for (i = 0; i < 10; i++) {
			if (caps & (1 << i))
				printf("%s, ", ac97feature[i]);
		}
		printf("%s\n", ac97enhancement[AC97_SOUND_ENHANCEMENT(caps)]);
	}

	ac97_read(as, AC97_REG_EXT_AUDIO_ID, &caps);
	if (caps)
		DPRINTF(("ac97: ext id %b\n", caps, AC97_EXT_AUDIO_BITS));
	if (caps & AC97_EXT_AUDIO_VRA)
		ac97_write(as, AC97_REG_EXT_AUDIO_CTRL,
		    AC97_EXT_AUDIO_VRA | AC97_EXT_AUDIO_VRM);

d616 1
a616 1
	    AudioNmaster, AudioNmute);
a617 1

d619 2
a620 1
	    AudioNdac, AudioNmute);
a621 1

d623 1
a623 1
	    AudioNvolume, AudioNmute);
d625 4
a628 1

a630 2
	ctl.dev = ac97_get_portnum_by_name(&as->codec_if, AudioCrecord,
	    AudioNsource, NULL);
d636 2
a637 1
int
d646 1
a646 1
		const char *name;
d652 1
a652 1

d659 1
a659 1

a663 5

		/* Set the delta for volume sources */
		if (dip->type == AUDIO_MIXER_VALUE)
			dip->un.v.delta = 1 << (8 - si->bits);

d670 2
d683 4
a686 2
	if (cp->dev < 0 || cp->dev >= as->num_source_info ||
	    cp->type != si->type)
d708 1
a708 1
		const struct audio_mixer_value *value = si->info;
d711 2
a712 2
		if (cp->un.value.num_channels <= 0 ||
		    cp->un.value.num_channels > value->num_channels)
d726 3
a728 3

		l >>= 8 - si->bits;
		r >>= 8 - si->bits;
d779 4
a782 2
	if (cp->dev < 0 || cp->dev >= as->num_source_info ||
	    cp->type != si->type)
d794 1
a794 2
		DPRINTFN(4, ("AUDIO_MIXER_ENUM: %x %d %x %d\n", val, si->ofs,
		    mask, cp->un.ord));
d798 1
a798 1
		const struct audio_mixer_value *value = si->info;
d802 1
a802 1
		    (cp->un.value.num_channels > value->num_channels))
d805 4
a808 2
		l = r = (val >> si->ofs) & mask;
		if (value->num_channels > 1) 
d810 1
d812 2
a813 2
		l <<= 8 - si->bits;
		r <<= 8 - si->bits;
d819 3
a821 5
		/*
		 * The EAP driver averages l and r for stereo
		 * channels that are requested in MONO mode. Does this
		 * make sense?
		 */
a837 49
int
ac97_set_rate(codec_if, p, mode)
	struct ac97_codec_if *codec_if;
	struct audio_params *p;
	int mode;
{
	struct ac97_softc *as = (struct ac97_softc *)codec_if;
	u_int16_t reg, val, regval, id = 0;

	DPRINTFN(5, ("set_rate(%lu) ", p->sample_rate));

	if (p->sample_rate > 0xffff) {
		if (mode != AUMODE_PLAY)
			return (EINVAL);
		if (ac97_read(as, AC97_REG_EXT_AUDIO_ID, &id))
			return (EIO);
		if (!(id & AC97_EXT_AUDIO_DRA))
			return (EINVAL);
		if (ac97_read(as, AC97_REG_EXT_AUDIO_CTRL, &id))
			return (EIO);
		id |= AC97_EXT_AUDIO_DRA;
		if (ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, id))
			return (EIO);
		p->sample_rate /= 2;
	}

	/* i guess it's better w/o clicks and squeecks when changing the rate */
	if (ac97_read(as, AC97_REG_POWER, &val) ||
	    ac97_write(as, AC97_REG_POWER, val |
	      (mode == AUMODE_PLAY? AC97_POWER_OUT : AC97_POWER_IN)))
		return (EIO);

	reg = mode == AUMODE_PLAY ?
	    AC97_REG_FRONT_DAC_RATE : AC97_REG_PCM_ADC_RATE;

	if (ac97_write(as, reg, (u_int16_t) p->sample_rate) ||
	    ac97_read(as, reg, &regval))
		return (EIO);
	p->sample_rate = regval;
	if (id & AC97_EXT_AUDIO_DRA)
		p->sample_rate *= 2;

	DPRINTFN(5, (" %lu\n", regval));

	if (ac97_write(as, AC97_REG_POWER, val))
		return (EIO);

	return (0);
}
@


1.3.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.3.4.2 2001/07/04 10:40:22 niklas Exp $	*/
d166 3
a168 6
		AudioCoutputs,	AudioNbass,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
		AC97_REG_MASTER_TONE, 4, 8, 0, 0, 0x0f0f
	}, {
		AudioCoutputs,	AudioNtreble,	NULL,	AUDIO_MIXER_VALUE,
		WRAP(ac97_volume_mono),
d174 1
a174 1
		AC97_REG_PCBEEP_VOLUME, 4, 1, 1, 0, 0x0000
d243 1
a243 1
		AudioCoutputs,	AudioNspatial,	AudioNcenter,AUDIO_MIXER_VALUE,
d247 1
a247 1
		AudioCoutputs,	AudioNspatial,	AudioNdepth, AUDIO_MIXER_VALUE,
d252 1
a252 1
		AudioCoutputs,	AudioNsurround,	NULL,	AUDIO_MIXER_VALUE,
d257 1
a257 1
		AudioCoutputs,	AudioNcenter,	NULL,	AUDIO_MIXER_VALUE,
d262 1
a262 1
		AudioCoutputs,	AudioNlfe,	NULL,	AUDIO_MIXER_VALUE,
a307 1
	{ 0x03, 0xff, 0, 0,	"AD1819" },
a308 1
	{ 0x48, 0xff, 0, 0,	"AD1881A" },
a309 1
	{ 0x61, 0xff, 0, 0,	"AD1886" },
a313 2
	{ 0x06,	0xff, 0, 0,	"AK4544A" },
	{ 0x07,	0xff, 0, 0,	"AK4545" },
a315 4
}, ac97_rl[] = {
	{ 0x00, 0xff, 0, 0,	"RL5306" },
	{ 0x10, 0xff, 0, 0,	"RL5382" },
	{ 0x20, 0xff, 0, 0,	"RL5383" },
a321 8
	{ 0x40,	0xf8, 7, 0,	"CS4201" },
	{ 0x50,	0xf8, 7, 0,	"CS4205" },
	{ 0x60,	0xf8, 7, 0,	"CS4291" },
}, ac97_is[] = {
	{ 0x00, 0xff, 0, 0,	"HMP9701" },
}, ac97_ic[] = {
	{ 0x01, 0xff, 0, 0,	"ICE1230" },
	{ 0x11, 0xff, 0, 0,	"ICE1232" },
a322 1
	{ 0x00,	0xff, 0, 0,	"LM454[03568]" },
d324 1
d332 1
a332 1
	{ 0x08,	0xff, 0, 0,	"STAC9708/11" },
a339 1
	{ 0x06,	0xff, 0, 0,	"TR28026" },
d341 1
a341 5
	{ 0x23,	0xff, 0, 0,	"TR28602" },
}, ac97_ti[] = {
	{ 0x20, 0xff, 0, 0,	"TLC320AD9xC" },
}, ac97_wb[] = {
	{ 0x01, 0xff, 0, 0,	"W83971D" },
d344 1
a344 1
	{ 0x03,	0xff, 0, 0,	"WM9704M/Q-0" }, /* & WM9703 */
a345 2
}, ac97_ym[] = {
	{ 0x00, 0xff, 0, 0,	"YMF743" },
d357 1
a357 2
	{ 0x414c4700, "Avance Logic",		cl(ac97_av) },
	{ 0x414c4300, "Realtek",		cl(ac97_rl) },
a358 2
	{ 0x48525300, "Intersil",		cl(ac97_is) },
	{ 0x49434500, "ICEnsemble",		cl(ac97_ic) },
a361 2
	{ 0x54584e00, "Texas Instruments",	cl(ac97_ti) },
	{ 0x57454300, "Winbond",		cl(ac97_wb) },
a362 1
	{ 0x594d4800, "Yamaha",			cl(ac97_ym) },
a364 1
#undef cl
d651 1
a651 1
					printf(" <%02x>", id & 0xff);
@


1.3.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a285 1
	u_int16_t caps, ext_id;
d633 1
a633 1
	u_int16_t id1, id2;
d664 1
a664 1
	ac97_read(as, AC97_REG_RESET, &as->caps);
d696 1
a696 1
	if (as->caps) {
d699 1
a699 1
			if (as->caps & (1 << i))
d702 1
a702 2
		printf("%s\n",
		    ac97enhancement[AC97_CAPS_ENHANCEMENT(as->caps)]);
d705 4
a708 5
	ac97_read(as, AC97_REG_EXT_AUDIO_ID, &as->ext_id);
	if (as->ext_id)
		DPRINTF(("ac97: ext id %b\n", as->ext_id,
		    AC97_EXT_AUDIO_BITS));
	if (as->ext_id & AC97_EXT_AUDIO_VRA)
a950 5
	if (!(as->ext_id & AC97_EXT_AUDIO_VRA)) {
		p->sample_rate = AC97_SINGLERATE;
		return (0);
	}

d954 3
a956 1
		if (!(as->ext_id & AC97_EXT_AUDIO_DRA))
@


1.3.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.3.4.4 2001/11/13 21:10:00 niklas Exp $	*/
d326 3
a328 3
	{ 0x00, 0xf0, 0xf, 0,	"RL5306" },
	{ 0x10, 0xf0, 0xf, 0,	"RL5382" },
	{ 0x20, 0xf0, 0xf, 0,	"RL5383" },
d683 1
a683 1
				if (codec >= vendor->codecs && codec->mask)
d687 2
a688 3
				if (codec >= vendor->codecs && codec->rev)
					printf(" rev %d",
					    id & codec->rev);
@


1.3.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a337 2
}, ac97_es[] = {
	{ 0x08, 0xff, 0, 0,	"ES1921" },
a387 1
	{ 0x45838300, "ESS Technology",		cl(ac97_es) },
a711 1
	ac97_read(as, AC97_REG_EXT_AUDIO_ID, &id1);
d713 2
a714 4
		id1 |= AC97_EXT_AUDIO_VRA;
	if (as->ext_id & AC97_EXT_AUDIO_VRM)
		id1 |= AC97_EXT_AUDIO_VRM;
	ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, id1);
@


1.3.4.7
log
@Merge in -current from about a week ago
@
text
@d290 6
a295 6
int ac97_mixer_get_port(struct ac97_codec_if *self, mixer_ctrl_t *cp);
int ac97_mixer_set_port(struct ac97_codec_if *self, mixer_ctrl_t *);
int ac97_query_devinfo(struct ac97_codec_if *self, mixer_devinfo_t *);
int ac97_get_portnum_by_name(struct ac97_codec_if *, char *, char *,
				  char *);
void ac97_restore_shadow(struct ac97_codec_if *self);
d453 5
a457 5
int ac97_str_equal(const char *, const char *);
void ac97_setup_source_info(struct ac97_softc *);
void ac97_setup_defaults(struct ac97_softc *);
int ac97_read(struct ac97_softc *, u_int8_t, u_int16_t *);
int ac97_write(struct ac97_softc *, u_int8_t, u_int16_t);
@


1.3.4.8
log
@Sync the SMP branch with 3.3
@
text
@a316 1
	{ 0x72, 0xff, 0, 0,	"AD1981A" },
d432 1
a432 1
	"KS Waves 3D",
d715 6
a720 8
	if (as->ext_id & (AC97_EXT_AUDIO_VRA | AC97_EXT_AUDIO_VRM)) {
		ac97_read(as, AC97_REG_EXT_AUDIO_CTRL, &id1);
		if (as->ext_id & AC97_EXT_AUDIO_VRA)
			id1 |= AC97_EXT_AUDIO_VRA;
		if (as->ext_id & AC97_EXT_AUDIO_VRM)
			id1 |= AC97_EXT_AUDIO_VRM;
		ac97_write(as, AC97_REG_EXT_AUDIO_CTRL, id1);
	}
d832 2
a833 7
			if (!(as->host_flags & AC97_HOST_SWAPPED_CHANNELS)) {
				l = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
				r = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
			} else {
				r = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
				l = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
			}
d918 3
a920 11
		if (value->num_channels == 1) 
			l = r = (val >> si->ofs) & mask;
		else {
			if (!(as->host_flags & AC97_HOST_SWAPPED_CHANNELS)) {
				l = (val >> si->ofs) & mask;
				r = (val >> (si->ofs + 8)) & mask;
			} else {
				r = (val >> si->ofs) & mask;
				l = (val >> (si->ofs + 8)) & mask;
			}
		}
@


1.3.4.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac97.c,v 1.3.4.8 2003/03/28 00:38:11 niklas Exp $	*/
a316 1
	{ 0x70, 0xff, 0, 0,	"AD1981" },
a325 1
	{ 0x20, 0xff, 0, 0,	"ALC650" },
a358 1
	{ 0x52,	0xff, 0, 0,	"STAC9752/53" },
a359 1
	{ 0x66,	0xff, 0, 0,	"STAC9766/67" },
d777 1
a777 1
			strlcpy(dip->label.name, name, sizeof dip->label.name);
@


1.3.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a296 2
static void ac97_ad198x_init(struct ac97_softc *);

a310 1
	void (*init)(struct ac97_softc *);
a318 2
	{ 0x74, 0xff, 0, 0,	"AD1981B" },
	{ 0x75, 0xff, 0, 0,	"AD1985",	ac97_ad198x_init },
a331 5
}, ac97_cm[] = {
	{ 0x41,	0xff, 0, 0,	"CMI9738" },
	{ 0x61,	0xff, 0, 0,	"CMI9739" },
}, ac97_cr[] = {
	{ 0x84,	0xff, 0, 0,	"EV1938" },
a340 5
}, ac97_cx[] = {
	{ 0x29, 0xff, 0, 0,	"CX20468" },
}, ac97_em[] = {
	{ 0x23, 0xff, 0, 0,	"EM28023" },
	{ 0x28, 0xff, 0, 0,	"EM28028" },
a350 3
}, ac97_ps[] = {
	{ 0x01,	0xff, 0, 0,	"UCB1510" },
	{ 0x04,	0xff, 0, 0,	"UCB1400" },
a364 2
}, ac97_vi[] = {
	{ 0x61, 0xff, 0, 0,	"VT1612A" },
a389 1
	{ 0x01408300, "Creative",		cl(ac97_cr) },
d391 2
a392 1
	{ 0x414b4D00, "Asahi Kasei",		cl(ac97_ak) },
a393 2
	{ 0x414c4700, "Avance Logic",		cl(ac97_av) },
	{ 0x434d4900, "C-Media Electronics",	cl(ac97_cm) },
a394 2
	{ 0x43585400, "Conexant",		cl(ac97_cx) },
	{ 0x454d4300, "eMicro",			cl(ac97_em) },
a398 1
	{ 0x50534300, "Philips Semiconductor",	cl(ac97_ps) },
a401 1
	{ 0x56494100, "VIA Technologies",	cl(ac97_vi) },
a645 3
	void (*initfunc)(struct ac97_softc *);

	initfunc = NULL;
d691 1
a691 1
				if (codec >= vendor->codecs && codec->mask) {
d693 1
a693 2
					initfunc = codec->init;
				} else
a753 4
	/* use initfunc for specific device */
	if (initfunc != NULL)
		initfunc(as);

a1020 14
}

/*
 * Codec-dependent initialization
 */
  	 
static void
ac97_ad198x_init(struct ac97_softc *as)
{
        unsigned short misc;

        ac97_read(as, AC97_AD_REG_MISC, &misc);
        ac97_write(as, AC97_AD_REG_MISC,
	    misc|AC97_AD_MISC_DAM|AC97_AD_MISC_MADPD);
@


1.3.4.11
log
@Merge with the trunk
@
text
@d276 2
a277 2
 * Check out http://www.intel.com/labs/media/audio/index.htm
 * for information on AC-97
d297 1
a297 2
void ac97_ad198x_init(struct ac97_softc *);
void ac97_cx20468_init(struct ac97_softc *);
d352 1
a352 2
	{ 0x21, 0xff, 0, 0,	"HSD11246" },
	{ 0x28, 0xf8, 7, 0,	"CX20468",	ac97_cx20468_init },
d726 2
a727 1
					printf(" rev %d", id & codec->rev);
d964 1
a964 1
		if (value->num_channels == 1)
d1060 2
a1061 2

void
d1064 1
a1064 1
	unsigned short misc;
d1066 2
a1067 2
	ac97_read(as, AC97_AD_REG_MISC, &misc);
	ac97_write(as, AC97_AD_REG_MISC,
a1068 10
}

void
ac97_cx20468_init(struct ac97_softc *as)
{
	unsigned short misc;

	ac97_read(as, AC97_CX_REG_MISC, &misc);
	ac97_write(as, AC97_CX_REG_MISC,
	    AC97_CX_SPDIFEN | AC97_CX_COPYRIGHT | AC97_CX_MASK);
@


1.2
log
@

Add get_portnum_by_name to ac97 vtbl.

get_portnum_by_name returns the mixer port # given a (class, device,
qualifier) tuple.
@
text
@d1 1
a1 1
/*      $OpenBSD: ac97.c,v 1.1 1999/09/19 06:45:12 csapuntz Exp $ */
d358 1
a358 2
#define AUDIO_DEBUG
#define AC97_DEBUG 0
@


1.1
log
@

AC-97 CODEC support. Some help from FreeBSD, esp. on nice printing of
features.
@
text
@d1 1
a1 1
/*      $OpenBSD: $ */
d282 2
d288 2
a289 1
	ac97_query_devinfo
d613 3
a615 2
		if (cp->un.value.num_channels != 
		    value->num_channels) return (EINVAL);
d653 19
d706 3
a708 2
		if (cp->un.value.num_channels != 
		    value->num_channels) return (EINVAL);
@

