head	1.100;
access;
symbols
	OPENBSD_6_2_BASE:1.100
	OPENBSD_6_1:1.97.0.4
	OPENBSD_6_1_BASE:1.97
	OPENBSD_6_0:1.96.0.4
	OPENBSD_6_0_BASE:1.96
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.90.0.6
	OPENBSD_5_8_BASE:1.90
	OPENBSD_5_7:1.90.0.2
	OPENBSD_5_7_BASE:1.90
	OPENBSD_5_6:1.87.0.4
	OPENBSD_5_6_BASE:1.87
	OPENBSD_5_5:1.83.0.4
	OPENBSD_5_5_BASE:1.83
	OPENBSD_5_4:1.82.0.4
	OPENBSD_5_4_BASE:1.82
	OPENBSD_5_3:1.82.0.2
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.81.0.6
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.81
	OPENBSD_5_1:1.81.0.8
	OPENBSD_5_0:1.81.0.4
	OPENBSD_5_0_BASE:1.81
	OPENBSD_4_9:1.81.0.2
	OPENBSD_4_9_BASE:1.81
	OPENBSD_4_8:1.78.0.4
	OPENBSD_4_8_BASE:1.78
	OPENBSD_4_7:1.78.0.2
	OPENBSD_4_7_BASE:1.78
	OPENBSD_4_6:1.73.0.4
	OPENBSD_4_6_BASE:1.73
	OPENBSD_4_5:1.72.0.2
	OPENBSD_4_5_BASE:1.72
	OPENBSD_4_4:1.67.0.2
	OPENBSD_4_4_BASE:1.67
	OPENBSD_4_3:1.65.0.2
	OPENBSD_4_3_BASE:1.65
	OPENBSD_4_2:1.61.0.2
	OPENBSD_4_2_BASE:1.61
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.53.0.2
	OPENBSD_3_9_BASE:1.53
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26;
locks; strict;
comment	@ * @;


1.100
date	2017.09.22.13.44.00;	author kevlo;	state Exp;
branches;
next	1.99;
commitid	HuWVIuVbGs3sLYJO;

1.99
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.98;
commitid	uRv5pa9QDlZaYgwD;

1.98
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.97;
commitid	6s3MfY9d6ZKdL2Uz;

1.97
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.96;
commitid	VyLWTsbepAOk7VQM;

1.96
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.95;
commitid	QHiEhS9DHyE6oiIr;

1.95
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.94;
commitid	J9apD0jq2AjFmqZc;

1.94
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.93;
commitid	B0kwmVGiD5DVx4kv;

1.93
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.92;
commitid	eYnPulzvLjDImPCa;

1.92
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.91;
commitid	YT6fyIEviv9qwbl6;

1.91
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.90;
commitid	p0v5tuE1Ch6fY0Nj;

1.90
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.89;
commitid	Hly9lJn6CNMylcFu;

1.89
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.88;
commitid	yM2VFFhpDTeFQlve;

1.88
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.87;
commitid	LS2TNeCue5R9L67C;

1.87
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.86;
commitid	JtO5uXxVcnZfhUkR;

1.86
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.85;
commitid	I19imNlAX05zJOED;

1.85
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.84;
commitid	EF98ch02VpFassUi;

1.84
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.83;

1.83
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.82;

1.82
date	2012.12.05.23.20.19;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2010.09.07.16.21.43;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2010.08.29.16.46.58;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2010.08.27.04.09.19;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2009.11.24.00.28.22;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2009.08.16.18.21.57;	author jsg;	state Exp;
branches;
next	1.76;

1.76
date	2009.08.16.18.05.51;	author jsg;	state Exp;
branches;
next	1.75;

1.75
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2009.07.28.11.45.05;	author blambert;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.72;

1.72
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.71;

1.71
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.70;

1.70
date	2008.08.27.10.29.53;	author damien;	state Exp;
branches;
next	1.69;

1.69
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.68;

1.68
date	2008.08.14.16.02.24;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.66;

1.66
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.21.15.58.22;	author blambert;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.24.12.37.01;	author blambert;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.30.11.33.14;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.07.20.20.15;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.06.12.20.59;	author jsg;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.02.08.41.04;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.14.04.59.55;	author jsg;	state Exp;
branches;
next	1.57;

1.57
date	2007.01.03.18.16.43;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2006.11.26.17.20.33;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2006.08.30.11.20.20;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2006.02.05.23.47.47;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.05.05.40.35;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.05.05.36.05;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.20.09.49.05;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.05.02.31.29;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.04.15.05.30;	author jsg;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.04.14.04.33;	author jsg;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.24.02.53.31;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.24.02.43.56;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.24.02.41.58;	author reyk;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.23.12.57.42;	author jsg;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.23.08.47.14;	author reyk;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.23.08.23.00;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.15.00.59.11;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.15.00.33.48;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.14.23.40.23;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.14.23.20.17;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.18.02.43.27;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.15.01.33.50;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.13.13.37.51;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.29.06.03.11;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.29.03.57.54;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.29.03.49.52;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.29.02.54.51;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.27.18.57.18;	author robert;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.23.23.14.30;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.18.00.10.36;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.15.09.24.53;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.12.07.05.48;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.03.14.36.38;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.02.11.14.12;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.27.09.32.46;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.25.12.18.27;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.22.09.16.51;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.19.03.33.30;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.14.12.49.29;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.08.11.08.56;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.06.21.57.06;	author pedro;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.06.10.35.54;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.06.07.08.24;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.22.11.22.17;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.22.10.14.25;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.19.11.29.27;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.19.11.07.32;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.19.09.36.18;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.10.06.49.19;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.09.21.46.56;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.09.21.39.04;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.04.04.54.56;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.31.00.16.15;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.29.01.02.31;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.100
log
@Use ieee80211_has_addr4() inline function where possible.

ok stsp@@
@
text
@/*	$OpenBSD: rtw.c,v 1.99 2017/09/08 05:36:52 deraadt Exp $	*/
/*	$NetBSD: rtw.c,v 1.29 2004/12/27 19:49:16 dyoung Exp $ */

/*-
 * Copyright (c) 2004, 2005 David Young.  All rights reserved.
 *
 * Programmed for NetBSD by David Young.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of David Young may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY David Young ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL David
 * Young BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * Device driver for the Realtek RTL8180 802.11 MAC/BBP.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>	/* splnet */

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/rtwreg.h>
#include <dev/ic/rtwvar.h>
#include <dev/ic/max2820reg.h>
#include <dev/ic/sa2400reg.h>
#include <dev/ic/si4136reg.h>
#include <dev/ic/rtl8225reg.h>
#include <dev/ic/smc93cx6var.h>

int rtw_rfprog_fallback = 0;
int rtw_do_chip_reset = 0;
int rtw_dwelltime = 200;	/* milliseconds per channel */
int rtw_macbangbits_timeout = 100;

#ifdef RTW_DEBUG
int rtw_debug = 0;
int rtw_rxbufs_limit = RTW_RXQLEN;
#endif /* RTW_DEBUG */

void	 rtw_start(struct ifnet *);
void	 rtw_txdesc_blk_init_all(struct rtw_txdesc_blk *);
void	 rtw_txsoft_blk_init_all(struct rtw_txsoft_blk *);
void	 rtw_txdesc_blk_init(struct rtw_txdesc_blk *);
void	 rtw_txdescs_sync(struct rtw_txdesc_blk *, u_int, u_int, int);
void	 rtw_txring_fixup(struct rtw_softc *);
void	 rtw_rxbufs_release(bus_dma_tag_t, struct rtw_rxsoft *);
void	 rtw_rxdesc_init(struct rtw_rxdesc_blk *, struct rtw_rxsoft *, int, int);
void	 rtw_rxring_fixup(struct rtw_softc *);
void	 rtw_io_enable(struct rtw_regs *, u_int8_t, int);
void	 rtw_intr_rx(struct rtw_softc *, u_int16_t);
#ifndef IEEE80211_STA_ONLY
void	 rtw_intr_beacon(struct rtw_softc *, u_int16_t);
void	 rtw_intr_atim(struct rtw_softc *);
#endif
void	 rtw_transmit_config(struct rtw_softc *);
void	 rtw_pktfilt_load(struct rtw_softc *);
void	 rtw_start(struct ifnet *);
void	 rtw_watchdog(struct ifnet *);
void	 rtw_next_scan(void *);
#ifndef IEEE80211_STA_ONLY
void	 rtw_recv_mgmt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, struct ieee80211_rxinfo *, int);
#endif
struct ieee80211_node *rtw_node_alloc(struct ieee80211com *);
void	 rtw_node_free(struct ieee80211com *, struct ieee80211_node *);
void	 rtw_media_status(struct ifnet *, struct ifmediareq *);
void	 rtw_txsoft_blk_cleanup_all(struct rtw_softc *);
void	 rtw_txdesc_blk_setup(struct rtw_txdesc_blk *, struct rtw_txdesc *,
	    u_int, bus_addr_t, bus_addr_t);
void	 rtw_txdesc_blk_setup_all(struct rtw_softc *);
void	 rtw_intr_tx(struct rtw_softc *, u_int16_t);
void	 rtw_intr_ioerror(struct rtw_softc *, u_int16_t);
void	 rtw_intr_timeout(struct rtw_softc *);
void	 rtw_stop(struct ifnet *, int);
void	 rtw_maxim_pwrstate(struct rtw_regs *, enum rtw_pwrstate, int, int);
void	 rtw_philips_pwrstate(struct rtw_regs *, enum rtw_pwrstate, int, int);
void	 rtw_rtl_pwrstate(struct rtw_regs *, enum rtw_pwrstate, int, int);
void	 rtw_pwrstate0(struct rtw_softc *, enum rtw_pwrstate, int, int);
void	 rtw_join_bss(struct rtw_softc *, u_int8_t *, u_int16_t);
void	 rtw_set_access1(struct rtw_regs *, enum rtw_access);
int	 rtw_srom_parse(struct rtw_softc *);
int	 rtw_srom_read(struct rtw_regs *, u_int32_t, struct rtw_srom *,
	    const char *);
void	 rtw_set_rfprog(struct rtw_regs *, int, const char *);
u_int8_t rtw_chan2txpower(struct rtw_srom *, struct ieee80211com *,
	    struct ieee80211_channel *);
int	 rtw_txsoft_blk_init(struct rtw_txsoft_blk *);
int	 rtw_rxsoft_init_all(bus_dma_tag_t, struct rtw_rxsoft *,
	    int *, const char *);
void	 rtw_txsoft_release(bus_dma_tag_t, struct ieee80211com *,
	    struct rtw_txsoft *);
void	 rtw_txsofts_release(bus_dma_tag_t, struct ieee80211com *,
	    struct rtw_txsoft_blk *);
void	 rtw_hwring_setup(struct rtw_softc *);
int	 rtw_swring_setup(struct rtw_softc *);
void	 rtw_txdescs_reset(struct rtw_softc *);
void	 rtw_rfmd_pwrstate(struct rtw_regs *, enum rtw_pwrstate, int, int);
int	 rtw_pwrstate(struct rtw_softc *, enum rtw_pwrstate);
int	 rtw_tune(struct rtw_softc *);
void	 rtw_set_nettype(struct rtw_softc *, enum ieee80211_opmode);
int	 rtw_compute_duration1(int, int, uint32_t, int, struct rtw_duration *);
int	 rtw_compute_duration(struct ieee80211_frame *, int, uint32_t, int,
	    int, struct rtw_duration *, struct rtw_duration *, int *, int);
int	 rtw_init(struct ifnet *);
int	 rtw_ioctl(struct ifnet *, u_long, caddr_t);
int	 rtw_seg_too_short(bus_dmamap_t);
struct mbuf *rtw_dmamap_load_txbuf(bus_dma_tag_t, bus_dmamap_t, struct mbuf *,
	    u_int, short *, const char *);
int	 rtw_newstate(struct ieee80211com *, enum ieee80211_state, int);
int	 rtw_media_change(struct ifnet *);
int	 rtw_txsoft_blk_setup_all(struct rtw_softc *);
int	 rtw_rf_attach(struct rtw_softc *, int);
u_int8_t rtw_check_phydelay(struct rtw_regs *, u_int32_t);
int	 rtw_chip_reset1(struct rtw_regs *, const char *);
int	 rtw_chip_reset(struct rtw_regs *, const char *);
int	 rtw_recall_eeprom(struct rtw_regs *, const char *);
int	 rtw_reset(struct rtw_softc *);
void	 rtw_reset_oactive(struct rtw_softc *);
int	 rtw_txdesc_dmamaps_create(bus_dma_tag_t, struct rtw_txsoft *, u_int);
int	 rtw_rxdesc_dmamaps_create(bus_dma_tag_t, struct rtw_rxsoft *, u_int);
void	 rtw_rxdesc_dmamaps_destroy(bus_dma_tag_t, struct rtw_rxsoft *, u_int);
void	 rtw_txdesc_dmamaps_destroy(bus_dma_tag_t, struct rtw_txsoft *, u_int);
void	 rtw_identify_country(struct rtw_regs *, enum rtw_locale *);
int	 rtw_identify_sta(struct rtw_regs *, u_int8_t (*)[], const char *);
void	 rtw_rxdescs_sync(struct rtw_rxdesc_blk *, int, int, int);
int	 rtw_rxsoft_alloc(bus_dma_tag_t, struct rtw_rxsoft *);
void	 rtw_collect_txpkt(struct rtw_softc *, struct rtw_txdesc_blk *,
	    struct rtw_txsoft *, int);
void	 rtw_collect_txring(struct rtw_softc *, struct rtw_txsoft_blk *,
	    struct rtw_txdesc_blk *, int);
void	 rtw_suspend_ticks(struct rtw_softc *);
void	 rtw_resume_ticks(struct rtw_softc *);
void	 rtw_enable_interrupts(struct rtw_softc *);
int	 rtw_dequeue(struct ifnet *, struct rtw_txsoft_blk **,
	    struct rtw_txdesc_blk **, struct mbuf **,
	    struct ieee80211_node **);
int	 rtw_txsoft_blk_setup(struct rtw_txsoft_blk *, u_int);
void	 rtw_rxdesc_init_all(struct rtw_rxdesc_blk *, struct rtw_rxsoft *,
	    int);
int	 rtw_txring_choose(struct rtw_softc *, struct rtw_txsoft_blk **,
	    struct rtw_txdesc_blk **, int);
u_int	 rtw_txring_next(struct rtw_regs *, struct rtw_txdesc_blk *);
struct mbuf *rtw_80211_dequeue(struct rtw_softc *, struct mbuf_queue *, int,
	    struct rtw_txsoft_blk **, struct rtw_txdesc_blk **,
	    struct ieee80211_node **);
uint64_t rtw_tsf_extend(struct rtw_regs *, u_int32_t);
#ifndef IEEE80211_STA_ONLY
void	 rtw_ibss_merge(struct rtw_softc *, struct ieee80211_node *,
	    u_int32_t);
#endif
void	 rtw_idle(struct rtw_regs *);
void	 rtw_led_attach(struct rtw_led_state *, void *);
void	 rtw_led_init(struct rtw_regs *);
void	 rtw_led_slowblink(void *);
void	 rtw_led_fastblink(void *);
void	 rtw_led_set(struct rtw_led_state *, struct rtw_regs *, u_int);
void	 rtw_led_newstate(struct rtw_softc *, enum ieee80211_state);

int	 rtw_phy_init(struct rtw_softc *);
int	 rtw_bbp_preinit(struct rtw_regs *, u_int, int, u_int);
int	 rtw_bbp_init(struct rtw_regs *, struct rtw_bbpset *, int,
	    int, u_int8_t, u_int);
void	 rtw_verify_syna(u_int, u_int32_t);
int	 rtw_sa2400_pwrstate(struct rtw_softc *, enum rtw_pwrstate);
int	 rtw_sa2400_txpower(struct rtw_softc *, u_int8_t);
int	 rtw_sa2400_tune(struct rtw_softc *, u_int);
int	 rtw_sa2400_vcocal_start(struct rtw_softc *, int);
int	 rtw_sa2400_vco_calibration(struct rtw_softc *);
int	 rtw_sa2400_filter_calibration(struct rtw_softc *);
int	 rtw_sa2400_dc_calibration(struct rtw_softc *);
int	 rtw_sa2400_calibrate(struct rtw_softc *, u_int);
int	 rtw_sa2400_init(struct rtw_softc *, u_int, u_int8_t,
	    enum rtw_pwrstate);
int	 rtw_max2820_pwrstate(struct rtw_softc *, enum rtw_pwrstate);
int	 rtw_max2820_init(struct rtw_softc *, u_int, u_int8_t,
	    enum rtw_pwrstate);
int	 rtw_max2820_txpower(struct rtw_softc *, u_int8_t);
int	 rtw_max2820_tune(struct rtw_softc *, u_int);
int	 rtw_rtl8225_pwrstate(struct rtw_softc *, enum rtw_pwrstate);
int	 rtw_rtl8225_init(struct rtw_softc *, u_int, u_int8_t,
	    enum rtw_pwrstate);
int	 rtw_rtl8225_txpower(struct rtw_softc *, u_int8_t);
int	 rtw_rtl8225_tune(struct rtw_softc *, u_int);
int	 rtw_rtl8255_pwrstate(struct rtw_softc *, enum rtw_pwrstate);
int	 rtw_rtl8255_init(struct rtw_softc *, u_int, u_int8_t,
	    enum rtw_pwrstate);
int	 rtw_rtl8255_txpower(struct rtw_softc *, u_int8_t);
int	 rtw_rtl8255_tune(struct rtw_softc *, u_int);
int	 rtw_grf5101_pwrstate(struct rtw_softc *, enum rtw_pwrstate);
int	 rtw_grf5101_init(struct rtw_softc *, u_int, u_int8_t,
	    enum rtw_pwrstate);
int	 rtw_grf5101_txpower(struct rtw_softc *, u_int8_t);
int	 rtw_grf5101_tune(struct rtw_softc *, u_int);
int	 rtw_rf_hostwrite(struct rtw_softc *, u_int, u_int32_t);
int	 rtw_rf_macwrite(struct rtw_softc *, u_int, u_int32_t);
int	 rtw_bbp_write(struct rtw_regs *, u_int, u_int);
u_int32_t rtw_grf5101_host_crypt(u_int, u_int32_t);
u_int32_t rtw_maxim_swizzle(u_int, uint32_t);
u_int32_t rtw_grf5101_mac_crypt(u_int, u_int32_t);
void	 rtw_rf_hostbangbits(struct rtw_regs *, u_int32_t, int, u_int);
void	 rtw_rf_rtl8225_hostbangbits(struct rtw_regs *, u_int32_t, int, u_int);
int	 rtw_rf_macbangbits(struct rtw_regs *, u_int32_t);

u_int8_t rtw_read8(void *, u_int32_t);
u_int16_t rtw_read16(void *, u_int32_t);
u_int32_t rtw_read32(void *, u_int32_t);
void	 rtw_write8(void *, u_int32_t, u_int8_t);
void	 rtw_write16(void *, u_int32_t, u_int16_t);
void	 rtw_write32(void *, u_int32_t, u_int32_t);
void	 rtw_barrier(void *, u_int32_t, u_int32_t, int);

#ifdef RTW_DEBUG
void	 rtw_print_txdesc(struct rtw_softc *, const char *,
	    struct rtw_txsoft *, struct rtw_txdesc_blk *, int);
const char *rtw_access_string(enum rtw_access);
void	 rtw_dump_rings(struct rtw_softc *);
void	 rtw_print_txdesc(struct rtw_softc *, const char *,
	    struct rtw_txsoft *, struct rtw_txdesc_blk *, int);
#endif

struct cfdriver rtw_cd = {
	NULL, "rtw", DV_IFNET
};

void
rtw_continuous_tx_enable(struct rtw_softc *sc, int enable)
{
	struct rtw_regs *regs = &sc->sc_regs;

	u_int32_t tcr;
	tcr = RTW_READ(regs, RTW_TCR);
	tcr &= ~RTW_TCR_LBK_MASK;
	if (enable)
		tcr |= RTW_TCR_LBK_CONT;
	else
		tcr |= RTW_TCR_LBK_NORMAL;
	RTW_WRITE(regs, RTW_TCR, tcr);
	RTW_SYNC(regs, RTW_TCR, RTW_TCR);
	rtw_set_access(regs, RTW_ACCESS_ANAPARM);
	rtw_txdac_enable(sc, !enable);
	rtw_set_access(regs, RTW_ACCESS_ANAPARM);/* XXX Voodoo from Linux. */
	rtw_set_access(regs, RTW_ACCESS_NONE);
}

#ifdef RTW_DEBUG
const char *
rtw_access_string(enum rtw_access access)
{
	switch (access) {
	case RTW_ACCESS_NONE:
		return "none";
	case RTW_ACCESS_CONFIG:
		return "config";
	case RTW_ACCESS_ANAPARM:
		return "anaparm";
	default:
		return "unknown";
	}
}
#endif

void
rtw_set_access1(struct rtw_regs *regs, enum rtw_access naccess)
{
	KASSERT(naccess >= RTW_ACCESS_NONE && naccess <= RTW_ACCESS_ANAPARM);
	KASSERT(regs->r_access >= RTW_ACCESS_NONE &&
	    regs->r_access <= RTW_ACCESS_ANAPARM);

	if (naccess == regs->r_access)
		return;

	switch (naccess) {
	case RTW_ACCESS_NONE:
		switch (regs->r_access) {
		case RTW_ACCESS_ANAPARM:
			rtw_anaparm_enable(regs, 0);
			/*FALLTHROUGH*/
		case RTW_ACCESS_CONFIG:
			rtw_config0123_enable(regs, 0);
			/*FALLTHROUGH*/
		case RTW_ACCESS_NONE:
			break;
		}
		break;
	case RTW_ACCESS_CONFIG:
		switch (regs->r_access) {
		case RTW_ACCESS_NONE:
			rtw_config0123_enable(regs, 1);
			/*FALLTHROUGH*/
		case RTW_ACCESS_CONFIG:
			break;
		case RTW_ACCESS_ANAPARM:
			rtw_anaparm_enable(regs, 0);
			break;
		}
		break;
	case RTW_ACCESS_ANAPARM:
		switch (regs->r_access) {
		case RTW_ACCESS_NONE:
			rtw_config0123_enable(regs, 1);
			/*FALLTHROUGH*/
		case RTW_ACCESS_CONFIG:
			rtw_anaparm_enable(regs, 1);
			/*FALLTHROUGH*/
		case RTW_ACCESS_ANAPARM:
			break;
		}
		break;
	}
}

void
rtw_set_access(struct rtw_regs *regs, enum rtw_access access)
{
	rtw_set_access1(regs, access);
	RTW_DPRINTF(RTW_DEBUG_ACCESS,
	    ("%s: access %s -> %s\n",__func__,
	    rtw_access_string(regs->r_access),
	    rtw_access_string(access)));
	regs->r_access = access;
}

/*
 * Enable registers, switch register banks.
 */
void
rtw_config0123_enable(struct rtw_regs *regs, int enable)
{
	u_int8_t ecr;
	ecr = RTW_READ8(regs, RTW_9346CR);
	ecr &= ~(RTW_9346CR_EEM_MASK | RTW_9346CR_EECS | RTW_9346CR_EESK);
	if (enable)
		ecr |= RTW_9346CR_EEM_CONFIG;
	else {
		RTW_WBW(regs, RTW_9346CR, MAX(RTW_CONFIG0, RTW_CONFIG3));
		ecr |= RTW_9346CR_EEM_NORMAL;
	}
	RTW_WRITE8(regs, RTW_9346CR, ecr);
	RTW_SYNC(regs, RTW_9346CR, RTW_9346CR);
}

/* requires rtw_config0123_enable(, 1) */
void
rtw_anaparm_enable(struct rtw_regs *regs, int enable)
{
	u_int8_t cfg3;

	cfg3 = RTW_READ8(regs, RTW_CONFIG3);
	cfg3 |= RTW_CONFIG3_CLKRUNEN;
	if (enable)
		cfg3 |= RTW_CONFIG3_PARMEN;
	else
		cfg3 &= ~RTW_CONFIG3_PARMEN;
	RTW_WRITE8(regs, RTW_CONFIG3, cfg3);
	RTW_SYNC(regs, RTW_CONFIG3, RTW_CONFIG3);
}

/* requires rtw_anaparm_enable(, 1) */
void
rtw_txdac_enable(struct rtw_softc *sc, int enable)
{
	u_int32_t anaparm;
	struct rtw_regs *regs = &sc->sc_regs;

	anaparm = RTW_READ(regs, RTW_ANAPARM_0);
	if (enable)
		anaparm &= ~RTW_ANAPARM_TXDACOFF;
	else
		anaparm |= RTW_ANAPARM_TXDACOFF;
	RTW_WRITE(regs, RTW_ANAPARM_0, anaparm);
	RTW_SYNC(regs, RTW_ANAPARM_0, RTW_ANAPARM_0);
}

int
rtw_chip_reset1(struct rtw_regs *regs, const char *dvname)
{
	u_int8_t cr;
	int i;

	RTW_WRITE8(regs, RTW_CR, RTW_CR_RST);

	RTW_WBR(regs, RTW_CR, RTW_CR);

	for (i = 0; i < 1000; i++) {
		if ((cr = RTW_READ8(regs, RTW_CR) & RTW_CR_RST) == 0) {
			RTW_DPRINTF(RTW_DEBUG_RESET,
			    ("%s: reset in %dus\n", dvname, i));
			return 0;
		}
		RTW_RBR(regs, RTW_CR, RTW_CR);
		DELAY(10); /* 10us */
	}

	printf("\n%s: reset failed\n", dvname);
	return ETIMEDOUT;
}

int
rtw_chip_reset(struct rtw_regs *regs, const char *dvname)
{
	uint32_t tcr;

	/* from Linux driver */
	tcr = RTW_TCR_CWMIN | RTW_TCR_MXDMA_2048 |
	    LSHIFT(7, RTW_TCR_SRL_MASK) | LSHIFT(7, RTW_TCR_LRL_MASK);

	RTW_WRITE(regs, RTW_TCR, tcr);

	RTW_WBW(regs, RTW_CR, RTW_TCR);

	return rtw_chip_reset1(regs, dvname);
}

int
rtw_recall_eeprom(struct rtw_regs *regs, const char *dvname)
{
	int i;
	u_int8_t ecr;

	ecr = RTW_READ8(regs, RTW_9346CR);
	ecr = (ecr & ~RTW_9346CR_EEM_MASK) | RTW_9346CR_EEM_AUTOLOAD;
	RTW_WRITE8(regs, RTW_9346CR, ecr);

	RTW_WBR(regs, RTW_9346CR, RTW_9346CR);

	/* wait 10ms for completion */
	for (i = 0; i < 50; i++) {
		ecr = RTW_READ8(regs, RTW_9346CR);
		if ((ecr & RTW_9346CR_EEM_MASK) == RTW_9346CR_EEM_NORMAL) {
			RTW_DPRINTF(RTW_DEBUG_RESET,
			    ("%s: recall EEPROM in %dus\n", dvname, i * 200));
			return (0);
		}
		RTW_RBR(regs, RTW_9346CR, RTW_9346CR);
		DELAY(200);
	}

	printf("\n%s: could not recall EEPROM in %dus\n", dvname, i * 200);

	return (ETIMEDOUT);
}

int
rtw_reset(struct rtw_softc *sc)
{
	int rc;
	uint8_t config1;

	if ((rc = rtw_chip_reset(&sc->sc_regs, sc->sc_dev.dv_xname)) != 0)
		return rc;

	if ((rc = rtw_recall_eeprom(&sc->sc_regs, sc->sc_dev.dv_xname)) != 0)
		;

	config1 = RTW_READ8(&sc->sc_regs, RTW_CONFIG1);
	RTW_WRITE8(&sc->sc_regs, RTW_CONFIG1, config1 & ~RTW_CONFIG1_PMEN);
	/* TBD turn off maximum power saving? */

	return 0;
}

int
rtw_txdesc_dmamaps_create(bus_dma_tag_t dmat, struct rtw_txsoft *descs,
    u_int ndescs)
{
	int i, rc = 0;
	for (i = 0; i < ndescs; i++) {
		rc = bus_dmamap_create(dmat, MCLBYTES, RTW_MAXPKTSEGS, MCLBYTES,
		    0, 0, &descs[i].ts_dmamap);
		if (rc != 0)
			break;
	}
	return rc;
}

int
rtw_rxdesc_dmamaps_create(bus_dma_tag_t dmat, struct rtw_rxsoft *descs,
    u_int ndescs)
{
	int i, rc = 0;
	for (i = 0; i < ndescs; i++) {
		rc = bus_dmamap_create(dmat, MCLBYTES, 1, MCLBYTES, 0, 0,
		    &descs[i].rs_dmamap);
		if (rc != 0)
			break;
	}
	return rc;
}

void
rtw_rxdesc_dmamaps_destroy(bus_dma_tag_t dmat, struct rtw_rxsoft *descs,
    u_int ndescs)
{
	int i;
	for (i = 0; i < ndescs; i++) {
		if (descs[i].rs_dmamap != NULL)
			bus_dmamap_destroy(dmat, descs[i].rs_dmamap);
	}
}

void
rtw_txdesc_dmamaps_destroy(bus_dma_tag_t dmat, struct rtw_txsoft *descs,
    u_int ndescs)
{
	int i;
	for (i = 0; i < ndescs; i++) {
		if (descs[i].ts_dmamap != NULL)
			bus_dmamap_destroy(dmat, descs[i].ts_dmamap);
	}
}

int
rtw_srom_parse(struct rtw_softc *sc)
{
	int i;
	struct rtw_srom *sr = &sc->sc_srom;
	u_int32_t *flags = &sc->sc_flags;
	u_int8_t *cs_threshold = &sc->sc_csthr;
	int *rfchipid = &sc->sc_rfchipid;
	u_int32_t *rcr = &sc->sc_rcr;
	enum rtw_locale *locale = &sc->sc_locale;
	u_int16_t version;
	u_int8_t mac[IEEE80211_ADDR_LEN];

	*flags &= ~(RTW_F_DIGPHY|RTW_F_DFLANTB|RTW_F_ANTDIV);
	*rcr &= ~(RTW_RCR_ENCS1 | RTW_RCR_ENCS2);

	version = RTW_SR_GET16(sr, RTW_SR_VERSION);
	RTW_DPRINTF(RTW_DEBUG_ATTACH,
	    ("%s: SROM %d.%d\n", sc->sc_dev.dv_xname, version >> 8,
	    version & 0xff));

	if (version <= 0x0101) {
		printf(" is not understood, limping along with defaults ");
		*flags |= (RTW_F_DIGPHY|RTW_F_ANTDIV);
		*cs_threshold = RTW_SR_ENERGYDETTHR_DEFAULT;
		*rcr |= RTW_RCR_ENCS1;
		*rfchipid = RTW_RFCHIPID_PHILIPS;
		return 0;
	}

	for (i = 0; i < IEEE80211_ADDR_LEN; i++)
		mac[i] = RTW_SR_GET(sr, RTW_SR_MAC + i);

	RTW_DPRINTF(RTW_DEBUG_ATTACH,
	    ("%s: EEPROM MAC %s\n", sc->sc_dev.dv_xname, ether_sprintf(mac)));

	*cs_threshold = RTW_SR_GET(sr, RTW_SR_ENERGYDETTHR);

	if ((RTW_SR_GET(sr, RTW_SR_CONFIG2) & RTW8180_CONFIG2_ANT) != 0)
		*flags |= RTW_F_ANTDIV;

	/* Note well: the sense of the RTW_SR_RFPARM_DIGPHY bit seems
	 * to be reversed.
	 */
	if ((RTW_SR_GET(sr, RTW_SR_RFPARM) & RTW_SR_RFPARM_DIGPHY) == 0)
		*flags |= RTW_F_DIGPHY;
	if ((RTW_SR_GET(sr, RTW_SR_RFPARM) & RTW_SR_RFPARM_DFLANTB) != 0)
		*flags |= RTW_F_DFLANTB;

	*rcr |= LSHIFT(MASK_AND_RSHIFT(RTW_SR_GET(sr, RTW_SR_RFPARM),
	    RTW_SR_RFPARM_CS_MASK), RTW_RCR_ENCS1);

	*rfchipid = RTW_SR_GET(sr, RTW_SR_RFCHIPID);

	if (sc->sc_flags & RTW_F_RTL8185) {
		*locale = RTW_LOCALE_UNKNOWN;
		return (0);
	}

	switch (RTW_SR_GET(sr, RTW_SR_CONFIG0) & RTW8180_CONFIG0_GL_MASK) {
	case RTW8180_CONFIG0_GL_USA:
		*locale = RTW_LOCALE_USA;
		break;
	case RTW8180_CONFIG0_GL_EUROPE:
		*locale = RTW_LOCALE_EUROPE;
		break;
	case RTW8180_CONFIG0_GL_JAPAN:
	case RTW8180_CONFIG0_GL_JAPAN2:
		*locale = RTW_LOCALE_JAPAN;
		break;
	default:
		*locale = RTW_LOCALE_UNKNOWN;
		break;
	}
	return 0;
}

/* Returns -1 on failure. */
int
rtw_srom_read(struct rtw_regs *regs, u_int32_t flags, struct rtw_srom *sr,
    const char *dvname)
{
	int rc;
	struct seeprom_descriptor sd;
	u_int8_t ecr;

	bzero(&sd, sizeof(sd));

	ecr = RTW_READ8(regs, RTW_9346CR);

	if ((flags & RTW_F_9356SROM) != 0) {
		RTW_DPRINTF(RTW_DEBUG_ATTACH, ("%s: 93c56 SROM\n", dvname));
		sr->sr_size = 256;
		sd.sd_chip = C56_66;
	} else {
		RTW_DPRINTF(RTW_DEBUG_ATTACH, ("%s: 93c46 SROM\n", dvname));
		sr->sr_size = 128;
		sd.sd_chip = C46;
	}

	ecr &= ~(RTW_9346CR_EEDI | RTW_9346CR_EEDO | RTW_9346CR_EESK |
	    RTW_9346CR_EEM_MASK | RTW_9346CR_EECS);
	ecr |= RTW_9346CR_EEM_PROGRAM;

	RTW_WRITE8(regs, RTW_9346CR, ecr);

	sr->sr_content = malloc(sr->sr_size, M_DEVBUF, M_NOWAIT | M_ZERO);

	if (sr->sr_content == NULL) {
		printf("%s: unable to allocate SROM buffer\n", dvname);
		return ENOMEM;
	}

	/* RTL8180 has a single 8-bit register for controlling the
	 * 93cx6 SROM.  There is no "ready" bit. The RTL8180
	 * input/output sense is the reverse of read_seeprom's.
	 */
	sd.sd_tag = regs->r_bt;
	sd.sd_bsh = regs->r_bh;
	sd.sd_regsize = 1;
	sd.sd_control_offset = RTW_9346CR;
	sd.sd_status_offset = RTW_9346CR;
	sd.sd_dataout_offset = RTW_9346CR;
	sd.sd_CK = RTW_9346CR_EESK;
	sd.sd_CS = RTW_9346CR_EECS;
	sd.sd_DI = RTW_9346CR_EEDO;
	sd.sd_DO = RTW_9346CR_EEDI;
	/* make read_seeprom enter EEPROM read/write mode */ 
	sd.sd_MS = ecr;
	sd.sd_RDY = 0;

	/* TBD bus barriers */
	if (!read_seeprom(&sd, sr->sr_content, 0, sr->sr_size/2)) {
		printf("\n%s: could not read SROM\n", dvname);
		free(sr->sr_content, M_DEVBUF, 0);
		sr->sr_content = NULL;
		return -1;	/* XXX */
	}

	/* end EEPROM read/write mode */ 
	RTW_WRITE8(regs, RTW_9346CR,
	    (ecr & ~RTW_9346CR_EEM_MASK) | RTW_9346CR_EEM_NORMAL);
	RTW_WBRW(regs, RTW_9346CR, RTW_9346CR);

	if ((rc = rtw_recall_eeprom(regs, dvname)) != 0)
		return rc;

#ifdef RTW_DEBUG
	{
		int i;
		RTW_DPRINTF(RTW_DEBUG_ATTACH,
		    ("\n%s: serial ROM:\n\t", dvname));
		for (i = 0; i < sr->sr_size/2; i++) {
			if (((i % 8) == 0) && (i != 0))
				RTW_DPRINTF(RTW_DEBUG_ATTACH, ("\n\t"));
			RTW_DPRINTF(RTW_DEBUG_ATTACH,
			    (" %04x", sr->sr_content[i]));
		}
		RTW_DPRINTF(RTW_DEBUG_ATTACH, ("\n"));
	}
#endif /* RTW_DEBUG */
	return 0;
}

void
rtw_set_rfprog(struct rtw_regs *regs, int rfchipid,
    const char *dvname)
{
	u_int8_t cfg4;
	const char *method;

	cfg4 = RTW_READ8(regs, RTW_CONFIG4) & ~RTW_CONFIG4_RFTYPE_MASK;

	switch (rfchipid) {
	default:
		cfg4 |= LSHIFT(rtw_rfprog_fallback, RTW_CONFIG4_RFTYPE_MASK);
		method = "fallback";
		break;
	case RTW_RFCHIPID_INTERSIL:
		cfg4 |= RTW_CONFIG4_RFTYPE_INTERSIL;
		method = "Intersil";
		break;
	case RTW_RFCHIPID_PHILIPS:
		cfg4 |= RTW_CONFIG4_RFTYPE_PHILIPS;
		method = "Philips";
		break;
	case RTW_RFCHIPID_RFMD2948:
		cfg4 |= RTW_CONFIG4_RFTYPE_RFMD;
		method = "RFMD";
		break;
	}

	RTW_WRITE8(regs, RTW_CONFIG4, cfg4);

	RTW_WBR(regs, RTW_CONFIG4, RTW_CONFIG4);

	RTW_DPRINTF(RTW_DEBUG_INIT,
	    ("%s: %s RF programming method, %#02x\n", dvname, method,
	    RTW_READ8(regs, RTW_CONFIG4)));
}

void
rtw_identify_country(struct rtw_regs *regs, enum rtw_locale *locale)
{
	u_int8_t cfg0 = RTW_READ8(regs, RTW_CONFIG0);

	switch (cfg0 & RTW8180_CONFIG0_GL_MASK) {
	case RTW8180_CONFIG0_GL_USA:
		*locale = RTW_LOCALE_USA;
		break;
	case RTW8180_CONFIG0_GL_JAPAN:
	case RTW8180_CONFIG0_GL_JAPAN2:
		*locale = RTW_LOCALE_JAPAN;
		break;
	case RTW8180_CONFIG0_GL_EUROPE:
		*locale = RTW_LOCALE_EUROPE;
		break;
	default:
		*locale = RTW_LOCALE_UNKNOWN;
		break;
	}
}

int
rtw_identify_sta(struct rtw_regs *regs, u_int8_t (*addr)[IEEE80211_ADDR_LEN],
    const char *dvname)
{
	static const u_int8_t empty_macaddr[IEEE80211_ADDR_LEN] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	u_int32_t idr0 = RTW_READ(regs, RTW_IDR0),
	    idr1 = RTW_READ(regs, RTW_IDR1);

	(*addr)[0] = MASK_AND_RSHIFT(idr0, 0xff);
	(*addr)[1] = MASK_AND_RSHIFT(idr0, 0xff00);
	(*addr)[2] = MASK_AND_RSHIFT(idr0, 0xff0000);
	(*addr)[3] = MASK_AND_RSHIFT(idr0, 0xff000000);

	(*addr)[4] = MASK_AND_RSHIFT(idr1, 0xff);
	(*addr)[5] = MASK_AND_RSHIFT(idr1, 0xff00);

	if (IEEE80211_ADDR_EQ(addr, empty_macaddr)) {
		printf("\n%s: could not get mac address, attach failed\n",
		    dvname);
		return ENXIO;
	}

	printf("address %s\n", ether_sprintf(*addr));

	return 0;
}

u_int8_t
rtw_chan2txpower(struct rtw_srom *sr, struct ieee80211com *ic,
    struct ieee80211_channel *chan)
{
	u_int idx = RTW_SR_TXPOWER1 + ieee80211_chan2ieee(ic, chan) - 1;
	KASSERT2(idx >= RTW_SR_TXPOWER1 && idx <= RTW_SR_TXPOWER14,
	    ("%s: channel %d out of range", __func__,
	     idx - RTW_SR_TXPOWER1 + 1));
	return RTW_SR_GET(sr, idx);
}

void
rtw_txdesc_blk_init_all(struct rtw_txdesc_blk *tdb)
{
	int pri;
	/* nfree: the number of free descriptors in each ring.
	 * The beacon ring is a special case: I do not let the
	 * driver use all of the descriptors on the beacon ring.
	 * The reasons are two-fold:
	 *
	 * (1) A BEACON descriptor's OWN bit is (apparently) not
	 * updated, so the driver cannot easily know if the descriptor
	 * belongs to it, or if it is racing the NIC.  If the NIC
	 * does not OWN every descriptor, then the driver can safely
	 * update the descriptors when RTW_TBDA points at tdb_next.
	 *
	 * (2) I hope that the NIC will process more than one BEACON
	 * descriptor in a single beacon interval, since that will
	 * enable multiple-BSS support.  Since the NIC does not
	 * clear the OWN bit, there is no natural place for it to
	 * stop processing BEACON desciptors.  Maybe it will *not*
	 * stop processing them!  I do not want to chance the NIC
	 * looping around and around a saturated beacon ring, so
	 * I will leave one descriptor unOWNed at all times.
	 */
	u_int nfree[RTW_NTXPRI] =
	    {RTW_NTXDESCLO, RTW_NTXDESCMD, RTW_NTXDESCHI,
	     RTW_NTXDESCBCN - 1};

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		tdb[pri].tdb_nfree = nfree[pri];
		tdb[pri].tdb_next = 0;
	}
}

int
rtw_txsoft_blk_init(struct rtw_txsoft_blk *tsb)
{
	int i;
	struct rtw_txsoft *ts;

	SIMPLEQ_INIT(&tsb->tsb_dirtyq);
	SIMPLEQ_INIT(&tsb->tsb_freeq);
	for (i = 0; i < tsb->tsb_ndesc; i++) {
		ts = &tsb->tsb_desc[i];
		ts->ts_mbuf = NULL;
		SIMPLEQ_INSERT_TAIL(&tsb->tsb_freeq, ts, ts_q);
	}
	tsb->tsb_tx_timer = 0;
	return 0;
}

void
rtw_txsoft_blk_init_all(struct rtw_txsoft_blk *tsb)
{
	int pri;
	for (pri = 0; pri < RTW_NTXPRI; pri++)
		rtw_txsoft_blk_init(&tsb[pri]);
}

void
rtw_rxdescs_sync(struct rtw_rxdesc_blk *rdb, int desc0, int nsync, int ops)
{
	KASSERT(nsync <= rdb->rdb_ndesc);
	/* sync to end of ring */
	if (desc0 + nsync > rdb->rdb_ndesc) {
		bus_dmamap_sync(rdb->rdb_dmat, rdb->rdb_dmamap,
		    offsetof(struct rtw_descs, hd_rx[desc0]),
		    sizeof(struct rtw_rxdesc) * (rdb->rdb_ndesc - desc0), ops);
		nsync -= (rdb->rdb_ndesc - desc0);
		desc0 = 0;
	}

	KASSERT(desc0 < rdb->rdb_ndesc);
	KASSERT(nsync <= rdb->rdb_ndesc);
	KASSERT(desc0 + nsync <= rdb->rdb_ndesc);

	/* sync what remains */
	bus_dmamap_sync(rdb->rdb_dmat, rdb->rdb_dmamap,
	    offsetof(struct rtw_descs, hd_rx[desc0]),
	    sizeof(struct rtw_rxdesc) * nsync, ops);
}

void
rtw_txdescs_sync(struct rtw_txdesc_blk *tdb, u_int desc0, u_int nsync, int ops)
{
	/* sync to end of ring */
	if (desc0 + nsync > tdb->tdb_ndesc) {
		bus_dmamap_sync(tdb->tdb_dmat, tdb->tdb_dmamap,
		    tdb->tdb_ofs + sizeof(struct rtw_txdesc) * desc0,
		    sizeof(struct rtw_txdesc) * (tdb->tdb_ndesc - desc0),
		    ops);
		nsync -= (tdb->tdb_ndesc - desc0);
		desc0 = 0;
	}

	/* sync what remains */
	bus_dmamap_sync(tdb->tdb_dmat, tdb->tdb_dmamap,
	    tdb->tdb_ofs + sizeof(struct rtw_txdesc) * desc0,
	    sizeof(struct rtw_txdesc) * nsync, ops);
}

void
rtw_rxbufs_release(bus_dma_tag_t dmat, struct rtw_rxsoft *desc)
{
	int i;
	struct rtw_rxsoft *rs;

	for (i = 0; i < RTW_RXQLEN; i++) {
		rs = &desc[i];
		if (rs->rs_mbuf == NULL)
			continue;
		bus_dmamap_sync(dmat, rs->rs_dmamap, 0,
		    rs->rs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(dmat, rs->rs_dmamap);
		m_freem(rs->rs_mbuf);
		rs->rs_mbuf = NULL;
	}
}

int
rtw_rxsoft_alloc(bus_dma_tag_t dmat, struct rtw_rxsoft *rs)
{
	int rc;
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return ENOBUFS;

	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return ENOBUFS;
	}

	m->m_pkthdr.len = m->m_len = m->m_ext.ext_size;

	if (rs->rs_mbuf != NULL)
		bus_dmamap_unload(dmat, rs->rs_dmamap);

	rs->rs_mbuf = NULL;

	rc = bus_dmamap_load_mbuf(dmat, rs->rs_dmamap, m, BUS_DMA_NOWAIT);
	if (rc != 0) {
		m_freem(m);
		return -1;
	}

	rs->rs_mbuf = m;

	return 0;
}

int
rtw_rxsoft_init_all(bus_dma_tag_t dmat, struct rtw_rxsoft *desc,
    int *ndesc, const char *dvname)
{
	int i, rc = 0;
	struct rtw_rxsoft *rs;

	for (i = 0; i < RTW_RXQLEN; i++) {
		rs = &desc[i];
		/* we're in rtw_init, so there should be no mbufs allocated */
		KASSERT(rs->rs_mbuf == NULL);
#ifdef RTW_DEBUG
		if (i == rtw_rxbufs_limit) {
			printf("%s: TEST hit %d-buffer limit\n", dvname, i);
			rc = ENOBUFS;
			break;
		}
#endif /* RTW_DEBUG */
		if ((rc = rtw_rxsoft_alloc(dmat, rs)) != 0) {
			printf("%s: rtw_rxsoft_alloc failed, %d buffers, "
			    "rc %d\n", dvname, i, rc);
			break;
		}
	}
	*ndesc = i;
	return rc;
}

void
rtw_rxdesc_init(struct rtw_rxdesc_blk *rdb, struct rtw_rxsoft *rs,
    int idx, int kick)
{
	int is_last = (idx == rdb->rdb_ndesc - 1);
	uint32_t ctl, octl, obuf;
	struct rtw_rxdesc *rd = &rdb->rdb_desc[idx];

	obuf = rd->rd_buf;
	rd->rd_buf = htole32(rs->rs_dmamap->dm_segs[0].ds_addr);

	ctl = LSHIFT(rs->rs_mbuf->m_len, RTW_RXCTL_LENGTH_MASK) |
	    RTW_RXCTL_OWN | RTW_RXCTL_FS | RTW_RXCTL_LS;

	if (is_last)
		ctl |= RTW_RXCTL_EOR;

	octl = rd->rd_ctl;
	rd->rd_ctl = htole32(ctl);

	RTW_DPRINTF(kick ? (RTW_DEBUG_RECV_DESC | RTW_DEBUG_IO_KICK)
	    : RTW_DEBUG_RECV_DESC,
	    ("%s: rd %p buf %08x -> %08x ctl %08x -> %08x\n", __func__, rd,
	    letoh32(obuf), letoh32(rd->rd_buf), letoh32(octl),
	    letoh32(rd->rd_ctl)));

	/* sync the mbuf */
	bus_dmamap_sync(rdb->rdb_dmat, rs->rs_dmamap, 0,
	    rs->rs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	/* sync the descriptor */
	bus_dmamap_sync(rdb->rdb_dmat, rdb->rdb_dmamap,
	    RTW_DESC_OFFSET(hd_rx, idx), sizeof(struct rtw_rxdesc),
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
}

void
rtw_rxdesc_init_all(struct rtw_rxdesc_blk *rdb, struct rtw_rxsoft *ctl,
    int kick)
{
	int i;
	struct rtw_rxsoft *rs;

	for (i = 0; i < rdb->rdb_ndesc; i++) {
		rs = &ctl[i];
		rtw_rxdesc_init(rdb, rs, i, kick);
	}
}

void
rtw_io_enable(struct rtw_regs *regs, u_int8_t flags, int enable)
{
	u_int8_t cr;

	RTW_DPRINTF(RTW_DEBUG_IOSTATE, ("%s: %s 0x%02x\n", __func__,
	    enable ? "enable" : "disable", flags));

	cr = RTW_READ8(regs, RTW_CR);

	/* XXX reference source does not enable MULRW */
#if 0
	/* enable PCI Read/Write Multiple */
	cr |= RTW_CR_MULRW;
#endif

	RTW_RBW(regs, RTW_CR, RTW_CR);	/* XXX paranoia? */
	if (enable)
		cr |= flags;
	else
		cr &= ~flags;
	RTW_WRITE8(regs, RTW_CR, cr);
	RTW_SYNC(regs, RTW_CR, RTW_CR);
}

void
rtw_intr_rx(struct rtw_softc *sc, u_int16_t isr)
{
#define	IS_BEACON(__fc0)						\
    ((__fc0 & (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==\
     (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_BEACON))

	static const int ratetbl[4] = {2, 4, 11, 22};	/* convert rates:
							 * hardware -> net80211
							 */
	u_int next, nproc = 0;
	int hwrate, len, rate, rssi, sq;
	u_int32_t hrssi, hstat, htsfth, htsftl;
	struct rtw_rxdesc *rd;
	struct rtw_rxsoft *rs;
	struct rtw_rxdesc_blk *rdb;
	struct mbuf *m;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct ieee80211_frame *wh;

	rdb = &sc->sc_rxdesc_blk;

	KASSERT(rdb->rdb_next < rdb->rdb_ndesc);

	for (next = rdb->rdb_next; ; next = (next + 1) % rdb->rdb_ndesc) {
		rtw_rxdescs_sync(rdb, next, 1,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		rd = &rdb->rdb_desc[next];
		rs = &sc->sc_rxsoft[next];

		hstat = letoh32(rd->rd_stat);
		hrssi = letoh32(rd->rd_rssi);
		htsfth = letoh32(rd->rd_tsfth);
		htsftl = letoh32(rd->rd_tsftl);

		RTW_DPRINTF(RTW_DEBUG_RECV_DESC,
		    ("%s: rxdesc[%d] hstat %08x hrssi %08x htsft %08x%08x\n",
		    __func__, next, hstat, hrssi, htsfth, htsftl));

		++nproc;

		/* still belongs to NIC */
		if ((hstat & RTW_RXSTAT_OWN) != 0) {
			if (nproc > 1)
				break;

			/* sometimes the NIC skips to the 0th descriptor */
			rtw_rxdescs_sync(rdb, 0, 1,
			    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
			rd = &rdb->rdb_desc[0];
			if ((rd->rd_stat & htole32(RTW_RXSTAT_OWN)) != 0)
				break;
			RTW_DPRINTF(RTW_DEBUG_BUGS,
			    ("%s: NIC skipped from rxdesc[%u] to rxdesc[0]\n",
			     sc->sc_dev.dv_xname, next));
			next = rdb->rdb_ndesc - 1;
			continue;
		}

#ifdef RTW_DEBUG
#define PRINTSTAT(flag) do { \
	if ((hstat & flag) != 0) { \
		printf("%s" #flag, delim); \
		delim = ","; \
	} \
} while (0)
		if ((rtw_debug & RTW_DEBUG_RECV_DESC) != 0) {
			const char *delim = "<";
			printf("%s: ", sc->sc_dev.dv_xname);
			if ((hstat & RTW_RXSTAT_DEBUG) != 0) {
				printf("status %08x", hstat);
				PRINTSTAT(RTW_RXSTAT_SPLCP);
				PRINTSTAT(RTW_RXSTAT_MAR);
				PRINTSTAT(RTW_RXSTAT_PAR);
				PRINTSTAT(RTW_RXSTAT_BAR);
				PRINTSTAT(RTW_RXSTAT_PWRMGT);
				PRINTSTAT(RTW_RXSTAT_CRC32);
				PRINTSTAT(RTW_RXSTAT_ICV);
				printf(">, ");
			}
		}
#undef PRINTSTAT
#endif /* RTW_DEBUG */

		if ((hstat & RTW_RXSTAT_IOERROR) != 0) {
			printf("%s: DMA error/FIFO overflow %08x, "
			    "rx descriptor %d\n", sc->sc_dev.dv_xname,
			    hstat & RTW_RXSTAT_IOERROR, next);
			sc->sc_if.if_ierrors++;
			goto next;
		}

		len = MASK_AND_RSHIFT(hstat, RTW_RXSTAT_LENGTH_MASK);
		if (len < IEEE80211_MIN_LEN) {
			sc->sc_ic.ic_stats.is_rx_tooshort++;
			goto next;
		}

		/* CRC is included with the packet; trim it off. */
		len -= IEEE80211_CRC_LEN;

		hwrate = MASK_AND_RSHIFT(hstat, RTW_RXSTAT_RATE_MASK);
		if (hwrate >= sizeof(ratetbl) / sizeof(ratetbl[0])) {
			printf("%s: unknown rate #%d\n", sc->sc_dev.dv_xname,
			    MASK_AND_RSHIFT(hstat, RTW_RXSTAT_RATE_MASK));
			sc->sc_if.if_ierrors++;
			goto next;
		}
		rate = ratetbl[hwrate];

#ifdef RTW_DEBUG
		RTW_DPRINTF(RTW_DEBUG_RECV_DESC,
		    ("rate %d.%d Mb/s, time %08x%08x\n", (rate * 5) / 10,
		     (rate * 5) % 10, htsfth, htsftl));
#endif /* RTW_DEBUG */

		if ((hstat & RTW_RXSTAT_RES) != 0 &&
		    sc->sc_ic.ic_opmode != IEEE80211_M_MONITOR)
			goto next;

		/* if bad flags, skip descriptor */
		if ((hstat & RTW_RXSTAT_ONESEG) != RTW_RXSTAT_ONESEG) {
			printf("%s: too many rx segments\n",
			    sc->sc_dev.dv_xname);
			goto next;
		}

		bus_dmamap_sync(sc->sc_dmat, rs->rs_dmamap, 0,
		    rs->rs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);

		m = rs->rs_mbuf;

		/* if temporarily out of memory, re-use mbuf */
		switch (rtw_rxsoft_alloc(sc->sc_dmat, rs)) {
		case 0:
			break;
		case ENOBUFS:
			printf("%s: rtw_rxsoft_alloc(, %d) failed, "
			    "dropping this packet\n", sc->sc_dev.dv_xname,
			    next);
			goto next;
		default:
			/* XXX shorten rx ring, instead? */
			panic("%s: could not load DMA map",
			    sc->sc_dev.dv_xname);
		}

		if (sc->sc_rfchipid == RTW_RFCHIPID_PHILIPS)
			rssi = MASK_AND_RSHIFT(hrssi, RTW_RXRSSI_RSSI);
		else {
			rssi = MASK_AND_RSHIFT(hrssi, RTW_RXRSSI_IMR_RSSI);
			/* TBD find out each front-end's LNA gain in the
			 * front-end's units
			 */
			if ((hrssi & RTW_RXRSSI_IMR_LNA) == 0)
				rssi |= 0x80;
		}

		sq = MASK_AND_RSHIFT(hrssi, RTW_RXRSSI_SQ);

		/*
		 * Note well: now we cannot recycle the rs_mbuf unless
		 * we restore its original length.
		 */
		m->m_pkthdr.len = m->m_len = len;

		wh = mtod(m, struct ieee80211_frame *);

		if (!IS_BEACON(wh->i_fc[0]))
			sc->sc_led_state.ls_event |= RTW_LED_S_RX;
		/* TBD use _MAR, _BAR, _PAR flags as hints to _find_rxnode? */
		ni = ieee80211_find_rxnode(&sc->sc_ic, wh);

		sc->sc_tsfth = htsfth;

#ifdef RTW_DEBUG
		if ((sc->sc_if.if_flags & (IFF_DEBUG|IFF_LINK2)) ==
		    (IFF_DEBUG|IFF_LINK2)) {
			ieee80211_dump_pkt(mtod(m, uint8_t *), m->m_pkthdr.len,
			    rate, rssi);
		}
#endif /* RTW_DEBUG */

#if NBPFILTER > 0
		if (sc->sc_radiobpf != NULL) {
			struct mbuf mb;
			struct ieee80211com *ic = &sc->sc_ic;
			struct rtw_rx_radiotap_header *rr = &sc->sc_rxtap;

			rr->rr_tsft =
			    htole64(((uint64_t)htsfth << 32) | htsftl);

			rr->rr_flags = 0;
			if ((hstat & RTW_RXSTAT_SPLCP) != 0)
				rr->rr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;

			rr->rr_rate = rate;
			rr->rr_chan_freq =
			    htole16(ic->ic_bss->ni_chan->ic_freq);
			rr->rr_chan_flags =
			    htole16(ic->ic_bss->ni_chan->ic_flags);
			rr->rr_antsignal = rssi;
			rr->rr_barker_lock = htole16(sq);

			mb.m_data = (caddr_t)rr;
			mb.m_len = sizeof(sc->sc_rxtapu);
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_radiobpf, &mb, BPF_DIRECTION_IN);
		}
#endif /* NBPFILTER > 0 */

		rxi.rxi_flags = 0;
		rxi.rxi_rssi = rssi;
		rxi.rxi_tstamp = htsftl;
		ieee80211_input(&sc->sc_if, m, ni, &rxi);
		ieee80211_release_node(&sc->sc_ic, ni);
next:
		rtw_rxdesc_init(rdb, rs, next, 0);
	}
	rdb->rdb_next = next;

	KASSERT(rdb->rdb_next < rdb->rdb_ndesc);

	return;
#undef IS_BEACON
}

void
rtw_txsoft_release(bus_dma_tag_t dmat, struct ieee80211com *ic,
    struct rtw_txsoft *ts)
{
	struct mbuf *m;
	struct ieee80211_node *ni;

	m = ts->ts_mbuf;
	ni = ts->ts_ni;
	KASSERT(m != NULL);
	KASSERT(ni != NULL);
	ts->ts_mbuf = NULL;
	ts->ts_ni = NULL;

	bus_dmamap_sync(dmat, ts->ts_dmamap, 0, ts->ts_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(dmat, ts->ts_dmamap);
	m_freem(m);
	ieee80211_release_node(ic, ni);
}

void
rtw_txsofts_release(bus_dma_tag_t dmat, struct ieee80211com *ic,
    struct rtw_txsoft_blk *tsb)
{
	struct rtw_txsoft *ts;

	while ((ts = SIMPLEQ_FIRST(&tsb->tsb_dirtyq)) != NULL) {
		rtw_txsoft_release(dmat, ic, ts);
		SIMPLEQ_REMOVE_HEAD(&tsb->tsb_dirtyq, ts_q);
		SIMPLEQ_INSERT_TAIL(&tsb->tsb_freeq, ts, ts_q);
	}
	tsb->tsb_tx_timer = 0;
}

void
rtw_collect_txpkt(struct rtw_softc *sc, struct rtw_txdesc_blk *tdb,
    struct rtw_txsoft *ts, int ndesc)
{
	uint32_t hstat;
	int data_retry, rts_retry;
	struct rtw_txdesc *tdn;
	const char *condstring;

	rtw_txsoft_release(sc->sc_dmat, &sc->sc_ic, ts);

	tdb->tdb_nfree += ndesc;

	tdn = &tdb->tdb_desc[ts->ts_last];

	hstat = letoh32(tdn->td_stat);
	rts_retry = MASK_AND_RSHIFT(hstat, RTW_TXSTAT_RTSRETRY_MASK);
	data_retry = MASK_AND_RSHIFT(hstat, RTW_TXSTAT_DRC_MASK);

	sc->sc_if.if_collisions += rts_retry + data_retry;

	if ((hstat & RTW_TXSTAT_TOK) != 0)
		condstring = "ok";
	else {
		sc->sc_if.if_oerrors++;
		condstring = "error";
	}

	DPRINTF(sc, RTW_DEBUG_XMIT_DESC,
	    ("%s: ts %p txdesc[%d, %d] %s tries rts %u data %u\n",
	    sc->sc_dev.dv_xname, ts, ts->ts_first, ts->ts_last,
	    condstring, rts_retry, data_retry));
}

void
rtw_reset_oactive(struct rtw_softc *sc)
{
	int oactive;
	int pri;
	struct rtw_txsoft_blk *tsb;
	struct rtw_txdesc_blk *tdb;
	oactive = ifq_is_oactive(&sc->sc_if.if_snd);
	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		tsb = &sc->sc_txsoft_blk[pri];
		tdb = &sc->sc_txdesc_blk[pri];
		if (!SIMPLEQ_EMPTY(&tsb->tsb_freeq) && tdb->tdb_nfree > 0)
			ifq_set_oactive(&sc->sc_if.if_snd);
	}
	if (oactive != ifq_is_oactive(&sc->sc_if.if_snd)) {
		DPRINTF(sc, RTW_DEBUG_OACTIVE,
		    ("%s: reset OACTIVE\n", __func__));
	}
}

/* Collect transmitted packets. */
void
rtw_collect_txring(struct rtw_softc *sc, struct rtw_txsoft_blk *tsb,
    struct rtw_txdesc_blk *tdb, int force)
{
	int ndesc;
	struct rtw_txsoft *ts;

	while ((ts = SIMPLEQ_FIRST(&tsb->tsb_dirtyq)) != NULL) {
		ndesc = 1 + ts->ts_last - ts->ts_first;
		if (ts->ts_last < ts->ts_first)
			ndesc += tdb->tdb_ndesc;

		KASSERT(ndesc > 0);

		rtw_txdescs_sync(tdb, ts->ts_first, ndesc,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		if (force) {
			int i;
			for (i = ts->ts_first; ; i = RTW_NEXT_IDX(tdb, i)) {
				tdb->tdb_desc[i].td_stat &=
				    ~htole32(RTW_TXSTAT_OWN);
				if (i == ts->ts_last)
					break;
			}
			rtw_txdescs_sync(tdb, ts->ts_first, ndesc,
			    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
		} else if ((tdb->tdb_desc[ts->ts_last].td_stat &
		    htole32(RTW_TXSTAT_OWN)) != 0)
			break;

		rtw_collect_txpkt(sc, tdb, ts, ndesc);
		SIMPLEQ_REMOVE_HEAD(&tsb->tsb_dirtyq, ts_q);
		SIMPLEQ_INSERT_TAIL(&tsb->tsb_freeq, ts, ts_q);
	}
	/* no more pending transmissions, cancel watchdog */
	if (ts == NULL)
		tsb->tsb_tx_timer = 0;
	rtw_reset_oactive(sc);
}

void
rtw_intr_tx(struct rtw_softc *sc, u_int16_t isr)
{
	int pri;
	struct rtw_txsoft_blk	*tsb;
	struct rtw_txdesc_blk	*tdb;

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		tsb = &sc->sc_txsoft_blk[pri];
		tdb = &sc->sc_txdesc_blk[pri];

		rtw_collect_txring(sc, tsb, tdb, 0);

	}

	if ((isr & RTW_INTR_TX) != 0)
		rtw_start(&sc->sc_if);
}

#ifndef IEEE80211_STA_ONLY
void
rtw_intr_beacon(struct rtw_softc *sc, u_int16_t isr)
{
	u_int next;
	uint32_t tsfth, tsftl;
	struct ieee80211com *ic;
	struct rtw_txdesc_blk *tdb = &sc->sc_txdesc_blk[RTW_TXPRIBCN];
	struct rtw_txsoft_blk *tsb = &sc->sc_txsoft_blk[RTW_TXPRIBCN];
	struct mbuf *m;

	tsfth = RTW_READ(&sc->sc_regs, RTW_TSFTRH);
	tsftl = RTW_READ(&sc->sc_regs, RTW_TSFTRL);

	if ((isr & (RTW_INTR_TBDOK|RTW_INTR_TBDER)) != 0) {
		next = rtw_txring_next(&sc->sc_regs, tdb);
		RTW_DPRINTF(RTW_DEBUG_BEACON,
		    ("%s: beacon ring %sprocessed, isr = %#04hx"
		     ", next %u expected %u, %llu\n", __func__,
		     (next == tdb->tdb_next) ? "" : "un", isr, next,
		     tdb->tdb_next, (uint64_t)tsfth << 32 | tsftl));
		if ((RTW_READ8(&sc->sc_regs, RTW_TPPOLL) & RTW_TPPOLL_BQ) == 0){
			rtw_collect_txring(sc, tsb, tdb, 1);
			tdb->tdb_next = 0;
		}
	}
	/* Start beacon transmission. */

	if ((isr & RTW_INTR_BCNINT) != 0 &&
	    sc->sc_ic.ic_state == IEEE80211_S_RUN &&
	    SIMPLEQ_EMPTY(&tsb->tsb_dirtyq)) {
		RTW_DPRINTF(RTW_DEBUG_BEACON,
		    ("%s: beacon prep. time, isr = %#04hx"
		     ", %16llu\n", __func__, isr,
		     (uint64_t)tsfth << 32 | tsftl));
		ic = &sc->sc_ic;
		if ((m = ieee80211_beacon_alloc(ic, ic->ic_bss)) != NULL) {
			RTW_DPRINTF(RTW_DEBUG_BEACON,
			    ("%s: m %p len %u\n", __func__, m, m->m_len));
		}

		if (m == NULL) {
			printf("%s: could not allocate beacon\n",
			    sc->sc_dev.dv_xname);
			return;
		}
		m->m_pkthdr.ph_cookie = ieee80211_ref_node(ic->ic_bss);
		mq_enqueue(&sc->sc_beaconq, m);
		rtw_start(&sc->sc_if);
	}
}

void
rtw_intr_atim(struct rtw_softc *sc)
{
	/* TBD */
	return;
}
#endif	/* IEEE80211_STA_ONLY */

#ifdef RTW_DEBUG
void
rtw_dump_rings(struct rtw_softc *sc)
{
	struct rtw_txdesc_blk *tdb;
	struct rtw_rxdesc *rd;
	struct rtw_rxdesc_blk *rdb;
	int desc, pri;

	if ((rtw_debug & RTW_DEBUG_IO_KICK) == 0)
		return;

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		tdb = &sc->sc_txdesc_blk[pri];
		printf("%s: txpri %d ndesc %d nfree %d\n", __func__, pri,
		    tdb->tdb_ndesc, tdb->tdb_nfree);
		for (desc = 0; desc < tdb->tdb_ndesc; desc++)
			rtw_print_txdesc(sc, ".", NULL, tdb, desc);
	}

	rdb = &sc->sc_rxdesc_blk;

	for (desc = 0; desc < RTW_RXQLEN; desc++) {
		rd = &rdb->rdb_desc[desc];
		printf("%s: %sctl %08x rsvd0/rssi %08x buf/tsftl %08x "
		    "rsvd1/tsfth %08x\n", __func__,
		    (desc >= rdb->rdb_ndesc) ? "UNUSED " : "",
		    letoh32(rd->rd_ctl), letoh32(rd->rd_rssi),
		    letoh32(rd->rd_buf), letoh32(rd->rd_tsfth));
	}
}
#endif /* RTW_DEBUG */

void
rtw_hwring_setup(struct rtw_softc *sc)
{
	int pri;
	struct rtw_regs *regs = &sc->sc_regs;
	struct rtw_txdesc_blk *tdb;

	sc->sc_txdesc_blk[RTW_TXPRILO].tdb_basereg = RTW_TLPDA;
	sc->sc_txdesc_blk[RTW_TXPRILO].tdb_base = RTW_RING_BASE(sc, hd_txlo);
	sc->sc_txdesc_blk[RTW_TXPRIMD].tdb_basereg = RTW_TNPDA;
	sc->sc_txdesc_blk[RTW_TXPRIMD].tdb_base = RTW_RING_BASE(sc, hd_txmd);
	sc->sc_txdesc_blk[RTW_TXPRIHI].tdb_basereg = RTW_THPDA;
	sc->sc_txdesc_blk[RTW_TXPRIHI].tdb_base = RTW_RING_BASE(sc, hd_txhi);
	sc->sc_txdesc_blk[RTW_TXPRIBCN].tdb_basereg = RTW_TBDA;
	sc->sc_txdesc_blk[RTW_TXPRIBCN].tdb_base = RTW_RING_BASE(sc, hd_bcn);

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		tdb = &sc->sc_txdesc_blk[pri];
		RTW_WRITE(regs, tdb->tdb_basereg, tdb->tdb_base);
		RTW_DPRINTF(RTW_DEBUG_XMIT_DESC,
		    ("%s: reg[tdb->tdb_basereg] <- %lx\n", __func__,
		     (u_int *)tdb->tdb_base));
	}

	RTW_WRITE(regs, RTW_RDSAR, RTW_RING_BASE(sc, hd_rx));

	RTW_DPRINTF(RTW_DEBUG_RECV_DESC,
	    ("%s: reg[RDSAR] <- %lx\n", __func__,
	     (u_int *)RTW_RING_BASE(sc, hd_rx)));

	RTW_SYNC(regs, RTW_TLPDA, RTW_RDSAR);
}

int
rtw_swring_setup(struct rtw_softc *sc)
{
	int rc, pri;
	struct rtw_rxdesc_blk *rdb;
	struct rtw_txdesc_blk *tdb;

	rtw_txdesc_blk_init_all(&sc->sc_txdesc_blk[0]);

	rtw_txsoft_blk_init_all(&sc->sc_txsoft_blk[0]);

	rdb = &sc->sc_rxdesc_blk;
	if ((rc = rtw_rxsoft_init_all(sc->sc_dmat, sc->sc_rxsoft,
	    &rdb->rdb_ndesc, sc->sc_dev.dv_xname)) != 0 &&
	    rdb->rdb_ndesc == 0) {
		printf("%s: could not allocate rx buffers\n",
		    sc->sc_dev.dv_xname);
		return rc;
	}

	rdb = &sc->sc_rxdesc_blk;
	rtw_rxdescs_sync(rdb, 0, rdb->rdb_ndesc,
	    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	rtw_rxdesc_init_all(rdb, sc->sc_rxsoft, 1);
	rdb->rdb_next = 0;

	tdb = &sc->sc_txdesc_blk[0];
	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		rtw_txdescs_sync(&tdb[pri], 0, tdb[pri].tdb_ndesc,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	}
	return 0;
}

void
rtw_txdesc_blk_init(struct rtw_txdesc_blk *tdb)
{
	int i;

	bzero(tdb->tdb_desc, sizeof(tdb->tdb_desc[0]) * tdb->tdb_ndesc);
	for (i = 0; i < tdb->tdb_ndesc; i++)
		tdb->tdb_desc[i].td_next = htole32(RTW_NEXT_DESC(tdb, i));
}

u_int
rtw_txring_next(struct rtw_regs *regs, struct rtw_txdesc_blk *tdb)
{
	return (letoh32(RTW_READ(regs, tdb->tdb_basereg)) - tdb->tdb_base) /
	    sizeof(struct rtw_txdesc);
}

void
rtw_txring_fixup(struct rtw_softc *sc)
{
	int pri;
	u_int next;
	struct rtw_txdesc_blk *tdb;
	struct rtw_regs *regs = &sc->sc_regs;

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		tdb = &sc->sc_txdesc_blk[pri];
		next = rtw_txring_next(regs, tdb);
		if (tdb->tdb_next == next)
			continue;
		RTW_DPRINTF(RTW_DEBUG_BUGS,
		    ("%s: tx-ring %d expected next %u, read %u\n", __func__,
		    pri, tdb->tdb_next, next));
		tdb->tdb_next = MIN(next, tdb->tdb_ndesc - 1);
	}
}

void
rtw_rxring_fixup(struct rtw_softc *sc)
{
	u_int next;
	uint32_t rdsar;
	struct rtw_rxdesc_blk *rdb;

	rdsar = letoh32(RTW_READ(&sc->sc_regs, RTW_RDSAR));
	next = (rdsar - RTW_RING_BASE(sc, hd_rx)) / sizeof(struct rtw_rxdesc);

	rdb = &sc->sc_rxdesc_blk;
	if (rdb->rdb_next != next) {
		RTW_DPRINTF(RTW_DEBUG_BUGS,
		    ("%s: rx-ring expected next %u, read %u\n", __func__,
		    rdb->rdb_next, next));
		rdb->rdb_next = MIN(next, rdb->rdb_ndesc - 1);
	}
}

void
rtw_txdescs_reset(struct rtw_softc *sc)
{
	int pri;

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		rtw_collect_txring(sc, &sc->sc_txsoft_blk[pri],
		    &sc->sc_txdesc_blk[pri], 1);
	}
}

void
rtw_intr_ioerror(struct rtw_softc *sc, u_int16_t isr)
{
	uint8_t cr = 0;
	int xmtr = 0, rcvr = 0;
	struct rtw_regs *regs = &sc->sc_regs;

	if ((isr & RTW_INTR_TXFOVW) != 0) {
		RTW_DPRINTF(RTW_DEBUG_BUGS,
		    ("%s: tx fifo underflow\n", sc->sc_dev.dv_xname));
		rcvr = xmtr = 1;
		cr |= RTW_CR_TE | RTW_CR_RE;
	}

	if ((isr & (RTW_INTR_RDU|RTW_INTR_RXFOVW)) != 0) {
		cr |= RTW_CR_RE;
		rcvr = 1;
	}

	RTW_DPRINTF(RTW_DEBUG_BUGS, ("%s: restarting xmit/recv, isr %hx"
	    "\n", sc->sc_dev.dv_xname, isr));

#ifdef RTW_DEBUG
	rtw_dump_rings(sc);
#endif /* RTW_DEBUG */

	rtw_io_enable(regs, cr, 0);

	/* Collect rx'd packets.  Refresh rx buffers. */
	if (rcvr)
		rtw_intr_rx(sc, 0);
	/* Collect tx'd packets.  XXX let's hope this stops the transmit
	 * timeouts.
	 */
	if (xmtr)
		rtw_txdescs_reset(sc);

	RTW_WRITE16(regs, RTW_IMR, 0);
	RTW_SYNC(regs, RTW_IMR, RTW_IMR);

	if (rtw_do_chip_reset) {
		rtw_chip_reset1(regs, sc->sc_dev.dv_xname);
	}

	rtw_rxdesc_init_all(&sc->sc_rxdesc_blk, &sc->sc_rxsoft[0], 1);

#ifdef RTW_DEBUG
	rtw_dump_rings(sc);
#endif /* RTW_DEBUG */

	RTW_WRITE16(regs, RTW_IMR, sc->sc_inten);
	RTW_SYNC(regs, RTW_IMR, RTW_IMR);
	if (rcvr)
		rtw_rxring_fixup(sc);
	rtw_io_enable(regs, cr, 1);
	if (xmtr)
		rtw_txring_fixup(sc);
}

void
rtw_suspend_ticks(struct rtw_softc *sc)
{
	RTW_DPRINTF(RTW_DEBUG_TIMEOUT,
	    ("%s: suspending ticks\n", sc->sc_dev.dv_xname));
	sc->sc_do_tick = 0;
}

void
rtw_resume_ticks(struct rtw_softc *sc)
{
	u_int32_t tsftrl0, tsftrl1, next_tick;

	tsftrl0 = RTW_READ(&sc->sc_regs, RTW_TSFTRL);

	tsftrl1 = RTW_READ(&sc->sc_regs, RTW_TSFTRL);
	next_tick = tsftrl1 + 1000000;
	RTW_WRITE(&sc->sc_regs, RTW_TINT, next_tick);

	sc->sc_do_tick = 1;

	RTW_DPRINTF(RTW_DEBUG_TIMEOUT,
	    ("%s: resume ticks delta %#08x now %#08x next %#08x\n",
	    sc->sc_dev.dv_xname, tsftrl1 - tsftrl0, tsftrl1, next_tick));
}

void
rtw_intr_timeout(struct rtw_softc *sc)
{
	RTW_DPRINTF(RTW_DEBUG_TIMEOUT, ("%s: timeout\n", sc->sc_dev.dv_xname));
	if (sc->sc_do_tick)
		rtw_resume_ticks(sc);
	return;
}

int
rtw_intr(void *arg)
{
	int i;
	struct rtw_softc *sc = arg;
	struct rtw_regs *regs = &sc->sc_regs;
	u_int16_t isr;

	/*
	 * If the interface isn't running, the interrupt couldn't
	 * possibly have come from us.
	 */
	if ((sc->sc_flags & RTW_F_ENABLED) == 0 ||
	    (sc->sc_if.if_flags & IFF_RUNNING) == 0 ||
	    (sc->sc_dev.dv_flags & DVF_ACTIVE) == 0) {
		RTW_DPRINTF(RTW_DEBUG_INTR, ("%s: stray interrupt\n",
		     sc->sc_dev.dv_xname));
		return (0);
	}

	for (i = 0; i < 10; i++) {
		isr = RTW_READ16(regs, RTW_ISR);

		RTW_WRITE16(regs, RTW_ISR, isr);
		RTW_WBR(regs, RTW_ISR, RTW_ISR);

		if (sc->sc_intr_ack != NULL)
			(*sc->sc_intr_ack)(regs);

		if (isr == 0)
			break;

#ifdef RTW_DEBUG
#define PRINTINTR(flag) do { \
	if ((isr & flag) != 0) { \
		printf("%s" #flag, delim); \
		delim = ","; \
	} \
} while (0)

		if ((rtw_debug & RTW_DEBUG_INTR) != 0 && isr != 0) {
			const char *delim = "<";

			printf("%s: reg[ISR] = %x", sc->sc_dev.dv_xname, isr);

			PRINTINTR(RTW_INTR_TXFOVW);
			PRINTINTR(RTW_INTR_TIMEOUT);
			PRINTINTR(RTW_INTR_BCNINT);
			PRINTINTR(RTW_INTR_ATIMINT);
			PRINTINTR(RTW_INTR_TBDER);
			PRINTINTR(RTW_INTR_TBDOK);
			PRINTINTR(RTW_INTR_THPDER);
			PRINTINTR(RTW_INTR_THPDOK);
			PRINTINTR(RTW_INTR_TNPDER);
			PRINTINTR(RTW_INTR_TNPDOK);
			PRINTINTR(RTW_INTR_RXFOVW);
			PRINTINTR(RTW_INTR_RDU);
			PRINTINTR(RTW_INTR_TLPDER);
			PRINTINTR(RTW_INTR_TLPDOK);
			PRINTINTR(RTW_INTR_RER);
			PRINTINTR(RTW_INTR_ROK);

			printf(">\n");
		}
#undef PRINTINTR
#endif /* RTW_DEBUG */

		if ((isr & RTW_INTR_RX) != 0)
			rtw_intr_rx(sc, isr & RTW_INTR_RX);
		if ((isr & RTW_INTR_TX) != 0)
			rtw_intr_tx(sc, isr & RTW_INTR_TX);
#ifndef IEEE80211_STA_ONLY
		if ((isr & RTW_INTR_BEACON) != 0)
			rtw_intr_beacon(sc, isr & RTW_INTR_BEACON);
		if ((isr & RTW_INTR_ATIMINT) != 0)
			rtw_intr_atim(sc);
#endif
		if ((isr & RTW_INTR_IOERROR) != 0)
			rtw_intr_ioerror(sc, isr & RTW_INTR_IOERROR);
		if ((isr & RTW_INTR_TIMEOUT) != 0)
			rtw_intr_timeout(sc);
	}

	return 1;
}

/* Must be called at splnet. */
void
rtw_stop(struct ifnet *ifp, int disable)
{
	int pri;
	struct rtw_softc *sc = (struct rtw_softc *)ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct rtw_regs *regs = &sc->sc_regs;

	if ((sc->sc_flags & RTW_F_ENABLED) == 0)
		return;

	rtw_suspend_ticks(sc);

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

	if ((sc->sc_flags & RTW_F_INVALID) == 0) {
		/* Disable interrupts. */
		RTW_WRITE16(regs, RTW_IMR, 0);

		RTW_WBW(regs, RTW_TPPOLL, RTW_IMR);

		/* Stop the transmit and receive processes. First stop DMA,
		 * then disable receiver and transmitter.
		 */
		RTW_WRITE8(regs, RTW_TPPOLL, RTW_TPPOLL_SALL);

		RTW_SYNC(regs, RTW_TPPOLL, RTW_IMR);

		rtw_io_enable(&sc->sc_regs, RTW_CR_RE|RTW_CR_TE, 0);
	}

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		rtw_txsofts_release(sc->sc_dmat, &sc->sc_ic,
		    &sc->sc_txsoft_blk[pri]);
	}

	rtw_rxbufs_release(sc->sc_dmat, &sc->sc_rxsoft[0]);

	if (disable)
		rtw_disable(sc);

	/* Mark the interface as not running.  Cancel the watchdog timer. */
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	return;
}

#ifdef RTW_DEBUG
const char *
rtw_pwrstate_string(enum rtw_pwrstate power)
{
	switch (power) {
	case RTW_ON:
		return "on";
	case RTW_SLEEP:
		return "sleep";
	case RTW_OFF:
		return "off";
	default:
		return "unknown";
	}
}
#endif

/* XXX For Maxim, I am using the RFMD settings gleaned from the
 * reference driver, plus a magic Maxim "ON" value that comes from
 * the Realtek document "Windows PG for Rtl8180."
 */
void
rtw_maxim_pwrstate(struct rtw_regs *regs, enum rtw_pwrstate power,
    int before_rf, int digphy)
{
	u_int32_t anaparm;

	anaparm = RTW_READ(regs, RTW_ANAPARM_0);
	anaparm &= ~(RTW_ANAPARM_RFPOW_MASK | RTW_ANAPARM_TXDACOFF);

	switch (power) {
	case RTW_OFF:
		if (before_rf)
			return;
		anaparm |= RTW_ANAPARM_RFPOW_MAXIM_OFF;
		anaparm |= RTW_ANAPARM_TXDACOFF;
		break;
	case RTW_SLEEP:
		if (!before_rf)
			return;
		anaparm |= RTW_ANAPARM_RFPOW_MAXIM_SLEEP;
		anaparm |= RTW_ANAPARM_TXDACOFF;
		break;
	case RTW_ON:
		if (!before_rf)
			return;
		anaparm |= RTW_ANAPARM_RFPOW_MAXIM_ON;
		break;
	}
	RTW_DPRINTF(RTW_DEBUG_PWR,
	    ("%s: power state %s, %s RF, reg[ANAPARM] <- %08x\n",
	    __func__, rtw_pwrstate_string(power),
	    (before_rf) ? "before" : "after", anaparm));

	RTW_WRITE(regs, RTW_ANAPARM_0, anaparm);
	RTW_SYNC(regs, RTW_ANAPARM_0, RTW_ANAPARM_0);
}

/* XXX I am using the RFMD settings gleaned from the reference
 * driver.  They agree 
 */
void
rtw_rfmd_pwrstate(struct rtw_regs *regs, enum rtw_pwrstate power,
    int before_rf, int digphy)
{
	u_int32_t anaparm;

	anaparm = RTW_READ(regs, RTW_ANAPARM_0);
	anaparm &= ~(RTW_ANAPARM_RFPOW_MASK | RTW_ANAPARM_TXDACOFF);

	switch (power) {
	case RTW_OFF:
		if (before_rf)
			return;
		anaparm |= RTW_ANAPARM_RFPOW_RFMD_OFF;
		anaparm |= RTW_ANAPARM_TXDACOFF;
		break;
	case RTW_SLEEP:
		if (!before_rf)
			return;
		anaparm |= RTW_ANAPARM_RFPOW_RFMD_SLEEP;
		anaparm |= RTW_ANAPARM_TXDACOFF;
		break;
	case RTW_ON:
		if (!before_rf)
			return;
		anaparm |= RTW_ANAPARM_RFPOW_RFMD_ON;
		break;
	}
	RTW_DPRINTF(RTW_DEBUG_PWR,
	    ("%s: power state %s, %s RF, reg[ANAPARM] <- %08x\n",
	    __func__, rtw_pwrstate_string(power),
	    (before_rf) ? "before" : "after", anaparm));

	RTW_WRITE(regs, RTW_ANAPARM_0, anaparm);
	RTW_SYNC(regs, RTW_ANAPARM_0, RTW_ANAPARM_0);
}

void
rtw_philips_pwrstate(struct rtw_regs *regs, enum rtw_pwrstate power,
    int before_rf, int digphy)
{
	u_int32_t anaparm;

	anaparm = RTW_READ(regs, RTW_ANAPARM_0);
	anaparm &= ~(RTW_ANAPARM_RFPOW_MASK | RTW_ANAPARM_TXDACOFF);

	switch (power) {
	case RTW_OFF:
		if (before_rf)
			return;
		anaparm |= RTW_ANAPARM_RFPOW_PHILIPS_OFF;
		anaparm |= RTW_ANAPARM_TXDACOFF;
		break;
	case RTW_SLEEP:
		if (!before_rf)
			return;
		anaparm |= RTW_ANAPARM_RFPOW_PHILIPS_SLEEP;
		anaparm |= RTW_ANAPARM_TXDACOFF;
		break;
	case RTW_ON:
		if (!before_rf)
			return;
		if (digphy) {
			anaparm |= RTW_ANAPARM_RFPOW_DIG_PHILIPS_ON;
			/* XXX guess */
			anaparm |= RTW_ANAPARM_TXDACOFF;
		} else
			anaparm |= RTW_ANAPARM_RFPOW_ANA_PHILIPS_ON;
		break;
	}
	RTW_DPRINTF(RTW_DEBUG_PWR,
	    ("%s: power state %s, %s RF, reg[ANAPARM] <- %08x\n",
	    __func__, rtw_pwrstate_string(power),
	    (before_rf) ? "before" : "after", anaparm));

	RTW_WRITE(regs, RTW_ANAPARM_0, anaparm);
	RTW_SYNC(regs, RTW_ANAPARM_0, RTW_ANAPARM_0);
}

void
rtw_rtl_pwrstate(struct rtw_regs *regs, enum rtw_pwrstate power,
    int before_rf, int digphy)
{
	/* empty */
}

void
rtw_pwrstate0(struct rtw_softc *sc, enum rtw_pwrstate power, int before_rf,
    int digphy)
{
	struct rtw_regs *regs = &sc->sc_regs;

	rtw_set_access(regs, RTW_ACCESS_ANAPARM);

	(*sc->sc_pwrstate_cb)(regs, power, before_rf, digphy);

	rtw_set_access(regs, RTW_ACCESS_NONE);

	return;
}

int
rtw_pwrstate(struct rtw_softc *sc, enum rtw_pwrstate power)
{
	int rc;

	RTW_DPRINTF(RTW_DEBUG_PWR,
	    ("%s: %s->%s\n", __func__,
	    rtw_pwrstate_string(sc->sc_pwrstate), rtw_pwrstate_string(power)));

	if (sc->sc_pwrstate == power)
		return 0;

	rtw_pwrstate0(sc, power, 1, sc->sc_flags & RTW_F_DIGPHY);
	rc = (*sc->sc_rf_pwrstate)(sc, power);
	rtw_pwrstate0(sc, power, 0, sc->sc_flags & RTW_F_DIGPHY);

	switch (power) {
	case RTW_ON:
		/* TBD set LEDs */
		break;
	case RTW_SLEEP:
		/* TBD */
		break;
	case RTW_OFF:
		/* TBD */
		break;
	}
	if (rc == 0)
		sc->sc_pwrstate = power;
	else
		sc->sc_pwrstate = RTW_OFF;
	return rc;
}

int
rtw_tune(struct rtw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	u_int chan, idx;
	u_int8_t txpower;
	int rc;

	KASSERT(ic->ic_bss->ni_chan != NULL);

	chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return 0;

	if (chan == sc->sc_cur_chan) {
		RTW_DPRINTF(RTW_DEBUG_TUNE,
		    ("%s: already tuned chan #%d\n", __func__, chan));
		return 0;
	}

	rtw_suspend_ticks(sc);

	rtw_io_enable(&sc->sc_regs, RTW_CR_RE | RTW_CR_TE, 0);

	/* TBD wait for Tx to complete */

	KASSERT((sc->sc_flags & RTW_F_ENABLED) != 0);

	idx = RTW_SR_TXPOWER1 +
	    ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan) - 1;
	KASSERT2(idx >= RTW_SR_TXPOWER1 && idx <= RTW_SR_TXPOWER14,
	    ("%s: channel %d out of range", __func__,
	     idx - RTW_SR_TXPOWER1 + 1));
	txpower =  RTW_SR_GET(&sc->sc_srom, idx);

	if ((rc = rtw_phy_init(sc)) != 0) {
		/* XXX condition on powersaving */
		printf("%s: phy init failed\n", sc->sc_dev.dv_xname);
	}

	sc->sc_cur_chan = chan;

	rtw_io_enable(&sc->sc_regs, RTW_CR_RE | RTW_CR_TE, 1);

	rtw_resume_ticks(sc);

	return rc;
}

void
rtw_disable(struct rtw_softc *sc)
{
	int rc;

	if ((sc->sc_flags & RTW_F_ENABLED) == 0)
		return;

	/* turn off PHY */
	if ((sc->sc_flags & RTW_F_INVALID) == 0 &&
	    (rc = rtw_pwrstate(sc, RTW_OFF)) != 0) {
		printf("%s: failed to turn off PHY (%d)\n",
		    sc->sc_dev.dv_xname, rc);
	}

	if (sc->sc_disable != NULL)
		(*sc->sc_disable)(sc);

	sc->sc_flags &= ~RTW_F_ENABLED;
}

int
rtw_enable(struct rtw_softc *sc)
{
	if ((sc->sc_flags & RTW_F_ENABLED) == 0) {
		if (sc->sc_enable != NULL && (*sc->sc_enable)(sc) != 0) {
			printf("%s: device enable failed\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}
		sc->sc_flags |= RTW_F_ENABLED;
	}
	return (0);
}

void
rtw_transmit_config(struct rtw_softc *sc)
{
	struct rtw_regs *regs = &sc->sc_regs;
	u_int32_t tcr;

	tcr = RTW_READ(regs, RTW_TCR);

	tcr |= RTW_TCR_CWMIN;
	tcr &= ~RTW_TCR_MXDMA_MASK;
	tcr |= RTW_TCR_MXDMA_256;
	if ((sc->sc_flags & RTW_F_RTL8185) == 0)
		tcr |= RTW8180_TCR_SAT;		/* send ACK as fast as possible */
	tcr &= ~RTW_TCR_LBK_MASK;
	tcr |= RTW_TCR_LBK_NORMAL;	/* normal operating mode */

	/* set short/long retry limits */
	tcr &= ~(RTW_TCR_SRL_MASK|RTW_TCR_LRL_MASK);
	tcr |= LSHIFT(4, RTW_TCR_SRL_MASK) | LSHIFT(4, RTW_TCR_LRL_MASK);

	tcr &= ~RTW_TCR_CRC;    /* NIC appends CRC32 */

	RTW_WRITE(regs, RTW_TCR, tcr);
	RTW_SYNC(regs, RTW_TCR, RTW_TCR);
}

void
rtw_enable_interrupts(struct rtw_softc *sc)
{
	struct rtw_regs *regs = &sc->sc_regs;

	sc->sc_inten = RTW_INTR_RX|RTW_INTR_TX|RTW_INTR_BEACON|RTW_INTR_ATIMINT;
	sc->sc_inten |= RTW_INTR_IOERROR|RTW_INTR_TIMEOUT;

	RTW_WRITE16(regs, RTW_IMR, sc->sc_inten);
	RTW_WBW(regs, RTW_IMR, RTW_ISR);
	RTW_WRITE16(regs, RTW_ISR, 0xffff);
	RTW_SYNC(regs, RTW_IMR, RTW_ISR);

	/* XXX necessary? */
	if (sc->sc_intr_ack != NULL)
		(*sc->sc_intr_ack)(regs);
}

void
rtw_set_nettype(struct rtw_softc *sc, enum ieee80211_opmode opmode)
{
	uint8_t msr;

	/* I'm guessing that MSR is protected as CONFIG[0123] are. */
	rtw_set_access(&sc->sc_regs, RTW_ACCESS_CONFIG);

	msr = RTW_READ8(&sc->sc_regs, RTW_MSR) & ~RTW_MSR_NETYPE_MASK;

	switch (opmode) {
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_AHDEMO:
	case IEEE80211_M_IBSS:
		msr |= RTW_MSR_NETYPE_ADHOC_OK;
		break;
	case IEEE80211_M_HOSTAP:
		msr |= RTW_MSR_NETYPE_AP_OK;
		break;
#endif
	case IEEE80211_M_MONITOR:
		/* XXX */
		msr |= RTW_MSR_NETYPE_NOLINK;
		break;
	case IEEE80211_M_STA:
		msr |= RTW_MSR_NETYPE_INFRA_OK;
		break;
	default:
		break;
	}
	RTW_WRITE8(&sc->sc_regs, RTW_MSR, msr);

	rtw_set_access(&sc->sc_regs, RTW_ACCESS_NONE);
}

void
rtw_pktfilt_load(struct rtw_softc *sc)
{
	struct rtw_regs *regs = &sc->sc_regs;
	struct ieee80211com *ic = &sc->sc_ic;
	struct arpcom *ac = &ic->ic_ac;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int hash;
	u_int32_t hashes[2] = { 0, 0 };
	struct ether_multi *enm;
	struct ether_multistep step;

	/* XXX might be necessary to stop Rx/Tx engines while setting filters */

	sc->sc_rcr &= ~RTW_RCR_PKTFILTER_MASK;
	sc->sc_rcr &= ~(RTW_RCR_MXDMA_MASK | RTW8180_RCR_RXFTH_MASK);

	sc->sc_rcr |= RTW_RCR_PKTFILTER_DEFAULT;
	/* MAC auto-reset PHY (huh?) */
	sc->sc_rcr |= RTW_RCR_ENMARP;
	/* DMA whole Rx packets, only.  Set Tx DMA burst size to 1024 bytes. */
	sc->sc_rcr |= RTW_RCR_MXDMA_1024 | RTW8180_RCR_RXFTH_WHOLE;

	switch (ic->ic_opmode) {
	case IEEE80211_M_MONITOR:
		sc->sc_rcr |= RTW_RCR_MONITOR;
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_AHDEMO:
	case IEEE80211_M_IBSS:
		/* receive broadcasts in our BSS */
		sc->sc_rcr |= RTW_RCR_ADD3;
		break;
#endif
	default:
		break;
	}

	ifp->if_flags &= ~IFF_ALLMULTI;

	/* XXX accept all broadcast if scanning */
	if ((ifp->if_flags & IFF_BROADCAST) != 0)
		sc->sc_rcr |= RTW_RCR_AB;	/* accept all broadcast */

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		if (ifp->if_flags & IFF_PROMISC)
			sc->sc_rcr |= RTW_RCR_AB; /* accept all broadcast */
allmulti:
		ifp->if_flags |= IFF_ALLMULTI;
		goto setit;
	}

	/*
	 * Program the 64-bit multicast hash filter.
	 */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		hash = ether_crc32_be((enm->enm_addrlo),
		    IEEE80211_ADDR_LEN) >> 26;
		hashes[hash >> 5] |= (1 << (hash & 0x1f));
		sc->sc_rcr |= RTW_RCR_AM;
		ETHER_NEXT_MULTI(step, enm);
	}

	/* all bits set => hash is useless */
	if (~(hashes[0] & hashes[1]) == 0)
		goto allmulti;

 setit:
	if (ifp->if_flags & IFF_ALLMULTI) {
		sc->sc_rcr |= RTW_RCR_AM;	/* accept all multicast */
		hashes[0] = hashes[1] = 0xffffffff;
	}

	RTW_WRITE(regs, RTW_MAR0, hashes[0]);
	RTW_WRITE(regs, RTW_MAR1, hashes[1]);
	RTW_WRITE(regs, RTW_RCR, sc->sc_rcr);
	RTW_SYNC(regs, RTW_MAR0, RTW_RCR); /* RTW_MAR0 < RTW_MAR1 < RTW_RCR */

	DPRINTF(sc, RTW_DEBUG_PKTFILT,
	    ("%s: RTW_MAR0 %08x RTW_MAR1 %08x RTW_RCR %08x\n",
	    sc->sc_dev.dv_xname, RTW_READ(regs, RTW_MAR0),
	    RTW_READ(regs, RTW_MAR1), RTW_READ(regs, RTW_RCR)));

	return;
}

/* Must be called at splnet. */
int
rtw_init(struct ifnet *ifp)
{
	struct rtw_softc *sc = (struct rtw_softc *)ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct rtw_regs *regs = &sc->sc_regs;
	int rc = 0;

	if ((rc = rtw_enable(sc)) != 0)
		goto out;

	/* Cancel pending I/O and reset. */
	rtw_stop(ifp, 0);

	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	DPRINTF(sc, RTW_DEBUG_TUNE, ("%s: channel %d freq %d flags 0x%04x\n",
	    __func__, ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan),
	    ic->ic_bss->ni_chan->ic_freq, ic->ic_bss->ni_chan->ic_flags));

	if ((rc = rtw_pwrstate(sc, RTW_OFF)) != 0)
		goto out;

	if ((rc = rtw_swring_setup(sc)) != 0)
		goto out;

	rtw_transmit_config(sc);

	rtw_set_access(regs, RTW_ACCESS_CONFIG);

	RTW_WRITE8(regs, RTW_MSR, 0x0);	/* no link */
	RTW_WBW(regs, RTW_MSR, RTW_BRSR);

	/* long PLCP header, 1Mb/2Mb basic rate */
	if (sc->sc_flags & RTW_F_RTL8185)
		RTW_WRITE16(regs, RTW_BRSR, RTW8185_BRSR_MBR_2MBPS);
	else
		RTW_WRITE16(regs, RTW_BRSR, RTW8180_BRSR_MBR_2MBPS);
	RTW_SYNC(regs, RTW_BRSR, RTW_BRSR);

	rtw_set_access(regs, RTW_ACCESS_ANAPARM);
	rtw_set_access(regs, RTW_ACCESS_NONE);

	/* XXX from reference sources */
	RTW_WRITE(regs, RTW_FEMR, 0xffff);
	RTW_SYNC(regs, RTW_FEMR, RTW_FEMR);

	rtw_set_rfprog(regs, sc->sc_rfchipid, sc->sc_dev.dv_xname);

	RTW_WRITE8(regs, RTW_PHYDELAY, sc->sc_phydelay);
	/* from Linux driver */
	RTW_WRITE8(regs, RTW_CRCOUNT, RTW_CRCOUNT_MAGIC);

	RTW_SYNC(regs, RTW_PHYDELAY, RTW_CRCOUNT);

	rtw_enable_interrupts(sc);

	rtw_pktfilt_load(sc);

	rtw_hwring_setup(sc);

	rtw_io_enable(regs, RTW_CR_RE|RTW_CR_TE, 1);

	ifp->if_flags |= IFF_RUNNING;
	ic->ic_state = IEEE80211_S_INIT;

	RTW_WRITE16(regs, RTW_BSSID16, 0x0);
	RTW_WRITE(regs, RTW_BSSID32, 0x0);

	rtw_resume_ticks(sc);

	rtw_set_nettype(sc, IEEE80211_M_MONITOR);

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		return ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		return ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

out:
	printf("%s: interface not running\n", sc->sc_dev.dv_xname);
	return rc;
}

void
rtw_led_init(struct rtw_regs *regs)
{
	u_int8_t cfg0, cfg1;

	rtw_set_access(regs, RTW_ACCESS_CONFIG);

	cfg0 = RTW_READ8(regs, RTW_CONFIG0);
	cfg0 |= RTW8180_CONFIG0_LEDGPOEN;
	RTW_WRITE8(regs, RTW_CONFIG0, cfg0);

	cfg1 = RTW_READ8(regs, RTW_CONFIG1);
	RTW_DPRINTF(RTW_DEBUG_LED,
	    ("%s: read % from reg[CONFIG1]\n", __func__, cfg1));

	cfg1 &= ~RTW_CONFIG1_LEDS_MASK;
	cfg1 |= RTW_CONFIG1_LEDS_TX_RX;
	RTW_WRITE8(regs, RTW_CONFIG1, cfg1);

	rtw_set_access(regs, RTW_ACCESS_NONE);
}

/* 
 * IEEE80211_S_INIT: 		LED1 off
 *
 * IEEE80211_S_AUTH,
 * IEEE80211_S_ASSOC,
 * IEEE80211_S_SCAN: 		LED1 blinks @@ 1 Hz, blinks at 5Hz for tx/rx
 *
 * IEEE80211_S_RUN: 		LED1 on, blinks @@ 5Hz for tx/rx
 */
void
rtw_led_newstate(struct rtw_softc *sc, enum ieee80211_state nstate)
{
	struct rtw_led_state *ls;

	ls = &sc->sc_led_state;

	switch (nstate) {
	case IEEE80211_S_INIT:
		rtw_led_init(&sc->sc_regs);
		timeout_del(&ls->ls_slow_ch);
		timeout_del(&ls->ls_fast_ch);
		ls->ls_slowblink = 0;
		ls->ls_actblink = 0;
		ls->ls_default = 0;
		break;
	case IEEE80211_S_SCAN:
		timeout_add_msec(&ls->ls_slow_ch, RTW_LED_SLOW_MSEC);
		timeout_add_msec(&ls->ls_fast_ch, RTW_LED_FAST_MSEC);
		/*FALLTHROUGH*/
	case IEEE80211_S_AUTH:
	case IEEE80211_S_ASSOC:
		ls->ls_default = RTW_LED1;
		ls->ls_actblink = RTW_LED1;
		ls->ls_slowblink = RTW_LED1;
		break;
	case IEEE80211_S_RUN:
		ls->ls_slowblink = 0;
		break;
	}
	rtw_led_set(ls, &sc->sc_regs, sc->sc_hwverid);
}

void
rtw_led_set(struct rtw_led_state *ls, struct rtw_regs *regs, u_int hwverid)
{
	u_int8_t led_condition;
	bus_size_t ofs;
	u_int8_t mask, newval, val;

	led_condition = ls->ls_default;

	if (ls->ls_state & RTW_LED_S_SLOW)
		led_condition ^= ls->ls_slowblink;
	if (ls->ls_state & (RTW_LED_S_RX|RTW_LED_S_TX))
		led_condition ^= ls->ls_actblink;

	RTW_DPRINTF(RTW_DEBUG_LED,
	    ("%s: LED condition %\n", __func__, led_condition));

	switch (hwverid) {
	default:
	case RTW_TCR_HWVERID_RTL8180F:
		ofs = RTW_PSR;
		newval = mask = RTW_PSR_LEDGPO0 | RTW_PSR_LEDGPO1;
		if (led_condition & RTW_LED0)
			newval &= ~RTW_PSR_LEDGPO0;
		if (led_condition & RTW_LED1)
			newval &= ~RTW_PSR_LEDGPO1;
		break;
	case RTW_TCR_HWVERID_RTL8180D:
		ofs = RTW_9346CR;
		mask = RTW_9346CR_EEM_MASK | RTW_9346CR_EEDI | RTW_9346CR_EECS;
		newval = RTW_9346CR_EEM_PROGRAM;
		if (led_condition & RTW_LED0)
			newval |= RTW_9346CR_EEDI;
		if (led_condition & RTW_LED1)
			newval |= RTW_9346CR_EECS;
		break;
	}
	val = RTW_READ8(regs, ofs);
	RTW_DPRINTF(RTW_DEBUG_LED,
	    ("%s: read % from reg[%#02]\n", __func__, val,
	     (u_int *)ofs));
	val &= ~mask;
	val |= newval;
	RTW_WRITE8(regs, ofs, val);
	RTW_DPRINTF(RTW_DEBUG_LED,
	    ("%s: wrote % to reg[%#02]\n", __func__, val,
	     (u_int *)ofs));
	RTW_SYNC(regs, ofs, ofs);
}

void
rtw_led_fastblink(void *arg)
{
	int ostate, s;
	struct rtw_softc *sc = (struct rtw_softc *)arg;
	struct rtw_led_state *ls = &sc->sc_led_state;

	s = splnet();
	ostate = ls->ls_state;
	ls->ls_state ^= ls->ls_event;

	if ((ls->ls_event & RTW_LED_S_TX) == 0)
		ls->ls_state &= ~RTW_LED_S_TX;

	if ((ls->ls_event & RTW_LED_S_RX) == 0)
		ls->ls_state &= ~RTW_LED_S_RX;

	ls->ls_event = 0;

	if (ostate != ls->ls_state)
		rtw_led_set(ls, &sc->sc_regs, sc->sc_hwverid);
	splx(s);

	timeout_add_msec(&ls->ls_fast_ch, RTW_LED_FAST_MSEC);
}

void
rtw_led_slowblink(void *arg)
{
	int s;
	struct rtw_softc *sc = (struct rtw_softc *)arg;
	struct rtw_led_state *ls = &sc->sc_led_state;

	s = splnet();
	ls->ls_state ^= RTW_LED_S_SLOW;
	rtw_led_set(ls, &sc->sc_regs, sc->sc_hwverid);
	splx(s);
	timeout_add_msec(&ls->ls_slow_ch, RTW_LED_SLOW_MSEC);
}

void
rtw_led_attach(struct rtw_led_state *ls, void *arg)
{
	timeout_set(&ls->ls_fast_ch, rtw_led_fastblink, arg);
	timeout_set(&ls->ls_slow_ch, rtw_led_slowblink, arg);
}

int
rtw_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct rtw_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int rc = 0, s;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) != 0) {
			if ((sc->sc_flags & RTW_F_ENABLED) != 0) {
				rtw_pktfilt_load(sc);
			} else
				rc = rtw_init(ifp);
		} else if ((sc->sc_flags & RTW_F_ENABLED) != 0)
			rtw_stop(ifp, 1);
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		if (cmd == SIOCADDMULTI)
			rc = ether_addmulti(ifr, &sc->sc_ic.ic_ac);
		else
			rc = ether_delmulti(ifr, &sc->sc_ic.ic_ac);
		if (rc != ENETRESET)
			break;
		if (ifp->if_flags & IFF_RUNNING)
			rtw_pktfilt_load(sc);
		rc = 0;
		break;

	default:
		if ((rc = ieee80211_ioctl(ifp, cmd, data)) == ENETRESET) {
			if ((sc->sc_flags & RTW_F_ENABLED) != 0)
				rc = rtw_init(ifp);
			else
				rc = 0;
		}
		break;
	}

	splx(s);
	return rc;
}

/* Select a transmit ring with at least one h/w and s/w descriptor free.
 * Return 0 on success, -1 on failure.
 */
int
rtw_txring_choose(struct rtw_softc *sc, struct rtw_txsoft_blk **tsbp,
    struct rtw_txdesc_blk **tdbp, int pri)
{
	struct rtw_txsoft_blk *tsb;
	struct rtw_txdesc_blk *tdb;

	KASSERT(pri >= 0 && pri < RTW_NTXPRI);

	tsb = &sc->sc_txsoft_blk[pri];
	tdb = &sc->sc_txdesc_blk[pri];

	if (SIMPLEQ_EMPTY(&tsb->tsb_freeq) || tdb->tdb_nfree == 0) {
		if (tsb->tsb_tx_timer == 0)
			tsb->tsb_tx_timer = 5;
		*tsbp = NULL;
		*tdbp = NULL;
		return -1;
	}
	*tsbp = tsb;
	*tdbp = tdb;
	return 0;
}

struct mbuf *
rtw_80211_dequeue(struct rtw_softc *sc, struct mbuf_queue *ifq, int pri,
    struct rtw_txsoft_blk **tsbp, struct rtw_txdesc_blk **tdbp,
    struct ieee80211_node **nip)
{
	struct mbuf *m;

	if (mq_empty(ifq))
		return NULL;
	if (rtw_txring_choose(sc, tsbp, tdbp, pri) == -1) {
		DPRINTF(sc, RTW_DEBUG_XMIT_RSRC, ("%s: no ring %d descriptor\n",
		    __func__, pri));
		ifq_set_oactive(&sc->sc_if.if_snd);
		sc->sc_if.if_timer = 1;
		return NULL;
	}
	m = mq_dequeue(ifq);
	*nip = m->m_pkthdr.ph_cookie;
	return m;
}

/* Point *mp at the next 802.11 frame to transmit.  Point *tsbp
 * at the driver's selection of transmit control block for the packet.
 */
int
rtw_dequeue(struct ifnet *ifp, struct rtw_txsoft_blk **tsbp,
    struct rtw_txdesc_blk **tdbp, struct mbuf **mp,
    struct ieee80211_node **nip)
{
	struct ieee80211com *ic;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct mbuf *m0;
	struct rtw_softc *sc;

	sc = (struct rtw_softc *)ifp->if_softc;
	ic = &sc->sc_ic;

	DPRINTF(sc, RTW_DEBUG_XMIT,
	    ("%s: enter %s\n", sc->sc_dev.dv_xname, __func__));

	if (ic->ic_state == IEEE80211_S_RUN &&
	    (*mp = rtw_80211_dequeue(sc, &sc->sc_beaconq, RTW_TXPRIBCN, tsbp,
	    tdbp, nip)) != NULL) {
		DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: dequeue beacon frame\n",
		    __func__));
		return 0;
	}

	if ((*mp = rtw_80211_dequeue(sc, &ic->ic_mgtq, RTW_TXPRIMD, tsbp,
	    tdbp, nip)) != NULL) {
		DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: dequeue mgt frame\n",
		    __func__));
		return 0;
	}

	if (sc->sc_ic.ic_state != IEEE80211_S_RUN) {
		DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: not running\n", __func__));
		return 0;
	}

	if ((*mp = rtw_80211_dequeue(sc, &ic->ic_pwrsaveq, RTW_TXPRIHI,
	    tsbp, tdbp, nip)) != NULL) {
		DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: dequeue pwrsave frame\n",
		    __func__));
		return 0;
	}

	if (ic->ic_state != IEEE80211_S_RUN) {
		DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: not running\n", __func__));
		return 0;
	}

	*mp = NULL;

	m0 = ifq_deq_begin(&ifp->if_snd);
	if (m0 == NULL) {
		DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: no frame ready\n",
		    __func__));
		return 0;
	}

	if (rtw_txring_choose(sc, tsbp, tdbp, RTW_TXPRIMD) == -1) {
		DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: no descriptor\n", __func__));
		ifq_deq_rollback(&ifp->if_snd, m0);
		ifq_set_oactive(&ifp->if_snd);
		sc->sc_if.if_timer = 1;
		return 0;
	}

	ifq_deq_commit(&ifp->if_snd, m0);
	if (m0 == NULL) {
		DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: no frame/ring ready\n",
		    __func__));
		return 0;
	}
	DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: dequeue data frame\n", __func__));
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
	if ((m0 = ieee80211_encap(ifp, m0, nip)) == NULL) {
		DPRINTF(sc, RTW_DEBUG_XMIT,
		    ("%s: encap error\n", __func__));
		ifp->if_oerrors++;
		return -1;
	}

	/* XXX should do WEP in hardware */
	if (ic->ic_flags & IEEE80211_F_WEPON) {
		wh = mtod(m0, struct ieee80211_frame *);
		k = ieee80211_get_txkey(ic, wh, *nip);
		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return -1;
	}

	DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: leave\n", __func__));
	*mp = m0;
	return 0;
}

int
rtw_seg_too_short(bus_dmamap_t dmamap)
{
	int i;
	for (i = 0; i < dmamap->dm_nsegs; i++) {
		if (dmamap->dm_segs[i].ds_len < 4) {
			printf("%s: segment too short\n", __func__);
			return 1;
		}
	}
	return 0;
}

/* TBD factor with atw_start */
struct mbuf *
rtw_dmamap_load_txbuf(bus_dma_tag_t dmat, bus_dmamap_t dmam, struct mbuf *chain,
    u_int ndescfree, short *ifflagsp, const char *dvname)
{
	int first, rc;
	struct mbuf *m, *m0;

	m0 = chain;

	/*
	 * Load the DMA map.  Copy and try (once) again if the packet
	 * didn't fit in the alloted number of segments.
	 */
	for (first = 1;
	     ((rc = bus_dmamap_load_mbuf(dmat, dmam, m0,
	     BUS_DMA_WRITE|BUS_DMA_NOWAIT)) != 0 ||
	     dmam->dm_nsegs > ndescfree || rtw_seg_too_short(dmam)) && first;
	     first = 0) {
		if (rc == 0)
			bus_dmamap_unload(dmat, dmam);
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			printf("%s: unable to allocate Tx mbuf\n",
			    dvname);
			break;
		}
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				printf("%s: cannot allocate Tx cluster\n",
				    dvname);
				m_freem(m);
				break;
			}
		}
		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m, caddr_t));
		m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;
		m_freem(m0);
		m0 = m;
		m = NULL;
	}
	if (rc != 0) {
		printf("%s: cannot load Tx buffer, rc = %d\n", dvname, rc);
		m_freem(m0);
		return NULL;
	} else if (rtw_seg_too_short(dmam)) {
		printf("%s: cannot load Tx buffer, segment too short\n",
		    dvname);
		bus_dmamap_unload(dmat, dmam);
		m_freem(m0);
		return NULL;
	} else if (dmam->dm_nsegs > ndescfree) {
		printf("%s: too many tx segments\n", dvname);
		bus_dmamap_unload(dmat, dmam);
		m_freem(m0);
		return NULL;
	}
	return m0;
}


/*
 * Arguments in:
 *
 * paylen:  payload length (no FCS, no WEP header)
 *
 * hdrlen:  header length
 *
 * rate:    MSDU speed, units 500kb/s
 *
 * flags:   IEEE80211_F_SHPREAMBLE (use short preamble),
 *          IEEE80211_F_SHSLOT (use short slot length)
 *
 * Arguments out:
 *
 * d:       802.11 Duration field for RTS,
 *          802.11 Duration field for data frame,
 *          PLCP Length for data frame,
 *          residual octets at end of data slot
 */
int
rtw_compute_duration1(int len, int use_ack, uint32_t flags, int rate,
    struct rtw_duration *d)
{
	int pre, ctsrate;
	int ack, bitlen, data_dur, remainder;

	/* RTS reserves medium for SIFS | CTS | SIFS | (DATA) | SIFS | ACK
	 * DATA reserves medium for SIFS | ACK
	 *
	 * XXXMYC: no ACK on multicast/broadcast or control packets
	 */

	bitlen = len * 8;

	pre = IEEE80211_DUR_DS_SIFS;
	if ((flags & IEEE80211_F_SHPREAMBLE) != 0)
		pre += IEEE80211_DUR_DS_SHORT_PREAMBLE +
		    IEEE80211_DUR_DS_FAST_PLCPHDR;
	else
		pre += IEEE80211_DUR_DS_LONG_PREAMBLE +
		    IEEE80211_DUR_DS_SLOW_PLCPHDR;

	d->d_residue = 0;
	data_dur = (bitlen * 2) / rate;
	remainder = (bitlen * 2) % rate;
	if (remainder != 0) {
		d->d_residue = (rate - remainder) / 16;
		data_dur++;
	}

	switch (rate) {
	case 2:		/* 1 Mb/s */
	case 4:		/* 2 Mb/s */
		/* 1 - 2 Mb/s WLAN: send ACK/CTS at 1 Mb/s */
		ctsrate = 2;
		break;
	case 11:	/* 5.5 Mb/s */
	case 22:	/* 11  Mb/s */
	case 44:	/* 22  Mb/s */
		/* 5.5 - 11 Mb/s WLAN: send ACK/CTS at 2 Mb/s */
		ctsrate = 4;
		break;
	default:
		/* TBD */
		return -1;
	}

	d->d_plcp_len = data_dur;

	ack = (use_ack) ? pre + (IEEE80211_DUR_DS_SLOW_ACK * 2) / ctsrate : 0;

	d->d_rts_dur =
	    pre + (IEEE80211_DUR_DS_SLOW_CTS * 2) / ctsrate +
	    pre + data_dur +
	    ack;

	d->d_data_dur = ack;

	return 0;
}

/*
 * Arguments in:
 *
 * wh:      802.11 header
 *
 * len: packet length 
 *
 * rate:    MSDU speed, units 500kb/s
 *
 * fraglen: fragment length, set to maximum (or higher) for no
 *          fragmentation
 *
 * flags:   IEEE80211_F_WEPON (hardware adds WEP),
 *          IEEE80211_F_SHPREAMBLE (use short preamble),
 *          IEEE80211_F_SHSLOT (use short slot length)
 *
 * Arguments out:
 *
 * d0: 802.11 Duration fields (RTS/Data), PLCP Length, Service fields
 *     of first/only fragment
 *
 * dn: 802.11 Duration fields (RTS/Data), PLCP Length, Service fields
 *     of first/only fragment
 */
int
rtw_compute_duration(struct ieee80211_frame *wh, int len, uint32_t flags,
    int fraglen, int rate, struct rtw_duration *d0, struct rtw_duration *dn,
    int *npktp, int debug)
{
	int ack, rc;
	int firstlen, hdrlen, lastlen, lastlen0, npkt, overlen, paylen;

	if (ieee80211_has_addr4(wh))
		hdrlen = sizeof(struct ieee80211_frame_addr4);
	else
		hdrlen = sizeof(struct ieee80211_frame);

	paylen = len - hdrlen;

	if ((flags & IEEE80211_F_WEPON) != 0)
		overlen = IEEE80211_WEP_TOTLEN + IEEE80211_CRC_LEN;
	else
		overlen = IEEE80211_CRC_LEN;

	npkt = paylen / fraglen;
	lastlen0 = paylen % fraglen;

	if (npkt == 0)			/* no fragments */
		lastlen = paylen + overlen;
	else if (lastlen0 != 0) {	/* a short "tail" fragment */
		lastlen = lastlen0 + overlen;
		npkt++;
	} else				/* full-length "tail" fragment */
		lastlen = fraglen + overlen;

	if (npktp != NULL)
		*npktp = npkt;

	if (npkt > 1)
		firstlen = fraglen + overlen;
	else
		firstlen = paylen + overlen;

	if (debug) {
		printf("%s: npkt %d firstlen %d lastlen0 %d lastlen %d "
		    "fraglen %d overlen %d len %d rate %d flags %08x\n",
		    __func__, npkt, firstlen, lastlen0, lastlen, fraglen,
		    overlen, len, rate, flags);
	}

	ack = !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (wh->i_fc[1] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL;

	rc = rtw_compute_duration1(firstlen + hdrlen, ack, flags, rate, d0);
	if (rc == -1)
		return rc;

	if (npkt <= 1) {
		*dn = *d0;
		return 0;
	}
	return rtw_compute_duration1(lastlen + hdrlen, ack, flags, rate, dn);
}

#ifdef RTW_DEBUG
void
rtw_print_txdesc(struct rtw_softc *sc, const char *action,
    struct rtw_txsoft *ts, struct rtw_txdesc_blk *tdb, int desc)
{
	struct rtw_txdesc *td = &tdb->tdb_desc[desc];
	DPRINTF(sc, RTW_DEBUG_XMIT_DESC, ("%s: %p %s txdesc[%d] next %#08x "
	    "buf %#08x ctl0 %#08x ctl1 %#08x len %#08x\n",
	    sc->sc_dev.dv_xname, ts, action, desc,
	    letoh32(td->td_buf), letoh32(td->td_next),
	    letoh32(td->td_ctl0), letoh32(td->td_ctl1),
	    letoh32(td->td_len)));
}
#endif /* RTW_DEBUG */

void
rtw_start(struct ifnet *ifp)
{
	uint8_t tppoll;
	int desc, i, lastdesc, npkt, rate;
	uint32_t proto_ctl0, ctl0, ctl1;
	bus_dmamap_t		dmamap;
	struct ieee80211com	*ic;
	struct ieee80211_frame	*wh;
	struct ieee80211_node	*ni;
	struct mbuf		*m0;
	struct rtw_softc	*sc;
	struct rtw_duration	*d0;
	struct rtw_txsoft_blk	*tsb;
	struct rtw_txdesc_blk	*tdb;
	struct rtw_txsoft	*ts;
	struct rtw_txdesc	*td;

	sc = (struct rtw_softc *)ifp->if_softc;
	ic = &sc->sc_ic;

	DPRINTF(sc, RTW_DEBUG_XMIT,
	    ("%s: enter %s\n", sc->sc_dev.dv_xname, __func__));

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		goto out;

	/* XXX do real rate control */
	proto_ctl0 = RTW_TXCTL0_RTSRATE_1MBPS;

	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) != 0)
		proto_ctl0 |= RTW_TXCTL0_SPLCP;

	for (;;) {
		if (rtw_dequeue(ifp, &tsb, &tdb, &m0, &ni) == -1)
			continue;
		if (m0 == NULL)
			break;
		ts = SIMPLEQ_FIRST(&tsb->tsb_freeq);

		dmamap = ts->ts_dmamap;

		m0 = rtw_dmamap_load_txbuf(sc->sc_dmat, dmamap, m0,
		    tdb->tdb_nfree, &ifp->if_flags, sc->sc_dev.dv_xname);

		if (m0 == NULL || dmamap->dm_nsegs == 0) {
			DPRINTF(sc, RTW_DEBUG_XMIT,
			    ("%s: fail dmamap load\n", __func__));
			goto post_dequeue_err;
		}

		wh = mtod(m0, struct ieee80211_frame *);

		/* XXX do real rate control */
		if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
		    IEEE80211_FC0_TYPE_MGT)
			rate = 2;
		else
			rate = MAX(2, ieee80211_get_rate(ic));

#ifdef RTW_DEBUG
		if ((sc->sc_if.if_flags & (IFF_DEBUG|IFF_LINK2)) ==
		    (IFF_DEBUG|IFF_LINK2)) {
			ieee80211_dump_pkt(mtod(m0, uint8_t *),
			    (dmamap->dm_nsegs == 1) ? m0->m_pkthdr.len
			    : sizeof(wh), rate, 0);
		}
#endif /* RTW_DEBUG */
		ctl0 = proto_ctl0 |
		    LSHIFT(m0->m_pkthdr.len, RTW_TXCTL0_TPKTSIZE_MASK);

		switch (rate) {
		default:
		case 2:
			ctl0 |= RTW_TXCTL0_RATE_1MBPS;
			break;
		case 4:
			ctl0 |= RTW_TXCTL0_RATE_2MBPS;
			break;
		case 11:
			ctl0 |= RTW_TXCTL0_RATE_5MBPS;
			break;
		case 22:
			ctl0 |= RTW_TXCTL0_RATE_11MBPS;
			break;
		}

		/* XXX >= ? Compare after fragmentation? */
		if (m0->m_pkthdr.len > ic->ic_rtsthreshold)
			ctl0 |= RTW_TXCTL0_RTSEN;

		if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
		    IEEE80211_FC0_TYPE_MGT) {
			ctl0 &= ~(RTW_TXCTL0_SPLCP | RTW_TXCTL0_RTSEN);
			if ((wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
			    IEEE80211_FC0_SUBTYPE_BEACON)
				ctl0 |= RTW_TXCTL0_BEACON;
		}

		if (rtw_compute_duration(wh, m0->m_pkthdr.len,
		    ic->ic_flags & ~IEEE80211_F_WEPON, ic->ic_fragthreshold,
		    rate, &ts->ts_d0, &ts->ts_dn, &npkt,
		    (sc->sc_if.if_flags & (IFF_DEBUG|IFF_LINK2)) ==
		    (IFF_DEBUG|IFF_LINK2)) == -1) {
			DPRINTF(sc, RTW_DEBUG_XMIT,
			    ("%s: fail compute duration\n", __func__));
			goto post_load_err;
		}

		d0 = &ts->ts_d0;

		*(uint16_t*)wh->i_dur = htole16(d0->d_data_dur);

		ctl1 = LSHIFT(d0->d_plcp_len, RTW_TXCTL1_LENGTH_MASK) |
		    LSHIFT(d0->d_rts_dur, RTW_TXCTL1_RTSDUR_MASK);

		if (d0->d_residue)
			ctl1 |= RTW_TXCTL1_LENGEXT;

		/* TBD fragmentation */

		ts->ts_first = tdb->tdb_next;

		rtw_txdescs_sync(tdb, ts->ts_first, dmamap->dm_nsegs,
		    BUS_DMASYNC_PREWRITE);

		KASSERT(ts->ts_first < tdb->tdb_ndesc);

#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap((caddr_t)ic->ic_rawbpf, m0,
			    BPF_DIRECTION_OUT);

		if (sc->sc_radiobpf != NULL) {
			struct mbuf mb;
			struct rtw_tx_radiotap_header *rt = &sc->sc_txtap;

			rt->rt_flags = 0;
			rt->rt_rate = rate;
			rt->rt_chan_freq =
			    htole16(ic->ic_bss->ni_chan->ic_freq);
			rt->rt_chan_flags =
			    htole16(ic->ic_bss->ni_chan->ic_flags);

			mb.m_data = (caddr_t)rt;
			mb.m_len = sizeof(sc->sc_txtapu);
			mb.m_next = m0;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_radiobpf, &mb, BPF_DIRECTION_OUT);

		}
#endif /* NBPFILTER > 0 */

		for (i = 0, lastdesc = desc = ts->ts_first;
		     i < dmamap->dm_nsegs;
		     i++, desc = RTW_NEXT_IDX(tdb, desc)) {
			if (dmamap->dm_segs[i].ds_len > RTW_TXLEN_LENGTH_MASK) {
				DPRINTF(sc, RTW_DEBUG_XMIT_DESC,
				    ("%s: seg too long\n", __func__));
				goto post_load_err;
			}
			td = &tdb->tdb_desc[desc];
			td->td_ctl0 = htole32(ctl0);
			if (i != 0)
				td->td_ctl0 |= htole32(RTW_TXCTL0_OWN);
			td->td_ctl1 = htole32(ctl1);
			td->td_buf = htole32(dmamap->dm_segs[i].ds_addr);
			td->td_len = htole32(dmamap->dm_segs[i].ds_len);
			lastdesc = desc;
#ifdef RTW_DEBUG
			rtw_print_txdesc(sc, "load", ts, tdb, desc);
#endif /* RTW_DEBUG */
		}

		KASSERT(desc < tdb->tdb_ndesc);

		ts->ts_ni = ni;
		ts->ts_mbuf = m0;
		ts->ts_last = lastdesc;
		tdb->tdb_desc[ts->ts_last].td_ctl0 |= htole32(RTW_TXCTL0_LS);
		tdb->tdb_desc[ts->ts_first].td_ctl0 |=
		    htole32(RTW_TXCTL0_FS);

#ifdef RTW_DEBUG
		rtw_print_txdesc(sc, "FS on", ts, tdb, ts->ts_first);
		rtw_print_txdesc(sc, "LS on", ts, tdb, ts->ts_last);
#endif /* RTW_DEBUG */

		tdb->tdb_nfree -= dmamap->dm_nsegs;
		tdb->tdb_next = desc;

		rtw_txdescs_sync(tdb, ts->ts_first, dmamap->dm_nsegs,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		tdb->tdb_desc[ts->ts_first].td_ctl0 |=
		    htole32(RTW_TXCTL0_OWN);

#ifdef RTW_DEBUG
		rtw_print_txdesc(sc, "OWN on", ts, tdb, ts->ts_first);
#endif /* RTW_DEBUG */

		rtw_txdescs_sync(tdb, ts->ts_first, 1,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		SIMPLEQ_REMOVE_HEAD(&tsb->tsb_freeq, ts_q);
		SIMPLEQ_INSERT_TAIL(&tsb->tsb_dirtyq, ts, ts_q);

		if (tsb != &sc->sc_txsoft_blk[RTW_TXPRIBCN])
			sc->sc_led_state.ls_event |= RTW_LED_S_TX;
		tsb->tsb_tx_timer = 5;
		ifp->if_timer = 1;
		tppoll = RTW_READ8(&sc->sc_regs, RTW_TPPOLL);
		tppoll &= ~RTW_TPPOLL_SALL;
		tppoll |= tsb->tsb_poll & RTW_TPPOLL_ALL;
		RTW_WRITE8(&sc->sc_regs, RTW_TPPOLL, tppoll);
		RTW_SYNC(&sc->sc_regs, RTW_TPPOLL, RTW_TPPOLL);
	}
out:
	DPRINTF(sc, RTW_DEBUG_XMIT, ("%s: leave\n", __func__));
	return;
post_load_err:
	bus_dmamap_unload(sc->sc_dmat, dmamap);
	m_freem(m0);
post_dequeue_err:
	ieee80211_release_node(&sc->sc_ic, ni);
	return;
}

void
rtw_idle(struct rtw_regs *regs)
{
	int active;

	/* request stop DMA; wait for packets to stop transmitting. */

	RTW_WRITE8(regs, RTW_TPPOLL, RTW_TPPOLL_SALL);
	RTW_WBR(regs, RTW_TPPOLL, RTW_TPPOLL);

	for (active = 0; active < 300 &&
	     (RTW_READ8(regs, RTW_TPPOLL) & RTW_TPPOLL_ACTIVE) != 0; active++)
		DELAY(10);
	RTW_DPRINTF(RTW_DEBUG_BUGS,
	    ("%s: transmit DMA idle in %dus\n", __func__, active * 10));
}

void
rtw_watchdog(struct ifnet *ifp)
{
	int pri, tx_timeouts = 0;
	struct rtw_softc *sc;
	struct rtw_txsoft_blk *tsb;

	sc = ifp->if_softc;

	ifp->if_timer = 0;

	if ((sc->sc_flags & RTW_F_ENABLED) == 0)
		return;

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		tsb = &sc->sc_txsoft_blk[pri];

		if (tsb->tsb_tx_timer == 0)
			continue;
		else if (--tsb->tsb_tx_timer == 0) {
			if (SIMPLEQ_EMPTY(&tsb->tsb_dirtyq))
				continue;
			RTW_DPRINTF(RTW_DEBUG_BUGS,
			    ("%s: transmit timeout, priority %d\n",
			    ifp->if_xname, pri));
			ifp->if_oerrors++;
			tx_timeouts++;
		} else
			ifp->if_timer = 1;
	}

	if (tx_timeouts > 0) {
		/* Stop Tx DMA, disable xmtr, flush Tx rings, enable xmtr,
		 * reset s/w tx-ring pointers, and start transmission.
		 *
		 * TBD Stop/restart just the broken rings?
		 */
		rtw_idle(&sc->sc_regs);
		rtw_io_enable(&sc->sc_regs, RTW_CR_TE, 0);
		rtw_txdescs_reset(sc);
		rtw_io_enable(&sc->sc_regs, RTW_CR_TE, 1);
		rtw_txring_fixup(sc);
		rtw_start(ifp);
	}
	ieee80211_watchdog(ifp);
}

void
rtw_next_scan(void *arg)
{
	struct rtw_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	/* don't call rtw_start w/o network interrupts blocked */
	s = splnet();
	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
	splx(s);
}

void
rtw_join_bss(struct rtw_softc *sc, u_int8_t *bssid, u_int16_t intval0)
{
	uint16_t bcnitv, bintritv, intval;
	int i;
	struct rtw_regs *regs = &sc->sc_regs;

	for (i = 0; i < IEEE80211_ADDR_LEN; i++)
		RTW_WRITE8(regs, RTW_BSSID + i, bssid[i]);

	RTW_SYNC(regs, RTW_BSSID16, RTW_BSSID32);

	rtw_set_access(regs, RTW_ACCESS_CONFIG);

	intval = MIN(intval0, PRESHIFT(RTW_BCNITV_BCNITV_MASK));

	bcnitv = RTW_READ16(regs, RTW_BCNITV) & ~RTW_BCNITV_BCNITV_MASK;
	bcnitv |= LSHIFT(intval, RTW_BCNITV_BCNITV_MASK);
	RTW_WRITE16(regs, RTW_BCNITV, bcnitv);
	/* interrupt host 1ms before the TBTT */
	bintritv = RTW_READ16(regs, RTW_BINTRITV) & ~RTW_BINTRITV_BINTRITV;
	bintritv |= LSHIFT(1000, RTW_BINTRITV_BINTRITV);
	RTW_WRITE16(regs, RTW_BINTRITV, bintritv);
	/* magic from Linux */
	RTW_WRITE16(regs, RTW_ATIMWND, LSHIFT(1, RTW_ATIMWND_ATIMWND));
	RTW_WRITE16(regs, RTW_ATIMTRITV, LSHIFT(2, RTW_ATIMTRITV_ATIMTRITV));
	rtw_set_access(regs, RTW_ACCESS_NONE);

	/* TBD WEP */
	RTW_WRITE8(regs, RTW8180_SCR, 0);

	rtw_io_enable(regs, RTW_CR_RE | RTW_CR_TE, 1);
}

/* Synchronize the hardware state with the software state. */
int
rtw_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ifnet *ifp = &ic->ic_if;
	struct rtw_softc *sc = ifp->if_softc;
	enum ieee80211_state ostate;
	int error;

	ostate = ic->ic_state;

	rtw_led_newstate(sc, nstate);

	if (nstate == IEEE80211_S_INIT) {
		timeout_del(&sc->sc_scan_to);
		sc->sc_cur_chan = IEEE80211_CHAN_ANY;
		return (*sc->sc_mtbl.mt_newstate)(ic, nstate, arg);
	}

	if (ostate == IEEE80211_S_INIT && nstate != IEEE80211_S_INIT)
		rtw_pwrstate(sc, RTW_ON);

	if ((error = rtw_tune(sc)) != 0)
		return error;

	switch (nstate) {
	case IEEE80211_S_INIT:
		panic("%s: unexpected state IEEE80211_S_INIT", __func__);
		break;
	case IEEE80211_S_SCAN:
		if (ostate != IEEE80211_S_SCAN) {
			bzero(ic->ic_bss->ni_bssid, IEEE80211_ADDR_LEN);
			rtw_set_nettype(sc, IEEE80211_M_MONITOR);
		}

		timeout_add_msec(&sc->sc_scan_to, rtw_dwelltime);

		break;
	case IEEE80211_S_RUN:
		switch (ic->ic_opmode) {
#ifndef IEEE80211_STA_ONLY
		case IEEE80211_M_HOSTAP:
		case IEEE80211_M_IBSS:
			rtw_set_nettype(sc, IEEE80211_M_MONITOR);
			/*FALLTHROUGH*/
		case IEEE80211_M_AHDEMO:
#endif
		case IEEE80211_M_STA:
			rtw_join_bss(sc, ic->ic_bss->ni_bssid,
			    ic->ic_bss->ni_intval);
			break;
		default:
			break;
		}
		rtw_set_nettype(sc, ic->ic_opmode);
		break;
	case IEEE80211_S_ASSOC:
	case IEEE80211_S_AUTH:
		break;
	}

	if (nstate != IEEE80211_S_SCAN)
		timeout_del(&sc->sc_scan_to);

	return (*sc->sc_mtbl.mt_newstate)(ic, nstate, arg);
}

/* Extend a 32-bit TSF timestamp to a 64-bit timestamp. */
uint64_t
rtw_tsf_extend(struct rtw_regs *regs, u_int32_t rstamp)
{
	u_int32_t tsftl, tsfth;

	tsfth = RTW_READ(regs, RTW_TSFTRH);
	tsftl = RTW_READ(regs, RTW_TSFTRL);
	if (tsftl < rstamp)	/* Compensate for rollover. */
		tsfth--;
	return ((u_int64_t)tsfth << 32) | rstamp;
}

#ifndef IEEE80211_STA_ONLY
void
rtw_ibss_merge(struct rtw_softc *sc, struct ieee80211_node *ni,
    u_int32_t rstamp)
{
	u_int8_t tppoll;
	struct ieee80211com *ic = &sc->sc_ic;

	if (ieee80211_ibss_merge(ic, ni,
	    rtw_tsf_extend(&sc->sc_regs, rstamp)) == ENETRESET) {
		/* Stop beacon queue.  Kick state machine to synchronize
		 * with the new IBSS.
		 */
		tppoll = RTW_READ8(&sc->sc_regs, RTW_TPPOLL);
		tppoll |= RTW_TPPOLL_SBQ;
		RTW_WRITE8(&sc->sc_regs, RTW_TPPOLL, tppoll);
		(void)ieee80211_new_state(&sc->sc_ic, IEEE80211_S_RUN, -1);
	}
	return;
}

void
rtw_recv_mgmt(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, struct ieee80211_rxinfo *rxi, int subtype)
{
	struct rtw_softc *sc = (struct rtw_softc*)ic->ic_softc;

	(*sc->sc_mtbl.mt_recv_mgmt)(ic, m, ni, rxi, subtype);

	switch (subtype) {
	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
	case IEEE80211_FC0_SUBTYPE_BEACON:
		if (ic->ic_opmode != IEEE80211_M_IBSS ||
		    ic->ic_state != IEEE80211_S_RUN)
			return;
		rtw_ibss_merge(sc, ni, rxi->rxi_tstamp);
		break;
	default:
		break;
	}
	return;
}
#endif	/* IEEE80211_STA_ONLY */

struct ieee80211_node *
rtw_node_alloc(struct ieee80211com *ic)
{
	struct rtw_softc *sc = (struct rtw_softc *)ic->ic_if.if_softc;
	struct ieee80211_node *ni = (*sc->sc_mtbl.mt_node_alloc)(ic);

	DPRINTF(sc, RTW_DEBUG_NODE,
	    ("%s: alloc node %p\n", sc->sc_dev.dv_xname, ni));
	return ni;
}

void
rtw_node_free(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct rtw_softc *sc = (struct rtw_softc *)ic->ic_if.if_softc;

	DPRINTF(sc, RTW_DEBUG_NODE,
	    ("%s: freeing node %p %s\n", sc->sc_dev.dv_xname, ni,
	    ether_sprintf(ni->ni_bssid)));
	(*sc->sc_mtbl.mt_node_free)(ic, ni);
}

int
rtw_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) ==
		    (IFF_RUNNING|IFF_UP))
			rtw_init(ifp);		/* XXX lose error */
		error = 0;
	}
	return error;
}

void
rtw_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct rtw_softc *sc = ifp->if_softc;

	if ((sc->sc_flags & RTW_F_ENABLED) == 0) {
		imr->ifm_active = IFM_IEEE80211 | IFM_NONE;
		imr->ifm_status = 0;
		return;
	}
	ieee80211_media_status(ifp, imr);
}

int
rtw_activate(struct device *self, int act)
{
	struct rtw_softc *sc = (struct rtw_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING) {
			rtw_stop(ifp, 1);
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, act);
		}
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP) {
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, act);
			rtw_init(ifp);
		}
		break;
	}
	return 0;
}

int
rtw_txsoft_blk_setup(struct rtw_txsoft_blk *tsb, u_int qlen)
{
	SIMPLEQ_INIT(&tsb->tsb_dirtyq);
	SIMPLEQ_INIT(&tsb->tsb_freeq);
	tsb->tsb_ndesc = qlen;
	tsb->tsb_desc = mallocarray(qlen, sizeof(*tsb->tsb_desc), M_DEVBUF,
	    M_NOWAIT);
	if (tsb->tsb_desc == NULL)
		return ENOMEM;
	return 0;
}

void
rtw_txsoft_blk_cleanup_all(struct rtw_softc *sc)
{
	int pri;
	struct rtw_txsoft_blk *tsb;

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		tsb = &sc->sc_txsoft_blk[pri];
		free(tsb->tsb_desc, M_DEVBUF, 0);
		tsb->tsb_desc = NULL;
	}
}

int
rtw_txsoft_blk_setup_all(struct rtw_softc *sc)
{
	int pri, rc = 0;
	int qlen[RTW_NTXPRI] =
	     {RTW_TXQLENLO, RTW_TXQLENMD, RTW_TXQLENHI, RTW_TXQLENBCN};
	struct rtw_txsoft_blk *tsbs;

	tsbs = sc->sc_txsoft_blk;

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		rc = rtw_txsoft_blk_setup(&tsbs[pri], qlen[pri]);
		if (rc != 0)
			break;
	}
	tsbs[RTW_TXPRILO].tsb_poll = RTW_TPPOLL_LPQ | RTW_TPPOLL_SLPQ;
	tsbs[RTW_TXPRIMD].tsb_poll = RTW_TPPOLL_NPQ | RTW_TPPOLL_SNPQ;
	tsbs[RTW_TXPRIHI].tsb_poll = RTW_TPPOLL_HPQ | RTW_TPPOLL_SHPQ;
	tsbs[RTW_TXPRIBCN].tsb_poll = RTW_TPPOLL_BQ | RTW_TPPOLL_SBQ;
	return rc;
}

void
rtw_txdesc_blk_setup(struct rtw_txdesc_blk *tdb, struct rtw_txdesc *desc,
    u_int ndesc, bus_addr_t ofs, bus_addr_t physbase)
{
	tdb->tdb_ndesc = ndesc;
	tdb->tdb_desc = desc;
	tdb->tdb_physbase = physbase;
	tdb->tdb_ofs = ofs;

	bzero(tdb->tdb_desc, sizeof(tdb->tdb_desc[0]) * tdb->tdb_ndesc);

	rtw_txdesc_blk_init(tdb);
	tdb->tdb_next = 0;
}

void
rtw_txdesc_blk_setup_all(struct rtw_softc *sc)
{
	rtw_txdesc_blk_setup(&sc->sc_txdesc_blk[RTW_TXPRILO],
	    &sc->sc_descs->hd_txlo[0], RTW_NTXDESCLO,
	    RTW_RING_OFFSET(hd_txlo), RTW_RING_BASE(sc, hd_txlo));

	rtw_txdesc_blk_setup(&sc->sc_txdesc_blk[RTW_TXPRIMD],
	    &sc->sc_descs->hd_txmd[0], RTW_NTXDESCMD,
	    RTW_RING_OFFSET(hd_txmd), RTW_RING_BASE(sc, hd_txmd));

	rtw_txdesc_blk_setup(&sc->sc_txdesc_blk[RTW_TXPRIHI],
	    &sc->sc_descs->hd_txhi[0], RTW_NTXDESCHI,
	    RTW_RING_OFFSET(hd_txhi), RTW_RING_BASE(sc, hd_txhi));

	rtw_txdesc_blk_setup(&sc->sc_txdesc_blk[RTW_TXPRIBCN],
	    &sc->sc_descs->hd_bcn[0], RTW_NTXDESCBCN,
	    RTW_RING_OFFSET(hd_bcn), RTW_RING_BASE(sc, hd_bcn));
}

int
rtw_rf_attach(struct rtw_softc *sc, int rfchipid)
{
	struct rtw_bbpset *bb = &sc->sc_bbpset;
	int notsup = 0;
	const char *rfname, *paname = NULL;
	char scratch[sizeof("unknown 0xXX")];

	switch (rfchipid) {
	case RTW_RFCHIPID_RTL8225:
		rfname = "RTL8225";
		sc->sc_pwrstate_cb = rtw_rtl_pwrstate;
		sc->sc_rf_init = rtw_rtl8255_init;
		sc->sc_rf_pwrstate = rtw_rtl8225_pwrstate;
		sc->sc_rf_tune = rtw_rtl8225_tune;
		sc->sc_rf_txpower = rtw_rtl8225_txpower;
		break;
	case RTW_RFCHIPID_RTL8255:
		rfname = "RTL8255";
		sc->sc_pwrstate_cb = rtw_rtl_pwrstate;
		sc->sc_rf_init = rtw_rtl8255_init;
		sc->sc_rf_pwrstate = rtw_rtl8255_pwrstate;
		sc->sc_rf_tune = rtw_rtl8255_tune;
		sc->sc_rf_txpower = rtw_rtl8255_txpower;
		break;
	case RTW_RFCHIPID_MAXIM2820:
		rfname = "MAX2820";	/* guess */
		paname = "MAX2422";	/* guess */
		/* XXX magic */
		bb->bb_antatten = RTW_BBP_ANTATTEN_MAXIM_MAGIC;
		bb->bb_chestlim =	0x00;
		bb->bb_chsqlim =	0x9f;
		bb->bb_ifagcdet =	0x64;
		bb->bb_ifagcini =	0x90;
		bb->bb_ifagclimit =	0x1a;
		bb->bb_lnadet =		0xf8;
		bb->bb_sys1 =		0x88;
		bb->bb_sys2 =		0x47;
		bb->bb_sys3 =		0x9b;
		bb->bb_trl =		0x88;
		bb->bb_txagc =		0x08;
		sc->sc_pwrstate_cb = rtw_maxim_pwrstate;
		sc->sc_rf_init = rtw_max2820_init;
		sc->sc_rf_pwrstate = rtw_max2820_pwrstate;
		sc->sc_rf_tune = rtw_max2820_tune;
		sc->sc_rf_txpower = rtw_max2820_txpower;
		break;
	case RTW_RFCHIPID_PHILIPS:
		rfname = "SA2400A";
		paname = "SA2411";
		/* XXX magic */
		bb->bb_antatten = RTW_BBP_ANTATTEN_PHILIPS_MAGIC;
		bb->bb_chestlim =	0x00;
		bb->bb_chsqlim =	0xa0;
		bb->bb_ifagcdet =	0x64;
		bb->bb_ifagcini =	0x90;
		bb->bb_ifagclimit =	0x1a;
		bb->bb_lnadet =		0xe0;
		bb->bb_sys1 =		0x98;
		bb->bb_sys2 =		0x47;
		bb->bb_sys3 =		0x90;
		bb->bb_trl =		0x88;
		bb->bb_txagc =		0x38;
		sc->sc_pwrstate_cb = rtw_philips_pwrstate;
		sc->sc_rf_init = rtw_sa2400_init;
		sc->sc_rf_pwrstate = rtw_sa2400_pwrstate;
		sc->sc_rf_tune = rtw_sa2400_tune;
		sc->sc_rf_txpower = rtw_sa2400_txpower;
		break;
	case RTW_RFCHIPID_RFMD2948:
		/* this is the same front-end as an atw(4)! */
		rfname = "RFMD RF2948B, "	/* mentioned in Realtek docs */
			 "LNA: RFMD RF2494, "	/* mentioned in Realtek docs */
			 "SYN: Silicon Labs Si4126";	 /* inferred from
							  * reference driver
							  */
		paname = "RF2189";		/* mentioned in Realtek docs */
		/* XXX RFMD has no RF constructor */
		sc->sc_pwrstate_cb = rtw_rfmd_pwrstate;
		notsup =  1;
		break;
	case RTW_RFCHIPID_GCT:		/* this combo seen in the wild */
		rfname = "GRF5101";
		paname = "WS9901";
		/* XXX magic */
		bb->bb_antatten = RTW_BBP_ANTATTEN_GCT_MAGIC;
		bb->bb_chestlim =	0x00;
		bb->bb_chsqlim =	0xa0;
		bb->bb_ifagcdet =	0x64;
		bb->bb_ifagcini =	0x90;
		bb->bb_ifagclimit =	0x1e;
		bb->bb_lnadet =		0xc0;
		bb->bb_sys1 =		0xa8;
		bb->bb_sys2 =		0x47;
		bb->bb_sys3 =		0x9b;
		bb->bb_trl =		0x88;
		bb->bb_txagc =		0x08;
		sc->sc_pwrstate_cb = rtw_maxim_pwrstate;
		sc->sc_rf_init = rtw_grf5101_init;
		sc->sc_rf_pwrstate = rtw_grf5101_pwrstate;
		sc->sc_rf_tune = rtw_grf5101_tune;
		sc->sc_rf_txpower = rtw_grf5101_txpower;
		break;
	case RTW_RFCHIPID_INTERSIL:
		rfname = "HFA3873";	/* guess */
		paname = "Intersil <unknown>";
		notsup = 1;
		break;
	default:
		snprintf(scratch, sizeof(scratch), "unknown 0x%02x", rfchipid);
		rfname = scratch;
		notsup = 1;
	}

	printf("radio %s, ", rfname);
	if (paname != NULL)
		printf("amp %s, ", paname);

	return (notsup);
}

/* Revision C and later use a different PHY delay setting than
 * revisions A and B.
 */
u_int8_t
rtw_check_phydelay(struct rtw_regs *regs, u_int32_t rcr0)
{
#define REVAB (RTW_RCR_MXDMA_UNLIMITED | RTW_RCR_AICV)
#define REVC (REVAB | RTW8180_RCR_RXFTH_WHOLE)

	u_int8_t phydelay = LSHIFT(0x6, RTW_PHYDELAY_PHYDELAY);

	RTW_WRITE(regs, RTW_RCR, REVAB);
	RTW_WBW(regs, RTW_RCR, RTW_RCR);
	RTW_WRITE(regs, RTW_RCR, REVC);

	RTW_WBR(regs, RTW_RCR, RTW_RCR);
	if ((RTW_READ(regs, RTW_RCR) & REVC) == REVC)
		phydelay |= RTW_PHYDELAY_REVC_MAGIC;

	RTW_WRITE(regs, RTW_RCR, rcr0);	/* restore RCR */
	RTW_SYNC(regs, RTW_RCR, RTW_RCR);

	return phydelay;
#undef REVC
}

void
rtw_attach(struct rtw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rtw_txsoft_blk *tsb;
	struct rtw_mtbl *mtbl;
	struct rtw_srom *sr;
	const char *vername;
	struct ifnet *ifp;
	char scratch[sizeof("unknown 0xXXXXXXXX")];
	int pri, rc, i;


	/* Use default DMA memory access */
	if (sc->sc_regs.r_read8 == NULL) {
		sc->sc_regs.r_read8 = rtw_read8;
		sc->sc_regs.r_read16 = rtw_read16;
		sc->sc_regs.r_read32 = rtw_read32;
		sc->sc_regs.r_write8 = rtw_write8;
		sc->sc_regs.r_write16 = rtw_write16;
		sc->sc_regs.r_write32 = rtw_write32;
		sc->sc_regs.r_barrier = rtw_barrier;
	}

	sc->sc_hwverid = RTW_READ(&sc->sc_regs, RTW_TCR) & RTW_TCR_HWVERID_MASK;
	switch (sc->sc_hwverid) {
	case RTW_TCR_HWVERID_RTL8185:
		vername = "RTL8185";
		sc->sc_flags |= RTW_F_RTL8185;
		break;
	case RTW_TCR_HWVERID_RTL8180F:
		vername = "RTL8180F";
		break;
	case RTW_TCR_HWVERID_RTL8180D:
		vername = "RTL8180D";
		break;
	default:
		snprintf(scratch, sizeof(scratch), "unknown 0x%08x",
		    sc->sc_hwverid);
		vername = scratch;
		break;
	}

	printf("%s: ver %s, ", sc->sc_dev.dv_xname, vername);

	rc = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct rtw_descs),
	    RTW_DESC_ALIGNMENT, 0, &sc->sc_desc_segs, 1, &sc->sc_desc_nsegs,
	    0);

	if (rc != 0) {
		printf("\n%s: could not allocate hw descriptors, error %d\n",
		     sc->sc_dev.dv_xname, rc);
		goto fail0;
	}

	rc = bus_dmamem_map(sc->sc_dmat, &sc->sc_desc_segs,
	    sc->sc_desc_nsegs, sizeof(struct rtw_descs),
	    (caddr_t*)&sc->sc_descs, BUS_DMA_COHERENT);

	if (rc != 0) {
		printf("\n%s: can't map hw descriptors, error %d\n",
		    sc->sc_dev.dv_xname, rc);
		goto fail1;
	}

	rc = bus_dmamap_create(sc->sc_dmat, sizeof(struct rtw_descs), 1,
	    sizeof(struct rtw_descs), 0, 0, &sc->sc_desc_dmamap);

	if (rc != 0) {
		printf("\n%s: could not create DMA map for hw descriptors, "
		    "error %d\n", sc->sc_dev.dv_xname, rc);
		goto fail2;
	}

	sc->sc_rxdesc_blk.rdb_dmat = sc->sc_dmat;
	sc->sc_rxdesc_blk.rdb_dmamap = sc->sc_desc_dmamap;

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		sc->sc_txdesc_blk[pri].tdb_dmat = sc->sc_dmat;
		sc->sc_txdesc_blk[pri].tdb_dmamap = sc->sc_desc_dmamap;
	}

	rc = bus_dmamap_load(sc->sc_dmat, sc->sc_desc_dmamap, sc->sc_descs,
	    sizeof(struct rtw_descs), NULL, 0);

	if (rc != 0) {
		printf("\n%s: could not load DMA map for hw descriptors, "
		    "error %d\n", sc->sc_dev.dv_xname, rc);
		goto fail3;
	}

	if (rtw_txsoft_blk_setup_all(sc) != 0)
		goto fail4;

	rtw_txdesc_blk_setup_all(sc);

	sc->sc_rxdesc_blk.rdb_desc = &sc->sc_descs->hd_rx[0];

	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		tsb = &sc->sc_txsoft_blk[pri];

		if ((rc = rtw_txdesc_dmamaps_create(sc->sc_dmat,
		    &tsb->tsb_desc[0], tsb->tsb_ndesc)) != 0) {
			printf("\n%s: could not load DMA map for "
			    "hw tx descriptors, error %d\n",
			    sc->sc_dev.dv_xname, rc);
			goto fail5;
		}
	}

	if ((rc = rtw_rxdesc_dmamaps_create(sc->sc_dmat, &sc->sc_rxsoft[0],
	    RTW_RXQLEN)) != 0) {
		printf("\n%s: could not load DMA map for hw rx descriptors, "
		    "error %d\n", sc->sc_dev.dv_xname, rc);
		goto fail6;
	}

	/* Reset the chip to a known state. */
	if (rtw_reset(sc) != 0)
		goto fail7;

	sc->sc_rcr = RTW_READ(&sc->sc_regs, RTW_RCR);

	if ((sc->sc_rcr & RTW_RCR_9356SEL) != 0)
		sc->sc_flags |= RTW_F_9356SROM;

	if (rtw_srom_read(&sc->sc_regs, sc->sc_flags, &sc->sc_srom,
	    sc->sc_dev.dv_xname) != 0)
		goto fail7;

	if (rtw_srom_parse(sc) != 0) {
		printf("\n%s: attach failed, malformed serial ROM\n",
		    sc->sc_dev.dv_xname);
		goto fail8;
	}

	RTW_DPRINTF(RTW_DEBUG_ATTACH, ("%s: %s PHY\n", sc->sc_dev.dv_xname,
	    ((sc->sc_flags & RTW_F_DIGPHY) != 0) ? "digital" : "analog"));

	RTW_DPRINTF(RTW_DEBUG_ATTACH, ("%s: CS threshold %u\n",
	    sc->sc_dev.dv_xname, sc->sc_csthr));

	if ((rtw_rf_attach(sc, sc->sc_rfchipid)) != 0) {
		printf("\n%s: attach failed, could not attach RF\n",
		    sc->sc_dev.dv_xname);
		goto fail8;
	}

	sc->sc_phydelay = rtw_check_phydelay(&sc->sc_regs, sc->sc_rcr);

	RTW_DPRINTF(RTW_DEBUG_ATTACH,
	    ("%s: PHY delay %d\n", sc->sc_dev.dv_xname, sc->sc_phydelay));

	if (sc->sc_locale == RTW_LOCALE_UNKNOWN)
		rtw_identify_country(&sc->sc_regs, &sc->sc_locale);

	for (i = 1; i <= 14; i++) {
		sc->sc_ic.ic_channels[i].ic_flags = IEEE80211_CHAN_B;
		sc->sc_ic.ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, sc->sc_ic.ic_channels[i].ic_flags);
	}

	if (rtw_identify_sta(&sc->sc_regs, &sc->sc_ic.ic_myaddr,
	    sc->sc_dev.dv_xname) != 0)
		goto fail8;

	ifp = &sc->sc_if;
	(void)memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	ifp->if_ioctl = rtw_ioctl;
	ifp->if_start = rtw_start;
	ifp->if_watchdog = rtw_watchdog;


	ic->ic_phytype = IEEE80211_T_DS;
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_caps = IEEE80211_C_PMGT | IEEE80211_C_MONITOR | IEEE80211_C_WEP;
#ifndef IEEE80211_STA_ONLY
	ic->ic_caps |= IEEE80211_C_HOSTAP | IEEE80211_C_IBSS;
#endif
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;

	rtw_led_attach(&sc->sc_led_state, (void *)sc);

	/*
	 * Call MI attach routines.
	 */
	if_attach(&sc->sc_if);
	ieee80211_ifattach(&sc->sc_if);

	mtbl = &sc->sc_mtbl;
	mtbl->mt_newstate = ic->ic_newstate;
	ic->ic_newstate = rtw_newstate;

#ifndef IEEE80211_STA_ONLY
	mtbl->mt_recv_mgmt = ic->ic_recv_mgmt;
	ic->ic_recv_mgmt = rtw_recv_mgmt;
#endif

	mtbl->mt_node_free = ic->ic_node_free;
	ic->ic_node_free = rtw_node_free;

	mtbl->mt_node_alloc = ic->ic_node_alloc;
	ic->ic_node_alloc = rtw_node_alloc;

	/* possibly we should fill in our own sc_send_prresp, since
	 * the RTL8180 is probably sending probe responses in ad hoc
	 * mode.
	 */

	/* complete initialization */
	ieee80211_media_init(&sc->sc_if, rtw_media_change, rtw_media_status);
	timeout_set(&sc->sc_scan_to, rtw_next_scan, sc);

#if NBPFILTER > 0
	bzero(&sc->sc_rxtapu, sizeof(sc->sc_rxtapu));
	sc->sc_rxtap.rr_ihdr.it_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.rr_ihdr.it_present = RTW_RX_RADIOTAP_PRESENT;

	bzero(&sc->sc_txtapu, sizeof(sc->sc_txtapu));
	sc->sc_txtap.rt_ihdr.it_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.rt_ihdr.it_present = RTW_TX_RADIOTAP_PRESENT;

	bpfattach(&sc->sc_radiobpf, &sc->sc_ic.ic_if, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + 64);
#endif
	return;

fail8:
	sr = &sc->sc_srom;
	if (sr->sr_content != NULL) {
		free(sr->sr_content, M_DEVBUF, sr->sr_size);
		sr->sr_content = NULL;
	}
	sr->sr_size = 0;

fail7:
	rtw_rxdesc_dmamaps_destroy(sc->sc_dmat, &sc->sc_rxsoft[0],
	    RTW_RXQLEN);

fail6:
	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		rtw_txdesc_dmamaps_destroy(sc->sc_dmat,
		    sc->sc_txsoft_blk[pri].tsb_desc,
		    sc->sc_txsoft_blk[pri].tsb_ndesc);
	}

fail5:
	rtw_txsoft_blk_cleanup_all(sc);

fail4:
	bus_dmamap_unload(sc->sc_dmat, sc->sc_desc_dmamap);
fail3:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_desc_dmamap);
fail2:
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_descs,
	    sizeof(struct rtw_descs));
fail1:
	bus_dmamem_free(sc->sc_dmat, &sc->sc_desc_segs,
	    sc->sc_desc_nsegs);
fail0:
	return;
}

int
rtw_detach(struct rtw_softc *sc)
{
	sc->sc_flags |= RTW_F_INVALID;

	timeout_del(&sc->sc_scan_to);

	rtw_stop(&sc->sc_if, 1);

	ieee80211_ifdetach(&sc->sc_if);
	if_detach(&sc->sc_if);

	return 0;
}

/*
 * PHY specific functions
 */

int
rtw_bbp_preinit(struct rtw_regs *regs, u_int antatten0, int dflantb,
    u_int freq)
{
	u_int antatten = antatten0;
	if (dflantb)
		antatten |= RTW_BBP_ANTATTEN_DFLANTB;
	if (freq == 2484) /* channel 14 */
		antatten |= RTW_BBP_ANTATTEN_CHAN14;
	return rtw_bbp_write(regs, RTW_BBP_ANTATTEN, antatten);
}

int
rtw_bbp_init(struct rtw_regs *regs, struct rtw_bbpset *bb, int antdiv,
    int dflantb, u_int8_t cs_threshold, u_int freq)
{
	int rc;
	u_int32_t sys2, sys3;

	sys2 = bb->bb_sys2;
	if (antdiv)
		sys2 |= RTW_BBP_SYS2_ANTDIV;
	sys3 = bb->bb_sys3 |
	    LSHIFT(cs_threshold, RTW_BBP_SYS3_CSTHRESH_MASK);

#define	RTW_BBP_WRITE_OR_RETURN(reg, val) \
	if ((rc = rtw_bbp_write(regs, reg, val)) != 0) \
		return rc;

	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_SYS1,		bb->bb_sys1);
	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_TXAGC,		bb->bb_txagc);
	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_LNADET,		bb->bb_lnadet);
	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_IFAGCINI,	bb->bb_ifagcini);
	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_IFAGCLIMIT,	bb->bb_ifagclimit);
	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_IFAGCDET,	bb->bb_ifagcdet);

	if ((rc = rtw_bbp_preinit(regs, bb->bb_antatten, dflantb, freq)) != 0)
		return rc;

	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_TRL,		bb->bb_trl);
	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_SYS2,		sys2);
	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_SYS3,		sys3);
	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_CHESTLIM,	bb->bb_chestlim);
	RTW_BBP_WRITE_OR_RETURN(RTW_BBP_CHSQLIM,	bb->bb_chsqlim);
	return 0;
}

int
rtw_sa2400_txpower(struct rtw_softc *sc, u_int8_t opaque_txpower)
{
	return rtw_rf_macwrite(sc, SA2400_TX, opaque_txpower);
}

/* make sure we're using the same settings as the reference driver */
void
rtw_verify_syna(u_int freq, u_int32_t val)
{
	u_int32_t expected_val = ~val;

	switch (freq) {
	case 2412:
		expected_val = 0x0000096c; /* ch 1 */
		break;
	case 2417:
		expected_val = 0x00080970; /* ch 2 */
		break;
	case 2422:
		expected_val = 0x00100974; /* ch 3 */
		break;
	case 2427:
		expected_val = 0x00180978; /* ch 4 */
		break;
	case 2432:
		expected_val = 0x00000980; /* ch 5 */
		break;
	case 2437:
		expected_val = 0x00080984; /* ch 6 */
		break;
	case 2442:
		expected_val = 0x00100988; /* ch 7 */
		break;
	case 2447:
		expected_val = 0x0018098c; /* ch 8 */
		break;
	case 2452:
		expected_val = 0x00000994; /* ch 9 */
		break;
	case 2457:
		expected_val = 0x00080998; /* ch 10 */
		break;
	case 2462:
		expected_val = 0x0010099c; /* ch 11 */
		break;
	case 2467:
		expected_val = 0x001809a0; /* ch 12 */
		break;
	case 2472:
		expected_val = 0x000009a8; /* ch 13 */
		break;
	case 2484:
		expected_val = 0x000009b4; /* ch 14 */
		break;
	}
	KASSERT(val == expected_val);
}

/* freq is in MHz */
int
rtw_sa2400_tune(struct rtw_softc *sc, u_int freq)
{
	int rc;
	u_int32_t syna, synb, sync;

	/* XO = 44MHz, R = 11, hence N is in units of XO / R = 4MHz.
	 *
	 * The channel spacing (5MHz) is not divisible by 4MHz, so
	 * we set the fractional part of N to compensate.
	 */
	int n = freq / 4, nf = (freq % 4) * 2;

	syna = LSHIFT(nf, SA2400_SYNA_NF_MASK) | LSHIFT(n, SA2400_SYNA_N_MASK);
	rtw_verify_syna(freq, syna);

	/* Divide the 44MHz crystal down to 4MHz. Set the fractional
	 * compensation charge pump value to agree with the fractional
	 * modulus.
	 */
	synb = LSHIFT(11, SA2400_SYNB_R_MASK) | SA2400_SYNB_L_NORMAL |
	    SA2400_SYNB_ON | SA2400_SYNB_ONE |
	    LSHIFT(80, SA2400_SYNB_FC_MASK); /* agrees w/ SA2400_SYNA_FM = 0 */

	sync = SA2400_SYNC_CP_NORMAL;

	if ((rc = rtw_rf_macwrite(sc, SA2400_SYNA, syna)) != 0)
		return rc;
	if ((rc = rtw_rf_macwrite(sc, SA2400_SYNB, synb)) != 0)
		return rc;
	if ((rc = rtw_rf_macwrite(sc, SA2400_SYNC, sync)) != 0)
		return rc;
	return rtw_rf_macwrite(sc, SA2400_SYND, 0x0);
}

int
rtw_sa2400_pwrstate(struct rtw_softc *sc, enum rtw_pwrstate power)
{
	u_int32_t opmode;
	opmode = SA2400_OPMODE_DEFAULTS;
	switch (power) {
	case RTW_ON:
		opmode |= SA2400_OPMODE_MODE_TXRX;
		break;
	case RTW_SLEEP:
		opmode |= SA2400_OPMODE_MODE_WAIT;
		break;
	case RTW_OFF:
		opmode |= SA2400_OPMODE_MODE_SLEEP;
		break;
	}

	if (sc->sc_flags & RTW_F_DIGPHY)
		opmode |= SA2400_OPMODE_DIGIN;

	return rtw_rf_macwrite(sc, SA2400_OPMODE, opmode);
}

int
rtw_sa2400_vcocal_start(struct rtw_softc *sc, int start)
{
	u_int32_t opmode;

	opmode = SA2400_OPMODE_DEFAULTS;
	if (start)
		opmode |= SA2400_OPMODE_MODE_VCOCALIB;
	else
		opmode |= SA2400_OPMODE_MODE_SLEEP;

	if (sc->sc_flags & RTW_F_DIGPHY)
		opmode |= SA2400_OPMODE_DIGIN;

	return rtw_rf_macwrite(sc, SA2400_OPMODE, opmode);
}

int
rtw_sa2400_vco_calibration(struct rtw_softc *sc)
{
	int rc;
	/* calibrate VCO */
	if ((rc = rtw_sa2400_vcocal_start(sc, 1)) != 0)
		return rc;
	DELAY(2200);	/* 2.2 milliseconds */
	/* XXX superfluous: SA2400 automatically entered SLEEP mode. */
	return rtw_sa2400_vcocal_start(sc, 0);
}

int
rtw_sa2400_filter_calibration(struct rtw_softc *sc)
{
	u_int32_t opmode;

	opmode = SA2400_OPMODE_DEFAULTS | SA2400_OPMODE_MODE_FCALIB;
	if (sc->sc_flags & RTW_F_DIGPHY)
		opmode |= SA2400_OPMODE_DIGIN;

	return rtw_rf_macwrite(sc, SA2400_OPMODE, opmode);
}

int
rtw_sa2400_dc_calibration(struct rtw_softc *sc)
{
	int rc;
	u_int32_t dccal;

	rtw_continuous_tx_enable(sc, 1);

	dccal = SA2400_OPMODE_DEFAULTS | SA2400_OPMODE_MODE_TXRX;

	rc = rtw_rf_macwrite(sc, SA2400_OPMODE, dccal);

	if (rc != 0)
		return rc;

	DELAY(5);	/* DCALIB after being in Tx mode for 5
			 * microseconds
			 */

	dccal &= ~SA2400_OPMODE_MODE_MASK;
	dccal |= SA2400_OPMODE_MODE_DCALIB;

	rc = rtw_rf_macwrite(sc, SA2400_OPMODE, dccal);
	if (rc != 0)
		return rc;

	DELAY(20);	/* calibration takes at most 20 microseconds */

	rtw_continuous_tx_enable(sc, 0);

	return 0;
}

int
rtw_sa2400_calibrate(struct rtw_softc *sc, u_int freq)
{
	int i, rc;

	/* XXX reference driver calibrates VCO twice. Is it a bug? */
	for (i = 0; i < 2; i++) {
		if ((rc = rtw_sa2400_vco_calibration(sc)) != 0)
			return rc;
	}
	/* VCO calibration erases synthesizer registers, so re-tune */
	if ((rc = rtw_sa2400_tune(sc, freq)) != 0)
		return rc;
	if ((rc = rtw_sa2400_filter_calibration(sc)) != 0)
		return rc;
	/* analog PHY needs DC calibration */
	if (!(sc->sc_flags & RTW_F_DIGPHY))
		return rtw_sa2400_dc_calibration(sc);
	return 0;
}

int
rtw_sa2400_init(struct rtw_softc *sc, u_int freq, u_int8_t opaque_txpower,
    enum rtw_pwrstate power)
{
	int rc;
	u_int32_t agc, manrx;

	if ((rc = rtw_sa2400_txpower(sc, opaque_txpower)) != 0)
		return rc;

	/* skip configuration if it's time to sleep or to power-down. */
	if (power == RTW_SLEEP || power == RTW_OFF)
		return rtw_sa2400_pwrstate(sc, power);

	/* go to sleep for configuration */
	if ((rc = rtw_sa2400_pwrstate(sc, RTW_SLEEP)) != 0)
		return rc;

	if ((rc = rtw_sa2400_tune(sc, freq)) != 0)
		return rc;

	agc = LSHIFT(25, SA2400_AGC_MAXGAIN_MASK);
	agc |= LSHIFT(7, SA2400_AGC_BBPDELAY_MASK);
	agc |= LSHIFT(15, SA2400_AGC_LNADELAY_MASK);
	agc |= LSHIFT(27, SA2400_AGC_RXONDELAY_MASK);

	if ((rc = rtw_rf_macwrite(sc, SA2400_AGC, agc)) != 0)
		return rc;

	/* XXX we are not supposed to be in RXMGC mode when we do this? */
	manrx = SA2400_MANRX_AHSN;
	manrx |= SA2400_MANRX_TEN;
	manrx |= LSHIFT(1023, SA2400_MANRX_RXGAIN_MASK);

	if ((rc = rtw_rf_macwrite(sc, SA2400_MANRX, manrx)) != 0)
		return rc;

	if ((rc = rtw_sa2400_calibrate(sc, freq)) != 0)
		return rc;

	/* enter Tx/Rx mode */
	return rtw_sa2400_pwrstate(sc, power);
}

/* freq is in MHz */
int
rtw_max2820_tune(struct rtw_softc *sc, u_int freq)
{
	if (freq < 2400 || freq > 2499)
		return -1;

	return rtw_rf_hostwrite(sc, MAX2820_CHANNEL,
	    LSHIFT(freq - 2400, MAX2820_CHANNEL_CF_MASK));
}

int
rtw_max2820_init(struct rtw_softc *sc, u_int freq, u_int8_t opaque_txpower,
    enum rtw_pwrstate power)
{
	int rc;

	if ((rc = rtw_rf_hostwrite(sc, MAX2820_TEST,
	    MAX2820_TEST_DEFAULT)) != 0)
		return rc;

	if ((rc = rtw_rf_hostwrite(sc, MAX2820_ENABLE,
	    MAX2820_ENABLE_DEFAULT)) != 0)
		return rc;

	/* skip configuration if it's time to sleep or to power-down. */
	if ((rc = rtw_max2820_pwrstate(sc, power)) != 0)
		return rc;
	else if (power == RTW_OFF || power == RTW_SLEEP)
		return 0;

	if ((rc = rtw_rf_hostwrite(sc, MAX2820_SYNTH,
	    MAX2820_SYNTH_R_44MHZ)) != 0)
		return rc;

	if ((rc = rtw_max2820_tune(sc, freq)) != 0)
		return rc;

	/* XXX The MAX2820 datasheet indicates that 1C and 2C should not
	 * be changed from 7, however, the reference driver sets them
	 * to 4 and 1, respectively.
	 */
	if ((rc = rtw_rf_hostwrite(sc, MAX2820_RECEIVE,
	    MAX2820_RECEIVE_DL_DEFAULT |
	    LSHIFT(4, MAX2820A_RECEIVE_1C_MASK) |
	    LSHIFT(1, MAX2820A_RECEIVE_2C_MASK))) != 0)
		return rc;

	return rtw_rf_hostwrite(sc, MAX2820_TRANSMIT,
	    MAX2820_TRANSMIT_PA_DEFAULT);
}

int
rtw_max2820_txpower(struct rtw_softc *sc, u_int8_t opaque_txpower)
{
	/* TBD */
	return 0;
}

int
rtw_max2820_pwrstate(struct rtw_softc *sc, enum rtw_pwrstate power)
{
	uint32_t enable;

	switch (power) {
	case RTW_OFF:
	case RTW_SLEEP:
	default:
		enable = 0x0;
		break;
	case RTW_ON:
		enable = MAX2820_ENABLE_DEFAULT;
		break;
	}
	return rtw_rf_hostwrite(sc, MAX2820_ENABLE, enable);
}

int
rtw_grf5101_init(struct rtw_softc *sc, u_int freq, u_int8_t opaque_txpower,
    enum rtw_pwrstate power)
{
	int rc;

	/*
	 * These values have been derived from the rtl8180-sa2400 Linux driver.
	 * It is unknown what they all do, GCT refuse to release any documentation
	 * so these are more than likely sub optimal settings
	 */

	rtw_rf_macwrite(sc, 0x01, 0x1a23);
	rtw_rf_macwrite(sc, 0x02, 0x4971);
	rtw_rf_macwrite(sc, 0x03, 0x41de);
	rtw_rf_macwrite(sc, 0x04, 0x2d80);

	rtw_rf_macwrite(sc, 0x05, 0x61ff);

	rtw_rf_macwrite(sc, 0x06, 0x0);

	rtw_rf_macwrite(sc, 0x08, 0x7533);
	rtw_rf_macwrite(sc, 0x09, 0xc401);
	rtw_rf_macwrite(sc, 0x0a, 0x0);
	rtw_rf_macwrite(sc, 0x0c, 0x1c7);
	rtw_rf_macwrite(sc, 0x0d, 0x29d3);
	rtw_rf_macwrite(sc, 0x0e, 0x2e8);
	rtw_rf_macwrite(sc, 0x10, 0x192);
	rtw_rf_macwrite(sc, 0x11, 0x248);
	rtw_rf_macwrite(sc, 0x12, 0x0);
	rtw_rf_macwrite(sc, 0x13, 0x20c4);
	rtw_rf_macwrite(sc, 0x14, 0xf4fc);
	rtw_rf_macwrite(sc, 0x15, 0x0);
	rtw_rf_macwrite(sc, 0x16, 0x1500);

	if ((rc = rtw_grf5101_txpower(sc, opaque_txpower)) != 0)
		return rc;

	if ((rc = rtw_grf5101_tune(sc, freq)) != 0)
		return rc;

	return (0);
}

int
rtw_grf5101_tune(struct rtw_softc *sc, u_int freq)
{
	struct ieee80211com *ic = &sc->sc_ic;
	u_int channel = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);

	/* set channel */
	rtw_rf_macwrite(sc, 0x07, 0);
	rtw_rf_macwrite(sc, 0x0b, channel - 1);
	rtw_rf_macwrite(sc, 0x07, 0x1000);

	return (0);
}

int
rtw_grf5101_txpower(struct rtw_softc *sc, u_int8_t opaque_txpower)
{
	rtw_rf_macwrite(sc, 0x15, 0);
	rtw_rf_macwrite(sc, 0x06, opaque_txpower);
	rtw_rf_macwrite(sc, 0x15, 0x10);
	rtw_rf_macwrite(sc, 0x15, 0x00);

	return (0);
}

int
rtw_grf5101_pwrstate(struct rtw_softc *sc, enum rtw_pwrstate power)
{
	switch (power) {
	case RTW_OFF:
		/* FALLTHROUGH */
	case RTW_SLEEP:
		rtw_rf_macwrite(sc, 0x07, 0x0000);
		rtw_rf_macwrite(sc, 0x1f, 0x0045);
		rtw_rf_macwrite(sc, 0x1f, 0x0005);
		rtw_rf_macwrite(sc, 0x00, 0x08e4);
		break;
	case RTW_ON:
		rtw_rf_macwrite(sc, 0x1f, 0x0001);
		DELAY(10);
		rtw_rf_macwrite(sc, 0x1f, 0x0001);
		DELAY(10);
		rtw_rf_macwrite(sc, 0x1f, 0x0041);
		DELAY(10);
		rtw_rf_macwrite(sc, 0x1f, 0x0061);
		DELAY(10);
		rtw_rf_macwrite(sc, 0x00, 0x0ae4);
		DELAY(10);
		rtw_rf_macwrite(sc, 0x07, 0x1000);
		DELAY(100);
		break;
	}

	return 0;
}

int
rtw_rtl8225_pwrstate(struct rtw_softc *sc, enum rtw_pwrstate power)
{
	return (0);
}

int
rtw_rtl8225_init(struct rtw_softc *sc, u_int freq, u_int8_t opaque_txpower,
    enum rtw_pwrstate power)
{
	return (0);
}

int
rtw_rtl8225_txpower(struct rtw_softc *sc, u_int8_t opaque_txpower)
{
	return (0);
}

int
rtw_rtl8225_tune(struct rtw_softc *sc, u_int freq)
{
	return (0);
}

int
rtw_rtl8255_pwrstate(struct rtw_softc *sc, enum rtw_pwrstate power)
{
	return (0);
}

int
rtw_rtl8255_init(struct rtw_softc *sc, u_int freq, u_int8_t opaque_txpower,
    enum rtw_pwrstate power)
{
	return (0);
}

int
rtw_rtl8255_txpower(struct rtw_softc *sc, u_int8_t opaque_txpower)
{
	return (0);
}

int
rtw_rtl8255_tune(struct rtw_softc *sc, u_int freq)
{
	return (0);
}

int
rtw_phy_init(struct rtw_softc *sc)
{
	int rc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct rtw_regs *regs = &sc->sc_regs;
	int antdiv = sc->sc_flags & RTW_F_ANTDIV;
	int dflantb = sc->sc_flags & RTW_F_DFLANTB;
	u_int freq = ic->ic_bss->ni_chan->ic_freq;	/* freq is in MHz */
	u_int8_t opaque_txpower = rtw_chan2txpower(&sc->sc_srom, ic,
	    ic->ic_bss->ni_chan);
	u_int8_t cs_threshold = sc->sc_csthr;
	enum rtw_pwrstate power = RTW_ON;

	RTW_DPRINTF(RTW_DEBUG_PHY,
	    ("%s: txpower %u csthresh %u freq %u antdiv %u dflantb %u "
	     "pwrstate %s\n", __func__, opaque_txpower, cs_threshold, freq,
	     antdiv, dflantb, rtw_pwrstate_string(power)));

	/* XXX is this really necessary? */
	if ((rc = (*sc->sc_rf_txpower)(sc, opaque_txpower)) != 0)
		return rc;
	if ((rc = rtw_bbp_preinit(regs, sc->sc_bbpset.bb_antatten, dflantb,
	    freq)) != 0)
		return rc;
	if ((rc = (*sc->sc_rf_tune)(sc, freq)) != 0)
		return rc;
	/* initialize RF  */
	if ((rc = (*sc->sc_rf_init)(sc, freq, opaque_txpower, power)) != 0)
		return rc;
#if 0	/* what is this redundant tx power setting here for? */
	if ((rc = (*sc->sc_rf_txpower)(sc, opaque_txpower)) != 0)
		return rc;
#endif
	return rtw_bbp_init(regs, &sc->sc_bbpset, antdiv, dflantb,
	    cs_threshold, freq);
}

/*
 * Generic PHY I/O functions
 */

int
rtw_bbp_write(struct rtw_regs *regs, u_int addr, u_int val)
{
#define	BBP_WRITE_ITERS	50
#define	BBP_WRITE_DELAY	1
	int i;
	u_int32_t wrbbp, rdbbp;

	RTW_DPRINTF(RTW_DEBUG_PHYIO,
	    ("%s: bbp[%u] <- %u\n", __func__, addr, val));

	KASSERT((addr & ~PRESHIFT(RTW_BB_ADDR_MASK)) == 0);
	KASSERT((val & ~PRESHIFT(RTW_BB_WR_MASK)) == 0);

	wrbbp = LSHIFT(addr, RTW_BB_ADDR_MASK) | RTW_BB_WREN |
	    LSHIFT(val, RTW_BB_WR_MASK) | RTW_BB_RD_MASK,

	rdbbp = LSHIFT(addr, RTW_BB_ADDR_MASK) |
	    RTW_BB_WR_MASK | RTW_BB_RD_MASK;

	RTW_DPRINTF(RTW_DEBUG_PHYIO,
	    ("%s: rdbbp = %#08x, wrbbp = %#08x\n", __func__, rdbbp, wrbbp));

	for (i = BBP_WRITE_ITERS; --i >= 0; ) {
		RTW_RBW(regs, RTW_BB, RTW_BB);
		RTW_WRITE(regs, RTW_BB, wrbbp);
		RTW_SYNC(regs, RTW_BB, RTW_BB);
		RTW_WRITE(regs, RTW_BB, rdbbp);
		RTW_SYNC(regs, RTW_BB, RTW_BB);
		delay(BBP_WRITE_DELAY);	/* 1 microsecond */
		if (MASK_AND_RSHIFT(RTW_READ(regs, RTW_BB),
		    RTW_BB_RD_MASK) == val) {
			RTW_DPRINTF(RTW_DEBUG_PHYIO,
			    ("%s: finished in %dus\n", __func__,
			    BBP_WRITE_DELAY * (BBP_WRITE_ITERS - i)));
			return 0;
		}
		delay(BBP_WRITE_DELAY);	/* again */
	}
	printf("%s: timeout\n", __func__);
	return -1;
}

/* Help rtw_rf_hostwrite bang bits to RF over 3-wire interface. */
void
rtw_rf_hostbangbits(struct rtw_regs *regs, u_int32_t bits, int lo_to_hi,
    u_int nbits)
{
	int i;
	u_int32_t mask, reg;

	KASSERT(nbits <= 32);

	RTW_DPRINTF(RTW_DEBUG_PHYIO,
	    ("%s: %u bits, %#08x, %s\n", __func__, nbits, bits,
	    (lo_to_hi) ? "lo to hi" : "hi to lo"));

	reg = RTW8180_PHYCFG_HST;
	RTW_WRITE(regs, RTW8180_PHYCFG, reg);
	RTW_SYNC(regs, RTW8180_PHYCFG, RTW8180_PHYCFG);

	if (lo_to_hi)
		mask = 0x1;
	else
		mask = 1 << (nbits - 1);

	for (i = 0; i < nbits; i++) {
		RTW_DPRINTF(RTW_DEBUG_PHYBITIO,
		    ("%s: bits %#08x mask %#08x -> bit %#08x\n",
		    __func__, bits, mask, bits & mask));

		if ((bits & mask) != 0)
			reg |= RTW8180_PHYCFG_HST_DATA;
		else
			reg &= ~RTW8180_PHYCFG_HST_DATA;

		reg |= RTW8180_PHYCFG_HST_CLK;
		RTW_WRITE(regs, RTW8180_PHYCFG, reg);
		RTW_SYNC(regs, RTW8180_PHYCFG, RTW8180_PHYCFG);

		DELAY(2);	/* arbitrary delay */

		reg &= ~RTW8180_PHYCFG_HST_CLK;
		RTW_WRITE(regs, RTW8180_PHYCFG, reg);
		RTW_SYNC(regs, RTW8180_PHYCFG, RTW8180_PHYCFG);

		if (lo_to_hi)
			mask <<= 1;
		else
			mask >>= 1;
	}

	reg |= RTW8180_PHYCFG_HST_EN;
	KASSERT((reg & RTW8180_PHYCFG_HST_CLK) == 0);
	RTW_WRITE(regs, RTW8180_PHYCFG, reg);
	RTW_SYNC(regs, RTW8180_PHYCFG, RTW8180_PHYCFG);
}

#if 0
void
rtw_rf_rtl8225_hostbangbits(struct rtw_regs *regs, u_int32_t bits, int lo_to_hi,
    u_int nbits)
{
	int i;
	u_int8_t page;
	u_int16_t reg0, reg1, reg2;
	u_int32_t mask;

	/* enable page 0 */
	page = RTW_READ8(regs, RTW_PSR);
	RTW_WRITE8(regs, RTW_PSR, page & ~RTW_PSR_PSEN);

	/* enable RF access */
	reg0 = RTW_READ16(regs, RTW8185_RFPINSOUTPUT) &
	    RTW8185_RFPINSOUTPUT_MASK;
	reg1 = RTW_READ16(regs, RTW8185_RFPINSENABLE);
	RTW_WRITE16(regs, RTW8185_RFPINSENABLE,
	    RTW8185_RFPINSENABLE_ENABLE | reg0);
	reg2 = RTW_READ16(regs, RTW8185_RFPINSSELECT);
	RTW_WRITE16(regs, RTW8185_RFPINSSELECT,
	    RTW8185_RFPINSSELECT_ENABLE | reg1 /* XXX | SW_GPIO_CTL */);
	DELAY(10);

	RTW_WRITE16(regs, RTW8185_RFPINSOUTPUT, reg0);
	DELAY(10);

	if (lo_to_hi)
		mask = 0x1;
	else
		mask = 1 << (nbits - 1);

	for (i = 0; i < nbits; i++) {
		RTW_DPRINTF(RTW_DEBUG_PHYBITIO,
		    ("%s: bits %#08x mask %#08x -> bit %#08x\n",
		    __func__, bits, mask, bits & mask));

		if ((bits & mask) != 0)
			reg |= RTW8180_PHYCFG_HST_DATA;
		else
			reg &= ~RTW8180_PHYCFG_HST_DATA;

		reg |= RTW8180_PHYCFG_HST_CLK;
		RTW_WRITE(regs, RTW8180_PHYCFG, reg);
		RTW_SYNC(regs, RTW8180_PHYCFG, RTW8180_PHYCFG);

		DELAY(2);	/* arbitrary delay */

		reg &= ~RTW8180_PHYCFG_HST_CLK;
		RTW_WRITE(regs, RTW8180_PHYCFG, reg);
		RTW_SYNC(regs, RTW8180_PHYCFG, RTW8180_PHYCFG);

		if (lo_to_hi)
			mask <<= 1;
		else
			mask >>= 1;
	}

	/* reset the page */
	RTW_WRITE8(regs, RTW_PSR, page);
}
#endif

/* Help rtw_rf_macwrite: tell MAC to bang bits to RF over the 3-wire
 * interface.
 */
int
rtw_rf_macbangbits(struct rtw_regs *regs, u_int32_t reg)
{
	int i;

	RTW_DPRINTF(RTW_DEBUG_PHY, ("%s: %#08x\n", __func__, reg));

	RTW_WRITE(regs, RTW8180_PHYCFG, RTW8180_PHYCFG_MAC_POLL | reg);

	RTW_WBR(regs, RTW8180_PHYCFG, RTW8180_PHYCFG);

	for (i = rtw_macbangbits_timeout; --i >= 0; delay(1)) {
		if ((RTW_READ(regs, RTW8180_PHYCFG) &
		    RTW8180_PHYCFG_MAC_POLL) == 0) {
			RTW_DPRINTF(RTW_DEBUG_PHY,
			    ("%s: finished in %dus\n", __func__,
			    rtw_macbangbits_timeout - i));
			return 0;
		}
		RTW_RBR(regs, RTW8180_PHYCFG, RTW8180_PHYCFG);
	}

	printf("%s: RTW8180_PHYCFG_MAC_POLL still set.\n", __func__);
	return -1;
}

u_int32_t
rtw_grf5101_host_crypt(u_int addr, u_int32_t val)
{
	/* TBD */
	return 0;
}

u_int32_t
rtw_grf5101_mac_crypt(u_int addr, u_int32_t val)
{
	u_int32_t data_and_addr;
#define EXTRACT_NIBBLE(d, which) (((d) >> (4 * (which))) & 0xf)
	static u_int8_t caesar[16] = {
		0x0, 0x8, 0x4, 0xc,
		0x2, 0xa, 0x6, 0xe,
		0x1, 0x9, 0x5, 0xd,
		0x3, 0xb, 0x7, 0xf
	};
	data_and_addr =
	    caesar[EXTRACT_NIBBLE(val, 2)] |
	    (caesar[EXTRACT_NIBBLE(val, 1)] <<  4) |
	    (caesar[EXTRACT_NIBBLE(val, 0)] <<  8) |
	    (caesar[(addr >> 1) & 0xf]      << 12) |
	    ((addr & 0x1)                   << 16) |
	    (caesar[EXTRACT_NIBBLE(val, 3)] << 24);
	return LSHIFT(data_and_addr, RTW8180_PHYCFG_MAC_PHILIPS_ADDR_MASK |
	    RTW8180_PHYCFG_MAC_PHILIPS_DATA_MASK);
#undef EXTRACT_NIBBLE
}

/* Bang bits over the 3-wire interface. */
int
rtw_rf_hostwrite(struct rtw_softc *sc, u_int addr, u_int32_t val)
{
	u_int nbits;
	int lo_to_hi;
	u_int32_t bits;
	void(*rf_bangbits)(struct rtw_regs *, u_int32_t, int, u_int) =
	    rtw_rf_hostbangbits;

	RTW_DPRINTF(RTW_DEBUG_PHYIO, ("%s: [%u] <- %#08x\n", __func__,
	    addr, val));

	switch (sc->sc_rfchipid) {
	case RTW_RFCHIPID_MAXIM2820:
		nbits = 16;
		lo_to_hi = 0;
		bits = LSHIFT(val, MAX2820_TWI_DATA_MASK) |
		    LSHIFT(addr, MAX2820_TWI_ADDR_MASK);
		break;
	case RTW_RFCHIPID_PHILIPS:
		KASSERT((addr & ~PRESHIFT(SA2400_TWI_ADDR_MASK)) == 0);
		KASSERT((val & ~PRESHIFT(SA2400_TWI_DATA_MASK)) == 0);
		bits = LSHIFT(val, SA2400_TWI_DATA_MASK) |
		    LSHIFT(addr, SA2400_TWI_ADDR_MASK) | SA2400_TWI_WREN;
		nbits = 32;
		lo_to_hi = 1;
		break;
	case RTW_RFCHIPID_GCT:
		KASSERT((addr & ~PRESHIFT(SI4126_TWI_ADDR_MASK)) == 0);
		KASSERT((val & ~PRESHIFT(SI4126_TWI_DATA_MASK)) == 0);
		bits = rtw_grf5101_host_crypt(addr, val);
		nbits = 21;
		lo_to_hi = 1;
		break;
	case RTW_RFCHIPID_RFMD2948:
		KASSERT((addr & ~PRESHIFT(SI4126_TWI_ADDR_MASK)) == 0);
		KASSERT((val & ~PRESHIFT(SI4126_TWI_DATA_MASK)) == 0);
		bits = LSHIFT(val, SI4126_TWI_DATA_MASK) |
		    LSHIFT(addr, SI4126_TWI_ADDR_MASK);
		nbits = 22;
		lo_to_hi = 0;
		break;
	case RTW_RFCHIPID_RTL8225:
	case RTW_RFCHIPID_RTL8255:
		nbits = 16;
		lo_to_hi = 0;
		bits = LSHIFT(val, RTL8225_TWI_DATA_MASK) |
		    LSHIFT(addr, RTL8225_TWI_ADDR_MASK);

		/* the RTL8225 uses a slightly modified RF interface */
		rf_bangbits = rtw_rf_hostbangbits;
		break;
	case RTW_RFCHIPID_INTERSIL:
	default:
		printf("%s: unknown rfchipid %d\n", __func__, sc->sc_rfchipid);
		return -1;
	}

	(*rf_bangbits)(&sc->sc_regs, bits, lo_to_hi, nbits);

	return 0;
}

u_int32_t
rtw_maxim_swizzle(u_int addr, u_int32_t val)
{
	u_int32_t hidata, lodata;

	KASSERT((val & ~(RTW_MAXIM_LODATA_MASK|RTW_MAXIM_HIDATA_MASK)) == 0);
	lodata = MASK_AND_RSHIFT(val, RTW_MAXIM_LODATA_MASK);
	hidata = MASK_AND_RSHIFT(val, RTW_MAXIM_HIDATA_MASK);
	return LSHIFT(lodata, RTW8180_PHYCFG_MAC_MAXIM_LODATA_MASK) |
	    LSHIFT(hidata, RTW8180_PHYCFG_MAC_MAXIM_HIDATA_MASK) |
	    LSHIFT(addr, RTW8180_PHYCFG_MAC_MAXIM_ADDR_MASK);
}

/* Tell the MAC what to bang over the 3-wire interface. */
int
rtw_rf_macwrite(struct rtw_softc *sc, u_int addr, u_int32_t val)
{
	u_int32_t reg;

	RTW_DPRINTF(RTW_DEBUG_PHYIO, ("%s: %s[%u] <- %#08x\n", __func__,
	    addr, val));

	switch (sc->sc_rfchipid) {
	case RTW_RFCHIPID_GCT:
		reg = rtw_grf5101_mac_crypt(addr, val);
		break;
	case RTW_RFCHIPID_MAXIM2820:
		reg = rtw_maxim_swizzle(addr, val);
		break;
	default:		/* XXX */
	case RTW_RFCHIPID_PHILIPS:
		KASSERT((addr &
		    ~PRESHIFT(RTW8180_PHYCFG_MAC_PHILIPS_ADDR_MASK)) == 0);
		KASSERT((val &
		    ~PRESHIFT(RTW8180_PHYCFG_MAC_PHILIPS_DATA_MASK)) == 0);

		reg = LSHIFT(addr, RTW8180_PHYCFG_MAC_PHILIPS_ADDR_MASK) |
		    LSHIFT(val, RTW8180_PHYCFG_MAC_PHILIPS_DATA_MASK);
	}

	switch (sc->sc_rfchipid) {
	case RTW_RFCHIPID_GCT:
	case RTW_RFCHIPID_MAXIM2820:
	case RTW_RFCHIPID_RFMD2948:
		reg |= RTW8180_PHYCFG_MAC_RFTYPE_RFMD;
		break;
	case RTW_RFCHIPID_INTERSIL:
		reg |= RTW8180_PHYCFG_MAC_RFTYPE_INTERSIL;
		break;
	case RTW_RFCHIPID_PHILIPS:
		reg |= RTW8180_PHYCFG_MAC_RFTYPE_PHILIPS;
		break;
	default:
		printf("%s: unknown rfchipid %d\n", __func__, sc->sc_rfchipid);
		return -1;
	}

	return rtw_rf_macbangbits(&sc->sc_regs, reg);
}


u_int8_t
rtw_read8(void *arg, u_int32_t off)
{
	struct rtw_regs *regs = (struct rtw_regs *)arg;
	return (bus_space_read_1(regs->r_bt, regs->r_bh, off));
}

u_int16_t
rtw_read16(void *arg, u_int32_t off)
{
	struct rtw_regs *regs = (struct rtw_regs *)arg;
	return (bus_space_read_2(regs->r_bt, regs->r_bh, off));
}

u_int32_t
rtw_read32(void *arg, u_int32_t off)
{
	struct rtw_regs *regs = (struct rtw_regs *)arg;
	return (bus_space_read_4(regs->r_bt, regs->r_bh, off));
}

void
rtw_write8(void *arg, u_int32_t off, u_int8_t val)
{
	struct rtw_regs *regs = (struct rtw_regs *)arg;
	bus_space_write_1(regs->r_bt, regs->r_bh, off, val);
}

void
rtw_write16(void *arg, u_int32_t off, u_int16_t val)
{
	struct rtw_regs *regs = (struct rtw_regs *)arg;
	bus_space_write_2(regs->r_bt, regs->r_bh, off, val);
}

void
rtw_write32(void *arg, u_int32_t off, u_int32_t val)
{
	struct rtw_regs *regs = (struct rtw_regs *)arg;
	bus_space_write_4(regs->r_bt, regs->r_bh, off, val);
}

void
rtw_barrier(void *arg, u_int32_t reg0, u_int32_t reg1, int flags)
{
	struct rtw_regs *regs = (struct rtw_regs *)arg;
	bus_space_barrier(regs->r_bt, regs->r_bh, MIN(reg0, reg1),
	    MAX(reg0, reg1) - MIN(reg0, reg1) + 4, flags);
}
@


1.99
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.98 2017/04/08 02:57:25 deraadt Exp $	*/
d2989 1
a2989 1
	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
@


1.98
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.97 2017/01/22 10:17:38 dlg Exp $	*/
a47 1
#include <sys/types.h>
@


1.97
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.96 2016/04/13 10:49:26 mpi Exp $	*/
a4059 1
	sr->sr_size = 0;
d4061 1
a4061 1
		free(sr->sr_content, M_DEVBUF, 0);
d4064 1
@


1.96
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.95 2015/12/08 13:34:22 tedu Exp $	*/
a2777 1
	ifp->if_opackets++;
@


1.95
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.94 2015/11/25 03:09:58 dlg Exp $	*/
a4003 1
	IFQ_SET_READY(&sc->sc_if.if_snd);
@


1.94
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.93 2015/11/20 03:35:22 dlg Exp $	*/
d3999 1
a3999 2
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST |
	    IFF_NOTRAILERS;
@


1.93
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.92 2015/11/04 12:11:59 dlg Exp $	*/
d190 1
a190 1
	    struct ieee80211_node **, short *);
d1378 1
a1378 1
	short oflags;
d1382 1
a1382 1
	oflags = sc->sc_if.if_flags;
d1387 1
a1387 1
			sc->sc_if.if_flags &= ~IFF_OACTIVE;
d1389 1
a1389 1
	if (oflags != sc->sc_if.if_flags) {
d1906 2
a1907 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d2684 1
a2684 1
    struct ieee80211_node **nip, short *if_flagsp)
d2693 1
a2693 1
		*if_flagsp |= IFF_OACTIVE;
a2714 1
	short *if_flagsp;
a2721 2
	if_flagsp = &ifp->if_flags;

d2724 1
a2724 1
	    tdbp, nip, if_flagsp)) != NULL) {
d2731 1
a2731 1
	    tdbp, nip, if_flagsp)) != NULL) {
d2743 1
a2743 1
	    tsbp, tdbp, nip, if_flagsp)) != NULL) {
d2766 1
a2766 1
		*if_flagsp |= IFF_OACTIVE;
d3082 1
a3082 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)
@


1.92
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.91 2015/10/25 12:48:46 mpi Exp $	*/
d2758 1
a2758 1
	IFQ_POLL(&ifp->if_snd, m0);
d2767 1
d2773 1
a2773 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.91
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.90 2015/02/10 23:25:46 mpi Exp $	*/
d188 1
a188 1
struct mbuf *rtw_80211_dequeue(struct rtw_softc *, struct ifqueue *, int,
d1503 1
a1503 1
		IF_ENQUEUE(&sc->sc_beaconq, m);
d2681 1
a2681 1
rtw_80211_dequeue(struct rtw_softc *sc, struct ifqueue *ifq, int pri,
d2687 1
a2687 1
	if (IF_IS_EMPTY(ifq))
d2696 1
a2696 1
	IF_DEQUEUE(ifq, m);
@


1.90
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.89 2014/12/22 02:28:51 tedu Exp $	*/
a2605 2
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifaddr *ifa = (struct ifaddr *)data;
a2613 3
		if (ifa->ifa_addr->sa_family == AF_INET) {
			arp_ifinit(&ic->ic_ac, ifa);
		}
@


1.89
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.88 2014/12/19 22:44:58 guenther Exp $	*/
a1239 1
		m->m_pkthdr.rcvif = &sc->sc_if;
@


1.88
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.87 2014/07/13 23:10:23 deraadt Exp $	*/
a60 1
#ifdef INET
a62 1
#endif
a2616 1
#ifdef INET
a2619 1
#endif  /* INET */
@


1.87
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.86 2014/07/12 18:48:17 tedu Exp $	*/
d49 1
a50 1
#include <machine/endian.h>
@


1.86
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.85 2014/07/08 17:19:25 deraadt Exp $	*/
d3617 1
a3617 1
	tsb->tsb_desc = malloc(qlen * sizeof(*tsb->tsb_desc), M_DEVBUF,
@


1.85
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.84 2014/03/19 10:09:19 mpi Exp $	*/
d693 1
a693 1
		free(sr->sr_content, M_DEVBUF);
d3632 1
a3632 1
		free(tsb->tsb_desc, M_DEVBUF);
d4076 1
a4076 1
		free(sr->sr_content, M_DEVBUF);
@


1.84
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.83 2013/11/26 09:50:33 mpi Exp $	*/
a52 2

#include <uvm/uvm_extern.h>
@


1.83
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.82 2012/12/05 23:20:19 deraadt Exp $	*/
d1507 1
a1507 1
		m->m_pkthdr.rcvif = (void *)ieee80211_ref_node(ic->ic_bss);
d2709 1
a2709 2
	*nip = (struct ieee80211_node *)m->m_pkthdr.rcvif;
	m->m_pkthdr.rcvif = NULL;
@


1.82
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.81 2010/09/07 16:21:43 deraadt Exp $	*/
d2281 1
a2281 1
	struct arpcom *ec = &ic->ic_ac;
d2320 3
a2322 2
	if (ifp->if_flags & IFF_PROMISC) {
		sc->sc_rcr |= RTW_RCR_AB;	/* accept all broadcast */
d2331 1
a2331 1
	ETHER_FIRST_MULTI(step, ec, enm);
a2332 5
		/* XXX */
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    ETHER_ADDR_LEN) != 0)
			goto allmulti;

@


1.81
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.80 2010/08/29 16:46:58 deraadt Exp $	*/
a37 1
#include <sys/cdefs.h>
@


1.80
log
@Massage the powerhook functions into activate functions, and then call
them from the powerhook.  Fix a few quibbles about the things done for
the IFF_RUNNING and IFF_UP cases
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.79 2010/08/27 04:09:19 deraadt Exp $	*/
a186 2
void	 rtw_establish_hooks(struct rtw_hooks *, const char *, void *);
void	 rtw_disestablish_hooks(struct rtw_hooks *, const char *, void *);
a3618 28
void
rtw_powerhook(int why, void *arg)
{
	rtw_activate(arg, why);
}

void
rtw_establish_hooks(struct rtw_hooks *hooks, const char *dvname,
    void *arg)
{
	/*
	 * Add a suspend hook to make sure we come back up after a
	 * resume.
	 */
	hooks->rh_power = powerhook_establish(rtw_powerhook, arg);
	if (hooks->rh_power == NULL)
		printf("%s: WARNING: unable to establish power hook\n",
		    dvname);
}

void
rtw_disestablish_hooks(struct rtw_hooks *hooks, const char *dvname,
    void *arg)
{
	if (hooks->rh_power != NULL)
		powerhook_disestablish(hooks->rh_power);
}

a4077 3

	rtw_establish_hooks(&sc->sc_hooks, sc->sc_dev.dv_xname, (void*)sc);

a4120 2
	rtw_disestablish_hooks(&sc->sc_hooks, sc->sc_dev.dv_xname,
	    (void*)sc);
@


1.79
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.78 2009/11/24 00:28:22 deraadt Exp $	*/
d3596 2
a3597 2
void
rtw_power(int why, void *arg)
d3599 1
a3599 1
	struct rtw_softc *sc = arg;
a3600 1
	int s;
d3602 7
a3608 9
	DPRINTF(sc, RTW_DEBUG_PWR,
	    ("%s: rtw_power(%d,)\n", sc->sc_dev.dv_xname, why));

	s = splnet();
	switch (why) {
	case PWR_SUSPEND:
		rtw_stop(ifp, 1);
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
d3610 1
a3610 1
	case PWR_RESUME:
d3613 1
a3613 1
				(*sc->sc_power)(sc, why);
d3618 7
a3624 1
	splx(s);
d3635 1
a3635 1
	hooks->rh_power = powerhook_establish(rtw_power, arg);
@


1.78
log
@kill hooks and timeouts before calling complex sleeping code from detach; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.77 2009/08/16 18:21:57 jsg Exp $	*/
a3607 3
	case PWR_STANDBY:
		/* XXX do nothing. */
		break;
@


1.77
log
@remove use of BITS and BIT macros
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.76 2009/08/16 18:05:51 jsg Exp $	*/
a4153 2
	rtw_stop(&sc->sc_if, 1);

d4157 3
@


1.76
log
@tweak a switch statement to appease lint
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.75 2009/08/10 20:29:54 deraadt Exp $	*/
d797 4
a800 4
	(*addr)[0] = MASK_AND_RSHIFT(idr0, BITS(0,  7));
	(*addr)[1] = MASK_AND_RSHIFT(idr0, BITS(8,  15));
	(*addr)[2] = MASK_AND_RSHIFT(idr0, BITS(16, 23));
	(*addr)[3] = MASK_AND_RSHIFT(idr0, BITS(24 ,31));
d802 2
a803 2
	(*addr)[4] = MASK_AND_RSHIFT(idr1, BITS(0,  7));
	(*addr)[5] = MASK_AND_RSHIFT(idr1, BITS(8, 15));
@


1.75
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.74 2009/07/28 11:45:05 blambert Exp $	*/
d4624 1
a4629 1
	default:
@


1.74
log
@timeout_add -> timeout_add_msec

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.73 2009/03/29 21:53:52 sthen Exp $	*/
a3626 9
/* rtw_shutdown: make sure the interface is stopped at reboot time. */
void
rtw_shutdown(void *arg)
{
	struct rtw_softc *sc = arg;

	rtw_stop(&sc->sc_ic.ic_if, 1);
}

a3631 8
	 * Make sure the interface is shutdown during reboot.
	 */
	hooks->rh_shutdown = shutdownhook_establish(rtw_shutdown, arg);
	if (hooks->rh_shutdown == NULL)
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    dvname);

	/*
a3644 3
	if (hooks->rh_shutdown != NULL)
		shutdownhook_disestablish(hooks->rh_shutdown);

@


1.73
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.72 2009/01/21 21:54:00 grange Exp $	*/
d2501 2
a2502 2
		timeout_add(&ls->ls_slow_ch, RTW_LED_SLOW_TICKS);
		timeout_add(&ls->ls_fast_ch, RTW_LED_FAST_TICKS);
d2590 1
a2590 1
	timeout_add(&ls->ls_fast_ch, RTW_LED_FAST_TICKS);
d2604 1
a2604 1
	timeout_add(&ls->ls_slow_ch, RTW_LED_SLOW_TICKS);
@


1.72
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.71 2008/11/28 02:44:17 brad Exp $	*/
d3959 1
a3959 1
		printf("\n%s: could not map hw descriptors, error %d\n",
@


1.71
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.70 2008/08/27 10:29:53 damien Exp $	*/
d3457 1
a3457 1
		timeout_add(&sc->sc_scan_to, rtw_dwelltime * hz / 1000);
@


1.70
log
@fix IEEE80211_RADIOTAP_F_SHORTPRE
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.69 2008/08/27 09:05:03 damien Exp $	*/
a2616 1
	int rc = 0, s;
d2619 1
d2621 1
a2621 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d2624 1
a2625 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			rc = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;
d2644 1
d2657 1
d2667 1
@


1.69
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.68 2008/08/14 16:02:24 damien Exp $	*/
d1276 1
d1278 1
a1278 1
				rr->rr_flags = IEEE80211_RADIOTAP_F_SHORTPRE;
a1279 1
			rr->rr_flags = 0;
@


1.68
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.67 2008/07/21 18:43:19 damien Exp $	*/
d101 1
d104 1
d110 1
d113 1
d199 1
d202 1
d1464 1
d1522 1
d1856 1
d1861 1
d2255 1
d2263 1
d2271 2
d2306 1
d2312 1
d3465 1
d3471 1
d3476 1
a3476 1
		case IEEE80211_M_MONITOR:
d3505 1
d3547 1
d4081 4
a4084 3
	ic->ic_caps = IEEE80211_C_PMGT | IEEE80211_C_IBSS |
	    IEEE80211_C_HOSTAP | IEEE80211_C_MONITOR | IEEE80211_C_WEP;

d4099 1
d4102 1
@


1.67
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.66 2008/04/16 18:32:15 damien Exp $	*/
a1302 8

	/*
	 * In HostAP mode, ieee80211_input() will enqueue packets in if_snd
	 * without calling if_start().
	 */
	if (!IFQ_IS_EMPTY(&sc->sc_if.if_snd) &&
	    !(sc->sc_if.if_flags & IFF_OACTIVE))
		(*sc->sc_if.if_start)(&sc->sc_if);
@


1.66
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.65 2007/11/21 15:58:22 blambert Exp $	*/
d109 1
a109 1
	    struct ieee80211_node *, int, int, u_int32_t);
d1093 1
a1093 1

d1292 4
a1295 1
		ieee80211_input(&sc->sc_if, m, ni, rssi, htsftl);
d3517 1
a3517 1
    struct ieee80211_node *ni, int subtype, int rssi, u_int32_t rstamp)
d3521 1
a3521 1
	(*sc->sc_mtbl.mt_recv_mgmt)(ic, m, ni, subtype, rssi, rstamp);
d3529 1
a3529 1
		rtw_ibss_merge(sc, ni, rstamp);
@


1.65
log
@Remove superfluous function declaration

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.64 2007/10/24 12:37:01 blambert Exp $	*/
d2721 3
d2729 1
d2736 1
a2736 1
	if (sc->sc_ic.ic_state == IEEE80211_S_RUN &&
d2744 1
a2744 1
	if ((*mp = rtw_80211_dequeue(sc, &sc->sc_ic.ic_mgtq, RTW_TXPRIMD, tsbp,
d2756 1
a2756 1
	if ((*mp = rtw_80211_dequeue(sc, &sc->sc_ic.ic_pwrsaveq, RTW_TXPRIHI,
d2763 1
a2763 1
	if (sc->sc_ic.ic_state != IEEE80211_S_RUN) {
d2804 4
a2807 2
	if (sc->sc_ic.ic_flags & IEEE80211_F_WEPON) {
		if ((m0 = ieee80211_wep_crypt(ifp, m0, 1)) == NULL)
@


1.64
log
@Unconditionally initialize all channels, regardless of locale.

Shaves 258 bytes from i386 kernel.

Feedback, guidance, testing, and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.63 2007/09/30 11:33:14 kettenis Exp $	*/
a94 1
u_int	 rtw_txring_next(struct rtw_regs *, struct rtw_txdesc_blk *);
@


1.63
log
@s/NPBFILTER/NBPFILTER/ in #endif comment. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.62 2007/09/17 01:33:33 krw Exp $	*/
a169 2
void	 rtw_init_channels(enum rtw_locale, struct ieee80211_channel (*)[],
	    const char*);
a760 41
rtw_init_channels(enum rtw_locale locale,
    struct ieee80211_channel (*chans)[IEEE80211_CHAN_MAX+1],
    const char *dvname)
{
	int i;
	const char *name = NULL;
#define ADD_CHANNEL(_chans, _chan) do {			\
	(*_chans)[_chan].ic_flags = IEEE80211_CHAN_B;		\
	(*_chans)[_chan].ic_freq =				\
	    ieee80211_ieee2mhz(_chan, (*_chans)[_chan].ic_flags);\
} while (0)

	switch (locale) {
	case RTW_LOCALE_USA:	/* 1-11 */
		name = "USA";
		for (i = 1; i <= 11; i++)
			ADD_CHANNEL(chans, i);
		break;
	case RTW_LOCALE_JAPAN:	/* 1-14 */
		name = "Japan";
		ADD_CHANNEL(chans, 14);
		for (i = 1; i <= 14; i++)
			ADD_CHANNEL(chans, i);
		break;
	case RTW_LOCALE_EUROPE:	/* 1-13 */
		name = "Europe";
		for (i = 1; i <= 13; i++)
			ADD_CHANNEL(chans, i);
		break;
	default:			/* 10-11 allowed by most countries */
		name = "<unknown>";
		for (i = 10; i <= 11; i++)
			ADD_CHANNEL(chans, i);
		break;
	}
	RTW_DPRINTF(RTW_DEBUG_ATTACH, ("%s: Geographic Location %s\n",
	    dvname, name));
#undef ADD_CHANNEL
}

void
a1043 1
	struct rtw_rxdesc *rd;
a1046 1
		rd = &rdb->rdb_desc[i];
d3892 1
a3892 1
	int pri, rc;
d4038 5
a4042 2
	rtw_init_channels(sc->sc_locale, &sc->sc_ic.ic_channels,
	    sc->sc_dev.dv_xname);
@


1.62
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.61 2007/06/07 20:20:15 damien Exp $	*/
d1336 1
a1336 1
#endif /* NPBFILTER > 0 */
d3264 1
a3264 1
#endif /* NPBFILTER > 0 */
@


1.61
log
@move ieee80211_compute_duration() and ieee80211_compute_duration1()
functions into the two drivers that use them (atw and rtw.)
this code is not generic enough to be used by other drivers and
there is no chance that it will ever be used in newer driver since
it supports 802.11b only.
plus, it hurts my eyes each time i look into ieee80211_output.c.

"fine with me as long as the logic doesn't change in the functions" jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.60 2007/04/06 12:20:59 jsg Exp $	*/
d667 1
a667 1
	sr->sr_content = malloc(sr->sr_size, M_DEVBUF, M_NOWAIT);
a672 2

	bzero(sr->sr_content, sr->sr_size);
@


1.60
log
@Correct order of bus_space_barrier() parameters.
From brad
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.59 2007/04/02 08:41:04 claudio Exp $	*/
d148 3
d2932 166
a3120 1
	struct ieee80211_duration *d0;
d3125 1
d3212 1
a3212 1
		if (ieee80211_compute_duration(wh, m0->m_pkthdr.len,
@


1.59
log
@Similar to other drivers call if_start() at the end of the rx interrupt because
ieee80211_input() may enqueue packets.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.58 2007/02/14 04:59:55 jsg Exp $	*/
d5009 1
a5009 1
	bus_space_barrier(regs->r_bh, regs->r_bt, MIN(reg0, reg1),
@


1.58
log
@remove some unused goop
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.57 2007/01/03 18:16:43 claudio Exp $	*/
d1345 8
@


1.57
log
@M_DUP_PKTHDR() cleanup. On static buffers M_DUP_PKTHDR() will leak mbuf tags.
See similar rum(4) commit for more info. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.56 2006/11/26 17:20:33 jsg Exp $	*/
a80 2
int rtw_host_rfio = 0;
int rtw_xmtr_restart = 0;
a142 1
void	 rtw_txdesc_blk_reset(struct rtw_txdesc_blk *);
a143 1
void	 rtw_rxdescs_reset(struct rtw_softc *);
a241 1
u_int8_t rtw_bbp_read(struct rtw_regs *, u_int);
d1952 1
d1967 1
a4607 12


u_int8_t
rtw_bbp_read(struct rtw_regs *regs, u_int addr)
{
	KASSERT((addr & ~PRESHIFT(RTW_BB_ADDR_MASK)) == 0);
	RTW_WRITE(regs, RTW_BB,
	    LSHIFT(addr, RTW_BB_ADDR_MASK) | RTW_BB_RD_MASK | RTW_BB_WR_MASK);
	delay(10);	/* XXX */
	RTW_WBR(regs, RTW_BB, RTW_BB);
	return MASK_AND_RSHIFT(RTW_READ(regs, RTW_BB), RTW_BB_RD_MASK);
}
@


1.56
log
@Make use of ieee80211_std_rateset
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.55 2006/08/30 11:20:20 jsg Exp $	*/
a1331 1
			M_DUP_PKTHDR(&mb, m);
d1335 3
a1337 1
			mb.m_pkthdr.len += mb.m_len;
a3082 1
			M_DUP_PKTHDR(&mb, m0);
d3086 3
a3088 1
			mb.m_pkthdr.len += mb.m_len;
@


1.55
log
@Return from channel tuning code if we get IEEE80211_CHAN_ANY
as per other drivers instead of doing panics.

Should workaround PR 5206 which I could never manage
to reproduce, though we really shouldn't be getting
IEEE80211_CHAN_ANY here.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.54 2006/03/25 22:41:43 djm Exp $	*/
d3763 1
a3763 1
	int pri, rc, nrate;
d3932 1
a3932 8
	nrate = 0;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] =
	    IEEE80211_RATE_BASIC | 2;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] =
	    IEEE80211_RATE_BASIC | 4;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] = 11;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] = 22;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_nrates = nrate;
@


1.54
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.53 2006/02/05 23:47:47 jsg Exp $	*/
d2161 2
a2162 2
	if (chan == IEEE80211_CHAN_ANY)
		panic("%s: chan == IEEE80211_CHAN_ANY", __func__);
@


1.53
log
@Add a fix from David Young to not set the ring indexes to something
obviously invalid, which can occur when ejecting a CardBus rtw.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.52 2006/01/05 05:40:35 jsg Exp $	*/
d1337 1
a1337 1
			bpf_mtap(sc->sc_radiobpf, &mb);
d2829 1
a2829 1
		bpf_mtap(ifp->if_bpf, m0);
d3068 2
a3069 1
			bpf_mtap((caddr_t)ic->ic_rawbpf, m0);
d3087 1
a3087 1
			bpf_mtap(sc->sc_radiobpf, &mb);
@


1.52
log
@rev 1.59 & 1.60 of rtw.c commited by David Young to NetBSD:

On a transmit FIFO overflow (err, actually an underflow...) reset
both the transmit & receive sections of the MAC.

Fix comments and debug printfs: Tx FIFOs underflow, they don't
overflow.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.50 2005/11/20 09:49:05 jsg Exp $	*/
d1695 1
a1695 1
		tdb->tdb_next = next;
d1714 1
a1714 1
		rdb->rdb_next = next;
@


1.51
log
@part of rev 1.58 of rtw.c David Young comitted to NetBSD:

Miscellaneous Realtek RTL8180L driver improvements:

3 Revamp handling of transmit descriptor rings.

4 Reliably IFF_OACTIVE when transmit descriptors are available, to
  stop the transmit section of the driver from freezing up.

5 Fix beacon transmission in adhoc and hostap modes.  XXX There is
  a wart in hostap mode, where beacons are transmitted at 1/2 the
  correct rate.  Load beacon descriptors when the RTW_INTR_BINT
  interrupt arrives; schedule RTW_INTR_BINT 1ms ahead of the target
  beacon time.

6 Recover more gracefully from tx/rx errors: avoid
  transmitter/receiver/chip resets.  Try to re-synchronize software
  state with hardware state---e.g., load next descriptor pointer
  from hardware.

7 Activate the transmit watchdog timer for beacons as well as other
  packets.

8 Introduce rtw_idle() that waits for transmit DMA to finish; call
  it before resetting the transmitter.
@
text
@d1739 2
a1740 2
		xmtr = 1;
		cr |= RTW_CR_TE;
d1744 1
a1744 1
		cr = RTW_CR_RE;
a1745 1
		return;
@


1.50
log
@Add support for GCT GRF5101 RF transceiver based hardware.  Magic numbers
partially derived from rtl8180-sa2400 Linux driver.
GCT refuse to release documentation so this is more than
likely not as optimal as it could be.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.49 2005/11/05 02:31:29 jsg Exp $	*/
d82 2
d95 1
d97 2
d101 1
d166 1
d173 1
a173 1
void	 rtw_identify_country(struct rtw_regs *, enum rtw_locale *, const char *);
d180 1
a180 1
	    struct rtw_txdesc_blk *);
d194 1
d201 1
d808 1
a808 2
rtw_identify_country(struct rtw_regs *regs, enum rtw_locale *locale,
    const char *dvname)
d873 23
a895 2
	u_int ndesc[RTW_NTXPRI] =
	    {RTW_NTXDESCLO, RTW_NTXDESCMD, RTW_NTXDESCHI, RTW_NTXDESCBCN};
d898 1
a898 1
		tdb[pri].tdb_nfree = ndesc[pri];
d916 1
a1098 1
	rdb->rdb_next = 0;
d1386 1
d1423 20
d1446 1
a1446 1
    struct rtw_txdesc_blk *tdb)
d1461 11
a1471 1
		if ((tdb->tdb_desc[ts->ts_last].td_stat &
a1474 5
		if (&sc->sc_txdesc_blk[RTW_TXPRIBCN] == tdb) {
			RTW_DPRINTF(RTW_DEBUG_BEACON,
			    ("%s: collected beacon\n", __func__));
		}

a1477 1
		sc->sc_if.if_flags &= ~IFF_OACTIVE;
d1479 1
d1482 1
d1496 1
a1496 1
		rtw_collect_txring(sc, tsb, tdb);
a1497 2
		if ((isr & RTW_INTR_TX) != 0)
			rtw_start(&sc->sc_if);
d1500 2
a1501 2
	/* TBD */
	return;
d1507 46
a1552 2
	/* TBD */
	return;
d1598 1
d1600 19
d1620 1
a1620 18
	RTW_WRITE(regs, RTW_TLPDA, RTW_RING_BASE(sc, hd_txlo));
	RTW_WRITE(regs, RTW_TNPDA, RTW_RING_BASE(sc, hd_txmd));
	RTW_WRITE(regs, RTW_THPDA, RTW_RING_BASE(sc, hd_txhi));
	RTW_WRITE(regs, RTW_TBDA, RTW_RING_BASE(sc, hd_bcn));
	RTW_SYNC(regs, RTW_TLPDA, RTW_RDSAR);
#if 0
	RTW_DPRINTF(RTW_DEBUG_XMIT_DESC,
	    ("%s: reg[TLPDA] <- %\n", __func__,
	     (u_int *)RTW_RING_BASE(sc, hd_txlo)));
	RTW_DPRINTF(RTW_DEBUG_XMIT_DESC,
	    ("%s: reg[TNPDA] <- %\n", __func__,
	     (u_int *)RTW_RING_BASE(sc, hd_txmd)));
	RTW_DPRINTF(RTW_DEBUG_XMIT_DESC,
	    ("%s: reg[THPDA] <- %\n", __func__,
	     (u_int *)RTW_RING_BASE(sc, hd_txhi)));
	RTW_DPRINTF(RTW_DEBUG_XMIT_DESC,
	    ("%s: reg[TBDA] <- %\n", __func__,
	     (u_int *)RTW_RING_BASE(sc, hd_bcn)));
d1622 1
a1622 1
	    ("%s: reg[RDSAR] <- %\n", __func__,
d1624 2
a1625 1
#endif
d1652 1
d1663 1
a1663 1
rtw_txdesc_blk_reset(struct rtw_txdesc_blk *tdb)
d1670 7
a1676 2
	tdb->tdb_nfree = tdb->tdb_ndesc;
	tdb->tdb_next = 0;
d1680 1
a1680 1
rtw_txdescs_reset(struct rtw_softc *sc)
d1683 1
d1685 1
d1689 26
a1714 5
		rtw_txsofts_release(sc->sc_dmat, &sc->sc_ic,
		    &sc->sc_txsoft_blk[pri]);
		rtw_txdesc_blk_reset(tdb);
		rtw_txdescs_sync(tdb, 0, tdb->tdb_ndesc,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1719 1
a1719 1
rtw_rxdescs_reset(struct rtw_softc *sc)
d1721 6
a1726 1
	rtw_rxdesc_init_all(&sc->sc_rxdesc_blk, &sc->sc_rxsoft[0], 1);
d1732 2
d1736 6
a1741 4
#ifdef RTW_DEBUG
	if ((isr & RTW_INTR_TXFOVW) != 0)
		printf("%s: tx fifo overflow\n", sc->sc_dev.dv_xname);
#endif
d1743 3
a1745 1
	if ((isr & (RTW_INTR_RDU|RTW_INTR_RXFOVW)) == 0)
d1747 1
d1749 1
a1749 1
	RTW_DPRINTF(RTW_DEBUG_BUGS, ("%s: restarting xmit/recv, isr %"
d1756 1
a1756 1
	rtw_io_enable(regs, RTW_CR_RE | RTW_CR_TE, 0);
d1758 8
a1765 4
	/* Collect rx'd packets.  Refresh rx buffers. */ 
	rtw_intr_rx(sc, 0);
	/* Collect tx'd packets. */ 
	rtw_intr_tx(sc, 0);
d1770 3
a1772 1
	rtw_chip_reset1(regs, sc->sc_dev.dv_xname);
d1774 1
a1774 4
	rtw_rxdescs_reset(sc);
	rtw_txdescs_reset(sc);

	rtw_hwring_setup(sc);
d1782 5
a1786 2
	rtw_io_enable(regs, RTW_CR_RE | RTW_CR_TE, 1);
	sc->sc_if.if_flags &= ~IFF_OACTIVE;
d2720 2
d2741 2
d2744 1
d2799 14
d2816 1
a2819 2
	*mp = NULL;

d2916 1
a2916 1
		*ifflagsp |= IFF_OACTIVE;
d2930 2
a2931 2
	DPRINTF(sc, RTW_DEBUG_XMIT_DESC, ("%s: %p %s txdesc[%d] ctl0 %#08x "
	    "ctl1 %#08x buf %#08x len %#08x\n",
d2933 2
a2934 2
	    letoh32(td->td_ctl0),
	    letoh32(td->td_ctl1), letoh32(td->td_buf),
d3146 1
a3146 1
		if (tsb != &sc->sc_txsoft_blk[RTW_TXPRIBCN]) {
d3148 2
a3149 4
			tsb->tsb_tx_timer = 5;
			ifp->if_timer = 1;
		}

d3168 17
d3187 1
a3187 1
	int pri;
d3203 1
a3203 2

		if (--tsb->tsb_tx_timer == 0) {
d3206 3
a3208 2
			printf("%s: transmit timeout, priority %d\n",
			    ifp->if_xname, pri);
d3210 1
a3210 12
			/* Stop Tx DMA, disable transmitter, clear
			 * Tx rings, and restart.
			 *
			 * TBD Stop/restart just the broken ring?
			 */
			RTW_WRITE8(&sc->sc_regs, RTW_TPPOLL, RTW_TPPOLL_SALL);
			RTW_SYNC(&sc->sc_regs, RTW_TPPOLL, RTW_TPPOLL);
			rtw_io_enable(&sc->sc_regs, RTW_CR_TE, 0);
			rtw_txdescs_reset(sc);
			rtw_io_enable(&sc->sc_regs, RTW_CR_TE, 1);
			sc->sc_if.if_flags &= ~IFF_OACTIVE;
			rtw_start(ifp);
d3214 14
a3228 1
	return;
d3249 1
a3249 1
	uint16_t bcnitv, intval;
d3265 4
a3271 1

a3285 1
	struct mbuf *m;
a3322 6
			m = ieee80211_beacon_alloc(ic, ic->ic_bss);
			if (m == NULL) {
				printf("%s: could not allocate beacon\n",
				    sc->sc_dev.dv_xname);
			} else
				IF_ENQUEUE(&sc->sc_beaconq, m);
a3341 6
	/* Start beacon transmission. */
	if (nstate == IEEE80211_S_RUN &&
	    (ic->ic_opmode == IEEE80211_M_HOSTAP ||
	     ic->ic_opmode == IEEE80211_M_IBSS))
		rtw_start(&sc->sc_if);

d3582 2
a3583 1
	rtw_txdesc_blk_reset(tdb);
d3907 1
a3907 2
		rtw_identify_country(&sc->sc_regs, &sc->sc_locale,
		    sc->sc_dev.dv_xname);
@


1.49
log
@Move displaying rf/pa type to rtw_rf_attach to simplify code.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.48 2005/11/04 15:05:30 jsg Exp $	*/
d230 5
d3515 18
a3532 1
		notsup = 1;
d4252 100
d4705 6
d4714 2
a4715 6
		if (sc->sc_rfchipid == RTW_RFCHIPID_GCT)
			bits = rtw_grf5101_host_crypt(addr, val);
		else {
			bits = LSHIFT(val, SI4126_TWI_DATA_MASK) |
			    LSHIFT(addr, SI4126_TWI_ADDR_MASK);
		}
@


1.48
log
@remove uneeded debug function.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.47 2005/11/04 14:04:33 jsg Exp $	*/
a558 2
	const char *rfname, *paname = NULL;
	char scratch[sizeof("unknown 0xXX")];
a601 42
	switch (*rfchipid) {
	case RTW_RFCHIPID_RTL8225:
		rfname = "RTL8225";
		break;
	case RTW_RFCHIPID_RTL8255:
		rfname = "RTL8255";
		break;
	case RTW_RFCHIPID_GCT:		/* this combo seen in the wild */
		rfname = "GRF5101";
		paname = "WS9901";
		break;
	case RTW_RFCHIPID_MAXIM2820:
		rfname = "MAX2820";	/* guess */
		paname = "MAX2422";	/* guess */
		break;
	case RTW_RFCHIPID_INTERSIL:
		rfname = "HFA3873";	/* guess */
		paname = "Intersil <unknown>";
		break;
	case RTW_RFCHIPID_PHILIPS:	/* this combo seen in the wild */
		rfname = "SA2400A";
		paname = "SA2411";
		break;
	case RTW_RFCHIPID_RFMD2948:
		/* this is the same front-end as an atw(4)! */
		rfname = "RFMD RF2948B, "	/* mentioned in Realtek docs */
			 "LNA: RFMD RF2494, "	/* mentioned in Realtek docs */
			 "SYN: Silicon Labs Si4126";	/* inferred from
			 				 * reference driver
							 */
		paname = "RF2189";		/* mentioned in Realtek docs */
		break;
	case RTW_RFCHIPID_RESERVED:
		rfname = paname = "reserved";
		break;
	default:
		snprintf(scratch, sizeof(scratch), "unknown 0x%02x", *rfchipid);
		rfname = scratch;
	}
	printf("radio %s, ", rfname);
	if (paname != NULL)
		printf("amp %s, ", paname);
d3430 3
d3436 1
d3444 1
d3452 2
d3474 2
d3496 7
d3505 12
a3516 1
		/*FALLTHROUGH*/
d3518 3
a3520 1
		return (1);
d3522 6
a3527 1
	return (0);
@


1.47
log
@Move access to RF tranceiver functions to be via callbacks.
"looks fine" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.46 2005/10/24 02:53:31 reyk Exp $	*/
a239 1
const char *rtw_rfchipid_string(int);
a4563 23
const char *
rtw_rfchipid_string(int rfchipid)
{
	switch (rfchipid) {
	case RTW_RFCHIPID_MAXIM2820:
		return "Maxim 2820";
	case RTW_RFCHIPID_PHILIPS:
		return "Philips SA2400";
	case RTW_RFCHIPID_GCT:
		return "GCT";
	case RTW_RFCHIPID_RFMD2948:
		return "RFMD 2948";
	case RTW_RFCHIPID_INTERSIL:
		return "Intersil";
	case RTW_RFCHIPID_RTL8225:
		return "Realtek RTL8225";
	case RTW_RFCHIPID_RTL8255:
		return "Realtek RTL8255";
	default:
		return "unknown";
	}
}

d4574 2
a4575 2
	RTW_DPRINTF(RTW_DEBUG_PHYIO, ("%s: %s[%u] <- %#08x\n", __func__,
	    rtw_rfchipid_string(sc->sc_rfchipid), addr, val));
@


1.46
log
@change read/write callbacks to use a void * instead of struct rtw_regs.
why? rtw uses the smc93cx6 EEPROM and a separate diff will allow
accessing it without depending on the bus_space_* functions. this is
required for the RTL8187L.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.45 2005/10/24 02:43:56 reyk Exp $	*/
a199 4
int	 rtw_rf_init(struct rtw_softc *, u_int, u_int8_t, enum rtw_pwrstate);
int	 rtw_rf_pwrstate(struct rtw_softc *, enum rtw_pwrstate);
int	 rtw_rf_tune(struct rtw_softc *, u_int);
int	 rtw_rf_txpower(struct rtw_softc *, u_int8_t);
d2021 1
a2021 1
	rc = rtw_rf_pwrstate(sc, power);
d3479 4
d3486 4
d3506 4
d3526 4
a3854 69
int
rtw_rf_init(struct rtw_softc *sc, u_int freq, u_int8_t opaque_txpower,
    enum rtw_pwrstate power)
{
	switch (sc->sc_rfchipid) {
	case RTW_RFCHIPID_PHILIPS:
		return rtw_sa2400_init(sc, freq, opaque_txpower, power);
	case RTW_RFCHIPID_MAXIM2820:
		return rtw_max2820_init(sc, freq, opaque_txpower, power);
	case RTW_RFCHIPID_RTL8225:
		return rtw_rtl8225_init(sc, freq, opaque_txpower, power);
	case RTW_RFCHIPID_RTL8255:
		return rtw_rtl8255_init(sc, freq, opaque_txpower, power);
	default:
		return (1);
	}
}

int
rtw_rf_pwrstate(struct rtw_softc *sc, enum rtw_pwrstate power)
{
	switch (sc->sc_rfchipid) {
	case RTW_RFCHIPID_PHILIPS:
		return rtw_sa2400_pwrstate(sc, power);
	case RTW_RFCHIPID_MAXIM2820:
		return rtw_max2820_pwrstate(sc, power);
	case RTW_RFCHIPID_RTL8225:
		return rtw_rtl8225_pwrstate(sc, power);
	case RTW_RFCHIPID_RTL8255:
		return rtw_rtl8255_pwrstate(sc, power);
	default:
		return (1);
	}
}

int
rtw_rf_tune(struct rtw_softc *sc, u_int freq)
{
	switch (sc->sc_rfchipid) {
	case RTW_RFCHIPID_PHILIPS:
		return rtw_sa2400_tune(sc, freq);
	case RTW_RFCHIPID_MAXIM2820:
		return rtw_max2820_tune(sc, freq);
	case RTW_RFCHIPID_RTL8225:
		return rtw_rtl8225_tune(sc, freq);
	case RTW_RFCHIPID_RTL8255:
		return rtw_rtl8255_tune(sc, freq);
	default:
		return (1);
	}
}

int
rtw_rf_txpower(struct rtw_softc *sc, u_int8_t opaque_txpower)
{
	switch (sc->sc_rfchipid) {
	case RTW_RFCHIPID_PHILIPS:
		return rtw_sa2400_txpower(sc, opaque_txpower);
	case RTW_RFCHIPID_MAXIM2820:
		return rtw_max2820_txpower(sc, opaque_txpower);
	case RTW_RFCHIPID_RTL8225:
		return rtw_rtl8225_txpower(sc, opaque_txpower);
	case RTW_RFCHIPID_RTL8255:
		return rtw_rtl8255_txpower(sc, opaque_txpower);
	default:
		return (1);
	}
}

d4310 1
a4310 1
	if ((rc = rtw_rf_txpower(sc, opaque_txpower)) != 0)
d4315 1
a4315 1
	if ((rc = rtw_rf_tune(sc, freq)) != 0)
d4318 1
a4318 1
	if ((rc = rtw_rf_init(sc, freq, opaque_txpower, power)) != 0)
d4321 1
a4321 1
	if ((rc = rtw_rf_txpower(sc, opaque_txpower)) != 0)
@


1.45
log
@fix RTW_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.44 2005/10/24 02:41:58 reyk Exp $	*/
d246 7
a252 7
u_int8_t rtw_read8(struct rtw_regs *, u_int32_t);
u_int16_t rtw_read16(struct rtw_regs *, u_int32_t);
u_int32_t rtw_read32(struct rtw_regs *, u_int32_t);
void	 rtw_write8(struct rtw_regs *, u_int32_t, u_int8_t);
void	 rtw_write16(struct rtw_regs *, u_int32_t, u_int16_t);
void	 rtw_write32(struct rtw_regs *, u_int32_t, u_int32_t);
void	 rtw_barrier(struct rtw_regs *, u_int32_t, u_int32_t, int);
d4769 1
a4769 1
rtw_read8(struct rtw_regs *regs, u_int32_t off)
d4771 1
d4776 1
a4776 1
rtw_read16(struct rtw_regs *regs, u_int32_t off)
d4778 1
d4783 1
a4783 1
rtw_read32(struct rtw_regs *regs, u_int32_t off)
d4785 1
d4790 1
a4790 1
rtw_write8(struct rtw_regs *regs, u_int32_t off, u_int8_t val)
d4792 1
d4797 1
a4797 1
rtw_write16(struct rtw_regs *regs, u_int32_t off, u_int16_t val)
d4799 1
d4804 1
a4804 1
rtw_write32(struct rtw_regs *regs, u_int32_t off, u_int32_t val)
d4806 1
d4811 1
a4811 1
rtw_barrier(struct rtw_regs *regs, u_int32_t reg0, u_int32_t reg1, int flags)
d4813 1
@


1.44
log
@change RTW_ANAPARM to RTW_ANAPARM_0 for consistency with the rtl8225 code.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.43 2005/10/23 12:57:42 jsg Exp $	*/
d4656 1
a4656 1
	    rtw_rfchipid_string(rfchipid), addr, val));
@


1.43
log
@Move rtw_attach error condition handling out of rtw_detach and into
rtw_attach simplifying things in the process. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.42 2005/10/23 08:47:14 reyk Exp $	*/
d407 1
a407 1
	anaparm = RTW_READ(regs, RTW_ANAPARM);
d412 2
a413 2
	RTW_WRITE(regs, RTW_ANAPARM, anaparm);
	RTW_SYNC(regs, RTW_ANAPARM, RTW_ANAPARM);
d1877 1
a1877 1
	anaparm = RTW_READ(regs, RTW_ANAPARM);
d1904 2
a1905 2
	RTW_WRITE(regs, RTW_ANAPARM, anaparm);
	RTW_SYNC(regs, RTW_ANAPARM, RTW_ANAPARM);
d1917 1
a1917 1
	anaparm = RTW_READ(regs, RTW_ANAPARM);
d1944 2
a1945 2
	RTW_WRITE(regs, RTW_ANAPARM, anaparm);
	RTW_SYNC(regs, RTW_ANAPARM, RTW_ANAPARM);
d1954 1
a1954 1
	anaparm = RTW_READ(regs, RTW_ANAPARM);
d1986 2
a1987 2
	RTW_WRITE(regs, RTW_ANAPARM, anaparm);
	RTW_SYNC(regs, RTW_ANAPARM, RTW_ANAPARM);
@


1.42
log
@use read/write/barrier callbacks, will be used later

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.41 2005/10/23 08:23:00 reyk Exp $	*/
d3561 1
a3566 1
	NEXT_ATTACH_STATE(sc, DETACHED);
d3607 1
a3607 1
		goto err;
a3609 2
	NEXT_ATTACH_STATE(sc, FINISH_DESC_ALLOC);

d3617 1
a3617 1
		goto err;
a3618 1
	NEXT_ATTACH_STATE(sc, FINISH_DESC_MAP);
d3626 1
a3626 1
		goto err;
a3627 1
	NEXT_ATTACH_STATE(sc, FINISH_DESCMAP_CREATE);
d3643 1
a3643 1
		goto err;
a3644 1
	NEXT_ATTACH_STATE(sc, FINISH_DESCMAP_LOAD);
d3647 1
a3647 2
		goto err;
	NEXT_ATTACH_STATE(sc, FINISH_TXCTLBLK_SETUP);
a3650 2
	NEXT_ATTACH_STATE(sc, FINISH_TXDESCBLK_SETUP);

d3661 1
a3661 1
			goto err;
a3664 1
	NEXT_ATTACH_STATE(sc, FINISH_TXMAPS_CREATE);
d3669 1
a3669 1
		goto err;
a3670 1
	NEXT_ATTACH_STATE(sc, FINISH_RXMAPS_CREATE);
d3674 1
a3674 2
		goto err;
	NEXT_ATTACH_STATE(sc, FINISH_RESET);
d3683 1
a3683 3
		goto err;

	NEXT_ATTACH_STATE(sc, FINISH_READ_SROM);
d3688 1
a3688 1
		goto err;
a3696 2
	NEXT_ATTACH_STATE(sc, FINISH_PARSE_SROM);

d3700 1
a3700 1
		goto err;
a3702 2
	NEXT_ATTACH_STATE(sc, FINISH_RF_ATTACH);

d3717 1
a3717 2
		goto err;
	NEXT_ATTACH_STATE(sc, FINISH_ID_STA);
d3789 13
a3801 1
	NEXT_ATTACH_STATE(sc, FINISHED);
d3803 21
a3823 3
	return;
err:
	rtw_detach(sc);
d3830 1
a3830 2
	int pri;
	struct rtw_srom *sr;
d3832 1
a3832 1
	sc->sc_flags |= RTW_F_INVALID;
d3834 5
a3838 3
	switch (sc->sc_attach_state) {
	case FINISHED:
		rtw_stop(&sc->sc_if, 1);
a3839 51
		rtw_disestablish_hooks(&sc->sc_hooks, sc->sc_dev.dv_xname,
		    (void*)sc);
		timeout_del(&sc->sc_scan_to);
		ieee80211_ifdetach(&sc->sc_if);
		if_detach(&sc->sc_if);
		break;
	case FINISH_ID_STA:
	case FINISH_RF_ATTACH:
	case FINISH_PARSE_SROM:
	case FINISH_READ_SROM:
		sr = &sc->sc_srom;
		sr->sr_size = 0;
		if (sr->sr_content != NULL) {
			free(sr->sr_content, M_DEVBUF);
			sr->sr_content = NULL;
		}
		/*FALLTHROUGH*/
	case FINISH_RESET:
	case FINISH_RXMAPS_CREATE:
		rtw_rxdesc_dmamaps_destroy(sc->sc_dmat, &sc->sc_rxsoft[0],
		    RTW_RXQLEN);
		/*FALLTHROUGH*/
	case FINISH_TXMAPS_CREATE:
		for (pri = 0; pri < RTW_NTXPRI; pri++) {
			rtw_txdesc_dmamaps_destroy(sc->sc_dmat,
			    sc->sc_txsoft_blk[pri].tsb_desc,
			    sc->sc_txsoft_blk[pri].tsb_ndesc);
		}
		/*FALLTHROUGH*/
	case FINISH_TXDESCBLK_SETUP:
	case FINISH_TXCTLBLK_SETUP:
		rtw_txsoft_blk_cleanup_all(sc);
		/*FALLTHROUGH*/
	case FINISH_DESCMAP_LOAD:
		bus_dmamap_unload(sc->sc_dmat, sc->sc_desc_dmamap);
		/*FALLTHROUGH*/
	case FINISH_DESCMAP_CREATE:
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_desc_dmamap);
		/*FALLTHROUGH*/
	case FINISH_DESC_MAP:
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_descs,
		    sizeof(struct rtw_descs));
		/*FALLTHROUGH*/
	case FINISH_DESC_ALLOC:
		bus_dmamem_free(sc->sc_dmat, &sc->sc_desc_segs,
		    sc->sc_desc_nsegs);
		/*FALLTHROUGH*/
	case DETACHED:
		NEXT_ATTACH_STATE(sc, DETACHED);
		break;
	}
@


1.41
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.40 2005/09/15 00:59:11 jsg Exp $	*/
d246 8
d3568 11
d4803 44
@


1.40
log
@Move two tiny sa2400 init functions back into calling sa2400 init function.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.39 2005/09/15 00:33:48 jsg Exp $	*/
d3876 1
a3876 1
		return (1);	
d3893 1
a3893 1
		return (1);	
d3910 1
a3910 1
		return (1);	
d3927 1
a3927 1
		return (1);	
d4375 2
a4376 1
	u_int8_t opaque_txpower = rtw_chan2txpower(&sc->sc_srom, ic, ic->ic_bss->ni_chan);
@


1.39
log
@Remove rtw_rfbus_write abstraction for readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.38 2005/09/14 23:40:23 jsg Exp $	*/
a211 1
int	 rtw_sa2400_manrx_init(struct rtw_softc *);
a215 1
int	 rtw_sa2400_agc_init(struct rtw_softc *);
a4100 15
rtw_sa2400_manrx_init(struct rtw_softc *sc)
{
	u_int32_t manrx;

	/* XXX we are not supposed to be in RXMGC mode when we do
	 * this?
	 */
	manrx = SA2400_MANRX_AHSN;
	manrx |= SA2400_MANRX_TEN;
	manrx |= LSHIFT(1023, SA2400_MANRX_RXGAIN_MASK);

	return rtw_rf_macwrite(sc, SA2400_MANRX, manrx);
}

int
a4174 13
rtw_sa2400_agc_init(struct rtw_softc *sc)
{
	u_int32_t agc;

	agc = LSHIFT(25, SA2400_AGC_MAXGAIN_MASK);
	agc |= LSHIFT(7, SA2400_AGC_BBPDELAY_MASK);
	agc |= LSHIFT(15, SA2400_AGC_LNADELAY_MASK);
	agc |= LSHIFT(27, SA2400_AGC_RXONDELAY_MASK);

	return rtw_rf_macwrite(sc, SA2400_AGC, agc);
}

int
d4200 1
d4215 7
a4221 1
	if ((rc = rtw_sa2400_agc_init(sc)) != 0)
d4223 7
a4229 1
	if ((rc = rtw_sa2400_manrx_init(sc)) != 0)
@


1.38
log
@As the _create functions for all the rf transceivers now just set some
default values, remove them and do value setting in rtw_rf_attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.37 2005/09/14 23:20:17 jsg Exp $	*/
a203 1
int	 rtw_rfbus_write(struct rtw_softc *, int, u_int, u_int32_t);
d236 2
a237 2
int	 rtw_rf_hostwrite(struct rtw_regs *, int, u_int, u_int32_t);
int	 rtw_rf_macwrite(struct rtw_regs *, int, u_int, u_int32_t);
a3475 15
	case RTW_RFCHIPID_RTL8255:
	default:
		sc->sc_rf_write = rtw_rf_hostwrite;
		break;
	case RTW_RFCHIPID_INTERSIL:
	case RTW_RFCHIPID_PHILIPS:
	case RTW_RFCHIPID_GCT: /* XXX a guess */
	case RTW_RFCHIPID_RFMD2948:
		sc->sc_rf_write = (rtw_host_rfio) ? rtw_rf_hostwrite :
		    rtw_rf_macwrite;
		break;
	}

	switch (rfchipid) {
	case RTW_RFCHIPID_RTL8225:
a3932 6
int
rtw_rfbus_write(struct rtw_softc *sc, int rfchipid, u_int addr, u_int32_t val)
{
	return (*sc->sc_rf_write)(&(sc->sc_regs), rfchipid, addr, val);
}

d3987 1
a3987 2
	return rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_TX,
	    opaque_txpower);
d4070 1
a4070 2
	if ((rc = rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_SYNA,
	    syna)) != 0)
d4072 1
a4072 2
	if ((rc = rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_SYNB,
	    synb)) != 0)
d4074 1
a4074 2
	if ((rc = rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_SYNC,
	    sync)) != 0)
d4076 1
a4076 1
	return rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_SYND, 0x0);
d4099 1
a4099 2
	return rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
	    opmode);
d4114 1
a4114 2
	return rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_MANRX,
	    manrx);
d4131 1
a4131 2
	return rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
	    opmode);
d4155 1
a4155 2
	return rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
	    opmode);
d4168 2
a4169 2
	rc = rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
	    dccal);
d4180 1
a4180 2
	rc = rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
	    dccal);
d4201 1
a4201 2
	return rtw_rfbus_write(sc, RTW_RFCHIPID_PHILIPS, SA2400_AGC,
	    agc);
d4263 1
a4263 1
	return rtw_rfbus_write(sc, RTW_RFCHIPID_MAXIM2820, MAX2820_CHANNEL,
d4273 1
a4273 1
	if ((rc = rtw_rfbus_write(sc, RTW_RFCHIPID_MAXIM2820, MAX2820_TEST,
d4277 1
a4277 1
	if ((rc = rtw_rfbus_write(sc, RTW_RFCHIPID_MAXIM2820, MAX2820_ENABLE,
d4287 1
a4287 1
	if ((rc = rtw_rfbus_write(sc, RTW_RFCHIPID_MAXIM2820, MAX2820_SYNTH,
d4298 1
a4298 1
	if ((rc = rtw_rfbus_write(sc, RTW_RFCHIPID_MAXIM2820, MAX2820_RECEIVE,
d4304 1
a4304 1
	return rtw_rfbus_write(sc, RTW_RFCHIPID_MAXIM2820, MAX2820_TRANSMIT,
d4330 1
a4330 2
	return rtw_rfbus_write(sc, RTW_RFCHIPID_MAXIM2820,
	    MAX2820_ENABLE, enable);
d4682 1
a4682 1
rtw_rf_hostwrite(struct rtw_regs *regs, int rfchipid, u_int addr, u_int32_t val)
d4693 1
a4693 1
	switch (rfchipid) {
d4712 1
a4712 1
		if (rfchipid == RTW_RFCHIPID_GCT)
d4733 1
a4733 1
		printf("%s: unknown rfchipid %d\n", __func__, rfchipid);
d4737 1
a4737 1
	(*rf_bangbits)(regs, bits, lo_to_hi, nbits);
d4757 1
a4757 1
rtw_rf_macwrite(struct rtw_regs *regs, int rfchipid, u_int addr, u_int32_t val)
d4762 1
a4762 1
	    rtw_rfchipid_string(rfchipid), addr, val));
d4764 1
a4764 1
	switch (rfchipid) {
d4782 1
a4782 1
	switch (rfchipid) {
d4795 1
a4795 1
		printf("%s: unknown rfchipid %d\n", __func__, rfchipid);
d4799 1
a4799 1
	return rtw_rf_macbangbits(regs, reg);
@


1.37
log
@Remove rtw_rf/rtw_rfbus and some other related abstractions
which made things overly complicated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.36 2005/09/08 12:44:55 jsg Exp $	*/
a204 4
int	 rtw_sa2400_create(struct rtw_softc *);
int	 rtw_max2820_create(struct rtw_softc *);
int 	 rtw_rtl8225_create(struct rtw_softc *);
int	 rtw_rtl8255_create(struct rtw_softc *);
d3473 2
a3491 1
		rtw_rtl8225_create(sc);
a3494 1
		rtw_rtl8255_create(sc);
d3498 13
a3510 1
		rtw_max2820_create(sc);
d3514 13
a3526 1
		rtw_sa2400_create(sc);
a4287 22
int
rtw_sa2400_create(struct rtw_softc *sc)
{
	struct rtw_bbpset *bb = &sc->sc_bbpset;

	/* XXX magic */
	bb->bb_antatten = RTW_BBP_ANTATTEN_PHILIPS_MAGIC;
	bb->bb_chestlim =	0x00;
	bb->bb_chsqlim =	0xa0;
	bb->bb_ifagcdet =	0x64;
	bb->bb_ifagcini =	0x90;
	bb->bb_ifagclimit =	0x1a;
	bb->bb_lnadet =		0xe0;
	bb->bb_sys1 =		0x98;
	bb->bb_sys2 =		0x47;
	bb->bb_sys3 =		0x90;
	bb->bb_trl =		0x88;
	bb->bb_txagc =		0x38;

	return (0);
}

a4366 22
rtw_max2820_create(struct rtw_softc *sc)
{
	struct rtw_bbpset *bb = &sc->sc_bbpset;

	/* XXX magic */
	bb->bb_antatten = RTW_BBP_ANTATTEN_MAXIM_MAGIC;
	bb->bb_chestlim =	0;
	bb->bb_chsqlim =	159;
	bb->bb_ifagcdet =	100;
	bb->bb_ifagcini =	144;
	bb->bb_ifagclimit =	26;
	bb->bb_lnadet =		248;
	bb->bb_sys1 =		136;
	bb->bb_sys2 =		71;
	bb->bb_sys3 =		155;
	bb->bb_trl =		136;
	bb->bb_txagc =		8;

	return (0);
}

int
a4391 6
rtw_rtl8225_create(struct rtw_softc *sc)
{
	return (0);
}

int
a4413 6
}

int
rtw_rtl8255_create(struct rtw_softc *sc)
{
	return(0);
@


1.36
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.35 2005/07/18 02:43:27 fgsch Exp $	*/
d127 1
a127 2
void	 rtw_set_rfprog(struct rtw_regs *, enum rtw_rfchipid,
	    const char *);
d154 1
a154 1
struct rtw_rf * rtw_rf_attach(struct rtw_softc *, enum rtw_rfchipid, int);
d199 11
a209 6
struct rtw_rf *rtw_sa2400_create(struct rtw_regs *, rtw_rf_write_t, int);
struct rtw_rf *rtw_max2820_create(struct rtw_regs *, rtw_rf_write_t, int);
struct rtw_rf *rtw_rtl8225_create(struct rtw_regs *, rtw_rf_write_t);
struct rtw_rf *rtw_rtl8255_create(struct rtw_regs *, rtw_rf_write_t);
int	 rtw_phy_init(struct rtw_regs *, struct rtw_rf *, u_int8_t, u_int8_t,
	    u_int, int, int, enum rtw_pwrstate);
d214 11
a224 12
int	 rtw_sa2400_pwrstate(struct rtw_rf *, enum rtw_pwrstate);
int	 rtw_sa2400_txpower(struct rtw_rf *, u_int8_t);
int	 rtw_sa2400_tune(struct rtw_rf *, u_int);
int	 rtw_sa2400_manrx_init(struct rtw_sa2400 *);
int	 rtw_sa2400_vcocal_start(struct rtw_sa2400 *, int);
int	 rtw_sa2400_vco_calibration(struct rtw_sa2400 *);
int	 rtw_sa2400_filter_calibration(struct rtw_sa2400 *);
int	 rtw_sa2400_dc_calibration(struct rtw_sa2400 *);
int	 rtw_sa2400_agc_init(struct rtw_sa2400 *);
void	 rtw_sa2400_destroy(struct rtw_rf *);
int	 rtw_sa2400_calibrate(struct rtw_rf *, u_int);
int	 rtw_sa2400_init(struct rtw_rf *, u_int, u_int8_t,
d226 2
a227 3
int	 rtw_max2820_pwrstate(struct rtw_rf *, enum rtw_pwrstate);
void	 rtw_max2820_destroy(struct rtw_rf *);
int	 rtw_max2820_init(struct rtw_rf *, u_int, u_int8_t,
d229 4
a232 5
int	 rtw_max2820_txpower(struct rtw_rf *, u_int8_t);
int	 rtw_max2820_tune(struct rtw_rf *, u_int);
int	 rtw_rtl8225_pwrstate(struct rtw_rf *, enum rtw_pwrstate);
void	 rtw_rtl8225_destroy(struct rtw_rf *);
int	 rtw_rtl8225_init(struct rtw_rf *, u_int, u_int8_t,
d234 4
a237 5
int	 rtw_rtl8225_txpower(struct rtw_rf *, u_int8_t);
int	 rtw_rtl8225_tune(struct rtw_rf *, u_int);
int	 rtw_rtl8255_pwrstate(struct rtw_rf *, enum rtw_pwrstate);
void	 rtw_rtl8255_destroy(struct rtw_rf *);
int	 rtw_rtl8255_init(struct rtw_rf *, u_int, u_int8_t,
d239 4
a242 6
int	 rtw_rtl8255_txpower(struct rtw_rf *, u_int8_t);
int	 rtw_rtl8255_tune(struct rtw_rf *, u_int);
int	 rtw_rf_hostwrite(struct rtw_regs *, enum rtw_rfchipid, u_int,
	    u_int32_t);
int	 rtw_rf_macwrite(struct rtw_regs *, enum rtw_rfchipid, u_int,
	    u_int32_t);
d251 1
a251 1
const char *rtw_rfchipid_string(enum rtw_rfchipid);
d560 1
a560 1
	enum rtw_rfchipid *rfchipid = &sc->sc_rfchipid;
d764 1
a764 1
rtw_set_rfprog(struct rtw_regs *regs, enum rtw_rfchipid rfchipid,
d2024 1
a2024 1
	rc = rtw_rf_pwrstate(sc->sc_rf, power);
a2051 2
	int antdiv = sc->sc_flags & RTW_F_ANTDIV,
	    dflantb = sc->sc_flags & RTW_F_DFLANTB;
d2080 1
a2080 4
	if ((rc = rtw_phy_init(&sc->sc_regs, sc->sc_rf,
	    rtw_chan2txpower(&sc->sc_srom, ic, ic->ic_bss->ni_chan),
	    sc->sc_csthr, ic->ic_bss->ni_chan->ic_freq, antdiv,
	    dflantb, RTW_ON)) != 0) {
d3474 2
a3475 2
struct rtw_rf *
rtw_rf_attach(struct rtw_softc *sc, enum rtw_rfchipid rfchipid, int digphy)
a3476 3
	rtw_rf_write_t rf_write;
	struct rtw_rf *rf;

d3481 1
a3481 1
		rf_write = rtw_rf_hostwrite;
d3487 2
a3488 1
		rf_write = (rtw_host_rfio) ? rtw_rf_hostwrite : rtw_rf_macwrite;
a3489 1

d3494 1
a3494 1
		rf = rtw_rtl8225_create(&sc->sc_regs, rf_write);
d3498 1
a3498 1
		rf = rtw_rtl8255_create(&sc->sc_regs, rf_write);
d3502 1
a3502 1
		rf = rtw_max2820_create(&sc->sc_regs, rf_write, 0);
d3506 1
a3506 1
		rf = rtw_sa2400_create(&sc->sc_regs, rf_write, digphy);
d3514 1
a3514 1
		return NULL;
d3516 1
a3516 4
	rf->rf_continuous_tx_cb =
	    (rtw_continuous_tx_cb_t)rtw_continuous_tx_enable;
	rf->rf_continuous_tx_arg = (void *)sc;
	return rf;
d3691 1
a3691 4
	sc->sc_rf = rtw_rf_attach(sc, sc->sc_rfchipid,
	    sc->sc_flags & RTW_F_DIGPHY);

	if (sc->sc_rf == NULL) {
a3813 3
		rtw_rf_destroy(sc->sc_rf);
		sc->sc_rf = NULL;
		/*FALLTHROUGH*/
a3859 6
void
rtw_rf_destroy(struct rtw_rf *rf)
{
	(*rf->rf_destroy)(rf);
}

d3861 1
a3861 1
rtw_rf_init(struct rtw_rf *rf, u_int freq, u_int8_t opaque_txpower,
d3864 12
a3875 1
	return (*rf->rf_init)(rf, freq, opaque_txpower, power);
d3879 1
a3879 1
rtw_rf_pwrstate(struct rtw_rf *rf, enum rtw_pwrstate power)
d3881 12
a3892 1
	return (*rf->rf_pwrstate)(rf, power);
d3896 1
a3896 1
rtw_rf_tune(struct rtw_rf *rf, u_int freq)
d3898 12
a3909 1
	return (*rf->rf_tune)(rf, freq);
d3913 1
a3913 1
rtw_rf_txpower(struct rtw_rf *rf, u_int8_t opaque_txpower)
d3915 12
a3926 1
	return (*rf->rf_txpower)(rf, opaque_txpower);
d3930 1
a3930 2
rtw_rfbus_write(struct rtw_rfbus *bus, enum rtw_rfchipid rfchipid, u_int addr,
    u_int32_t val)
d3932 1
a3932 1
	return (*bus->b_write)(bus->b_regs, rfchipid, addr, val);
d3987 1
a3987 1
rtw_sa2400_txpower(struct rtw_rf *rf, u_int8_t opaque_txpower)
d3989 1
a3989 4
	struct rtw_sa2400 *sa = (struct rtw_sa2400 *)rf;
	struct rtw_rfbus *bus = &sa->sa_bus;

	return rtw_rfbus_write(bus, RTW_RFCHIPID_PHILIPS, SA2400_TX,
d4048 1
a4048 1
rtw_sa2400_tune(struct rtw_rf *rf, u_int freq)
a4049 2
	struct rtw_sa2400 *sa = (struct rtw_sa2400 *)rf;
	struct rtw_rfbus *bus = &sa->sa_bus;
d4073 1
a4073 1
	if ((rc = rtw_rfbus_write(bus, RTW_RFCHIPID_PHILIPS, SA2400_SYNA,
d4076 1
a4076 1
	if ((rc = rtw_rfbus_write(bus, RTW_RFCHIPID_PHILIPS, SA2400_SYNB,
d4079 1
a4079 1
	if ((rc = rtw_rfbus_write(bus, RTW_RFCHIPID_PHILIPS, SA2400_SYNC,
d4082 1
a4082 1
	return rtw_rfbus_write(bus, RTW_RFCHIPID_PHILIPS, SA2400_SYND, 0x0);
d4086 1
a4086 1
rtw_sa2400_pwrstate(struct rtw_rf *rf, enum rtw_pwrstate power)
a4087 2
	struct rtw_sa2400 *sa = (struct rtw_sa2400 *)rf;
	struct rtw_rfbus *bus = &sa->sa_bus;
d4102 1
a4102 1
	if (sa->sa_digphy)
d4105 1
a4105 1
	return rtw_rfbus_write(bus, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
d4110 1
a4110 1
rtw_sa2400_manrx_init(struct rtw_sa2400 *sa)
d4121 1
a4121 1
	return rtw_rfbus_write(&sa->sa_bus, RTW_RFCHIPID_PHILIPS, SA2400_MANRX,
d4126 1
a4126 1
rtw_sa2400_vcocal_start(struct rtw_sa2400 *sa, int start)
d4136 1
a4136 1
	if (sa->sa_digphy)
d4139 1
a4139 1
	return rtw_rfbus_write(&sa->sa_bus, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
d4144 1
a4144 1
rtw_sa2400_vco_calibration(struct rtw_sa2400 *sa)
d4148 1
a4148 1
	if ((rc = rtw_sa2400_vcocal_start(sa, 1)) != 0)
d4152 1
a4152 1
	return rtw_sa2400_vcocal_start(sa, 0);
d4156 1
a4156 1
rtw_sa2400_filter_calibration(struct rtw_sa2400 *sa)
d4161 1
a4161 1
	if (sa->sa_digphy)
d4164 1
a4164 1
	return rtw_rfbus_write(&sa->sa_bus, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
d4169 1
a4169 1
rtw_sa2400_dc_calibration(struct rtw_sa2400 *sa)
a4170 1
	struct rtw_rf *rf = &sa->sa_rf;
d4174 1
a4174 1
	(*rf->rf_continuous_tx_cb)(rf->rf_continuous_tx_arg, 1);
d4178 1
a4178 1
	rc = rtw_rfbus_write(&sa->sa_bus, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
d4190 1
a4190 1
	rc = rtw_rfbus_write(&sa->sa_bus, RTW_RFCHIPID_PHILIPS, SA2400_OPMODE,
d4197 1
a4197 1
	(*rf->rf_continuous_tx_cb)(rf->rf_continuous_tx_arg, 0);
d4203 1
a4203 1
rtw_sa2400_agc_init(struct rtw_sa2400 *sa)
d4212 1
a4212 1
	return rtw_rfbus_write(&sa->sa_bus, RTW_RFCHIPID_PHILIPS, SA2400_AGC,
a4215 8
void
rtw_sa2400_destroy(struct rtw_rf *rf)
{
	struct rtw_sa2400 *sa = (struct rtw_sa2400 *)rf;
	bzero(sa, sizeof(*sa));
	free(sa, M_DEVBUF);
}

d4217 1
a4217 1
rtw_sa2400_calibrate(struct rtw_rf *rf, u_int freq)
a4218 1
	struct rtw_sa2400 *sa = (struct rtw_sa2400 *)rf;
d4223 1
a4223 1
		if ((rc = rtw_sa2400_vco_calibration(sa)) != 0)
d4227 1
a4227 1
	if ((rc = rtw_sa2400_tune(rf, freq)) != 0)
d4229 1
a4229 1
	if ((rc = rtw_sa2400_filter_calibration(sa)) != 0)
d4232 2
a4233 2
	if (!sa->sa_digphy)
		return rtw_sa2400_dc_calibration(sa);
d4238 1
a4238 1
rtw_sa2400_init(struct rtw_rf *rf, u_int freq, u_int8_t opaque_txpower,
a4240 1
	struct rtw_sa2400 *sa = (struct rtw_sa2400 *)rf;
d4243 1
a4243 1
	if ((rc = rtw_sa2400_txpower(rf, opaque_txpower)) != 0)
d4248 1
a4248 1
		return rtw_sa2400_pwrstate(rf, power);
d4251 1
a4251 1
	if ((rc = rtw_sa2400_pwrstate(rf, RTW_SLEEP)) != 0)
d4254 1
a4254 1
	if ((rc = rtw_sa2400_tune(rf, freq)) != 0)
d4256 1
a4256 1
	if ((rc = rtw_sa2400_agc_init(sa)) != 0)
d4258 1
a4258 1
	if ((rc = rtw_sa2400_manrx_init(sa)) != 0)
d4261 1
a4261 1
	if ((rc = rtw_sa2400_calibrate(rf, freq)) != 0)
d4265 1
a4265 1
	return rtw_sa2400_pwrstate(rf, power);
d4268 2
a4269 2
struct rtw_rf *
rtw_sa2400_create(struct rtw_regs *regs, rtw_rf_write_t rf_write, int digphy)
d4271 1
a4271 21
	struct rtw_sa2400 *sa;
	struct rtw_rfbus *bus;
	struct rtw_rf *rf;
	struct rtw_bbpset *bb;

	sa = malloc(sizeof(*sa), M_DEVBUF, M_NOWAIT);
	if (sa == NULL)
		return NULL;
	bzero(sa, sizeof(struct rtw_sa2400));

	sa->sa_digphy = digphy;

	rf = &sa->sa_rf;
	bus = &sa->sa_bus;

	rf->rf_init = rtw_sa2400_init;
	rf->rf_destroy = rtw_sa2400_destroy;
	rf->rf_txpower = rtw_sa2400_txpower;
	rf->rf_tune = rtw_sa2400_tune;
	rf->rf_pwrstate = rtw_sa2400_pwrstate;
	bb = &rf->rf_bbpset;
d4287 1
a4287 4
	bus->b_regs = regs;
	bus->b_write = rf_write;

	return &sa->sa_rf;
d4292 1
a4292 1
rtw_max2820_tune(struct rtw_rf *rf, u_int freq)
a4293 3
	struct rtw_max2820 *mx = (struct rtw_max2820 *)rf;
	struct rtw_rfbus *bus = &mx->mx_bus;

d4297 1
a4297 1
	return rtw_rfbus_write(bus, RTW_RFCHIPID_MAXIM2820, MAX2820_CHANNEL,
a4300 8
void
rtw_max2820_destroy(struct rtw_rf *rf)
{
	struct rtw_max2820 *mx = (struct rtw_max2820 *)rf;
	bzero(mx, sizeof(*mx));
	free(mx, M_DEVBUF);
}

d4302 1
a4302 1
rtw_max2820_init(struct rtw_rf *rf, u_int freq, u_int8_t opaque_txpower,
a4304 2
	struct rtw_max2820 *mx = (struct rtw_max2820 *)rf;
	struct rtw_rfbus *bus = &mx->mx_bus;
d4307 1
a4307 1
	if ((rc = rtw_rfbus_write(bus, RTW_RFCHIPID_MAXIM2820, MAX2820_TEST,
d4311 1
a4311 1
	if ((rc = rtw_rfbus_write(bus, RTW_RFCHIPID_MAXIM2820, MAX2820_ENABLE,
d4316 1
a4316 1
	if ((rc = rtw_max2820_pwrstate(rf, power)) != 0)
d4321 1
a4321 1
	if ((rc = rtw_rfbus_write(bus, RTW_RFCHIPID_MAXIM2820, MAX2820_SYNTH,
d4325 1
a4325 1
	if ((rc = rtw_max2820_tune(rf, freq)) != 0)
d4332 1
a4332 1
	if ((rc = rtw_rfbus_write(bus, RTW_RFCHIPID_MAXIM2820, MAX2820_RECEIVE,
d4338 1
a4338 1
	return rtw_rfbus_write(bus, RTW_RFCHIPID_MAXIM2820, MAX2820_TRANSMIT,
d4343 1
a4343 1
rtw_max2820_txpower(struct rtw_rf *rf, u_int8_t opaque_txpower)
d4350 1
a4350 1
rtw_max2820_pwrstate(struct rtw_rf *rf, enum rtw_pwrstate power)
a4352 5
	struct rtw_max2820 *mx;
	struct rtw_rfbus *bus;

	mx = (struct rtw_max2820 *)rf;
	bus = &mx->mx_bus;
d4364 1
a4364 1
	return rtw_rfbus_write(bus, RTW_RFCHIPID_MAXIM2820,
d4368 2
a4369 2
struct rtw_rf *
rtw_max2820_create(struct rtw_regs *regs, rtw_rf_write_t rf_write, int is_a)
d4371 1
a4371 21
	struct rtw_max2820 *mx;
	struct rtw_rfbus *bus;
	struct rtw_rf *rf;
	struct rtw_bbpset *bb;

	mx = malloc(sizeof(*mx), M_DEVBUF, M_NOWAIT);
	if (mx == NULL)
		return NULL;
	bzero(mx, sizeof(struct rtw_max2820));

	mx->mx_is_a = is_a;

	rf = &mx->mx_rf;
	bus = &mx->mx_bus;

	rf->rf_init = rtw_max2820_init;
	rf->rf_destroy = rtw_max2820_destroy;
	rf->rf_txpower = rtw_max2820_txpower;
	rf->rf_tune = rtw_max2820_tune;
	rf->rf_pwrstate = rtw_max2820_pwrstate;
	bb = &rf->rf_bbpset;
d4387 1
a4387 4
	bus->b_regs = regs;
	bus->b_write = rf_write;

	return &mx->mx_rf;
d4391 1
a4391 1
rtw_rtl8225_pwrstate(struct rtw_rf *rf, enum rtw_pwrstate power)
a4395 8
void
rtw_rtl8225_destroy(struct rtw_rf *rf)
{
	struct rtw_rtl8225 *rt = (struct rtw_rtl8225 *)rf;
	bzero(rt, sizeof(*rt));
	free(rt, M_DEVBUF);
}

d4397 1
a4397 1
rtw_rtl8225_init(struct rtw_rf *rf, u_int freq, u_int8_t opaque_txpower,
d4404 1
a4404 1
rtw_rtl8225_txpower(struct rtw_rf *rf, u_int8_t opaque_txpower)
d4410 1
a4410 1
rtw_rtl8225_tune(struct rtw_rf *rf, u_int freq)
d4415 2
a4416 2
struct rtw_rf *
rtw_rtl8225_create(struct rtw_regs *regs, rtw_rf_write_t rf_write)
d4418 1
a4418 24
	struct rtw_rtl8225 *rt;
	struct rtw_rfbus *bus;
	struct rtw_rf *rf;
	struct rtw_bbpset *bb;

	rt = malloc(sizeof(*rt), M_DEVBUF, M_NOWAIT);
	if (rt == NULL)
		return NULL;
	bzero(rt, sizeof(struct rtw_rtl8225));

	rf = &rt->rt_rf;
	bus = &rt->rt_bus;

	rf->rf_init = rtw_rtl8225_init;
	rf->rf_destroy = rtw_rtl8225_destroy;
	rf->rf_txpower = rtw_rtl8225_txpower;
	rf->rf_tune = rtw_rtl8225_tune;
	rf->rf_pwrstate = rtw_rtl8225_pwrstate;
	bb = &rf->rf_bbpset;

	bus->b_regs = regs;
	bus->b_write = rf_write;

	return (&rt->rt_rf);
d4422 1
a4422 1
rtw_rtl8255_pwrstate(struct rtw_rf *rf, enum rtw_pwrstate power)
a4426 8
void
rtw_rtl8255_destroy(struct rtw_rf *rf)
{
	struct rtw_rtl8255 *rt = (struct rtw_rtl8255 *)rf;
	bzero(rt, sizeof(*rt));
	free(rt, M_DEVBUF);
}

d4428 1
a4428 1
rtw_rtl8255_init(struct rtw_rf *rf, u_int freq, u_int8_t opaque_txpower,
d4435 1
a4435 1
rtw_rtl8255_txpower(struct rtw_rf *rf, u_int8_t opaque_txpower)
d4441 1
a4441 1
rtw_rtl8255_tune(struct rtw_rf *rf, u_int freq)
d4446 2
a4447 2
struct rtw_rf *
rtw_rtl8255_create(struct rtw_regs *regs, rtw_rf_write_t rf_write)
d4449 1
a4449 24
	struct rtw_rtl8255 *rt;
	struct rtw_rfbus *bus;
	struct rtw_rf *rf;
	struct rtw_bbpset *bb;

	rt = malloc(sizeof(*rt), M_DEVBUF, M_NOWAIT);
	if (rt == NULL)
		return NULL;
	bzero(rt, sizeof(struct rtw_rtl8255));

	rf = &rt->rt_rf;
	bus = &rt->rt_bus;

	rf->rf_init = rtw_rtl8255_init;
	rf->rf_destroy = rtw_rtl8255_destroy;
	rf->rf_txpower = rtw_rtl8255_txpower;
	rf->rf_tune = rtw_rtl8255_tune;
	rf->rf_pwrstate = rtw_rtl8255_pwrstate;
	bb = &rf->rf_bbpset;

	bus->b_regs = regs;
	bus->b_write = rf_write;

	return (&rt->rt_rf);
a4451 1
/* freq is in MHz */
d4453 1
a4453 3
rtw_phy_init(struct rtw_regs *regs, struct rtw_rf *rf, u_int8_t opaque_txpower,
    u_int8_t cs_threshold, u_int freq, int antdiv, int dflantb,
    enum rtw_pwrstate power)
d4456 9
d4471 1
a4471 1
	if ((rc = rtw_rf_txpower(rf, opaque_txpower)) != 0)
d4473 1
a4473 1
	if ((rc = rtw_bbp_preinit(regs, rf->rf_bbpset.bb_antatten, dflantb,
d4476 1
a4476 1
	if ((rc = rtw_rf_tune(rf, freq)) != 0)
d4479 1
a4479 1
	if ((rc = rtw_rf_init(rf, freq, opaque_txpower, power)) != 0)
d4482 1
a4482 1
	if ((rc = rtw_rf_txpower(rf, opaque_txpower)) != 0)
d4485 1
a4485 1
	return rtw_bbp_init(regs, &rf->rf_bbpset, antdiv, dflantb,
d4727 1
a4727 1
rtw_rfchipid_string(enum rtw_rfchipid rfchipid)
d4751 1
a4751 2
rtw_rf_hostwrite(struct rtw_regs *regs, enum rtw_rfchipid rfchipid,
    u_int addr, u_int32_t val)
d4826 1
a4826 2
rtw_rf_macwrite(struct rtw_regs *regs, enum rtw_rfchipid rfchipid,
    u_int addr, u_int32_t val)
@


1.35
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.34 2005/06/15 01:33:50 jsg Exp $	*/
a69 1
#include <net80211/ieee80211_compat.h>
@


1.34
log
@Match RTL8255 transceiver and stub out related support functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.33 2005/06/13 13:37:51 jsg Exp $	*/
d1287 1
a1287 1
			panic("%s: could not load DMA map\n",
d2062 1
a2062 1
		panic("%s: chan == IEEE80211_CHAN_ANY\n", __func__);
d3172 1
a3172 1
		panic("%s: unexpected state IEEE80211_S_INIT\n", __func__);
@


1.33
log
@Move a bunch of small functions that only get called once into
their calling functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.32 2005/05/29 06:03:11 reyk Exp $	*/
d204 1
d236 6
d615 3
d3490 1
d3508 4
d4517 62
d4863 2
d4913 1
@


1.32
log
@use JAPAN for locale code 0 stored in some rtw EEPROMs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.31 2005/05/29 03:57:54 reyk Exp $	*/
a91 2
void	 rtw_srom_defaults(struct rtw_srom *, u_int32_t *, u_int8_t *,
	    enum rtw_rfchipid *, u_int32_t *);
a94 1
void	 rtw_txdescs_sync_all(struct rtw_txdesc_blk *);
a165 1
void	 rtw_srom_free(struct rtw_srom *);
a181 3
void	 rtw_setifprops(struct ifnet *, const char *, void *);
void	 rtw_set80211props(struct ieee80211com *);
void	 rtw_set80211methods(struct rtw_mtbl *, struct ieee80211com *);
a548 20
void
rtw_srom_free(struct rtw_srom *sr)
{
	sr->sr_size = 0;
	if (sr->sr_content == NULL)
		return;
	free(sr->sr_content, M_DEVBUF);
	sr->sr_content = NULL;
}

void
rtw_srom_defaults(struct rtw_srom *sr, u_int32_t *flags, u_int8_t *cs_threshold,
    enum rtw_rfchipid *rfchipid, u_int32_t *rcr)
{
	*flags |= (RTW_F_DIGPHY|RTW_F_ANTDIV);
	*cs_threshold = RTW_SR_ENERGYDETTHR_DEFAULT;
	*rcr |= RTW_RCR_ENCS1;
	*rfchipid = RTW_RFCHIPID_PHILIPS;
}

d574 4
a577 1
		rtw_srom_defaults(sr, flags, cs_threshold, rfchipid, rcr);
a976 10
rtw_txdescs_sync_all(struct rtw_txdesc_blk *tdb)
{
	int pri;
	for (pri = 0; pri < RTW_NTXPRI; pri++) {
		rtw_txdescs_sync(&tdb[pri], 0, tdb[pri].tdb_ndesc,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	}
}

void
d1565 1
a1565 1
	int rc;
d1567 1
d1587 5
a1591 1
	rtw_txdescs_sync_all(&sc->sc_txdesc_blk[0]);
d2042 2
a2043 1
	u_int chan;
d2068 7
a2201 3
#define	rtw_calchash(addr) \
	(ether_crc32_be((addr), IEEE80211_ADDR_LEN) >> 26)

d2261 2
a2262 1
		hash = rtw_calchash(enm->enm_addrlo);
a3357 47
rtw_setifprops(struct ifnet *ifp, const char *dvname, void *softc)
{
	bcopy(dvname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = softc;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST |
	    IFF_NOTRAILERS;
	ifp->if_ioctl = rtw_ioctl;
	ifp->if_start = rtw_start;
	ifp->if_watchdog = rtw_watchdog;
}

void
rtw_set80211props(struct ieee80211com *ic)
{
	int nrate;
	ic->ic_phytype = IEEE80211_T_DS;
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_caps = IEEE80211_C_PMGT | IEEE80211_C_IBSS |
	    IEEE80211_C_HOSTAP | IEEE80211_C_MONITOR | IEEE80211_C_WEP;

	nrate = 0;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] =
	    IEEE80211_RATE_BASIC | 2;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] =
	    IEEE80211_RATE_BASIC | 4;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] = 11;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] = 22;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_nrates = nrate;
}

void
rtw_set80211methods(struct rtw_mtbl *mtbl, struct ieee80211com *ic)
{
	mtbl->mt_newstate = ic->ic_newstate;
	ic->ic_newstate = rtw_newstate;

	mtbl->mt_recv_mgmt = ic->ic_recv_mgmt;
	ic->ic_recv_mgmt = rtw_recv_mgmt;

	mtbl->mt_node_free = ic->ic_node_free;
	ic->ic_node_free = rtw_node_free;

	mtbl->mt_node_alloc = ic->ic_node_alloc;
	ic->ic_node_alloc = rtw_node_alloc;
}

void
d3547 1
d3549 1
d3551 1
d3553 1
a3553 1
	int pri, rc;
d3718 8
a3725 1
	rtw_setifprops(&sc->sc_if, sc->sc_dev.dv_xname, (void*)sc);
d3729 13
a3741 1
	rtw_set80211props(&sc->sc_ic);
d3751 12
a3762 1
	rtw_set80211methods(&sc->sc_mtbl, &sc->sc_ic);
d3800 1
d3821 6
a3826 1
		rtw_srom_free(&sc->sc_srom);
@


1.31
log
@further cleanup - use bzero, bcopy and bcmp

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.30 2005/05/29 03:49:52 reyk Exp $	*/
d681 1
d869 1
@


1.30
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.29 2005/05/29 02:54:51 reyk Exp $	*/
d699 1
a699 1
	(void)memset(&sd, 0, sizeof(sd));
d726 1
a726 1
	(void)memset(sr->sr_content, 0, sr->sr_size);
d1627 1
a1627 2
	(void)memset(tdb->tdb_desc, 0,
	    sizeof(tdb->tdb_desc[0]) * tdb->tdb_ndesc);
d2279 1
a2279 1
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi,
d3187 1
a3187 2
			(void)memset(ic->ic_bss->ni_bssid, 0,
			    IEEE80211_ADDR_LEN);
d3381 1
a3381 1
	(void)memcpy(ifp->if_xname, dvname, IFNAMSIZ);
d3515 1
a3515 2
	(void)memset(tdb->tdb_desc, 0,
	    sizeof(tdb->tdb_desc[0]) * tdb->tdb_ndesc);
d4225 1
a4225 1
	memset(sa, 0, sizeof(*sa));
d4346 1
a4346 1
	memset(mx, 0, sizeof(*mx));
@


1.29
log
@cleanup rtw
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.28 2005/05/27 18:57:18 robert Exp $	*/
d42 2
a43 2
#include <sys/systm.h> 
#include <sys/mbuf.h>   
d56 1
a56 1
 
d60 1
a60 1
#if NBPFILTER > 0 
d62 1
a62 1
#endif 
d83 1
a84 1
int rtw_dwelltime = 200;	/* milliseconds per channel */
d293 10
a302 10
        switch (access) {
        case RTW_ACCESS_NONE:
                return "none";
        case RTW_ACCESS_CONFIG:
                return "config";
        case RTW_ACCESS_ANAPARM:
                return "anaparm";
        default:
                return "unknown";
        }
d361 1
a361 1
	    ("%s: access %s -> %s\n",__func__, 
d449 1
a449 1
	      LSHIFT(7, RTW_TCR_SRL_MASK) | LSHIFT(7, RTW_TCR_LRL_MASK);
d665 1
a665 1
	if (paname != NULL) 
d887 1
a887 1
	          idr1 = RTW_READ(regs, RTW_IDR1);
d1032 1
a1032 1
	MGETHDR(m, M_DONTWAIT, MT_DATA); 
d1036 1
a1036 1
	MCLGET(m, M_DONTWAIT); 
d1080 1
a1080 1
			       "rc %d\n", dvname, i, rc);
d1108 2
a1109 3
	RTW_DPRINTF(
	    kick ? (RTW_DEBUG_RECV_DESC | RTW_DEBUG_IO_KICK)
	         : RTW_DEBUG_RECV_DESC,
d1111 2
a1112 2
	     letoh32(obuf), letoh32(rd->rd_buf), letoh32(octl),
	     letoh32(rd->rd_ctl)));
d1480 1
a1480 1
		    htole32(RTW_TXSTAT_OWN)) != 0) 
d1605 3
a1607 2
	if ((rc = rtw_rxsoft_init_all(sc->sc_dmat, sc->sc_rxsoft, &rdb->rdb_ndesc,
	     sc->sc_dev.dv_xname)) != 0 && rdb->rdb_ndesc == 0) {
d1612 1
a1612 1
	
d2683 1
a2683 1
		                     tdbp, nip, if_flagsp)) != NULL) {
d2690 1
a2690 1
		                     tdbp, nip, if_flagsp)) != NULL) {
d2702 1
a2702 1
	                             tsbp, tdbp, nip, if_flagsp)) != NULL) {
d2775 2
a2776 2
			  BUS_DMA_WRITE|BUS_DMA_NOWAIT)) != 0 ||
	      dmam->dm_nsegs > ndescfree || rtw_seg_too_short(dmam)) && first;
d2900 1
a2900 2
			                            : sizeof(wh),
			    rate, 0);
d3016 1
a3016 1
		   htole32(RTW_TXCTL0_FS);
d3721 1
a3721 1
	                                    RTW_RXQLEN)) != 0) {
d4039 1
a4039 1
        case 2472:
d4042 1
a4042 1
        case 2484:
d4195 1
a4195 1
	dccal &= ~SA2400_OPMODE_MODE_MASK; 
d4199 1
a4199 1
	   dccal);
d4423 2
a4424 1
	return rtw_rfbus_write(bus, RTW_RFCHIPID_MAXIM2820, MAX2820_ENABLE, enable);
d4612 1
a4612 1
		                    RTW_BB_RD_MASK) == val) {
d4688 1
a4688 1
	
d4758 2
a4759 1
		if ((RTW_READ(regs, RTW8180_PHYCFG) & RTW8180_PHYCFG_MAC_POLL) == 0) {
d4765 1
a4765 1
		RTW_RBR(regs, RTW8180_PHYCFG, RTW8180_PHYCFG);	/* XXX paranoia? */
d4784 15
a4798 13
	static u_int8_t caesar[16] = {0x0, 0x8, 0x4, 0xc,
	                              0x2, 0xa, 0x6, 0xe,
				      0x1, 0x9, 0x5, 0xd,
				      0x3, 0xb, 0x7, 0xf};

	data_and_addr =  caesar[EXTRACT_NIBBLE(val, 2)] |
	                (caesar[EXTRACT_NIBBLE(val, 1)] <<  4) |
	                (caesar[EXTRACT_NIBBLE(val, 0)] <<  8) |
	                (caesar[(addr >> 1) & 0xf]      << 12) |
	                ((addr & 0x1)                   << 16) |
	                (caesar[EXTRACT_NIBBLE(val, 3)] << 24);
	return LSHIFT(data_and_addr,
	    RTW8180_PHYCFG_MAC_PHILIPS_ADDR_MASK|RTW8180_PHYCFG_MAC_PHILIPS_DATA_MASK);
d4831 1
a4831 1
	void (*rf_bangbits)(struct rtw_regs *, u_int32_t, int, u_int) =
d4842 1
a4842 1
		       LSHIFT(addr, MAX2820_TWI_ADDR_MASK);
d4848 1
a4848 1
		       LSHIFT(addr, SA2400_TWI_ADDR_MASK) | SA2400_TWI_WREN;
d4860 1
a4860 1
			       LSHIFT(addr, SI4126_TWI_ADDR_MASK);
d4917 4
a4920 4
		KASSERT(
		    (addr & ~PRESHIFT(RTW8180_PHYCFG_MAC_PHILIPS_ADDR_MASK)) == 0);
		KASSERT(
		    (val & ~PRESHIFT(RTW8180_PHYCFG_MAC_PHILIPS_DATA_MASK)) == 0);
d4923 1
a4923 1
		      LSHIFT(val, RTW8180_PHYCFG_MAC_PHILIPS_DATA_MASK);
@


1.28
log
@make sure to enable socket on resume.
in order for the enable to work disable the socket on suspend.
lot of help from mickey@@

ok jsg@@ millert@@
@
text
@d1 3
a3 2
/*	$OpenBSD: rtw.c,v 1.27 2005/05/23 23:14:30 jsg Exp $	*/
/* $NetBSD: rtw.c,v 1.29 2004/12/27 19:49:16 dyoung Exp $ */
d75 4
a78 3
#include <dev/ic/rtwphyio.h>
#include <dev/ic/rtwphy.h>

a80 6
#define	KASSERT2(__cond, __msg)		\
	do {				\
		if (!(__cond))		\
			panic __msg ;	\
	} while (0)

d83 2
d91 42
a132 50
#define NEXT_ATTACH_STATE(sc, state) do {			\
	DPRINTF(sc, RTW_DEBUG_ATTACH,				\
	    ("%s: attach state %s\n", __func__, #state));	\
	sc->sc_attach_state = state;				\
} while (0)

int rtw_dwelltime = 200;	/* milliseconds per channel */

void rtw_start(struct ifnet *);
void rtw_srom_defaults(struct rtw_srom *, u_int32_t *, u_int8_t *,
    enum rtw_rfchipid *, u_int32_t *);
void rtw_txdesc_blk_init_all(struct rtw_txdesc_blk *);
void rtw_txsoft_blk_init_all(struct rtw_txsoft_blk *);
void rtw_txdescs_sync(struct rtw_txdesc_blk *, u_int, u_int, int);
void rtw_txdescs_sync_all(struct rtw_txdesc_blk *);
void rtw_rxbufs_release(bus_dma_tag_t, struct rtw_rxsoft *);
void rtw_rxdesc_init(struct rtw_rxdesc_blk *, struct rtw_rxsoft *, int, int);
void rtw_io_enable(struct rtw_regs *, u_int8_t, int);
void rtw_intr_rx(struct rtw_softc *, u_int16_t);
void rtw_intr_beacon(struct rtw_softc *, u_int16_t);
void rtw_intr_atim(struct rtw_softc *);
void rtw_transmit_config(struct rtw_regs *);
void rtw_pktfilt_load(struct rtw_softc *);
void rtw_start(struct ifnet *);
void rtw_watchdog(struct ifnet *);
void rtw_next_scan(void *);
void rtw_recv_mgmt(struct ieee80211com *, struct mbuf *,
    struct ieee80211_node *, int, int, u_int32_t);
struct ieee80211_node * rtw_node_alloc(struct ieee80211com *);
void rtw_node_free(struct ieee80211com *, struct ieee80211_node *);
void rtw_media_status(struct ifnet *, struct ifmediareq *);
void rtw_txsoft_blk_cleanup_all(struct rtw_softc *);
void rtw_txdesc_blk_setup(struct rtw_txdesc_blk *, struct rtw_txdesc *,
    u_int, bus_addr_t, bus_addr_t);
void rtw_txdesc_blk_setup_all(struct rtw_softc *);
void rtw_intr_tx(struct rtw_softc *, u_int16_t);
void rtw_intr_ioerror(struct rtw_softc *, u_int16_t);
void rtw_intr_timeout(struct rtw_softc *);
void rtw_stop(struct ifnet *, int);
void rtw_maxim_pwrstate(struct rtw_regs *, enum rtw_pwrstate, int, int);
void rtw_philips_pwrstate(struct rtw_regs *, enum rtw_pwrstate, int, int);
void rtw_pwrstate0(struct rtw_softc *, enum rtw_pwrstate, int, int);
void rtw_join_bss(struct rtw_softc *, u_int8_t *, u_int16_t);
void rtw_set_access1(struct rtw_regs *, enum rtw_access);
int rtw_srom_parse(struct rtw_srom *, u_int32_t *, u_int8_t *,
    enum rtw_rfchipid *, u_int32_t *, enum rtw_locale *, const char *);
int rtw_srom_read(struct rtw_regs *, u_int32_t, struct rtw_srom *,
    const char *);
void rtw_set_rfprog(struct rtw_regs *, enum rtw_rfchipid,
    const char *);
d134 20
a153 20
    struct ieee80211_channel *);
int rtw_txsoft_blk_init(struct rtw_txsoft_blk *);
int rtw_rxsoft_init_all(bus_dma_tag_t, struct rtw_rxsoft *,
    int *, const char *);
void rtw_txsoft_release(bus_dma_tag_t, struct ieee80211com *,
    struct rtw_txsoft *);
void rtw_txsofts_release(bus_dma_tag_t, struct ieee80211com *,
    struct rtw_txsoft_blk *);
void rtw_hwring_setup(struct rtw_softc *);
int rtw_swring_setup(struct rtw_softc *);
void rtw_txdesc_blk_reset(struct rtw_txdesc_blk *);
void rtw_txdescs_reset(struct rtw_softc *);
void rtw_rxdescs_reset(struct rtw_softc *);
void rtw_rfmd_pwrstate(struct rtw_regs *, enum rtw_pwrstate, int, int);
int rtw_pwrstate(struct rtw_softc *, enum rtw_pwrstate);
int rtw_tune(struct rtw_softc *);
void rtw_set_nettype(struct rtw_softc *, enum ieee80211_opmode);
int rtw_init(struct ifnet *);
int rtw_ioctl(struct ifnet *, u_long, caddr_t);
int rtw_seg_too_short(bus_dmamap_t);
d155 4
a158 4
    u_int, short *, const char *);
int rtw_newstate(struct ieee80211com *, enum ieee80211_state, int);
int rtw_media_change(struct ifnet *);
int rtw_txsoft_blk_setup_all(struct rtw_softc *);
d161 35
a195 34
int rtw_chip_reset1(struct rtw_regs *, const char *);
int rtw_chip_reset(struct rtw_regs *, const char *);
int rtw_recall_eeprom(struct rtw_regs *, const char *);
int rtw_reset(struct rtw_softc *);
int rtw_txdesc_dmamaps_create(bus_dma_tag_t, struct rtw_txsoft *, u_int);
int rtw_rxdesc_dmamaps_create(bus_dma_tag_t, struct rtw_rxsoft *, u_int);
void rtw_rxdesc_dmamaps_destroy(bus_dma_tag_t, struct rtw_rxsoft *, u_int);
void rtw_txdesc_dmamaps_destroy(bus_dma_tag_t, struct rtw_txsoft *, u_int);
void rtw_srom_free(struct rtw_srom *);
void rtw_init_channels(enum rtw_locale, struct ieee80211_channel (*)[],
    const char*);
void rtw_identify_country(struct rtw_regs *, enum rtw_locale *, const char *);
int rtw_identify_sta(struct rtw_regs *, u_int8_t (*)[], const char *);
void rtw_rxdescs_sync(struct rtw_rxdesc_blk *, int, int, int);
int rtw_rxsoft_alloc(bus_dma_tag_t, struct rtw_rxsoft *);
void rtw_collect_txpkt(struct rtw_softc *, struct rtw_txdesc_blk *,
    struct rtw_txsoft *, int);
void rtw_collect_txring(struct rtw_softc *, struct rtw_txsoft_blk *,
    struct rtw_txdesc_blk *);
void rtw_suspend_ticks(struct rtw_softc *);
void rtw_resume_ticks(struct rtw_softc *);
void rtw_enable_interrupts(struct rtw_softc *);
int rtw_dequeue(struct ifnet *, struct rtw_txsoft_blk **,
    struct rtw_txdesc_blk **, struct mbuf **,
    struct ieee80211_node **);
void rtw_setifprops(struct ifnet *, const char *, void *);
void rtw_set80211props(struct ieee80211com *);
void rtw_set80211methods(struct rtw_mtbl *, struct ieee80211com *);
void rtw_establish_hooks(struct rtw_hooks *, const char *, void *);
void rtw_disestablish_hooks(struct rtw_hooks *, const char *, void *);
int rtw_txsoft_blk_setup(struct rtw_txsoft_blk *, u_int);
void rtw_rxdesc_init_all(struct rtw_rxdesc_blk *, struct rtw_rxsoft *, int);
int rtw_txring_choose(struct rtw_softc *, struct rtw_txsoft_blk **,
    struct rtw_txdesc_blk **, int);
d197 2
a198 2
    struct rtw_txsoft_blk **, struct rtw_txdesc_blk **,
    struct ieee80211_node **, short *);
d200 55
a254 8
void rtw_ibss_merge(struct rtw_softc *, struct ieee80211_node *, u_int32_t);

void rtw_led_attach(struct rtw_led_state *, void *);
void rtw_led_init(struct rtw_regs *);
void rtw_led_slowblink(void *);
void rtw_led_fastblink(void *);
void rtw_led_set(struct rtw_led_state *, struct rtw_regs *, int);
void rtw_led_newstate(struct rtw_softc *, enum ieee80211_state);
d257 6
a262 6
void rtw_print_txdesc(struct rtw_softc *, const char *,
    struct rtw_txsoft *, struct rtw_txdesc_blk *, int);
const char * rtw_access_string(enum rtw_access);
void rtw_dump_rings(struct rtw_softc *);
void rtw_print_txdesc(struct rtw_softc *, const char *,
    struct rtw_txsoft *, struct rtw_txdesc_blk *, int);
d266 1
a266 1
    NULL, "rtw", DV_IFNET
d577 1
a577 3
rtw_srom_parse(struct rtw_srom *sr, u_int32_t *flags, u_int8_t *cs_threshold,
    enum rtw_rfchipid *rfchipid, u_int32_t *rcr, enum rtw_locale *locale,
    const char *dvname)
d580 7
a586 1
	const char *rfname, *paname;
d596 2
a597 1
	    ("%s: SROM %d.%d\n", dvname, version >> 8, version & 0xff));
d609 1
a609 1
	    ("%s: EEPROM MAC %s\n", dvname, ether_sprintf(mac)));
d613 1
a613 1
	if ((RTW_SR_GET(sr, RTW_SR_CONFIG2) & RTW_CONFIG2_ANT) != 0)
d629 3
d636 1
a636 1
	case RTW_RFCHIPID_MAXIM:
d648 1
a648 1
	case RTW_RFCHIPID_RFMD:
d662 9
a670 1
		rfname = paname = scratch;
a671 1
	printf("radio %s, amp %s, ", rfname, paname);
d673 2
a674 2
	switch (RTW_SR_GET(sr, RTW_SR_CONFIG0) & RTW_CONFIG0_GL_MASK) {
	case RTW_CONFIG0_GL_USA:
d677 1
a677 1
	case RTW_CONFIG0_GL_EUROPE:
d680 1
a680 1
	case RTW_CONFIG0_GL_JAPAN:
d801 1
a801 1
	case RTW_RFCHIPID_RFMD:
d863 2
a864 2
	switch (cfg0 & RTW_CONFIG0_GL_MASK) {
	case RTW_CONFIG0_GL_USA:
d867 1
a867 1
	case RTW_CONFIG0_GL_JAPAN:
d870 1
a870 1
	case RTW_CONFIG0_GL_EUROPE:
d2011 7
d2148 1
a2148 1
rtw_transmit_config(struct rtw_regs *regs)
d2150 1
d2158 2
a2159 1
	tcr |= RTW_TCR_SAT;		/* send ACK as fast as possible */
d2240 1
a2240 1
	sc->sc_rcr &= ~(RTW_RCR_MXDMA_MASK | RTW_RCR_RXFTH_MASK);
d2246 1
a2246 1
	sc->sc_rcr |= RTW_RCR_MXDMA_1024 | RTW_RCR_RXFTH_WHOLE;
d2339 1
a2339 1
	rtw_transmit_config(regs);
d2347 4
a2350 1
	RTW_WRITE16(regs, RTW_BRSR, RTW_BRSR_MBR8180_2MBPS);
d2404 1
a2404 1
	cfg0 |= RTW_CONFIG0_LEDGPOEN;
d2461 1
a2461 1
rtw_led_set(struct rtw_led_state *ls, struct rtw_regs *regs, int hwverid)
d2479 1
a2479 1
	case 'F':
d2487 1
a2487 1
	case 'D':
d3152 1
a3152 1
	RTW_WRITE8(regs, RTW_SCR, 0);
d3551 1
d3558 1
a3558 1
	case RTW_RFCHIPID_RFMD:
d3565 5
a3569 1
	case RTW_RFCHIPID_MAXIM:
d3577 1
a3577 1
	case RTW_RFCHIPID_RFMD:
d3597 1
a3597 1
#define REVC (REVAB | RTW_RCR_RXFTH_WHOLE)
d3620 2
d3626 5
a3630 3
	switch (RTW_READ(&sc->sc_regs, RTW_TCR) & RTW_TCR_HWVERID_MASK) {
	case RTW_TCR_HWVERID_F:
		sc->sc_hwverid = 'F';
d3632 5
a3636 2
	case RTW_TCR_HWVERID_D:
		sc->sc_hwverid = 'D';
d3639 3
a3641 1
		sc->sc_hwverid = '?';
d3644 2
a3645 1
	printf("%s: ver %c, ", sc->sc_dev.dv_xname, sc->sc_hwverid);
d3745 1
a3745 3
	if (rtw_srom_parse(&sc->sc_srom, &sc->sc_flags, &sc->sc_csthr,
	    &sc->sc_rfchipid, &sc->sc_rcr, &sc->sc_locale,
	    sc->sc_dev.dv_xname) != 0) {
d3934 1007
@


1.27
log
@Remove some unuseful debug code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.26 2005/03/18 00:10:36 jsg Exp $	*/
d3292 1
a3292 1
		rtw_stop(ifp, 0);
@


1.26
log
@Only complain about tx fifo overflows if RTW_DEBUG is set.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.25 2005/03/15 09:24:53 jsg Exp $	*/
a224 1
void rtw_print_regs(struct rtw_regs *, const char *, const char *);
a230 109
#ifdef RTW_DEBUG
void
rtw_print_regs(struct rtw_regs *regs, const char *dvname, const char *where)
{
#define PRINTREG32(sc, reg)				\
	RTW_DPRINTF(RTW_DEBUG_REGDUMP,			\
	    ("%s: reg[ " #reg " / %03x ] = %08x\n",	\
	    dvname, reg, RTW_READ(regs, reg)))

#define PRINTREG16(sc, reg)				\
	RTW_DPRINTF(RTW_DEBUG_REGDUMP,			\
	    ("%s: reg[ " #reg " / %03x ] = %04x\n",	\
	    dvname, reg, RTW_READ16(regs, reg)))

#define PRINTREG8(sc, reg)				\
	RTW_DPRINTF(RTW_DEBUG_REGDUMP,			\
	    ("%s: reg[ " #reg " / %03x ] = %02x\n",	\
	    dvname, reg, RTW_READ8(regs, reg)))

	RTW_DPRINTF(RTW_DEBUG_REGDUMP, ("%s: %s\n", dvname, where));

	PRINTREG32(regs, RTW_IDR0);
	PRINTREG32(regs, RTW_IDR1);
	PRINTREG32(regs, RTW_MAR0);
	PRINTREG32(regs, RTW_MAR1);
	PRINTREG32(regs, RTW_TSFTRL);
	PRINTREG32(regs, RTW_TSFTRH);
	PRINTREG32(regs, RTW_TLPDA);
	PRINTREG32(regs, RTW_TNPDA);
	PRINTREG32(regs, RTW_THPDA);
	PRINTREG32(regs, RTW_TCR);
	PRINTREG32(regs, RTW_RCR);
	PRINTREG32(regs, RTW_TINT);
	PRINTREG32(regs, RTW_TBDA);
	PRINTREG32(regs, RTW_ANAPARM);
	PRINTREG32(regs, RTW_BB);
	PRINTREG32(regs, RTW_PHYCFG);
	PRINTREG32(regs, RTW_WAKEUP0L);
	PRINTREG32(regs, RTW_WAKEUP0H);
	PRINTREG32(regs, RTW_WAKEUP1L);
	PRINTREG32(regs, RTW_WAKEUP1H);
	PRINTREG32(regs, RTW_WAKEUP2LL);
	PRINTREG32(regs, RTW_WAKEUP2LH);
	PRINTREG32(regs, RTW_WAKEUP2HL);
	PRINTREG32(regs, RTW_WAKEUP2HH);
	PRINTREG32(regs, RTW_WAKEUP3LL);
	PRINTREG32(regs, RTW_WAKEUP3LH);
	PRINTREG32(regs, RTW_WAKEUP3HL);
	PRINTREG32(regs, RTW_WAKEUP3HH);
	PRINTREG32(regs, RTW_WAKEUP4LL);
	PRINTREG32(regs, RTW_WAKEUP4LH);
	PRINTREG32(regs, RTW_WAKEUP4HL);
	PRINTREG32(regs, RTW_WAKEUP4HH);
	PRINTREG32(regs, RTW_DK0);
	PRINTREG32(regs, RTW_DK1);
	PRINTREG32(regs, RTW_DK2);
	PRINTREG32(regs, RTW_DK3);
	PRINTREG32(regs, RTW_RETRYCTR);
	PRINTREG32(regs, RTW_RDSAR);
	PRINTREG32(regs, RTW_FER);
	PRINTREG32(regs, RTW_FEMR);
	PRINTREG32(regs, RTW_FPSR);
	PRINTREG32(regs, RTW_FFER);

	/* 16-bit registers */
	PRINTREG16(regs, RTW_BRSR);
	PRINTREG16(regs, RTW_IMR);
	PRINTREG16(regs, RTW_ISR);
	PRINTREG16(regs, RTW_BCNITV);
	PRINTREG16(regs, RTW_ATIMWND);
	PRINTREG16(regs, RTW_BINTRITV);
	PRINTREG16(regs, RTW_ATIMTRITV);
	PRINTREG16(regs, RTW_CRC16ERR);
	PRINTREG16(regs, RTW_CRC0);
	PRINTREG16(regs, RTW_CRC1);
	PRINTREG16(regs, RTW_CRC2);
	PRINTREG16(regs, RTW_CRC3);
	PRINTREG16(regs, RTW_CRC4);
	PRINTREG16(regs, RTW_CWR);

	/* 8-bit registers */
	PRINTREG8(regs, RTW_CR);
	PRINTREG8(regs, RTW_9346CR);
	PRINTREG8(regs, RTW_CONFIG0);
	PRINTREG8(regs, RTW_CONFIG1);
	PRINTREG8(regs, RTW_CONFIG2);
	PRINTREG8(regs, RTW_MSR);
	PRINTREG8(regs, RTW_CONFIG3);
	PRINTREG8(regs, RTW_CONFIG4);
	PRINTREG8(regs, RTW_TESTR);
	PRINTREG8(regs, RTW_PSR);
	PRINTREG8(regs, RTW_SCR);
	PRINTREG8(regs, RTW_PHYDELAY);
	PRINTREG8(regs, RTW_CRCOUNT);
	PRINTREG8(regs, RTW_PHYADDR);
	PRINTREG8(regs, RTW_PHYDATAW);
	PRINTREG8(regs, RTW_PHYDATAR);
	PRINTREG8(regs, RTW_CONFIG5);
	PRINTREG8(regs, RTW_TPPOLL);

	PRINTREG16(regs, RTW_BSSID16);
	PRINTREG32(regs, RTW_BSSID32);
#undef PRINTREG32
#undef PRINTREG16
#undef PRINTREG8
}
#endif /* RTW_DEBUG */


d2525 1
a2525 7
#ifdef RTW_DEBUG
			rtw_print_regs(&sc->sc_regs, ifp->if_xname, __func__);
#endif /* RTW_DEBUG */
		} else if ((sc->sc_flags & RTW_F_ENABLED) != 0) {
#ifdef RTW_DEBUG
			rtw_print_regs(&sc->sc_regs, ifp->if_xname, __func__);
#endif /* RTW_DEBUG */
a2526 1
		}
@


1.25
log
@Make attach errors appear on new lines and make
dmesg output less ugly while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.24 2005/03/12 07:05:48 jsg Exp $	*/
d1719 1
d1722 1
@


1.24
log
@Fix RTW_DEBUG compilation and add a few more sanity checks in addition to
rtw.c -r 1.45 from dyoung@@NetBSD:

Log Message:
Misc. changes to improve ad hoc mode and to enable hostap mode:

  Fix the work-around for the NIC bug where it skips to rx
  descriptor 0.  The driver used to skip to rx descriptor 1.
  Hopefully this stops the out-of-order packet reception that
  Charles Hannum saw.

When debugging is enabled, print rx-descriptor status flags
before printing the rx bit rate.

Add a debug message for when a beacon tx buffer reclamation.

Reset IFF_OACTIVE when we reset the transmitter.

Pass the consolidated LED state, a struct rtw_led_state,
to rtw_led_attach.

Choose the bit-rate for management frames (1Mb/s) at the
same place we choose for all other frames.

Do not use the NIC's short preamble or RTS options for
management frames.  Label beacons for the NIC.

Following a Linux driver, take care not to zero arbitrary
bits in the TPPOLL register.

Use the new idiom for IBSS merges: disable transmitter,
kick the state machine.

Add a second descriptor to the beacon ring.
The NIC seems to like this much better.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.23 2005/03/03 14:36:38 damien Exp $	*/
d510 1
a510 1
	printf("%s: reset failed\n", dvname);
d554 1
a554 1
	printf("%s: could not recall EEPROM in %dus\n", dvname, i * 200);
d663 2
a664 1
	printf("SROM %d.%d ", version >> 8, version & 0xff);
d697 2
a698 2
		rfname = "GCT GRF5101";
		paname = "Winspring WS9901";
d705 1
a705 1
		rfname = "Intersil HFA3873";	/* guess */
d719 1
a719 1
		paname = "RFMD RF2189";		/* mentioned in Realtek docs */
d728 1
a728 1
	printf("RF %s PA %s ", rfname, paname);
d805 1
a805 1
		printf("%s: could not read SROM\n", dvname);
d955 1
a955 1
		printf("%s: could not get mac address, attach failed\n",
d3680 1
a3680 1
	printf("%s: ver %c ", sc->sc_dev.dv_xname, sc->sc_hwverid);
d3687 1
a3687 1
		printf("%s: could not allocate hw descriptors, error %d\n",
d3699 1
a3699 1
		printf("%s: could not map hw descriptors, error %d\n",
d3709 1
a3709 1
		printf("%s: could not create DMA map for hw descriptors, "
d3727 1
a3727 1
		printf("%s: could not load DMA map for hw descriptors, "
d3748 1
a3748 1
			printf("%s: could not load DMA map for "
d3758 1
a3758 1
		printf("%s: could not load DMA map for hw rx descriptors, "
d3783 1
a3783 1
		printf("%s: attach failed, malformed serial ROM\n",
d3800 1
a3800 1
		printf("%s: attach failed, could not attach RF\n",
@


1.23
log
@addtion of a generic function for allocating beacons: ieee80211_beacon_alloc().
ok jsg@@, reyk@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.22 2005/03/02 11:14:12 jsg Exp $	*/
a117 1
void rtw_start_beacon(struct rtw_softc *, int);
d135 1
a135 2
void rtw_join_bss(struct rtw_softc *, uint8_t *, enum ieee80211_opmode,
    uint16_t);
d211 1
a211 1
void rtw_led_attach(struct rtw_softc *);
d1276 3
a1278 3
			    ("%s: NIC skipped to rxdesc[0]\n",
			     sc->sc_dev.dv_xname));
			next = 0;
d1282 25
d1321 3
d1334 3
a1336 23
#define PRINTSTAT(flag) do { \
	if ((hstat & flag) != 0) { \
		printf("%s" #flag, delim); \
		delim = ","; \
	} \
} while (0)
		if ((rtw_debug & RTW_DEBUG_RECV_DESC) != 0) {
			const char *delim = "<";
			printf("%s: ", sc->sc_dev.dv_xname);
			if ((hstat & RTW_RXSTAT_DEBUG) != 0) {
				printf("status %08x", hstat);
				PRINTSTAT(RTW_RXSTAT_SPLCP);
				PRINTSTAT(RTW_RXSTAT_MAR);
				PRINTSTAT(RTW_RXSTAT_PAR);
				PRINTSTAT(RTW_RXSTAT_BAR);
				PRINTSTAT(RTW_RXSTAT_PWRMGT);
				PRINTSTAT(RTW_RXSTAT_CRC32);
				PRINTSTAT(RTW_RXSTAT_ICV);
				printf(">, ");
			}
			printf("rate %d.%d Mb/s, time %08x%08x\n",
			    (rate * 5) / 10, (rate * 5) % 10, htsfth, htsftl);
		}
a1388 1
		m->m_flags |= M_HASFCS;
d1540 5
d1634 2
a1635 2
	    ("%s: reg[TLPDA] <- %" PRIxPTR "\n", __func__,
	     (uintptr_t)RTW_RING_BASE(sc, hd_txlo)));
d1637 2
a1638 2
	    ("%s: reg[TNPDA] <- %" PRIxPTR "\n", __func__,
	     (uintptr_t)RTW_RING_BASE(sc, hd_txmd)));
d1640 2
a1641 2
	    ("%s: reg[THPDA] <- %" PRIxPTR "\n", __func__,
	     (uintptr_t)RTW_RING_BASE(sc, hd_txhi)));
d1643 2
a1644 2
	    ("%s: reg[TBDA] <- %" PRIxPTR "\n", __func__,
	     (uintptr_t)RTW_RING_BASE(sc, hd_bcn)));
d1646 2
a1647 2
	    ("%s: reg[RDSAR] <- %" PRIxPTR "\n", __func__,
	     (uintptr_t)RTW_RING_BASE(sc, hd_rx)));
d1724 2
a1725 2
	RTW_DPRINTF(RTW_DEBUG_BUGS, ("%s: restarting xmit/recv\n",
	    sc->sc_dev.dv_xname));
d1755 1
d2451 1
a2451 1
	    ("%s: read %" PRIx8 " from reg[CONFIG1]\n", __func__, cfg1));
d2517 1
a2517 1
	    ("%s: LED condition %" PRIx8 "\n", __func__, led_condition));
d2541 2
a2542 1
	    ("%s: read %" PRIx8 " from reg[%#02x]\n", __func__, val, ofs));
d2547 2
a2548 1
	    ("%s: wrote %" PRIx8 " to reg[%#02x]\n", __func__, val, ofs));
d2593 1
a2593 1
rtw_led_attach(struct rtw_softc *sc)
d2595 2
a2596 4
	struct rtw_led_state *ls = &sc->sc_led_state;

	timeout_set(&ls->ls_fast_ch, rtw_led_fastblink, sc);
	timeout_set(&ls->ls_slow_ch, rtw_led_slowblink, sc);
a2913 2
	rate = MAX(2, ieee80211_get_rate(ic));

d2935 9
d2956 1
a2956 6
		wh = mtod(m0, struct ieee80211_frame *);

		if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
		    IEEE80211_FC0_TYPE_MGT) {
			ctl0 |= RTW_TXCTL0_RATE_1MBPS;
		} else switch (rate) {
d2972 12
a2993 4
		/* XXX >= ? */
		if (m0->m_pkthdr.len > ic->ic_rtsthreshold)
			ctl0 |= RTW_TXCTL0_RTSEN;

d3099 3
a3101 2
		RTW_WRITE8(&sc->sc_regs, RTW_TPPOLL,
		    tppoll | (tsb->tsb_poll & RTW_TPPOLL_ALL));
a3117 1
	u_int8_t tppoll;
d3146 1
a3146 3
			tppoll = RTW_READ8(&sc->sc_regs, RTW_TPPOLL);
			RTW_WRITE8(&sc->sc_regs, RTW_TPPOLL,
			    tppoll | RTW_TPPOLL_SALL);
d3151 1
a3160 7
rtw_start_beacon(struct rtw_softc *sc, int enable)
{
	/* TBD */
	return;
}

void
d3176 1
a3176 2
rtw_join_bss(struct rtw_softc *sc, uint8_t *bssid, enum ieee80211_opmode opmode,
    uint16_t intval0)
a3197 2
	rtw_set_nettype(sc, opmode);

a3222 1
		rtw_start_beacon(sc, 0);
a3232 4
	case IEEE80211_S_ASSOC:
		rtw_join_bss(sc, ic->ic_bss->ni_bssid, ic->ic_opmode,
		    ic->ic_bss->ni_intval);
		break;
d3240 1
a3240 2
			rtw_join_bss(sc, ic->ic_bss->ni_bssid, ic->ic_opmode,
			    ic->ic_bss->ni_intval);
d3250 1
d3259 2
a3260 1
			rtw_join_bss(sc, ic->ic_bss->ni_bssid, ic->ic_opmode,
a3263 1
		case IEEE80211_M_STA:
d3266 1
d3268 1
d3276 1
d3280 1
a3280 3
		rtw_start_beacon(sc, 1);
	else
		rtw_start_beacon(sc, 0);
d3302 1
d3307 7
a3313 2
		rtw_join_bss(sc, ic->ic_bss->ni_bssid, ic->ic_opmode,
		    ic->ic_bss->ni_intval);
d3829 1
a3829 1
	rtw_led_attach(sc);
@


1.22
log
@radiotap support largely based on NetBSD rtw.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.21 2005/02/27 09:32:46 jsg Exp $	*/
a2346 141
#define	IEEE80211_BEACON_TIMESTAMP_LEN		8
#define	IEEE80211_BEACON_BINTVL_LEN		2
#define	IEEE80211_BEACON_CAPINFO_LEN		2
#define	IEEE80211_TLV_SSID_LEN(__esslen)	(2 + (__esslen))
#define	IEEE80211_TLV_SUPRATES_LEN(__nrates)	(2 + (__nrates))
#define	IEEE80211_TLV_XSUPRATES_LEN(__nrates)	(2 + (__nrates))
#define	IEEE80211_TLV_DSPARMS_LEN		3
#define	IEEE80211_TLV_IBSSPARMS			4
#define	IEEE80211_TLV_MIN_TIM			6

#define	IEEE80211_TLV_ALLRATES_LEN(__nrates)	\
	(((__nrates) > IEEE80211_RATE_SIZE) ? 4 + (__nrates) : 2 + (__nrates))

/* TBD factor with ieee80211_getmbuf */
static struct mbuf *
rtw_getmbuf(int flags, int type, u_int pktlen)
{
	struct mbuf *m;

	KASSERT2(pktlen <= MCLBYTES, ("802.11 packet too large: %u", pktlen));
	MGETHDR(m, flags, type);
	if (m == NULL || pktlen <= MHLEN)
		return m;
	MCLGET(m, flags);
	if ((m->m_flags & M_EXT) != 0)
		return m;
	m_free(m);
	return NULL;
}

/* TBD factor with ath_beacon_alloc */
static struct mbuf *
rtw_beacon_alloc(struct rtw_softc *sc, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_frame *wh;
	struct mbuf *m;
	int pktlen;
	uint8_t *frm;
	uint16_t capinfo;
	struct ieee80211_rateset *rs;

	/*
	 * NB: the beacon data buffer must be 32-bit aligned;
	 * we assume the mbuf routines will return us something
	 * with this alignment (perhaps should assert).
	 */
	rs = &ni->ni_rates;
	pktlen = sizeof(struct ieee80211_frame)
	       + IEEE80211_BEACON_TIMESTAMP_LEN
	       + IEEE80211_BEACON_BINTVL_LEN
	       + IEEE80211_BEACON_CAPINFO_LEN
	       + IEEE80211_TLV_SSID_LEN(ni->ni_esslen)
	       + IEEE80211_TLV_ALLRATES_LEN(rs->rs_nrates)
	       + IEEE80211_TLV_DSPARMS_LEN
	       + MAX(IEEE80211_TLV_IBSSPARMS, IEEE80211_TLV_MIN_TIM);

	m = rtw_getmbuf(M_DONTWAIT, MT_DATA, pktlen);
	if (m == NULL) {
		RTW_DPRINTF(RTW_DEBUG_BEACON,
			("%s: cannot get mbuf/cluster; size %u\n",
			__func__, pktlen));
#if 0
		sc->sc_stats.ast_be_nombuf++;
#endif
		return NULL;
	}

	wh = mtod(m, struct ieee80211_frame *);
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_BEACON;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	*(u_int16_t *)wh->i_dur = 0;
	memcpy(wh->i_addr1, etherbroadcastaddr, IEEE80211_ADDR_LEN);
	memcpy(wh->i_addr2, ic->ic_myaddr, IEEE80211_ADDR_LEN);
	memcpy(wh->i_addr3, ni->ni_bssid, IEEE80211_ADDR_LEN);
	*(u_int16_t *)wh->i_seq = 0;

	/*
	 * beacon frame format
	 *	[8] time stamp
	 *	[2] beacon interval
	 *	[2] cabability information
	 *	[tlv] ssid
	 *	[tlv] supported rates
	 *	[tlv] parameter set (IBSS)
	 *	[tlv] extended supported rates
	 */
	frm = (u_int8_t *)&wh[1];
	/* timestamp is set by hardware */
	memset(frm, 0, IEEE80211_BEACON_TIMESTAMP_LEN);
	frm += IEEE80211_BEACON_TIMESTAMP_LEN;
	*(u_int16_t *)frm = htole16(ni->ni_intval);
	frm += IEEE80211_BEACON_BINTVL_LEN;
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		capinfo = IEEE80211_CAPINFO_IBSS;
	else
		capinfo = IEEE80211_CAPINFO_ESS;
	if (ic->ic_flags & IEEE80211_F_WEPON)
		capinfo |= IEEE80211_CAPINFO_PRIVACY;
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
	*(u_int16_t *)frm = htole16(capinfo);
	frm += IEEE80211_BEACON_CAPINFO_LEN;
	*frm++ = IEEE80211_ELEMID_SSID;
	*frm++ = ni->ni_esslen;
	memcpy(frm, ni->ni_essid, ni->ni_esslen);
	frm += ni->ni_esslen;
	frm = ieee80211_add_rates(frm, rs);
	*frm++ = IEEE80211_ELEMID_DSPARMS;
	*frm++ = 1;
	*frm++ = ieee80211_chan2ieee(ic, ni->ni_chan);
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		*frm++ = IEEE80211_ELEMID_IBSSPARMS;
		*frm++ = 2;
		*frm++ = 0; *frm++ = 0;		/* TODO: ATIM window */
	} else {
		/* TODO: TIM */
		*frm++ = IEEE80211_ELEMID_TIM;
		*frm++ = 4;	/* length */
		*frm++ = 0;	/* DTIM count */ 
		*frm++ = 1;	/* DTIM period */
		*frm++ = 0;	/* bitmap control */
		*frm++ = 0;	/* Partial Virtual Bitmap (variable length) */
	}
	frm = ieee80211_add_xrates(frm, rs);
	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);
	m->m_pkthdr.rcvif = (void *)ni;
	KASSERT2(m->m_pkthdr.len <= pktlen,
		("beacon bigger than expected, len %u calculated %u",
		m->m_pkthdr.len, pktlen));

	RTW_DPRINTF(RTW_DEBUG_BEACON,
	    ("%s: m %p len %u\n", __func__, m, m->m_len));

	return m;
}

d3246 1
a3246 1
			m = rtw_beacon_alloc(sc, ic->ic_bss);
@


1.21
log
@IBSS bits from NetBSD rtw.c -r 1.40
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.20 2005/02/25 12:18:27 jsg Exp $	*/
a202 1
void rtw_init_radiotap(struct rtw_softc *);
d1402 30
d3133 25
a3638 12
void
rtw_init_radiotap(struct rtw_softc *sc)
{
	memset(&sc->sc_rxtapu, 0, sizeof(sc->sc_rxtapu));
	sc->sc_rxtap.rr_ihdr.it_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.rr_ihdr.it_present = RTW_RX_RADIOTAP_PRESENT;

	memset(&sc->sc_txtapu, 0, sizeof(sc->sc_txtapu));
	sc->sc_txtap.rt_ihdr.it_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.rt_ihdr.it_present = RTW_TX_RADIOTAP_PRESENT;
}

d3978 8
a3990 2

	rtw_init_radiotap(sc);
@


1.20
log
@Add support for software WEP.
Pointers from and ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.19 2005/02/22 09:16:51 jsg Exp $	*/
d211 2
a212 2
void rtw_recv_beacon(struct rtw_softc *, struct mbuf *,
    struct ieee80211_node *, int, int, uint32_t);
d3366 13
d3380 2
a3381 2
rtw_recv_beacon(struct rtw_softc *sc, struct mbuf *m,
    struct ieee80211_node *ni, int subtype, int rssi, uint32_t rstamp)
d3383 7
a3389 1
	(*sc->sc_mtbl.mt_recv_mgmt)(&sc->sc_ic, m, ni, subtype, rssi, rstamp);
d3399 2
a3401 3
	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:
		/* do nothing: hardware answers probe request XXX */
		break;
d3404 4
a3407 1
		rtw_recv_beacon(sc, m, ni, subtype, rssi, rstamp);
a3409 1
		(*sc->sc_mtbl.mt_recv_mgmt)(ic, m, ni, subtype, rssi, rstamp);
@


1.19
log
@From part of NetBSD rtw.c rev 1.36:
In rtw_detach, flag the rtw as "invalid" (RTW_F_INVALID).  Do not
try to power-down the RF section of an invalid rtw.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.18 2005/02/19 03:33:30 jsg Exp $	*/
d2884 7
a3070 3
		if ((wh->i_fc[1] & IEEE80211_FC1_WEP) != 0)
			ctl0 |= LSHIFT(sc->sc_txkey, RTW_TXCTL0_KEYID_MASK);

d3072 1
a3072 1
		    ic->ic_flags, ic->ic_fragthreshold,
@


1.18
log
@From part of NetBSD rtw.c rev 1.42:
log message:
Program the LEDs based on operating state and packet activity.

 * On a Revision F RTL8180, blink LED1 at 1Hz to indicate
   scan/authenticate/associate states.  In the run state, turn LED1
   on.  In every state, blink LED1 at 5Hz to indicate non-beacon
   tx/rx activity.  I would like to use two LEDs, but in all my
   Rev. F instances, LED0 is not wired to an LED; instead, the
   first LED is wired to indicate that the card's power is on.

 * On a Revision D RTL8180, program the LEDs so that LED0 indicates
   Tx, and LED1 indicates Rx.  The Rx LED will blink annoyingly if
   there are beacons in the air, but at least the Tx LED is useful.

 * Store the hardware revision in the softc to support my futile
   attempt at programming LEDs for both Rev. D and Rev. F parts;
   I never did get Rev. D LEDs to work right.

 * Add a debug flag RTW_DEBUG_LED for the LED transitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.17 2005/02/17 18:28:05 reyk Exp $	*/
d2128 2
a2129 1
	if ((rc = rtw_pwrstate(sc, RTW_OFF)) != 0)
d2132 1
d3932 2
@


1.17
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.16 2005/02/14 12:49:29 jsg Exp $	*/
d214 6
d1387 3
d2537 161
d3153 1
d3289 2
d3889 2
@


1.16
log
@From NetBSD:

From part of rtw.c rev 1.42:
log message:

Add RTW_TPPOLL_ALL, RTW_TPPOLL_SALL to start and stop, respectively,
all of the transmit rings.

Revamp the transmit section to make better use of all the transmit
rings:  beacon queue, high-, low-, and medium-priority rings.  Put
beacon frames on the beacon ring.  All other management frames,
and data frames, go on the medium-priority ring.  Power-save data
frames go on the high-priority ring.  (Note that powersaving is
not implemented!)  This is a work in progress.

Send all 802.11 Management frames at 1Mbps.

After we put a packet on a transmit ring, tickle the right bit in
the TPPOLL to tell RTL8180.  Stop all rings on error and in rtw_stop.

And rtw.c rev 1.33:
log message:

Consolidate variables related to the rx ring in sc_rxdesc_blk,
which is a struct rtw_rxdesc_blk.

Put a copy of the DMA tag and the DMA map into the rx- and tx-ring
blocks so that I don't have to pass them to subroutines all of the
time.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.15 2005/02/08 11:08:56 jsg Exp $	*/
a1236 1
	struct ieee80211com *ic = &sc->sc_ic;
d1395 1
a1395 4
		if (ni == ic->ic_bss)
			ieee80211_unref_node(&ni);
		else
			ieee80211_free_node(&sc->sc_ic, ni);
d1425 1
a1425 4
	if (ni == ic->ic_bss)
		ieee80211_unref_node(&ni);
	else
		ieee80211_free_node(ic, ni);
d2999 1
a2999 2
	if (ni != ic->ic_bss)
		ieee80211_free_node(&sc->sc_ic, ni);
@


1.15
log
@From NetBSD:

sys/dev/ic/rtw.c rev 1.38:

	Use clue from rtk(4) and re(4) to fix the rtw(4) packet
	filter.  Previously, I was using the wrong CRC32 function
	to hash multicast addresses; to compensate, I set the
	multicast filter to all 1s.  Now that I hash the addresses
	correctly, I do not any longer set the filter to all 1s.

	In rtw_ioctl, avoid gratuitous re-initialization when the
	interface flags change.  If a !IFF_UP -> IFF_UP transition,
	call rtw_init(); otherwise, only reload the packet filter.

sys/dev/ic/rtwreg.h rev 1.10:

	Put useful combinations of Receiver Control Register flags
	in RTW_RCR_PKTFILT_MASK, RTW_RCR_MONITOR, and
	RTW_RCR_PKTFILT_DEFAULT.  (XXX RTW_RCR_MONITOR should be
	called RTW_RCR_PKTFILT_MONITOR.)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.14 2005/02/06 21:57:06 pedro Exp $	*/
a86 2
int rtw_flush_rfio = 1;
int rtw_rfio_delay = 0;
d90 1
d106 2
a107 4
void rtw_txdescs_sync(bus_dma_tag_t, bus_dmamap_t , struct rtw_txdesc_blk *,
    u_int, u_int, int);
void rtw_txdescs_sync_all(bus_dma_tag_t, bus_dmamap_t,
    struct rtw_txdesc_blk *);
d109 1
a109 2
void rtw_rxdesc_init_all(bus_dma_tag_t, bus_dmamap_t,
    struct rtw_rxdesc *, struct rtw_rxsoft *, int);
a135 2
void rtw_recv_beacon(struct rtw_softc *, struct mbuf *,
    struct ieee80211_node *, int, int, u_int32_t);
d148 2
a149 2
int rtw_rxsoft_init_all(bus_dma_tag_t, struct rtw_rxsoft *, u_int *,
    const char *);
d152 2
a153 2
void rtw_txsofts_release(bus_dma_tag_t, bus_dmamap_t,
    struct ieee80211com *, struct rtw_txsoft_blk *);
d155 1
a155 1
void rtw_swring_setup(struct rtw_softc *);
d166 1
a166 1
struct mbuf * rtw_dmamap_load_txsoft(bus_dma_tag_t, bus_dmamap_t, struct mbuf *,
a178 1
void rtw_rxsofts_setup(struct rtw_rxsoft *);
d186 1
a186 1
void rtw_rxdescs_sync(bus_dma_tag_t, bus_dmamap_t, u_int, u_int, int);
a187 2
void rtw_rxdesc_init(bus_dma_tag_t, bus_dmamap_t, struct rtw_rxdesc *,
    struct rtw_rxsoft *, int, int);
d205 8
a603 8
rtw_rxsofts_setup(struct rtw_rxsoft *descs)
{
	int i;
	for (i = 0; i < RTW_RXQLEN; i++)
		descs[i].rs_mbuf = NULL;
}

void
d1010 1
a1010 2
rtw_rxdescs_sync(bus_dma_tag_t dmat, bus_dmamap_t dmap, u_int desc0, u_int
    nsync, int ops)
d1012 1
a1012 1
	KASSERT(nsync <= RTW_RXQLEN);
d1014 2
a1015 2
	if (desc0 + nsync > RTW_RXQLEN) {
		bus_dmamap_sync(dmat, dmap,
d1017 2
a1018 2
		    sizeof(struct rtw_rxdesc) * (RTW_RXQLEN - desc0), ops);
		nsync -= (RTW_RXQLEN - desc0);
d1022 3
a1024 3
	KASSERT(desc0 < RTW_RXQLEN);
	KASSERT(nsync <= RTW_RXQLEN);
	KASSERT(desc0 + nsync <= RTW_RXQLEN);
d1027 1
a1027 1
	bus_dmamap_sync(dmat, dmap,
d1033 1
a1033 2
rtw_txdescs_sync(bus_dma_tag_t dmat, bus_dmamap_t dmap,
    struct rtw_txdesc_blk *tdb, u_int desc0, u_int nsync, int ops)
d1037 1
a1037 1
		bus_dmamap_sync(dmat, dmap,
d1046 1
a1046 1
	bus_dmamap_sync(dmat, dmap,
d1052 1
a1052 2
rtw_txdescs_sync_all(bus_dma_tag_t dmat, bus_dmamap_t dmap,
    struct rtw_txdesc_blk *tdb)
d1056 1
a1056 2
		rtw_txdescs_sync(dmat, dmap,
		    &tdb[pri], 0, tdb[pri].tdb_ndesc,
d1069 2
d1090 2
a1091 1
	if (m == NULL)
d1093 1
d1115 1
a1115 1
    u_int *next, const char *dvname)
d1117 1
a1117 1
	int i, rc;
d1122 13
a1134 7
		if ((rc = rtw_rxsoft_alloc(dmat, rs)) == 0)
			continue;
		printf("%s: failed rtw_rxsoft_alloc after %d buffers, rc = %d\n",
		    dvname, i, rc);
		if (i == 0) {
			rtw_rxbufs_release(dmat, desc);
			return rc;
d1137 2
a1138 2
	*next = 0;
	return 0;
d1142 2
a1143 2
rtw_rxdesc_init(bus_dma_tag_t dmat, bus_dmamap_t dmam,
    struct rtw_rxdesc *rd, struct rtw_rxsoft *rs, int idx, int kick)
d1145 3
a1147 2
	int is_last = (idx == RTW_RXQLEN - 1);
	u_int32_t ctl, octl, obuf;
d1169 2
a1170 2
	bus_dmamap_sync(dmat, rs->rs_dmamap, 0, rs->rs_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREREAD);
d1173 2
a1174 2
	bus_dmamap_sync(dmat, dmam, RTW_DESC_OFFSET(hd_rx, idx),
	    sizeof(struct rtw_rxdesc),
d1179 2
a1180 2
rtw_rxdesc_init_all(bus_dma_tag_t dmat, bus_dmamap_t dmam,
    struct rtw_rxdesc *desc, struct rtw_rxsoft *ctl, int kick)
d1186 2
a1187 2
	for (i = 0; i < RTW_RXQLEN; i++) {
		rd = &desc[i];
d1189 1
a1189 1
		rtw_rxdesc_init(dmat, dmam, rd, rs, i, kick);
d1191 1
d1222 4
a1228 1

d1230 1
a1230 1
	int hwrate, len, rate, rssi;
d1234 1
d1241 1
a1241 1
	KASSERT(sc->sc_rxnext < RTW_RXQLEN);
d1243 6
a1248 4
	for (next = sc->sc_rxnext; ; next = (next + 1) % RTW_RXQLEN) {
		rtw_rxdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap,
		    next, 1, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		rd = &sc->sc_rxdesc[next];
a1259 3
		KASSERT((hstat & (RTW_RXSTAT_FS|RTW_RXSTAT_LS)) ==
		    (RTW_RXSTAT_FS|RTW_RXSTAT_LS));

d1268 3
a1270 3
			rtw_rxdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap,
			    0, 1, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
			rd = &sc->sc_rxdesc[0];
d1371 6
d1401 1
a1401 2
		rtw_rxdesc_init(sc->sc_dmat, sc->sc_desc_dmamap,
		    rd, rs, next, 0);
d1403 1
a1403 1
	KASSERT(sc->sc_rxnext < RTW_RXQLEN);
d1405 1
a1405 1
	sc->sc_rxnext = next;
d1408 1
d1436 2
a1437 2
rtw_txsofts_release(bus_dma_tag_t dmat, bus_dmamap_t desc_dmamap,
    struct ieee80211com *ic, struct rtw_txsoft_blk *tsb)
d1497 1
a1497 2
		rtw_txdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap, tdb,
		    ts->ts_first, ndesc,
d1554 1
d1568 2
d1571 2
a1572 2
		rd = &sc->sc_rxdesc[desc];
		printf("%s: ctl %08x rsvd0/rssi %08x buf/tsftl %08x "
d1574 1
d1610 1
a1610 1
void
d1613 3
d1620 15
a1634 13
	rtw_rxdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap,
	    0, RTW_RXQLEN, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	rtw_rxsoft_init_all(sc->sc_dmat, sc->sc_rxsoft, &sc->sc_rxnext,
	    sc->sc_dev.dv_xname);
	rtw_rxdesc_init_all(sc->sc_dmat, sc->sc_desc_dmamap,
	    sc->sc_rxdesc, sc->sc_rxsoft, 1);

	rtw_txdescs_sync_all(sc->sc_dmat, sc->sc_desc_dmamap,
	    &sc->sc_txdesc_blk[0]);
#if 0	/* redundant with rtw_rxdesc_init_all */
	rtw_rxdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap,
	    0, RTW_RXQLEN, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
#endif
d1643 1
a1643 1
	    sizeof(tdb->tdb_desc[0]) *tdb->tdb_ndesc);
d1658 1
a1658 1
		rtw_txsofts_release(sc->sc_dmat, sc->sc_desc_dmamap, &sc->sc_ic,
d1661 1
a1661 2
		rtw_txdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap, tdb,
		    0, tdb->tdb_ndesc,
d1669 1
a1669 6
	/* Re-initialize descriptors, just in case. */
	rtw_rxdesc_init_all(sc->sc_dmat, sc->sc_desc_dmamap, sc->sc_rxdesc,
	    &sc->sc_rxsoft[0], 1);

	/* Reset to start of ring. */
	sc->sc_rxnext = 0;
d1860 1
a1860 3
		RTW_WRITE8(regs, RTW_TPPOLL,
		    RTW_TPPOLL_SBQ|RTW_TPPOLL_SHPQ|RTW_TPPOLL_SNPQ|
		    RTW_TPPOLL_SLPQ);
d1868 1
a1868 1
		rtw_txsofts_release(sc->sc_dmat, sc->sc_desc_dmamap, &sc->sc_ic,
d1872 3
a1874 1
	if (disable) {
a1875 2
		rtw_rxbufs_release(sc->sc_dmat, &sc->sc_rxsoft[0]);
	}
d2314 141
d2478 2
a2479 1
	rtw_swring_setup(sc);
d2485 1
a2485 1
	RTW_WRITE8(regs, RTW_MSR, 0x0); /* no link */
d2531 1
d2584 5
a2588 5
		if (rc == ENETRESET) {
			if (sc->sc_flags & IFF_RUNNING)
				rtw_pktfilt_load(sc);
			rc = 0;
		}
d2603 44
a2654 2
	struct rtw_txsoft_blk *tsb;
	struct rtw_txdesc_blk *tdb;
d2657 1
a2657 1
	struct ieee80211com *ic;
a2662 1
	*mp = NULL;
d2664 1
a2664 2
	tsb = &sc->sc_txsoft_blk[RTW_TXPRIMD];
	tdb = &sc->sc_txdesc_blk[RTW_TXPRIMD];
d2666 5
a2670 4
	if (SIMPLEQ_EMPTY(&tsb->tsb_freeq) || tdb->tdb_nfree == 0) {
		DPRINTF(sc, RTW_DEBUG_XMIT,
		    ("%s: out of descriptors\n", __func__));
		ifp->if_flags |= IFF_OACTIVE;
d2674 6
a2679 1
	ic = &sc->sc_ic;
d2681 1
a2681 7
	if (!IF_IS_EMPTY(&ic->ic_mgtq)) {
		IF_DEQUEUE(&ic->ic_mgtq, m0);
		*nip = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
		m0->m_pkthdr.rcvif = NULL;
		DPRINTF(sc, RTW_DEBUG_XMIT,
		    ("%s: dequeue mgt frame\n", __func__));
	} else if (ic->ic_state != IEEE80211_S_RUN) {
d2684 25
a2708 16
	} else if (!IF_IS_EMPTY(&ic->ic_pwrsaveq)) {
		IF_DEQUEUE(&ic->ic_pwrsaveq, m0);
		*nip = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
		m0->m_pkthdr.rcvif = NULL;
		DPRINTF(sc, RTW_DEBUG_XMIT,
		    ("%s: dequeue pwrsave frame\n", __func__));
	} else {
		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == NULL) {
			DPRINTF(sc, RTW_DEBUG_XMIT,
			    ("%s: no frame\n", __func__));
			return 0;
		}
		DPRINTF(sc, RTW_DEBUG_XMIT,
		    ("%s: dequeue data frame\n", __func__));
		ifp->if_opackets++;
d2710 2
a2711 2
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0);
d2713 5
a2717 6
		if ((m0 = ieee80211_encap(ifp, m0, nip)) == NULL) {
			DPRINTF(sc, RTW_DEBUG_XMIT,
			    ("%s: encap error\n", __func__));
			ifp->if_oerrors++;
			return -1;
		}
a2719 2
	*tsbp = tsb;
	*tdbp = tdb;
d2739 2
a2740 2
rtw_dmamap_load_txsoft(bus_dma_tag_t dmat, bus_dmamap_t dmam,
    struct mbuf *chain, u_int ndescfree, short *ifflagsp, const char *dvname)
d2837 3
d2843 1
a2843 14
	switch (rate = MAX(2, ieee80211_get_rate(ic))) {
	case 2:
		proto_ctl0 |= RTW_TXCTL0_RATE_1MBPS;
		break;
	case 4:
		proto_ctl0 |= RTW_TXCTL0_RATE_2MBPS;
		break;
	case 11:
		proto_ctl0 |= RTW_TXCTL0_RATE_5MBPS;
		break;
	case 22:
		proto_ctl0 |= RTW_TXCTL0_RATE_11MBPS;
		break;
	}
d2857 1
a2857 1
		m0 = rtw_dmamap_load_txsoft(sc->sc_dmat, dmamap, m0,
d2880 22
d2930 1
a2930 2
		rtw_txdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap,
		    tdb, ts->ts_first, dmamap->dm_nsegs,
d2973 1
a2973 2
		rtw_txdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap,
		    tdb, ts->ts_first, dmamap->dm_nsegs,
d2983 1
a2983 2
		rtw_txdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap,
		    tdb, ts->ts_first, 1,
d2989 4
a2992 2
		tsb->tsb_tx_timer = 5;
		ifp->if_timer = 1;
d2995 2
a2996 3

		/* TBD poke other queues. */
		RTW_WRITE8(&sc->sc_regs, RTW_TPPOLL, tppoll | RTW_TPPOLL_NPQ);
d2999 1
d3014 1
d3040 2
d3043 3
a3045 1
			RTW_WRITE8(&sc->sc_regs, RTW_TPPOLL, RTW_TPPOLL_SNPQ);
d3120 1
a3159 1
		case IEEE80211_M_AHDEMO:
d3162 8
d3197 1
a3197 1
    struct ieee80211_node *ni, int subtype, int rssi, u_int32_t rstamp)
d3438 3
d3443 1
a3443 1
		rc = rtw_txsoft_blk_setup(&sc->sc_txsoft_blk[pri], qlen[pri]);
d3447 4
d3610 8
d3636 1
a3636 3
	sc->sc_rxdesc = &sc->sc_descs->hd_rx[0];

	rtw_rxsofts_setup(&sc->sc_rxsoft[0]);
@


1.14
log
@Wait 10ms for the completion of the EEPROM recall process, allowing a
couple of specific adapters (such as mine) to be correctly initiated.
Discussed with and okay jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.13 2005/02/06 10:35:54 jsg Exp $	*/
a2214 1
/* XXX is the endianness correct? test. */
d2216 1
a2216 1
	(ether_crc32_le((addr), IEEE80211_ADDR_LEN) & BITS(5, 0))
d2232 2
a2233 1
#define RTW_RCR_MONITOR (RTW_RCR_ACRC32|RTW_RCR_APM|RTW_RCR_AAP|RTW_RCR_AB|RTW_RCR_ACF | RTW_RCR_AICV | RTW_RCR_ACRC32)
d2235 2
a2236 6
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		sc->sc_rcr |= RTW_RCR_MONITOR;
	else
		sc->sc_rcr &= ~RTW_RCR_MONITOR;

	/* XXX reference sources BEGIN */
d2238 2
a2239 6
	sc->sc_rcr |= RTW_RCR_AB | RTW_RCR_AM | RTW_RCR_APM;
#if 0
	/* receive broadcasts in our BSS */
	sc->sc_rcr |= RTW_RCR_ADD3;
#endif
	/* XXX reference sources END */
d2241 12
a2252 6
	/* receive pwrmgmt frames. */
	sc->sc_rcr |= RTW_RCR_APWRMGT;
	/* receive mgmt/ctrl/data frames. */
	sc->sc_rcr |= RTW_RCR_ADF | RTW_RCR_AMF;
	/* initialize Rx DMA threshold, Tx DMA burst size */
	sc->sc_rcr |= RTW_RCR_RXFTH_WHOLE | RTW_RCR_MXDMA_1024;
d2256 4
d2278 2
a2279 1
		hashes[hash >> 5] |= 1 << (hash & 0x1f);
a2282 5
	if (ifp->if_flags & IFF_BROADCAST) {
		hash = rtw_calchash(etherbroadcastaddr);
		hashes[hash >> 5] |= 1 << (hash & 0x1f);
	}

d2288 1
a2288 1
	if (ifp->if_flags & IFF_ALLMULTI)
d2290 2
a2291 5

	if (ic->ic_state == IEEE80211_S_SCAN)
		sc->sc_rcr |= RTW_RCR_AB;	/* accept all broadcast */

	hashes[0] = hashes[1] = 0xffffffff;
d2413 1
a2413 1
			if (0 && (sc->sc_flags & RTW_F_ENABLED) != 0) {
d2945 9
a2953 1
		if (ic->ic_opmode == IEEE80211_M_STA)
d2955 2
a2956 1
		/*FALLTHROUGH*/
a2957 14
#if 0
		rtw_write_bcn_thresh(sc);
		rtw_write_ssid(sc);
		rtw_write_sup_rates(sc);
#endif
		if (ic->ic_opmode == IEEE80211_M_AHDEMO ||
		    ic->ic_opmode == IEEE80211_M_MONITOR)
			break;

		/* TBD set listen interval */

#if 0
		rtw_tsf(sc);
#endif
@


1.13
log
@Remove some uneeded code to reduce delta to NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.12 2005/02/06 07:08:24 jsg Exp $	*/
d540 2
a541 2
	/* wait 2.5ms for completion */
	for (i = 0; i < 25; i++) {
d545 2
a546 2
			    ("%s: recall EEPROM in %dus\n", dvname, i * 100));
			return 0;
d549 1
a549 1
		DELAY(100);
d551 4
a554 2
	printf("%s: recall EEPROM failed\n", dvname);
	return ETIMEDOUT;
@


1.12
log
@Fix a merge error that was causing a panic after associating.
Thanks to mcbride@@ for pointing me in the right direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.11 2005/01/22 11:22:17 jsg Exp $	*/
a44 4
#if 0
#include <sys/errno.h>
#include <sys/device.h>
#endif
a804 3
#if 0
	sd.sd_clkdelay = 50;
#endif
a875 33
#if 0
int
rtw_identify_rf(struct rtw_regs *regs, enum rtw_rftype *rftype,
    const char *dvname)
{
	u_int8_t cfg4;
	const char *name;

	cfg4 = RTW_READ8(regs, RTW_CONFIG4);

	switch (cfg4 & RTW_CONFIG4_RFTYPE_MASK) {
	case RTW_CONFIG4_RFTYPE_PHILIPS:
		*rftype = RTW_RFTYPE_PHILIPS;
		name = "Philips";
		break;
	case RTW_CONFIG4_RFTYPE_INTERSIL:
		*rftype = RTW_RFTYPE_INTERSIL;
		name = "Intersil";
		break;
	case RTW_CONFIG4_RFTYPE_RFMD:
		*rftype = RTW_RFTYPE_RFMD;
		name = "RFMD";
		break;
	default:
		name = "<unknown>";
		return ENXIO;
	}

	printf("%s: RF prog type %s\n", dvname, name);
	return 0;
}
#endif

a2347 3
#if 0
	RTW_WRITE(regs, RTW_FEMR, RTW_FEMR_GWAKE|RTW_FEMR_WKUP|RTW_FEMR_INTR);
#endif
a3341 13
#if 0
	CASSERT(RTW_DESC_ALIGNMENT % sizeof(struct rtw_txdesc) == 0,
	    "RTW_DESC_ALIGNMENT is not a multiple of "
	    "sizeof(struct rtw_txdesc)");

	CASSERT(RTW_DESC_ALIGNMENT % sizeof(struct rtw_rxdesc) == 0,
	    "RTW_DESC_ALIGNMENT is not a multiple of "
	    "sizeof(struct rtw_rxdesc)");

	CASSERT(RTW_DESC_ALIGNMENT % RTW_MAXPKTSEGS == 0,
	    "RTW_DESC_ALIGNMENT is not a multiple of RTW_MAXPKTSEGS");
#endif

a3472 9

#if 0
	if (rtw_identify_rf(&sc->sc_regs, &sc->sc_rftype,
	    sc->sc_dev.dv_xname) != 0) {
		printf("%s: attach failed, unknown RF unidentified\n",
		    sc->sc_dev.dv_xname);
		goto err;
	}
#endif
@


1.11
log
@Reduce diff to NetBSD.
From part of rtw.c rev 1.42:
Move the register access mode into struct rtw_regs.  Change
rtw_set_access, rtw_set_access1 to match.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.10 2005/01/22 10:14:25 jsg Exp $	*/
d2546 1
a2546 1
		IFQ_POLL(&ifp->if_snd, m0);
@


1.10
log
@Reduce diff to NetBSD.
From rtw.c rev 1.34:

I like the tlp/atw-style names for software descriptors, txsoft,
better than txctl.  Change from rtw_txctl/rtw_rxctl to
rtw_txsoft/rtw_rxsoft.  Change the descriptor blocks' names to
match: rtw_txctl_blk becomes rtw_txsoft_blk.  Change the member-name
prefixes for both software and hardware descriptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.9 2005/01/19 11:29:27 jsg Exp $	*/
d148 1
a148 1
void rtw_set_access1(struct rtw_regs *, enum rtw_access, enum rtw_access);
d357 1
a357 1
	rtw_set_access(sc, RTW_ACCESS_ANAPARM);
d359 2
a360 2
	rtw_set_access(sc, RTW_ACCESS_ANAPARM); /* XXX Voodoo from Linux. */
	rtw_set_access(sc, RTW_ACCESS_NONE);
d381 1
a381 2
rtw_set_access1(struct rtw_regs *regs,
    enum rtw_access oaccess, enum rtw_access naccess)
d384 2
a385 1
	KASSERT(oaccess >= RTW_ACCESS_NONE && oaccess <= RTW_ACCESS_ANAPARM);
d387 1
a387 1
	if (naccess == oaccess)
d392 1
a392 1
		switch (oaccess) {
d404 1
a404 1
		switch (oaccess) {
d416 1
a416 1
		switch (oaccess) {
d431 1
a431 1
rtw_set_access(struct rtw_softc *sc, enum rtw_access access)
d433 1
a433 1
	rtw_set_access1(&sc->sc_regs, sc->sc_access, access);
d435 2
a436 2
	    ("%s: access %s -> %s\n", sc->sc_dev.dv_xname,
	    rtw_access_string(sc->sc_access),
d438 1
a438 1
	sc->sc_access = access;
d2058 1
a2058 1
	rtw_set_access(sc, RTW_ACCESS_ANAPARM);
d2062 1
a2062 1
	rtw_set_access(sc, RTW_ACCESS_NONE);
d2228 1
a2228 1
	rtw_set_access(sc, RTW_ACCESS_CONFIG);
d2250 1
a2250 1
	rtw_set_access(sc, RTW_ACCESS_NONE);
d2376 1
a2376 1
	rtw_set_access(sc, RTW_ACCESS_CONFIG);
d2385 2
a2386 2
	rtw_set_access(sc, RTW_ACCESS_ANAPARM);
	rtw_set_access(sc, RTW_ACCESS_NONE);
d2926 1
a2926 1
	rtw_set_access(sc, RTW_ACCESS_CONFIG);
d2939 1
a2939 1
	rtw_set_access(sc, RTW_ACCESS_NONE);
@


1.9
log
@Remove the last of the rampant inline usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.8 2005/01/19 11:07:32 jsg Exp $	*/
d110 1
a110 1
void rtw_txctl_blk_init_all(struct rtw_txctl_blk *);
d115 1
a115 1
void rtw_rxbufs_release(bus_dma_tag_t, struct rtw_rxctl *);
d117 1
a117 1
    struct rtw_rxdesc *, struct rtw_rxctl *, int);
d133 1
a133 1
void rtw_txctl_blk_cleanup_all(struct rtw_softc *);
d157 2
a158 2
int rtw_txctl_blk_init(struct rtw_txctl_blk *);
int rtw_rxctl_init_all(bus_dma_tag_t, struct rtw_rxctl *, u_int *,
d160 4
a163 4
void rtw_txbuf_release(bus_dma_tag_t, struct ieee80211com *,
    struct rtw_txctl *);
void rtw_txbufs_release(bus_dma_tag_t, bus_dmamap_t,
    struct ieee80211com *, struct rtw_txctl_blk *);
d176 1
a176 1
struct mbuf * rtw_dmamap_load_txbuf(bus_dma_tag_t, bus_dmamap_t, struct mbuf *,
d180 1
a180 1
int rtw_txctl_blk_setup_all(struct rtw_softc *);
d187 5
a191 5
int rtw_txdesc_dmamaps_create(bus_dma_tag_t, struct rtw_txctl *, u_int);
int rtw_rxdesc_dmamaps_create(bus_dma_tag_t, struct rtw_rxctl *, u_int);
void rtw_rxctls_setup(struct rtw_rxctl *);
void rtw_rxdesc_dmamaps_destroy(bus_dma_tag_t, struct rtw_rxctl *, u_int);
void rtw_txdesc_dmamaps_destroy(bus_dma_tag_t, struct rtw_txctl *, u_int);
d198 1
a198 1
int rtw_rxbuf_alloc(bus_dma_tag_t, struct rtw_rxctl *);
d200 1
a200 1
    struct rtw_rxctl *, int, int);
d202 2
a203 2
    struct rtw_txctl *, int);
void rtw_collect_txring(struct rtw_softc *, struct rtw_txctl_blk *,
d208 1
a208 1
int rtw_dequeue(struct ifnet *, struct rtw_txctl_blk **,
d217 1
a217 1
int rtw_txctl_blk_setup(struct rtw_txctl_blk *, u_int);
d222 1
a222 1
    struct rtw_txctl *, struct rtw_txdesc_blk *, int);
d226 1
a226 1
    struct rtw_txctl *, struct rtw_txdesc_blk *, int);
d579 1
a579 1
rtw_txdesc_dmamaps_create(bus_dma_tag_t dmat, struct rtw_txctl *descs,
d585 1
a585 1
		    0, 0, &descs[i].stx_dmamap);
d593 1
a593 1
rtw_rxdesc_dmamaps_create(bus_dma_tag_t dmat, struct rtw_rxctl *descs,
d599 1
a599 1
		    &descs[i].srx_dmamap);
d607 1
a607 1
rtw_rxctls_setup(struct rtw_rxctl *descs)
d611 1
a611 1
		descs[i].srx_mbuf = NULL;
d615 1
a615 1
rtw_rxdesc_dmamaps_destroy(bus_dma_tag_t dmat, struct rtw_rxctl *descs,
d620 2
a621 2
		if (descs[i].srx_dmamap != NULL)
			bus_dmamap_destroy(dmat, descs[i].srx_dmamap);
d626 1
a626 1
rtw_txdesc_dmamaps_destroy(bus_dma_tag_t dmat, struct rtw_txctl *descs,
d631 2
a632 2
		if (descs[i].stx_dmamap != NULL)
			bus_dmamap_destroy(dmat, descs[i].stx_dmamap);
d1020 1
a1020 1
rtw_txdesc_blk_init_all(struct rtw_txdesc_blk *htcs)
d1027 2
a1028 2
		htcs[pri].htc_nfree = ndesc[pri];
		htcs[pri].htc_next = 0;
d1033 1
a1033 1
rtw_txctl_blk_init(struct rtw_txctl_blk *stc)
d1036 1
a1036 1
	struct rtw_txctl *stx;
d1038 6
a1043 6
	SIMPLEQ_INIT(&stc->stc_dirtyq);
	SIMPLEQ_INIT(&stc->stc_freeq);
	for (i = 0; i < stc->stc_ndesc; i++) {
		stx = &stc->stc_desc[i];
		stx->stx_mbuf = NULL;
		SIMPLEQ_INSERT_TAIL(&stc->stc_freeq, stx, stx_q);
d1049 1
a1049 1
rtw_txctl_blk_init_all(struct rtw_txctl_blk *stcs)
d1053 1
a1053 1
		rtw_txctl_blk_init(&stcs[pri]);
d1082 1
a1082 1
    struct rtw_txdesc_blk *htc, u_int desc0, u_int nsync, int ops)
d1085 1
a1085 1
	if (desc0 + nsync > htc->htc_ndesc) {
d1087 2
a1088 2
		    htc->htc_ofs + sizeof(struct rtw_txdesc) * desc0,
		    sizeof(struct rtw_txdesc) * (htc->htc_ndesc - desc0),
d1090 1
a1090 1
		nsync -= (htc->htc_ndesc - desc0);
d1096 1
a1096 1
	    htc->htc_ofs + sizeof(struct rtw_txdesc) * desc0,
d1102 1
a1102 1
    struct rtw_txdesc_blk *htcs)
d1107 1
a1107 1
		    &htcs[pri], 0, htcs[pri].htc_ndesc,
d1113 1
a1113 1
rtw_rxbufs_release(bus_dma_tag_t dmat, struct rtw_rxctl *desc)
d1116 1
a1116 1
	struct rtw_rxctl *srx;
d1119 6
a1124 6
		srx = &desc[i];
		bus_dmamap_sync(dmat, srx->srx_dmamap, 0,
		    srx->srx_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(dmat, srx->srx_dmamap);
		m_freem(srx->srx_mbuf);
		srx->srx_mbuf = NULL;
d1129 1
a1129 1
rtw_rxbuf_alloc(bus_dma_tag_t dmat, struct rtw_rxctl *srx)
d1144 2
a1145 2
	if (srx->srx_mbuf != NULL)
		bus_dmamap_unload(dmat, srx->srx_dmamap);
d1147 1
a1147 1
	srx->srx_mbuf = NULL;
d1149 1
a1149 1
	rc = bus_dmamap_load_mbuf(dmat, srx->srx_dmamap, m, BUS_DMA_NOWAIT);
d1155 1
a1155 1
	srx->srx_mbuf = m;
d1161 1
a1161 1
rtw_rxctl_init_all(bus_dma_tag_t dmat, struct rtw_rxctl *desc,
d1165 1
a1165 1
	struct rtw_rxctl *srx;
d1168 2
a1169 2
		srx = &desc[i];
		if ((rc = rtw_rxbuf_alloc(dmat, srx)) == 0)
d1171 1
a1171 1
		printf("%s: failed rtw_rxbuf_alloc after %d buffers, rc = %d\n",
d1184 1
a1184 1
    struct rtw_rxdesc *hrx, struct rtw_rxctl *srx, int idx, int kick)
d1189 2
a1190 2
	obuf = hrx->hrx_buf;
	hrx->hrx_buf = htole32(srx->srx_dmamap->dm_segs[0].ds_addr);
d1192 1
a1192 1
	ctl = LSHIFT(srx->srx_mbuf->m_len, RTW_RXCTL_LENGTH_MASK) |
d1198 2
a1199 2
	octl = hrx->hrx_ctl;
	hrx->hrx_ctl = htole32(ctl);
d1204 3
a1206 3
	    ("%s: hrx %p buf %08x -> %08x ctl %08x -> %08x\n", __func__, hrx,
	     letoh32(obuf), letoh32(hrx->hrx_buf), letoh32(octl),
	     letoh32(hrx->hrx_ctl)));
d1209 1
a1209 1
	bus_dmamap_sync(dmat, srx->srx_dmamap, 0, srx->srx_dmamap->dm_mapsize,
d1220 1
a1220 1
    struct rtw_rxdesc *desc, struct rtw_rxctl *ctl, int kick)
d1223 2
a1224 2
	struct rtw_rxdesc *hrx;
	struct rtw_rxctl *srx;
d1227 3
a1229 3
		hrx = &desc[i];
		srx = &ctl[i];
		rtw_rxdesc_init(dmat, dmam, hrx, srx, i, kick);
d1268 2
a1269 2
	struct rtw_rxdesc *hrx;
	struct rtw_rxctl *srx;
d1281 2
a1282 2
		hrx = &sc->sc_rxdesc[next];
		srx = &sc->sc_rxctl[next];
d1284 4
a1287 4
		hstat = letoh32(hrx->hrx_stat);
		hrssi = letoh32(hrx->hrx_rssi);
		htsfth = letoh32(hrx->hrx_tsfth);
		htsftl = letoh32(hrx->hrx_tsftl);
d1306 2
a1307 2
			hrx = &sc->sc_rxdesc[0];
			if ((hrx->hrx_stat & htole32(RTW_RXSTAT_OWN)) != 0)
d1376 2
a1377 2
		bus_dmamap_sync(sc->sc_dmat, srx->srx_dmamap, 0,
		    srx->srx_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
d1379 1
a1379 1
		m = srx->srx_mbuf;
d1382 1
a1382 1
		switch (rtw_rxbuf_alloc(sc->sc_dmat, srx)) {
d1386 1
a1386 1
			printf("%s: rtw_rxbuf_alloc(, %d) failed, "
d1432 1
a1432 1
		    hrx, srx, next, 0);
d1442 2
a1443 2
rtw_txbuf_release(bus_dma_tag_t dmat, struct ieee80211com *ic,
    struct rtw_txctl *stx)
d1448 2
a1449 2
	m = stx->stx_mbuf;
	ni = stx->stx_ni;
d1452 2
a1453 2
	stx->stx_mbuf = NULL;
	stx->stx_ni = NULL;
d1455 1
a1455 1
	bus_dmamap_sync(dmat, stx->stx_dmamap, 0, stx->stx_dmamap->dm_mapsize,
d1457 1
a1457 1
	bus_dmamap_unload(dmat, stx->stx_dmamap);
d1466 2
a1467 2
rtw_txbufs_release(bus_dma_tag_t dmat, bus_dmamap_t desc_dmamap,
    struct ieee80211com *ic, struct rtw_txctl_blk *stc)
d1469 1
a1469 1
	struct rtw_txctl *stx;
d1471 4
a1474 4
	while ((stx = SIMPLEQ_FIRST(&stc->stc_dirtyq)) != NULL) {
		rtw_txbuf_release(dmat, ic, stx);
		SIMPLEQ_REMOVE_HEAD(&stc->stc_dirtyq, stx_q);
		SIMPLEQ_INSERT_TAIL(&stc->stc_freeq, stx, stx_q);
d1479 2
a1480 2
rtw_collect_txpkt(struct rtw_softc *sc, struct rtw_txdesc_blk *htc,
    struct rtw_txctl *stx, int ndesc)
d1484 1
a1484 1
	struct rtw_txdesc *htxn;
d1487 1
a1487 1
	rtw_txbuf_release(sc->sc_dmat, &sc->sc_ic, stx);
d1489 1
a1489 1
	htc->htc_nfree += ndesc;
d1491 1
a1491 1
	htxn = &htc->htc_desc[stx->stx_last];
d1493 1
a1493 1
	hstat = letoh32(htxn->htx_stat);
d1507 2
a1508 2
	    ("%s: stx %p txdesc[%d, %d] %s tries rts %u data %u\n",
	    sc->sc_dev.dv_xname, stx, stx->stx_first, stx->stx_last,
d1514 2
a1515 2
rtw_collect_txring(struct rtw_softc *sc, struct rtw_txctl_blk *stc,
    struct rtw_txdesc_blk *htc)
d1518 1
a1518 1
	struct rtw_txctl *stx;
d1520 4
a1523 4
	while ((stx = SIMPLEQ_FIRST(&stc->stc_dirtyq)) != NULL) {
		ndesc = 1 + stx->stx_last - stx->stx_first;
		if (stx->stx_last < stx->stx_first)
			ndesc += htc->htc_ndesc;
d1527 2
a1528 2
		rtw_txdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap, htc,
		    stx->stx_first, ndesc,
d1531 1
a1531 1
		if ((htc->htc_desc[stx->stx_last].htx_stat &
d1535 3
a1537 3
		rtw_collect_txpkt(sc, htc, stx, ndesc);
		SIMPLEQ_REMOVE_HEAD(&stc->stc_dirtyq, stx_q);
		SIMPLEQ_INSERT_TAIL(&stc->stc_freeq, stx, stx_q);
d1540 2
a1541 2
	if (stx == NULL)
		stc->stc_tx_timer = 0;
d1548 2
a1549 2
	struct rtw_txctl_blk	*stc;
	struct rtw_txdesc_blk	*htc;
d1552 2
a1553 2
		stc = &sc->sc_txctl_blk[pri];
		htc = &sc->sc_txdesc_blk[pri];
d1555 1
a1555 1
		rtw_collect_txring(sc, stc, htc);
d1583 2
a1584 2
	struct rtw_txdesc_blk *htc;
	struct rtw_rxdesc *hrx;
d1591 1
a1591 1
		htc = &sc->sc_txdesc_blk[pri];
d1593 3
a1595 3
		    htc->htc_ndesc, htc->htc_nfree);
		for (desc = 0; desc < htc->htc_ndesc; desc++)
			rtw_print_txdesc(sc, ".", NULL, htc, desc);
d1599 1
a1599 1
		hrx = &sc->sc_rxdesc[desc];
d1602 2
a1603 2
		    letoh32(hrx->hrx_ctl), letoh32(hrx->hrx_rssi),
		    letoh32(hrx->hrx_buf), letoh32(hrx->hrx_tsfth));
d1642 1
a1642 1
	rtw_txctl_blk_init_all(&sc->sc_txctl_blk[0]);
d1646 1
a1646 1
	rtw_rxctl_init_all(sc->sc_dmat, sc->sc_rxctl, &sc->sc_rxnext,
d1649 1
a1649 1
	    sc->sc_rxdesc, sc->sc_rxctl, 1);
d1660 1
a1660 1
rtw_txdesc_blk_reset(struct rtw_txdesc_blk *htc)
d1664 6
a1669 6
	(void)memset(htc->htc_desc, 0,
	    sizeof(htc->htc_desc[0]) * htc->htc_ndesc);
	for (i = 0; i < htc->htc_ndesc; i++)
		htc->htc_desc[i].htx_next = htole32(RTW_NEXT_DESC(htc, i));
	htc->htc_nfree = htc->htc_ndesc;
	htc->htc_next = 0;
d1676 1
a1676 1
	struct rtw_txdesc_blk *htc;
d1679 6
a1684 6
		htc = &sc->sc_txdesc_blk[pri];
		rtw_txbufs_release(sc->sc_dmat, sc->sc_desc_dmamap, &sc->sc_ic,
		    &sc->sc_txctl_blk[pri]);
		rtw_txdesc_blk_reset(htc);
		rtw_txdescs_sync(sc->sc_dmat, sc->sc_desc_dmamap, htc,
		    0, htc->htc_ndesc,
d1694 1
a1694 1
	    &sc->sc_rxctl[0], 1);
d1898 2
a1899 2
		rtw_txbufs_release(sc->sc_dmat, sc->sc_desc_dmamap, &sc->sc_ic,
		    &sc->sc_txctl_blk[pri]);
d1904 1
a1904 1
		rtw_rxbufs_release(sc->sc_dmat, &sc->sc_rxctl[0]);
d2498 1
a2498 1
/* Point *mp at the next 802.11 frame to transmit.  Point *stcp
d2502 2
a2503 2
rtw_dequeue(struct ifnet *ifp, struct rtw_txctl_blk **stcp,
    struct rtw_txdesc_blk **htcp, struct mbuf **mp,
d2506 2
a2507 2
	struct rtw_txctl_blk *stc;
	struct rtw_txdesc_blk *htc;
d2518 2
a2519 2
	stc = &sc->sc_txctl_blk[RTW_TXPRIMD];
	htc = &sc->sc_txdesc_blk[RTW_TXPRIMD];
d2521 1
a2521 1
	if (SIMPLEQ_EMPTY(&stc->stc_freeq) || htc->htc_nfree == 0) {
d2567 2
a2568 2
	*stcp = stc;
	*htcp = htc;
d2588 2
a2589 2
rtw_dmamap_load_txbuf(bus_dma_tag_t dmat, bus_dmamap_t dmam, struct mbuf *chain,
    u_int ndescfree, short *ifflagsp, const char *dvname)
d2650 1
a2650 1
    struct rtw_txctl *stx, struct rtw_txdesc_blk *htc, int desc)
d2652 1
a2652 1
	struct rtw_txdesc *htx = &htc->htc_desc[desc];
d2655 4
a2658 4
	    sc->sc_dev.dv_xname, stx, action, desc,
	    letoh32(htx->htx_ctl0),
	    letoh32(htx->htx_ctl1), letoh32(htx->htx_buf),
	    letoh32(htx->htx_len)));
d2675 4
a2678 4
	struct rtw_txctl_blk	*stc;
	struct rtw_txdesc_blk	*htc;
	struct rtw_txctl	*stx;
	struct rtw_txdesc	*htx;
d2708 1
a2708 1
		if (rtw_dequeue(ifp, &stc, &htc, &m0, &ni) == -1)
d2712 1
a2712 1
		stx = SIMPLEQ_FIRST(&stc->stc_freeq);
d2714 1
a2714 1
		dmamap = stx->stx_dmamap;
d2716 2
a2717 2
		m0 = rtw_dmamap_load_txbuf(sc->sc_dmat, dmamap, m0,
		    htc->htc_nfree, &ifp->if_flags, sc->sc_dev.dv_xname);
d2741 1
a2741 1
		    rate, &stx->stx_d0, &stx->stx_dn, &npkt,
d2753 1
a2753 1
		d0 = &stx->stx_d0;
d2765 1
a2765 1
		stx->stx_first = htc->htc_next;
d2768 1
a2768 1
		    htc, stx->stx_first, dmamap->dm_nsegs,
d2771 1
a2771 1
		KASSERT(stx->stx_first < htc->htc_ndesc);
d2773 1
a2773 1
		for (i = 0, lastdesc = desc = stx->stx_first;
d2775 1
a2775 1
		     i++, desc = RTW_NEXT_IDX(htc, desc)) {
d2781 2
a2782 2
			htx = &htc->htc_desc[desc];
			htx->htx_ctl0 = htole32(ctl0);
d2784 4
a2787 4
				htx->htx_ctl0 |= htole32(RTW_TXCTL0_OWN);
			htx->htx_ctl1 = htole32(ctl1);
			htx->htx_buf = htole32(dmamap->dm_segs[i].ds_addr);
			htx->htx_len = htole32(dmamap->dm_segs[i].ds_len);
d2790 1
a2790 1
			rtw_print_txdesc(sc, "load", stx, htc, desc);
d2794 1
a2794 1
		KASSERT(desc < htc->htc_ndesc);
d2796 5
a2800 5
		stx->stx_ni = ni;
		stx->stx_mbuf = m0;
		stx->stx_last = lastdesc;
		htc->htc_desc[stx->stx_last].htx_ctl0 |= htole32(RTW_TXCTL0_LS);
		htc->htc_desc[stx->stx_first].htx_ctl0 |=
d2804 2
a2805 2
		rtw_print_txdesc(sc, "FS on", stx, htc, stx->stx_first);
		rtw_print_txdesc(sc, "LS on", stx, htc, stx->stx_last);
d2808 2
a2809 2
		htc->htc_nfree -= dmamap->dm_nsegs;
		htc->htc_next = desc;
d2812 1
a2812 1
		    htc, stx->stx_first, dmamap->dm_nsegs,
d2815 1
a2815 1
		htc->htc_desc[stx->stx_first].htx_ctl0 |=
d2819 1
a2819 1
		rtw_print_txdesc(sc, "OWN on", stx, htc, stx->stx_first);
d2823 1
a2823 1
		    htc, stx->stx_first, 1,
d2826 2
a2827 2
		SIMPLEQ_REMOVE_HEAD(&stc->stc_freeq, stx_q);
		SIMPLEQ_INSERT_TAIL(&stc->stc_dirtyq, stx, stx_q);
d2829 1
a2829 1
		stc->stc_tx_timer = 5;
d2854 1
a2854 1
	struct rtw_txctl_blk *stc;
d2864 1
a2864 1
		stc = &sc->sc_txctl_blk[pri];
d2866 1
a2866 1
		if (stc->stc_tx_timer == 0)
d2869 2
a2870 2
		if (--stc->stc_tx_timer == 0) {
			if (SIMPLEQ_EMPTY(&stc->stc_dirtyq))
d3237 1
a3237 1
rtw_txctl_blk_setup(struct rtw_txctl_blk *stc, u_int qlen)
d3239 4
a3242 4
	SIMPLEQ_INIT(&stc->stc_dirtyq);
	SIMPLEQ_INIT(&stc->stc_freeq);
	stc->stc_ndesc = qlen;
	stc->stc_desc = malloc(qlen * sizeof(*stc->stc_desc), M_DEVBUF,
d3244 1
a3244 1
	if (stc->stc_desc == NULL)
d3250 1
a3250 1
rtw_txctl_blk_cleanup_all(struct rtw_softc *sc)
d3253 1
a3253 1
	struct rtw_txctl_blk *stc;
d3256 3
a3258 3
		stc = &sc->sc_txctl_blk[pri];
		free(stc->stc_desc, M_DEVBUF);
		stc->stc_desc = NULL;
d3263 1
a3263 1
rtw_txctl_blk_setup_all(struct rtw_softc *sc)
d3270 1
a3270 1
		rc = rtw_txctl_blk_setup(&sc->sc_txctl_blk[pri], qlen[pri]);
d3278 1
a3278 1
rtw_txdesc_blk_setup(struct rtw_txdesc_blk *htc, struct rtw_txdesc *desc,
d3281 4
a3284 4
	htc->htc_ndesc = ndesc;
	htc->htc_desc = desc;
	htc->htc_physbase = physbase;
	htc->htc_ofs = ofs;
d3286 2
a3287 2
	(void)memset(htc->htc_desc, 0,
	    sizeof(htc->htc_desc[0]) * htc->htc_ndesc);
d3289 1
a3289 1
	rtw_txdesc_blk_reset(htc);
d3382 1
a3382 1
	struct rtw_txctl_blk *stc;
d3456 1
a3456 1
	if (rtw_txctl_blk_setup_all(sc) != 0)
d3466 1
a3466 1
	rtw_rxctls_setup(&sc->sc_rxctl[0]);
d3469 1
a3469 1
		stc = &sc->sc_txctl_blk[pri];
d3472 1
a3472 1
		    &stc->stc_desc[0], stc->stc_ndesc)) != 0) {
d3481 1
a3481 1
	if ((rc = rtw_rxdesc_dmamaps_create(sc->sc_dmat, &sc->sc_rxctl[0],
d3624 1
a3624 1
		rtw_rxdesc_dmamaps_destroy(sc->sc_dmat, &sc->sc_rxctl[0],
d3630 2
a3631 2
			    sc->sc_txctl_blk[pri].stc_desc,
			    sc->sc_txctl_blk[pri].stc_ndesc);
d3636 1
a3636 1
		rtw_txctl_blk_cleanup_all(sc);
@


1.8
log
@destatic functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.7 2005/01/19 09:36:18 jsg Exp $	*/
d492 1
a492 1
__inline int
d516 1
a516 1
__inline int
d532 1
a532 1
__inline int
d559 1
a559 1
__inline int
d578 1
a578 1
__inline int
d592 1
a592 1
__inline int
d606 1
a606 1
__inline void
d614 1
a614 1
__inline void
d625 1
a625 1
__inline void
d636 1
a636 1
__inline void
d884 1
a884 1
__inline int
d916 1
a916 1
__inline void
d957 1
a957 1
__inline void
d979 1
a979 1
__inline int
d1056 1
a1056 1
__inline void
d1128 1
a1128 1
__inline int
d1182 1
a1182 1
__inline void
d1478 1
a1478 1
__inline void
d1513 1
a1513 1
__inline void
d1744 1
a1744 1
__inline void
d1752 1
a1752 1
__inline void
d2204 1
a2204 1
__inline void
d2501 1
a2501 1
__inline int
d3144 1
a3144 1
__inline void
d3156 1
a3156 1
__inline void
d3175 1
a3175 1
__inline void
d3191 1
a3191 1
__inline void
d3213 1
a3213 1
__inline void
d3224 1
a3224 1
__inline void
@


1.7
log
@Use the RF chipset type rather than the hardware version when determining
whether to use host or MAC controlled RF I/O.

From part of NetBSD rev 1.42
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.6 2005/01/10 06:49:19 jsg Exp $	*/
d183 36
d492 1
a492 1
static __inline int
d516 1
a516 1
static __inline int
d532 1
a532 1
static __inline int
d559 1
a559 1
static __inline int
d578 1
a578 1
static __inline int
d592 1
a592 1
static __inline int
d606 1
a606 1
static __inline void
d614 1
a614 1
static __inline void
d625 1
a625 1
static __inline void
d636 1
a636 1
static __inline void
d884 1
a884 1
static __inline int
d916 1
a916 1
static __inline void
d957 1
a957 1
static __inline void
d979 1
a979 1
static __inline int
d1056 1
a1056 1
static __inline void
d1128 1
a1128 1
static __inline int
d1182 1
a1182 1
static __inline void
d1478 1
a1478 1
static __inline void
d1513 1
a1513 1
static __inline void
d1744 1
a1744 1
static __inline void
d1752 1
a1752 1
static __inline void
d2204 1
a2204 1
static __inline void
d2501 1
a2501 1
static __inline int
d3144 1
a3144 1
static __inline void
d3156 1
a3156 1
static __inline void
d3175 1
a3175 1
static __inline void
d3191 1
a3191 1
static __inline void
d3213 1
a3213 1
static __inline void
d3224 1
a3224 1
static __inline void
d3236 1
a3236 1
static int
d3657 38
@


1.6
log
@Make the time spent scanning per channel consistent with other drivers
and much more reasonable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.5 2005/01/09 21:46:56 jsg Exp $	*/
d181 1
a181 2
struct rtw_rf * rtw_rf_attach(struct rtw_softc *, enum rtw_rfchipid,
    rtw_rf_write_t, int);
d3277 1
a3277 2
rtw_rf_attach(struct rtw_softc *sc, enum rtw_rfchipid rfchipid,
    rtw_rf_write_t rf_write, int digphy)
d3279 1
d3283 13
a3345 1
	rtw_rf_write_t rf_write;
d3347 1
a3347 1
	int pri, rc, vers;
d3366 1
a3366 2
		vers = 'F';
		rf_write = rtw_rf_macwrite;
d3369 1
a3369 5
		vers = 'D';
		if (rtw_host_rfio)
			rf_write = rtw_rf_hostwrite;
		else
			rf_write = rtw_rf_macwrite;
d3372 1
a3372 2
		vers = '?';
		rf_write = rtw_rf_macwrite;
d3375 1
a3375 1
	printf("%s: ver %c ", sc->sc_dev.dv_xname, vers);
d3485 1
a3485 1
	sc->sc_rf = rtw_rf_attach(sc, sc->sc_rfchipid, rf_write,
@


1.5
log
@From dyoung@@NetBSD rev 1.41:
Set initial conditions to guarantee that when read_seeprom toggles
Chip Select, it turns *on* rather than *off*.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.4 2005/01/09 21:39:04 jsg Exp $	*/
d104 1
a104 1
int rtw_dwelltime = 1000;	/* milliseconds */
@


1.4
log
@Use the macwrite instead of the hostwrite radio programming method
for rev F devices which lets us get responses from access points.
Driver is still not fully working as yet.
From a discussion with David Young.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.3 2005/01/04 04:54:56 jsg Exp $	*/
d743 1
a743 1
	    RTW_9346CR_EEM_MASK);
@


1.3
log
@shrink dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.2 2004/12/31 00:16:15 jsg Exp $	*/
d3356 1
a3356 1
		rf_write = rtw_rf_hostwrite;
@


1.2
log
@Move the cfdriver struct to rtw.c where it belongs so cardbus rtw
can be enabled seperately from pci rtw. From fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtw.c,v 1.1 2004/12/29 01:02:31 jsg Exp $	*/
d636 1
a636 1
	printf("%s: SROM version %d.%d", dvname, version >> 8, version & 0xff);
d639 1
a639 1
		printf(" is not understood, limping along with defaults\n");
a642 1
	printf("\n");
d673 2
a674 2
		rfname = "Maxim MAX2820";	/* guess */
		paname = "Maxim MAX2422";	/* guess */
d681 2
a682 2
		rfname = "Philips SA2400A";
		paname = "Philips SA2411";
d700 1
a700 1
	printf("%s: RF: %s, PA: %s\n", dvname, rfname, paname);
d917 2
a918 1
	printf("%s: Geographic Location %s\n", dvname, name);
d968 1
a968 1
	printf("%s: 802.11 address %s\n", dvname, ether_sprintf(*addr));
d3370 1
a3370 1
	printf("%s: hardware version %c\n", sc->sc_dev.dv_xname, vers);
d3472 2
a3473 2
	printf("%s: %s PHY\n", sc->sc_dev.dv_xname,
	    ((sc->sc_flags & RTW_F_DIGPHY) != 0) ? "digital" : "analog");
d3475 2
a3476 1
	printf("%s: CS threshold %u\n", sc->sc_dev.dv_xname, sc->sc_csthr);
@


1.1
log
@Driver for Realtek 802.11 devices from NetBSD.
Not yet working.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d194 4
@

