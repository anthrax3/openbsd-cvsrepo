head	1.81;
access;
symbols
	OPENBSD_6_0:1.80.0.4
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.79.0.2
	OPENBSD_5_9_BASE:1.79
	OPENBSD_5_8:1.73.0.4
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.70.0.2
	OPENBSD_5_7_BASE:1.70
	OPENBSD_5_6:1.67.0.4
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.62.0.10
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.62.0.8
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.62.0.4
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.6
	OPENBSD_5_0:1.62.0.2
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.61.0.6
	OPENBSD_4_9_BASE:1.61
	OPENBSD_4_8:1.61.0.4
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.58.0.4
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.54.0.2
	OPENBSD_4_5_BASE:1.54
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.46.0.4
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.43.0.2
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.20
	UBC:1.12.0.6
	UBC_BASE:1.12
	SMP:1.12.0.4
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12;
locks; strict;
comment	@ * @;


1.81
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.80;
commitid	VyLWTsbepAOk7VQM;

1.80
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.79;
commitid	QHiEhS9DHyE6oiIr;

1.79
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.78;
commitid	J9apD0jq2AjFmqZc;

1.78
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.77;
commitid	B0kwmVGiD5DVx4kv;

1.77
date	2015.11.24.15.25.20;	author mpi;	state Exp;
branches;
next	1.76;
commitid	MfakaqIkeFe2uL7U;

1.76
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.75;
commitid	eYnPulzvLjDImPCa;

1.75
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.74;
commitid	p0v5tuE1Ch6fY0Nj;

1.74
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.73;
commitid	6vhYvh5CxZAHMnsN;

1.73
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.72;
commitid	MVWrtktB46JRxFWT;

1.72
date	2015.03.30.09.47.05;	author mpi;	state Exp;
branches;
next	1.71;
commitid	ttU0PzD1JQ3uzozO;

1.71
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.70;
commitid	p4LJxGKbi0BU2cG6;

1.70
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.69;
commitid	yM2VFFhpDTeFQlve;

1.69
date	2014.11.27.14.53.42;	author brad;	state Exp;
branches;
next	1.68;
commitid	NtfFntFLbD7jE0vg;

1.68
date	2014.11.27.05.47.25;	author brad;	state Exp;
branches;
next	1.67;
commitid	AlekjOO8Qd2OskW0;

1.67
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.66;
commitid	TGHgrLxu6sxZoiFt;

1.66
date	2014.07.08.05.35.18;	author dlg;	state Exp;
branches;
next	1.65;
commitid	0QJleeeWqZmC5anF;

1.65
date	2014.06.17.02.48.30;	author dlg;	state Exp;
branches;
next	1.64;
commitid	BuzTSBSBZbyxBC07;

1.64
date	2014.04.22.15.52.05;	author naddy;	state Exp;
branches;
next	1.63;

1.63
date	2013.08.07.01.06.29;	author bluhm;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.05.05.25.09;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.15.17.54.54;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.09.11.40.58;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.22.14.31.04;	author sthen;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.11.22.37.58;	author sthen;	state Exp;
branches;
next	1.56;

1.56
date	2009.04.23.21.24.14;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2009.04.17.20.20.18;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2008.12.10.20.37.48;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2008.11.26.13.30.29;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.18.02.28.25;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.18.00.36.34;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2006.12.21.22.13.36;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2006.12.21.21.48.11;	author jason;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.21.21.43.44;	author jason;	state Exp;
branches;
next	1.43;

1.43
date	2006.06.25.21.53.44;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.12.15.06.12;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.16.06.08.13;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.21.22.10.56;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.26.04.27.19;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.08.04.14.25;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.04.05.02.38;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.28.00.21.23;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.08.19.01.20;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.31.01.51.30;	author mcbride;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.18.15.35.47;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.26.08.01.42;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.05.20.46.26;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.08.21.42.11;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.01.06.00.10;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.26.01.08.18;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.20.22.06.45;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.14.17.20.52;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.28.02.04.44;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.07.03.42.14;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.07.00.30.39;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.06.20.02.26;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.05.22.13.18;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.18.22.48.03;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.09.15.07.20;	author jason;	state Exp;
branches
	1.12.4.1
	1.12.6.1;
next	1.11;

1.11
date	2001.10.04.20.36.16;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.04.19.17.59;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.02.21.39.35;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.02.21.21.52;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.02.20.32.46;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.23.20.03.01;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.20.17.58.33;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.29.05.33.10;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.23.05.27.01;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.23.05.12.59;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.21.16.16.50;	author jason;	state Exp;
branches;
next	;

1.12.4.1
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2003.03.28.00.38.13;	author niklas;	state Exp;
branches;
next	1.12.4.5;

1.12.4.5
date	2003.05.13.19.35.00;	author ho;	state Exp;
branches;
next	1.12.4.6;

1.12.4.6
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	1.12.4.7;

1.12.4.7
date	2004.06.05.23.12.42;	author niklas;	state Exp;
branches;
next	;

1.12.6.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.12.6.3;

1.12.6.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.81
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: hme.c,v 1.80 2016/04/13 10:49:26 mpi Exp $	*/
/*	$NetBSD: hme.c,v 1.21 2001/07/07 15:59:37 thorpej Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * HME Ethernet module driver.
 */

#include "bpfilter.h"

#undef HMEDEBUG

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/mbuf.h> 
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <machine/bus.h>

#include <dev/ic/hmereg.h>
#include <dev/ic/hmevar.h>

struct cfdriver hme_cd = {
	NULL, "hme", DV_IFNET
};

#define	HME_RX_OFFSET	2

void		hme_start(struct ifnet *);
void		hme_stop(struct hme_softc *, int);
int		hme_ioctl(struct ifnet *, u_long, caddr_t);
void		hme_tick(void *);
void		hme_watchdog(struct ifnet *);
void		hme_init(struct hme_softc *);
void		hme_meminit(struct hme_softc *);
void		hme_mifinit(struct hme_softc *);
void		hme_reset(struct hme_softc *);
void		hme_iff(struct hme_softc *);
void		hme_fill_rx_ring(struct hme_softc *);
int		hme_newbuf(struct hme_softc *, struct hme_sxd *);

/* MII methods & callbacks */
static int	hme_mii_readreg(struct device *, int, int);
static void	hme_mii_writereg(struct device *, int, int, int);
static void	hme_mii_statchg(struct device *);

int		hme_mediachange(struct ifnet *);
void		hme_mediastatus(struct ifnet *, struct ifmediareq *);

int		hme_eint(struct hme_softc *, u_int);
int		hme_rint(struct hme_softc *);
int		hme_tint(struct hme_softc *);

void
hme_config(struct hme_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mii_data *mii = &sc->sc_mii;
	struct mii_softc *child;
	bus_dma_tag_t dmatag = sc->sc_dmatag;
	bus_dma_segment_t seg;
	bus_size_t size;
	int rseg, error, i;

	/*
	 * HME common initialization.
	 *
	 * hme_softc fields that must be initialized by the front-end:
	 *
	 * the bus tag:
	 *	sc_bustag
	 *
	 * the dma bus tag:
	 *	sc_dmatag
	 *
	 * the bus handles:
	 *	sc_seb		(Shared Ethernet Block registers)
	 *	sc_erx		(Receiver Unit registers)
	 *	sc_etx		(Transmitter Unit registers)
	 *	sc_mac		(MAC registers)
	 *	sc_mif		(Management Interface registers)
	 *
	 * the maximum bus burst size:
	 *	sc_burst
	 *
	 * the local Ethernet address:
	 *	sc_arpcom.ac_enaddr
	 *
	 */

	/* Make sure the chip is stopped. */
	hme_stop(sc, 0);

	for (i = 0; i < HME_TX_RING_SIZE; i++) {
		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, HME_TX_NSEGS,
		    MCLBYTES, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &sc->sc_txd[i].sd_map) != 0) {
			sc->sc_txd[i].sd_map = NULL;
			goto fail;
		}
	}
	for (i = 0; i < HME_RX_RING_SIZE; i++) {
		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1,
		    MCLBYTES, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &sc->sc_rxd[i].sd_map) != 0) {
			sc->sc_rxd[i].sd_map = NULL;
			goto fail;
		}
	}
	if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1, MCLBYTES, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_rxmap_spare) != 0) {
		sc->sc_rxmap_spare = NULL;
		goto fail;
	}

	/*
	 * Allocate DMA capable memory
	 * Buffer descriptors must be aligned on a 2048 byte boundary;
	 * take this into account when calculating the size. Note that
	 * the maximum number of descriptors (256) occupies 2048 bytes,
	 * so we allocate that much regardless of the number of descriptors.
	 */
	size = (HME_XD_SIZE * HME_RX_RING_MAX) +	/* RX descriptors */
	    (HME_XD_SIZE * HME_TX_RING_MAX);		/* TX descriptors */

	/* Allocate DMA buffer */
	if ((error = bus_dmamem_alloc(dmatag, size, 2048, 0, &seg, 1, &rseg,
	    BUS_DMA_NOWAIT)) != 0) {
		printf("\n%s: DMA buffer alloc error %d\n",
		    sc->sc_dev.dv_xname, error);
		return;
	}

	/* Map DMA memory in CPU addressable space */
	if ((error = bus_dmamem_map(dmatag, &seg, rseg, size,
	    &sc->sc_rb.rb_membase, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("\n%s: DMA buffer map error %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamap_unload(dmatag, sc->sc_dmamap);
		bus_dmamem_free(dmatag, &seg, rseg);
		return;
	}

	if ((error = bus_dmamap_create(dmatag, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
		printf("\n%s: DMA map create error %d\n",
		    sc->sc_dev.dv_xname, error);
		return;
	}

	/* Load the buffer */
	if ((error = bus_dmamap_load(dmatag, sc->sc_dmamap,
	    sc->sc_rb.rb_membase, size, NULL,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("\n%s: DMA buffer map load error %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamem_free(dmatag, &seg, rseg);
		return;
	}
	sc->sc_rb.rb_dmabase = sc->sc_dmamap->dm_segs[0].ds_addr;

	printf(", address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/* Initialize ifnet structure. */
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
	ifp->if_softc = sc;
	ifp->if_start = hme_start;
	ifp->if_ioctl = hme_ioctl;
	ifp->if_watchdog = hme_watchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Initialize ifmedia structures and MII info */
	mii->mii_ifp = ifp;
	mii->mii_readreg = hme_mii_readreg; 
	mii->mii_writereg = hme_mii_writereg;
	mii->mii_statchg = hme_mii_statchg;

	ifmedia_init(&mii->mii_media, IFM_IMASK,
	    hme_mediachange, hme_mediastatus);

	hme_mifinit(sc);

	if (sc->sc_tcvr == -1)
		mii_attach(&sc->sc_dev, mii, 0xffffffff, MII_PHY_ANY,
		    MII_OFFSET_ANY, 0);
	else
		mii_attach(&sc->sc_dev, mii, 0xffffffff, sc->sc_tcvr,
		    MII_OFFSET_ANY, 0);

	child = LIST_FIRST(&mii->mii_phys);
	if (child == NULL) {
		/* No PHY attached */
		ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);
		ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);
	} else {
		/*
		 * Walk along the list of attached MII devices and
		 * establish an `MII instance' to `phy number'
		 * mapping. We'll use this mapping in media change
		 * requests to determine which phy to use to program
		 * the MIF configuration register.
		 */
		for (; child != NULL; child = LIST_NEXT(child, mii_list)) {
			/*
			 * Note: we support just two PHYs: the built-in
			 * internal device and an external on the MII
			 * connector.
			 */
			if (child->mii_phy > 1 || child->mii_inst > 1) {
				printf("%s: cannot accommodate MII device %s"
				    " at phy %d, instance %lld\n",
				    sc->sc_dev.dv_xname,
				    child->mii_dev.dv_xname,
				    child->mii_phy, child->mii_inst);
				continue;
			}

			sc->sc_phys[child->mii_inst] = child->mii_phy;
		}

		/*
		 * XXX - we can really do the following ONLY if the
		 * phy indeed has the auto negotiation capability!!
		 */
		ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_AUTO);
	}

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->sc_tick_ch, hme_tick, sc);
	return;

fail:
	if (sc->sc_rxmap_spare != NULL)
		bus_dmamap_destroy(sc->sc_dmatag, sc->sc_rxmap_spare);
	for (i = 0; i < HME_TX_RING_SIZE; i++)
		if (sc->sc_txd[i].sd_map != NULL)
			bus_dmamap_destroy(sc->sc_dmatag, sc->sc_txd[i].sd_map);
	for (i = 0; i < HME_RX_RING_SIZE; i++)
		if (sc->sc_rxd[i].sd_map != NULL)
			bus_dmamap_destroy(sc->sc_dmatag, sc->sc_rxd[i].sd_map);
}

void
hme_unconfig(struct hme_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int i;

	hme_stop(sc, 1);

	bus_dmamap_destroy(sc->sc_dmatag, sc->sc_rxmap_spare);
	for (i = 0; i < HME_TX_RING_SIZE; i++)
		if (sc->sc_txd[i].sd_map != NULL)
			bus_dmamap_destroy(sc->sc_dmatag, sc->sc_txd[i].sd_map);
	for (i = 0; i < HME_RX_RING_SIZE; i++)
		if (sc->sc_rxd[i].sd_map != NULL)
			bus_dmamap_destroy(sc->sc_dmatag, sc->sc_rxd[i].sd_map);

	/* Detach all PHYs */
	mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete all remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);
}

void
hme_tick(void *arg)
{
	struct hme_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_mac;
	int s;

	s = splnet();
	/*
	 * Unload collision counters
	 */
	ifp->if_collisions +=
	    bus_space_read_4(t, mac, HME_MACI_NCCNT) +
	    bus_space_read_4(t, mac, HME_MACI_FCCNT) +
	    bus_space_read_4(t, mac, HME_MACI_EXCNT) +
	    bus_space_read_4(t, mac, HME_MACI_LTCNT);

	/*
	 * then clear the hardware counters.
	 */
	bus_space_write_4(t, mac, HME_MACI_NCCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_FCCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_EXCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_LTCNT, 0);

	/*
	 * If buffer allocation fails, the receive ring may become
	 * empty. There is no receive interrupt to recover from that.
	 */
	if (if_rxr_inuse(&sc->sc_rx_ring) == 0)
		hme_fill_rx_ring(sc);

	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick_ch, 1);
}

void
hme_reset(struct hme_softc *sc)
{
	int s;

	s = splnet();
	hme_init(sc);
	splx(s);
}

void
hme_stop(struct hme_softc *sc, int softonly)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t seb = sc->sc_seb;
	int n;

	timeout_del(&sc->sc_tick_ch);

	/*
	 * Mark the interface down and cancel the watchdog timer.
	 */
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	if (!softonly) {
		mii_down(&sc->sc_mii);

		/* Mask all interrupts */
		bus_space_write_4(t, seb, HME_SEBI_IMASK, 0xffffffff);

		/* Reset transmitter and receiver */
		bus_space_write_4(t, seb, HME_SEBI_RESET,
		    (HME_SEB_RESET_ETX | HME_SEB_RESET_ERX));

		for (n = 0; n < 20; n++) {
			u_int32_t v = bus_space_read_4(t, seb, HME_SEBI_RESET);
			if ((v & (HME_SEB_RESET_ETX | HME_SEB_RESET_ERX)) == 0)
				break;
			DELAY(20);
		}
		if (n >= 20)
			printf("%s: hme_stop: reset failed\n", sc->sc_dev.dv_xname);
	}

	for (n = 0; n < HME_TX_RING_SIZE; n++) {
		if (sc->sc_txd[n].sd_mbuf != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sc->sc_txd[n].sd_map,
			    0, sc->sc_txd[n].sd_map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sc->sc_txd[n].sd_map);
			m_freem(sc->sc_txd[n].sd_mbuf);
			sc->sc_txd[n].sd_mbuf = NULL;
		}
	}
	sc->sc_tx_prod = sc->sc_tx_cons = sc->sc_tx_cnt = 0;

	for (n = 0; n < HME_RX_RING_SIZE; n++) {
		if (sc->sc_rxd[n].sd_mbuf != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sc->sc_rxd[n].sd_map,
			    0, sc->sc_rxd[n].sd_map->dm_mapsize,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmatag, sc->sc_rxd[n].sd_map);
			m_freem(sc->sc_rxd[n].sd_mbuf);
			sc->sc_rxd[n].sd_mbuf = NULL;
		}
	}
	sc->sc_rx_prod = sc->sc_rx_cons = 0;
}

void
hme_meminit(struct hme_softc *sc)
{
	bus_addr_t dma;
	caddr_t p;
	unsigned int i;
	struct hme_ring *hr = &sc->sc_rb;

	p = hr->rb_membase;
	dma = hr->rb_dmabase;

	/*
	 * Allocate transmit descriptors
	 */
	hr->rb_txd = p;
	hr->rb_txddma = dma;
	p += HME_TX_RING_SIZE * HME_XD_SIZE;
	dma += HME_TX_RING_SIZE * HME_XD_SIZE;
	/* We have reserved descriptor space until the next 2048 byte boundary.*/
	dma = (bus_addr_t)roundup((u_long)dma, 2048);
	p = (caddr_t)roundup((u_long)p, 2048);

	/*
	 * Allocate receive descriptors
	 */
	hr->rb_rxd = p;
	hr->rb_rxddma = dma;
	p += HME_RX_RING_SIZE * HME_XD_SIZE;
	dma += HME_RX_RING_SIZE * HME_XD_SIZE;
	/* Again move forward to the next 2048 byte boundary.*/
	dma = (bus_addr_t)roundup((u_long)dma, 2048);
	p = (caddr_t)roundup((u_long)p, 2048);

	/*
	 * Initialize transmit descriptors
	 */
	for (i = 0; i < HME_TX_RING_SIZE; i++) {
		HME_XD_SETADDR(sc->sc_pci, hr->rb_txd, i, 0);
		HME_XD_SETFLAGS(sc->sc_pci, hr->rb_txd, i, 0);
		sc->sc_txd[i].sd_mbuf = NULL;
	}

	/*
	 * Initialize receive descriptors
	 */
	for (i = 0; i < HME_RX_RING_SIZE; i++) {
		HME_XD_SETADDR(sc->sc_pci, hr->rb_rxd, i, 0);
		HME_XD_SETFLAGS(sc->sc_pci, hr->rb_rxd, i, 0);
		sc->sc_rxd[i].sd_mbuf = NULL;
	}

	if_rxr_init(&sc->sc_rx_ring, 2, HME_RX_RING_SIZE);
	hme_fill_rx_ring(sc);
}

/*
 * Initialization of interface; set up initialization block
 * and transmit/receive descriptor rings.
 */
void
hme_init(struct hme_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t seb = sc->sc_seb;
	bus_space_handle_t etx = sc->sc_etx;
	bus_space_handle_t erx = sc->sc_erx;
	bus_space_handle_t mac = sc->sc_mac;
	u_int8_t *ea;
	u_int32_t v;

	/*
	 * Initialization sequence. The numbered steps below correspond
	 * to the sequence outlined in section 6.3.5.1 in the Ethernet
	 * Channel Engine manual (part of the PCIO manual).
	 * See also the STP2002-STQ document from Sun Microsystems.
	 */

	/* step 1 & 2. Reset the Ethernet Channel */
	hme_stop(sc, 0);

	/* Re-initialize the MIF */
	hme_mifinit(sc);

	/* step 3. Setup data structures in host memory */
	hme_meminit(sc);

	/* step 4. TX MAC registers & counters */
	bus_space_write_4(t, mac, HME_MACI_NCCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_FCCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_EXCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_LTCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_TXSIZE, ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);

	/* Load station MAC address */
	ea = sc->sc_arpcom.ac_enaddr;
	bus_space_write_4(t, mac, HME_MACI_MACADDR0, (ea[0] << 8) | ea[1]);
	bus_space_write_4(t, mac, HME_MACI_MACADDR1, (ea[2] << 8) | ea[3]);
	bus_space_write_4(t, mac, HME_MACI_MACADDR2, (ea[4] << 8) | ea[5]);

	/*
	 * Init seed for backoff
	 * (source suggested by manual: low 10 bits of MAC address)
	 */ 
	v = ((ea[4] << 8) | ea[5]) & 0x3fff;
	bus_space_write_4(t, mac, HME_MACI_RANDSEED, v);


	/* Note: Accepting power-on default for other MAC registers here.. */


	/* step 5. RX MAC registers & counters */
	hme_iff(sc);

	/* step 6 & 7. Program Descriptor Ring Base Addresses */
	bus_space_write_4(t, etx, HME_ETXI_RING, sc->sc_rb.rb_txddma);
	bus_space_write_4(t, etx, HME_ETXI_RSIZE, HME_TX_RING_SIZE);

	bus_space_write_4(t, erx, HME_ERXI_RING, sc->sc_rb.rb_rxddma);
	bus_space_write_4(t, mac, HME_MACI_RXSIZE, ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);

	/* step 8. Global Configuration & Interrupt Mask */
	bus_space_write_4(t, seb, HME_SEBI_IMASK,
	    ~(HME_SEB_STAT_HOSTTOTX | HME_SEB_STAT_RXTOHOST |
	      HME_SEB_STAT_TXALL | HME_SEB_STAT_TXPERR |
	      HME_SEB_STAT_RCNTEXP | HME_SEB_STAT_ALL_ERRORS));

	switch (sc->sc_burst) {
	default:
		v = 0;
		break;
	case 16:
		v = HME_SEB_CFG_BURST16;
		break;
	case 32:
		v = HME_SEB_CFG_BURST32;
		break;
	case 64:
		v = HME_SEB_CFG_BURST64;
		break;
	}
	bus_space_write_4(t, seb, HME_SEBI_CFG, v);

	/* step 9. ETX Configuration: use mostly default values */

	/* Enable DMA */
	v = bus_space_read_4(t, etx, HME_ETXI_CFG);
	v |= HME_ETX_CFG_DMAENABLE;
	bus_space_write_4(t, etx, HME_ETXI_CFG, v);

	/* Transmit Descriptor ring size: in increments of 16 */
	bus_space_write_4(t, etx, HME_ETXI_RSIZE, HME_TX_RING_SIZE / 16 - 1);

	/* step 10. ERX Configuration */
	v = bus_space_read_4(t, erx, HME_ERXI_CFG);
	v &= ~HME_ERX_CFG_RINGSIZE256;
#if HME_RX_RING_SIZE == 32
	v |= HME_ERX_CFG_RINGSIZE32;
#elif HME_RX_RING_SIZE == 64
	v |= HME_ERX_CFG_RINGSIZE64;
#elif HME_RX_RING_SIZE == 128
	v |= HME_ERX_CFG_RINGSIZE128;
#elif HME_RX_RING_SIZE == 256
	v |= HME_ERX_CFG_RINGSIZE256;
#else
# error	"RX ring size must be 32, 64, 128, or 256"
#endif
	/* Enable DMA */
	v |= HME_ERX_CFG_DMAENABLE | (HME_RX_OFFSET << 3);
	bus_space_write_4(t, erx, HME_ERXI_CFG, v);

	/* step 11. XIF Configuration */
	v = bus_space_read_4(t, mac, HME_MACI_XIF);
	v |= HME_MAC_XIF_OE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);

	/* step 12. RX_MAC Configuration Register */
	v = bus_space_read_4(t, mac, HME_MACI_RXCFG);
	v |= HME_MAC_RXCFG_ENABLE;
	bus_space_write_4(t, mac, HME_MACI_RXCFG, v);

	/* step 13. TX_MAC Configuration Register */
	v = bus_space_read_4(t, mac, HME_MACI_TXCFG);
	v |= (HME_MAC_TXCFG_ENABLE | HME_MAC_TXCFG_DGIVEUP);
	bus_space_write_4(t, mac, HME_MACI_TXCFG, v);

	/* Set the current media. */
	mii_mediachg(&sc->sc_mii);

	/* Start the one second timer. */
	timeout_add_sec(&sc->sc_tick_ch, 1);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	hme_start(ifp);
}

void
hme_start(struct ifnet *ifp)
{
	struct hme_softc *sc = (struct hme_softc *)ifp->if_softc;
	struct hme_ring *hr = &sc->sc_rb;
	struct mbuf *m;
	u_int32_t flags;
	bus_dmamap_t map;
	u_int32_t frag, cur, i;
	int error;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	while (sc->sc_txd[sc->sc_tx_prod].sd_mbuf == NULL) {
		m = ifq_deq_begin(&ifp->if_snd);
		if (m == NULL)
			break;

		/*
		 * Encapsulate this packet and start it going...
		 * or fail...
		 */

		cur = frag = sc->sc_tx_prod;
		map = sc->sc_txd[cur].sd_map;

		error = bus_dmamap_load_mbuf(sc->sc_dmatag, map, m,
		    BUS_DMA_NOWAIT);
		if (error != 0 && error != EFBIG)
			goto drop;
		if (error != 0) {
			/* Too many fragments, linearize. */
			if (m_defrag(m, M_DONTWAIT))
				goto drop;
			error = bus_dmamap_load_mbuf(sc->sc_dmatag, map, m,
			    BUS_DMA_NOWAIT);
			if (error != 0)
				goto drop;
		}

		if ((HME_TX_RING_SIZE - (sc->sc_tx_cnt + map->dm_nsegs)) < 5) {
			bus_dmamap_unload(sc->sc_dmatag, map);
			ifq_deq_rollback(&ifp->if_snd, m);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		/* We are now committed to transmitting the packet. */
		ifq_deq_commit(&ifp->if_snd, m);

#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		bus_dmamap_sync(sc->sc_dmatag, map, 0, map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

		for (i = 0; i < map->dm_nsegs; i++) {
			flags = HME_XD_ENCODE_TSIZE(map->dm_segs[i].ds_len);
			if (i == 0)
				flags |= HME_XD_SOP;
			else
				flags |= HME_XD_OWN;

			HME_XD_SETADDR(sc->sc_pci, hr->rb_txd, frag,
			    map->dm_segs[i].ds_addr);
			HME_XD_SETFLAGS(sc->sc_pci, hr->rb_txd, frag, flags);

			cur = frag;
			if (++frag == HME_TX_RING_SIZE)
				frag = 0;
		}

		/* Set end of packet on last descriptor. */
		flags = HME_XD_GETFLAGS(sc->sc_pci, hr->rb_txd, cur);
		flags |= HME_XD_EOP;
		HME_XD_SETFLAGS(sc->sc_pci, hr->rb_txd, cur, flags);

		sc->sc_tx_cnt += map->dm_nsegs;
		sc->sc_txd[sc->sc_tx_prod].sd_map = sc->sc_txd[cur].sd_map;
		sc->sc_txd[cur].sd_map = map;
		sc->sc_txd[cur].sd_mbuf = m;

		/* Give first frame over to the hardware. */
		flags = HME_XD_GETFLAGS(sc->sc_pci, hr->rb_txd, sc->sc_tx_prod);
		flags |= HME_XD_OWN;
		HME_XD_SETFLAGS(sc->sc_pci, hr->rb_txd, sc->sc_tx_prod, flags);

		bus_space_write_4(sc->sc_bustag, sc->sc_etx, HME_ETXI_PENDING,
		    HME_ETX_TP_DMAWAKEUP);
		sc->sc_tx_prod = frag;

		ifp->if_timer = 5;
	}

	return;

 drop:
	ifq_deq_commit(&ifp->if_snd, m);
	m_freem(m);
	ifp->if_oerrors++;
}

/*
 * Transmit interrupt.
 */
int
hme_tint(struct hme_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	unsigned int ri, txflags;
	struct hme_sxd *sd;
	int cnt = sc->sc_tx_cnt;

	/* Fetch current position in the transmit ring */
	ri = sc->sc_tx_cons;
	sd = &sc->sc_txd[ri];

	for (;;) {
		if (cnt <= 0)
			break;

		txflags = HME_XD_GETFLAGS(sc->sc_pci, sc->sc_rb.rb_txd, ri);

		if (txflags & HME_XD_OWN)
			break;

		ifq_clr_oactive(&ifp->if_snd);

		if (sd->sd_mbuf != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map,
			    0, sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			m_freem(sd->sd_mbuf);
			sd->sd_mbuf = NULL;
		}

		if (++ri == HME_TX_RING_SIZE) {
			ri = 0;
			sd = sc->sc_txd;
		} else
			sd++;

		--cnt;
	}

	sc->sc_tx_cnt = cnt;
	ifp->if_timer = cnt > 0 ? 5 : 0;

	/* Update ring */
	sc->sc_tx_cons = ri;

	hme_start(ifp);

	return (1);
}

/*
 * Receive interrupt.
 */
int
hme_rint(struct hme_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	struct hme_sxd *sd;
	unsigned int ri, len;
	u_int32_t flags;

	ri = sc->sc_rx_cons;
	sd = &sc->sc_rxd[ri];

	/*
	 * Process all buffers with valid data.
	 */
	while (if_rxr_inuse(&sc->sc_rx_ring) > 0) {
		flags = HME_XD_GETFLAGS(sc->sc_pci, sc->sc_rb.rb_rxd, ri);
		if (flags & HME_XD_OWN)
			break;

		bus_dmamap_sync(sc->sc_dmatag, sd->sd_map,
		    0, sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);

		m = sd->sd_mbuf;
		sd->sd_mbuf = NULL;

		if (++ri == HME_RX_RING_SIZE) {
			ri = 0;
			sd = sc->sc_rxd;
		} else
			sd++;

		if_rxr_put(&sc->sc_rx_ring, 1);

		if (flags & HME_XD_OFL) {
			ifp->if_ierrors++;
			printf("%s: buffer overflow, ri=%d; flags=0x%x\n",
			    sc->sc_dev.dv_xname, ri, flags);
			m_freem(m);
			continue;
		}

		len = HME_XD_DECODE_RSIZE(flags);
		m->m_pkthdr.len = m->m_len = len;

		ml_enqueue(&ml, m);
	}

	if_input(ifp, &ml);

	sc->sc_rx_cons = ri;
	hme_fill_rx_ring(sc);
	return (1);
}

int
hme_eint(struct hme_softc *sc, u_int status)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	if (status & HME_SEB_STAT_MIFIRQ) {
		printf("%s: XXXlink status changed\n", sc->sc_dev.dv_xname);
		status &= ~HME_SEB_STAT_MIFIRQ;
	}

	if (status & HME_SEB_STAT_DTIMEXP) {
		ifp->if_oerrors++;
		status &= ~HME_SEB_STAT_DTIMEXP;
	}

	if (status & HME_SEB_STAT_NORXD) {
		ifp->if_ierrors++;
		status &= ~HME_SEB_STAT_NORXD;
	}

	status &= ~(HME_SEB_STAT_RXTOHOST | HME_SEB_STAT_GOTFRAME |
	    HME_SEB_STAT_SENTFRAME | HME_SEB_STAT_HOSTTOTX |
	    HME_SEB_STAT_TXALL);

	if (status == 0)
		return (1);

#ifdef HME_DEBUG
	printf("%s: status=%b\n", sc->sc_dev.dv_xname, status, HME_SEB_STAT_BITS);
#endif
	return (1);
}

int
hme_intr(void *v)
{
	struct hme_softc *sc = (struct hme_softc *)v;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t seb = sc->sc_seb;
	u_int32_t status;
	int r = 0;

	status = bus_space_read_4(t, seb, HME_SEBI_STAT);
	if (status == 0xffffffff)
		return (0);

	if ((status & HME_SEB_STAT_ALL_ERRORS) != 0)
		r |= hme_eint(sc, status);

	if ((status & (HME_SEB_STAT_TXALL | HME_SEB_STAT_HOSTTOTX)) != 0)
		r |= hme_tint(sc);

	if ((status & HME_SEB_STAT_RXTOHOST) != 0)
		r |= hme_rint(sc);

	return (r);
}


void
hme_watchdog(struct ifnet *ifp)
{
	struct hme_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	ifp->if_oerrors++;

	hme_reset(sc);
}

/*
 * Initialize the MII Management Interface
 */
void
hme_mifinit(struct hme_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mif = sc->sc_mif;
	bus_space_handle_t mac = sc->sc_mac;
	int phy;
	u_int32_t v;

	v = bus_space_read_4(t, mif, HME_MIFI_CFG);
	phy = HME_PHYAD_EXTERNAL;
	if (v & HME_MIF_CFG_MDI1)
		phy = sc->sc_tcvr = HME_PHYAD_EXTERNAL;
	else if (v & HME_MIF_CFG_MDI0)
		phy = sc->sc_tcvr = HME_PHYAD_INTERNAL;
	else
		sc->sc_tcvr = -1;

	/* Configure the MIF in frame mode, no poll, current phy select */
	v = 0;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MIF_CFG_PHY;
	bus_space_write_4(t, mif, HME_MIFI_CFG, v);

	/* If an external transceiver is selected, enable its MII drivers */
	v = bus_space_read_4(t, mac, HME_MACI_XIF);
	v &= ~HME_MAC_XIF_MIIENABLE;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);
}

/*
 * MII interface
 */
static int
hme_mii_readreg(struct device *self, int phy, int reg)
{
	struct hme_softc *sc = (struct hme_softc *)self;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mif = sc->sc_mif;
	bus_space_handle_t mac = sc->sc_mac;
	u_int32_t v, xif_cfg, mifi_cfg;
	int n;

	if (phy != HME_PHYAD_EXTERNAL && phy != HME_PHYAD_INTERNAL)
		return (0);

	/* Select the desired PHY in the MIF configuration register */
	v = mifi_cfg = bus_space_read_4(t, mif, HME_MIFI_CFG);
	v &= ~HME_MIF_CFG_PHY;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MIF_CFG_PHY;
	bus_space_write_4(t, mif, HME_MIFI_CFG, v);

	/* Enable MII drivers on external transceiver */ 
	v = xif_cfg = bus_space_read_4(t, mac, HME_MACI_XIF);
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	else
		v &= ~HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);

	/* Construct the frame command */
	v = (MII_COMMAND_START << HME_MIF_FO_ST_SHIFT) |
	    HME_MIF_FO_TAMSB |
	    (MII_COMMAND_READ << HME_MIF_FO_OPC_SHIFT) |
	    (phy << HME_MIF_FO_PHYAD_SHIFT) |
	    (reg << HME_MIF_FO_REGAD_SHIFT);

	bus_space_write_4(t, mif, HME_MIFI_FO, v);
	for (n = 0; n < 100; n++) {
		DELAY(1);
		v = bus_space_read_4(t, mif, HME_MIFI_FO);
		if (v & HME_MIF_FO_TALSB) {
			v &= HME_MIF_FO_DATA;
			goto out;
		}
	}

	v = 0;
	printf("%s: mii_read timeout\n", sc->sc_dev.dv_xname);

out:
	/* Restore MIFI_CFG register */
	bus_space_write_4(t, mif, HME_MIFI_CFG, mifi_cfg);
	/* Restore XIF register */
	bus_space_write_4(t, mac, HME_MACI_XIF, xif_cfg);
	return (v);
}

static void
hme_mii_writereg(struct device *self, int phy, int reg, int val)
{
	struct hme_softc *sc = (void *)self;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mif = sc->sc_mif;
	bus_space_handle_t mac = sc->sc_mac;
	u_int32_t v, xif_cfg, mifi_cfg;
	int n;

	/* We can at most have two PHYs */
	if (phy != HME_PHYAD_EXTERNAL && phy != HME_PHYAD_INTERNAL)
		return;

	/* Select the desired PHY in the MIF configuration register */
	v = mifi_cfg = bus_space_read_4(t, mif, HME_MIFI_CFG);
	v &= ~HME_MIF_CFG_PHY;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MIF_CFG_PHY;
	bus_space_write_4(t, mif, HME_MIFI_CFG, v);

	/* Enable MII drivers on external transceiver */ 
	v = xif_cfg = bus_space_read_4(t, mac, HME_MACI_XIF);
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	else
		v &= ~HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);

	/* Construct the frame command */
	v = (MII_COMMAND_START << HME_MIF_FO_ST_SHIFT)	|
	    HME_MIF_FO_TAMSB				|
	    (MII_COMMAND_WRITE << HME_MIF_FO_OPC_SHIFT)	|
	    (phy << HME_MIF_FO_PHYAD_SHIFT)		|
	    (reg << HME_MIF_FO_REGAD_SHIFT)		|
	    (val & HME_MIF_FO_DATA);

	bus_space_write_4(t, mif, HME_MIFI_FO, v);
	for (n = 0; n < 100; n++) {
		DELAY(1);
		v = bus_space_read_4(t, mif, HME_MIFI_FO);
		if (v & HME_MIF_FO_TALSB)
			goto out;
	}

	printf("%s: mii_write timeout\n", sc->sc_dev.dv_xname);
out:
	/* Restore MIFI_CFG register */
	bus_space_write_4(t, mif, HME_MIFI_CFG, mifi_cfg);
	/* Restore XIF register */
	bus_space_write_4(t, mac, HME_MACI_XIF, xif_cfg);
}

static void
hme_mii_statchg(struct device *dev)
{
	struct hme_softc *sc = (void *)dev;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_mac;
	u_int32_t v;

#ifdef HMEDEBUG
	if (sc->sc_debug)
		printf("hme_mii_statchg: status change\n", phy);
#endif

	/* Set the MAC Full Duplex bit appropriately */
	/* Apparently the hme chip is SIMPLEX if working in full duplex mode,
	   but not otherwise. */
	v = bus_space_read_4(t, mac, HME_MACI_TXCFG);
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0) {
		v |= HME_MAC_TXCFG_FULLDPLX;
		sc->sc_arpcom.ac_if.if_flags |= IFF_SIMPLEX;
	} else {
		v &= ~HME_MAC_TXCFG_FULLDPLX;
		sc->sc_arpcom.ac_if.if_flags &= ~IFF_SIMPLEX;
	}
	bus_space_write_4(t, mac, HME_MACI_TXCFG, v);
}

int
hme_mediachange(struct ifnet *ifp)
{
	struct hme_softc *sc = ifp->if_softc;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mif = sc->sc_mif;
	bus_space_handle_t mac = sc->sc_mac;
	uint64_t instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
	int phy = sc->sc_phys[instance];
	u_int32_t v;

#ifdef HMEDEBUG
	if (sc->sc_debug)
		printf("hme_mediachange: phy = %d\n", phy);
#endif
	if (IFM_TYPE(sc->sc_media.ifm_media) != IFM_ETHER)
		return (EINVAL);

	/* Select the current PHY in the MIF configuration register */
	v = bus_space_read_4(t, mif, HME_MIFI_CFG);
	v &= ~HME_MIF_CFG_PHY;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MIF_CFG_PHY;
	bus_space_write_4(t, mif, HME_MIFI_CFG, v);

	/* If an external transceiver is selected, enable its MII drivers */
	v = bus_space_read_4(t, mac, HME_MACI_XIF);
	v &= ~HME_MAC_XIF_MIIENABLE;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);

	return (mii_mediachg(&sc->sc_mii));
}

void
hme_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct hme_softc *sc = ifp->if_softc;

	if ((ifp->if_flags & IFF_UP) == 0)
		return;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
}

/*
 * Process an ioctl request.
 */
int
hme_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct hme_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			hme_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				hme_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				hme_stop(sc, 0);
		}
#ifdef HMEDEBUG
		sc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;
#endif
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	case SIOCGIFRXR:
		error = if_rxr_ioctl((struct if_rxrinfo *)ifr->ifr_data,
		    NULL, MCLBYTES, &sc->sc_rx_ring);
 		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			hme_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
hme_iff(struct hme_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_mac;
	u_int32_t hash[4];
	u_int32_t rxcfg, crc;

	rxcfg = bus_space_read_4(t, mac, HME_MACI_RXCFG);
	rxcfg &= ~(HME_MAC_RXCFG_HENABLE | HME_MAC_RXCFG_PMISC);
	ifp->if_flags &= ~IFF_ALLMULTI;
	/* Clear hash table */
	hash[0] = hash[1] = hash[2] = hash[3] = 0;

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxcfg |= HME_MAC_RXCFG_PMISC;
	} else if (ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxcfg |= HME_MAC_RXCFG_HENABLE;
		hash[0] = hash[1] = hash[2] = hash[3] = 0xffff;
	} else {
		rxcfg |= HME_MAC_RXCFG_HENABLE;

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			crc = ether_crc32_le(enm->enm_addrlo,
			    ETHER_ADDR_LEN) >> 26; 

			/* Set the corresponding bit in the filter. */
			hash[crc >> 4] |= 1 << (crc & 0xf);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	/* Now load the hash table into the chip */
	bus_space_write_4(t, mac, HME_MACI_HASHTAB0, hash[0]);
	bus_space_write_4(t, mac, HME_MACI_HASHTAB1, hash[1]);
	bus_space_write_4(t, mac, HME_MACI_HASHTAB2, hash[2]);
	bus_space_write_4(t, mac, HME_MACI_HASHTAB3, hash[3]);
	bus_space_write_4(t, mac, HME_MACI_RXCFG, rxcfg);
}

void
hme_fill_rx_ring(struct hme_softc *sc)
{
	struct hme_sxd *sd;
	u_int slots;

	for (slots = if_rxr_get(&sc->sc_rx_ring, HME_RX_RING_SIZE);
	    slots > 0; slots--) {
		if (hme_newbuf(sc, &sc->sc_rxd[sc->sc_rx_prod]))
			break;

		sd = &sc->sc_rxd[sc->sc_rx_prod];
		HME_XD_SETADDR(sc->sc_pci, sc->sc_rb.rb_rxd, sc->sc_rx_prod,
		    sd->sd_map->dm_segs[0].ds_addr);
		HME_XD_SETFLAGS(sc->sc_pci, sc->sc_rb.rb_rxd, sc->sc_rx_prod,
		    HME_XD_OWN | HME_XD_ENCODE_RSIZE(HME_RX_PKTSIZE));

		if (++sc->sc_rx_prod == HME_RX_RING_SIZE)
			sc->sc_rx_prod = 0;
        }
	if_rxr_put(&sc->sc_rx_ring, slots);
}

int
hme_newbuf(struct hme_softc *sc, struct hme_sxd *d)
{
	struct mbuf *m;
	bus_dmamap_t map;

	/*
	 * All operations should be on local variables and/or rx spare map
	 * until we're sure everything is a success.
	 */

	m = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
	if (!m)
		return (ENOBUFS);

	if (bus_dmamap_load(sc->sc_dmatag, sc->sc_rxmap_spare,
	    mtod(m, caddr_t), MCLBYTES - HME_RX_OFFSET, NULL,
	    BUS_DMA_NOWAIT) != 0) {
		m_freem(m);
		return (ENOBUFS);
	}

	/*
	 * At this point we have a new buffer loaded into the spare map.
	 * Just need to clear out the old mbuf/map and put the new one
	 * in place.
	 */

	map = d->sd_map;
	d->sd_map = sc->sc_rxmap_spare;
	sc->sc_rxmap_spare = map;

	bus_dmamap_sync(sc->sc_dmatag, d->sd_map, 0, d->sd_map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

	m->m_data += HME_RX_OFFSET;
	d->sd_mbuf = m;
	return (0);
}
@


1.80
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.79 2015/12/08 13:34:22 tedu Exp $	*/
a764 2
		if (txflags & HME_XD_EOP)
			ifp->if_opackets++;
@


1.79
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.78 2015/11/25 03:09:58 dlg Exp $	*/
a218 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.78
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.77 2015/11/24 15:25:20 mpi Exp $	*/
d218 1
a218 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.77
log
@No need for "vlan.h" if you don't check for "#if NVLAN > 0".
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.76 2015/11/20 03:35:22 dlg Exp $	*/
d385 2
a386 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d627 1
a627 1
	ifp->if_flags &= ~IFF_OACTIVE;
d643 1
a643 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d676 1
a676 1
			ifp->if_flags |= IFF_OACTIVE;
d765 1
a765 1
		ifp->if_flags &= ~IFF_OACTIVE;
@


1.76
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.75 2015/10/25 12:48:46 mpi Exp $	*/
a37 1
#include "vlan.h"
@


1.75
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.74 2015/09/11 13:02:28 stsp Exp $	*/
d647 1
a647 1
		IFQ_POLL(&ifp->if_snd, m);
d675 1
d681 1
a681 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d736 1
a736 1
	IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.74
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.73 2015/06/24 09:40:54 mpi Exp $	*/
a1154 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1164 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.73
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.72 2015/03/30 09:47:05 mpi Exp $	*/
d262 1
a262 1
				    " at phy %d, instance %d\n",
d1107 1
a1107 1
	int instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
@


1.72
log
@Convert to if_input(), tested by sebastia@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.71 2015/03/14 03:38:47 jsg Exp $	*/
a844 2

		ifp->if_ipackets++;
@


1.71
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.70 2014/12/22 02:28:51 tedu Exp $	*/
d803 1
d848 2
a849 4
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
d851 1
a851 2
		ether_input_mbuf(ifp, m);
	}
a1295 1
	m->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
@


1.70
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.69 2014/11/27 14:53:42 brad Exp $	*/
a53 1
#include <net/if_dl.h>
@


1.69
log
@Garbage collect some bits that were never used.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.68 2014/11/27 05:47:25 brad Exp $	*/
a56 1
#ifdef INET
a58 1
#endif
a1170 1
#ifdef INET
a1172 1
#endif
@


1.68
log
@rxr ioctl handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.67 2014/07/22 13:12:12 mpi Exp $	*/
a520 9
	/* Call MI reset function if any */
	if (sc->sc_hwreset)
		(*sc->sc_hwreset)(sc);

#if 0
	/* Mask all MIF interrupts, just in case */
	bus_space_write_4(t, mif, HME_MIFI_IMASK, 0xffff);
#endif

a621 6

	/* step 14. Issue Transmit Pending command */

	/* Call MI initialization function if any */
	if (sc->sc_hwinit)
		(*sc->sc_hwinit)(sc);
@


1.67
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.66 2014/07/08 05:35:18 dlg Exp $	*/
d1213 5
@


1.66
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.65 2014/06/17 02:48:30 dlg Exp $	*/
a58 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a59 2
#include <netinet/tcp.h>
#include <netinet/udp.h>
@


1.65
log
@ansi function declarations.

ok gcc sha256
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.64 2014/04/22 15:52:05 naddy Exp $	*/
a229 2
	m_clsetwms(ifp, MCLBYTES, 0, HME_RX_RING_SIZE);

d361 1
a361 1
	if (sc->sc_rx_cnt == 0)
d438 1
a438 1
	sc->sc_rx_prod = sc->sc_rx_cons = sc->sc_rx_cnt = 0;
d492 1
d836 1
a836 1
	while (sc->sc_rx_cnt > 0) {
d853 2
a854 1
		sc->sc_rx_cnt--;
d1284 1
d1286 2
a1287 1
	while (sc->sc_rx_cnt < HME_RX_RING_SIZE) {
a1298 1
		sc->sc_rx_cnt++;
d1300 1
d1314 1
a1314 1
	m = MCLGETI(NULL, M_DONTWAIT, &sc->sc_arpcom.ac_if, MCLBYTES);
@


1.64
log
@Remove RX checksum offloading support.  The chip is too limited, and
examining higher protocol layers to adjust the checksum and calculate
the pseudo-header in the driver is too complex to be worthwhile.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.63 2013/08/07 01:06:29 bluhm Exp $	*/
d110 1
a110 2
hme_config(sc)
	struct hme_softc *sc;
d307 1
a307 2
hme_unconfig(sc)
	struct hme_softc *sc;
d333 1
a333 2
hme_tick(arg)
	void *arg;
d373 1
a373 2
hme_reset(sc)
	struct hme_softc *sc;
d444 1
a444 2
hme_meminit(sc)
	struct hme_softc *sc;
d502 1
a502 2
hme_init(sc)
	struct hme_softc *sc;
d656 1
a656 2
hme_start(ifp)
	struct ifnet *ifp;
d767 1
a767 2
hme_tint(sc)
	struct hme_softc *sc;
d823 1
a823 2
hme_rint(sc)
	struct hme_softc *sc;
d883 1
a883 3
hme_eint(sc, status)
	struct hme_softc *sc;
	u_int status;
d916 1
a916 2
hme_intr(v)
	void *v;
d942 1
a942 2
hme_watchdog(ifp)
	struct ifnet *ifp;
d956 1
a956 2
hme_mifinit(sc)
	struct hme_softc *sc;
d991 1
a991 3
hme_mii_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
d1047 1
a1047 3
hme_mii_writereg(self, phy, reg, val)
	struct device *self;
	int phy, reg, val;
d1100 1
a1100 2
hme_mii_statchg(dev)
	struct device *dev;
d1127 1
a1127 2
hme_mediachange(ifp)
	struct ifnet *ifp;
d1162 1
a1162 3
hme_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d1178 1
a1178 4
hme_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d1281 1
a1281 2
hme_fill_rx_ring(sc)
	struct hme_softc *sc;
d1302 1
a1302 3
hme_newbuf(sc, d)
	struct hme_softc *sc;
	struct hme_sxd *d;
@


1.63
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.62 2011/07/05 05:25:09 bluhm Exp $	*/
a107 2
/* TCP/UDP checksum offload support */
void 		hme_rxcksum(struct mbuf *, u_int32_t);
d517 1
a517 1
	u_int32_t v, n;
a625 4
	/* RX TCP/UDP cksum offset */
	n = (ETHER_HDR_LEN + sizeof(struct ip)) / 2;
	n = (n << HME_ERX_CFG_CSUM_SHIFT) & HME_ERX_CFG_CSUMSTART;
	v |= n;
a827 95
 * XXX layering violation
 *
 * If we can have additional csum data member in 'struct pkthdr' for
 * these incomplete checksum offload capable hardware, things would be
 * much simpler. That member variable will carry partial checksum
 * data and it may be evaluated in TCP/UDP input handler after
 * computing pseudo header checksumming.
 */
void
hme_rxcksum(struct mbuf *m, u_int32_t flags)
{
	struct ether_header *eh;
	struct ip *ip;
	struct udphdr *uh;
	int32_t hlen, len, pktlen;
	u_int16_t cksum, *opts;
	u_int32_t temp32;
	union pseudoh {
		struct hdr {
			u_int16_t len;
			u_int8_t ttl;
			u_int8_t proto;
			u_int32_t src;
			u_int32_t dst;
		} h;
		u_int16_t w[6];
	} ph;

	pktlen = m->m_pkthdr.len;
	if (pktlen < sizeof(struct ether_header))
		return;
	eh = mtod(m, struct ether_header *);
	if (eh->ether_type != htons(ETHERTYPE_IP))
		return;
	ip = (struct ip *)(eh + 1);
	if (ip->ip_v != IPVERSION)
		return;

	hlen = ip->ip_hl << 2;
	pktlen -= sizeof(struct ether_header);
	if (hlen < sizeof(struct ip))
		return;
	if (ntohs(ip->ip_len) < hlen)
		return;
	if (ntohs(ip->ip_len) != pktlen) 
		return;
	if (ip->ip_off & htons(IP_MF | IP_OFFMASK))
		return;	/* can't handle fragmented packet */

	switch (ip->ip_p) {
	case IPPROTO_TCP:
		if (pktlen < (hlen + sizeof(struct tcphdr)))
			return;
		break;
	case IPPROTO_UDP:
		if (pktlen < (hlen + sizeof(struct udphdr)))
			return;
		uh = (struct udphdr *)((caddr_t)ip + hlen);
		if (uh->uh_sum == 0)
			return; /* no checksum */
		break;
	default:
		return;
	}

	cksum = htons(~(flags & HME_XD_RXCKSUM));
	/* cksum fixup for IP options */
	len = hlen - sizeof(struct ip);
	if (len > 0) {
		opts = (u_int16_t *)(ip + 1);
		for (; len > 0; len -= sizeof(u_int16_t), opts++) {
			temp32 = cksum - *opts;
			temp32 = (temp32 >> 16) + (temp32 & 65535);
			cksum = temp32 & 65535;
		}
	}
	/* cksum fixup for pseudo-header, replace with in_cksum_phdr()? */
	ph.h.len = htons(ntohs(ip->ip_len) - hlen);
	ph.h.ttl = 0;
	ph.h.proto = ip->ip_p;
	ph.h.src = ip->ip_src.s_addr;
	ph.h.dst = ip->ip_dst.s_addr;
	temp32 = cksum;
	opts = &ph.w[0];
	temp32 += opts[0] + opts[1] + opts[2] + opts[3] + opts[4] + opts[5];
	temp32 = (temp32 >> 16) + (temp32 & 65535);
	temp32 += (temp32 >> 16);
	cksum = ~temp32;
	if (cksum == 0) {
		m->m_pkthdr.csum_flags |=
			M_TCP_CSUM_IN_OK | M_UDP_CSUM_IN_OK;
	}
}

/*
a876 1
		hme_rxcksum(m, flags);
@


1.62
log
@When the kernel runs out of mbuf clusters, the hme receive ring may
become empty.  In that case, the hme driver could not recover as
the ring was only filled after receiving data.  Check and potentially
fill an empty receive ring every second in hme_tick().
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.61 2009/10/15 17:54:54 deraadt Exp $	*/
a59 1
#include <netinet/in_var.h>
@


1.61
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.60 2009/08/10 20:29:54 deraadt Exp $	*/
d364 7
@


1.60
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.59 2009/08/09 11:40:58 deraadt Exp $	*/
d86 1
a86 1
void		hme_stop(struct hme_softc *);
d151 1
a151 1
	hme_stop(sc);
d311 27
d383 1
a383 2
hme_stop(sc)
	struct hme_softc *sc;
d398 2
a399 1
	mii_down(&sc->sc_mii);
d401 2
a402 2
	/* Mask all interrupts */
	bus_space_write_4(t, seb, HME_SEBI_IMASK, 0xffffffff);
d404 12
a415 9
	/* Reset transmitter and receiver */
	bus_space_write_4(t, seb, HME_SEBI_RESET,
	    (HME_SEB_RESET_ETX | HME_SEB_RESET_ERX));

	for (n = 0; n < 20; n++) {
		u_int32_t v = bus_space_read_4(t, seb, HME_SEBI_RESET);
		if ((v & (HME_SEB_RESET_ETX | HME_SEB_RESET_ERX)) == 0)
			break;
		DELAY(20);
a416 2
	if (n >= 20)
		printf("%s: hme_stop: reset failed\n", sc->sc_dev.dv_xname);
d523 1
a523 1
	hme_stop(sc);
d1033 2
d1327 1
a1327 1
				hme_stop(sc);
@


1.59
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.58 2009/06/22 14:31:04 sthen Exp $	*/
a89 1
void		hme_shutdown(void *);
a295 4
	sc->sc_sh = shutdownhook_establish(hme_shutdown, sc);
	if (sc->sc_sh == NULL)
		panic("hme_config: can't establish shutdownhook");

a1320 7
}

void
hme_shutdown(arg)
	void *arg;
{
	hme_stop((struct hme_softc *)arg);
@


1.58
log
@Tidy up promiscuous mode and multicast handling; tested by Simon Kuhnle
and myself. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.57 2009/06/11 22:37:58 sthen Exp $	*/
d1418 2
a1419 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
a1421 6

	MCLGETI(m, M_DONTWAIT, &sc->sc_arpcom.ac_if, MCLBYTES);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}
@


1.57
log
@Simplify the ioctl handling code. From Brad.
Tested by myself and Simon Kuhnle.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.56 2009/04/23 21:24:14 kettenis Exp $	*/
d95 1
a95 1
void		hme_setladrf(struct hme_softc *);
d542 1
a542 1
	hme_setladrf(sc);
a633 1
	ifp->if_timer = 0;
a1303 1

d1320 1
a1320 1
			hme_setladrf(sc);
a1334 3
/*
 * Set up the logical address filter.
 */
d1336 1
a1336 2
hme_setladrf(sc)
	struct hme_softc *sc;
d1339 1
a1341 1
	struct arpcom *ac = &sc->sc_arpcom;
d1345 1
a1345 1
	u_int32_t v, crc;
d1347 3
d1351 1
a1351 1
	hash[3] = hash[2] = hash[1] = hash[0] = 0;
d1353 4
a1356 7
	/* Get current RX configuration */
	v = bus_space_read_4(t, mac, HME_MACI_RXCFG);

	if ((ifp->if_flags & IFF_PROMISC) != 0) {
		/* Turn on promiscuous mode; turn off the hash filter */
		v |= HME_MAC_RXCFG_PMISC;
		v &= ~HME_MAC_RXCFG_HENABLE;
d1358 4
a1361 2
		goto chipit;
	}
d1363 4
a1366 3
	/* Turn off promiscuous mode; turn on the hash filter */
	v &= ~HME_MAC_RXCFG_PMISC;
	v |= HME_MAC_RXCFG_HENABLE;
d1368 2
a1369 7
	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */
d1371 1
a1371 14
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			hash[3] = hash[2] = hash[1] = hash[0] = 0xffff;
			ifp->if_flags |= IFF_ALLMULTI;
			goto chipit;
a1372 7

		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN)>> 26; 

		/* Set the corresponding bit in the filter. */
		hash[crc >> 4] |= 1 << (crc & 0xf);

		ETHER_NEXT_MULTI(step, enm);
a1374 3
	ifp->if_flags &= ~IFF_ALLMULTI;

chipit:
d1380 1
a1380 1
	bus_space_write_4(t, mac, HME_MACI_RXCFG, v);
@


1.56
log
@Clear IFF_RUNNING and IFF_OACTIVE flags and cancel watchdog timer in
hme_stop().  From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.55 2009/04/17 20:20:18 kettenis Exp $	*/
a231 1
	sc->sc_if_flags = ifp->if_flags;
a633 1
	sc->sc_if_flags = ifp->if_flags;
d635 1
a1213 1
	sc->sc_if_flags = sc->sc_arpcom.ac_if.if_flags;
d1286 3
a1288 1
		switch (ifa->ifa_addr->sa_family) {
d1290 1
a1290 7
		case AF_INET:
			if (ifp->if_flags & IFF_UP)
				hme_setladrf(sc);
			else {
				ifp->if_flags |= IFF_UP;
				hme_init(sc);
			}
a1291 1
			break;
a1292 4
		default:
			hme_init(sc);
			break;
		}
d1296 3
a1298 26
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			hme_stop(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			hme_init(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0) {
			/*
			 * If setting debug or promiscuous mode, do not reset
			 * the chip; for everything else, call hme_init()
			 * which will trigger a reset.
			 */
#define RESETIGN (IFF_CANTCHANGE | IFF_DEBUG)
			if (ifp->if_flags == sc->sc_if_flags)
				break;
			if ((ifp->if_flags & (~RESETIGN))
			    == (sc->sc_if_flags & (~RESETIGN)))
				hme_setladrf(sc);
d1301 3
a1303 1
#undef RESETIGN
d1305 1
a1325 1
	sc->sc_if_flags = ifp->if_flags;
@


1.55
log
@Switch hme(4) over to using MCLGETI when allocating mbufs for the RX ring.

tested by okan@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.54 2008/12/10 20:37:48 brad Exp $	*/
d365 1
d371 7
a1313 1
			ifp->if_flags &= ~IFF_RUNNING;
@


1.54
log
@Replace m_free() with m_freem() in foo_start() to ensure that upon error
the full mbuf chain is freed.

ok claudio@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.53 2008/11/28 02:44:17 brad Exp $	*/
d96 2
a97 1
int		hme_newbuf(struct hme_softc *, struct hme_sxd *, int);
d236 2
d398 13
d460 3
a462 9
		if (hme_newbuf(sc, &sc->sc_rxd[i], 1)) {
			printf("%s: rx allocation failed\n",
			    sc->sc_dev.dv_xname);
			break;
		}
		HME_XD_SETADDR(sc->sc_pci, hr->rb_rxd, i,
		    sc->sc_rxd[i].sd_map->dm_segs[0].ds_addr);
		HME_XD_SETFLAGS(sc->sc_pci, hr->rb_rxd, i,
		    HME_XD_OWN | HME_XD_ENCODE_RSIZE(HME_RX_PKTSIZE));
d465 1
a465 2
	sc->sc_tx_prod = sc->sc_tx_cons = sc->sc_tx_cnt = 0;
	sc->sc_last_rd = 0;
d906 1
a906 1
	ri = sc->sc_last_rd;
d912 1
a912 1
	for (;;) {
d917 14
d932 1
d935 2
a936 1
			goto again;
a938 1
		m = sd->sd_mbuf;
a941 9
		if (hme_newbuf(sc, sd, 0)) {
			/*
			 * Allocation of new mbuf cluster failed, leave the
			 * old one in place and keep going.
			 */
			ifp->if_ierrors++;
			goto again;
		}

a950 12

again:
		HME_XD_SETADDR(sc->sc_pci, sc->sc_rb.rb_rxd, ri,
		    sd->sd_map->dm_segs[0].ds_addr);
		HME_XD_SETFLAGS(sc->sc_pci, sc->sc_rb.rb_rxd, ri,
		    HME_XD_OWN | HME_XD_ENCODE_RSIZE(HME_RX_PKTSIZE));

		if (++ri == HME_RX_RING_SIZE) {
			ri = 0;
			sd = sc->sc_rxd;
		} else
			sd++;
d953 2
a954 1
	sc->sc_last_rd = ri;
d1439 22
d1462 1
a1462 1
hme_newbuf(sc, d, freeit)
a1464 1
	int freeit;
d1479 1
a1479 1
	MCLGET(m, M_DONTWAIT);
a1496 10

	if (d->sd_mbuf != NULL) {
		bus_dmamap_sync(sc->sc_dmatag, d->sd_map,
		    0, d->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmatag, d->sd_map);
		if (freeit) {
			m_freem(d->sd_mbuf);
			d->sd_mbuf = NULL;
		}
	}
@


1.53
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.52 2008/11/26 13:30:29 kettenis Exp $	*/
d728 1
a728 1
	m_free(m);
@


1.52
log
@Use bus_dmamap_load_mbuf instead of loading mbuf fragments ourselves, and
use m_defrag to linearize packets that don't fit in 16 segments.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.51 2008/10/02 20:21:13 brad Exp $	*/
a1330 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				hme_setladrf(sc);
			error = 0;
		}
		break;

d1338 6
@


1.51
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.50 2008/09/10 14:01:22 blambert Exp $	*/
a96 1
int		hme_encap(struct hme_softc *, struct mbuf *, int *);
d154 1
a154 1
		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1,
d386 1
a386 1
		if (sc->sc_txd[n].sd_loaded) {
a390 3
			sc->sc_txd[n].sd_loaded = 0;
		}
		if (sc->sc_txd[n].sd_mbuf != NULL) {
d628 1
d630 4
a633 1
	int bix, cnt = 0;
d638 1
a638 2
	bix = sc->sc_tx_prod;
	while (sc->sc_txd[bix].sd_mbuf == NULL) {
d643 31
d683 17
a699 3
		if (hme_encap(sc, m, &bix)) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
d702 14
a715 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d719 1
a719 2
		cnt++;
	}
a720 2
	if (cnt != 0) {
		sc->sc_tx_prod = bix;
d723 7
a760 5
		bus_dmamap_sync(sc->sc_dmatag, sd->sd_map,
		    0, sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
		sd->sd_loaded = 0;

d762 3
a1446 87
hme_encap(sc, mhead, bixp)
	struct hme_softc *sc;
	struct mbuf *mhead;
	int *bixp;
{
	struct hme_sxd *sd;
	struct mbuf *m;
	int frag, cur, cnt = 0;
	u_int32_t flags;
	struct hme_ring *hr = &sc->sc_rb;

	cur = frag = *bixp;
	sd = &sc->sc_txd[frag];

	for (m = mhead; m != NULL; m = m->m_next) {
		if (m->m_len == 0)
			continue;

		if ((HME_TX_RING_SIZE - (sc->sc_tx_cnt + cnt)) < 5)
			goto err;

		if (bus_dmamap_load(sc->sc_dmatag, sd->sd_map,
		    mtod(m, caddr_t), m->m_len, NULL, BUS_DMA_NOWAIT) != 0)
			goto err;

		sd->sd_loaded = 1;
		bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREWRITE);

		sd->sd_mbuf = NULL;

		flags = HME_XD_ENCODE_TSIZE(m->m_len);
		if (cnt == 0)
			flags |= HME_XD_SOP;
		else
			flags |= HME_XD_OWN;

		HME_XD_SETADDR(sc->sc_pci, hr->rb_txd, frag,
		    sd->sd_map->dm_segs[0].ds_addr);
		HME_XD_SETFLAGS(sc->sc_pci, hr->rb_txd, frag, flags);

		cur = frag;
		cnt++;
		if (++frag == HME_TX_RING_SIZE) {
			frag = 0;
			sd = sc->sc_txd;
		} else
			sd++;
	}

	/* Set end of packet on last descriptor. */
	flags = HME_XD_GETFLAGS(sc->sc_pci, hr->rb_txd, cur);
	flags |= HME_XD_EOP;
	HME_XD_SETFLAGS(sc->sc_pci, hr->rb_txd, cur, flags);
	sc->sc_txd[cur].sd_mbuf = mhead;

	/* Give first frame over to the hardware. */
	flags = HME_XD_GETFLAGS(sc->sc_pci, hr->rb_txd, (*bixp));
	flags |= HME_XD_OWN;
	HME_XD_SETFLAGS(sc->sc_pci, hr->rb_txd, (*bixp), flags);

	sc->sc_tx_cnt += cnt;
	*bixp = frag;

	/* sync descriptors */

	return (0);

err:
	/*
	 * Invalidate the stuff we may have already put into place. We
	 * will be called again to queue it later.
	 */
	for (; cnt > 0; cnt--) {
		if (--frag == -1)
			frag = HME_TX_RING_SIZE - 1;
		sd = &sc->sc_txd[frag];
		bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
		sd->sd_loaded = 0;
		sd->sd_mbuf = NULL;
	}
	return (ENOBUFS);
}

int
d1484 1
a1484 1
	if (d->sd_loaded) {
d1488 4
a1491 6
		d->sd_loaded = 0;
	}

	if ((d->sd_mbuf != NULL) && freeit) {
		m_freem(d->sd_mbuf);
		d->sd_mbuf = NULL;
a1496 2

	d->sd_loaded = 1;
@


1.50
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.49 2008/06/26 05:42:15 ray Exp $	*/
a1214 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

a1215 1

d1295 1
a1295 2
		error = ENOTTY;
		break;
@


1.49
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.48 2007/11/18 02:28:25 brad Exp $	*/
d345 1
a345 1
	timeout_add(&sc->sc_tick_ch, hz);
d618 1
a618 1
	timeout_add(&sc->sc_tick_ch, hz);
@


1.48
log
@revert previous commit as requested by kettenis and deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.46 2006/12/21 22:13:36 jason Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.47
log
@remove use of static.

ok dlg@@
@
text
@d107 3
a109 3
int		hme_mii_readreg(struct device *, int, int);
void		hme_mii_writereg(struct device *, int, int, int);
void		hme_mii_statchg(struct device *);
d1013 1
a1013 1
int
d1071 1
a1071 1
void
d1126 1
a1126 1
void
@


1.46
log
@betetr yet, just nuke sc_enaddr all together, just fill in arpcom and
everybody is happy
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.45 2006/12/21 21:48:11 jason Exp $	*/
d107 3
a109 3
static int	hme_mii_readreg(struct device *, int, int);
static void	hme_mii_writereg(struct device *, int, int, int);
static void	hme_mii_statchg(struct device *);
d1013 1
a1013 1
static int
d1071 1
a1071 1
static void
d1126 1
a1126 1
static void
@


1.45
log
@better yet, nuke all references to sc_enaddr except for the copy into arpcom.ac_enaddr
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.44 2006/12/21 21:43:44 jason Exp $	*/
d154 1
a154 1
	 *	sc_enaddr
a156 2

	bcopy(sc->sc_enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
@


1.44
log
@use the arpcom copy of the ethernet address so that updates to lladdr can work
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.43 2006/06/25 21:53:44 brad Exp $	*/
d231 1
a231 1
	printf(", address %s\n", ether_sprintf(sc->sc_enaddr));
@


1.43
log
@fix a typo in a comment and add the comment to the sparc hme driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.42 2006/03/25 22:41:43 djm Exp $	*/
d522 1
a522 1
	ea = sc->sc_enaddr;
@


1.42
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.41 2006/01/12 15:06:12 brad Exp $	*/
d1143 1
a1143 1
	/* Apparently the hme chip is SIMPLE if working in full duplex mode,
@


1.41
log
@- add a missing htons() to the receive checksum routine to fix
checksumming on little endian systems.
- only set the Ok flag in the checksum routine.

Checksumming fix from: Pyun YongHyeon <pyunyh at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.40 2005/12/16 06:08:13 brad Exp $	*/
d659 1
a659 1
			bpf_mtap(ifp->if_bpf, m);
d882 1
a882 1
			bpf_mtap(ifp->if_bpf, m);
@


1.40
log
@a little quieter
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.39 2005/10/21 22:10:56 brad Exp $	*/
d117 1
a117 1
/* TCP/UDP checksum offloading support */
d755 1
a755 1
	u_int16_t cksum, flag_bad, flag_ok, *opts;
a792 2
		flag_ok = M_TCP_CSUM_IN_OK;
		flag_bad = M_TCP_CSUM_IN_BAD;
a799 2
		flag_ok = M_UDP_CSUM_IN_OK;
		flag_bad = M_UDP_CSUM_IN_BAD;
d805 1
a805 1
	cksum = ~(flags & HME_XD_RXCKSUM);
d828 4
a831 4
	if (cksum != 0)
		m->m_pkthdr.csum_flags |= flag_bad;
	else
		m->m_pkthdr.csum_flags |= flag_ok;
a877 1
#if 0
a878 1
#endif
@


1.39
log
@tidy up dmesg printing a bit, makes PCI hme only take 2 lines
per interface instead of 3.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.38 2005/06/26 04:27:19 brad Exp $	*/
d939 1
d941 1
@


1.38
log
@rev 1.29

hme_init(): call mii_mediachg() to make sure the current media is set.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.37 2005/06/08 04:14:25 brad Exp $	*/
a162 1

d198 1
a198 1
		printf("%s: DMA buffer alloc error %d\n",
d206 1
a206 1
		printf("%s: DMA buffer map error %d\n",
d215 1
a215 1
		printf("%s: DMA map create error %d\n",
d224 1
a224 1
		printf("%s: DMA buffer map load error %d\n",
d231 1
a231 1
	printf(": address %s\n", ether_sprintf(sc->sc_enaddr));
d887 1
a887 2
		if (ifp->if_bpf) {
			m->m_pkthdr.len = m->m_len = len;
a888 1
		}
@


1.37
log
@disable RX checksum offload until its fixed on little endian systems
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.36 2005/04/25 17:55:51 brad Exp $	*/
d623 3
@


1.36
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.35 2005/02/04 05:02:38 brad Exp $	*/
d880 1
d882 1
@


1.35
log
@add hme(4) RX TCP/UDP checksum offload

From a diff posted to sparc@@ by Pyun YongHyeon

ok dlg@@, tested by mickey@@ "i get some badass improvement here." and
a few other users.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.34 2005/01/15 05:24:11 brad Exp $	*/
d831 1
a831 1
		m->m_pkthdr.csum |= flag_bad;
d833 1
a833 1
		m->m_pkthdr.csum |= flag_ok;
@


1.34
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.33 2004/09/28 00:21:23 brad Exp $	*/
d70 2
d117 2
d488 1
a488 1
	u_int32_t v;
d597 4
d738 99
d879 3
a888 1
		ifp->if_ipackets++;
@


1.33
log
@- Use ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN instead of HME_MTU
- Use ETHER_CRC_POLY_LE instead of MC_POLY_LE from hmereg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.32 2004/08/08 19:01:20 brad Exp $	*/
d1191 2
a1192 1
			hme_setladrf(sc);
@


1.32
log
@do not reset the chip (and subsequently the phy) when unnecessary; that is,
for address changes, multicast filter changes, or adjusting promiscuous mode.
Fixes resetting the phy for things like start/stopping tcpdump.

From NetBSD
tested by me, miod@@, otto@@ and a few others.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.31 2004/05/31 01:51:30 mcbride Exp $	*/
a80 4
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

d240 1
a240 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
d516 1
a516 1
	bus_space_write_4(t, mac, HME_MACI_TXSIZE, HME_MTU);
d543 1
a543 1
	bus_space_write_4(t, mac, HME_MACI_RXSIZE, HME_MTU);
@


1.31
log
@Don't reinvent the wheel, use ether_crc32_le() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.30 2004/05/12 06:35:10 tedu Exp $	*/
d242 1
d625 1
d1050 1
a1128 2
		ifp->if_flags |= IFF_UP;

d1132 6
a1137 1
			hme_init(sc);
d1165 3
a1167 2
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
d1169 9
a1177 1
			hme_init(sc);
d1210 1
@


1.30
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.29 2003/06/18 15:35:47 jason Exp $	*/
a1218 2
	u_char *cp;
	u_int32_t crc;
d1220 1
a1220 2
	u_int32_t v;
	int len;
d1264 1
a1264 19
		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			int octet = *cp++;
			int i;

#define MC_POLY_LE	0xedb88320UL	/* mcast crc, little endian */
			for (i = 0; i < 8; i++) {
				if ((crc & 1) ^ (octet & 1)) {
					crc >>= 1;
					crc ^= MC_POLY_LE;
				} else {
					crc >>= 1;
				}
				octet >>= 1;
			}
		}
		/* Just want the 6 most significant bits. */
		crc >>= 26;
@


1.29
log
@we already set the rx descriptor length to accept vlan packets... just
need to advertise the capability; tested by tsar at polarcap dot org
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.28 2003/04/27 11:22:52 ho Exp $	*/
a73 1
#include <net/bpfdesc.h>
@


1.28
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.27 2003/04/26 08:01:42 jmc Exp $	*/
d244 1
@


1.27
log
@managment -> management;

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.26 2003/03/05 20:46:26 jason Exp $	*/
d236 1
a236 1
	strcpy(ifp->if_xname, sc->sc_dev.dv_xname);
@


1.26
log
@update media handling based on NetBSD: mainly fix setting up of the output
drivers
also, force a preference of the external phy a little earlier: both ports
on the netra T1/105 now work.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.25 2003/02/08 21:42:11 jason Exp $	*/
d149 1
a149 1
	 *	sc_mif		(Managment Interface registers)
@


1.25
log
@avoid more spurious printfs (account for other uninteresting events).
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.24 2003/02/01 06:00:10 jason Exp $	*/
d251 2
a252 1
	ifmedia_init(&mii->mii_media, 0, hme_mediachange, hme_mediastatus);
d256 6
a261 2
	mii_attach(&sc->sc_dev, mii, 0xffffffff,
	    MII_PHY_ANY, MII_OFFSET_ANY, 0);
d379 3
a485 1
	bus_space_handle_t mif = sc->sc_mif;
a600 3
	/* If an external transceiver is connected, enable its MII drivers */
	if ((bus_space_read_4(t, mif, HME_MIFI_CFG) & HME_MIF_CFG_MDI1) != 0)
		v |= HME_MAC_XIF_MIIENABLE;
a602 1

d880 2
a883 1
	/* Configure the MIF in frame mode */
d885 12
a896 1
	v &= ~HME_MIF_CFG_BBMODE;
d899 6
a904 4
	if (v & HME_MIF_CFG_MDI1)
		sc->sc_tcvr = HME_PHYAD_EXTERNAL;
	else if (v & HME_MIF_CFG_MDI0)
		sc->sc_tcvr = HME_PHYAD_INTERNAL;
d918 2
a920 1
	u_int32_t v;
d922 1
a922 1
	if (sc->sc_tcvr != phy)
d926 1
a926 2
	v = bus_space_read_4(t, mif, HME_MIFI_CFG);
	/* Clear PHY select bit */
a928 1
		/* Set PHY select bit to get at external device */
d932 8
d951 4
a954 2
		if (v & HME_MIF_FO_TALSB)
			return (v & HME_MIF_FO_DATA);
d957 1
d959 7
a965 1
	return (0);
d976 2
a978 1
	u_int32_t v;
d980 2
a981 1
	if (sc->sc_tcvr != phy)
d985 1
a985 2
	v = bus_space_read_4(t, mif, HME_MIFI_CFG);
	/* Clear PHY select bit */
a987 1
		/* Set PHY select bit to get at external device */
d991 8
d1012 1
a1012 1
			return;
d1016 5
a1027 2
	int instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
	int phy = sc->sc_phys[instance];
a1028 1
	bus_space_handle_t mif = sc->sc_mif;
d1034 1
a1034 1
		printf("hme_mii_statchg: status change: phy = %d\n", phy);
a1036 7
	/* Select the current PHY in the MIF configuration register */
	v = bus_space_read_4(t, mif, HME_MIFI_CFG);
	v &= ~HME_MIF_CFG_PHY;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MIF_CFG_PHY;
	bus_space_write_4(t, mif, HME_MIFI_CFG, v);

d1038 2
a1048 7

	/* If an external transceiver is selected, enable its MII drivers */
	v = bus_space_read_4(t, mac, HME_MACI_XIF);
	v &= ~HME_MAC_XIF_MIIENABLE;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);
d1056 6
d1063 4
d1069 14
@


1.24
log
@Look, noone cares if you run of out rx descriptors and whining about it just makes the situation worse.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.23 2002/11/26 01:08:18 fgsch Exp $	*/
d819 4
@


1.23
log
@re-enable if_timer; jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.21 2002/11/14 17:20:52 jason Exp $	*/
d813 5
@


1.22
log
@If both phys are available, prefer the external one.
@
text
@d665 1
a665 1
		ifp->if_timer = 0;
d718 1
a718 2
	if (cnt == 0)
		ifp->if_timer = 0;
@


1.21
log
@Don't complain about the defer timer expiring, call it an oerror instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.20 2002/09/28 02:04:44 jason Exp $	*/
d875 5
d890 1
a890 1
	struct hme_softc *sc = (void *)self;
d896 3
d937 3
@


1.20
log
@- disable if_timer handling (there's a bug which causes this not to get
reset, causing watchdog timeouts).  The interfaces work fine, but the
timer doesn't get reset correctly.
- make IFF_SIMPLEX only set iff the media is IFM_FDX (prevents ip6 from
seeing it's packets and thinking another machine with the same mac is
on the wire when running half-duplex); from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.19 2002/08/07 03:42:14 jason Exp $	*/
d804 3
a806 1
	if ((status & HME_SEB_STAT_MIFIRQ) != 0) {
d808 9
a817 1
	}
d855 1
a855 1
	++ifp->if_oerrors;
@


1.19
log
@Hrmph, part of the logic was correct: turn off if_timer when all descriptors are found to be empty.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.18 2002/08/07 00:30:39 jason Exp $	*/
d665 1
a665 1
		ifp->if_timer = 5;
d974 1
a974 1
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0)
d976 2
a977 1
	else
d979 2
@


1.18
log
@fix if_timer handling:
- only set it to non-zero when at least on packet is enqueued
- zero it if we tx'd at least one packet
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.17 2002/08/06 20:02:26 jason Exp $	*/
d717 2
a718 1
	if (cnt != sc->sc_tx_cnt) {
a719 2
		sc->sc_tx_cnt = cnt;
	}
@


1.17
log
@be sure to unmap/deallocate buffers when hme_stop() is called
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.16 2002/06/14 21:34:59 todd Exp $	*/
d631 1
a631 1
	int bix;
d660 1
d663 4
a666 2
	sc->sc_tx_prod = bix;
	ifp->if_timer = 5;
d679 1
d686 1
a686 1
		if (sc->sc_tx_cnt <= 0)
d714 6
a719 1
		--sc->sc_tx_cnt;
a725 3

	if (sc->sc_tx_cnt == 0)
		ifp->if_timer = 0;
@


1.16
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.15 2002/06/05 22:13:18 fgsch Exp $	*/
d381 1
a381 1
			return;
d384 2
a399 2

	printf("%s: hme_stop: reset failed\n", sc->sc_dev.dv_xname);
@


1.15
log
@fix dma map handling logic in hme_newbuf(); from jason@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.14 2002/03/14 01:26:54 millert Exp $	*/
d278 1
a278 1
				printf("%s: cannot accomodate MII device %s"
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.13 2002/02/18 22:48:03 mickey Exp $	*/
d1308 5
a1323 7
	if (d->sd_loaded) {
		bus_dmamap_sync(sc->sc_dmatag, d->sd_map,
		    0, d->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmatag, d->sd_map);
		d->sd_loaded = 0;
	}

a1326 2
		if (d->sd_mbuf == NULL)
			return (ENOBUFS);
d1331 6
d1338 2
a1339 2
		bus_dmamap_sync(sc->sc_dmatag, d->sd_map, 0,
		    d->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
d1343 1
@


1.13
log
@call ether_ioctl(), fix pr/2371; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.12 2001/10/09 15:07:20 jason Exp $	*/
d95 13
a107 13
void		hme_start __P((struct ifnet *));
void		hme_stop __P((struct hme_softc *));
int		hme_ioctl __P((struct ifnet *, u_long, caddr_t));
void		hme_tick __P((void *));
void		hme_watchdog __P((struct ifnet *));
void		hme_shutdown __P((void *));
void		hme_init __P((struct hme_softc *));
void		hme_meminit __P((struct hme_softc *));
void		hme_mifinit __P((struct hme_softc *));
void		hme_reset __P((struct hme_softc *));
void		hme_setladrf __P((struct hme_softc *));
int		hme_newbuf __P((struct hme_softc *, struct hme_sxd *, int));
int		hme_encap __P((struct hme_softc *, struct mbuf *, int *));
d110 10
a119 10
static int	hme_mii_readreg __P((struct device *, int, int));
static void	hme_mii_writereg __P((struct device *, int, int, int));
static void	hme_mii_statchg __P((struct device *));

int		hme_mediachange __P((struct ifnet *));
void		hme_mediastatus __P((struct ifnet *, struct ifmediareq *));

int		hme_eint __P((struct hme_softc *, u_int));
int		hme_rint __P((struct hme_softc *));
int		hme_tint __P((struct hme_softc *));
@


1.12
log
@- keep a spare dmamap_t around for rx (use it to keep the old mbuf loaded
while trying to get the next buffer setup).
- reduce ring size for both rx & tx
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.11 2001/10/04 20:36:16 jason Exp $	*/
a71 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d1026 5
a1042 17
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else {
				memcpy(LLADDR(ifp->if_sadl),
				    ina->x_host.c_host, sizeof(sc->sc_enaddr));
			}	
			/* Set new address. */
			hme_init(sc);
			break;
		    }
#endif
d1099 1
a1099 1
		error = EINVAL;
@


1.12.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.12 2001/10/09 15:07:20 jason Exp $	*/
d72 5
d100 13
a112 13
void		hme_start(struct ifnet *);
void		hme_stop(struct hme_softc *);
int		hme_ioctl(struct ifnet *, u_long, caddr_t);
void		hme_tick(void *);
void		hme_watchdog(struct ifnet *);
void		hme_shutdown(void *);
void		hme_init(struct hme_softc *);
void		hme_meminit(struct hme_softc *);
void		hme_mifinit(struct hme_softc *);
void		hme_reset(struct hme_softc *);
void		hme_setladrf(struct hme_softc *);
int		hme_newbuf(struct hme_softc *, struct hme_sxd *, int);
int		hme_encap(struct hme_softc *, struct mbuf *, int *);
d115 10
a124 10
static int	hme_mii_readreg(struct device *, int, int);
static void	hme_mii_writereg(struct device *, int, int, int);
static void	hme_mii_statchg(struct device *);

int		hme_mediachange(struct ifnet *);
void		hme_mediastatus(struct ifnet *, struct ifmediareq *);

int		hme_eint(struct hme_softc *, u_int);
int		hme_rint(struct hme_softc *);
int		hme_tint(struct hme_softc *);
a1030 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d1043 17
d1116 1
a1116 1
		error = ENOTTY;
a1324 5
	/*
	 * All operations should be on local variables and/or rx spare map
	 * until we're sure everything is a success.
	 */

d1336 7
d1346 2
a1351 6
	/*
	 * At this point we have a new buffer loaded into the spare map.
	 * Just need to clear out the old mbuf/map and put the new one
	 * in place.
	 */

d1353 2
a1354 2
		bus_dmamap_sync(sc->sc_dmatag, d->sd_map,
		    0, d->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
a1357 1

@


1.12.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.12.6.1 2002/06/11 03:42:18 art Exp $	*/
d278 1
a278 1
				printf("%s: cannot accommodate MII device %s"
d381 1
a381 1
			break;
a383 2
	if (n >= 20)
		printf("%s: hme_stop: reset failed\n", sc->sc_dev.dv_xname);
d398 2
d631 1
a631 1
	int bix, cnt = 0;
a659 1
		cnt++;
d662 2
a663 4
	if (cnt != 0) {
		sc->sc_tx_prod = bix;
		ifp->if_timer = 0;
	}
a675 1
	int cnt = sc->sc_tx_cnt;
d682 1
a682 1
		if (cnt <= 0)
d710 1
a710 1
		--cnt;
a712 4
	sc->sc_tx_cnt = cnt;
	if (cnt == 0)
		ifp->if_timer = 0;

d718 3
d969 1
a969 1
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0) {
d971 1
a971 2
		sc->sc_arpcom.ac_if.if_flags |= IFF_SIMPLEX;
	} else {
a972 2
		sc->sc_arpcom.ac_if.if_flags &= ~IFF_SIMPLEX;
	}
@


1.12.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d149 1
a149 1
	 *	sc_mif		(Management Interface registers)
d236 1
a236 1
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
d251 1
a251 2
	ifmedia_init(&mii->mii_media, IFM_IMASK,
	    hme_mediachange, hme_mediastatus);
d255 2
a256 6
	if (sc->sc_tcvr == -1)
		mii_attach(&sc->sc_dev, mii, 0xffffffff, MII_PHY_ANY,
		    MII_OFFSET_ANY, 0);
	else
		mii_attach(&sc->sc_dev, mii, 0xffffffff, sc->sc_tcvr,
		    MII_OFFSET_ANY, 0);
a373 3
	/* Mask all interrupts */
	bus_space_write_4(t, seb, HME_SEBI_IMASK, 0xffffffff);

d478 1
d594 3
d599 1
d665 1
a665 1
		ifp->if_timer = 5;
d718 2
a719 1
	ifp->if_timer = cnt > 0 ? 5 : 0;
d804 1
a804 3
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	if (status & HME_SEB_STAT_MIFIRQ) {
d806 1
a806 11
		status &= ~HME_SEB_STAT_MIFIRQ;
	}

	if (status & HME_SEB_STAT_DTIMEXP) {
		ifp->if_oerrors++;
		status &= ~HME_SEB_STAT_DTIMEXP;
	}

	if (status & HME_SEB_STAT_NORXD) {
		ifp->if_ierrors++;
		status &= ~HME_SEB_STAT_NORXD;
a808 7
	status &= ~(HME_SEB_STAT_RXTOHOST | HME_SEB_STAT_GOTFRAME |
	    HME_SEB_STAT_SENTFRAME | HME_SEB_STAT_HOSTTOTX |
	    HME_SEB_STAT_TXALL);

	if (status == 0)
		return (1);

d845 1
a845 1
	ifp->if_oerrors++;
a858 2
	bus_space_handle_t mac = sc->sc_mac;
	int phy;
d861 1
d863 1
a863 12
	phy = HME_PHYAD_EXTERNAL;
	if (v & HME_MIF_CFG_MDI1)
		phy = sc->sc_tcvr = HME_PHYAD_EXTERNAL;
	else if (v & HME_MIF_CFG_MDI0)
		phy = sc->sc_tcvr = HME_PHYAD_INTERNAL;
	else
		sc->sc_tcvr = -1;

	/* Configure the MIF in frame mode, no poll, current phy select */
	v = 0;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MIF_CFG_PHY;
a864 7

	/* If an external transceiver is selected, enable its MII drivers */
	v = bus_space_read_4(t, mac, HME_MACI_XIF);
	v &= ~HME_MAC_XIF_MIIENABLE;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);
d875 1
a875 1
	struct hme_softc *sc = (struct hme_softc *)self;
a877 2
	bus_space_handle_t mac = sc->sc_mac;
	u_int32_t v, xif_cfg, mifi_cfg;
d879 1
a879 3

	if (phy != HME_PHYAD_EXTERNAL && phy != HME_PHYAD_INTERNAL)
		return (0);
d882 2
a883 1
	v = mifi_cfg = bus_space_read_4(t, mif, HME_MIFI_CFG);
d886 1
a889 8
	/* Enable MII drivers on external transceiver */ 
	v = xif_cfg = bus_space_read_4(t, mac, HME_MACI_XIF);
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	else
		v &= ~HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);

d901 2
a902 4
		if (v & HME_MIF_FO_TALSB) {
			v &= HME_MIF_FO_DATA;
			goto out;
		}
a904 1
	v = 0;
d906 1
a906 7

out:
	/* Restore MIFI_CFG register */
	bus_space_write_4(t, mif, HME_MIFI_CFG, mifi_cfg);
	/* Restore XIF register */
	bus_space_write_4(t, mac, HME_MACI_XIF, xif_cfg);
	return (v);
a916 2
	bus_space_handle_t mac = sc->sc_mac;
	u_int32_t v, xif_cfg, mifi_cfg;
d918 1
a918 4

	/* We can at most have two PHYs */
	if (phy != HME_PHYAD_EXTERNAL && phy != HME_PHYAD_INTERNAL)
		return;
d921 2
a922 1
	v = mifi_cfg = bus_space_read_4(t, mif, HME_MIFI_CFG);
d925 1
a928 8
	/* Enable MII drivers on external transceiver */ 
	v = xif_cfg = bus_space_read_4(t, mac, HME_MACI_XIF);
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	else
		v &= ~HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);

d942 1
a942 1
			goto out;
a945 5
out:
	/* Restore MIFI_CFG register */
	bus_space_write_4(t, mif, HME_MIFI_CFG, mifi_cfg);
	/* Restore XIF register */
	bus_space_write_4(t, mac, HME_MACI_XIF, xif_cfg);
d953 2
d956 1
d962 1
a962 1
		printf("hme_mii_statchg: status change\n", phy);
d965 7
a972 2
	/* Apparently the hme chip is SIMPLE if working in full duplex mode,
	   but not otherwise. */
d982 7
a995 6
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mif = sc->sc_mif;
	bus_space_handle_t mac = sc->sc_mac;
	int instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
	int phy = sc->sc_phys[instance];
	u_int32_t v;
a996 4
#ifdef HMEDEBUG
	if (sc->sc_debug)
		printf("hme_mediachange: phy = %d\n", phy);
#endif
a998 14

	/* Select the current PHY in the MIF configuration register */
	v = bus_space_read_4(t, mif, HME_MIFI_CFG);
	v &= ~HME_MIF_CFG_PHY;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MIF_CFG_PHY;
	bus_space_write_4(t, mif, HME_MIFI_CFG, v);

	/* If an external transceiver is selected, enable its MII drivers */
	v = bus_space_read_4(t, mac, HME_MACI_XIF);
	v &= ~HME_MAC_XIF_MIIENABLE;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);
@


1.12.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.12.4.2
log
@Merge in trunk
@
text
@d72 5
a1030 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d1043 17
d1116 1
a1116 1
		error = ENOTTY;
@


1.12.4.3
log
@Merge in -current from about a week ago
@
text
@d95 13
a107 13
void		hme_start(struct ifnet *);
void		hme_stop(struct hme_softc *);
int		hme_ioctl(struct ifnet *, u_long, caddr_t);
void		hme_tick(void *);
void		hme_watchdog(struct ifnet *);
void		hme_shutdown(void *);
void		hme_init(struct hme_softc *);
void		hme_meminit(struct hme_softc *);
void		hme_mifinit(struct hme_softc *);
void		hme_reset(struct hme_softc *);
void		hme_setladrf(struct hme_softc *);
int		hme_newbuf(struct hme_softc *, struct hme_sxd *, int);
int		hme_encap(struct hme_softc *, struct mbuf *, int *);
d110 3
a112 3
static int	hme_mii_readreg(struct device *, int, int);
static void	hme_mii_writereg(struct device *, int, int, int);
static void	hme_mii_statchg(struct device *);
d114 2
a115 2
int		hme_mediachange(struct ifnet *);
void		hme_mediastatus(struct ifnet *, struct ifmediareq *);
d117 3
a119 3
int		hme_eint(struct hme_softc *, u_int);
int		hme_rint(struct hme_softc *);
int		hme_tint(struct hme_softc *);
@


1.12.4.4
log
@Sync the SMP branch with 3.3
@
text
@d251 1
a251 2
	ifmedia_init(&mii->mii_media, IFM_IMASK,
	    hme_mediachange, hme_mediastatus);
d255 2
a256 6
	if (sc->sc_tcvr == -1)
		mii_attach(&sc->sc_dev, mii, 0xffffffff, MII_PHY_ANY,
		    MII_OFFSET_ANY, 0);
	else
		mii_attach(&sc->sc_dev, mii, 0xffffffff, sc->sc_tcvr,
		    MII_OFFSET_ANY, 0);
d278 1
a278 1
				printf("%s: cannot accommodate MII device %s"
a373 3
	/* Mask all interrupts */
	bus_space_write_4(t, seb, HME_SEBI_IMASK, 0xffffffff);

d381 1
a381 1
			break;
a383 2
	if (n >= 20)
		printf("%s: hme_stop: reset failed\n", sc->sc_dev.dv_xname);
d398 2
d478 1
d594 3
d599 1
d631 1
a631 1
	int bix, cnt = 0;
a659 1
		cnt++;
d662 2
a663 4
	if (cnt != 0) {
		sc->sc_tx_prod = bix;
		ifp->if_timer = 5;
	}
a675 1
	int cnt = sc->sc_tx_cnt;
d682 1
a682 1
		if (cnt <= 0)
d710 1
a710 1
		--cnt;
a712 3
	sc->sc_tx_cnt = cnt;
	ifp->if_timer = cnt > 0 ? 5 : 0;

d718 3
d799 1
a799 3
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	if (status & HME_SEB_STAT_MIFIRQ) {
d801 1
a801 1
		status &= ~HME_SEB_STAT_MIFIRQ;
a803 17
	if (status & HME_SEB_STAT_DTIMEXP) {
		ifp->if_oerrors++;
		status &= ~HME_SEB_STAT_DTIMEXP;
	}

	if (status & HME_SEB_STAT_NORXD) {
		ifp->if_ierrors++;
		status &= ~HME_SEB_STAT_NORXD;
	}

	status &= ~(HME_SEB_STAT_RXTOHOST | HME_SEB_STAT_GOTFRAME |
	    HME_SEB_STAT_SENTFRAME | HME_SEB_STAT_HOSTTOTX |
	    HME_SEB_STAT_TXALL);

	if (status == 0)
		return (1);

d840 1
a840 1
	ifp->if_oerrors++;
a853 2
	bus_space_handle_t mac = sc->sc_mac;
	int phy;
d856 1
d858 1
a858 12
	phy = HME_PHYAD_EXTERNAL;
	if (v & HME_MIF_CFG_MDI1)
		phy = sc->sc_tcvr = HME_PHYAD_EXTERNAL;
	else if (v & HME_MIF_CFG_MDI0)
		phy = sc->sc_tcvr = HME_PHYAD_INTERNAL;
	else
		sc->sc_tcvr = -1;

	/* Configure the MIF in frame mode, no poll, current phy select */
	v = 0;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MIF_CFG_PHY;
a859 7

	/* If an external transceiver is selected, enable its MII drivers */
	v = bus_space_read_4(t, mac, HME_MACI_XIF);
	v &= ~HME_MAC_XIF_MIIENABLE;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);
d870 1
a870 1
	struct hme_softc *sc = (struct hme_softc *)self;
a872 2
	bus_space_handle_t mac = sc->sc_mac;
	u_int32_t v, xif_cfg, mifi_cfg;
d874 1
a874 3

	if (phy != HME_PHYAD_EXTERNAL && phy != HME_PHYAD_INTERNAL)
		return (0);
d877 2
a878 1
	v = mifi_cfg = bus_space_read_4(t, mif, HME_MIFI_CFG);
d881 1
a884 8
	/* Enable MII drivers on external transceiver */ 
	v = xif_cfg = bus_space_read_4(t, mac, HME_MACI_XIF);
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	else
		v &= ~HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);

d896 2
a897 4
		if (v & HME_MIF_FO_TALSB) {
			v &= HME_MIF_FO_DATA;
			goto out;
		}
a899 1
	v = 0;
d901 1
a901 7

out:
	/* Restore MIFI_CFG register */
	bus_space_write_4(t, mif, HME_MIFI_CFG, mifi_cfg);
	/* Restore XIF register */
	bus_space_write_4(t, mac, HME_MACI_XIF, xif_cfg);
	return (v);
a911 2
	bus_space_handle_t mac = sc->sc_mac;
	u_int32_t v, xif_cfg, mifi_cfg;
d913 1
a913 4

	/* We can at most have two PHYs */
	if (phy != HME_PHYAD_EXTERNAL && phy != HME_PHYAD_INTERNAL)
		return;
d916 2
a917 1
	v = mifi_cfg = bus_space_read_4(t, mif, HME_MIFI_CFG);
d920 1
a923 8
	/* Enable MII drivers on external transceiver */ 
	v = xif_cfg = bus_space_read_4(t, mac, HME_MACI_XIF);
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	else
		v &= ~HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);

d937 1
a937 1
			goto out;
a940 5
out:
	/* Restore MIFI_CFG register */
	bus_space_write_4(t, mif, HME_MIFI_CFG, mifi_cfg);
	/* Restore XIF register */
	bus_space_write_4(t, mac, HME_MACI_XIF, xif_cfg);
d948 2
d951 1
d957 1
a957 1
		printf("hme_mii_statchg: status change\n", phy);
d960 7
a967 2
	/* Apparently the hme chip is SIMPLE if working in full duplex mode,
	   but not otherwise. */
d969 1
a969 1
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0) {
d971 1
a971 2
		sc->sc_arpcom.ac_if.if_flags |= IFF_SIMPLEX;
	} else {
a972 2
		sc->sc_arpcom.ac_if.if_flags &= ~IFF_SIMPLEX;
	}
d974 7
a987 6
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mif = sc->sc_mif;
	bus_space_handle_t mac = sc->sc_mac;
	int instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
	int phy = sc->sc_phys[instance];
	u_int32_t v;
a988 4
#ifdef HMEDEBUG
	if (sc->sc_debug)
		printf("hme_mediachange: phy = %d\n", phy);
#endif
a991 14
	/* Select the current PHY in the MIF configuration register */
	v = bus_space_read_4(t, mif, HME_MIFI_CFG);
	v &= ~HME_MIF_CFG_PHY;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MIF_CFG_PHY;
	bus_space_write_4(t, mif, HME_MIFI_CFG, v);

	/* If an external transceiver is selected, enable its MII drivers */
	v = bus_space_read_4(t, mac, HME_MACI_XIF);
	v &= ~HME_MAC_XIF_MIIENABLE;
	if (phy == HME_PHYAD_EXTERNAL)
		v |= HME_MAC_XIF_MIIENABLE;
	bus_space_write_4(t, mac, HME_MACI_XIF, v);

a1307 5
	/*
	 * All operations should be on local variables and/or rx spare map
	 * until we're sure everything is a success.
	 */

d1319 7
d1329 2
a1334 6
	/*
	 * At this point we have a new buffer loaded into the spare map.
	 * Just need to clear out the old mbuf/map and put the new one
	 * in place.
	 */

d1336 2
a1337 2
		bus_dmamap_sync(sc->sc_dmatag, d->sd_map,
		    0, d->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
a1340 1

@


1.12.4.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.12.4.4 2003/03/28 00:38:13 niklas Exp $	*/
d149 1
a149 1
	 *	sc_mif		(Management Interface registers)
d236 1
a236 1
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
@


1.12.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a243 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
@


1.12.4.7
log
@Merge with the trunk
@
text
@d74 1
d1220 2
d1223 2
a1224 1
	u_int32_t v, crc;
d1268 19
a1286 1
		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN)>> 26; 
@


1.11
log
@move stats update into ticker
allocate all dmamaps in advance (and use load/unload/sync as appropriate)
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.10 2001/10/04 19:17:59 jason Exp $	*/
d186 5
d313 2
d1323 1
d1343 3
a1345 2
	if (bus_dmamap_load(sc->sc_dmatag, d->sd_map, mtod(m, caddr_t),
	    MCLBYTES - HME_RX_OFFSET, NULL, BUS_DMA_NOWAIT) != 0) {
a1347 8

		/* XXX Reload old mbuf, and return. */
		bus_dmamap_load(sc->sc_dmatag, d->sd_map,
		    mtod(d->sd_mbuf, caddr_t), MCLBYTES - HME_RX_OFFSET,
		    NULL, BUS_DMA_NOWAIT);
		d->sd_loaded = 1;
		bus_dmamap_sync(sc->sc_dmatag, d->sd_map,
		    0, d->sd_map->dm_mapsize, BUS_DMASYNC_PREREAD);
d1351 16
a1371 2
	if ((d->sd_mbuf != NULL) && freeit)
		m_freem(d->sd_mbuf);
@


1.10
log
@Fix up tx logic: can't free zero length mbufs (may have to requeue, and it's
not polite to modify the mbuf chain and requeue).
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.9 2001/10/02 21:39:35 jason Exp $	*/
d136 1
a136 1
	int rseg, error;
d170 17
d305 9
d321 3
d327 17
d384 1
a384 1
		if (sc->sc_txd[n].sd_map != NULL) {
d389 1
a389 2
			bus_dmamap_destroy(sc->sc_dmatag, sc->sc_txd[n].sd_map);
			sc->sc_txd[n].sd_map = NULL;
a440 1
		sc->sc_txd[i].sd_map = NULL;
a671 2
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mac = sc->sc_mac;
a674 17
	/*
	 * Unload collision counters
	 */
	ifp->if_collisions +=
	    bus_space_read_4(t, mac, HME_MACI_NCCNT) +
	    bus_space_read_4(t, mac, HME_MACI_FCCNT) +
	    bus_space_read_4(t, mac, HME_MACI_EXCNT) +
	    bus_space_read_4(t, mac, HME_MACI_LTCNT);

	/*
	 * then clear the hardware counters.
	 */
	bus_space_write_4(t, mac, HME_MACI_NCCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_FCCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_EXCNT, 0);
	bus_space_write_4(t, mac, HME_MACI_LTCNT, 0);

d692 5
a696 7
		if (sd->sd_map != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map,
			    0, sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			bus_dmamap_destroy(sc->sc_dmatag, sd->sd_map);
			sd->sd_map = NULL;
		}
a1243 6
		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &sd->sd_map) != 0) {
			sd->sd_map = NULL;
			goto err;
		}

d1245 1
a1245 3
		    mtod(m, caddr_t), m->m_len, NULL, BUS_DMA_NOWAIT) != 0) {
			bus_dmamap_destroy(sc->sc_dmatag, sd->sd_map);
			sd->sd_map = NULL;
a1246 1
		}
d1248 1
d1303 1
a1303 1
		bus_dmamap_destroy(sc->sc_dmatag, sd->sd_map);
a1304 1
		sd->sd_map = NULL;
a1314 1
	bus_dmamap_t map = NULL;
d1328 5
a1332 4
	if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1, MCLBYTES, 0,
	    BUS_DMA_NOWAIT, &map) != 0) {
		m_freem(m);
		return (ENOBUFS);
d1335 12
a1346 3
	if (bus_dmamap_load(sc->sc_dmatag, map, mtod(m, caddr_t), MCLBYTES,
	    NULL, BUS_DMA_NOWAIT) != 0) {
		bus_dmamap_destroy(sc->sc_dmatag, map);
d1350 1
d1352 1
a1352 1
	bus_dmamap_sync(sc->sc_dmatag, map, 0, map->dm_mapsize,
a1356 6
	if (d->sd_map != NULL) {
		bus_dmamap_sync(sc->sc_dmatag, d->sd_map,
		    0, d->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmatag, d->sd_map);
		bus_dmamap_destroy(sc->sc_dmatag, d->sd_map);
	}
a1358 1
	d->sd_map = map;
@


1.9
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.8 2001/10/02 21:21:52 jason Exp $	*/
d347 1
a347 1
			m_free(sc->sc_txd[n].sd_mbuf);
d675 1
a675 1
			m_free(sd->sd_mbuf);
d1206 1
a1206 1
	struct mbuf *m, *mx;
d1214 2
a1215 5
	m = mhead;
	while (m != NULL) {
		if (m->m_len == 0) {
			mx = m_free(m);
			m = mx;
a1216 1
		}
d1237 1
a1237 1
		sd->sd_mbuf = m;
a1255 2

		m = m->m_next;
d1262 1
d1296 1
a1296 1
hme_newbuf(sc, d, f)
d1299 1
a1299 1
	int f;
d1331 2
a1332 4
	if (d->sd_mbuf != NULL && f) {
		if (f)
			m_freem(d->sd_mbuf);
	}
@


1.8
log
@De uglify (a bit) and garbage collect a bunch of now unused functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.7 2001/10/02 20:32:46 jason Exp $	*/
d181 2
a182 2
	if ((error = bus_dmamem_alloc(dmatag, size,
	    2048, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d190 1
a190 2
				    &sc->sc_rb.rb_membase,
				    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
d192 1
a192 1
			sc->sc_dev.dv_xname, error);
d199 1
a199 1
				    BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
d201 1
a201 1
			sc->sc_dev.dv_xname, error);
d210 1
a210 1
			sc->sc_dev.dv_xname, error);
d239 1
a239 1
			MII_PHY_ANY, MII_OFFSET_ANY, 0);
d262 4
a265 4
				       " at phy %d, instance %d\n",
				       sc->sc_dev.dv_xname,
				       child->mii_dev.dv_xname,
				       child->mii_phy, child->mii_inst);
d328 1
a328 1
			  (HME_SEB_RESET_ETX | HME_SEB_RESET_ERX));
d497 3
a499 8
			~(
			  /*HME_SEB_STAT_GOTFRAME | HME_SEB_STAT_SENTFRAME |*/
			  HME_SEB_STAT_HOSTTOTX |
			  HME_SEB_STAT_RXTOHOST |
			  HME_SEB_STAT_TXALL |
			  HME_SEB_STAT_TXPERR |
			  HME_SEB_STAT_RCNTEXP |
			  HME_SEB_STAT_ALL_ERRORS ));
a526 1

d613 1
a613 1
				  HME_ETX_TP_DMAWAKEUP);
d637 4
a640 4
		bus_space_read_4(t, mac, HME_MACI_NCCNT) +
		bus_space_read_4(t, mac, HME_MACI_FCCNT) +
		bus_space_read_4(t, mac, HME_MACI_EXCNT) +
		bus_space_read_4(t, mac, HME_MACI_LTCNT);
d725 1
a725 1
					sc->sc_dev.dv_xname, ri, flags);
a1056 1
			/*hme_stop(sc);*/
a1097 1

@


1.7
log
@Pull in a change I wrote a -long- time ago: avoid {bcopy/memcpy} into statically
allocated buffers.  Use the buffer provided in the mbuf (after bus_dmaifying
it, of course) instead
[This is only step one: next step, garbage collection and deuglification]
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.6 2001/09/23 20:03:01 jason Exp $	*/
a121 3
struct mbuf	*hme_get __P((struct hme_softc *, int, int));
int		hme_put __P((struct hme_softc *, int, struct mbuf *));
void		hme_read __P((struct hme_softc *, int, int));
a158 3
	 * (notyet:DMA capable memory for the ring descriptors & packet buffers:
	 *	rb_membase, rb_dmabase)
	 *
a170 17
	 * Allocate descriptors and buffers
	 * XXX - do all this differently.. and more configurably,
	 * eg. use things as `dma_load_mbuf()' on transmit,
	 *     and a pool of `EXTMEM' mbufs (with buffers DMA-mapped
	 *     all the time) on the reveiver side.
	 *
	 * Note: receive buffers must be 64-byte aligned.
	 * Also, apparently, the buffers must extend to a DMA burst
	 * boundary beyond the maximum packet size.
	 */
#define _HME_BUFSZ	1600

	/* Note: the # of descriptors must be a multiple of 16 */
	sc->sc_rb.rb_ntbuf = _HME_NDESC;
	sc->sc_rb.rb_nrbuf = _HME_NDESC;

	/*
d175 1
a175 1
	 * so we allocate that much regardless of _HME_NDESC.
d177 2
a178 4
	size =	2048 +					/* TX descriptors */
		2048 +					/* RX descriptors */
		sc->sc_rb.rb_ntbuf * _HME_BUFSZ +	/* TX buffers */
		sc->sc_rb.rb_nrbuf * _HME_BUFSZ;	/* TX buffers */
d182 1
a182 2
				      2048, 0,
				      &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d184 1
a184 1
			sc->sc_dev.dv_xname, error);
a287 9
#if 0
	printf("%s: %d receive buffers, %d transmit buffers\n",
	    sc->sc_dev.dv_xname, sc->sc_nrbuf, sc->sc_ntbuf);
	sc->sc_rbufaddr = malloc(sc->sc_nrbuf * sizeof(int), M_DEVBUF,
					M_WAITOK);
	sc->sc_tbufaddr = malloc(sc->sc_ntbuf * sizeof(int), M_DEVBUF,
					M_WAITOK);
#endif

d338 1
a338 1
	for (n = 0; n < sc->sc_rb.rb_ntbuf; n++) {
a359 1
	bus_addr_t txbufdma, rxbufdma;
d362 1
a362 1
	unsigned int ntbuf, nrbuf, i;
a367 3
	ntbuf = hr->rb_ntbuf;
	nrbuf = hr->rb_nrbuf;

d373 2
a374 2
	p += ntbuf * HME_XD_SIZE;
	dma += ntbuf * HME_XD_SIZE;
d384 2
a385 2
	p += nrbuf * HME_XD_SIZE;
	dma += nrbuf * HME_XD_SIZE;
a389 17

	/*
	 * Allocate transmit buffers
	 */
	hr->rb_txbuf = p;
	txbufdma = dma;
	p += ntbuf * _HME_BUFSZ;
	dma += ntbuf * _HME_BUFSZ;

	/*
	 * Allocate receive buffers
	 */
	hr->rb_rxbuf = p;
	rxbufdma = dma;
	p += nrbuf * _HME_BUFSZ;
	dma += nrbuf * _HME_BUFSZ;

d391 1
a391 1
	 * Initialize transmit buffer descriptors
d393 1
a393 1
	for (i = 0; i < ntbuf; i++) {
d401 1
a401 1
	 * Initialize receive buffer descriptors
d403 1
a403 1
	for (i = 0; i < nrbuf; i++) {
d412 1
a412 1
		    HME_XD_OWN | HME_XD_ENCODE_RSIZE(_HME_BUFSZ));
d415 2
a416 3
	hr->rb_tdhead = hr->rb_tdtail = 0;
	sc->sc_tx_cnt = 0;
	hr->rb_rdtail = 0;
d491 1
a491 1
	bus_space_write_4(t, etx, HME_ETXI_RSIZE, sc->sc_rb.rb_ntbuf);
d531 1
a531 1
	bus_space_write_4(t, etx, HME_ETXI_RSIZE, _HME_NDESC / 16 - 1);
d536 12
a547 20

	/* Encode Receive Descriptor ring size: four possible values */
	switch (_HME_NDESC /*XXX*/) {
	case 32:
		v |= HME_ERX_CFG_RINGSIZE32;
		break;
	case 64:
		v |= HME_ERX_CFG_RINGSIZE64;
		break;
	case 128:
		v |= HME_ERX_CFG_RINGSIZE128;
		break;
	case 256:
		v |= HME_ERX_CFG_RINGSIZE256;
		break;
	default:
		printf("hme: invalid Receive Descriptor ring size\n");
		break;
	}

a585 136
/*
 * Routine to copy from mbuf chain to transmit buffer in
 * network buffer memory.
 * Returns the amount of data copied.
 */
int
hme_put(sc, ri, m)
	struct hme_softc *sc;
	int ri;			/* Ring index */
	struct mbuf *m;
{
	struct mbuf *n;
	int len, tlen = 0;
	caddr_t bp;

	bp = sc->sc_rb.rb_txbuf + (ri % sc->sc_rb.rb_ntbuf) * _HME_BUFSZ;
	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			MFREE(m, n);
			continue;
		}
		memcpy(bp, mtod(m, caddr_t), len);
		bp += len;
		tlen += len;
		MFREE(m, n);
	}
	return (tlen);
}

/*
 * Pull data off an interface.
 * Len is length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present
 * we copy into clusters.
 */
struct mbuf *
hme_get(sc, ri, totlen)
	struct hme_softc *sc;
	int ri, totlen;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m, *m0, *newm;
	caddr_t bp;
	int len;

	MGETHDR(m0, M_DONTWAIT, MT_DATA);
	if (m0 == 0)
		return (0);
	m0->m_pkthdr.rcvif = ifp;
	m0->m_pkthdr.len = totlen;
	len = MHLEN;
	m = m0;

	bp = sc->sc_rb.rb_rxbuf + (ri % sc->sc_rb.rb_nrbuf) * _HME_BUFSZ;

	while (totlen > 0) {
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0)
				goto bad;
			len = MCLBYTES;
		}

		if (m == m0) {
			caddr_t newdata = (caddr_t)
			    ALIGN(m->m_data + sizeof(struct ether_header)) -
			    sizeof(struct ether_header);
			len -= newdata - m->m_data;
			m->m_data = newdata;
		}

		m->m_len = len = min(totlen, len);
		memcpy(mtod(m, caddr_t), bp, len);
		bp += len;

		totlen -= len;
		if (totlen > 0) {
			MGET(newm, M_DONTWAIT, MT_DATA);
			if (newm == 0)
				goto bad;
			len = MLEN;
			m = m->m_next = newm;
		}
	}

	return (m0);

bad:
	m_freem(m0);
	return (0);
}

/*
 * Pass a packet to the higher levels.
 */
void
hme_read(sc, ix, len)
	struct hme_softc *sc;
	int ix, len;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    (len > HME_MTU)) {
#ifdef HMEDEBUG
		printf("%s: invalid packet size %d; dropping\n",
		    sc->sc_dev.dv_xname, len);
#endif
		ifp->if_ierrors++;
		return;
	}

	/* Pull packet off interface. */
	m = hme_get(sc, ix, len);
	if (m == 0) {
		ifp->if_ierrors++;
		return;
	}

	ifp->if_ipackets++;

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m);
#endif

	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
}

d597 1
a597 1
	bix = sc->sc_rb.rb_tdhead;
d623 1
a623 1
	sc->sc_rb.rb_tdhead = bix;
d658 1
a658 1
	ri = sc->sc_rb.rb_tdtail;
d686 1
a686 1
		if (++ri == sc->sc_rb.rb_ntbuf) {
d696 1
a696 1
	sc->sc_rb.rb_tdtail = ri;
d719 1
a719 1
	ri = sc->sc_rb.rb_rdtail;
d763 1
a763 1
		    HME_XD_OWN | HME_XD_ENCODE_RSIZE(_HME_BUFSZ));
d765 1
a765 1
		if (++ri == sc->sc_rb.rb_nrbuf) {
d772 1
a772 1
	sc->sc_rb.rb_rdtail = ri;
d1231 1
a1231 1
		if ((sc->sc_rb.rb_ntbuf - (sc->sc_tx_cnt + cnt)) < 5)
d1264 1
a1264 1
		if (++frag == sc->sc_rb.rb_ntbuf) {
d1297 1
a1297 1
			frag = sc->sc_rb.rb_ntbuf - 1;
@


1.6
log
@solve mtu problem a little more elegantly (ramdisk works on blade100 and
u5 now).
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.5 2001/09/20 17:58:33 jason Exp $	*/
d98 2
d111 2
a186 1
#define _HME_NDESC	32
d373 15
d450 1
a450 1
		HME_XD_SETADDR(sc->sc_pci, hr->rb_txd, i, txbufdma + i * _HME_BUFSZ);
d452 2
d460 7
a466 1
		HME_XD_SETADDR(sc->sc_pci, hr->rb_rxd, i, rxbufdma + i * _HME_BUFSZ);
d468 1
a468 1
				HME_XD_OWN | HME_XD_ENCODE_RSIZE(_HME_BUFSZ));
d472 1
a472 1
	hr->rb_td_nbusy = 0;
d614 1
a614 1
	v |= HME_ERX_CFG_DMAENABLE;
a791 1
	caddr_t txd = sc->sc_rb.rb_txd;
d793 1
a793 2
	unsigned int ri, len;
	unsigned int ntbuf = sc->sc_rb.rb_ntbuf;
d798 4
a801 5
	ri = sc->sc_rb.rb_tdhead;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == 0)
d813 4
a816 4
		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		len = hme_put(sc, ri, m);
d818 1
a818 6
		/*
		 * Initialize transmit registers and start transmission
		 */
		HME_XD_SETFLAGS(sc->sc_pci, txd, ri,
			HME_XD_OWN | HME_XD_SOP | HME_XD_EOP |
			HME_XD_ENCODE_TSIZE(len));
a819 1
		/*if (sc->sc_rb.rb_td_nbusy <= 0)*/
a821 8

		if (++ri == ntbuf)
			ri = 0;

		if (++sc->sc_rb.rb_td_nbusy == ntbuf) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}
d824 2
a825 1
	sc->sc_rb.rb_tdhead = ri;
d839 1
d860 1
d863 1
a863 1
		if (sc->sc_rb.rb_td_nbusy <= 0)
d872 2
a873 1
		ifp->if_opackets++;
d875 13
a887 1
		if (++ri == sc->sc_rb.rb_ntbuf)
d889 3
d893 1
a893 1
		--sc->sc_rb.rb_td_nbusy;
d901 1
a901 1
	if (sc->sc_rb.rb_td_nbusy == 0)
d914 3
a916 2
	caddr_t xdr = sc->sc_rb.rb_rxd;
	unsigned int nrbuf = sc->sc_rb.rb_nrbuf;
d921 1
d927 1
a927 1
		flags = HME_XD_GETFLAGS(sc->sc_pci, xdr, ri);
d934 1
a934 3
		} else {
			len = HME_XD_DECODE_RSIZE(flags);
			hme_read(sc, ri, len);
d937 19
a955 3
		/* This buffer can be used by the hardware again */
		HME_XD_SETFLAGS(sc->sc_pci, xdr, ri,
				HME_XD_OWN | HME_XD_ENCODE_RSIZE(_HME_BUFSZ));
d957 10
a966 1
		if (++ri == nrbuf)
d968 3
a973 1

d1407 153
@


1.5
log
@undef HMEDEBUG by default, and maximum rx/tx size is
ETHERMTU + sizeof(struct ether_header) not ETHERMTU
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.4 2001/08/29 05:33:10 jason Exp $	*/
a86 3
#include <dev/ic/hmereg.h>
#include <dev/ic/hmevar.h>

d91 3
d498 1
a498 6
	v = ETHERMTU + sizeof(struct ether_header) +
#if NVLAN > 0
	    EVL_ENCAPLEN +
#endif
	    0;
	bus_space_write_4(t, mac, HME_MACI_TXSIZE, v);
d525 1
a525 6
	v = ETHERMTU + sizeof(struct ether_header) +
#if NVLAN > 0
	    EVL_ENCAPLEN +
#endif
	    0;
	bus_space_write_4(t, mac, HME_MACI_RXSIZE, v);
d730 1
a730 6
	    (len > ETHERMTU + sizeof(struct ether_header) +
#if NVLAN > 1
		EVL_ENCAPLEN +
#endif
		0
	    )) {
@


1.4
log
@initialize ac_enaddr from sc_enaddr
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.3 2001/08/23 05:27:01 jason Exp $	*/
d47 1
a47 1
#define HMEDEBUG
d498 1
a498 1
	v = ETHERMTU +
d530 1
a530 1
	v = ETHERMTU +
d740 1
a740 1
	    (len > ETHERMTU +
@


1.3
log
@decruftify: remove unnecessary/unused functions
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.2 2001/08/23 05:12:59 jason Exp $	*/
d165 2
@


1.2
log
@need bpfilter.h
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.1 2001/08/21 16:16:50 jason Exp $	*/
a124 8
static int	ether_cmp __P((u_char *, u_char *));

/* Default buffer copy routines */
void	hme_copytobuf_contig __P((struct hme_softc *, void *, int, int));
void	hme_copyfrombuf_contig __P((struct hme_softc *, void *, int, int));
void	hme_zerobuf_contig __P((struct hme_softc *, int, int));


a633 16
 * Compare two Ether/802 addresses for equality, inlined and unrolled for
 * speed.
 */
static __inline__ int
ether_cmp(a, b)
	u_char *a, *b;
{       
        
	if (a[5] != b[5] || a[4] != b[4] || a[3] != b[3] ||
	    a[2] != b[2] || a[1] != b[1] || a[0] != b[0])
		return (0);
	return (1);
}


/*
d1316 1
a1316 1
		if (ether_cmp(enm->enm_addrlo, enm->enm_addrhi)) {
a1365 46

/*
 * Routines for accessing the transmit and receive buffers.
 * The various CPU and adapter configurations supported by this
 * driver require three different access methods for buffers
 * and descriptors:
 *	(1) contig (contiguous data; no padding),
 *	(2) gap2 (two bytes of data followed by two bytes of padding),
 *	(3) gap16 (16 bytes of data followed by 16 bytes of padding).
 */

#if 0
/*
 * contig: contiguous data with no padding.
 *
 * Buffers may have any alignment.
 */

void
hme_copytobuf_contig(sc, from, ri, len)
	struct hme_softc *sc;
	void *from;
	int ri, len;
{
	volatile caddr_t buf = sc->sc_rb.rb_txbuf + (ri * _HME_BUFSZ);

	/*
	 * Just call memcpy() to do the work.
	 */
	memcpy(buf, from, len);
}

void
hme_copyfrombuf_contig(sc, to, boff, len)
	struct hme_softc *sc;
	void *to;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_rb.rb_rxbuf + (ri * _HME_BUFSZ);

	/*
	 * Just call memcpy() to do the work.
	 */
	memcpy(to, buf, len);
}
#endif
@


1.1
log
@bus independent part of hme driver from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
@

