head	1.71;
access;
symbols
	OPENBSD_6_2_BASE:1.71
	OPENBSD_6_1:1.71.0.8
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.71.0.6
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.70.0.4
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.66.0.6
	OPENBSD_5_5_BASE:1.66
	OPENBSD_5_4:1.66.0.2
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.65.0.8
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.65.0.4
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.6
	OPENBSD_5_0:1.65.0.2
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.63.0.4
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.63.0.2
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.53.0.6
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.49.0.4
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.49.0.2
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.38.0.4
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.38.0.2
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.22
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	SMP:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2;
locks; strict;
comment	@ * @;


1.71
date	2015.09.09.18.24.26;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	A1u7pQEYVfdRAnFA;

1.70
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.69;
commitid	p4LJxGKbi0BU2cG6;

1.69
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.68;
commitid	LS2TNeCue5R9L67C;

1.68
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	JtO5uXxVcnZfhUkR;

1.67
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.66;
commitid	I19imNlAX05zJOED;

1.66
date	2013.05.27.21.19.31;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2011.06.23.16.31.16;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.05.22.37.39;	author dlg;	state Exp;
branches;
next	1.63;

1.63
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.06.23.32.01;	author dlg;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.02.15.10.48;	author blambert;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.03.11.37.45;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2010.04.06.01.12.17;	author dlg;	state Exp;
branches;
next	1.57;

1.57
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.26.21.26.09;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.18.05.09.43;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.18.04.47.54;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2008.08.31.17.21.57;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.07.17.41.09;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2007.08.05.19.05.09;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.08.03.16.16;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.12.21.02.44.55;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.22.22.22.11;	author martin;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.03.16.53.16;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.20.22.32.48;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.03.11.00.36;	author martin;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.10.16.27.23;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.08.19.48.42;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.12.17.36.25;	author martin;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.13.23.33.02;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.31.10.27.14;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.30.00.24.33;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.25.01.49.12;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.18.01.14.54;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.18.00.49.28;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2003.10.09.17.32.42;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.29.18.52.53;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.01.17.15.06;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.28.22.16.55;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.09.02.28.13;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.21.00.48.55;	author krw;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2002.12.23.00.42.32;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.16.04.37.29;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.16.00.53.12;	author krw;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2002.07.20.11.22.27;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.09.02.11.47;	author jsyn;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.23.13.34.38;	author pefo;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.05.17.25.58;	author art;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.10.30.00.02.55;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.26.02.20.22;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.08.01.25.06;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.26.02.39.05;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.18.02.24.02;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.04.22.55.03;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.23.14.39;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.24.22.00.01;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.24.18.28.10;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.23.13.48.42;	author krw;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.04.15.06.01.28;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.16.29.32;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.01.17.14.27;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.20.05.18.43;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.20.00.32.28;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.15.04.07.58;	author krw;	state Exp;
branches;
next	;

1.7.4.1
date	2001.05.14.22.24.11;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2001.07.04.10.41.07;	author niklas;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.7.4.6;

1.7.4.6
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.7.4.7;

1.7.4.7
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.7.4.8;

1.7.4.8
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	1.7.4.9;

1.7.4.9
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2003.05.19.21.59.43;	author tedu;	state Exp;
branches;
next	;

1.22.2.1
date	2003.01.21.15.44.49;	author jason;	state Exp;
branches;
next	;

1.25.2.1
date	2003.06.12.18.47.51;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2004.04.30.22.07.37;	author brad;	state Exp;
branches;
next	;


desc
@@


1.71
log
@sizes for free(); ok semarie
@
text
@/*	$OpenBSD: siop.c,v 1.70 2015/03/14 03:38:47 jsg Exp $ */
/*	$NetBSD: siop.c,v 1.79 2005/11/18 23:10:32 bouyer Exp $	*/

/*
 * Copyright (c) 2000 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* SYM53c7/8xx PCI-SCSI I/O Processors driver */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/endian.h>

#include <machine/bus.h>

#include <dev/microcode/siop/siop.out>

#include <scsi/scsi_all.h>
#include <scsi/scsi_message.h>
#include <scsi/scsiconf.h>

#include <dev/ic/siopreg.h>
#include <dev/ic/siopvar_common.h>
#include <dev/ic/siopvar.h>

#ifndef SIOP_DEBUG
#undef SIOP_DEBUG
#undef SIOP_DEBUG_DR
#undef SIOP_DEBUG_INTR
#undef SIOP_DEBUG_SCHED
#undef DUMP_SCRIPT
#else
#define SIOP_DEBUG_DR
#define SIOP_DEBUG_INTR
#define SIOP_DEBUG_SCHED
#define DUMP_SCRIPT
#endif


#undef SIOP_STATS

#ifndef SIOP_DEFAULT_TARGET
#define SIOP_DEFAULT_TARGET 7
#endif

/* number of cmd descriptors per block */
#define SIOP_NCMDPB (PAGE_SIZE / sizeof(struct siop_xfer))

/* Number of scheduler slot (needs to match script) */
#define SIOP_NSLOTS 40

void	siop_table_sync(struct siop_cmd *, int);
void	siop_script_sync(struct siop_softc *, int);
u_int32_t siop_script_read(struct siop_softc *, u_int);
void	siop_script_write(struct siop_softc *, u_int, u_int32_t);
void	siop_reset(struct siop_softc *);
void	siop_handle_reset(struct siop_softc *);
int	siop_handle_qtag_reject(struct siop_cmd *);
void	siop_scsicmd_end(struct siop_cmd *);
void	siop_start(struct siop_softc *);
void 	siop_timeout(void *);
void	siop_scsicmd(struct scsi_xfer *);
void *	siop_cmd_get(void *);
void	siop_cmd_put(void *, void *);
int	siop_scsiprobe(struct scsi_link *);
void	siop_scsifree(struct scsi_link *);
#ifdef DUMP_SCRIPT
void	siop_dump_script(struct siop_softc *);
#endif
void	siop_morecbd(struct siop_softc *);
struct siop_lunsw *siop_get_lunsw(struct siop_softc *);
void	siop_add_reselsw(struct siop_softc *, int);
void	siop_update_scntl3(struct siop_softc *, struct siop_common_target *);

struct siop_dmamem *siop_dmamem_alloc(struct siop_softc *, size_t);
void	siop_dmamem_free(struct siop_softc *, struct siop_dmamem *);

struct cfdriver siop_cd = {
	NULL, "siop", DV_DULL
};

struct scsi_adapter siop_adapter = {
	siop_scsicmd,
	siop_minphys,
	siop_scsiprobe,
	siop_scsifree
};

#ifdef SIOP_STATS
static int siop_stat_intr = 0;
static int siop_stat_intr_shortxfer = 0;
static int siop_stat_intr_sdp = 0;
static int siop_stat_intr_saveoffset = 0;
static int siop_stat_intr_done = 0;
static int siop_stat_intr_xferdisc = 0;
static int siop_stat_intr_lunresel = 0;
static int siop_stat_intr_qfull = 0;
void siop_printstats(void);
#define INCSTAT(x) x++
#else
#define INCSTAT(x)
#endif

void
siop_table_sync(siop_cmd, ops)
	struct siop_cmd *siop_cmd;
	int ops;
{
	struct siop_common_softc *sc  = siop_cmd->cmd_c.siop_sc;
	bus_addr_t offset;

	offset = siop_cmd->cmd_c.dsa -
	    SIOP_DMA_DVA(siop_cmd->siop_cbdp->xfers);
	bus_dmamap_sync(sc->sc_dmat,
	    SIOP_DMA_MAP(siop_cmd->siop_cbdp->xfers), offset,
	    sizeof(struct siop_xfer), ops);
}

void
siop_script_sync(sc, ops)
	struct siop_softc *sc;
	int ops;
{
	if ((sc->sc_c.features & SF_CHIP_RAM) == 0)
		bus_dmamap_sync(sc->sc_c.sc_dmat, sc->sc_c.sc_scriptdma, 0,
		    PAGE_SIZE, ops);
}

u_int32_t
siop_script_read(sc, offset)
	struct siop_softc *sc;
	u_int offset;
{
	if (sc->sc_c.features & SF_CHIP_RAM) {
		return bus_space_read_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
		    offset * 4);
	} else {
		return siop_ctoh32(&sc->sc_c, sc->sc_c.sc_script[offset]);
	}
}

void
siop_script_write(sc, offset, val)
	struct siop_softc *sc;
	u_int offset;
	u_int32_t val;
{
	if (sc->sc_c.features & SF_CHIP_RAM) {
		bus_space_write_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
		    offset * 4, val);
	} else {
		sc->sc_c.sc_script[offset] = siop_htoc32(&sc->sc_c, val);
	}
}

void
siop_attach(sc)
	struct siop_softc *sc;
{
	struct scsibus_attach_args saa;

	if (siop_common_attach(&sc->sc_c) != 0)
		return;

	TAILQ_INIT(&sc->free_list);
	TAILQ_INIT(&sc->ready_list);
	TAILQ_INIT(&sc->urgent_list);
	TAILQ_INIT(&sc->cmds);
	TAILQ_INIT(&sc->lunsw_list);
	scsi_iopool_init(&sc->iopool, sc, siop_cmd_get, siop_cmd_put);
	sc->sc_currschedslot = 0;
	sc->sc_c.sc_link.adapter = &siop_adapter;
	sc->sc_c.sc_link.openings = SIOP_NTAG;
	sc->sc_c.sc_link.pool = &sc->iopool;

	/* Start with one page worth of commands */
	siop_morecbd(sc);

#ifdef SIOP_DEBUG
	printf("%s: script size = %d, PHY addr=0x%x, VIRT=%p\n",
	    sc->sc_c.sc_dev.dv_xname, (int)sizeof(siop_script),
	    (u_int32_t)sc->sc_c.sc_scriptaddr, sc->sc_c.sc_script);
#endif

	/* Do a bus reset, so that devices fall back to narrow/async */
	siop_resetbus(&sc->sc_c);
	/*
	 * siop_reset() will reset the chip, thus clearing pending interrupts
	 */
	siop_reset(sc);
#ifdef DUMP_SCRIPT
	siop_dump_script(sc);
#endif

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_c.sc_link;

	config_found((struct device*)sc, &saa, scsiprint);
}

void
siop_reset(sc)
	struct siop_softc *sc;
{
	int i, j;
	struct siop_lunsw *lunsw;

	siop_common_reset(&sc->sc_c);

	/* copy and patch the script */
	if (sc->sc_c.features & SF_CHIP_RAM) {
		bus_space_write_region_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh, 0,
		    siop_script, sizeof(siop_script) / sizeof(siop_script[0]));
		for (j = 0; j <
		    (sizeof(E_abs_msgin_Used) / sizeof(E_abs_msgin_Used[0]));
		    j++) {
			bus_space_write_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
			    E_abs_msgin_Used[j] * 4,
			    sc->sc_c.sc_scriptaddr + Ent_msgin_space);
		}
		if (sc->sc_c.features & SF_CHIP_LED0) {
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    Ent_led_on1, siop_led_on,
			    sizeof(siop_led_on) / sizeof(siop_led_on[0]));
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    Ent_led_on2, siop_led_on,
			    sizeof(siop_led_on) / sizeof(siop_led_on[0]));
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    Ent_led_off, siop_led_off,
			    sizeof(siop_led_off) / sizeof(siop_led_off[0]));
		}
	} else {
		for (j = 0;
		    j < (sizeof(siop_script) / sizeof(siop_script[0])); j++) {
			sc->sc_c.sc_script[j] =
			    siop_htoc32(&sc->sc_c, siop_script[j]);
		}
		for (j = 0; j <
		    (sizeof(E_abs_msgin_Used) / sizeof(E_abs_msgin_Used[0]));
		    j++) {
			sc->sc_c.sc_script[E_abs_msgin_Used[j]] =
			    siop_htoc32(&sc->sc_c,
				sc->sc_c.sc_scriptaddr + Ent_msgin_space);
		}
		if (sc->sc_c.features & SF_CHIP_LED0) {
			for (j = 0; j < (sizeof(siop_led_on) /
			    sizeof(siop_led_on[0])); j++)
				sc->sc_c.sc_script[
				    Ent_led_on1 / sizeof(siop_led_on[0]) + j
				    ] = siop_htoc32(&sc->sc_c, siop_led_on[j]);
			for (j = 0; j < (sizeof(siop_led_on) /
			    sizeof(siop_led_on[0])); j++)
				sc->sc_c.sc_script[
				    Ent_led_on2 / sizeof(siop_led_on[0]) + j
				    ] = siop_htoc32(&sc->sc_c, siop_led_on[j]);
			for (j = 0; j < (sizeof(siop_led_off) /
			    sizeof(siop_led_off[0])); j++)
				sc->sc_c.sc_script[
				   Ent_led_off / sizeof(siop_led_off[0]) + j
				   ] = siop_htoc32(&sc->sc_c, siop_led_off[j]);
		}
	}
	sc->script_free_lo = sizeof(siop_script) / sizeof(siop_script[0]);
	sc->script_free_hi = sc->sc_c.ram_size / 4;
	sc->sc_ntargets = 0;

	/* free used and unused lun switches */
	while((lunsw = TAILQ_FIRST(&sc->lunsw_list)) != NULL) {
#ifdef SIOP_DEBUG
		printf("%s: free lunsw at offset %d\n",
				sc->sc_c.sc_dev.dv_xname, lunsw->lunsw_off);
#endif
		TAILQ_REMOVE(&sc->lunsw_list, lunsw, next);
		free(lunsw, M_DEVBUF, 0);
	}
	TAILQ_INIT(&sc->lunsw_list);
	/* restore reselect switch */
	for (i = 0; i < sc->sc_c.sc_link.adapter_buswidth; i++) {
		struct siop_target *target;
		if (sc->sc_c.targets[i] == NULL)
			continue;
#ifdef SIOP_DEBUG
		printf("%s: restore sw for target %d\n",
				sc->sc_c.sc_dev.dv_xname, i);
#endif
		target = (struct siop_target *)sc->sc_c.targets[i];
		free(target->lunsw, M_DEVBUF, 0);
		target->lunsw = siop_get_lunsw(sc);
		if (target->lunsw == NULL) {
			printf("%s: can't alloc lunsw for target %d\n",
			    sc->sc_c.sc_dev.dv_xname, i);
			break;
		}
		siop_add_reselsw(sc, i);
	}

	/* start script */
	if ((sc->sc_c.features & SF_CHIP_RAM) == 0) {
		bus_dmamap_sync(sc->sc_c.sc_dmat, sc->sc_c.sc_scriptdma, 0,
		    PAGE_SIZE, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSP,
	    sc->sc_c.sc_scriptaddr + Ent_reselect);
}

#if 0
#define CALL_SCRIPT(ent) do {\
	printf ("start script DSA 0x%lx DSP 0x%lx\n", \
	    siop_cmd->cmd_c.dsa, \
	    sc->sc_c.sc_scriptaddr + ent); \
bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSP, sc->sc_c.sc_scriptaddr + ent); \
} while (0)
#else
#define CALL_SCRIPT(ent) do {\
bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSP, sc->sc_c.sc_scriptaddr + ent); \
} while (0)
#endif

int
siop_intr(v)
	void *v;
{
	struct siop_softc *sc = v;
	struct siop_target *siop_target;
	struct siop_cmd *siop_cmd;
	struct siop_lun *siop_lun;
	struct scsi_xfer *xs;
	int istat, sist, sstat1, dstat = 0;
	u_int32_t irqcode;
	int need_reset = 0;
	int offset, target, lun, tag;
	bus_addr_t dsa;
	struct siop_cbd *cbdp;
	int restart = 0;

	istat = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_ISTAT);
	if ((istat & (ISTAT_INTF | ISTAT_DIP | ISTAT_SIP)) == 0)
		return 0;
	INCSTAT(siop_stat_intr);
	if (istat & ISTAT_INTF) {
		printf("INTRF\n");
		bus_space_write_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_ISTAT, ISTAT_INTF);
	}
	if ((istat &(ISTAT_DIP | ISTAT_SIP | ISTAT_ABRT)) ==
	    (ISTAT_DIP | ISTAT_ABRT)) {
		/* clear abort */
		bus_space_write_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_ISTAT, 0);
	}
	/* use DSA to find the current siop_cmd */
	siop_cmd = NULL;
	dsa = bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA);
	TAILQ_FOREACH(cbdp, &sc->cmds, next) {
		if (dsa >= SIOP_DMA_DVA(cbdp->xfers) &&
	    	    dsa < SIOP_DMA_DVA(cbdp->xfers) + PAGE_SIZE) {
			dsa -= SIOP_DMA_DVA(cbdp->xfers);
			siop_cmd = &cbdp->cmds[dsa / sizeof(struct siop_xfer)];
			siop_table_sync(siop_cmd,
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
			break;
		}
	}
	if (siop_cmd) {
		xs = siop_cmd->cmd_c.xs;
		siop_target = (struct siop_target *)siop_cmd->cmd_c.siop_target;
		target = siop_cmd->cmd_c.xs->sc_link->target;
		lun = siop_cmd->cmd_c.xs->sc_link->lun;
		tag = siop_cmd->cmd_c.tag;
		siop_lun = siop_target->siop_lun[lun];
#ifdef DIAGNOSTIC
		if (siop_cmd->cmd_c.status != CMDST_ACTIVE &&
		    siop_cmd->cmd_c.status != CMDST_SENSE_ACTIVE) {
 			printf("siop_cmd (lun %d) for DSA 0x%x "
			    "not active (%d)\n", lun, (u_int)dsa,
			    siop_cmd->cmd_c.status);
			xs = NULL;
			siop_target = NULL;
			target = -1;
			lun = -1;
			tag = -1;
			siop_lun = NULL;
			siop_cmd = NULL;
		} else if (siop_lun->siop_tag[tag].active != siop_cmd) {
			printf("siop_cmd (lun %d tag %d) not in siop_lun "
			    "active (%p != %p)\n", lun, tag, siop_cmd,
			    siop_lun->siop_tag[tag].active);
		}
#endif
	} else {
		xs = NULL;
		siop_target = NULL;
		target = -1;
		lun = -1;
		tag = -1;
		siop_lun = NULL;
	}
	if (istat & ISTAT_DIP) {
		dstat = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_DSTAT);
		if (dstat & DSTAT_ABRT) {
			/* was probably generated by a bus reset IOCTL */
			if ((dstat & DSTAT_DFE) == 0)
				siop_clearfifo(&sc->sc_c);
			goto reset;
		}
		if (dstat & DSTAT_SSI) {
			printf("single step dsp 0x%08x dsa 0x08%x\n",
			    (int)(bus_space_read_4(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_DSP) -
			    sc->sc_c.sc_scriptaddr),
			    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
				SIOP_DSA));
			if ((dstat & ~(DSTAT_DFE | DSTAT_SSI)) == 0 &&
			    (istat & ISTAT_SIP) == 0) {
				bus_space_write_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_DCNTL,
				    bus_space_read_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_DCNTL) | DCNTL_STD);
			}
			return 1;
		}

		if (dstat & ~(DSTAT_SIR | DSTAT_DFE | DSTAT_SSI)) {
			printf("%s: DMA IRQ:", sc->sc_c.sc_dev.dv_xname);
			if (dstat & DSTAT_IID)
				printf(" illegal instruction");
			if (dstat & DSTAT_BF)
				printf(" bus fault");
			if (dstat & DSTAT_MDPE)
				printf(" parity");
			if (dstat & DSTAT_DFE)
				printf(" DMA fifo empty");
			else
				siop_clearfifo(&sc->sc_c);
			printf(", DSP=0x%x DSA=0x%x: ",
			    (int)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
				SIOP_DSP) - sc->sc_c.sc_scriptaddr),
			    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA));
			if (siop_cmd)
				printf("last msg_in=0x%x status=0x%x\n",
				    siop_cmd->cmd_tables->msg_in[0],
				    siop_ctoh32(&sc->sc_c,
					siop_cmd->cmd_tables->status));
			else
				printf("current DSA invalid\n");
			need_reset = 1;
		}
	}
	if (istat & ISTAT_SIP) {
		if (istat & ISTAT_DIP)
			delay(10);
		/*
		 * Can't read sist0 & sist1 independently, or we have to
		 * insert delay
		 */
		sist = bus_space_read_2(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_SIST0);
		sstat1 = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_SSTAT1);
#ifdef SIOP_DEBUG_INTR
		printf("scsi interrupt, sist=0x%x sstat1=0x%x "
		    "DSA=0x%x DSP=0x%lx\n", sist, sstat1,
		    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA),
		    (u_long)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_DSP) -
		    sc->sc_c.sc_scriptaddr));
#endif
		if (sist & SIST0_RST) {
			siop_handle_reset(sc);
			siop_start(sc);
			/* no table to flush here */
			return 1;
		}
		if (sist & SIST0_SGE) {
			if (siop_cmd)
				sc_print_addr(xs->sc_link);
			else
				printf("%s: ", sc->sc_c.sc_dev.dv_xname);
			printf("scsi gross error\n");
			goto reset;
		}
		if ((sist & SIST0_MA) && need_reset == 0) {
			if (siop_cmd) {
				int scratcha0;
				/* XXX Why read DSTAT again? */
				dstat = bus_space_read_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_DSTAT);
				/*
				 * first restore DSA, in case we were in a S/G
				 * operation.
				 */
				bus_space_write_4(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh,
				    SIOP_DSA, siop_cmd->cmd_c.dsa);
				scratcha0 = bus_space_read_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_SCRATCHA);
				switch (sstat1 & SSTAT1_PHASE_MASK) {
				case SSTAT1_PHASE_STATUS:
				/*
				 * previous phase may be aborted for any reason
				 * ( for example, the target has less data to
				 * transfer than requested). Compute resid and
				 * just go to status, the command should
				 * terminate.
				 */
					INCSTAT(siop_stat_intr_shortxfer);
					if (scratcha0 & A_flag_data)
						siop_ma(&siop_cmd->cmd_c);
					else if ((dstat & DSTAT_DFE) == 0)
						siop_clearfifo(&sc->sc_c);
					CALL_SCRIPT(Ent_status);
					return 1;
				case SSTAT1_PHASE_MSGIN:
				/*
				 * target may be ready to disconnect
				 * Compute resid which would be used later
				 * if a save data pointer is needed.
				 */
					INCSTAT(siop_stat_intr_xferdisc);
					if (scratcha0 & A_flag_data)
						siop_ma(&siop_cmd->cmd_c);
					else if ((dstat & DSTAT_DFE) == 0)
						siop_clearfifo(&sc->sc_c);
					bus_space_write_1(sc->sc_c.sc_rt,
					    sc->sc_c.sc_rh, SIOP_SCRATCHA,
					    scratcha0 & ~A_flag_data);
					CALL_SCRIPT(Ent_msgin);
					return 1;
				}
				printf("%s: unexpected phase mismatch %d\n",
				    sc->sc_c.sc_dev.dv_xname,
				    sstat1 & SSTAT1_PHASE_MASK);
			} else {
				printf("%s: phase mismatch without command\n",
				    sc->sc_c.sc_dev.dv_xname);
			}
			need_reset = 1;
		}
		if (sist & SIST0_PAR) {
			/* parity error, reset */
			if (siop_cmd)
				sc_print_addr(xs->sc_link);
			else
				printf("%s: ", sc->sc_c.sc_dev.dv_xname);
			printf("parity error\n");
			goto reset;
		}
		if ((sist & (SIST1_STO << 8)) && need_reset == 0) {
			/* selection time out, assume there's no device here */
			if (siop_cmd) {
				siop_cmd->cmd_c.status = CMDST_DONE;
				xs->error = XS_SELTIMEOUT;
				goto end;
			} else {
				printf("%s: selection timeout without "
				    "command\n", sc->sc_c.sc_dev.dv_xname);
				need_reset = 1;
			}
		}
		if (sist & SIST0_UDC) {
			/*
			 * unexpected disconnect. Usually the target signals
			 * a fatal condition this way. Attempt to get sense.
			 */
			 if (siop_cmd) {
				siop_cmd->cmd_tables->status =
				    siop_htoc32(&sc->sc_c, SCSI_CHECK);
				goto end;
			}
			printf("%s: unexpected disconnect without "
			    "command\n", sc->sc_c.sc_dev.dv_xname);
			goto reset;
		}
		if (sist & (SIST1_SBMC << 8)) {
			/* SCSI bus mode change */
			if (siop_modechange(&sc->sc_c) == 0 || need_reset == 1)
				goto reset;
			if ((istat & ISTAT_DIP) && (dstat & DSTAT_SIR)) {
				/*
				 * we have a script interrupt, it will
				 * restart the script.
				 */
				goto scintr;
			}
			/*
			 * else we have to restart it ourselve, at the
			 * interrupted instruction.
			 */
			bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			    SIOP_DSP,
			    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			    SIOP_DSP) - 8);
			return 1;
		}
		/* Else it's an unhandled exception (for now). */
		printf("%s: unhandled scsi interrupt, sist=0x%x sstat1=0x%x "
		    "DSA=0x%x DSP=0x%x\n", sc->sc_c.sc_dev.dv_xname,
		    sist, sstat1,
		    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA),
		    (int)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_DSP) - sc->sc_c.sc_scriptaddr));
		if (siop_cmd) {
			siop_cmd->cmd_c.status = CMDST_DONE;
			xs->error = XS_SELTIMEOUT;
			goto end;
		}
		need_reset = 1;
	} else {
		sist = sstat1 = 0;
	}
	if (need_reset) {
reset:
		/* fatal error, reset the bus */
		siop_resetbus(&sc->sc_c);
		/* no table to flush here */
		return 1;
	}

scintr:
	if ((istat & ISTAT_DIP) && (dstat & DSTAT_SIR)) { /* script interrupt */
		irqcode = bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_DSPS);
#ifdef SIOP_DEBUG_INTR
		printf("script interrupt 0x%x\n", irqcode);
#endif
		/*
		 * no command, or an inactive command is only valid for a
		 * reselect interrupt
		 */
		if ((irqcode & 0x80) == 0) {
			if (siop_cmd == NULL) {
				printf(
			"%s: script interrupt (0x%x) with invalid DSA !!!\n",
				    sc->sc_c.sc_dev.dv_xname, irqcode);
				goto reset;
			}
			if (siop_cmd->cmd_c.status != CMDST_ACTIVE &&
			    siop_cmd->cmd_c.status != CMDST_SENSE_ACTIVE) {
				printf("%s: command with invalid status "
				    "(IRQ code 0x%x current status %d) !\n",
				    sc->sc_c.sc_dev.dv_xname,
				    irqcode, siop_cmd->cmd_c.status);
				xs = NULL;
			}
		}
		switch(irqcode) {
		case A_int_err:
			printf("error, DSP=0x%x\n",
			    (int)(bus_space_read_4(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_DSP) - sc->sc_c.sc_scriptaddr));
			if (xs) {
				xs->error = XS_SELTIMEOUT;
				goto end;
			} else {
				goto reset;
			}
		case A_int_reseltarg:
			printf("%s: reselect with invalid target\n",
				    sc->sc_c.sc_dev.dv_xname);
			goto reset;
		case A_int_resellun:
			INCSTAT(siop_stat_intr_lunresel);
			target = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SCRATCHA) & 0xf;
			lun = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			    SIOP_SCRATCHA + 1);
			tag = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			    SIOP_SCRATCHA + 2);
			siop_target =
			    (struct siop_target *)sc->sc_c.targets[target];
			if (siop_target == NULL) {
				printf("%s: reselect with invalid target %d\n",
				    sc->sc_c.sc_dev.dv_xname, target);
				goto reset;
			}
			siop_lun = siop_target->siop_lun[lun];
			if (siop_lun == NULL) {
				printf("%s: target %d reselect with invalid "
				    "lun %d\n", sc->sc_c.sc_dev.dv_xname,
				    target, lun);
				goto reset;
			}
			if (siop_lun->siop_tag[tag].active == NULL) {
				printf("%s: target %d lun %d tag %d reselect "
				    "without command\n",
				    sc->sc_c.sc_dev.dv_xname,
				    target, lun, tag);
				goto reset;
			}
			siop_cmd = siop_lun->siop_tag[tag].active;
			bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			    SIOP_DSP, siop_cmd->cmd_c.dsa +
			    sizeof(struct siop_common_xfer) +
			    Ent_ldsa_reload_dsa);
			siop_table_sync(siop_cmd, BUS_DMASYNC_PREWRITE);
			return 1;
		case A_int_reseltag:
			printf("%s: reselect with invalid tag\n",
				    sc->sc_c.sc_dev.dv_xname);
			goto reset;
		case A_int_msgin:
		{
			int msgin = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SFBR);
			if (msgin == MSG_MESSAGE_REJECT) {
				int msg, extmsg;
				if (siop_cmd->cmd_tables->msg_out[0] & 0x80) {
					/*
					 * message was part of a identify +
					 * something else. Identify shouldn't
					 * have been rejected.
					 */
					msg =
					    siop_cmd->cmd_tables->msg_out[1];
					extmsg =
					    siop_cmd->cmd_tables->msg_out[3];
				} else {
					msg = siop_cmd->cmd_tables->msg_out[0];
					extmsg =
					    siop_cmd->cmd_tables->msg_out[2];
				}
				if (msg == MSG_MESSAGE_REJECT) {
					/* MSG_REJECT  for a MSG_REJECT  !*/
					if (xs)
						sc_print_addr(xs->sc_link);
					else
						printf("%s: ",
						   sc->sc_c.sc_dev.dv_xname);
					printf("our reject message was "
					    "rejected\n");
					goto reset;
				}
				if (msg == MSG_EXTENDED &&
				    extmsg == MSG_EXT_WDTR) {
					/* WDTR rejected, initiate sync */
					if ((siop_target->target_c.flags &
					   TARF_SYNC) == 0) {
						siop_target->target_c.status =
						    TARST_OK;
						siop_update_xfer_mode(&sc->sc_c,
						    target);
						/* no table to flush here */
						CALL_SCRIPT(Ent_msgin_ack);
						return 1;
					}
					siop_target->target_c.status =
					    TARST_SYNC_NEG;
					siop_sdtr_msg(&siop_cmd->cmd_c, 0,
					    sc->sc_c.st_minsync,
					    sc->sc_c.maxoff);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return 1;
				} else if (msg == MSG_EXTENDED &&
				    extmsg == MSG_EXT_SDTR) {
					/* sync rejected */
					siop_target->target_c.offset = 0;
					siop_target->target_c.period = 0;
					siop_target->target_c.status = TARST_OK;
					siop_update_xfer_mode(&sc->sc_c,
					    target);
					/* no table to flush here */
					CALL_SCRIPT(Ent_msgin_ack);
					return 1;
				} else if (msg == MSG_EXTENDED &&
				    extmsg == MSG_EXT_PPR) {
					/* PPR negotiation rejected */
					siop_target->target_c.offset = 0;
					siop_target->target_c.period = 0;
					siop_target->target_c.status = TARST_ASYNC;
					siop_target->target_c.flags &= ~(TARF_DT | TARF_ISDT);
					CALL_SCRIPT(Ent_msgin_ack);
					return 1;
				} else if (msg == MSG_SIMPLE_Q_TAG ||
				    msg == MSG_HEAD_OF_Q_TAG ||
				    msg == MSG_ORDERED_Q_TAG) {
					if (siop_handle_qtag_reject(
					    siop_cmd) == -1)
						goto reset;
					CALL_SCRIPT(Ent_msgin_ack);
					return 1;
				}
				if (xs)
					sc_print_addr(xs->sc_link);
				else
					printf("%s: ",
					    sc->sc_c.sc_dev.dv_xname);
				if (msg == MSG_EXTENDED) {
					printf("scsi message reject, extended "
					    "message sent was 0x%x\n", extmsg);
				} else {
					printf("scsi message reject, message "
					    "sent was 0x%x\n", msg);
				}
				/* no table to flush here */
				CALL_SCRIPT(Ent_msgin_ack);
				return 1;
			}
			if (msgin == MSG_IGN_WIDE_RESIDUE) {
			/* use the extmsgdata table to get the second byte */
				siop_cmd->cmd_tables->t_extmsgdata.count =
				    siop_htoc32(&sc->sc_c, 1);
				siop_table_sync(siop_cmd,
				    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
				CALL_SCRIPT(Ent_get_extmsgdata);
				return 1;
			}
			if (xs)
				sc_print_addr(xs->sc_link);
			else
				printf("%s: ", sc->sc_c.sc_dev.dv_xname);
			printf("unhandled message 0x%x\n",
			    siop_cmd->cmd_tables->msg_in[0]);
			siop_cmd->cmd_tables->msg_out[0] = MSG_MESSAGE_REJECT;
			siop_cmd->cmd_tables->t_msgout.count =
			    siop_htoc32(&sc->sc_c, 1);
			siop_table_sync(siop_cmd,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			CALL_SCRIPT(Ent_send_msgout);
			return 1;
		}
		case A_int_extmsgin:
#ifdef SIOP_DEBUG_INTR
			printf("extended message: msg 0x%x len %d\n",
			    siop_cmd->cmd_tables->msg_in[2],
			    siop_cmd->cmd_tables->msg_in[1]);
#endif
			if (siop_cmd->cmd_tables->msg_in[1] >
			    sizeof(siop_cmd->cmd_tables->msg_in) - 2)
				printf("%s: extended message too big (%d)\n",
				    sc->sc_c.sc_dev.dv_xname,
				    siop_cmd->cmd_tables->msg_in[1]);
			siop_cmd->cmd_tables->t_extmsgdata.count =
			    siop_htoc32(&sc->sc_c,
			        siop_cmd->cmd_tables->msg_in[1] - 1);
			siop_table_sync(siop_cmd,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			CALL_SCRIPT(Ent_get_extmsgdata);
			return 1;
		case A_int_extmsgdata:
#ifdef SIOP_DEBUG_INTR
			{
			int i;
			printf("extended message: 0x%x, data:",
			    siop_cmd->cmd_tables->msg_in[2]);
			for (i = 3; i < 2 + siop_cmd->cmd_tables->msg_in[1];
			    i++)
				printf(" 0x%x",
				    siop_cmd->cmd_tables->msg_in[i]);
			printf("\n");
			}
#endif
			if (siop_cmd->cmd_tables->msg_in[0] ==
			    MSG_IGN_WIDE_RESIDUE) {
			/* we got the second byte of MSG_IGN_WIDE_RESIDUE */
				if (siop_cmd->cmd_tables->msg_in[3] != 1)
					printf("MSG_IGN_WIDE_RESIDUE: "
					    "bad len %d\n",
					    siop_cmd->cmd_tables->msg_in[3]);
				switch (siop_iwr(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_iwr()");
				}
				return(1);
			}
			if (siop_cmd->cmd_tables->msg_in[2] == MSG_EXT_WDTR) {
				switch (siop_wdtr_neg(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
			}
			if (siop_cmd->cmd_tables->msg_in[2] == MSG_EXT_SDTR) {
				switch (siop_sdtr_neg(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_sdtr_neg()");
				}
				return(1);
			}
			if (siop_cmd->cmd_tables->msg_in[2] == MSG_EXT_PPR) {
				switch (siop_ppr_neg(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
			}
			/* send a message reject */
			siop_cmd->cmd_tables->msg_out[0] = MSG_MESSAGE_REJECT;
			siop_cmd->cmd_tables->t_msgout.count =
			    siop_htoc32(&sc->sc_c, 1);
			siop_table_sync(siop_cmd,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			CALL_SCRIPT(Ent_send_msgout);
			return 1;
		case A_int_disc:
			INCSTAT(siop_stat_intr_sdp);
			offset = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SCRATCHA + 1);
#ifdef SIOP_DEBUG_DR
			printf("disconnect offset %d\n", offset);
#endif
			siop_sdp(&siop_cmd->cmd_c, offset);
			/* we start again with no offset */
			siop_cmd->saved_offset = SIOP_NOOFFSET;
			siop_table_sync(siop_cmd,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			CALL_SCRIPT(Ent_script_sched);
			return 1;
		case A_int_saveoffset:
			INCSTAT(siop_stat_intr_saveoffset);
			offset = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SCRATCHA + 1);
#ifdef SIOP_DEBUG_DR
			printf("saveoffset offset %d\n", offset);
#endif
			siop_cmd->saved_offset = offset;
			CALL_SCRIPT(Ent_script_sched);
			return 1;
		case A_int_resfail:
			printf("reselect failed\n");
			/* check if we can put some command in scheduler */
			siop_start(sc);
			CALL_SCRIPT(Ent_script_sched);
			return  1;
		case A_int_done:
			if (xs == NULL) {
				printf("%s: done without command, DSA=0x%lx\n",
				    sc->sc_c.sc_dev.dv_xname,
				    (u_long)siop_cmd->cmd_c.dsa);
				siop_cmd->cmd_c.status = CMDST_FREE;
				siop_start(sc);
				CALL_SCRIPT(Ent_script_sched);
				return 1;
			}
#ifdef SIOP_DEBUG_INTR
			printf("done, DSA=0x%lx target id 0x%x last msg "
			    "in=0x%x status=0x%x\n", (u_long)siop_cmd->cmd_c.dsa,
			    siop_ctoh32(&sc->sc_c, siop_cmd->cmd_tables->id),
			    siop_cmd->cmd_tables->msg_in[0],
			    siop_ctoh32(&sc->sc_c,
				siop_cmd->cmd_tables->status));
#endif
			INCSTAT(siop_stat_intr_done);
			/* update resid.  */
			offset = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SCRATCHA + 1);
			/*
			 * if we got a disconnect between the last data phase
			 * and the status phase, offset will be 0. In this
			 * case, siop_cmd->saved_offset will have the proper
			 * value if it got updated by the controller
			 */
			if (offset == 0 && 
			    siop_cmd->saved_offset != SIOP_NOOFFSET)
				offset = siop_cmd->saved_offset;
			siop_update_resid(&siop_cmd->cmd_c, offset);
			if (siop_cmd->cmd_c.status == CMDST_SENSE_ACTIVE)
				siop_cmd->cmd_c.status = CMDST_SENSE_DONE;
			else
				siop_cmd->cmd_c.status = CMDST_DONE;
			goto end;
		default:
			printf("unknown irqcode %x\n", irqcode);
			if (xs) {
				xs->error = XS_SELTIMEOUT;
				goto end;
			}
			goto reset;
		}
		return 1;
	} else
		irqcode = 0;
	/* We can get here if ISTAT_DIP and DSTAT_DFE are the only bits set. */
	/* But that *SHOULDN'T* happen. It does on powerpc (at least).	     */
	printf("%s: siop_intr() - we should not be here!\n"
	    "   istat = 0x%x, dstat = 0x%x, sist = 0x%x, sstat1 = 0x%x\n"
	    "   need_reset = %x, irqcode = %x, siop_cmd %s\n",
	    sc->sc_c.sc_dev.dv_xname,
	    istat, dstat, sist, sstat1, need_reset, irqcode,
	    (siop_cmd == NULL) ? "== NULL" : "!= NULL");
	goto reset; /* Where we should have gone in the first place! */
end:
	/*
	 * restart the script now if command completed properly
	 * Otherwise wait for siop_scsicmd_end(), we may need to cleanup the
	 * queue
	 */
	xs->status = siop_ctoh32(&sc->sc_c, siop_cmd->cmd_tables->status);
	if (xs->status == SCSI_OK)
		CALL_SCRIPT(Ent_script_sched);
	else
		restart = 1;
	siop_lun->siop_tag[tag].active = NULL;
	siop_scsicmd_end(siop_cmd);
	siop_start(sc);
	if (restart)
		CALL_SCRIPT(Ent_script_sched);
	return 1;
}

void
siop_scsicmd_end(siop_cmd)
	struct siop_cmd *siop_cmd;
{
	struct scsi_xfer *xs = siop_cmd->cmd_c.xs;
	struct siop_softc *sc = (struct siop_softc *)siop_cmd->cmd_c.siop_sc;
	struct siop_lun *siop_lun =
	    ((struct siop_target*)sc->sc_c.targets[xs->sc_link->target])->siop_lun[xs->sc_link->lun];

	/*
	 * If the command is re-queued (SENSE, QUEUE_FULL) it
	 * must get a new timeout, so delete existing timeout now.
	 */
	timeout_del(&siop_cmd->cmd_c.xs->stimeout);

	switch(xs->status) {
	case SCSI_OK:
		xs->error = (siop_cmd->cmd_c.status == CMDST_DONE) ?
		    XS_NOERROR : XS_SENSE;
		break;
	case SCSI_BUSY:
		xs->error = XS_BUSY;
		break;
	case SCSI_CHECK:
		if (siop_cmd->cmd_c.status == CMDST_SENSE_DONE) {
			/* request sense on a request sense ? */
			printf("%s: request sense failed\n",
			    sc->sc_c.sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
		} else {
			siop_cmd->cmd_c.status = CMDST_SENSE;
		}
		break;
	case SCSI_QUEUE_FULL:
		/*
		 * Device didn't queue the command. We have to retry
		 * it.  We insert it into the urgent list, hoping to
		 * preserve order.  But unfortunately, commands already
		 * in the scheduler may be accepted before this one.
		 * Also remember the condition, to avoid starting new
		 * commands for this device before one is done.
		 */
		INCSTAT(siop_stat_intr_qfull);
#ifdef SIOP_DEBUG
		printf("%s:%d:%d: queue full (tag %d)\n", sc->sc_c.sc_dev.dv_xname,
		    xs->sc_link->target,
		    xs->sc_link->lun, siop_cmd->cmd_c.tag);
#endif
		siop_lun->lun_flags |= SIOP_LUNF_FULL;
		siop_cmd->cmd_c.status = CMDST_READY;
		siop_setuptables(&siop_cmd->cmd_c);
		siop_table_sync(siop_cmd, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		TAILQ_INSERT_TAIL(&sc->urgent_list, siop_cmd, next);
		return;
	case SCSI_SIOP_NOCHECK:
		/*
		 * don't check status, xs->error is already valid
		 */
		break;
	case SCSI_SIOP_NOSTATUS:
		/*
		 * the status byte was not updated, cmd was
		 * aborted
		 */
		xs->error = XS_SELTIMEOUT;
		break;
	default:
		xs->error = XS_DRIVER_STUFFUP;
	}
	if (siop_cmd->cmd_c.status != CMDST_SENSE_DONE &&
	    xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data, 0,
		    siop_cmd->cmd_c.dmamap_data->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data);
	}
	if (siop_cmd->cmd_c.status == CMDST_SENSE) {
		/* issue a request sense for this target */
		struct scsi_sense *cmd = (struct scsi_sense *)&siop_cmd->cmd_c.siop_tables->xscmd;
		int error;
		bzero(cmd, sizeof(*cmd));
		siop_cmd->cmd_c.siop_tables->cmd.count =
		   siop_htoc32(&sc->sc_c, sizeof(struct scsi_sense));
		cmd->opcode = REQUEST_SENSE;
		cmd->byte2 = xs->sc_link->lun << 5;
		cmd->unused[0] = cmd->unused[1] = 0;
		cmd->length = sizeof(struct scsi_sense_data);
		cmd->control = 0;
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
		error = bus_dmamap_load(sc->sc_c.sc_dmat,
		    siop_cmd->cmd_c.dmamap_data,
		    siop_cmd->cmd_c.sense, sizeof(struct scsi_sense_data),
		    NULL, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to load data DMA map "
			    "(for SENSE): %d\n",
			    sc->sc_c.sc_dev.dv_xname, error);
			xs->error = XS_DRIVER_STUFFUP;
			goto out;
		}
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data,
		    0, siop_cmd->cmd_c.dmamap_data->dm_mapsize,
		    BUS_DMASYNC_PREREAD);

		siop_setuptables(&siop_cmd->cmd_c);
		siop_table_sync(siop_cmd, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		/* arrange for the cmd to be handled now */
		TAILQ_INSERT_HEAD(&sc->urgent_list, siop_cmd, next);
		return;
	} else if (siop_cmd->cmd_c.status == CMDST_SENSE_DONE) {
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data,
		    0, siop_cmd->cmd_c.dmamap_data->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data);
		bcopy(siop_cmd->cmd_c.sense, &xs->sense, sizeof(xs->sense));
	}
out:
	siop_lun->lun_flags &= ~SIOP_LUNF_FULL;
#if 0
	if (xs->resid != 0)
		printf("resid %d datalen %d\n", xs->resid, xs->datalen);
#endif
	scsi_done(xs);
}

/*
 * handle a rejected queue tag message: the command will run untagged,
 * has to adjust the reselect script.
 */
int
siop_handle_qtag_reject(siop_cmd)
	struct siop_cmd *siop_cmd;
{
	struct siop_softc *sc = (struct siop_softc *)siop_cmd->cmd_c.siop_sc;
	int target = siop_cmd->cmd_c.xs->sc_link->target;
	int lun = siop_cmd->cmd_c.xs->sc_link->lun;
	int tag = siop_cmd->cmd_tables->msg_out[2];
	struct siop_lun *siop_lun =
	    ((struct siop_target*)sc->sc_c.targets[target])->siop_lun[lun];

#ifdef SIOP_DEBUG
	printf("%s:%d:%d: tag message %d (%d) rejected (status %d)\n",
	    sc->sc_c.sc_dev.dv_xname, target, lun, tag, siop_cmd->cmd_c.tag,
	    siop_cmd->cmd_c.status);
#endif

	if (siop_lun->siop_tag[0].active != NULL) {
		printf("%s: untagged command already running for target %d "
		    "lun %d (status %d)\n", sc->sc_c.sc_dev.dv_xname,
		    target, lun, siop_lun->siop_tag[0].active->cmd_c.status);
		return -1;
	}
	/* clear tag slot */
	siop_lun->siop_tag[tag].active = NULL;
	/* add command to non-tagged slot */
	siop_lun->siop_tag[0].active = siop_cmd;
	siop_cmd->cmd_c.tag = 0;
	/* adjust reselect script if there is one */
	if (siop_lun->siop_tag[0].reseloff > 0) {
		siop_script_write(sc,
		    siop_lun->siop_tag[0].reseloff + 1,
		    siop_cmd->cmd_c.dsa + sizeof(struct siop_common_xfer) +
		    Ent_ldsa_reload_dsa);
		siop_table_sync(siop_cmd, BUS_DMASYNC_PREWRITE);
	}
	return 0;
}

/*
 * handle a bus reset: reset chip, unqueue all active commands, free all
 * target struct and report lossage to upper layer.
 * As the upper layer may requeue immediately we have to first store
 * all active commands in a temporary queue.
 */
void
siop_handle_reset(sc)
	struct siop_softc *sc;
{
	struct cmd_list reset_list;
	struct siop_cmd *siop_cmd, *next_siop_cmd;
	struct siop_lun *siop_lun;
	int target, lun, tag;
	/*
	 * scsi bus reset. reset the chip and restart
	 * the queue. Need to clean up all active commands
	 */
	printf("%s: scsi bus reset\n", sc->sc_c.sc_dev.dv_xname);
	/* stop, reset and restart the chip */
	siop_reset(sc);
	TAILQ_INIT(&reset_list);
	/*
	 * Process all commands: first commands being executed
	 */
	for (target = 0; target < sc->sc_c.sc_link.adapter_buswidth;
	    target++) {
		if (sc->sc_c.targets[target] == NULL)
			continue;
		for (lun = 0; lun < 8; lun++) {
			struct siop_target *siop_target =
			    (struct siop_target *)sc->sc_c.targets[target];
			siop_lun = siop_target->siop_lun[lun];
			if (siop_lun == NULL)
				continue;
			siop_lun->lun_flags &= ~SIOP_LUNF_FULL;
			for (tag = 0; tag <
			    ((sc->sc_c.targets[target]->flags & TARF_TAG) ?
			    SIOP_NTAG : 1);
			    tag++) {
				siop_cmd = siop_lun->siop_tag[tag].active;
				if (siop_cmd == NULL)
					continue;
				siop_lun->siop_tag[tag].active = NULL;
				TAILQ_INSERT_TAIL(&reset_list, siop_cmd, next);
				sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
				printf("cmd %p (tag %d) added to reset list\n",
				    siop_cmd, tag);
			}
		}
		if (sc->sc_c.targets[target]->status != TARST_PROBING) {
			sc->sc_c.targets[target]->status = TARST_ASYNC;
			sc->sc_c.targets[target]->flags &= ~TARF_ISWIDE;
			sc->sc_c.targets[target]->period =
			    sc->sc_c.targets[target]->offset = 0;
			siop_update_xfer_mode(&sc->sc_c, target);
		}
	}
	/* Next commands from the urgent list */
	for (siop_cmd = TAILQ_FIRST(&sc->urgent_list); siop_cmd != NULL;
	    siop_cmd = next_siop_cmd) {
		next_siop_cmd = TAILQ_NEXT(siop_cmd, next);
		TAILQ_REMOVE(&sc->urgent_list, siop_cmd, next);
		TAILQ_INSERT_TAIL(&reset_list, siop_cmd, next);
		sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
		printf("cmd %p added to reset list from urgent list\n",
		    siop_cmd);
	}
	/* Then commands waiting in the input list. */
	for (siop_cmd = TAILQ_FIRST(&sc->ready_list); siop_cmd != NULL;
	    siop_cmd = next_siop_cmd) {
		next_siop_cmd = TAILQ_NEXT(siop_cmd, next);
		TAILQ_REMOVE(&sc->ready_list, siop_cmd, next);
		TAILQ_INSERT_TAIL(&reset_list, siop_cmd, next);
		sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
		printf("cmd %p added to reset list from ready list\n",
		    siop_cmd);
	}

	for (siop_cmd = TAILQ_FIRST(&reset_list); siop_cmd != NULL;
	    siop_cmd = next_siop_cmd) {
		next_siop_cmd = TAILQ_NEXT(siop_cmd, next);
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
		siop_cmd->cmd_c.xs->error =
		    (siop_cmd->cmd_c.flags & CMDFL_TIMEOUT)
		    ? XS_TIMEOUT : XS_RESET;
		siop_cmd->cmd_c.xs->status = SCSI_SIOP_NOCHECK;
		sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
		printf("cmd %p (status %d) reset",
		    siop_cmd, siop_cmd->cmd_c.status);
		if (siop_cmd->cmd_c.status == CMDST_SENSE ||
		    siop_cmd->cmd_c.status == CMDST_SENSE_ACTIVE) 
			siop_cmd->cmd_c.status = CMDST_SENSE_DONE;
		else
			siop_cmd->cmd_c.status = CMDST_DONE;
		printf(" with status %d, xs->error %d\n",
		    siop_cmd->cmd_c.status, siop_cmd->cmd_c.xs->error);
		TAILQ_REMOVE(&reset_list, siop_cmd, next);
		siop_scsicmd_end(siop_cmd);
	}
}

void *
siop_cmd_get(void *cookie)
{
	struct siop_softc *sc = cookie;
	struct siop_cmd *siop_cmd;
	int s;

	/* Look if a ccb is available. */
	s = splbio();
	siop_cmd = TAILQ_FIRST(&sc->free_list);
	if (siop_cmd != NULL) {
		TAILQ_REMOVE(&sc->free_list, siop_cmd, next);
#ifdef DIAGNOSTIC
		if (siop_cmd->cmd_c.status != CMDST_FREE)
			panic("siop_scsicmd: new cmd not free");
#endif
		siop_cmd->cmd_c.status = CMDST_READY;
	}
	splx(s);

	return (siop_cmd);
}

void
siop_cmd_put(void *cookie, void *io)
{
	struct siop_softc *sc = cookie;
	struct siop_cmd *siop_cmd = io;
	int s;

	s = splbio();
	siop_cmd->cmd_c.status = CMDST_FREE;
	TAILQ_INSERT_TAIL(&sc->free_list, siop_cmd, next);
	splx(s);
}

int
siop_scsiprobe(struct scsi_link *link)
{
	struct siop_softc *sc = (struct siop_softc *)link->adapter_softc;
	struct siop_target *siop_target;
	const int target = link->target;
	const int lun = link->lun;
	int i;

#ifdef SIOP_DEBUG
	printf("%s:%d:%d: probe\n",
	    sc->sc_c.sc_dev.dv_xname, target, lun);
#endif

	/* XXX locking */

	siop_target = (struct siop_target*)sc->sc_c.targets[target];
	if (siop_target == NULL) {
		siop_target = malloc(sizeof(*siop_target), M_DEVBUF,
		    M_WAITOK | M_CANFAIL | M_ZERO);
		if (siop_target == NULL) {
			printf("%s: can't malloc memory for target %d\n",
			    sc->sc_c.sc_dev.dv_xname, target);
			return (ENOMEM);
		}

		siop_target->target_c.status = TARST_PROBING;
		siop_target->target_c.flags  = 0;
		siop_target->target_c.id =
		    sc->sc_c.clock_div << 24; /* scntl3 */
		siop_target->target_c.id |=  target << 16; /* id */
		/* siop_target->target_c.id |= 0x0 << 8; scxfer is 0 */

		/* get a lun switch script */
		siop_target->lunsw = siop_get_lunsw(sc);
		if (siop_target->lunsw == NULL) {
			printf("%s: can't alloc lunsw for target %d\n",
			    sc->sc_c.sc_dev.dv_xname, target);
			free(siop_target, M_DEVBUF, sizeof *siop_target);
			return (ENOMEM);
		}
		for (i = 0; i < 8; i++)
			siop_target->siop_lun[i] = NULL;

		sc->sc_c.targets[target] =
		    (struct siop_common_target *)siop_target;

		siop_add_reselsw(sc, target);
	}

	if (siop_target->siop_lun[lun] == NULL) {
		siop_target->siop_lun[lun] =
		    malloc(sizeof(struct siop_lun), M_DEVBUF,
		    M_WAITOK | M_CANFAIL | M_ZERO);
		if (siop_target->siop_lun[lun] == NULL) {
			printf("%s: can't alloc siop_lun for "
			    "target %d lun %d\n",
			    sc->sc_c.sc_dev.dv_xname, target, lun);
			return (ENOMEM);
		}
	}

	return (0);
}

void
siop_scsicmd(xs)
	struct scsi_xfer *xs;
{
	struct siop_softc *sc = (struct siop_softc *)xs->sc_link->adapter_softc;
	struct siop_cmd *siop_cmd;
	struct siop_target *siop_target;
	int s, error, i, j;
	const int target = xs->sc_link->target;
	const int lun = xs->sc_link->lun;

#ifdef SIOP_DEBUG_SCHED
	printf("starting cmd for %d:%d\n", target, lun);
#endif

	siop_target = (struct siop_target*)sc->sc_c.targets[target];
	siop_cmd = xs->io;

	/*
	 * The xs may have been restarted by the scsi layer, so ensure the ccb
	 * starts in the proper state.
	 */
	siop_cmd->cmd_c.status = CMDST_READY;

	/* Always reset xs->stimeout, lest we timeout_del() with trash */
	timeout_set(&xs->stimeout, siop_timeout, siop_cmd);

	siop_cmd->cmd_c.siop_target = sc->sc_c.targets[target];
	siop_cmd->cmd_c.xs = xs;
	siop_cmd->cmd_c.flags = 0;

	bzero(&siop_cmd->cmd_c.siop_tables->xscmd,
	    sizeof(siop_cmd->cmd_c.siop_tables->xscmd));
	bcopy(xs->cmd, &siop_cmd->cmd_c.siop_tables->xscmd, xs->cmdlen);
	siop_cmd->cmd_c.siop_tables->cmd.count =
	    siop_htoc32(&sc->sc_c, xs->cmdlen);

	/* load the DMA maps */
	if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		error = bus_dmamap_load(sc->sc_c.sc_dmat,
		    siop_cmd->cmd_c.dmamap_data, xs->data, xs->datalen,
		    NULL, BUS_DMA_NOWAIT | BUS_DMA_STREAMING |
		    ((xs->flags & SCSI_DATA_IN) ?
			BUS_DMA_READ : BUS_DMA_WRITE));
		if (error) {
			printf("%s: unable to load data DMA map: %d\n",
			    sc->sc_c.sc_dev.dv_xname, error);
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}
		bus_dmamap_sync(sc->sc_c.sc_dmat,
		    siop_cmd->cmd_c.dmamap_data, 0,
		    siop_cmd->cmd_c.dmamap_data->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
	}

	siop_setuptables(&siop_cmd->cmd_c);
	siop_cmd->saved_offset = SIOP_NOOFFSET;
	siop_table_sync(siop_cmd,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	/* Negotiate transfer parameters on first non-polling command. */
	if (((xs->flags & SCSI_POLL) == 0) &&
	    siop_target->target_c.status == TARST_PROBING)
		siop_target->target_c.status = TARST_ASYNC;

	s = splbio();
	TAILQ_INSERT_TAIL(&sc->ready_list, siop_cmd, next);
	siop_start(sc);
	if ((xs->flags & SCSI_POLL) == 0) {
		splx(s);
		return;
	}

	/* Poll for command completion. */
	for(i = xs->timeout; i > 0; i--) {
		siop_intr(sc);
		if ((xs->flags & ITSDONE) == 0) {
			delay(1000);
			continue;
		}
		if (xs->cmd->opcode == INQUIRY && xs->error == XS_NOERROR) {
			struct scsi_inquiry_data *inqbuf =
			    (struct scsi_inquiry_data *)xs->data;
		 	if ((inqbuf->device & SID_QUAL) == SID_QUAL_BAD_LU)
				break;
			/* 
			 * Allocate cbd's to hold maximum openings worth of
			 * commands. Do this now because doing it dynamically in
			 * siop_startcmd may cause calls to bus_dma* functions
			 * in interrupt context.
			 */
			for (j = 0; j < SIOP_NTAG; j += SIOP_NCMDPB)
				siop_morecbd(sc);

			/*
			 * Set TARF_DT here because if it is turned off during
			 * PPR, it must STAY off!
			 */
			if ((lun == 0) && (sc->sc_c.features & SF_BUS_ULTRA3))
				sc->sc_c.targets[target]->flags |= TARF_DT;
			/*
			 * Can't do lun 0 here, because flags are not set yet.
			 * But have to do other lun's here because they never go
			 * through TARST_ASYNC.
			 */
			if (lun > 0)
				siop_add_dev(sc, target, lun);
		}
		break;
	}
	if (i == 0) {
		siop_timeout(siop_cmd);
		while ((xs->flags & ITSDONE) == 0)
			siop_intr(sc);
	}

	splx(s);
}

void
siop_start(sc)
	struct siop_softc *sc;
{
	struct siop_cmd *siop_cmd, *next_siop_cmd;
	struct siop_lun *siop_lun;
	struct siop_xfer *siop_xfer;
	u_int32_t dsa;
	int target, lun, tag, slot;
	int newcmd = 0; 
	int doingready = 0;

	/*
	 * first make sure to read valid data
	 */
	siop_script_sync(sc, BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	/*
	 * The queue management here is a bit tricky: the script always looks
	 * at the slot from first to last, so if we always use the first
	 * free slot commands can stay at the tail of the queue ~forever.
	 * The algorithm used here is to restart from the head when we know
	 * that the queue is empty, and only add commands after the last one.
	 * When we're at the end of the queue wait for the script to clear it.
	 * The best thing to do here would be to implement a circular queue,
	 * but using only 53c720 features this can be "interesting".
	 * A mid-way solution could be to implement 2 queues and swap orders.
	 */
	slot = sc->sc_currschedslot;
	/*
	 * If the instruction is 0x80000000 (JUMP foo, IF FALSE) the slot is
	 * free. As this is the last used slot, all previous slots are free,
	 * we can restart from 1.
	 * slot 0 is reserved for request sense commands.
	 */
	if (siop_script_read(sc, (Ent_script_sched_slot0 / 4) + slot * 2) ==
	    0x80000000) {
		slot = sc->sc_currschedslot = 1;
	} else {
		slot++;
	}
	/* first handle commands from the urgent list */
	siop_cmd = TAILQ_FIRST(&sc->urgent_list);
again:
	for (; siop_cmd != NULL; siop_cmd = next_siop_cmd) {
		next_siop_cmd = TAILQ_NEXT(siop_cmd, next);
#ifdef DIAGNOSTIC
		if (siop_cmd->cmd_c.status != CMDST_READY &&
		    siop_cmd->cmd_c.status != CMDST_SENSE)
			panic("siop: non-ready cmd in ready list");
#endif	
		target = siop_cmd->cmd_c.xs->sc_link->target;
		lun = siop_cmd->cmd_c.xs->sc_link->lun;
		siop_lun =
			((struct siop_target*)sc->sc_c.targets[target])->siop_lun[lun];
		/* if non-tagged command active, wait */
		if (siop_lun->siop_tag[0].active != NULL)
			continue;
		/*
		 * if we're in a queue full condition don't start a new
		 * command, unless it's a request sense
		 */
		if ((siop_lun->lun_flags & SIOP_LUNF_FULL) &&
		    siop_cmd->cmd_c.status == CMDST_READY)
			continue;
		/* find a free tag if needed */
		if (siop_cmd->cmd_c.flags & CMDFL_TAG) {
			for (tag = 1; tag < SIOP_NTAG; tag++) {
				if (siop_lun->siop_tag[tag].active == NULL)
					break;
			}
			if (tag == SIOP_NTAG) /* no free tag */
				continue;
		} else {
			tag = 0;
		}
		siop_cmd->cmd_c.tag = tag;
		/*
		 * find a free scheduler slot and load it. If it's a request
		 * sense we need to use slot 0.
		 */
		if (siop_cmd->cmd_c.status != CMDST_SENSE) {
			for (; slot < SIOP_NSLOTS; slot++) {
				/*
				 * If cmd if 0x80000000 the slot is free
				 */
				if (siop_script_read(sc,
				    (Ent_script_sched_slot0 / 4) + slot * 2) ==
				    0x80000000)
					break;
			}
			/* no more free slots, no need to continue */
			if (slot == SIOP_NSLOTS) {
				goto end;
			}
		} else {
			slot = 0;
			if (siop_script_read(sc, Ent_script_sched_slot0 / 4)
			    != 0x80000000) 
				goto end;
		}

#ifdef SIOP_DEBUG_SCHED
		printf("using slot %d for DSA 0x%lx\n", slot,
		    (u_long)siop_cmd->cmd_c.dsa);
#endif
		/* Ok, we can add the tag message */
		if (tag > 0) {
#ifdef DIAGNOSTIC
			int msgcount = siop_ctoh32(&sc->sc_c,
			    siop_cmd->cmd_tables->t_msgout.count);
			if (msgcount != 1)
				printf("%s:%d:%d: tag %d with msgcount %d\n",
				    sc->sc_c.sc_dev.dv_xname, target, lun, tag,
				    msgcount);
#endif
			siop_cmd->cmd_tables->msg_out[1] = MSG_SIMPLE_Q_TAG;
			siop_cmd->cmd_tables->msg_out[2] = tag;
			siop_cmd->cmd_tables->t_msgout.count =
			    siop_htoc32(&sc->sc_c, 3);
		}
		/* note that we started a new command */
		newcmd = 1;
		/* mark command as active */
		if (siop_cmd->cmd_c.status == CMDST_READY) {
			siop_cmd->cmd_c.status = CMDST_ACTIVE;
		} else if (siop_cmd->cmd_c.status == CMDST_SENSE) {
			siop_cmd->cmd_c.status = CMDST_SENSE_ACTIVE;
		} else
			panic("siop_start: bad status");
		if (doingready)
			TAILQ_REMOVE(&sc->ready_list, siop_cmd, next);
		else
			TAILQ_REMOVE(&sc->urgent_list, siop_cmd, next);
		siop_lun->siop_tag[tag].active = siop_cmd;
		/* patch scripts with DSA addr */
		dsa = siop_cmd->cmd_c.dsa;
		/* first reselect switch, if we have an entry */
		if (siop_lun->siop_tag[tag].reseloff > 0)
			siop_script_write(sc,
			    siop_lun->siop_tag[tag].reseloff + 1,
			    dsa + sizeof(struct siop_common_xfer) +
			    Ent_ldsa_reload_dsa);
		/* CMD script: MOVE MEMORY addr */
		siop_xfer = (struct siop_xfer*)siop_cmd->cmd_tables;
		siop_xfer->resel[E_ldsa_abs_slot_Used[0]] =
		    siop_htoc32(&sc->sc_c, sc->sc_c.sc_scriptaddr +
		        Ent_script_sched_slot0 + slot * 8);
		siop_table_sync(siop_cmd, BUS_DMASYNC_PREWRITE);
		/* scheduler slot: JUMP ldsa_select */
		siop_script_write(sc,
		    (Ent_script_sched_slot0 / 4) + slot * 2 + 1,
		    dsa + sizeof(struct siop_common_xfer) + Ent_ldsa_select);
		/* handle timeout */
		if (siop_cmd->cmd_c.status == CMDST_ACTIVE) {
			if ((siop_cmd->cmd_c.xs->flags & SCSI_POLL) == 0) {
				/* start expire timer */
				timeout_add_msec(&siop_cmd->cmd_c.xs->stimeout,
				    siop_cmd->cmd_c.xs->timeout);
			}
		}
		/*
		 * Change JUMP cmd so that this slot will be handled
		 */
		siop_script_write(sc, (Ent_script_sched_slot0 / 4) + slot * 2,
		    0x80080000);
		/* if we're using the request sense slot, stop here */
		if (slot == 0)
			goto end;
		sc->sc_currschedslot = slot;
		slot++;
	}
	if (doingready == 0) {
		/* now process ready list */
		doingready = 1;
		siop_cmd = TAILQ_FIRST(&sc->ready_list);
		goto again;
	}

end:
	/* if nothing changed no need to flush cache and wakeup script */
	if (newcmd == 0)
		return;
	/* make sure SCRIPT processor will read valid data */
	siop_script_sync(sc,BUS_DMASYNC_PREREAD |  BUS_DMASYNC_PREWRITE);
	/* Signal script it has some work to do */
	bus_space_write_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
	    SIOP_ISTAT, ISTAT_SIGP);
	/* and wait for IRQ */
}

void
siop_timeout(v)
	void *v;
{
	struct siop_cmd *siop_cmd = v;
	struct siop_softc *sc = (struct siop_softc *)siop_cmd->cmd_c.siop_sc;
	int s;

	/* deactivate callout */
	timeout_del(&siop_cmd->cmd_c.xs->stimeout);

	sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
	printf("timeout on SCSI command 0x%x\n",
	    siop_cmd->cmd_c.xs->cmd->opcode);

	s = splbio();
	/* reset the scsi bus */
	siop_resetbus(&sc->sc_c);
	siop_cmd->cmd_c.flags |= CMDFL_TIMEOUT;
	siop_handle_reset(sc);
	splx(s);
}

#ifdef DUMP_SCRIPT
void
siop_dump_script(sc)
	struct siop_softc *sc;
{
	int i;
	for (i = 0; i < PAGE_SIZE / 4; i += 2) {
		printf("0x%04x: 0x%08x 0x%08x", i * 4,
		    siop_ctoh32(&sc->sc_c, sc->sc_c.sc_script[i]),
		    siop_ctoh32(&sc->sc_c, sc->sc_c.sc_script[i+1]));
		if ((siop_ctoh32(&sc->sc_c,
		     sc->sc_c.sc_script[i]) & 0xe0000000) == 0xc0000000) {
			i++;
			printf(" 0x%08x", siop_ctoh32(&sc->sc_c,
			    sc->sc_c.sc_script[i+1]));
		}
		printf("\n");
	}
}
#endif

void
siop_morecbd(sc)
	struct siop_softc *sc;
{
	int error, off, i, j, s;
	struct siop_cbd *newcbd;
	struct siop_xfer *xfers, *xfer;
	bus_addr_t dsa;
	u_int32_t *scr;
	size_t sense_size = roundup(sizeof(struct scsi_sense_data), 16);

	/* allocate a new list head */
	newcbd = malloc(sizeof(struct siop_cbd), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (newcbd == NULL) {
		printf("%s: can't allocate memory for command descriptors "
		    "head\n", sc->sc_c.sc_dev.dv_xname);
		return;
	}

	/* allocate cmd list */
	newcbd->cmds = mallocarray(SIOP_NCMDPB, sizeof(struct siop_cmd),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (newcbd->cmds == NULL) {
		printf("%s: can't allocate memory for command descriptors\n",
		    sc->sc_c.sc_dev.dv_xname);
		goto bad3;
	}

	newcbd->xfers = siop_dmamem_alloc(sc, PAGE_SIZE);
	if (newcbd->xfers == NULL) {
		printf("%s: unable to allocate cbd xfer DMA memory\n",
		    sc->sc_c.sc_dev.dv_xname);
		goto bad2;
	}
	xfers = SIOP_DMA_KVA(newcbd->xfers);

	newcbd->sense = siop_dmamem_alloc(sc, sense_size * SIOP_NCMDPB);
	if (newcbd->sense == NULL) {
		printf("%s: unable to allocate cbd sense DMA memory\n",
		    sc->sc_c.sc_dev.dv_xname);
		goto bad1;
	}

	for (i = 0; i < SIOP_NCMDPB; i++) {
		error = bus_dmamap_create(sc->sc_c.sc_dmat, MAXPHYS, SIOP_NSG,
		    MAXPHYS, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &newcbd->cmds[i].cmd_c.dmamap_data);
		if (error) {
			printf("%s: unable to create data DMA map for cbd: "
			    "error %d\n",
			    sc->sc_c.sc_dev.dv_xname, error);
			goto bad0;
		}
	}

	/* Use two loops since bailing out above releases allocated memory */
	off = (sc->sc_c.features & SF_CHIP_BE) ? 3 : 0;
	for (i = 0; i < SIOP_NCMDPB; i++) {
		newcbd->cmds[i].cmd_c.siop_sc = &sc->sc_c;
		newcbd->cmds[i].siop_cbdp = newcbd;
		xfer = &xfers[i];
		newcbd->cmds[i].cmd_tables = (struct siop_common_xfer *)xfer;
		bzero(newcbd->cmds[i].cmd_tables, sizeof(struct siop_xfer));
		dsa = SIOP_DMA_DVA(newcbd->xfers) +
		    i * sizeof(struct siop_xfer);
		newcbd->cmds[i].cmd_c.dsa = dsa;
		newcbd->cmds[i].cmd_c.status = CMDST_FREE;
		newcbd->cmds[i].cmd_c.sense = (struct scsi_sense_data *)(
		    i * sense_size +
		    (u_int8_t *)SIOP_DMA_KVA(newcbd->sense));
		xfer->siop_tables.t_msgout.count= siop_htoc32(&sc->sc_c, 1);
		xfer->siop_tables.t_msgout.addr = siop_htoc32(&sc->sc_c, dsa);
		xfer->siop_tables.t_msgin.count= siop_htoc32(&sc->sc_c, 1);
		xfer->siop_tables.t_msgin.addr = siop_htoc32(&sc->sc_c,
		    dsa + offsetof(struct siop_common_xfer, msg_in));
		xfer->siop_tables.t_extmsgin.count= siop_htoc32(&sc->sc_c, 2);
		xfer->siop_tables.t_extmsgin.addr = siop_htoc32(&sc->sc_c,
		    dsa + offsetof(struct siop_common_xfer, msg_in) + 1);
		xfer->siop_tables.t_extmsgdata.addr = siop_htoc32(&sc->sc_c,
		    dsa + offsetof(struct siop_common_xfer, msg_in) + 3);
		xfer->siop_tables.t_status.count= siop_htoc32(&sc->sc_c, 1);
		xfer->siop_tables.t_status.addr = siop_htoc32(&sc->sc_c,
		    dsa + offsetof(struct siop_common_xfer, status) + off);
		xfer->siop_tables.cmd.count = siop_htoc32(&sc->sc_c, 0);
		xfer->siop_tables.cmd.addr = siop_htoc32(&sc->sc_c,
		    dsa + offsetof(struct siop_common_xfer, xscmd));
		/* The select/reselect script */
		scr = &xfer->resel[0];
		for (j = 0; j < sizeof(load_dsa) / sizeof(load_dsa[0]); j++)
			scr[j] = siop_htoc32(&sc->sc_c, load_dsa[j]);
		/*
		 * 0x78000000 is a 'move data8 to reg'. data8 is the second
		 * octet, reg offset is the third.
		 */
		scr[Ent_rdsa0 / 4] = siop_htoc32(&sc->sc_c,
		    0x78100000 | ((dsa & 0x000000ff) <<  8));
		scr[Ent_rdsa1 / 4] = siop_htoc32(&sc->sc_c,
		    0x78110000 | ( dsa & 0x0000ff00       ));
		scr[Ent_rdsa2 / 4] = siop_htoc32(&sc->sc_c,
		    0x78120000 | ((dsa & 0x00ff0000) >>  8));
		scr[Ent_rdsa3 / 4] = siop_htoc32(&sc->sc_c,
		    0x78130000 | ((dsa & 0xff000000) >> 16));
		scr[E_ldsa_abs_reselected_Used[0]] = siop_htoc32(&sc->sc_c,
		    sc->sc_c.sc_scriptaddr + Ent_reselected);
		scr[E_ldsa_abs_reselect_Used[0]] = siop_htoc32(&sc->sc_c,
		    sc->sc_c.sc_scriptaddr + Ent_reselect);
		scr[E_ldsa_abs_selected_Used[0]] = siop_htoc32(&sc->sc_c,
		    sc->sc_c.sc_scriptaddr + Ent_selected);
		scr[E_ldsa_abs_data_Used[0]] = siop_htoc32(&sc->sc_c,
		    dsa + sizeof(struct siop_common_xfer) + Ent_ldsa_data);
		/* JUMP foo, IF FALSE - used by MOVE MEMORY to clear the slot */
		scr[Ent_ldsa_data / 4] = siop_htoc32(&sc->sc_c, 0x80000000);
		s = splbio();
		TAILQ_INSERT_TAIL(&sc->free_list, &newcbd->cmds[i], next);
		splx(s);
#ifdef SIOP_DEBUG
		printf("tables[%d]: in=0x%x out=0x%x status=0x%x "
		    "offset=0x%x\n", i,
		    siop_ctoh32(&sc->sc_c,
			newcbd->cmds[i].cmd_tables->t_msgin.addr),
		    siop_ctoh32(&sc->sc_c,
			newcbd->cmds[i].cmd_tables->t_msgout.addr),
		    siop_ctoh32(&sc->sc_c,
			newcbd->cmds[i].cmd_tables->t_status.addr));
#endif
	}
	s = splbio();
	TAILQ_INSERT_TAIL(&sc->cmds, newcbd, next);
	splx(s);
	return;
bad0:
	while (--i >= 0) {
		bus_dmamap_destroy(sc->sc_c.sc_dmat,
		    newcbd->cmds[i].cmd_c.dmamap_data);
	}
	siop_dmamem_free(sc, newcbd->sense);
bad1:
	siop_dmamem_free(sc, newcbd->xfers);
bad2:
	free(newcbd->cmds, M_DEVBUF, SIOP_NCMDPB * sizeof(struct siop_cmd));
bad3:
	free(newcbd, M_DEVBUF, sizeof *newcbd);
}

struct siop_lunsw *
siop_get_lunsw(sc)
	struct siop_softc *sc;
{
	struct siop_lunsw *lunsw;
	int i;

	if (sc->script_free_lo + (sizeof(lun_switch) / sizeof(lun_switch[0])) >=
	    sc->script_free_hi)
		return NULL;
	lunsw = TAILQ_FIRST(&sc->lunsw_list);
	if (lunsw != NULL) {
#ifdef SIOP_DEBUG
		printf("siop_get_lunsw got lunsw at offset %d\n",
		    lunsw->lunsw_off);
#endif
		TAILQ_REMOVE(&sc->lunsw_list, lunsw, next);
		return lunsw;
	}
	lunsw = malloc(sizeof(struct siop_lunsw), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (lunsw == NULL)
		return NULL;
#ifdef SIOP_DEBUG
	printf("allocating lunsw at offset %d\n", sc->script_free_lo);
#endif
	if (sc->sc_c.features & SF_CHIP_RAM) {
		bus_space_write_region_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
		    sc->script_free_lo * 4, lun_switch,
		    sizeof(lun_switch) / sizeof(lun_switch[0]));
		bus_space_write_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
		    (sc->script_free_lo + E_abs_lunsw_return_Used[0]) * 4,
		    sc->sc_c.sc_scriptaddr + Ent_lunsw_return);
	} else {
		for (i = 0; i < sizeof(lun_switch) / sizeof(lun_switch[0]);
		    i++)
			sc->sc_c.sc_script[sc->script_free_lo + i] =
			    siop_htoc32(&sc->sc_c, lun_switch[i]);
		sc->sc_c.sc_script[
		    sc->script_free_lo + E_abs_lunsw_return_Used[0]] =
		    siop_htoc32(&sc->sc_c,
			sc->sc_c.sc_scriptaddr + Ent_lunsw_return);
	}
	lunsw->lunsw_off = sc->script_free_lo;
	lunsw->lunsw_size = sizeof(lun_switch) / sizeof(lun_switch[0]);
	sc->script_free_lo += lunsw->lunsw_size;
	siop_script_sync(sc, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	return lunsw;
}

void
siop_add_reselsw(sc, target)
	struct siop_softc *sc;
	int target;
{
	int i,j;
	struct siop_target *siop_target;
	struct siop_lun *siop_lun;

	siop_target = (struct siop_target *)sc->sc_c.targets[target];
	/*
	 * add an entry to resel switch
	 */
	siop_script_sync(sc, BUS_DMASYNC_POSTWRITE);
	for (i = 0; i < 15; i++) {
		siop_target->reseloff = Ent_resel_targ0 / 4 + i * 2;
		if ((siop_script_read(sc, siop_target->reseloff) & 0xff)
		    == 0xff) { /* it's free */
#ifdef SIOP_DEBUG
			printf("siop: target %d slot %d offset %d\n",
			    target, i, siop_target->reseloff);
#endif
			/* JUMP abs_foo, IF target | 0x80; */
			siop_script_write(sc, siop_target->reseloff,
			    0x800c0080 | target);
			siop_script_write(sc, siop_target->reseloff + 1,
			    sc->sc_c.sc_scriptaddr +
			    siop_target->lunsw->lunsw_off * 4 +
			    Ent_lun_switch_entry);
			break;
		}
	}
	if (i == 15) /* no free slot, shouldn't happen */
		panic("siop: resel switch full");

	sc->sc_ntargets++;
	for (i = 0; i < 8; i++) {
		siop_lun = siop_target->siop_lun[i];
		if (siop_lun == NULL)
			continue;
		if (siop_lun->reseloff > 0) {
			siop_lun->reseloff = 0;
			for (j = 0; j < SIOP_NTAG; j++)
				siop_lun->siop_tag[j].reseloff = 0;
			siop_add_dev(sc, target, i);
		}
	}
	siop_update_scntl3(sc, sc->sc_c.targets[target]);
	siop_script_sync(sc, BUS_DMASYNC_PREWRITE);
}

void
siop_update_scntl3(sc, _siop_target)
	struct siop_softc *sc;
	struct siop_common_target *_siop_target;
{
	struct siop_target *siop_target = (struct siop_target *)_siop_target;
	/* MOVE target->id >> 24 TO SCNTL3 */
	siop_script_write(sc,
	    siop_target->lunsw->lunsw_off + (Ent_restore_scntl3 / 4),
	    0x78030000 | ((siop_target->target_c.id >> 16) & 0x0000ff00));
	/* MOVE target->id >> 8 TO SXFER */
	siop_script_write(sc,
	    siop_target->lunsw->lunsw_off + (Ent_restore_scntl3 / 4) + 2,
	    0x78050000 | (siop_target->target_c.id & 0x0000ff00));
	siop_script_sync(sc, BUS_DMASYNC_PREWRITE);
}

void
siop_add_dev(sc, target, lun)
	struct siop_softc *sc;
	int target;
	int lun;
{
	struct siop_lunsw *lunsw;
	struct siop_target *siop_target =
	    (struct siop_target *)sc->sc_c.targets[target];
	struct siop_lun *siop_lun = siop_target->siop_lun[lun];
	int i, ntargets;

	if (siop_lun->reseloff > 0)
		return;
	lunsw = siop_target->lunsw;
	if ((lunsw->lunsw_off + lunsw->lunsw_size) < sc->script_free_lo) {
		/*
		 * can't extend this slot. Probably not worth trying to deal
		 * with this case
		 */
#ifdef SIOP_DEBUG
		printf("%s:%d:%d: can't allocate a lun sw slot\n",
		    sc->sc_c.sc_dev.dv_xname, target, lun);
#endif
		return;
	}
	/* count how many free targets we still have to probe */
	ntargets =  (sc->sc_c.sc_link.adapter_buswidth - 1) - 1 - sc->sc_ntargets;

	/*
	 * we need 8 bytes for the lun sw additional entry, and
	 * eventually sizeof(tag_switch) for the tag switch entry.
	 * Keep enough free space for the free targets that could be
	 * probed later.
	 */
	if (sc->script_free_lo + 2 +
	    (ntargets * sizeof(lun_switch) / sizeof(lun_switch[0])) >=
	    ((siop_target->target_c.flags & TARF_TAG) ?
	    sc->script_free_hi - (sizeof(tag_switch) / sizeof(tag_switch[0])) :
	    sc->script_free_hi)) {
		/*
		 * not enough space, probably not worth dealing with it.
		 * We can hold 13 tagged-queuing capable devices in the 4k RAM.
		 */
#ifdef SIOP_DEBUG
		printf("%s:%d:%d: not enough memory for a lun sw slot\n",
		    sc->sc_c.sc_dev.dv_xname, target, lun);
#endif
		return;
	}
#ifdef SIOP_DEBUG
	printf("%s:%d:%d: allocate lun sw entry\n",
	    sc->sc_c.sc_dev.dv_xname, target, lun);
#endif
	/* INT int_resellun */
	siop_script_write(sc, sc->script_free_lo, 0x98080000);
	siop_script_write(sc, sc->script_free_lo + 1, A_int_resellun);
	/* Now the slot entry: JUMP abs_foo, IF lun */
	siop_script_write(sc, sc->script_free_lo - 2,
	    0x800c0000 | lun);
	siop_script_write(sc, sc->script_free_lo - 1, 0);
	siop_lun->reseloff = sc->script_free_lo - 2;
	lunsw->lunsw_size += 2;
	sc->script_free_lo += 2;
	if (siop_target->target_c.flags & TARF_TAG) {
		/* we need a tag switch */
		sc->script_free_hi -=
		    sizeof(tag_switch) / sizeof(tag_switch[0]);
		if (sc->sc_c.features & SF_CHIP_RAM) {
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    sc->script_free_hi * 4, tag_switch,
			    sizeof(tag_switch) / sizeof(tag_switch[0]));
		} else {
			for(i = 0;
			    i < sizeof(tag_switch) / sizeof(tag_switch[0]);
			    i++) {
				sc->sc_c.sc_script[sc->script_free_hi + i] =
				    siop_htoc32(&sc->sc_c, tag_switch[i]);
			}
		}
		siop_script_write(sc,
		    siop_lun->reseloff + 1,
		    sc->sc_c.sc_scriptaddr + sc->script_free_hi * 4 +
		    Ent_tag_switch_entry);

		for (i = 0; i < SIOP_NTAG; i++) {
			siop_lun->siop_tag[i].reseloff =
			    sc->script_free_hi + (Ent_resel_tag0 / 4) + i * 2;
		}
	} else {
		/* non-tag case; just work with the lun switch */
		siop_lun->siop_tag[0].reseloff =
		    siop_target->siop_lun[lun]->reseloff;
	}
	siop_script_sync(sc, BUS_DMASYNC_PREWRITE);
}

void
siop_scsifree(struct scsi_link *link)
{
	struct siop_softc *sc = link->adapter_softc;
	int target = link->target;
	int lun = link->lun;
	int i;
	struct siop_target *siop_target;

#ifdef SIOP_DEBUG
		printf("%s:%d:%d: free lun sw entry\n",
		    sc->sc_c.sc_dev.dv_xname, target, lun);
#endif

	siop_target = (struct siop_target *)sc->sc_c.targets[target];
	free(siop_target->siop_lun[lun], M_DEVBUF, 0);
	siop_target->siop_lun[lun] = NULL;
	/* XXX compact sw entry too ? */
	/* check if we can free the whole target */
	for (i = 0; i < 8; i++) {
		if (siop_target->siop_lun[i] != NULL)
			return;
	}
#ifdef SIOP_DEBUG
	printf("%s: free siop_target for target %d lun %d lunsw offset %d\n",
	    sc->sc_c.sc_dev.dv_xname, target, lun,
	    siop_target->lunsw->lunsw_off);
#endif
	/*
	 * nothing here, free the target struct and resel
	 * switch entry
	 */
	siop_script_write(sc, siop_target->reseloff, 0x800c00ff);
	siop_script_sync(sc, BUS_DMASYNC_PREWRITE);
	TAILQ_INSERT_TAIL(&sc->lunsw_list, siop_target->lunsw, next);
	free(sc->sc_c.targets[target], M_DEVBUF, 0);
	sc->sc_c.targets[target] = NULL;
	sc->sc_ntargets--;
}

#ifdef SIOP_STATS
void
siop_printstats(void)
{
	printf("siop_stat_intr %d\n", siop_stat_intr);
	printf("siop_stat_intr_shortxfer %d\n", siop_stat_intr_shortxfer);
	printf("siop_stat_intr_xferdisc %d\n", siop_stat_intr_xferdisc);
	printf("siop_stat_intr_sdp %d\n", siop_stat_intr_sdp);
	printf("siop_stat_intr_saveoffset %d\n", siop_stat_intr_saveoffset);
	printf("siop_stat_intr_done %d\n", siop_stat_intr_done);
	printf("siop_stat_intr_lunresel %d\n", siop_stat_intr_lunresel);
	printf("siop_stat_intr_qfull %d\n", siop_stat_intr_qfull);
}
#endif

struct siop_dmamem *
siop_dmamem_alloc(struct siop_softc *sc, size_t size)
{
	struct siop_dmamem *sdm;
	int nsegs;

	sdm = malloc(sizeof(*sdm), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sdm == NULL)
		return (NULL);

	sdm->sdm_size = size;

	if (bus_dmamap_create(sc->sc_c.sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sdm->sdm_map) != 0)
		goto sdmfree;

	if (bus_dmamem_alloc(sc->sc_c.sc_dmat, size, PAGE_SIZE, 0,
	    &sdm->sdm_seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(sc->sc_c.sc_dmat, &sdm->sdm_seg, nsegs, size,
	    &sdm->sdm_kva, BUS_DMA_NOWAIT | BUS_DMA_COHERENT) != 0)
		goto free;

	if (bus_dmamap_load(sc->sc_c.sc_dmat, sdm->sdm_map, sdm->sdm_kva,
	    size, NULL, BUS_DMA_NOWAIT) != 0)
		goto unmap;

	return (sdm);

unmap:
	bus_dmamem_unmap(sc->sc_c.sc_dmat, sdm->sdm_kva, size);
free:
	bus_dmamem_free(sc->sc_c.sc_dmat, &sdm->sdm_seg, 1);
destroy:
	bus_dmamap_destroy(sc->sc_c.sc_dmat, sdm->sdm_map);
sdmfree:
	free(sdm, M_DEVBUF, sizeof *sdm);

	return (NULL);
}

void
siop_dmamem_free(struct siop_softc *sc, struct siop_dmamem *sdm)
{
	bus_dmamap_unload(sc->sc_c.sc_dmat, sdm->sdm_map);
	bus_dmamem_unmap(sc->sc_c.sc_dmat, sdm->sdm_kva, sdm->sdm_size);
	bus_dmamem_free(sc->sc_c.sc_dmat, &sdm->sdm_seg, 1);
	bus_dmamap_destroy(sc->sc_c.sc_dmat, sdm->sdm_map);
	free(sdm, M_DEVBUF, sizeof *sdm);
}

@


1.70
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.69 2014/12/19 22:44:58 guenther Exp $ */
d1428 1
a1428 1
			free(siop_target, M_DEVBUF, 0);
a1765 1
	return;
a1788 2

	return;
d1951 1
a1951 1
	free(newcbd->cmds, M_DEVBUF, 0);
d1953 1
a1953 2
	free(newcbd, M_DEVBUF, 0);
	return;
d2263 1
a2263 1
	free(sdm, M_DEVBUF, 0);
d2275 1
a2275 1
	free(sdm, M_DEVBUF, 0);
@


1.69
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.68 2014/07/13 23:10:23 deraadt Exp $ */
a34 1
#include <sys/buf.h>
@


1.68
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.67 2014/07/12 18:48:17 tedu Exp $ */
d37 1
a38 1
#include <machine/endian.h>
@


1.67
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.66 2013/05/27 21:19:31 miod Exp $ */
d1836 1
a1836 1
	newcbd->cmds = malloc(sizeof(struct siop_cmd) * SIOP_NCMDPB,
@


1.66
log
@Fix edge cases of uninitialized variables. In my tree for too long, I even
got ok's for azalia but I don't remember from whom.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.65 2011/06/23 16:31:16 deraadt Exp $ */
d302 1
a302 1
		free(lunsw, M_DEVBUF);
d315 1
a315 1
		free(target->lunsw, M_DEVBUF);
d1429 1
a1429 1
			free(siop_target, M_DEVBUF);
d1955 1
a1955 1
	free(newcbd->cmds, M_DEVBUF);
d1957 1
a1957 1
	free(newcbd, M_DEVBUF);
d2191 1
a2191 1
	free(siop_target->siop_lun[lun], M_DEVBUF);
d2211 1
a2211 1
	free(sc->sc_c.targets[target], M_DEVBUF);
d2268 1
a2268 1
	free(sdm, M_DEVBUF);
d2280 1
a2280 1
	free(sdm, M_DEVBUF);
@


1.65
log
@a bit more ansi; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.64 2011/04/05 22:37:39 dlg Exp $ */
d637 2
d1054 2
a1055 1
	}
@


1.64
log
@pull the dmamam wrapper in from all my other drivers and use it to replace
the siop command buffers and add dmaable buffers for sense data.

matthew@@ found that siop used to try to dma to the xs->sense bufer, which
is not guaranteed to be dma safe.
tested by matthew@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.63 2010/07/23 07:47:13 jsg Exp $ */
d2215 1
a2215 1
siop_printstats()
@


1.63
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.62 2010/07/06 23:32:01 dlg Exp $ */
d100 3
d138 3
a140 2
	    siop_cmd->siop_cbdp->xferdma->dm_segs[0].ds_addr;
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->siop_cbdp->xferdma, offset,
d383 3
a385 3
		if (dsa >= cbdp->xferdma->dm_segs[0].ds_addr &&
	    	    dsa < cbdp->xferdma->dm_segs[0].ds_addr + PAGE_SIZE) {
			dsa -= cbdp->xferdma->dm_segs[0].ds_addr;
d1171 3
a1173 2
		error = bus_dmamap_load(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data,
		    &xs->sense, sizeof(struct scsi_sense_data),
d1196 1
a1817 2
	bus_dma_segment_t seg;
	int rseg;
d1819 1
a1819 1
	struct siop_xfer *xfer;
d1822 1
d1840 5
a1844 5
	error = bus_dmamem_alloc(sc->sc_c.sc_dmat, PAGE_SIZE, PAGE_SIZE, 0, &seg,
	    1, &rseg, BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: unable to allocate cbd DMA memory, error = %d\n",
		    sc->sc_c.sc_dev.dv_xname, error);
d1847 6
a1852 12
	error = bus_dmamem_map(sc->sc_c.sc_dmat, &seg, rseg, PAGE_SIZE,
	    (caddr_t *)&newcbd->xfers, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (error) {
		printf("%s: unable to map cbd DMA memory, error = %d\n",
		    sc->sc_c.sc_dev.dv_xname, error);
		goto bad2;
	}
	error = bus_dmamap_create(sc->sc_c.sc_dmat, PAGE_SIZE, 1, PAGE_SIZE, 0,
	    BUS_DMA_NOWAIT, &newcbd->xferdma);
	if (error) {
		printf("%s: unable to create cbd DMA map, error = %d\n",
		    sc->sc_c.sc_dev.dv_xname, error);
d1855 1
a1855 11
	error = bus_dmamap_load(sc->sc_c.sc_dmat, newcbd->xferdma, newcbd->xfers,
	    PAGE_SIZE, NULL, BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: unable to load cbd DMA map, error = %d\n",
		    sc->sc_c.sc_dev.dv_xname, error);
		goto bad0;
	}
#ifdef SIOP_DEBUG
	printf("%s: alloc newcdb at PHY addr 0x%lx\n", sc->sc_c.sc_dev.dv_xname,
	    (unsigned long)newcbd->xferdma->dm_segs[0].ds_addr);
#endif
d1873 1
a1873 1
		xfer = &newcbd->xfers[i];
d1876 1
a1876 1
		dsa = newcbd->xferdma->dm_segs[0].ds_addr +
d1880 3
d1944 5
a1948 2
	bus_dmamap_unload(sc->sc_c.sc_dmat, newcbd->xferdma);
	bus_dmamap_destroy(sc->sc_c.sc_dmat, newcbd->xferdma);
d1950 1
a1950 1
	bus_dmamem_free(sc->sc_c.sc_dmat, &seg, rseg);
d2227 53
@


1.62
log
@siop sets XS_NO_CCB when it fails to allocate device state when commands
are first sent to target/lun, as opposed to failing to allocate a ccb
(which ive already fixed). this moves the allocation and freeing of this
device state in siop into the scsi_probe and scsi_free handlers.

if siop cant allocate memory for a device when the midlayer is about to
probe it, we dont send commands to it. if the midlayer fails to find a
device at that target/lun, it asks siop to free it.

simplifies the io path and avoids work during interrupts.

ok deraadt@@
reads good to both marco@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.61 2010/07/02 15:10:48 blambert Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.61
log
@timeout_add -> timeout_add_msec

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.60 2010/06/28 18:31:02 krw Exp $ */
d95 2
d112 2
a113 2
	NULL,
	NULL,
a362 1
	int freetarget = 0;
a582 1
				freetarget = 1;
a1075 2
	if (freetarget && siop_target->target_c.status == TARST_PROBING)
		siop_del_dev(sc, target, lun);
d1387 2
a1388 3
void
siop_scsicmd(xs)
	struct scsi_xfer *xs;
d1390 1
a1390 2
	struct siop_softc *sc = (struct siop_softc *)xs->sc_link->adapter_softc;
	struct siop_cmd *siop_cmd;
d1392 3
a1394 3
	int s, error, i, j;
	const int target = xs->sc_link->target;
	const int lun = xs->sc_link->lun;
d1396 3
a1398 3
	s = splbio();
#ifdef SIOP_DEBUG_SCHED
	printf("starting cmd for %d:%d\n", target, lun);
d1400 3
d1405 6
a1410 15
#ifdef SIOP_DEBUG
		printf("%s: alloc siop_target for target %d\n",
			sc->sc_c.sc_dev.dv_xname, target);
#endif
		sc->sc_c.targets[target] =
		    malloc(sizeof(struct siop_target), M_DEVBUF,
		        M_NOWAIT | M_ZERO);
		if (sc->sc_c.targets[target] == NULL) {
			printf("%s: can't malloc memory for "
			    "target %d\n", sc->sc_c.sc_dev.dv_xname,
			    target);
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			splx(s);
			return;
d1412 1
a1412 2
		siop_target =
		    (struct siop_target*)sc->sc_c.targets[target];
d1425 2
a1426 4
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			splx(s);
			return;
d1428 1
a1428 1
		for (i=0; i < 8; i++)
d1430 4
d1436 1
d1440 1
a1440 1
		    M_NOWAIT | M_ZERO);
d1445 1
a1445 4
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			splx(s);
			return;
d1449 19
a1500 1
			splx(s);
a1514 2
	TAILQ_INSERT_TAIL(&sc->ready_list, siop_cmd, next);

d1520 2
d2184 1
a2184 4
siop_del_dev(sc, target, lun)
	struct siop_softc *sc;
	int target;
	int lun;
d2186 3
d2191 1
d2196 1
a2196 2
	if (sc->sc_c.targets[target] == NULL)
		return;
@


1.60
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.59 2010/06/03 11:37:45 krw Exp $ */
a1574 1
	int timeout;
d1724 2
a1725 5
				timeout = (u_int64_t) siop_cmd->cmd_c.xs->timeout *
				    (u_int64_t)hz / 1000;
				if (timeout == 0)
					timeout = 1;
				timeout_add(&siop_cmd->cmd_c.xs->stimeout, timeout);
@


1.59
log
@Always initialize the ccb provided by the scsi layer into the proper
state when starting an i/o. Necessary as the scsi layer may now
re-submit a completed xs/ccb to the adapter in some error situations.

Fixes panics seen by various people, reproduced and fix tested by
sobrado@@.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.58 2010/04/06 01:12:17 dlg Exp $ */
a113 7
struct scsi_device siop_dev = {
	NULL,
	NULL,
	NULL,
	NULL,
};

a196 1
	sc->sc_c.sc_link.device = &siop_dev;
@


1.58
log
@modify siop to provide an iopool as a way for the midlayer to manage
access to its free ccbs.

ok krw@@ beck@@ marco@@
tested by beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.57 2010/03/23 01:57:19 krw Exp $ */
d1469 6
@


1.57
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.56 2010/01/10 00:10:23 krw Exp $ */
d93 2
d201 1
d206 1
a1208 2
	siop_cmd->cmd_c.status = CMDST_FREE;
	TAILQ_INSERT_TAIL(&sc->free_list, siop_cmd, next);
d1361 36
d1468 1
a1468 13
	/* Looks like we could issue a command, if a ccb is available. */
	siop_cmd = TAILQ_FIRST(&sc->free_list);
	if (siop_cmd == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		splx(s);
		return;
	}
	TAILQ_REMOVE(&sc->free_list, siop_cmd, next);
#ifdef DIAGNOSTIC
	if (siop_cmd->cmd_c.status != CMDST_FREE)
		panic("siop_scsicmd: new cmd not free");
#endif
a1475 1
	siop_cmd->cmd_c.status = CMDST_READY;
d1493 1
a1493 3
			siop_cmd->cmd_c.status = CMDST_FREE;
			TAILQ_INSERT_TAIL(&sc->free_list, siop_cmd, next);
			xs->error = XS_NO_CCB;
@


1.56
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.55 2009/11/26 21:26:09 krw Exp $ */
d92 1
a92 1
int	siop_scsicmd(struct scsi_xfer *);
d1359 1
a1359 1
int
d1387 2
d1390 1
a1390 1
			return(NO_CCB);
d1406 2
d1409 1
a1409 1
			return(NO_CCB);
d1423 2
d1426 1
a1426 1
			return(NO_CCB);
d1433 2
d1436 1
a1436 1
		return(NO_CCB);
d1470 2
d1473 1
a1473 1
			return(NO_CCB);
d1497 1
a1497 1
		return (SUCCESSFULLY_QUEUED);
a1543 1
	return (COMPLETE);
@


1.55
log
@Don't try to be clever and mix tag queueing mechanisms.  Few if any
disks actually do queueing correctly. Keep it SIMPLE.  Fixes naddy@@'s
magic DNES disks on siop even if dlg@@'s new midlayer is active.

ok marco@@, tested by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.54 2009/11/22 14:14:10 krw Exp $ */
a1204 1
	xs->flags |= ITSDONE;
@


1.54
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.53 2009/01/18 05:09:43 krw Exp $ */
d1655 1
a1655 7
			if (siop_cmd->cmd_c.xs->bp != NULL &&
			    (siop_cmd->cmd_c.xs->bp->b_flags & B_ASYNC))
				siop_cmd->cmd_tables->msg_out[1] =
				    MSG_SIMPLE_Q_TAG;
			else
				siop_cmd->cmd_tables->msg_out[1] =
				    MSG_ORDERED_Q_TAG;
@


1.53
log
@Put ccb back on free list if we bail out because we can't map the
data buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.52 2009/01/18 04:47:54 krw Exp $ */
d1389 1
a1389 1
			return(TRY_AGAIN_LATER);
d1406 1
a1406 1
			return(TRY_AGAIN_LATER);
d1421 1
a1421 1
			return(TRY_AGAIN_LATER);
d1464 1
a1464 1
			return(TRY_AGAIN_LATER);
@


1.52
log
@Don't lose ccb's if there are problems allocating the structures needed
to issue a command.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.51 2008/11/24 00:31:35 krw Exp $ */
d1461 2
@


1.51
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.50 2008/08/31 17:21:57 miod Exp $ */
d1373 1
a1373 15
		printf("starting cmd for %d:%d\n", target, lun);
#endif
	siop_cmd = TAILQ_FIRST(&sc->free_list);
	if (siop_cmd == NULL) {
		splx(s);
		return(NO_CCB);
	}
	TAILQ_REMOVE(&sc->free_list, siop_cmd, next);

	/* Always reset xs->stimeout, lest we timeout_del() with trash */
	timeout_set(&xs->stimeout, siop_timeout, siop_cmd);

#ifdef DIAGNOSTIC
	if (siop_cmd->cmd_c.status != CMDST_FREE)
		panic("siop_scsicmd: new cmd not free");
d1424 16
@


1.50
log
@Fix redundant device name and/or target printing after calling
sc_print_addr(); ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.49 2007/09/07 17:41:09 krw Exp $ */
d1378 1
a1378 1
		return(TRY_AGAIN_LATER);
@


1.49
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.48 2007/08/05 19:05:09 kettenis Exp $ */
d511 1
a511 1
				printf("%s:", sc->sc_c.sc_dev.dv_xname);
d577 1
a577 1
				printf("%s:", sc->sc_c.sc_dev.dv_xname);
@


1.48
log
@Add support for the (non-pci) NCR 53c720/770 in big-endian mode.

ok martin@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.47 2007/05/08 03:16:16 deraadt Exp $ */
d1396 2
a1397 2
		    malloc(sizeof(struct siop_target),
			M_DEVBUF, M_NOWAIT);
a1404 1
		bzero(sc->sc_c.targets[target], sizeof(struct siop_target));
d1429 1
a1429 1
		    M_NOWAIT);
a1436 1
		bzero(siop_target->siop_lun[lun], sizeof(struct siop_lun));
d1795 1
a1795 1
	newcbd = malloc(sizeof(struct siop_cbd), M_DEVBUF, M_NOWAIT);
a1800 1
	bzero(newcbd, sizeof(struct siop_cbd));
d1804 1
a1804 1
	    M_DEVBUF, M_NOWAIT);
a1809 1
	bzero(newcbd->cmds, sizeof(struct siop_cmd) * SIOP_NCMDPB);
d1957 1
a1957 1
	lunsw = malloc(sizeof(struct siop_lunsw), M_DEVBUF, M_NOWAIT);
a1959 1
	bzero(lunsw, sizeof(struct siop_lunsw));
@


1.47
log
@turn off SIOP_STATS; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.46 2006/12/21 02:44:55 krw Exp $ */
d167 1
a167 1
		return letoh32(sc->sc_c.sc_script[offset]);
d181 1
a181 1
		sc->sc_c.sc_script[offset] = htole32(val);
d266 2
a267 1
			sc->sc_c.sc_script[j] = htole32(siop_script[j]);
d273 2
a274 1
			    htole32(sc->sc_c.sc_scriptaddr + Ent_msgin_space);
d281 1
a281 1
				    ] = htole32(siop_led_on[j]);
d286 1
a286 1
				    ] = htole32(siop_led_on[j]);
d291 1
a291 1
				   ] = htole32(siop_led_off[j]);
d475 2
a476 1
				    letoh32(siop_cmd->cmd_tables->status));
d601 1
a601 1
				    htole32(SCSI_CHECK);
d836 1
a836 1
				    htole32(1);
d849 2
a850 1
			siop_cmd->cmd_tables->t_msgout.count= htole32(1);
d868 2
a869 1
			    htole32(siop_cmd->cmd_tables->msg_in[1] - 1);
d975 2
a976 1
			siop_cmd->cmd_tables->t_msgout.count = htole32(1);
d1024 1
a1024 1
			    letoh32(siop_cmd->cmd_tables->id),
d1026 2
a1027 1
			    letoh32(siop_cmd->cmd_tables->status));
d1073 1
a1073 1
	xs->status = letoh32(siop_cmd->cmd_tables->status);
d1171 1
a1171 1
		   htole32(sizeof(struct scsi_sense));
d1448 2
a1449 1
	siop_cmd->cmd_c.siop_tables->cmd.count = htole32(xs->cmdlen);
d1646 2
a1647 2
			int msgcount =
			    letoh32(siop_cmd->cmd_tables->t_msgout.count);
d1661 2
a1662 1
			siop_cmd->cmd_tables->t_msgout.count = htole32(3);
d1689 2
a1690 1
		    htole32(sc->sc_c.sc_scriptaddr + Ent_script_sched_slot0 + slot * 8);
d1771 4
a1774 4
		    letoh32(sc->sc_c.sc_script[i]),
		    letoh32(sc->sc_c.sc_script[i+1]));
		if ((letoh32(sc->sc_c.sc_script[i]) & 0xe0000000) ==
		    0xc0000000) {
d1776 2
a1777 1
			printf(" 0x%08x", letoh32(sc->sc_c.sc_script[i+1]));
d1788 1
a1788 1
	int error, i, j, s;
d1859 1
d1870 16
a1885 16
		xfer->siop_tables.t_msgout.count= htole32(1);
		xfer->siop_tables.t_msgout.addr = htole32(dsa);
		xfer->siop_tables.t_msgin.count= htole32(1);
		xfer->siop_tables.t_msgin.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, msg_in));
		xfer->siop_tables.t_extmsgin.count= htole32(2);
		xfer->siop_tables.t_extmsgin.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, msg_in) + 1);
		xfer->siop_tables.t_extmsgdata.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, msg_in) + 3);
		xfer->siop_tables.t_status.count= htole32(1);
		xfer->siop_tables.t_status.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, status));
		xfer->siop_tables.cmd.count= htole32(0);
		xfer->siop_tables.cmd.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, xscmd));
d1889 1
a1889 1
			scr[j] = htole32(load_dsa[j]);
d1894 16
a1909 17
		scr[Ent_rdsa0 / 4] =
		    htole32(0x78100000 | ((dsa & 0x000000ff) <<  8));
		scr[Ent_rdsa1 / 4] =
		    htole32(0x78110000 | ( dsa & 0x0000ff00       ));
		scr[Ent_rdsa2 / 4] =
		    htole32(0x78120000 | ((dsa & 0x00ff0000) >>  8));
		scr[Ent_rdsa3 / 4] =
		    htole32(0x78130000 | ((dsa & 0xff000000) >> 16));
		scr[E_ldsa_abs_reselected_Used[0]] =
		    htole32(sc->sc_c.sc_scriptaddr + Ent_reselected);
		scr[E_ldsa_abs_reselect_Used[0]] =
		    htole32(sc->sc_c.sc_scriptaddr + Ent_reselect);
		scr[E_ldsa_abs_selected_Used[0]] =
		    htole32(sc->sc_c.sc_scriptaddr + Ent_selected);
		scr[E_ldsa_abs_data_Used[0]] =
		    htole32(dsa + sizeof(struct siop_common_xfer) +
		    Ent_ldsa_data);
d1911 1
a1911 1
		scr[Ent_ldsa_data / 4] = htole32(0x80000000);
d1918 6
a1923 3
		    letoh32(newcbd->cmds[i].cmd_tables->t_msgin.addr),
		    letoh32(newcbd->cmds[i].cmd_tables->t_msgout.addr),
		    letoh32(newcbd->cmds[i].cmd_tables->t_status.addr));
d1979 1
a1979 1
			    htole32(lun_switch[i]);
d1982 2
a1983 1
		    htole32(sc->sc_c.sc_scriptaddr + Ent_lunsw_return);
d2138 1
a2138 1
				    htole32(tag_switch[i]);
@


1.46
log
@'immediatly' -> 'immediately' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.45 2006/11/28 23:59:45 dlg Exp $ */
d70 1
a70 1
#define SIOP_STATS
@


1.45
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.44 2006/05/22 22:22:11 martin Exp $ */
d1254 1
a1254 1
 * As the upper layer may requeue immediatly we have to first store
@


1.44
log
@- fix and prettify SIOP_DEBUG
- print device name on request sense failure

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.43 2005/12/03 16:53:16 krw Exp $ */
d189 2
d223 4
a226 1
	config_found((struct device*)sc, &sc->sc_c.sc_link, scsiprint);
@


1.43
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.42 2005/11/20 22:32:48 krw Exp $ */
a57 2
#endif
#undef SIOP_DEBUG
d62 7
d1102 2
a1103 1
			printf("request sense failed\n");
d1904 1
a1904 2
		    letoh32(newcbd->cmds[i].cmd_tables->t_status.addr),
		    letoh32(newcbd->cmds[i].cmd_tables->t_offset.addr));
@


1.42
log
@Un-revert backout to 20051009 and add patches from Martin Bouyer to
close NetBSD PR#31990. Fixes interaction with some problematic drives
found by miod@@, martin@@, otto@@.

Tested martin@@ otto@@ miod@@

ok miod@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.41 2005/11/03 11:00:36 martin Exp $ */
a1358 1
		xs->error = XS_DRIVER_STUFFUP;
a1383 1
			xs->error = XS_DRIVER_STUFFUP;
a1401 1
			xs->error = XS_DRIVER_STUFFUP;
a1416 1
			xs->error = XS_DRIVER_STUFFUP;
a1441 1
			xs->error = XS_DRIVER_STUFFUP;
@


1.41
log
@revert to 20051009 for now, need to investigate strange behaviour with
some controllers

discussed with otto@@ and henning@@, first noted by miod@@
@
text
@d1 2
a2 2
/*	$OpenBSD: siop.c,v 1.39 2005/10/08 19:48:42 krw Exp $ */
/*	$NetBSD: siop.c,v 1.65 2002/11/08 22:04:41 bouyer Exp $	*/
d118 1
d347 1
a347 1
	int istat, sist, sstat1, dstat;
d522 3
a524 2
				 * transfer than requested). Just go to status
				 * and the command should terminate.
d527 3
a529 1
					if ((dstat & DSTAT_DFE) == 0)
a530 1
					/* no table to flush here */
d534 5
a538 4
					/*
					 * target may be ready to disconnect
					 * Save data pointers just in case.
					 */
d541 1
a541 1
						siop_sdp(&siop_cmd->cmd_c);
a546 3
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
d820 9
d872 23
d972 15
a986 19
			if (offset > SIOP_NSG) {
				printf("%s: bad offset for disconnect (%d)\n",
				    sc->sc_c.sc_dev.dv_xname, offset);
				goto reset;
			}
			/* 
			 * offset == SIOP_NSG may be a valid condition if
			 * we get a sdp when the xfer is done.
			 * Don't call bcopy in this case.
			 */
			if (offset < SIOP_NSG) {
				bcopy(&siop_cmd->cmd_tables->data[offset],
				    &siop_cmd->cmd_tables->data[0],
				    (SIOP_NSG - offset) * sizeof(scr_table_t));
				siop_table_sync(siop_cmd,
				    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			}
			/* check if we can put some command in scheduler */
			siop_start(sc);
d1013 13
d1190 4
a1193 1
	xs->resid = 0;
d1458 1
d1899 2
a1900 1
		printf("tables[%d]: in=0x%x out=0x%x status=0x%x\n", i,
d1903 2
a1904 1
		    letoh32(newcbd->cmds[i].cmd_tables->t_status.addr));
d2186 1
@


1.40
log
@Add handling for IGNORE WIDE RESIDUE messages. Actually calculate
resid instead of assuming it is always 0. From bouyer via NetBSD. Note
we are now sync'd with the latest (1.78 siop.c, 1.37 siop_common.c)
NetBSD code.

Tested by various people over the last year+. Didn't solve any of
their problems but didn't cause any regression either.
@
text
@d2 1
a2 1
/*	$NetBSD: siop.c,v 1.78 2005/02/27 00:27:02 perry Exp $	*/
d346 1
a346 1
	int istat, sist, sstat1, dstat = 0;
d521 2
a522 3
				 * transfer than requested). Compute resid and
				 * just go to status, the command should
				 * terminate.
d525 1
a525 3
					if (scratcha0 & A_flag_data)
						siop_ma(&siop_cmd->cmd_c);
					else if ((dstat & DSTAT_DFE) == 0)
d527 1
d531 4
a534 5
				/*
				 * target may be ready to disconnect
				 * Compute resid which would be used later
				 * if a save data pointer is needed.
				 */
d537 1
a537 1
						siop_ma(&siop_cmd->cmd_c);
d543 3
a818 9
			if (msgin == MSG_IGN_WIDE_RESIDUE) {
			/* use the extmsgdata table to get the second byte */
				siop_cmd->cmd_tables->t_extmsgdata.count =
				    htole32(1);
				siop_table_sync(siop_cmd,
				    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
				CALL_SCRIPT(Ent_get_extmsgdata);
				return 1;
			}
a861 23
			if (siop_cmd->cmd_tables->msg_in[0] ==
			    MSG_IGN_WIDE_RESIDUE) {
			/* we got the second byte of MSG_IGN_WIDE_RESIDUE */
				if (siop_cmd->cmd_tables->msg_in[3] != 1)
					printf("MSG_IGN_WIDE_RESIDUE: "
					    "bad len %d\n",
					    siop_cmd->cmd_tables->msg_in[3]);
				switch (siop_iwr(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_iwr()");
				}
				return(1);
			}
d939 19
a957 3
			siop_sdp(&siop_cmd->cmd_c, offset);
			siop_table_sync(siop_cmd,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
a983 4
			/* update resid.  */
			offset = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SCRATCHA + 1);
			siop_update_resid(&siop_cmd->cmd_c, offset);
d1148 1
a1148 4
#if 0
	if (xs->resid != 0)
		printf("resid %d datalen %d\n", xs->resid, xs->datalen);
#endif
@


1.39
log
@'dma' -> 'DMA' (wiz via NetBSD), save a test after TAILQ_FOREACH() by
initializing siop_cmd to NULL first (matt via NetBSD), remove trailing
whitespace (perry vis NetBSD).
@
text
@d1 2
a2 2
/*	$OpenBSD: siop.c,v 1.38 2005/03/12 17:36:25 martin Exp $ */
/*	$NetBSD: siop.c,v 1.65 2002/11/08 22:04:41 bouyer Exp $	*/
d346 1
a346 1
	int istat, sist, sstat1, dstat;
d521 3
a523 2
				 * transfer than requested). Just go to status
				 * and the command should terminate.
d526 3
a528 1
					if ((dstat & DSTAT_DFE) == 0)
a529 1
					/* no table to flush here */
d533 5
a537 4
					/*
					 * target may be ready to disconnect
					 * Save data pointers just in case.
					 */
d540 1
a540 1
						siop_sdp(&siop_cmd->cmd_c);
a545 3
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
d819 9
d871 23
d971 3
a973 19
			if (offset > SIOP_NSG) {
				printf("%s: bad offset for disconnect (%d)\n",
				    sc->sc_c.sc_dev.dv_xname, offset);
				goto reset;
			}
			/* 
			 * offset == SIOP_NSG may be a valid condition if
			 * we get a sdp when the xfer is done.
			 * Don't call bcopy in this case.
			 */
			if (offset < SIOP_NSG) {
				bcopy(&siop_cmd->cmd_tables->data[offset],
				    &siop_cmd->cmd_tables->data[0],
				    (SIOP_NSG - offset) * sizeof(scr_table_t));
				siop_table_sync(siop_cmd,
				    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			}
			/* check if we can put some command in scheduler */
			siop_start(sc);
d1000 4
d1168 4
a1171 1
	xs->resid = 0;
@


1.38
log
@use TAILQ_FOREACH

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.37 2004/10/13 23:33:02 krw Exp $ */
d24 1
a24 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
d125 1
a125 1
#define INCSTAT(x) 
d371 1
a381 3
	} 
	if (cbdp == NULL) {
		siop_cmd = NULL;
d452 1
a452 1
				printf(" dma fifo empty");
d463 1
a463 1
			else 
d502 1
a502 1
			if (siop_cmd) { 
d679 1
a679 1
		case A_int_resellun: 
d794 1
a794 1
				} else if (msg == MSG_SIMPLE_Q_TAG || 
d835 1
a835 1
			    siop_cmd->cmd_tables->msg_in[2], 
d1225 1
a1225 1
			struct siop_target *siop_target = 
d1496 1
a1496 1
	 * at the slot from first to last, so if we always use the first 
d1627 1
a1627 1
		siop_xfer->resel[E_ldsa_abs_slot_Used[0]] = 
d1914 1
a1914 1
		    sc->script_free_lo + E_abs_lunsw_return_Used[0]] = 
d2069 1
a2069 1
				sc->sc_c.sc_script[sc->script_free_hi + i] = 
d2073 1
a2073 1
		siop_script_write(sc, 
d2084 1
a2084 1
		siop_lun->siop_tag[0].reseloff = 
@


1.37
log
@De-inline siop. Shrinks almost 1K on i386.

ok deraadt@@, marco@@, weingart@@, millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.36 2004/07/31 10:27:14 krw Exp $ */
d372 1
a372 2
	for (cbdp = TAILQ_FIRST(&sc->cmds); cbdp != NULL;
	    cbdp = TAILQ_NEXT(cbdp, next)) {
@


1.36
log
@Save a couple of hundred bytes (on i386) by putting the definition of
siop_dump_script inside #ifdef DUMP_SCRIPT/#endif, just like its
single invocation already is.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.35 2004/07/30 00:24:33 krw Exp $ */
d77 4
d128 15
a142 2
static __inline__ void siop_script_sync(struct siop_softc *, int);
static __inline__ void
d152 1
a152 2
static __inline__ u_int32_t siop_script_read(struct siop_softc *, u_int);
static __inline__ u_int32_t
d165 1
a165 3
static __inline__ void siop_script_write(struct siop_softc *, u_int,
	u_int32_t);
static __inline__ void
@


1.35
log
@Do not negotiate or use non-async transfer rates until probing (i.e.
SCSI_POLL'ing) is complete. Similar to what is done on mpt, ahc, ahd,
etc. This fixes problems during probe on hppa.

Problems found & ok mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.34 2004/04/25 01:49:12 krw Exp $ */
d84 1
d86 1
d1690 1
d1708 1
@


1.34
log
@Rework SCSI_POLL/INQUIRY logic to make it more readable, not least by
fitting all the lines into 80 columns. Prodded by deraadt@@.

Tested & ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.33 2004/04/18 01:14:54 krw Exp $ */
d1405 5
a1435 2
			if (sc->sc_c.targets[target]->status == TARST_PROBING)
				sc->sc_c.targets[target]->status = TARST_ASYNC;
@


1.33
log
@Fix cut/paste typo in error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.32 2004/04/18 00:49:28 krw Exp $ */
d1406 9
a1414 33
	if (xs->flags & SCSI_POLL) {
		/* poll for command completion */
		for(i = xs->timeout; i > 0; i--) {
			siop_intr(sc);
			if (xs->flags & ITSDONE) {
				if ((xs->cmd->opcode == INQUIRY)
				    && (xs->error == XS_NOERROR)) {
					error = ((struct scsi_inquiry_data *)xs->data)->device & SID_QUAL;
					if (error != SID_QUAL_BAD_LU) {
						/* 
						 * Allocate enough commands to hold at least max openings
						 * worth of commands. Do this statically now 'cuz 
						 * a) We can't rely on the upper layers to ask for more
						 * b) Doing it dynamically in siop_startcmd may cause 
						 *    calls to bus_dma* functions in interrupt context
						 */
						for (j = 0; j < SIOP_NTAG; j += SIOP_NCMDPB)
							siop_morecbd(sc);
						if (sc->sc_c.targets[target]->status == TARST_PROBING)
							sc->sc_c.targets[target]->status = TARST_ASYNC;

						/* Set TARF_DT here because if it is turned off during PPR, it must STAY off! */
						if ((lun == 0) && 
						    (sc->sc_c.features & SF_BUS_ULTRA3))
 							sc->sc_c.targets[target]->flags |= TARF_DT;
						/* Can't do lun 0 here, because flags not set yet */
						/* But have to do other lun's here because they never go through TARST_ASYNC */
						if (lun > 0)
							siop_add_dev(sc, target, lun);
					}
				}
				break;
			}
d1416 1
d1418 29
a1446 8
		splx(s);
		if (i == 0) {
			siop_timeout(siop_cmd);
			while ((xs->flags & ITSDONE) == 0) {
				s = splbio();
				siop_intr(sc);
				splx(s);
			}
d1448 1
a1448 1
		return (COMPLETE);
d1450 6
d1457 1
a1457 1
	return (SUCCESSFULLY_QUEUED);
@


1.32
log
@Restore siop's (and possibly others) ability to negotiate tags/wide/sync by
reverting to a single (short) INQUIRY command during probe. Compensate in siop
by trying PPR on all targets on SCSI-3 buses and falling back to WDTR/SDTR if
PPR rejected.

Problem found by mickey@@. Tested on a wide variety of devices by Marco.

ok marco@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.31 2003/10/21 18:58:49 jmc Exp $ */
d887 1
a887 1
					    "siop_wdtr_neg()");
@


1.31
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.30 2003/10/09 17:32:42 mickey Exp $ */
d772 9
a1428 1
						    (((struct scsi_inquiry_data *)xs->data)->flags2 & SID_CLOCKING) &&
@


1.31.2.1
log
@MFC:
Fix by krw@@

Restore siop's (and possibly others) ability to negotiate tags/wide/sync by
reverting to a single (short) INQUIRY command during probe. Compensate in siop
by trying PPR on all targets on SCSI-3 buses and falling back to WDTR/SDTR if
PPR rejected.

Problem found by mickey@@. Tested on a wide variety of devices by Marco.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.31 2003/10/21 18:58:49 jmc Exp $ */
a771 9
				} else if (msg == MSG_EXTENDED &&
				    extmsg == MSG_EXT_PPR) {
					/* PPR negotiation rejected */
					siop_target->target_c.offset = 0;
					siop_target->target_c.period = 0;
					siop_target->target_c.status = TARST_ASYNC;
					siop_target->target_c.flags &= ~(TARF_DT | TARF_ISDT);
					CALL_SCRIPT(Ent_msgin_ack);
					return 1;
d1420 1
@


1.30
log
@go back to non-raw busdma load as some archs still do not have load_raw
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.29 2003/09/29 18:52:53 mickey Exp $ */
d459 1
a459 1
		 * Can't read sist0 & sist1 independantly, or we have to
d602 1
a602 1
		/* Else it's an unhandled exeption (for now). */
d1175 1
a1175 1
 * target struct and report loosage to upper layer.
d1196 1
a1196 1
	 * Process all commands: first commmands being executed
d1992 1
a1992 1
	 * we need 8 bytes for the lun sw additionnal entry, and
@


1.29
log
@e own SIOP_DEBUG define instea of the system-wide one;
bzero() the sgl before fillig it up;
avoid reading registers extra times where we have a copy in the vars;
on scsi_cmd timeout call siop_handle_reset() directly instead of
    relying on the RST interrupt which does not happen always it semms;
use bus_dmamap_load_raw().
krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.28 2003/07/01 17:15:06 krw Exp $ */
d1742 2
a1743 2
	error = bus_dmamap_load_raw(sc->sc_c.sc_dmat, newcbd->xferdma, &seg,
	    rseg, PAGE_SIZE, BUS_DMA_NOWAIT);
@


1.28
log
@Don't dma map the xs->cmd. Copy it to a safe buffer that is already
mapped and sync'ed appropriately, and is guaranteed to be in one
memory page.

Eliminate now unused dmamap_cmd and rs_cmd fields.

Fix another error message (adding active command to reset list) so
that it includes the adapter name.

Add missing letoh32() calls to debug code.

The evils of directly mapping *xs->cmd were pointed out by Mickey
during osiop development. In particular, *xs->cmd may start on one
memory page and run into the next. Since the dma logic in most
cards/drivers (including siop) only allocates one address/size pair to
map *xs->cmd, parts of a command could be lost or corrupted.

The large number of 6 byte dma mappings noted long ago by someone
(Henric?).  This change reduces the dma mapping activity per i/o by
1/3 to 1/2 and may give a performance boost of some kind.

Successfully tested on i386, sparc64 (ultra30 - thanks Jolan,
blade100), macppc and alpha.

Unfortunately these changes don't fix the Blade1000 siop problems.

**NOTE** If scsi_generic is ever upped to 16 bytes the offsets in
siop.ss must be updated!
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.27 2003/06/28 22:16:55 krw Exp $ */
d56 2
a57 2
#ifndef DEBUG
#undef DEBUG
d468 1
a468 3
		    "DSA=0x%x DSP=0x%lx\n", sist,
		    bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_SSTAT1),
d604 2
a605 3
		    "DSA=0x%x DSP=0x%x\n", sc->sc_c.sc_dev.dv_xname, sist,
		    bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_SSTAT1),
d1656 3
d1660 2
a1661 1
	printf("timeout on SCSI command 0x%x\n", siop_cmd->cmd_c.xs->cmd->opcode);
a1665 8

	/* deactivate callout */
	timeout_del(&siop_cmd->cmd_c.xs->stimeout);
	/*
	 * mark command has being timed out and just return;
	 * the bus reset will generate an interrupt,
	 * it will be handled in siop_intr()
	 */
d1667 1
d1669 1
a1670 1

d1742 2
a1743 2
	error = bus_dmamap_load(sc->sc_c.sc_dmat, newcbd->xferdma, newcbd->xfers,
	    PAGE_SIZE, NULL, BUS_DMA_NOWAIT);
d1749 1
a1749 1
#ifdef DEBUG
d1982 1
a1982 1
#ifdef DEBUG
d2006 1
a2006 1
#ifdef DEBUG
@


1.27
log
@Fix a bug which would promote a target from TARST_PROBING to
TARST_ASYNC if a bus reset occurred while in TARST_PROBING.

Improve DMA IRQ error message to always display the adapter name.

Correct an indent botch.

All of which doesn't help the Blade1000 boot, though it is now both
less noisy and more informative.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.26 2003/06/09 02:28:13 krw Exp $ */
d493 1
a1085 1
	bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd);
d1088 1
d1090 8
a1097 5
		siop_cmd->cmd_c.rs_cmd.opcode = REQUEST_SENSE;
		siop_cmd->cmd_c.rs_cmd.byte2 = xs->sc_link->lun << 5;
		siop_cmd->cmd_c.rs_cmd.unused[0] = siop_cmd->cmd_c.rs_cmd.unused[1] = 0;
		siop_cmd->cmd_c.rs_cmd.length = sizeof(struct scsi_sense_data);
		siop_cmd->cmd_c.rs_cmd.control = 0;
a1098 10
		error = bus_dmamap_load(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd,
		    &siop_cmd->cmd_c.rs_cmd, sizeof(struct scsi_sense),
		    NULL, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to load cmd DMA map "
			    "(for SENSE): %d\n",
			    sc->sc_c.sc_dev.dv_xname, error);
			xs->error = XS_DRIVER_STUFFUP;
			goto out;
		}
a1106 1
			bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd);
a1111 3
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd,
		    0, siop_cmd->cmd_c.dmamap_cmd->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);
d1263 2
a1264 1
		printf("cmd %p (status %d) reset ",
d1367 5
a1372 10
	error = bus_dmamap_load(sc->sc_c.sc_dmat,
	    siop_cmd->cmd_c.dmamap_cmd,
	    xs->cmd, xs->cmdlen, NULL, BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: unable to load cmd DMA map: %d\n",
		    sc->sc_c.sc_dev.dv_xname, error);
		xs->error = XS_DRIVER_STUFFUP;
		splx(s);
		return(TRY_AGAIN_LATER);
	}
d1380 1
a1380 1
			printf("%s: unable to load cmd DMA map: %d\n",
a1382 2
			bus_dmamap_unload(sc->sc_c.sc_dmat,
			    siop_cmd->cmd_c.dmamap_cmd);
a1391 3
	bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd, 0,
	    siop_cmd->cmd_c.dmamap_cmd->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
a1768 10
		error = bus_dmamap_create(sc->sc_c.sc_dmat,
		    sizeof(struct scsi_generic), 1,
		    sizeof(struct scsi_generic), 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &newcbd->cmds[i].cmd_c.dmamap_cmd);
		if (error) {
			printf("%s: unable to create cmd DMA map for cbd %d\n",
			    sc->sc_c.sc_dev.dv_xname, error);
			goto bad0;
		}
d1795 3
@


1.26
log
@Fix erroneous handling of i/o's during a reset.

a) Set xs->status rather than cmd_tables->status because there will be
no interrupt processing to move it from cmd_tables->status to
xs->status.

b) Set cmd_c.status to correct value (CMDST_SENSE_DONE) when an active
sense command is reset.

c) Don't put a reset command from the ready queue into the free_list
twice, once in siop_scsicmd_end() and once manually.

Condition a) meant that the scsi layer was seeing successfully
completed i/o's (xs->error == XS_NOERROR) when they were in fact reset
and should have had xs->error == XS_TIMEOUT or xs->error == XS_RESET.
This meant lost data on output, and random or zero'ed data on input.

Condition b) meant that the wrong bus_dmamap_sync() was called, though
the actual action was apparently identical.

Condition c) meant that the free_list could become corrupt.

The problem was discovered by pb@@ on a heavily loaded server that
experienced timeouts. This fix was tested by pb@@ and henric@@ to prove
it did not affect normal processing. If nothing else it will provide
better error messages if the problem is ever encountered again.

Probably a good candidate for -stable if pb@@ can successfully
reproduce his timeout problems and not have his server crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.25 2003/01/21 00:48:55 krw Exp $ */
d431 22
a452 23
		printf("DMA IRQ:");
		if (dstat & DSTAT_IID)
			printf(" Illegal instruction");
		if (dstat & DSTAT_BF)
			printf(" bus fault");
		if (dstat & DSTAT_MDPE)
			printf(" parity");
		if (dstat & DSTAT_DFE)
			printf(" dma fifo empty");
		else
			siop_clearfifo(&sc->sc_c);
		printf(", DSP=0x%x DSA=0x%x: ",
		    (int)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_DSP) - sc->sc_c.sc_scriptaddr),
		    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA));
		if (siop_cmd)
			printf("last msg_in=0x%x status=0x%x\n",
			    siop_cmd->cmd_tables->msg_in[0],
			    letoh32(siop_cmd->cmd_tables->status));
		else 
			printf("%s: current DSA invalid\n",
			    sc->sc_c.sc_dev.dv_xname);
		need_reset = 1;
d1236 7
a1242 5
		sc->sc_c.targets[target]->status = TARST_ASYNC;
		sc->sc_c.targets[target]->flags &= ~TARF_ISWIDE;
		sc->sc_c.targets[target]->period =
		    sc->sc_c.targets[target]->offset = 0;
		siop_update_xfer_mode(&sc->sc_c, target);
@


1.25
log
@bzero() siop_target structure after malloc().

In combination with previous openings fix makes Niklas happy. Probably
fixes some negotiation bugs too.

Another good candidate for -stable.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.24 2002/12/23 00:42:32 krw Exp $ */
d1230 2
d1233 2
a1234 8
				printf("command with tag id %d reset\n", tag);
				siop_cmd->cmd_c.xs->error =
				    (siop_cmd->cmd_c.flags & CMDFL_TIMEOUT) ?
		    		    XS_TIMEOUT : XS_RESET;
				siop_cmd->cmd_c.xs->status = SCSI_SIOP_NOCHECK;
				siop_lun->siop_tag[tag].active = NULL;
				siop_cmd->cmd_c.status = CMDST_DONE;
				siop_scsicmd_end(siop_cmd);
a1246 4
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
		printf("cmd %p (target %d:%d) in reset list (wait)\n",
		    siop_cmd, siop_cmd->cmd_c.xs->sc_link->target,
		    siop_cmd->cmd_c.xs->sc_link->lun);
d1249 3
d1253 1
a1253 1
	/* Then command waiting in the input list */
a1256 4
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
		printf("cmd %p (target %d:%d) in reset list (wait)\n",
		    siop_cmd, siop_cmd->cmd_c.xs->sc_link->target,
		    siop_cmd->cmd_c.xs->sc_link->lun);
d1259 3
d1267 7
a1273 5
		siop_cmd->cmd_c.xs->error = (siop_cmd->cmd_c.flags & CMDFL_TIMEOUT) ?
		    XS_TIMEOUT : XS_RESET;
		siop_cmd->cmd_tables->status = htole32(SCSI_SIOP_NOCHECK);
		printf("cmd %p (status %d) about to be processed\n", siop_cmd,
		    siop_cmd->cmd_c.status);
d1279 2
a1282 1
		TAILQ_INSERT_TAIL(&sc->free_list, siop_cmd, next);
@


1.25.2.1
log
@MFC:
Fix by krw@@

Fix erroneous handling of i/o's during a reset.

a) Set xs->status rather than cmd_tables->status because there will be
no interrupt processing to move it from cmd_tables->status to
xs->status.

b) Set cmd_c.status to correct value (CMDST_SENSE_DONE) when an active
sense command is reset.

c) Don't put a reset command from the ready queue into the free_list
twice, once in siop_scsicmd_end() and once manually.

Condition a) meant that the scsi layer was seeing successfully
completed i/o's (xs->error == XS_NOERROR) when they were in fact reset
and should have had xs->error == XS_TIMEOUT or xs->error == XS_RESET.
This meant lost data on output, and random or zero'ed data on input.

Condition b) meant that the wrong bus_dmamap_sync() was called, though
the actual action was apparently identical.

Condition c) meant that the free_list could become corrupt.

The problem was discovered by pb@@ on a heavily loaded server that
experienced timeouts. This fix was tested by pb@@ and henric@@ to prove
it did not affect normal processing. If nothing else it will provide
better error messages if the problem is ever encountered again.

Probably a good candidate for -stable if pb@@ can successfully
reproduce his timeout problems and not have his server crash.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.25 2003/01/21 00:48:55 krw Exp $ */
d1230 6
d1237 2
a1238 4
				TAILQ_INSERT_TAIL(&reset_list, siop_cmd, next);
				sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
				printf("cmd %p (tag %d) added to reset list\n",
				    siop_cmd, tag);
d1251 4
a1256 3
		sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
		printf("cmd %p added to reset list from urgent list\n",
		    siop_cmd);
d1258 1
a1258 1
	/* Then commands waiting in the input list. */
d1262 4
a1267 3
		sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
		printf("cmd %p added to reset list from ready list\n",
		    siop_cmd);
d1273 5
a1277 7
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
		siop_cmd->cmd_c.xs->error =
		    (siop_cmd->cmd_c.flags & CMDFL_TIMEOUT)
		    ? XS_TIMEOUT : XS_RESET;
		siop_cmd->cmd_c.xs->status = SCSI_SIOP_NOCHECK;
		printf("cmd %p (status %d) reset ",
		    siop_cmd, siop_cmd->cmd_c.status);
a1282 2
		printf(" with status %d, xs->error %d\n",
		    siop_cmd->cmd_c.status, siop_cmd->cmd_c.xs->error);
d1285 1
@


1.24
log
@Fix complete botch in handling of 'openings'.

Assign a fixed value (SIOP_NTAGS) to the openings field in the
adapter's template sc_link, rather than incrementing the value as
cbd's are allocated. The template value is the one copied into each
device's sc_link structure as it is created.

Incrementing the value meant that each new device got a larger value
for openings. The total number of openings claimed by devices on a
bus soon exceeded the number of cbd's available. e.g. after 5
devices there would be 132 allocated cbd's, but the total number of
openings claimed by devices would be 300.

A heavy i/o load on an adapter with multiple devices could have
caused the upper scsi layer to try to queue more i/o's than the
driver had cbd's to store them in. Such i/o's would fail with EIO if
they were started with SCSI_NOSLEEP (e.g. sdstart()) or were not
queued within the specified retry limit. I/o's for devices 'later'
on the bus would be more likely to trigger this behaviour, due to
their inflated openings values.

This is good candidate for -stable.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.23 2002/11/16 04:37:29 krw Exp $ */
d1336 1
@


1.23
log
@From NetBSD (bouyer@@):

In siop_reset(), reset sc_ntargets to 0. The number of targets will be
computed again in siop_add_reselsw().

In siop_reset(), reset the tag reseloff to 0, in addition to the lun
reseloff. If siop_add_dev() fails this time we would use the old
reseloff, clobbering memory now used for something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.22 2002/09/16 00:53:12 krw Exp $ */
d178 1
a1863 1
	sc->sc_c.sc_link.openings += SIOP_NCMDPB;
@


1.22
log
@Resync siop with NetBSD. Make strong effort to minimize
differences, undoing whitespace, spelling, etc. changes
and adopting the NetBSD code instead of equivalent home
grown code for PPR negotiation, etc.

siop.c            1.21 -> 1.64
siop_common.c     1.12 -> 1.30
siopreg.h         1.7  -> 1.13
siopvar.h         1.13 -> 1.18
siopvar_common.h  1.10 -> 1.21
ncr53cxxx.c       1.5  -> 1.10
siop.ss           1.12 -> 1.17
siop_pci.c        1.8  -> 1.11
siop_pci_common.c 1.6  -> 1.17
siop_pci_common.h 1.2  -> 1.4

Many fixes, add 1010-66 support, restructure things to prepare for
addition of esiop, osiop and oosiop drivers.

tested on various archs by art@@, millert@@, wilfried@@, jason@@,
Dan Weeks.

ok deraadt@@.
@
text
@d1 2
a2 2
/*	$OpenBSD: siop.c,v 1.21 2002/07/20 11:22:27 art Exp $ */
/*	$NetBSD: siop.c,v 1.64 2002/07/26 01:00:43 wiz Exp $	*/
d266 1
d1932 1
a1932 1
	int i;
d1969 2
@


1.22.2.1
log
@Pull in patches from current:
Fix (krw):
---
Fix complete botch in handling of 'openings'.

Assign a fixed value (SIOP_NTAGS) to the openings field in the
adapter's template sc_link, rather than incrementing the value as
cbd's are allocated. The template value is the one copied into each
device's sc_link structure as it is created.

Incrementing the value meant that each new device got a larger value
for openings. The total number of openings claimed by devices on a
bus soon exceeded the number of cbd's available. e.g. after 5
devices there would be 132 allocated cbd's, but the total number of
openings claimed by devices would be 300.

A heavy i/o load on an adapter with multiple devices could have
caused the upper scsi layer to try to queue more i/o's than the
driver had cbd's to store them in. Such i/o's would fail with EIO if
they were started with SCSI_NOSLEEP (e.g. sdstart()) or were not
queued within the specified retry limit. I/o's for devices 'later'
on the bus would be more likely to trigger this behaviour, due to
their inflated openings values.

This is good candidate for -stable.
---
bzero() siop_target structure after malloc().

In combination with previous openings fix makes Niklas happy. Probably
fixes some negotiation bugs too.

Another good candidate for -stable.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.25 2003/01/21 00:48:55 krw Exp $ */
a177 1
	sc->sc_c.sc_link.openings = SIOP_NTAG;
a1333 1
		bzero(sc->sc_c.targets[target], sizeof(struct siop_target));
d1862 1
@


1.21
log
@If we call siop_intr manually, make sure it's protected by splbio.
My filesystem has been chopped to pieces.
@
text
@d1 2
a2 2
/*	$OpenBSD: siop.c,v 1.20 2002/06/09 02:11:47 jsyn Exp $ */
/*	$NetBSD: siop.c,v 1.39 2001/02/11 18:04:49 bouyer Exp $	*/
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer
d53 1
a54 1
#include <dev/ic/siopvar_common.h>
d74 1
a74 1
/* number of scheduler slots (needs to match script) */
d85 1
a85 1
int	siop_morecbd(struct siop_softc *);
d88 1
a88 1
void	siop_update_scntl3(struct siop_softc *, struct siop_target *);
d128 3
a130 3
	if ((sc->features & SF_CHIP_RAM) == 0)
		bus_dmamap_sync(sc->sc_dmat, sc->sc_scriptdma,
		    0, PAGE_SIZE, ops);
d139 3
a141 2
	if (sc->features & SF_CHIP_RAM) {
		return bus_space_read_4(sc->sc_ramt, sc->sc_ramh, offset * 4);
d143 1
a143 1
		return letoh32(sc->sc_script[offset]);
d155 3
a157 2
	if (sc->features & SF_CHIP_RAM) {
		bus_space_write_4(sc->sc_ramt, sc->sc_ramh, offset * 4, val);
d159 1
a159 1
		sc->sc_script[offset] = htole32(val);
d167 2
a168 3
	int error, i;
	bus_dma_segment_t seg;
	int rseg;
a169 35
	/*
	 * Allocate DMA-safe memory for the script and map it.
	 */
	if ((sc->features & SF_CHIP_RAM) == 0) {
		error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, 
		    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to allocate script DMA memory, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return;
		}
		error = bus_dmamem_map(sc->sc_dmat, &seg, rseg, PAGE_SIZE,
		    (caddr_t *)&sc->sc_script, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
		if (error) {
			printf("%s: unable to map script DMA memory, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return;
		}
		error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1,
		    PAGE_SIZE, 0, BUS_DMA_NOWAIT, &sc->sc_scriptdma);
		if (error) {
			printf("%s: unable to create script DMA map, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return;
		}
		error = bus_dmamap_load(sc->sc_dmat, sc->sc_scriptdma,
		    sc->sc_script, PAGE_SIZE, NULL, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: unable to load script DMA map, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			return;
		}
		sc->sc_scriptaddr = sc->sc_scriptdma->dm_segs[0].ds_addr;
		sc->ram_size = PAGE_SIZE;
	}
d176 6
d184 2
a185 2
	    sc->sc_dev.dv_xname, (int)sizeof(siop_script),
	    (u_int32_t)sc->sc_scriptaddr, sc->sc_script);
a186 45
	/* Start with one page worth of commands */
	siop_morecbd(sc);

	/*
	 * sc->sc_link is the template for all device sc_link's
	 * for devices attached to this adapter. It is passed to
	 * the upper layers in config_found().
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.openings = SIOP_OPENINGS;
	sc->sc_link.adapter_buswidth =
	    (sc->features & SF_BUS_WIDE) ? 16 : 8;
	sc->sc_link.adapter_target = bus_space_read_1(sc->sc_rt,
	    sc->sc_rh, SIOP_SCID);
	if (sc->sc_link.adapter_target == 0 ||
	    sc->sc_link.adapter_target >=
	    sc->sc_link.adapter_buswidth)
		sc->sc_link.adapter_target = SIOP_DEFAULT_TARGET;
	sc->sc_link.adapter = &siop_adapter;
	sc->sc_link.device = &siop_dev;
	sc->sc_link.flags  = 0;
	sc->sc_link.quirks = 0;
	if ((sc->features & SF_BUS_WIDE) == 0)
	  sc->sc_link.quirks |= SDEV_NOWIDE;

	for (i = 0; i < 16; i++)
		sc->targets[i] = NULL;

	/* find min_dt_sync and min_st_sync for this chip */
	sc->min_dt_sync = 0;
	for (i = 0; i < sizeof(period_factor) / sizeof(period_factor[0]); i++)
		if (period_factor[i].scf[sc->scf_index].dt_scf != 0) {
			sc->min_dt_sync = period_factor[i].factor;
			break;
		}

	sc->min_st_sync = 0;
	for (i = 0; i < sizeof(period_factor) / sizeof(period_factor[0]); i++)
		if (period_factor[i].scf[sc->scf_index].st_scf != 0) {
			sc->min_st_sync = period_factor[i].factor;
			break;
		}

	if (sc->min_st_sync == 0)
		panic("%s: can't find minimum allowed sync period factor\n", sc->sc_dev.dv_xname);
d189 1
a189 1
	siop_resetbus(sc);
d198 1
a198 1
	config_found((struct device*)sc, &sc->sc_link, scsiprint);
d208 1
a208 1
	siop_common_reset(sc);
d211 2
a212 2
	if (sc->features & SF_CHIP_RAM) {
		bus_space_write_region_4(sc->sc_ramt, sc->sc_ramh, 0,
d217 1
a217 1
			bus_space_write_4(sc->sc_ramt, sc->sc_ramh,
d219 15
a233 1
			    sc->sc_scriptaddr + Ent_msgin_space);
d238 1
a238 1
			sc->sc_script[j] = htole32(siop_script[j]);
d243 19
a261 2
			sc->sc_script[E_abs_msgin_Used[j]] =
			    htole32(sc->sc_scriptaddr + Ent_msgin_space);
d265 1
a265 1
	sc->script_free_hi = sc->ram_size / 4;
d271 1
a271 1
				sc->sc_dev.dv_xname, lunsw->lunsw_off);
d278 3
a280 2
	for (i = 0; i < sc->sc_link.adapter_buswidth; i++) {
		if (sc->targets[i] == NULL)
d284 1
a284 1
				sc->sc_dev.dv_xname, i);
d286 4
a289 3
		free(sc->targets[i]->lunsw, M_DEVBUF);
		sc->targets[i]->lunsw = siop_get_lunsw(sc);
		if (sc->targets[i]->lunsw == NULL) {
d291 1
a291 1
			    sc->sc_dev.dv_xname, i);
d298 6
a303 3
	siop_script_sync(sc, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	bus_space_write_4(sc->sc_rt, sc->sc_rh, SIOP_DSP,
	    sc->sc_scriptaddr + Ent_reselect);
d309 3
a311 3
	    siop_cmd->dsa, \
	    sc->sc_scriptaddr + ent); \
bus_space_write_4(sc->sc_rt, sc->sc_rh, SIOP_DSP, sc->sc_scriptaddr + ent); \
d315 1
a315 1
bus_space_write_4(sc->sc_rt, sc->sc_rh, SIOP_DSP, sc->sc_scriptaddr + ent); \
d328 2
a329 2
	int istat, sist = 0, sstat1 = 0, dstat = 0;
	u_int32_t irqcode = 0;
d337 1
a337 1
	istat = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_ISTAT);
d343 8
a350 1
		bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_ISTAT, ISTAT_INTF);
d353 1
a353 1
	dsa = bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSA);
d369 5
a373 5
		xs = siop_cmd->xs;
		siop_target = siop_cmd->siop_target;
		target = siop_cmd->xs->sc_link->target;
		lun = siop_cmd->xs->sc_link->lun;
		tag = siop_cmd->tag;
d376 5
a380 4
		if (siop_cmd->status != CMDST_ACTIVE &&
		    siop_cmd->status != CMDST_SENSE_ACTIVE) {
			printf("siop_cmd (lun %d) not active (%d)\n",
				lun, siop_cmd->status);
d403 8
a410 1
		dstat = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_DSTAT);
d413 5
a417 3
			    (int)(bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSP) -
			    sc->sc_scriptaddr),
			    bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSA));
d420 4
a423 3
				bus_space_write_1(sc->sc_rt, sc->sc_rh,
				    SIOP_DCNTL, bus_space_read_1(sc->sc_rt,
				    sc->sc_rh, SIOP_DCNTL) | DCNTL_STD);
d427 1
d429 23
a451 23
			printf("DMA IRQ:");
			if (dstat & DSTAT_IID)
				printf("Illegal instruction");
			if (dstat & DSTAT_ABRT)
				printf(" abort");
			if (dstat & DSTAT_BF)
				printf(" bus fault");
			if (dstat & DSTAT_MDPE)
				printf(" parity");
			if (dstat & DSTAT_DFE)
				printf(" dma fifo empty");
			printf(", DSP=0x%x DSA=0x%x: ",
			    (int)(bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSP) -
				sc->sc_scriptaddr),
			    bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSA));
			if (siop_cmd)
				printf("last msg_in=0x%x status=0x%x\n",
				    siop_cmd->siop_tables.msg_in[0],
				    letoh32(siop_cmd->siop_tables.status));
			else 
				printf("%s: current DSA invalid\n",
				    sc->sc_dev.dv_xname);
			need_reset = 1;
d461 4
a464 2
		sist = bus_space_read_2(sc->sc_rt, sc->sc_rh, SIOP_SIST0);
		sstat1 = bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SSTAT1);
d468 6
a473 4
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SSTAT1),
		    bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSA),
		    (u_long)(bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSP) -
		    sc->sc_scriptaddr));
d485 1
a485 1
				printf("%s:", sc->sc_dev.dv_xname);
d492 2
a493 2
				dstat = bus_space_read_1(sc->sc_rt, sc->sc_rh,
				    SIOP_DSTAT);
d498 5
a502 4
				bus_space_write_4(sc->sc_rt, sc->sc_rh,
				    SIOP_DSA, siop_cmd->dsa);
				scratcha0 = bus_space_read_1(sc->sc_rt,
				    sc->sc_rh, SIOP_SCRATCHA);
d506 2
a507 2
				 * Previous phase may have aborted for any reason
				 * (for example, the target has less data to
d513 1
a513 1
						siop_clearfifo(sc);
d519 1
a519 1
					 * Target may be ready to disconnect.
d524 1
a524 1
						siop_sdp(siop_cmd);
d526 3
a528 3
						siop_clearfifo(sc);
					bus_space_write_1(sc->sc_rt, sc->sc_rh,
					    SIOP_SCRATCHA,
d537 1
a537 1
				    sc->sc_dev.dv_xname,
d541 1
a541 1
				    sc->sc_dev.dv_xname);
d550 1
a550 1
				printf("%s:", sc->sc_dev.dv_xname);
d557 1
a557 1
				siop_cmd->status = CMDST_DONE;
d563 1
a563 1
				    "command\n", sc->sc_dev.dv_xname);
d573 1
a573 1
				siop_cmd->siop_tables.status =
d578 1
a578 1
			    "command\n", sc->sc_dev.dv_xname);
d583 1
a583 1
			if (siop_modechange(sc) == 0 || need_reset == 1)
d587 1
a587 1
				 * We have a script interrupt. It will
d593 1
a593 1
			 * Else we have to restart the script ourself, at the
d596 3
a598 2
			bus_space_write_4(sc->sc_rt, sc->sc_rh, SIOP_DSP,
			    bus_space_read_4(sc->sc_rt, sc->sc_rh,
d602 1
a602 1
		/* Else it's an unhandled exception (for now). */
d604 6
a609 5
		    "DSA=0x%x DSP=0x%x\n", sc->sc_dev.dv_xname, sist,
		    bus_space_read_1(sc->sc_rt, sc->sc_rh, SIOP_SSTAT1),
		    bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSA),
		    (int)(bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSP) -
		    sc->sc_scriptaddr));
d611 1
a611 1
			siop_cmd->status = CMDST_DONE;
d620 1
a620 1
		siop_resetbus(sc);
d627 1
a627 1
		irqcode = bus_space_read_4(sc->sc_rt, sc->sc_rh,
d638 3
a640 3
				printf("%s: script interrupt (0x%x) with "
				    "invalid DSA !!!\n", sc->sc_dev.dv_xname,
				    irqcode);
d643 2
a644 2
			if (siop_cmd->status != CMDST_ACTIVE &&
			    siop_cmd->status != CMDST_SENSE_ACTIVE) {
d647 2
a648 2
				    sc->sc_dev.dv_xname,
				    irqcode, siop_cmd->status);
d655 2
a656 2
			    (int)(bus_space_read_4(sc->sc_rt, sc->sc_rh,
			    SIOP_DSP) - sc->sc_scriptaddr));
d665 1
a665 1
				    sc->sc_dev.dv_xname);
d669 3
a671 3
			target = bus_space_read_1(sc->sc_rt, sc->sc_rh,
			    SIOP_SCRATCHA) & 0xf;
			lun = bus_space_read_1(sc->sc_rt, sc->sc_rh,
d673 1
a673 1
			tag = bus_space_read_1(sc->sc_rt, sc->sc_rh,
d675 2
a676 1
			siop_target = sc->targets[target];
d678 2
a679 2
				printf("%s: reselect with invalid "
				    "target %d\n", sc->sc_dev.dv_xname, target);
d685 1
a685 1
				    "lun %d\n", sc->sc_dev.dv_xname,
d691 2
a692 1
				    "without command\n", sc->sc_dev.dv_xname,
d697 3
a699 2
			bus_space_write_4(sc->sc_rt, sc->sc_rh, SIOP_DSP,
			    siop_cmd->dsa + sizeof(struct siop_xfer_common) +
d705 1
a705 1
				    sc->sc_dev.dv_xname);
d709 2
a710 2
			int msgin = bus_space_read_1(sc->sc_rt, sc->sc_rh,
			    SIOP_SFBR);
d713 1
a713 1
				if (siop_cmd->siop_tables.msg_out[0] & 0x80) {
d715 1
a715 1
					 * Message was part of an identify +
d719 2
a720 1
					msg = siop_cmd->siop_tables.msg_out[1];
d722 1
a722 1
					    siop_cmd->siop_tables.msg_out[3];
d724 1
a724 1
					msg = siop_cmd->siop_tables.msg_out[0];
d726 1
a726 1
					    siop_cmd->siop_tables.msg_out[2];
d729 1
a729 1
					/* MSG_REJECT for a MSG_REJECT! */
d734 1
a734 1
						   sc->sc_dev.dv_xname);
d741 7
a747 4
					if ((siop_target->flags & TARF_SYNC)
					    == 0) {
						siop_target->status = TARST_OK;
						siop_print_info(sc, target);
d752 5
a756 3
					siop_target->status = TARST_SYNC_NEG;
					siop_sdtr_msg(siop_cmd, 0,
					    sc->min_st_sync, sc->maxoff);
d764 6
a769 2
					siop_target->status = TARST_OK;
					siop_print_info(sc, target);
d785 2
a786 1
					printf("%s: ", sc->sc_dev.dv_xname);
d801 1
a801 1
				printf("%s: ", sc->sc_dev.dv_xname);
d803 3
a805 3
			    siop_cmd->siop_tables.msg_in[0]);
			siop_cmd->siop_tables.msg_out[0] = MSG_MESSAGE_REJECT;
			siop_cmd->siop_tables.t_msgout.count= htole32(1);
d814 2
a815 2
			    siop_cmd->siop_tables.msg_in[2], 
			    siop_cmd->siop_tables.msg_in[1]);
d817 2
a818 1
			if (siop_cmd->siop_tables.msg_in[1] > 6)
d820 4
a823 4
				    sc->sc_dev.dv_xname,
				    siop_cmd->siop_tables.msg_in[1]);
			siop_cmd->siop_tables.t_extmsgdata.count =
			    htole32(siop_cmd->siop_tables.msg_in[1] - 1);
a828 1
		{
d833 2
a834 2
			    siop_cmd->siop_tables.msg_in[2]);
			for (i = 3; i < 2 + siop_cmd->siop_tables.msg_in[1];
d837 1
a837 1
				    siop_cmd->siop_tables.msg_in[i]);
d841 41
a881 19
			int neg_action = SIOP_NEG_NOP;
			const char *neg_name = "";

			switch (siop_cmd->siop_tables.msg_in[2]) {
			case MSG_EXT_WDTR:
				neg_action = siop_wdtr_neg(siop_cmd);
				neg_name = "wdtr";
				break;
			case MSG_EXT_SDTR:
				neg_action = siop_sdtr_neg(siop_cmd);
				neg_name = "sdtr";
				break;
			case MSG_EXT_PPR:
				neg_action = siop_ppr_neg(siop_cmd);
				neg_name = "ppr";
				break;
			default:
				neg_action = SIOP_NEG_MSGREJ;
				break;
d883 20
a902 25

			switch (neg_action) {
			case SIOP_NEG_NOP:
				break;
			case SIOP_NEG_MSGOUT:
				siop_update_scntl3(sc, siop_cmd->siop_target);
				siop_table_sync(siop_cmd,
				    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
				CALL_SCRIPT(Ent_send_msgout);
				break;
			case SIOP_NEG_ACK:
				siop_update_scntl3(sc, siop_cmd->siop_target);
				siop_table_sync(siop_cmd,
				    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
				CALL_SCRIPT(Ent_msgin_ack);
				break;
			case SIOP_NEG_MSGREJ:
				siop_cmd->siop_tables.msg_out[0] = MSG_MESSAGE_REJECT;
				siop_cmd->siop_tables.t_msgout.count = htole32(1);
				siop_table_sync(siop_cmd,
				    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
				CALL_SCRIPT(Ent_send_msgout);
				break;
			default:
				panic("invalid return value from siop_%s_neg(): 0x%x", neg_name, neg_action);
d904 7
a910 4
			
			return (1);
		}

d913 2
a914 2
			offset = bus_space_read_1(sc->sc_rt, sc->sc_rh,
			    SIOP_SCRATCHA + 1);
d920 1
a920 1
				    sc->sc_dev.dv_xname, offset);
d926 1
a926 1
			 * Don't call memmove in this case.
d929 3
a931 3
				bcopy(&siop_cmd->siop_tables.data[offset],
				    &siop_cmd->siop_tables.data[0],
				    (SIOP_NSG - offset) * sizeof(struct scr_table));
a934 1
			CALL_SCRIPT(Ent_script_sched);
d937 1
d941 2
d948 3
a950 2
				    sc->sc_dev.dv_xname, (u_long)siop_cmd->dsa);
				siop_cmd->status = CMDST_FREE;
d957 4
a960 4
			    "in=0x%x status=0x%x\n", (u_long)siop_cmd->dsa,
			    letoh32(siop_cmd->siop_tables.id),
			    siop_cmd->siop_tables.msg_in[0],
			    letoh32(siop_cmd->siop_tables.status));
d963 2
a964 2
			if (siop_cmd->status == CMDST_SENSE_ACTIVE)
				siop_cmd->status = CMDST_SENSE_DONE;
d966 1
a966 1
				siop_cmd->status = CMDST_DONE;
d983 1
a983 1
	    sc->sc_dev.dv_xname,
d989 3
a991 3
	 * Restart the script now if command completed properly.
	 * Otherwise wait for siop_scsicmd_end(), it may need to put
	 * a cmd at the front of the queue.
d993 2
a994 2
	if (letoh32(siop_cmd->siop_tables.status) == SCSI_OK &&
	    TAILQ_FIRST(&sc->urgent_list) != NULL)
d998 1
d1000 2
a1001 7
	siop_lun->siop_tag[tag].active = NULL;
	if (siop_cmd->status == CMDST_FREE) {
		TAILQ_INSERT_TAIL(&sc->free_list, siop_cmd, next);
		siop_lun->lun_flags &= ~SIOP_LUNF_FULL;
		if (freetarget && siop_target->status == TARST_PROBING)
			siop_del_dev(sc, target, lun);
	}
d1012 4
a1015 2
	struct scsi_xfer *xs = siop_cmd->xs;
	struct siop_softc *sc = siop_cmd->siop_sc;
d1017 7
a1023 1
	switch(letoh32(siop_cmd->siop_tables.status)) {
d1025 1
a1025 1
		xs->error = (siop_cmd->status == CMDST_DONE) ?
d1032 1
a1032 1
		if (siop_cmd->status == CMDST_SENSE_DONE) {
d1037 1
a1037 1
			siop_cmd->status = CMDST_SENSE;
a1040 3
		{
		struct siop_lun *siop_lun = siop_cmd->siop_target->siop_lun[
		    xs->sc_link->lun];
d1051 1
a1051 1
		printf("%s:%d:%d: queue full (tag %d)\n", sc->sc_dev.dv_xname,
d1053 1
a1053 1
		    xs->sc_link->lun, siop_cmd->tag);
a1054 1
		timeout_del(&xs->stimeout);
d1056 3
a1058 2
		siop_cmd->status = CMDST_READY;
		siop_setuptables(siop_cmd);
a1060 1
		}
d1076 1
a1076 1
	if (siop_cmd->status != CMDST_SENSE_DONE &&
d1078 2
a1079 2
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1082 1
a1082 1
		bus_dmamap_unload(sc->sc_dmat, siop_cmd->dmamap_data);
d1084 2
a1085 2
	bus_dmamap_unload(sc->sc_dmat, siop_cmd->dmamap_cmd);
	if (siop_cmd->status == CMDST_SENSE) {
d1088 8
a1095 8
		siop_cmd->rs_cmd.opcode = REQUEST_SENSE;
		siop_cmd->rs_cmd.byte2 = xs->sc_link->lun << 5;
		siop_cmd->rs_cmd.unused[0] = siop_cmd->rs_cmd.unused[1] = 0;
		siop_cmd->rs_cmd.length = sizeof(struct scsi_sense_data);
		siop_cmd->rs_cmd.control = 0;
		siop_cmd->flags &= ~CMDFL_TAG;
		error = bus_dmamap_load(sc->sc_dmat, siop_cmd->dmamap_cmd,
		    &siop_cmd->rs_cmd, sizeof(struct scsi_sense),
d1100 1
a1100 1
			    sc->sc_dev.dv_xname, error);
d1104 1
a1104 1
		error = bus_dmamap_load(sc->sc_dmat, siop_cmd->dmamap_data,
d1110 1
a1110 1
			    sc->sc_dev.dv_xname, error);
d1112 1
a1112 1
			bus_dmamap_unload(sc->sc_dmat, siop_cmd->dmamap_cmd);
d1115 2
a1116 2
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1118 2
a1119 2
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
		    0, siop_cmd->dmamap_cmd->dm_mapsize,
d1122 2
a1123 1
		siop_setuptables(siop_cmd);
d1127 3
a1129 3
	} else if (siop_cmd->status == CMDST_SENSE_DONE) {
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1131 1
a1131 1
		bus_dmamap_unload(sc->sc_dmat, siop_cmd->dmamap_data);
d1134 1
a1134 2
	timeout_del(&siop_cmd->xs->stimeout);
	siop_cmd->status = CMDST_FREE;
d1136 2
d1150 6
a1155 5
	struct siop_softc *sc = siop_cmd->siop_sc;
	int target = siop_cmd->xs->sc_link->target;
	int lun = siop_cmd->xs->sc_link->lun;
	int tag = siop_cmd->siop_tables.msg_out[2];
	struct siop_lun *siop_lun = sc->targets[target]->siop_lun[lun];
d1159 2
a1160 2
	    sc->sc_dev.dv_xname, target, lun, tag, siop_cmd->tag,
	    siop_cmd->status);
d1165 2
a1166 2
		    "lun %d (status %d)\n", sc->sc_dev.dv_xname, target, lun,
		    siop_lun->siop_tag[0].active->status);
d1173 1
a1173 1
	siop_cmd->tag = 0;
d1178 1
a1178 1
		    siop_cmd->dsa + sizeof(struct siop_xfer_common) +
d1186 3
a1188 3
 * Handle a bus reset: reset chip, unqueue all active commands, free all
 * target structs and report losage to upper layer.
 * As the upper layer may requeue immediately we have to first store
d1200 2
a1201 2
	 * SCSI bus reset. Reset the chip and restart
	 * the queue. Need to clean up all active commands.
d1203 1
a1203 1
	printf("%s: scsi bus reset\n", sc->sc_dev.dv_xname);
d1210 1
a1210 1
	for (target = 0; target < sc->sc_link.adapter_buswidth;
d1212 1
a1212 1
		if (sc->targets[target] == NULL)
d1215 3
a1217 1
			siop_lun = sc->targets[target]->siop_lun[lun];
d1222 1
a1222 1
			    ((sc->targets[target]->flags & TARF_TAG) ?
d1228 6
a1233 3
				printf("cmd %p (target %d:%d) in reset list\n",
				    siop_cmd, target, lun);
				TAILQ_INSERT_TAIL(&reset_list, siop_cmd, next);
d1235 2
d1239 5
a1243 2
		sc->targets[target]->status = TARST_ASYNC;
		sc->targets[target]->flags  = 0;
d1249 1
a1249 1
		siop_cmd->flags &= ~CMDFL_TAG;
d1251 2
a1252 2
		    siop_cmd, siop_cmd->xs->sc_link->target,
		    siop_cmd->xs->sc_link->lun);
d1260 1
a1260 1
		siop_cmd->flags &= ~CMDFL_TAG;
d1262 2
a1263 2
		    siop_cmd, siop_cmd->xs->sc_link->target,
		    siop_cmd->xs->sc_link->lun);
d1271 1
a1271 1
		siop_cmd->xs->error = (siop_cmd->flags & CMDFL_TIMEOUT) ?
d1273 1
a1273 1
		siop_cmd->siop_tables.status = htole32(SCSI_SIOP_NOCHECK);
d1275 4
a1278 4
		    siop_cmd->status);
		if (siop_cmd->status == CMDST_SENSE ||
		    siop_cmd->status == CMDST_SENSE_ACTIVE) 
			siop_cmd->status = CMDST_SENSE_DONE;
d1280 1
a1280 1
			siop_cmd->status = CMDST_DONE;
d1293 1
d1300 1
a1300 1
	printf("starting cmd 0x%02x for %d:%d\n", xs->cmd->opcode, target, lun);
d1303 1
a1303 3
	if (siop_cmd != NULL) {
		TAILQ_REMOVE(&sc->free_list, siop_cmd, next);
	} else {
d1308 1
d1314 1
a1314 1
	if (siop_cmd->status != CMDST_FREE)
d1317 2
a1318 1
	if (sc->targets[target] == NULL) {
d1321 1
a1321 1
			sc->sc_dev.dv_xname, target);
d1323 7
a1329 5
		sc->targets[target] =
		    malloc(sizeof(struct siop_target), M_DEVBUF, M_NOWAIT);
		if (sc->targets[target] == NULL) {
			printf("%s: can't malloc memory for target %d\n",
			    sc->sc_dev.dv_xname, target);
d1334 8
a1341 5
		sc->targets[target]->status = TARST_PROBING;
		sc->targets[target]->flags  = 0;
		sc->targets[target]->id = sc->clock_div << 24; /* scntl3 */
		sc->targets[target]->id |=  target << 16; /* id */
		/* sc->targets[target]->id |= 0x0 << 8; scxfer is 0 */
d1344 2
a1345 2
		sc->targets[target]->lunsw = siop_get_lunsw(sc);
		if (sc->targets[target]->lunsw == NULL) {
d1347 1
a1347 1
			    sc->sc_dev.dv_xname, target);
d1353 1
a1353 1
			sc->targets[target]->siop_lun[i] = NULL;
d1356 8
a1363 7

	if (sc->targets[target]->siop_lun[lun] == NULL) {
		sc->targets[target]->siop_lun[lun] =
		    malloc(sizeof(struct siop_lun), M_DEVBUF, M_NOWAIT);
		if (sc->targets[target]->siop_lun[lun] == NULL) {
			printf("%s: can't alloc siop_lun for target %d "
			    "lun %d\n", sc->sc_dev.dv_xname, target, lun);
d1368 1
a1368 2
		memset(sc->targets[target]->siop_lun[lun], 0,
		    sizeof(struct siop_lun));
d1370 4
a1373 4
	siop_cmd->siop_target = sc->targets[target];
	siop_cmd->xs = xs;
	siop_cmd->flags = 0;
	siop_cmd->status = CMDST_READY;
d1376 2
a1377 1
	error = bus_dmamap_load(sc->sc_dmat, siop_cmd->dmamap_cmd,
d1381 1
a1381 1
		    sc->sc_dev.dv_xname, error);
d1387 5
a1391 2
		error = bus_dmamap_load(sc->sc_dmat, siop_cmd->dmamap_data,
		    xs->data, xs->datalen, NULL, BUS_DMA_NOWAIT);
d1394 1
a1394 1
			    sc->sc_dev.dv_xname, error);
d1396 2
a1397 1
			bus_dmamap_unload(sc->sc_dmat, siop_cmd->dmamap_cmd);
d1401 3
a1403 2
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1407 2
a1408 2
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
	    0, siop_cmd->dmamap_cmd->dm_mapsize,
d1411 3
a1413 1
	siop_setuptables(siop_cmd);
d1429 1
a1429 1
						 * worth of commands. Do this statically now because 
d1436 8
a1443 2
						if (sc->targets[target]->status == TARST_PROBING)
							sc->targets[target]->status = TARST_ASYNC;
d1445 1
d1475 1
d1489 1
a1489 1
	 * at the slots from first to last, so if we always use the first 
d1517 2
a1518 2
		if (siop_cmd->status != CMDST_READY &&
		    siop_cmd->status != CMDST_SENSE)
d1521 4
a1524 3
		target = siop_cmd->xs->sc_link->target;
		lun = siop_cmd->xs->sc_link->lun;
		siop_lun = sc->targets[target]->siop_lun[lun];
d1533 1
a1533 1
		    siop_cmd->status == CMDST_READY)
d1536 1
a1536 1
		if (siop_cmd->flags & CMDFL_TAG) {
d1546 1
a1546 1
		siop_cmd->tag = tag;
d1551 1
a1551 1
		if (siop_cmd->status != CMDST_SENSE) {
d1574 1
a1574 1
		    (u_long)siop_cmd->dsa);
d1580 1
a1580 1
			    letoh32(siop_cmd->siop_tables.t_msgout.count);
d1583 1
a1583 1
				    sc->sc_dev.dv_xname, target, lun, tag,
d1586 3
a1588 3
			if (siop_cmd->xs->bp != NULL &&
			    (siop_cmd->xs->bp->b_flags & B_ASYNC))
				siop_cmd->siop_tables.msg_out[1] =
d1591 1
a1591 1
				siop_cmd->siop_tables.msg_out[1] =
d1593 2
a1594 2
			siop_cmd->siop_tables.msg_out[2] = tag;
			siop_cmd->siop_tables.t_msgout.count = htole32(3);
d1599 4
a1602 4
		if (siop_cmd->status == CMDST_READY) {
			siop_cmd->status = CMDST_ACTIVE;
		} else if (siop_cmd->status == CMDST_SENSE) {
			siop_cmd->status = CMDST_SENSE_ACTIVE;
d1611 1
a1611 1
		dsa = siop_cmd->dsa;
d1616 1
a1616 1
			    dsa + sizeof(struct siop_xfer_common) +
d1619 3
a1621 3
		siop_cmd->siop_xfer->resel[E_ldsa_abs_slot_Used[0]] = 
		   htole32(sc->sc_scriptaddr + Ent_script_sched_slot0 +
		   slot * 8);
d1626 1
a1626 1
		    dsa + sizeof(struct siop_xfer_common) + Ent_ldsa_select);
d1628 2
a1629 2
		if (siop_cmd->status == CMDST_ACTIVE) {
			if ((siop_cmd->xs->flags & SCSI_POLL) == 0) {
d1631 1
a1631 1
				timeout = (u_int64_t) siop_cmd->xs->timeout *
d1635 1
a1635 1
				timeout_add(&siop_cmd->xs->stimeout, timeout);
d1663 2
a1664 1
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_ISTAT, ISTAT_SIGP);
d1674 1
a1674 1
	struct siop_softc *sc = siop_cmd->siop_sc;
d1677 2
a1678 2
	sc_print_addr(siop_cmd->xs->sc_link);
	printf("timeout on SCSI command 0x%x\n", siop_cmd->xs->cmd->opcode);
d1682 1
a1682 1
	siop_resetbus(sc);
d1685 1
a1685 1
	timeout_del(&siop_cmd->xs->stimeout);
d1687 3
a1689 3
	 * Mark command as being timed out and just return. The bus
	 * reset will generate an interrupt, which will be handled
	 * in siop_intr().
d1691 1
a1691 1
	siop_cmd->flags |= CMDFL_TIMEOUT;
d1704 4
a1707 2
		    letoh32(sc->sc_script[i]), letoh32(sc->sc_script[i+1]));
		if ((letoh32(sc->sc_script[i]) & 0xe0000000) == 0xc0000000) {
d1709 1
a1709 1
			printf(" 0x%08x", letoh32(sc->sc_script[i+1]));
d1715 1
a1715 1
int
d1719 1
a1719 1
	int error, i, j;
d1723 1
d1731 2
a1732 2
		    "head\n", sc->sc_dev.dv_xname);
		return ENOMEM;
d1734 1
a1734 1
	memset(newcbd, 0, sizeof(struct siop_cbd));
d1737 2
a1738 2
	newcbd->cmds =
	    malloc(sizeof(struct siop_cmd) * SIOP_NCMDPB, M_DEVBUF, M_NOWAIT);
d1741 1
a1741 2
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
d1744 2
a1745 2
	memset(newcbd->cmds, 0, sizeof(struct siop_cmd) * SIOP_NCMDPB);
	error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, PAGE_SIZE, 0, &seg,
d1749 1
a1749 1
		    sc->sc_dev.dv_xname, error);
d1752 1
a1752 1
	error = bus_dmamem_map(sc->sc_dmat, &seg, rseg, PAGE_SIZE,
d1756 1
a1756 1
		    sc->sc_dev.dv_xname, error);
d1759 1
a1759 1
	error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1, PAGE_SIZE, 0,
d1763 1
a1763 1
		    sc->sc_dev.dv_xname, error);
d1766 1
a1766 1
	error = bus_dmamap_load(sc->sc_dmat, newcbd->xferdma, newcbd->xfers,
d1770 1
a1770 1
		    sc->sc_dev.dv_xname, error);
d1774 1
a1774 1
	printf("%s: alloc newcdb at PHY addr 0x%lx\n", sc->sc_dev.dv_xname,
a1776 1

d1778 1
a1778 1
		error = bus_dmamap_create(sc->sc_dmat, MAXPHYS, SIOP_NSG,
d1780 1
a1780 1
		    &newcbd->cmds[i].dmamap_data);
d1784 1
a1784 1
			    sc->sc_dev.dv_xname, error);
d1787 1
a1787 1
		error = bus_dmamap_create(sc->sc_dmat,
d1791 1
a1791 1
		    &newcbd->cmds[i].dmamap_cmd);
d1794 1
a1794 1
			    sc->sc_dev.dv_xname, error);
d1797 5
a1801 1
		newcbd->cmds[i].siop_sc = sc;
d1803 4
a1806 4
		newcbd->cmds[i].siop_xfer = &newcbd->xfers[i];
		memset(newcbd->cmds[i].siop_xfer, 0,
		    sizeof(struct siop_xfer));
		newcbd->cmds[i].dsa = newcbd->xferdma->dm_segs[0].ds_addr +
d1808 15
a1822 13
		dsa = newcbd->cmds[i].dsa;
		newcbd->cmds[i].status = CMDST_FREE;
		newcbd->cmds[i].siop_tables.t_msgout.count= htole32(1);
		newcbd->cmds[i].siop_tables.t_msgout.addr = htole32(dsa);
		newcbd->cmds[i].siop_tables.t_msgin.count= htole32(1);
		newcbd->cmds[i].siop_tables.t_msgin.addr = htole32(dsa + 16);
		newcbd->cmds[i].siop_tables.t_extmsgin.count= htole32(2);
		newcbd->cmds[i].siop_tables.t_extmsgin.addr = htole32(dsa + 17);
		newcbd->cmds[i].siop_tables.t_extmsgdata.addr =
		    htole32(dsa + 19);
		newcbd->cmds[i].siop_tables.t_status.count= htole32(1);
		newcbd->cmds[i].siop_tables.t_status.addr = htole32(dsa + 32);

d1824 1
a1824 1
		scr = &newcbd->cmds[i].siop_xfer->resel[0];
d1840 1
a1840 1
		    htole32(sc->sc_scriptaddr + Ent_reselected);
d1842 1
a1842 1
		    htole32(sc->sc_scriptaddr + Ent_reselect);
d1844 1
a1844 1
		    htole32(sc->sc_scriptaddr + Ent_selected);
d1846 1
a1846 1
		    htole32(dsa + sizeof(struct siop_xfer_common) +
d1850 1
d1852 1
d1855 3
a1857 3
		    letoh32(newcbd->cmds[i].siop_tables.t_msgin.addr),
		    letoh32(newcbd->cmds[i].siop_tables.t_msgout.addr),
		    letoh32(newcbd->cmds[i].siop_tables.t_status.addr));
d1860 1
d1862 3
a1864 1
	return 0;
d1866 2
a1867 1
	bus_dmamap_destroy(sc->sc_dmat, newcbd->xferdma);
d1869 1
a1869 1
	bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d1874 1
a1874 1
	return error;
d1899 1
a1899 1
	memset(lunsw, 0, sizeof(struct siop_lunsw));
d1903 2
a1904 2
	if (sc->features & SF_CHIP_RAM) {
		bus_space_write_region_4(sc->sc_ramt, sc->sc_ramh,
d1907 1
a1907 1
		bus_space_write_4(sc->sc_ramt, sc->sc_ramh,
d1909 1
a1909 1
		    sc->sc_scriptaddr + Ent_lunsw_return);
d1913 1
a1913 1
			sc->sc_script[sc->script_free_lo + i] =
d1915 3
a1917 2
		sc->sc_script[sc->script_free_lo + E_abs_lunsw_return_Used[0]] = 
		    htole32(sc->sc_scriptaddr + Ent_lunsw_return);
a1921 3
	if (sc->script_free_lo > 1024)
		printf("%s: script_free_lo (%d) > 1024\n", sc->sc_dev.dv_xname,
		    sc->script_free_lo);
d1932 1
d1934 2
d1941 2
a1942 2
		sc->targets[target]->reseloff = Ent_resel_targ0 / 4 + i * 2;
		if ((siop_script_read(sc, sc->targets[target]->reseloff) & 0xff)
d1946 1
a1946 1
			    target, i, sc->targets[target]->reseloff);
d1949 1
a1949 1
			siop_script_write(sc, sc->targets[target]->reseloff,
d1951 3
a1953 3
			siop_script_write(sc, sc->targets[target]->reseloff + 1,
			    sc->sc_scriptaddr +
			    sc->targets[target]->lunsw->lunsw_off * 4 +
d1963 1
a1963 1
		siop_lun = sc->targets[target]->siop_lun[i];
d1971 1
a1971 1
	siop_update_scntl3(sc, sc->targets[target]);
d1976 1
a1976 1
siop_update_scntl3(sc, siop_target)
d1978 1
a1978 1
	struct siop_target *siop_target;
d1980 1
d1984 1
a1984 1
	    0x78030000 | ((siop_target->id >> 16) & 0x0000ff00));
d1988 1
a1988 11
	    0x78050000 | (siop_target->id & 0x0000ff00));
	/* If DT, change null op ('MOVE 0xff TO SFBR') to 'MOVE n TO SCNTL4' */
	if (siop_target->flags & TARF_ISDT)
		siop_script_write(sc,
		    siop_target->lunsw->lunsw_off + (Ent_restore_scntl3 / 4) + 4,
		    0x78bc0000 | ((siop_target->id << 8) & 0x0000ff00));
	else
		siop_script_write(sc,
		    siop_target->lunsw->lunsw_off + (Ent_restore_scntl3 / 4) + 4,
		    0x7808ff00);

d1999 3
a2001 1
	struct siop_lun *siop_lun = sc->targets[target]->siop_lun[lun];
d2006 1
a2006 1
	lunsw = sc->targets[target]->lunsw;
d2009 2
a2010 2
		 * Can't extend this slot. Probably not worth trying to deal
		 * with this case.
d2014 1
a2014 1
		    sc->sc_dev.dv_xname, target, lun);
d2019 1
a2019 1
	ntargets =  (sc->sc_link.adapter_buswidth - 1) - 1 - sc->sc_ntargets;
d2022 1
a2022 1
	 * We need 8 bytes for the lun sw additional entry, and
d2029 1
a2029 1
	    ((sc->targets[target]->flags & TARF_TAG) ?
d2033 1
a2033 1
		 * Not enough space, but probably not worth dealing with it.
d2038 1
a2038 1
		    sc->sc_dev.dv_xname, target, lun);
d2044 1
a2044 1
	    sc->sc_dev.dv_xname, target, lun);
d2056 1
a2056 1
	if (sc->targets[target]->flags & TARF_TAG) {
d2060 3
a2062 2
		if (sc->features & SF_CHIP_RAM) {
			bus_space_write_region_4(sc->sc_ramt, sc->sc_ramh,
d2069 1
a2069 1
				sc->sc_script[sc->script_free_hi + i] = 
d2075 1
a2075 1
		    sc->sc_scriptaddr + sc->script_free_hi * 4 +
d2085 1
a2085 1
		    sc->targets[target]->siop_lun[lun]->reseloff;
d2097 1
d2100 1
a2100 1
		    sc->sc_dev.dv_xname, target, lun);
d2102 1
a2102 1
	if (sc->targets[target] == NULL)
d2104 3
a2106 2
	free(sc->targets[target]->siop_lun[lun], M_DEVBUF);
	sc->targets[target]->siop_lun[lun] = NULL;
d2110 1
a2110 1
		if (sc->targets[target]->siop_lun[i] != NULL)
d2115 2
a2116 2
	    sc->sc_dev.dv_xname, target, lun,
	    sc->targets[target]->lunsw->lunsw_off);
d2122 1
a2122 1
	siop_script_write(sc, sc->targets[target]->reseloff, 0x800c00ff);
d2124 3
a2126 3
	TAILQ_INSERT_TAIL(&sc->lunsw_list, sc->targets[target]->lunsw, next);
	free(sc->targets[target], M_DEVBUF);
	sc->targets[target] = NULL;
@


1.20
log
@fix the use of "cuz" in the tree; these are all in comments

noticed by aaron@@, recommended by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.19 2002/03/14 01:26:55 millert Exp $ */
d1397 2
a1398 1
			while ((xs->flags & ITSDONE) == 0)
d1400 2
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.18 2002/01/23 13:34:38 pefo Exp $ */
d1376 1
a1376 1
						 * worth of commands. Do this statically now 'cuz 
@


1.18
log
@Use the size of the cmd dmamap when syncing the scsi command, not data size.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.17 2001/11/05 17:25:58 art Exp $ */
d77 12
a88 12
void	siop_reset __P((struct siop_softc *));
void	siop_handle_reset __P((struct siop_softc *));
int	siop_handle_qtag_reject __P((struct siop_cmd *));
void	siop_scsicmd_end __P((struct siop_cmd *));
void	siop_start __P((struct siop_softc *));
void 	siop_timeout __P((void *));
int	siop_scsicmd __P((struct scsi_xfer *));
void	siop_dump_script __P((struct siop_softc *));
int	siop_morecbd __P((struct siop_softc *));
struct siop_lunsw *siop_get_lunsw __P((struct siop_softc *));
void	siop_add_reselsw __P((struct siop_softc *, int));
void	siop_update_scntl3 __P((struct siop_softc *, struct siop_target *));
d116 1
a116 1
void siop_printstats __P((void));
d122 1
a122 1
static __inline__ void siop_script_sync __P((struct siop_softc *, int));
d133 1
a133 1
static __inline__ u_int32_t siop_script_read __P((struct siop_softc *, u_int));
d146 2
a147 2
static __inline__ void siop_script_write __P((struct siop_softc *, u_int,
	u_int32_t));
@


1.17
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.16 2001/10/30 00:02:55 krw Exp $ */
d1093 1
a1093 1
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1357 1
a1357 1
	    0, siop_cmd->dmamap_data->dm_mapsize,
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.18 2002/01/23 13:34:38 pefo Exp $ */
d1093 1
a1093 1
		    0, siop_cmd->dmamap_cmd->dm_mapsize,
d1357 1
a1357 1
	    0, siop_cmd->dmamap_cmd->dm_mapsize,
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.17.2.1 2002/01/31 22:55:32 niklas Exp $ */
d77 12
a88 12
void	siop_reset(struct siop_softc *);
void	siop_handle_reset(struct siop_softc *);
int	siop_handle_qtag_reject(struct siop_cmd *);
void	siop_scsicmd_end(struct siop_cmd *);
void	siop_start(struct siop_softc *);
void 	siop_timeout(void *);
int	siop_scsicmd(struct scsi_xfer *);
void	siop_dump_script(struct siop_softc *);
int	siop_morecbd(struct siop_softc *);
struct siop_lunsw *siop_get_lunsw(struct siop_softc *);
void	siop_add_reselsw(struct siop_softc *, int);
void	siop_update_scntl3(struct siop_softc *, struct siop_target *);
d116 1
a116 1
void siop_printstats(void);
d122 1
a122 1
static __inline__ void siop_script_sync(struct siop_softc *, int);
d133 1
a133 1
static __inline__ u_int32_t siop_script_read(struct siop_softc *, u_int);
d146 2
a147 2
static __inline__ void siop_script_write(struct siop_softc *, u_int,
	u_int32_t);
d1376 1
a1376 1
						 * worth of commands. Do this statically now because 
@


1.17.2.3
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: siop.c,v 1.64 2002/07/26 01:00:43 wiz Exp $	*/
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
d53 1
a54 1
#include <dev/ic/siopvar.h>
d74 1
a74 1
/* Number of scheduler slot (needs to match script) */
d85 1
a85 1
void	siop_morecbd(struct siop_softc *);
d88 1
a88 1
void	siop_update_scntl3(struct siop_softc *, struct siop_common_target *);
d128 3
a130 3
	if ((sc->sc_c.features & SF_CHIP_RAM) == 0)
		bus_dmamap_sync(sc->sc_c.sc_dmat, sc->sc_c.sc_scriptdma, 0,
		    PAGE_SIZE, ops);
d139 2
a140 3
	if (sc->sc_c.features & SF_CHIP_RAM) {
		return bus_space_read_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
		    offset * 4);
d142 1
a142 1
		return letoh32(sc->sc_c.sc_script[offset]);
d154 2
a155 3
	if (sc->sc_c.features & SF_CHIP_RAM) {
		bus_space_write_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
		    offset * 4, val);
d157 1
a157 1
		sc->sc_c.sc_script[offset] = htole32(val);
d165 3
a167 2
	if (siop_common_attach(&sc->sc_c) != 0)
		return;
d169 35
d210 5
a214 3
	sc->sc_c.sc_link.adapter = &siop_adapter;
	sc->sc_c.sc_link.device = &siop_dev;

d218 42
a259 5
#ifdef SIOP_DEBUG
	printf("%s: script size = %d, PHY addr=0x%x, VIRT=%p\n",
	    sc->sc_c.sc_dev.dv_xname, (int)sizeof(siop_script),
	    (u_int32_t)sc->sc_c.sc_scriptaddr, sc->sc_c.sc_script);
#endif
d262 1
a262 1
	siop_resetbus(&sc->sc_c);
d271 1
a271 1
	config_found((struct device*)sc, &sc->sc_c.sc_link, scsiprint);
d281 1
a281 1
	siop_common_reset(&sc->sc_c);
d284 2
a285 2
	if (sc->sc_c.features & SF_CHIP_RAM) {
		bus_space_write_region_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh, 0,
d290 1
a290 1
			bus_space_write_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
d292 1
a292 15
			    sc->sc_c.sc_scriptaddr + Ent_msgin_space);
		}
		if (sc->sc_c.features & SF_CHIP_LED0) {
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    Ent_led_on1, siop_led_on,
			    sizeof(siop_led_on) / sizeof(siop_led_on[0]));
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    Ent_led_on2, siop_led_on,
			    sizeof(siop_led_on) / sizeof(siop_led_on[0]));
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    Ent_led_off, siop_led_off,
			    sizeof(siop_led_off) / sizeof(siop_led_off[0]));
d297 1
a297 1
			sc->sc_c.sc_script[j] = htole32(siop_script[j]);
d302 2
a303 19
			sc->sc_c.sc_script[E_abs_msgin_Used[j]] =
			    htole32(sc->sc_c.sc_scriptaddr + Ent_msgin_space);
		}
		if (sc->sc_c.features & SF_CHIP_LED0) {
			for (j = 0; j < (sizeof(siop_led_on) /
			    sizeof(siop_led_on[0])); j++)
				sc->sc_c.sc_script[
				    Ent_led_on1 / sizeof(siop_led_on[0]) + j
				    ] = htole32(siop_led_on[j]);
			for (j = 0; j < (sizeof(siop_led_on) /
			    sizeof(siop_led_on[0])); j++)
				sc->sc_c.sc_script[
				    Ent_led_on2 / sizeof(siop_led_on[0]) + j
				    ] = htole32(siop_led_on[j]);
			for (j = 0; j < (sizeof(siop_led_off) /
			    sizeof(siop_led_off[0])); j++)
				sc->sc_c.sc_script[
				   Ent_led_off / sizeof(siop_led_off[0]) + j
				   ] = htole32(siop_led_off[j]);
d307 1
a307 1
	sc->script_free_hi = sc->sc_c.ram_size / 4;
d313 1
a313 1
				sc->sc_c.sc_dev.dv_xname, lunsw->lunsw_off);
d320 2
a321 3
	for (i = 0; i < sc->sc_c.sc_link.adapter_buswidth; i++) {
		struct siop_target *target;
		if (sc->sc_c.targets[i] == NULL)
d325 1
a325 1
				sc->sc_c.sc_dev.dv_xname, i);
d327 3
a329 4
		target = (struct siop_target *)sc->sc_c.targets[i];
		free(target->lunsw, M_DEVBUF);
		target->lunsw = siop_get_lunsw(sc);
		if (target->lunsw == NULL) {
d331 1
a331 1
			    sc->sc_c.sc_dev.dv_xname, i);
d338 3
a340 6
	if ((sc->sc_c.features & SF_CHIP_RAM) == 0) {
		bus_dmamap_sync(sc->sc_c.sc_dmat, sc->sc_c.sc_scriptdma, 0,
		    PAGE_SIZE, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSP,
	    sc->sc_c.sc_scriptaddr + Ent_reselect);
d346 3
a348 3
	    siop_cmd->cmd_c.dsa, \
	    sc->sc_c.sc_scriptaddr + ent); \
bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSP, sc->sc_c.sc_scriptaddr + ent); \
d352 1
a352 1
bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSP, sc->sc_c.sc_scriptaddr + ent); \
d365 2
a366 2
	int istat, sist, sstat1, dstat;
	u_int32_t irqcode;
d374 1
a374 1
	istat = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_ISTAT);
d380 1
a380 8
		bus_space_write_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_ISTAT, ISTAT_INTF);
	}
	if ((istat &(ISTAT_DIP | ISTAT_SIP | ISTAT_ABRT)) ==
	    (ISTAT_DIP | ISTAT_ABRT)) {
		/* clear abort */
		bus_space_write_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_ISTAT, 0);
d383 1
a383 1
	dsa = bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA);
d399 5
a403 5
		xs = siop_cmd->cmd_c.xs;
		siop_target = (struct siop_target *)siop_cmd->cmd_c.siop_target;
		target = siop_cmd->cmd_c.xs->sc_link->target;
		lun = siop_cmd->cmd_c.xs->sc_link->lun;
		tag = siop_cmd->cmd_c.tag;
d406 4
a409 5
		if (siop_cmd->cmd_c.status != CMDST_ACTIVE &&
		    siop_cmd->cmd_c.status != CMDST_SENSE_ACTIVE) {
 			printf("siop_cmd (lun %d) for DSA 0x%x "
			    "not active (%d)\n", lun, (u_int)dsa,
			    siop_cmd->cmd_c.status);
d432 1
a432 8
		dstat = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_DSTAT);
		if (dstat & DSTAT_ABRT) {
			/* was probably generated by a bus reset IOCTL */
			if ((dstat & DSTAT_DFE) == 0)
				siop_clearfifo(&sc->sc_c);
			goto reset;
		}
d435 3
a437 5
			    (int)(bus_space_read_4(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_DSP) -
			    sc->sc_c.sc_scriptaddr),
			    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
				SIOP_DSA));
d440 3
a442 4
				bus_space_write_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_DCNTL,
				    bus_space_read_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_DCNTL) | DCNTL_STD);
a445 1

d447 23
a469 23
		printf("DMA IRQ:");
		if (dstat & DSTAT_IID)
			printf(" Illegal instruction");
		if (dstat & DSTAT_BF)
			printf(" bus fault");
		if (dstat & DSTAT_MDPE)
			printf(" parity");
		if (dstat & DSTAT_DFE)
			printf(" dma fifo empty");
		else
			siop_clearfifo(&sc->sc_c);
		printf(", DSP=0x%x DSA=0x%x: ",
		    (int)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_DSP) - sc->sc_c.sc_scriptaddr),
		    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA));
		if (siop_cmd)
			printf("last msg_in=0x%x status=0x%x\n",
			    siop_cmd->cmd_tables->msg_in[0],
			    letoh32(siop_cmd->cmd_tables->status));
		else 
			printf("%s: current DSA invalid\n",
			    sc->sc_c.sc_dev.dv_xname);
		need_reset = 1;
d479 2
a480 4
		sist = bus_space_read_2(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_SIST0);
		sstat1 = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_SSTAT1);
d484 4
a487 6
		    bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_SSTAT1),
		    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA),
		    (u_long)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_DSP) -
		    sc->sc_c.sc_scriptaddr));
d499 1
a499 1
				printf("%s:", sc->sc_c.sc_dev.dv_xname);
d506 2
a507 2
				dstat = bus_space_read_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_DSTAT);
d512 4
a515 5
				bus_space_write_4(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh,
				    SIOP_DSA, siop_cmd->cmd_c.dsa);
				scratcha0 = bus_space_read_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_SCRATCHA);
d519 2
a520 2
				 * previous phase may be aborted for any reason
				 * ( for example, the target has less data to
d526 1
a526 1
						siop_clearfifo(&sc->sc_c);
d532 1
a532 1
					 * target may be ready to disconnect
d537 1
a537 1
						siop_sdp(&siop_cmd->cmd_c);
d539 3
a541 3
						siop_clearfifo(&sc->sc_c);
					bus_space_write_1(sc->sc_c.sc_rt,
					    sc->sc_c.sc_rh, SIOP_SCRATCHA,
d550 1
a550 1
				    sc->sc_c.sc_dev.dv_xname,
d554 1
a554 1
				    sc->sc_c.sc_dev.dv_xname);
d563 1
a563 1
				printf("%s:", sc->sc_c.sc_dev.dv_xname);
d570 1
a570 1
				siop_cmd->cmd_c.status = CMDST_DONE;
d576 1
a576 1
				    "command\n", sc->sc_c.sc_dev.dv_xname);
d586 1
a586 1
				siop_cmd->cmd_tables->status =
d591 1
a591 1
			    "command\n", sc->sc_c.sc_dev.dv_xname);
d596 1
a596 1
			if (siop_modechange(&sc->sc_c) == 0 || need_reset == 1)
d600 1
a600 1
				 * we have a script interrupt, it will
d606 1
a606 1
			 * else we have to restart it ourselve, at the
d609 2
a610 3
			bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			    SIOP_DSP,
			    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
d614 1
a614 1
		/* Else it's an unhandled exeption (for now). */
d616 5
a620 6
		    "DSA=0x%x DSP=0x%x\n", sc->sc_c.sc_dev.dv_xname, sist,
		    bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_SSTAT1),
		    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA),
		    (int)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_DSP) - sc->sc_c.sc_scriptaddr));
d622 1
a622 1
			siop_cmd->cmd_c.status = CMDST_DONE;
d631 1
a631 1
		siop_resetbus(&sc->sc_c);
d638 1
a638 1
		irqcode = bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
d649 3
a651 3
				printf(
			"%s: script interrupt (0x%x) with invalid DSA !!!\n",
				    sc->sc_c.sc_dev.dv_xname, irqcode);
d654 2
a655 2
			if (siop_cmd->cmd_c.status != CMDST_ACTIVE &&
			    siop_cmd->cmd_c.status != CMDST_SENSE_ACTIVE) {
d658 2
a659 2
				    sc->sc_c.sc_dev.dv_xname,
				    irqcode, siop_cmd->cmd_c.status);
d666 2
a667 2
			    (int)(bus_space_read_4(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_DSP) - sc->sc_c.sc_scriptaddr));
d676 1
a676 1
				    sc->sc_c.sc_dev.dv_xname);
d680 3
a682 3
			target = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SCRATCHA) & 0xf;
			lun = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
d684 1
a684 1
			tag = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
d686 1
a686 2
			siop_target =
			    (struct siop_target *)sc->sc_c.targets[target];
d688 2
a689 2
				printf("%s: reselect with invalid target %d\n",
				    sc->sc_c.sc_dev.dv_xname, target);
d695 1
a695 1
				    "lun %d\n", sc->sc_c.sc_dev.dv_xname,
d701 1
a701 2
				    "without command\n",
				    sc->sc_c.sc_dev.dv_xname,
d706 2
a707 3
			bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			    SIOP_DSP, siop_cmd->cmd_c.dsa +
			    sizeof(struct siop_common_xfer) +
d713 1
a713 1
				    sc->sc_c.sc_dev.dv_xname);
d717 2
a718 2
			int msgin = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SFBR);
d721 1
a721 1
				if (siop_cmd->cmd_tables->msg_out[0] & 0x80) {
d723 1
a723 1
					 * message was part of a identify +
d727 1
a727 2
					msg =
					    siop_cmd->cmd_tables->msg_out[1];
d729 1
a729 1
					    siop_cmd->cmd_tables->msg_out[3];
d731 1
a731 1
					msg = siop_cmd->cmd_tables->msg_out[0];
d733 1
a733 1
					    siop_cmd->cmd_tables->msg_out[2];
d736 1
a736 1
					/* MSG_REJECT  for a MSG_REJECT  !*/
d741 1
a741 1
						   sc->sc_c.sc_dev.dv_xname);
d748 4
a751 7
					/* WDTR rejected, initiate sync */
					if ((siop_target->target_c.flags &
					   TARF_SYNC) == 0) {
						siop_target->target_c.status =
						    TARST_OK;
						siop_update_xfer_mode(&sc->sc_c,
						    target);
d756 3
a758 5
					siop_target->target_c.status =
					    TARST_SYNC_NEG;
					siop_sdtr_msg(&siop_cmd->cmd_c, 0,
					    sc->sc_c.st_minsync,
					    sc->sc_c.maxoff);
d766 2
a767 6
					/* sync rejected */
					siop_target->target_c.offset = 0;
					siop_target->target_c.period = 0;
					siop_target->target_c.status = TARST_OK;
					siop_update_xfer_mode(&sc->sc_c,
					    target);
d783 1
a783 2
					printf("%s: ",
					    sc->sc_c.sc_dev.dv_xname);
d798 1
a798 1
				printf("%s: ", sc->sc_c.sc_dev.dv_xname);
d800 3
a802 3
			    siop_cmd->cmd_tables->msg_in[0]);
			siop_cmd->cmd_tables->msg_out[0] = MSG_MESSAGE_REJECT;
			siop_cmd->cmd_tables->t_msgout.count= htole32(1);
d811 2
a812 2
			    siop_cmd->cmd_tables->msg_in[2], 
			    siop_cmd->cmd_tables->msg_in[1]);
d814 1
a814 2
			if (siop_cmd->cmd_tables->msg_in[1] >
			    sizeof(siop_cmd->cmd_tables->msg_in) - 2)
d816 4
a819 4
				    sc->sc_c.sc_dev.dv_xname,
				    siop_cmd->cmd_tables->msg_in[1]);
			siop_cmd->cmd_tables->t_extmsgdata.count =
			    htole32(siop_cmd->cmd_tables->msg_in[1] - 1);
d825 1
d830 2
a831 2
			    siop_cmd->cmd_tables->msg_in[2]);
			for (i = 3; i < 2 + siop_cmd->cmd_tables->msg_in[1];
d834 1
a834 1
				    siop_cmd->cmd_tables->msg_in[i]);
d838 19
a856 20
			if (siop_cmd->cmd_tables->msg_in[2] == MSG_EXT_WDTR) {
				switch (siop_wdtr_neg(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
d858 25
a882 20
			if (siop_cmd->cmd_tables->msg_in[2] == MSG_EXT_SDTR) {
				switch (siop_sdtr_neg(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
d884 4
a887 28
			if (siop_cmd->cmd_tables->msg_in[2] == MSG_EXT_PPR) {
				switch (siop_ppr_neg(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
			}
			/* send a message reject */
			siop_cmd->cmd_tables->msg_out[0] = MSG_MESSAGE_REJECT;
			siop_cmd->cmd_tables->t_msgout.count = htole32(1);
			siop_table_sync(siop_cmd,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			CALL_SCRIPT(Ent_send_msgout);
			return 1;
d890 2
a891 2
			offset = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SCRATCHA + 1);
d897 1
a897 1
				    sc->sc_c.sc_dev.dv_xname, offset);
d903 1
a903 1
			 * Don't call bcopy in this case.
d906 3
a908 3
				bcopy(&siop_cmd->cmd_tables->data[offset],
				    &siop_cmd->cmd_tables->data[0],
				    (SIOP_NSG - offset) * sizeof(scr_table_t));
d912 1
a914 1
			CALL_SCRIPT(Ent_script_sched);
a917 2
			/* check if we can put some command in scheduler */
			siop_start(sc);
d923 2
a924 3
				    sc->sc_c.sc_dev.dv_xname,
				    (u_long)siop_cmd->cmd_c.dsa);
				siop_cmd->cmd_c.status = CMDST_FREE;
d931 4
a934 4
			    "in=0x%x status=0x%x\n", (u_long)siop_cmd->cmd_c.dsa,
			    letoh32(siop_cmd->cmd_tables->id),
			    siop_cmd->cmd_tables->msg_in[0],
			    letoh32(siop_cmd->cmd_tables->status));
d937 2
a938 2
			if (siop_cmd->cmd_c.status == CMDST_SENSE_ACTIVE)
				siop_cmd->cmd_c.status = CMDST_SENSE_DONE;
d940 1
a940 1
				siop_cmd->cmd_c.status = CMDST_DONE;
d957 1
a957 1
	    sc->sc_c.sc_dev.dv_xname,
d963 3
a965 3
	 * restart the script now if command completed properly
	 * Otherwise wait for siop_scsicmd_end(), we may need to cleanup the
	 * queue
d967 2
a968 2
	xs->status = letoh32(siop_cmd->cmd_tables->status);
	if (xs->status == SCSI_OK)
d972 1
d974 6
a979 3
	siop_scsicmd_end(siop_cmd);
	if (freetarget && siop_target->target_c.status == TARST_PROBING)
		siop_del_dev(sc, target, lun);
d990 2
a991 4
	struct scsi_xfer *xs = siop_cmd->cmd_c.xs;
	struct siop_softc *sc = (struct siop_softc *)siop_cmd->cmd_c.siop_sc;
	struct siop_lun *siop_lun =
	    ((struct siop_target*)sc->sc_c.targets[xs->sc_link->target])->siop_lun[xs->sc_link->lun];
d993 1
a993 7
	/*
	 * If the command is re-queued (SENSE, QUEUE_FULL) it
	 * must get a new timeout, so delete existing timeout now.
	 */
	timeout_del(&siop_cmd->cmd_c.xs->stimeout);

	switch(xs->status) {
d995 1
a995 1
		xs->error = (siop_cmd->cmd_c.status == CMDST_DONE) ?
d1002 1
a1002 1
		if (siop_cmd->cmd_c.status == CMDST_SENSE_DONE) {
d1007 1
a1007 1
			siop_cmd->cmd_c.status = CMDST_SENSE;
d1011 3
d1024 1
a1024 1
		printf("%s:%d:%d: queue full (tag %d)\n", sc->sc_c.sc_dev.dv_xname,
d1026 1
a1026 1
		    xs->sc_link->lun, siop_cmd->cmd_c.tag);
d1028 1
d1030 2
a1031 3
		siop_cmd->cmd_c.status = CMDST_READY;
		siop_setuptables(&siop_cmd->cmd_c);
		siop_table_sync(siop_cmd, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1034 1
d1050 1
a1050 1
	if (siop_cmd->cmd_c.status != CMDST_SENSE_DONE &&
d1052 2
a1053 2
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data, 0,
		    siop_cmd->cmd_c.dmamap_data->dm_mapsize,
d1056 1
a1056 1
		bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data);
d1058 2
a1059 2
	bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd);
	if (siop_cmd->cmd_c.status == CMDST_SENSE) {
d1062 8
a1069 8
		siop_cmd->cmd_c.rs_cmd.opcode = REQUEST_SENSE;
		siop_cmd->cmd_c.rs_cmd.byte2 = xs->sc_link->lun << 5;
		siop_cmd->cmd_c.rs_cmd.unused[0] = siop_cmd->cmd_c.rs_cmd.unused[1] = 0;
		siop_cmd->cmd_c.rs_cmd.length = sizeof(struct scsi_sense_data);
		siop_cmd->cmd_c.rs_cmd.control = 0;
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
		error = bus_dmamap_load(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd,
		    &siop_cmd->cmd_c.rs_cmd, sizeof(struct scsi_sense),
d1074 1
a1074 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1078 1
a1078 1
		error = bus_dmamap_load(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data,
d1084 1
a1084 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1086 1
a1086 1
			bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd);
d1089 2
a1090 2
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data,
		    0, siop_cmd->cmd_c.dmamap_data->dm_mapsize,
d1092 2
a1093 2
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd,
		    0, siop_cmd->cmd_c.dmamap_cmd->dm_mapsize,
d1096 1
a1096 2
		siop_setuptables(&siop_cmd->cmd_c);
		siop_table_sync(siop_cmd, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1100 3
a1102 3
	} else if (siop_cmd->cmd_c.status == CMDST_SENSE_DONE) {
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data,
		    0, siop_cmd->cmd_c.dmamap_data->dm_mapsize,
d1104 1
a1104 1
		bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data);
d1107 2
a1108 1
	siop_lun->lun_flags &= ~SIOP_LUNF_FULL;
a1109 2
	siop_cmd->cmd_c.status = CMDST_FREE;
	TAILQ_INSERT_TAIL(&sc->free_list, siop_cmd, next);
d1122 5
a1126 6
	struct siop_softc *sc = (struct siop_softc *)siop_cmd->cmd_c.siop_sc;
	int target = siop_cmd->cmd_c.xs->sc_link->target;
	int lun = siop_cmd->cmd_c.xs->sc_link->lun;
	int tag = siop_cmd->cmd_tables->msg_out[2];
	struct siop_lun *siop_lun =
	    ((struct siop_target*)sc->sc_c.targets[target])->siop_lun[lun];
d1130 2
a1131 2
	    sc->sc_c.sc_dev.dv_xname, target, lun, tag, siop_cmd->cmd_c.tag,
	    siop_cmd->cmd_c.status);
d1136 2
a1137 2
		    "lun %d (status %d)\n", sc->sc_c.sc_dev.dv_xname,
		    target, lun, siop_lun->siop_tag[0].active->cmd_c.status);
d1144 1
a1144 1
	siop_cmd->cmd_c.tag = 0;
d1149 1
a1149 1
		    siop_cmd->cmd_c.dsa + sizeof(struct siop_common_xfer) +
d1157 3
a1159 3
 * handle a bus reset: reset chip, unqueue all active commands, free all
 * target struct and report loosage to upper layer.
 * As the upper layer may requeue immediatly we have to first store
d1171 2
a1172 2
	 * scsi bus reset. reset the chip and restart
	 * the queue. Need to clean up all active commands
d1174 1
a1174 1
	printf("%s: scsi bus reset\n", sc->sc_c.sc_dev.dv_xname);
d1181 1
a1181 1
	for (target = 0; target < sc->sc_c.sc_link.adapter_buswidth;
d1183 1
a1183 1
		if (sc->sc_c.targets[target] == NULL)
d1186 1
a1186 3
			struct siop_target *siop_target = 
			    (struct siop_target *)sc->sc_c.targets[target];
			siop_lun = siop_target->siop_lun[lun];
d1191 1
a1191 1
			    ((sc->sc_c.targets[target]->flags & TARF_TAG) ?
d1197 3
a1199 6
				sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
				printf("command with tag id %d reset\n", tag);
				siop_cmd->cmd_c.xs->error =
				    (siop_cmd->cmd_c.flags & CMDFL_TIMEOUT) ?
		    		    XS_TIMEOUT : XS_RESET;
				siop_cmd->cmd_c.xs->status = SCSI_SIOP_NOCHECK;
a1200 2
				siop_cmd->cmd_c.status = CMDST_DONE;
				siop_scsicmd_end(siop_cmd);
d1203 2
a1204 5
		sc->sc_c.targets[target]->status = TARST_ASYNC;
		sc->sc_c.targets[target]->flags &= ~TARF_ISWIDE;
		sc->sc_c.targets[target]->period =
		    sc->sc_c.targets[target]->offset = 0;
		siop_update_xfer_mode(&sc->sc_c, target);
d1210 1
a1210 1
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
d1212 2
a1213 2
		    siop_cmd, siop_cmd->cmd_c.xs->sc_link->target,
		    siop_cmd->cmd_c.xs->sc_link->lun);
d1221 1
a1221 1
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
d1223 2
a1224 2
		    siop_cmd, siop_cmd->cmd_c.xs->sc_link->target,
		    siop_cmd->cmd_c.xs->sc_link->lun);
d1232 1
a1232 1
		siop_cmd->cmd_c.xs->error = (siop_cmd->cmd_c.flags & CMDFL_TIMEOUT) ?
d1234 1
a1234 1
		siop_cmd->cmd_tables->status = htole32(SCSI_SIOP_NOCHECK);
d1236 4
a1239 4
		    siop_cmd->cmd_c.status);
		if (siop_cmd->cmd_c.status == CMDST_SENSE ||
		    siop_cmd->cmd_c.status == CMDST_SENSE_ACTIVE) 
			siop_cmd->cmd_c.status = CMDST_SENSE_DONE;
d1241 1
a1241 1
			siop_cmd->cmd_c.status = CMDST_DONE;
a1253 1
	struct siop_target *siop_target;
d1260 1
a1260 1
		printf("starting cmd for %d:%d\n", target, lun);
d1263 3
a1265 1
	if (siop_cmd == NULL) {
a1269 1
	TAILQ_REMOVE(&sc->free_list, siop_cmd, next);
d1275 1
a1275 1
	if (siop_cmd->cmd_c.status != CMDST_FREE)
d1278 1
a1278 2
	siop_target = (struct siop_target*)sc->sc_c.targets[target];
	if (siop_target == NULL) {
d1281 1
a1281 1
			sc->sc_c.sc_dev.dv_xname, target);
d1283 5
a1287 7
		sc->sc_c.targets[target] =
		    malloc(sizeof(struct siop_target),
			M_DEVBUF, M_NOWAIT);
		if (sc->sc_c.targets[target] == NULL) {
			printf("%s: can't malloc memory for "
			    "target %d\n", sc->sc_c.sc_dev.dv_xname,
			    target);
d1292 5
a1296 8
		siop_target =
		    (struct siop_target*)sc->sc_c.targets[target];
		siop_target->target_c.status = TARST_PROBING;
		siop_target->target_c.flags  = 0;
		siop_target->target_c.id =
		    sc->sc_c.clock_div << 24; /* scntl3 */
		siop_target->target_c.id |=  target << 16; /* id */
		/* siop_target->target_c.id |= 0x0 << 8; scxfer is 0 */
d1299 2
a1300 2
		siop_target->lunsw = siop_get_lunsw(sc);
		if (siop_target->lunsw == NULL) {
d1302 1
a1302 1
			    sc->sc_c.sc_dev.dv_xname, target);
d1308 1
a1308 1
			siop_target->siop_lun[i] = NULL;
d1311 7
a1317 8
	if (siop_target->siop_lun[lun] == NULL) {
		siop_target->siop_lun[lun] =
		    malloc(sizeof(struct siop_lun), M_DEVBUF,
		    M_NOWAIT);
		if (siop_target->siop_lun[lun] == NULL) {
			printf("%s: can't alloc siop_lun for "
			    "target %d lun %d\n",
			    sc->sc_c.sc_dev.dv_xname, target, lun);
d1322 2
a1323 1
		bzero(siop_target->siop_lun[lun], sizeof(struct siop_lun));
d1325 4
a1328 4
	siop_cmd->cmd_c.siop_target = sc->sc_c.targets[target];
	siop_cmd->cmd_c.xs = xs;
	siop_cmd->cmd_c.flags = 0;
	siop_cmd->cmd_c.status = CMDST_READY;
d1331 1
a1331 2
	error = bus_dmamap_load(sc->sc_c.sc_dmat,
	    siop_cmd->cmd_c.dmamap_cmd,
d1335 1
a1335 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1341 2
a1342 5
		error = bus_dmamap_load(sc->sc_c.sc_dmat,
		    siop_cmd->cmd_c.dmamap_data, xs->data, xs->datalen,
		    NULL, BUS_DMA_NOWAIT | BUS_DMA_STREAMING |
		    ((xs->flags & SCSI_DATA_IN) ?
			BUS_DMA_READ : BUS_DMA_WRITE));
d1345 1
a1345 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1347 1
a1347 2
			bus_dmamap_unload(sc->sc_c.sc_dmat,
			    siop_cmd->cmd_c.dmamap_cmd);
d1351 2
a1352 3
		bus_dmamap_sync(sc->sc_c.sc_dmat,
		    siop_cmd->cmd_c.dmamap_data, 0,
		    siop_cmd->cmd_c.dmamap_data->dm_mapsize,
d1356 2
a1357 2
	bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd, 0,
	    siop_cmd->cmd_c.dmamap_cmd->dm_mapsize,
d1360 1
a1360 3
	siop_setuptables(&siop_cmd->cmd_c);
	siop_table_sync(siop_cmd,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1376 1
a1376 1
						 * worth of commands. Do this statically now 'cuz 
d1383 2
a1384 8
						if (sc->sc_c.targets[target]->status == TARST_PROBING)
							sc->sc_c.targets[target]->status = TARST_ASYNC;

						/* Set TARF_DT here because if it is turned off during PPR, it must STAY off! */
						if ((lun == 0) && 
						    (((struct scsi_inquiry_data *)xs->data)->flags2 & SID_CLOCKING) &&
						    (sc->sc_c.features & SF_BUS_ULTRA3))
 							sc->sc_c.targets[target]->flags |= TARF_DT;
a1385 1
						/* But have to do other lun's here because they never go through TARST_ASYNC */
d1397 1
a1397 2
			while ((xs->flags & ITSDONE) == 0) {
				s = splbio();
a1398 2
				splx(s);
			}
a1411 1
	struct siop_xfer *siop_xfer;
d1425 1
a1425 1
	 * at the slot from first to last, so if we always use the first 
d1453 2
a1454 2
		if (siop_cmd->cmd_c.status != CMDST_READY &&
		    siop_cmd->cmd_c.status != CMDST_SENSE)
d1457 3
a1459 4
		target = siop_cmd->cmd_c.xs->sc_link->target;
		lun = siop_cmd->cmd_c.xs->sc_link->lun;
		siop_lun =
			((struct siop_target*)sc->sc_c.targets[target])->siop_lun[lun];
d1468 1
a1468 1
		    siop_cmd->cmd_c.status == CMDST_READY)
d1471 1
a1471 1
		if (siop_cmd->cmd_c.flags & CMDFL_TAG) {
d1481 1
a1481 1
		siop_cmd->cmd_c.tag = tag;
d1486 1
a1486 1
		if (siop_cmd->cmd_c.status != CMDST_SENSE) {
d1509 1
a1509 1
		    (u_long)siop_cmd->cmd_c.dsa);
d1515 1
a1515 1
			    letoh32(siop_cmd->cmd_tables->t_msgout.count);
d1518 1
a1518 1
				    sc->sc_c.sc_dev.dv_xname, target, lun, tag,
d1521 3
a1523 3
			if (siop_cmd->cmd_c.xs->bp != NULL &&
			    (siop_cmd->cmd_c.xs->bp->b_flags & B_ASYNC))
				siop_cmd->cmd_tables->msg_out[1] =
d1526 1
a1526 1
				siop_cmd->cmd_tables->msg_out[1] =
d1528 2
a1529 2
			siop_cmd->cmd_tables->msg_out[2] = tag;
			siop_cmd->cmd_tables->t_msgout.count = htole32(3);
d1534 4
a1537 4
		if (siop_cmd->cmd_c.status == CMDST_READY) {
			siop_cmd->cmd_c.status = CMDST_ACTIVE;
		} else if (siop_cmd->cmd_c.status == CMDST_SENSE) {
			siop_cmd->cmd_c.status = CMDST_SENSE_ACTIVE;
d1546 1
a1546 1
		dsa = siop_cmd->cmd_c.dsa;
d1551 1
a1551 1
			    dsa + sizeof(struct siop_common_xfer) +
d1554 3
a1556 3
		siop_xfer = (struct siop_xfer*)siop_cmd->cmd_tables;
		siop_xfer->resel[E_ldsa_abs_slot_Used[0]] = 
		    htole32(sc->sc_c.sc_scriptaddr + Ent_script_sched_slot0 + slot * 8);
d1561 1
a1561 1
		    dsa + sizeof(struct siop_common_xfer) + Ent_ldsa_select);
d1563 2
a1564 2
		if (siop_cmd->cmd_c.status == CMDST_ACTIVE) {
			if ((siop_cmd->cmd_c.xs->flags & SCSI_POLL) == 0) {
d1566 1
a1566 1
				timeout = (u_int64_t) siop_cmd->cmd_c.xs->timeout *
d1570 1
a1570 1
				timeout_add(&siop_cmd->cmd_c.xs->stimeout, timeout);
d1598 1
a1598 2
	bus_space_write_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
	    SIOP_ISTAT, ISTAT_SIGP);
d1608 1
a1608 1
	struct siop_softc *sc = (struct siop_softc *)siop_cmd->cmd_c.siop_sc;
d1611 2
a1612 2
	sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
	printf("timeout on SCSI command 0x%x\n", siop_cmd->cmd_c.xs->cmd->opcode);
d1616 1
a1616 1
	siop_resetbus(&sc->sc_c);
d1619 1
a1619 1
	timeout_del(&siop_cmd->cmd_c.xs->stimeout);
d1621 3
a1623 3
	 * mark command has being timed out and just return;
	 * the bus reset will generate an interrupt,
	 * it will be handled in siop_intr()
d1625 1
a1625 1
	siop_cmd->cmd_c.flags |= CMDFL_TIMEOUT;
d1638 2
a1639 4
		    letoh32(sc->sc_c.sc_script[i]),
		    letoh32(sc->sc_c.sc_script[i+1]));
		if ((letoh32(sc->sc_c.sc_script[i]) & 0xe0000000) ==
		    0xc0000000) {
d1641 1
a1641 1
			printf(" 0x%08x", letoh32(sc->sc_c.sc_script[i+1]));
d1647 1
a1647 1
void
d1651 1
a1651 1
	int error, i, j, s;
a1654 1
	struct siop_xfer *xfer;
d1662 2
a1663 2
		    "head\n", sc->sc_c.sc_dev.dv_xname);
		return;
d1665 1
a1665 1
	bzero(newcbd, sizeof(struct siop_cbd));
d1668 2
a1669 2
	newcbd->cmds = malloc(sizeof(struct siop_cmd) * SIOP_NCMDPB,
	    M_DEVBUF, M_NOWAIT);
d1672 2
a1673 1
		    sc->sc_c.sc_dev.dv_xname);
d1676 2
a1677 2
	bzero(newcbd->cmds, sizeof(struct siop_cmd) * SIOP_NCMDPB);
	error = bus_dmamem_alloc(sc->sc_c.sc_dmat, PAGE_SIZE, PAGE_SIZE, 0, &seg,
d1681 1
a1681 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1684 1
a1684 1
	error = bus_dmamem_map(sc->sc_c.sc_dmat, &seg, rseg, PAGE_SIZE,
d1688 1
a1688 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1691 1
a1691 1
	error = bus_dmamap_create(sc->sc_c.sc_dmat, PAGE_SIZE, 1, PAGE_SIZE, 0,
d1695 1
a1695 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1698 1
a1698 1
	error = bus_dmamap_load(sc->sc_c.sc_dmat, newcbd->xferdma, newcbd->xfers,
d1702 1
a1702 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1706 1
a1706 1
	printf("%s: alloc newcdb at PHY addr 0x%lx\n", sc->sc_c.sc_dev.dv_xname,
d1709 1
d1711 1
a1711 1
		error = bus_dmamap_create(sc->sc_c.sc_dmat, MAXPHYS, SIOP_NSG,
d1713 1
a1713 1
		    &newcbd->cmds[i].cmd_c.dmamap_data);
d1717 1
a1717 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1720 1
a1720 1
		error = bus_dmamap_create(sc->sc_c.sc_dmat,
d1724 1
a1724 1
		    &newcbd->cmds[i].cmd_c.dmamap_cmd);
d1727 1
a1727 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1730 1
a1730 5
	}

	/* Use two loops since bailing out above releases allocated memory */
	for (i = 0; i < SIOP_NCMDPB; i++) {
		newcbd->cmds[i].cmd_c.siop_sc = &sc->sc_c;
d1732 4
a1735 4
		xfer = &newcbd->xfers[i];
		newcbd->cmds[i].cmd_tables = (struct siop_common_xfer *)xfer;
		bzero(newcbd->cmds[i].cmd_tables, sizeof(struct siop_xfer));
		dsa = newcbd->xferdma->dm_segs[0].ds_addr +
d1737 13
a1749 15
		newcbd->cmds[i].cmd_c.dsa = dsa;
		newcbd->cmds[i].cmd_c.status = CMDST_FREE;
		xfer->siop_tables.t_msgout.count= htole32(1);
		xfer->siop_tables.t_msgout.addr = htole32(dsa);
		xfer->siop_tables.t_msgin.count= htole32(1);
		xfer->siop_tables.t_msgin.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, msg_in));
		xfer->siop_tables.t_extmsgin.count= htole32(2);
		xfer->siop_tables.t_extmsgin.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, msg_in) + 1);
		xfer->siop_tables.t_extmsgdata.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, msg_in) + 3);
		xfer->siop_tables.t_status.count= htole32(1);
		xfer->siop_tables.t_status.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, status));
d1751 1
a1751 1
		scr = &xfer->resel[0];
d1767 1
a1767 1
		    htole32(sc->sc_c.sc_scriptaddr + Ent_reselected);
d1769 1
a1769 1
		    htole32(sc->sc_c.sc_scriptaddr + Ent_reselect);
d1771 1
a1771 1
		    htole32(sc->sc_c.sc_scriptaddr + Ent_selected);
d1773 1
a1773 1
		    htole32(dsa + sizeof(struct siop_common_xfer) +
a1776 1
		s = splbio();
a1777 1
		splx(s);
d1780 3
a1782 3
		    letoh32(newcbd->cmds[i].cmd_tables->t_msgin.addr),
		    letoh32(newcbd->cmds[i].cmd_tables->t_msgout.addr),
		    letoh32(newcbd->cmds[i].cmd_tables->t_status.addr));
a1784 1
	s = splbio();
d1786 1
a1786 3
	sc->sc_c.sc_link.openings += SIOP_NCMDPB;
	splx(s);
	return;
d1788 1
a1788 2
	bus_dmamap_unload(sc->sc_c.sc_dmat, newcbd->xferdma);
	bus_dmamap_destroy(sc->sc_c.sc_dmat, newcbd->xferdma);
d1790 1
a1790 1
	bus_dmamem_free(sc->sc_c.sc_dmat, &seg, rseg);
d1795 1
a1795 1
	return;
d1820 1
a1820 1
	bzero(lunsw, sizeof(struct siop_lunsw));
d1824 2
a1825 2
	if (sc->sc_c.features & SF_CHIP_RAM) {
		bus_space_write_region_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
d1828 1
a1828 1
		bus_space_write_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
d1830 1
a1830 1
		    sc->sc_c.sc_scriptaddr + Ent_lunsw_return);
d1834 1
a1834 1
			sc->sc_c.sc_script[sc->script_free_lo + i] =
d1836 2
a1837 3
		sc->sc_c.sc_script[
		    sc->script_free_lo + E_abs_lunsw_return_Used[0]] = 
		    htole32(sc->sc_c.sc_scriptaddr + Ent_lunsw_return);
d1842 3
a1854 1
	struct siop_target *siop_target;
a1855 2

	siop_target = (struct siop_target *)sc->sc_c.targets[target];
d1861 2
a1862 2
		siop_target->reseloff = Ent_resel_targ0 / 4 + i * 2;
		if ((siop_script_read(sc, siop_target->reseloff) & 0xff)
d1866 1
a1866 1
			    target, i, siop_target->reseloff);
d1869 1
a1869 1
			siop_script_write(sc, siop_target->reseloff,
d1871 3
a1873 3
			siop_script_write(sc, siop_target->reseloff + 1,
			    sc->sc_c.sc_scriptaddr +
			    siop_target->lunsw->lunsw_off * 4 +
d1883 1
a1883 1
		siop_lun = siop_target->siop_lun[i];
d1891 1
a1891 1
	siop_update_scntl3(sc, sc->sc_c.targets[target]);
d1896 1
a1896 1
siop_update_scntl3(sc, _siop_target)
d1898 1
a1898 1
	struct siop_common_target *_siop_target;
a1899 1
	struct siop_target *siop_target = (struct siop_target *)_siop_target;
d1903 1
a1903 1
	    0x78030000 | ((siop_target->target_c.id >> 16) & 0x0000ff00));
d1907 11
a1917 1
	    0x78050000 | (siop_target->target_c.id & 0x0000ff00));
d1928 1
a1928 3
	struct siop_target *siop_target =
	    (struct siop_target *)sc->sc_c.targets[target];
	struct siop_lun *siop_lun = siop_target->siop_lun[lun];
d1933 1
a1933 1
	lunsw = siop_target->lunsw;
d1936 2
a1937 2
		 * can't extend this slot. Probably not worth trying to deal
		 * with this case
d1941 1
a1941 1
		    sc->sc_c.sc_dev.dv_xname, target, lun);
d1946 1
a1946 1
	ntargets =  (sc->sc_c.sc_link.adapter_buswidth - 1) - 1 - sc->sc_ntargets;
d1949 1
a1949 1
	 * we need 8 bytes for the lun sw additionnal entry, and
d1956 1
a1956 1
	    ((siop_target->target_c.flags & TARF_TAG) ?
d1960 1
a1960 1
		 * not enough space, probably not worth dealing with it.
d1965 1
a1965 1
		    sc->sc_c.sc_dev.dv_xname, target, lun);
d1971 1
a1971 1
	    sc->sc_c.sc_dev.dv_xname, target, lun);
d1983 1
a1983 1
	if (siop_target->target_c.flags & TARF_TAG) {
d1987 2
a1988 3
		if (sc->sc_c.features & SF_CHIP_RAM) {
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
d1995 1
a1995 1
				sc->sc_c.sc_script[sc->script_free_hi + i] = 
d2001 1
a2001 1
		    sc->sc_c.sc_scriptaddr + sc->script_free_hi * 4 +
d2011 1
a2011 1
		    siop_target->siop_lun[lun]->reseloff;
a2022 1
	struct siop_target *siop_target;
d2025 1
a2025 1
		    sc->sc_c.sc_dev.dv_xname, target, lun);
d2027 1
a2027 1
	if (sc->sc_c.targets[target] == NULL)
d2029 2
a2030 3
	siop_target = (struct siop_target *)sc->sc_c.targets[target];
	free(siop_target->siop_lun[lun], M_DEVBUF);
	siop_target->siop_lun[lun] = NULL;
d2034 1
a2034 1
		if (siop_target->siop_lun[i] != NULL)
d2039 2
a2040 2
	    sc->sc_c.sc_dev.dv_xname, target, lun,
	    siop_target->lunsw->lunsw_off);
d2046 1
a2046 1
	siop_script_write(sc, siop_target->reseloff, 0x800c00ff);
d2048 3
a2050 3
	TAILQ_INSERT_TAIL(&sc->lunsw_list, siop_target->lunsw, next);
	free(sc->sc_c.targets[target], M_DEVBUF);
	sc->sc_c.targets[target] = NULL;
@


1.17.2.4
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: siop.c,v 1.65 2002/11/08 22:04:41 bouyer Exp $	*/
a177 1
	sc->sc_c.sc_link.openings = SIOP_NTAG;
a265 1
	sc->sc_ntargets = 0;
a1333 1
		bzero(sc->sc_c.targets[target], sizeof(struct siop_target));
d1862 1
d1931 1
a1931 1
	int i,j;
a1967 2
			for (j = 0; j < SIOP_NTAG; j++)
				siop_lun->siop_tag[j].reseloff = 0;
@


1.16
log
@From NetBSD: add __packed__ attribute to hardware structure that
lacked it (scr_table).

Also remove scr_table_t typedef and just use 'struct scr_table' to be
consistant with all other structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.15 2001/10/26 02:20:22 krw Exp $ */
d129 1
a129 1
		siop_bus_dmamap_sync(sc->sc_dmat, sc->sc_scriptdma,
d1052 1
a1052 1
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1089 1
a1089 1
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1092 1
a1092 1
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
d1101 1
a1101 1
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1351 1
a1351 1
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1356 1
a1356 1
	siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
@


1.15
log
@Allocate an appropriate number of cbd's for each discovered LUN
at probe time, rather than allocating them dynamically as
SCSI commands are started.

This should eliminate one possible way of calling bus_dmamem_map()
while in interrupt context.

Potential problem spotted by Art@@.

Inspired by changes to achieve same effect in NetBSD by bouyer@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.14 2001/10/08 01:25:06 krw Exp $ */
d908 1
a908 1
				    (SIOP_NSG - offset) * sizeof(scr_table_t));
@


1.14
log
@Complete (I hope) the changes to siop that make it pay attention
to the quirks table.

These latest changes, triggered by problems Dan Weeks was having
and developed with a lot of testing by Dan, should ensure that
siop is a) using the quirks of the correct LUN during wide/sync
negotiations and b) calling siop_add_dev() for all LUN's which
return valid information from an INQUIRY command.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.13 2001/08/26 02:39:05 krw Exp $ */
d215 2
d1254 1
a1254 1
	int s, error, i;
d1263 1
a1263 1
	if (siop_cmd) {
a1265 10
		if (siop_morecbd(sc) == 0) {
			siop_cmd = TAILQ_FIRST(&sc->free_list);
#ifdef DIAGNOSTIC
			if (siop_cmd == NULL)
				panic("siop_morecbd succeed and does nothing");
#endif
			TAILQ_REMOVE(&sc->free_list, siop_cmd, next);
		}
	}
	if (siop_cmd == NULL) {
d1374 9
d1612 1
a1612 1
	printf("command timeout\n");
d1709 1
a1709 1
	
@


1.13
log
@Prepare for transition to 5-parameter bus_dmamap_sync() by creating and
using *_bus_dmamap_sync() defines that are defined appropriately
depending on __HAS_NEW_BUS_DMAMAP_SYNC.

Most of the code changes are simple reversions to the original NetBSD
code.

Slip in a siop_script_sync() instead of a manually done code section.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.12 2001/08/18 02:24:02 krw Exp $ */
d1379 10
a1388 3
				    && (xs->error == XS_NOERROR)
				    && (sc->targets[target]->status == TARST_PROBING))
					sc->targets[target]->status = TARST_ASYNC;
@


1.12
log
@Make siop pay attention to quirks table. This not only eliminates the
ugly INQUIRY snooping but avoids adding even uglier #ifdef's to turn
off stuff, e.g. tagged queuing.

Add two disk drives now known to lie about supporting tagged queuing
to quirks table. One from millert@@ (<MICROP, 4421-07 0329SJ, 0329>)
and one from Hakan Olsson (<SEAGATE, ST150176LW, 0002>).

Add field 'inquiry_flags2' to struct scsi_link to hold flags2 field
from struct scsi_inquiry_data. These flags relate to SCSI-3 specific
features.

Clean up some logic, eliminating need for TARF_PPR flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.11 2001/07/04 22:55:03 espie Exp $ */
d129 2
a130 1
		bus_dmamap_sync(sc->sc_dmat, sc->sc_scriptdma, ops);
d336 1
a336 4
	if ((sc->features & SF_CHIP_RAM) == 0) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_scriptdma,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
d1050 2
a1051 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1087 2
a1088 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1090 2
a1091 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
d1099 2
a1100 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1359 2
a1360 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1364 2
a1365 1
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
@


1.11
log
@Embedding newlines in strings is a bad idea, and prints out badly.
Okay millert@@, like previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.10 2001/06/25 23:14:39 krw Exp $ */
d215 5
d233 3
d1200 1
a1200 1
		sc->targets[target]->flags &= ~(TARF_ISWIDE | TARF_ISDT | TARF_ISQAS | TARF_ISIUS);
a1247 1
	struct scsi_inquiry_data *inqdata;
d1375 2
a1376 19
				    && (xs->sc_link->lun == 0)
				    && (xs->error == XS_NOERROR)) {
					inqdata = (struct scsi_inquiry_data *)xs->data;

					if (inqdata->flags & SID_CmdQue) {
						sc->targets[target]->flags |= TARF_TAG;
						xs->sc_link->openings += SIOP_NTAG - SIOP_OPENINGS;
					}

					if ((inqdata->flags & SID_WBus16) && (sc->features & SF_BUS_WIDE))
						sc->targets[target]->flags |= TARF_WIDE;
					if (inqdata->flags & SID_Sync)
						sc->targets[target]->flags |= TARF_SYNC;

					if ((sc->features & SF_CHIP_C10)
					    && (sc->targets[target]->flags & TARF_WIDE)
					    && (inqdata->flags2 & (SID_CLOCKING | SID_QAS | SID_IUS)))
						sc->targets[target]->flags |= TARF_PPR;

a1377 6
					
					if (sc->targets[target]->flags
					    & (TARF_WIDE | TARF_SYNC | TARF_PPR)) {
						siop_add_dev(sc, target, lun);
					}
				}
@


1.10
log
@Revert change to using sc_link in calls to siop_print_info().

sc_link->device_softc not necessarily available for devices like cd's
that don't issue SCSI commands after INQUIRY during probe, leaving
negotiation triggering to next LUN. Spotted by Nikolay Sturm.

Fixing this is not worth the effort and added complexity for a
cosmetic improvement.

Keep code cleanups done at the same time, and add a typo fix
(destiation -> destination).
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.9 2001/06/24 22:00:01 krw Exp $ */
d641 2
a642 2
				printf("%s: script interrupt (0x%x) with
				    invalid DSA !!!\n", sc->sc_dev.dv_xname,
@


1.9
log
@Remove an over-optimization from the polling loop of siop_scsicmd(),
i.e. calling siop_print_info() immediately for async devices.

With the change to use xs->sc_link as parameter to siop_print_info()
this immediate call wouldn't work as the sc_link is not initialized
until AFTER the return from processing the INQUIRY command.

So, just use the default negotiation logic which is triggered by the
next command to be handled.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.8 2001/06/24 18:28:10 krw Exp $ */
d743 1
a743 1
						siop_print_info(xs->sc_link);
d759 1
a759 1
					siop_print_info(xs->sc_link);
@


1.8
log
@Pass the device's scsi_link to siop_print_info(), instead of the
adapter's siop_softc. This allows easy access to the dv_xname of the
device whose negotiation results are being reported. This makes boot
probe and subsequent log messages clearer.

e.g. message will now read

   sd0: negotiated tagged 16 bit 20 MHz 16 REQ/ACK offset xfers

instead of

   siop0: target 0 now using tagged 16 bit 20 MHz 16 REQ/ACK offset xfers

Clean up siop_print_info() a bit as long as we are there.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.7 2001/04/23 13:48:42 krw Exp $ */
d1371 1
d1387 2
a1390 1
						sc->targets[target]->status = TARST_ASYNC;
a1391 4
					}
					else {
						sc->targets[target]->status = TARST_OK;
						siop_print_info(xs->sc_link);
@


1.7
log
@Clean up supposedly 'impossible' case in siop_intr() so

a) meaningful but not voluminous debug info is printed
   and clearly associated with the offending siop bus.

b) instead of panic'ing, reset the scsi bus and return.

This problem was only seen under heavy load on powerpc.

Plus fix one typo (exeption -> exception).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.6 2001/04/15 06:01:28 krw Exp $ */
d743 1
a743 1
						siop_print_info(sc, target);
d759 1
a759 1
					siop_print_info(sc, target);
d1393 1
a1393 1
						siop_print_info(sc, target);
@


1.7.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d357 2
a358 2
	int istat, sist, sstat1, dstat;
	u_int32_t irqcode;
d606 1
a606 1
		/* Else it's an unhandled exeption (for now). */
d944 9
a952 7
	/* We just shouldn't get here */
	printf("istat = 0x%x, dstat = 0x%x, sist = 0x%x, sstat1 = 0x%x\n", istat, dstat, sist, sstat1);
	printf("need_reset = %d, irqcode = %d, siop_cmd = %p, siop_target = %p, xs = %p\n");
	if (siop_cmd != NULL)
		printf("siop_cmd->status = %d\n", siop_cmd->status);
	panic("%s: siop_intr: I shouldn't be here!", sc->sc_dev.dv_xname);
	return 1;
@


1.7.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.7.4.1 2001/05/14 22:24:11 niklas Exp $ */
d357 2
a358 2
	int istat, sist = 0, sstat1 = 0, dstat = 0;
	u_int32_t irqcode = 0;
d606 1
a606 1
		/* Else it's an unhandled exception (for now). */
d944 7
a950 9
	/* We can get here if ISTAT_DIP and DSTAT_DFE are the only bits set. */
	/* But that *SHOULDN'T* happen. It does on powerpc (at least).	     */
	printf("%s: siop_intr() - we should not be here!\n"
	    "   istat = 0x%x, dstat = 0x%x, sist = 0x%x, sstat1 = 0x%x\n"
	    "   need_reset = %x, irqcode = %x, siop_cmd %s\n",
	    sc->sc_dev.dv_xname,
	    istat, dstat, sist, sstat1, need_reset, irqcode,
	    (siop_cmd == NULL) ? "== NULL" : "!= NULL");
	goto reset; /* Where we should have gone in the first place! */
a1368 1

a1383 2
					sc->targets[target]->status = TARST_ASYNC;
					
d1386 1
d1388 4
@


1.7.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.7.4.2 2001/07/04 10:41:07 niklas Exp $ */
d129 1
a129 2
		siop_bus_dmamap_sync(sc->sc_dmat, sc->sc_scriptdma,
		    0, PAGE_SIZE, ops);
a213 2
	/* Start with one page worth of commands */
	siop_morecbd(sc);
a214 5
	/*
	 * sc->sc_link is the template for all device sc_link's
	 * for devices attached to this adapter. It is passed to
	 * the upper layers in config_found().
	 */
a227 3
	sc->sc_link.quirks = 0;
	if ((sc->features & SF_BUS_WIDE) == 0)
	  sc->sc_link.quirks |= SDEV_NOWIDE;
d327 4
a330 1
	siop_script_sync(sc, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d641 2
a642 2
				printf("%s: script interrupt (0x%x) with "
				    "invalid DSA !!!\n", sc->sc_dev.dv_xname,
d1044 1
a1044 2
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1080 1
a1080 2
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1082 1
a1082 2
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1090 1
a1090 2
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1192 1
a1192 1
		sc->targets[target]->flags  = 0;
d1240 1
d1243 1
a1243 1
	int s, error, i, j;
d1252 1
a1252 1
	if (siop_cmd != NULL) {
d1255 10
d1350 1
a1350 2
		siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
		    0, siop_cmd->dmamap_data->dm_mapsize,
d1354 1
a1354 2
	siop_bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
	    0, siop_cmd->dmamap_data->dm_mapsize,
d1368 1
d1370 22
a1391 16
					error = ((struct scsi_inquiry_data *)xs->data)->device & SID_QUAL;
					if (error != SID_QUAL_BAD_LU) {
						/* 
						 * Allocate enough commands to hold at least max openings
						 * worth of commands. Do this statically now 'cuz 
						 * a) We can't rely on the upper layers to ask for more
						 * b) Doing it dynamically in siop_startcmd may cause 
						 *    calls to bus_dma* functions in interrupt context
						 */
						for (j = 0; j < SIOP_NTAG; j += SIOP_NCMDPB)
							siop_morecbd(sc);
						if (sc->targets[target]->status == TARST_PROBING)
							sc->targets[target]->status = TARST_ASYNC;
						/* Can't do lun 0 here, because flags not set yet */
						if (lun > 0)
							siop_add_dev(sc, target, lun);
d1616 1
a1616 1
	printf("timeout on SCSI command 0x%x\n", siop_cmd->xs->cmd->opcode);
d1713 1
a1713 1

@


1.7.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d129 1
a129 1
		bus_dmamap_sync(sc->sc_dmat, sc->sc_scriptdma,
d908 1
a908 1
				    (SIOP_NSG - offset) * sizeof(struct scr_table));
d1052 1
a1052 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1089 1
a1089 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1092 1
a1092 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
d1101 1
a1101 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1351 1
a1351 1
		bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_data,
d1356 1
a1356 1
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->dmamap_cmd,
@


1.7.4.5
log
@Merge in trunk
@
text
@d1093 1
a1093 1
		    0, siop_cmd->dmamap_cmd->dm_mapsize,
d1357 1
a1357 1
	    0, siop_cmd->dmamap_cmd->dm_mapsize,
@


1.7.4.6
log
@Merge in -current from about a week ago
@
text
@d77 12
a88 12
void	siop_reset(struct siop_softc *);
void	siop_handle_reset(struct siop_softc *);
int	siop_handle_qtag_reject(struct siop_cmd *);
void	siop_scsicmd_end(struct siop_cmd *);
void	siop_start(struct siop_softc *);
void 	siop_timeout(void *);
int	siop_scsicmd(struct scsi_xfer *);
void	siop_dump_script(struct siop_softc *);
int	siop_morecbd(struct siop_softc *);
struct siop_lunsw *siop_get_lunsw(struct siop_softc *);
void	siop_add_reselsw(struct siop_softc *, int);
void	siop_update_scntl3(struct siop_softc *, struct siop_target *);
d116 1
a116 1
void siop_printstats(void);
d122 1
a122 1
static __inline__ void siop_script_sync(struct siop_softc *, int);
d133 1
a133 1
static __inline__ u_int32_t siop_script_read(struct siop_softc *, u_int);
d146 2
a147 2
static __inline__ void siop_script_write(struct siop_softc *, u_int,
	u_int32_t);
@


1.7.4.7
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: siop.c,v 1.65 2002/11/08 22:04:41 bouyer Exp $	*/
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
d53 1
a54 1
#include <dev/ic/siopvar.h>
d74 1
a74 1
/* Number of scheduler slot (needs to match script) */
d85 1
a85 1
void	siop_morecbd(struct siop_softc *);
d88 1
a88 1
void	siop_update_scntl3(struct siop_softc *, struct siop_common_target *);
d128 3
a130 3
	if ((sc->sc_c.features & SF_CHIP_RAM) == 0)
		bus_dmamap_sync(sc->sc_c.sc_dmat, sc->sc_c.sc_scriptdma, 0,
		    PAGE_SIZE, ops);
d139 2
a140 3
	if (sc->sc_c.features & SF_CHIP_RAM) {
		return bus_space_read_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
		    offset * 4);
d142 1
a142 1
		return letoh32(sc->sc_c.sc_script[offset]);
d154 2
a155 3
	if (sc->sc_c.features & SF_CHIP_RAM) {
		bus_space_write_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
		    offset * 4, val);
d157 1
a157 1
		sc->sc_c.sc_script[offset] = htole32(val);
d165 3
a167 2
	if (siop_common_attach(&sc->sc_c) != 0)
		return;
d169 35
d210 5
a214 4
	sc->sc_c.sc_link.adapter = &siop_adapter;
	sc->sc_c.sc_link.device = &siop_dev;
	sc->sc_c.sc_link.openings = SIOP_NTAG;

d218 42
a259 5
#ifdef SIOP_DEBUG
	printf("%s: script size = %d, PHY addr=0x%x, VIRT=%p\n",
	    sc->sc_c.sc_dev.dv_xname, (int)sizeof(siop_script),
	    (u_int32_t)sc->sc_c.sc_scriptaddr, sc->sc_c.sc_script);
#endif
d262 1
a262 1
	siop_resetbus(&sc->sc_c);
d271 1
a271 1
	config_found((struct device*)sc, &sc->sc_c.sc_link, scsiprint);
d281 1
a281 1
	siop_common_reset(&sc->sc_c);
d284 2
a285 2
	if (sc->sc_c.features & SF_CHIP_RAM) {
		bus_space_write_region_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh, 0,
d290 1
a290 1
			bus_space_write_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
d292 1
a292 15
			    sc->sc_c.sc_scriptaddr + Ent_msgin_space);
		}
		if (sc->sc_c.features & SF_CHIP_LED0) {
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    Ent_led_on1, siop_led_on,
			    sizeof(siop_led_on) / sizeof(siop_led_on[0]));
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    Ent_led_on2, siop_led_on,
			    sizeof(siop_led_on) / sizeof(siop_led_on[0]));
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
			    Ent_led_off, siop_led_off,
			    sizeof(siop_led_off) / sizeof(siop_led_off[0]));
d297 1
a297 1
			sc->sc_c.sc_script[j] = htole32(siop_script[j]);
d302 2
a303 19
			sc->sc_c.sc_script[E_abs_msgin_Used[j]] =
			    htole32(sc->sc_c.sc_scriptaddr + Ent_msgin_space);
		}
		if (sc->sc_c.features & SF_CHIP_LED0) {
			for (j = 0; j < (sizeof(siop_led_on) /
			    sizeof(siop_led_on[0])); j++)
				sc->sc_c.sc_script[
				    Ent_led_on1 / sizeof(siop_led_on[0]) + j
				    ] = htole32(siop_led_on[j]);
			for (j = 0; j < (sizeof(siop_led_on) /
			    sizeof(siop_led_on[0])); j++)
				sc->sc_c.sc_script[
				    Ent_led_on2 / sizeof(siop_led_on[0]) + j
				    ] = htole32(siop_led_on[j]);
			for (j = 0; j < (sizeof(siop_led_off) /
			    sizeof(siop_led_off[0])); j++)
				sc->sc_c.sc_script[
				   Ent_led_off / sizeof(siop_led_off[0]) + j
				   ] = htole32(siop_led_off[j]);
d307 1
a307 2
	sc->script_free_hi = sc->sc_c.ram_size / 4;
	sc->sc_ntargets = 0;
d313 1
a313 1
				sc->sc_c.sc_dev.dv_xname, lunsw->lunsw_off);
d320 2
a321 3
	for (i = 0; i < sc->sc_c.sc_link.adapter_buswidth; i++) {
		struct siop_target *target;
		if (sc->sc_c.targets[i] == NULL)
d325 1
a325 1
				sc->sc_c.sc_dev.dv_xname, i);
d327 3
a329 4
		target = (struct siop_target *)sc->sc_c.targets[i];
		free(target->lunsw, M_DEVBUF);
		target->lunsw = siop_get_lunsw(sc);
		if (target->lunsw == NULL) {
d331 1
a331 1
			    sc->sc_c.sc_dev.dv_xname, i);
d338 3
a340 6
	if ((sc->sc_c.features & SF_CHIP_RAM) == 0) {
		bus_dmamap_sync(sc->sc_c.sc_dmat, sc->sc_c.sc_scriptdma, 0,
		    PAGE_SIZE, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSP,
	    sc->sc_c.sc_scriptaddr + Ent_reselect);
d346 3
a348 3
	    siop_cmd->cmd_c.dsa, \
	    sc->sc_c.sc_scriptaddr + ent); \
bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSP, sc->sc_c.sc_scriptaddr + ent); \
d352 1
a352 1
bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSP, sc->sc_c.sc_scriptaddr + ent); \
d365 2
a366 2
	int istat, sist, sstat1, dstat;
	u_int32_t irqcode;
d374 1
a374 1
	istat = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_ISTAT);
d380 1
a380 8
		bus_space_write_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_ISTAT, ISTAT_INTF);
	}
	if ((istat &(ISTAT_DIP | ISTAT_SIP | ISTAT_ABRT)) ==
	    (ISTAT_DIP | ISTAT_ABRT)) {
		/* clear abort */
		bus_space_write_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_ISTAT, 0);
d383 1
a383 1
	dsa = bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA);
d399 5
a403 5
		xs = siop_cmd->cmd_c.xs;
		siop_target = (struct siop_target *)siop_cmd->cmd_c.siop_target;
		target = siop_cmd->cmd_c.xs->sc_link->target;
		lun = siop_cmd->cmd_c.xs->sc_link->lun;
		tag = siop_cmd->cmd_c.tag;
d406 4
a409 5
		if (siop_cmd->cmd_c.status != CMDST_ACTIVE &&
		    siop_cmd->cmd_c.status != CMDST_SENSE_ACTIVE) {
 			printf("siop_cmd (lun %d) for DSA 0x%x "
			    "not active (%d)\n", lun, (u_int)dsa,
			    siop_cmd->cmd_c.status);
d432 1
a432 8
		dstat = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_DSTAT);
		if (dstat & DSTAT_ABRT) {
			/* was probably generated by a bus reset IOCTL */
			if ((dstat & DSTAT_DFE) == 0)
				siop_clearfifo(&sc->sc_c);
			goto reset;
		}
d435 3
a437 5
			    (int)(bus_space_read_4(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_DSP) -
			    sc->sc_c.sc_scriptaddr),
			    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
				SIOP_DSA));
d440 3
a442 4
				bus_space_write_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_DCNTL,
				    bus_space_read_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_DCNTL) | DCNTL_STD);
a445 1

d447 23
a469 23
		printf("DMA IRQ:");
		if (dstat & DSTAT_IID)
			printf(" Illegal instruction");
		if (dstat & DSTAT_BF)
			printf(" bus fault");
		if (dstat & DSTAT_MDPE)
			printf(" parity");
		if (dstat & DSTAT_DFE)
			printf(" dma fifo empty");
		else
			siop_clearfifo(&sc->sc_c);
		printf(", DSP=0x%x DSA=0x%x: ",
		    (int)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_DSP) - sc->sc_c.sc_scriptaddr),
		    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA));
		if (siop_cmd)
			printf("last msg_in=0x%x status=0x%x\n",
			    siop_cmd->cmd_tables->msg_in[0],
			    letoh32(siop_cmd->cmd_tables->status));
		else 
			printf("%s: current DSA invalid\n",
			    sc->sc_c.sc_dev.dv_xname);
		need_reset = 1;
d479 2
a480 4
		sist = bus_space_read_2(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_SIST0);
		sstat1 = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
		    SIOP_SSTAT1);
d484 4
a487 6
		    bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_SSTAT1),
		    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA),
		    (u_long)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_DSP) -
		    sc->sc_c.sc_scriptaddr));
d499 1
a499 1
				printf("%s:", sc->sc_c.sc_dev.dv_xname);
d506 2
a507 2
				dstat = bus_space_read_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_DSTAT);
d512 4
a515 5
				bus_space_write_4(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh,
				    SIOP_DSA, siop_cmd->cmd_c.dsa);
				scratcha0 = bus_space_read_1(sc->sc_c.sc_rt,
				    sc->sc_c.sc_rh, SIOP_SCRATCHA);
d519 2
a520 2
				 * previous phase may be aborted for any reason
				 * ( for example, the target has less data to
d526 1
a526 1
						siop_clearfifo(&sc->sc_c);
d532 1
a532 1
					 * target may be ready to disconnect
d537 1
a537 1
						siop_sdp(&siop_cmd->cmd_c);
d539 3
a541 3
						siop_clearfifo(&sc->sc_c);
					bus_space_write_1(sc->sc_c.sc_rt,
					    sc->sc_c.sc_rh, SIOP_SCRATCHA,
d550 1
a550 1
				    sc->sc_c.sc_dev.dv_xname,
d554 1
a554 1
				    sc->sc_c.sc_dev.dv_xname);
d563 1
a563 1
				printf("%s:", sc->sc_c.sc_dev.dv_xname);
d570 1
a570 1
				siop_cmd->cmd_c.status = CMDST_DONE;
d576 1
a576 1
				    "command\n", sc->sc_c.sc_dev.dv_xname);
d586 1
a586 1
				siop_cmd->cmd_tables->status =
d591 1
a591 1
			    "command\n", sc->sc_c.sc_dev.dv_xname);
d596 1
a596 1
			if (siop_modechange(&sc->sc_c) == 0 || need_reset == 1)
d600 1
a600 1
				 * we have a script interrupt, it will
d606 1
a606 1
			 * else we have to restart it ourselve, at the
d609 2
a610 3
			bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			    SIOP_DSP,
			    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
d614 1
a614 1
		/* Else it's an unhandled exeption (for now). */
d616 5
a620 6
		    "DSA=0x%x DSP=0x%x\n", sc->sc_c.sc_dev.dv_xname, sist,
		    bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_SSTAT1),
		    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA),
		    (int)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			SIOP_DSP) - sc->sc_c.sc_scriptaddr));
d622 1
a622 1
			siop_cmd->cmd_c.status = CMDST_DONE;
d631 1
a631 1
		siop_resetbus(&sc->sc_c);
d638 1
a638 1
		irqcode = bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
d649 3
a651 3
				printf(
			"%s: script interrupt (0x%x) with invalid DSA !!!\n",
				    sc->sc_c.sc_dev.dv_xname, irqcode);
d654 2
a655 2
			if (siop_cmd->cmd_c.status != CMDST_ACTIVE &&
			    siop_cmd->cmd_c.status != CMDST_SENSE_ACTIVE) {
d658 2
a659 2
				    sc->sc_c.sc_dev.dv_xname,
				    irqcode, siop_cmd->cmd_c.status);
d666 2
a667 2
			    (int)(bus_space_read_4(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_DSP) - sc->sc_c.sc_scriptaddr));
d676 1
a676 1
				    sc->sc_c.sc_dev.dv_xname);
d680 3
a682 3
			target = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SCRATCHA) & 0xf;
			lun = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
d684 1
a684 1
			tag = bus_space_read_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
d686 1
a686 2
			siop_target =
			    (struct siop_target *)sc->sc_c.targets[target];
d688 2
a689 2
				printf("%s: reselect with invalid target %d\n",
				    sc->sc_c.sc_dev.dv_xname, target);
d695 1
a695 1
				    "lun %d\n", sc->sc_c.sc_dev.dv_xname,
d701 1
a701 2
				    "without command\n",
				    sc->sc_c.sc_dev.dv_xname,
d706 2
a707 3
			bus_space_write_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
			    SIOP_DSP, siop_cmd->cmd_c.dsa +
			    sizeof(struct siop_common_xfer) +
d713 1
a713 1
				    sc->sc_c.sc_dev.dv_xname);
d717 2
a718 2
			int msgin = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SFBR);
d721 1
a721 1
				if (siop_cmd->cmd_tables->msg_out[0] & 0x80) {
d723 1
a723 1
					 * message was part of a identify +
d727 1
a727 2
					msg =
					    siop_cmd->cmd_tables->msg_out[1];
d729 1
a729 1
					    siop_cmd->cmd_tables->msg_out[3];
d731 1
a731 1
					msg = siop_cmd->cmd_tables->msg_out[0];
d733 1
a733 1
					    siop_cmd->cmd_tables->msg_out[2];
d736 1
a736 1
					/* MSG_REJECT  for a MSG_REJECT  !*/
d741 1
a741 1
						   sc->sc_c.sc_dev.dv_xname);
d748 4
a751 7
					/* WDTR rejected, initiate sync */
					if ((siop_target->target_c.flags &
					   TARF_SYNC) == 0) {
						siop_target->target_c.status =
						    TARST_OK;
						siop_update_xfer_mode(&sc->sc_c,
						    target);
d756 3
a758 5
					siop_target->target_c.status =
					    TARST_SYNC_NEG;
					siop_sdtr_msg(&siop_cmd->cmd_c, 0,
					    sc->sc_c.st_minsync,
					    sc->sc_c.maxoff);
d766 2
a767 6
					/* sync rejected */
					siop_target->target_c.offset = 0;
					siop_target->target_c.period = 0;
					siop_target->target_c.status = TARST_OK;
					siop_update_xfer_mode(&sc->sc_c,
					    target);
d783 1
a783 2
					printf("%s: ",
					    sc->sc_c.sc_dev.dv_xname);
d798 1
a798 1
				printf("%s: ", sc->sc_c.sc_dev.dv_xname);
d800 3
a802 3
			    siop_cmd->cmd_tables->msg_in[0]);
			siop_cmd->cmd_tables->msg_out[0] = MSG_MESSAGE_REJECT;
			siop_cmd->cmd_tables->t_msgout.count= htole32(1);
d811 2
a812 2
			    siop_cmd->cmd_tables->msg_in[2], 
			    siop_cmd->cmd_tables->msg_in[1]);
d814 1
a814 2
			if (siop_cmd->cmd_tables->msg_in[1] >
			    sizeof(siop_cmd->cmd_tables->msg_in) - 2)
d816 4
a819 4
				    sc->sc_c.sc_dev.dv_xname,
				    siop_cmd->cmd_tables->msg_in[1]);
			siop_cmd->cmd_tables->t_extmsgdata.count =
			    htole32(siop_cmd->cmd_tables->msg_in[1] - 1);
d825 1
d830 2
a831 2
			    siop_cmd->cmd_tables->msg_in[2]);
			for (i = 3; i < 2 + siop_cmd->cmd_tables->msg_in[1];
d834 1
a834 1
				    siop_cmd->cmd_tables->msg_in[i]);
d838 19
a856 20
			if (siop_cmd->cmd_tables->msg_in[2] == MSG_EXT_WDTR) {
				switch (siop_wdtr_neg(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
d858 25
a882 20
			if (siop_cmd->cmd_tables->msg_in[2] == MSG_EXT_SDTR) {
				switch (siop_sdtr_neg(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
d884 4
a887 28
			if (siop_cmd->cmd_tables->msg_in[2] == MSG_EXT_PPR) {
				switch (siop_ppr_neg(&siop_cmd->cmd_c)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->cmd_c.siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
			}
			/* send a message reject */
			siop_cmd->cmd_tables->msg_out[0] = MSG_MESSAGE_REJECT;
			siop_cmd->cmd_tables->t_msgout.count = htole32(1);
			siop_table_sync(siop_cmd,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			CALL_SCRIPT(Ent_send_msgout);
			return 1;
d890 2
a891 2
			offset = bus_space_read_1(sc->sc_c.sc_rt,
			    sc->sc_c.sc_rh, SIOP_SCRATCHA + 1);
d897 1
a897 1
				    sc->sc_c.sc_dev.dv_xname, offset);
d903 1
a903 1
			 * Don't call bcopy in this case.
d906 3
a908 3
				bcopy(&siop_cmd->cmd_tables->data[offset],
				    &siop_cmd->cmd_tables->data[0],
				    (SIOP_NSG - offset) * sizeof(scr_table_t));
d912 1
a914 1
			CALL_SCRIPT(Ent_script_sched);
a917 2
			/* check if we can put some command in scheduler */
			siop_start(sc);
d923 2
a924 3
				    sc->sc_c.sc_dev.dv_xname,
				    (u_long)siop_cmd->cmd_c.dsa);
				siop_cmd->cmd_c.status = CMDST_FREE;
d931 4
a934 4
			    "in=0x%x status=0x%x\n", (u_long)siop_cmd->cmd_c.dsa,
			    letoh32(siop_cmd->cmd_tables->id),
			    siop_cmd->cmd_tables->msg_in[0],
			    letoh32(siop_cmd->cmd_tables->status));
d937 2
a938 2
			if (siop_cmd->cmd_c.status == CMDST_SENSE_ACTIVE)
				siop_cmd->cmd_c.status = CMDST_SENSE_DONE;
d940 1
a940 1
				siop_cmd->cmd_c.status = CMDST_DONE;
d957 1
a957 1
	    sc->sc_c.sc_dev.dv_xname,
d963 3
a965 3
	 * restart the script now if command completed properly
	 * Otherwise wait for siop_scsicmd_end(), we may need to cleanup the
	 * queue
d967 2
a968 2
	xs->status = letoh32(siop_cmd->cmd_tables->status);
	if (xs->status == SCSI_OK)
d972 1
d974 6
a979 3
	siop_scsicmd_end(siop_cmd);
	if (freetarget && siop_target->target_c.status == TARST_PROBING)
		siop_del_dev(sc, target, lun);
d990 2
a991 10
	struct scsi_xfer *xs = siop_cmd->cmd_c.xs;
	struct siop_softc *sc = (struct siop_softc *)siop_cmd->cmd_c.siop_sc;
	struct siop_lun *siop_lun =
	    ((struct siop_target*)sc->sc_c.targets[xs->sc_link->target])->siop_lun[xs->sc_link->lun];

	/*
	 * If the command is re-queued (SENSE, QUEUE_FULL) it
	 * must get a new timeout, so delete existing timeout now.
	 */
	timeout_del(&siop_cmd->cmd_c.xs->stimeout);
d993 1
a993 1
	switch(xs->status) {
d995 1
a995 1
		xs->error = (siop_cmd->cmd_c.status == CMDST_DONE) ?
d1002 1
a1002 1
		if (siop_cmd->cmd_c.status == CMDST_SENSE_DONE) {
d1007 1
a1007 1
			siop_cmd->cmd_c.status = CMDST_SENSE;
d1011 3
d1024 1
a1024 1
		printf("%s:%d:%d: queue full (tag %d)\n", sc->sc_c.sc_dev.dv_xname,
d1026 1
a1026 1
		    xs->sc_link->lun, siop_cmd->cmd_c.tag);
d1028 1
d1030 2
a1031 3
		siop_cmd->cmd_c.status = CMDST_READY;
		siop_setuptables(&siop_cmd->cmd_c);
		siop_table_sync(siop_cmd, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1034 1
d1050 1
a1050 1
	if (siop_cmd->cmd_c.status != CMDST_SENSE_DONE &&
d1052 2
a1053 2
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data, 0,
		    siop_cmd->cmd_c.dmamap_data->dm_mapsize,
d1056 1
a1056 1
		bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data);
d1058 2
a1059 2
	bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd);
	if (siop_cmd->cmd_c.status == CMDST_SENSE) {
d1062 8
a1069 8
		siop_cmd->cmd_c.rs_cmd.opcode = REQUEST_SENSE;
		siop_cmd->cmd_c.rs_cmd.byte2 = xs->sc_link->lun << 5;
		siop_cmd->cmd_c.rs_cmd.unused[0] = siop_cmd->cmd_c.rs_cmd.unused[1] = 0;
		siop_cmd->cmd_c.rs_cmd.length = sizeof(struct scsi_sense_data);
		siop_cmd->cmd_c.rs_cmd.control = 0;
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
		error = bus_dmamap_load(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd,
		    &siop_cmd->cmd_c.rs_cmd, sizeof(struct scsi_sense),
d1074 1
a1074 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1078 1
a1078 1
		error = bus_dmamap_load(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data,
d1084 1
a1084 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1086 1
a1086 1
			bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd);
d1089 2
a1090 2
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data,
		    0, siop_cmd->cmd_c.dmamap_data->dm_mapsize,
d1092 2
a1093 2
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd,
		    0, siop_cmd->cmd_c.dmamap_cmd->dm_mapsize,
d1096 1
a1096 2
		siop_setuptables(&siop_cmd->cmd_c);
		siop_table_sync(siop_cmd, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1100 3
a1102 3
	} else if (siop_cmd->cmd_c.status == CMDST_SENSE_DONE) {
		bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data,
		    0, siop_cmd->cmd_c.dmamap_data->dm_mapsize,
d1104 1
a1104 1
		bus_dmamap_unload(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_data);
d1107 2
a1108 1
	siop_lun->lun_flags &= ~SIOP_LUNF_FULL;
a1109 2
	siop_cmd->cmd_c.status = CMDST_FREE;
	TAILQ_INSERT_TAIL(&sc->free_list, siop_cmd, next);
d1122 5
a1126 6
	struct siop_softc *sc = (struct siop_softc *)siop_cmd->cmd_c.siop_sc;
	int target = siop_cmd->cmd_c.xs->sc_link->target;
	int lun = siop_cmd->cmd_c.xs->sc_link->lun;
	int tag = siop_cmd->cmd_tables->msg_out[2];
	struct siop_lun *siop_lun =
	    ((struct siop_target*)sc->sc_c.targets[target])->siop_lun[lun];
d1130 2
a1131 2
	    sc->sc_c.sc_dev.dv_xname, target, lun, tag, siop_cmd->cmd_c.tag,
	    siop_cmd->cmd_c.status);
d1136 2
a1137 2
		    "lun %d (status %d)\n", sc->sc_c.sc_dev.dv_xname,
		    target, lun, siop_lun->siop_tag[0].active->cmd_c.status);
d1144 1
a1144 1
	siop_cmd->cmd_c.tag = 0;
d1149 1
a1149 1
		    siop_cmd->cmd_c.dsa + sizeof(struct siop_common_xfer) +
d1157 3
a1159 3
 * handle a bus reset: reset chip, unqueue all active commands, free all
 * target struct and report loosage to upper layer.
 * As the upper layer may requeue immediatly we have to first store
d1171 2
a1172 2
	 * scsi bus reset. reset the chip and restart
	 * the queue. Need to clean up all active commands
d1174 1
a1174 1
	printf("%s: scsi bus reset\n", sc->sc_c.sc_dev.dv_xname);
d1181 1
a1181 1
	for (target = 0; target < sc->sc_c.sc_link.adapter_buswidth;
d1183 1
a1183 1
		if (sc->sc_c.targets[target] == NULL)
d1186 1
a1186 3
			struct siop_target *siop_target = 
			    (struct siop_target *)sc->sc_c.targets[target];
			siop_lun = siop_target->siop_lun[lun];
d1191 1
a1191 1
			    ((sc->sc_c.targets[target]->flags & TARF_TAG) ?
d1197 3
a1199 6
				sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
				printf("command with tag id %d reset\n", tag);
				siop_cmd->cmd_c.xs->error =
				    (siop_cmd->cmd_c.flags & CMDFL_TIMEOUT) ?
		    		    XS_TIMEOUT : XS_RESET;
				siop_cmd->cmd_c.xs->status = SCSI_SIOP_NOCHECK;
a1200 2
				siop_cmd->cmd_c.status = CMDST_DONE;
				siop_scsicmd_end(siop_cmd);
d1203 2
a1204 5
		sc->sc_c.targets[target]->status = TARST_ASYNC;
		sc->sc_c.targets[target]->flags &= ~TARF_ISWIDE;
		sc->sc_c.targets[target]->period =
		    sc->sc_c.targets[target]->offset = 0;
		siop_update_xfer_mode(&sc->sc_c, target);
d1210 1
a1210 1
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
d1212 2
a1213 2
		    siop_cmd, siop_cmd->cmd_c.xs->sc_link->target,
		    siop_cmd->cmd_c.xs->sc_link->lun);
d1221 1
a1221 1
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
d1223 2
a1224 2
		    siop_cmd, siop_cmd->cmd_c.xs->sc_link->target,
		    siop_cmd->cmd_c.xs->sc_link->lun);
d1232 1
a1232 1
		siop_cmd->cmd_c.xs->error = (siop_cmd->cmd_c.flags & CMDFL_TIMEOUT) ?
d1234 1
a1234 1
		siop_cmd->cmd_tables->status = htole32(SCSI_SIOP_NOCHECK);
d1236 4
a1239 4
		    siop_cmd->cmd_c.status);
		if (siop_cmd->cmd_c.status == CMDST_SENSE ||
		    siop_cmd->cmd_c.status == CMDST_SENSE_ACTIVE) 
			siop_cmd->cmd_c.status = CMDST_SENSE_DONE;
d1241 1
a1241 1
			siop_cmd->cmd_c.status = CMDST_DONE;
a1253 1
	struct siop_target *siop_target;
d1260 1
a1260 1
		printf("starting cmd for %d:%d\n", target, lun);
d1263 3
a1265 1
	if (siop_cmd == NULL) {
a1269 1
	TAILQ_REMOVE(&sc->free_list, siop_cmd, next);
d1275 1
a1275 1
	if (siop_cmd->cmd_c.status != CMDST_FREE)
d1278 1
a1278 2
	siop_target = (struct siop_target*)sc->sc_c.targets[target];
	if (siop_target == NULL) {
d1281 1
a1281 1
			sc->sc_c.sc_dev.dv_xname, target);
d1283 5
a1287 7
		sc->sc_c.targets[target] =
		    malloc(sizeof(struct siop_target),
			M_DEVBUF, M_NOWAIT);
		if (sc->sc_c.targets[target] == NULL) {
			printf("%s: can't malloc memory for "
			    "target %d\n", sc->sc_c.sc_dev.dv_xname,
			    target);
d1292 5
a1296 9
		bzero(sc->sc_c.targets[target], sizeof(struct siop_target));
		siop_target =
		    (struct siop_target*)sc->sc_c.targets[target];
		siop_target->target_c.status = TARST_PROBING;
		siop_target->target_c.flags  = 0;
		siop_target->target_c.id =
		    sc->sc_c.clock_div << 24; /* scntl3 */
		siop_target->target_c.id |=  target << 16; /* id */
		/* siop_target->target_c.id |= 0x0 << 8; scxfer is 0 */
d1299 2
a1300 2
		siop_target->lunsw = siop_get_lunsw(sc);
		if (siop_target->lunsw == NULL) {
d1302 1
a1302 1
			    sc->sc_c.sc_dev.dv_xname, target);
d1308 1
a1308 1
			siop_target->siop_lun[i] = NULL;
d1311 7
a1317 8
	if (siop_target->siop_lun[lun] == NULL) {
		siop_target->siop_lun[lun] =
		    malloc(sizeof(struct siop_lun), M_DEVBUF,
		    M_NOWAIT);
		if (siop_target->siop_lun[lun] == NULL) {
			printf("%s: can't alloc siop_lun for "
			    "target %d lun %d\n",
			    sc->sc_c.sc_dev.dv_xname, target, lun);
d1322 2
a1323 1
		bzero(siop_target->siop_lun[lun], sizeof(struct siop_lun));
d1325 4
a1328 4
	siop_cmd->cmd_c.siop_target = sc->sc_c.targets[target];
	siop_cmd->cmd_c.xs = xs;
	siop_cmd->cmd_c.flags = 0;
	siop_cmd->cmd_c.status = CMDST_READY;
d1331 1
a1331 2
	error = bus_dmamap_load(sc->sc_c.sc_dmat,
	    siop_cmd->cmd_c.dmamap_cmd,
d1335 1
a1335 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1341 2
a1342 5
		error = bus_dmamap_load(sc->sc_c.sc_dmat,
		    siop_cmd->cmd_c.dmamap_data, xs->data, xs->datalen,
		    NULL, BUS_DMA_NOWAIT | BUS_DMA_STREAMING |
		    ((xs->flags & SCSI_DATA_IN) ?
			BUS_DMA_READ : BUS_DMA_WRITE));
d1345 1
a1345 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1347 1
a1347 2
			bus_dmamap_unload(sc->sc_c.sc_dmat,
			    siop_cmd->cmd_c.dmamap_cmd);
d1351 2
a1352 3
		bus_dmamap_sync(sc->sc_c.sc_dmat,
		    siop_cmd->cmd_c.dmamap_data, 0,
		    siop_cmd->cmd_c.dmamap_data->dm_mapsize,
d1356 2
a1357 2
	bus_dmamap_sync(sc->sc_c.sc_dmat, siop_cmd->cmd_c.dmamap_cmd, 0,
	    siop_cmd->cmd_c.dmamap_cmd->dm_mapsize,
d1360 1
a1360 3
	siop_setuptables(&siop_cmd->cmd_c);
	siop_table_sync(siop_cmd,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1383 2
a1384 8
						if (sc->sc_c.targets[target]->status == TARST_PROBING)
							sc->sc_c.targets[target]->status = TARST_ASYNC;

						/* Set TARF_DT here because if it is turned off during PPR, it must STAY off! */
						if ((lun == 0) && 
						    (((struct scsi_inquiry_data *)xs->data)->flags2 & SID_CLOCKING) &&
						    (sc->sc_c.features & SF_BUS_ULTRA3))
 							sc->sc_c.targets[target]->flags |= TARF_DT;
a1385 1
						/* But have to do other lun's here because they never go through TARST_ASYNC */
d1397 1
a1397 2
			while ((xs->flags & ITSDONE) == 0) {
				s = splbio();
a1398 2
				splx(s);
			}
a1411 1
	struct siop_xfer *siop_xfer;
d1425 1
a1425 1
	 * at the slot from first to last, so if we always use the first 
d1453 2
a1454 2
		if (siop_cmd->cmd_c.status != CMDST_READY &&
		    siop_cmd->cmd_c.status != CMDST_SENSE)
d1457 3
a1459 4
		target = siop_cmd->cmd_c.xs->sc_link->target;
		lun = siop_cmd->cmd_c.xs->sc_link->lun;
		siop_lun =
			((struct siop_target*)sc->sc_c.targets[target])->siop_lun[lun];
d1468 1
a1468 1
		    siop_cmd->cmd_c.status == CMDST_READY)
d1471 1
a1471 1
		if (siop_cmd->cmd_c.flags & CMDFL_TAG) {
d1481 1
a1481 1
		siop_cmd->cmd_c.tag = tag;
d1486 1
a1486 1
		if (siop_cmd->cmd_c.status != CMDST_SENSE) {
d1509 1
a1509 1
		    (u_long)siop_cmd->cmd_c.dsa);
d1515 1
a1515 1
			    letoh32(siop_cmd->cmd_tables->t_msgout.count);
d1518 1
a1518 1
				    sc->sc_c.sc_dev.dv_xname, target, lun, tag,
d1521 3
a1523 3
			if (siop_cmd->cmd_c.xs->bp != NULL &&
			    (siop_cmd->cmd_c.xs->bp->b_flags & B_ASYNC))
				siop_cmd->cmd_tables->msg_out[1] =
d1526 1
a1526 1
				siop_cmd->cmd_tables->msg_out[1] =
d1528 2
a1529 2
			siop_cmd->cmd_tables->msg_out[2] = tag;
			siop_cmd->cmd_tables->t_msgout.count = htole32(3);
d1534 4
a1537 4
		if (siop_cmd->cmd_c.status == CMDST_READY) {
			siop_cmd->cmd_c.status = CMDST_ACTIVE;
		} else if (siop_cmd->cmd_c.status == CMDST_SENSE) {
			siop_cmd->cmd_c.status = CMDST_SENSE_ACTIVE;
d1546 1
a1546 1
		dsa = siop_cmd->cmd_c.dsa;
d1551 1
a1551 1
			    dsa + sizeof(struct siop_common_xfer) +
d1554 3
a1556 3
		siop_xfer = (struct siop_xfer*)siop_cmd->cmd_tables;
		siop_xfer->resel[E_ldsa_abs_slot_Used[0]] = 
		    htole32(sc->sc_c.sc_scriptaddr + Ent_script_sched_slot0 + slot * 8);
d1561 1
a1561 1
		    dsa + sizeof(struct siop_common_xfer) + Ent_ldsa_select);
d1563 2
a1564 2
		if (siop_cmd->cmd_c.status == CMDST_ACTIVE) {
			if ((siop_cmd->cmd_c.xs->flags & SCSI_POLL) == 0) {
d1566 1
a1566 1
				timeout = (u_int64_t) siop_cmd->cmd_c.xs->timeout *
d1570 1
a1570 1
				timeout_add(&siop_cmd->cmd_c.xs->stimeout, timeout);
d1598 1
a1598 2
	bus_space_write_1(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
	    SIOP_ISTAT, ISTAT_SIGP);
d1608 1
a1608 1
	struct siop_softc *sc = (struct siop_softc *)siop_cmd->cmd_c.siop_sc;
d1611 2
a1612 2
	sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
	printf("timeout on SCSI command 0x%x\n", siop_cmd->cmd_c.xs->cmd->opcode);
d1616 1
a1616 1
	siop_resetbus(&sc->sc_c);
d1619 1
a1619 1
	timeout_del(&siop_cmd->cmd_c.xs->stimeout);
d1621 3
a1623 3
	 * mark command has being timed out and just return;
	 * the bus reset will generate an interrupt,
	 * it will be handled in siop_intr()
d1625 1
a1625 1
	siop_cmd->cmd_c.flags |= CMDFL_TIMEOUT;
d1638 2
a1639 4
		    letoh32(sc->sc_c.sc_script[i]),
		    letoh32(sc->sc_c.sc_script[i+1]));
		if ((letoh32(sc->sc_c.sc_script[i]) & 0xe0000000) ==
		    0xc0000000) {
d1641 1
a1641 1
			printf(" 0x%08x", letoh32(sc->sc_c.sc_script[i+1]));
d1647 1
a1647 1
void
d1651 1
a1651 1
	int error, i, j, s;
a1654 1
	struct siop_xfer *xfer;
d1662 2
a1663 2
		    "head\n", sc->sc_c.sc_dev.dv_xname);
		return;
d1665 1
a1665 1
	bzero(newcbd, sizeof(struct siop_cbd));
d1668 2
a1669 2
	newcbd->cmds = malloc(sizeof(struct siop_cmd) * SIOP_NCMDPB,
	    M_DEVBUF, M_NOWAIT);
d1672 2
a1673 1
		    sc->sc_c.sc_dev.dv_xname);
d1676 2
a1677 2
	bzero(newcbd->cmds, sizeof(struct siop_cmd) * SIOP_NCMDPB);
	error = bus_dmamem_alloc(sc->sc_c.sc_dmat, PAGE_SIZE, PAGE_SIZE, 0, &seg,
d1681 1
a1681 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1684 1
a1684 1
	error = bus_dmamem_map(sc->sc_c.sc_dmat, &seg, rseg, PAGE_SIZE,
d1688 1
a1688 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1691 1
a1691 1
	error = bus_dmamap_create(sc->sc_c.sc_dmat, PAGE_SIZE, 1, PAGE_SIZE, 0,
d1695 1
a1695 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1698 1
a1698 1
	error = bus_dmamap_load(sc->sc_c.sc_dmat, newcbd->xferdma, newcbd->xfers,
d1702 1
a1702 1
		    sc->sc_c.sc_dev.dv_xname, error);
d1706 1
a1706 1
	printf("%s: alloc newcdb at PHY addr 0x%lx\n", sc->sc_c.sc_dev.dv_xname,
d1709 1
d1711 1
a1711 1
		error = bus_dmamap_create(sc->sc_c.sc_dmat, MAXPHYS, SIOP_NSG,
d1713 1
a1713 1
		    &newcbd->cmds[i].cmd_c.dmamap_data);
d1717 1
a1717 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1720 1
a1720 1
		error = bus_dmamap_create(sc->sc_c.sc_dmat,
d1724 1
a1724 1
		    &newcbd->cmds[i].cmd_c.dmamap_cmd);
d1727 1
a1727 1
			    sc->sc_c.sc_dev.dv_xname, error);
d1730 1
a1730 5
	}

	/* Use two loops since bailing out above releases allocated memory */
	for (i = 0; i < SIOP_NCMDPB; i++) {
		newcbd->cmds[i].cmd_c.siop_sc = &sc->sc_c;
d1732 4
a1735 4
		xfer = &newcbd->xfers[i];
		newcbd->cmds[i].cmd_tables = (struct siop_common_xfer *)xfer;
		bzero(newcbd->cmds[i].cmd_tables, sizeof(struct siop_xfer));
		dsa = newcbd->xferdma->dm_segs[0].ds_addr +
d1737 13
a1749 15
		newcbd->cmds[i].cmd_c.dsa = dsa;
		newcbd->cmds[i].cmd_c.status = CMDST_FREE;
		xfer->siop_tables.t_msgout.count= htole32(1);
		xfer->siop_tables.t_msgout.addr = htole32(dsa);
		xfer->siop_tables.t_msgin.count= htole32(1);
		xfer->siop_tables.t_msgin.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, msg_in));
		xfer->siop_tables.t_extmsgin.count= htole32(2);
		xfer->siop_tables.t_extmsgin.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, msg_in) + 1);
		xfer->siop_tables.t_extmsgdata.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, msg_in) + 3);
		xfer->siop_tables.t_status.count= htole32(1);
		xfer->siop_tables.t_status.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, status));
d1751 1
a1751 1
		scr = &xfer->resel[0];
d1767 1
a1767 1
		    htole32(sc->sc_c.sc_scriptaddr + Ent_reselected);
d1769 1
a1769 1
		    htole32(sc->sc_c.sc_scriptaddr + Ent_reselect);
d1771 1
a1771 1
		    htole32(sc->sc_c.sc_scriptaddr + Ent_selected);
d1773 1
a1773 1
		    htole32(dsa + sizeof(struct siop_common_xfer) +
a1776 1
		s = splbio();
a1777 1
		splx(s);
d1780 3
a1782 3
		    letoh32(newcbd->cmds[i].cmd_tables->t_msgin.addr),
		    letoh32(newcbd->cmds[i].cmd_tables->t_msgout.addr),
		    letoh32(newcbd->cmds[i].cmd_tables->t_status.addr));
a1784 1
	s = splbio();
d1786 1
a1786 2
	splx(s);
	return;
d1788 1
a1788 2
	bus_dmamap_unload(sc->sc_c.sc_dmat, newcbd->xferdma);
	bus_dmamap_destroy(sc->sc_c.sc_dmat, newcbd->xferdma);
d1790 1
a1790 1
	bus_dmamem_free(sc->sc_c.sc_dmat, &seg, rseg);
d1795 1
a1795 1
	return;
d1820 1
a1820 1
	bzero(lunsw, sizeof(struct siop_lunsw));
d1824 2
a1825 2
	if (sc->sc_c.features & SF_CHIP_RAM) {
		bus_space_write_region_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
d1828 1
a1828 1
		bus_space_write_4(sc->sc_c.sc_ramt, sc->sc_c.sc_ramh,
d1830 1
a1830 1
		    sc->sc_c.sc_scriptaddr + Ent_lunsw_return);
d1834 1
a1834 1
			sc->sc_c.sc_script[sc->script_free_lo + i] =
d1836 2
a1837 3
		sc->sc_c.sc_script[
		    sc->script_free_lo + E_abs_lunsw_return_Used[0]] = 
		    htole32(sc->sc_c.sc_scriptaddr + Ent_lunsw_return);
d1842 3
d1854 1
a1854 2
	int i,j;
	struct siop_target *siop_target;
a1855 2

	siop_target = (struct siop_target *)sc->sc_c.targets[target];
d1861 2
a1862 2
		siop_target->reseloff = Ent_resel_targ0 / 4 + i * 2;
		if ((siop_script_read(sc, siop_target->reseloff) & 0xff)
d1866 1
a1866 1
			    target, i, siop_target->reseloff);
d1869 1
a1869 1
			siop_script_write(sc, siop_target->reseloff,
d1871 3
a1873 3
			siop_script_write(sc, siop_target->reseloff + 1,
			    sc->sc_c.sc_scriptaddr +
			    siop_target->lunsw->lunsw_off * 4 +
d1883 1
a1883 1
		siop_lun = siop_target->siop_lun[i];
a1887 2
			for (j = 0; j < SIOP_NTAG; j++)
				siop_lun->siop_tag[j].reseloff = 0;
d1891 1
a1891 1
	siop_update_scntl3(sc, sc->sc_c.targets[target]);
d1896 1
a1896 1
siop_update_scntl3(sc, _siop_target)
d1898 1
a1898 1
	struct siop_common_target *_siop_target;
a1899 1
	struct siop_target *siop_target = (struct siop_target *)_siop_target;
d1903 1
a1903 1
	    0x78030000 | ((siop_target->target_c.id >> 16) & 0x0000ff00));
d1907 11
a1917 1
	    0x78050000 | (siop_target->target_c.id & 0x0000ff00));
d1928 1
a1928 3
	struct siop_target *siop_target =
	    (struct siop_target *)sc->sc_c.targets[target];
	struct siop_lun *siop_lun = siop_target->siop_lun[lun];
d1933 1
a1933 1
	lunsw = siop_target->lunsw;
d1936 2
a1937 2
		 * can't extend this slot. Probably not worth trying to deal
		 * with this case
d1941 1
a1941 1
		    sc->sc_c.sc_dev.dv_xname, target, lun);
d1946 1
a1946 1
	ntargets =  (sc->sc_c.sc_link.adapter_buswidth - 1) - 1 - sc->sc_ntargets;
d1949 1
a1949 1
	 * we need 8 bytes for the lun sw additionnal entry, and
d1956 1
a1956 1
	    ((siop_target->target_c.flags & TARF_TAG) ?
d1960 1
a1960 1
		 * not enough space, probably not worth dealing with it.
d1965 1
a1965 1
		    sc->sc_c.sc_dev.dv_xname, target, lun);
d1971 1
a1971 1
	    sc->sc_c.sc_dev.dv_xname, target, lun);
d1983 1
a1983 1
	if (siop_target->target_c.flags & TARF_TAG) {
d1987 2
a1988 3
		if (sc->sc_c.features & SF_CHIP_RAM) {
			bus_space_write_region_4(sc->sc_c.sc_ramt,
			    sc->sc_c.sc_ramh,
d1995 1
a1995 1
				sc->sc_c.sc_script[sc->script_free_hi + i] = 
d2001 1
a2001 1
		    sc->sc_c.sc_scriptaddr + sc->script_free_hi * 4 +
d2011 1
a2011 1
		    siop_target->siop_lun[lun]->reseloff;
a2022 1
	struct siop_target *siop_target;
d2025 1
a2025 1
		    sc->sc_c.sc_dev.dv_xname, target, lun);
d2027 1
a2027 1
	if (sc->sc_c.targets[target] == NULL)
d2029 2
a2030 3
	siop_target = (struct siop_target *)sc->sc_c.targets[target];
	free(siop_target->siop_lun[lun], M_DEVBUF);
	siop_target->siop_lun[lun] = NULL;
d2034 1
a2034 1
		if (siop_target->siop_lun[i] != NULL)
d2039 2
a2040 2
	    sc->sc_c.sc_dev.dv_xname, target, lun,
	    siop_target->lunsw->lunsw_off);
d2046 1
a2046 1
	siop_script_write(sc, siop_target->reseloff, 0x800c00ff);
d2048 3
a2050 3
	TAILQ_INSERT_TAIL(&sc->lunsw_list, siop_target->lunsw, next);
	free(sc->sc_c.targets[target], M_DEVBUF);
	sc->sc_c.targets[target] = NULL;
@


1.7.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d56 2
a57 2
#ifndef SIOP_DEBUG
#undef SIOP_DEBUG
d431 23
a453 22
			printf("%s: DMA IRQ:", sc->sc_c.sc_dev.dv_xname);
			if (dstat & DSTAT_IID)
				printf(" illegal instruction");
			if (dstat & DSTAT_BF)
				printf(" bus fault");
			if (dstat & DSTAT_MDPE)
				printf(" parity");
			if (dstat & DSTAT_DFE)
				printf(" dma fifo empty");
			else
				siop_clearfifo(&sc->sc_c);
			printf(", DSP=0x%x DSA=0x%x: ",
			    (int)(bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh,
				SIOP_DSP) - sc->sc_c.sc_scriptaddr),
			    bus_space_read_4(sc->sc_c.sc_rt, sc->sc_c.sc_rh, SIOP_DSA));
			if (siop_cmd)
				printf("last msg_in=0x%x status=0x%x\n",
				    siop_cmd->cmd_tables->msg_in[0],
				    letoh32(siop_cmd->cmd_tables->status));
			else 
				printf("current DSA invalid\n");
			need_reset = 1;
d460 1
a460 1
		 * Can't read sist0 & sist1 independently, or we have to
d469 3
a471 1
		    "DSA=0x%x DSP=0x%lx\n", sist, sstat1,
a493 1
				/* XXX Why read DSTAT again? */
d604 1
a604 1
		/* Else it's an unhandled exception (for now). */
d606 3
a608 2
		    "DSA=0x%x DSP=0x%x\n", sc->sc_c.sc_dev.dv_xname,
		    sist, sstat1,
d1086 1
a1088 1
		struct scsi_sense *cmd = (struct scsi_sense *)&siop_cmd->cmd_c.siop_tables->xscmd;
d1090 5
a1094 8
		bzero(cmd, sizeof(*cmd));
		siop_cmd->cmd_c.siop_tables->cmd.count =
		   htole32(sizeof(struct scsi_sense));
		cmd->opcode = REQUEST_SENSE;
		cmd->byte2 = xs->sc_link->lun << 5;
		cmd->unused[0] = cmd->unused[1] = 0;
		cmd->length = sizeof(struct scsi_sense_data);
		cmd->control = 0;
d1096 10
d1114 1
d1120 3
d1189 1
a1189 1
 * target struct and report lossage to upper layer.
d1210 1
a1210 1
	 * Process all commands: first commands being executed
d1230 6
d1237 2
a1238 4
				TAILQ_INSERT_TAIL(&reset_list, siop_cmd, next);
				sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
				printf("cmd %p (tag %d) added to reset list\n",
				    siop_cmd, tag);
d1241 5
a1245 7
		if (sc->sc_c.targets[target]->status != TARST_PROBING) {
			sc->sc_c.targets[target]->status = TARST_ASYNC;
			sc->sc_c.targets[target]->flags &= ~TARF_ISWIDE;
			sc->sc_c.targets[target]->period =
			    sc->sc_c.targets[target]->offset = 0;
			siop_update_xfer_mode(&sc->sc_c, target);
		}
d1251 4
a1256 3
		sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
		printf("cmd %p added to reset list from urgent list\n",
		    siop_cmd);
d1258 1
a1258 1
	/* Then commands waiting in the input list. */
d1262 4
a1267 3
		sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
		printf("cmd %p added to reset list from ready list\n",
		    siop_cmd);
d1273 5
a1277 8
		siop_cmd->cmd_c.flags &= ~CMDFL_TAG;
		siop_cmd->cmd_c.xs->error =
		    (siop_cmd->cmd_c.flags & CMDFL_TIMEOUT)
		    ? XS_TIMEOUT : XS_RESET;
		siop_cmd->cmd_c.xs->status = SCSI_SIOP_NOCHECK;
		sc_print_addr(siop_cmd->cmd_c.xs->sc_link);
		printf("cmd %p (status %d) reset",
		    siop_cmd, siop_cmd->cmd_c.status);
a1282 2
		printf(" with status %d, xs->error %d\n",
		    siop_cmd->cmd_c.status, siop_cmd->cmd_c.xs->error);
d1285 1
a1377 5
	bzero(&siop_cmd->cmd_c.siop_tables->xscmd,
	    sizeof(siop_cmd->cmd_c.siop_tables->xscmd));
	bcopy(xs->cmd, &siop_cmd->cmd_c.siop_tables->xscmd, xs->cmdlen);
	siop_cmd->cmd_c.siop_tables->cmd.count = htole32(xs->cmdlen);

d1379 10
d1396 1
a1396 1
			printf("%s: unable to load data DMA map: %d\n",
d1399 2
d1410 3
a1679 3
	/* deactivate callout */
	timeout_del(&siop_cmd->cmd_c.xs->stimeout);

d1681 1
a1681 2
	printf("timeout on SCSI command 0x%x\n",
	    siop_cmd->cmd_c.xs->cmd->opcode);
d1686 8
a1694 1
	siop_handle_reset(sc);
d1696 1
a1697 1
	return;
d1776 1
a1776 1
#ifdef SIOP_DEBUG
d1790 10
a1825 3
		xfer->siop_tables.cmd.count= htole32(0);
		xfer->siop_tables.cmd.addr = htole32(dsa +
				offsetof(struct siop_common_xfer, xscmd));
d2016 1
a2016 1
#ifdef SIOP_DEBUG
d2026 1
a2026 1
	 * we need 8 bytes for the lun sw additional entry, and
d2040 1
a2040 1
#ifdef SIOP_DEBUG
@


1.7.4.9
log
@Merge with the trunk
@
text
@a771 9
				} else if (msg == MSG_EXTENDED &&
				    extmsg == MSG_EXT_PPR) {
					/* PPR negotiation rejected */
					siop_target->target_c.offset = 0;
					siop_target->target_c.period = 0;
					siop_target->target_c.status = TARST_ASYNC;
					siop_target->target_c.flags &= ~(TARF_DT | TARF_ISDT);
					CALL_SCRIPT(Ent_msgin_ack);
					return 1;
d878 1
a878 1
					    "siop_sdtr_neg()");
d1397 34
a1430 9
	if ((xs->flags & SCSI_POLL) == 0) {
		splx(s);
		return (SUCCESSFULLY_QUEUED);
	}

	/* Poll for command completion. */
	for(i = xs->timeout; i > 0; i--) {
		siop_intr(sc);
		if ((xs->flags & ITSDONE) == 0) {
a1431 1
			continue;
d1433 8
a1440 29
		if (xs->cmd->opcode == INQUIRY && xs->error == XS_NOERROR) {
			struct scsi_inquiry_data *inqbuf =
			    (struct scsi_inquiry_data *)xs->data;
		 	if ((inqbuf->device & SID_QUAL) == SID_QUAL_BAD_LU)
				break;
			/* 
			 * Allocate cbd's to hold maximum openings worth of
			 * commands. Do this now because doing it dynamically in
			 * siop_startcmd may cause calls to bus_dma* functions
			 * in interrupt context.
			 */
			for (j = 0; j < SIOP_NTAG; j += SIOP_NCMDPB)
				siop_morecbd(sc);
			if (sc->sc_c.targets[target]->status == TARST_PROBING)
				sc->sc_c.targets[target]->status = TARST_ASYNC;

			/*
			 * Set TARF_DT here because if it is turned off during
			 * PPR, it must STAY off!
			 */
			if ((lun == 0) && (sc->sc_c.features & SF_BUS_ULTRA3))
				sc->sc_c.targets[target]->flags |= TARF_DT;
			/*
			 * Can't do lun 0 here, because flags are not set yet.
			 * But have to do other lun's here because they never go
			 * through TARST_ASYNC.
			 */
			if (lun > 0)
				siop_add_dev(sc, target, lun);
d1442 1
a1442 1
		break;
a1443 6
	if (i == 0) {
		siop_timeout(siop_cmd);
		while ((xs->flags & ITSDONE) == 0)
			siop_intr(sc);
	}

d1445 1
a1445 1
	return (COMPLETE);
@


1.6
log
@Support U160 on 53c1010 chips.

Add support for PPR negotiations and DT transfers,
and the preservation and restoration of the
SCNTL4 register which controls Ultra3 transfers.

Redo sync lookup, since the same period factor
can mean two things depending on whether you are
using DT or ST. Keep a minimum allowed ST period
factor, and a minimum allowd DT period factor for
each adapter.

Currently NO support for QAS or IUS or AIP.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.5 2001/03/06 16:29:32 krw Exp $ */
d357 2
a358 2
	int istat, sist, sstat1, dstat;
	u_int32_t irqcode;
d606 1
a606 1
		/* Else it's an unhandled exeption (for now). */
d944 9
a952 7
	/* We just shouldn't get here */
	printf("istat = 0x%x, dstat = 0x%x, sist = 0x%x, sstat1 = 0x%x\n", istat, dstat, sist, sstat1);
	printf("need_reset = %d, irqcode = %d, siop_cmd = %p, siop_target = %p, xs = %p\n");
	if (siop_cmd != NULL)
		printf("siop_cmd->status = %d\n", siop_cmd->status);
	panic("%s: siop_intr: I shouldn't be here!", sc->sc_dev.dv_xname);
	return 1;
@


1.5
log
@1) Enable tag queuing.

2) Negotiate and report wide/sync only after INQUIRY
   results known.

3) Clean up wide/sync negotiation code a bit, ensuring
   that an agressive target does not prematurely force
   negotiation before the INQUIRY is done. Seen by millert@@.

4) Ensure that a wide negotiation always resets the
   sync settings to async.

5) Some error message improvements from thorpej@@NetBSD.

6) Some KNF.

7) Print wide/sync negotiation results after each
   completed negotiation.

8) Print some relevant information just before a panic
   that should never happen. But does on PowerPC.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.4 2001/03/01 17:14:27 krw Exp $ */
d232 18
a249 13
	/* find min/max sync period for this chip */
	sc->maxsync = 0;
	sc->minsync = 255;
	for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]); i++) {
		if (sc->clock_period != scf_period[i].clock)
			continue;
		if (sc->maxsync < scf_period[i].period)
			sc->maxsync = scf_period[i].period;
		if (sc->minsync > scf_period[i].period)
			sc->minsync = scf_period[i].period;
	}
	if (sc->maxsync == 255 || sc->minsync == 0)
		panic("siop: can't find my sync parameters\n");
d750 1
a750 1
					    sc->minsync, sc->maxoff);
d817 1
d830 19
a848 20
			if (siop_cmd->siop_tables.msg_in[2] == MSG_EXT_WDTR) {
				switch (siop_wdtr_neg(siop_cmd)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
d850 25
a874 20
			if (siop_cmd->siop_tables.msg_in[2] == MSG_EXT_SDTR) {
				switch (siop_sdtr_neg(siop_cmd)) {
				case SIOP_NEG_MSGOUT:
					siop_update_scntl3(sc,
					    siop_cmd->siop_target);
					siop_table_sync(siop_cmd,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);
					CALL_SCRIPT(Ent_send_msgout);
					return(1);
				case SIOP_NEG_ACK:
					siop_update_scntl3(sc,
					    siop_cmd->siop_target);
					CALL_SCRIPT(Ent_msgin_ack);
					return(1);
				default:
					panic("invalid retval from "
					    "siop_wdtr_neg()");
				}
				return(1);
d876 4
a879 7
			/* send a message reject */
			siop_cmd->siop_tables.msg_out[0] = MSG_MESSAGE_REJECT;
			siop_cmd->siop_tables.t_msgout.count = htole32(1);
			siop_table_sync(siop_cmd,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			CALL_SCRIPT(Ent_send_msgout);
			return 1;
d1190 1
a1190 1
		sc->targets[target]->flags &= ~TARF_ISWIDE;
d1373 1
d1378 8
a1385 1
					if (sc->targets[target]->flags & (TARF_WIDE | TARF_SYNC)) {
d1746 1
a1746 1
		newcbd->cmds[i].siop_tables.t_msgin.addr = htole32(dsa + 8);
d1748 1
a1748 1
		newcbd->cmds[i].siop_tables.t_extmsgin.addr = htole32(dsa + 9);
d1750 1
a1750 1
		    htole32(dsa + 11);
d1752 1
a1752 1
		newcbd->cmds[i].siop_tables.t_status.addr = htole32(dsa + 16);
d1912 10
@


1.4
log
@Typo police: various misspelling, capitalizations, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.3 2001/02/20 05:18:43 krw Exp $ */
a88 1
void	siop_print_info __P((struct siop_softc *, int));
d216 1
a216 1
	sc->sc_link.openings = 2;
d434 23
a456 23
		printf("DMA IRQ:");
		if (dstat & DSTAT_IID)
			printf(" Illegal instruction");
		if (dstat & DSTAT_ABRT)
			printf(" abort");
		if (dstat & DSTAT_BF)
			printf(" bus fault");
		if (dstat & DSTAT_MDPE)
			printf(" parity");
		if (dstat & DSTAT_DFE)
			printf(" dma fifo empty");
		printf(", DSP=0x%x DSA=0x%x: ",
		    (int)(bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSP) -
		    sc->sc_scriptaddr),
		    bus_space_read_4(sc->sc_rt, sc->sc_rh, SIOP_DSA));
		if (siop_cmd)
			printf("last msg_in=0x%x status=0x%x\n",
			    siop_cmd->siop_tables.msg_in[0],
			    letoh32(siop_cmd->siop_tables.status));
		else 
			printf("%s: current DSA invalid\n",
			    sc->sc_dev.dv_xname);
		need_reset = 1;
d738 1
d754 1
d937 6
a942 2
	/* We just should't get there */
	panic("siop_intr: I shouldn't be there !");
d1054 2
a1055 1
			printf("%s: unable to load cmd DMA map: %d",
d1064 2
a1065 1
			printf("%s: unable to load sense DMA map: %d",
a1226 31
void
siop_print_info(sc, target)
	struct siop_softc *sc;
	int target;
{
	const u_int32_t id = sc->targets[target]->id;
	const u_int8_t scf = ((id >> 24) & SCNTL3_SCF_MASK) >> SCNTL3_SCF_SHIFT;
	const u_int8_t offset = ((id >> 8) & SXFER_MO_MASK) >> SXFER_MO_SHIFT;
	const int clock = sc->clock_period;
	int i;

	printf("%s: target %d using %d bit ", sc->sc_dev.dv_xname, target,
	    (sc->targets[target]->flags & TARF_ISWIDE) ? 16 : 8);

	if (offset == 0)
		printf("async ");
	else {
		for (i = 0; i < sizeof(scf_period) / sizeof(scf_period[0]); i++)
			if ((scf_period[i].clock == clock) 
			    && (scf_period[i].scf == scf)) {
				printf("%s ", scf_period[i].rate);
				break;
			}
		if (i == sizeof(scf_period) / sizeof(scf_period[0]))
			printf("? ");
		printf("MHz %d REQ/ACK offset ", offset);
	}
	
	printf("xfers\n");
}

d1231 1
d1240 1
a1240 1
	printf("starting cmd for %d:%d\n", target, lun);
d1283 1
a1283 6

		if (sc->features & SF_BUS_WIDE)
			sc->targets[target]->flags = TARF_SYNC | TARF_WIDE;
		else
			sc->targets[target]->flags = TARF_SYNC;
			
d1300 1
a1300 2
	} else if (sc->targets[target]->status == TARST_PROBING)
		sc->targets[target]->status = TARST_ASYNC;
d1324 1
a1324 1
		printf("%s: unable to load cmd DMA map: %d",
d1334 1
a1334 1
			printf("%s: unable to load cmd DMA map: %d",
d1360 19
a1378 2
				    && (xs->error == XS_NOERROR))
					siop_print_info(sc, target);
@


1.3
log
@If you can't do wide xfers, don't tempt the targets by offering
it. They might not turn you down. Spotted by drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.2 2001/02/20 00:32:28 krw Exp $ */
d74 1
a74 1
/* Number of scheduler slot (needs to match script) */
d507 2
a508 2
				 * previous phase may be aborted for any reason
				 * ( for example, the target has less data to
d520 1
a520 1
					 * target may be ready to disconnect
d588 1
a588 1
				 * we have a script interrupt, it will
d594 1
a594 1
			 * else we have to restart it ourselve, at the
d711 2
a712 2
					 * message was part of a identify +
					 * something else. Identify shoudl't
d724 1
a724 1
					/* MSG_REJECT  for a MSG_REJECT  !*/
d941 1
a941 1
	 * restart the script now if command completed properly
d943 1
a943 1
	 * a cmd in front of the queue
d993 6
a998 7
		 * device didn't queue the command. We have to
		 * retry it.
		 * We insert it in the urgent list, hoping to preserve order.
		 * But unfortunably, commands already in the scheduler may
		 * be accepted before this one.
		 * Also remember the condition, to avoid starting new commands
		 * for this device before one is done.
d1129 3
a1131 3
 * handle a bus reset: reset chip, unqueue all active commands, free all
 * target struct and report loosage to upper layer.
 * As the upper layer may requeue immediatly we have to first store
d1143 2
a1144 2
	 * scsi bus reset. reset the chip and restart
	 * the queue. Need to clean up all active commands
d1426 1
a1426 1
	 * at the slot from first to last, so if we always use the first 
d1497 1
a1497 1
			/* no more free slot, no need to continue */
d1566 1
a1566 1
				/* start exire timer */
a1620 1
	/* mark command as being timed out; siop_intr will handle it */
d1622 3
a1624 3
	 * mark command has being timed out and just return;
	 * the bus reset will generate an interrupt,
	 * it will be handled in siop_intr()
d1927 2
a1928 2
		 * can't extend this slot. Probably not worth trying to deal
		 * with this case
d1940 1
a1940 1
	 * we need 8 bytes for the lun sw additionnal entry, and
d1942 1
a1942 1
	 * Keep enouth free space for the free targets that could be
d1951 1
a1951 1
		 * not enouth space, probably not worth dealing with it.
d1955 1
a1955 1
		printf("%s:%d:%d: not enouth memory for a lun sw slot\n",
@


1.2
log
@Tone down the verbosity level on the siop driver, print negotiation
results on one line, during boot polling only.

Force wide/sync negotiations for all targets during boot.

Delete extraneous name field and associated strings that duplicate
info provided in INQUIRY data.

Actually timeout during polling rather than wait forever for
ITSDONE.

Remove unneeded check for SCSI_POLL before calling scsi_done(). Makes
logic conform to other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: siop.c,v 1.1 2001/02/15 04:07:58 krw Exp $ */
d1307 6
a1312 1
		sc->targets[target]->flags = TARF_WIDE | TARF_SYNC;
@


1.1
log
@Import siop, a replacement for the ncr SCSI driver, from NetBSD.

Written for NetBSD by Manuel Bouyer.

Tested with various cards on i386 and alpha.

Outstanding issue: doesn't work with PowerPC yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d89 1
a735 4
					/* WDTR rejected, initiate sync */
					printf("%s: target %d using 8bit "
					    "transfers\n", sc->sc_dev.dv_xname,
					    target);
a752 4
					/* sync rejected */
					printf("%s: target %d asynchronous\n",
					    sc->sc_dev.dv_xname,
					    target);
d1084 1
a1084 2
	if ((xs->flags & SCSI_POLL) == 0)
		scsi_done (xs);
d1221 31
d1307 1
a1307 1
		sc->targets[target]->flags = 0;
d1324 3
a1326 1
	}
d1380 9
a1388 1
		while ((xs->flags & ITSDONE) == 0) {
a1389 1
			siop_intr(sc);
d1392 5
@

