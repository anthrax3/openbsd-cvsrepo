head	1.51;
access;
symbols
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.6
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.47.0.6
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.41.0.20
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.18
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.14
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.16
	OPENBSD_5_0:1.41.0.12
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.10
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.8
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.4
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.6
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.2
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.40.0.4
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.37.0.4
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.31.0.4
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.29.0.4
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.25
	SMP:1.24.0.4
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	UBC_SYNC_B:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	UBC:1.16.0.2
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.51
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.50;
commitid	5gdEnqVoJuTuwdTu;

1.50
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.49;
commitid	FuSD2mFDJWATHIDx;

1.49
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.48;
commitid	5DvsamK0GblTp8ww;

1.48
date	2015.11.04.12.22.01;	author dlg;	state Exp;
branches;
next	1.47;
commitid	R6jlRnhn2aOlkkT9;

1.47
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.46;
commitid	Z1vcFtHO8wRH0yRt;

1.46
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.45;
commitid	uzzBR7hz9ncd4O6G;

1.45
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.44;
commitid	jdBY2kKXhfcoQitp;

1.44
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.43;
commitid	TGHgrLxu6sxZoiFt;

1.43
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.42;
commitid	I19imNlAX05zJOED;

1.42
date	2013.08.07.01.06.30;	author bluhm;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.09.17.06.18;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.06.02.18.38;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.26.19.46.28;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.01.20.22.22;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.27.09.48.02;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.03.21.11.48;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.31.05.37.13;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.04.18.13.03;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.23.21.12.23;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.15.21.53.28;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.02.21.55.07;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.21.11.22.24;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.15.20.32.17;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.16.02.30.40;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.15.17.49.39;	author millert;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	2003.01.21.20.09.39;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.21.16.26.40;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.14.23.29.50;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.13.03.49.51;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.25.01.59.52;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.23.18.50.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.21.06.56.24;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2002.04.26.22.19.07;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.23.22.25.29;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.15.19.47.33;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.11.15.34.27;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.08.18.44.42;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.08.18.31.27;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.07.23.23.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.01.22.00.18;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.01.21.05.38;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.01.20.57.56;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.30.22.40.26;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.29.18.57.46;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.28.22.22.33;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.28.21.22.52;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2002.03.28.18.21.06;	author mickey;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;

1.24.4.1
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.24.4.2;

1.24.4.2
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	1.24.4.3;

1.24.4.3
date	2004.06.05.23.12.42;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.51
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_wi_hostap.c,v 1.50 2015/11/24 13:45:06 mpi Exp $	*/

/*
 * Copyright (c) 2002
 *	Thomas Skibo <skibo@@pacbell.net>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Thomas Skibo.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Thomas Skibo AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Thomas Skibo OR HIS DRINKING PALS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* This is experimental Host AP software for Prism 2 802.11b interfaces.
 *
 * Much of this is based upon the "Linux Host AP driver Host AP driver
 * for Intersil Prism2" by Jouni Malinen <jkm@@ssh.com> or <jkmaline@@cc.hut.fi>.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <sys/ucred.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/syslog.h>
#include <sys/sysctl.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_ioctl.h>

#include <dev/ic/if_wireg.h>
#include <dev/ic/if_wi_ieee.h>
#include <dev/ic/if_wivar.h>

void wihap_timeout(void *v);
void wihap_sta_timeout(void *v);
struct wihap_sta_info *wihap_sta_alloc(struct wi_softc *sc, u_int8_t *addr);
void wihap_sta_delete(struct wihap_sta_info *sta);
struct wihap_sta_info *wihap_sta_find(struct wihap_info *whi, u_int8_t *addr);
int wihap_sta_is_assoc(struct wihap_info *whi, u_int8_t addr[]);
void wihap_auth_req(struct wi_softc *sc, struct wi_frame *rxfrm,
    caddr_t pkt, int len);
void wihap_sta_deauth(struct wi_softc *sc, u_int8_t sta_addr[],
    u_int16_t reason);
void wihap_deauth_req(struct wi_softc *sc, struct wi_frame *rxfrm,
    caddr_t pkt, int len);
void wihap_assoc_req(struct wi_softc *sc, struct wi_frame *rxfrm,
    caddr_t pkt, int len);
void wihap_sta_disassoc(struct wi_softc *sc, u_int8_t sta_addr[],
    u_int16_t reason);
void wihap_disassoc_req(struct wi_softc *sc, struct wi_frame *rxfrm,
    caddr_t pkt, int len);

#ifndef SMALL_KERNEL
/*
 * take_hword()
 *
 *	Used for parsing management frames.  The pkt pointer and length
 *	variables are updated after the value is removed.
 */
static __inline u_int16_t
take_hword(caddr_t *ppkt, int *plen)
{
	u_int16_t s = letoh16(* (u_int16_t *) *ppkt);
	*ppkt += sizeof(u_int16_t);
	*plen -= sizeof(u_int16_t);
	return s;
}

/* take_tlv()
 *
 *	Parse out TLV element from a packet, check for underflow of packet
 *	or overflow of buffer, update pkt/len.
 */
static int
take_tlv(caddr_t *ppkt, int *plen, int id_expect, void *dst, int maxlen)
{
	u_int8_t id, len;

	if (*plen < 2)
		return -1;

	id = ((u_int8_t *)*ppkt)[0];
	len = ((u_int8_t *)*ppkt)[1];

	if (id != id_expect || *plen < len+2 || maxlen < len)
		return -1;

	bcopy(*ppkt + 2, dst, len);
	*plen -= 2 + len;
	*ppkt += 2 + len;

	return (len);
}

/* put_hword()
 *	Put half-word element into management frames.
 */
static __inline void
put_hword(caddr_t *ppkt, u_int16_t s)
{
	* (u_int16_t *) *ppkt = htole16(s);
	*ppkt += sizeof(u_int16_t);
}

/* put_tlv()
 *	Put TLV elements into management frames.
 */
static void
put_tlv(caddr_t *ppkt, u_int8_t id, void *src, u_int8_t len)
{
	(*ppkt)[0] = id;
	(*ppkt)[1] = len;
	bcopy(src, (*ppkt) + 2, len);
	*ppkt += 2 + len;
}

static int
put_rates(caddr_t *ppkt, u_int16_t rates)
{
	u_int8_t ratebuf[8];
	int len = 0;

	if (rates & WI_SUPPRATES_1M)
		ratebuf[len++] = 0x82;
	if (rates & WI_SUPPRATES_2M)
		ratebuf[len++] = 0x84;
	if (rates & WI_SUPPRATES_5M)
		ratebuf[len++] = 0x8b;
	if (rates & WI_SUPPRATES_11M)
		ratebuf[len++] = 0x96;

	put_tlv(ppkt, IEEE80211_ELEMID_RATES, ratebuf, len);
	return len;
}

/* wihap_init()
 *
 *	Initialize host AP data structures.  Called even if port type is
 *	not AP.  Caller MUST raise to splnet().
 */
void
wihap_init(struct wi_softc *sc)
{
	int i;
	struct wihap_info *whi = &sc->wi_hostap_info;

	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf("wihap_init: sc=%p whi=%p\n", sc, whi);

	bzero(whi, sizeof(struct wihap_info));

	if (sc->wi_ptype != WI_PORTTYPE_HOSTAP)
		return;

	whi->apflags = WIHAPFL_ACTIVE;

	TAILQ_INIT(&whi->sta_list);
	for (i = 0; i < WI_STA_HASH_SIZE; i++)
		LIST_INIT(&whi->sta_hash[i]);

	whi->inactivity_time = WIHAP_DFLT_INACTIVITY_TIME;
	timeout_set(&whi->tmo, wihap_timeout, sc);
}

/* wihap_sta_disassoc()
 *
 *	Send a disassociation frame to a specified station.
 */
void
wihap_sta_disassoc(struct wi_softc *sc, u_int8_t sta_addr[], u_int16_t reason)
{
	struct wi_80211_hdr	*resp_hdr;
	caddr_t			pkt;

	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf("Sending disassoc to sta %s\n", ether_sprintf(sta_addr));

	/* Send disassoc packet. */
	resp_hdr = (struct wi_80211_hdr *)sc->wi_txbuf;
	bzero(resp_hdr, sizeof(struct wi_80211_hdr));
	resp_hdr->frame_ctl = WI_FTYPE_MGMT | WI_STYPE_MGMT_DISAS;
	pkt = (caddr_t)&sc->wi_txbuf + sizeof(struct wi_80211_hdr);

	bcopy(sta_addr, resp_hdr->addr1, ETHER_ADDR_LEN);
	bcopy(sc->sc_ic.ic_myaddr, resp_hdr->addr2, IEEE80211_ADDR_LEN);
	bcopy(sc->sc_ic.ic_myaddr, resp_hdr->addr3, IEEE80211_ADDR_LEN);

	put_hword(&pkt, reason);

	wi_mgmt_xmit(sc, (caddr_t)&sc->wi_txbuf,
	    2 + sizeof(struct wi_80211_hdr));
}

/* wihap_sta_deauth()
 *
 *	Send a deauthentication message to a specified station.
 */
void
wihap_sta_deauth(struct wi_softc *sc, u_int8_t sta_addr[], u_int16_t reason)
{
	struct wi_80211_hdr	*resp_hdr;
	caddr_t			pkt;

	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf("Sending deauth to sta %s\n", ether_sprintf(sta_addr));

	/* Send deauth packet. */
	resp_hdr = (struct wi_80211_hdr *)sc->wi_txbuf;
	bzero(resp_hdr, sizeof(struct wi_80211_hdr));
	resp_hdr->frame_ctl = htole16(WI_FTYPE_MGMT | WI_STYPE_MGMT_DEAUTH);
	pkt = (caddr_t)&sc->wi_txbuf + sizeof(struct wi_80211_hdr);

	bcopy(sta_addr, resp_hdr->addr1, ETHER_ADDR_LEN);
	bcopy(sc->sc_ic.ic_myaddr, resp_hdr->addr2, IEEE80211_ADDR_LEN);
	bcopy(sc->sc_ic.ic_myaddr, resp_hdr->addr3, IEEE80211_ADDR_LEN);

	put_hword(&pkt, reason);

	wi_mgmt_xmit(sc, (caddr_t)&sc->wi_txbuf,
	    2 + sizeof(struct wi_80211_hdr));
}

/* wihap_shutdown()
 *
 *	Disassociate all stations and free up data structures.
 */
void
wihap_shutdown(struct wi_softc *sc)
{
	struct wihap_info	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info	*sta, *next;
	int i, s;

	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf("wihap_shutdown: sc=%p whi=%p\n", sc, whi);

	if (!(whi->apflags & WIHAPFL_ACTIVE))
		return;
	whi->apflags = 0;

	s = splnet();

	/* Disable wihap inactivity timer. */
	timeout_del(&whi->tmo);

	/* Delete all stations from the list. */
	for (sta = TAILQ_FIRST(&whi->sta_list); sta != NULL; sta = next) {
		timeout_del(&sta->tmo);
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_shutdown: free(sta=%p)\n", sta);
		next = TAILQ_NEXT(sta, list);
		if (sta->challenge)
			free(sta->challenge, M_TEMP, 0);
		free(sta, M_DEVBUF, 0);
	}
	TAILQ_INIT(&whi->sta_list);

	/* Broadcast disassoc and deauth to all the stations. */
	if (sc->wi_flags & WI_FLAGS_ATTACHED) {
		for (i = 0; i < 5; i++) {
			wihap_sta_disassoc(sc, etherbroadcastaddr,
			    IEEE80211_REASON_ASSOC_LEAVE);
			wihap_sta_deauth(sc, etherbroadcastaddr,
			    IEEE80211_REASON_AUTH_LEAVE);
			DELAY(50);
		}
	}

	splx(s);
}

/* sta_hash_func()
 * Hash function for finding stations from ethernet address.
 */
static __inline int
sta_hash_func(u_int8_t addr[])
{
	return ((addr[3] + addr[4] + addr[5]) % WI_STA_HASH_SIZE);
}

/* addr_cmp():  Maybe this is a faster way to compare addresses? */
static __inline int
addr_cmp(u_int8_t a[], u_int8_t b[])
{
	return (*(u_int16_t *)(a + 4) == *(u_int16_t *)(b + 4) &&
		*(u_int16_t *)(a + 2) == *(u_int16_t *)(b + 2) &&
		*(u_int16_t *)(a    ) == *(u_int16_t *)(b));
}

/* wihap_sta_movetail(): move sta to the tail of the station list in whi */
static __inline void
wihap_sta_movetail(struct wihap_info *whi, struct wihap_sta_info *sta)
{
	TAILQ_REMOVE(&whi->sta_list, sta, list);
	sta->flags &= ~WI_SIFLAGS_DEAD;
	TAILQ_INSERT_TAIL(&whi->sta_list, sta, list);
}

void
wihap_timeout(void *v)
{
	struct wi_softc		*sc = v;
	struct wihap_info	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info	*sta, *next;
	int	i, s;

	s = splnet();

	for (i = 10, sta = TAILQ_FIRST(&whi->sta_list);
	    i != 0 && sta != NULL && (sta->flags & WI_SIFLAGS_DEAD);
	    i--, sta = next) {
		next = TAILQ_NEXT(sta, list);
		if (timeout_pending(&sta->tmo)) {
			/* Became alive again, move to end of list. */
			wihap_sta_movetail(whi, sta);
		} else if (sta->flags & WI_SIFLAGS_ASSOC) {
			if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
				printf("wihap_timeout: disassoc due to inactivity: %s\n",
				    ether_sprintf(sta->addr));

			/* Disassoc station. */
			wihap_sta_disassoc(sc, sta->addr,
			    IEEE80211_REASON_ASSOC_EXPIRE);
			sta->flags &= ~WI_SIFLAGS_ASSOC;

			/*
			 * Move to end of the list and reset station timeout.
			 * We do this to make sure we don't get deauthed
			 * until inactivity_time seconds have passed.
			 */
			wihap_sta_movetail(whi, sta);
			timeout_add_sec(&sta->tmo, whi->inactivity_time);
		} else if (sta->flags & WI_SIFLAGS_AUTHEN) {
			if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
				printf("wihap_timeout: deauth due to inactivity: %s\n",
				    ether_sprintf(sta->addr));

			/* Deauthenticate station. */
			wihap_sta_deauth(sc, sta->addr,
			    IEEE80211_REASON_AUTH_EXPIRE);
			sta->flags &= ~WI_SIFLAGS_AUTHEN;

			/* Delete the station if it's not permanent. */
			if (sta->flags & WI_SIFLAGS_PERM)
				wihap_sta_movetail(whi, sta);
			else
				wihap_sta_delete(sta);
		}
	}

	/* Restart the timeout if there are still dead stations left. */
	sta = TAILQ_FIRST(&whi->sta_list);
	if (sta != NULL && (sta->flags & WI_SIFLAGS_DEAD))
		timeout_add(&whi->tmo, 1);	/* still work left, requeue */

	splx(s);
}

void
wihap_sta_timeout(void *v)
{
	struct wihap_sta_info	*sta = v;
	struct wi_softc		*sc = sta->sc;
	struct wihap_info	*whi = &sc->wi_hostap_info;
	int	s;

	s = splnet();

	/* Mark sta as dead and move it to the head of the list. */
	TAILQ_REMOVE(&whi->sta_list, sta, list);
	sta->flags |= WI_SIFLAGS_DEAD;
	TAILQ_INSERT_HEAD(&whi->sta_list, sta, list);

	/* Add wihap timeout if we have not already done so. */
	if (!timeout_pending(&whi->tmo))
		timeout_add(&whi->tmo, hz / 10);

	splx(s);
}

/* wihap_sta_delete()
 * Delete a single station and free up its data structure.
 * Caller must raise to splnet().
 */
void
wihap_sta_delete(struct wihap_sta_info *sta)
{
	struct wi_softc		*sc = sta->sc;
	struct wihap_info	*whi = &sc->wi_hostap_info;
	int i = sta->asid - 0xc001;

	timeout_del(&sta->tmo);

	whi->asid_inuse_mask[i >> 4] &= ~(1UL << (i & 0xf));

	TAILQ_REMOVE(&whi->sta_list, sta, list);
	LIST_REMOVE(sta, hash);
	if (sta->challenge)
		free(sta->challenge, M_TEMP, 0);
	free(sta, M_DEVBUF, 0);
	whi->n_stations--;
}

/* wihap_sta_alloc()
 *
 *	Create a new station data structure and put it in the list
 *	and hash table.
 */
struct wihap_sta_info *
wihap_sta_alloc(struct wi_softc *sc, u_int8_t *addr)
{
	struct wihap_info	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info	*sta;
	int i, hash = sta_hash_func(addr);

	/* Allocate structure. */
	sta = malloc(sizeof(*sta), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sta == NULL)
		return (NULL);

	/* Allocate an ASID. */
	i=hash<<4;
	while (whi->asid_inuse_mask[i >> 4] & (1UL << (i & 0xf)))
		i = (i == (WI_STA_HASH_SIZE << 4) - 1) ? 0 : (i + 1);
	whi->asid_inuse_mask[i >> 4] |= (1UL << (i & 0xf));
	sta->asid = 0xc001 + i;

	/* Insert in list and hash list. */
	TAILQ_INSERT_TAIL(&whi->sta_list, sta, list);
	LIST_INSERT_HEAD(&whi->sta_hash[hash], sta, hash);

	sta->sc = sc;
	whi->n_stations++;
	bcopy(addr, &sta->addr, ETHER_ADDR_LEN);
	timeout_set(&sta->tmo, wihap_sta_timeout, sta);
	timeout_add_sec(&sta->tmo, whi->inactivity_time);

	return (sta);
}

/* wihap_sta_find()
 *
 *	Find station structure given address.
 */
struct wihap_sta_info *
wihap_sta_find(struct wihap_info *whi, u_int8_t *addr)
{
	int i;
	struct wihap_sta_info *sta;

	i = sta_hash_func(addr);
	LIST_FOREACH(sta, &whi->sta_hash[i], hash)
		if (addr_cmp(addr, sta->addr))
			return sta;

	return (NULL);
}

static __inline int
wihap_check_rates(struct wihap_sta_info *sta, u_int8_t rates[], int rates_len)
{
	struct wi_softc *sc = sta->sc;
	int	i;

	sta->rates = 0;
	sta->tx_max_rate = 0;
	for (i = 0; i < rates_len; i++)
		switch (rates[i] & 0x7f) {
		case 0x02:
			sta->rates |= WI_SUPPRATES_1M;
			break;
		case 0x04:
			sta->rates |= WI_SUPPRATES_2M;
			if (sta->tx_max_rate < 1)
				sta->tx_max_rate = 1;
			break;
		case 0x0b:
			sta->rates |= WI_SUPPRATES_5M;
			if (sta->tx_max_rate < 2)
				sta->tx_max_rate = 2;
			break;
		case 0x16:
			sta->rates |= WI_SUPPRATES_11M;
			sta->tx_max_rate = 3;
			break;
		}

	sta->rates &= sc->wi_supprates;
	sta->tx_curr_rate = sta->tx_max_rate;

	return (sta->rates == 0 ? -1 : 0);
}


/* wihap_auth_req()
 *
 *	Handle incoming authentication request.
 */
void
wihap_auth_req(struct wi_softc *sc, struct wi_frame *rxfrm,
    caddr_t pkt, int len)
{
	struct wihap_info	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info	*sta;
	int			i, s;

	u_int16_t		algo;
	u_int16_t		seq;
	u_int16_t		status;
	int			challenge_len;
	u_int32_t		challenge[32];

	struct wi_80211_hdr	*resp_hdr;

	if (len < 6) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_auth_req: station %s short request\n",
			    ether_sprintf(rxfrm->wi_addr2));
		return;
	}

	/* Break open packet. */
	algo = take_hword(&pkt, &len);
	seq = take_hword(&pkt, &len);
	status = take_hword(&pkt, &len);
	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf("wihap_auth_req: station %s algo=0x%x seq=0x%x\n",
		    ether_sprintf(rxfrm->wi_addr2), algo, seq);

	/* Ignore vendor private tlv (if any). */
	(void)take_tlv(&pkt, &len, IEEE80211_ELEMID_VENDOR, challenge,
	    sizeof(challenge));

	challenge_len = 0;
	if (len > 0 && (challenge_len = take_tlv(&pkt, &len,
	    IEEE80211_ELEMID_CHALLENGE, challenge, sizeof(challenge))) < 0) {
		status = IEEE80211_STATUS_CHALLENGE;
		goto fail;
	}

	/* Find or create station info. */
	sta = wihap_sta_find(whi, rxfrm->wi_addr2);
	if (sta == NULL) {

		/* Are we allowing new stations?
		 */
		if (whi->apflags & WIHAPFL_MAC_FILT) {
			status = IEEE80211_STATUS_OTHER; /* XXX */
			goto fail;
		}

		/* Check for too many stations.
		 */
		if (whi->n_stations >= WIHAP_MAX_STATIONS) {
			status = IEEE80211_STATUS_TOOMANY;
			goto fail;
		}

		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_auth_req: new station\n");

		/* Create new station. */
		s = splnet();
		sta = wihap_sta_alloc(sc, rxfrm->wi_addr2);
		splx(s);
		if (sta == NULL) {
			/* Out of memory! */
			status = IEEE80211_STATUS_TOOMANY;
			goto fail;
		}
	}
	timeout_add_sec(&sta->tmo, whi->inactivity_time);

	/* Note: it's okay to leave the station info structure around
	 * if the authen fails.  It'll be timed out eventually.
	 */
	switch (algo) {
	case IEEE80211_AUTH_ALG_OPEN:
		if (sc->wi_authtype != IEEE80211_AUTH_OPEN) {
			status = IEEE80211_STATUS_ALG;
			goto fail;
		}
		if (seq != 1) {
			status = IEEE80211_STATUS_SEQUENCE;
			goto fail;
		}
		challenge_len = 0;
		sta->flags |= WI_SIFLAGS_AUTHEN;
		break;
	case IEEE80211_AUTH_ALG_SHARED:
		if (sc->wi_authtype != IEEE80211_AUTH_SHARED) {
			status = IEEE80211_STATUS_ALG;
			goto fail;
		}
		switch (seq) {
		case 1:
			/* Create a challenge frame. */
			if (!sta->challenge) {
				sta->challenge = malloc(128, M_TEMP, M_NOWAIT);
				if (!sta->challenge)
					return;
			}
			for (i = 0; i < 32; i++)
				challenge[i] = sta->challenge[i] =
					arc4random();
			
			if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
				printf("\tchallenge: 0x%x 0x%x ...\n",
				   challenge[0], challenge[1]);
			challenge_len = 128;
			break;
		case 3:
			if (challenge_len != 128 || !sta->challenge ||
			    !(letoh16(rxfrm->wi_frame_ctl) & WI_FCTL_WEP)) {
				status = IEEE80211_STATUS_CHALLENGE;
				goto fail;
			}

			for (i=0; i<32; i++)
				if (sta->challenge[i] != challenge[i]) {
					status = IEEE80211_STATUS_CHALLENGE;
					goto fail;
				}

			sta->flags |= WI_SIFLAGS_AUTHEN;
			free(sta->challenge, M_TEMP, 0);
			sta->challenge = NULL;
			challenge_len = 0;
			break;
		default:
			status = IEEE80211_STATUS_SEQUENCE;
			goto fail;
		} /* switch (seq) */
		break;
	default:
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_auth_req: algorithm unsupported: 0x%x\n",
			   algo);
		status = IEEE80211_STATUS_ALG;
		goto fail;
	} /* switch (algo) */

	status = IEEE80211_STATUS_SUCCESS;

fail:
	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf("wihap_auth_req: returns status=0x%x\n", status);

	/* Send response. */
	resp_hdr = (struct wi_80211_hdr *)&sc->wi_txbuf;
	bzero(resp_hdr, sizeof(struct wi_80211_hdr));
	resp_hdr->frame_ctl = htole16(WI_FTYPE_MGMT | WI_STYPE_MGMT_AUTH);
	bcopy(rxfrm->wi_addr2, resp_hdr->addr1, ETHER_ADDR_LEN);
	bcopy(sc->sc_ic.ic_myaddr, resp_hdr->addr2, IEEE80211_ADDR_LEN);
	bcopy(sc->sc_ic.ic_myaddr, resp_hdr->addr3, IEEE80211_ADDR_LEN);

	pkt = (caddr_t)&sc->wi_txbuf + sizeof(struct wi_80211_hdr);
	put_hword(&pkt, algo);
	put_hword(&pkt, seq + 1);
	put_hword(&pkt, status);
	if (challenge_len > 0)
		put_tlv(&pkt, IEEE80211_ELEMID_CHALLENGE,
			challenge, challenge_len);

	wi_mgmt_xmit(sc, (caddr_t)&sc->wi_txbuf,
	    6 + sizeof(struct wi_80211_hdr) +
	    (challenge_len > 0 ? challenge_len + 2 : 0));
}


/* wihap_assoc_req()
 *
 *	Handle incoming association and reassociation requests.
 */
void
wihap_assoc_req(struct wi_softc *sc, struct wi_frame *rxfrm,
		caddr_t pkt, int len)
{
	struct wihap_info	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info	*sta;
	struct wi_80211_hdr	*resp_hdr;
	u_int16_t		capinfo;
	u_int16_t		lstintvl;
	u_int8_t		rates[12];
	int			ssid_len, rates_len;
	struct ieee80211_nwid	ssid;
	u_int16_t		status;
	u_int16_t		asid = 0;

	if (len < 8)
		return;

	/* Pull out request parameters. */
	capinfo = take_hword(&pkt, &len);
	lstintvl = take_hword(&pkt, &len);

	if ((rxfrm->wi_frame_ctl & htole16(WI_FCTL_STYPE)) ==
	    htole16(WI_STYPE_MGMT_REASREQ)) {
		if (len < 6)
			return;
		/* Eat the MAC address of the current AP */
		take_hword(&pkt, &len);
		take_hword(&pkt, &len);
		take_hword(&pkt, &len);
	}

	if ((ssid_len = take_tlv(&pkt, &len, IEEE80211_ELEMID_SSID,
	    ssid.i_nwid, sizeof(ssid))) < 0)
		return;
	ssid.i_len = ssid_len;
	if ((rates_len = take_tlv(&pkt, &len, IEEE80211_ELEMID_RATES,
	    rates, sizeof(rates))) < 0)
		return;

	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf("wihap_assoc_req: from station %s\n",
		    ether_sprintf(rxfrm->wi_addr2));

	/* If SSID doesn't match, simply drop. */
	if (sc->wi_net_name.i_len != ssid.i_len ||
	    memcmp(sc->wi_net_name.i_nwid, ssid.i_nwid, ssid.i_len)) {

		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_assoc_req: bad ssid: '%.*s' != '%.*s'\n",
			    ssid.i_len, ssid.i_nwid, sc->wi_net_name.i_len,
			    sc->wi_net_name.i_nwid);
		return;
	}

	/* Is this station authenticated yet? */
	sta = wihap_sta_find(whi, rxfrm->wi_addr2);
	if (sta == NULL || !(sta->flags & WI_SIFLAGS_AUTHEN)) {
		wihap_sta_deauth(sc, rxfrm->wi_addr2,
		    IEEE80211_REASON_NOT_AUTHED);
		return;
	}

	/* Check supported rates against ours. */
	if (wihap_check_rates(sta, rates, rates_len) < 0) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_assoc_req: rates mismatch.\n");
		status = IEEE80211_STATUS_BASIC_RATE;
		goto fail;
	}

	/* Check capinfo.
	 * Check for ESS, not IBSS.
	 * Check WEP/PRIVACY flags match.
	 * Refuse stations requesting to be put on CF-polling list.
	 */
	sta->capinfo = capinfo;
	status = IEEE80211_STATUS_CAPINFO;
	if ((capinfo & (IEEE80211_CAPINFO_ESS | IEEE80211_CAPINFO_IBSS)) !=
	    IEEE80211_CAPINFO_ESS) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_assoc_req: capinfo: not ESS: "
			    "capinfo=0x%x\n", capinfo);
		goto fail;

	}
	if ((sc->wi_use_wep && !(capinfo & IEEE80211_CAPINFO_PRIVACY)) ||
	    (!sc->wi_use_wep && (capinfo & IEEE80211_CAPINFO_PRIVACY))) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_assoc_req: WEP flag mismatch: "
			    "capinfo=0x%x\n", capinfo);
		goto fail;
	}
	if ((capinfo & (IEEE80211_CAPINFO_CF_POLLABLE |
	    IEEE80211_CAPINFO_CF_POLLREQ)) == IEEE80211_CAPINFO_CF_POLLABLE) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_assoc_req: polling not supported: "
			    "capinfo=0x%x\n", capinfo);
		goto fail;
	}

	/* Use ASID is allocated by whi_sta_alloc(). */
	asid = sta->asid;

	if (sta->flags & WI_SIFLAGS_ASSOC) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_assoc_req: already assoc'ed?\n");
	}

	sta->flags |= WI_SIFLAGS_ASSOC;
	timeout_add_sec(&sta->tmo, whi->inactivity_time);
	status = IEEE80211_STATUS_SUCCESS;

fail:
	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		printf("wihap_assoc_req: returns status=0x%x\n", status);

	/* Send response. */
	resp_hdr = (struct wi_80211_hdr *)&sc->wi_txbuf;
	bzero(resp_hdr, sizeof(struct wi_80211_hdr));
	resp_hdr->frame_ctl = htole16(WI_FTYPE_MGMT | WI_STYPE_MGMT_ASRESP);
	pkt = (caddr_t)&sc->wi_txbuf + sizeof(struct wi_80211_hdr);

	bcopy(rxfrm->wi_addr2, resp_hdr->addr1, ETHER_ADDR_LEN);
	bcopy(sc->sc_ic.ic_myaddr, resp_hdr->addr2, IEEE80211_ADDR_LEN);
	bcopy(sc->sc_ic.ic_myaddr, resp_hdr->addr3, IEEE80211_ADDR_LEN);

	put_hword(&pkt, capinfo);
	put_hword(&pkt, status);
	put_hword(&pkt, asid);
	rates_len = put_rates(&pkt, sc->wi_supprates);

	wi_mgmt_xmit(sc, (caddr_t)&sc->wi_txbuf,
	    8 + rates_len + sizeof(struct wi_80211_hdr));
}

/* wihap_deauth_req()
 *
 *	Handle deauthentication requests.  Delete the station.
 */
void
wihap_deauth_req(struct wi_softc *sc, struct wi_frame *rxfrm,
		 caddr_t pkt, int len)
{
	struct wihap_info	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info	*sta;
	u_int16_t		reason;

	if (len<2)
		return;

	reason = take_hword(&pkt, &len);

	sta = wihap_sta_find(whi, rxfrm->wi_addr2);
	if (sta == NULL) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_deauth_req: unknown station: %s\n",
			    ether_sprintf(rxfrm->wi_addr2));
	}
	else
		wihap_sta_delete(sta);
}

/* wihap_disassoc_req()
 *
 *	Handle disassociation requests.  Just reset the assoc flag.
 *	We'll free up the station resources when we get a deauth
 *	request or when it times out.
 */
void
wihap_disassoc_req(struct wi_softc *sc, struct wi_frame *rxfrm,
    caddr_t pkt, int len)
{
	struct wihap_info	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info	*sta;
	u_int16_t		reason;

	if (len < 2)
		return;

	reason = take_hword(&pkt, &len);

	sta = wihap_sta_find(whi, rxfrm->wi_addr2);
	if (sta == NULL) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("wihap_disassoc_req: unknown station: %s\n",
			    ether_sprintf(rxfrm->wi_addr2));
	}
	else if (!(sta->flags & WI_SIFLAGS_AUTHEN)) {
		/*
		 * If station is not authenticated, send deauthentication
		 * frame.
		 */
		wihap_sta_deauth(sc, rxfrm->wi_addr2,
		    IEEE80211_REASON_NOT_AUTHED);
		return;
	}
	else
		sta->flags &= ~WI_SIFLAGS_ASSOC;
}

/* wihap_debug_frame_type()
 *
 * Print out frame type.  Used in early debugging.
 */
static __inline void
wihap_debug_frame_type(struct wi_frame *rxfrm)
{
	printf("wihap_mgmt_input: len=%d ", letoh16(rxfrm->wi_dat_len));

	if ((rxfrm->wi_frame_ctl & htole16(WI_FCTL_FTYPE)) ==
	    htole16(WI_FTYPE_MGMT)) {

		printf("MGMT: ");

		switch (letoh16(rxfrm->wi_frame_ctl) & WI_FCTL_STYPE) {
		case WI_STYPE_MGMT_ASREQ:
			printf("assoc req: \n");
			break;
		case WI_STYPE_MGMT_ASRESP:
			printf("assoc resp: \n");
			break;
		case WI_STYPE_MGMT_REASREQ:
			printf("reassoc req: \n");
			break;
		case WI_STYPE_MGMT_REASRESP:
			printf("reassoc resp: \n");
			break;
		case WI_STYPE_MGMT_PROBEREQ:
			printf("probe req: \n");
			break;
		case WI_STYPE_MGMT_PROBERESP:
			printf("probe resp: \n");
			break;
		case WI_STYPE_MGMT_BEACON:
			printf("beacon: \n");
			break;
		case WI_STYPE_MGMT_ATIM:
			printf("ann traf ind \n");
			break;
		case WI_STYPE_MGMT_DISAS:
			printf("disassociation: \n");
			break;
		case WI_STYPE_MGMT_AUTH:
			printf("auth: \n");
			break;
		case WI_STYPE_MGMT_DEAUTH:
			printf("deauth: \n");
			break;
		default:
			printf("unknown (stype=0x%x)\n",
			    letoh16(rxfrm->wi_frame_ctl) & WI_FCTL_STYPE);
		}

	}
	else {
		printf("ftype=0x%x (ctl=0x%x)\n",
		    letoh16(rxfrm->wi_frame_ctl) & WI_FCTL_FTYPE,
		    letoh16(rxfrm->wi_frame_ctl));
	}
}

/*
 * wihap_mgmt_input:
 *
 *	Called for each management frame received in host ap mode.
 *	wihap_mgmt_input() is expected to free the mbuf.
 */
void
wihap_mgmt_input(struct wi_softc *sc, struct wi_frame *rxfrm, struct mbuf *m)
{
	caddr_t	pkt;
	int	s, len;

	if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
		wihap_debug_frame_type(rxfrm);

	pkt = mtod(m, caddr_t) + WI_802_11_OFFSET_RAW;
	len = m->m_len - WI_802_11_OFFSET_RAW;

	if ((rxfrm->wi_frame_ctl & htole16(WI_FCTL_FTYPE)) ==
	    htole16(WI_FTYPE_MGMT)) {

		/* any of the following will mess w/ the station list */
		s = splsoftclock();
		switch (letoh16(rxfrm->wi_frame_ctl) & WI_FCTL_STYPE) {
		case WI_STYPE_MGMT_ASREQ:
			wihap_assoc_req(sc, rxfrm, pkt, len);
			break;
		case WI_STYPE_MGMT_ASRESP:
			break;
		case WI_STYPE_MGMT_REASREQ:
			wihap_assoc_req(sc, rxfrm, pkt, len);
			break;
		case WI_STYPE_MGMT_REASRESP:
			break;
		case WI_STYPE_MGMT_PROBEREQ:
			break;
		case WI_STYPE_MGMT_PROBERESP:
			break;
		case WI_STYPE_MGMT_BEACON:
			break;
		case WI_STYPE_MGMT_ATIM:
			break;
		case WI_STYPE_MGMT_DISAS:
			wihap_disassoc_req(sc, rxfrm, pkt, len);
			break;
		case WI_STYPE_MGMT_AUTH:
			wihap_auth_req(sc, rxfrm, pkt, len);
			break;
		case WI_STYPE_MGMT_DEAUTH:
			wihap_deauth_req(sc, rxfrm, pkt, len);
			break;
		}
		splx(s);
	}

	m_freem(m);
}

/* wihap_sta_is_assoc()
 *
 *	Determine if a station is assoc'ed.  Update its activity
 *	counter as a side-effect.
 */
int
wihap_sta_is_assoc(struct wihap_info *whi, u_int8_t addr[])
{
	struct wihap_sta_info *sta;

	sta = wihap_sta_find(whi, addr);
	if (sta != NULL && (sta->flags & WI_SIFLAGS_ASSOC)) {
		/* Keep it active. */
		timeout_add_sec(&sta->tmo, whi->inactivity_time);
		return (1);
	}

	return (0);
}

/* wihap_check_tx()
 *
 *	Determine if a station is assoc'ed, get its tx rate, and update
 *	its activity.
 */
int
wihap_check_tx(struct wihap_info *whi, u_int8_t addr[], u_int8_t *txrate)
{
	struct wihap_sta_info *sta;
	static u_int8_t txratetable[] = { 10, 20, 55, 110 };
	int s;

	if (addr[0] & 0x01) {
		*txrate = 0; /* XXX: multicast rate? */
		return (1);
	}

	s = splsoftclock();
	sta = wihap_sta_find(whi, addr);
	if (sta != NULL && (sta->flags & WI_SIFLAGS_ASSOC)) {
		/* Keep it active. */
		timeout_add_sec(&sta->tmo, whi->inactivity_time);
		*txrate = txratetable[sta->tx_curr_rate];
		splx(s);
		return (1);
	}
	splx(s);

	return (0);
}

/*
 * wihap_data_input()
 *
 *	Handle all data input on interface when in Host AP mode.
 *	Some packets are destined for this machine, others are
 *	repeated to other stations.
 *
 *	If wihap_data_input() returns a non-zero, it has processed
 *	the packet and will free the mbuf.
 */
int
wihap_data_input(struct wi_softc *sc, struct wi_frame *rxfrm, struct mbuf *m)
{
	struct ifnet		*ifp = &sc->sc_ic.ic_if;
	struct wihap_info	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info	*sta;
	int			mcast, s;
	u_int16_t		fctl;

	/*
	 * TODS flag must be set.  However, Lucent cards set NULLFUNC but
	 * not TODS when probing an AP to see if it is alive after it has
	 * been down for a while.  We accept these probe packets and send a
	 * disassoc packet later on if the station is not already associated.
	 */
	fctl = letoh16(rxfrm->wi_frame_ctl);
	if (!(fctl & WI_FCTL_TODS) && !(fctl & WI_STYPE_NULLFUNC)) {
		if (ifp->if_flags & IFF_DEBUG)
			printf("wihap_data_input: no TODS src=%s, fctl=0x%x\n",
			    ether_sprintf(rxfrm->wi_addr2), fctl);
		m_freem(m);
		return (1);
	}

	/* Check BSSID. (Is this necessary?) */
	if (!addr_cmp(rxfrm->wi_addr1, sc->sc_ic.ic_myaddr)) {
		if (ifp->if_flags & IFF_DEBUG)
			printf("wihap_data_input: incorrect bss: %s\n",
			    ether_sprintf(rxfrm->wi_addr1));
		m_freem(m);
		return (1);
	}

	s = splsoftclock();

	/* Find source station. */
	sta = wihap_sta_find(whi, rxfrm->wi_addr2);

	/* Source station must be associated. */
	if (sta == NULL || !(sta->flags & WI_SIFLAGS_ASSOC)) {
		if (ifp->if_flags & IFF_DEBUG)
			printf("wihap_data_input: dropping unassoc src %s\n",
			    ether_sprintf(rxfrm->wi_addr2));
		wihap_sta_disassoc(sc, rxfrm->wi_addr2,
		    IEEE80211_REASON_ASSOC_LEAVE);
		splx(s);
		m_freem(m);
		return (1);
	}

	timeout_add_sec(&sta->tmo, whi->inactivity_time);
	sta->sig_info = letoh16(rxfrm->wi_q_info);

	splx(s);

	/* Repeat this packet to BSS? */
	mcast = (rxfrm->wi_addr3[0] & 0x01) != 0;
	if (mcast || wihap_sta_is_assoc(whi, rxfrm->wi_addr3)) {

		/* If it's multicast, make a copy.
		 */
		if (mcast) {
			m = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
			if (m == NULL)
				return (0);
			m->m_flags |= M_MCAST; /* XXX */
		}

		/* Queue up for repeating.
		 */
		if_enqueue(ifp, m);
		return (!mcast);
	}

	return (0);
}

/* wihap_ioctl()
 *
 *	Handle Host AP specific ioctls.  Called from wi_ioctl().
 */
int
wihap_ioctl(struct wi_softc *sc, u_long command, caddr_t data)
{
	struct proc		*p = curproc;
	struct ifreq		*ifr = (struct ifreq *) data;
	struct wihap_info	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info	*sta;
	struct hostap_getall	reqall;
	struct hostap_sta	reqsta;
	struct hostap_sta	stabuf;
	int			s, error = 0, n, flag;

	struct ieee80211_nodereq nr;
	struct ieee80211_nodereq_all *na;

	if (!(sc->sc_ic.ic_if.if_flags & IFF_RUNNING))
		return ENODEV;

	switch (command) {
	case SIOCHOSTAP_DEL:
		if ((error = suser(p, 0)))
			break;
		if ((error = copyin(ifr->ifr_data, &reqsta, sizeof(reqsta))))
			break;
		s = splnet();
		sta = wihap_sta_find(whi, reqsta.addr);
		if (sta == NULL)
			error = ENOENT;
		else {
			/* Disassociate station. */
			if (sta->flags & WI_SIFLAGS_ASSOC)
				wihap_sta_disassoc(sc, sta->addr,
				    IEEE80211_REASON_ASSOC_LEAVE);
			/* Deauth station. */
			if (sta->flags & WI_SIFLAGS_AUTHEN)
				wihap_sta_deauth(sc, sta->addr,
				    IEEE80211_REASON_AUTH_LEAVE);

			wihap_sta_delete(sta);
		}
		splx(s);
		break;

	case SIOCHOSTAP_GET:
		if ((error = copyin(ifr->ifr_data, &reqsta, sizeof(reqsta))))
			break;
		s = splnet();
		sta = wihap_sta_find(whi, reqsta.addr);
		if (sta == NULL)
			error = ENOENT;
		else {
			reqsta.flags = sta->flags;
			reqsta.asid = sta->asid;
			reqsta.capinfo = sta->capinfo;
			reqsta.sig_info = sta->sig_info;
			reqsta.rates = sta->rates;

			error = copyout(&reqsta, ifr->ifr_data,
			    sizeof(reqsta));
		}
		splx(s);
		break;

	case SIOCHOSTAP_ADD:
		if ((error = suser(p, 0)))
			break;
		if ((error = copyin(ifr->ifr_data, &reqsta, sizeof(reqsta))))
			break;
		s = splnet();
		sta = wihap_sta_find(whi, reqsta.addr);
		if (sta != NULL) {
			error = EEXIST;
			splx(s);
			break;
		}
		if (whi->n_stations >= WIHAP_MAX_STATIONS) {
			error = ENOSPC;
			splx(s);
			break;
		}
		sta = wihap_sta_alloc(sc, reqsta.addr);
		sta->flags = reqsta.flags;
		timeout_add_sec(&sta->tmo, whi->inactivity_time);
		splx(s);
		break;

	case SIOCHOSTAP_SFLAGS:
		if ((error = suser(p, 0)))
			break;
		if ((error = copyin(ifr->ifr_data, &flag, sizeof(int))))
			break;

		whi->apflags = (whi->apflags & WIHAPFL_CANTCHANGE) |
		    (flag & ~WIHAPFL_CANTCHANGE);
		break;

	case SIOCHOSTAP_GFLAGS:
		flag = (int) whi->apflags;
		error = copyout(&flag, ifr->ifr_data, sizeof(int));
		break;

	case SIOCHOSTAP_GETALL:
		if ((error = copyin(ifr->ifr_data, &reqall, sizeof(reqall))))
			break;

		reqall.nstations = whi->n_stations;
		n = 0;
		s = splnet();
		sta = TAILQ_FIRST(&whi->sta_list);
		while (sta && reqall.size >= n+sizeof(struct hostap_sta)) {

			bcopy(sta->addr, stabuf.addr, ETHER_ADDR_LEN);
			stabuf.asid = sta->asid;
			stabuf.flags = sta->flags;
			stabuf.capinfo = sta->capinfo;
			stabuf.sig_info = sta->sig_info;
			stabuf.rates = sta->rates;

			error = copyout(&stabuf, (caddr_t) reqall.addr + n,
			    sizeof(struct hostap_sta));
			if (error)
				break;

			sta = TAILQ_NEXT(sta, list);
			n += sizeof(struct hostap_sta);
		}
		splx(s);

		if (!error)
			error = copyout(&reqall, ifr->ifr_data,
			    sizeof(reqall));
		break;

	case SIOCG80211ALLNODES:
		na = (struct ieee80211_nodereq_all *)data;
		na->na_nodes = n = 0;
		s = splnet();
		sta = TAILQ_FIRST(&whi->sta_list);
		while (sta && na->na_size >=
		    n + sizeof(struct ieee80211_nodereq)) {
			bzero(&nr, sizeof(nr));
			IEEE80211_ADDR_COPY(nr.nr_macaddr, sta->addr);
			IEEE80211_ADDR_COPY(nr.nr_bssid,
			    &sc->sc_ic.ic_myaddr);
			nr.nr_channel = sc->wi_channel;
			nr.nr_chan_flags = IEEE80211_CHAN_B;
			nr.nr_associd = sta->asid;
			nr.nr_rssi = sta->sig_info >> 8;
			nr.nr_max_rssi = 0;
			nr.nr_capinfo = sta->capinfo;
			nr.nr_nrates = 0;
			if (sta->rates & WI_SUPPRATES_1M)
				nr.nr_rates[nr.nr_nrates++] = 2;
			if (sta->rates & WI_SUPPRATES_2M)
				nr.nr_rates[nr.nr_nrates++] = 4;
			if (sta->rates & WI_SUPPRATES_5M)
				nr.nr_rates[nr.nr_nrates++] = 11;
			if (sta->rates & WI_SUPPRATES_11M)
				nr.nr_rates[nr.nr_nrates++] = 22;

			error = copyout(&nr, (caddr_t)na->na_node + n,
			    sizeof(struct ieee80211_nodereq));
			if (error)
				break;
			n += sizeof(struct ieee80211_nodereq);
			na->na_nodes++;
			sta = TAILQ_NEXT(sta, list);
		}
		splx(s);
		break;

	default:
		printf("wihap_ioctl: i shouldn't get other ioctls!\n");
		error = EINVAL;
	}

	return (error);
}

#else
void
wihap_init(struct wi_softc *sc)
{
	return;
}

void
wihap_shutdown(struct wi_softc *sc)
{
	return;
}

void
wihap_mgmt_input(struct wi_softc *sc, struct wi_frame *rxfrm, struct mbuf *m)
{
	return;
}

int
wihap_data_input(struct wi_softc *sc, struct wi_frame *rxfrm, struct mbuf *m)
{
	return (0);
}

int
wihap_ioctl(struct wi_softc *sc, u_long command, caddr_t data)
{
	return (EINVAL);
}

int
wihap_check_tx(struct wihap_info *whi, u_int8_t addr[], u_int8_t *txrate)
{
	return (0);
}
#endif
@


1.50
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.49 2015/11/24 13:33:17 mpi Exp $	*/
a58 1
#include <net/if_dl.h>
@


1.49
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.48 2015/11/04 12:22:01 dlg Exp $	*/
a58 1
#include <net/if_arp.h>
@


1.48
log
@use if_enqueue() rather than doing a poor inline version of it.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.47 2014/11/18 02:37:30 tedu Exp $	*/
a61 1
#include <net/if_types.h>
@


1.47
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.46 2014/09/14 14:17:24 jsg Exp $	*/
d1166 1
a1166 12
		if (IF_QFULL(&ifp->if_snd)) {
			IF_DROP(&ifp->if_snd);
			m_freem(m);
		}
		else {
			ifp->if_obytes += m->m_pkthdr.len;
			if (m->m_flags & M_MCAST)
				ifp->if_omcasts++;
			IF_ENQUEUE(&ifp->if_snd, m);
			if ((ifp->if_flags & IFF_OACTIVE) == 0)
				(*ifp->if_start)(ifp);
		}
@


1.46
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.45 2014/09/13 16:06:37 doug Exp $	*/
a68 2

#include <dev/rndvar.h>
@


1.45
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.44 2014/07/22 13:12:12 mpi Exp $	*/
a48 1
#include <sys/proc.h>
@


1.44
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.43 2014/07/12 18:48:17 tedu Exp $	*/
d290 1
a290 2
	for (sta = TAILQ_FIRST(&whi->sta_list);
	    sta != TAILQ_END(&whi->sta_list); sta = next) {
d353 2
a354 2
	    i != 0 && sta != TAILQ_END(&whi->sta_list) &&
	    (sta->flags & WI_SIFLAGS_DEAD); i--, sta = next) {
@


1.43
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.42 2013/08/07 01:06:30 bluhm Exp $	*/
a65 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.42
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.41 2008/10/15 19:12:19 blambert Exp $	*/
d299 2
a300 2
			free(sta->challenge, M_TEMP);
		free(sta, M_DEVBUF);
d445 2
a446 2
		free(sta->challenge, M_TEMP);
	free(sta, M_DEVBUF);
d672 1
a672 1
			free(sta->challenge, M_TEMP);
@


1.41
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.40 2007/10/09 17:06:18 gilles Exp $	*/
a66 1
#include <netinet/in_var.h>
@


1.40
log
@MALLOC -> malloc

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.39 2007/10/06 02:18:38 krw Exp $	*/
d379 1
a379 1
			timeout_add(&sta->tmo, hz * whi->inactivity_time);
d483 1
a483 1
	timeout_add(&sta->tmo, hz * whi->inactivity_time);
d619 1
a619 1
	timeout_add(&sta->tmo, hz * whi->inactivity_time);
d832 1
a832 1
	timeout_add(&sta->tmo, hz * whi->inactivity_time);
d1055 1
a1055 1
		timeout_add(&sta->tmo, hz * whi->inactivity_time);
d1083 1
a1083 1
		timeout_add(&sta->tmo, hz * whi->inactivity_time);
d1153 1
a1153 1
	timeout_add(&sta->tmo, hz * whi->inactivity_time);
d1277 1
a1277 1
		timeout_add(&sta->tmo, hz * whi->inactivity_time);
@


1.39
log
@Oops. Forgot to do FREE -> free when I did MALLOC -> malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.38 2007/10/03 10:52:11 krw Exp $	*/
d300 1
a300 1
			FREE(sta->challenge, M_TEMP);
d446 1
a446 1
		FREE(sta->challenge, M_TEMP);
d646 1
a646 2
				MALLOC(sta->challenge, u_int32_t *, 128,
				       M_TEMP, M_NOWAIT);
d673 1
a673 1
			FREE(sta->challenge, M_TEMP);
@


1.38
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.37 2006/11/26 19:46:28 deraadt Exp $	*/
d297 1
a297 1
			printf("wihap_shutdown: FREE(sta=%p)\n", sta);
d301 1
a301 1
		FREE(sta, M_DEVBUF);
d447 1
a447 1
	FREE(sta, M_DEVBUF);
@


1.37
log
@avoid extra inclusions; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.36 2006/07/01 20:22:22 reyk Exp $	*/
d464 1
a464 2
	MALLOC(sta, struct wihap_sta_info *, sizeof(struct wihap_sta_info),
	    M_DEVBUF, M_NOWAIT);
a466 2

	bzero(sta, sizeof(struct wihap_sta_info));
@


1.36
log
@always report the channel as type 802.11b (IEEE802_CHAN_B) in the
net80211 node wrappers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.35 2006/06/27 09:48:02 reyk Exp $	*/
d71 1
a71 1
#include <net80211/ieee80211.h>
a72 1
#include <net80211/ieee80211_var.h>
@


1.35
log
@add some more net80211 compatibility glue:
- support scanning and node listing ("ifconfig -M"). this will replace
wicontrol -L in station mode and wicontrol -l in hostap mode.
- allow to print the BSSID

tested by quite a few people
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.34 2006/04/20 20:31:12 miod Exp $	*/
d1344 2
@


1.34
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.33 2005/12/03 21:11:48 brad Exp $	*/
d1212 3
d1332 37
@


1.33
log
@splimp -> splnet

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.32 2005/10/31 05:37:13 jsg Exp $	*/
d195 1
a195 1
		printf("wihap_init: sc=0x%x whi=0x%x\n", sc, whi);
d282 1
a282 1
		printf("wihap_shutdown: sc=0x%x whi=0x%x\n", sc, whi);
d298 1
a298 1
			printf("wihap_shutdown: FREE(sta=0x%x)\n", sta);
@


1.32
log
@Move from arpcom to ieee80211com in wi softc.  This will be
required for net80211 support.
Updated version of a diff from dlg@@
similiar diff ok fgsch@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.31 2005/01/04 18:13:03 millert Exp $	*/
d186 1
a186 1
 *	not AP.  Caller MUST raise to splimp().
d288 1
a288 1
	s = splimp();
d355 1
a355 1
	s = splimp();
d415 1
a415 1
	s = splimp();
d431 1
a431 1
 * Caller must raise to splimp().
d614 1
a614 1
		s = splimp();
d1221 1
a1221 1
		s = splimp();
d1243 1
a1243 1
		s = splimp();
d1265 1
a1265 1
		s = splimp();
d1304 1
a1304 1
		s = splimp();
@


1.31
log
@If we get a vendor private tlv when we are expecting a challenge,
just ignore the vendor private one and continue.  Fixes a problem
with hostap and some 802.11g cards.  Adapted from a diff by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.30 2004/11/23 21:12:23 fgsch Exp $	*/
d73 1
d194 1
a194 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d222 1
a222 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d232 2
a233 2
	bcopy(sc->sc_arpcom.ac_enaddr, resp_hdr->addr2, ETHER_ADDR_LEN);
	bcopy(sc->sc_arpcom.ac_enaddr, resp_hdr->addr3, ETHER_ADDR_LEN);
d251 1
a251 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d261 2
a262 2
	bcopy(sc->sc_arpcom.ac_enaddr, resp_hdr->addr2, ETHER_ADDR_LEN);
	bcopy(sc->sc_arpcom.ac_enaddr, resp_hdr->addr3, ETHER_ADDR_LEN);
d281 1
a281 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d297 1
a297 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d365 1
a365 1
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d382 1
a382 1
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d567 1
a567 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d577 1
a577 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d610 1
a610 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d659 1
a659 1
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d688 1
a688 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d698 1
a698 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d706 2
a707 2
	bcopy(sc->sc_arpcom.ac_enaddr, resp_hdr->addr2, ETHER_ADDR_LEN);
	bcopy(sc->sc_arpcom.ac_enaddr, resp_hdr->addr3, ETHER_ADDR_LEN);
d767 1
a767 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d775 1
a775 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d792 1
a792 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d807 1
a807 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d815 1
a815 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d822 1
a822 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d832 1
a832 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d841 1
a841 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d851 2
a852 2
	bcopy(sc->sc_arpcom.ac_enaddr, resp_hdr->addr2, ETHER_ADDR_LEN);
	bcopy(sc->sc_arpcom.ac_enaddr, resp_hdr->addr3, ETHER_ADDR_LEN);
d882 1
a882 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d911 1
a911 1
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d1001 1
a1001 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
d1111 1
a1111 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d1133 1
a1133 1
	if (!addr_cmp(rxfrm->wi_addr1, sc->sc_arpcom.ac_enaddr)) {
d1212 1
a1212 1
	if (!(sc->sc_arpcom.ac_if.if_flags & IFF_RUNNING))
@


1.30
log
@replace old net/if_ieee80211.h header with the net80211 ones, kernel part.
millert@@ mcbride@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.29 2004/03/15 21:53:28 millert Exp $	*/
d579 4
@


1.29
log
@Changes to wihap_auth_req():
If the station sends a bogus challenge when authorizing, send back
a response to that effect instead of just returning.

Simplify sequence number handling--there's no need to update the sequence
value by hand since we just need to increment it for the response packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.28 2004/03/02 21:55:07 millert Exp $	*/
d71 2
a72 1
#include <net/if_ieee80211.h>
@


1.28
log
@Make HostAP work Prism cards with newer firmware (1.7.0 and higher).
Accept probe packets that Lucent cards send when the associated AP
disapears; this speeds up reassocication with those cards.  Don't
advertise HostAP as being available for firmware 1.4.2.  I added a
note about this in the man pages a while ago but forgot to update
the driver itself.  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.27 2003/09/21 11:22:24 fgsch Exp $	*/
d546 1
a546 2
 *	Handle incoming authentication request.  Only handle OPEN
 *	requests.
d564 4
a567 1
	if (len < 6)
d569 1
a574 5
	challenge_len = 0;
	if (len > 0 && (challenge_len = take_tlv(&pkt, &len,
	    IEEE80211_ELEMID_CHALLENGE, challenge, sizeof(challenge))) < 0)
		return;

d579 7
a624 1
			seq = 2;
a628 1
			seq = 2;
a632 1
		seq = 2;
a636 1
			seq = 2;
a656 1
			seq = 2;
a674 1
			seq = 4;
a676 1
			seq = 2;
d705 1
a705 1
	put_hword(&pkt, seq);
@


1.27
log
@sync with netbsd defines. no functional changes.
ok markus deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.25 2003/05/16 02:30:40 millert Exp $	*/
d1111 1
d1113 8
a1120 2
	/* TODS flag must be set. */
	if (!(rxfrm->wi_frame_ctl & htole16(WI_FCTL_TODS))) {
d1122 2
a1123 2
			printf("wihap_data_input: no TODS src=%s\n",
			    ether_sprintf(rxfrm->wi_addr2));
@


1.26
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d595 1
a595 1
			status = IEEE80211_STATUS_TOO_MANY_STATIONS;
d608 1
a608 1
			status = IEEE80211_STATUS_TOO_MANY_STATIONS;
d790 1
a790 1
		status = IEEE80211_STATUS_RATES;
@


1.25
log
@Use 16bit alignment in addr_cmp() (not 32bit) so this has a chance
of working on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.24 2003/02/15 17:49:39 millert Exp $	*/
d1206 1
a1206 1
		if ((error = suser(p->p_ucred, &p->p_acflag)))
d1250 1
a1250 1
		if ((error = suser(p->p_ucred, &p->p_acflag)))
d1273 1
a1273 1
		if ((error = suser(p->p_ucred, &p->p_acflag)))
@


1.24
log
@Increase xfer rates buffer from 8 to 12 bytes.  This allows 802.11g
stations such as the airport extreme to associate.  Tested by
Ben Lovett.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.23 2003/01/21 20:09:39 millert Exp $	*/
d332 2
a333 1
		*(u_int32_t *)(a    ) == *(u_int32_t *)(b));
@


1.24.4.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.24 2003/02/15 17:49:39 millert Exp $	*/
d332 1
a332 2
		*(u_int16_t *)(a + 2) == *(u_int16_t *)(b + 2) &&
		*(u_int16_t *)(a    ) == *(u_int16_t *)(b));
@


1.24.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d595 1
a595 1
			status = IEEE80211_STATUS_TOOMANY;
d608 1
a608 1
			status = IEEE80211_STATUS_TOOMANY;
d790 1
a790 1
		status = IEEE80211_STATUS_BASIC_RATE;
d1206 1
a1206 1
		if ((error = suser(p, 0)))
d1250 1
a1250 1
		if ((error = suser(p, 0)))
d1273 1
a1273 1
		if ((error = suser(p, 0)))
@


1.24.4.3
log
@Merge with the trunk
@
text
@d546 2
a547 1
 *	Handle incoming authentication request.
d565 1
a565 4
	if (len < 6) {
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf("wihap_auth_req: station %s short request\n",
			    ether_sprintf(rxfrm->wi_addr2));
a566 1
	}
d572 5
a580 7
	challenge_len = 0;
	if (len > 0 && (challenge_len = take_tlv(&pkt, &len,
	    IEEE80211_ELEMID_CHALLENGE, challenge, sizeof(challenge))) < 0) {
		status = IEEE80211_STATUS_CHALLENGE;
		goto fail;
	}

d620 1
d625 1
d630 1
d635 1
d656 1
d675 1
d678 1
d707 1
a707 1
	put_hword(&pkt, seq + 1);
a1110 1
	u_int16_t		fctl;
d1112 2
a1113 8
	/*
	 * TODS flag must be set.  However, Lucent cards set NULLFUNC but
	 * not TODS when probing an AP to see if it is alive after it has
	 * been down for a while.  We accept these probe packets and send a
	 * disassoc packet later on if the station is not already associated.
	 */
	fctl = letoh16(rxfrm->wi_frame_ctl);
	if (!(fctl & WI_FCTL_TODS) && !(fctl & WI_STYPE_NULLFUNC)) {
d1115 2
a1116 2
			printf("wihap_data_input: no TODS src=%s, fctl=0x%x\n",
			    ether_sprintf(rxfrm->wi_addr2), fctl);
@


1.23
log
@Use a 2-level timeout for hostap.  Instead of of sending a station
a deauth/disassoc packet when the inactivity timer fires, just set
a flag, re-queue it and set the master wihap timer if needed.  What
this does is to effectively bundle (and serialize) deauth/disassoc
packets so if a large number need to be sent at once we don't stomp
all over the card.  We also only do at most 10 stations at a time.
The sta_list has been changed from a doubly linked list to a tailq.
Inactive stations are kept at the head of the queue, new ones are
added to the tail.

Idea and OK by mickey@@, prompted by an issue found by
merith AT vantronix DOT net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.22 2003/01/21 16:26:40 millert Exp $	*/
d731 1
a731 1
	u_int8_t		rates[8];
d755 1
a755 1
	    ssid.i_nwid, sizeof(ssid)))<0)
d759 1
a759 1
	    rates, sizeof(rates)))<0)
d786 1
a786 1
	if (wihap_check_rates(sta, rates, rates_len)<0) {
@


1.22
log
@Stub out hostap bits #ifdef SMALL_KERNEL to free up space on the
floppies; OK mickey@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.21 2003/01/14 23:29:50 millert Exp $	*/
d79 1
d202 1
a202 1
	LIST_INIT(&whi->sta_list);
d207 1
a270 1
 *	Caller must raise to splimp().
d288 3
d292 2
a293 2
	for (sta = LIST_FIRST(&whi->sta_list);
	    sta != LIST_END(&whi->sta_list); sta = next) {
d297 1
a297 1
		next = LIST_NEXT(sta, list);
d302 1
a302 1
	LIST_INIT(&whi->sta_list);
d335 9
d345 1
a345 1
wihap_sta_timeout(void *v)
d347 1
a347 2
	struct wihap_sta_info	*sta = v;
	struct wi_softc		*sc = sta->sc;
d349 2
a350 1
	int	s;
d352 1
a352 1
	s = splsoftnet();
d354 41
a394 4
	if (sta->flags & WI_SIFLAGS_ASSOC) {
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf("wihap_timer: disassoc due to inactivity: %s\n",
			    ether_sprintf(sta->addr));
d396 4
a399 4
		/* Disassoc station. */
		wihap_sta_disassoc(sc, sta->addr,
		    IEEE80211_REASON_ASSOC_EXPIRE);
		sta->flags &= ~WI_SIFLAGS_ASSOC;
d401 2
a402 1
		timeout_add(&sta->tmo, hz * whi->inactivity_time);
d404 7
a410 1
	} else if (sta->flags & WI_SIFLAGS_AUTHEN) {
d412 1
a412 3
		if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
			printf("wihap_timer: deauth due to inactivity: %s\n",
			    ether_sprintf(sta->addr));
d414 8
a421 3
		/* Deauthenticate station. */
		wihap_sta_deauth(sc, sta->addr, IEEE80211_REASON_AUTH_EXPIRE);
		sta->flags &= ~WI_SIFLAGS_AUTHEN;
a422 4
		/* Delete the station if it's not permanent. */
		if (!(sta->flags & WI_SIFLAGS_PERM))
			wihap_sta_delete(sta);
	}
d428 1
d441 1
a441 1
	LIST_REMOVE(sta, list);
d477 1
a477 1
	LIST_INSERT_HEAD(&whi->sta_list, sta, list);
d554 1
a554 1
	int			i;
d602 1
d604 1
d1293 1
a1293 1
		sta = LIST_FIRST(&whi->sta_list);
d1308 1
a1308 1
			sta = LIST_NEXT(sta, list);
@


1.21
log
@In wihap_shutdown() use a broadcast for disassoc and deauth packets
instead of sending a separate packet to each station.
Based on a patch from merith AT vantronix DOT net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.20 2002/08/13 03:49:51 millert Exp $	*/
d97 1
d1265 38
@


1.20
log
@change WI_PORTTYPE_AP -> WI_PORTTYPE_HOSTAP to match FreeBSD and NetBSD.
The reason for this is that it is possible in the future to have
wi(4) be a real AP using the AP tertiary firmware.
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.19 2002/06/25 01:59:52 millert Exp $	*/
d275 1
a275 1
	int s;
a283 4
	/* XXX: I read somewhere you can deauth all the stations with
	 * a single broadcast.  Maybe try that someday.
	 */

a284 2
	sta = LIST_FIRST(&whi->sta_list);
	while (sta) {
d286 3
a289 13

		if (sc->wi_flags & WI_FLAGS_ATTACHED) {
			/* Disassociate station. */
			if (sta->flags & WI_SIFLAGS_ASSOC)
				wihap_sta_disassoc(sc, sta->addr,
				    IEEE80211_REASON_ASSOC_LEAVE);
			/* Deauth station. */
			if (sta->flags & WI_SIFLAGS_AUTHEN)
				wihap_sta_deauth(sc, sta->addr,
				    IEEE80211_REASON_AUTH_LEAVE);
		}

		/* Delete the structure. */
d293 2
a295 1
		sta = next;
d297 13
@


1.19
log
@Handle REASREQ packets earlier when processing an association
request.  We need to eat the MAC address of the packet before we
go looking at the SSID and such.  Doing do is sufficient to make
Cisco cards associate with HostAP.  From FreeBSD (jhay).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.18 2002/06/23 18:50:08 millert Exp $	*/
d195 1
a195 1
	if (sc->wi_ptype != WI_PORTTYPE_AP)
@


1.18
log
@If we receive a packet with our BSSID from an unassociated station,
tell the station to disassociate itself.  This fixes a problem when
the HostAP reboots but stations still think they are associated.
With this change the station will re-associate properly.

Change wihap_sta_disassoc() to take an array of u_int8_t (ether
addr) instead of a struct wihap_sta_info * to make the above change
possible.  This is also consistent with wihap_sta_deauth().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.17 2002/06/21 06:56:24 millert Exp $	*/
d685 11
a702 7

	if ((rxfrm->wi_frame_ctl & htole16(WI_FCTL_STYPE)) ==
	    htole16(WI_STYPE_MGMT_REASREQ)) {
		/* Reassociation Request--Current AP.  (Ignore?) */
		if (len < 6)
			return;
	}
@


1.17
log
@Add some missing casts of sc->wi_txbuf -> caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.16 2002/06/09 03:14:18 todd Exp $	*/
d92 2
a93 2
void wihap_sta_disassoc(struct wi_softc *sc,
    struct wihap_sta_info *sta, u_int16_t reason);
d212 1
a212 2
wihap_sta_disassoc(struct wi_softc *sc,
    struct wihap_sta_info *sta, u_int16_t reason)
d218 1
a218 1
		printf("Sending disassoc to sta %s\n", ether_sprintf(sta->addr));
d226 1
a226 1
	bcopy(sta->addr, resp_hdr->addr1, ETHER_ADDR_LEN);
d241 1
a241 2
wihap_sta_deauth(struct wi_softc *sc, u_int8_t sta_addr[],
    u_int16_t reason)
d297 1
a297 1
				wihap_sta_disassoc(sc, sta,
d348 2
a349 1
		wihap_sta_disassoc(sc, sta, IEEE80211_REASON_ASSOC_EXPIRE);
d1077 2
d1154 1
a1154 1
				wihap_sta_disassoc(sc, sta,
@


1.16
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.15 2002/04/26 22:19:07 millert Exp $	*/
d222 1
a222 1
	resp_hdr = (struct wi_80211_hdr *) sc->wi_txbuf;
d225 1
a225 1
	pkt = sc->wi_txbuf + sizeof(struct wi_80211_hdr);
d233 2
a234 1
	wi_mgmt_xmit(sc, sc->wi_txbuf, 2 + sizeof(struct wi_80211_hdr));
d252 1
a252 1
	resp_hdr = (struct wi_80211_hdr *) sc->wi_txbuf;
d255 1
a255 1
	pkt = sc->wi_txbuf + sizeof(struct wi_80211_hdr);
d263 2
a264 1
	wi_mgmt_xmit(sc, sc->wi_txbuf, 2 + sizeof(struct wi_80211_hdr));
d640 1
a640 1
	resp_hdr = (struct wi_80211_hdr *) sc->wi_txbuf;
d647 1
a647 1
	pkt = &sc->wi_txbuf[sizeof(struct wi_80211_hdr)];
d655 2
a656 1
	wi_mgmt_xmit(sc, sc->wi_txbuf, 6 + sizeof(struct wi_80211_hdr) +
d779 1
a779 1
	resp_hdr = (struct wi_80211_hdr *) sc->wi_txbuf;
d782 1
a782 1
	pkt = sc->wi_txbuf + sizeof(struct wi_80211_hdr);
d793 1
a793 1
	wi_mgmt_xmit(sc, sc->wi_txbuf,
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.16.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.16.2.1 2002/06/11 03:42:18 art Exp $	*/
d92 2
a93 2
void wihap_sta_disassoc(struct wi_softc *sc, u_int8_t sta_addr[],
    u_int16_t reason);
d195 1
a195 1
	if (sc->wi_ptype != WI_PORTTYPE_HOSTAP)
d212 2
a213 1
wihap_sta_disassoc(struct wi_softc *sc, u_int8_t sta_addr[], u_int16_t reason)
d219 1
a219 1
		printf("Sending disassoc to sta %s\n", ether_sprintf(sta_addr));
d222 1
a222 1
	resp_hdr = (struct wi_80211_hdr *)sc->wi_txbuf;
d225 1
a225 1
	pkt = (caddr_t)&sc->wi_txbuf + sizeof(struct wi_80211_hdr);
d227 1
a227 1
	bcopy(sta_addr, resp_hdr->addr1, ETHER_ADDR_LEN);
d233 1
a233 2
	wi_mgmt_xmit(sc, (caddr_t)&sc->wi_txbuf,
	    2 + sizeof(struct wi_80211_hdr));
d241 2
a242 1
wihap_sta_deauth(struct wi_softc *sc, u_int8_t sta_addr[], u_int16_t reason)
d251 1
a251 1
	resp_hdr = (struct wi_80211_hdr *)sc->wi_txbuf;
d254 1
a254 1
	pkt = (caddr_t)&sc->wi_txbuf + sizeof(struct wi_80211_hdr);
d262 1
a262 2
	wi_mgmt_xmit(sc, (caddr_t)&sc->wi_txbuf,
	    2 + sizeof(struct wi_80211_hdr));
d297 1
a297 1
				wihap_sta_disassoc(sc, sta->addr,
d348 1
a348 2
		wihap_sta_disassoc(sc, sta->addr,
		    IEEE80211_REASON_ASSOC_EXPIRE);
d638 1
a638 1
	resp_hdr = (struct wi_80211_hdr *)&sc->wi_txbuf;
d645 1
a645 1
	pkt = (caddr_t)&sc->wi_txbuf + sizeof(struct wi_80211_hdr);
d653 1
a653 2
	wi_mgmt_xmit(sc, (caddr_t)&sc->wi_txbuf,
	    6 + sizeof(struct wi_80211_hdr) +
a682 11

	if ((rxfrm->wi_frame_ctl & htole16(WI_FCTL_STYPE)) ==
	    htole16(WI_STYPE_MGMT_REASREQ)) {
		if (len < 6)
			return;
		/* Eat the MAC address of the current AP */
		take_hword(&pkt, &len);
		take_hword(&pkt, &len);
		take_hword(&pkt, &len);
	}

d691 7
d776 1
a776 1
	resp_hdr = (struct wi_80211_hdr *)&sc->wi_txbuf;
d779 1
a779 1
	pkt = (caddr_t)&sc->wi_txbuf + sizeof(struct wi_80211_hdr);
d790 1
a790 1
	wi_mgmt_xmit(sc, (caddr_t)&sc->wi_txbuf,
a1074 2
		wihap_sta_disassoc(sc, rxfrm->wi_addr2,
		    IEEE80211_REASON_ASSOC_LEAVE);
d1150 1
a1150 1
				wihap_sta_disassoc(sc, sta->addr,
@


1.16.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a78 1
void wihap_timeout(void *v);
a96 1
#ifndef SMALL_KERNEL
d200 1
a200 1
	TAILQ_INIT(&whi->sta_list);
a204 1
	timeout_set(&whi->tmo, wihap_timeout, sc);
d268 1
d275 1
a275 1
	int i, s;
d284 4
d289 2
d292 12
a303 2
	/* Disable wihap inactivity timer. */
	timeout_del(&whi->tmo);
d305 1
a305 4
	/* Delete all stations from the list. */
	for (sta = TAILQ_FIRST(&whi->sta_list);
	    sta != TAILQ_END(&whi->sta_list); sta = next) {
		timeout_del(&sta->tmo);
d308 1
a308 3
		next = TAILQ_NEXT(sta, list);
		if (sta->challenge)
			FREE(sta->challenge, M_TEMP);
d310 1
a311 13
	TAILQ_INIT(&whi->sta_list);

	/* Broadcast disassoc and deauth to all the stations. */
	if (sc->wi_flags & WI_FLAGS_ATTACHED) {
		for (i = 0; i < 5; i++) {
			wihap_sta_disassoc(sc, etherbroadcastaddr,
			    IEEE80211_REASON_ASSOC_LEAVE);
			wihap_sta_deauth(sc, etherbroadcastaddr,
			    IEEE80211_REASON_AUTH_LEAVE);
			DELAY(50);
		}
	}

d329 1
a329 11
		*(u_int16_t *)(a + 2) == *(u_int16_t *)(b + 2) &&
		*(u_int16_t *)(a    ) == *(u_int16_t *)(b));
}

/* wihap_sta_movetail(): move sta to the tail of the station list in whi */
static __inline void
wihap_sta_movetail(struct wihap_info *whi, struct wihap_sta_info *sta)
{
	TAILQ_REMOVE(&whi->sta_list, sta, list);
	sta->flags &= ~WI_SIFLAGS_DEAD;
	TAILQ_INSERT_TAIL(&whi->sta_list, sta, list);
d333 1
a333 1
wihap_timeout(void *v)
d335 2
a336 1
	struct wi_softc		*sc = v;
d338 1
a338 2
	struct wihap_sta_info	*sta, *next;
	int	i, s;
d340 1
a340 1
	s = splimp();
d342 4
a345 11
	for (i = 10, sta = TAILQ_FIRST(&whi->sta_list);
	    i != 0 && sta != TAILQ_END(&whi->sta_list) &&
	    (sta->flags & WI_SIFLAGS_DEAD); i--, sta = next) {
		next = TAILQ_NEXT(sta, list);
		if (timeout_pending(&sta->tmo)) {
			/* Became alive again, move to end of list. */
			wihap_sta_movetail(whi, sta);
		} else if (sta->flags & WI_SIFLAGS_ASSOC) {
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
				printf("wihap_timeout: disassoc due to inactivity: %s\n",
				    ether_sprintf(sta->addr));
d347 4
a350 16
			/* Disassoc station. */
			wihap_sta_disassoc(sc, sta->addr,
			    IEEE80211_REASON_ASSOC_EXPIRE);
			sta->flags &= ~WI_SIFLAGS_ASSOC;

			/*
			 * Move to end of the list and reset station timeout.
			 * We do this to make sure we don't get deauthed
			 * until inactivity_time seconds have passed.
			 */
			wihap_sta_movetail(whi, sta);
			timeout_add(&sta->tmo, hz * whi->inactivity_time);
		} else if (sta->flags & WI_SIFLAGS_AUTHEN) {
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
				printf("wihap_timeout: deauth due to inactivity: %s\n",
				    ether_sprintf(sta->addr));
d352 1
a352 12
			/* Deauthenticate station. */
			wihap_sta_deauth(sc, sta->addr,
			    IEEE80211_REASON_AUTH_EXPIRE);
			sta->flags &= ~WI_SIFLAGS_AUTHEN;

			/* Delete the station if it's not permanent. */
			if (sta->flags & WI_SIFLAGS_PERM)
				wihap_sta_movetail(whi, sta);
			else
				wihap_sta_delete(sta);
		}
	}
d354 1
a354 4
	/* Restart the timeout if there are still dead stations left. */
	sta = TAILQ_FIRST(&whi->sta_list);
	if (sta != NULL && (sta->flags & WI_SIFLAGS_DEAD))
		timeout_add(&whi->tmo, 1);	/* still work left, requeue */
d356 3
a358 2
	splx(s);
}
d360 3
a362 18
void
wihap_sta_timeout(void *v)
{
	struct wihap_sta_info	*sta = v;
	struct wi_softc		*sc = sta->sc;
	struct wihap_info	*whi = &sc->wi_hostap_info;
	int	s;

	s = splimp();

	/* Mark sta as dead and move it to the head of the list. */
	TAILQ_REMOVE(&whi->sta_list, sta, list);
	sta->flags |= WI_SIFLAGS_DEAD;
	TAILQ_INSERT_HEAD(&whi->sta_list, sta, list);

	/* Add wihap timeout if we have not already done so. */
	if (!timeout_pending(&whi->tmo))
		timeout_add(&whi->tmo, hz / 10);
d364 4
a372 1
 * Caller must raise to splimp().
d385 1
a385 1
	TAILQ_REMOVE(&whi->sta_list, sta, list);
d421 1
a421 1
	TAILQ_INSERT_TAIL(&whi->sta_list, sta, list);
d498 1
a498 1
	int			i, s;
a545 1
		s = splimp();
a546 1
		splx(s);
d673 1
a673 1
	u_int8_t		rates[12];
d697 1
a697 1
	    ssid.i_nwid, sizeof(ssid))) < 0)
d701 1
a701 1
	    rates, sizeof(rates))) < 0)
d728 1
a728 1
	if (wihap_check_rates(sta, rates, rates_len) < 0) {
d1235 1
a1235 1
		sta = TAILQ_FIRST(&whi->sta_list);
d1250 1
a1250 1
			sta = TAILQ_NEXT(sta, list);
a1265 38

#else
void
wihap_init(struct wi_softc *sc)
{
	return;
}

void
wihap_shutdown(struct wi_softc *sc)
{
	return;
}

void
wihap_mgmt_input(struct wi_softc *sc, struct wi_frame *rxfrm, struct mbuf *m)
{
	return;
}

int
wihap_data_input(struct wi_softc *sc, struct wi_frame *rxfrm, struct mbuf *m)
{
	return (0);
}

int
wihap_ioctl(struct wi_softc *sc, u_long command, caddr_t data)
{
	return (EINVAL);
}

int
wihap_check_tx(struct wihap_info *whi, u_int8_t addr[], u_int8_t *txrate)
{
	return (0);
}
#endif
@


1.15
log
@Implement shared key support for hostap mode; from Thomas Skibo
Also do a little KNF while I'm in here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.14 2002/04/23 22:25:29 millert Exp $	*/
d190 1
a190 1
	if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d218 1
a218 1
	if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d228 2
a229 2
	bcopy(sc->arpcom.ac_enaddr, resp_hdr->addr2, ETHER_ADDR_LEN);
	bcopy(sc->arpcom.ac_enaddr, resp_hdr->addr3, ETHER_ADDR_LEN);
d247 1
a247 1
	if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d257 2
a258 2
	bcopy(sc->arpcom.ac_enaddr, resp_hdr->addr2, ETHER_ADDR_LEN);
	bcopy(sc->arpcom.ac_enaddr, resp_hdr->addr3, ETHER_ADDR_LEN);
d277 1
a277 1
	if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d306 1
a306 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d343 1
a343 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d355 1
a355 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d519 1
a519 1
	if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d541 1
a541 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d592 1
a592 1
			if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d624 1
a624 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d634 1
a634 1
	if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d642 2
a643 2
	bcopy(sc->arpcom.ac_enaddr, resp_hdr->addr2, ETHER_ADDR_LEN);
	bcopy(sc->arpcom.ac_enaddr, resp_hdr->addr3, ETHER_ADDR_LEN);
d698 1
a698 1
	if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d706 1
a706 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d723 1
a723 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d738 1
a738 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d746 1
a746 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d753 1
a753 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d763 1
a763 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d772 1
a772 1
	if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d782 2
a783 2
	bcopy(sc->arpcom.ac_enaddr, resp_hdr->addr2, ETHER_ADDR_LEN);
	bcopy(sc->arpcom.ac_enaddr, resp_hdr->addr3, ETHER_ADDR_LEN);
d813 1
a813 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d842 1
a842 1
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d932 1
a932 1
	if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
d1042 1
a1042 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d1057 1
a1057 1
	if (!addr_cmp(rxfrm->wi_addr1, sc->arpcom.ac_enaddr)) {
d1134 1
a1134 1
	if (!(sc->arpcom.ac_if.if_flags & IFF_RUNNING))
@


1.14
log
@Clear flags indicating whether or not wi or hostap is active as
early as possible.  Also move the timeout_del() in wi_stop() to
before we disable wi(4) so it doesn't fire at the wrong time.
Joint effort between mickey@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.13 2002/04/15 19:47:33 millert Exp $	*/
d73 2
d182 1
a182 1
 *	not AP.
d268 1
d386 2
d408 1
a408 1
		return(NULL);
d429 1
a429 1
	return(sta);
d447 1
a447 1
	return(NULL);
d497 1
d503 1
a503 1
	u_int8_t		challenge[128];
d507 1
a507 1
	if (len<6)
d514 1
a514 1
	challenge_len=0;
d516 1
a516 1
	    IEEE80211_ELEMID_CHALLENGE, challenge, sizeof(challenge)))<0)
d520 2
a521 20
		printf("wihap_auth_req: from station: %s\n",
		    ether_sprintf(rxfrm->wi_addr2));

	switch (algo) {
	case IEEE80211_AUTH_ALG_OPEN:
		if (seq != 1) {
			status = IEEE80211_STATUS_SEQUENCE;
			goto fail;
		}
		challenge_len=0;
		break;
	case IEEE80211_AUTH_ALG_SHARED:
		/* NOT YET */
	default:
		if (sc->arpcom.ac_if.if_flags & IFF_DEBUG)
			printf("wihap_auth_req: algorithm unsupported: %d\n",
			    algo);
		status = IEEE80211_STATUS_ALG;
		goto fail;
	}
d523 1
d552 78
a630 2
	sta->flags |= WI_SIFLAGS_AUTHEN;
	timeout_add(&sta->tmo, hz * whi->inactivity_time);
d647 1
a647 1
	put_hword(&pkt, 2);
d653 2
a654 3
	wi_mgmt_xmit(sc, sc->wi_txbuf,
		     6 + sizeof(struct wi_80211_hdr) +
		     (challenge_len>0 ? challenge_len + 2 : 0));
d693 1
a693 1
		/* Reassociation Request-- * Current AP.  (Ignore?) */
d723 2
d739 2
a740 2
			printf("wihap_assoc_req: capinfo mismatch: "
			    "client using IBSS mode\n");
d747 2
a748 2
			printf("wihap_assoc_req: capinfo mismatch: client "
			    "%susing WEP\n", sc->wi_use_wep ? "not " : "");
d754 2
a755 2
			printf("wihap_assoc_req: capinfo mismatch: "
			    "client requested CF polling\n");
d814 2
a815 2
			printf("wihap_deauth_req: unknown station: 6D\n",
			    rxfrm->wi_addr2, ":");
d843 2
a844 2
			printf("wihap_disassoc_req: unknown station: 6D\n",
			    rxfrm->wi_addr2, ":");
d992 1
a992 1
		return(1);
d995 1
a995 1
	return(0);
d1012 1
a1012 1
		return(1);
d1022 1
a1022 1
		return(1);
d1026 1
a1026 1
	return(0);
d1053 1
a1053 1
		return(1);
d1062 1
a1062 1
		return(1);
d1077 1
a1077 1
		return(1);
d1094 1
a1094 1
				return(0);
d1256 1
a1256 1
	return(error);
@


1.13
log
@Remove bogus casts to int in printf that causes a warning on 64bit arches.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.12 2002/04/11 15:34:27 millert Exp $	*/
d279 1
a309 2

	whi->apflags = 0;
@


1.12
log
@o Check supported speeds before examing capabilties
o If capinfo doesn't match, save it anyway for debugging porpoises
o Add more info for capinfo failures in debug mode
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.11 2002/04/08 18:44:42 mickey Exp $	*/
d189 1
a189 1
		printf("wihap_init: sc=0x%x whi=0x%x\n", (int)sc, (int)whi);
d275 1
a275 2
		printf("wihap_shutdown: sc=0x%x whi=0x%x\n",
		    (int)sc, (int)whi);
d303 1
a303 1
			printf("wihap_shutdown: FREE(sta=0x%x)\n", (int)sta);
@


1.11
log
@two missing splx()s
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.10 2002/04/08 18:31:27 mickey Exp $	*/
d659 6
d667 1
a667 1
	 * Check WEP/PRIVACY flags match.  XXX: WEP doesn't work for host AP.
d670 2
d673 1
a673 7
	    IEEE80211_CAPINFO_ESS ||
	    (sc->wi_use_wep && !(capinfo & IEEE80211_CAPINFO_PRIVACY)) ||
	    (!sc->wi_use_wep && (capinfo & IEEE80211_CAPINFO_PRIVACY)) ||
	    (capinfo & (IEEE80211_CAPINFO_CF_POLLABLE |
		IEEE80211_CAPINFO_CF_POLLREQ)) ==
	    IEEE80211_CAPINFO_CF_POLLABLE) {

d676 2
a677 1
			    "capinfo=0x%x\n", capinfo);
d679 6
a684 1
		status = IEEE80211_STATUS_CAPINFO;
d687 5
a691 5
	sta->capinfo = capinfo;

	/* Check supported rates against ours. */
	if (wihap_check_rates(sta, rates, rates_len)<0) {
		status = IEEE80211_STATUS_RATES;
@


1.10
log
@make hostap work on other-endian machines; tested by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.9 2002/04/07 23:23:49 millert Exp $	*/
d1119 1
d1124 1
@


1.9
log
@Don't reset COR in wi_reset(), break it out into its own function and
only call it from wi_attach() and wi_pcmcia_activate() (ie: just once).
It would be nicer to have the COR reset be part of the bus-specific
code but we need to know whether or not we have a Lucent card since
old Lucent firmware revs get messed up on a COR soft reset.

Even with the COR reset we still need to avoid initializing Symbol
cards more than once.  However, we *do* want to do a reset after
returning from suspend.  Therefore, rename wi_gone to wi_flags and
store both the attach and init status in it.  wi_reset() now checks
wi_flags to see if the card should be initialized in the Symbol case.

Info on initializing Symbol cards once from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.8 2002/04/01 22:00:18 mickey Exp $	*/
d629 2
a630 1
	if ((rxfrm->wi_frame_ctl & WI_FCTL_STYPE) == WI_STYPE_MGMT_REASREQ) {
d706 1
a706 1
	resp_hdr->frame_ctl = WI_FTYPE_MGMT | WI_STYPE_MGMT_ASRESP;
d716 1
a716 1
	rates_len=put_rates(&pkt, sc->wi_supprates);
d719 1
a719 1
	    8 + rates_len+sizeof(struct wi_80211_hdr));
d794 1
a794 1
	printf("wihap_mgmt_input: len=%d ", rxfrm->wi_dat_len);
d796 2
a797 1
	if ((letoh16(rxfrm->wi_frame_ctl) & WI_FCTL_FTYPE) == WI_FTYPE_MGMT) {
d866 2
a867 1
	if ((rxfrm->wi_frame_ctl & WI_FCTL_FTYPE) == WI_FTYPE_MGMT) {
d976 1
a976 1
	if (!(letoh16(rxfrm->wi_frame_ctl) & WI_FCTL_TODS)) {
d1009 1
a1009 1
	sta->sig_info = rxfrm->wi_q_info;
@


1.8
log
@freem mbuf on input pkt check failure
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.7 2002/04/01 21:05:38 mickey Exp $	*/
d291 1
a291 1
		if (!sc->wi_gone) {
@


1.7
log
@killed a char accidentally
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.6 2002/04/01 20:57:56 mickey Exp $	*/
d977 1
d986 1
d1001 1
@


1.6
log
@need to splsoftclock here too, i think i've got 'em all now
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.5 2002/03/30 22:40:26 mickey Exp $	*/
d949 1
a949 1
	spx(s);
@


1.5
log
@kill lots of space and insert some more for knf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.4 2002/03/29 18:57:46 millert Exp $	*/
d161 1
a162 1
	u_int8_t ratebuf[8];
d933 1
d940 1
d946 1
d949 1
@


1.4
log
@i_nwid is not a NUL-terminated string, it is length bounded.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.3 2002/03/28 22:22:33 mickey Exp $	*/
d129 3
a131 3
	bcopy(*ppkt+2, dst, len);
	*plen -= 2+len;
	*ppkt += 2+len;
d133 1
a133 1
	return len;
d154 2
a155 2
	bcopy(src, (*ppkt)+2, len);
	*ppkt += 2+len;
d199 1
a199 1
	for (i=0; i<WI_STA_HASH_SIZE; i++)
d213 1
a213 1
	struct wi_80211_hdr 	*resp_hdr;
d231 1
a231 1
	wi_mgmt_xmit(sc, sc->wi_txbuf, 2+sizeof(struct wi_80211_hdr));
d242 1
a242 1
	struct wi_80211_hdr 	*resp_hdr;
d260 1
a260 1
	wi_mgmt_xmit(sc, sc->wi_txbuf, 2+sizeof(struct wi_80211_hdr));
d270 2
a271 2
	struct wihap_info 	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info 	*sta, *next;
d276 1
a276 1
		       (int)sc, (int)whi);
d295 1
a295 1
					   IEEE80211_REASON_ASSOC_LEAVE);
d299 1
a299 1
					 IEEE80211_REASON_AUTH_LEAVE);
d304 1
a304 1
			printf("wihap_shutdown: FREE(sta=0x%x)\n", (int) sta);
d327 2
a328 2
	return (*(u_int16_t *)(a+4) == *(u_int16_t *)(b+4) &&
		*(u_int32_t *)a     == *(u_int32_t *)b);
d334 3
a336 3
	struct wihap_sta_info 	*sta = v;
	struct wi_softc 	*sc = sta->sc;
	struct wihap_info 	*whi = &sc->wi_hostap_info;
d376 1
a376 1
	struct wihap_info 	*whi = &sc->wi_hostap_info;
d381 1
a381 1
	whi->asid_inuse_mask[i>>4] &= ~(1ul<<(i&0xf));
d397 1
a397 1
	struct wihap_info 	*whi = &sc->wi_hostap_info;
d403 1
a403 1
	       M_DEVBUF, M_NOWAIT);
d411 4
a414 4
	while (whi->asid_inuse_mask[i>>4] & (1ul<<(i&0xf)))
		i = (i==(WI_STA_HASH_SIZE<<4)-1) ? 0 : (i+1);
	whi->asid_inuse_mask[i>>4] |= (1ul<<(i&0xf));
	sta->asid = 0xc001+i;
d441 1
a441 1
		if (addr_cmp(addr,sta->addr))
d455 1
a455 1
	for (i=0; i<rates_len; i++)
d462 1
a462 1
			if (sta->tx_max_rate<1)
d467 1
a467 1
			if (sta->tx_max_rate<2)
d490 1
a490 1
	       caddr_t pkt, int len)
d501 1
a501 1
	struct wi_80211_hdr 	*resp_hdr;
d511 2
a512 2
	if (len > 0 && (challenge_len=take_tlv(&pkt, &len,
	     IEEE80211_ELEMID_CHALLENGE, challenge, sizeof(challenge)))<0)
d517 1
a517 1
		       ether_sprintf(rxfrm->wi_addr2));
d532 1
a532 1
			       algo);
d592 1
a592 1
		     (challenge_len>0 ? challenge_len+2 : 0));
d606 1
a606 1
	struct wi_80211_hdr 	*resp_hdr;
d610 1
a610 1
	int 			ssid_len, rates_len;
d621 2
a622 2
	if ((ssid_len=take_tlv(&pkt, &len, IEEE80211_ELEMID_SSID,
			       ssid.i_nwid, sizeof(ssid)))<0)
d625 2
a626 2
	if ((rates_len=take_tlv(&pkt, &len, IEEE80211_ELEMID_RATES,
				rates, sizeof(rates)))<0)
d637 1
a637 1
		       ether_sprintf(rxfrm->wi_addr2));
d654 1
a654 1
				 IEEE80211_REASON_NOT_AUTHED);
d663 1
a663 1
	if ((capinfo & (IEEE80211_CAPINFO_ESS|IEEE80211_CAPINFO_IBSS)) !=
d667 2
a668 2
	    (capinfo & (IEEE80211_CAPINFO_CF_POLLABLE|
			IEEE80211_CAPINFO_CF_POLLREQ)) ==
d673 1
a673 1
			       "capinfo=0x%x\n", capinfo);
d679 1
a679 1
		
d718 1
a718 1
		     8+rates_len+sizeof(struct wi_80211_hdr));
d731 1
a731 1
	u_int16_t 		reason;
d742 1
a742 1
			       rxfrm->wi_addr2, ":");
d756 1
a756 1
		  caddr_t pkt, int len)
d760 1
a760 1
	u_int16_t 		reason;
d762 1
a762 1
	if (len<2)
d771 1
a771 1
			       rxfrm->wi_addr2, ":");
d774 2
a775 1
		/* If station is not authenticated, send deauthentication
d779 1
a779 1
				 IEEE80211_REASON_NOT_AUTHED);
d835 1
a835 1
				letoh16(rxfrm->wi_frame_ctl) & WI_FCTL_STYPE);
d841 2
a842 2
			letoh16(rxfrm->wi_frame_ctl) & WI_FCTL_FTYPE,
			letoh16(rxfrm->wi_frame_ctl));
d914 1
a914 1
	if (sta!=NULL && (sta->flags & WI_SIFLAGS_ASSOC)) {
d940 1
a940 1
	if (sta!=NULL && (sta->flags & WI_SIFLAGS_ASSOC)) {
d943 1
a943 1
		*txrate = txratetable[ sta->tx_curr_rate ];
d965 1
a965 1
	struct wihap_sta_info 	*sta;
d972 1
a972 1
				ether_sprintf(rxfrm->wi_addr2));
d980 1
a980 1
				ether_sprintf(rxfrm->wi_addr1));
d993 1
a993 1
				ether_sprintf(rxfrm->wi_addr2));
d1045 5
a1049 5
	struct wihap_info 	*whi = &sc->wi_hostap_info;
	struct wihap_sta_info 	*sta;
	struct hostap_getall 	reqall;
	struct hostap_sta 	reqsta;
	struct hostap_sta 	stabuf;
d1069 1
a1069 1
					   IEEE80211_REASON_ASSOC_LEAVE);
d1073 1
a1073 1
					 IEEE80211_REASON_AUTH_LEAVE);
d1095 1
a1095 1
					sizeof(reqsta));
d1127 2
a1128 3
		whi->apflags =
			(whi->apflags & WIHAPFL_CANTCHANGE) |
			(flag & ~WIHAPFL_CANTCHANGE);
d1154 1
a1154 1
					sizeof(struct hostap_sta));
d1165 1
a1165 1
					sizeof(reqall));
@


1.3
log
@put the protos and spls in place
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.2 2002/03/28 21:22:52 mickey Exp $	*/
d622 1
a622 1
			       ssid.i_nwid, sizeof(ssid)-1))<0)
a624 1
	ssid.i_nwid[ssid_len] = '\0';
d644 3
a646 2
			printf("wihap_assoc_req: bad ssid: '%s' != '%s'\n",
			    ssid.i_nwid, sc->wi_net_name.i_nwid);
@


1.2
log
@missing timeout add and del; some minor api change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_hostap.c,v 1.1 2002/03/28 18:21:06 mickey Exp $	*/
d78 1
d80 14
d209 1
a209 1
static void
d238 3
a240 2
static void
wihap_sta_deauth(struct wi_softc *sc, u_int8_t sta_addr[], u_int16_t reason)
d272 1
d285 1
d309 1
d336 1
d339 1
a339 1
	s = splimp();
d394 1
a394 1
static struct wihap_sta_info *
d433 1
a433 1
static struct wihap_sta_info *
d447 1
a447 1
static int
d488 1
a488 1
static void
d600 1
a600 1
static void
d725 1
a725 1
static void
d754 1
a754 1
static void
d789 1
a789 1
static void
d854 2
a855 2
	caddr_t		pkt;
	int		len;
d865 2
d896 1
a896 1

d907 1
a907 1
static int
d918 2
a919 2
	else
		return(0);
d937 1
d945 1
d965 1
a965 1
	int			mcast;
d983 2
d993 1
d1000 2
d1049 1
a1049 1
	int			error = 0, n, flag;
d1060 1
d1076 1
d1082 1
d1096 1
d1104 1
d1117 1
d1142 1
d1161 1
@


1.1
log
@basic host-ap implementation, more work is needed; from Thomas Skibo <skibo@@pacbell.net>; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d195 2
a196 1
wihap_sta_disassoc(struct wi_softc *sc, u_int8_t sta_addr[], u_int16_t reason)
d202 1
a202 1
		printf("Sending disassoc to sta %s\n", ether_sprintf(sta_addr));
d210 1
a210 1
	bcopy(sta_addr, resp_hdr->addr1, ETHER_ADDR_LEN);
d271 2
d276 1
a276 1
				wihap_sta_disassoc(sc, sta->addr,
d327 1
a327 1
		wihap_sta_disassoc(sc, sta->addr, IEEE80211_REASON_ASSOC_EXPIRE);
d330 2
d1037 1
a1037 1
				wihap_sta_disassoc(sc, sta->addr,
@

