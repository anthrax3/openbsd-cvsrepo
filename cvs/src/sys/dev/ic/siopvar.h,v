head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.24
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.22
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.16
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.18
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.10
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.14
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.12
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.8
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.6
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.13.0.16
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.18
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.14
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.12
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.10
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.8
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.6
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.4
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2;
locks; strict;
comment	@ * @;


1.17
date	2011.09.23.10.40.06;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.05.22.37.39;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.06.01.12.17;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.20.22.32.48;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.08.16.52.38;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.13.23.33.03;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.16.20.30.06;	author avsm;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.14.22.37.48;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.06.22.24.14;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.16.00.53.12;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.15.06.01.29;	author krw;	state Exp;
branches
	1.4.4.1
	1.4.8.1;
next	1.3;

1.3
date	2001.03.10.05.04.06;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.01.17.14.28;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.15.04.07.58;	author krw;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.24.13;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Make sure siop_xfer is a multiple of 128 bytes as intended (and as told by
the comments); this makes hppa64 much happier according to jsing@@.
ok krw@@ exactly two years ago, it was about time to commit this.
@
text
@/*	$OpenBSD: siopvar.h,v 1.16 2011/04/05 22:37:39 dlg Exp $ */
/*	$NetBSD: siopvar.h,v 1.22 2005/11/18 23:10:32 bouyer Exp $	*/

/*
 * Copyright (c) 2000 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* structure and definitions for the siop driver */

/* Number of tag */
#define SIOP_NTAG 16

/*
 * wrap up the bus_dma api.
 */
struct siop_dmamem {
	bus_dmamap_t		sdm_map;
	bus_dma_segment_t	sdm_seg;
	size_t			sdm_size;
	caddr_t			sdm_kva;
};
#define SIOP_DMA_MAP(_sdm)	((_sdm)->sdm_map)
#define SIOP_DMA_DVA(_sdm)	((_sdm)->sdm_map->dm_segs[0].ds_addr)
#define SIOP_DMA_KVA(_sdm)	((void *)(_sdm)->sdm_kva)

/*
 * xfer description of the script: tables and reselect script
 * In struct siop_common_cmd siop_xfer will point to this.
 */
struct siop_xfer {
	struct siop_common_xfer siop_tables;
	/* u_int32_t resel[sizeof(load_dsa) / sizeof(load_dsa[0])]; */
	/* Add some entries to make size 384 bytes (244+140) */
	u_int32_t resel[35];
} __packed;

/*
 * This describes a command handled by the SCSI controller
 * These are chained in either a free list or an active list
 * We have one queue per target
 */

struct siop_cmd {
	TAILQ_ENTRY (siop_cmd) next;
	struct siop_common_cmd cmd_c;
	struct siop_cbd *siop_cbdp; /* pointer to our siop_cbd */
	int reselslot;
	u_int32_t saved_offset; /* offset in table after disc without sdp */
};
#define cmd_tables cmd_c.siop_tables

/* command block descriptors: an array of siop_cmd, siop_xfer, and sense */
struct siop_cbd {
	TAILQ_ENTRY (siop_cbd) next;
	struct siop_cmd *cmds;
	struct siop_dmamem *xfers;
	struct siop_dmamem *sense;
};

/* per-tag struct */
struct siop_tag {
	struct siop_cmd *active; /* active command */
	u_int reseloff;
};

/* per lun struct */
struct siop_lun {
	struct siop_tag siop_tag[SIOP_NTAG]; /* tag array */
	int lun_flags;
#define SIOP_LUNF_FULL 0x01 /* queue full message */
	u_int reseloff;
};

/*
 * per target struct; siop_common_cmd->target and siop_common_softc->targets[]
 * will point to this
 */
struct siop_target {
	struct siop_common_target target_c;
	struct siop_lun *siop_lun[8]; /* per-lun state */
	u_int reseloff;
	struct siop_lunsw *lunsw;
};

struct siop_lunsw {
	TAILQ_ENTRY (siop_lunsw) next;
	u_int32_t lunsw_off; /* offset of this lun sw, from sc_scriptaddr*/
	u_int32_t lunsw_size; /* size of this lun sw */
};


TAILQ_HEAD(cmd_list, siop_cmd);
TAILQ_HEAD(cbd_list, siop_cbd);
TAILQ_HEAD(lunsw_list, siop_lunsw);


/* Driver internal state */
struct siop_softc {
	struct siop_common_softc sc_c;
	int sc_currschedslot;		/* current scheduler slot */
	struct cbd_list cmds;		/* list of command block descriptors */
	struct cmd_list free_list;	/* cmd descr free list */
	struct cmd_list urgent_list;	/* high priority cmd descr list */
	struct cmd_list ready_list;	/* cmd descr ready list */
	struct scsi_iopool iopool;	/* cmd pool */
	struct lunsw_list lunsw_list;	/* lunsw free list */
	u_int32_t script_free_lo;	/* free ram offset from sc_scriptaddr */
	u_int32_t script_free_hi;	/* free ram offset from sc_scriptaddr */
	int sc_ntargets;		/* number of known targets */
	u_int32_t sc_flags;
};

/* defs for sc_flags */
#define SCF_CHAN_NOSLOT	0x0001		/* channel out of scheduler slot */

void    siop_attach(struct siop_softc *);
int	siop_intr(void *);
void	siop_add_dev(struct siop_softc *, int, int);
void	siop_del_dev(struct siop_softc *, int, int);
@


1.16
log
@pull the dmamam wrapper in from all my other drivers and use it to replace
the siop command buffers and add dmaable buffers for sense data.

matthew@@ found that siop used to try to dma to the xs->sense bufer, which
is not guaranteed to be dma safe.
tested by matthew@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.15 2010/07/23 07:47:13 jsg Exp $ */
d54 2
a55 2
	/* Add some entries to make size 384 bytes (256+128) */
	u_int32_t resel[36];
@


1.15
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.14 2010/04/06 01:12:17 dlg Exp $ */
d35 13
d73 1
a73 1
/* command block descriptors: an array of siop_cmd + an array of siop_xfer */
d77 2
a78 2
	struct siop_xfer *xfers;
	bus_dmamap_t xferdma; /* DMA map for this block of xfers */
@


1.14
log
@modify siop to provide an iopool as a way for the midlayer to manage
access to its free ccbs.

ok krw@@ beck@@ marco@@
tested by beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.13 2005/11/20 22:32:48 krw Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@Un-revert backout to 20051009 and add patches from Martin Bouyer to
close NetBSD PR#31990. Fixes interaction with some problematic drives
found by miod@@, martin@@, otto@@.

Tested martin@@ otto@@ miod@@

ok miod@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.12 2005/10/08 16:52:38 krw Exp $ */
d118 1
@


1.12
log
@Remove some trailing whitespace in license. From perry via NetBSD.
Note we are now sync'd up to latest (r1.21) NetBSD source.
@
text
@d1 2
a2 2
/*	$OpenBSD: siopvar.h,v 1.11 2004/10/13 23:33:03 krw Exp $ */
/*	$NetBSD: siopvar.h,v 1.21 2005/02/27 00:27:02 perry Exp $	*/
d61 1
@


1.11
log
@De-inline siop. Shrinks almost 1K on i386.

ok deraadt@@, marco@@, weingart@@, millert@@.
@
text
@d1 2
a2 2
/*	$OpenBSD: siopvar.h,v 1.10 2003/11/16 20:30:06 avsm Exp $ */
/*	$NetBSD: siopvar.h,v 1.18 2002/04/23 20:41:15 bouyer Exp $ */
d24 1
a24 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
@


1.10
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.9 2003/10/21 18:58:49 jmc Exp $ */
a101 15

static __inline__ void siop_table_sync(struct siop_cmd *, int);
static __inline__ void
siop_table_sync(siop_cmd, ops)
	struct siop_cmd *siop_cmd;
	int ops;
{
	struct siop_common_softc *sc  = siop_cmd->cmd_c.siop_sc;
	bus_addr_t offset;

	offset = siop_cmd->cmd_c.dsa -
	    siop_cmd->siop_cbdp->xferdma->dm_segs[0].ds_addr;
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->siop_cbdp->xferdma, offset,
	    sizeof(struct siop_xfer), ops);
}
@


1.9
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.8 2003/10/14 22:37:48 krw Exp $ */
d48 1
a48 1
} __attribute__((__packed__));
@


1.8
log
@Align siop_xfer on 128 byte boundary for all architectures now that 3.4 is out.

ok (and from) mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.7 2003/09/06 22:24:14 krw Exp $ */
d51 2
a52 2
 * This decribes a command handled by the SCSI controller
 * These are chained in either a free list or a active list
d140 1
a140 1
#define SCF_CHAN_NOSLOT	0x0001		/* channel out of sheduler slot */
@


1.7
log
@A couple of hppa-only changes, allowing siop to work on pci hppa
machines.

Align siop_xfer on 128 byte boundary, and don't use on-board RAM.
Aligning siop_xfer will be made general, post-3.4.

From mickey@@.

ok deraadt@@ mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.6 2002/09/16 00:53:12 krw Exp $ */
d46 1
a46 2
#ifdef __hppa__
	/* XXX Add some entries to make size 384 bytes (256+128) */
a47 3
#else
	u_int32_t resel[25];
#endif
@


1.6
log
@Resync siop with NetBSD. Make strong effort to minimize
differences, undoing whitespace, spelling, etc. changes
and adopting the NetBSD code instead of equivalent home
grown code for PPR negotiation, etc.

siop.c            1.21 -> 1.64
siop_common.c     1.12 -> 1.30
siopreg.h         1.7  -> 1.13
siopvar.h         1.13 -> 1.18
siopvar_common.h  1.10 -> 1.21
ncr53cxxx.c       1.5  -> 1.10
siop.ss           1.12 -> 1.17
siop_pci.c        1.8  -> 1.11
siop_pci_common.c 1.6  -> 1.17
siop_pci_common.h 1.2  -> 1.4

Many fixes, add 1010-66 support, restructure things to prepare for
addition of esiop, osiop and oosiop drivers.

tested on various archs by art@@, millert@@, wilfried@@, jason@@,
Dan Weeks.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.5 2002/03/14 01:26:55 millert Exp $ */
d46 4
d51 1
@


1.5
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: siopvar.h,v 1.4 2001/04/15 06:01:29 krw Exp $ */
/*	$NetBSD: siopvar.h,v 1.13 2000/10/23 23:18:11 bouyer Exp $	*/
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer
d36 82
d122 1
d125 1
a125 20
	struct device sc_dev;
	struct scsi_link sc_link;	/* link to upper level */
	int features;			/* chip's features */
	int ram_size;
	int maxburst;
	int maxoff;
	int clock_div;			/* async. clock divider (scntl3) */
	int min_dt_sync;		/* minimum acceptable double transition sync */
	int min_st_sync;		/* minimum acceptable single transition sync */
	int scf_index;			/* clock id == index into period_factor[].scf */
	bus_space_tag_t sc_rt;		/* bus_space registers tag */
	bus_space_handle_t sc_rh;	/* bus_space registers handle */
	bus_addr_t sc_raddr;		/* register adresses */
	bus_space_tag_t sc_ramt;	/* bus_space ram tag */
	bus_space_handle_t sc_ramh;	/* bus_space ram handle */
	bus_dma_tag_t sc_dmat;		/* bus DMA tag */
	void (*sc_reset)(struct siop_softc*); /* reset callback */
	bus_dmamap_t  sc_scriptdma;	/* DMA map for script */
	bus_addr_t sc_scriptaddr;	/* on-board ram or physical adress */
	u_int32_t *sc_script;		/* script location in memory */
a133 1
	struct siop_target *targets[16]; /* per-target states */
d137 1
d139 1
a139 23
/* none for now */

/* features */
#define SF_BUS_WIDE	0x00000001 /* wide bus */
#define SF_BUS_ULTRA	0x00000002 /* Ultra (20Mhz) bus */
#define SF_BUS_ULTRA2	0x00000004 /* Ultra2 (40Mhz) bus */
#define SF_BUS_DIFF	0x00000008 /* differential bus */

#define SF_CHIP_LED0	0x00000100 /* led on GPIO0 */
#define SF_CHIP_DBLR	0x00000200 /* clock doubler */
#define SF_CHIP_QUAD	0x00000400 /* clock quadrupler */
#define SF_CHIP_FIFO	0x00000800 /* large fifo */
#define SF_CHIP_PF	0x00001000 /* Intructions prefetch */
#define SF_CHIP_RAM	0x00002000 /* on-board RAM */
#define SF_CHIP_LS	0x00004000 /* load/store instruction */
#define SF_CHIP_10REGS	0x00008000 /* 10 scratch registers */
#define SF_CHIP_C10	0x00010000 /* 1010 or variant */

#define SF_PCI_RL	0x01000000 /* PCI read line */
#define SF_PCI_RM	0x02000000 /* PCI read multiple */
#define SF_PCI_BOF	0x04000000 /* PCI burst opcode fetch */
#define SF_PCI_CLS	0x08000000 /* PCI cache line size */
#define SF_PCI_WRI	0x10000000 /* PCI write and invalidate */
d143 2
@


1.4
log
@Support U160 on 53c1010 chips.

Add support for PPR negotiations and DT transfers,
and the preservation and restoration of the
SCNTL4 register which controls Ultra3 transfers.

Redo sync lookup, since the same period factor
can mean two things depending on whether you are
using DT or ST. Keep a minimum allowed ST period
factor, and a minimum allowd DT period factor for
each adapter.

Currently NO support for QAS or IUS or AIP.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.3 2001/03/10 05:04:06 krw Exp $ */
d58 1
a58 1
	void (*sc_reset) __P((struct siop_softc*)); /* reset callback */
d99 2
a100 2
void    siop_attach __P((struct siop_softc *));
int	siop_intr __P((void *));
@


1.4.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.4 2001/04/15 06:01:29 krw Exp $ */
d58 1
a58 1
	void (*sc_reset)(struct siop_softc*); /* reset callback */
d99 2
a100 2
void    siop_attach(struct siop_softc *);
int	siop_intr(void *);
@


1.4.8.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: siopvar.h,v 1.18 2002/04/23 20:41:15 bouyer Exp $ */
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
a35 82
/* Number of tag */
#define SIOP_NTAG 16

/*
 * xfer description of the script: tables and reselect script
 * In struct siop_common_cmd siop_xfer will point to this.
 */
struct siop_xfer {
	struct siop_common_xfer siop_tables;
	/* u_int32_t resel[sizeof(load_dsa) / sizeof(load_dsa[0])]; */
	u_int32_t resel[25];
} __attribute__((__packed__));

/*
 * This decribes a command handled by the SCSI controller
 * These are chained in either a free list or a active list
 * We have one queue per target
 */

struct siop_cmd {
	TAILQ_ENTRY (siop_cmd) next;
	struct siop_common_cmd cmd_c;
	struct siop_cbd *siop_cbdp; /* pointer to our siop_cbd */
	int reselslot;
};
#define cmd_tables cmd_c.siop_tables

/* command block descriptors: an array of siop_cmd + an array of siop_xfer */
struct siop_cbd {
	TAILQ_ENTRY (siop_cbd) next;
	struct siop_cmd *cmds;
	struct siop_xfer *xfers;
	bus_dmamap_t xferdma; /* DMA map for this block of xfers */
};

/* per-tag struct */
struct siop_tag {
	struct siop_cmd *active; /* active command */
	u_int reseloff;
};

/* per lun struct */
struct siop_lun {
	struct siop_tag siop_tag[SIOP_NTAG]; /* tag array */
	int lun_flags;
#define SIOP_LUNF_FULL 0x01 /* queue full message */
	u_int reseloff;
};

/*
 * per target struct; siop_common_cmd->target and siop_common_softc->targets[]
 * will point to this
 */
struct siop_target {
	struct siop_common_target target_c;
	struct siop_lun *siop_lun[8]; /* per-lun state */
	u_int reseloff;
	struct siop_lunsw *lunsw;
};

struct siop_lunsw {
	TAILQ_ENTRY (siop_lunsw) next;
	u_int32_t lunsw_off; /* offset of this lun sw, from sc_scriptaddr*/
	u_int32_t lunsw_size; /* size of this lun sw */
};

static __inline__ void siop_table_sync(struct siop_cmd *, int);
static __inline__ void
siop_table_sync(siop_cmd, ops)
	struct siop_cmd *siop_cmd;
	int ops;
{
	struct siop_common_softc *sc  = siop_cmd->cmd_c.siop_sc;
	bus_addr_t offset;

	offset = siop_cmd->cmd_c.dsa -
	    siop_cmd->siop_cbdp->xferdma->dm_segs[0].ds_addr;
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->siop_cbdp->xferdma, offset,
	    sizeof(struct siop_xfer), ops);
}


a39 1

d42 20
a61 1
	struct siop_common_softc sc_c;
d70 1
d74 2
d77 21
a97 2
/* defs for sc_flags */
#define SCF_CHAN_NOSLOT	0x0001		/* channel out of sheduler slot */
a100 2
void	siop_add_dev(struct siop_softc *, int, int);
void	siop_del_dev(struct siop_softc *, int, int);
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.4 2001/04/15 06:01:29 krw Exp $ */
@


1.4.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d58 1
a58 1
	void (*sc_reset)(struct siop_softc*); /* reset callback */
d99 2
a100 2
void    siop_attach(struct siop_softc *);
int	siop_intr(void *);
@


1.4.4.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: siopvar.h,v 1.18 2002/04/23 20:41:15 bouyer Exp $ */
d17 1
a17 1
 *	This product includes software developed by Manuel Bouyer.
a35 82
/* Number of tag */
#define SIOP_NTAG 16

/*
 * xfer description of the script: tables and reselect script
 * In struct siop_common_cmd siop_xfer will point to this.
 */
struct siop_xfer {
	struct siop_common_xfer siop_tables;
	/* u_int32_t resel[sizeof(load_dsa) / sizeof(load_dsa[0])]; */
	u_int32_t resel[25];
} __attribute__((__packed__));

/*
 * This decribes a command handled by the SCSI controller
 * These are chained in either a free list or a active list
 * We have one queue per target
 */

struct siop_cmd {
	TAILQ_ENTRY (siop_cmd) next;
	struct siop_common_cmd cmd_c;
	struct siop_cbd *siop_cbdp; /* pointer to our siop_cbd */
	int reselslot;
};
#define cmd_tables cmd_c.siop_tables

/* command block descriptors: an array of siop_cmd + an array of siop_xfer */
struct siop_cbd {
	TAILQ_ENTRY (siop_cbd) next;
	struct siop_cmd *cmds;
	struct siop_xfer *xfers;
	bus_dmamap_t xferdma; /* DMA map for this block of xfers */
};

/* per-tag struct */
struct siop_tag {
	struct siop_cmd *active; /* active command */
	u_int reseloff;
};

/* per lun struct */
struct siop_lun {
	struct siop_tag siop_tag[SIOP_NTAG]; /* tag array */
	int lun_flags;
#define SIOP_LUNF_FULL 0x01 /* queue full message */
	u_int reseloff;
};

/*
 * per target struct; siop_common_cmd->target and siop_common_softc->targets[]
 * will point to this
 */
struct siop_target {
	struct siop_common_target target_c;
	struct siop_lun *siop_lun[8]; /* per-lun state */
	u_int reseloff;
	struct siop_lunsw *lunsw;
};

struct siop_lunsw {
	TAILQ_ENTRY (siop_lunsw) next;
	u_int32_t lunsw_off; /* offset of this lun sw, from sc_scriptaddr*/
	u_int32_t lunsw_size; /* size of this lun sw */
};

static __inline__ void siop_table_sync(struct siop_cmd *, int);
static __inline__ void
siop_table_sync(siop_cmd, ops)
	struct siop_cmd *siop_cmd;
	int ops;
{
	struct siop_common_softc *sc  = siop_cmd->cmd_c.siop_sc;
	bus_addr_t offset;

	offset = siop_cmd->cmd_c.dsa -
	    siop_cmd->siop_cbdp->xferdma->dm_segs[0].ds_addr;
	bus_dmamap_sync(sc->sc_dmat, siop_cmd->siop_cbdp->xferdma, offset,
	    sizeof(struct siop_xfer), ops);
}


a39 1

d42 20
a61 1
	struct siop_common_softc sc_c;
d70 1
d74 2
d77 21
a97 2
/* defs for sc_flags */
#define SCF_CHAN_NOSLOT	0x0001		/* channel out of sheduler slot */
a100 2
void	siop_add_dev(struct siop_softc *, int, int);
void	siop_del_dev(struct siop_softc *, int, int);
@


1.4.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d46 2
a47 3
	/* Add some entries to make size 384 bytes (256+128) */
	u_int32_t resel[36];
} __packed;
d50 2
a51 2
 * This describes a command handled by the SCSI controller
 * These are chained in either a free list or an active list
d139 1
a139 1
#define SCF_CHAN_NOSLOT	0x0001		/* channel out of scheduler slot */
@


1.3
log
@First support for 53c1010 chip. This enables support up to U2W for
either or both channels on the 53c1010. U3W/U160 support coming.

The particulars of 53c1010 support was derived from the FreeBSD/Linux
sym-2 driver under development by Gerard ROUDIER (groudier@@FreeBSD.org).

This first support ensures that registers and bits now reserved are
not used by the 53c1010. It uses the new DFBC register to obtain
DMA FIFO relics.

A single new feature (SF_CHIP_C10) was added, rather than a new
feature for each change the 53c1010 incorporates.

These changes were sufficient to get the imbedded 53c1010 on a Tyan
S2510U3NG board to support installation of OpenBSD to a Quantum Atlas
10K2 drive, and several subsequent 'make build' and 'make release'
cycles using disks on both channels, with and without
softupdates.

More 53c1010 specific code is yet to be extracted from sym-2,
including the changes necessary to enable U160.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.2 2001/03/01 17:14:28 krw Exp $ */
d49 3
a51 3
	int clock_period;		/* clock period (ns * 10) */
	int minsync;			/* min and max sync period, */
	int maxsync;			/* as sent in SDTR message */
@


1.2
log
@Typo police: various misspelling, capitalizations, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: siopvar.h,v 1.1 2001/02/15 04:07:58 krw Exp $ */
d91 1
@


1.1
log
@Import siop, a replacement for the ncr SCSI driver, from NetBSD.

Written for NetBSD by Manuel Bouyer.

Tested with various cards on i386 and alpha.

Outstanding issue: doesn't work with PowerPC yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d65 1
a65 1
	struct cmd_list urgent_list;	/* hitgh priority cmd descr list */
@

