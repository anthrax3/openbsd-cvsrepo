head	1.25;
access;
symbols
	OPENBSD_6_1:1.24.0.12
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.10
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.4
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.14
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.12
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.8
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.6
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.4.0.12
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.14
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2017.07.26.03.36.19;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	PIDGvrDlgRKSrjfT;

1.24
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.23;
commitid	uzzBR7hz9ncd4O6G;

1.23
date	2011.10.25.15.48.06;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.03.12.42.36;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.30.19.06.16;	author mk;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.04.04.57.14;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.29.13.58.51;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.03.16.53.16;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.17.18.07.36;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.03.07.29.29;	author mickey;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	97.04.13.20.10.29;	author mickey;	state Exp;
branches
	1.2.14.1;
next	1.1;

1.1
date	96.11.28.23.27.54;	author niklas;	state Exp;
branches;
next	;

1.2.14.1
date	2001.05.14.22.24.20;	author niklas;	state Exp;
branches;
next	1.2.14.2;

1.2.14.2
date	2002.03.28.12.09.41;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@uha_init_mscp() is unused.
@
text
@/*	$OpenBSD: uha.c,v 1.24 2014/09/14 14:17:25 jsg Exp $	*/
/*	$NetBSD: uha.c,v 1.3 1996/10/13 01:37:29 christos Exp $	*/

#undef UHADEBUG

/*
 * Copyright (c) 1994, 1996 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Ported for use with the UltraStor 14f by Gary Close (gclose@@wvnvms.wvnet.edu)
 * Slight fixes to timeouts to run with the 34F
 * Thanks to Julian Elischer for advice and help with this port.
 *
 * Originally written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * commenced: Sun Sep 27 18:14:01 PDT 1992
 * slight mod to make work with 34F as well: Wed Jun  2 18:05:48 WST 1993
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/uhareg.h>
#include <dev/ic/uhavar.h>

#define KVTOPHYS(x)	vtophys((vaddr_t)x)

void uha_reset_mscp(struct uha_softc *, struct uha_mscp *);
void uha_mscp_free(void *, void *);
void *uha_mscp_alloc(void *);
void uhaminphys(struct buf *, struct scsi_link *);
void uha_scsi_cmd(struct scsi_xfer *);

struct scsi_adapter uha_switch = {
	uha_scsi_cmd,
	uhaminphys,
	0,
	0,
};

struct cfdriver uha_cd = {
	NULL, "uha", DV_DULL
};

#define	UHA_ABORT_TIMEOUT	2000	/* time to wait for abort (mSec) */

#ifdef __OpenBSD__
int	uhaprint(void *, const char *);

int
uhaprint(aux, name)
	void *aux;
	const char *name;
{

	if (name != NULL)
		printf("%s: scsibus ", name);
	return UNCONF;
}
#endif

/*
 * Attach all the sub-devices we can find
 */
void
uha_attach(sc)
	struct uha_softc *sc;
{
	struct scsibus_attach_args saa;

	(sc->init)(sc);
	SLIST_INIT(&sc->sc_free_mscp);

	mtx_init(&sc->sc_mscp_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, uha_mscp_alloc, uha_mscp_free);

	/*
	 * fill in the prototype scsi_link.
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->sc_scsi_dev;
	sc->sc_link.adapter = &uha_switch;
	sc->sc_link.openings = 2;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	/*
	 * ask the adapter what subunits are present
	 */
	config_found(&sc->sc_dev, &saa, uhaprint);
}

void
uha_reset_mscp(sc, mscp)
	struct uha_softc *sc;
	struct uha_mscp *mscp;
{

	mscp->flags = 0;
}

/*
 * A mscp (and hence a mbx-out) is put onto the free list.
 */
void
uha_mscp_free(xsc, xmscp)
	void *xsc, *xmscp;
{
	struct uha_softc *sc = xsc;
	struct uha_mscp *mscp = xmscp;

	uha_reset_mscp(sc, mscp);

	mtx_enter(&sc->sc_mscp_mtx);
	SLIST_INSERT_HEAD(&sc->sc_free_mscp, mscp, chain);
	mtx_leave(&sc->sc_mscp_mtx);
}

/*
 * Get a free mscp
 */
void *
uha_mscp_alloc(xsc)
	void *xsc;	
{
	struct uha_softc *sc = xsc;
	struct uha_mscp *mscp;

	mtx_enter(&sc->sc_mscp_mtx);
	mscp = SLIST_FIRST(&sc->sc_free_mscp);
	if (mscp) {
		SLIST_REMOVE_HEAD(&sc->sc_free_mscp, chain);
		mscp->flags |= MSCP_ALLOC;
	}
	mtx_leave(&sc->sc_mscp_mtx);

	return (mscp);
}

/*
 * given a physical address, find the mscp that it corresponds to.
 */
struct uha_mscp *
uha_mscp_phys_kv(sc, mscp_phys)
	struct uha_softc *sc;
	u_long mscp_phys;
{
	int hashnum = MSCP_HASH(mscp_phys);
	struct uha_mscp *mscp = sc->sc_mscphash[hashnum];

	while (mscp) {
		if (mscp->hashkey == mscp_phys)
			break;
		mscp = mscp->nexthash;
	}
	return (mscp);
}

/*
 * We have a mscp which has been processed by the adaptor, now we look to see
 * how the operation went.
 */
void
uha_done(sc, mscp)
	struct uha_softc *sc;
	struct uha_mscp *mscp;
{
	struct scsi_sense_data *s1, *s2;
	struct scsi_xfer *xs = mscp->xs;

	SC_DEBUG(xs->sc_link, SDEV_DB2, ("uha_done\n"));
	/*
	 * Otherwise, put the results of the operation
	 * into the xfer and call whoever started it
	 */
	if ((mscp->flags & MSCP_ALLOC) == 0) {
		panic("%s: exiting ccb not allocated!", sc->sc_dev.dv_xname);
		return;
	}
	if (xs->error == XS_NOERROR) {
		if (mscp->host_stat != UHA_NO_ERR) {
			switch (mscp->host_stat) {
			case UHA_SBUS_TIMEOUT:		/* No response */
				xs->error = XS_SELTIMEOUT;
				break;
			default:	/* Other scsi protocol messes */
				printf("%s: host_stat %x\n",
				    sc->sc_dev.dv_xname, mscp->host_stat);
				xs->error = XS_DRIVER_STUFFUP;
			}
		} else if (mscp->target_stat != SCSI_OK) {
			switch (mscp->target_stat) {
			case SCSI_CHECK:
				s1 = &mscp->mscp_sense;
				s2 = &xs->sense;
				*s2 = *s1;
				xs->error = XS_SENSE;
				break;
			case SCSI_BUSY:
				xs->error = XS_BUSY;
				break;
			default:
				printf("%s: target_stat %x\n",
				    sc->sc_dev.dv_xname, mscp->target_stat);
				xs->error = XS_DRIVER_STUFFUP;
			}
		} else
			xs->resid = 0;
	}

	scsi_done(xs);
}

void
uhaminphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > ((UHA_NSEG - 1) << PGSHIFT))
		bp->b_bcount = ((UHA_NSEG - 1) << PGSHIFT);
	minphys(bp);
}

/*
 * start a scsi operation given the command and the data address.  Also
 * needs the unit, target and lu.
 */
void
uha_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *sc_link = xs->sc_link;
	struct uha_softc *sc = sc_link->adapter_softc;
	struct uha_mscp *mscp;
	struct uha_dma_seg *sg;
	int seg;		/* scatter gather seg being worked on */
	u_long thiskv, thisphys, nextphys;
	int bytes_this_seg, bytes_this_page, datalen, flags;
	int s;

	SC_DEBUG(sc_link, SDEV_DB2, ("uha_scsi_cmd\n"));
	/*
	 * get a mscp (mbox-out) to use. If the transfer
	 * is from a buf (possibly from interrupt time)
	 * then we can't allow it to sleep
	 */
	flags = xs->flags;
	mscp = xs->io;

	mscp->xs = xs;
	mscp->timeout = xs->timeout;
	timeout_set(&xs->stimeout, uha_timeout, xs);

	/*
	 * Put all the arguments for the xfer in the mscp
	 */
	if (flags & SCSI_RESET) {
		mscp->opcode = UHA_SDR;
		mscp->ca = 0x01;
	} else {
		mscp->opcode = UHA_TSP;
		/* XXX Not for tapes. */
		mscp->ca = 0x01;
		bcopy(xs->cmd, &mscp->scsi_cmd, mscp->scsi_cmd_length);
	}
	mscp->xdir = UHA_SDET;
	mscp->dcn = 0x00;
	mscp->chan = 0x00;
	mscp->target = sc_link->target;
	mscp->lun = sc_link->lun;
	mscp->scsi_cmd_length = xs->cmdlen;
	mscp->sense_ptr = KVTOPHYS(&mscp->mscp_sense);
	mscp->req_sense_length = sizeof(mscp->mscp_sense);
	mscp->host_stat = 0x00;
	mscp->target_stat = 0x00;

	if (xs->datalen) {
		sg = mscp->uha_dma;
		seg = 0;

		/*
		 * Set up the scatter gather block
		 */
		SC_DEBUG(sc_link, SDEV_DB4,
		    ("%d @@0x%x:- ", xs->datalen, xs->data));
		datalen = xs->datalen;
		thiskv = (int) xs->data;
		thisphys = KVTOPHYS(thiskv);

		while (datalen && seg < UHA_NSEG) {
			bytes_this_seg = 0;

			/* put in the base address */
			sg->seg_addr = thisphys;

			SC_DEBUGN(sc_link, SDEV_DB4, ("0x%x", thisphys));

			/* do it at least once */
			nextphys = thisphys;
			while (datalen && thisphys == nextphys) {
				/*
				 * This page is contiguous (physically)
				 * with the last, just extend the
				 * length
				 */
				/* how far to the end of the page */
				nextphys = (thisphys & ~PGOFSET) + NBPG;
				bytes_this_page = nextphys - thisphys;
				/**** or the data ****/
				bytes_this_page = min(bytes_this_page,
						      datalen);
				bytes_this_seg += bytes_this_page;
				datalen -= bytes_this_page;

				/* get more ready for the next page */
				thiskv = (thiskv & ~PGOFSET) + NBPG;
				if (datalen)
					thisphys = KVTOPHYS(thiskv);
			}
			/*
			 * next page isn't contiguous, finish the seg
			 */
			SC_DEBUGN(sc_link, SDEV_DB4,
			    ("(0x%x)", bytes_this_seg));
			sg->seg_len = bytes_this_seg;
			sg++;
			seg++;
		}

		SC_DEBUGN(sc_link, SDEV_DB4, ("\n"));
		if (datalen) {
			/*
			 * there's still data, must have run out of segs!
			 */
			printf("%s: uha_scsi_cmd, more than %d dma segs\n",
			    sc->sc_dev.dv_xname, UHA_NSEG);
			goto bad;
		}
		mscp->data_addr = KVTOPHYS(mscp->uha_dma);
		mscp->data_length = xs->datalen;
		mscp->sgth = 0x01;
		mscp->sg_num = seg;
	} else {		/* No data xfer, use non S/G values */
		mscp->data_addr = (physaddr)0;
		mscp->data_length = 0;
		mscp->sgth = 0x00;
		mscp->sg_num = 0;
	}
	mscp->link_id = 0;
	mscp->link_addr = (physaddr)0;

	s = splbio();
	(sc->start_mbox)(sc, mscp);
	splx(s);

	/*
	 * Usually return SUCCESSFULLY QUEUED
	 */
	if ((flags & SCSI_POLL) == 0)
		return;

	/*
	 * If we can't use interrupts, poll on completion
	 */
	if ((sc->poll)(sc, xs, mscp->timeout)) {
		uha_timeout(mscp);
		if ((sc->poll)(sc, xs, mscp->timeout))
			uha_timeout(mscp);
	}
	return;

bad:
	xs->error = XS_DRIVER_STUFFUP;
	scsi_done(xs);
	return;
}

void
uha_timeout(arg)
	void *arg;
{
	struct uha_mscp *mscp = arg;
	struct scsi_xfer *xs = mscp->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct uha_softc *sc = sc_link->adapter_softc;
	int s;

	sc_print_addr(sc_link);
	printf("timed out");

	s = splbio();

	if (mscp->flags & MSCP_ABORT) {
		/* abort timed out */
		printf(" AGAIN\n");
		/* XXX Must reset! */
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		mscp->xs->error = XS_TIMEOUT;
		mscp->timeout = UHA_ABORT_TIMEOUT;
		mscp->flags |= MSCP_ABORT;
		(sc->start_mbox)(sc, mscp);
	}

	splx(s);
}
@


1.24
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.23 2011/10/25 15:48:06 krw Exp $	*/
a4 5
#ifdef DDB
#define	integrate
#else
#define	integrate	static inline
#endif
d79 1
a79 1
integrate void uha_reset_mscp(struct uha_softc *, struct uha_mscp *);
a80 1
integrate void uha_init_mscp(struct uha_softc *, struct uha_mscp *);
d146 1
a146 1
integrate void
a169 19
}

integrate void
uha_init_mscp(sc, mscp)
	struct uha_softc *sc;
	struct uha_mscp *mscp;
{
	int hashnum;

	bzero(mscp, sizeof(struct uha_mscp));
	/*
	 * put in the phystokv hash table
	 * Never gets taken out.
	 */
	mscp->hashkey = KVTOPHYS(mscp);
	hashnum = MSCP_HASH(mscp->hashkey);
	mscp->nexthash = sc->sc_mscphash[hashnum];
	sc->sc_mscphash[hashnum] = mscp;
	uha_reset_mscp(sc, mscp);
@


1.23
log
@Initialize variables before use. And if initializing, use the correct
source! From Pedro Martelletto.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.22 2011/04/03 12:42:36 krw Exp $	*/
a70 1
#include <sys/proc.h>
@


1.22
log
@Iopoolification of some less common scsi drivers.

ok dlg@@ ("miod will not object" dlg@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.21 2010/08/07 03:50:01 krw Exp $	*/
d169 2
a170 2
	struct uha_softc *sc = xmscp;
	struct uha_mscp *mscp;
@


1.21
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.20 2010/06/30 19:06:16 mk Exp $	*/
d86 1
a86 1
void uha_free_mscp(struct uha_softc *, struct uha_mscp *);
d88 1
a88 1
struct uha_mscp *uha_get_mscp(struct uha_softc *, int);
d132 3
d142 1
d166 4
a169 2
uha_free_mscp(sc, mscp)
	struct uha_softc *sc;
a170 2
{
	int s;
d172 1
a172 1
	s = splbio();
d174 1
a174 1
	uha_reset_mscp(sc, mscp);
d176 1
a176 9

	/*
	 * If there were none, wake anybody waiting for one to come free,
	 * starting with queued entries.
	 */
	if (SLIST_NEXT(mscp, chain) == NULL)
		wakeup(&sc->sc_free_mscp);

	splx(s);
a199 3
 *
 * If there are none, see if we can allocate a new one.  If so, put it in the
 * hash table too otherwise either return an error or sleep.
d201 3
a203 4
struct uha_mscp *
uha_get_mscp(sc, flags)
	struct uha_softc *sc;
	int flags;
d205 1
a206 3
	int s;

	s = splbio();
d208 5
a212 25
	/*
	 * If we can and have to, sleep waiting for one to come free
	 * but only if we can't allocate a new one
	 */
	for (;;) {
		mscp = SLIST_FIRST(&sc->sc_free_mscp);
		if (mscp) {
			SLIST_REMOVE_HEAD(&sc->sc_free_mscp, chain);
			break;
		}
		if (sc->sc_nummscps < UHA_MSCP_MAX) {
			mscp = (struct uha_mscp *) malloc(sizeof(struct uha_mscp),
			    M_TEMP, M_NOWAIT);
			if (!mscp) {
				printf("%s: can't malloc mscp\n",
				    sc->sc_dev.dv_xname);
				goto out;
			}
			uha_init_mscp(sc, mscp);
			sc->sc_nummscps++;
			break;
		}
		if ((flags & SCSI_NOSLEEP) != 0)
			goto out;
		tsleep(&sc->sc_free_mscp, PRIBIO, "uhamsc", 0);
d214 1
a215 4
	mscp->flags |= MSCP_ALLOC;

out:
	splx(s);
d289 1
a289 1
	uha_free_mscp(sc, mscp);
d325 2
a326 5
	if ((mscp = uha_get_mscp(sc, flags)) == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
a451 1
	uha_free_mscp(sc, mscp);
@


1.20
log
@Use SLIST instead of TAILQ for the ccb free list.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.19 2010/06/28 18:31:02 krw Exp $	*/
d289 1
a289 1
		panic("%s: exiting ccb not allocated!\n", sc->sc_dev.dv_xname);
@


1.19
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.18 2010/06/26 23:24:44 guenther Exp $	*/
d130 1
a130 1
	TAILQ_INIT(&sc->sc_free_mscp);
d171 1
a171 1
	TAILQ_INSERT_HEAD(&sc->sc_free_mscp, mscp, chain);
d177 1
a177 1
	if (TAILQ_NEXT(mscp, chain) == NULL)
d223 1
a223 1
		mscp = TAILQ_FIRST(&sc->sc_free_mscp);
d225 1
a225 1
			TAILQ_REMOVE(&sc->sc_free_mscp, mscp, chain);
@


1.18
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.17 2010/05/20 00:55:17 krw Exp $	*/
a98 8
/* the below structure is so we have a default dev struct for out link struct */
struct scsi_device uha_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

a137 1
	sc->sc_link.device = &uha_dev;
@


1.17
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.16 2010/03/23 01:57:20 krw Exp $	*/
d72 1
a72 1
#include <sys/user.h>
@


1.16
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.15 2010/01/09 23:15:06 krw Exp $	*/
a368 1
		s = splbio();
a369 1
		splx(s);
a495 1
	s = splbio();
a496 1
	splx(s);
@


1.15
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.14 2009/09/04 04:57:14 miod Exp $	*/
d90 1
a90 1
int uha_scsi_cmd(struct scsi_xfer *);
d347 1
a347 1
int
d368 5
a372 1
		return (NO_CCB);
d484 1
a484 1
		return (SUCCESSFULLY_QUEUED);
d494 1
a494 1
	return (COMPLETE);
d502 1
a502 1
	return (COMPLETE);
@


1.14
log
@Missing scsi_done() in some error path returning COMPLETE; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.13 2009/08/29 13:58:51 jasper Exp $	*/
a331 1
	xs->flags |= ITSDONE;
a493 1
	xs->flags |= ITSDONE;
@


1.13
log
@remove more unneeded Debugger() calls from dev/

agreed by deraadt@@
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.12 2009/02/16 21:19:07 miod Exp $	*/
d495 4
@


1.12
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.11 2008/11/24 00:31:35 krw Exp $	*/
a82 4
#ifndef	DDB
#define Debugger() panic("should call debugger here (ultra14f.c)")
#endif /* ! DDB */

d298 1
a298 2
		printf("%s: exiting ccb not allocated!\n", sc->sc_dev.dv_xname);
		Debugger();
@


1.11
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.10 2008/09/12 11:14:04 miod Exp $	*/
d93 1
a93 1
void uhaminphys(struct buf *);
d342 1
a342 2
uhaminphys(bp)
	struct buf *bp;
a343 1

@


1.10
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.9 2006/11/28 23:59:45 dlg Exp $	*/
d376 1
a376 1
		return (TRY_AGAIN_LATER);
@


1.9
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.8 2005/12/03 16:53:16 krw Exp $	*/
d408 39
a446 16
#ifdef	TFS
		if (flags & SCSI_DATA_UIO) {
			struct iovec *iovp;
			iovp = ((struct uio *) xs->data)->uio_iov;
			datalen = ((struct uio *) xs->data)->uio_iovcnt;
			xs->datalen = 0;
			while (datalen && seg < UHA_NSEG) {
				sg->seg_addr = (physaddr)iovp->iov_base;
				sg->seg_len = iovp->iov_len;
				xs->datalen += iovp->iov_len;
				SC_DEBUGN(sc_link, SDEV_DB4, ("(0x%x@@0x%x)",
				    iovp->iov_len, iovp->iov_base));
				sg++;
				iovp++;
				seg++;
				datalen--;
a447 3
		} else
#endif /*TFS */
		{
d449 1
a449 1
			 * Set up the scatter gather block
d451 5
a455 45
			SC_DEBUG(sc_link, SDEV_DB4,
			    ("%d @@0x%x:- ", xs->datalen, xs->data));
			datalen = xs->datalen;
			thiskv = (int) xs->data;
			thisphys = KVTOPHYS(thiskv);

			while (datalen && seg < UHA_NSEG) {
				bytes_this_seg = 0;

				/* put in the base address */
				sg->seg_addr = thisphys;

				SC_DEBUGN(sc_link, SDEV_DB4, ("0x%x", thisphys));

				/* do it at least once */
				nextphys = thisphys;
				while (datalen && thisphys == nextphys) {
					/*
					 * This page is contiguous (physically)
					 * with the last, just extend the
					 * length
					 */
					/* how far to the end of the page */
					nextphys = (thisphys & ~PGOFSET) + NBPG;
					bytes_this_page = nextphys - thisphys;
					/**** or the data ****/
					bytes_this_page = min(bytes_this_page,
							      datalen);
					bytes_this_seg += bytes_this_page;
					datalen -= bytes_this_page;

					/* get more ready for the next page */
					thiskv = (thiskv & ~PGOFSET) + NBPG;
					if (datalen)
						thisphys = KVTOPHYS(thiskv);
				}
				/*
				 * next page isn't contiguous, finish the seg
				 */
				SC_DEBUGN(sc_link, SDEV_DB4,
				    ("(0x%x)", bytes_this_seg));
				sg->seg_len = bytes_this_seg;
				sg++;
				seg++;
			}
d457 1
a457 1
		/* end of iov/kv decision */
@


1.8
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.7 2005/11/23 11:30:14 mickey Exp $	*/
d139 1
a146 3
#ifndef __OpenBSD__
	sc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;
#endif
d153 3
d159 1
a159 5
#ifdef __OpenBSD__
	config_found(&sc->sc_dev, &sc->sc_link, uhaprint);
#else
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
#endif
@


1.7
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.6 2005/02/17 18:07:36 jfb Exp $	*/
a378 1
		xs->error = XS_DRIVER_STUFFUP;
@


1.6
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.5 2004/12/26 21:22:13 miod Exp $	*/
d87 1
a87 1
#define KVTOPHYS(x)	vtophys(x)
@


1.5
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.4 2002/03/14 01:26:55 millert Exp $	*/
d454 1
a454 1
					 * with the the last, just extend the
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.3 2001/02/03 07:29:29 mickey Exp $	*/
d193 1
a193 1
	if (mscp->chain.tqe_next == 0)
d239 1
a239 1
		mscp = sc->sc_free_mscp.tqh_first;
@


1.3
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.2 1997/04/13 20:10:29 mickey Exp $	*/
d89 6
a94 6
integrate void uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));
void uha_free_mscp __P((struct uha_softc *, struct uha_mscp *));
integrate void uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));
struct uha_mscp *uha_get_mscp __P((struct uha_softc *, int));
void uhaminphys __P((struct buf *));
int uha_scsi_cmd __P((struct scsi_xfer *));
d118 1
a118 1
int	uhaprint __P((void *, const char *));
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.3 2001/02/03 07:29:29 mickey Exp $	*/
d89 6
a94 6
integrate void uha_reset_mscp(struct uha_softc *, struct uha_mscp *);
void uha_free_mscp(struct uha_softc *, struct uha_mscp *);
integrate void uha_init_mscp(struct uha_softc *, struct uha_mscp *);
struct uha_mscp *uha_get_mscp(struct uha_softc *, int);
void uhaminphys(struct buf *);
int uha_scsi_cmd(struct scsi_xfer *);
d118 1
a118 1
int	uhaprint(void *, const char *);
@


1.2
log
@make it compile again
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.1 1996/11/28 23:27:54 niklas Exp $	*/
d384 1
@


1.2.14.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.3 2001/02/03 07:29:29 mickey Exp $	*/
a383 1
	timeout_set(&xs->stimeout, uha_timeout, xs);
@


1.2.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 6
a94 6
integrate void uha_reset_mscp(struct uha_softc *, struct uha_mscp *);
void uha_free_mscp(struct uha_softc *, struct uha_mscp *);
integrate void uha_init_mscp(struct uha_softc *, struct uha_mscp *);
struct uha_mscp *uha_get_mscp(struct uha_softc *, int);
void uhaminphys(struct buf *);
int uha_scsi_cmd(struct scsi_xfer *);
d118 1
a118 1
int	uhaprint(void *, const char *);
@


1.1
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha.c,v 1.3 1996/10/13 01:37:29 christos Exp $	*/
d89 1
a89 1
void uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));
d91 1
a91 1
void uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));
@
