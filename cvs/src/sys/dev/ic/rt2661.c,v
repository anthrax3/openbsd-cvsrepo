head	1.91;
access;
symbols
	OPENBSD_6_1_BASE:1.91
	OPENBSD_6_0:1.90.0.4
	OPENBSD_6_0_BASE:1.90
	OPENBSD_5_9:1.89.0.2
	OPENBSD_5_9_BASE:1.89
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.75.0.4
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.68.0.4
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.68.0.2
	OPENBSD_5_3_BASE:1.68
	OPENBSD_5_2:1.67.0.2
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.6
	OPENBSD_5_0:1.65.0.2
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.36.0.4
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13;
locks; strict;
comment	@ * @;


1.91
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.90;
commitid	VyLWTsbepAOk7VQM;

1.90
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.89;
commitid	QHiEhS9DHyE6oiIr;

1.89
date	2015.12.11.16.07.01;	author mpi;	state Exp;
branches;
next	1.88;
commitid	fbhqfhfdKxBcsetK;

1.88
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.87;
commitid	B0kwmVGiD5DVx4kv;

1.87
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.86;
commitid	5DvsamK0GblTp8ww;

1.86
date	2015.11.20.12.41.29;	author mpi;	state Exp;
branches;
next	1.85;
commitid	be9Ys4hrOFYlfa34;

1.85
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.84;
commitid	eYnPulzvLjDImPCa;

1.84
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.83;
commitid	YT6fyIEviv9qwbl6;

1.83
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.82;
commitid	p0v5tuE1Ch6fY0Nj;

1.82
date	2015.09.09.19.26.05;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	XlGeAMTUDUJVt1tj;

1.81
date	2015.08.29.20.55.34;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	pUbB7iMiclIsR7nA;

1.80
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.79;
commitid	p4LJxGKbi0BU2cG6;

1.79
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.78;
commitid	Hly9lJn6CNMylcFu;

1.78
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.77;
commitid	yM2VFFhpDTeFQlve;

1.77
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.76;
commitid	LS2TNeCue5R9L67C;

1.76
date	2014.09.06.05.41.35;	author jsg;	state Exp;
branches;
next	1.75;
commitid	TZ6gfz2Iz0CRv2Rz;

1.75
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.74;
commitid	TGHgrLxu6sxZoiFt;

1.74
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	JtO5uXxVcnZfhUkR;

1.73
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.72;
commitid	I19imNlAX05zJOED;

1.72
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.71;

1.71
date	2014.03.11.19.45.28;	author guenther;	state Exp;
branches;
next	1.70;

1.70
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2013.08.07.01.06.30;	author bluhm;	state Exp;
branches;
next	1.68;

1.68
date	2012.08.23.10.34.25;	author stsp;	state Exp;
branches;
next	1.67;

1.67
date	2012.07.17.14.43.12;	author stsp;	state Exp;
branches;
next	1.66;

1.66
date	2012.07.13.10.08.15;	author stsp;	state Exp;
branches;
next	1.65;

1.65
date	2011.03.18.06.05.21;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2011.02.22.20.05.03;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.06.19.20.21;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2010.09.06.18.22.02;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2010.08.28.18.08.07;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.58;

1.58
date	2010.08.27.16.06.25;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2010.08.27.04.09.18;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2010.08.25.21.37.59;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2010.08.04.19.48.33;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2010.02.14.09.20.34;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2009.11.01.12.08.36;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2009.08.10.17.47.23;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2009.07.29.17.46.31;	author blambert;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.47;

1.47
date	2008.12.22.18.20.47;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2008.12.21.18.19.58;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2008.11.25.21.43.57;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.14.16.02.24;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.17.14.29.11;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.15.01.37.49;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.08.18.50.57;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.03.18.16.43;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.17.16.24.00;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.03.16.39.13;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.26.11.14.18;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.13.20.06.38;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.30.20.15.22;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.22.12.14.44;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.18.21.11.02;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.18.16.20.20;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2006.08.09.07.46.37;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2006.08.03.09.28.13;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.18.16.40.30;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.18.18.44.04;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.18.12.32.46;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.14.19.31.47;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.10.20.31.59;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.08.19.58.44;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.01.16.24.22;	author robert;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.01.08.41.11;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.27.20.54.15;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.25.13.08.39;	author damien;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2006.02.25.13.02.10;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.25.12.56.47;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.18.09.41.41;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.15.17.23.26;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.14.12.43.27;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.14.08.50.38;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.13.21.09.49;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.11.21.39.10;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.11.21.02.17;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.10.21.33.52;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.10.21.20.46;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.09.20.03.34;	author damien;	state Exp;
branches;
next	;

1.13.2.1
date	2006.05.03.03.43.49;	author brad;	state Exp;
branches;
next	;


desc
@@


1.91
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: rt2661.c,v 1.90 2016/04/13 10:49:26 mpi Exp $	*/

/*-
 * Copyright (c) 2006
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Ralink Technology RT2561, RT2561S and RT2661 chipset driver
 * http://www.ralinktech.com/
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>
#include <net80211/ieee80211_node.h>

#include <dev/ic/rt2661var.h>
#include <dev/ic/rt2661reg.h>

#include <dev/pci/pcidevs.h>

#ifdef RAL_DEBUG
#define DPRINTF(x)	do { if (rt2661_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (rt2661_debug >= (n)) printf x; } while (0)
int rt2661_debug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

void		rt2661_attachhook(struct device *);
int		rt2661_alloc_tx_ring(struct rt2661_softc *,
		    struct rt2661_tx_ring *, int);
void		rt2661_reset_tx_ring(struct rt2661_softc *,
		    struct rt2661_tx_ring *);
void		rt2661_free_tx_ring(struct rt2661_softc *,
		    struct rt2661_tx_ring *);
int		rt2661_alloc_rx_ring(struct rt2661_softc *,
		    struct rt2661_rx_ring *, int);
void		rt2661_reset_rx_ring(struct rt2661_softc *,
		    struct rt2661_rx_ring *);
void		rt2661_free_rx_ring(struct rt2661_softc *,
		    struct rt2661_rx_ring *);
struct		ieee80211_node *rt2661_node_alloc(struct ieee80211com *);
void		rt2661_node_free(struct ieee80211com *,
		    struct ieee80211_node *);
int		rt2661_media_change(struct ifnet *);
void		rt2661_next_scan(void *);
void		rt2661_iter_func(void *, struct ieee80211_node *);
void		rt2661_updatestats(void *);
void		rt2661_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
int		rt2661_newstate(struct ieee80211com *, enum ieee80211_state,
		    int);
uint16_t	rt2661_eeprom_read(struct rt2661_softc *, uint8_t);
void		rt2661_tx_intr(struct rt2661_softc *);
void		rt2661_tx_dma_intr(struct rt2661_softc *,
		    struct rt2661_tx_ring *);
void		rt2661_rx_intr(struct rt2661_softc *);
#ifndef IEEE80211_STA_ONLY
void		rt2661_mcu_beacon_expire(struct rt2661_softc *);
#endif
void		rt2661_mcu_wakeup(struct rt2661_softc *);
void		rt2661_mcu_cmd_intr(struct rt2661_softc *);
int		rt2661_intr(void *);
#if NBPFILTER > 0
uint8_t		rt2661_rxrate(const struct rt2661_rx_desc *);
#endif
int		rt2661_ack_rate(struct ieee80211com *, int);
uint16_t	rt2661_txtime(int, int, uint32_t);
uint8_t		rt2661_plcp_signal(int);
void		rt2661_setup_tx_desc(struct rt2661_softc *,
		    struct rt2661_tx_desc *, uint32_t, uint16_t, int, int,
		    const bus_dma_segment_t *, int, int, u_int8_t);
int		rt2661_tx_mgt(struct rt2661_softc *, struct mbuf *,
		    struct ieee80211_node *);
int		rt2661_tx_data(struct rt2661_softc *, struct mbuf *,
		    struct ieee80211_node *, int);
void		rt2661_start(struct ifnet *);
void		rt2661_watchdog(struct ifnet *);
int		rt2661_ioctl(struct ifnet *, u_long, caddr_t);
void		rt2661_bbp_write(struct rt2661_softc *, uint8_t, uint8_t);
uint8_t		rt2661_bbp_read(struct rt2661_softc *, uint8_t);
void		rt2661_rf_write(struct rt2661_softc *, uint8_t, uint32_t);
int		rt2661_tx_cmd(struct rt2661_softc *, uint8_t, uint16_t);
void		rt2661_select_antenna(struct rt2661_softc *);
void		rt2661_enable_mrr(struct rt2661_softc *);
void		rt2661_set_txpreamble(struct rt2661_softc *);
void		rt2661_set_basicrates(struct rt2661_softc *);
void		rt2661_select_band(struct rt2661_softc *,
		    struct ieee80211_channel *);
void		rt2661_set_chan(struct rt2661_softc *,
		    struct ieee80211_channel *);
void		rt2661_set_bssid(struct rt2661_softc *, const uint8_t *);
void		rt2661_set_macaddr(struct rt2661_softc *, const uint8_t *);
void		rt2661_update_promisc(struct rt2661_softc *);
void		rt2661_updateslot(struct ieee80211com *);
void		rt2661_set_slottime(struct rt2661_softc *);
const char	*rt2661_get_rf(int);
void		rt2661_read_eeprom(struct rt2661_softc *);
int		rt2661_bbp_init(struct rt2661_softc *);
int		rt2661_init(struct ifnet *);
void		rt2661_stop(struct ifnet *, int);
int		rt2661_load_microcode(struct rt2661_softc *);
void		rt2661_rx_tune(struct rt2661_softc *);
#ifdef notyet
void		rt2661_radar_start(struct rt2661_softc *);
int		rt2661_radar_stop(struct rt2661_softc *);
#endif
#ifndef IEEE80211_STA_ONLY
int		rt2661_prepare_beacon(struct rt2661_softc *);
#endif
void		rt2661_enable_tsf_sync(struct rt2661_softc *);
int		rt2661_get_rssi(struct rt2661_softc *, uint8_t);
struct		rt2661_amrr_node *rt2661_amrr_node_alloc(struct ieee80211com *,
		    struct rt2661_node *);
void 		rt2661_amrr_node_free(struct rt2661_softc *,
		    struct rt2661_amrr_node *);
void		rt2661_amrr_node_free_all(struct rt2661_softc *);
void		rt2661_amrr_node_free_unused(struct rt2661_softc *);
struct 		rt2661_amrr_node *rt2661_amrr_node_find(struct rt2661_softc *,
		    u_int8_t);

static const struct {
	uint32_t	reg;
	uint32_t	val;
} rt2661_def_mac[] = {
	RT2661_DEF_MAC
};

static const struct {
	uint8_t	reg;
	uint8_t	val;
} rt2661_def_bbp[] = {
	RT2661_DEF_BBP
};

static const struct rfprog {
	uint8_t		chan;
	uint32_t	r1, r2, r3, r4;
}  rt2661_rf5225_1[] = {
	RT2661_RF5225_1
}, rt2661_rf5225_2[] = {
	RT2661_RF5225_2
};

int
rt2661_attach(void *xsc, int id)
{
	struct rt2661_softc *sc = xsc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t val;
	int error, ac, ntries;

	sc->sc_id = id;

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 15;
	timeout_set(&sc->amrr_to, rt2661_updatestats, sc);
	timeout_set(&sc->scan_to, rt2661_next_scan, sc);

	TAILQ_INIT(&sc->amn);

	/* wait for NIC to initialize */
	for (ntries = 0; ntries < 1000; ntries++) {
		if ((val = RAL_READ(sc, RT2661_MAC_CSR0)) != 0)
			break;
		DELAY(1000);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for NIC to initialize\n",
		    sc->sc_dev.dv_xname);
		return EIO;
	}

	/* retrieve RF rev. no and various other things from EEPROM */
	rt2661_read_eeprom(sc);
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	printf("%s: MAC/BBP RT%X, RF %s\n", sc->sc_dev.dv_xname, val,
	    rt2661_get_rf(sc->rf_rev));

	/*
	 * Allocate Tx and Rx rings.
	 */
	for (ac = 0; ac < 4; ac++) {
		error = rt2661_alloc_tx_ring(sc, &sc->txq[ac],
		    RT2661_TX_RING_COUNT);
		if (error != 0) {
			printf("%s: could not allocate Tx ring %d\n",
			    sc->sc_dev.dv_xname, ac);
			goto fail1;
		}
	}

	error = rt2661_alloc_tx_ring(sc, &sc->mgtq, RT2661_MGT_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Mgt ring\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}

	error = rt2661_alloc_rx_ring(sc, &sc->rxq, RT2661_RX_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Rx ring\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}

	config_mountroot(xsc, rt2661_attachhook);

	return 0;

fail2:	rt2661_free_tx_ring(sc, &sc->mgtq);
fail1:	while (--ac >= 0)
		rt2661_free_tx_ring(sc, &sc->txq[ac]);
	return ENXIO;
}

void
rt2661_attachhook(struct device *self)
{
	struct rt2661_softc *sc = (struct rt2661_softc *)self;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	const char *name = NULL;
	int i, error;

	switch (sc->sc_id) {
	case PCI_PRODUCT_RALINK_RT2561:
		name = "ral-rt2561";
		break;
	case PCI_PRODUCT_RALINK_RT2561S:
		name = "ral-rt2561s";
		break;
	case PCI_PRODUCT_RALINK_RT2661:
		name = "ral-rt2661";
		break;
	}
	if ((error = loadfirmware(name, &sc->ucode, &sc->ucsize)) != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, name);
		return;
	}

	ic->ic_phytype = IEEE80211_T_OFDM; /* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA; /* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
#ifndef IEEE80211_STA_ONLY
	    IEEE80211_C_IBSS |		/* IBSS mode supported */
	    IEEE80211_C_HOSTAP |	/* HostAP mode supported */
#endif
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_WEP |		/* s/w WEP */
	    IEEE80211_C_RSN;		/* WPA/RSN */

	if (sc->rf_rev == RT2661_RF_5225 || sc->rf_rev == RT2661_RF_5325) {
		/* set supported .11a rates */
		ic->ic_sup_rates[IEEE80211_MODE_11A] =
		    ieee80211_std_rateset_11a;

		/* set supported .11a channels */
		for (i = 36; i <= 64; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 100; i <= 140; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 149; i <= 165; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
	}

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = rt2661_ioctl;
	ifp->if_start = rt2661_start;
	ifp->if_watchdog = rt2661_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_node_alloc = rt2661_node_alloc;
	sc->sc_node_free = ic->ic_node_free;
	ic->ic_node_free = rt2661_node_free;
	ic->ic_newassoc = rt2661_newassoc;
	ic->ic_updateslot = rt2661_updateslot;

	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = rt2661_newstate;
	ieee80211_media_init(ifp, rt2661_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + 64);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(RT2661_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(RT2661_TX_RADIOTAP_PRESENT);
#endif
}

int
rt2661_detach(void *xsc)
{
	struct rt2661_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int ac;

	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);

	ieee80211_ifdetach(ifp);	/* free all nodes */
	rt2661_amrr_node_free_all(sc);
	if_detach(ifp);

	for (ac = 0; ac < 4; ac++)
		rt2661_free_tx_ring(sc, &sc->txq[ac]);
	rt2661_free_tx_ring(sc, &sc->mgtq);
	rt2661_free_rx_ring(sc, &sc->rxq);

	if (sc->ucode != NULL)
		free(sc->ucode, M_DEVBUF, sc->ucsize);

	return 0;
}

void
rt2661_suspend(void *xsc)
{
	struct rt2661_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (ifp->if_flags & IFF_RUNNING) {
		rt2661_stop(ifp, 1);
		sc->sc_flags &= ~RT2661_FWLOADED;
	}
}

void
rt2661_wakeup(void *xsc)
{
	struct rt2661_softc *sc = xsc;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (ifp->if_flags & IFF_UP)
		rt2661_init(ifp);	
}

int
rt2661_alloc_tx_ring(struct rt2661_softc *sc, struct rt2661_tx_ring *ring,
    int count)
{
	int i, nsegs, error;

	ring->count = count;
	ring->queued = 0;
	ring->cur = ring->next = ring->stat = 0;

	error = bus_dmamap_create(sc->sc_dmat, count * RT2661_TX_DESC_SIZE, 1,
	    count * RT2661_TX_DESC_SIZE, 0, BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, count * RT2661_TX_DESC_SIZE,
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    count * RT2661_TX_DESC_SIZE, (caddr_t *)&ring->desc,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    count * RT2661_TX_DESC_SIZE, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ring->physaddr = ring->map->dm_segs->ds_addr;

	ring->data = mallocarray(count, sizeof (struct rt2661_tx_data),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ring->data == NULL) {
		printf("%s: could not allocate soft data\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}

	for (i = 0; i < count; i++) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    RT2661_MAX_SCATTER, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &ring->data[i].map);
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	return 0;

fail:	rt2661_free_tx_ring(sc, ring);
	return error;
}

void
rt2661_reset_tx_ring(struct rt2661_softc *sc, struct rt2661_tx_ring *ring)
{
	int i;

	for (i = 0; i < ring->count; i++) {
		struct rt2661_tx_desc *desc = &ring->desc[i];
		struct rt2661_tx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}

		/*
		 * The node has already been freed at that point so don't call
		 * ieee80211_release_node() here.
		 */
		data->ni = NULL;

		desc->flags = 0;
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ring->queued = 0;
	ring->cur = ring->next = ring->stat = 0;
}

void
rt2661_free_tx_ring(struct rt2661_softc *sc, struct rt2661_tx_ring *ring)
{
	int i;

	if (ring->desc != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    ring->count * RT2661_TX_DESC_SIZE);
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}

	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			struct rt2661_tx_data *data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    data->map->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}
			/*
			 * The node has already been freed at that point so
			 * don't call ieee80211_release_node() here.
			 */
			data->ni = NULL;

			if (data->map != NULL)
				bus_dmamap_destroy(sc->sc_dmat, data->map);
		}
		free(ring->data, M_DEVBUF, ring->count * sizeof *ring->data);
	}
}

int
rt2661_alloc_rx_ring(struct rt2661_softc *sc, struct rt2661_rx_ring *ring,
    int count)
{
	int i, nsegs, error;

	ring->count = count;
	ring->cur = ring->next = 0;

	error = bus_dmamap_create(sc->sc_dmat, count * RT2661_RX_DESC_SIZE, 1,
	    count * RT2661_RX_DESC_SIZE, 0, BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, count * RT2661_RX_DESC_SIZE,
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    count * RT2661_RX_DESC_SIZE, (caddr_t *)&ring->desc,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    count * RT2661_RX_DESC_SIZE, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load desc DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ring->physaddr = ring->map->dm_segs->ds_addr;

	ring->data = mallocarray(count, sizeof (struct rt2661_rx_data),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ring->data == NULL) {
		printf("%s: could not allocate soft data\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}

	/*
	 * Pre-allocate Rx buffers and populate Rx ring.
	 */
	for (i = 0; i < count; i++) {
		struct rt2661_rx_desc *desc = &sc->rxq.desc[i];
		struct rt2661_rx_data *data = &sc->rxq.data[i];

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &data->map);
		if (error != 0) {
			printf("%s: could not create DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: could not load rx buf DMA map",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		desc->flags = htole32(RT2661_RX_BUSY);
		desc->physaddr = htole32(data->map->dm_segs->ds_addr);
	}

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	return 0;

fail:	rt2661_free_rx_ring(sc, ring);
	return error;
}

void
rt2661_reset_rx_ring(struct rt2661_softc *sc, struct rt2661_rx_ring *ring)
{
	int i;

	for (i = 0; i < ring->count; i++)
		ring->desc[i].flags = htole32(RT2661_RX_BUSY);

	bus_dmamap_sync(sc->sc_dmat, ring->map, 0, ring->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	ring->cur = ring->next = 0;
}

void
rt2661_free_rx_ring(struct rt2661_softc *sc, struct rt2661_rx_ring *ring)
{
	int i;

	if (ring->desc != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ring->map, 0,
		    ring->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    ring->count * RT2661_RX_DESC_SIZE);
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}

	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			struct rt2661_rx_data *data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    data->map->dm_mapsize,
				    BUS_DMASYNC_POSTREAD);
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}

			if (data->map != NULL)
				bus_dmamap_destroy(sc->sc_dmat, data->map);
		}
		free(ring->data, M_DEVBUF, ring->count * sizeof *ring->data);
	}
}

struct rt2661_amrr_node *
rt2661_amrr_node_alloc(struct ieee80211com *ic, struct rt2661_node *rn)
{
	struct rt2661_softc *sc = ic->ic_softc;
	struct rt2661_amrr_node *amn;
	int s;

	if (sc->amn_count >= RT2661_AMRR_NODES_MAX)
		rt2661_amrr_node_free_unused(sc);
	if (sc->amn_count >= RT2661_AMRR_NODES_MAX)
		return NULL;

	amn = malloc(sizeof (struct rt2661_amrr_node), M_DEVBUF,
	    M_NOWAIT | M_ZERO);

	if (amn) {
		s = splnet();
		amn->id = sc->amn_count++;
		amn->rn = rn;
		TAILQ_INSERT_TAIL(&sc->amn, amn, entry);
		splx(s);
	}

	return amn;
}

void
rt2661_amrr_node_free(struct rt2661_softc *sc, struct rt2661_amrr_node *amn)
{
	int s;

	s = splnet();
	if (amn->rn)
		amn->rn->amn = NULL;
	TAILQ_REMOVE(&sc->amn, amn, entry);
	sc->amn_count--;
	splx(s);
	free(amn, M_DEVBUF, sizeof *amn);
}

void
rt2661_amrr_node_free_all(struct rt2661_softc *sc)
{
	struct rt2661_amrr_node *amn, *a;
	int s;

	s = splnet();
	TAILQ_FOREACH_SAFE(amn, &sc->amn, entry, a)
		rt2661_amrr_node_free(sc, amn);
	splx(s);
}

void
rt2661_amrr_node_free_unused(struct rt2661_softc *sc)
{
	struct rt2661_amrr_node *amn, *a;
	int s;

	s = splnet();
	TAILQ_FOREACH_SAFE(amn, &sc->amn, entry, a) {
		if (amn->rn == NULL)
			rt2661_amrr_node_free(sc, amn);
	}
	splx(s);
}

struct rt2661_amrr_node *
rt2661_amrr_node_find(struct rt2661_softc *sc, u_int8_t id)
{
	struct rt2661_amrr_node *amn, *a, *ret = NULL;
	int s;

	if (id == RT2661_AMRR_INVALID_ID)
		return NULL;

	s = splnet();
	TAILQ_FOREACH_SAFE(amn, &sc->amn, entry, a) {
		/* If the corresponding node was freed, free the amrr node. */
		if (amn->rn == NULL)
			rt2661_amrr_node_free(sc, amn);
		else if (amn->id == id)
			ret = amn;
	}
	splx(s);

	return ret;
}

struct ieee80211_node *
rt2661_node_alloc(struct ieee80211com *ic)
{
	struct rt2661_node *rn;

	rn = malloc(sizeof (struct rt2661_node), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (rn == NULL)
		return NULL;

	rn->amn = rt2661_amrr_node_alloc(ic, rn);
	return (struct ieee80211_node *)rn;
}

void
rt2661_node_free(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct rt2661_softc *sc = ic->ic_softc;
	struct rt2661_node *rn = (struct rt2661_node *)ni;

	if (rn->amn)
		rn->amn->rn = NULL;
	sc->sc_node_free(ic, ni);
}

int
rt2661_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		rt2661_init(ifp);

	return 0;
}

/*
 * This function is called periodically (every 200ms) during scanning to
 * switch from one channel to another.
 */
void
rt2661_next_scan(void *arg)
{
	struct rt2661_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	s = splnet();
	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
	splx(s);
}

/*
 * This function is called for each neighbor node.
 */
void
rt2661_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct rt2661_softc *sc = arg;
	struct rt2661_node *rn = (struct rt2661_node *)ni;

	if (rn->amn)
		ieee80211_amrr_choose(&sc->amrr, ni, &rn->amn->amn);
}

/*
 * This function is called periodically (every 500ms) in RUN state to update
 * various settings like rate control statistics or Rx sensitivity.
 */
void
rt2661_updatestats(void *arg)
{
	struct rt2661_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	s = splnet();
	if (ic->ic_opmode == IEEE80211_M_STA)
		rt2661_iter_func(sc, ic->ic_bss);
	else
		ieee80211_iterate_nodes(ic, rt2661_iter_func, arg);

	/* update rx sensitivity and free unused amrr nodes every 1 sec */
	if (++sc->ncalls & 1) {
		rt2661_rx_tune(sc);
		rt2661_amrr_node_free_unused(sc);
	}
	splx(s);

	timeout_add_msec(&sc->amrr_to, 500);
}

void
rt2661_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct rt2661_softc *sc = ic->ic_softc;
	struct rt2661_node *rn = (struct rt2661_node *)ni;
	int i;

	if (rn->amn)
		ieee80211_amrr_node_init(&sc->amrr, &rn->amn->amn);

	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;
}

int
rt2661_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct rt2661_softc *sc = ic->ic_if.if_softc;
	enum ieee80211_state ostate;
	struct ieee80211_node *ni;
	uint32_t tmp;

	ostate = ic->ic_state;
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);

	switch (nstate) {
	case IEEE80211_S_INIT:
		if (ostate == IEEE80211_S_RUN) {
			/* abort TSF synchronization */
			tmp = RAL_READ(sc, RT2661_TXRX_CSR9);
			RAL_WRITE(sc, RT2661_TXRX_CSR9, tmp & ~0x00ffffff);
		}
		break;

	case IEEE80211_S_SCAN:
		rt2661_set_chan(sc, ic->ic_bss->ni_chan);
		timeout_add_msec(&sc->scan_to, 200);
		break;

	case IEEE80211_S_AUTH:
	case IEEE80211_S_ASSOC:
		rt2661_set_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_RUN:
		rt2661_set_chan(sc, ic->ic_bss->ni_chan);

		ni = ic->ic_bss;

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			rt2661_set_slottime(sc);
			rt2661_enable_mrr(sc);
			rt2661_set_txpreamble(sc);
			rt2661_set_basicrates(sc);
			rt2661_set_bssid(sc, ni->ni_bssid);
		}

#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
		    ic->ic_opmode == IEEE80211_M_IBSS)
			rt2661_prepare_beacon(sc);
#endif

		if (ic->ic_opmode == IEEE80211_M_STA) {
			/* fake a join to init the tx rate */
			rt2661_newassoc(ic, ni, 1);
		}

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			sc->ncalls = 0;
			sc->avg_rssi = -95;	/* reset EMA */
			timeout_add_msec(&sc->amrr_to, 500);
			rt2661_enable_tsf_sync(sc);
		}
		break;
	}

	return sc->sc_newstate(ic, nstate, arg);
}

/*
 * Read 16 bits at address 'addr' from the serial EEPROM (either 93C46 or
 * 93C66).
 */
uint16_t
rt2661_eeprom_read(struct rt2661_softc *sc, uint8_t addr)
{
	uint32_t tmp;
	uint16_t val;
	int n;

	/* clock C once before the first command */
	RT2661_EEPROM_CTL(sc, 0);

	RT2661_EEPROM_CTL(sc, RT2661_S);
	RT2661_EEPROM_CTL(sc, RT2661_S | RT2661_C);
	RT2661_EEPROM_CTL(sc, RT2661_S);

	/* write start bit (1) */
	RT2661_EEPROM_CTL(sc, RT2661_S | RT2661_D);
	RT2661_EEPROM_CTL(sc, RT2661_S | RT2661_D | RT2661_C);

	/* write READ opcode (10) */
	RT2661_EEPROM_CTL(sc, RT2661_S | RT2661_D);
	RT2661_EEPROM_CTL(sc, RT2661_S | RT2661_D | RT2661_C);
	RT2661_EEPROM_CTL(sc, RT2661_S);
	RT2661_EEPROM_CTL(sc, RT2661_S | RT2661_C);

	/* write address (A5-A0 or A7-A0) */
	n = (RAL_READ(sc, RT2661_E2PROM_CSR) & RT2661_93C46) ? 5 : 7;
	for (; n >= 0; n--) {
		RT2661_EEPROM_CTL(sc, RT2661_S |
		    (((addr >> n) & 1) << RT2661_SHIFT_D));
		RT2661_EEPROM_CTL(sc, RT2661_S |
		    (((addr >> n) & 1) << RT2661_SHIFT_D) | RT2661_C);
	}

	RT2661_EEPROM_CTL(sc, RT2661_S);

	/* read data Q15-Q0 */
	val = 0;
	for (n = 15; n >= 0; n--) {
		RT2661_EEPROM_CTL(sc, RT2661_S | RT2661_C);
		tmp = RAL_READ(sc, RT2661_E2PROM_CSR);
		val |= ((tmp & RT2661_Q) >> RT2661_SHIFT_Q) << n;
		RT2661_EEPROM_CTL(sc, RT2661_S);
	}

	RT2661_EEPROM_CTL(sc, 0);

	/* clear Chip Select and clock C */
	RT2661_EEPROM_CTL(sc, RT2661_S);
	RT2661_EEPROM_CTL(sc, 0);
	RT2661_EEPROM_CTL(sc, RT2661_C);

	return val;
}

/* The TX interrupt handler accumulates statistics based on whether frames
 * were sent successfully by the ASIC. */
void
rt2661_tx_intr(struct rt2661_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct rt2661_amrr_node *amn;
	int retrycnt;
	u_int8_t amrr_id;

	for (;;) {
		const uint32_t val = RAL_READ(sc, RT2661_STA_CSR4);
		if (!(val & RT2661_TX_STAT_VALID))
			break;

		/* retrieve rate control algorithm context */
		amrr_id = RT2661_TX_PRIV_DATA(val);
		amn = rt2661_amrr_node_find(sc, amrr_id);

		switch (RT2661_TX_RESULT(val)) {
		case RT2661_TX_SUCCESS:
			retrycnt = RT2661_TX_RETRYCNT(val);

			DPRINTFN(10, ("data frame sent successfully after "
			    "%d retries\n", retrycnt));
			if (amn) {
				amn->amn.amn_txcnt++;
				if (retrycnt > 0)
					amn->amn.amn_retrycnt++;
			}
			break;

		case RT2661_TX_RETRY_FAIL:
			DPRINTFN(9, ("sending data frame failed (too much "
			    "retries)\n"));
			if (amn) {
				amn->amn.amn_txcnt++;
				amn->amn.amn_retrycnt++;
			}
			ifp->if_oerrors++;
			break;

		default:
			/* other failure */
			printf("%s: sending data frame failed 0x%08x\n",
			    sc->sc_dev.dv_xname, val);
			ifp->if_oerrors++;
		}

		DPRINTFN(15, ("tx done amrr_id=%hhu amn=0x%x\n", amrr_id, amn));
	}
}

/* The TX DMA interrupt handler processes frames which have been offloaded
 * to the ASIC for transmission. We can free all resources corresponding
 * to the frame here. */
void
rt2661_tx_dma_intr(struct rt2661_softc *sc, struct rt2661_tx_ring *txq)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	for (;;) {
		struct rt2661_tx_desc *desc = &txq->desc[txq->next];
		struct rt2661_tx_data *data = &txq->data[txq->next];

		bus_dmamap_sync(sc->sc_dmat, txq->map,
		    txq->next * RT2661_TX_DESC_SIZE, RT2661_TX_DESC_SIZE,
		    BUS_DMASYNC_POSTREAD);

		if ((letoh32(desc->flags) & RT2661_TX_BUSY) ||
		    !(letoh32(desc->flags) & RT2661_TX_VALID))
			break;

		/* descriptor is no longer valid */
		desc->flags &= ~htole32(RT2661_TX_VALID);

		bus_dmamap_sync(sc->sc_dmat, txq->map,
		    txq->next * RT2661_TX_DESC_SIZE, RT2661_TX_DESC_SIZE,
		    BUS_DMASYNC_PREWRITE);

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		data->m = NULL;
		ieee80211_release_node(ic, data->ni);
		data->ni = NULL;

		DPRINTFN(15, ("tx dma done q=%p idx=%u\n", txq, txq->next));

		txq->queued--;
		if (++txq->next >= txq->count)	/* faster than % count */
			txq->next = 0;
	}

	if (sc->mgtq.queued == 0 && sc->txq[0].queued == 0)
		sc->sc_tx_timer = 0;
	if (sc->mgtq.queued < RT2661_MGT_RING_COUNT &&
	    sc->txq[0].queued < RT2661_TX_RING_COUNT - 1) {
		if (sc->mgtq.queued < RT2661_MGT_RING_COUNT)
			sc->sc_flags &= ~RT2661_MGT_OACTIVE;
		if (sc->txq[0].queued < RT2661_TX_RING_COUNT - 1)
			sc->sc_flags &= ~RT2661_DATA_OACTIVE;
		if (!(sc->sc_flags & (RT2661_MGT_OACTIVE|RT2661_DATA_OACTIVE)))
			ifq_clr_oactive(&ifp->if_snd);
		rt2661_start(ifp);
	}
}

void
rt2661_rx_intr(struct rt2661_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *mnew, *m;
	int error, rssi;

	for (;;) {
		struct rt2661_rx_desc *desc = &sc->rxq.desc[sc->rxq.cur];
		struct rt2661_rx_data *data = &sc->rxq.data[sc->rxq.cur];

		bus_dmamap_sync(sc->sc_dmat, sc->rxq.map,
		    sc->rxq.cur * RT2661_RX_DESC_SIZE, RT2661_RX_DESC_SIZE,
		    BUS_DMASYNC_POSTREAD);

		if (letoh32(desc->flags) & RT2661_RX_BUSY)
			break;

		if ((letoh32(desc->flags) & RT2661_RX_PHY_ERROR) ||
		    (letoh32(desc->flags) & RT2661_RX_CRC_ERROR)) {
			/*
			 * This should not happen since we did not request
			 * to receive those frames when we filled TXRX_CSR0.
			 */
			DPRINTFN(5, ("PHY or CRC error flags 0x%08x\n",
			    letoh32(desc->flags)));
			ifp->if_ierrors++;
			goto skip;
		}

		if ((letoh32(desc->flags) & RT2661_RX_CIPHER_MASK) != 0) {
			ifp->if_ierrors++;
			goto skip;
		}

		/*
		 * Try to allocate a new mbuf for this ring element and load it
		 * before processing the current mbuf. If the ring element
		 * cannot be loaded, drop the received packet and reuse the old
		 * mbuf. In the unlikely case that the old mbuf can't be
		 * reloaded either, explicitly panic.
		 */
		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
			ifp->if_ierrors++;
			goto skip;
		}
		MCLGET(mnew, M_DONTWAIT);
		if (!(mnew->m_flags & M_EXT)) {
			m_freem(mnew);
			ifp->if_ierrors++;
			goto skip;
		}

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmat, data->map);

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(mnew, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			m_freem(mnew);

			/* try to reload the old mbuf */
			error = bus_dmamap_load(sc->sc_dmat, data->map,
			    mtod(data->m, void *), MCLBYTES, NULL,
			    BUS_DMA_NOWAIT);
			if (error != 0) {
				/* very unlikely that it will fail... */
				panic("%s: could not load old rx mbuf",
				    sc->sc_dev.dv_xname);
			}
			/* physical address may have changed */
			desc->physaddr = htole32(data->map->dm_segs->ds_addr);
			ifp->if_ierrors++;
			goto skip;
		}

		/*
	 	 * New mbuf successfully loaded, update Rx ring and continue
		 * processing.
		 */
		m = data->m;
		data->m = mnew;
		desc->physaddr = htole32(data->map->dm_segs->ds_addr);

		/* finalize mbuf */
		m->m_pkthdr.len = m->m_len =
		    (letoh32(desc->flags) >> 16) & 0xfff;

#if NBPFILTER > 0
		if (sc->sc_drvbpf != NULL) {
			struct mbuf mb;
			struct rt2661_rx_radiotap_header *tap = &sc->sc_rxtap;
			uint32_t tsf_lo, tsf_hi;

			/* get timestamp (low and high 32 bits) */
			tsf_hi = RAL_READ(sc, RT2661_TXRX_CSR13);
			tsf_lo = RAL_READ(sc, RT2661_TXRX_CSR12);

			tap->wr_tsf =
			    htole64(((uint64_t)tsf_hi << 32) | tsf_lo);
			tap->wr_flags = 0;
			tap->wr_rate = rt2661_rxrate(desc);
			tap->wr_chan_freq = htole16(sc->sc_curchan->ic_freq);
			tap->wr_chan_flags = htole16(sc->sc_curchan->ic_flags);
			tap->wr_antsignal = desc->rssi;

			mb.m_data = (caddr_t)tap;
			mb.m_len = sc->sc_rxtap_len;
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
		}
#endif

		wh = mtod(m, struct ieee80211_frame *);
		ni = ieee80211_find_rxnode(ic, wh);

		/* send the frame to the 802.11 layer */
		rxi.rxi_flags = 0;
		rxi.rxi_rssi = desc->rssi;
		rxi.rxi_tstamp = 0;	/* unused */
		ieee80211_input(ifp, m, ni, &rxi);

		/*-
		 * Keep track of the average RSSI using an Exponential Moving
		 * Average (EMA) of 8 Wilder's days:
		 *     avg = (1 / N) x rssi + ((N - 1) / N) x avg
		 */
		rssi = rt2661_get_rssi(sc, desc->rssi);
		sc->avg_rssi = (rssi + 7 * sc->avg_rssi) / 8;

		/* node is no longer needed */
		ieee80211_release_node(ic, ni);

skip:		desc->flags |= htole32(RT2661_RX_BUSY);

		bus_dmamap_sync(sc->sc_dmat, sc->rxq.map,
		    sc->rxq.cur * RT2661_RX_DESC_SIZE, RT2661_RX_DESC_SIZE,
		    BUS_DMASYNC_PREWRITE);

		DPRINTFN(15, ("rx intr idx=%u\n", sc->rxq.cur));

		sc->rxq.cur = (sc->rxq.cur + 1) % RT2661_RX_RING_COUNT;
	}
}

#ifndef IEEE80211_STA_ONLY
/*
 * This function is called in HostAP or IBSS modes when it's time to send a
 * new beacon (every ni_intval milliseconds).
 */
void
rt2661_mcu_beacon_expire(struct rt2661_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	if (sc->sc_flags & RT2661_UPDATE_SLOT) {
		sc->sc_flags &= ~RT2661_UPDATE_SLOT;
		sc->sc_flags |= RT2661_SET_SLOTTIME;
	} else if (sc->sc_flags & RT2661_SET_SLOTTIME) {
		sc->sc_flags &= ~RT2661_SET_SLOTTIME;
		rt2661_set_slottime(sc);
	}

	if (ic->ic_curmode == IEEE80211_MODE_11G) {
		/* update ERP Information Element */
		RAL_WRITE_1(sc, sc->erp_csr, ic->ic_bss->ni_erp);
		RAL_RW_BARRIER_1(sc, sc->erp_csr);
	}

	DPRINTFN(15, ("beacon expired\n"));
}
#endif

void
rt2661_mcu_wakeup(struct rt2661_softc *sc)
{
	RAL_WRITE(sc, RT2661_MAC_CSR11, 5 << 16);

	RAL_WRITE(sc, RT2661_SOFT_RESET_CSR, 0x7);
	RAL_WRITE(sc, RT2661_IO_CNTL_CSR, 0x18);
	RAL_WRITE(sc, RT2661_PCI_USEC_CSR, 0x20);

	/* send wakeup command to MCU */
	rt2661_tx_cmd(sc, RT2661_MCU_CMD_WAKEUP, 0);
}

void
rt2661_mcu_cmd_intr(struct rt2661_softc *sc)
{
	RAL_READ(sc, RT2661_M2H_CMD_DONE_CSR);
	RAL_WRITE(sc, RT2661_M2H_CMD_DONE_CSR, 0xffffffff);
}

int
rt2661_intr(void *arg)
{
	struct rt2661_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t r1, r2;

	r1 = RAL_READ(sc, RT2661_INT_SOURCE_CSR);
	r2 = RAL_READ(sc, RT2661_MCU_INT_SOURCE_CSR);
	if (__predict_false(r1 == 0xffffffff && r2 == 0xffffffff))
		return 0;	/* device likely went away */
	if (r1 == 0 && r2 == 0)
		return 0;	/* not for us */

	/* disable MAC and MCU interrupts */
	RAL_WRITE(sc, RT2661_INT_MASK_CSR, 0xffffff7f);
	RAL_WRITE(sc, RT2661_MCU_INT_MASK_CSR, 0xffffffff);

	/* acknowledge interrupts */
	RAL_WRITE(sc, RT2661_INT_SOURCE_CSR, r1);
	RAL_WRITE(sc, RT2661_MCU_INT_SOURCE_CSR, r2);

	/* don't re-enable interrupts if we're shutting down */
	if (!(ifp->if_flags & IFF_RUNNING))
		return 0;

	if (r1 & RT2661_MGT_DONE)
		rt2661_tx_dma_intr(sc, &sc->mgtq);

	if (r1 & RT2661_RX_DONE)
		rt2661_rx_intr(sc);

	if (r1 & RT2661_TX0_DMA_DONE)
		rt2661_tx_dma_intr(sc, &sc->txq[0]);

	if (r1 & RT2661_TX1_DMA_DONE)
		rt2661_tx_dma_intr(sc, &sc->txq[1]);

	if (r1 & RT2661_TX2_DMA_DONE)
		rt2661_tx_dma_intr(sc, &sc->txq[2]);

	if (r1 & RT2661_TX3_DMA_DONE)
		rt2661_tx_dma_intr(sc, &sc->txq[3]);

	if (r1 & RT2661_TX_DONE)
		rt2661_tx_intr(sc);

	if (r2 & RT2661_MCU_CMD_DONE)
		rt2661_mcu_cmd_intr(sc);

#ifndef IEEE80211_STA_ONLY
	if (r2 & RT2661_MCU_BEACON_EXPIRE)
		rt2661_mcu_beacon_expire(sc);
#endif

	if (r2 & RT2661_MCU_WAKEUP)
		rt2661_mcu_wakeup(sc);

	/* re-enable MAC and MCU interrupts */
	RAL_WRITE(sc, RT2661_INT_MASK_CSR, 0x0000ff10);
	RAL_WRITE(sc, RT2661_MCU_INT_MASK_CSR, 0);

	return 1;
}

/* quickly determine if a given rate is CCK or OFDM */
#define RAL_RATE_IS_OFDM(rate) ((rate) >= 12 && (rate) != 22)

#define RAL_ACK_SIZE	14	/* 10 + 4(FCS) */
#define RAL_CTS_SIZE	14	/* 10 + 4(FCS) */

/*
 * This function is only used by the Rx radiotap code. It returns the rate at
 * which a given frame was received.
 */
#if NBPFILTER > 0
uint8_t
rt2661_rxrate(const struct rt2661_rx_desc *desc)
{
	if (letoh32(desc->flags) & RT2661_RX_OFDM) {
		/* reverse function of rt2661_plcp_signal */
		switch (desc->rate & 0xf) {
		case 0xb:	return 12;
		case 0xf:	return 18;
		case 0xa:	return 24;
		case 0xe:	return 36;
		case 0x9:	return 48;
		case 0xd:	return 72;
		case 0x8:	return 96;
		case 0xc:	return 108;
		}
	} else {
		if (desc->rate == 10)
			return 2;
		if (desc->rate == 20)
			return 4;
		if (desc->rate == 55)
			return 11;
		if (desc->rate == 110)
			return 22;
	}
	return 2;	/* should not get there */
}
#endif

/*
 * Return the expected ack rate for a frame transmitted at rate `rate'.
 */
int
rt2661_ack_rate(struct ieee80211com *ic, int rate)
{
	switch (rate) {
	/* CCK rates */
	case 2:
		return 2;
	case 4:
	case 11:
	case 22:
		return (ic->ic_curmode == IEEE80211_MODE_11B) ? 4 : rate;

	/* OFDM rates */
	case 12:
	case 18:
		return 12;
	case 24:
	case 36:
		return 24;
	case 48:
	case 72:
	case 96:
	case 108:
		return 48;
	}

	/* default to 1Mbps */
	return 2;
}

/*
 * Compute the duration (in us) needed to transmit `len' bytes at rate `rate'.
 * The function automatically determines the operating mode depending on the
 * given rate. `flags' indicates whether short preamble is in use or not.
 */
uint16_t
rt2661_txtime(int len, int rate, uint32_t flags)
{
	uint16_t txtime;

	if (RAL_RATE_IS_OFDM(rate)) {
		/* IEEE Std 802.11g-2003, pp. 44 */
		txtime = (8 + 4 * len + 3 + rate - 1) / rate;
		txtime = 16 + 4 + 4 * txtime + 6;
	} else {
		/* IEEE Std 802.11b-1999, pp. 28 */
		txtime = (16 * len + rate - 1) / rate;
		if (rate != 2 && (flags & IEEE80211_F_SHPREAMBLE))
			txtime +=  72 + 24;
		else
			txtime += 144 + 48;
	}
	return txtime;
}

uint8_t
rt2661_plcp_signal(int rate)
{
	switch (rate) {
	/* CCK rates (returned values are device-dependent) */
	case 2:		return 0x0;
	case 4:		return 0x1;
	case 11:	return 0x2;
	case 22:	return 0x3;

	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
	case 12:	return 0xb;
	case 18:	return 0xf;
	case 24:	return 0xa;
	case 36:	return 0xe;
	case 48:	return 0x9;
	case 72:	return 0xd;
	case 96:	return 0x8;
	case 108:	return 0xc;

	/* unsupported rates (should not get there) */
	default:	return 0xff;
	}
}

void
rt2661_setup_tx_desc(struct rt2661_softc *sc, struct rt2661_tx_desc *desc,
    uint32_t flags, uint16_t xflags, int len, int rate,
    const bus_dma_segment_t *segs, int nsegs, int ac, u_int8_t amrr_id)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t plcp_length;
	int i, remainder;

	desc->flags = htole32(flags);
	desc->flags |= htole32(len << 16);
	desc->flags |= htole32(RT2661_TX_BUSY | RT2661_TX_VALID);

	desc->xflags = htole16(xflags);
	desc->xflags |= htole16(nsegs << 13);

	desc->wme = htole16(
	    RT2661_QID(ac) |
	    RT2661_AIFSN(2) |
	    RT2661_LOGCWMIN(4) |
	    RT2661_LOGCWMAX(10));

	/*
	 * Remember the ID of the AMRR node to update when Tx completes.
	 * This field is driver private data only. It will be made available
	 * by the NIC in STA_CSR4 on Tx interrupts.
	 */
	desc->priv_data = amrr_id;

	/* setup PLCP fields */
	desc->plcp_signal  = rt2661_plcp_signal(rate);
	desc->plcp_service = 4;

	len += IEEE80211_CRC_LEN;
	if (RAL_RATE_IS_OFDM(rate)) {
		desc->flags |= htole32(RT2661_TX_OFDM);

		plcp_length = len & 0xfff;
		desc->plcp_length_hi = plcp_length >> 6;
		desc->plcp_length_lo = plcp_length & 0x3f;
	} else {
		plcp_length = (16 * len + rate - 1) / rate;
		if (rate == 22) {
			remainder = (16 * len) % 22;
			if (remainder != 0 && remainder < 7)
				desc->plcp_service |= RT2661_PLCP_LENGEXT;
		}
		desc->plcp_length_hi = plcp_length >> 8;
		desc->plcp_length_lo = plcp_length & 0xff;

		if (rate != 2 && (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
			desc->plcp_signal |= 0x08;
	}

	/* RT2x61 supports scatter with up to 5 segments */
	for (i = 0; i < nsegs; i++) {
		desc->addr[i] = htole32(segs[i].ds_addr);
		desc->len [i] = htole16(segs[i].ds_len);
	}
}

int
rt2661_tx_mgt(struct rt2661_softc *sc, struct mbuf *m0,
    struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rt2661_tx_desc *desc;
	struct rt2661_tx_data *data;
	struct ieee80211_frame *wh;
	uint16_t dur;
	uint32_t flags = 0;
	int rate, error;

	desc = &sc->mgtq.desc[sc->mgtq.cur];
	data = &sc->mgtq.data[sc->mgtq.cur];

	/* send mgt frames at the lowest available rate */
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return error;
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct rt2661_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(sc->sc_curchan->ic_freq);
		tap->wt_chan_flags = htole16(sc->sc_curchan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	data->m = m0;
	data->ni = ni;

	wh = mtod(m0, struct ieee80211_frame *);

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RT2661_TX_NEED_ACK;

		dur = rt2661_txtime(RAL_ACK_SIZE, rate, ic->ic_flags) +
		    sc->sifs;
		*(uint16_t *)wh->i_dur = htole16(dur);

#ifndef IEEE80211_STA_ONLY
		/* tell hardware to set timestamp in probe responses */
		if ((wh->i_fc[0] &
		    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
		    (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
			flags |= RT2661_TX_TIMESTAMP;
#endif
	}

	rt2661_setup_tx_desc(sc, desc, flags, 0 /* XXX HWSEQ */,
	    m0->m_pkthdr.len, rate, data->map->dm_segs, data->map->dm_nsegs,
	    RT2661_QID_MGT, RT2661_AMRR_INVALID_ID);

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->mgtq.map,
	    sc->mgtq.cur * RT2661_TX_DESC_SIZE, RT2661_TX_DESC_SIZE,
	    BUS_DMASYNC_PREWRITE);

	DPRINTFN(10, ("sending mgt frame len=%u idx=%u rate=%u\n",
	    m0->m_pkthdr.len, sc->mgtq.cur, rate));

	/* kick mgt */
	sc->mgtq.queued++;
	sc->mgtq.cur = (sc->mgtq.cur + 1) % RT2661_MGT_RING_COUNT;
	RAL_WRITE(sc, RT2661_TX_CNTL_CSR, RT2661_KICK_MGT);

	return 0;
}

int
rt2661_tx_data(struct rt2661_softc *sc, struct mbuf *m0,
    struct ieee80211_node *ni, int ac)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rt2661_tx_ring *txq = &sc->txq[ac];
	struct rt2661_node *rn;
	struct rt2661_tx_desc *desc;
	struct rt2661_tx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct mbuf *m1;
	uint16_t dur;
	uint32_t flags = 0;
	int pktlen, rate, needcts = 0, needrts = 0, error;

	rn = ((ni == ic->ic_bss) ? NULL : (struct rt2661_node *)ni);
	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

	/* compute actual packet length (including CRC and crypto overhead) */
	pktlen = m0->m_pkthdr.len + IEEE80211_CRC_LEN;

	/* pickup a rate */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* multicast frames are sent at the lowest avail. rate */
		rate = ni->ni_rates.rs_rates[0];
	} else if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
	} else
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	if (rate == 0)
		rate = 2;	/* XXX should not happen */
	rate &= IEEE80211_RATE_VAL;

	/*
	 * Packet Bursting: backoff after ppb=8 frames to give other STAs a
	 * chance to contend for the wireless medium.
	 */
	if (ic->ic_opmode == IEEE80211_M_STA && (ni->ni_txseq & 7))
		flags |= RT2661_TX_IFS_SIFS;

	/* check if RTS/CTS or CTS-to-self protection must be used */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* multicast frames are not sent at OFDM rates in 802.11b/g */
		if (pktlen > ic->ic_rtsthreshold) {
			needrts = 1;	/* RTS/CTS based on frame length */
		} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
		    RAL_RATE_IS_OFDM(rate)) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				needcts = 1;	/* CTS-to-self */
			else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				needrts = 1;	/* RTS/CTS */
		}
	}
	if (needrts || needcts) {
		struct mbuf *mprot;
		int protrate, ackrate;

		protrate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;
		ackrate  = rt2661_ack_rate(ic, rate);

		dur = rt2661_txtime(pktlen, rate, ic->ic_flags) +
		      rt2661_txtime(RAL_ACK_SIZE, ackrate, ic->ic_flags) +
		      2 * sc->sifs;
		if (needrts) {
			dur += rt2661_txtime(RAL_CTS_SIZE, rt2661_ack_rate(ic,
			    protrate), ic->ic_flags) + sc->sifs;
			mprot = ieee80211_get_rts(ic, wh, dur);
		} else {
			mprot = ieee80211_get_cts_to_self(ic, dur);
		}
		if (mprot == NULL) {
			printf("%s: could not allocate protection frame\n",
			    sc->sc_dev.dv_xname);
			m_freem(m0);
			return ENOBUFS;
		}

		desc = &txq->desc[txq->cur];
		data = &txq->data[txq->cur];

		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, mprot,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(mprot);
			m_freem(m0);
			return error;
		}

		data->m = mprot;
		/* avoid multiple free() of the same node for each fragment */
		data->ni = ieee80211_ref_node(ni);

		/* XXX may want to pass the protection frame to BPF */

		rt2661_setup_tx_desc(sc, desc,
		    (needrts ? RT2661_TX_NEED_ACK : 0) | RT2661_TX_MORE_FRAG,
		    0, mprot->m_pkthdr.len, protrate, data->map->dm_segs,
		    data->map->dm_nsegs, ac,
	    	    (rn && rn->amn) ? rn->amn->id : RT2661_AMRR_INVALID_ID);

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, txq->map,
		    txq->cur * RT2661_TX_DESC_SIZE, RT2661_TX_DESC_SIZE,
		    BUS_DMASYNC_PREWRITE);

		txq->queued++;
		txq->cur = (txq->cur + 1) % RT2661_TX_RING_COUNT;

		flags |= RT2661_TX_LONG_RETRY | RT2661_TX_IFS_SIFS;
	}

	data = &txq->data[txq->cur];
	desc = &txq->desc[txq->cur];

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0 && error != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return error;
	}
	if (error != 0) {
		/* too many fragments, linearize */
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
			m_freem(m0);
			return ENOBUFS;
		}
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(m1);
				return ENOBUFS;
			}
		}
		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_pkthdr.len = m1->m_len = m0->m_pkthdr.len;
		m_freem(m0);
		m0 = m1;

		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m0);
			return error;
		}

		/* packet header have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct rt2661_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(sc->sc_curchan->ic_freq);
		tap->wt_chan_flags = htole16(sc->sc_curchan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	data->m = m0;
	data->ni = ni;

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RT2661_TX_NEED_ACK;

		dur = rt2661_txtime(RAL_ACK_SIZE, rt2661_ack_rate(ic, rate),
		    ic->ic_flags) + sc->sifs;
		*(uint16_t *)wh->i_dur = htole16(dur);
	}

	rt2661_setup_tx_desc(sc, desc, flags, 0, m0->m_pkthdr.len, rate,
	    data->map->dm_segs, data->map->dm_nsegs, ac,
	    (rn && rn->amn) ? rn->amn->id : RT2661_AMRR_INVALID_ID);

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, txq->map, txq->cur * RT2661_TX_DESC_SIZE,
	    RT2661_TX_DESC_SIZE, BUS_DMASYNC_PREWRITE);

	DPRINTFN(10, ("sending data frame len=%u idx=%u rate=%u\n",
	    m0->m_pkthdr.len, txq->cur, rate));

	/* kick Tx */
	txq->queued++;
	txq->cur = (txq->cur + 1) % RT2661_TX_RING_COUNT;
	RAL_WRITE(sc, RT2661_TX_CNTL_CSR, 1);

	return 0;
}

void
rt2661_start(struct ifnet *ifp)
{
	struct rt2661_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct mbuf *m0;
	struct ieee80211_node *ni;

	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (mq_len(&ic->ic_mgtq) > 0) {
			if (sc->mgtq.queued >= RT2661_MGT_RING_COUNT) {
				ifq_set_oactive(&ifp->if_snd);
				break;
			}

			m0 = mq_dequeue(&ic->ic_mgtq);
			if (m0 == NULL)
				continue;
			ni = m0->m_pkthdr.ph_cookie;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (rt2661_tx_mgt(sc, m0, ni) != 0)
				break;

		} else {
			if (sc->txq[0].queued >= RT2661_TX_RING_COUNT - 1) {
				ifq_set_oactive(&ifp->if_snd);
				break;
			}

			if (ic->ic_state != IEEE80211_S_RUN)
				break;

			IFQ_DEQUEUE(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0,
				    BPF_DIRECTION_OUT);
#endif
			if (rt2661_tx_data(sc, m0, ni, 0) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
rt2661_watchdog(struct ifnet *ifp)
{
	struct rt2661_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			rt2661_init(ifp);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
rt2661_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct rt2661_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				rt2661_update_promisc(sc);
			else
				rt2661_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				rt2661_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCS80211CHANNEL:
		/*
		 * This allows for fast channel switching in monitor mode
		 * (used by kismet). In IBSS mode, we must explicitly reset
		 * the interface to generate a new beacon frame.
		 */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING))
				rt2661_set_chan(sc, ic->ic_ibss_chan);
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			rt2661_init(ifp);
		error = 0;
	}

	splx(s);

	return error;
}

void
rt2661_bbp_write(struct rt2661_softc *sc, uint8_t reg, uint8_t val)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2661_PHY_CSR3) & RT2661_BBP_BUSY))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not write to BBP\n", sc->sc_dev.dv_xname);
		return;
	}

	tmp = RT2661_BBP_BUSY | (reg & 0x7f) << 8 | val;
	RAL_WRITE(sc, RT2661_PHY_CSR3, tmp);

	DPRINTFN(15, ("BBP R%u <- 0x%02x\n", reg, val));
}

uint8_t
rt2661_bbp_read(struct rt2661_softc *sc, uint8_t reg)
{
	uint32_t val;
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2661_PHY_CSR3) & RT2661_BBP_BUSY))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not read from BBP\n", sc->sc_dev.dv_xname);
		return 0;
	}

	val = RT2661_BBP_BUSY | RT2661_BBP_READ | reg << 8;
	RAL_WRITE(sc, RT2661_PHY_CSR3, val);

	for (ntries = 0; ntries < 100; ntries++) {
		val = RAL_READ(sc, RT2661_PHY_CSR3);
		if (!(val & RT2661_BBP_BUSY))
			return val & 0xff;
		DELAY(1);
	}

	printf("%s: could not read from BBP\n", sc->sc_dev.dv_xname);
	return 0;
}

void
rt2661_rf_write(struct rt2661_softc *sc, uint8_t reg, uint32_t val)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 100; ntries++) {
		if (!(RAL_READ(sc, RT2661_PHY_CSR4) & RT2661_RF_BUSY))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not write to RF\n", sc->sc_dev.dv_xname);
		return;
	}

	tmp = RT2661_RF_BUSY | RT2661_RF_21BIT | (val & 0x1fffff) << 2 |
	    (reg & 3);
	RAL_WRITE(sc, RT2661_PHY_CSR4, tmp);

	/* remember last written value in sc */
	sc->rf_regs[reg] = val;

	DPRINTFN(15, ("RF R[%u] <- 0x%05x\n", reg & 3, val & 0x1fffff));
}

int
rt2661_tx_cmd(struct rt2661_softc *sc, uint8_t cmd, uint16_t arg)
{
	if (RAL_READ(sc, RT2661_H2M_MAILBOX_CSR) & RT2661_H2M_BUSY)
		return EIO;	/* there is already a command pending */

	RAL_WRITE(sc, RT2661_H2M_MAILBOX_CSR,
	    RT2661_H2M_BUSY | RT2661_TOKEN_NO_INTR << 16 | arg);

	RAL_WRITE(sc, RT2661_HOST_CMD_CSR, RT2661_KICK_CMD | cmd);

	return 0;
}

void
rt2661_select_antenna(struct rt2661_softc *sc)
{
	uint8_t bbp4, bbp77;
	uint32_t tmp;

	bbp4  = rt2661_bbp_read(sc,  4);
	bbp77 = rt2661_bbp_read(sc, 77);

	/* TBD */

	/* make sure Rx is disabled before switching antenna */
	tmp = RAL_READ(sc, RT2661_TXRX_CSR0);
	RAL_WRITE(sc, RT2661_TXRX_CSR0, tmp | RT2661_DISABLE_RX);

	rt2661_bbp_write(sc,  4, bbp4);
	rt2661_bbp_write(sc, 77, bbp77);

	/* restore Rx filter */
	RAL_WRITE(sc, RT2661_TXRX_CSR0, tmp);
}

/*
 * Enable multi-rate retries for frames sent at OFDM rates.
 * In 802.11b/g mode, allow fallback to CCK rates.
 */
void
rt2661_enable_mrr(struct rt2661_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;

	tmp = RAL_READ(sc, RT2661_TXRX_CSR4);

	tmp &= ~RT2661_MRR_CCK_FALLBACK;
	if (!IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan))
		tmp |= RT2661_MRR_CCK_FALLBACK;
	tmp |= RT2661_MRR_ENABLED;

	RAL_WRITE(sc, RT2661_TXRX_CSR4, tmp);
}

void
rt2661_set_txpreamble(struct rt2661_softc *sc)
{
	uint32_t tmp;

	tmp = RAL_READ(sc, RT2661_TXRX_CSR4);

	tmp &= ~RT2661_SHORT_PREAMBLE;
	if (sc->sc_ic.ic_flags & IEEE80211_F_SHPREAMBLE)
		tmp |= RT2661_SHORT_PREAMBLE;

	RAL_WRITE(sc, RT2661_TXRX_CSR4, tmp);
}

void
rt2661_set_basicrates(struct rt2661_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	/* update basic rate set */
	if (ic->ic_curmode == IEEE80211_MODE_11B) {
		/* 11b basic rates: 1, 2Mbps */
		RAL_WRITE(sc, RT2661_TXRX_CSR5, 0x3);
	} else if (ic->ic_curmode == IEEE80211_MODE_11A) {
		/* 11a basic rates: 6, 12, 24Mbps */
		RAL_WRITE(sc, RT2661_TXRX_CSR5, 0x150);
	} else {
		/* 11b/g basic rates: 1, 2, 5.5, 11Mbps */
		RAL_WRITE(sc, RT2661_TXRX_CSR5, 0xf);
	}
}

/*
 * Reprogram MAC/BBP to switch to a new band.  Values taken from the reference
 * driver.
 */
void
rt2661_select_band(struct rt2661_softc *sc, struct ieee80211_channel *c)
{
	uint8_t bbp17, bbp35, bbp96, bbp97, bbp98, bbp104;
	uint32_t tmp;

	/* update all BBP registers that depend on the band */
	bbp17 = 0x20; bbp96 = 0x48; bbp104 = 0x2c;
	bbp35 = 0x50; bbp97 = 0x48; bbp98  = 0x48;
	if (IEEE80211_IS_CHAN_5GHZ(c)) {
		bbp17 += 0x08; bbp96 += 0x10; bbp104 += 0x0c;
		bbp35 += 0x10; bbp97 += 0x10; bbp98  += 0x10;
	}
	if ((IEEE80211_IS_CHAN_2GHZ(c) && sc->ext_2ghz_lna) ||
	    (IEEE80211_IS_CHAN_5GHZ(c) && sc->ext_5ghz_lna)) {
		bbp17 += 0x10; bbp96 += 0x10; bbp104 += 0x10;
	}

	sc->bbp17 = bbp17;
	rt2661_bbp_write(sc,  17, bbp17);
	rt2661_bbp_write(sc,  96, bbp96);
	rt2661_bbp_write(sc, 104, bbp104);

	if ((IEEE80211_IS_CHAN_2GHZ(c) && sc->ext_2ghz_lna) ||
	    (IEEE80211_IS_CHAN_5GHZ(c) && sc->ext_5ghz_lna)) {
		rt2661_bbp_write(sc, 75, 0x80);
		rt2661_bbp_write(sc, 86, 0x80);
		rt2661_bbp_write(sc, 88, 0x80);
	}

	rt2661_bbp_write(sc, 35, bbp35);
	rt2661_bbp_write(sc, 97, bbp97);
	rt2661_bbp_write(sc, 98, bbp98);

	tmp = RAL_READ(sc, RT2661_PHY_CSR0);
	tmp &= ~(RT2661_PA_PE_2GHZ | RT2661_PA_PE_5GHZ);
	if (IEEE80211_IS_CHAN_2GHZ(c))
		tmp |= RT2661_PA_PE_2GHZ;
	else
		tmp |= RT2661_PA_PE_5GHZ;
	RAL_WRITE(sc, RT2661_PHY_CSR0, tmp);

	/* 802.11a uses a 16 microseconds short interframe space */
	sc->sifs = IEEE80211_IS_CHAN_5GHZ(c) ? 16 : 10;
}

void
rt2661_set_chan(struct rt2661_softc *sc, struct ieee80211_channel *c)
{
	struct ieee80211com *ic = &sc->sc_ic;
	const struct rfprog *rfprog;
	uint8_t bbp3, bbp94 = RT2661_BBPR94_DEFAULT;
	int8_t power;
	u_int i, chan;

	chan = ieee80211_chan2ieee(ic, c);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return;

	/* select the appropriate RF settings based on what EEPROM says */
	rfprog = (sc->rfprog == 0) ? rt2661_rf5225_1 : rt2661_rf5225_2;

	/* find the settings for this channel (we know it exists) */
	for (i = 0; rfprog[i].chan != chan; i++);

	power = sc->txpow[i];
	if (power < 0) {
		bbp94 += power;
		power = 0;
	} else if (power > 31) {
		bbp94 += power - 31;
		power = 31;
	}

	/*
	 * If we are switching from the 2GHz band to the 5GHz band or
	 * vice-versa, BBP registers need to be reprogrammed.
	 */
	if (c->ic_flags != sc->sc_curchan->ic_flags) {
		rt2661_select_band(sc, c);
		rt2661_select_antenna(sc);
	}
	sc->sc_curchan = c;

	rt2661_rf_write(sc, RAL_RF1, rfprog[i].r1);
	rt2661_rf_write(sc, RAL_RF2, rfprog[i].r2);
	rt2661_rf_write(sc, RAL_RF3, rfprog[i].r3 | power << 7);
	rt2661_rf_write(sc, RAL_RF4, rfprog[i].r4 | sc->rffreq << 10);

	DELAY(200);

	rt2661_rf_write(sc, RAL_RF1, rfprog[i].r1);
	rt2661_rf_write(sc, RAL_RF2, rfprog[i].r2);
	rt2661_rf_write(sc, RAL_RF3, rfprog[i].r3 | power << 7 | 1);
	rt2661_rf_write(sc, RAL_RF4, rfprog[i].r4 | sc->rffreq << 10);

	DELAY(200);

	rt2661_rf_write(sc, RAL_RF1, rfprog[i].r1);
	rt2661_rf_write(sc, RAL_RF2, rfprog[i].r2);
	rt2661_rf_write(sc, RAL_RF3, rfprog[i].r3 | power << 7);
	rt2661_rf_write(sc, RAL_RF4, rfprog[i].r4 | sc->rffreq << 10);

	/* enable smart mode for MIMO-capable RFs */
	bbp3 = rt2661_bbp_read(sc, 3);

	bbp3 &= ~RT2661_SMART_MODE;
	if (sc->rf_rev == RT2661_RF_5325 || sc->rf_rev == RT2661_RF_2529)
		bbp3 |= RT2661_SMART_MODE;

	rt2661_bbp_write(sc, 3, bbp3);

	if (bbp94 != RT2661_BBPR94_DEFAULT)
		rt2661_bbp_write(sc, 94, bbp94);

	/* 5GHz radio needs a 1ms delay here */
	if (IEEE80211_IS_CHAN_5GHZ(c))
		DELAY(1000);
}

void
rt2661_set_bssid(struct rt2661_softc *sc, const uint8_t *bssid)
{
	uint32_t tmp;

	tmp = bssid[0] | bssid[1] << 8 | bssid[2] << 16 | bssid[3] << 24;
	RAL_WRITE(sc, RT2661_MAC_CSR4, tmp);

	tmp = bssid[4] | bssid[5] << 8 | RT2661_ONE_BSSID << 16;
	RAL_WRITE(sc, RT2661_MAC_CSR5, tmp);
}

void
rt2661_set_macaddr(struct rt2661_softc *sc, const uint8_t *addr)
{
	uint32_t tmp;

	tmp = addr[0] | addr[1] << 8 | addr[2] << 16 | addr[3] << 24;
	RAL_WRITE(sc, RT2661_MAC_CSR2, tmp);

	tmp = addr[4] | addr[5] << 8 | 0xff << 16;
	RAL_WRITE(sc, RT2661_MAC_CSR3, tmp);
}

void
rt2661_update_promisc(struct rt2661_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t tmp;

	tmp = RAL_READ(sc, RT2661_TXRX_CSR0);

	tmp &= ~RT2661_DROP_NOT_TO_ME;
	if (!(ifp->if_flags & IFF_PROMISC))
		tmp |= RT2661_DROP_NOT_TO_ME;

	RAL_WRITE(sc, RT2661_TXRX_CSR0, tmp);

	DPRINTF(("%s promiscuous mode\n", (ifp->if_flags & IFF_PROMISC) ?
	    "entering" : "leaving"));
}

void
rt2661_updateslot(struct ieee80211com *ic)
{
	struct rt2661_softc *sc = ic->ic_if.if_softc;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
		/*
		 * In HostAP mode, we defer setting of new slot time until
		 * updated ERP Information Element has propagated to all
		 * associated STAs.
		 */
		sc->sc_flags |= RT2661_UPDATE_SLOT;
	} else
#endif
		rt2661_set_slottime(sc);
}

void
rt2661_set_slottime(struct rt2661_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t slottime;
	uint32_t tmp;

	slottime = (ic->ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;

	tmp = RAL_READ(sc, RT2661_MAC_CSR9);
	tmp = (tmp & ~0xff) | slottime;
	RAL_WRITE(sc, RT2661_MAC_CSR9, tmp);

	DPRINTF(("setting slot time to %uus\n", slottime));
}

const char *
rt2661_get_rf(int rev)
{
	switch (rev) {
	case RT2661_RF_5225:	return "RT5225";
	case RT2661_RF_5325:	return "RT5325 (MIMO XR)";
	case RT2661_RF_2527:	return "RT2527";
	case RT2661_RF_2529:	return "RT2529 (MIMO XR)";
	default:		return "unknown";
	}
}

void
rt2661_read_eeprom(struct rt2661_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t val;
	int i;

	/* read MAC address */
	val = rt2661_eeprom_read(sc, RT2661_EEPROM_MAC01);
	ic->ic_myaddr[0] = val & 0xff;
	ic->ic_myaddr[1] = val >> 8;

	val = rt2661_eeprom_read(sc, RT2661_EEPROM_MAC23);
	ic->ic_myaddr[2] = val & 0xff;
	ic->ic_myaddr[3] = val >> 8;

	val = rt2661_eeprom_read(sc, RT2661_EEPROM_MAC45);
	ic->ic_myaddr[4] = val & 0xff;
	ic->ic_myaddr[5] = val >> 8;

	val = rt2661_eeprom_read(sc, RT2661_EEPROM_ANTENNA);
	/* XXX: test if different from 0xffff? */
	sc->rf_rev   = (val >> 11) & 0x1f;
	sc->hw_radio = (val >> 10) & 0x1;
	sc->rx_ant   = (val >> 4)  & 0x3;
	sc->tx_ant   = (val >> 2)  & 0x3;
	sc->nb_ant   = val & 0x3;

	DPRINTF(("RF revision=%d\n", sc->rf_rev));

	val = rt2661_eeprom_read(sc, RT2661_EEPROM_CONFIG2);
	sc->ext_5ghz_lna = (val >> 6) & 0x1;
	sc->ext_2ghz_lna = (val >> 4) & 0x1;

	DPRINTF(("External 2GHz LNA=%d\nExternal 5GHz LNA=%d\n",
	    sc->ext_2ghz_lna, sc->ext_5ghz_lna));

	val = rt2661_eeprom_read(sc, RT2661_EEPROM_RSSI_2GHZ_OFFSET);
	if ((val & 0xff) != 0xff)
		sc->rssi_2ghz_corr = (int8_t)(val & 0xff);	/* signed */

	val = rt2661_eeprom_read(sc, RT2661_EEPROM_RSSI_5GHZ_OFFSET);
	if ((val & 0xff) != 0xff)
		sc->rssi_5ghz_corr = (int8_t)(val & 0xff);	/* signed */

	/* adjust RSSI correction for external low-noise amplifier */
	if (sc->ext_2ghz_lna)
		sc->rssi_2ghz_corr -= 14;
	if (sc->ext_5ghz_lna)
		sc->rssi_5ghz_corr -= 14;

	DPRINTF(("RSSI 2GHz corr=%d\nRSSI 5GHz corr=%d\n",
	    sc->rssi_2ghz_corr, sc->rssi_5ghz_corr));

	val = rt2661_eeprom_read(sc, RT2661_EEPROM_FREQ_OFFSET);
	if ((val >> 8) != 0xff)
		sc->rfprog = (val >> 8) & 0x3;
	if ((val & 0xff) != 0xff)
		sc->rffreq = val & 0xff;

	DPRINTF(("RF prog=%d\nRF freq=%d\n", sc->rfprog, sc->rffreq));

	/* read Tx power for all a/b/g channels */
	for (i = 0; i < 19; i++) {
		val = rt2661_eeprom_read(sc, RT2661_EEPROM_TXPOWER + i);
		sc->txpow[i * 2] = (int8_t)(val >> 8);		/* signed */
		DPRINTF(("Channel=%d Tx power=%d\n",
		    rt2661_rf5225_1[i * 2].chan, sc->txpow[i * 2]));
		sc->txpow[i * 2 + 1] = (int8_t)(val & 0xff);	/* signed */
		DPRINTF(("Channel=%d Tx power=%d\n",
		    rt2661_rf5225_1[i * 2 + 1].chan, sc->txpow[i * 2 + 1]));
	}

	/* read vendor-specific BBP values */
	for (i = 0; i < 16; i++) {
		val = rt2661_eeprom_read(sc, RT2661_EEPROM_BBP_BASE + i);
		if (val == 0 || val == 0xffff)
			continue;	/* skip invalid entries */
		sc->bbp_prom[i].reg = val >> 8;
		sc->bbp_prom[i].val = val & 0xff;
		DPRINTF(("BBP R%d=%02x\n", sc->bbp_prom[i].reg,
		    sc->bbp_prom[i].val));
	}
}

int
rt2661_bbp_init(struct rt2661_softc *sc)
{
	int i, ntries;

	/* wait for BBP to be ready */
	for (ntries = 0; ntries < 100; ntries++) {
		const uint8_t val = rt2661_bbp_read(sc, 0);
		if (val != 0 && val != 0xff)
			break;
		DELAY(100);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for BBP\n", sc->sc_dev.dv_xname);
		return EIO;
	}

	/* initialize BBP registers to default values */
	for (i = 0; i < nitems(rt2661_def_bbp); i++) {
		rt2661_bbp_write(sc, rt2661_def_bbp[i].reg,
		    rt2661_def_bbp[i].val);
	}

	/* write vendor-specific BBP values (from EEPROM) */
	for (i = 0; i < 16; i++) {
		if (sc->bbp_prom[i].reg == 0)
			continue;
		rt2661_bbp_write(sc, sc->bbp_prom[i].reg, sc->bbp_prom[i].val);
	}

	return 0;
}

int
rt2661_init(struct ifnet *ifp)
{
	struct rt2661_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp, sta[3];
	int i, ntries;

	/* for CardBus, power on the socket */
	if (!(sc->sc_flags & RT2661_ENABLED)) {
		if (sc->sc_enable != NULL && (*sc->sc_enable)(sc) != 0) {
			printf("%s: could not enable device\n",
			    sc->sc_dev.dv_xname);
			return EIO;
		}
		sc->sc_flags |= RT2661_ENABLED;
	}

	rt2661_stop(ifp, 0);

	if (!(sc->sc_flags & RT2661_FWLOADED)) {
		if (rt2661_load_microcode(sc) != 0) {
			printf("%s: could not load 8051 microcode\n",
			    sc->sc_dev.dv_xname);
			rt2661_stop(ifp, 1);
			return EIO;
		}
		sc->sc_flags |= RT2661_FWLOADED;
	}

	/* initialize Tx rings */
	RAL_WRITE(sc, RT2661_AC1_BASE_CSR, sc->txq[1].physaddr);
	RAL_WRITE(sc, RT2661_AC0_BASE_CSR, sc->txq[0].physaddr);
	RAL_WRITE(sc, RT2661_AC2_BASE_CSR, sc->txq[2].physaddr);
	RAL_WRITE(sc, RT2661_AC3_BASE_CSR, sc->txq[3].physaddr);

	/* initialize Mgt ring */
	RAL_WRITE(sc, RT2661_MGT_BASE_CSR, sc->mgtq.physaddr);

	/* initialize Rx ring */
	RAL_WRITE(sc, RT2661_RX_BASE_CSR, sc->rxq.physaddr);

	/* initialize Tx rings sizes */
	RAL_WRITE(sc, RT2661_TX_RING_CSR0,
	    RT2661_TX_RING_COUNT << 24 |
	    RT2661_TX_RING_COUNT << 16 |
	    RT2661_TX_RING_COUNT <<  8 |
	    RT2661_TX_RING_COUNT);

	RAL_WRITE(sc, RT2661_TX_RING_CSR1,
	    RT2661_TX_DESC_WSIZE << 16 |
	    RT2661_TX_RING_COUNT <<  8 |	/* XXX: HCCA ring unused */
	    RT2661_MGT_RING_COUNT);

	/* initialize Rx rings */
	RAL_WRITE(sc, RT2661_RX_RING_CSR,
	    RT2661_RX_DESC_BACK  << 16 |
	    RT2661_RX_DESC_WSIZE <<  8 |
	    RT2661_RX_RING_COUNT);

	/* XXX: some magic here */
	RAL_WRITE(sc, RT2661_TX_DMA_DST_CSR, 0xaa);

	/* load base addresses of all 5 Tx rings (4 data + 1 mgt) */
	RAL_WRITE(sc, RT2661_LOAD_TX_RING_CSR, 0x1f);

	/* load base address of Rx ring */
	RAL_WRITE(sc, RT2661_RX_CNTL_CSR, 2);

	/* initialize MAC registers to default values */
	for (i = 0; i < nitems(rt2661_def_mac); i++)
		RAL_WRITE(sc, rt2661_def_mac[i].reg, rt2661_def_mac[i].val);

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	rt2661_set_macaddr(sc, ic->ic_myaddr);

	/* set host ready */
	RAL_WRITE(sc, RT2661_MAC_CSR1, 3);
	RAL_WRITE(sc, RT2661_MAC_CSR1, 0);

	/* wait for BBP/RF to wakeup */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (RAL_READ(sc, RT2661_MAC_CSR12) & 8)
			break;
		DELAY(1000);
	}
	if (ntries == 1000) {
		printf("timeout waiting for BBP/RF to wakeup\n");
		rt2661_stop(ifp, 1);
		return EIO;
	}

	if (rt2661_bbp_init(sc) != 0) {
		rt2661_stop(ifp, 1);
		return EIO;
	}

	/* select default channel */
	sc->sc_curchan = ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	rt2661_select_band(sc, sc->sc_curchan);
	rt2661_select_antenna(sc);
	rt2661_set_chan(sc, sc->sc_curchan);

	/* update Rx filter */
	tmp = RAL_READ(sc, RT2661_TXRX_CSR0) & 0xffff;

	tmp |= RT2661_DROP_PHY_ERROR | RT2661_DROP_CRC_ERROR;
	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
		tmp |= RT2661_DROP_CTL | RT2661_DROP_VER_ERROR |
		       RT2661_DROP_ACKCTS;
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode != IEEE80211_M_HOSTAP)
#endif
			tmp |= RT2661_DROP_TODS;
		if (!(ifp->if_flags & IFF_PROMISC))
			tmp |= RT2661_DROP_NOT_TO_ME;
	}

	RAL_WRITE(sc, RT2661_TXRX_CSR0, tmp);

	/* clear STA registers */
	RAL_READ_REGION_4(sc, RT2661_STA_CSR0, sta, nitems(sta));

	/* initialize ASIC */
	RAL_WRITE(sc, RT2661_MAC_CSR1, 4);

	/* clear any pending interrupt */
	RAL_WRITE(sc, RT2661_INT_SOURCE_CSR, 0xffffffff);

	/* enable interrupts */
	RAL_WRITE(sc, RT2661_INT_MASK_CSR, 0x0000ff10);
	RAL_WRITE(sc, RT2661_MCU_INT_MASK_CSR, 0);

	/* kick Rx */
	RAL_WRITE(sc, RT2661_RX_CNTL_CSR, 1);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	return 0;
}

void
rt2661_stop(struct ifnet *ifp, int disable)
{
	struct rt2661_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;
	int ac;

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);	/* free all nodes */
	rt2661_amrr_node_free_all(sc);

	/* abort Tx (for all 5 Tx rings) */
	RAL_WRITE(sc, RT2661_TX_CNTL_CSR, 0x1f << 16);

	/* disable Rx (value remains after reset!) */
	tmp = RAL_READ(sc, RT2661_TXRX_CSR0);
	RAL_WRITE(sc, RT2661_TXRX_CSR0, tmp | RT2661_DISABLE_RX);

	/* reset ASIC */
	RAL_WRITE(sc, RT2661_MAC_CSR1, 3);
	RAL_WRITE(sc, RT2661_MAC_CSR1, 0);

	/* disable interrupts */
	RAL_WRITE(sc, RT2661_INT_MASK_CSR, 0xffffff7f);
	RAL_WRITE(sc, RT2661_MCU_INT_MASK_CSR, 0xffffffff);

	/* clear any pending interrupt */
	RAL_WRITE(sc, RT2661_INT_SOURCE_CSR, 0xffffffff);
	RAL_WRITE(sc, RT2661_MCU_INT_SOURCE_CSR, 0xffffffff);

	/* reset Tx and Rx rings */
	for (ac = 0; ac < 4; ac++)
		rt2661_reset_tx_ring(sc, &sc->txq[ac]);
	rt2661_reset_tx_ring(sc, &sc->mgtq);
	rt2661_reset_rx_ring(sc, &sc->rxq);

	/* for CardBus, power down the socket */
	if (disable && sc->sc_disable != NULL) {
		if (sc->sc_flags & RT2661_ENABLED) {
			(*sc->sc_disable)(sc);
			sc->sc_flags &= ~(RT2661_ENABLED | RT2661_FWLOADED);
		}
	}
}

int
rt2661_load_microcode(struct rt2661_softc *sc)
{
	int ntries;

	/* reset 8051 */
	RAL_WRITE(sc, RT2661_MCU_CNTL_CSR, RT2661_MCU_RESET);

	/* cancel any pending Host to MCU command */
	RAL_WRITE(sc, RT2661_H2M_MAILBOX_CSR, 0);
	RAL_WRITE(sc, RT2661_M2H_CMD_DONE_CSR, 0xffffffff);
	RAL_WRITE(sc, RT2661_HOST_CMD_CSR, 0);

	/* write 8051's microcode */
	RAL_WRITE(sc, RT2661_MCU_CNTL_CSR, RT2661_MCU_RESET | RT2661_MCU_SEL);
	RAL_WRITE_REGION_1(sc, RT2661_MCU_CODE_BASE, sc->ucode, sc->ucsize);
	RAL_WRITE(sc, RT2661_MCU_CNTL_CSR, RT2661_MCU_RESET);

	/* kick 8051's ass */
	RAL_WRITE(sc, RT2661_MCU_CNTL_CSR, 0);

	/* wait for 8051 to initialize */
	for (ntries = 0; ntries < 500; ntries++) {
		if (RAL_READ(sc, RT2661_MCU_CNTL_CSR) & RT2661_MCU_READY)
			break;
		DELAY(100);
	}
	if (ntries == 500) {
		printf("%s: timeout waiting for MCU to initialize\n",
		    sc->sc_dev.dv_xname);
		return EIO;
	}
	return 0;
}

/*
 * Dynamically tune Rx sensitivity (BBP register 17) based on average RSSI and
 * false CCA count.  This function is called periodically (every seconds) when
 * in the RUN state.  Values taken from the reference driver.
 */
void
rt2661_rx_tune(struct rt2661_softc *sc)
{
	uint8_t bbp17;
	uint16_t cca;
	int lo, hi, dbm;

	/*
	 * Tuning range depends on operating band and on the presence of an
	 * external low-noise amplifier.
	 */
	lo = 0x20;
	if (IEEE80211_IS_CHAN_5GHZ(sc->sc_curchan))
		lo += 0x08;
	if ((IEEE80211_IS_CHAN_2GHZ(sc->sc_curchan) && sc->ext_2ghz_lna) ||
	    (IEEE80211_IS_CHAN_5GHZ(sc->sc_curchan) && sc->ext_5ghz_lna))
		lo += 0x10;
	hi = lo + 0x20;

	dbm = sc->avg_rssi;
	/* retrieve false CCA count since last call (clear on read) */
	cca = RAL_READ(sc, RT2661_STA_CSR1) & 0xffff;

	DPRINTFN(2, ("RSSI=%ddBm false CCA=%d\n", dbm, cca));

	if (dbm < -74) {
		/* very bad RSSI, tune using false CCA count */
		bbp17 = sc->bbp17; /* current value */

		hi -= 2 * (-74 - dbm);
		if (hi < lo)
			hi = lo;

		if (bbp17 > hi)
			bbp17 = hi;
		else if (cca > 512)
			bbp17 = min(bbp17 + 1, hi);
		else if (cca < 100)
			bbp17 = max(bbp17 - 1, lo);

	} else if (dbm < -66) {
		bbp17 = lo + 0x08;
	} else if (dbm < -58) {
		bbp17 = lo + 0x10;
	} else if (dbm < -35) {
		bbp17 = hi;
	} else {	/* very good RSSI >= -35dBm */
		bbp17 = 0x60;	/* very low sensitivity */
	}

	if (bbp17 != sc->bbp17) {
		DPRINTF(("BBP17 %x->%x\n", sc->bbp17, bbp17));
		rt2661_bbp_write(sc, 17, bbp17);
		sc->bbp17 = bbp17;
	}
}

#ifdef notyet
/*
 * Enter/Leave radar detection mode.
 * This is for 802.11h additional regulatory domains.
 */
void
rt2661_radar_start(struct rt2661_softc *sc)
{
	uint32_t tmp;

	/* disable Rx */
	tmp = RAL_READ(sc, RT2661_TXRX_CSR0);
	RAL_WRITE(sc, RT2661_TXRX_CSR0, tmp | RT2661_DISABLE_RX);

	rt2661_bbp_write(sc, 82, 0x20);
	rt2661_bbp_write(sc, 83, 0x00);
	rt2661_bbp_write(sc, 84, 0x40);

	/* save current BBP registers values */
	sc->bbp18 = rt2661_bbp_read(sc, 18);
	sc->bbp21 = rt2661_bbp_read(sc, 21);
	sc->bbp22 = rt2661_bbp_read(sc, 22);
	sc->bbp16 = rt2661_bbp_read(sc, 16);
	sc->bbp17 = rt2661_bbp_read(sc, 17);
	sc->bbp64 = rt2661_bbp_read(sc, 64);

	rt2661_bbp_write(sc, 18, 0xff);
	rt2661_bbp_write(sc, 21, 0x3f);
	rt2661_bbp_write(sc, 22, 0x3f);
	rt2661_bbp_write(sc, 16, 0xbd);
	rt2661_bbp_write(sc, 17, sc->ext_5ghz_lna ? 0x44 : 0x34);
	rt2661_bbp_write(sc, 64, 0x21);

	/* restore Rx filter */
	RAL_WRITE(sc, RT2661_TXRX_CSR0, tmp);
}

int
rt2661_radar_stop(struct rt2661_softc *sc)
{
	uint8_t bbp66;

	/* read radar detection result */
	bbp66 = rt2661_bbp_read(sc, 66);

	/* restore BBP registers values */
	rt2661_bbp_write(sc, 16, sc->bbp16);
	rt2661_bbp_write(sc, 17, sc->bbp17);
	rt2661_bbp_write(sc, 18, sc->bbp18);
	rt2661_bbp_write(sc, 21, sc->bbp21);
	rt2661_bbp_write(sc, 22, sc->bbp22);
	rt2661_bbp_write(sc, 64, sc->bbp64);

	return bbp66 == 1;
}
#endif

#ifndef IEEE80211_STA_ONLY
int
rt2661_prepare_beacon(struct rt2661_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct rt2661_tx_desc desc;
	struct mbuf *m0;
	int rate;

	m0 = ieee80211_beacon_alloc(ic, ni);
	if (m0 == NULL) {
		printf("%s: could not allocate beacon frame\n",
		    sc->sc_dev.dv_xname);
		return ENOBUFS;
	}

	/* send beacons at the lowest available rate */
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;

	rt2661_setup_tx_desc(sc, &desc, RT2661_TX_TIMESTAMP, RT2661_TX_HWSEQ,
	    m0->m_pkthdr.len, rate, NULL, 0, RT2661_QID_MGT,
	    RT2661_AMRR_INVALID_ID);

	/* copy the first 24 bytes of Tx descriptor into NIC memory */
	RAL_WRITE_REGION_1(sc, RT2661_HW_BEACON_BASE0, (uint8_t *)&desc, 24);

	/* copy beacon header and payload into NIC memory */
	RAL_WRITE_REGION_1(sc, RT2661_HW_BEACON_BASE0 + 24,
	    mtod(m0, uint8_t *), m0->m_pkthdr.len);

	m_freem(m0);

	/*
	 * Store offset of ERP Information Element so that we can update it
	 * dynamically when the slot time changes.
	 * XXX: this is ugly since it depends on how net80211 builds beacon
	 * frames but ieee80211_beacon_alloc() doesn't store offsets for us.
	 */
	if (ic->ic_curmode == IEEE80211_MODE_11G) {
		sc->erp_csr =
		    RT2661_HW_BEACON_BASE0 + 24 +
		    sizeof (struct ieee80211_frame) +
		    8 + 2 + 2 +
		    ((ic->ic_flags & IEEE80211_F_HIDENWID) ?
			1 : 2 + ni->ni_esslen) +
		    2 + min(ni->ni_rates.rs_nrates, IEEE80211_RATE_SIZE) +
		    2 + 1 +
		    ((ic->ic_opmode == IEEE80211_M_IBSS) ? 4 : 6) +
		    2;
	}

	return 0;
}
#endif

/*
 * Enable TSF synchronization and tell h/w to start sending beacons for IBSS
 * and HostAP operating modes.
 */
void
rt2661_enable_tsf_sync(struct rt2661_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode != IEEE80211_M_STA) {
		/*
		 * Change default 16ms TBTT adjustment to 8ms.
		 * Must be done before enabling beacon generation.
		 */
		RAL_WRITE(sc, RT2661_TXRX_CSR10, 1 << 12 | 8);
	}
#endif
	tmp = RAL_READ(sc, RT2661_TXRX_CSR9) & 0xff000000;

	/* set beacon interval (in 1/16ms unit) */
	tmp |= ic->ic_bss->ni_intval * 16;

	tmp |= RT2661_TSF_TICKING | RT2661_ENABLE_TBTT;
	if (ic->ic_opmode == IEEE80211_M_STA)
		tmp |= RT2661_TSF_MODE(1);
#ifndef IEEE80211_STA_ONLY
	else
		tmp |= RT2661_TSF_MODE(2) | RT2661_GENERATE_BEACON;
#endif
	RAL_WRITE(sc, RT2661_TXRX_CSR9, tmp);
}

/*
 * Retrieve the "Received Signal Strength Indicator" from the raw values
 * contained in Rx descriptors.  The computation depends on which band the
 * frame was received.  Correction values taken from the reference driver.
 */
int
rt2661_get_rssi(struct rt2661_softc *sc, uint8_t raw)
{
	int lna, agc, rssi;

	lna = (raw >> 5) & 0x3;
	agc = raw & 0x1f;

	rssi = 2 * agc;

	if (IEEE80211_IS_CHAN_2GHZ(sc->sc_curchan)) {
		rssi += sc->rssi_2ghz_corr;

		if (lna == 1)
			rssi -= 64;
		else if (lna == 2)
			rssi -= 74;
		else if (lna == 3)
			rssi -= 90;
	} else {
		rssi += sc->rssi_5ghz_corr;

		if (lna == 1)
			rssi -= 64;
		else if (lna == 2)
			rssi -= 86;
		else if (lna == 3)
			rssi -= 100;
	}
	return rssi;
}
@


1.90
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.89 2015/12/11 16:07:01 mpi Exp $	*/
a1072 1
			ifp->if_opackets++;
@


1.89
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.88 2015/11/25 03:09:58 dlg Exp $	*/
a344 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.88
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.87 2015/11/24 13:33:17 mpi Exp $	*/
d72 1
a72 1
void		rt2661_attachhook(void *);
d251 1
a251 4
	if (rootvp == NULL)
		mountroothook_establish(rt2661_attachhook, sc);
	else
		rt2661_attachhook(sc);
d262 1
a262 1
rt2661_attachhook(void *xsc)
d264 1
a264 1
	struct rt2661_softc *sc = xsc;
@


1.87
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.86 2015/11/20 12:41:29 mpi Exp $	*/
d1153 1
a1153 1
			ifp->if_flags &= ~IFF_OACTIVE;
d1931 1
a1931 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1937 1
a1937 1
				ifp->if_flags |= IFF_OACTIVE;
d1954 1
a1954 1
				ifp->if_flags |= IFF_OACTIVE;
a2709 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2711 1
d2731 2
a2732 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.86
log
@Check for space on the ring before dequeuing packets.

Allows us to get rid of mq_requeue(9) and IFQ_POLL(9) because wireless
drivers use a special queue for management frames.

Tested by stsp@@, ok dlg@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.85 2015/11/20 03:35:22 dlg Exp $	*/
a48 1
#include <net/if_types.h>
@


1.85
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.84 2015/11/04 12:11:59 dlg Exp $	*/
d1936 1
a1936 2
		m0 = mq_dequeue(&ic->ic_mgtq);
		if (m0 != NULL) {
a1938 1
				mq_requeue(&ic->ic_mgtq, m0);
d1942 3
d1954 5
d1961 2
a1962 1
			m0 = ifq_deq_begin(&ifp->if_snd);
a1964 7
			if (sc->txq[0].queued >= RT2661_TX_RING_COUNT - 1) {
				ifq_deq_rollback(&ifp->if_snd, m0);
				/* there is no place left in this ring */
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			ifq_deq_commit(&ifp->if_snd, m0);
@


1.84
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.83 2015/10/25 12:48:46 mpi Exp $	*/
d1955 1
a1955 1
			IFQ_POLL(&ifp->if_snd, m0);
d1959 1
d1964 1
a1964 1
			IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.83
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.82 2015/09/09 19:26:05 deraadt Exp $	*/
d1936 1
a1936 1
		IF_POLL(&ic->ic_mgtq, m0);
d1940 1
a1942 1
			IF_DEQUEUE(&ic->ic_mgtq, m0);
@


1.82
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.81 2015/08/29 20:55:34 deraadt Exp $	*/
a2013 1
	struct ifaddr *ifa;
a2020 1
		ifa = (struct ifaddr *)data;
a2021 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.81
log
@firmware sizes are known; use them for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.80 2015/03/14 03:38:47 jsg Exp $	*/
d564 1
a564 1
		free(ring->data, M_DEVBUF, 0);
d715 1
a715 1
		free(ring->data, M_DEVBUF, 0);
d756 1
a756 1
	free(amn, M_DEVBUF, 0);
@


1.80
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.79 2015/02/10 23:25:46 mpi Exp $	*/
d399 1
a399 1
		free(sc->ucode, M_DEVBUF, 0);
@


1.79
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.78 2014/12/22 02:28:51 tedu Exp $	*/
a46 1
#include <net/if_arp.h>
@


1.78
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.77 2014/12/19 22:44:58 guenther Exp $	*/
a1250 1
		m->m_pkthdr.rcvif = ifp;
@


1.77
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.76 2014/09/06 05:41:35 jsg Exp $	*/
a2025 1
#ifdef INET
a2027 1
#endif
@


1.76
log
@reduce the amount of pci includes
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.75 2014/07/22 13:12:12 mpi Exp $	*/
d38 1
a40 1
#include <machine/endian.h>
@


1.75
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.74 2014/07/13 23:10:23 deraadt Exp $	*/
a62 2
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
@


1.74
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.73 2014/07/12 18:48:17 tedu Exp $	*/
a52 1
#include <netinet/in_systm.h>
a53 1
#include <netinet/ip.h>
@


1.73
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.72 2014/03/19 10:09:19 mpi Exp $	*/
d476 2
a477 2
	ring->data = malloc(count * sizeof (struct rt2661_tx_data), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
d617 2
a618 2
	ring->data = malloc(count * sizeof (struct rt2661_rx_data), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
@


1.72
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.71 2014/03/11 19:45:28 guenther Exp $	*/
d404 1
a404 1
		free(sc->ucode, M_DEVBUF);
d569 1
a569 1
		free(ring->data, M_DEVBUF);
d720 1
a720 1
		free(ring->data, M_DEVBUF);
d761 1
a761 1
	free(amn, M_DEVBUF);
@


1.71
log
@lint is gone, and the 'lint' conditional was never in the implementation
namespace, so stop changing behavior when it's #defined

ok beck@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.70 2013/12/06 21:03:03 deraadt Exp $	*/
d1950 1
a1950 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
@


1.70
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.69 2013/08/07 01:06:30 bluhm Exp $	*/
d276 1
a276 1
	const char *name = NULL;	/* make lint happy */
@


1.69
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.68 2012/08/23 10:34:25 stsp Exp $	*/
d422 1
a422 1
rt2661_resume(void *xsc)
@


1.68
log
@Fix a race in rt2661 Tx interrupt processing which can cause Tx processing
to get stuck with OACTIVE set, requiring 'ifconfig ral0 down up' to unwedge.

Make space in the Tx queue from the rt2661_tx_dma_intr() handler,
rather than waiting until rt2661_tx_intr() is run. The latter function
now collects AMRR statistics only. AMRR node allocation is now separated
from ieee80211_node allocation to make this possible.

This commit also brings back the separation of OACTIVE flags for management
and data Tx queues which I reverted in the previous commit.

Inspired by ral commits by sephe@@dragonflybsd and patch submission to
misc@@ by Roland Dreier http://marc.info/?l=openbsd-misc&m=125895269930106&w=2

Tested by myself, edd, jsg, Tobias Ulmer, Pieter Verberne, Tim van der Molen.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.67 2012/07/17 14:43:12 stsp Exp $	*/
a53 1
#include <netinet/in_var.h>
@


1.67
log
@Revert my previous change for rt2661. It is causing excessive "ral0: device
timeout" messages on my soekris and doesn't fix the real problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.65 2011/03/18 06:05:21 deraadt Exp $	*/
d37 1
d61 1
d93 2
d122 1
a122 1
		    const bus_dma_segment_t *, int, int);
d163 8
d210 2
d361 2
d396 1
d725 88
d816 3
a818 1
	return malloc(sizeof (struct rt2661_node), M_DEVBUF,
d820 16
d880 2
a881 1
	ieee80211_amrr_choose(&sc->amrr, ni, &rn->amn);
d901 2
a902 2
	/* update rx sensitivity every 1 sec */
	if (++sc->ncalls & 1)
d904 2
d915 1
d918 2
a919 1
	ieee80211_amrr_node_init(&sc->amrr, &((struct rt2661_node *)ni)->amn);
d1053 2
d1060 3
a1062 4
	struct rt2661_tx_ring *txq;
	struct rt2661_tx_data *data;
	struct rt2661_node *rn;
	int qid, retrycnt;
a1068 4
		/* retrieve the queue in which this frame was sent */
		qid = RT2661_TX_QID(val);
		txq = (qid <= 3) ? &sc->txq[qid] : &sc->mgtq;

d1070 2
a1071 6
		data = &txq->data[txq->stat];
		rn = (struct rt2661_node *)data->ni;

		/* if no frame has been sent, ignore */
		if (rn == NULL)
			continue;
d1079 5
a1083 3
			rn->amn.amn_txcnt++;
			if (retrycnt > 0)
				rn->amn.amn_retrycnt++;
d1090 4
a1093 2
			rn->amn.amn_txcnt++;
			rn->amn.amn_retrycnt++;
d1104 1
a1104 8
		ieee80211_release_node(ic, data->ni);
		data->ni = NULL;

		DPRINTFN(15, ("tx done q=%d idx=%u\n", qid, txq->stat));

		txq->queued--;
		if (++txq->stat >= txq->count)	/* faster than % count */
			txq->stat = 0;
a1105 4

	sc->sc_tx_timer = 0;
	ifp->if_flags &= ~IFF_OACTIVE;
	rt2661_start(ifp);
d1108 3
d1114 3
d1141 2
a1142 1
		/* node reference is released in rt2661_tx_intr() */
d1146 1
d1150 13
d1559 1
a1559 1
    const bus_dma_segment_t *segs, int nsegs, int ac)
d1579 3
a1581 3
	 * Remember in which queue this frame was sent. This field is driver
	 * private data only. It will be made available by the NIC in STA_CSR4
	 * on Tx interrupts.
d1583 1
a1583 1
	desc->qid = ac;
d1687 1
a1687 1
	    RT2661_QID_MGT);
d1712 1
d1722 1
d1817 2
a1818 1
		    data->map->dm_nsegs, ac);
d1908 2
a1909 1
	    data->map->dm_segs, data->map->dm_nsegs, ac);
d2748 1
d2959 2
a2960 1
	    m0->m_pkthdr.len, rate, NULL, 0, RT2661_QID_MGT);
@


1.66
log
@Keep separate OACTIVE flags to mark full management/data tx queues,
and set the interface's IFF_OACTIVE flag if either queue is full and
clear it only if both queues have free slots. Before this change both
queues were setting/clearing the same flag with no regard for the
other queue's state.

Also, don't reset the tx watchdog counter if either queue still has frames
queued when we exit the frame-processing loop in the per-queue interrupt
handlers.

Both changes originally from sephe@@dragonfly.

Tested by myself and edd on a slow busy soekris which before this
change required occasional 'ifconfig ral0 down up' to recover.
@
text
@d989 3
a991 12
	if (sc->mgtq.queued == 0 && sc->txq[0].queued == 0)
		sc->sc_tx_timer = 0;
	if (sc->mgtq.queued < RT2661_MGT_RING_COUNT &&
	    sc->txq[0].queued < RT2661_TX_RING_COUNT - 1) {
		if (sc->mgtq.queued < RT2661_MGT_RING_COUNT)
			sc->sc_flags &= ~RT2661_MGT_OACTIVE;
		if (sc->txq[0].queued < RT2661_TX_RING_COUNT - 1)
			sc->sc_flags &= ~RT2661_DATA_OACTIVE;
		if (!(sc->sc_flags & (RT2661_MGT_OACTIVE|RT2661_DATA_OACTIVE)))
			ifp->if_flags &= ~IFF_OACTIVE;
		rt2661_start(ifp);
	}
a1807 1
				sc->sc_flags |= RT2661_MGT_OACTIVE;
a1829 1
				sc->sc_flags |= RT2661_DATA_OACTIVE;
a2604 1
	sc->sc_flags &= ~(RT2661_MGT_OACTIVE|RT2661_DATA_OACTIVE);
@


1.65
log
@Fix firmware loading at startup (and resume); from Tim van der Molen
based on discussion with damien; tested by others on the lists
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.64 2011/02/22 20:05:03 kettenis Exp $	*/
d989 12
a1000 3
	sc->sc_tx_timer = 0;
	ifp->if_flags &= ~IFF_OACTIVE;
	rt2661_start(ifp);
d1817 1
d1840 1
d2616 1
@


1.64
log
@Mark descriptors as invalid *before* unmapping the associated mbuf.
Might prevent the unrecoverable DMA error mentioned in PR 6557.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.63 2010/09/07 16:21:42 deraadt Exp $	*/
d399 1
a399 1
	if (ifp->if_flags & IFF_RUNNING)
d401 2
d2469 8
a2476 5
	if (rt2661_load_microcode(sc) != 0) {
		printf("%s: could not load 8051 microcode\n",
		    sc->sc_dev.dv_xname);
		rt2661_stop(ifp, 1);
		return EIO;
d2639 1
a2639 1
			sc->sc_flags &= ~RT2661_ENABLED;
@


1.63
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.62 2010/09/06 19:20:21 deraadt Exp $	*/
d1007 7
a1019 7

		/* descriptor is no longer valid */
		desc->flags &= ~htole32(RT2661_TX_VALID);

		bus_dmamap_sync(sc->sc_dmat, txq->map,
		    txq->next * RT2661_TX_DESC_SIZE, RT2661_TX_DESC_SIZE,
		    BUS_DMASYNC_PREWRITE);
@


1.62
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.61 2010/09/06 18:22:02 kettenis Exp $	*/
a158 1
void		rt2661_powerhook(int, void *);
a248 6
	sc->sc_powerhook = powerhook_establish(rt2661_powerhook, sc);
	if (sc->sc_powerhook == NULL) {
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);
	}

a378 3
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);

a2916 18
}

void
rt2661_powerhook(int why, void *arg)
{
	struct rt2661_softc *sc = arg;
	int s;

	s = splnet();
	switch (why) {
	case DVACT_SUSPEND:
		rt2661_suspend(sc);
		break;
	case DVACT_RESUME:
		rt2661_resume(sc);
		break;
	}
	splx(s);
@


1.61
log
@Make the interrupt handler bail out early if the device wen away.  Fixes
freezes that occur when removing CardBus cards when the interface is up.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.60 2010/08/28 18:08:07 deraadt Exp $	*/
d2937 1
a2937 1
	case PWR_SUSPEND:
d2940 1
a2940 1
	case PWR_RESUME:
@


1.60
log
@rename the *_power functions to *_powerhook to indicate that we've been
here already for the activate/powerhook cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.59 2010/08/27 17:08:00 jsg Exp $	*/
d1250 2
@


1.59
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.58 2010/08/27 16:06:25 kettenis Exp $	*/
d159 1
a159 1
void		rt2661_power(int, void *);
d250 1
a250 1
	sc->sc_powerhook = powerhook_establish(rt2661_power, sc);
d2928 1
a2928 1
rt2661_power(int why, void *arg)
@


1.58
log
@Stop calling xxx_power() from xxx_resume(); instead do it the other way around.
Get rid of the sc_power() callback, which isn't used anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.57 2010/08/27 04:09:18 deraadt Exp $	*/
a344 1
	ifp->if_init = rt2661_init;
@


1.57
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.56 2010/08/25 21:37:59 kettenis Exp $	*/
d418 1
d420 2
a421 1
	rt2661_power(PWR_RESUME, sc);
a2931 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d2937 1
a2937 3
		rt2661_stop(ifp, 0);
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
d2940 1
a2940 5
		if (ifp->if_flags & IFF_UP) {
			rt2661_init(ifp);	
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, why);
		}
@


1.56
log
@Make CardBus ral(4) suspend and resume properly on machines that keep the
CardBus bridge powered up during suspend.  Step zero on the long road
towards fully suspending CardBus on all machines.

ok deraadt@@, damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.55 2010/08/04 19:48:33 damien Exp $	*/
a2935 1
	case PWR_STANDBY:
@


1.55
log
@add suspend/resume support for PCI ral(4) devices.

ok deraadt@@, sthen@@

tested by matthew@@ (RT2560), dcoppa@@ (RT2790), okan@@ (RT2860), todd@@ (RT2560)
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.54 2010/05/19 15:27:35 oga Exp $	*/
d411 1
a411 1
		rt2661_stop(ifp, 0);
@


1.54
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.53 2010/04/20 22:05:43 tedu Exp $	*/
d77 1
d148 1
a148 2
int		rt2661_load_microcode(struct rt2661_softc *, const uint8_t *,
		    int);
a188 1
	struct ifnet *ifp = &ic->ic_if;
d190 1
a190 1
	int error, ac, i, ntries;
d245 45
a374 13

	sc->sc_powerhook = powerhook_establish(rt2661_power, sc);
	if (sc->sc_powerhook == NULL) {
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);
	}

	return 0;

fail2:	rt2661_free_tx_ring(sc, &sc->mgtq);
fail1:	while (--ac >= 0)
		rt2661_free_tx_ring(sc, &sc->txq[ac]);
	return ENXIO;
d398 3
d404 18
a2458 3
	const char *name = NULL;	/* make lint happy */
	uint8_t *ucode;
	size_t size;
d2460 1
a2460 1
	int i, ntries, error;
d2474 5
a2478 30
	if (!(sc->sc_flags & RT2661_FWLOADED)) {
		switch (sc->sc_id) {
		case PCI_PRODUCT_RALINK_RT2561:
			name = "ral-rt2561";
			break;
		case PCI_PRODUCT_RALINK_RT2561S:
			name = "ral-rt2561s";
			break;
		case PCI_PRODUCT_RALINK_RT2661:
			name = "ral-rt2661";
			break;
		}

		if ((error = loadfirmware(name, &ucode, &size)) != 0) {
			printf("%s: error %d, could not read firmware %s\n",
			    sc->sc_dev.dv_xname, error, name);
			rt2661_stop(ifp, 1);
			return EIO;
		}

		if (rt2661_load_microcode(sc, ucode, size) != 0) {
			printf("%s: could not load 8051 microcode\n",
			    sc->sc_dev.dv_xname);
			free(ucode, M_DEVBUF);
			rt2661_stop(ifp, 1);
			return EIO;
		}

		free(ucode, M_DEVBUF);
		sc->sc_flags |= RT2661_FWLOADED;
d2641 1
a2641 1
			sc->sc_flags &= ~(RT2661_ENABLED | RT2661_FWLOADED);
d2647 1
a2647 1
rt2661_load_microcode(struct rt2661_softc *sc, const uint8_t *ucode, int size)
d2661 1
a2661 1
	RAL_WRITE_REGION_1(sc, RT2661_MCU_CODE_BASE, ucode, size);
a2932 2
	DPRINTF(("%s: rt2661_power(%d)\n", sc->sc_dev.dv_xname, why));

d2937 1
a2937 2
		rt2661_stop(ifp, 1);
		sc->sc_flags &= ~RT2661_FWLOADED; 
a2945 2
			if (ifp->if_flags & IFF_RUNNING)
				rt2661_start(ifp);
@


1.53
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.52 2010/02/14 09:20:34 damien Exp $	*/
d389 1
a389 1
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a412 1
	memset(ring->desc, 0, count * RT2661_TX_DESC_SIZE);
d530 1
a530 1
	    PAGE_SIZE, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a553 1
	memset(ring->desc, 0, count * RT2661_RX_DESC_SIZE);
@


1.52
log
@The ASIC does not like PCI bursts on registers because of a silicon bug.
To prevent PCI read or write bursts, we issue a read to a non-contiguous
register before accessing a register.  This problem does not show up on
the x86 architecture since the memory model makes it almost impossible
to generate PCI bursts without doing DMA.

This bug is "documented" in the Ralink Linux driver as:
"//Patch for ASIC turst read/write bug, needs to remove after metel fix"

This fix makes the RT2561S chip on the Gdium (loongson) work.
It fails to load the firmware without it.

Tested by miod@@ of the Gdium (slightly different diff though)
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.51 2009/11/01 12:08:36 damien Exp $	*/
a28 1
#include <sys/sysctl.h>
@


1.51
log
@call powerhook_disestablish() and pci_intr_disestablish() earlier.

diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.50 2009/08/10 17:47:23 damien Exp $	*/
d62 1
a63 1
#include <dev/ic/rt2661var.h>
@


1.50
log
@three more shutdown hooks bite the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.49 2009/07/29 17:46:31 blambert Exp $	*/
d357 3
a361 3

	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);
@


1.49
log
@timeout_add -> timeout_add_msec

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.48 2009/03/29 21:53:52 sthen Exp $	*/
a332 9
	/*
	 * Make sure the interface is shutdown during reboot.
	 */
	sc->sc_sdhook = shutdownhook_establish(rt2661_shutdown, sc);
	if (sc->sc_sdhook == NULL) {
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    sc->sc_dev.dv_xname);
	}

a362 3
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);

a2933 9
}

void
rt2661_shutdown(void *arg)
{
	struct rt2661_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	rt2661_stop(ifp, 1);
@


1.48
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.47 2008/12/22 18:20:47 damien Exp $	*/
d752 1
a752 1
	timeout_add(&sc->amrr_to, hz / 2);
d793 1
a793 1
		timeout_add(&sc->scan_to, hz / 5);
d828 1
a828 1
			timeout_add(&sc->amrr_to, hz / 2);
@


1.47
log
@I swapped MGETHDR arguments in my m_defrag removal commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.46 2008/12/21 18:19:58 damien Exp $	*/
d413 1
a413 1
		printf("%s: could not map desc DMA memory\n",
d555 1
a555 1
		printf("%s: could not map desc DMA memory\n",
d1471 1
a1471 1
		printf("%s: could not map mbuf (error %d)\n",
d1632 1
a1632 1
			printf("%s: could not map mbuf (error %d)\n",
d1668 1
a1668 1
		printf("%s: could not map mbuf (error %d)\n",
d1696 1
a1696 1
			printf("%s: could not map mbuf (error %d)\n",
@


1.46
log
@Undo m_defrag().

m_defrag() does not work.  It seems to assume that if the length of
the mbuf passed as parameter is less than MHLEN, then it is an mbuf
header and not a cluster (or something like that.)
It thus fails miserably in the bcopy path.
I don't have the time to investigate further into this.

Thanks to Okan Demirmen for reporting the issue on a ral(4) RT2560.
The RT2560 chipset does not support TX scatter and thus m_defrag()
was called much more often than in other drivers using m_defrag()
where it was less noticeable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.45 2008/11/25 21:43:57 damien Exp $	*/
d1675 1
a1675 1
		MGETHDR(m1, MT_DATA, M_DONTWAIT);
@


1.45
log
@use shiny new m_defrag() and nitems() instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.44 2008/08/27 09:05:03 damien Exp $	*/
d1549 1
d1675 2
a1676 1
		if (m_defrag(m0, M_DONTWAIT) != 0) {
d1678 9
a1686 1
			return ENOMEM;
d1688 5
@


1.44
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.43 2008/08/14 16:02:24 damien Exp $	*/
a1548 1
	struct mbuf *mnew;
d1674 1
a1674 3

		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
a1677 15
		M_DUP_PKTHDR(mnew, m0);
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(mnew, M_DONTWAIT);
			if (!(mnew->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(mnew);
				return ENOMEM;
			}
		}

		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(mnew, caddr_t));
		m_freem(m0);
		mnew->m_len = mnew->m_pkthdr.len;
		m0 = mnew;

a2371 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d2387 1
a2387 1
	for (i = 0; i < N(rt2661_def_bbp); i++) {
a2399 1
#undef N
a2404 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d2497 1
a2497 1
	for (i = 0; i < N(rt2661_def_mac); i++)
d2548 1
a2548 1
	RAL_READ_REGION_4(sc, RT2661_STA_CSR0, sta, N(sta));
a2571 1
#undef N
@


1.43
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.42 2008/07/21 18:43:19 damien Exp $	*/
d104 1
d106 1
d155 1
d157 1
d253 2
a255 1
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
d257 1
d814 1
d818 1
d1155 1
d1181 1
d1251 1
d1254 1
d1509 1
d1515 1
d2261 1
d2270 1
d2558 1
d2560 1
d2798 1
d2851 1
d2863 1
d2871 1
a2871 1

d2880 1
d2883 1
a2883 1

@


1.42
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.41 2008/04/16 18:32:15 damien Exp $	*/
a1144 7

	/*
	 * In HostAP mode, ieee80211_input() will enqueue packets in if_snd
	 * without calling if_start().
	 */
	if (!IFQ_IS_EMPTY(&ifp->if_snd) && !(ifp->if_flags & IFF_OACTIVE))
		rt2661_start(ifp);
@


1.41
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.40 2007/11/17 14:29:11 damien Exp $	*/
d998 1
d1119 4
a1122 1
		ieee80211_input(ifp, m, ni, desc->rssi, 0);
@


1.40
log
@RT2560+RT2661: update the physical address in the RX descriptor after
bus_dmamap_load() in the case where the same mbuf is reloaded.
RT2661: remove a 2x prototype, fix an error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.39 2007/10/15 01:37:49 fgsch Exp $	*/
d255 2
a256 1
	    IEEE80211_C_WEP;		/* s/w WEP */
a1445 1
	struct ifnet *ifp = &ic->ic_if;
a1458 11
	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

d1491 2
a1532 1
	struct ifnet *ifp = &ic->ic_if;
d1537 1
d1545 4
a1548 3
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
@


1.39
log
@more remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.38 2007/09/07 19:05:05 damien Exp $	*/
a156 1
void		rt2661_shutdown(void *);
d334 1
d364 1
a769 1
	int error = 0;
d825 1
a825 1
	return (error != 0) ? error : sc->sc_newstate(ic, nstate, arg);
d1066 2
d2665 2
a2666 1
		printf("timeout waiting for MCU to initialize\n");
@


1.38
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.37 2007/08/28 18:34:38 deraadt Exp $	*/
a1599 1
		uint16_t dur;
@


1.37
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.36 2007/03/08 18:50:57 deraadt Exp $	*/
d422 1
a422 1
	    M_NOWAIT);
a429 1
	memset(ring->data, 0, count * sizeof (struct rt2661_tx_data));
d564 1
a564 1
	    M_NOWAIT);
a574 1
	memset(ring->data, 0, count * sizeof (struct rt2661_rx_data));
d673 2
a674 6
	struct rt2661_node *rn;

	rn = malloc(sizeof (struct rt2661_node), M_DEVBUF, M_NOWAIT);
	if (rn != NULL)
		bzero(rn, sizeof (struct rt2661_node));
	return (struct ieee80211_node *)rn;
@


1.36
log
@XXX commit a workaround (as found in a few other drivers) for the
divide by zero rate bug.  Someone has to find the source of this
bug one day; from stephen@@sock.org.uk, ok niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.35 2007/01/03 18:16:43 claudio Exp $	*/
d2432 1
a2432 1
	int i, ntries;
d2459 3
a2461 3
		if (loadfirmware(name, &ucode, &size) != 0) {
			printf("%s: could not read microcode %s\n",
			    sc->sc_dev.dv_xname, name);
@


1.35
log
@M_DUP_PKTHDR() cleanup. On static buffers M_DUP_PKTHDR() will leak mbuf tags.
See similar rum(4) commit for more info. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.34 2006/12/17 16:24:00 damien Exp $	*/
d1579 2
@


1.34
log
@fix index of ERP information element in beacons.
still ugly, but correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.33 2006/12/03 16:39:13 damien Exp $	*/
a1106 1
			M_DUP_PKTHDR(&mb, m);
d1110 3
a1112 1
			mb.m_pkthdr.len += mb.m_len;
a1492 1
		M_DUP_PKTHDR(&mb, m0);
d1496 3
a1498 1
		mb.m_pkthdr.len += mb.m_len;
a1718 1
		M_DUP_PKTHDR(&mb, m0);
d1722 3
a1724 1
		mb.m_pkthdr.len += mb.m_len;
@


1.33
log
@fix handling of the SIOCS80211CHANNEL ioctl in monitor mode:
don't call xxx_set_chan() if the interface is not up&running.

patch from Steffen Schuetz (st dot sch at gmx dot net) with
minor modifications by me.

closes kernel/5313
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.32 2006/11/26 11:14:18 deraadt Exp $	*/
d2831 6
a2836 4
		    8 + 2 + 2 + 2 + ni->ni_esslen + 2 + 1 +
		    ((ic->ic_opmode == IEEE80211_M_IBSS) ? 3 : 6) +
		    2 + ni->ni_rates.rs_nrates +
		    ((ni->ni_rates.rs_nrates > IEEE80211_RATE_SIZE) ? 2 : 0) +
@


1.32
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.31 2006/11/13 20:06:38 damien Exp $	*/
d260 2
a261 1
		ic->ic_sup_rates[IEEE80211_MODE_11A] = ieee80211_std_rateset_11a;
d1898 3
a1900 1
			rt2661_set_chan(sc, ic->ic_ibss_chan);
@


1.31
log
@first round of commits for proper 11b/g protection support:
- use the newly introduced ieee80211_get_rts() and
  ieee80211_get_cts_to_self() functions.
- use CTS-to-self instead of RTS/CTS to protect OFDM frames in
  a mixed 11b/g BSS.
- make sure multicast frames are sent using CCK modulation.

remove support for 5GHz radios in ral(4) RT2560 and ural(4).
i'm not aware of any such adapters on the market and 11a code
is known to be broken.

some cleanup while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.29 2006/10/22 12:14:44 damien Exp $	*/
a158 12
/*
 * Supported rates for 802.11a/b/g modes (in 500Kbps unit).
 */
static const struct ieee80211_rateset rt2661_rateset_11a =
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };

static const struct ieee80211_rateset rt2661_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

static const struct ieee80211_rateset rt2661_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d260 1
a260 1
		ic->ic_sup_rates[IEEE80211_MODE_11A] = rt2661_rateset_11a;
d281 2
a282 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = rt2661_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = rt2661_rateset_11g;
@


1.30
log
@Fix dynamic tuning of the radio sensitivity I broke when moving from
rssadapt(9) to AMRR.

pointed out by Erki Malling on misc@@
@
text
@d109 1
a109 1
uint8_t		rt2661_rxrate(struct rt2661_rx_desc *);
a118 2
struct		mbuf *rt2661_get_rts(struct rt2661_softc *,
		    struct ieee80211_frame *, uint16_t);
a345 1

a461 2
	struct rt2661_tx_desc *desc;
	struct rt2661_tx_data *data;
d465 2
a466 2
		desc = &ring->desc[i];
		data = &ring->data[i];
a494 1
	struct rt2661_tx_data *data;
d508 1
a508 1
			data = &ring->data[i];
a516 1

a533 2
	struct rt2661_rx_desc *desc;
	struct rt2661_rx_data *data;
d589 2
a590 2
		desc = &sc->rxq.desc[i];
		data = &sc->rxq.data[i];
a606 1

a652 1
	struct rt2661_rx_data *data;
d666 1
a666 1
			data = &ring->data[i];
d790 1
a793 2
		timeout_del(&sc->amrr_to);

a910 1
	uint32_t val;
d914 1
a914 1
		val = RAL_READ(sc, RT2661_STA_CSR4);
a974 3
	struct rt2661_tx_desc *desc;
	struct rt2661_tx_data *data;

d976 2
a977 2
		desc = &txq->desc[txq->next];
		data = &txq->data[txq->next];
a1012 2
	struct rt2661_rx_desc *desc;
	struct rt2661_rx_data *data;
d1019 2
a1020 2
		desc = &sc->rxq.desc[sc->rxq.cur];
		data = &sc->rxq.data[sc->rxq.cur];
a1057 1

d1282 1
a1282 1
rt2661_rxrate(struct rt2661_rx_desc *desc)
a1311 1
 * XXX: this should depend on the destination node basic rate set.
a1549 32
/*
 * Build a RTS control frame.
 */
struct mbuf *
rt2661_get_rts(struct rt2661_softc *sc, struct ieee80211_frame *wh,
    uint16_t dur)
{
	struct ieee80211_frame_rts *rts;
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		sc->sc_ic.ic_stats.is_tx_nombuf++;
		printf("%s: could not allocate RTS frame\n",
		    sc->sc_dev.dv_xname);
		return NULL;
	}

	rts = mtod(m, struct ieee80211_frame_rts *);

	rts->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_CTL |
	    IEEE80211_FC0_SUBTYPE_RTS;
	rts->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	*(uint16_t *)rts->i_dur = htole16(dur);
	IEEE80211_ADDR_COPY(rts->i_ra, wh->i_addr1);
	IEEE80211_ADDR_COPY(rts->i_ta, wh->i_addr2);

	m->m_pkthdr.len = m->m_len = sizeof (struct ieee80211_frame_rts);

	return m;
}

d1563 1
a1563 1
	int rate, useprot, error;
a1566 7
	if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
	} else
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	rate &= IEEE80211_RATE_VAL;

d1576 14
d1597 16
a1612 14
	/*-
	 * IEEE Std 802.11-1999, pp 82: "A STA shall use an RTS/CTS exchange
	 * for directed frames only when the length of the MPDU is greater
	 * than the length threshold indicated by" ic_rtsthreshold.
	 *
	 * IEEE Std 802.11-2003g, pp 13: "ERP STAs shall use protection
	 * mechanism (such as RTS/CTS or CTS-to-self) for ERP-OFDM MPDUs of
	 * type Data or an MMPDU".
	 */
	useprot = !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (m0->m_pkthdr.len + IEEE80211_CRC_LEN > ic->ic_rtsthreshold ||
	     ((ic->ic_flags & IEEE80211_F_USEPROT) && RAL_RATE_IS_OFDM(rate)));
	if (useprot) {
		struct mbuf *m;
a1613 1
		int rtsrate, ackrate;
d1615 2
a1616 2
		rtsrate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;
		ackrate = rt2661_ack_rate(ic, rate);
d1618 1
a1618 2
		dur = rt2661_txtime(m0->m_pkthdr.len + 4, rate, ic->ic_flags) +
		      rt2661_txtime(RAL_CTS_SIZE, rtsrate, ic->ic_flags) +
d1620 10
a1629 5
		      3 * sc->sifs;

		m = rt2661_get_rts(sc, wh, dur);
		if (m == NULL) {
			printf("%s: could not allocate RTS frame\n",
d1638 1
a1638 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
d1643 1
a1643 1
			m_freem(m);
d1648 1
d1650 1
a1650 1
		ieee80211_ref_node(ni);
d1652 1
a1652 2
		data->m = m;
		data->ni = ni;
d1654 4
a1657 3
		rt2661_setup_tx_desc(sc, desc, RT2661_TX_NEED_ACK |
		    RT2661_TX_MORE_FRAG, 0, m->m_pkthdr.len, rtsrate,
		    data->map->dm_segs, data->map->dm_nsegs, ac);
a1689 1

d2087 1
a2087 1
	} else if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
d2091 2
a2092 2
		/* 11g basic rates: 1, 2, 5.5, 11, 6, 12, 24Mbps */
		RAL_WRITE(sc, RT2661_TXRX_CSR5, 0x15f);
a2395 1
	uint8_t val;
d2399 1
a2399 1
		val = rt2661_bbp_read(sc, 0);
@


1.29
log
@replace rssadapt(9) with amrr for automatic rate control.
as a side-effect, this should fix all the "bogus xmit rate" panics
users have been complaining about for some time when operating in
HostAP mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.28 2006/10/18 21:11:02 mglocker Exp $	*/
d1150 1
a1150 1
		ieee80211_input(ifp, m, ni, rssi, 0);
d1157 1
@


1.28
log
@Fix packet length for RX bpf mtap.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.27 2006/09/18 16:20:20 damien Exp $	*/
d59 1
a59 1
#include <net80211/ieee80211_rssadapt.h>
a90 2
void		rt2661_node_copy(struct ieee80211com *ic,
		    struct ieee80211_node *, const struct ieee80211_node *);
d95 2
d207 4
a210 2
	timeout_set(&sc->scan_ch, rt2661_next_scan, sc);
	timeout_set(&sc->rssadapt_ch, rt2661_updatestats, sc);
d319 1
a319 1
	ic->ic_node_copy = rt2661_node_copy;
d370 2
a371 2
	timeout_del(&sc->scan_ch);
	timeout_del(&sc->rssadapt_ch);
d700 3
a702 13
	if (rn == NULL)
		return NULL;

	memset(rn, 0, sizeof (struct rt2661_node));

	return &rn->ni;
}

void
rt2661_node_copy(struct ieee80211com *ic, struct ieee80211_node *dst,
    const struct ieee80211_node *src)
{
	*(struct rt2661_node *)dst = *(const struct rt2661_node *)src;
d730 1
d732 1
d735 1
d744 1
d747 1
a747 1
	ieee80211_rssadapt_updatestats(&rn->rssadapt);
d751 1
a751 1
 * This function is called periodically (every 100ms) in RUN state to update
d759 1
d761 1
d768 1
a768 1
	if (++sc->ncalls == 10) {
d770 12
a781 2
		sc->ncalls = 0;
	}
d783 5
a787 1
	timeout_add(&sc->rssadapt_ch, hz / 10);
d800 1
a800 1
	timeout_del(&sc->scan_ch);
d804 1
a804 1
		timeout_del(&sc->rssadapt_ch);
d815 1
a815 1
		timeout_add(&sc->scan_ch, hz / 5);
d840 5
d848 1
a848 1
			timeout_add(&sc->rssadapt_ch, hz / 10);
d949 3
a951 4
			if (retrycnt == 0 && data->id.id_node != NULL) {
				ieee80211_rssadapt_raise_rate(ic,
				    &rn->rssadapt, &data->id);
			}
d958 2
a959 4
			if (data->id.id_node != NULL) {
				ieee80211_rssadapt_lower_rate(ic, data->ni,
				    &rn->rssadapt, &data->id);
			}
a1030 1
	struct rt2661_node *rn;
d1150 1
a1150 6
		ieee80211_input(ifp, m, ni, desc->rssi, 0);

		/* give rssi to the rate adatation algorithm */
		rn = (struct rt2661_node *)ni;
		rssi = rt2661_get_rssi(sc, desc->rssi);
		ieee80211_rssadapt_input(ic, ni, &rn->rssadapt, rssi);
a1609 2
	struct rt2661_node *rn;
	struct ieee80211_rateset *rs;
a1617 1
	/* XXX this should be reworked! */
d1619 4
a1622 13
		if (ic->ic_curmode != IEEE80211_MODE_AUTO)
			rs = &ic->ic_sup_rates[ic->ic_curmode];
		else
			rs = &ic->ic_sup_rates[IEEE80211_MODE_11G];

		rate = rs->rs_rates[ic->ic_fixed_rate];
	} else {
		rs = &ni->ni_rates;
		rn = (struct rt2661_node *)ni;
		ni->ni_txrate = ieee80211_rssadapt_choose(&rn->rssadapt, rs,
		    wh, m0->m_pkthdr.len, -1, NULL, 0);
		rate = rs->rs_rates[ni->ni_txrate];
	}
a1623 2
	if (rate == 0)
		rate = 2;	/* fallback to 1Mbps; should not happen */
a1692 3
		/* RTS frames are not taken into account for rssadapt */
		data->id.id_node = NULL;

a1778 9
	/* remember link conditions for rate control algorithm */
	if (ic->ic_fixed_rate == -1) {
		data->id.id_len = m0->m_pkthdr.len;
		data->id.id_rateidx = ni->ni_txrate;
		data->id.id_node = ni;
		data->id.id_rssi = ni->ni_rssi;
	} else
		data->id.id_node = NULL;

d2874 1
a2874 1
	 * frames but ieee80211_beacon_alloc() don't store offsets for us.
@


1.27
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.26 2006/08/09 07:46:37 damien Exp $	*/
d1126 1
a1126 1
			mb.m_len = sc->sc_txtap_len;
@


1.26
log
@flags for register TXRX_CSR4 were shifted one bit too much on the left.
this has probably affected short preamble support as well as hardware
multi-rate retries settings.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.25 2006/08/03 09:28:13 damien Exp $	*/
d1860 1
a1860 1
			IFQ_DEQUEUE(&ifp->if_snd, m0);
a1864 1
				IF_PREPEND(&ifp->if_snd, m0);
d1868 1
@


1.25
log
@802.11a uses a 16 microseconds short interframe space.
With this change, I now have a working 802.11a ral-based AP.
Fix rt2661_set_macaddr() so that we don't override the "unicast to me"
flag in RT2661_MAC_CSR3 when setting the MAC address.

Thanks to wim@@ for donating a RT2561 a/b/g adapter.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.24 2006/07/18 16:40:30 damien Exp $	*/
d264 1
a264 1
	    IEEE80211_C_HOSTAP |	/* HostAp mode supported */
@


1.24
log
@modify interrupt handlers to exit early and return 0 on shared interrupts.

pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.23 2006/06/18 18:44:04 damien Exp $	*/
a1285 2
#define RAL_SIFS	10	/* us */

d1530 1
a1530 1
		    RAL_SIFS;
d1670 1
a1670 1
		      3 * RAL_SIFS;
d1801 1
a1801 1
		    ic->ic_flags) + RAL_SIFS;
d2198 3
d2297 1
a2297 1
	tmp = addr[4] | addr[5] << 8;
@


1.23
log
@- implement new ic_updateslot() callback.
- in hostap mode, we defer update of the slot time until all associated
  STAs are notified with updated beacons.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.22 2006/06/18 12:32:46 damien Exp $	*/
d1226 5
d1235 4
a1241 6

	r1 = RAL_READ(sc, RT2661_INT_SOURCE_CSR);
	RAL_WRITE(sc, RT2661_INT_SOURCE_CSR, r1);

	r2 = RAL_READ(sc, RT2661_MCU_INT_SOURCE_CSR);
	RAL_WRITE(sc, RT2661_MCU_INT_SOURCE_CSR, r2);
@


1.22
log
@enable packet bursting when operating as a STA.
limit bursts to 8 frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.21 2006/06/14 19:31:47 damien Exp $	*/
d141 2
a142 1
void		rt2661_update_slot(struct rt2661_softc *);
d318 1
d817 1
a817 1
			rt2661_update_slot(sc);
d1173 4
d1180 17
a1196 1
	/* do nothing */
d1364 1
a1364 1
		/* IEEE Std 802.11a-1999, pp. 37 */
d2316 17
a2332 1
rt2661_update_slot(struct rt2661_softc *sc)
d2343 2
d2857 1
d2862 1
a2862 1
	m0 = ieee80211_beacon_alloc(ic, ic->ic_bss);
d2870 1
a2870 1
	rate = IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan) ? 12 : 2;
d2883 17
@


1.21
log
@must use RTS/CTS protection when sending frames at OFDM rates in a BSS
with non-ERP STAs.  some bits are missing in net80211 though, so this
code won't be triggered yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.20 2006/06/10 20:31:59 damien Exp $	*/
d1617 7
a1691 5
		/*
		 * IEEE Std 802.11-1999: "when an RTS/CTS exchange is used, the
		 * asynchronous data frame shall be transmitted after the CTS
		 * frame and a SIFS period".
		 */
@


1.20
log
@- simplify allocation/free/reset of QoS Tx rings
- move default MAC/BBP/RF settings from rt2661.c to rt2661reg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.19 2006/06/08 19:58:44 damien Exp $	*/
a185 3
/*
 * Default settings for RF registers; values taken from the reference driver.
 */
d1118 2
a1119 3
			tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
			tap->wr_chan_flags =
			    htole16(ic->ic_ibss_chan->ic_flags);
a1170 1
/* ARGSUSED */
d1488 2
a1489 2
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
d1510 1
a1510 1
		/* tell hardware to add timestamp in probe responses */
d1585 1
a1585 1
	int rate, error;
d1617 1
a1617 1
	/*
d1620 5
a1624 1
	 * than the length threshold indicated by [...]" ic_rtsthreshold.
d1626 4
a1629 2
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    m0->m_pkthdr.len + IEEE80211_CRC_LEN > ic->ic_rtsthreshold) {
d1643 6
d1686 1
a1686 1
		 * IEEE Std 802.11-1999: when an RTS/CTS exchange is used, the
d1688 1
a1688 1
		 * frame and a SIFS period.
d1690 1
a1690 1
		flags |= RT2661_TX_LONG_RETRY | RT2661_TX_IFS;
d1748 2
a1749 2
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
d1827 1
a1827 2
				bpf_mtap(ic->ic_rawbpf, m0,
				    BPF_DIRECTION_OUT);
d2921 1
a2921 1
	
d2949 1
a2949 1
	
a2951 1

@


1.19
log
@Keep track of the average RSSI using an Exponential Moving Average (EMA).
Use it to dynamically tune radio receive sensitivity.

The idea is simple:
- increase sensitivity when the RSSI is bad to optimize throughput on
  long distance to the AP, and
- decrease sensitivity when the RSSI is good to reduce noise level and
  optimize throughput on short distance to the AP

The EMA allows to smooth RSSI variations so we don't end up changing the
sensitivity too frequently.  We check if it would be worth updating the
sensitivity every one second.
RSSI thresholds were taken from the Ralink Tech. Linux driver.


Also, clean a few things while I'm here:
- account for FCS when determining if RTS protection must be used
- fix check for whether WEP encryption is needed or not
- encrypt mgmt frames if we need to (shared authmode)
- cosmetic tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.18 2006/06/01 16:24:22 robert Exp $	*/
a171 3
/*
 * Default values for MAC registers; values taken from the reference driver.
 */
d176 1
a176 25
	{ RT2661_TXRX_CSR0,        0x0000b032 },
	{ RT2661_TXRX_CSR1,        0x9eb39eb3 },
	{ RT2661_TXRX_CSR2,        0x8a8b8c8d },
	{ RT2661_TXRX_CSR3,        0x00858687 },
	{ RT2661_TXRX_CSR7,        0x2e31353b },
	{ RT2661_TXRX_CSR8,        0x2a2a2a2c },
	{ RT2661_TXRX_CSR15,       0x0000000f },
	{ RT2661_MAC_CSR6,         0x00000fff },
	{ RT2661_MAC_CSR8,         0x016c030a },
	{ RT2661_MAC_CSR10,        0x00000718 },
	{ RT2661_MAC_CSR12,        0x00000004 },
	{ RT2661_MAC_CSR13,        0x0000e000 },
	{ RT2661_SEC_CSR0,         0x00000000 },
	{ RT2661_SEC_CSR1,         0x00000000 },
	{ RT2661_SEC_CSR5,         0x00000000 },
	{ RT2661_PHY_CSR1,         0x000023b0 },
	{ RT2661_PHY_CSR5,         0x060a100c },
	{ RT2661_PHY_CSR6,         0x00080606 },
	{ RT2661_PHY_CSR7,         0x00000a08 },
	{ RT2661_PCI_CFG_CSR,      0x3cca4808 },
	{ RT2661_AIFSN_CSR,        0x00002273 },
	{ RT2661_CWMIN_CSR,        0x00002344 },
	{ RT2661_CWMAX_CSR,        0x000034aa },
	{ RT2661_TEST_MODE_CSR,    0x00000200 },
	{ RT2661_M2H_CMD_DONE_CSR, 0xffffffff }
a178 3
/*
 * Default values for BBP registers; values taken from the reference driver.
 */
d183 1
a183 25
	{   3, 0x00 },
	{  15, 0x30 },
	{  17, 0x20 },
	{  21, 0xc8 },
	{  22, 0x38 },
	{  23, 0x06 },
	{  24, 0xfe },
	{  25, 0x0a },
	{  26, 0x0d },
	{  34, 0x12 },
	{  37, 0x07 },
	{  39, 0xf8 },
	{  41, 0x60 },
	{  53, 0x10 },
	{  54, 0x18 },
	{  60, 0x10 },
	{  61, 0x04 },
	{  62, 0x04 },
	{  75, 0xfe },
	{  86, 0xfe },
	{  88, 0xfe },
	{  90, 0x0f },
	{  99, 0x00 },
	{ 102, 0x16 },
	{ 107, 0x04 }
d191 3
a193 47
	uint32_t	r1;
	uint32_t	r2;
	uint32_t	r3;
	uint32_t	r4;
} rt2661_rf5225_1[] = {
	{   1, 0x00b33, 0x011e1, 0x1a014, 0x30282 },
	{   2, 0x00b33, 0x011e1, 0x1a014, 0x30287 },
	{   3, 0x00b33, 0x011e2, 0x1a014, 0x30282 },
	{   4, 0x00b33, 0x011e2, 0x1a014, 0x30287 },
	{   5, 0x00b33, 0x011e3, 0x1a014, 0x30282 },
	{   6, 0x00b33, 0x011e3, 0x1a014, 0x30287 },
	{   7, 0x00b33, 0x011e4, 0x1a014, 0x30282 },
	{   8, 0x00b33, 0x011e4, 0x1a014, 0x30287 },
	{   9, 0x00b33, 0x011e5, 0x1a014, 0x30282 },
	{  10, 0x00b33, 0x011e5, 0x1a014, 0x30287 },
	{  11, 0x00b33, 0x011e6, 0x1a014, 0x30282 },
	{  12, 0x00b33, 0x011e6, 0x1a014, 0x30287 },
	{  13, 0x00b33, 0x011e7, 0x1a014, 0x30282 },
	{  14, 0x00b33, 0x011e8, 0x1a014, 0x30284 },

	{  36, 0x00b33, 0x01266, 0x26014, 0x30288 },
	{  40, 0x00b33, 0x01268, 0x26014, 0x30280 },
	{  44, 0x00b33, 0x01269, 0x26014, 0x30282 },
	{  48, 0x00b33, 0x0126a, 0x26014, 0x30284 },
	{  52, 0x00b33, 0x0126b, 0x26014, 0x30286 },
	{  56, 0x00b33, 0x0126c, 0x26014, 0x30288 },
	{  60, 0x00b33, 0x0126e, 0x26014, 0x30280 },
	{  64, 0x00b33, 0x0126f, 0x26014, 0x30282 },

	{ 100, 0x00b33, 0x0128a, 0x2e014, 0x30280 },
	{ 104, 0x00b33, 0x0128b, 0x2e014, 0x30282 },
	{ 108, 0x00b33, 0x0128c, 0x2e014, 0x30284 },
	{ 112, 0x00b33, 0x0128d, 0x2e014, 0x30286 },
	{ 116, 0x00b33, 0x0128e, 0x2e014, 0x30288 },
	{ 120, 0x00b33, 0x012a0, 0x2e014, 0x30280 },
	{ 124, 0x00b33, 0x012a1, 0x2e014, 0x30282 },
	{ 128, 0x00b33, 0x012a2, 0x2e014, 0x30284 },
	{ 132, 0x00b33, 0x012a3, 0x2e014, 0x30286 },
	{ 136, 0x00b33, 0x012a4, 0x2e014, 0x30288 },
	{ 140, 0x00b33, 0x012a6, 0x2e014, 0x30280 },

	{ 149, 0x00b33, 0x012a8, 0x2e014, 0x30287 },
	{ 153, 0x00b33, 0x012a9, 0x2e014, 0x30289 },
	{ 157, 0x00b33, 0x012ab, 0x2e014, 0x30281 },
	{ 161, 0x00b33, 0x012ac, 0x2e014, 0x30283 },
	{ 165, 0x00b33, 0x012ad, 0x2e014, 0x30285 }

d195 1
a195 41
	{   1, 0x00b33, 0x011e1, 0x1a014, 0x30282 },
	{   2, 0x00b33, 0x011e1, 0x1a014, 0x30287 },
	{   3, 0x00b33, 0x011e2, 0x1a014, 0x30282 },
	{   4, 0x00b33, 0x011e2, 0x1a014, 0x30287 },
	{   5, 0x00b33, 0x011e3, 0x1a014, 0x30282 },
	{   6, 0x00b33, 0x011e3, 0x1a014, 0x30287 },
	{   7, 0x00b33, 0x011e4, 0x1a014, 0x30282 },
	{   8, 0x00b33, 0x011e4, 0x1a014, 0x30287 },
	{   9, 0x00b33, 0x011e5, 0x1a014, 0x30282 },
	{  10, 0x00b33, 0x011e5, 0x1a014, 0x30287 },
	{  11, 0x00b33, 0x011e6, 0x1a014, 0x30282 },
	{  12, 0x00b33, 0x011e6, 0x1a014, 0x30287 },
	{  13, 0x00b33, 0x011e7, 0x1a014, 0x30282 },
	{  14, 0x00b33, 0x011e8, 0x1a014, 0x30284 },

	{  36, 0x00b35, 0x11206, 0x26014, 0x30280 },
	{  40, 0x00b34, 0x111a0, 0x26014, 0x30280 },
	{  44, 0x00b34, 0x111a1, 0x26014, 0x30286 },
	{  48, 0x00b34, 0x111a3, 0x26014, 0x30282 },
	{  52, 0x00b34, 0x111a4, 0x26014, 0x30288 },
	{  56, 0x00b34, 0x111a6, 0x26014, 0x30284 },
	{  60, 0x00b34, 0x111a8, 0x26014, 0x30280 },
	{  64, 0x00b34, 0x111a9, 0x26014, 0x30286 },

	{ 100, 0x00b35, 0x11226, 0x2e014, 0x30280 },
	{ 104, 0x00b35, 0x11228, 0x2e014, 0x30280 },
	{ 108, 0x00b35, 0x1122a, 0x2e014, 0x30280 },
	{ 112, 0x00b35, 0x1122c, 0x2e014, 0x30280 },
	{ 116, 0x00b35, 0x1122e, 0x2e014, 0x30280 },
	{ 120, 0x00b34, 0x111c0, 0x2e014, 0x30280 },
	{ 124, 0x00b34, 0x111c1, 0x2e014, 0x30286 },
	{ 128, 0x00b34, 0x111c3, 0x2e014, 0x30282 },
	{ 132, 0x00b34, 0x111c4, 0x2e014, 0x30288 },
	{ 136, 0x00b34, 0x111c6, 0x2e014, 0x30284 },
	{ 140, 0x00b34, 0x111c8, 0x2e014, 0x30280 },

	{ 149, 0x00b34, 0x111cb, 0x2e014, 0x30286 },
	{ 153, 0x00b34, 0x111cd, 0x2e014, 0x30282 },
	{ 157, 0x00b35, 0x11242, 0x2e014, 0x30285 },
	{ 161, 0x00b35, 0x11244, 0x2e014, 0x30285 },
	{ 165, 0x00b35, 0x11246, 0x2e014, 0x30285 }
d205 1
a205 1
	int error, i, ntries;
d234 8
a241 26
	error = rt2661_alloc_tx_ring(sc, &sc->txq[0], RT2661_TX_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Tx ring 0\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}

	error = rt2661_alloc_tx_ring(sc, &sc->txq[1], RT2661_TX_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Tx ring 1\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}

	error = rt2661_alloc_tx_ring(sc, &sc->txq[2], RT2661_TX_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Tx ring 2\n",
		    sc->sc_dev.dv_xname);
		goto fail3;
	}

	error = rt2661_alloc_tx_ring(sc, &sc->txq[3], RT2661_TX_RING_COUNT);
	if (error != 0) {
		printf("%s: could not allocate Tx ring 3\n",
		    sc->sc_dev.dv_xname);
		goto fail4;
d248 1
a248 1
		goto fail5;
d255 1
a255 1
		goto fail6;
d356 4
a359 6
fail6:	rt2661_free_tx_ring(sc, &sc->mgtq);
fail5:	rt2661_free_tx_ring(sc, &sc->txq[3]);
fail4:	rt2661_free_tx_ring(sc, &sc->txq[2]);
fail3:	rt2661_free_tx_ring(sc, &sc->txq[1]);
fail2:	rt2661_free_tx_ring(sc, &sc->txq[0]);
fail1:	return ENXIO;
d367 1
d380 2
a381 4
	rt2661_free_tx_ring(sc, &sc->txq[0]);
	rt2661_free_tx_ring(sc, &sc->txq[1]);
	rt2661_free_tx_ring(sc, &sc->txq[2]);
	rt2661_free_tx_ring(sc, &sc->txq[3]);
d2610 1
d2638 2
a2639 4
	rt2661_reset_tx_ring(sc, &sc->txq[0]);
	rt2661_reset_tx_ring(sc, &sc->txq[1]);
	rt2661_reset_tx_ring(sc, &sc->txq[2]);
	rt2661_reset_tx_ring(sc, &sc->txq[3]);
@


1.18
log
@Add powerhooks for ral(4) cards with RT2561 chipset, and also fix
builds with RAL_DEBUG, so we have debug information now.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.17 2006/05/01 08:41:11 damien Exp $	*/
d96 1
a96 1
void		rt2661_rssadapt_updatestats(void *);
a146 1
void		rt2661_power(int, void *);
d149 1
a150 1
void		rt2661_rx_tune(struct rt2661_softc *);
d157 2
d348 1
a348 1
	timeout_set(&sc->rssadapt_ch, rt2661_rssadapt_updatestats, sc);
d499 1
a499 1
	if (sc->sc_sdhook == NULL)
d502 2
d505 1
a505 1
	if (sc->sc_powerhook == NULL)
d508 1
d916 1
a916 1
 * the rate adaptation statistics.
d919 1
a919 1
rt2661_rssadapt_updatestats(void *arg)
d924 10
a933 1
	ieee80211_iterate_nodes(ic, rt2661_iter_func, arg);
d989 2
d1181 1
a1181 1
	int error;
d1302 9
a1310 2
		ieee80211_rssadapt_input(ic, ni, &rn->rssadapt,
		    rt2661_get_rssi(sc, desc->rssi));
d1611 1
d1625 11
a1666 2
	wh = mtod(m0, struct ieee80211_frame *);

d1772 1
a1772 1
	if (ic->ic_flags & IEEE80211_F_WEPON) {
d1787 1
a1787 1
	    m0->m_pkthdr.len > ic->ic_rtsthreshold) {
d1915 1
a1915 1
	/* remember link conditions for rate adaptation algorithm */
d2303 1
a2845 1
#ifdef notyet
d2870 1
d2874 1
a2874 10
	if (dbm >= -35) {
		bbp17 = 0x60;
	} else if (dbm >= -58) {
		bbp17 = hi;
	} else if (dbm >= -66) {
		bbp17 = lo + 0x10;
	} else if (dbm >= -74) {
		bbp17 = lo + 0x08;
	} else {
		/* RSSI < -74dBm, tune using false CCA count */
d2876 2
d2884 1
a2884 1
		if (bbp17 > hi) {
d2886 4
d2891 8
a2898 7
		} else if (cca > 512) {
			if (++bbp17 > hi)
				bbp17 = hi;
		} else if (cca < 100) {
			if (--bbp17 < lo)
				bbp17 = lo;
		}
d2902 1
d2908 1
d3106 1
@


1.17
log
@remove an unused prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.16 2006/04/20 20:31:12 miod Exp $	*/
d72 1
a72 1
int rt2661_debug = 0;
d147 1
d494 12
d528 5
d3032 40
@


1.16
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.15 2006/03/27 20:54:15 damien Exp $	*/
a140 1
int		rt2661_wme_update(struct ieee80211com *);
@


1.15
log
@fixes interrupts processing.

should fix a panic reported by Karel Gardas.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.14 2006/03/25 22:41:43 djm Exp $	*/
d2556 2
a2557 1
			printf("%s: could not enable device\n");
@


1.14
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.13 2006/02/25 13:08:39 damien Exp $	*/
d1050 4
d1326 1
d1333 4
d2739 4
@


1.13
log
@comment code that is currently unused (radar detection and dynamic rx
sensitivity tuning).  fix a typo while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.12 2006/02/25 13:02:10 damien Exp $	*/
d1254 1
a1254 1
			bpf_mtap(sc->sc_drvbpf, &mb);
d1600 1
a1600 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1850 1
a1850 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1921 2
a1922 1
				bpf_mtap(ic->ic_rawbpf, m0);
d1941 1
a1941 1
				bpf_mtap(ifp->if_bpf, m0);
d1948 2
a1949 1
				bpf_mtap(ic->ic_rawbpf, m0);
@


1.13.2.1
log
@MFC:
Fix by damien@@

fixes interrupts processing.

should fix a panic reported by Karel Gardas.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.13 2006/02/25 13:08:39 damien Exp $	*/
a1049 4
		/* if no frame has been sent, ignore */
		if (rn == NULL)
			continue;

a1321 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
a1327 4
	/* don't re-enable interrupts if we're shutting down */
	if (!(ifp->if_flags & IFF_RUNNING))
		return 0;

a2727 4

	/* clear any pending interrupt */
	RAL_WRITE(sc, RT2661_INT_SOURCE_CSR, 0xffffffff);
	RAL_WRITE(sc, RT2661_MCU_INT_SOURCE_CSR, 0xffffffff);
@


1.12
log
@instead of panicing when tx rate is zero, fallback to 1Mbps.
this is a temporary workaround since we should really not see any node
with an empty rate set but it seems to happen in hostap mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.11 2006/02/25 12:56:47 damien Exp $	*/
d150 1
d154 1
d2780 1
d2845 1
a2845 1
 * This is for 802.11d additional regulatory domains.
d2897 1
@


1.11
log
@load the firmware only when necessary (first call to rt2661_init or if the
cardbus socket has been powered off). restore the call to rt2661_init() in
the watchdog since the firmware is not reloaded in this case.
fixes "timeout waiting for BBP" errors seen on some PCI adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.10 2006/02/18 09:41:41 damien Exp $	*/
d1709 2
a1710 3

	/* assert tx rate is non-null so we don't end up dividing by zero */
	KASSERT(rate != 0);
@


1.10
log
@don't try to release references to nodes that have been freed by net80211.
in HostAP mode, when switching to the INIT state, net80211 sends a DISASSOC
and a DEAUTH frame to all associated stations and immediately free all the
nodes while we may still hold references to them in our Tx queues.

hopefully, this should fix PRs 4469/kernel and 4953/kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.9 2006/02/15 17:23:26 damien Exp $	*/
d1971 1
a1971 2
			ifp->if_flags &= ~IFF_UP;
			rt2661_stop(ifp, 1);
d2552 19
a2570 11
	switch (sc->sc_id) {
	case PCI_PRODUCT_RALINK_RT2561:
		name = "ral-rt2561";
		break;
	case PCI_PRODUCT_RALINK_RT2561S:
		name = "ral-rt2561s";
		break;
	case PCI_PRODUCT_RALINK_RT2661:
		name = "ral-rt2661";
		break;
	}
d2572 7
a2578 6
	if (loadfirmware(name, &ucode, &size) != 0) {
		printf("%s: could not read microcode %s\n",
		    sc->sc_dev.dv_xname, name);
		rt2661_stop(ifp, 1);
		return EIO;
	}
a2579 3
	if (rt2661_load_microcode(sc, ucode, size) != 0) {
		printf("%s: could not load 8051 microcode\n",
		    sc->sc_dev.dv_xname);
d2581 1
a2581 2
		rt2661_stop(ifp, 1);
		return EIO;
a2583 2
	free(ucode, M_DEVBUF);

a2706 2
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);	/* free all nodes */

d2711 2
d2740 1
a2740 1
			sc->sc_flags &= ~RT2661_ENABLED;
@


1.9
log
@don't re-init the interface on watchdog timeout.  we need to reload the
firmware which can't be done outside of a process context.
instead, just turn the interface down (rt2661_stop) for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.8 2006/01/14 12:43:27 damien Exp $	*/
d511 1
a511 1
	ieee80211_ifdetach(ifp);
a599 1
	struct ieee80211com *ic = &sc->sc_ic;
d616 5
a620 4
		if (data->ni != NULL) {
			ieee80211_release_node(ic, data->ni);
			data->ni = NULL;
		}
a634 1
	struct ieee80211com *ic = &sc->sc_ic;
d659 5
a663 2
			if (data->ni != NULL)
				ieee80211_release_node(ic, data->ni);
d1900 7
d2705 1
a2705 1
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
@


1.8
log
@- give rate to rx radiotap
- read TSF high 32bit word before low 32bit word to avoid wraparounds
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.5 2006/01/11 21:39:10 damien Exp $	*/
d1962 2
a1963 1
			rt2661_init(ifp);
@


1.7
log
@Correct the length of the rx radiotap to be that of the rx not tx
struct.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.6 2006/01/13 21:09:49 damien Exp $	*/
d108 3
d1233 1
a1234 1
			tsf_hi = RAL_READ(sc, RT2661_TXRX_CSR13);
d1239 1
d1247 1
a1247 1
			mb.m_len = sc->sc_rxtap_len;
d1374 34
@


1.6
log
@- fix short slot time
- add WEP capability flag
- make sure to reset fallback to CCK rates when switching to 802.11a
- give BBP more time to initialize
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.5 2006/01/11 21:39:10 damien Exp $	*/
d1243 1
a1243 1
			mb.m_len = sc->sc_txtap_len;
@


1.5
log
@enable multi-rate retries for frames sent at OFDM rates (with CCK fallback).
fix setting of basic rates.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.4 2006/01/11 21:02:17 damien Exp $	*/
d418 3
a420 1
	    IEEE80211_C_SHPREAMBLE;	/* short preamble supported */
d944 1
a944 1
			rt2661_set_bssid(sc, ic->ic_bss->ni_bssid);
d2133 1
a2133 1
	tmp |= RT2661_MRR_ENABLED;
d2136 1
d2458 1
a2458 1
		DELAY(1);
d2502 2
@


1.4
log
@fix RTS protection mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.3 2006/01/10 21:33:52 damien Exp $	*/
d128 1
d130 1
a130 2
void		rt2661_set_basicrates(struct rt2661_softc *,
		    const struct ieee80211_rateset *);
d939 1
d941 1
a941 1
			rt2661_set_basicrates(sc, &ni->ni_rates);
d2119 19
d2153 1
a2153 2
rt2661_set_basicrates(struct rt2661_softc *sc,
    const struct ieee80211_rateset *rs)
d2155 1
a2155 4
#define RV(r)	((r) & IEEE80211_RATE_VAL)
	uint32_t mask = 0;
	uint8_t rate;
	int i, j;
d2157 10
a2166 13
	for (i = 0; i < rs->rs_nrates; i++) {
		rate = rs->rs_rates[i];

		if (!(rate & IEEE80211_RATE_BASIC))
			continue;

		/*
		 * Find h/w rate index.  We know it exists because the rate
		 * set has already been negotiated.
		 */
		for (j = 0; rt2661_rateset_11g.rs_rates[j] != RV(rate); j++);

		mask |= 1 << j;
a2167 5

	RAL_WRITE(sc, RT2661_TXRX_CSR5, mask);

	DPRINTF(("Setting basic rate mask to 0x%x\n", mask));
#undef RV
@


1.3
log
@add RTS protection mode support.
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.2 2006/01/10 21:20:46 damien Exp $	*/
d1703 1
a1703 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
d1723 1
a1723 1
		    RT2661_TX_MORE_FRAG, 0, m0->m_pkthdr.len, rtsrate,
@


1.2
log
@- use rssadapt(9) as rate control algorithm
- add 802.11 radiotap support
- read 802.11a channels tx power from EEPROM
- read vendor-specific BBP settings from EEPROM
- fix setting of beacons (xflags)
- fix DMA sync in rt2661_rx_intr
- indicate whether RF supports MIMO in dmesg
- add short slot time support
- many cleanups while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: rt2661.c,v 1.1 2006/01/09 20:03:34 damien Exp $	*/
d1646 1
a1646 1
	int error, rate = 48;
d1677 64
@


1.1
log
@- add preliminary support for Ralink Technology RT2561, RT2561S and RT2661
  chipsets in ral(4).
- restructure the code a bit; split ic/ral.c into ic/rt2560.c and ic/rt2661.c
- import the 8051 microcode files required by these chipsets.
- more to come;  there is currently no automatic rate control and some
  features are untested (hostap and ibss modes for instance).  most of
  the pre-802.11n capabilities of the RT2661 chipset are not supported
  (like frame aggregation, piggy-back).  MIMO should work though the
  performance/range gain has not been measured.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a68 2
/*#define RAL_DEBUG*/

d72 1
a72 1
int rt2661_debug = 10;
d90 3
d95 2
d112 1
a112 1
		    struct rt2661_tx_desc *, uint32_t, int, int,
d114 4
a119 2
int		rt2661_tx_mgt(struct rt2661_softc *, struct mbuf *,
		    struct ieee80211_node *);
d126 1
a126 1
int		rt2661_tx_cmd(struct rt2661_softc *, uint8_t, uint8_t, uint8_t);
d139 1
a139 1
void		rt2661_update_slot(struct ifnet *);
a172 1
	{ RT2661_MAC_CSR11,        0x0000000a },
d174 1
a174 1
	{ RT2661_TXRX_CSR1,        0x9eaa9eaf },
d342 1
d466 2
d474 13
d501 1
a501 1
	struct ifnet *ifp =  &sc->sc_ic.ic_if;
d504 1
d822 21
d873 26
d913 2
d937 4
a940 4
		rt2661_set_txpreamble(sc);
		rt2661_set_basicrates(sc, &ni->ni_rates);

		if (ic->ic_opmode != IEEE80211_M_MONITOR)
d942 1
d948 2
a949 1
		if (ic->ic_opmode != IEEE80211_M_MONITOR)
d951 1
d1023 1
d1038 1
d1046 1
a1046 1
			/*if (retrycnt == 0 && data->id.id_node != NULL) {
d1049 2
a1050 1
			}*/
d1056 1
a1056 1
			/*if (data->id.id_node != NULL) {
d1059 1
a1059 1
			}*/
d1070 3
a1087 1
	struct ieee80211com *ic = &sc->sc_ic;
d1108 1
a1108 2
		ieee80211_release_node(ic, data->ni);
		data->ni = NULL;
d1131 1
a1140 3
		if (letoh32(desc->flags) & RT2661_RX_BUSY)
			break;

d1145 3
d1152 1
a1152 1
			 * to receive those frames when we filled RXCSR0.
d1220 27
d1253 5
d1297 1
a1297 1
	rt2661_tx_cmd(sc, RT2661_MCU_CMD_WAKEUP, 0, 0);
a1328 3
	if (r1 & RT2661_TX_DONE)
		rt2661_tx_intr(sc);

d1341 3
d1454 2
a1455 2
    uint32_t flags, int len, int rate, const bus_dma_segment_t *segs,
    int nsegs, int ac)
d1465 2
a1466 1
	desc->xflags = htole16(nsegs << 13);
d1469 1
d1472 1
a1472 2
	    RT2661_LOGCWMAX(10) |
	    RT2661_QID(ac));
d1474 6
a1479 2
	/* remember in which queue this frame was sent */
	desc->id = ac;
d1522 1
a1522 1
	uint32_t flags = 0;	/* XXX HWSEQ */
d1540 19
d1578 3
a1580 2
	rt2661_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate,
	    data->map->dm_segs, data->map->dm_nsegs, RT2661_TXQ_MGT);
d1599 32
d1640 2
d1650 20
d1727 19
d1749 9
d1766 1
a1766 1
	rt2661_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate,
d2019 1
a2019 1
rt2661_tx_cmd(struct rt2661_softc *sc, uint8_t cmd, uint8_t arg0, uint8_t arg1)
d2025 1
a2025 1
	    RT2661_H2M_BUSY | RT2661_TOKEN_NO_INTR << 16 | arg1 << 8 | arg0);
a2147 1
	uint8_t power, bbp94 = 0, bbp3;
d2149 2
d2157 12
a2168 7
	if (IEEE80211_IS_CHAN_2GHZ(c)) {
		power = sc->txpow[chan - 1];
		if (power > 31) {
			bbp94 = RT2661_BBPR94_DEFAULT + (power - 31);
			power = 31;
		}
	} else
d2170 1
a2181 6
	/* select the appropriate RF settings based on what EEPROM says */
	rfprog = (sc->rfprog == 0) ? rt2661_rf5225_1 : rt2661_rf5225_2;

	/* find the settings for this channel */
	for (i = 0; rfprog[i].chan != chan; i++);

d2201 1
a2201 1
	/* enable smart mode for RT2661 */
d2210 1
a2210 1
	if (bbp94 != 0)
d2261 1
a2261 1
rt2661_update_slot(struct ifnet *ifp)
a2262 1
	struct rt2661_softc *sc = ifp->if_softc;
d2279 1
a2279 1
	case RT2661_RF_5325:	return "RT5325";
d2281 1
a2281 1
	case RT2661_RF_2529:	return "RT2529";
a2309 1
	sc->led_mode = (val >> 6)  & 0x7;
d2348 2
a2349 2
	/* read Tx power for all b/g channels */
	for (i = 0; i < 14 / 2; i++) {
d2351 17
a2367 4
		sc->txpow[i * 2] = val >> 8;
		DPRINTF(("Channel=%d Tx power=%d\n", i * 2, val >> 8));
		sc->txpow[i * 2 + 1] = val & 0xff;
		DPRINTF(("Channel=%d Tx power=%d\n", i * 2 + 1, val & 0xff));
d2396 7
d2413 1
a2413 1
	const char *name;
d2787 2
a2788 2
	rt2661_setup_tx_desc(sc, &desc, RT2661_TX_TIMESTAMP | RT2661_TX_HWSEQ,
	    m0->m_pkthdr.len, rate, NULL, 0, RT2661_TXQ_MGT);
@

