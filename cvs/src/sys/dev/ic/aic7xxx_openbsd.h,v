head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.6
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.8
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.14
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.12
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.8
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.6
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.4
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.2
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.19.0.14
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.12
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.8
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	UBC:1.7.0.4
	UBC_SYNC_B:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.26
date	2016.08.17.01.17.54;	author krw;	state Exp;
branches;
next	1.25;
commitid	ABXin5xH6wOo5rmV;

1.25
date	2015.07.17.21.42.49;	author krw;	state Exp;
branches;
next	1.24;
commitid	bEhopXwWgYXDvWRJ;

1.24
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.23;
commitid	uzzBR7hz9ncd4O6G;

1.23
date	2012.02.12.14.30.51;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.02.11.19.02.38;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.04.22.17.23;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.15.10.10.37;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.02.02.20.37;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.28.03.05.39;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.10.11.45.43;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.01.21.49.54;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.12.15.32.12;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.24.04.28.33;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.01.01.36.23;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.17.14.40.55;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.28.21.29.27;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.24.22.45.45;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.21.18.58.48;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.05.05.41.03;	author smurph;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2002.07.01.23.31.05;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.28.00.34.54;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.19.02.49.20;	author millert;	state dead;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.00.04.09;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.28.11.51.00;	author niklas;	state dead;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.03.28.14.05.52;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Move to iopool. No voluntary testers after several years of requests so now
everybody gets to test!
@
text
@/*	$OpenBSD: aic7xxx_openbsd.h,v 1.25 2015/07/17 21:42:49 krw Exp $	*/
/*	$NetBSD: aic7xxx_osm.h,v 1.7 2003/11/02 11:07:44 wiz Exp $	*/

/*
 * OpenBSD platform specific driver option settings, data structures,
 * function declarations and includes.
 *
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2001-2002 Steve Murphree, Jr.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. The name of the author(s) may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.h#14 $
 *
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx_osm.h,v 1.20 2002/12/04 22:51:29 scottl Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
 */

#ifndef _AIC7XXX_OPENBSD_H_
#define _AIC7XXX_OPENBSD_H_

#include "pci.h"		/* for config options */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/queue.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_message.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>

#include <uvm/uvm_extern.h>

#ifdef CAM_NEW_TRAN_CODE
#define AHC_NEW_TRAN_SETTINGS
#endif /* CAM_NEW_TRAN_CODE */

#if NPCI > 0
#define AHC_PCI_CONFIG 1
#endif

#if 0
#define AHC_DEBUG	AHC_SHOW_SENSE | AHC_SHOW_MISC | AHC_SHOW_CMDS
#endif

#ifdef DEBUG
#define bootverbose	1
#else
#define bootverbose	0
#endif
/****************************** Platform Macros *******************************/

#define	SCSI_IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_channel_b.scsibus)
#define	SCSI_SCSI_ID(ahc, sc_link)	\
	(SCSI_IS_SCSIBUS_B(ahc, sc_link) ? ahc->our_id_b : ahc->our_id)
#define	SCSI_CHANNEL(ahc, sc_link)	\
	(SCSI_IS_SCSIBUS_B(ahc, sc_link) ? 'B' : 'A')
#define BUILD_SCSIID(ahc, sc_link, target_id, our_id) \
        ((((target_id) << TID_SHIFT) & TID) | (our_id) \
        | (SCSI_IS_SCSIBUS_B(ahc, sc_link) ? TWIN_CHNLB : 0))

#ifndef offsetof
#define offsetof(type, member)  ((size_t)(&((type *)0)->member))
#endif
/************************* Forward Declarations *******************************/
typedef struct pci_attach_args * ahc_dev_softc_t;

/***************************** Bus Space/DMA **********************************/

/* XXX Need to update Bus DMA for partial map syncs */
#define ahc_dmamap_sync(ahc, dma_tag, dmamap, offset, len, op)		\
	bus_dmamap_sync(dma_tag, dmamap, offset, len, op)

/************************ Tunable Driver Parameters  **************************/
/*
 * The number of DMA segments supported.  The sequencer can handle any number
 * of physically contiguous S/G entries.  To reduce the driver's memory
 * consumption, we limit the number supported to be sufficient to handle
 * the largest mapping supported by the kernel, MAXPHYS.  Assuming the
 * transfer is as fragmented as possible and unaligned, this turns out to
 * be the number of paged sized transfers in MAXPHYS plus an extra element
 * to handle any unaligned residual.  The sequencer fetches SG elements
 * in cacheline sized chucks, so make the number per-transaction an even
 * multiple of 16 which should align us on even the largest of cacheline
 * boundaries.
 */
#define AHC_NSEG (roundup(atop(MAXPHYS) + 1, 16))

/* This driver supports target mode */
//#define AHC_TARGET_MODE 1

#include <dev/ic/aic7xxxvar.h>

/************************** Softc/SCB Platform Data ***************************/
struct ahc_platform_data {
};

struct scb_platform_data {
};

/*
 * Some ISA devices (e.g. on a VLB) can perform 32-bit DMA.  This
 * flag is passed to bus_dmamap_create() to indicate that fact.
 */
#ifndef ISABUS_DMA_32BIT
#define ISABUS_DMA_32BIT	BUS_DMA_BUS1
#endif

/************************** Timer DataStructures ******************************/
typedef struct timeout ahc_timer_t;

/***************************** Core Includes **********************************/
#if AHC_REG_PRETTY_PRINT
#define AIC_DEBUG_REGISTERS 1
#else
#define AIC_DEBUG_REGISTERS 0
#endif

/***************************** Timer Facilities *******************************/
void ahc_timeout(void*);

#define ahc_timer_init callout_init
#define ahc_timer_stop callout_stop

static __inline void
ahc_timer_reset(ahc_timer_t *timer, u_int usec, ahc_callback_t *func, void *arg)
{
	callout_reset(timer, (usec * hz)/1000000, func, arg);
}

static __inline void
ahc_scb_timer_reset(struct scb *scb, u_int usec)
{
	if (!(scb->xs->xs_control & XS_CTL_POLL)) {
		callout_reset(&scb->xs->xs_callout,
			      (usec * hz)/1000000, ahc_timeout, scb);
	}
}

/*************************** Device Access ************************************/
#define ahc_inb(ahc, port)				\
	bus_space_read_1((ahc)->tag, (ahc)->bsh, port)

#define ahc_outb(ahc, port, value)			\
	bus_space_write_1((ahc)->tag, (ahc)->bsh, port, value)

#define ahc_outsb(ahc, port, valp, count)		\
	bus_space_write_multi_1((ahc)->tag, (ahc)->bsh, port, valp, count)

#define ahc_insb(ahc, port, valp, count)		\
	bus_space_read_multi_1((ahc)->tag, (ahc)->bsh, port, valp, count)

static __inline void ahc_flush_device_writes(struct ahc_softc *);

static __inline void
ahc_flush_device_writes(struct ahc_softc *ahc)
{
	bus_space_barrier(ahc->tag, ahc->bsh, 0, 0x100,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	ahc_inb(ahc, INTSTAT);
}

/**************************** Locking Primitives ******************************/

/****************************** OS Primitives *********************************/

/************************** Transaction Operations ****************************/
static __inline void ahc_set_transaction_status(struct scb *, uint32_t);
static __inline void ahc_set_scsi_status(struct scb *, uint32_t);
static __inline uint32_t ahc_get_transaction_status(struct scb *);
static __inline uint32_t ahc_get_scsi_status(struct scb *);
static __inline void ahc_set_transaction_tag(struct scb *, int, u_int);
static __inline u_long ahc_get_transfer_length(struct scb *);
static __inline int ahc_get_transfer_dir(struct scb *);
static __inline void ahc_set_residual(struct scb *, u_long);
static __inline void ahc_set_sense_residual(struct scb *, u_long);
static __inline u_long ahc_get_residual(struct scb *);
static __inline int ahc_perform_autosense(struct scb *);
static __inline uint32_t ahc_get_sense_bufsize(struct ahc_softc *,
    struct scb *);
static __inline void ahc_freeze_scb(struct scb *);
static __inline void ahc_platform_freeze_devq(struct ahc_softc *, struct scb *);
static __inline int  ahc_platform_abort_scbs(struct ahc_softc *, int, char,
    int, u_int, role_t, uint32_t);

static __inline
void ahc_set_transaction_status(struct scb *scb, uint32_t status)
{
	scb->xs->error = status;
}

static __inline
void ahc_set_scsi_status(struct scb *scb, uint32_t status)
{
	scb->xs->status = status;
}

static __inline
uint32_t ahc_get_transaction_status(struct scb *scb)
{
	if (scb->xs->flags & ITSDONE)
		return CAM_REQ_CMP;
	else
		return scb->xs->error;
}

static __inline
uint32_t ahc_get_scsi_status(struct scb *scb)
{
	return (scb->xs->status);
}

static __inline
void ahc_set_transaction_tag(struct scb *scb, int enabled, u_int type)
{
}

static __inline
u_long ahc_get_transfer_length(struct scb *scb)
{
	return (scb->xs->datalen);
}

static __inline
int ahc_get_transfer_dir(struct scb *scb)
{
	return (scb->xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT));
}

static __inline
void ahc_set_residual(struct scb *scb, u_long resid)
{
	scb->xs->resid = resid;
}

static __inline
void ahc_set_sense_residual(struct scb *scb, u_long resid)
{
	scb->xs->resid = resid;
}

static __inline
u_long ahc_get_residual(struct scb *scb)
{
	return (scb->xs->resid);
}

static __inline
int ahc_perform_autosense(struct scb *scb)
{
	/* Return true for OpenBSD */
	return (1);
}

static __inline uint32_t
ahc_get_sense_bufsize(struct ahc_softc *ahc, struct scb *scb)
{
	return (sizeof(struct scsi_sense_data));
}

static __inline void
ahc_freeze_scb(struct scb *scb)
{
}

static __inline void
ahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
{
}

static __inline int
ahc_platform_abort_scbs(struct ahc_softc *ahc, int target,
			char channel, int lun, u_int tag,
			role_t role, uint32_t status)
{
	return (0);
}

static __inline void
ahc_platform_scb_free(struct ahc_softc *ahc, struct scb *scb)
{
	int s;

	s = splbio();

	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0) {
		ahc->flags &= ~AHC_RESOURCE_SHORTAGE;
	}

	timeout_del(&scb->xs->stimeout);

	splx(s);
}

/********************************** PCI ***************************************/
#ifdef AHC_PCI_CONFIG
static __inline uint32_t ahc_pci_read_config(ahc_dev_softc_t, int, int);
static __inline void	 ahc_pci_write_config(ahc_dev_softc_t, int, uint32_t,
    int);
static __inline int	 ahc_get_pci_function(ahc_dev_softc_t);
static __inline int	 ahc_get_pci_slot(ahc_dev_softc_t);
static __inline int	 ahc_get_pci_bus(ahc_dev_softc_t);

int			 ahc_pci_map_registers(struct ahc_softc *);
int			 ahc_pci_map_int(struct ahc_softc *);

static __inline uint32_t
ahc_pci_read_config(ahc_dev_softc_t pci, int reg, int width)
{
	return (pci_conf_read(pci->pa_pc, pci->pa_tag, reg));
}

static __inline void
ahc_pci_write_config(ahc_dev_softc_t pci, int reg, uint32_t value, int width)
{
	pci_conf_write(pci->pa_pc, pci->pa_tag, reg, value);
}

static __inline int
ahc_get_pci_function(ahc_dev_softc_t pci)
{
	return (pci->pa_function);
}

static __inline int
ahc_get_pci_slot(ahc_dev_softc_t pci)
{
	return (pci->pa_device);
}

static __inline int
ahc_get_pci_bus(ahc_dev_softc_t pci)
{
	return (pci->pa_bus);
}

typedef enum
{
	AHC_POWER_STATE_D0,
	AHC_POWER_STATE_D1,
	AHC_POWER_STATE_D2,
	AHC_POWER_STATE_D3
} ahc_power_state;

void ahc_power_state_change(struct ahc_softc *, ahc_power_state);
#endif
/******************************** VL/EISA *************************************/
int aic7770_map_registers(struct ahc_softc *, u_int);
int aic7770_map_int(struct ahc_softc *, int);

/********************************* Debug **************************************/
static __inline void	ahc_print_path(struct ahc_softc *, struct scb *);
static __inline void	ahc_platform_dump_card_state(struct ahc_softc *);

static __inline void
ahc_print_path(struct ahc_softc *ahc, struct scb *scb)
{
	sc_print_addr(scb->xs->sc_link);
}

static __inline void
ahc_platform_dump_card_state(struct ahc_softc *ahc)
{
	/* Nothing to do here for OpenBSD */
	printf("FEATURES = 0x%x, FLAGS = 0x%x, CHIP = 0x%x BUGS =0x%x\n",
	       ahc->features, ahc->flags, ahc->chip, ahc->bugs);
}
/**************************** Transfer Settings *******************************/
void	  ahc_notify_xfer_settings_change(struct ahc_softc *,
					  struct ahc_devinfo *);
void	  ahc_platform_set_tags(struct ahc_softc *, struct ahc_devinfo *, int);

/************************* Initialization/Teardown ****************************/
int	  ahc_platform_alloc(struct ahc_softc *, void *);
void	  ahc_platform_free(struct ahc_softc *);
int	  ahc_map_int(struct ahc_softc *);
int	  ahc_attach(struct ahc_softc *);
int	  ahc_softc_comp(struct ahc_softc *, struct ahc_softc *);
int	  ahc_detach(struct device *, int);

/****************************** Interrupts ************************************/
int                     ahc_platform_intr(void *);
static __inline void    ahc_platform_flushwork(struct ahc_softc *);
static __inline void
ahc_platform_flushwork(struct ahc_softc *ahc)
{
}

/************************ Misc Function Declarations **************************/
void	  ahc_done(struct ahc_softc *, struct scb *);
void	  ahc_send_async(struct ahc_softc *, char, u_int, u_int, ac_code,
    void *);
void	 *ahc_scb_alloc(void *);
void	  ahc_scb_free(void *, void *);

#endif  /* _AIC7XXX_OPENBSD_H_ */
@


1.25
log
@Nuke a bunch of leading and trailing whitespace so I don't go blind
reading this code. No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.24 2014/09/14 14:17:24 jsg Exp $	*/
d430 2
@


1.24
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.23 2012/02/12 14:30:51 deraadt Exp $	*/
d6 1
a6 1
 * function declarations and includes. 
d74 1
a74 1
#if NPCI > 0 
d76 1
a76 1
#endif 
d84 1
a84 1
#else 
d86 1
a86 1
#endif 
d122 1
a122 1
 * boundaries. 
d144 1
a144 1
#endif 
d171 1
a171 1
  	if (!(scb->xs->xs_control & XS_CTL_POLL)) {
d402 1
a402 1
	printf("FEATURES = 0x%x, FLAGS = 0x%x, CHIP = 0x%x BUGS =0x%x\n", 
@


1.23
log
@use the barrier before the inb; not instead of
prompted by kettenis, ok miod, tested on the troublesome machine
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.22 2012/02/11 19:02:38 deraadt Exp $	*/
a54 1
#include <sys/proc.h>
@


1.22
log
@This code used to do a register read to force a barrier -- that is not
sufficient.  Now, use bus_space_barrier explicitly.  This was exposed
by newer gcc on DS20 alpha with ahc(4) controllers using any drives
other than Seagates.  During initial probe the drive vendor/product
string would be empty.
diff from miod; tested by myself and henning
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.21 2011/07/17 22:46:48 matthew Exp $	*/
d198 1
@


1.21
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.20 2011/07/04 22:17:23 matthew Exp $	*/
d196 2
a197 2
	/* XXX Is this sufficient for all architectures??? */
	ahc_inb(ahc, INTSTAT);
@


1.20
log
@Use the SDEV_2NDBUS flag like isp(4) instead of the current
scsi_link::scsibus hack to determine which channel the link is
associated with.

"looks sane" dlg@@, but haven't found any testers yet; committing so
further SCSI refactorings can go in.  dlg@@ or I will back out or fix
if anything breaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.19 2007/09/15 10:10:37 martin Exp $	*/
d91 1
a91 1
	(((sc_link)->flags & SDEV_2NDBUS) != 0)
@


1.19
log
@replace ctob and btoc with ptoa and atop respectively

help and ok miod@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.18 2007/05/02 02:20:37 krw Exp $	*/
d91 1
a91 1
	((sc_link)->scsibus == (ahc)->sc_channel_b.scsibus)
@


1.18
log
@Eliminate unused inline functions and replace ahc_lock() which
resolves to s = splbio() and ahc_unlock() which resolves to splx(s)
with splbio/splx calls.

ok marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.17 2005/12/28 03:05:39 krw Exp $	*/
d125 1
a125 1
#define AHC_NSEG (roundup(btoc(MAXPHYS) + 1, 16))
@


1.17
log
@Oops. Missed file from previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.16 2005/12/10 11:45:43 miod Exp $	*/
a200 14
/* Lock protecting internal data structures */
static __inline void ahc_lockinit(struct ahc_softc *);
static __inline void ahc_lock(struct ahc_softc *, int *);
static __inline void ahc_unlock(struct ahc_softc *, int *);

/* Lock held during command completion to the upper layer */
static __inline void ahc_done_lockinit(struct ahc_softc *);
static __inline void ahc_done_lock(struct ahc_softc *, int *);
static __inline void ahc_done_unlock(struct ahc_softc *, int *);

/* Lock held during ahc_list manipulation and ahc softc frees */
static __inline void ahc_list_lockinit(void);
static __inline void ahc_list_lock(int *);
static __inline void ahc_list_unlock(int *);
a201 48
static __inline void
ahc_lockinit(struct ahc_softc *ahc)
{
}

static __inline void
ahc_lock(struct ahc_softc *ahc, int *flags)
{
	*flags = splbio();
}

static __inline void
ahc_unlock(struct ahc_softc *ahc, int *flags)
{
	splx(*flags);
}

/* Lock held during command completion to the upper layer */
static __inline void
ahc_done_lockinit(struct ahc_softc *ahc)
{
}

static __inline void
ahc_done_lock(struct ahc_softc *ahc, int *flags)
{
}

static __inline void
ahc_done_unlock(struct ahc_softc *ahc, int *flags)
{
}

/* Lock held during ahc_list manipulation and ahc softc frees */
static __inline void
ahc_list_lockinit()
{
}

static __inline void
ahc_list_lock(int *flags)
{
}

static __inline void
ahc_list_unlock(int *flags)
{
}
d321 2
a322 2
	ahc_lock(ahc, &s);
	
d326 1
a326 1
	
d328 2
a329 2
	
	ahc_unlock(ahc, &s);
@


1.16
log
@{en,re}trys -> {en,re}tries; eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.15 2005/06/01 21:49:54 miod Exp $	*/
d385 1
a385 2
	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||
	    (scb->flags & SCB_RECOVERY_SCB) != 0) {
@


1.15
log
@De-inline a few functions if option SMALL_KERNEL, and do not compile
ahc_print_scb() unless option AHC_DEBUG.

Saves about 3KB on alpha RAMDISK{,B}.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.14 2005/02/12 15:32:12 krw Exp $	*/
d115 1
a115 1
 * of physically contiguous S/G entrys.  To reduce the driver's memory
@


1.14
log
@Fix crashes during probe by ensuring that SCSI_IS_SCSIBUS_B() returns
false until scsi bus b is initialized.

Set TWIN_CHNLB bit that is used elsewhere. Missed chunk from last code
sync.

Problem found and fixes tested on HP Proliant ML310 by Valov Oleg.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.13 2004/10/24 04:28:33 krw Exp $	*/
d79 1
d81 1
@


1.13
log
@Shuffle defines around so that ahc and ahd use the aic_ names that
come with the freebsd sources, rather than duplicating those names in
the ahd_ and ahc_ namespaces. Big reduction in delta to freebsd
sources, which reduces noise when updating the code.

No .o differences found on i386.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.12 2004/08/01 01:36:23 krw Exp $	*/
d95 2
a96 1
        ((((target_id) << TID_SHIFT) & TID) | (our_id))
@


1.12
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.11 2004/01/17 14:40:55 krw Exp $	*/
a143 15
/********************************* Byte Order *********************************/
#define ahc_htobe16(x) htobe16(x)
#define ahc_htobe32(x) htobe32(x)
#define ahc_htobe64(x) htobe64(x)
#define ahc_htole16(x) htole16(x)
#define ahc_htole32(x) htole32(x)
#define ahc_htole64(x) htole64(x)
                       
#define ahc_be16toh(x) betoh16(x)
#define ahc_be32toh(x) betoh32(x)
#define ahc_be64toh(x) betoh64(x)
#define ahc_le16toh(x) letoh16(x)
#define ahc_le32toh(x) letoh32(x)
#define ahc_le64toh(x) letoh64(x)

a261 1
#define ahc_delay DELAY
@


1.11
log
@Major stability improvement. Fix a variety of systems and problems
by dealing with various error conditions.

Testing by Marco Peereboom, Olivier Cherrier, Alex Holst, Daniel Lucq,
deraadt@@, beck@@ and others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.10 2003/12/28 21:29:27 krw Exp $	*/
a375 7
	struct scsi_xfer *xs = scb->xs;
	int target;

	target = xs->sc_link->target;
	if (!(scb->flags & SCB_FREEZE_QUEUE)) {
		scb->flags |= SCB_FREEZE_QUEUE;
	}
@


1.10
log
@Give i/o's requeued as a result of aborts, timeouts, etc. a status of
XS_RESET rather than XS_NOERROR. This prevents unfinished i/o's from
being treated as successfully completed ones.

Don't bother setting SCB_REQUEUE in scb->flags since the scb is
immediately thrown away.

Make setting TAG_ENB a little more correct by doing it somewhere both
the initial scb setup and subsequent tag resets have access to.

Fix a typo.

ok miod "I'm not an authoritative person on SCSI issues... though I'm
learning!" @@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx_openbsd.h,v 1.9 2003/12/24 22:45:45 krw Exp $	*/
a327 19
	/*
	 * Assume that enabled == 0, or tstate->tagenable has already
	 * been checked and found to be set.
	 */
	switch (scb->xs->cmd->opcode) {
	case INQUIRY:
	case TEST_UNIT_READY:
	case REQUEST_SENSE:
		/* Don't use tagged i/o on these commands. */
		enabled = 0;
		break;
	default:
		break;
	}

	if (enabled)
		scb->hscb->control |= TAG_ENB;
	else
		scb->hscb->control &= ~TAG_ENB;
@


1.9
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d328 19
@


1.8
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 3
d36 1
a36 1
 * $Id: aic7xxx_openbsd.h,v 1.7 2002/07/05 05:41:03 smurph Exp $
d38 4
a41 2
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx_freebsd.h,v 1.12 2001/07/18 21:39:47 gibbs Exp $
 * $OpenBSD: aic7xxx_openbsd.h,v 1.7 2002/07/05 05:41:03 smurph Exp $
d50 1
a51 1
#include <sys/kernel.h>
a52 5
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcivar.h>

d58 6
d71 3
a73 3
#define AHC_SHOWSENSE	0x01
#define AHC_SHOWMISC	0x02
#define AHC_SHOWCMDS	0x04
d79 1
a79 4
#if 0
#define AHC_DEBUG	AHC_SHOWSENSE | AHC_SHOWMISC | AHC_SHOWCMDS
extern int ahc_debug;
#endif 
d89 1
a89 1
	((sc_link)->scsibus == (ahc)->platform_data->sc_link_b.scsibus)
d95 1
a95 8
        ((((target_id) << TID_SHIFT) & TID) | (our_id) \
        | (SCSI_IS_SCSIBUS_B(ahc, sc_link) ? TWIN_CHNLB : 0))
#define XS_SCSI_ID(xs) \
	((xs)->sc_link->target)
#define XS_LUN(xs) \
	((xs)->sc_link->lun)
#define XS_TCL(xs) \
	BUILD_TCL(XS_SCSI_ID(xs), XS_LUN(xs))
a99 101

/* COMPAT CAM to XS stuff */
#define CAM_DIR_IN		SCSI_DATA_IN
#define AC_TRANSFER_NEG		0
#define AC_SENT_BDR		0
#define AC_BUS_RESET		0
#define CAM_BUS_WILDCARD	((int)~0)
#define CAM_TARGET_WILDCARD	((int)~0)
#define CAM_LUN_WILDCARD	((int)~0)

/* SPI-3 definitions */
#ifndef MSG_SIMPLE_TASK
#define MSG_SIMPLE_TASK		MSG_SIMPLE_Q_TAG
#endif
#ifndef MSG_ORDERED_TASK
#define MSG_ORDERED_TASK	MSG_ORDERED_Q_TAG
#endif 

/*  FreeBSD to OpenBSD message defs */
#define MSG_EXT_PPR_QAS_REQ	MSG_EXT_PPR_PROT_QAS
#define MSG_EXT_PPR_DT_REQ	MSG_EXT_PPR_PROT_DT	
#define MSG_EXT_PPR_IU_REQ      MSG_EXT_PPR_PROT_IUS

/*  FreeBSD bus_space defines */
#define BUS_SPACE_MAXSIZE_24BIT 0xFFFFFF
#define BUS_SPACE_MAXSIZE_32BIT 0xFFFFFFFF
#define BUS_SPACE_MAXSIZE       (64 * 1024) /* Maximum supported size */
#define BUS_SPACE_MAXADDR_24BIT 0xFFFFFF
#define BUS_SPACE_MAXADDR_32BIT 0xFFFFFFFF
#define BUS_SPACE_MAXADDR       0xFFFFFFFF

/* CAM  Status field values (From FreeBSD cam.h 1.10 */
typedef enum {
	CAM_REQ_INPROG,		/* CCB request is in progress */
	CAM_REQ_CMP,		/* CCB request completed without error */
	CAM_REQ_ABORTED,	/* CCB request aborted by the host */
	CAM_UA_ABORT,		/* Unable to abort CCB request */
	CAM_REQ_CMP_ERR,	/* CCB request completed with an error */
	CAM_BUSY,		/* CAM subsystem is busy */
	CAM_REQ_INVALID,	/* CCB request was invalid */
	CAM_PATH_INVALID,	/* Supplied Path ID is invalid */
	CAM_DEV_NOT_THERE,	/* SCSI Device Not Installed/there */
	CAM_UA_TERMIO,		/* Unable to terminate I/O CCB request */
	CAM_SEL_TIMEOUT,	/* Target Selection Timeout */
	CAM_CMD_TIMEOUT,	/* Command timeout */
	CAM_SCSI_STATUS_ERROR,	/* SCSI error, look at error code in CCB */
	CAM_MSG_REJECT_REC,	/* Message Reject Received */
	CAM_SCSI_BUS_RESET,	/* SCSI Bus Reset Sent/Received */
	CAM_UNCOR_PARITY,	/* Uncorrectable parity error occurred */
	CAM_AUTOSENSE_FAIL = 0x10,/* Autosense: request sense cmd fail */
	CAM_NO_HBA,		/* No HBA Detected error */
	CAM_DATA_RUN_ERR,	/* Data Overrun error */
	CAM_UNEXP_BUSFREE,	/* Unexpected Bus Free */
	CAM_SEQUENCE_FAIL,	/* Target Bus Phase Sequence Failure */
	CAM_CCB_LEN_ERR,	/* CCB length supplied is inadequate */
	CAM_PROVIDE_FAIL,	/* Unable to provide requested capability */
	CAM_BDR_SENT,		/* A SCSI BDR msg was sent to target */
	CAM_REQ_TERMIO,		/* CCB request terminated by the host */
	CAM_UNREC_HBA_ERROR,	/* Unrecoverable Host Bus Adapter Error */
	CAM_REQ_TOO_BIG,	/* The request was too large for this host */
	CAM_REQUEUE_REQ,	/*
				 * This request should be requeued to preserve
				 * transaction ordering.  This typically occurs
				 * when the SIM recognizes an error that should
				 * freeze the queue and must place additional
				 * requests for the target at the sim level
				 * back into the XPT queue.
				 */
	CAM_IDE = 0x33,		/* Initiator Detected Error */
	CAM_RESRC_UNAVAIL,	/* Resource Unavailable */
	CAM_UNACKED_EVENT,	/* Unacknowledged Event by Host */
	CAM_MESSAGE_RECV,	/* Message Received in Host Target Mode */
	CAM_INVALID_CDB,	/* Invalid CDB received in Host Target Mode */
	CAM_LUN_INVALID,	/* Lun supplied is invalid */
	CAM_TID_INVALID,	/* Target ID supplied is invalid */
	CAM_FUNC_NOTAVAIL,	/* The requested function is not available */
	CAM_NO_NEXUS,		/* Nexus is not established */
	CAM_IID_INVALID,	/* The initiator ID is invalid */
	CAM_CDB_RECVD,		/* The SCSI CDB has been received */
	CAM_LUN_ALRDY_ENA,	/* The LUN is already enabled for target mode */
	CAM_SCSI_BUSY,		/* SCSI Bus Busy */

	CAM_DEV_QFRZN = 0x40,	/* The DEV queue is frozen w/this err */

	/* Autosense data valid for target */
	CAM_AUTOSNS_VALID = 0x80,
	CAM_RELEASE_SIMQ = 0x100,/* SIM ready to take more commands */
	CAM_SIM_QUEUED   = 0x200,/* SIM has this command in it's queue */

	CAM_STATUS_MASK = 0x3F,	/* Mask bits for just the status # */

	/* Target Specific Adjunct Status */
	CAM_SENT_SENSE = 0x40000000	/* sent sense with status */
} cam_status;

/*  FreeBSD to OpenBSD status defs */
#define SCSI_STATUS_CHECK_COND	SCSI_CHECK
#define SCSI_STATUS_CMD_TERMINATED	SCSI_TERMINATED
#define SCSI_STATUS_OK		SCSI_OK
#define SCSI_REV_2		SC_SCSI_2

a101 1
typedef struct scsi_xfer * ahc_io_ctx_t;
d106 1
a106 1
#define ahc_dmamap_sync(ahc, dma_tag, dmamap, offset, len, op)	\
d111 1
a111 1
 * The number of dma segments supported.  The sequencer can handle any number
d124 2
a125 4
/* This driver does NOT supports target mode */
#ifdef AHC_TARGET_MODE
#undef AHC_TARGET_MODE
#endif 
d127 1
a127 2
/***************************** Core Includes **********************************/
#include <dev/ic/aic7xxx.h>
a130 24
	bus_dma_segment_t	pshared_data_seg;
	int			pshared_data_nseg;
	int			pshared_data_size;
#define shared_data_seg		platform_data->pshared_data_seg
#define shared_data_nseg	platform_data->pshared_data_nseg
#define shared_data_size	platform_data->pshared_data_size
	/*
	 * Hooks into the XPT.
	 */
	struct	scsi_link	sc_link;
        /* Second bus for Twin channel cards */
	struct	scsi_link 	sc_link_b;
	
	void			*ih;
	int			channel_b_primary;
	
	/* queue management */
	int			queue_blocked;
	u_int16_t		devqueue_blocked[AHC_NUM_TARGETS];
	LIST_HEAD(, scsi_xfer) sc_xxxq;	/* XXX software request queue */
	struct scsi_xfer *sc_xxxqlast;	/* last entry in queue */
	
	u_int8_t		inited_targets[AHC_NUM_TARGETS];
	u_int8_t		inited_channels[2];
a132 5
typedef enum {
	SCB_FREEZE_QUEUE	= 0x0001,
	SCB_REQUEUE		= 0x0002
} scb_pflag;

a133 1
	scb_pflag	flags;
d159 31
a202 1

d206 1
a206 2
ahc_flush_device_writes(ahc)
	struct ahc_softc *ahc;
a213 1
#ifdef AHC_INLINES
d215 2
a216 2
static __inline void ahc_lock(struct ahc_softc *, int *flags);
static __inline void ahc_unlock(struct ahc_softc *, int *flags);
d220 7
a226 2
static __inline void ahc_done_lock(struct ahc_softc *, int *flags);
static __inline void ahc_done_unlock(struct ahc_softc *, int *flags);
d229 1
a229 2
ahc_lockinit(ahc)
	struct ahc_softc *ahc;
a230 1
	/* Nothing to do here for OpenBSD */
d234 1
a234 3
ahc_lock(ahc, flags)
	struct ahc_softc *ahc;
	int *flags;
d240 1
a240 3
ahc_unlock(ahc, flags)
	struct ahc_softc *ahc;
	int *flags;
d247 1
a247 2
ahc_done_lockinit(ahc)
	struct ahc_softc *ahc;
a248 1
	/* Nothing to do here for OpenBSD */
d252 1
a252 3
ahc_done_lock(ahc, flags)
	struct ahc_softc *ahc;
	int *flags;
a253 1
	/* Nothing to do here for OpenBSD */
d257 1
a257 3
ahc_done_unlock(ahc, flags)
	struct ahc_softc *ahc;
	int *flags;
a258 1
	/* Nothing to do here for OpenBSD */
d261 5
a265 1
#else
d267 4
a270 8
#define ahc_lockinit(ahc);	
#define ahc_lock(ahc, flags)    *(flags) = splbio()
#define ahc_unlock(ahc, flags)	splx(*(flags))
#define ahc_done_lockinit(ahc);
#define ahc_done_lock(ahc, flags);
#define ahc_done_unlock(ahc, flags);

#endif 
d272 4
d277 1
a277 1
#define ahc_delay delay
a279 2

#ifdef AHC_INLINES
a280 10
static __inline void ahc_set_transaction_tag(struct scb *, int, u_int);
static __inline void ahc_platform_scb_free(struct ahc_softc *ahc,
					   struct scb *scb);
#else 
void ahc_set_transaction_status(struct scb *, uint32_t);
void ahc_set_transaction_tag(struct scb *, int, u_int);
void ahc_platform_scb_free(struct ahc_softc *ahc,
			   struct scb *scb);
#endif

d284 1
d291 3
a293 2
static __inline uint32_t ahc_get_sense_bufsize(struct ahc_softc*, struct scb*);
static __inline void ahc_freeze_scb(struct scb *scb);
d295 3
a297 9
static __inline int  ahc_platform_abort_scbs(struct ahc_softc *ahc, int target,
					     char channel, int lun, u_int tag,
					     role_t role, uint32_t status);
/* 
 * This is a hack to keep from modifying the main
 * driver code as much as possible.  This function
 * does CAM to SCSI api stuff.
 */
#ifdef AHC_INLINES
d299 3
a301 37
void ahc_set_transaction_status(scb, status)
	struct scb *scb;
	uint32_t status;
{
	/* don't wipe the error */
	if (scb->io_ctx->error == XS_NOERROR){
		switch (status) {
		case CAM_CMD_TIMEOUT:
			status = XS_TIMEOUT;
			break;
		case CAM_BDR_SENT:
		case CAM_SCSI_BUS_RESET:
			status = XS_RESET;
			break;
		case CAM_UNEXP_BUSFREE:
		case CAM_REQ_TOO_BIG:
		case CAM_REQ_ABORTED:
		case CAM_AUTOSENSE_FAIL:
		case CAM_NO_HBA:
			status = XS_DRIVER_STUFFUP;
			break;
		case CAM_SEL_TIMEOUT:
			status = XS_SELTIMEOUT;
			break;
		case CAM_REQUEUE_REQ:
			scb->platform_data->flags |= SCB_REQUEUE;
			scb->io_ctx->error = XS_NOERROR;
			break;
		case CAM_SCSI_STATUS_ERROR:
		default:
			status = scb->io_ctx->error;
			break;
		}
	} else {
		status = scb->io_ctx->error;
	}
	scb->io_ctx->error = status;
d303 1
a303 1
#endif 
d305 3
a307 5
void ahc_set_scsi_status(scb, status)
	struct scb *scb;
	uint32_t status;
{
	scb->io_ctx->status = status;
a309 6
/* 
 * This is a hack to keep from modifying the main
 * driver code as much as possible.
 * This function ONLY needs to return weather 
 * a scsi_xfer is in progress or not. XXX smurph
 */
d311 1
a311 2
uint32_t ahc_get_transaction_status(scb)
	struct scb *scb;
d313 4
a316 1
	return (scb->io_ctx->flags & ITSDONE ? CAM_REQ_CMP : CAM_REQ_INPROG);
d320 1
a320 2
uint32_t ahc_get_scsi_status(scb)
	struct scb *scb;
d322 1
a322 1
	return (scb->io_ctx->status);
a324 1
#ifdef AHC_INLINE
d326 1
a326 4
void ahc_set_transaction_tag(scb, enabled, type)
	struct scb *scb;
	int enabled;
	u_int type;
a327 9
	struct scsi_xfer *xs = scb->io_ctx;
	switch (type) {
	case MSG_SIMPLE_TASK:
		if (enabled)
			xs->sc_link->quirks &= ~SDEV_NOTAGS;
		else
			xs->sc_link->quirks |= SDEV_NOTAGS;
		break;
	}
d329 1
a329 1
#endif 
d331 1
a331 2
u_long ahc_get_transfer_length(scb)
	struct scb *scb;
d333 1
a333 1
	return (scb->io_ctx->datalen);
d337 1
a337 2
int ahc_get_transfer_dir(scb)
	struct scb *scb;
d339 1
a339 1
	return (scb->io_ctx->flags & (SCSI_DATA_IN | SCSI_DATA_OUT));
d343 1
a343 3
void ahc_set_residual(scb, resid)
	struct scb *scb;
	u_long resid;
d345 1
a345 1
	scb->io_ctx->resid = resid;
d349 1
a349 3
void ahc_set_sense_residual(scb, resid)
	struct scb *scb;
	u_long resid;
d351 1
a351 1
	scb->io_ctx->resid = resid;
d355 1
a355 2
u_long ahc_get_residual(scb)
	struct scb *scb;
d357 1
a357 1
	return (scb->io_ctx->resid);
d361 1
a361 2
int ahc_perform_autosense(scb)
	struct scb *scb;
d368 1
a368 3
ahc_get_sense_bufsize(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d374 1
a374 2
ahc_freeze_scb(scb)
	struct scb *scb;
d376 1
a376 2
	struct scsi_xfer *xs = scb->io_ctx;
	struct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
d380 2
a381 3
	if (!(scb->platform_data->flags & SCB_FREEZE_QUEUE)) {
		ahc->platform_data->devqueue_blocked[target]++;
		scb->platform_data->flags |= SCB_FREEZE_QUEUE;
d386 1
a386 3
ahc_platform_freeze_devq(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
a387 1
	/* Nothing to do here for OpenBSD */
d391 3
a393 7
ahc_platform_abort_scbs(ahc, target, channel, lun, tag, role, status)
	struct ahc_softc *ahc;
	int target, lun;
	char channel;
	u_int tag;
	role_t role;
	uint32_t status;
a394 1
	/* Nothing to do here for OpenBSD */
a397 1
#ifdef AHC_INLINE
d399 1
a399 3
ahc_platform_scb_free(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
a407 1
		ahc->platform_data->queue_blocked = 0;
d410 1
a410 1
	timeout_del(&scb->io_ctx->stimeout);
a413 1
#endif 
d417 6
a422 22
int                      ahc_pci_map_registers(struct ahc_softc *ahc);
int                      ahc_pci_map_int(struct ahc_softc *ahc);

typedef enum
{
	AHC_POWER_STATE_D0,
	AHC_POWER_STATE_D1,
	AHC_POWER_STATE_D2,
	AHC_POWER_STATE_D3
} ahc_power_state;

void                    ahc_power_state_change(struct ahc_softc *ahc,
						    ahc_power_state new_state);

static __inline uint32_t ahc_pci_read_config(ahc_dev_softc_t pci,
						  int reg, int width);
static __inline void    ahc_pci_write_config(ahc_dev_softc_t pci,
						  int reg, uint32_t value,
						  int width);
static __inline u_int   ahc_get_pci_function(ahc_dev_softc_t);
static __inline u_int   ahc_get_pci_slot(ahc_dev_softc_t);
static __inline u_int   ahc_get_pci_bus(ahc_dev_softc_t);
d424 2
d428 1
a428 3
ahc_pci_read_config(pa, reg, width)
	ahc_dev_softc_t pa;
	int reg, width;
d430 1
a430 1
	return (pci_conf_read(pa->pa_pc, pa->pa_tag, reg));
d434 1
a434 4
ahc_pci_write_config(pa, reg, value, width)
	ahc_dev_softc_t pa;
	uint32_t value;
	int reg, width;
d436 1
a436 1
	pci_conf_write(pa->pa_pc, pa->pa_tag, reg, value);
d439 2
a440 3
static __inline u_int
ahc_get_pci_function(pa)
	ahc_dev_softc_t pa;
d442 1
a442 1
	return (pa->pa_function);
d445 2
a446 3
static __inline u_int
ahc_get_pci_slot(pa)
	ahc_dev_softc_t pa;
d448 1
a448 1
	return (pa->pa_device);
d451 2
a452 3
static __inline u_int
ahc_get_pci_bus(pa)
	ahc_dev_softc_t pa;
d454 1
a454 1
	return (pa->pa_bus);
d456 10
a466 1

d468 2
a469 2
int aic7770_map_registers(struct ahc_softc *ahc);
int aic7770_map_int(struct ahc_softc *ahc, int irq);
d472 2
a473 2
static __inline void    ahc_print_path(struct ahc_softc *, struct scb *);
static __inline void    ahc_platform_dump_card_state(struct ahc_softc *ahc);
d476 1
a476 3
ahc_print_path(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d478 1
a478 1
	sc_print_addr(scb->io_ctx->sc_link);
d482 1
a482 2
ahc_platform_dump_card_state(ahc)
	struct ahc_softc *ahc;
d489 3
a491 4
void      ahc_notify_xfer_settings_change(struct ahc_softc *,
					       struct ahc_devinfo *);
void      ahc_platform_set_tags(struct ahc_softc *, struct ahc_devinfo *,
				     ahc_queue_alg);
d494 6
a499 4
int       ahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg);
void      ahc_platform_free(struct ahc_softc *ahc);
int       ahc_attach(struct ahc_softc *);
int       ahc_softc_comp(struct ahc_softc *lahc, struct ahc_softc *rahc);
d503 1
a503 2
static __inline void    ahc_platform_flushwork(struct ahc_softc *ahc);

d505 1
a505 2
ahc_platform_flushwork(ahc)
	struct ahc_softc *ahc;
a506 1
	/* Nothing to do here for OpenBSD */
d510 3
a512 12
void    ahc_done(struct ahc_softc *ahc, struct scb *scb);
void    ahc_send_async(struct ahc_softc *, char /*channel*/,
			    u_int /*target*/, u_int /*lun*/, u_int, void *arg);

int     ahc_createdmamem(struct ahc_softc *ahc, bus_dma_tag_t dmat,
			      int size, bus_dmamap_t *mapp, caddr_t *vaddr,
			      bus_addr_t *baddr, bus_dma_segment_t *segs,
			      int *nseg, const char *what);
void    ahc_freedmamem(bus_dma_tag_t tag, int size,
			    bus_dmamap_t map, caddr_t vaddr,
			    bus_dma_segment_t *seg, int nseg);
void    ahc_force_neg(struct ahc_softc *ahc);
a513 107
/*
 * Routines to manage a scsi_xfer into the software queue.  
 * We overload xs->free_list to to ensure we don't run into a queue 
 * resource shortage, and keep a pointer to the last entry around 
 * to make insertion O(C).
 */
static __inline void   ahc_list_insert_before(struct ahc_softc *ahc,
						   struct scsi_xfer *xs,
						   struct scsi_xfer *next_xs);
static __inline void   ahc_list_insert_head(struct ahc_softc *ahc,
						 struct scsi_xfer *xs);
static __inline void   ahc_list_insert_tail(struct ahc_softc *ahc,
						 struct scsi_xfer *xs);
static __inline void   ahc_list_remove(struct ahc_softc *ahc,
					    struct scsi_xfer *xs);
static __inline struct scsi_xfer *ahc_list_next(struct ahc_softc *ahc,
						     struct scsi_xfer *xs);
static __inline struct scsi_xfer *ahc_first_xs(struct ahc_softc *);

static __inline void
ahc_list_insert_before(ahc, xs, next_xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scsi_xfer *next_xs;
{
	LIST_INSERT_BEFORE(xs, next_xs, free_list); 

}

static __inline void
ahc_list_insert_head(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	if (ahc->platform_data->sc_xxxq.lh_first == NULL)
		ahc->platform_data->sc_xxxqlast = xs;
	LIST_INSERT_HEAD(&ahc->platform_data->sc_xxxq, xs, free_list);
	return;
}

static __inline void
ahc_list_insert_tail(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	if (ahc->platform_data->sc_xxxq.lh_first == NULL){
		ahc->platform_data->sc_xxxqlast = xs;
		LIST_INSERT_HEAD(&ahc->platform_data->sc_xxxq, xs, free_list);
		return;
	}
	LIST_INSERT_AFTER(ahc->platform_data->sc_xxxqlast, xs, free_list);
	ahc->platform_data->sc_xxxqlast = xs;
}

static __inline void
ahc_list_remove(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	struct scsi_xfer *lxs;
	if (xs == ahc->platform_data->sc_xxxqlast) {
		lxs = ahc->platform_data->sc_xxxq.lh_first;
		while (lxs != NULL) {
			if (LIST_NEXT(lxs, free_list) == ahc->platform_data->sc_xxxqlast) {
                                ahc->platform_data->sc_xxxqlast = lxs;
				break;
			}
			lxs = LIST_NEXT(xs, free_list);
		}
	}
	
	LIST_REMOVE(xs, free_list);
	if (ahc->platform_data->sc_xxxq.lh_first == NULL)
		ahc->platform_data->sc_xxxqlast = NULL;
}

static __inline struct scsi_xfer *
ahc_list_next(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	return(LIST_NEXT(xs, free_list));
}

/*
 * Pick the first xs for a non-blocked target.
 */
static __inline struct scsi_xfer *
ahc_first_xs(ahc)
	struct ahc_softc *ahc;
{
	int target;
	struct scsi_xfer *xs = ahc->platform_data->sc_xxxq.lh_first;

	if (ahc->platform_data->queue_blocked)
        	return NULL;

	while (xs != NULL) {
		target = xs->sc_link->target;
		if (ahc->platform_data->devqueue_blocked[target] == 0 &&
		    ahc_index_busy_tcl(ahc, XS_TCL(xs)) == SCB_LIST_NULL)
			break;
		xs = LIST_NEXT(xs, free_list);
	}

	return xs;
}
a514 1

@


1.7
log
@attempt to make ahc smaller.  change PCI interrupt handler.
@
text
@d33 1
a33 1
 * $Id: aic7xxx_openbsd.h,v 1.5 2002/06/28 00:34:54 smurph Exp $
d36 1
a36 1
 * $OpenBSD: aic7xxx_openbsd.h,v 1.5 2002/06/28 00:34:54 smurph Exp $
d329 1
a329 1
/* Lock held during command compeletion to the upper layer */
d357 1
a357 1
/* Lock held during command compeletion to the upper layer */
@


1.7.4.1
log
@sync to -current
@
text
@d33 1
a33 1
 * $Id$
d36 1
a36 1
 * $OpenBSD$
@


1.6
log
@Ensure scb is setup correctly.  Add debugging info.
@
text
@a255 3
	/* for pci error interrupts  */
	int(*pci_intr_func)(struct ahc_softc *);
        
d311 1
d324 1
d381 11
d396 2
d399 10
a411 1
static __inline void ahc_set_transaction_tag(struct scb *, int, u_int);
d422 1
a422 1
						  char channel, int lun, u_int tag,
a423 3
static __inline void ahc_platform_scb_free(struct ahc_softc *ahc,
					   struct scb *scb);

d429 1
d469 1
a469 1

d498 1
d515 1
a515 1

d605 1
d625 1
@


1.5
log
@Return of new ahc
@
text
@d33 1
a33 1
 * $Id: aic7xxx_openbsd.h,v 1.3 2002/03/14 01:26:54 millert Exp $
d36 1
a36 1
 * $OpenBSD: aic7xxx_openbsd.h,v 1.3 2002/03/14 01:26:54 millert Exp $
d691 2
@


1.4
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d258 1
a258 1
	
d402 1
a402 1
						  role_t role, uint32_t status);
d404 1
a404 1
						struct scb *scb);
d607 2
a608 2
int			 ahc_pci_map_registers(struct ahc_softc *ahc);
int			 ahc_pci_map_int(struct ahc_softc *ahc);
d618 1
a618 1
void			ahc_power_state_change(struct ahc_softc *ahc,
d623 1
a623 1
static __inline void	ahc_pci_write_config(ahc_dev_softc_t pci,
d626 3
a628 3
static __inline u_int	ahc_get_pci_function(ahc_dev_softc_t);
static __inline u_int	ahc_get_pci_slot(ahc_dev_softc_t);
static __inline u_int	ahc_get_pci_bus(ahc_dev_softc_t);
d675 2
a676 2
static __inline void	ahc_print_path(struct ahc_softc *, struct scb *);
static __inline void	ahc_platform_dump_card_state(struct ahc_softc *ahc);
d693 1
a693 1
void	  ahc_notify_xfer_settings_change(struct ahc_softc *,
d695 1
a695 1
void	  ahc_platform_set_tags(struct ahc_softc *, struct ahc_devinfo *,
d699 4
a702 4
int	  ahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg);
void	  ahc_platform_free(struct ahc_softc *ahc);
int	  ahc_attach(struct ahc_softc *);
int	  ahc_softc_comp(struct ahc_softc *lahc, struct ahc_softc *rahc);
d705 2
a706 2
int			ahc_platform_intr(void *);
static __inline void	ahc_platform_flushwork(struct ahc_softc *ahc);
d716 2
a717 2
void	ahc_done(struct ahc_softc *ahc, struct scb *scb);
void	ahc_send_async(struct ahc_softc *, char /*channel*/,
d720 1
a720 1
int	ahc_createdmamem(struct ahc_softc *ahc, bus_dma_tag_t dmat,
d724 1
a724 1
void	ahc_freedmamem(bus_dma_tag_t tag, int size,
d727 1
a727 1
void	ahc_force_neg(struct ahc_softc *ahc);
d735 1
a735 1
static __inline	void   ahc_list_insert_before(struct ahc_softc *ahc,
d738 1
a738 1
static __inline	void   ahc_list_insert_head(struct ahc_softc *ahc,
d740 1
a740 1
static __inline	void   ahc_list_insert_tail(struct ahc_softc *ahc,
d742 1
a742 1
static __inline	void   ahc_list_remove(struct ahc_softc *ahc,
d744 1
a744 1
static __inline	struct scsi_xfer *ahc_list_next(struct ahc_softc *ahc,
d746 1
a746 1
static __inline	struct scsi_xfer *ahc_first_xs(struct ahc_softc *);
@


1.3
log
@First round of __P removal in sys
@
text
@d33 1
a33 1
 * $Id: aic7xxx_openbsd.h,v 1.2 2002/03/14 00:04:09 krw Exp $
d36 1
a36 1
 * $OpenBSD: aic7xxx_openbsd.h,v 1.2 2002/03/14 00:04:09 krw Exp $
@


1.2
log
@Fix *some* problems with new ahc driver that were surfaced with
the recent changes to scsiconf.c.

a) Restore marking of appropriate devices as tagged
b) Fix an off-by-one error that sprayed bits around
c) Use correct field (quirks) when setting SDEV_NOTAGS bit
d) Use TAG_ENB define instead of MSG_SIMPLE_Q_TAG when
   manipulating hscb->control. Both were defined to the
   same value, but TAG_ENB is the define used to extract
   the bit later on.

This leaves problems, most often seen as faults when accessing
a CD drive and disk drive on the same bus.

ok smurph@@
@
text
@d33 1
a33 1
 * $Id: aic7xxx_openbsd.h,v 1.1 2002/02/16 04:36:33 smurph Exp $
d36 1
a36 1
 * $OpenBSD: aic7xxx_openbsd.h,v 1.1 2002/02/16 04:36:33 smurph Exp $
d257 1
a257 1
	int(*pci_intr_func) __P((struct ahc_softc *));
d314 1
a314 1
static __inline void ahc_flush_device_writes __P((struct ahc_softc *));
d326 3
a328 3
static __inline void ahc_lockinit __P((struct ahc_softc *));
static __inline void ahc_lock __P((struct ahc_softc *, int *flags));
static __inline void ahc_unlock __P((struct ahc_softc *, int *flags));
d331 3
a333 3
static __inline void ahc_done_lockinit __P((struct ahc_softc *));
static __inline void ahc_done_lock __P((struct ahc_softc *, int *flags));
static __inline void ahc_done_unlock __P((struct ahc_softc *, int *flags));
d386 15
a400 15
static __inline void ahc_set_transaction_status __P((struct scb *, uint32_t));
static __inline void ahc_set_scsi_status __P((struct scb *, uint32_t));
static __inline uint32_t ahc_get_transaction_status __P((struct scb *));
static __inline uint32_t ahc_get_scsi_status __P((struct scb *));
static __inline void ahc_set_transaction_tag __P((struct scb *, int, u_int));
static __inline u_long ahc_get_transfer_length __P((struct scb *));
static __inline int ahc_get_transfer_dir __P((struct scb *));
static __inline void ahc_set_residual __P((struct scb *, u_long));
static __inline void ahc_set_sense_residual __P((struct scb *, u_long));
static __inline u_long ahc_get_residual __P((struct scb *));
static __inline int ahc_perform_autosense __P((struct scb *));
static __inline uint32_t ahc_get_sense_bufsize __P((struct ahc_softc*, struct scb*));
static __inline void ahc_freeze_scb __P((struct scb *scb));
static __inline void ahc_platform_freeze_devq __P((struct ahc_softc *, struct scb *));
static __inline int  ahc_platform_abort_scbs __P((struct ahc_softc *ahc, int target,
d402 3
a404 3
						  role_t role, uint32_t status));
static __inline void ahc_platform_scb_free __P((struct ahc_softc *ahc,
						struct scb *scb));
d607 2
a608 2
int			 ahc_pci_map_registers __P((struct ahc_softc *ahc));
int			 ahc_pci_map_int __P((struct ahc_softc *ahc));
d618 2
a619 2
void			ahc_power_state_change __P((struct ahc_softc *ahc,
						    ahc_power_state new_state));
d621 3
a623 3
static __inline uint32_t ahc_pci_read_config __P((ahc_dev_softc_t pci,
						  int reg, int width));
static __inline void	ahc_pci_write_config __P((ahc_dev_softc_t pci,
d625 4
a628 4
						  int width));
static __inline u_int	ahc_get_pci_function __P((ahc_dev_softc_t));
static __inline u_int	ahc_get_pci_slot __P((ahc_dev_softc_t));
static __inline u_int	ahc_get_pci_bus __P((ahc_dev_softc_t));
d671 2
a672 2
int aic7770_map_registers __P((struct ahc_softc *ahc));
int aic7770_map_int __P((struct ahc_softc *ahc, int irq));
d675 2
a676 2
static __inline void	ahc_print_path __P((struct ahc_softc *, struct scb *));
static __inline void	ahc_platform_dump_card_state __P((struct ahc_softc *ahc));
d693 4
a696 4
void	  ahc_notify_xfer_settings_change __P((struct ahc_softc *,
					       struct ahc_devinfo *));
void	  ahc_platform_set_tags __P((struct ahc_softc *, struct ahc_devinfo *,
				     ahc_queue_alg));
d699 4
a702 4
int	  ahc_platform_alloc __P((struct ahc_softc *ahc, void *platform_arg));
void	  ahc_platform_free __P((struct ahc_softc *ahc));
int	  ahc_attach __P((struct ahc_softc *));
int	  ahc_softc_comp __P((struct ahc_softc *lahc, struct ahc_softc *rahc));
d705 2
a706 2
int			ahc_platform_intr __P((void *));
static __inline void	ahc_platform_flushwork __P((struct ahc_softc *ahc));
d716 3
a718 3
void	ahc_done __P((struct ahc_softc *ahc, struct scb *scb));
void	ahc_send_async __P((struct ahc_softc *, char /*channel*/,
			    u_int /*target*/, u_int /*lun*/, u_int, void *arg));
d720 1
a720 1
int	ahc_createdmamem __P((struct ahc_softc *ahc, bus_dma_tag_t dmat,
d723 2
a724 2
			      int *nseg, const char *what));
void	ahc_freedmamem __P((bus_dma_tag_t tag, int size,
d726 2
a727 2
			    bus_dma_segment_t *seg, int nseg));
void	ahc_force_neg __P((struct ahc_softc *ahc));
d735 1
a735 1
static __inline	void   ahc_list_insert_before __P((struct ahc_softc *ahc,
d737 10
a746 10
						   struct scsi_xfer *next_xs));
static __inline	void   ahc_list_insert_head __P((struct ahc_softc *ahc,
						 struct scsi_xfer *xs));
static __inline	void   ahc_list_insert_tail __P((struct ahc_softc *ahc,
						 struct scsi_xfer *xs));
static __inline	void   ahc_list_remove __P((struct ahc_softc *ahc,
					    struct scsi_xfer *xs));
static __inline	struct scsi_xfer *ahc_list_next __P((struct ahc_softc *ahc,
						     struct scsi_xfer *xs));
static __inline	struct scsi_xfer *ahc_first_xs __P((struct ahc_softc *));
@


1.1
log
@New port of FreeBSD's ahc driver
@
text
@d33 1
a33 1
 * $Id$
d36 1
a36 1
 * $OpenBSD: src/sys/dev/ic/aic7xxx_openbsd.h,v 1.12 2001/07/18 21:39:47 smurph Exp $
d489 1
a489 1
			xs->sc_link->flags &= ~SDEV_NOTAGS;
d491 1
a491 1
			xs->sc_link->flags |= SDEV_NOTAGS;
@


1.1.2.1
log
@Merge in -current from about a week ago
@
text
@d33 1
a33 1
 * $Id: aic7xxx_openbsd.h,v 1.1 2002/02/16 04:36:33 smurph Exp $
d36 1
a36 1
 * $OpenBSD: aic7xxx_openbsd.h,v 1.1 2002/02/16 04:36:33 smurph Exp $
@


1.1.2.2
log
@Sync SMP to 3.3, files that CVS misses due to some bug
@
text
@d33 1
a33 1
 * $Id$
d36 1
a36 1
 * $OpenBSD$
d256 3
d314 1
a314 2

static __inline void ahc_flush_device_writes(struct ahc_softc *);
d326 3
a328 4
#ifdef AHC_INLINES
static __inline void ahc_lockinit(struct ahc_softc *);
static __inline void ahc_lock(struct ahc_softc *, int *flags);
static __inline void ahc_unlock(struct ahc_softc *, int *flags);
d331 3
a333 3
static __inline void ahc_done_lockinit(struct ahc_softc *);
static __inline void ahc_done_lock(struct ahc_softc *, int *flags);
static __inline void ahc_done_unlock(struct ahc_softc *, int *flags);
a381 11
#else

#define ahc_lockinit(ahc);	
#define ahc_lock(ahc, flags)    *(flags) = splbio()
#define ahc_unlock(ahc, flags)	splx(*(flags))
#define ahc_done_lockinit(ahc);
#define ahc_done_lock(ahc, flags);
#define ahc_done_unlock(ahc, flags);

#endif 

d386 19
a405 27
#ifdef AHC_INLINES
static __inline void ahc_set_transaction_status(struct scb *, uint32_t);
static __inline void ahc_set_transaction_tag(struct scb *, int, u_int);
static __inline void ahc_platform_scb_free(struct ahc_softc *ahc,
					   struct scb *scb);
#else 
void ahc_set_transaction_status(struct scb *, uint32_t);
void ahc_set_transaction_tag(struct scb *, int, u_int);
void ahc_platform_scb_free(struct ahc_softc *ahc,
			   struct scb *scb);
#endif

static __inline void ahc_set_scsi_status(struct scb *, uint32_t);
static __inline uint32_t ahc_get_transaction_status(struct scb *);
static __inline uint32_t ahc_get_scsi_status(struct scb *);
static __inline u_long ahc_get_transfer_length(struct scb *);
static __inline int ahc_get_transfer_dir(struct scb *);
static __inline void ahc_set_residual(struct scb *, u_long);
static __inline void ahc_set_sense_residual(struct scb *, u_long);
static __inline u_long ahc_get_residual(struct scb *);
static __inline int ahc_perform_autosense(struct scb *);
static __inline uint32_t ahc_get_sense_bufsize(struct ahc_softc*, struct scb*);
static __inline void ahc_freeze_scb(struct scb *scb);
static __inline void ahc_platform_freeze_devq(struct ahc_softc *, struct scb *);
static __inline int  ahc_platform_abort_scbs(struct ahc_softc *ahc, int target,
					     char channel, int lun, u_int tag,
					     role_t role, uint32_t status);
a410 1
#ifdef AHC_INLINES
d450 1
a450 1
#endif 
a478 1
#ifdef AHC_INLINE
d489 1
a489 1
			xs->sc_link->quirks &= ~SDEV_NOTAGS;
d491 1
a491 1
			xs->sc_link->quirks |= SDEV_NOTAGS;
d495 1
a495 1
#endif 
a584 1
#ifdef AHC_INLINE
a603 1
#endif 
d607 2
a608 2
int                      ahc_pci_map_registers(struct ahc_softc *ahc);
int                      ahc_pci_map_int(struct ahc_softc *ahc);
d618 2
a619 2
void                    ahc_power_state_change(struct ahc_softc *ahc,
						    ahc_power_state new_state);
d621 3
a623 3
static __inline uint32_t ahc_pci_read_config(ahc_dev_softc_t pci,
						  int reg, int width);
static __inline void    ahc_pci_write_config(ahc_dev_softc_t pci,
d625 4
a628 4
						  int width);
static __inline u_int   ahc_get_pci_function(ahc_dev_softc_t);
static __inline u_int   ahc_get_pci_slot(ahc_dev_softc_t);
static __inline u_int   ahc_get_pci_bus(ahc_dev_softc_t);
d671 2
a672 2
int aic7770_map_registers(struct ahc_softc *ahc);
int aic7770_map_int(struct ahc_softc *ahc, int irq);
d675 2
a676 2
static __inline void    ahc_print_path(struct ahc_softc *, struct scb *);
static __inline void    ahc_platform_dump_card_state(struct ahc_softc *ahc);
a690 2
	printf("FEATURES = 0x%x, FLAGS = 0x%x, CHIP = 0x%x BUGS =0x%x\n", 
	       ahc->features, ahc->flags, ahc->chip, ahc->bugs);
d693 4
a696 4
void      ahc_notify_xfer_settings_change(struct ahc_softc *,
					       struct ahc_devinfo *);
void      ahc_platform_set_tags(struct ahc_softc *, struct ahc_devinfo *,
				     ahc_queue_alg);
d699 4
a702 4
int       ahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg);
void      ahc_platform_free(struct ahc_softc *ahc);
int       ahc_attach(struct ahc_softc *);
int       ahc_softc_comp(struct ahc_softc *lahc, struct ahc_softc *rahc);
d705 2
a706 2
int                     ahc_platform_intr(void *);
static __inline void    ahc_platform_flushwork(struct ahc_softc *ahc);
d716 3
a718 3
void    ahc_done(struct ahc_softc *ahc, struct scb *scb);
void    ahc_send_async(struct ahc_softc *, char /*channel*/,
			    u_int /*target*/, u_int /*lun*/, u_int, void *arg);
d720 1
a720 1
int     ahc_createdmamem(struct ahc_softc *ahc, bus_dma_tag_t dmat,
d723 2
a724 2
			      int *nseg, const char *what);
void    ahc_freedmamem(bus_dma_tag_t tag, int size,
d726 2
a727 2
			    bus_dma_segment_t *seg, int nseg);
void    ahc_force_neg(struct ahc_softc *ahc);
d735 1
a735 1
static __inline void   ahc_list_insert_before(struct ahc_softc *ahc,
d737 10
a746 10
						   struct scsi_xfer *next_xs);
static __inline void   ahc_list_insert_head(struct ahc_softc *ahc,
						 struct scsi_xfer *xs);
static __inline void   ahc_list_insert_tail(struct ahc_softc *ahc,
						 struct scsi_xfer *xs);
static __inline void   ahc_list_remove(struct ahc_softc *ahc,
					    struct scsi_xfer *xs);
static __inline struct scsi_xfer *ahc_list_next(struct ahc_softc *ahc,
						     struct scsi_xfer *xs);
static __inline struct scsi_xfer *ahc_first_xs(struct ahc_softc *);
@


1.1.2.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a0 3
/*	$OpenBSD$	*/
/*	$NetBSD: aic7xxx_osm.h,v 1.7 2003/11/02 11:07:44 wiz Exp $	*/

d33 1
a33 1
 * //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.h#14 $
d35 2
a36 4
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx_osm.h,v 1.20 2002/12/04 22:51:29 scottl Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
d45 1
a46 1
#include <sys/systm.h>
d48 5
a57 6
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <machine/bus.h>
#include <machine/intr.h>

d65 3
a67 3
#ifdef CAM_NEW_TRAN_CODE
#define AHC_NEW_TRAN_SETTINGS
#endif /* CAM_NEW_TRAN_CODE */
d73 4
a76 1
#define AHC_DEBUG	AHC_SHOW_SENSE | AHC_SHOW_MISC | AHC_SHOW_CMDS
d86 1
a86 1
	((sc_link)->scsibus == (ahc)->sc_channel_b.scsibus)
d92 8
a99 1
        ((((target_id) << TID_SHIFT) & TID) | (our_id))
d104 101
d207 1
d212 1
a212 1
#define ahc_dmamap_sync(ahc, dma_tag, dmamap, offset, len, op)		\
d217 1
a217 1
 * The number of DMA segments supported.  The sequencer can handle any number
d230 4
a233 2
/* This driver supports target mode */
//#define AHC_TARGET_MODE 1
d235 2
a236 1
#include <dev/ic/aic7xxxvar.h>
d240 24
d266 5
d272 1
a297 31
/************************** Timer DataStructures ******************************/
typedef struct timeout ahc_timer_t;

/***************************** Core Includes **********************************/
#if AHC_REG_PRETTY_PRINT
#define AIC_DEBUG_REGISTERS 1
#else
#define AIC_DEBUG_REGISTERS 0
#endif

/***************************** Timer Facilities *******************************/
void ahc_timeout(void*);

#define ahc_timer_init callout_init
#define ahc_timer_stop callout_stop

static __inline void
ahc_timer_reset(ahc_timer_t *timer, u_int usec, ahc_callback_t *func, void *arg)
{
	callout_reset(timer, (usec * hz)/1000000, func, arg);
}

static __inline void
ahc_scb_timer_reset(struct scb *scb, u_int usec)
{
  	if (!(scb->xs->xs_control & XS_CTL_POLL)) {
		callout_reset(&scb->xs->xs_callout,
			      (usec * hz)/1000000, ahc_timeout, scb);
	}
}

d311 1
d315 2
a316 1
ahc_flush_device_writes(struct ahc_softc *ahc)
d324 1
d326 2
a327 2
static __inline void ahc_lock(struct ahc_softc *, int *);
static __inline void ahc_unlock(struct ahc_softc *, int *);
d329 1
a329 1
/* Lock held during command completion to the upper layer */
d331 2
a332 7
static __inline void ahc_done_lock(struct ahc_softc *, int *);
static __inline void ahc_done_unlock(struct ahc_softc *, int *);

/* Lock held during ahc_list manipulation and ahc softc frees */
static __inline void ahc_list_lockinit(void);
static __inline void ahc_list_lock(int *);
static __inline void ahc_list_unlock(int *);
d335 2
a336 1
ahc_lockinit(struct ahc_softc *ahc)
d338 1
d342 3
a344 1
ahc_lock(struct ahc_softc *ahc, int *flags)
d350 3
a352 1
ahc_unlock(struct ahc_softc *ahc, int *flags)
d357 1
a357 1
/* Lock held during command completion to the upper layer */
d359 2
a360 1
ahc_done_lockinit(struct ahc_softc *ahc)
d362 1
d366 3
a368 1
ahc_done_lock(struct ahc_softc *ahc, int *flags)
d370 1
d374 3
a376 1
ahc_done_unlock(struct ahc_softc *ahc, int *flags)
d378 1
d381 8
a388 5
/* Lock held during ahc_list manipulation and ahc softc frees */
static __inline void
ahc_list_lockinit()
{
}
d390 1
a390 4
static __inline void
ahc_list_lock(int *flags)
{
}
a391 4
static __inline void
ahc_list_unlock(int *flags)
{
}
d393 1
a393 1
#define ahc_delay DELAY
d396 2
d399 10
a411 1
static __inline void ahc_set_transaction_tag(struct scb *, int, u_int);
d418 2
a419 3
static __inline uint32_t ahc_get_sense_bufsize(struct ahc_softc *,
    struct scb *);
static __inline void ahc_freeze_scb(struct scb *);
d421 9
a429 3
static __inline int  ahc_platform_abort_scbs(struct ahc_softc *, int, char,
    int, u_int, role_t, uint32_t);

d431 37
a467 3
void ahc_set_transaction_status(struct scb *scb, uint32_t status)
{
	scb->xs->error = status;
d469 1
a469 1

d471 5
a475 3
void ahc_set_scsi_status(struct scb *scb, uint32_t status)
{
	scb->xs->status = status;
d478 6
d485 2
a486 1
uint32_t ahc_get_transaction_status(struct scb *scb)
d488 1
a488 4
	if (scb->xs->flags & ITSDONE)
		return CAM_REQ_CMP;
	else
		return scb->xs->error;
d492 2
a493 1
uint32_t ahc_get_scsi_status(struct scb *scb)
d495 1
a495 1
	return (scb->xs->status);
d498 1
d500 4
a503 1
void ahc_set_transaction_tag(struct scb *scb, int enabled, u_int type)
d505 9
d515 1
a515 1

d517 2
a518 1
u_long ahc_get_transfer_length(struct scb *scb)
d520 1
a520 1
	return (scb->xs->datalen);
d524 2
a525 1
int ahc_get_transfer_dir(struct scb *scb)
d527 1
a527 1
	return (scb->xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT));
d531 3
a533 1
void ahc_set_residual(struct scb *scb, u_long resid)
d535 1
a535 1
	scb->xs->resid = resid;
d539 3
a541 1
void ahc_set_sense_residual(struct scb *scb, u_long resid)
d543 1
a543 1
	scb->xs->resid = resid;
d547 2
a548 1
u_long ahc_get_residual(struct scb *scb)
d550 1
a550 1
	return (scb->xs->resid);
d554 2
a555 1
int ahc_perform_autosense(struct scb *scb)
d562 3
a564 1
ahc_get_sense_bufsize(struct ahc_softc *ahc, struct scb *scb)
d570 2
a571 1
ahc_freeze_scb(struct scb *scb)
d573 2
a574 1
	struct scsi_xfer *xs = scb->xs;
d578 3
a580 2
	if (!(scb->flags & SCB_FREEZE_QUEUE)) {
		scb->flags |= SCB_FREEZE_QUEUE;
d585 3
a587 1
ahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
d589 1
d593 7
a599 3
ahc_platform_abort_scbs(struct ahc_softc *ahc, int target,
			char channel, int lun, u_int tag,
			role_t role, uint32_t status)
d601 1
d605 1
d607 3
a609 1
ahc_platform_scb_free(struct ahc_softc *ahc, struct scb *scb)
d618 1
d621 1
a621 1
	timeout_del(&scb->xs->stimeout);
d625 1
d629 22
a650 6
static __inline uint32_t ahc_pci_read_config(ahc_dev_softc_t, int, int);
static __inline void	 ahc_pci_write_config(ahc_dev_softc_t, int, uint32_t,
    int);
static __inline int	 ahc_get_pci_function(ahc_dev_softc_t);
static __inline int	 ahc_get_pci_slot(ahc_dev_softc_t);
static __inline int	 ahc_get_pci_bus(ahc_dev_softc_t);
a651 2
int			 ahc_pci_map_registers(struct ahc_softc *);
int			 ahc_pci_map_int(struct ahc_softc *);
d654 3
a656 1
ahc_pci_read_config(ahc_dev_softc_t pci, int reg, int width)
d658 1
a658 1
	return (pci_conf_read(pci->pa_pc, pci->pa_tag, reg));
d662 4
a665 1
ahc_pci_write_config(ahc_dev_softc_t pci, int reg, uint32_t value, int width)
d667 1
a667 1
	pci_conf_write(pci->pa_pc, pci->pa_tag, reg, value);
d670 3
a672 2
static __inline int
ahc_get_pci_function(ahc_dev_softc_t pci)
d674 1
a674 1
	return (pci->pa_function);
d677 3
a679 2
static __inline int
ahc_get_pci_slot(ahc_dev_softc_t pci)
d681 1
a681 1
	return (pci->pa_device);
d684 3
a686 2
static __inline int
ahc_get_pci_bus(ahc_dev_softc_t pci)
d688 1
a688 1
	return (pci->pa_bus);
d690 1
a691 10
typedef enum
{
	AHC_POWER_STATE_D0,
	AHC_POWER_STATE_D1,
	AHC_POWER_STATE_D2,
	AHC_POWER_STATE_D3
} ahc_power_state;

void ahc_power_state_change(struct ahc_softc *, ahc_power_state);
#endif
d693 2
a694 2
int aic7770_map_registers(struct ahc_softc *, u_int);
int aic7770_map_int(struct ahc_softc *, int);
d697 2
a698 2
static __inline void	ahc_print_path(struct ahc_softc *, struct scb *);
static __inline void	ahc_platform_dump_card_state(struct ahc_softc *);
d701 3
a703 1
ahc_print_path(struct ahc_softc *ahc, struct scb *scb)
d705 1
a705 1
	sc_print_addr(scb->xs->sc_link);
d709 2
a710 1
ahc_platform_dump_card_state(struct ahc_softc *ahc)
d717 4
a720 3
void	  ahc_notify_xfer_settings_change(struct ahc_softc *,
					  struct ahc_devinfo *);
void	  ahc_platform_set_tags(struct ahc_softc *, struct ahc_devinfo *, int);
d723 4
a726 6
int	  ahc_platform_alloc(struct ahc_softc *, void *);
void	  ahc_platform_free(struct ahc_softc *);
int	  ahc_map_int(struct ahc_softc *);
int	  ahc_attach(struct ahc_softc *);
int	  ahc_softc_comp(struct ahc_softc *, struct ahc_softc *);
int	  ahc_detach(struct device *, int);
d730 2
a731 1
static __inline void    ahc_platform_flushwork(struct ahc_softc *);
d733 2
a734 1
ahc_platform_flushwork(struct ahc_softc *ahc)
d736 1
d740 12
a751 3
void	  ahc_done(struct ahc_softc *, struct scb *);
void	  ahc_send_async(struct ahc_softc *, char, u_int, u_int, ac_code,
    void *);
d753 107
d861 1
@


