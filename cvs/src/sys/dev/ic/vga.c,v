head	1.68;
access;
symbols
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.68.0.6
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.68.0.2
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.67.0.4
	OPENBSD_5_8_BASE:1.67
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.63.0.4
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.55.0.8
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.55.0.4
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.6
	OPENBSD_5_0:1.55.0.2
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.54.0.2
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.50.0.4
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.49.0.2
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.45.0.4
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.38.0.8
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.6
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.38.0.4
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.38.0.2
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.32
	SMP_SYNC_B:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.30
	UBC:1.27.0.4
	UBC_BASE:1.27
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.12.0.12
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.10
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.8
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11;
locks; strict;
comment	@ * @;


1.68
date	2015.09.09.18.23.39;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	b7uF71hcvJADoXUp;

1.67
date	2015.07.26.03.17.07;	author miod;	state Exp;
branches;
next	1.66;
commitid	0kywYp2i1cqnzJaY;

1.66
date	2015.07.18.00.48.05;	author miod;	state Exp;
branches;
next	1.65;
commitid	zOVsbR9piOCLHrSg;

1.65
date	2015.03.29.18.45.22;	author miod;	state Exp;
branches;
next	1.64;
commitid	Zn8MYTvkjKcNFl7W;

1.64
date	2015.03.29.17.23.00;	author miod;	state Exp;
branches;
next	1.63;
commitid	W9FilqcH2hjXaqVe;

1.63
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	JtO5uXxVcnZfhUkR;

1.62
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.61;
commitid	I19imNlAX05zJOED;

1.61
date	2013.10.20.21.24.00;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2013.10.20.20.07.29;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2013.10.19.14.32.45;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.18.17.38.33;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2013.07.06.14.36.33;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2013.03.18.10.12.40;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2011.04.03.15.46.30;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2010.08.28.12.48.14;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2010.08.08.17.21.05;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2009.08.12.15.58.30;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.49;

1.49
date	2009.02.15.17.08.23;	author chl;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.01.14.37.22;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.16.19.00.28;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.06.22.03.23;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.02.19.11.09;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.29.19.11.15;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2006.09.29.19.46.02;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.31.06.41.27;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.25.23.58.14;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.04.15.03.53;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2004.08.06.13.25.30;	author pefo;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.27.17.44.44;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.17.18.31.03;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.03.16.17.47;	author tholo;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2001.05.16.19.17.01;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.08.22.28.43;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.08.16.16.10;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.14.04.44.01;	author aaron;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.01.20.30.02;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.22.12.43.47;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.16.14.02.36;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.14.02.49.22;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.28.16.48.28;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.08.02.47.10;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.31.16.38.00;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.31.02.12.28;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.22.01.39.38;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.15.20.17.37;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	98.09.28.01.07.34;	author rahnds;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	97.11.06.12.26.54;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.03.38.44;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.02.53.41;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.08.25.08.26.43;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.22.22.25.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.31.13.40.01;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.31.04.03.43;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.07.10.19.08.28;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.10.04.25.57;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.07.09.03.07.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.07.09.02.58.35;	author deraadt;	state Exp;
branches;
next	;

1.12.8.1
date	2001.05.14.22.24.21;	author niklas;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2001.07.04.10.41.16;	author niklas;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.12.8.4;

1.12.8.4
date	2002.03.28.12.09.41;	author niklas;	state Exp;
branches;
next	1.12.8.5;

1.12.8.5
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.12.8.6;

1.12.8.6
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.12.8.7;

1.12.8.7
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;

1.27.4.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.68
log
@sizes for free(); ok sthen semarie
@
text
@/* $OpenBSD: vga.c,v 1.67 2015/07/26 03:17:07 miod Exp $ */
/* $NetBSD: vga.c,v 1.28.2.1 2000/06/30 16:27:47 simonb Exp $ */

/*-
  * Copyright (c) 1999 Kazutaka YOKOTA <yokota@@zodiac.mech.utsunomiya-u.ac.jp>
  * Copyright (c) 1992-1998 Søren Schmidt
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer as
  *    the first lines of this file unmodified.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  * 3. The name of the author may not be used to endorse or promote products
  *    derived from this software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */
/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "vga.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <machine/bus.h>

#include <dev/ic/mc6845reg.h>
#include <dev/ic/pcdisplayvar.h>
#include <dev/ic/vgareg.h>

#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/unicode.h>

#include <dev/ic/vgavar.h>
#include <dev/ic/pcdisplay.h>

static struct vgafont {
	char name[WSFONT_NAME_SIZE];
	int height;
	int encoding;
#ifdef notyet
	int firstchar, numchars;
#endif
	int slot;
	void *fontdata;
} vga_builtinfont = {
	.name = "builtin",
	.height = 16,
	.encoding = WSDISPLAY_FONTENC_IBM,
#ifdef notyet
	.firstchar = 0,
	.numchars = 256,
#endif
	.slot = 0,
	.fontdata = NULL
};

int vgaconsole, vga_console_type, vga_console_attached;
struct vgascreen vga_console_screen;
struct vga_config vga_console_vc;

int	vga_selectfont(struct vga_config *, struct vgascreen *,
    const char *, const char *);
void	vga_init_screen(struct vga_config *, struct vgascreen *,
    const struct wsscreen_descr *, int, long *);
void	vga_init(struct vga_config *, bus_space_tag_t, bus_space_tag_t);
void	vga_setfont(struct vga_config *, struct vgascreen *);
void	vga_pick_monitor_type(struct vga_config *);

int	vga_mapchar(void *, int, unsigned int *);
int	vga_putchar(void *, int, int, u_int, long);
int	vga_alloc_attr(void *, int, int, int, long *);
int	vga_copyrows(void *, int, int, int);
void	vga_unpack_attr(void *, long, int *, int *, int *);

static const struct wsdisplay_emulops vga_emulops = {
	pcdisplay_cursor,
	vga_mapchar,
	vga_putchar,
	pcdisplay_copycols,
	pcdisplay_erasecols,
	vga_copyrows,
	pcdisplay_eraserows,
	vga_alloc_attr,
	vga_unpack_attr
};

/*
 * translate WS(=ANSI) color codes to standard pc ones
 */
static const unsigned char fgansitopc[] = {
#ifdef __alpha__
	/*
	 * XXX DEC HAS SWITCHED THE CODES FOR BLUE AND RED!!!
	 * XXX We should probably not bother with this
	 * XXX (reinitialize the palette registers).
	 */
	FG_BLACK, FG_BLUE, FG_GREEN, FG_CYAN, FG_RED,
	FG_MAGENTA, FG_BROWN, FG_LIGHTGREY
#else
	FG_BLACK, FG_RED, FG_GREEN, FG_BROWN, FG_BLUE,
	FG_MAGENTA, FG_CYAN, FG_LIGHTGREY
#endif
}, bgansitopc[] = {
#ifdef __alpha__
	BG_BLACK, BG_BLUE, BG_GREEN, BG_CYAN, BG_RED,
	BG_MAGENTA, BG_BROWN, BG_LIGHTGREY
#else
	BG_BLACK, BG_RED, BG_GREEN, BG_BROWN, BG_BLUE,
	BG_MAGENTA, BG_CYAN, BG_LIGHTGREY
#endif
};

/*
 * translate standard pc color codes to WS(=ANSI) ones
 */
static const u_int8_t pctoansi[] = {
#ifdef __alpha__
	WSCOL_BLACK, WSCOL_RED, WSCOL_GREEN, WSCOL_BROWN,
	WSCOL_BLUE, WSCOL_MAGENTA, WSCOL_CYAN, WSCOL_WHITE
#else
	WSCOL_BLACK, WSCOL_BLUE, WSCOL_GREEN, WSCOL_CYAN,
	WSCOL_RED, WSCOL_MAGENTA, WSCOL_BROWN, WSCOL_WHITE
#endif
};


const struct wsscreen_descr vga_stdscreen = {
	"80x25", 80, 25,
	&vga_emulops,
	8, 16,
	WSSCREEN_WSCOLORS | WSSCREEN_HILIT | WSSCREEN_BLINK
}, vga_stdscreen_mono = {
	"80x25", 80, 25,
	&vga_emulops,
	8, 16,
	WSSCREEN_HILIT | WSSCREEN_UNDERLINE | WSSCREEN_BLINK | WSSCREEN_REVERSE
}, vga_stdscreen_bf = {
	"80x25bf", 80, 25,
	&vga_emulops,
	8, 16,
	WSSCREEN_WSCOLORS | WSSCREEN_BLINK
}, vga_40lscreen = {
	"80x40", 80, 40,
	&vga_emulops,
	8, 10,
	WSSCREEN_WSCOLORS | WSSCREEN_HILIT | WSSCREEN_BLINK
}, vga_40lscreen_mono = {
	"80x40", 80, 40,
	&vga_emulops,
	8, 10,
	WSSCREEN_HILIT | WSSCREEN_UNDERLINE | WSSCREEN_BLINK | WSSCREEN_REVERSE
}, vga_40lscreen_bf = {
	"80x40bf", 80, 40,
	&vga_emulops,
	8, 10,
	WSSCREEN_WSCOLORS | WSSCREEN_BLINK
}, vga_50lscreen = {
	"80x50", 80, 50,
	&vga_emulops,
	8, 8,
	WSSCREEN_WSCOLORS | WSSCREEN_HILIT | WSSCREEN_BLINK
}, vga_50lscreen_mono = {
	"80x50", 80, 50,
	&vga_emulops,
	8, 8,
	WSSCREEN_HILIT | WSSCREEN_UNDERLINE | WSSCREEN_BLINK | WSSCREEN_REVERSE
}, vga_50lscreen_bf = {
	"80x50bf", 80, 50,
	&vga_emulops,
	8, 8,
	WSSCREEN_WSCOLORS | WSSCREEN_BLINK
};

#define VGA_SCREEN_CANTWOFONTS(type) (!((type)->capabilities & WSSCREEN_HILIT))

const struct wsscreen_descr *_vga_scrlist[] = {
	&vga_stdscreen,
	&vga_stdscreen_bf,
	&vga_40lscreen,
	&vga_40lscreen_bf,
	&vga_50lscreen,
	&vga_50lscreen_bf,
	/* XXX other formats, graphics screen? */
}, *_vga_scrlist_mono[] = {
	&vga_stdscreen_mono,
	&vga_40lscreen_mono,
	&vga_50lscreen_mono,
	/* XXX other formats, graphics screen? */
};

const struct wsscreen_list vga_screenlist = {
	sizeof(_vga_scrlist) / sizeof(struct wsscreen_descr *),
	_vga_scrlist
}, vga_screenlist_mono = {
	sizeof(_vga_scrlist_mono) / sizeof(struct wsscreen_descr *),
	_vga_scrlist_mono
};

int	vga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	vga_mmap(void *, off_t, int);
int	vga_alloc_screen(void *, const struct wsscreen_descr *,
			 void **, int *, int *, long *);
void	vga_free_screen(void *, void *);
int	vga_show_screen(void *, void *, int,
			void (*) (void *, int, int), void *);
int	vga_load_font(void *, void *, struct wsdisplay_font *);
int	vga_list_font(void *, struct wsdisplay_font *);
void	vga_scrollback(void *, void *, int);
void	vga_burner(void *v, u_int on, u_int flags);
int	vga_getchar(void *, int, int, struct wsdisplay_charcell *);

void vga_doswitch(struct vga_config *);

const struct wsdisplay_accessops vga_accessops = {
	.ioctl = vga_ioctl,
	.mmap = vga_mmap,
	.alloc_screen = vga_alloc_screen,
	.free_screen = vga_free_screen,
	.show_screen = vga_show_screen,
	.load_font = vga_load_font,
	.list_font = vga_list_font,
	.scrollback = vga_scrollback,
	.getchar = vga_getchar,
	.burn_screen = vga_burner
};

/*
 * The following functions implement back-end configuration grabbing
 * and attachment.
 */
int
vga_common_probe(bus_space_tag_t iot, bus_space_tag_t memt)
{
	bus_space_handle_t ioh_vga, ioh_6845, memh;
	u_int8_t regval;
	u_int16_t vgadata;
	int gotio_vga, gotio_6845, gotmem, mono, rv;
	int dispoffset;

	gotio_vga = gotio_6845 = gotmem = rv = 0;

	if (bus_space_map(iot, 0x3c0, 0x10, 0, &ioh_vga))
		goto bad;
	gotio_vga = 1;

	/* read "misc output register" */
	regval = bus_space_read_1(iot, ioh_vga, 0xc);
	mono = !(regval & 1);

	if (bus_space_map(iot, (mono ? 0x3b0 : 0x3d0), 0x10, 0, &ioh_6845))
		goto bad;
	gotio_6845 = 1;

	if (bus_space_map(memt, 0xa0000, 0x20000, 0, &memh))
		goto bad;
	gotmem = 1;

	dispoffset = (mono ? 0x10000 : 0x18000);

	vgadata = bus_space_read_2(memt, memh, dispoffset);
	bus_space_write_2(memt, memh, dispoffset, 0xa55a);
	if (bus_space_read_2(memt, memh, dispoffset) != 0xa55a)
		goto bad;
	bus_space_write_2(memt, memh, dispoffset, vgadata);

	/*
	 * check if this is really a VGA
	 * (try to write "Color Select" register as XFree86 does)
	 * XXX check before if at least EGA?
	 */
	/* reset state */
	(void) bus_space_read_1(iot, ioh_6845, 10);
	bus_space_write_1(iot, ioh_vga, VGA_ATC_INDEX,
			  20 | 0x20); /* colselect | enable */
	regval = bus_space_read_1(iot, ioh_vga, VGA_ATC_DATAR);
	/* toggle the implemented bits */
	bus_space_write_1(iot, ioh_vga, VGA_ATC_DATAW, regval ^ 0x0f);
	bus_space_write_1(iot, ioh_vga, VGA_ATC_INDEX,
			  20 | 0x20);
	/* read back */
	if (bus_space_read_1(iot, ioh_vga, VGA_ATC_DATAR) != (regval ^ 0x0f))
		goto bad;
	/* restore contents */
	bus_space_write_1(iot, ioh_vga, VGA_ATC_DATAW, regval);

	rv = 1;
bad:
	if (gotio_vga)
		bus_space_unmap(iot, ioh_vga, 0x10);
	if (gotio_6845)
		bus_space_unmap(iot, ioh_6845, 0x10);
	if (gotmem)
		bus_space_unmap(memt, memh, 0x20000);

	return (rv);
}

/*
 * We want at least ASCII 32..127 be present in the
 * first font slot.
 */
#define vga_valid_primary_font(f) \
	(f->encoding == WSDISPLAY_FONTENC_IBM || \
	f->encoding == WSDISPLAY_FONTENC_ISO)

int
vga_selectfont(struct vga_config *vc, struct vgascreen *scr, const char *name1,
    const char *name2) /* NULL: take first found */
{
	const struct wsscreen_descr *type = scr->pcs.type;
	struct vgafont *f1, *f2;
	int i;

	f1 = f2 = 0;

	for (i = 0; i < VGA_MAXFONT; i++) {
		struct vgafont *f = vc->vc_fonts[i];
		if (!f || f->height != type->fontheight)
			continue;
		if (!f1 &&
		    vga_valid_primary_font(f) &&
		    (!name1 || !*name1 ||
		     !strncmp(name1, f->name, WSFONT_NAME_SIZE))) {
			f1 = f;
			continue;
		}
		if (!f2 &&
		    VGA_SCREEN_CANTWOFONTS(type) &&
		    (!name2 || !*name2 ||
		     !strncmp(name2, f->name, WSFONT_NAME_SIZE))) {
			f2 = f;
			continue;
		}
	}

	/*
	 * The request fails if no primary font was found,
	 * or if a second font was requested but not found.
	 */
	if (f1 && (!name2 || !*name2 || f2)) {
#ifdef VGAFONTDEBUG
		if (scr != &vga_console_screen || vga_console_attached) {
			printf("vga (%s): font1=%s (slot %d)", type->name,
			       f1->name, f1->slot);
			if (f2)
				printf(", font2=%s (slot %d)",
				       f2->name, f2->slot);
			printf("\n");
		}
#endif
		scr->fontset1 = f1;
		scr->fontset2 = f2;
		return (0);
	}
	return (ENXIO);
}

void
vga_init_screen(struct vga_config *vc, struct vgascreen *scr,
    const struct wsscreen_descr *type, int existing, long *attrp)
{
	int cpos;
	int res;

	scr->cfg = vc;
	scr->pcs.hdl = (struct pcdisplay_handle *)&vc->hdl;
	scr->pcs.type = type;
	scr->pcs.active = 0;
	scr->mindispoffset = 0;
	scr->maxdispoffset = 0x8000 - type->nrows * type->ncols * 2;

	if (existing) {
		cpos = vga_6845_read(&vc->hdl, cursorh) << 8;
		cpos |= vga_6845_read(&vc->hdl, cursorl);

		/* make sure we have a valid cursor position */
		if (cpos < 0 || cpos >= type->nrows * type->ncols)
			cpos = 0;

		scr->pcs.dispoffset = vga_6845_read(&vc->hdl, startadrh) << 9;
		scr->pcs.dispoffset |= vga_6845_read(&vc->hdl, startadrl) << 1;

		/* make sure we have a valid memory offset */
		if (scr->pcs.dispoffset < scr->mindispoffset ||
		    scr->pcs.dispoffset > scr->maxdispoffset)
			scr->pcs.dispoffset = scr->mindispoffset;
	} else {
		cpos = 0;
		scr->pcs.dispoffset = scr->mindispoffset;
	}
	scr->pcs.visibleoffset = scr->pcs.dispoffset;
	scr->vga_rollover = 0;

	scr->pcs.vc_crow = cpos / type->ncols;
	scr->pcs.vc_ccol = cpos % type->ncols;
	pcdisplay_cursor_init(&scr->pcs, existing);

#ifdef __alpha__
	if (!vc->hdl.vh_mono)
		/*
		 * DEC firmware uses a blue background.
		 */
		res = vga_alloc_attr(scr, WSCOL_WHITE, WSCOL_BLUE,
				     WSATTR_WSCOLORS, attrp);
	else
#endif
	res = vga_alloc_attr(scr, 0, 0, 0, attrp);
#ifdef DIAGNOSTIC
	if (res)
		panic("vga_init_screen: attribute botch");
#endif

	scr->pcs.mem = NULL;

	scr->fontset1 = scr->fontset2 = 0;
	if (vga_selectfont(vc, scr, 0, 0)) {
		if (scr == &vga_console_screen)
			panic("vga_init_screen: no font");
		else
			printf("vga_init_screen: no font\n");
	}

	vc->nscreens++;
	LIST_INSERT_HEAD(&vc->screens, scr, next);
}

void
vga_init(struct vga_config *vc, bus_space_tag_t iot, bus_space_tag_t memt)
{
	struct vga_handle *vh = &vc->hdl;
	u_int8_t mor;
	int i;

        vh->vh_iot = iot;
        vh->vh_memt = memt;

        if (bus_space_map(vh->vh_iot, 0x3c0, 0x10, 0, &vh->vh_ioh_vga))
                panic("vga_common_setup: can't map vga i/o");

	/* read "misc output register" */
	mor = bus_space_read_1(vh->vh_iot, vh->vh_ioh_vga, 0xc);
	vh->vh_mono = !(mor & 1);

	if (bus_space_map(vh->vh_iot, (vh->vh_mono ? 0x3b0 : 0x3d0), 0x10, 0,
			  &vh->vh_ioh_6845))
                panic("vga_common_setup: can't map 6845 i/o");

        if (bus_space_map(vh->vh_memt, 0xa0000, 0x20000, 0, &vh->vh_allmemh))
                panic("vga_common_setup: can't map mem space");

        if (bus_space_subregion(vh->vh_memt, vh->vh_allmemh,
				(vh->vh_mono ? 0x10000 : 0x18000), 0x8000,
				&vh->vh_memh))
                panic("vga_common_setup: mem subrange failed");

#ifdef __alpha__
	vga_pick_monitor_type(vc);
#endif

	vc->nscreens = 0;
	LIST_INIT(&vc->screens);
	vc->active = NULL;
#ifdef __alpha__
	if (vc->custom_list.screens != NULL)
		vc->currenttype = vc->custom_list.screens[0];
	else
#endif
		vc->currenttype =
		    vh->vh_mono ? &vga_stdscreen_mono : &vga_stdscreen;

	vc->vc_fonts[0] = &vga_builtinfont;
	for (i = 1; i < VGA_MAXFONT; i++)
		vc->vc_fonts[i] = NULL;

	vc->currentfontset1 = vc->currentfontset2 = 0;

	vga_save_palette(vc);
}

struct vga_config *
vga_common_attach(struct device *self, bus_space_tag_t iot,
    bus_space_tag_t memt, int type)
{
	return vga_extended_attach(self, iot, memt, type, NULL);
}

struct vga_config *
vga_extended_attach(struct device *self, bus_space_tag_t iot,
    bus_space_tag_t memt, int type, paddr_t (*map)(void *, off_t, int))
{
	int console;
	struct vga_config *vc;
	struct wsemuldisplaydev_attach_args aa;

	console = vga_is_console(iot, type);
	if (console)
		vga_console_attached = 1;

	if (type == -1)
		return NULL;

	if (console) {
		vc = &vga_console_vc;
	} else {
		vc = malloc(sizeof(*vc), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (vc == NULL)
			return NULL;
		vga_init(vc, iot, memt);
	}

	vc->vc_softc = self;
	vc->vc_type = type;
	vc->vc_mmap = map;

	aa.console = console;
#ifdef __alpha__
	if (vc->custom_list.screens != NULL)
		aa.scrdata = &vc->custom_list;
	else
#endif
		aa.scrdata =
		    vc->hdl.vh_mono ? &vga_screenlist_mono : &vga_screenlist;

	aa.accessops = &vga_accessops;
	aa.accesscookie = vc;
	aa.defaultscreens = 0;

        config_found_sm(self, &aa, wsemuldisplaydevprint,
	    wsemuldisplaydevsubmatch);

	return vc;
}

int
vga_cnattach(bus_space_tag_t iot, bus_space_tag_t memt, int type, int check)
{
	long defattr;
	const struct wsscreen_descr *scr;

	if (check && !vga_common_probe(iot, memt))
		return (ENXIO);

	/* set up bus-independent VGA configuration */
	vga_init(&vga_console_vc, iot, memt);
	scr = vga_console_vc.currenttype;
	vga_init_screen(&vga_console_vc, &vga_console_screen, scr, 1, &defattr);

	vga_console_screen.pcs.active = 1;
	vga_console_vc.active = &vga_console_screen;

	wsdisplay_cnattach(scr, &vga_console_screen,
			   vga_console_screen.pcs.vc_ccol,
			   vga_console_screen.pcs.vc_crow,
			   defattr);

	vgaconsole = 1;
	vga_console_type = type;
	return (0);
}

int
vga_is_console(bus_space_tag_t iot, int type)
{
	if (vgaconsole &&
	    !vga_console_attached &&
	    iot == vga_console_vc.hdl.vh_iot &&
	    (vga_console_type == -1 || (type == vga_console_type)))
		return (1);
	return (0);
}

int
vga_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct vga_config *vc = v;
	int mode;
#if NVGA_PCI > 0
	int error;

	if (vc->vc_type == WSDISPLAY_TYPE_PCIVGA &&
	    (error = vga_pci_ioctl(v, cmd, data, flag, p)) != ENOTTY)
		return (error);
#endif

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(int *)data = vc->vc_type;
		/* XXX should get detailed hardware information here */
		break;

	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		if (mode == WSDISPLAYIO_MODE_EMUL) {
			vga_restore_fonts(vc);
			vga_restore_palette(vc);
		}
		break;

	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		break;

	case WSDISPLAYIO_GINFO:
	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		/* NONE of these operations are by the generic VGA driver. */
		return ENOTTY;
	}

	return (0);
}

paddr_t
vga_mmap(void *v, off_t offset, int prot)
{
	struct vga_config *vc = v;

	if (vc->vc_mmap != NULL)
		return (*vc->vc_mmap)(v, offset, prot);

	return (paddr_t)-1;
}

int
vga_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *defattrp)
{
	struct vga_config *vc = v;
	struct vgascreen *scr;

	if (vc->nscreens == 1) {
		/*
		 * When allocating the second screen, get backing store
		 * for the first one too.
		 * XXX We could be more clever and use video RAM.
		 */
		scr = LIST_FIRST(&vc->screens);
		scr->pcs.mem = mallocarray(scr->pcs.type->ncols,
		    scr->pcs.type->nrows * 2, M_DEVBUF, M_WAITOK);
	}

	scr = malloc(sizeof(struct vgascreen), M_DEVBUF, M_WAITOK);
	vga_init_screen(vc, scr, type, vc->nscreens == 0, defattrp);

	if (vc->nscreens == 1) {
		scr->pcs.active = 1;
		vc->active = scr;
		vc->currenttype = type;
	} else {
		scr->pcs.mem = mallocarray(type->ncols,
		    type->nrows * 2, M_DEVBUF, M_WAITOK);
		pcdisplay_eraserows(&scr->pcs, 0, type->nrows, *defattrp);
	}

	*cookiep = scr;
	*curxp = scr->pcs.vc_ccol;
	*curyp = scr->pcs.vc_crow;

	return (0);
}

void
vga_free_screen(void *v, void *cookie)
{
	struct vgascreen *vs = cookie;
	struct vga_config *vc = vs->cfg;

	LIST_REMOVE(vs, next);
	vc->nscreens--;
	if (vs != &vga_console_screen) {
		/*
		 * deallocating the one but last screen
		 * removes backing store for the last one
		 */
		if (vc->nscreens == 1)
			free(LIST_FIRST(&vc->screens)->pcs.mem, M_DEVBUF, 0);

		/* Last screen has no backing store */
		if (vc->nscreens != 0)
			free(vs->pcs.mem, M_DEVBUF, 0);

		free(vs, M_DEVBUF, sizeof *vs);
	} else
		panic("vga_free_screen: console");

	if (vc->active == vs)
		vc->active = NULL;
}

void
vga_setfont(struct vga_config *vc, struct vgascreen *scr)
{
	int fontslot1, fontslot2;

	fontslot1 = (scr->fontset1 ? scr->fontset1->slot : 0);
	fontslot2 = (scr->fontset2 ? scr->fontset2->slot : fontslot1);
	if (vc->currentfontset1 != fontslot1 ||
	    vc->currentfontset2 != fontslot2) {
		vga_setfontset(&vc->hdl, fontslot1, fontslot2);
		vc->currentfontset1 = fontslot1;
		vc->currentfontset2 = fontslot2;
	}
}

int
vga_show_screen(void *v, void *cookie, int waitok, void (*cb)(void *, int, int),
    void *cbarg)
{
	struct vgascreen *scr = cookie, *oldscr;
	struct vga_config *vc = scr->cfg;

	oldscr = vc->active; /* can be NULL! */
	if (scr == oldscr) {
		return (0);
	}

	vc->wantedscreen = cookie;
	vc->switchcb = cb;
	vc->switchcbarg = cbarg;
	if (cb) {
		timeout_set(&vc->vc_switch_timeout,
		    (void(*)(void *))vga_doswitch, vc);
		timeout_add(&vc->vc_switch_timeout, 0);
		return (EAGAIN);
	}

	vga_doswitch(vc);
	return (0);
}

void
vga_doswitch(struct vga_config *vc)
{
	struct vgascreen *scr, *oldscr;
	struct vga_handle *vh = &vc->hdl;
	const struct wsscreen_descr *type;
	int s;

	scr = vc->wantedscreen;
	if (!scr) {
		printf("vga_doswitch: disappeared\n");
		(*vc->switchcb)(vc->switchcbarg, EIO, 0);
		return;
	}

	type = scr->pcs.type;
	oldscr = vc->active; /* can be NULL! */
	if (scr == oldscr)
		return;
	s = spltty();
#ifdef DIAGNOSTIC
	if (oldscr) {
		if (!oldscr->pcs.active)
			panic("vga_show_screen: not active");
		if (oldscr->pcs.type != vc->currenttype)
			panic("vga_show_screen: bad type");
	}
	if (scr->pcs.active)
		panic("vga_show_screen: active");
#endif

	scr->vga_rollover = 0;

	if (oldscr) {
		const struct wsscreen_descr *oldtype = oldscr->pcs.type;

		oldscr->pcs.active = 0;
		bus_space_read_region_2(vh->vh_memt, vh->vh_memh,
					oldscr->pcs.dispoffset, oldscr->pcs.mem,
					oldtype->ncols * oldtype->nrows);
	}

	if (vc->currenttype != type) {
		vga_setscreentype(vh, type);
		vc->currenttype = type;
	}

	vga_setfont(vc, scr);
	vga_restore_palette(vc);

	scr->pcs.visibleoffset = scr->pcs.dispoffset = scr->mindispoffset;
	if (!oldscr || (scr->pcs.dispoffset != oldscr->pcs.dispoffset)) {
		vga_6845_write(vh, startadrh, scr->pcs.dispoffset >> 9);
		vga_6845_write(vh, startadrl, scr->pcs.dispoffset >> 1);
	}

	bus_space_write_region_2(vh->vh_memt, vh->vh_memh,
				scr->pcs.dispoffset, scr->pcs.mem,
				type->ncols * type->nrows);
	scr->pcs.active = 1;
	splx(s);

	vc->active = scr;

	pcdisplay_cursor_reset(&scr->pcs);
	pcdisplay_cursor(&scr->pcs, scr->pcs.cursoron,
			 scr->pcs.vc_crow, scr->pcs.vc_ccol);

	vc->wantedscreen = 0;
	if (vc->switchcb)
		(*vc->switchcb)(vc->switchcbarg, 0, 0);
}

int
vga_load_font(void *v, void *cookie, struct wsdisplay_font *data)
{
	struct vga_config *vc = v;
	struct vgascreen *scr = cookie;
	char *name2;
	int res, slot;
	struct vgafont *f;

	if (data->data == NULL) {
		if (scr == NULL)
			return EINVAL;

		if ((name2 = data->name) != NULL) {
			while (*name2 && *name2 != ',')
				name2++;
			if (*name2)
				*name2++ = '\0';
		}
		res = vga_selectfont(vc, scr, data->name, name2);
		if (res == 0)
			vga_setfont(vc, scr);
		return (res);
	}

	if (data->fontwidth != 8 || data->stride != 1)
		return (EINVAL); /* XXX 1 byte per line */
	if (data->firstchar != 0 || data->numchars != 256)
		return (EINVAL);

	if (data->index < 0) {
		for (slot = 0; slot < VGA_MAXFONT; slot++)
			if (!vc->vc_fonts[slot])
				break;
	} else
		slot = data->index;

	if (slot >= VGA_MAXFONT)
		return (ENOSPC);

	if (vc->vc_fonts[slot] != NULL)
		return (EEXIST);
	f = malloc(sizeof(struct vgafont), M_DEVBUF, M_WAITOK | M_CANFAIL);
	if (f == NULL)
		return (ENOMEM);
	strlcpy(f->name, data->name, sizeof(f->name));
	f->height = data->fontheight;
	f->encoding = data->encoding;
#ifdef notyet
	f->firstchar = data->firstchar;
	f->numchars = data->numchars;
#endif
#ifdef VGAFONTDEBUG
	printf("vga: load %s (8x%d, enc %d) font to slot %d\n", f->name,
	       f->height, f->encoding, slot);
#endif
	vga_loadchars(&vc->hdl, slot, 0, 256, f->height, data->data);
	f->slot = slot;
	f->fontdata = data->data;
	vc->vc_fonts[slot] = f;
	data->cookie = f;
	data->index = slot;

	return (0);
}

int
vga_list_font(void *v, struct wsdisplay_font *data)
{
	struct vga_config *vc = v;
	struct vgafont *f;

	if (data->index < 0 || data->index >= VGA_MAXFONT)
		return EINVAL;

	if ((f = vc->vc_fonts[data->index]) == NULL)
		return EINVAL;

	strlcpy(data->name, f->name, sizeof data->name);
#ifdef notyet
	data->firstchar = f->firstchar;
	data->numchars = f->numchars;
#else
	data->firstchar = 0;
	data->numchars = 256;
#endif
	data->encoding = f->encoding;
	data->fontwidth = 8;
	data->fontheight = f->height;
	data->stride = 1;
	data->bitorder = data->byteorder = WSDISPLAY_FONTORDER_L2R;

	return (0);
}

void
vga_scrollback(void *v, void *cookie, int lines)
{
	struct vga_config *vc = v;
	struct vgascreen *scr = cookie;
	struct vga_handle *vh = &vc->hdl;

	if (lines == 0) {
		if (scr->pcs.visibleoffset == scr->pcs.dispoffset)
			return;

		scr->pcs.visibleoffset = scr->pcs.dispoffset;	/* reset */
	}
	else {
		int vga_scr_end;
		int margin = scr->pcs.type->ncols * 2;
		int ul, we, p, st;

		vga_scr_end = (scr->pcs.dispoffset + scr->pcs.type->ncols *
		    scr->pcs.type->nrows * 2);
		if (scr->vga_rollover > vga_scr_end + margin) {
			ul = vga_scr_end;
			we = scr->vga_rollover + scr->pcs.type->ncols * 2;
		} else {
			ul = 0;
			we = 0x8000;
		}
		p = (scr->pcs.visibleoffset - ul + we) % we + lines *
		    (scr->pcs.type->ncols * 2);
		st = (scr->pcs.dispoffset - ul + we) % we;
		if (p < margin)
			p = 0;
		if (p > st - margin)
			p = st;
		scr->pcs.visibleoffset = (p + ul) % we;
	}
	
	/* update visible position */
	vga_6845_write(vh, startadrh, scr->pcs.visibleoffset >> 9);
	vga_6845_write(vh, startadrl, scr->pcs.visibleoffset >> 1);
}

int
vga_alloc_attr(void *id, int fg, int bg, int flags, long *attrp)
{
	struct vgascreen *scr = id;
	struct vga_config *vc = scr->cfg;

	if (vc->hdl.vh_mono) {
		if (flags & WSATTR_WSCOLORS)
			return (EINVAL);
		if (flags & WSATTR_REVERSE)
			*attrp = 0x70;
		else
			*attrp = 0x07;
		if (flags & WSATTR_UNDERLINE)
			*attrp |= FG_UNDERLINE;
		if (flags & WSATTR_HILIT)
			*attrp |= FG_INTENSE;
	} else {
		if (flags & (WSATTR_UNDERLINE | WSATTR_REVERSE))
			return (EINVAL);
		if (flags & WSATTR_WSCOLORS)
			*attrp = fgansitopc[fg & 7] | bgansitopc[bg & 7];
		else
			*attrp = 7;
		if ((flags & WSATTR_HILIT) || (fg & 8) || (bg & 8))
			*attrp += 8;
	}
	if (flags & WSATTR_BLINK)
		*attrp |= FG_BLINK;
	return (0);
}

void
vga_unpack_attr(void *id, long attr, int *fg, int *bg, int *ul)
{
	struct vgascreen *scr = id;
	struct vga_config *vc = scr->cfg;

	if (vc->hdl.vh_mono) {
		*fg = (attr & 0x07) == 0x07 ? WSCOL_WHITE : WSCOL_BLACK;
		*bg = attr & 0x70 ? WSCOL_WHITE : WSCOL_BLACK;
		if (ul != NULL)
			*ul = *fg != WSCOL_WHITE && (attr & 0x01) ? 1 : 0;
	} else {
		*fg = pctoansi[attr & 0x07];
		*bg = pctoansi[(attr & 0x70) >> 4];
		if (ul != NULL)
			*ul = 0;
	}
	if (attr & FG_INTENSE)
		*fg += 8;
}

int
vga_copyrows(void *id, int srcrow, int dstrow, int nrows)
{
	struct vgascreen *scr = id;
	bus_space_tag_t memt = scr->pcs.hdl->ph_memt;
	bus_space_handle_t memh = scr->pcs.hdl->ph_memh;
	int ncols = scr->pcs.type->ncols;
	bus_size_t srcoff, dstoff;
	int s;

	srcoff = srcrow * ncols + 0;
	dstoff = dstrow * ncols + 0;

	s = spltty();
	if (scr->pcs.active) {
		if (dstrow == 0 && (srcrow + nrows == scr->pcs.type->nrows)) {
#ifdef PCDISPLAY_SOFTCURSOR
			int cursoron = scr->pcs.cursoron;

			/* NOTE this assumes pcdisplay_cursor() never fails */
			if (cursoron)
				pcdisplay_cursor(&scr->pcs, 0,
				    scr->pcs.vc_crow, scr->pcs.vc_ccol);
#endif
			/* scroll up whole screen */
			if ((scr->pcs.dispoffset + srcrow * ncols * 2)
			    <= scr->maxdispoffset) {
				scr->pcs.dispoffset += srcrow * ncols * 2;
			} else {
				bus_space_copy_2(memt, memh,
					scr->pcs.dispoffset + srcoff * 2,
					memh, scr->mindispoffset,
					nrows * ncols);
				scr->vga_rollover = scr->pcs.dispoffset;
				scr->pcs.dispoffset = scr->mindispoffset;
			}
			scr->pcs.visibleoffset = scr->pcs.dispoffset;
			vga_6845_write(&scr->cfg->hdl, startadrh,
				       scr->pcs.dispoffset >> 9);
			vga_6845_write(&scr->cfg->hdl, startadrl,
				       scr->pcs.dispoffset >> 1);
#ifdef PCDISPLAY_SOFTCURSOR
			/* NOTE this assumes pcdisplay_cursor() never fails */
			if (cursoron)
				pcdisplay_cursor(&scr->pcs, 1,
				    scr->pcs.vc_crow, scr->pcs.vc_ccol);
#endif
		} else {
			bus_space_copy_2(memt, memh,
					scr->pcs.dispoffset + srcoff * 2,
					memh, scr->pcs.dispoffset + dstoff * 2,
					nrows * ncols);
		}
	} else
		bcopy(&scr->pcs.mem[srcoff], &scr->pcs.mem[dstoff],
		      nrows * ncols * 2);
	splx(s);

	return 0;
}

int _vga_mapchar(void *, struct vgafont *, int, unsigned int *);

int
_vga_mapchar(void *id, struct vgafont *font, int uni, unsigned int *index)
{

	switch (font->encoding) {
	case WSDISPLAY_FONTENC_ISO:
		if (uni < 256) {
			*index = uni;
			return (5);
		} else {
			*index = '?';
			return (0);
		}
		break;
	case WSDISPLAY_FONTENC_IBM:
		return (pcdisplay_mapchar(id, uni, index));
	default:
#ifdef VGAFONTDEBUG
		printf("_vga_mapchar: encoding=%d\n", font->encoding);
#endif
		*index = '?';
		return (0);
	}
}

int
vga_mapchar(void *id, int uni, unsigned int *index)
{
	struct vgascreen *scr = id;
	unsigned int idx1, idx2;
	int res1, res2;

	res1 = 0;
	idx1 = ' '; /* space */
	if (scr->fontset1)
		res1 = _vga_mapchar(id, scr->fontset1, uni, &idx1);
	res2 = -1;
	if (scr->fontset2) {
		KASSERT(VGA_SCREEN_CANTWOFONTS(scr->pcs.type));
		res2 = _vga_mapchar(id, scr->fontset2, uni, &idx2);
	}
	if (res2 >= res1) {
		*index = idx2 | 0x0800; /* attribute bit 3 */
		return (res2);
	}
	*index = idx1;
	return (res1);
}

int
vga_putchar(void *c, int row, int col, u_int uc, long attr)
{
	struct vgascreen *scr = c;
	int rc;
	int s;
	
	s = spltty();
	if (scr->pcs.active && scr->pcs.visibleoffset != scr->pcs.dispoffset)
		vga_scrollback(scr->cfg, scr, 0);
	rc = pcdisplay_putchar(c, row, col, uc, attr);
	splx(s);

	return rc;
}

void
vga_burner(void *v, u_int on, u_int flags)
{
	struct vga_config *vc = v;
	struct vga_handle *vh = &vc->hdl;
	u_int8_t r;
	int s;

	s = splhigh();
	vga_ts_write(vh, syncreset, 0x01);
	if (on) {
		vga_ts_write(vh, mode, (vga_ts_read(vh, mode) & ~0x20));
		r = vga_6845_read(vh, mode) | 0x80;
		DELAY(10000);
		vga_6845_write(vh, mode, r);
	} else {
		vga_ts_write(vh, mode, (vga_ts_read(vh, mode) | 0x20));
		if (flags & WSDISPLAY_BURN_VBLANK) {
			r = vga_6845_read(vh, mode) & ~0x80;
			DELAY(10000);
			vga_6845_write(vh, mode, r);
		}
	}
	vga_ts_write(vh, syncreset, 0x03);
	splx(s);
}

int
vga_getchar(void *c, int row, int col, struct wsdisplay_charcell *cell)
{
	struct vga_config *vc = c;
	
	return (pcdisplay_getchar(vc->active, row, col, cell));
}	

void
vga_save_palette(struct vga_config *vc)
{
	struct vga_handle *vh = &vc->hdl;
	uint i;
	uint8_t *palette = vc->vc_palette;

	if (vh->vh_mono)
		return;

	vga_raw_write(vh, VGA_DAC_MASK, 0xff);
	vga_raw_write(vh, VGA_DAC_READ, 0x00);
	for (i = 0; i < 3 * 256; i++)
		*palette++ = vga_raw_read(vh, VGA_DAC_DATA);

	vga_raw_read(vh, 0x0a);			/* reset flip/flop */
}

void
vga_restore_palette(struct vga_config *vc)
{
	struct vga_handle *vh = &vc->hdl;
	uint i;
	uint8_t *palette = vc->vc_palette;

	if (vh->vh_mono)
		return;

	vga_raw_write(vh, VGA_DAC_MASK, 0xff);
	vga_raw_write(vh, VGA_DAC_WRITE, 0x00);
	for (i = 0; i < 3 * 256; i++)
		vga_raw_write(vh, VGA_DAC_DATA, *palette++);

	vga_raw_read(vh, 0x0a);			/* reset flip/flop */

	vga_enable(vh);
}

void
vga_restore_fonts(struct vga_config *vc)
{
	int slot;
	struct vgafont *f;

	for (slot = 0; slot < VGA_MAXFONT; slot++) {
		f = vc->vc_fonts[slot];
		if (f == NULL || f->fontdata == NULL)
			continue;

		vga_loadchars(&vc->hdl, slot, 0, 256, f->height, f->fontdata);
	}
}

#ifdef __alpha__
void
vga_pick_monitor_type(struct vga_config *vc)
{
	struct vga_handle *vh = &vc->hdl;

	/*
	 * The Tadpole Alphabook1 uses a 800x600 flat panel in text mode,
	 * causing the display console to really be 100x37 instead of the
	 * usual 80x25.
	 * We attempt to detect this here by checking the CRTC registers.
	 */
	unsigned int hend, oflow, vend;
	unsigned int width, height;

	hend = vga_6845_read(vh, hdisple);
	oflow = vga_6845_read(vh, overfll);
	vend = vga_6845_read(vh, vde);
	if (oflow & 0x02)
		vend |= 0x100;
	if (oflow & 0x40)
		vend |= 0x200;

	width = hend + 1;
	height = (vend + 1) / 16;

	/* check that the values sound plausible */
	if ((width > 80 && width <= 128) && (height > 25 && height <= 50)) {
		snprintf(vc->custom_scr.name, sizeof(vc->custom_scr.name),
		    "%ux%u", width, height);
		vc->custom_scr.ncols = width;
		vc->custom_scr.nrows = height;
		vc->custom_scr.textops = &vga_emulops;
		vc->custom_scr.fontwidth = 8;
		vc->custom_scr.fontheight = 16;
		vc->custom_scr.capabilities =
		    WSSCREEN_WSCOLORS | WSSCREEN_HILIT | WSSCREEN_BLINK;
		vc->custom_scrlist[0] = &vc->custom_scr;
		vc->custom_list.nscreens = 1;
		vc->custom_list.screens =
		    (const struct wsscreen_descr **)vc->custom_scrlist;
	}
}
#endif

struct cfdriver vga_cd = {
	NULL, "vga", DV_DULL
};
@


1.67
log
@When attaching on an alpha system, get the current textmode resolution by
querying the 6845 registers, and preserve it if it is larger than 80x25 yet
plausible.

This is necessary to properly operate on the Alphabook 1 where the vga display
is running in a 100x37 textmode.

Other platforms are not affected.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.66 2015/07/18 00:48:05 miod Exp $ */
d733 1
a733 1
		free(vs, M_DEVBUF, 0);
@


1.66
log
@Shuffle include file ordering in preparation for future changes in vgavar.h,
which will have it depend upon wsdisplayvar.h.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.65 2015/03/29 18:45:22 miod Exp $ */
d112 1
d501 4
d508 7
a514 1
	vc->currenttype = vh->vh_mono ? &vga_stdscreen_mono : &vga_stdscreen;
d561 8
a568 1
	aa.scrdata = (vc->hdl.vh_mono ? &vga_screenlist_mono : &vga_screenlist);
d1260 45
@


1.65
log
@Restore user-loaded vga fonts upon X11->VT switch and upon resume; from
dan mclaughlin, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.64 2015/03/29 17:23:00 miod Exp $ */
a72 1
#include <dev/ic/vgavar.h>
d78 1
@


1.64
log
@In vga_load_font(), keep track of the font bits being passed by the caller,
should the need to free them arise; and only perform the `use font' logic
if we are in the `use font' case (i.e. font->data == NULL).

Prompted by a discussion with dan mclaughlin on tech@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.63 2014/07/13 23:10:23 deraadt Exp $ */
d360 1
a360 1
	for (i = 0; i < 8; i++) {
d506 1
a506 1
	for (i = 1; i < 8; i++)
d620 2
a621 1
		if (mode == WSDISPLAYIO_MODE_EMUL)
d623 1
d868 1
a868 1
		for (slot = 0; slot < 8; slot++)
d874 1
a874 1
	if (slot >= 8)
d909 1
a909 1
	if (data->index < 0 || data->index >= nitems(vc->vc_fonts))
d1226 15
@


1.63
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.62 2014/07/12 18:48:17 tedu Exp $ */
d89 1
d91 3
a93 3
	"builtin",
	16,
	WSDISPLAY_FONTENC_IBM,
d95 2
a96 1
	0, 256,
d98 2
a99 1
	0
d844 4
a847 1
	if (scr) {
d855 1
a855 1
		if (!res)
d893 1
@


1.62
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.61 2013/10/20 21:24:00 miod Exp $ */
d666 2
a667 3
		scr->pcs.mem =
		  malloc(scr->pcs.type->ncols * scr->pcs.type->nrows * 2,
		    M_DEVBUF, M_WAITOK);
d678 2
a679 2
		scr->pcs.mem = malloc(type->ncols * type->nrows * 2,
				      M_DEVBUF, M_WAITOK);
@


1.61
log
@No longer store fonts added with the WSDISPLAYIO_LDFONT ioctl into the
wsdisplay softc. Instead, since the knowledge about available fonts lies in
the parent driver itself, introduce a list_font wsdisplay_accessop which
queries a font index, suitable to use within the WSDISPLAYIO_LSFONT ioctl.

With this in place:
- there is no global wsdisplay limit on the number of fonts loaded. Such a
  limit will be enforced by the display drivers themselves.
- built-in kernel fonts will now appear in the list of fonts.

Grow a list_font accesop for rasops, which relies upon wsfont_enum(), which
is turned into something useful (and abortable if you do not need to iterate
further). Not used by any rasops driver yet.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.60 2013/10/20 20:07:29 miod Exp $ */
d705 1
a705 1
			free(LIST_FIRST(&vc->screens)->pcs.mem, M_DEVBUF);
d709 1
a709 1
			free(vs->pcs.mem, M_DEVBUF);
d711 1
a711 1
		free(vs, M_DEVBUF);
@


1.60
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.59 2013/10/19 14:32:45 miod Exp $ */
d248 1
d262 1
d504 1
a504 1
		vc->vc_fonts[i] = 0;
d891 29
@


1.59
log
@Remove never enabled WSCONS_SUPPORT_PCVTFONTS code.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.58 2013/10/18 17:38:33 miod Exp $ */
d255 9
a263 9
	vga_ioctl,
	vga_mmap,
	vga_alloc_screen,
	vga_free_screen,
	vga_show_screen,
	vga_load_font,
	vga_scrollback,
	vga_getchar,
	vga_burner
@


1.58
log
@Make sure that, when a particular mapchar() can't find a proper glyph for the
requested character in the font it is using, it suggests a question mark
character, instead of a space, so that the existence of the non-representable
character becomes visible.

Note that this is consistent with pcdisplay which suggests a diamond for
missing glyphs.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.57 2013/07/06 14:36:33 kettenis Exp $ */
a856 6
#ifndef WSCONS_SUPPORT_PCVTFONTS
	if (data->encoding == WSDISPLAY_FONTENC_PCVT) {
		printf("vga: pcvt font support not built in, see vga(4)\n");
		return (EINVAL);
	}
#endif
a1048 135
#ifdef WSCONS_SUPPORT_PCVTFONTS

#define NOTYET 0xffff
static const u_int16_t pcvt_unichars[0xa0] = {
/* 0 */	_e006U,
	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
	NOTYET,
	0x2409, /* SYMBOL FOR HORIZONTAL TABULATION */
	0x240a, /* SYMBOL FOR LINE FEED */
	0x240b, /* SYMBOL FOR VERTICAL TABULATION */
	0x240c, /* SYMBOL FOR FORM FEED */
	0x240d, /* SYMBOL FOR CARRIAGE RETURN */
	NOTYET, NOTYET,
/* 1 */	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
/* 2 */	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
/* 3 */	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
/* 4 */	0x03c1, /* GREEK SMALL LETTER RHO */
	0x03c8, /* GREEK SMALL LETTER PSI */
	0x2202, /* PARTIAL DIFFERENTIAL */
	0x03bb, /* GREEK SMALL LETTER LAMDA */
	0x03b9, /* GREEK SMALL LETTER IOTA */
	0x03b7, /* GREEK SMALL LETTER ETA */
	0x03b5, /* GREEK SMALL LETTER EPSILON */
	0x03c7, /* GREEK SMALL LETTER CHI */
	0x2228, /* LOGICAL OR */
	0x2227, /* LOGICAL AND */
	0x222a, /* UNION */
	0x2283, /* SUPERSET OF */
	0x2282, /* SUBSET OF */
	0x03a5, /* GREEK CAPITAL LETTER UPSILON */
	0x039e, /* GREEK CAPITAL LETTER XI */
	0x03a8, /* GREEK CAPITAL LETTER PSI */
/* 5 */	0x03a0, /* GREEK CAPITAL LETTER PI */
	0x21d2, /* RIGHTWARDS DOUBLE ARROW */
	0x21d4, /* LEFT RIGHT DOUBLE ARROW */
	0x039b, /* GREEK CAPITAL LETTER LAMDA */
	0x0398, /* GREEK CAPITAL LETTER THETA */
	0x2243, /* ASYMPTOTICALLY EQUAL TO */
	0x2207, /* NABLA */
	0x2206, /* INCREMENT */
	0x221d, /* PROPORTIONAL TO */
	0x2234, /* THEREFORE */
	0x222b, /* INTEGRAL */
	0x2215, /* DIVISION SLASH */
	0x2216, /* SET MINUS */
	_e00eU,
	_e00dU,
	_e00bU,
/* 6 */	_e00cU,
	_e007U,
	_e008U,
	_e009U,
	_e00aU,
	0x221a, /* SQUARE ROOT */
	0x03c9, /* GREEK SMALL LETTER OMEGA */
	0x00a5, /* YEN SIGN */
	0x03be, /* GREEK SMALL LETTER XI */
	0x00fd, /* LATIN SMALL LETTER Y WITH ACUTE */
	0x00fe, /* LATIN SMALL LETTER THORN */
	0x00f0, /* LATIN SMALL LETTER ETH */
	0x00de, /* LATIN CAPITAL LETTER THORN */
	0x00dd, /* LATIN CAPITAL LETTER Y WITH ACUTE */
	0x00d7, /* MULTIPLICATION SIGN */
	0x00d0, /* LATIN CAPITAL LETTER ETH */
/* 7 */	0x00be, /* VULGAR FRACTION THREE QUARTERS */
	0x00b8, /* CEDILLA */
	0x00b4, /* ACUTE ACCENT */
	0x00af, /* MACRON */
	0x00ae, /* REGISTERED SIGN */
	0x00ad, /* SOFT HYPHEN */
	0x00ac, /* NOT SIGN */
	0x00a8, /* DIAERESIS */
	0x2260, /* NOT EQUAL TO */
	_e005U,
	_e004U,
	_e003U,
	_e002U,
	_e001U,
	0x03c5, /* GREEK SMALL LETTER UPSILON */
	0x00f8, /* LATIN SMALL LETTER O WITH STROKE */
/* 8 */	0x0153, /* LATIN SMALL LIGATURE OE */
	0x00f5, /* LATIN SMALL LETTER O WITH TILDE !!!doc bug */
	0x00e3, /* LATIN SMALL LETTER A WITH TILDE */
	0x0178, /* LATIN CAPITAL LETTER Y WITH DIAERESIS */
	0x00db, /* LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
	0x00da, /* LATIN CAPITAL LETTER U WITH ACUTE */
	0x00d9, /* LATIN CAPITAL LETTER U WITH GRAVE */
	0x00d8, /* LATIN CAPITAL LETTER O WITH STROKE */
	0x0152, /* LATIN CAPITAL LIGATURE OE */
	0x00d5, /* LATIN CAPITAL LETTER O WITH TILDE */
	0x00d4, /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
	0x00d3, /* LATIN CAPITAL LETTER O WITH ACUTE */
	0x00d2, /* LATIN CAPITAL LETTER O WITH GRAVE */
	0x00cf, /* LATIN CAPITAL LETTER I WITH DIAERESIS */
	0x00ce, /* LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
	0x00cd, /* LATIN CAPITAL LETTER I WITH ACUTE */
/* 9 */	0x00cc, /* LATIN CAPITAL LETTER I WITH GRAVE */
	0x00cb, /* LATIN CAPITAL LETTER E WITH DIAERESIS */
	0x00ca, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
	0x00c8, /* LATIN CAPITAL LETTER E WITH GRAVE */
	0x00c3, /* LATIN CAPITAL LETTER A WITH TILDE */
	0x00c2, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
	0x00c1, /* LATIN CAPITAL LETTER A WITH ACUTE */
	0x00c0, /* LATIN CAPITAL LETTER A WITH GRAVE */
	0x00b9, /* SUPERSCRIPT ONE */
	0x00b7, /* MIDDLE DOT */
	0x03b6, /* GREEK SMALL LETTER ZETA */
	0x00b3, /* SUPERSCRIPT THREE */
	0x00a9, /* COPYRIGHT SIGN */
	0x00a4, /* CURRENCY SIGN */
	0x03ba, /* GREEK SMALL LETTER KAPPA */
	_e000U
};

int vga_pcvt_mapchar(int, unsigned int *);

int
vga_pcvt_mapchar(int uni, unsigned int *index)
{
	int i;

	for (i = 0; i < 0xa0; i++) /* 0xa0..0xff are reserved */
		if (uni == pcvt_unichars[i]) {
			*index = i;
			return (5);
		}
	*index = 0x99; /* middle dot */
	return (0);
}

#endif /* WSCONS_SUPPORT_PCVTFONTS */

d1061 1
a1061 1
			*index = ' ';
a1066 4
#ifdef WSCONS_SUPPORT_PCVTFONTS
	case WSDISPLAY_FONTENC_PCVT:
		return (vga_pcvt_mapchar(uni, index));
#endif
@


1.57
log
@Use wsemuldisplaydevsubmatch.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.56 2013/03/18 10:12:40 kettenis Exp $ */
d1216 1
a1216 1
		*index = ' ';
@


1.56
log
@Provide a way for *drm(4) to prevent the VGA text console wsdisplay(4) instance
from attaching after it has taken over control of the VGA hardware.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.55 2011/04/03 15:46:30 miod Exp $ */
a115 2
int	displaysubmatch(struct device *, void *, void *);

d550 2
a551 1
        config_found_sm(self, &aa, wsemuldisplaydevprint, displaysubmatch);
a553 12
}

int
displaysubmatch(struct device *parent, void *match, void *aux)
{
	extern struct cfdriver wsdisplay_cd;
	struct cfdata *cf = match;

	/* only allow wsdisplay to attach */
	if (cf->cf_driver == &wsdisplay_cd)
		return ((*cf->cf_attach->ca_match)(parent, match, aux));
	return (0);
@


1.55
log
@Sprinkle spltty around code which plays with either the video memory or
the backing store. The state of a VT is only coherent if both the active
flag and the backing store are in order, which is not the case during VT
switches.
This fixes display glitches occuring during VT switches if one of the
VT involved is doing a lot of tty updates.
Noticed by deraadt@@ on a machine too fast for mere mortals.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.54 2010/08/28 12:48:14 miod Exp $ */
d527 5
a534 1
		vga_console_attached = 1;
@


1.54
log
@ansify function definitions, and constify a few arrays while there.
no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.53 2010/08/08 17:21:05 miod Exp $ */
d773 1
d781 1
d784 3
a793 5
#endif
	if (scr == oldscr) {
		return;
	}
#ifdef DIAGNOSTIC
d827 1
d1011 1
d1016 1
d1059 1
d1258 5
a1262 2

	if (scr->pcs.visibleoffset != scr->pcs.dispoffset)
d1264 2
d1267 1
a1267 1
	return pcdisplay_putchar(c, row, col, uc, attr);
@


1.53
log
@Try to save the vga hardware state around suspend, and also redisplay the
textmode video memory contents if we had to POST the vga bios.
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.52 2009/09/05 14:09:35 miod Exp $ */
d273 1
a273 2
vga_common_probe(iot, memt)
	bus_space_tag_t iot, memt;
d348 2
a349 4
vga_selectfont(vc, scr, name1, name2)
	struct vga_config *vc;
	struct vgascreen *scr;
	const char *name1, *name2; /* NULL: take first found */
d400 2
a401 6
vga_init_screen(vc, scr, type, existing, attrp)
	struct vga_config *vc;
	struct vgascreen *scr;
	const struct wsscreen_descr *type;
	int existing;
	long *attrp;
d469 1
a469 3
vga_init(vc, iot, memt)
	struct vga_config *vc;
	bus_space_tag_t iot, memt;
d512 2
a513 4
vga_common_attach(self, iot, memt, type)
	struct device *self;
	bus_space_tag_t iot, memt;
	int type;
d519 2
a520 5
vga_extended_attach(self, iot, memt, type, map)
	struct device *self;
	bus_space_tag_t iot, memt;
	int type;
	paddr_t (*map)(void *, off_t, int);
d566 1
a566 3
vga_cnattach(iot, memt, type, check)
	bus_space_tag_t iot, memt;
	int type, check;
d593 1
a593 3
vga_is_console(iot, type)
	bus_space_tag_t iot;
	int type;
d604 1
a604 6
vga_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d649 1
a649 4
vga_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d656 1
a656 1
	return -1;
d660 2
a661 6
vga_alloc_screen(v, type, cookiep, curxp, curyp, defattrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *defattrp;
d699 1
a699 3
vga_free_screen(v, cookie)
	void *v;
	void *cookie;
d727 1
a727 3
vga_setfont(vc, scr)
	struct vga_config *vc;
	struct vgascreen *scr;
d742 2
a743 6
vga_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d768 1
a768 2
vga_doswitch(vc)
	struct vga_config *vc;
d840 1
a840 4
vga_load_font(v, cookie, data)
	void *v;
	void *cookie;
	struct wsdisplay_font *data;
d908 1
a908 4
vga_scrollback(v, cookie, lines)
	void *v;
	void *cookie;
	int lines;
d950 1
a950 5
vga_alloc_attr(id, fg, bg, flags, attrp)
	void *id;
	int fg, bg;
	int flags;
	long *attrp;
d982 1
a982 4
vga_unpack_attr(id, attr, fg, bg, ul)
	void *id;
	long attr;
	int *fg, *bg, *ul;
d1003 1
a1003 3
vga_copyrows(id, srcrow, dstrow, nrows)
	void *id;
	int srcrow, dstrow, nrows;
d1063 1
a1063 1
static u_int16_t pcvt_unichars[0xa0] = {
d1180 1
a1180 3
vga_pcvt_mapchar(uni, index)
	int uni;
	unsigned int *index;
d1198 1
a1198 5
_vga_mapchar(id, font, uni, index)
	void *id;
	struct vgafont *font;
	int uni;
	unsigned int *index;
d1227 1
a1227 4
vga_mapchar(id, uni, index)
	void *id;
	int uni;
	unsigned int *index;
d1251 1
a1251 6
vga_putchar(c, row, col, uc, attr)
	void *c;
	int row;
	int col;
	u_int uc;
	long attr;
d1262 1
a1262 3
vga_burner(v, on, flags)
	void *v;
	u_int on, flags;
d1289 1
a1289 4
vga_getchar(c, row, col, cell)
	void *c;
	int row, col;
	struct wsdisplay_charcell *cell;
@


1.52
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.51 2009/08/12 15:58:30 miod Exp $ */
a98 15
struct vgascreen {
	struct pcdisplayscreen pcs;

	LIST_ENTRY(vgascreen) next;

	struct vga_config *cfg;

	/* videostate */
	struct vgafont *fontset1, *fontset2;
	/* font data */

	int mindispoffset, maxdispoffset;
	int vga_rollover;
};

a509 3
#if 0
	callout_init(&vc->vc_switch_callout);
#endif
d520 1
a520 1
void
d526 1
a526 1
	vga_extended_attach(self, iot, memt, type, NULL);
d529 1
a529 1
void
d548 1
a548 1
			return;
d563 2
@


1.51
log
@Backing store for ega and vga virtual console is not allocated until the
second vc is created.  However, it was allocated using the geometry of
the second vc to allocate backing store for the first.  Be sure to use
the proper values in case geometries differ.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.50 2009/03/29 21:53:52 sthen Exp $ */
d126 1
a126 1
void	vga_putchar(void *, int, int, u_int, long);
d128 1
a128 1
void	vga_copyrows(void *, int, int, int);
d1070 1
a1070 1
void
d1089 1
d1112 1
d1126 2
d1329 1
a1329 1
void
d1342 1
a1342 1
	pcdisplay_putchar(c, row, col, uc, attr);
@


1.50
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.49 2009/02/15 17:08:23 chl Exp $ */
d718 4
a721 2
		LIST_FIRST(&vc->screens)->pcs.mem =
		  malloc(type->ncols * type->nrows * 2, M_DEVBUF, M_WAITOK);
@


1.49
log
@change M_WAITOK --> M_WAITOK | M_CANFAIL

with help from miod@@

ok miod@@ oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.48 2009/02/01 14:37:22 miod Exp $ */
d503 1
a503 1
                panic("vga_common_setup: couldn't map vga io");
d511 1
a511 1
                panic("vga_common_setup: couldn't map 6845 io");
d514 1
a514 1
                panic("vga_common_setup: couldn't map memory");
@


1.48
log
@Save the text mode color palette upon startup, and restore it when
switching consoles or when X11 exits. Almost all other operating systems
do this, and thus do not suffer from palette bugs in some X11 drivers.

From FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.47 2008/03/16 19:00:28 oga Exp $ */
d940 1
a940 1
	f = malloc(sizeof(struct vgafont), M_DEVBUF, M_WAITOK);
@


1.47
log
@Make agp(4) attach at vga(4) instead of pchb(4). This is because sometimes
agp and drm need to use the same memory mapping, the best way to deal
with that is to allow them to share (that's coming later), for this to
work cleanly we move the attach point of agp.

Ideally most agp drivers would attach at pchb, with only agp_i810
(and any that work similarly) attaching at vga, but this will do for
now.

ok kettenis@@, miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.46 2007/10/01 04:03:51 krw Exp $ */
d4 29
a108 1
	/* palette */
d534 2
d646 1
d661 6
d868 1
a868 1
	/* XXX switch colours! */
d1378 38
@


1.46
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.45 2007/02/11 20:29:22 miod Exp $ */
d103 2
d550 13
a562 1
        config_found(self, &aa, wsemuldisplaydevprint);
@


1.45
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.44 2007/02/06 22:03:23 miod Exp $ */
d532 1
a532 1
		vc = malloc(sizeof(struct vga_config), M_DEVBUF, M_NOWAIT);
a534 1
		bzero(vc, sizeof(struct vga_config));
@


1.44
log
@Evil typo; spotted by Thorsten Glaser
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.43 2006/12/02 19:11:09 miod Exp $ */
a50 4

#if 0
#include "opt_wsdisplay_compat.h" /* for WSCONS_SUPPORT_PCVTFONTS */
#endif
@


1.43
log
@In alloc_attr(), make sure xxansitopc[] indicies are within bounds.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.42 2006/11/29 19:11:15 miod Exp $ */
d1015 1
a1015 1
		if (*ul != NULL)
@


1.42
log
@Change the getchar wsdisplay_accessops function to not return a
display-dependent value, but instead fill a structure with the chaarcter
and a valid attribute, suitable for use with unpack_attr.

Adapt the wsmoused code to these changes, and remove all knowledge of
the text-mode style pc video attributes in it.

This will eventually allow wsmoused to be used on non-pcdisplay devices.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.41 2006/11/29 19:08:22 miod Exp $ */
d987 1
a987 1
			*attrp = fgansitopc[fg] | bgansitopc[bg];
d990 1
a990 1
		if (flags & WSATTR_HILIT)
@


1.41
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.40 2006/11/29 12:13:54 miod Exp $ */
d241 1
a241 1
u_int16_t vga_getchar(void *, int, int);
d1322 2
a1323 2
u_int16_t
vga_getchar(c, row, col)
d1326 1
d1330 1
a1330 1
	return (pcdisplay_getchar(vc->active, row, col));
@


1.40
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.39 2006/09/29 19:46:02 miod Exp $ */
d105 1
d115 2
a116 1
	vga_alloc_attr
d122 1
a122 1
static unsigned char fgansitopc[] = {
d145 14
d996 24
@


1.39
log
@If option PCDISPLAY_SOFTCURSOR, force the hardware cursor off every time
we switch vt, so that the hardware cursor does not reappear after starting
X11, and switching to a text vt.

Spotted by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.38 2005/01/31 06:41:27 miod Exp $ */
d535 1
@


1.38
log
@Be sure to always return an error for unrecognized ioctls. Found by matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.37 2005/01/05 23:04:25 miod Exp $ */
d820 1
@


1.37
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.36 2004/12/26 21:22:13 miod Exp $ */
d616 1
@


1.36
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.35 2004/12/25 23:58:14 miod Exp $ */
d602 5
a606 1
		return 0;
a610 2
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
d620 1
a620 1
	return -1;
@


1.35
log
@Do not allow loading a font in an used font slot; discussed with and ok mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.34 2004/11/04 15:03:53 mickey Exp $ */
d652 1
a652 1
		vc->screens.lh_first->pcs.mem =
d692 1
a692 1
			free(vc->screens.lh_first->pcs.mem, M_DEVBUF);
@


1.34
log
@fix memory leak on deleting a screen; from janjaap@@stack.nl via pr3977
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.33 2004/08/06 13:25:30 pefo Exp $ */
d871 4
a874 3
	if (!vc->vc_fonts[slot])
		f = malloc(sizeof(struct vgafont), M_DEVBUF, M_WAITOK);
	if (!f)
@


1.33
log
@Easy one! Remove two redundant assignments.
OK from miod@@, millert@@, henning@@, marcus@@ .... :)
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.32 2004/02/27 17:44:44 millert Exp $ */
d685 13
a697 1
	if (vs != &vga_console_screen)
d699 1
a699 1
	else
d703 1
a703 1
		vc->active = 0;
@


1.32
log
@Fix a botched strchr() inlining in vga_load_font and avoid dereferencing
data->name if it is NULL.   Fixes the WSDISPLAY_USEFONT ioctl.
Adapted from a patch by Benjamin Lewis; NULL check from NetBSD.  OK tdeval@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.31 2003/05/17 18:31:03 krw Exp $ */
a997 2
				memt = memt;
				memh = memh;
@


1.31
log
@Replace suspect strncpy with strlcpy to ensure null termination.

ok tdeval@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.30 2002/07/12 20:17:03 mickey Exp $ */
d826 6
a831 5
		name2 = data->name;
		while (*name2 && *name2 != ',')
			name2++;
		if (name2)
			*name2++ = '\0';
@


1.30
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.29 2002/03/14 03:16:05 millert Exp $ */
d862 1
a862 1
	strncpy(f->name, data->name, sizeof(f->name));
@


1.29
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.28 2002/03/14 01:26:55 millert Exp $ */
a499 1
#ifdef arc
d508 1
a508 1
	int (*map)(void *, vaddr_t, int);
a509 1
#endif /* arc */
a528 1
#ifdef arc
a529 1
#endif
a626 2

#ifdef arc
d631 1
a631 3
#else
	/* XXX */
#endif
@


1.28
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.27 2001/08/03 16:17:47 tholo Exp $ */
d94 1
a94 1
int vga_selectfont(struct vga_config *, struct vgascreen *,
d99 1
a99 1
void vga_setfont(struct vga_config *, struct vgascreen *);
d101 3
a103 3
int vga_mapchar(void *, int, unsigned int *);
void vga_putchar(void *, int, int, u_int, long);
int vga_alloc_attr(void *, int, int, int, long *);
d218 1
a218 1
			      void **, int *, int *, long *);
d220 2
a221 2
int	vga_show_screen __P((void *, void *, int,
			     void (*) (void *, int, int), void *));
@


1.27
log
@Avoid warning when building with vga on isa without vga on pci; ok mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.26 2001/05/16 19:17:01 mickey Exp $ */
d94 11
a104 11
int vga_selectfont __P((struct vga_config *, struct vgascreen *,
    const char *, const char *));
void	vga_init_screen __P((struct vga_config *, struct vgascreen *,
    const struct wsscreen_descr *, int, long *));
void	vga_init __P((struct vga_config *, bus_space_tag_t, bus_space_tag_t));
void vga_setfont __P((struct vga_config *, struct vgascreen *));

int vga_mapchar __P((void *, int, unsigned int *));
void vga_putchar __P((void *, int, int, u_int, long));
int vga_alloc_attr __P((void *, int, int, int, long *));
void	vga_copyrows __P((void *, int, int, int));
d215 5
a219 5
int	vga_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
paddr_t	vga_mmap __P((void *, off_t, int));
int	vga_alloc_screen __P((void *, const struct wsscreen_descr *,
			      void **, int *, int *, long *));
void	vga_free_screen __P((void *, void *));
d222 4
a225 4
int	vga_load_font __P((void *, void *, struct wsdisplay_font *));
void	vga_scrollback __P((void *, void *, int));
void	vga_burner __P((void *v, u_int on, u_int flags));
u_int16_t vga_getchar __P((void *, int, int));
d227 1
a227 1
void vga_doswitch __P((struct vga_config *));
d509 1
a509 1
	int (*map) __P((void *, vaddr_t, int));
d724 1
a724 1
	void (*cb) __P((void *, int, int));
d1146 1
a1146 1
int vga_pcvt_mapchar __P((int, unsigned int *));
d1166 1
a1166 1
int _vga_mapchar __P((void *, struct vgafont *, int, unsigned int *));
@


1.27.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.27 2001/08/03 16:17:47 tholo Exp $ */
d94 11
a104 11
int	vga_selectfont(struct vga_config *, struct vgascreen *,
    const char *, const char *);
void	vga_init_screen(struct vga_config *, struct vgascreen *,
    const struct wsscreen_descr *, int, long *);
void	vga_init(struct vga_config *, bus_space_tag_t, bus_space_tag_t);
void	vga_setfont(struct vga_config *, struct vgascreen *);

int	vga_mapchar(void *, int, unsigned int *);
void	vga_putchar(void *, int, int, u_int, long);
int	vga_alloc_attr(void *, int, int, int, long *);
void	vga_copyrows(void *, int, int, int);
d215 11
a225 11
int	vga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	vga_mmap(void *, off_t, int);
int	vga_alloc_screen(void *, const struct wsscreen_descr *,
			 void **, int *, int *, long *);
void	vga_free_screen(void *, void *);
int	vga_show_screen(void *, void *, int,
			void (*) (void *, int, int), void *);
int	vga_load_font(void *, void *, struct wsdisplay_font *);
void	vga_scrollback(void *, void *, int);
void	vga_burner(void *v, u_int on, u_int flags);
u_int16_t vga_getchar(void *, int, int);
d227 1
a227 1
void vga_doswitch(struct vga_config *);
d509 1
a509 1
	int (*map)(void *, vaddr_t, int);
d724 1
a724 1
	void (*cb)(void *, int, int);
d1146 1
a1146 1
int vga_pcvt_mapchar(int, unsigned int *);
d1166 1
a1166 1
int _vga_mapchar(void *, struct vgafont *, int, unsigned int *);
@


1.27.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.27.4.1 2002/06/11 03:42:20 art Exp $ */
d500 1
d509 1
a509 1
	paddr_t (*map)(void *, off_t, int);
d511 1
d531 1
d533 1
d631 2
d637 3
a639 1

@


1.26
log
@allocate memory w/ NOWAIT during autoconf time and check for NULL return
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.25 2001/05/08 22:28:43 mickey Exp $ */
d594 1
a596 1
#if NVGA_PCI > 0
@


1.25
log
@inplement screen burner in screenblank(1) style (no program though).
disabled by default, also supports vsync blanking, disabled by default.
aaron@@ looked at it a while back and i fixed problems he had indicated.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.24 2001/05/08 16:16:10 mickey Exp $ */
d522 3
a524 1
		vc = malloc(sizeof(struct vga_config), M_DEVBUF, M_WAITOK);
@


1.24
log
@support a hook for vga_pci-based ioctls; aaron@@ ook
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.23 2001/04/14 04:44:01 aaron Exp $ */
d90 3
a92 3
static int vgaconsole, vga_console_type, vga_console_attached;
static struct vgascreen vga_console_screen;
static struct vga_config vga_console_vc;
d95 4
a98 6
			const char *, const char *));
void vga_init_screen __P((struct vga_config *, struct vgascreen *,
			  const struct wsscreen_descr *,
			  int, long *));
void vga_init __P((struct vga_config *, bus_space_tag_t,
		   bus_space_tag_t));
d106 1
a106 1
const struct wsdisplay_emulops vga_emulops = {
d224 1
d237 2
a238 1
	vga_getchar
d1240 29
@


1.23
log
@Kernel support for console mouse functionality which will be controlled by
the wsmoused daemon (replacement for moused which was used with PCVT). Adds
a "getchar" method to the display drivers which returns the value of the
character currently under the cursor (e.g., so it may be inversed). From jbm@@.

Still needs a bit of cleanup and improvement, especially X cohabitation
features. The pointer moves to fast as well. These sorts of issues will be
corrected in-tree.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.22 2001/04/01 20:30:02 mickey Exp $ */
d31 2
a34 1
#include <sys/timeout.h>
a89 23
struct vga_config {
	struct vga_handle hdl;

	int vc_type;
	int nscreens;
	LIST_HEAD(, vgascreen) screens;
	struct vgascreen *active; /* current display */
	const struct wsscreen_descr *currenttype;
	int currentfontset1, currentfontset2;

	struct vgafont *vc_fonts[8];

	struct vgascreen *wantedscreen;
	void (*switchcb) __P((void *, int, int));
	void *switchcbarg;

#ifdef arc
	paddr_t (*vc_mmap) __P((void *, off_t, int));
#endif

	struct timeout vc_switch_timeout;
};

d527 1
d592 7
@


1.22
log
@if we have a secondary fontset loaded and it
does mapchar for it w /the same success as primary,
prefer secondary mapping. this fixes non-lat char display.
from Igor Grabin <violent@@death.kiev.ua>
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.21 2001/03/22 12:43:47 mickey Exp $ */
d123 1
a123 1
static void vga_setfont __P((struct vga_config *, struct vgascreen *));
d125 3
a127 3
static int vga_mapchar __P((void *, int, unsigned int *));
static void vga_putchar __P((void *, int, int, u_int, long));
static int	vga_alloc_attr __P((void *, int, int, int, long *));
d248 1
d259 2
a260 1
	vga_scrollback
d1240 1
a1240 1
static void
d1255 10
@


1.21
log
@remember vga type as passed from lower level attach
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.20 2001/03/16 14:02:36 mickey Exp $ */
d1230 1
a1230 1
	if (res2 > res1) {
@


1.20
log
@zero vga_config after alloc
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.19 2001/03/14 02:49:22 mickey Exp $ */
d92 1
d547 1
a609 1
#if 0
a610 1
#endif
a612 1
#if 0
a616 5
#else
	case WSDISPLAYIO_GTYPE:
		*(int *)data = WSDISPLAY_TYPE_UNKNOWN;
		return 0;
#endif
@


1.19
log
@allow listing and soon deleting fonts; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.18 2001/02/28 16:48:28 mickey Exp $ */
d542 1
@


1.18
log
@do not blindely bus_space_ma the vga bios,
it could be of a different size than 0x8000,
and now bios(4) does it for us the right way.
besides, would the prom be at the same address on non-i386?
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.17 2001/02/08 02:47:10 aaron Exp $ */
d56 1
a56 1
	char name[16];
d116 1
a116 1
			char *, char *));
d344 1
a344 1
	char *name1, *name2; /* NULL: take first found */
d358 2
a359 1
		    (!name1 || !strcmp(name1, f->name))) {
d365 2
a366 1
		    (!name2 || !strcmp(name2, f->name))) {
d376 1
a376 1
	if (f1 && (!name2 || f2)) {
d871 8
a878 4
	for (slot = 0; slot < 8; slot++)
		if (!vc->vc_fonts[slot])
			break;
	if (slot == 8)
d881 4
a884 1
	f = malloc(sizeof(struct vgafont), M_DEVBUF, M_WAITOK);
d899 2
@


1.17
log
@Cause keypresses to reset the screen in case we are in scrollback (previously
the screen was only restored if a new character was actually displayed on the
screen); jcs@@rt.fm. This brings us closer to the behavior of PCVT. Also, while
I'm here, add some #ifdef so wskbd does not depend on wsdisplay (pointed out
to me by fgsch@@).
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.16 2001/01/31 16:38:00 aaron Exp $ */
a97 4
	int vc_biosmapped;
	bus_space_tag_t vc_biostag;
	bus_space_handle_t vc_bioshdl;

a494 8

	/* should only reserve the space (no need to map - save KVM) */
	vc->vc_biostag = memt;
	if (bus_space_map(vc->vc_biostag, 0xc0000, 0x8000, 0,
			  &vc->vc_bioshdl))
		vc->vc_biosmapped = 0;
	else
		vc->vc_biosmapped = 1;
@


1.16
log
@OpenBSD does have paddr_t, I can't explain why I thought it didn't; art@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.15 2001/01/31 02:12:28 aaron Exp $ */
d916 4
a919 1
	if (lines == 0)
d921 1
@


1.15
log
@Some int -> u_long (I incorrectly converted paddr_t to int when porting this).
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.14 2000/11/22 01:39:38 aaron Exp $ */
d243 1
a243 1
u_long	vga_mmap __P((void *, off_t, int));
d650 1
a650 1
u_long
@


1.14
log
@Set visible offset properly.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.13 2000/11/15 20:17:37 aaron Exp $ */
d243 1
a243 1
int	vga_mmap __P((void *, off_t, int));
d650 1
a650 1
int
@


1.13
log
@Updated VGA driver; from NetBSD. Needed for wscons on i386 and alpha. These
files could probably be updated even a bit further (they are from mid-summer).

In addition, I've added support for console scrollback, somewhat inspired by
Linux's vgacon driver. Basically, instead of allocating our own buffer and
doing lots of copies, we take advantage of Video RAM and just modify the VGA
display origin register as appropriate. This approach has a few advantages:
simple to implement, no wasted KVM, it's fast, and after a boot you can now
scroll back all the way to the BIOS messages (assuming your msgbuf is of a
typical length :). Disadvantages are that the VRAM buffer is relatively
small (only 32k) and we do not support raster devices through this method.
(thanks to mickey@@ for pointing this out).

The code for this is fairly unobtrusive, so should we come up with a better
approach to console scrollback at a later time (i.e., even more platform
independent) it should be easy to revert this.

We're one step further in porting nice features of PCVT over to wscons.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a1016 1
				scr->pcs.visibleoffset = scr->pcs.dispoffset;
d1020 1
@


1.12
log
@support powerpc port (needs ifdef to use powerpc_btop()), is there
a machine independant function that calls this md function??
@
text
@d1 2
a2 2
/*	$OpenBSD: vga.c,v 1.11 1997/11/06 12:26:54 niklas Exp $	*/
/*	$NetBSD: vga.c,v 1.3 1996/12/02 22:24:54 cgd Exp $	*/
d33 1
d36 2
d40 3
a42 1
#include <dev/wscons/wsconsvar.h>
d45 3
a47 2
#define	VGA_IO_D_6845_ADDR	0x4
#define	VGA_IO_D_6845_DATA	0x5
d49 64
a112 2
struct cfdriver vga_cd = {
	NULL, "vga", DV_DULL,
d115 16
a130 4
void	vga_cursor __P((void *, int, int, int));
void	vga_putstr __P((void *, int, int, char *, int));
void	vga_copycols __P((void *, int, int, int, int));
void	vga_erasecols __P((void *, int, int, int));
a131 2
void	vga_eraserows __P((void *, int, int));
void	vga_set_attr __P((void *, int));
d133 6
a138 5
struct wscons_emulfuncs vga_emulfuncs = {
	vga_cursor,
	vga_putstr,
	vga_copycols,
	vga_erasecols,
d140 100
a239 2
	vga_eraserows,
	vga_set_attr,
d242 21
a262 1
int	vgaprint __P((void *, const char *));
d272 2
a273 1
	bus_space_handle_t ioh_b, ioh_c, ioh_d, memh;
d275 2
a276 1
	int gotio_b, gotio_c, gotio_d, gotmem, rv;
d278 1
a278 1
	gotio_b = gotio_c = gotio_d = gotmem = rv = 0;
d280 1
a280 1
	if (bus_space_map(iot, 0x3b0, 0xc, 0, &ioh_b))
d282 7
a288 2
	gotio_b = 1;
	if (bus_space_map(iot, 0x3c0, 0x10, 0, &ioh_c))
d290 3
a292 2
	gotio_c = 1;
	if (bus_space_map(iot, 0x3d0, 0x10, 0, &ioh_d))
d294 7
a300 2
	gotio_d = 1;
	if (bus_space_map(memt, 0xb8000, 0x8000, 0, &memh))
d302 1
a302 1
	gotmem = 1;
d304 19
a322 4
	vgadata = bus_space_read_2(memt, memh, 0);
	bus_space_write_2(memt, memh, 0, 0xa55a);
	rv = (bus_space_read_2(memt, memh, 0) == 0xa55a);
	bus_space_write_2(memt, memh, 0, vgadata);
d324 1
d326 4
a329 6
	if (gotio_b)
		bus_space_unmap(iot, ioh_b, 0xc);
	if (gotio_c)
		bus_space_unmap(iot, ioh_c, 0x10);
	if (gotio_d)
		bus_space_unmap(iot, ioh_d, 0x10);
d331 1
a331 1
		bus_space_unmap(memt, memh, 0x8000);
d336 60
d397 1
a397 2
vga_common_setup(iot, memt, vc)
	bus_space_tag_t iot, memt;
d399 4
d405 1
d407 28
a434 2
        vc->vc_iot = iot;
        vc->vc_memt = memt;
d436 20
a455 18
        if (bus_space_map(vc->vc_iot, 0x3b0, 0xc, 0, &vc->vc_ioh_b))
                panic("vga_common_setup: couldn't map io b");
        if (bus_space_map(vc->vc_iot, 0x3c0, 0x10, 0, &vc->vc_ioh_c))
                panic("vga_common_setup: couldn't map io c");
        if (bus_space_map(vc->vc_iot, 0x3d0, 0x10, 0, &vc->vc_ioh_d))
                panic("vga_common_setup: couldn't map io d");
        if (bus_space_map(vc->vc_memt, 0xb8000, 0x8000, 0, &vc->vc_memh))
                panic("vga_common_setup: couldn't map memory"); 

	vc->vc_nrow = 25;
	vc->vc_ncol = 80;

	bus_space_write_1(iot, vc->vc_ioh_d, VGA_IO_D_6845_ADDR, 14); 
	cpos = bus_space_read_1(iot, vc->vc_ioh_d, VGA_IO_D_6845_DATA) << 8;
	bus_space_write_1(iot, vc->vc_ioh_d, VGA_IO_D_6845_ADDR, 15);
	cpos |= bus_space_read_1(iot, vc->vc_ioh_d, VGA_IO_D_6845_DATA);
	vc->vc_crow = cpos / vc->vc_ncol;
	vc->vc_ccol = cpos % vc->vc_ncol;
d457 7
a463 4
	vc->vc_so = 0;
#if 0
	vc->vc_at = 0x00 | 0xf;			/* black bg|white fg */
	vc->vc_so_at = 0x00 | 0xf | 0x80;	/* black bg|white fg|blink */
d465 2
a466 10
	/* clear screen, frob cursor, etc.? */
	pcivga_eraserows(vc, 0, vc->vc_nrow);
#endif
	/*
	 * XXX DEC HAS SWITCHED THE CODES FOR BLUE AND RED!!!
	 * XXX Therefore, though the comments say "blue bg", the code uses
	 * XXX the value for a red background!
	 */
	vc->vc_at = 0x40 | 0x0f;		/* blue bg|white fg */
	vc->vc_so_at = 0x40 | 0x0f | 0x80;	/* blue bg|white fg|blink */
d470 1
a470 2
vga_wscons_attach(parent, vc, console)
	struct device *parent;
d472 1
a472 1
	int console;
d474 41
a514 2
	struct wscons_attach_args waa;
	struct wscons_odev_spec *wo;
d516 3
a518 2
        waa.waa_isconsole = console;
        wo = &waa.waa_odev_spec;
d520 2
a521 2
        wo->wo_emulfuncs = &vga_emulfuncs;
	wo->wo_emulfuncs_cookie = vc;
d523 8
a530 10
        wo->wo_ioctl = vc->vc_ioctl;
        wo->wo_mmap = vc->vc_mmap;
        wo->wo_miscfuncs_cookie = vc;

        wo->wo_nrows = vc->vc_nrow;
        wo->wo_ncols = vc->vc_ncol;
        wo->wo_crow = vc->vc_crow;
        wo->wo_ccol = vc->vc_ccol;
 
        config_found(parent, &waa, vgaprint);
d534 8
a541 1
vga_wscons_console(vc)
d543 11
a553 2
{
	struct wscons_odev_spec wo;
d555 3
a557 2
        wo.wo_emulfuncs = &vga_emulfuncs;
	wo.wo_emulfuncs_cookie = vc;
d559 4
a562 1
	/* ioctl and mmap are unused until real attachment. */
d564 1
a564 6
        wo.wo_nrows = vc->vc_nrow;
        wo.wo_ncols = vc->vc_ncol;
        wo.wo_crow = vc->vc_crow;
        wo.wo_ccol = vc->vc_ccol;
 
        wscons_attach_console(&wo);
d568 3
a570 3
vgaprint(aux, pnp)
	void *aux;
	const char *pnp;
d572 5
d578 16
a593 3
	if (pnp)
		printf("wscons at %s", pnp);
	return (UNCONF);
d597 14
a610 1
vgaioctl(v, cmd, data, flag, p)
d617 29
a645 1
	/*struct vga_config *vc = v;*/
a646 1
	/* XXX */
d651 1
a651 1
vgammap(v, offset, prot)
d656 2
a658 2
	bus_space_handle_t h;
	u_int32_t *port;
d660 60
a719 8
	if (offset >= 0x00000 && offset < 0x100000)	/* 1MB of mem */
		h = vc->vc_memh + offset;
	else if (offset >= 0x10000 && offset < 0x140000) /* 256KB of iohb */
		h = vc->vc_ioh_b;
	else if (offset >= 0x140000 && offset < 0x180000) /* 256KB of iohc */
		h = vc->vc_ioh_c;
	else if (offset >= 0x180000 && offset < 0x1c0000) /* 256KB of iohd */
		h = vc->vc_ioh_d;
d721 1
a721 1
		return (-1);
d723 2
a724 8
	port = (u_int32_t *)(h << 5);
#ifdef alpha
	return alpha_btop(port);		/* XXX */
#elif defined(i386)
	return i386_btop(port);
#elif defined(powerpc)
	return powerpc_btop(port);
#endif
a726 4
/*
 * The following functions implement the MI ANSI terminal emulation on
 * a VGA display.
 */
d728 23
a750 3
vga_cursor(id, on, row, col)
	void *id;
	int on, row, col;
d752 2
a753 4
	struct vga_config *vc = id;
	bus_space_tag_t iot = vc->vc_iot;
	bus_space_handle_t ioh_d = vc->vc_ioh_d;
	int pos;
d755 3
a757 10
#if 0
	printf("vga_cursor: %d %d\n", row, col);
#endif
	/* turn the cursor off */
	if (!on) {
		/* XXX disable cursor how??? */
		vc->vc_crow = vc->vc_ccol = -1;
	} else {
		vc->vc_crow = row;
		vc->vc_ccol = col;
d760 9
a768 1
	pos = row * vc->vc_ncol + col;
d770 2
a771 4
	bus_space_write_1(iot, ioh_d, VGA_IO_D_6845_ADDR, 14);
	bus_space_write_1(iot, ioh_d, VGA_IO_D_6845_DATA, pos >> 8);
	bus_space_write_1(iot, ioh_d, VGA_IO_D_6845_ADDR, 15);
	bus_space_write_1(iot, ioh_d, VGA_IO_D_6845_DATA, pos);
d775 54
a828 16
vga_putstr(id, row, col, cp, len)
	void *id;
	int row, col;
	char *cp;
	int len;
{
	struct vga_config *vc = id;
	bus_space_tag_t memt = vc->vc_memt;
	bus_space_handle_t memh = vc->vc_memh;
	int i, off;

	off = (row * vc->vc_ncol + col) * 2;
	for (i = 0; i < len; i++, cp++, off += 2) {
		bus_space_write_1(memt, memh, off, *cp);
		bus_space_write_1(memt, memh, off + 1,
		    vc->vc_so ? vc->vc_so_at : vc->vc_at);
d830 14
d846 5
a850 4
void
vga_copycols(id, row, srccol, dstcol, ncols)
	void *id;
	int row, srccol, dstcol, ncols;
d852 28
a879 2
	struct vga_config *vc = id;
	bus_size_t srcoff, dstoff;
d881 21
a901 2
	srcoff = (row * vc->vc_ncol + srccol) * 2;
	dstoff = (row * vc->vc_ncol + dstcol) * 2;
d903 1
a903 2
	bus_space_copy_2(vc->vc_memt, vc->vc_memh, srcoff, vc->vc_memh, dstoff,
	    ncols);
d907 4
a910 3
vga_erasecols(id, row, startcol, ncols)
	void *id;
	int row, startcol, ncols;
d912 3
a914 3
	struct vga_config *vc = id;
	bus_size_t off;
	u_int16_t val;
d916 30
a945 1
	off = (row * vc->vc_ncol + startcol) * 2;
d947 9
a955 1
	val = (vc->vc_at << 8) | ' ';
d957 24
a980 1
	bus_space_set_region_2(vc->vc_memt, vc->vc_memh, off, val, ncols);
d988 4
a991 1
	struct vga_config *vc = id;
d994 2
a995 2
	srcoff = (srcrow * vc->vc_ncol + 0) * 2;
	dstoff = (dstrow * vc->vc_ncol + 0) * 2;
d997 42
a1038 2
	bus_space_copy_2(vc->vc_memt, vc->vc_memh, srcoff, vc->vc_memh, dstoff,
	    nrows * vc->vc_ncol);
d1041 123
a1163 4
void
vga_eraserows(id, startrow, nrows)
	void *id;
	int startrow, nrows;
d1165 1
a1165 3
	struct vga_config *vc = id;
	bus_size_t off, count;
	u_int16_t val;
d1167 8
a1174 2
	off = (startrow * vc->vc_ncol + 0) * 2;
	count = nrows * vc->vc_ncol;
d1176 1
a1176 1
	val = (vc->vc_at << 8) | ' ';
d1178 33
a1210 1
	bus_space_set_region_2(vc->vc_memt, vc->vc_memh, off, val, count);
d1213 2
a1214 2
void
vga_set_attr(id, val)
d1216 2
a1217 1
	int val;
d1219 20
a1238 1
	struct vga_config *vc = id;
d1240 14
a1253 1
	vc->vc_so = val;
d1255 4
@


1.12.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/* $OpenBSD: vga.c,v 1.23 2001/04/14 04:44:01 aaron Exp $ */
/* $NetBSD: vga.c,v 1.28.2.1 2000/06/30 16:27:47 simonb Exp $ */
a32 1
#include <sys/timeout.h>
a34 2
#include <sys/malloc.h>
#include <sys/queue.h>
d37 1
a37 3
#include <dev/ic/mc6845reg.h>
#include <dev/ic/pcdisplayvar.h>
#include <dev/ic/vgareg.h>
d40 2
a41 3
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/unicode.h>
d43 2
a44 22
#include <dev/ic/pcdisplay.h>

#if 0
#include "opt_wsdisplay_compat.h" /* for WSCONS_SUPPORT_PCVTFONTS */
#endif

static struct vgafont {
	char name[WSFONT_NAME_SIZE];
	int height;
	int encoding;
#ifdef notyet
	int firstchar, numchars;
#endif
	int slot;
} vga_builtinfont = {
	"builtin",
	16,
	WSDISPLAY_FONTENC_IBM,
#ifdef notyet
	0, 256,
#endif
	0
d47 4
a50 55
struct vgascreen {
	struct pcdisplayscreen pcs;

	LIST_ENTRY(vgascreen) next;

	struct vga_config *cfg;

	/* videostate */
	struct vgafont *fontset1, *fontset2;
	/* font data */
	/* palette */

	int mindispoffset, maxdispoffset;
	int vga_rollover;
};

struct vga_config {
	struct vga_handle hdl;

	int vc_type;
	int nscreens;
	LIST_HEAD(, vgascreen) screens;
	struct vgascreen *active; /* current display */
	const struct wsscreen_descr *currenttype;
	int currentfontset1, currentfontset2;

	struct vgafont *vc_fonts[8];

	struct vgascreen *wantedscreen;
	void (*switchcb) __P((void *, int, int));
	void *switchcbarg;

#ifdef arc
	paddr_t (*vc_mmap) __P((void *, off_t, int));
#endif

	struct timeout vc_switch_timeout;
};

static int vgaconsole, vga_console_type, vga_console_attached;
static struct vgascreen vga_console_screen;
static struct vga_config vga_console_vc;

int vga_selectfont __P((struct vga_config *, struct vgascreen *,
			const char *, const char *));
void vga_init_screen __P((struct vga_config *, struct vgascreen *,
			  const struct wsscreen_descr *,
			  int, long *));
void vga_init __P((struct vga_config *, bus_space_tag_t,
		   bus_space_tag_t));
void vga_setfont __P((struct vga_config *, struct vgascreen *));

int vga_mapchar __P((void *, int, unsigned int *));
void vga_putchar __P((void *, int, int, u_int, long));
int vga_alloc_attr __P((void *, int, int, int, long *));
d52 2
d55 5
a59 6
const struct wsdisplay_emulops vga_emulops = {
	pcdisplay_cursor,
	vga_mapchar,
	vga_putchar,
	pcdisplay_copycols,
	pcdisplay_erasecols,
d61 2
a62 100
	pcdisplay_eraserows,
	vga_alloc_attr
};

/*
 * translate WS(=ANSI) color codes to standard pc ones
 */
static unsigned char fgansitopc[] = {
#ifdef __alpha__
	/*
	 * XXX DEC HAS SWITCHED THE CODES FOR BLUE AND RED!!!
	 * XXX We should probably not bother with this
	 * XXX (reinitialize the palette registers).
	 */
	FG_BLACK, FG_BLUE, FG_GREEN, FG_CYAN, FG_RED,
	FG_MAGENTA, FG_BROWN, FG_LIGHTGREY
#else
	FG_BLACK, FG_RED, FG_GREEN, FG_BROWN, FG_BLUE,
	FG_MAGENTA, FG_CYAN, FG_LIGHTGREY
#endif
}, bgansitopc[] = {
#ifdef __alpha__
	BG_BLACK, BG_BLUE, BG_GREEN, BG_CYAN, BG_RED,
	BG_MAGENTA, BG_BROWN, BG_LIGHTGREY
#else
	BG_BLACK, BG_RED, BG_GREEN, BG_BROWN, BG_BLUE,
	BG_MAGENTA, BG_CYAN, BG_LIGHTGREY
#endif
};

const struct wsscreen_descr vga_stdscreen = {
	"80x25", 80, 25,
	&vga_emulops,
	8, 16,
	WSSCREEN_WSCOLORS | WSSCREEN_HILIT | WSSCREEN_BLINK
}, vga_stdscreen_mono = {
	"80x25", 80, 25,
	&vga_emulops,
	8, 16,
	WSSCREEN_HILIT | WSSCREEN_UNDERLINE | WSSCREEN_BLINK | WSSCREEN_REVERSE
}, vga_stdscreen_bf = {
	"80x25bf", 80, 25,
	&vga_emulops,
	8, 16,
	WSSCREEN_WSCOLORS | WSSCREEN_BLINK
}, vga_40lscreen = {
	"80x40", 80, 40,
	&vga_emulops,
	8, 10,
	WSSCREEN_WSCOLORS | WSSCREEN_HILIT | WSSCREEN_BLINK
}, vga_40lscreen_mono = {
	"80x40", 80, 40,
	&vga_emulops,
	8, 10,
	WSSCREEN_HILIT | WSSCREEN_UNDERLINE | WSSCREEN_BLINK | WSSCREEN_REVERSE
}, vga_40lscreen_bf = {
	"80x40bf", 80, 40,
	&vga_emulops,
	8, 10,
	WSSCREEN_WSCOLORS | WSSCREEN_BLINK
}, vga_50lscreen = {
	"80x50", 80, 50,
	&vga_emulops,
	8, 8,
	WSSCREEN_WSCOLORS | WSSCREEN_HILIT | WSSCREEN_BLINK
}, vga_50lscreen_mono = {
	"80x50", 80, 50,
	&vga_emulops,
	8, 8,
	WSSCREEN_HILIT | WSSCREEN_UNDERLINE | WSSCREEN_BLINK | WSSCREEN_REVERSE
}, vga_50lscreen_bf = {
	"80x50bf", 80, 50,
	&vga_emulops,
	8, 8,
	WSSCREEN_WSCOLORS | WSSCREEN_BLINK
};

#define VGA_SCREEN_CANTWOFONTS(type) (!((type)->capabilities & WSSCREEN_HILIT))

const struct wsscreen_descr *_vga_scrlist[] = {
	&vga_stdscreen,
	&vga_stdscreen_bf,
	&vga_40lscreen,
	&vga_40lscreen_bf,
	&vga_50lscreen,
	&vga_50lscreen_bf,
	/* XXX other formats, graphics screen? */
}, *_vga_scrlist_mono[] = {
	&vga_stdscreen_mono,
	&vga_40lscreen_mono,
	&vga_50lscreen_mono,
	/* XXX other formats, graphics screen? */
};

const struct wsscreen_list vga_screenlist = {
	sizeof(_vga_scrlist) / sizeof(struct wsscreen_descr *),
	_vga_scrlist
}, vga_screenlist_mono = {
	sizeof(_vga_scrlist_mono) / sizeof(struct wsscreen_descr *),
	_vga_scrlist_mono
d65 1
a65 23
int	vga_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
paddr_t	vga_mmap __P((void *, off_t, int));
int	vga_alloc_screen __P((void *, const struct wsscreen_descr *,
			      void **, int *, int *, long *));
void	vga_free_screen __P((void *, void *));
int	vga_show_screen __P((void *, void *, int,
			     void (*) (void *, int, int), void *));
int	vga_load_font __P((void *, void *, struct wsdisplay_font *));
void	vga_scrollback __P((void *, void *, int));
u_int16_t vga_getchar __P((void *, int, int));

void vga_doswitch __P((struct vga_config *));

const struct wsdisplay_accessops vga_accessops = {
	vga_ioctl,
	vga_mmap,
	vga_alloc_screen,
	vga_free_screen,
	vga_show_screen,
	vga_load_font,
	vga_scrollback,
	vga_getchar
};
d75 1
a75 2
	bus_space_handle_t ioh_vga, ioh_6845, memh;
	u_int8_t regval;
d77 1
a77 2
	int gotio_vga, gotio_6845, gotmem, mono, rv;
	int dispoffset;
d79 1
a79 1
	gotio_vga = gotio_6845 = gotmem = rv = 0;
d81 1
a81 1
	if (bus_space_map(iot, 0x3c0, 0x10, 0, &ioh_vga))
d83 5
a87 7
	gotio_vga = 1;

	/* read "misc output register" */
	regval = bus_space_read_1(iot, ioh_vga, 0xc);
	mono = !(regval & 1);

	if (bus_space_map(iot, (mono ? 0x3b0 : 0x3d0), 0x10, 0, &ioh_6845))
d89 2
a90 3
	gotio_6845 = 1;

	if (bus_space_map(memt, 0xa0000, 0x20000, 0, &memh))
d94 4
a97 1
	dispoffset = (mono ? 0x10000 : 0x18000);
a98 27
	vgadata = bus_space_read_2(memt, memh, dispoffset);
	bus_space_write_2(memt, memh, dispoffset, 0xa55a);
	if (bus_space_read_2(memt, memh, dispoffset) != 0xa55a)
		goto bad;
	bus_space_write_2(memt, memh, dispoffset, vgadata);

	/*
	 * check if this is really a VGA
	 * (try to write "Color Select" register as XFree86 does)
	 * XXX check before if at least EGA?
	 */
	/* reset state */
	(void) bus_space_read_1(iot, ioh_6845, 10);
	bus_space_write_1(iot, ioh_vga, VGA_ATC_INDEX,
			  20 | 0x20); /* colselect | enable */
	regval = bus_space_read_1(iot, ioh_vga, VGA_ATC_DATAR);
	/* toggle the implemented bits */
	bus_space_write_1(iot, ioh_vga, VGA_ATC_DATAW, regval ^ 0x0f);
	bus_space_write_1(iot, ioh_vga, VGA_ATC_INDEX,
			  20 | 0x20);
	/* read back */
	if (bus_space_read_1(iot, ioh_vga, VGA_ATC_DATAR) != (regval ^ 0x0f))
		goto bad;
	/* restore contents */
	bus_space_write_1(iot, ioh_vga, VGA_ATC_DATAW, regval);

	rv = 1;
d100 6
a105 4
	if (gotio_vga)
		bus_space_unmap(iot, ioh_vga, 0x10);
	if (gotio_6845)
		bus_space_unmap(iot, ioh_6845, 0x10);
d107 1
a107 1
		bus_space_unmap(memt, memh, 0x20000);
a111 62
/*
 * We want at least ASCII 32..127 be present in the
 * first font slot.
 */
#define vga_valid_primary_font(f) \
	(f->encoding == WSDISPLAY_FONTENC_IBM || \
	f->encoding == WSDISPLAY_FONTENC_ISO)

int
vga_selectfont(vc, scr, name1, name2)
	struct vga_config *vc;
	struct vgascreen *scr;
	const char *name1, *name2; /* NULL: take first found */
{
	const struct wsscreen_descr *type = scr->pcs.type;
	struct vgafont *f1, *f2;
	int i;

	f1 = f2 = 0;

	for (i = 0; i < 8; i++) {
		struct vgafont *f = vc->vc_fonts[i];
		if (!f || f->height != type->fontheight)
			continue;
		if (!f1 &&
		    vga_valid_primary_font(f) &&
		    (!name1 || !*name1 ||
		     !strncmp(name1, f->name, WSFONT_NAME_SIZE))) {
			f1 = f;
			continue;
		}
		if (!f2 &&
		    VGA_SCREEN_CANTWOFONTS(type) &&
		    (!name2 || !*name2 ||
		     !strncmp(name2, f->name, WSFONT_NAME_SIZE))) {
			f2 = f;
			continue;
		}
	}

	/*
	 * The request fails if no primary font was found,
	 * or if a second font was requested but not found.
	 */
	if (f1 && (!name2 || !*name2 || f2)) {
#ifdef VGAFONTDEBUG
		if (scr != &vga_console_screen || vga_console_attached) {
			printf("vga (%s): font1=%s (slot %d)", type->name,
			       f1->name, f1->slot);
			if (f2)
				printf(", font2=%s (slot %d)",
				       f2->name, f2->slot);
			printf("\n");
		}
#endif
		scr->fontset1 = f1;
		scr->fontset2 = f2;
		return (0);
	}
	return (ENXIO);
}

d113 2
a114 1
vga_init_screen(vc, scr, type, existing, attrp)
a115 4
	struct vgascreen *scr;
	const struct wsscreen_descr *type;
	int existing;
	long *attrp;
a117 1
	int res;
d119 2
a120 28
	scr->cfg = vc;
	scr->pcs.hdl = (struct pcdisplay_handle *)&vc->hdl;
	scr->pcs.type = type;
	scr->pcs.active = 0;
	scr->mindispoffset = 0;
	scr->maxdispoffset = 0x8000 - type->nrows * type->ncols * 2;

	if (existing) {
		cpos = vga_6845_read(&vc->hdl, cursorh) << 8;
		cpos |= vga_6845_read(&vc->hdl, cursorl);

		/* make sure we have a valid cursor position */
		if (cpos < 0 || cpos >= type->nrows * type->ncols)
			cpos = 0;

		scr->pcs.dispoffset = vga_6845_read(&vc->hdl, startadrh) << 9;
		scr->pcs.dispoffset |= vga_6845_read(&vc->hdl, startadrl) << 1;

		/* make sure we have a valid memory offset */
		if (scr->pcs.dispoffset < scr->mindispoffset ||
		    scr->pcs.dispoffset > scr->maxdispoffset)
			scr->pcs.dispoffset = scr->mindispoffset;
	} else {
		cpos = 0;
		scr->pcs.dispoffset = scr->mindispoffset;
	}
	scr->pcs.visibleoffset = scr->pcs.dispoffset;
	scr->vga_rollover = 0;
d122 18
a139 18
	scr->pcs.vc_crow = cpos / type->ncols;
	scr->pcs.vc_ccol = cpos % type->ncols;
	pcdisplay_cursor_init(&scr->pcs, existing);

#ifdef __alpha__
	if (!vc->hdl.vh_mono)
		/*
		 * DEC firmware uses a blue background.
		 */
		res = vga_alloc_attr(scr, WSCOL_WHITE, WSCOL_BLUE,
				     WSATTR_WSCOLORS, attrp);
	else
#endif
	res = vga_alloc_attr(scr, 0, 0, 0, attrp);
#ifdef DIAGNOSTIC
	if (res)
		panic("vga_init_screen: attribute botch");
#endif
d141 4
a144 1
	scr->pcs.mem = NULL;
d146 10
a155 10
	scr->fontset1 = scr->fontset2 = 0;
	if (vga_selectfont(vc, scr, 0, 0)) {
		if (scr == &vga_console_screen)
			panic("vga_init_screen: no font");
		else
			printf("vga_init_screen: no font\n");
	}

	vc->nscreens++;
	LIST_INSERT_HEAD(&vc->screens, scr, next);
d159 2
a160 1
vga_init(vc, iot, memt)
d162 1
a162 1
	bus_space_tag_t iot, memt;
d164 2
a165 33
	struct vga_handle *vh = &vc->hdl;
	u_int8_t mor;
	int i;

        vh->vh_iot = iot;
        vh->vh_memt = memt;

        if (bus_space_map(vh->vh_iot, 0x3c0, 0x10, 0, &vh->vh_ioh_vga))
                panic("vga_common_setup: couldn't map vga io");

	/* read "misc output register" */
	mor = bus_space_read_1(vh->vh_iot, vh->vh_ioh_vga, 0xc);
	vh->vh_mono = !(mor & 1);

	if (bus_space_map(vh->vh_iot, (vh->vh_mono ? 0x3b0 : 0x3d0), 0x10, 0,
			  &vh->vh_ioh_6845))
                panic("vga_common_setup: couldn't map 6845 io");

        if (bus_space_map(vh->vh_memt, 0xa0000, 0x20000, 0, &vh->vh_allmemh))
                panic("vga_common_setup: couldn't map memory");

        if (bus_space_subregion(vh->vh_memt, vh->vh_allmemh,
				(vh->vh_mono ? 0x10000 : 0x18000), 0x8000,
				&vh->vh_memh))
                panic("vga_common_setup: mem subrange failed");

	vc->nscreens = 0;
	LIST_INIT(&vc->screens);
	vc->active = NULL;
	vc->currenttype = vh->vh_mono ? &vga_stdscreen_mono : &vga_stdscreen;
#if 0
	callout_init(&vc->vc_switch_callout);
#endif
d167 2
a168 3
	vc->vc_fonts[0] = &vga_builtinfont;
	for (i = 1; i < 8; i++)
		vc->vc_fonts[i] = 0;
d170 2
a171 2
	vc->currentfontset1 = vc->currentfontset2 = 0;
}
d173 10
a182 8
void
vga_common_attach(self, iot, memt, type)
	struct device *self;
	bus_space_tag_t iot, memt;
	int type;
{
#ifdef arc
	vga_extended_attach(self, iot, memt, type, NULL);
d186 2
a187 5
vga_extended_attach(self, iot, memt, type, map)
	struct device *self;
	bus_space_tag_t iot, memt;
	int type;
	int (*map) __P((void *, vaddr_t, int));
d189 1
a189 15
#endif /* arc */
	int console;
	struct vga_config *vc;
	struct wsemuldisplaydev_attach_args aa;

	console = vga_is_console(iot, type);

	if (console) {
		vc = &vga_console_vc;
		vga_console_attached = 1;
	} else {
		vc = malloc(sizeof(struct vga_config), M_DEVBUF, M_WAITOK);
		bzero(vc, sizeof(struct vga_config));
		vga_init(vc, iot, memt);
	}
d191 2
a192 4
	vc->vc_type = type;
#ifdef arc
	vc->vc_mmap = map;
#endif
d194 1
a194 4
	aa.console = console;
	aa.scrdata = (vc->hdl.vh_mono ? &vga_screenlist_mono : &vga_screenlist);
	aa.accessops = &vga_accessops;
	aa.accesscookie = vc;
d196 6
a201 1
        config_found(self, &aa, wsemuldisplaydevprint);
d205 3
a207 3
vga_cnattach(iot, memt, type, check)
	bus_space_tag_t iot, memt;
	int type, check;
a208 5
	long defattr;
	const struct wsscreen_descr *scr;

	if (check && !vga_common_probe(iot, memt))
		return (ENXIO);
d210 3
a212 16
	/* set up bus-independent VGA configuration */
	vga_init(&vga_console_vc, iot, memt);
	scr = vga_console_vc.currenttype;
	vga_init_screen(&vga_console_vc, &vga_console_screen, scr, 1, &defattr);

	vga_console_screen.pcs.active = 1;
	vga_console_vc.active = &vga_console_screen;

	wsdisplay_cnattach(scr, &vga_console_screen,
			   vga_console_screen.pcs.vc_ccol,
			   vga_console_screen.pcs.vc_crow,
			   defattr);

	vgaconsole = 1;
	vga_console_type = type;
	return (0);
d216 1
a216 14
vga_is_console(iot, type)
	bus_space_tag_t iot;
	int type;
{
	if (vgaconsole &&
	    !vga_console_attached &&
	    iot == vga_console_vc.hdl.vh_iot &&
	    (vga_console_type == -1 || (type == vga_console_type)))
		return (1);
	return (0);
}

int
vga_ioctl(v, cmd, data, flag, p)
d223 1
a223 21
	struct vga_config *vc = v;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(int *)data = vc->vc_type;
		/* XXX should get detailed hardware information here */
		return 0;

	case WSDISPLAYIO_GINFO:
	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
		/* NONE of these operations are by the generic VGA driver. */
		return ENOTTY;
	}
d225 1
d229 2
a230 2
paddr_t
vga_mmap(v, offset, prot)
d235 3
d239 10
a248 2
#ifdef arc
	struct vga_config *vc = v;
d250 7
a256 4
	if (vc->vc_mmap != NULL)
		return (*vc->vc_mmap)(v, offset, prot);
#else
	/* XXX */
a257 1
	return -1;
d260 8
a267 7
int
vga_alloc_screen(v, type, cookiep, curxp, curyp, defattrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *defattrp;
d269 4
a272 2
	struct vga_config *vc = v;
	struct vgascreen *scr;
d274 7
a280 17
	if (vc->nscreens == 1) {
		/*
		 * When allocating the second screen, get backing store
		 * for the first one too.
		 * XXX We could be more clever and use video RAM.
		 */
		vc->screens.lh_first->pcs.mem =
		  malloc(type->ncols * type->nrows * 2, M_DEVBUF, M_WAITOK);
	}

	scr = malloc(sizeof(struct vgascreen), M_DEVBUF, M_WAITOK);
	vga_init_screen(vc, scr, type, vc->nscreens == 0, defattrp);

	if (vc->nscreens == 1) {
		scr->pcs.active = 1;
		vc->active = scr;
		vc->currenttype = type;
d282 2
a283 3
		scr->pcs.mem = malloc(type->ncols * type->nrows * 2,
				      M_DEVBUF, M_WAITOK);
		pcdisplay_eraserows(&scr->pcs, 0, type->nrows, *defattrp);
d286 1
a286 3
	*cookiep = scr;
	*curxp = scr->pcs.vc_ccol;
	*curyp = scr->pcs.vc_crow;
d288 4
a291 1
	return (0);
d295 5
a299 41
vga_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct vgascreen *vs = cookie;
	struct vga_config *vc = vs->cfg;

	LIST_REMOVE(vs, next);
	if (vs != &vga_console_screen)
		free(vs, M_DEVBUF);
	else
		panic("vga_free_screen: console");

	if (vc->active == vs)
		vc->active = 0;
}

void
vga_setfont(vc, scr)
	struct vga_config *vc;
	struct vgascreen *scr;
{
	int fontslot1, fontslot2;

	fontslot1 = (scr->fontset1 ? scr->fontset1->slot : 0);
	fontslot2 = (scr->fontset2 ? scr->fontset2->slot : fontslot1);
	if (vc->currentfontset1 != fontslot1 ||
	    vc->currentfontset2 != fontslot2) {
		vga_setfontset(&vc->hdl, fontslot1, fontslot2);
		vc->currentfontset1 = fontslot1;
		vc->currentfontset2 = fontslot2;
	}
}

int
vga_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb) __P((void *, int, int));
	void *cbarg;
d301 10
a310 16
	struct vgascreen *scr = cookie, *oldscr;
	struct vga_config *vc = scr->cfg;

	oldscr = vc->active; /* can be NULL! */
	if (scr == oldscr) {
		return (0);
	}

	vc->wantedscreen = cookie;
	vc->switchcb = cb;
	vc->switchcbarg = cbarg;
	if (cb) {
		timeout_set(&vc->vc_switch_timeout,
		    (void(*)(void *))vga_doswitch, vc);
		timeout_add(&vc->vc_switch_timeout, 0);
		return (EAGAIN);
a311 3

	vga_doswitch(vc);
	return (0);
d315 3
a317 2
vga_doswitch(vc)
	struct vga_config *vc;
d319 2
a320 29
	struct vgascreen *scr, *oldscr;
	struct vga_handle *vh = &vc->hdl;
	const struct wsscreen_descr *type;

	scr = vc->wantedscreen;
	if (!scr) {
		printf("vga_doswitch: disappeared\n");
		(*vc->switchcb)(vc->switchcbarg, EIO, 0);
		return;
	}
	type = scr->pcs.type;
	oldscr = vc->active; /* can be NULL! */
#ifdef DIAGNOSTIC
	if (oldscr) {
		if (!oldscr->pcs.active)
			panic("vga_show_screen: not active");
		if (oldscr->pcs.type != vc->currenttype)
			panic("vga_show_screen: bad type");
	}
#endif
	if (scr == oldscr) {
		return;
	}
#ifdef DIAGNOSTIC
	if (scr->pcs.active)
		panic("vga_show_screen: active");
#endif

	scr->vga_rollover = 0;
d322 2
a323 2
	if (oldscr) {
		const struct wsscreen_descr *oldtype = oldscr->pcs.type;
d325 2
a326 102
		oldscr->pcs.active = 0;
		bus_space_read_region_2(vh->vh_memt, vh->vh_memh,
					oldscr->pcs.dispoffset, oldscr->pcs.mem,
					oldtype->ncols * oldtype->nrows);
	}

	if (vc->currenttype != type) {
		vga_setscreentype(vh, type);
		vc->currenttype = type;
	}

	vga_setfont(vc, scr);
	/* XXX switch colours! */

	scr->pcs.visibleoffset = scr->pcs.dispoffset = scr->mindispoffset;
	if (!oldscr || (scr->pcs.dispoffset != oldscr->pcs.dispoffset)) {
		vga_6845_write(vh, startadrh, scr->pcs.dispoffset >> 9);
		vga_6845_write(vh, startadrl, scr->pcs.dispoffset >> 1);
	}

	bus_space_write_region_2(vh->vh_memt, vh->vh_memh,
				scr->pcs.dispoffset, scr->pcs.mem,
				type->ncols * type->nrows);
	scr->pcs.active = 1;

	vc->active = scr;

	pcdisplay_cursor(&scr->pcs, scr->pcs.cursoron,
			 scr->pcs.vc_crow, scr->pcs.vc_ccol);

	vc->wantedscreen = 0;
	if (vc->switchcb)
		(*vc->switchcb)(vc->switchcbarg, 0, 0);
}

int
vga_load_font(v, cookie, data)
	void *v;
	void *cookie;
	struct wsdisplay_font *data;
{
	struct vga_config *vc = v;
	struct vgascreen *scr = cookie;
	char *name2;
	int res, slot;
	struct vgafont *f;

	if (scr) {
		name2 = data->name;
		while (*name2 && *name2 != ',')
			name2++;
		if (name2)
			*name2++ = '\0';
		res = vga_selectfont(vc, scr, data->name, name2);
		if (!res)
			vga_setfont(vc, scr);
		return (res);
	}

	if (data->fontwidth != 8 || data->stride != 1)
		return (EINVAL); /* XXX 1 byte per line */
	if (data->firstchar != 0 || data->numchars != 256)
		return (EINVAL);
#ifndef WSCONS_SUPPORT_PCVTFONTS
	if (data->encoding == WSDISPLAY_FONTENC_PCVT) {
		printf("vga: pcvt font support not built in, see vga(4)\n");
		return (EINVAL);
	}
#endif

	if (data->index < 0) {
		for (slot = 0; slot < 8; slot++)
			if (!vc->vc_fonts[slot])
				break;
	} else
		slot = data->index;

	if (slot >= 8)
		return (ENOSPC);

	if (!vc->vc_fonts[slot])
		f = malloc(sizeof(struct vgafont), M_DEVBUF, M_WAITOK);
	if (!f)
		return (ENOMEM);
	strncpy(f->name, data->name, sizeof(f->name));
	f->height = data->fontheight;
	f->encoding = data->encoding;
#ifdef notyet
	f->firstchar = data->firstchar;
	f->numchars = data->numchars;
#endif
#ifdef VGAFONTDEBUG
	printf("vga: load %s (8x%d, enc %d) font to slot %d\n", f->name,
	       f->height, f->encoding, slot);
#endif
	vga_loadchars(&vc->hdl, slot, 0, 256, f->height, data->data);
	f->slot = slot;
	vc->vc_fonts[slot] = f;
	data->cookie = f;
	data->index = slot;

	return (0);
d330 3
a332 4
vga_scrollback(v, cookie, lines)
	void *v;
	void *cookie;
	int lines;
d334 3
a336 3
	struct vga_config *vc = v;
	struct vgascreen *scr = cookie;
	struct vga_handle *vh = &vc->hdl;
d338 1
a338 3
	if (lines == 0) {
		if (scr->pcs.visibleoffset == scr->pcs.dispoffset)
			return;
d340 1
a340 30
		scr->pcs.visibleoffset = scr->pcs.dispoffset;	/* reset */
	}
	else {
		int vga_scr_end;
		int margin = scr->pcs.type->ncols * 2;
		int ul, we, p, st;

		vga_scr_end = (scr->pcs.dispoffset + scr->pcs.type->ncols *
		    scr->pcs.type->nrows * 2);
		if (scr->vga_rollover > vga_scr_end + margin) {
			ul = vga_scr_end;
			we = scr->vga_rollover + scr->pcs.type->ncols * 2;
		} else {
			ul = 0;
			we = 0x8000;
		}
		p = (scr->pcs.visibleoffset - ul + we) % we + lines *
		    (scr->pcs.type->ncols * 2);
		st = (scr->pcs.dispoffset - ul + we) % we;
		if (p < margin)
			p = 0;
		if (p > st - margin)
			p = st;
		scr->pcs.visibleoffset = (p + ul) % we;
	}
	
	/* update visible position */
	vga_6845_write(vh, startadrh, scr->pcs.visibleoffset >> 9);
	vga_6845_write(vh, startadrl, scr->pcs.visibleoffset >> 1);
}
d342 1
a342 34
int
vga_alloc_attr(id, fg, bg, flags, attrp)
	void *id;
	int fg, bg;
	int flags;
	long *attrp;
{
	struct vgascreen *scr = id;
	struct vga_config *vc = scr->cfg;

	if (vc->hdl.vh_mono) {
		if (flags & WSATTR_WSCOLORS)
			return (EINVAL);
		if (flags & WSATTR_REVERSE)
			*attrp = 0x70;
		else
			*attrp = 0x07;
		if (flags & WSATTR_UNDERLINE)
			*attrp |= FG_UNDERLINE;
		if (flags & WSATTR_HILIT)
			*attrp |= FG_INTENSE;
	} else {
		if (flags & (WSATTR_UNDERLINE | WSATTR_REVERSE))
			return (EINVAL);
		if (flags & WSATTR_WSCOLORS)
			*attrp = fgansitopc[fg] | bgansitopc[bg];
		else
			*attrp = 7;
		if (flags & WSATTR_HILIT)
			*attrp += 8;
	}
	if (flags & WSATTR_BLINK)
		*attrp |= FG_BLINK;
	return (0);
d350 1
a350 4
	struct vgascreen *scr = id;
	bus_space_tag_t memt = scr->pcs.hdl->ph_memt;
	bus_space_handle_t memh = scr->pcs.hdl->ph_memh;
	int ncols = scr->pcs.type->ncols;
d353 2
a354 2
	srcoff = srcrow * ncols + 0;
	dstoff = dstrow * ncols + 0;
d356 2
a357 42
	if (scr->pcs.active) {
		if (dstrow == 0 && (srcrow + nrows == scr->pcs.type->nrows)) {
#ifdef PCDISPLAY_SOFTCURSOR
			int cursoron = scr->pcs.cursoron;

			if (cursoron)
				pcdisplay_cursor(&scr->pcs, 0,
				    scr->pcs.vc_crow, scr->pcs.vc_ccol);
#endif
			/* scroll up whole screen */
			if ((scr->pcs.dispoffset + srcrow * ncols * 2)
			    <= scr->maxdispoffset) {
				scr->pcs.dispoffset += srcrow * ncols * 2;
			} else {
				bus_space_copy_2(memt, memh,
					scr->pcs.dispoffset + srcoff * 2,
					memh, scr->mindispoffset,
					nrows * ncols);
				scr->vga_rollover = scr->pcs.dispoffset;
				scr->pcs.dispoffset = scr->mindispoffset;
				memt = memt;
				memh = memh;
			}
			scr->pcs.visibleoffset = scr->pcs.dispoffset;
			vga_6845_write(&scr->cfg->hdl, startadrh,
				       scr->pcs.dispoffset >> 9);
			vga_6845_write(&scr->cfg->hdl, startadrl,
				       scr->pcs.dispoffset >> 1);
#ifdef PCDISPLAY_SOFTCURSOR
			if (cursoron)
				pcdisplay_cursor(&scr->pcs, 1,
				    scr->pcs.vc_crow, scr->pcs.vc_ccol);
#endif
		} else {
			bus_space_copy_2(memt, memh,
					scr->pcs.dispoffset + srcoff * 2,
					memh, scr->pcs.dispoffset + dstoff * 2,
					nrows * ncols);
		}
	} else
		bcopy(&scr->pcs.mem[srcoff], &scr->pcs.mem[dstoff],
		      nrows * ncols * 2);
d360 4
a363 123
#ifdef WSCONS_SUPPORT_PCVTFONTS

#define NOTYET 0xffff
static u_int16_t pcvt_unichars[0xa0] = {
/* 0 */	_e006U,
	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
	NOTYET,
	0x2409, /* SYMBOL FOR HORIZONTAL TABULATION */
	0x240a, /* SYMBOL FOR LINE FEED */
	0x240b, /* SYMBOL FOR VERTICAL TABULATION */
	0x240c, /* SYMBOL FOR FORM FEED */
	0x240d, /* SYMBOL FOR CARRIAGE RETURN */
	NOTYET, NOTYET,
/* 1 */	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
/* 2 */	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
/* 3 */	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
	NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET, NOTYET,
/* 4 */	0x03c1, /* GREEK SMALL LETTER RHO */
	0x03c8, /* GREEK SMALL LETTER PSI */
	0x2202, /* PARTIAL DIFFERENTIAL */
	0x03bb, /* GREEK SMALL LETTER LAMDA */
	0x03b9, /* GREEK SMALL LETTER IOTA */
	0x03b7, /* GREEK SMALL LETTER ETA */
	0x03b5, /* GREEK SMALL LETTER EPSILON */
	0x03c7, /* GREEK SMALL LETTER CHI */
	0x2228, /* LOGICAL OR */
	0x2227, /* LOGICAL AND */
	0x222a, /* UNION */
	0x2283, /* SUPERSET OF */
	0x2282, /* SUBSET OF */
	0x03a5, /* GREEK CAPITAL LETTER UPSILON */
	0x039e, /* GREEK CAPITAL LETTER XI */
	0x03a8, /* GREEK CAPITAL LETTER PSI */
/* 5 */	0x03a0, /* GREEK CAPITAL LETTER PI */
	0x21d2, /* RIGHTWARDS DOUBLE ARROW */
	0x21d4, /* LEFT RIGHT DOUBLE ARROW */
	0x039b, /* GREEK CAPITAL LETTER LAMDA */
	0x0398, /* GREEK CAPITAL LETTER THETA */
	0x2243, /* ASYMPTOTICALLY EQUAL TO */
	0x2207, /* NABLA */
	0x2206, /* INCREMENT */
	0x221d, /* PROPORTIONAL TO */
	0x2234, /* THEREFORE */
	0x222b, /* INTEGRAL */
	0x2215, /* DIVISION SLASH */
	0x2216, /* SET MINUS */
	_e00eU,
	_e00dU,
	_e00bU,
/* 6 */	_e00cU,
	_e007U,
	_e008U,
	_e009U,
	_e00aU,
	0x221a, /* SQUARE ROOT */
	0x03c9, /* GREEK SMALL LETTER OMEGA */
	0x00a5, /* YEN SIGN */
	0x03be, /* GREEK SMALL LETTER XI */
	0x00fd, /* LATIN SMALL LETTER Y WITH ACUTE */
	0x00fe, /* LATIN SMALL LETTER THORN */
	0x00f0, /* LATIN SMALL LETTER ETH */
	0x00de, /* LATIN CAPITAL LETTER THORN */
	0x00dd, /* LATIN CAPITAL LETTER Y WITH ACUTE */
	0x00d7, /* MULTIPLICATION SIGN */
	0x00d0, /* LATIN CAPITAL LETTER ETH */
/* 7 */	0x00be, /* VULGAR FRACTION THREE QUARTERS */
	0x00b8, /* CEDILLA */
	0x00b4, /* ACUTE ACCENT */
	0x00af, /* MACRON */
	0x00ae, /* REGISTERED SIGN */
	0x00ad, /* SOFT HYPHEN */
	0x00ac, /* NOT SIGN */
	0x00a8, /* DIAERESIS */
	0x2260, /* NOT EQUAL TO */
	_e005U,
	_e004U,
	_e003U,
	_e002U,
	_e001U,
	0x03c5, /* GREEK SMALL LETTER UPSILON */
	0x00f8, /* LATIN SMALL LETTER O WITH STROKE */
/* 8 */	0x0153, /* LATIN SMALL LIGATURE OE */
	0x00f5, /* LATIN SMALL LETTER O WITH TILDE !!!doc bug */
	0x00e3, /* LATIN SMALL LETTER A WITH TILDE */
	0x0178, /* LATIN CAPITAL LETTER Y WITH DIAERESIS */
	0x00db, /* LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
	0x00da, /* LATIN CAPITAL LETTER U WITH ACUTE */
	0x00d9, /* LATIN CAPITAL LETTER U WITH GRAVE */
	0x00d8, /* LATIN CAPITAL LETTER O WITH STROKE */
	0x0152, /* LATIN CAPITAL LIGATURE OE */
	0x00d5, /* LATIN CAPITAL LETTER O WITH TILDE */
	0x00d4, /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
	0x00d3, /* LATIN CAPITAL LETTER O WITH ACUTE */
	0x00d2, /* LATIN CAPITAL LETTER O WITH GRAVE */
	0x00cf, /* LATIN CAPITAL LETTER I WITH DIAERESIS */
	0x00ce, /* LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
	0x00cd, /* LATIN CAPITAL LETTER I WITH ACUTE */
/* 9 */	0x00cc, /* LATIN CAPITAL LETTER I WITH GRAVE */
	0x00cb, /* LATIN CAPITAL LETTER E WITH DIAERESIS */
	0x00ca, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
	0x00c8, /* LATIN CAPITAL LETTER E WITH GRAVE */
	0x00c3, /* LATIN CAPITAL LETTER A WITH TILDE */
	0x00c2, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
	0x00c1, /* LATIN CAPITAL LETTER A WITH ACUTE */
	0x00c0, /* LATIN CAPITAL LETTER A WITH GRAVE */
	0x00b9, /* SUPERSCRIPT ONE */
	0x00b7, /* MIDDLE DOT */
	0x03b6, /* GREEK SMALL LETTER ZETA */
	0x00b3, /* SUPERSCRIPT THREE */
	0x00a9, /* COPYRIGHT SIGN */
	0x00a4, /* CURRENCY SIGN */
	0x03ba, /* GREEK SMALL LETTER KAPPA */
	_e000U
};

int vga_pcvt_mapchar __P((int, unsigned int *));

int
vga_pcvt_mapchar(uni, index)
	int uni;
	unsigned int *index;
d365 3
a367 10
	int i;

	for (i = 0; i < 0xa0; i++) /* 0xa0..0xff are reserved */
		if (uni == pcvt_unichars[i]) {
			*index = i;
			return (5);
		}
	*index = 0x99; /* middle dot */
	return (0);
}
d369 2
a370 1
#endif /* WSCONS_SUPPORT_PCVTFONTS */
d372 1
a372 1
int _vga_mapchar __P((void *, struct vgafont *, int, unsigned int *));
d374 1
a374 31
int
_vga_mapchar(id, font, uni, index)
	void *id;
	struct vgafont *font;
	int uni;
	unsigned int *index;
{

	switch (font->encoding) {
	case WSDISPLAY_FONTENC_ISO:
		if (uni < 256) {
			*index = uni;
			return (5);
		} else {
			*index = ' ';
			return (0);
		}
		break;
	case WSDISPLAY_FONTENC_IBM:
		return (pcdisplay_mapchar(id, uni, index));
#ifdef WSCONS_SUPPORT_PCVTFONTS
	case WSDISPLAY_FONTENC_PCVT:
		return (vga_pcvt_mapchar(uni, index));
#endif
	default:
#ifdef VGAFONTDEBUG
		printf("_vga_mapchar: encoding=%d\n", font->encoding);
#endif
		*index = ' ';
		return (0);
	}
d377 2
a378 2
int
vga_mapchar(id, uni, index)
d380 1
a380 2
	int uni;
	unsigned int *index;
d382 1
a382 33
	struct vgascreen *scr = id;
	unsigned int idx1, idx2;
	int res1, res2;

	res1 = 0;
	idx1 = ' '; /* space */
	if (scr->fontset1)
		res1 = _vga_mapchar(id, scr->fontset1, uni, &idx1);
	res2 = -1;
	if (scr->fontset2) {
		KASSERT(VGA_SCREEN_CANTWOFONTS(scr->pcs.type));
		res2 = _vga_mapchar(id, scr->fontset2, uni, &idx2);
	}
	if (res2 >= res1) {
		*index = idx2 | 0x0800; /* attribute bit 3 */
		return (res2);
	}
	*index = idx1;
	return (res1);
}

void
vga_putchar(c, row, col, uc, attr)
	void *c;
	int row;
	int col;
	u_int uc;
	long attr;
{
	struct vgascreen *scr = c;

	if (scr->pcs.visibleoffset != scr->pcs.dispoffset)
		vga_scrollback(scr->cfg, scr, 0);
d384 1
a384 1
	pcdisplay_putchar(c, row, col, uc, attr);
a385 14

u_int16_t
vga_getchar(c, row, col)
	void *c;
	int row, col;
{
	struct vga_config *vc = c;
	
	return (pcdisplay_getchar(vc->active, row, col));
}	

struct cfdriver vga_cd = {
	NULL, "vga", DV_DULL
};
@


1.12.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.12.8.1 2001/05/14 22:24:21 niklas Exp $ */
a30 2
#include "vga.h"

d33 1
d89 26
a114 3
int vgaconsole, vga_console_type, vga_console_attached;
struct vgascreen vga_console_screen;
struct vga_config vga_console_vc;
d117 6
a122 4
    const char *, const char *));
void	vga_init_screen __P((struct vga_config *, struct vgascreen *,
    const struct wsscreen_descr *, int, long *));
void	vga_init __P((struct vga_config *, bus_space_tag_t, bus_space_tag_t));
d130 1
a130 1
static const struct wsdisplay_emulops vga_emulops = {
a247 1
void	vga_burner __P((void *v, u_int on, u_int flags));
d260 1
a260 2
	vga_getchar,
	vga_burner
d544 1
a544 3
		vc = malloc(sizeof(struct vga_config), M_DEVBUF, M_NOWAIT);
		if (vc == NULL)
			return;
a548 1
	vc->vc_softc = self;
a612 7
	int error;

#if NVGA_PCI > 0
	if (vc->vc_type == WSDISPLAY_TYPE_PCIVGA &&
	    (error = vga_pci_ioctl(v, cmd, data, flag, p)) != ENOTTY)
		return (error);
#endif
a1253 29
}

void
vga_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct vga_config *vc = v;
	struct vga_handle *vh = &vc->hdl;
	u_int8_t r;
	int s;

	s = splhigh();
	vga_ts_write(vh, syncreset, 0x01);
	if (on) {
		vga_ts_write(vh, mode, (vga_ts_read(vh, mode) & ~0x20));
		r = vga_6845_read(vh, mode) | 0x80;
		DELAY(10000);
		vga_6845_write(vh, mode, r);
	} else {
		vga_ts_write(vh, mode, (vga_ts_read(vh, mode) | 0x20));
		if (flags & WSDISPLAY_BURN_VBLANK) {
			r = vga_6845_read(vh, mode) & ~0x80;
			DELAY(10000);
			vga_6845_write(vh, mode, r);
		}
	}
	vga_ts_write(vh, syncreset, 0x03);
	splx(s);
@


1.12.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.12.8.2 2001/07/04 10:41:16 niklas Exp $ */
a593 1
#if NVGA_PCI > 0
d596 1
@


1.12.8.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d94 11
a104 11
int	vga_selectfont(struct vga_config *, struct vgascreen *,
    const char *, const char *);
void	vga_init_screen(struct vga_config *, struct vgascreen *,
    const struct wsscreen_descr *, int, long *);
void	vga_init(struct vga_config *, bus_space_tag_t, bus_space_tag_t);
void	vga_setfont(struct vga_config *, struct vgascreen *);

int	vga_mapchar(void *, int, unsigned int *);
void	vga_putchar(void *, int, int, u_int, long);
int	vga_alloc_attr(void *, int, int, int, long *);
void	vga_copyrows(void *, int, int, int);
d215 11
a225 11
int	vga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	vga_mmap(void *, off_t, int);
int	vga_alloc_screen(void *, const struct wsscreen_descr *,
			 void **, int *, int *, long *);
void	vga_free_screen(void *, void *);
int	vga_show_screen(void *, void *, int,
			void (*) (void *, int, int), void *);
int	vga_load_font(void *, void *, struct wsdisplay_font *);
void	vga_scrollback(void *, void *, int);
void	vga_burner(void *v, u_int on, u_int flags);
u_int16_t vga_getchar(void *, int, int);
d227 1
a227 1
void vga_doswitch(struct vga_config *);
d509 1
a509 1
	int (*map)(void *, vaddr_t, int);
d724 1
a724 1
	void (*cb)(void *, int, int);
d1146 1
a1146 1
int vga_pcvt_mapchar(int, unsigned int *);
d1166 1
a1166 1
int _vga_mapchar(void *, struct vgafont *, int, unsigned int *);
@


1.12.8.5
log
@Sync the SMP branch with 3.3
@
text
@d500 1
d509 1
a509 1
	paddr_t (*map)(void *, off_t, int);
d511 1
d531 1
d533 1
d631 2
d637 3
a639 1

@


1.12.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vga.c,v 1.12.8.5 2003/03/28 00:38:15 niklas Exp $ */
d862 1
a862 1
	strlcpy(f->name, data->name, sizeof(f->name));
@


1.12.8.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d826 5
a830 6
		if ((name2 = data->name) != NULL) {
			while (*name2 && *name2 != ',')
				name2++;
			if (*name2)
				*name2++ = '\0';
		}
@


1.11
log
@Add some missing things for the MI vga driver.  Move wscons to an MI place as
well.  $OpenBSD$ tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.10 1997/11/06 03:38:44 mickey Exp $	*/
d255 2
@


1.10
log
@temp <machine_btop() fix
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.9 1997/11/06 02:53:41 niklas Exp $	*/
d37 1
a37 1
#include <alpha/wscons/wsconsvar.h>
@


1.9
log
@We need an MI vga driver.  The alpha one was most MI.  Not entirely yet though.
Some files were move behind CVS back.
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.8 1997/08/25 08:26:43 deraadt Exp $	*/
d251 1
d253 3
@


1.8
log
@better mmap support, what fun
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.7 1997/08/22 22:25:59 deraadt Exp $	*/
d38 1
a38 1
#include <alpha/dev/vgavar.h>
d251 1
a251 1
	return alpha_btop(port);
@


1.7
log
@wscons -> vga_xxx -> vga mmap() support. first cut
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.6 1997/07/31 13:40:01 kstailey Exp $	*/
d236 2
d239 13
a251 11
	if (offset >= 0xb8000 && offset < 0xc0000) {
		printf("%p\n", alpha_btop(ALPHA_K0SEG_TO_PHYS(vc->vc_memh) + offset - 0xb8000));
		return alpha_btop(ALPHA_K0SEG_TO_PHYS(vc->vc_memh) + offset - 0xb8000);
	}
	if (offset >= 0x0000 && offset < 0x2000)
		return alpha_btop(ALPHA_K0SEG_TO_PHYS(vc->vc_ioh_b));
	if (offset >= 0x2000 && offset < 0x4000)
		return alpha_btop(ALPHA_K0SEG_TO_PHYS(vc->vc_ioh_c));
	if (offset >= 0x4000 && offset < 0x6000)
		return alpha_btop(ALPHA_K0SEG_TO_PHYS(vc->vc_ioh_d));
	return -1;
@


1.6
log
@text video attributes, tested only on vga, send me E-mail if it breaks something, thx.
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.5 1997/07/31 04:03:43 kstailey Exp $	*/
a65 2
int	vgaioctl __P((void *, u_long, caddr_t, int, struct proc *));
int	vgammap __P((void *, off_t, int));
d173 2
a174 2
        wo->wo_ioctl = vgaioctl;
        wo->wo_mmap = vgammap;
d223 2
d235 12
a246 1
	/* XXX */
@


1.5
log
@bus_space_copy_2() is now overlap safe
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.2 1997/07/09 03:07:39 deraadt Exp $	*/
d53 1
d62 1
d354 10
@


1.4
log
@fix vga_copycols(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.3 1997/07/10 04:25:57 kstailey Exp $	*/
a222 1

a232 1

a290 2
/* be careful not to call bus_space_copy_2() with overlapping regions */

d302 2
a303 13
	if (ncols == 0 || srccol == dstcol)
		return;

	if (srccol < dstcol && srccol + ncols > dstcol) {
		int scol, dcol;

		for (scol = srccol + ncols - 1, dcol = dstcol + ncols - 1;
		     scol >= srccol; scol--, dcol--) {
			vga_copycols(id, row, scol, dcol, 1);
		}
	} else
		bus_space_copy_2(vc->vc_memt, vc->vc_memh, srcoff, vc->vc_memh,
		    dstoff, ncols);
a321 2
/* be careful not to call bus_space_copy_2() with overlapping regions */

d333 2
a334 13
	if (nrows == 0 || srcrow == dstrow)
		return;

	if (srcrow < dstrow && srcrow + nrows > dstrow) {
		int srow, drow;

		for (srow = srcrow + nrows - 1, drow = dstrow + nrows - 1;
		     srow >= srcrow; srow--, drow--) {
			vga_copyrows(id, srow, drow, 1);
		}
	} else
		bus_space_copy_2(vc->vc_memt, vc->vc_memh, srcoff,
			 vc->vc_memh, dstoff, nrows * vc->vc_ncol);
@


1.3
log
@fix backward scrolling
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.2 1997/07/09 03:07:39 deraadt Exp $	*/
d293 2
d306 13
a318 3
	/* XXX SHOULDN'T USE THIS IF REGIONS OVERLAP... */
	bus_space_copy_2(vc->vc_memt, vc->vc_memh, srcoff, vc->vc_memh, dstoff,
	    ncols);
@


1.2
log
@argh
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.1 1997/07/09 02:58:35 deraadt Exp $	*/
d325 2
d338 13
a350 3
	/* XXX SHOULDN'T USE THIS IF REGIONS OVERLAP... */
	bus_space_copy_2(vc->vc_memt, vc->vc_memh, srcoff, vc->vc_memh, dstoff,
	    nrows * vc->vc_ncol);
@


1.1
log
@alpha/common/ insults my filec
@
text
@d1 1
a1 1
/*	$OpenBSD: vga.c,v 1.3 1997/07/06 16:13:19 niklas Exp $	*/
d38 1
a38 1
#include <alpha/common/vgavar.h>
@
